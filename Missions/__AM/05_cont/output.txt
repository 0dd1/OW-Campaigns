// export you , you2 , russians , arabians , neutral ; export apemans , apemans_amount_on_start ; export oma ; export om ; export arabs_cars ; export JMM ; export Glad ; export Har ; export Den , Lisa , Frank ; export Don , Brown ; export Bobby , Cyrus ; export Denis ; export Sol1 , Sol2 , Sci ; export Car1 , Car2 , Car3 ; export CameFromXY ; export map_size_x , map_size_y ; export first_ape ; export was_first_attack ; export away_from_last_attack ; export first_attack ; export mine_attack ; export thief_attack ; export lonely_attack ; export next_attack ; export attacking ; export attacky ; export opic ; export cil_mit_1_ape_eng_splnen ; export cil_mit_5_ape_eng_splnen ; export zasilka_muze ; export zasilka_landed ; export denis_can_come ; export RadarBuild ; export tvoji_lidi ; export not_char ; export opicaci ; export ztraty ; export uz_je_cas ; export added_apes ; export max_added_apes ; export mat_crates ; export all , used , other ; export Gamma2Commander ; starting begin map_size_x := 100 ;
   0: LD_ADDR_EXP 29
   4: PUSH
   5: LD_INT 100
   7: ST_TO_ADDR
// map_size_y := 80 ;
   8: LD_ADDR_EXP 30
  12: PUSH
  13: LD_INT 80
  15: ST_TO_ADDR
// prepare_sides ;
  16: CALL 980 0 0
// prepare_yours_cars ;
  20: CALL 299 0 0
// load_units ;
  24: CALL 481 0 0
// SetDifficulty ;
  28: CALL 1048 0 0
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
  32: LD_ADDR_EXP 6
  36: PUSH
  37: LD_INT 23
  39: PUSH
  40: LD_INT 0
  42: PUSH
  43: EMPTY
  44: LIST
  45: LIST
  46: PUSH
  47: EMPTY
  48: LIST
  49: PPUSH
  50: CALL_OW 69
  54: ST_TO_ADDR
// apemans_amount_on_start := ( apemans + 0 ) ;
  55: LD_ADDR_EXP 7
  59: PUSH
  60: LD_EXP 6
  64: PUSH
  65: LD_INT 0
  67: PLUS
  68: ST_TO_ADDR
// was_first_attack := false ;
  69: LD_ADDR_EXP 32
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// first_attack := false ;
  77: LD_ADDR_EXP 34
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// mine_attack := false ;
  85: LD_ADDR_EXP 35
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// thief_attack := false ;
  93: LD_ADDR_EXP 36
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// lonely_attack := false ;
 101: LD_ADDR_EXP 37
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// next_attack := false ;
 109: LD_ADDR_EXP 38
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// attacking := false ;
 117: LD_ADDR_EXP 39
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// attacky := 0 ;
 125: LD_ADDR_EXP 40
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// CameFromXY := [ [ 110 , 31 ] , [ 106 , 23 ] , [ 123 , 74 ] , [ 120 , 74 ] , [ 74 , 6 ] , [ 83 , 75 ] , [ 39 , 4 ] ] ;
 133: LD_ADDR_EXP 28
 137: PUSH
 138: LD_INT 110
 140: PUSH
 141: LD_INT 31
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: PUSH
 148: LD_INT 106
 150: PUSH
 151: LD_INT 23
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: PUSH
 158: LD_INT 123
 160: PUSH
 161: LD_INT 74
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: PUSH
 168: LD_INT 120
 170: PUSH
 171: LD_INT 74
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 74
 180: PUSH
 181: LD_INT 6
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 83
 190: PUSH
 191: LD_INT 75
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: PUSH
 198: LD_INT 39
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: PUSH
 208: EMPTY
 209: LIST
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: LIST
 215: LIST
 216: ST_TO_ADDR
// opic := 0 ;
 217: LD_ADDR_EXP 41
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// zasilka_muze := false ;
 225: LD_ADDR_EXP 44
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// denis_can_come := false ;
 233: LD_ADDR_EXP 46
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// budovy := [ ] ;
 241: LD_ADDR_EXP 64
 245: PUSH
 246: EMPTY
 247: ST_TO_ADDR
// laboratore := [ ] ;
 248: LD_ADDR_EXP 63
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// tvoji_lidi := [ ] ;
 255: LD_ADDR_EXP 48
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// ztraty := 0 ;
 262: LD_ADDR_EXP 51
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// added_apes := 0 ;
 270: LD_ADDR_EXP 53
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// max_added_apes := 10 ;
 278: LD_ADDR_EXP 54
 282: PUSH
 283: LD_INT 10
 285: ST_TO_ADDR
// uz_je_cas := false ;
 286: LD_ADDR_EXP 52
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// Dialog1 ;
 294: CALL 3387 0 0
// end ;
 298: END
// function prepare_yours_cars ; begin
 299: LD_INT 0
 301: PPUSH
// InitUc ;
 302: CALL_OW 18
// InitHc ;
 306: CALL_OW 19
// InitVc ;
 310: CALL_OW 20
// uc_side := you ;
 314: LD_ADDR_OWVAR 20
 318: PUSH
 319: LD_EXP 1
 323: ST_TO_ADDR
// uc_nation := nation_american ;
 324: LD_ADDR_OWVAR 21
 328: PUSH
 329: LD_INT 1
 331: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 332: LD_ADDR_OWVAR 37
 336: PUSH
 337: LD_INT 1
 339: ST_TO_ADDR
// vc_control := control_manual ;
 340: LD_ADDR_OWVAR 38
 344: PUSH
 345: LD_INT 1
 347: ST_TO_ADDR
// vc_engine := engine_solar ;
 348: LD_ADDR_OWVAR 39
 352: PUSH
 353: LD_INT 2
 355: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 356: LD_ADDR_OWVAR 40
 360: PUSH
 361: LD_INT 2
 363: ST_TO_ADDR
// Car1 := CreateVehicle ;
 364: LD_ADDR_EXP 25
 368: PUSH
 369: CALL_OW 45
 373: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 374: LD_ADDR_OWVAR 37
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// vc_control := control_manual ;
 382: LD_ADDR_OWVAR 38
 386: PUSH
 387: LD_INT 1
 389: ST_TO_ADDR
// vc_engine := engine_solar ;
 390: LD_ADDR_OWVAR 39
 394: PUSH
 395: LD_INT 2
 397: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 398: LD_ADDR_OWVAR 40
 402: PUSH
 403: LD_INT 2
 405: ST_TO_ADDR
// Car2 := CreateVehicle ;
 406: LD_ADDR_EXP 26
 410: PUSH
 411: CALL_OW 45
 415: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
 416: LD_ADDR_OWVAR 37
 420: PUSH
 421: LD_INT 2
 423: ST_TO_ADDR
// vc_control := control_manual ;
 424: LD_ADDR_OWVAR 38
 428: PUSH
 429: LD_INT 1
 431: ST_TO_ADDR
// vc_engine := engine_solar ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_INT 2
 439: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
 440: LD_ADDR_OWVAR 40
 444: PUSH
 445: LD_INT 12
 447: ST_TO_ADDR
// Car3 := CreateVehicle ;
 448: LD_ADDR_EXP 27
 452: PUSH
 453: CALL_OW 45
 457: ST_TO_ADDR
// SetCargo ( [ Car3 ] , mat_cans , 100 ) ;
 458: LD_EXP 27
 462: PUSH
 463: EMPTY
 464: LIST
 465: PPUSH
 466: LD_INT 1
 468: PPUSH
 469: LD_INT 100
 471: PPUSH
 472: CALL_OW 290
// end ;
 476: LD_VAR 0 1
 480: RET
// function load_units ; begin
 481: LD_INT 0
 483: PPUSH
// InitUc ;
 484: CALL_OW 18
// InitHc ;
 488: CALL_OW 19
// InitVc ;
 492: CALL_OW 20
// uc_side := you ;
 496: LD_ADDR_OWVAR 20
 500: PUSH
 501: LD_EXP 1
 505: ST_TO_ADDR
// uc_nation := nation_american ;
 506: LD_ADDR_OWVAR 21
 510: PUSH
 511: LD_INT 1
 513: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 514: LD_ADDR_EXP 11
 518: PUSH
 519: LD_STRING JMM
 521: PPUSH
 522: CALL_OW 34
 526: ST_TO_ADDR
// Glad := CreateCharacter ( Gladstone ) ;
 527: LD_ADDR_EXP 12
 531: PUSH
 532: LD_STRING Gladstone
 534: PPUSH
 535: CALL_OW 34
 539: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 540: LD_ADDR_EXP 13
 544: PUSH
 545: LD_STRING Harisson
 547: PPUSH
 548: CALL_OW 25
 552: ST_TO_ADDR
// Denis := NewCharacter ( Denis ) ;
 553: LD_ADDR_EXP 21
 557: PUSH
 558: LD_STRING Denis
 560: PPUSH
 561: CALL_OW 25
 565: ST_TO_ADDR
// if TestCharacters ( otherDelta ) then
 566: LD_STRING otherDelta
 568: PPUSH
 569: CALL_OW 28
 573: IFFALSE 590
// used := CreateCharacterSet ( otherDelta ) else
 575: LD_ADDR_EXP 57
 579: PUSH
 580: LD_STRING otherDelta
 582: PPUSH
 583: CALL_OW 31
 587: ST_TO_ADDR
 588: GO 597
// used := [ ] ;
 590: LD_ADDR_EXP 57
 594: PUSH
 595: EMPTY
 596: ST_TO_ADDR
// Lisa := 0 ;
 597: LD_ADDR_EXP 15
 601: PUSH
 602: LD_INT 0
 604: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 605: LD_STRING Lisa
 607: PPUSH
 608: CALL_OW 29
 612: IFFALSE 643
// if LoadVariable ( LisaLoc , 0 ) = 3 then
 614: LD_STRING LisaLoc
 616: PPUSH
 617: LD_INT 0
 619: PPUSH
 620: CALL_OW 30
 624: PUSH
 625: LD_INT 3
 627: EQUAL
 628: IFFALSE 643
// Lisa := CreateCharacter ( Lisa ) ;
 630: LD_ADDR_EXP 15
 634: PUSH
 635: LD_STRING Lisa
 637: PPUSH
 638: CALL_OW 34
 642: ST_TO_ADDR
// Cyrus := 0 ;
 643: LD_ADDR_EXP 20
 647: PUSH
 648: LD_INT 0
 650: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 651: LD_STRING Cyrus
 653: PPUSH
 654: CALL_OW 29
 658: IFFALSE 689
// if LoadVariable ( CyrusLoc , 0 ) = 3 then
 660: LD_STRING CyrusLoc
 662: PPUSH
 663: LD_INT 0
 665: PPUSH
 666: CALL_OW 30
 670: PUSH
 671: LD_INT 3
 673: EQUAL
 674: IFFALSE 689
// Cyrus := CreateCharacter ( Cyrus ) ;
 676: LD_ADDR_EXP 20
 680: PUSH
 681: LD_STRING Cyrus
 683: PPUSH
 684: CALL_OW 34
 688: ST_TO_ADDR
// Bobby := 0 ;
 689: LD_ADDR_EXP 19
 693: PUSH
 694: LD_INT 0
 696: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 697: LD_STRING Bobby
 699: PPUSH
 700: CALL_OW 29
 704: IFFALSE 735
// if LoadVariable ( BobbyLoc , 0 ) = 3 then
 706: LD_STRING BobbyLoc
 708: PPUSH
 709: LD_INT 0
 711: PPUSH
 712: CALL_OW 30
 716: PUSH
 717: LD_INT 3
 719: EQUAL
 720: IFFALSE 735
// Bobby := CreateCharacter ( Bobby ) ;
 722: LD_ADDR_EXP 19
 726: PUSH
 727: LD_STRING Bobby
 729: PPUSH
 730: CALL_OW 34
 734: ST_TO_ADDR
// Frank := 0 ;
 735: LD_ADDR_EXP 16
 739: PUSH
 740: LD_INT 0
 742: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 743: LD_STRING Frank
 745: PPUSH
 746: CALL_OW 29
 750: IFFALSE 781
// if LoadVariable ( FrankLoc , 0 ) = 3 then
 752: LD_STRING FrankLoc
 754: PPUSH
 755: LD_INT 0
 757: PPUSH
 758: CALL_OW 30
 762: PUSH
 763: LD_INT 3
 765: EQUAL
 766: IFFALSE 781
// Frank := CreateCharacter ( Frank ) ;
 768: LD_ADDR_EXP 16
 772: PUSH
 773: LD_STRING Frank
 775: PPUSH
 776: CALL_OW 34
 780: ST_TO_ADDR
// Don := 0 ;
 781: LD_ADDR_EXP 17
 785: PUSH
 786: LD_INT 0
 788: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 789: LD_STRING Donaldson
 791: PPUSH
 792: CALL_OW 29
 796: IFFALSE 827
// if LoadVariable ( DonaldsonLoc , 0 ) = 3 then
 798: LD_STRING DonaldsonLoc
 800: PPUSH
 801: LD_INT 0
 803: PPUSH
 804: CALL_OW 30
 808: PUSH
 809: LD_INT 3
 811: EQUAL
 812: IFFALSE 827
// Don := CreateCharacter ( Donaldson ) ;
 814: LD_ADDR_EXP 17
 818: PUSH
 819: LD_STRING Donaldson
 821: PPUSH
 822: CALL_OW 34
 826: ST_TO_ADDR
// Brown := 0 ;
 827: LD_ADDR_EXP 18
 831: PUSH
 832: LD_INT 0
 834: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 835: LD_STRING Brown
 837: PPUSH
 838: CALL_OW 29
 842: IFFALSE 873
// if LoadVariable ( BrownLoc , 0 ) = 3 then
 844: LD_STRING BrownLoc
 846: PPUSH
 847: LD_INT 0
 849: PPUSH
 850: CALL_OW 30
 854: PUSH
 855: LD_INT 3
 857: EQUAL
 858: IFFALSE 873
// Brown := CreateCharacter ( Brown ) ;
 860: LD_ADDR_EXP 18
 864: PUSH
 865: LD_STRING Brown
 867: PPUSH
 868: CALL_OW 34
 872: ST_TO_ADDR
// used := ( [ JMM , Glad , Lisa , Cyrus , Bobby , Frank , Don , Brown ] diff [ 0 ] ) ^ used ;
 873: LD_ADDR_EXP 57
 877: PUSH
 878: LD_EXP 11
 882: PUSH
 883: LD_EXP 12
 887: PUSH
 888: LD_EXP 15
 892: PUSH
 893: LD_EXP 20
 897: PUSH
 898: LD_EXP 19
 902: PUSH
 903: LD_EXP 16
 907: PUSH
 908: LD_EXP 17
 912: PUSH
 913: LD_EXP 18
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: LD_INT 0
 930: PUSH
 931: EMPTY
 932: LIST
 933: DIFF
 934: PUSH
 935: LD_EXP 57
 939: ADD
 940: ST_TO_ADDR
// if not UnitFilter ( used , [ f_class , class_engineer ] ) then
 941: LD_EXP 57
 945: PPUSH
 946: LD_INT 25
 948: PUSH
 949: LD_INT 2
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PPUSH
 956: CALL_OW 72
 960: NOT
 961: IFFALSE 975
// SetClass ( JMM , class_engineer ) ;
 963: LD_EXP 11
 967: PPUSH
 968: LD_INT 2
 970: PPUSH
 971: CALL_OW 336
// end ;
 975: LD_VAR 0 1
 979: RET
// function prepare_sides ; begin
 980: LD_INT 0
 982: PPUSH
// you := 1 ;
 983: LD_ADDR_EXP 1
 987: PUSH
 988: LD_INT 1
 990: ST_TO_ADDR
// you2 := 4 ;
 991: LD_ADDR_EXP 2
 995: PUSH
 996: LD_INT 4
 998: ST_TO_ADDR
// arabians := 2 ;
 999: LD_ADDR_EXP 4
1003: PUSH
1004: LD_INT 2
1006: ST_TO_ADDR
// russians := 3 ;
1007: LD_ADDR_EXP 3
1011: PUSH
1012: LD_INT 3
1014: ST_TO_ADDR
// neutral := 0 ;
1015: LD_ADDR_EXP 5
1019: PUSH
1020: LD_INT 0
1022: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
1023: LD_EXP 4
1027: PPUSH
1028: LD_EXP 1
1032: PPUSH
1033: LD_INT 2
1035: PPUSH
1036: LD_INT 1
1038: PPUSH
1039: CALL_OW 80
// end ;
1043: LD_VAR 0 1
1047: RET
// export wait_first_attack ; export utoku ; function SetDifficulty ; begin
1048: LD_INT 0
1050: PPUSH
// wait_first_attack := [ 1 1$20 , 0 0$50 , 0 0$35 ] [ difficulty ] ;
1051: LD_ADDR_EXP 60
1055: PUSH
1056: LD_INT 2800
1058: PUSH
1059: LD_INT 1750
1061: PUSH
1062: LD_INT 1225
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_OWVAR 67
1074: ARRAY
1075: ST_TO_ADDR
// utoku := [ 9 , 12 , 19 ] [ difficulty ] ;
1076: LD_ADDR_EXP 61
1080: PUSH
1081: LD_INT 9
1083: PUSH
1084: LD_INT 12
1086: PUSH
1087: LD_INT 19
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: PUSH
1095: LD_OWVAR 67
1099: ARRAY
1100: ST_TO_ADDR
// end ;
1101: LD_VAR 0 1
1105: RET
// export function make_arabs ( pocet , unitclass ) ; var list , arab , d ; begin
1106: LD_INT 0
1108: PPUSH
1109: PPUSH
1110: PPUSH
1111: PPUSH
// InitUc ;
1112: CALL_OW 18
// InitHc ;
1116: CALL_OW 19
// uc_side := arabians ;
1120: LD_ADDR_OWVAR 20
1124: PUSH
1125: LD_EXP 4
1129: ST_TO_ADDR
// uc_nation := nation_arabian ;
1130: LD_ADDR_OWVAR 21
1134: PUSH
1135: LD_INT 2
1137: ST_TO_ADDR
// d := difficulty - 1 ;
1138: LD_ADDR_VAR 0 6
1142: PUSH
1143: LD_OWVAR 67
1147: PUSH
1148: LD_INT 1
1150: MINUS
1151: ST_TO_ADDR
// while pocet > 0 do
1152: LD_VAR 0 1
1156: PUSH
1157: LD_INT 0
1159: GREATER
1160: IFFALSE 1804
// begin hc_class := unitclass ;
1162: LD_ADDR_OWVAR 28
1166: PUSH
1167: LD_VAR 0 2
1171: ST_TO_ADDR
// if Rand ( 1 , 10 ) >= 4 then
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL_OW 12
1182: PUSH
1183: LD_INT 4
1185: GREATEREQUAL
1186: IFFALSE 1198
// hc_sex := sex_female else
1188: LD_ADDR_OWVAR 27
1192: PUSH
1193: LD_INT 2
1195: ST_TO_ADDR
1196: GO 1206
// hc_sex := sex_male ;
1198: LD_ADDR_OWVAR 27
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// case unitclass of class_soldier :
1206: LD_VAR 0 2
1210: PUSH
1211: LD_INT 1
1213: DOUBLE
1214: EQUAL
1215: IFTRUE 1219
1217: GO 1344
1219: POP
// begin hc_attr := [ Rand ( 8 , 10 ) + d , Rand ( 8 , 10 ) + d ] ;
1220: LD_ADDR_OWVAR 29
1224: PUSH
1225: LD_INT 8
1227: PPUSH
1228: LD_INT 10
1230: PPUSH
1231: CALL_OW 12
1235: PUSH
1236: LD_VAR 0 6
1240: PLUS
1241: PUSH
1242: LD_INT 8
1244: PPUSH
1245: LD_INT 10
1247: PPUSH
1248: CALL_OW 12
1252: PUSH
1253: LD_VAR 0 6
1257: PLUS
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1263: LD_ADDR_OWVAR 31
1267: PUSH
1268: LD_INT 2
1270: PPUSH
1271: LD_INT 3
1273: PPUSH
1274: CALL_OW 12
1278: PUSH
1279: LD_VAR 0 6
1283: PLUS
1284: PUSH
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: CALL_OW 12
1295: PUSH
1296: LD_VAR 0 6
1300: PLUS
1301: PUSH
1302: LD_INT 0
1304: PPUSH
1305: LD_INT 1
1307: PPUSH
1308: CALL_OW 12
1312: PUSH
1313: LD_VAR 0 6
1317: PLUS
1318: PUSH
1319: LD_INT 0
1321: PPUSH
1322: LD_INT 0
1324: PPUSH
1325: CALL_OW 12
1329: PUSH
1330: LD_VAR 0 6
1334: PLUS
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: ST_TO_ADDR
// end ; class_engineer :
1342: GO 1744
1344: LD_INT 2
1346: DOUBLE
1347: EQUAL
1348: IFTRUE 1352
1350: GO 1477
1352: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1353: LD_ADDR_OWVAR 29
1357: PUSH
1358: LD_INT 8
1360: PPUSH
1361: LD_INT 9
1363: PPUSH
1364: CALL_OW 12
1368: PUSH
1369: LD_VAR 0 6
1373: PLUS
1374: PUSH
1375: LD_INT 8
1377: PPUSH
1378: LD_INT 9
1380: PPUSH
1381: CALL_OW 12
1385: PUSH
1386: LD_VAR 0 6
1390: PLUS
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1396: LD_ADDR_OWVAR 31
1400: PUSH
1401: LD_INT 0
1403: PPUSH
1404: LD_INT 1
1406: PPUSH
1407: CALL_OW 12
1411: PUSH
1412: LD_VAR 0 6
1416: PLUS
1417: PUSH
1418: LD_INT 2
1420: PPUSH
1421: LD_INT 3
1423: PPUSH
1424: CALL_OW 12
1428: PUSH
1429: LD_VAR 0 6
1433: PLUS
1434: PUSH
1435: LD_INT 0
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: CALL_OW 12
1445: PUSH
1446: LD_VAR 0 6
1450: PLUS
1451: PUSH
1452: LD_INT 0
1454: PPUSH
1455: LD_INT 0
1457: PPUSH
1458: CALL_OW 12
1462: PUSH
1463: LD_VAR 0 6
1467: PLUS
1468: PUSH
1469: EMPTY
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: ST_TO_ADDR
// end ; class_mechanic :
1475: GO 1744
1477: LD_INT 3
1479: DOUBLE
1480: EQUAL
1481: IFTRUE 1485
1483: GO 1610
1485: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1486: LD_ADDR_OWVAR 29
1490: PUSH
1491: LD_INT 8
1493: PPUSH
1494: LD_INT 9
1496: PPUSH
1497: CALL_OW 12
1501: PUSH
1502: LD_VAR 0 6
1506: PLUS
1507: PUSH
1508: LD_INT 8
1510: PPUSH
1511: LD_INT 9
1513: PPUSH
1514: CALL_OW 12
1518: PUSH
1519: LD_VAR 0 6
1523: PLUS
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 0 ) + d , Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 0 ) + d ] ;
1529: LD_ADDR_OWVAR 31
1533: PUSH
1534: LD_INT 0
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 12
1544: PUSH
1545: LD_VAR 0 6
1549: PLUS
1550: PUSH
1551: LD_INT 0
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL_OW 12
1561: PUSH
1562: LD_VAR 0 6
1566: PLUS
1567: PUSH
1568: LD_INT 2
1570: PPUSH
1571: LD_INT 3
1573: PPUSH
1574: CALL_OW 12
1578: PUSH
1579: LD_VAR 0 6
1583: PLUS
1584: PUSH
1585: LD_INT 0
1587: PPUSH
1588: LD_INT 0
1590: PPUSH
1591: CALL_OW 12
1595: PUSH
1596: LD_VAR 0 6
1600: PLUS
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: ST_TO_ADDR
// end ; class_scientistic :
1608: GO 1744
1610: LD_INT 4
1612: DOUBLE
1613: EQUAL
1614: IFTRUE 1618
1616: GO 1743
1618: POP
// begin hc_attr := [ Rand ( 8 , 8 ) + d , Rand ( 8 , 8 ) + d ] ;
1619: LD_ADDR_OWVAR 29
1623: PUSH
1624: LD_INT 8
1626: PPUSH
1627: LD_INT 8
1629: PPUSH
1630: CALL_OW 12
1634: PUSH
1635: LD_VAR 0 6
1639: PLUS
1640: PUSH
1641: LD_INT 8
1643: PPUSH
1644: LD_INT 8
1646: PPUSH
1647: CALL_OW 12
1651: PUSH
1652: LD_VAR 0 6
1656: PLUS
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 1 , 2 ) + d , Rand ( 2 , 3 ) + d ] ;
1662: LD_ADDR_OWVAR 31
1666: PUSH
1667: LD_INT 0
1669: PPUSH
1670: LD_INT 1
1672: PPUSH
1673: CALL_OW 12
1677: PUSH
1678: LD_VAR 0 6
1682: PLUS
1683: PUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_INT 1
1689: PPUSH
1690: CALL_OW 12
1694: PUSH
1695: LD_VAR 0 6
1699: PLUS
1700: PUSH
1701: LD_INT 1
1703: PPUSH
1704: LD_INT 2
1706: PPUSH
1707: CALL_OW 12
1711: PUSH
1712: LD_VAR 0 6
1716: PLUS
1717: PUSH
1718: LD_INT 2
1720: PPUSH
1721: LD_INT 3
1723: PPUSH
1724: CALL_OW 12
1728: PUSH
1729: LD_VAR 0 6
1733: PLUS
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// end ; end ;
1741: GO 1744
1743: POP
// arab := CreateHuman ;
1744: LD_ADDR_VAR 0 5
1748: PUSH
1749: CALL_OW 44
1753: ST_TO_ADDR
// if list then
1754: LD_VAR 0 4
1758: IFFALSE 1778
// list := list ^ arab else
1760: LD_ADDR_VAR 0 4
1764: PUSH
1765: LD_VAR 0 4
1769: PUSH
1770: LD_VAR 0 5
1774: ADD
1775: ST_TO_ADDR
1776: GO 1788
// list := arab ;
1778: LD_ADDR_VAR 0 4
1782: PUSH
1783: LD_VAR 0 5
1787: ST_TO_ADDR
// pocet := pocet - 1 ;
1788: LD_ADDR_VAR 0 1
1792: PUSH
1793: LD_VAR 0 1
1797: PUSH
1798: LD_INT 1
1800: MINUS
1801: ST_TO_ADDR
// end ;
1802: GO 1152
// result := list ;
1804: LD_ADDR_VAR 0 3
1808: PUSH
1809: LD_VAR 0 4
1813: ST_TO_ADDR
// end ;
1814: LD_VAR 0 3
1818: RET
// every 0 0$2 trigger not cil_mit_1_ape_eng_splnen and UnitFilter ( apemans , [ f_side , neutral ] ) + ( max_added_apes - added_apes ) < ( 2 - opic ) do
1819: LD_EXP 42
1823: NOT
1824: PUSH
1825: LD_EXP 6
1829: PPUSH
1830: LD_INT 22
1832: PUSH
1833: LD_EXP 5
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PPUSH
1842: CALL_OW 72
1846: PUSH
1847: LD_EXP 54
1851: PUSH
1852: LD_EXP 53
1856: MINUS
1857: PLUS
1858: PUSH
1859: LD_INT 2
1861: PUSH
1862: LD_EXP 41
1866: MINUS
1867: LESS
1868: AND
1869: IFFALSE 1884
1871: GO 1873
1873: DISABLE
// begin disable ( 0 ) ;
1874: LD_INT 0
1876: DISABLE_MARKED
// YouLost ( Apeman ) ;
1877: LD_STRING Apeman
1879: PPUSH
1880: CALL_OW 104
// end ;
1884: END
// every 0 0$2 trigger not GetTech ( tech_ApePsych , you ) = state_researched and not laboratore and KolikCrates < 20 and mat_crates = 3 do
1885: LD_INT 2
1887: PPUSH
1888: LD_EXP 1
1892: PPUSH
1893: CALL_OW 321
1897: PUSH
1898: LD_INT 2
1900: EQUAL
1901: NOT
1902: PUSH
1903: LD_EXP 63
1907: NOT
1908: AND
1909: PUSH
1910: CALL 3138 0 0
1914: PUSH
1915: LD_INT 20
1917: LESS
1918: AND
1919: PUSH
1920: LD_EXP 55
1924: PUSH
1925: LD_INT 3
1927: EQUAL
1928: AND
1929: IFFALSE 1944
1931: GO 1933
1933: DISABLE
// begin disable ( 0 ) ;
1934: LD_INT 0
1936: DISABLE_MARKED
// YouLost ( Resources ) ;
1937: LD_STRING Resources
1939: PPUSH
1940: CALL_OW 104
// end ;
1944: END
// every 0 0$10 trigger RadarBuild and cil_mit_5_ape_eng_splnen do
1945: LD_EXP 47
1949: PUSH
1950: LD_EXP 43
1954: AND
1955: IFFALSE 1971
1957: GO 1959
1959: DISABLE
// begin wait ( 0 0$8 ) ;
1960: LD_INT 280
1962: PPUSH
1963: CALL_OW 67
// Vyhra ;
1967: CALL 3263 0 0
// end ;
1971: END
// export function Save ; var Delta , tmp , t ; begin
1972: LD_INT 0
1974: PPUSH
1975: PPUSH
1976: PPUSH
1977: PPUSH
// SaveCharacters ( JMM , JMM ) ;
1978: LD_EXP 11
1982: PPUSH
1983: LD_STRING JMM
1985: PPUSH
1986: CALL_OW 38
// if Lisa then
1990: LD_EXP 15
1994: IFFALSE 2029
// begin SaveCharacters ( Lisa , Lisa ) ;
1996: LD_EXP 15
2000: PPUSH
2001: LD_STRING Lisa
2003: PPUSH
2004: CALL_OW 38
// if IsDead ( Lisa ) then
2008: LD_EXP 15
2012: PPUSH
2013: CALL_OW 301
2017: IFFALSE 2029
// SaveVariable ( 0 , LisaLoc ) ;
2019: LD_INT 0
2021: PPUSH
2022: LD_STRING LisaLoc
2024: PPUSH
2025: CALL_OW 39
// end ; if Frank then
2029: LD_EXP 16
2033: IFFALSE 2068
// begin SaveCharacters ( Frank , Frank ) ;
2035: LD_EXP 16
2039: PPUSH
2040: LD_STRING Frank
2042: PPUSH
2043: CALL_OW 38
// if IsDead ( Frank ) then
2047: LD_EXP 16
2051: PPUSH
2052: CALL_OW 301
2056: IFFALSE 2068
// SaveVariable ( 0 , FrankLoc ) ;
2058: LD_INT 0
2060: PPUSH
2061: LD_STRING FrankLoc
2063: PPUSH
2064: CALL_OW 39
// end ; if Don then
2068: LD_EXP 17
2072: IFFALSE 2107
// begin SaveCharacters ( Don , Donaldson ) ;
2074: LD_EXP 17
2078: PPUSH
2079: LD_STRING Donaldson
2081: PPUSH
2082: CALL_OW 38
// if IsDead ( Don ) then
2086: LD_EXP 17
2090: PPUSH
2091: CALL_OW 301
2095: IFFALSE 2107
// SaveVariable ( 0 , DonaldsonLoc ) ;
2097: LD_INT 0
2099: PPUSH
2100: LD_STRING DonaldsonLoc
2102: PPUSH
2103: CALL_OW 39
// end ; if Brown then
2107: LD_EXP 18
2111: IFFALSE 2146
// begin SaveCharacters ( Brown , Brown ) ;
2113: LD_EXP 18
2117: PPUSH
2118: LD_STRING Brown
2120: PPUSH
2121: CALL_OW 38
// if IsDead ( Brown ) then
2125: LD_EXP 18
2129: PPUSH
2130: CALL_OW 301
2134: IFFALSE 2146
// SaveVariable ( 0 , BrownLoc ) ;
2136: LD_INT 0
2138: PPUSH
2139: LD_STRING BrownLoc
2141: PPUSH
2142: CALL_OW 39
// end ; if Glad then
2146: LD_EXP 12
2150: IFFALSE 2197
// begin SaveCharacters ( Glad , Gladstone ) ;
2152: LD_EXP 12
2156: PPUSH
2157: LD_STRING Gladstone
2159: PPUSH
2160: CALL_OW 38
// if IsDead ( Glad ) then
2164: LD_EXP 12
2168: PPUSH
2169: CALL_OW 301
2173: IFFALSE 2187
// SaveVariable ( 0 , GladstoneLoc ) else
2175: LD_INT 0
2177: PPUSH
2178: LD_STRING GladstoneLoc
2180: PPUSH
2181: CALL_OW 39
2185: GO 2197
// SaveVariable ( 3 , GladstoneLoc ) ;
2187: LD_INT 3
2189: PPUSH
2190: LD_STRING GladstoneLoc
2192: PPUSH
2193: CALL_OW 39
// end ; if Denis then
2197: LD_EXP 21
2201: IFFALSE 2248
// begin SaveCharacters ( Den , Denis ) ;
2203: LD_EXP 14
2207: PPUSH
2208: LD_STRING Denis
2210: PPUSH
2211: CALL_OW 38
// if IsDead ( Den ) then
2215: LD_EXP 14
2219: PPUSH
2220: CALL_OW 301
2224: IFFALSE 2238
// SaveVariable ( 0 , DenisLoc ) else
2226: LD_INT 0
2228: PPUSH
2229: LD_STRING DenisLoc
2231: PPUSH
2232: CALL_OW 39
2236: GO 2248
// SaveVariable ( 3 , DenisLoc ) ;
2238: LD_INT 3
2240: PPUSH
2241: LD_STRING DenisLoc
2243: PPUSH
2244: CALL_OW 39
// end ; if Bobby then
2248: LD_EXP 19
2252: IFFALSE 2287
// begin SaveCharacters ( Bobby , Bobby ) ;
2254: LD_EXP 19
2258: PPUSH
2259: LD_STRING Bobby
2261: PPUSH
2262: CALL_OW 38
// if IsDead ( Bobby ) then
2266: LD_EXP 19
2270: PPUSH
2271: CALL_OW 301
2275: IFFALSE 2287
// SaveVariable ( 0 , BobbyLoc ) ;
2277: LD_INT 0
2279: PPUSH
2280: LD_STRING BobbyLoc
2282: PPUSH
2283: CALL_OW 39
// end ; if Cyrus then
2287: LD_EXP 20
2291: IFFALSE 2326
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2293: LD_EXP 20
2297: PPUSH
2298: LD_STRING Cyrus
2300: PPUSH
2301: CALL_OW 38
// if IsDead ( Cyrus ) then
2305: LD_EXP 20
2309: PPUSH
2310: CALL_OW 301
2314: IFFALSE 2326
// SaveVariable ( 0 , CyrusLoc ) ;
2316: LD_INT 0
2318: PPUSH
2319: LD_STRING CyrusLoc
2321: PPUSH
2322: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Don , Brown , Glad , Den , Bobby , Cyrus , 0 ] , otherDelta ) ;
2326: LD_INT 22
2328: PUSH
2329: LD_EXP 1
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PUSH
2338: LD_INT 21
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: PUSH
2348: LD_INT 23
2350: PUSH
2351: LD_INT 1
2353: PUSH
2354: EMPTY
2355: LIST
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: PPUSH
2363: CALL_OW 69
2367: PUSH
2368: LD_EXP 11
2372: PUSH
2373: LD_EXP 15
2377: PUSH
2378: LD_EXP 16
2382: PUSH
2383: LD_EXP 17
2387: PUSH
2388: LD_EXP 18
2392: PUSH
2393: LD_EXP 12
2397: PUSH
2398: LD_EXP 14
2402: PUSH
2403: LD_EXP 19
2407: PUSH
2408: LD_EXP 20
2412: PUSH
2413: LD_INT 0
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: LIST
2426: LIST
2427: DIFF
2428: PPUSH
2429: LD_STRING otherDelta
2431: PPUSH
2432: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) , opicaci ) ;
2436: LD_INT 22
2438: PUSH
2439: LD_EXP 1
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PUSH
2448: LD_INT 23
2450: PUSH
2451: LD_INT 0
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PPUSH
2462: CALL_OW 69
2466: PPUSH
2467: LD_STRING opicaci
2469: PPUSH
2470: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
2474: LD_ADDR_VAR 0 3
2478: PUSH
2479: LD_INT 22
2481: PUSH
2482: LD_EXP 1
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PUSH
2491: LD_INT 21
2493: PUSH
2494: LD_INT 3
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: PPUSH
2505: CALL_OW 69
2509: ST_TO_ADDR
// Delta := [ ] ;
2510: LD_ADDR_VAR 0 2
2514: PUSH
2515: EMPTY
2516: ST_TO_ADDR
// for t in tmp do
2517: LD_ADDR_VAR 0 4
2521: PUSH
2522: LD_VAR 0 3
2526: PUSH
2527: FOR_IN
2528: IFFALSE 2882
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
2530: LD_VAR 0 4
2534: PPUSH
2535: CALL_OW 266
2539: PUSH
2540: LD_INT 9
2542: DOUBLE
2543: EQUAL
2544: IFTRUE 2584
2546: LD_INT 10
2548: DOUBLE
2549: EQUAL
2550: IFTRUE 2584
2552: LD_INT 13
2554: DOUBLE
2555: EQUAL
2556: IFTRUE 2584
2558: LD_INT 12
2560: DOUBLE
2561: EQUAL
2562: IFTRUE 2584
2564: LD_INT 15
2566: DOUBLE
2567: EQUAL
2568: IFTRUE 2584
2570: LD_INT 11
2572: DOUBLE
2573: EQUAL
2574: IFTRUE 2584
2576: LD_INT 14
2578: DOUBLE
2579: EQUAL
2580: IFTRUE 2584
2582: GO 2587
2584: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
2585: GO 2880
2587: LD_INT 6
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2607
2593: LD_INT 7
2595: DOUBLE
2596: EQUAL
2597: IFTRUE 2607
2599: LD_INT 8
2601: DOUBLE
2602: EQUAL
2603: IFTRUE 2607
2605: GO 2709
2607: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetLabKind ( t , 1 ) , GetLabKind ( t , 2 ) ] ] ; b_bunker , b_turret :
2608: LD_ADDR_VAR 0 2
2612: PUSH
2613: LD_VAR 0 2
2617: PUSH
2618: LD_VAR 0 4
2622: PPUSH
2623: CALL_OW 250
2627: PUSH
2628: LD_VAR 0 4
2632: PPUSH
2633: CALL_OW 251
2637: PUSH
2638: LD_VAR 0 4
2642: PPUSH
2643: CALL_OW 254
2647: PUSH
2648: LD_VAR 0 4
2652: PPUSH
2653: CALL_OW 266
2657: PUSH
2658: LD_VAR 0 4
2662: PPUSH
2663: CALL_OW 267
2667: PUSH
2668: LD_VAR 0 4
2672: PPUSH
2673: LD_INT 1
2675: PPUSH
2676: CALL_OW 268
2680: PUSH
2681: LD_VAR 0 4
2685: PPUSH
2686: LD_INT 2
2688: PPUSH
2689: CALL_OW 268
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: LIST
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: ADD
2706: ST_TO_ADDR
2707: GO 2880
2709: LD_INT 32
2711: DOUBLE
2712: EQUAL
2713: IFTRUE 2723
2715: LD_INT 33
2717: DOUBLE
2718: EQUAL
2719: IFTRUE 2723
2721: GO 2808
2723: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetBWeapon ( t ) ] ] ; else
2724: LD_ADDR_VAR 0 2
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: LD_VAR 0 4
2738: PPUSH
2739: CALL_OW 250
2743: PUSH
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 251
2753: PUSH
2754: LD_VAR 0 4
2758: PPUSH
2759: CALL_OW 254
2763: PUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: CALL_OW 266
2773: PUSH
2774: LD_VAR 0 4
2778: PPUSH
2779: CALL_OW 267
2783: PUSH
2784: LD_VAR 0 4
2788: PPUSH
2789: CALL_OW 269
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: PUSH
2802: EMPTY
2803: LIST
2804: ADD
2805: ST_TO_ADDR
2806: GO 2880
2808: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) ] ] ; end ;
2809: LD_ADDR_VAR 0 2
2813: PUSH
2814: LD_VAR 0 2
2818: PUSH
2819: LD_VAR 0 4
2823: PPUSH
2824: CALL_OW 250
2828: PUSH
2829: LD_VAR 0 4
2833: PPUSH
2834: CALL_OW 251
2838: PUSH
2839: LD_VAR 0 4
2843: PPUSH
2844: CALL_OW 254
2848: PUSH
2849: LD_VAR 0 4
2853: PPUSH
2854: CALL_OW 266
2858: PUSH
2859: LD_VAR 0 4
2863: PPUSH
2864: CALL_OW 267
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: PUSH
2876: EMPTY
2877: LIST
2878: ADD
2879: ST_TO_ADDR
// end ;
2880: GO 2527
2882: POP
2883: POP
// SaveVariable ( Delta , Delta ) ;
2884: LD_VAR 0 2
2888: PPUSH
2889: LD_STRING Delta
2891: PPUSH
2892: CALL_OW 39
// SaveVariable ( Researched ( you , tech_radar ) , RadarDeveloped ) ;
2896: LD_EXP 1
2900: PPUSH
2901: LD_INT 6
2903: PPUSH
2904: CALL_OW 325
2908: PPUSH
2909: LD_STRING RadarDeveloped
2911: PPUSH
2912: CALL_OW 39
// end ;
2916: LD_VAR 0 1
2920: RET
// export function SetMedals ; var medal1 , medal2 , medal3 ; begin
2921: LD_INT 0
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
// AddMedal ( Tame , cil_mit_5_ape_eng_splnen ) ;
2927: LD_STRING Tame
2929: PPUSH
2930: LD_EXP 43
2934: PPUSH
2935: CALL_OW 101
// if cil_mit_5_ape_eng_splnen then
2939: LD_EXP 43
2943: IFFALSE 2953
// medal1 := true ;
2945: LD_ADDR_VAR 0 2
2949: PUSH
2950: LD_INT 1
2952: ST_TO_ADDR
// case GetTech ( tech_Radar , you ) of state_researched :
2953: LD_INT 6
2955: PPUSH
2956: LD_EXP 1
2960: PPUSH
2961: CALL_OW 321
2965: PUSH
2966: LD_INT 2
2968: DOUBLE
2969: EQUAL
2970: IFTRUE 2974
2972: GO 2995
2974: POP
// begin AddMedal ( Radar , 1 ) ;
2975: LD_STRING Radar
2977: PPUSH
2978: LD_INT 1
2980: PPUSH
2981: CALL_OW 101
// medal2 := true ;
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_INT 1
2992: ST_TO_ADDR
// end ; state_disabled :
2993: GO 3040
2995: LD_INT 0
2997: DOUBLE
2998: EQUAL
2999: IFTRUE 3003
3001: GO 3017
3003: POP
// AddMedal ( Radar , - 1 ) ; state_enabled :
3004: LD_STRING Radar
3006: PPUSH
3007: LD_INT 1
3009: NEG
3010: PPUSH
3011: CALL_OW 101
3015: GO 3040
3017: LD_INT 1
3019: DOUBLE
3020: EQUAL
3021: IFTRUE 3025
3023: GO 3039
3025: POP
// AddMedal ( Radar , - 2 ) ; end ;
3026: LD_STRING Radar
3028: PPUSH
3029: LD_INT 2
3031: NEG
3032: PPUSH
3033: CALL_OW 101
3037: GO 3040
3039: POP
// if GetTech ( tech_Radar , you ) = state_disabled then
3040: LD_INT 6
3042: PPUSH
3043: LD_EXP 1
3047: PPUSH
3048: CALL_OW 321
3052: PUSH
3053: LD_INT 0
3055: EQUAL
3056: IFFALSE 3071
// begin AddMedal ( buildRadar , - 1 ) ;
3058: LD_STRING buildRadar
3060: PPUSH
3061: LD_INT 1
3063: NEG
3064: PPUSH
3065: CALL_OW 101
// end else
3069: GO 3108
// begin if RadarBuild then
3071: LD_EXP 47
3075: IFFALSE 3097
// begin AddMedal ( buildRadar , 1 ) ;
3077: LD_STRING buildRadar
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: CALL_OW 101
// medal3 := true ;
3087: LD_ADDR_VAR 0 4
3091: PUSH
3092: LD_INT 1
3094: ST_TO_ADDR
// end else
3095: GO 3108
// AddMedal ( buildRadar , - 2 ) ;
3097: LD_STRING buildRadar
3099: PPUSH
3100: LD_INT 2
3102: NEG
3103: PPUSH
3104: CALL_OW 101
// end ; SA_EndMission ( 1 , 5 , medal1 , medal2 , medal3 ) ;
3108: LD_INT 1
3110: PPUSH
3111: LD_INT 5
3113: PPUSH
3114: LD_VAR 0 2
3118: PPUSH
3119: LD_VAR 0 3
3123: PPUSH
3124: LD_VAR 0 4
3128: PPUSH
3129: CALL 15496 0 5
// end ;
3133: LD_VAR 0 1
3137: RET
// function KolikCrates ; var base ; begin
3138: LD_INT 0
3140: PPUSH
3141: PPUSH
// result := GetCargo ( FilterAllUnits ( [ f_side , you ] ) , mat_cans ) + GetResourceArea ( all_map , mat_cans ) ;
3142: LD_ADDR_VAR 0 1
3146: PUSH
3147: LD_INT 22
3149: PUSH
3150: LD_EXP 1
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PPUSH
3159: CALL_OW 69
3163: PPUSH
3164: LD_INT 1
3166: PPUSH
3167: CALL_OW 289
3171: PUSH
3172: LD_INT 8
3174: PPUSH
3175: LD_INT 1
3177: PPUSH
3178: CALL_OW 287
3182: PLUS
3183: ST_TO_ADDR
// base := FilterAllUnits ( [ f_type , unit_building ] ) ;
3184: LD_ADDR_VAR 0 2
3188: PUSH
3189: LD_INT 21
3191: PUSH
3192: LD_INT 3
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: PPUSH
3199: CALL_OW 69
3203: ST_TO_ADDR
// if base then
3204: LD_VAR 0 2
3208: IFFALSE 3243
// result := result + GetResourceType ( GetBase ( base [ 1 ] ) , mat_cans ) ;
3210: LD_ADDR_VAR 0 1
3214: PUSH
3215: LD_VAR 0 1
3219: PUSH
3220: LD_VAR 0 2
3224: PUSH
3225: LD_INT 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 274
3233: PPUSH
3234: LD_INT 1
3236: PPUSH
3237: CALL_OW 275
3241: PLUS
3242: ST_TO_ADDR
// end ;
3243: LD_VAR 0 1
3247: RET
// on EndTheMissionRaised ( x ) do begin end_the_mission_allowed := false ;
3248: LD_ADDR_OWVAR 57
3252: PUSH
3253: LD_INT 0
3255: ST_TO_ADDR
// Vyhra ;
3256: CALL 3263 0 0
// end ;
3260: PPOPN 1
3262: END
// export function Vyhra ; begin
3263: LD_INT 0
3265: PPUSH
// if tick <= 15 15$00 then
3266: LD_OWVAR 1
3270: PUSH
3271: LD_INT 31500
3273: LESSEQUAL
3274: IFFALSE 3280
// SA_LikeAWind ;
3276: CALL 15416 0 0
// disable ( 0 ) ;
3280: LD_INT 0
3282: DISABLE_MARKED
// SetMedals ;
3283: CALL 2921 0 0
// GiveMedals ( Main ) ;
3287: LD_STRING Main
3289: PPUSH
3290: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3294: LD_INT 22
3296: PUSH
3297: LD_EXP 1
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PUSH
3306: LD_INT 21
3308: PUSH
3309: LD_INT 1
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PUSH
3316: LD_INT 23
3318: PUSH
3319: LD_INT 1
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: LIST
3330: PPUSH
3331: CALL_OW 69
3335: PPUSH
3336: CALL_OW 43
// Save ;
3340: CALL 1972 0 0
// YouWin ;
3344: CALL_OW 103
// end ;
3348: LD_VAR 0 1
3352: RET
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_lab_half ] ] ) then
3353: LD_VAR 0 1
3357: PPUSH
3358: LD_INT 30
3360: PUSH
3361: LD_INT 7
3363: PUSH
3364: EMPTY
3365: LIST
3366: LIST
3367: PUSH
3368: EMPTY
3369: LIST
3370: PPUSH
3371: CALL_OW 72
3375: IFFALSE 3384
// MyHint ( UpgradeLab ) ;
3377: LD_STRING UpgradeLab
3379: PPUSH
3380: CALL 15169 0 1
// end ; end_of_file
3384: PPOPN 1
3386: END
// var startx , starty , startd ; export function Dialog1 ; var qr , i , mechs , sols ; begin
3387: LD_INT 0
3389: PPUSH
3390: PPUSH
3391: PPUSH
3392: PPUSH
3393: PPUSH
// InGameOn ;
3394: CALL_OW 8
// startx := 27 ;
3398: LD_ADDR_LOC 1
3402: PUSH
3403: LD_INT 27
3405: ST_TO_ADDR
// starty := 50 ;
3406: LD_ADDR_LOC 2
3410: PUSH
3411: LD_INT 50
3413: ST_TO_ADDR
// startd := 5 ;
3414: LD_ADDR_LOC 3
3418: PUSH
3419: LD_INT 5
3421: ST_TO_ADDR
// InitUc ;
3422: CALL_OW 18
// InitHc ;
3426: CALL_OW 19
// InitVc ;
3430: CALL_OW 20
// uc_side := you ;
3434: LD_ADDR_OWVAR 20
3438: PUSH
3439: LD_EXP 1
3443: ST_TO_ADDR
// uc_nation := nation_american ;
3444: LD_ADDR_OWVAR 21
3448: PUSH
3449: LD_INT 1
3451: ST_TO_ADDR
// not_char := used diff [ JMM , Glad , Lisa , Frank ] ;
3452: LD_ADDR_EXP 49
3456: PUSH
3457: LD_EXP 57
3461: PUSH
3462: LD_EXP 11
3466: PUSH
3467: LD_EXP 12
3471: PUSH
3472: LD_EXP 15
3476: PUSH
3477: LD_EXP 16
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: DIFF
3488: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Brown , Don ] ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_EXP 49
3498: PUSH
3499: LD_EXP 20
3503: PUSH
3504: LD_EXP 19
3508: PUSH
3509: LD_EXP 18
3513: PUSH
3514: LD_EXP 17
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: LIST
3523: LIST
3524: DIFF
3525: ST_TO_ADDR
// if Brown in used then
3526: LD_EXP 18
3530: PUSH
3531: LD_EXP 57
3535: IN
3536: IFFALSE 3557
// not_char := not_char ^ [ Brown ] ;
3538: LD_ADDR_EXP 49
3542: PUSH
3543: LD_EXP 49
3547: PUSH
3548: LD_EXP 18
3552: PUSH
3553: EMPTY
3554: LIST
3555: ADD
3556: ST_TO_ADDR
// if Don in used then
3557: LD_EXP 17
3561: PUSH
3562: LD_EXP 57
3566: IN
3567: IFFALSE 3588
// not_char := not_char ^ [ Don ] ;
3569: LD_ADDR_EXP 49
3573: PUSH
3574: LD_EXP 49
3578: PUSH
3579: LD_EXP 17
3583: PUSH
3584: EMPTY
3585: LIST
3586: ADD
3587: ST_TO_ADDR
// if Cyrus in used then
3588: LD_EXP 20
3592: PUSH
3593: LD_EXP 57
3597: IN
3598: IFFALSE 3619
// not_char := not_char ^ [ Cyrus ] ;
3600: LD_ADDR_EXP 49
3604: PUSH
3605: LD_EXP 49
3609: PUSH
3610: LD_EXP 20
3614: PUSH
3615: EMPTY
3616: LIST
3617: ADD
3618: ST_TO_ADDR
// if Bobby in used then
3619: LD_EXP 19
3623: PUSH
3624: LD_EXP 57
3628: IN
3629: IFFALSE 3650
// not_char := not_char ^ [ Bobby ] ;
3631: LD_ADDR_EXP 49
3635: PUSH
3636: LD_EXP 49
3640: PUSH
3641: LD_EXP 19
3645: PUSH
3646: EMPTY
3647: LIST
3648: ADD
3649: ST_TO_ADDR
// mechs := UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) ;
3650: LD_ADDR_VAR 0 4
3654: PUSH
3655: LD_EXP 57
3659: PPUSH
3660: LD_INT 25
3662: PUSH
3663: LD_INT 3
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: PUSH
3670: EMPTY
3671: LIST
3672: PPUSH
3673: CALL_OW 72
3677: ST_TO_ADDR
// sols := UnitFilter ( used , [ [ f_class , class_soldier ] ] ) ;
3678: LD_ADDR_VAR 0 5
3682: PUSH
3683: LD_EXP 57
3687: PPUSH
3688: LD_INT 25
3690: PUSH
3691: LD_INT 1
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PUSH
3698: EMPTY
3699: LIST
3700: PPUSH
3701: CALL_OW 72
3705: ST_TO_ADDR
// used := mechs ^ sols ^ ( used diff ( mechs ^ sols ) ) ;
3706: LD_ADDR_EXP 57
3710: PUSH
3711: LD_VAR 0 4
3715: PUSH
3716: LD_VAR 0 5
3720: ADD
3721: PUSH
3722: LD_EXP 57
3726: PUSH
3727: LD_VAR 0 4
3731: PUSH
3732: LD_VAR 0 5
3736: ADD
3737: DIFF
3738: ADD
3739: ST_TO_ADDR
// Wait ( 0 0$1.0 ) ;
3740: LD_INT 35
3742: PPUSH
3743: CALL_OW 67
// PlaceHumanInUnit ( used [ 1 ] , Car1 ) ;
3747: LD_EXP 57
3751: PUSH
3752: LD_INT 1
3754: ARRAY
3755: PPUSH
3756: LD_EXP 25
3760: PPUSH
3761: CALL_OW 52
// PlaceHumanInUnit ( used [ 2 ] , Car2 ) ;
3765: LD_EXP 57
3769: PUSH
3770: LD_INT 2
3772: ARRAY
3773: PPUSH
3774: LD_EXP 26
3778: PPUSH
3779: CALL_OW 52
// PlaceHumanInUnit ( used [ 3 ] , Car3 ) ;
3783: LD_EXP 57
3787: PUSH
3788: LD_INT 3
3790: ARRAY
3791: PPUSH
3792: LD_EXP 27
3796: PPUSH
3797: CALL_OW 52
// PlaceUnitXYR ( Car1 , startx , starty , startd , false ) ;
3801: LD_EXP 25
3805: PPUSH
3806: LD_LOC 1
3810: PPUSH
3811: LD_LOC 2
3815: PPUSH
3816: LD_LOC 3
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 50
// PlaceUnitXYR ( Car2 , startx , starty , startd , false ) ;
3828: LD_EXP 26
3832: PPUSH
3833: LD_LOC 1
3837: PPUSH
3838: LD_LOC 2
3842: PPUSH
3843: LD_LOC 3
3847: PPUSH
3848: LD_INT 0
3850: PPUSH
3851: CALL_OW 50
// PlaceUnitXYR ( Car3 , startx , starty , startd , false ) ;
3855: LD_EXP 27
3859: PPUSH
3860: LD_LOC 1
3864: PPUSH
3865: LD_LOC 2
3869: PPUSH
3870: LD_LOC 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// for i := 4 to used do
3882: LD_ADDR_VAR 0 3
3886: PUSH
3887: DOUBLE
3888: LD_INT 4
3890: DEC
3891: ST_TO_ADDR
3892: LD_EXP 57
3896: PUSH
3897: FOR_TO
3898: IFFALSE 3935
// PlaceUnitXYR ( used [ i ] , startx , starty , startd , false ) ;
3900: LD_EXP 57
3904: PUSH
3905: LD_VAR 0 3
3909: ARRAY
3910: PPUSH
3911: LD_LOC 1
3915: PPUSH
3916: LD_LOC 2
3920: PPUSH
3921: LD_LOC 3
3925: PPUSH
3926: LD_INT 0
3928: PPUSH
3929: CALL_OW 50
3933: GO 3897
3935: POP
3936: POP
// tvoji_lidi := used ;
3937: LD_ADDR_EXP 48
3941: PUSH
3942: LD_EXP 57
3946: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
3947: LD_INT 35
3949: PPUSH
3950: CALL_OW 67
// CenterNowOnXY ( startx , starty ) ;
3954: LD_LOC 1
3958: PPUSH
3959: LD_LOC 2
3963: PPUSH
3964: CALL_OW 86
// Say ( JMM , D1d-JMM-1a ) ;
3968: LD_EXP 11
3972: PPUSH
3973: LD_STRING D1d-JMM-1a
3975: PPUSH
3976: CALL_OW 88
// SayRadio ( Har , D1d-Har-1 ) ;
3980: LD_EXP 13
3984: PPUSH
3985: LD_STRING D1d-Har-1
3987: PPUSH
3988: CALL_OW 94
// InGameOff ;
3992: CALL_OW 9
// SaveForQuickRestart ;
3996: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
4000: LD_STRING M1
4002: PPUSH
4003: CALL_OW 337
// Wait ( 0 0$1.0 ) ;
4007: LD_INT 35
4009: PPUSH
4010: CALL_OW 67
// TalkOn ;
4014: CALL 14821 0 0
// if Say ( JMM , D2-JMM-1 ) then
4018: LD_EXP 11
4022: PPUSH
4023: LD_STRING D2-JMM-1
4025: PPUSH
4026: CALL_OW 88
4030: IFFALSE 4086
// if Say ( Glad , D2-Glad-1 ) then
4032: LD_EXP 12
4036: PPUSH
4037: LD_STRING D2-Glad-1
4039: PPUSH
4040: CALL_OW 88
4044: IFFALSE 4086
// if Say ( JMM , D2-JMM-2 ) then
4046: LD_EXP 11
4050: PPUSH
4051: LD_STRING D2-JMM-2
4053: PPUSH
4054: CALL_OW 88
4058: IFFALSE 4086
// if Say ( Glad , D2-Glad-2 ) then
4060: LD_EXP 12
4064: PPUSH
4065: LD_STRING D2-Glad-2
4067: PPUSH
4068: CALL_OW 88
4072: IFFALSE 4086
// Say ( JMM , D2-JMM-3 ) ;
4074: LD_EXP 11
4078: PPUSH
4079: LD_STRING D2-JMM-3
4081: PPUSH
4082: CALL_OW 88
// TalkOff ;
4086: CALL 14829 0 0
// end ;
4090: LD_VAR 0 1
4094: RET
// every 0 0$10 trigger denis_can_come and laboratore do var a , mytick ;
4095: LD_EXP 46
4099: PUSH
4100: LD_EXP 63
4104: AND
4105: IFFALSE 4485
4107: GO 4109
4109: DISABLE
4110: LD_INT 0
4112: PPUSH
4113: PPUSH
// begin mytick := tick + 0 0$55 ;
4114: LD_ADDR_VAR 0 2
4118: PUSH
4119: LD_OWVAR 1
4123: PUSH
4124: LD_INT 1925
4126: PLUS
4127: ST_TO_ADDR
// while mytick > tick and GetTechProgress ( tech_ApePsych , you ) < 40 do
4128: LD_VAR 0 2
4132: PUSH
4133: LD_OWVAR 1
4137: GREATER
4138: PUSH
4139: LD_INT 2
4141: PPUSH
4142: LD_EXP 1
4146: PPUSH
4147: CALL_OW 326
4151: PUSH
4152: LD_INT 40
4154: LESS
4155: AND
4156: IFFALSE 4167
// wait ( 0 0$1 ) ;
4158: LD_INT 35
4160: PPUSH
4161: CALL_OW 67
4165: GO 4128
// SetSide ( Denis , you2 ) ;
4167: LD_EXP 21
4171: PPUSH
4172: LD_EXP 2
4176: PPUSH
4177: CALL_OW 235
// PlaceUnitXYR ( Denis , 20 , 35 , 5 , false ) ;
4181: LD_EXP 21
4185: PPUSH
4186: LD_INT 20
4188: PPUSH
4189: LD_INT 35
4191: PPUSH
4192: LD_INT 5
4194: PPUSH
4195: LD_INT 0
4197: PPUSH
4198: CALL_OW 50
// Wait ( 0 0$2 ) ;
4202: LD_INT 70
4204: PPUSH
4205: CALL_OW 67
// Den := Denis ;
4209: LD_ADDR_EXP 14
4213: PUSH
4214: LD_EXP 21
4218: ST_TO_ADDR
// DialogueOn ;
4219: CALL_OW 6
// CenterOnUnits ( Den ) ;
4223: LD_EXP 14
4227: PPUSH
4228: CALL_OW 85
// if Say ( Den , DD-Den-1 ) then
4232: LD_EXP 14
4236: PPUSH
4237: LD_STRING DD-Den-1
4239: PPUSH
4240: CALL_OW 88
4244: IFFALSE 4272
// if Say ( JMM , DD-JMM-1 ) then
4246: LD_EXP 11
4250: PPUSH
4251: LD_STRING DD-JMM-1
4253: PPUSH
4254: CALL_OW 88
4258: IFFALSE 4272
// Say ( Den , DD-Den-2 ) ;
4260: LD_EXP 14
4264: PPUSH
4265: LD_STRING DD-Den-2
4267: PPUSH
4268: CALL_OW 88
// DialogueOff ;
4272: CALL_OW 7
// if laboratore then
4276: LD_EXP 63
4280: IFFALSE 4298
// a := laboratore [ 1 ] else
4282: LD_ADDR_VAR 0 1
4286: PUSH
4287: LD_EXP 63
4291: PUSH
4292: LD_INT 1
4294: ARRAY
4295: ST_TO_ADDR
4296: GO 4312
// a := budovy [ 1 ] ;
4298: LD_ADDR_VAR 0 1
4302: PUSH
4303: LD_EXP 64
4307: PUSH
4308: LD_INT 1
4310: ARRAY
4311: ST_TO_ADDR
// ComMoveUnit ( Den , a ) ;
4312: LD_EXP 14
4316: PPUSH
4317: LD_VAR 0 1
4321: PPUSH
4322: CALL_OW 112
// Say ( Den , DD-Den-2a ) ;
4326: LD_EXP 14
4330: PPUSH
4331: LD_STRING DD-Den-2a
4333: PPUSH
4334: CALL_OW 88
// mytick := tick + 0 0$20 ;
4338: LD_ADDR_VAR 0 2
4342: PUSH
4343: LD_OWVAR 1
4347: PUSH
4348: LD_INT 700
4350: PLUS
4351: ST_TO_ADDR
// while GetDistUnits ( den , a ) > 4 and IsLive ( a ) and mytick > tick do
4352: LD_EXP 14
4356: PPUSH
4357: LD_VAR 0 1
4361: PPUSH
4362: CALL_OW 296
4366: PUSH
4367: LD_INT 4
4369: GREATER
4370: PUSH
4371: LD_VAR 0 1
4375: PPUSH
4376: CALL_OW 300
4380: AND
4381: PUSH
4382: LD_VAR 0 2
4386: PUSH
4387: LD_OWVAR 1
4391: GREATER
4392: AND
4393: IFFALSE 4404
// wait ( 0 0$0.6 ) ;
4395: LD_INT 21
4397: PPUSH
4398: CALL_OW 67
4402: GO 4352
// SetSide ( Den , you ) ;
4404: LD_EXP 14
4408: PPUSH
4409: LD_EXP 1
4413: PPUSH
4414: CALL_OW 235
// tvoji_lidi := tvoji_lidi union Den ;
4418: LD_ADDR_EXP 48
4422: PUSH
4423: LD_EXP 48
4427: PUSH
4428: LD_EXP 14
4432: UNION
4433: ST_TO_ADDR
// if laboratore then
4434: LD_EXP 63
4438: IFFALSE 4485
// begin ComEnterUnit ( Den , a ) ;
4440: LD_EXP 14
4444: PPUSH
4445: LD_VAR 0 1
4449: PPUSH
4450: CALL_OW 120
// AddComChangeProfession ( Den , class_scientistic ) ;
4454: LD_EXP 14
4458: PPUSH
4459: LD_INT 4
4461: PPUSH
4462: CALL_OW 183
// Wait ( 0 0$2 ) ;
4466: LD_INT 70
4468: PPUSH
4469: CALL_OW 67
// Say ( Den , DD-Den-2b ) ;
4473: LD_EXP 14
4477: PPUSH
4478: LD_STRING DD-Den-2b
4480: PPUSH
4481: CALL_OW 88
// end ; end ;
4485: PPOPN 2
4487: END
// on ResearchComplete ( tech , lab ) do var qr ;
4488: LD_INT 0
4490: PPUSH
// begin if ( GetSide ( lab ) = you ) then
4491: LD_VAR 0 2
4495: PPUSH
4496: CALL_OW 255
4500: PUSH
4501: LD_EXP 1
4505: EQUAL
4506: IFFALSE 4808
// begin wait ( 0 0$1 ) ;
4508: LD_INT 35
4510: PPUSH
4511: CALL_OW 67
// if tech = tech_ApeLang then
4515: LD_VAR 0 1
4519: PUSH
4520: LD_INT 1
4522: EQUAL
4523: IFFALSE 4614
// begin zasilka_muze := true ;
4525: LD_ADDR_EXP 44
4529: PUSH
4530: LD_INT 1
4532: ST_TO_ADDR
// if IsLive ( Glad ) then
4533: LD_EXP 12
4537: PPUSH
4538: CALL_OW 300
4542: IFFALSE 4607
// begin Wait ( 0 0$1 ) ;
4544: LD_INT 35
4546: PPUSH
4547: CALL_OW 67
// DialogueOn ;
4551: CALL_OW 6
// Say ( Glad , D3-Glad-1 ) ;
4555: LD_EXP 12
4559: PPUSH
4560: LD_STRING D3-Glad-1
4562: PPUSH
4563: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
4567: LD_EXP 11
4571: PPUSH
4572: LD_STRING D3-JMM-1
4574: PPUSH
4575: CALL_OW 88
// Say ( Glad , D3-Glad-2 ) ;
4579: LD_EXP 12
4583: PPUSH
4584: LD_STRING D3-Glad-2
4586: PPUSH
4587: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
4591: LD_EXP 11
4595: PPUSH
4596: LD_STRING D3-JMM-2
4598: PPUSH
4599: CALL_OW 88
// DialogueOff ;
4603: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4607: LD_STRING ApemenTaming
4609: PPUSH
4610: CALL 15169 0 1
// end ; if tech = tech_ApePsych then
4614: LD_VAR 0 1
4618: PUSH
4619: LD_INT 2
4621: EQUAL
4622: IFFALSE 4769
// begin Wait ( 0 0$1 ) ;
4624: LD_INT 35
4626: PPUSH
4627: CALL_OW 67
// while opic <= 0 do
4631: LD_EXP 41
4635: PUSH
4636: LD_INT 0
4638: LESSEQUAL
4639: IFFALSE 4650
// wait ( 0 0$2 ) ;
4641: LD_INT 70
4643: PPUSH
4644: CALL_OW 67
4648: GO 4631
// DialogueOn ;
4650: CALL_OW 6
// if Frank then
4654: LD_EXP 16
4658: IFFALSE 4674
// Say ( Frank , D8a-Frank-1 ) else
4660: LD_EXP 16
4664: PPUSH
4665: LD_STRING D8a-Frank-1
4667: PPUSH
4668: CALL_OW 88
4672: GO 4700
// SayAny ( not_char , D8a-Sol1-1 , you , sex_male , 0 , 0 ) ;
4674: LD_EXP 49
4678: PPUSH
4679: LD_STRING D8a-Sol1-1
4681: PPUSH
4682: LD_EXP 1
4686: PPUSH
4687: LD_INT 1
4689: PPUSH
4690: LD_INT 0
4692: PPUSH
4693: LD_INT 0
4695: PPUSH
4696: CALL 14895 0 6
// if Den then
4700: LD_EXP 14
4704: IFFALSE 4720
// Say ( Den , D8a-Den-1 ) else
4706: LD_EXP 14
4710: PPUSH
4711: LD_STRING D8a-Den-1
4713: PPUSH
4714: CALL_OW 88
4718: GO 4746
// SayAny ( not_char , D8a-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
4720: LD_EXP 49
4724: PPUSH
4725: LD_STRING D8a-Sci1-1
4727: PPUSH
4728: LD_EXP 1
4732: PPUSH
4733: LD_INT 1
4735: PPUSH
4736: LD_INT 4
4738: PPUSH
4739: LD_INT 0
4741: PPUSH
4742: CALL 14895 0 6
// Say ( JMM , D8a-JMM-1 ) ;
4746: LD_EXP 11
4750: PPUSH
4751: LD_STRING D8a-JMM-1
4753: PPUSH
4754: CALL_OW 88
// DialogueOff ;
4758: CALL_OW 7
// MyHint ( ApemenPsychology ) ;
4762: LD_STRING ApemenPsychology
4764: PPUSH
4765: CALL 15169 0 1
// end ; if tech = tech_Radar then
4769: LD_VAR 0 1
4773: PUSH
4774: LD_INT 6
4776: EQUAL
4777: IFFALSE 4808
// begin ChangeMissionObjectives ( M2a ) ;
4779: LD_STRING M2a
4781: PPUSH
4782: CALL_OW 337
// SetRestrict ( b_ext_radar , you , state_enabled ) ;
4786: LD_INT 20
4788: PPUSH
4789: LD_EXP 1
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: CALL_OW 324
// MyHint ( Extensions ) ;
4801: LD_STRING Extensions
4803: PPUSH
4804: CALL 15169 0 1
// end ; end ; end ;
4808: PPOPN 3
4810: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) >= 5 do
4811: LD_INT 25
4813: PUSH
4814: LD_INT 16
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PPUSH
4821: CALL_OW 69
4825: PUSH
4826: LD_INT 5
4828: GREATEREQUAL
4829: IFFALSE 4849
4831: GO 4833
4833: DISABLE
// begin cil_mit_5_ape_eng_splnen := true ;
4834: LD_ADDR_EXP 43
4838: PUSH
4839: LD_INT 1
4841: ST_TO_ADDR
// ChangeMissionObjectives ( M1b ) ;
4842: LD_STRING M1b
4844: PPUSH
4845: CALL_OW 337
// end ;
4849: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) do
4850: LD_INT 25
4852: PUSH
4853: LD_INT 16
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PPUSH
4860: CALL_OW 69
4864: IFFALSE 4884
4866: GO 4868
4868: DISABLE
// begin cil_mit_1_ape_eng_splnen := true ;
4869: LD_ADDR_EXP 42
4873: PUSH
4874: LD_INT 1
4876: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
4877: LD_STRING M1a
4879: PPUSH
4880: CALL_OW 337
// end ;
4884: END
// every 0 0$3 trigger FilterAllUnits ( [ f_weapon , us_radar ] ) or ma_radar do
4885: LD_INT 34
4887: PUSH
4888: LD_INT 11
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 69
4899: PUSH
4900: CALL 4926 0 0
4904: OR
4905: IFFALSE 4925
4907: GO 4909
4909: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4910: LD_STRING M2b
4912: PPUSH
4913: CALL_OW 337
// RadarBuild := true ;
4917: LD_ADDR_EXP 47
4921: PUSH
4922: LD_INT 1
4924: ST_TO_ADDR
// end ;
4925: END
// function ma_radar ; var i ; begin
4926: LD_INT 0
4928: PPUSH
4929: PPUSH
// result := false ;
4930: LD_ADDR_VAR 0 1
4934: PUSH
4935: LD_INT 0
4937: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
4938: LD_ADDR_VAR 0 2
4942: PUSH
4943: LD_INT 21
4945: PUSH
4946: LD_INT 3
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 69
4957: PUSH
4958: FOR_IN
4959: IFFALSE 4988
// begin if GetBWeapon ( i ) = us_radar then
4961: LD_VAR 0 2
4965: PPUSH
4966: CALL_OW 269
4970: PUSH
4971: LD_INT 11
4973: EQUAL
4974: IFFALSE 4986
// begin result := true ;
4976: LD_ADDR_VAR 0 1
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// break ;
4984: GO 4988
// end ; end ;
4986: GO 4958
4988: POP
4989: POP
// end ;
4990: LD_VAR 0 1
4994: RET
// every 7 7$0 do var hex , depot ;
4995: GO 4997
4997: DISABLE
4998: LD_INT 0
5000: PPUSH
5001: PPUSH
// begin depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) ;
5002: LD_ADDR_VAR 0 2
5006: PUSH
5007: LD_INT 2
5009: PUSH
5010: LD_INT 30
5012: PUSH
5013: LD_INT 0
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 30
5022: PUSH
5023: LD_INT 1
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: LIST
5037: PPUSH
5038: CALL_OW 69
5042: ST_TO_ADDR
// if depot then
5043: LD_VAR 0 2
5047: IFFALSE 5065
// depot := depot [ 1 ] else
5049: LD_ADDR_VAR 0 2
5053: PUSH
5054: LD_VAR 0 2
5058: PUSH
5059: LD_INT 1
5061: ARRAY
5062: ST_TO_ADDR
5063: GO 5075
// depot := JMM ;
5065: LD_ADDR_VAR 0 2
5069: PUSH
5070: LD_EXP 11
5074: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
5075: LD_ADDR_VAR 0 1
5079: PUSH
5080: LD_INT 0
5082: PPUSH
5083: CALL_OW 15
5087: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5088: LD_VAR 0 2
5092: PPUSH
5093: LD_VAR 0 1
5097: PUSH
5098: LD_INT 1
5100: ARRAY
5101: PPUSH
5102: LD_VAR 0 1
5106: PUSH
5107: LD_INT 2
5109: ARRAY
5110: PPUSH
5111: CALL_OW 297
5115: PUSH
5116: LD_INT 10
5118: GREATER
5119: PUSH
5120: LD_VAR 0 2
5124: PPUSH
5125: LD_VAR 0 1
5129: PUSH
5130: LD_INT 1
5132: ARRAY
5133: PPUSH
5134: LD_VAR 0 1
5138: PUSH
5139: LD_INT 2
5141: ARRAY
5142: PPUSH
5143: CALL_OW 297
5147: PUSH
5148: LD_INT 20
5150: LESS
5151: AND
5152: IFFALSE 5075
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5154: LD_INT 5
5156: PPUSH
5157: LD_VAR 0 1
5161: PUSH
5162: LD_INT 1
5164: ARRAY
5165: PPUSH
5166: LD_VAR 0 1
5170: PUSH
5171: LD_INT 2
5173: ARRAY
5174: PPUSH
5175: LD_INT 5
5177: PPUSH
5178: LD_INT 1
5180: PPUSH
5181: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5185: LD_ADDR_EXP 55
5189: PUSH
5190: LD_EXP 55
5194: PUSH
5195: LD_INT 1
5197: PLUS
5198: ST_TO_ADDR
// end ;
5199: PPOPN 2
5201: END
// every 0 0$10 trigger zasilka_muze do var hex , depot ;
5202: LD_EXP 44
5206: IFFALSE 5423
5208: GO 5210
5210: DISABLE
5211: LD_INT 0
5213: PPUSH
5214: PPUSH
// begin wait ( 10 10$0 ) ;
5215: LD_INT 21000
5217: PPUSH
5218: CALL_OW 67
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) [ 1 ] ;
5222: LD_ADDR_VAR 0 2
5226: PUSH
5227: LD_INT 2
5229: PUSH
5230: LD_INT 30
5232: PUSH
5233: LD_INT 0
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 30
5242: PUSH
5243: LD_INT 1
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: LIST
5257: PPUSH
5258: CALL_OW 69
5262: PUSH
5263: LD_INT 1
5265: ARRAY
5266: ST_TO_ADDR
// if depot then
5267: LD_VAR 0 2
5271: IFFALSE 5289
// depot := depot [ 1 ] else
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: LD_VAR 0 2
5282: PUSH
5283: LD_INT 1
5285: ARRAY
5286: ST_TO_ADDR
5287: GO 5299
// depot := JMM ;
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: LD_EXP 11
5298: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
5299: LD_ADDR_VAR 0 1
5303: PUSH
5304: LD_INT 0
5306: PPUSH
5307: CALL_OW 15
5311: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5312: LD_VAR 0 2
5316: PPUSH
5317: LD_VAR 0 1
5321: PUSH
5322: LD_INT 1
5324: ARRAY
5325: PPUSH
5326: LD_VAR 0 1
5330: PUSH
5331: LD_INT 2
5333: ARRAY
5334: PPUSH
5335: CALL_OW 297
5339: PUSH
5340: LD_INT 10
5342: GREATER
5343: PUSH
5344: LD_VAR 0 2
5348: PPUSH
5349: LD_VAR 0 1
5353: PUSH
5354: LD_INT 1
5356: ARRAY
5357: PPUSH
5358: LD_VAR 0 1
5362: PUSH
5363: LD_INT 2
5365: ARRAY
5366: PPUSH
5367: CALL_OW 297
5371: PUSH
5372: LD_INT 20
5374: LESS
5375: AND
5376: IFFALSE 5299
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5378: LD_INT 5
5380: PPUSH
5381: LD_VAR 0 1
5385: PUSH
5386: LD_INT 1
5388: ARRAY
5389: PPUSH
5390: LD_VAR 0 1
5394: PUSH
5395: LD_INT 2
5397: ARRAY
5398: PPUSH
5399: LD_INT 5
5401: PPUSH
5402: LD_INT 1
5404: PPUSH
5405: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5409: LD_ADDR_EXP 55
5413: PUSH
5414: LD_EXP 55
5418: PUSH
5419: LD_INT 1
5421: PLUS
5422: ST_TO_ADDR
// end ;
5423: PPOPN 2
5425: END
// every 0 0$1 trigger zasilka_muze and Den do var cekani , budova , x , y , mytick ;
5426: LD_EXP 44
5430: PUSH
5431: LD_EXP 14
5435: AND
5436: IFFALSE 5886
5438: GO 5440
5440: DISABLE
5441: LD_INT 0
5443: PPUSH
5444: PPUSH
5445: PPUSH
5446: PPUSH
5447: PPUSH
// begin cekani := [ 1 1$30 , 1 1$50 , 2 2$10 , 2 2$30 ] [ rand ( 1 , 4 ) ] ;
5448: LD_ADDR_VAR 0 1
5452: PUSH
5453: LD_INT 3150
5455: PUSH
5456: LD_INT 3850
5458: PUSH
5459: LD_INT 4550
5461: PUSH
5462: LD_INT 5250
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PUSH
5471: LD_INT 1
5473: PPUSH
5474: LD_INT 4
5476: PPUSH
5477: CALL_OW 12
5481: ARRAY
5482: ST_TO_ADDR
// mytick := tick + cekani ;
5483: LD_ADDR_VAR 0 5
5487: PUSH
5488: LD_OWVAR 1
5492: PUSH
5493: LD_VAR 0 1
5497: PLUS
5498: ST_TO_ADDR
// while tick < mytick and GetTechProgress ( tech_ApePsych , you ) < 70 do
5499: LD_OWVAR 1
5503: PUSH
5504: LD_VAR 0 5
5508: LESS
5509: PUSH
5510: LD_INT 2
5512: PPUSH
5513: LD_EXP 1
5517: PPUSH
5518: CALL_OW 326
5522: PUSH
5523: LD_INT 70
5525: LESS
5526: AND
5527: IFFALSE 5538
// Wait ( 0 0$1 ) ;
5529: LD_INT 35
5531: PPUSH
5532: CALL_OW 67
5536: GO 5499
// budova := FilterAllUnits ( [ f_btype , b_depot ] ) ;
5538: LD_ADDR_VAR 0 2
5542: PUSH
5543: LD_INT 30
5545: PUSH
5546: LD_INT 0
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: ST_TO_ADDR
// if budova then
5558: LD_VAR 0 2
5562: IFFALSE 5610
// begin budova := budova [ 1 ] ;
5564: LD_ADDR_VAR 0 2
5568: PUSH
5569: LD_VAR 0 2
5573: PUSH
5574: LD_INT 1
5576: ARRAY
5577: ST_TO_ADDR
// x := GetX ( budova ) ;
5578: LD_ADDR_VAR 0 3
5582: PUSH
5583: LD_VAR 0 2
5587: PPUSH
5588: CALL_OW 250
5592: ST_TO_ADDR
// y := GetY ( budova ) ;
5593: LD_ADDR_VAR 0 4
5597: PUSH
5598: LD_VAR 0 2
5602: PPUSH
5603: CALL_OW 251
5607: ST_TO_ADDR
// end else
5608: GO 5626
// begin x := 41 ;
5610: LD_ADDR_VAR 0 3
5614: PUSH
5615: LD_INT 41
5617: ST_TO_ADDR
// y := 24 ;
5618: LD_ADDR_VAR 0 4
5622: PUSH
5623: LD_INT 24
5625: ST_TO_ADDR
// end ; CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5626: LD_INT 5
5628: PPUSH
5629: LD_VAR 0 3
5633: PPUSH
5634: LD_VAR 0 4
5638: PPUSH
5639: LD_INT 10
5641: PPUSH
5642: LD_INT 1
5644: PPUSH
5645: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5649: LD_ADDR_EXP 55
5653: PUSH
5654: LD_EXP 55
5658: PUSH
5659: LD_INT 1
5661: PLUS
5662: ST_TO_ADDR
// Wait ( 0 0$6 ) ;
5663: LD_INT 210
5665: PPUSH
5666: CALL_OW 67
// DialogueOn ;
5670: CALL_OW 6
// Say ( JMM , D4-JMM-1 ) ;
5674: LD_EXP 11
5678: PPUSH
5679: LD_STRING D4-JMM-1
5681: PPUSH
5682: CALL_OW 88
// if Say ( Den , D4-Den-1 ) then
5686: LD_EXP 14
5690: PPUSH
5691: LD_STRING D4-Den-1
5693: PPUSH
5694: CALL_OW 88
5698: IFFALSE 5726
// if Say ( JMM , D4-JMM-2 ) then
5700: LD_EXP 11
5704: PPUSH
5705: LD_STRING D4-JMM-2
5707: PPUSH
5708: CALL_OW 88
5712: IFFALSE 5726
// Say ( Den , D4-Den-2 ) ;
5714: LD_EXP 14
5718: PPUSH
5719: LD_STRING D4-Den-2
5721: PPUSH
5722: CALL_OW 88
// DialogueOff ;
5726: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5730: LD_STRING M2
5732: PPUSH
5733: CALL_OW 337
// SetTech ( tech_Radar , you , state_enabled ) ;
5737: LD_INT 6
5739: PPUSH
5740: LD_EXP 1
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: CALL_OW 322
// SetRestrict ( b_lab_half , you , state_enabled ) ;
5752: LD_INT 7
5754: PPUSH
5755: LD_EXP 1
5759: PPUSH
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 324
// SetRestrict ( b_lab_opto , you , state_enabled ) ;
5767: LD_INT 15
5769: PPUSH
5770: LD_EXP 1
5774: PPUSH
5775: LD_INT 1
5777: PPUSH
5778: CALL_OW 324
// zasilka_landed := true ;
5782: LD_ADDR_EXP 45
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// if difficulty <= 2 then
5790: LD_OWVAR 67
5794: PUSH
5795: LD_INT 2
5797: LESSEQUAL
5798: IFFALSE 5886
// begin wait ( Rand ( 0 0$50 , 1 1$30 ) ) ;
5800: LD_INT 1750
5802: PPUSH
5803: LD_INT 3150
5805: PPUSH
5806: CALL_OW 12
5810: PPUSH
5811: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5815: LD_INT 5
5817: PPUSH
5818: LD_VAR 0 3
5822: PPUSH
5823: LD_VAR 0 4
5827: PPUSH
5828: LD_INT 10
5830: PPUSH
5831: LD_INT 1
5833: PPUSH
5834: CALL_OW 56
// if difficulty <= 1 then
5838: LD_OWVAR 67
5842: PUSH
5843: LD_INT 1
5845: LESSEQUAL
5846: IFFALSE 5886
// begin wait ( Rand ( 0 0$30 , 1 1$0 ) ) ;
5848: LD_INT 1050
5850: PPUSH
5851: LD_INT 2100
5853: PPUSH
5854: CALL_OW 12
5858: PPUSH
5859: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5863: LD_INT 5
5865: PPUSH
5866: LD_VAR 0 3
5870: PPUSH
5871: LD_VAR 0 4
5875: PPUSH
5876: LD_INT 10
5878: PPUSH
5879: LD_INT 1
5881: PPUSH
5882: CALL_OW 56
// end ; end ; end ;
5886: PPOPN 5
5888: END
// every 0 0$3.0 trigger attacking and see_any ( you , oma ) do var dia1 , kdo1 , kdo2 , kdo3 , cvidi ;
5889: LD_EXP 39
5893: PUSH
5894: LD_EXP 1
5898: PPUSH
5899: LD_EXP 8
5903: PPUSH
5904: CALL 13872 0 2
5908: AND
5909: IFFALSE 6467
5911: GO 5913
5913: DISABLE
5914: LD_INT 0
5916: PPUSH
5917: PPUSH
5918: PPUSH
5919: PPUSH
5920: PPUSH
// begin while cvidi < 5 do
5921: LD_VAR 0 5
5925: PUSH
5926: LD_INT 5
5928: LESS
5929: IFFALSE 5979
// begin while see_any ( you , oma ) do
5931: LD_EXP 1
5935: PPUSH
5936: LD_EXP 8
5940: PPUSH
5941: CALL 13872 0 2
5945: IFFALSE 5970
// begin Wait ( 0 0$1 ) ;
5947: LD_INT 35
5949: PPUSH
5950: CALL_OW 67
// cvidi := cvidi + 1 ;
5954: LD_ADDR_VAR 0 5
5958: PUSH
5959: LD_VAR 0 5
5963: PUSH
5964: LD_INT 1
5966: PLUS
5967: ST_TO_ADDR
// end ;
5968: GO 5931
// Wait ( 0 0$1 ) ;
5970: LD_INT 35
5972: PPUSH
5973: CALL_OW 67
// end ;
5977: GO 5921
// for dia1 := 1 to 5 do
5979: LD_ADDR_VAR 0 1
5983: PUSH
5984: DOUBLE
5985: LD_INT 1
5987: DEC
5988: ST_TO_ADDR
5989: LD_INT 5
5991: PUSH
5992: FOR_TO
5993: IFFALSE 6029
// begin while see_any ( you , oma ) do
5995: LD_EXP 1
5999: PPUSH
6000: LD_EXP 8
6004: PPUSH
6005: CALL 13872 0 2
6009: IFFALSE 6020
// Wait ( 0 0$1 ) ;
6011: LD_INT 35
6013: PPUSH
6014: CALL_OW 67
6018: GO 5995
// Wait ( 0 0$1 ) ;
6020: LD_INT 35
6022: PPUSH
6023: CALL_OW 67
// end ;
6027: GO 5992
6029: POP
6030: POP
// if IsLive ( Lisa ) then
6031: LD_EXP 15
6035: PPUSH
6036: CALL_OW 300
6040: IFFALSE 6159
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 0 ) ;
6042: LD_ADDR_VAR 0 2
6046: PUSH
6047: LD_EXP 49
6051: PPUSH
6052: LD_EXP 1
6056: PPUSH
6057: LD_INT 1
6059: PPUSH
6060: LD_INT 0
6062: PPUSH
6063: LD_INT 0
6065: PPUSH
6066: CALL 14975 0 5
6070: ST_TO_ADDR
// DialogueOn ;
6071: CALL_OW 6
// if Say ( kdo1 , D5a-Sol1-1 ) then
6075: LD_VAR 0 2
6079: PPUSH
6080: LD_STRING D5a-Sol1-1
6082: PPUSH
6083: CALL_OW 88
6087: IFFALSE 6101
// Say ( Lisa , D5a-Lisa-1 ) ;
6089: LD_EXP 15
6093: PPUSH
6094: LD_STRING D5a-Lisa-1
6096: PPUSH
6097: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-2 ) then
6101: LD_VAR 0 2
6105: PPUSH
6106: LD_STRING D5a-Sol1-2
6108: PPUSH
6109: CALL_OW 88
6113: IFFALSE 6127
// Say ( Lisa , D5a-Lisa-2 ) ;
6115: LD_EXP 15
6119: PPUSH
6120: LD_STRING D5a-Lisa-2
6122: PPUSH
6123: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-3 ) then
6127: LD_VAR 0 2
6131: PPUSH
6132: LD_STRING D5a-Sol1-3
6134: PPUSH
6135: CALL_OW 88
6139: IFFALSE 6153
// Say ( Lisa , D5a-Lisa-3 ) ;
6141: LD_EXP 15
6145: PPUSH
6146: LD_STRING D5a-Lisa-3
6148: PPUSH
6149: CALL_OW 88
// DialogueOff ;
6153: CALL_OW 7
// end else
6157: GO 6459
// begin DialogueOn ;
6159: CALL_OW 6
// kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
6163: LD_ADDR_VAR 0 2
6167: PUSH
6168: LD_EXP 49
6172: PPUSH
6173: LD_EXP 1
6177: PPUSH
6178: LD_INT 1
6180: PPUSH
6181: LD_INT 0
6183: PPUSH
6184: LD_INT 1
6186: PPUSH
6187: CALL 14975 0 5
6191: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
6192: LD_ADDR_VAR 0 3
6196: PUSH
6197: LD_EXP 49
6201: PPUSH
6202: LD_EXP 1
6206: PPUSH
6207: LD_INT 1
6209: PPUSH
6210: LD_INT 0
6212: PPUSH
6213: LD_INT 2
6215: PPUSH
6216: CALL 14975 0 5
6220: ST_TO_ADDR
// kdo3 := WhoSayAny ( not_char , you , sex_female , 0 , 1 ) ;
6221: LD_ADDR_VAR 0 4
6225: PUSH
6226: LD_EXP 49
6230: PPUSH
6231: LD_EXP 1
6235: PPUSH
6236: LD_INT 2
6238: PPUSH
6239: LD_INT 0
6241: PPUSH
6242: LD_INT 1
6244: PPUSH
6245: CALL 14975 0 5
6249: ST_TO_ADDR
// if Say ( kdo1 , D5-Sol1-1 ) then
6250: LD_VAR 0 2
6254: PPUSH
6255: LD_STRING D5-Sol1-1
6257: PPUSH
6258: CALL_OW 88
6262: IFFALSE 6291
// if not Say ( kdo2 , D5-Sol2-1 ) then
6264: LD_VAR 0 3
6268: PPUSH
6269: LD_STRING D5-Sol2-1
6271: PPUSH
6272: CALL_OW 88
6276: NOT
6277: IFFALSE 6291
// Say ( kdo3 , D5-FSol2-1 ) ;
6279: LD_VAR 0 4
6283: PPUSH
6284: LD_STRING D5-FSol2-1
6286: PPUSH
6287: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-2 ) then
6291: LD_VAR 0 2
6295: PPUSH
6296: LD_STRING D5-Sol1-2
6298: PPUSH
6299: CALL_OW 88
6303: IFFALSE 6332
// if not Say ( kdo2 , D5-Sol2-2 ) then
6305: LD_VAR 0 3
6309: PPUSH
6310: LD_STRING D5-Sol2-2
6312: PPUSH
6313: CALL_OW 88
6317: NOT
6318: IFFALSE 6332
// Say ( kdo3 , D5-FSol2-2 ) ;
6320: LD_VAR 0 4
6324: PPUSH
6325: LD_STRING D5-FSol2-2
6327: PPUSH
6328: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-3 ) then
6332: LD_VAR 0 2
6336: PPUSH
6337: LD_STRING D5-Sol1-3
6339: PPUSH
6340: CALL_OW 88
6344: IFFALSE 6373
// if not Say ( kdo2 , D5-Sol2-3 ) then
6346: LD_VAR 0 3
6350: PPUSH
6351: LD_STRING D5-Sol2-3
6353: PPUSH
6354: CALL_OW 88
6358: NOT
6359: IFFALSE 6373
// Say ( kdo3 , D5-FSol2-3 ) ;
6361: LD_VAR 0 4
6365: PPUSH
6366: LD_STRING D5-FSol2-3
6368: PPUSH
6369: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-4 ) then
6373: LD_VAR 0 2
6377: PPUSH
6378: LD_STRING D5-Sol1-4
6380: PPUSH
6381: CALL_OW 88
6385: IFFALSE 6414
// if not Say ( kdo2 , D5-Sol2-4 ) then
6387: LD_VAR 0 3
6391: PPUSH
6392: LD_STRING D5-Sol2-4
6394: PPUSH
6395: CALL_OW 88
6399: NOT
6400: IFFALSE 6414
// Say ( kdo3 , D5-FSol2-4 ) ;
6402: LD_VAR 0 4
6406: PPUSH
6407: LD_STRING D5-FSol2-4
6409: PPUSH
6410: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-5 ) then
6414: LD_VAR 0 2
6418: PPUSH
6419: LD_STRING D5-Sol1-5
6421: PPUSH
6422: CALL_OW 88
6426: IFFALSE 6455
// if not Say ( kdo2 , D5-Sol2-5 ) then
6428: LD_VAR 0 3
6432: PPUSH
6433: LD_STRING D5-Sol2-5
6435: PPUSH
6436: CALL_OW 88
6440: NOT
6441: IFFALSE 6455
// Say ( kdo3 , D5-FSol2-5 ) ;
6443: LD_VAR 0 4
6447: PPUSH
6448: LD_STRING D5-FSol2-5
6450: PPUSH
6451: CALL_OW 88
// DialogueOff ;
6455: CALL_OW 7
// end ; denis_can_come := true ;
6459: LD_ADDR_EXP 46
6463: PUSH
6464: LD_INT 1
6466: ST_TO_ADDR
// end ;
6467: PPOPN 5
6469: END
// var den_uz_ochocil ; on ApemanTamed ( ktery , kym ) do begin if ( GetSide ( kym ) = you ) then
6470: LD_VAR 0 2
6474: PPUSH
6475: CALL_OW 255
6479: PUSH
6480: LD_EXP 1
6484: EQUAL
6485: IFFALSE 6734
// begin opic := opic + 1 ;
6487: LD_ADDR_EXP 41
6491: PUSH
6492: LD_EXP 41
6496: PUSH
6497: LD_INT 1
6499: PLUS
6500: ST_TO_ADDR
// if kym = Den and not den_uz_ochocil then
6501: LD_VAR 0 2
6505: PUSH
6506: LD_EXP 14
6510: EQUAL
6511: PUSH
6512: LD_LOC 4
6516: NOT
6517: AND
6518: IFFALSE 6550
// begin TalkOn ;
6520: CALL 14821 0 0
// Say ( Den , D7a-Den-1 ) ;
6524: LD_EXP 14
6528: PPUSH
6529: LD_STRING D7a-Den-1
6531: PPUSH
6532: CALL_OW 88
// TalkOff ;
6536: CALL 14829 0 0
// den_uz_ochocil := true ;
6540: LD_ADDR_LOC 4
6544: PUSH
6545: LD_INT 1
6547: ST_TO_ADDR
// end else
6548: GO 6676
// if not first_ape then
6550: LD_EXP 31
6554: NOT
6555: IFFALSE 6676
// begin if kym = Glad then
6557: LD_VAR 0 2
6561: PUSH
6562: LD_EXP 12
6566: EQUAL
6567: IFFALSE 6591
// begin TalkOn ;
6569: CALL 14821 0 0
// Say ( Glad , D7b-Glad-1 ) ;
6573: LD_EXP 12
6577: PPUSH
6578: LD_STRING D7b-Glad-1
6580: PPUSH
6581: CALL_OW 88
// TalkOff ;
6585: CALL 14829 0 0
// end else
6589: GO 6676
// begin if GetSex ( kym ) = sex_male then
6591: LD_VAR 0 2
6595: PPUSH
6596: CALL_OW 258
6600: PUSH
6601: LD_INT 1
6603: EQUAL
6604: IFFALSE 6642
// begin TalkOn ;
6606: CALL 14821 0 0
// SayAny ( not_char , D7c-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
6610: LD_EXP 49
6614: PPUSH
6615: LD_STRING D7c-Sci1-1
6617: PPUSH
6618: LD_EXP 1
6622: PPUSH
6623: LD_INT 1
6625: PPUSH
6626: LD_INT 4
6628: PPUSH
6629: LD_INT 0
6631: PPUSH
6632: CALL 14895 0 6
// TalkOff ;
6636: CALL 14829 0 0
// end else
6640: GO 6676
// begin TalkOn ;
6642: CALL 14821 0 0
// SayAny ( not_char , D7c-FSci1-1 , you , sex_female , class_scientistic , 0 ) ;
6646: LD_EXP 49
6650: PPUSH
6651: LD_STRING D7c-FSci1-1
6653: PPUSH
6654: LD_EXP 1
6658: PPUSH
6659: LD_INT 2
6661: PPUSH
6662: LD_INT 4
6664: PPUSH
6665: LD_INT 0
6667: PPUSH
6668: CALL 14895 0 6
// TalkOff ;
6672: CALL 14829 0 0
// end ; end ; end ; if not first_ape then
6676: LD_EXP 31
6680: NOT
6681: IFFALSE 6734
// begin first_ape := true ;
6683: LD_ADDR_EXP 31
6687: PUSH
6688: LD_INT 1
6690: ST_TO_ADDR
// if kym <> Glad and IsLive ( Glad ) then
6691: LD_VAR 0 2
6695: PUSH
6696: LD_EXP 12
6700: NONEQUAL
6701: PUSH
6702: LD_EXP 12
6706: PPUSH
6707: CALL_OW 300
6711: AND
6712: IFFALSE 6734
// begin TalkOn ;
6714: CALL 14821 0 0
// Say ( Glad , D7c-Glad-1 ) ;
6718: LD_EXP 12
6722: PPUSH
6723: LD_STRING D7c-Glad-1
6725: PPUSH
6726: CALL_OW 88
// TalkOff ;
6730: CALL 14829 0 0
// end ; end ; end ; end ;
6734: PPOPN 2
6736: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) and GetDistUnits ( NearestUnitToUnit ( UnitFilter ( apemans , [ f_side , you ] ) , Lisa ) , Lisa ) < 6 do
6737: LD_INT 22
6739: PUSH
6740: LD_EXP 1
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 101
6751: PUSH
6752: LD_EXP 4
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: PUSH
6761: EMPTY
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: NOT
6770: PUSH
6771: LD_EXP 6
6775: PPUSH
6776: LD_INT 22
6778: PUSH
6779: LD_EXP 1
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: PPUSH
6788: CALL_OW 72
6792: PPUSH
6793: LD_EXP 15
6797: PPUSH
6798: CALL_OW 74
6802: PPUSH
6803: LD_EXP 15
6807: PPUSH
6808: CALL_OW 296
6812: PUSH
6813: LD_INT 6
6815: LESS
6816: AND
6817: IFFALSE 6842
6819: GO 6821
6821: DISABLE
// begin TalkOn ;
6822: CALL 14821 0 0
// Say ( Lisa , D8-Lisa-1 ) ;
6826: LD_EXP 15
6830: PPUSH
6831: LD_STRING D8-Lisa-1
6833: PPUSH
6834: CALL_OW 88
// TalkOff ;
6838: CALL 14829 0 0
// end ;
6842: END
// every 0 0$10 trigger cil_mit_1_ape_eng_splnen do var qr ;
6843: LD_EXP 42
6847: IFFALSE 6890
6849: GO 6851
6851: DISABLE
6852: LD_INT 0
6854: PPUSH
// begin qr := Query ( Q2 ) ;
6855: LD_ADDR_VAR 0 1
6859: PUSH
6860: LD_STRING Q2
6862: PPUSH
6863: CALL_OW 97
6867: ST_TO_ADDR
// end_the_mission_allowed := true ;
6868: LD_ADDR_OWVAR 57
6872: PUSH
6873: LD_INT 1
6875: ST_TO_ADDR
// if qr = 1 then
6876: LD_VAR 0 1
6880: PUSH
6881: LD_INT 1
6883: EQUAL
6884: IFFALSE 6890
// begin Vyhra ;
6886: CALL 3263 0 0
// end ; end ; end_of_file
6890: PPOPN 1
6892: END
// export depot , laboratore , budovy ; on BuildingComplete ( build ) do begin budovy := budovy union build ;
6893: LD_ADDR_EXP 64
6897: PUSH
6898: LD_EXP 64
6902: PUSH
6903: LD_VAR 0 1
6907: UNION
6908: ST_TO_ADDR
// if GetBType ( build ) = b_lab then
6909: LD_VAR 0 1
6913: PPUSH
6914: CALL_OW 266
6918: PUSH
6919: LD_INT 6
6921: EQUAL
6922: IFFALSE 6940
// laboratore := laboratore union build ;
6924: LD_ADDR_EXP 63
6928: PUSH
6929: LD_EXP 63
6933: PUSH
6934: LD_VAR 0 1
6938: UNION
6939: ST_TO_ADDR
// if GetBType ( build ) = b_depot then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 266
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: IFFALSE 6977
// begin depot := build ;
6955: LD_ADDR_EXP 62
6959: PUSH
6960: LD_VAR 0 1
6964: ST_TO_ADDR
// SetBName ( build , delta ) ;
6965: LD_VAR 0 1
6969: PPUSH
6970: LD_STRING delta
6972: PPUSH
6973: CALL_OW 500
// end ; if GetBType ( build ) = b_workshop then
6977: LD_VAR 0 1
6981: PPUSH
6982: CALL_OW 266
6986: PUSH
6987: LD_INT 2
6989: EQUAL
6990: IFFALSE 6999
// MyHint ( Recycle ) ;
6992: LD_STRING Recycle
6994: PPUSH
6995: CALL 15169 0 1
// if GetBType ( build ) = b_ext_radar then
6999: LD_VAR 0 1
7003: PPUSH
7004: CALL_OW 266
7008: PUSH
7009: LD_INT 20
7011: EQUAL
7012: IFFALSE 7021
// MyHint ( Radar ) ;
7014: LD_STRING Radar
7016: PPUSH
7017: CALL 15169 0 1
// end ;
7021: PPOPN 1
7023: END
// on UnitDestroyed ( un ) do begin if un in budovy then
7024: LD_VAR 0 1
7028: PUSH
7029: LD_EXP 64
7033: IN
7034: IFFALSE 7052
// budovy := budovy diff un ;
7036: LD_ADDR_EXP 64
7040: PUSH
7041: LD_EXP 64
7045: PUSH
7046: LD_VAR 0 1
7050: DIFF
7051: ST_TO_ADDR
// if un in laboratore then
7052: LD_VAR 0 1
7056: PUSH
7057: LD_EXP 63
7061: IN
7062: IFFALSE 7080
// laboratore := laboratore diff un ;
7064: LD_ADDR_EXP 63
7068: PUSH
7069: LD_EXP 63
7073: PUSH
7074: LD_VAR 0 1
7078: DIFF
7079: ST_TO_ADDR
// if un in tvoji_lidi then
7080: LD_VAR 0 1
7084: PUSH
7085: LD_EXP 48
7089: IN
7090: IFFALSE 7122
// begin tvoji_lidi := tvoji_lidi diff un ;
7092: LD_ADDR_EXP 48
7096: PUSH
7097: LD_EXP 48
7101: PUSH
7102: LD_VAR 0 1
7106: DIFF
7107: ST_TO_ADDR
// ztraty := ztraty + 1 ;
7108: LD_ADDR_EXP 51
7112: PUSH
7113: LD_EXP 51
7117: PUSH
7118: LD_INT 1
7120: PLUS
7121: ST_TO_ADDR
// end ; if un in oma then
7122: LD_VAR 0 1
7126: PUSH
7127: LD_EXP 8
7131: IN
7132: IFFALSE 7150
// oma := oma diff un ;
7134: LD_ADDR_EXP 8
7138: PUSH
7139: LD_EXP 8
7143: PUSH
7144: LD_VAR 0 1
7148: DIFF
7149: ST_TO_ADDR
// if un in arabs_cars then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_EXP 10
7159: IN
7160: IFFALSE 7178
// arabs_cars := arabs_cars diff un ;
7162: LD_ADDR_EXP 10
7166: PUSH
7167: LD_EXP 10
7171: PUSH
7172: LD_VAR 0 1
7176: DIFF
7177: ST_TO_ADDR
// if un in apemans then
7178: LD_VAR 0 1
7182: PUSH
7183: LD_EXP 6
7187: IN
7188: IFFALSE 7206
// apemans := apemans diff un ;
7190: LD_ADDR_EXP 6
7194: PUSH
7195: LD_EXP 6
7199: PUSH
7200: LD_VAR 0 1
7204: DIFF
7205: ST_TO_ADDR
// if un = JMM then
7206: LD_VAR 0 1
7210: PUSH
7211: LD_EXP 11
7215: EQUAL
7216: IFFALSE 7228
// begin disable ( 0 ) ;
7218: LD_INT 0
7220: DISABLE_MARKED
// YouLost ( JMM ) ;
7221: LD_STRING JMM
7223: PPUSH
7224: CALL_OW 104
// end ; if UnitFilter ( un , [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) then
7228: LD_VAR 0 1
7232: PPUSH
7233: LD_INT 22
7235: PUSH
7236: LD_EXP 1
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PUSH
7245: LD_INT 23
7247: PUSH
7248: LD_INT 0
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PPUSH
7259: CALL_OW 72
7263: IFFALSE 7279
// begin opic := opic - 1 ;
7265: LD_ADDR_EXP 41
7269: PUSH
7270: LD_EXP 41
7274: PUSH
7275: LD_INT 1
7277: MINUS
7278: ST_TO_ADDR
// end ; end ;
7279: PPOPN 1
7281: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = you then
7282: LD_VAR 0 3
7286: PUSH
7287: LD_EXP 1
7291: EQUAL
7292: IFFALSE 7325
// begin arabs_cars := arabs_cars union vehnew ;
7294: LD_ADDR_EXP 10
7298: PUSH
7299: LD_EXP 10
7303: PUSH
7304: LD_VAR 0 1
7308: UNION
7309: ST_TO_ADDR
// evade_shortest_way ( vehnew , false , true ) ;
7310: LD_VAR 0 1
7314: PPUSH
7315: LD_INT 0
7317: PPUSH
7318: LD_INT 1
7320: PPUSH
7321: CALL 12836 0 3
// end ; if origside = arabians then
7325: LD_VAR 0 3
7329: PUSH
7330: LD_EXP 4
7334: EQUAL
7335: IFFALSE 7353
// begin arabs_cars := arabs_cars diff vehold ;
7337: LD_ADDR_EXP 10
7341: PUSH
7342: LD_EXP 10
7346: PUSH
7347: LD_VAR 0 2
7351: DIFF
7352: ST_TO_ADDR
// end ; end ;
7353: PPOPN 4
7355: END
// every 0 0$10 do
7356: GO 7358
7358: DISABLE
// Randomize ;
7359: CALL_OW 10
7363: END
// every 0 0$10 trigger apemans < 5 do var op ;
7364: LD_EXP 6
7368: PUSH
7369: LD_INT 5
7371: LESS
7372: IFFALSE 7638
7374: GO 7376
7376: DISABLE
7377: LD_INT 0
7379: PPUSH
// begin InitUc ;
7380: CALL_OW 18
// InitHc ;
7384: CALL_OW 19
// uc_nation := nation_nature ;
7388: LD_ADDR_OWVAR 21
7392: PUSH
7393: LD_INT 0
7395: ST_TO_ADDR
// uc_side := 0 ;
7396: LD_ADDR_OWVAR 20
7400: PUSH
7401: LD_INT 0
7403: ST_TO_ADDR
// hc_class := class_apeman ;
7404: LD_ADDR_OWVAR 28
7408: PUSH
7409: LD_INT 12
7411: ST_TO_ADDR
// hc_agressivity := Rand ( - 5 , 10 ) ;
7412: LD_ADDR_OWVAR 35
7416: PUSH
7417: LD_INT 5
7419: NEG
7420: PPUSH
7421: LD_INT 10
7423: PPUSH
7424: CALL_OW 12
7428: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
7429: LD_ADDR_OWVAR 27
7433: PUSH
7434: LD_INT 1
7436: PPUSH
7437: LD_INT 2
7439: PPUSH
7440: CALL_OW 12
7444: ST_TO_ADDR
// op := CreateHuman ;
7445: LD_ADDR_VAR 0 1
7449: PUSH
7450: CALL_OW 44
7454: ST_TO_ADDR
// case rand ( 1 , 4 ) of 1 :
7455: LD_INT 1
7457: PPUSH
7458: LD_INT 4
7460: PPUSH
7461: CALL_OW 12
7465: PUSH
7466: LD_INT 1
7468: DOUBLE
7469: EQUAL
7470: IFTRUE 7474
7472: GO 7498
7474: POP
// PlaceUnitXYR ( op , 16 , 1 , 5 , false ) ; 2 :
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 16
7482: PPUSH
7483: LD_INT 1
7485: PPUSH
7486: LD_INT 5
7488: PPUSH
7489: LD_INT 0
7491: PPUSH
7492: CALL_OW 50
7496: GO 7595
7498: LD_INT 2
7500: DOUBLE
7501: EQUAL
7502: IFTRUE 7506
7504: GO 7530
7506: POP
// PlaceUnitXYR ( op , 46 , 1 , 5 , false ) ; 3 :
7507: LD_VAR 0 1
7511: PPUSH
7512: LD_INT 46
7514: PPUSH
7515: LD_INT 1
7517: PPUSH
7518: LD_INT 5
7520: PPUSH
7521: LD_INT 0
7523: PPUSH
7524: CALL_OW 50
7528: GO 7595
7530: LD_INT 3
7532: DOUBLE
7533: EQUAL
7534: IFTRUE 7538
7536: GO 7562
7538: POP
// PlaceUnitXYR ( op , 1 , 23 , 5 , false ) ; 4 :
7539: LD_VAR 0 1
7543: PPUSH
7544: LD_INT 1
7546: PPUSH
7547: LD_INT 23
7549: PPUSH
7550: LD_INT 5
7552: PPUSH
7553: LD_INT 0
7555: PPUSH
7556: CALL_OW 50
7560: GO 7595
7562: LD_INT 4
7564: DOUBLE
7565: EQUAL
7566: IFTRUE 7570
7568: GO 7594
7570: POP
// PlaceUnitXYR ( op , 80 , 1 , 5 , false ) ; end ;
7571: LD_VAR 0 1
7575: PPUSH
7576: LD_INT 80
7578: PPUSH
7579: LD_INT 1
7581: PPUSH
7582: LD_INT 5
7584: PPUSH
7585: LD_INT 0
7587: PPUSH
7588: CALL_OW 50
7592: GO 7595
7594: POP
// apemans := apemans union op ;
7595: LD_ADDR_EXP 6
7599: PUSH
7600: LD_EXP 6
7604: PUSH
7605: LD_VAR 0 1
7609: UNION
7610: ST_TO_ADDR
// added_apes := added_apes + 1 ;
7611: LD_ADDR_EXP 53
7615: PUSH
7616: LD_EXP 53
7620: PUSH
7621: LD_INT 1
7623: PLUS
7624: ST_TO_ADDR
// if added_apes < max_added_apes then
7625: LD_EXP 53
7629: PUSH
7630: LD_EXP 54
7634: LESS
7635: IFFALSE 7638
// enable ;
7637: ENABLE
// end ; end_of_file
7638: PPOPN 1
7640: END
// var amici_v ; var amici_h ; var amici_b ; on DestinationUnreachable ( un ) do begin if GetSide ( un ) = arabians then
7641: LD_VAR 0 1
7645: PPUSH
7646: CALL_OW 255
7650: PUSH
7651: LD_EXP 4
7655: EQUAL
7656: IFFALSE 7739
// begin if attacking and laboratore then
7658: LD_EXP 39
7662: PUSH
7663: LD_EXP 63
7667: AND
7668: IFFALSE 7727
// begin ComAgressiveMove ( un , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7670: LD_VAR 0 1
7674: PPUSH
7675: LD_EXP 63
7679: PUSH
7680: LD_INT 1
7682: ARRAY
7683: PPUSH
7684: CALL_OW 250
7688: PPUSH
7689: LD_EXP 63
7693: PUSH
7694: LD_INT 1
7696: ARRAY
7697: PPUSH
7698: CALL_OW 251
7702: PPUSH
7703: CALL_OW 114
// AddComAttackUnit ( un , laboratore [ 1 ] ) ;
7707: LD_VAR 0 1
7711: PPUSH
7712: LD_EXP 63
7716: PUSH
7717: LD_INT 1
7719: ARRAY
7720: PPUSH
7721: CALL_OW 175
// end else
7725: GO 7739
// ComMoveToArea ( un , border ) ;
7727: LD_VAR 0 1
7731: PPUSH
7732: LD_INT 7
7734: PPUSH
7735: CALL_OW 113
// end ; end ;
7739: PPOPN 1
7741: END
// every 0 0$50 do
7742: GO 7744
7744: DISABLE
// begin Wait ( wait_first_attack ) ;
7745: LD_EXP 60
7749: PPUSH
7750: CALL_OW 67
// attacky := attacky + 1 ;
7754: LD_ADDR_EXP 40
7758: PUSH
7759: LD_EXP 40
7763: PUSH
7764: LD_INT 1
7766: PLUS
7767: ST_TO_ADDR
// attacking := true ;
7768: LD_ADDR_EXP 39
7772: PUSH
7773: LD_INT 1
7775: ST_TO_ADDR
// F_first_attack ;
7776: CALL 9307 0 0
// oma := FilterAllUnits ( [ f_side , arabians ] ) ;
7780: LD_ADDR_EXP 8
7784: PUSH
7785: LD_INT 22
7787: PUSH
7788: LD_EXP 4
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PPUSH
7797: CALL_OW 69
7801: ST_TO_ADDR
// end ;
7802: END
// every 0 0$1 do var i ;
7803: GO 7805
7805: DISABLE
7806: LD_INT 0
7808: PPUSH
// begin om := FilterAllUnits ( [ f_side , arabians ] ) ;
7809: LD_ADDR_EXP 9
7813: PUSH
7814: LD_INT 22
7816: PUSH
7817: LD_EXP 4
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: ST_TO_ADDR
// for i in om do
7831: LD_ADDR_VAR 0 1
7835: PUSH
7836: LD_EXP 9
7840: PUSH
7841: FOR_IN
7842: IFFALSE 7878
// if IsIdle ( i ) then
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 316
7853: IFFALSE 7876
// begin RaiseSailEvent ( i ) ;
7855: LD_VAR 0 1
7859: PPUSH
7860: CALL_OW 427
// ComMoveToArea ( i , border ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 7
7871: PPUSH
7872: CALL_OW 113
// end ;
7876: GO 7841
7878: POP
7879: POP
// enable ;
7880: ENABLE
// end ;
7881: PPOPN 1
7883: END
// on SailEvent ( x ) do var k ;
7884: LD_INT 0
7886: PPUSH
// begin k := 0 ;
7887: LD_ADDR_VAR 0 2
7891: PUSH
7892: LD_INT 0
7894: ST_TO_ADDR
// while k < 3 and IsLive ( x ) do
7895: LD_VAR 0 2
7899: PUSH
7900: LD_INT 3
7902: LESS
7903: PUSH
7904: LD_VAR 0 1
7908: PPUSH
7909: CALL_OW 300
7913: AND
7914: IFFALSE 7950
// begin wait ( 0 0$1 ) ;
7916: LD_INT 35
7918: PPUSH
7919: CALL_OW 67
// if IsIdle ( x ) then
7923: LD_VAR 0 1
7927: PPUSH
7928: CALL_OW 316
7932: IFFALSE 7948
// k := k + 1 ;
7934: LD_ADDR_VAR 0 2
7938: PUSH
7939: LD_VAR 0 2
7943: PUSH
7944: LD_INT 1
7946: PLUS
7947: ST_TO_ADDR
// end ;
7948: GO 7895
// ComMoveToArea ( x , border ) ;
7950: LD_VAR 0 1
7954: PPUSH
7955: LD_INT 7
7957: PPUSH
7958: CALL_OW 113
// AddComWait ( x , 0 0$10 ) ;
7962: LD_VAR 0 1
7966: PPUSH
7967: LD_INT 350
7969: PPUSH
7970: CALL_OW 202
// if laboratore then
7974: LD_EXP 63
7978: IFFALSE 8017
// AddComAgressiveMove ( x , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7980: LD_VAR 0 1
7984: PPUSH
7985: LD_EXP 63
7989: PUSH
7990: LD_INT 1
7992: ARRAY
7993: PPUSH
7994: CALL_OW 250
7998: PPUSH
7999: LD_EXP 63
8003: PUSH
8004: LD_INT 1
8006: ARRAY
8007: PPUSH
8008: CALL_OW 251
8012: PPUSH
8013: CALL_OW 174
// end ;
8017: PPOPN 2
8019: END
// export last_attack_was ; every 3 3$50.0 + 3 3$0 trigger budovy and not attacking do
8020: LD_EXP 64
8024: PUSH
8025: LD_EXP 39
8029: NOT
8030: AND
8031: IFFALSE 8061
8033: GO 8035
8035: DISABLE
// begin if difficulty = 1 then
8036: LD_OWVAR 67
8040: PUSH
8041: LD_INT 1
8043: EQUAL
8044: IFFALSE 8061
// begin last_attack_was := tick ;
8046: LD_ADDR_EXP 65
8050: PUSH
8051: LD_OWVAR 1
8055: ST_TO_ADDR
// WhichAttack ;
8056: CALL 8281 0 0
// enable ;
8060: ENABLE
// end ; end ;
8061: END
// every 3 3$10.0 + 2 2$0 trigger budovy and not attacking do
8062: LD_EXP 64
8066: PUSH
8067: LD_EXP 39
8071: NOT
8072: AND
8073: IFFALSE 8103
8075: GO 8077
8077: DISABLE
// begin if difficulty = 2 then
8078: LD_OWVAR 67
8082: PUSH
8083: LD_INT 2
8085: EQUAL
8086: IFFALSE 8103
// begin last_attack_was := tick ;
8088: LD_ADDR_EXP 65
8092: PUSH
8093: LD_OWVAR 1
8097: ST_TO_ADDR
// WhichAttack ;
8098: CALL 8281 0 0
// enable ;
8102: ENABLE
// end ; end ;
8103: END
// every 2 2$30.0 + 1 1$30 trigger budovy and not attacking do
8104: LD_EXP 64
8108: PUSH
8109: LD_EXP 39
8113: NOT
8114: AND
8115: IFFALSE 8145
8117: GO 8119
8119: DISABLE
// begin if difficulty = 3 then
8120: LD_OWVAR 67
8124: PUSH
8125: LD_INT 3
8127: EQUAL
8128: IFFALSE 8145
// begin last_attack_was := tick ;
8130: LD_ADDR_EXP 65
8134: PUSH
8135: LD_OWVAR 1
8139: ST_TO_ADDR
// WhichAttack ;
8140: CALL 8281 0 0
// enable ;
8144: ENABLE
// end ; end ;
8145: END
// function free_cars ; var i ; begin
8146: LD_INT 0
8148: PPUSH
8149: PPUSH
// for i in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) do
8150: LD_ADDR_VAR 0 2
8154: PUSH
8155: LD_INT 21
8157: PUSH
8158: LD_INT 2
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: LD_INT 22
8167: PUSH
8168: LD_EXP 1
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PPUSH
8181: CALL_OW 69
8185: PUSH
8186: FOR_IN
8187: IFFALSE 8213
// begin if not IsDrivenBy ( i ) then
8189: LD_VAR 0 2
8193: PPUSH
8194: CALL_OW 311
8198: NOT
8199: IFFALSE 8211
// begin result := true ;
8201: LD_ADDR_VAR 0 1
8205: PUSH
8206: LD_INT 1
8208: ST_TO_ADDR
// break ;
8209: GO 8213
// end ; end ;
8211: GO 8186
8213: POP
8214: POP
// end ;
8215: LD_VAR 0 1
8219: RET
// function lonely ; begin
8220: LD_INT 0
8222: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , depot , 16 ] ] ) ;
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_INT 22
8230: PUSH
8231: LD_EXP 1
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 21
8242: PUSH
8243: LD_INT 1
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 91
8252: PUSH
8253: LD_EXP 62
8257: PUSH
8258: LD_INT 16
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: LIST
8270: PPUSH
8271: CALL_OW 69
8275: ST_TO_ADDR
// end ;
8276: LD_VAR 0 1
8280: RET
// function WhichAttack ; var l ; begin
8281: LD_INT 0
8283: PPUSH
8284: PPUSH
// attacky := attacky + 1 ;
8285: LD_ADDR_EXP 40
8289: PUSH
8290: LD_EXP 40
8294: PUSH
8295: LD_INT 1
8297: PLUS
8298: ST_TO_ADDR
// attacking := true ;
8299: LD_ADDR_EXP 39
8303: PUSH
8304: LD_INT 1
8306: ST_TO_ADDR
// l := lonely ;
8307: LD_ADDR_VAR 0 2
8311: PUSH
8312: CALL 8220 0 0
8316: ST_TO_ADDR
// case true of l :
8317: LD_INT 1
8319: PUSH
8320: LD_VAR 0 2
8324: DOUBLE
8325: EQUAL
8326: IFTRUE 8330
8328: GO 8342
8330: POP
// F_lonely_attack ( l ) ; free_cars and rand ( 1 , 3 ) = 1 :
8331: LD_VAR 0 2
8335: PPUSH
8336: CALL 11321 0 1
8340: GO 8413
8342: CALL 8146 0 0
8346: PUSH
8347: LD_INT 1
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: CALL_OW 12
8357: PUSH
8358: LD_INT 1
8360: EQUAL
8361: AND
8362: DOUBLE
8363: EQUAL
8364: IFTRUE 8368
8366: GO 8375
8368: POP
// F_thief_attack ; budovy and rand ( 1 , 2 ) = 1 :
8369: CALL 10577 0 0
8373: GO 8413
8375: LD_EXP 64
8379: PUSH
8380: LD_INT 1
8382: PPUSH
8383: LD_INT 2
8385: PPUSH
8386: CALL_OW 12
8390: PUSH
8391: LD_INT 1
8393: EQUAL
8394: AND
8395: DOUBLE
8396: EQUAL
8397: IFTRUE 8401
8399: GO 8408
8401: POP
// F_mine_attack ; else
8402: CALL 9841 0 0
8406: GO 8413
8408: POP
// F_next_attack ; end ;
8409: CALL 11674 0 0
// if attacky < utoku then
8413: LD_EXP 40
8417: PUSH
8418: LD_EXP 61
8422: LESS
8423: IFFALSE 8426
// enable ;
8425: ENABLE
// oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8426: LD_ADDR_EXP 8
8430: PUSH
8431: LD_INT 22
8433: PUSH
8434: LD_EXP 4
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PUSH
8443: LD_INT 21
8445: PUSH
8446: LD_INT 1
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: PPUSH
8457: CALL_OW 69
8461: ST_TO_ADDR
// end ;
8462: LD_VAR 0 1
8466: RET
// every 0 0$1.0 do var i , a ;
8467: GO 8469
8469: DISABLE
8470: LD_INT 0
8472: PPUSH
8473: PPUSH
// begin oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8474: LD_ADDR_EXP 8
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_EXP 4
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 21
8493: PUSH
8494: LD_INT 1
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if oma then
8510: LD_EXP 8
8514: IFFALSE 8823
// begin a := oma [ rand ( 1 , oma ) ] ;
8516: LD_ADDR_VAR 0 2
8520: PUSH
8521: LD_EXP 8
8525: PUSH
8526: LD_INT 1
8528: PPUSH
8529: LD_EXP 8
8533: PPUSH
8534: CALL_OW 12
8538: ARRAY
8539: ST_TO_ADDR
// if ( tick - last_attack_was ) > 5 5$0 then
8540: LD_OWVAR 1
8544: PUSH
8545: LD_EXP 65
8549: MINUS
8550: PUSH
8551: LD_INT 10500
8553: GREATER
8554: IFFALSE 8606
// ComAttackUnit ( oma , NearestUnitToUnit ( FilterAllUnits ( [ f_side , you ] ) , oma [ Rand ( 1 , oma ) ] ) ) ;
8556: LD_EXP 8
8560: PPUSH
8561: LD_INT 22
8563: PUSH
8564: LD_EXP 1
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PPUSH
8573: CALL_OW 69
8577: PPUSH
8578: LD_EXP 8
8582: PUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_EXP 8
8590: PPUSH
8591: CALL_OW 12
8595: ARRAY
8596: PPUSH
8597: CALL_OW 74
8601: PPUSH
8602: CALL_OW 115
// if ( tick - last_attack_was ) > 7 7$0 then
8606: LD_OWVAR 1
8610: PUSH
8611: LD_EXP 65
8615: MINUS
8616: PUSH
8617: LD_INT 14700
8619: GREATER
8620: IFFALSE 8657
// evade_shortest_way_from_xy ( getx ( a ) , gety ( a ) , oma , true , true ) ;
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 250
8631: PPUSH
8632: LD_VAR 0 2
8636: PPUSH
8637: CALL_OW 251
8641: PPUSH
8642: LD_EXP 8
8646: PPUSH
8647: LD_INT 1
8649: PPUSH
8650: LD_INT 1
8652: PPUSH
8653: CALL 12923 0 5
// for i in oma do
8657: LD_ADDR_VAR 0 1
8661: PUSH
8662: LD_EXP 8
8666: PUSH
8667: FOR_IN
8668: IFFALSE 8821
// begin if IsIdle ( i ) and IsInArea ( i , border ) then
8670: LD_VAR 0 1
8674: PPUSH
8675: CALL_OW 316
8679: PUSH
8680: LD_VAR 0 1
8684: PPUSH
8685: LD_INT 7
8687: PPUSH
8688: CALL_OW 308
8692: AND
8693: IFFALSE 8819
// begin if IsInUnit ( i ) then
8695: LD_VAR 0 1
8699: PPUSH
8700: CALL_OW 310
8704: IFFALSE 8749
// arabs_cars := arabs_cars union UnitFilter ( IsInUnit ( i ) , [ f_not , [ f_weapon , us_cargo_bay ] ] ) ;
8706: LD_ADDR_EXP 10
8710: PUSH
8711: LD_EXP 10
8715: PUSH
8716: LD_VAR 0 1
8720: PPUSH
8721: CALL_OW 310
8725: PPUSH
8726: LD_INT 3
8728: PUSH
8729: LD_INT 34
8731: PUSH
8732: LD_INT 12
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: PPUSH
8743: CALL_OW 72
8747: UNION
8748: ST_TO_ADDR
// RemoveUnit ( IsInUnit ( i ) ) ;
8749: LD_VAR 0 1
8753: PPUSH
8754: CALL_OW 310
8758: PPUSH
8759: CALL_OW 64
// SetLives ( IsInUnit ( i ) , 1000 ) ;
8763: LD_VAR 0 1
8767: PPUSH
8768: CALL_OW 310
8772: PPUSH
8773: LD_INT 1000
8775: PPUSH
8776: CALL_OW 234
// DestroyUnit ( i ) ;
8780: LD_VAR 0 1
8784: PPUSH
8785: CALL_OW 65
// oma := oma diff i ;
8789: LD_ADDR_EXP 8
8793: PUSH
8794: LD_EXP 8
8798: PUSH
8799: LD_VAR 0 1
8803: DIFF
8804: ST_TO_ADDR
// away_from_last_attack := away_from_last_attack + 1 ;
8805: LD_ADDR_EXP 33
8809: PUSH
8810: LD_EXP 33
8814: PUSH
8815: LD_INT 1
8817: PLUS
8818: ST_TO_ADDR
// end ; end ;
8819: GO 8667
8821: POP
8822: POP
// end ; enable ;
8823: ENABLE
// end ;
8824: PPOPN 2
8826: END
// every 0 0$2 trigger attacking do var aro , ar , uso , us , a , i ;
8827: LD_EXP 39
8831: IFFALSE 9093
8833: GO 8835
8835: DISABLE
8836: LD_INT 0
8838: PPUSH
8839: PPUSH
8840: PPUSH
8841: PPUSH
8842: PPUSH
8843: PPUSH
// begin aro := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8844: LD_ADDR_VAR 0 1
8848: PUSH
8849: LD_INT 22
8851: PUSH
8852: LD_EXP 4
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PPUSH
8861: CALL_OW 69
8865: PPUSH
8866: CALL_OW 256
8870: ST_TO_ADDR
// uso := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: LD_INT 22
8878: PUSH
8879: LD_EXP 1
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PPUSH
8888: CALL_OW 69
8892: PPUSH
8893: CALL_OW 256
8897: ST_TO_ADDR
// wait ( 0 0$2 ) ;
8898: LD_INT 70
8900: PPUSH
8901: CALL_OW 67
// while attacking do
8905: LD_EXP 39
8909: IFFALSE 9092
// begin ar := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_INT 22
8918: PUSH
8919: LD_EXP 4
8923: PUSH
8924: EMPTY
8925: LIST
8926: LIST
8927: PPUSH
8928: CALL_OW 69
8932: PPUSH
8933: CALL_OW 256
8937: ST_TO_ADDR
// us := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8938: LD_ADDR_VAR 0 4
8942: PUSH
8943: LD_INT 22
8945: PUSH
8946: LD_EXP 1
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: PPUSH
8955: CALL_OW 69
8959: PPUSH
8960: CALL_OW 256
8964: ST_TO_ADDR
// if ( aro - ar ) * 1.2 < uso - us then
8965: LD_VAR 0 1
8969: PUSH
8970: LD_VAR 0 2
8974: MINUS
8975: PUSH
8976: LD_REAL  1.20000000000000E+0000
8979: MUL
8980: PUSH
8981: LD_VAR 0 3
8985: PUSH
8986: LD_VAR 0 4
8990: MINUS
8991: LESS
8992: IFFALSE 9063
// begin a := FilterAllUnits ( [ f_side , arabians ] ) ;
8994: LD_ADDR_VAR 0 5
8998: PUSH
8999: LD_INT 22
9001: PUSH
9002: LD_EXP 4
9006: PUSH
9007: EMPTY
9008: LIST
9009: LIST
9010: PPUSH
9011: CALL_OW 69
9015: ST_TO_ADDR
// for i in a do
9016: LD_ADDR_VAR 0 6
9020: PUSH
9021: LD_VAR 0 5
9025: PUSH
9026: FOR_IN
9027: IFFALSE 9061
// if GetLives ( i ) < 400 then
9029: LD_VAR 0 6
9033: PPUSH
9034: CALL_OW 256
9038: PUSH
9039: LD_INT 400
9041: LESS
9042: IFFALSE 9059
// evade_shortest_way ( i , false , true ) ;
9044: LD_VAR 0 6
9048: PPUSH
9049: LD_INT 0
9051: PPUSH
9052: LD_INT 1
9054: PPUSH
9055: CALL 12836 0 3
9059: GO 9026
9061: POP
9062: POP
// end ; wait ( 0 0$0.5 ) ;
9063: LD_INT 18
9065: PPUSH
9066: CALL_OW 67
// aro := ar ;
9070: LD_ADDR_VAR 0 1
9074: PUSH
9075: LD_VAR 0 2
9079: ST_TO_ADDR
// uso := us ;
9080: LD_ADDR_VAR 0 3
9084: PUSH
9085: LD_VAR 0 4
9089: ST_TO_ADDR
// end ;
9090: GO 8905
// enable ;
9092: ENABLE
// end ;
9093: PPOPN 6
9095: END
// every 0 0$1.0 trigger not oma do
9096: LD_EXP 8
9100: NOT
9101: IFFALSE 9155
9103: GO 9105
9105: DISABLE
// begin attacking := false ;
9106: LD_ADDR_EXP 39
9110: PUSH
9111: LD_INT 0
9113: ST_TO_ADDR
// first_attack := false ;
9114: LD_ADDR_EXP 34
9118: PUSH
9119: LD_INT 0
9121: ST_TO_ADDR
// mine_attack := false ;
9122: LD_ADDR_EXP 35
9126: PUSH
9127: LD_INT 0
9129: ST_TO_ADDR
// thief_attack := false ;
9130: LD_ADDR_EXP 36
9134: PUSH
9135: LD_INT 0
9137: ST_TO_ADDR
// lonely_attack := false ;
9138: LD_ADDR_EXP 37
9142: PUSH
9143: LD_INT 0
9145: ST_TO_ADDR
// next_attack := false ;
9146: LD_ADDR_EXP 38
9150: PUSH
9151: LD_INT 0
9153: ST_TO_ADDR
// enable ;
9154: ENABLE
// end ;
9155: END
// every 0 0$1 do var a ;
9156: GO 9158
9158: DISABLE
9159: LD_INT 0
9161: PPUSH
// begin a :=  ;
9162: LD_ADDR_VAR 0 1
9166: PUSH
9167: LD_STRING 
9169: ST_TO_ADDR
// if attacking then
9170: LD_EXP 39
9174: IFFALSE 9190
// a := a &  attacking ;
9176: LD_ADDR_VAR 0 1
9180: PUSH
9181: LD_VAR 0 1
9185: PUSH
9186: LD_STRING  attacking
9188: STR
9189: ST_TO_ADDR
// if first_attack then
9190: LD_EXP 34
9194: IFFALSE 9210
// a := a &  first ;
9196: LD_ADDR_VAR 0 1
9200: PUSH
9201: LD_VAR 0 1
9205: PUSH
9206: LD_STRING  first
9208: STR
9209: ST_TO_ADDR
// if mine_attack then
9210: LD_EXP 35
9214: IFFALSE 9230
// a := a &  mine ;
9216: LD_ADDR_VAR 0 1
9220: PUSH
9221: LD_VAR 0 1
9225: PUSH
9226: LD_STRING  mine
9228: STR
9229: ST_TO_ADDR
// if thief_attack then
9230: LD_EXP 36
9234: IFFALSE 9250
// a := a &  thief ;
9236: LD_ADDR_VAR 0 1
9240: PUSH
9241: LD_VAR 0 1
9245: PUSH
9246: LD_STRING  thief
9248: STR
9249: ST_TO_ADDR
// if lonely_attack then
9250: LD_EXP 37
9254: IFFALSE 9270
// a := a &  lonely ;
9256: LD_ADDR_VAR 0 1
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_STRING  lonely
9268: STR
9269: ST_TO_ADDR
// if next_attack then
9270: LD_EXP 38
9274: IFFALSE 9290
// a := a &  next ;
9276: LD_ADDR_VAR 0 1
9280: PUSH
9281: LD_VAR 0 1
9285: PUSH
9286: LD_STRING  next
9288: STR
9289: ST_TO_ADDR
// debug_strings := [ a ] ;
9290: LD_ADDR_OWVAR 48
9294: PUSH
9295: LD_VAR 0 1
9299: PUSH
9300: EMPTY
9301: LIST
9302: ST_TO_ADDR
// enable ;
9303: ENABLE
// end ;
9304: PPOPN 1
9306: END
// function F_first_attack ; var i , r , amici , x , y , units , a , b ; begin
9307: LD_INT 0
9309: PPUSH
9310: PPUSH
9311: PPUSH
9312: PPUSH
9313: PPUSH
9314: PPUSH
9315: PPUSH
9316: PPUSH
9317: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9318: LD_ADDR_VAR 0 3
9322: PUSH
9323: LD_INT 1
9325: PPUSH
9326: LD_EXP 28
9330: PPUSH
9331: CALL_OW 12
9335: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9336: LD_ADDR_VAR 0 5
9340: PUSH
9341: LD_EXP 28
9345: PUSH
9346: LD_VAR 0 3
9350: ARRAY
9351: PUSH
9352: LD_INT 1
9354: ARRAY
9355: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9356: LD_ADDR_VAR 0 6
9360: PUSH
9361: LD_EXP 28
9365: PUSH
9366: LD_VAR 0 3
9370: ARRAY
9371: PUSH
9372: LD_INT 2
9374: ARRAY
9375: ST_TO_ADDR
// units := 2 ;
9376: LD_ADDR_VAR 0 7
9380: PUSH
9381: LD_INT 2
9383: ST_TO_ADDR
// a := make_arabs ( units , class_soldier ) ;
9384: LD_ADDR_VAR 0 8
9388: PUSH
9389: LD_VAR 0 7
9393: PPUSH
9394: LD_INT 1
9396: PPUSH
9397: CALL 1106 0 2
9401: ST_TO_ADDR
// for i in a do
9402: LD_ADDR_VAR 0 2
9406: PUSH
9407: LD_VAR 0 8
9411: PUSH
9412: FOR_IN
9413: IFFALSE 9442
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9415: LD_VAR 0 2
9419: PPUSH
9420: LD_VAR 0 5
9424: PPUSH
9425: LD_VAR 0 6
9429: PPUSH
9430: LD_INT 5
9432: PPUSH
9433: LD_INT 0
9435: PPUSH
9436: CALL_OW 50
9440: GO 9412
9442: POP
9443: POP
// r := Rand ( 1 , CameFromXY ) ;
9444: LD_ADDR_VAR 0 3
9448: PUSH
9449: LD_INT 1
9451: PPUSH
9452: LD_EXP 28
9456: PPUSH
9457: CALL_OW 12
9461: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9462: LD_ADDR_VAR 0 5
9466: PUSH
9467: LD_EXP 28
9471: PUSH
9472: LD_VAR 0 3
9476: ARRAY
9477: PUSH
9478: LD_INT 1
9480: ARRAY
9481: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9482: LD_ADDR_VAR 0 6
9486: PUSH
9487: LD_EXP 28
9491: PUSH
9492: LD_VAR 0 3
9496: ARRAY
9497: PUSH
9498: LD_INT 2
9500: ARRAY
9501: ST_TO_ADDR
// units := difficulty + 1 ;
9502: LD_ADDR_VAR 0 7
9506: PUSH
9507: LD_OWVAR 67
9511: PUSH
9512: LD_INT 1
9514: PLUS
9515: ST_TO_ADDR
// b := make_arabs ( units , class_soldier ) ;
9516: LD_ADDR_VAR 0 9
9520: PUSH
9521: LD_VAR 0 7
9525: PPUSH
9526: LD_INT 1
9528: PPUSH
9529: CALL 1106 0 2
9533: ST_TO_ADDR
// for i in b do
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 9
9543: PUSH
9544: FOR_IN
9545: IFFALSE 9574
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9547: LD_VAR 0 2
9551: PPUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: LD_VAR 0 6
9561: PPUSH
9562: LD_INT 5
9564: PPUSH
9565: LD_INT 0
9567: PPUSH
9568: CALL_OW 50
9572: GO 9544
9574: POP
9575: POP
// amici_b := budovy ;
9576: LD_ADDR_LOC 7
9580: PUSH
9581: LD_EXP 64
9585: ST_TO_ADDR
// amici_h := FilterAllUnits ( [ f_side , you ] ) ;
9586: LD_ADDR_LOC 6
9590: PUSH
9591: LD_INT 22
9593: PUSH
9594: LD_EXP 1
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 69
9607: ST_TO_ADDR
// away_from_last_attack := 0 ;
9608: LD_ADDR_EXP 33
9612: PUSH
9613: LD_INT 0
9615: ST_TO_ADDR
// make_mess := a ^ b ;
9616: LD_ADDR_LOC 9
9620: PUSH
9621: LD_VAR 0 8
9625: PUSH
9626: LD_VAR 0 9
9630: ADD
9631: ST_TO_ADDR
// if amici_b then
9632: LD_LOC 7
9636: IFFALSE 9677
// ComAgressiveMove ( make_mess , GetX ( amici_b [ 1 ] ) , GetY ( amici_b [ 1 ] ) ) else
9638: LD_LOC 9
9642: PPUSH
9643: LD_LOC 7
9647: PUSH
9648: LD_INT 1
9650: ARRAY
9651: PPUSH
9652: CALL_OW 250
9656: PPUSH
9657: LD_LOC 7
9661: PUSH
9662: LD_INT 1
9664: ARRAY
9665: PPUSH
9666: CALL_OW 251
9670: PPUSH
9671: CALL_OW 114
9675: GO 9714
// ComAgressiveMove ( make_mess , GetX ( amici_h [ 1 ] ) , GetY ( amici_h [ 1 ] ) ) ;
9677: LD_LOC 9
9681: PPUSH
9682: LD_LOC 6
9686: PUSH
9687: LD_INT 1
9689: ARRAY
9690: PPUSH
9691: CALL_OW 250
9695: PPUSH
9696: LD_LOC 6
9700: PUSH
9701: LD_INT 1
9703: ARRAY
9704: PPUSH
9705: CALL_OW 251
9709: PPUSH
9710: CALL_OW 114
// was_first_attack := true ;
9714: LD_ADDR_EXP 32
9718: PUSH
9719: LD_INT 1
9721: ST_TO_ADDR
// first_attack := true ;
9722: LD_ADDR_EXP 34
9726: PUSH
9727: LD_INT 1
9729: ST_TO_ADDR
// while see_any ( you , make_mess ) do
9730: LD_EXP 1
9734: PPUSH
9735: LD_LOC 9
9739: PPUSH
9740: CALL 13872 0 2
9744: IFFALSE 9755
// wait ( 0 0$0.5 ) ;
9746: LD_INT 18
9748: PPUSH
9749: CALL_OW 67
9753: GO 9730
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
9755: LD_ADDR_VAR 0 4
9759: PUSH
9760: LD_INT 22
9762: PUSH
9763: LD_EXP 1
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 101
9774: PUSH
9775: LD_EXP 4
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PPUSH
9788: CALL_OW 69
9792: ST_TO_ADDR
// if amici then
9793: LD_VAR 0 4
9797: IFFALSE 9836
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
9799: LD_LOC 9
9803: PPUSH
9804: LD_VAR 0 4
9808: PUSH
9809: LD_INT 1
9811: ARRAY
9812: PPUSH
9813: CALL_OW 250
9817: PPUSH
9818: LD_VAR 0 4
9822: PUSH
9823: LD_INT 1
9825: ARRAY
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: CALL_OW 114
// end ; end ;
9836: LD_VAR 0 1
9840: RET
// var set_charge , make_mess ; function F_mine_attack ; var i , r , amici , x , y , units , w_b , amici_b ; begin
9841: LD_INT 0
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
9848: PPUSH
9849: PPUSH
9850: PPUSH
9851: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9852: LD_ADDR_VAR 0 3
9856: PUSH
9857: LD_INT 1
9859: PPUSH
9860: LD_EXP 28
9864: PPUSH
9865: CALL_OW 12
9869: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9870: LD_ADDR_VAR 0 5
9874: PUSH
9875: LD_EXP 28
9879: PUSH
9880: LD_VAR 0 3
9884: ARRAY
9885: PUSH
9886: LD_INT 1
9888: ARRAY
9889: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9890: LD_ADDR_VAR 0 6
9894: PUSH
9895: LD_EXP 28
9899: PUSH
9900: LD_VAR 0 3
9904: ARRAY
9905: PUSH
9906: LD_INT 2
9908: ARRAY
9909: ST_TO_ADDR
// units := difficulty * 2 ;
9910: LD_ADDR_VAR 0 7
9914: PUSH
9915: LD_OWVAR 67
9919: PUSH
9920: LD_INT 2
9922: MUL
9923: ST_TO_ADDR
// amici_b := budovy ;
9924: LD_ADDR_VAR 0 9
9928: PUSH
9929: LD_EXP 64
9933: ST_TO_ADDR
// w_b := Rand ( 1 , ( amici_b + 0 ) ) ;
9934: LD_ADDR_VAR 0 8
9938: PUSH
9939: LD_INT 1
9941: PPUSH
9942: LD_VAR 0 9
9946: PUSH
9947: LD_INT 0
9949: PLUS
9950: PPUSH
9951: CALL_OW 12
9955: ST_TO_ADDR
// if amici_b then
9956: LD_VAR 0 9
9960: IFFALSE 10572
// begin make_mess := make_arabs ( units , class_soldier ) ;
9962: LD_ADDR_LOC 9
9966: PUSH
9967: LD_VAR 0 7
9971: PPUSH
9972: LD_INT 1
9974: PPUSH
9975: CALL 1106 0 2
9979: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
9980: LD_ADDR_VAR 0 7
9984: PUSH
9985: LD_LOC 9
9989: PUSH
9990: LD_INT 0
9992: PLUS
9993: ST_TO_ADDR
// for i in make_mess do
9994: LD_ADDR_VAR 0 2
9998: PUSH
9999: LD_LOC 9
10003: PUSH
10004: FOR_IN
10005: IFFALSE 10034
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
10007: LD_VAR 0 2
10011: PPUSH
10012: LD_VAR 0 5
10016: PPUSH
10017: LD_VAR 0 6
10021: PPUSH
10022: LD_INT 5
10024: PPUSH
10025: LD_INT 0
10027: PPUSH
10028: CALL_OW 50
10032: GO 10004
10034: POP
10035: POP
// away_from_last_attack := 0 ;
10036: LD_ADDR_EXP 33
10040: PUSH
10041: LD_INT 0
10043: ST_TO_ADDR
// set_charge := get_live_from_list ( make_mess , 0 , difficulty ) ;
10044: LD_ADDR_LOC 8
10048: PUSH
10049: LD_LOC 9
10053: PPUSH
10054: LD_INT 0
10056: PPUSH
10057: LD_OWVAR 67
10061: PPUSH
10062: CALL 13666 0 3
10066: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , difficulty , units - difficulty ) ;
10067: LD_ADDR_LOC 9
10071: PUSH
10072: LD_LOC 9
10076: PPUSH
10077: LD_OWVAR 67
10081: PPUSH
10082: LD_VAR 0 7
10086: PUSH
10087: LD_OWVAR 67
10091: MINUS
10092: PPUSH
10093: CALL 13666 0 3
10097: ST_TO_ADDR
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10098: LD_LOC 9
10102: PPUSH
10103: LD_VAR 0 9
10107: PUSH
10108: LD_VAR 0 8
10112: ARRAY
10113: PPUSH
10114: CALL_OW 250
10118: PPUSH
10119: LD_VAR 0 9
10123: PUSH
10124: LD_VAR 0 8
10128: ARRAY
10129: PPUSH
10130: CALL_OW 251
10134: PPUSH
10135: CALL_OW 114
// find_easiest_way ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , 7 , 3 , set_charge , you , false ) ;
10139: LD_VAR 0 9
10143: PUSH
10144: LD_VAR 0 8
10148: ARRAY
10149: PPUSH
10150: CALL_OW 250
10154: PPUSH
10155: LD_VAR 0 9
10159: PUSH
10160: LD_VAR 0 8
10164: ARRAY
10165: PPUSH
10166: CALL_OW 251
10170: PPUSH
10171: LD_INT 7
10173: PPUSH
10174: LD_INT 3
10176: PPUSH
10177: LD_LOC 8
10181: PPUSH
10182: LD_EXP 1
10186: PPUSH
10187: LD_INT 0
10189: PPUSH
10190: CALL 12294 0 7
// AddComPlaceDelayedCharge ( set_charge , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , amici_b [ w_b ] ) ;
10194: LD_LOC 8
10198: PPUSH
10199: LD_VAR 0 9
10203: PUSH
10204: LD_VAR 0 8
10208: ARRAY
10209: PPUSH
10210: CALL_OW 250
10214: PPUSH
10215: LD_VAR 0 9
10219: PUSH
10220: LD_VAR 0 8
10224: ARRAY
10225: PPUSH
10226: CALL_OW 251
10230: PPUSH
10231: LD_VAR 0 9
10235: PUSH
10236: LD_VAR 0 8
10240: ARRAY
10241: PPUSH
10242: CALL_OW 192
// evade_shortest_way_from_xy ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , set_charge , true , true ) ;
10246: LD_VAR 0 9
10250: PUSH
10251: LD_VAR 0 8
10255: ARRAY
10256: PPUSH
10257: CALL_OW 250
10261: PPUSH
10262: LD_VAR 0 9
10266: PUSH
10267: LD_VAR 0 8
10271: ARRAY
10272: PPUSH
10273: CALL_OW 251
10277: PPUSH
10278: LD_LOC 8
10282: PPUSH
10283: LD_INT 1
10285: PPUSH
10286: LD_INT 1
10288: PPUSH
10289: CALL 12923 0 5
// mine_attack := true ;
10293: LD_ADDR_EXP 35
10297: PUSH
10298: LD_INT 1
10300: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
10301: LD_EXP 1
10305: PPUSH
10306: LD_LOC 9
10310: PPUSH
10311: CALL 13872 0 2
10315: NOT
10316: IFFALSE 10327
// wait ( 0 0$0.5 ) ;
10318: LD_INT 18
10320: PPUSH
10321: CALL_OW 67
10325: GO 10301
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
10327: LD_ADDR_VAR 0 4
10331: PUSH
10332: LD_INT 22
10334: PUSH
10335: LD_EXP 1
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PUSH
10344: LD_INT 101
10346: PUSH
10347: LD_EXP 4
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: LD_INT 21
10358: PUSH
10359: LD_INT 1
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: PPUSH
10371: CALL_OW 69
10375: ST_TO_ADDR
// if amici then
10376: LD_VAR 0 4
10380: IFFALSE 10499
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
10382: LD_LOC 9
10386: PPUSH
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: CALL_OW 250
10400: PPUSH
10401: LD_VAR 0 4
10405: PUSH
10406: LD_INT 1
10408: ARRAY
10409: PPUSH
10410: CALL_OW 251
10414: PPUSH
10415: CALL_OW 114
// for i := 1 to amici do
10419: LD_ADDR_VAR 0 2
10423: PUSH
10424: DOUBLE
10425: LD_INT 1
10427: DEC
10428: ST_TO_ADDR
10429: LD_VAR 0 4
10433: PUSH
10434: FOR_TO
10435: IFFALSE 10480
// begin AddComAgressiveMove ( make_mess , GetX ( amici [ i ] ) , GetY ( amici [ i ] ) ) ;
10437: LD_LOC 9
10441: PPUSH
10442: LD_VAR 0 4
10446: PUSH
10447: LD_VAR 0 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 250
10457: PPUSH
10458: LD_VAR 0 4
10462: PUSH
10463: LD_VAR 0 2
10467: ARRAY
10468: PPUSH
10469: CALL_OW 251
10473: PPUSH
10474: CALL_OW 174
// end ;
10478: GO 10434
10480: POP
10481: POP
// evade_shortest_way ( make_mess , true , true ) ;
10482: LD_LOC 9
10486: PPUSH
10487: LD_INT 1
10489: PPUSH
10490: LD_INT 1
10492: PPUSH
10493: CALL 12836 0 3
// end else
10497: GO 10572
// begin if IsOk ( amici_b [ w_b ] ) then
10499: LD_VAR 0 9
10503: PUSH
10504: LD_VAR 0 8
10508: ARRAY
10509: PPUSH
10510: CALL_OW 302
10514: IFFALSE 10557
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10516: LD_LOC 9
10520: PPUSH
10521: LD_VAR 0 9
10525: PUSH
10526: LD_VAR 0 8
10530: ARRAY
10531: PPUSH
10532: CALL_OW 250
10536: PPUSH
10537: LD_VAR 0 9
10541: PUSH
10542: LD_VAR 0 8
10546: ARRAY
10547: PPUSH
10548: CALL_OW 251
10552: PPUSH
10553: CALL_OW 114
// evade_shortest_way ( make_mess , true , true ) ;
10557: LD_LOC 9
10561: PPUSH
10562: LD_INT 1
10564: PPUSH
10565: LD_INT 1
10567: PPUSH
10568: CALL 12836 0 3
// end ; end ; end ;
10572: LD_VAR 0 1
10576: RET
// var capcar1 , capcar2 ; var steal_car ; function F_thief_attack ; var i , r , x , y , units , amici3 ; begin
10577: LD_INT 0
10579: PPUSH
10580: PPUSH
10581: PPUSH
10582: PPUSH
10583: PPUSH
10584: PPUSH
10585: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
10586: LD_ADDR_VAR 0 3
10590: PUSH
10591: LD_INT 1
10593: PPUSH
10594: LD_EXP 28
10598: PPUSH
10599: CALL_OW 12
10603: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
10604: LD_ADDR_VAR 0 4
10608: PUSH
10609: LD_EXP 28
10613: PUSH
10614: LD_VAR 0 3
10618: ARRAY
10619: PUSH
10620: LD_INT 1
10622: ARRAY
10623: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
10624: LD_ADDR_VAR 0 5
10628: PUSH
10629: LD_EXP 28
10633: PUSH
10634: LD_VAR 0 3
10638: ARRAY
10639: PUSH
10640: LD_INT 2
10642: ARRAY
10643: ST_TO_ADDR
// units := 3 + difficulty + attacky div 7 + away_from_last_attack div 4 ;
10644: LD_ADDR_VAR 0 6
10648: PUSH
10649: LD_INT 3
10651: PUSH
10652: LD_OWVAR 67
10656: PLUS
10657: PUSH
10658: LD_EXP 40
10662: PUSH
10663: LD_INT 7
10665: DIV
10666: PLUS
10667: PUSH
10668: LD_EXP 33
10672: PUSH
10673: LD_INT 4
10675: DIV
10676: PLUS
10677: ST_TO_ADDR
// amici_v := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10678: LD_ADDR_LOC 5
10682: PUSH
10683: LD_INT 21
10685: PUSH
10686: LD_INT 2
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 22
10695: PUSH
10696: LD_EXP 1
10700: PUSH
10701: EMPTY
10702: LIST
10703: LIST
10704: PUSH
10705: EMPTY
10706: LIST
10707: LIST
10708: PPUSH
10709: CALL_OW 69
10713: ST_TO_ADDR
// if amici_v then
10714: LD_LOC 5
10718: IFFALSE 11316
// begin make_mess := make_arabs ( units , class_soldier ) ;
10720: LD_ADDR_LOC 9
10724: PUSH
10725: LD_VAR 0 6
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: CALL 1106 0 2
10737: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
10738: LD_ADDR_VAR 0 6
10742: PUSH
10743: LD_LOC 9
10747: PUSH
10748: LD_INT 0
10750: PLUS
10751: ST_TO_ADDR
// for i in make_mess do
10752: LD_ADDR_VAR 0 2
10756: PUSH
10757: LD_LOC 9
10761: PUSH
10762: FOR_IN
10763: IFFALSE 10792
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
10765: LD_VAR 0 2
10769: PPUSH
10770: LD_VAR 0 4
10774: PPUSH
10775: LD_VAR 0 5
10779: PPUSH
10780: LD_INT 5
10782: PPUSH
10783: LD_INT 0
10785: PPUSH
10786: CALL_OW 50
10790: GO 10762
10792: POP
10793: POP
// away_from_last_attack := 0 ;
10794: LD_ADDR_EXP 33
10798: PUSH
10799: LD_INT 0
10801: ST_TO_ADDR
// if difficulty > 1 then
10802: LD_OWVAR 67
10806: PUSH
10807: LD_INT 1
10809: GREATER
10810: IFFALSE 10862
// begin steal_car := get_live_from_list ( make_mess , 0 , 2 ) ;
10812: LD_ADDR_LOC 12
10816: PUSH
10817: LD_LOC 9
10821: PPUSH
10822: LD_INT 0
10824: PPUSH
10825: LD_INT 2
10827: PPUSH
10828: CALL 13666 0 3
10832: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 2 , units - 2 ) ;
10833: LD_ADDR_LOC 9
10837: PUSH
10838: LD_LOC 9
10842: PPUSH
10843: LD_INT 2
10845: PPUSH
10846: LD_VAR 0 6
10850: PUSH
10851: LD_INT 2
10853: MINUS
10854: PPUSH
10855: CALL 13666 0 3
10859: ST_TO_ADDR
// end else
10860: GO 10910
// begin steal_car := get_live_from_list ( make_mess , 0 , 1 ) ;
10862: LD_ADDR_LOC 12
10866: PUSH
10867: LD_LOC 9
10871: PPUSH
10872: LD_INT 0
10874: PPUSH
10875: LD_INT 1
10877: PPUSH
10878: CALL 13666 0 3
10882: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 1 , units - 1 ) ;
10883: LD_ADDR_LOC 9
10887: PUSH
10888: LD_LOC 9
10892: PPUSH
10893: LD_INT 1
10895: PPUSH
10896: LD_VAR 0 6
10900: PUSH
10901: LD_INT 1
10903: MINUS
10904: PPUSH
10905: CALL 13666 0 3
10909: ST_TO_ADDR
// end ; ComAgressiveMove ( make_mess , GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) ) ;
10910: LD_LOC 9
10914: PPUSH
10915: LD_LOC 5
10919: PUSH
10920: LD_INT 1
10922: ARRAY
10923: PPUSH
10924: CALL_OW 250
10928: PPUSH
10929: LD_LOC 5
10933: PUSH
10934: LD_INT 1
10936: ARRAY
10937: PPUSH
10938: CALL_OW 251
10942: PPUSH
10943: CALL_OW 114
// find_easiest_way ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , 7 , 3 , steal_car , you , false ) ;
10947: LD_LOC 5
10951: PUSH
10952: LD_INT 1
10954: ARRAY
10955: PPUSH
10956: CALL_OW 250
10960: PPUSH
10961: LD_LOC 5
10965: PUSH
10966: LD_INT 1
10968: ARRAY
10969: PPUSH
10970: CALL_OW 251
10974: PPUSH
10975: LD_INT 7
10977: PPUSH
10978: LD_INT 3
10980: PPUSH
10981: LD_LOC 12
10985: PPUSH
10986: LD_EXP 1
10990: PPUSH
10991: LD_INT 0
10993: PPUSH
10994: CALL 12294 0 7
// com_queue := true ;
10998: LD_ADDR_OWVAR 49
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// AddComEnterUnit ( steal_car , amici_v [ 1 ] ) ;
11006: LD_LOC 12
11010: PPUSH
11011: LD_LOC 5
11015: PUSH
11016: LD_INT 1
11018: ARRAY
11019: PPUSH
11020: CALL_OW 180
// com_queue := false ;
11024: LD_ADDR_OWVAR 49
11028: PUSH
11029: LD_INT 0
11031: ST_TO_ADDR
// evade_shortest_way_from_xy ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , steal_car , true , true ) ;
11032: LD_LOC 5
11036: PUSH
11037: LD_INT 1
11039: ARRAY
11040: PPUSH
11041: CALL_OW 250
11045: PPUSH
11046: LD_LOC 5
11050: PUSH
11051: LD_INT 1
11053: ARRAY
11054: PPUSH
11055: CALL_OW 251
11059: PPUSH
11060: LD_LOC 12
11064: PPUSH
11065: LD_INT 1
11067: PPUSH
11068: LD_INT 1
11070: PPUSH
11071: CALL 12923 0 5
// thief_attack := true ;
11075: LD_ADDR_EXP 36
11079: PUSH
11080: LD_INT 1
11082: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
11083: LD_EXP 1
11087: PPUSH
11088: LD_LOC 9
11092: PPUSH
11093: CALL 13872 0 2
11097: NOT
11098: IFFALSE 11109
// wait ( 0 0$0.5 ) ;
11100: LD_INT 18
11102: PPUSH
11103: CALL_OW 67
11107: GO 11083
// amici_b := FilterAllUnits ( [ f_type , unit_building ] ) ;
11109: LD_ADDR_LOC 7
11113: PUSH
11114: LD_INT 21
11116: PUSH
11117: LD_INT 3
11119: PUSH
11120: EMPTY
11121: LIST
11122: LIST
11123: PPUSH
11124: CALL_OW 69
11128: ST_TO_ADDR
// amici3 := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
11129: LD_ADDR_VAR 0 7
11133: PUSH
11134: LD_INT 22
11136: PUSH
11137: LD_EXP 1
11141: PUSH
11142: EMPTY
11143: LIST
11144: LIST
11145: PUSH
11146: LD_INT 101
11148: PUSH
11149: LD_EXP 4
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: LD_INT 21
11160: PUSH
11161: LD_INT 1
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: ST_TO_ADDR
// if amici3 then
11178: LD_VAR 0 7
11182: IFFALSE 11277
// begin ComAttackUnit ( make_mess , amici3 [ 1 ] ) ;
11184: LD_LOC 9
11188: PPUSH
11189: LD_VAR 0 7
11193: PUSH
11194: LD_INT 1
11196: ARRAY
11197: PPUSH
11198: CALL_OW 115
// for i := 2 to amici3 do
11202: LD_ADDR_VAR 0 2
11206: PUSH
11207: DOUBLE
11208: LD_INT 2
11210: DEC
11211: ST_TO_ADDR
11212: LD_VAR 0 7
11216: PUSH
11217: FOR_TO
11218: IFFALSE 11258
// begin com_queue := true ;
11220: LD_ADDR_OWVAR 49
11224: PUSH
11225: LD_INT 1
11227: ST_TO_ADDR
// ComAttackUnit ( make_mess , amici3 [ i ] ) ;
11228: LD_LOC 9
11232: PPUSH
11233: LD_VAR 0 7
11237: PUSH
11238: LD_VAR 0 2
11242: ARRAY
11243: PPUSH
11244: CALL_OW 115
// com_queue := false ;
11248: LD_ADDR_OWVAR 49
11252: PUSH
11253: LD_INT 0
11255: ST_TO_ADDR
// end ;
11256: GO 11217
11258: POP
11259: POP
// evade_shortest_way ( make_mess , true , true ) ;
11260: LD_LOC 9
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 1
11270: PPUSH
11271: CALL 12836 0 3
// end else
11275: GO 11316
// begin if amici_b then
11277: LD_LOC 7
11281: IFFALSE 11301
// ComAttackUnit ( make_mess , amici_b [ 1 ] ) ;
11283: LD_LOC 9
11287: PPUSH
11288: LD_LOC 7
11292: PUSH
11293: LD_INT 1
11295: ARRAY
11296: PPUSH
11297: CALL_OW 115
// evade_shortest_way ( make_mess , true , true ) ;
11301: LD_LOC 9
11305: PPUSH
11306: LD_INT 1
11308: PPUSH
11309: LD_INT 1
11311: PPUSH
11312: CALL 12836 0 3
// end ; end ; end ;
11316: LD_VAR 0 1
11320: RET
// function F_lonely_attack ( daleko ) ; var i , r , x , y , units ; begin
11321: LD_INT 0
11323: PPUSH
11324: PPUSH
11325: PPUSH
11326: PPUSH
11327: PPUSH
11328: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11329: LD_ADDR_VAR 0 4
11333: PUSH
11334: LD_INT 1
11336: PPUSH
11337: LD_EXP 28
11341: PPUSH
11342: CALL_OW 12
11346: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11347: LD_ADDR_VAR 0 5
11351: PUSH
11352: LD_EXP 28
11356: PUSH
11357: LD_VAR 0 4
11361: ARRAY
11362: PUSH
11363: LD_INT 1
11365: ARRAY
11366: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11367: LD_ADDR_VAR 0 6
11371: PUSH
11372: LD_EXP 28
11376: PUSH
11377: LD_VAR 0 4
11381: ARRAY
11382: PUSH
11383: LD_INT 2
11385: ARRAY
11386: ST_TO_ADDR
// units := 1 + difficulty ;
11387: LD_ADDR_VAR 0 7
11391: PUSH
11392: LD_INT 1
11394: PUSH
11395: LD_OWVAR 67
11399: PLUS
11400: ST_TO_ADDR
// if daleko then
11401: LD_VAR 0 1
11405: IFFALSE 11669
// begin make_mess := make_arabs ( units , class_soldier ) ;
11407: LD_ADDR_LOC 9
11411: PUSH
11412: LD_VAR 0 7
11416: PPUSH
11417: LD_INT 1
11419: PPUSH
11420: CALL 1106 0 2
11424: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11425: LD_ADDR_VAR 0 7
11429: PUSH
11430: LD_LOC 9
11434: PUSH
11435: LD_INT 0
11437: PLUS
11438: ST_TO_ADDR
// for i in make_mess do
11439: LD_ADDR_VAR 0 3
11443: PUSH
11444: LD_LOC 9
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11479
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11452: LD_VAR 0 3
11456: PPUSH
11457: LD_VAR 0 5
11461: PPUSH
11462: LD_VAR 0 6
11466: PPUSH
11467: LD_INT 5
11469: PPUSH
11470: LD_INT 0
11472: PPUSH
11473: CALL_OW 50
11477: GO 11449
11479: POP
11480: POP
// away_from_last_attack := 0 ;
11481: LD_ADDR_EXP 33
11485: PUSH
11486: LD_INT 0
11488: ST_TO_ADDR
// make_mess := make_mess ;
11489: LD_ADDR_LOC 9
11493: PUSH
11494: LD_LOC 9
11498: ST_TO_ADDR
// find_easiest_way ( GetX ( daleko [ 1 ] ) , GetY ( daleko [ 1 ] ) , 7 , 3 , make_mess , you , true ) ;
11499: LD_VAR 0 1
11503: PUSH
11504: LD_INT 1
11506: ARRAY
11507: PPUSH
11508: CALL_OW 250
11512: PPUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_INT 1
11520: ARRAY
11521: PPUSH
11522: CALL_OW 251
11526: PPUSH
11527: LD_INT 7
11529: PPUSH
11530: LD_INT 3
11532: PPUSH
11533: LD_LOC 9
11537: PPUSH
11538: LD_EXP 1
11542: PPUSH
11543: LD_INT 1
11545: PPUSH
11546: CALL 12294 0 7
// AddComAttackUnit ( make_mess , daleko [ 1 ] ) ;
11550: LD_LOC 9
11554: PPUSH
11555: LD_VAR 0 1
11559: PUSH
11560: LD_INT 1
11562: ARRAY
11563: PPUSH
11564: CALL_OW 175
// if daleko >= 2 then
11568: LD_VAR 0 1
11572: PUSH
11573: LD_INT 2
11575: GREATEREQUAL
11576: IFFALSE 11624
// begin AddComAttackUnit ( make_mess , daleko [ 2 ] ) ;
11578: LD_LOC 9
11582: PPUSH
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 2
11590: ARRAY
11591: PPUSH
11592: CALL_OW 175
// if daleko >= 3 then
11596: LD_VAR 0 1
11600: PUSH
11601: LD_INT 3
11603: GREATEREQUAL
11604: IFFALSE 11624
// begin AddComAttackUnit ( make_mess , daleko [ 3 ] ) ;
11606: LD_LOC 9
11610: PPUSH
11611: LD_VAR 0 1
11615: PUSH
11616: LD_INT 3
11618: ARRAY
11619: PPUSH
11620: CALL_OW 175
// end ; end ; evade_shortest_way ( make_mess , true , true ) ;
11624: LD_LOC 9
11628: PPUSH
11629: LD_INT 1
11631: PPUSH
11632: LD_INT 1
11634: PPUSH
11635: CALL 12836 0 3
// attacky := attacky + 1 ;
11639: LD_ADDR_EXP 40
11643: PUSH
11644: LD_EXP 40
11648: PUSH
11649: LD_INT 1
11651: PLUS
11652: ST_TO_ADDR
// lonely_attack := true ;
11653: LD_ADDR_EXP 37
11657: PUSH
11658: LD_INT 1
11660: ST_TO_ADDR
// attacking := true ;
11661: LD_ADDR_EXP 39
11665: PUSH
11666: LD_INT 1
11668: ST_TO_ADDR
// end ; end ;
11669: LD_VAR 0 2
11673: RET
// function F_next_attack ; var i , a , r , x , y , units , amici ; begin
11674: LD_INT 0
11676: PPUSH
11677: PPUSH
11678: PPUSH
11679: PPUSH
11680: PPUSH
11681: PPUSH
11682: PPUSH
11683: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11684: LD_ADDR_VAR 0 4
11688: PUSH
11689: LD_INT 1
11691: PPUSH
11692: LD_EXP 28
11696: PPUSH
11697: CALL_OW 12
11701: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11702: LD_ADDR_VAR 0 5
11706: PUSH
11707: LD_EXP 28
11711: PUSH
11712: LD_VAR 0 4
11716: ARRAY
11717: PUSH
11718: LD_INT 1
11720: ARRAY
11721: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11722: LD_ADDR_VAR 0 6
11726: PUSH
11727: LD_EXP 28
11731: PUSH
11732: LD_VAR 0 4
11736: ARRAY
11737: PUSH
11738: LD_INT 2
11740: ARRAY
11741: ST_TO_ADDR
// units := 2 + difficulty + away_from_last_attack div 8 + attacky div 8 ;
11742: LD_ADDR_VAR 0 7
11746: PUSH
11747: LD_INT 2
11749: PUSH
11750: LD_OWVAR 67
11754: PLUS
11755: PUSH
11756: LD_EXP 33
11760: PUSH
11761: LD_INT 8
11763: DIV
11764: PLUS
11765: PUSH
11766: LD_EXP 40
11770: PUSH
11771: LD_INT 8
11773: DIV
11774: PLUS
11775: ST_TO_ADDR
// make_mess := make_arabs ( units , class_soldier ) ;
11776: LD_ADDR_LOC 9
11780: PUSH
11781: LD_VAR 0 7
11785: PPUSH
11786: LD_INT 1
11788: PPUSH
11789: CALL 1106 0 2
11793: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11794: LD_ADDR_VAR 0 7
11798: PUSH
11799: LD_LOC 9
11803: PUSH
11804: LD_INT 0
11806: PLUS
11807: ST_TO_ADDR
// for i in make_mess do
11808: LD_ADDR_VAR 0 2
11812: PUSH
11813: LD_LOC 9
11817: PUSH
11818: FOR_IN
11819: IFFALSE 11848
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11821: LD_VAR 0 2
11825: PPUSH
11826: LD_VAR 0 5
11830: PPUSH
11831: LD_VAR 0 6
11835: PPUSH
11836: LD_INT 5
11838: PPUSH
11839: LD_INT 0
11841: PPUSH
11842: CALL_OW 50
11846: GO 11818
11848: POP
11849: POP
// away_from_last_attack := 0 ;
11850: LD_ADDR_EXP 33
11854: PUSH
11855: LD_INT 0
11857: ST_TO_ADDR
// make_mess := make_mess ;
11858: LD_ADDR_LOC 9
11862: PUSH
11863: LD_LOC 9
11867: ST_TO_ADDR
// a := Rand ( 1 , budovy ) ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: LD_INT 1
11875: PPUSH
11876: LD_EXP 64
11880: PPUSH
11881: CALL_OW 12
11885: ST_TO_ADDR
// if budovy then
11886: LD_EXP 64
11890: IFFALSE 11935
// ComAgressiveMove ( make_mess , GetX ( budovy [ a ] ) , GetY ( budovy [ a ] ) ) else
11892: LD_LOC 9
11896: PPUSH
11897: LD_EXP 64
11901: PUSH
11902: LD_VAR 0 3
11906: ARRAY
11907: PPUSH
11908: CALL_OW 250
11912: PPUSH
11913: LD_EXP 64
11917: PUSH
11918: LD_VAR 0 3
11922: ARRAY
11923: PPUSH
11924: CALL_OW 251
11928: PPUSH
11929: CALL_OW 114
11933: GO 11972
// ComAgressiveMove ( make_mess , GetX ( tvoji_lidi [ 1 ] ) , GetY ( tvoji_lidi [ 1 ] ) ) ;
11935: LD_LOC 9
11939: PPUSH
11940: LD_EXP 48
11944: PUSH
11945: LD_INT 1
11947: ARRAY
11948: PPUSH
11949: CALL_OW 250
11953: PPUSH
11954: LD_EXP 48
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: CALL_OW 251
11967: PPUSH
11968: CALL_OW 114
// next_attack := true ;
11972: LD_ADDR_EXP 38
11976: PUSH
11977: LD_INT 1
11979: ST_TO_ADDR
// attacky := attacky + 1 ;
11980: LD_ADDR_EXP 40
11984: PUSH
11985: LD_EXP 40
11989: PUSH
11990: LD_INT 1
11992: PLUS
11993: ST_TO_ADDR
// attacking := true ;
11994: LD_ADDR_EXP 39
11998: PUSH
11999: LD_INT 1
12001: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
12002: LD_EXP 1
12006: PPUSH
12007: LD_LOC 9
12011: PPUSH
12012: CALL 13872 0 2
12016: NOT
12017: IFFALSE 12028
// wait ( 0 0$0.5 ) ;
12019: LD_INT 18
12021: PPUSH
12022: CALL_OW 67
12026: GO 12002
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
12028: LD_ADDR_VAR 0 8
12032: PUSH
12033: LD_INT 22
12035: PUSH
12036: LD_EXP 1
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: LD_INT 101
12047: PUSH
12048: LD_EXP 4
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: EMPTY
12058: LIST
12059: LIST
12060: PPUSH
12061: CALL_OW 69
12065: ST_TO_ADDR
// if amici then
12066: LD_VAR 0 8
12070: IFFALSE 12111
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
12072: LD_LOC 9
12076: PPUSH
12077: LD_VAR 0 8
12081: PUSH
12082: LD_INT 1
12084: ARRAY
12085: PPUSH
12086: CALL_OW 250
12090: PPUSH
12091: LD_VAR 0 8
12095: PUSH
12096: LD_INT 1
12098: ARRAY
12099: PPUSH
12100: CALL_OW 251
12104: PPUSH
12105: CALL_OW 114
// end else
12109: GO 12142
// begin ComMoveXY ( make_mess , x , y ) ;
12111: LD_LOC 9
12115: PPUSH
12116: LD_VAR 0 5
12120: PPUSH
12121: LD_VAR 0 6
12125: PPUSH
12126: CALL_OW 111
// AddComMoveToArea ( make_mess , border ) ;
12130: LD_LOC 9
12134: PPUSH
12135: LD_INT 7
12137: PPUSH
12138: CALL_OW 173
// end ; end ;
12142: LD_VAR 0 1
12146: RET
// every 0 0$1.0 do
12147: GO 12149
12149: DISABLE
// begin enter_near_vehicle ( make_mess , 4 , FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ) ;
12150: LD_LOC 9
12154: PPUSH
12155: LD_INT 4
12157: PPUSH
12158: LD_INT 22
12160: PUSH
12161: LD_EXP 1
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: LD_INT 21
12172: PUSH
12173: LD_INT 2
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PPUSH
12184: CALL_OW 69
12188: PPUSH
12189: CALL 13943 0 3
// arabs_cars := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) ;
12193: LD_ADDR_EXP 10
12197: PUSH
12198: LD_INT 21
12200: PUSH
12201: LD_INT 2
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 22
12210: PUSH
12211: LD_EXP 4
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: PPUSH
12224: CALL_OW 69
12228: ST_TO_ADDR
// if arabs_cars then
12229: LD_EXP 10
12233: IFFALSE 12292
// begin if GetWeapon ( arabs_cars [ 1 ] ) <> us_cargo_bay then
12235: LD_EXP 10
12239: PUSH
12240: LD_INT 1
12242: ARRAY
12243: PPUSH
12244: CALL_OW 264
12248: PUSH
12249: LD_INT 12
12251: NONEQUAL
12252: IFFALSE 12280
// begin ComWait ( arabs_cars , 0 0$12 ) ;
12254: LD_EXP 10
12258: PPUSH
12259: LD_INT 420
12261: PPUSH
12262: CALL_OW 142
// AddComMoveToArea ( arabs_cars , border ) ;
12266: LD_EXP 10
12270: PPUSH
12271: LD_INT 7
12273: PPUSH
12274: CALL_OW 173
// end else
12278: GO 12292
// ComMoveToArea ( arabs_cars , border ) ;
12280: LD_EXP 10
12284: PPUSH
12285: LD_INT 7
12287: PPUSH
12288: CALL_OW 113
// end ; enable ;
12292: ENABLE
// end ; end_of_file
12293: END
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
12294: LD_INT 0
12296: PPUSH
12297: PPUSH
12298: PPUSH
12299: PPUSH
12300: PPUSH
12301: PPUSH
12302: PPUSH
12303: PPUSH
12304: PPUSH
12305: PPUSH
12306: PPUSH
12307: PPUSH
12308: PPUSH
12309: PPUSH
12310: PPUSH
// for for_unit in for_units do
12311: LD_ADDR_VAR 0 22
12315: PUSH
12316: LD_VAR 0 5
12320: PUSH
12321: FOR_IN
12322: IFFALSE 12829
// begin x := px ;
12324: LD_ADDR_VAR 0 9
12328: PUSH
12329: LD_VAR 0 1
12333: ST_TO_ADDR
// y := py ;
12334: LD_ADDR_VAR 0 10
12338: PUSH
12339: LD_VAR 0 2
12343: ST_TO_ADDR
// lx := px ;
12344: LD_ADDR_VAR 0 13
12348: PUSH
12349: LD_VAR 0 1
12353: ST_TO_ADDR
// ly := py ;
12354: LD_ADDR_VAR 0 14
12358: PUSH
12359: LD_VAR 0 2
12363: ST_TO_ADDR
// for j2 := 1 to hloubka do
12364: LD_ADDR_VAR 0 18
12368: PUSH
12369: DOUBLE
12370: LD_INT 1
12372: DEC
12373: ST_TO_ADDR
12374: LD_VAR 0 3
12378: PUSH
12379: FOR_TO
12380: IFFALSE 12712
// begin howgood := 50000 ;
12382: LD_ADDR_VAR 0 15
12386: PUSH
12387: LD_INT 50000
12389: ST_TO_ADDR
// smer := 0 ;
12390: LD_ADDR_VAR 0 16
12394: PUSH
12395: LD_INT 0
12397: ST_TO_ADDR
// kolem := 0 ;
12398: LD_ADDR_VAR 0 21
12402: PUSH
12403: LD_INT 0
12405: ST_TO_ADDR
// for i2 := 0 to 4 do
12406: LD_ADDR_VAR 0 17
12410: PUSH
12411: DOUBLE
12412: LD_INT 0
12414: DEC
12415: ST_TO_ADDR
12416: LD_INT 4
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12614
// begin x2 := ShiftX ( x , i2 , krok ) ;
12422: LD_ADDR_VAR 0 11
12426: PUSH
12427: LD_VAR 0 9
12431: PPUSH
12432: LD_VAR 0 17
12436: PPUSH
12437: LD_VAR 0 4
12441: PPUSH
12442: CALL_OW 272
12446: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
12447: LD_ADDR_VAR 0 12
12451: PUSH
12452: LD_VAR 0 10
12456: PPUSH
12457: LD_VAR 0 17
12461: PPUSH
12462: LD_VAR 0 4
12466: PPUSH
12467: CALL_OW 273
12471: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
12472: LD_ADDR_VAR 0 20
12476: PUSH
12477: LD_VAR 0 6
12481: PPUSH
12482: LD_VAR 0 11
12486: PPUSH
12487: LD_VAR 0 12
12491: PPUSH
12492: CALL_OW 293
12496: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
12497: LD_VAR 0 20
12501: PUSH
12502: LD_VAR 0 15
12506: LESS
12507: PUSH
12508: LD_VAR 0 1
12512: PPUSH
12513: LD_VAR 0 2
12517: PPUSH
12518: LD_VAR 0 9
12522: PPUSH
12523: LD_VAR 0 10
12527: PPUSH
12528: CALL_OW 298
12532: PUSH
12533: LD_VAR 0 1
12537: PPUSH
12538: LD_VAR 0 2
12542: PPUSH
12543: LD_VAR 0 11
12547: PPUSH
12548: LD_VAR 0 12
12552: PPUSH
12553: CALL_OW 298
12557: LESS
12558: AND
12559: IFFALSE 12596
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
12561: LD_ADDR_VAR 0 15
12565: PUSH
12566: LD_VAR 0 6
12570: PPUSH
12571: LD_VAR 0 11
12575: PPUSH
12576: LD_VAR 0 12
12580: PPUSH
12581: CALL_OW 293
12585: ST_TO_ADDR
// smer := i2 ;
12586: LD_ADDR_VAR 0 16
12590: PUSH
12591: LD_VAR 0 17
12595: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
12596: LD_ADDR_VAR 0 21
12600: PUSH
12601: LD_VAR 0 21
12605: PUSH
12606: LD_VAR 0 20
12610: PLUS
12611: ST_TO_ADDR
// end ;
12612: GO 12419
12614: POP
12615: POP
// x := ShiftX ( x , smer , krok ) ;
12616: LD_ADDR_VAR 0 9
12620: PUSH
12621: LD_VAR 0 9
12625: PPUSH
12626: LD_VAR 0 16
12630: PPUSH
12631: LD_VAR 0 4
12635: PPUSH
12636: CALL_OW 272
12640: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
12641: LD_ADDR_VAR 0 10
12645: PUSH
12646: LD_VAR 0 10
12650: PPUSH
12651: LD_VAR 0 16
12655: PPUSH
12656: LD_VAR 0 4
12660: PPUSH
12661: CALL_OW 273
12665: ST_TO_ADDR
// lx := lx ^ x ;
12666: LD_ADDR_VAR 0 13
12670: PUSH
12671: LD_VAR 0 13
12675: PUSH
12676: LD_VAR 0 9
12680: ADD
12681: ST_TO_ADDR
// ly := ly ^ y ;
12682: LD_ADDR_VAR 0 14
12686: PUSH
12687: LD_VAR 0 14
12691: PUSH
12692: LD_VAR 0 10
12696: ADD
12697: ST_TO_ADDR
// if kolem = 0 then
12698: LD_VAR 0 21
12702: PUSH
12703: LD_INT 0
12705: EQUAL
12706: IFFALSE 12710
// break ;
12708: GO 12712
// end ;
12710: GO 12379
12712: POP
12713: POP
// for j2 := ( lx + 0 ) downto 1 do
12714: LD_ADDR_VAR 0 18
12718: PUSH
12719: DOUBLE
12720: LD_VAR 0 13
12724: PUSH
12725: LD_INT 0
12727: PLUS
12728: INC
12729: ST_TO_ADDR
12730: LD_INT 1
12732: PUSH
12733: FOR_DOWNTO
12734: IFFALSE 12825
// begin if not queue and j2 = ( lx + 0 ) then
12736: LD_VAR 0 7
12740: NOT
12741: PUSH
12742: LD_VAR 0 18
12746: PUSH
12747: LD_VAR 0 13
12751: PUSH
12752: LD_INT 0
12754: PLUS
12755: EQUAL
12756: AND
12757: IFFALSE 12792
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
12759: LD_VAR 0 22
12763: PPUSH
12764: LD_VAR 0 13
12768: PUSH
12769: LD_VAR 0 18
12773: ARRAY
12774: PPUSH
12775: LD_VAR 0 14
12779: PUSH
12780: LD_VAR 0 18
12784: ARRAY
12785: PPUSH
12786: CALL_OW 111
12790: GO 12823
// begin AddComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
12792: LD_VAR 0 22
12796: PPUSH
12797: LD_VAR 0 13
12801: PUSH
12802: LD_VAR 0 18
12806: ARRAY
12807: PPUSH
12808: LD_VAR 0 14
12812: PUSH
12813: LD_VAR 0 18
12817: ARRAY
12818: PPUSH
12819: CALL_OW 171
// end ; end ;
12823: GO 12733
12825: POP
12826: POP
// end ;
12827: GO 12321
12829: POP
12830: POP
// end ;
12831: LD_VAR 0 8
12835: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
// for for_unit in for_units do
12842: LD_ADDR_VAR 0 5
12846: PUSH
12847: LD_VAR 0 1
12851: PUSH
12852: FOR_IN
12853: IFFALSE 12916
// begin unx := GetX ( for_unit ) ;
12855: LD_ADDR_VAR 0 6
12859: PUSH
12860: LD_VAR 0 5
12864: PPUSH
12865: CALL_OW 250
12869: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
12870: LD_ADDR_VAR 0 7
12874: PUSH
12875: LD_VAR 0 5
12879: PPUSH
12880: CALL_OW 251
12884: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
12885: LD_VAR 0 6
12889: PPUSH
12890: LD_VAR 0 7
12894: PPUSH
12895: LD_VAR 0 5
12899: PPUSH
12900: LD_VAR 0 2
12904: PPUSH
12905: LD_VAR 0 3
12909: PPUSH
12910: CALL 12923 0 5
// end ;
12914: GO 12852
12916: POP
12917: POP
// end ;
12918: LD_VAR 0 4
12922: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
12923: LD_INT 0
12925: PPUSH
12926: PPUSH
12927: PPUSH
12928: PPUSH
12929: PPUSH
12930: PPUSH
12931: PPUSH
// for for_unit in for_units do
12932: LD_ADDR_VAR 0 12
12936: PUSH
12937: LD_VAR 0 3
12941: PUSH
12942: FOR_IN
12943: IFFALSE 13659
// begin foundswD := 50000 ;
12945: LD_ADDR_VAR 0 9
12949: PUSH
12950: LD_INT 50000
12952: ST_TO_ADDR
// eswTX := 0 ;
12953: LD_ADDR_VAR 0 10
12957: PUSH
12958: LD_INT 0
12960: ST_TO_ADDR
// eswTY := 0 ;
12961: LD_ADDR_VAR 0 11
12965: PUSH
12966: LD_INT 0
12968: ST_TO_ADDR
// while eswTX < map_size_x do
12969: LD_VAR 0 10
12973: PUSH
12974: LD_EXP 29
12978: LESS
12979: IFFALSE 13079
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
12981: LD_VAR 0 1
12985: PPUSH
12986: LD_VAR 0 2
12990: PPUSH
12991: LD_VAR 0 10
12995: PPUSH
12996: LD_VAR 0 11
13000: PPUSH
13001: CALL_OW 298
13005: PUSH
13006: LD_VAR 0 9
13010: LESS
13011: IFFALSE 13063
// begin foundswX := eswTX ;
13013: LD_ADDR_VAR 0 7
13017: PUSH
13018: LD_VAR 0 10
13022: ST_TO_ADDR
// foundswY := eswTY ;
13023: LD_ADDR_VAR 0 8
13027: PUSH
13028: LD_VAR 0 11
13032: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13033: LD_ADDR_VAR 0 9
13037: PUSH
13038: LD_VAR 0 1
13042: PPUSH
13043: LD_VAR 0 2
13047: PPUSH
13048: LD_VAR 0 10
13052: PPUSH
13053: LD_VAR 0 11
13057: PPUSH
13058: CALL_OW 298
13062: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
13063: LD_ADDR_VAR 0 10
13067: PUSH
13068: LD_VAR 0 10
13072: PUSH
13073: LD_INT 10
13075: PLUS
13076: ST_TO_ADDR
// end ;
13077: GO 12969
// eswTX := map_size_x div 2 ;
13079: LD_ADDR_VAR 0 10
13083: PUSH
13084: LD_EXP 29
13088: PUSH
13089: LD_INT 2
13091: DIV
13092: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
13093: LD_ADDR_VAR 0 11
13097: PUSH
13098: LD_EXP 30
13102: PUSH
13103: LD_INT 1
13105: MINUS
13106: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
13107: LD_VAR 0 10
13111: PUSH
13112: LD_EXP 29
13116: PUSH
13117: LD_EXP 29
13121: PUSH
13122: LD_INT 2
13124: DIV
13125: PLUS
13126: LESS
13127: IFFALSE 13227
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13129: LD_VAR 0 1
13133: PPUSH
13134: LD_VAR 0 2
13138: PPUSH
13139: LD_VAR 0 10
13143: PPUSH
13144: LD_VAR 0 11
13148: PPUSH
13149: CALL_OW 298
13153: PUSH
13154: LD_VAR 0 9
13158: LESS
13159: IFFALSE 13211
// begin foundswX := eswTX ;
13161: LD_ADDR_VAR 0 7
13165: PUSH
13166: LD_VAR 0 10
13170: ST_TO_ADDR
// foundswY := eswTY ;
13171: LD_ADDR_VAR 0 8
13175: PUSH
13176: LD_VAR 0 11
13180: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13181: LD_ADDR_VAR 0 9
13185: PUSH
13186: LD_VAR 0 1
13190: PPUSH
13191: LD_VAR 0 2
13195: PPUSH
13196: LD_VAR 0 10
13200: PPUSH
13201: LD_VAR 0 11
13205: PPUSH
13206: CALL_OW 298
13210: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
13211: LD_ADDR_VAR 0 10
13215: PUSH
13216: LD_VAR 0 10
13220: PUSH
13221: LD_INT 10
13223: PLUS
13224: ST_TO_ADDR
// end ;
13225: GO 13107
// eswTX := 0 ;
13227: LD_ADDR_VAR 0 10
13231: PUSH
13232: LD_INT 0
13234: ST_TO_ADDR
// eswTY := 0 ;
13235: LD_ADDR_VAR 0 11
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13243: LD_VAR 0 11
13247: PUSH
13248: LD_EXP 30
13252: LESS
13253: IFFALSE 13367
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13255: LD_VAR 0 1
13259: PPUSH
13260: LD_VAR 0 2
13264: PPUSH
13265: LD_VAR 0 10
13269: PPUSH
13270: LD_VAR 0 11
13274: PPUSH
13275: CALL_OW 298
13279: PUSH
13280: LD_VAR 0 9
13284: LESS
13285: IFFALSE 13337
// begin foundswX := eswTX ;
13287: LD_ADDR_VAR 0 7
13291: PUSH
13292: LD_VAR 0 10
13296: ST_TO_ADDR
// foundswY := eswTY ;
13297: LD_ADDR_VAR 0 8
13301: PUSH
13302: LD_VAR 0 11
13306: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13307: LD_ADDR_VAR 0 9
13311: PUSH
13312: LD_VAR 0 1
13316: PPUSH
13317: LD_VAR 0 2
13321: PPUSH
13322: LD_VAR 0 10
13326: PPUSH
13327: LD_VAR 0 11
13331: PPUSH
13332: CALL_OW 298
13336: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13337: LD_ADDR_VAR 0 11
13341: PUSH
13342: LD_VAR 0 11
13346: PUSH
13347: LD_INT 10
13349: PLUS
13350: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13351: LD_ADDR_VAR 0 10
13355: PUSH
13356: LD_VAR 0 10
13360: PUSH
13361: LD_INT 5
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13243
// eswTX := map_size_x ;
13367: LD_ADDR_VAR 0 10
13371: PUSH
13372: LD_EXP 29
13376: ST_TO_ADDR
// eswTY := 1 ;
13377: LD_ADDR_VAR 0 11
13381: PUSH
13382: LD_INT 1
13384: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13385: LD_VAR 0 11
13389: PUSH
13390: LD_EXP 30
13394: LESS
13395: IFFALSE 13509
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13397: LD_VAR 0 1
13401: PPUSH
13402: LD_VAR 0 2
13406: PPUSH
13407: LD_VAR 0 10
13411: PPUSH
13412: LD_VAR 0 11
13416: PPUSH
13417: CALL_OW 298
13421: PUSH
13422: LD_VAR 0 9
13426: LESS
13427: IFFALSE 13479
// begin foundswX := eswTX ;
13429: LD_ADDR_VAR 0 7
13433: PUSH
13434: LD_VAR 0 10
13438: ST_TO_ADDR
// foundswY := eswTY ;
13439: LD_ADDR_VAR 0 8
13443: PUSH
13444: LD_VAR 0 11
13448: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13449: LD_ADDR_VAR 0 9
13453: PUSH
13454: LD_VAR 0 1
13458: PPUSH
13459: LD_VAR 0 2
13463: PPUSH
13464: LD_VAR 0 10
13468: PPUSH
13469: LD_VAR 0 11
13473: PPUSH
13474: CALL_OW 298
13478: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13479: LD_ADDR_VAR 0 11
13483: PUSH
13484: LD_VAR 0 11
13488: PUSH
13489: LD_INT 10
13491: PLUS
13492: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13493: LD_ADDR_VAR 0 10
13497: PUSH
13498: LD_VAR 0 10
13502: PUSH
13503: LD_INT 5
13505: PLUS
13506: ST_TO_ADDR
// end ;
13507: GO 13385
// if queue then
13509: LD_VAR 0 4
13513: IFFALSE 13587
// begin if agressive then
13515: LD_VAR 0 5
13519: IFFALSE 13554
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13521: LD_VAR 0 12
13525: PPUSH
13526: LD_VAR 0 7
13530: PPUSH
13531: LD_VAR 0 8
13535: PPUSH
13536: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
13540: LD_VAR 0 12
13544: PPUSH
13545: LD_INT 7
13547: PPUSH
13548: CALL_OW 173
// end else
13552: GO 13585
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
13554: LD_VAR 0 12
13558: PPUSH
13559: LD_VAR 0 7
13563: PPUSH
13564: LD_VAR 0 8
13568: PPUSH
13569: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
13573: LD_VAR 0 12
13577: PPUSH
13578: LD_INT 7
13580: PPUSH
13581: CALL_OW 173
// end ; end else
13585: GO 13657
// begin if agressive then
13587: LD_VAR 0 5
13591: IFFALSE 13626
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13593: LD_VAR 0 12
13597: PPUSH
13598: LD_VAR 0 7
13602: PPUSH
13603: LD_VAR 0 8
13607: PPUSH
13608: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
13612: LD_VAR 0 12
13616: PPUSH
13617: LD_INT 7
13619: PPUSH
13620: CALL_OW 173
// end else
13624: GO 13657
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
13626: LD_VAR 0 12
13630: PPUSH
13631: LD_VAR 0 7
13635: PPUSH
13636: LD_VAR 0 8
13640: PPUSH
13641: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
13645: LD_VAR 0 12
13649: PPUSH
13650: LD_INT 7
13652: PPUSH
13653: CALL_OW 173
// end ; end ; end ;
13657: GO 12942
13659: POP
13660: POP
// end ;
13661: LD_VAR 0 6
13665: RET
// export function get_live_from_list ( sez1 , skip , pocet ) ; var un1 , count , max , skiped ; var list ; begin
13666: LD_INT 0
13668: PPUSH
13669: PPUSH
13670: PPUSH
13671: PPUSH
13672: PPUSH
13673: PPUSH
// un1 := 1 ;
13674: LD_ADDR_VAR 0 5
13678: PUSH
13679: LD_INT 1
13681: ST_TO_ADDR
// count := 0 ;
13682: LD_ADDR_VAR 0 6
13686: PUSH
13687: LD_INT 0
13689: ST_TO_ADDR
// skiped := 0 ;
13690: LD_ADDR_VAR 0 8
13694: PUSH
13695: LD_INT 0
13697: ST_TO_ADDR
// max := ( sez1 + 0 ) ;
13698: LD_ADDR_VAR 0 7
13702: PUSH
13703: LD_VAR 0 1
13707: PUSH
13708: LD_INT 0
13710: PLUS
13711: ST_TO_ADDR
// while un1 <= max and count < pocet do
13712: LD_VAR 0 5
13716: PUSH
13717: LD_VAR 0 7
13721: LESSEQUAL
13722: PUSH
13723: LD_VAR 0 6
13727: PUSH
13728: LD_VAR 0 3
13732: LESS
13733: AND
13734: IFFALSE 13857
// begin if IsLive ( sez1 [ un1 ] ) then
13736: LD_VAR 0 1
13740: PUSH
13741: LD_VAR 0 5
13745: ARRAY
13746: PPUSH
13747: CALL_OW 300
13751: IFFALSE 13841
// begin if skiped >= skip then
13753: LD_VAR 0 8
13757: PUSH
13758: LD_VAR 0 2
13762: GREATEREQUAL
13763: IFFALSE 13827
// begin if list then
13765: LD_VAR 0 9
13769: IFFALSE 13795
// list := list ^ sez1 [ un1 ] else
13771: LD_ADDR_VAR 0 9
13775: PUSH
13776: LD_VAR 0 9
13780: PUSH
13781: LD_VAR 0 1
13785: PUSH
13786: LD_VAR 0 5
13790: ARRAY
13791: ADD
13792: ST_TO_ADDR
13793: GO 13811
// list := sez1 [ un1 ] ;
13795: LD_ADDR_VAR 0 9
13799: PUSH
13800: LD_VAR 0 1
13804: PUSH
13805: LD_VAR 0 5
13809: ARRAY
13810: ST_TO_ADDR
// count := count + 1 ;
13811: LD_ADDR_VAR 0 6
13815: PUSH
13816: LD_VAR 0 6
13820: PUSH
13821: LD_INT 1
13823: PLUS
13824: ST_TO_ADDR
// end else
13825: GO 13841
// begin skiped := skiped + 1 ;
13827: LD_ADDR_VAR 0 8
13831: PUSH
13832: LD_VAR 0 8
13836: PUSH
13837: LD_INT 1
13839: PLUS
13840: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
13841: LD_ADDR_VAR 0 5
13845: PUSH
13846: LD_VAR 0 5
13850: PUSH
13851: LD_INT 1
13853: PLUS
13854: ST_TO_ADDR
// end ;
13855: GO 13712
// result := list ;
13857: LD_ADDR_VAR 0 4
13861: PUSH
13862: LD_VAR 0 9
13866: ST_TO_ADDR
// end ;
13867: LD_VAR 0 4
13871: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
13872: LD_INT 0
13874: PPUSH
13875: PPUSH
13876: PPUSH
// see_any_r := false ;
13877: LD_ADDR_VAR 0 5
13881: PUSH
13882: LD_INT 0
13884: ST_TO_ADDR
// for sai in sez2 do
13885: LD_ADDR_VAR 0 4
13889: PUSH
13890: LD_VAR 0 2
13894: PUSH
13895: FOR_IN
13896: IFFALSE 13926
// if See ( strana , sai ) then
13898: LD_VAR 0 1
13902: PPUSH
13903: LD_VAR 0 4
13907: PPUSH
13908: CALL_OW 292
13912: IFFALSE 13924
// begin see_any_r := true ;
13914: LD_ADDR_VAR 0 5
13918: PUSH
13919: LD_INT 1
13921: ST_TO_ADDR
// break ;
13922: GO 13926
// end ;
13924: GO 13895
13926: POP
13927: POP
// ; result := see_any_r ;
13928: LD_ADDR_VAR 0 3
13932: PUSH
13933: LD_VAR 0 5
13937: ST_TO_ADDR
// end ;
13938: LD_VAR 0 3
13942: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
13948: PPUSH
// for i in who do
13949: LD_ADDR_VAR 0 6
13953: PUSH
13954: LD_VAR 0 1
13958: PUSH
13959: FOR_IN
13960: IFFALSE 14031
// begin for j in what do
13962: LD_ADDR_VAR 0 7
13966: PUSH
13967: LD_VAR 0 3
13971: PUSH
13972: FOR_IN
13973: IFFALSE 14027
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
13975: LD_VAR 0 7
13979: PPUSH
13980: CALL_OW 311
13984: NOT
13985: PUSH
13986: LD_VAR 0 6
13990: PPUSH
13991: LD_VAR 0 7
13995: PPUSH
13996: CALL_OW 296
14000: PUSH
14001: LD_VAR 0 2
14005: LESSEQUAL
14006: AND
14007: IFFALSE 14025
// begin ComEnterUnit ( i , j ) ;
14009: LD_VAR 0 6
14013: PPUSH
14014: LD_VAR 0 7
14018: PPUSH
14019: CALL_OW 120
// break ;
14023: GO 14027
// end ; end ;
14025: GO 13972
14027: POP
14028: POP
// end ;
14029: GO 13959
14031: POP
14032: POP
// end ;
14033: LD_VAR 0 4
14037: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
14038: LD_INT 0
14040: PPUSH
14041: PPUSH
14042: PPUSH
14043: PPUSH
// for i in who do
14044: LD_ADDR_VAR 0 6
14048: PUSH
14049: LD_VAR 0 1
14053: PUSH
14054: FOR_IN
14055: IFFALSE 14154
// begin add := false ;
14057: LD_ADDR_VAR 0 5
14061: PUSH
14062: LD_INT 0
14064: ST_TO_ADDR
// for j in what do
14065: LD_ADDR_VAR 0 7
14069: PUSH
14070: LD_VAR 0 3
14074: PUSH
14075: FOR_IN
14076: IFFALSE 14110
// begin if GetDistUnits ( i , j ) <= dist then
14078: LD_VAR 0 6
14082: PPUSH
14083: LD_VAR 0 7
14087: PPUSH
14088: CALL_OW 296
14092: PUSH
14093: LD_VAR 0 2
14097: LESSEQUAL
14098: IFFALSE 14108
// begin add := true ;
14100: LD_ADDR_VAR 0 5
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// end ; end ;
14108: GO 14075
14110: POP
14111: POP
// if add then
14112: LD_VAR 0 5
14116: IFFALSE 14152
// begin if result then
14118: LD_VAR 0 4
14122: IFFALSE 14142
// result := result ^ i else
14124: LD_ADDR_VAR 0 4
14128: PUSH
14129: LD_VAR 0 4
14133: PUSH
14134: LD_VAR 0 6
14138: ADD
14139: ST_TO_ADDR
14140: GO 14152
// result := i ;
14142: LD_ADDR_VAR 0 4
14146: PUSH
14147: LD_VAR 0 6
14151: ST_TO_ADDR
// end ; end ;
14152: GO 14054
14154: POP
14155: POP
// end ;
14156: LD_VAR 0 4
14160: RET
// export function comqb ; begin
14161: LD_INT 0
14163: PPUSH
// com_queue := true ;
14164: LD_ADDR_OWVAR 49
14168: PUSH
14169: LD_INT 1
14171: ST_TO_ADDR
// end ;
14172: LD_VAR 0 1
14176: RET
// export function comqe ; begin
14177: LD_INT 0
14179: PPUSH
// com_queue := false ;
14180: LD_ADDR_OWVAR 49
14184: PUSH
14185: LD_INT 0
14187: ST_TO_ADDR
// end ;
14188: LD_VAR 0 1
14192: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
14193: LD_INT 0
14195: PPUSH
14196: PPUSH
14197: PPUSH
// i1 := 1 ;
14198: LD_ADDR_VAR 0 5
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// while i1 <= path do
14206: LD_VAR 0 5
14210: PUSH
14211: LD_VAR 0 2
14215: LESSEQUAL
14216: IFFALSE 14463
// begin a := path [ i1 ] ;
14218: LD_ADDR_VAR 0 6
14222: PUSH
14223: LD_VAR 0 2
14227: PUSH
14228: LD_VAR 0 5
14232: ARRAY
14233: ST_TO_ADDR
// if a < 0 then
14234: LD_VAR 0 6
14238: PUSH
14239: LD_INT 0
14241: LESS
14242: IFFALSE 14299
// begin while a <= - 1 do
14244: LD_VAR 0 6
14248: PUSH
14249: LD_INT 1
14251: NEG
14252: LESSEQUAL
14253: IFFALSE 14283
// begin a := a + 1 ;
14255: LD_ADDR_VAR 0 6
14259: PUSH
14260: LD_VAR 0 6
14264: PUSH
14265: LD_INT 1
14267: PLUS
14268: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
14269: LD_VAR 0 1
14273: PPUSH
14274: LD_INT 35
14276: PPUSH
14277: CALL_OW 202
// end ;
14281: GO 14244
// i1 := i1 + 1 ;
14283: LD_ADDR_VAR 0 5
14287: PUSH
14288: LD_VAR 0 5
14292: PUSH
14293: LD_INT 1
14295: PLUS
14296: ST_TO_ADDR
// end else
14297: GO 14461
// begin if a = 0 then
14299: LD_VAR 0 6
14303: PUSH
14304: LD_INT 0
14306: EQUAL
14307: IFFALSE 14369
// begin a := path [ i1 + 1 ] ;
14309: LD_ADDR_VAR 0 6
14313: PUSH
14314: LD_VAR 0 2
14318: PUSH
14319: LD_VAR 0 5
14323: PUSH
14324: LD_INT 1
14326: PLUS
14327: ARRAY
14328: ST_TO_ADDR
// if a = 0 then
14329: LD_VAR 0 6
14333: PUSH
14334: LD_INT 0
14336: EQUAL
14337: IFFALSE 14348
// AddComReturn ( for_units ) ;
14339: LD_VAR 0 1
14343: PPUSH
14344: CALL_OW 204
// if a = 1 then
14348: LD_VAR 0 6
14352: PUSH
14353: LD_INT 1
14355: EQUAL
14356: IFFALSE 14367
// AddComRemember ( for_units ) ;
14358: LD_VAR 0 1
14362: PPUSH
14363: CALL_OW 203
// end else
14367: GO 14447
// begin if agressive then
14369: LD_VAR 0 3
14373: IFFALSE 14412
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
14375: LD_VAR 0 1
14379: PPUSH
14380: LD_VAR 0 2
14384: PUSH
14385: LD_VAR 0 5
14389: ARRAY
14390: PPUSH
14391: LD_VAR 0 2
14395: PUSH
14396: LD_VAR 0 5
14400: PUSH
14401: LD_INT 1
14403: PLUS
14404: ARRAY
14405: PPUSH
14406: CALL_OW 174
14410: GO 14447
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
14412: LD_VAR 0 1
14416: PPUSH
14417: LD_VAR 0 2
14421: PUSH
14422: LD_VAR 0 5
14426: ARRAY
14427: PPUSH
14428: LD_VAR 0 2
14432: PUSH
14433: LD_VAR 0 5
14437: PUSH
14438: LD_INT 1
14440: PLUS
14441: ARRAY
14442: PPUSH
14443: CALL_OW 171
// end ; i1 := i1 + 2 ;
14447: LD_ADDR_VAR 0 5
14451: PUSH
14452: LD_VAR 0 5
14456: PUSH
14457: LD_INT 2
14459: PLUS
14460: ST_TO_ADDR
// end ; end ;
14461: GO 14206
// end ;
14463: LD_VAR 0 4
14467: RET
// export function find_drivers ( cars , drivers ) ; var empty , free , i , konec ; begin
14468: LD_INT 0
14470: PPUSH
14471: PPUSH
14472: PPUSH
14473: PPUSH
14474: PPUSH
// cars := cars union [ ] ;
14475: LD_ADDR_VAR 0 1
14479: PUSH
14480: LD_VAR 0 1
14484: PUSH
14485: EMPTY
14486: UNION
14487: ST_TO_ADDR
// drivers := drivers union [ ] ;
14488: LD_ADDR_VAR 0 2
14492: PUSH
14493: LD_VAR 0 2
14497: PUSH
14498: EMPTY
14499: UNION
14500: ST_TO_ADDR
// for i in cars do
14501: LD_ADDR_VAR 0 6
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: FOR_IN
14512: IFFALSE 14548
// if not IsDrivenBy ( i ) then
14514: LD_VAR 0 6
14518: PPUSH
14519: CALL_OW 311
14523: NOT
14524: IFFALSE 14546
// empty := add ( empty , i ) ;
14526: LD_ADDR_VAR 0 4
14530: PUSH
14531: LD_VAR 0 4
14535: PPUSH
14536: LD_VAR 0 6
14540: PPUSH
14541: CALL 14837 0 2
14545: ST_TO_ADDR
14546: GO 14511
14548: POP
14549: POP
// for i in drivers do
14550: LD_ADDR_VAR 0 6
14554: PUSH
14555: LD_VAR 0 2
14559: PUSH
14560: FOR_IN
14561: IFFALSE 14597
// if not IsInUnit ( i ) then
14563: LD_VAR 0 6
14567: PPUSH
14568: CALL_OW 310
14572: NOT
14573: IFFALSE 14595
// free := add ( free , i ) ;
14575: LD_ADDR_VAR 0 5
14579: PUSH
14580: LD_VAR 0 5
14584: PPUSH
14585: LD_VAR 0 6
14589: PPUSH
14590: CALL 14837 0 2
14594: ST_TO_ADDR
14595: GO 14560
14597: POP
14598: POP
// result := cars diff empty ;
14599: LD_ADDR_VAR 0 3
14603: PUSH
14604: LD_VAR 0 1
14608: PUSH
14609: LD_VAR 0 4
14613: DIFF
14614: ST_TO_ADDR
// if empty <= free then
14615: LD_VAR 0 4
14619: PUSH
14620: LD_VAR 0 5
14624: LESSEQUAL
14625: IFFALSE 14639
// konec := empty else
14627: LD_ADDR_VAR 0 7
14631: PUSH
14632: LD_VAR 0 4
14636: ST_TO_ADDR
14637: GO 14649
// konec := free ;
14639: LD_ADDR_VAR 0 7
14643: PUSH
14644: LD_VAR 0 5
14648: ST_TO_ADDR
// for i := 1 to konec do
14649: LD_ADDR_VAR 0 6
14653: PUSH
14654: DOUBLE
14655: LD_INT 1
14657: DEC
14658: ST_TO_ADDR
14659: LD_VAR 0 7
14663: PUSH
14664: FOR_TO
14665: IFFALSE 14721
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
14667: LD_VAR 0 5
14671: PUSH
14672: LD_VAR 0 6
14676: ARRAY
14677: PPUSH
14678: LD_VAR 0 4
14682: PUSH
14683: LD_VAR 0 6
14687: ARRAY
14688: PPUSH
14689: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
14693: LD_ADDR_VAR 0 3
14697: PUSH
14698: LD_VAR 0 3
14702: PPUSH
14703: LD_VAR 0 4
14707: PUSH
14708: LD_VAR 0 6
14712: ARRAY
14713: PPUSH
14714: CALL 14837 0 2
14718: ST_TO_ADDR
// end ;
14719: GO 14664
14721: POP
14722: POP
// end ;
14723: LD_VAR 0 3
14727: RET
// export function rand_xy_in_map ; var x , y ; begin
14728: LD_INT 0
14730: PPUSH
14731: PPUSH
14732: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
14733: LD_ADDR_VAR 0 3
14737: PUSH
14738: LD_INT 2
14740: PPUSH
14741: LD_EXP 30
14745: PUSH
14746: LD_INT 2
14748: MINUS
14749: PPUSH
14750: CALL_OW 12
14754: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
14755: LD_ADDR_VAR 0 2
14759: PUSH
14760: LD_VAR 0 3
14764: PUSH
14765: LD_INT 2
14767: DIV
14768: PUSH
14769: LD_INT 2
14771: PLUS
14772: PPUSH
14773: LD_EXP 29
14777: PUSH
14778: LD_VAR 0 3
14782: PUSH
14783: LD_INT 2
14785: DIV
14786: PLUS
14787: PUSH
14788: LD_INT 2
14790: MINUS
14791: PPUSH
14792: CALL_OW 12
14796: ST_TO_ADDR
// result := [ x , y ] ;
14797: LD_ADDR_VAR 0 1
14801: PUSH
14802: LD_VAR 0 2
14806: PUSH
14807: LD_VAR 0 3
14811: PUSH
14812: EMPTY
14813: LIST
14814: LIST
14815: ST_TO_ADDR
// end ;
14816: LD_VAR 0 1
14820: RET
// export function TalkOn ; begin
14821: LD_INT 0
14823: PPUSH
// end ;
14824: LD_VAR 0 1
14828: RET
// export function TalkOff ; begin
14829: LD_INT 0
14831: PPUSH
// end ;
14832: LD_VAR 0 1
14836: RET
// export function add ( list , list1 ) ; begin
14837: LD_INT 0
14839: PPUSH
// if list = 0 then
14840: LD_VAR 0 1
14844: PUSH
14845: LD_INT 0
14847: EQUAL
14848: IFFALSE 14857
// list := [ ] ;
14850: LD_ADDR_VAR 0 1
14854: PUSH
14855: EMPTY
14856: ST_TO_ADDR
// if list1 = 0 then
14857: LD_VAR 0 2
14861: PUSH
14862: LD_INT 0
14864: EQUAL
14865: IFFALSE 14874
// list1 := [ ] ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: EMPTY
14873: ST_TO_ADDR
// result := list ^ list1 ;
14874: LD_ADDR_VAR 0 3
14878: PUSH
14879: LD_VAR 0 1
14883: PUSH
14884: LD_VAR 0 2
14888: ADD
14889: ST_TO_ADDR
// end ;
14890: LD_VAR 0 3
14894: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
14895: LD_INT 0
14897: PPUSH
14898: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
14899: LD_ADDR_VAR 0 8
14903: PUSH
14904: LD_VAR 0 1
14908: PPUSH
14909: LD_VAR 0 3
14913: PPUSH
14914: LD_VAR 0 4
14918: PPUSH
14919: LD_VAR 0 5
14923: PPUSH
14924: LD_VAR 0 6
14928: PPUSH
14929: CALL 14975 0 5
14933: ST_TO_ADDR
// if kdo then
14934: LD_VAR 0 8
14938: IFFALSE 14962
// result := Say ( kdo , ident ) else
14940: LD_ADDR_VAR 0 7
14944: PUSH
14945: LD_VAR 0 8
14949: PPUSH
14950: LD_VAR 0 2
14954: PPUSH
14955: CALL_OW 88
14959: ST_TO_ADDR
14960: GO 14970
// result := false ;
14962: LD_ADDR_VAR 0 7
14966: PUSH
14967: LD_INT 0
14969: ST_TO_ADDR
// end ;
14970: LD_VAR 0 7
14974: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
14975: LD_INT 0
14977: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
14978: LD_ADDR_VAR 0 1
14982: PUSH
14983: LD_VAR 0 1
14987: PPUSH
14988: LD_INT 21
14990: PUSH
14991: LD_INT 1
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 22
15000: PUSH
15001: LD_VAR 0 2
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PUSH
15010: LD_INT 3
15012: PUSH
15013: LD_INT 23
15015: PUSH
15016: LD_INT 0
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: PPUSH
15029: CALL_OW 72
15033: ST_TO_ADDR
// if sex <> 0 then
15034: LD_VAR 0 3
15038: PUSH
15039: LD_INT 0
15041: NONEQUAL
15042: IFFALSE 15071
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
15044: LD_ADDR_VAR 0 1
15048: PUSH
15049: LD_VAR 0 1
15053: PPUSH
15054: LD_INT 26
15056: PUSH
15057: LD_VAR 0 3
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: PPUSH
15066: CALL_OW 72
15070: ST_TO_ADDR
// if Hclass <> 0 then
15071: LD_VAR 0 4
15075: PUSH
15076: LD_INT 0
15078: NONEQUAL
15079: IFFALSE 15108
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
15081: LD_ADDR_VAR 0 1
15085: PUSH
15086: LD_VAR 0 1
15090: PPUSH
15091: LD_INT 25
15093: PUSH
15094: LD_VAR 0 4
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: PPUSH
15103: CALL_OW 72
15107: ST_TO_ADDR
// if index <= 0 then
15108: LD_VAR 0 5
15112: PUSH
15113: LD_INT 0
15115: LESSEQUAL
15116: IFFALSE 15126
// index := 1 ;
15118: LD_ADDR_VAR 0 5
15122: PUSH
15123: LD_INT 1
15125: ST_TO_ADDR
// if lidi >= index then
15126: LD_VAR 0 1
15130: PUSH
15131: LD_VAR 0 5
15135: GREATEREQUAL
15136: IFFALSE 15156
// result := lidi [ index ] else
15138: LD_ADDR_VAR 0 6
15142: PUSH
15143: LD_VAR 0 1
15147: PUSH
15148: LD_VAR 0 5
15152: ARRAY
15153: ST_TO_ADDR
15154: GO 15164
// result := 0 ;
15156: LD_ADDR_VAR 0 6
15160: PUSH
15161: LD_INT 0
15163: ST_TO_ADDR
// end ;
15164: LD_VAR 0 6
15168: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
15169: LD_INT 0
15171: PPUSH
// if not hinty_co_byli then
15172: LD_EXP 66
15176: NOT
15177: IFFALSE 15186
// hinty_co_byli := [ ] ;
15179: LD_ADDR_EXP 66
15183: PUSH
15184: EMPTY
15185: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
15186: LD_VAR 0 1
15190: PUSH
15191: LD_EXP 66
15195: IN
15196: NOT
15197: IFFALSE 15224
// begin hinty_co_byli := hinty_co_byli ^ ident ;
15199: LD_ADDR_EXP 66
15203: PUSH
15204: LD_EXP 66
15208: PUSH
15209: LD_VAR 0 1
15213: ADD
15214: ST_TO_ADDR
// Hint ( ident ) ;
15215: LD_VAR 0 1
15219: PPUSH
15220: CALL_OW 339
// end ; end ; end_of_file
15224: LD_VAR 0 2
15228: RET
// every 0 0$2 + 0 0$0.1 do
15229: GO 15231
15231: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
15232: LD_INT 22
15234: PUSH
15235: LD_INT 1
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PUSH
15242: LD_INT 2
15244: PUSH
15245: LD_INT 25
15247: PUSH
15248: LD_INT 12
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: PUSH
15255: LD_INT 25
15257: PUSH
15258: LD_INT 16
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: PUSH
15265: LD_INT 25
15267: PUSH
15268: LD_INT 15
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 25
15277: PUSH
15278: LD_INT 17
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: LIST
15289: LIST
15290: LIST
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PPUSH
15296: CALL_OW 69
15300: PUSH
15301: LD_INT 22
15303: PUSH
15304: LD_INT 1
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 21
15313: PUSH
15314: LD_INT 1
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: LD_INT 2
15326: PUSH
15327: LD_INT 25
15329: PUSH
15330: LD_INT 12
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 25
15339: PUSH
15340: LD_INT 16
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 25
15349: PUSH
15350: LD_INT 15
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: LD_INT 25
15359: PUSH
15360: LD_INT 17
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: LIST
15382: PPUSH
15383: CALL_OW 69
15387: GREATER
15388: IFFALSE 15399
// begin SetAchievement ( ACH_POTA ) ;
15390: LD_STRING ACH_POTA
15392: PPUSH
15393: CALL_OW 543
// exit ;
15397: GO 15400
// end ; enable ;
15399: ENABLE
// end ;
15400: END
// export function SA_TamedAllApeman ; begin
15401: LD_INT 0
15403: PPUSH
// SetAchievement ( ACH_FDA ) ;
15404: LD_STRING ACH_FDA
15406: PPUSH
15407: CALL_OW 543
// end ;
15411: LD_VAR 0 1
15415: RET
// export function SA_LikeAWind ; begin
15416: LD_INT 0
15418: PPUSH
// SetAchievement ( ACH_WND ) ;
15419: LD_STRING ACH_WND
15421: PPUSH
15422: CALL_OW 543
// end ;
15426: LD_VAR 0 1
15430: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) >= apemans_amount_on_start do
15431: LD_INT 22
15433: PUSH
15434: LD_INT 1
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: PUSH
15441: LD_INT 2
15443: PUSH
15444: LD_INT 25
15446: PUSH
15447: LD_INT 12
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: LD_INT 25
15456: PUSH
15457: LD_INT 16
15459: PUSH
15460: EMPTY
15461: LIST
15462: LIST
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: LIST
15468: PUSH
15469: EMPTY
15470: LIST
15471: LIST
15472: PPUSH
15473: CALL_OW 69
15477: PUSH
15478: LD_EXP 7
15482: GREATEREQUAL
15483: IFFALSE 15495
15485: GO 15487
15487: DISABLE
// SetAchievement ( ACH_FDA ) ; end_of_file
15488: LD_STRING ACH_FDA
15490: PPUSH
15491: CALL_OW 543
15495: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
15496: LD_INT 0
15498: PPUSH
15499: PPUSH
// if not missionNumber then
15500: LD_VAR 0 2
15504: NOT
15505: IFFALSE 15509
// exit ;
15507: GO 15639
// achiv := false ;
15509: LD_ADDR_VAR 0 7
15513: PUSH
15514: LD_INT 0
15516: ST_TO_ADDR
// case campaignNumber of 1 :
15517: LD_VAR 0 1
15521: PUSH
15522: LD_INT 1
15524: DOUBLE
15525: EQUAL
15526: IFTRUE 15530
15528: GO 15541
15530: POP
// achiv := ACH_GOTA ; 2 :
15531: LD_ADDR_VAR 0 7
15535: PUSH
15536: LD_STRING ACH_GOTA
15538: ST_TO_ADDR
15539: GO 15591
15541: LD_INT 2
15543: DOUBLE
15544: EQUAL
15545: IFTRUE 15549
15547: GO 15552
15549: POP
// ; 3 :
15550: GO 15591
15552: LD_INT 3
15554: DOUBLE
15555: EQUAL
15556: IFTRUE 15560
15558: GO 15571
15560: POP
// achiv := ACH_MOTSU ; 4 :
15561: LD_ADDR_VAR 0 7
15565: PUSH
15566: LD_STRING ACH_MOTSU
15568: ST_TO_ADDR
15569: GO 15591
15571: LD_INT 4
15573: DOUBLE
15574: EQUAL
15575: IFTRUE 15579
15577: GO 15590
15579: POP
// achiv := ACH_LOP ; end ;
15580: LD_ADDR_VAR 0 7
15584: PUSH
15585: LD_STRING ACH_LOP
15587: ST_TO_ADDR
15588: GO 15591
15590: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
15591: LD_OWVAR 67
15595: PUSH
15596: LD_INT 3
15598: EQUAL
15599: PUSH
15600: LD_VAR 0 7
15604: AND
15605: PUSH
15606: LD_VAR 0 3
15610: AND
15611: PUSH
15612: LD_VAR 0 4
15616: AND
15617: PUSH
15618: LD_VAR 0 5
15622: AND
15623: IFFALSE 15639
// SetAchievementEX ( achiv , missionNumber ) ;
15625: LD_VAR 0 7
15629: PPUSH
15630: LD_VAR 0 2
15634: PPUSH
15635: CALL_OW 564
// end ;
15639: LD_VAR 0 6
15643: RET
// export function SA_BehemothConstructed ; begin
15644: LD_INT 0
15646: PPUSH
// SetAchievement ( ACH_SMC ) ;
15647: LD_STRING ACH_SMC
15649: PPUSH
15650: CALL_OW 543
// end ;
15654: LD_VAR 0 1
15658: RET

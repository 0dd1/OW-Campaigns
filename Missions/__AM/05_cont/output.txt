// export you , you2 , russians , arabians , neutral ; export apemans , apemans_amount_on_start ; export oma ; export om ; export arabs_cars ; export JMM ; export Glad ; export Har ; export Den , Lisa , Frank ; export Don , Brown ; export Bobby , Cyrus ; export Denis ; export Sol1 , Sol2 , Sci ; export Car1 , Car2 , Car3 ; export CameFromXY ; export map_size_x , map_size_y ; export first_ape ; export was_first_attack ; export away_from_last_attack ; export first_attack ; export mine_attack ; export thief_attack ; export lonely_attack ; export next_attack ; export attacking ; export attacky ; export opic ; export cil_mit_1_ape_eng_splnen ; export cil_mit_5_ape_eng_splnen ; export zasilka_muze ; export zasilka_landed ; export denis_can_come ; export RadarBuild ; export tvoji_lidi ; export not_char ; export opicaci ; export ztraty ; export uz_je_cas ; export added_apes ; export max_added_apes ; export mat_crates ; export all , used , other ; export Gamma2Commander ; starting begin map_size_x := 100 ;
   0: LD_ADDR_EXP 29
   4: PUSH
   5: LD_INT 100
   7: ST_TO_ADDR
// map_size_y := 80 ;
   8: LD_ADDR_EXP 30
  12: PUSH
  13: LD_INT 80
  15: ST_TO_ADDR
// prepare_sides ;
  16: CALL 980 0 0
// prepare_yours_cars ;
  20: CALL 299 0 0
// load_units ;
  24: CALL 481 0 0
// SetDifficulty ;
  28: CALL 1048 0 0
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
  32: LD_ADDR_EXP 6
  36: PUSH
  37: LD_INT 23
  39: PUSH
  40: LD_INT 0
  42: PUSH
  43: EMPTY
  44: LIST
  45: LIST
  46: PUSH
  47: EMPTY
  48: LIST
  49: PPUSH
  50: CALL_OW 69
  54: ST_TO_ADDR
// apemans_amount_on_start := ( apemans + 0 ) ;
  55: LD_ADDR_EXP 7
  59: PUSH
  60: LD_EXP 6
  64: PUSH
  65: LD_INT 0
  67: PLUS
  68: ST_TO_ADDR
// was_first_attack := false ;
  69: LD_ADDR_EXP 32
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// first_attack := false ;
  77: LD_ADDR_EXP 34
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// mine_attack := false ;
  85: LD_ADDR_EXP 35
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// thief_attack := false ;
  93: LD_ADDR_EXP 36
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// lonely_attack := false ;
 101: LD_ADDR_EXP 37
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// next_attack := false ;
 109: LD_ADDR_EXP 38
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// attacking := false ;
 117: LD_ADDR_EXP 39
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// attacky := 0 ;
 125: LD_ADDR_EXP 40
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// CameFromXY := [ [ 110 , 31 ] , [ 106 , 23 ] , [ 123 , 74 ] , [ 120 , 74 ] , [ 74 , 6 ] , [ 83 , 75 ] , [ 39 , 4 ] ] ;
 133: LD_ADDR_EXP 28
 137: PUSH
 138: LD_INT 110
 140: PUSH
 141: LD_INT 31
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: PUSH
 148: LD_INT 106
 150: PUSH
 151: LD_INT 23
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: PUSH
 158: LD_INT 123
 160: PUSH
 161: LD_INT 74
 163: PUSH
 164: EMPTY
 165: LIST
 166: LIST
 167: PUSH
 168: LD_INT 120
 170: PUSH
 171: LD_INT 74
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 74
 180: PUSH
 181: LD_INT 6
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 83
 190: PUSH
 191: LD_INT 75
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: PUSH
 198: LD_INT 39
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: PUSH
 208: EMPTY
 209: LIST
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: LIST
 215: LIST
 216: ST_TO_ADDR
// opic := 0 ;
 217: LD_ADDR_EXP 41
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// zasilka_muze := false ;
 225: LD_ADDR_EXP 44
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// denis_can_come := false ;
 233: LD_ADDR_EXP 46
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// budovy := [ ] ;
 241: LD_ADDR_EXP 64
 245: PUSH
 246: EMPTY
 247: ST_TO_ADDR
// laboratore := [ ] ;
 248: LD_ADDR_EXP 63
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// tvoji_lidi := [ ] ;
 255: LD_ADDR_EXP 48
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// ztraty := 0 ;
 262: LD_ADDR_EXP 51
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// added_apes := 0 ;
 270: LD_ADDR_EXP 53
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// max_added_apes := 10 ;
 278: LD_ADDR_EXP 54
 282: PUSH
 283: LD_INT 10
 285: ST_TO_ADDR
// uz_je_cas := false ;
 286: LD_ADDR_EXP 52
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// Dialog1 ;
 294: CALL 3373 0 0
// end ;
 298: END
// function prepare_yours_cars ; begin
 299: LD_INT 0
 301: PPUSH
// InitUc ;
 302: CALL_OW 18
// InitHc ;
 306: CALL_OW 19
// InitVc ;
 310: CALL_OW 20
// uc_side := you ;
 314: LD_ADDR_OWVAR 20
 318: PUSH
 319: LD_EXP 1
 323: ST_TO_ADDR
// uc_nation := nation_american ;
 324: LD_ADDR_OWVAR 21
 328: PUSH
 329: LD_INT 1
 331: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 332: LD_ADDR_OWVAR 37
 336: PUSH
 337: LD_INT 1
 339: ST_TO_ADDR
// vc_control := control_manual ;
 340: LD_ADDR_OWVAR 38
 344: PUSH
 345: LD_INT 1
 347: ST_TO_ADDR
// vc_engine := engine_solar ;
 348: LD_ADDR_OWVAR 39
 352: PUSH
 353: LD_INT 2
 355: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 356: LD_ADDR_OWVAR 40
 360: PUSH
 361: LD_INT 2
 363: ST_TO_ADDR
// Car1 := CreateVehicle ;
 364: LD_ADDR_EXP 25
 368: PUSH
 369: CALL_OW 45
 373: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 374: LD_ADDR_OWVAR 37
 378: PUSH
 379: LD_INT 1
 381: ST_TO_ADDR
// vc_control := control_manual ;
 382: LD_ADDR_OWVAR 38
 386: PUSH
 387: LD_INT 1
 389: ST_TO_ADDR
// vc_engine := engine_solar ;
 390: LD_ADDR_OWVAR 39
 394: PUSH
 395: LD_INT 2
 397: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 398: LD_ADDR_OWVAR 40
 402: PUSH
 403: LD_INT 2
 405: ST_TO_ADDR
// Car2 := CreateVehicle ;
 406: LD_ADDR_EXP 26
 410: PUSH
 411: CALL_OW 45
 415: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
 416: LD_ADDR_OWVAR 37
 420: PUSH
 421: LD_INT 2
 423: ST_TO_ADDR
// vc_control := control_manual ;
 424: LD_ADDR_OWVAR 38
 428: PUSH
 429: LD_INT 1
 431: ST_TO_ADDR
// vc_engine := engine_solar ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_INT 2
 439: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
 440: LD_ADDR_OWVAR 40
 444: PUSH
 445: LD_INT 12
 447: ST_TO_ADDR
// Car3 := CreateVehicle ;
 448: LD_ADDR_EXP 27
 452: PUSH
 453: CALL_OW 45
 457: ST_TO_ADDR
// SetCargo ( [ Car3 ] , mat_cans , 100 ) ;
 458: LD_EXP 27
 462: PUSH
 463: EMPTY
 464: LIST
 465: PPUSH
 466: LD_INT 1
 468: PPUSH
 469: LD_INT 100
 471: PPUSH
 472: CALL_OW 290
// end ;
 476: LD_VAR 0 1
 480: RET
// function load_units ; begin
 481: LD_INT 0
 483: PPUSH
// InitUc ;
 484: CALL_OW 18
// InitHc ;
 488: CALL_OW 19
// InitVc ;
 492: CALL_OW 20
// uc_side := you ;
 496: LD_ADDR_OWVAR 20
 500: PUSH
 501: LD_EXP 1
 505: ST_TO_ADDR
// uc_nation := nation_american ;
 506: LD_ADDR_OWVAR 21
 510: PUSH
 511: LD_INT 1
 513: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 514: LD_ADDR_EXP 11
 518: PUSH
 519: LD_STRING JMM
 521: PPUSH
 522: CALL_OW 34
 526: ST_TO_ADDR
// Glad := CreateCharacter ( Gladstone ) ;
 527: LD_ADDR_EXP 12
 531: PUSH
 532: LD_STRING Gladstone
 534: PPUSH
 535: CALL_OW 34
 539: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 540: LD_ADDR_EXP 13
 544: PUSH
 545: LD_STRING Harisson
 547: PPUSH
 548: CALL_OW 25
 552: ST_TO_ADDR
// Denis := NewCharacter ( Denis ) ;
 553: LD_ADDR_EXP 21
 557: PUSH
 558: LD_STRING Denis
 560: PPUSH
 561: CALL_OW 25
 565: ST_TO_ADDR
// if TestCharacters ( otherDelta ) then
 566: LD_STRING otherDelta
 568: PPUSH
 569: CALL_OW 28
 573: IFFALSE 590
// used := CreateCharacterSet ( otherDelta ) else
 575: LD_ADDR_EXP 57
 579: PUSH
 580: LD_STRING otherDelta
 582: PPUSH
 583: CALL_OW 31
 587: ST_TO_ADDR
 588: GO 597
// used := [ ] ;
 590: LD_ADDR_EXP 57
 594: PUSH
 595: EMPTY
 596: ST_TO_ADDR
// Lisa := 0 ;
 597: LD_ADDR_EXP 15
 601: PUSH
 602: LD_INT 0
 604: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 605: LD_STRING Lisa
 607: PPUSH
 608: CALL_OW 29
 612: IFFALSE 643
// if LoadVariable ( LisaLoc , 0 ) = 3 then
 614: LD_STRING LisaLoc
 616: PPUSH
 617: LD_INT 0
 619: PPUSH
 620: CALL_OW 30
 624: PUSH
 625: LD_INT 3
 627: EQUAL
 628: IFFALSE 643
// Lisa := CreateCharacter ( Lisa ) ;
 630: LD_ADDR_EXP 15
 634: PUSH
 635: LD_STRING Lisa
 637: PPUSH
 638: CALL_OW 34
 642: ST_TO_ADDR
// Cyrus := 0 ;
 643: LD_ADDR_EXP 20
 647: PUSH
 648: LD_INT 0
 650: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 651: LD_STRING Cyrus
 653: PPUSH
 654: CALL_OW 29
 658: IFFALSE 689
// if LoadVariable ( CyrusLoc , 0 ) = 3 then
 660: LD_STRING CyrusLoc
 662: PPUSH
 663: LD_INT 0
 665: PPUSH
 666: CALL_OW 30
 670: PUSH
 671: LD_INT 3
 673: EQUAL
 674: IFFALSE 689
// Cyrus := CreateCharacter ( Cyrus ) ;
 676: LD_ADDR_EXP 20
 680: PUSH
 681: LD_STRING Cyrus
 683: PPUSH
 684: CALL_OW 34
 688: ST_TO_ADDR
// Bobby := 0 ;
 689: LD_ADDR_EXP 19
 693: PUSH
 694: LD_INT 0
 696: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 697: LD_STRING Bobby
 699: PPUSH
 700: CALL_OW 29
 704: IFFALSE 735
// if LoadVariable ( BobbyLoc , 0 ) = 3 then
 706: LD_STRING BobbyLoc
 708: PPUSH
 709: LD_INT 0
 711: PPUSH
 712: CALL_OW 30
 716: PUSH
 717: LD_INT 3
 719: EQUAL
 720: IFFALSE 735
// Bobby := CreateCharacter ( Bobby ) ;
 722: LD_ADDR_EXP 19
 726: PUSH
 727: LD_STRING Bobby
 729: PPUSH
 730: CALL_OW 34
 734: ST_TO_ADDR
// Frank := 0 ;
 735: LD_ADDR_EXP 16
 739: PUSH
 740: LD_INT 0
 742: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 743: LD_STRING Frank
 745: PPUSH
 746: CALL_OW 29
 750: IFFALSE 781
// if LoadVariable ( FrankLoc , 0 ) = 3 then
 752: LD_STRING FrankLoc
 754: PPUSH
 755: LD_INT 0
 757: PPUSH
 758: CALL_OW 30
 762: PUSH
 763: LD_INT 3
 765: EQUAL
 766: IFFALSE 781
// Frank := CreateCharacter ( Frank ) ;
 768: LD_ADDR_EXP 16
 772: PUSH
 773: LD_STRING Frank
 775: PPUSH
 776: CALL_OW 34
 780: ST_TO_ADDR
// Don := 0 ;
 781: LD_ADDR_EXP 17
 785: PUSH
 786: LD_INT 0
 788: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 789: LD_STRING Donaldson
 791: PPUSH
 792: CALL_OW 29
 796: IFFALSE 827
// if LoadVariable ( DonaldsonLoc , 0 ) = 3 then
 798: LD_STRING DonaldsonLoc
 800: PPUSH
 801: LD_INT 0
 803: PPUSH
 804: CALL_OW 30
 808: PUSH
 809: LD_INT 3
 811: EQUAL
 812: IFFALSE 827
// Don := CreateCharacter ( Donaldson ) ;
 814: LD_ADDR_EXP 17
 818: PUSH
 819: LD_STRING Donaldson
 821: PPUSH
 822: CALL_OW 34
 826: ST_TO_ADDR
// Brown := 0 ;
 827: LD_ADDR_EXP 18
 831: PUSH
 832: LD_INT 0
 834: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 835: LD_STRING Brown
 837: PPUSH
 838: CALL_OW 29
 842: IFFALSE 873
// if LoadVariable ( BrownLoc , 0 ) = 3 then
 844: LD_STRING BrownLoc
 846: PPUSH
 847: LD_INT 0
 849: PPUSH
 850: CALL_OW 30
 854: PUSH
 855: LD_INT 3
 857: EQUAL
 858: IFFALSE 873
// Brown := CreateCharacter ( Brown ) ;
 860: LD_ADDR_EXP 18
 864: PUSH
 865: LD_STRING Brown
 867: PPUSH
 868: CALL_OW 34
 872: ST_TO_ADDR
// used := ( [ JMM , Glad , Lisa , Cyrus , Bobby , Frank , Don , Brown ] diff [ 0 ] ) ^ used ;
 873: LD_ADDR_EXP 57
 877: PUSH
 878: LD_EXP 11
 882: PUSH
 883: LD_EXP 12
 887: PUSH
 888: LD_EXP 15
 892: PUSH
 893: LD_EXP 20
 897: PUSH
 898: LD_EXP 19
 902: PUSH
 903: LD_EXP 16
 907: PUSH
 908: LD_EXP 17
 912: PUSH
 913: LD_EXP 18
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: LD_INT 0
 930: PUSH
 931: EMPTY
 932: LIST
 933: DIFF
 934: PUSH
 935: LD_EXP 57
 939: ADD
 940: ST_TO_ADDR
// if not UnitFilter ( used , [ f_class , class_engineer ] ) then
 941: LD_EXP 57
 945: PPUSH
 946: LD_INT 25
 948: PUSH
 949: LD_INT 2
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PPUSH
 956: CALL_OW 72
 960: NOT
 961: IFFALSE 975
// SetClass ( JMM , class_engineer ) ;
 963: LD_EXP 11
 967: PPUSH
 968: LD_INT 2
 970: PPUSH
 971: CALL_OW 336
// end ;
 975: LD_VAR 0 1
 979: RET
// function prepare_sides ; begin
 980: LD_INT 0
 982: PPUSH
// you := 1 ;
 983: LD_ADDR_EXP 1
 987: PUSH
 988: LD_INT 1
 990: ST_TO_ADDR
// you2 := 4 ;
 991: LD_ADDR_EXP 2
 995: PUSH
 996: LD_INT 4
 998: ST_TO_ADDR
// arabians := 2 ;
 999: LD_ADDR_EXP 4
1003: PUSH
1004: LD_INT 2
1006: ST_TO_ADDR
// russians := 3 ;
1007: LD_ADDR_EXP 3
1011: PUSH
1012: LD_INT 3
1014: ST_TO_ADDR
// neutral := 0 ;
1015: LD_ADDR_EXP 5
1019: PUSH
1020: LD_INT 0
1022: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
1023: LD_EXP 4
1027: PPUSH
1028: LD_EXP 1
1032: PPUSH
1033: LD_INT 2
1035: PPUSH
1036: LD_INT 1
1038: PPUSH
1039: CALL_OW 80
// end ;
1043: LD_VAR 0 1
1047: RET
// export wait_first_attack ; export utoku ; function SetDifficulty ; begin
1048: LD_INT 0
1050: PPUSH
// wait_first_attack := [ 1 1$20 , 0 0$50 , 0 0$35 ] [ difficulty ] ;
1051: LD_ADDR_EXP 60
1055: PUSH
1056: LD_INT 2800
1058: PUSH
1059: LD_INT 1750
1061: PUSH
1062: LD_INT 1225
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_OWVAR 67
1074: ARRAY
1075: ST_TO_ADDR
// utoku := [ 9 , 12 , 19 ] [ difficulty ] ;
1076: LD_ADDR_EXP 61
1080: PUSH
1081: LD_INT 9
1083: PUSH
1084: LD_INT 12
1086: PUSH
1087: LD_INT 19
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: PUSH
1095: LD_OWVAR 67
1099: ARRAY
1100: ST_TO_ADDR
// end ;
1101: LD_VAR 0 1
1105: RET
// export function make_arabs ( pocet , unitclass ) ; var list , arab , d ; begin
1106: LD_INT 0
1108: PPUSH
1109: PPUSH
1110: PPUSH
1111: PPUSH
// InitUc ;
1112: CALL_OW 18
// InitHc ;
1116: CALL_OW 19
// uc_side := arabians ;
1120: LD_ADDR_OWVAR 20
1124: PUSH
1125: LD_EXP 4
1129: ST_TO_ADDR
// uc_nation := nation_arabian ;
1130: LD_ADDR_OWVAR 21
1134: PUSH
1135: LD_INT 2
1137: ST_TO_ADDR
// d := difficulty - 1 ;
1138: LD_ADDR_VAR 0 6
1142: PUSH
1143: LD_OWVAR 67
1147: PUSH
1148: LD_INT 1
1150: MINUS
1151: ST_TO_ADDR
// while pocet > 0 do
1152: LD_VAR 0 1
1156: PUSH
1157: LD_INT 0
1159: GREATER
1160: IFFALSE 1804
// begin hc_class := unitclass ;
1162: LD_ADDR_OWVAR 28
1166: PUSH
1167: LD_VAR 0 2
1171: ST_TO_ADDR
// if Rand ( 1 , 10 ) >= 4 then
1172: LD_INT 1
1174: PPUSH
1175: LD_INT 10
1177: PPUSH
1178: CALL_OW 12
1182: PUSH
1183: LD_INT 4
1185: GREATEREQUAL
1186: IFFALSE 1198
// hc_sex := sex_female else
1188: LD_ADDR_OWVAR 27
1192: PUSH
1193: LD_INT 2
1195: ST_TO_ADDR
1196: GO 1206
// hc_sex := sex_male ;
1198: LD_ADDR_OWVAR 27
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// case unitclass of class_soldier :
1206: LD_VAR 0 2
1210: PUSH
1211: LD_INT 1
1213: DOUBLE
1214: EQUAL
1215: IFTRUE 1219
1217: GO 1344
1219: POP
// begin hc_attr := [ Rand ( 8 , 10 ) + d , Rand ( 8 , 10 ) + d ] ;
1220: LD_ADDR_OWVAR 29
1224: PUSH
1225: LD_INT 8
1227: PPUSH
1228: LD_INT 10
1230: PPUSH
1231: CALL_OW 12
1235: PUSH
1236: LD_VAR 0 6
1240: PLUS
1241: PUSH
1242: LD_INT 8
1244: PPUSH
1245: LD_INT 10
1247: PPUSH
1248: CALL_OW 12
1252: PUSH
1253: LD_VAR 0 6
1257: PLUS
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1263: LD_ADDR_OWVAR 31
1267: PUSH
1268: LD_INT 2
1270: PPUSH
1271: LD_INT 3
1273: PPUSH
1274: CALL_OW 12
1278: PUSH
1279: LD_VAR 0 6
1283: PLUS
1284: PUSH
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: CALL_OW 12
1295: PUSH
1296: LD_VAR 0 6
1300: PLUS
1301: PUSH
1302: LD_INT 0
1304: PPUSH
1305: LD_INT 1
1307: PPUSH
1308: CALL_OW 12
1312: PUSH
1313: LD_VAR 0 6
1317: PLUS
1318: PUSH
1319: LD_INT 0
1321: PPUSH
1322: LD_INT 0
1324: PPUSH
1325: CALL_OW 12
1329: PUSH
1330: LD_VAR 0 6
1334: PLUS
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: ST_TO_ADDR
// end ; class_engineer :
1342: GO 1744
1344: LD_INT 2
1346: DOUBLE
1347: EQUAL
1348: IFTRUE 1352
1350: GO 1477
1352: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1353: LD_ADDR_OWVAR 29
1357: PUSH
1358: LD_INT 8
1360: PPUSH
1361: LD_INT 9
1363: PPUSH
1364: CALL_OW 12
1368: PUSH
1369: LD_VAR 0 6
1373: PLUS
1374: PUSH
1375: LD_INT 8
1377: PPUSH
1378: LD_INT 9
1380: PPUSH
1381: CALL_OW 12
1385: PUSH
1386: LD_VAR 0 6
1390: PLUS
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1396: LD_ADDR_OWVAR 31
1400: PUSH
1401: LD_INT 0
1403: PPUSH
1404: LD_INT 1
1406: PPUSH
1407: CALL_OW 12
1411: PUSH
1412: LD_VAR 0 6
1416: PLUS
1417: PUSH
1418: LD_INT 2
1420: PPUSH
1421: LD_INT 3
1423: PPUSH
1424: CALL_OW 12
1428: PUSH
1429: LD_VAR 0 6
1433: PLUS
1434: PUSH
1435: LD_INT 0
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: CALL_OW 12
1445: PUSH
1446: LD_VAR 0 6
1450: PLUS
1451: PUSH
1452: LD_INT 0
1454: PPUSH
1455: LD_INT 0
1457: PPUSH
1458: CALL_OW 12
1462: PUSH
1463: LD_VAR 0 6
1467: PLUS
1468: PUSH
1469: EMPTY
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: ST_TO_ADDR
// end ; class_mechanic :
1475: GO 1744
1477: LD_INT 3
1479: DOUBLE
1480: EQUAL
1481: IFTRUE 1485
1483: GO 1610
1485: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1486: LD_ADDR_OWVAR 29
1490: PUSH
1491: LD_INT 8
1493: PPUSH
1494: LD_INT 9
1496: PPUSH
1497: CALL_OW 12
1501: PUSH
1502: LD_VAR 0 6
1506: PLUS
1507: PUSH
1508: LD_INT 8
1510: PPUSH
1511: LD_INT 9
1513: PPUSH
1514: CALL_OW 12
1518: PUSH
1519: LD_VAR 0 6
1523: PLUS
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 0 ) + d , Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 0 ) + d ] ;
1529: LD_ADDR_OWVAR 31
1533: PUSH
1534: LD_INT 0
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 12
1544: PUSH
1545: LD_VAR 0 6
1549: PLUS
1550: PUSH
1551: LD_INT 0
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL_OW 12
1561: PUSH
1562: LD_VAR 0 6
1566: PLUS
1567: PUSH
1568: LD_INT 2
1570: PPUSH
1571: LD_INT 3
1573: PPUSH
1574: CALL_OW 12
1578: PUSH
1579: LD_VAR 0 6
1583: PLUS
1584: PUSH
1585: LD_INT 0
1587: PPUSH
1588: LD_INT 0
1590: PPUSH
1591: CALL_OW 12
1595: PUSH
1596: LD_VAR 0 6
1600: PLUS
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: ST_TO_ADDR
// end ; class_scientistic :
1608: GO 1744
1610: LD_INT 4
1612: DOUBLE
1613: EQUAL
1614: IFTRUE 1618
1616: GO 1743
1618: POP
// begin hc_attr := [ Rand ( 8 , 8 ) + d , Rand ( 8 , 8 ) + d ] ;
1619: LD_ADDR_OWVAR 29
1623: PUSH
1624: LD_INT 8
1626: PPUSH
1627: LD_INT 8
1629: PPUSH
1630: CALL_OW 12
1634: PUSH
1635: LD_VAR 0 6
1639: PLUS
1640: PUSH
1641: LD_INT 8
1643: PPUSH
1644: LD_INT 8
1646: PPUSH
1647: CALL_OW 12
1651: PUSH
1652: LD_VAR 0 6
1656: PLUS
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 1 , 2 ) + d , Rand ( 2 , 3 ) + d ] ;
1662: LD_ADDR_OWVAR 31
1666: PUSH
1667: LD_INT 0
1669: PPUSH
1670: LD_INT 1
1672: PPUSH
1673: CALL_OW 12
1677: PUSH
1678: LD_VAR 0 6
1682: PLUS
1683: PUSH
1684: LD_INT 0
1686: PPUSH
1687: LD_INT 1
1689: PPUSH
1690: CALL_OW 12
1694: PUSH
1695: LD_VAR 0 6
1699: PLUS
1700: PUSH
1701: LD_INT 1
1703: PPUSH
1704: LD_INT 2
1706: PPUSH
1707: CALL_OW 12
1711: PUSH
1712: LD_VAR 0 6
1716: PLUS
1717: PUSH
1718: LD_INT 2
1720: PPUSH
1721: LD_INT 3
1723: PPUSH
1724: CALL_OW 12
1728: PUSH
1729: LD_VAR 0 6
1733: PLUS
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: ST_TO_ADDR
// end ; end ;
1741: GO 1744
1743: POP
// arab := CreateHuman ;
1744: LD_ADDR_VAR 0 5
1748: PUSH
1749: CALL_OW 44
1753: ST_TO_ADDR
// if list then
1754: LD_VAR 0 4
1758: IFFALSE 1778
// list := list ^ arab else
1760: LD_ADDR_VAR 0 4
1764: PUSH
1765: LD_VAR 0 4
1769: PUSH
1770: LD_VAR 0 5
1774: ADD
1775: ST_TO_ADDR
1776: GO 1788
// list := arab ;
1778: LD_ADDR_VAR 0 4
1782: PUSH
1783: LD_VAR 0 5
1787: ST_TO_ADDR
// pocet := pocet - 1 ;
1788: LD_ADDR_VAR 0 1
1792: PUSH
1793: LD_VAR 0 1
1797: PUSH
1798: LD_INT 1
1800: MINUS
1801: ST_TO_ADDR
// end ;
1802: GO 1152
// result := list ;
1804: LD_ADDR_VAR 0 3
1808: PUSH
1809: LD_VAR 0 4
1813: ST_TO_ADDR
// end ;
1814: LD_VAR 0 3
1818: RET
// every 0 0$2 trigger not cil_mit_1_ape_eng_splnen and UnitFilter ( apemans , [ f_side , neutral ] ) + ( max_added_apes - added_apes ) < ( 2 - opic ) do
1819: LD_EXP 42
1823: NOT
1824: PUSH
1825: LD_EXP 6
1829: PPUSH
1830: LD_INT 22
1832: PUSH
1833: LD_EXP 5
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PPUSH
1842: CALL_OW 72
1846: PUSH
1847: LD_EXP 54
1851: PUSH
1852: LD_EXP 53
1856: MINUS
1857: PLUS
1858: PUSH
1859: LD_INT 2
1861: PUSH
1862: LD_EXP 41
1866: MINUS
1867: LESS
1868: AND
1869: IFFALSE 1884
1871: GO 1873
1873: DISABLE
// begin disable ( 0 ) ;
1874: LD_INT 0
1876: DISABLE_MARKED
// YouLost ( Apeman ) ;
1877: LD_STRING Apeman
1879: PPUSH
1880: CALL_OW 104
// end ;
1884: END
// every 0 0$2 trigger not GetTech ( tech_ApePsych , you ) = state_researched and not laboratore and KolikCrates < 20 and mat_crates = 3 do
1885: LD_INT 2
1887: PPUSH
1888: LD_EXP 1
1892: PPUSH
1893: CALL_OW 321
1897: PUSH
1898: LD_INT 2
1900: EQUAL
1901: NOT
1902: PUSH
1903: LD_EXP 63
1907: NOT
1908: AND
1909: PUSH
1910: CALL 3138 0 0
1914: PUSH
1915: LD_INT 20
1917: LESS
1918: AND
1919: PUSH
1920: LD_EXP 55
1924: PUSH
1925: LD_INT 3
1927: EQUAL
1928: AND
1929: IFFALSE 1944
1931: GO 1933
1933: DISABLE
// begin disable ( 0 ) ;
1934: LD_INT 0
1936: DISABLE_MARKED
// YouLost ( Resources ) ;
1937: LD_STRING Resources
1939: PPUSH
1940: CALL_OW 104
// end ;
1944: END
// every 0 0$10 trigger RadarBuild and cil_mit_5_ape_eng_splnen do
1945: LD_EXP 47
1949: PUSH
1950: LD_EXP 43
1954: AND
1955: IFFALSE 1971
1957: GO 1959
1959: DISABLE
// begin wait ( 0 0$8 ) ;
1960: LD_INT 280
1962: PPUSH
1963: CALL_OW 67
// Vyhra ;
1967: CALL 3263 0 0
// end ;
1971: END
// export function Save ; var Delta , tmp , t ; begin
1972: LD_INT 0
1974: PPUSH
1975: PPUSH
1976: PPUSH
1977: PPUSH
// SaveCharacters ( JMM , JMM ) ;
1978: LD_EXP 11
1982: PPUSH
1983: LD_STRING JMM
1985: PPUSH
1986: CALL_OW 38
// if Lisa then
1990: LD_EXP 15
1994: IFFALSE 2029
// begin SaveCharacters ( Lisa , Lisa ) ;
1996: LD_EXP 15
2000: PPUSH
2001: LD_STRING Lisa
2003: PPUSH
2004: CALL_OW 38
// if IsDead ( Lisa ) then
2008: LD_EXP 15
2012: PPUSH
2013: CALL_OW 301
2017: IFFALSE 2029
// SaveVariable ( 0 , LisaLoc ) ;
2019: LD_INT 0
2021: PPUSH
2022: LD_STRING LisaLoc
2024: PPUSH
2025: CALL_OW 39
// end ; if Frank then
2029: LD_EXP 16
2033: IFFALSE 2068
// begin SaveCharacters ( Frank , Frank ) ;
2035: LD_EXP 16
2039: PPUSH
2040: LD_STRING Frank
2042: PPUSH
2043: CALL_OW 38
// if IsDead ( Frank ) then
2047: LD_EXP 16
2051: PPUSH
2052: CALL_OW 301
2056: IFFALSE 2068
// SaveVariable ( 0 , FrankLoc ) ;
2058: LD_INT 0
2060: PPUSH
2061: LD_STRING FrankLoc
2063: PPUSH
2064: CALL_OW 39
// end ; if Don then
2068: LD_EXP 17
2072: IFFALSE 2107
// begin SaveCharacters ( Don , Donaldson ) ;
2074: LD_EXP 17
2078: PPUSH
2079: LD_STRING Donaldson
2081: PPUSH
2082: CALL_OW 38
// if IsDead ( Don ) then
2086: LD_EXP 17
2090: PPUSH
2091: CALL_OW 301
2095: IFFALSE 2107
// SaveVariable ( 0 , DonaldsonLoc ) ;
2097: LD_INT 0
2099: PPUSH
2100: LD_STRING DonaldsonLoc
2102: PPUSH
2103: CALL_OW 39
// end ; if Brown then
2107: LD_EXP 18
2111: IFFALSE 2146
// begin SaveCharacters ( Brown , Brown ) ;
2113: LD_EXP 18
2117: PPUSH
2118: LD_STRING Brown
2120: PPUSH
2121: CALL_OW 38
// if IsDead ( Brown ) then
2125: LD_EXP 18
2129: PPUSH
2130: CALL_OW 301
2134: IFFALSE 2146
// SaveVariable ( 0 , BrownLoc ) ;
2136: LD_INT 0
2138: PPUSH
2139: LD_STRING BrownLoc
2141: PPUSH
2142: CALL_OW 39
// end ; if Glad then
2146: LD_EXP 12
2150: IFFALSE 2197
// begin SaveCharacters ( Glad , Gladstone ) ;
2152: LD_EXP 12
2156: PPUSH
2157: LD_STRING Gladstone
2159: PPUSH
2160: CALL_OW 38
// if IsDead ( Glad ) then
2164: LD_EXP 12
2168: PPUSH
2169: CALL_OW 301
2173: IFFALSE 2187
// SaveVariable ( 0 , GladstoneLoc ) else
2175: LD_INT 0
2177: PPUSH
2178: LD_STRING GladstoneLoc
2180: PPUSH
2181: CALL_OW 39
2185: GO 2197
// SaveVariable ( 3 , GladstoneLoc ) ;
2187: LD_INT 3
2189: PPUSH
2190: LD_STRING GladstoneLoc
2192: PPUSH
2193: CALL_OW 39
// end ; if Denis then
2197: LD_EXP 21
2201: IFFALSE 2248
// begin SaveCharacters ( Den , Denis ) ;
2203: LD_EXP 14
2207: PPUSH
2208: LD_STRING Denis
2210: PPUSH
2211: CALL_OW 38
// if IsDead ( Den ) then
2215: LD_EXP 14
2219: PPUSH
2220: CALL_OW 301
2224: IFFALSE 2238
// SaveVariable ( 0 , DenisLoc ) else
2226: LD_INT 0
2228: PPUSH
2229: LD_STRING DenisLoc
2231: PPUSH
2232: CALL_OW 39
2236: GO 2248
// SaveVariable ( 3 , DenisLoc ) ;
2238: LD_INT 3
2240: PPUSH
2241: LD_STRING DenisLoc
2243: PPUSH
2244: CALL_OW 39
// end ; if Bobby then
2248: LD_EXP 19
2252: IFFALSE 2287
// begin SaveCharacters ( Bobby , Bobby ) ;
2254: LD_EXP 19
2258: PPUSH
2259: LD_STRING Bobby
2261: PPUSH
2262: CALL_OW 38
// if IsDead ( Bobby ) then
2266: LD_EXP 19
2270: PPUSH
2271: CALL_OW 301
2275: IFFALSE 2287
// SaveVariable ( 0 , BobbyLoc ) ;
2277: LD_INT 0
2279: PPUSH
2280: LD_STRING BobbyLoc
2282: PPUSH
2283: CALL_OW 39
// end ; if Cyrus then
2287: LD_EXP 20
2291: IFFALSE 2326
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2293: LD_EXP 20
2297: PPUSH
2298: LD_STRING Cyrus
2300: PPUSH
2301: CALL_OW 38
// if IsDead ( Cyrus ) then
2305: LD_EXP 20
2309: PPUSH
2310: CALL_OW 301
2314: IFFALSE 2326
// SaveVariable ( 0 , CyrusLoc ) ;
2316: LD_INT 0
2318: PPUSH
2319: LD_STRING CyrusLoc
2321: PPUSH
2322: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Don , Brown , Glad , Den , Bobby , Cyrus , 0 ] , otherDelta ) ;
2326: LD_INT 22
2328: PUSH
2329: LD_EXP 1
2333: PUSH
2334: EMPTY
2335: LIST
2336: LIST
2337: PUSH
2338: LD_INT 21
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: PUSH
2348: LD_INT 23
2350: PUSH
2351: LD_INT 1
2353: PUSH
2354: EMPTY
2355: LIST
2356: LIST
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: PPUSH
2363: CALL_OW 69
2367: PUSH
2368: LD_EXP 11
2372: PUSH
2373: LD_EXP 15
2377: PUSH
2378: LD_EXP 16
2382: PUSH
2383: LD_EXP 17
2387: PUSH
2388: LD_EXP 18
2392: PUSH
2393: LD_EXP 12
2397: PUSH
2398: LD_EXP 14
2402: PUSH
2403: LD_EXP 19
2407: PUSH
2408: LD_EXP 20
2412: PUSH
2413: LD_INT 0
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: LIST
2426: LIST
2427: DIFF
2428: PPUSH
2429: LD_STRING otherDelta
2431: PPUSH
2432: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) , opicaci ) ;
2436: LD_INT 22
2438: PUSH
2439: LD_EXP 1
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PUSH
2448: LD_INT 23
2450: PUSH
2451: LD_INT 0
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PPUSH
2462: CALL_OW 69
2466: PPUSH
2467: LD_STRING opicaci
2469: PPUSH
2470: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
2474: LD_ADDR_VAR 0 3
2478: PUSH
2479: LD_INT 22
2481: PUSH
2482: LD_EXP 1
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PUSH
2491: LD_INT 21
2493: PUSH
2494: LD_INT 3
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: PPUSH
2505: CALL_OW 69
2509: ST_TO_ADDR
// Delta := [ ] ;
2510: LD_ADDR_VAR 0 2
2514: PUSH
2515: EMPTY
2516: ST_TO_ADDR
// for t in tmp do
2517: LD_ADDR_VAR 0 4
2521: PUSH
2522: LD_VAR 0 3
2526: PUSH
2527: FOR_IN
2528: IFFALSE 2882
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
2530: LD_VAR 0 4
2534: PPUSH
2535: CALL_OW 266
2539: PUSH
2540: LD_INT 9
2542: DOUBLE
2543: EQUAL
2544: IFTRUE 2584
2546: LD_INT 10
2548: DOUBLE
2549: EQUAL
2550: IFTRUE 2584
2552: LD_INT 13
2554: DOUBLE
2555: EQUAL
2556: IFTRUE 2584
2558: LD_INT 12
2560: DOUBLE
2561: EQUAL
2562: IFTRUE 2584
2564: LD_INT 15
2566: DOUBLE
2567: EQUAL
2568: IFTRUE 2584
2570: LD_INT 11
2572: DOUBLE
2573: EQUAL
2574: IFTRUE 2584
2576: LD_INT 14
2578: DOUBLE
2579: EQUAL
2580: IFTRUE 2584
2582: GO 2587
2584: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
2585: GO 2880
2587: LD_INT 6
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2607
2593: LD_INT 7
2595: DOUBLE
2596: EQUAL
2597: IFTRUE 2607
2599: LD_INT 8
2601: DOUBLE
2602: EQUAL
2603: IFTRUE 2607
2605: GO 2709
2607: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetLabKind ( t , 1 ) , GetLabKind ( t , 2 ) ] ] ; b_bunker , b_turret :
2608: LD_ADDR_VAR 0 2
2612: PUSH
2613: LD_VAR 0 2
2617: PUSH
2618: LD_VAR 0 4
2622: PPUSH
2623: CALL_OW 250
2627: PUSH
2628: LD_VAR 0 4
2632: PPUSH
2633: CALL_OW 251
2637: PUSH
2638: LD_VAR 0 4
2642: PPUSH
2643: CALL_OW 254
2647: PUSH
2648: LD_VAR 0 4
2652: PPUSH
2653: CALL_OW 266
2657: PUSH
2658: LD_VAR 0 4
2662: PPUSH
2663: CALL_OW 267
2667: PUSH
2668: LD_VAR 0 4
2672: PPUSH
2673: LD_INT 1
2675: PPUSH
2676: CALL_OW 268
2680: PUSH
2681: LD_VAR 0 4
2685: PPUSH
2686: LD_INT 2
2688: PPUSH
2689: CALL_OW 268
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: LIST
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: ADD
2706: ST_TO_ADDR
2707: GO 2880
2709: LD_INT 32
2711: DOUBLE
2712: EQUAL
2713: IFTRUE 2723
2715: LD_INT 33
2717: DOUBLE
2718: EQUAL
2719: IFTRUE 2723
2721: GO 2808
2723: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetBWeapon ( t ) ] ] ; else
2724: LD_ADDR_VAR 0 2
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: LD_VAR 0 4
2738: PPUSH
2739: CALL_OW 250
2743: PUSH
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 251
2753: PUSH
2754: LD_VAR 0 4
2758: PPUSH
2759: CALL_OW 254
2763: PUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: CALL_OW 266
2773: PUSH
2774: LD_VAR 0 4
2778: PPUSH
2779: CALL_OW 267
2783: PUSH
2784: LD_VAR 0 4
2788: PPUSH
2789: CALL_OW 269
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: PUSH
2802: EMPTY
2803: LIST
2804: ADD
2805: ST_TO_ADDR
2806: GO 2880
2808: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) ] ] ; end ;
2809: LD_ADDR_VAR 0 2
2813: PUSH
2814: LD_VAR 0 2
2818: PUSH
2819: LD_VAR 0 4
2823: PPUSH
2824: CALL_OW 250
2828: PUSH
2829: LD_VAR 0 4
2833: PPUSH
2834: CALL_OW 251
2838: PUSH
2839: LD_VAR 0 4
2843: PPUSH
2844: CALL_OW 254
2848: PUSH
2849: LD_VAR 0 4
2853: PPUSH
2854: CALL_OW 266
2858: PUSH
2859: LD_VAR 0 4
2863: PPUSH
2864: CALL_OW 267
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: PUSH
2876: EMPTY
2877: LIST
2878: ADD
2879: ST_TO_ADDR
// end ;
2880: GO 2527
2882: POP
2883: POP
// SaveVariable ( Delta , Delta ) ;
2884: LD_VAR 0 2
2888: PPUSH
2889: LD_STRING Delta
2891: PPUSH
2892: CALL_OW 39
// SaveVariable ( Researched ( you , tech_radar ) , RadarDeveloped ) ;
2896: LD_EXP 1
2900: PPUSH
2901: LD_INT 6
2903: PPUSH
2904: CALL_OW 325
2908: PPUSH
2909: LD_STRING RadarDeveloped
2911: PPUSH
2912: CALL_OW 39
// end ;
2916: LD_VAR 0 1
2920: RET
// export function SetMedals ; var medal1 , medal2 , medal3 ; begin
2921: LD_INT 0
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
// AddMedal ( Tame , cil_mit_5_ape_eng_splnen ) ;
2927: LD_STRING Tame
2929: PPUSH
2930: LD_EXP 43
2934: PPUSH
2935: CALL_OW 101
// if cil_mit_5_ape_eng_splnen then
2939: LD_EXP 43
2943: IFFALSE 2953
// medal1 := true ;
2945: LD_ADDR_VAR 0 2
2949: PUSH
2950: LD_INT 1
2952: ST_TO_ADDR
// case GetTech ( tech_Radar , you ) of state_researched :
2953: LD_INT 6
2955: PPUSH
2956: LD_EXP 1
2960: PPUSH
2961: CALL_OW 321
2965: PUSH
2966: LD_INT 2
2968: DOUBLE
2969: EQUAL
2970: IFTRUE 2974
2972: GO 2995
2974: POP
// begin AddMedal ( Radar , 1 ) ;
2975: LD_STRING Radar
2977: PPUSH
2978: LD_INT 1
2980: PPUSH
2981: CALL_OW 101
// medal2 := true ;
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_INT 1
2992: ST_TO_ADDR
// end ; state_disabled :
2993: GO 3040
2995: LD_INT 0
2997: DOUBLE
2998: EQUAL
2999: IFTRUE 3003
3001: GO 3017
3003: POP
// AddMedal ( Radar , - 1 ) ; state_enabled :
3004: LD_STRING Radar
3006: PPUSH
3007: LD_INT 1
3009: NEG
3010: PPUSH
3011: CALL_OW 101
3015: GO 3040
3017: LD_INT 1
3019: DOUBLE
3020: EQUAL
3021: IFTRUE 3025
3023: GO 3039
3025: POP
// AddMedal ( Radar , - 2 ) ; end ;
3026: LD_STRING Radar
3028: PPUSH
3029: LD_INT 2
3031: NEG
3032: PPUSH
3033: CALL_OW 101
3037: GO 3040
3039: POP
// if GetTech ( tech_Radar , you ) = state_disabled then
3040: LD_INT 6
3042: PPUSH
3043: LD_EXP 1
3047: PPUSH
3048: CALL_OW 321
3052: PUSH
3053: LD_INT 0
3055: EQUAL
3056: IFFALSE 3071
// begin AddMedal ( buildRadar , - 1 ) ;
3058: LD_STRING buildRadar
3060: PPUSH
3061: LD_INT 1
3063: NEG
3064: PPUSH
3065: CALL_OW 101
// end else
3069: GO 3108
// begin if RadarBuild then
3071: LD_EXP 47
3075: IFFALSE 3097
// begin AddMedal ( buildRadar , 1 ) ;
3077: LD_STRING buildRadar
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: CALL_OW 101
// medal3 := true ;
3087: LD_ADDR_VAR 0 4
3091: PUSH
3092: LD_INT 1
3094: ST_TO_ADDR
// end else
3095: GO 3108
// AddMedal ( buildRadar , - 2 ) ;
3097: LD_STRING buildRadar
3099: PPUSH
3100: LD_INT 2
3102: NEG
3103: PPUSH
3104: CALL_OW 101
// end ; SA_EndMission ( 1 , 5 , medal1 , medal2 , medal3 ) ;
3108: LD_INT 1
3110: PPUSH
3111: LD_INT 5
3113: PPUSH
3114: LD_VAR 0 2
3118: PPUSH
3119: LD_VAR 0 3
3123: PPUSH
3124: LD_VAR 0 4
3128: PPUSH
3129: CALL 15467 0 5
// end ;
3133: LD_VAR 0 1
3137: RET
// function KolikCrates ; var base ; begin
3138: LD_INT 0
3140: PPUSH
3141: PPUSH
// result := GetCargo ( FilterAllUnits ( [ f_side , you ] ) , mat_cans ) + GetResourceArea ( all_map , mat_cans ) ;
3142: LD_ADDR_VAR 0 1
3146: PUSH
3147: LD_INT 22
3149: PUSH
3150: LD_EXP 1
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PPUSH
3159: CALL_OW 69
3163: PPUSH
3164: LD_INT 1
3166: PPUSH
3167: CALL_OW 289
3171: PUSH
3172: LD_INT 8
3174: PPUSH
3175: LD_INT 1
3177: PPUSH
3178: CALL_OW 287
3182: PLUS
3183: ST_TO_ADDR
// base := FilterAllUnits ( [ f_type , unit_building ] ) ;
3184: LD_ADDR_VAR 0 2
3188: PUSH
3189: LD_INT 21
3191: PUSH
3192: LD_INT 3
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: PPUSH
3199: CALL_OW 69
3203: ST_TO_ADDR
// if base then
3204: LD_VAR 0 2
3208: IFFALSE 3243
// result := result + GetResourceType ( GetBase ( base [ 1 ] ) , mat_cans ) ;
3210: LD_ADDR_VAR 0 1
3214: PUSH
3215: LD_VAR 0 1
3219: PUSH
3220: LD_VAR 0 2
3224: PUSH
3225: LD_INT 1
3227: ARRAY
3228: PPUSH
3229: CALL_OW 274
3233: PPUSH
3234: LD_INT 1
3236: PPUSH
3237: CALL_OW 275
3241: PLUS
3242: ST_TO_ADDR
// end ;
3243: LD_VAR 0 1
3247: RET
// on EndTheMissionRaised ( x ) do begin end_the_mission_allowed := false ;
3248: LD_ADDR_OWVAR 57
3252: PUSH
3253: LD_INT 0
3255: ST_TO_ADDR
// Vyhra ;
3256: CALL 3263 0 0
// end ;
3260: PPOPN 1
3262: END
// export function Vyhra ; begin
3263: LD_INT 0
3265: PPUSH
// disable ( 0 ) ;
3266: LD_INT 0
3268: DISABLE_MARKED
// SetMedals ;
3269: CALL 2921 0 0
// GiveMedals ( Main ) ;
3273: LD_STRING Main
3275: PPUSH
3276: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3280: LD_INT 22
3282: PUSH
3283: LD_EXP 1
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 21
3294: PUSH
3295: LD_INT 1
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 23
3304: PUSH
3305: LD_INT 1
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: LIST
3316: PPUSH
3317: CALL_OW 69
3321: PPUSH
3322: CALL_OW 43
// Save ;
3326: CALL 1972 0 0
// YouWin ;
3330: CALL_OW 103
// end ;
3334: LD_VAR 0 1
3338: RET
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_lab_half ] ] ) then
3339: LD_VAR 0 1
3343: PPUSH
3344: LD_INT 30
3346: PUSH
3347: LD_INT 7
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: PPUSH
3357: CALL_OW 72
3361: IFFALSE 3370
// MyHint ( UpgradeLab ) ;
3363: LD_STRING UpgradeLab
3365: PPUSH
3366: CALL 15155 0 1
// end ; end_of_file
3370: PPOPN 1
3372: END
// var startx , starty , startd ; export function Dialog1 ; var qr , i , mechs , sols ; begin
3373: LD_INT 0
3375: PPUSH
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
// InGameOn ;
3380: CALL_OW 8
// startx := 27 ;
3384: LD_ADDR_LOC 1
3388: PUSH
3389: LD_INT 27
3391: ST_TO_ADDR
// starty := 50 ;
3392: LD_ADDR_LOC 2
3396: PUSH
3397: LD_INT 50
3399: ST_TO_ADDR
// startd := 5 ;
3400: LD_ADDR_LOC 3
3404: PUSH
3405: LD_INT 5
3407: ST_TO_ADDR
// InitUc ;
3408: CALL_OW 18
// InitHc ;
3412: CALL_OW 19
// InitVc ;
3416: CALL_OW 20
// uc_side := you ;
3420: LD_ADDR_OWVAR 20
3424: PUSH
3425: LD_EXP 1
3429: ST_TO_ADDR
// uc_nation := nation_american ;
3430: LD_ADDR_OWVAR 21
3434: PUSH
3435: LD_INT 1
3437: ST_TO_ADDR
// not_char := used diff [ JMM , Glad , Lisa , Frank ] ;
3438: LD_ADDR_EXP 49
3442: PUSH
3443: LD_EXP 57
3447: PUSH
3448: LD_EXP 11
3452: PUSH
3453: LD_EXP 12
3457: PUSH
3458: LD_EXP 15
3462: PUSH
3463: LD_EXP 16
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: DIFF
3474: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Brown , Don ] ;
3475: LD_ADDR_EXP 49
3479: PUSH
3480: LD_EXP 49
3484: PUSH
3485: LD_EXP 20
3489: PUSH
3490: LD_EXP 19
3494: PUSH
3495: LD_EXP 18
3499: PUSH
3500: LD_EXP 17
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: DIFF
3511: ST_TO_ADDR
// if Brown in used then
3512: LD_EXP 18
3516: PUSH
3517: LD_EXP 57
3521: IN
3522: IFFALSE 3543
// not_char := not_char ^ [ Brown ] ;
3524: LD_ADDR_EXP 49
3528: PUSH
3529: LD_EXP 49
3533: PUSH
3534: LD_EXP 18
3538: PUSH
3539: EMPTY
3540: LIST
3541: ADD
3542: ST_TO_ADDR
// if Don in used then
3543: LD_EXP 17
3547: PUSH
3548: LD_EXP 57
3552: IN
3553: IFFALSE 3574
// not_char := not_char ^ [ Don ] ;
3555: LD_ADDR_EXP 49
3559: PUSH
3560: LD_EXP 49
3564: PUSH
3565: LD_EXP 17
3569: PUSH
3570: EMPTY
3571: LIST
3572: ADD
3573: ST_TO_ADDR
// if Cyrus in used then
3574: LD_EXP 20
3578: PUSH
3579: LD_EXP 57
3583: IN
3584: IFFALSE 3605
// not_char := not_char ^ [ Cyrus ] ;
3586: LD_ADDR_EXP 49
3590: PUSH
3591: LD_EXP 49
3595: PUSH
3596: LD_EXP 20
3600: PUSH
3601: EMPTY
3602: LIST
3603: ADD
3604: ST_TO_ADDR
// if Bobby in used then
3605: LD_EXP 19
3609: PUSH
3610: LD_EXP 57
3614: IN
3615: IFFALSE 3636
// not_char := not_char ^ [ Bobby ] ;
3617: LD_ADDR_EXP 49
3621: PUSH
3622: LD_EXP 49
3626: PUSH
3627: LD_EXP 19
3631: PUSH
3632: EMPTY
3633: LIST
3634: ADD
3635: ST_TO_ADDR
// mechs := UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) ;
3636: LD_ADDR_VAR 0 4
3640: PUSH
3641: LD_EXP 57
3645: PPUSH
3646: LD_INT 25
3648: PUSH
3649: LD_INT 3
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: PUSH
3656: EMPTY
3657: LIST
3658: PPUSH
3659: CALL_OW 72
3663: ST_TO_ADDR
// sols := UnitFilter ( used , [ [ f_class , class_soldier ] ] ) ;
3664: LD_ADDR_VAR 0 5
3668: PUSH
3669: LD_EXP 57
3673: PPUSH
3674: LD_INT 25
3676: PUSH
3677: LD_INT 1
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: EMPTY
3685: LIST
3686: PPUSH
3687: CALL_OW 72
3691: ST_TO_ADDR
// used := mechs ^ sols ^ ( used diff ( mechs ^ sols ) ) ;
3692: LD_ADDR_EXP 57
3696: PUSH
3697: LD_VAR 0 4
3701: PUSH
3702: LD_VAR 0 5
3706: ADD
3707: PUSH
3708: LD_EXP 57
3712: PUSH
3713: LD_VAR 0 4
3717: PUSH
3718: LD_VAR 0 5
3722: ADD
3723: DIFF
3724: ADD
3725: ST_TO_ADDR
// Wait ( 0 0$1.0 ) ;
3726: LD_INT 35
3728: PPUSH
3729: CALL_OW 67
// PlaceHumanInUnit ( used [ 1 ] , Car1 ) ;
3733: LD_EXP 57
3737: PUSH
3738: LD_INT 1
3740: ARRAY
3741: PPUSH
3742: LD_EXP 25
3746: PPUSH
3747: CALL_OW 52
// PlaceHumanInUnit ( used [ 2 ] , Car2 ) ;
3751: LD_EXP 57
3755: PUSH
3756: LD_INT 2
3758: ARRAY
3759: PPUSH
3760: LD_EXP 26
3764: PPUSH
3765: CALL_OW 52
// PlaceHumanInUnit ( used [ 3 ] , Car3 ) ;
3769: LD_EXP 57
3773: PUSH
3774: LD_INT 3
3776: ARRAY
3777: PPUSH
3778: LD_EXP 27
3782: PPUSH
3783: CALL_OW 52
// PlaceUnitXYR ( Car1 , startx , starty , startd , false ) ;
3787: LD_EXP 25
3791: PPUSH
3792: LD_LOC 1
3796: PPUSH
3797: LD_LOC 2
3801: PPUSH
3802: LD_LOC 3
3806: PPUSH
3807: LD_INT 0
3809: PPUSH
3810: CALL_OW 50
// PlaceUnitXYR ( Car2 , startx , starty , startd , false ) ;
3814: LD_EXP 26
3818: PPUSH
3819: LD_LOC 1
3823: PPUSH
3824: LD_LOC 2
3828: PPUSH
3829: LD_LOC 3
3833: PPUSH
3834: LD_INT 0
3836: PPUSH
3837: CALL_OW 50
// PlaceUnitXYR ( Car3 , startx , starty , startd , false ) ;
3841: LD_EXP 27
3845: PPUSH
3846: LD_LOC 1
3850: PPUSH
3851: LD_LOC 2
3855: PPUSH
3856: LD_LOC 3
3860: PPUSH
3861: LD_INT 0
3863: PPUSH
3864: CALL_OW 50
// for i := 4 to used do
3868: LD_ADDR_VAR 0 3
3872: PUSH
3873: DOUBLE
3874: LD_INT 4
3876: DEC
3877: ST_TO_ADDR
3878: LD_EXP 57
3882: PUSH
3883: FOR_TO
3884: IFFALSE 3921
// PlaceUnitXYR ( used [ i ] , startx , starty , startd , false ) ;
3886: LD_EXP 57
3890: PUSH
3891: LD_VAR 0 3
3895: ARRAY
3896: PPUSH
3897: LD_LOC 1
3901: PPUSH
3902: LD_LOC 2
3906: PPUSH
3907: LD_LOC 3
3911: PPUSH
3912: LD_INT 0
3914: PPUSH
3915: CALL_OW 50
3919: GO 3883
3921: POP
3922: POP
// tvoji_lidi := used ;
3923: LD_ADDR_EXP 48
3927: PUSH
3928: LD_EXP 57
3932: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
3933: LD_INT 35
3935: PPUSH
3936: CALL_OW 67
// CenterNowOnXY ( startx , starty ) ;
3940: LD_LOC 1
3944: PPUSH
3945: LD_LOC 2
3949: PPUSH
3950: CALL_OW 86
// Say ( JMM , D1d-JMM-1a ) ;
3954: LD_EXP 11
3958: PPUSH
3959: LD_STRING D1d-JMM-1a
3961: PPUSH
3962: CALL_OW 88
// SayRadio ( Har , D1d-Har-1 ) ;
3966: LD_EXP 13
3970: PPUSH
3971: LD_STRING D1d-Har-1
3973: PPUSH
3974: CALL_OW 94
// InGameOff ;
3978: CALL_OW 9
// SaveForQuickRestart ;
3982: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3986: LD_STRING M1
3988: PPUSH
3989: CALL_OW 337
// Wait ( 0 0$1.0 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// TalkOn ;
4000: CALL 14807 0 0
// if Say ( JMM , D2-JMM-1 ) then
4004: LD_EXP 11
4008: PPUSH
4009: LD_STRING D2-JMM-1
4011: PPUSH
4012: CALL_OW 88
4016: IFFALSE 4072
// if Say ( Glad , D2-Glad-1 ) then
4018: LD_EXP 12
4022: PPUSH
4023: LD_STRING D2-Glad-1
4025: PPUSH
4026: CALL_OW 88
4030: IFFALSE 4072
// if Say ( JMM , D2-JMM-2 ) then
4032: LD_EXP 11
4036: PPUSH
4037: LD_STRING D2-JMM-2
4039: PPUSH
4040: CALL_OW 88
4044: IFFALSE 4072
// if Say ( Glad , D2-Glad-2 ) then
4046: LD_EXP 12
4050: PPUSH
4051: LD_STRING D2-Glad-2
4053: PPUSH
4054: CALL_OW 88
4058: IFFALSE 4072
// Say ( JMM , D2-JMM-3 ) ;
4060: LD_EXP 11
4064: PPUSH
4065: LD_STRING D2-JMM-3
4067: PPUSH
4068: CALL_OW 88
// TalkOff ;
4072: CALL 14815 0 0
// end ;
4076: LD_VAR 0 1
4080: RET
// every 0 0$10 trigger denis_can_come and laboratore do var a , mytick ;
4081: LD_EXP 46
4085: PUSH
4086: LD_EXP 63
4090: AND
4091: IFFALSE 4471
4093: GO 4095
4095: DISABLE
4096: LD_INT 0
4098: PPUSH
4099: PPUSH
// begin mytick := tick + 0 0$55 ;
4100: LD_ADDR_VAR 0 2
4104: PUSH
4105: LD_OWVAR 1
4109: PUSH
4110: LD_INT 1925
4112: PLUS
4113: ST_TO_ADDR
// while mytick > tick and GetTechProgress ( tech_ApePsych , you ) < 40 do
4114: LD_VAR 0 2
4118: PUSH
4119: LD_OWVAR 1
4123: GREATER
4124: PUSH
4125: LD_INT 2
4127: PPUSH
4128: LD_EXP 1
4132: PPUSH
4133: CALL_OW 326
4137: PUSH
4138: LD_INT 40
4140: LESS
4141: AND
4142: IFFALSE 4153
// wait ( 0 0$1 ) ;
4144: LD_INT 35
4146: PPUSH
4147: CALL_OW 67
4151: GO 4114
// SetSide ( Denis , you2 ) ;
4153: LD_EXP 21
4157: PPUSH
4158: LD_EXP 2
4162: PPUSH
4163: CALL_OW 235
// PlaceUnitXYR ( Denis , 20 , 35 , 5 , false ) ;
4167: LD_EXP 21
4171: PPUSH
4172: LD_INT 20
4174: PPUSH
4175: LD_INT 35
4177: PPUSH
4178: LD_INT 5
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// Wait ( 0 0$2 ) ;
4188: LD_INT 70
4190: PPUSH
4191: CALL_OW 67
// Den := Denis ;
4195: LD_ADDR_EXP 14
4199: PUSH
4200: LD_EXP 21
4204: ST_TO_ADDR
// DialogueOn ;
4205: CALL_OW 6
// CenterOnUnits ( Den ) ;
4209: LD_EXP 14
4213: PPUSH
4214: CALL_OW 85
// if Say ( Den , DD-Den-1 ) then
4218: LD_EXP 14
4222: PPUSH
4223: LD_STRING DD-Den-1
4225: PPUSH
4226: CALL_OW 88
4230: IFFALSE 4258
// if Say ( JMM , DD-JMM-1 ) then
4232: LD_EXP 11
4236: PPUSH
4237: LD_STRING DD-JMM-1
4239: PPUSH
4240: CALL_OW 88
4244: IFFALSE 4258
// Say ( Den , DD-Den-2 ) ;
4246: LD_EXP 14
4250: PPUSH
4251: LD_STRING DD-Den-2
4253: PPUSH
4254: CALL_OW 88
// DialogueOff ;
4258: CALL_OW 7
// if laboratore then
4262: LD_EXP 63
4266: IFFALSE 4284
// a := laboratore [ 1 ] else
4268: LD_ADDR_VAR 0 1
4272: PUSH
4273: LD_EXP 63
4277: PUSH
4278: LD_INT 1
4280: ARRAY
4281: ST_TO_ADDR
4282: GO 4298
// a := budovy [ 1 ] ;
4284: LD_ADDR_VAR 0 1
4288: PUSH
4289: LD_EXP 64
4293: PUSH
4294: LD_INT 1
4296: ARRAY
4297: ST_TO_ADDR
// ComMoveUnit ( Den , a ) ;
4298: LD_EXP 14
4302: PPUSH
4303: LD_VAR 0 1
4307: PPUSH
4308: CALL_OW 112
// Say ( Den , DD-Den-2a ) ;
4312: LD_EXP 14
4316: PPUSH
4317: LD_STRING DD-Den-2a
4319: PPUSH
4320: CALL_OW 88
// mytick := tick + 0 0$20 ;
4324: LD_ADDR_VAR 0 2
4328: PUSH
4329: LD_OWVAR 1
4333: PUSH
4334: LD_INT 700
4336: PLUS
4337: ST_TO_ADDR
// while GetDistUnits ( den , a ) > 4 and IsLive ( a ) and mytick > tick do
4338: LD_EXP 14
4342: PPUSH
4343: LD_VAR 0 1
4347: PPUSH
4348: CALL_OW 296
4352: PUSH
4353: LD_INT 4
4355: GREATER
4356: PUSH
4357: LD_VAR 0 1
4361: PPUSH
4362: CALL_OW 300
4366: AND
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: LD_OWVAR 1
4377: GREATER
4378: AND
4379: IFFALSE 4390
// wait ( 0 0$0.6 ) ;
4381: LD_INT 21
4383: PPUSH
4384: CALL_OW 67
4388: GO 4338
// SetSide ( Den , you ) ;
4390: LD_EXP 14
4394: PPUSH
4395: LD_EXP 1
4399: PPUSH
4400: CALL_OW 235
// tvoji_lidi := tvoji_lidi union Den ;
4404: LD_ADDR_EXP 48
4408: PUSH
4409: LD_EXP 48
4413: PUSH
4414: LD_EXP 14
4418: UNION
4419: ST_TO_ADDR
// if laboratore then
4420: LD_EXP 63
4424: IFFALSE 4471
// begin ComEnterUnit ( Den , a ) ;
4426: LD_EXP 14
4430: PPUSH
4431: LD_VAR 0 1
4435: PPUSH
4436: CALL_OW 120
// AddComChangeProfession ( Den , class_scientistic ) ;
4440: LD_EXP 14
4444: PPUSH
4445: LD_INT 4
4447: PPUSH
4448: CALL_OW 183
// Wait ( 0 0$2 ) ;
4452: LD_INT 70
4454: PPUSH
4455: CALL_OW 67
// Say ( Den , DD-Den-2b ) ;
4459: LD_EXP 14
4463: PPUSH
4464: LD_STRING DD-Den-2b
4466: PPUSH
4467: CALL_OW 88
// end ; end ;
4471: PPOPN 2
4473: END
// on ResearchComplete ( tech , lab ) do var qr ;
4474: LD_INT 0
4476: PPUSH
// begin if ( GetSide ( lab ) = you ) then
4477: LD_VAR 0 2
4481: PPUSH
4482: CALL_OW 255
4486: PUSH
4487: LD_EXP 1
4491: EQUAL
4492: IFFALSE 4794
// begin wait ( 0 0$1 ) ;
4494: LD_INT 35
4496: PPUSH
4497: CALL_OW 67
// if tech = tech_ApeLang then
4501: LD_VAR 0 1
4505: PUSH
4506: LD_INT 1
4508: EQUAL
4509: IFFALSE 4600
// begin zasilka_muze := true ;
4511: LD_ADDR_EXP 44
4515: PUSH
4516: LD_INT 1
4518: ST_TO_ADDR
// if IsLive ( Glad ) then
4519: LD_EXP 12
4523: PPUSH
4524: CALL_OW 300
4528: IFFALSE 4593
// begin Wait ( 0 0$1 ) ;
4530: LD_INT 35
4532: PPUSH
4533: CALL_OW 67
// DialogueOn ;
4537: CALL_OW 6
// Say ( Glad , D3-Glad-1 ) ;
4541: LD_EXP 12
4545: PPUSH
4546: LD_STRING D3-Glad-1
4548: PPUSH
4549: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
4553: LD_EXP 11
4557: PPUSH
4558: LD_STRING D3-JMM-1
4560: PPUSH
4561: CALL_OW 88
// Say ( Glad , D3-Glad-2 ) ;
4565: LD_EXP 12
4569: PPUSH
4570: LD_STRING D3-Glad-2
4572: PPUSH
4573: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
4577: LD_EXP 11
4581: PPUSH
4582: LD_STRING D3-JMM-2
4584: PPUSH
4585: CALL_OW 88
// DialogueOff ;
4589: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4593: LD_STRING ApemenTaming
4595: PPUSH
4596: CALL 15155 0 1
// end ; if tech = tech_ApePsych then
4600: LD_VAR 0 1
4604: PUSH
4605: LD_INT 2
4607: EQUAL
4608: IFFALSE 4755
// begin Wait ( 0 0$1 ) ;
4610: LD_INT 35
4612: PPUSH
4613: CALL_OW 67
// while opic <= 0 do
4617: LD_EXP 41
4621: PUSH
4622: LD_INT 0
4624: LESSEQUAL
4625: IFFALSE 4636
// wait ( 0 0$2 ) ;
4627: LD_INT 70
4629: PPUSH
4630: CALL_OW 67
4634: GO 4617
// DialogueOn ;
4636: CALL_OW 6
// if Frank then
4640: LD_EXP 16
4644: IFFALSE 4660
// Say ( Frank , D8a-Frank-1 ) else
4646: LD_EXP 16
4650: PPUSH
4651: LD_STRING D8a-Frank-1
4653: PPUSH
4654: CALL_OW 88
4658: GO 4686
// SayAny ( not_char , D8a-Sol1-1 , you , sex_male , 0 , 0 ) ;
4660: LD_EXP 49
4664: PPUSH
4665: LD_STRING D8a-Sol1-1
4667: PPUSH
4668: LD_EXP 1
4672: PPUSH
4673: LD_INT 1
4675: PPUSH
4676: LD_INT 0
4678: PPUSH
4679: LD_INT 0
4681: PPUSH
4682: CALL 14881 0 6
// if Den then
4686: LD_EXP 14
4690: IFFALSE 4706
// Say ( Den , D8a-Den-1 ) else
4692: LD_EXP 14
4696: PPUSH
4697: LD_STRING D8a-Den-1
4699: PPUSH
4700: CALL_OW 88
4704: GO 4732
// SayAny ( not_char , D8a-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
4706: LD_EXP 49
4710: PPUSH
4711: LD_STRING D8a-Sci1-1
4713: PPUSH
4714: LD_EXP 1
4718: PPUSH
4719: LD_INT 1
4721: PPUSH
4722: LD_INT 4
4724: PPUSH
4725: LD_INT 0
4727: PPUSH
4728: CALL 14881 0 6
// Say ( JMM , D8a-JMM-1 ) ;
4732: LD_EXP 11
4736: PPUSH
4737: LD_STRING D8a-JMM-1
4739: PPUSH
4740: CALL_OW 88
// DialogueOff ;
4744: CALL_OW 7
// MyHint ( ApemenPsychology ) ;
4748: LD_STRING ApemenPsychology
4750: PPUSH
4751: CALL 15155 0 1
// end ; if tech = tech_Radar then
4755: LD_VAR 0 1
4759: PUSH
4760: LD_INT 6
4762: EQUAL
4763: IFFALSE 4794
// begin ChangeMissionObjectives ( M2a ) ;
4765: LD_STRING M2a
4767: PPUSH
4768: CALL_OW 337
// SetRestrict ( b_ext_radar , you , state_enabled ) ;
4772: LD_INT 20
4774: PPUSH
4775: LD_EXP 1
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: CALL_OW 324
// MyHint ( Extensions ) ;
4787: LD_STRING Extensions
4789: PPUSH
4790: CALL 15155 0 1
// end ; end ; end ;
4794: PPOPN 3
4796: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) >= 5 do
4797: LD_INT 25
4799: PUSH
4800: LD_INT 16
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PPUSH
4807: CALL_OW 69
4811: PUSH
4812: LD_INT 5
4814: GREATEREQUAL
4815: IFFALSE 4835
4817: GO 4819
4819: DISABLE
// begin cil_mit_5_ape_eng_splnen := true ;
4820: LD_ADDR_EXP 43
4824: PUSH
4825: LD_INT 1
4827: ST_TO_ADDR
// ChangeMissionObjectives ( M1b ) ;
4828: LD_STRING M1b
4830: PPUSH
4831: CALL_OW 337
// end ;
4835: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) do
4836: LD_INT 25
4838: PUSH
4839: LD_INT 16
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PPUSH
4846: CALL_OW 69
4850: IFFALSE 4870
4852: GO 4854
4854: DISABLE
// begin cil_mit_1_ape_eng_splnen := true ;
4855: LD_ADDR_EXP 42
4859: PUSH
4860: LD_INT 1
4862: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
4863: LD_STRING M1a
4865: PPUSH
4866: CALL_OW 337
// end ;
4870: END
// every 0 0$3 trigger FilterAllUnits ( [ f_weapon , us_radar ] ) or ma_radar do
4871: LD_INT 34
4873: PUSH
4874: LD_INT 11
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL_OW 69
4885: PUSH
4886: CALL 4912 0 0
4890: OR
4891: IFFALSE 4911
4893: GO 4895
4895: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4896: LD_STRING M2b
4898: PPUSH
4899: CALL_OW 337
// RadarBuild := true ;
4903: LD_ADDR_EXP 47
4907: PUSH
4908: LD_INT 1
4910: ST_TO_ADDR
// end ;
4911: END
// function ma_radar ; var i ; begin
4912: LD_INT 0
4914: PPUSH
4915: PPUSH
// result := false ;
4916: LD_ADDR_VAR 0 1
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
4924: LD_ADDR_VAR 0 2
4928: PUSH
4929: LD_INT 21
4931: PUSH
4932: LD_INT 3
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PPUSH
4939: CALL_OW 69
4943: PUSH
4944: FOR_IN
4945: IFFALSE 4974
// begin if GetBWeapon ( i ) = us_radar then
4947: LD_VAR 0 2
4951: PPUSH
4952: CALL_OW 269
4956: PUSH
4957: LD_INT 11
4959: EQUAL
4960: IFFALSE 4972
// begin result := true ;
4962: LD_ADDR_VAR 0 1
4966: PUSH
4967: LD_INT 1
4969: ST_TO_ADDR
// break ;
4970: GO 4974
// end ; end ;
4972: GO 4944
4974: POP
4975: POP
// end ;
4976: LD_VAR 0 1
4980: RET
// every 7 7$0 do var hex , depot ;
4981: GO 4983
4983: DISABLE
4984: LD_INT 0
4986: PPUSH
4987: PPUSH
// begin depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) ;
4988: LD_ADDR_VAR 0 2
4992: PUSH
4993: LD_INT 2
4995: PUSH
4996: LD_INT 30
4998: PUSH
4999: LD_INT 0
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: PUSH
5006: LD_INT 30
5008: PUSH
5009: LD_INT 1
5011: PUSH
5012: EMPTY
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: LIST
5023: PPUSH
5024: CALL_OW 69
5028: ST_TO_ADDR
// if depot then
5029: LD_VAR 0 2
5033: IFFALSE 5051
// depot := depot [ 1 ] else
5035: LD_ADDR_VAR 0 2
5039: PUSH
5040: LD_VAR 0 2
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: ST_TO_ADDR
5049: GO 5061
// depot := JMM ;
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_EXP 11
5060: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
5061: LD_ADDR_VAR 0 1
5065: PUSH
5066: LD_INT 0
5068: PPUSH
5069: CALL_OW 15
5073: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5074: LD_VAR 0 2
5078: PPUSH
5079: LD_VAR 0 1
5083: PUSH
5084: LD_INT 1
5086: ARRAY
5087: PPUSH
5088: LD_VAR 0 1
5092: PUSH
5093: LD_INT 2
5095: ARRAY
5096: PPUSH
5097: CALL_OW 297
5101: PUSH
5102: LD_INT 10
5104: GREATER
5105: PUSH
5106: LD_VAR 0 2
5110: PPUSH
5111: LD_VAR 0 1
5115: PUSH
5116: LD_INT 1
5118: ARRAY
5119: PPUSH
5120: LD_VAR 0 1
5124: PUSH
5125: LD_INT 2
5127: ARRAY
5128: PPUSH
5129: CALL_OW 297
5133: PUSH
5134: LD_INT 20
5136: LESS
5137: AND
5138: IFFALSE 5061
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5140: LD_INT 5
5142: PPUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: PPUSH
5152: LD_VAR 0 1
5156: PUSH
5157: LD_INT 2
5159: ARRAY
5160: PPUSH
5161: LD_INT 5
5163: PPUSH
5164: LD_INT 1
5166: PPUSH
5167: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5171: LD_ADDR_EXP 55
5175: PUSH
5176: LD_EXP 55
5180: PUSH
5181: LD_INT 1
5183: PLUS
5184: ST_TO_ADDR
// end ;
5185: PPOPN 2
5187: END
// every 0 0$10 trigger zasilka_muze do var hex , depot ;
5188: LD_EXP 44
5192: IFFALSE 5409
5194: GO 5196
5196: DISABLE
5197: LD_INT 0
5199: PPUSH
5200: PPUSH
// begin wait ( 10 10$0 ) ;
5201: LD_INT 21000
5203: PPUSH
5204: CALL_OW 67
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) [ 1 ] ;
5208: LD_ADDR_VAR 0 2
5212: PUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 30
5218: PUSH
5219: LD_INT 0
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 30
5228: PUSH
5229: LD_INT 1
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 69
5248: PUSH
5249: LD_INT 1
5251: ARRAY
5252: ST_TO_ADDR
// if depot then
5253: LD_VAR 0 2
5257: IFFALSE 5275
// depot := depot [ 1 ] else
5259: LD_ADDR_VAR 0 2
5263: PUSH
5264: LD_VAR 0 2
5268: PUSH
5269: LD_INT 1
5271: ARRAY
5272: ST_TO_ADDR
5273: GO 5285
// depot := JMM ;
5275: LD_ADDR_VAR 0 2
5279: PUSH
5280: LD_EXP 11
5284: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
5285: LD_ADDR_VAR 0 1
5289: PUSH
5290: LD_INT 0
5292: PPUSH
5293: CALL_OW 15
5297: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5298: LD_VAR 0 2
5302: PPUSH
5303: LD_VAR 0 1
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: LD_VAR 0 1
5316: PUSH
5317: LD_INT 2
5319: ARRAY
5320: PPUSH
5321: CALL_OW 297
5325: PUSH
5326: LD_INT 10
5328: GREATER
5329: PUSH
5330: LD_VAR 0 2
5334: PPUSH
5335: LD_VAR 0 1
5339: PUSH
5340: LD_INT 1
5342: ARRAY
5343: PPUSH
5344: LD_VAR 0 1
5348: PUSH
5349: LD_INT 2
5351: ARRAY
5352: PPUSH
5353: CALL_OW 297
5357: PUSH
5358: LD_INT 20
5360: LESS
5361: AND
5362: IFFALSE 5285
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5364: LD_INT 5
5366: PPUSH
5367: LD_VAR 0 1
5371: PUSH
5372: LD_INT 1
5374: ARRAY
5375: PPUSH
5376: LD_VAR 0 1
5380: PUSH
5381: LD_INT 2
5383: ARRAY
5384: PPUSH
5385: LD_INT 5
5387: PPUSH
5388: LD_INT 1
5390: PPUSH
5391: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5395: LD_ADDR_EXP 55
5399: PUSH
5400: LD_EXP 55
5404: PUSH
5405: LD_INT 1
5407: PLUS
5408: ST_TO_ADDR
// end ;
5409: PPOPN 2
5411: END
// every 0 0$1 trigger zasilka_muze and Den do var cekani , budova , x , y , mytick ;
5412: LD_EXP 44
5416: PUSH
5417: LD_EXP 14
5421: AND
5422: IFFALSE 5872
5424: GO 5426
5426: DISABLE
5427: LD_INT 0
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
// begin cekani := [ 1 1$30 , 1 1$50 , 2 2$10 , 2 2$30 ] [ rand ( 1 , 4 ) ] ;
5434: LD_ADDR_VAR 0 1
5438: PUSH
5439: LD_INT 3150
5441: PUSH
5442: LD_INT 3850
5444: PUSH
5445: LD_INT 4550
5447: PUSH
5448: LD_INT 5250
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: LIST
5455: LIST
5456: PUSH
5457: LD_INT 1
5459: PPUSH
5460: LD_INT 4
5462: PPUSH
5463: CALL_OW 12
5467: ARRAY
5468: ST_TO_ADDR
// mytick := tick + cekani ;
5469: LD_ADDR_VAR 0 5
5473: PUSH
5474: LD_OWVAR 1
5478: PUSH
5479: LD_VAR 0 1
5483: PLUS
5484: ST_TO_ADDR
// while tick < mytick and GetTechProgress ( tech_ApePsych , you ) < 70 do
5485: LD_OWVAR 1
5489: PUSH
5490: LD_VAR 0 5
5494: LESS
5495: PUSH
5496: LD_INT 2
5498: PPUSH
5499: LD_EXP 1
5503: PPUSH
5504: CALL_OW 326
5508: PUSH
5509: LD_INT 70
5511: LESS
5512: AND
5513: IFFALSE 5524
// Wait ( 0 0$1 ) ;
5515: LD_INT 35
5517: PPUSH
5518: CALL_OW 67
5522: GO 5485
// budova := FilterAllUnits ( [ f_btype , b_depot ] ) ;
5524: LD_ADDR_VAR 0 2
5528: PUSH
5529: LD_INT 30
5531: PUSH
5532: LD_INT 0
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: PPUSH
5539: CALL_OW 69
5543: ST_TO_ADDR
// if budova then
5544: LD_VAR 0 2
5548: IFFALSE 5596
// begin budova := budova [ 1 ] ;
5550: LD_ADDR_VAR 0 2
5554: PUSH
5555: LD_VAR 0 2
5559: PUSH
5560: LD_INT 1
5562: ARRAY
5563: ST_TO_ADDR
// x := GetX ( budova ) ;
5564: LD_ADDR_VAR 0 3
5568: PUSH
5569: LD_VAR 0 2
5573: PPUSH
5574: CALL_OW 250
5578: ST_TO_ADDR
// y := GetY ( budova ) ;
5579: LD_ADDR_VAR 0 4
5583: PUSH
5584: LD_VAR 0 2
5588: PPUSH
5589: CALL_OW 251
5593: ST_TO_ADDR
// end else
5594: GO 5612
// begin x := 41 ;
5596: LD_ADDR_VAR 0 3
5600: PUSH
5601: LD_INT 41
5603: ST_TO_ADDR
// y := 24 ;
5604: LD_ADDR_VAR 0 4
5608: PUSH
5609: LD_INT 24
5611: ST_TO_ADDR
// end ; CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5612: LD_INT 5
5614: PPUSH
5615: LD_VAR 0 3
5619: PPUSH
5620: LD_VAR 0 4
5624: PPUSH
5625: LD_INT 10
5627: PPUSH
5628: LD_INT 1
5630: PPUSH
5631: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5635: LD_ADDR_EXP 55
5639: PUSH
5640: LD_EXP 55
5644: PUSH
5645: LD_INT 1
5647: PLUS
5648: ST_TO_ADDR
// Wait ( 0 0$6 ) ;
5649: LD_INT 210
5651: PPUSH
5652: CALL_OW 67
// DialogueOn ;
5656: CALL_OW 6
// Say ( JMM , D4-JMM-1 ) ;
5660: LD_EXP 11
5664: PPUSH
5665: LD_STRING D4-JMM-1
5667: PPUSH
5668: CALL_OW 88
// if Say ( Den , D4-Den-1 ) then
5672: LD_EXP 14
5676: PPUSH
5677: LD_STRING D4-Den-1
5679: PPUSH
5680: CALL_OW 88
5684: IFFALSE 5712
// if Say ( JMM , D4-JMM-2 ) then
5686: LD_EXP 11
5690: PPUSH
5691: LD_STRING D4-JMM-2
5693: PPUSH
5694: CALL_OW 88
5698: IFFALSE 5712
// Say ( Den , D4-Den-2 ) ;
5700: LD_EXP 14
5704: PPUSH
5705: LD_STRING D4-Den-2
5707: PPUSH
5708: CALL_OW 88
// DialogueOff ;
5712: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5716: LD_STRING M2
5718: PPUSH
5719: CALL_OW 337
// SetTech ( tech_Radar , you , state_enabled ) ;
5723: LD_INT 6
5725: PPUSH
5726: LD_EXP 1
5730: PPUSH
5731: LD_INT 1
5733: PPUSH
5734: CALL_OW 322
// SetRestrict ( b_lab_half , you , state_enabled ) ;
5738: LD_INT 7
5740: PPUSH
5741: LD_EXP 1
5745: PPUSH
5746: LD_INT 1
5748: PPUSH
5749: CALL_OW 324
// SetRestrict ( b_lab_opto , you , state_enabled ) ;
5753: LD_INT 15
5755: PPUSH
5756: LD_EXP 1
5760: PPUSH
5761: LD_INT 1
5763: PPUSH
5764: CALL_OW 324
// zasilka_landed := true ;
5768: LD_ADDR_EXP 45
5772: PUSH
5773: LD_INT 1
5775: ST_TO_ADDR
// if difficulty <= 2 then
5776: LD_OWVAR 67
5780: PUSH
5781: LD_INT 2
5783: LESSEQUAL
5784: IFFALSE 5872
// begin wait ( Rand ( 0 0$50 , 1 1$30 ) ) ;
5786: LD_INT 1750
5788: PPUSH
5789: LD_INT 3150
5791: PPUSH
5792: CALL_OW 12
5796: PPUSH
5797: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5801: LD_INT 5
5803: PPUSH
5804: LD_VAR 0 3
5808: PPUSH
5809: LD_VAR 0 4
5813: PPUSH
5814: LD_INT 10
5816: PPUSH
5817: LD_INT 1
5819: PPUSH
5820: CALL_OW 56
// if difficulty <= 1 then
5824: LD_OWVAR 67
5828: PUSH
5829: LD_INT 1
5831: LESSEQUAL
5832: IFFALSE 5872
// begin wait ( Rand ( 0 0$30 , 1 1$0 ) ) ;
5834: LD_INT 1050
5836: PPUSH
5837: LD_INT 2100
5839: PPUSH
5840: CALL_OW 12
5844: PPUSH
5845: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5849: LD_INT 5
5851: PPUSH
5852: LD_VAR 0 3
5856: PPUSH
5857: LD_VAR 0 4
5861: PPUSH
5862: LD_INT 10
5864: PPUSH
5865: LD_INT 1
5867: PPUSH
5868: CALL_OW 56
// end ; end ; end ;
5872: PPOPN 5
5874: END
// every 0 0$3.0 trigger attacking and see_any ( you , oma ) do var dia1 , kdo1 , kdo2 , kdo3 , cvidi ;
5875: LD_EXP 39
5879: PUSH
5880: LD_EXP 1
5884: PPUSH
5885: LD_EXP 8
5889: PPUSH
5890: CALL 13858 0 2
5894: AND
5895: IFFALSE 6453
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
// begin while cvidi < 5 do
5907: LD_VAR 0 5
5911: PUSH
5912: LD_INT 5
5914: LESS
5915: IFFALSE 5965
// begin while see_any ( you , oma ) do
5917: LD_EXP 1
5921: PPUSH
5922: LD_EXP 8
5926: PPUSH
5927: CALL 13858 0 2
5931: IFFALSE 5956
// begin Wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// cvidi := cvidi + 1 ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 5
5949: PUSH
5950: LD_INT 1
5952: PLUS
5953: ST_TO_ADDR
// end ;
5954: GO 5917
// Wait ( 0 0$1 ) ;
5956: LD_INT 35
5958: PPUSH
5959: CALL_OW 67
// end ;
5963: GO 5907
// for dia1 := 1 to 5 do
5965: LD_ADDR_VAR 0 1
5969: PUSH
5970: DOUBLE
5971: LD_INT 1
5973: DEC
5974: ST_TO_ADDR
5975: LD_INT 5
5977: PUSH
5978: FOR_TO
5979: IFFALSE 6015
// begin while see_any ( you , oma ) do
5981: LD_EXP 1
5985: PPUSH
5986: LD_EXP 8
5990: PPUSH
5991: CALL 13858 0 2
5995: IFFALSE 6006
// Wait ( 0 0$1 ) ;
5997: LD_INT 35
5999: PPUSH
6000: CALL_OW 67
6004: GO 5981
// Wait ( 0 0$1 ) ;
6006: LD_INT 35
6008: PPUSH
6009: CALL_OW 67
// end ;
6013: GO 5978
6015: POP
6016: POP
// if IsLive ( Lisa ) then
6017: LD_EXP 15
6021: PPUSH
6022: CALL_OW 300
6026: IFFALSE 6145
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 0 ) ;
6028: LD_ADDR_VAR 0 2
6032: PUSH
6033: LD_EXP 49
6037: PPUSH
6038: LD_EXP 1
6042: PPUSH
6043: LD_INT 1
6045: PPUSH
6046: LD_INT 0
6048: PPUSH
6049: LD_INT 0
6051: PPUSH
6052: CALL 14961 0 5
6056: ST_TO_ADDR
// DialogueOn ;
6057: CALL_OW 6
// if Say ( kdo1 , D5a-Sol1-1 ) then
6061: LD_VAR 0 2
6065: PPUSH
6066: LD_STRING D5a-Sol1-1
6068: PPUSH
6069: CALL_OW 88
6073: IFFALSE 6087
// Say ( Lisa , D5a-Lisa-1 ) ;
6075: LD_EXP 15
6079: PPUSH
6080: LD_STRING D5a-Lisa-1
6082: PPUSH
6083: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-2 ) then
6087: LD_VAR 0 2
6091: PPUSH
6092: LD_STRING D5a-Sol1-2
6094: PPUSH
6095: CALL_OW 88
6099: IFFALSE 6113
// Say ( Lisa , D5a-Lisa-2 ) ;
6101: LD_EXP 15
6105: PPUSH
6106: LD_STRING D5a-Lisa-2
6108: PPUSH
6109: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-3 ) then
6113: LD_VAR 0 2
6117: PPUSH
6118: LD_STRING D5a-Sol1-3
6120: PPUSH
6121: CALL_OW 88
6125: IFFALSE 6139
// Say ( Lisa , D5a-Lisa-3 ) ;
6127: LD_EXP 15
6131: PPUSH
6132: LD_STRING D5a-Lisa-3
6134: PPUSH
6135: CALL_OW 88
// DialogueOff ;
6139: CALL_OW 7
// end else
6143: GO 6445
// begin DialogueOn ;
6145: CALL_OW 6
// kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
6149: LD_ADDR_VAR 0 2
6153: PUSH
6154: LD_EXP 49
6158: PPUSH
6159: LD_EXP 1
6163: PPUSH
6164: LD_INT 1
6166: PPUSH
6167: LD_INT 0
6169: PPUSH
6170: LD_INT 1
6172: PPUSH
6173: CALL 14961 0 5
6177: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
6178: LD_ADDR_VAR 0 3
6182: PUSH
6183: LD_EXP 49
6187: PPUSH
6188: LD_EXP 1
6192: PPUSH
6193: LD_INT 1
6195: PPUSH
6196: LD_INT 0
6198: PPUSH
6199: LD_INT 2
6201: PPUSH
6202: CALL 14961 0 5
6206: ST_TO_ADDR
// kdo3 := WhoSayAny ( not_char , you , sex_female , 0 , 1 ) ;
6207: LD_ADDR_VAR 0 4
6211: PUSH
6212: LD_EXP 49
6216: PPUSH
6217: LD_EXP 1
6221: PPUSH
6222: LD_INT 2
6224: PPUSH
6225: LD_INT 0
6227: PPUSH
6228: LD_INT 1
6230: PPUSH
6231: CALL 14961 0 5
6235: ST_TO_ADDR
// if Say ( kdo1 , D5-Sol1-1 ) then
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_STRING D5-Sol1-1
6243: PPUSH
6244: CALL_OW 88
6248: IFFALSE 6277
// if not Say ( kdo2 , D5-Sol2-1 ) then
6250: LD_VAR 0 3
6254: PPUSH
6255: LD_STRING D5-Sol2-1
6257: PPUSH
6258: CALL_OW 88
6262: NOT
6263: IFFALSE 6277
// Say ( kdo3 , D5-FSol2-1 ) ;
6265: LD_VAR 0 4
6269: PPUSH
6270: LD_STRING D5-FSol2-1
6272: PPUSH
6273: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-2 ) then
6277: LD_VAR 0 2
6281: PPUSH
6282: LD_STRING D5-Sol1-2
6284: PPUSH
6285: CALL_OW 88
6289: IFFALSE 6318
// if not Say ( kdo2 , D5-Sol2-2 ) then
6291: LD_VAR 0 3
6295: PPUSH
6296: LD_STRING D5-Sol2-2
6298: PPUSH
6299: CALL_OW 88
6303: NOT
6304: IFFALSE 6318
// Say ( kdo3 , D5-FSol2-2 ) ;
6306: LD_VAR 0 4
6310: PPUSH
6311: LD_STRING D5-FSol2-2
6313: PPUSH
6314: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-3 ) then
6318: LD_VAR 0 2
6322: PPUSH
6323: LD_STRING D5-Sol1-3
6325: PPUSH
6326: CALL_OW 88
6330: IFFALSE 6359
// if not Say ( kdo2 , D5-Sol2-3 ) then
6332: LD_VAR 0 3
6336: PPUSH
6337: LD_STRING D5-Sol2-3
6339: PPUSH
6340: CALL_OW 88
6344: NOT
6345: IFFALSE 6359
// Say ( kdo3 , D5-FSol2-3 ) ;
6347: LD_VAR 0 4
6351: PPUSH
6352: LD_STRING D5-FSol2-3
6354: PPUSH
6355: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-4 ) then
6359: LD_VAR 0 2
6363: PPUSH
6364: LD_STRING D5-Sol1-4
6366: PPUSH
6367: CALL_OW 88
6371: IFFALSE 6400
// if not Say ( kdo2 , D5-Sol2-4 ) then
6373: LD_VAR 0 3
6377: PPUSH
6378: LD_STRING D5-Sol2-4
6380: PPUSH
6381: CALL_OW 88
6385: NOT
6386: IFFALSE 6400
// Say ( kdo3 , D5-FSol2-4 ) ;
6388: LD_VAR 0 4
6392: PPUSH
6393: LD_STRING D5-FSol2-4
6395: PPUSH
6396: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-5 ) then
6400: LD_VAR 0 2
6404: PPUSH
6405: LD_STRING D5-Sol1-5
6407: PPUSH
6408: CALL_OW 88
6412: IFFALSE 6441
// if not Say ( kdo2 , D5-Sol2-5 ) then
6414: LD_VAR 0 3
6418: PPUSH
6419: LD_STRING D5-Sol2-5
6421: PPUSH
6422: CALL_OW 88
6426: NOT
6427: IFFALSE 6441
// Say ( kdo3 , D5-FSol2-5 ) ;
6429: LD_VAR 0 4
6433: PPUSH
6434: LD_STRING D5-FSol2-5
6436: PPUSH
6437: CALL_OW 88
// DialogueOff ;
6441: CALL_OW 7
// end ; denis_can_come := true ;
6445: LD_ADDR_EXP 46
6449: PUSH
6450: LD_INT 1
6452: ST_TO_ADDR
// end ;
6453: PPOPN 5
6455: END
// var den_uz_ochocil ; on ApemanTamed ( ktery , kym ) do begin if ( GetSide ( kym ) = you ) then
6456: LD_VAR 0 2
6460: PPUSH
6461: CALL_OW 255
6465: PUSH
6466: LD_EXP 1
6470: EQUAL
6471: IFFALSE 6720
// begin opic := opic + 1 ;
6473: LD_ADDR_EXP 41
6477: PUSH
6478: LD_EXP 41
6482: PUSH
6483: LD_INT 1
6485: PLUS
6486: ST_TO_ADDR
// if kym = Den and not den_uz_ochocil then
6487: LD_VAR 0 2
6491: PUSH
6492: LD_EXP 14
6496: EQUAL
6497: PUSH
6498: LD_LOC 4
6502: NOT
6503: AND
6504: IFFALSE 6536
// begin TalkOn ;
6506: CALL 14807 0 0
// Say ( Den , D7a-Den-1 ) ;
6510: LD_EXP 14
6514: PPUSH
6515: LD_STRING D7a-Den-1
6517: PPUSH
6518: CALL_OW 88
// TalkOff ;
6522: CALL 14815 0 0
// den_uz_ochocil := true ;
6526: LD_ADDR_LOC 4
6530: PUSH
6531: LD_INT 1
6533: ST_TO_ADDR
// end else
6534: GO 6662
// if not first_ape then
6536: LD_EXP 31
6540: NOT
6541: IFFALSE 6662
// begin if kym = Glad then
6543: LD_VAR 0 2
6547: PUSH
6548: LD_EXP 12
6552: EQUAL
6553: IFFALSE 6577
// begin TalkOn ;
6555: CALL 14807 0 0
// Say ( Glad , D7b-Glad-1 ) ;
6559: LD_EXP 12
6563: PPUSH
6564: LD_STRING D7b-Glad-1
6566: PPUSH
6567: CALL_OW 88
// TalkOff ;
6571: CALL 14815 0 0
// end else
6575: GO 6662
// begin if GetSex ( kym ) = sex_male then
6577: LD_VAR 0 2
6581: PPUSH
6582: CALL_OW 258
6586: PUSH
6587: LD_INT 1
6589: EQUAL
6590: IFFALSE 6628
// begin TalkOn ;
6592: CALL 14807 0 0
// SayAny ( not_char , D7c-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
6596: LD_EXP 49
6600: PPUSH
6601: LD_STRING D7c-Sci1-1
6603: PPUSH
6604: LD_EXP 1
6608: PPUSH
6609: LD_INT 1
6611: PPUSH
6612: LD_INT 4
6614: PPUSH
6615: LD_INT 0
6617: PPUSH
6618: CALL 14881 0 6
// TalkOff ;
6622: CALL 14815 0 0
// end else
6626: GO 6662
// begin TalkOn ;
6628: CALL 14807 0 0
// SayAny ( not_char , D7c-FSci1-1 , you , sex_female , class_scientistic , 0 ) ;
6632: LD_EXP 49
6636: PPUSH
6637: LD_STRING D7c-FSci1-1
6639: PPUSH
6640: LD_EXP 1
6644: PPUSH
6645: LD_INT 2
6647: PPUSH
6648: LD_INT 4
6650: PPUSH
6651: LD_INT 0
6653: PPUSH
6654: CALL 14881 0 6
// TalkOff ;
6658: CALL 14815 0 0
// end ; end ; end ; if not first_ape then
6662: LD_EXP 31
6666: NOT
6667: IFFALSE 6720
// begin first_ape := true ;
6669: LD_ADDR_EXP 31
6673: PUSH
6674: LD_INT 1
6676: ST_TO_ADDR
// if kym <> Glad and IsLive ( Glad ) then
6677: LD_VAR 0 2
6681: PUSH
6682: LD_EXP 12
6686: NONEQUAL
6687: PUSH
6688: LD_EXP 12
6692: PPUSH
6693: CALL_OW 300
6697: AND
6698: IFFALSE 6720
// begin TalkOn ;
6700: CALL 14807 0 0
// Say ( Glad , D7c-Glad-1 ) ;
6704: LD_EXP 12
6708: PPUSH
6709: LD_STRING D7c-Glad-1
6711: PPUSH
6712: CALL_OW 88
// TalkOff ;
6716: CALL 14815 0 0
// end ; end ; end ; end ;
6720: PPOPN 2
6722: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) and GetDistUnits ( NearestUnitToUnit ( UnitFilter ( apemans , [ f_side , you ] ) , Lisa ) , Lisa ) < 6 do
6723: LD_INT 22
6725: PUSH
6726: LD_EXP 1
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PUSH
6735: LD_INT 101
6737: PUSH
6738: LD_EXP 4
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL_OW 69
6755: NOT
6756: PUSH
6757: LD_EXP 6
6761: PPUSH
6762: LD_INT 22
6764: PUSH
6765: LD_EXP 1
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PPUSH
6774: CALL_OW 72
6778: PPUSH
6779: LD_EXP 15
6783: PPUSH
6784: CALL_OW 74
6788: PPUSH
6789: LD_EXP 15
6793: PPUSH
6794: CALL_OW 296
6798: PUSH
6799: LD_INT 6
6801: LESS
6802: AND
6803: IFFALSE 6828
6805: GO 6807
6807: DISABLE
// begin TalkOn ;
6808: CALL 14807 0 0
// Say ( Lisa , D8-Lisa-1 ) ;
6812: LD_EXP 15
6816: PPUSH
6817: LD_STRING D8-Lisa-1
6819: PPUSH
6820: CALL_OW 88
// TalkOff ;
6824: CALL 14815 0 0
// end ;
6828: END
// every 0 0$10 trigger cil_mit_1_ape_eng_splnen do var qr ;
6829: LD_EXP 42
6833: IFFALSE 6876
6835: GO 6837
6837: DISABLE
6838: LD_INT 0
6840: PPUSH
// begin qr := Query ( Q2 ) ;
6841: LD_ADDR_VAR 0 1
6845: PUSH
6846: LD_STRING Q2
6848: PPUSH
6849: CALL_OW 97
6853: ST_TO_ADDR
// end_the_mission_allowed := true ;
6854: LD_ADDR_OWVAR 57
6858: PUSH
6859: LD_INT 1
6861: ST_TO_ADDR
// if qr = 1 then
6862: LD_VAR 0 1
6866: PUSH
6867: LD_INT 1
6869: EQUAL
6870: IFFALSE 6876
// begin Vyhra ;
6872: CALL 3263 0 0
// end ; end ; end_of_file
6876: PPOPN 1
6878: END
// export depot , laboratore , budovy ; on BuildingComplete ( build ) do begin budovy := budovy union build ;
6879: LD_ADDR_EXP 64
6883: PUSH
6884: LD_EXP 64
6888: PUSH
6889: LD_VAR 0 1
6893: UNION
6894: ST_TO_ADDR
// if GetBType ( build ) = b_lab then
6895: LD_VAR 0 1
6899: PPUSH
6900: CALL_OW 266
6904: PUSH
6905: LD_INT 6
6907: EQUAL
6908: IFFALSE 6926
// laboratore := laboratore union build ;
6910: LD_ADDR_EXP 63
6914: PUSH
6915: LD_EXP 63
6919: PUSH
6920: LD_VAR 0 1
6924: UNION
6925: ST_TO_ADDR
// if GetBType ( build ) = b_depot then
6926: LD_VAR 0 1
6930: PPUSH
6931: CALL_OW 266
6935: PUSH
6936: LD_INT 0
6938: EQUAL
6939: IFFALSE 6963
// begin depot := build ;
6941: LD_ADDR_EXP 62
6945: PUSH
6946: LD_VAR 0 1
6950: ST_TO_ADDR
// SetBName ( build , delta ) ;
6951: LD_VAR 0 1
6955: PPUSH
6956: LD_STRING delta
6958: PPUSH
6959: CALL_OW 500
// end ; if GetBType ( build ) = b_workshop then
6963: LD_VAR 0 1
6967: PPUSH
6968: CALL_OW 266
6972: PUSH
6973: LD_INT 2
6975: EQUAL
6976: IFFALSE 6985
// MyHint ( Recycle ) ;
6978: LD_STRING Recycle
6980: PPUSH
6981: CALL 15155 0 1
// if GetBType ( build ) = b_ext_radar then
6985: LD_VAR 0 1
6989: PPUSH
6990: CALL_OW 266
6994: PUSH
6995: LD_INT 20
6997: EQUAL
6998: IFFALSE 7007
// MyHint ( Radar ) ;
7000: LD_STRING Radar
7002: PPUSH
7003: CALL 15155 0 1
// end ;
7007: PPOPN 1
7009: END
// on UnitDestroyed ( un ) do begin if un in budovy then
7010: LD_VAR 0 1
7014: PUSH
7015: LD_EXP 64
7019: IN
7020: IFFALSE 7038
// budovy := budovy diff un ;
7022: LD_ADDR_EXP 64
7026: PUSH
7027: LD_EXP 64
7031: PUSH
7032: LD_VAR 0 1
7036: DIFF
7037: ST_TO_ADDR
// if un in laboratore then
7038: LD_VAR 0 1
7042: PUSH
7043: LD_EXP 63
7047: IN
7048: IFFALSE 7066
// laboratore := laboratore diff un ;
7050: LD_ADDR_EXP 63
7054: PUSH
7055: LD_EXP 63
7059: PUSH
7060: LD_VAR 0 1
7064: DIFF
7065: ST_TO_ADDR
// if un in tvoji_lidi then
7066: LD_VAR 0 1
7070: PUSH
7071: LD_EXP 48
7075: IN
7076: IFFALSE 7108
// begin tvoji_lidi := tvoji_lidi diff un ;
7078: LD_ADDR_EXP 48
7082: PUSH
7083: LD_EXP 48
7087: PUSH
7088: LD_VAR 0 1
7092: DIFF
7093: ST_TO_ADDR
// ztraty := ztraty + 1 ;
7094: LD_ADDR_EXP 51
7098: PUSH
7099: LD_EXP 51
7103: PUSH
7104: LD_INT 1
7106: PLUS
7107: ST_TO_ADDR
// end ; if un in oma then
7108: LD_VAR 0 1
7112: PUSH
7113: LD_EXP 8
7117: IN
7118: IFFALSE 7136
// oma := oma diff un ;
7120: LD_ADDR_EXP 8
7124: PUSH
7125: LD_EXP 8
7129: PUSH
7130: LD_VAR 0 1
7134: DIFF
7135: ST_TO_ADDR
// if un in arabs_cars then
7136: LD_VAR 0 1
7140: PUSH
7141: LD_EXP 10
7145: IN
7146: IFFALSE 7164
// arabs_cars := arabs_cars diff un ;
7148: LD_ADDR_EXP 10
7152: PUSH
7153: LD_EXP 10
7157: PUSH
7158: LD_VAR 0 1
7162: DIFF
7163: ST_TO_ADDR
// if un in apemans then
7164: LD_VAR 0 1
7168: PUSH
7169: LD_EXP 6
7173: IN
7174: IFFALSE 7192
// apemans := apemans diff un ;
7176: LD_ADDR_EXP 6
7180: PUSH
7181: LD_EXP 6
7185: PUSH
7186: LD_VAR 0 1
7190: DIFF
7191: ST_TO_ADDR
// if un = JMM then
7192: LD_VAR 0 1
7196: PUSH
7197: LD_EXP 11
7201: EQUAL
7202: IFFALSE 7214
// begin disable ( 0 ) ;
7204: LD_INT 0
7206: DISABLE_MARKED
// YouLost ( JMM ) ;
7207: LD_STRING JMM
7209: PPUSH
7210: CALL_OW 104
// end ; if UnitFilter ( un , [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) then
7214: LD_VAR 0 1
7218: PPUSH
7219: LD_INT 22
7221: PUSH
7222: LD_EXP 1
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 23
7233: PUSH
7234: LD_INT 0
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 72
7249: IFFALSE 7265
// begin opic := opic - 1 ;
7251: LD_ADDR_EXP 41
7255: PUSH
7256: LD_EXP 41
7260: PUSH
7261: LD_INT 1
7263: MINUS
7264: ST_TO_ADDR
// end ; end ;
7265: PPOPN 1
7267: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = you then
7268: LD_VAR 0 3
7272: PUSH
7273: LD_EXP 1
7277: EQUAL
7278: IFFALSE 7311
// begin arabs_cars := arabs_cars union vehnew ;
7280: LD_ADDR_EXP 10
7284: PUSH
7285: LD_EXP 10
7289: PUSH
7290: LD_VAR 0 1
7294: UNION
7295: ST_TO_ADDR
// evade_shortest_way ( vehnew , false , true ) ;
7296: LD_VAR 0 1
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: LD_INT 1
7306: PPUSH
7307: CALL 12822 0 3
// end ; if origside = arabians then
7311: LD_VAR 0 3
7315: PUSH
7316: LD_EXP 4
7320: EQUAL
7321: IFFALSE 7339
// begin arabs_cars := arabs_cars diff vehold ;
7323: LD_ADDR_EXP 10
7327: PUSH
7328: LD_EXP 10
7332: PUSH
7333: LD_VAR 0 2
7337: DIFF
7338: ST_TO_ADDR
// end ; end ;
7339: PPOPN 4
7341: END
// every 0 0$10 do
7342: GO 7344
7344: DISABLE
// Randomize ;
7345: CALL_OW 10
7349: END
// every 0 0$10 trigger apemans < 5 do var op ;
7350: LD_EXP 6
7354: PUSH
7355: LD_INT 5
7357: LESS
7358: IFFALSE 7624
7360: GO 7362
7362: DISABLE
7363: LD_INT 0
7365: PPUSH
// begin InitUc ;
7366: CALL_OW 18
// InitHc ;
7370: CALL_OW 19
// uc_nation := nation_nature ;
7374: LD_ADDR_OWVAR 21
7378: PUSH
7379: LD_INT 0
7381: ST_TO_ADDR
// uc_side := 0 ;
7382: LD_ADDR_OWVAR 20
7386: PUSH
7387: LD_INT 0
7389: ST_TO_ADDR
// hc_class := class_apeman ;
7390: LD_ADDR_OWVAR 28
7394: PUSH
7395: LD_INT 12
7397: ST_TO_ADDR
// hc_agressivity := Rand ( - 5 , 10 ) ;
7398: LD_ADDR_OWVAR 35
7402: PUSH
7403: LD_INT 5
7405: NEG
7406: PPUSH
7407: LD_INT 10
7409: PPUSH
7410: CALL_OW 12
7414: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
7415: LD_ADDR_OWVAR 27
7419: PUSH
7420: LD_INT 1
7422: PPUSH
7423: LD_INT 2
7425: PPUSH
7426: CALL_OW 12
7430: ST_TO_ADDR
// op := CreateHuman ;
7431: LD_ADDR_VAR 0 1
7435: PUSH
7436: CALL_OW 44
7440: ST_TO_ADDR
// case rand ( 1 , 4 ) of 1 :
7441: LD_INT 1
7443: PPUSH
7444: LD_INT 4
7446: PPUSH
7447: CALL_OW 12
7451: PUSH
7452: LD_INT 1
7454: DOUBLE
7455: EQUAL
7456: IFTRUE 7460
7458: GO 7484
7460: POP
// PlaceUnitXYR ( op , 16 , 1 , 5 , false ) ; 2 :
7461: LD_VAR 0 1
7465: PPUSH
7466: LD_INT 16
7468: PPUSH
7469: LD_INT 1
7471: PPUSH
7472: LD_INT 5
7474: PPUSH
7475: LD_INT 0
7477: PPUSH
7478: CALL_OW 50
7482: GO 7581
7484: LD_INT 2
7486: DOUBLE
7487: EQUAL
7488: IFTRUE 7492
7490: GO 7516
7492: POP
// PlaceUnitXYR ( op , 46 , 1 , 5 , false ) ; 3 :
7493: LD_VAR 0 1
7497: PPUSH
7498: LD_INT 46
7500: PPUSH
7501: LD_INT 1
7503: PPUSH
7504: LD_INT 5
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 50
7514: GO 7581
7516: LD_INT 3
7518: DOUBLE
7519: EQUAL
7520: IFTRUE 7524
7522: GO 7548
7524: POP
// PlaceUnitXYR ( op , 1 , 23 , 5 , false ) ; 4 :
7525: LD_VAR 0 1
7529: PPUSH
7530: LD_INT 1
7532: PPUSH
7533: LD_INT 23
7535: PPUSH
7536: LD_INT 5
7538: PPUSH
7539: LD_INT 0
7541: PPUSH
7542: CALL_OW 50
7546: GO 7581
7548: LD_INT 4
7550: DOUBLE
7551: EQUAL
7552: IFTRUE 7556
7554: GO 7580
7556: POP
// PlaceUnitXYR ( op , 80 , 1 , 5 , false ) ; end ;
7557: LD_VAR 0 1
7561: PPUSH
7562: LD_INT 80
7564: PPUSH
7565: LD_INT 1
7567: PPUSH
7568: LD_INT 5
7570: PPUSH
7571: LD_INT 0
7573: PPUSH
7574: CALL_OW 50
7578: GO 7581
7580: POP
// apemans := apemans union op ;
7581: LD_ADDR_EXP 6
7585: PUSH
7586: LD_EXP 6
7590: PUSH
7591: LD_VAR 0 1
7595: UNION
7596: ST_TO_ADDR
// added_apes := added_apes + 1 ;
7597: LD_ADDR_EXP 53
7601: PUSH
7602: LD_EXP 53
7606: PUSH
7607: LD_INT 1
7609: PLUS
7610: ST_TO_ADDR
// if added_apes < max_added_apes then
7611: LD_EXP 53
7615: PUSH
7616: LD_EXP 54
7620: LESS
7621: IFFALSE 7624
// enable ;
7623: ENABLE
// end ; end_of_file
7624: PPOPN 1
7626: END
// var amici_v ; var amici_h ; var amici_b ; on DestinationUnreachable ( un ) do begin if GetSide ( un ) = arabians then
7627: LD_VAR 0 1
7631: PPUSH
7632: CALL_OW 255
7636: PUSH
7637: LD_EXP 4
7641: EQUAL
7642: IFFALSE 7725
// begin if attacking and laboratore then
7644: LD_EXP 39
7648: PUSH
7649: LD_EXP 63
7653: AND
7654: IFFALSE 7713
// begin ComAgressiveMove ( un , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7656: LD_VAR 0 1
7660: PPUSH
7661: LD_EXP 63
7665: PUSH
7666: LD_INT 1
7668: ARRAY
7669: PPUSH
7670: CALL_OW 250
7674: PPUSH
7675: LD_EXP 63
7679: PUSH
7680: LD_INT 1
7682: ARRAY
7683: PPUSH
7684: CALL_OW 251
7688: PPUSH
7689: CALL_OW 114
// AddComAttackUnit ( un , laboratore [ 1 ] ) ;
7693: LD_VAR 0 1
7697: PPUSH
7698: LD_EXP 63
7702: PUSH
7703: LD_INT 1
7705: ARRAY
7706: PPUSH
7707: CALL_OW 175
// end else
7711: GO 7725
// ComMoveToArea ( un , border ) ;
7713: LD_VAR 0 1
7717: PPUSH
7718: LD_INT 7
7720: PPUSH
7721: CALL_OW 113
// end ; end ;
7725: PPOPN 1
7727: END
// every 0 0$50 do
7728: GO 7730
7730: DISABLE
// begin Wait ( wait_first_attack ) ;
7731: LD_EXP 60
7735: PPUSH
7736: CALL_OW 67
// attacky := attacky + 1 ;
7740: LD_ADDR_EXP 40
7744: PUSH
7745: LD_EXP 40
7749: PUSH
7750: LD_INT 1
7752: PLUS
7753: ST_TO_ADDR
// attacking := true ;
7754: LD_ADDR_EXP 39
7758: PUSH
7759: LD_INT 1
7761: ST_TO_ADDR
// F_first_attack ;
7762: CALL 9293 0 0
// oma := FilterAllUnits ( [ f_side , arabians ] ) ;
7766: LD_ADDR_EXP 8
7770: PUSH
7771: LD_INT 22
7773: PUSH
7774: LD_EXP 4
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PPUSH
7783: CALL_OW 69
7787: ST_TO_ADDR
// end ;
7788: END
// every 0 0$1 do var i ;
7789: GO 7791
7791: DISABLE
7792: LD_INT 0
7794: PPUSH
// begin om := FilterAllUnits ( [ f_side , arabians ] ) ;
7795: LD_ADDR_EXP 9
7799: PUSH
7800: LD_INT 22
7802: PUSH
7803: LD_EXP 4
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PPUSH
7812: CALL_OW 69
7816: ST_TO_ADDR
// for i in om do
7817: LD_ADDR_VAR 0 1
7821: PUSH
7822: LD_EXP 9
7826: PUSH
7827: FOR_IN
7828: IFFALSE 7864
// if IsIdle ( i ) then
7830: LD_VAR 0 1
7834: PPUSH
7835: CALL_OW 316
7839: IFFALSE 7862
// begin RaiseSailEvent ( i ) ;
7841: LD_VAR 0 1
7845: PPUSH
7846: CALL_OW 427
// ComMoveToArea ( i , border ) ;
7850: LD_VAR 0 1
7854: PPUSH
7855: LD_INT 7
7857: PPUSH
7858: CALL_OW 113
// end ;
7862: GO 7827
7864: POP
7865: POP
// enable ;
7866: ENABLE
// end ;
7867: PPOPN 1
7869: END
// on SailEvent ( x ) do var k ;
7870: LD_INT 0
7872: PPUSH
// begin k := 0 ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_INT 0
7880: ST_TO_ADDR
// while k < 3 and IsLive ( x ) do
7881: LD_VAR 0 2
7885: PUSH
7886: LD_INT 3
7888: LESS
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 300
7899: AND
7900: IFFALSE 7936
// begin wait ( 0 0$1 ) ;
7902: LD_INT 35
7904: PPUSH
7905: CALL_OW 67
// if IsIdle ( x ) then
7909: LD_VAR 0 1
7913: PPUSH
7914: CALL_OW 316
7918: IFFALSE 7934
// k := k + 1 ;
7920: LD_ADDR_VAR 0 2
7924: PUSH
7925: LD_VAR 0 2
7929: PUSH
7930: LD_INT 1
7932: PLUS
7933: ST_TO_ADDR
// end ;
7934: GO 7881
// ComMoveToArea ( x , border ) ;
7936: LD_VAR 0 1
7940: PPUSH
7941: LD_INT 7
7943: PPUSH
7944: CALL_OW 113
// AddComWait ( x , 0 0$10 ) ;
7948: LD_VAR 0 1
7952: PPUSH
7953: LD_INT 350
7955: PPUSH
7956: CALL_OW 202
// if laboratore then
7960: LD_EXP 63
7964: IFFALSE 8003
// AddComAgressiveMove ( x , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7966: LD_VAR 0 1
7970: PPUSH
7971: LD_EXP 63
7975: PUSH
7976: LD_INT 1
7978: ARRAY
7979: PPUSH
7980: CALL_OW 250
7984: PPUSH
7985: LD_EXP 63
7989: PUSH
7990: LD_INT 1
7992: ARRAY
7993: PPUSH
7994: CALL_OW 251
7998: PPUSH
7999: CALL_OW 174
// end ;
8003: PPOPN 2
8005: END
// export last_attack_was ; every 3 3$50.0 + 3 3$0 trigger budovy and not attacking do
8006: LD_EXP 64
8010: PUSH
8011: LD_EXP 39
8015: NOT
8016: AND
8017: IFFALSE 8047
8019: GO 8021
8021: DISABLE
// begin if difficulty = 1 then
8022: LD_OWVAR 67
8026: PUSH
8027: LD_INT 1
8029: EQUAL
8030: IFFALSE 8047
// begin last_attack_was := tick ;
8032: LD_ADDR_EXP 65
8036: PUSH
8037: LD_OWVAR 1
8041: ST_TO_ADDR
// WhichAttack ;
8042: CALL 8267 0 0
// enable ;
8046: ENABLE
// end ; end ;
8047: END
// every 3 3$10.0 + 2 2$0 trigger budovy and not attacking do
8048: LD_EXP 64
8052: PUSH
8053: LD_EXP 39
8057: NOT
8058: AND
8059: IFFALSE 8089
8061: GO 8063
8063: DISABLE
// begin if difficulty = 2 then
8064: LD_OWVAR 67
8068: PUSH
8069: LD_INT 2
8071: EQUAL
8072: IFFALSE 8089
// begin last_attack_was := tick ;
8074: LD_ADDR_EXP 65
8078: PUSH
8079: LD_OWVAR 1
8083: ST_TO_ADDR
// WhichAttack ;
8084: CALL 8267 0 0
// enable ;
8088: ENABLE
// end ; end ;
8089: END
// every 2 2$30.0 + 1 1$30 trigger budovy and not attacking do
8090: LD_EXP 64
8094: PUSH
8095: LD_EXP 39
8099: NOT
8100: AND
8101: IFFALSE 8131
8103: GO 8105
8105: DISABLE
// begin if difficulty = 3 then
8106: LD_OWVAR 67
8110: PUSH
8111: LD_INT 3
8113: EQUAL
8114: IFFALSE 8131
// begin last_attack_was := tick ;
8116: LD_ADDR_EXP 65
8120: PUSH
8121: LD_OWVAR 1
8125: ST_TO_ADDR
// WhichAttack ;
8126: CALL 8267 0 0
// enable ;
8130: ENABLE
// end ; end ;
8131: END
// function free_cars ; var i ; begin
8132: LD_INT 0
8134: PPUSH
8135: PPUSH
// for i in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) do
8136: LD_ADDR_VAR 0 2
8140: PUSH
8141: LD_INT 21
8143: PUSH
8144: LD_INT 2
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 22
8153: PUSH
8154: LD_EXP 1
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PUSH
8172: FOR_IN
8173: IFFALSE 8199
// begin if not IsDrivenBy ( i ) then
8175: LD_VAR 0 2
8179: PPUSH
8180: CALL_OW 311
8184: NOT
8185: IFFALSE 8197
// begin result := true ;
8187: LD_ADDR_VAR 0 1
8191: PUSH
8192: LD_INT 1
8194: ST_TO_ADDR
// break ;
8195: GO 8199
// end ; end ;
8197: GO 8172
8199: POP
8200: POP
// end ;
8201: LD_VAR 0 1
8205: RET
// function lonely ; begin
8206: LD_INT 0
8208: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , depot , 16 ] ] ) ;
8209: LD_ADDR_VAR 0 1
8213: PUSH
8214: LD_INT 22
8216: PUSH
8217: LD_EXP 1
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: PUSH
8226: LD_INT 21
8228: PUSH
8229: LD_INT 1
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 91
8238: PUSH
8239: LD_EXP 62
8243: PUSH
8244: LD_INT 16
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 69
8261: ST_TO_ADDR
// end ;
8262: LD_VAR 0 1
8266: RET
// function WhichAttack ; var l ; begin
8267: LD_INT 0
8269: PPUSH
8270: PPUSH
// attacky := attacky + 1 ;
8271: LD_ADDR_EXP 40
8275: PUSH
8276: LD_EXP 40
8280: PUSH
8281: LD_INT 1
8283: PLUS
8284: ST_TO_ADDR
// attacking := true ;
8285: LD_ADDR_EXP 39
8289: PUSH
8290: LD_INT 1
8292: ST_TO_ADDR
// l := lonely ;
8293: LD_ADDR_VAR 0 2
8297: PUSH
8298: CALL 8206 0 0
8302: ST_TO_ADDR
// case true of l :
8303: LD_INT 1
8305: PUSH
8306: LD_VAR 0 2
8310: DOUBLE
8311: EQUAL
8312: IFTRUE 8316
8314: GO 8328
8316: POP
// F_lonely_attack ( l ) ; free_cars and rand ( 1 , 3 ) = 1 :
8317: LD_VAR 0 2
8321: PPUSH
8322: CALL 11307 0 1
8326: GO 8399
8328: CALL 8132 0 0
8332: PUSH
8333: LD_INT 1
8335: PPUSH
8336: LD_INT 3
8338: PPUSH
8339: CALL_OW 12
8343: PUSH
8344: LD_INT 1
8346: EQUAL
8347: AND
8348: DOUBLE
8349: EQUAL
8350: IFTRUE 8354
8352: GO 8361
8354: POP
// F_thief_attack ; budovy and rand ( 1 , 2 ) = 1 :
8355: CALL 10563 0 0
8359: GO 8399
8361: LD_EXP 64
8365: PUSH
8366: LD_INT 1
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: PUSH
8377: LD_INT 1
8379: EQUAL
8380: AND
8381: DOUBLE
8382: EQUAL
8383: IFTRUE 8387
8385: GO 8394
8387: POP
// F_mine_attack ; else
8388: CALL 9827 0 0
8392: GO 8399
8394: POP
// F_next_attack ; end ;
8395: CALL 11660 0 0
// if attacky < utoku then
8399: LD_EXP 40
8403: PUSH
8404: LD_EXP 61
8408: LESS
8409: IFFALSE 8412
// enable ;
8411: ENABLE
// oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8412: LD_ADDR_EXP 8
8416: PUSH
8417: LD_INT 22
8419: PUSH
8420: LD_EXP 4
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PUSH
8429: LD_INT 21
8431: PUSH
8432: LD_INT 1
8434: PUSH
8435: EMPTY
8436: LIST
8437: LIST
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PPUSH
8443: CALL_OW 69
8447: ST_TO_ADDR
// end ;
8448: LD_VAR 0 1
8452: RET
// every 0 0$1.0 do var i , a ;
8453: GO 8455
8455: DISABLE
8456: LD_INT 0
8458: PPUSH
8459: PPUSH
// begin oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8460: LD_ADDR_EXP 8
8464: PUSH
8465: LD_INT 22
8467: PUSH
8468: LD_EXP 4
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 21
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 69
8495: ST_TO_ADDR
// if oma then
8496: LD_EXP 8
8500: IFFALSE 8809
// begin a := oma [ rand ( 1 , oma ) ] ;
8502: LD_ADDR_VAR 0 2
8506: PUSH
8507: LD_EXP 8
8511: PUSH
8512: LD_INT 1
8514: PPUSH
8515: LD_EXP 8
8519: PPUSH
8520: CALL_OW 12
8524: ARRAY
8525: ST_TO_ADDR
// if ( tick - last_attack_was ) > 5 5$0 then
8526: LD_OWVAR 1
8530: PUSH
8531: LD_EXP 65
8535: MINUS
8536: PUSH
8537: LD_INT 10500
8539: GREATER
8540: IFFALSE 8592
// ComAttackUnit ( oma , NearestUnitToUnit ( FilterAllUnits ( [ f_side , you ] ) , oma [ Rand ( 1 , oma ) ] ) ) ;
8542: LD_EXP 8
8546: PPUSH
8547: LD_INT 22
8549: PUSH
8550: LD_EXP 1
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PPUSH
8559: CALL_OW 69
8563: PPUSH
8564: LD_EXP 8
8568: PUSH
8569: LD_INT 1
8571: PPUSH
8572: LD_EXP 8
8576: PPUSH
8577: CALL_OW 12
8581: ARRAY
8582: PPUSH
8583: CALL_OW 74
8587: PPUSH
8588: CALL_OW 115
// if ( tick - last_attack_was ) > 7 7$0 then
8592: LD_OWVAR 1
8596: PUSH
8597: LD_EXP 65
8601: MINUS
8602: PUSH
8603: LD_INT 14700
8605: GREATER
8606: IFFALSE 8643
// evade_shortest_way_from_xy ( getx ( a ) , gety ( a ) , oma , true , true ) ;
8608: LD_VAR 0 2
8612: PPUSH
8613: CALL_OW 250
8617: PPUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: CALL_OW 251
8627: PPUSH
8628: LD_EXP 8
8632: PPUSH
8633: LD_INT 1
8635: PPUSH
8636: LD_INT 1
8638: PPUSH
8639: CALL 12909 0 5
// for i in oma do
8643: LD_ADDR_VAR 0 1
8647: PUSH
8648: LD_EXP 8
8652: PUSH
8653: FOR_IN
8654: IFFALSE 8807
// begin if IsIdle ( i ) and IsInArea ( i , border ) then
8656: LD_VAR 0 1
8660: PPUSH
8661: CALL_OW 316
8665: PUSH
8666: LD_VAR 0 1
8670: PPUSH
8671: LD_INT 7
8673: PPUSH
8674: CALL_OW 308
8678: AND
8679: IFFALSE 8805
// begin if IsInUnit ( i ) then
8681: LD_VAR 0 1
8685: PPUSH
8686: CALL_OW 310
8690: IFFALSE 8735
// arabs_cars := arabs_cars union UnitFilter ( IsInUnit ( i ) , [ f_not , [ f_weapon , us_cargo_bay ] ] ) ;
8692: LD_ADDR_EXP 10
8696: PUSH
8697: LD_EXP 10
8701: PUSH
8702: LD_VAR 0 1
8706: PPUSH
8707: CALL_OW 310
8711: PPUSH
8712: LD_INT 3
8714: PUSH
8715: LD_INT 34
8717: PUSH
8718: LD_INT 12
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PPUSH
8729: CALL_OW 72
8733: UNION
8734: ST_TO_ADDR
// RemoveUnit ( IsInUnit ( i ) ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: CALL_OW 310
8744: PPUSH
8745: CALL_OW 64
// SetLives ( IsInUnit ( i ) , 1000 ) ;
8749: LD_VAR 0 1
8753: PPUSH
8754: CALL_OW 310
8758: PPUSH
8759: LD_INT 1000
8761: PPUSH
8762: CALL_OW 234
// DestroyUnit ( i ) ;
8766: LD_VAR 0 1
8770: PPUSH
8771: CALL_OW 65
// oma := oma diff i ;
8775: LD_ADDR_EXP 8
8779: PUSH
8780: LD_EXP 8
8784: PUSH
8785: LD_VAR 0 1
8789: DIFF
8790: ST_TO_ADDR
// away_from_last_attack := away_from_last_attack + 1 ;
8791: LD_ADDR_EXP 33
8795: PUSH
8796: LD_EXP 33
8800: PUSH
8801: LD_INT 1
8803: PLUS
8804: ST_TO_ADDR
// end ; end ;
8805: GO 8653
8807: POP
8808: POP
// end ; enable ;
8809: ENABLE
// end ;
8810: PPOPN 2
8812: END
// every 0 0$2 trigger attacking do var aro , ar , uso , us , a , i ;
8813: LD_EXP 39
8817: IFFALSE 9079
8819: GO 8821
8821: DISABLE
8822: LD_INT 0
8824: PPUSH
8825: PPUSH
8826: PPUSH
8827: PPUSH
8828: PPUSH
8829: PPUSH
// begin aro := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8830: LD_ADDR_VAR 0 1
8834: PUSH
8835: LD_INT 22
8837: PUSH
8838: LD_EXP 4
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: PPUSH
8847: CALL_OW 69
8851: PPUSH
8852: CALL_OW 256
8856: ST_TO_ADDR
// uso := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8857: LD_ADDR_VAR 0 3
8861: PUSH
8862: LD_INT 22
8864: PUSH
8865: LD_EXP 1
8869: PUSH
8870: EMPTY
8871: LIST
8872: LIST
8873: PPUSH
8874: CALL_OW 69
8878: PPUSH
8879: CALL_OW 256
8883: ST_TO_ADDR
// wait ( 0 0$2 ) ;
8884: LD_INT 70
8886: PPUSH
8887: CALL_OW 67
// while attacking do
8891: LD_EXP 39
8895: IFFALSE 9078
// begin ar := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8897: LD_ADDR_VAR 0 2
8901: PUSH
8902: LD_INT 22
8904: PUSH
8905: LD_EXP 4
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PPUSH
8914: CALL_OW 69
8918: PPUSH
8919: CALL_OW 256
8923: ST_TO_ADDR
// us := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8924: LD_ADDR_VAR 0 4
8928: PUSH
8929: LD_INT 22
8931: PUSH
8932: LD_EXP 1
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: PPUSH
8941: CALL_OW 69
8945: PPUSH
8946: CALL_OW 256
8950: ST_TO_ADDR
// if ( aro - ar ) * 1.2 < uso - us then
8951: LD_VAR 0 1
8955: PUSH
8956: LD_VAR 0 2
8960: MINUS
8961: PUSH
8962: LD_REAL  1.20000000000000E+0000
8965: MUL
8966: PUSH
8967: LD_VAR 0 3
8971: PUSH
8972: LD_VAR 0 4
8976: MINUS
8977: LESS
8978: IFFALSE 9049
// begin a := FilterAllUnits ( [ f_side , arabians ] ) ;
8980: LD_ADDR_VAR 0 5
8984: PUSH
8985: LD_INT 22
8987: PUSH
8988: LD_EXP 4
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: PPUSH
8997: CALL_OW 69
9001: ST_TO_ADDR
// for i in a do
9002: LD_ADDR_VAR 0 6
9006: PUSH
9007: LD_VAR 0 5
9011: PUSH
9012: FOR_IN
9013: IFFALSE 9047
// if GetLives ( i ) < 400 then
9015: LD_VAR 0 6
9019: PPUSH
9020: CALL_OW 256
9024: PUSH
9025: LD_INT 400
9027: LESS
9028: IFFALSE 9045
// evade_shortest_way ( i , false , true ) ;
9030: LD_VAR 0 6
9034: PPUSH
9035: LD_INT 0
9037: PPUSH
9038: LD_INT 1
9040: PPUSH
9041: CALL 12822 0 3
9045: GO 9012
9047: POP
9048: POP
// end ; wait ( 0 0$0.5 ) ;
9049: LD_INT 18
9051: PPUSH
9052: CALL_OW 67
// aro := ar ;
9056: LD_ADDR_VAR 0 1
9060: PUSH
9061: LD_VAR 0 2
9065: ST_TO_ADDR
// uso := us ;
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: LD_VAR 0 4
9075: ST_TO_ADDR
// end ;
9076: GO 8891
// enable ;
9078: ENABLE
// end ;
9079: PPOPN 6
9081: END
// every 0 0$1.0 trigger not oma do
9082: LD_EXP 8
9086: NOT
9087: IFFALSE 9141
9089: GO 9091
9091: DISABLE
// begin attacking := false ;
9092: LD_ADDR_EXP 39
9096: PUSH
9097: LD_INT 0
9099: ST_TO_ADDR
// first_attack := false ;
9100: LD_ADDR_EXP 34
9104: PUSH
9105: LD_INT 0
9107: ST_TO_ADDR
// mine_attack := false ;
9108: LD_ADDR_EXP 35
9112: PUSH
9113: LD_INT 0
9115: ST_TO_ADDR
// thief_attack := false ;
9116: LD_ADDR_EXP 36
9120: PUSH
9121: LD_INT 0
9123: ST_TO_ADDR
// lonely_attack := false ;
9124: LD_ADDR_EXP 37
9128: PUSH
9129: LD_INT 0
9131: ST_TO_ADDR
// next_attack := false ;
9132: LD_ADDR_EXP 38
9136: PUSH
9137: LD_INT 0
9139: ST_TO_ADDR
// enable ;
9140: ENABLE
// end ;
9141: END
// every 0 0$1 do var a ;
9142: GO 9144
9144: DISABLE
9145: LD_INT 0
9147: PPUSH
// begin a :=  ;
9148: LD_ADDR_VAR 0 1
9152: PUSH
9153: LD_STRING 
9155: ST_TO_ADDR
// if attacking then
9156: LD_EXP 39
9160: IFFALSE 9176
// a := a &  attacking ;
9162: LD_ADDR_VAR 0 1
9166: PUSH
9167: LD_VAR 0 1
9171: PUSH
9172: LD_STRING  attacking
9174: STR
9175: ST_TO_ADDR
// if first_attack then
9176: LD_EXP 34
9180: IFFALSE 9196
// a := a &  first ;
9182: LD_ADDR_VAR 0 1
9186: PUSH
9187: LD_VAR 0 1
9191: PUSH
9192: LD_STRING  first
9194: STR
9195: ST_TO_ADDR
// if mine_attack then
9196: LD_EXP 35
9200: IFFALSE 9216
// a := a &  mine ;
9202: LD_ADDR_VAR 0 1
9206: PUSH
9207: LD_VAR 0 1
9211: PUSH
9212: LD_STRING  mine
9214: STR
9215: ST_TO_ADDR
// if thief_attack then
9216: LD_EXP 36
9220: IFFALSE 9236
// a := a &  thief ;
9222: LD_ADDR_VAR 0 1
9226: PUSH
9227: LD_VAR 0 1
9231: PUSH
9232: LD_STRING  thief
9234: STR
9235: ST_TO_ADDR
// if lonely_attack then
9236: LD_EXP 37
9240: IFFALSE 9256
// a := a &  lonely ;
9242: LD_ADDR_VAR 0 1
9246: PUSH
9247: LD_VAR 0 1
9251: PUSH
9252: LD_STRING  lonely
9254: STR
9255: ST_TO_ADDR
// if next_attack then
9256: LD_EXP 38
9260: IFFALSE 9276
// a := a &  next ;
9262: LD_ADDR_VAR 0 1
9266: PUSH
9267: LD_VAR 0 1
9271: PUSH
9272: LD_STRING  next
9274: STR
9275: ST_TO_ADDR
// debug_strings := [ a ] ;
9276: LD_ADDR_OWVAR 48
9280: PUSH
9281: LD_VAR 0 1
9285: PUSH
9286: EMPTY
9287: LIST
9288: ST_TO_ADDR
// enable ;
9289: ENABLE
// end ;
9290: PPOPN 1
9292: END
// function F_first_attack ; var i , r , amici , x , y , units , a , b ; begin
9293: LD_INT 0
9295: PPUSH
9296: PPUSH
9297: PPUSH
9298: PPUSH
9299: PPUSH
9300: PPUSH
9301: PPUSH
9302: PPUSH
9303: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9304: LD_ADDR_VAR 0 3
9308: PUSH
9309: LD_INT 1
9311: PPUSH
9312: LD_EXP 28
9316: PPUSH
9317: CALL_OW 12
9321: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9322: LD_ADDR_VAR 0 5
9326: PUSH
9327: LD_EXP 28
9331: PUSH
9332: LD_VAR 0 3
9336: ARRAY
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9342: LD_ADDR_VAR 0 6
9346: PUSH
9347: LD_EXP 28
9351: PUSH
9352: LD_VAR 0 3
9356: ARRAY
9357: PUSH
9358: LD_INT 2
9360: ARRAY
9361: ST_TO_ADDR
// units := 2 ;
9362: LD_ADDR_VAR 0 7
9366: PUSH
9367: LD_INT 2
9369: ST_TO_ADDR
// a := make_arabs ( units , class_soldier ) ;
9370: LD_ADDR_VAR 0 8
9374: PUSH
9375: LD_VAR 0 7
9379: PPUSH
9380: LD_INT 1
9382: PPUSH
9383: CALL 1106 0 2
9387: ST_TO_ADDR
// for i in a do
9388: LD_ADDR_VAR 0 2
9392: PUSH
9393: LD_VAR 0 8
9397: PUSH
9398: FOR_IN
9399: IFFALSE 9428
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 5
9410: PPUSH
9411: LD_VAR 0 6
9415: PPUSH
9416: LD_INT 5
9418: PPUSH
9419: LD_INT 0
9421: PPUSH
9422: CALL_OW 50
9426: GO 9398
9428: POP
9429: POP
// r := Rand ( 1 , CameFromXY ) ;
9430: LD_ADDR_VAR 0 3
9434: PUSH
9435: LD_INT 1
9437: PPUSH
9438: LD_EXP 28
9442: PPUSH
9443: CALL_OW 12
9447: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9448: LD_ADDR_VAR 0 5
9452: PUSH
9453: LD_EXP 28
9457: PUSH
9458: LD_VAR 0 3
9462: ARRAY
9463: PUSH
9464: LD_INT 1
9466: ARRAY
9467: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9468: LD_ADDR_VAR 0 6
9472: PUSH
9473: LD_EXP 28
9477: PUSH
9478: LD_VAR 0 3
9482: ARRAY
9483: PUSH
9484: LD_INT 2
9486: ARRAY
9487: ST_TO_ADDR
// units := difficulty + 1 ;
9488: LD_ADDR_VAR 0 7
9492: PUSH
9493: LD_OWVAR 67
9497: PUSH
9498: LD_INT 1
9500: PLUS
9501: ST_TO_ADDR
// b := make_arabs ( units , class_soldier ) ;
9502: LD_ADDR_VAR 0 9
9506: PUSH
9507: LD_VAR 0 7
9511: PPUSH
9512: LD_INT 1
9514: PPUSH
9515: CALL 1106 0 2
9519: ST_TO_ADDR
// for i in b do
9520: LD_ADDR_VAR 0 2
9524: PUSH
9525: LD_VAR 0 9
9529: PUSH
9530: FOR_IN
9531: IFFALSE 9560
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9533: LD_VAR 0 2
9537: PPUSH
9538: LD_VAR 0 5
9542: PPUSH
9543: LD_VAR 0 6
9547: PPUSH
9548: LD_INT 5
9550: PPUSH
9551: LD_INT 0
9553: PPUSH
9554: CALL_OW 50
9558: GO 9530
9560: POP
9561: POP
// amici_b := budovy ;
9562: LD_ADDR_LOC 7
9566: PUSH
9567: LD_EXP 64
9571: ST_TO_ADDR
// amici_h := FilterAllUnits ( [ f_side , you ] ) ;
9572: LD_ADDR_LOC 6
9576: PUSH
9577: LD_INT 22
9579: PUSH
9580: LD_EXP 1
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PPUSH
9589: CALL_OW 69
9593: ST_TO_ADDR
// away_from_last_attack := 0 ;
9594: LD_ADDR_EXP 33
9598: PUSH
9599: LD_INT 0
9601: ST_TO_ADDR
// make_mess := a ^ b ;
9602: LD_ADDR_LOC 9
9606: PUSH
9607: LD_VAR 0 8
9611: PUSH
9612: LD_VAR 0 9
9616: ADD
9617: ST_TO_ADDR
// if amici_b then
9618: LD_LOC 7
9622: IFFALSE 9663
// ComAgressiveMove ( make_mess , GetX ( amici_b [ 1 ] ) , GetY ( amici_b [ 1 ] ) ) else
9624: LD_LOC 9
9628: PPUSH
9629: LD_LOC 7
9633: PUSH
9634: LD_INT 1
9636: ARRAY
9637: PPUSH
9638: CALL_OW 250
9642: PPUSH
9643: LD_LOC 7
9647: PUSH
9648: LD_INT 1
9650: ARRAY
9651: PPUSH
9652: CALL_OW 251
9656: PPUSH
9657: CALL_OW 114
9661: GO 9700
// ComAgressiveMove ( make_mess , GetX ( amici_h [ 1 ] ) , GetY ( amici_h [ 1 ] ) ) ;
9663: LD_LOC 9
9667: PPUSH
9668: LD_LOC 6
9672: PUSH
9673: LD_INT 1
9675: ARRAY
9676: PPUSH
9677: CALL_OW 250
9681: PPUSH
9682: LD_LOC 6
9686: PUSH
9687: LD_INT 1
9689: ARRAY
9690: PPUSH
9691: CALL_OW 251
9695: PPUSH
9696: CALL_OW 114
// was_first_attack := true ;
9700: LD_ADDR_EXP 32
9704: PUSH
9705: LD_INT 1
9707: ST_TO_ADDR
// first_attack := true ;
9708: LD_ADDR_EXP 34
9712: PUSH
9713: LD_INT 1
9715: ST_TO_ADDR
// while see_any ( you , make_mess ) do
9716: LD_EXP 1
9720: PPUSH
9721: LD_LOC 9
9725: PPUSH
9726: CALL 13858 0 2
9730: IFFALSE 9741
// wait ( 0 0$0.5 ) ;
9732: LD_INT 18
9734: PPUSH
9735: CALL_OW 67
9739: GO 9716
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
9741: LD_ADDR_VAR 0 4
9745: PUSH
9746: LD_INT 22
9748: PUSH
9749: LD_EXP 1
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PUSH
9758: LD_INT 101
9760: PUSH
9761: LD_EXP 4
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PPUSH
9774: CALL_OW 69
9778: ST_TO_ADDR
// if amici then
9779: LD_VAR 0 4
9783: IFFALSE 9822
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
9785: LD_LOC 9
9789: PPUSH
9790: LD_VAR 0 4
9794: PUSH
9795: LD_INT 1
9797: ARRAY
9798: PPUSH
9799: CALL_OW 250
9803: PPUSH
9804: LD_VAR 0 4
9808: PUSH
9809: LD_INT 1
9811: ARRAY
9812: PPUSH
9813: CALL_OW 251
9817: PPUSH
9818: CALL_OW 114
// end ; end ;
9822: LD_VAR 0 1
9826: RET
// var set_charge , make_mess ; function F_mine_attack ; var i , r , amici , x , y , units , w_b , amici_b ; begin
9827: LD_INT 0
9829: PPUSH
9830: PPUSH
9831: PPUSH
9832: PPUSH
9833: PPUSH
9834: PPUSH
9835: PPUSH
9836: PPUSH
9837: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9838: LD_ADDR_VAR 0 3
9842: PUSH
9843: LD_INT 1
9845: PPUSH
9846: LD_EXP 28
9850: PPUSH
9851: CALL_OW 12
9855: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9856: LD_ADDR_VAR 0 5
9860: PUSH
9861: LD_EXP 28
9865: PUSH
9866: LD_VAR 0 3
9870: ARRAY
9871: PUSH
9872: LD_INT 1
9874: ARRAY
9875: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9876: LD_ADDR_VAR 0 6
9880: PUSH
9881: LD_EXP 28
9885: PUSH
9886: LD_VAR 0 3
9890: ARRAY
9891: PUSH
9892: LD_INT 2
9894: ARRAY
9895: ST_TO_ADDR
// units := difficulty * 2 ;
9896: LD_ADDR_VAR 0 7
9900: PUSH
9901: LD_OWVAR 67
9905: PUSH
9906: LD_INT 2
9908: MUL
9909: ST_TO_ADDR
// amici_b := budovy ;
9910: LD_ADDR_VAR 0 9
9914: PUSH
9915: LD_EXP 64
9919: ST_TO_ADDR
// w_b := Rand ( 1 , ( amici_b + 0 ) ) ;
9920: LD_ADDR_VAR 0 8
9924: PUSH
9925: LD_INT 1
9927: PPUSH
9928: LD_VAR 0 9
9932: PUSH
9933: LD_INT 0
9935: PLUS
9936: PPUSH
9937: CALL_OW 12
9941: ST_TO_ADDR
// if amici_b then
9942: LD_VAR 0 9
9946: IFFALSE 10558
// begin make_mess := make_arabs ( units , class_soldier ) ;
9948: LD_ADDR_LOC 9
9952: PUSH
9953: LD_VAR 0 7
9957: PPUSH
9958: LD_INT 1
9960: PPUSH
9961: CALL 1106 0 2
9965: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
9966: LD_ADDR_VAR 0 7
9970: PUSH
9971: LD_LOC 9
9975: PUSH
9976: LD_INT 0
9978: PLUS
9979: ST_TO_ADDR
// for i in make_mess do
9980: LD_ADDR_VAR 0 2
9984: PUSH
9985: LD_LOC 9
9989: PUSH
9990: FOR_IN
9991: IFFALSE 10020
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9993: LD_VAR 0 2
9997: PPUSH
9998: LD_VAR 0 5
10002: PPUSH
10003: LD_VAR 0 6
10007: PPUSH
10008: LD_INT 5
10010: PPUSH
10011: LD_INT 0
10013: PPUSH
10014: CALL_OW 50
10018: GO 9990
10020: POP
10021: POP
// away_from_last_attack := 0 ;
10022: LD_ADDR_EXP 33
10026: PUSH
10027: LD_INT 0
10029: ST_TO_ADDR
// set_charge := get_live_from_list ( make_mess , 0 , difficulty ) ;
10030: LD_ADDR_LOC 8
10034: PUSH
10035: LD_LOC 9
10039: PPUSH
10040: LD_INT 0
10042: PPUSH
10043: LD_OWVAR 67
10047: PPUSH
10048: CALL 13652 0 3
10052: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , difficulty , units - difficulty ) ;
10053: LD_ADDR_LOC 9
10057: PUSH
10058: LD_LOC 9
10062: PPUSH
10063: LD_OWVAR 67
10067: PPUSH
10068: LD_VAR 0 7
10072: PUSH
10073: LD_OWVAR 67
10077: MINUS
10078: PPUSH
10079: CALL 13652 0 3
10083: ST_TO_ADDR
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10084: LD_LOC 9
10088: PPUSH
10089: LD_VAR 0 9
10093: PUSH
10094: LD_VAR 0 8
10098: ARRAY
10099: PPUSH
10100: CALL_OW 250
10104: PPUSH
10105: LD_VAR 0 9
10109: PUSH
10110: LD_VAR 0 8
10114: ARRAY
10115: PPUSH
10116: CALL_OW 251
10120: PPUSH
10121: CALL_OW 114
// find_easiest_way ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , 7 , 3 , set_charge , you , false ) ;
10125: LD_VAR 0 9
10129: PUSH
10130: LD_VAR 0 8
10134: ARRAY
10135: PPUSH
10136: CALL_OW 250
10140: PPUSH
10141: LD_VAR 0 9
10145: PUSH
10146: LD_VAR 0 8
10150: ARRAY
10151: PPUSH
10152: CALL_OW 251
10156: PPUSH
10157: LD_INT 7
10159: PPUSH
10160: LD_INT 3
10162: PPUSH
10163: LD_LOC 8
10167: PPUSH
10168: LD_EXP 1
10172: PPUSH
10173: LD_INT 0
10175: PPUSH
10176: CALL 12280 0 7
// AddComPlaceDelayedCharge ( set_charge , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , amici_b [ w_b ] ) ;
10180: LD_LOC 8
10184: PPUSH
10185: LD_VAR 0 9
10189: PUSH
10190: LD_VAR 0 8
10194: ARRAY
10195: PPUSH
10196: CALL_OW 250
10200: PPUSH
10201: LD_VAR 0 9
10205: PUSH
10206: LD_VAR 0 8
10210: ARRAY
10211: PPUSH
10212: CALL_OW 251
10216: PPUSH
10217: LD_VAR 0 9
10221: PUSH
10222: LD_VAR 0 8
10226: ARRAY
10227: PPUSH
10228: CALL_OW 192
// evade_shortest_way_from_xy ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , set_charge , true , true ) ;
10232: LD_VAR 0 9
10236: PUSH
10237: LD_VAR 0 8
10241: ARRAY
10242: PPUSH
10243: CALL_OW 250
10247: PPUSH
10248: LD_VAR 0 9
10252: PUSH
10253: LD_VAR 0 8
10257: ARRAY
10258: PPUSH
10259: CALL_OW 251
10263: PPUSH
10264: LD_LOC 8
10268: PPUSH
10269: LD_INT 1
10271: PPUSH
10272: LD_INT 1
10274: PPUSH
10275: CALL 12909 0 5
// mine_attack := true ;
10279: LD_ADDR_EXP 35
10283: PUSH
10284: LD_INT 1
10286: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
10287: LD_EXP 1
10291: PPUSH
10292: LD_LOC 9
10296: PPUSH
10297: CALL 13858 0 2
10301: NOT
10302: IFFALSE 10313
// wait ( 0 0$0.5 ) ;
10304: LD_INT 18
10306: PPUSH
10307: CALL_OW 67
10311: GO 10287
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
10313: LD_ADDR_VAR 0 4
10317: PUSH
10318: LD_INT 22
10320: PUSH
10321: LD_EXP 1
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: PUSH
10330: LD_INT 101
10332: PUSH
10333: LD_EXP 4
10337: PUSH
10338: EMPTY
10339: LIST
10340: LIST
10341: PUSH
10342: LD_INT 21
10344: PUSH
10345: LD_INT 1
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: LIST
10356: PPUSH
10357: CALL_OW 69
10361: ST_TO_ADDR
// if amici then
10362: LD_VAR 0 4
10366: IFFALSE 10485
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
10368: LD_LOC 9
10372: PPUSH
10373: LD_VAR 0 4
10377: PUSH
10378: LD_INT 1
10380: ARRAY
10381: PPUSH
10382: CALL_OW 250
10386: PPUSH
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: CALL_OW 251
10400: PPUSH
10401: CALL_OW 114
// for i := 1 to amici do
10405: LD_ADDR_VAR 0 2
10409: PUSH
10410: DOUBLE
10411: LD_INT 1
10413: DEC
10414: ST_TO_ADDR
10415: LD_VAR 0 4
10419: PUSH
10420: FOR_TO
10421: IFFALSE 10466
// begin AddComAgressiveMove ( make_mess , GetX ( amici [ i ] ) , GetY ( amici [ i ] ) ) ;
10423: LD_LOC 9
10427: PPUSH
10428: LD_VAR 0 4
10432: PUSH
10433: LD_VAR 0 2
10437: ARRAY
10438: PPUSH
10439: CALL_OW 250
10443: PPUSH
10444: LD_VAR 0 4
10448: PUSH
10449: LD_VAR 0 2
10453: ARRAY
10454: PPUSH
10455: CALL_OW 251
10459: PPUSH
10460: CALL_OW 174
// end ;
10464: GO 10420
10466: POP
10467: POP
// evade_shortest_way ( make_mess , true , true ) ;
10468: LD_LOC 9
10472: PPUSH
10473: LD_INT 1
10475: PPUSH
10476: LD_INT 1
10478: PPUSH
10479: CALL 12822 0 3
// end else
10483: GO 10558
// begin if IsOk ( amici_b [ w_b ] ) then
10485: LD_VAR 0 9
10489: PUSH
10490: LD_VAR 0 8
10494: ARRAY
10495: PPUSH
10496: CALL_OW 302
10500: IFFALSE 10543
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10502: LD_LOC 9
10506: PPUSH
10507: LD_VAR 0 9
10511: PUSH
10512: LD_VAR 0 8
10516: ARRAY
10517: PPUSH
10518: CALL_OW 250
10522: PPUSH
10523: LD_VAR 0 9
10527: PUSH
10528: LD_VAR 0 8
10532: ARRAY
10533: PPUSH
10534: CALL_OW 251
10538: PPUSH
10539: CALL_OW 114
// evade_shortest_way ( make_mess , true , true ) ;
10543: LD_LOC 9
10547: PPUSH
10548: LD_INT 1
10550: PPUSH
10551: LD_INT 1
10553: PPUSH
10554: CALL 12822 0 3
// end ; end ; end ;
10558: LD_VAR 0 1
10562: RET
// var capcar1 , capcar2 ; var steal_car ; function F_thief_attack ; var i , r , x , y , units , amici3 ; begin
10563: LD_INT 0
10565: PPUSH
10566: PPUSH
10567: PPUSH
10568: PPUSH
10569: PPUSH
10570: PPUSH
10571: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
10572: LD_ADDR_VAR 0 3
10576: PUSH
10577: LD_INT 1
10579: PPUSH
10580: LD_EXP 28
10584: PPUSH
10585: CALL_OW 12
10589: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
10590: LD_ADDR_VAR 0 4
10594: PUSH
10595: LD_EXP 28
10599: PUSH
10600: LD_VAR 0 3
10604: ARRAY
10605: PUSH
10606: LD_INT 1
10608: ARRAY
10609: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
10610: LD_ADDR_VAR 0 5
10614: PUSH
10615: LD_EXP 28
10619: PUSH
10620: LD_VAR 0 3
10624: ARRAY
10625: PUSH
10626: LD_INT 2
10628: ARRAY
10629: ST_TO_ADDR
// units := 3 + difficulty + attacky div 7 + away_from_last_attack div 4 ;
10630: LD_ADDR_VAR 0 6
10634: PUSH
10635: LD_INT 3
10637: PUSH
10638: LD_OWVAR 67
10642: PLUS
10643: PUSH
10644: LD_EXP 40
10648: PUSH
10649: LD_INT 7
10651: DIV
10652: PLUS
10653: PUSH
10654: LD_EXP 33
10658: PUSH
10659: LD_INT 4
10661: DIV
10662: PLUS
10663: ST_TO_ADDR
// amici_v := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10664: LD_ADDR_LOC 5
10668: PUSH
10669: LD_INT 21
10671: PUSH
10672: LD_INT 2
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PUSH
10679: LD_INT 22
10681: PUSH
10682: LD_EXP 1
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PPUSH
10695: CALL_OW 69
10699: ST_TO_ADDR
// if amici_v then
10700: LD_LOC 5
10704: IFFALSE 11302
// begin make_mess := make_arabs ( units , class_soldier ) ;
10706: LD_ADDR_LOC 9
10710: PUSH
10711: LD_VAR 0 6
10715: PPUSH
10716: LD_INT 1
10718: PPUSH
10719: CALL 1106 0 2
10723: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
10724: LD_ADDR_VAR 0 6
10728: PUSH
10729: LD_LOC 9
10733: PUSH
10734: LD_INT 0
10736: PLUS
10737: ST_TO_ADDR
// for i in make_mess do
10738: LD_ADDR_VAR 0 2
10742: PUSH
10743: LD_LOC 9
10747: PUSH
10748: FOR_IN
10749: IFFALSE 10778
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 4
10760: PPUSH
10761: LD_VAR 0 5
10765: PPUSH
10766: LD_INT 5
10768: PPUSH
10769: LD_INT 0
10771: PPUSH
10772: CALL_OW 50
10776: GO 10748
10778: POP
10779: POP
// away_from_last_attack := 0 ;
10780: LD_ADDR_EXP 33
10784: PUSH
10785: LD_INT 0
10787: ST_TO_ADDR
// if difficulty > 1 then
10788: LD_OWVAR 67
10792: PUSH
10793: LD_INT 1
10795: GREATER
10796: IFFALSE 10848
// begin steal_car := get_live_from_list ( make_mess , 0 , 2 ) ;
10798: LD_ADDR_LOC 12
10802: PUSH
10803: LD_LOC 9
10807: PPUSH
10808: LD_INT 0
10810: PPUSH
10811: LD_INT 2
10813: PPUSH
10814: CALL 13652 0 3
10818: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 2 , units - 2 ) ;
10819: LD_ADDR_LOC 9
10823: PUSH
10824: LD_LOC 9
10828: PPUSH
10829: LD_INT 2
10831: PPUSH
10832: LD_VAR 0 6
10836: PUSH
10837: LD_INT 2
10839: MINUS
10840: PPUSH
10841: CALL 13652 0 3
10845: ST_TO_ADDR
// end else
10846: GO 10896
// begin steal_car := get_live_from_list ( make_mess , 0 , 1 ) ;
10848: LD_ADDR_LOC 12
10852: PUSH
10853: LD_LOC 9
10857: PPUSH
10858: LD_INT 0
10860: PPUSH
10861: LD_INT 1
10863: PPUSH
10864: CALL 13652 0 3
10868: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 1 , units - 1 ) ;
10869: LD_ADDR_LOC 9
10873: PUSH
10874: LD_LOC 9
10878: PPUSH
10879: LD_INT 1
10881: PPUSH
10882: LD_VAR 0 6
10886: PUSH
10887: LD_INT 1
10889: MINUS
10890: PPUSH
10891: CALL 13652 0 3
10895: ST_TO_ADDR
// end ; ComAgressiveMove ( make_mess , GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) ) ;
10896: LD_LOC 9
10900: PPUSH
10901: LD_LOC 5
10905: PUSH
10906: LD_INT 1
10908: ARRAY
10909: PPUSH
10910: CALL_OW 250
10914: PPUSH
10915: LD_LOC 5
10919: PUSH
10920: LD_INT 1
10922: ARRAY
10923: PPUSH
10924: CALL_OW 251
10928: PPUSH
10929: CALL_OW 114
// find_easiest_way ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , 7 , 3 , steal_car , you , false ) ;
10933: LD_LOC 5
10937: PUSH
10938: LD_INT 1
10940: ARRAY
10941: PPUSH
10942: CALL_OW 250
10946: PPUSH
10947: LD_LOC 5
10951: PUSH
10952: LD_INT 1
10954: ARRAY
10955: PPUSH
10956: CALL_OW 251
10960: PPUSH
10961: LD_INT 7
10963: PPUSH
10964: LD_INT 3
10966: PPUSH
10967: LD_LOC 12
10971: PPUSH
10972: LD_EXP 1
10976: PPUSH
10977: LD_INT 0
10979: PPUSH
10980: CALL 12280 0 7
// com_queue := true ;
10984: LD_ADDR_OWVAR 49
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// AddComEnterUnit ( steal_car , amici_v [ 1 ] ) ;
10992: LD_LOC 12
10996: PPUSH
10997: LD_LOC 5
11001: PUSH
11002: LD_INT 1
11004: ARRAY
11005: PPUSH
11006: CALL_OW 180
// com_queue := false ;
11010: LD_ADDR_OWVAR 49
11014: PUSH
11015: LD_INT 0
11017: ST_TO_ADDR
// evade_shortest_way_from_xy ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , steal_car , true , true ) ;
11018: LD_LOC 5
11022: PUSH
11023: LD_INT 1
11025: ARRAY
11026: PPUSH
11027: CALL_OW 250
11031: PPUSH
11032: LD_LOC 5
11036: PUSH
11037: LD_INT 1
11039: ARRAY
11040: PPUSH
11041: CALL_OW 251
11045: PPUSH
11046: LD_LOC 12
11050: PPUSH
11051: LD_INT 1
11053: PPUSH
11054: LD_INT 1
11056: PPUSH
11057: CALL 12909 0 5
// thief_attack := true ;
11061: LD_ADDR_EXP 36
11065: PUSH
11066: LD_INT 1
11068: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
11069: LD_EXP 1
11073: PPUSH
11074: LD_LOC 9
11078: PPUSH
11079: CALL 13858 0 2
11083: NOT
11084: IFFALSE 11095
// wait ( 0 0$0.5 ) ;
11086: LD_INT 18
11088: PPUSH
11089: CALL_OW 67
11093: GO 11069
// amici_b := FilterAllUnits ( [ f_type , unit_building ] ) ;
11095: LD_ADDR_LOC 7
11099: PUSH
11100: LD_INT 21
11102: PUSH
11103: LD_INT 3
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: ST_TO_ADDR
// amici3 := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
11115: LD_ADDR_VAR 0 7
11119: PUSH
11120: LD_INT 22
11122: PUSH
11123: LD_EXP 1
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PUSH
11132: LD_INT 101
11134: PUSH
11135: LD_EXP 4
11139: PUSH
11140: EMPTY
11141: LIST
11142: LIST
11143: PUSH
11144: LD_INT 21
11146: PUSH
11147: LD_INT 1
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: LIST
11158: PPUSH
11159: CALL_OW 69
11163: ST_TO_ADDR
// if amici3 then
11164: LD_VAR 0 7
11168: IFFALSE 11263
// begin ComAttackUnit ( make_mess , amici3 [ 1 ] ) ;
11170: LD_LOC 9
11174: PPUSH
11175: LD_VAR 0 7
11179: PUSH
11180: LD_INT 1
11182: ARRAY
11183: PPUSH
11184: CALL_OW 115
// for i := 2 to amici3 do
11188: LD_ADDR_VAR 0 2
11192: PUSH
11193: DOUBLE
11194: LD_INT 2
11196: DEC
11197: ST_TO_ADDR
11198: LD_VAR 0 7
11202: PUSH
11203: FOR_TO
11204: IFFALSE 11244
// begin com_queue := true ;
11206: LD_ADDR_OWVAR 49
11210: PUSH
11211: LD_INT 1
11213: ST_TO_ADDR
// ComAttackUnit ( make_mess , amici3 [ i ] ) ;
11214: LD_LOC 9
11218: PPUSH
11219: LD_VAR 0 7
11223: PUSH
11224: LD_VAR 0 2
11228: ARRAY
11229: PPUSH
11230: CALL_OW 115
// com_queue := false ;
11234: LD_ADDR_OWVAR 49
11238: PUSH
11239: LD_INT 0
11241: ST_TO_ADDR
// end ;
11242: GO 11203
11244: POP
11245: POP
// evade_shortest_way ( make_mess , true , true ) ;
11246: LD_LOC 9
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: LD_INT 1
11256: PPUSH
11257: CALL 12822 0 3
// end else
11261: GO 11302
// begin if amici_b then
11263: LD_LOC 7
11267: IFFALSE 11287
// ComAttackUnit ( make_mess , amici_b [ 1 ] ) ;
11269: LD_LOC 9
11273: PPUSH
11274: LD_LOC 7
11278: PUSH
11279: LD_INT 1
11281: ARRAY
11282: PPUSH
11283: CALL_OW 115
// evade_shortest_way ( make_mess , true , true ) ;
11287: LD_LOC 9
11291: PPUSH
11292: LD_INT 1
11294: PPUSH
11295: LD_INT 1
11297: PPUSH
11298: CALL 12822 0 3
// end ; end ; end ;
11302: LD_VAR 0 1
11306: RET
// function F_lonely_attack ( daleko ) ; var i , r , x , y , units ; begin
11307: LD_INT 0
11309: PPUSH
11310: PPUSH
11311: PPUSH
11312: PPUSH
11313: PPUSH
11314: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11315: LD_ADDR_VAR 0 4
11319: PUSH
11320: LD_INT 1
11322: PPUSH
11323: LD_EXP 28
11327: PPUSH
11328: CALL_OW 12
11332: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_EXP 28
11342: PUSH
11343: LD_VAR 0 4
11347: ARRAY
11348: PUSH
11349: LD_INT 1
11351: ARRAY
11352: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11353: LD_ADDR_VAR 0 6
11357: PUSH
11358: LD_EXP 28
11362: PUSH
11363: LD_VAR 0 4
11367: ARRAY
11368: PUSH
11369: LD_INT 2
11371: ARRAY
11372: ST_TO_ADDR
// units := 1 + difficulty ;
11373: LD_ADDR_VAR 0 7
11377: PUSH
11378: LD_INT 1
11380: PUSH
11381: LD_OWVAR 67
11385: PLUS
11386: ST_TO_ADDR
// if daleko then
11387: LD_VAR 0 1
11391: IFFALSE 11655
// begin make_mess := make_arabs ( units , class_soldier ) ;
11393: LD_ADDR_LOC 9
11397: PUSH
11398: LD_VAR 0 7
11402: PPUSH
11403: LD_INT 1
11405: PPUSH
11406: CALL 1106 0 2
11410: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11411: LD_ADDR_VAR 0 7
11415: PUSH
11416: LD_LOC 9
11420: PUSH
11421: LD_INT 0
11423: PLUS
11424: ST_TO_ADDR
// for i in make_mess do
11425: LD_ADDR_VAR 0 3
11429: PUSH
11430: LD_LOC 9
11434: PUSH
11435: FOR_IN
11436: IFFALSE 11465
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11438: LD_VAR 0 3
11442: PPUSH
11443: LD_VAR 0 5
11447: PPUSH
11448: LD_VAR 0 6
11452: PPUSH
11453: LD_INT 5
11455: PPUSH
11456: LD_INT 0
11458: PPUSH
11459: CALL_OW 50
11463: GO 11435
11465: POP
11466: POP
// away_from_last_attack := 0 ;
11467: LD_ADDR_EXP 33
11471: PUSH
11472: LD_INT 0
11474: ST_TO_ADDR
// make_mess := make_mess ;
11475: LD_ADDR_LOC 9
11479: PUSH
11480: LD_LOC 9
11484: ST_TO_ADDR
// find_easiest_way ( GetX ( daleko [ 1 ] ) , GetY ( daleko [ 1 ] ) , 7 , 3 , make_mess , you , true ) ;
11485: LD_VAR 0 1
11489: PUSH
11490: LD_INT 1
11492: ARRAY
11493: PPUSH
11494: CALL_OW 250
11498: PPUSH
11499: LD_VAR 0 1
11503: PUSH
11504: LD_INT 1
11506: ARRAY
11507: PPUSH
11508: CALL_OW 251
11512: PPUSH
11513: LD_INT 7
11515: PPUSH
11516: LD_INT 3
11518: PPUSH
11519: LD_LOC 9
11523: PPUSH
11524: LD_EXP 1
11528: PPUSH
11529: LD_INT 1
11531: PPUSH
11532: CALL 12280 0 7
// AddComAttackUnit ( make_mess , daleko [ 1 ] ) ;
11536: LD_LOC 9
11540: PPUSH
11541: LD_VAR 0 1
11545: PUSH
11546: LD_INT 1
11548: ARRAY
11549: PPUSH
11550: CALL_OW 175
// if daleko >= 2 then
11554: LD_VAR 0 1
11558: PUSH
11559: LD_INT 2
11561: GREATEREQUAL
11562: IFFALSE 11610
// begin AddComAttackUnit ( make_mess , daleko [ 2 ] ) ;
11564: LD_LOC 9
11568: PPUSH
11569: LD_VAR 0 1
11573: PUSH
11574: LD_INT 2
11576: ARRAY
11577: PPUSH
11578: CALL_OW 175
// if daleko >= 3 then
11582: LD_VAR 0 1
11586: PUSH
11587: LD_INT 3
11589: GREATEREQUAL
11590: IFFALSE 11610
// begin AddComAttackUnit ( make_mess , daleko [ 3 ] ) ;
11592: LD_LOC 9
11596: PPUSH
11597: LD_VAR 0 1
11601: PUSH
11602: LD_INT 3
11604: ARRAY
11605: PPUSH
11606: CALL_OW 175
// end ; end ; evade_shortest_way ( make_mess , true , true ) ;
11610: LD_LOC 9
11614: PPUSH
11615: LD_INT 1
11617: PPUSH
11618: LD_INT 1
11620: PPUSH
11621: CALL 12822 0 3
// attacky := attacky + 1 ;
11625: LD_ADDR_EXP 40
11629: PUSH
11630: LD_EXP 40
11634: PUSH
11635: LD_INT 1
11637: PLUS
11638: ST_TO_ADDR
// lonely_attack := true ;
11639: LD_ADDR_EXP 37
11643: PUSH
11644: LD_INT 1
11646: ST_TO_ADDR
// attacking := true ;
11647: LD_ADDR_EXP 39
11651: PUSH
11652: LD_INT 1
11654: ST_TO_ADDR
// end ; end ;
11655: LD_VAR 0 2
11659: RET
// function F_next_attack ; var i , a , r , x , y , units , amici ; begin
11660: LD_INT 0
11662: PPUSH
11663: PPUSH
11664: PPUSH
11665: PPUSH
11666: PPUSH
11667: PPUSH
11668: PPUSH
11669: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11670: LD_ADDR_VAR 0 4
11674: PUSH
11675: LD_INT 1
11677: PPUSH
11678: LD_EXP 28
11682: PPUSH
11683: CALL_OW 12
11687: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11688: LD_ADDR_VAR 0 5
11692: PUSH
11693: LD_EXP 28
11697: PUSH
11698: LD_VAR 0 4
11702: ARRAY
11703: PUSH
11704: LD_INT 1
11706: ARRAY
11707: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11708: LD_ADDR_VAR 0 6
11712: PUSH
11713: LD_EXP 28
11717: PUSH
11718: LD_VAR 0 4
11722: ARRAY
11723: PUSH
11724: LD_INT 2
11726: ARRAY
11727: ST_TO_ADDR
// units := 2 + difficulty + away_from_last_attack div 8 + attacky div 8 ;
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_INT 2
11735: PUSH
11736: LD_OWVAR 67
11740: PLUS
11741: PUSH
11742: LD_EXP 33
11746: PUSH
11747: LD_INT 8
11749: DIV
11750: PLUS
11751: PUSH
11752: LD_EXP 40
11756: PUSH
11757: LD_INT 8
11759: DIV
11760: PLUS
11761: ST_TO_ADDR
// make_mess := make_arabs ( units , class_soldier ) ;
11762: LD_ADDR_LOC 9
11766: PUSH
11767: LD_VAR 0 7
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: CALL 1106 0 2
11779: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11780: LD_ADDR_VAR 0 7
11784: PUSH
11785: LD_LOC 9
11789: PUSH
11790: LD_INT 0
11792: PLUS
11793: ST_TO_ADDR
// for i in make_mess do
11794: LD_ADDR_VAR 0 2
11798: PUSH
11799: LD_LOC 9
11803: PUSH
11804: FOR_IN
11805: IFFALSE 11834
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11807: LD_VAR 0 2
11811: PPUSH
11812: LD_VAR 0 5
11816: PPUSH
11817: LD_VAR 0 6
11821: PPUSH
11822: LD_INT 5
11824: PPUSH
11825: LD_INT 0
11827: PPUSH
11828: CALL_OW 50
11832: GO 11804
11834: POP
11835: POP
// away_from_last_attack := 0 ;
11836: LD_ADDR_EXP 33
11840: PUSH
11841: LD_INT 0
11843: ST_TO_ADDR
// make_mess := make_mess ;
11844: LD_ADDR_LOC 9
11848: PUSH
11849: LD_LOC 9
11853: ST_TO_ADDR
// a := Rand ( 1 , budovy ) ;
11854: LD_ADDR_VAR 0 3
11858: PUSH
11859: LD_INT 1
11861: PPUSH
11862: LD_EXP 64
11866: PPUSH
11867: CALL_OW 12
11871: ST_TO_ADDR
// if budovy then
11872: LD_EXP 64
11876: IFFALSE 11921
// ComAgressiveMove ( make_mess , GetX ( budovy [ a ] ) , GetY ( budovy [ a ] ) ) else
11878: LD_LOC 9
11882: PPUSH
11883: LD_EXP 64
11887: PUSH
11888: LD_VAR 0 3
11892: ARRAY
11893: PPUSH
11894: CALL_OW 250
11898: PPUSH
11899: LD_EXP 64
11903: PUSH
11904: LD_VAR 0 3
11908: ARRAY
11909: PPUSH
11910: CALL_OW 251
11914: PPUSH
11915: CALL_OW 114
11919: GO 11958
// ComAgressiveMove ( make_mess , GetX ( tvoji_lidi [ 1 ] ) , GetY ( tvoji_lidi [ 1 ] ) ) ;
11921: LD_LOC 9
11925: PPUSH
11926: LD_EXP 48
11930: PUSH
11931: LD_INT 1
11933: ARRAY
11934: PPUSH
11935: CALL_OW 250
11939: PPUSH
11940: LD_EXP 48
11944: PUSH
11945: LD_INT 1
11947: ARRAY
11948: PPUSH
11949: CALL_OW 251
11953: PPUSH
11954: CALL_OW 114
// next_attack := true ;
11958: LD_ADDR_EXP 38
11962: PUSH
11963: LD_INT 1
11965: ST_TO_ADDR
// attacky := attacky + 1 ;
11966: LD_ADDR_EXP 40
11970: PUSH
11971: LD_EXP 40
11975: PUSH
11976: LD_INT 1
11978: PLUS
11979: ST_TO_ADDR
// attacking := true ;
11980: LD_ADDR_EXP 39
11984: PUSH
11985: LD_INT 1
11987: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
11988: LD_EXP 1
11992: PPUSH
11993: LD_LOC 9
11997: PPUSH
11998: CALL 13858 0 2
12002: NOT
12003: IFFALSE 12014
// wait ( 0 0$0.5 ) ;
12005: LD_INT 18
12007: PPUSH
12008: CALL_OW 67
12012: GO 11988
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
12014: LD_ADDR_VAR 0 8
12018: PUSH
12019: LD_INT 22
12021: PUSH
12022: LD_EXP 1
12026: PUSH
12027: EMPTY
12028: LIST
12029: LIST
12030: PUSH
12031: LD_INT 101
12033: PUSH
12034: LD_EXP 4
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PPUSH
12047: CALL_OW 69
12051: ST_TO_ADDR
// if amici then
12052: LD_VAR 0 8
12056: IFFALSE 12097
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
12058: LD_LOC 9
12062: PPUSH
12063: LD_VAR 0 8
12067: PUSH
12068: LD_INT 1
12070: ARRAY
12071: PPUSH
12072: CALL_OW 250
12076: PPUSH
12077: LD_VAR 0 8
12081: PUSH
12082: LD_INT 1
12084: ARRAY
12085: PPUSH
12086: CALL_OW 251
12090: PPUSH
12091: CALL_OW 114
// end else
12095: GO 12128
// begin ComMoveXY ( make_mess , x , y ) ;
12097: LD_LOC 9
12101: PPUSH
12102: LD_VAR 0 5
12106: PPUSH
12107: LD_VAR 0 6
12111: PPUSH
12112: CALL_OW 111
// AddComMoveToArea ( make_mess , border ) ;
12116: LD_LOC 9
12120: PPUSH
12121: LD_INT 7
12123: PPUSH
12124: CALL_OW 173
// end ; end ;
12128: LD_VAR 0 1
12132: RET
// every 0 0$1.0 do
12133: GO 12135
12135: DISABLE
// begin enter_near_vehicle ( make_mess , 4 , FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ) ;
12136: LD_LOC 9
12140: PPUSH
12141: LD_INT 4
12143: PPUSH
12144: LD_INT 22
12146: PUSH
12147: LD_EXP 1
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PUSH
12156: LD_INT 21
12158: PUSH
12159: LD_INT 2
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: PPUSH
12175: CALL 13929 0 3
// arabs_cars := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) ;
12179: LD_ADDR_EXP 10
12183: PUSH
12184: LD_INT 21
12186: PUSH
12187: LD_INT 2
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 22
12196: PUSH
12197: LD_EXP 4
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PPUSH
12210: CALL_OW 69
12214: ST_TO_ADDR
// if arabs_cars then
12215: LD_EXP 10
12219: IFFALSE 12278
// begin if GetWeapon ( arabs_cars [ 1 ] ) <> us_cargo_bay then
12221: LD_EXP 10
12225: PUSH
12226: LD_INT 1
12228: ARRAY
12229: PPUSH
12230: CALL_OW 264
12234: PUSH
12235: LD_INT 12
12237: NONEQUAL
12238: IFFALSE 12266
// begin ComWait ( arabs_cars , 0 0$12 ) ;
12240: LD_EXP 10
12244: PPUSH
12245: LD_INT 420
12247: PPUSH
12248: CALL_OW 142
// AddComMoveToArea ( arabs_cars , border ) ;
12252: LD_EXP 10
12256: PPUSH
12257: LD_INT 7
12259: PPUSH
12260: CALL_OW 173
// end else
12264: GO 12278
// ComMoveToArea ( arabs_cars , border ) ;
12266: LD_EXP 10
12270: PPUSH
12271: LD_INT 7
12273: PPUSH
12274: CALL_OW 113
// end ; enable ;
12278: ENABLE
// end ; end_of_file
12279: END
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
12280: LD_INT 0
12282: PPUSH
12283: PPUSH
12284: PPUSH
12285: PPUSH
12286: PPUSH
12287: PPUSH
12288: PPUSH
12289: PPUSH
12290: PPUSH
12291: PPUSH
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
12296: PPUSH
// for for_unit in for_units do
12297: LD_ADDR_VAR 0 22
12301: PUSH
12302: LD_VAR 0 5
12306: PUSH
12307: FOR_IN
12308: IFFALSE 12815
// begin x := px ;
12310: LD_ADDR_VAR 0 9
12314: PUSH
12315: LD_VAR 0 1
12319: ST_TO_ADDR
// y := py ;
12320: LD_ADDR_VAR 0 10
12324: PUSH
12325: LD_VAR 0 2
12329: ST_TO_ADDR
// lx := px ;
12330: LD_ADDR_VAR 0 13
12334: PUSH
12335: LD_VAR 0 1
12339: ST_TO_ADDR
// ly := py ;
12340: LD_ADDR_VAR 0 14
12344: PUSH
12345: LD_VAR 0 2
12349: ST_TO_ADDR
// for j2 := 1 to hloubka do
12350: LD_ADDR_VAR 0 18
12354: PUSH
12355: DOUBLE
12356: LD_INT 1
12358: DEC
12359: ST_TO_ADDR
12360: LD_VAR 0 3
12364: PUSH
12365: FOR_TO
12366: IFFALSE 12698
// begin howgood := 50000 ;
12368: LD_ADDR_VAR 0 15
12372: PUSH
12373: LD_INT 50000
12375: ST_TO_ADDR
// smer := 0 ;
12376: LD_ADDR_VAR 0 16
12380: PUSH
12381: LD_INT 0
12383: ST_TO_ADDR
// kolem := 0 ;
12384: LD_ADDR_VAR 0 21
12388: PUSH
12389: LD_INT 0
12391: ST_TO_ADDR
// for i2 := 0 to 4 do
12392: LD_ADDR_VAR 0 17
12396: PUSH
12397: DOUBLE
12398: LD_INT 0
12400: DEC
12401: ST_TO_ADDR
12402: LD_INT 4
12404: PUSH
12405: FOR_TO
12406: IFFALSE 12600
// begin x2 := ShiftX ( x , i2 , krok ) ;
12408: LD_ADDR_VAR 0 11
12412: PUSH
12413: LD_VAR 0 9
12417: PPUSH
12418: LD_VAR 0 17
12422: PPUSH
12423: LD_VAR 0 4
12427: PPUSH
12428: CALL_OW 272
12432: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
12433: LD_ADDR_VAR 0 12
12437: PUSH
12438: LD_VAR 0 10
12442: PPUSH
12443: LD_VAR 0 17
12447: PPUSH
12448: LD_VAR 0 4
12452: PPUSH
12453: CALL_OW 273
12457: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
12458: LD_ADDR_VAR 0 20
12462: PUSH
12463: LD_VAR 0 6
12467: PPUSH
12468: LD_VAR 0 11
12472: PPUSH
12473: LD_VAR 0 12
12477: PPUSH
12478: CALL_OW 293
12482: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
12483: LD_VAR 0 20
12487: PUSH
12488: LD_VAR 0 15
12492: LESS
12493: PUSH
12494: LD_VAR 0 1
12498: PPUSH
12499: LD_VAR 0 2
12503: PPUSH
12504: LD_VAR 0 9
12508: PPUSH
12509: LD_VAR 0 10
12513: PPUSH
12514: CALL_OW 298
12518: PUSH
12519: LD_VAR 0 1
12523: PPUSH
12524: LD_VAR 0 2
12528: PPUSH
12529: LD_VAR 0 11
12533: PPUSH
12534: LD_VAR 0 12
12538: PPUSH
12539: CALL_OW 298
12543: LESS
12544: AND
12545: IFFALSE 12582
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
12547: LD_ADDR_VAR 0 15
12551: PUSH
12552: LD_VAR 0 6
12556: PPUSH
12557: LD_VAR 0 11
12561: PPUSH
12562: LD_VAR 0 12
12566: PPUSH
12567: CALL_OW 293
12571: ST_TO_ADDR
// smer := i2 ;
12572: LD_ADDR_VAR 0 16
12576: PUSH
12577: LD_VAR 0 17
12581: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
12582: LD_ADDR_VAR 0 21
12586: PUSH
12587: LD_VAR 0 21
12591: PUSH
12592: LD_VAR 0 20
12596: PLUS
12597: ST_TO_ADDR
// end ;
12598: GO 12405
12600: POP
12601: POP
// x := ShiftX ( x , smer , krok ) ;
12602: LD_ADDR_VAR 0 9
12606: PUSH
12607: LD_VAR 0 9
12611: PPUSH
12612: LD_VAR 0 16
12616: PPUSH
12617: LD_VAR 0 4
12621: PPUSH
12622: CALL_OW 272
12626: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
12627: LD_ADDR_VAR 0 10
12631: PUSH
12632: LD_VAR 0 10
12636: PPUSH
12637: LD_VAR 0 16
12641: PPUSH
12642: LD_VAR 0 4
12646: PPUSH
12647: CALL_OW 273
12651: ST_TO_ADDR
// lx := lx ^ x ;
12652: LD_ADDR_VAR 0 13
12656: PUSH
12657: LD_VAR 0 13
12661: PUSH
12662: LD_VAR 0 9
12666: ADD
12667: ST_TO_ADDR
// ly := ly ^ y ;
12668: LD_ADDR_VAR 0 14
12672: PUSH
12673: LD_VAR 0 14
12677: PUSH
12678: LD_VAR 0 10
12682: ADD
12683: ST_TO_ADDR
// if kolem = 0 then
12684: LD_VAR 0 21
12688: PUSH
12689: LD_INT 0
12691: EQUAL
12692: IFFALSE 12696
// break ;
12694: GO 12698
// end ;
12696: GO 12365
12698: POP
12699: POP
// for j2 := ( lx + 0 ) downto 1 do
12700: LD_ADDR_VAR 0 18
12704: PUSH
12705: DOUBLE
12706: LD_VAR 0 13
12710: PUSH
12711: LD_INT 0
12713: PLUS
12714: INC
12715: ST_TO_ADDR
12716: LD_INT 1
12718: PUSH
12719: FOR_DOWNTO
12720: IFFALSE 12811
// begin if not queue and j2 = ( lx + 0 ) then
12722: LD_VAR 0 7
12726: NOT
12727: PUSH
12728: LD_VAR 0 18
12732: PUSH
12733: LD_VAR 0 13
12737: PUSH
12738: LD_INT 0
12740: PLUS
12741: EQUAL
12742: AND
12743: IFFALSE 12778
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
12745: LD_VAR 0 22
12749: PPUSH
12750: LD_VAR 0 13
12754: PUSH
12755: LD_VAR 0 18
12759: ARRAY
12760: PPUSH
12761: LD_VAR 0 14
12765: PUSH
12766: LD_VAR 0 18
12770: ARRAY
12771: PPUSH
12772: CALL_OW 111
12776: GO 12809
// begin AddComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
12778: LD_VAR 0 22
12782: PPUSH
12783: LD_VAR 0 13
12787: PUSH
12788: LD_VAR 0 18
12792: ARRAY
12793: PPUSH
12794: LD_VAR 0 14
12798: PUSH
12799: LD_VAR 0 18
12803: ARRAY
12804: PPUSH
12805: CALL_OW 171
// end ; end ;
12809: GO 12719
12811: POP
12812: POP
// end ;
12813: GO 12307
12815: POP
12816: POP
// end ;
12817: LD_VAR 0 8
12821: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
12822: LD_INT 0
12824: PPUSH
12825: PPUSH
12826: PPUSH
12827: PPUSH
// for for_unit in for_units do
12828: LD_ADDR_VAR 0 5
12832: PUSH
12833: LD_VAR 0 1
12837: PUSH
12838: FOR_IN
12839: IFFALSE 12902
// begin unx := GetX ( for_unit ) ;
12841: LD_ADDR_VAR 0 6
12845: PUSH
12846: LD_VAR 0 5
12850: PPUSH
12851: CALL_OW 250
12855: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
12856: LD_ADDR_VAR 0 7
12860: PUSH
12861: LD_VAR 0 5
12865: PPUSH
12866: CALL_OW 251
12870: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
12871: LD_VAR 0 6
12875: PPUSH
12876: LD_VAR 0 7
12880: PPUSH
12881: LD_VAR 0 5
12885: PPUSH
12886: LD_VAR 0 2
12890: PPUSH
12891: LD_VAR 0 3
12895: PPUSH
12896: CALL 12909 0 5
// end ;
12900: GO 12838
12902: POP
12903: POP
// end ;
12904: LD_VAR 0 4
12908: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
12909: LD_INT 0
12911: PPUSH
12912: PPUSH
12913: PPUSH
12914: PPUSH
12915: PPUSH
12916: PPUSH
12917: PPUSH
// for for_unit in for_units do
12918: LD_ADDR_VAR 0 12
12922: PUSH
12923: LD_VAR 0 3
12927: PUSH
12928: FOR_IN
12929: IFFALSE 13645
// begin foundswD := 50000 ;
12931: LD_ADDR_VAR 0 9
12935: PUSH
12936: LD_INT 50000
12938: ST_TO_ADDR
// eswTX := 0 ;
12939: LD_ADDR_VAR 0 10
12943: PUSH
12944: LD_INT 0
12946: ST_TO_ADDR
// eswTY := 0 ;
12947: LD_ADDR_VAR 0 11
12951: PUSH
12952: LD_INT 0
12954: ST_TO_ADDR
// while eswTX < map_size_x do
12955: LD_VAR 0 10
12959: PUSH
12960: LD_EXP 29
12964: LESS
12965: IFFALSE 13065
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
12967: LD_VAR 0 1
12971: PPUSH
12972: LD_VAR 0 2
12976: PPUSH
12977: LD_VAR 0 10
12981: PPUSH
12982: LD_VAR 0 11
12986: PPUSH
12987: CALL_OW 298
12991: PUSH
12992: LD_VAR 0 9
12996: LESS
12997: IFFALSE 13049
// begin foundswX := eswTX ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 10
13008: ST_TO_ADDR
// foundswY := eswTY ;
13009: LD_ADDR_VAR 0 8
13013: PUSH
13014: LD_VAR 0 11
13018: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13019: LD_ADDR_VAR 0 9
13023: PUSH
13024: LD_VAR 0 1
13028: PPUSH
13029: LD_VAR 0 2
13033: PPUSH
13034: LD_VAR 0 10
13038: PPUSH
13039: LD_VAR 0 11
13043: PPUSH
13044: CALL_OW 298
13048: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
13049: LD_ADDR_VAR 0 10
13053: PUSH
13054: LD_VAR 0 10
13058: PUSH
13059: LD_INT 10
13061: PLUS
13062: ST_TO_ADDR
// end ;
13063: GO 12955
// eswTX := map_size_x div 2 ;
13065: LD_ADDR_VAR 0 10
13069: PUSH
13070: LD_EXP 29
13074: PUSH
13075: LD_INT 2
13077: DIV
13078: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
13079: LD_ADDR_VAR 0 11
13083: PUSH
13084: LD_EXP 30
13088: PUSH
13089: LD_INT 1
13091: MINUS
13092: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
13093: LD_VAR 0 10
13097: PUSH
13098: LD_EXP 29
13102: PUSH
13103: LD_EXP 29
13107: PUSH
13108: LD_INT 2
13110: DIV
13111: PLUS
13112: LESS
13113: IFFALSE 13213
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13115: LD_VAR 0 1
13119: PPUSH
13120: LD_VAR 0 2
13124: PPUSH
13125: LD_VAR 0 10
13129: PPUSH
13130: LD_VAR 0 11
13134: PPUSH
13135: CALL_OW 298
13139: PUSH
13140: LD_VAR 0 9
13144: LESS
13145: IFFALSE 13197
// begin foundswX := eswTX ;
13147: LD_ADDR_VAR 0 7
13151: PUSH
13152: LD_VAR 0 10
13156: ST_TO_ADDR
// foundswY := eswTY ;
13157: LD_ADDR_VAR 0 8
13161: PUSH
13162: LD_VAR 0 11
13166: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13167: LD_ADDR_VAR 0 9
13171: PUSH
13172: LD_VAR 0 1
13176: PPUSH
13177: LD_VAR 0 2
13181: PPUSH
13182: LD_VAR 0 10
13186: PPUSH
13187: LD_VAR 0 11
13191: PPUSH
13192: CALL_OW 298
13196: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
13197: LD_ADDR_VAR 0 10
13201: PUSH
13202: LD_VAR 0 10
13206: PUSH
13207: LD_INT 10
13209: PLUS
13210: ST_TO_ADDR
// end ;
13211: GO 13093
// eswTX := 0 ;
13213: LD_ADDR_VAR 0 10
13217: PUSH
13218: LD_INT 0
13220: ST_TO_ADDR
// eswTY := 0 ;
13221: LD_ADDR_VAR 0 11
13225: PUSH
13226: LD_INT 0
13228: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13229: LD_VAR 0 11
13233: PUSH
13234: LD_EXP 30
13238: LESS
13239: IFFALSE 13353
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13241: LD_VAR 0 1
13245: PPUSH
13246: LD_VAR 0 2
13250: PPUSH
13251: LD_VAR 0 10
13255: PPUSH
13256: LD_VAR 0 11
13260: PPUSH
13261: CALL_OW 298
13265: PUSH
13266: LD_VAR 0 9
13270: LESS
13271: IFFALSE 13323
// begin foundswX := eswTX ;
13273: LD_ADDR_VAR 0 7
13277: PUSH
13278: LD_VAR 0 10
13282: ST_TO_ADDR
// foundswY := eswTY ;
13283: LD_ADDR_VAR 0 8
13287: PUSH
13288: LD_VAR 0 11
13292: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13293: LD_ADDR_VAR 0 9
13297: PUSH
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_VAR 0 2
13307: PPUSH
13308: LD_VAR 0 10
13312: PPUSH
13313: LD_VAR 0 11
13317: PPUSH
13318: CALL_OW 298
13322: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13323: LD_ADDR_VAR 0 11
13327: PUSH
13328: LD_VAR 0 11
13332: PUSH
13333: LD_INT 10
13335: PLUS
13336: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13337: LD_ADDR_VAR 0 10
13341: PUSH
13342: LD_VAR 0 10
13346: PUSH
13347: LD_INT 5
13349: PLUS
13350: ST_TO_ADDR
// end ;
13351: GO 13229
// eswTX := map_size_x ;
13353: LD_ADDR_VAR 0 10
13357: PUSH
13358: LD_EXP 29
13362: ST_TO_ADDR
// eswTY := 1 ;
13363: LD_ADDR_VAR 0 11
13367: PUSH
13368: LD_INT 1
13370: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13371: LD_VAR 0 11
13375: PUSH
13376: LD_EXP 30
13380: LESS
13381: IFFALSE 13495
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13383: LD_VAR 0 1
13387: PPUSH
13388: LD_VAR 0 2
13392: PPUSH
13393: LD_VAR 0 10
13397: PPUSH
13398: LD_VAR 0 11
13402: PPUSH
13403: CALL_OW 298
13407: PUSH
13408: LD_VAR 0 9
13412: LESS
13413: IFFALSE 13465
// begin foundswX := eswTX ;
13415: LD_ADDR_VAR 0 7
13419: PUSH
13420: LD_VAR 0 10
13424: ST_TO_ADDR
// foundswY := eswTY ;
13425: LD_ADDR_VAR 0 8
13429: PUSH
13430: LD_VAR 0 11
13434: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13435: LD_ADDR_VAR 0 9
13439: PUSH
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_VAR 0 2
13449: PPUSH
13450: LD_VAR 0 10
13454: PPUSH
13455: LD_VAR 0 11
13459: PPUSH
13460: CALL_OW 298
13464: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13465: LD_ADDR_VAR 0 11
13469: PUSH
13470: LD_VAR 0 11
13474: PUSH
13475: LD_INT 10
13477: PLUS
13478: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13479: LD_ADDR_VAR 0 10
13483: PUSH
13484: LD_VAR 0 10
13488: PUSH
13489: LD_INT 5
13491: PLUS
13492: ST_TO_ADDR
// end ;
13493: GO 13371
// if queue then
13495: LD_VAR 0 4
13499: IFFALSE 13573
// begin if agressive then
13501: LD_VAR 0 5
13505: IFFALSE 13540
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13507: LD_VAR 0 12
13511: PPUSH
13512: LD_VAR 0 7
13516: PPUSH
13517: LD_VAR 0 8
13521: PPUSH
13522: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
13526: LD_VAR 0 12
13530: PPUSH
13531: LD_INT 7
13533: PPUSH
13534: CALL_OW 173
// end else
13538: GO 13571
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
13540: LD_VAR 0 12
13544: PPUSH
13545: LD_VAR 0 7
13549: PPUSH
13550: LD_VAR 0 8
13554: PPUSH
13555: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
13559: LD_VAR 0 12
13563: PPUSH
13564: LD_INT 7
13566: PPUSH
13567: CALL_OW 173
// end ; end else
13571: GO 13643
// begin if agressive then
13573: LD_VAR 0 5
13577: IFFALSE 13612
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13579: LD_VAR 0 12
13583: PPUSH
13584: LD_VAR 0 7
13588: PPUSH
13589: LD_VAR 0 8
13593: PPUSH
13594: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
13598: LD_VAR 0 12
13602: PPUSH
13603: LD_INT 7
13605: PPUSH
13606: CALL_OW 173
// end else
13610: GO 13643
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
13612: LD_VAR 0 12
13616: PPUSH
13617: LD_VAR 0 7
13621: PPUSH
13622: LD_VAR 0 8
13626: PPUSH
13627: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
13631: LD_VAR 0 12
13635: PPUSH
13636: LD_INT 7
13638: PPUSH
13639: CALL_OW 173
// end ; end ; end ;
13643: GO 12928
13645: POP
13646: POP
// end ;
13647: LD_VAR 0 6
13651: RET
// export function get_live_from_list ( sez1 , skip , pocet ) ; var un1 , count , max , skiped ; var list ; begin
13652: LD_INT 0
13654: PPUSH
13655: PPUSH
13656: PPUSH
13657: PPUSH
13658: PPUSH
13659: PPUSH
// un1 := 1 ;
13660: LD_ADDR_VAR 0 5
13664: PUSH
13665: LD_INT 1
13667: ST_TO_ADDR
// count := 0 ;
13668: LD_ADDR_VAR 0 6
13672: PUSH
13673: LD_INT 0
13675: ST_TO_ADDR
// skiped := 0 ;
13676: LD_ADDR_VAR 0 8
13680: PUSH
13681: LD_INT 0
13683: ST_TO_ADDR
// max := ( sez1 + 0 ) ;
13684: LD_ADDR_VAR 0 7
13688: PUSH
13689: LD_VAR 0 1
13693: PUSH
13694: LD_INT 0
13696: PLUS
13697: ST_TO_ADDR
// while un1 <= max and count < pocet do
13698: LD_VAR 0 5
13702: PUSH
13703: LD_VAR 0 7
13707: LESSEQUAL
13708: PUSH
13709: LD_VAR 0 6
13713: PUSH
13714: LD_VAR 0 3
13718: LESS
13719: AND
13720: IFFALSE 13843
// begin if IsLive ( sez1 [ un1 ] ) then
13722: LD_VAR 0 1
13726: PUSH
13727: LD_VAR 0 5
13731: ARRAY
13732: PPUSH
13733: CALL_OW 300
13737: IFFALSE 13827
// begin if skiped >= skip then
13739: LD_VAR 0 8
13743: PUSH
13744: LD_VAR 0 2
13748: GREATEREQUAL
13749: IFFALSE 13813
// begin if list then
13751: LD_VAR 0 9
13755: IFFALSE 13781
// list := list ^ sez1 [ un1 ] else
13757: LD_ADDR_VAR 0 9
13761: PUSH
13762: LD_VAR 0 9
13766: PUSH
13767: LD_VAR 0 1
13771: PUSH
13772: LD_VAR 0 5
13776: ARRAY
13777: ADD
13778: ST_TO_ADDR
13779: GO 13797
// list := sez1 [ un1 ] ;
13781: LD_ADDR_VAR 0 9
13785: PUSH
13786: LD_VAR 0 1
13790: PUSH
13791: LD_VAR 0 5
13795: ARRAY
13796: ST_TO_ADDR
// count := count + 1 ;
13797: LD_ADDR_VAR 0 6
13801: PUSH
13802: LD_VAR 0 6
13806: PUSH
13807: LD_INT 1
13809: PLUS
13810: ST_TO_ADDR
// end else
13811: GO 13827
// begin skiped := skiped + 1 ;
13813: LD_ADDR_VAR 0 8
13817: PUSH
13818: LD_VAR 0 8
13822: PUSH
13823: LD_INT 1
13825: PLUS
13826: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
13827: LD_ADDR_VAR 0 5
13831: PUSH
13832: LD_VAR 0 5
13836: PUSH
13837: LD_INT 1
13839: PLUS
13840: ST_TO_ADDR
// end ;
13841: GO 13698
// result := list ;
13843: LD_ADDR_VAR 0 4
13847: PUSH
13848: LD_VAR 0 9
13852: ST_TO_ADDR
// end ;
13853: LD_VAR 0 4
13857: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
13858: LD_INT 0
13860: PPUSH
13861: PPUSH
13862: PPUSH
// see_any_r := false ;
13863: LD_ADDR_VAR 0 5
13867: PUSH
13868: LD_INT 0
13870: ST_TO_ADDR
// for sai in sez2 do
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: LD_VAR 0 2
13880: PUSH
13881: FOR_IN
13882: IFFALSE 13912
// if See ( strana , sai ) then
13884: LD_VAR 0 1
13888: PPUSH
13889: LD_VAR 0 4
13893: PPUSH
13894: CALL_OW 292
13898: IFFALSE 13910
// begin see_any_r := true ;
13900: LD_ADDR_VAR 0 5
13904: PUSH
13905: LD_INT 1
13907: ST_TO_ADDR
// break ;
13908: GO 13912
// end ;
13910: GO 13881
13912: POP
13913: POP
// ; result := see_any_r ;
13914: LD_ADDR_VAR 0 3
13918: PUSH
13919: LD_VAR 0 5
13923: ST_TO_ADDR
// end ;
13924: LD_VAR 0 3
13928: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
13929: LD_INT 0
13931: PPUSH
13932: PPUSH
13933: PPUSH
13934: PPUSH
// for i in who do
13935: LD_ADDR_VAR 0 6
13939: PUSH
13940: LD_VAR 0 1
13944: PUSH
13945: FOR_IN
13946: IFFALSE 14017
// begin for j in what do
13948: LD_ADDR_VAR 0 7
13952: PUSH
13953: LD_VAR 0 3
13957: PUSH
13958: FOR_IN
13959: IFFALSE 14013
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
13961: LD_VAR 0 7
13965: PPUSH
13966: CALL_OW 311
13970: NOT
13971: PUSH
13972: LD_VAR 0 6
13976: PPUSH
13977: LD_VAR 0 7
13981: PPUSH
13982: CALL_OW 296
13986: PUSH
13987: LD_VAR 0 2
13991: LESSEQUAL
13992: AND
13993: IFFALSE 14011
// begin ComEnterUnit ( i , j ) ;
13995: LD_VAR 0 6
13999: PPUSH
14000: LD_VAR 0 7
14004: PPUSH
14005: CALL_OW 120
// break ;
14009: GO 14013
// end ; end ;
14011: GO 13958
14013: POP
14014: POP
// end ;
14015: GO 13945
14017: POP
14018: POP
// end ;
14019: LD_VAR 0 4
14023: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
14024: LD_INT 0
14026: PPUSH
14027: PPUSH
14028: PPUSH
14029: PPUSH
// for i in who do
14030: LD_ADDR_VAR 0 6
14034: PUSH
14035: LD_VAR 0 1
14039: PUSH
14040: FOR_IN
14041: IFFALSE 14140
// begin add := false ;
14043: LD_ADDR_VAR 0 5
14047: PUSH
14048: LD_INT 0
14050: ST_TO_ADDR
// for j in what do
14051: LD_ADDR_VAR 0 7
14055: PUSH
14056: LD_VAR 0 3
14060: PUSH
14061: FOR_IN
14062: IFFALSE 14096
// begin if GetDistUnits ( i , j ) <= dist then
14064: LD_VAR 0 6
14068: PPUSH
14069: LD_VAR 0 7
14073: PPUSH
14074: CALL_OW 296
14078: PUSH
14079: LD_VAR 0 2
14083: LESSEQUAL
14084: IFFALSE 14094
// begin add := true ;
14086: LD_ADDR_VAR 0 5
14090: PUSH
14091: LD_INT 1
14093: ST_TO_ADDR
// end ; end ;
14094: GO 14061
14096: POP
14097: POP
// if add then
14098: LD_VAR 0 5
14102: IFFALSE 14138
// begin if result then
14104: LD_VAR 0 4
14108: IFFALSE 14128
// result := result ^ i else
14110: LD_ADDR_VAR 0 4
14114: PUSH
14115: LD_VAR 0 4
14119: PUSH
14120: LD_VAR 0 6
14124: ADD
14125: ST_TO_ADDR
14126: GO 14138
// result := i ;
14128: LD_ADDR_VAR 0 4
14132: PUSH
14133: LD_VAR 0 6
14137: ST_TO_ADDR
// end ; end ;
14138: GO 14040
14140: POP
14141: POP
// end ;
14142: LD_VAR 0 4
14146: RET
// export function comqb ; begin
14147: LD_INT 0
14149: PPUSH
// com_queue := true ;
14150: LD_ADDR_OWVAR 49
14154: PUSH
14155: LD_INT 1
14157: ST_TO_ADDR
// end ;
14158: LD_VAR 0 1
14162: RET
// export function comqe ; begin
14163: LD_INT 0
14165: PPUSH
// com_queue := false ;
14166: LD_ADDR_OWVAR 49
14170: PUSH
14171: LD_INT 0
14173: ST_TO_ADDR
// end ;
14174: LD_VAR 0 1
14178: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
14179: LD_INT 0
14181: PPUSH
14182: PPUSH
14183: PPUSH
// i1 := 1 ;
14184: LD_ADDR_VAR 0 5
14188: PUSH
14189: LD_INT 1
14191: ST_TO_ADDR
// while i1 <= path do
14192: LD_VAR 0 5
14196: PUSH
14197: LD_VAR 0 2
14201: LESSEQUAL
14202: IFFALSE 14449
// begin a := path [ i1 ] ;
14204: LD_ADDR_VAR 0 6
14208: PUSH
14209: LD_VAR 0 2
14213: PUSH
14214: LD_VAR 0 5
14218: ARRAY
14219: ST_TO_ADDR
// if a < 0 then
14220: LD_VAR 0 6
14224: PUSH
14225: LD_INT 0
14227: LESS
14228: IFFALSE 14285
// begin while a <= - 1 do
14230: LD_VAR 0 6
14234: PUSH
14235: LD_INT 1
14237: NEG
14238: LESSEQUAL
14239: IFFALSE 14269
// begin a := a + 1 ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_VAR 0 6
14250: PUSH
14251: LD_INT 1
14253: PLUS
14254: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
14255: LD_VAR 0 1
14259: PPUSH
14260: LD_INT 35
14262: PPUSH
14263: CALL_OW 202
// end ;
14267: GO 14230
// i1 := i1 + 1 ;
14269: LD_ADDR_VAR 0 5
14273: PUSH
14274: LD_VAR 0 5
14278: PUSH
14279: LD_INT 1
14281: PLUS
14282: ST_TO_ADDR
// end else
14283: GO 14447
// begin if a = 0 then
14285: LD_VAR 0 6
14289: PUSH
14290: LD_INT 0
14292: EQUAL
14293: IFFALSE 14355
// begin a := path [ i1 + 1 ] ;
14295: LD_ADDR_VAR 0 6
14299: PUSH
14300: LD_VAR 0 2
14304: PUSH
14305: LD_VAR 0 5
14309: PUSH
14310: LD_INT 1
14312: PLUS
14313: ARRAY
14314: ST_TO_ADDR
// if a = 0 then
14315: LD_VAR 0 6
14319: PUSH
14320: LD_INT 0
14322: EQUAL
14323: IFFALSE 14334
// AddComReturn ( for_units ) ;
14325: LD_VAR 0 1
14329: PPUSH
14330: CALL_OW 204
// if a = 1 then
14334: LD_VAR 0 6
14338: PUSH
14339: LD_INT 1
14341: EQUAL
14342: IFFALSE 14353
// AddComRemember ( for_units ) ;
14344: LD_VAR 0 1
14348: PPUSH
14349: CALL_OW 203
// end else
14353: GO 14433
// begin if agressive then
14355: LD_VAR 0 3
14359: IFFALSE 14398
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
14361: LD_VAR 0 1
14365: PPUSH
14366: LD_VAR 0 2
14370: PUSH
14371: LD_VAR 0 5
14375: ARRAY
14376: PPUSH
14377: LD_VAR 0 2
14381: PUSH
14382: LD_VAR 0 5
14386: PUSH
14387: LD_INT 1
14389: PLUS
14390: ARRAY
14391: PPUSH
14392: CALL_OW 174
14396: GO 14433
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
14398: LD_VAR 0 1
14402: PPUSH
14403: LD_VAR 0 2
14407: PUSH
14408: LD_VAR 0 5
14412: ARRAY
14413: PPUSH
14414: LD_VAR 0 2
14418: PUSH
14419: LD_VAR 0 5
14423: PUSH
14424: LD_INT 1
14426: PLUS
14427: ARRAY
14428: PPUSH
14429: CALL_OW 171
// end ; i1 := i1 + 2 ;
14433: LD_ADDR_VAR 0 5
14437: PUSH
14438: LD_VAR 0 5
14442: PUSH
14443: LD_INT 2
14445: PLUS
14446: ST_TO_ADDR
// end ; end ;
14447: GO 14192
// end ;
14449: LD_VAR 0 4
14453: RET
// export function find_drivers ( cars , drivers ) ; var empty , free , i , konec ; begin
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
14459: PPUSH
14460: PPUSH
// cars := cars union [ ] ;
14461: LD_ADDR_VAR 0 1
14465: PUSH
14466: LD_VAR 0 1
14470: PUSH
14471: EMPTY
14472: UNION
14473: ST_TO_ADDR
// drivers := drivers union [ ] ;
14474: LD_ADDR_VAR 0 2
14478: PUSH
14479: LD_VAR 0 2
14483: PUSH
14484: EMPTY
14485: UNION
14486: ST_TO_ADDR
// for i in cars do
14487: LD_ADDR_VAR 0 6
14491: PUSH
14492: LD_VAR 0 1
14496: PUSH
14497: FOR_IN
14498: IFFALSE 14534
// if not IsDrivenBy ( i ) then
14500: LD_VAR 0 6
14504: PPUSH
14505: CALL_OW 311
14509: NOT
14510: IFFALSE 14532
// empty := add ( empty , i ) ;
14512: LD_ADDR_VAR 0 4
14516: PUSH
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 6
14526: PPUSH
14527: CALL 14823 0 2
14531: ST_TO_ADDR
14532: GO 14497
14534: POP
14535: POP
// for i in drivers do
14536: LD_ADDR_VAR 0 6
14540: PUSH
14541: LD_VAR 0 2
14545: PUSH
14546: FOR_IN
14547: IFFALSE 14583
// if not IsInUnit ( i ) then
14549: LD_VAR 0 6
14553: PPUSH
14554: CALL_OW 310
14558: NOT
14559: IFFALSE 14581
// free := add ( free , i ) ;
14561: LD_ADDR_VAR 0 5
14565: PUSH
14566: LD_VAR 0 5
14570: PPUSH
14571: LD_VAR 0 6
14575: PPUSH
14576: CALL 14823 0 2
14580: ST_TO_ADDR
14581: GO 14546
14583: POP
14584: POP
// result := cars diff empty ;
14585: LD_ADDR_VAR 0 3
14589: PUSH
14590: LD_VAR 0 1
14594: PUSH
14595: LD_VAR 0 4
14599: DIFF
14600: ST_TO_ADDR
// if empty <= free then
14601: LD_VAR 0 4
14605: PUSH
14606: LD_VAR 0 5
14610: LESSEQUAL
14611: IFFALSE 14625
// konec := empty else
14613: LD_ADDR_VAR 0 7
14617: PUSH
14618: LD_VAR 0 4
14622: ST_TO_ADDR
14623: GO 14635
// konec := free ;
14625: LD_ADDR_VAR 0 7
14629: PUSH
14630: LD_VAR 0 5
14634: ST_TO_ADDR
// for i := 1 to konec do
14635: LD_ADDR_VAR 0 6
14639: PUSH
14640: DOUBLE
14641: LD_INT 1
14643: DEC
14644: ST_TO_ADDR
14645: LD_VAR 0 7
14649: PUSH
14650: FOR_TO
14651: IFFALSE 14707
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
14653: LD_VAR 0 5
14657: PUSH
14658: LD_VAR 0 6
14662: ARRAY
14663: PPUSH
14664: LD_VAR 0 4
14668: PUSH
14669: LD_VAR 0 6
14673: ARRAY
14674: PPUSH
14675: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
14679: LD_ADDR_VAR 0 3
14683: PUSH
14684: LD_VAR 0 3
14688: PPUSH
14689: LD_VAR 0 4
14693: PUSH
14694: LD_VAR 0 6
14698: ARRAY
14699: PPUSH
14700: CALL 14823 0 2
14704: ST_TO_ADDR
// end ;
14705: GO 14650
14707: POP
14708: POP
// end ;
14709: LD_VAR 0 3
14713: RET
// export function rand_xy_in_map ; var x , y ; begin
14714: LD_INT 0
14716: PPUSH
14717: PPUSH
14718: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
14719: LD_ADDR_VAR 0 3
14723: PUSH
14724: LD_INT 2
14726: PPUSH
14727: LD_EXP 30
14731: PUSH
14732: LD_INT 2
14734: MINUS
14735: PPUSH
14736: CALL_OW 12
14740: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
14741: LD_ADDR_VAR 0 2
14745: PUSH
14746: LD_VAR 0 3
14750: PUSH
14751: LD_INT 2
14753: DIV
14754: PUSH
14755: LD_INT 2
14757: PLUS
14758: PPUSH
14759: LD_EXP 29
14763: PUSH
14764: LD_VAR 0 3
14768: PUSH
14769: LD_INT 2
14771: DIV
14772: PLUS
14773: PUSH
14774: LD_INT 2
14776: MINUS
14777: PPUSH
14778: CALL_OW 12
14782: ST_TO_ADDR
// result := [ x , y ] ;
14783: LD_ADDR_VAR 0 1
14787: PUSH
14788: LD_VAR 0 2
14792: PUSH
14793: LD_VAR 0 3
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: ST_TO_ADDR
// end ;
14802: LD_VAR 0 1
14806: RET
// export function TalkOn ; begin
14807: LD_INT 0
14809: PPUSH
// end ;
14810: LD_VAR 0 1
14814: RET
// export function TalkOff ; begin
14815: LD_INT 0
14817: PPUSH
// end ;
14818: LD_VAR 0 1
14822: RET
// export function add ( list , list1 ) ; begin
14823: LD_INT 0
14825: PPUSH
// if list = 0 then
14826: LD_VAR 0 1
14830: PUSH
14831: LD_INT 0
14833: EQUAL
14834: IFFALSE 14843
// list := [ ] ;
14836: LD_ADDR_VAR 0 1
14840: PUSH
14841: EMPTY
14842: ST_TO_ADDR
// if list1 = 0 then
14843: LD_VAR 0 2
14847: PUSH
14848: LD_INT 0
14850: EQUAL
14851: IFFALSE 14860
// list1 := [ ] ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: EMPTY
14859: ST_TO_ADDR
// result := list ^ list1 ;
14860: LD_ADDR_VAR 0 3
14864: PUSH
14865: LD_VAR 0 1
14869: PUSH
14870: LD_VAR 0 2
14874: ADD
14875: ST_TO_ADDR
// end ;
14876: LD_VAR 0 3
14880: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
14881: LD_INT 0
14883: PPUSH
14884: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
14885: LD_ADDR_VAR 0 8
14889: PUSH
14890: LD_VAR 0 1
14894: PPUSH
14895: LD_VAR 0 3
14899: PPUSH
14900: LD_VAR 0 4
14904: PPUSH
14905: LD_VAR 0 5
14909: PPUSH
14910: LD_VAR 0 6
14914: PPUSH
14915: CALL 14961 0 5
14919: ST_TO_ADDR
// if kdo then
14920: LD_VAR 0 8
14924: IFFALSE 14948
// result := Say ( kdo , ident ) else
14926: LD_ADDR_VAR 0 7
14930: PUSH
14931: LD_VAR 0 8
14935: PPUSH
14936: LD_VAR 0 2
14940: PPUSH
14941: CALL_OW 88
14945: ST_TO_ADDR
14946: GO 14956
// result := false ;
14948: LD_ADDR_VAR 0 7
14952: PUSH
14953: LD_INT 0
14955: ST_TO_ADDR
// end ;
14956: LD_VAR 0 7
14960: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
14961: LD_INT 0
14963: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
14964: LD_ADDR_VAR 0 1
14968: PUSH
14969: LD_VAR 0 1
14973: PPUSH
14974: LD_INT 21
14976: PUSH
14977: LD_INT 1
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: PUSH
14984: LD_INT 22
14986: PUSH
14987: LD_VAR 0 2
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 3
14998: PUSH
14999: LD_INT 23
15001: PUSH
15002: LD_INT 0
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: PPUSH
15015: CALL_OW 72
15019: ST_TO_ADDR
// if sex <> 0 then
15020: LD_VAR 0 3
15024: PUSH
15025: LD_INT 0
15027: NONEQUAL
15028: IFFALSE 15057
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
15030: LD_ADDR_VAR 0 1
15034: PUSH
15035: LD_VAR 0 1
15039: PPUSH
15040: LD_INT 26
15042: PUSH
15043: LD_VAR 0 3
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PPUSH
15052: CALL_OW 72
15056: ST_TO_ADDR
// if Hclass <> 0 then
15057: LD_VAR 0 4
15061: PUSH
15062: LD_INT 0
15064: NONEQUAL
15065: IFFALSE 15094
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
15067: LD_ADDR_VAR 0 1
15071: PUSH
15072: LD_VAR 0 1
15076: PPUSH
15077: LD_INT 25
15079: PUSH
15080: LD_VAR 0 4
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PPUSH
15089: CALL_OW 72
15093: ST_TO_ADDR
// if index <= 0 then
15094: LD_VAR 0 5
15098: PUSH
15099: LD_INT 0
15101: LESSEQUAL
15102: IFFALSE 15112
// index := 1 ;
15104: LD_ADDR_VAR 0 5
15108: PUSH
15109: LD_INT 1
15111: ST_TO_ADDR
// if lidi >= index then
15112: LD_VAR 0 1
15116: PUSH
15117: LD_VAR 0 5
15121: GREATEREQUAL
15122: IFFALSE 15142
// result := lidi [ index ] else
15124: LD_ADDR_VAR 0 6
15128: PUSH
15129: LD_VAR 0 1
15133: PUSH
15134: LD_VAR 0 5
15138: ARRAY
15139: ST_TO_ADDR
15140: GO 15150
// result := 0 ;
15142: LD_ADDR_VAR 0 6
15146: PUSH
15147: LD_INT 0
15149: ST_TO_ADDR
// end ;
15150: LD_VAR 0 6
15154: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
15155: LD_INT 0
15157: PPUSH
// if not hinty_co_byli then
15158: LD_EXP 66
15162: NOT
15163: IFFALSE 15172
// hinty_co_byli := [ ] ;
15165: LD_ADDR_EXP 66
15169: PUSH
15170: EMPTY
15171: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
15172: LD_VAR 0 1
15176: PUSH
15177: LD_EXP 66
15181: IN
15182: NOT
15183: IFFALSE 15210
// begin hinty_co_byli := hinty_co_byli ^ ident ;
15185: LD_ADDR_EXP 66
15189: PUSH
15190: LD_EXP 66
15194: PUSH
15195: LD_VAR 0 1
15199: ADD
15200: ST_TO_ADDR
// Hint ( ident ) ;
15201: LD_VAR 0 1
15205: PPUSH
15206: CALL_OW 339
// end ; end ; end_of_file
15210: LD_VAR 0 2
15214: RET
// every 0 0$2 + 0 0$0.1 do
15215: GO 15217
15217: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
15218: LD_INT 22
15220: PUSH
15221: LD_INT 1
15223: PUSH
15224: EMPTY
15225: LIST
15226: LIST
15227: PUSH
15228: LD_INT 2
15230: PUSH
15231: LD_INT 25
15233: PUSH
15234: LD_INT 12
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PUSH
15241: LD_INT 25
15243: PUSH
15244: LD_INT 16
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: LD_INT 25
15253: PUSH
15254: LD_INT 15
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: PUSH
15261: LD_INT 25
15263: PUSH
15264: LD_INT 17
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: LIST
15281: PPUSH
15282: CALL_OW 69
15286: PUSH
15287: LD_INT 22
15289: PUSH
15290: LD_INT 1
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PUSH
15297: LD_INT 21
15299: PUSH
15300: LD_INT 1
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: PUSH
15307: LD_INT 3
15309: PUSH
15310: LD_INT 2
15312: PUSH
15313: LD_INT 25
15315: PUSH
15316: LD_INT 12
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: PUSH
15323: LD_INT 25
15325: PUSH
15326: LD_INT 16
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 25
15335: PUSH
15336: LD_INT 15
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: LD_INT 25
15345: PUSH
15346: LD_INT 17
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: PUSH
15360: EMPTY
15361: LIST
15362: LIST
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: LIST
15368: PPUSH
15369: CALL_OW 69
15373: GREATER
15374: IFFALSE 15385
// begin SetAchievement ( ACH_POTA ) ;
15376: LD_STRING ACH_POTA
15378: PPUSH
15379: CALL_OW 543
// exit ;
15383: GO 15386
// end ; enable ;
15385: ENABLE
// end ;
15386: END
// export function SA_TamedAllApeman ; begin
15387: LD_INT 0
15389: PPUSH
// SetAchievement ( ACH_FDA ) ;
15390: LD_STRING ACH_FDA
15392: PPUSH
15393: CALL_OW 543
// end ;
15397: LD_VAR 0 1
15401: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) >= apemans_amount_on_start do
15402: LD_INT 22
15404: PUSH
15405: LD_INT 1
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: PUSH
15412: LD_INT 2
15414: PUSH
15415: LD_INT 25
15417: PUSH
15418: LD_INT 12
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PUSH
15425: LD_INT 25
15427: PUSH
15428: LD_INT 16
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL_OW 69
15448: PUSH
15449: LD_EXP 7
15453: GREATEREQUAL
15454: IFFALSE 15466
15456: GO 15458
15458: DISABLE
// SetAchievement ( ACH_FDA ) ; end_of_file
15459: LD_STRING ACH_FDA
15461: PPUSH
15462: CALL_OW 543
15466: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
15467: LD_INT 0
15469: PPUSH
15470: PPUSH
// if not missionNumber then
15471: LD_VAR 0 2
15475: NOT
15476: IFFALSE 15480
// exit ;
15478: GO 15581
// achiv := false ;
15480: LD_ADDR_VAR 0 7
15484: PUSH
15485: LD_INT 0
15487: ST_TO_ADDR
// case campaignNumber of 1 :
15488: LD_VAR 0 1
15492: PUSH
15493: LD_INT 1
15495: DOUBLE
15496: EQUAL
15497: IFTRUE 15501
15499: GO 15512
15501: POP
// achiv := ACH_GOTA ; 2 :
15502: LD_ADDR_VAR 0 7
15506: PUSH
15507: LD_STRING ACH_GOTA
15509: ST_TO_ADDR
15510: GO 15543
15512: LD_INT 2
15514: DOUBLE
15515: EQUAL
15516: IFTRUE 15520
15518: GO 15523
15520: POP
// ; 3 :
15521: GO 15543
15523: LD_INT 3
15525: DOUBLE
15526: EQUAL
15527: IFTRUE 15531
15529: GO 15542
15531: POP
// achiv := ACH_MOTRF ; end ;
15532: LD_ADDR_VAR 0 7
15536: PUSH
15537: LD_STRING ACH_MOTRF
15539: ST_TO_ADDR
15540: GO 15543
15542: POP
// if achiv and medal1 and medal2 and medal3 then
15543: LD_VAR 0 7
15547: PUSH
15548: LD_VAR 0 3
15552: AND
15553: PUSH
15554: LD_VAR 0 4
15558: AND
15559: PUSH
15560: LD_VAR 0 5
15564: AND
15565: IFFALSE 15581
// SetAchievementEX ( achiv , missionNumber ) ;
15567: LD_VAR 0 7
15571: PPUSH
15572: LD_VAR 0 2
15576: PPUSH
15577: CALL_OW 564
// end ;
15581: LD_VAR 0 6
15585: RET

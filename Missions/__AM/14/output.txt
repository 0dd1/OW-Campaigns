// export MacMillan , Powell , Joan , Lisa , Anezka ; export survivor , who_survive ; export truck1 , ukradle_auto ; export time_crates_us , time_crates_ru ; export other_survivors ; export on_optolab ; export you , russians , neutral ; export double_laser , double_hint ; export selected_opto_lab ; export veh_jmm , veh_surv ; export fastEscape ; export kappa_saved ; var russians_eliminated , doublelasers_turrets ; function prepare_units ; var un , i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
// uc_nation := nation_american ;
   5: LD_ADDR_OWVAR 21
   9: PUSH
  10: LD_INT 1
  12: ST_TO_ADDR
// uc_side := you ;
  13: LD_ADDR_OWVAR 20
  17: PUSH
  18: LD_EXP 14
  22: ST_TO_ADDR
// hc_class := class_soldier ;
  23: LD_ADDR_OWVAR 28
  27: PUSH
  28: LD_INT 1
  30: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_STRING JMM
  38: PPUSH
  39: CALL_OW 34
  43: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_STRING Powell
  51: PPUSH
  52: CALL_OW 25
  56: ST_TO_ADDR
// uc_side := neutral ;
  57: LD_ADDR_OWVAR 20
  61: PUSH
  62: LD_EXP 16
  66: ST_TO_ADDR
// if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) then
  67: LD_STRING Joan
  69: PPUSH
  70: CALL_OW 28
  74: PUSH
  75: LD_STRING Joan
  77: PPUSH
  78: CALL_OW 29
  82: AND
  83: IFFALSE 126
// begin hc_class := class_scientistic ;
  85: LD_ADDR_OWVAR 28
  89: PUSH
  90: LD_INT 4
  92: ST_TO_ADDR
// Joan := CreateCharacter ( Joan ) ;
  93: LD_ADDR_EXP 3
  97: PUSH
  98: LD_STRING Joan
 100: PPUSH
 101: CALL_OW 34
 105: ST_TO_ADDR
// survivor := Joan ;
 106: LD_ADDR_EXP 6
 110: PUSH
 111: LD_EXP 3
 115: ST_TO_ADDR
// who_survive := 1 ;
 116: LD_ADDR_EXP 7
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// end else
 124: GO 216
// if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
 126: LD_STRING Lisa
 128: PPUSH
 129: CALL_OW 28
 133: PUSH
 134: LD_STRING Lisa
 136: PPUSH
 137: CALL_OW 29
 141: AND
 142: IFFALSE 185
// begin hc_class := class_soldier ;
 144: LD_ADDR_OWVAR 28
 148: PUSH
 149: LD_INT 1
 151: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
 152: LD_ADDR_EXP 4
 156: PUSH
 157: LD_STRING Lisa
 159: PPUSH
 160: CALL_OW 34
 164: ST_TO_ADDR
// survivor := Lisa ;
 165: LD_ADDR_EXP 6
 169: PUSH
 170: LD_EXP 4
 174: ST_TO_ADDR
// who_survive := 2 ;
 175: LD_ADDR_EXP 7
 179: PUSH
 180: LD_INT 2
 182: ST_TO_ADDR
// end else
 183: GO 216
// begin Anezka := NewCharacter ( Coonie ) ;
 185: LD_ADDR_EXP 5
 189: PUSH
 190: LD_STRING Coonie
 192: PPUSH
 193: CALL_OW 25
 197: ST_TO_ADDR
// survivor := Anezka ;
 198: LD_ADDR_EXP 6
 202: PUSH
 203: LD_EXP 5
 207: ST_TO_ADDR
// who_survive := 3 ;
 208: LD_ADDR_EXP 7
 212: PUSH
 213: LD_INT 3
 215: ST_TO_ADDR
// end ; uc_side := you ;
 216: LD_ADDR_OWVAR 20
 220: PUSH
 221: LD_EXP 14
 225: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 226: LD_STRING other_survivors
 228: PPUSH
 229: CALL_OW 28
 233: IFFALSE 250
// other_survivors := CreateCharacterSet ( other_survivors ) else
 235: LD_ADDR_EXP 12
 239: PUSH
 240: LD_STRING other_survivors
 242: PPUSH
 243: CALL_OW 31
 247: ST_TO_ADDR
 248: GO 257
// other_survivors := [ ] ;
 250: LD_ADDR_EXP 12
 254: PUSH
 255: EMPTY
 256: ST_TO_ADDR
// uc_direction := 1 ;
 257: LD_ADDR_OWVAR 24
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// vc_chassis := us_morphling ;
 265: LD_ADDR_OWVAR 37
 269: PUSH
 270: LD_INT 5
 272: ST_TO_ADDR
// vc_control := control_manual ;
 273: LD_ADDR_OWVAR 38
 277: PUSH
 278: LD_INT 1
 280: ST_TO_ADDR
// vc_engine := engine_siberite ;
 281: LD_ADDR_OWVAR 39
 285: PUSH
 286: LD_INT 3
 288: ST_TO_ADDR
// vc_weapon := us_laser ;
 289: LD_ADDR_OWVAR 40
 293: PUSH
 294: LD_INT 9
 296: ST_TO_ADDR
// truck1 := CreateVehicle ;
 297: LD_ADDR_EXP 8
 301: PUSH
 302: CALL_OW 45
 306: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
 307: LD_ADDR_OWVAR 24
 311: PUSH
 312: LD_INT 0
 314: PPUSH
 315: LD_INT 5
 317: PPUSH
 318: CALL_OW 12
 322: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 323: LD_EXP 1
 327: PPUSH
 328: LD_EXP 8
 332: PPUSH
 333: CALL_OW 52
// uc_nation = nation_russian ;
 337: LD_ADDR_OWVAR 21
 341: PUSH
 342: LD_INT 3
 344: ST_TO_ADDR
// uc_side = russians ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_EXP 15
 354: ST_TO_ADDR
// PlaceUnitXY ( truck1 , 6 , 6 , false ) ;
 355: LD_EXP 8
 359: PPUSH
 360: LD_INT 6
 362: PPUSH
 363: LD_INT 6
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 48
// PlaceUnitXY ( survivor , 65 , 108 , false ) ;
 373: LD_EXP 6
 377: PPUSH
 378: LD_INT 65
 380: PPUSH
 381: LD_INT 108
 383: PPUSH
 384: LD_INT 0
 386: PPUSH
 387: CALL_OW 48
// ComFree ( [ MacMillan , survivor ] ) ;
 391: LD_EXP 1
 395: PUSH
 396: LD_EXP 6
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PPUSH
 405: CALL_OW 139
// end ;
 409: LD_VAR 0 1
 413: RET
// function prepare_sides ; begin
 414: LD_INT 0
 416: PPUSH
// you = 1 ;
 417: LD_ADDR_EXP 14
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// neutral = 4 ;
 425: LD_ADDR_EXP 16
 429: PUSH
 430: LD_INT 4
 432: ST_TO_ADDR
// russians = 3 ;
 433: LD_ADDR_EXP 15
 437: PUSH
 438: LD_INT 3
 440: ST_TO_ADDR
// visit_base := false ;
 441: LD_ADDR_EXP 34
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// on_optolab := false ;
 449: LD_ADDR_EXP 13
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// russians_eliminated := false ;
 457: LD_ADDR_LOC 1
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// double_laser := 0 ;
 465: LD_ADDR_EXP 17
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// double_hint := false ;
 473: LD_ADDR_EXP 18
 477: PUSH
 478: LD_INT 0
 480: ST_TO_ADDR
// doublelasers_turrets := [ ] ;
 481: LD_ADDR_LOC 2
 485: PUSH
 486: EMPTY
 487: ST_TO_ADDR
// selected_opto_lab := false ;
 488: LD_ADDR_EXP 19
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
 496: LD_EXP 14
 500: PPUSH
 501: LD_EXP 15
 505: PPUSH
 506: LD_INT 2
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
 516: LD_EXP 14
 520: PPUSH
 521: LD_EXP 16
 525: PPUSH
 526: LD_INT 1
 528: PPUSH
 529: LD_INT 1
 531: PPUSH
 532: CALL_OW 80
// enable ( 1 ) ;
 536: LD_INT 1
 538: ENABLE_MARKED
// disable ( 5 ) ;
 539: LD_INT 5
 541: DISABLE_MARKED
// disable ( 11 ) ;
 542: LD_INT 11
 544: DISABLE_MARKED
// end ;
 545: LD_VAR 0 1
 549: RET
// starting begin RandomizeAll ;
 550: CALL_OW 11
// fastEscape = 0 ;
 554: LD_ADDR_EXP 22
 558: PUSH
 559: LD_INT 0
 561: ST_TO_ADDR
// prepare_sides ;
 562: CALL 414 0 0
// prepare_units ;
 566: CALL 0 0 0
// starting_scene ;
 570: CALL 5369 0 0
// prepare_ru_base ;
 574: CALL 3008 0 0
// prepare_us_base ;
 578: CALL 8132 0 0
// ru_scientistic_priority ;
 582: CALL 8722 0 0
// startup_manufacturing ;
 586: CALL 10322 0 0
// startup_war_definition ;
 590: CALL 11755 0 0
// init_keep_base ;
 594: CALL 16971 0 0
// start_defend ;
 598: CALL 16369 0 0
// time_crates_us := Rand ( 0 0$20 , 0 0$40 ) ;
 602: LD_ADDR_EXP 10
 606: PUSH
 607: LD_INT 700
 609: PPUSH
 610: LD_INT 1400
 612: PPUSH
 613: CALL_OW 12
 617: ST_TO_ADDR
// time_crates_ru := Rand ( 0 0$30 , 0 0$60 ) ;
 618: LD_ADDR_EXP 11
 622: PUSH
 623: LD_INT 1050
 625: PPUSH
 626: LD_INT 2100
 628: PPUSH
 629: CALL_OW 12
 633: ST_TO_ADDR
// end ;
 634: END
// every 0 0$5 trigger TICK >= time_crates_us do
 635: LD_OWVAR 1
 639: PUSH
 640: LD_EXP 10
 644: GREATEREQUAL
 645: IFFALSE 694
 647: GO 649
 649: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 5 ) , inner_base , true ) ;
 650: LD_INT 2
 652: PPUSH
 653: LD_INT 5
 655: PPUSH
 656: CALL_OW 12
 660: PPUSH
 661: LD_INT 4
 663: PPUSH
 664: LD_INT 1
 666: PPUSH
 667: CALL_OW 55
// time_crates_us := TICK + Rand ( 0 0$60 , 0 0$100 ) ;
 671: LD_ADDR_EXP 10
 675: PUSH
 676: LD_OWVAR 1
 680: PUSH
 681: LD_INT 2100
 683: PPUSH
 684: LD_INT 3500
 686: PPUSH
 687: CALL_OW 12
 691: PLUS
 692: ST_TO_ADDR
// enable ;
 693: ENABLE
// end ;
 694: END
// every 0 0$5 trigger TICK >= time_crates_ru do
 695: LD_OWVAR 1
 699: PUSH
 700: LD_EXP 11
 704: GREATEREQUAL
 705: IFFALSE 754
 707: GO 709
 709: DISABLE
// begin CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
 710: LD_INT 3
 712: PPUSH
 713: LD_INT 5
 715: PPUSH
 716: CALL_OW 12
 720: PPUSH
 721: LD_INT 10
 723: PPUSH
 724: LD_INT 1
 726: PPUSH
 727: CALL_OW 55
// time_crates_ru := TICK + Rand ( 0 0$30 , 0 0$60 ) ;
 731: LD_ADDR_EXP 11
 735: PUSH
 736: LD_OWVAR 1
 740: PUSH
 741: LD_INT 1050
 743: PPUSH
 744: LD_INT 2100
 746: PPUSH
 747: CALL_OW 12
 751: PLUS
 752: ST_TO_ADDR
// enable ;
 753: ENABLE
// end ;
 754: END
// export function konec_mise ; var saved , un ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
// if IsOK ( MacMillan ) and not russians_eliminated then
 760: LD_EXP 1
 764: PPUSH
 765: CALL_OW 302
 769: PUSH
 770: LD_LOC 1
 774: NOT
 775: AND
 776: IFFALSE 874
// begin un := IsInUnit ( MacMillan ) ;
 778: LD_ADDR_VAR 0 3
 782: PUSH
 783: LD_EXP 1
 787: PPUSH
 788: CALL_OW 310
 792: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 793: LD_VAR 0 3
 797: PPUSH
 798: CALL_OW 247
 802: PUSH
 803: LD_INT 2
 805: EQUAL
 806: IFFALSE 859
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
 808: LD_ADDR_EXP 20
 812: PUSH
 813: LD_VAR 0 3
 817: PPUSH
 818: CALL_OW 265
 822: PUSH
 823: LD_VAR 0 3
 827: PPUSH
 828: CALL_OW 262
 832: PUSH
 833: LD_VAR 0 3
 837: PPUSH
 838: CALL_OW 263
 842: PUSH
 843: LD_VAR 0 3
 847: PPUSH
 848: CALL_OW 264
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 859: LD_VAR 0 3
 863: PPUSH
 864: CALL_OW 247
 868: PUSH
 869: LD_INT 2
 871: EQUAL
 872: IFFALSE 874
// end ; if IsDead ( MacMillan ) or ( GetLives ( MacMillan ) < 250 ) then
 874: LD_EXP 1
 878: PPUSH
 879: CALL_OW 301
 883: PUSH
 884: LD_EXP 1
 888: PPUSH
 889: CALL_OW 256
 893: PUSH
 894: LD_INT 250
 896: LESS
 897: OR
 898: IFFALSE 909
// begin YouLost ( JMM ) ;
 900: LD_STRING JMM
 902: PPUSH
 903: CALL_OW 104
// exit ;
 907: GO 1689
// end ; if ( GetLives ( survivor ) > 250 ) and visit_base then
 909: LD_EXP 6
 913: PPUSH
 914: CALL_OW 256
 918: PUSH
 919: LD_INT 250
 921: GREATER
 922: PUSH
 923: LD_EXP 34
 927: AND
 928: IFFALSE 944
// AddMedal ( protect , who_survive ) else
 930: LD_STRING protect
 932: PPUSH
 933: LD_EXP 7
 937: PPUSH
 938: CALL_OW 101
 942: GO 1016
// case who_survive of 1 :
 944: LD_EXP 7
 948: PUSH
 949: LD_INT 1
 951: DOUBLE
 952: EQUAL
 953: IFTRUE 957
 955: GO 971
 957: POP
// AddMedal ( protect , - 1 ) ; 2 :
 958: LD_STRING protect
 960: PPUSH
 961: LD_INT 1
 963: NEG
 964: PPUSH
 965: CALL_OW 101
 969: GO 1016
 971: LD_INT 2
 973: DOUBLE
 974: EQUAL
 975: IFTRUE 979
 977: GO 993
 979: POP
// AddMedal ( protect , - 2 ) ; 3 :
 980: LD_STRING protect
 982: PPUSH
 983: LD_INT 2
 985: NEG
 986: PPUSH
 987: CALL_OW 101
 991: GO 1016
 993: LD_INT 3
 995: DOUBLE
 996: EQUAL
 997: IFTRUE 1001
 999: GO 1015
1001: POP
// AddMedal ( protect , - 3 ) ; end ;
1002: LD_STRING protect
1004: PPUSH
1005: LD_INT 3
1007: NEG
1008: PPUSH
1009: CALL_OW 101
1013: GO 1016
1015: POP
// if ( GetLives ( survivor ) > 250 ) and visit_base then
1016: LD_EXP 6
1020: PPUSH
1021: CALL_OW 256
1025: PUSH
1026: LD_INT 250
1028: GREATER
1029: PUSH
1030: LD_EXP 34
1034: AND
1035: IFFALSE 1058
// saved := [ MacMillan , survivor ] else
1037: LD_ADDR_VAR 0 2
1041: PUSH
1042: LD_EXP 1
1046: PUSH
1047: LD_EXP 6
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: ST_TO_ADDR
1056: GO 1071
// saved := [ MacMillan ] ;
1058: LD_ADDR_VAR 0 2
1062: PUSH
1063: LD_EXP 1
1067: PUSH
1068: EMPTY
1069: LIST
1070: ST_TO_ADDR
// double_laser := double_laser + doublelasers_turrets ;
1071: LD_ADDR_EXP 17
1075: PUSH
1076: LD_EXP 17
1080: PUSH
1081: LD_LOC 2
1085: PLUS
1086: ST_TO_ADDR
// if visit_base then
1087: LD_EXP 34
1091: IFFALSE 1175
// begin if not selected_opto_lab then
1093: LD_EXP 19
1097: NOT
1098: IFFALSE 1113
// AddMedal ( double , - 1 ) else
1100: LD_STRING double
1102: PPUSH
1103: LD_INT 1
1105: NEG
1106: PPUSH
1107: CALL_OW 101
1111: GO 1173
// case double_laser of 0 :
1113: LD_EXP 17
1117: PUSH
1118: LD_INT 0
1120: DOUBLE
1121: EQUAL
1122: IFTRUE 1126
1124: GO 1140
1126: POP
// AddMedal ( double , - 2 ) ; 1 :
1127: LD_STRING double
1129: PPUSH
1130: LD_INT 2
1132: NEG
1133: PPUSH
1134: CALL_OW 101
1138: GO 1173
1140: LD_INT 1
1142: DOUBLE
1143: EQUAL
1144: IFTRUE 1148
1146: GO 1162
1148: POP
// AddMedal ( double , - 3 ) ; else
1149: LD_STRING double
1151: PPUSH
1152: LD_INT 3
1154: NEG
1155: PPUSH
1156: CALL_OW 101
1160: GO 1173
1162: POP
// Addmedal ( double , 1 ) ; end ;
1163: LD_STRING double
1165: PPUSH
1166: LD_INT 1
1168: PPUSH
1169: CALL_OW 101
// end else
1173: GO 1186
// AddMedal ( double , - 2 ) ;
1175: LD_STRING double
1177: PPUSH
1178: LD_INT 2
1180: NEG
1181: PPUSH
1182: CALL_OW 101
// if russians_eliminated then
1186: LD_LOC 1
1190: IFFALSE 1220
// begin AddMedal ( base , 1 ) ;
1192: LD_STRING base
1194: PPUSH
1195: LD_INT 1
1197: PPUSH
1198: CALL_OW 101
// GiveMedals ( Eliminate ) ;
1202: LD_STRING Eliminate
1204: PPUSH
1205: CALL_OW 102
// RewardPeople ( saved ) ;
1209: LD_VAR 0 2
1213: PPUSH
1214: CALL_OW 43
// end else
1218: GO 1267
// begin if not visit_base then
1220: LD_EXP 34
1224: NOT
1225: IFFALSE 1240
// AddMedal ( base , - 2 ) else
1227: LD_STRING base
1229: PPUSH
1230: LD_INT 2
1232: NEG
1233: PPUSH
1234: CALL_OW 101
1238: GO 1251
// AddMedal ( base , - 1 ) ;
1240: LD_STRING base
1242: PPUSH
1243: LD_INT 1
1245: NEG
1246: PPUSH
1247: CALL_OW 101
// GiveMedals ( Reach ) ;
1251: LD_STRING Reach
1253: PPUSH
1254: CALL_OW 102
// RewardPeople ( saved ) ;
1258: LD_VAR 0 2
1262: PPUSH
1263: CALL_OW 43
// end ; kappa_saved := false ;
1267: LD_ADDR_EXP 23
1271: PUSH
1272: LD_INT 0
1274: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1275: LD_EXP 1
1279: PPUSH
1280: LD_STRING JMM
1282: PPUSH
1283: CALL_OW 38
// if not visit_base then
1287: LD_EXP 34
1291: NOT
1292: IFFALSE 1303
// KillUnit ( survivor ) ;
1294: LD_EXP 6
1298: PPUSH
1299: CALL_OW 66
// case who_survive of 1 :
1303: LD_EXP 7
1307: PUSH
1308: LD_INT 1
1310: DOUBLE
1311: EQUAL
1312: IFTRUE 1316
1314: GO 1331
1316: POP
// SaveCharacters ( Joan , Joan ) ; 2 :
1317: LD_EXP 3
1321: PPUSH
1322: LD_STRING Joan
1324: PPUSH
1325: CALL_OW 38
1329: GO 1378
1331: LD_INT 2
1333: DOUBLE
1334: EQUAL
1335: IFTRUE 1339
1337: GO 1354
1339: POP
// SaveCharacters ( Lisa , Lisa ) ; 3 :
1340: LD_EXP 4
1344: PPUSH
1345: LD_STRING Lisa
1347: PPUSH
1348: CALL_OW 38
1352: GO 1378
1354: LD_INT 3
1356: DOUBLE
1357: EQUAL
1358: IFTRUE 1362
1360: GO 1377
1362: POP
// SaveCharacters ( Anezka , Coonie ) ; end ;
1363: LD_EXP 5
1367: PPUSH
1368: LD_STRING Coonie
1370: PPUSH
1371: CALL_OW 38
1375: GO 1378
1377: POP
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1378: LD_EXP 6
1382: PPUSH
1383: CALL_OW 256
1387: PUSH
1388: LD_INT 250
1390: GREATER
1391: PUSH
1392: LD_EXP 22
1396: PUSH
1397: LD_INT 0
1399: EQUAL
1400: AND
1401: IFFALSE 1420
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
1403: LD_EXP 6
1407: PPUSH
1408: CALL_OW 300
1412: PPUSH
1413: LD_STRING woman_saved
1415: PPUSH
1416: CALL_OW 39
// if [ GetSide ( survivor ) = 4 or IsDead ( survivor ) ] and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
1420: LD_EXP 6
1424: PPUSH
1425: CALL_OW 255
1429: PUSH
1430: LD_INT 4
1432: EQUAL
1433: PUSH
1434: LD_EXP 6
1438: PPUSH
1439: CALL_OW 301
1443: OR
1444: PUSH
1445: EMPTY
1446: LIST
1447: PUSH
1448: LD_INT 22
1450: PUSH
1451: LD_INT 3
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_INT 21
1460: PUSH
1461: LD_INT 1
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: PUSH
1468: LD_INT 50
1470: PUSH
1471: EMPTY
1472: LIST
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: PPUSH
1479: CALL_OW 69
1483: PUSH
1484: LD_INT 0
1486: GREATER
1487: AND
1488: PUSH
1489: LD_INT 22
1491: PUSH
1492: LD_INT 1
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 21
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PPUSH
1513: CALL_OW 69
1517: PUSH
1518: LD_INT 1
1520: EQUAL
1521: AND
1522: IFFALSE 1532
// kappa_saved = false ;
1524: LD_ADDR_EXP 23
1528: PUSH
1529: LD_INT 0
1531: ST_TO_ADDR
// if GetDistUnits ( IsInUnit ( survivor ) , IsInUnit ( Macmillan ) ) < 15 then
1532: LD_EXP 6
1536: PPUSH
1537: CALL_OW 310
1541: PPUSH
1542: LD_EXP 1
1546: PPUSH
1547: CALL_OW 310
1551: PPUSH
1552: CALL_OW 296
1556: PUSH
1557: LD_INT 15
1559: LESS
1560: IFFALSE 1570
// kappa_saved = true ;
1562: LD_ADDR_EXP 23
1566: PUSH
1567: LD_INT 1
1569: ST_TO_ADDR
// SaveVariable ( kappa_saved , kappa_saved ) ;
1570: LD_EXP 23
1574: PPUSH
1575: LD_STRING kappa_saved
1577: PPUSH
1578: CALL_OW 39
// SaveVariable ( visit_base , kappa_delayed ) ;
1582: LD_EXP 34
1586: PPUSH
1587: LD_STRING kappa_delayed
1589: PPUSH
1590: CALL_OW 39
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1594: LD_EXP 6
1598: PPUSH
1599: CALL_OW 256
1603: PUSH
1604: LD_INT 250
1606: GREATER
1607: PUSH
1608: LD_EXP 22
1612: PUSH
1613: LD_INT 0
1615: EQUAL
1616: AND
1617: IFFALSE 1642
// SaveVariable ( ( visit_base and IsOK ( survivor ) ) , woman_alive ) ;
1619: LD_EXP 34
1623: PUSH
1624: LD_EXP 6
1628: PPUSH
1629: CALL_OW 302
1633: AND
1634: PPUSH
1635: LD_STRING woman_alive
1637: PPUSH
1638: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
1642: LD_EXP 7
1646: PPUSH
1647: LD_STRING woman_in_am14
1649: PPUSH
1650: CALL_OW 39
// if not russians_eliminated then
1654: LD_LOC 1
1658: NOT
1659: IFFALSE 1685
// begin SaveVariable ( veh_jmm , veh_jmm ) ;
1661: LD_EXP 20
1665: PPUSH
1666: LD_STRING veh_jmm
1668: PPUSH
1669: CALL_OW 39
// SaveVariable ( veh_surv , veh_surv ) ;
1673: LD_EXP 21
1677: PPUSH
1678: LD_STRING veh_surv
1680: PPUSH
1681: CALL_OW 39
// end ; YouWin ;
1685: CALL_OW 103
// end ;
1689: LD_VAR 0 1
1693: RET
// function almost_done_macmillan ; var odpoved , vysledek , un ; begin
1694: LD_INT 0
1696: PPUSH
1697: PPUSH
1698: PPUSH
1699: PPUSH
// vysledek := true ;
1700: LD_ADDR_VAR 0 3
1704: PUSH
1705: LD_INT 1
1707: ST_TO_ADDR
// un := IsInUnit ( MacMillan ) ;
1708: LD_ADDR_VAR 0 4
1712: PUSH
1713: LD_EXP 1
1717: PPUSH
1718: CALL_OW 310
1722: ST_TO_ADDR
// if not IsOK ( survivor ) or ( IsInArea ( survivor , near_exit ) and IsInUnit ( survivor ) ) then
1723: LD_EXP 6
1727: PPUSH
1728: CALL_OW 302
1732: NOT
1733: PUSH
1734: LD_EXP 6
1738: PPUSH
1739: LD_INT 26
1741: PPUSH
1742: CALL_OW 308
1746: PUSH
1747: LD_EXP 6
1751: PPUSH
1752: CALL_OW 310
1756: AND
1757: OR
1758: IFFALSE 1841
// begin fastEscape = 1 ;
1760: LD_ADDR_EXP 22
1764: PUSH
1765: LD_INT 1
1767: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1768: LD_EXP 1
1772: PPUSH
1773: LD_STRING JMM
1775: PPUSH
1776: CALL_OW 38
// CheckSurvivorStatus ;
1780: CALL 2803 0 0
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1784: LD_ADDR_EXP 20
1788: PUSH
1789: LD_VAR 0 4
1793: PPUSH
1794: CALL_OW 265
1798: PUSH
1799: LD_VAR 0 4
1803: PPUSH
1804: CALL_OW 262
1808: PUSH
1809: LD_VAR 0 4
1813: PPUSH
1814: CALL_OW 263
1818: PUSH
1819: LD_VAR 0 4
1823: PPUSH
1824: CALL_OW 264
1828: PUSH
1829: EMPTY
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: ST_TO_ADDR
// konec_mise ;
1835: CALL 755 0 0
// end else
1839: GO 1919
// begin case who_survive of 1 :
1841: LD_EXP 7
1845: PUSH
1846: LD_INT 1
1848: DOUBLE
1849: EQUAL
1850: IFTRUE 1854
1852: GO 1870
1854: POP
// odpoved := Query ( Q3bJ ) ; 2 :
1855: LD_ADDR_VAR 0 2
1859: PUSH
1860: LD_STRING Q3bJ
1862: PPUSH
1863: CALL_OW 97
1867: ST_TO_ADDR
1868: GO 1919
1870: LD_INT 2
1872: DOUBLE
1873: EQUAL
1874: IFTRUE 1878
1876: GO 1894
1878: POP
// odpoved := Query ( Q3bL ) ; 3 :
1879: LD_ADDR_VAR 0 2
1883: PUSH
1884: LD_STRING Q3bL
1886: PPUSH
1887: CALL_OW 97
1891: ST_TO_ADDR
1892: GO 1919
1894: LD_INT 3
1896: DOUBLE
1897: EQUAL
1898: IFTRUE 1902
1900: GO 1918
1902: POP
// odpoved := Query ( Q3bX ) ; end ;
1903: LD_ADDR_VAR 0 2
1907: PUSH
1908: LD_STRING Q3bX
1910: PPUSH
1911: CALL_OW 97
1915: ST_TO_ADDR
1916: GO 1919
1918: POP
// end ; if odpoved = 1 then
1919: LD_VAR 0 2
1923: PUSH
1924: LD_INT 1
1926: EQUAL
1927: IFFALSE 1935
// konec_mise else
1929: CALL 755 0 0
1933: GO 1943
// vysledek := false ;
1935: LD_ADDR_VAR 0 3
1939: PUSH
1940: LD_INT 0
1942: ST_TO_ADDR
// result := vysledek ;
1943: LD_ADDR_VAR 0 1
1947: PUSH
1948: LD_VAR 0 3
1952: ST_TO_ADDR
// end ;
1953: LD_VAR 0 1
1957: RET
// function almost_done_survivor ; var odpoved , vysledek , un ; begin
1958: LD_INT 0
1960: PPUSH
1961: PPUSH
1962: PPUSH
1963: PPUSH
// odpoved := false ;
1964: LD_ADDR_VAR 0 2
1968: PUSH
1969: LD_INT 0
1971: ST_TO_ADDR
// vysledek := true ;
1972: LD_ADDR_VAR 0 3
1976: PUSH
1977: LD_INT 1
1979: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
1980: LD_ADDR_VAR 0 4
1984: PUSH
1985: LD_EXP 6
1989: PPUSH
1990: CALL_OW 310
1994: ST_TO_ADDR
// if IsOK ( MacMillan ) then
1995: LD_EXP 1
1999: PPUSH
2000: CALL_OW 302
2004: IFFALSE 2021
// odpoved := Query ( Q3b ) else
2006: LD_ADDR_VAR 0 2
2010: PUSH
2011: LD_STRING Q3b
2013: PPUSH
2014: CALL_OW 97
2018: ST_TO_ADDR
2019: GO 2029
// odpoved := true ;
2021: LD_ADDR_VAR 0 2
2025: PUSH
2026: LD_INT 1
2028: ST_TO_ADDR
// if odpoved then
2029: LD_VAR 0 2
2033: IFFALSE 2041
// begin CheckSurvivorStatus ;
2035: CALL 2803 0 0
// end else
2039: GO 2049
// vysledek := false ;
2041: LD_ADDR_VAR 0 3
2045: PUSH
2046: LD_INT 0
2048: ST_TO_ADDR
// result := vysledek ;
2049: LD_ADDR_VAR 0 1
2053: PUSH
2054: LD_VAR 0 3
2058: ST_TO_ADDR
// end ;
2059: LD_VAR 0 1
2063: RET
// every 0 0$2 trigger IsInArea ( MacMillan , exit_area ) do var odpoved ;
2064: LD_EXP 1
2068: PPUSH
2069: LD_INT 25
2071: PPUSH
2072: CALL_OW 308
2076: IFFALSE 2178
2078: GO 2080
2080: DISABLE
2081: LD_INT 0
2083: PPUSH
// begin if IsInUnit ( MacMillan ) then
2084: LD_EXP 1
2088: PPUSH
2089: CALL_OW 310
2093: IFFALSE 2137
// begin if not almost_done_macmillan then
2095: CALL 1694 0 0
2099: NOT
2100: IFFALSE 2135
// repeat wait ( 0 0$1 ) ;
2102: LD_INT 35
2104: PPUSH
2105: CALL_OW 67
// until not ( IsInArea ( MacMillan , exit_area ) and IsInUnit ( MacMillan ) ) ;
2109: LD_EXP 1
2113: PPUSH
2114: LD_INT 25
2116: PPUSH
2117: CALL_OW 308
2121: PUSH
2122: LD_EXP 1
2126: PPUSH
2127: CALL_OW 310
2131: AND
2132: NOT
2133: IFFALSE 2102
// end else
2135: GO 2177
// begin Query ( Q3a ) ;
2137: LD_STRING Q3a
2139: PPUSH
2140: CALL_OW 97
// repeat wait ( 0 0$1 ) ;
2144: LD_INT 35
2146: PPUSH
2147: CALL_OW 67
// until IsInUnit ( MacMillan ) or ( not IsInArea ( MacMillan , exit_area ) ) ;
2151: LD_EXP 1
2155: PPUSH
2156: CALL_OW 310
2160: PUSH
2161: LD_EXP 1
2165: PPUSH
2166: LD_INT 25
2168: PPUSH
2169: CALL_OW 308
2173: NOT
2174: OR
2175: IFFALSE 2144
// end ; enable ;
2177: ENABLE
// end ;
2178: PPOPN 1
2180: END
// every 0 0$2 trigger IsInArea ( survivor , exit_area ) do var odpoved , un ;
2181: LD_EXP 6
2185: PPUSH
2186: LD_INT 25
2188: PPUSH
2189: CALL_OW 308
2193: IFFALSE 2360
2195: GO 2197
2197: DISABLE
2198: LD_INT 0
2200: PPUSH
2201: PPUSH
// begin if IsInUnit ( survivor ) then
2202: LD_EXP 6
2206: PPUSH
2207: CALL_OW 310
2211: IFFALSE 2255
// begin if not almost_done_survivor then
2213: CALL 1958 0 0
2217: NOT
2218: IFFALSE 2253
// repeat wait ( 0 0$1 ) ;
2220: LD_INT 35
2222: PPUSH
2223: CALL_OW 67
// until not ( IsInArea ( survivor , exit_area ) and IsInUnit ( survivor ) ) ;
2227: LD_EXP 6
2231: PPUSH
2232: LD_INT 25
2234: PPUSH
2235: CALL_OW 308
2239: PUSH
2240: LD_EXP 6
2244: PPUSH
2245: CALL_OW 310
2249: AND
2250: NOT
2251: IFFALSE 2220
// end else
2253: GO 2348
// begin case who_survive of 1 :
2255: LD_EXP 7
2259: PUSH
2260: LD_INT 1
2262: DOUBLE
2263: EQUAL
2264: IFTRUE 2268
2266: GO 2278
2268: POP
// Query ( Q3aJ ) ; 2 :
2269: LD_STRING Q3aJ
2271: PPUSH
2272: CALL_OW 97
2276: GO 2315
2278: LD_INT 2
2280: DOUBLE
2281: EQUAL
2282: IFTRUE 2286
2284: GO 2296
2286: POP
// Query ( Q3aL ) ; 3 :
2287: LD_STRING Q3aL
2289: PPUSH
2290: CALL_OW 97
2294: GO 2315
2296: LD_INT 3
2298: DOUBLE
2299: EQUAL
2300: IFTRUE 2304
2302: GO 2314
2304: POP
// Query ( Q3aX ) ; end ;
2305: LD_STRING Q3aX
2307: PPUSH
2308: CALL_OW 97
2312: GO 2315
2314: POP
// repeat wait ( 0 0$1 ) ;
2315: LD_INT 35
2317: PPUSH
2318: CALL_OW 67
// until IsInUnit ( survivor ) or ( not IsInArea ( survivor , exit_area ) ) ;
2322: LD_EXP 6
2326: PPUSH
2327: CALL_OW 310
2331: PUSH
2332: LD_EXP 6
2336: PPUSH
2337: LD_INT 25
2339: PPUSH
2340: CALL_OW 308
2344: NOT
2345: OR
2346: IFFALSE 2315
// end ; if IsLive ( survivor ) then
2348: LD_EXP 6
2352: PPUSH
2353: CALL_OW 300
2357: IFFALSE 2360
// enable ;
2359: ENABLE
// end ;
2360: PPOPN 2
2362: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do var vozidla , lide ;
2363: LD_INT 22
2365: PUSH
2366: LD_EXP 15
2370: PUSH
2371: EMPTY
2372: LIST
2373: LIST
2374: PUSH
2375: LD_INT 2
2377: PUSH
2378: LD_INT 30
2380: PUSH
2381: LD_INT 0
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: PUSH
2388: LD_INT 30
2390: PUSH
2391: LD_INT 1
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 69
2411: NOT
2412: IFFALSE 2665
2414: GO 2416
2416: DISABLE
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
// begin repeat vozidla := FilterAllUnits ( [ [ f_side , russians ] , [ [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] , [ f_ok ] ] ) ;
2421: LD_ADDR_VAR 0 1
2425: PUSH
2426: LD_INT 22
2428: PUSH
2429: LD_EXP 15
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: PUSH
2438: LD_INT 21
2440: PUSH
2441: LD_INT 2
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PUSH
2448: LD_INT 33
2450: PUSH
2451: LD_INT 3
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 50
2464: PUSH
2465: EMPTY
2466: LIST
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: LIST
2472: PPUSH
2473: CALL_OW 69
2477: ST_TO_ADDR
// lide := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
2478: LD_ADDR_VAR 0 2
2482: PUSH
2483: LD_INT 22
2485: PUSH
2486: LD_EXP 15
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: LD_INT 21
2497: PUSH
2498: LD_INT 1
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: PUSH
2505: LD_INT 50
2507: PUSH
2508: EMPTY
2509: LIST
2510: PUSH
2511: EMPTY
2512: LIST
2513: LIST
2514: LIST
2515: PPUSH
2516: CALL_OW 69
2520: ST_TO_ADDR
// if not ( lide or vozidla ) then
2521: LD_VAR 0 2
2525: PUSH
2526: LD_VAR 0 1
2530: OR
2531: NOT
2532: IFFALSE 2542
// russians_eliminated := true ;
2534: LD_ADDR_LOC 1
2538: PUSH
2539: LD_INT 1
2541: ST_TO_ADDR
// wait ( 0 0$1 ) ;
2542: LD_INT 35
2544: PPUSH
2545: CALL_OW 67
// until IsOk ( MacMillan ) and russians_eliminated ;
2549: LD_EXP 1
2553: PPUSH
2554: CALL_OW 302
2558: PUSH
2559: LD_LOC 1
2563: AND
2564: IFFALSE 2421
// DialogueOn ;
2566: CALL_OW 6
// Say ( MacMillan , DEnd-JMM-1 ) ;
2570: LD_EXP 1
2574: PPUSH
2575: LD_STRING DEnd-JMM-1
2577: PPUSH
2578: CALL_OW 88
// case who_survive of 1 :
2582: LD_EXP 7
2586: PUSH
2587: LD_INT 1
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2595
2593: GO 2610
2595: POP
// Say ( Joan , DEnd-Joan-1 ) ; 2 :
2596: LD_EXP 3
2600: PPUSH
2601: LD_STRING DEnd-Joan-1
2603: PPUSH
2604: CALL_OW 88
2608: GO 2657
2610: LD_INT 2
2612: DOUBLE
2613: EQUAL
2614: IFTRUE 2618
2616: GO 2633
2618: POP
// Say ( Lisa , DEnd-Lisa-1 ) ; 3 :
2619: LD_EXP 4
2623: PPUSH
2624: LD_STRING DEnd-Lisa-1
2626: PPUSH
2627: CALL_OW 88
2631: GO 2657
2633: LD_INT 3
2635: DOUBLE
2636: EQUAL
2637: IFTRUE 2641
2639: GO 2656
2641: POP
// Say ( Anezka , DEnd-Con-1 ) ; end ;
2642: LD_EXP 5
2646: PPUSH
2647: LD_STRING DEnd-Con-1
2649: PPUSH
2650: CALL_OW 88
2654: GO 2657
2656: POP
// DialogueOff ;
2657: CALL_OW 7
// konec_mise ;
2661: CALL 755 0 0
// end ;
2665: PPOPN 2
2667: END
// every 0 0$3 do var un , list ;
2668: GO 2670
2670: DISABLE
2671: LD_INT 0
2673: PPUSH
2674: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
2675: LD_ADDR_VAR 0 2
2679: PUSH
2680: LD_INT 22
2682: PUSH
2683: LD_EXP 14
2687: PUSH
2688: EMPTY
2689: LIST
2690: LIST
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: LD_INT 30
2697: PUSH
2698: LD_INT 32
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PUSH
2705: LD_INT 30
2707: PUSH
2708: LD_INT 33
2710: PUSH
2711: EMPTY
2712: LIST
2713: LIST
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL_OW 69
2728: ST_TO_ADDR
// for un in list do
2729: LD_ADDR_VAR 0 1
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: FOR_IN
2740: IFFALSE 2797
// if GetBWeapon ( un ) = us_double_laser then
2742: LD_VAR 0 1
2746: PPUSH
2747: CALL_OW 269
2751: PUSH
2752: LD_INT 10
2754: EQUAL
2755: IFFALSE 2795
// begin if not double_hint then
2757: LD_EXP 18
2761: NOT
2762: IFFALSE 2779
// begin Hint ( DoubleLaser ) ;
2764: LD_STRING DoubleLaser
2766: PPUSH
2767: CALL_OW 339
// double_hint := true ;
2771: LD_ADDR_EXP 18
2775: PUSH
2776: LD_INT 1
2778: ST_TO_ADDR
// end ; doublelasers_turrets := doublelasers_turrets union un ;
2779: LD_ADDR_LOC 2
2783: PUSH
2784: LD_LOC 2
2788: PUSH
2789: LD_VAR 0 1
2793: UNION
2794: ST_TO_ADDR
// end ;
2795: GO 2739
2797: POP
2798: POP
// enable ;
2799: ENABLE
// end ;
2800: PPOPN 2
2802: END
// export function CheckSurvivorStatus ; var un ; begin
2803: LD_INT 0
2805: PPUSH
2806: PPUSH
// if IsOK ( survivor ) then
2807: LD_EXP 6
2811: PPUSH
2812: CALL_OW 302
2816: IFFALSE 3003
// begin repeat un := IsInUnit ( survivor ) ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_EXP 6
2827: PPUSH
2828: CALL_OW 310
2832: ST_TO_ADDR
// ComMoveXY ( survivor , 147 , 16 ) ;
2833: LD_EXP 6
2837: PPUSH
2838: LD_INT 147
2840: PPUSH
2841: LD_INT 16
2843: PPUSH
2844: CALL_OW 111
// wait ( 0 0$1 ) ;
2848: LD_INT 35
2850: PPUSH
2851: CALL_OW 67
// until IsInArea ( survivor , exit_area ) or IsInArea ( un , exit_area ) ;
2855: LD_EXP 6
2859: PPUSH
2860: LD_INT 25
2862: PPUSH
2863: CALL_OW 308
2867: PUSH
2868: LD_VAR 0 2
2872: PPUSH
2873: LD_INT 25
2875: PPUSH
2876: CALL_OW 308
2880: OR
2881: IFFALSE 2818
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
2883: LD_EXP 6
2887: PPUSH
2888: CALL_OW 300
2892: PPUSH
2893: LD_STRING woman_saved
2895: PPUSH
2896: CALL_OW 39
// SaveVariable ( IsLive ( survivor ) , woman_alive ) ;
2900: LD_EXP 6
2904: PPUSH
2905: CALL_OW 300
2909: PPUSH
2910: LD_STRING woman_alive
2912: PPUSH
2913: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
2917: LD_EXP 7
2921: PPUSH
2922: LD_STRING woman_in_am14
2924: PPUSH
2925: CALL_OW 39
// kappa_saved = 1 ;
2929: LD_ADDR_EXP 23
2933: PUSH
2934: LD_INT 1
2936: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
2937: LD_ADDR_VAR 0 2
2941: PUSH
2942: LD_EXP 6
2946: PPUSH
2947: CALL_OW 310
2951: ST_TO_ADDR
// veh_surv := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
2952: LD_ADDR_EXP 21
2956: PUSH
2957: LD_VAR 0 2
2961: PPUSH
2962: CALL_OW 265
2966: PUSH
2967: LD_VAR 0 2
2971: PPUSH
2972: CALL_OW 262
2976: PUSH
2977: LD_VAR 0 2
2981: PPUSH
2982: CALL_OW 263
2986: PUSH
2987: LD_VAR 0 2
2991: PPUSH
2992: CALL_OW 264
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: LIST
3002: ST_TO_ADDR
// end ; end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export ru_ing , ru_sol , ru_sci , ru_mec ; export russians_forces ; export ru_collector ; export checking ; export reserved_people ; export function prepare_ru_base ; var un , i , num_sol , num_ing , num_sci , num_mec , lev ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
// RevealFogArea ( russians , ru_crates ) ;
3018: LD_EXP 15
3022: PPUSH
3023: LD_INT 10
3025: PPUSH
3026: CALL_OW 332
// num_ing := [ 1 , 2 , 2 ] [ difficulty ] ;
3030: LD_ADDR_VAR 0 5
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 2
3040: PUSH
3041: LD_INT 2
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: PUSH
3049: LD_OWVAR 67
3053: ARRAY
3054: ST_TO_ADDR
// num_sol := [ 2 , 2 , 3 ] [ difficulty ] ;
3055: LD_ADDR_VAR 0 4
3059: PUSH
3060: LD_INT 2
3062: PUSH
3063: LD_INT 2
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: PUSH
3074: LD_OWVAR 67
3078: ARRAY
3079: ST_TO_ADDR
// num_sci := [ 1 , 3 , 6 ] [ difficulty ] ;
3080: LD_ADDR_VAR 0 6
3084: PUSH
3085: LD_INT 1
3087: PUSH
3088: LD_INT 3
3090: PUSH
3091: LD_INT 6
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: ST_TO_ADDR
// num_mec := [ 2 , 2 , 4 ] [ difficulty ] ;
3105: LD_ADDR_VAR 0 7
3109: PUSH
3110: LD_INT 2
3112: PUSH
3113: LD_INT 2
3115: PUSH
3116: LD_INT 4
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: PUSH
3124: LD_OWVAR 67
3128: ARRAY
3129: ST_TO_ADDR
// lev := [ 6 , 8 , 10 ] [ difficulty ] ;
3130: LD_ADDR_VAR 0 8
3134: PUSH
3135: LD_INT 6
3137: PUSH
3138: LD_INT 8
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_OWVAR 67
3153: ARRAY
3154: ST_TO_ADDR
// russians_forces := [ ] ;
3155: LD_ADDR_EXP 28
3159: PUSH
3160: EMPTY
3161: ST_TO_ADDR
// ru_ing := [ ] ;
3162: LD_ADDR_EXP 24
3166: PUSH
3167: EMPTY
3168: ST_TO_ADDR
// ru_sol := [ ] ;
3169: LD_ADDR_EXP 25
3173: PUSH
3174: EMPTY
3175: ST_TO_ADDR
// ru_sci := [ ] ;
3176: LD_ADDR_EXP 26
3180: PUSH
3181: EMPTY
3182: ST_TO_ADDR
// ru_mec := [ ] ;
3183: LD_ADDR_EXP 27
3187: PUSH
3188: EMPTY
3189: ST_TO_ADDR
// reserved_people := [ ] ;
3190: LD_ADDR_EXP 31
3194: PUSH
3195: EMPTY
3196: ST_TO_ADDR
// uc_nation = nation_russian ;
3197: LD_ADDR_OWVAR 21
3201: PUSH
3202: LD_INT 3
3204: ST_TO_ADDR
// uc_side = russians ;
3205: LD_ADDR_OWVAR 20
3209: PUSH
3210: LD_EXP 15
3214: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
3215: LD_ADDR_OWVAR 24
3219: PUSH
3220: LD_INT 0
3222: PPUSH
3223: LD_INT 5
3225: PPUSH
3226: CALL_OW 12
3230: ST_TO_ADDR
// hc_gallery :=  ;
3231: LD_ADDR_OWVAR 33
3235: PUSH
3236: LD_STRING 
3238: ST_TO_ADDR
// hc_name :=  ;
3239: LD_ADDR_OWVAR 26
3243: PUSH
3244: LD_STRING 
3246: ST_TO_ADDR
// hc_importance := 0 ;
3247: LD_ADDR_OWVAR 32
3251: PUSH
3252: LD_INT 0
3254: ST_TO_ADDR
// for i := 1 to num_ing do
3255: LD_ADDR_VAR 0 3
3259: PUSH
3260: DOUBLE
3261: LD_INT 1
3263: DEC
3264: ST_TO_ADDR
3265: LD_VAR 0 5
3269: PUSH
3270: FOR_TO
3271: IFFALSE 3379
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3273: LD_ADDR_OWVAR 36
3277: PUSH
3278: LD_INT 2
3280: PPUSH
3281: LD_INT 5
3283: PPUSH
3284: CALL_OW 12
3288: ST_TO_ADDR
// PrepareEngineer ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3289: LD_INT 2
3291: PPUSH
3292: LD_INT 4
3294: PPUSH
3295: CALL_OW 12
3299: PUSH
3300: LD_INT 2
3302: MOD
3303: PUSH
3304: LD_INT 1
3306: PLUS
3307: PPUSH
3308: LD_VAR 0 8
3312: PUSH
3313: LD_INT 0
3315: PPUSH
3316: LD_INT 3
3318: PPUSH
3319: CALL_OW 12
3323: PLUS
3324: PPUSH
3325: CALL_OW 382
// un := CreateHuman ;
3329: LD_ADDR_VAR 0 2
3333: PUSH
3334: CALL_OW 44
3338: ST_TO_ADDR
// ru_ing := ru_ing ^ un ;
3339: LD_ADDR_EXP 24
3343: PUSH
3344: LD_EXP 24
3348: PUSH
3349: LD_VAR 0 2
3353: ADD
3354: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3355: LD_VAR 0 2
3359: PPUSH
3360: LD_INT 8
3362: PPUSH
3363: LD_INT 0
3365: PPUSH
3366: CALL_OW 49
// wait ( 1 ) ;
3370: LD_INT 1
3372: PPUSH
3373: CALL_OW 67
// end ;
3377: GO 3270
3379: POP
3380: POP
// for i := 1 to num_sol do
3381: LD_ADDR_VAR 0 3
3385: PUSH
3386: DOUBLE
3387: LD_INT 1
3389: DEC
3390: ST_TO_ADDR
3391: LD_VAR 0 4
3395: PUSH
3396: FOR_TO
3397: IFFALSE 3505
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3399: LD_ADDR_OWVAR 36
3403: PUSH
3404: LD_INT 2
3406: PPUSH
3407: LD_INT 5
3409: PPUSH
3410: CALL_OW 12
3414: ST_TO_ADDR
// PrepareSoldier ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3415: LD_INT 2
3417: PPUSH
3418: LD_INT 4
3420: PPUSH
3421: CALL_OW 12
3425: PUSH
3426: LD_INT 2
3428: MOD
3429: PUSH
3430: LD_INT 1
3432: PLUS
3433: PPUSH
3434: LD_VAR 0 8
3438: PUSH
3439: LD_INT 0
3441: PPUSH
3442: LD_INT 3
3444: PPUSH
3445: CALL_OW 12
3449: PLUS
3450: PPUSH
3451: CALL_OW 381
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 2
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// ru_sol := ru_sol ^ un ;
3465: LD_ADDR_EXP 25
3469: PUSH
3470: LD_EXP 25
3474: PUSH
3475: LD_VAR 0 2
3479: ADD
3480: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3481: LD_VAR 0 2
3485: PPUSH
3486: LD_INT 8
3488: PPUSH
3489: LD_INT 0
3491: PPUSH
3492: CALL_OW 49
// wait ( 1 ) ;
3496: LD_INT 1
3498: PPUSH
3499: CALL_OW 67
// end ;
3503: GO 3396
3505: POP
3506: POP
// for i := 1 to num_sci do
3507: LD_ADDR_VAR 0 3
3511: PUSH
3512: DOUBLE
3513: LD_INT 1
3515: DEC
3516: ST_TO_ADDR
3517: LD_VAR 0 6
3521: PUSH
3522: FOR_TO
3523: IFFALSE 3631
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3525: LD_ADDR_OWVAR 36
3529: PUSH
3530: LD_INT 2
3532: PPUSH
3533: LD_INT 5
3535: PPUSH
3536: CALL_OW 12
3540: ST_TO_ADDR
// PrepareScientist ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3541: LD_INT 2
3543: PPUSH
3544: LD_INT 4
3546: PPUSH
3547: CALL_OW 12
3551: PUSH
3552: LD_INT 2
3554: MOD
3555: PUSH
3556: LD_INT 1
3558: PLUS
3559: PPUSH
3560: LD_VAR 0 8
3564: PUSH
3565: LD_INT 0
3567: PPUSH
3568: LD_INT 3
3570: PPUSH
3571: CALL_OW 12
3575: PLUS
3576: PPUSH
3577: CALL_OW 384
// un := CreateHuman ;
3581: LD_ADDR_VAR 0 2
3585: PUSH
3586: CALL_OW 44
3590: ST_TO_ADDR
// ru_sci := ru_sci ^ un ;
3591: LD_ADDR_EXP 26
3595: PUSH
3596: LD_EXP 26
3600: PUSH
3601: LD_VAR 0 2
3605: ADD
3606: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 8
3614: PPUSH
3615: LD_INT 0
3617: PPUSH
3618: CALL_OW 49
// wait ( 1 ) ;
3622: LD_INT 1
3624: PPUSH
3625: CALL_OW 67
// end ;
3629: GO 3522
3631: POP
3632: POP
// for i := 1 to num_mec do
3633: LD_ADDR_VAR 0 3
3637: PUSH
3638: DOUBLE
3639: LD_INT 1
3641: DEC
3642: ST_TO_ADDR
3643: LD_VAR 0 7
3647: PUSH
3648: FOR_TO
3649: IFFALSE 3757
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3651: LD_ADDR_OWVAR 36
3655: PUSH
3656: LD_INT 2
3658: PPUSH
3659: LD_INT 5
3661: PPUSH
3662: CALL_OW 12
3666: ST_TO_ADDR
// PrepareMechanic ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3667: LD_INT 2
3669: PPUSH
3670: LD_INT 4
3672: PPUSH
3673: CALL_OW 12
3677: PUSH
3678: LD_INT 2
3680: MOD
3681: PUSH
3682: LD_INT 1
3684: PLUS
3685: PPUSH
3686: LD_VAR 0 8
3690: PUSH
3691: LD_INT 0
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: CALL_OW 12
3701: PLUS
3702: PPUSH
3703: CALL_OW 383
// un := CreateHuman ;
3707: LD_ADDR_VAR 0 2
3711: PUSH
3712: CALL_OW 44
3716: ST_TO_ADDR
// ru_mec := ru_mec ^ un ;
3717: LD_ADDR_EXP 27
3721: PUSH
3722: LD_EXP 27
3726: PUSH
3727: LD_VAR 0 2
3731: ADD
3732: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_INT 8
3740: PPUSH
3741: LD_INT 0
3743: PPUSH
3744: CALL_OW 49
// wait ( 1 ) ;
3748: LD_INT 1
3750: PPUSH
3751: CALL_OW 67
// end ;
3755: GO 3648
3757: POP
3758: POP
// russians_forces := ru_ing ^ ru_sol ^ ru_sci ^ ru_mec ;
3759: LD_ADDR_EXP 28
3763: PUSH
3764: LD_EXP 24
3768: PUSH
3769: LD_EXP 25
3773: ADD
3774: PUSH
3775: LD_EXP 26
3779: ADD
3780: PUSH
3781: LD_EXP 27
3785: ADD
3786: ST_TO_ADDR
// i := 1 ;
3787: LD_ADDR_VAR 0 3
3791: PUSH
3792: LD_INT 1
3794: ST_TO_ADDR
// for un in ru_mec do
3795: LD_ADDR_VAR 0 2
3799: PUSH
3800: LD_EXP 27
3804: PUSH
3805: FOR_IN
3806: IFFALSE 3871
// begin if ( i mod 2 ) = 0 then
3808: LD_VAR 0 3
3812: PUSH
3813: LD_INT 2
3815: MOD
3816: PUSH
3817: LD_INT 0
3819: EQUAL
3820: IFFALSE 3836
// ComEnterUnit ( un , ru_fact2 ) else
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 40
3829: PPUSH
3830: CALL_OW 120
3834: GO 3848
// ComEnterUnit ( un , ru_fact1 ) ;
3836: LD_VAR 0 2
3840: PPUSH
3841: LD_INT 1
3843: PPUSH
3844: CALL_OW 120
// i := i + 1 ;
3848: LD_ADDR_VAR 0 3
3852: PUSH
3853: LD_VAR 0 3
3857: PUSH
3858: LD_INT 1
3860: PLUS
3861: ST_TO_ADDR
// wait ( 1 ) ;
3862: LD_INT 1
3864: PPUSH
3865: CALL_OW 67
// end ;
3869: GO 3805
3871: POP
3872: POP
// for un in ru_sci do
3873: LD_ADDR_VAR 0 2
3877: PUSH
3878: LD_EXP 26
3882: PUSH
3883: FOR_IN
3884: IFFALSE 3935
// begin if ( un mod 2 ) = 0 then
3886: LD_VAR 0 2
3890: PUSH
3891: LD_INT 2
3893: MOD
3894: PUSH
3895: LD_INT 0
3897: EQUAL
3898: IFFALSE 3914
// ComEnterUnit ( un , ru_lab1 ) else
3900: LD_VAR 0 2
3904: PPUSH
3905: LD_INT 14
3907: PPUSH
3908: CALL_OW 120
3912: GO 3926
// ComEnterunit ( un , ru_lab2 ) ;
3914: LD_VAR 0 2
3918: PPUSH
3919: LD_INT 15
3921: PPUSH
3922: CALL_OW 120
// wait ( 1 ) ;
3926: LD_INT 1
3928: PPUSH
3929: CALL_OW 67
// end ;
3933: GO 3883
3935: POP
3936: POP
// uc_direction := Rand ( 0 , 5 ) ;
3937: LD_ADDR_OWVAR 24
3941: PUSH
3942: LD_INT 0
3944: PPUSH
3945: LD_INT 5
3947: PPUSH
3948: CALL_OW 12
3952: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
3953: LD_ADDR_OWVAR 37
3957: PUSH
3958: LD_INT 21
3960: ST_TO_ADDR
// vc_control := control_manual ;
3961: LD_ADDR_OWVAR 38
3965: PUSH
3966: LD_INT 1
3968: ST_TO_ADDR
// vc_engine := engine_combustion ;
3969: LD_ADDR_OWVAR 39
3973: PUSH
3974: LD_INT 1
3976: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
3977: LD_ADDR_OWVAR 40
3981: PUSH
3982: LD_INT 51
3984: ST_TO_ADDR
// ru_collector := CreateVehicle ;
3985: LD_ADDR_EXP 29
3989: PUSH
3990: CALL_OW 45
3994: ST_TO_ADDR
// PlaceUnitXYR ( ru_collector , ShiftX ( GetX ( ru_depot ) , 4 , 5 ) , GetY ( ru_depot ) , 5 , false ) ;
3995: LD_EXP 29
3999: PPUSH
4000: LD_INT 22
4002: PPUSH
4003: CALL_OW 250
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 5
4013: PPUSH
4014: CALL_OW 272
4018: PPUSH
4019: LD_INT 22
4021: PPUSH
4022: CALL_OW 251
4026: PPUSH
4027: LD_INT 5
4029: PPUSH
4030: LD_INT 0
4032: PPUSH
4033: CALL_OW 50
// end ;
4037: LD_VAR 0 1
4041: RET
// export crate_list ; every 0 0$5 trigger GetListOfCratesInArea ( ru_crates ) do var un , free_unit , x , y , max , i , clear_crates , old_class , attempt ;
4042: LD_INT 10
4044: PPUSH
4045: CALL_OW 435
4049: IFFALSE 4897
4051: GO 4053
4053: DISABLE
4054: LD_INT 0
4056: PPUSH
4057: PPUSH
4058: PPUSH
4059: PPUSH
4060: PPUSH
4061: PPUSH
4062: PPUSH
4063: PPUSH
4064: PPUSH
// begin crate_list := GetListOfCratesInArea ( ru_crates ) ;
4065: LD_ADDR_EXP 32
4069: PUSH
4070: LD_INT 10
4072: PPUSH
4073: CALL_OW 435
4077: ST_TO_ADDR
// free_unit := false ;
4078: LD_ADDR_VAR 0 2
4082: PUSH
4083: LD_INT 0
4085: ST_TO_ADDR
// i := russians_forces diff reserved_people ;
4086: LD_ADDR_VAR 0 6
4090: PUSH
4091: LD_EXP 28
4095: PUSH
4096: LD_EXP 31
4100: DIFF
4101: ST_TO_ADDR
// for un in i do
4102: LD_ADDR_VAR 0 1
4106: PUSH
4107: LD_VAR 0 6
4111: PUSH
4112: FOR_IN
4113: IFFALSE 4152
// begin if not ( HasTask ( un ) or GetUnitMc ( un ) ) then
4115: LD_VAR 0 1
4119: PPUSH
4120: CALL_OW 314
4124: PUSH
4125: LD_VAR 0 1
4129: PPUSH
4130: CALL_OW 388
4134: OR
4135: NOT
4136: IFFALSE 4150
// begin free_unit := un ;
4138: LD_ADDR_VAR 0 2
4142: PUSH
4143: LD_VAR 0 1
4147: ST_TO_ADDR
// break ;
4148: GO 4152
// end ; end ;
4150: GO 4112
4152: POP
4153: POP
// if free_unit and IsOK ( free_unit ) then
4154: LD_VAR 0 2
4158: PUSH
4159: LD_VAR 0 2
4163: PPUSH
4164: CALL_OW 302
4168: AND
4169: IFFALSE 4896
// begin reserved_people := reserved_people ^ free_unit ;
4171: LD_ADDR_EXP 31
4175: PUSH
4176: LD_EXP 31
4180: PUSH
4181: LD_VAR 0 2
4185: ADD
4186: ST_TO_ADDR
// ComRemember ( free_unit ) ;
4187: LD_VAR 0 2
4191: PPUSH
4192: CALL_OW 143
// if IsLive ( ru_collector ) then
4196: LD_EXP 29
4200: PPUSH
4201: CALL_OW 300
4205: IFFALSE 4351
// begin repeat ComEnterUnit ( free_unit , ru_collector ) ;
4207: LD_VAR 0 2
4211: PPUSH
4212: LD_EXP 29
4216: PPUSH
4217: CALL_OW 120
// wait ( 0 0$1 ) ;
4221: LD_INT 35
4223: PPUSH
4224: CALL_OW 67
// until ( IsInUnit ( free_unit ) ) or not IsLive ( ru_collector ) ;
4228: LD_VAR 0 2
4232: PPUSH
4233: CALL_OW 310
4237: PUSH
4238: LD_EXP 29
4242: PPUSH
4243: CALL_OW 300
4247: NOT
4248: OR
4249: IFFALSE 4207
// if not IsLive ( ru_collector ) then
4251: LD_EXP 29
4255: PPUSH
4256: CALL_OW 300
4260: NOT
4261: IFFALSE 4339
// begin un := free_unit ;
4263: LD_ADDR_VAR 0 1
4267: PUSH
4268: LD_VAR 0 2
4272: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4273: LD_ADDR_VAR 0 8
4277: PUSH
4278: LD_VAR 0 1
4282: PPUSH
4283: CALL_OW 257
4287: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4288: LD_VAR 0 1
4292: PPUSH
4293: CALL_OW 257
4297: PUSH
4298: LD_INT 2
4300: EQUAL
4301: NOT
4302: IFFALSE 4337
// begin ComEnterUnit ( un , ru_depot ) ;
4304: LD_VAR 0 1
4308: PPUSH
4309: LD_INT 22
4311: PPUSH
4312: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_INT 2
4323: PPUSH
4324: CALL_OW 183
// wait ( 0 0$1 ) ;
4328: LD_INT 35
4330: PPUSH
4331: CALL_OW 67
// end ;
4335: GO 4288
// end else
4337: GO 4349
// un := ru_collector ;
4339: LD_ADDR_VAR 0 1
4343: PUSH
4344: LD_EXP 29
4348: ST_TO_ADDR
// end else
4349: GO 4425
// begin un := free_unit ;
4351: LD_ADDR_VAR 0 1
4355: PUSH
4356: LD_VAR 0 2
4360: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4361: LD_ADDR_VAR 0 8
4365: PUSH
4366: LD_VAR 0 1
4370: PPUSH
4371: CALL_OW 257
4375: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4376: LD_VAR 0 1
4380: PPUSH
4381: CALL_OW 257
4385: PUSH
4386: LD_INT 2
4388: EQUAL
4389: NOT
4390: IFFALSE 4425
// begin ComEnterUnit ( un , ru_depot ) ;
4392: LD_VAR 0 1
4396: PPUSH
4397: LD_INT 22
4399: PPUSH
4400: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4404: LD_VAR 0 1
4408: PPUSH
4409: LD_INT 2
4411: PPUSH
4412: CALL_OW 183
// wait ( 0 0$1 ) ;
4416: LD_INT 35
4418: PPUSH
4419: CALL_OW 67
// end ;
4423: GO 4376
// end ; if IsLive ( ru_collector ) then
4425: LD_EXP 29
4429: PPUSH
4430: CALL_OW 300
4434: IFFALSE 4465
// ComCollect ( un , crate_list [ 1 ] , crate_list [ 2 ] ) else
4436: LD_VAR 0 1
4440: PPUSH
4441: LD_EXP 32
4445: PUSH
4446: LD_INT 1
4448: ARRAY
4449: PPUSH
4450: LD_EXP 32
4454: PUSH
4455: LD_INT 2
4457: ARRAY
4458: PPUSH
4459: CALL_OW 117
4463: GO 4492
// ComGet ( un , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4465: LD_VAR 0 1
4469: PPUSH
4470: LD_EXP 32
4474: PUSH
4475: LD_INT 1
4477: ARRAY
4478: PPUSH
4479: LD_EXP 32
4483: PUSH
4484: LD_INT 2
4486: ARRAY
4487: PPUSH
4488: CALL_OW 160
// clear_crates := false ;
4492: LD_ADDR_VAR 0 7
4496: PUSH
4497: LD_INT 0
4499: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4500: LD_INT 35
4502: PPUSH
4503: CALL_OW 67
// if IsLive ( ru_collector ) and GetFuel ( un ) < 25 then
4507: LD_EXP 29
4511: PPUSH
4512: CALL_OW 300
4516: PUSH
4517: LD_VAR 0 1
4521: PPUSH
4522: CALL_OW 261
4526: PUSH
4527: LD_INT 25
4529: LESS
4530: AND
4531: IFFALSE 4624
// begin clear_crates := true ;
4533: LD_ADDR_VAR 0 7
4537: PUSH
4538: LD_INT 1
4540: ST_TO_ADDR
// if not SeeXY ( you , crate_list [ 1 ] , crate_list [ 2 ] ) then
4541: LD_EXP 14
4545: PPUSH
4546: LD_EXP 32
4550: PUSH
4551: LD_INT 1
4553: ARRAY
4554: PPUSH
4555: LD_EXP 32
4559: PUSH
4560: LD_INT 2
4562: ARRAY
4563: PPUSH
4564: CALL_OW 293
4568: NOT
4569: IFFALSE 4624
// begin MoveAreaXY ( crates_end , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4571: LD_INT 34
4573: PPUSH
4574: LD_EXP 32
4578: PUSH
4579: LD_INT 1
4581: ARRAY
4582: PPUSH
4583: LD_EXP 32
4587: PUSH
4588: LD_INT 2
4590: ARRAY
4591: PPUSH
4592: CALL_OW 425
// EraseResourceArea ( crates_end , mat_cans ) ;
4596: LD_INT 34
4598: PPUSH
4599: LD_INT 1
4601: PPUSH
4602: CALL_OW 286
// AddResourceType ( GetBase ( ru_depot ) , mat_cans , 50 ) ;
4606: LD_INT 22
4608: PPUSH
4609: CALL_OW 274
4613: PPUSH
4614: LD_INT 1
4616: PPUSH
4617: LD_INT 50
4619: PPUSH
4620: CALL_OW 276
// end ; end ; until ( not IsBusy ( un ) ) or clear_crates ;
4624: LD_VAR 0 1
4628: PPUSH
4629: CALL_OW 315
4633: NOT
4634: PUSH
4635: LD_VAR 0 7
4639: OR
4640: IFFALSE 4500
// if IsLive ( ru_collector ) then
4642: LD_EXP 29
4646: PPUSH
4647: CALL_OW 300
4651: IFFALSE 4685
// begin ComMoveUnit ( ru_collector , ru_depot ) ;
4653: LD_EXP 29
4657: PPUSH
4658: LD_INT 22
4660: PPUSH
4661: CALL_OW 112
// AddComExitVehicle ( ru_collector ) ;
4665: LD_EXP 29
4669: PPUSH
4670: CALL_OW 181
// ComReturn ( free_unit ) ;
4674: LD_VAR 0 2
4678: PPUSH
4679: CALL_OW 144
// end else
4683: GO 4880
// begin case old_class of class_mechanic :
4685: LD_VAR 0 8
4689: PUSH
4690: LD_INT 3
4692: DOUBLE
4693: EQUAL
4694: IFTRUE 4698
4696: GO 4750
4698: POP
// begin if IsOK ( ru_fact1 ) then
4699: LD_INT 1
4701: PPUSH
4702: CALL_OW 302
4706: IFFALSE 4722
// ComEnterUnit ( un , ru_fact1 ) else
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 1
4715: PPUSH
4716: CALL_OW 120
4720: GO 4734
// ComEnterUnit ( un , ru_fact2 ) ;
4722: LD_VAR 0 1
4726: PPUSH
4727: LD_INT 40
4729: PPUSH
4730: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4734: LD_VAR 0 1
4738: PPUSH
4739: LD_VAR 0 8
4743: PPUSH
4744: CALL_OW 183
// end ; class_scientistic :
4748: GO 4871
4750: LD_INT 4
4752: DOUBLE
4753: EQUAL
4754: IFTRUE 4758
4756: GO 4810
4758: POP
// begin if IsOK ( ru_lab1 ) then
4759: LD_INT 14
4761: PPUSH
4762: CALL_OW 302
4766: IFFALSE 4782
// ComEnterUnit ( un , ru_lab1 ) else
4768: LD_VAR 0 1
4772: PPUSH
4773: LD_INT 14
4775: PPUSH
4776: CALL_OW 120
4780: GO 4794
// ComEnterUnit ( un , ru_lab2 ) ;
4782: LD_VAR 0 1
4786: PPUSH
4787: LD_INT 15
4789: PPUSH
4790: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4794: LD_VAR 0 1
4798: PPUSH
4799: LD_VAR 0 8
4803: PPUSH
4804: CALL_OW 183
// end ; class_soldier :
4808: GO 4871
4810: LD_INT 1
4812: DOUBLE
4813: EQUAL
4814: IFTRUE 4818
4816: GO 4847
4818: POP
// begin ComEnterUnit ( un , ru_barac ) ;
4819: LD_VAR 0 1
4823: PPUSH
4824: LD_INT 45
4826: PPUSH
4827: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4831: LD_VAR 0 1
4835: PPUSH
4836: LD_VAR 0 8
4840: PPUSH
4841: CALL_OW 183
// end ; class_engineer :
4845: GO 4871
4847: LD_INT 2
4849: DOUBLE
4850: EQUAL
4851: IFTRUE 4855
4853: GO 4870
4855: POP
// ComMoveUnit ( un , ru_depot ) ; end ;
4856: LD_VAR 0 1
4860: PPUSH
4861: LD_INT 22
4863: PPUSH
4864: CALL_OW 112
4868: GO 4871
4870: POP
// AddComReturn ( un ) ;
4871: LD_VAR 0 1
4875: PPUSH
4876: CALL_OW 204
// end ; reserved_people := reserved_people diff free_unit ;
4880: LD_ADDR_EXP 31
4884: PUSH
4885: LD_EXP 31
4889: PUSH
4890: LD_VAR 0 2
4894: DIFF
4895: ST_TO_ADDR
// end ; enable ;
4896: ENABLE
// end ;
4897: PPOPN 9
4899: END
// function ukradni_macmillanovi_auto ; var un ; begin
4900: LD_INT 0
4902: PPUSH
4903: PPUSH
// for un in ru_sol do
4904: LD_ADDR_VAR 0 2
4908: PUSH
4909: LD_EXP 25
4913: PUSH
4914: FOR_IN
4915: IFFALSE 4944
// if IsOK ( un ) then
4917: LD_VAR 0 2
4921: PPUSH
4922: CALL_OW 302
4926: IFFALSE 4942
// ComEnterUnit ( un , truck1 ) ;
4928: LD_VAR 0 2
4932: PPUSH
4933: LD_EXP 8
4937: PPUSH
4938: CALL_OW 120
4942: GO 4914
4944: POP
4945: POP
// AddComAgressiveMove ( ru_sol , 69 , 35 ) ;
4946: LD_EXP 25
4950: PPUSH
4951: LD_INT 69
4953: PPUSH
4954: LD_INT 35
4956: PPUSH
4957: CALL_OW 174
// AddComReturn ( ru_sol ) ;
4961: LD_EXP 25
4965: PPUSH
4966: CALL_OW 204
// wait ( 0 0$20 ) ;
4970: LD_INT 700
4972: PPUSH
4973: CALL_OW 67
// end ;
4977: LD_VAR 0 1
4981: RET
// every 6 6$0 do var way_ru_patrol , x , y , i , max ;
4982: GO 4984
4984: DISABLE
4985: LD_INT 0
4987: PPUSH
4988: PPUSH
4989: PPUSH
4990: PPUSH
4991: PPUSH
// begin way_ru_patrol := [ 88 , 47 , 69 , 36 , 42 , 16 , 33 , 14 , 16 , 6 , 6 , 6 , 19 , 29 , 34 , 38 , 47 , 42 , 44 , 27 , 61 , 45 , 66 , 33 , 110 , 58 ] ;
4992: LD_ADDR_VAR 0 1
4996: PUSH
4997: LD_INT 88
4999: PUSH
5000: LD_INT 47
5002: PUSH
5003: LD_INT 69
5005: PUSH
5006: LD_INT 36
5008: PUSH
5009: LD_INT 42
5011: PUSH
5012: LD_INT 16
5014: PUSH
5015: LD_INT 33
5017: PUSH
5018: LD_INT 14
5020: PUSH
5021: LD_INT 16
5023: PUSH
5024: LD_INT 6
5026: PUSH
5027: LD_INT 6
5029: PUSH
5030: LD_INT 6
5032: PUSH
5033: LD_INT 19
5035: PUSH
5036: LD_INT 29
5038: PUSH
5039: LD_INT 34
5041: PUSH
5042: LD_INT 38
5044: PUSH
5045: LD_INT 47
5047: PUSH
5048: LD_INT 42
5050: PUSH
5051: LD_INT 44
5053: PUSH
5054: LD_INT 27
5056: PUSH
5057: LD_INT 61
5059: PUSH
5060: LD_INT 45
5062: PUSH
5063: LD_INT 66
5065: PUSH
5066: LD_INT 33
5068: PUSH
5069: LD_INT 110
5071: PUSH
5072: LD_INT 58
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: ST_TO_ADDR
// ComRemember ( ru_sol ) ;
5103: LD_EXP 25
5107: PPUSH
5108: CALL_OW 143
// reserved_people := reserved_people ^ ru_sol ;
5112: LD_ADDR_EXP 31
5116: PUSH
5117: LD_EXP 31
5121: PUSH
5122: LD_EXP 25
5126: ADD
5127: ST_TO_ADDR
// max := 0 + way_ru_patrol ;
5128: LD_ADDR_VAR 0 5
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: LD_VAR 0 1
5140: PLUS
5141: ST_TO_ADDR
// for i := 1 to ( max div 2 ) do
5142: LD_ADDR_VAR 0 4
5146: PUSH
5147: DOUBLE
5148: LD_INT 1
5150: DEC
5151: ST_TO_ADDR
5152: LD_VAR 0 5
5156: PUSH
5157: LD_INT 2
5159: DIV
5160: PUSH
5161: FOR_TO
5162: IFFALSE 5229
// begin x := way_ru_patrol [ ( 2 * i ) - 1 ] ;
5164: LD_ADDR_VAR 0 2
5168: PUSH
5169: LD_VAR 0 1
5173: PUSH
5174: LD_INT 2
5176: PUSH
5177: LD_VAR 0 4
5181: MUL
5182: PUSH
5183: LD_INT 1
5185: MINUS
5186: ARRAY
5187: ST_TO_ADDR
// y := way_ru_patrol [ ( 2 * i ) ] ;
5188: LD_ADDR_VAR 0 3
5192: PUSH
5193: LD_VAR 0 1
5197: PUSH
5198: LD_INT 2
5200: PUSH
5201: LD_VAR 0 4
5205: MUL
5206: ARRAY
5207: ST_TO_ADDR
// AddComAgressiveMove ( ru_sol , x , y ) ;
5208: LD_EXP 25
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_VAR 0 3
5222: PPUSH
5223: CALL_OW 174
// end ;
5227: GO 5161
5229: POP
5230: POP
// repeat if See ( russians , truck1 ) then
5231: LD_EXP 15
5235: PPUSH
5236: LD_EXP 8
5240: PPUSH
5241: CALL_OW 292
5245: IFFALSE 5251
// ukradni_macmillanovi_auto ;
5247: CALL 4900 0 0
// wait ( 0 0$1 ) ;
5251: LD_INT 35
5253: PPUSH
5254: CALL_OW 67
// until at_home ( ru_sol ) ;
5258: LD_EXP 25
5262: PPUSH
5263: CALL 5288 0 1
5267: IFFALSE 5231
// reserved_people := reserved_people diff ru_sol ;
5269: LD_ADDR_EXP 31
5273: PUSH
5274: LD_EXP 31
5278: PUSH
5279: LD_EXP 25
5283: DIFF
5284: ST_TO_ADDR
// end ;
5285: PPOPN 5
5287: END
// function at_home ( list ) ; var un , vysledek ; begin
5288: LD_INT 0
5290: PPUSH
5291: PPUSH
5292: PPUSH
// vysledek := true ;
5293: LD_ADDR_VAR 0 4
5297: PUSH
5298: LD_INT 1
5300: ST_TO_ADDR
// for un in list do
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: LD_VAR 0 1
5310: PUSH
5311: FOR_IN
5312: IFFALSE 5352
// if IsOK ( un ) and not IsInArea ( un , RU_Base ) then
5314: LD_VAR 0 3
5318: PPUSH
5319: CALL_OW 302
5323: PUSH
5324: LD_VAR 0 3
5328: PPUSH
5329: LD_INT 2
5331: PPUSH
5332: CALL_OW 308
5336: NOT
5337: AND
5338: IFFALSE 5350
// begin vysledek := false ;
5340: LD_ADDR_VAR 0 4
5344: PUSH
5345: LD_INT 0
5347: ST_TO_ADDR
// break ;
5348: GO 5352
// end ;
5350: GO 5311
5352: POP
5353: POP
// result := vysledek ;
5354: LD_ADDR_VAR 0 2
5358: PUSH
5359: LD_VAR 0 4
5363: ST_TO_ADDR
// end ; end_of_file
5364: LD_VAR 0 2
5368: RET
// export odpoved ; export visit_base ; var dialogue_running ; export function starting_scene ; var x , y ; begin
5369: LD_INT 0
5371: PPUSH
5372: PPUSH
5373: PPUSH
// CenterNowOnUnits ( truck1 ) ;
5374: LD_EXP 8
5378: PPUSH
5379: CALL_OW 87
// interface_hidden := true ;
5383: LD_ADDR_OWVAR 54
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// InGameOn ;
5391: CALL_OW 8
// ComMoveXY ( truck1 , 20 , 7 ) ;
5395: LD_EXP 8
5399: PPUSH
5400: LD_INT 20
5402: PPUSH
5403: LD_INT 7
5405: PPUSH
5406: CALL_OW 111
// AddComMoveXY ( truck1 , 27 , 10 ) ;
5410: LD_EXP 8
5414: PPUSH
5415: LD_INT 27
5417: PPUSH
5418: LD_INT 10
5420: PPUSH
5421: CALL_OW 171
// AddComMoveXY ( truck1 , 37 , 16 ) ;
5425: LD_EXP 8
5429: PPUSH
5430: LD_INT 37
5432: PPUSH
5433: LD_INT 16
5435: PPUSH
5436: CALL_OW 171
// wait ( 0 0$3 ) ;
5440: LD_INT 105
5442: PPUSH
5443: CALL_OW 67
// async ;
5447: ASYNC
// SayRadio ( Powell , D1-Pow-1 ) ;
5448: LD_EXP 2
5452: PPUSH
5453: LD_STRING D1-Pow-1
5455: PPUSH
5456: CALL_OW 94
// sync ;
5460: SYNC
// wait ( 0 0$2 ) ;
5461: LD_INT 70
5463: PPUSH
5464: CALL_OW 67
// ComStop ( MacMillan ) ;
5468: LD_EXP 1
5472: PPUSH
5473: CALL_OW 141
// ComExitVehicle ( truck1 ) ;
5477: LD_EXP 8
5481: PPUSH
5482: CALL_OW 121
// x := GetX ( MacMillan ) + 10 ;
5486: LD_ADDR_VAR 0 2
5490: PUSH
5491: LD_EXP 1
5495: PPUSH
5496: CALL_OW 250
5500: PUSH
5501: LD_INT 10
5503: PLUS
5504: ST_TO_ADDR
// y := GetY ( MacMillan ) + 10 ;
5505: LD_ADDR_VAR 0 3
5509: PUSH
5510: LD_EXP 1
5514: PPUSH
5515: CALL_OW 251
5519: PUSH
5520: LD_INT 10
5522: PLUS
5523: ST_TO_ADDR
// ComMoveXY ( MacMillan , x , y ) ;
5524: LD_EXP 1
5528: PPUSH
5529: LD_VAR 0 2
5533: PPUSH
5534: LD_VAR 0 3
5538: PPUSH
5539: CALL_OW 111
// wait ( 0 0$2 ) ;
5543: LD_INT 70
5545: PPUSH
5546: CALL_OW 67
// InGameOff ;
5550: CALL_OW 9
// DialogueOn ;
5554: CALL_OW 6
// interface_hidden := true ;
5558: LD_ADDR_OWVAR 54
5562: PUSH
5563: LD_INT 1
5565: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
5566: LD_EXP 1
5570: PPUSH
5571: LD_STRING D1-JMM-1
5573: PPUSH
5574: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
5578: LD_EXP 2
5582: PPUSH
5583: LD_STRING D1-Pow-2
5585: PPUSH
5586: CALL_OW 94
// Say ( MacMillan , D1-JMM-2 ) ;
5590: LD_EXP 1
5594: PPUSH
5595: LD_STRING D1-JMM-2
5597: PPUSH
5598: CALL_OW 88
// SaveForQuickRestart ;
5602: CALL_OW 22
// wait ( 0 0$0.5 ) ;
5606: LD_INT 18
5608: PPUSH
5609: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5613: LD_STRING M1
5615: PPUSH
5616: CALL_OW 337
// DialogueOff ;
5620: CALL_OW 7
// interface_hidden := false ;
5624: LD_ADDR_OWVAR 54
5628: PUSH
5629: LD_INT 0
5631: ST_TO_ADDR
// dialogue_running := false ;
5632: LD_ADDR_LOC 3
5636: PUSH
5637: LD_INT 0
5639: ST_TO_ADDR
// end ;
5640: LD_VAR 0 1
5644: RET
// function odpoved_joan ; begin
5645: LD_INT 0
5647: PPUSH
// case odpoved of 1 :
5648: LD_EXP 33
5652: PUSH
5653: LD_INT 1
5655: DOUBLE
5656: EQUAL
5657: IFTRUE 5661
5659: GO 5700
5661: POP
// begin Say ( MacMillan , D2Ja-JMM-1 ) ;
5662: LD_EXP 1
5666: PPUSH
5667: LD_STRING D2Ja-JMM-1
5669: PPUSH
5670: CALL_OW 88
// SayRadio ( Joan , D2Ja-Joan-1 ) ;
5674: LD_EXP 3
5678: PPUSH
5679: LD_STRING D2Ja-Joan-1
5681: PPUSH
5682: CALL_OW 94
// Say ( MacMillan , D2Ja-JMM-2 ) ;
5686: LD_EXP 1
5690: PPUSH
5691: LD_STRING D2Ja-JMM-2
5693: PPUSH
5694: CALL_OW 88
// end ; 2 :
5698: GO 5795
5700: LD_INT 2
5702: DOUBLE
5703: EQUAL
5704: IFTRUE 5708
5706: GO 5771
5708: POP
// begin Say ( MacMillan , D2Jb-JMM-1 ) ;
5709: LD_EXP 1
5713: PPUSH
5714: LD_STRING D2Jb-JMM-1
5716: PPUSH
5717: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-1 ) ;
5721: LD_EXP 3
5725: PPUSH
5726: LD_STRING D2Jb-Joan-1
5728: PPUSH
5729: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-2 ) ;
5733: LD_EXP 1
5737: PPUSH
5738: LD_STRING D2Jb-JMM-2
5740: PPUSH
5741: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-2 ) ;
5745: LD_EXP 3
5749: PPUSH
5750: LD_STRING D2Jb-Joan-2
5752: PPUSH
5753: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-3 ) ;
5757: LD_EXP 1
5761: PPUSH
5762: LD_STRING D2Jb-JMM-3
5764: PPUSH
5765: CALL_OW 88
// end ; 3 :
5769: GO 5795
5771: LD_INT 3
5773: DOUBLE
5774: EQUAL
5775: IFTRUE 5779
5777: GO 5794
5779: POP
// begin SayRadio ( Joan , D2Jc-Joan-1 ) ;
5780: LD_EXP 3
5784: PPUSH
5785: LD_STRING D2Jc-Joan-1
5787: PPUSH
5788: CALL_OW 94
// end ; end ;
5792: GO 5795
5794: POP
// end ;
5795: LD_VAR 0 1
5799: RET
// function odpoved_lisa ; begin
5800: LD_INT 0
5802: PPUSH
// case odpoved of 1 :
5803: LD_EXP 33
5807: PUSH
5808: LD_INT 1
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5879
5816: POP
// begin Say ( MacMillan , D2La-JMM-1 ) ;
5817: LD_EXP 1
5821: PPUSH
5822: LD_STRING D2La-JMM-1
5824: PPUSH
5825: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-1 ) ;
5829: LD_EXP 4
5833: PPUSH
5834: LD_STRING D2La-Lisa-1
5836: PPUSH
5837: CALL_OW 94
// Say ( MacMillan , D2La-JMM-2 ) ;
5841: LD_EXP 1
5845: PPUSH
5846: LD_STRING D2La-JMM-2
5848: PPUSH
5849: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-2 ) ;
5853: LD_EXP 4
5857: PPUSH
5858: LD_STRING D2La-Lisa-2
5860: PPUSH
5861: CALL_OW 94
// Say ( MacMillan , D2La-JMM-3 ) ;
5865: LD_EXP 1
5869: PPUSH
5870: LD_STRING D2La-JMM-3
5872: PPUSH
5873: CALL_OW 88
// end ; 2 :
5877: GO 5962
5879: LD_INT 2
5881: DOUBLE
5882: EQUAL
5883: IFTRUE 5887
5885: GO 5938
5887: POP
// begin Say ( MacMillan , D2Lb-JMM-1 ) ;
5888: LD_EXP 1
5892: PPUSH
5893: LD_STRING D2Lb-JMM-1
5895: PPUSH
5896: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-1 ) ;
5900: LD_EXP 4
5904: PPUSH
5905: LD_STRING D2Lb-Lisa-1
5907: PPUSH
5908: CALL_OW 94
// Say ( MacMillan , D2Lb-JMM-2 ) ;
5912: LD_EXP 1
5916: PPUSH
5917: LD_STRING D2Lb-JMM-2
5919: PPUSH
5920: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-2 ) ;
5924: LD_EXP 4
5928: PPUSH
5929: LD_STRING D2Lb-Lisa-2
5931: PPUSH
5932: CALL_OW 94
// end ; 3 :
5936: GO 5962
5938: LD_INT 3
5940: DOUBLE
5941: EQUAL
5942: IFTRUE 5946
5944: GO 5961
5946: POP
// begin SayRadio ( Lisa , D2Lc-Lisa-1 ) ;
5947: LD_EXP 4
5951: PPUSH
5952: LD_STRING D2Lc-Lisa-1
5954: PPUSH
5955: CALL_OW 94
// end ; end ;
5959: GO 5962
5961: POP
// end ;
5962: LD_VAR 0 1
5966: RET
// function odpoved_anezka ; begin
5967: LD_INT 0
5969: PPUSH
// case odpoved of 1 :
5970: LD_EXP 33
5974: PUSH
5975: LD_INT 1
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 5998
5983: POP
// begin Say ( MacMillan , D2Xa-JMM-1 ) ;
5984: LD_EXP 1
5988: PPUSH
5989: LD_STRING D2Xa-JMM-1
5991: PPUSH
5992: CALL_OW 88
// end ; 2 :
5996: GO 6057
5998: LD_INT 2
6000: DOUBLE
6001: EQUAL
6002: IFTRUE 6006
6004: GO 6033
6006: POP
// begin Say ( MacMillan , D2Xb-JMM-1 ) ;
6007: LD_EXP 1
6011: PPUSH
6012: LD_STRING D2Xb-JMM-1
6014: PPUSH
6015: CALL_OW 88
// SayRadio ( anezka , D2Xb-Con-1 ) ;
6019: LD_EXP 5
6023: PPUSH
6024: LD_STRING D2Xb-Con-1
6026: PPUSH
6027: CALL_OW 94
// end ; 3 :
6031: GO 6057
6033: LD_INT 3
6035: DOUBLE
6036: EQUAL
6037: IFTRUE 6041
6039: GO 6056
6041: POP
// begin SayRadio ( anezka , D2Xc-Con-1 ) ;
6042: LD_EXP 5
6046: PPUSH
6047: LD_STRING D2Xc-Con-1
6049: PPUSH
6050: CALL_OW 94
// end ; end ;
6054: GO 6057
6056: POP
// end ;
6057: LD_VAR 0 1
6061: RET
// every 0 0$1 trigger IsInArea ( MacMillan , help_calling ) and ( not visit_base ) do
6062: LD_EXP 1
6066: PPUSH
6067: LD_INT 5
6069: PPUSH
6070: CALL_OW 308
6074: PUSH
6075: LD_EXP 34
6079: NOT
6080: AND
6081: IFFALSE 6487
6083: GO 6085
6085: DISABLE
// begin DialogueOn ;
6086: CALL_OW 6
// interface_hidden := true ;
6090: LD_ADDR_OWVAR 54
6094: PUSH
6095: LD_INT 1
6097: ST_TO_ADDR
// case who_survive of 1 :
6098: LD_EXP 7
6102: PUSH
6103: LD_INT 1
6105: DOUBLE
6106: EQUAL
6107: IFTRUE 6111
6109: GO 6126
6111: POP
// SayRadio ( Joan , D2J-Joan-1 ) ; 2 :
6112: LD_EXP 3
6116: PPUSH
6117: LD_STRING D2J-Joan-1
6119: PPUSH
6120: CALL_OW 94
6124: GO 6173
6126: LD_INT 2
6128: DOUBLE
6129: EQUAL
6130: IFTRUE 6134
6132: GO 6149
6134: POP
// SayRadio ( Lisa , D2L-Lisa-1 ) ; 3 :
6135: LD_EXP 4
6139: PPUSH
6140: LD_STRING D2L-Lisa-1
6142: PPUSH
6143: CALL_OW 94
6147: GO 6173
6149: LD_INT 3
6151: DOUBLE
6152: EQUAL
6153: IFTRUE 6157
6155: GO 6172
6157: POP
// SayRadio ( anezka , D2X-Con-1 ) ; end ;
6158: LD_EXP 5
6162: PPUSH
6163: LD_STRING D2X-Con-1
6165: PPUSH
6166: CALL_OW 94
6170: GO 6173
6172: POP
// if Query ( Q1 ) = 2 then
6173: LD_STRING Q1
6175: PPUSH
6176: CALL_OW 97
6180: PUSH
6181: LD_INT 2
6183: EQUAL
6184: IFFALSE 6200
// begin DialogueOff ;
6186: CALL_OW 7
// interface_hidden := false ;
6190: LD_ADDR_OWVAR 54
6194: PUSH
6195: LD_INT 0
6197: ST_TO_ADDR
// exit ;
6198: GO 6487
// end ; case who_survive of 1 :
6200: LD_EXP 7
6204: PUSH
6205: LD_INT 1
6207: DOUBLE
6208: EQUAL
6209: IFTRUE 6213
6211: GO 6264
6213: POP
// begin Say ( MacMillan , D2J-JMM-1 ) ;
6214: LD_EXP 1
6218: PPUSH
6219: LD_STRING D2J-JMM-1
6221: PPUSH
6222: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-2 ) ;
6226: LD_EXP 3
6230: PPUSH
6231: LD_STRING D2J-Joan-2
6233: PPUSH
6234: CALL_OW 94
// Say ( MacMillan , D2J-JMM-2 ) ;
6238: LD_EXP 1
6242: PPUSH
6243: LD_STRING D2J-JMM-2
6245: PPUSH
6246: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-3 ) ;
6250: LD_EXP 3
6254: PPUSH
6255: LD_STRING D2J-Joan-3
6257: PPUSH
6258: CALL_OW 94
// end ; 2 :
6262: GO 6359
6264: LD_INT 2
6266: DOUBLE
6267: EQUAL
6268: IFTRUE 6272
6270: GO 6323
6272: POP
// begin Say ( MacMillan , D2L-JMM-1 ) ;
6273: LD_EXP 1
6277: PPUSH
6278: LD_STRING D2L-JMM-1
6280: PPUSH
6281: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-2 ) ;
6285: LD_EXP 4
6289: PPUSH
6290: LD_STRING D2L-Lisa-2
6292: PPUSH
6293: CALL_OW 94
// Say ( MacMillan , D2L-JMM-2 ) ;
6297: LD_EXP 1
6301: PPUSH
6302: LD_STRING D2L-JMM-2
6304: PPUSH
6305: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-3 ) ;
6309: LD_EXP 4
6313: PPUSH
6314: LD_STRING D2L-Lisa-3
6316: PPUSH
6317: CALL_OW 94
// end ; 3 :
6321: GO 6359
6323: LD_INT 3
6325: DOUBLE
6326: EQUAL
6327: IFTRUE 6331
6329: GO 6358
6331: POP
// begin Say ( MacMillan , D2X-JMM-1 ) ;
6332: LD_EXP 1
6336: PPUSH
6337: LD_STRING D2X-JMM-1
6339: PPUSH
6340: CALL_OW 88
// SayRadio ( anezka , D2X-Con-2 ) ;
6344: LD_EXP 5
6348: PPUSH
6349: LD_STRING D2X-Con-2
6351: PPUSH
6352: CALL_OW 94
// end ; end ;
6356: GO 6359
6358: POP
// wait ( 0 0$1 ) ;
6359: LD_INT 35
6361: PPUSH
6362: CALL_OW 67
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6366: LD_EXP 2
6370: PPUSH
6371: LD_STRING DPowell-Pow-1
6373: PPUSH
6374: CALL_OW 94
// wait ( 0 0$1 ) ;
6378: LD_INT 35
6380: PPUSH
6381: CALL_OW 67
// case who_survive of 1 :
6385: LD_EXP 7
6389: PUSH
6390: LD_INT 1
6392: DOUBLE
6393: EQUAL
6394: IFTRUE 6398
6396: GO 6418
6398: POP
// begin odpoved := Query ( Q2J ) ;
6399: LD_ADDR_EXP 33
6403: PUSH
6404: LD_STRING Q2J
6406: PPUSH
6407: CALL_OW 97
6411: ST_TO_ADDR
// odpoved_joan ;
6412: CALL 5645 0 0
// end ; 2 :
6416: GO 6475
6418: LD_INT 2
6420: DOUBLE
6421: EQUAL
6422: IFTRUE 6426
6424: GO 6446
6426: POP
// begin odpoved := Query ( Q2L ) ;
6427: LD_ADDR_EXP 33
6431: PUSH
6432: LD_STRING Q2L
6434: PPUSH
6435: CALL_OW 97
6439: ST_TO_ADDR
// odpoved_lisa ;
6440: CALL 5800 0 0
// end ; 3 :
6444: GO 6475
6446: LD_INT 3
6448: DOUBLE
6449: EQUAL
6450: IFTRUE 6454
6452: GO 6474
6454: POP
// begin odpoved := Query ( Q2X ) ;
6455: LD_ADDR_EXP 33
6459: PUSH
6460: LD_STRING Q2X
6462: PPUSH
6463: CALL_OW 97
6467: ST_TO_ADDR
// odpoved_anezka ;
6468: CALL 5967 0 0
// end ; end ;
6472: GO 6475
6474: POP
// DialogueOff ;
6475: CALL_OW 7
// interface_hidden := false ;
6479: LD_ADDR_OWVAR 54
6483: PUSH
6484: LD_INT 0
6486: ST_TO_ADDR
// end ;
6487: END
// every 0 0$1 trigger IsInArea ( MacMillan , US_base ) do var dist , list ;
6488: LD_EXP 1
6492: PPUSH
6493: LD_INT 1
6495: PPUSH
6496: CALL_OW 308
6500: IFFALSE 7211
6502: GO 6504
6504: DISABLE
6505: LD_INT 0
6507: PPUSH
6508: PPUSH
// begin ComMoveUnit ( survivor , MacMillan ) ;
6509: LD_EXP 6
6513: PPUSH
6514: LD_EXP 1
6518: PPUSH
6519: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6523: LD_INT 35
6525: PPUSH
6526: CALL_OW 67
// until See ( you , survivor ) ;
6530: LD_EXP 14
6534: PPUSH
6535: LD_EXP 6
6539: PPUSH
6540: CALL_OW 292
6544: IFFALSE 6523
// SetSideBase ( GetBase ( us_depot ) , you ) ;
6546: LD_INT 48
6548: PPUSH
6549: CALL_OW 274
6553: PPUSH
6554: LD_EXP 14
6558: PPUSH
6559: CALL_OW 236
// SetSide ( survivor , you ) ;
6563: LD_EXP 6
6567: PPUSH
6568: LD_EXP 14
6572: PPUSH
6573: CALL_OW 235
// SetSide ( us_trucks , you ) ;
6577: LD_EXP 35
6581: PPUSH
6582: LD_EXP 14
6586: PPUSH
6587: CALL_OW 235
// list := FilterAllUnits ( [ [ f_side , neutral ] , [ f_class , class_apeman_engineer ] ] ) ;
6591: LD_ADDR_VAR 0 2
6595: PUSH
6596: LD_INT 22
6598: PUSH
6599: LD_EXP 16
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: PUSH
6608: LD_INT 25
6610: PUSH
6611: LD_INT 16
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PPUSH
6622: CALL_OW 69
6626: ST_TO_ADDR
// SetSide ( list , you ) ;
6627: LD_VAR 0 2
6631: PPUSH
6632: LD_EXP 14
6636: PPUSH
6637: CALL_OW 235
// visit_base := true ;
6641: LD_ADDR_EXP 34
6645: PUSH
6646: LD_INT 1
6648: ST_TO_ADDR
// InGameOn ;
6649: CALL_OW 8
// if IsOK ( Joan ) then
6653: LD_EXP 3
6657: PPUSH
6658: CALL_OW 302
6662: IFFALSE 6674
// dist := 1 else
6664: LD_ADDR_VAR 0 1
6668: PUSH
6669: LD_INT 1
6671: ST_TO_ADDR
6672: GO 6682
// dist := 3 ;
6674: LD_ADDR_VAR 0 1
6678: PUSH
6679: LD_INT 3
6681: ST_TO_ADDR
// list := TICK ;
6682: LD_ADDR_VAR 0 2
6686: PUSH
6687: LD_OWVAR 1
6691: ST_TO_ADDR
// while ( GetDistUnits ( MacMillan , survivor ) > dist ) and ( ( list + 0 0$6 ) > TICK ) do
6692: LD_EXP 1
6696: PPUSH
6697: LD_EXP 6
6701: PPUSH
6702: CALL_OW 296
6706: PUSH
6707: LD_VAR 0 1
6711: GREATER
6712: PUSH
6713: LD_VAR 0 2
6717: PUSH
6718: LD_INT 210
6720: PLUS
6721: PUSH
6722: LD_OWVAR 1
6726: GREATER
6727: AND
6728: IFFALSE 6785
// begin ComMoveUnit ( survivor , MacMillan ) ;
6730: LD_EXP 6
6734: PPUSH
6735: LD_EXP 1
6739: PPUSH
6740: CALL_OW 112
// ComMoveUnit ( MacMillan , survivor ) ;
6744: LD_EXP 1
6748: PPUSH
6749: LD_EXP 6
6753: PPUSH
6754: CALL_OW 112
// wait ( 20 ) ;
6758: LD_INT 20
6760: PPUSH
6761: CALL_OW 67
// CenterOnUnits ( [ MacMillan , survivor ] ) ;
6765: LD_EXP 1
6769: PUSH
6770: LD_EXP 6
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PPUSH
6779: CALL_OW 85
// end ;
6783: GO 6692
// ComStop ( [ MacMillan , survivor ] ) ;
6785: LD_EXP 1
6789: PUSH
6790: LD_EXP 6
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PPUSH
6799: CALL_OW 141
// ComTurnUnit ( survivor , MacMillan ) ;
6803: LD_EXP 6
6807: PPUSH
6808: LD_EXP 1
6812: PPUSH
6813: CALL_OW 119
// ComTurnUnit ( MacMillan , survivor ) ;
6817: LD_EXP 1
6821: PPUSH
6822: LD_EXP 6
6826: PPUSH
6827: CALL_OW 119
// wait ( 5 ) ;
6831: LD_INT 5
6833: PPUSH
6834: CALL_OW 67
// InGameOff ;
6838: CALL_OW 9
// DialogueOn ;
6842: CALL_OW 6
// interface_hidden := true ;
6846: LD_ADDR_OWVAR 54
6850: PUSH
6851: LD_INT 1
6853: ST_TO_ADDR
// case who_survive of 1 :
6854: LD_EXP 7
6858: PUSH
6859: LD_INT 1
6861: DOUBLE
6862: EQUAL
6863: IFTRUE 6867
6865: GO 6925
6867: POP
// begin Say ( Joan , D3J-Joan-1 ) ;
6868: LD_EXP 3
6872: PPUSH
6873: LD_STRING D3J-Joan-1
6875: PPUSH
6876: CALL_OW 88
// Say ( MacMillan , D3J-JMM-1 ) ;
6880: LD_EXP 1
6884: PPUSH
6885: LD_STRING D3J-JMM-1
6887: PPUSH
6888: CALL_OW 88
// Say ( Joan , D3J-Joan-2 ) ;
6892: LD_EXP 3
6896: PPUSH
6897: LD_STRING D3J-Joan-2
6899: PPUSH
6900: CALL_OW 88
// Say ( MacMillan , D3J-JMM-2 ) ;
6904: LD_EXP 1
6908: PPUSH
6909: LD_STRING D3J-JMM-2
6911: PPUSH
6912: CALL_OW 88
// ChangeMissionObjectives ( M2J ) ;
6916: LD_STRING M2J
6918: PPUSH
6919: CALL_OW 337
// end ; 2 :
6923: GO 7022
6925: LD_INT 2
6927: DOUBLE
6928: EQUAL
6929: IFTRUE 6933
6931: GO 6991
6933: POP
// begin Say ( Lisa , D3L-Lisa-1 ) ;
6934: LD_EXP 4
6938: PPUSH
6939: LD_STRING D3L-Lisa-1
6941: PPUSH
6942: CALL_OW 88
// Say ( MacMillan , D3L-JMM-1 ) ;
6946: LD_EXP 1
6950: PPUSH
6951: LD_STRING D3L-JMM-1
6953: PPUSH
6954: CALL_OW 88
// Say ( Lisa , D3L-Lisa-2 ) ;
6958: LD_EXP 4
6962: PPUSH
6963: LD_STRING D3L-Lisa-2
6965: PPUSH
6966: CALL_OW 88
// Say ( MacMillan , D3L-JMM-2 ) ;
6970: LD_EXP 1
6974: PPUSH
6975: LD_STRING D3L-JMM-2
6977: PPUSH
6978: CALL_OW 88
// ChangeMissionObjectives ( M2L ) ;
6982: LD_STRING M2L
6984: PPUSH
6985: CALL_OW 337
// end ; 3 :
6989: GO 7022
6991: LD_INT 3
6993: DOUBLE
6994: EQUAL
6995: IFTRUE 6999
6997: GO 7021
6999: POP
// begin Say ( anezka , D3X-Con-1 ) ;
7000: LD_EXP 5
7004: PPUSH
7005: LD_STRING D3X-Con-1
7007: PPUSH
7008: CALL_OW 88
// ChangeMissionObjectives ( M2X ) ;
7012: LD_STRING M2X
7014: PPUSH
7015: CALL_OW 337
// end ; end ;
7019: GO 7022
7021: POP
// Say ( MacMillan , D4-JMM-1 ) ;
7022: LD_EXP 1
7026: PPUSH
7027: LD_STRING D4-JMM-1
7029: PPUSH
7030: CALL_OW 88
// case who_survive of 1 :
7034: LD_EXP 7
7038: PUSH
7039: LD_INT 1
7041: DOUBLE
7042: EQUAL
7043: IFTRUE 7047
7045: GO 7062
7047: POP
// Say ( Joan , D4-Joan-1 ) ; 2 :
7048: LD_EXP 3
7052: PPUSH
7053: LD_STRING D4-Joan-1
7055: PPUSH
7056: CALL_OW 88
7060: GO 7109
7062: LD_INT 2
7064: DOUBLE
7065: EQUAL
7066: IFTRUE 7070
7068: GO 7085
7070: POP
// Say ( Lisa , D4-Lisa-1 ) ; 3 :
7071: LD_EXP 4
7075: PPUSH
7076: LD_STRING D4-Lisa-1
7078: PPUSH
7079: CALL_OW 88
7083: GO 7109
7085: LD_INT 3
7087: DOUBLE
7088: EQUAL
7089: IFTRUE 7093
7091: GO 7108
7093: POP
// Say ( Anezka , D4-Con-1 ) ; end ;
7094: LD_EXP 5
7098: PPUSH
7099: LD_STRING D4-Con-1
7101: PPUSH
7102: CALL_OW 88
7106: GO 7109
7108: POP
// Say ( MacMillan , D4-JMM-2 ) ;
7109: LD_EXP 1
7113: PPUSH
7114: LD_STRING D4-JMM-2
7116: PPUSH
7117: CALL_OW 88
// case who_survive of 1 :
7121: LD_EXP 7
7125: PUSH
7126: LD_INT 1
7128: DOUBLE
7129: EQUAL
7130: IFTRUE 7134
7132: GO 7149
7134: POP
// Say ( Joan , D4-Joan-2 ) ; 2 :
7135: LD_EXP 3
7139: PPUSH
7140: LD_STRING D4-Joan-2
7142: PPUSH
7143: CALL_OW 88
7147: GO 7196
7149: LD_INT 2
7151: DOUBLE
7152: EQUAL
7153: IFTRUE 7157
7155: GO 7172
7157: POP
// Say ( Lisa , D4-Lisa-2 ) ; 3 :
7158: LD_EXP 4
7162: PPUSH
7163: LD_STRING D4-Lisa-2
7165: PPUSH
7166: CALL_OW 88
7170: GO 7196
7172: LD_INT 3
7174: DOUBLE
7175: EQUAL
7176: IFTRUE 7180
7178: GO 7195
7180: POP
// Say ( Anezka , D4-Con-2 ) ; end ;
7181: LD_EXP 5
7185: PPUSH
7186: LD_STRING D4-Con-2
7188: PPUSH
7189: CALL_OW 88
7193: GO 7196
7195: POP
// DialogueOff ;
7196: CALL_OW 7
// interface_hidden := false ;
7200: LD_ADDR_OWVAR 54
7204: PUSH
7205: LD_INT 0
7207: ST_TO_ADDR
// enable ( 11 ) ;
7208: LD_INT 11
7210: ENABLE_MARKED
// end ;
7211: PPOPN 2
7213: END
// every 0 0$1 trigger IsSelected ( us_trucks ) marked 11 do
7214: LD_EXP 35
7218: PPUSH
7219: CALL_OW 306
7223: IFFALSE 7398
7225: GO 7227
7227: DISABLE
// begin if FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_control_tower ] ] ) then
7228: LD_INT 22
7230: PUSH
7231: LD_EXP 14
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: PUSH
7240: LD_INT 30
7242: PUSH
7243: LD_INT 36
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PPUSH
7254: CALL_OW 69
7258: IFFALSE 7262
// exit ;
7260: GO 7398
// while dialogue_running do
7262: LD_LOC 3
7266: IFFALSE 7277
// wait ( 0 0$1 ) ;
7268: LD_INT 35
7270: PPUSH
7271: CALL_OW 67
7275: GO 7262
// dialogue_running := true ;
7277: LD_ADDR_LOC 3
7281: PUSH
7282: LD_INT 1
7284: ST_TO_ADDR
// DisableExclamations ;
7285: CALL_OW 474
// Say ( MacMillan , D5-JMM-1 ) ;
7289: LD_EXP 1
7293: PPUSH
7294: LD_STRING D5-JMM-1
7296: PPUSH
7297: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7301: LD_INT 77
7303: PPUSH
7304: LD_INT 87
7306: PPUSH
7307: CALL_OW 84
// case who_survive of 1 :
7311: LD_EXP 7
7315: PUSH
7316: LD_INT 1
7318: DOUBLE
7319: EQUAL
7320: IFTRUE 7324
7322: GO 7339
7324: POP
// Say ( Joan , D5-Joan-1 ) ; 2 :
7325: LD_EXP 3
7329: PPUSH
7330: LD_STRING D5-Joan-1
7332: PPUSH
7333: CALL_OW 88
7337: GO 7386
7339: LD_INT 2
7341: DOUBLE
7342: EQUAL
7343: IFTRUE 7347
7345: GO 7362
7347: POP
// Say ( Lisa , D5-Lisa-1 ) ; 3 :
7348: LD_EXP 4
7352: PPUSH
7353: LD_STRING D5-Lisa-1
7355: PPUSH
7356: CALL_OW 88
7360: GO 7386
7362: LD_INT 3
7364: DOUBLE
7365: EQUAL
7366: IFTRUE 7370
7368: GO 7385
7370: POP
// Say ( Anezka , D5-Con-1 ) ; end ;
7371: LD_EXP 5
7375: PPUSH
7376: LD_STRING D5-Con-1
7378: PPUSH
7379: CALL_OW 88
7383: GO 7386
7385: POP
// EnableExclamations ;
7386: CALL_OW 473
// dialogue_running := false ;
7390: LD_ADDR_LOC 3
7394: PUSH
7395: LD_INT 0
7397: ST_TO_ADDR
// end ;
7398: END
// every 0 0$1 trigger IsSelected ( us_lab1 ) marked 11 do
7399: LD_INT 32
7401: PPUSH
7402: CALL_OW 306
7406: IFFALSE 7764
7408: GO 7410
7410: DISABLE
// begin while dialogue_running do
7411: LD_LOC 3
7415: IFFALSE 7426
// wait ( 0 0$1 ) ;
7417: LD_INT 35
7419: PPUSH
7420: CALL_OW 67
7424: GO 7411
// dialogue_running := true ;
7426: LD_ADDR_LOC 3
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// DisableExclamations ;
7434: CALL_OW 474
// selected_opto_lab := true ;
7438: LD_ADDR_EXP 19
7442: PUSH
7443: LD_INT 1
7445: ST_TO_ADDR
// case who_survive of 1 :
7446: LD_EXP 7
7450: PUSH
7451: LD_INT 1
7453: DOUBLE
7454: EQUAL
7455: IFTRUE 7459
7457: GO 7566
7459: POP
// begin Say ( MacMillan , D6J-JMM-1 ) ;
7460: LD_EXP 1
7464: PPUSH
7465: LD_STRING D6J-JMM-1
7467: PPUSH
7468: CALL_OW 88
// if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
7472: LD_STRING Denis
7474: PPUSH
7475: CALL_OW 28
7479: PUSH
7480: LD_STRING Denis
7482: PPUSH
7483: CALL_OW 29
7487: AND
7488: IFFALSE 7528
// begin Say ( Joan , D6J-Joan-1 ) ;
7490: LD_EXP 3
7494: PPUSH
7495: LD_STRING D6J-Joan-1
7497: PPUSH
7498: CALL_OW 88
// Say ( MacMillan , D6J-JMM-2 ) ;
7502: LD_EXP 1
7506: PPUSH
7507: LD_STRING D6J-JMM-2
7509: PPUSH
7510: CALL_OW 88
// Say ( Joan , D6J-Joan-2 ) ;
7514: LD_EXP 3
7518: PPUSH
7519: LD_STRING D6J-Joan-2
7521: PPUSH
7522: CALL_OW 88
// end else
7526: GO 7540
// Say ( Joan , D6J-Joan-2a ) ;
7528: LD_EXP 3
7532: PPUSH
7533: LD_STRING D6J-Joan-2a
7535: PPUSH
7536: CALL_OW 88
// Say ( MacMillan , D6J-JMM-3 ) ;
7540: LD_EXP 1
7544: PPUSH
7545: LD_STRING D6J-JMM-3
7547: PPUSH
7548: CALL_OW 88
// Say ( Joan , D6J-Joan-3 ) ;
7552: LD_EXP 3
7556: PPUSH
7557: LD_STRING D6J-Joan-3
7559: PPUSH
7560: CALL_OW 88
// end ; 2 :
7564: GO 7745
7566: LD_INT 2
7568: DOUBLE
7569: EQUAL
7570: IFTRUE 7574
7572: GO 7625
7574: POP
// begin Say ( MacMillan , D6L-JMM-1 ) ;
7575: LD_EXP 1
7579: PPUSH
7580: LD_STRING D6L-JMM-1
7582: PPUSH
7583: CALL_OW 88
// Say ( Lisa , D6L-Lisa-1 ) ;
7587: LD_EXP 4
7591: PPUSH
7592: LD_STRING D6L-Lisa-1
7594: PPUSH
7595: CALL_OW 88
// Say ( MacMillan , D6L-JMM-2 ) ;
7599: LD_EXP 1
7603: PPUSH
7604: LD_STRING D6L-JMM-2
7606: PPUSH
7607: CALL_OW 88
// Say ( Lisa , D6L-Lisa-2 ) ;
7611: LD_EXP 4
7615: PPUSH
7616: LD_STRING D6L-Lisa-2
7618: PPUSH
7619: CALL_OW 88
// end ; 3 :
7623: GO 7745
7625: LD_INT 3
7627: DOUBLE
7628: EQUAL
7629: IFTRUE 7633
7631: GO 7744
7633: POP
// begin Say ( MacMillan , D6X-JMM-1 ) ;
7634: LD_EXP 1
7638: PPUSH
7639: LD_STRING D6X-JMM-1
7641: PPUSH
7642: CALL_OW 88
// Say ( Anezka , D6X-Con-1 ) ;
7646: LD_EXP 5
7650: PPUSH
7651: LD_STRING D6X-Con-1
7653: PPUSH
7654: CALL_OW 88
// Say ( MacMillan , D6X-JMM-2 ) ;
7658: LD_EXP 1
7662: PPUSH
7663: LD_STRING D6X-JMM-2
7665: PPUSH
7666: CALL_OW 88
// Say ( Anezka , D6X-Con-2 ) ;
7670: LD_EXP 5
7674: PPUSH
7675: LD_STRING D6X-Con-2
7677: PPUSH
7678: CALL_OW 88
// Say ( MacMillan , D6X-JMM-3 ) ;
7682: LD_EXP 1
7686: PPUSH
7687: LD_STRING D6X-JMM-3
7689: PPUSH
7690: CALL_OW 88
// Say ( Anezka , D6X-Con-3 ) ;
7694: LD_EXP 5
7698: PPUSH
7699: LD_STRING D6X-Con-3
7701: PPUSH
7702: CALL_OW 88
// Say ( MacMillan , D6X-JMM-4 ) ;
7706: LD_EXP 1
7710: PPUSH
7711: LD_STRING D6X-JMM-4
7713: PPUSH
7714: CALL_OW 88
// Say ( Anezka , D6X-Con-4 ) ;
7718: LD_EXP 5
7722: PPUSH
7723: LD_STRING D6X-Con-4
7725: PPUSH
7726: CALL_OW 88
// Say ( MacMillan , D6X-JMM-5 ) ;
7730: LD_EXP 1
7734: PPUSH
7735: LD_STRING D6X-JMM-5
7737: PPUSH
7738: CALL_OW 88
// end ; end ;
7742: GO 7745
7744: POP
// ChangeMissionObjectives ( M3 ) ;
7745: LD_STRING M3
7747: PPUSH
7748: CALL_OW 337
// EnableExclamations ;
7752: CALL_OW 473
// dialogue_running := false ;
7756: LD_ADDR_LOC 3
7760: PUSH
7761: LD_INT 0
7763: ST_TO_ADDR
// end ;
7764: END
// every 10 10$0 do
7765: GO 7767
7767: DISABLE
// begin DialogueOn ;
7768: CALL_OW 6
// interface_hidden := true ;
7772: LD_ADDR_OWVAR 54
7776: PUSH
7777: LD_INT 1
7779: ST_TO_ADDR
// Say ( Powell , D7-Pow-1 ) ;
7780: LD_EXP 2
7784: PPUSH
7785: LD_STRING D7-Pow-1
7787: PPUSH
7788: CALL_OW 88
// Say ( MacMillan , D7-JMM-1 ) ;
7792: LD_EXP 1
7796: PPUSH
7797: LD_STRING D7-JMM-1
7799: PPUSH
7800: CALL_OW 88
// Say ( Powell , D7-Pow-2 ) ;
7804: LD_EXP 2
7808: PPUSH
7809: LD_STRING D7-Pow-2
7811: PPUSH
7812: CALL_OW 88
// if IsLive ( survivor ) then
7816: LD_EXP 6
7820: PPUSH
7821: CALL_OW 300
7825: IFFALSE 7841
// Say ( MacMillan , D7-JMM-2 ) else
7827: LD_EXP 1
7831: PPUSH
7832: LD_STRING D7-JMM-2
7834: PPUSH
7835: CALL_OW 88
7839: GO 7853
// Say ( MacMillan , D7-JMM-2a ) ;
7841: LD_EXP 1
7845: PPUSH
7846: LD_STRING D7-JMM-2a
7848: PPUSH
7849: CALL_OW 88
// Say ( Powell , D7-Pow-3 ) ;
7853: LD_EXP 2
7857: PPUSH
7858: LD_STRING D7-Pow-3
7860: PPUSH
7861: CALL_OW 88
// Say ( MacMillan , D7-JMM-3 ) ;
7865: LD_EXP 1
7869: PPUSH
7870: LD_STRING D7-JMM-3
7872: PPUSH
7873: CALL_OW 88
// Say ( Powell , D7-Pow-4 ) ;
7877: LD_EXP 2
7881: PPUSH
7882: LD_STRING D7-Pow-4
7884: PPUSH
7885: CALL_OW 88
// DialogueOff ;
7889: CALL_OW 7
// interface_hidden := false ;
7893: LD_ADDR_OWVAR 54
7897: PUSH
7898: LD_INT 0
7900: ST_TO_ADDR
// end ;
7901: END
// every 0 0$20 do
7902: GO 7904
7904: DISABLE
// begin ukradle_auto := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] , [ f_chassis , us_morphling ] ] ) ;
7905: LD_ADDR_EXP 9
7909: PUSH
7910: LD_INT 22
7912: PUSH
7913: LD_EXP 15
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PUSH
7922: LD_INT 21
7924: PUSH
7925: LD_INT 2
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 31
7934: PUSH
7935: LD_INT 5
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: LIST
7946: PPUSH
7947: CALL_OW 69
7951: ST_TO_ADDR
// mm_vehicle := ukradle_auto ;
7952: LD_ADDR_EXP 63
7956: PUSH
7957: LD_EXP 9
7961: ST_TO_ADDR
// manual_forces := manual_forces ^ mm_vehicle ;
7962: LD_ADDR_EXP 59
7966: PUSH
7967: LD_EXP 59
7971: PUSH
7972: LD_EXP 63
7976: ADD
7977: ST_TO_ADDR
// if ukradle_auto then
7978: LD_EXP 9
7982: IFFALSE 7987
// enable ( 5 ) ;
7984: LD_INT 5
7986: ENABLE_MARKED
// end ;
7987: END
// function vzdalenost_macmillana_od_auta ; var v_x , v_y ; begin
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
// v_x := GetX ( ukradle_auto ) - GetX ( MacMillan ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_EXP 9
8002: PPUSH
8003: CALL_OW 250
8007: PUSH
8008: LD_EXP 1
8012: PPUSH
8013: CALL_OW 250
8017: MINUS
8018: ST_TO_ADDR
// v_x := GetY ( ukradle_auto ) - GetY ( MacMillan ) ;
8019: LD_ADDR_VAR 0 2
8023: PUSH
8024: LD_EXP 9
8028: PPUSH
8029: CALL_OW 251
8033: PUSH
8034: LD_EXP 1
8038: PPUSH
8039: CALL_OW 251
8043: MINUS
8044: ST_TO_ADDR
// if ( ( v_x > - 6 ) and ( v_x < 6 ) ) and ( ( v_y > - 6 ) and ( v_y < 6 ) ) then
8045: LD_VAR 0 2
8049: PUSH
8050: LD_INT 6
8052: NEG
8053: GREATER
8054: PUSH
8055: LD_VAR 0 2
8059: PUSH
8060: LD_INT 6
8062: LESS
8063: AND
8064: PUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 6
8072: NEG
8073: GREATER
8074: PUSH
8075: LD_VAR 0 3
8079: PUSH
8080: LD_INT 6
8082: LESS
8083: AND
8084: AND
8085: IFFALSE 8097
// result := true else
8087: LD_ADDR_VAR 0 1
8091: PUSH
8092: LD_INT 1
8094: ST_TO_ADDR
8095: GO 8105
// result := false ;
8097: LD_ADDR_VAR 0 1
8101: PUSH
8102: LD_INT 0
8104: ST_TO_ADDR
// end ;
8105: LD_VAR 0 1
8109: RET
// every 0 0$1 trigger vzdalenost_macmillana_od_auta marked 5 do
8110: CALL 7988 0 0
8114: IFFALSE 8131
8116: GO 8118
8118: DISABLE
// begin Say ( MacMillan , D8-JMM-1 ) ;
8119: LD_EXP 1
8123: PPUSH
8124: LD_STRING D8-JMM-1
8126: PPUSH
8127: CALL_OW 88
// end ; end_of_file
8131: END
// export us_trucks ; export number_us_trucks ; export heavy_trucks , medium_trucks , light_trucks ; export function prepare_us_base ; var un , i ; begin
8132: LD_INT 0
8134: PPUSH
8135: PPUSH
8136: PPUSH
// number_us_trucks := 4 ;
8137: LD_ADDR_EXP 36
8141: PUSH
8142: LD_INT 4
8144: ST_TO_ADDR
// light_trucks := Rand ( 1 , ( number_us_trucks div 2 ) ) ;
8145: LD_ADDR_EXP 39
8149: PUSH
8150: LD_INT 1
8152: PPUSH
8153: LD_EXP 36
8157: PUSH
8158: LD_INT 2
8160: DIV
8161: PPUSH
8162: CALL_OW 12
8166: ST_TO_ADDR
// heavy_trucks := Rand ( 0 , ( number_us_trucks div 2 ) ) ;
8167: LD_ADDR_EXP 37
8171: PUSH
8172: LD_INT 0
8174: PPUSH
8175: LD_EXP 36
8179: PUSH
8180: LD_INT 2
8182: DIV
8183: PPUSH
8184: CALL_OW 12
8188: ST_TO_ADDR
// medium_trucks := number_us_trucks - ( light_trucks + heavy_trucks ) ;
8189: LD_ADDR_EXP 38
8193: PUSH
8194: LD_EXP 36
8198: PUSH
8199: LD_EXP 39
8203: PUSH
8204: LD_EXP 37
8208: PLUS
8209: MINUS
8210: ST_TO_ADDR
// us_trucks := [ ] ;
8211: LD_ADDR_EXP 35
8215: PUSH
8216: EMPTY
8217: ST_TO_ADDR
// uc_nation = nation_american ;
8218: LD_ADDR_OWVAR 21
8222: PUSH
8223: LD_INT 1
8225: ST_TO_ADDR
// uc_side = neutral ;
8226: LD_ADDR_OWVAR 20
8230: PUSH
8231: LD_EXP 16
8235: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
8236: LD_ADDR_OWVAR 24
8240: PUSH
8241: LD_INT 0
8243: PPUSH
8244: LD_INT 5
8246: PPUSH
8247: CALL_OW 12
8251: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
8252: LD_ADDR_OWVAR 37
8256: PUSH
8257: LD_INT 2
8259: ST_TO_ADDR
// vc_control := control_remote ;
8260: LD_ADDR_OWVAR 38
8264: PUSH
8265: LD_INT 2
8267: ST_TO_ADDR
// vc_engine := engine_solar ;
8268: LD_ADDR_OWVAR 39
8272: PUSH
8273: LD_INT 2
8275: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
8276: LD_ADDR_OWVAR 40
8280: PUSH
8281: LD_INT 12
8283: ST_TO_ADDR
// un := CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: CALL_OW 45
8293: ST_TO_ADDR
// PlaceUnitXY ( un , 84 , 119 , false ) ;
8294: LD_VAR 0 2
8298: PPUSH
8299: LD_INT 84
8301: PPUSH
8302: LD_INT 119
8304: PPUSH
8305: LD_INT 0
8307: PPUSH
8308: CALL_OW 48
// us_trucks := us_trucks ^ un ;
8312: LD_ADDR_EXP 35
8316: PUSH
8317: LD_EXP 35
8321: PUSH
8322: LD_VAR 0 2
8326: ADD
8327: ST_TO_ADDR
// for i := 1 to light_trucks do
8328: LD_ADDR_VAR 0 3
8332: PUSH
8333: DOUBLE
8334: LD_INT 1
8336: DEC
8337: ST_TO_ADDR
8338: LD_EXP 39
8342: PUSH
8343: FOR_TO
8344: IFFALSE 8437
// begin uc_direction := Rand ( 0 , 5 ) ;
8346: LD_ADDR_OWVAR 24
8350: PUSH
8351: LD_INT 0
8353: PPUSH
8354: LD_INT 5
8356: PPUSH
8357: CALL_OW 12
8361: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
8362: LD_ADDR_OWVAR 37
8366: PUSH
8367: LD_INT 1
8369: ST_TO_ADDR
// vc_control := control_remote ;
8370: LD_ADDR_OWVAR 38
8374: PUSH
8375: LD_INT 2
8377: ST_TO_ADDR
// vc_engine := engine_solar ;
8378: LD_ADDR_OWVAR 39
8382: PUSH
8383: LD_INT 2
8385: ST_TO_ADDR
// vc_weapon := us_light_gun ;
8386: LD_ADDR_OWVAR 40
8390: PUSH
8391: LD_INT 3
8393: ST_TO_ADDR
// un := CreateVehicle ;
8394: LD_ADDR_VAR 0 2
8398: PUSH
8399: CALL_OW 45
8403: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8404: LD_VAR 0 2
8408: PPUSH
8409: LD_INT 9
8411: PPUSH
8412: LD_INT 0
8414: PPUSH
8415: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8419: LD_ADDR_EXP 35
8423: PUSH
8424: LD_EXP 35
8428: PUSH
8429: LD_VAR 0 2
8433: ADD
8434: ST_TO_ADDR
// end ;
8435: GO 8343
8437: POP
8438: POP
// for i := 1 to medium_trucks do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_EXP 38
8453: PUSH
8454: FOR_TO
8455: IFFALSE 8580
// begin uc_direction := Rand ( 0 , 5 ) ;
8457: LD_ADDR_OWVAR 24
8461: PUSH
8462: LD_INT 0
8464: PPUSH
8465: LD_INT 5
8467: PPUSH
8468: CALL_OW 12
8472: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8473: LD_VAR 0 3
8477: PUSH
8478: LD_INT 2
8480: MOD
8481: PUSH
8482: LD_INT 1
8484: EQUAL
8485: IFFALSE 8505
// begin vc_chassis := us_medium_wheeled ;
8487: LD_ADDR_OWVAR 37
8491: PUSH
8492: LD_INT 2
8494: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
8495: LD_ADDR_OWVAR 40
8499: PUSH
8500: LD_INT 4
8502: ST_TO_ADDR
// end else
8503: GO 8521
// begin vc_chassis := us_medium_tracked ;
8505: LD_ADDR_OWVAR 37
8509: PUSH
8510: LD_INT 3
8512: ST_TO_ADDR
// vc_weapon := us_double_gun ;
8513: LD_ADDR_OWVAR 40
8517: PUSH
8518: LD_INT 5
8520: ST_TO_ADDR
// end ; vc_control := control_remote ;
8521: LD_ADDR_OWVAR 38
8525: PUSH
8526: LD_INT 2
8528: ST_TO_ADDR
// vc_engine := engine_combustion ;
8529: LD_ADDR_OWVAR 39
8533: PUSH
8534: LD_INT 1
8536: ST_TO_ADDR
// un := CreateVehicle ;
8537: LD_ADDR_VAR 0 2
8541: PUSH
8542: CALL_OW 45
8546: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8547: LD_VAR 0 2
8551: PPUSH
8552: LD_INT 9
8554: PPUSH
8555: LD_INT 0
8557: PPUSH
8558: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8562: LD_ADDR_EXP 35
8566: PUSH
8567: LD_EXP 35
8571: PUSH
8572: LD_VAR 0 2
8576: ADD
8577: ST_TO_ADDR
// end ;
8578: GO 8454
8580: POP
8581: POP
// for i := 1 to heavy_trucks do
8582: LD_ADDR_VAR 0 3
8586: PUSH
8587: DOUBLE
8588: LD_INT 1
8590: DEC
8591: ST_TO_ADDR
8592: LD_EXP 37
8596: PUSH
8597: FOR_TO
8598: IFFALSE 8715
// begin uc_direction := Rand ( 0 , 5 ) ;
8600: LD_ADDR_OWVAR 24
8604: PUSH
8605: LD_INT 0
8607: PPUSH
8608: LD_INT 5
8610: PPUSH
8611: CALL_OW 12
8615: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8616: LD_ADDR_OWVAR 37
8620: PUSH
8621: LD_INT 4
8623: ST_TO_ADDR
// vc_control := control_remote ;
8624: LD_ADDR_OWVAR 38
8628: PUSH
8629: LD_INT 2
8631: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8632: LD_VAR 0 3
8636: PUSH
8637: LD_INT 2
8639: MOD
8640: PUSH
8641: LD_INT 1
8643: EQUAL
8644: IFFALSE 8656
// vc_engine := engine_siberite else
8646: LD_ADDR_OWVAR 39
8650: PUSH
8651: LD_INT 3
8653: ST_TO_ADDR
8654: GO 8664
// vc_engine := engine_combustion ;
8656: LD_ADDR_OWVAR 39
8660: PUSH
8661: LD_INT 1
8663: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
8664: LD_ADDR_OWVAR 40
8668: PUSH
8669: LD_INT 6
8671: ST_TO_ADDR
// un := CreateVehicle ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: CALL_OW 45
8681: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8682: LD_VAR 0 2
8686: PPUSH
8687: LD_INT 9
8689: PPUSH
8690: LD_INT 0
8692: PPUSH
8693: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8697: LD_ADDR_EXP 35
8701: PUSH
8702: LD_EXP 35
8706: PUSH
8707: LD_VAR 0 2
8711: ADD
8712: ST_TO_ADDR
// end ;
8713: GO 8597
8715: POP
8716: POP
// end ; end_of_file
8717: LD_VAR 0 1
8721: RET
// export ru_lab1_queue , ru_lab2_queue ; export ru_lab1_upgrade , ru_lab2_upgrade ; export research_1 , research_2 ; var research_done , laboratory ; var finished_1 , finished_2 ; var soucet1 , soucet2 ; export function ru_scientistic_priority ; begin
8722: LD_INT 0
8724: PPUSH
// ru_lab1_queue := [ tech_AdvRocket ] ;
8725: LD_ADDR_EXP 40
8729: PUSH
8730: LD_INT 71
8732: PUSH
8733: EMPTY
8734: LIST
8735: ST_TO_ADDR
// ru_lab2_queue := [ tech_TauRad , tech_SpacAnom , tech_LimTeleport , tech_MatPred , tech_TargTeleport ] ;
8736: LD_ADDR_EXP 41
8740: PUSH
8741: LD_INT 28
8743: PUSH
8744: LD_INT 29
8746: PUSH
8747: LD_INT 37
8749: PUSH
8750: LD_INT 9
8752: PUSH
8753: LD_INT 38
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: ST_TO_ADDR
// ru_lab1_upgrade := [ tech_Tech1 , tech_Weap1 , tech_Sib1 , tech_Tech2 , tech_Weap2 , tech_Sib2 , tech_Tech3 , tech_Weap3 , tech_Sib3 ] ;
8763: LD_ADDR_EXP 42
8767: PUSH
8768: LD_INT 48
8770: PUSH
8771: LD_INT 51
8773: PUSH
8774: LD_INT 54
8776: PUSH
8777: LD_INT 49
8779: PUSH
8780: LD_INT 52
8782: PUSH
8783: LD_INT 55
8785: PUSH
8786: LD_INT 50
8788: PUSH
8789: LD_INT 53
8791: PUSH
8792: LD_INT 56
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: ST_TO_ADDR
// ru_lab2_upgrade := [ tech_Comp1 , tech_ST1 , tech_Comp2 , tech_ST2 , tech_Comp3 , tech_ST3 ] ;
8806: LD_ADDR_EXP 43
8810: PUSH
8811: LD_INT 57
8813: PUSH
8814: LD_INT 63
8816: PUSH
8817: LD_INT 58
8819: PUSH
8820: LD_INT 64
8822: PUSH
8823: LD_INT 59
8825: PUSH
8826: LD_INT 65
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: ST_TO_ADDR
// research_1 := false ;
8837: LD_ADDR_EXP 44
8841: PUSH
8842: LD_INT 0
8844: ST_TO_ADDR
// research_2 := false ;
8845: LD_ADDR_EXP 45
8849: PUSH
8850: LD_INT 0
8852: ST_TO_ADDR
// finished_1 := false ;
8853: LD_ADDR_LOC 6
8857: PUSH
8858: LD_INT 0
8860: ST_TO_ADDR
// finished_2 := false ;
8861: LD_ADDR_LOC 7
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// end ;
8869: LD_VAR 0 1
8873: RET
// function change_technology_lab1 ; var i , j , pom ; begin
8874: LD_INT 0
8876: PPUSH
8877: PPUSH
8878: PPUSH
8879: PPUSH
// j := 1 ;
8880: LD_ADDR_VAR 0 3
8884: PUSH
8885: LD_INT 1
8887: ST_TO_ADDR
// pom := [ ] ;
8888: LD_ADDR_VAR 0 4
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// for i in ru_lab1_queue do
8895: LD_ADDR_VAR 0 2
8899: PUSH
8900: LD_EXP 40
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8950
// begin if j > 1 then
8908: LD_VAR 0 3
8912: PUSH
8913: LD_INT 1
8915: GREATER
8916: IFFALSE 8934
// pom := pom ^ i ;
8918: LD_ADDR_VAR 0 4
8922: PUSH
8923: LD_VAR 0 4
8927: PUSH
8928: LD_VAR 0 2
8932: ADD
8933: ST_TO_ADDR
// j := j + 1 ;
8934: LD_ADDR_VAR 0 3
8938: PUSH
8939: LD_VAR 0 3
8943: PUSH
8944: LD_INT 1
8946: PLUS
8947: ST_TO_ADDR
// end ;
8948: GO 8905
8950: POP
8951: POP
// ru_lab1_queue := pom ;
8952: LD_ADDR_EXP 40
8956: PUSH
8957: LD_VAR 0 4
8961: ST_TO_ADDR
// if not ru_lab1_queue then
8962: LD_EXP 40
8966: NOT
8967: IFFALSE 8986
// begin ru_lab1_queue := ru_lab1_upgrade ;
8969: LD_ADDR_EXP 40
8973: PUSH
8974: LD_EXP 42
8978: ST_TO_ADDR
// ru_lab1_upgrade := [ ] ;
8979: LD_ADDR_EXP 42
8983: PUSH
8984: EMPTY
8985: ST_TO_ADDR
// end ; end ;
8986: LD_VAR 0 1
8990: RET
// function change_technology_lab2 ; var i , j , pom ; begin
8991: LD_INT 0
8993: PPUSH
8994: PPUSH
8995: PPUSH
8996: PPUSH
// j := 1 ;
8997: LD_ADDR_VAR 0 3
9001: PUSH
9002: LD_INT 1
9004: ST_TO_ADDR
// pom := [ ] ;
9005: LD_ADDR_VAR 0 4
9009: PUSH
9010: EMPTY
9011: ST_TO_ADDR
// for i in ru_lab2_queue do
9012: LD_ADDR_VAR 0 2
9016: PUSH
9017: LD_EXP 41
9021: PUSH
9022: FOR_IN
9023: IFFALSE 9067
// begin if j > 1 then
9025: LD_VAR 0 3
9029: PUSH
9030: LD_INT 1
9032: GREATER
9033: IFFALSE 9051
// pom := pom ^ i ;
9035: LD_ADDR_VAR 0 4
9039: PUSH
9040: LD_VAR 0 4
9044: PUSH
9045: LD_VAR 0 2
9049: ADD
9050: ST_TO_ADDR
// j := j + 1 ;
9051: LD_ADDR_VAR 0 3
9055: PUSH
9056: LD_VAR 0 3
9060: PUSH
9061: LD_INT 1
9063: PLUS
9064: ST_TO_ADDR
// end ;
9065: GO 9022
9067: POP
9068: POP
// ru_lab2_queue := pom ;
9069: LD_ADDR_EXP 41
9073: PUSH
9074: LD_VAR 0 4
9078: ST_TO_ADDR
// if not ru_lab2_queue then
9079: LD_EXP 41
9083: NOT
9084: IFFALSE 9103
// begin ru_lab2_queue := ru_lab2_upgrade ;
9086: LD_ADDR_EXP 41
9090: PUSH
9091: LD_EXP 43
9095: ST_TO_ADDR
// ru_lab2_upgrade := [ ] ;
9096: LD_ADDR_EXP 43
9100: PUSH
9101: EMPTY
9102: ST_TO_ADDR
// end ; end ;
9103: LD_VAR 0 1
9107: RET
// on ResearchComplete ( research_done , laboratory ) do begin case laboratory of ru_lab1 :
9108: LD_VAR 0 2
9112: PUSH
9113: LD_INT 14
9115: DOUBLE
9116: EQUAL
9117: IFTRUE 9121
9119: GO 9132
9121: POP
// research_1 := false ; ru_lab2 :
9122: LD_ADDR_EXP 44
9126: PUSH
9127: LD_INT 0
9129: ST_TO_ADDR
9130: GO 9152
9132: LD_INT 15
9134: DOUBLE
9135: EQUAL
9136: IFTRUE 9140
9138: GO 9151
9140: POP
// research_2 := false ; end ;
9141: LD_ADDR_EXP 45
9145: PUSH
9146: LD_INT 0
9148: ST_TO_ADDR
9149: GO 9152
9151: POP
// end ;
9152: PPOPN 2
9154: END
// function vyrovnej_vedecke_sily ; var un , un1 , un2 , i , move_to , how_much ; begin
9155: LD_INT 0
9157: PPUSH
9158: PPUSH
9159: PPUSH
9160: PPUSH
9161: PPUSH
9162: PPUSH
9163: PPUSH
// un1 := 0 + UnitsInside ( ru_lab1 ) ;
9164: LD_ADDR_VAR 0 3
9168: PUSH
9169: LD_INT 0
9171: PUSH
9172: LD_INT 14
9174: PPUSH
9175: CALL_OW 313
9179: PLUS
9180: ST_TO_ADDR
// un2 := 0 + UnitsInside ( ru_lab2 ) ;
9181: LD_ADDR_VAR 0 4
9185: PUSH
9186: LD_INT 0
9188: PUSH
9189: LD_INT 15
9191: PPUSH
9192: CALL_OW 313
9196: PLUS
9197: ST_TO_ADDR
// if un1 >= un2 then
9198: LD_VAR 0 3
9202: PUSH
9203: LD_VAR 0 4
9207: GREATEREQUAL
9208: IFFALSE 9251
// begin move_to := ru_lab2 ;
9210: LD_ADDR_VAR 0 6
9214: PUSH
9215: LD_INT 15
9217: ST_TO_ADDR
// how_much := ( un1 - un2 ) div 2 ;
9218: LD_ADDR_VAR 0 7
9222: PUSH
9223: LD_VAR 0 3
9227: PUSH
9228: LD_VAR 0 4
9232: MINUS
9233: PUSH
9234: LD_INT 2
9236: DIV
9237: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_INT 14
9245: PPUSH
9246: CALL_OW 313
9250: ST_TO_ADDR
// end ; if un1 < un2 then
9251: LD_VAR 0 3
9255: PUSH
9256: LD_VAR 0 4
9260: LESS
9261: IFFALSE 9304
// begin move_to := ru_lab1 ;
9263: LD_ADDR_VAR 0 6
9267: PUSH
9268: LD_INT 14
9270: ST_TO_ADDR
// how_much := ( un2 - un1 ) div 2 ;
9271: LD_ADDR_VAR 0 7
9275: PUSH
9276: LD_VAR 0 4
9280: PUSH
9281: LD_VAR 0 3
9285: MINUS
9286: PUSH
9287: LD_INT 2
9289: DIV
9290: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9291: LD_ADDR_VAR 0 2
9295: PUSH
9296: LD_INT 15
9298: PPUSH
9299: CALL_OW 313
9303: ST_TO_ADDR
// end ; for i := 1 to how_much do
9304: LD_ADDR_VAR 0 5
9308: PUSH
9309: DOUBLE
9310: LD_INT 1
9312: DEC
9313: ST_TO_ADDR
9314: LD_VAR 0 7
9318: PUSH
9319: FOR_TO
9320: IFFALSE 9359
// begin ComExitBuilding ( un [ i ] ) ;
9322: LD_VAR 0 2
9326: PUSH
9327: LD_VAR 0 5
9331: ARRAY
9332: PPUSH
9333: CALL_OW 122
// AddComEnterUnit ( un [ i ] , move_to ) ;
9337: LD_VAR 0 2
9341: PUSH
9342: LD_VAR 0 5
9346: ARRAY
9347: PPUSH
9348: LD_VAR 0 6
9352: PPUSH
9353: CALL_OW 180
// end ;
9357: GO 9319
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 1
9365: RET
// every 0 0$15 trigger UnitsInside ( ru_lab1 ) and not research_1 do var un , i , j ;
9366: LD_INT 14
9368: PPUSH
9369: CALL_OW 313
9373: PUSH
9374: LD_EXP 44
9378: NOT
9379: AND
9380: IFFALSE 9701
9382: GO 9384
9384: DISABLE
9385: LD_INT 0
9387: PPUSH
9388: PPUSH
9389: PPUSH
// begin un := UnitsInside ( ru_lab1 ) ;
9390: LD_ADDR_VAR 0 1
9394: PUSH
9395: LD_INT 14
9397: PPUSH
9398: CALL_OW 313
9402: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9403: LD_VAR 0 1
9407: PPUSH
9408: LD_INT 4
9410: PPUSH
9411: CALL_OW 336
// if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9415: LD_EXP 40
9419: PUSH
9420: LD_EXP 42
9424: AND
9425: IFFALSE 9451
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9427: LD_INT 14
9429: PPUSH
9430: LD_EXP 40
9434: PUSH
9435: LD_INT 1
9437: ARRAY
9438: PPUSH
9439: CALL_OW 124
// research_1 := true ;
9443: LD_ADDR_EXP 44
9447: PUSH
9448: LD_INT 1
9450: ST_TO_ADDR
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9451: LD_EXP 40
9455: PUSH
9456: LD_EXP 42
9460: NOT
9461: AND
9462: IFFALSE 9595
// begin if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9464: LD_EXP 41
9468: PUSH
9469: LD_EXP 43
9473: AND
9474: IFFALSE 9510
// begin un := UnitsInside ( ru_lab1 ) ;
9476: LD_ADDR_VAR 0 1
9480: PUSH
9481: LD_INT 14
9483: PPUSH
9484: CALL_OW 313
9488: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9489: LD_VAR 0 1
9493: PPUSH
9494: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9498: LD_VAR 0 1
9502: PPUSH
9503: LD_INT 15
9505: PPUSH
9506: CALL_OW 180
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9510: LD_EXP 41
9514: PUSH
9515: LD_EXP 43
9519: NOT
9520: AND
9521: IFFALSE 9558
// begin vyrovnej_vedecke_sily ;
9523: CALL 9155 0 0
// wait ( 0 0$5 ) ;
9527: LD_INT 175
9529: PPUSH
9530: CALL_OW 67
// ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9534: LD_INT 14
9536: PPUSH
9537: LD_EXP 40
9541: PUSH
9542: LD_INT 1
9544: ARRAY
9545: PPUSH
9546: CALL_OW 124
// research_1 := true ;
9550: LD_ADDR_EXP 44
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// end ; if not ( ru_lab2_queue or ru_lab2_upgrade ) then
9558: LD_EXP 41
9562: PUSH
9563: LD_EXP 43
9567: OR
9568: NOT
9569: IFFALSE 9595
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9571: LD_INT 14
9573: PPUSH
9574: LD_EXP 40
9578: PUSH
9579: LD_INT 1
9581: ARRAY
9582: PPUSH
9583: CALL_OW 124
// research_1 := true ;
9587: LD_ADDR_EXP 44
9591: PUSH
9592: LD_INT 1
9594: ST_TO_ADDR
// end ; end ; if research_1 then
9595: LD_EXP 44
9599: IFFALSE 9605
// change_technology_lab1 ;
9601: CALL 8874 0 0
// soucet1 := 0 + ru_lab1_queue + ru_lab1_upgrade ;
9605: LD_ADDR_LOC 8
9609: PUSH
9610: LD_INT 0
9612: PUSH
9613: LD_EXP 40
9617: PLUS
9618: PUSH
9619: LD_EXP 42
9623: PLUS
9624: ST_TO_ADDR
// if ( soucet1 = 0 ) and ( not research_1 ) then
9625: LD_LOC 8
9629: PUSH
9630: LD_INT 0
9632: EQUAL
9633: PUSH
9634: LD_EXP 44
9638: NOT
9639: AND
9640: IFFALSE 9684
// begin finished_1 := true ;
9642: LD_ADDR_LOC 6
9646: PUSH
9647: LD_INT 1
9649: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9650: LD_ADDR_VAR 0 1
9654: PUSH
9655: LD_INT 14
9657: PPUSH
9658: CALL_OW 313
9662: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9663: LD_VAR 0 1
9667: PPUSH
9668: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9672: LD_VAR 0 1
9676: PPUSH
9677: LD_INT 15
9679: PPUSH
9680: CALL_OW 180
// end ; if ( soucet1 > 0 ) or research_1 then
9684: LD_LOC 8
9688: PUSH
9689: LD_INT 0
9691: GREATER
9692: PUSH
9693: LD_EXP 44
9697: OR
9698: IFFALSE 9701
// enable ;
9700: ENABLE
// end ;
9701: PPOPN 3
9703: END
// every 0 0$15 trigger UnitsInside ( ru_lab2 ) and not research_2 do var un , i , j ;
9704: LD_INT 15
9706: PPUSH
9707: CALL_OW 313
9711: PUSH
9712: LD_EXP 45
9716: NOT
9717: AND
9718: IFFALSE 10039
9720: GO 9722
9722: DISABLE
9723: LD_INT 0
9725: PPUSH
9726: PPUSH
9727: PPUSH
// begin un := UnitsInside ( ru_lab2 ) ;
9728: LD_ADDR_VAR 0 1
9732: PUSH
9733: LD_INT 15
9735: PPUSH
9736: CALL_OW 313
9740: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 4
9748: PPUSH
9749: CALL_OW 336
// if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9753: LD_EXP 41
9757: PUSH
9758: LD_EXP 43
9762: AND
9763: IFFALSE 9789
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9765: LD_INT 15
9767: PPUSH
9768: LD_EXP 41
9772: PUSH
9773: LD_INT 1
9775: ARRAY
9776: PPUSH
9777: CALL_OW 124
// research_2 := true ;
9781: LD_ADDR_EXP 45
9785: PUSH
9786: LD_INT 1
9788: ST_TO_ADDR
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9789: LD_EXP 41
9793: PUSH
9794: LD_EXP 43
9798: NOT
9799: AND
9800: IFFALSE 9933
// begin if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9802: LD_EXP 40
9806: PUSH
9807: LD_EXP 42
9811: AND
9812: IFFALSE 9848
// begin un := UnitsInside ( ru_lab2 ) ;
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_INT 15
9821: PPUSH
9822: CALL_OW 313
9826: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
9836: LD_VAR 0 1
9840: PPUSH
9841: LD_INT 14
9843: PPUSH
9844: CALL_OW 180
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9848: LD_EXP 40
9852: PUSH
9853: LD_EXP 42
9857: NOT
9858: AND
9859: IFFALSE 9896
// begin vyrovnej_vedecke_sily ;
9861: CALL 9155 0 0
// wait ( 0 0$5 ) ;
9865: LD_INT 175
9867: PPUSH
9868: CALL_OW 67
// ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9872: LD_INT 15
9874: PPUSH
9875: LD_EXP 41
9879: PUSH
9880: LD_INT 1
9882: ARRAY
9883: PPUSH
9884: CALL_OW 124
// research_2 := true ;
9888: LD_ADDR_EXP 45
9892: PUSH
9893: LD_INT 1
9895: ST_TO_ADDR
// end ; if not ( ru_lab1_queue or ru_lab1_upgrade ) then
9896: LD_EXP 40
9900: PUSH
9901: LD_EXP 42
9905: OR
9906: NOT
9907: IFFALSE 9933
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9909: LD_INT 15
9911: PPUSH
9912: LD_EXP 41
9916: PUSH
9917: LD_INT 1
9919: ARRAY
9920: PPUSH
9921: CALL_OW 124
// research_2 := true ;
9925: LD_ADDR_EXP 45
9929: PUSH
9930: LD_INT 1
9932: ST_TO_ADDR
// end ; end ; if research_2 then
9933: LD_EXP 45
9937: IFFALSE 9943
// change_technology_lab2 ;
9939: CALL 8991 0 0
// soucet2 := 0 + ru_lab2_queue + ru_lab2_upgrade ;
9943: LD_ADDR_LOC 9
9947: PUSH
9948: LD_INT 0
9950: PUSH
9951: LD_EXP 41
9955: PLUS
9956: PUSH
9957: LD_EXP 43
9961: PLUS
9962: ST_TO_ADDR
// if ( soucet2 = 0 ) and ( not research_2 ) then
9963: LD_LOC 9
9967: PUSH
9968: LD_INT 0
9970: EQUAL
9971: PUSH
9972: LD_EXP 45
9976: NOT
9977: AND
9978: IFFALSE 10022
// begin finished_2 := true ;
9980: LD_ADDR_LOC 7
9984: PUSH
9985: LD_INT 1
9987: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9988: LD_ADDR_VAR 0 1
9992: PUSH
9993: LD_INT 15
9995: PPUSH
9996: CALL_OW 313
10000: ST_TO_ADDR
// ComExitBuilding ( un ) ;
10001: LD_VAR 0 1
10005: PPUSH
10006: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
10010: LD_VAR 0 1
10014: PPUSH
10015: LD_INT 14
10017: PPUSH
10018: CALL_OW 180
// end ; if ( soucet2 > 0 ) or research_2 then
10022: LD_LOC 9
10026: PUSH
10027: LD_INT 0
10029: GREATER
10030: PUSH
10031: LD_EXP 45
10035: OR
10036: IFFALSE 10039
// enable ;
10038: ENABLE
// end ;
10039: PPOPN 3
10041: END
// every 0 0$10 trigger finished_1 and finished_2 do var un , sci , i , build ;
10042: LD_LOC 6
10046: PUSH
10047: LD_LOC 7
10051: AND
10052: IFFALSE 10319
10054: GO 10056
10056: DISABLE
10057: LD_INT 0
10059: PPUSH
10060: PPUSH
10061: PPUSH
10062: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
10063: LD_ADDR_VAR 0 2
10067: PUSH
10068: LD_INT 22
10070: PUSH
10071: LD_EXP 15
10075: PUSH
10076: EMPTY
10077: LIST
10078: LIST
10079: PUSH
10080: LD_INT 25
10082: PUSH
10083: LD_INT 4
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: ST_TO_ADDR
// ComExitBuilding ( sci ) ;
10099: LD_VAR 0 2
10103: PPUSH
10104: CALL_OW 122
// build := FilterAllUnits ( [ [ f_side , russians ] , [ f_btype , b_factory ] ] ) ;
10108: LD_ADDR_VAR 0 4
10112: PUSH
10113: LD_INT 22
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PUSH
10125: LD_INT 30
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: PPUSH
10139: CALL_OW 69
10143: ST_TO_ADDR
// if build then
10144: LD_VAR 0 4
10148: IFFALSE 10221
// begin i := 1 ;
10150: LD_ADDR_VAR 0 3
10154: PUSH
10155: LD_INT 1
10157: ST_TO_ADDR
// for un in sci do
10158: LD_ADDR_VAR 0 1
10162: PUSH
10163: LD_VAR 0 2
10167: PUSH
10168: FOR_IN
10169: IFFALSE 10217
// begin ComEnterUnit ( un , build [ ( i mod build ) + 1 ] ) ;
10171: LD_VAR 0 1
10175: PPUSH
10176: LD_VAR 0 4
10180: PUSH
10181: LD_VAR 0 3
10185: PUSH
10186: LD_VAR 0 4
10190: MOD
10191: PUSH
10192: LD_INT 1
10194: PLUS
10195: ARRAY
10196: PPUSH
10197: CALL_OW 120
// i := i + 1 ;
10201: LD_ADDR_VAR 0 3
10205: PUSH
10206: LD_VAR 0 3
10210: PUSH
10211: LD_INT 1
10213: PLUS
10214: ST_TO_ADDR
// end ;
10215: GO 10168
10217: POP
10218: POP
// end else
10219: GO 10319
// begin build := FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_EXP 15
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 2
10240: PUSH
10241: LD_INT 30
10243: PUSH
10244: LD_INT 5
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 30
10253: PUSH
10254: LD_INT 4
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: PPUSH
10270: CALL_OW 69
10274: ST_TO_ADDR
// if build then
10275: LD_VAR 0 4
10279: IFFALSE 10319
// begin ComEnterUnit ( sci , build ) ;
10281: LD_VAR 0 2
10285: PPUSH
10286: LD_VAR 0 4
10290: PPUSH
10291: CALL_OW 120
// AddComChangeProfession ( sci , class_soldier ) ;
10295: LD_VAR 0 2
10299: PPUSH
10300: LD_INT 1
10302: PPUSH
10303: CALL_OW 183
// AddComChangeProfession ( sci , class_bazooker ) ;
10307: LD_VAR 0 2
10311: PPUSH
10312: LD_INT 9
10314: PPUSH
10315: CALL_OW 183
// end ; end ; end ; end_of_file
10319: PPOPN 4
10321: END
// export base_crates , base_oil , base_siberit ; export busy_fact1 , busy_fact2 ; export vyber_pro_tovarnu ; var hotove_vozidlo , volna_tovarna ; var cekat_dodavku ; var time_fact1 , time_fact2 ; var no_siberit ; var factory1_idle , factory2_idle ; export function startup_manufacturing ; begin
10322: LD_INT 0
10324: PPUSH
// busy_fact1 := false ;
10325: LD_ADDR_EXP 49
10329: PUSH
10330: LD_INT 0
10332: ST_TO_ADDR
// busy_fact2 := false ;
10333: LD_ADDR_EXP 50
10337: PUSH
10338: LD_INT 0
10340: ST_TO_ADDR
// time_fact1 := Rand ( 0 0$2 , 0 0$10 ) ;
10341: LD_ADDR_LOC 13
10345: PUSH
10346: LD_INT 70
10348: PPUSH
10349: LD_INT 350
10351: PPUSH
10352: CALL_OW 12
10356: ST_TO_ADDR
// time_fact2 := Rand ( 0 0$2 , 0 0$10 ) ;
10357: LD_ADDR_LOC 14
10361: PUSH
10362: LD_INT 70
10364: PPUSH
10365: LD_INT 350
10367: PPUSH
10368: CALL_OW 12
10372: ST_TO_ADDR
// end ;
10373: LD_VAR 0 1
10377: RET
// function zjisti_zdroje ; var base ; begin
10378: LD_INT 0
10380: PPUSH
10381: PPUSH
// base := GetBase ( ru_depot ) ;
10382: LD_ADDR_VAR 0 2
10386: PUSH
10387: LD_INT 22
10389: PPUSH
10390: CALL_OW 274
10394: ST_TO_ADDR
// base_crates := GetResourceType ( base , mat_cans ) ;
10395: LD_ADDR_EXP 46
10399: PUSH
10400: LD_VAR 0 2
10404: PPUSH
10405: LD_INT 1
10407: PPUSH
10408: CALL_OW 275
10412: ST_TO_ADDR
// base_oil := GetResourceType ( base , mat_oil ) ;
10413: LD_ADDR_EXP 47
10417: PUSH
10418: LD_VAR 0 2
10422: PPUSH
10423: LD_INT 2
10425: PPUSH
10426: CALL_OW 275
10430: ST_TO_ADDR
// base_siberit := GetResourceType ( base , mat_siberit ) ;
10431: LD_ADDR_EXP 48
10435: PUSH
10436: LD_VAR 0 2
10440: PPUSH
10441: LD_INT 3
10443: PPUSH
10444: CALL_OW 275
10448: ST_TO_ADDR
// end ;
10449: LD_VAR 0 1
10453: RET
// every 0 0$2 trigger UnitsInside ( ru_fact1 ) and UnitsInside ( ru_fact2 ) marked 1 do var un ;
10454: LD_INT 1
10456: PPUSH
10457: CALL_OW 313
10461: PUSH
10462: LD_INT 40
10464: PPUSH
10465: CALL_OW 313
10469: AND
10470: IFFALSE 10502
10472: GO 10474
10474: DISABLE
10475: LD_INT 0
10477: PPUSH
// begin ComRemember ( UnitsInside ( ru_fact1 ) ) ;
10478: LD_INT 1
10480: PPUSH
10481: CALL_OW 313
10485: PPUSH
10486: CALL_OW 143
// ComRemember ( UnitsInside ( ru_fact2 ) ) ;
10490: LD_INT 40
10492: PPUSH
10493: CALL_OW 313
10497: PPUSH
10498: CALL_OW 143
// end ;
10502: PPOPN 1
10504: END
// function vyber_komponenty ; var specialni ; begin
10505: LD_INT 0
10507: PPUSH
10508: PPUSH
// cekat_dodavku := true ;
10509: LD_ADDR_LOC 12
10513: PUSH
10514: LD_INT 1
10516: ST_TO_ADDR
// specialni := false ;
10517: LD_ADDR_VAR 0 2
10521: PUSH
10522: LD_INT 0
10524: ST_TO_ADDR
// no_siberit := false ;
10525: LD_ADDR_LOC 15
10529: PUSH
10530: LD_INT 0
10532: ST_TO_ADDR
// zjisti_pozadavky ;
10533: CALL 11926 0 0
// if 1 = 2 then
10537: LD_INT 1
10539: PUSH
10540: LD_INT 2
10542: EQUAL
10543: IFFALSE 10800
// begin case chybi of 1 :
10545: LD_EXP 62
10549: PUSH
10550: LD_INT 1
10552: DOUBLE
10553: EQUAL
10554: IFTRUE 10558
10556: GO 10633
10558: POP
// begin if ( base_crates >= 55 ) then
10559: LD_EXP 46
10563: PUSH
10564: LD_INT 55
10566: GREATEREQUAL
10567: IFFALSE 10579
// vc_chassis := ru_heavy_tracked else
10569: LD_ADDR_OWVAR 37
10573: PUSH
10574: LD_INT 24
10576: ST_TO_ADDR
10577: GO 10587
// vc_chassis := ru_heavy_wheeled ;
10579: LD_ADDR_OWVAR 37
10583: PUSH
10584: LD_INT 23
10586: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10587: LD_ADDR_OWVAR 40
10591: PUSH
10592: LD_INT 49
10594: ST_TO_ADDR
// vc_control := control_computer ;
10595: LD_ADDR_OWVAR 38
10599: PUSH
10600: LD_INT 3
10602: ST_TO_ADDR
// if ( base_siberit >= 60 ) then
10603: LD_EXP 48
10607: PUSH
10608: LD_INT 60
10610: GREATEREQUAL
10611: IFFALSE 10623
// vc_engine := engine_siberite else
10613: LD_ADDR_OWVAR 39
10617: PUSH
10618: LD_INT 3
10620: ST_TO_ADDR
10621: GO 10631
// vc_engine := engine_combustion ;
10623: LD_ADDR_OWVAR 39
10627: PUSH
10628: LD_INT 1
10630: ST_TO_ADDR
// end ; 2 :
10631: GO 10790
10633: LD_INT 2
10635: DOUBLE
10636: EQUAL
10637: IFTRUE 10641
10639: GO 10676
10641: POP
// begin vc_chassis := ru_heavy_tracked ;
10642: LD_ADDR_OWVAR 37
10646: PUSH
10647: LD_INT 24
10649: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10650: LD_ADDR_OWVAR 40
10654: PUSH
10655: LD_INT 49
10657: ST_TO_ADDR
// vc_control := control_manual ;
10658: LD_ADDR_OWVAR 38
10662: PUSH
10663: LD_INT 1
10665: ST_TO_ADDR
// vc_engine := engine_siberite ;
10666: LD_ADDR_OWVAR 39
10670: PUSH
10671: LD_INT 3
10673: ST_TO_ADDR
// end ; 3 :
10674: GO 10790
10676: LD_INT 3
10678: DOUBLE
10679: EQUAL
10680: IFTRUE 10684
10682: GO 10789
10684: POP
// begin vc_chassis := ru_heavy_tracked ;
10685: LD_ADDR_OWVAR 37
10689: PUSH
10690: LD_INT 24
10692: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10693: LD_ADDR_OWVAR 40
10697: PUSH
10698: LD_INT 46
10700: ST_TO_ADDR
// if base_crates < 70 then
10701: LD_EXP 46
10705: PUSH
10706: LD_INT 70
10708: LESS
10709: IFFALSE 10719
// vc_chassis := ru_heavy_wheeled ;
10711: LD_ADDR_OWVAR 37
10715: PUSH
10716: LD_INT 23
10718: ST_TO_ADDR
// if base_crates < 60 then
10719: LD_EXP 46
10723: PUSH
10724: LD_INT 60
10726: LESS
10727: IFFALSE 10745
// begin vc_weapon := ru_rocket ;
10729: LD_ADDR_OWVAR 40
10733: PUSH
10734: LD_INT 47
10736: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10737: LD_ADDR_OWVAR 37
10741: PUSH
10742: LD_INT 24
10744: ST_TO_ADDR
// end ; if base_crates < 55 then
10745: LD_EXP 46
10749: PUSH
10750: LD_INT 55
10752: LESS
10753: IFFALSE 10763
// vc_chassis := ru_heavy_wheeled ;
10755: LD_ADDR_OWVAR 37
10759: PUSH
10760: LD_INT 23
10762: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10763: LD_ADDR_OWVAR 40
10767: PUSH
10768: LD_INT 49
10770: ST_TO_ADDR
// vc_control := control_manual ;
10771: LD_ADDR_OWVAR 38
10775: PUSH
10776: LD_INT 1
10778: ST_TO_ADDR
// vc_engine := engine_siberite ;
10779: LD_ADDR_OWVAR 39
10783: PUSH
10784: LD_INT 3
10786: ST_TO_ADDR
// end ; end ;
10787: GO 10790
10789: POP
// specialni := true ;
10790: LD_ADDR_VAR 0 2
10794: PUSH
10795: LD_INT 1
10797: ST_TO_ADDR
// end else
10798: GO 10800
// begin end ; if ( base_crates < 65 ) and ( not specialni ) then
10800: LD_EXP 46
10804: PUSH
10805: LD_INT 65
10807: LESS
10808: PUSH
10809: LD_VAR 0 2
10813: NOT
10814: AND
10815: IFFALSE 10903
// begin cekat_dodavku := false ;
10817: LD_ADDR_LOC 12
10821: PUSH
10822: LD_INT 0
10824: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10825: LD_ADDR_OWVAR 40
10829: PUSH
10830: LD_INT 45
10832: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10833: LD_ADDR_OWVAR 37
10837: PUSH
10838: LD_INT 22
10840: ST_TO_ADDR
// if base_crates < 60 then
10841: LD_EXP 46
10845: PUSH
10846: LD_INT 60
10848: LESS
10849: IFFALSE 10859
// vc_chassis := ru_medium_wheeled ;
10851: LD_ADDR_OWVAR 37
10855: PUSH
10856: LD_INT 21
10858: ST_TO_ADDR
// if base_crates < 55 then
10859: LD_EXP 46
10863: PUSH
10864: LD_INT 55
10866: LESS
10867: IFFALSE 10885
// begin vc_chassis := ru_medium_tracked ;
10869: LD_ADDR_OWVAR 37
10873: PUSH
10874: LD_INT 22
10876: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
10877: LD_ADDR_OWVAR 40
10881: PUSH
10882: LD_INT 43
10884: ST_TO_ADDR
// end ; if base_crates < 50 then
10885: LD_EXP 46
10889: PUSH
10890: LD_INT 50
10892: LESS
10893: IFFALSE 10903
// vc_chassis := ru_medium_wheeled ;
10895: LD_ADDR_OWVAR 37
10899: PUSH
10900: LD_INT 21
10902: ST_TO_ADDR
// end ; if ( base_crates >= 65 ) and ( vyber_pro_tovarnu = 1 ) and ( not specialni ) then
10903: LD_EXP 46
10907: PUSH
10908: LD_INT 65
10910: GREATEREQUAL
10911: PUSH
10912: LD_EXP 51
10916: PUSH
10917: LD_INT 1
10919: EQUAL
10920: AND
10921: PUSH
10922: LD_VAR 0 2
10926: NOT
10927: AND
10928: IFFALSE 11016
// begin cekat_dodavku := false ;
10930: LD_ADDR_LOC 12
10934: PUSH
10935: LD_INT 0
10937: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10938: LD_ADDR_OWVAR 40
10942: PUSH
10943: LD_INT 46
10945: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10946: LD_ADDR_OWVAR 37
10950: PUSH
10951: LD_INT 24
10953: ST_TO_ADDR
// if base_crates < 80 then
10954: LD_EXP 46
10958: PUSH
10959: LD_INT 80
10961: LESS
10962: IFFALSE 10972
// vc_chassis := ru_heavy_wheeled ;
10964: LD_ADDR_OWVAR 37
10968: PUSH
10969: LD_INT 23
10971: ST_TO_ADDR
// if base_crates < 70 then
10972: LD_EXP 46
10976: PUSH
10977: LD_INT 70
10979: LESS
10980: IFFALSE 10998
// begin vc_weapon := ru_rocket ;
10982: LD_ADDR_OWVAR 40
10986: PUSH
10987: LD_INT 47
10989: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10990: LD_ADDR_OWVAR 37
10994: PUSH
10995: LD_INT 24
10997: ST_TO_ADDR
// end ; if base_crates < 65 then
10998: LD_EXP 46
11002: PUSH
11003: LD_INT 65
11005: LESS
11006: IFFALSE 11016
// vc_chassis := ru_heavy_wheeled ;
11008: LD_ADDR_OWVAR 37
11012: PUSH
11013: LD_INT 23
11015: ST_TO_ADDR
// end ; if ( base_crates >= 70 ) and ( vyber_pro_tovarnu = 2 ) and ( not specialni ) then
11016: LD_EXP 46
11020: PUSH
11021: LD_INT 70
11023: GREATEREQUAL
11024: PUSH
11025: LD_EXP 51
11029: PUSH
11030: LD_INT 2
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_VAR 0 2
11039: NOT
11040: AND
11041: IFFALSE 11085
// begin cekat_dodavku := false ;
11043: LD_ADDR_LOC 12
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// vc_weapon := ru_rocket ;
11051: LD_ADDR_OWVAR 40
11055: PUSH
11056: LD_INT 47
11058: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11059: LD_ADDR_OWVAR 37
11063: PUSH
11064: LD_INT 24
11066: ST_TO_ADDR
// if base_crates < 75 then
11067: LD_EXP 46
11071: PUSH
11072: LD_INT 75
11074: LESS
11075: IFFALSE 11085
// vc_chassis := ru_heavy_wheeled ;
11077: LD_ADDR_OWVAR 37
11081: PUSH
11082: LD_INT 23
11084: ST_TO_ADDR
// end ; if not specialni then
11085: LD_VAR 0 2
11089: NOT
11090: IFFALSE 11171
// begin vc_control := control_computer ;
11092: LD_ADDR_OWVAR 38
11096: PUSH
11097: LD_INT 3
11099: ST_TO_ADDR
// if ( vc_chassis > 22 ) and ( base_siberit >= 10 ) and ( not no_siberit ) then
11100: LD_OWVAR 37
11104: PUSH
11105: LD_INT 22
11107: GREATER
11108: PUSH
11109: LD_EXP 48
11113: PUSH
11114: LD_INT 10
11116: GREATEREQUAL
11117: AND
11118: PUSH
11119: LD_LOC 15
11123: NOT
11124: AND
11125: IFFALSE 11145
// begin vc_engine := engine_siberite ;
11127: LD_ADDR_OWVAR 39
11131: PUSH
11132: LD_INT 3
11134: ST_TO_ADDR
// cekat_dodavku := false ;
11135: LD_ADDR_LOC 12
11139: PUSH
11140: LD_INT 0
11142: ST_TO_ADDR
// end else
11143: GO 11171
// if base_oil >= 30 then
11145: LD_EXP 47
11149: PUSH
11150: LD_INT 30
11152: GREATEREQUAL
11153: IFFALSE 11171
// begin vc_engine := engine_combustion ;
11155: LD_ADDR_OWVAR 39
11159: PUSH
11160: LD_INT 1
11162: ST_TO_ADDR
// cekat_dodavku := false ;
11163: LD_ADDR_LOC 12
11167: PUSH
11168: LD_INT 0
11170: ST_TO_ADDR
// end ; end ; end ;
11171: LD_VAR 0 1
11175: RET
// on VehicleConstructed ( hotove_vozidlo , volna_tovarna ) do begin if GetSide ( hotove_vozidlo ) = russians then
11176: LD_VAR 0 1
11180: PPUSH
11181: CALL_OW 255
11185: PUSH
11186: LD_EXP 15
11190: EQUAL
11191: IFFALSE 11290
// begin if GetControl ( hotove_vozidlo ) = control_manual then
11193: LD_VAR 0 1
11197: PPUSH
11198: CALL_OW 263
11202: PUSH
11203: LD_INT 1
11205: EQUAL
11206: IFFALSE 11224
// zaparkuj_vozidlo ( volna_tovarna , hotove_vozidlo ) else
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_VAR 0 1
11217: PPUSH
11218: CALL 12079 0 2
11222: GO 11240
// war_forces := war_forces ^ hotove_vozidlo ;
11224: LD_ADDR_EXP 52
11228: PUSH
11229: LD_EXP 52
11233: PUSH
11234: LD_VAR 0 1
11238: ADD
11239: ST_TO_ADDR
// collect_war_forces ;
11240: CALL 12227 0 0
// case volna_tovarna of ru_fact1 :
11244: LD_VAR 0 2
11248: PUSH
11249: LD_INT 1
11251: DOUBLE
11252: EQUAL
11253: IFTRUE 11257
11255: GO 11268
11257: POP
// busy_fact1 := false ; ru_fact2 :
11258: LD_ADDR_EXP 49
11262: PUSH
11263: LD_INT 0
11265: ST_TO_ADDR
11266: GO 11288
11268: LD_INT 40
11270: DOUBLE
11271: EQUAL
11272: IFTRUE 11276
11274: GO 11287
11276: POP
// busy_fact2 := false ; end ;
11277: LD_ADDR_EXP 50
11281: PUSH
11282: LD_INT 0
11284: ST_TO_ADDR
11285: GO 11288
11287: POP
// end else
11288: GO 11358
// if GetWeapon ( hotove_vozidlo ) = us_double_laser then
11290: LD_VAR 0 1
11294: PPUSH
11295: CALL_OW 264
11299: PUSH
11300: LD_INT 10
11302: EQUAL
11303: IFFALSE 11358
// begin double_laser := double_laser + 1 ;
11305: LD_ADDR_EXP 17
11309: PUSH
11310: LD_EXP 17
11314: PUSH
11315: LD_INT 1
11317: PLUS
11318: ST_TO_ADDR
// if not double_hint then
11319: LD_EXP 18
11323: NOT
11324: IFFALSE 11341
// begin Hint ( DoubleLaser ) ;
11326: LD_STRING DoubleLaser
11328: PPUSH
11329: CALL_OW 339
// double_hint := true ;
11333: LD_ADDR_EXP 18
11337: PUSH
11338: LD_INT 1
11340: ST_TO_ADDR
// end ; if double_laser = 2 then
11341: LD_EXP 17
11345: PUSH
11346: LD_INT 2
11348: EQUAL
11349: IFFALSE 11358
// ChangeMissionObjectives ( M3a ) ;
11351: LD_STRING M3a
11353: PPUSH
11354: CALL_OW 337
// end ; end ;
11358: PPOPN 2
11360: END
// every 0 0$10 trigger UnitsInside ( ru_fact1 ) and ( not busy_fact1 ) and ( TICK >= time_fact1 ) do var un ;
11361: LD_INT 1
11363: PPUSH
11364: CALL_OW 313
11368: PUSH
11369: LD_EXP 49
11373: NOT
11374: AND
11375: PUSH
11376: LD_OWVAR 1
11380: PUSH
11381: LD_LOC 13
11385: GREATEREQUAL
11386: AND
11387: IFFALSE 11495
11389: GO 11391
11391: DISABLE
11392: LD_INT 0
11394: PPUSH
// begin zjisti_zdroje ;
11395: CALL 10378 0 0
// if base_crates >= 40 then
11399: LD_EXP 46
11403: PUSH
11404: LD_INT 40
11406: GREATEREQUAL
11407: IFFALSE 11472
// begin vyber_pro_tovarnu := 1 ;
11409: LD_ADDR_EXP 51
11413: PUSH
11414: LD_INT 1
11416: ST_TO_ADDR
// vyber_komponenty ;
11417: CALL 10505 0 0
// if not cekat_dodavku then
11421: LD_LOC 12
11425: NOT
11426: IFFALSE 11472
// begin ComConstruct ( ru_fact1 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11428: LD_INT 1
11430: PPUSH
11431: LD_OWVAR 37
11435: PPUSH
11436: LD_OWVAR 39
11440: PPUSH
11441: LD_OWVAR 38
11445: PPUSH
11446: LD_OWVAR 40
11450: PPUSH
11451: CALL_OW 125
// if IsBusy ( ru_fact1 ) then
11455: LD_INT 1
11457: PPUSH
11458: CALL_OW 315
11462: IFFALSE 11472
// busy_fact1 := true ;
11464: LD_ADDR_EXP 49
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// end ; end ; time_fact1 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11472: LD_ADDR_LOC 13
11476: PUSH
11477: LD_OWVAR 1
11481: PUSH
11482: LD_INT 1400
11484: PPUSH
11485: LD_INT 2100
11487: PPUSH
11488: CALL_OW 12
11492: PLUS
11493: ST_TO_ADDR
// enable ;
11494: ENABLE
// end ;
11495: PPOPN 1
11497: END
// every 0 0$10 trigger UnitsInside ( ru_fact2 ) and ( not busy_fact2 ) and ( TICK >= time_fact2 ) do var un ;
11498: LD_INT 40
11500: PPUSH
11501: CALL_OW 313
11505: PUSH
11506: LD_EXP 50
11510: NOT
11511: AND
11512: PUSH
11513: LD_OWVAR 1
11517: PUSH
11518: LD_LOC 14
11522: GREATEREQUAL
11523: AND
11524: IFFALSE 11632
11526: GO 11528
11528: DISABLE
11529: LD_INT 0
11531: PPUSH
// begin zjisti_zdroje ;
11532: CALL 10378 0 0
// if base_crates >= 40 then
11536: LD_EXP 46
11540: PUSH
11541: LD_INT 40
11543: GREATEREQUAL
11544: IFFALSE 11609
// begin vyber_pro_tovarnu := 2 ;
11546: LD_ADDR_EXP 51
11550: PUSH
11551: LD_INT 2
11553: ST_TO_ADDR
// vyber_komponenty ;
11554: CALL 10505 0 0
// if not cekat_dodavku then
11558: LD_LOC 12
11562: NOT
11563: IFFALSE 11609
// begin ComConstruct ( ru_fact2 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11565: LD_INT 40
11567: PPUSH
11568: LD_OWVAR 37
11572: PPUSH
11573: LD_OWVAR 39
11577: PPUSH
11578: LD_OWVAR 38
11582: PPUSH
11583: LD_OWVAR 40
11587: PPUSH
11588: CALL_OW 125
// if IsBusy ( ru_fact2 ) then
11592: LD_INT 40
11594: PPUSH
11595: CALL_OW 315
11599: IFFALSE 11609
// busy_fact2 := true ;
11601: LD_ADDR_EXP 50
11605: PUSH
11606: LD_INT 1
11608: ST_TO_ADDR
// end ; end ; time_fact2 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11609: LD_ADDR_LOC 14
11613: PUSH
11614: LD_OWVAR 1
11618: PUSH
11619: LD_INT 1400
11621: PPUSH
11622: LD_INT 2100
11624: PPUSH
11625: CALL_OW 12
11629: PLUS
11630: ST_TO_ADDR
// enable ;
11631: ENABLE
// end ;
11632: PPOPN 1
11634: END
// every 0 0$10 trigger ( busy_fact1 ) and ( base_crates > 40 ) do
11635: LD_EXP 49
11639: PUSH
11640: LD_EXP 46
11644: PUSH
11645: LD_INT 40
11647: GREATER
11648: AND
11649: IFFALSE 11694
11651: GO 11653
11653: DISABLE
// begin factory1_idle := factory1_idle + 1 ;
11654: LD_ADDR_LOC 16
11658: PUSH
11659: LD_LOC 16
11663: PUSH
11664: LD_INT 1
11666: PLUS
11667: ST_TO_ADDR
// if factory1_idle > 10 then
11668: LD_LOC 16
11672: PUSH
11673: LD_INT 10
11675: GREATER
11676: IFFALSE 11694
// begin factory1_idle := 0 ;
11678: LD_ADDR_LOC 16
11682: PUSH
11683: LD_INT 0
11685: ST_TO_ADDR
// busy_fact1 := false ;
11686: LD_ADDR_EXP 49
11690: PUSH
11691: LD_INT 0
11693: ST_TO_ADDR
// end ; end ;
11694: END
// every 0 0$10 trigger ( busy_fact2 ) and ( base_crates > 40 ) do
11695: LD_EXP 50
11699: PUSH
11700: LD_EXP 46
11704: PUSH
11705: LD_INT 40
11707: GREATER
11708: AND
11709: IFFALSE 11754
11711: GO 11713
11713: DISABLE
// begin factory2_idle := factory2_idle + 1 ;
11714: LD_ADDR_LOC 17
11718: PUSH
11719: LD_LOC 17
11723: PUSH
11724: LD_INT 1
11726: PLUS
11727: ST_TO_ADDR
// if factory2_idle > 10 then
11728: LD_LOC 17
11732: PUSH
11733: LD_INT 10
11735: GREATER
11736: IFFALSE 11754
// begin factory2_idle := 0 ;
11738: LD_ADDR_LOC 17
11742: PUSH
11743: LD_INT 0
11745: ST_TO_ADDR
// busy_fact2 := false ;
11746: LD_ADDR_EXP 50
11750: PUSH
11751: LD_INT 0
11753: ST_TO_ADDR
// end ; end ; end_of_file
11754: END
// export war_forces , war_lapser , war_count ; export attack_forces ; export backup_forces , backup_lapser , backup_count ; export manual_forces , manual_lapser ; export fuel_tank ; export chybi ; export mm_vehicle ; export defend_forces ; export us_important ; var klic_area_1 , klic_area_2 ; var klic_area_3 , klic_area_4 ; var klic_area_5 , klic_area_6 ; var klic_area_7 , klic_area_8 ; var klic_area_9 ; var destroy_now ; var important ; var multi ; var skrivanek ; var kolibrik ; var attack_begin ; var cislo_utoku ; var now_area , next_area ; var event_unit ; export function startup_war_definition ; begin
11755: LD_INT 0
11757: PPUSH
// war_forces := [ ] ;
11758: LD_ADDR_EXP 52
11762: PUSH
11763: EMPTY
11764: ST_TO_ADDR
// war_lapser := 0 ;
11765: LD_ADDR_EXP 53
11769: PUSH
11770: LD_INT 0
11772: ST_TO_ADDR
// war_count := Rand ( 2 , 3 ) ;
11773: LD_ADDR_EXP 54
11777: PUSH
11778: LD_INT 2
11780: PPUSH
11781: LD_INT 3
11783: PPUSH
11784: CALL_OW 12
11788: ST_TO_ADDR
// backup_forces := [ ] ;
11789: LD_ADDR_EXP 56
11793: PUSH
11794: EMPTY
11795: ST_TO_ADDR
// backup_lapser := 0 ;
11796: LD_ADDR_EXP 57
11800: PUSH
11801: LD_INT 0
11803: ST_TO_ADDR
// backup_count := Rand ( 2 , 3 ) ;
11804: LD_ADDR_EXP 58
11808: PUSH
11809: LD_INT 2
11811: PPUSH
11812: LD_INT 3
11814: PPUSH
11815: CALL_OW 12
11819: ST_TO_ADDR
// manual_forces := [ ] ;
11820: LD_ADDR_EXP 59
11824: PUSH
11825: EMPTY
11826: ST_TO_ADDR
// manual_lapser := 0 ;
11827: LD_ADDR_EXP 60
11831: PUSH
11832: LD_INT 0
11834: ST_TO_ADDR
// defend_forces := [ ] ;
11835: LD_ADDR_EXP 64
11839: PUSH
11840: EMPTY
11841: ST_TO_ADDR
// klic_area_1 := [ ] ;
11842: LD_ADDR_LOC 18
11846: PUSH
11847: EMPTY
11848: ST_TO_ADDR
// klic_area_2 := [ ] ;
11849: LD_ADDR_LOC 19
11853: PUSH
11854: EMPTY
11855: ST_TO_ADDR
// klic_area_3 := [ ] ;
11856: LD_ADDR_LOC 20
11860: PUSH
11861: EMPTY
11862: ST_TO_ADDR
// klic_area_4 := [ ] ;
11863: LD_ADDR_LOC 21
11867: PUSH
11868: EMPTY
11869: ST_TO_ADDR
// klic_area_5 := [ ] ;
11870: LD_ADDR_LOC 22
11874: PUSH
11875: EMPTY
11876: ST_TO_ADDR
// klic_area_6 := [ ] ;
11877: LD_ADDR_LOC 23
11881: PUSH
11882: EMPTY
11883: ST_TO_ADDR
// klic_area_7 := [ ] ;
11884: LD_ADDR_LOC 24
11888: PUSH
11889: EMPTY
11890: ST_TO_ADDR
// klic_area_8 := [ ] ;
11891: LD_ADDR_LOC 25
11895: PUSH
11896: EMPTY
11897: ST_TO_ADDR
// klic_area_9 := [ ] ;
11898: LD_ADDR_LOC 26
11902: PUSH
11903: EMPTY
11904: ST_TO_ADDR
// cislo_utoku := 1 ;
11905: LD_ADDR_LOC 33
11909: PUSH
11910: LD_INT 1
11912: ST_TO_ADDR
// mm_vehicle := 0 ;
11913: LD_ADDR_EXP 63
11917: PUSH
11918: LD_INT 0
11920: ST_TO_ADDR
// end ;
11921: LD_VAR 0 1
11925: RET
// export function zjisti_pozadavky ; var vybrano ; var i ; begin
11926: LD_INT 0
11928: PPUSH
11929: PPUSH
11930: PPUSH
// chybi := 0 ;
11931: LD_ADDR_EXP 62
11935: PUSH
11936: LD_INT 0
11938: ST_TO_ADDR
// if manual_forces < russians_forces then
11939: LD_EXP 59
11943: PUSH
11944: LD_EXP 28
11948: LESS
11949: IFFALSE 11959
// chybi := 3 ;
11951: LD_ADDR_EXP 62
11955: PUSH
11956: LD_INT 3
11958: ST_TO_ADDR
// end ;
11959: LD_VAR 0 1
11963: RET
// every 5 5$0 trigger ( backup_forces < backup_count ) and ( war_forces > 0 ) do var hex ;
11964: LD_EXP 56
11968: PUSH
11969: LD_EXP 58
11973: LESS
11974: PUSH
11975: LD_EXP 52
11979: PUSH
11980: LD_INT 0
11982: GREATER
11983: AND
11984: IFFALSE 12076
11986: GO 11988
11988: DISABLE
11989: LD_INT 0
11991: PPUSH
// begin hex := RandHexArea ( parking_place , true ) ;
11992: LD_ADDR_VAR 0 1
11996: PUSH
11997: LD_INT 11
11999: PPUSH
12000: LD_INT 1
12002: PPUSH
12003: CALL_OW 16
12007: ST_TO_ADDR
// backup_forces := backup_forces ^ ( war_forces [ 1 ] ) ;
12008: LD_ADDR_EXP 56
12012: PUSH
12013: LD_EXP 56
12017: PUSH
12018: LD_EXP 52
12022: PUSH
12023: LD_INT 1
12025: ARRAY
12026: ADD
12027: ST_TO_ADDR
// ComAgressiveMove ( war_forces [ 1 ] , hex [ 1 ] , hex [ 2 ] ) ;
12028: LD_EXP 52
12032: PUSH
12033: LD_INT 1
12035: ARRAY
12036: PPUSH
12037: LD_VAR 0 1
12041: PUSH
12042: LD_INT 1
12044: ARRAY
12045: PPUSH
12046: LD_VAR 0 1
12050: PUSH
12051: LD_INT 2
12053: ARRAY
12054: PPUSH
12055: CALL_OW 114
// war_forces := war_forces diff backup_forces ;
12059: LD_ADDR_EXP 52
12063: PUSH
12064: LD_EXP 52
12068: PUSH
12069: LD_EXP 56
12073: DIFF
12074: ST_TO_ADDR
// enable ;
12075: ENABLE
// end ;
12076: PPOPN 1
12078: END
// export function zaparkuj_vozidlo ( puvod_ridice , vozidlo ) ; var ridic , hex ; begin
12079: LD_INT 0
12081: PPUSH
12082: PPUSH
12083: PPUSH
// manual_forces := manual_forces ^ vozidlo ;
12084: LD_ADDR_EXP 59
12088: PUSH
12089: LD_EXP 59
12093: PUSH
12094: LD_VAR 0 2
12098: ADD
12099: ST_TO_ADDR
// hex := RandHexArea ( parking_place , true ) ;
12100: LD_ADDR_VAR 0 5
12104: PUSH
12105: LD_INT 11
12107: PPUSH
12108: LD_INT 1
12110: PPUSH
12111: CALL_OW 16
12115: ST_TO_ADDR
// if ( manual_forces < 2 ) then
12116: LD_EXP 59
12120: PUSH
12121: LD_INT 2
12123: LESS
12124: IFFALSE 12143
// ComMoveXY ( vozidlo , 103 , 59 ) else
12126: LD_VAR 0 2
12130: PPUSH
12131: LD_INT 103
12133: PPUSH
12134: LD_INT 59
12136: PPUSH
12137: CALL_OW 111
12141: GO 12170
// ComMoveXY ( vozidlo , hex [ 1 ] , hex [ 2 ] ) ;
12143: LD_VAR 0 2
12147: PPUSH
12148: LD_VAR 0 5
12152: PUSH
12153: LD_INT 1
12155: ARRAY
12156: PPUSH
12157: LD_VAR 0 5
12161: PUSH
12162: LD_INT 2
12164: ARRAY
12165: PPUSH
12166: CALL_OW 111
// repeat wait ( 0 0$5 ) ;
12170: LD_INT 175
12172: PPUSH
12173: CALL_OW 67
// until not IsBusy ( vozidlo ) ;
12177: LD_VAR 0 2
12181: PPUSH
12182: CALL_OW 315
12186: NOT
12187: IFFALSE 12170
// ridic := IsDrivenBy ( vozidlo ) ;
12189: LD_ADDR_VAR 0 4
12193: PUSH
12194: LD_VAR 0 2
12198: PPUSH
12199: CALL_OW 311
12203: ST_TO_ADDR
// ComExitVehicle ( ridic ) ;
12204: LD_VAR 0 4
12208: PPUSH
12209: CALL_OW 121
// AddComReturn ( ridic ) ;
12213: LD_VAR 0 4
12217: PPUSH
12218: CALL_OW 204
// end ;
12222: LD_VAR 0 3
12226: RET
// export function collect_war_forces ; begin
12227: LD_INT 0
12229: PPUSH
// ComAgressiveMove ( war_forces , 103 , 65 ) ;
12230: LD_EXP 52
12234: PPUSH
12235: LD_INT 103
12237: PPUSH
12238: LD_INT 65
12240: PPUSH
12241: CALL_OW 114
// end ;
12245: LD_VAR 0 1
12249: RET
// function zjisti_cilove_misto ( cislo_arei ) ; var vysledek ; begin
12250: LD_INT 0
12252: PPUSH
12253: PPUSH
// case cislo_arei of 1 :
12254: LD_VAR 0 1
12258: PUSH
12259: LD_INT 1
12261: DOUBLE
12262: EQUAL
12263: IFTRUE 12267
12265: GO 12285
12267: POP
// vysledek := [ 75 , 83 ] ; 2 :
12268: LD_ADDR_VAR 0 3
12272: PUSH
12273: LD_INT 75
12275: PUSH
12276: LD_INT 83
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: ST_TO_ADDR
12283: GO 12494
12285: LD_INT 2
12287: DOUBLE
12288: EQUAL
12289: IFTRUE 12293
12291: GO 12311
12293: POP
// vysledek := [ 82 , 102 ] ; 3 :
12294: LD_ADDR_VAR 0 3
12298: PUSH
12299: LD_INT 82
12301: PUSH
12302: LD_INT 102
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: ST_TO_ADDR
12309: GO 12494
12311: LD_INT 3
12313: DOUBLE
12314: EQUAL
12315: IFTRUE 12319
12317: GO 12337
12319: POP
// vysledek := [ 85 , 116 ] ; 4 :
12320: LD_ADDR_VAR 0 3
12324: PUSH
12325: LD_INT 85
12327: PUSH
12328: LD_INT 116
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: ST_TO_ADDR
12335: GO 12494
12337: LD_INT 4
12339: DOUBLE
12340: EQUAL
12341: IFTRUE 12345
12343: GO 12363
12345: POP
// vysledek := [ 95 , 107 ] ; 5 :
12346: LD_ADDR_VAR 0 3
12350: PUSH
12351: LD_INT 95
12353: PUSH
12354: LD_INT 107
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: ST_TO_ADDR
12361: GO 12494
12363: LD_INT 5
12365: DOUBLE
12366: EQUAL
12367: IFTRUE 12371
12369: GO 12389
12371: POP
// vysledek := [ 108 , 116 ] ; 6 :
12372: LD_ADDR_VAR 0 3
12376: PUSH
12377: LD_INT 108
12379: PUSH
12380: LD_INT 116
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: ST_TO_ADDR
12387: GO 12494
12389: LD_INT 6
12391: DOUBLE
12392: EQUAL
12393: IFTRUE 12397
12395: GO 12415
12397: POP
// vysledek := [ 105 , 133 ] ; 7 :
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 105
12405: PUSH
12406: LD_INT 133
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: ST_TO_ADDR
12413: GO 12494
12415: LD_INT 7
12417: DOUBLE
12418: EQUAL
12419: IFTRUE 12423
12421: GO 12441
12423: POP
// vysledek := [ 85 , 133 ] ; 8 :
12424: LD_ADDR_VAR 0 3
12428: PUSH
12429: LD_INT 85
12431: PUSH
12432: LD_INT 133
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: ST_TO_ADDR
12439: GO 12494
12441: LD_INT 8
12443: DOUBLE
12444: EQUAL
12445: IFTRUE 12449
12447: GO 12467
12449: POP
// vysledek := [ 62 , 105 ] ; 9 :
12450: LD_ADDR_VAR 0 3
12454: PUSH
12455: LD_INT 62
12457: PUSH
12458: LD_INT 105
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: ST_TO_ADDR
12465: GO 12494
12467: LD_INT 9
12469: DOUBLE
12470: EQUAL
12471: IFTRUE 12475
12473: GO 12493
12475: POP
// vysledek := [ 103 , 97 ] ; end ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_INT 103
12483: PUSH
12484: LD_INT 97
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: ST_TO_ADDR
12491: GO 12494
12493: POP
// result := vysledek ;
12494: LD_ADDR_VAR 0 2
12498: PUSH
12499: LD_VAR 0 3
12503: ST_TO_ADDR
// end ;
12504: LD_VAR 0 2
12508: RET
// function a_jmeno ( cislo ) ; var vysledek ; begin
12509: LD_INT 0
12511: PPUSH
12512: PPUSH
// case cislo of 1 :
12513: LD_VAR 0 1
12517: PUSH
12518: LD_INT 1
12520: DOUBLE
12521: EQUAL
12522: IFTRUE 12526
12524: GO 12537
12526: POP
// vysledek := u_north ; 2 :
12527: LD_ADDR_VAR 0 3
12531: PUSH
12532: LD_INT 16
12534: ST_TO_ADDR
12535: GO 12747
12537: LD_INT 2
12539: DOUBLE
12540: EQUAL
12541: IFTRUE 12545
12543: GO 12556
12545: POP
// vysledek := u_central_n ; 3 :
12546: LD_ADDR_VAR 0 3
12550: PUSH
12551: LD_INT 17
12553: ST_TO_ADDR
12554: GO 12747
12556: LD_INT 3
12558: DOUBLE
12559: EQUAL
12560: IFTRUE 12564
12562: GO 12575
12564: POP
// vysledek := u_central ; 4 :
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 19
12572: ST_TO_ADDR
12573: GO 12747
12575: LD_INT 4
12577: DOUBLE
12578: EQUAL
12579: IFTRUE 12583
12581: GO 12594
12583: POP
// vysledek := u_hill ; 5 :
12584: LD_ADDR_VAR 0 3
12588: PUSH
12589: LD_INT 18
12591: ST_TO_ADDR
12592: GO 12747
12594: LD_INT 5
12596: DOUBLE
12597: EQUAL
12598: IFTRUE 12602
12600: GO 12613
12602: POP
// vysledek := u_walley ; 6 :
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: LD_INT 21
12610: ST_TO_ADDR
12611: GO 12747
12613: LD_INT 6
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12632
12621: POP
// vysledek := u_forgotten ; 7 :
12622: LD_ADDR_VAR 0 3
12626: PUSH
12627: LD_INT 23
12629: ST_TO_ADDR
12630: GO 12747
12632: LD_INT 7
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12651
12640: POP
// vysledek := u_south ; 8 :
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: LD_INT 20
12648: ST_TO_ADDR
12649: GO 12747
12651: LD_INT 8
12653: DOUBLE
12654: EQUAL
12655: IFTRUE 12659
12657: GO 12670
12659: POP
// vysledek := u_heart ; 9 :
12660: LD_ADDR_VAR 0 3
12664: PUSH
12665: LD_INT 22
12667: ST_TO_ADDR
12668: GO 12747
12670: LD_INT 9
12672: DOUBLE
12673: EQUAL
12674: IFTRUE 12678
12676: GO 12689
12678: POP
// vysledek := u_east ; 11 :
12679: LD_ADDR_VAR 0 3
12683: PUSH
12684: LD_INT 24
12686: ST_TO_ADDR
12687: GO 12747
12689: LD_INT 11
12691: DOUBLE
12692: EQUAL
12693: IFTRUE 12697
12695: GO 12708
12697: POP
// vysledek := n_gather ; 12 :
12698: LD_ADDR_VAR 0 3
12702: PUSH
12703: LD_INT 13
12705: ST_TO_ADDR
12706: GO 12747
12708: LD_INT 12
12710: DOUBLE
12711: EQUAL
12712: IFTRUE 12716
12714: GO 12727
12716: POP
// vysledek := e_gather ; 13 :
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_INT 14
12724: ST_TO_ADDR
12725: GO 12747
12727: LD_INT 13
12729: DOUBLE
12730: EQUAL
12731: IFTRUE 12735
12733: GO 12746
12735: POP
// vysledek := s_gather ; end ;
12736: LD_ADDR_VAR 0 3
12740: PUSH
12741: LD_INT 15
12743: ST_TO_ADDR
12744: GO 12747
12746: POP
// result := vysledek ;
12747: LD_ADDR_VAR 0 2
12751: PUSH
12752: LD_VAR 0 3
12756: ST_TO_ADDR
// end ;
12757: LD_VAR 0 2
12761: RET
// function goto_north_sector ; var i , utocniku ; begin
12762: LD_INT 0
12764: PPUSH
12765: PPUSH
12766: PPUSH
// ComAgressiveMove ( attack_forces , 100 , 67 ) ;
12767: LD_EXP 55
12771: PPUSH
12772: LD_INT 100
12774: PPUSH
12775: LD_INT 67
12777: PPUSH
12778: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 87 , 65 ) ;
12782: LD_EXP 55
12786: PPUSH
12787: LD_INT 87
12789: PPUSH
12790: LD_INT 65
12792: PPUSH
12793: CALL_OW 174
// AddComAgressiveMove ( attack_forces , 74 , 64 ) ;
12797: LD_EXP 55
12801: PPUSH
12802: LD_INT 74
12804: PPUSH
12805: LD_INT 64
12807: PPUSH
12808: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12812: LD_INT 70
12814: PPUSH
12815: CALL_OW 67
// until vsichni_v_arei ( n_gather ) or ( not attack_forces ) ;
12819: LD_INT 13
12821: PPUSH
12822: CALL 13632 0 1
12826: PUSH
12827: LD_EXP 55
12831: NOT
12832: OR
12833: IFFALSE 12812
// attack_begin := true ;
12835: LD_ADDR_LOC 32
12839: PUSH
12840: LD_INT 1
12842: ST_TO_ADDR
// end ;
12843: LD_VAR 0 1
12847: RET
// function goto_east_sector ; var i , utocniku ; begin
12848: LD_INT 0
12850: PPUSH
12851: PPUSH
12852: PPUSH
// utocniku := 0 + attack_forces ;
12853: LD_ADDR_VAR 0 3
12857: PUSH
12858: LD_INT 0
12860: PUSH
12861: LD_EXP 55
12865: PLUS
12866: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12867: LD_EXP 55
12871: PPUSH
12872: LD_INT 111
12874: PPUSH
12875: LD_INT 73
12877: PPUSH
12878: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 116 , 95 ) ;
12882: LD_EXP 55
12886: PPUSH
12887: LD_INT 116
12889: PPUSH
12890: LD_INT 95
12892: PPUSH
12893: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12897: LD_INT 70
12899: PPUSH
12900: CALL_OW 67
// until vsichni_v_arei ( e_gather ) or ( not attack_forces ) ;
12904: LD_INT 14
12906: PPUSH
12907: CALL 13632 0 1
12911: PUSH
12912: LD_EXP 55
12916: NOT
12917: OR
12918: IFFALSE 12897
// attack_begin := true ;
12920: LD_ADDR_LOC 32
12924: PUSH
12925: LD_INT 1
12927: ST_TO_ADDR
// end ;
12928: LD_VAR 0 1
12932: RET
// function goto_south_sector ; var i , utocniku ; begin
12933: LD_INT 0
12935: PPUSH
12936: PPUSH
12937: PPUSH
// utocniku := 0 + attack_forces ;
12938: LD_ADDR_VAR 0 3
12942: PUSH
12943: LD_INT 0
12945: PUSH
12946: LD_EXP 55
12950: PLUS
12951: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12952: LD_EXP 55
12956: PPUSH
12957: LD_INT 111
12959: PPUSH
12960: LD_INT 73
12962: PPUSH
12963: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 127 , 118 ) ;
12967: LD_EXP 55
12971: PPUSH
12972: LD_INT 127
12974: PPUSH
12975: LD_INT 118
12977: PPUSH
12978: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12982: LD_INT 70
12984: PPUSH
12985: CALL_OW 67
// until vsichni_v_arei ( s_gather ) or ( not attack_forces ) ;
12989: LD_INT 15
12991: PPUSH
12992: CALL 13632 0 1
12996: PUSH
12997: LD_EXP 55
13001: NOT
13002: OR
13003: IFFALSE 12982
// attack_begin := true ;
13005: LD_ADDR_LOC 32
13009: PUSH
13010: LD_INT 1
13012: ST_TO_ADDR
// end ;
13013: LD_VAR 0 1
13017: RET
// function zjisti_schudne_okoli ( area ) ; var a1 , a2 , vysledek ; var v1 , v2 ; begin
13018: LD_INT 0
13020: PPUSH
13021: PPUSH
13022: PPUSH
13023: PPUSH
13024: PPUSH
13025: PPUSH
// case area of 1 :
13026: LD_VAR 0 1
13030: PUSH
13031: LD_INT 1
13033: DOUBLE
13034: EQUAL
13035: IFTRUE 13039
13037: GO 13058
13039: POP
// begin a1 := 2 ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_INT 2
13047: ST_TO_ADDR
// a2 := 0 ;
13048: LD_ADDR_VAR 0 4
13052: PUSH
13053: LD_INT 0
13055: ST_TO_ADDR
// end ; 2 :
13056: GO 13356
13058: LD_INT 2
13060: DOUBLE
13061: EQUAL
13062: IFTRUE 13066
13064: GO 13085
13066: POP
// begin a1 := 3 ;
13067: LD_ADDR_VAR 0 3
13071: PUSH
13072: LD_INT 3
13074: ST_TO_ADDR
// a2 := 8 ;
13075: LD_ADDR_VAR 0 4
13079: PUSH
13080: LD_INT 8
13082: ST_TO_ADDR
// end ; 3 :
13083: GO 13356
13085: LD_INT 3
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13112
13093: POP
// begin a1 := 7 ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 7
13101: ST_TO_ADDR
// a2 := 2 ;
13102: LD_ADDR_VAR 0 4
13106: PUSH
13107: LD_INT 2
13109: ST_TO_ADDR
// end ; 4 :
13110: GO 13356
13112: LD_INT 4
13114: DOUBLE
13115: EQUAL
13116: IFTRUE 13120
13118: GO 13139
13120: POP
// begin a1 := 2 ;
13121: LD_ADDR_VAR 0 3
13125: PUSH
13126: LD_INT 2
13128: ST_TO_ADDR
// a2 := 3 ;
13129: LD_ADDR_VAR 0 4
13133: PUSH
13134: LD_INT 3
13136: ST_TO_ADDR
// end ; 5 :
13137: GO 13356
13139: LD_INT 5
13141: DOUBLE
13142: EQUAL
13143: IFTRUE 13147
13145: GO 13166
13147: POP
// begin a1 := 3 ;
13148: LD_ADDR_VAR 0 3
13152: PUSH
13153: LD_INT 3
13155: ST_TO_ADDR
// a2 := 6 ;
13156: LD_ADDR_VAR 0 4
13160: PUSH
13161: LD_INT 6
13163: ST_TO_ADDR
// end ; 6 :
13164: GO 13356
13166: LD_INT 6
13168: DOUBLE
13169: EQUAL
13170: IFTRUE 13174
13172: GO 13193
13174: POP
// begin a1 := 7 ;
13175: LD_ADDR_VAR 0 3
13179: PUSH
13180: LD_INT 7
13182: ST_TO_ADDR
// a2 := 3 ;
13183: LD_ADDR_VAR 0 4
13187: PUSH
13188: LD_INT 3
13190: ST_TO_ADDR
// end ; 7 :
13191: GO 13356
13193: LD_INT 7
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13220
13201: POP
// begin a1 := 8 ;
13202: LD_ADDR_VAR 0 3
13206: PUSH
13207: LD_INT 8
13209: ST_TO_ADDR
// a2 := 3 ;
13210: LD_ADDR_VAR 0 4
13214: PUSH
13215: LD_INT 3
13217: ST_TO_ADDR
// end ; 8 :
13218: GO 13356
13220: LD_INT 8
13222: DOUBLE
13223: EQUAL
13224: IFTRUE 13228
13226: GO 13247
13228: POP
// begin a1 := 2 ;
13229: LD_ADDR_VAR 0 3
13233: PUSH
13234: LD_INT 2
13236: ST_TO_ADDR
// a2 := 7 ;
13237: LD_ADDR_VAR 0 4
13241: PUSH
13242: LD_INT 7
13244: ST_TO_ADDR
// end ; 9 :
13245: GO 13356
13247: LD_INT 9
13249: DOUBLE
13250: EQUAL
13251: IFTRUE 13255
13253: GO 13274
13255: POP
// begin a1 := 2 ;
13256: LD_ADDR_VAR 0 3
13260: PUSH
13261: LD_INT 2
13263: ST_TO_ADDR
// a2 := 5 ;
13264: LD_ADDR_VAR 0 4
13268: PUSH
13269: LD_INT 5
13271: ST_TO_ADDR
// end ; 11 :
13272: GO 13356
13274: LD_INT 11
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13282
13280: GO 13301
13282: POP
// begin a1 := 1 ;
13283: LD_ADDR_VAR 0 3
13287: PUSH
13288: LD_INT 1
13290: ST_TO_ADDR
// a2 := 0 ;
13291: LD_ADDR_VAR 0 4
13295: PUSH
13296: LD_INT 0
13298: ST_TO_ADDR
// end ; 12 :
13299: GO 13356
13301: LD_INT 12
13303: DOUBLE
13304: EQUAL
13305: IFTRUE 13309
13307: GO 13328
13309: POP
// begin a1 := 5 ;
13310: LD_ADDR_VAR 0 3
13314: PUSH
13315: LD_INT 5
13317: ST_TO_ADDR
// a2 := 0 ;
13318: LD_ADDR_VAR 0 4
13322: PUSH
13323: LD_INT 0
13325: ST_TO_ADDR
// end ; 13 :
13326: GO 13356
13328: LD_INT 13
13330: DOUBLE
13331: EQUAL
13332: IFTRUE 13336
13334: GO 13355
13336: POP
// begin a1 := 9 ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 9
13344: ST_TO_ADDR
// a2 := 0 ;
13345: LD_ADDR_VAR 0 4
13349: PUSH
13350: LD_INT 0
13352: ST_TO_ADDR
// end ; end ;
13353: GO 13356
13355: POP
// v1 := [ a1 ] ;
13356: LD_ADDR_VAR 0 6
13360: PUSH
13361: LD_VAR 0 3
13365: PUSH
13366: EMPTY
13367: LIST
13368: ST_TO_ADDR
// if a2 then
13369: LD_VAR 0 4
13373: IFFALSE 13391
// v1 := v1 ^ a1 ;
13375: LD_ADDR_VAR 0 6
13379: PUSH
13380: LD_VAR 0 6
13384: PUSH
13385: LD_VAR 0 3
13389: ADD
13390: ST_TO_ADDR
// vysledek := v1 [ Rand ( 1 , v1 ) ] ;
13391: LD_ADDR_VAR 0 5
13395: PUSH
13396: LD_VAR 0 6
13400: PUSH
13401: LD_INT 1
13403: PPUSH
13404: LD_VAR 0 6
13408: PPUSH
13409: CALL_OW 12
13413: ARRAY
13414: ST_TO_ADDR
// result := vysledek ;
13415: LD_ADDR_VAR 0 2
13419: PUSH
13420: LD_VAR 0 5
13424: ST_TO_ADDR
// end ;
13425: LD_VAR 0 2
13429: RET
// function navrhni_startovni_pozici ; var s1 , s2 , s3 , vysledek ; var un , truck ; begin
13430: LD_INT 0
13432: PPUSH
13433: PPUSH
13434: PPUSH
13435: PPUSH
13436: PPUSH
13437: PPUSH
13438: PPUSH
// s1 := klic_area_1 ;
13439: LD_ADDR_VAR 0 2
13443: PUSH
13444: LD_LOC 18
13448: ST_TO_ADDR
// s2 := klic_area_9 ;
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: LD_LOC 26
13458: ST_TO_ADDR
// s3 := klic_area_5 ;
13459: LD_ADDR_VAR 0 4
13463: PUSH
13464: LD_LOC 22
13468: ST_TO_ADDR
// truck := true ;
13469: LD_ADDR_VAR 0 7
13473: PUSH
13474: LD_INT 1
13476: ST_TO_ADDR
// for un in attack_forces do
13477: LD_ADDR_VAR 0 6
13481: PUSH
13482: LD_EXP 55
13486: PUSH
13487: FOR_IN
13488: IFFALSE 13515
// if GetChassis ( un ) <> ru_heavy_tracked then
13490: LD_VAR 0 6
13494: PPUSH
13495: CALL_OW 265
13499: PUSH
13500: LD_INT 24
13502: NONEQUAL
13503: IFFALSE 13513
// truck := false ;
13505: LD_ADDR_VAR 0 7
13509: PUSH
13510: LD_INT 0
13512: ST_TO_ADDR
13513: GO 13487
13515: POP
13516: POP
// if ( a_jmeno ( s1 ) < a_jmeno ( s2 ) ) and ( a_jmeno ( s1 ) < a_jmeno ( s3 ) ) and truck then
13517: LD_VAR 0 2
13521: PPUSH
13522: CALL 12509 0 1
13526: PUSH
13527: LD_VAR 0 3
13531: PPUSH
13532: CALL 12509 0 1
13536: LESS
13537: PUSH
13538: LD_VAR 0 2
13542: PPUSH
13543: CALL 12509 0 1
13547: PUSH
13548: LD_VAR 0 4
13552: PPUSH
13553: CALL 12509 0 1
13557: LESS
13558: AND
13559: PUSH
13560: LD_VAR 0 7
13564: AND
13565: IFFALSE 13577
// vysledek := 1 else
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: LD_INT 1
13574: ST_TO_ADDR
13575: GO 13617
// if ( a_jmeno ( s2 ) < a_jmeno ( s3 ) ) then
13577: LD_VAR 0 3
13581: PPUSH
13582: CALL 12509 0 1
13586: PUSH
13587: LD_VAR 0 4
13591: PPUSH
13592: CALL 12509 0 1
13596: LESS
13597: IFFALSE 13609
// vysledek := 9 else
13599: LD_ADDR_VAR 0 5
13603: PUSH
13604: LD_INT 9
13606: ST_TO_ADDR
13607: GO 13617
// vysledek := 5 ;
13609: LD_ADDR_VAR 0 5
13613: PUSH
13614: LD_INT 5
13616: ST_TO_ADDR
// result := vysledek ;
13617: LD_ADDR_VAR 0 1
13621: PUSH
13622: LD_VAR 0 5
13626: ST_TO_ADDR
// end ;
13627: LD_VAR 0 1
13631: RET
// function vsichni_v_arei ( ktera_area ) ; var un , vysledek ; begin
13632: LD_INT 0
13634: PPUSH
13635: PPUSH
13636: PPUSH
// un := FilterUnitsInArea ( ktera_area , [ [ f_side , russians ] ] ) ;
13637: LD_ADDR_VAR 0 3
13641: PUSH
13642: LD_VAR 0 1
13646: PPUSH
13647: LD_INT 22
13649: PUSH
13650: LD_EXP 15
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: PUSH
13659: EMPTY
13660: LIST
13661: PPUSH
13662: CALL_OW 70
13666: ST_TO_ADDR
// if un >= ( ( attack_forces + 1 ) div 2 ) then
13667: LD_VAR 0 3
13671: PUSH
13672: LD_EXP 55
13676: PUSH
13677: LD_INT 1
13679: PLUS
13680: PUSH
13681: LD_INT 2
13683: DIV
13684: GREATEREQUAL
13685: IFFALSE 13697
// vysledek := true else
13687: LD_ADDR_VAR 0 4
13691: PUSH
13692: LD_INT 1
13694: ST_TO_ADDR
13695: GO 13705
// vysledek := false ;
13697: LD_ADDR_VAR 0 4
13701: PUSH
13702: LD_INT 0
13704: ST_TO_ADDR
// result := vysledek ;
13705: LD_ADDR_VAR 0 2
13709: PUSH
13710: LD_VAR 0 4
13714: ST_TO_ADDR
// end ;
13715: LD_VAR 0 2
13719: RET
// function see_important ( now_area ) ; var un , area , vysledek ; begin
13720: LD_INT 0
13722: PPUSH
13723: PPUSH
13724: PPUSH
13725: PPUSH
// vysledek := false ;
13726: LD_ADDR_VAR 0 5
13730: PUSH
13731: LD_INT 0
13733: ST_TO_ADDR
// area := [ ] ;
13734: LD_ADDR_VAR 0 4
13738: PUSH
13739: EMPTY
13740: ST_TO_ADDR
// for un in us_important do
13741: LD_ADDR_VAR 0 3
13745: PUSH
13746: LD_EXP 65
13750: PUSH
13751: FOR_IN
13752: IFFALSE 14061
// if See ( russians , un ) then
13754: LD_EXP 15
13758: PPUSH
13759: LD_VAR 0 3
13763: PPUSH
13764: CALL_OW 292
13768: IFFALSE 14059
// begin area := area ^ un ;
13770: LD_ADDR_VAR 0 4
13774: PUSH
13775: LD_VAR 0 4
13779: PUSH
13780: LD_VAR 0 3
13784: ADD
13785: ST_TO_ADDR
// case now_area of 1 :
13786: LD_VAR 0 1
13790: PUSH
13791: LD_INT 1
13793: DOUBLE
13794: EQUAL
13795: IFTRUE 13799
13797: GO 13818
13799: POP
// klic_area_1 := klic_area_1 union area ; 2 :
13800: LD_ADDR_LOC 18
13804: PUSH
13805: LD_LOC 18
13809: PUSH
13810: LD_VAR 0 4
13814: UNION
13815: ST_TO_ADDR
13816: GO 14035
13818: LD_INT 2
13820: DOUBLE
13821: EQUAL
13822: IFTRUE 13826
13824: GO 13845
13826: POP
// klic_area_2 := klic_area_2 union area ; 3 :
13827: LD_ADDR_LOC 19
13831: PUSH
13832: LD_LOC 19
13836: PUSH
13837: LD_VAR 0 4
13841: UNION
13842: ST_TO_ADDR
13843: GO 14035
13845: LD_INT 3
13847: DOUBLE
13848: EQUAL
13849: IFTRUE 13853
13851: GO 13872
13853: POP
// klic_area_3 := klic_area_3 union area ; 4 :
13854: LD_ADDR_LOC 20
13858: PUSH
13859: LD_LOC 20
13863: PUSH
13864: LD_VAR 0 4
13868: UNION
13869: ST_TO_ADDR
13870: GO 14035
13872: LD_INT 4
13874: DOUBLE
13875: EQUAL
13876: IFTRUE 13880
13878: GO 13899
13880: POP
// klic_area_4 := klic_area_4 union area ; 5 :
13881: LD_ADDR_LOC 21
13885: PUSH
13886: LD_LOC 21
13890: PUSH
13891: LD_VAR 0 4
13895: UNION
13896: ST_TO_ADDR
13897: GO 14035
13899: LD_INT 5
13901: DOUBLE
13902: EQUAL
13903: IFTRUE 13907
13905: GO 13926
13907: POP
// klic_area_5 := klic_area_5 union area ; 6 :
13908: LD_ADDR_LOC 22
13912: PUSH
13913: LD_LOC 22
13917: PUSH
13918: LD_VAR 0 4
13922: UNION
13923: ST_TO_ADDR
13924: GO 14035
13926: LD_INT 6
13928: DOUBLE
13929: EQUAL
13930: IFTRUE 13934
13932: GO 13953
13934: POP
// klic_area_6 := klic_area_6 union area ; 7 :
13935: LD_ADDR_LOC 23
13939: PUSH
13940: LD_LOC 23
13944: PUSH
13945: LD_VAR 0 4
13949: UNION
13950: ST_TO_ADDR
13951: GO 14035
13953: LD_INT 7
13955: DOUBLE
13956: EQUAL
13957: IFTRUE 13961
13959: GO 13980
13961: POP
// klic_area_7 := klic_area_7 union area ; 8 :
13962: LD_ADDR_LOC 24
13966: PUSH
13967: LD_LOC 24
13971: PUSH
13972: LD_VAR 0 4
13976: UNION
13977: ST_TO_ADDR
13978: GO 14035
13980: LD_INT 8
13982: DOUBLE
13983: EQUAL
13984: IFTRUE 13988
13986: GO 14007
13988: POP
// klic_area_8 := klic_area_8 union area ; 9 :
13989: LD_ADDR_LOC 25
13993: PUSH
13994: LD_LOC 25
13998: PUSH
13999: LD_VAR 0 4
14003: UNION
14004: ST_TO_ADDR
14005: GO 14035
14007: LD_INT 9
14009: DOUBLE
14010: EQUAL
14011: IFTRUE 14015
14013: GO 14034
14015: POP
// klic_area_9 := klic_area_9 union area ; end ;
14016: LD_ADDR_LOC 26
14020: PUSH
14021: LD_LOC 26
14025: PUSH
14026: LD_VAR 0 4
14030: UNION
14031: ST_TO_ADDR
14032: GO 14035
14034: POP
// destroy_now := destroy_now union un ;
14035: LD_ADDR_LOC 27
14039: PUSH
14040: LD_LOC 27
14044: PUSH
14045: LD_VAR 0 3
14049: UNION
14050: ST_TO_ADDR
// vysledek := true ;
14051: LD_ADDR_VAR 0 5
14055: PUSH
14056: LD_INT 1
14058: ST_TO_ADDR
// end ;
14059: GO 13751
14061: POP
14062: POP
// result := vysledek ;
14063: LD_ADDR_VAR 0 2
14067: PUSH
14068: LD_VAR 0 5
14072: ST_TO_ADDR
// end ;
14073: LD_VAR 0 2
14077: RET
// function destroy_important ( area ) ; var i , j , max , max_search ; var cil , prior_1 , prior_max ; begin
14078: LD_INT 0
14080: PPUSH
14081: PPUSH
14082: PPUSH
14083: PPUSH
14084: PPUSH
14085: PPUSH
14086: PPUSH
14087: PPUSH
// max_search := 3 ;
14088: LD_ADDR_VAR 0 6
14092: PUSH
14093: LD_INT 3
14095: ST_TO_ADDR
// max := 0 + destroy_now ;
14096: LD_ADDR_VAR 0 5
14100: PUSH
14101: LD_INT 0
14103: PUSH
14104: LD_LOC 27
14108: PLUS
14109: ST_TO_ADDR
// if max > 3 then
14110: LD_VAR 0 5
14114: PUSH
14115: LD_INT 3
14117: GREATER
14118: IFFALSE 14130
// j := 3 else
14120: LD_ADDR_VAR 0 4
14124: PUSH
14125: LD_INT 3
14127: ST_TO_ADDR
14128: GO 14140
// j := max ;
14130: LD_ADDR_VAR 0 4
14134: PUSH
14135: LD_VAR 0 5
14139: ST_TO_ADDR
// prior_max := [ 0 , 0 ] ;
14140: LD_ADDR_VAR 0 9
14144: PUSH
14145: LD_INT 0
14147: PUSH
14148: LD_INT 0
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: ST_TO_ADDR
// for i = 1 to j do
14155: LD_ADDR_VAR 0 3
14159: PUSH
14160: DOUBLE
14161: LD_INT 1
14163: DEC
14164: ST_TO_ADDR
14165: LD_VAR 0 4
14169: PUSH
14170: FOR_TO
14171: IFFALSE 14449
// begin prior_1 := 0 ;
14173: LD_ADDR_VAR 0 8
14177: PUSH
14178: LD_INT 0
14180: ST_TO_ADDR
// case GetBType ( destroy_now [ i ] ) of 33 :
14181: LD_LOC 27
14185: PUSH
14186: LD_VAR 0 3
14190: ARRAY
14191: PPUSH
14192: CALL_OW 266
14196: PUSH
14197: LD_INT 33
14199: DOUBLE
14200: EQUAL
14201: IFTRUE 14205
14203: GO 14216
14205: POP
// prior_1 := 4 ; 30 :
14206: LD_ADDR_VAR 0 8
14210: PUSH
14211: LD_INT 4
14213: ST_TO_ADDR
14214: GO 14301
14216: LD_INT 30
14218: DOUBLE
14219: EQUAL
14220: IFTRUE 14224
14222: GO 14235
14224: POP
// prior_1 := 4 ; 29 :
14225: LD_ADDR_VAR 0 8
14229: PUSH
14230: LD_INT 4
14232: ST_TO_ADDR
14233: GO 14301
14235: LD_INT 29
14237: DOUBLE
14238: EQUAL
14239: IFTRUE 14243
14241: GO 14254
14243: POP
// prior_1 := 3 ; 28 :
14244: LD_ADDR_VAR 0 8
14248: PUSH
14249: LD_INT 3
14251: ST_TO_ADDR
14252: GO 14301
14254: LD_INT 28
14256: DOUBLE
14257: EQUAL
14258: IFTRUE 14262
14260: GO 14273
14262: POP
// prior_1 := 3 ; 26 :
14263: LD_ADDR_VAR 0 8
14267: PUSH
14268: LD_INT 3
14270: ST_TO_ADDR
14271: GO 14301
14273: LD_INT 26
14275: DOUBLE
14276: EQUAL
14277: IFTRUE 14281
14279: GO 14292
14281: POP
// prior_1 := 2 ; else
14282: LD_ADDR_VAR 0 8
14286: PUSH
14287: LD_INT 2
14289: ST_TO_ADDR
14290: GO 14301
14292: POP
// prior_1 := 1 ; end ;
14293: LD_ADDR_VAR 0 8
14297: PUSH
14298: LD_INT 1
14300: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 750 then
14301: LD_LOC 27
14305: PUSH
14306: LD_VAR 0 3
14310: ARRAY
14311: PPUSH
14312: CALL_OW 256
14316: PUSH
14317: LD_INT 750
14319: LESS
14320: IFFALSE 14336
// prior_1 := prior_1 + 1 ;
14322: LD_ADDR_VAR 0 8
14326: PUSH
14327: LD_VAR 0 8
14331: PUSH
14332: LD_INT 1
14334: PLUS
14335: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 500 then
14336: LD_LOC 27
14340: PUSH
14341: LD_VAR 0 3
14345: ARRAY
14346: PPUSH
14347: CALL_OW 256
14351: PUSH
14352: LD_INT 500
14354: LESS
14355: IFFALSE 14371
// prior_1 := prior_1 + 2 ;
14357: LD_ADDR_VAR 0 8
14361: PUSH
14362: LD_VAR 0 8
14366: PUSH
14367: LD_INT 2
14369: PLUS
14370: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 250 then
14371: LD_LOC 27
14375: PUSH
14376: LD_VAR 0 3
14380: ARRAY
14381: PPUSH
14382: CALL_OW 256
14386: PUSH
14387: LD_INT 250
14389: LESS
14390: IFFALSE 14406
// prior_1 := prior_1 + 2 ;
14392: LD_ADDR_VAR 0 8
14396: PUSH
14397: LD_VAR 0 8
14401: PUSH
14402: LD_INT 2
14404: PLUS
14405: ST_TO_ADDR
// if prior_1 > prior_max [ 1 ] then
14406: LD_VAR 0 8
14410: PUSH
14411: LD_VAR 0 9
14415: PUSH
14416: LD_INT 1
14418: ARRAY
14419: GREATER
14420: IFFALSE 14447
// prior_max := [ prior_1 , destroy_now [ i ] ] ;
14422: LD_ADDR_VAR 0 9
14426: PUSH
14427: LD_VAR 0 8
14431: PUSH
14432: LD_LOC 27
14436: PUSH
14437: LD_VAR 0 3
14441: ARRAY
14442: PUSH
14443: EMPTY
14444: LIST
14445: LIST
14446: ST_TO_ADDR
// end ;
14447: GO 14170
14449: POP
14450: POP
// if prior_max [ 2 ] then
14451: LD_VAR 0 9
14455: PUSH
14456: LD_INT 2
14458: ARRAY
14459: IFFALSE 14502
// DestroyTarget ( prior_max [ 2 ] , GetX ( prior_max [ 2 ] ) , GetY ( prior_max [ 2 ] ) ) ;
14461: LD_VAR 0 9
14465: PUSH
14466: LD_INT 2
14468: ARRAY
14469: PPUSH
14470: LD_VAR 0 9
14474: PUSH
14475: LD_INT 2
14477: ARRAY
14478: PPUSH
14479: CALL_OW 250
14483: PPUSH
14484: LD_VAR 0 9
14488: PUSH
14489: LD_INT 2
14491: ARRAY
14492: PPUSH
14493: CALL_OW 251
14497: PPUSH
14498: CALL 14507 0 3
// end ;
14502: LD_VAR 0 2
14506: RET
// function DestroyTarget ( target , x , y ) ; var un ; begin
14507: LD_INT 0
14509: PPUSH
14510: PPUSH
// for un in attack_forces do
14511: LD_ADDR_VAR 0 5
14515: PUSH
14516: LD_EXP 55
14520: PUSH
14521: FOR_IN
14522: IFFALSE 14583
// if GetWeapon ( un ) in [ ru_rocket , ru_rocket_launcher ] then
14524: LD_VAR 0 5
14528: PPUSH
14529: CALL_OW 264
14533: PUSH
14534: LD_INT 47
14536: PUSH
14537: LD_INT 45
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: IN
14544: IFFALSE 14567
// ComAttackPlace ( un , x , y ) else
14546: LD_VAR 0 5
14550: PPUSH
14551: LD_VAR 0 2
14555: PPUSH
14556: LD_VAR 0 3
14560: PPUSH
14561: CALL_OW 116
14565: GO 14581
// ComAttackUnit ( un , target ) ;
14567: LD_VAR 0 5
14571: PPUSH
14572: LD_VAR 0 1
14576: PPUSH
14577: CALL_OW 115
14581: GO 14521
14583: POP
14584: POP
// end ;
14585: LD_VAR 0 4
14589: RET
// function konec_jednoho_utoku ; begin
14590: LD_INT 0
14592: PPUSH
// war_forces := war_forces ^ attack_forces ;
14593: LD_ADDR_EXP 52
14597: PUSH
14598: LD_EXP 52
14602: PUSH
14603: LD_EXP 55
14607: ADD
14608: ST_TO_ADDR
// attack_forces := [ ] ;
14609: LD_ADDR_EXP 55
14613: PUSH
14614: EMPTY
14615: ST_TO_ADDR
// attack_begin := false ;
14616: LD_ADDR_LOC 32
14620: PUSH
14621: LD_INT 0
14623: ST_TO_ADDR
// war_count := Rand ( cislo_utoku + 1 , cislo_utoku + 3 ) ;
14624: LD_ADDR_EXP 54
14628: PUSH
14629: LD_LOC 33
14633: PUSH
14634: LD_INT 1
14636: PLUS
14637: PPUSH
14638: LD_LOC 33
14642: PUSH
14643: LD_INT 3
14645: PLUS
14646: PPUSH
14647: CALL_OW 12
14651: ST_TO_ADDR
// if war_count > 4 then
14652: LD_EXP 54
14656: PUSH
14657: LD_INT 4
14659: GREATER
14660: IFFALSE 14678
// war_count := Rand ( 4 , 5 ) ;
14662: LD_ADDR_EXP 54
14666: PUSH
14667: LD_INT 4
14669: PPUSH
14670: LD_INT 5
14672: PPUSH
14673: CALL_OW 12
14677: ST_TO_ADDR
// end ;
14678: LD_VAR 0 1
14682: RET
// function low_cesta ; var i , max , areas , mc_id , new_destination ; begin
14683: LD_INT 0
14685: PPUSH
14686: PPUSH
14687: PPUSH
14688: PPUSH
14689: PPUSH
14690: PPUSH
// multi := false ;
14691: LD_ADDR_LOC 29
14695: PUSH
14696: LD_INT 0
14698: ST_TO_ADDR
// attack_begin := false ;
14699: LD_ADDR_LOC 32
14703: PUSH
14704: LD_INT 0
14706: ST_TO_ADDR
// max := 0 + attack_forces ;
14707: LD_ADDR_VAR 0 3
14711: PUSH
14712: LD_INT 0
14714: PUSH
14715: LD_EXP 55
14719: PLUS
14720: ST_TO_ADDR
// destroy_now := [ ] ;
14721: LD_ADDR_LOC 27
14725: PUSH
14726: EMPTY
14727: ST_TO_ADDR
// if cislo_utoku > 1 then
14728: LD_LOC 33
14732: PUSH
14733: LD_INT 1
14735: GREATER
14736: IFFALSE 14750
// now_area := navrhni_startovni_pozici else
14738: LD_ADDR_LOC 34
14742: PUSH
14743: CALL 13430 0 0
14747: ST_TO_ADDR
14748: GO 14758
// now_area := 1 ;
14750: LD_ADDR_LOC 34
14754: PUSH
14755: LD_INT 1
14757: ST_TO_ADDR
// case now_area of 1 :
14758: LD_LOC 34
14762: PUSH
14763: LD_INT 1
14765: DOUBLE
14766: EQUAL
14767: IFTRUE 14771
14769: GO 14778
14771: POP
// goto_north_sector ; 9 :
14772: CALL 12762 0 0
14776: GO 14809
14778: LD_INT 9
14780: DOUBLE
14781: EQUAL
14782: IFTRUE 14786
14784: GO 14793
14786: POP
// goto_east_sector ; 5 :
14787: CALL 12848 0 0
14791: GO 14809
14793: LD_INT 5
14795: DOUBLE
14796: EQUAL
14797: IFTRUE 14801
14799: GO 14808
14801: POP
// goto_south_sector ; end ;
14802: CALL 12933 0 0
14806: GO 14809
14808: POP
// repeat wait ( 0 0$1 ) ;
14809: LD_INT 35
14811: PPUSH
14812: CALL_OW 67
// until attack_begin ;
14816: LD_LOC 32
14820: IFFALSE 14809
// mc_id := 0 ;
14822: LD_ADDR_VAR 0 5
14826: PUSH
14827: LD_INT 0
14829: ST_TO_ADDR
// repeat next_area := zjisti_schudne_okoli ( now_area ) ;
14830: LD_ADDR_LOC 35
14834: PUSH
14835: LD_LOC 34
14839: PPUSH
14840: CALL 13018 0 1
14844: ST_TO_ADDR
// new_destination := zjisti_cilove_misto ( next_area ) ;
14845: LD_ADDR_VAR 0 6
14849: PUSH
14850: LD_LOC 35
14854: PPUSH
14855: CALL 12250 0 1
14859: ST_TO_ADDR
// repeat if see_important ( now_area ) then
14860: LD_LOC 34
14864: PPUSH
14865: CALL 13720 0 1
14869: IFFALSE 14910
// begin if ExistMc ( mc_id ) then
14871: LD_VAR 0 5
14875: PPUSH
14876: CALL_OW 386
14880: IFFALSE 14899
// begin KillMc ( mc_id ) ;
14882: LD_VAR 0 5
14886: PPUSH
14887: CALL_OW 387
// mc_id := 0 ;
14891: LD_ADDR_VAR 0 5
14895: PUSH
14896: LD_INT 0
14898: ST_TO_ADDR
// end ; destroy_important ( now_area ) ;
14899: LD_LOC 34
14903: PPUSH
14904: CALL 14078 0 1
// end else
14908: GO 14967
// if not ExistMc ( mc_id ) then
14910: LD_VAR 0 5
14914: PPUSH
14915: CALL_OW 386
14919: NOT
14920: IFFALSE 14967
// mc_id := McMove ( 2 , attack_forces , [ [ new_destination [ 1 ] , new_destination [ 2 ] ] ] , [ ] ) ;
14922: LD_ADDR_VAR 0 5
14926: PUSH
14927: LD_INT 2
14929: PPUSH
14930: LD_EXP 55
14934: PPUSH
14935: LD_VAR 0 6
14939: PUSH
14940: LD_INT 1
14942: ARRAY
14943: PUSH
14944: LD_VAR 0 6
14948: PUSH
14949: LD_INT 2
14951: ARRAY
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: EMPTY
14958: LIST
14959: PPUSH
14960: EMPTY
14961: PPUSH
14962: CALL_OW 398
14966: ST_TO_ADDR
// wait ( 0 0$3 ) ;
14967: LD_INT 105
14969: PPUSH
14970: CALL_OW 67
// until vsichni_v_arei ( a_jmeno ( next_area ) ) or ( not attack_forces ) ;
14974: LD_LOC 35
14978: PPUSH
14979: CALL 12509 0 1
14983: PPUSH
14984: CALL 13632 0 1
14988: PUSH
14989: LD_EXP 55
14993: NOT
14994: OR
14995: IFFALSE 14860
// now_area := next_area ;
14997: LD_ADDR_LOC 34
15001: PUSH
15002: LD_LOC 35
15006: ST_TO_ADDR
// until not attack_forces ;
15007: LD_EXP 55
15011: NOT
15012: IFFALSE 14830
// konec_jednoho_utoku ;
15014: CALL 14590 0 0
// cislo_utoku := cislo_utoku + 1 ;
15018: LD_ADDR_LOC 33
15022: PUSH
15023: LD_LOC 33
15027: PUSH
15028: LD_INT 1
15030: PLUS
15031: ST_TO_ADDR
// end ;
15032: LD_VAR 0 1
15036: RET
// function nacti_important_budovy ; var list_important , un ; begin
15037: LD_INT 0
15039: PPUSH
15040: PPUSH
15041: PPUSH
// us_important := [ ] ;
15042: LD_ADDR_EXP 65
15046: PUSH
15047: EMPTY
15048: ST_TO_ADDR
// list_important := FilterAllUnits ( [ [ f_or , [ f_side , you ] , [ f_side , neutral ] ] , [ f_type , unit_building ] ] ) ;
15049: LD_ADDR_VAR 0 2
15053: PUSH
15054: LD_INT 2
15056: PUSH
15057: LD_INT 22
15059: PUSH
15060: LD_EXP 14
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: LD_INT 22
15071: PUSH
15072: LD_EXP 16
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: PUSH
15081: EMPTY
15082: LIST
15083: LIST
15084: LIST
15085: PUSH
15086: LD_INT 21
15088: PUSH
15089: LD_INT 3
15091: PUSH
15092: EMPTY
15093: LIST
15094: LIST
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: PPUSH
15100: CALL_OW 69
15104: ST_TO_ADDR
// important := [ b_depot , b_warehouse , b_factory , b_armoury , b_barracks , b_lab_full , b_oil_power , b_solar_power , b_siberite_power , b_oil_mine , b_siberite_mine , b_breastwork , b_bunker , b_turret ] ;
15105: LD_ADDR_LOC 28
15109: PUSH
15110: LD_INT 0
15112: PUSH
15113: LD_INT 1
15115: PUSH
15116: LD_INT 3
15118: PUSH
15119: LD_INT 4
15121: PUSH
15122: LD_INT 5
15124: PUSH
15125: LD_INT 8
15127: PUSH
15128: LD_INT 26
15130: PUSH
15131: LD_INT 27
15133: PUSH
15134: LD_INT 28
15136: PUSH
15137: LD_INT 29
15139: PUSH
15140: LD_INT 30
15142: PUSH
15143: LD_INT 31
15145: PUSH
15146: LD_INT 32
15148: PUSH
15149: LD_INT 33
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: ST_TO_ADDR
// for un in list_important do
15168: LD_ADDR_VAR 0 3
15172: PUSH
15173: LD_VAR 0 2
15177: PUSH
15178: FOR_IN
15179: IFFALSE 15216
// begin if GetBType ( un ) in important then
15181: LD_VAR 0 3
15185: PPUSH
15186: CALL_OW 266
15190: PUSH
15191: LD_LOC 28
15195: IN
15196: IFFALSE 15214
// us_important := us_important ^ un ;
15198: LD_ADDR_EXP 65
15202: PUSH
15203: LD_EXP 65
15207: PUSH
15208: LD_VAR 0 3
15212: ADD
15213: ST_TO_ADDR
// end ;
15214: GO 15178
15216: POP
15217: POP
// end ;
15218: LD_VAR 0 1
15222: RET
// on UnitGoesToRed ( jednotka ) do begin event_unit := jednotka ;
15223: LD_ADDR_LOC 36
15227: PUSH
15228: LD_VAR 0 1
15232: ST_TO_ADDR
// if jednotka in attack_forces then
15233: LD_VAR 0 1
15237: PUSH
15238: LD_EXP 55
15242: IN
15243: IFFALSE 15281
// begin attack_forces := attack_forces diff [ jednotka ] ;
15245: LD_ADDR_EXP 55
15249: PUSH
15250: LD_EXP 55
15254: PUSH
15255: LD_VAR 0 1
15259: PUSH
15260: EMPTY
15261: LIST
15262: DIFF
15263: ST_TO_ADDR
// if ( not attack_forces ) and ( attack_begin ) then
15264: LD_EXP 55
15268: NOT
15269: PUSH
15270: LD_LOC 32
15274: AND
15275: IFFALSE 15281
// konec_jednoho_utoku ;
15277: CALL 14590 0 0
// end ; if ( ( jednotka = MacMillan ) and ( not IsOK ( survivor ) ) ) or ( ( jednotka = MacMillan ) and ( not visit_base ) ) then
15281: LD_VAR 0 1
15285: PUSH
15286: LD_EXP 1
15290: EQUAL
15291: PUSH
15292: LD_EXP 6
15296: PPUSH
15297: CALL_OW 302
15301: NOT
15302: AND
15303: PUSH
15304: LD_VAR 0 1
15308: PUSH
15309: LD_EXP 1
15313: EQUAL
15314: PUSH
15315: LD_EXP 34
15319: NOT
15320: AND
15321: OR
15322: IFFALSE 15328
// konec_mise ;
15324: CALL 755 0 0
// end ;
15328: PPOPN 1
15330: END
// on UnitDestroyed ( jednotka ) do var pomocna_mnozina ;
15331: LD_INT 0
15333: PPUSH
// begin event_unit := jednotka ;
15334: LD_ADDR_LOC 36
15338: PUSH
15339: LD_VAR 0 1
15343: ST_TO_ADDR
// attack_forces := attack_forces diff [ jednotka ] ;
15344: LD_ADDR_EXP 55
15348: PUSH
15349: LD_EXP 55
15353: PUSH
15354: LD_VAR 0 1
15358: PUSH
15359: EMPTY
15360: LIST
15361: DIFF
15362: ST_TO_ADDR
// us_important := us_important diff [ jednotka ] ;
15363: LD_ADDR_EXP 65
15367: PUSH
15368: LD_EXP 65
15372: PUSH
15373: LD_VAR 0 1
15377: PUSH
15378: EMPTY
15379: LIST
15380: DIFF
15381: ST_TO_ADDR
// destroy_now := destroy_now diff [ jednotka ] ;
15382: LD_ADDR_LOC 27
15386: PUSH
15387: LD_LOC 27
15391: PUSH
15392: LD_VAR 0 1
15396: PUSH
15397: EMPTY
15398: LIST
15399: DIFF
15400: ST_TO_ADDR
// case now_area of 1 :
15401: LD_LOC 34
15405: PUSH
15406: LD_INT 1
15408: DOUBLE
15409: EQUAL
15410: IFTRUE 15414
15412: GO 15436
15414: POP
// klic_area_1 := klic_area_1 diff [ jednotka ] ; 2 :
15415: LD_ADDR_LOC 18
15419: PUSH
15420: LD_LOC 18
15424: PUSH
15425: LD_VAR 0 1
15429: PUSH
15430: EMPTY
15431: LIST
15432: DIFF
15433: ST_TO_ADDR
15434: GO 15677
15436: LD_INT 2
15438: DOUBLE
15439: EQUAL
15440: IFTRUE 15444
15442: GO 15466
15444: POP
// klic_area_2 := klic_area_2 diff [ jednotka ] ; 3 :
15445: LD_ADDR_LOC 19
15449: PUSH
15450: LD_LOC 19
15454: PUSH
15455: LD_VAR 0 1
15459: PUSH
15460: EMPTY
15461: LIST
15462: DIFF
15463: ST_TO_ADDR
15464: GO 15677
15466: LD_INT 3
15468: DOUBLE
15469: EQUAL
15470: IFTRUE 15474
15472: GO 15496
15474: POP
// klic_area_3 := klic_area_3 diff [ jednotka ] ; 4 :
15475: LD_ADDR_LOC 20
15479: PUSH
15480: LD_LOC 20
15484: PUSH
15485: LD_VAR 0 1
15489: PUSH
15490: EMPTY
15491: LIST
15492: DIFF
15493: ST_TO_ADDR
15494: GO 15677
15496: LD_INT 4
15498: DOUBLE
15499: EQUAL
15500: IFTRUE 15504
15502: GO 15526
15504: POP
// klic_area_4 := klic_area_4 diff [ jednotka ] ; 5 :
15505: LD_ADDR_LOC 21
15509: PUSH
15510: LD_LOC 21
15514: PUSH
15515: LD_VAR 0 1
15519: PUSH
15520: EMPTY
15521: LIST
15522: DIFF
15523: ST_TO_ADDR
15524: GO 15677
15526: LD_INT 5
15528: DOUBLE
15529: EQUAL
15530: IFTRUE 15534
15532: GO 15556
15534: POP
// klic_area_5 := klic_area_5 diff [ jednotka ] ; 6 :
15535: LD_ADDR_LOC 22
15539: PUSH
15540: LD_LOC 22
15544: PUSH
15545: LD_VAR 0 1
15549: PUSH
15550: EMPTY
15551: LIST
15552: DIFF
15553: ST_TO_ADDR
15554: GO 15677
15556: LD_INT 6
15558: DOUBLE
15559: EQUAL
15560: IFTRUE 15564
15562: GO 15586
15564: POP
// klic_area_6 := klic_area_6 diff [ jednotka ] ; 7 :
15565: LD_ADDR_LOC 23
15569: PUSH
15570: LD_LOC 23
15574: PUSH
15575: LD_VAR 0 1
15579: PUSH
15580: EMPTY
15581: LIST
15582: DIFF
15583: ST_TO_ADDR
15584: GO 15677
15586: LD_INT 7
15588: DOUBLE
15589: EQUAL
15590: IFTRUE 15594
15592: GO 15616
15594: POP
// klic_area_7 := klic_area_7 diff [ jednotka ] ; 8 :
15595: LD_ADDR_LOC 24
15599: PUSH
15600: LD_LOC 24
15604: PUSH
15605: LD_VAR 0 1
15609: PUSH
15610: EMPTY
15611: LIST
15612: DIFF
15613: ST_TO_ADDR
15614: GO 15677
15616: LD_INT 8
15618: DOUBLE
15619: EQUAL
15620: IFTRUE 15624
15622: GO 15646
15624: POP
// klic_area_8 := klic_area_8 diff [ jednotka ] ; 9 :
15625: LD_ADDR_LOC 25
15629: PUSH
15630: LD_LOC 25
15634: PUSH
15635: LD_VAR 0 1
15639: PUSH
15640: EMPTY
15641: LIST
15642: DIFF
15643: ST_TO_ADDR
15644: GO 15677
15646: LD_INT 9
15648: DOUBLE
15649: EQUAL
15650: IFTRUE 15654
15652: GO 15676
15654: POP
// klic_area_9 := klic_area_9 diff [ jednotka ] ; end ;
15655: LD_ADDR_LOC 26
15659: PUSH
15660: LD_LOC 26
15664: PUSH
15665: LD_VAR 0 1
15669: PUSH
15670: EMPTY
15671: LIST
15672: DIFF
15673: ST_TO_ADDR
15674: GO 15677
15676: POP
// if jednotka = macmillan then
15677: LD_VAR 0 1
15681: PUSH
15682: LD_EXP 1
15686: EQUAL
15687: IFFALSE 15693
// konec_mise ;
15689: CALL 755 0 0
// if ( not attack_forces ) and ( attack_begin ) then
15693: LD_EXP 55
15697: NOT
15698: PUSH
15699: LD_LOC 32
15703: AND
15704: IFFALSE 15710
// konec_jednoho_utoku ;
15706: CALL 14590 0 0
// if GetSide ( jednotka ) = russians then
15710: LD_VAR 0 1
15714: PPUSH
15715: CALL_OW 255
15719: PUSH
15720: LD_EXP 15
15724: EQUAL
15725: IFFALSE 15814
// begin russians_forces := russians_forces diff jednotka ;
15727: LD_ADDR_EXP 28
15731: PUSH
15732: LD_EXP 28
15736: PUSH
15737: LD_VAR 0 1
15741: DIFF
15742: ST_TO_ADDR
// ru_ing := ru_ing diff jednotka ;
15743: LD_ADDR_EXP 24
15747: PUSH
15748: LD_EXP 24
15752: PUSH
15753: LD_VAR 0 1
15757: DIFF
15758: ST_TO_ADDR
// ru_sol := ru_sol diff jednotka ;
15759: LD_ADDR_EXP 25
15763: PUSH
15764: LD_EXP 25
15768: PUSH
15769: LD_VAR 0 1
15773: DIFF
15774: ST_TO_ADDR
// ru_sci := ru_sci diff jednotka ;
15775: LD_ADDR_EXP 26
15779: PUSH
15780: LD_EXP 26
15784: PUSH
15785: LD_VAR 0 1
15789: DIFF
15790: ST_TO_ADDR
// ru_mec := ru_mec diff jednotka ;
15791: LD_ADDR_EXP 27
15795: PUSH
15796: LD_EXP 27
15800: PUSH
15801: LD_VAR 0 1
15805: DIFF
15806: ST_TO_ADDR
// reserved_people := [ ] ;
15807: LD_ADDR_EXP 31
15811: PUSH
15812: EMPTY
15813: ST_TO_ADDR
// end ; end ;
15814: PPOPN 2
15816: END
// on VehicleCaptured ( veh_new , veh_old , veh_orig , veh_hum ) do begin if GetSide ( veh_old ) = russians then
15817: LD_VAR 0 2
15821: PPUSH
15822: CALL_OW 255
15826: PUSH
15827: LD_EXP 15
15831: EQUAL
15832: IFFALSE 15872
// begin war_forces := war_forces diff [ veh_old ] ;
15834: LD_ADDR_EXP 52
15838: PUSH
15839: LD_EXP 52
15843: PUSH
15844: LD_VAR 0 2
15848: PUSH
15849: EMPTY
15850: LIST
15851: DIFF
15852: ST_TO_ADDR
// attack_forces := attack_forces diff [ veh_old ] ;
15853: LD_ADDR_EXP 55
15857: PUSH
15858: LD_EXP 55
15862: PUSH
15863: LD_VAR 0 2
15867: PUSH
15868: EMPTY
15869: LIST
15870: DIFF
15871: ST_TO_ADDR
// end ; if ( not attack_forces ) and ( attack_begin ) then
15872: LD_EXP 55
15876: NOT
15877: PUSH
15878: LD_LOC 32
15882: AND
15883: IFFALSE 15889
// konec_jednoho_utoku ;
15885: CALL 14590 0 0
// end ;
15889: PPOPN 4
15891: END
// on BuildingComplete ( jednotka ) do begin if GetBType ( jednotka ) in important then
15892: LD_VAR 0 1
15896: PPUSH
15897: CALL_OW 266
15901: PUSH
15902: LD_LOC 28
15906: IN
15907: IFFALSE 15925
// us_important := us_important ^ jednotka ;
15909: LD_ADDR_EXP 65
15913: PUSH
15914: LD_EXP 65
15918: PUSH
15919: LD_VAR 0 1
15923: ADD
15924: ST_TO_ADDR
// end ;
15925: PPOPN 1
15927: END
// function multi_cesta ; begin
15928: LD_INT 0
15930: PPUSH
// multi := true ;
15931: LD_ADDR_LOC 29
15935: PUSH
15936: LD_INT 1
15938: ST_TO_ADDR
// end ;
15939: LD_VAR 0 1
15943: RET
// every 0 0$45 trigger ( war_forces >= war_count ) and ( not attack_begin ) do var list , un ;
15944: LD_EXP 52
15948: PUSH
15949: LD_EXP 54
15953: GREATEREQUAL
15954: PUSH
15955: LD_LOC 32
15959: NOT
15960: AND
15961: IFFALSE 16069
15963: GO 15965
15965: DISABLE
15966: LD_INT 0
15968: PPUSH
15969: PPUSH
// begin list := [ ] ;
15970: LD_ADDR_VAR 0 1
15974: PUSH
15975: EMPTY
15976: ST_TO_ADDR
// for un in war_forces do
15977: LD_ADDR_VAR 0 2
15981: PUSH
15982: LD_EXP 52
15986: PUSH
15987: FOR_IN
15988: IFFALSE 16020
// if un in defend_forces then
15990: LD_VAR 0 2
15994: PUSH
15995: LD_EXP 64
15999: IN
16000: IFFALSE 16018
// list := list ^ un ;
16002: LD_ADDR_VAR 0 1
16006: PUSH
16007: LD_VAR 0 1
16011: PUSH
16012: LD_VAR 0 2
16016: ADD
16017: ST_TO_ADDR
16018: GO 15987
16020: POP
16021: POP
// if ( war_forces diff list ) < war_count then
16022: LD_EXP 52
16026: PUSH
16027: LD_VAR 0 1
16031: DIFF
16032: PUSH
16033: LD_EXP 54
16037: LESS
16038: IFFALSE 16043
// begin enable ;
16040: ENABLE
// exit ;
16041: GO 16069
// end ; attack_forces := war_forces ;
16043: LD_ADDR_EXP 55
16047: PUSH
16048: LD_EXP 52
16052: ST_TO_ADDR
// war_forces := [ ] ;
16053: LD_ADDR_EXP 52
16057: PUSH
16058: EMPTY
16059: ST_TO_ADDR
// nacti_important_budovy ;
16060: CALL 15037 0 0
// low_cesta ;
16064: CALL 14683 0 0
// enable ;
16068: ENABLE
// end ;
16069: PPOPN 2
16071: END
// every 0 0$5 trigger attack_forces > 0 do var un , puvodni_velikost ;
16072: LD_EXP 55
16076: PUSH
16077: LD_INT 0
16079: GREATER
16080: IFFALSE 16171
16082: GO 16084
16084: DISABLE
16085: LD_INT 0
16087: PPUSH
16088: PPUSH
// begin puvodni_velikost := 0 + attack_forces ;
16089: LD_ADDR_VAR 0 2
16093: PUSH
16094: LD_INT 0
16096: PUSH
16097: LD_EXP 55
16101: PLUS
16102: ST_TO_ADDR
// for un in attack_forces do
16103: LD_ADDR_VAR 0 1
16107: PUSH
16108: LD_EXP 55
16112: PUSH
16113: FOR_IN
16114: IFFALSE 16146
// if not IsOK ( un ) then
16116: LD_VAR 0 1
16120: PPUSH
16121: CALL_OW 302
16125: NOT
16126: IFFALSE 16144
// attack_forces := attack_forces diff un ;
16128: LD_ADDR_EXP 55
16132: PUSH
16133: LD_EXP 55
16137: PUSH
16138: LD_VAR 0 1
16142: DIFF
16143: ST_TO_ADDR
16144: GO 16113
16146: POP
16147: POP
// if ( attack_forces = [ ] ) and ( puvodni_velikost > 0 ) then
16148: LD_EXP 55
16152: PUSH
16153: EMPTY
16154: EQUAL
16155: PUSH
16156: LD_VAR 0 2
16160: PUSH
16161: LD_INT 0
16163: GREATER
16164: AND
16165: IFFALSE 16171
// konec_jednoho_utoku ;
16167: CALL 14590 0 0
// end ; end_of_file
16171: PPOPN 2
16173: END
// var id_reg , id_def ; function prepare_defend ( side ) ; var def_u ; begin
16174: LD_INT 0
16176: PPUSH
16177: PPUSH
// def_u := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_building ] , [ f_btype , b_turret ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_type , unit_vehicle ] ] ] ) ;
16178: LD_ADDR_VAR 0 3
16182: PUSH
16183: LD_INT 22
16185: PUSH
16186: LD_VAR 0 1
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PUSH
16195: LD_INT 2
16197: PUSH
16198: LD_INT 21
16200: PUSH
16201: LD_INT 3
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PUSH
16208: LD_INT 30
16210: PUSH
16211: LD_INT 33
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PUSH
16218: LD_INT 30
16220: PUSH
16221: LD_INT 32
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: LD_INT 30
16230: PUSH
16231: LD_INT 31
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: EMPTY
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: PUSH
16244: LD_INT 21
16246: PUSH
16247: LD_INT 2
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: LIST
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PPUSH
16263: CALL_OW 69
16267: ST_TO_ADDR
// def_u := def_u union ru_sol ;
16268: LD_ADDR_VAR 0 3
16272: PUSH
16273: LD_VAR 0 3
16277: PUSH
16278: LD_EXP 25
16282: UNION
16283: ST_TO_ADDR
// def_u := def_u diff reserved_people ;
16284: LD_ADDR_VAR 0 3
16288: PUSH
16289: LD_VAR 0 3
16293: PUSH
16294: LD_EXP 31
16298: DIFF
16299: ST_TO_ADDR
// def_u := def_u diff ru_collector ;
16300: LD_ADDR_VAR 0 3
16304: PUSH
16305: LD_VAR 0 3
16309: PUSH
16310: LD_EXP 29
16314: DIFF
16315: ST_TO_ADDR
// def_u := ( def_u union war_forces ) union backup_forces ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_VAR 0 3
16325: PUSH
16326: LD_EXP 52
16330: UNION
16331: PUSH
16332: LD_EXP 56
16336: UNION
16337: ST_TO_ADDR
// def_u := def_u union manual_forces ;
16338: LD_ADDR_VAR 0 3
16342: PUSH
16343: LD_VAR 0 3
16347: PUSH
16348: LD_EXP 59
16352: UNION
16353: ST_TO_ADDR
// result := def_u ;
16354: LD_ADDR_VAR 0 2
16358: PUSH
16359: LD_VAR 0 3
16363: ST_TO_ADDR
// end ;
16364: LD_VAR 0 2
16368: RET
// export function start_defend ; var side ; begin
16369: LD_INT 0
16371: PPUSH
16372: PPUSH
// id_reg := McRegistry ( 3 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , ru_defend ] , [ mc_reg_area_to_protect , ru_defend ] , [ mc_reg_units_to_protect , prepare_defend ( russians ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
16373: LD_ADDR_LOC 37
16377: PUSH
16378: LD_INT 3
16380: PPUSH
16381: LD_INT 1
16383: PUSH
16384: LD_INT 35
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: LD_INT 5
16393: PUSH
16394: LD_INT 140
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PUSH
16401: LD_INT 2
16403: PUSH
16404: LD_INT 27
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 3
16413: PUSH
16414: LD_INT 27
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: LD_INT 4
16423: PUSH
16424: LD_EXP 15
16428: PPUSH
16429: CALL 16174 0 1
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: PUSH
16438: LD_INT 8
16440: PUSH
16441: LD_INT 7
16443: NEG
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PPUSH
16454: CALL_OW 399
16458: ST_TO_ADDR
// id_def := McDefend ( 100 , id_reg , prepare_defend ( russians ) , [ [ mc_def_advantage , 500 ] , [ mc_area_dont_leave , ru_base ] , [ mc_retreat_area_people , ru_heal ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
16459: LD_ADDR_LOC 38
16463: PUSH
16464: LD_INT 100
16466: PPUSH
16467: LD_LOC 37
16471: PPUSH
16472: LD_EXP 15
16476: PPUSH
16477: CALL 16174 0 1
16481: PPUSH
16482: LD_INT 1
16484: PUSH
16485: LD_INT 500
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 2
16494: PUSH
16495: LD_INT 2
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: LD_INT 7
16504: PUSH
16505: LD_INT 28
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 5
16514: PUSH
16515: LD_INT 600
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: PPUSH
16528: CALL_OW 401
16532: ST_TO_ADDR
// end ;
16533: LD_VAR 0 1
16537: RET
// on McRegistryResultChanges ( mcid , n , s ) do begin if n then
16538: LD_VAR 0 2
16542: IFFALSE 16567
// begin AddMcUnits ( mcid , prepare_defend ( russians ) ) ;
16544: LD_VAR 0 1
16548: PPUSH
16549: LD_EXP 15
16553: PPUSH
16554: CALL 16174 0 1
16558: PPUSH
16559: CALL_OW 390
// SendForces ;
16563: CALL 16813 0 0
// end ; end ;
16567: PPOPN 3
16569: END
// every 0 0$5 do var side , sci , list ;
16570: GO 16572
16572: DISABLE
16573: LD_INT 0
16575: PPUSH
16576: PPUSH
16577: PPUSH
// begin list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 950 ] ] ] ) ;
16578: LD_ADDR_VAR 0 3
16582: PUSH
16583: LD_INT 28
16585: PPUSH
16586: LD_INT 22
16588: PUSH
16589: LD_EXP 15
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: PUSH
16598: LD_INT 21
16600: PUSH
16601: LD_INT 1
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: PUSH
16608: LD_INT 3
16610: PUSH
16611: LD_INT 24
16613: PUSH
16614: LD_INT 950
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: LIST
16629: PPUSH
16630: CALL_OW 70
16634: ST_TO_ADDR
// if list then
16635: LD_VAR 0 3
16639: IFFALSE 16809
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
16641: LD_ADDR_VAR 0 2
16645: PUSH
16646: LD_INT 22
16648: PUSH
16649: LD_EXP 15
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 25
16660: PUSH
16661: LD_INT 4
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PPUSH
16672: CALL_OW 69
16676: ST_TO_ADDR
// ComRemember ( sci ) ;
16677: LD_VAR 0 2
16681: PPUSH
16682: CALL_OW 143
// wait ( 5 ) ;
16686: LD_INT 5
16688: PPUSH
16689: CALL_OW 67
// ComMoveToArea ( sci , ru_heal ) ;
16693: LD_VAR 0 2
16697: PPUSH
16698: LD_INT 28
16700: PPUSH
16701: CALL_OW 113
// repeat list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
16705: LD_ADDR_VAR 0 3
16709: PUSH
16710: LD_INT 28
16712: PPUSH
16713: LD_INT 22
16715: PUSH
16716: LD_EXP 15
16720: PUSH
16721: EMPTY
16722: LIST
16723: LIST
16724: PUSH
16725: LD_INT 21
16727: PUSH
16728: LD_INT 1
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: PUSH
16735: LD_INT 3
16737: PUSH
16738: LD_INT 24
16740: PUSH
16741: LD_INT 1000
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: EMPTY
16749: LIST
16750: LIST
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: LIST
16756: PPUSH
16757: CALL_OW 70
16761: ST_TO_ADDR
// if list then
16762: LD_VAR 0 3
16766: IFFALSE 16786
// AddComHeal ( sci , list [ 1 ] ) ;
16768: LD_VAR 0 2
16772: PPUSH
16773: LD_VAR 0 3
16777: PUSH
16778: LD_INT 1
16780: ARRAY
16781: PPUSH
16782: CALL_OW 188
// wait ( 0 0$2 ) ;
16786: LD_INT 70
16788: PPUSH
16789: CALL_OW 67
// until not list ;
16793: LD_VAR 0 3
16797: NOT
16798: IFFALSE 16705
// ComReturn ( sci ) ;
16800: LD_VAR 0 2
16804: PPUSH
16805: CALL_OW 144
// end ; enable ;
16809: ENABLE
// end ;
16810: PPOPN 3
16812: END
// function SendForces ; var list , target ; begin
16813: LD_INT 0
16815: PPUSH
16816: PPUSH
16817: PPUSH
// ComRemember ( war_forces ) ;
16818: LD_EXP 52
16822: PPUSH
16823: CALL_OW 143
// ComRemember ( backup_forces ) ;
16827: LD_EXP 56
16831: PPUSH
16832: CALL_OW 143
// repeat list := FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) ;
16836: LD_ADDR_VAR 0 2
16840: PUSH
16841: LD_INT 33
16843: PPUSH
16844: LD_INT 22
16846: PUSH
16847: LD_EXP 14
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 50
16858: PUSH
16859: EMPTY
16860: LIST
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PPUSH
16866: CALL_OW 70
16870: ST_TO_ADDR
// defend_forces := war_forces union backup_forces ;
16871: LD_ADDR_EXP 64
16875: PUSH
16876: LD_EXP 52
16880: PUSH
16881: LD_EXP 56
16885: UNION
16886: ST_TO_ADDR
// target := NearestUnitToUnit ( list , ru_depot ) ;
16887: LD_ADDR_VAR 0 3
16891: PUSH
16892: LD_VAR 0 2
16896: PPUSH
16897: LD_INT 22
16899: PPUSH
16900: CALL_OW 74
16904: ST_TO_ADDR
// ComAttackPlace ( defend_forces , GetX ( target ) , GetY ( target ) ) ;
16905: LD_EXP 64
16909: PPUSH
16910: LD_VAR 0 3
16914: PPUSH
16915: CALL_OW 250
16919: PPUSH
16920: LD_VAR 0 3
16924: PPUSH
16925: CALL_OW 251
16929: PPUSH
16930: CALL_OW 116
// wait ( 50 ) ;
16934: LD_INT 50
16936: PPUSH
16937: CALL_OW 67
// until not list ;
16941: LD_VAR 0 2
16945: NOT
16946: IFFALSE 16836
// ComReturn ( war_forces ) ;
16948: LD_EXP 52
16952: PPUSH
16953: CALL_OW 144
// ComReturn ( backup_forces ) ;
16957: LD_EXP 56
16961: PPUSH
16962: CALL_OW 144
// end ; end_of_file
16966: LD_VAR 0 1
16970: RET
// var b_list ; export function init_keep_base ; var un , list ; begin
16971: LD_INT 0
16973: PPUSH
16974: PPUSH
16975: PPUSH
// b_list := [ ] ;
16976: LD_ADDR_LOC 39
16980: PUSH
16981: EMPTY
16982: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_building ] ] ) ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_INT 22
16990: PUSH
16991: LD_EXP 15
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: LD_INT 21
17002: PUSH
17003: LD_INT 3
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: EMPTY
17011: LIST
17012: LIST
17013: PPUSH
17014: CALL_OW 69
17018: ST_TO_ADDR
// if un then
17019: LD_VAR 0 2
17023: IFFALSE 17049
// b_list := GetBuildList ( GetBase ( un [ 1 ] ) ) ;
17025: LD_ADDR_LOC 39
17029: PUSH
17030: LD_VAR 0 2
17034: PUSH
17035: LD_INT 1
17037: ARRAY
17038: PPUSH
17039: CALL_OW 274
17043: PPUSH
17044: CALL_OW 417
17048: ST_TO_ADDR
// enable ( 2 ) ;
17049: LD_INT 2
17051: ENABLE_MARKED
// end ;
17052: LD_VAR 0 1
17056: RET
// every 0 0$3 trigger FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) marked 2 do var engineers ;
17057: LD_INT 33
17059: PPUSH
17060: LD_INT 22
17062: PUSH
17063: LD_EXP 14
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: PUSH
17072: LD_INT 50
17074: PUSH
17075: EMPTY
17076: LIST
17077: PUSH
17078: EMPTY
17079: LIST
17080: LIST
17081: PPUSH
17082: CALL_OW 70
17086: IFFALSE 17171
17088: GO 17090
17090: DISABLE
17091: LD_INT 0
17093: PPUSH
// begin engineers := ru_ing ;
17094: LD_ADDR_VAR 0 1
17098: PUSH
17099: LD_EXP 24
17103: ST_TO_ADDR
// if not engineers then
17104: LD_VAR 0 1
17108: NOT
17109: IFFALSE 17121
// engineers := ru_sol ;
17111: LD_ADDR_VAR 0 1
17115: PUSH
17116: LD_EXP 25
17120: ST_TO_ADDR
// ComRemember ( engineers ) ;
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL_OW 143
// WaitForMc ( McBase ( 3 , engineers , b_list , 0 , 0 , 0 ) ) ;
17130: LD_INT 3
17132: PPUSH
17133: LD_VAR 0 1
17137: PPUSH
17138: LD_LOC 39
17142: PPUSH
17143: LD_INT 0
17145: PPUSH
17146: LD_INT 0
17148: PPUSH
17149: LD_INT 0
17151: PPUSH
17152: CALL_OW 397
17156: PPUSH
17157: CALL_OW 385
// ComReturn ( engineers ) ;
17161: LD_VAR 0 1
17165: PPUSH
17166: CALL_OW 144
// enable ;
17170: ENABLE
// end ; end_of_file
17171: PPOPN 1
17173: END
// every 0 0$2 + 0 0$0.1 do
17174: GO 17176
17176: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17177: LD_INT 22
17179: PUSH
17180: LD_INT 1
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PUSH
17187: LD_INT 2
17189: PUSH
17190: LD_INT 25
17192: PUSH
17193: LD_INT 12
17195: PUSH
17196: EMPTY
17197: LIST
17198: LIST
17199: PUSH
17200: LD_INT 25
17202: PUSH
17203: LD_INT 16
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: PUSH
17210: LD_INT 25
17212: PUSH
17213: LD_INT 15
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: PUSH
17220: LD_INT 25
17222: PUSH
17223: LD_INT 17
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: LIST
17234: LIST
17235: LIST
17236: PUSH
17237: EMPTY
17238: LIST
17239: LIST
17240: PPUSH
17241: CALL_OW 69
17245: PUSH
17246: LD_INT 22
17248: PUSH
17249: LD_INT 1
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: PUSH
17256: LD_INT 21
17258: PUSH
17259: LD_INT 1
17261: PUSH
17262: EMPTY
17263: LIST
17264: LIST
17265: PUSH
17266: LD_INT 3
17268: PUSH
17269: LD_INT 2
17271: PUSH
17272: LD_INT 25
17274: PUSH
17275: LD_INT 12
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: PUSH
17282: LD_INT 25
17284: PUSH
17285: LD_INT 16
17287: PUSH
17288: EMPTY
17289: LIST
17290: LIST
17291: PUSH
17292: LD_INT 25
17294: PUSH
17295: LD_INT 15
17297: PUSH
17298: EMPTY
17299: LIST
17300: LIST
17301: PUSH
17302: LD_INT 25
17304: PUSH
17305: LD_INT 17
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: LIST
17316: LIST
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: LIST
17327: PPUSH
17328: CALL_OW 69
17332: GREATER
17333: IFFALSE 17344
// begin SetAchievement ( ACH_POTA ) ;
17335: LD_STRING ACH_POTA
17337: PPUSH
17338: CALL_OW 543
// exit ;
17342: GO 17345
// end ; enable ;
17344: ENABLE
// end ;
17345: END

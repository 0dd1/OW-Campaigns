// export MacMillan , Powell , Joan , Lisa , Anezka ; export survivor , who_survive ; export truck1 , ukradle_auto ; export time_crates_us , time_crates_ru ; export other_survivors ; export on_optolab ; export you , russians , neutral ; export double_laser , double_hint ; export selected_opto_lab ; export veh_jmm , veh_surv ; export fastEscape ; export kappa_saved ; var russians_eliminated , doublelasers_turrets ; function prepare_units ; var un , i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
// uc_nation := nation_american ;
   5: LD_ADDR_OWVAR 21
   9: PUSH
  10: LD_INT 1
  12: ST_TO_ADDR
// uc_side := you ;
  13: LD_ADDR_OWVAR 20
  17: PUSH
  18: LD_EXP 14
  22: ST_TO_ADDR
// hc_class := class_soldier ;
  23: LD_ADDR_OWVAR 28
  27: PUSH
  28: LD_INT 1
  30: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_STRING JMM
  38: PPUSH
  39: CALL_OW 34
  43: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_STRING Powell
  51: PPUSH
  52: CALL_OW 25
  56: ST_TO_ADDR
// uc_side := neutral ;
  57: LD_ADDR_OWVAR 20
  61: PUSH
  62: LD_EXP 16
  66: ST_TO_ADDR
// if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) then
  67: LD_STRING Joan
  69: PPUSH
  70: CALL_OW 28
  74: PUSH
  75: LD_STRING Joan
  77: PPUSH
  78: CALL_OW 29
  82: AND
  83: IFFALSE 126
// begin hc_class := class_scientistic ;
  85: LD_ADDR_OWVAR 28
  89: PUSH
  90: LD_INT 4
  92: ST_TO_ADDR
// Joan := CreateCharacter ( Joan ) ;
  93: LD_ADDR_EXP 3
  97: PUSH
  98: LD_STRING Joan
 100: PPUSH
 101: CALL_OW 34
 105: ST_TO_ADDR
// survivor := Joan ;
 106: LD_ADDR_EXP 6
 110: PUSH
 111: LD_EXP 3
 115: ST_TO_ADDR
// who_survive := 1 ;
 116: LD_ADDR_EXP 7
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// end else
 124: GO 216
// if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
 126: LD_STRING Lisa
 128: PPUSH
 129: CALL_OW 28
 133: PUSH
 134: LD_STRING Lisa
 136: PPUSH
 137: CALL_OW 29
 141: AND
 142: IFFALSE 185
// begin hc_class := class_soldier ;
 144: LD_ADDR_OWVAR 28
 148: PUSH
 149: LD_INT 1
 151: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
 152: LD_ADDR_EXP 4
 156: PUSH
 157: LD_STRING Lisa
 159: PPUSH
 160: CALL_OW 34
 164: ST_TO_ADDR
// survivor := Lisa ;
 165: LD_ADDR_EXP 6
 169: PUSH
 170: LD_EXP 4
 174: ST_TO_ADDR
// who_survive := 2 ;
 175: LD_ADDR_EXP 7
 179: PUSH
 180: LD_INT 2
 182: ST_TO_ADDR
// end else
 183: GO 216
// begin Anezka := NewCharacter ( Coonie ) ;
 185: LD_ADDR_EXP 5
 189: PUSH
 190: LD_STRING Coonie
 192: PPUSH
 193: CALL_OW 25
 197: ST_TO_ADDR
// survivor := Anezka ;
 198: LD_ADDR_EXP 6
 202: PUSH
 203: LD_EXP 5
 207: ST_TO_ADDR
// who_survive := 3 ;
 208: LD_ADDR_EXP 7
 212: PUSH
 213: LD_INT 3
 215: ST_TO_ADDR
// end ; uc_side := you ;
 216: LD_ADDR_OWVAR 20
 220: PUSH
 221: LD_EXP 14
 225: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 226: LD_STRING other_survivors
 228: PPUSH
 229: CALL_OW 28
 233: IFFALSE 250
// other_survivors := CreateCharacterSet ( other_survivors ) else
 235: LD_ADDR_EXP 12
 239: PUSH
 240: LD_STRING other_survivors
 242: PPUSH
 243: CALL_OW 31
 247: ST_TO_ADDR
 248: GO 257
// other_survivors := [ ] ;
 250: LD_ADDR_EXP 12
 254: PUSH
 255: EMPTY
 256: ST_TO_ADDR
// uc_direction := 1 ;
 257: LD_ADDR_OWVAR 24
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// vc_chassis := us_morphling ;
 265: LD_ADDR_OWVAR 37
 269: PUSH
 270: LD_INT 5
 272: ST_TO_ADDR
// vc_control := control_manual ;
 273: LD_ADDR_OWVAR 38
 277: PUSH
 278: LD_INT 1
 280: ST_TO_ADDR
// vc_engine := engine_siberite ;
 281: LD_ADDR_OWVAR 39
 285: PUSH
 286: LD_INT 3
 288: ST_TO_ADDR
// vc_weapon := us_laser ;
 289: LD_ADDR_OWVAR 40
 293: PUSH
 294: LD_INT 9
 296: ST_TO_ADDR
// truck1 := CreateVehicle ;
 297: LD_ADDR_EXP 8
 301: PUSH
 302: CALL_OW 45
 306: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
 307: LD_ADDR_OWVAR 24
 311: PUSH
 312: LD_INT 0
 314: PPUSH
 315: LD_INT 5
 317: PPUSH
 318: CALL_OW 12
 322: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 323: LD_EXP 1
 327: PPUSH
 328: LD_EXP 8
 332: PPUSH
 333: CALL_OW 52
// uc_nation = nation_russian ;
 337: LD_ADDR_OWVAR 21
 341: PUSH
 342: LD_INT 3
 344: ST_TO_ADDR
// uc_side = russians ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_EXP 15
 354: ST_TO_ADDR
// PlaceUnitXY ( truck1 , 6 , 6 , false ) ;
 355: LD_EXP 8
 359: PPUSH
 360: LD_INT 6
 362: PPUSH
 363: LD_INT 6
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 48
// PlaceUnitXY ( survivor , 65 , 108 , false ) ;
 373: LD_EXP 6
 377: PPUSH
 378: LD_INT 65
 380: PPUSH
 381: LD_INT 108
 383: PPUSH
 384: LD_INT 0
 386: PPUSH
 387: CALL_OW 48
// ComFree ( [ MacMillan , survivor ] ) ;
 391: LD_EXP 1
 395: PUSH
 396: LD_EXP 6
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PPUSH
 405: CALL_OW 139
// end ;
 409: LD_VAR 0 1
 413: RET
// function prepare_sides ; begin
 414: LD_INT 0
 416: PPUSH
// you = 1 ;
 417: LD_ADDR_EXP 14
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// neutral = 4 ;
 425: LD_ADDR_EXP 16
 429: PUSH
 430: LD_INT 4
 432: ST_TO_ADDR
// russians = 3 ;
 433: LD_ADDR_EXP 15
 437: PUSH
 438: LD_INT 3
 440: ST_TO_ADDR
// visit_base := false ;
 441: LD_ADDR_EXP 34
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// on_optolab := false ;
 449: LD_ADDR_EXP 13
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// russians_eliminated := false ;
 457: LD_ADDR_LOC 1
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// double_laser := 0 ;
 465: LD_ADDR_EXP 17
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// double_hint := false ;
 473: LD_ADDR_EXP 18
 477: PUSH
 478: LD_INT 0
 480: ST_TO_ADDR
// doublelasers_turrets := [ ] ;
 481: LD_ADDR_LOC 2
 485: PUSH
 486: EMPTY
 487: ST_TO_ADDR
// selected_opto_lab := false ;
 488: LD_ADDR_EXP 19
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
 496: LD_EXP 14
 500: PPUSH
 501: LD_EXP 15
 505: PPUSH
 506: LD_INT 2
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
 516: LD_EXP 14
 520: PPUSH
 521: LD_EXP 16
 525: PPUSH
 526: LD_INT 1
 528: PPUSH
 529: LD_INT 1
 531: PPUSH
 532: CALL_OW 80
// enable ( 1 ) ;
 536: LD_INT 1
 538: ENABLE_MARKED
// disable ( 5 ) ;
 539: LD_INT 5
 541: DISABLE_MARKED
// disable ( 11 ) ;
 542: LD_INT 11
 544: DISABLE_MARKED
// end ;
 545: LD_VAR 0 1
 549: RET
// starting begin RandomizeAll ;
 550: CALL_OW 11
// fastEscape = 0 ;
 554: LD_ADDR_EXP 22
 558: PUSH
 559: LD_INT 0
 561: ST_TO_ADDR
// prepare_sides ;
 562: CALL 414 0 0
// prepare_units ;
 566: CALL 0 0 0
// starting_scene ;
 570: CALL 5445 0 0
// prepare_ru_base ;
 574: CALL 3084 0 0
// prepare_us_base ;
 578: CALL 8208 0 0
// ru_scientistic_priority ;
 582: CALL 8798 0 0
// startup_manufacturing ;
 586: CALL 10398 0 0
// startup_war_definition ;
 590: CALL 11831 0 0
// init_keep_base ;
 594: CALL 17047 0 0
// start_defend ;
 598: CALL 16445 0 0
// time_crates_us := Rand ( 0 0$20 , 0 0$40 ) ;
 602: LD_ADDR_EXP 10
 606: PUSH
 607: LD_INT 700
 609: PPUSH
 610: LD_INT 1400
 612: PPUSH
 613: CALL_OW 12
 617: ST_TO_ADDR
// time_crates_ru := Rand ( 0 0$30 , 0 0$60 ) ;
 618: LD_ADDR_EXP 11
 622: PUSH
 623: LD_INT 1050
 625: PPUSH
 626: LD_INT 2100
 628: PPUSH
 629: CALL_OW 12
 633: ST_TO_ADDR
// end ;
 634: END
// every 0 0$5 trigger TICK >= time_crates_us do
 635: LD_OWVAR 1
 639: PUSH
 640: LD_EXP 10
 644: GREATEREQUAL
 645: IFFALSE 694
 647: GO 649
 649: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 5 ) , inner_base , true ) ;
 650: LD_INT 2
 652: PPUSH
 653: LD_INT 5
 655: PPUSH
 656: CALL_OW 12
 660: PPUSH
 661: LD_INT 4
 663: PPUSH
 664: LD_INT 1
 666: PPUSH
 667: CALL_OW 55
// time_crates_us := TICK + Rand ( 0 0$60 , 0 0$100 ) ;
 671: LD_ADDR_EXP 10
 675: PUSH
 676: LD_OWVAR 1
 680: PUSH
 681: LD_INT 2100
 683: PPUSH
 684: LD_INT 3500
 686: PPUSH
 687: CALL_OW 12
 691: PLUS
 692: ST_TO_ADDR
// enable ;
 693: ENABLE
// end ;
 694: END
// every 0 0$5 trigger TICK >= time_crates_ru do
 695: LD_OWVAR 1
 699: PUSH
 700: LD_EXP 11
 704: GREATEREQUAL
 705: IFFALSE 754
 707: GO 709
 709: DISABLE
// begin CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
 710: LD_INT 3
 712: PPUSH
 713: LD_INT 5
 715: PPUSH
 716: CALL_OW 12
 720: PPUSH
 721: LD_INT 10
 723: PPUSH
 724: LD_INT 1
 726: PPUSH
 727: CALL_OW 55
// time_crates_ru := TICK + Rand ( 0 0$30 , 0 0$60 ) ;
 731: LD_ADDR_EXP 11
 735: PUSH
 736: LD_OWVAR 1
 740: PUSH
 741: LD_INT 1050
 743: PPUSH
 744: LD_INT 2100
 746: PPUSH
 747: CALL_OW 12
 751: PLUS
 752: ST_TO_ADDR
// enable ;
 753: ENABLE
// end ;
 754: END
// export function konec_mise ; var saved , un , medal1 , medal2 , medal3 ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
 760: PPUSH
 761: PPUSH
 762: PPUSH
// medal1 := false ;
 763: LD_ADDR_VAR 0 4
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// medal2 := false ;
 771: LD_ADDR_VAR 0 5
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// medal3 := false ;
 779: LD_ADDR_VAR 0 6
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// if IsOK ( MacMillan ) and not russians_eliminated then
 787: LD_EXP 1
 791: PPUSH
 792: CALL_OW 302
 796: PUSH
 797: LD_LOC 1
 801: NOT
 802: AND
 803: IFFALSE 901
// begin un := IsInUnit ( MacMillan ) ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_EXP 1
 814: PPUSH
 815: CALL_OW 310
 819: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 820: LD_VAR 0 3
 824: PPUSH
 825: CALL_OW 247
 829: PUSH
 830: LD_INT 2
 832: EQUAL
 833: IFFALSE 886
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
 835: LD_ADDR_EXP 20
 839: PUSH
 840: LD_VAR 0 3
 844: PPUSH
 845: CALL_OW 265
 849: PUSH
 850: LD_VAR 0 3
 854: PPUSH
 855: CALL_OW 262
 859: PUSH
 860: LD_VAR 0 3
 864: PPUSH
 865: CALL_OW 263
 869: PUSH
 870: LD_VAR 0 3
 874: PPUSH
 875: CALL_OW 264
 879: PUSH
 880: EMPTY
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 886: LD_VAR 0 3
 890: PPUSH
 891: CALL_OW 247
 895: PUSH
 896: LD_INT 2
 898: EQUAL
 899: IFFALSE 901
// end ; if IsDead ( MacMillan ) or ( GetLives ( MacMillan ) < 250 ) then
 901: LD_EXP 1
 905: PPUSH
 906: CALL_OW 301
 910: PUSH
 911: LD_EXP 1
 915: PPUSH
 916: CALL_OW 256
 920: PUSH
 921: LD_INT 250
 923: LESS
 924: OR
 925: IFFALSE 936
// begin YouLost ( JMM ) ;
 927: LD_STRING JMM
 929: PPUSH
 930: CALL_OW 104
// exit ;
 934: GO 1765
// end ; if ( GetLives ( survivor ) > 250 ) and visit_base then
 936: LD_EXP 6
 940: PPUSH
 941: CALL_OW 256
 945: PUSH
 946: LD_INT 250
 948: GREATER
 949: PUSH
 950: LD_EXP 34
 954: AND
 955: IFFALSE 979
// begin medal1 := true ;
 957: LD_ADDR_VAR 0 4
 961: PUSH
 962: LD_INT 1
 964: ST_TO_ADDR
// AddMedal ( protect , who_survive ) ;
 965: LD_STRING protect
 967: PPUSH
 968: LD_EXP 7
 972: PPUSH
 973: CALL_OW 101
// end else
 977: GO 1051
// case who_survive of 1 :
 979: LD_EXP 7
 983: PUSH
 984: LD_INT 1
 986: DOUBLE
 987: EQUAL
 988: IFTRUE 992
 990: GO 1006
 992: POP
// AddMedal ( protect , - 1 ) ; 2 :
 993: LD_STRING protect
 995: PPUSH
 996: LD_INT 1
 998: NEG
 999: PPUSH
1000: CALL_OW 101
1004: GO 1051
1006: LD_INT 2
1008: DOUBLE
1009: EQUAL
1010: IFTRUE 1014
1012: GO 1028
1014: POP
// AddMedal ( protect , - 2 ) ; 3 :
1015: LD_STRING protect
1017: PPUSH
1018: LD_INT 2
1020: NEG
1021: PPUSH
1022: CALL_OW 101
1026: GO 1051
1028: LD_INT 3
1030: DOUBLE
1031: EQUAL
1032: IFTRUE 1036
1034: GO 1050
1036: POP
// AddMedal ( protect , - 3 ) ; end ;
1037: LD_STRING protect
1039: PPUSH
1040: LD_INT 3
1042: NEG
1043: PPUSH
1044: CALL_OW 101
1048: GO 1051
1050: POP
// if ( GetLives ( survivor ) > 250 ) and visit_base then
1051: LD_EXP 6
1055: PPUSH
1056: CALL_OW 256
1060: PUSH
1061: LD_INT 250
1063: GREATER
1064: PUSH
1065: LD_EXP 34
1069: AND
1070: IFFALSE 1093
// saved := [ MacMillan , survivor ] else
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_EXP 1
1081: PUSH
1082: LD_EXP 6
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: ST_TO_ADDR
1091: GO 1106
// saved := [ MacMillan ] ;
1093: LD_ADDR_VAR 0 2
1097: PUSH
1098: LD_EXP 1
1102: PUSH
1103: EMPTY
1104: LIST
1105: ST_TO_ADDR
// double_laser := double_laser + doublelasers_turrets ;
1106: LD_ADDR_EXP 17
1110: PUSH
1111: LD_EXP 17
1115: PUSH
1116: LD_LOC 2
1120: PLUS
1121: ST_TO_ADDR
// if visit_base then
1122: LD_EXP 34
1126: IFFALSE 1218
// begin if not selected_opto_lab then
1128: LD_EXP 19
1132: NOT
1133: IFFALSE 1148
// AddMedal ( double , - 1 ) else
1135: LD_STRING double
1137: PPUSH
1138: LD_INT 1
1140: NEG
1141: PPUSH
1142: CALL_OW 101
1146: GO 1216
// case double_laser of 0 :
1148: LD_EXP 17
1152: PUSH
1153: LD_INT 0
1155: DOUBLE
1156: EQUAL
1157: IFTRUE 1161
1159: GO 1175
1161: POP
// AddMedal ( double , - 2 ) ; 1 :
1162: LD_STRING double
1164: PPUSH
1165: LD_INT 2
1167: NEG
1168: PPUSH
1169: CALL_OW 101
1173: GO 1216
1175: LD_INT 1
1177: DOUBLE
1178: EQUAL
1179: IFTRUE 1183
1181: GO 1197
1183: POP
// AddMedal ( double , - 3 ) ; else
1184: LD_STRING double
1186: PPUSH
1187: LD_INT 3
1189: NEG
1190: PPUSH
1191: CALL_OW 101
1195: GO 1216
1197: POP
// begin medal2 := true ;
1198: LD_ADDR_VAR 0 5
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// Addmedal ( double , 1 ) ;
1206: LD_STRING double
1208: PPUSH
1209: LD_INT 1
1211: PPUSH
1212: CALL_OW 101
// end ; end ; end else
1216: GO 1229
// AddMedal ( double , - 2 ) ;
1218: LD_STRING double
1220: PPUSH
1221: LD_INT 2
1223: NEG
1224: PPUSH
1225: CALL_OW 101
// if russians_eliminated then
1229: LD_LOC 1
1233: IFFALSE 1296
// begin AddMedal ( base , 1 ) ;
1235: LD_STRING base
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: CALL_OW 101
// medal3 := true ;
1245: LD_ADDR_VAR 0 6
1249: PUSH
1250: LD_INT 1
1252: ST_TO_ADDR
// SA_EndMission ( 1 , 14 , medal1 , medal2 , medal3 ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 14
1258: PPUSH
1259: LD_VAR 0 4
1263: PPUSH
1264: LD_VAR 0 5
1268: PPUSH
1269: LD_VAR 0 6
1273: PPUSH
1274: CALL 17422 0 5
// GiveMedals ( Eliminate ) ;
1278: LD_STRING Eliminate
1280: PPUSH
1281: CALL_OW 102
// RewardPeople ( saved ) ;
1285: LD_VAR 0 2
1289: PPUSH
1290: CALL_OW 43
// end else
1294: GO 1343
// begin if not visit_base then
1296: LD_EXP 34
1300: NOT
1301: IFFALSE 1316
// AddMedal ( base , - 2 ) else
1303: LD_STRING base
1305: PPUSH
1306: LD_INT 2
1308: NEG
1309: PPUSH
1310: CALL_OW 101
1314: GO 1327
// AddMedal ( base , - 1 ) ;
1316: LD_STRING base
1318: PPUSH
1319: LD_INT 1
1321: NEG
1322: PPUSH
1323: CALL_OW 101
// GiveMedals ( Reach ) ;
1327: LD_STRING Reach
1329: PPUSH
1330: CALL_OW 102
// RewardPeople ( saved ) ;
1334: LD_VAR 0 2
1338: PPUSH
1339: CALL_OW 43
// end ; kappa_saved := false ;
1343: LD_ADDR_EXP 23
1347: PUSH
1348: LD_INT 0
1350: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1351: LD_EXP 1
1355: PPUSH
1356: LD_STRING JMM
1358: PPUSH
1359: CALL_OW 38
// if not visit_base then
1363: LD_EXP 34
1367: NOT
1368: IFFALSE 1379
// KillUnit ( survivor ) ;
1370: LD_EXP 6
1374: PPUSH
1375: CALL_OW 66
// case who_survive of 1 :
1379: LD_EXP 7
1383: PUSH
1384: LD_INT 1
1386: DOUBLE
1387: EQUAL
1388: IFTRUE 1392
1390: GO 1407
1392: POP
// SaveCharacters ( Joan , Joan ) ; 2 :
1393: LD_EXP 3
1397: PPUSH
1398: LD_STRING Joan
1400: PPUSH
1401: CALL_OW 38
1405: GO 1454
1407: LD_INT 2
1409: DOUBLE
1410: EQUAL
1411: IFTRUE 1415
1413: GO 1430
1415: POP
// SaveCharacters ( Lisa , Lisa ) ; 3 :
1416: LD_EXP 4
1420: PPUSH
1421: LD_STRING Lisa
1423: PPUSH
1424: CALL_OW 38
1428: GO 1454
1430: LD_INT 3
1432: DOUBLE
1433: EQUAL
1434: IFTRUE 1438
1436: GO 1453
1438: POP
// SaveCharacters ( Anezka , Coonie ) ; end ;
1439: LD_EXP 5
1443: PPUSH
1444: LD_STRING Coonie
1446: PPUSH
1447: CALL_OW 38
1451: GO 1454
1453: POP
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1454: LD_EXP 6
1458: PPUSH
1459: CALL_OW 256
1463: PUSH
1464: LD_INT 250
1466: GREATER
1467: PUSH
1468: LD_EXP 22
1472: PUSH
1473: LD_INT 0
1475: EQUAL
1476: AND
1477: IFFALSE 1496
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
1479: LD_EXP 6
1483: PPUSH
1484: CALL_OW 300
1488: PPUSH
1489: LD_STRING woman_saved
1491: PPUSH
1492: CALL_OW 39
// if [ GetSide ( survivor ) = 4 or IsDead ( survivor ) ] and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
1496: LD_EXP 6
1500: PPUSH
1501: CALL_OW 255
1505: PUSH
1506: LD_INT 4
1508: EQUAL
1509: PUSH
1510: LD_EXP 6
1514: PPUSH
1515: CALL_OW 301
1519: OR
1520: PUSH
1521: EMPTY
1522: LIST
1523: PUSH
1524: LD_INT 22
1526: PUSH
1527: LD_INT 3
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 21
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: LD_INT 50
1546: PUSH
1547: EMPTY
1548: LIST
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL_OW 69
1559: PUSH
1560: LD_INT 0
1562: GREATER
1563: AND
1564: PUSH
1565: LD_INT 22
1567: PUSH
1568: LD_INT 1
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PUSH
1575: LD_INT 21
1577: PUSH
1578: LD_INT 1
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PPUSH
1589: CALL_OW 69
1593: PUSH
1594: LD_INT 1
1596: EQUAL
1597: AND
1598: IFFALSE 1608
// kappa_saved = false ;
1600: LD_ADDR_EXP 23
1604: PUSH
1605: LD_INT 0
1607: ST_TO_ADDR
// if GetDistUnits ( IsInUnit ( survivor ) , IsInUnit ( Macmillan ) ) < 15 then
1608: LD_EXP 6
1612: PPUSH
1613: CALL_OW 310
1617: PPUSH
1618: LD_EXP 1
1622: PPUSH
1623: CALL_OW 310
1627: PPUSH
1628: CALL_OW 296
1632: PUSH
1633: LD_INT 15
1635: LESS
1636: IFFALSE 1646
// kappa_saved = true ;
1638: LD_ADDR_EXP 23
1642: PUSH
1643: LD_INT 1
1645: ST_TO_ADDR
// SaveVariable ( kappa_saved , kappa_saved ) ;
1646: LD_EXP 23
1650: PPUSH
1651: LD_STRING kappa_saved
1653: PPUSH
1654: CALL_OW 39
// SaveVariable ( visit_base , kappa_delayed ) ;
1658: LD_EXP 34
1662: PPUSH
1663: LD_STRING kappa_delayed
1665: PPUSH
1666: CALL_OW 39
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1670: LD_EXP 6
1674: PPUSH
1675: CALL_OW 256
1679: PUSH
1680: LD_INT 250
1682: GREATER
1683: PUSH
1684: LD_EXP 22
1688: PUSH
1689: LD_INT 0
1691: EQUAL
1692: AND
1693: IFFALSE 1718
// SaveVariable ( ( visit_base and IsOK ( survivor ) ) , woman_alive ) ;
1695: LD_EXP 34
1699: PUSH
1700: LD_EXP 6
1704: PPUSH
1705: CALL_OW 302
1709: AND
1710: PPUSH
1711: LD_STRING woman_alive
1713: PPUSH
1714: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
1718: LD_EXP 7
1722: PPUSH
1723: LD_STRING woman_in_am14
1725: PPUSH
1726: CALL_OW 39
// if not russians_eliminated then
1730: LD_LOC 1
1734: NOT
1735: IFFALSE 1761
// begin SaveVariable ( veh_jmm , veh_jmm ) ;
1737: LD_EXP 20
1741: PPUSH
1742: LD_STRING veh_jmm
1744: PPUSH
1745: CALL_OW 39
// SaveVariable ( veh_surv , veh_surv ) ;
1749: LD_EXP 21
1753: PPUSH
1754: LD_STRING veh_surv
1756: PPUSH
1757: CALL_OW 39
// end ; YouWin ;
1761: CALL_OW 103
// end ;
1765: LD_VAR 0 1
1769: RET
// function almost_done_macmillan ; var odpoved , vysledek , un ; begin
1770: LD_INT 0
1772: PPUSH
1773: PPUSH
1774: PPUSH
1775: PPUSH
// vysledek := true ;
1776: LD_ADDR_VAR 0 3
1780: PUSH
1781: LD_INT 1
1783: ST_TO_ADDR
// un := IsInUnit ( MacMillan ) ;
1784: LD_ADDR_VAR 0 4
1788: PUSH
1789: LD_EXP 1
1793: PPUSH
1794: CALL_OW 310
1798: ST_TO_ADDR
// if not IsOK ( survivor ) or ( IsInArea ( survivor , near_exit ) and IsInUnit ( survivor ) ) then
1799: LD_EXP 6
1803: PPUSH
1804: CALL_OW 302
1808: NOT
1809: PUSH
1810: LD_EXP 6
1814: PPUSH
1815: LD_INT 26
1817: PPUSH
1818: CALL_OW 308
1822: PUSH
1823: LD_EXP 6
1827: PPUSH
1828: CALL_OW 310
1832: AND
1833: OR
1834: IFFALSE 1917
// begin fastEscape = 1 ;
1836: LD_ADDR_EXP 22
1840: PUSH
1841: LD_INT 1
1843: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1844: LD_EXP 1
1848: PPUSH
1849: LD_STRING JMM
1851: PPUSH
1852: CALL_OW 38
// CheckSurvivorStatus ;
1856: CALL 2879 0 0
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1860: LD_ADDR_EXP 20
1864: PUSH
1865: LD_VAR 0 4
1869: PPUSH
1870: CALL_OW 265
1874: PUSH
1875: LD_VAR 0 4
1879: PPUSH
1880: CALL_OW 262
1884: PUSH
1885: LD_VAR 0 4
1889: PPUSH
1890: CALL_OW 263
1894: PUSH
1895: LD_VAR 0 4
1899: PPUSH
1900: CALL_OW 264
1904: PUSH
1905: EMPTY
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: ST_TO_ADDR
// konec_mise ;
1911: CALL 755 0 0
// end else
1915: GO 1995
// begin case who_survive of 1 :
1917: LD_EXP 7
1921: PUSH
1922: LD_INT 1
1924: DOUBLE
1925: EQUAL
1926: IFTRUE 1930
1928: GO 1946
1930: POP
// odpoved := Query ( Q3bJ ) ; 2 :
1931: LD_ADDR_VAR 0 2
1935: PUSH
1936: LD_STRING Q3bJ
1938: PPUSH
1939: CALL_OW 97
1943: ST_TO_ADDR
1944: GO 1995
1946: LD_INT 2
1948: DOUBLE
1949: EQUAL
1950: IFTRUE 1954
1952: GO 1970
1954: POP
// odpoved := Query ( Q3bL ) ; 3 :
1955: LD_ADDR_VAR 0 2
1959: PUSH
1960: LD_STRING Q3bL
1962: PPUSH
1963: CALL_OW 97
1967: ST_TO_ADDR
1968: GO 1995
1970: LD_INT 3
1972: DOUBLE
1973: EQUAL
1974: IFTRUE 1978
1976: GO 1994
1978: POP
// odpoved := Query ( Q3bX ) ; end ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_STRING Q3bX
1986: PPUSH
1987: CALL_OW 97
1991: ST_TO_ADDR
1992: GO 1995
1994: POP
// end ; if odpoved = 1 then
1995: LD_VAR 0 2
1999: PUSH
2000: LD_INT 1
2002: EQUAL
2003: IFFALSE 2011
// konec_mise else
2005: CALL 755 0 0
2009: GO 2019
// vysledek := false ;
2011: LD_ADDR_VAR 0 3
2015: PUSH
2016: LD_INT 0
2018: ST_TO_ADDR
// result := vysledek ;
2019: LD_ADDR_VAR 0 1
2023: PUSH
2024: LD_VAR 0 3
2028: ST_TO_ADDR
// end ;
2029: LD_VAR 0 1
2033: RET
// function almost_done_survivor ; var odpoved , vysledek , un ; begin
2034: LD_INT 0
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// odpoved := false ;
2040: LD_ADDR_VAR 0 2
2044: PUSH
2045: LD_INT 0
2047: ST_TO_ADDR
// vysledek := true ;
2048: LD_ADDR_VAR 0 3
2052: PUSH
2053: LD_INT 1
2055: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
2056: LD_ADDR_VAR 0 4
2060: PUSH
2061: LD_EXP 6
2065: PPUSH
2066: CALL_OW 310
2070: ST_TO_ADDR
// if IsOK ( MacMillan ) then
2071: LD_EXP 1
2075: PPUSH
2076: CALL_OW 302
2080: IFFALSE 2097
// odpoved := Query ( Q3b ) else
2082: LD_ADDR_VAR 0 2
2086: PUSH
2087: LD_STRING Q3b
2089: PPUSH
2090: CALL_OW 97
2094: ST_TO_ADDR
2095: GO 2105
// odpoved := true ;
2097: LD_ADDR_VAR 0 2
2101: PUSH
2102: LD_INT 1
2104: ST_TO_ADDR
// if odpoved then
2105: LD_VAR 0 2
2109: IFFALSE 2117
// begin CheckSurvivorStatus ;
2111: CALL 2879 0 0
// end else
2115: GO 2125
// vysledek := false ;
2117: LD_ADDR_VAR 0 3
2121: PUSH
2122: LD_INT 0
2124: ST_TO_ADDR
// result := vysledek ;
2125: LD_ADDR_VAR 0 1
2129: PUSH
2130: LD_VAR 0 3
2134: ST_TO_ADDR
// end ;
2135: LD_VAR 0 1
2139: RET
// every 0 0$2 trigger IsInArea ( MacMillan , exit_area ) do var odpoved ;
2140: LD_EXP 1
2144: PPUSH
2145: LD_INT 25
2147: PPUSH
2148: CALL_OW 308
2152: IFFALSE 2254
2154: GO 2156
2156: DISABLE
2157: LD_INT 0
2159: PPUSH
// begin if IsInUnit ( MacMillan ) then
2160: LD_EXP 1
2164: PPUSH
2165: CALL_OW 310
2169: IFFALSE 2213
// begin if not almost_done_macmillan then
2171: CALL 1770 0 0
2175: NOT
2176: IFFALSE 2211
// repeat wait ( 0 0$1 ) ;
2178: LD_INT 35
2180: PPUSH
2181: CALL_OW 67
// until not ( IsInArea ( MacMillan , exit_area ) and IsInUnit ( MacMillan ) ) ;
2185: LD_EXP 1
2189: PPUSH
2190: LD_INT 25
2192: PPUSH
2193: CALL_OW 308
2197: PUSH
2198: LD_EXP 1
2202: PPUSH
2203: CALL_OW 310
2207: AND
2208: NOT
2209: IFFALSE 2178
// end else
2211: GO 2253
// begin Query ( Q3a ) ;
2213: LD_STRING Q3a
2215: PPUSH
2216: CALL_OW 97
// repeat wait ( 0 0$1 ) ;
2220: LD_INT 35
2222: PPUSH
2223: CALL_OW 67
// until IsInUnit ( MacMillan ) or ( not IsInArea ( MacMillan , exit_area ) ) ;
2227: LD_EXP 1
2231: PPUSH
2232: CALL_OW 310
2236: PUSH
2237: LD_EXP 1
2241: PPUSH
2242: LD_INT 25
2244: PPUSH
2245: CALL_OW 308
2249: NOT
2250: OR
2251: IFFALSE 2220
// end ; enable ;
2253: ENABLE
// end ;
2254: PPOPN 1
2256: END
// every 0 0$2 trigger IsInArea ( survivor , exit_area ) do var odpoved , un ;
2257: LD_EXP 6
2261: PPUSH
2262: LD_INT 25
2264: PPUSH
2265: CALL_OW 308
2269: IFFALSE 2436
2271: GO 2273
2273: DISABLE
2274: LD_INT 0
2276: PPUSH
2277: PPUSH
// begin if IsInUnit ( survivor ) then
2278: LD_EXP 6
2282: PPUSH
2283: CALL_OW 310
2287: IFFALSE 2331
// begin if not almost_done_survivor then
2289: CALL 2034 0 0
2293: NOT
2294: IFFALSE 2329
// repeat wait ( 0 0$1 ) ;
2296: LD_INT 35
2298: PPUSH
2299: CALL_OW 67
// until not ( IsInArea ( survivor , exit_area ) and IsInUnit ( survivor ) ) ;
2303: LD_EXP 6
2307: PPUSH
2308: LD_INT 25
2310: PPUSH
2311: CALL_OW 308
2315: PUSH
2316: LD_EXP 6
2320: PPUSH
2321: CALL_OW 310
2325: AND
2326: NOT
2327: IFFALSE 2296
// end else
2329: GO 2424
// begin case who_survive of 1 :
2331: LD_EXP 7
2335: PUSH
2336: LD_INT 1
2338: DOUBLE
2339: EQUAL
2340: IFTRUE 2344
2342: GO 2354
2344: POP
// Query ( Q3aJ ) ; 2 :
2345: LD_STRING Q3aJ
2347: PPUSH
2348: CALL_OW 97
2352: GO 2391
2354: LD_INT 2
2356: DOUBLE
2357: EQUAL
2358: IFTRUE 2362
2360: GO 2372
2362: POP
// Query ( Q3aL ) ; 3 :
2363: LD_STRING Q3aL
2365: PPUSH
2366: CALL_OW 97
2370: GO 2391
2372: LD_INT 3
2374: DOUBLE
2375: EQUAL
2376: IFTRUE 2380
2378: GO 2390
2380: POP
// Query ( Q3aX ) ; end ;
2381: LD_STRING Q3aX
2383: PPUSH
2384: CALL_OW 97
2388: GO 2391
2390: POP
// repeat wait ( 0 0$1 ) ;
2391: LD_INT 35
2393: PPUSH
2394: CALL_OW 67
// until IsInUnit ( survivor ) or ( not IsInArea ( survivor , exit_area ) ) ;
2398: LD_EXP 6
2402: PPUSH
2403: CALL_OW 310
2407: PUSH
2408: LD_EXP 6
2412: PPUSH
2413: LD_INT 25
2415: PPUSH
2416: CALL_OW 308
2420: NOT
2421: OR
2422: IFFALSE 2391
// end ; if IsLive ( survivor ) then
2424: LD_EXP 6
2428: PPUSH
2429: CALL_OW 300
2433: IFFALSE 2436
// enable ;
2435: ENABLE
// end ;
2436: PPOPN 2
2438: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do var vozidla , lide ;
2439: LD_INT 22
2441: PUSH
2442: LD_EXP 15
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 2
2453: PUSH
2454: LD_INT 30
2456: PUSH
2457: LD_INT 0
2459: PUSH
2460: EMPTY
2461: LIST
2462: LIST
2463: PUSH
2464: LD_INT 30
2466: PUSH
2467: LD_INT 1
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: CALL_OW 69
2487: NOT
2488: IFFALSE 2741
2490: GO 2492
2492: DISABLE
2493: LD_INT 0
2495: PPUSH
2496: PPUSH
// begin repeat vozidla := FilterAllUnits ( [ [ f_side , russians ] , [ [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] , [ f_ok ] ] ) ;
2497: LD_ADDR_VAR 0 1
2501: PUSH
2502: LD_INT 22
2504: PUSH
2505: LD_EXP 15
2509: PUSH
2510: EMPTY
2511: LIST
2512: LIST
2513: PUSH
2514: LD_INT 21
2516: PUSH
2517: LD_INT 2
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: PUSH
2524: LD_INT 33
2526: PUSH
2527: LD_INT 3
2529: PUSH
2530: EMPTY
2531: LIST
2532: LIST
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_INT 50
2540: PUSH
2541: EMPTY
2542: LIST
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: PPUSH
2549: CALL_OW 69
2553: ST_TO_ADDR
// lide := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_INT 22
2561: PUSH
2562: LD_EXP 15
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: LD_INT 21
2573: PUSH
2574: LD_INT 1
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 50
2583: PUSH
2584: EMPTY
2585: LIST
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: PPUSH
2592: CALL_OW 69
2596: ST_TO_ADDR
// if not ( lide or vozidla ) then
2597: LD_VAR 0 2
2601: PUSH
2602: LD_VAR 0 1
2606: OR
2607: NOT
2608: IFFALSE 2618
// russians_eliminated := true ;
2610: LD_ADDR_LOC 1
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// wait ( 0 0$1 ) ;
2618: LD_INT 35
2620: PPUSH
2621: CALL_OW 67
// until IsOk ( MacMillan ) and russians_eliminated ;
2625: LD_EXP 1
2629: PPUSH
2630: CALL_OW 302
2634: PUSH
2635: LD_LOC 1
2639: AND
2640: IFFALSE 2497
// DialogueOn ;
2642: CALL_OW 6
// Say ( MacMillan , DEnd-JMM-1 ) ;
2646: LD_EXP 1
2650: PPUSH
2651: LD_STRING DEnd-JMM-1
2653: PPUSH
2654: CALL_OW 88
// case who_survive of 1 :
2658: LD_EXP 7
2662: PUSH
2663: LD_INT 1
2665: DOUBLE
2666: EQUAL
2667: IFTRUE 2671
2669: GO 2686
2671: POP
// Say ( Joan , DEnd-Joan-1 ) ; 2 :
2672: LD_EXP 3
2676: PPUSH
2677: LD_STRING DEnd-Joan-1
2679: PPUSH
2680: CALL_OW 88
2684: GO 2733
2686: LD_INT 2
2688: DOUBLE
2689: EQUAL
2690: IFTRUE 2694
2692: GO 2709
2694: POP
// Say ( Lisa , DEnd-Lisa-1 ) ; 3 :
2695: LD_EXP 4
2699: PPUSH
2700: LD_STRING DEnd-Lisa-1
2702: PPUSH
2703: CALL_OW 88
2707: GO 2733
2709: LD_INT 3
2711: DOUBLE
2712: EQUAL
2713: IFTRUE 2717
2715: GO 2732
2717: POP
// Say ( Anezka , DEnd-Con-1 ) ; end ;
2718: LD_EXP 5
2722: PPUSH
2723: LD_STRING DEnd-Con-1
2725: PPUSH
2726: CALL_OW 88
2730: GO 2733
2732: POP
// DialogueOff ;
2733: CALL_OW 7
// konec_mise ;
2737: CALL 755 0 0
// end ;
2741: PPOPN 2
2743: END
// every 0 0$3 do var un , list ;
2744: GO 2746
2746: DISABLE
2747: LD_INT 0
2749: PPUSH
2750: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_INT 22
2758: PUSH
2759: LD_EXP 14
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 30
2773: PUSH
2774: LD_INT 32
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: PUSH
2781: LD_INT 30
2783: PUSH
2784: LD_INT 33
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: LIST
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// for un in list do
2805: LD_ADDR_VAR 0 1
2809: PUSH
2810: LD_VAR 0 2
2814: PUSH
2815: FOR_IN
2816: IFFALSE 2873
// if GetBWeapon ( un ) = us_double_laser then
2818: LD_VAR 0 1
2822: PPUSH
2823: CALL_OW 269
2827: PUSH
2828: LD_INT 10
2830: EQUAL
2831: IFFALSE 2871
// begin if not double_hint then
2833: LD_EXP 18
2837: NOT
2838: IFFALSE 2855
// begin Hint ( DoubleLaser ) ;
2840: LD_STRING DoubleLaser
2842: PPUSH
2843: CALL_OW 339
// double_hint := true ;
2847: LD_ADDR_EXP 18
2851: PUSH
2852: LD_INT 1
2854: ST_TO_ADDR
// end ; doublelasers_turrets := doublelasers_turrets union un ;
2855: LD_ADDR_LOC 2
2859: PUSH
2860: LD_LOC 2
2864: PUSH
2865: LD_VAR 0 1
2869: UNION
2870: ST_TO_ADDR
// end ;
2871: GO 2815
2873: POP
2874: POP
// enable ;
2875: ENABLE
// end ;
2876: PPOPN 2
2878: END
// export function CheckSurvivorStatus ; var un ; begin
2879: LD_INT 0
2881: PPUSH
2882: PPUSH
// if IsOK ( survivor ) then
2883: LD_EXP 6
2887: PPUSH
2888: CALL_OW 302
2892: IFFALSE 3079
// begin repeat un := IsInUnit ( survivor ) ;
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: LD_EXP 6
2903: PPUSH
2904: CALL_OW 310
2908: ST_TO_ADDR
// ComMoveXY ( survivor , 147 , 16 ) ;
2909: LD_EXP 6
2913: PPUSH
2914: LD_INT 147
2916: PPUSH
2917: LD_INT 16
2919: PPUSH
2920: CALL_OW 111
// wait ( 0 0$1 ) ;
2924: LD_INT 35
2926: PPUSH
2927: CALL_OW 67
// until IsInArea ( survivor , exit_area ) or IsInArea ( un , exit_area ) ;
2931: LD_EXP 6
2935: PPUSH
2936: LD_INT 25
2938: PPUSH
2939: CALL_OW 308
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PPUSH
2952: CALL_OW 308
2956: OR
2957: IFFALSE 2894
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
2959: LD_EXP 6
2963: PPUSH
2964: CALL_OW 300
2968: PPUSH
2969: LD_STRING woman_saved
2971: PPUSH
2972: CALL_OW 39
// SaveVariable ( IsLive ( survivor ) , woman_alive ) ;
2976: LD_EXP 6
2980: PPUSH
2981: CALL_OW 300
2985: PPUSH
2986: LD_STRING woman_alive
2988: PPUSH
2989: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
2993: LD_EXP 7
2997: PPUSH
2998: LD_STRING woman_in_am14
3000: PPUSH
3001: CALL_OW 39
// kappa_saved = 1 ;
3005: LD_ADDR_EXP 23
3009: PUSH
3010: LD_INT 1
3012: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
3013: LD_ADDR_VAR 0 2
3017: PUSH
3018: LD_EXP 6
3022: PPUSH
3023: CALL_OW 310
3027: ST_TO_ADDR
// veh_surv := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
3028: LD_ADDR_EXP 21
3032: PUSH
3033: LD_VAR 0 2
3037: PPUSH
3038: CALL_OW 265
3042: PUSH
3043: LD_VAR 0 2
3047: PPUSH
3048: CALL_OW 262
3052: PUSH
3053: LD_VAR 0 2
3057: PPUSH
3058: CALL_OW 263
3062: PUSH
3063: LD_VAR 0 2
3067: PPUSH
3068: CALL_OW 264
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: ST_TO_ADDR
// end ; end ; end_of_file
3079: LD_VAR 0 1
3083: RET
// export ru_ing , ru_sol , ru_sci , ru_mec ; export russians_forces ; export ru_collector ; export checking ; export reserved_people ; export function prepare_ru_base ; var un , i , num_sol , num_ing , num_sci , num_mec , lev ; begin
3084: LD_INT 0
3086: PPUSH
3087: PPUSH
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
// RevealFogArea ( russians , ru_crates ) ;
3094: LD_EXP 15
3098: PPUSH
3099: LD_INT 10
3101: PPUSH
3102: CALL_OW 332
// num_ing := [ 1 , 2 , 2 ] [ difficulty ] ;
3106: LD_ADDR_VAR 0 5
3110: PUSH
3111: LD_INT 1
3113: PUSH
3114: LD_INT 2
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_OWVAR 67
3129: ARRAY
3130: ST_TO_ADDR
// num_sol := [ 2 , 2 , 3 ] [ difficulty ] ;
3131: LD_ADDR_VAR 0 4
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 2
3141: PUSH
3142: LD_INT 3
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: LIST
3149: PUSH
3150: LD_OWVAR 67
3154: ARRAY
3155: ST_TO_ADDR
// num_sci := [ 1 , 3 , 6 ] [ difficulty ] ;
3156: LD_ADDR_VAR 0 6
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 6
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_OWVAR 67
3179: ARRAY
3180: ST_TO_ADDR
// num_mec := [ 2 , 2 , 4 ] [ difficulty ] ;
3181: LD_ADDR_VAR 0 7
3185: PUSH
3186: LD_INT 2
3188: PUSH
3189: LD_INT 2
3191: PUSH
3192: LD_INT 4
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: LD_OWVAR 67
3204: ARRAY
3205: ST_TO_ADDR
// lev := [ 6 , 8 , 10 ] [ difficulty ] ;
3206: LD_ADDR_VAR 0 8
3210: PUSH
3211: LD_INT 6
3213: PUSH
3214: LD_INT 8
3216: PUSH
3217: LD_INT 10
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: PUSH
3225: LD_OWVAR 67
3229: ARRAY
3230: ST_TO_ADDR
// russians_forces := [ ] ;
3231: LD_ADDR_EXP 28
3235: PUSH
3236: EMPTY
3237: ST_TO_ADDR
// ru_ing := [ ] ;
3238: LD_ADDR_EXP 24
3242: PUSH
3243: EMPTY
3244: ST_TO_ADDR
// ru_sol := [ ] ;
3245: LD_ADDR_EXP 25
3249: PUSH
3250: EMPTY
3251: ST_TO_ADDR
// ru_sci := [ ] ;
3252: LD_ADDR_EXP 26
3256: PUSH
3257: EMPTY
3258: ST_TO_ADDR
// ru_mec := [ ] ;
3259: LD_ADDR_EXP 27
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// reserved_people := [ ] ;
3266: LD_ADDR_EXP 31
3270: PUSH
3271: EMPTY
3272: ST_TO_ADDR
// uc_nation = nation_russian ;
3273: LD_ADDR_OWVAR 21
3277: PUSH
3278: LD_INT 3
3280: ST_TO_ADDR
// uc_side = russians ;
3281: LD_ADDR_OWVAR 20
3285: PUSH
3286: LD_EXP 15
3290: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
3291: LD_ADDR_OWVAR 24
3295: PUSH
3296: LD_INT 0
3298: PPUSH
3299: LD_INT 5
3301: PPUSH
3302: CALL_OW 12
3306: ST_TO_ADDR
// hc_gallery :=  ;
3307: LD_ADDR_OWVAR 33
3311: PUSH
3312: LD_STRING 
3314: ST_TO_ADDR
// hc_name :=  ;
3315: LD_ADDR_OWVAR 26
3319: PUSH
3320: LD_STRING 
3322: ST_TO_ADDR
// hc_importance := 0 ;
3323: LD_ADDR_OWVAR 32
3327: PUSH
3328: LD_INT 0
3330: ST_TO_ADDR
// for i := 1 to num_ing do
3331: LD_ADDR_VAR 0 3
3335: PUSH
3336: DOUBLE
3337: LD_INT 1
3339: DEC
3340: ST_TO_ADDR
3341: LD_VAR 0 5
3345: PUSH
3346: FOR_TO
3347: IFFALSE 3455
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3349: LD_ADDR_OWVAR 36
3353: PUSH
3354: LD_INT 2
3356: PPUSH
3357: LD_INT 5
3359: PPUSH
3360: CALL_OW 12
3364: ST_TO_ADDR
// PrepareEngineer ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3365: LD_INT 2
3367: PPUSH
3368: LD_INT 4
3370: PPUSH
3371: CALL_OW 12
3375: PUSH
3376: LD_INT 2
3378: MOD
3379: PUSH
3380: LD_INT 1
3382: PLUS
3383: PPUSH
3384: LD_VAR 0 8
3388: PUSH
3389: LD_INT 0
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: CALL_OW 12
3399: PLUS
3400: PPUSH
3401: CALL_OW 382
// un := CreateHuman ;
3405: LD_ADDR_VAR 0 2
3409: PUSH
3410: CALL_OW 44
3414: ST_TO_ADDR
// ru_ing := ru_ing ^ un ;
3415: LD_ADDR_EXP 24
3419: PUSH
3420: LD_EXP 24
3424: PUSH
3425: LD_VAR 0 2
3429: ADD
3430: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3431: LD_VAR 0 2
3435: PPUSH
3436: LD_INT 8
3438: PPUSH
3439: LD_INT 0
3441: PPUSH
3442: CALL_OW 49
// wait ( 1 ) ;
3446: LD_INT 1
3448: PPUSH
3449: CALL_OW 67
// end ;
3453: GO 3346
3455: POP
3456: POP
// for i := 1 to num_sol do
3457: LD_ADDR_VAR 0 3
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_VAR 0 4
3471: PUSH
3472: FOR_TO
3473: IFFALSE 3581
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3475: LD_ADDR_OWVAR 36
3479: PUSH
3480: LD_INT 2
3482: PPUSH
3483: LD_INT 5
3485: PPUSH
3486: CALL_OW 12
3490: ST_TO_ADDR
// PrepareSoldier ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3491: LD_INT 2
3493: PPUSH
3494: LD_INT 4
3496: PPUSH
3497: CALL_OW 12
3501: PUSH
3502: LD_INT 2
3504: MOD
3505: PUSH
3506: LD_INT 1
3508: PLUS
3509: PPUSH
3510: LD_VAR 0 8
3514: PUSH
3515: LD_INT 0
3517: PPUSH
3518: LD_INT 3
3520: PPUSH
3521: CALL_OW 12
3525: PLUS
3526: PPUSH
3527: CALL_OW 381
// un := CreateHuman ;
3531: LD_ADDR_VAR 0 2
3535: PUSH
3536: CALL_OW 44
3540: ST_TO_ADDR
// ru_sol := ru_sol ^ un ;
3541: LD_ADDR_EXP 25
3545: PUSH
3546: LD_EXP 25
3550: PUSH
3551: LD_VAR 0 2
3555: ADD
3556: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3557: LD_VAR 0 2
3561: PPUSH
3562: LD_INT 8
3564: PPUSH
3565: LD_INT 0
3567: PPUSH
3568: CALL_OW 49
// wait ( 1 ) ;
3572: LD_INT 1
3574: PPUSH
3575: CALL_OW 67
// end ;
3579: GO 3472
3581: POP
3582: POP
// for i := 1 to num_sci do
3583: LD_ADDR_VAR 0 3
3587: PUSH
3588: DOUBLE
3589: LD_INT 1
3591: DEC
3592: ST_TO_ADDR
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_TO
3599: IFFALSE 3707
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3601: LD_ADDR_OWVAR 36
3605: PUSH
3606: LD_INT 2
3608: PPUSH
3609: LD_INT 5
3611: PPUSH
3612: CALL_OW 12
3616: ST_TO_ADDR
// PrepareScientist ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3617: LD_INT 2
3619: PPUSH
3620: LD_INT 4
3622: PPUSH
3623: CALL_OW 12
3627: PUSH
3628: LD_INT 2
3630: MOD
3631: PUSH
3632: LD_INT 1
3634: PLUS
3635: PPUSH
3636: LD_VAR 0 8
3640: PUSH
3641: LD_INT 0
3643: PPUSH
3644: LD_INT 3
3646: PPUSH
3647: CALL_OW 12
3651: PLUS
3652: PPUSH
3653: CALL_OW 384
// un := CreateHuman ;
3657: LD_ADDR_VAR 0 2
3661: PUSH
3662: CALL_OW 44
3666: ST_TO_ADDR
// ru_sci := ru_sci ^ un ;
3667: LD_ADDR_EXP 26
3671: PUSH
3672: LD_EXP 26
3676: PUSH
3677: LD_VAR 0 2
3681: ADD
3682: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_INT 8
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: CALL_OW 49
// wait ( 1 ) ;
3698: LD_INT 1
3700: PPUSH
3701: CALL_OW 67
// end ;
3705: GO 3598
3707: POP
3708: POP
// for i := 1 to num_mec do
3709: LD_ADDR_VAR 0 3
3713: PUSH
3714: DOUBLE
3715: LD_INT 1
3717: DEC
3718: ST_TO_ADDR
3719: LD_VAR 0 7
3723: PUSH
3724: FOR_TO
3725: IFFALSE 3833
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3727: LD_ADDR_OWVAR 36
3731: PUSH
3732: LD_INT 2
3734: PPUSH
3735: LD_INT 5
3737: PPUSH
3738: CALL_OW 12
3742: ST_TO_ADDR
// PrepareMechanic ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3743: LD_INT 2
3745: PPUSH
3746: LD_INT 4
3748: PPUSH
3749: CALL_OW 12
3753: PUSH
3754: LD_INT 2
3756: MOD
3757: PUSH
3758: LD_INT 1
3760: PLUS
3761: PPUSH
3762: LD_VAR 0 8
3766: PUSH
3767: LD_INT 0
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: CALL_OW 12
3777: PLUS
3778: PPUSH
3779: CALL_OW 383
// un := CreateHuman ;
3783: LD_ADDR_VAR 0 2
3787: PUSH
3788: CALL_OW 44
3792: ST_TO_ADDR
// ru_mec := ru_mec ^ un ;
3793: LD_ADDR_EXP 27
3797: PUSH
3798: LD_EXP 27
3802: PUSH
3803: LD_VAR 0 2
3807: ADD
3808: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3809: LD_VAR 0 2
3813: PPUSH
3814: LD_INT 8
3816: PPUSH
3817: LD_INT 0
3819: PPUSH
3820: CALL_OW 49
// wait ( 1 ) ;
3824: LD_INT 1
3826: PPUSH
3827: CALL_OW 67
// end ;
3831: GO 3724
3833: POP
3834: POP
// russians_forces := ru_ing ^ ru_sol ^ ru_sci ^ ru_mec ;
3835: LD_ADDR_EXP 28
3839: PUSH
3840: LD_EXP 24
3844: PUSH
3845: LD_EXP 25
3849: ADD
3850: PUSH
3851: LD_EXP 26
3855: ADD
3856: PUSH
3857: LD_EXP 27
3861: ADD
3862: ST_TO_ADDR
// i := 1 ;
3863: LD_ADDR_VAR 0 3
3867: PUSH
3868: LD_INT 1
3870: ST_TO_ADDR
// for un in ru_mec do
3871: LD_ADDR_VAR 0 2
3875: PUSH
3876: LD_EXP 27
3880: PUSH
3881: FOR_IN
3882: IFFALSE 3947
// begin if ( i mod 2 ) = 0 then
3884: LD_VAR 0 3
3888: PUSH
3889: LD_INT 2
3891: MOD
3892: PUSH
3893: LD_INT 0
3895: EQUAL
3896: IFFALSE 3912
// ComEnterUnit ( un , ru_fact2 ) else
3898: LD_VAR 0 2
3902: PPUSH
3903: LD_INT 40
3905: PPUSH
3906: CALL_OW 120
3910: GO 3924
// ComEnterUnit ( un , ru_fact1 ) ;
3912: LD_VAR 0 2
3916: PPUSH
3917: LD_INT 1
3919: PPUSH
3920: CALL_OW 120
// i := i + 1 ;
3924: LD_ADDR_VAR 0 3
3928: PUSH
3929: LD_VAR 0 3
3933: PUSH
3934: LD_INT 1
3936: PLUS
3937: ST_TO_ADDR
// wait ( 1 ) ;
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 67
// end ;
3945: GO 3881
3947: POP
3948: POP
// for un in ru_sci do
3949: LD_ADDR_VAR 0 2
3953: PUSH
3954: LD_EXP 26
3958: PUSH
3959: FOR_IN
3960: IFFALSE 4011
// begin if ( un mod 2 ) = 0 then
3962: LD_VAR 0 2
3966: PUSH
3967: LD_INT 2
3969: MOD
3970: PUSH
3971: LD_INT 0
3973: EQUAL
3974: IFFALSE 3990
// ComEnterUnit ( un , ru_lab1 ) else
3976: LD_VAR 0 2
3980: PPUSH
3981: LD_INT 14
3983: PPUSH
3984: CALL_OW 120
3988: GO 4002
// ComEnterunit ( un , ru_lab2 ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 15
3997: PPUSH
3998: CALL_OW 120
// wait ( 1 ) ;
4002: LD_INT 1
4004: PPUSH
4005: CALL_OW 67
// end ;
4009: GO 3959
4011: POP
4012: POP
// uc_direction := Rand ( 0 , 5 ) ;
4013: LD_ADDR_OWVAR 24
4017: PUSH
4018: LD_INT 0
4020: PPUSH
4021: LD_INT 5
4023: PPUSH
4024: CALL_OW 12
4028: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
4029: LD_ADDR_OWVAR 37
4033: PUSH
4034: LD_INT 21
4036: ST_TO_ADDR
// vc_control := control_manual ;
4037: LD_ADDR_OWVAR 38
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// vc_engine := engine_combustion ;
4045: LD_ADDR_OWVAR 39
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4053: LD_ADDR_OWVAR 40
4057: PUSH
4058: LD_INT 51
4060: ST_TO_ADDR
// ru_collector := CreateVehicle ;
4061: LD_ADDR_EXP 29
4065: PUSH
4066: CALL_OW 45
4070: ST_TO_ADDR
// PlaceUnitXYR ( ru_collector , ShiftX ( GetX ( ru_depot ) , 4 , 5 ) , GetY ( ru_depot ) , 5 , false ) ;
4071: LD_EXP 29
4075: PPUSH
4076: LD_INT 22
4078: PPUSH
4079: CALL_OW 250
4083: PPUSH
4084: LD_INT 4
4086: PPUSH
4087: LD_INT 5
4089: PPUSH
4090: CALL_OW 272
4094: PPUSH
4095: LD_INT 22
4097: PPUSH
4098: CALL_OW 251
4102: PPUSH
4103: LD_INT 5
4105: PPUSH
4106: LD_INT 0
4108: PPUSH
4109: CALL_OW 50
// end ;
4113: LD_VAR 0 1
4117: RET
// export crate_list ; every 0 0$5 trigger GetListOfCratesInArea ( ru_crates ) do var un , free_unit , x , y , max , i , clear_crates , old_class , attempt ;
4118: LD_INT 10
4120: PPUSH
4121: CALL_OW 435
4125: IFFALSE 4973
4127: GO 4129
4129: DISABLE
4130: LD_INT 0
4132: PPUSH
4133: PPUSH
4134: PPUSH
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
// begin crate_list := GetListOfCratesInArea ( ru_crates ) ;
4141: LD_ADDR_EXP 32
4145: PUSH
4146: LD_INT 10
4148: PPUSH
4149: CALL_OW 435
4153: ST_TO_ADDR
// free_unit := false ;
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// i := russians_forces diff reserved_people ;
4162: LD_ADDR_VAR 0 6
4166: PUSH
4167: LD_EXP 28
4171: PUSH
4172: LD_EXP 31
4176: DIFF
4177: ST_TO_ADDR
// for un in i do
4178: LD_ADDR_VAR 0 1
4182: PUSH
4183: LD_VAR 0 6
4187: PUSH
4188: FOR_IN
4189: IFFALSE 4228
// begin if not ( HasTask ( un ) or GetUnitMc ( un ) ) then
4191: LD_VAR 0 1
4195: PPUSH
4196: CALL_OW 314
4200: PUSH
4201: LD_VAR 0 1
4205: PPUSH
4206: CALL_OW 388
4210: OR
4211: NOT
4212: IFFALSE 4226
// begin free_unit := un ;
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_VAR 0 1
4223: ST_TO_ADDR
// break ;
4224: GO 4228
// end ; end ;
4226: GO 4188
4228: POP
4229: POP
// if free_unit and IsOK ( free_unit ) then
4230: LD_VAR 0 2
4234: PUSH
4235: LD_VAR 0 2
4239: PPUSH
4240: CALL_OW 302
4244: AND
4245: IFFALSE 4972
// begin reserved_people := reserved_people ^ free_unit ;
4247: LD_ADDR_EXP 31
4251: PUSH
4252: LD_EXP 31
4256: PUSH
4257: LD_VAR 0 2
4261: ADD
4262: ST_TO_ADDR
// ComRemember ( free_unit ) ;
4263: LD_VAR 0 2
4267: PPUSH
4268: CALL_OW 143
// if IsLive ( ru_collector ) then
4272: LD_EXP 29
4276: PPUSH
4277: CALL_OW 300
4281: IFFALSE 4427
// begin repeat ComEnterUnit ( free_unit , ru_collector ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_EXP 29
4292: PPUSH
4293: CALL_OW 120
// wait ( 0 0$1 ) ;
4297: LD_INT 35
4299: PPUSH
4300: CALL_OW 67
// until ( IsInUnit ( free_unit ) ) or not IsLive ( ru_collector ) ;
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL_OW 310
4313: PUSH
4314: LD_EXP 29
4318: PPUSH
4319: CALL_OW 300
4323: NOT
4324: OR
4325: IFFALSE 4283
// if not IsLive ( ru_collector ) then
4327: LD_EXP 29
4331: PPUSH
4332: CALL_OW 300
4336: NOT
4337: IFFALSE 4415
// begin un := free_unit ;
4339: LD_ADDR_VAR 0 1
4343: PUSH
4344: LD_VAR 0 2
4348: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4349: LD_ADDR_VAR 0 8
4353: PUSH
4354: LD_VAR 0 1
4358: PPUSH
4359: CALL_OW 257
4363: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4364: LD_VAR 0 1
4368: PPUSH
4369: CALL_OW 257
4373: PUSH
4374: LD_INT 2
4376: EQUAL
4377: NOT
4378: IFFALSE 4413
// begin ComEnterUnit ( un , ru_depot ) ;
4380: LD_VAR 0 1
4384: PPUSH
4385: LD_INT 22
4387: PPUSH
4388: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4392: LD_VAR 0 1
4396: PPUSH
4397: LD_INT 2
4399: PPUSH
4400: CALL_OW 183
// wait ( 0 0$1 ) ;
4404: LD_INT 35
4406: PPUSH
4407: CALL_OW 67
// end ;
4411: GO 4364
// end else
4413: GO 4425
// un := ru_collector ;
4415: LD_ADDR_VAR 0 1
4419: PUSH
4420: LD_EXP 29
4424: ST_TO_ADDR
// end else
4425: GO 4501
// begin un := free_unit ;
4427: LD_ADDR_VAR 0 1
4431: PUSH
4432: LD_VAR 0 2
4436: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4437: LD_ADDR_VAR 0 8
4441: PUSH
4442: LD_VAR 0 1
4446: PPUSH
4447: CALL_OW 257
4451: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4452: LD_VAR 0 1
4456: PPUSH
4457: CALL_OW 257
4461: PUSH
4462: LD_INT 2
4464: EQUAL
4465: NOT
4466: IFFALSE 4501
// begin ComEnterUnit ( un , ru_depot ) ;
4468: LD_VAR 0 1
4472: PPUSH
4473: LD_INT 22
4475: PPUSH
4476: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4480: LD_VAR 0 1
4484: PPUSH
4485: LD_INT 2
4487: PPUSH
4488: CALL_OW 183
// wait ( 0 0$1 ) ;
4492: LD_INT 35
4494: PPUSH
4495: CALL_OW 67
// end ;
4499: GO 4452
// end ; if IsLive ( ru_collector ) then
4501: LD_EXP 29
4505: PPUSH
4506: CALL_OW 300
4510: IFFALSE 4541
// ComCollect ( un , crate_list [ 1 ] , crate_list [ 2 ] ) else
4512: LD_VAR 0 1
4516: PPUSH
4517: LD_EXP 32
4521: PUSH
4522: LD_INT 1
4524: ARRAY
4525: PPUSH
4526: LD_EXP 32
4530: PUSH
4531: LD_INT 2
4533: ARRAY
4534: PPUSH
4535: CALL_OW 117
4539: GO 4568
// ComGet ( un , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4541: LD_VAR 0 1
4545: PPUSH
4546: LD_EXP 32
4550: PUSH
4551: LD_INT 1
4553: ARRAY
4554: PPUSH
4555: LD_EXP 32
4559: PUSH
4560: LD_INT 2
4562: ARRAY
4563: PPUSH
4564: CALL_OW 160
// clear_crates := false ;
4568: LD_ADDR_VAR 0 7
4572: PUSH
4573: LD_INT 0
4575: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4576: LD_INT 35
4578: PPUSH
4579: CALL_OW 67
// if IsLive ( ru_collector ) and GetFuel ( un ) < 25 then
4583: LD_EXP 29
4587: PPUSH
4588: CALL_OW 300
4592: PUSH
4593: LD_VAR 0 1
4597: PPUSH
4598: CALL_OW 261
4602: PUSH
4603: LD_INT 25
4605: LESS
4606: AND
4607: IFFALSE 4700
// begin clear_crates := true ;
4609: LD_ADDR_VAR 0 7
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// if not SeeXY ( you , crate_list [ 1 ] , crate_list [ 2 ] ) then
4617: LD_EXP 14
4621: PPUSH
4622: LD_EXP 32
4626: PUSH
4627: LD_INT 1
4629: ARRAY
4630: PPUSH
4631: LD_EXP 32
4635: PUSH
4636: LD_INT 2
4638: ARRAY
4639: PPUSH
4640: CALL_OW 293
4644: NOT
4645: IFFALSE 4700
// begin MoveAreaXY ( crates_end , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4647: LD_INT 34
4649: PPUSH
4650: LD_EXP 32
4654: PUSH
4655: LD_INT 1
4657: ARRAY
4658: PPUSH
4659: LD_EXP 32
4663: PUSH
4664: LD_INT 2
4666: ARRAY
4667: PPUSH
4668: CALL_OW 425
// EraseResourceArea ( crates_end , mat_cans ) ;
4672: LD_INT 34
4674: PPUSH
4675: LD_INT 1
4677: PPUSH
4678: CALL_OW 286
// AddResourceType ( GetBase ( ru_depot ) , mat_cans , 50 ) ;
4682: LD_INT 22
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 1
4692: PPUSH
4693: LD_INT 50
4695: PPUSH
4696: CALL_OW 276
// end ; end ; until ( not IsBusy ( un ) ) or clear_crates ;
4700: LD_VAR 0 1
4704: PPUSH
4705: CALL_OW 315
4709: NOT
4710: PUSH
4711: LD_VAR 0 7
4715: OR
4716: IFFALSE 4576
// if IsLive ( ru_collector ) then
4718: LD_EXP 29
4722: PPUSH
4723: CALL_OW 300
4727: IFFALSE 4761
// begin ComMoveUnit ( ru_collector , ru_depot ) ;
4729: LD_EXP 29
4733: PPUSH
4734: LD_INT 22
4736: PPUSH
4737: CALL_OW 112
// AddComExitVehicle ( ru_collector ) ;
4741: LD_EXP 29
4745: PPUSH
4746: CALL_OW 181
// ComReturn ( free_unit ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: CALL_OW 144
// end else
4759: GO 4956
// begin case old_class of class_mechanic :
4761: LD_VAR 0 8
4765: PUSH
4766: LD_INT 3
4768: DOUBLE
4769: EQUAL
4770: IFTRUE 4774
4772: GO 4826
4774: POP
// begin if IsOK ( ru_fact1 ) then
4775: LD_INT 1
4777: PPUSH
4778: CALL_OW 302
4782: IFFALSE 4798
// ComEnterUnit ( un , ru_fact1 ) else
4784: LD_VAR 0 1
4788: PPUSH
4789: LD_INT 1
4791: PPUSH
4792: CALL_OW 120
4796: GO 4810
// ComEnterUnit ( un , ru_fact2 ) ;
4798: LD_VAR 0 1
4802: PPUSH
4803: LD_INT 40
4805: PPUSH
4806: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4810: LD_VAR 0 1
4814: PPUSH
4815: LD_VAR 0 8
4819: PPUSH
4820: CALL_OW 183
// end ; class_scientistic :
4824: GO 4947
4826: LD_INT 4
4828: DOUBLE
4829: EQUAL
4830: IFTRUE 4834
4832: GO 4886
4834: POP
// begin if IsOK ( ru_lab1 ) then
4835: LD_INT 14
4837: PPUSH
4838: CALL_OW 302
4842: IFFALSE 4858
// ComEnterUnit ( un , ru_lab1 ) else
4844: LD_VAR 0 1
4848: PPUSH
4849: LD_INT 14
4851: PPUSH
4852: CALL_OW 120
4856: GO 4870
// ComEnterUnit ( un , ru_lab2 ) ;
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 15
4865: PPUSH
4866: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4870: LD_VAR 0 1
4874: PPUSH
4875: LD_VAR 0 8
4879: PPUSH
4880: CALL_OW 183
// end ; class_soldier :
4884: GO 4947
4886: LD_INT 1
4888: DOUBLE
4889: EQUAL
4890: IFTRUE 4894
4892: GO 4923
4894: POP
// begin ComEnterUnit ( un , ru_barac ) ;
4895: LD_VAR 0 1
4899: PPUSH
4900: LD_INT 45
4902: PPUSH
4903: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4907: LD_VAR 0 1
4911: PPUSH
4912: LD_VAR 0 8
4916: PPUSH
4917: CALL_OW 183
// end ; class_engineer :
4921: GO 4947
4923: LD_INT 2
4925: DOUBLE
4926: EQUAL
4927: IFTRUE 4931
4929: GO 4946
4931: POP
// ComMoveUnit ( un , ru_depot ) ; end ;
4932: LD_VAR 0 1
4936: PPUSH
4937: LD_INT 22
4939: PPUSH
4940: CALL_OW 112
4944: GO 4947
4946: POP
// AddComReturn ( un ) ;
4947: LD_VAR 0 1
4951: PPUSH
4952: CALL_OW 204
// end ; reserved_people := reserved_people diff free_unit ;
4956: LD_ADDR_EXP 31
4960: PUSH
4961: LD_EXP 31
4965: PUSH
4966: LD_VAR 0 2
4970: DIFF
4971: ST_TO_ADDR
// end ; enable ;
4972: ENABLE
// end ;
4973: PPOPN 9
4975: END
// function ukradni_macmillanovi_auto ; var un ; begin
4976: LD_INT 0
4978: PPUSH
4979: PPUSH
// for un in ru_sol do
4980: LD_ADDR_VAR 0 2
4984: PUSH
4985: LD_EXP 25
4989: PUSH
4990: FOR_IN
4991: IFFALSE 5020
// if IsOK ( un ) then
4993: LD_VAR 0 2
4997: PPUSH
4998: CALL_OW 302
5002: IFFALSE 5018
// ComEnterUnit ( un , truck1 ) ;
5004: LD_VAR 0 2
5008: PPUSH
5009: LD_EXP 8
5013: PPUSH
5014: CALL_OW 120
5018: GO 4990
5020: POP
5021: POP
// AddComAgressiveMove ( ru_sol , 69 , 35 ) ;
5022: LD_EXP 25
5026: PPUSH
5027: LD_INT 69
5029: PPUSH
5030: LD_INT 35
5032: PPUSH
5033: CALL_OW 174
// AddComReturn ( ru_sol ) ;
5037: LD_EXP 25
5041: PPUSH
5042: CALL_OW 204
// wait ( 0 0$20 ) ;
5046: LD_INT 700
5048: PPUSH
5049: CALL_OW 67
// end ;
5053: LD_VAR 0 1
5057: RET
// every 6 6$0 do var way_ru_patrol , x , y , i , max ;
5058: GO 5060
5060: DISABLE
5061: LD_INT 0
5063: PPUSH
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
// begin way_ru_patrol := [ 88 , 47 , 69 , 36 , 42 , 16 , 33 , 14 , 16 , 6 , 6 , 6 , 19 , 29 , 34 , 38 , 47 , 42 , 44 , 27 , 61 , 45 , 66 , 33 , 110 , 58 ] ;
5068: LD_ADDR_VAR 0 1
5072: PUSH
5073: LD_INT 88
5075: PUSH
5076: LD_INT 47
5078: PUSH
5079: LD_INT 69
5081: PUSH
5082: LD_INT 36
5084: PUSH
5085: LD_INT 42
5087: PUSH
5088: LD_INT 16
5090: PUSH
5091: LD_INT 33
5093: PUSH
5094: LD_INT 14
5096: PUSH
5097: LD_INT 16
5099: PUSH
5100: LD_INT 6
5102: PUSH
5103: LD_INT 6
5105: PUSH
5106: LD_INT 6
5108: PUSH
5109: LD_INT 19
5111: PUSH
5112: LD_INT 29
5114: PUSH
5115: LD_INT 34
5117: PUSH
5118: LD_INT 38
5120: PUSH
5121: LD_INT 47
5123: PUSH
5124: LD_INT 42
5126: PUSH
5127: LD_INT 44
5129: PUSH
5130: LD_INT 27
5132: PUSH
5133: LD_INT 61
5135: PUSH
5136: LD_INT 45
5138: PUSH
5139: LD_INT 66
5141: PUSH
5142: LD_INT 33
5144: PUSH
5145: LD_INT 110
5147: PUSH
5148: LD_INT 58
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: ST_TO_ADDR
// ComRemember ( ru_sol ) ;
5179: LD_EXP 25
5183: PPUSH
5184: CALL_OW 143
// reserved_people := reserved_people ^ ru_sol ;
5188: LD_ADDR_EXP 31
5192: PUSH
5193: LD_EXP 31
5197: PUSH
5198: LD_EXP 25
5202: ADD
5203: ST_TO_ADDR
// max := 0 + way_ru_patrol ;
5204: LD_ADDR_VAR 0 5
5208: PUSH
5209: LD_INT 0
5211: PUSH
5212: LD_VAR 0 1
5216: PLUS
5217: ST_TO_ADDR
// for i := 1 to ( max div 2 ) do
5218: LD_ADDR_VAR 0 4
5222: PUSH
5223: DOUBLE
5224: LD_INT 1
5226: DEC
5227: ST_TO_ADDR
5228: LD_VAR 0 5
5232: PUSH
5233: LD_INT 2
5235: DIV
5236: PUSH
5237: FOR_TO
5238: IFFALSE 5305
// begin x := way_ru_patrol [ ( 2 * i ) - 1 ] ;
5240: LD_ADDR_VAR 0 2
5244: PUSH
5245: LD_VAR 0 1
5249: PUSH
5250: LD_INT 2
5252: PUSH
5253: LD_VAR 0 4
5257: MUL
5258: PUSH
5259: LD_INT 1
5261: MINUS
5262: ARRAY
5263: ST_TO_ADDR
// y := way_ru_patrol [ ( 2 * i ) ] ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: LD_VAR 0 1
5273: PUSH
5274: LD_INT 2
5276: PUSH
5277: LD_VAR 0 4
5281: MUL
5282: ARRAY
5283: ST_TO_ADDR
// AddComAgressiveMove ( ru_sol , x , y ) ;
5284: LD_EXP 25
5288: PPUSH
5289: LD_VAR 0 2
5293: PPUSH
5294: LD_VAR 0 3
5298: PPUSH
5299: CALL_OW 174
// end ;
5303: GO 5237
5305: POP
5306: POP
// repeat if See ( russians , truck1 ) then
5307: LD_EXP 15
5311: PPUSH
5312: LD_EXP 8
5316: PPUSH
5317: CALL_OW 292
5321: IFFALSE 5327
// ukradni_macmillanovi_auto ;
5323: CALL 4976 0 0
// wait ( 0 0$1 ) ;
5327: LD_INT 35
5329: PPUSH
5330: CALL_OW 67
// until at_home ( ru_sol ) ;
5334: LD_EXP 25
5338: PPUSH
5339: CALL 5364 0 1
5343: IFFALSE 5307
// reserved_people := reserved_people diff ru_sol ;
5345: LD_ADDR_EXP 31
5349: PUSH
5350: LD_EXP 31
5354: PUSH
5355: LD_EXP 25
5359: DIFF
5360: ST_TO_ADDR
// end ;
5361: PPOPN 5
5363: END
// function at_home ( list ) ; var un , vysledek ; begin
5364: LD_INT 0
5366: PPUSH
5367: PPUSH
5368: PPUSH
// vysledek := true ;
5369: LD_ADDR_VAR 0 4
5373: PUSH
5374: LD_INT 1
5376: ST_TO_ADDR
// for un in list do
5377: LD_ADDR_VAR 0 3
5381: PUSH
5382: LD_VAR 0 1
5386: PUSH
5387: FOR_IN
5388: IFFALSE 5428
// if IsOK ( un ) and not IsInArea ( un , RU_Base ) then
5390: LD_VAR 0 3
5394: PPUSH
5395: CALL_OW 302
5399: PUSH
5400: LD_VAR 0 3
5404: PPUSH
5405: LD_INT 2
5407: PPUSH
5408: CALL_OW 308
5412: NOT
5413: AND
5414: IFFALSE 5426
// begin vysledek := false ;
5416: LD_ADDR_VAR 0 4
5420: PUSH
5421: LD_INT 0
5423: ST_TO_ADDR
// break ;
5424: GO 5428
// end ;
5426: GO 5387
5428: POP
5429: POP
// result := vysledek ;
5430: LD_ADDR_VAR 0 2
5434: PUSH
5435: LD_VAR 0 4
5439: ST_TO_ADDR
// end ; end_of_file
5440: LD_VAR 0 2
5444: RET
// export odpoved ; export visit_base ; var dialogue_running ; export function starting_scene ; var x , y ; begin
5445: LD_INT 0
5447: PPUSH
5448: PPUSH
5449: PPUSH
// CenterNowOnUnits ( truck1 ) ;
5450: LD_EXP 8
5454: PPUSH
5455: CALL_OW 87
// interface_hidden := true ;
5459: LD_ADDR_OWVAR 54
5463: PUSH
5464: LD_INT 1
5466: ST_TO_ADDR
// InGameOn ;
5467: CALL_OW 8
// ComMoveXY ( truck1 , 20 , 7 ) ;
5471: LD_EXP 8
5475: PPUSH
5476: LD_INT 20
5478: PPUSH
5479: LD_INT 7
5481: PPUSH
5482: CALL_OW 111
// AddComMoveXY ( truck1 , 27 , 10 ) ;
5486: LD_EXP 8
5490: PPUSH
5491: LD_INT 27
5493: PPUSH
5494: LD_INT 10
5496: PPUSH
5497: CALL_OW 171
// AddComMoveXY ( truck1 , 37 , 16 ) ;
5501: LD_EXP 8
5505: PPUSH
5506: LD_INT 37
5508: PPUSH
5509: LD_INT 16
5511: PPUSH
5512: CALL_OW 171
// wait ( 0 0$3 ) ;
5516: LD_INT 105
5518: PPUSH
5519: CALL_OW 67
// async ;
5523: ASYNC
// SayRadio ( Powell , D1-Pow-1 ) ;
5524: LD_EXP 2
5528: PPUSH
5529: LD_STRING D1-Pow-1
5531: PPUSH
5532: CALL_OW 94
// sync ;
5536: SYNC
// wait ( 0 0$2 ) ;
5537: LD_INT 70
5539: PPUSH
5540: CALL_OW 67
// ComStop ( MacMillan ) ;
5544: LD_EXP 1
5548: PPUSH
5549: CALL_OW 141
// ComExitVehicle ( truck1 ) ;
5553: LD_EXP 8
5557: PPUSH
5558: CALL_OW 121
// x := GetX ( MacMillan ) + 10 ;
5562: LD_ADDR_VAR 0 2
5566: PUSH
5567: LD_EXP 1
5571: PPUSH
5572: CALL_OW 250
5576: PUSH
5577: LD_INT 10
5579: PLUS
5580: ST_TO_ADDR
// y := GetY ( MacMillan ) + 10 ;
5581: LD_ADDR_VAR 0 3
5585: PUSH
5586: LD_EXP 1
5590: PPUSH
5591: CALL_OW 251
5595: PUSH
5596: LD_INT 10
5598: PLUS
5599: ST_TO_ADDR
// ComMoveXY ( MacMillan , x , y ) ;
5600: LD_EXP 1
5604: PPUSH
5605: LD_VAR 0 2
5609: PPUSH
5610: LD_VAR 0 3
5614: PPUSH
5615: CALL_OW 111
// wait ( 0 0$2 ) ;
5619: LD_INT 70
5621: PPUSH
5622: CALL_OW 67
// InGameOff ;
5626: CALL_OW 9
// DialogueOn ;
5630: CALL_OW 6
// interface_hidden := true ;
5634: LD_ADDR_OWVAR 54
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
5642: LD_EXP 1
5646: PPUSH
5647: LD_STRING D1-JMM-1
5649: PPUSH
5650: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
5654: LD_EXP 2
5658: PPUSH
5659: LD_STRING D1-Pow-2
5661: PPUSH
5662: CALL_OW 94
// Say ( MacMillan , D1-JMM-2 ) ;
5666: LD_EXP 1
5670: PPUSH
5671: LD_STRING D1-JMM-2
5673: PPUSH
5674: CALL_OW 88
// SaveForQuickRestart ;
5678: CALL_OW 22
// wait ( 0 0$0.5 ) ;
5682: LD_INT 18
5684: PPUSH
5685: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5689: LD_STRING M1
5691: PPUSH
5692: CALL_OW 337
// DialogueOff ;
5696: CALL_OW 7
// interface_hidden := false ;
5700: LD_ADDR_OWVAR 54
5704: PUSH
5705: LD_INT 0
5707: ST_TO_ADDR
// dialogue_running := false ;
5708: LD_ADDR_LOC 3
5712: PUSH
5713: LD_INT 0
5715: ST_TO_ADDR
// end ;
5716: LD_VAR 0 1
5720: RET
// function odpoved_joan ; begin
5721: LD_INT 0
5723: PPUSH
// case odpoved of 1 :
5724: LD_EXP 33
5728: PUSH
5729: LD_INT 1
5731: DOUBLE
5732: EQUAL
5733: IFTRUE 5737
5735: GO 5776
5737: POP
// begin Say ( MacMillan , D2Ja-JMM-1 ) ;
5738: LD_EXP 1
5742: PPUSH
5743: LD_STRING D2Ja-JMM-1
5745: PPUSH
5746: CALL_OW 88
// SayRadio ( Joan , D2Ja-Joan-1 ) ;
5750: LD_EXP 3
5754: PPUSH
5755: LD_STRING D2Ja-Joan-1
5757: PPUSH
5758: CALL_OW 94
// Say ( MacMillan , D2Ja-JMM-2 ) ;
5762: LD_EXP 1
5766: PPUSH
5767: LD_STRING D2Ja-JMM-2
5769: PPUSH
5770: CALL_OW 88
// end ; 2 :
5774: GO 5871
5776: LD_INT 2
5778: DOUBLE
5779: EQUAL
5780: IFTRUE 5784
5782: GO 5847
5784: POP
// begin Say ( MacMillan , D2Jb-JMM-1 ) ;
5785: LD_EXP 1
5789: PPUSH
5790: LD_STRING D2Jb-JMM-1
5792: PPUSH
5793: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-1 ) ;
5797: LD_EXP 3
5801: PPUSH
5802: LD_STRING D2Jb-Joan-1
5804: PPUSH
5805: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-2 ) ;
5809: LD_EXP 1
5813: PPUSH
5814: LD_STRING D2Jb-JMM-2
5816: PPUSH
5817: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-2 ) ;
5821: LD_EXP 3
5825: PPUSH
5826: LD_STRING D2Jb-Joan-2
5828: PPUSH
5829: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-3 ) ;
5833: LD_EXP 1
5837: PPUSH
5838: LD_STRING D2Jb-JMM-3
5840: PPUSH
5841: CALL_OW 88
// end ; 3 :
5845: GO 5871
5847: LD_INT 3
5849: DOUBLE
5850: EQUAL
5851: IFTRUE 5855
5853: GO 5870
5855: POP
// begin SayRadio ( Joan , D2Jc-Joan-1 ) ;
5856: LD_EXP 3
5860: PPUSH
5861: LD_STRING D2Jc-Joan-1
5863: PPUSH
5864: CALL_OW 94
// end ; end ;
5868: GO 5871
5870: POP
// end ;
5871: LD_VAR 0 1
5875: RET
// function odpoved_lisa ; begin
5876: LD_INT 0
5878: PPUSH
// case odpoved of 1 :
5879: LD_EXP 33
5883: PUSH
5884: LD_INT 1
5886: DOUBLE
5887: EQUAL
5888: IFTRUE 5892
5890: GO 5955
5892: POP
// begin Say ( MacMillan , D2La-JMM-1 ) ;
5893: LD_EXP 1
5897: PPUSH
5898: LD_STRING D2La-JMM-1
5900: PPUSH
5901: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-1 ) ;
5905: LD_EXP 4
5909: PPUSH
5910: LD_STRING D2La-Lisa-1
5912: PPUSH
5913: CALL_OW 94
// Say ( MacMillan , D2La-JMM-2 ) ;
5917: LD_EXP 1
5921: PPUSH
5922: LD_STRING D2La-JMM-2
5924: PPUSH
5925: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-2 ) ;
5929: LD_EXP 4
5933: PPUSH
5934: LD_STRING D2La-Lisa-2
5936: PPUSH
5937: CALL_OW 94
// Say ( MacMillan , D2La-JMM-3 ) ;
5941: LD_EXP 1
5945: PPUSH
5946: LD_STRING D2La-JMM-3
5948: PPUSH
5949: CALL_OW 88
// end ; 2 :
5953: GO 6038
5955: LD_INT 2
5957: DOUBLE
5958: EQUAL
5959: IFTRUE 5963
5961: GO 6014
5963: POP
// begin Say ( MacMillan , D2Lb-JMM-1 ) ;
5964: LD_EXP 1
5968: PPUSH
5969: LD_STRING D2Lb-JMM-1
5971: PPUSH
5972: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-1 ) ;
5976: LD_EXP 4
5980: PPUSH
5981: LD_STRING D2Lb-Lisa-1
5983: PPUSH
5984: CALL_OW 94
// Say ( MacMillan , D2Lb-JMM-2 ) ;
5988: LD_EXP 1
5992: PPUSH
5993: LD_STRING D2Lb-JMM-2
5995: PPUSH
5996: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-2 ) ;
6000: LD_EXP 4
6004: PPUSH
6005: LD_STRING D2Lb-Lisa-2
6007: PPUSH
6008: CALL_OW 94
// end ; 3 :
6012: GO 6038
6014: LD_INT 3
6016: DOUBLE
6017: EQUAL
6018: IFTRUE 6022
6020: GO 6037
6022: POP
// begin SayRadio ( Lisa , D2Lc-Lisa-1 ) ;
6023: LD_EXP 4
6027: PPUSH
6028: LD_STRING D2Lc-Lisa-1
6030: PPUSH
6031: CALL_OW 94
// end ; end ;
6035: GO 6038
6037: POP
// end ;
6038: LD_VAR 0 1
6042: RET
// function odpoved_anezka ; begin
6043: LD_INT 0
6045: PPUSH
// case odpoved of 1 :
6046: LD_EXP 33
6050: PUSH
6051: LD_INT 1
6053: DOUBLE
6054: EQUAL
6055: IFTRUE 6059
6057: GO 6074
6059: POP
// begin Say ( MacMillan , D2Xa-JMM-1 ) ;
6060: LD_EXP 1
6064: PPUSH
6065: LD_STRING D2Xa-JMM-1
6067: PPUSH
6068: CALL_OW 88
// end ; 2 :
6072: GO 6133
6074: LD_INT 2
6076: DOUBLE
6077: EQUAL
6078: IFTRUE 6082
6080: GO 6109
6082: POP
// begin Say ( MacMillan , D2Xb-JMM-1 ) ;
6083: LD_EXP 1
6087: PPUSH
6088: LD_STRING D2Xb-JMM-1
6090: PPUSH
6091: CALL_OW 88
// SayRadio ( anezka , D2Xb-Con-1 ) ;
6095: LD_EXP 5
6099: PPUSH
6100: LD_STRING D2Xb-Con-1
6102: PPUSH
6103: CALL_OW 94
// end ; 3 :
6107: GO 6133
6109: LD_INT 3
6111: DOUBLE
6112: EQUAL
6113: IFTRUE 6117
6115: GO 6132
6117: POP
// begin SayRadio ( anezka , D2Xc-Con-1 ) ;
6118: LD_EXP 5
6122: PPUSH
6123: LD_STRING D2Xc-Con-1
6125: PPUSH
6126: CALL_OW 94
// end ; end ;
6130: GO 6133
6132: POP
// end ;
6133: LD_VAR 0 1
6137: RET
// every 0 0$1 trigger IsInArea ( MacMillan , help_calling ) and ( not visit_base ) do
6138: LD_EXP 1
6142: PPUSH
6143: LD_INT 5
6145: PPUSH
6146: CALL_OW 308
6150: PUSH
6151: LD_EXP 34
6155: NOT
6156: AND
6157: IFFALSE 6563
6159: GO 6161
6161: DISABLE
// begin DialogueOn ;
6162: CALL_OW 6
// interface_hidden := true ;
6166: LD_ADDR_OWVAR 54
6170: PUSH
6171: LD_INT 1
6173: ST_TO_ADDR
// case who_survive of 1 :
6174: LD_EXP 7
6178: PUSH
6179: LD_INT 1
6181: DOUBLE
6182: EQUAL
6183: IFTRUE 6187
6185: GO 6202
6187: POP
// SayRadio ( Joan , D2J-Joan-1 ) ; 2 :
6188: LD_EXP 3
6192: PPUSH
6193: LD_STRING D2J-Joan-1
6195: PPUSH
6196: CALL_OW 94
6200: GO 6249
6202: LD_INT 2
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6225
6210: POP
// SayRadio ( Lisa , D2L-Lisa-1 ) ; 3 :
6211: LD_EXP 4
6215: PPUSH
6216: LD_STRING D2L-Lisa-1
6218: PPUSH
6219: CALL_OW 94
6223: GO 6249
6225: LD_INT 3
6227: DOUBLE
6228: EQUAL
6229: IFTRUE 6233
6231: GO 6248
6233: POP
// SayRadio ( anezka , D2X-Con-1 ) ; end ;
6234: LD_EXP 5
6238: PPUSH
6239: LD_STRING D2X-Con-1
6241: PPUSH
6242: CALL_OW 94
6246: GO 6249
6248: POP
// if Query ( Q1 ) = 2 then
6249: LD_STRING Q1
6251: PPUSH
6252: CALL_OW 97
6256: PUSH
6257: LD_INT 2
6259: EQUAL
6260: IFFALSE 6276
// begin DialogueOff ;
6262: CALL_OW 7
// interface_hidden := false ;
6266: LD_ADDR_OWVAR 54
6270: PUSH
6271: LD_INT 0
6273: ST_TO_ADDR
// exit ;
6274: GO 6563
// end ; case who_survive of 1 :
6276: LD_EXP 7
6280: PUSH
6281: LD_INT 1
6283: DOUBLE
6284: EQUAL
6285: IFTRUE 6289
6287: GO 6340
6289: POP
// begin Say ( MacMillan , D2J-JMM-1 ) ;
6290: LD_EXP 1
6294: PPUSH
6295: LD_STRING D2J-JMM-1
6297: PPUSH
6298: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-2 ) ;
6302: LD_EXP 3
6306: PPUSH
6307: LD_STRING D2J-Joan-2
6309: PPUSH
6310: CALL_OW 94
// Say ( MacMillan , D2J-JMM-2 ) ;
6314: LD_EXP 1
6318: PPUSH
6319: LD_STRING D2J-JMM-2
6321: PPUSH
6322: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-3 ) ;
6326: LD_EXP 3
6330: PPUSH
6331: LD_STRING D2J-Joan-3
6333: PPUSH
6334: CALL_OW 94
// end ; 2 :
6338: GO 6435
6340: LD_INT 2
6342: DOUBLE
6343: EQUAL
6344: IFTRUE 6348
6346: GO 6399
6348: POP
// begin Say ( MacMillan , D2L-JMM-1 ) ;
6349: LD_EXP 1
6353: PPUSH
6354: LD_STRING D2L-JMM-1
6356: PPUSH
6357: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-2 ) ;
6361: LD_EXP 4
6365: PPUSH
6366: LD_STRING D2L-Lisa-2
6368: PPUSH
6369: CALL_OW 94
// Say ( MacMillan , D2L-JMM-2 ) ;
6373: LD_EXP 1
6377: PPUSH
6378: LD_STRING D2L-JMM-2
6380: PPUSH
6381: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-3 ) ;
6385: LD_EXP 4
6389: PPUSH
6390: LD_STRING D2L-Lisa-3
6392: PPUSH
6393: CALL_OW 94
// end ; 3 :
6397: GO 6435
6399: LD_INT 3
6401: DOUBLE
6402: EQUAL
6403: IFTRUE 6407
6405: GO 6434
6407: POP
// begin Say ( MacMillan , D2X-JMM-1 ) ;
6408: LD_EXP 1
6412: PPUSH
6413: LD_STRING D2X-JMM-1
6415: PPUSH
6416: CALL_OW 88
// SayRadio ( anezka , D2X-Con-2 ) ;
6420: LD_EXP 5
6424: PPUSH
6425: LD_STRING D2X-Con-2
6427: PPUSH
6428: CALL_OW 94
// end ; end ;
6432: GO 6435
6434: POP
// wait ( 0 0$1 ) ;
6435: LD_INT 35
6437: PPUSH
6438: CALL_OW 67
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6442: LD_EXP 2
6446: PPUSH
6447: LD_STRING DPowell-Pow-1
6449: PPUSH
6450: CALL_OW 94
// wait ( 0 0$1 ) ;
6454: LD_INT 35
6456: PPUSH
6457: CALL_OW 67
// case who_survive of 1 :
6461: LD_EXP 7
6465: PUSH
6466: LD_INT 1
6468: DOUBLE
6469: EQUAL
6470: IFTRUE 6474
6472: GO 6494
6474: POP
// begin odpoved := Query ( Q2J ) ;
6475: LD_ADDR_EXP 33
6479: PUSH
6480: LD_STRING Q2J
6482: PPUSH
6483: CALL_OW 97
6487: ST_TO_ADDR
// odpoved_joan ;
6488: CALL 5721 0 0
// end ; 2 :
6492: GO 6551
6494: LD_INT 2
6496: DOUBLE
6497: EQUAL
6498: IFTRUE 6502
6500: GO 6522
6502: POP
// begin odpoved := Query ( Q2L ) ;
6503: LD_ADDR_EXP 33
6507: PUSH
6508: LD_STRING Q2L
6510: PPUSH
6511: CALL_OW 97
6515: ST_TO_ADDR
// odpoved_lisa ;
6516: CALL 5876 0 0
// end ; 3 :
6520: GO 6551
6522: LD_INT 3
6524: DOUBLE
6525: EQUAL
6526: IFTRUE 6530
6528: GO 6550
6530: POP
// begin odpoved := Query ( Q2X ) ;
6531: LD_ADDR_EXP 33
6535: PUSH
6536: LD_STRING Q2X
6538: PPUSH
6539: CALL_OW 97
6543: ST_TO_ADDR
// odpoved_anezka ;
6544: CALL 6043 0 0
// end ; end ;
6548: GO 6551
6550: POP
// DialogueOff ;
6551: CALL_OW 7
// interface_hidden := false ;
6555: LD_ADDR_OWVAR 54
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// end ;
6563: END
// every 0 0$1 trigger IsInArea ( MacMillan , US_base ) do var dist , list ;
6564: LD_EXP 1
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: CALL_OW 308
6576: IFFALSE 7287
6578: GO 6580
6580: DISABLE
6581: LD_INT 0
6583: PPUSH
6584: PPUSH
// begin ComMoveUnit ( survivor , MacMillan ) ;
6585: LD_EXP 6
6589: PPUSH
6590: LD_EXP 1
6594: PPUSH
6595: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6599: LD_INT 35
6601: PPUSH
6602: CALL_OW 67
// until See ( you , survivor ) ;
6606: LD_EXP 14
6610: PPUSH
6611: LD_EXP 6
6615: PPUSH
6616: CALL_OW 292
6620: IFFALSE 6599
// SetSideBase ( GetBase ( us_depot ) , you ) ;
6622: LD_INT 48
6624: PPUSH
6625: CALL_OW 274
6629: PPUSH
6630: LD_EXP 14
6634: PPUSH
6635: CALL_OW 236
// SetSide ( survivor , you ) ;
6639: LD_EXP 6
6643: PPUSH
6644: LD_EXP 14
6648: PPUSH
6649: CALL_OW 235
// SetSide ( us_trucks , you ) ;
6653: LD_EXP 35
6657: PPUSH
6658: LD_EXP 14
6662: PPUSH
6663: CALL_OW 235
// list := FilterAllUnits ( [ [ f_side , neutral ] , [ f_class , class_apeman_engineer ] ] ) ;
6667: LD_ADDR_VAR 0 2
6671: PUSH
6672: LD_INT 22
6674: PUSH
6675: LD_EXP 16
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: LD_INT 25
6686: PUSH
6687: LD_INT 16
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PPUSH
6698: CALL_OW 69
6702: ST_TO_ADDR
// SetSide ( list , you ) ;
6703: LD_VAR 0 2
6707: PPUSH
6708: LD_EXP 14
6712: PPUSH
6713: CALL_OW 235
// visit_base := true ;
6717: LD_ADDR_EXP 34
6721: PUSH
6722: LD_INT 1
6724: ST_TO_ADDR
// InGameOn ;
6725: CALL_OW 8
// if IsOK ( Joan ) then
6729: LD_EXP 3
6733: PPUSH
6734: CALL_OW 302
6738: IFFALSE 6750
// dist := 1 else
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_INT 1
6747: ST_TO_ADDR
6748: GO 6758
// dist := 3 ;
6750: LD_ADDR_VAR 0 1
6754: PUSH
6755: LD_INT 3
6757: ST_TO_ADDR
// list := TICK ;
6758: LD_ADDR_VAR 0 2
6762: PUSH
6763: LD_OWVAR 1
6767: ST_TO_ADDR
// while ( GetDistUnits ( MacMillan , survivor ) > dist ) and ( ( list + 0 0$6 ) > TICK ) do
6768: LD_EXP 1
6772: PPUSH
6773: LD_EXP 6
6777: PPUSH
6778: CALL_OW 296
6782: PUSH
6783: LD_VAR 0 1
6787: GREATER
6788: PUSH
6789: LD_VAR 0 2
6793: PUSH
6794: LD_INT 210
6796: PLUS
6797: PUSH
6798: LD_OWVAR 1
6802: GREATER
6803: AND
6804: IFFALSE 6861
// begin ComMoveUnit ( survivor , MacMillan ) ;
6806: LD_EXP 6
6810: PPUSH
6811: LD_EXP 1
6815: PPUSH
6816: CALL_OW 112
// ComMoveUnit ( MacMillan , survivor ) ;
6820: LD_EXP 1
6824: PPUSH
6825: LD_EXP 6
6829: PPUSH
6830: CALL_OW 112
// wait ( 20 ) ;
6834: LD_INT 20
6836: PPUSH
6837: CALL_OW 67
// CenterOnUnits ( [ MacMillan , survivor ] ) ;
6841: LD_EXP 1
6845: PUSH
6846: LD_EXP 6
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 85
// end ;
6859: GO 6768
// ComStop ( [ MacMillan , survivor ] ) ;
6861: LD_EXP 1
6865: PUSH
6866: LD_EXP 6
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PPUSH
6875: CALL_OW 141
// ComTurnUnit ( survivor , MacMillan ) ;
6879: LD_EXP 6
6883: PPUSH
6884: LD_EXP 1
6888: PPUSH
6889: CALL_OW 119
// ComTurnUnit ( MacMillan , survivor ) ;
6893: LD_EXP 1
6897: PPUSH
6898: LD_EXP 6
6902: PPUSH
6903: CALL_OW 119
// wait ( 5 ) ;
6907: LD_INT 5
6909: PPUSH
6910: CALL_OW 67
// InGameOff ;
6914: CALL_OW 9
// DialogueOn ;
6918: CALL_OW 6
// interface_hidden := true ;
6922: LD_ADDR_OWVAR 54
6926: PUSH
6927: LD_INT 1
6929: ST_TO_ADDR
// case who_survive of 1 :
6930: LD_EXP 7
6934: PUSH
6935: LD_INT 1
6937: DOUBLE
6938: EQUAL
6939: IFTRUE 6943
6941: GO 7001
6943: POP
// begin Say ( Joan , D3J-Joan-1 ) ;
6944: LD_EXP 3
6948: PPUSH
6949: LD_STRING D3J-Joan-1
6951: PPUSH
6952: CALL_OW 88
// Say ( MacMillan , D3J-JMM-1 ) ;
6956: LD_EXP 1
6960: PPUSH
6961: LD_STRING D3J-JMM-1
6963: PPUSH
6964: CALL_OW 88
// Say ( Joan , D3J-Joan-2 ) ;
6968: LD_EXP 3
6972: PPUSH
6973: LD_STRING D3J-Joan-2
6975: PPUSH
6976: CALL_OW 88
// Say ( MacMillan , D3J-JMM-2 ) ;
6980: LD_EXP 1
6984: PPUSH
6985: LD_STRING D3J-JMM-2
6987: PPUSH
6988: CALL_OW 88
// ChangeMissionObjectives ( M2J ) ;
6992: LD_STRING M2J
6994: PPUSH
6995: CALL_OW 337
// end ; 2 :
6999: GO 7098
7001: LD_INT 2
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7067
7009: POP
// begin Say ( Lisa , D3L-Lisa-1 ) ;
7010: LD_EXP 4
7014: PPUSH
7015: LD_STRING D3L-Lisa-1
7017: PPUSH
7018: CALL_OW 88
// Say ( MacMillan , D3L-JMM-1 ) ;
7022: LD_EXP 1
7026: PPUSH
7027: LD_STRING D3L-JMM-1
7029: PPUSH
7030: CALL_OW 88
// Say ( Lisa , D3L-Lisa-2 ) ;
7034: LD_EXP 4
7038: PPUSH
7039: LD_STRING D3L-Lisa-2
7041: PPUSH
7042: CALL_OW 88
// Say ( MacMillan , D3L-JMM-2 ) ;
7046: LD_EXP 1
7050: PPUSH
7051: LD_STRING D3L-JMM-2
7053: PPUSH
7054: CALL_OW 88
// ChangeMissionObjectives ( M2L ) ;
7058: LD_STRING M2L
7060: PPUSH
7061: CALL_OW 337
// end ; 3 :
7065: GO 7098
7067: LD_INT 3
7069: DOUBLE
7070: EQUAL
7071: IFTRUE 7075
7073: GO 7097
7075: POP
// begin Say ( anezka , D3X-Con-1 ) ;
7076: LD_EXP 5
7080: PPUSH
7081: LD_STRING D3X-Con-1
7083: PPUSH
7084: CALL_OW 88
// ChangeMissionObjectives ( M2X ) ;
7088: LD_STRING M2X
7090: PPUSH
7091: CALL_OW 337
// end ; end ;
7095: GO 7098
7097: POP
// Say ( MacMillan , D4-JMM-1 ) ;
7098: LD_EXP 1
7102: PPUSH
7103: LD_STRING D4-JMM-1
7105: PPUSH
7106: CALL_OW 88
// case who_survive of 1 :
7110: LD_EXP 7
7114: PUSH
7115: LD_INT 1
7117: DOUBLE
7118: EQUAL
7119: IFTRUE 7123
7121: GO 7138
7123: POP
// Say ( Joan , D4-Joan-1 ) ; 2 :
7124: LD_EXP 3
7128: PPUSH
7129: LD_STRING D4-Joan-1
7131: PPUSH
7132: CALL_OW 88
7136: GO 7185
7138: LD_INT 2
7140: DOUBLE
7141: EQUAL
7142: IFTRUE 7146
7144: GO 7161
7146: POP
// Say ( Lisa , D4-Lisa-1 ) ; 3 :
7147: LD_EXP 4
7151: PPUSH
7152: LD_STRING D4-Lisa-1
7154: PPUSH
7155: CALL_OW 88
7159: GO 7185
7161: LD_INT 3
7163: DOUBLE
7164: EQUAL
7165: IFTRUE 7169
7167: GO 7184
7169: POP
// Say ( Anezka , D4-Con-1 ) ; end ;
7170: LD_EXP 5
7174: PPUSH
7175: LD_STRING D4-Con-1
7177: PPUSH
7178: CALL_OW 88
7182: GO 7185
7184: POP
// Say ( MacMillan , D4-JMM-2 ) ;
7185: LD_EXP 1
7189: PPUSH
7190: LD_STRING D4-JMM-2
7192: PPUSH
7193: CALL_OW 88
// case who_survive of 1 :
7197: LD_EXP 7
7201: PUSH
7202: LD_INT 1
7204: DOUBLE
7205: EQUAL
7206: IFTRUE 7210
7208: GO 7225
7210: POP
// Say ( Joan , D4-Joan-2 ) ; 2 :
7211: LD_EXP 3
7215: PPUSH
7216: LD_STRING D4-Joan-2
7218: PPUSH
7219: CALL_OW 88
7223: GO 7272
7225: LD_INT 2
7227: DOUBLE
7228: EQUAL
7229: IFTRUE 7233
7231: GO 7248
7233: POP
// Say ( Lisa , D4-Lisa-2 ) ; 3 :
7234: LD_EXP 4
7238: PPUSH
7239: LD_STRING D4-Lisa-2
7241: PPUSH
7242: CALL_OW 88
7246: GO 7272
7248: LD_INT 3
7250: DOUBLE
7251: EQUAL
7252: IFTRUE 7256
7254: GO 7271
7256: POP
// Say ( Anezka , D4-Con-2 ) ; end ;
7257: LD_EXP 5
7261: PPUSH
7262: LD_STRING D4-Con-2
7264: PPUSH
7265: CALL_OW 88
7269: GO 7272
7271: POP
// DialogueOff ;
7272: CALL_OW 7
// interface_hidden := false ;
7276: LD_ADDR_OWVAR 54
7280: PUSH
7281: LD_INT 0
7283: ST_TO_ADDR
// enable ( 11 ) ;
7284: LD_INT 11
7286: ENABLE_MARKED
// end ;
7287: PPOPN 2
7289: END
// every 0 0$1 trigger IsSelected ( us_trucks ) marked 11 do
7290: LD_EXP 35
7294: PPUSH
7295: CALL_OW 306
7299: IFFALSE 7474
7301: GO 7303
7303: DISABLE
// begin if FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_control_tower ] ] ) then
7304: LD_INT 22
7306: PUSH
7307: LD_EXP 14
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 30
7318: PUSH
7319: LD_INT 36
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PPUSH
7330: CALL_OW 69
7334: IFFALSE 7338
// exit ;
7336: GO 7474
// while dialogue_running do
7338: LD_LOC 3
7342: IFFALSE 7353
// wait ( 0 0$1 ) ;
7344: LD_INT 35
7346: PPUSH
7347: CALL_OW 67
7351: GO 7338
// dialogue_running := true ;
7353: LD_ADDR_LOC 3
7357: PUSH
7358: LD_INT 1
7360: ST_TO_ADDR
// DisableExclamations ;
7361: CALL_OW 474
// Say ( MacMillan , D5-JMM-1 ) ;
7365: LD_EXP 1
7369: PPUSH
7370: LD_STRING D5-JMM-1
7372: PPUSH
7373: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7377: LD_INT 77
7379: PPUSH
7380: LD_INT 87
7382: PPUSH
7383: CALL_OW 84
// case who_survive of 1 :
7387: LD_EXP 7
7391: PUSH
7392: LD_INT 1
7394: DOUBLE
7395: EQUAL
7396: IFTRUE 7400
7398: GO 7415
7400: POP
// Say ( Joan , D5-Joan-1 ) ; 2 :
7401: LD_EXP 3
7405: PPUSH
7406: LD_STRING D5-Joan-1
7408: PPUSH
7409: CALL_OW 88
7413: GO 7462
7415: LD_INT 2
7417: DOUBLE
7418: EQUAL
7419: IFTRUE 7423
7421: GO 7438
7423: POP
// Say ( Lisa , D5-Lisa-1 ) ; 3 :
7424: LD_EXP 4
7428: PPUSH
7429: LD_STRING D5-Lisa-1
7431: PPUSH
7432: CALL_OW 88
7436: GO 7462
7438: LD_INT 3
7440: DOUBLE
7441: EQUAL
7442: IFTRUE 7446
7444: GO 7461
7446: POP
// Say ( Anezka , D5-Con-1 ) ; end ;
7447: LD_EXP 5
7451: PPUSH
7452: LD_STRING D5-Con-1
7454: PPUSH
7455: CALL_OW 88
7459: GO 7462
7461: POP
// EnableExclamations ;
7462: CALL_OW 473
// dialogue_running := false ;
7466: LD_ADDR_LOC 3
7470: PUSH
7471: LD_INT 0
7473: ST_TO_ADDR
// end ;
7474: END
// every 0 0$1 trigger IsSelected ( us_lab1 ) marked 11 do
7475: LD_INT 32
7477: PPUSH
7478: CALL_OW 306
7482: IFFALSE 7840
7484: GO 7486
7486: DISABLE
// begin while dialogue_running do
7487: LD_LOC 3
7491: IFFALSE 7502
// wait ( 0 0$1 ) ;
7493: LD_INT 35
7495: PPUSH
7496: CALL_OW 67
7500: GO 7487
// dialogue_running := true ;
7502: LD_ADDR_LOC 3
7506: PUSH
7507: LD_INT 1
7509: ST_TO_ADDR
// DisableExclamations ;
7510: CALL_OW 474
// selected_opto_lab := true ;
7514: LD_ADDR_EXP 19
7518: PUSH
7519: LD_INT 1
7521: ST_TO_ADDR
// case who_survive of 1 :
7522: LD_EXP 7
7526: PUSH
7527: LD_INT 1
7529: DOUBLE
7530: EQUAL
7531: IFTRUE 7535
7533: GO 7642
7535: POP
// begin Say ( MacMillan , D6J-JMM-1 ) ;
7536: LD_EXP 1
7540: PPUSH
7541: LD_STRING D6J-JMM-1
7543: PPUSH
7544: CALL_OW 88
// if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
7548: LD_STRING Denis
7550: PPUSH
7551: CALL_OW 28
7555: PUSH
7556: LD_STRING Denis
7558: PPUSH
7559: CALL_OW 29
7563: AND
7564: IFFALSE 7604
// begin Say ( Joan , D6J-Joan-1 ) ;
7566: LD_EXP 3
7570: PPUSH
7571: LD_STRING D6J-Joan-1
7573: PPUSH
7574: CALL_OW 88
// Say ( MacMillan , D6J-JMM-2 ) ;
7578: LD_EXP 1
7582: PPUSH
7583: LD_STRING D6J-JMM-2
7585: PPUSH
7586: CALL_OW 88
// Say ( Joan , D6J-Joan-2 ) ;
7590: LD_EXP 3
7594: PPUSH
7595: LD_STRING D6J-Joan-2
7597: PPUSH
7598: CALL_OW 88
// end else
7602: GO 7616
// Say ( Joan , D6J-Joan-2a ) ;
7604: LD_EXP 3
7608: PPUSH
7609: LD_STRING D6J-Joan-2a
7611: PPUSH
7612: CALL_OW 88
// Say ( MacMillan , D6J-JMM-3 ) ;
7616: LD_EXP 1
7620: PPUSH
7621: LD_STRING D6J-JMM-3
7623: PPUSH
7624: CALL_OW 88
// Say ( Joan , D6J-Joan-3 ) ;
7628: LD_EXP 3
7632: PPUSH
7633: LD_STRING D6J-Joan-3
7635: PPUSH
7636: CALL_OW 88
// end ; 2 :
7640: GO 7821
7642: LD_INT 2
7644: DOUBLE
7645: EQUAL
7646: IFTRUE 7650
7648: GO 7701
7650: POP
// begin Say ( MacMillan , D6L-JMM-1 ) ;
7651: LD_EXP 1
7655: PPUSH
7656: LD_STRING D6L-JMM-1
7658: PPUSH
7659: CALL_OW 88
// Say ( Lisa , D6L-Lisa-1 ) ;
7663: LD_EXP 4
7667: PPUSH
7668: LD_STRING D6L-Lisa-1
7670: PPUSH
7671: CALL_OW 88
// Say ( MacMillan , D6L-JMM-2 ) ;
7675: LD_EXP 1
7679: PPUSH
7680: LD_STRING D6L-JMM-2
7682: PPUSH
7683: CALL_OW 88
// Say ( Lisa , D6L-Lisa-2 ) ;
7687: LD_EXP 4
7691: PPUSH
7692: LD_STRING D6L-Lisa-2
7694: PPUSH
7695: CALL_OW 88
// end ; 3 :
7699: GO 7821
7701: LD_INT 3
7703: DOUBLE
7704: EQUAL
7705: IFTRUE 7709
7707: GO 7820
7709: POP
// begin Say ( MacMillan , D6X-JMM-1 ) ;
7710: LD_EXP 1
7714: PPUSH
7715: LD_STRING D6X-JMM-1
7717: PPUSH
7718: CALL_OW 88
// Say ( Anezka , D6X-Con-1 ) ;
7722: LD_EXP 5
7726: PPUSH
7727: LD_STRING D6X-Con-1
7729: PPUSH
7730: CALL_OW 88
// Say ( MacMillan , D6X-JMM-2 ) ;
7734: LD_EXP 1
7738: PPUSH
7739: LD_STRING D6X-JMM-2
7741: PPUSH
7742: CALL_OW 88
// Say ( Anezka , D6X-Con-2 ) ;
7746: LD_EXP 5
7750: PPUSH
7751: LD_STRING D6X-Con-2
7753: PPUSH
7754: CALL_OW 88
// Say ( MacMillan , D6X-JMM-3 ) ;
7758: LD_EXP 1
7762: PPUSH
7763: LD_STRING D6X-JMM-3
7765: PPUSH
7766: CALL_OW 88
// Say ( Anezka , D6X-Con-3 ) ;
7770: LD_EXP 5
7774: PPUSH
7775: LD_STRING D6X-Con-3
7777: PPUSH
7778: CALL_OW 88
// Say ( MacMillan , D6X-JMM-4 ) ;
7782: LD_EXP 1
7786: PPUSH
7787: LD_STRING D6X-JMM-4
7789: PPUSH
7790: CALL_OW 88
// Say ( Anezka , D6X-Con-4 ) ;
7794: LD_EXP 5
7798: PPUSH
7799: LD_STRING D6X-Con-4
7801: PPUSH
7802: CALL_OW 88
// Say ( MacMillan , D6X-JMM-5 ) ;
7806: LD_EXP 1
7810: PPUSH
7811: LD_STRING D6X-JMM-5
7813: PPUSH
7814: CALL_OW 88
// end ; end ;
7818: GO 7821
7820: POP
// ChangeMissionObjectives ( M3 ) ;
7821: LD_STRING M3
7823: PPUSH
7824: CALL_OW 337
// EnableExclamations ;
7828: CALL_OW 473
// dialogue_running := false ;
7832: LD_ADDR_LOC 3
7836: PUSH
7837: LD_INT 0
7839: ST_TO_ADDR
// end ;
7840: END
// every 10 10$0 do
7841: GO 7843
7843: DISABLE
// begin DialogueOn ;
7844: CALL_OW 6
// interface_hidden := true ;
7848: LD_ADDR_OWVAR 54
7852: PUSH
7853: LD_INT 1
7855: ST_TO_ADDR
// Say ( Powell , D7-Pow-1 ) ;
7856: LD_EXP 2
7860: PPUSH
7861: LD_STRING D7-Pow-1
7863: PPUSH
7864: CALL_OW 88
// Say ( MacMillan , D7-JMM-1 ) ;
7868: LD_EXP 1
7872: PPUSH
7873: LD_STRING D7-JMM-1
7875: PPUSH
7876: CALL_OW 88
// Say ( Powell , D7-Pow-2 ) ;
7880: LD_EXP 2
7884: PPUSH
7885: LD_STRING D7-Pow-2
7887: PPUSH
7888: CALL_OW 88
// if IsLive ( survivor ) then
7892: LD_EXP 6
7896: PPUSH
7897: CALL_OW 300
7901: IFFALSE 7917
// Say ( MacMillan , D7-JMM-2 ) else
7903: LD_EXP 1
7907: PPUSH
7908: LD_STRING D7-JMM-2
7910: PPUSH
7911: CALL_OW 88
7915: GO 7929
// Say ( MacMillan , D7-JMM-2a ) ;
7917: LD_EXP 1
7921: PPUSH
7922: LD_STRING D7-JMM-2a
7924: PPUSH
7925: CALL_OW 88
// Say ( Powell , D7-Pow-3 ) ;
7929: LD_EXP 2
7933: PPUSH
7934: LD_STRING D7-Pow-3
7936: PPUSH
7937: CALL_OW 88
// Say ( MacMillan , D7-JMM-3 ) ;
7941: LD_EXP 1
7945: PPUSH
7946: LD_STRING D7-JMM-3
7948: PPUSH
7949: CALL_OW 88
// Say ( Powell , D7-Pow-4 ) ;
7953: LD_EXP 2
7957: PPUSH
7958: LD_STRING D7-Pow-4
7960: PPUSH
7961: CALL_OW 88
// DialogueOff ;
7965: CALL_OW 7
// interface_hidden := false ;
7969: LD_ADDR_OWVAR 54
7973: PUSH
7974: LD_INT 0
7976: ST_TO_ADDR
// end ;
7977: END
// every 0 0$20 do
7978: GO 7980
7980: DISABLE
// begin ukradle_auto := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] , [ f_chassis , us_morphling ] ] ) ;
7981: LD_ADDR_EXP 9
7985: PUSH
7986: LD_INT 22
7988: PUSH
7989: LD_EXP 15
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 21
8000: PUSH
8001: LD_INT 2
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 31
8010: PUSH
8011: LD_INT 5
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: LIST
8022: PPUSH
8023: CALL_OW 69
8027: ST_TO_ADDR
// mm_vehicle := ukradle_auto ;
8028: LD_ADDR_EXP 63
8032: PUSH
8033: LD_EXP 9
8037: ST_TO_ADDR
// manual_forces := manual_forces ^ mm_vehicle ;
8038: LD_ADDR_EXP 59
8042: PUSH
8043: LD_EXP 59
8047: PUSH
8048: LD_EXP 63
8052: ADD
8053: ST_TO_ADDR
// if ukradle_auto then
8054: LD_EXP 9
8058: IFFALSE 8063
// enable ( 5 ) ;
8060: LD_INT 5
8062: ENABLE_MARKED
// end ;
8063: END
// function vzdalenost_macmillana_od_auta ; var v_x , v_y ; begin
8064: LD_INT 0
8066: PPUSH
8067: PPUSH
8068: PPUSH
// v_x := GetX ( ukradle_auto ) - GetX ( MacMillan ) ;
8069: LD_ADDR_VAR 0 2
8073: PUSH
8074: LD_EXP 9
8078: PPUSH
8079: CALL_OW 250
8083: PUSH
8084: LD_EXP 1
8088: PPUSH
8089: CALL_OW 250
8093: MINUS
8094: ST_TO_ADDR
// v_x := GetY ( ukradle_auto ) - GetY ( MacMillan ) ;
8095: LD_ADDR_VAR 0 2
8099: PUSH
8100: LD_EXP 9
8104: PPUSH
8105: CALL_OW 251
8109: PUSH
8110: LD_EXP 1
8114: PPUSH
8115: CALL_OW 251
8119: MINUS
8120: ST_TO_ADDR
// if ( ( v_x > - 6 ) and ( v_x < 6 ) ) and ( ( v_y > - 6 ) and ( v_y < 6 ) ) then
8121: LD_VAR 0 2
8125: PUSH
8126: LD_INT 6
8128: NEG
8129: GREATER
8130: PUSH
8131: LD_VAR 0 2
8135: PUSH
8136: LD_INT 6
8138: LESS
8139: AND
8140: PUSH
8141: LD_VAR 0 3
8145: PUSH
8146: LD_INT 6
8148: NEG
8149: GREATER
8150: PUSH
8151: LD_VAR 0 3
8155: PUSH
8156: LD_INT 6
8158: LESS
8159: AND
8160: AND
8161: IFFALSE 8173
// result := true else
8163: LD_ADDR_VAR 0 1
8167: PUSH
8168: LD_INT 1
8170: ST_TO_ADDR
8171: GO 8181
// result := false ;
8173: LD_ADDR_VAR 0 1
8177: PUSH
8178: LD_INT 0
8180: ST_TO_ADDR
// end ;
8181: LD_VAR 0 1
8185: RET
// every 0 0$1 trigger vzdalenost_macmillana_od_auta marked 5 do
8186: CALL 8064 0 0
8190: IFFALSE 8207
8192: GO 8194
8194: DISABLE
// begin Say ( MacMillan , D8-JMM-1 ) ;
8195: LD_EXP 1
8199: PPUSH
8200: LD_STRING D8-JMM-1
8202: PPUSH
8203: CALL_OW 88
// end ; end_of_file
8207: END
// export us_trucks ; export number_us_trucks ; export heavy_trucks , medium_trucks , light_trucks ; export function prepare_us_base ; var un , i ; begin
8208: LD_INT 0
8210: PPUSH
8211: PPUSH
8212: PPUSH
// number_us_trucks := 4 ;
8213: LD_ADDR_EXP 36
8217: PUSH
8218: LD_INT 4
8220: ST_TO_ADDR
// light_trucks := Rand ( 1 , ( number_us_trucks div 2 ) ) ;
8221: LD_ADDR_EXP 39
8225: PUSH
8226: LD_INT 1
8228: PPUSH
8229: LD_EXP 36
8233: PUSH
8234: LD_INT 2
8236: DIV
8237: PPUSH
8238: CALL_OW 12
8242: ST_TO_ADDR
// heavy_trucks := Rand ( 0 , ( number_us_trucks div 2 ) ) ;
8243: LD_ADDR_EXP 37
8247: PUSH
8248: LD_INT 0
8250: PPUSH
8251: LD_EXP 36
8255: PUSH
8256: LD_INT 2
8258: DIV
8259: PPUSH
8260: CALL_OW 12
8264: ST_TO_ADDR
// medium_trucks := number_us_trucks - ( light_trucks + heavy_trucks ) ;
8265: LD_ADDR_EXP 38
8269: PUSH
8270: LD_EXP 36
8274: PUSH
8275: LD_EXP 39
8279: PUSH
8280: LD_EXP 37
8284: PLUS
8285: MINUS
8286: ST_TO_ADDR
// us_trucks := [ ] ;
8287: LD_ADDR_EXP 35
8291: PUSH
8292: EMPTY
8293: ST_TO_ADDR
// uc_nation = nation_american ;
8294: LD_ADDR_OWVAR 21
8298: PUSH
8299: LD_INT 1
8301: ST_TO_ADDR
// uc_side = neutral ;
8302: LD_ADDR_OWVAR 20
8306: PUSH
8307: LD_EXP 16
8311: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
8312: LD_ADDR_OWVAR 24
8316: PUSH
8317: LD_INT 0
8319: PPUSH
8320: LD_INT 5
8322: PPUSH
8323: CALL_OW 12
8327: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
8328: LD_ADDR_OWVAR 37
8332: PUSH
8333: LD_INT 2
8335: ST_TO_ADDR
// vc_control := control_remote ;
8336: LD_ADDR_OWVAR 38
8340: PUSH
8341: LD_INT 2
8343: ST_TO_ADDR
// vc_engine := engine_solar ;
8344: LD_ADDR_OWVAR 39
8348: PUSH
8349: LD_INT 2
8351: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
8352: LD_ADDR_OWVAR 40
8356: PUSH
8357: LD_INT 12
8359: ST_TO_ADDR
// un := CreateVehicle ;
8360: LD_ADDR_VAR 0 2
8364: PUSH
8365: CALL_OW 45
8369: ST_TO_ADDR
// PlaceUnitXY ( un , 84 , 119 , false ) ;
8370: LD_VAR 0 2
8374: PPUSH
8375: LD_INT 84
8377: PPUSH
8378: LD_INT 119
8380: PPUSH
8381: LD_INT 0
8383: PPUSH
8384: CALL_OW 48
// us_trucks := us_trucks ^ un ;
8388: LD_ADDR_EXP 35
8392: PUSH
8393: LD_EXP 35
8397: PUSH
8398: LD_VAR 0 2
8402: ADD
8403: ST_TO_ADDR
// for i := 1 to light_trucks do
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: DOUBLE
8410: LD_INT 1
8412: DEC
8413: ST_TO_ADDR
8414: LD_EXP 39
8418: PUSH
8419: FOR_TO
8420: IFFALSE 8513
// begin uc_direction := Rand ( 0 , 5 ) ;
8422: LD_ADDR_OWVAR 24
8426: PUSH
8427: LD_INT 0
8429: PPUSH
8430: LD_INT 5
8432: PPUSH
8433: CALL_OW 12
8437: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
8438: LD_ADDR_OWVAR 37
8442: PUSH
8443: LD_INT 1
8445: ST_TO_ADDR
// vc_control := control_remote ;
8446: LD_ADDR_OWVAR 38
8450: PUSH
8451: LD_INT 2
8453: ST_TO_ADDR
// vc_engine := engine_solar ;
8454: LD_ADDR_OWVAR 39
8458: PUSH
8459: LD_INT 2
8461: ST_TO_ADDR
// vc_weapon := us_light_gun ;
8462: LD_ADDR_OWVAR 40
8466: PUSH
8467: LD_INT 3
8469: ST_TO_ADDR
// un := CreateVehicle ;
8470: LD_ADDR_VAR 0 2
8474: PUSH
8475: CALL_OW 45
8479: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8480: LD_VAR 0 2
8484: PPUSH
8485: LD_INT 9
8487: PPUSH
8488: LD_INT 0
8490: PPUSH
8491: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8495: LD_ADDR_EXP 35
8499: PUSH
8500: LD_EXP 35
8504: PUSH
8505: LD_VAR 0 2
8509: ADD
8510: ST_TO_ADDR
// end ;
8511: GO 8419
8513: POP
8514: POP
// for i := 1 to medium_trucks do
8515: LD_ADDR_VAR 0 3
8519: PUSH
8520: DOUBLE
8521: LD_INT 1
8523: DEC
8524: ST_TO_ADDR
8525: LD_EXP 38
8529: PUSH
8530: FOR_TO
8531: IFFALSE 8656
// begin uc_direction := Rand ( 0 , 5 ) ;
8533: LD_ADDR_OWVAR 24
8537: PUSH
8538: LD_INT 0
8540: PPUSH
8541: LD_INT 5
8543: PPUSH
8544: CALL_OW 12
8548: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8549: LD_VAR 0 3
8553: PUSH
8554: LD_INT 2
8556: MOD
8557: PUSH
8558: LD_INT 1
8560: EQUAL
8561: IFFALSE 8581
// begin vc_chassis := us_medium_wheeled ;
8563: LD_ADDR_OWVAR 37
8567: PUSH
8568: LD_INT 2
8570: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
8571: LD_ADDR_OWVAR 40
8575: PUSH
8576: LD_INT 4
8578: ST_TO_ADDR
// end else
8579: GO 8597
// begin vc_chassis := us_medium_tracked ;
8581: LD_ADDR_OWVAR 37
8585: PUSH
8586: LD_INT 3
8588: ST_TO_ADDR
// vc_weapon := us_double_gun ;
8589: LD_ADDR_OWVAR 40
8593: PUSH
8594: LD_INT 5
8596: ST_TO_ADDR
// end ; vc_control := control_remote ;
8597: LD_ADDR_OWVAR 38
8601: PUSH
8602: LD_INT 2
8604: ST_TO_ADDR
// vc_engine := engine_combustion ;
8605: LD_ADDR_OWVAR 39
8609: PUSH
8610: LD_INT 1
8612: ST_TO_ADDR
// un := CreateVehicle ;
8613: LD_ADDR_VAR 0 2
8617: PUSH
8618: CALL_OW 45
8622: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8623: LD_VAR 0 2
8627: PPUSH
8628: LD_INT 9
8630: PPUSH
8631: LD_INT 0
8633: PPUSH
8634: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8638: LD_ADDR_EXP 35
8642: PUSH
8643: LD_EXP 35
8647: PUSH
8648: LD_VAR 0 2
8652: ADD
8653: ST_TO_ADDR
// end ;
8654: GO 8530
8656: POP
8657: POP
// for i := 1 to heavy_trucks do
8658: LD_ADDR_VAR 0 3
8662: PUSH
8663: DOUBLE
8664: LD_INT 1
8666: DEC
8667: ST_TO_ADDR
8668: LD_EXP 37
8672: PUSH
8673: FOR_TO
8674: IFFALSE 8791
// begin uc_direction := Rand ( 0 , 5 ) ;
8676: LD_ADDR_OWVAR 24
8680: PUSH
8681: LD_INT 0
8683: PPUSH
8684: LD_INT 5
8686: PPUSH
8687: CALL_OW 12
8691: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8692: LD_ADDR_OWVAR 37
8696: PUSH
8697: LD_INT 4
8699: ST_TO_ADDR
// vc_control := control_remote ;
8700: LD_ADDR_OWVAR 38
8704: PUSH
8705: LD_INT 2
8707: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8708: LD_VAR 0 3
8712: PUSH
8713: LD_INT 2
8715: MOD
8716: PUSH
8717: LD_INT 1
8719: EQUAL
8720: IFFALSE 8732
// vc_engine := engine_siberite else
8722: LD_ADDR_OWVAR 39
8726: PUSH
8727: LD_INT 3
8729: ST_TO_ADDR
8730: GO 8740
// vc_engine := engine_combustion ;
8732: LD_ADDR_OWVAR 39
8736: PUSH
8737: LD_INT 1
8739: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
8740: LD_ADDR_OWVAR 40
8744: PUSH
8745: LD_INT 6
8747: ST_TO_ADDR
// un := CreateVehicle ;
8748: LD_ADDR_VAR 0 2
8752: PUSH
8753: CALL_OW 45
8757: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8758: LD_VAR 0 2
8762: PPUSH
8763: LD_INT 9
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8773: LD_ADDR_EXP 35
8777: PUSH
8778: LD_EXP 35
8782: PUSH
8783: LD_VAR 0 2
8787: ADD
8788: ST_TO_ADDR
// end ;
8789: GO 8673
8791: POP
8792: POP
// end ; end_of_file
8793: LD_VAR 0 1
8797: RET
// export ru_lab1_queue , ru_lab2_queue ; export ru_lab1_upgrade , ru_lab2_upgrade ; export research_1 , research_2 ; var research_done , laboratory ; var finished_1 , finished_2 ; var soucet1 , soucet2 ; export function ru_scientistic_priority ; begin
8798: LD_INT 0
8800: PPUSH
// ru_lab1_queue := [ tech_AdvRocket ] ;
8801: LD_ADDR_EXP 40
8805: PUSH
8806: LD_INT 71
8808: PUSH
8809: EMPTY
8810: LIST
8811: ST_TO_ADDR
// ru_lab2_queue := [ tech_TauRad , tech_SpacAnom , tech_LimTeleport , tech_MatPred , tech_TargTeleport ] ;
8812: LD_ADDR_EXP 41
8816: PUSH
8817: LD_INT 28
8819: PUSH
8820: LD_INT 29
8822: PUSH
8823: LD_INT 37
8825: PUSH
8826: LD_INT 9
8828: PUSH
8829: LD_INT 38
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: ST_TO_ADDR
// ru_lab1_upgrade := [ tech_Tech1 , tech_Weap1 , tech_Sib1 , tech_Tech2 , tech_Weap2 , tech_Sib2 , tech_Tech3 , tech_Weap3 , tech_Sib3 ] ;
8839: LD_ADDR_EXP 42
8843: PUSH
8844: LD_INT 48
8846: PUSH
8847: LD_INT 51
8849: PUSH
8850: LD_INT 54
8852: PUSH
8853: LD_INT 49
8855: PUSH
8856: LD_INT 52
8858: PUSH
8859: LD_INT 55
8861: PUSH
8862: LD_INT 50
8864: PUSH
8865: LD_INT 53
8867: PUSH
8868: LD_INT 56
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: ST_TO_ADDR
// ru_lab2_upgrade := [ tech_Comp1 , tech_ST1 , tech_Comp2 , tech_ST2 , tech_Comp3 , tech_ST3 ] ;
8882: LD_ADDR_EXP 43
8886: PUSH
8887: LD_INT 57
8889: PUSH
8890: LD_INT 63
8892: PUSH
8893: LD_INT 58
8895: PUSH
8896: LD_INT 64
8898: PUSH
8899: LD_INT 59
8901: PUSH
8902: LD_INT 65
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: ST_TO_ADDR
// research_1 := false ;
8913: LD_ADDR_EXP 44
8917: PUSH
8918: LD_INT 0
8920: ST_TO_ADDR
// research_2 := false ;
8921: LD_ADDR_EXP 45
8925: PUSH
8926: LD_INT 0
8928: ST_TO_ADDR
// finished_1 := false ;
8929: LD_ADDR_LOC 6
8933: PUSH
8934: LD_INT 0
8936: ST_TO_ADDR
// finished_2 := false ;
8937: LD_ADDR_LOC 7
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// end ;
8945: LD_VAR 0 1
8949: RET
// function change_technology_lab1 ; var i , j , pom ; begin
8950: LD_INT 0
8952: PPUSH
8953: PPUSH
8954: PPUSH
8955: PPUSH
// j := 1 ;
8956: LD_ADDR_VAR 0 3
8960: PUSH
8961: LD_INT 1
8963: ST_TO_ADDR
// pom := [ ] ;
8964: LD_ADDR_VAR 0 4
8968: PUSH
8969: EMPTY
8970: ST_TO_ADDR
// for i in ru_lab1_queue do
8971: LD_ADDR_VAR 0 2
8975: PUSH
8976: LD_EXP 40
8980: PUSH
8981: FOR_IN
8982: IFFALSE 9026
// begin if j > 1 then
8984: LD_VAR 0 3
8988: PUSH
8989: LD_INT 1
8991: GREATER
8992: IFFALSE 9010
// pom := pom ^ i ;
8994: LD_ADDR_VAR 0 4
8998: PUSH
8999: LD_VAR 0 4
9003: PUSH
9004: LD_VAR 0 2
9008: ADD
9009: ST_TO_ADDR
// j := j + 1 ;
9010: LD_ADDR_VAR 0 3
9014: PUSH
9015: LD_VAR 0 3
9019: PUSH
9020: LD_INT 1
9022: PLUS
9023: ST_TO_ADDR
// end ;
9024: GO 8981
9026: POP
9027: POP
// ru_lab1_queue := pom ;
9028: LD_ADDR_EXP 40
9032: PUSH
9033: LD_VAR 0 4
9037: ST_TO_ADDR
// if not ru_lab1_queue then
9038: LD_EXP 40
9042: NOT
9043: IFFALSE 9062
// begin ru_lab1_queue := ru_lab1_upgrade ;
9045: LD_ADDR_EXP 40
9049: PUSH
9050: LD_EXP 42
9054: ST_TO_ADDR
// ru_lab1_upgrade := [ ] ;
9055: LD_ADDR_EXP 42
9059: PUSH
9060: EMPTY
9061: ST_TO_ADDR
// end ; end ;
9062: LD_VAR 0 1
9066: RET
// function change_technology_lab2 ; var i , j , pom ; begin
9067: LD_INT 0
9069: PPUSH
9070: PPUSH
9071: PPUSH
9072: PPUSH
// j := 1 ;
9073: LD_ADDR_VAR 0 3
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// pom := [ ] ;
9081: LD_ADDR_VAR 0 4
9085: PUSH
9086: EMPTY
9087: ST_TO_ADDR
// for i in ru_lab2_queue do
9088: LD_ADDR_VAR 0 2
9092: PUSH
9093: LD_EXP 41
9097: PUSH
9098: FOR_IN
9099: IFFALSE 9143
// begin if j > 1 then
9101: LD_VAR 0 3
9105: PUSH
9106: LD_INT 1
9108: GREATER
9109: IFFALSE 9127
// pom := pom ^ i ;
9111: LD_ADDR_VAR 0 4
9115: PUSH
9116: LD_VAR 0 4
9120: PUSH
9121: LD_VAR 0 2
9125: ADD
9126: ST_TO_ADDR
// j := j + 1 ;
9127: LD_ADDR_VAR 0 3
9131: PUSH
9132: LD_VAR 0 3
9136: PUSH
9137: LD_INT 1
9139: PLUS
9140: ST_TO_ADDR
// end ;
9141: GO 9098
9143: POP
9144: POP
// ru_lab2_queue := pom ;
9145: LD_ADDR_EXP 41
9149: PUSH
9150: LD_VAR 0 4
9154: ST_TO_ADDR
// if not ru_lab2_queue then
9155: LD_EXP 41
9159: NOT
9160: IFFALSE 9179
// begin ru_lab2_queue := ru_lab2_upgrade ;
9162: LD_ADDR_EXP 41
9166: PUSH
9167: LD_EXP 43
9171: ST_TO_ADDR
// ru_lab2_upgrade := [ ] ;
9172: LD_ADDR_EXP 43
9176: PUSH
9177: EMPTY
9178: ST_TO_ADDR
// end ; end ;
9179: LD_VAR 0 1
9183: RET
// on ResearchComplete ( research_done , laboratory ) do begin case laboratory of ru_lab1 :
9184: LD_VAR 0 2
9188: PUSH
9189: LD_INT 14
9191: DOUBLE
9192: EQUAL
9193: IFTRUE 9197
9195: GO 9208
9197: POP
// research_1 := false ; ru_lab2 :
9198: LD_ADDR_EXP 44
9202: PUSH
9203: LD_INT 0
9205: ST_TO_ADDR
9206: GO 9228
9208: LD_INT 15
9210: DOUBLE
9211: EQUAL
9212: IFTRUE 9216
9214: GO 9227
9216: POP
// research_2 := false ; end ;
9217: LD_ADDR_EXP 45
9221: PUSH
9222: LD_INT 0
9224: ST_TO_ADDR
9225: GO 9228
9227: POP
// end ;
9228: PPOPN 2
9230: END
// function vyrovnej_vedecke_sily ; var un , un1 , un2 , i , move_to , how_much ; begin
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
9239: PPUSH
// un1 := 0 + UnitsInside ( ru_lab1 ) ;
9240: LD_ADDR_VAR 0 3
9244: PUSH
9245: LD_INT 0
9247: PUSH
9248: LD_INT 14
9250: PPUSH
9251: CALL_OW 313
9255: PLUS
9256: ST_TO_ADDR
// un2 := 0 + UnitsInside ( ru_lab2 ) ;
9257: LD_ADDR_VAR 0 4
9261: PUSH
9262: LD_INT 0
9264: PUSH
9265: LD_INT 15
9267: PPUSH
9268: CALL_OW 313
9272: PLUS
9273: ST_TO_ADDR
// if un1 >= un2 then
9274: LD_VAR 0 3
9278: PUSH
9279: LD_VAR 0 4
9283: GREATEREQUAL
9284: IFFALSE 9327
// begin move_to := ru_lab2 ;
9286: LD_ADDR_VAR 0 6
9290: PUSH
9291: LD_INT 15
9293: ST_TO_ADDR
// how_much := ( un1 - un2 ) div 2 ;
9294: LD_ADDR_VAR 0 7
9298: PUSH
9299: LD_VAR 0 3
9303: PUSH
9304: LD_VAR 0 4
9308: MINUS
9309: PUSH
9310: LD_INT 2
9312: DIV
9313: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9314: LD_ADDR_VAR 0 2
9318: PUSH
9319: LD_INT 14
9321: PPUSH
9322: CALL_OW 313
9326: ST_TO_ADDR
// end ; if un1 < un2 then
9327: LD_VAR 0 3
9331: PUSH
9332: LD_VAR 0 4
9336: LESS
9337: IFFALSE 9380
// begin move_to := ru_lab1 ;
9339: LD_ADDR_VAR 0 6
9343: PUSH
9344: LD_INT 14
9346: ST_TO_ADDR
// how_much := ( un2 - un1 ) div 2 ;
9347: LD_ADDR_VAR 0 7
9351: PUSH
9352: LD_VAR 0 4
9356: PUSH
9357: LD_VAR 0 3
9361: MINUS
9362: PUSH
9363: LD_INT 2
9365: DIV
9366: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 15
9374: PPUSH
9375: CALL_OW 313
9379: ST_TO_ADDR
// end ; for i := 1 to how_much do
9380: LD_ADDR_VAR 0 5
9384: PUSH
9385: DOUBLE
9386: LD_INT 1
9388: DEC
9389: ST_TO_ADDR
9390: LD_VAR 0 7
9394: PUSH
9395: FOR_TO
9396: IFFALSE 9435
// begin ComExitBuilding ( un [ i ] ) ;
9398: LD_VAR 0 2
9402: PUSH
9403: LD_VAR 0 5
9407: ARRAY
9408: PPUSH
9409: CALL_OW 122
// AddComEnterUnit ( un [ i ] , move_to ) ;
9413: LD_VAR 0 2
9417: PUSH
9418: LD_VAR 0 5
9422: ARRAY
9423: PPUSH
9424: LD_VAR 0 6
9428: PPUSH
9429: CALL_OW 180
// end ;
9433: GO 9395
9435: POP
9436: POP
// end ;
9437: LD_VAR 0 1
9441: RET
// every 0 0$15 trigger UnitsInside ( ru_lab1 ) and not research_1 do var un , i , j ;
9442: LD_INT 14
9444: PPUSH
9445: CALL_OW 313
9449: PUSH
9450: LD_EXP 44
9454: NOT
9455: AND
9456: IFFALSE 9777
9458: GO 9460
9460: DISABLE
9461: LD_INT 0
9463: PPUSH
9464: PPUSH
9465: PPUSH
// begin un := UnitsInside ( ru_lab1 ) ;
9466: LD_ADDR_VAR 0 1
9470: PUSH
9471: LD_INT 14
9473: PPUSH
9474: CALL_OW 313
9478: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_INT 4
9486: PPUSH
9487: CALL_OW 336
// if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9491: LD_EXP 40
9495: PUSH
9496: LD_EXP 42
9500: AND
9501: IFFALSE 9527
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9503: LD_INT 14
9505: PPUSH
9506: LD_EXP 40
9510: PUSH
9511: LD_INT 1
9513: ARRAY
9514: PPUSH
9515: CALL_OW 124
// research_1 := true ;
9519: LD_ADDR_EXP 44
9523: PUSH
9524: LD_INT 1
9526: ST_TO_ADDR
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9527: LD_EXP 40
9531: PUSH
9532: LD_EXP 42
9536: NOT
9537: AND
9538: IFFALSE 9671
// begin if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9540: LD_EXP 41
9544: PUSH
9545: LD_EXP 43
9549: AND
9550: IFFALSE 9586
// begin un := UnitsInside ( ru_lab1 ) ;
9552: LD_ADDR_VAR 0 1
9556: PUSH
9557: LD_INT 14
9559: PPUSH
9560: CALL_OW 313
9564: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9565: LD_VAR 0 1
9569: PPUSH
9570: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9574: LD_VAR 0 1
9578: PPUSH
9579: LD_INT 15
9581: PPUSH
9582: CALL_OW 180
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9586: LD_EXP 41
9590: PUSH
9591: LD_EXP 43
9595: NOT
9596: AND
9597: IFFALSE 9634
// begin vyrovnej_vedecke_sily ;
9599: CALL 9231 0 0
// wait ( 0 0$5 ) ;
9603: LD_INT 175
9605: PPUSH
9606: CALL_OW 67
// ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9610: LD_INT 14
9612: PPUSH
9613: LD_EXP 40
9617: PUSH
9618: LD_INT 1
9620: ARRAY
9621: PPUSH
9622: CALL_OW 124
// research_1 := true ;
9626: LD_ADDR_EXP 44
9630: PUSH
9631: LD_INT 1
9633: ST_TO_ADDR
// end ; if not ( ru_lab2_queue or ru_lab2_upgrade ) then
9634: LD_EXP 41
9638: PUSH
9639: LD_EXP 43
9643: OR
9644: NOT
9645: IFFALSE 9671
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9647: LD_INT 14
9649: PPUSH
9650: LD_EXP 40
9654: PUSH
9655: LD_INT 1
9657: ARRAY
9658: PPUSH
9659: CALL_OW 124
// research_1 := true ;
9663: LD_ADDR_EXP 44
9667: PUSH
9668: LD_INT 1
9670: ST_TO_ADDR
// end ; end ; if research_1 then
9671: LD_EXP 44
9675: IFFALSE 9681
// change_technology_lab1 ;
9677: CALL 8950 0 0
// soucet1 := 0 + ru_lab1_queue + ru_lab1_upgrade ;
9681: LD_ADDR_LOC 8
9685: PUSH
9686: LD_INT 0
9688: PUSH
9689: LD_EXP 40
9693: PLUS
9694: PUSH
9695: LD_EXP 42
9699: PLUS
9700: ST_TO_ADDR
// if ( soucet1 = 0 ) and ( not research_1 ) then
9701: LD_LOC 8
9705: PUSH
9706: LD_INT 0
9708: EQUAL
9709: PUSH
9710: LD_EXP 44
9714: NOT
9715: AND
9716: IFFALSE 9760
// begin finished_1 := true ;
9718: LD_ADDR_LOC 6
9722: PUSH
9723: LD_INT 1
9725: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9726: LD_ADDR_VAR 0 1
9730: PUSH
9731: LD_INT 14
9733: PPUSH
9734: CALL_OW 313
9738: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_INT 15
9755: PPUSH
9756: CALL_OW 180
// end ; if ( soucet1 > 0 ) or research_1 then
9760: LD_LOC 8
9764: PUSH
9765: LD_INT 0
9767: GREATER
9768: PUSH
9769: LD_EXP 44
9773: OR
9774: IFFALSE 9777
// enable ;
9776: ENABLE
// end ;
9777: PPOPN 3
9779: END
// every 0 0$15 trigger UnitsInside ( ru_lab2 ) and not research_2 do var un , i , j ;
9780: LD_INT 15
9782: PPUSH
9783: CALL_OW 313
9787: PUSH
9788: LD_EXP 45
9792: NOT
9793: AND
9794: IFFALSE 10115
9796: GO 9798
9798: DISABLE
9799: LD_INT 0
9801: PPUSH
9802: PPUSH
9803: PPUSH
// begin un := UnitsInside ( ru_lab2 ) ;
9804: LD_ADDR_VAR 0 1
9808: PUSH
9809: LD_INT 15
9811: PPUSH
9812: CALL_OW 313
9816: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9817: LD_VAR 0 1
9821: PPUSH
9822: LD_INT 4
9824: PPUSH
9825: CALL_OW 336
// if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9829: LD_EXP 41
9833: PUSH
9834: LD_EXP 43
9838: AND
9839: IFFALSE 9865
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9841: LD_INT 15
9843: PPUSH
9844: LD_EXP 41
9848: PUSH
9849: LD_INT 1
9851: ARRAY
9852: PPUSH
9853: CALL_OW 124
// research_2 := true ;
9857: LD_ADDR_EXP 45
9861: PUSH
9862: LD_INT 1
9864: ST_TO_ADDR
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9865: LD_EXP 41
9869: PUSH
9870: LD_EXP 43
9874: NOT
9875: AND
9876: IFFALSE 10009
// begin if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9878: LD_EXP 40
9882: PUSH
9883: LD_EXP 42
9887: AND
9888: IFFALSE 9924
// begin un := UnitsInside ( ru_lab2 ) ;
9890: LD_ADDR_VAR 0 1
9894: PUSH
9895: LD_INT 15
9897: PPUSH
9898: CALL_OW 313
9902: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9903: LD_VAR 0 1
9907: PPUSH
9908: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
9912: LD_VAR 0 1
9916: PPUSH
9917: LD_INT 14
9919: PPUSH
9920: CALL_OW 180
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9924: LD_EXP 40
9928: PUSH
9929: LD_EXP 42
9933: NOT
9934: AND
9935: IFFALSE 9972
// begin vyrovnej_vedecke_sily ;
9937: CALL 9231 0 0
// wait ( 0 0$5 ) ;
9941: LD_INT 175
9943: PPUSH
9944: CALL_OW 67
// ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9948: LD_INT 15
9950: PPUSH
9951: LD_EXP 41
9955: PUSH
9956: LD_INT 1
9958: ARRAY
9959: PPUSH
9960: CALL_OW 124
// research_2 := true ;
9964: LD_ADDR_EXP 45
9968: PUSH
9969: LD_INT 1
9971: ST_TO_ADDR
// end ; if not ( ru_lab1_queue or ru_lab1_upgrade ) then
9972: LD_EXP 40
9976: PUSH
9977: LD_EXP 42
9981: OR
9982: NOT
9983: IFFALSE 10009
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9985: LD_INT 15
9987: PPUSH
9988: LD_EXP 41
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PPUSH
9997: CALL_OW 124
// research_2 := true ;
10001: LD_ADDR_EXP 45
10005: PUSH
10006: LD_INT 1
10008: ST_TO_ADDR
// end ; end ; if research_2 then
10009: LD_EXP 45
10013: IFFALSE 10019
// change_technology_lab2 ;
10015: CALL 9067 0 0
// soucet2 := 0 + ru_lab2_queue + ru_lab2_upgrade ;
10019: LD_ADDR_LOC 9
10023: PUSH
10024: LD_INT 0
10026: PUSH
10027: LD_EXP 41
10031: PLUS
10032: PUSH
10033: LD_EXP 43
10037: PLUS
10038: ST_TO_ADDR
// if ( soucet2 = 0 ) and ( not research_2 ) then
10039: LD_LOC 9
10043: PUSH
10044: LD_INT 0
10046: EQUAL
10047: PUSH
10048: LD_EXP 45
10052: NOT
10053: AND
10054: IFFALSE 10098
// begin finished_2 := true ;
10056: LD_ADDR_LOC 7
10060: PUSH
10061: LD_INT 1
10063: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
10064: LD_ADDR_VAR 0 1
10068: PUSH
10069: LD_INT 15
10071: PPUSH
10072: CALL_OW 313
10076: ST_TO_ADDR
// ComExitBuilding ( un ) ;
10077: LD_VAR 0 1
10081: PPUSH
10082: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
10086: LD_VAR 0 1
10090: PPUSH
10091: LD_INT 14
10093: PPUSH
10094: CALL_OW 180
// end ; if ( soucet2 > 0 ) or research_2 then
10098: LD_LOC 9
10102: PUSH
10103: LD_INT 0
10105: GREATER
10106: PUSH
10107: LD_EXP 45
10111: OR
10112: IFFALSE 10115
// enable ;
10114: ENABLE
// end ;
10115: PPOPN 3
10117: END
// every 0 0$10 trigger finished_1 and finished_2 do var un , sci , i , build ;
10118: LD_LOC 6
10122: PUSH
10123: LD_LOC 7
10127: AND
10128: IFFALSE 10395
10130: GO 10132
10132: DISABLE
10133: LD_INT 0
10135: PPUSH
10136: PPUSH
10137: PPUSH
10138: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
10139: LD_ADDR_VAR 0 2
10143: PUSH
10144: LD_INT 22
10146: PUSH
10147: LD_EXP 15
10151: PUSH
10152: EMPTY
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 25
10158: PUSH
10159: LD_INT 4
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PPUSH
10170: CALL_OW 69
10174: ST_TO_ADDR
// ComExitBuilding ( sci ) ;
10175: LD_VAR 0 2
10179: PPUSH
10180: CALL_OW 122
// build := FilterAllUnits ( [ [ f_side , russians ] , [ f_btype , b_factory ] ] ) ;
10184: LD_ADDR_VAR 0 4
10188: PUSH
10189: LD_INT 22
10191: PUSH
10192: LD_EXP 15
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: LD_INT 30
10203: PUSH
10204: LD_INT 3
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PPUSH
10215: CALL_OW 69
10219: ST_TO_ADDR
// if build then
10220: LD_VAR 0 4
10224: IFFALSE 10297
// begin i := 1 ;
10226: LD_ADDR_VAR 0 3
10230: PUSH
10231: LD_INT 1
10233: ST_TO_ADDR
// for un in sci do
10234: LD_ADDR_VAR 0 1
10238: PUSH
10239: LD_VAR 0 2
10243: PUSH
10244: FOR_IN
10245: IFFALSE 10293
// begin ComEnterUnit ( un , build [ ( i mod build ) + 1 ] ) ;
10247: LD_VAR 0 1
10251: PPUSH
10252: LD_VAR 0 4
10256: PUSH
10257: LD_VAR 0 3
10261: PUSH
10262: LD_VAR 0 4
10266: MOD
10267: PUSH
10268: LD_INT 1
10270: PLUS
10271: ARRAY
10272: PPUSH
10273: CALL_OW 120
// i := i + 1 ;
10277: LD_ADDR_VAR 0 3
10281: PUSH
10282: LD_VAR 0 3
10286: PUSH
10287: LD_INT 1
10289: PLUS
10290: ST_TO_ADDR
// end ;
10291: GO 10244
10293: POP
10294: POP
// end else
10295: GO 10395
// begin build := FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
10297: LD_ADDR_VAR 0 4
10301: PUSH
10302: LD_INT 22
10304: PUSH
10305: LD_EXP 15
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: LD_INT 30
10319: PUSH
10320: LD_INT 5
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 30
10329: PUSH
10330: LD_INT 4
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PPUSH
10346: CALL_OW 69
10350: ST_TO_ADDR
// if build then
10351: LD_VAR 0 4
10355: IFFALSE 10395
// begin ComEnterUnit ( sci , build ) ;
10357: LD_VAR 0 2
10361: PPUSH
10362: LD_VAR 0 4
10366: PPUSH
10367: CALL_OW 120
// AddComChangeProfession ( sci , class_soldier ) ;
10371: LD_VAR 0 2
10375: PPUSH
10376: LD_INT 1
10378: PPUSH
10379: CALL_OW 183
// AddComChangeProfession ( sci , class_bazooker ) ;
10383: LD_VAR 0 2
10387: PPUSH
10388: LD_INT 9
10390: PPUSH
10391: CALL_OW 183
// end ; end ; end ; end_of_file
10395: PPOPN 4
10397: END
// export base_crates , base_oil , base_siberit ; export busy_fact1 , busy_fact2 ; export vyber_pro_tovarnu ; var hotove_vozidlo , volna_tovarna ; var cekat_dodavku ; var time_fact1 , time_fact2 ; var no_siberit ; var factory1_idle , factory2_idle ; export function startup_manufacturing ; begin
10398: LD_INT 0
10400: PPUSH
// busy_fact1 := false ;
10401: LD_ADDR_EXP 49
10405: PUSH
10406: LD_INT 0
10408: ST_TO_ADDR
// busy_fact2 := false ;
10409: LD_ADDR_EXP 50
10413: PUSH
10414: LD_INT 0
10416: ST_TO_ADDR
// time_fact1 := Rand ( 0 0$2 , 0 0$10 ) ;
10417: LD_ADDR_LOC 13
10421: PUSH
10422: LD_INT 70
10424: PPUSH
10425: LD_INT 350
10427: PPUSH
10428: CALL_OW 12
10432: ST_TO_ADDR
// time_fact2 := Rand ( 0 0$2 , 0 0$10 ) ;
10433: LD_ADDR_LOC 14
10437: PUSH
10438: LD_INT 70
10440: PPUSH
10441: LD_INT 350
10443: PPUSH
10444: CALL_OW 12
10448: ST_TO_ADDR
// end ;
10449: LD_VAR 0 1
10453: RET
// function zjisti_zdroje ; var base ; begin
10454: LD_INT 0
10456: PPUSH
10457: PPUSH
// base := GetBase ( ru_depot ) ;
10458: LD_ADDR_VAR 0 2
10462: PUSH
10463: LD_INT 22
10465: PPUSH
10466: CALL_OW 274
10470: ST_TO_ADDR
// base_crates := GetResourceType ( base , mat_cans ) ;
10471: LD_ADDR_EXP 46
10475: PUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_INT 1
10483: PPUSH
10484: CALL_OW 275
10488: ST_TO_ADDR
// base_oil := GetResourceType ( base , mat_oil ) ;
10489: LD_ADDR_EXP 47
10493: PUSH
10494: LD_VAR 0 2
10498: PPUSH
10499: LD_INT 2
10501: PPUSH
10502: CALL_OW 275
10506: ST_TO_ADDR
// base_siberit := GetResourceType ( base , mat_siberit ) ;
10507: LD_ADDR_EXP 48
10511: PUSH
10512: LD_VAR 0 2
10516: PPUSH
10517: LD_INT 3
10519: PPUSH
10520: CALL_OW 275
10524: ST_TO_ADDR
// end ;
10525: LD_VAR 0 1
10529: RET
// every 0 0$2 trigger UnitsInside ( ru_fact1 ) and UnitsInside ( ru_fact2 ) marked 1 do var un ;
10530: LD_INT 1
10532: PPUSH
10533: CALL_OW 313
10537: PUSH
10538: LD_INT 40
10540: PPUSH
10541: CALL_OW 313
10545: AND
10546: IFFALSE 10578
10548: GO 10550
10550: DISABLE
10551: LD_INT 0
10553: PPUSH
// begin ComRemember ( UnitsInside ( ru_fact1 ) ) ;
10554: LD_INT 1
10556: PPUSH
10557: CALL_OW 313
10561: PPUSH
10562: CALL_OW 143
// ComRemember ( UnitsInside ( ru_fact2 ) ) ;
10566: LD_INT 40
10568: PPUSH
10569: CALL_OW 313
10573: PPUSH
10574: CALL_OW 143
// end ;
10578: PPOPN 1
10580: END
// function vyber_komponenty ; var specialni ; begin
10581: LD_INT 0
10583: PPUSH
10584: PPUSH
// cekat_dodavku := true ;
10585: LD_ADDR_LOC 12
10589: PUSH
10590: LD_INT 1
10592: ST_TO_ADDR
// specialni := false ;
10593: LD_ADDR_VAR 0 2
10597: PUSH
10598: LD_INT 0
10600: ST_TO_ADDR
// no_siberit := false ;
10601: LD_ADDR_LOC 15
10605: PUSH
10606: LD_INT 0
10608: ST_TO_ADDR
// zjisti_pozadavky ;
10609: CALL 12002 0 0
// if 1 = 2 then
10613: LD_INT 1
10615: PUSH
10616: LD_INT 2
10618: EQUAL
10619: IFFALSE 10876
// begin case chybi of 1 :
10621: LD_EXP 62
10625: PUSH
10626: LD_INT 1
10628: DOUBLE
10629: EQUAL
10630: IFTRUE 10634
10632: GO 10709
10634: POP
// begin if ( base_crates >= 55 ) then
10635: LD_EXP 46
10639: PUSH
10640: LD_INT 55
10642: GREATEREQUAL
10643: IFFALSE 10655
// vc_chassis := ru_heavy_tracked else
10645: LD_ADDR_OWVAR 37
10649: PUSH
10650: LD_INT 24
10652: ST_TO_ADDR
10653: GO 10663
// vc_chassis := ru_heavy_wheeled ;
10655: LD_ADDR_OWVAR 37
10659: PUSH
10660: LD_INT 23
10662: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10663: LD_ADDR_OWVAR 40
10667: PUSH
10668: LD_INT 49
10670: ST_TO_ADDR
// vc_control := control_computer ;
10671: LD_ADDR_OWVAR 38
10675: PUSH
10676: LD_INT 3
10678: ST_TO_ADDR
// if ( base_siberit >= 60 ) then
10679: LD_EXP 48
10683: PUSH
10684: LD_INT 60
10686: GREATEREQUAL
10687: IFFALSE 10699
// vc_engine := engine_siberite else
10689: LD_ADDR_OWVAR 39
10693: PUSH
10694: LD_INT 3
10696: ST_TO_ADDR
10697: GO 10707
// vc_engine := engine_combustion ;
10699: LD_ADDR_OWVAR 39
10703: PUSH
10704: LD_INT 1
10706: ST_TO_ADDR
// end ; 2 :
10707: GO 10866
10709: LD_INT 2
10711: DOUBLE
10712: EQUAL
10713: IFTRUE 10717
10715: GO 10752
10717: POP
// begin vc_chassis := ru_heavy_tracked ;
10718: LD_ADDR_OWVAR 37
10722: PUSH
10723: LD_INT 24
10725: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10726: LD_ADDR_OWVAR 40
10730: PUSH
10731: LD_INT 49
10733: ST_TO_ADDR
// vc_control := control_manual ;
10734: LD_ADDR_OWVAR 38
10738: PUSH
10739: LD_INT 1
10741: ST_TO_ADDR
// vc_engine := engine_siberite ;
10742: LD_ADDR_OWVAR 39
10746: PUSH
10747: LD_INT 3
10749: ST_TO_ADDR
// end ; 3 :
10750: GO 10866
10752: LD_INT 3
10754: DOUBLE
10755: EQUAL
10756: IFTRUE 10760
10758: GO 10865
10760: POP
// begin vc_chassis := ru_heavy_tracked ;
10761: LD_ADDR_OWVAR 37
10765: PUSH
10766: LD_INT 24
10768: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10769: LD_ADDR_OWVAR 40
10773: PUSH
10774: LD_INT 46
10776: ST_TO_ADDR
// if base_crates < 70 then
10777: LD_EXP 46
10781: PUSH
10782: LD_INT 70
10784: LESS
10785: IFFALSE 10795
// vc_chassis := ru_heavy_wheeled ;
10787: LD_ADDR_OWVAR 37
10791: PUSH
10792: LD_INT 23
10794: ST_TO_ADDR
// if base_crates < 60 then
10795: LD_EXP 46
10799: PUSH
10800: LD_INT 60
10802: LESS
10803: IFFALSE 10821
// begin vc_weapon := ru_rocket ;
10805: LD_ADDR_OWVAR 40
10809: PUSH
10810: LD_INT 47
10812: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10813: LD_ADDR_OWVAR 37
10817: PUSH
10818: LD_INT 24
10820: ST_TO_ADDR
// end ; if base_crates < 55 then
10821: LD_EXP 46
10825: PUSH
10826: LD_INT 55
10828: LESS
10829: IFFALSE 10839
// vc_chassis := ru_heavy_wheeled ;
10831: LD_ADDR_OWVAR 37
10835: PUSH
10836: LD_INT 23
10838: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10839: LD_ADDR_OWVAR 40
10843: PUSH
10844: LD_INT 49
10846: ST_TO_ADDR
// vc_control := control_manual ;
10847: LD_ADDR_OWVAR 38
10851: PUSH
10852: LD_INT 1
10854: ST_TO_ADDR
// vc_engine := engine_siberite ;
10855: LD_ADDR_OWVAR 39
10859: PUSH
10860: LD_INT 3
10862: ST_TO_ADDR
// end ; end ;
10863: GO 10866
10865: POP
// specialni := true ;
10866: LD_ADDR_VAR 0 2
10870: PUSH
10871: LD_INT 1
10873: ST_TO_ADDR
// end else
10874: GO 10876
// begin end ; if ( base_crates < 65 ) and ( not specialni ) then
10876: LD_EXP 46
10880: PUSH
10881: LD_INT 65
10883: LESS
10884: PUSH
10885: LD_VAR 0 2
10889: NOT
10890: AND
10891: IFFALSE 10979
// begin cekat_dodavku := false ;
10893: LD_ADDR_LOC 12
10897: PUSH
10898: LD_INT 0
10900: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10901: LD_ADDR_OWVAR 40
10905: PUSH
10906: LD_INT 45
10908: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10909: LD_ADDR_OWVAR 37
10913: PUSH
10914: LD_INT 22
10916: ST_TO_ADDR
// if base_crates < 60 then
10917: LD_EXP 46
10921: PUSH
10922: LD_INT 60
10924: LESS
10925: IFFALSE 10935
// vc_chassis := ru_medium_wheeled ;
10927: LD_ADDR_OWVAR 37
10931: PUSH
10932: LD_INT 21
10934: ST_TO_ADDR
// if base_crates < 55 then
10935: LD_EXP 46
10939: PUSH
10940: LD_INT 55
10942: LESS
10943: IFFALSE 10961
// begin vc_chassis := ru_medium_tracked ;
10945: LD_ADDR_OWVAR 37
10949: PUSH
10950: LD_INT 22
10952: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
10953: LD_ADDR_OWVAR 40
10957: PUSH
10958: LD_INT 43
10960: ST_TO_ADDR
// end ; if base_crates < 50 then
10961: LD_EXP 46
10965: PUSH
10966: LD_INT 50
10968: LESS
10969: IFFALSE 10979
// vc_chassis := ru_medium_wheeled ;
10971: LD_ADDR_OWVAR 37
10975: PUSH
10976: LD_INT 21
10978: ST_TO_ADDR
// end ; if ( base_crates >= 65 ) and ( vyber_pro_tovarnu = 1 ) and ( not specialni ) then
10979: LD_EXP 46
10983: PUSH
10984: LD_INT 65
10986: GREATEREQUAL
10987: PUSH
10988: LD_EXP 51
10992: PUSH
10993: LD_INT 1
10995: EQUAL
10996: AND
10997: PUSH
10998: LD_VAR 0 2
11002: NOT
11003: AND
11004: IFFALSE 11092
// begin cekat_dodavku := false ;
11006: LD_ADDR_LOC 12
11010: PUSH
11011: LD_INT 0
11013: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
11014: LD_ADDR_OWVAR 40
11018: PUSH
11019: LD_INT 46
11021: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11022: LD_ADDR_OWVAR 37
11026: PUSH
11027: LD_INT 24
11029: ST_TO_ADDR
// if base_crates < 80 then
11030: LD_EXP 46
11034: PUSH
11035: LD_INT 80
11037: LESS
11038: IFFALSE 11048
// vc_chassis := ru_heavy_wheeled ;
11040: LD_ADDR_OWVAR 37
11044: PUSH
11045: LD_INT 23
11047: ST_TO_ADDR
// if base_crates < 70 then
11048: LD_EXP 46
11052: PUSH
11053: LD_INT 70
11055: LESS
11056: IFFALSE 11074
// begin vc_weapon := ru_rocket ;
11058: LD_ADDR_OWVAR 40
11062: PUSH
11063: LD_INT 47
11065: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11066: LD_ADDR_OWVAR 37
11070: PUSH
11071: LD_INT 24
11073: ST_TO_ADDR
// end ; if base_crates < 65 then
11074: LD_EXP 46
11078: PUSH
11079: LD_INT 65
11081: LESS
11082: IFFALSE 11092
// vc_chassis := ru_heavy_wheeled ;
11084: LD_ADDR_OWVAR 37
11088: PUSH
11089: LD_INT 23
11091: ST_TO_ADDR
// end ; if ( base_crates >= 70 ) and ( vyber_pro_tovarnu = 2 ) and ( not specialni ) then
11092: LD_EXP 46
11096: PUSH
11097: LD_INT 70
11099: GREATEREQUAL
11100: PUSH
11101: LD_EXP 51
11105: PUSH
11106: LD_INT 2
11108: EQUAL
11109: AND
11110: PUSH
11111: LD_VAR 0 2
11115: NOT
11116: AND
11117: IFFALSE 11161
// begin cekat_dodavku := false ;
11119: LD_ADDR_LOC 12
11123: PUSH
11124: LD_INT 0
11126: ST_TO_ADDR
// vc_weapon := ru_rocket ;
11127: LD_ADDR_OWVAR 40
11131: PUSH
11132: LD_INT 47
11134: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11135: LD_ADDR_OWVAR 37
11139: PUSH
11140: LD_INT 24
11142: ST_TO_ADDR
// if base_crates < 75 then
11143: LD_EXP 46
11147: PUSH
11148: LD_INT 75
11150: LESS
11151: IFFALSE 11161
// vc_chassis := ru_heavy_wheeled ;
11153: LD_ADDR_OWVAR 37
11157: PUSH
11158: LD_INT 23
11160: ST_TO_ADDR
// end ; if not specialni then
11161: LD_VAR 0 2
11165: NOT
11166: IFFALSE 11247
// begin vc_control := control_computer ;
11168: LD_ADDR_OWVAR 38
11172: PUSH
11173: LD_INT 3
11175: ST_TO_ADDR
// if ( vc_chassis > 22 ) and ( base_siberit >= 10 ) and ( not no_siberit ) then
11176: LD_OWVAR 37
11180: PUSH
11181: LD_INT 22
11183: GREATER
11184: PUSH
11185: LD_EXP 48
11189: PUSH
11190: LD_INT 10
11192: GREATEREQUAL
11193: AND
11194: PUSH
11195: LD_LOC 15
11199: NOT
11200: AND
11201: IFFALSE 11221
// begin vc_engine := engine_siberite ;
11203: LD_ADDR_OWVAR 39
11207: PUSH
11208: LD_INT 3
11210: ST_TO_ADDR
// cekat_dodavku := false ;
11211: LD_ADDR_LOC 12
11215: PUSH
11216: LD_INT 0
11218: ST_TO_ADDR
// end else
11219: GO 11247
// if base_oil >= 30 then
11221: LD_EXP 47
11225: PUSH
11226: LD_INT 30
11228: GREATEREQUAL
11229: IFFALSE 11247
// begin vc_engine := engine_combustion ;
11231: LD_ADDR_OWVAR 39
11235: PUSH
11236: LD_INT 1
11238: ST_TO_ADDR
// cekat_dodavku := false ;
11239: LD_ADDR_LOC 12
11243: PUSH
11244: LD_INT 0
11246: ST_TO_ADDR
// end ; end ; end ;
11247: LD_VAR 0 1
11251: RET
// on VehicleConstructed ( hotove_vozidlo , volna_tovarna ) do begin if GetSide ( hotove_vozidlo ) = russians then
11252: LD_VAR 0 1
11256: PPUSH
11257: CALL_OW 255
11261: PUSH
11262: LD_EXP 15
11266: EQUAL
11267: IFFALSE 11366
// begin if GetControl ( hotove_vozidlo ) = control_manual then
11269: LD_VAR 0 1
11273: PPUSH
11274: CALL_OW 263
11278: PUSH
11279: LD_INT 1
11281: EQUAL
11282: IFFALSE 11300
// zaparkuj_vozidlo ( volna_tovarna , hotove_vozidlo ) else
11284: LD_VAR 0 2
11288: PPUSH
11289: LD_VAR 0 1
11293: PPUSH
11294: CALL 12155 0 2
11298: GO 11316
// war_forces := war_forces ^ hotove_vozidlo ;
11300: LD_ADDR_EXP 52
11304: PUSH
11305: LD_EXP 52
11309: PUSH
11310: LD_VAR 0 1
11314: ADD
11315: ST_TO_ADDR
// collect_war_forces ;
11316: CALL 12303 0 0
// case volna_tovarna of ru_fact1 :
11320: LD_VAR 0 2
11324: PUSH
11325: LD_INT 1
11327: DOUBLE
11328: EQUAL
11329: IFTRUE 11333
11331: GO 11344
11333: POP
// busy_fact1 := false ; ru_fact2 :
11334: LD_ADDR_EXP 49
11338: PUSH
11339: LD_INT 0
11341: ST_TO_ADDR
11342: GO 11364
11344: LD_INT 40
11346: DOUBLE
11347: EQUAL
11348: IFTRUE 11352
11350: GO 11363
11352: POP
// busy_fact2 := false ; end ;
11353: LD_ADDR_EXP 50
11357: PUSH
11358: LD_INT 0
11360: ST_TO_ADDR
11361: GO 11364
11363: POP
// end else
11364: GO 11434
// if GetWeapon ( hotove_vozidlo ) = us_double_laser then
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 264
11375: PUSH
11376: LD_INT 10
11378: EQUAL
11379: IFFALSE 11434
// begin double_laser := double_laser + 1 ;
11381: LD_ADDR_EXP 17
11385: PUSH
11386: LD_EXP 17
11390: PUSH
11391: LD_INT 1
11393: PLUS
11394: ST_TO_ADDR
// if not double_hint then
11395: LD_EXP 18
11399: NOT
11400: IFFALSE 11417
// begin Hint ( DoubleLaser ) ;
11402: LD_STRING DoubleLaser
11404: PPUSH
11405: CALL_OW 339
// double_hint := true ;
11409: LD_ADDR_EXP 18
11413: PUSH
11414: LD_INT 1
11416: ST_TO_ADDR
// end ; if double_laser = 2 then
11417: LD_EXP 17
11421: PUSH
11422: LD_INT 2
11424: EQUAL
11425: IFFALSE 11434
// ChangeMissionObjectives ( M3a ) ;
11427: LD_STRING M3a
11429: PPUSH
11430: CALL_OW 337
// end ; end ;
11434: PPOPN 2
11436: END
// every 0 0$10 trigger UnitsInside ( ru_fact1 ) and ( not busy_fact1 ) and ( TICK >= time_fact1 ) do var un ;
11437: LD_INT 1
11439: PPUSH
11440: CALL_OW 313
11444: PUSH
11445: LD_EXP 49
11449: NOT
11450: AND
11451: PUSH
11452: LD_OWVAR 1
11456: PUSH
11457: LD_LOC 13
11461: GREATEREQUAL
11462: AND
11463: IFFALSE 11571
11465: GO 11467
11467: DISABLE
11468: LD_INT 0
11470: PPUSH
// begin zjisti_zdroje ;
11471: CALL 10454 0 0
// if base_crates >= 40 then
11475: LD_EXP 46
11479: PUSH
11480: LD_INT 40
11482: GREATEREQUAL
11483: IFFALSE 11548
// begin vyber_pro_tovarnu := 1 ;
11485: LD_ADDR_EXP 51
11489: PUSH
11490: LD_INT 1
11492: ST_TO_ADDR
// vyber_komponenty ;
11493: CALL 10581 0 0
// if not cekat_dodavku then
11497: LD_LOC 12
11501: NOT
11502: IFFALSE 11548
// begin ComConstruct ( ru_fact1 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11504: LD_INT 1
11506: PPUSH
11507: LD_OWVAR 37
11511: PPUSH
11512: LD_OWVAR 39
11516: PPUSH
11517: LD_OWVAR 38
11521: PPUSH
11522: LD_OWVAR 40
11526: PPUSH
11527: CALL_OW 125
// if IsBusy ( ru_fact1 ) then
11531: LD_INT 1
11533: PPUSH
11534: CALL_OW 315
11538: IFFALSE 11548
// busy_fact1 := true ;
11540: LD_ADDR_EXP 49
11544: PUSH
11545: LD_INT 1
11547: ST_TO_ADDR
// end ; end ; time_fact1 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11548: LD_ADDR_LOC 13
11552: PUSH
11553: LD_OWVAR 1
11557: PUSH
11558: LD_INT 1400
11560: PPUSH
11561: LD_INT 2100
11563: PPUSH
11564: CALL_OW 12
11568: PLUS
11569: ST_TO_ADDR
// enable ;
11570: ENABLE
// end ;
11571: PPOPN 1
11573: END
// every 0 0$10 trigger UnitsInside ( ru_fact2 ) and ( not busy_fact2 ) and ( TICK >= time_fact2 ) do var un ;
11574: LD_INT 40
11576: PPUSH
11577: CALL_OW 313
11581: PUSH
11582: LD_EXP 50
11586: NOT
11587: AND
11588: PUSH
11589: LD_OWVAR 1
11593: PUSH
11594: LD_LOC 14
11598: GREATEREQUAL
11599: AND
11600: IFFALSE 11708
11602: GO 11604
11604: DISABLE
11605: LD_INT 0
11607: PPUSH
// begin zjisti_zdroje ;
11608: CALL 10454 0 0
// if base_crates >= 40 then
11612: LD_EXP 46
11616: PUSH
11617: LD_INT 40
11619: GREATEREQUAL
11620: IFFALSE 11685
// begin vyber_pro_tovarnu := 2 ;
11622: LD_ADDR_EXP 51
11626: PUSH
11627: LD_INT 2
11629: ST_TO_ADDR
// vyber_komponenty ;
11630: CALL 10581 0 0
// if not cekat_dodavku then
11634: LD_LOC 12
11638: NOT
11639: IFFALSE 11685
// begin ComConstruct ( ru_fact2 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11641: LD_INT 40
11643: PPUSH
11644: LD_OWVAR 37
11648: PPUSH
11649: LD_OWVAR 39
11653: PPUSH
11654: LD_OWVAR 38
11658: PPUSH
11659: LD_OWVAR 40
11663: PPUSH
11664: CALL_OW 125
// if IsBusy ( ru_fact2 ) then
11668: LD_INT 40
11670: PPUSH
11671: CALL_OW 315
11675: IFFALSE 11685
// busy_fact2 := true ;
11677: LD_ADDR_EXP 50
11681: PUSH
11682: LD_INT 1
11684: ST_TO_ADDR
// end ; end ; time_fact2 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11685: LD_ADDR_LOC 14
11689: PUSH
11690: LD_OWVAR 1
11694: PUSH
11695: LD_INT 1400
11697: PPUSH
11698: LD_INT 2100
11700: PPUSH
11701: CALL_OW 12
11705: PLUS
11706: ST_TO_ADDR
// enable ;
11707: ENABLE
// end ;
11708: PPOPN 1
11710: END
// every 0 0$10 trigger ( busy_fact1 ) and ( base_crates > 40 ) do
11711: LD_EXP 49
11715: PUSH
11716: LD_EXP 46
11720: PUSH
11721: LD_INT 40
11723: GREATER
11724: AND
11725: IFFALSE 11770
11727: GO 11729
11729: DISABLE
// begin factory1_idle := factory1_idle + 1 ;
11730: LD_ADDR_LOC 16
11734: PUSH
11735: LD_LOC 16
11739: PUSH
11740: LD_INT 1
11742: PLUS
11743: ST_TO_ADDR
// if factory1_idle > 10 then
11744: LD_LOC 16
11748: PUSH
11749: LD_INT 10
11751: GREATER
11752: IFFALSE 11770
// begin factory1_idle := 0 ;
11754: LD_ADDR_LOC 16
11758: PUSH
11759: LD_INT 0
11761: ST_TO_ADDR
// busy_fact1 := false ;
11762: LD_ADDR_EXP 49
11766: PUSH
11767: LD_INT 0
11769: ST_TO_ADDR
// end ; end ;
11770: END
// every 0 0$10 trigger ( busy_fact2 ) and ( base_crates > 40 ) do
11771: LD_EXP 50
11775: PUSH
11776: LD_EXP 46
11780: PUSH
11781: LD_INT 40
11783: GREATER
11784: AND
11785: IFFALSE 11830
11787: GO 11789
11789: DISABLE
// begin factory2_idle := factory2_idle + 1 ;
11790: LD_ADDR_LOC 17
11794: PUSH
11795: LD_LOC 17
11799: PUSH
11800: LD_INT 1
11802: PLUS
11803: ST_TO_ADDR
// if factory2_idle > 10 then
11804: LD_LOC 17
11808: PUSH
11809: LD_INT 10
11811: GREATER
11812: IFFALSE 11830
// begin factory2_idle := 0 ;
11814: LD_ADDR_LOC 17
11818: PUSH
11819: LD_INT 0
11821: ST_TO_ADDR
// busy_fact2 := false ;
11822: LD_ADDR_EXP 50
11826: PUSH
11827: LD_INT 0
11829: ST_TO_ADDR
// end ; end ; end_of_file
11830: END
// export war_forces , war_lapser , war_count ; export attack_forces ; export backup_forces , backup_lapser , backup_count ; export manual_forces , manual_lapser ; export fuel_tank ; export chybi ; export mm_vehicle ; export defend_forces ; export us_important ; var klic_area_1 , klic_area_2 ; var klic_area_3 , klic_area_4 ; var klic_area_5 , klic_area_6 ; var klic_area_7 , klic_area_8 ; var klic_area_9 ; var destroy_now ; var important ; var multi ; var skrivanek ; var kolibrik ; var attack_begin ; var cislo_utoku ; var now_area , next_area ; var event_unit ; export function startup_war_definition ; begin
11831: LD_INT 0
11833: PPUSH
// war_forces := [ ] ;
11834: LD_ADDR_EXP 52
11838: PUSH
11839: EMPTY
11840: ST_TO_ADDR
// war_lapser := 0 ;
11841: LD_ADDR_EXP 53
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// war_count := Rand ( 2 , 3 ) ;
11849: LD_ADDR_EXP 54
11853: PUSH
11854: LD_INT 2
11856: PPUSH
11857: LD_INT 3
11859: PPUSH
11860: CALL_OW 12
11864: ST_TO_ADDR
// backup_forces := [ ] ;
11865: LD_ADDR_EXP 56
11869: PUSH
11870: EMPTY
11871: ST_TO_ADDR
// backup_lapser := 0 ;
11872: LD_ADDR_EXP 57
11876: PUSH
11877: LD_INT 0
11879: ST_TO_ADDR
// backup_count := Rand ( 2 , 3 ) ;
11880: LD_ADDR_EXP 58
11884: PUSH
11885: LD_INT 2
11887: PPUSH
11888: LD_INT 3
11890: PPUSH
11891: CALL_OW 12
11895: ST_TO_ADDR
// manual_forces := [ ] ;
11896: LD_ADDR_EXP 59
11900: PUSH
11901: EMPTY
11902: ST_TO_ADDR
// manual_lapser := 0 ;
11903: LD_ADDR_EXP 60
11907: PUSH
11908: LD_INT 0
11910: ST_TO_ADDR
// defend_forces := [ ] ;
11911: LD_ADDR_EXP 64
11915: PUSH
11916: EMPTY
11917: ST_TO_ADDR
// klic_area_1 := [ ] ;
11918: LD_ADDR_LOC 18
11922: PUSH
11923: EMPTY
11924: ST_TO_ADDR
// klic_area_2 := [ ] ;
11925: LD_ADDR_LOC 19
11929: PUSH
11930: EMPTY
11931: ST_TO_ADDR
// klic_area_3 := [ ] ;
11932: LD_ADDR_LOC 20
11936: PUSH
11937: EMPTY
11938: ST_TO_ADDR
// klic_area_4 := [ ] ;
11939: LD_ADDR_LOC 21
11943: PUSH
11944: EMPTY
11945: ST_TO_ADDR
// klic_area_5 := [ ] ;
11946: LD_ADDR_LOC 22
11950: PUSH
11951: EMPTY
11952: ST_TO_ADDR
// klic_area_6 := [ ] ;
11953: LD_ADDR_LOC 23
11957: PUSH
11958: EMPTY
11959: ST_TO_ADDR
// klic_area_7 := [ ] ;
11960: LD_ADDR_LOC 24
11964: PUSH
11965: EMPTY
11966: ST_TO_ADDR
// klic_area_8 := [ ] ;
11967: LD_ADDR_LOC 25
11971: PUSH
11972: EMPTY
11973: ST_TO_ADDR
// klic_area_9 := [ ] ;
11974: LD_ADDR_LOC 26
11978: PUSH
11979: EMPTY
11980: ST_TO_ADDR
// cislo_utoku := 1 ;
11981: LD_ADDR_LOC 33
11985: PUSH
11986: LD_INT 1
11988: ST_TO_ADDR
// mm_vehicle := 0 ;
11989: LD_ADDR_EXP 63
11993: PUSH
11994: LD_INT 0
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 1
12001: RET
// export function zjisti_pozadavky ; var vybrano ; var i ; begin
12002: LD_INT 0
12004: PPUSH
12005: PPUSH
12006: PPUSH
// chybi := 0 ;
12007: LD_ADDR_EXP 62
12011: PUSH
12012: LD_INT 0
12014: ST_TO_ADDR
// if manual_forces < russians_forces then
12015: LD_EXP 59
12019: PUSH
12020: LD_EXP 28
12024: LESS
12025: IFFALSE 12035
// chybi := 3 ;
12027: LD_ADDR_EXP 62
12031: PUSH
12032: LD_INT 3
12034: ST_TO_ADDR
// end ;
12035: LD_VAR 0 1
12039: RET
// every 5 5$0 trigger ( backup_forces < backup_count ) and ( war_forces > 0 ) do var hex ;
12040: LD_EXP 56
12044: PUSH
12045: LD_EXP 58
12049: LESS
12050: PUSH
12051: LD_EXP 52
12055: PUSH
12056: LD_INT 0
12058: GREATER
12059: AND
12060: IFFALSE 12152
12062: GO 12064
12064: DISABLE
12065: LD_INT 0
12067: PPUSH
// begin hex := RandHexArea ( parking_place , true ) ;
12068: LD_ADDR_VAR 0 1
12072: PUSH
12073: LD_INT 11
12075: PPUSH
12076: LD_INT 1
12078: PPUSH
12079: CALL_OW 16
12083: ST_TO_ADDR
// backup_forces := backup_forces ^ ( war_forces [ 1 ] ) ;
12084: LD_ADDR_EXP 56
12088: PUSH
12089: LD_EXP 56
12093: PUSH
12094: LD_EXP 52
12098: PUSH
12099: LD_INT 1
12101: ARRAY
12102: ADD
12103: ST_TO_ADDR
// ComAgressiveMove ( war_forces [ 1 ] , hex [ 1 ] , hex [ 2 ] ) ;
12104: LD_EXP 52
12108: PUSH
12109: LD_INT 1
12111: ARRAY
12112: PPUSH
12113: LD_VAR 0 1
12117: PUSH
12118: LD_INT 1
12120: ARRAY
12121: PPUSH
12122: LD_VAR 0 1
12126: PUSH
12127: LD_INT 2
12129: ARRAY
12130: PPUSH
12131: CALL_OW 114
// war_forces := war_forces diff backup_forces ;
12135: LD_ADDR_EXP 52
12139: PUSH
12140: LD_EXP 52
12144: PUSH
12145: LD_EXP 56
12149: DIFF
12150: ST_TO_ADDR
// enable ;
12151: ENABLE
// end ;
12152: PPOPN 1
12154: END
// export function zaparkuj_vozidlo ( puvod_ridice , vozidlo ) ; var ridic , hex ; begin
12155: LD_INT 0
12157: PPUSH
12158: PPUSH
12159: PPUSH
// manual_forces := manual_forces ^ vozidlo ;
12160: LD_ADDR_EXP 59
12164: PUSH
12165: LD_EXP 59
12169: PUSH
12170: LD_VAR 0 2
12174: ADD
12175: ST_TO_ADDR
// hex := RandHexArea ( parking_place , true ) ;
12176: LD_ADDR_VAR 0 5
12180: PUSH
12181: LD_INT 11
12183: PPUSH
12184: LD_INT 1
12186: PPUSH
12187: CALL_OW 16
12191: ST_TO_ADDR
// if ( manual_forces < 2 ) then
12192: LD_EXP 59
12196: PUSH
12197: LD_INT 2
12199: LESS
12200: IFFALSE 12219
// ComMoveXY ( vozidlo , 103 , 59 ) else
12202: LD_VAR 0 2
12206: PPUSH
12207: LD_INT 103
12209: PPUSH
12210: LD_INT 59
12212: PPUSH
12213: CALL_OW 111
12217: GO 12246
// ComMoveXY ( vozidlo , hex [ 1 ] , hex [ 2 ] ) ;
12219: LD_VAR 0 2
12223: PPUSH
12224: LD_VAR 0 5
12228: PUSH
12229: LD_INT 1
12231: ARRAY
12232: PPUSH
12233: LD_VAR 0 5
12237: PUSH
12238: LD_INT 2
12240: ARRAY
12241: PPUSH
12242: CALL_OW 111
// repeat wait ( 0 0$5 ) ;
12246: LD_INT 175
12248: PPUSH
12249: CALL_OW 67
// until not IsBusy ( vozidlo ) ;
12253: LD_VAR 0 2
12257: PPUSH
12258: CALL_OW 315
12262: NOT
12263: IFFALSE 12246
// ridic := IsDrivenBy ( vozidlo ) ;
12265: LD_ADDR_VAR 0 4
12269: PUSH
12270: LD_VAR 0 2
12274: PPUSH
12275: CALL_OW 311
12279: ST_TO_ADDR
// ComExitVehicle ( ridic ) ;
12280: LD_VAR 0 4
12284: PPUSH
12285: CALL_OW 121
// AddComReturn ( ridic ) ;
12289: LD_VAR 0 4
12293: PPUSH
12294: CALL_OW 204
// end ;
12298: LD_VAR 0 3
12302: RET
// export function collect_war_forces ; begin
12303: LD_INT 0
12305: PPUSH
// ComAgressiveMove ( war_forces , 103 , 65 ) ;
12306: LD_EXP 52
12310: PPUSH
12311: LD_INT 103
12313: PPUSH
12314: LD_INT 65
12316: PPUSH
12317: CALL_OW 114
// end ;
12321: LD_VAR 0 1
12325: RET
// function zjisti_cilove_misto ( cislo_arei ) ; var vysledek ; begin
12326: LD_INT 0
12328: PPUSH
12329: PPUSH
// case cislo_arei of 1 :
12330: LD_VAR 0 1
12334: PUSH
12335: LD_INT 1
12337: DOUBLE
12338: EQUAL
12339: IFTRUE 12343
12341: GO 12361
12343: POP
// vysledek := [ 75 , 83 ] ; 2 :
12344: LD_ADDR_VAR 0 3
12348: PUSH
12349: LD_INT 75
12351: PUSH
12352: LD_INT 83
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: ST_TO_ADDR
12359: GO 12570
12361: LD_INT 2
12363: DOUBLE
12364: EQUAL
12365: IFTRUE 12369
12367: GO 12387
12369: POP
// vysledek := [ 82 , 102 ] ; 3 :
12370: LD_ADDR_VAR 0 3
12374: PUSH
12375: LD_INT 82
12377: PUSH
12378: LD_INT 102
12380: PUSH
12381: EMPTY
12382: LIST
12383: LIST
12384: ST_TO_ADDR
12385: GO 12570
12387: LD_INT 3
12389: DOUBLE
12390: EQUAL
12391: IFTRUE 12395
12393: GO 12413
12395: POP
// vysledek := [ 85 , 116 ] ; 4 :
12396: LD_ADDR_VAR 0 3
12400: PUSH
12401: LD_INT 85
12403: PUSH
12404: LD_INT 116
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: ST_TO_ADDR
12411: GO 12570
12413: LD_INT 4
12415: DOUBLE
12416: EQUAL
12417: IFTRUE 12421
12419: GO 12439
12421: POP
// vysledek := [ 95 , 107 ] ; 5 :
12422: LD_ADDR_VAR 0 3
12426: PUSH
12427: LD_INT 95
12429: PUSH
12430: LD_INT 107
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: ST_TO_ADDR
12437: GO 12570
12439: LD_INT 5
12441: DOUBLE
12442: EQUAL
12443: IFTRUE 12447
12445: GO 12465
12447: POP
// vysledek := [ 108 , 116 ] ; 6 :
12448: LD_ADDR_VAR 0 3
12452: PUSH
12453: LD_INT 108
12455: PUSH
12456: LD_INT 116
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: ST_TO_ADDR
12463: GO 12570
12465: LD_INT 6
12467: DOUBLE
12468: EQUAL
12469: IFTRUE 12473
12471: GO 12491
12473: POP
// vysledek := [ 105 , 133 ] ; 7 :
12474: LD_ADDR_VAR 0 3
12478: PUSH
12479: LD_INT 105
12481: PUSH
12482: LD_INT 133
12484: PUSH
12485: EMPTY
12486: LIST
12487: LIST
12488: ST_TO_ADDR
12489: GO 12570
12491: LD_INT 7
12493: DOUBLE
12494: EQUAL
12495: IFTRUE 12499
12497: GO 12517
12499: POP
// vysledek := [ 85 , 133 ] ; 8 :
12500: LD_ADDR_VAR 0 3
12504: PUSH
12505: LD_INT 85
12507: PUSH
12508: LD_INT 133
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: ST_TO_ADDR
12515: GO 12570
12517: LD_INT 8
12519: DOUBLE
12520: EQUAL
12521: IFTRUE 12525
12523: GO 12543
12525: POP
// vysledek := [ 62 , 105 ] ; 9 :
12526: LD_ADDR_VAR 0 3
12530: PUSH
12531: LD_INT 62
12533: PUSH
12534: LD_INT 105
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: ST_TO_ADDR
12541: GO 12570
12543: LD_INT 9
12545: DOUBLE
12546: EQUAL
12547: IFTRUE 12551
12549: GO 12569
12551: POP
// vysledek := [ 103 , 97 ] ; end ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_INT 103
12559: PUSH
12560: LD_INT 97
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: ST_TO_ADDR
12567: GO 12570
12569: POP
// result := vysledek ;
12570: LD_ADDR_VAR 0 2
12574: PUSH
12575: LD_VAR 0 3
12579: ST_TO_ADDR
// end ;
12580: LD_VAR 0 2
12584: RET
// function a_jmeno ( cislo ) ; var vysledek ; begin
12585: LD_INT 0
12587: PPUSH
12588: PPUSH
// case cislo of 1 :
12589: LD_VAR 0 1
12593: PUSH
12594: LD_INT 1
12596: DOUBLE
12597: EQUAL
12598: IFTRUE 12602
12600: GO 12613
12602: POP
// vysledek := u_north ; 2 :
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: LD_INT 16
12610: ST_TO_ADDR
12611: GO 12823
12613: LD_INT 2
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12632
12621: POP
// vysledek := u_central_n ; 3 :
12622: LD_ADDR_VAR 0 3
12626: PUSH
12627: LD_INT 17
12629: ST_TO_ADDR
12630: GO 12823
12632: LD_INT 3
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12651
12640: POP
// vysledek := u_central ; 4 :
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: LD_INT 19
12648: ST_TO_ADDR
12649: GO 12823
12651: LD_INT 4
12653: DOUBLE
12654: EQUAL
12655: IFTRUE 12659
12657: GO 12670
12659: POP
// vysledek := u_hill ; 5 :
12660: LD_ADDR_VAR 0 3
12664: PUSH
12665: LD_INT 18
12667: ST_TO_ADDR
12668: GO 12823
12670: LD_INT 5
12672: DOUBLE
12673: EQUAL
12674: IFTRUE 12678
12676: GO 12689
12678: POP
// vysledek := u_walley ; 6 :
12679: LD_ADDR_VAR 0 3
12683: PUSH
12684: LD_INT 21
12686: ST_TO_ADDR
12687: GO 12823
12689: LD_INT 6
12691: DOUBLE
12692: EQUAL
12693: IFTRUE 12697
12695: GO 12708
12697: POP
// vysledek := u_forgotten ; 7 :
12698: LD_ADDR_VAR 0 3
12702: PUSH
12703: LD_INT 23
12705: ST_TO_ADDR
12706: GO 12823
12708: LD_INT 7
12710: DOUBLE
12711: EQUAL
12712: IFTRUE 12716
12714: GO 12727
12716: POP
// vysledek := u_south ; 8 :
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_INT 20
12724: ST_TO_ADDR
12725: GO 12823
12727: LD_INT 8
12729: DOUBLE
12730: EQUAL
12731: IFTRUE 12735
12733: GO 12746
12735: POP
// vysledek := u_heart ; 9 :
12736: LD_ADDR_VAR 0 3
12740: PUSH
12741: LD_INT 22
12743: ST_TO_ADDR
12744: GO 12823
12746: LD_INT 9
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12765
12754: POP
// vysledek := u_east ; 11 :
12755: LD_ADDR_VAR 0 3
12759: PUSH
12760: LD_INT 24
12762: ST_TO_ADDR
12763: GO 12823
12765: LD_INT 11
12767: DOUBLE
12768: EQUAL
12769: IFTRUE 12773
12771: GO 12784
12773: POP
// vysledek := n_gather ; 12 :
12774: LD_ADDR_VAR 0 3
12778: PUSH
12779: LD_INT 13
12781: ST_TO_ADDR
12782: GO 12823
12784: LD_INT 12
12786: DOUBLE
12787: EQUAL
12788: IFTRUE 12792
12790: GO 12803
12792: POP
// vysledek := e_gather ; 13 :
12793: LD_ADDR_VAR 0 3
12797: PUSH
12798: LD_INT 14
12800: ST_TO_ADDR
12801: GO 12823
12803: LD_INT 13
12805: DOUBLE
12806: EQUAL
12807: IFTRUE 12811
12809: GO 12822
12811: POP
// vysledek := s_gather ; end ;
12812: LD_ADDR_VAR 0 3
12816: PUSH
12817: LD_INT 15
12819: ST_TO_ADDR
12820: GO 12823
12822: POP
// result := vysledek ;
12823: LD_ADDR_VAR 0 2
12827: PUSH
12828: LD_VAR 0 3
12832: ST_TO_ADDR
// end ;
12833: LD_VAR 0 2
12837: RET
// function goto_north_sector ; var i , utocniku ; begin
12838: LD_INT 0
12840: PPUSH
12841: PPUSH
12842: PPUSH
// ComAgressiveMove ( attack_forces , 100 , 67 ) ;
12843: LD_EXP 55
12847: PPUSH
12848: LD_INT 100
12850: PPUSH
12851: LD_INT 67
12853: PPUSH
12854: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 87 , 65 ) ;
12858: LD_EXP 55
12862: PPUSH
12863: LD_INT 87
12865: PPUSH
12866: LD_INT 65
12868: PPUSH
12869: CALL_OW 174
// AddComAgressiveMove ( attack_forces , 74 , 64 ) ;
12873: LD_EXP 55
12877: PPUSH
12878: LD_INT 74
12880: PPUSH
12881: LD_INT 64
12883: PPUSH
12884: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12888: LD_INT 70
12890: PPUSH
12891: CALL_OW 67
// until vsichni_v_arei ( n_gather ) or ( not attack_forces ) ;
12895: LD_INT 13
12897: PPUSH
12898: CALL 13708 0 1
12902: PUSH
12903: LD_EXP 55
12907: NOT
12908: OR
12909: IFFALSE 12888
// attack_begin := true ;
12911: LD_ADDR_LOC 32
12915: PUSH
12916: LD_INT 1
12918: ST_TO_ADDR
// end ;
12919: LD_VAR 0 1
12923: RET
// function goto_east_sector ; var i , utocniku ; begin
12924: LD_INT 0
12926: PPUSH
12927: PPUSH
12928: PPUSH
// utocniku := 0 + attack_forces ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 0
12936: PUSH
12937: LD_EXP 55
12941: PLUS
12942: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12943: LD_EXP 55
12947: PPUSH
12948: LD_INT 111
12950: PPUSH
12951: LD_INT 73
12953: PPUSH
12954: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 116 , 95 ) ;
12958: LD_EXP 55
12962: PPUSH
12963: LD_INT 116
12965: PPUSH
12966: LD_INT 95
12968: PPUSH
12969: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12973: LD_INT 70
12975: PPUSH
12976: CALL_OW 67
// until vsichni_v_arei ( e_gather ) or ( not attack_forces ) ;
12980: LD_INT 14
12982: PPUSH
12983: CALL 13708 0 1
12987: PUSH
12988: LD_EXP 55
12992: NOT
12993: OR
12994: IFFALSE 12973
// attack_begin := true ;
12996: LD_ADDR_LOC 32
13000: PUSH
13001: LD_INT 1
13003: ST_TO_ADDR
// end ;
13004: LD_VAR 0 1
13008: RET
// function goto_south_sector ; var i , utocniku ; begin
13009: LD_INT 0
13011: PPUSH
13012: PPUSH
13013: PPUSH
// utocniku := 0 + attack_forces ;
13014: LD_ADDR_VAR 0 3
13018: PUSH
13019: LD_INT 0
13021: PUSH
13022: LD_EXP 55
13026: PLUS
13027: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
13028: LD_EXP 55
13032: PPUSH
13033: LD_INT 111
13035: PPUSH
13036: LD_INT 73
13038: PPUSH
13039: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 127 , 118 ) ;
13043: LD_EXP 55
13047: PPUSH
13048: LD_INT 127
13050: PPUSH
13051: LD_INT 118
13053: PPUSH
13054: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
13058: LD_INT 70
13060: PPUSH
13061: CALL_OW 67
// until vsichni_v_arei ( s_gather ) or ( not attack_forces ) ;
13065: LD_INT 15
13067: PPUSH
13068: CALL 13708 0 1
13072: PUSH
13073: LD_EXP 55
13077: NOT
13078: OR
13079: IFFALSE 13058
// attack_begin := true ;
13081: LD_ADDR_LOC 32
13085: PUSH
13086: LD_INT 1
13088: ST_TO_ADDR
// end ;
13089: LD_VAR 0 1
13093: RET
// function zjisti_schudne_okoli ( area ) ; var a1 , a2 , vysledek ; var v1 , v2 ; begin
13094: LD_INT 0
13096: PPUSH
13097: PPUSH
13098: PPUSH
13099: PPUSH
13100: PPUSH
13101: PPUSH
// case area of 1 :
13102: LD_VAR 0 1
13106: PUSH
13107: LD_INT 1
13109: DOUBLE
13110: EQUAL
13111: IFTRUE 13115
13113: GO 13134
13115: POP
// begin a1 := 2 ;
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: LD_INT 2
13123: ST_TO_ADDR
// a2 := 0 ;
13124: LD_ADDR_VAR 0 4
13128: PUSH
13129: LD_INT 0
13131: ST_TO_ADDR
// end ; 2 :
13132: GO 13432
13134: LD_INT 2
13136: DOUBLE
13137: EQUAL
13138: IFTRUE 13142
13140: GO 13161
13142: POP
// begin a1 := 3 ;
13143: LD_ADDR_VAR 0 3
13147: PUSH
13148: LD_INT 3
13150: ST_TO_ADDR
// a2 := 8 ;
13151: LD_ADDR_VAR 0 4
13155: PUSH
13156: LD_INT 8
13158: ST_TO_ADDR
// end ; 3 :
13159: GO 13432
13161: LD_INT 3
13163: DOUBLE
13164: EQUAL
13165: IFTRUE 13169
13167: GO 13188
13169: POP
// begin a1 := 7 ;
13170: LD_ADDR_VAR 0 3
13174: PUSH
13175: LD_INT 7
13177: ST_TO_ADDR
// a2 := 2 ;
13178: LD_ADDR_VAR 0 4
13182: PUSH
13183: LD_INT 2
13185: ST_TO_ADDR
// end ; 4 :
13186: GO 13432
13188: LD_INT 4
13190: DOUBLE
13191: EQUAL
13192: IFTRUE 13196
13194: GO 13215
13196: POP
// begin a1 := 2 ;
13197: LD_ADDR_VAR 0 3
13201: PUSH
13202: LD_INT 2
13204: ST_TO_ADDR
// a2 := 3 ;
13205: LD_ADDR_VAR 0 4
13209: PUSH
13210: LD_INT 3
13212: ST_TO_ADDR
// end ; 5 :
13213: GO 13432
13215: LD_INT 5
13217: DOUBLE
13218: EQUAL
13219: IFTRUE 13223
13221: GO 13242
13223: POP
// begin a1 := 3 ;
13224: LD_ADDR_VAR 0 3
13228: PUSH
13229: LD_INT 3
13231: ST_TO_ADDR
// a2 := 6 ;
13232: LD_ADDR_VAR 0 4
13236: PUSH
13237: LD_INT 6
13239: ST_TO_ADDR
// end ; 6 :
13240: GO 13432
13242: LD_INT 6
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13269
13250: POP
// begin a1 := 7 ;
13251: LD_ADDR_VAR 0 3
13255: PUSH
13256: LD_INT 7
13258: ST_TO_ADDR
// a2 := 3 ;
13259: LD_ADDR_VAR 0 4
13263: PUSH
13264: LD_INT 3
13266: ST_TO_ADDR
// end ; 7 :
13267: GO 13432
13269: LD_INT 7
13271: DOUBLE
13272: EQUAL
13273: IFTRUE 13277
13275: GO 13296
13277: POP
// begin a1 := 8 ;
13278: LD_ADDR_VAR 0 3
13282: PUSH
13283: LD_INT 8
13285: ST_TO_ADDR
// a2 := 3 ;
13286: LD_ADDR_VAR 0 4
13290: PUSH
13291: LD_INT 3
13293: ST_TO_ADDR
// end ; 8 :
13294: GO 13432
13296: LD_INT 8
13298: DOUBLE
13299: EQUAL
13300: IFTRUE 13304
13302: GO 13323
13304: POP
// begin a1 := 2 ;
13305: LD_ADDR_VAR 0 3
13309: PUSH
13310: LD_INT 2
13312: ST_TO_ADDR
// a2 := 7 ;
13313: LD_ADDR_VAR 0 4
13317: PUSH
13318: LD_INT 7
13320: ST_TO_ADDR
// end ; 9 :
13321: GO 13432
13323: LD_INT 9
13325: DOUBLE
13326: EQUAL
13327: IFTRUE 13331
13329: GO 13350
13331: POP
// begin a1 := 2 ;
13332: LD_ADDR_VAR 0 3
13336: PUSH
13337: LD_INT 2
13339: ST_TO_ADDR
// a2 := 5 ;
13340: LD_ADDR_VAR 0 4
13344: PUSH
13345: LD_INT 5
13347: ST_TO_ADDR
// end ; 11 :
13348: GO 13432
13350: LD_INT 11
13352: DOUBLE
13353: EQUAL
13354: IFTRUE 13358
13356: GO 13377
13358: POP
// begin a1 := 1 ;
13359: LD_ADDR_VAR 0 3
13363: PUSH
13364: LD_INT 1
13366: ST_TO_ADDR
// a2 := 0 ;
13367: LD_ADDR_VAR 0 4
13371: PUSH
13372: LD_INT 0
13374: ST_TO_ADDR
// end ; 12 :
13375: GO 13432
13377: LD_INT 12
13379: DOUBLE
13380: EQUAL
13381: IFTRUE 13385
13383: GO 13404
13385: POP
// begin a1 := 5 ;
13386: LD_ADDR_VAR 0 3
13390: PUSH
13391: LD_INT 5
13393: ST_TO_ADDR
// a2 := 0 ;
13394: LD_ADDR_VAR 0 4
13398: PUSH
13399: LD_INT 0
13401: ST_TO_ADDR
// end ; 13 :
13402: GO 13432
13404: LD_INT 13
13406: DOUBLE
13407: EQUAL
13408: IFTRUE 13412
13410: GO 13431
13412: POP
// begin a1 := 9 ;
13413: LD_ADDR_VAR 0 3
13417: PUSH
13418: LD_INT 9
13420: ST_TO_ADDR
// a2 := 0 ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_INT 0
13428: ST_TO_ADDR
// end ; end ;
13429: GO 13432
13431: POP
// v1 := [ a1 ] ;
13432: LD_ADDR_VAR 0 6
13436: PUSH
13437: LD_VAR 0 3
13441: PUSH
13442: EMPTY
13443: LIST
13444: ST_TO_ADDR
// if a2 then
13445: LD_VAR 0 4
13449: IFFALSE 13467
// v1 := v1 ^ a1 ;
13451: LD_ADDR_VAR 0 6
13455: PUSH
13456: LD_VAR 0 6
13460: PUSH
13461: LD_VAR 0 3
13465: ADD
13466: ST_TO_ADDR
// vysledek := v1 [ Rand ( 1 , v1 ) ] ;
13467: LD_ADDR_VAR 0 5
13471: PUSH
13472: LD_VAR 0 6
13476: PUSH
13477: LD_INT 1
13479: PPUSH
13480: LD_VAR 0 6
13484: PPUSH
13485: CALL_OW 12
13489: ARRAY
13490: ST_TO_ADDR
// result := vysledek ;
13491: LD_ADDR_VAR 0 2
13495: PUSH
13496: LD_VAR 0 5
13500: ST_TO_ADDR
// end ;
13501: LD_VAR 0 2
13505: RET
// function navrhni_startovni_pozici ; var s1 , s2 , s3 , vysledek ; var un , truck ; begin
13506: LD_INT 0
13508: PPUSH
13509: PPUSH
13510: PPUSH
13511: PPUSH
13512: PPUSH
13513: PPUSH
13514: PPUSH
// s1 := klic_area_1 ;
13515: LD_ADDR_VAR 0 2
13519: PUSH
13520: LD_LOC 18
13524: ST_TO_ADDR
// s2 := klic_area_9 ;
13525: LD_ADDR_VAR 0 3
13529: PUSH
13530: LD_LOC 26
13534: ST_TO_ADDR
// s3 := klic_area_5 ;
13535: LD_ADDR_VAR 0 4
13539: PUSH
13540: LD_LOC 22
13544: ST_TO_ADDR
// truck := true ;
13545: LD_ADDR_VAR 0 7
13549: PUSH
13550: LD_INT 1
13552: ST_TO_ADDR
// for un in attack_forces do
13553: LD_ADDR_VAR 0 6
13557: PUSH
13558: LD_EXP 55
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13591
// if GetChassis ( un ) <> ru_heavy_tracked then
13566: LD_VAR 0 6
13570: PPUSH
13571: CALL_OW 265
13575: PUSH
13576: LD_INT 24
13578: NONEQUAL
13579: IFFALSE 13589
// truck := false ;
13581: LD_ADDR_VAR 0 7
13585: PUSH
13586: LD_INT 0
13588: ST_TO_ADDR
13589: GO 13563
13591: POP
13592: POP
// if ( a_jmeno ( s1 ) < a_jmeno ( s2 ) ) and ( a_jmeno ( s1 ) < a_jmeno ( s3 ) ) and truck then
13593: LD_VAR 0 2
13597: PPUSH
13598: CALL 12585 0 1
13602: PUSH
13603: LD_VAR 0 3
13607: PPUSH
13608: CALL 12585 0 1
13612: LESS
13613: PUSH
13614: LD_VAR 0 2
13618: PPUSH
13619: CALL 12585 0 1
13623: PUSH
13624: LD_VAR 0 4
13628: PPUSH
13629: CALL 12585 0 1
13633: LESS
13634: AND
13635: PUSH
13636: LD_VAR 0 7
13640: AND
13641: IFFALSE 13653
// vysledek := 1 else
13643: LD_ADDR_VAR 0 5
13647: PUSH
13648: LD_INT 1
13650: ST_TO_ADDR
13651: GO 13693
// if ( a_jmeno ( s2 ) < a_jmeno ( s3 ) ) then
13653: LD_VAR 0 3
13657: PPUSH
13658: CALL 12585 0 1
13662: PUSH
13663: LD_VAR 0 4
13667: PPUSH
13668: CALL 12585 0 1
13672: LESS
13673: IFFALSE 13685
// vysledek := 9 else
13675: LD_ADDR_VAR 0 5
13679: PUSH
13680: LD_INT 9
13682: ST_TO_ADDR
13683: GO 13693
// vysledek := 5 ;
13685: LD_ADDR_VAR 0 5
13689: PUSH
13690: LD_INT 5
13692: ST_TO_ADDR
// result := vysledek ;
13693: LD_ADDR_VAR 0 1
13697: PUSH
13698: LD_VAR 0 5
13702: ST_TO_ADDR
// end ;
13703: LD_VAR 0 1
13707: RET
// function vsichni_v_arei ( ktera_area ) ; var un , vysledek ; begin
13708: LD_INT 0
13710: PPUSH
13711: PPUSH
13712: PPUSH
// un := FilterUnitsInArea ( ktera_area , [ [ f_side , russians ] ] ) ;
13713: LD_ADDR_VAR 0 3
13717: PUSH
13718: LD_VAR 0 1
13722: PPUSH
13723: LD_INT 22
13725: PUSH
13726: LD_EXP 15
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PUSH
13735: EMPTY
13736: LIST
13737: PPUSH
13738: CALL_OW 70
13742: ST_TO_ADDR
// if un >= ( ( attack_forces + 1 ) div 2 ) then
13743: LD_VAR 0 3
13747: PUSH
13748: LD_EXP 55
13752: PUSH
13753: LD_INT 1
13755: PLUS
13756: PUSH
13757: LD_INT 2
13759: DIV
13760: GREATEREQUAL
13761: IFFALSE 13773
// vysledek := true else
13763: LD_ADDR_VAR 0 4
13767: PUSH
13768: LD_INT 1
13770: ST_TO_ADDR
13771: GO 13781
// vysledek := false ;
13773: LD_ADDR_VAR 0 4
13777: PUSH
13778: LD_INT 0
13780: ST_TO_ADDR
// result := vysledek ;
13781: LD_ADDR_VAR 0 2
13785: PUSH
13786: LD_VAR 0 4
13790: ST_TO_ADDR
// end ;
13791: LD_VAR 0 2
13795: RET
// function see_important ( now_area ) ; var un , area , vysledek ; begin
13796: LD_INT 0
13798: PPUSH
13799: PPUSH
13800: PPUSH
13801: PPUSH
// vysledek := false ;
13802: LD_ADDR_VAR 0 5
13806: PUSH
13807: LD_INT 0
13809: ST_TO_ADDR
// area := [ ] ;
13810: LD_ADDR_VAR 0 4
13814: PUSH
13815: EMPTY
13816: ST_TO_ADDR
// for un in us_important do
13817: LD_ADDR_VAR 0 3
13821: PUSH
13822: LD_EXP 65
13826: PUSH
13827: FOR_IN
13828: IFFALSE 14137
// if See ( russians , un ) then
13830: LD_EXP 15
13834: PPUSH
13835: LD_VAR 0 3
13839: PPUSH
13840: CALL_OW 292
13844: IFFALSE 14135
// begin area := area ^ un ;
13846: LD_ADDR_VAR 0 4
13850: PUSH
13851: LD_VAR 0 4
13855: PUSH
13856: LD_VAR 0 3
13860: ADD
13861: ST_TO_ADDR
// case now_area of 1 :
13862: LD_VAR 0 1
13866: PUSH
13867: LD_INT 1
13869: DOUBLE
13870: EQUAL
13871: IFTRUE 13875
13873: GO 13894
13875: POP
// klic_area_1 := klic_area_1 union area ; 2 :
13876: LD_ADDR_LOC 18
13880: PUSH
13881: LD_LOC 18
13885: PUSH
13886: LD_VAR 0 4
13890: UNION
13891: ST_TO_ADDR
13892: GO 14111
13894: LD_INT 2
13896: DOUBLE
13897: EQUAL
13898: IFTRUE 13902
13900: GO 13921
13902: POP
// klic_area_2 := klic_area_2 union area ; 3 :
13903: LD_ADDR_LOC 19
13907: PUSH
13908: LD_LOC 19
13912: PUSH
13913: LD_VAR 0 4
13917: UNION
13918: ST_TO_ADDR
13919: GO 14111
13921: LD_INT 3
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 13948
13929: POP
// klic_area_3 := klic_area_3 union area ; 4 :
13930: LD_ADDR_LOC 20
13934: PUSH
13935: LD_LOC 20
13939: PUSH
13940: LD_VAR 0 4
13944: UNION
13945: ST_TO_ADDR
13946: GO 14111
13948: LD_INT 4
13950: DOUBLE
13951: EQUAL
13952: IFTRUE 13956
13954: GO 13975
13956: POP
// klic_area_4 := klic_area_4 union area ; 5 :
13957: LD_ADDR_LOC 21
13961: PUSH
13962: LD_LOC 21
13966: PUSH
13967: LD_VAR 0 4
13971: UNION
13972: ST_TO_ADDR
13973: GO 14111
13975: LD_INT 5
13977: DOUBLE
13978: EQUAL
13979: IFTRUE 13983
13981: GO 14002
13983: POP
// klic_area_5 := klic_area_5 union area ; 6 :
13984: LD_ADDR_LOC 22
13988: PUSH
13989: LD_LOC 22
13993: PUSH
13994: LD_VAR 0 4
13998: UNION
13999: ST_TO_ADDR
14000: GO 14111
14002: LD_INT 6
14004: DOUBLE
14005: EQUAL
14006: IFTRUE 14010
14008: GO 14029
14010: POP
// klic_area_6 := klic_area_6 union area ; 7 :
14011: LD_ADDR_LOC 23
14015: PUSH
14016: LD_LOC 23
14020: PUSH
14021: LD_VAR 0 4
14025: UNION
14026: ST_TO_ADDR
14027: GO 14111
14029: LD_INT 7
14031: DOUBLE
14032: EQUAL
14033: IFTRUE 14037
14035: GO 14056
14037: POP
// klic_area_7 := klic_area_7 union area ; 8 :
14038: LD_ADDR_LOC 24
14042: PUSH
14043: LD_LOC 24
14047: PUSH
14048: LD_VAR 0 4
14052: UNION
14053: ST_TO_ADDR
14054: GO 14111
14056: LD_INT 8
14058: DOUBLE
14059: EQUAL
14060: IFTRUE 14064
14062: GO 14083
14064: POP
// klic_area_8 := klic_area_8 union area ; 9 :
14065: LD_ADDR_LOC 25
14069: PUSH
14070: LD_LOC 25
14074: PUSH
14075: LD_VAR 0 4
14079: UNION
14080: ST_TO_ADDR
14081: GO 14111
14083: LD_INT 9
14085: DOUBLE
14086: EQUAL
14087: IFTRUE 14091
14089: GO 14110
14091: POP
// klic_area_9 := klic_area_9 union area ; end ;
14092: LD_ADDR_LOC 26
14096: PUSH
14097: LD_LOC 26
14101: PUSH
14102: LD_VAR 0 4
14106: UNION
14107: ST_TO_ADDR
14108: GO 14111
14110: POP
// destroy_now := destroy_now union un ;
14111: LD_ADDR_LOC 27
14115: PUSH
14116: LD_LOC 27
14120: PUSH
14121: LD_VAR 0 3
14125: UNION
14126: ST_TO_ADDR
// vysledek := true ;
14127: LD_ADDR_VAR 0 5
14131: PUSH
14132: LD_INT 1
14134: ST_TO_ADDR
// end ;
14135: GO 13827
14137: POP
14138: POP
// result := vysledek ;
14139: LD_ADDR_VAR 0 2
14143: PUSH
14144: LD_VAR 0 5
14148: ST_TO_ADDR
// end ;
14149: LD_VAR 0 2
14153: RET
// function destroy_important ( area ) ; var i , j , max , max_search ; var cil , prior_1 , prior_max ; begin
14154: LD_INT 0
14156: PPUSH
14157: PPUSH
14158: PPUSH
14159: PPUSH
14160: PPUSH
14161: PPUSH
14162: PPUSH
14163: PPUSH
// max_search := 3 ;
14164: LD_ADDR_VAR 0 6
14168: PUSH
14169: LD_INT 3
14171: ST_TO_ADDR
// max := 0 + destroy_now ;
14172: LD_ADDR_VAR 0 5
14176: PUSH
14177: LD_INT 0
14179: PUSH
14180: LD_LOC 27
14184: PLUS
14185: ST_TO_ADDR
// if max > 3 then
14186: LD_VAR 0 5
14190: PUSH
14191: LD_INT 3
14193: GREATER
14194: IFFALSE 14206
// j := 3 else
14196: LD_ADDR_VAR 0 4
14200: PUSH
14201: LD_INT 3
14203: ST_TO_ADDR
14204: GO 14216
// j := max ;
14206: LD_ADDR_VAR 0 4
14210: PUSH
14211: LD_VAR 0 5
14215: ST_TO_ADDR
// prior_max := [ 0 , 0 ] ;
14216: LD_ADDR_VAR 0 9
14220: PUSH
14221: LD_INT 0
14223: PUSH
14224: LD_INT 0
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
// for i = 1 to j do
14231: LD_ADDR_VAR 0 3
14235: PUSH
14236: DOUBLE
14237: LD_INT 1
14239: DEC
14240: ST_TO_ADDR
14241: LD_VAR 0 4
14245: PUSH
14246: FOR_TO
14247: IFFALSE 14525
// begin prior_1 := 0 ;
14249: LD_ADDR_VAR 0 8
14253: PUSH
14254: LD_INT 0
14256: ST_TO_ADDR
// case GetBType ( destroy_now [ i ] ) of 33 :
14257: LD_LOC 27
14261: PUSH
14262: LD_VAR 0 3
14266: ARRAY
14267: PPUSH
14268: CALL_OW 266
14272: PUSH
14273: LD_INT 33
14275: DOUBLE
14276: EQUAL
14277: IFTRUE 14281
14279: GO 14292
14281: POP
// prior_1 := 4 ; 30 :
14282: LD_ADDR_VAR 0 8
14286: PUSH
14287: LD_INT 4
14289: ST_TO_ADDR
14290: GO 14377
14292: LD_INT 30
14294: DOUBLE
14295: EQUAL
14296: IFTRUE 14300
14298: GO 14311
14300: POP
// prior_1 := 4 ; 29 :
14301: LD_ADDR_VAR 0 8
14305: PUSH
14306: LD_INT 4
14308: ST_TO_ADDR
14309: GO 14377
14311: LD_INT 29
14313: DOUBLE
14314: EQUAL
14315: IFTRUE 14319
14317: GO 14330
14319: POP
// prior_1 := 3 ; 28 :
14320: LD_ADDR_VAR 0 8
14324: PUSH
14325: LD_INT 3
14327: ST_TO_ADDR
14328: GO 14377
14330: LD_INT 28
14332: DOUBLE
14333: EQUAL
14334: IFTRUE 14338
14336: GO 14349
14338: POP
// prior_1 := 3 ; 26 :
14339: LD_ADDR_VAR 0 8
14343: PUSH
14344: LD_INT 3
14346: ST_TO_ADDR
14347: GO 14377
14349: LD_INT 26
14351: DOUBLE
14352: EQUAL
14353: IFTRUE 14357
14355: GO 14368
14357: POP
// prior_1 := 2 ; else
14358: LD_ADDR_VAR 0 8
14362: PUSH
14363: LD_INT 2
14365: ST_TO_ADDR
14366: GO 14377
14368: POP
// prior_1 := 1 ; end ;
14369: LD_ADDR_VAR 0 8
14373: PUSH
14374: LD_INT 1
14376: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 750 then
14377: LD_LOC 27
14381: PUSH
14382: LD_VAR 0 3
14386: ARRAY
14387: PPUSH
14388: CALL_OW 256
14392: PUSH
14393: LD_INT 750
14395: LESS
14396: IFFALSE 14412
// prior_1 := prior_1 + 1 ;
14398: LD_ADDR_VAR 0 8
14402: PUSH
14403: LD_VAR 0 8
14407: PUSH
14408: LD_INT 1
14410: PLUS
14411: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 500 then
14412: LD_LOC 27
14416: PUSH
14417: LD_VAR 0 3
14421: ARRAY
14422: PPUSH
14423: CALL_OW 256
14427: PUSH
14428: LD_INT 500
14430: LESS
14431: IFFALSE 14447
// prior_1 := prior_1 + 2 ;
14433: LD_ADDR_VAR 0 8
14437: PUSH
14438: LD_VAR 0 8
14442: PUSH
14443: LD_INT 2
14445: PLUS
14446: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 250 then
14447: LD_LOC 27
14451: PUSH
14452: LD_VAR 0 3
14456: ARRAY
14457: PPUSH
14458: CALL_OW 256
14462: PUSH
14463: LD_INT 250
14465: LESS
14466: IFFALSE 14482
// prior_1 := prior_1 + 2 ;
14468: LD_ADDR_VAR 0 8
14472: PUSH
14473: LD_VAR 0 8
14477: PUSH
14478: LD_INT 2
14480: PLUS
14481: ST_TO_ADDR
// if prior_1 > prior_max [ 1 ] then
14482: LD_VAR 0 8
14486: PUSH
14487: LD_VAR 0 9
14491: PUSH
14492: LD_INT 1
14494: ARRAY
14495: GREATER
14496: IFFALSE 14523
// prior_max := [ prior_1 , destroy_now [ i ] ] ;
14498: LD_ADDR_VAR 0 9
14502: PUSH
14503: LD_VAR 0 8
14507: PUSH
14508: LD_LOC 27
14512: PUSH
14513: LD_VAR 0 3
14517: ARRAY
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: ST_TO_ADDR
// end ;
14523: GO 14246
14525: POP
14526: POP
// if prior_max [ 2 ] then
14527: LD_VAR 0 9
14531: PUSH
14532: LD_INT 2
14534: ARRAY
14535: IFFALSE 14578
// DestroyTarget ( prior_max [ 2 ] , GetX ( prior_max [ 2 ] ) , GetY ( prior_max [ 2 ] ) ) ;
14537: LD_VAR 0 9
14541: PUSH
14542: LD_INT 2
14544: ARRAY
14545: PPUSH
14546: LD_VAR 0 9
14550: PUSH
14551: LD_INT 2
14553: ARRAY
14554: PPUSH
14555: CALL_OW 250
14559: PPUSH
14560: LD_VAR 0 9
14564: PUSH
14565: LD_INT 2
14567: ARRAY
14568: PPUSH
14569: CALL_OW 251
14573: PPUSH
14574: CALL 14583 0 3
// end ;
14578: LD_VAR 0 2
14582: RET
// function DestroyTarget ( target , x , y ) ; var un ; begin
14583: LD_INT 0
14585: PPUSH
14586: PPUSH
// for un in attack_forces do
14587: LD_ADDR_VAR 0 5
14591: PUSH
14592: LD_EXP 55
14596: PUSH
14597: FOR_IN
14598: IFFALSE 14659
// if GetWeapon ( un ) in [ ru_rocket , ru_rocket_launcher ] then
14600: LD_VAR 0 5
14604: PPUSH
14605: CALL_OW 264
14609: PUSH
14610: LD_INT 47
14612: PUSH
14613: LD_INT 45
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: IN
14620: IFFALSE 14643
// ComAttackPlace ( un , x , y ) else
14622: LD_VAR 0 5
14626: PPUSH
14627: LD_VAR 0 2
14631: PPUSH
14632: LD_VAR 0 3
14636: PPUSH
14637: CALL_OW 116
14641: GO 14657
// ComAttackUnit ( un , target ) ;
14643: LD_VAR 0 5
14647: PPUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 115
14657: GO 14597
14659: POP
14660: POP
// end ;
14661: LD_VAR 0 4
14665: RET
// function konec_jednoho_utoku ; begin
14666: LD_INT 0
14668: PPUSH
// war_forces := war_forces ^ attack_forces ;
14669: LD_ADDR_EXP 52
14673: PUSH
14674: LD_EXP 52
14678: PUSH
14679: LD_EXP 55
14683: ADD
14684: ST_TO_ADDR
// attack_forces := [ ] ;
14685: LD_ADDR_EXP 55
14689: PUSH
14690: EMPTY
14691: ST_TO_ADDR
// attack_begin := false ;
14692: LD_ADDR_LOC 32
14696: PUSH
14697: LD_INT 0
14699: ST_TO_ADDR
// war_count := Rand ( cislo_utoku + 1 , cislo_utoku + 3 ) ;
14700: LD_ADDR_EXP 54
14704: PUSH
14705: LD_LOC 33
14709: PUSH
14710: LD_INT 1
14712: PLUS
14713: PPUSH
14714: LD_LOC 33
14718: PUSH
14719: LD_INT 3
14721: PLUS
14722: PPUSH
14723: CALL_OW 12
14727: ST_TO_ADDR
// if war_count > 4 then
14728: LD_EXP 54
14732: PUSH
14733: LD_INT 4
14735: GREATER
14736: IFFALSE 14754
// war_count := Rand ( 4 , 5 ) ;
14738: LD_ADDR_EXP 54
14742: PUSH
14743: LD_INT 4
14745: PPUSH
14746: LD_INT 5
14748: PPUSH
14749: CALL_OW 12
14753: ST_TO_ADDR
// end ;
14754: LD_VAR 0 1
14758: RET
// function low_cesta ; var i , max , areas , mc_id , new_destination ; begin
14759: LD_INT 0
14761: PPUSH
14762: PPUSH
14763: PPUSH
14764: PPUSH
14765: PPUSH
14766: PPUSH
// multi := false ;
14767: LD_ADDR_LOC 29
14771: PUSH
14772: LD_INT 0
14774: ST_TO_ADDR
// attack_begin := false ;
14775: LD_ADDR_LOC 32
14779: PUSH
14780: LD_INT 0
14782: ST_TO_ADDR
// max := 0 + attack_forces ;
14783: LD_ADDR_VAR 0 3
14787: PUSH
14788: LD_INT 0
14790: PUSH
14791: LD_EXP 55
14795: PLUS
14796: ST_TO_ADDR
// destroy_now := [ ] ;
14797: LD_ADDR_LOC 27
14801: PUSH
14802: EMPTY
14803: ST_TO_ADDR
// if cislo_utoku > 1 then
14804: LD_LOC 33
14808: PUSH
14809: LD_INT 1
14811: GREATER
14812: IFFALSE 14826
// now_area := navrhni_startovni_pozici else
14814: LD_ADDR_LOC 34
14818: PUSH
14819: CALL 13506 0 0
14823: ST_TO_ADDR
14824: GO 14834
// now_area := 1 ;
14826: LD_ADDR_LOC 34
14830: PUSH
14831: LD_INT 1
14833: ST_TO_ADDR
// case now_area of 1 :
14834: LD_LOC 34
14838: PUSH
14839: LD_INT 1
14841: DOUBLE
14842: EQUAL
14843: IFTRUE 14847
14845: GO 14854
14847: POP
// goto_north_sector ; 9 :
14848: CALL 12838 0 0
14852: GO 14885
14854: LD_INT 9
14856: DOUBLE
14857: EQUAL
14858: IFTRUE 14862
14860: GO 14869
14862: POP
// goto_east_sector ; 5 :
14863: CALL 12924 0 0
14867: GO 14885
14869: LD_INT 5
14871: DOUBLE
14872: EQUAL
14873: IFTRUE 14877
14875: GO 14884
14877: POP
// goto_south_sector ; end ;
14878: CALL 13009 0 0
14882: GO 14885
14884: POP
// repeat wait ( 0 0$1 ) ;
14885: LD_INT 35
14887: PPUSH
14888: CALL_OW 67
// until attack_begin ;
14892: LD_LOC 32
14896: IFFALSE 14885
// mc_id := 0 ;
14898: LD_ADDR_VAR 0 5
14902: PUSH
14903: LD_INT 0
14905: ST_TO_ADDR
// repeat next_area := zjisti_schudne_okoli ( now_area ) ;
14906: LD_ADDR_LOC 35
14910: PUSH
14911: LD_LOC 34
14915: PPUSH
14916: CALL 13094 0 1
14920: ST_TO_ADDR
// new_destination := zjisti_cilove_misto ( next_area ) ;
14921: LD_ADDR_VAR 0 6
14925: PUSH
14926: LD_LOC 35
14930: PPUSH
14931: CALL 12326 0 1
14935: ST_TO_ADDR
// repeat if see_important ( now_area ) then
14936: LD_LOC 34
14940: PPUSH
14941: CALL 13796 0 1
14945: IFFALSE 14986
// begin if ExistMc ( mc_id ) then
14947: LD_VAR 0 5
14951: PPUSH
14952: CALL_OW 386
14956: IFFALSE 14975
// begin KillMc ( mc_id ) ;
14958: LD_VAR 0 5
14962: PPUSH
14963: CALL_OW 387
// mc_id := 0 ;
14967: LD_ADDR_VAR 0 5
14971: PUSH
14972: LD_INT 0
14974: ST_TO_ADDR
// end ; destroy_important ( now_area ) ;
14975: LD_LOC 34
14979: PPUSH
14980: CALL 14154 0 1
// end else
14984: GO 15043
// if not ExistMc ( mc_id ) then
14986: LD_VAR 0 5
14990: PPUSH
14991: CALL_OW 386
14995: NOT
14996: IFFALSE 15043
// mc_id := McMove ( 2 , attack_forces , [ [ new_destination [ 1 ] , new_destination [ 2 ] ] ] , [ ] ) ;
14998: LD_ADDR_VAR 0 5
15002: PUSH
15003: LD_INT 2
15005: PPUSH
15006: LD_EXP 55
15010: PPUSH
15011: LD_VAR 0 6
15015: PUSH
15016: LD_INT 1
15018: ARRAY
15019: PUSH
15020: LD_VAR 0 6
15024: PUSH
15025: LD_INT 2
15027: ARRAY
15028: PUSH
15029: EMPTY
15030: LIST
15031: LIST
15032: PUSH
15033: EMPTY
15034: LIST
15035: PPUSH
15036: EMPTY
15037: PPUSH
15038: CALL_OW 398
15042: ST_TO_ADDR
// wait ( 0 0$3 ) ;
15043: LD_INT 105
15045: PPUSH
15046: CALL_OW 67
// until vsichni_v_arei ( a_jmeno ( next_area ) ) or ( not attack_forces ) ;
15050: LD_LOC 35
15054: PPUSH
15055: CALL 12585 0 1
15059: PPUSH
15060: CALL 13708 0 1
15064: PUSH
15065: LD_EXP 55
15069: NOT
15070: OR
15071: IFFALSE 14936
// now_area := next_area ;
15073: LD_ADDR_LOC 34
15077: PUSH
15078: LD_LOC 35
15082: ST_TO_ADDR
// until not attack_forces ;
15083: LD_EXP 55
15087: NOT
15088: IFFALSE 14906
// konec_jednoho_utoku ;
15090: CALL 14666 0 0
// cislo_utoku := cislo_utoku + 1 ;
15094: LD_ADDR_LOC 33
15098: PUSH
15099: LD_LOC 33
15103: PUSH
15104: LD_INT 1
15106: PLUS
15107: ST_TO_ADDR
// end ;
15108: LD_VAR 0 1
15112: RET
// function nacti_important_budovy ; var list_important , un ; begin
15113: LD_INT 0
15115: PPUSH
15116: PPUSH
15117: PPUSH
// us_important := [ ] ;
15118: LD_ADDR_EXP 65
15122: PUSH
15123: EMPTY
15124: ST_TO_ADDR
// list_important := FilterAllUnits ( [ [ f_or , [ f_side , you ] , [ f_side , neutral ] ] , [ f_type , unit_building ] ] ) ;
15125: LD_ADDR_VAR 0 2
15129: PUSH
15130: LD_INT 2
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_EXP 14
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 22
15147: PUSH
15148: LD_EXP 16
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: PUSH
15157: EMPTY
15158: LIST
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 21
15164: PUSH
15165: LD_INT 3
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PPUSH
15176: CALL_OW 69
15180: ST_TO_ADDR
// important := [ b_depot , b_warehouse , b_factory , b_armoury , b_barracks , b_lab_full , b_oil_power , b_solar_power , b_siberite_power , b_oil_mine , b_siberite_mine , b_breastwork , b_bunker , b_turret ] ;
15181: LD_ADDR_LOC 28
15185: PUSH
15186: LD_INT 0
15188: PUSH
15189: LD_INT 1
15191: PUSH
15192: LD_INT 3
15194: PUSH
15195: LD_INT 4
15197: PUSH
15198: LD_INT 5
15200: PUSH
15201: LD_INT 8
15203: PUSH
15204: LD_INT 26
15206: PUSH
15207: LD_INT 27
15209: PUSH
15210: LD_INT 28
15212: PUSH
15213: LD_INT 29
15215: PUSH
15216: LD_INT 30
15218: PUSH
15219: LD_INT 31
15221: PUSH
15222: LD_INT 32
15224: PUSH
15225: LD_INT 33
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: ST_TO_ADDR
// for un in list_important do
15244: LD_ADDR_VAR 0 3
15248: PUSH
15249: LD_VAR 0 2
15253: PUSH
15254: FOR_IN
15255: IFFALSE 15292
// begin if GetBType ( un ) in important then
15257: LD_VAR 0 3
15261: PPUSH
15262: CALL_OW 266
15266: PUSH
15267: LD_LOC 28
15271: IN
15272: IFFALSE 15290
// us_important := us_important ^ un ;
15274: LD_ADDR_EXP 65
15278: PUSH
15279: LD_EXP 65
15283: PUSH
15284: LD_VAR 0 3
15288: ADD
15289: ST_TO_ADDR
// end ;
15290: GO 15254
15292: POP
15293: POP
// end ;
15294: LD_VAR 0 1
15298: RET
// on UnitGoesToRed ( jednotka ) do begin event_unit := jednotka ;
15299: LD_ADDR_LOC 36
15303: PUSH
15304: LD_VAR 0 1
15308: ST_TO_ADDR
// if jednotka in attack_forces then
15309: LD_VAR 0 1
15313: PUSH
15314: LD_EXP 55
15318: IN
15319: IFFALSE 15357
// begin attack_forces := attack_forces diff [ jednotka ] ;
15321: LD_ADDR_EXP 55
15325: PUSH
15326: LD_EXP 55
15330: PUSH
15331: LD_VAR 0 1
15335: PUSH
15336: EMPTY
15337: LIST
15338: DIFF
15339: ST_TO_ADDR
// if ( not attack_forces ) and ( attack_begin ) then
15340: LD_EXP 55
15344: NOT
15345: PUSH
15346: LD_LOC 32
15350: AND
15351: IFFALSE 15357
// konec_jednoho_utoku ;
15353: CALL 14666 0 0
// end ; if ( ( jednotka = MacMillan ) and ( not IsOK ( survivor ) ) ) or ( ( jednotka = MacMillan ) and ( not visit_base ) ) then
15357: LD_VAR 0 1
15361: PUSH
15362: LD_EXP 1
15366: EQUAL
15367: PUSH
15368: LD_EXP 6
15372: PPUSH
15373: CALL_OW 302
15377: NOT
15378: AND
15379: PUSH
15380: LD_VAR 0 1
15384: PUSH
15385: LD_EXP 1
15389: EQUAL
15390: PUSH
15391: LD_EXP 34
15395: NOT
15396: AND
15397: OR
15398: IFFALSE 15404
// konec_mise ;
15400: CALL 755 0 0
// end ;
15404: PPOPN 1
15406: END
// on UnitDestroyed ( jednotka ) do var pomocna_mnozina ;
15407: LD_INT 0
15409: PPUSH
// begin event_unit := jednotka ;
15410: LD_ADDR_LOC 36
15414: PUSH
15415: LD_VAR 0 1
15419: ST_TO_ADDR
// attack_forces := attack_forces diff [ jednotka ] ;
15420: LD_ADDR_EXP 55
15424: PUSH
15425: LD_EXP 55
15429: PUSH
15430: LD_VAR 0 1
15434: PUSH
15435: EMPTY
15436: LIST
15437: DIFF
15438: ST_TO_ADDR
// us_important := us_important diff [ jednotka ] ;
15439: LD_ADDR_EXP 65
15443: PUSH
15444: LD_EXP 65
15448: PUSH
15449: LD_VAR 0 1
15453: PUSH
15454: EMPTY
15455: LIST
15456: DIFF
15457: ST_TO_ADDR
// destroy_now := destroy_now diff [ jednotka ] ;
15458: LD_ADDR_LOC 27
15462: PUSH
15463: LD_LOC 27
15467: PUSH
15468: LD_VAR 0 1
15472: PUSH
15473: EMPTY
15474: LIST
15475: DIFF
15476: ST_TO_ADDR
// case now_area of 1 :
15477: LD_LOC 34
15481: PUSH
15482: LD_INT 1
15484: DOUBLE
15485: EQUAL
15486: IFTRUE 15490
15488: GO 15512
15490: POP
// klic_area_1 := klic_area_1 diff [ jednotka ] ; 2 :
15491: LD_ADDR_LOC 18
15495: PUSH
15496: LD_LOC 18
15500: PUSH
15501: LD_VAR 0 1
15505: PUSH
15506: EMPTY
15507: LIST
15508: DIFF
15509: ST_TO_ADDR
15510: GO 15753
15512: LD_INT 2
15514: DOUBLE
15515: EQUAL
15516: IFTRUE 15520
15518: GO 15542
15520: POP
// klic_area_2 := klic_area_2 diff [ jednotka ] ; 3 :
15521: LD_ADDR_LOC 19
15525: PUSH
15526: LD_LOC 19
15530: PUSH
15531: LD_VAR 0 1
15535: PUSH
15536: EMPTY
15537: LIST
15538: DIFF
15539: ST_TO_ADDR
15540: GO 15753
15542: LD_INT 3
15544: DOUBLE
15545: EQUAL
15546: IFTRUE 15550
15548: GO 15572
15550: POP
// klic_area_3 := klic_area_3 diff [ jednotka ] ; 4 :
15551: LD_ADDR_LOC 20
15555: PUSH
15556: LD_LOC 20
15560: PUSH
15561: LD_VAR 0 1
15565: PUSH
15566: EMPTY
15567: LIST
15568: DIFF
15569: ST_TO_ADDR
15570: GO 15753
15572: LD_INT 4
15574: DOUBLE
15575: EQUAL
15576: IFTRUE 15580
15578: GO 15602
15580: POP
// klic_area_4 := klic_area_4 diff [ jednotka ] ; 5 :
15581: LD_ADDR_LOC 21
15585: PUSH
15586: LD_LOC 21
15590: PUSH
15591: LD_VAR 0 1
15595: PUSH
15596: EMPTY
15597: LIST
15598: DIFF
15599: ST_TO_ADDR
15600: GO 15753
15602: LD_INT 5
15604: DOUBLE
15605: EQUAL
15606: IFTRUE 15610
15608: GO 15632
15610: POP
// klic_area_5 := klic_area_5 diff [ jednotka ] ; 6 :
15611: LD_ADDR_LOC 22
15615: PUSH
15616: LD_LOC 22
15620: PUSH
15621: LD_VAR 0 1
15625: PUSH
15626: EMPTY
15627: LIST
15628: DIFF
15629: ST_TO_ADDR
15630: GO 15753
15632: LD_INT 6
15634: DOUBLE
15635: EQUAL
15636: IFTRUE 15640
15638: GO 15662
15640: POP
// klic_area_6 := klic_area_6 diff [ jednotka ] ; 7 :
15641: LD_ADDR_LOC 23
15645: PUSH
15646: LD_LOC 23
15650: PUSH
15651: LD_VAR 0 1
15655: PUSH
15656: EMPTY
15657: LIST
15658: DIFF
15659: ST_TO_ADDR
15660: GO 15753
15662: LD_INT 7
15664: DOUBLE
15665: EQUAL
15666: IFTRUE 15670
15668: GO 15692
15670: POP
// klic_area_7 := klic_area_7 diff [ jednotka ] ; 8 :
15671: LD_ADDR_LOC 24
15675: PUSH
15676: LD_LOC 24
15680: PUSH
15681: LD_VAR 0 1
15685: PUSH
15686: EMPTY
15687: LIST
15688: DIFF
15689: ST_TO_ADDR
15690: GO 15753
15692: LD_INT 8
15694: DOUBLE
15695: EQUAL
15696: IFTRUE 15700
15698: GO 15722
15700: POP
// klic_area_8 := klic_area_8 diff [ jednotka ] ; 9 :
15701: LD_ADDR_LOC 25
15705: PUSH
15706: LD_LOC 25
15710: PUSH
15711: LD_VAR 0 1
15715: PUSH
15716: EMPTY
15717: LIST
15718: DIFF
15719: ST_TO_ADDR
15720: GO 15753
15722: LD_INT 9
15724: DOUBLE
15725: EQUAL
15726: IFTRUE 15730
15728: GO 15752
15730: POP
// klic_area_9 := klic_area_9 diff [ jednotka ] ; end ;
15731: LD_ADDR_LOC 26
15735: PUSH
15736: LD_LOC 26
15740: PUSH
15741: LD_VAR 0 1
15745: PUSH
15746: EMPTY
15747: LIST
15748: DIFF
15749: ST_TO_ADDR
15750: GO 15753
15752: POP
// if jednotka = macmillan then
15753: LD_VAR 0 1
15757: PUSH
15758: LD_EXP 1
15762: EQUAL
15763: IFFALSE 15769
// konec_mise ;
15765: CALL 755 0 0
// if ( not attack_forces ) and ( attack_begin ) then
15769: LD_EXP 55
15773: NOT
15774: PUSH
15775: LD_LOC 32
15779: AND
15780: IFFALSE 15786
// konec_jednoho_utoku ;
15782: CALL 14666 0 0
// if GetSide ( jednotka ) = russians then
15786: LD_VAR 0 1
15790: PPUSH
15791: CALL_OW 255
15795: PUSH
15796: LD_EXP 15
15800: EQUAL
15801: IFFALSE 15890
// begin russians_forces := russians_forces diff jednotka ;
15803: LD_ADDR_EXP 28
15807: PUSH
15808: LD_EXP 28
15812: PUSH
15813: LD_VAR 0 1
15817: DIFF
15818: ST_TO_ADDR
// ru_ing := ru_ing diff jednotka ;
15819: LD_ADDR_EXP 24
15823: PUSH
15824: LD_EXP 24
15828: PUSH
15829: LD_VAR 0 1
15833: DIFF
15834: ST_TO_ADDR
// ru_sol := ru_sol diff jednotka ;
15835: LD_ADDR_EXP 25
15839: PUSH
15840: LD_EXP 25
15844: PUSH
15845: LD_VAR 0 1
15849: DIFF
15850: ST_TO_ADDR
// ru_sci := ru_sci diff jednotka ;
15851: LD_ADDR_EXP 26
15855: PUSH
15856: LD_EXP 26
15860: PUSH
15861: LD_VAR 0 1
15865: DIFF
15866: ST_TO_ADDR
// ru_mec := ru_mec diff jednotka ;
15867: LD_ADDR_EXP 27
15871: PUSH
15872: LD_EXP 27
15876: PUSH
15877: LD_VAR 0 1
15881: DIFF
15882: ST_TO_ADDR
// reserved_people := [ ] ;
15883: LD_ADDR_EXP 31
15887: PUSH
15888: EMPTY
15889: ST_TO_ADDR
// end ; end ;
15890: PPOPN 2
15892: END
// on VehicleCaptured ( veh_new , veh_old , veh_orig , veh_hum ) do begin if GetSide ( veh_old ) = russians then
15893: LD_VAR 0 2
15897: PPUSH
15898: CALL_OW 255
15902: PUSH
15903: LD_EXP 15
15907: EQUAL
15908: IFFALSE 15948
// begin war_forces := war_forces diff [ veh_old ] ;
15910: LD_ADDR_EXP 52
15914: PUSH
15915: LD_EXP 52
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: EMPTY
15926: LIST
15927: DIFF
15928: ST_TO_ADDR
// attack_forces := attack_forces diff [ veh_old ] ;
15929: LD_ADDR_EXP 55
15933: PUSH
15934: LD_EXP 55
15938: PUSH
15939: LD_VAR 0 2
15943: PUSH
15944: EMPTY
15945: LIST
15946: DIFF
15947: ST_TO_ADDR
// end ; if ( not attack_forces ) and ( attack_begin ) then
15948: LD_EXP 55
15952: NOT
15953: PUSH
15954: LD_LOC 32
15958: AND
15959: IFFALSE 15965
// konec_jednoho_utoku ;
15961: CALL 14666 0 0
// end ;
15965: PPOPN 4
15967: END
// on BuildingComplete ( jednotka ) do begin if GetBType ( jednotka ) in important then
15968: LD_VAR 0 1
15972: PPUSH
15973: CALL_OW 266
15977: PUSH
15978: LD_LOC 28
15982: IN
15983: IFFALSE 16001
// us_important := us_important ^ jednotka ;
15985: LD_ADDR_EXP 65
15989: PUSH
15990: LD_EXP 65
15994: PUSH
15995: LD_VAR 0 1
15999: ADD
16000: ST_TO_ADDR
// end ;
16001: PPOPN 1
16003: END
// function multi_cesta ; begin
16004: LD_INT 0
16006: PPUSH
// multi := true ;
16007: LD_ADDR_LOC 29
16011: PUSH
16012: LD_INT 1
16014: ST_TO_ADDR
// end ;
16015: LD_VAR 0 1
16019: RET
// every 0 0$45 trigger ( war_forces >= war_count ) and ( not attack_begin ) do var list , un ;
16020: LD_EXP 52
16024: PUSH
16025: LD_EXP 54
16029: GREATEREQUAL
16030: PUSH
16031: LD_LOC 32
16035: NOT
16036: AND
16037: IFFALSE 16145
16039: GO 16041
16041: DISABLE
16042: LD_INT 0
16044: PPUSH
16045: PPUSH
// begin list := [ ] ;
16046: LD_ADDR_VAR 0 1
16050: PUSH
16051: EMPTY
16052: ST_TO_ADDR
// for un in war_forces do
16053: LD_ADDR_VAR 0 2
16057: PUSH
16058: LD_EXP 52
16062: PUSH
16063: FOR_IN
16064: IFFALSE 16096
// if un in defend_forces then
16066: LD_VAR 0 2
16070: PUSH
16071: LD_EXP 64
16075: IN
16076: IFFALSE 16094
// list := list ^ un ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_VAR 0 1
16087: PUSH
16088: LD_VAR 0 2
16092: ADD
16093: ST_TO_ADDR
16094: GO 16063
16096: POP
16097: POP
// if ( war_forces diff list ) < war_count then
16098: LD_EXP 52
16102: PUSH
16103: LD_VAR 0 1
16107: DIFF
16108: PUSH
16109: LD_EXP 54
16113: LESS
16114: IFFALSE 16119
// begin enable ;
16116: ENABLE
// exit ;
16117: GO 16145
// end ; attack_forces := war_forces ;
16119: LD_ADDR_EXP 55
16123: PUSH
16124: LD_EXP 52
16128: ST_TO_ADDR
// war_forces := [ ] ;
16129: LD_ADDR_EXP 52
16133: PUSH
16134: EMPTY
16135: ST_TO_ADDR
// nacti_important_budovy ;
16136: CALL 15113 0 0
// low_cesta ;
16140: CALL 14759 0 0
// enable ;
16144: ENABLE
// end ;
16145: PPOPN 2
16147: END
// every 0 0$5 trigger attack_forces > 0 do var un , puvodni_velikost ;
16148: LD_EXP 55
16152: PUSH
16153: LD_INT 0
16155: GREATER
16156: IFFALSE 16247
16158: GO 16160
16160: DISABLE
16161: LD_INT 0
16163: PPUSH
16164: PPUSH
// begin puvodni_velikost := 0 + attack_forces ;
16165: LD_ADDR_VAR 0 2
16169: PUSH
16170: LD_INT 0
16172: PUSH
16173: LD_EXP 55
16177: PLUS
16178: ST_TO_ADDR
// for un in attack_forces do
16179: LD_ADDR_VAR 0 1
16183: PUSH
16184: LD_EXP 55
16188: PUSH
16189: FOR_IN
16190: IFFALSE 16222
// if not IsOK ( un ) then
16192: LD_VAR 0 1
16196: PPUSH
16197: CALL_OW 302
16201: NOT
16202: IFFALSE 16220
// attack_forces := attack_forces diff un ;
16204: LD_ADDR_EXP 55
16208: PUSH
16209: LD_EXP 55
16213: PUSH
16214: LD_VAR 0 1
16218: DIFF
16219: ST_TO_ADDR
16220: GO 16189
16222: POP
16223: POP
// if ( attack_forces = [ ] ) and ( puvodni_velikost > 0 ) then
16224: LD_EXP 55
16228: PUSH
16229: EMPTY
16230: EQUAL
16231: PUSH
16232: LD_VAR 0 2
16236: PUSH
16237: LD_INT 0
16239: GREATER
16240: AND
16241: IFFALSE 16247
// konec_jednoho_utoku ;
16243: CALL 14666 0 0
// end ; end_of_file
16247: PPOPN 2
16249: END
// var id_reg , id_def ; function prepare_defend ( side ) ; var def_u ; begin
16250: LD_INT 0
16252: PPUSH
16253: PPUSH
// def_u := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_building ] , [ f_btype , b_turret ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_type , unit_vehicle ] ] ] ) ;
16254: LD_ADDR_VAR 0 3
16258: PUSH
16259: LD_INT 22
16261: PUSH
16262: LD_VAR 0 1
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PUSH
16271: LD_INT 2
16273: PUSH
16274: LD_INT 21
16276: PUSH
16277: LD_INT 3
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: LD_INT 30
16286: PUSH
16287: LD_INT 33
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: LD_INT 30
16296: PUSH
16297: LD_INT 32
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PUSH
16304: LD_INT 30
16306: PUSH
16307: LD_INT 31
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: PUSH
16314: EMPTY
16315: LIST
16316: LIST
16317: LIST
16318: LIST
16319: PUSH
16320: LD_INT 21
16322: PUSH
16323: LD_INT 2
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: LIST
16334: PUSH
16335: EMPTY
16336: LIST
16337: LIST
16338: PPUSH
16339: CALL_OW 69
16343: ST_TO_ADDR
// def_u := def_u union ru_sol ;
16344: LD_ADDR_VAR 0 3
16348: PUSH
16349: LD_VAR 0 3
16353: PUSH
16354: LD_EXP 25
16358: UNION
16359: ST_TO_ADDR
// def_u := def_u diff reserved_people ;
16360: LD_ADDR_VAR 0 3
16364: PUSH
16365: LD_VAR 0 3
16369: PUSH
16370: LD_EXP 31
16374: DIFF
16375: ST_TO_ADDR
// def_u := def_u diff ru_collector ;
16376: LD_ADDR_VAR 0 3
16380: PUSH
16381: LD_VAR 0 3
16385: PUSH
16386: LD_EXP 29
16390: DIFF
16391: ST_TO_ADDR
// def_u := ( def_u union war_forces ) union backup_forces ;
16392: LD_ADDR_VAR 0 3
16396: PUSH
16397: LD_VAR 0 3
16401: PUSH
16402: LD_EXP 52
16406: UNION
16407: PUSH
16408: LD_EXP 56
16412: UNION
16413: ST_TO_ADDR
// def_u := def_u union manual_forces ;
16414: LD_ADDR_VAR 0 3
16418: PUSH
16419: LD_VAR 0 3
16423: PUSH
16424: LD_EXP 59
16428: UNION
16429: ST_TO_ADDR
// result := def_u ;
16430: LD_ADDR_VAR 0 2
16434: PUSH
16435: LD_VAR 0 3
16439: ST_TO_ADDR
// end ;
16440: LD_VAR 0 2
16444: RET
// export function start_defend ; var side ; begin
16445: LD_INT 0
16447: PPUSH
16448: PPUSH
// id_reg := McRegistry ( 3 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , ru_defend ] , [ mc_reg_area_to_protect , ru_defend ] , [ mc_reg_units_to_protect , prepare_defend ( russians ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
16449: LD_ADDR_LOC 37
16453: PUSH
16454: LD_INT 3
16456: PPUSH
16457: LD_INT 1
16459: PUSH
16460: LD_INT 35
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PUSH
16467: LD_INT 5
16469: PUSH
16470: LD_INT 140
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: PUSH
16477: LD_INT 2
16479: PUSH
16480: LD_INT 27
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: PUSH
16487: LD_INT 3
16489: PUSH
16490: LD_INT 27
16492: PUSH
16493: EMPTY
16494: LIST
16495: LIST
16496: PUSH
16497: LD_INT 4
16499: PUSH
16500: LD_EXP 15
16504: PPUSH
16505: CALL 16250 0 1
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: LD_INT 8
16516: PUSH
16517: LD_INT 7
16519: NEG
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: PPUSH
16530: CALL_OW 399
16534: ST_TO_ADDR
// id_def := McDefend ( 100 , id_reg , prepare_defend ( russians ) , [ [ mc_def_advantage , 500 ] , [ mc_area_dont_leave , ru_base ] , [ mc_retreat_area_people , ru_heal ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
16535: LD_ADDR_LOC 38
16539: PUSH
16540: LD_INT 100
16542: PPUSH
16543: LD_LOC 37
16547: PPUSH
16548: LD_EXP 15
16552: PPUSH
16553: CALL 16250 0 1
16557: PPUSH
16558: LD_INT 1
16560: PUSH
16561: LD_INT 500
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 2
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: LD_INT 7
16580: PUSH
16581: LD_INT 28
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PUSH
16588: LD_INT 5
16590: PUSH
16591: LD_INT 600
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: LIST
16602: LIST
16603: PPUSH
16604: CALL_OW 401
16608: ST_TO_ADDR
// end ;
16609: LD_VAR 0 1
16613: RET
// on McRegistryResultChanges ( mcid , n , s ) do begin if n then
16614: LD_VAR 0 2
16618: IFFALSE 16643
// begin AddMcUnits ( mcid , prepare_defend ( russians ) ) ;
16620: LD_VAR 0 1
16624: PPUSH
16625: LD_EXP 15
16629: PPUSH
16630: CALL 16250 0 1
16634: PPUSH
16635: CALL_OW 390
// SendForces ;
16639: CALL 16889 0 0
// end ; end ;
16643: PPOPN 3
16645: END
// every 0 0$5 do var side , sci , list ;
16646: GO 16648
16648: DISABLE
16649: LD_INT 0
16651: PPUSH
16652: PPUSH
16653: PPUSH
// begin list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 950 ] ] ] ) ;
16654: LD_ADDR_VAR 0 3
16658: PUSH
16659: LD_INT 28
16661: PPUSH
16662: LD_INT 22
16664: PUSH
16665: LD_EXP 15
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 21
16676: PUSH
16677: LD_INT 1
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: LD_INT 3
16686: PUSH
16687: LD_INT 24
16689: PUSH
16690: LD_INT 950
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: LIST
16705: PPUSH
16706: CALL_OW 70
16710: ST_TO_ADDR
// if list then
16711: LD_VAR 0 3
16715: IFFALSE 16885
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
16717: LD_ADDR_VAR 0 2
16721: PUSH
16722: LD_INT 22
16724: PUSH
16725: LD_EXP 15
16729: PUSH
16730: EMPTY
16731: LIST
16732: LIST
16733: PUSH
16734: LD_INT 25
16736: PUSH
16737: LD_INT 4
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PPUSH
16748: CALL_OW 69
16752: ST_TO_ADDR
// ComRemember ( sci ) ;
16753: LD_VAR 0 2
16757: PPUSH
16758: CALL_OW 143
// wait ( 5 ) ;
16762: LD_INT 5
16764: PPUSH
16765: CALL_OW 67
// ComMoveToArea ( sci , ru_heal ) ;
16769: LD_VAR 0 2
16773: PPUSH
16774: LD_INT 28
16776: PPUSH
16777: CALL_OW 113
// repeat list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
16781: LD_ADDR_VAR 0 3
16785: PUSH
16786: LD_INT 28
16788: PPUSH
16789: LD_INT 22
16791: PUSH
16792: LD_EXP 15
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 21
16803: PUSH
16804: LD_INT 1
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: LD_INT 3
16813: PUSH
16814: LD_INT 24
16816: PUSH
16817: LD_INT 1000
16819: PUSH
16820: EMPTY
16821: LIST
16822: LIST
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 70
16837: ST_TO_ADDR
// if list then
16838: LD_VAR 0 3
16842: IFFALSE 16862
// AddComHeal ( sci , list [ 1 ] ) ;
16844: LD_VAR 0 2
16848: PPUSH
16849: LD_VAR 0 3
16853: PUSH
16854: LD_INT 1
16856: ARRAY
16857: PPUSH
16858: CALL_OW 188
// wait ( 0 0$2 ) ;
16862: LD_INT 70
16864: PPUSH
16865: CALL_OW 67
// until not list ;
16869: LD_VAR 0 3
16873: NOT
16874: IFFALSE 16781
// ComReturn ( sci ) ;
16876: LD_VAR 0 2
16880: PPUSH
16881: CALL_OW 144
// end ; enable ;
16885: ENABLE
// end ;
16886: PPOPN 3
16888: END
// function SendForces ; var list , target ; begin
16889: LD_INT 0
16891: PPUSH
16892: PPUSH
16893: PPUSH
// ComRemember ( war_forces ) ;
16894: LD_EXP 52
16898: PPUSH
16899: CALL_OW 143
// ComRemember ( backup_forces ) ;
16903: LD_EXP 56
16907: PPUSH
16908: CALL_OW 143
// repeat list := FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) ;
16912: LD_ADDR_VAR 0 2
16916: PUSH
16917: LD_INT 33
16919: PPUSH
16920: LD_INT 22
16922: PUSH
16923: LD_EXP 14
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 50
16934: PUSH
16935: EMPTY
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PPUSH
16942: CALL_OW 70
16946: ST_TO_ADDR
// defend_forces := war_forces union backup_forces ;
16947: LD_ADDR_EXP 64
16951: PUSH
16952: LD_EXP 52
16956: PUSH
16957: LD_EXP 56
16961: UNION
16962: ST_TO_ADDR
// target := NearestUnitToUnit ( list , ru_depot ) ;
16963: LD_ADDR_VAR 0 3
16967: PUSH
16968: LD_VAR 0 2
16972: PPUSH
16973: LD_INT 22
16975: PPUSH
16976: CALL_OW 74
16980: ST_TO_ADDR
// ComAttackPlace ( defend_forces , GetX ( target ) , GetY ( target ) ) ;
16981: LD_EXP 64
16985: PPUSH
16986: LD_VAR 0 3
16990: PPUSH
16991: CALL_OW 250
16995: PPUSH
16996: LD_VAR 0 3
17000: PPUSH
17001: CALL_OW 251
17005: PPUSH
17006: CALL_OW 116
// wait ( 50 ) ;
17010: LD_INT 50
17012: PPUSH
17013: CALL_OW 67
// until not list ;
17017: LD_VAR 0 2
17021: NOT
17022: IFFALSE 16912
// ComReturn ( war_forces ) ;
17024: LD_EXP 52
17028: PPUSH
17029: CALL_OW 144
// ComReturn ( backup_forces ) ;
17033: LD_EXP 56
17037: PPUSH
17038: CALL_OW 144
// end ; end_of_file
17042: LD_VAR 0 1
17046: RET
// var b_list ; export function init_keep_base ; var un , list ; begin
17047: LD_INT 0
17049: PPUSH
17050: PPUSH
17051: PPUSH
// b_list := [ ] ;
17052: LD_ADDR_LOC 39
17056: PUSH
17057: EMPTY
17058: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_building ] ] ) ;
17059: LD_ADDR_VAR 0 2
17063: PUSH
17064: LD_INT 22
17066: PUSH
17067: LD_EXP 15
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 21
17078: PUSH
17079: LD_INT 3
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: ST_TO_ADDR
// if un then
17095: LD_VAR 0 2
17099: IFFALSE 17125
// b_list := GetBuildList ( GetBase ( un [ 1 ] ) ) ;
17101: LD_ADDR_LOC 39
17105: PUSH
17106: LD_VAR 0 2
17110: PUSH
17111: LD_INT 1
17113: ARRAY
17114: PPUSH
17115: CALL_OW 274
17119: PPUSH
17120: CALL_OW 417
17124: ST_TO_ADDR
// enable ( 2 ) ;
17125: LD_INT 2
17127: ENABLE_MARKED
// end ;
17128: LD_VAR 0 1
17132: RET
// every 0 0$3 trigger FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) marked 2 do var engineers ;
17133: LD_INT 33
17135: PPUSH
17136: LD_INT 22
17138: PUSH
17139: LD_EXP 14
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: PUSH
17148: LD_INT 50
17150: PUSH
17151: EMPTY
17152: LIST
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PPUSH
17158: CALL_OW 70
17162: IFFALSE 17247
17164: GO 17166
17166: DISABLE
17167: LD_INT 0
17169: PPUSH
// begin engineers := ru_ing ;
17170: LD_ADDR_VAR 0 1
17174: PUSH
17175: LD_EXP 24
17179: ST_TO_ADDR
// if not engineers then
17180: LD_VAR 0 1
17184: NOT
17185: IFFALSE 17197
// engineers := ru_sol ;
17187: LD_ADDR_VAR 0 1
17191: PUSH
17192: LD_EXP 25
17196: ST_TO_ADDR
// ComRemember ( engineers ) ;
17197: LD_VAR 0 1
17201: PPUSH
17202: CALL_OW 143
// WaitForMc ( McBase ( 3 , engineers , b_list , 0 , 0 , 0 ) ) ;
17206: LD_INT 3
17208: PPUSH
17209: LD_VAR 0 1
17213: PPUSH
17214: LD_LOC 39
17218: PPUSH
17219: LD_INT 0
17221: PPUSH
17222: LD_INT 0
17224: PPUSH
17225: LD_INT 0
17227: PPUSH
17228: CALL_OW 397
17232: PPUSH
17233: CALL_OW 385
// ComReturn ( engineers ) ;
17237: LD_VAR 0 1
17241: PPUSH
17242: CALL_OW 144
// enable ;
17246: ENABLE
// end ; end_of_file
17247: PPOPN 1
17249: END
// every 0 0$2 + 0 0$0.1 do
17250: GO 17252
17252: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17253: LD_INT 22
17255: PUSH
17256: LD_INT 1
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: PUSH
17263: LD_INT 2
17265: PUSH
17266: LD_INT 25
17268: PUSH
17269: LD_INT 12
17271: PUSH
17272: EMPTY
17273: LIST
17274: LIST
17275: PUSH
17276: LD_INT 25
17278: PUSH
17279: LD_INT 16
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: PUSH
17286: LD_INT 25
17288: PUSH
17289: LD_INT 15
17291: PUSH
17292: EMPTY
17293: LIST
17294: LIST
17295: PUSH
17296: LD_INT 25
17298: PUSH
17299: LD_INT 17
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: LIST
17310: LIST
17311: LIST
17312: PUSH
17313: EMPTY
17314: LIST
17315: LIST
17316: PPUSH
17317: CALL_OW 69
17321: PUSH
17322: LD_INT 22
17324: PUSH
17325: LD_INT 1
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PUSH
17332: LD_INT 21
17334: PUSH
17335: LD_INT 1
17337: PUSH
17338: EMPTY
17339: LIST
17340: LIST
17341: PUSH
17342: LD_INT 3
17344: PUSH
17345: LD_INT 2
17347: PUSH
17348: LD_INT 25
17350: PUSH
17351: LD_INT 12
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: LD_INT 25
17360: PUSH
17361: LD_INT 16
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: PUSH
17368: LD_INT 25
17370: PUSH
17371: LD_INT 15
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PUSH
17378: LD_INT 25
17380: PUSH
17381: LD_INT 17
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: PUSH
17388: EMPTY
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: PUSH
17399: EMPTY
17400: LIST
17401: LIST
17402: LIST
17403: PPUSH
17404: CALL_OW 69
17408: GREATER
17409: IFFALSE 17420
// begin SetAchievement ( ACH_POTA ) ;
17411: LD_STRING ACH_POTA
17413: PPUSH
17414: CALL_OW 543
// exit ;
17418: GO 17421
// end ; enable ;
17420: ENABLE
// end ; end_of_file
17421: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
17422: LD_INT 0
17424: PPUSH
17425: PPUSH
// if not missionNumber then
17426: LD_VAR 0 2
17430: NOT
17431: IFFALSE 17435
// exit ;
17433: GO 17555
// achiv := false ;
17435: LD_ADDR_VAR 0 7
17439: PUSH
17440: LD_INT 0
17442: ST_TO_ADDR
// case campaignNumber of 1 :
17443: LD_VAR 0 1
17447: PUSH
17448: LD_INT 1
17450: DOUBLE
17451: EQUAL
17452: IFTRUE 17456
17454: GO 17467
17456: POP
// achiv := ACH_GOTA ; 2 :
17457: LD_ADDR_VAR 0 7
17461: PUSH
17462: LD_STRING ACH_GOTA
17464: ST_TO_ADDR
17465: GO 17517
17467: LD_INT 2
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17478
17475: POP
// ; 3 :
17476: GO 17517
17478: LD_INT 3
17480: DOUBLE
17481: EQUAL
17482: IFTRUE 17486
17484: GO 17497
17486: POP
// achiv := ACH_MOTSU ; 4 :
17487: LD_ADDR_VAR 0 7
17491: PUSH
17492: LD_STRING ACH_MOTSU
17494: ST_TO_ADDR
17495: GO 17517
17497: LD_INT 4
17499: DOUBLE
17500: EQUAL
17501: IFTRUE 17505
17503: GO 17516
17505: POP
// achiv := ACH_LOP ; end ;
17506: LD_ADDR_VAR 0 7
17510: PUSH
17511: LD_STRING ACH_LOP
17513: ST_TO_ADDR
17514: GO 17517
17516: POP
// if achiv and medal1 and medal2 and medal3 then
17517: LD_VAR 0 7
17521: PUSH
17522: LD_VAR 0 3
17526: AND
17527: PUSH
17528: LD_VAR 0 4
17532: AND
17533: PUSH
17534: LD_VAR 0 5
17538: AND
17539: IFFALSE 17555
// SetAchievementEX ( achiv , missionNumber ) ;
17541: LD_VAR 0 7
17545: PPUSH
17546: LD_VAR 0 2
17550: PPUSH
17551: CALL_OW 564
// end ;
17555: LD_VAR 0 6
17559: RET

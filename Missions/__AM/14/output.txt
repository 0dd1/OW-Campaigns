// export MacMillan , Powell , Joan , Lisa , Anezka ; export survivor , who_survive ; export truck1 , ukradle_auto ; export time_crates_us , time_crates_ru ; export other_survivors ; export on_optolab ; export you , russians , neutral ; export double_laser , double_hint ; export selected_opto_lab ; export veh_jmm , veh_surv ; export fastEscape ; export kappa_saved ; var russians_eliminated , doublelasers_turrets ; function prepare_units ; var un , i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
// uc_nation := nation_american ;
   5: LD_ADDR_OWVAR 21
   9: PUSH
  10: LD_INT 1
  12: ST_TO_ADDR
// uc_side := you ;
  13: LD_ADDR_OWVAR 20
  17: PUSH
  18: LD_EXP 14
  22: ST_TO_ADDR
// hc_class := class_soldier ;
  23: LD_ADDR_OWVAR 28
  27: PUSH
  28: LD_INT 1
  30: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_STRING JMM
  38: PPUSH
  39: CALL_OW 34
  43: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_STRING Powell
  51: PPUSH
  52: CALL_OW 25
  56: ST_TO_ADDR
// uc_side := neutral ;
  57: LD_ADDR_OWVAR 20
  61: PUSH
  62: LD_EXP 16
  66: ST_TO_ADDR
// if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) then
  67: LD_STRING Joan
  69: PPUSH
  70: CALL_OW 28
  74: PUSH
  75: LD_STRING Joan
  77: PPUSH
  78: CALL_OW 29
  82: AND
  83: IFFALSE 126
// begin hc_class := class_scientistic ;
  85: LD_ADDR_OWVAR 28
  89: PUSH
  90: LD_INT 4
  92: ST_TO_ADDR
// Joan := CreateCharacter ( Joan ) ;
  93: LD_ADDR_EXP 3
  97: PUSH
  98: LD_STRING Joan
 100: PPUSH
 101: CALL_OW 34
 105: ST_TO_ADDR
// survivor := Joan ;
 106: LD_ADDR_EXP 6
 110: PUSH
 111: LD_EXP 3
 115: ST_TO_ADDR
// who_survive := 1 ;
 116: LD_ADDR_EXP 7
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// end else
 124: GO 216
// if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
 126: LD_STRING Lisa
 128: PPUSH
 129: CALL_OW 28
 133: PUSH
 134: LD_STRING Lisa
 136: PPUSH
 137: CALL_OW 29
 141: AND
 142: IFFALSE 185
// begin hc_class := class_soldier ;
 144: LD_ADDR_OWVAR 28
 148: PUSH
 149: LD_INT 1
 151: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
 152: LD_ADDR_EXP 4
 156: PUSH
 157: LD_STRING Lisa
 159: PPUSH
 160: CALL_OW 34
 164: ST_TO_ADDR
// survivor := Lisa ;
 165: LD_ADDR_EXP 6
 169: PUSH
 170: LD_EXP 4
 174: ST_TO_ADDR
// who_survive := 2 ;
 175: LD_ADDR_EXP 7
 179: PUSH
 180: LD_INT 2
 182: ST_TO_ADDR
// end else
 183: GO 216
// begin Anezka := NewCharacter ( Coonie ) ;
 185: LD_ADDR_EXP 5
 189: PUSH
 190: LD_STRING Coonie
 192: PPUSH
 193: CALL_OW 25
 197: ST_TO_ADDR
// survivor := Anezka ;
 198: LD_ADDR_EXP 6
 202: PUSH
 203: LD_EXP 5
 207: ST_TO_ADDR
// who_survive := 3 ;
 208: LD_ADDR_EXP 7
 212: PUSH
 213: LD_INT 3
 215: ST_TO_ADDR
// end ; uc_side := you ;
 216: LD_ADDR_OWVAR 20
 220: PUSH
 221: LD_EXP 14
 225: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 226: LD_STRING other_survivors
 228: PPUSH
 229: CALL_OW 28
 233: IFFALSE 250
// other_survivors := CreateCharacterSet ( other_survivors ) else
 235: LD_ADDR_EXP 12
 239: PUSH
 240: LD_STRING other_survivors
 242: PPUSH
 243: CALL_OW 31
 247: ST_TO_ADDR
 248: GO 257
// other_survivors := [ ] ;
 250: LD_ADDR_EXP 12
 254: PUSH
 255: EMPTY
 256: ST_TO_ADDR
// uc_direction := 1 ;
 257: LD_ADDR_OWVAR 24
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// vc_chassis := us_morphling ;
 265: LD_ADDR_OWVAR 37
 269: PUSH
 270: LD_INT 5
 272: ST_TO_ADDR
// vc_control := control_manual ;
 273: LD_ADDR_OWVAR 38
 277: PUSH
 278: LD_INT 1
 280: ST_TO_ADDR
// vc_engine := engine_siberite ;
 281: LD_ADDR_OWVAR 39
 285: PUSH
 286: LD_INT 3
 288: ST_TO_ADDR
// vc_weapon := us_laser ;
 289: LD_ADDR_OWVAR 40
 293: PUSH
 294: LD_INT 9
 296: ST_TO_ADDR
// truck1 := CreateVehicle ;
 297: LD_ADDR_EXP 8
 301: PUSH
 302: CALL_OW 45
 306: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
 307: LD_ADDR_OWVAR 24
 311: PUSH
 312: LD_INT 0
 314: PPUSH
 315: LD_INT 5
 317: PPUSH
 318: CALL_OW 12
 322: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 323: LD_EXP 1
 327: PPUSH
 328: LD_EXP 8
 332: PPUSH
 333: CALL_OW 52
// uc_nation = nation_russian ;
 337: LD_ADDR_OWVAR 21
 341: PUSH
 342: LD_INT 3
 344: ST_TO_ADDR
// uc_side = russians ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_EXP 15
 354: ST_TO_ADDR
// PlaceUnitXY ( truck1 , 6 , 6 , false ) ;
 355: LD_EXP 8
 359: PPUSH
 360: LD_INT 6
 362: PPUSH
 363: LD_INT 6
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 48
// PlaceUnitXY ( survivor , 65 , 108 , false ) ;
 373: LD_EXP 6
 377: PPUSH
 378: LD_INT 65
 380: PPUSH
 381: LD_INT 108
 383: PPUSH
 384: LD_INT 0
 386: PPUSH
 387: CALL_OW 48
// ComFree ( [ MacMillan , survivor ] ) ;
 391: LD_EXP 1
 395: PUSH
 396: LD_EXP 6
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PPUSH
 405: CALL_OW 139
// end ;
 409: LD_VAR 0 1
 413: RET
// function prepare_sides ; begin
 414: LD_INT 0
 416: PPUSH
// you = 1 ;
 417: LD_ADDR_EXP 14
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// neutral = 4 ;
 425: LD_ADDR_EXP 16
 429: PUSH
 430: LD_INT 4
 432: ST_TO_ADDR
// russians = 3 ;
 433: LD_ADDR_EXP 15
 437: PUSH
 438: LD_INT 3
 440: ST_TO_ADDR
// visit_base := false ;
 441: LD_ADDR_EXP 34
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// on_optolab := false ;
 449: LD_ADDR_EXP 13
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// russians_eliminated := false ;
 457: LD_ADDR_LOC 1
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// double_laser := 0 ;
 465: LD_ADDR_EXP 17
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// double_hint := false ;
 473: LD_ADDR_EXP 18
 477: PUSH
 478: LD_INT 0
 480: ST_TO_ADDR
// doublelasers_turrets := [ ] ;
 481: LD_ADDR_LOC 2
 485: PUSH
 486: EMPTY
 487: ST_TO_ADDR
// selected_opto_lab := false ;
 488: LD_ADDR_EXP 19
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
 496: LD_EXP 14
 500: PPUSH
 501: LD_EXP 15
 505: PPUSH
 506: LD_INT 2
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
 516: LD_EXP 14
 520: PPUSH
 521: LD_EXP 16
 525: PPUSH
 526: LD_INT 1
 528: PPUSH
 529: LD_INT 1
 531: PPUSH
 532: CALL_OW 80
// enable ( 1 ) ;
 536: LD_INT 1
 538: ENABLE_MARKED
// disable ( 5 ) ;
 539: LD_INT 5
 541: DISABLE_MARKED
// disable ( 11 ) ;
 542: LD_INT 11
 544: DISABLE_MARKED
// end ;
 545: LD_VAR 0 1
 549: RET
// starting begin RandomizeAll ;
 550: CALL_OW 11
// fastEscape = 0 ;
 554: LD_ADDR_EXP 22
 558: PUSH
 559: LD_INT 0
 561: ST_TO_ADDR
// prepare_sides ;
 562: CALL 414 0 0
// prepare_units ;
 566: CALL 0 0 0
// starting_scene ;
 570: CALL 5445 0 0
// prepare_ru_base ;
 574: CALL 3084 0 0
// prepare_us_base ;
 578: CALL 8212 0 0
// ru_scientistic_priority ;
 582: CALL 8802 0 0
// startup_manufacturing ;
 586: CALL 10402 0 0
// startup_war_definition ;
 590: CALL 11835 0 0
// init_keep_base ;
 594: CALL 17051 0 0
// start_defend ;
 598: CALL 16449 0 0
// time_crates_us := Rand ( 0 0$20 , 0 0$40 ) ;
 602: LD_ADDR_EXP 10
 606: PUSH
 607: LD_INT 700
 609: PPUSH
 610: LD_INT 1400
 612: PPUSH
 613: CALL_OW 12
 617: ST_TO_ADDR
// time_crates_ru := Rand ( 0 0$30 , 0 0$60 ) ;
 618: LD_ADDR_EXP 11
 622: PUSH
 623: LD_INT 1050
 625: PPUSH
 626: LD_INT 2100
 628: PPUSH
 629: CALL_OW 12
 633: ST_TO_ADDR
// end ;
 634: END
// every 0 0$5 trigger TICK >= time_crates_us do
 635: LD_OWVAR 1
 639: PUSH
 640: LD_EXP 10
 644: GREATEREQUAL
 645: IFFALSE 694
 647: GO 649
 649: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 5 ) , inner_base , true ) ;
 650: LD_INT 2
 652: PPUSH
 653: LD_INT 5
 655: PPUSH
 656: CALL_OW 12
 660: PPUSH
 661: LD_INT 4
 663: PPUSH
 664: LD_INT 1
 666: PPUSH
 667: CALL_OW 55
// time_crates_us := TICK + Rand ( 0 0$60 , 0 0$100 ) ;
 671: LD_ADDR_EXP 10
 675: PUSH
 676: LD_OWVAR 1
 680: PUSH
 681: LD_INT 2100
 683: PPUSH
 684: LD_INT 3500
 686: PPUSH
 687: CALL_OW 12
 691: PLUS
 692: ST_TO_ADDR
// enable ;
 693: ENABLE
// end ;
 694: END
// every 0 0$5 trigger TICK >= time_crates_ru do
 695: LD_OWVAR 1
 699: PUSH
 700: LD_EXP 11
 704: GREATEREQUAL
 705: IFFALSE 754
 707: GO 709
 709: DISABLE
// begin CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
 710: LD_INT 3
 712: PPUSH
 713: LD_INT 5
 715: PPUSH
 716: CALL_OW 12
 720: PPUSH
 721: LD_INT 10
 723: PPUSH
 724: LD_INT 1
 726: PPUSH
 727: CALL_OW 55
// time_crates_ru := TICK + Rand ( 0 0$30 , 0 0$60 ) ;
 731: LD_ADDR_EXP 11
 735: PUSH
 736: LD_OWVAR 1
 740: PUSH
 741: LD_INT 1050
 743: PPUSH
 744: LD_INT 2100
 746: PPUSH
 747: CALL_OW 12
 751: PLUS
 752: ST_TO_ADDR
// enable ;
 753: ENABLE
// end ;
 754: END
// export function konec_mise ; var saved , un , medal1 , medal2 , medal3 ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
 760: PPUSH
 761: PPUSH
 762: PPUSH
// medal1 := false ;
 763: LD_ADDR_VAR 0 4
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// medal2 := false ;
 771: LD_ADDR_VAR 0 5
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// medal3 := false ;
 779: LD_ADDR_VAR 0 6
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// if IsOK ( MacMillan ) and not russians_eliminated then
 787: LD_EXP 1
 791: PPUSH
 792: CALL_OW 302
 796: PUSH
 797: LD_LOC 1
 801: NOT
 802: AND
 803: IFFALSE 901
// begin un := IsInUnit ( MacMillan ) ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_EXP 1
 814: PPUSH
 815: CALL_OW 310
 819: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 820: LD_VAR 0 3
 824: PPUSH
 825: CALL_OW 247
 829: PUSH
 830: LD_INT 2
 832: EQUAL
 833: IFFALSE 886
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
 835: LD_ADDR_EXP 20
 839: PUSH
 840: LD_VAR 0 3
 844: PPUSH
 845: CALL_OW 265
 849: PUSH
 850: LD_VAR 0 3
 854: PPUSH
 855: CALL_OW 262
 859: PUSH
 860: LD_VAR 0 3
 864: PPUSH
 865: CALL_OW 263
 869: PUSH
 870: LD_VAR 0 3
 874: PPUSH
 875: CALL_OW 264
 879: PUSH
 880: EMPTY
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 886: LD_VAR 0 3
 890: PPUSH
 891: CALL_OW 247
 895: PUSH
 896: LD_INT 2
 898: EQUAL
 899: IFFALSE 901
// end ; if IsDead ( MacMillan ) or ( GetLives ( MacMillan ) < 250 ) then
 901: LD_EXP 1
 905: PPUSH
 906: CALL_OW 301
 910: PUSH
 911: LD_EXP 1
 915: PPUSH
 916: CALL_OW 256
 920: PUSH
 921: LD_INT 250
 923: LESS
 924: OR
 925: IFFALSE 936
// begin YouLost ( JMM ) ;
 927: LD_STRING JMM
 929: PPUSH
 930: CALL_OW 104
// exit ;
 934: GO 1765
// end ; if ( GetLives ( survivor ) > 250 ) and visit_base then
 936: LD_EXP 6
 940: PPUSH
 941: CALL_OW 256
 945: PUSH
 946: LD_INT 250
 948: GREATER
 949: PUSH
 950: LD_EXP 34
 954: AND
 955: IFFALSE 979
// begin medal1 := true ;
 957: LD_ADDR_VAR 0 4
 961: PUSH
 962: LD_INT 1
 964: ST_TO_ADDR
// AddMedal ( protect , who_survive ) ;
 965: LD_STRING protect
 967: PPUSH
 968: LD_EXP 7
 972: PPUSH
 973: CALL_OW 101
// end else
 977: GO 1051
// case who_survive of 1 :
 979: LD_EXP 7
 983: PUSH
 984: LD_INT 1
 986: DOUBLE
 987: EQUAL
 988: IFTRUE 992
 990: GO 1006
 992: POP
// AddMedal ( protect , - 1 ) ; 2 :
 993: LD_STRING protect
 995: PPUSH
 996: LD_INT 1
 998: NEG
 999: PPUSH
1000: CALL_OW 101
1004: GO 1051
1006: LD_INT 2
1008: DOUBLE
1009: EQUAL
1010: IFTRUE 1014
1012: GO 1028
1014: POP
// AddMedal ( protect , - 2 ) ; 3 :
1015: LD_STRING protect
1017: PPUSH
1018: LD_INT 2
1020: NEG
1021: PPUSH
1022: CALL_OW 101
1026: GO 1051
1028: LD_INT 3
1030: DOUBLE
1031: EQUAL
1032: IFTRUE 1036
1034: GO 1050
1036: POP
// AddMedal ( protect , - 3 ) ; end ;
1037: LD_STRING protect
1039: PPUSH
1040: LD_INT 3
1042: NEG
1043: PPUSH
1044: CALL_OW 101
1048: GO 1051
1050: POP
// if ( GetLives ( survivor ) > 250 ) and visit_base then
1051: LD_EXP 6
1055: PPUSH
1056: CALL_OW 256
1060: PUSH
1061: LD_INT 250
1063: GREATER
1064: PUSH
1065: LD_EXP 34
1069: AND
1070: IFFALSE 1093
// saved := [ MacMillan , survivor ] else
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_EXP 1
1081: PUSH
1082: LD_EXP 6
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: ST_TO_ADDR
1091: GO 1106
// saved := [ MacMillan ] ;
1093: LD_ADDR_VAR 0 2
1097: PUSH
1098: LD_EXP 1
1102: PUSH
1103: EMPTY
1104: LIST
1105: ST_TO_ADDR
// double_laser := double_laser + doublelasers_turrets ;
1106: LD_ADDR_EXP 17
1110: PUSH
1111: LD_EXP 17
1115: PUSH
1116: LD_LOC 2
1120: PLUS
1121: ST_TO_ADDR
// if visit_base then
1122: LD_EXP 34
1126: IFFALSE 1218
// begin if not selected_opto_lab then
1128: LD_EXP 19
1132: NOT
1133: IFFALSE 1148
// AddMedal ( double , - 1 ) else
1135: LD_STRING double
1137: PPUSH
1138: LD_INT 1
1140: NEG
1141: PPUSH
1142: CALL_OW 101
1146: GO 1216
// case double_laser of 0 :
1148: LD_EXP 17
1152: PUSH
1153: LD_INT 0
1155: DOUBLE
1156: EQUAL
1157: IFTRUE 1161
1159: GO 1175
1161: POP
// AddMedal ( double , - 2 ) ; 1 :
1162: LD_STRING double
1164: PPUSH
1165: LD_INT 2
1167: NEG
1168: PPUSH
1169: CALL_OW 101
1173: GO 1216
1175: LD_INT 1
1177: DOUBLE
1178: EQUAL
1179: IFTRUE 1183
1181: GO 1197
1183: POP
// AddMedal ( double , - 3 ) ; else
1184: LD_STRING double
1186: PPUSH
1187: LD_INT 3
1189: NEG
1190: PPUSH
1191: CALL_OW 101
1195: GO 1216
1197: POP
// begin medal2 := true ;
1198: LD_ADDR_VAR 0 5
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// Addmedal ( double , 1 ) ;
1206: LD_STRING double
1208: PPUSH
1209: LD_INT 1
1211: PPUSH
1212: CALL_OW 101
// end ; end ; end else
1216: GO 1229
// AddMedal ( double , - 2 ) ;
1218: LD_STRING double
1220: PPUSH
1221: LD_INT 2
1223: NEG
1224: PPUSH
1225: CALL_OW 101
// if russians_eliminated then
1229: LD_LOC 1
1233: IFFALSE 1296
// begin AddMedal ( base , 1 ) ;
1235: LD_STRING base
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: CALL_OW 101
// medal3 := true ;
1245: LD_ADDR_VAR 0 6
1249: PUSH
1250: LD_INT 1
1252: ST_TO_ADDR
// SA_EndMission ( 1 , 14 , medal1 , medal2 , medal3 ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 14
1258: PPUSH
1259: LD_VAR 0 4
1263: PPUSH
1264: LD_VAR 0 5
1268: PPUSH
1269: LD_VAR 0 6
1273: PPUSH
1274: CALL 17441 0 5
// GiveMedals ( Eliminate ) ;
1278: LD_STRING Eliminate
1280: PPUSH
1281: CALL_OW 102
// RewardPeople ( saved ) ;
1285: LD_VAR 0 2
1289: PPUSH
1290: CALL_OW 43
// end else
1294: GO 1343
// begin if not visit_base then
1296: LD_EXP 34
1300: NOT
1301: IFFALSE 1316
// AddMedal ( base , - 2 ) else
1303: LD_STRING base
1305: PPUSH
1306: LD_INT 2
1308: NEG
1309: PPUSH
1310: CALL_OW 101
1314: GO 1327
// AddMedal ( base , - 1 ) ;
1316: LD_STRING base
1318: PPUSH
1319: LD_INT 1
1321: NEG
1322: PPUSH
1323: CALL_OW 101
// GiveMedals ( Reach ) ;
1327: LD_STRING Reach
1329: PPUSH
1330: CALL_OW 102
// RewardPeople ( saved ) ;
1334: LD_VAR 0 2
1338: PPUSH
1339: CALL_OW 43
// end ; kappa_saved := false ;
1343: LD_ADDR_EXP 23
1347: PUSH
1348: LD_INT 0
1350: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1351: LD_EXP 1
1355: PPUSH
1356: LD_STRING JMM
1358: PPUSH
1359: CALL_OW 38
// if not visit_base then
1363: LD_EXP 34
1367: NOT
1368: IFFALSE 1379
// KillUnit ( survivor ) ;
1370: LD_EXP 6
1374: PPUSH
1375: CALL_OW 66
// case who_survive of 1 :
1379: LD_EXP 7
1383: PUSH
1384: LD_INT 1
1386: DOUBLE
1387: EQUAL
1388: IFTRUE 1392
1390: GO 1407
1392: POP
// SaveCharacters ( Joan , Joan ) ; 2 :
1393: LD_EXP 3
1397: PPUSH
1398: LD_STRING Joan
1400: PPUSH
1401: CALL_OW 38
1405: GO 1454
1407: LD_INT 2
1409: DOUBLE
1410: EQUAL
1411: IFTRUE 1415
1413: GO 1430
1415: POP
// SaveCharacters ( Lisa , Lisa ) ; 3 :
1416: LD_EXP 4
1420: PPUSH
1421: LD_STRING Lisa
1423: PPUSH
1424: CALL_OW 38
1428: GO 1454
1430: LD_INT 3
1432: DOUBLE
1433: EQUAL
1434: IFTRUE 1438
1436: GO 1453
1438: POP
// SaveCharacters ( Anezka , Coonie ) ; end ;
1439: LD_EXP 5
1443: PPUSH
1444: LD_STRING Coonie
1446: PPUSH
1447: CALL_OW 38
1451: GO 1454
1453: POP
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1454: LD_EXP 6
1458: PPUSH
1459: CALL_OW 256
1463: PUSH
1464: LD_INT 250
1466: GREATER
1467: PUSH
1468: LD_EXP 22
1472: PUSH
1473: LD_INT 0
1475: EQUAL
1476: AND
1477: IFFALSE 1496
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
1479: LD_EXP 6
1483: PPUSH
1484: CALL_OW 300
1488: PPUSH
1489: LD_STRING woman_saved
1491: PPUSH
1492: CALL_OW 39
// if [ GetSide ( survivor ) = 4 or IsDead ( survivor ) ] and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
1496: LD_EXP 6
1500: PPUSH
1501: CALL_OW 255
1505: PUSH
1506: LD_INT 4
1508: EQUAL
1509: PUSH
1510: LD_EXP 6
1514: PPUSH
1515: CALL_OW 301
1519: OR
1520: PUSH
1521: EMPTY
1522: LIST
1523: PUSH
1524: LD_INT 22
1526: PUSH
1527: LD_INT 3
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 21
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: LD_INT 50
1546: PUSH
1547: EMPTY
1548: LIST
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL_OW 69
1559: PUSH
1560: LD_INT 0
1562: GREATER
1563: AND
1564: PUSH
1565: LD_INT 22
1567: PUSH
1568: LD_INT 1
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PUSH
1575: LD_INT 21
1577: PUSH
1578: LD_INT 1
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PPUSH
1589: CALL_OW 69
1593: PUSH
1594: LD_INT 1
1596: EQUAL
1597: AND
1598: IFFALSE 1608
// kappa_saved = false ;
1600: LD_ADDR_EXP 23
1604: PUSH
1605: LD_INT 0
1607: ST_TO_ADDR
// if GetDistUnits ( IsInUnit ( survivor ) , IsInUnit ( Macmillan ) ) < 15 then
1608: LD_EXP 6
1612: PPUSH
1613: CALL_OW 310
1617: PPUSH
1618: LD_EXP 1
1622: PPUSH
1623: CALL_OW 310
1627: PPUSH
1628: CALL_OW 296
1632: PUSH
1633: LD_INT 15
1635: LESS
1636: IFFALSE 1646
// kappa_saved = true ;
1638: LD_ADDR_EXP 23
1642: PUSH
1643: LD_INT 1
1645: ST_TO_ADDR
// SaveVariable ( kappa_saved , kappa_saved ) ;
1646: LD_EXP 23
1650: PPUSH
1651: LD_STRING kappa_saved
1653: PPUSH
1654: CALL_OW 39
// SaveVariable ( visit_base , kappa_delayed ) ;
1658: LD_EXP 34
1662: PPUSH
1663: LD_STRING kappa_delayed
1665: PPUSH
1666: CALL_OW 39
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1670: LD_EXP 6
1674: PPUSH
1675: CALL_OW 256
1679: PUSH
1680: LD_INT 250
1682: GREATER
1683: PUSH
1684: LD_EXP 22
1688: PUSH
1689: LD_INT 0
1691: EQUAL
1692: AND
1693: IFFALSE 1718
// SaveVariable ( ( visit_base and IsOK ( survivor ) ) , woman_alive ) ;
1695: LD_EXP 34
1699: PUSH
1700: LD_EXP 6
1704: PPUSH
1705: CALL_OW 302
1709: AND
1710: PPUSH
1711: LD_STRING woman_alive
1713: PPUSH
1714: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
1718: LD_EXP 7
1722: PPUSH
1723: LD_STRING woman_in_am14
1725: PPUSH
1726: CALL_OW 39
// if not russians_eliminated then
1730: LD_LOC 1
1734: NOT
1735: IFFALSE 1761
// begin SaveVariable ( veh_jmm , veh_jmm ) ;
1737: LD_EXP 20
1741: PPUSH
1742: LD_STRING veh_jmm
1744: PPUSH
1745: CALL_OW 39
// SaveVariable ( veh_surv , veh_surv ) ;
1749: LD_EXP 21
1753: PPUSH
1754: LD_STRING veh_surv
1756: PPUSH
1757: CALL_OW 39
// end ; YouWin ;
1761: CALL_OW 103
// end ;
1765: LD_VAR 0 1
1769: RET
// function almost_done_macmillan ; var odpoved , vysledek , un ; begin
1770: LD_INT 0
1772: PPUSH
1773: PPUSH
1774: PPUSH
1775: PPUSH
// vysledek := true ;
1776: LD_ADDR_VAR 0 3
1780: PUSH
1781: LD_INT 1
1783: ST_TO_ADDR
// un := IsInUnit ( MacMillan ) ;
1784: LD_ADDR_VAR 0 4
1788: PUSH
1789: LD_EXP 1
1793: PPUSH
1794: CALL_OW 310
1798: ST_TO_ADDR
// if not IsOK ( survivor ) or ( IsInArea ( survivor , near_exit ) and IsInUnit ( survivor ) ) then
1799: LD_EXP 6
1803: PPUSH
1804: CALL_OW 302
1808: NOT
1809: PUSH
1810: LD_EXP 6
1814: PPUSH
1815: LD_INT 26
1817: PPUSH
1818: CALL_OW 308
1822: PUSH
1823: LD_EXP 6
1827: PPUSH
1828: CALL_OW 310
1832: AND
1833: OR
1834: IFFALSE 1917
// begin fastEscape = 1 ;
1836: LD_ADDR_EXP 22
1840: PUSH
1841: LD_INT 1
1843: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1844: LD_EXP 1
1848: PPUSH
1849: LD_STRING JMM
1851: PPUSH
1852: CALL_OW 38
// CheckSurvivorStatus ;
1856: CALL 2879 0 0
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1860: LD_ADDR_EXP 20
1864: PUSH
1865: LD_VAR 0 4
1869: PPUSH
1870: CALL_OW 265
1874: PUSH
1875: LD_VAR 0 4
1879: PPUSH
1880: CALL_OW 262
1884: PUSH
1885: LD_VAR 0 4
1889: PPUSH
1890: CALL_OW 263
1894: PUSH
1895: LD_VAR 0 4
1899: PPUSH
1900: CALL_OW 264
1904: PUSH
1905: EMPTY
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: ST_TO_ADDR
// konec_mise ;
1911: CALL 755 0 0
// end else
1915: GO 1995
// begin case who_survive of 1 :
1917: LD_EXP 7
1921: PUSH
1922: LD_INT 1
1924: DOUBLE
1925: EQUAL
1926: IFTRUE 1930
1928: GO 1946
1930: POP
// odpoved := Query ( Q3bJ ) ; 2 :
1931: LD_ADDR_VAR 0 2
1935: PUSH
1936: LD_STRING Q3bJ
1938: PPUSH
1939: CALL_OW 97
1943: ST_TO_ADDR
1944: GO 1995
1946: LD_INT 2
1948: DOUBLE
1949: EQUAL
1950: IFTRUE 1954
1952: GO 1970
1954: POP
// odpoved := Query ( Q3bL ) ; 3 :
1955: LD_ADDR_VAR 0 2
1959: PUSH
1960: LD_STRING Q3bL
1962: PPUSH
1963: CALL_OW 97
1967: ST_TO_ADDR
1968: GO 1995
1970: LD_INT 3
1972: DOUBLE
1973: EQUAL
1974: IFTRUE 1978
1976: GO 1994
1978: POP
// odpoved := Query ( Q3bX ) ; end ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_STRING Q3bX
1986: PPUSH
1987: CALL_OW 97
1991: ST_TO_ADDR
1992: GO 1995
1994: POP
// end ; if odpoved = 1 then
1995: LD_VAR 0 2
1999: PUSH
2000: LD_INT 1
2002: EQUAL
2003: IFFALSE 2011
// konec_mise else
2005: CALL 755 0 0
2009: GO 2019
// vysledek := false ;
2011: LD_ADDR_VAR 0 3
2015: PUSH
2016: LD_INT 0
2018: ST_TO_ADDR
// result := vysledek ;
2019: LD_ADDR_VAR 0 1
2023: PUSH
2024: LD_VAR 0 3
2028: ST_TO_ADDR
// end ;
2029: LD_VAR 0 1
2033: RET
// function almost_done_survivor ; var odpoved , vysledek , un ; begin
2034: LD_INT 0
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// odpoved := false ;
2040: LD_ADDR_VAR 0 2
2044: PUSH
2045: LD_INT 0
2047: ST_TO_ADDR
// vysledek := true ;
2048: LD_ADDR_VAR 0 3
2052: PUSH
2053: LD_INT 1
2055: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
2056: LD_ADDR_VAR 0 4
2060: PUSH
2061: LD_EXP 6
2065: PPUSH
2066: CALL_OW 310
2070: ST_TO_ADDR
// if IsOK ( MacMillan ) then
2071: LD_EXP 1
2075: PPUSH
2076: CALL_OW 302
2080: IFFALSE 2097
// odpoved := Query ( Q3b ) else
2082: LD_ADDR_VAR 0 2
2086: PUSH
2087: LD_STRING Q3b
2089: PPUSH
2090: CALL_OW 97
2094: ST_TO_ADDR
2095: GO 2105
// odpoved := true ;
2097: LD_ADDR_VAR 0 2
2101: PUSH
2102: LD_INT 1
2104: ST_TO_ADDR
// if odpoved then
2105: LD_VAR 0 2
2109: IFFALSE 2117
// begin CheckSurvivorStatus ;
2111: CALL 2879 0 0
// end else
2115: GO 2125
// vysledek := false ;
2117: LD_ADDR_VAR 0 3
2121: PUSH
2122: LD_INT 0
2124: ST_TO_ADDR
// result := vysledek ;
2125: LD_ADDR_VAR 0 1
2129: PUSH
2130: LD_VAR 0 3
2134: ST_TO_ADDR
// end ;
2135: LD_VAR 0 1
2139: RET
// every 0 0$2 trigger IsInArea ( MacMillan , exit_area ) do var odpoved ;
2140: LD_EXP 1
2144: PPUSH
2145: LD_INT 25
2147: PPUSH
2148: CALL_OW 308
2152: IFFALSE 2254
2154: GO 2156
2156: DISABLE
2157: LD_INT 0
2159: PPUSH
// begin if IsInUnit ( MacMillan ) then
2160: LD_EXP 1
2164: PPUSH
2165: CALL_OW 310
2169: IFFALSE 2213
// begin if not almost_done_macmillan then
2171: CALL 1770 0 0
2175: NOT
2176: IFFALSE 2211
// repeat wait ( 0 0$1 ) ;
2178: LD_INT 35
2180: PPUSH
2181: CALL_OW 67
// until not ( IsInArea ( MacMillan , exit_area ) and IsInUnit ( MacMillan ) ) ;
2185: LD_EXP 1
2189: PPUSH
2190: LD_INT 25
2192: PPUSH
2193: CALL_OW 308
2197: PUSH
2198: LD_EXP 1
2202: PPUSH
2203: CALL_OW 310
2207: AND
2208: NOT
2209: IFFALSE 2178
// end else
2211: GO 2253
// begin Query ( Q3a ) ;
2213: LD_STRING Q3a
2215: PPUSH
2216: CALL_OW 97
// repeat wait ( 0 0$1 ) ;
2220: LD_INT 35
2222: PPUSH
2223: CALL_OW 67
// until IsInUnit ( MacMillan ) or ( not IsInArea ( MacMillan , exit_area ) ) ;
2227: LD_EXP 1
2231: PPUSH
2232: CALL_OW 310
2236: PUSH
2237: LD_EXP 1
2241: PPUSH
2242: LD_INT 25
2244: PPUSH
2245: CALL_OW 308
2249: NOT
2250: OR
2251: IFFALSE 2220
// end ; enable ;
2253: ENABLE
// end ;
2254: PPOPN 1
2256: END
// every 0 0$2 trigger IsInArea ( survivor , exit_area ) do var odpoved , un ;
2257: LD_EXP 6
2261: PPUSH
2262: LD_INT 25
2264: PPUSH
2265: CALL_OW 308
2269: IFFALSE 2436
2271: GO 2273
2273: DISABLE
2274: LD_INT 0
2276: PPUSH
2277: PPUSH
// begin if IsInUnit ( survivor ) then
2278: LD_EXP 6
2282: PPUSH
2283: CALL_OW 310
2287: IFFALSE 2331
// begin if not almost_done_survivor then
2289: CALL 2034 0 0
2293: NOT
2294: IFFALSE 2329
// repeat wait ( 0 0$1 ) ;
2296: LD_INT 35
2298: PPUSH
2299: CALL_OW 67
// until not ( IsInArea ( survivor , exit_area ) and IsInUnit ( survivor ) ) ;
2303: LD_EXP 6
2307: PPUSH
2308: LD_INT 25
2310: PPUSH
2311: CALL_OW 308
2315: PUSH
2316: LD_EXP 6
2320: PPUSH
2321: CALL_OW 310
2325: AND
2326: NOT
2327: IFFALSE 2296
// end else
2329: GO 2424
// begin case who_survive of 1 :
2331: LD_EXP 7
2335: PUSH
2336: LD_INT 1
2338: DOUBLE
2339: EQUAL
2340: IFTRUE 2344
2342: GO 2354
2344: POP
// Query ( Q3aJ ) ; 2 :
2345: LD_STRING Q3aJ
2347: PPUSH
2348: CALL_OW 97
2352: GO 2391
2354: LD_INT 2
2356: DOUBLE
2357: EQUAL
2358: IFTRUE 2362
2360: GO 2372
2362: POP
// Query ( Q3aL ) ; 3 :
2363: LD_STRING Q3aL
2365: PPUSH
2366: CALL_OW 97
2370: GO 2391
2372: LD_INT 3
2374: DOUBLE
2375: EQUAL
2376: IFTRUE 2380
2378: GO 2390
2380: POP
// Query ( Q3aX ) ; end ;
2381: LD_STRING Q3aX
2383: PPUSH
2384: CALL_OW 97
2388: GO 2391
2390: POP
// repeat wait ( 0 0$1 ) ;
2391: LD_INT 35
2393: PPUSH
2394: CALL_OW 67
// until IsInUnit ( survivor ) or ( not IsInArea ( survivor , exit_area ) ) ;
2398: LD_EXP 6
2402: PPUSH
2403: CALL_OW 310
2407: PUSH
2408: LD_EXP 6
2412: PPUSH
2413: LD_INT 25
2415: PPUSH
2416: CALL_OW 308
2420: NOT
2421: OR
2422: IFFALSE 2391
// end ; if IsLive ( survivor ) then
2424: LD_EXP 6
2428: PPUSH
2429: CALL_OW 300
2433: IFFALSE 2436
// enable ;
2435: ENABLE
// end ;
2436: PPOPN 2
2438: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do var vozidla , lide ;
2439: LD_INT 22
2441: PUSH
2442: LD_EXP 15
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 2
2453: PUSH
2454: LD_INT 30
2456: PUSH
2457: LD_INT 0
2459: PUSH
2460: EMPTY
2461: LIST
2462: LIST
2463: PUSH
2464: LD_INT 30
2466: PUSH
2467: LD_INT 1
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: CALL_OW 69
2487: NOT
2488: IFFALSE 2741
2490: GO 2492
2492: DISABLE
2493: LD_INT 0
2495: PPUSH
2496: PPUSH
// begin repeat vozidla := FilterAllUnits ( [ [ f_side , russians ] , [ [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] , [ f_ok ] ] ) ;
2497: LD_ADDR_VAR 0 1
2501: PUSH
2502: LD_INT 22
2504: PUSH
2505: LD_EXP 15
2509: PUSH
2510: EMPTY
2511: LIST
2512: LIST
2513: PUSH
2514: LD_INT 21
2516: PUSH
2517: LD_INT 2
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: PUSH
2524: LD_INT 33
2526: PUSH
2527: LD_INT 3
2529: PUSH
2530: EMPTY
2531: LIST
2532: LIST
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_INT 50
2540: PUSH
2541: EMPTY
2542: LIST
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: PPUSH
2549: CALL_OW 69
2553: ST_TO_ADDR
// lide := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_INT 22
2561: PUSH
2562: LD_EXP 15
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: LD_INT 21
2573: PUSH
2574: LD_INT 1
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 50
2583: PUSH
2584: EMPTY
2585: LIST
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: PPUSH
2592: CALL_OW 69
2596: ST_TO_ADDR
// if not ( lide or vozidla ) then
2597: LD_VAR 0 2
2601: PUSH
2602: LD_VAR 0 1
2606: OR
2607: NOT
2608: IFFALSE 2618
// russians_eliminated := true ;
2610: LD_ADDR_LOC 1
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// wait ( 0 0$1 ) ;
2618: LD_INT 35
2620: PPUSH
2621: CALL_OW 67
// until IsOk ( MacMillan ) and russians_eliminated ;
2625: LD_EXP 1
2629: PPUSH
2630: CALL_OW 302
2634: PUSH
2635: LD_LOC 1
2639: AND
2640: IFFALSE 2497
// DialogueOn ;
2642: CALL_OW 6
// Say ( MacMillan , DEnd-JMM-1 ) ;
2646: LD_EXP 1
2650: PPUSH
2651: LD_STRING DEnd-JMM-1
2653: PPUSH
2654: CALL_OW 88
// case who_survive of 1 :
2658: LD_EXP 7
2662: PUSH
2663: LD_INT 1
2665: DOUBLE
2666: EQUAL
2667: IFTRUE 2671
2669: GO 2686
2671: POP
// Say ( Joan , DEnd-Joan-1 ) ; 2 :
2672: LD_EXP 3
2676: PPUSH
2677: LD_STRING DEnd-Joan-1
2679: PPUSH
2680: CALL_OW 88
2684: GO 2733
2686: LD_INT 2
2688: DOUBLE
2689: EQUAL
2690: IFTRUE 2694
2692: GO 2709
2694: POP
// Say ( Lisa , DEnd-Lisa-1 ) ; 3 :
2695: LD_EXP 4
2699: PPUSH
2700: LD_STRING DEnd-Lisa-1
2702: PPUSH
2703: CALL_OW 88
2707: GO 2733
2709: LD_INT 3
2711: DOUBLE
2712: EQUAL
2713: IFTRUE 2717
2715: GO 2732
2717: POP
// Say ( Anezka , DEnd-Con-1 ) ; end ;
2718: LD_EXP 5
2722: PPUSH
2723: LD_STRING DEnd-Con-1
2725: PPUSH
2726: CALL_OW 88
2730: GO 2733
2732: POP
// DialogueOff ;
2733: CALL_OW 7
// konec_mise ;
2737: CALL 755 0 0
// end ;
2741: PPOPN 2
2743: END
// every 0 0$3 do var un , list ;
2744: GO 2746
2746: DISABLE
2747: LD_INT 0
2749: PPUSH
2750: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_INT 22
2758: PUSH
2759: LD_EXP 14
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 30
2773: PUSH
2774: LD_INT 32
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: PUSH
2781: LD_INT 30
2783: PUSH
2784: LD_INT 33
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: LIST
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// for un in list do
2805: LD_ADDR_VAR 0 1
2809: PUSH
2810: LD_VAR 0 2
2814: PUSH
2815: FOR_IN
2816: IFFALSE 2873
// if GetBWeapon ( un ) = us_double_laser then
2818: LD_VAR 0 1
2822: PPUSH
2823: CALL_OW 269
2827: PUSH
2828: LD_INT 10
2830: EQUAL
2831: IFFALSE 2871
// begin if not double_hint then
2833: LD_EXP 18
2837: NOT
2838: IFFALSE 2855
// begin Hint ( DoubleLaser ) ;
2840: LD_STRING DoubleLaser
2842: PPUSH
2843: CALL_OW 339
// double_hint := true ;
2847: LD_ADDR_EXP 18
2851: PUSH
2852: LD_INT 1
2854: ST_TO_ADDR
// end ; doublelasers_turrets := doublelasers_turrets union un ;
2855: LD_ADDR_LOC 2
2859: PUSH
2860: LD_LOC 2
2864: PUSH
2865: LD_VAR 0 1
2869: UNION
2870: ST_TO_ADDR
// end ;
2871: GO 2815
2873: POP
2874: POP
// enable ;
2875: ENABLE
// end ;
2876: PPOPN 2
2878: END
// export function CheckSurvivorStatus ; var un ; begin
2879: LD_INT 0
2881: PPUSH
2882: PPUSH
// if IsOK ( survivor ) then
2883: LD_EXP 6
2887: PPUSH
2888: CALL_OW 302
2892: IFFALSE 3079
// begin repeat un := IsInUnit ( survivor ) ;
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: LD_EXP 6
2903: PPUSH
2904: CALL_OW 310
2908: ST_TO_ADDR
// ComMoveXY ( survivor , 147 , 16 ) ;
2909: LD_EXP 6
2913: PPUSH
2914: LD_INT 147
2916: PPUSH
2917: LD_INT 16
2919: PPUSH
2920: CALL_OW 111
// wait ( 0 0$1 ) ;
2924: LD_INT 35
2926: PPUSH
2927: CALL_OW 67
// until IsInArea ( survivor , exit_area ) or IsInArea ( un , exit_area ) ;
2931: LD_EXP 6
2935: PPUSH
2936: LD_INT 25
2938: PPUSH
2939: CALL_OW 308
2943: PUSH
2944: LD_VAR 0 2
2948: PPUSH
2949: LD_INT 25
2951: PPUSH
2952: CALL_OW 308
2956: OR
2957: IFFALSE 2894
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
2959: LD_EXP 6
2963: PPUSH
2964: CALL_OW 300
2968: PPUSH
2969: LD_STRING woman_saved
2971: PPUSH
2972: CALL_OW 39
// SaveVariable ( IsLive ( survivor ) , woman_alive ) ;
2976: LD_EXP 6
2980: PPUSH
2981: CALL_OW 300
2985: PPUSH
2986: LD_STRING woman_alive
2988: PPUSH
2989: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
2993: LD_EXP 7
2997: PPUSH
2998: LD_STRING woman_in_am14
3000: PPUSH
3001: CALL_OW 39
// kappa_saved = 1 ;
3005: LD_ADDR_EXP 23
3009: PUSH
3010: LD_INT 1
3012: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
3013: LD_ADDR_VAR 0 2
3017: PUSH
3018: LD_EXP 6
3022: PPUSH
3023: CALL_OW 310
3027: ST_TO_ADDR
// veh_surv := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
3028: LD_ADDR_EXP 21
3032: PUSH
3033: LD_VAR 0 2
3037: PPUSH
3038: CALL_OW 265
3042: PUSH
3043: LD_VAR 0 2
3047: PPUSH
3048: CALL_OW 262
3052: PUSH
3053: LD_VAR 0 2
3057: PPUSH
3058: CALL_OW 263
3062: PUSH
3063: LD_VAR 0 2
3067: PPUSH
3068: CALL_OW 264
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: ST_TO_ADDR
// end ; end ; end_of_file
3079: LD_VAR 0 1
3083: RET
// export ru_ing , ru_sol , ru_sci , ru_mec ; export russians_forces ; export ru_collector ; export checking ; export reserved_people ; export function prepare_ru_base ; var un , i , num_sol , num_ing , num_sci , num_mec , lev ; begin
3084: LD_INT 0
3086: PPUSH
3087: PPUSH
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
// RevealFogArea ( russians , ru_crates ) ;
3094: LD_EXP 15
3098: PPUSH
3099: LD_INT 10
3101: PPUSH
3102: CALL_OW 332
// num_ing := [ 1 , 2 , 2 ] [ difficulty ] ;
3106: LD_ADDR_VAR 0 5
3110: PUSH
3111: LD_INT 1
3113: PUSH
3114: LD_INT 2
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_OWVAR 67
3129: ARRAY
3130: ST_TO_ADDR
// num_sol := [ 2 , 2 , 3 ] [ difficulty ] ;
3131: LD_ADDR_VAR 0 4
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 2
3141: PUSH
3142: LD_INT 3
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: LIST
3149: PUSH
3150: LD_OWVAR 67
3154: ARRAY
3155: ST_TO_ADDR
// num_sci := [ 1 , 3 , 6 ] [ difficulty ] ;
3156: LD_ADDR_VAR 0 6
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 6
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_OWVAR 67
3179: ARRAY
3180: ST_TO_ADDR
// num_mec := [ 2 , 2 , 4 ] [ difficulty ] ;
3181: LD_ADDR_VAR 0 7
3185: PUSH
3186: LD_INT 2
3188: PUSH
3189: LD_INT 2
3191: PUSH
3192: LD_INT 4
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: LD_OWVAR 67
3204: ARRAY
3205: ST_TO_ADDR
// lev := [ 6 , 8 , 10 ] [ difficulty ] ;
3206: LD_ADDR_VAR 0 8
3210: PUSH
3211: LD_INT 6
3213: PUSH
3214: LD_INT 8
3216: PUSH
3217: LD_INT 10
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: PUSH
3225: LD_OWVAR 67
3229: ARRAY
3230: ST_TO_ADDR
// russians_forces := [ ] ;
3231: LD_ADDR_EXP 28
3235: PUSH
3236: EMPTY
3237: ST_TO_ADDR
// ru_ing := [ ] ;
3238: LD_ADDR_EXP 24
3242: PUSH
3243: EMPTY
3244: ST_TO_ADDR
// ru_sol := [ ] ;
3245: LD_ADDR_EXP 25
3249: PUSH
3250: EMPTY
3251: ST_TO_ADDR
// ru_sci := [ ] ;
3252: LD_ADDR_EXP 26
3256: PUSH
3257: EMPTY
3258: ST_TO_ADDR
// ru_mec := [ ] ;
3259: LD_ADDR_EXP 27
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// reserved_people := [ ] ;
3266: LD_ADDR_EXP 31
3270: PUSH
3271: EMPTY
3272: ST_TO_ADDR
// uc_nation = nation_russian ;
3273: LD_ADDR_OWVAR 21
3277: PUSH
3278: LD_INT 3
3280: ST_TO_ADDR
// uc_side = russians ;
3281: LD_ADDR_OWVAR 20
3285: PUSH
3286: LD_EXP 15
3290: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
3291: LD_ADDR_OWVAR 24
3295: PUSH
3296: LD_INT 0
3298: PPUSH
3299: LD_INT 5
3301: PPUSH
3302: CALL_OW 12
3306: ST_TO_ADDR
// hc_gallery :=  ;
3307: LD_ADDR_OWVAR 33
3311: PUSH
3312: LD_STRING 
3314: ST_TO_ADDR
// hc_name :=  ;
3315: LD_ADDR_OWVAR 26
3319: PUSH
3320: LD_STRING 
3322: ST_TO_ADDR
// hc_importance := 0 ;
3323: LD_ADDR_OWVAR 32
3327: PUSH
3328: LD_INT 0
3330: ST_TO_ADDR
// for i := 1 to num_ing do
3331: LD_ADDR_VAR 0 3
3335: PUSH
3336: DOUBLE
3337: LD_INT 1
3339: DEC
3340: ST_TO_ADDR
3341: LD_VAR 0 5
3345: PUSH
3346: FOR_TO
3347: IFFALSE 3455
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3349: LD_ADDR_OWVAR 36
3353: PUSH
3354: LD_INT 2
3356: PPUSH
3357: LD_INT 5
3359: PPUSH
3360: CALL_OW 12
3364: ST_TO_ADDR
// PrepareEngineer ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3365: LD_INT 2
3367: PPUSH
3368: LD_INT 4
3370: PPUSH
3371: CALL_OW 12
3375: PUSH
3376: LD_INT 2
3378: MOD
3379: PUSH
3380: LD_INT 1
3382: PLUS
3383: PPUSH
3384: LD_VAR 0 8
3388: PUSH
3389: LD_INT 0
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: CALL_OW 12
3399: PLUS
3400: PPUSH
3401: CALL_OW 382
// un := CreateHuman ;
3405: LD_ADDR_VAR 0 2
3409: PUSH
3410: CALL_OW 44
3414: ST_TO_ADDR
// ru_ing := ru_ing ^ un ;
3415: LD_ADDR_EXP 24
3419: PUSH
3420: LD_EXP 24
3424: PUSH
3425: LD_VAR 0 2
3429: ADD
3430: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3431: LD_VAR 0 2
3435: PPUSH
3436: LD_INT 8
3438: PPUSH
3439: LD_INT 0
3441: PPUSH
3442: CALL_OW 49
// wait ( 1 ) ;
3446: LD_INT 1
3448: PPUSH
3449: CALL_OW 67
// end ;
3453: GO 3346
3455: POP
3456: POP
// for i := 1 to num_sol do
3457: LD_ADDR_VAR 0 3
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_VAR 0 4
3471: PUSH
3472: FOR_TO
3473: IFFALSE 3581
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3475: LD_ADDR_OWVAR 36
3479: PUSH
3480: LD_INT 2
3482: PPUSH
3483: LD_INT 5
3485: PPUSH
3486: CALL_OW 12
3490: ST_TO_ADDR
// PrepareSoldier ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3491: LD_INT 2
3493: PPUSH
3494: LD_INT 4
3496: PPUSH
3497: CALL_OW 12
3501: PUSH
3502: LD_INT 2
3504: MOD
3505: PUSH
3506: LD_INT 1
3508: PLUS
3509: PPUSH
3510: LD_VAR 0 8
3514: PUSH
3515: LD_INT 0
3517: PPUSH
3518: LD_INT 3
3520: PPUSH
3521: CALL_OW 12
3525: PLUS
3526: PPUSH
3527: CALL_OW 381
// un := CreateHuman ;
3531: LD_ADDR_VAR 0 2
3535: PUSH
3536: CALL_OW 44
3540: ST_TO_ADDR
// ru_sol := ru_sol ^ un ;
3541: LD_ADDR_EXP 25
3545: PUSH
3546: LD_EXP 25
3550: PUSH
3551: LD_VAR 0 2
3555: ADD
3556: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3557: LD_VAR 0 2
3561: PPUSH
3562: LD_INT 8
3564: PPUSH
3565: LD_INT 0
3567: PPUSH
3568: CALL_OW 49
// wait ( 1 ) ;
3572: LD_INT 1
3574: PPUSH
3575: CALL_OW 67
// end ;
3579: GO 3472
3581: POP
3582: POP
// for i := 1 to num_sci do
3583: LD_ADDR_VAR 0 3
3587: PUSH
3588: DOUBLE
3589: LD_INT 1
3591: DEC
3592: ST_TO_ADDR
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_TO
3599: IFFALSE 3707
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3601: LD_ADDR_OWVAR 36
3605: PUSH
3606: LD_INT 2
3608: PPUSH
3609: LD_INT 5
3611: PPUSH
3612: CALL_OW 12
3616: ST_TO_ADDR
// PrepareScientist ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3617: LD_INT 2
3619: PPUSH
3620: LD_INT 4
3622: PPUSH
3623: CALL_OW 12
3627: PUSH
3628: LD_INT 2
3630: MOD
3631: PUSH
3632: LD_INT 1
3634: PLUS
3635: PPUSH
3636: LD_VAR 0 8
3640: PUSH
3641: LD_INT 0
3643: PPUSH
3644: LD_INT 3
3646: PPUSH
3647: CALL_OW 12
3651: PLUS
3652: PPUSH
3653: CALL_OW 384
// un := CreateHuman ;
3657: LD_ADDR_VAR 0 2
3661: PUSH
3662: CALL_OW 44
3666: ST_TO_ADDR
// ru_sci := ru_sci ^ un ;
3667: LD_ADDR_EXP 26
3671: PUSH
3672: LD_EXP 26
3676: PUSH
3677: LD_VAR 0 2
3681: ADD
3682: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_INT 8
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: CALL_OW 49
// wait ( 1 ) ;
3698: LD_INT 1
3700: PPUSH
3701: CALL_OW 67
// end ;
3705: GO 3598
3707: POP
3708: POP
// for i := 1 to num_mec do
3709: LD_ADDR_VAR 0 3
3713: PUSH
3714: DOUBLE
3715: LD_INT 1
3717: DEC
3718: ST_TO_ADDR
3719: LD_VAR 0 7
3723: PUSH
3724: FOR_TO
3725: IFFALSE 3833
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3727: LD_ADDR_OWVAR 36
3731: PUSH
3732: LD_INT 2
3734: PPUSH
3735: LD_INT 5
3737: PPUSH
3738: CALL_OW 12
3742: ST_TO_ADDR
// PrepareMechanic ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3743: LD_INT 2
3745: PPUSH
3746: LD_INT 4
3748: PPUSH
3749: CALL_OW 12
3753: PUSH
3754: LD_INT 2
3756: MOD
3757: PUSH
3758: LD_INT 1
3760: PLUS
3761: PPUSH
3762: LD_VAR 0 8
3766: PUSH
3767: LD_INT 0
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: CALL_OW 12
3777: PLUS
3778: PPUSH
3779: CALL_OW 383
// un := CreateHuman ;
3783: LD_ADDR_VAR 0 2
3787: PUSH
3788: CALL_OW 44
3792: ST_TO_ADDR
// ru_mec := ru_mec ^ un ;
3793: LD_ADDR_EXP 27
3797: PUSH
3798: LD_EXP 27
3802: PUSH
3803: LD_VAR 0 2
3807: ADD
3808: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3809: LD_VAR 0 2
3813: PPUSH
3814: LD_INT 8
3816: PPUSH
3817: LD_INT 0
3819: PPUSH
3820: CALL_OW 49
// wait ( 1 ) ;
3824: LD_INT 1
3826: PPUSH
3827: CALL_OW 67
// end ;
3831: GO 3724
3833: POP
3834: POP
// russians_forces := ru_ing ^ ru_sol ^ ru_sci ^ ru_mec ;
3835: LD_ADDR_EXP 28
3839: PUSH
3840: LD_EXP 24
3844: PUSH
3845: LD_EXP 25
3849: ADD
3850: PUSH
3851: LD_EXP 26
3855: ADD
3856: PUSH
3857: LD_EXP 27
3861: ADD
3862: ST_TO_ADDR
// i := 1 ;
3863: LD_ADDR_VAR 0 3
3867: PUSH
3868: LD_INT 1
3870: ST_TO_ADDR
// for un in ru_mec do
3871: LD_ADDR_VAR 0 2
3875: PUSH
3876: LD_EXP 27
3880: PUSH
3881: FOR_IN
3882: IFFALSE 3947
// begin if ( i mod 2 ) = 0 then
3884: LD_VAR 0 3
3888: PUSH
3889: LD_INT 2
3891: MOD
3892: PUSH
3893: LD_INT 0
3895: EQUAL
3896: IFFALSE 3912
// ComEnterUnit ( un , ru_fact2 ) else
3898: LD_VAR 0 2
3902: PPUSH
3903: LD_INT 40
3905: PPUSH
3906: CALL_OW 120
3910: GO 3924
// ComEnterUnit ( un , ru_fact1 ) ;
3912: LD_VAR 0 2
3916: PPUSH
3917: LD_INT 1
3919: PPUSH
3920: CALL_OW 120
// i := i + 1 ;
3924: LD_ADDR_VAR 0 3
3928: PUSH
3929: LD_VAR 0 3
3933: PUSH
3934: LD_INT 1
3936: PLUS
3937: ST_TO_ADDR
// wait ( 1 ) ;
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 67
// end ;
3945: GO 3881
3947: POP
3948: POP
// for un in ru_sci do
3949: LD_ADDR_VAR 0 2
3953: PUSH
3954: LD_EXP 26
3958: PUSH
3959: FOR_IN
3960: IFFALSE 4011
// begin if ( un mod 2 ) = 0 then
3962: LD_VAR 0 2
3966: PUSH
3967: LD_INT 2
3969: MOD
3970: PUSH
3971: LD_INT 0
3973: EQUAL
3974: IFFALSE 3990
// ComEnterUnit ( un , ru_lab1 ) else
3976: LD_VAR 0 2
3980: PPUSH
3981: LD_INT 14
3983: PPUSH
3984: CALL_OW 120
3988: GO 4002
// ComEnterunit ( un , ru_lab2 ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 15
3997: PPUSH
3998: CALL_OW 120
// wait ( 1 ) ;
4002: LD_INT 1
4004: PPUSH
4005: CALL_OW 67
// end ;
4009: GO 3959
4011: POP
4012: POP
// uc_direction := Rand ( 0 , 5 ) ;
4013: LD_ADDR_OWVAR 24
4017: PUSH
4018: LD_INT 0
4020: PPUSH
4021: LD_INT 5
4023: PPUSH
4024: CALL_OW 12
4028: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
4029: LD_ADDR_OWVAR 37
4033: PUSH
4034: LD_INT 21
4036: ST_TO_ADDR
// vc_control := control_manual ;
4037: LD_ADDR_OWVAR 38
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// vc_engine := engine_combustion ;
4045: LD_ADDR_OWVAR 39
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4053: LD_ADDR_OWVAR 40
4057: PUSH
4058: LD_INT 51
4060: ST_TO_ADDR
// ru_collector := CreateVehicle ;
4061: LD_ADDR_EXP 29
4065: PUSH
4066: CALL_OW 45
4070: ST_TO_ADDR
// PlaceUnitXYR ( ru_collector , ShiftX ( GetX ( ru_depot ) , 4 , 5 ) , GetY ( ru_depot ) , 5 , false ) ;
4071: LD_EXP 29
4075: PPUSH
4076: LD_INT 22
4078: PPUSH
4079: CALL_OW 250
4083: PPUSH
4084: LD_INT 4
4086: PPUSH
4087: LD_INT 5
4089: PPUSH
4090: CALL_OW 272
4094: PPUSH
4095: LD_INT 22
4097: PPUSH
4098: CALL_OW 251
4102: PPUSH
4103: LD_INT 5
4105: PPUSH
4106: LD_INT 0
4108: PPUSH
4109: CALL_OW 50
// end ;
4113: LD_VAR 0 1
4117: RET
// export crate_list ; every 0 0$5 trigger GetListOfCratesInArea ( ru_crates ) do var un , free_unit , x , y , max , i , clear_crates , old_class , attempt ;
4118: LD_INT 10
4120: PPUSH
4121: CALL_OW 435
4125: IFFALSE 4973
4127: GO 4129
4129: DISABLE
4130: LD_INT 0
4132: PPUSH
4133: PPUSH
4134: PPUSH
4135: PPUSH
4136: PPUSH
4137: PPUSH
4138: PPUSH
4139: PPUSH
4140: PPUSH
// begin crate_list := GetListOfCratesInArea ( ru_crates ) ;
4141: LD_ADDR_EXP 32
4145: PUSH
4146: LD_INT 10
4148: PPUSH
4149: CALL_OW 435
4153: ST_TO_ADDR
// free_unit := false ;
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// i := russians_forces diff reserved_people ;
4162: LD_ADDR_VAR 0 6
4166: PUSH
4167: LD_EXP 28
4171: PUSH
4172: LD_EXP 31
4176: DIFF
4177: ST_TO_ADDR
// for un in i do
4178: LD_ADDR_VAR 0 1
4182: PUSH
4183: LD_VAR 0 6
4187: PUSH
4188: FOR_IN
4189: IFFALSE 4228
// begin if not ( HasTask ( un ) or GetUnitMc ( un ) ) then
4191: LD_VAR 0 1
4195: PPUSH
4196: CALL_OW 314
4200: PUSH
4201: LD_VAR 0 1
4205: PPUSH
4206: CALL_OW 388
4210: OR
4211: NOT
4212: IFFALSE 4226
// begin free_unit := un ;
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_VAR 0 1
4223: ST_TO_ADDR
// break ;
4224: GO 4228
// end ; end ;
4226: GO 4188
4228: POP
4229: POP
// if free_unit and IsOK ( free_unit ) then
4230: LD_VAR 0 2
4234: PUSH
4235: LD_VAR 0 2
4239: PPUSH
4240: CALL_OW 302
4244: AND
4245: IFFALSE 4972
// begin reserved_people := reserved_people ^ free_unit ;
4247: LD_ADDR_EXP 31
4251: PUSH
4252: LD_EXP 31
4256: PUSH
4257: LD_VAR 0 2
4261: ADD
4262: ST_TO_ADDR
// ComRemember ( free_unit ) ;
4263: LD_VAR 0 2
4267: PPUSH
4268: CALL_OW 143
// if IsLive ( ru_collector ) then
4272: LD_EXP 29
4276: PPUSH
4277: CALL_OW 300
4281: IFFALSE 4427
// begin repeat ComEnterUnit ( free_unit , ru_collector ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_EXP 29
4292: PPUSH
4293: CALL_OW 120
// wait ( 0 0$1 ) ;
4297: LD_INT 35
4299: PPUSH
4300: CALL_OW 67
// until ( IsInUnit ( free_unit ) ) or not IsLive ( ru_collector ) ;
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL_OW 310
4313: PUSH
4314: LD_EXP 29
4318: PPUSH
4319: CALL_OW 300
4323: NOT
4324: OR
4325: IFFALSE 4283
// if not IsLive ( ru_collector ) then
4327: LD_EXP 29
4331: PPUSH
4332: CALL_OW 300
4336: NOT
4337: IFFALSE 4415
// begin un := free_unit ;
4339: LD_ADDR_VAR 0 1
4343: PUSH
4344: LD_VAR 0 2
4348: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4349: LD_ADDR_VAR 0 8
4353: PUSH
4354: LD_VAR 0 1
4358: PPUSH
4359: CALL_OW 257
4363: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4364: LD_VAR 0 1
4368: PPUSH
4369: CALL_OW 257
4373: PUSH
4374: LD_INT 2
4376: EQUAL
4377: NOT
4378: IFFALSE 4413
// begin ComEnterUnit ( un , ru_depot ) ;
4380: LD_VAR 0 1
4384: PPUSH
4385: LD_INT 22
4387: PPUSH
4388: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4392: LD_VAR 0 1
4396: PPUSH
4397: LD_INT 2
4399: PPUSH
4400: CALL_OW 183
// wait ( 0 0$1 ) ;
4404: LD_INT 35
4406: PPUSH
4407: CALL_OW 67
// end ;
4411: GO 4364
// end else
4413: GO 4425
// un := ru_collector ;
4415: LD_ADDR_VAR 0 1
4419: PUSH
4420: LD_EXP 29
4424: ST_TO_ADDR
// end else
4425: GO 4501
// begin un := free_unit ;
4427: LD_ADDR_VAR 0 1
4431: PUSH
4432: LD_VAR 0 2
4436: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4437: LD_ADDR_VAR 0 8
4441: PUSH
4442: LD_VAR 0 1
4446: PPUSH
4447: CALL_OW 257
4451: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4452: LD_VAR 0 1
4456: PPUSH
4457: CALL_OW 257
4461: PUSH
4462: LD_INT 2
4464: EQUAL
4465: NOT
4466: IFFALSE 4501
// begin ComEnterUnit ( un , ru_depot ) ;
4468: LD_VAR 0 1
4472: PPUSH
4473: LD_INT 22
4475: PPUSH
4476: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4480: LD_VAR 0 1
4484: PPUSH
4485: LD_INT 2
4487: PPUSH
4488: CALL_OW 183
// wait ( 0 0$1 ) ;
4492: LD_INT 35
4494: PPUSH
4495: CALL_OW 67
// end ;
4499: GO 4452
// end ; if IsLive ( ru_collector ) then
4501: LD_EXP 29
4505: PPUSH
4506: CALL_OW 300
4510: IFFALSE 4541
// ComCollect ( un , crate_list [ 1 ] , crate_list [ 2 ] ) else
4512: LD_VAR 0 1
4516: PPUSH
4517: LD_EXP 32
4521: PUSH
4522: LD_INT 1
4524: ARRAY
4525: PPUSH
4526: LD_EXP 32
4530: PUSH
4531: LD_INT 2
4533: ARRAY
4534: PPUSH
4535: CALL_OW 117
4539: GO 4568
// ComGet ( un , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4541: LD_VAR 0 1
4545: PPUSH
4546: LD_EXP 32
4550: PUSH
4551: LD_INT 1
4553: ARRAY
4554: PPUSH
4555: LD_EXP 32
4559: PUSH
4560: LD_INT 2
4562: ARRAY
4563: PPUSH
4564: CALL_OW 160
// clear_crates := false ;
4568: LD_ADDR_VAR 0 7
4572: PUSH
4573: LD_INT 0
4575: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4576: LD_INT 35
4578: PPUSH
4579: CALL_OW 67
// if IsLive ( ru_collector ) and GetFuel ( un ) < 25 then
4583: LD_EXP 29
4587: PPUSH
4588: CALL_OW 300
4592: PUSH
4593: LD_VAR 0 1
4597: PPUSH
4598: CALL_OW 261
4602: PUSH
4603: LD_INT 25
4605: LESS
4606: AND
4607: IFFALSE 4700
// begin clear_crates := true ;
4609: LD_ADDR_VAR 0 7
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// if not SeeXY ( you , crate_list [ 1 ] , crate_list [ 2 ] ) then
4617: LD_EXP 14
4621: PPUSH
4622: LD_EXP 32
4626: PUSH
4627: LD_INT 1
4629: ARRAY
4630: PPUSH
4631: LD_EXP 32
4635: PUSH
4636: LD_INT 2
4638: ARRAY
4639: PPUSH
4640: CALL_OW 293
4644: NOT
4645: IFFALSE 4700
// begin MoveAreaXY ( crates_end , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4647: LD_INT 34
4649: PPUSH
4650: LD_EXP 32
4654: PUSH
4655: LD_INT 1
4657: ARRAY
4658: PPUSH
4659: LD_EXP 32
4663: PUSH
4664: LD_INT 2
4666: ARRAY
4667: PPUSH
4668: CALL_OW 425
// EraseResourceArea ( crates_end , mat_cans ) ;
4672: LD_INT 34
4674: PPUSH
4675: LD_INT 1
4677: PPUSH
4678: CALL_OW 286
// AddResourceType ( GetBase ( ru_depot ) , mat_cans , 50 ) ;
4682: LD_INT 22
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 1
4692: PPUSH
4693: LD_INT 50
4695: PPUSH
4696: CALL_OW 276
// end ; end ; until ( not IsBusy ( un ) ) or clear_crates ;
4700: LD_VAR 0 1
4704: PPUSH
4705: CALL_OW 315
4709: NOT
4710: PUSH
4711: LD_VAR 0 7
4715: OR
4716: IFFALSE 4576
// if IsLive ( ru_collector ) then
4718: LD_EXP 29
4722: PPUSH
4723: CALL_OW 300
4727: IFFALSE 4761
// begin ComMoveUnit ( ru_collector , ru_depot ) ;
4729: LD_EXP 29
4733: PPUSH
4734: LD_INT 22
4736: PPUSH
4737: CALL_OW 112
// AddComExitVehicle ( ru_collector ) ;
4741: LD_EXP 29
4745: PPUSH
4746: CALL_OW 181
// ComReturn ( free_unit ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: CALL_OW 144
// end else
4759: GO 4956
// begin case old_class of class_mechanic :
4761: LD_VAR 0 8
4765: PUSH
4766: LD_INT 3
4768: DOUBLE
4769: EQUAL
4770: IFTRUE 4774
4772: GO 4826
4774: POP
// begin if IsOK ( ru_fact1 ) then
4775: LD_INT 1
4777: PPUSH
4778: CALL_OW 302
4782: IFFALSE 4798
// ComEnterUnit ( un , ru_fact1 ) else
4784: LD_VAR 0 1
4788: PPUSH
4789: LD_INT 1
4791: PPUSH
4792: CALL_OW 120
4796: GO 4810
// ComEnterUnit ( un , ru_fact2 ) ;
4798: LD_VAR 0 1
4802: PPUSH
4803: LD_INT 40
4805: PPUSH
4806: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4810: LD_VAR 0 1
4814: PPUSH
4815: LD_VAR 0 8
4819: PPUSH
4820: CALL_OW 183
// end ; class_scientistic :
4824: GO 4947
4826: LD_INT 4
4828: DOUBLE
4829: EQUAL
4830: IFTRUE 4834
4832: GO 4886
4834: POP
// begin if IsOK ( ru_lab1 ) then
4835: LD_INT 14
4837: PPUSH
4838: CALL_OW 302
4842: IFFALSE 4858
// ComEnterUnit ( un , ru_lab1 ) else
4844: LD_VAR 0 1
4848: PPUSH
4849: LD_INT 14
4851: PPUSH
4852: CALL_OW 120
4856: GO 4870
// ComEnterUnit ( un , ru_lab2 ) ;
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 15
4865: PPUSH
4866: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4870: LD_VAR 0 1
4874: PPUSH
4875: LD_VAR 0 8
4879: PPUSH
4880: CALL_OW 183
// end ; class_soldier :
4884: GO 4947
4886: LD_INT 1
4888: DOUBLE
4889: EQUAL
4890: IFTRUE 4894
4892: GO 4923
4894: POP
// begin ComEnterUnit ( un , ru_barac ) ;
4895: LD_VAR 0 1
4899: PPUSH
4900: LD_INT 45
4902: PPUSH
4903: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4907: LD_VAR 0 1
4911: PPUSH
4912: LD_VAR 0 8
4916: PPUSH
4917: CALL_OW 183
// end ; class_engineer :
4921: GO 4947
4923: LD_INT 2
4925: DOUBLE
4926: EQUAL
4927: IFTRUE 4931
4929: GO 4946
4931: POP
// ComMoveUnit ( un , ru_depot ) ; end ;
4932: LD_VAR 0 1
4936: PPUSH
4937: LD_INT 22
4939: PPUSH
4940: CALL_OW 112
4944: GO 4947
4946: POP
// AddComReturn ( un ) ;
4947: LD_VAR 0 1
4951: PPUSH
4952: CALL_OW 204
// end ; reserved_people := reserved_people diff free_unit ;
4956: LD_ADDR_EXP 31
4960: PUSH
4961: LD_EXP 31
4965: PUSH
4966: LD_VAR 0 2
4970: DIFF
4971: ST_TO_ADDR
// end ; enable ;
4972: ENABLE
// end ;
4973: PPOPN 9
4975: END
// function ukradni_macmillanovi_auto ; var un ; begin
4976: LD_INT 0
4978: PPUSH
4979: PPUSH
// for un in ru_sol do
4980: LD_ADDR_VAR 0 2
4984: PUSH
4985: LD_EXP 25
4989: PUSH
4990: FOR_IN
4991: IFFALSE 5020
// if IsOK ( un ) then
4993: LD_VAR 0 2
4997: PPUSH
4998: CALL_OW 302
5002: IFFALSE 5018
// ComEnterUnit ( un , truck1 ) ;
5004: LD_VAR 0 2
5008: PPUSH
5009: LD_EXP 8
5013: PPUSH
5014: CALL_OW 120
5018: GO 4990
5020: POP
5021: POP
// AddComAgressiveMove ( ru_sol , 69 , 35 ) ;
5022: LD_EXP 25
5026: PPUSH
5027: LD_INT 69
5029: PPUSH
5030: LD_INT 35
5032: PPUSH
5033: CALL_OW 174
// AddComReturn ( ru_sol ) ;
5037: LD_EXP 25
5041: PPUSH
5042: CALL_OW 204
// wait ( 0 0$20 ) ;
5046: LD_INT 700
5048: PPUSH
5049: CALL_OW 67
// end ;
5053: LD_VAR 0 1
5057: RET
// every 6 6$0 do var way_ru_patrol , x , y , i , max ;
5058: GO 5060
5060: DISABLE
5061: LD_INT 0
5063: PPUSH
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
// begin way_ru_patrol := [ 88 , 47 , 69 , 36 , 42 , 16 , 33 , 14 , 16 , 6 , 6 , 6 , 19 , 29 , 34 , 38 , 47 , 42 , 44 , 27 , 61 , 45 , 66 , 33 , 110 , 58 ] ;
5068: LD_ADDR_VAR 0 1
5072: PUSH
5073: LD_INT 88
5075: PUSH
5076: LD_INT 47
5078: PUSH
5079: LD_INT 69
5081: PUSH
5082: LD_INT 36
5084: PUSH
5085: LD_INT 42
5087: PUSH
5088: LD_INT 16
5090: PUSH
5091: LD_INT 33
5093: PUSH
5094: LD_INT 14
5096: PUSH
5097: LD_INT 16
5099: PUSH
5100: LD_INT 6
5102: PUSH
5103: LD_INT 6
5105: PUSH
5106: LD_INT 6
5108: PUSH
5109: LD_INT 19
5111: PUSH
5112: LD_INT 29
5114: PUSH
5115: LD_INT 34
5117: PUSH
5118: LD_INT 38
5120: PUSH
5121: LD_INT 47
5123: PUSH
5124: LD_INT 42
5126: PUSH
5127: LD_INT 44
5129: PUSH
5130: LD_INT 27
5132: PUSH
5133: LD_INT 61
5135: PUSH
5136: LD_INT 45
5138: PUSH
5139: LD_INT 66
5141: PUSH
5142: LD_INT 33
5144: PUSH
5145: LD_INT 110
5147: PUSH
5148: LD_INT 58
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: ST_TO_ADDR
// ComRemember ( ru_sol ) ;
5179: LD_EXP 25
5183: PPUSH
5184: CALL_OW 143
// reserved_people := reserved_people ^ ru_sol ;
5188: LD_ADDR_EXP 31
5192: PUSH
5193: LD_EXP 31
5197: PUSH
5198: LD_EXP 25
5202: ADD
5203: ST_TO_ADDR
// max := 0 + way_ru_patrol ;
5204: LD_ADDR_VAR 0 5
5208: PUSH
5209: LD_INT 0
5211: PUSH
5212: LD_VAR 0 1
5216: PLUS
5217: ST_TO_ADDR
// for i := 1 to ( max div 2 ) do
5218: LD_ADDR_VAR 0 4
5222: PUSH
5223: DOUBLE
5224: LD_INT 1
5226: DEC
5227: ST_TO_ADDR
5228: LD_VAR 0 5
5232: PUSH
5233: LD_INT 2
5235: DIV
5236: PUSH
5237: FOR_TO
5238: IFFALSE 5305
// begin x := way_ru_patrol [ ( 2 * i ) - 1 ] ;
5240: LD_ADDR_VAR 0 2
5244: PUSH
5245: LD_VAR 0 1
5249: PUSH
5250: LD_INT 2
5252: PUSH
5253: LD_VAR 0 4
5257: MUL
5258: PUSH
5259: LD_INT 1
5261: MINUS
5262: ARRAY
5263: ST_TO_ADDR
// y := way_ru_patrol [ ( 2 * i ) ] ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: LD_VAR 0 1
5273: PUSH
5274: LD_INT 2
5276: PUSH
5277: LD_VAR 0 4
5281: MUL
5282: ARRAY
5283: ST_TO_ADDR
// AddComAgressiveMove ( ru_sol , x , y ) ;
5284: LD_EXP 25
5288: PPUSH
5289: LD_VAR 0 2
5293: PPUSH
5294: LD_VAR 0 3
5298: PPUSH
5299: CALL_OW 174
// end ;
5303: GO 5237
5305: POP
5306: POP
// repeat if See ( russians , truck1 ) then
5307: LD_EXP 15
5311: PPUSH
5312: LD_EXP 8
5316: PPUSH
5317: CALL_OW 292
5321: IFFALSE 5327
// ukradni_macmillanovi_auto ;
5323: CALL 4976 0 0
// wait ( 0 0$1 ) ;
5327: LD_INT 35
5329: PPUSH
5330: CALL_OW 67
// until at_home ( ru_sol ) ;
5334: LD_EXP 25
5338: PPUSH
5339: CALL 5364 0 1
5343: IFFALSE 5307
// reserved_people := reserved_people diff ru_sol ;
5345: LD_ADDR_EXP 31
5349: PUSH
5350: LD_EXP 31
5354: PUSH
5355: LD_EXP 25
5359: DIFF
5360: ST_TO_ADDR
// end ;
5361: PPOPN 5
5363: END
// function at_home ( list ) ; var un , vysledek ; begin
5364: LD_INT 0
5366: PPUSH
5367: PPUSH
5368: PPUSH
// vysledek := true ;
5369: LD_ADDR_VAR 0 4
5373: PUSH
5374: LD_INT 1
5376: ST_TO_ADDR
// for un in list do
5377: LD_ADDR_VAR 0 3
5381: PUSH
5382: LD_VAR 0 1
5386: PUSH
5387: FOR_IN
5388: IFFALSE 5428
// if IsOK ( un ) and not IsInArea ( un , RU_Base ) then
5390: LD_VAR 0 3
5394: PPUSH
5395: CALL_OW 302
5399: PUSH
5400: LD_VAR 0 3
5404: PPUSH
5405: LD_INT 2
5407: PPUSH
5408: CALL_OW 308
5412: NOT
5413: AND
5414: IFFALSE 5426
// begin vysledek := false ;
5416: LD_ADDR_VAR 0 4
5420: PUSH
5421: LD_INT 0
5423: ST_TO_ADDR
// break ;
5424: GO 5428
// end ;
5426: GO 5387
5428: POP
5429: POP
// result := vysledek ;
5430: LD_ADDR_VAR 0 2
5434: PUSH
5435: LD_VAR 0 4
5439: ST_TO_ADDR
// end ; end_of_file
5440: LD_VAR 0 2
5444: RET
// export odpoved ; export visit_base ; var dialogue_running ; export function starting_scene ; var x , y ; begin
5445: LD_INT 0
5447: PPUSH
5448: PPUSH
5449: PPUSH
// CenterNowOnUnits ( truck1 ) ;
5450: LD_EXP 8
5454: PPUSH
5455: CALL_OW 87
// interface_hidden := true ;
5459: LD_ADDR_OWVAR 54
5463: PUSH
5464: LD_INT 1
5466: ST_TO_ADDR
// InGameOn ;
5467: CALL_OW 8
// ComMoveXY ( truck1 , 20 , 7 ) ;
5471: LD_EXP 8
5475: PPUSH
5476: LD_INT 20
5478: PPUSH
5479: LD_INT 7
5481: PPUSH
5482: CALL_OW 111
// AddComMoveXY ( truck1 , 27 , 10 ) ;
5486: LD_EXP 8
5490: PPUSH
5491: LD_INT 27
5493: PPUSH
5494: LD_INT 10
5496: PPUSH
5497: CALL_OW 171
// AddComMoveXY ( truck1 , 37 , 16 ) ;
5501: LD_EXP 8
5505: PPUSH
5506: LD_INT 37
5508: PPUSH
5509: LD_INT 16
5511: PPUSH
5512: CALL_OW 171
// wait ( 0 0$3 ) ;
5516: LD_INT 105
5518: PPUSH
5519: CALL_OW 67
// async ;
5523: ASYNC
// SayRadio ( Powell , D1-Pow-1 ) ;
5524: LD_EXP 2
5528: PPUSH
5529: LD_STRING D1-Pow-1
5531: PPUSH
5532: CALL_OW 94
// sync ;
5536: SYNC
// wait ( 0 0$2 ) ;
5537: LD_INT 70
5539: PPUSH
5540: CALL_OW 67
// ComStop ( MacMillan ) ;
5544: LD_EXP 1
5548: PPUSH
5549: CALL_OW 141
// ComExitVehicle ( truck1 ) ;
5553: LD_EXP 8
5557: PPUSH
5558: CALL_OW 121
// x := GetX ( MacMillan ) + 10 ;
5562: LD_ADDR_VAR 0 2
5566: PUSH
5567: LD_EXP 1
5571: PPUSH
5572: CALL_OW 250
5576: PUSH
5577: LD_INT 10
5579: PLUS
5580: ST_TO_ADDR
// y := GetY ( MacMillan ) + 10 ;
5581: LD_ADDR_VAR 0 3
5585: PUSH
5586: LD_EXP 1
5590: PPUSH
5591: CALL_OW 251
5595: PUSH
5596: LD_INT 10
5598: PLUS
5599: ST_TO_ADDR
// ComMoveXY ( MacMillan , x , y ) ;
5600: LD_EXP 1
5604: PPUSH
5605: LD_VAR 0 2
5609: PPUSH
5610: LD_VAR 0 3
5614: PPUSH
5615: CALL_OW 111
// wait ( 0 0$2 ) ;
5619: LD_INT 70
5621: PPUSH
5622: CALL_OW 67
// InGameOff ;
5626: CALL_OW 9
// DialogueOn ;
5630: CALL_OW 6
// interface_hidden := true ;
5634: LD_ADDR_OWVAR 54
5638: PUSH
5639: LD_INT 1
5641: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
5642: LD_EXP 1
5646: PPUSH
5647: LD_STRING D1-JMM-1
5649: PPUSH
5650: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
5654: LD_EXP 2
5658: PPUSH
5659: LD_STRING D1-Pow-2
5661: PPUSH
5662: CALL_OW 94
// Say ( MacMillan , D1-JMM-2 ) ;
5666: LD_EXP 1
5670: PPUSH
5671: LD_STRING D1-JMM-2
5673: PPUSH
5674: CALL_OW 88
// SaveForQuickRestart ;
5678: CALL_OW 22
// wait ( 0 0$0.5 ) ;
5682: LD_INT 18
5684: PPUSH
5685: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5689: LD_STRING M1
5691: PPUSH
5692: CALL_OW 337
// DialogueOff ;
5696: CALL_OW 7
// interface_hidden := false ;
5700: LD_ADDR_OWVAR 54
5704: PUSH
5705: LD_INT 0
5707: ST_TO_ADDR
// dialogue_running := false ;
5708: LD_ADDR_LOC 3
5712: PUSH
5713: LD_INT 0
5715: ST_TO_ADDR
// end ;
5716: LD_VAR 0 1
5720: RET
// function odpoved_joan ; begin
5721: LD_INT 0
5723: PPUSH
// case odpoved of 1 :
5724: LD_EXP 33
5728: PUSH
5729: LD_INT 1
5731: DOUBLE
5732: EQUAL
5733: IFTRUE 5737
5735: GO 5776
5737: POP
// begin Say ( MacMillan , D2Ja-JMM-1 ) ;
5738: LD_EXP 1
5742: PPUSH
5743: LD_STRING D2Ja-JMM-1
5745: PPUSH
5746: CALL_OW 88
// SayRadio ( Joan , D2Ja-Joan-1 ) ;
5750: LD_EXP 3
5754: PPUSH
5755: LD_STRING D2Ja-Joan-1
5757: PPUSH
5758: CALL_OW 94
// Say ( MacMillan , D2Ja-JMM-2 ) ;
5762: LD_EXP 1
5766: PPUSH
5767: LD_STRING D2Ja-JMM-2
5769: PPUSH
5770: CALL_OW 88
// end ; 2 :
5774: GO 5871
5776: LD_INT 2
5778: DOUBLE
5779: EQUAL
5780: IFTRUE 5784
5782: GO 5847
5784: POP
// begin Say ( MacMillan , D2Jb-JMM-1 ) ;
5785: LD_EXP 1
5789: PPUSH
5790: LD_STRING D2Jb-JMM-1
5792: PPUSH
5793: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-1 ) ;
5797: LD_EXP 3
5801: PPUSH
5802: LD_STRING D2Jb-Joan-1
5804: PPUSH
5805: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-2 ) ;
5809: LD_EXP 1
5813: PPUSH
5814: LD_STRING D2Jb-JMM-2
5816: PPUSH
5817: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-2 ) ;
5821: LD_EXP 3
5825: PPUSH
5826: LD_STRING D2Jb-Joan-2
5828: PPUSH
5829: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-3 ) ;
5833: LD_EXP 1
5837: PPUSH
5838: LD_STRING D2Jb-JMM-3
5840: PPUSH
5841: CALL_OW 88
// end ; 3 :
5845: GO 5871
5847: LD_INT 3
5849: DOUBLE
5850: EQUAL
5851: IFTRUE 5855
5853: GO 5870
5855: POP
// begin SayRadio ( Joan , D2Jc-Joan-1 ) ;
5856: LD_EXP 3
5860: PPUSH
5861: LD_STRING D2Jc-Joan-1
5863: PPUSH
5864: CALL_OW 94
// end ; end ;
5868: GO 5871
5870: POP
// end ;
5871: LD_VAR 0 1
5875: RET
// function odpoved_lisa ; begin
5876: LD_INT 0
5878: PPUSH
// case odpoved of 1 :
5879: LD_EXP 33
5883: PUSH
5884: LD_INT 1
5886: DOUBLE
5887: EQUAL
5888: IFTRUE 5892
5890: GO 5955
5892: POP
// begin Say ( MacMillan , D2La-JMM-1 ) ;
5893: LD_EXP 1
5897: PPUSH
5898: LD_STRING D2La-JMM-1
5900: PPUSH
5901: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-1 ) ;
5905: LD_EXP 4
5909: PPUSH
5910: LD_STRING D2La-Lisa-1
5912: PPUSH
5913: CALL_OW 94
// Say ( MacMillan , D2La-JMM-2 ) ;
5917: LD_EXP 1
5921: PPUSH
5922: LD_STRING D2La-JMM-2
5924: PPUSH
5925: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-2 ) ;
5929: LD_EXP 4
5933: PPUSH
5934: LD_STRING D2La-Lisa-2
5936: PPUSH
5937: CALL_OW 94
// Say ( MacMillan , D2La-JMM-3 ) ;
5941: LD_EXP 1
5945: PPUSH
5946: LD_STRING D2La-JMM-3
5948: PPUSH
5949: CALL_OW 88
// end ; 2 :
5953: GO 6038
5955: LD_INT 2
5957: DOUBLE
5958: EQUAL
5959: IFTRUE 5963
5961: GO 6014
5963: POP
// begin Say ( MacMillan , D2Lb-JMM-1 ) ;
5964: LD_EXP 1
5968: PPUSH
5969: LD_STRING D2Lb-JMM-1
5971: PPUSH
5972: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-1 ) ;
5976: LD_EXP 4
5980: PPUSH
5981: LD_STRING D2Lb-Lisa-1
5983: PPUSH
5984: CALL_OW 94
// Say ( MacMillan , D2Lb-JMM-2 ) ;
5988: LD_EXP 1
5992: PPUSH
5993: LD_STRING D2Lb-JMM-2
5995: PPUSH
5996: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-2 ) ;
6000: LD_EXP 4
6004: PPUSH
6005: LD_STRING D2Lb-Lisa-2
6007: PPUSH
6008: CALL_OW 94
// end ; 3 :
6012: GO 6038
6014: LD_INT 3
6016: DOUBLE
6017: EQUAL
6018: IFTRUE 6022
6020: GO 6037
6022: POP
// begin SayRadio ( Lisa , D2Lc-Lisa-1 ) ;
6023: LD_EXP 4
6027: PPUSH
6028: LD_STRING D2Lc-Lisa-1
6030: PPUSH
6031: CALL_OW 94
// end ; end ;
6035: GO 6038
6037: POP
// end ;
6038: LD_VAR 0 1
6042: RET
// function odpoved_anezka ; begin
6043: LD_INT 0
6045: PPUSH
// case odpoved of 1 :
6046: LD_EXP 33
6050: PUSH
6051: LD_INT 1
6053: DOUBLE
6054: EQUAL
6055: IFTRUE 6059
6057: GO 6074
6059: POP
// begin Say ( MacMillan , D2Xa-JMM-1 ) ;
6060: LD_EXP 1
6064: PPUSH
6065: LD_STRING D2Xa-JMM-1
6067: PPUSH
6068: CALL_OW 88
// end ; 2 :
6072: GO 6133
6074: LD_INT 2
6076: DOUBLE
6077: EQUAL
6078: IFTRUE 6082
6080: GO 6109
6082: POP
// begin Say ( MacMillan , D2Xb-JMM-1 ) ;
6083: LD_EXP 1
6087: PPUSH
6088: LD_STRING D2Xb-JMM-1
6090: PPUSH
6091: CALL_OW 88
// SayRadio ( anezka , D2Xb-Con-1 ) ;
6095: LD_EXP 5
6099: PPUSH
6100: LD_STRING D2Xb-Con-1
6102: PPUSH
6103: CALL_OW 94
// end ; 3 :
6107: GO 6133
6109: LD_INT 3
6111: DOUBLE
6112: EQUAL
6113: IFTRUE 6117
6115: GO 6132
6117: POP
// begin SayRadio ( anezka , D2Xc-Con-1 ) ;
6118: LD_EXP 5
6122: PPUSH
6123: LD_STRING D2Xc-Con-1
6125: PPUSH
6126: CALL_OW 94
// end ; end ;
6130: GO 6133
6132: POP
// end ;
6133: LD_VAR 0 1
6137: RET
// every 0 0$1 trigger IsInArea ( MacMillan , help_calling ) and ( not visit_base ) do
6138: LD_EXP 1
6142: PPUSH
6143: LD_INT 5
6145: PPUSH
6146: CALL_OW 308
6150: PUSH
6151: LD_EXP 34
6155: NOT
6156: AND
6157: IFFALSE 6563
6159: GO 6161
6161: DISABLE
// begin DialogueOn ;
6162: CALL_OW 6
// interface_hidden := true ;
6166: LD_ADDR_OWVAR 54
6170: PUSH
6171: LD_INT 1
6173: ST_TO_ADDR
// case who_survive of 1 :
6174: LD_EXP 7
6178: PUSH
6179: LD_INT 1
6181: DOUBLE
6182: EQUAL
6183: IFTRUE 6187
6185: GO 6202
6187: POP
// SayRadio ( Joan , D2J-Joan-1 ) ; 2 :
6188: LD_EXP 3
6192: PPUSH
6193: LD_STRING D2J-Joan-1
6195: PPUSH
6196: CALL_OW 94
6200: GO 6249
6202: LD_INT 2
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6225
6210: POP
// SayRadio ( Lisa , D2L-Lisa-1 ) ; 3 :
6211: LD_EXP 4
6215: PPUSH
6216: LD_STRING D2L-Lisa-1
6218: PPUSH
6219: CALL_OW 94
6223: GO 6249
6225: LD_INT 3
6227: DOUBLE
6228: EQUAL
6229: IFTRUE 6233
6231: GO 6248
6233: POP
// SayRadio ( anezka , D2X-Con-1 ) ; end ;
6234: LD_EXP 5
6238: PPUSH
6239: LD_STRING D2X-Con-1
6241: PPUSH
6242: CALL_OW 94
6246: GO 6249
6248: POP
// if Query ( Q1 ) = 2 then
6249: LD_STRING Q1
6251: PPUSH
6252: CALL_OW 97
6256: PUSH
6257: LD_INT 2
6259: EQUAL
6260: IFFALSE 6276
// begin DialogueOff ;
6262: CALL_OW 7
// interface_hidden := false ;
6266: LD_ADDR_OWVAR 54
6270: PUSH
6271: LD_INT 0
6273: ST_TO_ADDR
// exit ;
6274: GO 6563
// end ; case who_survive of 1 :
6276: LD_EXP 7
6280: PUSH
6281: LD_INT 1
6283: DOUBLE
6284: EQUAL
6285: IFTRUE 6289
6287: GO 6340
6289: POP
// begin Say ( MacMillan , D2J-JMM-1 ) ;
6290: LD_EXP 1
6294: PPUSH
6295: LD_STRING D2J-JMM-1
6297: PPUSH
6298: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-2 ) ;
6302: LD_EXP 3
6306: PPUSH
6307: LD_STRING D2J-Joan-2
6309: PPUSH
6310: CALL_OW 94
// Say ( MacMillan , D2J-JMM-2 ) ;
6314: LD_EXP 1
6318: PPUSH
6319: LD_STRING D2J-JMM-2
6321: PPUSH
6322: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-3 ) ;
6326: LD_EXP 3
6330: PPUSH
6331: LD_STRING D2J-Joan-3
6333: PPUSH
6334: CALL_OW 94
// end ; 2 :
6338: GO 6435
6340: LD_INT 2
6342: DOUBLE
6343: EQUAL
6344: IFTRUE 6348
6346: GO 6399
6348: POP
// begin Say ( MacMillan , D2L-JMM-1 ) ;
6349: LD_EXP 1
6353: PPUSH
6354: LD_STRING D2L-JMM-1
6356: PPUSH
6357: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-2 ) ;
6361: LD_EXP 4
6365: PPUSH
6366: LD_STRING D2L-Lisa-2
6368: PPUSH
6369: CALL_OW 94
// Say ( MacMillan , D2L-JMM-2 ) ;
6373: LD_EXP 1
6377: PPUSH
6378: LD_STRING D2L-JMM-2
6380: PPUSH
6381: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-3 ) ;
6385: LD_EXP 4
6389: PPUSH
6390: LD_STRING D2L-Lisa-3
6392: PPUSH
6393: CALL_OW 94
// end ; 3 :
6397: GO 6435
6399: LD_INT 3
6401: DOUBLE
6402: EQUAL
6403: IFTRUE 6407
6405: GO 6434
6407: POP
// begin Say ( MacMillan , D2X-JMM-1 ) ;
6408: LD_EXP 1
6412: PPUSH
6413: LD_STRING D2X-JMM-1
6415: PPUSH
6416: CALL_OW 88
// SayRadio ( anezka , D2X-Con-2 ) ;
6420: LD_EXP 5
6424: PPUSH
6425: LD_STRING D2X-Con-2
6427: PPUSH
6428: CALL_OW 94
// end ; end ;
6432: GO 6435
6434: POP
// wait ( 0 0$1 ) ;
6435: LD_INT 35
6437: PPUSH
6438: CALL_OW 67
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6442: LD_EXP 2
6446: PPUSH
6447: LD_STRING DPowell-Pow-1
6449: PPUSH
6450: CALL_OW 94
// wait ( 0 0$1 ) ;
6454: LD_INT 35
6456: PPUSH
6457: CALL_OW 67
// case who_survive of 1 :
6461: LD_EXP 7
6465: PUSH
6466: LD_INT 1
6468: DOUBLE
6469: EQUAL
6470: IFTRUE 6474
6472: GO 6494
6474: POP
// begin odpoved := Query ( Q2J ) ;
6475: LD_ADDR_EXP 33
6479: PUSH
6480: LD_STRING Q2J
6482: PPUSH
6483: CALL_OW 97
6487: ST_TO_ADDR
// odpoved_joan ;
6488: CALL 5721 0 0
// end ; 2 :
6492: GO 6551
6494: LD_INT 2
6496: DOUBLE
6497: EQUAL
6498: IFTRUE 6502
6500: GO 6522
6502: POP
// begin odpoved := Query ( Q2L ) ;
6503: LD_ADDR_EXP 33
6507: PUSH
6508: LD_STRING Q2L
6510: PPUSH
6511: CALL_OW 97
6515: ST_TO_ADDR
// odpoved_lisa ;
6516: CALL 5876 0 0
// end ; 3 :
6520: GO 6551
6522: LD_INT 3
6524: DOUBLE
6525: EQUAL
6526: IFTRUE 6530
6528: GO 6550
6530: POP
// begin odpoved := Query ( Q2X ) ;
6531: LD_ADDR_EXP 33
6535: PUSH
6536: LD_STRING Q2X
6538: PPUSH
6539: CALL_OW 97
6543: ST_TO_ADDR
// odpoved_anezka ;
6544: CALL 6043 0 0
// end ; end ;
6548: GO 6551
6550: POP
// DialogueOff ;
6551: CALL_OW 7
// interface_hidden := false ;
6555: LD_ADDR_OWVAR 54
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// end ;
6563: END
// every 0 0$1 trigger IsInArea ( MacMillan , US_base ) do var dist , list ;
6564: LD_EXP 1
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: CALL_OW 308
6576: IFFALSE 7291
6578: GO 6580
6580: DISABLE
6581: LD_INT 0
6583: PPUSH
6584: PPUSH
// begin ComMoveUnit ( survivor , MacMillan ) ;
6585: LD_EXP 6
6589: PPUSH
6590: LD_EXP 1
6594: PPUSH
6595: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6599: LD_INT 35
6601: PPUSH
6602: CALL_OW 67
// until See ( you , survivor ) ;
6606: LD_EXP 14
6610: PPUSH
6611: LD_EXP 6
6615: PPUSH
6616: CALL_OW 292
6620: IFFALSE 6599
// SetSideBase ( GetBase ( us_depot ) , you ) ;
6622: LD_INT 48
6624: PPUSH
6625: CALL_OW 274
6629: PPUSH
6630: LD_EXP 14
6634: PPUSH
6635: CALL_OW 236
// SetSide ( survivor , you ) ;
6639: LD_EXP 6
6643: PPUSH
6644: LD_EXP 14
6648: PPUSH
6649: CALL_OW 235
// SetSide ( us_trucks , you ) ;
6653: LD_EXP 35
6657: PPUSH
6658: LD_EXP 14
6662: PPUSH
6663: CALL_OW 235
// list := FilterAllUnits ( [ [ f_side , neutral ] , [ f_class , class_apeman_engineer ] ] ) ;
6667: LD_ADDR_VAR 0 2
6671: PUSH
6672: LD_INT 22
6674: PUSH
6675: LD_EXP 16
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: LD_INT 25
6686: PUSH
6687: LD_INT 16
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PPUSH
6698: CALL_OW 69
6702: ST_TO_ADDR
// SetSide ( list , you ) ;
6703: LD_VAR 0 2
6707: PPUSH
6708: LD_EXP 14
6712: PPUSH
6713: CALL_OW 235
// visit_base := true ;
6717: LD_ADDR_EXP 34
6721: PUSH
6722: LD_INT 1
6724: ST_TO_ADDR
// InGameOn ;
6725: CALL_OW 8
// if IsOK ( Joan ) then
6729: LD_EXP 3
6733: PPUSH
6734: CALL_OW 302
6738: IFFALSE 6754
// begin dist := 1 ;
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_INT 1
6747: ST_TO_ADDR
// SA_HelpJoan ;
6748: CALL 17426 0 0
// end else
6752: GO 6762
// dist := 3 ;
6754: LD_ADDR_VAR 0 1
6758: PUSH
6759: LD_INT 3
6761: ST_TO_ADDR
// list := TICK ;
6762: LD_ADDR_VAR 0 2
6766: PUSH
6767: LD_OWVAR 1
6771: ST_TO_ADDR
// while ( GetDistUnits ( MacMillan , survivor ) > dist ) and ( ( list + 0 0$6 ) > TICK ) do
6772: LD_EXP 1
6776: PPUSH
6777: LD_EXP 6
6781: PPUSH
6782: CALL_OW 296
6786: PUSH
6787: LD_VAR 0 1
6791: GREATER
6792: PUSH
6793: LD_VAR 0 2
6797: PUSH
6798: LD_INT 210
6800: PLUS
6801: PUSH
6802: LD_OWVAR 1
6806: GREATER
6807: AND
6808: IFFALSE 6865
// begin ComMoveUnit ( survivor , MacMillan ) ;
6810: LD_EXP 6
6814: PPUSH
6815: LD_EXP 1
6819: PPUSH
6820: CALL_OW 112
// ComMoveUnit ( MacMillan , survivor ) ;
6824: LD_EXP 1
6828: PPUSH
6829: LD_EXP 6
6833: PPUSH
6834: CALL_OW 112
// wait ( 20 ) ;
6838: LD_INT 20
6840: PPUSH
6841: CALL_OW 67
// CenterOnUnits ( [ MacMillan , survivor ] ) ;
6845: LD_EXP 1
6849: PUSH
6850: LD_EXP 6
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: PPUSH
6859: CALL_OW 85
// end ;
6863: GO 6772
// ComStop ( [ MacMillan , survivor ] ) ;
6865: LD_EXP 1
6869: PUSH
6870: LD_EXP 6
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 141
// ComTurnUnit ( survivor , MacMillan ) ;
6883: LD_EXP 6
6887: PPUSH
6888: LD_EXP 1
6892: PPUSH
6893: CALL_OW 119
// ComTurnUnit ( MacMillan , survivor ) ;
6897: LD_EXP 1
6901: PPUSH
6902: LD_EXP 6
6906: PPUSH
6907: CALL_OW 119
// wait ( 5 ) ;
6911: LD_INT 5
6913: PPUSH
6914: CALL_OW 67
// InGameOff ;
6918: CALL_OW 9
// DialogueOn ;
6922: CALL_OW 6
// interface_hidden := true ;
6926: LD_ADDR_OWVAR 54
6930: PUSH
6931: LD_INT 1
6933: ST_TO_ADDR
// case who_survive of 1 :
6934: LD_EXP 7
6938: PUSH
6939: LD_INT 1
6941: DOUBLE
6942: EQUAL
6943: IFTRUE 6947
6945: GO 7005
6947: POP
// begin Say ( Joan , D3J-Joan-1 ) ;
6948: LD_EXP 3
6952: PPUSH
6953: LD_STRING D3J-Joan-1
6955: PPUSH
6956: CALL_OW 88
// Say ( MacMillan , D3J-JMM-1 ) ;
6960: LD_EXP 1
6964: PPUSH
6965: LD_STRING D3J-JMM-1
6967: PPUSH
6968: CALL_OW 88
// Say ( Joan , D3J-Joan-2 ) ;
6972: LD_EXP 3
6976: PPUSH
6977: LD_STRING D3J-Joan-2
6979: PPUSH
6980: CALL_OW 88
// Say ( MacMillan , D3J-JMM-2 ) ;
6984: LD_EXP 1
6988: PPUSH
6989: LD_STRING D3J-JMM-2
6991: PPUSH
6992: CALL_OW 88
// ChangeMissionObjectives ( M2J ) ;
6996: LD_STRING M2J
6998: PPUSH
6999: CALL_OW 337
// end ; 2 :
7003: GO 7102
7005: LD_INT 2
7007: DOUBLE
7008: EQUAL
7009: IFTRUE 7013
7011: GO 7071
7013: POP
// begin Say ( Lisa , D3L-Lisa-1 ) ;
7014: LD_EXP 4
7018: PPUSH
7019: LD_STRING D3L-Lisa-1
7021: PPUSH
7022: CALL_OW 88
// Say ( MacMillan , D3L-JMM-1 ) ;
7026: LD_EXP 1
7030: PPUSH
7031: LD_STRING D3L-JMM-1
7033: PPUSH
7034: CALL_OW 88
// Say ( Lisa , D3L-Lisa-2 ) ;
7038: LD_EXP 4
7042: PPUSH
7043: LD_STRING D3L-Lisa-2
7045: PPUSH
7046: CALL_OW 88
// Say ( MacMillan , D3L-JMM-2 ) ;
7050: LD_EXP 1
7054: PPUSH
7055: LD_STRING D3L-JMM-2
7057: PPUSH
7058: CALL_OW 88
// ChangeMissionObjectives ( M2L ) ;
7062: LD_STRING M2L
7064: PPUSH
7065: CALL_OW 337
// end ; 3 :
7069: GO 7102
7071: LD_INT 3
7073: DOUBLE
7074: EQUAL
7075: IFTRUE 7079
7077: GO 7101
7079: POP
// begin Say ( anezka , D3X-Con-1 ) ;
7080: LD_EXP 5
7084: PPUSH
7085: LD_STRING D3X-Con-1
7087: PPUSH
7088: CALL_OW 88
// ChangeMissionObjectives ( M2X ) ;
7092: LD_STRING M2X
7094: PPUSH
7095: CALL_OW 337
// end ; end ;
7099: GO 7102
7101: POP
// Say ( MacMillan , D4-JMM-1 ) ;
7102: LD_EXP 1
7106: PPUSH
7107: LD_STRING D4-JMM-1
7109: PPUSH
7110: CALL_OW 88
// case who_survive of 1 :
7114: LD_EXP 7
7118: PUSH
7119: LD_INT 1
7121: DOUBLE
7122: EQUAL
7123: IFTRUE 7127
7125: GO 7142
7127: POP
// Say ( Joan , D4-Joan-1 ) ; 2 :
7128: LD_EXP 3
7132: PPUSH
7133: LD_STRING D4-Joan-1
7135: PPUSH
7136: CALL_OW 88
7140: GO 7189
7142: LD_INT 2
7144: DOUBLE
7145: EQUAL
7146: IFTRUE 7150
7148: GO 7165
7150: POP
// Say ( Lisa , D4-Lisa-1 ) ; 3 :
7151: LD_EXP 4
7155: PPUSH
7156: LD_STRING D4-Lisa-1
7158: PPUSH
7159: CALL_OW 88
7163: GO 7189
7165: LD_INT 3
7167: DOUBLE
7168: EQUAL
7169: IFTRUE 7173
7171: GO 7188
7173: POP
// Say ( Anezka , D4-Con-1 ) ; end ;
7174: LD_EXP 5
7178: PPUSH
7179: LD_STRING D4-Con-1
7181: PPUSH
7182: CALL_OW 88
7186: GO 7189
7188: POP
// Say ( MacMillan , D4-JMM-2 ) ;
7189: LD_EXP 1
7193: PPUSH
7194: LD_STRING D4-JMM-2
7196: PPUSH
7197: CALL_OW 88
// case who_survive of 1 :
7201: LD_EXP 7
7205: PUSH
7206: LD_INT 1
7208: DOUBLE
7209: EQUAL
7210: IFTRUE 7214
7212: GO 7229
7214: POP
// Say ( Joan , D4-Joan-2 ) ; 2 :
7215: LD_EXP 3
7219: PPUSH
7220: LD_STRING D4-Joan-2
7222: PPUSH
7223: CALL_OW 88
7227: GO 7276
7229: LD_INT 2
7231: DOUBLE
7232: EQUAL
7233: IFTRUE 7237
7235: GO 7252
7237: POP
// Say ( Lisa , D4-Lisa-2 ) ; 3 :
7238: LD_EXP 4
7242: PPUSH
7243: LD_STRING D4-Lisa-2
7245: PPUSH
7246: CALL_OW 88
7250: GO 7276
7252: LD_INT 3
7254: DOUBLE
7255: EQUAL
7256: IFTRUE 7260
7258: GO 7275
7260: POP
// Say ( Anezka , D4-Con-2 ) ; end ;
7261: LD_EXP 5
7265: PPUSH
7266: LD_STRING D4-Con-2
7268: PPUSH
7269: CALL_OW 88
7273: GO 7276
7275: POP
// DialogueOff ;
7276: CALL_OW 7
// interface_hidden := false ;
7280: LD_ADDR_OWVAR 54
7284: PUSH
7285: LD_INT 0
7287: ST_TO_ADDR
// enable ( 11 ) ;
7288: LD_INT 11
7290: ENABLE_MARKED
// end ;
7291: PPOPN 2
7293: END
// every 0 0$1 trigger IsSelected ( us_trucks ) marked 11 do
7294: LD_EXP 35
7298: PPUSH
7299: CALL_OW 306
7303: IFFALSE 7478
7305: GO 7307
7307: DISABLE
// begin if FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_control_tower ] ] ) then
7308: LD_INT 22
7310: PUSH
7311: LD_EXP 14
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: LD_INT 30
7322: PUSH
7323: LD_INT 36
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL_OW 69
7338: IFFALSE 7342
// exit ;
7340: GO 7478
// while dialogue_running do
7342: LD_LOC 3
7346: IFFALSE 7357
// wait ( 0 0$1 ) ;
7348: LD_INT 35
7350: PPUSH
7351: CALL_OW 67
7355: GO 7342
// dialogue_running := true ;
7357: LD_ADDR_LOC 3
7361: PUSH
7362: LD_INT 1
7364: ST_TO_ADDR
// DisableExclamations ;
7365: CALL_OW 474
// Say ( MacMillan , D5-JMM-1 ) ;
7369: LD_EXP 1
7373: PPUSH
7374: LD_STRING D5-JMM-1
7376: PPUSH
7377: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7381: LD_INT 77
7383: PPUSH
7384: LD_INT 87
7386: PPUSH
7387: CALL_OW 84
// case who_survive of 1 :
7391: LD_EXP 7
7395: PUSH
7396: LD_INT 1
7398: DOUBLE
7399: EQUAL
7400: IFTRUE 7404
7402: GO 7419
7404: POP
// Say ( Joan , D5-Joan-1 ) ; 2 :
7405: LD_EXP 3
7409: PPUSH
7410: LD_STRING D5-Joan-1
7412: PPUSH
7413: CALL_OW 88
7417: GO 7466
7419: LD_INT 2
7421: DOUBLE
7422: EQUAL
7423: IFTRUE 7427
7425: GO 7442
7427: POP
// Say ( Lisa , D5-Lisa-1 ) ; 3 :
7428: LD_EXP 4
7432: PPUSH
7433: LD_STRING D5-Lisa-1
7435: PPUSH
7436: CALL_OW 88
7440: GO 7466
7442: LD_INT 3
7444: DOUBLE
7445: EQUAL
7446: IFTRUE 7450
7448: GO 7465
7450: POP
// Say ( Anezka , D5-Con-1 ) ; end ;
7451: LD_EXP 5
7455: PPUSH
7456: LD_STRING D5-Con-1
7458: PPUSH
7459: CALL_OW 88
7463: GO 7466
7465: POP
// EnableExclamations ;
7466: CALL_OW 473
// dialogue_running := false ;
7470: LD_ADDR_LOC 3
7474: PUSH
7475: LD_INT 0
7477: ST_TO_ADDR
// end ;
7478: END
// every 0 0$1 trigger IsSelected ( us_lab1 ) marked 11 do
7479: LD_INT 32
7481: PPUSH
7482: CALL_OW 306
7486: IFFALSE 7844
7488: GO 7490
7490: DISABLE
// begin while dialogue_running do
7491: LD_LOC 3
7495: IFFALSE 7506
// wait ( 0 0$1 ) ;
7497: LD_INT 35
7499: PPUSH
7500: CALL_OW 67
7504: GO 7491
// dialogue_running := true ;
7506: LD_ADDR_LOC 3
7510: PUSH
7511: LD_INT 1
7513: ST_TO_ADDR
// DisableExclamations ;
7514: CALL_OW 474
// selected_opto_lab := true ;
7518: LD_ADDR_EXP 19
7522: PUSH
7523: LD_INT 1
7525: ST_TO_ADDR
// case who_survive of 1 :
7526: LD_EXP 7
7530: PUSH
7531: LD_INT 1
7533: DOUBLE
7534: EQUAL
7535: IFTRUE 7539
7537: GO 7646
7539: POP
// begin Say ( MacMillan , D6J-JMM-1 ) ;
7540: LD_EXP 1
7544: PPUSH
7545: LD_STRING D6J-JMM-1
7547: PPUSH
7548: CALL_OW 88
// if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
7552: LD_STRING Denis
7554: PPUSH
7555: CALL_OW 28
7559: PUSH
7560: LD_STRING Denis
7562: PPUSH
7563: CALL_OW 29
7567: AND
7568: IFFALSE 7608
// begin Say ( Joan , D6J-Joan-1 ) ;
7570: LD_EXP 3
7574: PPUSH
7575: LD_STRING D6J-Joan-1
7577: PPUSH
7578: CALL_OW 88
// Say ( MacMillan , D6J-JMM-2 ) ;
7582: LD_EXP 1
7586: PPUSH
7587: LD_STRING D6J-JMM-2
7589: PPUSH
7590: CALL_OW 88
// Say ( Joan , D6J-Joan-2 ) ;
7594: LD_EXP 3
7598: PPUSH
7599: LD_STRING D6J-Joan-2
7601: PPUSH
7602: CALL_OW 88
// end else
7606: GO 7620
// Say ( Joan , D6J-Joan-2a ) ;
7608: LD_EXP 3
7612: PPUSH
7613: LD_STRING D6J-Joan-2a
7615: PPUSH
7616: CALL_OW 88
// Say ( MacMillan , D6J-JMM-3 ) ;
7620: LD_EXP 1
7624: PPUSH
7625: LD_STRING D6J-JMM-3
7627: PPUSH
7628: CALL_OW 88
// Say ( Joan , D6J-Joan-3 ) ;
7632: LD_EXP 3
7636: PPUSH
7637: LD_STRING D6J-Joan-3
7639: PPUSH
7640: CALL_OW 88
// end ; 2 :
7644: GO 7825
7646: LD_INT 2
7648: DOUBLE
7649: EQUAL
7650: IFTRUE 7654
7652: GO 7705
7654: POP
// begin Say ( MacMillan , D6L-JMM-1 ) ;
7655: LD_EXP 1
7659: PPUSH
7660: LD_STRING D6L-JMM-1
7662: PPUSH
7663: CALL_OW 88
// Say ( Lisa , D6L-Lisa-1 ) ;
7667: LD_EXP 4
7671: PPUSH
7672: LD_STRING D6L-Lisa-1
7674: PPUSH
7675: CALL_OW 88
// Say ( MacMillan , D6L-JMM-2 ) ;
7679: LD_EXP 1
7683: PPUSH
7684: LD_STRING D6L-JMM-2
7686: PPUSH
7687: CALL_OW 88
// Say ( Lisa , D6L-Lisa-2 ) ;
7691: LD_EXP 4
7695: PPUSH
7696: LD_STRING D6L-Lisa-2
7698: PPUSH
7699: CALL_OW 88
// end ; 3 :
7703: GO 7825
7705: LD_INT 3
7707: DOUBLE
7708: EQUAL
7709: IFTRUE 7713
7711: GO 7824
7713: POP
// begin Say ( MacMillan , D6X-JMM-1 ) ;
7714: LD_EXP 1
7718: PPUSH
7719: LD_STRING D6X-JMM-1
7721: PPUSH
7722: CALL_OW 88
// Say ( Anezka , D6X-Con-1 ) ;
7726: LD_EXP 5
7730: PPUSH
7731: LD_STRING D6X-Con-1
7733: PPUSH
7734: CALL_OW 88
// Say ( MacMillan , D6X-JMM-2 ) ;
7738: LD_EXP 1
7742: PPUSH
7743: LD_STRING D6X-JMM-2
7745: PPUSH
7746: CALL_OW 88
// Say ( Anezka , D6X-Con-2 ) ;
7750: LD_EXP 5
7754: PPUSH
7755: LD_STRING D6X-Con-2
7757: PPUSH
7758: CALL_OW 88
// Say ( MacMillan , D6X-JMM-3 ) ;
7762: LD_EXP 1
7766: PPUSH
7767: LD_STRING D6X-JMM-3
7769: PPUSH
7770: CALL_OW 88
// Say ( Anezka , D6X-Con-3 ) ;
7774: LD_EXP 5
7778: PPUSH
7779: LD_STRING D6X-Con-3
7781: PPUSH
7782: CALL_OW 88
// Say ( MacMillan , D6X-JMM-4 ) ;
7786: LD_EXP 1
7790: PPUSH
7791: LD_STRING D6X-JMM-4
7793: PPUSH
7794: CALL_OW 88
// Say ( Anezka , D6X-Con-4 ) ;
7798: LD_EXP 5
7802: PPUSH
7803: LD_STRING D6X-Con-4
7805: PPUSH
7806: CALL_OW 88
// Say ( MacMillan , D6X-JMM-5 ) ;
7810: LD_EXP 1
7814: PPUSH
7815: LD_STRING D6X-JMM-5
7817: PPUSH
7818: CALL_OW 88
// end ; end ;
7822: GO 7825
7824: POP
// ChangeMissionObjectives ( M3 ) ;
7825: LD_STRING M3
7827: PPUSH
7828: CALL_OW 337
// EnableExclamations ;
7832: CALL_OW 473
// dialogue_running := false ;
7836: LD_ADDR_LOC 3
7840: PUSH
7841: LD_INT 0
7843: ST_TO_ADDR
// end ;
7844: END
// every 10 10$0 do
7845: GO 7847
7847: DISABLE
// begin DialogueOn ;
7848: CALL_OW 6
// interface_hidden := true ;
7852: LD_ADDR_OWVAR 54
7856: PUSH
7857: LD_INT 1
7859: ST_TO_ADDR
// Say ( Powell , D7-Pow-1 ) ;
7860: LD_EXP 2
7864: PPUSH
7865: LD_STRING D7-Pow-1
7867: PPUSH
7868: CALL_OW 88
// Say ( MacMillan , D7-JMM-1 ) ;
7872: LD_EXP 1
7876: PPUSH
7877: LD_STRING D7-JMM-1
7879: PPUSH
7880: CALL_OW 88
// Say ( Powell , D7-Pow-2 ) ;
7884: LD_EXP 2
7888: PPUSH
7889: LD_STRING D7-Pow-2
7891: PPUSH
7892: CALL_OW 88
// if IsLive ( survivor ) then
7896: LD_EXP 6
7900: PPUSH
7901: CALL_OW 300
7905: IFFALSE 7921
// Say ( MacMillan , D7-JMM-2 ) else
7907: LD_EXP 1
7911: PPUSH
7912: LD_STRING D7-JMM-2
7914: PPUSH
7915: CALL_OW 88
7919: GO 7933
// Say ( MacMillan , D7-JMM-2a ) ;
7921: LD_EXP 1
7925: PPUSH
7926: LD_STRING D7-JMM-2a
7928: PPUSH
7929: CALL_OW 88
// Say ( Powell , D7-Pow-3 ) ;
7933: LD_EXP 2
7937: PPUSH
7938: LD_STRING D7-Pow-3
7940: PPUSH
7941: CALL_OW 88
// Say ( MacMillan , D7-JMM-3 ) ;
7945: LD_EXP 1
7949: PPUSH
7950: LD_STRING D7-JMM-3
7952: PPUSH
7953: CALL_OW 88
// Say ( Powell , D7-Pow-4 ) ;
7957: LD_EXP 2
7961: PPUSH
7962: LD_STRING D7-Pow-4
7964: PPUSH
7965: CALL_OW 88
// DialogueOff ;
7969: CALL_OW 7
// interface_hidden := false ;
7973: LD_ADDR_OWVAR 54
7977: PUSH
7978: LD_INT 0
7980: ST_TO_ADDR
// end ;
7981: END
// every 0 0$20 do
7982: GO 7984
7984: DISABLE
// begin ukradle_auto := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] , [ f_chassis , us_morphling ] ] ) ;
7985: LD_ADDR_EXP 9
7989: PUSH
7990: LD_INT 22
7992: PUSH
7993: LD_EXP 15
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: LD_INT 21
8004: PUSH
8005: LD_INT 2
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: LD_INT 31
8014: PUSH
8015: LD_INT 5
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: LIST
8026: PPUSH
8027: CALL_OW 69
8031: ST_TO_ADDR
// mm_vehicle := ukradle_auto ;
8032: LD_ADDR_EXP 63
8036: PUSH
8037: LD_EXP 9
8041: ST_TO_ADDR
// manual_forces := manual_forces ^ mm_vehicle ;
8042: LD_ADDR_EXP 59
8046: PUSH
8047: LD_EXP 59
8051: PUSH
8052: LD_EXP 63
8056: ADD
8057: ST_TO_ADDR
// if ukradle_auto then
8058: LD_EXP 9
8062: IFFALSE 8067
// enable ( 5 ) ;
8064: LD_INT 5
8066: ENABLE_MARKED
// end ;
8067: END
// function vzdalenost_macmillana_od_auta ; var v_x , v_y ; begin
8068: LD_INT 0
8070: PPUSH
8071: PPUSH
8072: PPUSH
// v_x := GetX ( ukradle_auto ) - GetX ( MacMillan ) ;
8073: LD_ADDR_VAR 0 2
8077: PUSH
8078: LD_EXP 9
8082: PPUSH
8083: CALL_OW 250
8087: PUSH
8088: LD_EXP 1
8092: PPUSH
8093: CALL_OW 250
8097: MINUS
8098: ST_TO_ADDR
// v_x := GetY ( ukradle_auto ) - GetY ( MacMillan ) ;
8099: LD_ADDR_VAR 0 2
8103: PUSH
8104: LD_EXP 9
8108: PPUSH
8109: CALL_OW 251
8113: PUSH
8114: LD_EXP 1
8118: PPUSH
8119: CALL_OW 251
8123: MINUS
8124: ST_TO_ADDR
// if ( ( v_x > - 6 ) and ( v_x < 6 ) ) and ( ( v_y > - 6 ) and ( v_y < 6 ) ) then
8125: LD_VAR 0 2
8129: PUSH
8130: LD_INT 6
8132: NEG
8133: GREATER
8134: PUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 6
8142: LESS
8143: AND
8144: PUSH
8145: LD_VAR 0 3
8149: PUSH
8150: LD_INT 6
8152: NEG
8153: GREATER
8154: PUSH
8155: LD_VAR 0 3
8159: PUSH
8160: LD_INT 6
8162: LESS
8163: AND
8164: AND
8165: IFFALSE 8177
// result := true else
8167: LD_ADDR_VAR 0 1
8171: PUSH
8172: LD_INT 1
8174: ST_TO_ADDR
8175: GO 8185
// result := false ;
8177: LD_ADDR_VAR 0 1
8181: PUSH
8182: LD_INT 0
8184: ST_TO_ADDR
// end ;
8185: LD_VAR 0 1
8189: RET
// every 0 0$1 trigger vzdalenost_macmillana_od_auta marked 5 do
8190: CALL 8068 0 0
8194: IFFALSE 8211
8196: GO 8198
8198: DISABLE
// begin Say ( MacMillan , D8-JMM-1 ) ;
8199: LD_EXP 1
8203: PPUSH
8204: LD_STRING D8-JMM-1
8206: PPUSH
8207: CALL_OW 88
// end ; end_of_file
8211: END
// export us_trucks ; export number_us_trucks ; export heavy_trucks , medium_trucks , light_trucks ; export function prepare_us_base ; var un , i ; begin
8212: LD_INT 0
8214: PPUSH
8215: PPUSH
8216: PPUSH
// number_us_trucks := 4 ;
8217: LD_ADDR_EXP 36
8221: PUSH
8222: LD_INT 4
8224: ST_TO_ADDR
// light_trucks := Rand ( 1 , ( number_us_trucks div 2 ) ) ;
8225: LD_ADDR_EXP 39
8229: PUSH
8230: LD_INT 1
8232: PPUSH
8233: LD_EXP 36
8237: PUSH
8238: LD_INT 2
8240: DIV
8241: PPUSH
8242: CALL_OW 12
8246: ST_TO_ADDR
// heavy_trucks := Rand ( 0 , ( number_us_trucks div 2 ) ) ;
8247: LD_ADDR_EXP 37
8251: PUSH
8252: LD_INT 0
8254: PPUSH
8255: LD_EXP 36
8259: PUSH
8260: LD_INT 2
8262: DIV
8263: PPUSH
8264: CALL_OW 12
8268: ST_TO_ADDR
// medium_trucks := number_us_trucks - ( light_trucks + heavy_trucks ) ;
8269: LD_ADDR_EXP 38
8273: PUSH
8274: LD_EXP 36
8278: PUSH
8279: LD_EXP 39
8283: PUSH
8284: LD_EXP 37
8288: PLUS
8289: MINUS
8290: ST_TO_ADDR
// us_trucks := [ ] ;
8291: LD_ADDR_EXP 35
8295: PUSH
8296: EMPTY
8297: ST_TO_ADDR
// uc_nation = nation_american ;
8298: LD_ADDR_OWVAR 21
8302: PUSH
8303: LD_INT 1
8305: ST_TO_ADDR
// uc_side = neutral ;
8306: LD_ADDR_OWVAR 20
8310: PUSH
8311: LD_EXP 16
8315: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
8316: LD_ADDR_OWVAR 24
8320: PUSH
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 5
8326: PPUSH
8327: CALL_OW 12
8331: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
8332: LD_ADDR_OWVAR 37
8336: PUSH
8337: LD_INT 2
8339: ST_TO_ADDR
// vc_control := control_remote ;
8340: LD_ADDR_OWVAR 38
8344: PUSH
8345: LD_INT 2
8347: ST_TO_ADDR
// vc_engine := engine_solar ;
8348: LD_ADDR_OWVAR 39
8352: PUSH
8353: LD_INT 2
8355: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
8356: LD_ADDR_OWVAR 40
8360: PUSH
8361: LD_INT 12
8363: ST_TO_ADDR
// un := CreateVehicle ;
8364: LD_ADDR_VAR 0 2
8368: PUSH
8369: CALL_OW 45
8373: ST_TO_ADDR
// PlaceUnitXY ( un , 84 , 119 , false ) ;
8374: LD_VAR 0 2
8378: PPUSH
8379: LD_INT 84
8381: PPUSH
8382: LD_INT 119
8384: PPUSH
8385: LD_INT 0
8387: PPUSH
8388: CALL_OW 48
// us_trucks := us_trucks ^ un ;
8392: LD_ADDR_EXP 35
8396: PUSH
8397: LD_EXP 35
8401: PUSH
8402: LD_VAR 0 2
8406: ADD
8407: ST_TO_ADDR
// for i := 1 to light_trucks do
8408: LD_ADDR_VAR 0 3
8412: PUSH
8413: DOUBLE
8414: LD_INT 1
8416: DEC
8417: ST_TO_ADDR
8418: LD_EXP 39
8422: PUSH
8423: FOR_TO
8424: IFFALSE 8517
// begin uc_direction := Rand ( 0 , 5 ) ;
8426: LD_ADDR_OWVAR 24
8430: PUSH
8431: LD_INT 0
8433: PPUSH
8434: LD_INT 5
8436: PPUSH
8437: CALL_OW 12
8441: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
8442: LD_ADDR_OWVAR 37
8446: PUSH
8447: LD_INT 1
8449: ST_TO_ADDR
// vc_control := control_remote ;
8450: LD_ADDR_OWVAR 38
8454: PUSH
8455: LD_INT 2
8457: ST_TO_ADDR
// vc_engine := engine_solar ;
8458: LD_ADDR_OWVAR 39
8462: PUSH
8463: LD_INT 2
8465: ST_TO_ADDR
// vc_weapon := us_light_gun ;
8466: LD_ADDR_OWVAR 40
8470: PUSH
8471: LD_INT 3
8473: ST_TO_ADDR
// un := CreateVehicle ;
8474: LD_ADDR_VAR 0 2
8478: PUSH
8479: CALL_OW 45
8483: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8484: LD_VAR 0 2
8488: PPUSH
8489: LD_INT 9
8491: PPUSH
8492: LD_INT 0
8494: PPUSH
8495: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8499: LD_ADDR_EXP 35
8503: PUSH
8504: LD_EXP 35
8508: PUSH
8509: LD_VAR 0 2
8513: ADD
8514: ST_TO_ADDR
// end ;
8515: GO 8423
8517: POP
8518: POP
// for i := 1 to medium_trucks do
8519: LD_ADDR_VAR 0 3
8523: PUSH
8524: DOUBLE
8525: LD_INT 1
8527: DEC
8528: ST_TO_ADDR
8529: LD_EXP 38
8533: PUSH
8534: FOR_TO
8535: IFFALSE 8660
// begin uc_direction := Rand ( 0 , 5 ) ;
8537: LD_ADDR_OWVAR 24
8541: PUSH
8542: LD_INT 0
8544: PPUSH
8545: LD_INT 5
8547: PPUSH
8548: CALL_OW 12
8552: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 2
8560: MOD
8561: PUSH
8562: LD_INT 1
8564: EQUAL
8565: IFFALSE 8585
// begin vc_chassis := us_medium_wheeled ;
8567: LD_ADDR_OWVAR 37
8571: PUSH
8572: LD_INT 2
8574: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
8575: LD_ADDR_OWVAR 40
8579: PUSH
8580: LD_INT 4
8582: ST_TO_ADDR
// end else
8583: GO 8601
// begin vc_chassis := us_medium_tracked ;
8585: LD_ADDR_OWVAR 37
8589: PUSH
8590: LD_INT 3
8592: ST_TO_ADDR
// vc_weapon := us_double_gun ;
8593: LD_ADDR_OWVAR 40
8597: PUSH
8598: LD_INT 5
8600: ST_TO_ADDR
// end ; vc_control := control_remote ;
8601: LD_ADDR_OWVAR 38
8605: PUSH
8606: LD_INT 2
8608: ST_TO_ADDR
// vc_engine := engine_combustion ;
8609: LD_ADDR_OWVAR 39
8613: PUSH
8614: LD_INT 1
8616: ST_TO_ADDR
// un := CreateVehicle ;
8617: LD_ADDR_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8627: LD_VAR 0 2
8631: PPUSH
8632: LD_INT 9
8634: PPUSH
8635: LD_INT 0
8637: PPUSH
8638: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8642: LD_ADDR_EXP 35
8646: PUSH
8647: LD_EXP 35
8651: PUSH
8652: LD_VAR 0 2
8656: ADD
8657: ST_TO_ADDR
// end ;
8658: GO 8534
8660: POP
8661: POP
// for i := 1 to heavy_trucks do
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: DOUBLE
8668: LD_INT 1
8670: DEC
8671: ST_TO_ADDR
8672: LD_EXP 37
8676: PUSH
8677: FOR_TO
8678: IFFALSE 8795
// begin uc_direction := Rand ( 0 , 5 ) ;
8680: LD_ADDR_OWVAR 24
8684: PUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_INT 5
8690: PPUSH
8691: CALL_OW 12
8695: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8696: LD_ADDR_OWVAR 37
8700: PUSH
8701: LD_INT 4
8703: ST_TO_ADDR
// vc_control := control_remote ;
8704: LD_ADDR_OWVAR 38
8708: PUSH
8709: LD_INT 2
8711: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8712: LD_VAR 0 3
8716: PUSH
8717: LD_INT 2
8719: MOD
8720: PUSH
8721: LD_INT 1
8723: EQUAL
8724: IFFALSE 8736
// vc_engine := engine_siberite else
8726: LD_ADDR_OWVAR 39
8730: PUSH
8731: LD_INT 3
8733: ST_TO_ADDR
8734: GO 8744
// vc_engine := engine_combustion ;
8736: LD_ADDR_OWVAR 39
8740: PUSH
8741: LD_INT 1
8743: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
8744: LD_ADDR_OWVAR 40
8748: PUSH
8749: LD_INT 6
8751: ST_TO_ADDR
// un := CreateVehicle ;
8752: LD_ADDR_VAR 0 2
8756: PUSH
8757: CALL_OW 45
8761: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8762: LD_VAR 0 2
8766: PPUSH
8767: LD_INT 9
8769: PPUSH
8770: LD_INT 0
8772: PPUSH
8773: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8777: LD_ADDR_EXP 35
8781: PUSH
8782: LD_EXP 35
8786: PUSH
8787: LD_VAR 0 2
8791: ADD
8792: ST_TO_ADDR
// end ;
8793: GO 8677
8795: POP
8796: POP
// end ; end_of_file
8797: LD_VAR 0 1
8801: RET
// export ru_lab1_queue , ru_lab2_queue ; export ru_lab1_upgrade , ru_lab2_upgrade ; export research_1 , research_2 ; var research_done , laboratory ; var finished_1 , finished_2 ; var soucet1 , soucet2 ; export function ru_scientistic_priority ; begin
8802: LD_INT 0
8804: PPUSH
// ru_lab1_queue := [ tech_AdvRocket ] ;
8805: LD_ADDR_EXP 40
8809: PUSH
8810: LD_INT 71
8812: PUSH
8813: EMPTY
8814: LIST
8815: ST_TO_ADDR
// ru_lab2_queue := [ tech_TauRad , tech_SpacAnom , tech_LimTeleport , tech_MatPred , tech_TargTeleport ] ;
8816: LD_ADDR_EXP 41
8820: PUSH
8821: LD_INT 28
8823: PUSH
8824: LD_INT 29
8826: PUSH
8827: LD_INT 37
8829: PUSH
8830: LD_INT 9
8832: PUSH
8833: LD_INT 38
8835: PUSH
8836: EMPTY
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// ru_lab1_upgrade := [ tech_Tech1 , tech_Weap1 , tech_Sib1 , tech_Tech2 , tech_Weap2 , tech_Sib2 , tech_Tech3 , tech_Weap3 , tech_Sib3 ] ;
8843: LD_ADDR_EXP 42
8847: PUSH
8848: LD_INT 48
8850: PUSH
8851: LD_INT 51
8853: PUSH
8854: LD_INT 54
8856: PUSH
8857: LD_INT 49
8859: PUSH
8860: LD_INT 52
8862: PUSH
8863: LD_INT 55
8865: PUSH
8866: LD_INT 50
8868: PUSH
8869: LD_INT 53
8871: PUSH
8872: LD_INT 56
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: ST_TO_ADDR
// ru_lab2_upgrade := [ tech_Comp1 , tech_ST1 , tech_Comp2 , tech_ST2 , tech_Comp3 , tech_ST3 ] ;
8886: LD_ADDR_EXP 43
8890: PUSH
8891: LD_INT 57
8893: PUSH
8894: LD_INT 63
8896: PUSH
8897: LD_INT 58
8899: PUSH
8900: LD_INT 64
8902: PUSH
8903: LD_INT 59
8905: PUSH
8906: LD_INT 65
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: LIST
8916: ST_TO_ADDR
// research_1 := false ;
8917: LD_ADDR_EXP 44
8921: PUSH
8922: LD_INT 0
8924: ST_TO_ADDR
// research_2 := false ;
8925: LD_ADDR_EXP 45
8929: PUSH
8930: LD_INT 0
8932: ST_TO_ADDR
// finished_1 := false ;
8933: LD_ADDR_LOC 6
8937: PUSH
8938: LD_INT 0
8940: ST_TO_ADDR
// finished_2 := false ;
8941: LD_ADDR_LOC 7
8945: PUSH
8946: LD_INT 0
8948: ST_TO_ADDR
// end ;
8949: LD_VAR 0 1
8953: RET
// function change_technology_lab1 ; var i , j , pom ; begin
8954: LD_INT 0
8956: PPUSH
8957: PPUSH
8958: PPUSH
8959: PPUSH
// j := 1 ;
8960: LD_ADDR_VAR 0 3
8964: PUSH
8965: LD_INT 1
8967: ST_TO_ADDR
// pom := [ ] ;
8968: LD_ADDR_VAR 0 4
8972: PUSH
8973: EMPTY
8974: ST_TO_ADDR
// for i in ru_lab1_queue do
8975: LD_ADDR_VAR 0 2
8979: PUSH
8980: LD_EXP 40
8984: PUSH
8985: FOR_IN
8986: IFFALSE 9030
// begin if j > 1 then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_INT 1
8995: GREATER
8996: IFFALSE 9014
// pom := pom ^ i ;
8998: LD_ADDR_VAR 0 4
9002: PUSH
9003: LD_VAR 0 4
9007: PUSH
9008: LD_VAR 0 2
9012: ADD
9013: ST_TO_ADDR
// j := j + 1 ;
9014: LD_ADDR_VAR 0 3
9018: PUSH
9019: LD_VAR 0 3
9023: PUSH
9024: LD_INT 1
9026: PLUS
9027: ST_TO_ADDR
// end ;
9028: GO 8985
9030: POP
9031: POP
// ru_lab1_queue := pom ;
9032: LD_ADDR_EXP 40
9036: PUSH
9037: LD_VAR 0 4
9041: ST_TO_ADDR
// if not ru_lab1_queue then
9042: LD_EXP 40
9046: NOT
9047: IFFALSE 9066
// begin ru_lab1_queue := ru_lab1_upgrade ;
9049: LD_ADDR_EXP 40
9053: PUSH
9054: LD_EXP 42
9058: ST_TO_ADDR
// ru_lab1_upgrade := [ ] ;
9059: LD_ADDR_EXP 42
9063: PUSH
9064: EMPTY
9065: ST_TO_ADDR
// end ; end ;
9066: LD_VAR 0 1
9070: RET
// function change_technology_lab2 ; var i , j , pom ; begin
9071: LD_INT 0
9073: PPUSH
9074: PPUSH
9075: PPUSH
9076: PPUSH
// j := 1 ;
9077: LD_ADDR_VAR 0 3
9081: PUSH
9082: LD_INT 1
9084: ST_TO_ADDR
// pom := [ ] ;
9085: LD_ADDR_VAR 0 4
9089: PUSH
9090: EMPTY
9091: ST_TO_ADDR
// for i in ru_lab2_queue do
9092: LD_ADDR_VAR 0 2
9096: PUSH
9097: LD_EXP 41
9101: PUSH
9102: FOR_IN
9103: IFFALSE 9147
// begin if j > 1 then
9105: LD_VAR 0 3
9109: PUSH
9110: LD_INT 1
9112: GREATER
9113: IFFALSE 9131
// pom := pom ^ i ;
9115: LD_ADDR_VAR 0 4
9119: PUSH
9120: LD_VAR 0 4
9124: PUSH
9125: LD_VAR 0 2
9129: ADD
9130: ST_TO_ADDR
// j := j + 1 ;
9131: LD_ADDR_VAR 0 3
9135: PUSH
9136: LD_VAR 0 3
9140: PUSH
9141: LD_INT 1
9143: PLUS
9144: ST_TO_ADDR
// end ;
9145: GO 9102
9147: POP
9148: POP
// ru_lab2_queue := pom ;
9149: LD_ADDR_EXP 41
9153: PUSH
9154: LD_VAR 0 4
9158: ST_TO_ADDR
// if not ru_lab2_queue then
9159: LD_EXP 41
9163: NOT
9164: IFFALSE 9183
// begin ru_lab2_queue := ru_lab2_upgrade ;
9166: LD_ADDR_EXP 41
9170: PUSH
9171: LD_EXP 43
9175: ST_TO_ADDR
// ru_lab2_upgrade := [ ] ;
9176: LD_ADDR_EXP 43
9180: PUSH
9181: EMPTY
9182: ST_TO_ADDR
// end ; end ;
9183: LD_VAR 0 1
9187: RET
// on ResearchComplete ( research_done , laboratory ) do begin case laboratory of ru_lab1 :
9188: LD_VAR 0 2
9192: PUSH
9193: LD_INT 14
9195: DOUBLE
9196: EQUAL
9197: IFTRUE 9201
9199: GO 9212
9201: POP
// research_1 := false ; ru_lab2 :
9202: LD_ADDR_EXP 44
9206: PUSH
9207: LD_INT 0
9209: ST_TO_ADDR
9210: GO 9232
9212: LD_INT 15
9214: DOUBLE
9215: EQUAL
9216: IFTRUE 9220
9218: GO 9231
9220: POP
// research_2 := false ; end ;
9221: LD_ADDR_EXP 45
9225: PUSH
9226: LD_INT 0
9228: ST_TO_ADDR
9229: GO 9232
9231: POP
// end ;
9232: PPOPN 2
9234: END
// function vyrovnej_vedecke_sily ; var un , un1 , un2 , i , move_to , how_much ; begin
9235: LD_INT 0
9237: PPUSH
9238: PPUSH
9239: PPUSH
9240: PPUSH
9241: PPUSH
9242: PPUSH
9243: PPUSH
// un1 := 0 + UnitsInside ( ru_lab1 ) ;
9244: LD_ADDR_VAR 0 3
9248: PUSH
9249: LD_INT 0
9251: PUSH
9252: LD_INT 14
9254: PPUSH
9255: CALL_OW 313
9259: PLUS
9260: ST_TO_ADDR
// un2 := 0 + UnitsInside ( ru_lab2 ) ;
9261: LD_ADDR_VAR 0 4
9265: PUSH
9266: LD_INT 0
9268: PUSH
9269: LD_INT 15
9271: PPUSH
9272: CALL_OW 313
9276: PLUS
9277: ST_TO_ADDR
// if un1 >= un2 then
9278: LD_VAR 0 3
9282: PUSH
9283: LD_VAR 0 4
9287: GREATEREQUAL
9288: IFFALSE 9331
// begin move_to := ru_lab2 ;
9290: LD_ADDR_VAR 0 6
9294: PUSH
9295: LD_INT 15
9297: ST_TO_ADDR
// how_much := ( un1 - un2 ) div 2 ;
9298: LD_ADDR_VAR 0 7
9302: PUSH
9303: LD_VAR 0 3
9307: PUSH
9308: LD_VAR 0 4
9312: MINUS
9313: PUSH
9314: LD_INT 2
9316: DIV
9317: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9318: LD_ADDR_VAR 0 2
9322: PUSH
9323: LD_INT 14
9325: PPUSH
9326: CALL_OW 313
9330: ST_TO_ADDR
// end ; if un1 < un2 then
9331: LD_VAR 0 3
9335: PUSH
9336: LD_VAR 0 4
9340: LESS
9341: IFFALSE 9384
// begin move_to := ru_lab1 ;
9343: LD_ADDR_VAR 0 6
9347: PUSH
9348: LD_INT 14
9350: ST_TO_ADDR
// how_much := ( un2 - un1 ) div 2 ;
9351: LD_ADDR_VAR 0 7
9355: PUSH
9356: LD_VAR 0 4
9360: PUSH
9361: LD_VAR 0 3
9365: MINUS
9366: PUSH
9367: LD_INT 2
9369: DIV
9370: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9371: LD_ADDR_VAR 0 2
9375: PUSH
9376: LD_INT 15
9378: PPUSH
9379: CALL_OW 313
9383: ST_TO_ADDR
// end ; for i := 1 to how_much do
9384: LD_ADDR_VAR 0 5
9388: PUSH
9389: DOUBLE
9390: LD_INT 1
9392: DEC
9393: ST_TO_ADDR
9394: LD_VAR 0 7
9398: PUSH
9399: FOR_TO
9400: IFFALSE 9439
// begin ComExitBuilding ( un [ i ] ) ;
9402: LD_VAR 0 2
9406: PUSH
9407: LD_VAR 0 5
9411: ARRAY
9412: PPUSH
9413: CALL_OW 122
// AddComEnterUnit ( un [ i ] , move_to ) ;
9417: LD_VAR 0 2
9421: PUSH
9422: LD_VAR 0 5
9426: ARRAY
9427: PPUSH
9428: LD_VAR 0 6
9432: PPUSH
9433: CALL_OW 180
// end ;
9437: GO 9399
9439: POP
9440: POP
// end ;
9441: LD_VAR 0 1
9445: RET
// every 0 0$15 trigger UnitsInside ( ru_lab1 ) and not research_1 do var un , i , j ;
9446: LD_INT 14
9448: PPUSH
9449: CALL_OW 313
9453: PUSH
9454: LD_EXP 44
9458: NOT
9459: AND
9460: IFFALSE 9781
9462: GO 9464
9464: DISABLE
9465: LD_INT 0
9467: PPUSH
9468: PPUSH
9469: PPUSH
// begin un := UnitsInside ( ru_lab1 ) ;
9470: LD_ADDR_VAR 0 1
9474: PUSH
9475: LD_INT 14
9477: PPUSH
9478: CALL_OW 313
9482: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9483: LD_VAR 0 1
9487: PPUSH
9488: LD_INT 4
9490: PPUSH
9491: CALL_OW 336
// if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9495: LD_EXP 40
9499: PUSH
9500: LD_EXP 42
9504: AND
9505: IFFALSE 9531
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9507: LD_INT 14
9509: PPUSH
9510: LD_EXP 40
9514: PUSH
9515: LD_INT 1
9517: ARRAY
9518: PPUSH
9519: CALL_OW 124
// research_1 := true ;
9523: LD_ADDR_EXP 44
9527: PUSH
9528: LD_INT 1
9530: ST_TO_ADDR
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9531: LD_EXP 40
9535: PUSH
9536: LD_EXP 42
9540: NOT
9541: AND
9542: IFFALSE 9675
// begin if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9544: LD_EXP 41
9548: PUSH
9549: LD_EXP 43
9553: AND
9554: IFFALSE 9590
// begin un := UnitsInside ( ru_lab1 ) ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 14
9563: PPUSH
9564: CALL_OW 313
9568: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9569: LD_VAR 0 1
9573: PPUSH
9574: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9578: LD_VAR 0 1
9582: PPUSH
9583: LD_INT 15
9585: PPUSH
9586: CALL_OW 180
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9590: LD_EXP 41
9594: PUSH
9595: LD_EXP 43
9599: NOT
9600: AND
9601: IFFALSE 9638
// begin vyrovnej_vedecke_sily ;
9603: CALL 9235 0 0
// wait ( 0 0$5 ) ;
9607: LD_INT 175
9609: PPUSH
9610: CALL_OW 67
// ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9614: LD_INT 14
9616: PPUSH
9617: LD_EXP 40
9621: PUSH
9622: LD_INT 1
9624: ARRAY
9625: PPUSH
9626: CALL_OW 124
// research_1 := true ;
9630: LD_ADDR_EXP 44
9634: PUSH
9635: LD_INT 1
9637: ST_TO_ADDR
// end ; if not ( ru_lab2_queue or ru_lab2_upgrade ) then
9638: LD_EXP 41
9642: PUSH
9643: LD_EXP 43
9647: OR
9648: NOT
9649: IFFALSE 9675
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9651: LD_INT 14
9653: PPUSH
9654: LD_EXP 40
9658: PUSH
9659: LD_INT 1
9661: ARRAY
9662: PPUSH
9663: CALL_OW 124
// research_1 := true ;
9667: LD_ADDR_EXP 44
9671: PUSH
9672: LD_INT 1
9674: ST_TO_ADDR
// end ; end ; if research_1 then
9675: LD_EXP 44
9679: IFFALSE 9685
// change_technology_lab1 ;
9681: CALL 8954 0 0
// soucet1 := 0 + ru_lab1_queue + ru_lab1_upgrade ;
9685: LD_ADDR_LOC 8
9689: PUSH
9690: LD_INT 0
9692: PUSH
9693: LD_EXP 40
9697: PLUS
9698: PUSH
9699: LD_EXP 42
9703: PLUS
9704: ST_TO_ADDR
// if ( soucet1 = 0 ) and ( not research_1 ) then
9705: LD_LOC 8
9709: PUSH
9710: LD_INT 0
9712: EQUAL
9713: PUSH
9714: LD_EXP 44
9718: NOT
9719: AND
9720: IFFALSE 9764
// begin finished_1 := true ;
9722: LD_ADDR_LOC 6
9726: PUSH
9727: LD_INT 1
9729: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9730: LD_ADDR_VAR 0 1
9734: PUSH
9735: LD_INT 14
9737: PPUSH
9738: CALL_OW 313
9742: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9743: LD_VAR 0 1
9747: PPUSH
9748: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 15
9759: PPUSH
9760: CALL_OW 180
// end ; if ( soucet1 > 0 ) or research_1 then
9764: LD_LOC 8
9768: PUSH
9769: LD_INT 0
9771: GREATER
9772: PUSH
9773: LD_EXP 44
9777: OR
9778: IFFALSE 9781
// enable ;
9780: ENABLE
// end ;
9781: PPOPN 3
9783: END
// every 0 0$15 trigger UnitsInside ( ru_lab2 ) and not research_2 do var un , i , j ;
9784: LD_INT 15
9786: PPUSH
9787: CALL_OW 313
9791: PUSH
9792: LD_EXP 45
9796: NOT
9797: AND
9798: IFFALSE 10119
9800: GO 9802
9802: DISABLE
9803: LD_INT 0
9805: PPUSH
9806: PPUSH
9807: PPUSH
// begin un := UnitsInside ( ru_lab2 ) ;
9808: LD_ADDR_VAR 0 1
9812: PUSH
9813: LD_INT 15
9815: PPUSH
9816: CALL_OW 313
9820: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_INT 4
9828: PPUSH
9829: CALL_OW 336
// if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9833: LD_EXP 41
9837: PUSH
9838: LD_EXP 43
9842: AND
9843: IFFALSE 9869
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9845: LD_INT 15
9847: PPUSH
9848: LD_EXP 41
9852: PUSH
9853: LD_INT 1
9855: ARRAY
9856: PPUSH
9857: CALL_OW 124
// research_2 := true ;
9861: LD_ADDR_EXP 45
9865: PUSH
9866: LD_INT 1
9868: ST_TO_ADDR
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9869: LD_EXP 41
9873: PUSH
9874: LD_EXP 43
9878: NOT
9879: AND
9880: IFFALSE 10013
// begin if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9882: LD_EXP 40
9886: PUSH
9887: LD_EXP 42
9891: AND
9892: IFFALSE 9928
// begin un := UnitsInside ( ru_lab2 ) ;
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_INT 15
9901: PPUSH
9902: CALL_OW 313
9906: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9907: LD_VAR 0 1
9911: PPUSH
9912: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
9916: LD_VAR 0 1
9920: PPUSH
9921: LD_INT 14
9923: PPUSH
9924: CALL_OW 180
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9928: LD_EXP 40
9932: PUSH
9933: LD_EXP 42
9937: NOT
9938: AND
9939: IFFALSE 9976
// begin vyrovnej_vedecke_sily ;
9941: CALL 9235 0 0
// wait ( 0 0$5 ) ;
9945: LD_INT 175
9947: PPUSH
9948: CALL_OW 67
// ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9952: LD_INT 15
9954: PPUSH
9955: LD_EXP 41
9959: PUSH
9960: LD_INT 1
9962: ARRAY
9963: PPUSH
9964: CALL_OW 124
// research_2 := true ;
9968: LD_ADDR_EXP 45
9972: PUSH
9973: LD_INT 1
9975: ST_TO_ADDR
// end ; if not ( ru_lab1_queue or ru_lab1_upgrade ) then
9976: LD_EXP 40
9980: PUSH
9981: LD_EXP 42
9985: OR
9986: NOT
9987: IFFALSE 10013
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9989: LD_INT 15
9991: PPUSH
9992: LD_EXP 41
9996: PUSH
9997: LD_INT 1
9999: ARRAY
10000: PPUSH
10001: CALL_OW 124
// research_2 := true ;
10005: LD_ADDR_EXP 45
10009: PUSH
10010: LD_INT 1
10012: ST_TO_ADDR
// end ; end ; if research_2 then
10013: LD_EXP 45
10017: IFFALSE 10023
// change_technology_lab2 ;
10019: CALL 9071 0 0
// soucet2 := 0 + ru_lab2_queue + ru_lab2_upgrade ;
10023: LD_ADDR_LOC 9
10027: PUSH
10028: LD_INT 0
10030: PUSH
10031: LD_EXP 41
10035: PLUS
10036: PUSH
10037: LD_EXP 43
10041: PLUS
10042: ST_TO_ADDR
// if ( soucet2 = 0 ) and ( not research_2 ) then
10043: LD_LOC 9
10047: PUSH
10048: LD_INT 0
10050: EQUAL
10051: PUSH
10052: LD_EXP 45
10056: NOT
10057: AND
10058: IFFALSE 10102
// begin finished_2 := true ;
10060: LD_ADDR_LOC 7
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
10068: LD_ADDR_VAR 0 1
10072: PUSH
10073: LD_INT 15
10075: PPUSH
10076: CALL_OW 313
10080: ST_TO_ADDR
// ComExitBuilding ( un ) ;
10081: LD_VAR 0 1
10085: PPUSH
10086: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
10090: LD_VAR 0 1
10094: PPUSH
10095: LD_INT 14
10097: PPUSH
10098: CALL_OW 180
// end ; if ( soucet2 > 0 ) or research_2 then
10102: LD_LOC 9
10106: PUSH
10107: LD_INT 0
10109: GREATER
10110: PUSH
10111: LD_EXP 45
10115: OR
10116: IFFALSE 10119
// enable ;
10118: ENABLE
// end ;
10119: PPOPN 3
10121: END
// every 0 0$10 trigger finished_1 and finished_2 do var un , sci , i , build ;
10122: LD_LOC 6
10126: PUSH
10127: LD_LOC 7
10131: AND
10132: IFFALSE 10399
10134: GO 10136
10136: DISABLE
10137: LD_INT 0
10139: PPUSH
10140: PPUSH
10141: PPUSH
10142: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
10143: LD_ADDR_VAR 0 2
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_EXP 15
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 25
10162: PUSH
10163: LD_INT 4
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: ST_TO_ADDR
// ComExitBuilding ( sci ) ;
10179: LD_VAR 0 2
10183: PPUSH
10184: CALL_OW 122
// build := FilterAllUnits ( [ [ f_side , russians ] , [ f_btype , b_factory ] ] ) ;
10188: LD_ADDR_VAR 0 4
10192: PUSH
10193: LD_INT 22
10195: PUSH
10196: LD_EXP 15
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 30
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: ST_TO_ADDR
// if build then
10224: LD_VAR 0 4
10228: IFFALSE 10301
// begin i := 1 ;
10230: LD_ADDR_VAR 0 3
10234: PUSH
10235: LD_INT 1
10237: ST_TO_ADDR
// for un in sci do
10238: LD_ADDR_VAR 0 1
10242: PUSH
10243: LD_VAR 0 2
10247: PUSH
10248: FOR_IN
10249: IFFALSE 10297
// begin ComEnterUnit ( un , build [ ( i mod build ) + 1 ] ) ;
10251: LD_VAR 0 1
10255: PPUSH
10256: LD_VAR 0 4
10260: PUSH
10261: LD_VAR 0 3
10265: PUSH
10266: LD_VAR 0 4
10270: MOD
10271: PUSH
10272: LD_INT 1
10274: PLUS
10275: ARRAY
10276: PPUSH
10277: CALL_OW 120
// i := i + 1 ;
10281: LD_ADDR_VAR 0 3
10285: PUSH
10286: LD_VAR 0 3
10290: PUSH
10291: LD_INT 1
10293: PLUS
10294: ST_TO_ADDR
// end ;
10295: GO 10248
10297: POP
10298: POP
// end else
10299: GO 10399
// begin build := FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
10301: LD_ADDR_VAR 0 4
10305: PUSH
10306: LD_INT 22
10308: PUSH
10309: LD_EXP 15
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 2
10320: PUSH
10321: LD_INT 30
10323: PUSH
10324: LD_INT 5
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PUSH
10331: LD_INT 30
10333: PUSH
10334: LD_INT 4
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: PPUSH
10350: CALL_OW 69
10354: ST_TO_ADDR
// if build then
10355: LD_VAR 0 4
10359: IFFALSE 10399
// begin ComEnterUnit ( sci , build ) ;
10361: LD_VAR 0 2
10365: PPUSH
10366: LD_VAR 0 4
10370: PPUSH
10371: CALL_OW 120
// AddComChangeProfession ( sci , class_soldier ) ;
10375: LD_VAR 0 2
10379: PPUSH
10380: LD_INT 1
10382: PPUSH
10383: CALL_OW 183
// AddComChangeProfession ( sci , class_bazooker ) ;
10387: LD_VAR 0 2
10391: PPUSH
10392: LD_INT 9
10394: PPUSH
10395: CALL_OW 183
// end ; end ; end ; end_of_file
10399: PPOPN 4
10401: END
// export base_crates , base_oil , base_siberit ; export busy_fact1 , busy_fact2 ; export vyber_pro_tovarnu ; var hotove_vozidlo , volna_tovarna ; var cekat_dodavku ; var time_fact1 , time_fact2 ; var no_siberit ; var factory1_idle , factory2_idle ; export function startup_manufacturing ; begin
10402: LD_INT 0
10404: PPUSH
// busy_fact1 := false ;
10405: LD_ADDR_EXP 49
10409: PUSH
10410: LD_INT 0
10412: ST_TO_ADDR
// busy_fact2 := false ;
10413: LD_ADDR_EXP 50
10417: PUSH
10418: LD_INT 0
10420: ST_TO_ADDR
// time_fact1 := Rand ( 0 0$2 , 0 0$10 ) ;
10421: LD_ADDR_LOC 13
10425: PUSH
10426: LD_INT 70
10428: PPUSH
10429: LD_INT 350
10431: PPUSH
10432: CALL_OW 12
10436: ST_TO_ADDR
// time_fact2 := Rand ( 0 0$2 , 0 0$10 ) ;
10437: LD_ADDR_LOC 14
10441: PUSH
10442: LD_INT 70
10444: PPUSH
10445: LD_INT 350
10447: PPUSH
10448: CALL_OW 12
10452: ST_TO_ADDR
// end ;
10453: LD_VAR 0 1
10457: RET
// function zjisti_zdroje ; var base ; begin
10458: LD_INT 0
10460: PPUSH
10461: PPUSH
// base := GetBase ( ru_depot ) ;
10462: LD_ADDR_VAR 0 2
10466: PUSH
10467: LD_INT 22
10469: PPUSH
10470: CALL_OW 274
10474: ST_TO_ADDR
// base_crates := GetResourceType ( base , mat_cans ) ;
10475: LD_ADDR_EXP 46
10479: PUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: LD_INT 1
10487: PPUSH
10488: CALL_OW 275
10492: ST_TO_ADDR
// base_oil := GetResourceType ( base , mat_oil ) ;
10493: LD_ADDR_EXP 47
10497: PUSH
10498: LD_VAR 0 2
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 275
10510: ST_TO_ADDR
// base_siberit := GetResourceType ( base , mat_siberit ) ;
10511: LD_ADDR_EXP 48
10515: PUSH
10516: LD_VAR 0 2
10520: PPUSH
10521: LD_INT 3
10523: PPUSH
10524: CALL_OW 275
10528: ST_TO_ADDR
// end ;
10529: LD_VAR 0 1
10533: RET
// every 0 0$2 trigger UnitsInside ( ru_fact1 ) and UnitsInside ( ru_fact2 ) marked 1 do var un ;
10534: LD_INT 1
10536: PPUSH
10537: CALL_OW 313
10541: PUSH
10542: LD_INT 40
10544: PPUSH
10545: CALL_OW 313
10549: AND
10550: IFFALSE 10582
10552: GO 10554
10554: DISABLE
10555: LD_INT 0
10557: PPUSH
// begin ComRemember ( UnitsInside ( ru_fact1 ) ) ;
10558: LD_INT 1
10560: PPUSH
10561: CALL_OW 313
10565: PPUSH
10566: CALL_OW 143
// ComRemember ( UnitsInside ( ru_fact2 ) ) ;
10570: LD_INT 40
10572: PPUSH
10573: CALL_OW 313
10577: PPUSH
10578: CALL_OW 143
// end ;
10582: PPOPN 1
10584: END
// function vyber_komponenty ; var specialni ; begin
10585: LD_INT 0
10587: PPUSH
10588: PPUSH
// cekat_dodavku := true ;
10589: LD_ADDR_LOC 12
10593: PUSH
10594: LD_INT 1
10596: ST_TO_ADDR
// specialni := false ;
10597: LD_ADDR_VAR 0 2
10601: PUSH
10602: LD_INT 0
10604: ST_TO_ADDR
// no_siberit := false ;
10605: LD_ADDR_LOC 15
10609: PUSH
10610: LD_INT 0
10612: ST_TO_ADDR
// zjisti_pozadavky ;
10613: CALL 12006 0 0
// if 1 = 2 then
10617: LD_INT 1
10619: PUSH
10620: LD_INT 2
10622: EQUAL
10623: IFFALSE 10880
// begin case chybi of 1 :
10625: LD_EXP 62
10629: PUSH
10630: LD_INT 1
10632: DOUBLE
10633: EQUAL
10634: IFTRUE 10638
10636: GO 10713
10638: POP
// begin if ( base_crates >= 55 ) then
10639: LD_EXP 46
10643: PUSH
10644: LD_INT 55
10646: GREATEREQUAL
10647: IFFALSE 10659
// vc_chassis := ru_heavy_tracked else
10649: LD_ADDR_OWVAR 37
10653: PUSH
10654: LD_INT 24
10656: ST_TO_ADDR
10657: GO 10667
// vc_chassis := ru_heavy_wheeled ;
10659: LD_ADDR_OWVAR 37
10663: PUSH
10664: LD_INT 23
10666: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10667: LD_ADDR_OWVAR 40
10671: PUSH
10672: LD_INT 49
10674: ST_TO_ADDR
// vc_control := control_computer ;
10675: LD_ADDR_OWVAR 38
10679: PUSH
10680: LD_INT 3
10682: ST_TO_ADDR
// if ( base_siberit >= 60 ) then
10683: LD_EXP 48
10687: PUSH
10688: LD_INT 60
10690: GREATEREQUAL
10691: IFFALSE 10703
// vc_engine := engine_siberite else
10693: LD_ADDR_OWVAR 39
10697: PUSH
10698: LD_INT 3
10700: ST_TO_ADDR
10701: GO 10711
// vc_engine := engine_combustion ;
10703: LD_ADDR_OWVAR 39
10707: PUSH
10708: LD_INT 1
10710: ST_TO_ADDR
// end ; 2 :
10711: GO 10870
10713: LD_INT 2
10715: DOUBLE
10716: EQUAL
10717: IFTRUE 10721
10719: GO 10756
10721: POP
// begin vc_chassis := ru_heavy_tracked ;
10722: LD_ADDR_OWVAR 37
10726: PUSH
10727: LD_INT 24
10729: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10730: LD_ADDR_OWVAR 40
10734: PUSH
10735: LD_INT 49
10737: ST_TO_ADDR
// vc_control := control_manual ;
10738: LD_ADDR_OWVAR 38
10742: PUSH
10743: LD_INT 1
10745: ST_TO_ADDR
// vc_engine := engine_siberite ;
10746: LD_ADDR_OWVAR 39
10750: PUSH
10751: LD_INT 3
10753: ST_TO_ADDR
// end ; 3 :
10754: GO 10870
10756: LD_INT 3
10758: DOUBLE
10759: EQUAL
10760: IFTRUE 10764
10762: GO 10869
10764: POP
// begin vc_chassis := ru_heavy_tracked ;
10765: LD_ADDR_OWVAR 37
10769: PUSH
10770: LD_INT 24
10772: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10773: LD_ADDR_OWVAR 40
10777: PUSH
10778: LD_INT 46
10780: ST_TO_ADDR
// if base_crates < 70 then
10781: LD_EXP 46
10785: PUSH
10786: LD_INT 70
10788: LESS
10789: IFFALSE 10799
// vc_chassis := ru_heavy_wheeled ;
10791: LD_ADDR_OWVAR 37
10795: PUSH
10796: LD_INT 23
10798: ST_TO_ADDR
// if base_crates < 60 then
10799: LD_EXP 46
10803: PUSH
10804: LD_INT 60
10806: LESS
10807: IFFALSE 10825
// begin vc_weapon := ru_rocket ;
10809: LD_ADDR_OWVAR 40
10813: PUSH
10814: LD_INT 47
10816: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10817: LD_ADDR_OWVAR 37
10821: PUSH
10822: LD_INT 24
10824: ST_TO_ADDR
// end ; if base_crates < 55 then
10825: LD_EXP 46
10829: PUSH
10830: LD_INT 55
10832: LESS
10833: IFFALSE 10843
// vc_chassis := ru_heavy_wheeled ;
10835: LD_ADDR_OWVAR 37
10839: PUSH
10840: LD_INT 23
10842: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10843: LD_ADDR_OWVAR 40
10847: PUSH
10848: LD_INT 49
10850: ST_TO_ADDR
// vc_control := control_manual ;
10851: LD_ADDR_OWVAR 38
10855: PUSH
10856: LD_INT 1
10858: ST_TO_ADDR
// vc_engine := engine_siberite ;
10859: LD_ADDR_OWVAR 39
10863: PUSH
10864: LD_INT 3
10866: ST_TO_ADDR
// end ; end ;
10867: GO 10870
10869: POP
// specialni := true ;
10870: LD_ADDR_VAR 0 2
10874: PUSH
10875: LD_INT 1
10877: ST_TO_ADDR
// end else
10878: GO 10880
// begin end ; if ( base_crates < 65 ) and ( not specialni ) then
10880: LD_EXP 46
10884: PUSH
10885: LD_INT 65
10887: LESS
10888: PUSH
10889: LD_VAR 0 2
10893: NOT
10894: AND
10895: IFFALSE 10983
// begin cekat_dodavku := false ;
10897: LD_ADDR_LOC 12
10901: PUSH
10902: LD_INT 0
10904: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10905: LD_ADDR_OWVAR 40
10909: PUSH
10910: LD_INT 45
10912: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10913: LD_ADDR_OWVAR 37
10917: PUSH
10918: LD_INT 22
10920: ST_TO_ADDR
// if base_crates < 60 then
10921: LD_EXP 46
10925: PUSH
10926: LD_INT 60
10928: LESS
10929: IFFALSE 10939
// vc_chassis := ru_medium_wheeled ;
10931: LD_ADDR_OWVAR 37
10935: PUSH
10936: LD_INT 21
10938: ST_TO_ADDR
// if base_crates < 55 then
10939: LD_EXP 46
10943: PUSH
10944: LD_INT 55
10946: LESS
10947: IFFALSE 10965
// begin vc_chassis := ru_medium_tracked ;
10949: LD_ADDR_OWVAR 37
10953: PUSH
10954: LD_INT 22
10956: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
10957: LD_ADDR_OWVAR 40
10961: PUSH
10962: LD_INT 43
10964: ST_TO_ADDR
// end ; if base_crates < 50 then
10965: LD_EXP 46
10969: PUSH
10970: LD_INT 50
10972: LESS
10973: IFFALSE 10983
// vc_chassis := ru_medium_wheeled ;
10975: LD_ADDR_OWVAR 37
10979: PUSH
10980: LD_INT 21
10982: ST_TO_ADDR
// end ; if ( base_crates >= 65 ) and ( vyber_pro_tovarnu = 1 ) and ( not specialni ) then
10983: LD_EXP 46
10987: PUSH
10988: LD_INT 65
10990: GREATEREQUAL
10991: PUSH
10992: LD_EXP 51
10996: PUSH
10997: LD_INT 1
10999: EQUAL
11000: AND
11001: PUSH
11002: LD_VAR 0 2
11006: NOT
11007: AND
11008: IFFALSE 11096
// begin cekat_dodavku := false ;
11010: LD_ADDR_LOC 12
11014: PUSH
11015: LD_INT 0
11017: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
11018: LD_ADDR_OWVAR 40
11022: PUSH
11023: LD_INT 46
11025: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11026: LD_ADDR_OWVAR 37
11030: PUSH
11031: LD_INT 24
11033: ST_TO_ADDR
// if base_crates < 80 then
11034: LD_EXP 46
11038: PUSH
11039: LD_INT 80
11041: LESS
11042: IFFALSE 11052
// vc_chassis := ru_heavy_wheeled ;
11044: LD_ADDR_OWVAR 37
11048: PUSH
11049: LD_INT 23
11051: ST_TO_ADDR
// if base_crates < 70 then
11052: LD_EXP 46
11056: PUSH
11057: LD_INT 70
11059: LESS
11060: IFFALSE 11078
// begin vc_weapon := ru_rocket ;
11062: LD_ADDR_OWVAR 40
11066: PUSH
11067: LD_INT 47
11069: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11070: LD_ADDR_OWVAR 37
11074: PUSH
11075: LD_INT 24
11077: ST_TO_ADDR
// end ; if base_crates < 65 then
11078: LD_EXP 46
11082: PUSH
11083: LD_INT 65
11085: LESS
11086: IFFALSE 11096
// vc_chassis := ru_heavy_wheeled ;
11088: LD_ADDR_OWVAR 37
11092: PUSH
11093: LD_INT 23
11095: ST_TO_ADDR
// end ; if ( base_crates >= 70 ) and ( vyber_pro_tovarnu = 2 ) and ( not specialni ) then
11096: LD_EXP 46
11100: PUSH
11101: LD_INT 70
11103: GREATEREQUAL
11104: PUSH
11105: LD_EXP 51
11109: PUSH
11110: LD_INT 2
11112: EQUAL
11113: AND
11114: PUSH
11115: LD_VAR 0 2
11119: NOT
11120: AND
11121: IFFALSE 11165
// begin cekat_dodavku := false ;
11123: LD_ADDR_LOC 12
11127: PUSH
11128: LD_INT 0
11130: ST_TO_ADDR
// vc_weapon := ru_rocket ;
11131: LD_ADDR_OWVAR 40
11135: PUSH
11136: LD_INT 47
11138: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
11139: LD_ADDR_OWVAR 37
11143: PUSH
11144: LD_INT 24
11146: ST_TO_ADDR
// if base_crates < 75 then
11147: LD_EXP 46
11151: PUSH
11152: LD_INT 75
11154: LESS
11155: IFFALSE 11165
// vc_chassis := ru_heavy_wheeled ;
11157: LD_ADDR_OWVAR 37
11161: PUSH
11162: LD_INT 23
11164: ST_TO_ADDR
// end ; if not specialni then
11165: LD_VAR 0 2
11169: NOT
11170: IFFALSE 11251
// begin vc_control := control_computer ;
11172: LD_ADDR_OWVAR 38
11176: PUSH
11177: LD_INT 3
11179: ST_TO_ADDR
// if ( vc_chassis > 22 ) and ( base_siberit >= 10 ) and ( not no_siberit ) then
11180: LD_OWVAR 37
11184: PUSH
11185: LD_INT 22
11187: GREATER
11188: PUSH
11189: LD_EXP 48
11193: PUSH
11194: LD_INT 10
11196: GREATEREQUAL
11197: AND
11198: PUSH
11199: LD_LOC 15
11203: NOT
11204: AND
11205: IFFALSE 11225
// begin vc_engine := engine_siberite ;
11207: LD_ADDR_OWVAR 39
11211: PUSH
11212: LD_INT 3
11214: ST_TO_ADDR
// cekat_dodavku := false ;
11215: LD_ADDR_LOC 12
11219: PUSH
11220: LD_INT 0
11222: ST_TO_ADDR
// end else
11223: GO 11251
// if base_oil >= 30 then
11225: LD_EXP 47
11229: PUSH
11230: LD_INT 30
11232: GREATEREQUAL
11233: IFFALSE 11251
// begin vc_engine := engine_combustion ;
11235: LD_ADDR_OWVAR 39
11239: PUSH
11240: LD_INT 1
11242: ST_TO_ADDR
// cekat_dodavku := false ;
11243: LD_ADDR_LOC 12
11247: PUSH
11248: LD_INT 0
11250: ST_TO_ADDR
// end ; end ; end ;
11251: LD_VAR 0 1
11255: RET
// on VehicleConstructed ( hotove_vozidlo , volna_tovarna ) do begin if GetSide ( hotove_vozidlo ) = russians then
11256: LD_VAR 0 1
11260: PPUSH
11261: CALL_OW 255
11265: PUSH
11266: LD_EXP 15
11270: EQUAL
11271: IFFALSE 11370
// begin if GetControl ( hotove_vozidlo ) = control_manual then
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 263
11282: PUSH
11283: LD_INT 1
11285: EQUAL
11286: IFFALSE 11304
// zaparkuj_vozidlo ( volna_tovarna , hotove_vozidlo ) else
11288: LD_VAR 0 2
11292: PPUSH
11293: LD_VAR 0 1
11297: PPUSH
11298: CALL 12159 0 2
11302: GO 11320
// war_forces := war_forces ^ hotove_vozidlo ;
11304: LD_ADDR_EXP 52
11308: PUSH
11309: LD_EXP 52
11313: PUSH
11314: LD_VAR 0 1
11318: ADD
11319: ST_TO_ADDR
// collect_war_forces ;
11320: CALL 12307 0 0
// case volna_tovarna of ru_fact1 :
11324: LD_VAR 0 2
11328: PUSH
11329: LD_INT 1
11331: DOUBLE
11332: EQUAL
11333: IFTRUE 11337
11335: GO 11348
11337: POP
// busy_fact1 := false ; ru_fact2 :
11338: LD_ADDR_EXP 49
11342: PUSH
11343: LD_INT 0
11345: ST_TO_ADDR
11346: GO 11368
11348: LD_INT 40
11350: DOUBLE
11351: EQUAL
11352: IFTRUE 11356
11354: GO 11367
11356: POP
// busy_fact2 := false ; end ;
11357: LD_ADDR_EXP 50
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
11365: GO 11368
11367: POP
// end else
11368: GO 11438
// if GetWeapon ( hotove_vozidlo ) = us_double_laser then
11370: LD_VAR 0 1
11374: PPUSH
11375: CALL_OW 264
11379: PUSH
11380: LD_INT 10
11382: EQUAL
11383: IFFALSE 11438
// begin double_laser := double_laser + 1 ;
11385: LD_ADDR_EXP 17
11389: PUSH
11390: LD_EXP 17
11394: PUSH
11395: LD_INT 1
11397: PLUS
11398: ST_TO_ADDR
// if not double_hint then
11399: LD_EXP 18
11403: NOT
11404: IFFALSE 11421
// begin Hint ( DoubleLaser ) ;
11406: LD_STRING DoubleLaser
11408: PPUSH
11409: CALL_OW 339
// double_hint := true ;
11413: LD_ADDR_EXP 18
11417: PUSH
11418: LD_INT 1
11420: ST_TO_ADDR
// end ; if double_laser = 2 then
11421: LD_EXP 17
11425: PUSH
11426: LD_INT 2
11428: EQUAL
11429: IFFALSE 11438
// ChangeMissionObjectives ( M3a ) ;
11431: LD_STRING M3a
11433: PPUSH
11434: CALL_OW 337
// end ; end ;
11438: PPOPN 2
11440: END
// every 0 0$10 trigger UnitsInside ( ru_fact1 ) and ( not busy_fact1 ) and ( TICK >= time_fact1 ) do var un ;
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 313
11448: PUSH
11449: LD_EXP 49
11453: NOT
11454: AND
11455: PUSH
11456: LD_OWVAR 1
11460: PUSH
11461: LD_LOC 13
11465: GREATEREQUAL
11466: AND
11467: IFFALSE 11575
11469: GO 11471
11471: DISABLE
11472: LD_INT 0
11474: PPUSH
// begin zjisti_zdroje ;
11475: CALL 10458 0 0
// if base_crates >= 40 then
11479: LD_EXP 46
11483: PUSH
11484: LD_INT 40
11486: GREATEREQUAL
11487: IFFALSE 11552
// begin vyber_pro_tovarnu := 1 ;
11489: LD_ADDR_EXP 51
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// vyber_komponenty ;
11497: CALL 10585 0 0
// if not cekat_dodavku then
11501: LD_LOC 12
11505: NOT
11506: IFFALSE 11552
// begin ComConstruct ( ru_fact1 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11508: LD_INT 1
11510: PPUSH
11511: LD_OWVAR 37
11515: PPUSH
11516: LD_OWVAR 39
11520: PPUSH
11521: LD_OWVAR 38
11525: PPUSH
11526: LD_OWVAR 40
11530: PPUSH
11531: CALL_OW 125
// if IsBusy ( ru_fact1 ) then
11535: LD_INT 1
11537: PPUSH
11538: CALL_OW 315
11542: IFFALSE 11552
// busy_fact1 := true ;
11544: LD_ADDR_EXP 49
11548: PUSH
11549: LD_INT 1
11551: ST_TO_ADDR
// end ; end ; time_fact1 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11552: LD_ADDR_LOC 13
11556: PUSH
11557: LD_OWVAR 1
11561: PUSH
11562: LD_INT 1400
11564: PPUSH
11565: LD_INT 2100
11567: PPUSH
11568: CALL_OW 12
11572: PLUS
11573: ST_TO_ADDR
// enable ;
11574: ENABLE
// end ;
11575: PPOPN 1
11577: END
// every 0 0$10 trigger UnitsInside ( ru_fact2 ) and ( not busy_fact2 ) and ( TICK >= time_fact2 ) do var un ;
11578: LD_INT 40
11580: PPUSH
11581: CALL_OW 313
11585: PUSH
11586: LD_EXP 50
11590: NOT
11591: AND
11592: PUSH
11593: LD_OWVAR 1
11597: PUSH
11598: LD_LOC 14
11602: GREATEREQUAL
11603: AND
11604: IFFALSE 11712
11606: GO 11608
11608: DISABLE
11609: LD_INT 0
11611: PPUSH
// begin zjisti_zdroje ;
11612: CALL 10458 0 0
// if base_crates >= 40 then
11616: LD_EXP 46
11620: PUSH
11621: LD_INT 40
11623: GREATEREQUAL
11624: IFFALSE 11689
// begin vyber_pro_tovarnu := 2 ;
11626: LD_ADDR_EXP 51
11630: PUSH
11631: LD_INT 2
11633: ST_TO_ADDR
// vyber_komponenty ;
11634: CALL 10585 0 0
// if not cekat_dodavku then
11638: LD_LOC 12
11642: NOT
11643: IFFALSE 11689
// begin ComConstruct ( ru_fact2 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11645: LD_INT 40
11647: PPUSH
11648: LD_OWVAR 37
11652: PPUSH
11653: LD_OWVAR 39
11657: PPUSH
11658: LD_OWVAR 38
11662: PPUSH
11663: LD_OWVAR 40
11667: PPUSH
11668: CALL_OW 125
// if IsBusy ( ru_fact2 ) then
11672: LD_INT 40
11674: PPUSH
11675: CALL_OW 315
11679: IFFALSE 11689
// busy_fact2 := true ;
11681: LD_ADDR_EXP 50
11685: PUSH
11686: LD_INT 1
11688: ST_TO_ADDR
// end ; end ; time_fact2 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11689: LD_ADDR_LOC 14
11693: PUSH
11694: LD_OWVAR 1
11698: PUSH
11699: LD_INT 1400
11701: PPUSH
11702: LD_INT 2100
11704: PPUSH
11705: CALL_OW 12
11709: PLUS
11710: ST_TO_ADDR
// enable ;
11711: ENABLE
// end ;
11712: PPOPN 1
11714: END
// every 0 0$10 trigger ( busy_fact1 ) and ( base_crates > 40 ) do
11715: LD_EXP 49
11719: PUSH
11720: LD_EXP 46
11724: PUSH
11725: LD_INT 40
11727: GREATER
11728: AND
11729: IFFALSE 11774
11731: GO 11733
11733: DISABLE
// begin factory1_idle := factory1_idle + 1 ;
11734: LD_ADDR_LOC 16
11738: PUSH
11739: LD_LOC 16
11743: PUSH
11744: LD_INT 1
11746: PLUS
11747: ST_TO_ADDR
// if factory1_idle > 10 then
11748: LD_LOC 16
11752: PUSH
11753: LD_INT 10
11755: GREATER
11756: IFFALSE 11774
// begin factory1_idle := 0 ;
11758: LD_ADDR_LOC 16
11762: PUSH
11763: LD_INT 0
11765: ST_TO_ADDR
// busy_fact1 := false ;
11766: LD_ADDR_EXP 49
11770: PUSH
11771: LD_INT 0
11773: ST_TO_ADDR
// end ; end ;
11774: END
// every 0 0$10 trigger ( busy_fact2 ) and ( base_crates > 40 ) do
11775: LD_EXP 50
11779: PUSH
11780: LD_EXP 46
11784: PUSH
11785: LD_INT 40
11787: GREATER
11788: AND
11789: IFFALSE 11834
11791: GO 11793
11793: DISABLE
// begin factory2_idle := factory2_idle + 1 ;
11794: LD_ADDR_LOC 17
11798: PUSH
11799: LD_LOC 17
11803: PUSH
11804: LD_INT 1
11806: PLUS
11807: ST_TO_ADDR
// if factory2_idle > 10 then
11808: LD_LOC 17
11812: PUSH
11813: LD_INT 10
11815: GREATER
11816: IFFALSE 11834
// begin factory2_idle := 0 ;
11818: LD_ADDR_LOC 17
11822: PUSH
11823: LD_INT 0
11825: ST_TO_ADDR
// busy_fact2 := false ;
11826: LD_ADDR_EXP 50
11830: PUSH
11831: LD_INT 0
11833: ST_TO_ADDR
// end ; end ; end_of_file
11834: END
// export war_forces , war_lapser , war_count ; export attack_forces ; export backup_forces , backup_lapser , backup_count ; export manual_forces , manual_lapser ; export fuel_tank ; export chybi ; export mm_vehicle ; export defend_forces ; export us_important ; var klic_area_1 , klic_area_2 ; var klic_area_3 , klic_area_4 ; var klic_area_5 , klic_area_6 ; var klic_area_7 , klic_area_8 ; var klic_area_9 ; var destroy_now ; var important ; var multi ; var skrivanek ; var kolibrik ; var attack_begin ; var cislo_utoku ; var now_area , next_area ; var event_unit ; export function startup_war_definition ; begin
11835: LD_INT 0
11837: PPUSH
// war_forces := [ ] ;
11838: LD_ADDR_EXP 52
11842: PUSH
11843: EMPTY
11844: ST_TO_ADDR
// war_lapser := 0 ;
11845: LD_ADDR_EXP 53
11849: PUSH
11850: LD_INT 0
11852: ST_TO_ADDR
// war_count := Rand ( 2 , 3 ) ;
11853: LD_ADDR_EXP 54
11857: PUSH
11858: LD_INT 2
11860: PPUSH
11861: LD_INT 3
11863: PPUSH
11864: CALL_OW 12
11868: ST_TO_ADDR
// backup_forces := [ ] ;
11869: LD_ADDR_EXP 56
11873: PUSH
11874: EMPTY
11875: ST_TO_ADDR
// backup_lapser := 0 ;
11876: LD_ADDR_EXP 57
11880: PUSH
11881: LD_INT 0
11883: ST_TO_ADDR
// backup_count := Rand ( 2 , 3 ) ;
11884: LD_ADDR_EXP 58
11888: PUSH
11889: LD_INT 2
11891: PPUSH
11892: LD_INT 3
11894: PPUSH
11895: CALL_OW 12
11899: ST_TO_ADDR
// manual_forces := [ ] ;
11900: LD_ADDR_EXP 59
11904: PUSH
11905: EMPTY
11906: ST_TO_ADDR
// manual_lapser := 0 ;
11907: LD_ADDR_EXP 60
11911: PUSH
11912: LD_INT 0
11914: ST_TO_ADDR
// defend_forces := [ ] ;
11915: LD_ADDR_EXP 64
11919: PUSH
11920: EMPTY
11921: ST_TO_ADDR
// klic_area_1 := [ ] ;
11922: LD_ADDR_LOC 18
11926: PUSH
11927: EMPTY
11928: ST_TO_ADDR
// klic_area_2 := [ ] ;
11929: LD_ADDR_LOC 19
11933: PUSH
11934: EMPTY
11935: ST_TO_ADDR
// klic_area_3 := [ ] ;
11936: LD_ADDR_LOC 20
11940: PUSH
11941: EMPTY
11942: ST_TO_ADDR
// klic_area_4 := [ ] ;
11943: LD_ADDR_LOC 21
11947: PUSH
11948: EMPTY
11949: ST_TO_ADDR
// klic_area_5 := [ ] ;
11950: LD_ADDR_LOC 22
11954: PUSH
11955: EMPTY
11956: ST_TO_ADDR
// klic_area_6 := [ ] ;
11957: LD_ADDR_LOC 23
11961: PUSH
11962: EMPTY
11963: ST_TO_ADDR
// klic_area_7 := [ ] ;
11964: LD_ADDR_LOC 24
11968: PUSH
11969: EMPTY
11970: ST_TO_ADDR
// klic_area_8 := [ ] ;
11971: LD_ADDR_LOC 25
11975: PUSH
11976: EMPTY
11977: ST_TO_ADDR
// klic_area_9 := [ ] ;
11978: LD_ADDR_LOC 26
11982: PUSH
11983: EMPTY
11984: ST_TO_ADDR
// cislo_utoku := 1 ;
11985: LD_ADDR_LOC 33
11989: PUSH
11990: LD_INT 1
11992: ST_TO_ADDR
// mm_vehicle := 0 ;
11993: LD_ADDR_EXP 63
11997: PUSH
11998: LD_INT 0
12000: ST_TO_ADDR
// end ;
12001: LD_VAR 0 1
12005: RET
// export function zjisti_pozadavky ; var vybrano ; var i ; begin
12006: LD_INT 0
12008: PPUSH
12009: PPUSH
12010: PPUSH
// chybi := 0 ;
12011: LD_ADDR_EXP 62
12015: PUSH
12016: LD_INT 0
12018: ST_TO_ADDR
// if manual_forces < russians_forces then
12019: LD_EXP 59
12023: PUSH
12024: LD_EXP 28
12028: LESS
12029: IFFALSE 12039
// chybi := 3 ;
12031: LD_ADDR_EXP 62
12035: PUSH
12036: LD_INT 3
12038: ST_TO_ADDR
// end ;
12039: LD_VAR 0 1
12043: RET
// every 5 5$0 trigger ( backup_forces < backup_count ) and ( war_forces > 0 ) do var hex ;
12044: LD_EXP 56
12048: PUSH
12049: LD_EXP 58
12053: LESS
12054: PUSH
12055: LD_EXP 52
12059: PUSH
12060: LD_INT 0
12062: GREATER
12063: AND
12064: IFFALSE 12156
12066: GO 12068
12068: DISABLE
12069: LD_INT 0
12071: PPUSH
// begin hex := RandHexArea ( parking_place , true ) ;
12072: LD_ADDR_VAR 0 1
12076: PUSH
12077: LD_INT 11
12079: PPUSH
12080: LD_INT 1
12082: PPUSH
12083: CALL_OW 16
12087: ST_TO_ADDR
// backup_forces := backup_forces ^ ( war_forces [ 1 ] ) ;
12088: LD_ADDR_EXP 56
12092: PUSH
12093: LD_EXP 56
12097: PUSH
12098: LD_EXP 52
12102: PUSH
12103: LD_INT 1
12105: ARRAY
12106: ADD
12107: ST_TO_ADDR
// ComAgressiveMove ( war_forces [ 1 ] , hex [ 1 ] , hex [ 2 ] ) ;
12108: LD_EXP 52
12112: PUSH
12113: LD_INT 1
12115: ARRAY
12116: PPUSH
12117: LD_VAR 0 1
12121: PUSH
12122: LD_INT 1
12124: ARRAY
12125: PPUSH
12126: LD_VAR 0 1
12130: PUSH
12131: LD_INT 2
12133: ARRAY
12134: PPUSH
12135: CALL_OW 114
// war_forces := war_forces diff backup_forces ;
12139: LD_ADDR_EXP 52
12143: PUSH
12144: LD_EXP 52
12148: PUSH
12149: LD_EXP 56
12153: DIFF
12154: ST_TO_ADDR
// enable ;
12155: ENABLE
// end ;
12156: PPOPN 1
12158: END
// export function zaparkuj_vozidlo ( puvod_ridice , vozidlo ) ; var ridic , hex ; begin
12159: LD_INT 0
12161: PPUSH
12162: PPUSH
12163: PPUSH
// manual_forces := manual_forces ^ vozidlo ;
12164: LD_ADDR_EXP 59
12168: PUSH
12169: LD_EXP 59
12173: PUSH
12174: LD_VAR 0 2
12178: ADD
12179: ST_TO_ADDR
// hex := RandHexArea ( parking_place , true ) ;
12180: LD_ADDR_VAR 0 5
12184: PUSH
12185: LD_INT 11
12187: PPUSH
12188: LD_INT 1
12190: PPUSH
12191: CALL_OW 16
12195: ST_TO_ADDR
// if ( manual_forces < 2 ) then
12196: LD_EXP 59
12200: PUSH
12201: LD_INT 2
12203: LESS
12204: IFFALSE 12223
// ComMoveXY ( vozidlo , 103 , 59 ) else
12206: LD_VAR 0 2
12210: PPUSH
12211: LD_INT 103
12213: PPUSH
12214: LD_INT 59
12216: PPUSH
12217: CALL_OW 111
12221: GO 12250
// ComMoveXY ( vozidlo , hex [ 1 ] , hex [ 2 ] ) ;
12223: LD_VAR 0 2
12227: PPUSH
12228: LD_VAR 0 5
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: LD_VAR 0 5
12241: PUSH
12242: LD_INT 2
12244: ARRAY
12245: PPUSH
12246: CALL_OW 111
// repeat wait ( 0 0$5 ) ;
12250: LD_INT 175
12252: PPUSH
12253: CALL_OW 67
// until not IsBusy ( vozidlo ) ;
12257: LD_VAR 0 2
12261: PPUSH
12262: CALL_OW 315
12266: NOT
12267: IFFALSE 12250
// ridic := IsDrivenBy ( vozidlo ) ;
12269: LD_ADDR_VAR 0 4
12273: PUSH
12274: LD_VAR 0 2
12278: PPUSH
12279: CALL_OW 311
12283: ST_TO_ADDR
// ComExitVehicle ( ridic ) ;
12284: LD_VAR 0 4
12288: PPUSH
12289: CALL_OW 121
// AddComReturn ( ridic ) ;
12293: LD_VAR 0 4
12297: PPUSH
12298: CALL_OW 204
// end ;
12302: LD_VAR 0 3
12306: RET
// export function collect_war_forces ; begin
12307: LD_INT 0
12309: PPUSH
// ComAgressiveMove ( war_forces , 103 , 65 ) ;
12310: LD_EXP 52
12314: PPUSH
12315: LD_INT 103
12317: PPUSH
12318: LD_INT 65
12320: PPUSH
12321: CALL_OW 114
// end ;
12325: LD_VAR 0 1
12329: RET
// function zjisti_cilove_misto ( cislo_arei ) ; var vysledek ; begin
12330: LD_INT 0
12332: PPUSH
12333: PPUSH
// case cislo_arei of 1 :
12334: LD_VAR 0 1
12338: PUSH
12339: LD_INT 1
12341: DOUBLE
12342: EQUAL
12343: IFTRUE 12347
12345: GO 12365
12347: POP
// vysledek := [ 75 , 83 ] ; 2 :
12348: LD_ADDR_VAR 0 3
12352: PUSH
12353: LD_INT 75
12355: PUSH
12356: LD_INT 83
12358: PUSH
12359: EMPTY
12360: LIST
12361: LIST
12362: ST_TO_ADDR
12363: GO 12574
12365: LD_INT 2
12367: DOUBLE
12368: EQUAL
12369: IFTRUE 12373
12371: GO 12391
12373: POP
// vysledek := [ 82 , 102 ] ; 3 :
12374: LD_ADDR_VAR 0 3
12378: PUSH
12379: LD_INT 82
12381: PUSH
12382: LD_INT 102
12384: PUSH
12385: EMPTY
12386: LIST
12387: LIST
12388: ST_TO_ADDR
12389: GO 12574
12391: LD_INT 3
12393: DOUBLE
12394: EQUAL
12395: IFTRUE 12399
12397: GO 12417
12399: POP
// vysledek := [ 85 , 116 ] ; 4 :
12400: LD_ADDR_VAR 0 3
12404: PUSH
12405: LD_INT 85
12407: PUSH
12408: LD_INT 116
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: ST_TO_ADDR
12415: GO 12574
12417: LD_INT 4
12419: DOUBLE
12420: EQUAL
12421: IFTRUE 12425
12423: GO 12443
12425: POP
// vysledek := [ 95 , 107 ] ; 5 :
12426: LD_ADDR_VAR 0 3
12430: PUSH
12431: LD_INT 95
12433: PUSH
12434: LD_INT 107
12436: PUSH
12437: EMPTY
12438: LIST
12439: LIST
12440: ST_TO_ADDR
12441: GO 12574
12443: LD_INT 5
12445: DOUBLE
12446: EQUAL
12447: IFTRUE 12451
12449: GO 12469
12451: POP
// vysledek := [ 108 , 116 ] ; 6 :
12452: LD_ADDR_VAR 0 3
12456: PUSH
12457: LD_INT 108
12459: PUSH
12460: LD_INT 116
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: ST_TO_ADDR
12467: GO 12574
12469: LD_INT 6
12471: DOUBLE
12472: EQUAL
12473: IFTRUE 12477
12475: GO 12495
12477: POP
// vysledek := [ 105 , 133 ] ; 7 :
12478: LD_ADDR_VAR 0 3
12482: PUSH
12483: LD_INT 105
12485: PUSH
12486: LD_INT 133
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: ST_TO_ADDR
12493: GO 12574
12495: LD_INT 7
12497: DOUBLE
12498: EQUAL
12499: IFTRUE 12503
12501: GO 12521
12503: POP
// vysledek := [ 85 , 133 ] ; 8 :
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 85
12511: PUSH
12512: LD_INT 133
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: ST_TO_ADDR
12519: GO 12574
12521: LD_INT 8
12523: DOUBLE
12524: EQUAL
12525: IFTRUE 12529
12527: GO 12547
12529: POP
// vysledek := [ 62 , 105 ] ; 9 :
12530: LD_ADDR_VAR 0 3
12534: PUSH
12535: LD_INT 62
12537: PUSH
12538: LD_INT 105
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: ST_TO_ADDR
12545: GO 12574
12547: LD_INT 9
12549: DOUBLE
12550: EQUAL
12551: IFTRUE 12555
12553: GO 12573
12555: POP
// vysledek := [ 103 , 97 ] ; end ;
12556: LD_ADDR_VAR 0 3
12560: PUSH
12561: LD_INT 103
12563: PUSH
12564: LD_INT 97
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: ST_TO_ADDR
12571: GO 12574
12573: POP
// result := vysledek ;
12574: LD_ADDR_VAR 0 2
12578: PUSH
12579: LD_VAR 0 3
12583: ST_TO_ADDR
// end ;
12584: LD_VAR 0 2
12588: RET
// function a_jmeno ( cislo ) ; var vysledek ; begin
12589: LD_INT 0
12591: PPUSH
12592: PPUSH
// case cislo of 1 :
12593: LD_VAR 0 1
12597: PUSH
12598: LD_INT 1
12600: DOUBLE
12601: EQUAL
12602: IFTRUE 12606
12604: GO 12617
12606: POP
// vysledek := u_north ; 2 :
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: LD_INT 16
12614: ST_TO_ADDR
12615: GO 12827
12617: LD_INT 2
12619: DOUBLE
12620: EQUAL
12621: IFTRUE 12625
12623: GO 12636
12625: POP
// vysledek := u_central_n ; 3 :
12626: LD_ADDR_VAR 0 3
12630: PUSH
12631: LD_INT 17
12633: ST_TO_ADDR
12634: GO 12827
12636: LD_INT 3
12638: DOUBLE
12639: EQUAL
12640: IFTRUE 12644
12642: GO 12655
12644: POP
// vysledek := u_central ; 4 :
12645: LD_ADDR_VAR 0 3
12649: PUSH
12650: LD_INT 19
12652: ST_TO_ADDR
12653: GO 12827
12655: LD_INT 4
12657: DOUBLE
12658: EQUAL
12659: IFTRUE 12663
12661: GO 12674
12663: POP
// vysledek := u_hill ; 5 :
12664: LD_ADDR_VAR 0 3
12668: PUSH
12669: LD_INT 18
12671: ST_TO_ADDR
12672: GO 12827
12674: LD_INT 5
12676: DOUBLE
12677: EQUAL
12678: IFTRUE 12682
12680: GO 12693
12682: POP
// vysledek := u_walley ; 6 :
12683: LD_ADDR_VAR 0 3
12687: PUSH
12688: LD_INT 21
12690: ST_TO_ADDR
12691: GO 12827
12693: LD_INT 6
12695: DOUBLE
12696: EQUAL
12697: IFTRUE 12701
12699: GO 12712
12701: POP
// vysledek := u_forgotten ; 7 :
12702: LD_ADDR_VAR 0 3
12706: PUSH
12707: LD_INT 23
12709: ST_TO_ADDR
12710: GO 12827
12712: LD_INT 7
12714: DOUBLE
12715: EQUAL
12716: IFTRUE 12720
12718: GO 12731
12720: POP
// vysledek := u_south ; 8 :
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: LD_INT 20
12728: ST_TO_ADDR
12729: GO 12827
12731: LD_INT 8
12733: DOUBLE
12734: EQUAL
12735: IFTRUE 12739
12737: GO 12750
12739: POP
// vysledek := u_heart ; 9 :
12740: LD_ADDR_VAR 0 3
12744: PUSH
12745: LD_INT 22
12747: ST_TO_ADDR
12748: GO 12827
12750: LD_INT 9
12752: DOUBLE
12753: EQUAL
12754: IFTRUE 12758
12756: GO 12769
12758: POP
// vysledek := u_east ; 11 :
12759: LD_ADDR_VAR 0 3
12763: PUSH
12764: LD_INT 24
12766: ST_TO_ADDR
12767: GO 12827
12769: LD_INT 11
12771: DOUBLE
12772: EQUAL
12773: IFTRUE 12777
12775: GO 12788
12777: POP
// vysledek := n_gather ; 12 :
12778: LD_ADDR_VAR 0 3
12782: PUSH
12783: LD_INT 13
12785: ST_TO_ADDR
12786: GO 12827
12788: LD_INT 12
12790: DOUBLE
12791: EQUAL
12792: IFTRUE 12796
12794: GO 12807
12796: POP
// vysledek := e_gather ; 13 :
12797: LD_ADDR_VAR 0 3
12801: PUSH
12802: LD_INT 14
12804: ST_TO_ADDR
12805: GO 12827
12807: LD_INT 13
12809: DOUBLE
12810: EQUAL
12811: IFTRUE 12815
12813: GO 12826
12815: POP
// vysledek := s_gather ; end ;
12816: LD_ADDR_VAR 0 3
12820: PUSH
12821: LD_INT 15
12823: ST_TO_ADDR
12824: GO 12827
12826: POP
// result := vysledek ;
12827: LD_ADDR_VAR 0 2
12831: PUSH
12832: LD_VAR 0 3
12836: ST_TO_ADDR
// end ;
12837: LD_VAR 0 2
12841: RET
// function goto_north_sector ; var i , utocniku ; begin
12842: LD_INT 0
12844: PPUSH
12845: PPUSH
12846: PPUSH
// ComAgressiveMove ( attack_forces , 100 , 67 ) ;
12847: LD_EXP 55
12851: PPUSH
12852: LD_INT 100
12854: PPUSH
12855: LD_INT 67
12857: PPUSH
12858: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 87 , 65 ) ;
12862: LD_EXP 55
12866: PPUSH
12867: LD_INT 87
12869: PPUSH
12870: LD_INT 65
12872: PPUSH
12873: CALL_OW 174
// AddComAgressiveMove ( attack_forces , 74 , 64 ) ;
12877: LD_EXP 55
12881: PPUSH
12882: LD_INT 74
12884: PPUSH
12885: LD_INT 64
12887: PPUSH
12888: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12892: LD_INT 70
12894: PPUSH
12895: CALL_OW 67
// until vsichni_v_arei ( n_gather ) or ( not attack_forces ) ;
12899: LD_INT 13
12901: PPUSH
12902: CALL 13712 0 1
12906: PUSH
12907: LD_EXP 55
12911: NOT
12912: OR
12913: IFFALSE 12892
// attack_begin := true ;
12915: LD_ADDR_LOC 32
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// end ;
12923: LD_VAR 0 1
12927: RET
// function goto_east_sector ; var i , utocniku ; begin
12928: LD_INT 0
12930: PPUSH
12931: PPUSH
12932: PPUSH
// utocniku := 0 + attack_forces ;
12933: LD_ADDR_VAR 0 3
12937: PUSH
12938: LD_INT 0
12940: PUSH
12941: LD_EXP 55
12945: PLUS
12946: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12947: LD_EXP 55
12951: PPUSH
12952: LD_INT 111
12954: PPUSH
12955: LD_INT 73
12957: PPUSH
12958: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 116 , 95 ) ;
12962: LD_EXP 55
12966: PPUSH
12967: LD_INT 116
12969: PPUSH
12970: LD_INT 95
12972: PPUSH
12973: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12977: LD_INT 70
12979: PPUSH
12980: CALL_OW 67
// until vsichni_v_arei ( e_gather ) or ( not attack_forces ) ;
12984: LD_INT 14
12986: PPUSH
12987: CALL 13712 0 1
12991: PUSH
12992: LD_EXP 55
12996: NOT
12997: OR
12998: IFFALSE 12977
// attack_begin := true ;
13000: LD_ADDR_LOC 32
13004: PUSH
13005: LD_INT 1
13007: ST_TO_ADDR
// end ;
13008: LD_VAR 0 1
13012: RET
// function goto_south_sector ; var i , utocniku ; begin
13013: LD_INT 0
13015: PPUSH
13016: PPUSH
13017: PPUSH
// utocniku := 0 + attack_forces ;
13018: LD_ADDR_VAR 0 3
13022: PUSH
13023: LD_INT 0
13025: PUSH
13026: LD_EXP 55
13030: PLUS
13031: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
13032: LD_EXP 55
13036: PPUSH
13037: LD_INT 111
13039: PPUSH
13040: LD_INT 73
13042: PPUSH
13043: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 127 , 118 ) ;
13047: LD_EXP 55
13051: PPUSH
13052: LD_INT 127
13054: PPUSH
13055: LD_INT 118
13057: PPUSH
13058: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
13062: LD_INT 70
13064: PPUSH
13065: CALL_OW 67
// until vsichni_v_arei ( s_gather ) or ( not attack_forces ) ;
13069: LD_INT 15
13071: PPUSH
13072: CALL 13712 0 1
13076: PUSH
13077: LD_EXP 55
13081: NOT
13082: OR
13083: IFFALSE 13062
// attack_begin := true ;
13085: LD_ADDR_LOC 32
13089: PUSH
13090: LD_INT 1
13092: ST_TO_ADDR
// end ;
13093: LD_VAR 0 1
13097: RET
// function zjisti_schudne_okoli ( area ) ; var a1 , a2 , vysledek ; var v1 , v2 ; begin
13098: LD_INT 0
13100: PPUSH
13101: PPUSH
13102: PPUSH
13103: PPUSH
13104: PPUSH
13105: PPUSH
// case area of 1 :
13106: LD_VAR 0 1
13110: PUSH
13111: LD_INT 1
13113: DOUBLE
13114: EQUAL
13115: IFTRUE 13119
13117: GO 13138
13119: POP
// begin a1 := 2 ;
13120: LD_ADDR_VAR 0 3
13124: PUSH
13125: LD_INT 2
13127: ST_TO_ADDR
// a2 := 0 ;
13128: LD_ADDR_VAR 0 4
13132: PUSH
13133: LD_INT 0
13135: ST_TO_ADDR
// end ; 2 :
13136: GO 13436
13138: LD_INT 2
13140: DOUBLE
13141: EQUAL
13142: IFTRUE 13146
13144: GO 13165
13146: POP
// begin a1 := 3 ;
13147: LD_ADDR_VAR 0 3
13151: PUSH
13152: LD_INT 3
13154: ST_TO_ADDR
// a2 := 8 ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 8
13162: ST_TO_ADDR
// end ; 3 :
13163: GO 13436
13165: LD_INT 3
13167: DOUBLE
13168: EQUAL
13169: IFTRUE 13173
13171: GO 13192
13173: POP
// begin a1 := 7 ;
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_INT 7
13181: ST_TO_ADDR
// a2 := 2 ;
13182: LD_ADDR_VAR 0 4
13186: PUSH
13187: LD_INT 2
13189: ST_TO_ADDR
// end ; 4 :
13190: GO 13436
13192: LD_INT 4
13194: DOUBLE
13195: EQUAL
13196: IFTRUE 13200
13198: GO 13219
13200: POP
// begin a1 := 2 ;
13201: LD_ADDR_VAR 0 3
13205: PUSH
13206: LD_INT 2
13208: ST_TO_ADDR
// a2 := 3 ;
13209: LD_ADDR_VAR 0 4
13213: PUSH
13214: LD_INT 3
13216: ST_TO_ADDR
// end ; 5 :
13217: GO 13436
13219: LD_INT 5
13221: DOUBLE
13222: EQUAL
13223: IFTRUE 13227
13225: GO 13246
13227: POP
// begin a1 := 3 ;
13228: LD_ADDR_VAR 0 3
13232: PUSH
13233: LD_INT 3
13235: ST_TO_ADDR
// a2 := 6 ;
13236: LD_ADDR_VAR 0 4
13240: PUSH
13241: LD_INT 6
13243: ST_TO_ADDR
// end ; 6 :
13244: GO 13436
13246: LD_INT 6
13248: DOUBLE
13249: EQUAL
13250: IFTRUE 13254
13252: GO 13273
13254: POP
// begin a1 := 7 ;
13255: LD_ADDR_VAR 0 3
13259: PUSH
13260: LD_INT 7
13262: ST_TO_ADDR
// a2 := 3 ;
13263: LD_ADDR_VAR 0 4
13267: PUSH
13268: LD_INT 3
13270: ST_TO_ADDR
// end ; 7 :
13271: GO 13436
13273: LD_INT 7
13275: DOUBLE
13276: EQUAL
13277: IFTRUE 13281
13279: GO 13300
13281: POP
// begin a1 := 8 ;
13282: LD_ADDR_VAR 0 3
13286: PUSH
13287: LD_INT 8
13289: ST_TO_ADDR
// a2 := 3 ;
13290: LD_ADDR_VAR 0 4
13294: PUSH
13295: LD_INT 3
13297: ST_TO_ADDR
// end ; 8 :
13298: GO 13436
13300: LD_INT 8
13302: DOUBLE
13303: EQUAL
13304: IFTRUE 13308
13306: GO 13327
13308: POP
// begin a1 := 2 ;
13309: LD_ADDR_VAR 0 3
13313: PUSH
13314: LD_INT 2
13316: ST_TO_ADDR
// a2 := 7 ;
13317: LD_ADDR_VAR 0 4
13321: PUSH
13322: LD_INT 7
13324: ST_TO_ADDR
// end ; 9 :
13325: GO 13436
13327: LD_INT 9
13329: DOUBLE
13330: EQUAL
13331: IFTRUE 13335
13333: GO 13354
13335: POP
// begin a1 := 2 ;
13336: LD_ADDR_VAR 0 3
13340: PUSH
13341: LD_INT 2
13343: ST_TO_ADDR
// a2 := 5 ;
13344: LD_ADDR_VAR 0 4
13348: PUSH
13349: LD_INT 5
13351: ST_TO_ADDR
// end ; 11 :
13352: GO 13436
13354: LD_INT 11
13356: DOUBLE
13357: EQUAL
13358: IFTRUE 13362
13360: GO 13381
13362: POP
// begin a1 := 1 ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 1
13370: ST_TO_ADDR
// a2 := 0 ;
13371: LD_ADDR_VAR 0 4
13375: PUSH
13376: LD_INT 0
13378: ST_TO_ADDR
// end ; 12 :
13379: GO 13436
13381: LD_INT 12
13383: DOUBLE
13384: EQUAL
13385: IFTRUE 13389
13387: GO 13408
13389: POP
// begin a1 := 5 ;
13390: LD_ADDR_VAR 0 3
13394: PUSH
13395: LD_INT 5
13397: ST_TO_ADDR
// a2 := 0 ;
13398: LD_ADDR_VAR 0 4
13402: PUSH
13403: LD_INT 0
13405: ST_TO_ADDR
// end ; 13 :
13406: GO 13436
13408: LD_INT 13
13410: DOUBLE
13411: EQUAL
13412: IFTRUE 13416
13414: GO 13435
13416: POP
// begin a1 := 9 ;
13417: LD_ADDR_VAR 0 3
13421: PUSH
13422: LD_INT 9
13424: ST_TO_ADDR
// a2 := 0 ;
13425: LD_ADDR_VAR 0 4
13429: PUSH
13430: LD_INT 0
13432: ST_TO_ADDR
// end ; end ;
13433: GO 13436
13435: POP
// v1 := [ a1 ] ;
13436: LD_ADDR_VAR 0 6
13440: PUSH
13441: LD_VAR 0 3
13445: PUSH
13446: EMPTY
13447: LIST
13448: ST_TO_ADDR
// if a2 then
13449: LD_VAR 0 4
13453: IFFALSE 13471
// v1 := v1 ^ a1 ;
13455: LD_ADDR_VAR 0 6
13459: PUSH
13460: LD_VAR 0 6
13464: PUSH
13465: LD_VAR 0 3
13469: ADD
13470: ST_TO_ADDR
// vysledek := v1 [ Rand ( 1 , v1 ) ] ;
13471: LD_ADDR_VAR 0 5
13475: PUSH
13476: LD_VAR 0 6
13480: PUSH
13481: LD_INT 1
13483: PPUSH
13484: LD_VAR 0 6
13488: PPUSH
13489: CALL_OW 12
13493: ARRAY
13494: ST_TO_ADDR
// result := vysledek ;
13495: LD_ADDR_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ST_TO_ADDR
// end ;
13505: LD_VAR 0 2
13509: RET
// function navrhni_startovni_pozici ; var s1 , s2 , s3 , vysledek ; var un , truck ; begin
13510: LD_INT 0
13512: PPUSH
13513: PPUSH
13514: PPUSH
13515: PPUSH
13516: PPUSH
13517: PPUSH
13518: PPUSH
// s1 := klic_area_1 ;
13519: LD_ADDR_VAR 0 2
13523: PUSH
13524: LD_LOC 18
13528: ST_TO_ADDR
// s2 := klic_area_9 ;
13529: LD_ADDR_VAR 0 3
13533: PUSH
13534: LD_LOC 26
13538: ST_TO_ADDR
// s3 := klic_area_5 ;
13539: LD_ADDR_VAR 0 4
13543: PUSH
13544: LD_LOC 22
13548: ST_TO_ADDR
// truck := true ;
13549: LD_ADDR_VAR 0 7
13553: PUSH
13554: LD_INT 1
13556: ST_TO_ADDR
// for un in attack_forces do
13557: LD_ADDR_VAR 0 6
13561: PUSH
13562: LD_EXP 55
13566: PUSH
13567: FOR_IN
13568: IFFALSE 13595
// if GetChassis ( un ) <> ru_heavy_tracked then
13570: LD_VAR 0 6
13574: PPUSH
13575: CALL_OW 265
13579: PUSH
13580: LD_INT 24
13582: NONEQUAL
13583: IFFALSE 13593
// truck := false ;
13585: LD_ADDR_VAR 0 7
13589: PUSH
13590: LD_INT 0
13592: ST_TO_ADDR
13593: GO 13567
13595: POP
13596: POP
// if ( a_jmeno ( s1 ) < a_jmeno ( s2 ) ) and ( a_jmeno ( s1 ) < a_jmeno ( s3 ) ) and truck then
13597: LD_VAR 0 2
13601: PPUSH
13602: CALL 12589 0 1
13606: PUSH
13607: LD_VAR 0 3
13611: PPUSH
13612: CALL 12589 0 1
13616: LESS
13617: PUSH
13618: LD_VAR 0 2
13622: PPUSH
13623: CALL 12589 0 1
13627: PUSH
13628: LD_VAR 0 4
13632: PPUSH
13633: CALL 12589 0 1
13637: LESS
13638: AND
13639: PUSH
13640: LD_VAR 0 7
13644: AND
13645: IFFALSE 13657
// vysledek := 1 else
13647: LD_ADDR_VAR 0 5
13651: PUSH
13652: LD_INT 1
13654: ST_TO_ADDR
13655: GO 13697
// if ( a_jmeno ( s2 ) < a_jmeno ( s3 ) ) then
13657: LD_VAR 0 3
13661: PPUSH
13662: CALL 12589 0 1
13666: PUSH
13667: LD_VAR 0 4
13671: PPUSH
13672: CALL 12589 0 1
13676: LESS
13677: IFFALSE 13689
// vysledek := 9 else
13679: LD_ADDR_VAR 0 5
13683: PUSH
13684: LD_INT 9
13686: ST_TO_ADDR
13687: GO 13697
// vysledek := 5 ;
13689: LD_ADDR_VAR 0 5
13693: PUSH
13694: LD_INT 5
13696: ST_TO_ADDR
// result := vysledek ;
13697: LD_ADDR_VAR 0 1
13701: PUSH
13702: LD_VAR 0 5
13706: ST_TO_ADDR
// end ;
13707: LD_VAR 0 1
13711: RET
// function vsichni_v_arei ( ktera_area ) ; var un , vysledek ; begin
13712: LD_INT 0
13714: PPUSH
13715: PPUSH
13716: PPUSH
// un := FilterUnitsInArea ( ktera_area , [ [ f_side , russians ] ] ) ;
13717: LD_ADDR_VAR 0 3
13721: PUSH
13722: LD_VAR 0 1
13726: PPUSH
13727: LD_INT 22
13729: PUSH
13730: LD_EXP 15
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: EMPTY
13740: LIST
13741: PPUSH
13742: CALL_OW 70
13746: ST_TO_ADDR
// if un >= ( ( attack_forces + 1 ) div 2 ) then
13747: LD_VAR 0 3
13751: PUSH
13752: LD_EXP 55
13756: PUSH
13757: LD_INT 1
13759: PLUS
13760: PUSH
13761: LD_INT 2
13763: DIV
13764: GREATEREQUAL
13765: IFFALSE 13777
// vysledek := true else
13767: LD_ADDR_VAR 0 4
13771: PUSH
13772: LD_INT 1
13774: ST_TO_ADDR
13775: GO 13785
// vysledek := false ;
13777: LD_ADDR_VAR 0 4
13781: PUSH
13782: LD_INT 0
13784: ST_TO_ADDR
// result := vysledek ;
13785: LD_ADDR_VAR 0 2
13789: PUSH
13790: LD_VAR 0 4
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// function see_important ( now_area ) ; var un , area , vysledek ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
13805: PPUSH
// vysledek := false ;
13806: LD_ADDR_VAR 0 5
13810: PUSH
13811: LD_INT 0
13813: ST_TO_ADDR
// area := [ ] ;
13814: LD_ADDR_VAR 0 4
13818: PUSH
13819: EMPTY
13820: ST_TO_ADDR
// for un in us_important do
13821: LD_ADDR_VAR 0 3
13825: PUSH
13826: LD_EXP 65
13830: PUSH
13831: FOR_IN
13832: IFFALSE 14141
// if See ( russians , un ) then
13834: LD_EXP 15
13838: PPUSH
13839: LD_VAR 0 3
13843: PPUSH
13844: CALL_OW 292
13848: IFFALSE 14139
// begin area := area ^ un ;
13850: LD_ADDR_VAR 0 4
13854: PUSH
13855: LD_VAR 0 4
13859: PUSH
13860: LD_VAR 0 3
13864: ADD
13865: ST_TO_ADDR
// case now_area of 1 :
13866: LD_VAR 0 1
13870: PUSH
13871: LD_INT 1
13873: DOUBLE
13874: EQUAL
13875: IFTRUE 13879
13877: GO 13898
13879: POP
// klic_area_1 := klic_area_1 union area ; 2 :
13880: LD_ADDR_LOC 18
13884: PUSH
13885: LD_LOC 18
13889: PUSH
13890: LD_VAR 0 4
13894: UNION
13895: ST_TO_ADDR
13896: GO 14115
13898: LD_INT 2
13900: DOUBLE
13901: EQUAL
13902: IFTRUE 13906
13904: GO 13925
13906: POP
// klic_area_2 := klic_area_2 union area ; 3 :
13907: LD_ADDR_LOC 19
13911: PUSH
13912: LD_LOC 19
13916: PUSH
13917: LD_VAR 0 4
13921: UNION
13922: ST_TO_ADDR
13923: GO 14115
13925: LD_INT 3
13927: DOUBLE
13928: EQUAL
13929: IFTRUE 13933
13931: GO 13952
13933: POP
// klic_area_3 := klic_area_3 union area ; 4 :
13934: LD_ADDR_LOC 20
13938: PUSH
13939: LD_LOC 20
13943: PUSH
13944: LD_VAR 0 4
13948: UNION
13949: ST_TO_ADDR
13950: GO 14115
13952: LD_INT 4
13954: DOUBLE
13955: EQUAL
13956: IFTRUE 13960
13958: GO 13979
13960: POP
// klic_area_4 := klic_area_4 union area ; 5 :
13961: LD_ADDR_LOC 21
13965: PUSH
13966: LD_LOC 21
13970: PUSH
13971: LD_VAR 0 4
13975: UNION
13976: ST_TO_ADDR
13977: GO 14115
13979: LD_INT 5
13981: DOUBLE
13982: EQUAL
13983: IFTRUE 13987
13985: GO 14006
13987: POP
// klic_area_5 := klic_area_5 union area ; 6 :
13988: LD_ADDR_LOC 22
13992: PUSH
13993: LD_LOC 22
13997: PUSH
13998: LD_VAR 0 4
14002: UNION
14003: ST_TO_ADDR
14004: GO 14115
14006: LD_INT 6
14008: DOUBLE
14009: EQUAL
14010: IFTRUE 14014
14012: GO 14033
14014: POP
// klic_area_6 := klic_area_6 union area ; 7 :
14015: LD_ADDR_LOC 23
14019: PUSH
14020: LD_LOC 23
14024: PUSH
14025: LD_VAR 0 4
14029: UNION
14030: ST_TO_ADDR
14031: GO 14115
14033: LD_INT 7
14035: DOUBLE
14036: EQUAL
14037: IFTRUE 14041
14039: GO 14060
14041: POP
// klic_area_7 := klic_area_7 union area ; 8 :
14042: LD_ADDR_LOC 24
14046: PUSH
14047: LD_LOC 24
14051: PUSH
14052: LD_VAR 0 4
14056: UNION
14057: ST_TO_ADDR
14058: GO 14115
14060: LD_INT 8
14062: DOUBLE
14063: EQUAL
14064: IFTRUE 14068
14066: GO 14087
14068: POP
// klic_area_8 := klic_area_8 union area ; 9 :
14069: LD_ADDR_LOC 25
14073: PUSH
14074: LD_LOC 25
14078: PUSH
14079: LD_VAR 0 4
14083: UNION
14084: ST_TO_ADDR
14085: GO 14115
14087: LD_INT 9
14089: DOUBLE
14090: EQUAL
14091: IFTRUE 14095
14093: GO 14114
14095: POP
// klic_area_9 := klic_area_9 union area ; end ;
14096: LD_ADDR_LOC 26
14100: PUSH
14101: LD_LOC 26
14105: PUSH
14106: LD_VAR 0 4
14110: UNION
14111: ST_TO_ADDR
14112: GO 14115
14114: POP
// destroy_now := destroy_now union un ;
14115: LD_ADDR_LOC 27
14119: PUSH
14120: LD_LOC 27
14124: PUSH
14125: LD_VAR 0 3
14129: UNION
14130: ST_TO_ADDR
// vysledek := true ;
14131: LD_ADDR_VAR 0 5
14135: PUSH
14136: LD_INT 1
14138: ST_TO_ADDR
// end ;
14139: GO 13831
14141: POP
14142: POP
// result := vysledek ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_VAR 0 5
14152: ST_TO_ADDR
// end ;
14153: LD_VAR 0 2
14157: RET
// function destroy_important ( area ) ; var i , j , max , max_search ; var cil , prior_1 , prior_max ; begin
14158: LD_INT 0
14160: PPUSH
14161: PPUSH
14162: PPUSH
14163: PPUSH
14164: PPUSH
14165: PPUSH
14166: PPUSH
14167: PPUSH
// max_search := 3 ;
14168: LD_ADDR_VAR 0 6
14172: PUSH
14173: LD_INT 3
14175: ST_TO_ADDR
// max := 0 + destroy_now ;
14176: LD_ADDR_VAR 0 5
14180: PUSH
14181: LD_INT 0
14183: PUSH
14184: LD_LOC 27
14188: PLUS
14189: ST_TO_ADDR
// if max > 3 then
14190: LD_VAR 0 5
14194: PUSH
14195: LD_INT 3
14197: GREATER
14198: IFFALSE 14210
// j := 3 else
14200: LD_ADDR_VAR 0 4
14204: PUSH
14205: LD_INT 3
14207: ST_TO_ADDR
14208: GO 14220
// j := max ;
14210: LD_ADDR_VAR 0 4
14214: PUSH
14215: LD_VAR 0 5
14219: ST_TO_ADDR
// prior_max := [ 0 , 0 ] ;
14220: LD_ADDR_VAR 0 9
14224: PUSH
14225: LD_INT 0
14227: PUSH
14228: LD_INT 0
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: ST_TO_ADDR
// for i = 1 to j do
14235: LD_ADDR_VAR 0 3
14239: PUSH
14240: DOUBLE
14241: LD_INT 1
14243: DEC
14244: ST_TO_ADDR
14245: LD_VAR 0 4
14249: PUSH
14250: FOR_TO
14251: IFFALSE 14529
// begin prior_1 := 0 ;
14253: LD_ADDR_VAR 0 8
14257: PUSH
14258: LD_INT 0
14260: ST_TO_ADDR
// case GetBType ( destroy_now [ i ] ) of 33 :
14261: LD_LOC 27
14265: PUSH
14266: LD_VAR 0 3
14270: ARRAY
14271: PPUSH
14272: CALL_OW 266
14276: PUSH
14277: LD_INT 33
14279: DOUBLE
14280: EQUAL
14281: IFTRUE 14285
14283: GO 14296
14285: POP
// prior_1 := 4 ; 30 :
14286: LD_ADDR_VAR 0 8
14290: PUSH
14291: LD_INT 4
14293: ST_TO_ADDR
14294: GO 14381
14296: LD_INT 30
14298: DOUBLE
14299: EQUAL
14300: IFTRUE 14304
14302: GO 14315
14304: POP
// prior_1 := 4 ; 29 :
14305: LD_ADDR_VAR 0 8
14309: PUSH
14310: LD_INT 4
14312: ST_TO_ADDR
14313: GO 14381
14315: LD_INT 29
14317: DOUBLE
14318: EQUAL
14319: IFTRUE 14323
14321: GO 14334
14323: POP
// prior_1 := 3 ; 28 :
14324: LD_ADDR_VAR 0 8
14328: PUSH
14329: LD_INT 3
14331: ST_TO_ADDR
14332: GO 14381
14334: LD_INT 28
14336: DOUBLE
14337: EQUAL
14338: IFTRUE 14342
14340: GO 14353
14342: POP
// prior_1 := 3 ; 26 :
14343: LD_ADDR_VAR 0 8
14347: PUSH
14348: LD_INT 3
14350: ST_TO_ADDR
14351: GO 14381
14353: LD_INT 26
14355: DOUBLE
14356: EQUAL
14357: IFTRUE 14361
14359: GO 14372
14361: POP
// prior_1 := 2 ; else
14362: LD_ADDR_VAR 0 8
14366: PUSH
14367: LD_INT 2
14369: ST_TO_ADDR
14370: GO 14381
14372: POP
// prior_1 := 1 ; end ;
14373: LD_ADDR_VAR 0 8
14377: PUSH
14378: LD_INT 1
14380: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 750 then
14381: LD_LOC 27
14385: PUSH
14386: LD_VAR 0 3
14390: ARRAY
14391: PPUSH
14392: CALL_OW 256
14396: PUSH
14397: LD_INT 750
14399: LESS
14400: IFFALSE 14416
// prior_1 := prior_1 + 1 ;
14402: LD_ADDR_VAR 0 8
14406: PUSH
14407: LD_VAR 0 8
14411: PUSH
14412: LD_INT 1
14414: PLUS
14415: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 500 then
14416: LD_LOC 27
14420: PUSH
14421: LD_VAR 0 3
14425: ARRAY
14426: PPUSH
14427: CALL_OW 256
14431: PUSH
14432: LD_INT 500
14434: LESS
14435: IFFALSE 14451
// prior_1 := prior_1 + 2 ;
14437: LD_ADDR_VAR 0 8
14441: PUSH
14442: LD_VAR 0 8
14446: PUSH
14447: LD_INT 2
14449: PLUS
14450: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 250 then
14451: LD_LOC 27
14455: PUSH
14456: LD_VAR 0 3
14460: ARRAY
14461: PPUSH
14462: CALL_OW 256
14466: PUSH
14467: LD_INT 250
14469: LESS
14470: IFFALSE 14486
// prior_1 := prior_1 + 2 ;
14472: LD_ADDR_VAR 0 8
14476: PUSH
14477: LD_VAR 0 8
14481: PUSH
14482: LD_INT 2
14484: PLUS
14485: ST_TO_ADDR
// if prior_1 > prior_max [ 1 ] then
14486: LD_VAR 0 8
14490: PUSH
14491: LD_VAR 0 9
14495: PUSH
14496: LD_INT 1
14498: ARRAY
14499: GREATER
14500: IFFALSE 14527
// prior_max := [ prior_1 , destroy_now [ i ] ] ;
14502: LD_ADDR_VAR 0 9
14506: PUSH
14507: LD_VAR 0 8
14511: PUSH
14512: LD_LOC 27
14516: PUSH
14517: LD_VAR 0 3
14521: ARRAY
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: ST_TO_ADDR
// end ;
14527: GO 14250
14529: POP
14530: POP
// if prior_max [ 2 ] then
14531: LD_VAR 0 9
14535: PUSH
14536: LD_INT 2
14538: ARRAY
14539: IFFALSE 14582
// DestroyTarget ( prior_max [ 2 ] , GetX ( prior_max [ 2 ] ) , GetY ( prior_max [ 2 ] ) ) ;
14541: LD_VAR 0 9
14545: PUSH
14546: LD_INT 2
14548: ARRAY
14549: PPUSH
14550: LD_VAR 0 9
14554: PUSH
14555: LD_INT 2
14557: ARRAY
14558: PPUSH
14559: CALL_OW 250
14563: PPUSH
14564: LD_VAR 0 9
14568: PUSH
14569: LD_INT 2
14571: ARRAY
14572: PPUSH
14573: CALL_OW 251
14577: PPUSH
14578: CALL 14587 0 3
// end ;
14582: LD_VAR 0 2
14586: RET
// function DestroyTarget ( target , x , y ) ; var un ; begin
14587: LD_INT 0
14589: PPUSH
14590: PPUSH
// for un in attack_forces do
14591: LD_ADDR_VAR 0 5
14595: PUSH
14596: LD_EXP 55
14600: PUSH
14601: FOR_IN
14602: IFFALSE 14663
// if GetWeapon ( un ) in [ ru_rocket , ru_rocket_launcher ] then
14604: LD_VAR 0 5
14608: PPUSH
14609: CALL_OW 264
14613: PUSH
14614: LD_INT 47
14616: PUSH
14617: LD_INT 45
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: IN
14624: IFFALSE 14647
// ComAttackPlace ( un , x , y ) else
14626: LD_VAR 0 5
14630: PPUSH
14631: LD_VAR 0 2
14635: PPUSH
14636: LD_VAR 0 3
14640: PPUSH
14641: CALL_OW 116
14645: GO 14661
// ComAttackUnit ( un , target ) ;
14647: LD_VAR 0 5
14651: PPUSH
14652: LD_VAR 0 1
14656: PPUSH
14657: CALL_OW 115
14661: GO 14601
14663: POP
14664: POP
// end ;
14665: LD_VAR 0 4
14669: RET
// function konec_jednoho_utoku ; begin
14670: LD_INT 0
14672: PPUSH
// war_forces := war_forces ^ attack_forces ;
14673: LD_ADDR_EXP 52
14677: PUSH
14678: LD_EXP 52
14682: PUSH
14683: LD_EXP 55
14687: ADD
14688: ST_TO_ADDR
// attack_forces := [ ] ;
14689: LD_ADDR_EXP 55
14693: PUSH
14694: EMPTY
14695: ST_TO_ADDR
// attack_begin := false ;
14696: LD_ADDR_LOC 32
14700: PUSH
14701: LD_INT 0
14703: ST_TO_ADDR
// war_count := Rand ( cislo_utoku + 1 , cislo_utoku + 3 ) ;
14704: LD_ADDR_EXP 54
14708: PUSH
14709: LD_LOC 33
14713: PUSH
14714: LD_INT 1
14716: PLUS
14717: PPUSH
14718: LD_LOC 33
14722: PUSH
14723: LD_INT 3
14725: PLUS
14726: PPUSH
14727: CALL_OW 12
14731: ST_TO_ADDR
// if war_count > 4 then
14732: LD_EXP 54
14736: PUSH
14737: LD_INT 4
14739: GREATER
14740: IFFALSE 14758
// war_count := Rand ( 4 , 5 ) ;
14742: LD_ADDR_EXP 54
14746: PUSH
14747: LD_INT 4
14749: PPUSH
14750: LD_INT 5
14752: PPUSH
14753: CALL_OW 12
14757: ST_TO_ADDR
// end ;
14758: LD_VAR 0 1
14762: RET
// function low_cesta ; var i , max , areas , mc_id , new_destination ; begin
14763: LD_INT 0
14765: PPUSH
14766: PPUSH
14767: PPUSH
14768: PPUSH
14769: PPUSH
14770: PPUSH
// multi := false ;
14771: LD_ADDR_LOC 29
14775: PUSH
14776: LD_INT 0
14778: ST_TO_ADDR
// attack_begin := false ;
14779: LD_ADDR_LOC 32
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// max := 0 + attack_forces ;
14787: LD_ADDR_VAR 0 3
14791: PUSH
14792: LD_INT 0
14794: PUSH
14795: LD_EXP 55
14799: PLUS
14800: ST_TO_ADDR
// destroy_now := [ ] ;
14801: LD_ADDR_LOC 27
14805: PUSH
14806: EMPTY
14807: ST_TO_ADDR
// if cislo_utoku > 1 then
14808: LD_LOC 33
14812: PUSH
14813: LD_INT 1
14815: GREATER
14816: IFFALSE 14830
// now_area := navrhni_startovni_pozici else
14818: LD_ADDR_LOC 34
14822: PUSH
14823: CALL 13510 0 0
14827: ST_TO_ADDR
14828: GO 14838
// now_area := 1 ;
14830: LD_ADDR_LOC 34
14834: PUSH
14835: LD_INT 1
14837: ST_TO_ADDR
// case now_area of 1 :
14838: LD_LOC 34
14842: PUSH
14843: LD_INT 1
14845: DOUBLE
14846: EQUAL
14847: IFTRUE 14851
14849: GO 14858
14851: POP
// goto_north_sector ; 9 :
14852: CALL 12842 0 0
14856: GO 14889
14858: LD_INT 9
14860: DOUBLE
14861: EQUAL
14862: IFTRUE 14866
14864: GO 14873
14866: POP
// goto_east_sector ; 5 :
14867: CALL 12928 0 0
14871: GO 14889
14873: LD_INT 5
14875: DOUBLE
14876: EQUAL
14877: IFTRUE 14881
14879: GO 14888
14881: POP
// goto_south_sector ; end ;
14882: CALL 13013 0 0
14886: GO 14889
14888: POP
// repeat wait ( 0 0$1 ) ;
14889: LD_INT 35
14891: PPUSH
14892: CALL_OW 67
// until attack_begin ;
14896: LD_LOC 32
14900: IFFALSE 14889
// mc_id := 0 ;
14902: LD_ADDR_VAR 0 5
14906: PUSH
14907: LD_INT 0
14909: ST_TO_ADDR
// repeat next_area := zjisti_schudne_okoli ( now_area ) ;
14910: LD_ADDR_LOC 35
14914: PUSH
14915: LD_LOC 34
14919: PPUSH
14920: CALL 13098 0 1
14924: ST_TO_ADDR
// new_destination := zjisti_cilove_misto ( next_area ) ;
14925: LD_ADDR_VAR 0 6
14929: PUSH
14930: LD_LOC 35
14934: PPUSH
14935: CALL 12330 0 1
14939: ST_TO_ADDR
// repeat if see_important ( now_area ) then
14940: LD_LOC 34
14944: PPUSH
14945: CALL 13800 0 1
14949: IFFALSE 14990
// begin if ExistMc ( mc_id ) then
14951: LD_VAR 0 5
14955: PPUSH
14956: CALL_OW 386
14960: IFFALSE 14979
// begin KillMc ( mc_id ) ;
14962: LD_VAR 0 5
14966: PPUSH
14967: CALL_OW 387
// mc_id := 0 ;
14971: LD_ADDR_VAR 0 5
14975: PUSH
14976: LD_INT 0
14978: ST_TO_ADDR
// end ; destroy_important ( now_area ) ;
14979: LD_LOC 34
14983: PPUSH
14984: CALL 14158 0 1
// end else
14988: GO 15047
// if not ExistMc ( mc_id ) then
14990: LD_VAR 0 5
14994: PPUSH
14995: CALL_OW 386
14999: NOT
15000: IFFALSE 15047
// mc_id := McMove ( 2 , attack_forces , [ [ new_destination [ 1 ] , new_destination [ 2 ] ] ] , [ ] ) ;
15002: LD_ADDR_VAR 0 5
15006: PUSH
15007: LD_INT 2
15009: PPUSH
15010: LD_EXP 55
15014: PPUSH
15015: LD_VAR 0 6
15019: PUSH
15020: LD_INT 1
15022: ARRAY
15023: PUSH
15024: LD_VAR 0 6
15028: PUSH
15029: LD_INT 2
15031: ARRAY
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: PUSH
15037: EMPTY
15038: LIST
15039: PPUSH
15040: EMPTY
15041: PPUSH
15042: CALL_OW 398
15046: ST_TO_ADDR
// wait ( 0 0$3 ) ;
15047: LD_INT 105
15049: PPUSH
15050: CALL_OW 67
// until vsichni_v_arei ( a_jmeno ( next_area ) ) or ( not attack_forces ) ;
15054: LD_LOC 35
15058: PPUSH
15059: CALL 12589 0 1
15063: PPUSH
15064: CALL 13712 0 1
15068: PUSH
15069: LD_EXP 55
15073: NOT
15074: OR
15075: IFFALSE 14940
// now_area := next_area ;
15077: LD_ADDR_LOC 34
15081: PUSH
15082: LD_LOC 35
15086: ST_TO_ADDR
// until not attack_forces ;
15087: LD_EXP 55
15091: NOT
15092: IFFALSE 14910
// konec_jednoho_utoku ;
15094: CALL 14670 0 0
// cislo_utoku := cislo_utoku + 1 ;
15098: LD_ADDR_LOC 33
15102: PUSH
15103: LD_LOC 33
15107: PUSH
15108: LD_INT 1
15110: PLUS
15111: ST_TO_ADDR
// end ;
15112: LD_VAR 0 1
15116: RET
// function nacti_important_budovy ; var list_important , un ; begin
15117: LD_INT 0
15119: PPUSH
15120: PPUSH
15121: PPUSH
// us_important := [ ] ;
15122: LD_ADDR_EXP 65
15126: PUSH
15127: EMPTY
15128: ST_TO_ADDR
// list_important := FilterAllUnits ( [ [ f_or , [ f_side , you ] , [ f_side , neutral ] ] , [ f_type , unit_building ] ] ) ;
15129: LD_ADDR_VAR 0 2
15133: PUSH
15134: LD_INT 2
15136: PUSH
15137: LD_INT 22
15139: PUSH
15140: LD_EXP 14
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: LD_INT 22
15151: PUSH
15152: LD_EXP 16
15156: PUSH
15157: EMPTY
15158: LIST
15159: LIST
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: LIST
15165: PUSH
15166: LD_INT 21
15168: PUSH
15169: LD_INT 3
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PPUSH
15180: CALL_OW 69
15184: ST_TO_ADDR
// important := [ b_depot , b_warehouse , b_factory , b_armoury , b_barracks , b_lab_full , b_oil_power , b_solar_power , b_siberite_power , b_oil_mine , b_siberite_mine , b_breastwork , b_bunker , b_turret ] ;
15185: LD_ADDR_LOC 28
15189: PUSH
15190: LD_INT 0
15192: PUSH
15193: LD_INT 1
15195: PUSH
15196: LD_INT 3
15198: PUSH
15199: LD_INT 4
15201: PUSH
15202: LD_INT 5
15204: PUSH
15205: LD_INT 8
15207: PUSH
15208: LD_INT 26
15210: PUSH
15211: LD_INT 27
15213: PUSH
15214: LD_INT 28
15216: PUSH
15217: LD_INT 29
15219: PUSH
15220: LD_INT 30
15222: PUSH
15223: LD_INT 31
15225: PUSH
15226: LD_INT 32
15228: PUSH
15229: LD_INT 33
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: ST_TO_ADDR
// for un in list_important do
15248: LD_ADDR_VAR 0 3
15252: PUSH
15253: LD_VAR 0 2
15257: PUSH
15258: FOR_IN
15259: IFFALSE 15296
// begin if GetBType ( un ) in important then
15261: LD_VAR 0 3
15265: PPUSH
15266: CALL_OW 266
15270: PUSH
15271: LD_LOC 28
15275: IN
15276: IFFALSE 15294
// us_important := us_important ^ un ;
15278: LD_ADDR_EXP 65
15282: PUSH
15283: LD_EXP 65
15287: PUSH
15288: LD_VAR 0 3
15292: ADD
15293: ST_TO_ADDR
// end ;
15294: GO 15258
15296: POP
15297: POP
// end ;
15298: LD_VAR 0 1
15302: RET
// on UnitGoesToRed ( jednotka ) do begin event_unit := jednotka ;
15303: LD_ADDR_LOC 36
15307: PUSH
15308: LD_VAR 0 1
15312: ST_TO_ADDR
// if jednotka in attack_forces then
15313: LD_VAR 0 1
15317: PUSH
15318: LD_EXP 55
15322: IN
15323: IFFALSE 15361
// begin attack_forces := attack_forces diff [ jednotka ] ;
15325: LD_ADDR_EXP 55
15329: PUSH
15330: LD_EXP 55
15334: PUSH
15335: LD_VAR 0 1
15339: PUSH
15340: EMPTY
15341: LIST
15342: DIFF
15343: ST_TO_ADDR
// if ( not attack_forces ) and ( attack_begin ) then
15344: LD_EXP 55
15348: NOT
15349: PUSH
15350: LD_LOC 32
15354: AND
15355: IFFALSE 15361
// konec_jednoho_utoku ;
15357: CALL 14670 0 0
// end ; if ( ( jednotka = MacMillan ) and ( not IsOK ( survivor ) ) ) or ( ( jednotka = MacMillan ) and ( not visit_base ) ) then
15361: LD_VAR 0 1
15365: PUSH
15366: LD_EXP 1
15370: EQUAL
15371: PUSH
15372: LD_EXP 6
15376: PPUSH
15377: CALL_OW 302
15381: NOT
15382: AND
15383: PUSH
15384: LD_VAR 0 1
15388: PUSH
15389: LD_EXP 1
15393: EQUAL
15394: PUSH
15395: LD_EXP 34
15399: NOT
15400: AND
15401: OR
15402: IFFALSE 15408
// konec_mise ;
15404: CALL 755 0 0
// end ;
15408: PPOPN 1
15410: END
// on UnitDestroyed ( jednotka ) do var pomocna_mnozina ;
15411: LD_INT 0
15413: PPUSH
// begin event_unit := jednotka ;
15414: LD_ADDR_LOC 36
15418: PUSH
15419: LD_VAR 0 1
15423: ST_TO_ADDR
// attack_forces := attack_forces diff [ jednotka ] ;
15424: LD_ADDR_EXP 55
15428: PUSH
15429: LD_EXP 55
15433: PUSH
15434: LD_VAR 0 1
15438: PUSH
15439: EMPTY
15440: LIST
15441: DIFF
15442: ST_TO_ADDR
// us_important := us_important diff [ jednotka ] ;
15443: LD_ADDR_EXP 65
15447: PUSH
15448: LD_EXP 65
15452: PUSH
15453: LD_VAR 0 1
15457: PUSH
15458: EMPTY
15459: LIST
15460: DIFF
15461: ST_TO_ADDR
// destroy_now := destroy_now diff [ jednotka ] ;
15462: LD_ADDR_LOC 27
15466: PUSH
15467: LD_LOC 27
15471: PUSH
15472: LD_VAR 0 1
15476: PUSH
15477: EMPTY
15478: LIST
15479: DIFF
15480: ST_TO_ADDR
// case now_area of 1 :
15481: LD_LOC 34
15485: PUSH
15486: LD_INT 1
15488: DOUBLE
15489: EQUAL
15490: IFTRUE 15494
15492: GO 15516
15494: POP
// klic_area_1 := klic_area_1 diff [ jednotka ] ; 2 :
15495: LD_ADDR_LOC 18
15499: PUSH
15500: LD_LOC 18
15504: PUSH
15505: LD_VAR 0 1
15509: PUSH
15510: EMPTY
15511: LIST
15512: DIFF
15513: ST_TO_ADDR
15514: GO 15757
15516: LD_INT 2
15518: DOUBLE
15519: EQUAL
15520: IFTRUE 15524
15522: GO 15546
15524: POP
// klic_area_2 := klic_area_2 diff [ jednotka ] ; 3 :
15525: LD_ADDR_LOC 19
15529: PUSH
15530: LD_LOC 19
15534: PUSH
15535: LD_VAR 0 1
15539: PUSH
15540: EMPTY
15541: LIST
15542: DIFF
15543: ST_TO_ADDR
15544: GO 15757
15546: LD_INT 3
15548: DOUBLE
15549: EQUAL
15550: IFTRUE 15554
15552: GO 15576
15554: POP
// klic_area_3 := klic_area_3 diff [ jednotka ] ; 4 :
15555: LD_ADDR_LOC 20
15559: PUSH
15560: LD_LOC 20
15564: PUSH
15565: LD_VAR 0 1
15569: PUSH
15570: EMPTY
15571: LIST
15572: DIFF
15573: ST_TO_ADDR
15574: GO 15757
15576: LD_INT 4
15578: DOUBLE
15579: EQUAL
15580: IFTRUE 15584
15582: GO 15606
15584: POP
// klic_area_4 := klic_area_4 diff [ jednotka ] ; 5 :
15585: LD_ADDR_LOC 21
15589: PUSH
15590: LD_LOC 21
15594: PUSH
15595: LD_VAR 0 1
15599: PUSH
15600: EMPTY
15601: LIST
15602: DIFF
15603: ST_TO_ADDR
15604: GO 15757
15606: LD_INT 5
15608: DOUBLE
15609: EQUAL
15610: IFTRUE 15614
15612: GO 15636
15614: POP
// klic_area_5 := klic_area_5 diff [ jednotka ] ; 6 :
15615: LD_ADDR_LOC 22
15619: PUSH
15620: LD_LOC 22
15624: PUSH
15625: LD_VAR 0 1
15629: PUSH
15630: EMPTY
15631: LIST
15632: DIFF
15633: ST_TO_ADDR
15634: GO 15757
15636: LD_INT 6
15638: DOUBLE
15639: EQUAL
15640: IFTRUE 15644
15642: GO 15666
15644: POP
// klic_area_6 := klic_area_6 diff [ jednotka ] ; 7 :
15645: LD_ADDR_LOC 23
15649: PUSH
15650: LD_LOC 23
15654: PUSH
15655: LD_VAR 0 1
15659: PUSH
15660: EMPTY
15661: LIST
15662: DIFF
15663: ST_TO_ADDR
15664: GO 15757
15666: LD_INT 7
15668: DOUBLE
15669: EQUAL
15670: IFTRUE 15674
15672: GO 15696
15674: POP
// klic_area_7 := klic_area_7 diff [ jednotka ] ; 8 :
15675: LD_ADDR_LOC 24
15679: PUSH
15680: LD_LOC 24
15684: PUSH
15685: LD_VAR 0 1
15689: PUSH
15690: EMPTY
15691: LIST
15692: DIFF
15693: ST_TO_ADDR
15694: GO 15757
15696: LD_INT 8
15698: DOUBLE
15699: EQUAL
15700: IFTRUE 15704
15702: GO 15726
15704: POP
// klic_area_8 := klic_area_8 diff [ jednotka ] ; 9 :
15705: LD_ADDR_LOC 25
15709: PUSH
15710: LD_LOC 25
15714: PUSH
15715: LD_VAR 0 1
15719: PUSH
15720: EMPTY
15721: LIST
15722: DIFF
15723: ST_TO_ADDR
15724: GO 15757
15726: LD_INT 9
15728: DOUBLE
15729: EQUAL
15730: IFTRUE 15734
15732: GO 15756
15734: POP
// klic_area_9 := klic_area_9 diff [ jednotka ] ; end ;
15735: LD_ADDR_LOC 26
15739: PUSH
15740: LD_LOC 26
15744: PUSH
15745: LD_VAR 0 1
15749: PUSH
15750: EMPTY
15751: LIST
15752: DIFF
15753: ST_TO_ADDR
15754: GO 15757
15756: POP
// if jednotka = macmillan then
15757: LD_VAR 0 1
15761: PUSH
15762: LD_EXP 1
15766: EQUAL
15767: IFFALSE 15773
// konec_mise ;
15769: CALL 755 0 0
// if ( not attack_forces ) and ( attack_begin ) then
15773: LD_EXP 55
15777: NOT
15778: PUSH
15779: LD_LOC 32
15783: AND
15784: IFFALSE 15790
// konec_jednoho_utoku ;
15786: CALL 14670 0 0
// if GetSide ( jednotka ) = russians then
15790: LD_VAR 0 1
15794: PPUSH
15795: CALL_OW 255
15799: PUSH
15800: LD_EXP 15
15804: EQUAL
15805: IFFALSE 15894
// begin russians_forces := russians_forces diff jednotka ;
15807: LD_ADDR_EXP 28
15811: PUSH
15812: LD_EXP 28
15816: PUSH
15817: LD_VAR 0 1
15821: DIFF
15822: ST_TO_ADDR
// ru_ing := ru_ing diff jednotka ;
15823: LD_ADDR_EXP 24
15827: PUSH
15828: LD_EXP 24
15832: PUSH
15833: LD_VAR 0 1
15837: DIFF
15838: ST_TO_ADDR
// ru_sol := ru_sol diff jednotka ;
15839: LD_ADDR_EXP 25
15843: PUSH
15844: LD_EXP 25
15848: PUSH
15849: LD_VAR 0 1
15853: DIFF
15854: ST_TO_ADDR
// ru_sci := ru_sci diff jednotka ;
15855: LD_ADDR_EXP 26
15859: PUSH
15860: LD_EXP 26
15864: PUSH
15865: LD_VAR 0 1
15869: DIFF
15870: ST_TO_ADDR
// ru_mec := ru_mec diff jednotka ;
15871: LD_ADDR_EXP 27
15875: PUSH
15876: LD_EXP 27
15880: PUSH
15881: LD_VAR 0 1
15885: DIFF
15886: ST_TO_ADDR
// reserved_people := [ ] ;
15887: LD_ADDR_EXP 31
15891: PUSH
15892: EMPTY
15893: ST_TO_ADDR
// end ; end ;
15894: PPOPN 2
15896: END
// on VehicleCaptured ( veh_new , veh_old , veh_orig , veh_hum ) do begin if GetSide ( veh_old ) = russians then
15897: LD_VAR 0 2
15901: PPUSH
15902: CALL_OW 255
15906: PUSH
15907: LD_EXP 15
15911: EQUAL
15912: IFFALSE 15952
// begin war_forces := war_forces diff [ veh_old ] ;
15914: LD_ADDR_EXP 52
15918: PUSH
15919: LD_EXP 52
15923: PUSH
15924: LD_VAR 0 2
15928: PUSH
15929: EMPTY
15930: LIST
15931: DIFF
15932: ST_TO_ADDR
// attack_forces := attack_forces diff [ veh_old ] ;
15933: LD_ADDR_EXP 55
15937: PUSH
15938: LD_EXP 55
15942: PUSH
15943: LD_VAR 0 2
15947: PUSH
15948: EMPTY
15949: LIST
15950: DIFF
15951: ST_TO_ADDR
// end ; if ( not attack_forces ) and ( attack_begin ) then
15952: LD_EXP 55
15956: NOT
15957: PUSH
15958: LD_LOC 32
15962: AND
15963: IFFALSE 15969
// konec_jednoho_utoku ;
15965: CALL 14670 0 0
// end ;
15969: PPOPN 4
15971: END
// on BuildingComplete ( jednotka ) do begin if GetBType ( jednotka ) in important then
15972: LD_VAR 0 1
15976: PPUSH
15977: CALL_OW 266
15981: PUSH
15982: LD_LOC 28
15986: IN
15987: IFFALSE 16005
// us_important := us_important ^ jednotka ;
15989: LD_ADDR_EXP 65
15993: PUSH
15994: LD_EXP 65
15998: PUSH
15999: LD_VAR 0 1
16003: ADD
16004: ST_TO_ADDR
// end ;
16005: PPOPN 1
16007: END
// function multi_cesta ; begin
16008: LD_INT 0
16010: PPUSH
// multi := true ;
16011: LD_ADDR_LOC 29
16015: PUSH
16016: LD_INT 1
16018: ST_TO_ADDR
// end ;
16019: LD_VAR 0 1
16023: RET
// every 0 0$45 trigger ( war_forces >= war_count ) and ( not attack_begin ) do var list , un ;
16024: LD_EXP 52
16028: PUSH
16029: LD_EXP 54
16033: GREATEREQUAL
16034: PUSH
16035: LD_LOC 32
16039: NOT
16040: AND
16041: IFFALSE 16149
16043: GO 16045
16045: DISABLE
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
// begin list := [ ] ;
16050: LD_ADDR_VAR 0 1
16054: PUSH
16055: EMPTY
16056: ST_TO_ADDR
// for un in war_forces do
16057: LD_ADDR_VAR 0 2
16061: PUSH
16062: LD_EXP 52
16066: PUSH
16067: FOR_IN
16068: IFFALSE 16100
// if un in defend_forces then
16070: LD_VAR 0 2
16074: PUSH
16075: LD_EXP 64
16079: IN
16080: IFFALSE 16098
// list := list ^ un ;
16082: LD_ADDR_VAR 0 1
16086: PUSH
16087: LD_VAR 0 1
16091: PUSH
16092: LD_VAR 0 2
16096: ADD
16097: ST_TO_ADDR
16098: GO 16067
16100: POP
16101: POP
// if ( war_forces diff list ) < war_count then
16102: LD_EXP 52
16106: PUSH
16107: LD_VAR 0 1
16111: DIFF
16112: PUSH
16113: LD_EXP 54
16117: LESS
16118: IFFALSE 16123
// begin enable ;
16120: ENABLE
// exit ;
16121: GO 16149
// end ; attack_forces := war_forces ;
16123: LD_ADDR_EXP 55
16127: PUSH
16128: LD_EXP 52
16132: ST_TO_ADDR
// war_forces := [ ] ;
16133: LD_ADDR_EXP 52
16137: PUSH
16138: EMPTY
16139: ST_TO_ADDR
// nacti_important_budovy ;
16140: CALL 15117 0 0
// low_cesta ;
16144: CALL 14763 0 0
// enable ;
16148: ENABLE
// end ;
16149: PPOPN 2
16151: END
// every 0 0$5 trigger attack_forces > 0 do var un , puvodni_velikost ;
16152: LD_EXP 55
16156: PUSH
16157: LD_INT 0
16159: GREATER
16160: IFFALSE 16251
16162: GO 16164
16164: DISABLE
16165: LD_INT 0
16167: PPUSH
16168: PPUSH
// begin puvodni_velikost := 0 + attack_forces ;
16169: LD_ADDR_VAR 0 2
16173: PUSH
16174: LD_INT 0
16176: PUSH
16177: LD_EXP 55
16181: PLUS
16182: ST_TO_ADDR
// for un in attack_forces do
16183: LD_ADDR_VAR 0 1
16187: PUSH
16188: LD_EXP 55
16192: PUSH
16193: FOR_IN
16194: IFFALSE 16226
// if not IsOK ( un ) then
16196: LD_VAR 0 1
16200: PPUSH
16201: CALL_OW 302
16205: NOT
16206: IFFALSE 16224
// attack_forces := attack_forces diff un ;
16208: LD_ADDR_EXP 55
16212: PUSH
16213: LD_EXP 55
16217: PUSH
16218: LD_VAR 0 1
16222: DIFF
16223: ST_TO_ADDR
16224: GO 16193
16226: POP
16227: POP
// if ( attack_forces = [ ] ) and ( puvodni_velikost > 0 ) then
16228: LD_EXP 55
16232: PUSH
16233: EMPTY
16234: EQUAL
16235: PUSH
16236: LD_VAR 0 2
16240: PUSH
16241: LD_INT 0
16243: GREATER
16244: AND
16245: IFFALSE 16251
// konec_jednoho_utoku ;
16247: CALL 14670 0 0
// end ; end_of_file
16251: PPOPN 2
16253: END
// var id_reg , id_def ; function prepare_defend ( side ) ; var def_u ; begin
16254: LD_INT 0
16256: PPUSH
16257: PPUSH
// def_u := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_building ] , [ f_btype , b_turret ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_type , unit_vehicle ] ] ] ) ;
16258: LD_ADDR_VAR 0 3
16262: PUSH
16263: LD_INT 22
16265: PUSH
16266: LD_VAR 0 1
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: LD_INT 2
16277: PUSH
16278: LD_INT 21
16280: PUSH
16281: LD_INT 3
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PUSH
16288: LD_INT 30
16290: PUSH
16291: LD_INT 33
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 30
16300: PUSH
16301: LD_INT 32
16303: PUSH
16304: EMPTY
16305: LIST
16306: LIST
16307: PUSH
16308: LD_INT 30
16310: PUSH
16311: LD_INT 31
16313: PUSH
16314: EMPTY
16315: LIST
16316: LIST
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: PUSH
16324: LD_INT 21
16326: PUSH
16327: LD_INT 2
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: LIST
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PPUSH
16343: CALL_OW 69
16347: ST_TO_ADDR
// def_u := def_u union ru_sol ;
16348: LD_ADDR_VAR 0 3
16352: PUSH
16353: LD_VAR 0 3
16357: PUSH
16358: LD_EXP 25
16362: UNION
16363: ST_TO_ADDR
// def_u := def_u diff reserved_people ;
16364: LD_ADDR_VAR 0 3
16368: PUSH
16369: LD_VAR 0 3
16373: PUSH
16374: LD_EXP 31
16378: DIFF
16379: ST_TO_ADDR
// def_u := def_u diff ru_collector ;
16380: LD_ADDR_VAR 0 3
16384: PUSH
16385: LD_VAR 0 3
16389: PUSH
16390: LD_EXP 29
16394: DIFF
16395: ST_TO_ADDR
// def_u := ( def_u union war_forces ) union backup_forces ;
16396: LD_ADDR_VAR 0 3
16400: PUSH
16401: LD_VAR 0 3
16405: PUSH
16406: LD_EXP 52
16410: UNION
16411: PUSH
16412: LD_EXP 56
16416: UNION
16417: ST_TO_ADDR
// def_u := def_u union manual_forces ;
16418: LD_ADDR_VAR 0 3
16422: PUSH
16423: LD_VAR 0 3
16427: PUSH
16428: LD_EXP 59
16432: UNION
16433: ST_TO_ADDR
// result := def_u ;
16434: LD_ADDR_VAR 0 2
16438: PUSH
16439: LD_VAR 0 3
16443: ST_TO_ADDR
// end ;
16444: LD_VAR 0 2
16448: RET
// export function start_defend ; var side ; begin
16449: LD_INT 0
16451: PPUSH
16452: PPUSH
// id_reg := McRegistry ( 3 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , ru_defend ] , [ mc_reg_area_to_protect , ru_defend ] , [ mc_reg_units_to_protect , prepare_defend ( russians ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
16453: LD_ADDR_LOC 37
16457: PUSH
16458: LD_INT 3
16460: PPUSH
16461: LD_INT 1
16463: PUSH
16464: LD_INT 35
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PUSH
16471: LD_INT 5
16473: PUSH
16474: LD_INT 140
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: PUSH
16481: LD_INT 2
16483: PUSH
16484: LD_INT 27
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PUSH
16491: LD_INT 3
16493: PUSH
16494: LD_INT 27
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 4
16503: PUSH
16504: LD_EXP 15
16508: PPUSH
16509: CALL 16254 0 1
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PUSH
16518: LD_INT 8
16520: PUSH
16521: LD_INT 7
16523: NEG
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: LIST
16531: LIST
16532: LIST
16533: PPUSH
16534: CALL_OW 399
16538: ST_TO_ADDR
// id_def := McDefend ( 100 , id_reg , prepare_defend ( russians ) , [ [ mc_def_advantage , 500 ] , [ mc_area_dont_leave , ru_base ] , [ mc_retreat_area_people , ru_heal ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
16539: LD_ADDR_LOC 38
16543: PUSH
16544: LD_INT 100
16546: PPUSH
16547: LD_LOC 37
16551: PPUSH
16552: LD_EXP 15
16556: PPUSH
16557: CALL 16254 0 1
16561: PPUSH
16562: LD_INT 1
16564: PUSH
16565: LD_INT 500
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: PUSH
16572: LD_INT 2
16574: PUSH
16575: LD_INT 2
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: PUSH
16582: LD_INT 7
16584: PUSH
16585: LD_INT 28
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PUSH
16592: LD_INT 5
16594: PUSH
16595: LD_INT 600
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: LIST
16607: PPUSH
16608: CALL_OW 401
16612: ST_TO_ADDR
// end ;
16613: LD_VAR 0 1
16617: RET
// on McRegistryResultChanges ( mcid , n , s ) do begin if n then
16618: LD_VAR 0 2
16622: IFFALSE 16647
// begin AddMcUnits ( mcid , prepare_defend ( russians ) ) ;
16624: LD_VAR 0 1
16628: PPUSH
16629: LD_EXP 15
16633: PPUSH
16634: CALL 16254 0 1
16638: PPUSH
16639: CALL_OW 390
// SendForces ;
16643: CALL 16893 0 0
// end ; end ;
16647: PPOPN 3
16649: END
// every 0 0$5 do var side , sci , list ;
16650: GO 16652
16652: DISABLE
16653: LD_INT 0
16655: PPUSH
16656: PPUSH
16657: PPUSH
// begin list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 950 ] ] ] ) ;
16658: LD_ADDR_VAR 0 3
16662: PUSH
16663: LD_INT 28
16665: PPUSH
16666: LD_INT 22
16668: PUSH
16669: LD_EXP 15
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 21
16680: PUSH
16681: LD_INT 1
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 3
16690: PUSH
16691: LD_INT 24
16693: PUSH
16694: LD_INT 950
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: LIST
16709: PPUSH
16710: CALL_OW 70
16714: ST_TO_ADDR
// if list then
16715: LD_VAR 0 3
16719: IFFALSE 16889
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
16721: LD_ADDR_VAR 0 2
16725: PUSH
16726: LD_INT 22
16728: PUSH
16729: LD_EXP 15
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: PUSH
16738: LD_INT 25
16740: PUSH
16741: LD_INT 4
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: EMPTY
16749: LIST
16750: LIST
16751: PPUSH
16752: CALL_OW 69
16756: ST_TO_ADDR
// ComRemember ( sci ) ;
16757: LD_VAR 0 2
16761: PPUSH
16762: CALL_OW 143
// wait ( 5 ) ;
16766: LD_INT 5
16768: PPUSH
16769: CALL_OW 67
// ComMoveToArea ( sci , ru_heal ) ;
16773: LD_VAR 0 2
16777: PPUSH
16778: LD_INT 28
16780: PPUSH
16781: CALL_OW 113
// repeat list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
16785: LD_ADDR_VAR 0 3
16789: PUSH
16790: LD_INT 28
16792: PPUSH
16793: LD_INT 22
16795: PUSH
16796: LD_EXP 15
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: PUSH
16805: LD_INT 21
16807: PUSH
16808: LD_INT 1
16810: PUSH
16811: EMPTY
16812: LIST
16813: LIST
16814: PUSH
16815: LD_INT 3
16817: PUSH
16818: LD_INT 24
16820: PUSH
16821: LD_INT 1000
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: EMPTY
16833: LIST
16834: LIST
16835: LIST
16836: PPUSH
16837: CALL_OW 70
16841: ST_TO_ADDR
// if list then
16842: LD_VAR 0 3
16846: IFFALSE 16866
// AddComHeal ( sci , list [ 1 ] ) ;
16848: LD_VAR 0 2
16852: PPUSH
16853: LD_VAR 0 3
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 188
// wait ( 0 0$2 ) ;
16866: LD_INT 70
16868: PPUSH
16869: CALL_OW 67
// until not list ;
16873: LD_VAR 0 3
16877: NOT
16878: IFFALSE 16785
// ComReturn ( sci ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: CALL_OW 144
// end ; enable ;
16889: ENABLE
// end ;
16890: PPOPN 3
16892: END
// function SendForces ; var list , target ; begin
16893: LD_INT 0
16895: PPUSH
16896: PPUSH
16897: PPUSH
// ComRemember ( war_forces ) ;
16898: LD_EXP 52
16902: PPUSH
16903: CALL_OW 143
// ComRemember ( backup_forces ) ;
16907: LD_EXP 56
16911: PPUSH
16912: CALL_OW 143
// repeat list := FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) ;
16916: LD_ADDR_VAR 0 2
16920: PUSH
16921: LD_INT 33
16923: PPUSH
16924: LD_INT 22
16926: PUSH
16927: LD_EXP 14
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: PUSH
16936: LD_INT 50
16938: PUSH
16939: EMPTY
16940: LIST
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PPUSH
16946: CALL_OW 70
16950: ST_TO_ADDR
// defend_forces := war_forces union backup_forces ;
16951: LD_ADDR_EXP 64
16955: PUSH
16956: LD_EXP 52
16960: PUSH
16961: LD_EXP 56
16965: UNION
16966: ST_TO_ADDR
// target := NearestUnitToUnit ( list , ru_depot ) ;
16967: LD_ADDR_VAR 0 3
16971: PUSH
16972: LD_VAR 0 2
16976: PPUSH
16977: LD_INT 22
16979: PPUSH
16980: CALL_OW 74
16984: ST_TO_ADDR
// ComAttackPlace ( defend_forces , GetX ( target ) , GetY ( target ) ) ;
16985: LD_EXP 64
16989: PPUSH
16990: LD_VAR 0 3
16994: PPUSH
16995: CALL_OW 250
16999: PPUSH
17000: LD_VAR 0 3
17004: PPUSH
17005: CALL_OW 251
17009: PPUSH
17010: CALL_OW 116
// wait ( 50 ) ;
17014: LD_INT 50
17016: PPUSH
17017: CALL_OW 67
// until not list ;
17021: LD_VAR 0 2
17025: NOT
17026: IFFALSE 16916
// ComReturn ( war_forces ) ;
17028: LD_EXP 52
17032: PPUSH
17033: CALL_OW 144
// ComReturn ( backup_forces ) ;
17037: LD_EXP 56
17041: PPUSH
17042: CALL_OW 144
// end ; end_of_file
17046: LD_VAR 0 1
17050: RET
// var b_list ; export function init_keep_base ; var un , list ; begin
17051: LD_INT 0
17053: PPUSH
17054: PPUSH
17055: PPUSH
// b_list := [ ] ;
17056: LD_ADDR_LOC 39
17060: PUSH
17061: EMPTY
17062: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_building ] ] ) ;
17063: LD_ADDR_VAR 0 2
17067: PUSH
17068: LD_INT 22
17070: PUSH
17071: LD_EXP 15
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: LD_INT 21
17082: PUSH
17083: LD_INT 3
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: PPUSH
17094: CALL_OW 69
17098: ST_TO_ADDR
// if un then
17099: LD_VAR 0 2
17103: IFFALSE 17129
// b_list := GetBuildList ( GetBase ( un [ 1 ] ) ) ;
17105: LD_ADDR_LOC 39
17109: PUSH
17110: LD_VAR 0 2
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: CALL_OW 274
17123: PPUSH
17124: CALL_OW 417
17128: ST_TO_ADDR
// enable ( 2 ) ;
17129: LD_INT 2
17131: ENABLE_MARKED
// end ;
17132: LD_VAR 0 1
17136: RET
// every 0 0$3 trigger FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) marked 2 do var engineers ;
17137: LD_INT 33
17139: PPUSH
17140: LD_INT 22
17142: PUSH
17143: LD_EXP 14
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: PUSH
17152: LD_INT 50
17154: PUSH
17155: EMPTY
17156: LIST
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: PPUSH
17162: CALL_OW 70
17166: IFFALSE 17251
17168: GO 17170
17170: DISABLE
17171: LD_INT 0
17173: PPUSH
// begin engineers := ru_ing ;
17174: LD_ADDR_VAR 0 1
17178: PUSH
17179: LD_EXP 24
17183: ST_TO_ADDR
// if not engineers then
17184: LD_VAR 0 1
17188: NOT
17189: IFFALSE 17201
// engineers := ru_sol ;
17191: LD_ADDR_VAR 0 1
17195: PUSH
17196: LD_EXP 25
17200: ST_TO_ADDR
// ComRemember ( engineers ) ;
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL_OW 143
// WaitForMc ( McBase ( 3 , engineers , b_list , 0 , 0 , 0 ) ) ;
17210: LD_INT 3
17212: PPUSH
17213: LD_VAR 0 1
17217: PPUSH
17218: LD_LOC 39
17222: PPUSH
17223: LD_INT 0
17225: PPUSH
17226: LD_INT 0
17228: PPUSH
17229: LD_INT 0
17231: PPUSH
17232: CALL_OW 397
17236: PPUSH
17237: CALL_OW 385
// ComReturn ( engineers ) ;
17241: LD_VAR 0 1
17245: PPUSH
17246: CALL_OW 144
// enable ;
17250: ENABLE
// end ; end_of_file
17251: PPOPN 1
17253: END
// every 0 0$2 + 0 0$0.1 do
17254: GO 17256
17256: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17257: LD_INT 22
17259: PUSH
17260: LD_INT 1
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: LD_INT 25
17272: PUSH
17273: LD_INT 12
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PUSH
17280: LD_INT 25
17282: PUSH
17283: LD_INT 16
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PUSH
17290: LD_INT 25
17292: PUSH
17293: LD_INT 15
17295: PUSH
17296: EMPTY
17297: LIST
17298: LIST
17299: PUSH
17300: LD_INT 25
17302: PUSH
17303: LD_INT 17
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: LIST
17314: LIST
17315: LIST
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PPUSH
17321: CALL_OW 69
17325: PUSH
17326: LD_INT 22
17328: PUSH
17329: LD_INT 1
17331: PUSH
17332: EMPTY
17333: LIST
17334: LIST
17335: PUSH
17336: LD_INT 21
17338: PUSH
17339: LD_INT 1
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: PUSH
17346: LD_INT 3
17348: PUSH
17349: LD_INT 2
17351: PUSH
17352: LD_INT 25
17354: PUSH
17355: LD_INT 12
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PUSH
17362: LD_INT 25
17364: PUSH
17365: LD_INT 16
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: PUSH
17372: LD_INT 25
17374: PUSH
17375: LD_INT 15
17377: PUSH
17378: EMPTY
17379: LIST
17380: LIST
17381: PUSH
17382: LD_INT 25
17384: PUSH
17385: LD_INT 17
17387: PUSH
17388: EMPTY
17389: LIST
17390: LIST
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: PUSH
17399: EMPTY
17400: LIST
17401: LIST
17402: PUSH
17403: EMPTY
17404: LIST
17405: LIST
17406: LIST
17407: PPUSH
17408: CALL_OW 69
17412: GREATER
17413: IFFALSE 17424
// begin SetAchievement ( ACH_POTA ) ;
17415: LD_STRING ACH_POTA
17417: PPUSH
17418: CALL_OW 543
// exit ;
17422: GO 17425
// end ; enable ;
17424: ENABLE
// end ;
17425: END
// export function SA_HelpJoan ; begin
17426: LD_INT 0
17428: PPUSH
// SetAchievement ( ACH_TLO ) ;
17429: LD_STRING ACH_TLO
17431: PPUSH
17432: CALL_OW 543
// end ; end_of_file
17436: LD_VAR 0 1
17440: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
17441: LD_INT 0
17443: PPUSH
17444: PPUSH
// if not missionNumber then
17445: LD_VAR 0 2
17449: NOT
17450: IFFALSE 17454
// exit ;
17452: GO 17584
// achiv := false ;
17454: LD_ADDR_VAR 0 7
17458: PUSH
17459: LD_INT 0
17461: ST_TO_ADDR
// case campaignNumber of 1 :
17462: LD_VAR 0 1
17466: PUSH
17467: LD_INT 1
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17486
17475: POP
// achiv := ACH_GOTA ; 2 :
17476: LD_ADDR_VAR 0 7
17480: PUSH
17481: LD_STRING ACH_GOTA
17483: ST_TO_ADDR
17484: GO 17536
17486: LD_INT 2
17488: DOUBLE
17489: EQUAL
17490: IFTRUE 17494
17492: GO 17497
17494: POP
// ; 3 :
17495: GO 17536
17497: LD_INT 3
17499: DOUBLE
17500: EQUAL
17501: IFTRUE 17505
17503: GO 17516
17505: POP
// achiv := ACH_MOTSU ; 4 :
17506: LD_ADDR_VAR 0 7
17510: PUSH
17511: LD_STRING ACH_MOTSU
17513: ST_TO_ADDR
17514: GO 17536
17516: LD_INT 4
17518: DOUBLE
17519: EQUAL
17520: IFTRUE 17524
17522: GO 17535
17524: POP
// achiv := ACH_LOP ; end ;
17525: LD_ADDR_VAR 0 7
17529: PUSH
17530: LD_STRING ACH_LOP
17532: ST_TO_ADDR
17533: GO 17536
17535: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
17536: LD_OWVAR 67
17540: PUSH
17541: LD_INT 3
17543: EQUAL
17544: PUSH
17545: LD_VAR 0 7
17549: AND
17550: PUSH
17551: LD_VAR 0 3
17555: AND
17556: PUSH
17557: LD_VAR 0 4
17561: AND
17562: PUSH
17563: LD_VAR 0 5
17567: AND
17568: IFFALSE 17584
// SetAchievementEX ( achiv , missionNumber ) ;
17570: LD_VAR 0 7
17574: PPUSH
17575: LD_VAR 0 2
17579: PPUSH
17580: CALL_OW 564
// end ;
17584: LD_VAR 0 6
17588: RET
// export function SA_BehemothConstructed ; begin
17589: LD_INT 0
17591: PPUSH
// SetAchievement ( ACH_SMC ) ;
17592: LD_STRING ACH_SMC
17594: PPUSH
17595: CALL_OW 543
// end ;
17599: LD_VAR 0 1
17603: RET

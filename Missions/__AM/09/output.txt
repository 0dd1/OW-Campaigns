// export Frank , Lisa , Joan , Powell , JMM , Denis , Bobby , Cyrus , Donaldson , Brown , Gladstone , Gary ; export FSol1 , Sol1 , Sci1 ; export you , you2 , russians , arabians ; export otherG2 , other_survivors , Gamma2 ; export SikorskiDiedIn8 ; function load_units_1 ; var i , bud , b , depot , blds , tmp , lidi ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
   7: PPUSH
   8: PPUSH
   9: PPUSH
// InitUc ;
  10: CALL_OW 18
// InitHc ;
  14: CALL_OW 19
// InitVc ;
  18: CALL_OW 20
// Gamma2 := LoadVariable ( Gamma2 , [ ] ) ;
  22: LD_ADDR_EXP 22
  26: PUSH
  27: LD_STRING Gamma2
  29: PPUSH
  30: EMPTY
  31: PPUSH
  32: CALL_OW 30
  36: ST_TO_ADDR
// if not Gamma2 then
  37: LD_EXP 22
  41: NOT
  42: IFFALSE 51
// Msg ( Corrupted save ) ;
  44: LD_STRING Corrupted save
  46: PPUSH
  47: CALL_OW 100
// blds := [ ] ;
  51: LD_ADDR_VAR 0 6
  55: PUSH
  56: EMPTY
  57: ST_TO_ADDR
// for i in Gamma2 do
  58: LD_ADDR_VAR 0 2
  62: PUSH
  63: LD_EXP 22
  67: PUSH
  68: FOR_IN
  69: IFFALSE 295
// begin bc_type := i [ 4 ] ;
  71: LD_ADDR_OWVAR 42
  75: PUSH
  76: LD_VAR 0 2
  80: PUSH
  81: LD_INT 4
  83: ARRAY
  84: ST_TO_ADDR
// bc_level := i [ 5 ] ;
  85: LD_ADDR_OWVAR 43
  89: PUSH
  90: LD_VAR 0 2
  94: PUSH
  95: LD_INT 5
  97: ARRAY
  98: ST_TO_ADDR
// uc_nation := i [ 6 ] ;
  99: LD_ADDR_OWVAR 21
 103: PUSH
 104: LD_VAR 0 2
 108: PUSH
 109: LD_INT 6
 111: ARRAY
 112: ST_TO_ADDR
// case bc_type of b_lab , b_lab_half , b_lab_full :
 113: LD_OWVAR 42
 117: PUSH
 118: LD_INT 6
 120: DOUBLE
 121: EQUAL
 122: IFTRUE 138
 124: LD_INT 7
 126: DOUBLE
 127: EQUAL
 128: IFTRUE 138
 130: LD_INT 8
 132: DOUBLE
 133: EQUAL
 134: IFTRUE 138
 136: GO 169
 138: POP
// begin bc_kind1 := i [ 7 ] ;
 139: LD_ADDR_OWVAR 44
 143: PUSH
 144: LD_VAR 0 2
 148: PUSH
 149: LD_INT 7
 151: ARRAY
 152: ST_TO_ADDR
// bc_kind2 := i [ 8 ] ;
 153: LD_ADDR_OWVAR 45
 157: PUSH
 158: LD_VAR 0 2
 162: PUSH
 163: LD_INT 8
 165: ARRAY
 166: ST_TO_ADDR
// end ; end ;
 167: GO 170
 169: POP
// tmp := CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
 170: LD_ADDR_VAR 0 7
 174: PUSH
 175: LD_VAR 0 2
 179: PUSH
 180: LD_INT 1
 182: ARRAY
 183: PPUSH
 184: LD_VAR 0 2
 188: PUSH
 189: LD_INT 2
 191: ARRAY
 192: PPUSH
 193: LD_VAR 0 2
 197: PUSH
 198: LD_INT 3
 200: ARRAY
 201: PPUSH
 202: CALL_OW 47
 206: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
 207: LD_OWVAR 42
 211: PUSH
 212: LD_INT 32
 214: EQUAL
 215: PUSH
 216: LD_OWVAR 42
 220: PUSH
 221: LD_INT 33
 223: EQUAL
 224: OR
 225: IFFALSE 245
// PlaceWeaponTurret ( tmp , i [ 7 ] ) ;
 227: LD_VAR 0 7
 231: PPUSH
 232: LD_VAR 0 2
 236: PUSH
 237: LD_INT 7
 239: ARRAY
 240: PPUSH
 241: CALL_OW 431
// if bc_type = b_depot or bc_type = b_warehouse then
 245: LD_OWVAR 42
 249: PUSH
 250: LD_INT 0
 252: EQUAL
 253: PUSH
 254: LD_OWVAR 42
 258: PUSH
 259: LD_INT 1
 261: EQUAL
 262: OR
 263: IFFALSE 277
// Setbname ( tmp , gamma ) ;
 265: LD_VAR 0 7
 269: PPUSH
 270: LD_STRING gamma
 272: PPUSH
 273: CALL_OW 500
// blds := blds ^ tmp ;
 277: LD_ADDR_VAR 0 6
 281: PUSH
 282: LD_VAR 0 6
 286: PUSH
 287: LD_VAR 0 7
 291: ADD
 292: ST_TO_ADDR
// end ;
 293: GO 68
 295: POP
 296: POP
// uc_side := you ;
 297: LD_ADDR_OWVAR 20
 301: PUSH
 302: LD_EXP 16
 306: ST_TO_ADDR
// uc_nation := nation_american ;
 307: LD_ADDR_OWVAR 21
 311: PUSH
 312: LD_INT 1
 314: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 315: LD_ADDR_EXP 5
 319: PUSH
 320: LD_STRING JMM
 322: PPUSH
 323: CALL_OW 34
 327: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 328: LD_ADDR_EXP 4
 332: PUSH
 333: LD_STRING Powell
 335: PPUSH
 336: CALL_OW 25
 340: ST_TO_ADDR
// if TestCharacters ( otherGamma2 ) then
 341: LD_STRING otherGamma2
 343: PPUSH
 344: CALL_OW 28
 348: IFFALSE 363
// otherG2 := CreateCharacterSet ( otherGamma2 ) ;
 350: LD_ADDR_EXP 20
 354: PUSH
 355: LD_STRING otherGamma2
 357: PPUSH
 358: CALL_OW 31
 362: ST_TO_ADDR
// Lisa := 0 ;
 363: LD_ADDR_EXP 2
 367: PUSH
 368: LD_INT 0
 370: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 371: LD_STRING Lisa
 373: PPUSH
 374: CALL_OW 29
 378: IFFALSE 409
// if LoadVariable ( LisaLoc , 0 ) = 2 then
 380: LD_STRING LisaLoc
 382: PPUSH
 383: LD_INT 0
 385: PPUSH
 386: CALL_OW 30
 390: PUSH
 391: LD_INT 2
 393: EQUAL
 394: IFFALSE 409
// Lisa := CreateCharacter ( Lisa ) ;
 396: LD_ADDR_EXP 2
 400: PUSH
 401: LD_STRING Lisa
 403: PPUSH
 404: CALL_OW 34
 408: ST_TO_ADDR
// Frank := 0 ;
 409: LD_ADDR_EXP 1
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 417: LD_STRING Frank
 419: PPUSH
 420: CALL_OW 29
 424: IFFALSE 455
// if LoadVariable ( FrankLoc , 0 ) = 2 then
 426: LD_STRING FrankLoc
 428: PPUSH
 429: LD_INT 0
 431: PPUSH
 432: CALL_OW 30
 436: PUSH
 437: LD_INT 2
 439: EQUAL
 440: IFFALSE 455
// Frank := CreateCharacter ( Frank ) ;
 442: LD_ADDR_EXP 1
 446: PUSH
 447: LD_STRING Frank
 449: PPUSH
 450: CALL_OW 34
 454: ST_TO_ADDR
// Donaldson := 0 ;
 455: LD_ADDR_EXP 9
 459: PUSH
 460: LD_INT 0
 462: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 463: LD_STRING Donaldson
 465: PPUSH
 466: CALL_OW 29
 470: IFFALSE 501
// if LoadVariable ( DonaldsonLoc , 0 ) = 2 then
 472: LD_STRING DonaldsonLoc
 474: PPUSH
 475: LD_INT 0
 477: PPUSH
 478: CALL_OW 30
 482: PUSH
 483: LD_INT 2
 485: EQUAL
 486: IFFALSE 501
// Donaldson := CreateCharacter ( Donaldson ) ;
 488: LD_ADDR_EXP 9
 492: PUSH
 493: LD_STRING Donaldson
 495: PPUSH
 496: CALL_OW 34
 500: ST_TO_ADDR
// Brown := 0 ;
 501: LD_ADDR_EXP 10
 505: PUSH
 506: LD_INT 0
 508: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 509: LD_STRING Brown
 511: PPUSH
 512: CALL_OW 29
 516: IFFALSE 547
// if LoadVariable ( BrownLoc , 0 ) = 2 then
 518: LD_STRING BrownLoc
 520: PPUSH
 521: LD_INT 0
 523: PPUSH
 524: CALL_OW 30
 528: PUSH
 529: LD_INT 2
 531: EQUAL
 532: IFFALSE 547
// Brown := CreateCharacter ( Brown ) ;
 534: LD_ADDR_EXP 10
 538: PUSH
 539: LD_STRING Brown
 541: PPUSH
 542: CALL_OW 34
 546: ST_TO_ADDR
// Gladstone := 0 ;
 547: LD_ADDR_EXP 11
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 555: LD_STRING Gladstone
 557: PPUSH
 558: CALL_OW 29
 562: IFFALSE 593
// if LoadVariable ( GladstoneLoc , 0 ) = 2 then
 564: LD_STRING GladstoneLoc
 566: PPUSH
 567: LD_INT 0
 569: PPUSH
 570: CALL_OW 30
 574: PUSH
 575: LD_INT 2
 577: EQUAL
 578: IFFALSE 593
// Gladstone := CreateCharacter ( Gladstone ) ;
 580: LD_ADDR_EXP 11
 584: PUSH
 585: LD_STRING Gladstone
 587: PPUSH
 588: CALL_OW 34
 592: ST_TO_ADDR
// Joan := 0 ;
 593: LD_ADDR_EXP 3
 597: PUSH
 598: LD_INT 0
 600: ST_TO_ADDR
// if CheckCharacterSet ( Joan ) then
 601: LD_STRING Joan
 603: PPUSH
 604: CALL_OW 29
 608: IFFALSE 639
// if LoadVariable ( JoanLoc , 0 ) = 2 then
 610: LD_STRING JoanLoc
 612: PPUSH
 613: LD_INT 0
 615: PPUSH
 616: CALL_OW 30
 620: PUSH
 621: LD_INT 2
 623: EQUAL
 624: IFFALSE 639
// Joan := CreateCharacter ( Joan ) ;
 626: LD_ADDR_EXP 3
 630: PUSH
 631: LD_STRING Joan
 633: PPUSH
 634: CALL_OW 34
 638: ST_TO_ADDR
// Denis := 0 ;
 639: LD_ADDR_EXP 6
 643: PUSH
 644: LD_INT 0
 646: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 647: LD_STRING Denis
 649: PPUSH
 650: CALL_OW 29
 654: IFFALSE 685
// if LoadVariable ( DenisLoc , 0 ) = 2 then
 656: LD_STRING DenisLoc
 658: PPUSH
 659: LD_INT 0
 661: PPUSH
 662: CALL_OW 30
 666: PUSH
 667: LD_INT 2
 669: EQUAL
 670: IFFALSE 685
// Denis := CreateCharacter ( Denis ) ;
 672: LD_ADDR_EXP 6
 676: PUSH
 677: LD_STRING Denis
 679: PPUSH
 680: CALL_OW 34
 684: ST_TO_ADDR
// if not Lisa then
 685: LD_EXP 2
 689: NOT
 690: IFFALSE 738
// FSol1 := UnitFilter ( otherG2 diff [ Lisa , Frank , JMM ] , [ f_sex , sex_female ] ) ;
 692: LD_ADDR_EXP 13
 696: PUSH
 697: LD_EXP 20
 701: PUSH
 702: LD_EXP 2
 706: PUSH
 707: LD_EXP 1
 711: PUSH
 712: LD_EXP 5
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: DIFF
 722: PPUSH
 723: LD_INT 26
 725: PUSH
 726: LD_INT 2
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: PPUSH
 733: CALL_OW 72
 737: ST_TO_ADDR
// if FSol1 then
 738: LD_EXP 13
 742: IFFALSE 760
// FSol1 := FSol1 [ 1 ] else
 744: LD_ADDR_EXP 13
 748: PUSH
 749: LD_EXP 13
 753: PUSH
 754: LD_INT 1
 756: ARRAY
 757: ST_TO_ADDR
 758: GO 803
// begin uc_side := you ;
 760: LD_ADDR_OWVAR 20
 764: PUSH
 765: LD_EXP 16
 769: ST_TO_ADDR
// PrepareHuman ( sex_female , 0 , Rand ( - 2 , - 4 ) ) ;
 770: LD_INT 2
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: LD_INT 2
 778: NEG
 779: PPUSH
 780: LD_INT 4
 782: NEG
 783: PPUSH
 784: CALL_OW 12
 788: PPUSH
 789: CALL_OW 380
// FSol1 := CreateHuman ;
 793: LD_ADDR_EXP 13
 797: PUSH
 798: CALL_OW 44
 802: ST_TO_ADDR
// end ; if not Frank then
 803: LD_EXP 1
 807: NOT
 808: IFFALSE 856
// Sol1 := UnitFilter ( otherG2 diff [ Lisa , Frank , JMM ] , [ f_sex , sex_male ] ) ;
 810: LD_ADDR_EXP 14
 814: PUSH
 815: LD_EXP 20
 819: PUSH
 820: LD_EXP 2
 824: PUSH
 825: LD_EXP 1
 829: PUSH
 830: LD_EXP 5
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: DIFF
 840: PPUSH
 841: LD_INT 26
 843: PUSH
 844: LD_INT 1
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PPUSH
 851: CALL_OW 72
 855: ST_TO_ADDR
// if Sol1 then
 856: LD_EXP 14
 860: IFFALSE 878
// Sol1 := Sol1 [ 1 ] else
 862: LD_ADDR_EXP 14
 866: PUSH
 867: LD_EXP 14
 871: PUSH
 872: LD_INT 1
 874: ARRAY
 875: ST_TO_ADDR
 876: GO 921
// begin uc_side := you ;
 878: LD_ADDR_OWVAR 20
 882: PUSH
 883: LD_EXP 16
 887: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , Rand ( - 2 , - 4 ) ) ;
 888: LD_INT 1
 890: PPUSH
 891: LD_INT 0
 893: PPUSH
 894: LD_INT 2
 896: NEG
 897: PPUSH
 898: LD_INT 4
 900: NEG
 901: PPUSH
 902: CALL_OW 12
 906: PPUSH
 907: CALL_OW 380
// Sol1 := CreateHuman ;
 911: LD_ADDR_EXP 14
 915: PUSH
 916: CALL_OW 44
 920: ST_TO_ADDR
// end ; if LoadVariable ( SikorskiLoc , 0 ) = 0 then
 921: LD_STRING SikorskiLoc
 923: PPUSH
 924: LD_INT 0
 926: PPUSH
 927: CALL_OW 30
 931: PUSH
 932: LD_INT 0
 934: EQUAL
 935: IFFALSE 947
// SikorskiDiedin8 := true else
 937: LD_ADDR_EXP 23
 941: PUSH
 942: LD_INT 1
 944: ST_TO_ADDR
 945: GO 955
// SikorskiDiedin8 := false ;
 947: LD_ADDR_EXP 23
 951: PUSH
 952: LD_INT 0
 954: ST_TO_ADDR
// PlaceUnitXYR ( JMM , 52 , 23 , 10 , false ) ;
 955: LD_EXP 5
 959: PPUSH
 960: LD_INT 52
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 10
 968: PPUSH
 969: LD_INT 0
 971: PPUSH
 972: CALL_OW 50
// depot := FilterAllUnits ( [ f_btype , b_depot ] ) ;
 976: LD_ADDR_VAR 0 5
 980: PUSH
 981: LD_INT 30
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: PPUSH
 991: CALL_OW 69
 995: ST_TO_ADDR
// if depot then
 996: LD_VAR 0 5
1000: IFFALSE 1016
// depot := depot [ 1 ] ;
1002: LD_ADDR_VAR 0 5
1006: PUSH
1007: LD_VAR 0 5
1011: PUSH
1012: LD_INT 1
1014: ARRAY
1015: ST_TO_ADDR
// lidi := [ Lisa , Frank , Donaldson , Brown , Joan , Denis , Gladstone , FSol1 , Sol1 ] diff 0 ;
1016: LD_ADDR_VAR 0 8
1020: PUSH
1021: LD_EXP 2
1025: PUSH
1026: LD_EXP 1
1030: PUSH
1031: LD_EXP 9
1035: PUSH
1036: LD_EXP 10
1040: PUSH
1041: LD_EXP 3
1045: PUSH
1046: LD_EXP 6
1050: PUSH
1051: LD_EXP 11
1055: PUSH
1056: LD_EXP 13
1060: PUSH
1061: LD_EXP 14
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: PUSH
1077: LD_INT 0
1079: DIFF
1080: ST_TO_ADDR
// for i in lidi do
1081: LD_ADDR_VAR 0 2
1085: PUSH
1086: LD_VAR 0 8
1090: PUSH
1091: FOR_IN
1092: IFFALSE 1131
// begin PlaceUnitXYR ( i , GetX ( JMM ) , GetY ( JMM ) , 5 , false ) ;
1094: LD_VAR 0 2
1098: PPUSH
1099: LD_EXP 5
1103: PPUSH
1104: CALL_OW 250
1108: PPUSH
1109: LD_EXP 5
1113: PPUSH
1114: CALL_OW 251
1118: PPUSH
1119: LD_INT 5
1121: PPUSH
1122: LD_INT 0
1124: PPUSH
1125: CALL_OW 50
// end ;
1129: GO 1091
1131: POP
1132: POP
// bud := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_workshop ] , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_control_tower ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ;
1133: LD_ADDR_VAR 0 3
1137: PUSH
1138: LD_INT 2
1140: PUSH
1141: LD_INT 30
1143: PUSH
1144: LD_INT 0
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 30
1153: PUSH
1154: LD_INT 1
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: PUSH
1161: LD_INT 30
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: PUSH
1171: LD_INT 30
1173: PUSH
1174: LD_INT 2
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: PUSH
1181: LD_INT 30
1183: PUSH
1184: LD_INT 6
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 30
1193: PUSH
1194: LD_INT 7
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 30
1203: PUSH
1204: LD_INT 8
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: PUSH
1211: LD_INT 30
1213: PUSH
1214: LD_INT 4
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: PUSH
1221: LD_INT 30
1223: PUSH
1224: LD_INT 5
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: PUSH
1231: LD_INT 30
1233: PUSH
1234: LD_INT 36
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 30
1243: PUSH
1244: LD_INT 32
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: PUSH
1251: LD_INT 30
1253: PUSH
1254: LD_INT 31
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PPUSH
1276: CALL_OW 69
1280: ST_TO_ADDR
// if CheckCharacterSet ( otherGamma2 ) then
1281: LD_STRING otherGamma2
1283: PPUSH
1284: CALL_OW 29
1288: IFFALSE 1303
// otherG2 := CreateCharacterSet ( otherGamma2 ) ;
1290: LD_ADDR_EXP 20
1294: PUSH
1295: LD_STRING otherGamma2
1297: PPUSH
1298: CALL_OW 31
1302: ST_TO_ADDR
// for i in otherG2 do
1303: LD_ADDR_VAR 0 2
1307: PUSH
1308: LD_EXP 20
1312: PUSH
1313: FOR_IN
1314: IFFALSE 1409
// begin b := bud [ Rand ( 1 , bud ) ] ;
1316: LD_ADDR_VAR 0 4
1320: PUSH
1321: LD_VAR 0 3
1325: PUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 3
1333: PPUSH
1334: CALL_OW 12
1338: ARRAY
1339: ST_TO_ADDR
// if rand ( 1 , 5 ) < 3 then
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 5
1345: PPUSH
1346: CALL_OW 12
1350: PUSH
1351: LD_INT 3
1353: LESS
1354: IFFALSE 1372
// PlaceHumanInUnit ( i , b ) else
1356: LD_VAR 0 2
1360: PPUSH
1361: LD_VAR 0 4
1365: PPUSH
1366: CALL_OW 52
1370: GO 1407
// PlaceUnitXYR ( i , Getx ( b ) , gety ( b ) , 11 , false ) ;
1372: LD_VAR 0 2
1376: PPUSH
1377: LD_VAR 0 4
1381: PPUSH
1382: CALL_OW 250
1386: PPUSH
1387: LD_VAR 0 4
1391: PPUSH
1392: CALL_OW 251
1396: PPUSH
1397: LD_INT 11
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 50
// end ;
1407: GO 1313
1409: POP
1410: POP
// lidi := lidi + otherG2 ;
1411: LD_ADDR_VAR 0 8
1415: PUSH
1416: LD_VAR 0 8
1420: PUSH
1421: LD_EXP 20
1425: PLUS
1426: ST_TO_ADDR
// for i := lidi to 22 do
1427: LD_ADDR_VAR 0 2
1431: PUSH
1432: DOUBLE
1433: LD_VAR 0 8
1437: DEC
1438: ST_TO_ADDR
1439: LD_INT 22
1441: PUSH
1442: FOR_TO
1443: IFFALSE 1559
// begin PrepareHuman ( 0 , 0 , rand ( 4 , 6 ) ) ;
1445: LD_INT 0
1447: PPUSH
1448: LD_INT 0
1450: PPUSH
1451: LD_INT 4
1453: PPUSH
1454: LD_INT 6
1456: PPUSH
1457: CALL_OW 12
1461: PPUSH
1462: CALL_OW 380
// b := bud [ Rand ( 1 , bud ) ] ;
1466: LD_ADDR_VAR 0 4
1470: PUSH
1471: LD_VAR 0 3
1475: PUSH
1476: LD_INT 1
1478: PPUSH
1479: LD_VAR 0 3
1483: PPUSH
1484: CALL_OW 12
1488: ARRAY
1489: ST_TO_ADDR
// if rand ( 1 , 5 ) < 3 then
1490: LD_INT 1
1492: PPUSH
1493: LD_INT 5
1495: PPUSH
1496: CALL_OW 12
1500: PUSH
1501: LD_INT 3
1503: LESS
1504: IFFALSE 1522
// PlaceHumanInUnit ( CreateHuman , b ) else
1506: CALL_OW 44
1510: PPUSH
1511: LD_VAR 0 4
1515: PPUSH
1516: CALL_OW 52
1520: GO 1557
// PlaceUnitXYR ( CreateHuman , Getx ( b ) , gety ( b ) , 14 , false ) ;
1522: CALL_OW 44
1526: PPUSH
1527: LD_VAR 0 4
1531: PPUSH
1532: CALL_OW 250
1536: PPUSH
1537: LD_VAR 0 4
1541: PPUSH
1542: CALL_OW 251
1546: PPUSH
1547: LD_INT 14
1549: PPUSH
1550: LD_INT 0
1552: PPUSH
1553: CALL_OW 50
// end ;
1557: GO 1442
1559: POP
1560: POP
// for i := 1 to 6 do
1561: LD_ADDR_VAR 0 2
1565: PUSH
1566: DOUBLE
1567: LD_INT 1
1569: DEC
1570: ST_TO_ADDR
1571: LD_INT 6
1573: PUSH
1574: FOR_TO
1575: IFFALSE 1736
// begin vc_engine := engine_combustion ;
1577: LD_ADDR_OWVAR 39
1581: PUSH
1582: LD_INT 1
1584: ST_TO_ADDR
// vc_control := control_manual ;
1585: LD_ADDR_OWVAR 38
1589: PUSH
1590: LD_INT 1
1592: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_heavy_gun , us_double_gun , us_cargo_bay , us_machine_gun ] [ Rand ( 1 , 5 ) ] ;
1593: LD_ADDR_OWVAR 40
1597: PUSH
1598: LD_INT 4
1600: PUSH
1601: LD_INT 6
1603: PUSH
1604: LD_INT 5
1606: PUSH
1607: LD_INT 12
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: EMPTY
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: PUSH
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 5
1625: PPUSH
1626: CALL_OW 12
1630: ARRAY
1631: ST_TO_ADDR
// if vc_weapon = us_heavy_gun then
1632: LD_OWVAR 40
1636: PUSH
1637: LD_INT 6
1639: EQUAL
1640: IFFALSE 1652
// vc_chassis = us_heavy_tracked else
1642: LD_ADDR_OWVAR 37
1646: PUSH
1647: LD_INT 4
1649: ST_TO_ADDR
1650: GO 1683
// vc_chassis := [ us_medium_tracked , us_medium_wheeled , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
1652: LD_ADDR_OWVAR 37
1656: PUSH
1657: LD_INT 3
1659: PUSH
1660: LD_INT 2
1662: PUSH
1663: LD_INT 4
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 1
1673: PPUSH
1674: LD_INT 3
1676: PPUSH
1677: CALL_OW 12
1681: ARRAY
1682: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
1683: LD_ADDR_OWVAR 24
1687: PUSH
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 5
1693: PPUSH
1694: CALL_OW 12
1698: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , Getx ( b ) , gety ( b ) , 14 , false ) ;
1699: CALL_OW 45
1703: PPUSH
1704: LD_VAR 0 4
1708: PPUSH
1709: CALL_OW 250
1713: PPUSH
1714: LD_VAR 0 4
1718: PPUSH
1719: CALL_OW 251
1723: PPUSH
1724: LD_INT 14
1726: PPUSH
1727: LD_INT 0
1729: PPUSH
1730: CALL_OW 50
// end ;
1734: GO 1574
1736: POP
1737: POP
// end ;
1738: LD_VAR 0 1
1742: RET
// starting begin you := 1 ;
1743: LD_ADDR_EXP 16
1747: PUSH
1748: LD_INT 1
1750: ST_TO_ADDR
// you2 := 4 ;
1751: LD_ADDR_EXP 17
1755: PUSH
1756: LD_INT 4
1758: ST_TO_ADDR
// arabians := 2 ;
1759: LD_ADDR_EXP 19
1763: PUSH
1764: LD_INT 2
1766: ST_TO_ADDR
// russians := 3 ;
1767: LD_ADDR_EXP 18
1771: PUSH
1772: LD_INT 3
1774: ST_TO_ADDR
// load_units_1 ;
1775: CALL 0 0 0
// Dialog1 ;
1779: CALL 1794 0 0
// ChangeMap ( %_cont , %_cont ) ;
1783: LD_STRING %_cont
1785: PPUSH
1786: LD_STRING %_cont
1788: PPUSH
1789: CALL_OW 340
// end ; end_of_file
1793: END
// export function Dialog1 ; begin
1794: LD_INT 0
1796: PPUSH
// InGameOn ;
1797: CALL_OW 8
// Wait ( 0 0$2 ) ;
1801: LD_INT 70
1803: PPUSH
1804: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
1808: LD_EXP 5
1812: PPUSH
1813: CALL_OW 87
// SayRadio ( Powell , D1-Pow-1 ) ;
1817: LD_EXP 4
1821: PPUSH
1822: LD_STRING D1-Pow-1
1824: PPUSH
1825: CALL_OW 94
// Say ( JMM , D1-JMM-1 ) ;
1829: LD_EXP 5
1833: PPUSH
1834: LD_STRING D1-JMM-1
1836: PPUSH
1837: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
1841: LD_EXP 4
1845: PPUSH
1846: LD_STRING D1-Pow-2
1848: PPUSH
1849: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
1853: LD_EXP 5
1857: PPUSH
1858: LD_STRING D1-JMM-2
1860: PPUSH
1861: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
1865: LD_EXP 4
1869: PPUSH
1870: LD_STRING D1-Pow-3
1872: PPUSH
1873: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
1877: LD_EXP 5
1881: PPUSH
1882: LD_STRING D1-JMM-3
1884: PPUSH
1885: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
1889: LD_EXP 4
1893: PPUSH
1894: LD_STRING D1-Pow-4
1896: PPUSH
1897: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
1901: LD_EXP 5
1905: PPUSH
1906: LD_STRING D1-JMM-4
1908: PPUSH
1909: CALL_OW 88
// SayRadio ( Powell , D1-Pow-5 ) ;
1913: LD_EXP 4
1917: PPUSH
1918: LD_STRING D1-Pow-5
1920: PPUSH
1921: CALL_OW 94
// Say ( JMM , D1-JMM-5 ) ;
1925: LD_EXP 5
1929: PPUSH
1930: LD_STRING D1-JMM-5
1932: PPUSH
1933: CALL_OW 88
// SayRadio ( Powell , D1-Pow-6 ) ;
1937: LD_EXP 4
1941: PPUSH
1942: LD_STRING D1-Pow-6
1944: PPUSH
1945: CALL_OW 94
// if not SikorskiDiedin8 then
1949: LD_EXP 23
1953: NOT
1954: IFFALSE 1982
// begin SayRadio ( Powell , D1-Pow-6a ) ;
1956: LD_EXP 4
1960: PPUSH
1961: LD_STRING D1-Pow-6a
1963: PPUSH
1964: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6b ) ;
1968: LD_EXP 4
1972: PPUSH
1973: LD_STRING D1-Pow-6b
1975: PPUSH
1976: CALL_OW 94
// end else
1980: GO 2006
// begin SayRadio ( Powell , D1-Pow-6c ) ;
1982: LD_EXP 4
1986: PPUSH
1987: LD_STRING D1-Pow-6c
1989: PPUSH
1990: CALL_OW 94
// SayRadio ( Powell , D1-Pow-6d ) ;
1994: LD_EXP 4
1998: PPUSH
1999: LD_STRING D1-Pow-6d
2001: PPUSH
2002: CALL_OW 94
// end ; Say ( JMM , D1-JMM-6 ) ;
2006: LD_EXP 5
2010: PPUSH
2011: LD_STRING D1-JMM-6
2013: PPUSH
2014: CALL_OW 88
// Say ( JMM , D1-JMM-6a ) ;
2018: LD_EXP 5
2022: PPUSH
2023: LD_STRING D1-JMM-6a
2025: PPUSH
2026: CALL_OW 88
// SayRadio ( Powell , D1-Pow-7 ) ;
2030: LD_EXP 4
2034: PPUSH
2035: LD_STRING D1-Pow-7
2037: PPUSH
2038: CALL_OW 94
// Say ( JMM , D1-JMM-7 ) ;
2042: LD_EXP 5
2046: PPUSH
2047: LD_STRING D1-JMM-7
2049: PPUSH
2050: CALL_OW 88
// SayRadio ( Powell , D1-Pow-8 ) ;
2054: LD_EXP 4
2058: PPUSH
2059: LD_STRING D1-Pow-8
2061: PPUSH
2062: CALL_OW 94
// Say ( JMM , D1-JMM-8 ) ;
2066: LD_EXP 5
2070: PPUSH
2071: LD_STRING D1-JMM-8
2073: PPUSH
2074: CALL_OW 88
// SayRadio ( Powell , D1-Pow-9 ) ;
2078: LD_EXP 4
2082: PPUSH
2083: LD_STRING D1-Pow-9
2085: PPUSH
2086: CALL_OW 94
// if Lisa then
2090: LD_EXP 2
2094: IFFALSE 2110
// Say ( Lisa , D1a-Lisa-1 ) else
2096: LD_EXP 2
2100: PPUSH
2101: LD_STRING D1a-Lisa-1
2103: PPUSH
2104: CALL_OW 88
2108: GO 2122
// Say ( FSol1 , D1a-FSol1-1 ) ;
2110: LD_EXP 13
2114: PPUSH
2115: LD_STRING D1a-FSol1-1
2117: PPUSH
2118: CALL_OW 88
// if Frank then
2122: LD_EXP 1
2126: IFFALSE 2142
// Say ( Frank , D1a-Frank-1 ) else
2128: LD_EXP 1
2132: PPUSH
2133: LD_STRING D1a-Frank-1
2135: PPUSH
2136: CALL_OW 88
2140: GO 2154
// Say ( Sol1 , D1a-Sol1-1 ) ;
2142: LD_EXP 14
2146: PPUSH
2147: LD_STRING D1a-Sol1-1
2149: PPUSH
2150: CALL_OW 88
// if Lisa then
2154: LD_EXP 2
2158: IFFALSE 2174
// Say ( Lisa , D1a-Lisa-2 ) else
2160: LD_EXP 2
2164: PPUSH
2165: LD_STRING D1a-Lisa-2
2167: PPUSH
2168: CALL_OW 88
2172: GO 2186
// Say ( FSol1 , D1a-FSol1-2 ) ;
2174: LD_EXP 13
2178: PPUSH
2179: LD_STRING D1a-FSol1-2
2181: PPUSH
2182: CALL_OW 88
// if Frank then
2186: LD_EXP 1
2190: IFFALSE 2206
// Say ( Frank , D1a-Frank-2 ) else
2192: LD_EXP 1
2196: PPUSH
2197: LD_STRING D1a-Frank-2
2199: PPUSH
2200: CALL_OW 88
2204: GO 2218
// Say ( Sol1 , D1a-Sol1-2 ) ;
2206: LD_EXP 14
2210: PPUSH
2211: LD_STRING D1a-Sol1-2
2213: PPUSH
2214: CALL_OW 88
// if Lisa then
2218: LD_EXP 2
2222: IFFALSE 2238
// Say ( Lisa , D1a-Lisa-3 ) else
2224: LD_EXP 2
2228: PPUSH
2229: LD_STRING D1a-Lisa-3
2231: PPUSH
2232: CALL_OW 88
2236: GO 2250
// Say ( FSol1 , D1a-FSol1-3 ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_STRING D1a-FSol1-3
2245: PPUSH
2246: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
2250: LD_EXP 5
2254: PPUSH
2255: LD_STRING D1a-JMM-3
2257: PPUSH
2258: CALL_OW 88
// Dialog1b ;
2262: CALL 2297 0 0
// ComMoveXY ( JMM , 67 , 66 ) ;
2266: LD_EXP 5
2270: PPUSH
2271: LD_INT 67
2273: PPUSH
2274: LD_INT 66
2276: PPUSH
2277: CALL_OW 111
// wait ( 0 0$4 ) ;
2281: LD_INT 140
2283: PPUSH
2284: CALL_OW 67
// InGameOff ;
2288: CALL_OW 9
// end ;
2292: LD_VAR 0 1
2296: RET
// function Dialog1b ; var adepts , i , j , k ; begin
2297: LD_INT 0
2299: PPUSH
2300: PPUSH
2301: PPUSH
2302: PPUSH
2303: PPUSH
// adepts := [ ] union [ Lisa , Gladstone , Joan , Donaldson ] ;
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: EMPTY
2310: PUSH
2311: LD_EXP 2
2315: PUSH
2316: LD_EXP 11
2320: PUSH
2321: LD_EXP 3
2325: PUSH
2326: LD_EXP 9
2330: PUSH
2331: EMPTY
2332: LIST
2333: LIST
2334: LIST
2335: LIST
2336: UNION
2337: ST_TO_ADDR
// adepts := adepts diff 0 ;
2338: LD_ADDR_VAR 0 2
2342: PUSH
2343: LD_VAR 0 2
2347: PUSH
2348: LD_INT 0
2350: DIFF
2351: ST_TO_ADDR
// if adepts then
2352: LD_VAR 0 2
2356: IFFALSE 2784
// begin i := Rand ( 1 , adepts ) ;
2358: LD_ADDR_VAR 0 3
2362: PUSH
2363: LD_INT 1
2365: PPUSH
2366: LD_VAR 0 2
2370: PPUSH
2371: CALL_OW 12
2375: ST_TO_ADDR
// case adepts [ i ] of Lisa :
2376: LD_VAR 0 2
2380: PUSH
2381: LD_VAR 0 3
2385: ARRAY
2386: PUSH
2387: LD_EXP 2
2391: DOUBLE
2392: EQUAL
2393: IFTRUE 2397
2395: GO 2412
2397: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2398: LD_EXP 2
2402: PPUSH
2403: LD_STRING D1b-Lisa-1
2405: PPUSH
2406: CALL_OW 88
2410: GO 2488
2412: LD_EXP 11
2416: DOUBLE
2417: EQUAL
2418: IFTRUE 2422
2420: GO 2437
2422: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2423: LD_EXP 11
2427: PPUSH
2428: LD_STRING D1b-Glad-1
2430: PPUSH
2431: CALL_OW 88
2435: GO 2488
2437: LD_EXP 3
2441: DOUBLE
2442: EQUAL
2443: IFTRUE 2447
2445: GO 2462
2447: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2448: LD_EXP 3
2452: PPUSH
2453: LD_STRING D1b-Joan-1
2455: PPUSH
2456: CALL_OW 88
2460: GO 2488
2462: LD_EXP 9
2466: DOUBLE
2467: EQUAL
2468: IFTRUE 2472
2470: GO 2487
2472: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2473: LD_EXP 9
2477: PPUSH
2478: LD_STRING D1b-Don-1
2480: PPUSH
2481: CALL_OW 88
2485: GO 2488
2487: POP
// j := Rand ( 1 , adepts ) ;
2488: LD_ADDR_VAR 0 4
2492: PUSH
2493: LD_INT 1
2495: PPUSH
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 12
2505: ST_TO_ADDR
// if j <> i then
2506: LD_VAR 0 4
2510: PUSH
2511: LD_VAR 0 3
2515: NONEQUAL
2516: IFFALSE 2630
// case adepts [ j ] of Lisa :
2518: LD_VAR 0 2
2522: PUSH
2523: LD_VAR 0 4
2527: ARRAY
2528: PUSH
2529: LD_EXP 2
2533: DOUBLE
2534: EQUAL
2535: IFTRUE 2539
2537: GO 2554
2539: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2540: LD_EXP 2
2544: PPUSH
2545: LD_STRING D1b-Lisa-1
2547: PPUSH
2548: CALL_OW 88
2552: GO 2630
2554: LD_EXP 11
2558: DOUBLE
2559: EQUAL
2560: IFTRUE 2564
2562: GO 2579
2564: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2565: LD_EXP 11
2569: PPUSH
2570: LD_STRING D1b-Glad-1
2572: PPUSH
2573: CALL_OW 88
2577: GO 2630
2579: LD_EXP 3
2583: DOUBLE
2584: EQUAL
2585: IFTRUE 2589
2587: GO 2604
2589: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2590: LD_EXP 3
2594: PPUSH
2595: LD_STRING D1b-Joan-1
2597: PPUSH
2598: CALL_OW 88
2602: GO 2630
2604: LD_EXP 9
2608: DOUBLE
2609: EQUAL
2610: IFTRUE 2614
2612: GO 2629
2614: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2615: LD_EXP 9
2619: PPUSH
2620: LD_STRING D1b-Don-1
2622: PPUSH
2623: CALL_OW 88
2627: GO 2630
2629: POP
// k := Rand ( 1 , adepts ) ;
2630: LD_ADDR_VAR 0 5
2634: PUSH
2635: LD_INT 1
2637: PPUSH
2638: LD_VAR 0 2
2642: PPUSH
2643: CALL_OW 12
2647: ST_TO_ADDR
// if k <> j and k <> i then
2648: LD_VAR 0 5
2652: PUSH
2653: LD_VAR 0 4
2657: NONEQUAL
2658: PUSH
2659: LD_VAR 0 5
2663: PUSH
2664: LD_VAR 0 3
2668: NONEQUAL
2669: AND
2670: IFFALSE 2784
// case adepts [ k ] of Lisa :
2672: LD_VAR 0 2
2676: PUSH
2677: LD_VAR 0 5
2681: ARRAY
2682: PUSH
2683: LD_EXP 2
2687: DOUBLE
2688: EQUAL
2689: IFTRUE 2693
2691: GO 2708
2693: POP
// Say ( Lisa , D1b-Lisa-1 ) ; Gladstone :
2694: LD_EXP 2
2698: PPUSH
2699: LD_STRING D1b-Lisa-1
2701: PPUSH
2702: CALL_OW 88
2706: GO 2784
2708: LD_EXP 11
2712: DOUBLE
2713: EQUAL
2714: IFTRUE 2718
2716: GO 2733
2718: POP
// Say ( Gladstone , D1b-Glad-1 ) ; Joan :
2719: LD_EXP 11
2723: PPUSH
2724: LD_STRING D1b-Glad-1
2726: PPUSH
2727: CALL_OW 88
2731: GO 2784
2733: LD_EXP 3
2737: DOUBLE
2738: EQUAL
2739: IFTRUE 2743
2741: GO 2758
2743: POP
// Say ( Joan , D1b-Joan-1 ) ; Donaldson :
2744: LD_EXP 3
2748: PPUSH
2749: LD_STRING D1b-Joan-1
2751: PPUSH
2752: CALL_OW 88
2756: GO 2784
2758: LD_EXP 9
2762: DOUBLE
2763: EQUAL
2764: IFTRUE 2768
2766: GO 2783
2768: POP
// Say ( Donaldson , D1b-Don-1 ) ; end ;
2769: LD_EXP 9
2773: PPUSH
2774: LD_STRING D1b-Don-1
2776: PPUSH
2777: CALL_OW 88
2781: GO 2784
2783: POP
// end ; end ; end_of_file
2784: LD_VAR 0 1
2788: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
2789: LD_INT 0
2791: PPUSH
2792: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
2793: LD_ADDR_VAR 0 8
2797: PUSH
2798: LD_VAR 0 1
2802: PPUSH
2803: LD_VAR 0 3
2807: PPUSH
2808: LD_VAR 0 4
2812: PPUSH
2813: LD_VAR 0 5
2817: PPUSH
2818: LD_VAR 0 6
2822: PPUSH
2823: CALL 2869 0 5
2827: ST_TO_ADDR
// if kdo then
2828: LD_VAR 0 8
2832: IFFALSE 2856
// result := Say ( kdo , ident ) else
2834: LD_ADDR_VAR 0 7
2838: PUSH
2839: LD_VAR 0 8
2843: PPUSH
2844: LD_VAR 0 2
2848: PPUSH
2849: CALL_OW 88
2853: ST_TO_ADDR
2854: GO 2864
// result := false ;
2856: LD_ADDR_VAR 0 7
2860: PUSH
2861: LD_INT 0
2863: ST_TO_ADDR
// end ;
2864: LD_VAR 0 7
2868: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
2869: LD_INT 0
2871: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
2872: LD_ADDR_VAR 0 1
2876: PUSH
2877: LD_VAR 0 1
2881: PPUSH
2882: LD_INT 21
2884: PUSH
2885: LD_INT 1
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 22
2894: PUSH
2895: LD_VAR 0 2
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: PUSH
2904: LD_INT 3
2906: PUSH
2907: LD_INT 23
2909: PUSH
2910: LD_INT 0
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: LIST
2921: LIST
2922: PPUSH
2923: CALL_OW 72
2927: ST_TO_ADDR
// if sex <> 0 then
2928: LD_VAR 0 3
2932: PUSH
2933: LD_INT 0
2935: NONEQUAL
2936: IFFALSE 2965
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
2938: LD_ADDR_VAR 0 1
2942: PUSH
2943: LD_VAR 0 1
2947: PPUSH
2948: LD_INT 26
2950: PUSH
2951: LD_VAR 0 3
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: PPUSH
2960: CALL_OW 72
2964: ST_TO_ADDR
// if Hclass <> 0 then
2965: LD_VAR 0 4
2969: PUSH
2970: LD_INT 0
2972: NONEQUAL
2973: IFFALSE 3002
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
2975: LD_ADDR_VAR 0 1
2979: PUSH
2980: LD_VAR 0 1
2984: PPUSH
2985: LD_INT 25
2987: PUSH
2988: LD_VAR 0 4
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: PPUSH
2997: CALL_OW 72
3001: ST_TO_ADDR
// if index <= 0 then
3002: LD_VAR 0 5
3006: PUSH
3007: LD_INT 0
3009: LESSEQUAL
3010: IFFALSE 3020
// index := 1 ;
3012: LD_ADDR_VAR 0 5
3016: PUSH
3017: LD_INT 1
3019: ST_TO_ADDR
// if lidi >= index then
3020: LD_VAR 0 1
3024: PUSH
3025: LD_VAR 0 5
3029: GREATEREQUAL
3030: IFFALSE 3050
// result := lidi [ index ] else
3032: LD_ADDR_VAR 0 6
3036: PUSH
3037: LD_VAR 0 1
3041: PUSH
3042: LD_VAR 0 5
3046: ARRAY
3047: ST_TO_ADDR
3048: GO 3058
// result := 0 ;
3050: LD_ADDR_VAR 0 6
3054: PUSH
3055: LD_INT 0
3057: ST_TO_ADDR
// end ; end_of_file
3058: LD_VAR 0 6
3062: RET
// on DestinationUnreachable ( un ) do begin if un = JMM then
3063: LD_VAR 0 1
3067: PUSH
3068: LD_EXP 5
3072: EQUAL
3073: IFFALSE 3106
// ComMoveXY ( JMM , Rand ( 47 , 89 ) , Rand ( 53 , 95 ) ) ;
3075: LD_EXP 5
3079: PPUSH
3080: LD_INT 47
3082: PPUSH
3083: LD_INT 89
3085: PPUSH
3086: CALL_OW 12
3090: PPUSH
3091: LD_INT 53
3093: PPUSH
3094: LD_INT 95
3096: PPUSH
3097: CALL_OW 12
3101: PPUSH
3102: CALL_OW 111
// end ;
3106: PPOPN 1
3108: END

// export you , russians , neutral ; export Bobby , Cyrus , Lisa , MacMillan , Cornell , Powell , Khatam , Frank ; export Kobra1 , other_survivors , cornells , yours ; export atack , saved_units ; export mrtvi_lide ; export JMMinvehicle , Cyrusinvehicle ; export Mikhail , rus_vehicle ; export rus_south , rus_guard1 , rus_guard2 , rus_guard3 , rus_guard4 ; export South_russian_patrol , forest_force1 , forest_force2 ; export grass_force1 , grass_force2 , grass_force3 ; export Cornell_group , amtruck1 , amtruck2 , cans , cans1 ; export Dialogue_wait , time_to_return , time_to_attack , solar_constructed , solar_saved , Meet_Frank , base_reached , cornell_lost , Frank_Query ; var time_crates ; function prepare_units ; var un , i , JMM_group , cornell_limit ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
// JMM_group := [ ] ;
   7: LD_ADDR_VAR 0 4
  11: PUSH
  12: EMPTY
  13: ST_TO_ADDR
// cornell_limit := 0 ;
  14: LD_ADDR_VAR 0 5
  18: PUSH
  19: LD_INT 0
  21: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
  22: LD_ADDR_OWVAR 24
  26: PUSH
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 5
  32: PPUSH
  33: CALL_OW 12
  37: ST_TO_ADDR
// uc_nation = nation_american ;
  38: LD_ADDR_OWVAR 21
  42: PUSH
  43: LD_INT 1
  45: ST_TO_ADDR
// uc_side = you ;
  46: LD_ADDR_OWVAR 20
  50: PUSH
  51: LD_EXP 1
  55: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  56: LD_ADDR_EXP 7
  60: PUSH
  61: LD_STRING JMM
  63: PPUSH
  64: CALL_OW 34
  68: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
  69: LD_ADDR_EXP 6
  73: PUSH
  74: LD_STRING Lisa
  76: PPUSH
  77: CALL_OW 34
  81: ST_TO_ADDR
// Bobby := CreateCharacter ( Bobby ) ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_STRING Bobby
  89: PPUSH
  90: CALL_OW 34
  94: ST_TO_ADDR
// Cyrus := CreateCharacter ( Cyrus ) ;
  95: LD_ADDR_EXP 5
  99: PUSH
 100: LD_STRING Cyrus
 102: PPUSH
 103: CALL_OW 34
 107: ST_TO_ADDR
// Khatam := CreateCharacter ( Khatam ) ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_STRING Khatam
 115: PPUSH
 116: CALL_OW 34
 120: ST_TO_ADDR
// Frank := NewCharacter ( Frank ) ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_STRING Frank
 128: PPUSH
 129: CALL_OW 25
 133: ST_TO_ADDR
// Cornell := NewCharacter ( Cornell ) ;
 134: LD_ADDR_EXP 8
 138: PUSH
 139: LD_STRING Cornell
 141: PPUSH
 142: CALL_OW 25
 146: ST_TO_ADDR
// JMM_group := [ Lisa , Bobby , Cyrus , Khatam ] diff 0 ;
 147: LD_ADDR_VAR 0 4
 151: PUSH
 152: LD_EXP 6
 156: PUSH
 157: LD_EXP 4
 161: PUSH
 162: LD_EXP 5
 166: PUSH
 167: LD_EXP 10
 171: PUSH
 172: EMPTY
 173: LIST
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 0
 180: DIFF
 181: ST_TO_ADDR
// PlaceUnitXY ( Cornell , 163 , 100 , false ) ;
 182: LD_EXP 8
 186: PPUSH
 187: LD_INT 163
 189: PPUSH
 190: LD_INT 100
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 48
// Powell := NewCharacter ( Powell ) ;
 200: LD_ADDR_EXP 9
 204: PUSH
 205: LD_STRING Powell
 207: PPUSH
 208: CALL_OW 25
 212: ST_TO_ADDR
// hc_gallery :=  ;
 213: LD_ADDR_OWVAR 33
 217: PUSH
 218: LD_STRING 
 220: ST_TO_ADDR
// hc_importance := 0 ;
 221: LD_ADDR_OWVAR 32
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// cornells := [ ] ;
 229: LD_ADDR_EXP 14
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// cornell_limit := 5 + ( 4 - JMM_group ) ;
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_INT 5
 243: PUSH
 244: LD_INT 4
 246: PUSH
 247: LD_VAR 0 4
 251: MINUS
 252: PLUS
 253: ST_TO_ADDR
// for i := 1 to cornell_limit do
 254: LD_ADDR_VAR 0 3
 258: PUSH
 259: DOUBLE
 260: LD_INT 1
 262: DEC
 263: ST_TO_ADDR
 264: LD_VAR 0 5
 268: PUSH
 269: FOR_TO
 270: IFFALSE 346
// begin PrepareHuman ( 2 - i mod 2 , 0 , 2 ) ;
 272: LD_INT 2
 274: PUSH
 275: LD_VAR 0 3
 279: PUSH
 280: LD_INT 2
 282: MOD
 283: MINUS
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: LD_INT 2
 290: PPUSH
 291: CALL_OW 380
// hc_class := class_soldier ;
 295: LD_ADDR_OWVAR 28
 299: PUSH
 300: LD_INT 1
 302: ST_TO_ADDR
// un := CreateHuman ;
 303: LD_ADDR_VAR 0 2
 307: PUSH
 308: CALL_OW 44
 312: ST_TO_ADDR
// cornells := cornells ^ un ;
 313: LD_ADDR_EXP 14
 317: PUSH
 318: LD_EXP 14
 322: PUSH
 323: LD_VAR 0 2
 327: ADD
 328: ST_TO_ADDR
// PlaceUnitArea ( un , cornellsarea , false ) ;
 329: LD_VAR 0 2
 333: PPUSH
 334: LD_INT 20
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 49
// end ;
 344: GO 269
 346: POP
 347: POP
// if TestCharacters ( other_survivors ) then
 348: LD_STRING other_survivors
 350: PPUSH
 351: CALL_OW 28
 355: IFFALSE 372
// other_survivors := CreateCharacterSet ( other_survivors ) else
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING other_survivors
 364: PPUSH
 365: CALL_OW 31
 369: ST_TO_ADDR
 370: GO 379
// other_survivors := [ ] ;
 372: LD_ADDR_EXP 13
 376: PUSH
 377: EMPTY
 378: ST_TO_ADDR
// uc_nation = nation_russian ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// uc_side = russians ;
 387: LD_ADDR_OWVAR 20
 391: PUSH
 392: LD_EXP 2
 396: ST_TO_ADDR
// if ( LoadVariable ( us2mikhail_state , 0 ) = 5 ) and TestCharacters ( Mikhail ) and CheckCharacterSet ( Mikhail ) then
 397: LD_STRING us2mikhail_state
 399: PPUSH
 400: LD_INT 0
 402: PPUSH
 403: CALL_OW 30
 407: PUSH
 408: LD_INT 5
 410: EQUAL
 411: PUSH
 412: LD_STRING Mikhail
 414: PPUSH
 415: CALL_OW 28
 419: AND
 420: PUSH
 421: LD_STRING Mikhail
 423: PPUSH
 424: CALL_OW 29
 428: AND
 429: IFFALSE 444
// Mikhail := CreateCharacter ( Mikhail ) ;
 431: LD_ADDR_EXP 21
 435: PUSH
 436: LD_STRING Mikhail
 438: PPUSH
 439: CALL_OW 34
 443: ST_TO_ADDR
// JMMinvehicle := LoadVariable ( us2JMMInVehicle , false ) ;
 444: LD_ADDR_EXP 19
 448: PUSH
 449: LD_STRING us2JMMInVehicle
 451: PPUSH
 452: LD_INT 0
 454: PPUSH
 455: CALL_OW 30
 459: ST_TO_ADDR
// Cyrusinvehicle := LoadVariable ( us2CyrusInVehicle , false ) ;
 460: LD_ADDR_EXP 20
 464: PUSH
 465: LD_STRING us2CyrusInVehicle
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: CALL_OW 30
 475: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
 476: LD_INT 2
 478: PUSH
 479: LD_INT 3
 481: PUSH
 482: LD_INT 1
 484: PUSH
 485: LD_INT 4
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: PPUSH
 494: CALL_OW 139
// Kobra1 := [ MacMillan , Bobby , Lisa , Cyrus , Mikhail , Khatam ] ^ other_survivors diff [ 0 ] ;
 498: LD_ADDR_EXP 12
 502: PUSH
 503: LD_EXP 7
 507: PUSH
 508: LD_EXP 4
 512: PUSH
 513: LD_EXP 6
 517: PUSH
 518: LD_EXP 5
 522: PUSH
 523: LD_EXP 21
 527: PUSH
 528: LD_EXP 10
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_EXP 13
 545: ADD
 546: PUSH
 547: LD_INT 0
 549: PUSH
 550: EMPTY
 551: LIST
 552: DIFF
 553: ST_TO_ADDR
// SetClass ( Kobra1 diff Mikhail , class_soldier ) ;
 554: LD_EXP 12
 558: PUSH
 559: LD_EXP 21
 563: DIFF
 564: PPUSH
 565: LD_INT 1
 567: PPUSH
 568: CALL_OW 336
// Kobra1 := Kobra1 diff [ 0 ] ;
 572: LD_ADDR_EXP 12
 576: PUSH
 577: LD_EXP 12
 581: PUSH
 582: LD_INT 0
 584: PUSH
 585: EMPTY
 586: LIST
 587: DIFF
 588: ST_TO_ADDR
// cans := LoadVariable ( us2cans , 60 ) ;
 589: LD_ADDR_EXP 37
 593: PUSH
 594: LD_STRING us2cans
 596: PPUSH
 597: LD_INT 60
 599: PPUSH
 600: CALL_OW 30
 604: ST_TO_ADDR
// if cans > 200 then
 605: LD_EXP 37
 609: PUSH
 610: LD_INT 200
 612: GREATER
 613: IFFALSE 623
// cans := 200 ;
 615: LD_ADDR_EXP 37
 619: PUSH
 620: LD_INT 200
 622: ST_TO_ADDR
// cans1 := 30 ;
 623: LD_ADDR_EXP 38
 627: PUSH
 628: LD_INT 30
 630: ST_TO_ADDR
// cans1 := cans1 + ( ( cans - 30 + 10 ) div 30 ) * 10 ;
 631: LD_ADDR_EXP 38
 635: PUSH
 636: LD_EXP 38
 640: PUSH
 641: LD_EXP 37
 645: PUSH
 646: LD_INT 30
 648: MINUS
 649: PUSH
 650: LD_INT 10
 652: PLUS
 653: PUSH
 654: LD_INT 30
 656: DIV
 657: PUSH
 658: LD_INT 10
 660: MUL
 661: PLUS
 662: ST_TO_ADDR
// if cans1 > 100 then
 663: LD_EXP 38
 667: PUSH
 668: LD_INT 100
 670: GREATER
 671: IFFALSE 681
// cans1 := 100 ;
 673: LD_ADDR_EXP 38
 677: PUSH
 678: LD_INT 100
 680: ST_TO_ADDR
// cans := cans - cans1 ;
 681: LD_ADDR_EXP 37
 685: PUSH
 686: LD_EXP 37
 690: PUSH
 691: LD_EXP 38
 695: MINUS
 696: ST_TO_ADDR
// if cans > 100 then
 697: LD_EXP 37
 701: PUSH
 702: LD_INT 100
 704: GREATER
 705: IFFALSE 715
// cans := 100 ;
 707: LD_ADDR_EXP 37
 711: PUSH
 712: LD_INT 100
 714: ST_TO_ADDR
// uc_side := you ;
 715: LD_ADDR_OWVAR 20
 719: PUSH
 720: LD_EXP 1
 724: ST_TO_ADDR
// uc_nation := nation_russian ;
 725: LD_ADDR_OWVAR 21
 729: PUSH
 730: LD_INT 3
 732: ST_TO_ADDR
// uc_direction := 5 ;
 733: LD_ADDR_OWVAR 24
 737: PUSH
 738: LD_INT 5
 740: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
 741: LD_ADDR_OWVAR 37
 745: PUSH
 746: LD_INT 22
 748: ST_TO_ADDR
// vc_engine := engine_combustion ;
 749: LD_ADDR_OWVAR 39
 753: PUSH
 754: LD_INT 1
 756: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
 757: LD_ADDR_OWVAR 40
 761: PUSH
 762: LD_INT 51
 764: ST_TO_ADDR
// vc_control := control_manual ;
 765: LD_ADDR_OWVAR 38
 769: PUSH
 770: LD_INT 1
 772: ST_TO_ADDR
// if cans1 > 0 then
 773: LD_EXP 38
 777: PUSH
 778: LD_INT 0
 780: GREATER
 781: IFFALSE 856
// begin amtruck1 := CreateVehicle ;
 783: LD_ADDR_EXP 35
 787: PUSH
 788: CALL_OW 45
 792: ST_TO_ADDR
// PlaceHumanInUnit ( Macmillan , amtruck1 ) ;
 793: LD_EXP 7
 797: PPUSH
 798: LD_EXP 35
 802: PPUSH
 803: CALL_OW 52
// SetCargo ( amtruck1 , mat_cans , cans1 ) ;
 807: LD_EXP 35
 811: PPUSH
 812: LD_INT 1
 814: PPUSH
 815: LD_EXP 38
 819: PPUSH
 820: CALL_OW 290
// SetFuel ( amtruck1 , 50 ) ;
 824: LD_EXP 35
 828: PPUSH
 829: LD_INT 50
 831: PPUSH
 832: CALL_OW 240
// PlaceUnitXY ( amtruck1 , 174 , 115 , false ) ;
 836: LD_EXP 35
 840: PPUSH
 841: LD_INT 174
 843: PPUSH
 844: LD_INT 115
 846: PPUSH
 847: LD_INT 0
 849: PPUSH
 850: CALL_OW 48
// end else
 854: GO 874
// PlaceUnitXY ( MacMillan , 174 , 115 , false ) ;
 856: LD_EXP 7
 860: PPUSH
 861: LD_INT 174
 863: PPUSH
 864: LD_INT 115
 866: PPUSH
 867: LD_INT 0
 869: PPUSH
 870: CALL_OW 48
// if ( cans > 0 ) and ( Kobra1 > 1 ) then
 874: LD_EXP 37
 878: PUSH
 879: LD_INT 0
 881: GREATER
 882: PUSH
 883: LD_EXP 12
 887: PUSH
 888: LD_INT 1
 890: GREATER
 891: AND
 892: IFFALSE 969
// begin amtruck2 := CreateVehicle ;
 894: LD_ADDR_EXP 36
 898: PUSH
 899: CALL_OW 45
 903: ST_TO_ADDR
// PlaceHumanInUnit ( Kobra1 [ 2 ] , amtruck2 ) ;
 904: LD_EXP 12
 908: PUSH
 909: LD_INT 2
 911: ARRAY
 912: PPUSH
 913: LD_EXP 36
 917: PPUSH
 918: CALL_OW 52
// SetCargo ( amtruck2 , mat_cans , cans ) ;
 922: LD_EXP 36
 926: PPUSH
 927: LD_INT 1
 929: PPUSH
 930: LD_EXP 37
 934: PPUSH
 935: CALL_OW 290
// SetFuel ( amtruck2 , 50 ) ;
 939: LD_EXP 36
 943: PPUSH
 944: LD_INT 50
 946: PPUSH
 947: CALL_OW 240
// PlaceUnitXY ( amtruck2 , 171 , 115 , false ) ;
 951: LD_EXP 36
 955: PPUSH
 956: LD_INT 171
 958: PPUSH
 959: LD_INT 115
 961: PPUSH
 962: LD_INT 0
 964: PPUSH
 965: CALL_OW 48
// end ; for un in Kobra1 do
 969: LD_ADDR_VAR 0 2
 973: PUSH
 974: LD_EXP 12
 978: PUSH
 979: FOR_IN
 980: IFFALSE 1011
// if not IsInUnit ( un ) then
 982: LD_VAR 0 2
 986: PPUSH
 987: CALL_OW 310
 991: NOT
 992: IFFALSE 1009
// PlaceUnitArea ( un , enterarea , false ) ;
 994: LD_VAR 0 2
 998: PPUSH
 999: LD_INT 19
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
1009: GO 979
1011: POP
1012: POP
// end ;
1013: LD_VAR 0 1
1017: RET
// function prepare_sides ; begin
1018: LD_INT 0
1020: PPUSH
// you = 1 ;
1021: LD_ADDR_EXP 1
1025: PUSH
1026: LD_INT 1
1028: ST_TO_ADDR
// neutral = 4 ;
1029: LD_ADDR_EXP 3
1033: PUSH
1034: LD_INT 4
1036: ST_TO_ADDR
// russians = 3 ;
1037: LD_ADDR_EXP 2
1041: PUSH
1042: LD_INT 3
1044: ST_TO_ADDR
// atack = 0 ;
1045: LD_ADDR_EXP 16
1049: PUSH
1050: LD_INT 0
1052: ST_TO_ADDR
// time_to_return := [ 25 25$0 , 12 12$0 , 2 2$0 ] [ difficulty ] ;
1053: LD_ADDR_EXP 40
1057: PUSH
1058: LD_INT 52500
1060: PUSH
1061: LD_INT 25200
1063: PUSH
1064: LD_INT 4200
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_OWVAR 67
1076: ARRAY
1077: ST_TO_ADDR
// time_to_attack := [ 40 40$0 , 25 25$0 , 15 15$0 ] [ difficulty ] ;
1078: LD_ADDR_EXP 41
1082: PUSH
1083: LD_INT 84000
1085: PUSH
1086: LD_INT 52500
1088: PUSH
1089: LD_INT 31500
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: PUSH
1097: LD_OWVAR 67
1101: ARRAY
1102: ST_TO_ADDR
// solar_constructed := false ;
1103: LD_ADDR_EXP 42
1107: PUSH
1108: LD_INT 0
1110: ST_TO_ADDR
// solar_saved := true ;
1111: LD_ADDR_EXP 43
1115: PUSH
1116: LD_INT 1
1118: ST_TO_ADDR
// saved_units = [ ] ;
1119: LD_ADDR_EXP 17
1123: PUSH
1124: EMPTY
1125: ST_TO_ADDR
// time_crates := Rand ( 0 0$20 , 0 0$40 ) ;
1126: LD_ADDR_LOC 1
1130: PUSH
1131: LD_INT 700
1133: PPUSH
1134: LD_INT 1400
1136: PPUSH
1137: CALL_OW 12
1141: ST_TO_ADDR
// mrtvi_lide := 0 ;
1142: LD_ADDR_EXP 18
1146: PUSH
1147: LD_INT 0
1149: ST_TO_ADDR
// Meet_Frank := false ;
1150: LD_ADDR_EXP 44
1154: PUSH
1155: LD_INT 0
1157: ST_TO_ADDR
// base_reached := false ;
1158: LD_ADDR_EXP 45
1162: PUSH
1163: LD_INT 0
1165: ST_TO_ADDR
// cornell_lost := false ;
1166: LD_ADDR_EXP 46
1170: PUSH
1171: LD_INT 0
1173: ST_TO_ADDR
// Dialogue_wait := false ;
1174: LD_ADDR_EXP 39
1178: PUSH
1179: LD_INT 0
1181: ST_TO_ADDR
// forest_force1 = [ forest11 , forest12 ] ;
1182: LD_ADDR_EXP 29
1186: PUSH
1187: LD_INT 26
1189: PUSH
1190: LD_INT 25
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: ST_TO_ADDR
// forest_force2 = [ forest21 , forest22 ] ;
1197: LD_ADDR_EXP 30
1201: PUSH
1202: LD_INT 41
1204: PUSH
1205: LD_INT 42
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// ComEnterUnit ( guard1 , bunker1 ) ;
1212: LD_INT 30
1214: PPUSH
1215: LD_INT 28
1217: PPUSH
1218: CALL_OW 120
// ComEnterUnit ( guard2 , bunker2 ) ;
1222: LD_INT 29
1224: PPUSH
1225: LD_INT 27
1227: PPUSH
1228: CALL_OW 120
// ComEnterUnit ( guard3 , bunker3 ) ;
1232: LD_INT 48
1234: PPUSH
1235: LD_INT 34
1237: PPUSH
1238: CALL_OW 120
// ComEnterUnit ( guard4 , bunker4 ) ;
1242: LD_INT 47
1244: PPUSH
1245: LD_INT 33
1247: PPUSH
1248: CALL_OW 120
// ComEnterUnit ( guard5 , bunker5 ) ;
1252: LD_INT 49
1254: PPUSH
1255: LD_INT 32
1257: PPUSH
1258: CALL_OW 120
// ComEnterUnit ( guard6 , bunker6 ) ;
1262: LD_INT 20
1264: PPUSH
1265: LD_INT 31
1267: PPUSH
1268: CALL_OW 120
// ComEnterUnit ( guard7 , bunker7 ) ;
1272: LD_INT 53
1274: PPUSH
1275: LD_INT 52
1277: PPUSH
1278: CALL_OW 120
// ComEnterUnit ( maker_1 , factory1 ) ;
1282: LD_INT 16
1284: PPUSH
1285: LD_INT 11
1287: PPUSH
1288: CALL_OW 120
// ComEnterUnit ( maker_2 , factory2 ) ;
1292: LD_INT 46
1294: PPUSH
1295: LD_INT 10
1297: PPUSH
1298: CALL_OW 120
// ComEnterUnit ( sci1 , labor1 ) ;
1302: LD_INT 18
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: CALL_OW 120
// ComHold ( am1 ) ;
1312: LD_INT 2
1314: PPUSH
1315: CALL_OW 140
// SetAttitude ( russians , you , att_friend , true ) ;
1319: LD_EXP 2
1323: PPUSH
1324: LD_EXP 1
1328: PPUSH
1329: LD_INT 1
1331: PPUSH
1332: LD_INT 1
1334: PPUSH
1335: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
1339: LD_EXP 1
1343: PPUSH
1344: LD_EXP 3
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: LD_INT 1
1354: PPUSH
1355: CALL_OW 80
// SetAttitude ( russians , neutral , att_friend , true ) ;
1359: LD_EXP 2
1363: PPUSH
1364: LD_EXP 3
1368: PPUSH
1369: LD_INT 1
1371: PPUSH
1372: LD_INT 1
1374: PPUSH
1375: CALL_OW 80
// disable ( 1 ) ;
1379: LD_INT 1
1381: DISABLE_MARKED
// disable ( 2 ) ;
1382: LD_INT 2
1384: DISABLE_MARKED
// disable ( 3 ) ;
1385: LD_INT 3
1387: DISABLE_MARKED
// disable ( 4 ) ;
1388: LD_INT 4
1390: DISABLE_MARKED
// disable ( 5 ) ;
1391: LD_INT 5
1393: DISABLE_MARKED
// disable ( 7 ) ;
1394: LD_INT 7
1396: DISABLE_MARKED
// disable ( 8 ) ;
1397: LD_INT 8
1399: DISABLE_MARKED
// disable ( 10 ) ;
1400: LD_INT 10
1402: DISABLE_MARKED
// enable ( 11 ) ;
1403: LD_INT 11
1405: ENABLE_MARKED
// end ;
1406: LD_VAR 0 1
1410: RET
// starting begin interface_hidden := true ;
1411: LD_ADDR_OWVAR 54
1415: PUSH
1416: LD_INT 1
1418: ST_TO_ADDR
// RandomizeAll ;
1419: CALL_OW 11
// prepare_sides ;
1423: CALL 1018 0 0
// prepare_russian_side ;
1427: CALL 12931 0 0
// fix_difficulty ;
1431: CALL 14444 0 0
// prepare_units ;
1435: CALL 0 0 0
// starting_scene ;
1439: CALL 8489 0 0
// init_hints ;
1443: CALL 14797 0 0
// run_ru_guarding ;
1447: CALL 4017 0 0
// end ;
1451: END
// every 0 0$5 trigger TICK >= time_crates do
1452: LD_OWVAR 1
1456: PUSH
1457: LD_LOC 1
1461: GREATEREQUAL
1462: IFFALSE 1511
1464: GO 1466
1466: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 3 ) , Am_Base , true ) ;
1467: LD_INT 2
1469: PPUSH
1470: LD_INT 3
1472: PPUSH
1473: CALL_OW 12
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: CALL_OW 55
// time_crates := TICK + Rand ( 0 0$50 , 0 0$100 ) ;
1488: LD_ADDR_LOC 1
1492: PUSH
1493: LD_OWVAR 1
1497: PUSH
1498: LD_INT 1750
1500: PPUSH
1501: LD_INT 3500
1503: PPUSH
1504: CALL_OW 12
1508: PLUS
1509: ST_TO_ADDR
// enable ;
1510: ENABLE
// end ;
1511: END
// function Konec_Mise ; var m1 , m2 , m3 , dying_units , units_for_save , medal1 , medal2 , medal3 ; begin
1512: LD_INT 0
1514: PPUSH
1515: PPUSH
1516: PPUSH
1517: PPUSH
1518: PPUSH
1519: PPUSH
1520: PPUSH
1521: PPUSH
1522: PPUSH
// wait ( 5 ) ;
1523: LD_INT 5
1525: PPUSH
1526: CALL_OW 67
// gained_medals := [ ] ;
1530: LD_ADDR_OWVAR 61
1534: PUSH
1535: EMPTY
1536: ST_TO_ADDR
// missing_medals := [ ] ;
1537: LD_ADDR_OWVAR 62
1541: PUSH
1542: EMPTY
1543: ST_TO_ADDR
// dying_units := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_ok ] ] ) diff MacMillan ;
1544: LD_ADDR_VAR 0 5
1548: PUSH
1549: LD_INT 22
1551: PUSH
1552: LD_EXP 1
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 21
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 50
1576: PUSH
1577: EMPTY
1578: LIST
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: LIST
1584: LIST
1585: PPUSH
1586: CALL_OW 69
1590: PUSH
1591: LD_EXP 7
1595: DIFF
1596: ST_TO_ADDR
// mrtvi_lide := mrtvi_lide + dying_units ;
1597: LD_ADDR_EXP 18
1601: PUSH
1602: LD_EXP 18
1606: PUSH
1607: LD_VAR 0 5
1611: PLUS
1612: ST_TO_ADDR
// saved_units := saved_units diff mrtvi_lide ;
1613: LD_ADDR_EXP 17
1617: PUSH
1618: LD_EXP 17
1622: PUSH
1623: LD_EXP 18
1627: DIFF
1628: ST_TO_ADDR
// if IsDead ( MacMillan ) or IsDying ( MacMillan ) then
1629: LD_EXP 7
1633: PPUSH
1634: CALL_OW 301
1638: PUSH
1639: LD_EXP 7
1643: PPUSH
1644: CALL_OW 303
1648: OR
1649: IFFALSE 1660
// begin YouLost ( 0 ) ;
1651: LD_STRING 0
1653: PPUSH
1654: CALL_OW 104
// exit ;
1658: GO 2167
// end ; if saved_units and not base_reached then
1660: LD_EXP 17
1664: PUSH
1665: LD_EXP 45
1669: NOT
1670: AND
1671: IFFALSE 1682
// begin YouLost ( 4 ) ;
1673: LD_STRING 4
1675: PPUSH
1676: CALL_OW 104
// exit ;
1680: GO 2167
// end ; if saved_units < 4 then
1682: LD_EXP 17
1686: PUSH
1687: LD_INT 4
1689: LESS
1690: IFFALSE 1701
// begin YouLost ( 1 ) ;
1692: LD_STRING 1
1694: PPUSH
1695: CALL_OW 104
// exit ;
1699: GO 2167
// end ; if IsOK ( MacMillan ) then
1701: LD_EXP 7
1705: PPUSH
1706: CALL_OW 302
1710: IFFALSE 1758
// begin m1 := IsInUnit ( MacMillan ) ;
1712: LD_ADDR_VAR 0 2
1716: PUSH
1717: LD_EXP 7
1721: PPUSH
1722: CALL_OW 310
1726: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
1727: LD_EXP 7
1731: PPUSH
1732: CALL_OW 64
// if m1 then
1736: LD_VAR 0 2
1740: IFFALSE 1751
// RemoveUnit ( m1 ) ;
1742: LD_VAR 0 2
1746: PPUSH
1747: CALL_OW 64
// wait ( 20 ) ;
1751: LD_INT 20
1753: PPUSH
1754: CALL_OW 67
// end ; if not mrtvi_lide then
1758: LD_EXP 18
1762: NOT
1763: IFFALSE 1773
// medal1 := true ;
1765: LD_ADDR_VAR 0 7
1769: PUSH
1770: LD_INT 1
1772: ST_TO_ADDR
// AddMedal ( No , not mrtvi_lide ) ;
1773: LD_STRING No
1775: PPUSH
1776: LD_EXP 18
1780: NOT
1781: PPUSH
1782: CALL_OW 101
// AddMedal ( Solar1 , solar_constructed ) ;
1786: LD_STRING Solar1
1788: PPUSH
1789: LD_EXP 42
1793: PPUSH
1794: CALL_OW 101
// if solar_constructed then
1798: LD_EXP 42
1802: IFFALSE 1851
// begin medal2 := true ;
1804: LD_ADDR_VAR 0 8
1808: PUSH
1809: LD_INT 1
1811: ST_TO_ADDR
// if solar_saved then
1812: LD_EXP 43
1816: IFFALSE 1838
// begin AddMedal ( Solar2 , 1 ) ;
1818: LD_STRING Solar2
1820: PPUSH
1821: LD_INT 1
1823: PPUSH
1824: CALL_OW 101
// medal3 := true ;
1828: LD_ADDR_VAR 0 9
1832: PUSH
1833: LD_INT 1
1835: ST_TO_ADDR
// end else
1836: GO 1849
// AddMedal ( Solar2 , - 2 ) ;
1838: LD_STRING Solar2
1840: PPUSH
1841: LD_INT 2
1843: NEG
1844: PPUSH
1845: CALL_OW 101
// end else
1849: GO 1862
// AddMedal ( Solar2 , - 1 ) ;
1851: LD_STRING Solar2
1853: PPUSH
1854: LD_INT 1
1856: NEG
1857: PPUSH
1858: CALL_OW 101
// SA_EndMission ( 1 , 3 , medal1 , medal2 , medal3 ) ;
1862: LD_INT 1
1864: PPUSH
1865: LD_INT 3
1867: PPUSH
1868: LD_VAR 0 7
1872: PPUSH
1873: LD_VAR 0 8
1877: PPUSH
1878: LD_VAR 0 9
1882: PPUSH
1883: CALL 14943 0 5
// GiveMedals ( Main ) ;
1887: LD_STRING Main
1889: PPUSH
1890: CALL_OW 102
// saved_units := saved_units diff 0 ;
1894: LD_ADDR_EXP 17
1898: PUSH
1899: LD_EXP 17
1903: PUSH
1904: LD_INT 0
1906: DIFF
1907: ST_TO_ADDR
// if Meet_Frank then
1908: LD_EXP 44
1912: IFFALSE 1930
// saved_units := saved_units union Frank ;
1914: LD_ADDR_EXP 17
1918: PUSH
1919: LD_EXP 17
1923: PUSH
1924: LD_EXP 11
1928: UNION
1929: ST_TO_ADDR
// RewardPeople ( saved_units union MacMillan ) ;
1930: LD_EXP 17
1934: PUSH
1935: LD_EXP 7
1939: UNION
1940: PPUSH
1941: CALL_OW 43
// DeleteVariable ( us2cans ) ;
1945: LD_STRING us2cans
1947: PPUSH
1948: CALL_OW 41
// DeleteVariable ( us2JMMInVehicle ) ;
1952: LD_STRING us2JMMInVehicle
1954: PPUSH
1955: CALL_OW 41
// DeleteVariable ( us2CyrusInVehicle ) ;
1959: LD_STRING us2CyrusInVehicle
1961: PPUSH
1962: CALL_OW 41
// SaveCharacters ( MacMillan , JMM ) ;
1966: LD_EXP 7
1970: PPUSH
1971: LD_STRING JMM
1973: PPUSH
1974: CALL_OW 38
// SaveCharacters ( Cyrus , Cyrus ) ;
1978: LD_EXP 5
1982: PPUSH
1983: LD_STRING Cyrus
1985: PPUSH
1986: CALL_OW 38
// SaveCharacters ( Bobby , Bobby ) ;
1990: LD_EXP 4
1994: PPUSH
1995: LD_STRING Bobby
1997: PPUSH
1998: CALL_OW 38
// SaveCharacters ( Lisa , Lisa ) ;
2002: LD_EXP 6
2006: PPUSH
2007: LD_STRING Lisa
2009: PPUSH
2010: CALL_OW 38
// SaveCharacters ( Khatam , Khatam ) ;
2014: LD_EXP 10
2018: PPUSH
2019: LD_STRING Khatam
2021: PPUSH
2022: CALL_OW 38
// if Meet_Frank then
2026: LD_EXP 44
2030: IFFALSE 2044
// SaveCharacters ( Frank , Frank ) ;
2032: LD_EXP 11
2036: PPUSH
2037: LD_STRING Frank
2039: PPUSH
2040: CALL_OW 38
// SaveCharacters ( Mikhail , Mikhail ) ;
2044: LD_EXP 21
2048: PPUSH
2049: LD_STRING Mikhail
2051: PPUSH
2052: CALL_OW 38
// SaveCharacters ( Cornell , Cornell ) ;
2056: LD_EXP 8
2060: PPUSH
2061: LD_STRING Cornell
2063: PPUSH
2064: CALL_OW 38
// units_for_save := other_survivors ^ saved_units ;
2068: LD_ADDR_VAR 0 6
2072: PUSH
2073: LD_EXP 13
2077: PUSH
2078: LD_EXP 17
2082: ADD
2083: ST_TO_ADDR
// units_for_save := units_for_save diff [ MacMillan , Frank , Cyrus , Bobby , Lisa , Khatam ] ;
2084: LD_ADDR_VAR 0 6
2088: PUSH
2089: LD_VAR 0 6
2093: PUSH
2094: LD_EXP 7
2098: PUSH
2099: LD_EXP 11
2103: PUSH
2104: LD_EXP 5
2108: PUSH
2109: LD_EXP 4
2113: PUSH
2114: LD_EXP 6
2118: PUSH
2119: LD_EXP 10
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: DIFF
2132: ST_TO_ADDR
// units_for_save := units_for_save union units_for_save ;
2133: LD_ADDR_VAR 0 6
2137: PUSH
2138: LD_VAR 0 6
2142: PUSH
2143: LD_VAR 0 6
2147: UNION
2148: ST_TO_ADDR
// SaveCharacters ( units_for_save , other_survivors ) ;
2149: LD_VAR 0 6
2153: PPUSH
2154: LD_STRING other_survivors
2156: PPUSH
2157: CALL_OW 38
// YouWin ;
2161: CALL_OW 103
// exit ;
2165: GO 2167
// end ;
2167: LD_VAR 0 1
2171: RET
// function return_of_frank ; var koncova_area ; begin
2172: LD_INT 0
2174: PPUSH
2175: PPUSH
// koncova_area := true ;
2176: LD_ADDR_VAR 0 2
2180: PUSH
2181: LD_INT 1
2183: ST_TO_ADDR
// SetSide ( Frank , you ) ;
2184: LD_EXP 11
2188: PPUSH
2189: LD_EXP 1
2193: PPUSH
2194: CALL_OW 235
// case koncova_area of IsInArea ( MacMillan , Top_1 ) :
2198: LD_VAR 0 2
2202: PUSH
2203: LD_EXP 7
2207: PPUSH
2208: LD_INT 13
2210: PPUSH
2211: CALL_OW 308
2215: DOUBLE
2216: EQUAL
2217: IFTRUE 2221
2219: GO 2239
2221: POP
// PlaceUnitArea ( Frank , frank_1 , false ) ; IsInArea ( MacMillan , Top_2 ) :
2222: LD_EXP 11
2226: PPUSH
2227: LD_INT 21
2229: PPUSH
2230: LD_INT 0
2232: PPUSH
2233: CALL_OW 49
2237: GO 2420
2239: LD_EXP 7
2243: PPUSH
2244: LD_INT 14
2246: PPUSH
2247: CALL_OW 308
2251: DOUBLE
2252: EQUAL
2253: IFTRUE 2257
2255: GO 2275
2257: POP
// PlaceUnitArea ( Frank , frank_2 , false ) ; IsInArea ( MacMillan , Top_3 ) :
2258: LD_EXP 11
2262: PPUSH
2263: LD_INT 22
2265: PPUSH
2266: LD_INT 0
2268: PPUSH
2269: CALL_OW 49
2273: GO 2420
2275: LD_EXP 7
2279: PPUSH
2280: LD_INT 15
2282: PPUSH
2283: CALL_OW 308
2287: DOUBLE
2288: EQUAL
2289: IFTRUE 2293
2291: GO 2311
2293: POP
// PlaceUnitArea ( Frank , frank_3 , false ) ; IsInArea ( MacMillan , Top_4 ) :
2294: LD_EXP 11
2298: PPUSH
2299: LD_INT 23
2301: PPUSH
2302: LD_INT 0
2304: PPUSH
2305: CALL_OW 49
2309: GO 2420
2311: LD_EXP 7
2315: PPUSH
2316: LD_INT 16
2318: PPUSH
2319: CALL_OW 308
2323: DOUBLE
2324: EQUAL
2325: IFTRUE 2329
2327: GO 2347
2329: POP
// PlaceUnitArea ( Frank , frank_4 , false ) ; IsInArea ( MacMillan , Top_5 ) :
2330: LD_EXP 11
2334: PPUSH
2335: LD_INT 24
2337: PPUSH
2338: LD_INT 0
2340: PPUSH
2341: CALL_OW 49
2345: GO 2420
2347: LD_EXP 7
2351: PPUSH
2352: LD_INT 17
2354: PPUSH
2355: CALL_OW 308
2359: DOUBLE
2360: EQUAL
2361: IFTRUE 2365
2363: GO 2383
2365: POP
// PlaceUnitArea ( Frank , frank_5 , false ) ; IsInArea ( MacMillan , Top_6 ) :
2366: LD_EXP 11
2370: PPUSH
2371: LD_INT 25
2373: PPUSH
2374: LD_INT 0
2376: PPUSH
2377: CALL_OW 49
2381: GO 2420
2383: LD_EXP 7
2387: PPUSH
2388: LD_INT 18
2390: PPUSH
2391: CALL_OW 308
2395: DOUBLE
2396: EQUAL
2397: IFTRUE 2401
2399: GO 2419
2401: POP
// PlaceUnitArea ( Frank , frank_6 , false ) ; end ;
2402: LD_EXP 11
2406: PPUSH
2407: LD_INT 26
2409: PPUSH
2410: LD_INT 0
2412: PPUSH
2413: CALL_OW 49
2417: GO 2420
2419: POP
// wait ( 10 ) ;
2420: LD_INT 10
2422: PPUSH
2423: CALL_OW 67
// ComRemember ( Frank ) ;
2427: LD_EXP 11
2431: PPUSH
2432: CALL_OW 143
// ComMoveUnit ( Frank , MacMillan ) ;
2436: LD_EXP 11
2440: PPUSH
2441: LD_EXP 7
2445: PPUSH
2446: CALL_OW 112
// Wait ( 0 0$2 ) ;
2450: LD_INT 70
2452: PPUSH
2453: CALL_OW 67
// ComStop ( Frank ) ;
2457: LD_EXP 11
2461: PPUSH
2462: CALL_OW 141
// ComTurnUnit ( Frank , MacMillan ) ;
2466: LD_EXP 11
2470: PPUSH
2471: LD_EXP 7
2475: PPUSH
2476: CALL_OW 119
// CenterOnUnits ( Frank ) ;
2480: LD_EXP 11
2484: PPUSH
2485: CALL_OW 85
// wait ( 20 ) ;
2489: LD_INT 20
2491: PPUSH
2492: CALL_OW 67
// DialogueOn ;
2496: CALL_OW 6
// interface_hidden := true ;
2500: LD_ADDR_OWVAR 54
2504: PUSH
2505: LD_INT 1
2507: ST_TO_ADDR
// Say ( Frank , D6a-Frank-1 ) ;
2508: LD_EXP 11
2512: PPUSH
2513: LD_STRING D6a-Frank-1
2515: PPUSH
2516: CALL_OW 88
// interface_hidden := false ;
2520: LD_ADDR_OWVAR 54
2524: PUSH
2525: LD_INT 0
2527: ST_TO_ADDR
// DialogueOff ;
2528: CALL_OW 7
// ComReturn ( Frank ) ;
2532: LD_EXP 11
2536: PPUSH
2537: CALL_OW 144
// repeat wait ( 10 ) ;
2541: LD_INT 10
2543: PPUSH
2544: CALL_OW 67
// if GetLives ( Frank ) < 900 then
2548: LD_EXP 11
2552: PPUSH
2553: CALL_OW 256
2557: PUSH
2558: LD_INT 900
2560: LESS
2561: IFFALSE 2586
// SetLives ( Frank , GetLives ( Frank ) + 50 ) ;
2563: LD_EXP 11
2567: PPUSH
2568: LD_EXP 11
2572: PPUSH
2573: CALL_OW 256
2577: PUSH
2578: LD_INT 50
2580: PLUS
2581: PPUSH
2582: CALL_OW 234
// until not HasTask ( Frank ) ;
2586: LD_EXP 11
2590: PPUSH
2591: CALL_OW 314
2595: NOT
2596: IFFALSE 2541
// RemoveUnit ( Frank ) ;
2598: LD_EXP 11
2602: PPUSH
2603: CALL_OW 64
// end ;
2607: LD_VAR 0 1
2611: RET
// export function GridY ( un ) ; var veh , grid ; begin
2612: LD_INT 0
2614: PPUSH
2615: PPUSH
2616: PPUSH
// veh := false ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_INT 0
2624: ST_TO_ADDR
// veh := IsInUnit ( un ) ;
2625: LD_ADDR_VAR 0 3
2629: PUSH
2630: LD_VAR 0 1
2634: PPUSH
2635: CALL_OW 310
2639: ST_TO_ADDR
// if veh then
2640: LD_VAR 0 3
2644: IFFALSE 2663
// grid := GetY ( veh ) else
2646: LD_ADDR_VAR 0 4
2650: PUSH
2651: LD_VAR 0 3
2655: PPUSH
2656: CALL_OW 251
2660: ST_TO_ADDR
2661: GO 2678
// grid := GetY ( un ) ;
2663: LD_ADDR_VAR 0 4
2667: PUSH
2668: LD_VAR 0 1
2672: PPUSH
2673: CALL_OW 251
2677: ST_TO_ADDR
// result := grid ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 4
2687: ST_TO_ADDR
// end ;
2688: LD_VAR 0 2
2692: RET
// every 0 0$1 trigger GridY ( MacMillan ) < 18 do var un ;
2693: LD_EXP 7
2697: PPUSH
2698: CALL 2612 0 1
2702: PUSH
2703: LD_INT 18
2705: LESS
2706: IFFALSE 2735
2708: GO 2710
2710: DISABLE
2711: LD_INT 0
2713: PPUSH
// begin if GetSide ( Frank ) = neutral then
2714: LD_EXP 11
2718: PPUSH
2719: CALL_OW 255
2723: PUSH
2724: LD_EXP 3
2728: EQUAL
2729: IFFALSE 2735
// return_of_frank ;
2731: CALL 2172 0 0
// end ;
2735: PPOPN 1
2737: END
// on UnitDestroyed ( un ) do begin if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_human ) then
2738: LD_VAR 0 1
2742: PPUSH
2743: CALL_OW 255
2747: PUSH
2748: LD_EXP 1
2752: EQUAL
2753: PUSH
2754: LD_VAR 0 1
2758: PPUSH
2759: CALL_OW 247
2763: PUSH
2764: LD_INT 1
2766: EQUAL
2767: AND
2768: IFFALSE 2784
// mrtvi_lide := mrtvi_lide + 1 ;
2770: LD_ADDR_EXP 18
2774: PUSH
2775: LD_EXP 18
2779: PUSH
2780: LD_INT 1
2782: PLUS
2783: ST_TO_ADDR
// if un = MacMillan then
2784: LD_VAR 0 1
2788: PUSH
2789: LD_EXP 7
2793: EQUAL
2794: IFFALSE 2800
// Konec_Mise ;
2796: CALL 1512 0 0
// if un = sklad then
2800: LD_VAR 0 1
2804: PUSH
2805: LD_INT 5
2807: EQUAL
2808: IFFALSE 2819
// begin YouLost ( 2 ) ;
2810: LD_STRING 2
2812: PPUSH
2813: CALL_OW 104
// exit ;
2817: GO 2835
// end ; ru_trucks := ru_trucks diff un ;
2819: LD_ADDR_EXP 48
2823: PUSH
2824: LD_EXP 48
2828: PUSH
2829: LD_VAR 0 1
2833: DIFF
2834: ST_TO_ADDR
// end ;
2835: PPOPN 1
2837: END
// every 0 0$5.1 do
2838: GO 2840
2840: DISABLE
// begin if ( ( FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_lives , 0 ] , [ f_type , unit_human ] ] ) diff MacMillan ) + saved_units ) < 4 then
2841: LD_INT 23
2843: PUSH
2844: LD_INT 1
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 24
2853: PUSH
2854: LD_INT 0
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: LD_INT 21
2863: PUSH
2864: LD_INT 1
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: PPUSH
2876: CALL_OW 69
2880: PUSH
2881: LD_EXP 7
2885: DIFF
2886: PUSH
2887: LD_EXP 17
2891: PLUS
2892: PUSH
2893: LD_INT 4
2895: LESS
2896: IFFALSE 2902
// Konec_Mise ;
2898: CALL 1512 0 0
// enable ;
2902: ENABLE
// end ;
2903: END
// every 0 0$1 trigger IsInArea ( MacMillan , TopBorder ) or IsInArea ( IsInUnit ( MacMillan ) , TopBorder ) do var un , list , car , isin , living ;
2904: LD_EXP 7
2908: PPUSH
2909: LD_INT 1
2911: PPUSH
2912: CALL_OW 308
2916: PUSH
2917: LD_EXP 7
2921: PPUSH
2922: CALL_OW 310
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: CALL_OW 308
2934: OR
2935: IFFALSE 3468
2937: GO 2939
2939: DISABLE
2940: LD_INT 0
2942: PPUSH
2943: PPUSH
2944: PPUSH
2945: PPUSH
2946: PPUSH
// begin living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
2947: LD_ADDR_VAR 0 5
2951: PUSH
2952: LD_INT 22
2954: PUSH
2955: LD_EXP 1
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: PUSH
2964: LD_INT 21
2966: PUSH
2967: LD_INT 1
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 50
2976: PUSH
2977: EMPTY
2978: LIST
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: LIST
2984: PPUSH
2985: CALL_OW 69
2989: PUSH
2990: LD_EXP 7
2994: DIFF
2995: ST_TO_ADDR
// car := IsInUnit ( MacMillan ) ;
2996: LD_ADDR_VAR 0 3
3000: PUSH
3001: LD_EXP 7
3005: PPUSH
3006: CALL_OW 310
3010: ST_TO_ADDR
// if not living then
3011: LD_VAR 0 5
3015: NOT
3016: IFFALSE 3073
// begin RemoveUnit ( MacMillan ) ;
3018: LD_EXP 7
3022: PPUSH
3023: CALL_OW 64
// if car then
3027: LD_VAR 0 3
3031: IFFALSE 3065
// begin if GetEngine ( car ) = engine_solar then
3033: LD_VAR 0 3
3037: PPUSH
3038: CALL_OW 262
3042: PUSH
3043: LD_INT 2
3045: EQUAL
3046: IFFALSE 3056
// solar_saved := true ;
3048: LD_ADDR_EXP 43
3052: PUSH
3053: LD_INT 1
3055: ST_TO_ADDR
// RemoveUnit ( car ) ;
3056: LD_VAR 0 3
3060: PPUSH
3061: CALL_OW 64
// end ; Konec_mise ;
3065: CALL 1512 0 0
// exit ;
3069: GO 3468
// end else
3071: GO 3467
// if Query ( Q2 ) = 1 then
3073: LD_STRING Q2
3075: PPUSH
3076: CALL_OW 97
3080: PUSH
3081: LD_INT 1
3083: EQUAL
3084: IFFALSE 3249
// begin repeat wait ( 0 0$1 ) ;
3086: LD_INT 35
3088: PPUSH
3089: CALL_OW 67
// living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
3093: LD_ADDR_VAR 0 5
3097: PUSH
3098: LD_INT 22
3100: PUSH
3101: LD_EXP 1
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: LD_INT 21
3112: PUSH
3113: LD_INT 1
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: LD_INT 50
3122: PUSH
3123: EMPTY
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: LIST
3130: PPUSH
3131: CALL_OW 69
3135: PUSH
3136: LD_EXP 7
3140: DIFF
3141: ST_TO_ADDR
// isin := IsInArea ( MacMillan , TopBorder ) ;
3142: LD_ADDR_VAR 0 4
3146: PUSH
3147: LD_EXP 7
3151: PPUSH
3152: LD_INT 1
3154: PPUSH
3155: CALL_OW 308
3159: ST_TO_ADDR
// until not ( living and isin ) ;
3160: LD_VAR 0 5
3164: PUSH
3165: LD_VAR 0 4
3169: AND
3170: NOT
3171: IFFALSE 3086
// if isin then
3173: LD_VAR 0 4
3177: IFFALSE 3247
// begin car := IsInUnit ( MacMillan ) ;
3179: LD_ADDR_VAR 0 3
3183: PUSH
3184: LD_EXP 7
3188: PPUSH
3189: CALL_OW 310
3193: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
3194: LD_EXP 7
3198: PPUSH
3199: CALL_OW 64
// if car then
3203: LD_VAR 0 3
3207: IFFALSE 3241
// begin if GetEngine ( car ) = engine_solar then
3209: LD_VAR 0 3
3213: PPUSH
3214: CALL_OW 262
3218: PUSH
3219: LD_INT 2
3221: EQUAL
3222: IFFALSE 3232
// solar_saved := true ;
3224: LD_ADDR_EXP 43
3228: PUSH
3229: LD_INT 1
3231: ST_TO_ADDR
// RemoveUnit ( car ) ;
3232: LD_VAR 0 3
3236: PPUSH
3237: CALL_OW 64
// end ; Konec_mise ;
3241: CALL 1512 0 0
// exit ;
3245: GO 3468
// end ; end else
3247: GO 3467
// begin RemoveUnit ( MacMillan ) ;
3249: LD_EXP 7
3253: PPUSH
3254: CALL_OW 64
// if car then
3258: LD_VAR 0 3
3262: IFFALSE 3296
// begin if GetEngine ( car ) = engine_solar then
3264: LD_VAR 0 3
3268: PPUSH
3269: CALL_OW 262
3273: PUSH
3274: LD_INT 2
3276: EQUAL
3277: IFFALSE 3287
// solar_saved := true ;
3279: LD_ADDR_EXP 43
3283: PUSH
3284: LD_INT 1
3286: ST_TO_ADDR
// RemoveUnit ( car ) ;
3287: LD_VAR 0 3
3291: PPUSH
3292: CALL_OW 64
// end ; ingame_video := true ;
3296: LD_ADDR_OWVAR 52
3300: PUSH
3301: LD_INT 1
3303: ST_TO_ADDR
// interface_hidden := true ;
3304: LD_ADDR_OWVAR 54
3308: PUSH
3309: LD_INT 1
3311: ST_TO_ADDR
// repeat living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3312: LD_ADDR_VAR 0 5
3316: PUSH
3317: LD_INT 22
3319: PUSH
3320: LD_EXP 1
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: PUSH
3329: LD_INT 21
3331: PUSH
3332: LD_INT 1
3334: PUSH
3335: EMPTY
3336: LIST
3337: LIST
3338: PUSH
3339: LD_INT 50
3341: PUSH
3342: EMPTY
3343: LIST
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: PPUSH
3350: CALL_OW 69
3354: ST_TO_ADDR
// CenterOnNorthestUnit ( living ) ;
3355: LD_VAR 0 5
3359: PPUSH
3360: CALL 3471 0 1
// for un in living do
3364: LD_ADDR_VAR 0 1
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: FOR_IN
3375: IFFALSE 3437
// ComMoveXY ( un , GetX ( un ) - ( GetY ( un ) div 2 ) + Rand ( - 3 , 3 ) , Rand ( 1 , 2 ) ) ;
3377: LD_VAR 0 1
3381: PPUSH
3382: LD_VAR 0 1
3386: PPUSH
3387: CALL_OW 250
3391: PUSH
3392: LD_VAR 0 1
3396: PPUSH
3397: CALL_OW 251
3401: PUSH
3402: LD_INT 2
3404: DIV
3405: MINUS
3406: PUSH
3407: LD_INT 3
3409: NEG
3410: PPUSH
3411: LD_INT 3
3413: PPUSH
3414: CALL_OW 12
3418: PLUS
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: LD_INT 2
3425: PPUSH
3426: CALL_OW 12
3430: PPUSH
3431: CALL_OW 111
3435: GO 3374
3437: POP
3438: POP
// wait ( 0 0$3 ) ;
3439: LD_INT 105
3441: PPUSH
3442: CALL_OW 67
// until not living ;
3446: LD_VAR 0 5
3450: NOT
3451: IFFALSE 3312
// ingame_video := false ;
3453: LD_ADDR_OWVAR 52
3457: PUSH
3458: LD_INT 0
3460: ST_TO_ADDR
// Konec_mise ;
3461: CALL 1512 0 0
// exit ;
3465: GO 3468
// end ; enable ;
3467: ENABLE
// end ;
3468: PPOPN 5
3470: END
// function CenterOnNorthestUnit ( list ) ; var un , north , x , y , car ; begin
3471: LD_INT 0
3473: PPUSH
3474: PPUSH
3475: PPUSH
3476: PPUSH
3477: PPUSH
3478: PPUSH
// north := 200 ;
3479: LD_ADDR_VAR 0 4
3483: PUSH
3484: LD_INT 200
3486: ST_TO_ADDR
// for un in list do
3487: LD_ADDR_VAR 0 3
3491: PUSH
3492: LD_VAR 0 1
3496: PUSH
3497: FOR_IN
3498: IFFALSE 3607
// begin car := IsInUnit ( un ) ;
3500: LD_ADDR_VAR 0 7
3504: PUSH
3505: LD_VAR 0 3
3509: PPUSH
3510: CALL_OW 310
3514: ST_TO_ADDR
// if car then
3515: LD_VAR 0 7
3519: IFFALSE 3553
// begin x := GetX ( car ) ;
3521: LD_ADDR_VAR 0 5
3525: PUSH
3526: LD_VAR 0 7
3530: PPUSH
3531: CALL_OW 250
3535: ST_TO_ADDR
// y := GetY ( car ) ;
3536: LD_ADDR_VAR 0 6
3540: PUSH
3541: LD_VAR 0 7
3545: PPUSH
3546: CALL_OW 251
3550: ST_TO_ADDR
// end else
3551: GO 3583
// begin x := GetX ( un ) ;
3553: LD_ADDR_VAR 0 5
3557: PUSH
3558: LD_VAR 0 3
3562: PPUSH
3563: CALL_OW 250
3567: ST_TO_ADDR
// y := GetY ( un ) ;
3568: LD_ADDR_VAR 0 6
3572: PUSH
3573: LD_VAR 0 3
3577: PPUSH
3578: CALL_OW 251
3582: ST_TO_ADDR
// end ; if y < north then
3583: LD_VAR 0 6
3587: PUSH
3588: LD_VAR 0 4
3592: LESS
3593: IFFALSE 3605
// north := un ;
3595: LD_ADDR_VAR 0 4
3599: PUSH
3600: LD_VAR 0 3
3604: ST_TO_ADDR
// end ;
3605: GO 3497
3607: POP
3608: POP
// CenterOnXY ( x - 2 , y - 4 ) ;
3609: LD_VAR 0 5
3613: PUSH
3614: LD_INT 2
3616: MINUS
3617: PPUSH
3618: LD_VAR 0 6
3622: PUSH
3623: LD_INT 4
3625: MINUS
3626: PPUSH
3627: CALL_OW 84
// end ;
3631: LD_VAR 0 2
3635: RET
// every 0 0$1 trigger FilterUnitsInArea ( TopBorder , [ [ f_side , you ] ] ) do var un , car , list ;
3636: LD_INT 1
3638: PPUSH
3639: LD_INT 22
3641: PUSH
3642: LD_EXP 1
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: EMPTY
3652: LIST
3653: PPUSH
3654: CALL_OW 70
3658: IFFALSE 4014
3660: GO 3662
3662: DISABLE
3663: LD_INT 0
3665: PPUSH
3666: PPUSH
3667: PPUSH
// begin list := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3668: LD_ADDR_VAR 0 3
3672: PUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 22
3678: PUSH
3679: LD_EXP 1
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: PUSH
3688: LD_INT 21
3690: PUSH
3691: LD_INT 1
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PUSH
3698: LD_INT 50
3700: PUSH
3701: EMPTY
3702: LIST
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: PPUSH
3709: CALL_OW 70
3713: ST_TO_ADDR
// car := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
3714: LD_ADDR_VAR 0 2
3718: PUSH
3719: LD_INT 1
3721: PPUSH
3722: LD_INT 22
3724: PUSH
3725: LD_EXP 1
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 21
3736: PUSH
3737: LD_INT 2
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: LD_INT 50
3746: PUSH
3747: EMPTY
3748: LIST
3749: PUSH
3750: EMPTY
3751: LIST
3752: LIST
3753: LIST
3754: PPUSH
3755: CALL_OW 70
3759: ST_TO_ADDR
// for un in car do
3760: LD_ADDR_VAR 0 1
3764: PUSH
3765: LD_VAR 0 2
3769: PUSH
3770: FOR_IN
3771: IFFALSE 3807
// if IsDrivenBy ( un ) then
3773: LD_VAR 0 1
3777: PPUSH
3778: CALL_OW 311
3782: IFFALSE 3805
// list := list ^ IsDrivenBy ( un ) ;
3784: LD_ADDR_VAR 0 3
3788: PUSH
3789: LD_VAR 0 3
3793: PUSH
3794: LD_VAR 0 1
3798: PPUSH
3799: CALL_OW 311
3803: ADD
3804: ST_TO_ADDR
3805: GO 3770
3807: POP
3808: POP
// list := list union list ;
3809: LD_ADDR_VAR 0 3
3813: PUSH
3814: LD_VAR 0 3
3818: PUSH
3819: LD_VAR 0 3
3823: UNION
3824: ST_TO_ADDR
// list := list diff [ 0 , MacMillan ] ;
3825: LD_ADDR_VAR 0 3
3829: PUSH
3830: LD_VAR 0 3
3834: PUSH
3835: LD_INT 0
3837: PUSH
3838: LD_EXP 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: DIFF
3847: ST_TO_ADDR
// if Frank_Query = 1 then
3848: LD_EXP 47
3852: PUSH
3853: LD_INT 1
3855: EQUAL
3856: IFFALSE 3874
// list := list diff Frank ;
3858: LD_ADDR_VAR 0 3
3862: PUSH
3863: LD_VAR 0 3
3867: PUSH
3868: LD_EXP 11
3872: DIFF
3873: ST_TO_ADDR
// for un in list do
3874: LD_ADDR_VAR 0 1
3878: PUSH
3879: LD_VAR 0 3
3883: PUSH
3884: FOR_IN
3885: IFFALSE 3967
// begin car := IsInUnit ( un ) ;
3887: LD_ADDR_VAR 0 2
3891: PUSH
3892: LD_VAR 0 1
3896: PPUSH
3897: CALL_OW 310
3901: ST_TO_ADDR
// RemoveUnit ( un ) ;
3902: LD_VAR 0 1
3906: PPUSH
3907: CALL_OW 64
// if car then
3911: LD_VAR 0 2
3915: IFFALSE 3949
// begin if GetEngine ( car ) = engine_solar then
3917: LD_VAR 0 2
3921: PPUSH
3922: CALL_OW 262
3926: PUSH
3927: LD_INT 2
3929: EQUAL
3930: IFFALSE 3940
// solar_saved := true ;
3932: LD_ADDR_EXP 43
3936: PUSH
3937: LD_INT 1
3939: ST_TO_ADDR
// RemoveUnit ( car ) ;
3940: LD_VAR 0 2
3944: PPUSH
3945: CALL_OW 64
// end ; saved_units := saved_units union un ;
3949: LD_ADDR_EXP 17
3953: PUSH
3954: LD_EXP 17
3958: PUSH
3959: LD_VAR 0 1
3963: UNION
3964: ST_TO_ADDR
// end ;
3965: GO 3884
3967: POP
3968: POP
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) then
3969: LD_INT 22
3971: PUSH
3972: LD_EXP 1
3976: PUSH
3977: EMPTY
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 21
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 50
3993: PUSH
3994: EMPTY
3995: LIST
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: LIST
4001: PPUSH
4002: CALL_OW 69
4006: NOT
4007: IFFALSE 4013
// Konec_mise ;
4009: CALL 1512 0 0
// enable ;
4013: ENABLE
// end ; end_of_file
4014: PPOPN 3
4016: END
// export function run_ru_guarding ; begin
4017: LD_INT 0
4019: PPUSH
// enable ( 1 ) ;
4020: LD_INT 1
4022: ENABLE_MARKED
// end ;
4023: LD_VAR 0 1
4027: RET
// every 0 0$1 marked 1 do var i , south_guard_way ;
4028: GO 4030
4030: DISABLE
4031: LD_INT 0
4033: PPUSH
4034: PPUSH
// begin south_guard_way = [ 119 , 105 , 102 , 88 , 109 , 106 ] ;
4035: LD_ADDR_VAR 0 2
4039: PUSH
4040: LD_INT 119
4042: PUSH
4043: LD_INT 105
4045: PUSH
4046: LD_INT 102
4048: PUSH
4049: LD_INT 88
4051: PUSH
4052: LD_INT 109
4054: PUSH
4055: LD_INT 106
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: LIST
4062: LIST
4063: LIST
4064: LIST
4065: ST_TO_ADDR
// South_russian_patrol := [ s_guard1 , s_guard2 , s_guard3 , s_guard4 ] diff 0 ;
4066: LD_ADDR_EXP 28
4070: PUSH
4071: LD_EXP 50
4075: PUSH
4076: LD_EXP 51
4080: PUSH
4081: LD_EXP 52
4085: PUSH
4086: LD_EXP 53
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 0
4099: DIFF
4100: ST_TO_ADDR
// repeat for i = 1 to ( south_guard_way div 2 ) do
4101: LD_ADDR_VAR 0 1
4105: PUSH
4106: DOUBLE
4107: LD_INT 1
4109: DEC
4110: ST_TO_ADDR
4111: LD_VAR 0 2
4115: PUSH
4116: LD_INT 2
4118: DIV
4119: PUSH
4120: FOR_TO
4121: IFFALSE 4180
// begin AddComAgressiveMove ( South_russian_patrol , south_guard_way [ ( i * 2 ) - 1 ] , south_guard_way [ ( i * 2 ) ] ) ;
4123: LD_EXP 28
4127: PPUSH
4128: LD_VAR 0 2
4132: PUSH
4133: LD_VAR 0 1
4137: PUSH
4138: LD_INT 2
4140: MUL
4141: PUSH
4142: LD_INT 1
4144: MINUS
4145: ARRAY
4146: PPUSH
4147: LD_VAR 0 2
4151: PUSH
4152: LD_VAR 0 1
4156: PUSH
4157: LD_INT 2
4159: MUL
4160: ARRAY
4161: PPUSH
4162: CALL_OW 174
// AddComWait ( South_russian_patrol , 0 0$2 ) ;
4166: LD_EXP 28
4170: PPUSH
4171: LD_INT 70
4173: PPUSH
4174: CALL_OW 202
// end ;
4178: GO 4120
4180: POP
4181: POP
// repeat wait ( 0 0$2 ) ;
4182: LD_INT 70
4184: PPUSH
4185: CALL_OW 67
// until not ( IsBusy ( s_guard1 ) or IsBusy ( s_guard2 ) or IsBusy ( s_guard3 ) or IsBusy ( s_guard4 ) ) ;
4189: LD_EXP 50
4193: PPUSH
4194: CALL_OW 315
4198: PUSH
4199: LD_EXP 51
4203: PPUSH
4204: CALL_OW 315
4208: OR
4209: PUSH
4210: LD_EXP 52
4214: PPUSH
4215: CALL_OW 315
4219: OR
4220: PUSH
4221: LD_EXP 53
4225: PPUSH
4226: CALL_OW 315
4230: OR
4231: NOT
4232: IFFALSE 4182
// until not ( IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) ) ;
4234: LD_EXP 50
4238: PPUSH
4239: CALL_OW 302
4243: PUSH
4244: LD_EXP 50
4248: PPUSH
4249: CALL_OW 302
4253: OR
4254: PUSH
4255: LD_EXP 50
4259: PPUSH
4260: CALL_OW 302
4264: OR
4265: PUSH
4266: LD_EXP 50
4270: PPUSH
4271: CALL_OW 302
4275: OR
4276: NOT
4277: IFFALSE 4101
// end ;
4279: PPOPN 2
4281: END
// every 0 0$1 marked 1 do var x , y , truck_way , patroll ;
4282: GO 4284
4284: DISABLE
4285: LD_INT 0
4287: PPUSH
4288: PPUSH
4289: PPUSH
4290: PPUSH
// begin truck_way = [ 149 , 116 , 148 , 110 , 146 , 107 , 141 , 102 , 132 , 96 , 127 , 91 , 123 , 85 , 122 , 80 , 127 , 76 , 130 , 68 , 129 , 63 , 124 , 55 , 117 , 47 , 116 , 36 , 114 , 28 , 0 , 114 , 28 , 116 , 36 , 117 , 47 , 124 , 55 , 129 , 63 , 130 , 68 , 127 , 76 , 122 , 80 , 123 , 85 , 127 , 91 , 132 , 96 , 141 , 102 , 146 , 107 , 148 , 110 , - 1 ] ;
4291: LD_ADDR_VAR 0 3
4295: PUSH
4296: LD_INT 149
4298: PUSH
4299: LD_INT 116
4301: PUSH
4302: LD_INT 148
4304: PUSH
4305: LD_INT 110
4307: PUSH
4308: LD_INT 146
4310: PUSH
4311: LD_INT 107
4313: PUSH
4314: LD_INT 141
4316: PUSH
4317: LD_INT 102
4319: PUSH
4320: LD_INT 132
4322: PUSH
4323: LD_INT 96
4325: PUSH
4326: LD_INT 127
4328: PUSH
4329: LD_INT 91
4331: PUSH
4332: LD_INT 123
4334: PUSH
4335: LD_INT 85
4337: PUSH
4338: LD_INT 122
4340: PUSH
4341: LD_INT 80
4343: PUSH
4344: LD_INT 127
4346: PUSH
4347: LD_INT 76
4349: PUSH
4350: LD_INT 130
4352: PUSH
4353: LD_INT 68
4355: PUSH
4356: LD_INT 129
4358: PUSH
4359: LD_INT 63
4361: PUSH
4362: LD_INT 124
4364: PUSH
4365: LD_INT 55
4367: PUSH
4368: LD_INT 117
4370: PUSH
4371: LD_INT 47
4373: PUSH
4374: LD_INT 116
4376: PUSH
4377: LD_INT 36
4379: PUSH
4380: LD_INT 114
4382: PUSH
4383: LD_INT 28
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: LD_INT 114
4391: PUSH
4392: LD_INT 28
4394: PUSH
4395: LD_INT 116
4397: PUSH
4398: LD_INT 36
4400: PUSH
4401: LD_INT 117
4403: PUSH
4404: LD_INT 47
4406: PUSH
4407: LD_INT 124
4409: PUSH
4410: LD_INT 55
4412: PUSH
4413: LD_INT 129
4415: PUSH
4416: LD_INT 63
4418: PUSH
4419: LD_INT 130
4421: PUSH
4422: LD_INT 68
4424: PUSH
4425: LD_INT 127
4427: PUSH
4428: LD_INT 76
4430: PUSH
4431: LD_INT 122
4433: PUSH
4434: LD_INT 80
4436: PUSH
4437: LD_INT 123
4439: PUSH
4440: LD_INT 85
4442: PUSH
4443: LD_INT 127
4445: PUSH
4446: LD_INT 91
4448: PUSH
4449: LD_INT 132
4451: PUSH
4452: LD_INT 96
4454: PUSH
4455: LD_INT 141
4457: PUSH
4458: LD_INT 102
4460: PUSH
4461: LD_INT 146
4463: PUSH
4464: LD_INT 107
4466: PUSH
4467: LD_INT 148
4469: PUSH
4470: LD_INT 110
4472: PUSH
4473: LD_INT 1
4475: NEG
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: LIST
4488: LIST
4489: LIST
4490: LIST
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: ST_TO_ADDR
// patroll := ru_trucks [ 8 ] ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: LD_EXP 48
4548: PUSH
4549: LD_INT 8
4551: ARRAY
4552: ST_TO_ADDR
// repeat x := - 1 ;
4553: LD_ADDR_VAR 0 1
4557: PUSH
4558: LD_INT 1
4560: NEG
4561: ST_TO_ADDR
// for y in truck_way do
4562: LD_ADDR_VAR 0 2
4566: PUSH
4567: LD_VAR 0 3
4571: PUSH
4572: FOR_IN
4573: IFFALSE 4664
// case y of - 1 , 0 :
4575: LD_VAR 0 2
4579: PUSH
4580: LD_INT 1
4582: NEG
4583: DOUBLE
4584: EQUAL
4585: IFTRUE 4595
4587: LD_INT 0
4589: DOUBLE
4590: EQUAL
4591: IFTRUE 4595
4593: GO 4610
4595: POP
// AddComWait ( patroll , 0 0$5 ) ; else
4596: LD_VAR 0 4
4600: PPUSH
4601: LD_INT 175
4603: PPUSH
4604: CALL_OW 202
4608: GO 4662
4610: POP
// if x = - 1 then
4611: LD_VAR 0 1
4615: PUSH
4616: LD_INT 1
4618: NEG
4619: EQUAL
4620: IFFALSE 4634
// x := y else
4622: LD_ADDR_VAR 0 1
4626: PUSH
4627: LD_VAR 0 2
4631: ST_TO_ADDR
4632: GO 4662
// begin AddComAgressiveMove ( patroll , x , y ) ;
4634: LD_VAR 0 4
4638: PPUSH
4639: LD_VAR 0 1
4643: PPUSH
4644: LD_VAR 0 2
4648: PPUSH
4649: CALL_OW 174
// x := - 1 ;
4653: LD_ADDR_VAR 0 1
4657: PUSH
4658: LD_INT 1
4660: NEG
4661: ST_TO_ADDR
// end ; end ;
4662: GO 4572
4664: POP
4665: POP
// repeat if See ( you , patroll ) and See ( russians , MacMillan ) then
4666: LD_EXP 1
4670: PPUSH
4671: LD_VAR 0 4
4675: PPUSH
4676: CALL_OW 292
4680: PUSH
4681: LD_EXP 2
4685: PPUSH
4686: LD_EXP 7
4690: PPUSH
4691: CALL_OW 292
4695: AND
4696: IFFALSE 4783
// repeat if See ( russians , MacMillan ) then
4698: LD_EXP 2
4702: PPUSH
4703: LD_EXP 7
4707: PPUSH
4708: CALL_OW 292
4712: IFFALSE 4743
// ComAgressiveMove ( patroll , GetX ( MacMillan ) , GetY ( MacMillan ) ) ;
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_EXP 7
4723: PPUSH
4724: CALL_OW 250
4728: PPUSH
4729: LD_EXP 7
4733: PPUSH
4734: CALL_OW 251
4738: PPUSH
4739: CALL_OW 114
// wait ( 0 0$1 ) ;
4743: LD_INT 35
4745: PPUSH
4746: CALL_OW 67
// until not ( See ( russians , MacMillan ) or See ( russians , Bobby ) ) ;
4750: LD_EXP 2
4754: PPUSH
4755: LD_EXP 7
4759: PPUSH
4760: CALL_OW 292
4764: PUSH
4765: LD_EXP 2
4769: PPUSH
4770: LD_EXP 4
4774: PPUSH
4775: CALL_OW 292
4779: OR
4780: NOT
4781: IFFALSE 4698
// wait ( 0 0$1 ) ;
4783: LD_INT 35
4785: PPUSH
4786: CALL_OW 67
// until not IsBusy ( patroll ) ;
4790: LD_VAR 0 4
4794: PPUSH
4795: CALL_OW 315
4799: NOT
4800: IFFALSE 4666
// if ( atack = 1 and GetSide ( patroll ) = russians ) then
4802: LD_EXP 16
4806: PUSH
4807: LD_INT 1
4809: EQUAL
4810: PUSH
4811: LD_VAR 0 4
4815: PPUSH
4816: CALL_OW 255
4820: PUSH
4821: LD_EXP 2
4825: EQUAL
4826: AND
4827: IFFALSE 4846
// repeat wait ( 0 0$2 ) ;
4829: LD_INT 70
4831: PPUSH
4832: CALL_OW 67
// until atack = 0 ;
4836: LD_EXP 16
4840: PUSH
4841: LD_INT 0
4843: EQUAL
4844: IFFALSE 4829
// until not IsOK ( patroll ) ;
4846: LD_VAR 0 4
4850: PPUSH
4851: CALL_OW 302
4855: NOT
4856: IFFALSE 4553
// end ;
4858: PPOPN 4
4860: END
// every 0 0$1 marked 1 do var x , y , forest_way1 ;
4861: GO 4863
4863: DISABLE
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
4868: PPUSH
// begin forest_way1 = [ 27 , 45 , - 1 , 38 , 49 , 40 , 34 , - 1 , - 1 , 38 , 49 , 27 , 45 , - 1 ] ;
4869: LD_ADDR_VAR 0 3
4873: PUSH
4874: LD_INT 27
4876: PUSH
4877: LD_INT 45
4879: PUSH
4880: LD_INT 1
4882: NEG
4883: PUSH
4884: LD_INT 38
4886: PUSH
4887: LD_INT 49
4889: PUSH
4890: LD_INT 40
4892: PUSH
4893: LD_INT 34
4895: PUSH
4896: LD_INT 1
4898: NEG
4899: PUSH
4900: LD_INT 1
4902: NEG
4903: PUSH
4904: LD_INT 38
4906: PUSH
4907: LD_INT 49
4909: PUSH
4910: LD_INT 27
4912: PUSH
4913: LD_INT 45
4915: PUSH
4916: LD_INT 1
4918: NEG
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: LIST
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: LIST
4935: ST_TO_ADDR
// repeat x := - 1 ;
4936: LD_ADDR_VAR 0 1
4940: PUSH
4941: LD_INT 1
4943: NEG
4944: ST_TO_ADDR
// for y in forest_way1 do
4945: LD_ADDR_VAR 0 2
4949: PUSH
4950: LD_VAR 0 3
4954: PUSH
4955: FOR_IN
4956: IFFALSE 5041
// case y of - 1 :
4958: LD_VAR 0 2
4962: PUSH
4963: LD_INT 1
4965: NEG
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 4987
4972: POP
// AddComWait ( forest_force1 , 0 0$2 ) ; else
4973: LD_EXP 29
4977: PPUSH
4978: LD_INT 70
4980: PPUSH
4981: CALL_OW 202
4985: GO 5039
4987: POP
// if x = - 1 then
4988: LD_VAR 0 1
4992: PUSH
4993: LD_INT 1
4995: NEG
4996: EQUAL
4997: IFFALSE 5011
// x := y else
4999: LD_ADDR_VAR 0 1
5003: PUSH
5004: LD_VAR 0 2
5008: ST_TO_ADDR
5009: GO 5039
// begin AddComAgressiveMove ( forest_force1 , x , y ) ;
5011: LD_EXP 29
5015: PPUSH
5016: LD_VAR 0 1
5020: PPUSH
5021: LD_VAR 0 2
5025: PPUSH
5026: CALL_OW 174
// x := - 1 ;
5030: LD_ADDR_VAR 0 1
5034: PUSH
5035: LD_INT 1
5037: NEG
5038: ST_TO_ADDR
// end ; end ;
5039: GO 4955
5041: POP
5042: POP
// repeat wait ( 0 0$2 ) ;
5043: LD_INT 70
5045: PPUSH
5046: CALL_OW 67
// until not ( IsBusy ( forest11 ) or IsBusy ( forest12 ) ) ;
5050: LD_INT 26
5052: PPUSH
5053: CALL_OW 315
5057: PUSH
5058: LD_INT 25
5060: PPUSH
5061: CALL_OW 315
5065: OR
5066: NOT
5067: IFFALSE 5043
// until not ( IsOK ( forest11 ) or IsOK ( forest12 ) ) ;
5069: LD_INT 26
5071: PPUSH
5072: CALL_OW 302
5076: PUSH
5077: LD_INT 25
5079: PPUSH
5080: CALL_OW 302
5084: OR
5085: NOT
5086: IFFALSE 4936
// end ;
5088: PPOPN 3
5090: END
// every 0 0$1 marked 1 do var x , y , forest_way2 ;
5091: GO 5093
5093: DISABLE
5094: LD_INT 0
5096: PPUSH
5097: PPUSH
5098: PPUSH
// begin forest_way2 = [ 38 , 29 , - 1 , 39 , 50 , 53 , 57 , 55 , 39 , - 1 ] ;
5099: LD_ADDR_VAR 0 3
5103: PUSH
5104: LD_INT 38
5106: PUSH
5107: LD_INT 29
5109: PUSH
5110: LD_INT 1
5112: NEG
5113: PUSH
5114: LD_INT 39
5116: PUSH
5117: LD_INT 50
5119: PUSH
5120: LD_INT 53
5122: PUSH
5123: LD_INT 57
5125: PUSH
5126: LD_INT 55
5128: PUSH
5129: LD_INT 39
5131: PUSH
5132: LD_INT 1
5134: NEG
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: LIST
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: ST_TO_ADDR
// repeat x := - 1 ;
5148: LD_ADDR_VAR 0 1
5152: PUSH
5153: LD_INT 1
5155: NEG
5156: ST_TO_ADDR
// for y in forest_way2 do
5157: LD_ADDR_VAR 0 2
5161: PUSH
5162: LD_VAR 0 3
5166: PUSH
5167: FOR_IN
5168: IFFALSE 5253
// case y of - 1 :
5170: LD_VAR 0 2
5174: PUSH
5175: LD_INT 1
5177: NEG
5178: DOUBLE
5179: EQUAL
5180: IFTRUE 5184
5182: GO 5199
5184: POP
// AddComWait ( forest_force2 , 0 0$2 ) ; else
5185: LD_EXP 30
5189: PPUSH
5190: LD_INT 70
5192: PPUSH
5193: CALL_OW 202
5197: GO 5251
5199: POP
// if x = - 1 then
5200: LD_VAR 0 1
5204: PUSH
5205: LD_INT 1
5207: NEG
5208: EQUAL
5209: IFFALSE 5223
// x := y else
5211: LD_ADDR_VAR 0 1
5215: PUSH
5216: LD_VAR 0 2
5220: ST_TO_ADDR
5221: GO 5251
// begin AddComAgressiveMove ( forest_force2 , x , y ) ;
5223: LD_EXP 30
5227: PPUSH
5228: LD_VAR 0 1
5232: PPUSH
5233: LD_VAR 0 2
5237: PPUSH
5238: CALL_OW 174
// x := - 1 ;
5242: LD_ADDR_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: NEG
5250: ST_TO_ADDR
// end ; end ;
5251: GO 5167
5253: POP
5254: POP
// repeat Wait ( 0 0$2 ) ;
5255: LD_INT 70
5257: PPUSH
5258: CALL_OW 67
// until not ( IsBusy ( forest21 ) or IsBusy ( forest22 ) ) ;
5262: LD_INT 41
5264: PPUSH
5265: CALL_OW 315
5269: PUSH
5270: LD_INT 42
5272: PPUSH
5273: CALL_OW 315
5277: OR
5278: NOT
5279: IFFALSE 5255
// until not ( IsOK ( forest21 ) or IsOK ( forest22 ) ) ;
5281: LD_INT 41
5283: PPUSH
5284: CALL_OW 302
5288: PUSH
5289: LD_INT 42
5291: PPUSH
5292: CALL_OW 302
5296: OR
5297: NOT
5298: IFFALSE 5148
// end ;
5300: PPOPN 3
5302: END
// every 0 0$1 marked 1 do var x , y , grass_way1 ;
5303: GO 5305
5305: DISABLE
5306: LD_INT 0
5308: PPUSH
5309: PPUSH
5310: PPUSH
// begin grass_force1 = [ grass_11 , grass_12 ] ;
5311: LD_ADDR_EXP 31
5315: PUSH
5316: LD_INT 21
5318: PUSH
5319: LD_INT 22
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: ST_TO_ADDR
// grass_way1 = [ 77 , 67 , - 1 , 83 , 56 , - 1 , 65 , 49 , - 1 ] ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_INT 77
5333: PUSH
5334: LD_INT 67
5336: PUSH
5337: LD_INT 1
5339: NEG
5340: PUSH
5341: LD_INT 83
5343: PUSH
5344: LD_INT 56
5346: PUSH
5347: LD_INT 1
5349: NEG
5350: PUSH
5351: LD_INT 65
5353: PUSH
5354: LD_INT 49
5356: PUSH
5357: LD_INT 1
5359: NEG
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: LIST
5368: LIST
5369: LIST
5370: LIST
5371: ST_TO_ADDR
// repeat x := - 1 ;
5372: LD_ADDR_VAR 0 1
5376: PUSH
5377: LD_INT 1
5379: NEG
5380: ST_TO_ADDR
// for y in grass_way1 do
5381: LD_ADDR_VAR 0 2
5385: PUSH
5386: LD_VAR 0 3
5390: PUSH
5391: FOR_IN
5392: IFFALSE 5503
// case y of - 1 :
5394: LD_VAR 0 2
5398: PUSH
5399: LD_INT 1
5401: NEG
5402: DOUBLE
5403: EQUAL
5404: IFTRUE 5408
5406: GO 5423
5408: POP
// AddComWait ( grass_force1 , 0 0$2 ) ; else
5409: LD_EXP 31
5413: PPUSH
5414: LD_INT 70
5416: PPUSH
5417: CALL_OW 202
5421: GO 5501
5423: POP
// if x = - 1 then
5424: LD_VAR 0 1
5428: PUSH
5429: LD_INT 1
5431: NEG
5432: EQUAL
5433: IFFALSE 5447
// x := y else
5435: LD_ADDR_VAR 0 1
5439: PUSH
5440: LD_VAR 0 2
5444: ST_TO_ADDR
5445: GO 5501
// begin AddComAgressiveMove ( grass_force1 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5447: LD_EXP 31
5451: PPUSH
5452: LD_VAR 0 1
5456: PUSH
5457: LD_INT 1
5459: NEG
5460: PPUSH
5461: LD_INT 1
5463: PPUSH
5464: CALL_OW 12
5468: PLUS
5469: PPUSH
5470: LD_VAR 0 2
5474: PUSH
5475: LD_INT 1
5477: NEG
5478: PPUSH
5479: LD_INT 1
5481: PPUSH
5482: CALL_OW 12
5486: PLUS
5487: PPUSH
5488: CALL_OW 174
// x := - 1 ;
5492: LD_ADDR_VAR 0 1
5496: PUSH
5497: LD_INT 1
5499: NEG
5500: ST_TO_ADDR
// end ; end ;
5501: GO 5391
5503: POP
5504: POP
// repeat Wait ( 0 0$2 ) ;
5505: LD_INT 70
5507: PPUSH
5508: CALL_OW 67
// until not ( IsBusy ( grass_11 ) or IsBusy ( grass_12 ) ) ;
5512: LD_INT 21
5514: PPUSH
5515: CALL_OW 315
5519: PUSH
5520: LD_INT 22
5522: PPUSH
5523: CALL_OW 315
5527: OR
5528: NOT
5529: IFFALSE 5505
// until not ( IsOK ( grass_11 ) or IsOK ( grass_12 ) ) ;
5531: LD_INT 21
5533: PPUSH
5534: CALL_OW 302
5538: PUSH
5539: LD_INT 22
5541: PPUSH
5542: CALL_OW 302
5546: OR
5547: NOT
5548: IFFALSE 5372
// end ;
5550: PPOPN 3
5552: END
// every 0 0$1 marked 1 do var x , y , grass_way2 ;
5553: GO 5555
5555: DISABLE
5556: LD_INT 0
5558: PPUSH
5559: PPUSH
5560: PPUSH
// begin grass_force2 = [ grass_21 , grass_22 ] ;
5561: LD_ADDR_EXP 32
5565: PUSH
5566: LD_INT 23
5568: PUSH
5569: LD_INT 24
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: ST_TO_ADDR
// grass_way2 = [ 129 , 64 , - 1 , 127 , 75 , - 1 , 104 , 62 , - 1 ] ;
5576: LD_ADDR_VAR 0 3
5580: PUSH
5581: LD_INT 129
5583: PUSH
5584: LD_INT 64
5586: PUSH
5587: LD_INT 1
5589: NEG
5590: PUSH
5591: LD_INT 127
5593: PUSH
5594: LD_INT 75
5596: PUSH
5597: LD_INT 1
5599: NEG
5600: PUSH
5601: LD_INT 104
5603: PUSH
5604: LD_INT 62
5606: PUSH
5607: LD_INT 1
5609: NEG
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: ST_TO_ADDR
// repeat x := - 1 ;
5622: LD_ADDR_VAR 0 1
5626: PUSH
5627: LD_INT 1
5629: NEG
5630: ST_TO_ADDR
// for y in grass_way2 do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: LD_VAR 0 3
5640: PUSH
5641: FOR_IN
5642: IFFALSE 5753
// case y of - 1 :
5644: LD_VAR 0 2
5648: PUSH
5649: LD_INT 1
5651: NEG
5652: DOUBLE
5653: EQUAL
5654: IFTRUE 5658
5656: GO 5673
5658: POP
// AddComWait ( grass_force2 , 0 0$2 ) ; else
5659: LD_EXP 32
5663: PPUSH
5664: LD_INT 70
5666: PPUSH
5667: CALL_OW 202
5671: GO 5751
5673: POP
// if x = - 1 then
5674: LD_VAR 0 1
5678: PUSH
5679: LD_INT 1
5681: NEG
5682: EQUAL
5683: IFFALSE 5697
// x := y else
5685: LD_ADDR_VAR 0 1
5689: PUSH
5690: LD_VAR 0 2
5694: ST_TO_ADDR
5695: GO 5751
// begin AddComAgressiveMove ( grass_force2 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5697: LD_EXP 32
5701: PPUSH
5702: LD_VAR 0 1
5706: PUSH
5707: LD_INT 1
5709: NEG
5710: PPUSH
5711: LD_INT 1
5713: PPUSH
5714: CALL_OW 12
5718: PLUS
5719: PPUSH
5720: LD_VAR 0 2
5724: PUSH
5725: LD_INT 1
5727: NEG
5728: PPUSH
5729: LD_INT 1
5731: PPUSH
5732: CALL_OW 12
5736: PLUS
5737: PPUSH
5738: CALL_OW 174
// x := - 1 ;
5742: LD_ADDR_VAR 0 1
5746: PUSH
5747: LD_INT 1
5749: NEG
5750: ST_TO_ADDR
// end ; end ;
5751: GO 5641
5753: POP
5754: POP
// repeat Wait ( 0 0$2 ) ;
5755: LD_INT 70
5757: PPUSH
5758: CALL_OW 67
// until not ( IsBusy ( grass_21 ) or IsBusy ( grass_22 ) ) ;
5762: LD_INT 23
5764: PPUSH
5765: CALL_OW 315
5769: PUSH
5770: LD_INT 24
5772: PPUSH
5773: CALL_OW 315
5777: OR
5778: NOT
5779: IFFALSE 5755
// until not ( IsOK ( grass_21 ) or IsOK ( grass_22 ) ) ;
5781: LD_INT 23
5783: PPUSH
5784: CALL_OW 302
5788: PUSH
5789: LD_INT 24
5791: PPUSH
5792: CALL_OW 302
5796: OR
5797: NOT
5798: IFFALSE 5622
// end ;
5800: PPOPN 3
5802: END
// every 0 0$1 marked 1 do var x , y , grass_way3 ;
5803: GO 5805
5805: DISABLE
5806: LD_INT 0
5808: PPUSH
5809: PPUSH
5810: PPUSH
// begin grass_force3 = [ grass_31 , grass_32 , grass_33 ] ;
5811: LD_ADDR_EXP 33
5815: PUSH
5816: LD_EXP 60
5820: PUSH
5821: LD_EXP 61
5825: PUSH
5826: LD_EXP 62
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: LIST
5835: ST_TO_ADDR
// grass_way3 = [ 73 , 39 , - 1 , 81 , 50 , 88 , 37 , - 1 ] ;
5836: LD_ADDR_VAR 0 3
5840: PUSH
5841: LD_INT 73
5843: PUSH
5844: LD_INT 39
5846: PUSH
5847: LD_INT 1
5849: NEG
5850: PUSH
5851: LD_INT 81
5853: PUSH
5854: LD_INT 50
5856: PUSH
5857: LD_INT 88
5859: PUSH
5860: LD_INT 37
5862: PUSH
5863: LD_INT 1
5865: NEG
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: LIST
5876: ST_TO_ADDR
// repeat x := - 1 ;
5877: LD_ADDR_VAR 0 1
5881: PUSH
5882: LD_INT 1
5884: NEG
5885: ST_TO_ADDR
// for y in grass_way3 do
5886: LD_ADDR_VAR 0 2
5890: PUSH
5891: LD_VAR 0 3
5895: PUSH
5896: FOR_IN
5897: IFFALSE 6008
// case y of - 1 :
5899: LD_VAR 0 2
5903: PUSH
5904: LD_INT 1
5906: NEG
5907: DOUBLE
5908: EQUAL
5909: IFTRUE 5913
5911: GO 5928
5913: POP
// AddComWait ( grass_force3 , 0 0$2 ) ; else
5914: LD_EXP 33
5918: PPUSH
5919: LD_INT 70
5921: PPUSH
5922: CALL_OW 202
5926: GO 6006
5928: POP
// if x = - 1 then
5929: LD_VAR 0 1
5933: PUSH
5934: LD_INT 1
5936: NEG
5937: EQUAL
5938: IFFALSE 5952
// x := y else
5940: LD_ADDR_VAR 0 1
5944: PUSH
5945: LD_VAR 0 2
5949: ST_TO_ADDR
5950: GO 6006
// begin AddComMoveXY ( grass_force3 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5952: LD_EXP 33
5956: PPUSH
5957: LD_VAR 0 1
5961: PUSH
5962: LD_INT 1
5964: NEG
5965: PPUSH
5966: LD_INT 1
5968: PPUSH
5969: CALL_OW 12
5973: PLUS
5974: PPUSH
5975: LD_VAR 0 2
5979: PUSH
5980: LD_INT 1
5982: NEG
5983: PPUSH
5984: LD_INT 1
5986: PPUSH
5987: CALL_OW 12
5991: PLUS
5992: PPUSH
5993: CALL_OW 171
// x := - 1 ;
5997: LD_ADDR_VAR 0 1
6001: PUSH
6002: LD_INT 1
6004: NEG
6005: ST_TO_ADDR
// end ; end ;
6006: GO 5896
6008: POP
6009: POP
// repeat Wait ( 0 0$2 ) ;
6010: LD_INT 70
6012: PPUSH
6013: CALL_OW 67
// until not ( IsBusy ( grass_31 ) or IsBusy ( grass_32 ) or IsBusy ( grass_33 ) ) ;
6017: LD_EXP 60
6021: PPUSH
6022: CALL_OW 315
6026: PUSH
6027: LD_EXP 61
6031: PPUSH
6032: CALL_OW 315
6036: OR
6037: PUSH
6038: LD_EXP 62
6042: PPUSH
6043: CALL_OW 315
6047: OR
6048: NOT
6049: IFFALSE 6010
// until not ( IsOK ( grass_31 ) or IsOK ( grass_32 ) or IsOK ( grass_33 ) ) ;
6051: LD_EXP 60
6055: PPUSH
6056: CALL_OW 302
6060: PUSH
6061: LD_EXP 61
6065: PPUSH
6066: CALL_OW 302
6070: OR
6071: PUSH
6072: LD_EXP 62
6076: PPUSH
6077: CALL_OW 302
6081: OR
6082: NOT
6083: IFFALSE 5877
// end ;
6085: PPOPN 3
6087: END
// export function attack_began ; var i , truck_in_battle , russians_trucks , vozidlo ; begin
6088: LD_INT 0
6090: PPUSH
6091: PPUSH
6092: PPUSH
6093: PPUSH
6094: PPUSH
// ComRemember ( ru_trucks ) ;
6095: LD_EXP 48
6099: PPUSH
6100: CALL_OW 143
// ComAgressiveMove ( ru_trucks , 118 , 3 ) ;
6104: LD_EXP 48
6108: PPUSH
6109: LD_INT 118
6111: PPUSH
6112: LD_INT 3
6114: PPUSH
6115: CALL_OW 114
// repeat truck_in_battle := FilterUnitsInArea ( battlefield , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6119: LD_ADDR_VAR 0 3
6123: PUSH
6124: LD_INT 6
6126: PPUSH
6127: LD_INT 22
6129: PUSH
6130: LD_EXP 2
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PUSH
6139: LD_INT 21
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PPUSH
6153: CALL_OW 70
6157: ST_TO_ADDR
// for vozidlo in truck_in_battle do
6158: LD_ADDR_VAR 0 5
6162: PUSH
6163: LD_VAR 0 3
6167: PUSH
6168: FOR_IN
6169: IFFALSE 6182
// RemoveUnit ( vozidlo ) ;
6171: LD_VAR 0 5
6175: PPUSH
6176: CALL_OW 64
6180: GO 6168
6182: POP
6183: POP
// wait ( 0 0$1 ) ;
6184: LD_INT 35
6186: PPUSH
6187: CALL_OW 67
// i := false ;
6191: LD_ADDR_VAR 0 2
6195: PUSH
6196: LD_INT 0
6198: ST_TO_ADDR
// for vozidlo in ru_trucks do
6199: LD_ADDR_VAR 0 5
6203: PUSH
6204: LD_EXP 48
6208: PUSH
6209: FOR_IN
6210: IFFALSE 6235
// i := i or IsOK ( vozidlo ) ;
6212: LD_ADDR_VAR 0 2
6216: PUSH
6217: LD_VAR 0 2
6221: PUSH
6222: LD_VAR 0 5
6226: PPUSH
6227: CALL_OW 302
6231: OR
6232: ST_TO_ADDR
6233: GO 6209
6235: POP
6236: POP
// until not i ;
6237: LD_VAR 0 2
6241: NOT
6242: IFFALSE 6119
// repeat Wait ( 0 0$10 ) ;
6244: LD_INT 350
6246: PPUSH
6247: CALL_OW 67
// until not atack ;
6251: LD_EXP 16
6255: NOT
6256: IFFALSE 6244
// repeat for vozidlo in ru_trucks do
6258: LD_ADDR_VAR 0 5
6262: PUSH
6263: LD_EXP 48
6267: PUSH
6268: FOR_IN
6269: IFFALSE 6300
// if not IsOK ( vozidlo ) then
6271: LD_VAR 0 5
6275: PPUSH
6276: CALL_OW 302
6280: NOT
6281: IFFALSE 6298
// PlaceUnitArea ( vozidlo , battlefield , false ) ;
6283: LD_VAR 0 5
6287: PPUSH
6288: LD_INT 6
6290: PPUSH
6291: LD_INT 0
6293: PPUSH
6294: CALL_OW 49
6298: GO 6268
6300: POP
6301: POP
// ComReturn ( ru_trucks ) ;
6302: LD_EXP 48
6306: PPUSH
6307: CALL_OW 144
// wait ( 0 0$1 ) ;
6311: LD_INT 35
6313: PPUSH
6314: CALL_OW 67
// i := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6318: LD_ADDR_VAR 0 2
6322: PUSH
6323: LD_INT 22
6325: PUSH
6326: LD_EXP 2
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 21
6337: PUSH
6338: LD_INT 2
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: ST_TO_ADDR
// until not ( ru_trucks diff i ) ;
6354: LD_EXP 48
6358: PUSH
6359: LD_VAR 0 2
6363: DIFF
6364: NOT
6365: IFFALSE 6258
// end ;
6367: LD_VAR 0 1
6371: RET
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) or ( TICK > [ 15 15$0 , 10 10$0 , 5 5$0 ] [ difficulty ] ) marked 2 do var liv , ran , list , un , agresors , min_time , max_time ;
6372: LD_EXP 7
6376: PPUSH
6377: LD_INT 2
6379: PPUSH
6380: CALL_OW 308
6384: PUSH
6385: LD_OWVAR 1
6389: PUSH
6390: LD_INT 31500
6392: PUSH
6393: LD_INT 21000
6395: PUSH
6396: LD_INT 10500
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: PUSH
6404: LD_OWVAR 67
6408: ARRAY
6409: GREATER
6410: OR
6411: IFFALSE 7367
6413: GO 6415
6415: DISABLE
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
6421: PPUSH
6422: PPUSH
6423: PPUSH
6424: PPUSH
// begin min_time := [ 4 4$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
6425: LD_ADDR_VAR 0 6
6429: PUSH
6430: LD_INT 8400
6432: PUSH
6433: LD_INT 4200
6435: PUSH
6436: LD_INT 0
6438: PUSH
6439: EMPTY
6440: LIST
6441: LIST
6442: LIST
6443: PUSH
6444: LD_OWVAR 67
6448: ARRAY
6449: ST_TO_ADDR
// max_time := [ 8 8$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
6450: LD_ADDR_VAR 0 7
6454: PUSH
6455: LD_INT 16800
6457: PUSH
6458: LD_INT 8400
6460: PUSH
6461: LD_INT 4200
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: PUSH
6469: LD_OWVAR 67
6473: ARRAY
6474: ST_TO_ADDR
// ran := Rand ( min_time , max_time ) ;
6475: LD_ADDR_VAR 0 2
6479: PUSH
6480: LD_VAR 0 6
6484: PPUSH
6485: LD_VAR 0 7
6489: PPUSH
6490: CALL_OW 12
6494: ST_TO_ADDR
// Wait ( ran ) ;
6495: LD_VAR 0 2
6499: PPUSH
6500: CALL_OW 67
// ComAgressiveMove ( [ patrol1 , patrol2 ] , 130 , 68 ) ;
6504: LD_INT 14
6506: PUSH
6507: LD_INT 15
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: PPUSH
6514: LD_INT 130
6516: PPUSH
6517: LD_INT 68
6519: PPUSH
6520: CALL_OW 114
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 124 , 102 ) ;
6524: LD_INT 14
6526: PUSH
6527: LD_INT 15
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PPUSH
6534: LD_INT 124
6536: PPUSH
6537: LD_INT 102
6539: PPUSH
6540: CALL_OW 174
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 66 , 100 ) ;
6544: LD_INT 14
6546: PUSH
6547: LD_INT 15
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: PPUSH
6554: LD_INT 66
6556: PPUSH
6557: LD_INT 100
6559: PPUSH
6560: CALL_OW 174
// wait ( 0 0$15 ) ;
6564: LD_INT 525
6566: PPUSH
6567: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , [ f_class , class_soldier ] , f_not , [ f_side , russians ] ] ) ;
6571: LD_ADDR_VAR 0 3
6575: PUSH
6576: LD_INT 4
6578: PPUSH
6579: LD_INT 21
6581: PUSH
6582: LD_INT 1
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: PUSH
6589: LD_INT 25
6591: PUSH
6592: LD_INT 1
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: PUSH
6599: LD_INT 3
6601: PUSH
6602: LD_INT 22
6604: PUSH
6605: LD_EXP 2
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: PPUSH
6620: CALL_OW 70
6624: ST_TO_ADDR
// for un in list do
6625: LD_ADDR_VAR 0 4
6629: PUSH
6630: LD_VAR 0 3
6634: PUSH
6635: FOR_IN
6636: IFFALSE 6654
// PriorityAttack ( russians , un ) ;
6638: LD_EXP 2
6642: PPUSH
6643: LD_VAR 0 4
6647: PPUSH
6648: CALL_OW 470
6652: GO 6635
6654: POP
6655: POP
// repeat wait ( 15 ) ;
6656: LD_INT 15
6658: PPUSH
6659: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , f_not , [ f_side , russians ] , f_not , [ f_nation , nation_nature ] ] ) ;
6663: LD_ADDR_VAR 0 3
6667: PUSH
6668: LD_INT 4
6670: PPUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 1
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: LD_INT 3
6683: PUSH
6684: LD_INT 22
6686: PUSH
6687: LD_EXP 2
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: PUSH
6696: LD_INT 3
6698: PUSH
6699: LD_INT 23
6701: PUSH
6702: LD_INT 0
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 70
6720: ST_TO_ADDR
// agresors := [ ] ;
6721: LD_ADDR_VAR 0 5
6725: PUSH
6726: EMPTY
6727: ST_TO_ADDR
// if IsOK ( patrol1 ) then
6728: LD_INT 14
6730: PPUSH
6731: CALL_OW 302
6735: IFFALSE 6751
// agresors := agresors ^ patrol1 ;
6737: LD_ADDR_VAR 0 5
6741: PUSH
6742: LD_VAR 0 5
6746: PUSH
6747: LD_INT 14
6749: ADD
6750: ST_TO_ADDR
// if IsOK ( patrol2 ) then
6751: LD_INT 15
6753: PPUSH
6754: CALL_OW 302
6758: IFFALSE 6774
// agresors := agresors ^ patrol2 ;
6760: LD_ADDR_VAR 0 5
6764: PUSH
6765: LD_VAR 0 5
6769: PUSH
6770: LD_INT 15
6772: ADD
6773: ST_TO_ADDR
// if not agresors then
6774: LD_VAR 0 5
6778: NOT
6779: IFFALSE 6783
// exit ;
6781: GO 7367
// if list then
6783: LD_VAR 0 3
6787: IFFALSE 6828
// ComAgressiveMove ( agresors , GetX ( list [ 1 ] ) , GetY ( list [ 1 ] ) ) else
6789: LD_VAR 0 5
6793: PPUSH
6794: LD_VAR 0 3
6798: PUSH
6799: LD_INT 1
6801: ARRAY
6802: PPUSH
6803: CALL_OW 250
6807: PPUSH
6808: LD_VAR 0 3
6812: PUSH
6813: LD_INT 1
6815: ARRAY
6816: PPUSH
6817: CALL_OW 251
6821: PPUSH
6822: CALL_OW 114
6826: GO 6920
// begin list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_building ] ] ) ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 4
6835: PPUSH
6836: LD_INT 21
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PUSH
6846: EMPTY
6847: LIST
6848: PPUSH
6849: CALL_OW 70
6853: ST_TO_ADDR
// for un in list do
6854: LD_ADDR_VAR 0 4
6858: PUSH
6859: LD_VAR 0 3
6863: PUSH
6864: FOR_IN
6865: IFFALSE 6883
// PriorityAttack ( russians , un ) ;
6867: LD_EXP 2
6871: PPUSH
6872: LD_VAR 0 4
6876: PPUSH
6877: CALL_OW 470
6881: GO 6864
6883: POP
6884: POP
// if list then
6885: LD_VAR 0 3
6889: IFFALSE 6911
// ComAttackUnit ( agresors , list [ 1 ] ) else
6891: LD_VAR 0 5
6895: PPUSH
6896: LD_VAR 0 3
6900: PUSH
6901: LD_INT 1
6903: ARRAY
6904: PPUSH
6905: CALL_OW 115
6909: GO 6920
// begin YouLost ( 2 ) ;
6911: LD_STRING 2
6913: PPUSH
6914: CALL_OW 104
// exit ;
6918: GO 7367
// end ; end ; until ( GetDistUnits ( NearestUnitToUnit ( list , patrol1 ) , patrol1 ) < 9 ) or ( GetDistUnits ( NearestUnitToUnit ( list , patrol2 ) , patrol2 ) < 9 ) or ( GetLives ( patrol1 ) < 1000 ) or ( GetLives ( patrol2 ) < 1000 ) ;
6920: LD_VAR 0 3
6924: PPUSH
6925: LD_INT 14
6927: PPUSH
6928: CALL_OW 74
6932: PPUSH
6933: LD_INT 14
6935: PPUSH
6936: CALL_OW 296
6940: PUSH
6941: LD_INT 9
6943: LESS
6944: PUSH
6945: LD_VAR 0 3
6949: PPUSH
6950: LD_INT 15
6952: PPUSH
6953: CALL_OW 74
6957: PPUSH
6958: LD_INT 15
6960: PPUSH
6961: CALL_OW 296
6965: PUSH
6966: LD_INT 9
6968: LESS
6969: OR
6970: PUSH
6971: LD_INT 14
6973: PPUSH
6974: CALL_OW 256
6978: PUSH
6979: LD_INT 1000
6981: LESS
6982: OR
6983: PUSH
6984: LD_INT 15
6986: PPUSH
6987: CALL_OW 256
6991: PUSH
6992: LD_INT 1000
6994: LESS
6995: OR
6996: IFFALSE 6656
// CenterOnUnits ( [ patrol1 , patrol2 ] ) ;
6998: LD_INT 14
7000: PUSH
7001: LD_INT 15
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 85
// wait ( 200 - ( difficulty * 45 ) ) ;
7012: LD_INT 200
7014: PUSH
7015: LD_OWVAR 67
7019: PUSH
7020: LD_INT 45
7022: MUL
7023: MINUS
7024: PPUSH
7025: CALL_OW 67
// ComStop ( [ patrol1 , patrol2 ] ) ;
7029: LD_INT 14
7031: PUSH
7032: LD_INT 15
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PPUSH
7039: CALL_OW 141
// AddComMoveXY ( [ patrol1 , patrol2 ] , 84 , 71 ) ;
7043: LD_INT 14
7045: PUSH
7046: LD_INT 15
7048: PUSH
7049: EMPTY
7050: LIST
7051: LIST
7052: PPUSH
7053: LD_INT 84
7055: PPUSH
7056: LD_INT 71
7058: PPUSH
7059: CALL_OW 171
// AddComWait ( [ patrol1 , patrol2 ] , [ 0 0$6 , 0 0$4 , 0 0$2 ] [ difficulty ] ) ;
7063: LD_INT 14
7065: PUSH
7066: LD_INT 15
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: PPUSH
7073: LD_INT 210
7075: PUSH
7076: LD_INT 140
7078: PUSH
7079: LD_INT 70
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: CALL_OW 202
// AddComMoveXY ( [ patrol1 , patrol2 ] , 80 , 67 ) ;
7097: LD_INT 14
7099: PUSH
7100: LD_INT 15
7102: PUSH
7103: EMPTY
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 80
7109: PPUSH
7110: LD_INT 67
7112: PPUSH
7113: CALL_OW 171
// AddComMoveXY ( [ patrol1 , patrol2 ] , 45 , 22 ) ;
7117: LD_INT 14
7119: PUSH
7120: LD_INT 15
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PPUSH
7127: LD_INT 45
7129: PPUSH
7130: LD_INT 22
7132: PPUSH
7133: CALL_OW 171
// DialogueOn ;
7137: CALL_OW 6
// if IsOK ( patrol1 ) then
7141: LD_INT 14
7143: PPUSH
7144: CALL_OW 302
7148: IFFALSE 7162
// Say ( patrol1 , D8-Rus1-1 ) else
7150: LD_INT 14
7152: PPUSH
7153: LD_STRING D8-Rus1-1
7155: PPUSH
7156: CALL_OW 88
7160: GO 7172
// Say ( patrol2 , D8-Rus1-1 ) ;
7162: LD_INT 15
7164: PPUSH
7165: LD_STRING D8-Rus1-1
7167: PPUSH
7168: CALL_OW 88
// Say ( MacMillan , D8-JMM-1 ) ;
7172: LD_EXP 7
7176: PPUSH
7177: LD_STRING D8-JMM-1
7179: PPUSH
7180: CALL_OW 88
// DialogueOff ;
7184: CALL_OW 7
// ran := false ;
7188: LD_ADDR_VAR 0 2
7192: PUSH
7193: LD_INT 0
7195: ST_TO_ADDR
// repeat if ( not ran ) and ( ( IsOK ( patrol1 ) and ( GetY ( patrol1 ) < 60 ) ) or ( IsOK ( patrol2 ) and ( GetY ( patrol2 ) < 60 ) ) ) then
7196: LD_VAR 0 2
7200: NOT
7201: PUSH
7202: LD_INT 14
7204: PPUSH
7205: CALL_OW 302
7209: PUSH
7210: LD_INT 14
7212: PPUSH
7213: CALL_OW 251
7217: PUSH
7218: LD_INT 60
7220: LESS
7221: AND
7222: PUSH
7223: LD_INT 15
7225: PPUSH
7226: CALL_OW 302
7230: PUSH
7231: LD_INT 15
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 60
7241: LESS
7242: AND
7243: OR
7244: AND
7245: IFFALSE 7259
// begin ran := true ;
7247: LD_ADDR_VAR 0 2
7251: PUSH
7252: LD_INT 1
7254: ST_TO_ADDR
// talk_about_attack ;
7255: CALL 12747 0 0
// end ; Wait ( 0 0$1 ) ;
7259: LD_INT 35
7261: PPUSH
7262: CALL_OW 67
// until ( not ( IsOK ( patrol1 ) or IsOK ( patrol2 ) ) ) or ( IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) ) ;
7266: LD_INT 14
7268: PPUSH
7269: CALL_OW 302
7273: PUSH
7274: LD_INT 15
7276: PPUSH
7277: CALL_OW 302
7281: OR
7282: NOT
7283: PUSH
7284: LD_INT 14
7286: PPUSH
7287: LD_INT 7
7289: PPUSH
7290: CALL_OW 308
7294: PUSH
7295: LD_INT 15
7297: PPUSH
7298: LD_INT 7
7300: PPUSH
7301: CALL_OW 308
7305: OR
7306: OR
7307: IFFALSE 7196
// Dialogue_wait := true ;
7309: LD_ADDR_EXP 39
7313: PUSH
7314: LD_INT 1
7316: ST_TO_ADDR
// if IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) then
7317: LD_INT 14
7319: PPUSH
7320: LD_INT 7
7322: PPUSH
7323: CALL_OW 308
7327: PUSH
7328: LD_INT 15
7330: PPUSH
7331: LD_INT 7
7333: PPUSH
7334: CALL_OW 308
7338: OR
7339: IFFALSE 7347
// lets_destroy_americans else
7341: CALL 7370 0 0
7345: GO 7359
// Say ( MacMillan , D8a-JMM-1 ) ;
7347: LD_EXP 7
7351: PPUSH
7352: LD_STRING D8a-JMM-1
7354: PPUSH
7355: CALL_OW 88
// Dialogue_wait := false ;
7359: LD_ADDR_EXP 39
7363: PUSH
7364: LD_INT 0
7366: ST_TO_ADDR
// end ;
7367: PPOPN 7
7369: END
// function lets_destroy_americans ; var i , attackers1 , attackers2 ; begin
7370: LD_INT 0
7372: PPUSH
7373: PPUSH
7374: PPUSH
7375: PPUSH
// PriorityAttack ( russians , sklad ) ;
7376: LD_EXP 2
7380: PPUSH
7381: LD_INT 5
7383: PPUSH
7384: CALL_OW 470
// attackers1 := [ ] ;
7388: LD_ADDR_VAR 0 3
7392: PUSH
7393: EMPTY
7394: ST_TO_ADDR
// attackers2 := [ ] ;
7395: LD_ADDR_VAR 0 4
7399: PUSH
7400: EMPTY
7401: ST_TO_ADDR
// for i in ru_trucks do
7402: LD_ADDR_VAR 0 2
7406: PUSH
7407: LD_EXP 48
7411: PUSH
7412: FOR_IN
7413: IFFALSE 7471
// if ( 0 + attackers1 ) > ( 0 + attackers2 ) then
7415: LD_INT 0
7417: PUSH
7418: LD_VAR 0 3
7422: PLUS
7423: PUSH
7424: LD_INT 0
7426: PUSH
7427: LD_VAR 0 4
7431: PLUS
7432: GREATER
7433: IFFALSE 7453
// attackers2 := attackers2 ^ i else
7435: LD_ADDR_VAR 0 4
7439: PUSH
7440: LD_VAR 0 4
7444: PUSH
7445: LD_VAR 0 2
7449: ADD
7450: ST_TO_ADDR
7451: GO 7469
// attackers1 := attackers1 ^ i ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_VAR 0 3
7462: PUSH
7463: LD_VAR 0 2
7467: ADD
7468: ST_TO_ADDR
7469: GO 7412
7471: POP
7472: POP
// ComRemember ( attackers1 ) ;
7473: LD_VAR 0 3
7477: PPUSH
7478: CALL_OW 143
// ComRemember ( attackers2 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: CALL_OW 143
// Attack_US_Base ( attackers1 , attackers2 ) ;
7491: LD_VAR 0 3
7495: PPUSH
7496: LD_VAR 0 4
7500: PPUSH
7501: CALL 7639 0 2
// wait ( 0 0$4 ) ;
7505: LD_INT 140
7507: PPUSH
7508: CALL_OW 67
// ComReturn ( attackers1 ) ;
7512: LD_VAR 0 3
7516: PPUSH
7517: CALL_OW 144
// ComReturn ( attackers2 ) ;
7521: LD_VAR 0 4
7525: PPUSH
7526: CALL_OW 144
// end ;
7530: LD_VAR 0 1
7534: RET
// every 0 0$15 do var un ;
7535: GO 7537
7537: DISABLE
7538: LD_INT 0
7540: PPUSH
// begin for un in ru_trucks do
7541: LD_ADDR_VAR 0 1
7545: PUSH
7546: LD_EXP 48
7550: PUSH
7551: FOR_IN
7552: IFFALSE 7633
// if ( GetFuel ( un ) < 80 ) and ( not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , un , 10 ] ] ) ) then
7554: LD_VAR 0 1
7558: PPUSH
7559: CALL_OW 261
7563: PUSH
7564: LD_INT 80
7566: LESS
7567: PUSH
7568: LD_INT 22
7570: PUSH
7571: LD_EXP 1
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: LD_INT 21
7582: PUSH
7583: LD_INT 1
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: LD_INT 91
7592: PUSH
7593: LD_VAR 0 1
7597: PUSH
7598: LD_INT 10
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: LIST
7610: PPUSH
7611: CALL_OW 69
7615: NOT
7616: AND
7617: IFFALSE 7631
// SetFuel ( un , 100 ) ;
7619: LD_VAR 0 1
7623: PPUSH
7624: LD_INT 100
7626: PPUSH
7627: CALL_OW 240
7631: GO 7551
7633: POP
7634: POP
// enable ;
7635: ENABLE
// end ;
7636: PPOPN 1
7638: END
// function Attack_US_Base ( forces , backup ) ; var un , list , danger , time , driver , attack , retreat , repair ; begin
7639: LD_INT 0
7641: PPUSH
7642: PPUSH
7643: PPUSH
7644: PPUSH
7645: PPUSH
7646: PPUSH
7647: PPUSH
7648: PPUSH
7649: PPUSH
// ComAgressiveMove ( forces , 97 , 69 ) ;
7650: LD_VAR 0 1
7654: PPUSH
7655: LD_INT 97
7657: PPUSH
7658: LD_INT 69
7660: PPUSH
7661: CALL_OW 114
// wait ( 0 0$15 ) ;
7665: LD_INT 525
7667: PPUSH
7668: CALL_OW 67
// attack := forces ;
7672: LD_ADDR_VAR 0 9
7676: PUSH
7677: LD_VAR 0 1
7681: ST_TO_ADDR
// driver := [ ] ;
7682: LD_ADDR_VAR 0 8
7686: PUSH
7687: EMPTY
7688: ST_TO_ADDR
// repair := [ ] ;
7689: LD_ADDR_VAR 0 11
7693: PUSH
7694: EMPTY
7695: ST_TO_ADDR
// danger := false ;
7696: LD_ADDR_VAR 0 6
7700: PUSH
7701: LD_INT 0
7703: ST_TO_ADDR
// time := TICK ;
7704: LD_ADDR_VAR 0 7
7708: PUSH
7709: LD_OWVAR 1
7713: ST_TO_ADDR
// repeat ComAgressiveMove ( attack , 65 , 100 ) ;
7714: LD_VAR 0 9
7718: PPUSH
7719: LD_INT 65
7721: PPUSH
7722: LD_INT 100
7724: PPUSH
7725: CALL_OW 114
// for un in forces do
7729: LD_ADDR_VAR 0 4
7733: PUSH
7734: LD_VAR 0 1
7738: PUSH
7739: FOR_IN
7740: IFFALSE 7843
// begin if ( GetLives ( un ) < 600 ) and ( un in attack ) then
7742: LD_VAR 0 4
7746: PPUSH
7747: CALL_OW 256
7751: PUSH
7752: LD_INT 600
7754: LESS
7755: PUSH
7756: LD_VAR 0 4
7760: PUSH
7761: LD_VAR 0 9
7765: IN
7766: AND
7767: IFFALSE 7813
// begin attack := attack diff un ;
7769: LD_ADDR_VAR 0 9
7773: PUSH
7774: LD_VAR 0 9
7778: PUSH
7779: LD_VAR 0 4
7783: DIFF
7784: ST_TO_ADDR
// retreat := retreat ^ un ;
7785: LD_ADDR_VAR 0 10
7789: PUSH
7790: LD_VAR 0 10
7794: PUSH
7795: LD_VAR 0 4
7799: ADD
7800: ST_TO_ADDR
// ComMoveToArea ( un , ru_repair ) ;
7801: LD_VAR 0 4
7805: PPUSH
7806: LD_INT 27
7808: PPUSH
7809: CALL_OW 113
// end ; if not IsLive ( un ) then
7813: LD_VAR 0 4
7817: PPUSH
7818: CALL_OW 300
7822: NOT
7823: IFFALSE 7841
// forces := forces diff un ;
7825: LD_ADDR_VAR 0 1
7829: PUSH
7830: LD_VAR 0 1
7834: PUSH
7835: LD_VAR 0 4
7839: DIFF
7840: ST_TO_ADDR
// end ;
7841: GO 7739
7843: POP
7844: POP
// for un in retreat do
7845: LD_ADDR_VAR 0 4
7849: PUSH
7850: LD_VAR 0 10
7854: PUSH
7855: FOR_IN
7856: IFFALSE 7920
// if IsInArea ( un , ru_repair ) then
7858: LD_VAR 0 4
7862: PPUSH
7863: LD_INT 27
7865: PPUSH
7866: CALL_OW 308
7870: IFFALSE 7906
// begin retreat := retreat diff un ;
7872: LD_ADDR_VAR 0 10
7876: PUSH
7877: LD_VAR 0 10
7881: PUSH
7882: LD_VAR 0 4
7886: DIFF
7887: ST_TO_ADDR
// repair := repair ^ un ;
7888: LD_ADDR_VAR 0 11
7892: PUSH
7893: LD_VAR 0 11
7897: PUSH
7898: LD_VAR 0 4
7902: ADD
7903: ST_TO_ADDR
// end else
7904: GO 7918
// ComMoveToArea ( un , ru_repair ) ;
7906: LD_VAR 0 4
7910: PPUSH
7911: LD_INT 27
7913: PPUSH
7914: CALL_OW 113
7918: GO 7855
7920: POP
7921: POP
// for un in repair do
7922: LD_ADDR_VAR 0 4
7926: PUSH
7927: LD_VAR 0 11
7931: PUSH
7932: FOR_IN
7933: IFFALSE 7972
// if ( GetLives ( un ) < 1000 ) and IsDrivenBy ( un ) then
7935: LD_VAR 0 4
7939: PPUSH
7940: CALL_OW 256
7944: PUSH
7945: LD_INT 1000
7947: LESS
7948: PUSH
7949: LD_VAR 0 4
7953: PPUSH
7954: CALL_OW 311
7958: AND
7959: IFFALSE 7970
// ComExitVehicle ( un ) ;
7961: LD_VAR 0 4
7965: PPUSH
7966: CALL_OW 121
7970: GO 7932
7972: POP
7973: POP
// list = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] , f_not , [ f_lives , 1000 ] ] ) ;
7974: LD_ADDR_VAR 0 5
7978: PUSH
7979: LD_INT 28
7981: PPUSH
7982: LD_INT 22
7984: PUSH
7985: LD_EXP 2
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 21
7996: PUSH
7997: LD_INT 2
7999: PUSH
8000: EMPTY
8001: LIST
8002: LIST
8003: PUSH
8004: LD_INT 3
8006: PUSH
8007: LD_INT 24
8009: PUSH
8010: LD_INT 1000
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: PPUSH
8023: CALL_OW 70
8027: ST_TO_ADDR
// driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
8028: LD_ADDR_VAR 0 8
8032: PUSH
8033: LD_INT 28
8035: PPUSH
8036: LD_INT 22
8038: PUSH
8039: LD_EXP 2
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 21
8050: PUSH
8051: LD_INT 1
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: PUSH
8058: LD_INT 25
8060: PUSH
8061: LD_INT 3
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: LIST
8072: PPUSH
8073: CALL_OW 70
8077: ST_TO_ADDR
// danger = FilterUnitsInArea ( repair_around , [ [ f_side , you ] , [ f_ok ] ] ) ;
8078: LD_ADDR_VAR 0 6
8082: PUSH
8083: LD_INT 28
8085: PPUSH
8086: LD_INT 22
8088: PUSH
8089: LD_EXP 1
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 50
8100: PUSH
8101: EMPTY
8102: LIST
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PPUSH
8108: CALL_OW 70
8112: ST_TO_ADDR
// if list and not danger then
8113: LD_VAR 0 5
8117: PUSH
8118: LD_VAR 0 6
8122: NOT
8123: AND
8124: IFFALSE 8146
// ComRepairVehicle ( driver , list [ 1 ] ) else
8126: LD_VAR 0 8
8130: PPUSH
8131: LD_VAR 0 5
8135: PUSH
8136: LD_INT 1
8138: ARRAY
8139: PPUSH
8140: CALL_OW 129
8144: GO 8268
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8146: LD_ADDR_VAR 0 5
8150: PUSH
8151: LD_INT 28
8153: PPUSH
8154: LD_INT 22
8156: PUSH
8157: LD_EXP 2
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: PUSH
8166: LD_INT 21
8168: PUSH
8169: LD_INT 2
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: PUSH
8176: EMPTY
8177: LIST
8178: LIST
8179: PPUSH
8180: CALL_OW 70
8184: ST_TO_ADDR
// for un = 1 to driver do
8185: LD_ADDR_VAR 0 4
8189: PUSH
8190: DOUBLE
8191: LD_INT 1
8193: DEC
8194: ST_TO_ADDR
8195: LD_VAR 0 8
8199: PUSH
8200: FOR_TO
8201: IFFALSE 8243
// if un <= list then
8203: LD_VAR 0 4
8207: PUSH
8208: LD_VAR 0 5
8212: LESSEQUAL
8213: IFFALSE 8241
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8215: LD_VAR 0 8
8219: PUSH
8220: LD_VAR 0 4
8224: ARRAY
8225: PPUSH
8226: LD_VAR 0 5
8230: PUSH
8231: LD_VAR 0 4
8235: ARRAY
8236: PPUSH
8237: CALL_OW 120
8241: GO 8200
8243: POP
8244: POP
// attack := attack union repair ;
8245: LD_ADDR_VAR 0 9
8249: PUSH
8250: LD_VAR 0 9
8254: PUSH
8255: LD_VAR 0 11
8259: UNION
8260: ST_TO_ADDR
// repair := [ ] ;
8261: LD_ADDR_VAR 0 11
8265: PUSH
8266: EMPTY
8267: ST_TO_ADDR
// end ; if not repair then
8268: LD_VAR 0 11
8272: NOT
8273: IFFALSE 8430
// begin driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
8275: LD_ADDR_VAR 0 8
8279: PUSH
8280: LD_INT 28
8282: PPUSH
8283: LD_INT 22
8285: PUSH
8286: LD_EXP 2
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 21
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: EMPTY
8302: LIST
8303: LIST
8304: PUSH
8305: LD_INT 25
8307: PUSH
8308: LD_INT 3
8310: PUSH
8311: EMPTY
8312: LIST
8313: LIST
8314: PUSH
8315: EMPTY
8316: LIST
8317: LIST
8318: LIST
8319: PPUSH
8320: CALL_OW 70
8324: ST_TO_ADDR
// if driver then
8325: LD_VAR 0 8
8329: IFFALSE 8430
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8331: LD_ADDR_VAR 0 5
8335: PUSH
8336: LD_INT 28
8338: PPUSH
8339: LD_INT 22
8341: PUSH
8342: LD_EXP 2
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PUSH
8351: LD_INT 21
8353: PUSH
8354: LD_INT 2
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PPUSH
8365: CALL_OW 70
8369: ST_TO_ADDR
// for un = 1 to driver do
8370: LD_ADDR_VAR 0 4
8374: PUSH
8375: DOUBLE
8376: LD_INT 1
8378: DEC
8379: ST_TO_ADDR
8380: LD_VAR 0 8
8384: PUSH
8385: FOR_TO
8386: IFFALSE 8428
// if un <= list then
8388: LD_VAR 0 4
8392: PUSH
8393: LD_VAR 0 5
8397: LESSEQUAL
8398: IFFALSE 8426
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8400: LD_VAR 0 8
8404: PUSH
8405: LD_VAR 0 4
8409: ARRAY
8410: PPUSH
8411: LD_VAR 0 5
8415: PUSH
8416: LD_VAR 0 4
8420: ARRAY
8421: PPUSH
8422: CALL_OW 120
8426: GO 8385
8428: POP
8429: POP
// end ; end ; if ( TICK > ( time + 5 5$0 ) ) and backup then
8430: LD_OWVAR 1
8434: PUSH
8435: LD_VAR 0 7
8439: PUSH
8440: LD_INT 10500
8442: PLUS
8443: GREATER
8444: PUSH
8445: LD_VAR 0 2
8449: AND
8450: IFFALSE 8470
// begin attack := backup ;
8452: LD_ADDR_VAR 0 9
8456: PUSH
8457: LD_VAR 0 2
8461: ST_TO_ADDR
// backup := false ;
8462: LD_ADDR_VAR 0 2
8466: PUSH
8467: LD_INT 0
8469: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
8470: LD_INT 35
8472: PPUSH
8473: CALL_OW 67
// until not forces ;
8477: LD_VAR 0 1
8481: NOT
8482: IFFALSE 7714
// end ; end_of_file
8484: LD_VAR 0 3
8488: RET
// export function starting_scene ; var sol1 , time ; begin
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// time := TICK ;
8494: LD_ADDR_VAR 0 3
8498: PUSH
8499: LD_OWVAR 1
8503: ST_TO_ADDR
// wait ( 0 0$1 ) ;
8504: LD_INT 35
8506: PPUSH
8507: CALL_OW 67
// if amtruck1 then
8511: LD_EXP 35
8515: IFFALSE 8528
// CenterOnUnits ( amtruck1 ) else
8517: LD_EXP 35
8521: PPUSH
8522: CALL_OW 85
8526: GO 8537
// CenterOnUnits ( MacMillan ) ;
8528: LD_EXP 7
8532: PPUSH
8533: CALL_OW 85
// InGameOn ;
8537: CALL_OW 8
// ComWait ( Kobra1 diff MacMillan , 0 0$0.8 ) ;
8541: LD_EXP 12
8545: PUSH
8546: LD_EXP 7
8550: DIFF
8551: PPUSH
8552: LD_INT 28
8554: PPUSH
8555: CALL_OW 142
// if amtruck1 then
8559: LD_EXP 35
8563: IFFALSE 8616
// begin ComMoveXY ( amtruck1 , 172 , 112 ) ;
8565: LD_EXP 35
8569: PPUSH
8570: LD_INT 172
8572: PPUSH
8573: LD_INT 112
8575: PPUSH
8576: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8580: LD_EXP 12
8584: PUSH
8585: LD_EXP 7
8589: DIFF
8590: PPUSH
8591: LD_EXP 35
8595: PPUSH
8596: CALL_OW 172
// ComTurnUnit ( cornells , amtruck1 ) ;
8600: LD_EXP 14
8604: PPUSH
8605: LD_EXP 35
8609: PPUSH
8610: CALL_OW 119
// end else
8614: GO 8665
// begin ComMoveXY ( MacMillan , 168 , 109 ) ;
8616: LD_EXP 7
8620: PPUSH
8621: LD_INT 168
8623: PPUSH
8624: LD_INT 109
8626: PPUSH
8627: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8631: LD_EXP 12
8635: PUSH
8636: LD_EXP 7
8640: DIFF
8641: PPUSH
8642: LD_EXP 35
8646: PPUSH
8647: CALL_OW 172
// ComTurnUnit ( cornells , MacMillan ) ;
8651: LD_EXP 14
8655: PPUSH
8656: LD_EXP 7
8660: PPUSH
8661: CALL_OW 119
// end ; if amtruck2 then
8665: LD_EXP 36
8669: IFFALSE 8695
// begin ComMoveXY ( amtruck2 , 164 , 110 ) ;
8671: LD_EXP 36
8675: PPUSH
8676: LD_INT 164
8678: PPUSH
8679: LD_INT 110
8681: PPUSH
8682: CALL_OW 111
// AddComExitVehicle ( amtruck2 ) ;
8686: LD_EXP 36
8690: PPUSH
8691: CALL_OW 181
// end ; ComMoveXY ( Cornell , 165 , 105 ) ;
8695: LD_EXP 8
8699: PPUSH
8700: LD_INT 165
8702: PPUSH
8703: LD_INT 105
8705: PPUSH
8706: CALL_OW 111
// wait ( 0 0$1.5 ) ;
8710: LD_INT 52
8712: PPUSH
8713: CALL_OW 67
// ComHold ( Kobra1 diff MacMillan ) ;
8717: LD_EXP 12
8721: PUSH
8722: LD_EXP 7
8726: DIFF
8727: PPUSH
8728: CALL_OW 140
// if amtruck1 then
8732: LD_EXP 35
8736: IFFALSE 8788
// begin repeat Wait ( 0 0$0.5 ) ;
8738: LD_INT 18
8740: PPUSH
8741: CALL_OW 67
// until not IsBusy ( amtruck1 ) ;
8745: LD_EXP 35
8749: PPUSH
8750: CALL_OW 315
8754: NOT
8755: IFFALSE 8738
// ComExitVehicle ( amtruck1 ) ;
8757: LD_EXP 35
8761: PPUSH
8762: CALL_OW 121
// wait ( 0 0$0.2 ) ;
8766: LD_INT 7
8768: PPUSH
8769: CALL_OW 67
// ComMoveXY ( MacMillan , 168 , 109 ) ;
8773: LD_EXP 7
8777: PPUSH
8778: LD_INT 168
8780: PPUSH
8781: LD_INT 109
8783: PPUSH
8784: CALL_OW 111
// end ; repeat Wait ( 0 0$0.5 ) ;
8788: LD_INT 18
8790: PPUSH
8791: CALL_OW 67
// until not IsBusy ( MacMillan ) ;
8795: LD_EXP 7
8799: PPUSH
8800: CALL_OW 315
8804: NOT
8805: IFFALSE 8788
// ComHold ( Kobra1 ) ;
8807: LD_EXP 12
8811: PPUSH
8812: CALL_OW 140
// ComTurnUnit ( MacMillan , Cornell ) ;
8816: LD_EXP 7
8820: PPUSH
8821: LD_EXP 8
8825: PPUSH
8826: CALL_OW 119
// ComTurnUnit ( Cornell , MacMillan ) ;
8830: LD_EXP 8
8834: PPUSH
8835: LD_EXP 7
8839: PPUSH
8840: CALL_OW 119
// Wait ( 0 0$1 ) ;
8844: LD_INT 35
8846: PPUSH
8847: CALL_OW 67
// InGameOff ;
8851: CALL_OW 9
// DialogueOn ;
8855: CALL_OW 6
// interface_hidden := true ;
8859: LD_ADDR_OWVAR 54
8863: PUSH
8864: LD_INT 1
8866: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
8867: LD_EXP 7
8871: PPUSH
8872: LD_STRING D1-JMM-1
8874: PPUSH
8875: CALL_OW 88
// Say ( Cornell , D1-Corn-1 ) ;
8879: LD_EXP 8
8883: PPUSH
8884: LD_STRING D1-Corn-1
8886: PPUSH
8887: CALL_OW 88
// ComStop ( cornells ) ;
8891: LD_EXP 14
8895: PPUSH
8896: CALL_OW 141
// Say ( MacMillan , D1-JMM-2 ) ;
8900: LD_EXP 7
8904: PPUSH
8905: LD_STRING D1-JMM-2
8907: PPUSH
8908: CALL_OW 88
// Say ( MacMillan , D1-JMM-2a ) ;
8912: LD_EXP 7
8916: PPUSH
8917: LD_STRING D1-JMM-2a
8919: PPUSH
8920: CALL_OW 88
// Say ( Cornell , D1-Corn-2 ) ;
8924: LD_EXP 8
8928: PPUSH
8929: LD_STRING D1-Corn-2
8931: PPUSH
8932: CALL_OW 88
// if IsOK ( Mikhail ) then
8936: LD_EXP 21
8940: PPUSH
8941: CALL_OW 302
8945: IFFALSE 9070
// begin Say ( Cornell , D1a-Corn-1 ) ;
8947: LD_EXP 8
8951: PPUSH
8952: LD_STRING D1a-Corn-1
8954: PPUSH
8955: CALL_OW 88
// Say ( MacMillan , D1a-JMM-1 ) ;
8959: LD_EXP 7
8963: PPUSH
8964: LD_STRING D1a-JMM-1
8966: PPUSH
8967: CALL_OW 88
// ComMoveXY ( Mikhail , 169 , 107 ) ;
8971: LD_EXP 21
8975: PPUSH
8976: LD_INT 169
8978: PPUSH
8979: LD_INT 107
8981: PPUSH
8982: CALL_OW 111
// Say ( Cornell , D1a-Corn-2 ) ;
8986: LD_EXP 8
8990: PPUSH
8991: LD_STRING D1a-Corn-2
8993: PPUSH
8994: CALL_OW 88
// Say ( MacMillan , D1a-JMM-2 ) ;
8998: LD_EXP 7
9002: PPUSH
9003: LD_STRING D1a-JMM-2
9005: PPUSH
9006: CALL_OW 88
// Say ( Cornell , D1a-Corn-3 ) ;
9010: LD_EXP 8
9014: PPUSH
9015: LD_STRING D1a-Corn-3
9017: PPUSH
9018: CALL_OW 88
// Say ( MacMillan , D1a-JMM-3 ) ;
9022: LD_EXP 7
9026: PPUSH
9027: LD_STRING D1a-JMM-3
9029: PPUSH
9030: CALL_OW 88
// Say ( Cornell , D1a-Corn-4 ) ;
9034: LD_EXP 8
9038: PPUSH
9039: LD_STRING D1a-Corn-4
9041: PPUSH
9042: CALL_OW 88
// Say ( MacMillan , D1a-JMM-4 ) ;
9046: LD_EXP 7
9050: PPUSH
9051: LD_STRING D1a-JMM-4
9053: PPUSH
9054: CALL_OW 88
// Say ( Cornell , D1a-Corn-5 ) ;
9058: LD_EXP 8
9062: PPUSH
9063: LD_STRING D1a-Corn-5
9065: PPUSH
9066: CALL_OW 88
// end ; Say ( MacMillan , D1b-JMM-1 ) ;
9070: LD_EXP 7
9074: PPUSH
9075: LD_STRING D1b-JMM-1
9077: PPUSH
9078: CALL_OW 88
// Say ( Cornell , D1b-Corn-1 ) ;
9082: LD_EXP 8
9086: PPUSH
9087: LD_STRING D1b-Corn-1
9089: PPUSH
9090: CALL_OW 88
// Say ( MacMillan , D1b-JMM-2 ) ;
9094: LD_EXP 7
9098: PPUSH
9099: LD_STRING D1b-JMM-2
9101: PPUSH
9102: CALL_OW 88
// Say ( Cornell , D1b-Corn-2 ) ;
9106: LD_EXP 8
9110: PPUSH
9111: LD_STRING D1b-Corn-2
9113: PPUSH
9114: CALL_OW 88
// Say ( MacMillan , D1b-JMM-3 ) ;
9118: LD_EXP 7
9122: PPUSH
9123: LD_STRING D1b-JMM-3
9125: PPUSH
9126: CALL_OW 88
// SayRadio ( Powell , D1b-Pow-3 ) ;
9130: LD_EXP 9
9134: PPUSH
9135: LD_STRING D1b-Pow-3
9137: PPUSH
9138: CALL_OW 94
// Say ( MacMillan , D1b-JMM-4 ) ;
9142: LD_EXP 7
9146: PPUSH
9147: LD_STRING D1b-JMM-4
9149: PPUSH
9150: CALL_OW 88
// Say ( Cornell , D1b-Corn-4 ) ;
9154: LD_EXP 8
9158: PPUSH
9159: LD_STRING D1b-Corn-4
9161: PPUSH
9162: CALL_OW 88
// if IsOK ( Khatam ) then
9166: LD_EXP 10
9170: PPUSH
9171: CALL_OW 302
9175: IFFALSE 9191
// Say ( Khatam , D1b-Khat-4 ) else
9177: LD_EXP 10
9181: PPUSH
9182: LD_STRING D1b-Khat-4
9184: PPUSH
9185: CALL_OW 88
9189: GO 9238
// begin sol1 := UnitFilter ( cornells , [ f_sex , sex_male ] ) ;
9191: LD_ADDR_VAR 0 2
9195: PUSH
9196: LD_EXP 14
9200: PPUSH
9201: LD_INT 26
9203: PUSH
9204: LD_INT 1
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PPUSH
9211: CALL_OW 72
9215: ST_TO_ADDR
// if sol1 then
9216: LD_VAR 0 2
9220: IFFALSE 9238
// Say ( sol1 [ 1 ] , D1b-Sol1-4 ) ;
9222: LD_VAR 0 2
9226: PUSH
9227: LD_INT 1
9229: ARRAY
9230: PPUSH
9231: LD_STRING D1b-Sol1-4
9233: PPUSH
9234: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
9238: LD_EXP 5
9242: PPUSH
9243: CALL_OW 302
9247: IFFALSE 9296
// begin Say ( Cyrus , D1b-Cyrus-4 ) ;
9249: LD_EXP 5
9253: PPUSH
9254: LD_STRING D1b-Cyrus-4
9256: PPUSH
9257: CALL_OW 88
// if IsOK ( Lisa ) then
9261: LD_EXP 6
9265: PPUSH
9266: CALL_OW 302
9270: IFFALSE 9296
// begin Say ( Lisa , D1b-Lisa-4 ) ;
9272: LD_EXP 6
9276: PPUSH
9277: LD_STRING D1b-Lisa-4
9279: PPUSH
9280: CALL_OW 88
// Say ( Cyrus , D1b-Cyrus-5 ) ;
9284: LD_EXP 5
9288: PPUSH
9289: LD_STRING D1b-Cyrus-5
9291: PPUSH
9292: CALL_OW 88
// end ; end ; SelectGroup ;
9296: CALL 9538 0 0
// interface_hidden := false ;
9300: LD_ADDR_OWVAR 54
9304: PUSH
9305: LD_INT 0
9307: ST_TO_ADDR
// DialogueOff ;
9308: CALL_OW 7
// InGameOn ;
9312: CALL_OW 8
// enable ( 4 ) ;
9316: LD_INT 4
9318: ENABLE_MARKED
// Say ( MacMillan , D1d-JMM-1 ) ;
9319: LD_EXP 7
9323: PPUSH
9324: LD_STRING D1d-JMM-1
9326: PPUSH
9327: CALL_OW 88
// Say ( Cornell , D1d-Corn-1 ) ;
9331: LD_EXP 8
9335: PPUSH
9336: LD_STRING D1d-Corn-1
9338: PPUSH
9339: CALL_OW 88
// SetSide ( Cornell , neutral ) ;
9343: LD_EXP 8
9347: PPUSH
9348: LD_EXP 3
9352: PPUSH
9353: CALL_OW 235
// if amtruck2 then
9357: LD_EXP 36
9361: IFFALSE 9412
// begin ComEnterUnit ( Cornell , amtruck2 ) ;
9363: LD_EXP 8
9367: PPUSH
9368: LD_EXP 36
9372: PPUSH
9373: CALL_OW 120
// repeat wait ( 0 0$1 ) until IsInUnit ( Cornell ) ;
9377: LD_INT 35
9379: PPUSH
9380: CALL_OW 67
9384: LD_EXP 8
9388: PPUSH
9389: CALL_OW 310
9393: IFFALSE 9377
// ComMoveXY ( amtruck2 , 166 , 95 ) ;
9395: LD_EXP 36
9399: PPUSH
9400: LD_INT 166
9402: PPUSH
9403: LD_INT 95
9405: PPUSH
9406: CALL_OW 111
// end else
9410: GO 9436
// begin ComStop ( Cornell ) ;
9412: LD_EXP 8
9416: PPUSH
9417: CALL_OW 141
// ComMoveXY ( Cornell , 166 , 95 ) ;
9421: LD_EXP 8
9425: PPUSH
9426: LD_INT 166
9428: PPUSH
9429: LD_INT 95
9431: PPUSH
9432: CALL_OW 111
// end ; SaveForQuickRestart ;
9436: CALL_OW 22
// enable ( 8 ) ;
9440: LD_INT 8
9442: ENABLE_MARKED
// enable ( 3 ) ;
9443: LD_INT 3
9445: ENABLE_MARKED
// wait ( 0 0$0.5 ) ;
9446: LD_INT 18
9448: PPUSH
9449: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
9453: LD_STRING M1
9455: PPUSH
9456: CALL_OW 337
// TICK := time ;
9460: LD_ADDR_OWVAR 1
9464: PUSH
9465: LD_VAR 0 3
9469: ST_TO_ADDR
// ComFree ( [ yours ] ) ;
9470: LD_EXP 15
9474: PUSH
9475: EMPTY
9476: LIST
9477: PPUSH
9478: CALL_OW 139
// InGameOff ;
9482: CALL_OW 9
// Wait ( 0 0$5 ) ;
9486: LD_INT 175
9488: PPUSH
9489: CALL_OW 67
// SetAttitude ( russians , you , att_enemy , true ) ;
9493: LD_EXP 2
9497: PPUSH
9498: LD_EXP 1
9502: PPUSH
9503: LD_INT 2
9505: PPUSH
9506: LD_INT 1
9508: PPUSH
9509: CALL_OW 80
// SetAttitude ( russians , neutral , att_enemy , true ) ;
9513: LD_EXP 2
9517: PPUSH
9518: LD_EXP 3
9522: PPUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 1
9528: PPUSH
9529: CALL_OW 80
// end ;
9533: LD_VAR 0 1
9537: RET
// function SelectGroup ; var units ; begin
9538: LD_INT 0
9540: PPUSH
9541: PPUSH
// units := [ MacMillan , sel_changeable ] ^ ( Kobra1 diff [ MacMillan , Mikhail ] ) ^ [ sel_not_hired , sel_not_changeable , Cornell , Mikhail ] ^ [ sel_changeable ] ^ cornells ;
9542: LD_ADDR_VAR 0 2
9546: PUSH
9547: LD_EXP 7
9551: PUSH
9552: LD_INT -3
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: LD_EXP 12
9563: PUSH
9564: LD_EXP 7
9568: PUSH
9569: LD_EXP 21
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: DIFF
9578: ADD
9579: PUSH
9580: LD_INT -2
9582: PUSH
9583: LD_INT -4
9585: PUSH
9586: LD_EXP 8
9590: PUSH
9591: LD_EXP 21
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: ADD
9602: PUSH
9603: LD_INT -3
9605: PUSH
9606: EMPTY
9607: LIST
9608: ADD
9609: PUSH
9610: LD_EXP 14
9614: ADD
9615: ST_TO_ADDR
// yours := MacMillan ^ CharacterSelection ( Select five characters to go with you , 5 , 5 , units , [ ] ) ;
9616: LD_ADDR_EXP 15
9620: PUSH
9621: LD_EXP 7
9625: PUSH
9626: LD_STRING Select five characters to go with you
9628: PPUSH
9629: LD_INT 5
9631: PPUSH
9632: LD_INT 5
9634: PPUSH
9635: LD_VAR 0 2
9639: PPUSH
9640: EMPTY
9641: PPUSH
9642: CALL_OW 42
9646: ADD
9647: ST_TO_ADDR
// Cornell_group := Kobra1 union cornells diff yours ;
9648: LD_ADDR_EXP 34
9652: PUSH
9653: LD_EXP 12
9657: PUSH
9658: LD_EXP 14
9662: UNION
9663: PUSH
9664: LD_EXP 15
9668: DIFF
9669: ST_TO_ADDR
// end ;
9670: LD_VAR 0 1
9674: RET
// every 0 0$0.5 marked 4 do var pom_replace , lidi_mimo , group_out ;
9675: GO 9677
9677: DISABLE
9678: LD_INT 0
9680: PPUSH
9681: PPUSH
9682: PPUSH
// begin group_out := Cornell_group diff Cornell ;
9683: LD_ADDR_VAR 0 3
9687: PUSH
9688: LD_EXP 34
9692: PUSH
9693: LD_EXP 8
9697: DIFF
9698: ST_TO_ADDR
// SetSide ( Cornell_group , neutral ) ;
9699: LD_EXP 34
9703: PPUSH
9704: LD_EXP 3
9708: PPUSH
9709: CALL_OW 235
// ComMoveXY ( Cornell_group diff Cornell , 165 , 93 ) ;
9713: LD_EXP 34
9717: PUSH
9718: LD_EXP 8
9722: DIFF
9723: PPUSH
9724: LD_INT 165
9726: PPUSH
9727: LD_INT 93
9729: PPUSH
9730: CALL_OW 111
// repeat lidi_mimo := FilterUnitsInArea ( Leaving , [ [ f_side , neutral ] ] ) ;
9734: LD_ADDR_VAR 0 2
9738: PUSH
9739: LD_INT 3
9741: PPUSH
9742: LD_INT 22
9744: PUSH
9745: LD_EXP 3
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PUSH
9754: EMPTY
9755: LIST
9756: PPUSH
9757: CALL_OW 70
9761: ST_TO_ADDR
// group_out := group_out diff lidi_mimo ;
9762: LD_ADDR_VAR 0 3
9766: PUSH
9767: LD_VAR 0 3
9771: PUSH
9772: LD_VAR 0 2
9776: DIFF
9777: ST_TO_ADDR
// if lidi_mimo then
9778: LD_VAR 0 2
9782: IFFALSE 9810
// for pom_replace in lidi_mimo do
9784: LD_ADDR_VAR 0 1
9788: PUSH
9789: LD_VAR 0 2
9793: PUSH
9794: FOR_IN
9795: IFFALSE 9808
// RemoveUnit ( pom_replace ) ;
9797: LD_VAR 0 1
9801: PPUSH
9802: CALL_OW 64
9806: GO 9794
9808: POP
9809: POP
// Wait ( 0 0$0.5 ) ;
9810: LD_INT 18
9812: PPUSH
9813: CALL_OW 67
// until not group_out ;
9817: LD_VAR 0 3
9821: NOT
9822: IFFALSE 9734
// end ;
9824: PPOPN 3
9826: END
// every 0 0$0.5 marked 8 do
9827: GO 9829
9829: DISABLE
// begin repeat if IsInUnit ( Cornell ) then
9830: LD_EXP 8
9834: PPUSH
9835: CALL_OW 310
9839: IFFALSE 9863
// ComMoveXY ( IsInUnit ( Cornell ) , 166 , 95 ) else
9841: LD_EXP 8
9845: PPUSH
9846: CALL_OW 310
9850: PPUSH
9851: LD_INT 166
9853: PPUSH
9854: LD_INT 95
9856: PPUSH
9857: CALL_OW 111
9861: GO 9878
// ComMoveXY ( Cornell , 166 , 95 ) ;
9863: LD_EXP 8
9867: PPUSH
9868: LD_INT 166
9870: PPUSH
9871: LD_INT 95
9873: PPUSH
9874: CALL_OW 111
// Wait ( 0 0$0.5 ) ;
9878: LD_INT 18
9880: PPUSH
9881: CALL_OW 67
// until not ( IsBusy ( Cornell ) or IsBusy ( IsInUnit ( Cornell ) ) ) ;
9885: LD_EXP 8
9889: PPUSH
9890: CALL_OW 315
9894: PUSH
9895: LD_EXP 8
9899: PPUSH
9900: CALL_OW 310
9904: PPUSH
9905: CALL_OW 315
9909: OR
9910: NOT
9911: IFFALSE 9830
// if IsInUnit ( Cornell ) then
9913: LD_EXP 8
9917: PPUSH
9918: CALL_OW 310
9922: IFFALSE 9940
// RemoveUnit ( IsInUnit ( Cornell ) ) else
9924: LD_EXP 8
9928: PPUSH
9929: CALL_OW 310
9933: PPUSH
9934: CALL_OW 64
9938: GO 9949
// RemoveUnit ( Cornell ) ;
9940: LD_EXP 8
9944: PPUSH
9945: CALL_OW 64
// enable ( 3 ) ;
9949: LD_INT 3
9951: ENABLE_MARKED
// end ;
9952: END
// var tick_after ; every 0 0$1 trigger IsInArea ( MacMillan , Meeting ) do
9953: LD_EXP 7
9957: PPUSH
9958: LD_INT 4
9960: PPUSH
9961: CALL_OW 308
9965: IFFALSE 10518
9967: GO 9969
9969: DISABLE
// begin SetSideBase ( GetBase ( sklad ) , you ) ;
9970: LD_INT 5
9972: PPUSH
9973: CALL_OW 274
9977: PPUSH
9978: LD_EXP 1
9982: PPUSH
9983: CALL_OW 236
// SetSide ( [ am1 , am2 , am4 , am5 ] , you ) ;
9987: LD_INT 2
9989: PUSH
9990: LD_INT 3
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: LD_INT 4
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: LIST
10004: PPUSH
10005: LD_EXP 1
10009: PPUSH
10010: CALL_OW 235
// RevealFogArea ( you , Am_Base ) ;
10014: LD_EXP 1
10018: PPUSH
10019: LD_INT 2
10021: PPUSH
10022: CALL_OW 332
// ComMoveUnit ( MacMillan , am1 ) ;
10026: LD_EXP 7
10030: PPUSH
10031: LD_INT 2
10033: PPUSH
10034: CALL_OW 112
// ComMoveUnit ( am1 , MacMillan ) ;
10038: LD_INT 2
10040: PPUSH
10041: LD_EXP 7
10045: PPUSH
10046: CALL_OW 112
// repeat Wait ( 0 0$0.5 ) ;
10050: LD_INT 18
10052: PPUSH
10053: CALL_OW 67
// until GetDistUnits ( MacMillan , am1 ) < 5 ;
10057: LD_EXP 7
10061: PPUSH
10062: LD_INT 2
10064: PPUSH
10065: CALL_OW 296
10069: PUSH
10070: LD_INT 5
10072: LESS
10073: IFFALSE 10050
// ComStop ( [ MacMillan , am1 ] ) ;
10075: LD_EXP 7
10079: PUSH
10080: LD_INT 2
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: PPUSH
10087: CALL_OW 141
// CenterOnUnits ( am1 ) ;
10091: LD_INT 2
10093: PPUSH
10094: CALL_OW 85
// ComTurnUnit ( MacMillan , am1 ) ;
10098: LD_EXP 7
10102: PPUSH
10103: LD_INT 2
10105: PPUSH
10106: CALL_OW 119
// ComTurnUnit ( am1 , MacMillan ) ;
10110: LD_INT 2
10112: PPUSH
10113: LD_EXP 7
10117: PPUSH
10118: CALL_OW 119
// ComHold ( [ am1 , am2 , am4 , am5 ] ) ;
10122: LD_INT 2
10124: PUSH
10125: LD_INT 3
10127: PUSH
10128: LD_INT 1
10130: PUSH
10131: LD_INT 4
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: PPUSH
10140: CALL_OW 140
// Wait ( 0 0$1 ) ;
10144: LD_INT 35
10146: PPUSH
10147: CALL_OW 67
// DialogueOn ;
10151: CALL_OW 6
// interface_hidden := true ;
10155: LD_ADDR_OWVAR 54
10159: PUSH
10160: LD_INT 1
10162: ST_TO_ADDR
// Say ( MacMillan , D2-JMM-1 ) ;
10163: LD_EXP 7
10167: PPUSH
10168: LD_STRING D2-JMM-1
10170: PPUSH
10171: CALL_OW 88
// Say ( am1 , D2-Sol1-1 ) ;
10175: LD_INT 2
10177: PPUSH
10178: LD_STRING D2-Sol1-1
10180: PPUSH
10181: CALL_OW 88
// Say ( MacMillan , D2-JMM-2 ) ;
10185: LD_EXP 7
10189: PPUSH
10190: LD_STRING D2-JMM-2
10192: PPUSH
10193: CALL_OW 88
// Say ( am1 , D2-Sol1-2 ) ;
10197: LD_INT 2
10199: PPUSH
10200: LD_STRING D2-Sol1-2
10202: PPUSH
10203: CALL_OW 88
// Say ( MacMillan , D2-JMM-3 ) ;
10207: LD_EXP 7
10211: PPUSH
10212: LD_STRING D2-JMM-3
10214: PPUSH
10215: CALL_OW 88
// Say ( am1 , D2-Sol1-3 ) ;
10219: LD_INT 2
10221: PPUSH
10222: LD_STRING D2-Sol1-3
10224: PPUSH
10225: CALL_OW 88
// Say ( MacMillan , D2-JMM-4 ) ;
10229: LD_EXP 7
10233: PPUSH
10234: LD_STRING D2-JMM-4
10236: PPUSH
10237: CALL_OW 88
// Say ( am1 , D2-Sol1-4 ) ;
10241: LD_INT 2
10243: PPUSH
10244: LD_STRING D2-Sol1-4
10246: PPUSH
10247: CALL_OW 88
// Say ( MacMillan , D2-JMM-5 ) ;
10251: LD_EXP 7
10255: PPUSH
10256: LD_STRING D2-JMM-5
10258: PPUSH
10259: CALL_OW 88
// async ;
10263: ASYNC
// Say ( am1 , D2-Sol1-5 ) ;
10264: LD_INT 2
10266: PPUSH
10267: LD_STRING D2-Sol1-5
10269: PPUSH
10270: CALL_OW 88
// sync ;
10274: SYNC
// RevealFogArea ( you , panika_1 ) ;
10275: LD_EXP 1
10279: PPUSH
10280: LD_INT 9
10282: PPUSH
10283: CALL_OW 332
// CenterOnXY ( 121 , 51 ) ;
10287: LD_INT 121
10289: PPUSH
10290: LD_INT 51
10292: PPUSH
10293: CALL_OW 84
// DWait ( 0 0$6 ) ;
10297: LD_INT 210
10299: PPUSH
10300: CALL_OW 68
// RevealFogArea ( you , panika_2 ) ;
10304: LD_EXP 1
10308: PPUSH
10309: LD_INT 10
10311: PPUSH
10312: CALL_OW 332
// CenterOnXY ( 90 , 36 ) ;
10316: LD_INT 90
10318: PPUSH
10319: LD_INT 36
10321: PPUSH
10322: CALL_OW 84
// DWait ( 0 0$3 ) ;
10326: LD_INT 105
10328: PPUSH
10329: CALL_OW 68
// async ;
10333: ASYNC
// Say ( MacMillan , D2-JMM-6 ) ;
10334: LD_EXP 7
10338: PPUSH
10339: LD_STRING D2-JMM-6
10341: PPUSH
10342: CALL_OW 88
// sync ;
10346: SYNC
// RevealFogArea ( you , panika_3 ) ;
10347: LD_EXP 1
10351: PPUSH
10352: LD_INT 11
10354: PPUSH
10355: CALL_OW 332
// CenterOnXY ( 58 , 33 ) ;
10359: LD_INT 58
10361: PPUSH
10362: LD_INT 33
10364: PPUSH
10365: CALL_OW 84
// DWait ( 0 0$3 ) ;
10369: LD_INT 105
10371: PPUSH
10372: CALL_OW 68
// RevealFogArea ( you , panika_4 ) ;
10376: LD_EXP 1
10380: PPUSH
10381: LD_INT 12
10383: PPUSH
10384: CALL_OW 332
// CenterOnXY ( 36 , 42 ) ;
10388: LD_INT 36
10390: PPUSH
10391: LD_INT 42
10393: PPUSH
10394: CALL_OW 84
// Say ( am1 , D2-Sol1-6 ) ;
10398: LD_INT 2
10400: PPUSH
10401: LD_STRING D2-Sol1-6
10403: PPUSH
10404: CALL_OW 88
// CenterOnUnits ( MacMillan ) ;
10408: LD_EXP 7
10412: PPUSH
10413: CALL_OW 85
// Say ( MacMillan , D2-JMM-7 ) ;
10417: LD_EXP 7
10421: PPUSH
10422: LD_STRING D2-JMM-7
10424: PPUSH
10425: CALL_OW 88
// Say ( am1 , D2-Sol1-7 ) ;
10429: LD_INT 2
10431: PPUSH
10432: LD_STRING D2-Sol1-7
10434: PPUSH
10435: CALL_OW 88
// Say ( MacMillan , D2-JMM-8 ) ;
10439: LD_EXP 7
10443: PPUSH
10444: LD_STRING D2-JMM-8
10446: PPUSH
10447: CALL_OW 88
// DialogueOff ;
10451: CALL_OW 7
// interface_hidden := false ;
10455: LD_ADDR_OWVAR 54
10459: PUSH
10460: LD_INT 0
10462: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
10463: LD_INT 2
10465: PUSH
10466: LD_INT 3
10468: PUSH
10469: LD_INT 1
10471: PUSH
10472: LD_INT 4
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: PPUSH
10481: CALL_OW 139
// ChangeMissionObjectives ( MOutCap ) ;
10485: LD_STRING MOutCap
10487: PPUSH
10488: CALL_OW 337
// ChangeMissionObjectives ( MSolar1 ) ;
10492: LD_STRING MSolar1
10494: PPUSH
10495: CALL_OW 337
// Hint ( BuildingBase ) ;
10499: LD_STRING BuildingBase
10501: PPUSH
10502: CALL_OW 339
// base_reached := true ;
10506: LD_ADDR_EXP 45
10510: PUSH
10511: LD_INT 1
10513: ST_TO_ADDR
// talk_about_shipments ;
10514: CALL 10519 0 0
// end ;
10518: END
// function talk_about_shipments ; var fin , m , n ; begin
10519: LD_INT 0
10521: PPUSH
10522: PPUSH
10523: PPUSH
10524: PPUSH
// fin := false ;
10525: LD_ADDR_VAR 0 2
10529: PUSH
10530: LD_INT 0
10532: ST_TO_ADDR
// while not GetResourceArea ( am_base , mat_cans ) do
10533: LD_INT 2
10535: PPUSH
10536: LD_INT 1
10538: PPUSH
10539: CALL_OW 287
10543: NOT
10544: IFFALSE 10555
// wait ( 0 0$3 ) ;
10546: LD_INT 105
10548: PPUSH
10549: CALL_OW 67
10553: GO 10533
// Hint ( Crates ) ;
10555: LD_STRING Crates
10557: PPUSH
10558: CALL_OW 339
// m := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10562: LD_ADDR_VAR 0 3
10566: PUSH
10567: LD_INT 5
10569: PPUSH
10570: CALL_OW 274
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: ST_TO_ADDR
// repeat n := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10583: LD_ADDR_VAR 0 4
10587: PUSH
10588: LD_INT 5
10590: PPUSH
10591: CALL_OW 274
10595: PPUSH
10596: LD_INT 1
10598: PPUSH
10599: CALL_OW 275
10603: ST_TO_ADDR
// if n > m then
10604: LD_VAR 0 4
10608: PUSH
10609: LD_VAR 0 3
10613: GREATER
10614: IFFALSE 10626
// fin := true else
10616: LD_ADDR_VAR 0 2
10620: PUSH
10621: LD_INT 1
10623: ST_TO_ADDR
10624: GO 10636
// m := n ;
10626: LD_ADDR_VAR 0 3
10630: PUSH
10631: LD_VAR 0 4
10635: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10636: LD_INT 35
10638: PPUSH
10639: CALL_OW 67
// until fin ;
10643: LD_VAR 0 2
10647: IFFALSE 10583
// wait ( 0 0$2 ) ;
10649: LD_INT 70
10651: PPUSH
10652: CALL_OW 67
// DisableExclamations ;
10656: CALL_OW 474
// DialogueOn ;
10660: CALL_OW 6
// interface_hidden := true ;
10664: LD_ADDR_OWVAR 54
10668: PUSH
10669: LD_INT 1
10671: ST_TO_ADDR
// Say ( MacMillan , D2a-JMM-1 ) ;
10672: LD_EXP 7
10676: PPUSH
10677: LD_STRING D2a-JMM-1
10679: PPUSH
10680: CALL_OW 88
// Say ( am5 , D2a-Sci1-1 ) ;
10684: LD_INT 4
10686: PPUSH
10687: LD_STRING D2a-Sci1-1
10689: PPUSH
10690: CALL_OW 88
// Say ( MacMillan , D2a-JMM-2 ) ;
10694: LD_EXP 7
10698: PPUSH
10699: LD_STRING D2a-JMM-2
10701: PPUSH
10702: CALL_OW 88
// Say ( am5 , D2a-Sci1-2 ) ;
10706: LD_INT 4
10708: PPUSH
10709: LD_STRING D2a-Sci1-2
10711: PPUSH
10712: CALL_OW 88
// Say ( MacMillan , D2a-JMM-3 ) ;
10716: LD_EXP 7
10720: PPUSH
10721: LD_STRING D2a-JMM-3
10723: PPUSH
10724: CALL_OW 88
// Say ( am5 , D2a-Sci1-3 ) ;
10728: LD_INT 4
10730: PPUSH
10731: LD_STRING D2a-Sci1-3
10733: PPUSH
10734: CALL_OW 88
// interface_hidden := false ;
10738: LD_ADDR_OWVAR 54
10742: PUSH
10743: LD_INT 0
10745: ST_TO_ADDR
// DialogueOff ;
10746: CALL_OW 7
// EnableExclamations ;
10750: CALL_OW 473
// enable ( 10 ) ;
10754: LD_INT 10
10756: ENABLE_MARKED
// enable ( 2 ) ;
10757: LD_INT 2
10759: ENABLE_MARKED
// end ;
10760: LD_VAR 0 1
10764: RET
// on VehicleConstructed ( vyrobene_auto , tovarna ) marked 10 do begin talk_about_first_car ;
10765: CALL 10790 0 0
// solar_constructed := true ;
10769: LD_ADDR_EXP 42
10773: PUSH
10774: LD_INT 1
10776: ST_TO_ADDR
// ChangeMissionObjectives ( MOutSol ) ;
10777: LD_STRING MOutSol
10779: PPUSH
10780: CALL_OW 337
// disable ( 10 ) ;
10784: LD_INT 10
10786: DISABLE_MARKED
// end ;
10787: PPOPN 2
10789: END
// function talk_about_first_car ; begin
10790: LD_INT 0
10792: PPUSH
// repeat wait ( 0 0$1 ) ;
10793: LD_INT 35
10795: PPUSH
10796: CALL_OW 67
// until not Dialogue_wait ;
10800: LD_EXP 39
10804: NOT
10805: IFFALSE 10793
// Wait ( 0 0$3 ) ;
10807: LD_INT 105
10809: PPUSH
10810: CALL_OW 67
// DialogueOn ;
10814: CALL_OW 6
// interface_hidden := true ;
10818: LD_ADDR_OWVAR 54
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// Hint ( Vehicle ) ;
10826: LD_STRING Vehicle
10828: PPUSH
10829: CALL_OW 339
// Say ( MacMillan , D2b-JMM-1 ) ;
10833: LD_EXP 7
10837: PPUSH
10838: LD_STRING D2b-JMM-1
10840: PPUSH
10841: CALL_OW 88
// if IsOK ( am5 ) then
10845: LD_INT 4
10847: PPUSH
10848: CALL_OW 302
10852: IFFALSE 10866
// Say ( am5 , D2b-Sci1-1 ) else
10854: LD_INT 4
10856: PPUSH
10857: LD_STRING D2b-Sci1-1
10859: PPUSH
10860: CALL_OW 88
10864: GO 10878
// Say ( Khatam , D2b-Sci1-1 ) ;
10866: LD_EXP 10
10870: PPUSH
10871: LD_STRING D2b-Sci1-1
10873: PPUSH
10874: CALL_OW 88
// Say ( MacMillan , D2b-JMM-2 ) ;
10878: LD_EXP 7
10882: PPUSH
10883: LD_STRING D2b-JMM-2
10885: PPUSH
10886: CALL_OW 88
// if IsOK ( am5 ) then
10890: LD_INT 4
10892: PPUSH
10893: CALL_OW 302
10897: IFFALSE 10911
// Say ( am5 , D2b-Sci1-2 ) else
10899: LD_INT 4
10901: PPUSH
10902: LD_STRING D2b-Sci1-2
10904: PPUSH
10905: CALL_OW 88
10909: GO 10923
// Say ( Khatam , D2b-Sci1-2 ) ;
10911: LD_EXP 10
10915: PPUSH
10916: LD_STRING D2b-Sci1-2
10918: PPUSH
10919: CALL_OW 88
// Say ( MacMillan , D2b-JMM-3 ) ;
10923: LD_EXP 7
10927: PPUSH
10928: LD_STRING D2b-JMM-3
10930: PPUSH
10931: CALL_OW 88
// interface_hidden := false ;
10935: LD_ADDR_OWVAR 54
10939: PUSH
10940: LD_INT 0
10942: ST_TO_ADDR
// DialogueOff ;
10943: CALL_OW 7
// enable ( 7 ) ;
10947: LD_INT 7
10949: ENABLE_MARKED
// end ;
10950: LD_VAR 0 1
10954: RET
// every 0 0$2 trigger GetEngine ( IsInUnit ( MacMillan ) ) = engine_solar marked 7 do
10955: LD_EXP 7
10959: PPUSH
10960: CALL_OW 310
10964: PPUSH
10965: CALL_OW 262
10969: PUSH
10970: LD_INT 2
10972: EQUAL
10973: IFFALSE 11016
10975: GO 10977
10977: DISABLE
// begin DisableExclamations ;
10978: CALL_OW 474
// Say ( MacMillan , D2c-JMM-1 ) ;
10982: LD_EXP 7
10986: PPUSH
10987: LD_STRING D2c-JMM-1
10989: PPUSH
10990: CALL_OW 88
// if JMMinvehicle then
10994: LD_EXP 19
10998: IFFALSE 11012
// Say ( MacMillan , D2c-JMM-1a ) ;
11000: LD_EXP 7
11004: PPUSH
11005: LD_STRING D2c-JMM-1a
11007: PPUSH
11008: CALL_OW 88
// EnableExclamations ;
11012: CALL_OW 473
// end ;
11016: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Lisa ) ) = engine_solar marked 7 do
11017: LD_EXP 6
11021: PPUSH
11022: CALL_OW 310
11026: PPUSH
11027: CALL_OW 262
11031: PUSH
11032: LD_INT 2
11034: EQUAL
11035: IFFALSE 11209
11037: GO 11039
11039: DISABLE
// begin Wait ( 0 0$2 ) ;
11040: LD_INT 70
11042: PPUSH
11043: CALL_OW 67
// EnableExclamations ;
11047: CALL_OW 473
// async ;
11051: ASYNC
// Say ( Lisa , D2c-Lisa-1 ) ;
11052: LD_EXP 6
11056: PPUSH
11057: LD_STRING D2c-Lisa-1
11059: PPUSH
11060: CALL_OW 88
// sync ;
11064: SYNC
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) - 2 ) ;
11065: LD_EXP 6
11069: PPUSH
11070: LD_EXP 6
11074: PPUSH
11075: CALL_OW 250
11079: PPUSH
11080: LD_EXP 6
11084: PPUSH
11085: CALL_OW 251
11089: PUSH
11090: LD_INT 2
11092: MINUS
11093: PPUSH
11094: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) + 2 , GetY ( Lisa ) + 2 ) ;
11098: LD_EXP 6
11102: PPUSH
11103: LD_EXP 6
11107: PPUSH
11108: CALL_OW 250
11112: PUSH
11113: LD_INT 2
11115: PLUS
11116: PPUSH
11117: LD_EXP 6
11121: PPUSH
11122: CALL_OW 251
11126: PUSH
11127: LD_INT 2
11129: PLUS
11130: PPUSH
11131: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) + 2 ) ;
11135: LD_EXP 6
11139: PPUSH
11140: LD_EXP 6
11144: PPUSH
11145: CALL_OW 250
11149: PPUSH
11150: LD_EXP 6
11154: PPUSH
11155: CALL_OW 251
11159: PUSH
11160: LD_INT 2
11162: PLUS
11163: PPUSH
11164: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) - 2 , GetY ( Lisa ) - 2 ) ;
11168: LD_EXP 6
11172: PPUSH
11173: LD_EXP 6
11177: PPUSH
11178: CALL_OW 250
11182: PUSH
11183: LD_INT 2
11185: MINUS
11186: PPUSH
11187: LD_EXP 6
11191: PPUSH
11192: CALL_OW 251
11196: PUSH
11197: LD_INT 2
11199: MINUS
11200: PPUSH
11201: CALL_OW 171
// DisableExclamations ;
11205: CALL_OW 474
// end ;
11209: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Cyrus ) ) = engine_solar marked 7 do
11210: LD_EXP 5
11214: PPUSH
11215: CALL_OW 310
11219: PPUSH
11220: CALL_OW 262
11224: PUSH
11225: LD_INT 2
11227: EQUAL
11228: IFFALSE 11271
11230: GO 11232
11232: DISABLE
// begin DisableExclamations ;
11233: CALL_OW 474
// Say ( Cyrus , D2c-Cyrus-1 ) ;
11237: LD_EXP 5
11241: PPUSH
11242: LD_STRING D2c-Cyrus-1
11244: PPUSH
11245: CALL_OW 88
// if Cyrusinvehicle then
11249: LD_EXP 20
11253: IFFALSE 11267
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11255: LD_EXP 5
11259: PPUSH
11260: LD_STRING D2c-Cyrus-1a
11262: PPUSH
11263: CALL_OW 88
// EnableExclamations ;
11267: CALL_OW 473
// end ;
11271: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Bobby ) ) = engine_solar marked 7 do
11272: LD_EXP 4
11276: PPUSH
11277: CALL_OW 310
11281: PPUSH
11282: CALL_OW 262
11286: PUSH
11287: LD_INT 2
11289: EQUAL
11290: IFFALSE 11315
11292: GO 11294
11294: DISABLE
// begin EnableExclamations ;
11295: CALL_OW 473
// Say ( Bobby , D2c-Bobby-1 ) ;
11299: LD_EXP 4
11303: PPUSH
11304: LD_STRING D2c-Bobby-1
11306: PPUSH
11307: CALL_OW 88
// DisableExclamations ;
11311: CALL_OW 474
// end ;
11315: END
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) marked 2 do var hold_list ;
11316: LD_EXP 7
11320: PPUSH
11321: LD_INT 2
11323: PPUSH
11324: CALL_OW 308
11328: IFFALSE 12184
11330: GO 11332
11332: DISABLE
11333: LD_INT 0
11335: PPUSH
// begin PlaceUnitXY ( Frank , 34 , 65 , false ) ;
11336: LD_EXP 11
11340: PPUSH
11341: LD_INT 34
11343: PPUSH
11344: LD_INT 65
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 48
// ComMoveXY ( Frank , 50 , 74 ) ;
11354: LD_EXP 11
11358: PPUSH
11359: LD_INT 50
11361: PPUSH
11362: LD_INT 74
11364: PPUSH
11365: CALL_OW 111
// AddComMoveXY ( Frank , 60 , 87 ) ;
11369: LD_EXP 11
11373: PPUSH
11374: LD_INT 60
11376: PPUSH
11377: LD_INT 87
11379: PPUSH
11380: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11384: LD_INT 35
11386: PPUSH
11387: CALL_OW 67
// until not IsBusy ( Frank ) ;
11391: LD_EXP 11
11395: PPUSH
11396: CALL_OW 315
11400: NOT
11401: IFFALSE 11384
// CenterOnUnits ( Frank ) ;
11403: LD_EXP 11
11407: PPUSH
11408: CALL_OW 85
// InGameOn ;
11412: CALL_OW 8
// hold_list := [ Frank ] ;
11416: LD_ADDR_VAR 0 1
11420: PUSH
11421: LD_EXP 11
11425: PUSH
11426: EMPTY
11427: LIST
11428: ST_TO_ADDR
// if IsInArea ( MacMillan , Am_Base ) and not ( GetType ( IsInUnit ( MacMillan ) ) = unit_building ) then
11429: LD_EXP 7
11433: PPUSH
11434: LD_INT 2
11436: PPUSH
11437: CALL_OW 308
11441: PUSH
11442: LD_EXP 7
11446: PPUSH
11447: CALL_OW 310
11451: PPUSH
11452: CALL_OW 247
11456: PUSH
11457: LD_INT 3
11459: EQUAL
11460: NOT
11461: AND
11462: IFFALSE 11495
// begin ComMoveXY ( MacMillan , 62 , 91 ) ;
11464: LD_EXP 7
11468: PPUSH
11469: LD_INT 62
11471: PPUSH
11472: LD_INT 91
11474: PPUSH
11475: CALL_OW 111
// hold_list := hold_list ^ MacMillan ;
11479: LD_ADDR_VAR 0 1
11483: PUSH
11484: LD_VAR 0 1
11488: PUSH
11489: LD_EXP 7
11493: ADD
11494: ST_TO_ADDR
// end ; if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11495: LD_EXP 6
11499: PPUSH
11500: LD_INT 2
11502: PPUSH
11503: CALL_OW 308
11507: PUSH
11508: LD_EXP 6
11512: PPUSH
11513: CALL_OW 310
11517: PPUSH
11518: CALL_OW 247
11522: PUSH
11523: LD_INT 3
11525: EQUAL
11526: NOT
11527: AND
11528: IFFALSE 11561
// begin ComMoveXY ( Lisa , 59 , 90 ) ;
11530: LD_EXP 6
11534: PPUSH
11535: LD_INT 59
11537: PPUSH
11538: LD_INT 90
11540: PPUSH
11541: CALL_OW 111
// hold_list := hold_list ^ Lisa ;
11545: LD_ADDR_VAR 0 1
11549: PUSH
11550: LD_VAR 0 1
11554: PUSH
11555: LD_EXP 6
11559: ADD
11560: ST_TO_ADDR
// end ; if IsInArea ( am1 , Am_Base ) and not ( GetType ( IsInUnit ( am1 ) ) = unit_building ) then
11561: LD_INT 2
11563: PPUSH
11564: LD_INT 2
11566: PPUSH
11567: CALL_OW 308
11571: PUSH
11572: LD_INT 2
11574: PPUSH
11575: CALL_OW 310
11579: PPUSH
11580: CALL_OW 247
11584: PUSH
11585: LD_INT 3
11587: EQUAL
11588: NOT
11589: AND
11590: IFFALSE 11619
// begin ComMoveXY ( am1 , 65 , 91 ) ;
11592: LD_INT 2
11594: PPUSH
11595: LD_INT 65
11597: PPUSH
11598: LD_INT 91
11600: PPUSH
11601: CALL_OW 111
// hold_list := hold_list ^ am1 ;
11605: LD_ADDR_VAR 0 1
11609: PUSH
11610: LD_VAR 0 1
11614: PUSH
11615: LD_INT 2
11617: ADD
11618: ST_TO_ADDR
// end ; Wait ( 0 0$2 ) ;
11619: LD_INT 70
11621: PPUSH
11622: CALL_OW 67
// InGameOff ;
11626: CALL_OW 9
// interface_hidden := true ;
11630: LD_ADDR_OWVAR 54
11634: PUSH
11635: LD_INT 1
11637: ST_TO_ADDR
// DialogueOn ;
11638: CALL_OW 6
// Meet_Frank := true ;
11642: LD_ADDR_EXP 44
11646: PUSH
11647: LD_INT 1
11649: ST_TO_ADDR
// ComHold ( hold_list ) ;
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 140
// AddComTurnUnit ( Frank , MacMillan ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_EXP 7
11668: PPUSH
11669: CALL_OW 179
// AddComTurnUnit ( hold_list diff Frank , Frank ) ;
11673: LD_VAR 0 1
11677: PUSH
11678: LD_EXP 11
11682: DIFF
11683: PPUSH
11684: LD_EXP 11
11688: PPUSH
11689: CALL_OW 179
// Say ( MacMillan , D6-JMM-1 ) ;
11693: LD_EXP 7
11697: PPUSH
11698: LD_STRING D6-JMM-1
11700: PPUSH
11701: CALL_OW 88
// Say ( Frank , D6-Frank-1 ) ;
11705: LD_EXP 11
11709: PPUSH
11710: LD_STRING D6-Frank-1
11712: PPUSH
11713: CALL_OW 88
// RevealFogArea ( you , odkryj_mapu ) ;
11717: LD_EXP 1
11721: PPUSH
11722: LD_INT 5
11724: PPUSH
11725: CALL_OW 332
// CenterOnXY ( 33 , 12 ) ;
11729: LD_INT 33
11731: PPUSH
11732: LD_INT 12
11734: PPUSH
11735: CALL_OW 84
// DWait ( 0 0$4 ) ;
11739: LD_INT 140
11741: PPUSH
11742: CALL_OW 68
// CenterOnXY ( 65 , 18 ) ;
11746: LD_INT 65
11748: PPUSH
11749: LD_INT 18
11751: PPUSH
11752: CALL_OW 84
// DWait ( 0 0$3 ) ;
11756: LD_INT 105
11758: PPUSH
11759: CALL_OW 68
// CenterOnUnits ( Frank ) ;
11763: LD_EXP 11
11767: PPUSH
11768: CALL_OW 85
// DWait ( 0 0$4 ) ;
11772: LD_INT 140
11774: PPUSH
11775: CALL_OW 68
// DialogueOff ;
11779: CALL_OW 7
// InGameOn ;
11783: CALL_OW 8
// if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11787: LD_EXP 6
11791: PPUSH
11792: LD_INT 2
11794: PPUSH
11795: CALL_OW 308
11799: PUSH
11800: LD_EXP 6
11804: PPUSH
11805: CALL_OW 310
11809: PPUSH
11810: CALL_OW 247
11814: PUSH
11815: LD_INT 3
11817: EQUAL
11818: NOT
11819: AND
11820: IFFALSE 11876
// begin ComMoveUnit ( Lisa , Frank ) ;
11822: LD_EXP 6
11826: PPUSH
11827: LD_EXP 11
11831: PPUSH
11832: CALL_OW 112
// Wait ( 40 ) ;
11836: LD_INT 40
11838: PPUSH
11839: CALL_OW 67
// Say ( Lisa , D6-Lisa-1 ) ;
11843: LD_EXP 6
11847: PPUSH
11848: LD_STRING D6-Lisa-1
11850: PPUSH
11851: CALL_OW 88
// Say ( Frank , D6-Frank-2 ) ;
11855: LD_EXP 11
11859: PPUSH
11860: LD_STRING D6-Frank-2
11862: PPUSH
11863: CALL_OW 88
// ComHold ( Lisa ) ;
11867: LD_EXP 6
11871: PPUSH
11872: CALL_OW 140
// end ; InGameOff ;
11876: CALL_OW 9
// DialogueOn ;
11880: CALL_OW 6
// interface_hidden := true ;
11884: LD_ADDR_OWVAR 54
11888: PUSH
11889: LD_INT 1
11891: ST_TO_ADDR
// Say ( am1 , D6-Sol1-2 ) ;
11892: LD_INT 2
11894: PPUSH
11895: LD_STRING D6-Sol1-2
11897: PPUSH
11898: CALL_OW 88
// Say ( MacMillan , D6-JMM-2 ) ;
11902: LD_EXP 7
11906: PPUSH
11907: LD_STRING D6-JMM-2
11909: PPUSH
11910: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
11914: LD_EXP 11
11918: PPUSH
11919: LD_STRING D6-Frank-3
11921: PPUSH
11922: CALL_OW 88
// Say ( MacMillan , D6-JMM-3 ) ;
11926: LD_EXP 7
11930: PPUSH
11931: LD_STRING D6-JMM-3
11933: PPUSH
11934: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
11938: LD_EXP 11
11942: PPUSH
11943: LD_STRING D6-Frank-4
11945: PPUSH
11946: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
11950: LD_EXP 11
11954: PPUSH
11955: LD_STRING D6-Frank-4a
11957: PPUSH
11958: CALL_OW 88
// Say ( MacMillan , D6-JMM-4 ) ;
11962: LD_EXP 7
11966: PPUSH
11967: LD_STRING D6-JMM-4
11969: PPUSH
11970: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
11974: LD_EXP 11
11978: PPUSH
11979: LD_STRING D6-Frank-5
11981: PPUSH
11982: CALL_OW 88
// if IsOK ( Lisa ) then
11986: LD_EXP 6
11990: PPUSH
11991: CALL_OW 302
11995: IFFALSE 12009
// Say ( Lisa , D6-Lisa-5 ) ;
11997: LD_EXP 6
12001: PPUSH
12002: LD_STRING D6-Lisa-5
12004: PPUSH
12005: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
12009: LD_EXP 11
12013: PPUSH
12014: LD_STRING D6-Frank-6
12016: PPUSH
12017: CALL_OW 88
// Say ( MacMillan , D6-JMM-6 ) ;
12021: LD_EXP 7
12025: PPUSH
12026: LD_STRING D6-JMM-6
12028: PPUSH
12029: CALL_OW 88
// Frank_Query := Query ( Q1 ) ;
12033: LD_ADDR_EXP 47
12037: PUSH
12038: LD_STRING Q1
12040: PPUSH
12041: CALL_OW 97
12045: ST_TO_ADDR
// if Frank_Query = 1 then
12046: LD_EXP 47
12050: PUSH
12051: LD_INT 1
12053: EQUAL
12054: IFFALSE 12148
// begin SetSide ( Frank , neutral ) ;
12056: LD_EXP 11
12060: PPUSH
12061: LD_EXP 3
12065: PPUSH
12066: CALL_OW 235
// ComStop ( Lisa ) ;
12070: LD_EXP 6
12074: PPUSH
12075: CALL_OW 141
// ComMoveXY ( Frank , 35 , 68 ) ;
12079: LD_EXP 11
12083: PPUSH
12084: LD_INT 35
12086: PPUSH
12087: LD_INT 68
12089: PPUSH
12090: CALL_OW 111
// Wait ( 0 0$2 ) ;
12094: LD_INT 70
12096: PPUSH
12097: CALL_OW 67
// DialogueOff ;
12101: CALL_OW 7
// interface_hidden := false ;
12105: LD_ADDR_OWVAR 54
12109: PUSH
12110: LD_INT 0
12112: ST_TO_ADDR
// repeat Wait ( 0 0$0.5 ) ;
12113: LD_INT 18
12115: PPUSH
12116: CALL_OW 67
// until IsAt ( Frank , 35 , 68 ) ;
12120: LD_EXP 11
12124: PPUSH
12125: LD_INT 35
12127: PPUSH
12128: LD_INT 68
12130: PPUSH
12131: CALL_OW 307
12135: IFFALSE 12113
// RemoveUnit ( Frank ) ;
12137: LD_EXP 11
12141: PPUSH
12142: CALL_OW 64
// end else
12146: GO 12160
// begin DialogueOff ;
12148: CALL_OW 7
// interface_hidden := false ;
12152: LD_ADDR_OWVAR 54
12156: PUSH
12157: LD_INT 0
12159: ST_TO_ADDR
// end ; ComStop ( hold_list diff Frank ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_EXP 11
12169: DIFF
12170: PPUSH
12171: CALL_OW 141
// ComFree ( hold_list ) ;
12175: LD_VAR 0 1
12179: PPUSH
12180: CALL_OW 139
// end ;
12184: PPOPN 1
12186: END
// every 0 0$5 marked 5 do
12187: GO 12189
12189: DISABLE
// begin wait ( 0 0$10 ) ;
12190: LD_INT 350
12192: PPUSH
12193: CALL_OW 67
// RevealFogArea ( you , odkryj_mapu2 ) ;
12197: LD_EXP 1
12201: PPUSH
12202: LD_INT 8
12204: PPUSH
12205: CALL_OW 332
// SayRadio ( Frank , D3b-Frank-1 ) ;
12209: LD_EXP 11
12213: PPUSH
12214: LD_STRING D3b-Frank-1
12216: PPUSH
12217: CALL_OW 94
// end ;
12221: END
// every 0 0$10 trigger ( TICK > ( time_to_attack - 2 2$30 ) ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) > 5 ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) >= FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ) do
12222: LD_OWVAR 1
12226: PUSH
12227: LD_EXP 41
12231: PUSH
12232: LD_INT 5250
12234: MINUS
12235: GREATER
12236: PUSH
12237: LD_INT 22
12239: PUSH
12240: LD_EXP 1
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: PUSH
12249: LD_INT 21
12251: PUSH
12252: LD_INT 2
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: PUSH
12259: LD_INT 32
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: LIST
12273: PPUSH
12274: CALL_OW 69
12278: PUSH
12279: LD_INT 5
12281: GREATER
12282: OR
12283: PUSH
12284: LD_INT 22
12286: PUSH
12287: LD_EXP 1
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: LD_INT 21
12298: PUSH
12299: LD_INT 2
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: PUSH
12306: LD_INT 32
12308: PUSH
12309: LD_INT 2
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: PUSH
12316: EMPTY
12317: LIST
12318: LIST
12319: LIST
12320: PPUSH
12321: CALL_OW 69
12325: PUSH
12326: LD_INT 22
12328: PUSH
12329: LD_EXP 1
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 21
12340: PUSH
12341: LD_INT 1
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 50
12350: PUSH
12351: EMPTY
12352: LIST
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: LIST
12358: PPUSH
12359: CALL_OW 69
12363: GREATEREQUAL
12364: OR
12365: IFFALSE 12404
12367: GO 12369
12369: DISABLE
// begin if cornell_lost then
12370: LD_EXP 46
12374: IFFALSE 12378
// exit ;
12376: GO 12404
// time_to_attack := TICK + 2 2$30 ;
12378: LD_ADDR_EXP 41
12382: PUSH
12383: LD_OWVAR 1
12387: PUSH
12388: LD_INT 5250
12390: PLUS
12391: ST_TO_ADDR
// SayRadio ( Cornell , D3-Corn-1 ) ;
12392: LD_EXP 8
12396: PPUSH
12397: LD_STRING D3-Corn-1
12399: PPUSH
12400: CALL_OW 94
// end ;
12404: END
// every 0 0$10 trigger TICK > ( time_to_attack ) do
12405: LD_OWVAR 1
12409: PUSH
12410: LD_EXP 41
12414: GREATER
12415: IFFALSE 12620
12417: GO 12419
12419: DISABLE
// begin if cornell_lost then
12420: LD_EXP 46
12424: IFFALSE 12428
// exit ;
12426: GO 12620
// CenterOnUnits ( MacMillan ) ;
12428: LD_EXP 7
12432: PPUSH
12433: CALL_OW 85
// DisableExclamations ;
12437: CALL_OW 474
// DialogueOn ;
12441: CALL_OW 6
// interface_hidden := true ;
12445: LD_ADDR_OWVAR 54
12449: PUSH
12450: LD_INT 1
12452: ST_TO_ADDR
// SayRadio ( Cornell , D3a-Corn-1 ) ;
12453: LD_EXP 8
12457: PPUSH
12458: LD_STRING D3a-Corn-1
12460: PPUSH
12461: CALL_OW 94
// Say ( MacMillan , D3a-JMM-1 ) ;
12465: LD_EXP 7
12469: PPUSH
12470: LD_STRING D3a-JMM-1
12472: PPUSH
12473: CALL_OW 88
// SayRadio ( Cornell , D3a-Corn-2 ) ;
12477: LD_EXP 8
12481: PPUSH
12482: LD_STRING D3a-Corn-2
12484: PPUSH
12485: CALL_OW 94
// interface_hidden := false ;
12489: LD_ADDR_OWVAR 54
12493: PUSH
12494: LD_INT 0
12496: ST_TO_ADDR
// DialogueOff ;
12497: CALL_OW 7
// EnableExclamations ;
12501: CALL_OW 473
// ChangeMissionObjectives ( MOutWait ) ;
12505: LD_STRING MOutWait
12507: PPUSH
12508: CALL_OW 337
// ChangeMissionObjectives ( M2 ) ;
12512: LD_STRING M2
12514: PPUSH
12515: CALL_OW 337
// SetAreaMapShow ( TopBorder , 1 ) ;
12519: LD_INT 1
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 424
// if FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_nation , nation_american ] ] ) then
12529: LD_INT 22
12531: PUSH
12532: LD_EXP 1
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 21
12543: PUSH
12544: LD_INT 2
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 23
12553: PUSH
12554: LD_INT 1
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: PPUSH
12566: CALL_OW 69
12570: IFFALSE 12581
// Hint ( Skills1 ) else
12572: LD_STRING Skills1
12574: PPUSH
12575: CALL_OW 339
12579: GO 12588
// Hint ( Skills2 ) ;
12581: LD_STRING Skills2
12583: PPUSH
12584: CALL_OW 339
// if ( GetSide ( Frank ) = neutral ) then
12588: LD_EXP 11
12592: PPUSH
12593: CALL_OW 255
12597: PUSH
12598: LD_EXP 3
12602: EQUAL
12603: IFFALSE 12608
// enable ( 5 ) ;
12605: LD_INT 5
12607: ENABLE_MARKED
// atack := 1 ;
12608: LD_ADDR_EXP 16
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// attack_began ;
12616: CALL 6088 0 0
// end ;
12620: END
// every 0 0$10 trigger TICK > ( time_to_attack + time_to_return - 1 1$0 ) do
12621: LD_OWVAR 1
12625: PUSH
12626: LD_EXP 41
12630: PUSH
12631: LD_EXP 40
12635: PLUS
12636: PUSH
12637: LD_INT 2100
12639: MINUS
12640: GREATER
12641: IFFALSE 12665
12643: GO 12645
12645: DISABLE
// begin if not cornell_lost then
12646: LD_EXP 46
12650: NOT
12651: IFFALSE 12665
// SayRadio ( Cornell , D4-Corn-1 ) ;
12653: LD_EXP 8
12657: PPUSH
12658: LD_STRING D4-Corn-1
12660: PPUSH
12661: CALL_OW 94
// end ;
12665: END
// every 0 0$1 trigger GridY ( MacMillan ) < 10 or TICK > ( time_to_attack + time_to_return ) marked 3 do
12666: LD_EXP 7
12670: PPUSH
12671: CALL 2612 0 1
12675: PUSH
12676: LD_INT 10
12678: LESS
12679: PUSH
12680: LD_OWVAR 1
12684: PUSH
12685: LD_EXP 41
12689: PUSH
12690: LD_EXP 40
12694: PLUS
12695: GREATER
12696: OR
12697: IFFALSE 12746
12699: GO 12701
12701: DISABLE
// begin SayRadio ( Cornell , D5-Corn-1 ) ;
12702: LD_EXP 8
12706: PPUSH
12707: LD_STRING D5-Corn-1
12709: PPUSH
12710: CALL_OW 94
// if TICK < ( 15 15$0 + time_to_return ) then
12714: LD_OWVAR 1
12718: PUSH
12719: LD_INT 31500
12721: PUSH
12722: LD_EXP 40
12726: PLUS
12727: LESS
12728: IFFALSE 12738
// atack := 0 ;
12730: LD_ADDR_EXP 16
12734: PUSH
12735: LD_INT 0
12737: ST_TO_ADDR
// cornell_lost := true ;
12738: LD_ADDR_EXP 46
12742: PUSH
12743: LD_INT 1
12745: ST_TO_ADDR
// end ;
12746: END
// export function talk_about_attack ; begin
12747: LD_INT 0
12749: PPUSH
// DisableExclamations ;
12750: CALL_OW 474
// if IsOK ( patrol1 ) and IsOK ( patrol2 ) then
12754: LD_INT 14
12756: PPUSH
12757: CALL_OW 302
12761: PUSH
12762: LD_INT 15
12764: PPUSH
12765: CALL_OW 302
12769: AND
12770: IFFALSE 12786
// Say ( MacMillan , D8b-JMM-1a ) else
12772: LD_EXP 7
12776: PPUSH
12777: LD_STRING D8b-JMM-1a
12779: PPUSH
12780: CALL_OW 88
12784: GO 12798
// Say ( MacMillan , D8b-JMM-1 ) ;
12786: LD_EXP 7
12790: PPUSH
12791: LD_STRING D8b-JMM-1
12793: PPUSH
12794: CALL_OW 88
// Say ( am1 , D8b-Sol1-1 ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_STRING D8b-Sol1-1
12803: PPUSH
12804: CALL_OW 88
// if IsOK ( Cyrus ) then
12808: LD_EXP 5
12812: PPUSH
12813: CALL_OW 302
12817: IFFALSE 12831
// Say ( Cyrus , D8b-Cyrus-1 ) ;
12819: LD_EXP 5
12823: PPUSH
12824: LD_STRING D8b-Cyrus-1
12826: PPUSH
12827: CALL_OW 88
// if IsOK ( Bobby ) then
12831: LD_EXP 4
12835: PPUSH
12836: CALL_OW 302
12840: IFFALSE 12854
// Say ( Bobby , D8b-Bobby-1 ) ;
12842: LD_EXP 4
12846: PPUSH
12847: LD_STRING D8b-Bobby-1
12849: PPUSH
12850: CALL_OW 88
// if not ( IsOK ( Cyrus ) or IsOK ( Bobby ) ) then
12854: LD_EXP 5
12858: PPUSH
12859: CALL_OW 302
12863: PUSH
12864: LD_EXP 4
12868: PPUSH
12869: CALL_OW 302
12873: OR
12874: NOT
12875: IFFALSE 12887
// Say ( am2 , D8b-Sol2-1 ) ;
12877: LD_INT 3
12879: PPUSH
12880: LD_STRING D8b-Sol2-1
12882: PPUSH
12883: CALL_OW 88
// Say ( MacMillan , D8b-JMM-2 ) ;
12887: LD_EXP 7
12891: PPUSH
12892: LD_STRING D8b-JMM-2
12894: PPUSH
12895: CALL_OW 88
// if IsOK ( Lisa ) then
12899: LD_EXP 6
12903: PPUSH
12904: CALL_OW 302
12908: IFFALSE 12922
// Say ( Lisa , D8b-Lisa-2 ) ;
12910: LD_EXP 6
12914: PPUSH
12915: LD_STRING D8b-Lisa-2
12917: PPUSH
12918: CALL_OW 88
// EnableExclamations ;
12922: CALL_OW 473
// end ; end_of_file
12926: LD_VAR 0 1
12930: RET
// export ru_trucks , ru_drivers ; var levels , positions ; export s_guard1 , s_guard2 , s_guard3 , s_guard4 , home_11 , home_12 , home_21 , home_22 , home_31 , home_32 , grass_31 , grass_32 , grass_33 ; export function prepare_russian_side ; begin
12931: LD_INT 0
12933: PPUSH
// levels := [ 1 , 3 , 6 ] [ difficulty ] ;
12934: LD_ADDR_LOC 3
12938: PUSH
12939: LD_INT 1
12941: PUSH
12942: LD_INT 3
12944: PUSH
12945: LD_INT 6
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: LIST
12952: PUSH
12953: LD_OWVAR 67
12957: ARRAY
12958: ST_TO_ADDR
// positions := [ 21 , 14 , 29 , 8 , 49 , 23 , 55 , 13 , 75 , 22 , 93 , 20 , 106 , 20 , 145 , 106 ] ;
12959: LD_ADDR_LOC 4
12963: PUSH
12964: LD_INT 21
12966: PUSH
12967: LD_INT 14
12969: PUSH
12970: LD_INT 29
12972: PUSH
12973: LD_INT 8
12975: PUSH
12976: LD_INT 49
12978: PUSH
12979: LD_INT 23
12981: PUSH
12982: LD_INT 55
12984: PUSH
12985: LD_INT 13
12987: PUSH
12988: LD_INT 75
12990: PUSH
12991: LD_INT 22
12993: PUSH
12994: LD_INT 93
12996: PUSH
12997: LD_INT 20
12999: PUSH
13000: LD_INT 106
13002: PUSH
13003: LD_INT 20
13005: PUSH
13006: LD_INT 145
13008: PUSH
13009: LD_INT 106
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: LIST
13029: ST_TO_ADDR
// if difficulty > 1 then
13030: LD_OWVAR 67
13034: PUSH
13035: LD_INT 1
13037: GREATER
13038: IFFALSE 13052
// begin prepare_home1 ;
13040: CALL 13081 0 0
// prepare_home2 ;
13044: CALL 13233 0 0
// prepare_home3 ;
13048: CALL 13385 0 0
// end ; prepare_s_guard ;
13052: CALL 13537 0 0
// prepare_grass3 ;
13056: CALL 13731 0 0
// prepare_drivers ;
13060: CALL 13988 0 0
// prepare_vehicles ;
13064: CALL 14093 0 0
// drivers_into_vehicles ;
13068: CALL 14363 0 0
// place_russian_batery ;
13072: CALL 13900 0 0
// end ;
13076: LD_VAR 0 1
13080: RET
// function prepare_home1 ; var un , sol ; begin
13081: LD_INT 0
13083: PPUSH
13084: PPUSH
13085: PPUSH
// uc_side := russians ;
13086: LD_ADDR_OWVAR 20
13090: PUSH
13091: LD_EXP 2
13095: ST_TO_ADDR
// uc_nation := nation_russian ;
13096: LD_ADDR_OWVAR 21
13100: PUSH
13101: LD_INT 3
13103: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13104: LD_ADDR_VAR 0 2
13108: PUSH
13109: DOUBLE
13110: LD_INT 1
13112: DEC
13113: ST_TO_ADDR
13114: LD_OWVAR 67
13118: PUSH
13119: LD_INT 1
13121: MINUS
13122: PUSH
13123: FOR_TO
13124: IFFALSE 13226
// begin PrepareSoldier ( 0 , levels ) ;
13126: LD_INT 0
13128: PPUSH
13129: LD_LOC 3
13133: PPUSH
13134: CALL_OW 381
// sol := CreateHuman ;
13138: LD_ADDR_VAR 0 3
13142: PUSH
13143: CALL_OW 44
13147: ST_TO_ADDR
// case un of 1 :
13148: LD_VAR 0 2
13152: PUSH
13153: LD_INT 1
13155: DOUBLE
13156: EQUAL
13157: IFTRUE 13161
13159: GO 13174
13161: POP
// home_11 := sol ; 2 :
13162: LD_ADDR_EXP 54
13166: PUSH
13167: LD_VAR 0 3
13171: ST_TO_ADDR
13172: GO 13196
13174: LD_INT 2
13176: DOUBLE
13177: EQUAL
13178: IFTRUE 13182
13180: GO 13195
13182: POP
// home_12 := sol ; end ;
13183: LD_ADDR_EXP 55
13187: PUSH
13188: LD_VAR 0 3
13192: ST_TO_ADDR
13193: GO 13196
13195: POP
// PlaceUnitXYR ( sol , 88 , 23 , 3 , false ) ;
13196: LD_VAR 0 3
13200: PPUSH
13201: LD_INT 88
13203: PPUSH
13204: LD_INT 23
13206: PPUSH
13207: LD_INT 3
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 50
// wait ( 1 ) ;
13217: LD_INT 1
13219: PPUSH
13220: CALL_OW 67
// end ;
13224: GO 13123
13226: POP
13227: POP
// end ;
13228: LD_VAR 0 1
13232: RET
// function prepare_home2 ; var un , sol ; begin
13233: LD_INT 0
13235: PPUSH
13236: PPUSH
13237: PPUSH
// uc_side := russians ;
13238: LD_ADDR_OWVAR 20
13242: PUSH
13243: LD_EXP 2
13247: ST_TO_ADDR
// uc_nation := nation_russian ;
13248: LD_ADDR_OWVAR 21
13252: PUSH
13253: LD_INT 3
13255: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13256: LD_ADDR_VAR 0 2
13260: PUSH
13261: DOUBLE
13262: LD_INT 1
13264: DEC
13265: ST_TO_ADDR
13266: LD_OWVAR 67
13270: PUSH
13271: LD_INT 1
13273: MINUS
13274: PUSH
13275: FOR_TO
13276: IFFALSE 13378
// begin PrepareSoldier ( 0 , levels ) ;
13278: LD_INT 0
13280: PPUSH
13281: LD_LOC 3
13285: PPUSH
13286: CALL_OW 381
// sol := CreateHuman ;
13290: LD_ADDR_VAR 0 3
13294: PUSH
13295: CALL_OW 44
13299: ST_TO_ADDR
// case un of 1 :
13300: LD_VAR 0 2
13304: PUSH
13305: LD_INT 1
13307: DOUBLE
13308: EQUAL
13309: IFTRUE 13313
13311: GO 13326
13313: POP
// home_21 := sol ; 2 :
13314: LD_ADDR_EXP 56
13318: PUSH
13319: LD_VAR 0 3
13323: ST_TO_ADDR
13324: GO 13348
13326: LD_INT 2
13328: DOUBLE
13329: EQUAL
13330: IFTRUE 13334
13332: GO 13347
13334: POP
// home_22 := sol ; end ;
13335: LD_ADDR_EXP 57
13339: PUSH
13340: LD_VAR 0 3
13344: ST_TO_ADDR
13345: GO 13348
13347: POP
// PlaceUnitXYR ( sol , 69 , 19 , 3 , false ) ;
13348: LD_VAR 0 3
13352: PPUSH
13353: LD_INT 69
13355: PPUSH
13356: LD_INT 19
13358: PPUSH
13359: LD_INT 3
13361: PPUSH
13362: LD_INT 0
13364: PPUSH
13365: CALL_OW 50
// wait ( 1 ) ;
13369: LD_INT 1
13371: PPUSH
13372: CALL_OW 67
// end ;
13376: GO 13275
13378: POP
13379: POP
// end ;
13380: LD_VAR 0 1
13384: RET
// function prepare_home3 ; var un , sol ; begin
13385: LD_INT 0
13387: PPUSH
13388: PPUSH
13389: PPUSH
// uc_side := russians ;
13390: LD_ADDR_OWVAR 20
13394: PUSH
13395: LD_EXP 2
13399: ST_TO_ADDR
// uc_nation := nation_russian ;
13400: LD_ADDR_OWVAR 21
13404: PUSH
13405: LD_INT 3
13407: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13408: LD_ADDR_VAR 0 2
13412: PUSH
13413: DOUBLE
13414: LD_INT 1
13416: DEC
13417: ST_TO_ADDR
13418: LD_OWVAR 67
13422: PUSH
13423: LD_INT 1
13425: MINUS
13426: PUSH
13427: FOR_TO
13428: IFFALSE 13530
// begin PrepareSoldier ( 0 , levels ) ;
13430: LD_INT 0
13432: PPUSH
13433: LD_LOC 3
13437: PPUSH
13438: CALL_OW 381
// sol := CreateHuman ;
13442: LD_ADDR_VAR 0 3
13446: PUSH
13447: CALL_OW 44
13451: ST_TO_ADDR
// case un of 1 :
13452: LD_VAR 0 2
13456: PUSH
13457: LD_INT 1
13459: DOUBLE
13460: EQUAL
13461: IFTRUE 13465
13463: GO 13478
13465: POP
// home_31 := sol ; 2 :
13466: LD_ADDR_EXP 58
13470: PUSH
13471: LD_VAR 0 3
13475: ST_TO_ADDR
13476: GO 13500
13478: LD_INT 2
13480: DOUBLE
13481: EQUAL
13482: IFTRUE 13486
13484: GO 13499
13486: POP
// home_32 := sol ; end ;
13487: LD_ADDR_EXP 59
13491: PUSH
13492: LD_VAR 0 3
13496: ST_TO_ADDR
13497: GO 13500
13499: POP
// PlaceUnitXYR ( sol , 17 , 10 , 3 , false ) ;
13500: LD_VAR 0 3
13504: PPUSH
13505: LD_INT 17
13507: PPUSH
13508: LD_INT 10
13510: PPUSH
13511: LD_INT 3
13513: PPUSH
13514: LD_INT 0
13516: PPUSH
13517: CALL_OW 50
// wait ( 1 ) ;
13521: LD_INT 1
13523: PPUSH
13524: CALL_OW 67
// end ;
13528: GO 13427
13530: POP
13531: POP
// end ;
13532: LD_VAR 0 1
13536: RET
// function prepare_s_guard ; var un , sol ; begin
13537: LD_INT 0
13539: PPUSH
13540: PPUSH
13541: PPUSH
// uc_side := russians ;
13542: LD_ADDR_OWVAR 20
13546: PUSH
13547: LD_EXP 2
13551: ST_TO_ADDR
// uc_nation := nation_russian ;
13552: LD_ADDR_OWVAR 21
13556: PUSH
13557: LD_INT 3
13559: ST_TO_ADDR
// for un = 1 to ( difficulty + 1 ) do
13560: LD_ADDR_VAR 0 2
13564: PUSH
13565: DOUBLE
13566: LD_INT 1
13568: DEC
13569: ST_TO_ADDR
13570: LD_OWVAR 67
13574: PUSH
13575: LD_INT 1
13577: PLUS
13578: PUSH
13579: FOR_TO
13580: IFFALSE 13724
// begin PrepareSoldier ( 0 , levels ) ;
13582: LD_INT 0
13584: PPUSH
13585: LD_LOC 3
13589: PPUSH
13590: CALL_OW 381
// sol := CreateHuman ;
13594: LD_ADDR_VAR 0 3
13598: PUSH
13599: CALL_OW 44
13603: ST_TO_ADDR
// case un of 1 :
13604: LD_VAR 0 2
13608: PUSH
13609: LD_INT 1
13611: DOUBLE
13612: EQUAL
13613: IFTRUE 13617
13615: GO 13630
13617: POP
// s_guard1 := sol ; 2 :
13618: LD_ADDR_EXP 50
13622: PUSH
13623: LD_VAR 0 3
13627: ST_TO_ADDR
13628: GO 13694
13630: LD_INT 2
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13651
13638: POP
// s_guard2 := sol ; 3 :
13639: LD_ADDR_EXP 51
13643: PUSH
13644: LD_VAR 0 3
13648: ST_TO_ADDR
13649: GO 13694
13651: LD_INT 3
13653: DOUBLE
13654: EQUAL
13655: IFTRUE 13659
13657: GO 13672
13659: POP
// s_guard3 := sol ; 4 :
13660: LD_ADDR_EXP 52
13664: PUSH
13665: LD_VAR 0 3
13669: ST_TO_ADDR
13670: GO 13694
13672: LD_INT 4
13674: DOUBLE
13675: EQUAL
13676: IFTRUE 13680
13678: GO 13693
13680: POP
// s_guard4 := sol ; end ;
13681: LD_ADDR_EXP 53
13685: PUSH
13686: LD_VAR 0 3
13690: ST_TO_ADDR
13691: GO 13694
13693: POP
// PlaceUnitXYR ( sol , 118 , 105 , 3 , false ) ;
13694: LD_VAR 0 3
13698: PPUSH
13699: LD_INT 118
13701: PPUSH
13702: LD_INT 105
13704: PPUSH
13705: LD_INT 3
13707: PPUSH
13708: LD_INT 0
13710: PPUSH
13711: CALL_OW 50
// wait ( 1 ) ;
13715: LD_INT 1
13717: PPUSH
13718: CALL_OW 67
// end ;
13722: GO 13579
13724: POP
13725: POP
// end ;
13726: LD_VAR 0 1
13730: RET
// function prepare_grass3 ; var un , sol ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
13735: PPUSH
// uc_side := russians ;
13736: LD_ADDR_OWVAR 20
13740: PUSH
13741: LD_EXP 2
13745: ST_TO_ADDR
// uc_nation := nation_russian ;
13746: LD_ADDR_OWVAR 21
13750: PUSH
13751: LD_INT 3
13753: ST_TO_ADDR
// for un = 1 to difficulty do
13754: LD_ADDR_VAR 0 2
13758: PUSH
13759: DOUBLE
13760: LD_INT 1
13762: DEC
13763: ST_TO_ADDR
13764: LD_OWVAR 67
13768: PUSH
13769: FOR_TO
13770: IFFALSE 13893
// begin PrepareSoldier ( 0 , levels ) ;
13772: LD_INT 0
13774: PPUSH
13775: LD_LOC 3
13779: PPUSH
13780: CALL_OW 381
// sol := CreateHuman ;
13784: LD_ADDR_VAR 0 3
13788: PUSH
13789: CALL_OW 44
13793: ST_TO_ADDR
// case un of 1 :
13794: LD_VAR 0 2
13798: PUSH
13799: LD_INT 1
13801: DOUBLE
13802: EQUAL
13803: IFTRUE 13807
13805: GO 13820
13807: POP
// grass_31 := sol ; 2 :
13808: LD_ADDR_EXP 60
13812: PUSH
13813: LD_VAR 0 3
13817: ST_TO_ADDR
13818: GO 13863
13820: LD_INT 2
13822: DOUBLE
13823: EQUAL
13824: IFTRUE 13828
13826: GO 13841
13828: POP
// grass_32 := sol ; 3 :
13829: LD_ADDR_EXP 61
13833: PUSH
13834: LD_VAR 0 3
13838: ST_TO_ADDR
13839: GO 13863
13841: LD_INT 3
13843: DOUBLE
13844: EQUAL
13845: IFTRUE 13849
13847: GO 13862
13849: POP
// grass_33 := sol ; end ;
13850: LD_ADDR_EXP 62
13854: PUSH
13855: LD_VAR 0 3
13859: ST_TO_ADDR
13860: GO 13863
13862: POP
// PlaceUnitXYR ( sol , 73 , 38 , 3 , false ) ;
13863: LD_VAR 0 3
13867: PPUSH
13868: LD_INT 73
13870: PPUSH
13871: LD_INT 38
13873: PPUSH
13874: LD_INT 3
13876: PPUSH
13877: LD_INT 0
13879: PPUSH
13880: CALL_OW 50
// wait ( 1 ) ;
13884: LD_INT 1
13886: PPUSH
13887: CALL_OW 67
// end ;
13891: GO 13769
13893: POP
13894: POP
// end ;
13895: LD_VAR 0 1
13899: RET
// function place_russian_batery ; var i ; begin
13900: LD_INT 0
13902: PPUSH
13903: PPUSH
// for i = 1 to 8 do
13904: LD_ADDR_VAR 0 2
13908: PUSH
13909: DOUBLE
13910: LD_INT 1
13912: DEC
13913: ST_TO_ADDR
13914: LD_INT 8
13916: PUSH
13917: FOR_TO
13918: IFFALSE 13981
// begin PlaceUnitXY ( ru_trucks [ i ] , positions [ ( i * 2 ) - 1 ] , positions [ ( i * 2 ) ] , false ) ;
13920: LD_EXP 48
13924: PUSH
13925: LD_VAR 0 2
13929: ARRAY
13930: PPUSH
13931: LD_LOC 4
13935: PUSH
13936: LD_VAR 0 2
13940: PUSH
13941: LD_INT 2
13943: MUL
13944: PUSH
13945: LD_INT 1
13947: MINUS
13948: ARRAY
13949: PPUSH
13950: LD_LOC 4
13954: PUSH
13955: LD_VAR 0 2
13959: PUSH
13960: LD_INT 2
13962: MUL
13963: ARRAY
13964: PPUSH
13965: LD_INT 0
13967: PPUSH
13968: CALL_OW 48
// wait ( 1 ) ;
13972: LD_INT 1
13974: PPUSH
13975: CALL_OW 67
// end ;
13979: GO 13917
13981: POP
13982: POP
// end ;
13983: LD_VAR 0 1
13987: RET
// function prepare_drivers ; var i ; begin
13988: LD_INT 0
13990: PPUSH
13991: PPUSH
// ru_drivers := [ ] ;
13992: LD_ADDR_EXP 49
13996: PUSH
13997: EMPTY
13998: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
13999: LD_ADDR_OWVAR 24
14003: PUSH
14004: LD_INT 0
14006: PPUSH
14007: LD_INT 5
14009: PPUSH
14010: CALL_OW 12
14014: ST_TO_ADDR
// uc_nation = nation_russian ;
14015: LD_ADDR_OWVAR 21
14019: PUSH
14020: LD_INT 3
14022: ST_TO_ADDR
// uc_side = russians ;
14023: LD_ADDR_OWVAR 20
14027: PUSH
14028: LD_EXP 2
14032: ST_TO_ADDR
// for i = 1 to 8 do
14033: LD_ADDR_VAR 0 2
14037: PUSH
14038: DOUBLE
14039: LD_INT 1
14041: DEC
14042: ST_TO_ADDR
14043: LD_INT 8
14045: PUSH
14046: FOR_TO
14047: IFFALSE 14086
// begin PrepareMechanic ( 0 , levels ) ;
14049: LD_INT 0
14051: PPUSH
14052: LD_LOC 3
14056: PPUSH
14057: CALL_OW 383
// ru_drivers := ru_drivers ^ CreateHuman ;
14061: LD_ADDR_EXP 49
14065: PUSH
14066: LD_EXP 49
14070: PUSH
14071: CALL_OW 44
14075: ADD
14076: ST_TO_ADDR
// wait ( 1 ) ;
14077: LD_INT 1
14079: PPUSH
14080: CALL_OW 67
// end ;
14084: GO 14046
14086: POP
14087: POP
// end ;
14088: LD_VAR 0 1
14092: RET
// function prepare_vehicles ; var i , weapon ; begin
14093: LD_INT 0
14095: PPUSH
14096: PPUSH
14097: PPUSH
// ru_trucks := [ ] ;
14098: LD_ADDR_EXP 48
14102: PUSH
14103: EMPTY
14104: ST_TO_ADDR
// weapon := [ 1 , 0 , 0 ] ;
14105: LD_ADDR_VAR 0 3
14109: PUSH
14110: LD_INT 1
14112: PUSH
14113: LD_INT 0
14115: PUSH
14116: LD_INT 0
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: LIST
14123: ST_TO_ADDR
// uc_nation = nation_russian ;
14124: LD_ADDR_OWVAR 21
14128: PUSH
14129: LD_INT 3
14131: ST_TO_ADDR
// uc_side = russians ;
14132: LD_ADDR_OWVAR 20
14136: PUSH
14137: LD_EXP 2
14141: ST_TO_ADDR
// for i = 1 to 8 do
14142: LD_ADDR_VAR 0 2
14146: PUSH
14147: DOUBLE
14148: LD_INT 1
14150: DEC
14151: ST_TO_ADDR
14152: LD_INT 8
14154: PUSH
14155: FOR_TO
14156: IFFALSE 14356
// begin uc_direction = rand ( 0 , 5 ) ;
14158: LD_ADDR_OWVAR 24
14162: PUSH
14163: LD_INT 0
14165: PPUSH
14166: LD_INT 5
14168: PPUSH
14169: CALL_OW 12
14173: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
14174: LD_ADDR_OWVAR 37
14178: PUSH
14179: LD_INT 21
14181: ST_TO_ADDR
// vc_engine := engine_combustion ;
14182: LD_ADDR_OWVAR 39
14186: PUSH
14187: LD_INT 1
14189: ST_TO_ADDR
// vc_control := control_manual ;
14190: LD_ADDR_OWVAR 38
14194: PUSH
14195: LD_INT 1
14197: ST_TO_ADDR
// case ( i mod difficulty ) + 1 of 1 :
14198: LD_VAR 0 2
14202: PUSH
14203: LD_OWVAR 67
14207: MOD
14208: PUSH
14209: LD_INT 1
14211: PLUS
14212: PUSH
14213: LD_INT 1
14215: DOUBLE
14216: EQUAL
14217: IFTRUE 14221
14219: GO 14252
14221: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 3 ) + 1 ] ; 2 :
14222: LD_ADDR_OWVAR 40
14226: PUSH
14227: LD_INT 42
14229: PUSH
14230: LD_VAR 0 3
14234: PUSH
14235: LD_VAR 0 2
14239: PUSH
14240: LD_INT 3
14242: MOD
14243: PUSH
14244: LD_INT 1
14246: PLUS
14247: ARRAY
14248: PLUS
14249: ST_TO_ADDR
14250: GO 14331
14252: LD_INT 2
14254: DOUBLE
14255: EQUAL
14256: IFTRUE 14260
14258: GO 14291
14260: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 2 ) + 1 ] ; 3 :
14261: LD_ADDR_OWVAR 40
14265: PUSH
14266: LD_INT 42
14268: PUSH
14269: LD_VAR 0 3
14273: PUSH
14274: LD_VAR 0 2
14278: PUSH
14279: LD_INT 2
14281: MOD
14282: PUSH
14283: LD_INT 1
14285: PLUS
14286: ARRAY
14287: PLUS
14288: ST_TO_ADDR
14289: GO 14331
14291: LD_INT 3
14293: DOUBLE
14294: EQUAL
14295: IFTRUE 14299
14297: GO 14330
14299: POP
// vc_weapon := ru_gatling_gun - weapon [ ( i mod 3 ) + 1 ] ; end ;
14300: LD_ADDR_OWVAR 40
14304: PUSH
14305: LD_INT 43
14307: PUSH
14308: LD_VAR 0 3
14312: PUSH
14313: LD_VAR 0 2
14317: PUSH
14318: LD_INT 3
14320: MOD
14321: PUSH
14322: LD_INT 1
14324: PLUS
14325: ARRAY
14326: MINUS
14327: ST_TO_ADDR
14328: GO 14331
14330: POP
// ru_trucks := ru_trucks ^ CreateVehicle ;
14331: LD_ADDR_EXP 48
14335: PUSH
14336: LD_EXP 48
14340: PUSH
14341: CALL_OW 45
14345: ADD
14346: ST_TO_ADDR
// wait ( 1 ) ;
14347: LD_INT 1
14349: PPUSH
14350: CALL_OW 67
// end ;
14354: GO 14155
14356: POP
14357: POP
// end ;
14358: LD_VAR 0 1
14362: RET
// function drivers_into_vehicles ; var i ; begin
14363: LD_INT 0
14365: PPUSH
14366: PPUSH
// for i = 1 to 8 do
14367: LD_ADDR_VAR 0 2
14371: PUSH
14372: DOUBLE
14373: LD_INT 1
14375: DEC
14376: ST_TO_ADDR
14377: LD_INT 8
14379: PUSH
14380: FOR_TO
14381: IFFALSE 14418
// begin PlaceHumanInUnit ( ru_drivers [ i ] , ru_trucks [ i ] ) ;
14383: LD_EXP 49
14387: PUSH
14388: LD_VAR 0 2
14392: ARRAY
14393: PPUSH
14394: LD_EXP 48
14398: PUSH
14399: LD_VAR 0 2
14403: ARRAY
14404: PPUSH
14405: CALL_OW 52
// wait ( 1 ) ;
14409: LD_INT 1
14411: PPUSH
14412: CALL_OW 67
// end ;
14416: GO 14380
14418: POP
14419: POP
// end ; end_of_file
14420: LD_VAR 0 1
14424: RET
// on VehicleCaptured ( v_new , v_old , o_side , hum ) do begin ru_trucks := ru_trucks diff v_old ;
14425: LD_ADDR_EXP 48
14429: PUSH
14430: LD_EXP 48
14434: PUSH
14435: LD_VAR 0 2
14439: DIFF
14440: ST_TO_ADDR
// end ; end_of_file
14441: PPOPN 4
14443: END
// var remove_bunkers , remove_soldiers , remove_drivers , remove_vehicles ; export function fix_difficulty ; begin
14444: LD_INT 0
14446: PPUSH
// remove_bunkers := [ [ bunker2 , bunker3 , bunker5 , bunker6 ] , [ bunker2 , bunker5 ] ] ;
14447: LD_ADDR_LOC 5
14451: PUSH
14452: LD_INT 27
14454: PUSH
14455: LD_INT 34
14457: PUSH
14458: LD_INT 32
14460: PUSH
14461: LD_INT 31
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: PUSH
14470: LD_INT 27
14472: PUSH
14473: LD_INT 32
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: ST_TO_ADDR
// remove_soldiers := [ [ guard2 , guard3 , guard5 , guard6 ] , [ guard2 , guard5 ] ] ;
14484: LD_ADDR_LOC 6
14488: PUSH
14489: LD_INT 29
14491: PUSH
14492: LD_INT 48
14494: PUSH
14495: LD_INT 49
14497: PUSH
14498: LD_INT 20
14500: PUSH
14501: EMPTY
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: PUSH
14507: LD_INT 29
14509: PUSH
14510: LD_INT 49
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: ST_TO_ADDR
// remove_drivers := [ [ ru_drivers [ 1 ] , ru_drivers [ 3 ] , ru_drivers [ 5 ] , ru_drivers [ 7 ] , ] , [ ru_drivers [ 2 ] , ru_drivers [ 4 ] , ru_drivers [ 6 ] ] ] ;
14521: LD_ADDR_LOC 7
14525: PUSH
14526: LD_EXP 49
14530: PUSH
14531: LD_INT 1
14533: ARRAY
14534: PUSH
14535: LD_EXP 49
14539: PUSH
14540: LD_INT 3
14542: ARRAY
14543: PUSH
14544: LD_EXP 49
14548: PUSH
14549: LD_INT 5
14551: ARRAY
14552: PUSH
14553: LD_EXP 49
14557: PUSH
14558: LD_INT 7
14560: ARRAY
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: PUSH
14568: LD_EXP 49
14572: PUSH
14573: LD_INT 2
14575: ARRAY
14576: PUSH
14577: LD_EXP 49
14581: PUSH
14582: LD_INT 4
14584: ARRAY
14585: PUSH
14586: LD_EXP 49
14590: PUSH
14591: LD_INT 6
14593: ARRAY
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: LIST
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: ST_TO_ADDR
// remove_vehicles := [ [ ru_trucks [ 1 ] , ru_trucks [ 3 ] , ru_trucks [ 5 ] , ru_trucks [ 7 ] , ] , [ ru_trucks [ 2 ] , ru_trucks [ 4 ] , ru_trucks [ 6 ] ] ] ;
14604: LD_ADDR_LOC 8
14608: PUSH
14609: LD_EXP 48
14613: PUSH
14614: LD_INT 1
14616: ARRAY
14617: PUSH
14618: LD_EXP 48
14622: PUSH
14623: LD_INT 3
14625: ARRAY
14626: PUSH
14627: LD_EXP 48
14631: PUSH
14632: LD_INT 5
14634: ARRAY
14635: PUSH
14636: LD_EXP 48
14640: PUSH
14641: LD_INT 7
14643: ARRAY
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: PUSH
14651: LD_EXP 48
14655: PUSH
14656: LD_INT 2
14658: ARRAY
14659: PUSH
14660: LD_EXP 48
14664: PUSH
14665: LD_INT 4
14667: ARRAY
14668: PUSH
14669: LD_EXP 48
14673: PUSH
14674: LD_INT 6
14676: ARRAY
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: ST_TO_ADDR
// if difficulty < 3 then
14687: LD_OWVAR 67
14691: PUSH
14692: LD_INT 3
14694: LESS
14695: IFFALSE 14757
// begin fce_remove_units ( remove_soldiers [ difficulty ] ) ;
14697: LD_LOC 6
14701: PUSH
14702: LD_OWVAR 67
14706: ARRAY
14707: PPUSH
14708: CALL 14762 0 1
// fce_remove_units ( remove_bunkers [ difficulty ] ) ;
14712: LD_LOC 5
14716: PUSH
14717: LD_OWVAR 67
14721: ARRAY
14722: PPUSH
14723: CALL 14762 0 1
// fce_remove_units ( remove_drivers [ difficulty ] ) ;
14727: LD_LOC 7
14731: PUSH
14732: LD_OWVAR 67
14736: ARRAY
14737: PPUSH
14738: CALL 14762 0 1
// fce_remove_units ( remove_vehicles [ difficulty ] ) ;
14742: LD_LOC 8
14746: PUSH
14747: LD_OWVAR 67
14751: ARRAY
14752: PPUSH
14753: CALL 14762 0 1
// end ; end ;
14757: LD_VAR 0 1
14761: RET
// function fce_remove_units ( list ) ; var un ; begin
14762: LD_INT 0
14764: PPUSH
14765: PPUSH
// for un in list do
14766: LD_ADDR_VAR 0 3
14770: PUSH
14771: LD_VAR 0 1
14775: PUSH
14776: FOR_IN
14777: IFFALSE 14790
// RemoveUnit ( un ) ;
14779: LD_VAR 0 3
14783: PPUSH
14784: CALL_OW 64
14788: GO 14776
14790: POP
14791: POP
// end ; end_of_file
14792: LD_VAR 0 2
14796: RET
// var h_workshop , h_lab ; export function init_hints ; begin
14797: LD_INT 0
14799: PPUSH
// h_workshop := true ;
14800: LD_ADDR_LOC 9
14804: PUSH
14805: LD_INT 1
14807: ST_TO_ADDR
// h_lab := true ;
14808: LD_ADDR_LOC 10
14812: PUSH
14813: LD_INT 1
14815: ST_TO_ADDR
// end ;
14816: LD_VAR 0 1
14820: RET
// on BuildingComplete ( un ) do begin if ( GetBType ( un ) = b_workshop ) and ( h_workshop ) then
14821: LD_VAR 0 1
14825: PPUSH
14826: CALL_OW 266
14830: PUSH
14831: LD_INT 2
14833: EQUAL
14834: PUSH
14835: LD_LOC 9
14839: AND
14840: IFFALSE 14891
// begin h_workshop := false ;
14842: LD_ADDR_LOC 9
14846: PUSH
14847: LD_INT 0
14849: ST_TO_ADDR
// if GetTech ( tech_SolEng , you ) = state_researched then
14850: LD_INT 45
14852: PPUSH
14853: LD_EXP 1
14857: PPUSH
14858: CALL_OW 321
14862: PUSH
14863: LD_INT 2
14865: EQUAL
14866: IFFALSE 14884
// begin Hint ( Workshop2 ) ;
14868: LD_STRING Workshop2
14870: PPUSH
14871: CALL_OW 339
// Hint ( BuildingVehicles ) ;
14875: LD_STRING BuildingVehicles
14877: PPUSH
14878: CALL_OW 339
// end else
14882: GO 14891
// Hint ( Workshop1 ) ;
14884: LD_STRING Workshop1
14886: PPUSH
14887: CALL_OW 339
// end ; if ( GetBType ( un ) = b_lab ) and ( h_lab ) then
14891: LD_VAR 0 1
14895: PPUSH
14896: CALL_OW 266
14900: PUSH
14901: LD_INT 6
14903: EQUAL
14904: PUSH
14905: LD_LOC 10
14909: AND
14910: IFFALSE 14927
// begin h_lab := false ;
14912: LD_ADDR_LOC 10
14916: PUSH
14917: LD_INT 0
14919: ST_TO_ADDR
// Hint ( Laboratory ) ;
14920: LD_STRING Laboratory
14922: PPUSH
14923: CALL_OW 339
// end ; end ;
14927: PPOPN 1
14929: END
// on Contact ( side1 , side2 ) marked 11 do begin Hint ( Shift ) ;
14930: LD_STRING Shift
14932: PPUSH
14933: CALL_OW 339
// disable ( 11 ) ;
14937: LD_INT 11
14939: DISABLE_MARKED
// end ; end_of_file
14940: PPOPN 2
14942: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// if not missionNumber then
14947: LD_VAR 0 2
14951: NOT
14952: IFFALSE 14956
// exit ;
14954: GO 15057
// achiv := false ;
14956: LD_ADDR_VAR 0 7
14960: PUSH
14961: LD_INT 0
14963: ST_TO_ADDR
// case campaignNumber of 1 :
14964: LD_VAR 0 1
14968: PUSH
14969: LD_INT 1
14971: DOUBLE
14972: EQUAL
14973: IFTRUE 14977
14975: GO 14988
14977: POP
// achiv := ACH_GOTA ; 2 :
14978: LD_ADDR_VAR 0 7
14982: PUSH
14983: LD_STRING ACH_GOTA
14985: ST_TO_ADDR
14986: GO 15019
14988: LD_INT 2
14990: DOUBLE
14991: EQUAL
14992: IFTRUE 14996
14994: GO 14999
14996: POP
// ; 3 :
14997: GO 15019
14999: LD_INT 3
15001: DOUBLE
15002: EQUAL
15003: IFTRUE 15007
15005: GO 15018
15007: POP
// achiv := ACH_MOTRF ; end ;
15008: LD_ADDR_VAR 0 7
15012: PUSH
15013: LD_STRING ACH_MOTRF
15015: ST_TO_ADDR
15016: GO 15019
15018: POP
// if achiv and medal1 and medal2 and medal3 then
15019: LD_VAR 0 7
15023: PUSH
15024: LD_VAR 0 3
15028: AND
15029: PUSH
15030: LD_VAR 0 4
15034: AND
15035: PUSH
15036: LD_VAR 0 5
15040: AND
15041: IFFALSE 15057
// SetAchievementEX ( achiv , missionNumber ) ;
15043: LD_VAR 0 7
15047: PPUSH
15048: LD_VAR 0 2
15052: PPUSH
15053: CALL_OW 564
// end ;
15057: LD_VAR 0 6
15061: RET

// export you , russians , neutral ; export Bobby , Cyrus , Lisa , MacMillan , Cornell , Powell , Khatam , Frank ; export Kobra1 , other_survivors , cornells , yours ; export atack , saved_units ; export mrtvi_lide ; export JMMinvehicle , Cyrusinvehicle ; export Mikhail , rus_vehicle ; export rus_south , rus_guard1 , rus_guard2 , rus_guard3 , rus_guard4 ; export South_russian_patrol , forest_force1 , forest_force2 ; export grass_force1 , grass_force2 , grass_force3 ; export Cornell_group , amtruck1 , amtruck2 , cans , cans1 ; export Dialogue_wait , time_to_return , time_to_attack , solar_constructed , solar_saved , Meet_Frank , base_reached , cornell_lost , Frank_Query ; var time_crates ; function prepare_units ; var un , i , JMM_group , cornell_limit ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
// JMM_group := [ ] ;
   7: LD_ADDR_VAR 0 4
  11: PUSH
  12: EMPTY
  13: ST_TO_ADDR
// cornell_limit := 0 ;
  14: LD_ADDR_VAR 0 5
  18: PUSH
  19: LD_INT 0
  21: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
  22: LD_ADDR_OWVAR 24
  26: PUSH
  27: LD_INT 0
  29: PPUSH
  30: LD_INT 5
  32: PPUSH
  33: CALL_OW 12
  37: ST_TO_ADDR
// uc_nation = nation_american ;
  38: LD_ADDR_OWVAR 21
  42: PUSH
  43: LD_INT 1
  45: ST_TO_ADDR
// uc_side = you ;
  46: LD_ADDR_OWVAR 20
  50: PUSH
  51: LD_EXP 1
  55: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  56: LD_ADDR_EXP 7
  60: PUSH
  61: LD_STRING JMM
  63: PPUSH
  64: CALL_OW 34
  68: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
  69: LD_ADDR_EXP 6
  73: PUSH
  74: LD_STRING Lisa
  76: PPUSH
  77: CALL_OW 34
  81: ST_TO_ADDR
// Bobby := CreateCharacter ( Bobby ) ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_STRING Bobby
  89: PPUSH
  90: CALL_OW 34
  94: ST_TO_ADDR
// Cyrus := CreateCharacter ( Cyrus ) ;
  95: LD_ADDR_EXP 5
  99: PUSH
 100: LD_STRING Cyrus
 102: PPUSH
 103: CALL_OW 34
 107: ST_TO_ADDR
// Khatam := CreateCharacter ( Khatam ) ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_STRING Khatam
 115: PPUSH
 116: CALL_OW 34
 120: ST_TO_ADDR
// Frank := NewCharacter ( Frank ) ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_STRING Frank
 128: PPUSH
 129: CALL_OW 25
 133: ST_TO_ADDR
// Cornell := NewCharacter ( Cornell ) ;
 134: LD_ADDR_EXP 8
 138: PUSH
 139: LD_STRING Cornell
 141: PPUSH
 142: CALL_OW 25
 146: ST_TO_ADDR
// JMM_group := [ Lisa , Bobby , Cyrus , Khatam ] diff 0 ;
 147: LD_ADDR_VAR 0 4
 151: PUSH
 152: LD_EXP 6
 156: PUSH
 157: LD_EXP 4
 161: PUSH
 162: LD_EXP 5
 166: PUSH
 167: LD_EXP 10
 171: PUSH
 172: EMPTY
 173: LIST
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_INT 0
 180: DIFF
 181: ST_TO_ADDR
// PlaceUnitXY ( Cornell , 163 , 100 , false ) ;
 182: LD_EXP 8
 186: PPUSH
 187: LD_INT 163
 189: PPUSH
 190: LD_INT 100
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 48
// Powell := NewCharacter ( Powell ) ;
 200: LD_ADDR_EXP 9
 204: PUSH
 205: LD_STRING Powell
 207: PPUSH
 208: CALL_OW 25
 212: ST_TO_ADDR
// hc_gallery :=  ;
 213: LD_ADDR_OWVAR 33
 217: PUSH
 218: LD_STRING 
 220: ST_TO_ADDR
// hc_importance := 0 ;
 221: LD_ADDR_OWVAR 32
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// cornells := [ ] ;
 229: LD_ADDR_EXP 14
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// cornell_limit := 5 + ( 4 - JMM_group ) ;
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_INT 5
 243: PUSH
 244: LD_INT 4
 246: PUSH
 247: LD_VAR 0 4
 251: MINUS
 252: PLUS
 253: ST_TO_ADDR
// for i := 1 to cornell_limit do
 254: LD_ADDR_VAR 0 3
 258: PUSH
 259: DOUBLE
 260: LD_INT 1
 262: DEC
 263: ST_TO_ADDR
 264: LD_VAR 0 5
 268: PUSH
 269: FOR_TO
 270: IFFALSE 346
// begin PrepareHuman ( 2 - i mod 2 , 0 , 2 ) ;
 272: LD_INT 2
 274: PUSH
 275: LD_VAR 0 3
 279: PUSH
 280: LD_INT 2
 282: MOD
 283: MINUS
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: LD_INT 2
 290: PPUSH
 291: CALL_OW 380
// hc_class := class_soldier ;
 295: LD_ADDR_OWVAR 28
 299: PUSH
 300: LD_INT 1
 302: ST_TO_ADDR
// un := CreateHuman ;
 303: LD_ADDR_VAR 0 2
 307: PUSH
 308: CALL_OW 44
 312: ST_TO_ADDR
// cornells := cornells ^ un ;
 313: LD_ADDR_EXP 14
 317: PUSH
 318: LD_EXP 14
 322: PUSH
 323: LD_VAR 0 2
 327: ADD
 328: ST_TO_ADDR
// PlaceUnitArea ( un , cornellsarea , false ) ;
 329: LD_VAR 0 2
 333: PPUSH
 334: LD_INT 20
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 49
// end ;
 344: GO 269
 346: POP
 347: POP
// if TestCharacters ( other_survivors ) then
 348: LD_STRING other_survivors
 350: PPUSH
 351: CALL_OW 28
 355: IFFALSE 372
// other_survivors := CreateCharacterSet ( other_survivors ) else
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING other_survivors
 364: PPUSH
 365: CALL_OW 31
 369: ST_TO_ADDR
 370: GO 379
// other_survivors := [ ] ;
 372: LD_ADDR_EXP 13
 376: PUSH
 377: EMPTY
 378: ST_TO_ADDR
// uc_nation = nation_russian ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// uc_side = russians ;
 387: LD_ADDR_OWVAR 20
 391: PUSH
 392: LD_EXP 2
 396: ST_TO_ADDR
// if ( LoadVariable ( us2mikhail_state , 0 ) = 5 ) and TestCharacters ( Mikhail ) and CheckCharacterSet ( Mikhail ) then
 397: LD_STRING us2mikhail_state
 399: PPUSH
 400: LD_INT 0
 402: PPUSH
 403: CALL_OW 30
 407: PUSH
 408: LD_INT 5
 410: EQUAL
 411: PUSH
 412: LD_STRING Mikhail
 414: PPUSH
 415: CALL_OW 28
 419: AND
 420: PUSH
 421: LD_STRING Mikhail
 423: PPUSH
 424: CALL_OW 29
 428: AND
 429: IFFALSE 444
// Mikhail := CreateCharacter ( Mikhail ) ;
 431: LD_ADDR_EXP 21
 435: PUSH
 436: LD_STRING Mikhail
 438: PPUSH
 439: CALL_OW 34
 443: ST_TO_ADDR
// JMMinvehicle := LoadVariable ( us2JMMInVehicle , false ) ;
 444: LD_ADDR_EXP 19
 448: PUSH
 449: LD_STRING us2JMMInVehicle
 451: PPUSH
 452: LD_INT 0
 454: PPUSH
 455: CALL_OW 30
 459: ST_TO_ADDR
// Cyrusinvehicle := LoadVariable ( us2CyrusInVehicle , false ) ;
 460: LD_ADDR_EXP 20
 464: PUSH
 465: LD_STRING us2CyrusInVehicle
 467: PPUSH
 468: LD_INT 0
 470: PPUSH
 471: CALL_OW 30
 475: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
 476: LD_INT 2
 478: PUSH
 479: LD_INT 3
 481: PUSH
 482: LD_INT 1
 484: PUSH
 485: LD_INT 4
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: PPUSH
 494: CALL_OW 139
// Kobra1 := [ MacMillan , Bobby , Lisa , Cyrus , Mikhail , Khatam ] ^ other_survivors diff [ 0 ] ;
 498: LD_ADDR_EXP 12
 502: PUSH
 503: LD_EXP 7
 507: PUSH
 508: LD_EXP 4
 512: PUSH
 513: LD_EXP 6
 517: PUSH
 518: LD_EXP 5
 522: PUSH
 523: LD_EXP 21
 527: PUSH
 528: LD_EXP 10
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_EXP 13
 545: ADD
 546: PUSH
 547: LD_INT 0
 549: PUSH
 550: EMPTY
 551: LIST
 552: DIFF
 553: ST_TO_ADDR
// SetClass ( Kobra1 diff Mikhail , class_soldier ) ;
 554: LD_EXP 12
 558: PUSH
 559: LD_EXP 21
 563: DIFF
 564: PPUSH
 565: LD_INT 1
 567: PPUSH
 568: CALL_OW 336
// Kobra1 := Kobra1 diff [ 0 ] ;
 572: LD_ADDR_EXP 12
 576: PUSH
 577: LD_EXP 12
 581: PUSH
 582: LD_INT 0
 584: PUSH
 585: EMPTY
 586: LIST
 587: DIFF
 588: ST_TO_ADDR
// cans := LoadVariable ( us2cans , 60 ) ;
 589: LD_ADDR_EXP 37
 593: PUSH
 594: LD_STRING us2cans
 596: PPUSH
 597: LD_INT 60
 599: PPUSH
 600: CALL_OW 30
 604: ST_TO_ADDR
// if cans > 200 then
 605: LD_EXP 37
 609: PUSH
 610: LD_INT 200
 612: GREATER
 613: IFFALSE 623
// cans := 200 ;
 615: LD_ADDR_EXP 37
 619: PUSH
 620: LD_INT 200
 622: ST_TO_ADDR
// cans1 := 30 ;
 623: LD_ADDR_EXP 38
 627: PUSH
 628: LD_INT 30
 630: ST_TO_ADDR
// cans1 := cans1 + ( ( cans - 30 + 10 ) div 30 ) * 10 ;
 631: LD_ADDR_EXP 38
 635: PUSH
 636: LD_EXP 38
 640: PUSH
 641: LD_EXP 37
 645: PUSH
 646: LD_INT 30
 648: MINUS
 649: PUSH
 650: LD_INT 10
 652: PLUS
 653: PUSH
 654: LD_INT 30
 656: DIV
 657: PUSH
 658: LD_INT 10
 660: MUL
 661: PLUS
 662: ST_TO_ADDR
// if cans1 > 100 then
 663: LD_EXP 38
 667: PUSH
 668: LD_INT 100
 670: GREATER
 671: IFFALSE 681
// cans1 := 100 ;
 673: LD_ADDR_EXP 38
 677: PUSH
 678: LD_INT 100
 680: ST_TO_ADDR
// cans := cans - cans1 ;
 681: LD_ADDR_EXP 37
 685: PUSH
 686: LD_EXP 37
 690: PUSH
 691: LD_EXP 38
 695: MINUS
 696: ST_TO_ADDR
// if cans > 100 then
 697: LD_EXP 37
 701: PUSH
 702: LD_INT 100
 704: GREATER
 705: IFFALSE 715
// cans := 100 ;
 707: LD_ADDR_EXP 37
 711: PUSH
 712: LD_INT 100
 714: ST_TO_ADDR
// uc_side := you ;
 715: LD_ADDR_OWVAR 20
 719: PUSH
 720: LD_EXP 1
 724: ST_TO_ADDR
// uc_nation := nation_russian ;
 725: LD_ADDR_OWVAR 21
 729: PUSH
 730: LD_INT 3
 732: ST_TO_ADDR
// uc_direction := 5 ;
 733: LD_ADDR_OWVAR 24
 737: PUSH
 738: LD_INT 5
 740: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
 741: LD_ADDR_OWVAR 37
 745: PUSH
 746: LD_INT 22
 748: ST_TO_ADDR
// vc_engine := engine_combustion ;
 749: LD_ADDR_OWVAR 39
 753: PUSH
 754: LD_INT 1
 756: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
 757: LD_ADDR_OWVAR 40
 761: PUSH
 762: LD_INT 51
 764: ST_TO_ADDR
// vc_control := control_manual ;
 765: LD_ADDR_OWVAR 38
 769: PUSH
 770: LD_INT 1
 772: ST_TO_ADDR
// if cans1 > 0 then
 773: LD_EXP 38
 777: PUSH
 778: LD_INT 0
 780: GREATER
 781: IFFALSE 856
// begin amtruck1 := CreateVehicle ;
 783: LD_ADDR_EXP 35
 787: PUSH
 788: CALL_OW 45
 792: ST_TO_ADDR
// PlaceHumanInUnit ( Macmillan , amtruck1 ) ;
 793: LD_EXP 7
 797: PPUSH
 798: LD_EXP 35
 802: PPUSH
 803: CALL_OW 52
// SetCargo ( amtruck1 , mat_cans , cans1 ) ;
 807: LD_EXP 35
 811: PPUSH
 812: LD_INT 1
 814: PPUSH
 815: LD_EXP 38
 819: PPUSH
 820: CALL_OW 290
// SetFuel ( amtruck1 , 50 ) ;
 824: LD_EXP 35
 828: PPUSH
 829: LD_INT 50
 831: PPUSH
 832: CALL_OW 240
// PlaceUnitXY ( amtruck1 , 174 , 115 , false ) ;
 836: LD_EXP 35
 840: PPUSH
 841: LD_INT 174
 843: PPUSH
 844: LD_INT 115
 846: PPUSH
 847: LD_INT 0
 849: PPUSH
 850: CALL_OW 48
// end else
 854: GO 874
// PlaceUnitXY ( MacMillan , 174 , 115 , false ) ;
 856: LD_EXP 7
 860: PPUSH
 861: LD_INT 174
 863: PPUSH
 864: LD_INT 115
 866: PPUSH
 867: LD_INT 0
 869: PPUSH
 870: CALL_OW 48
// if ( cans > 0 ) and ( Kobra1 > 1 ) then
 874: LD_EXP 37
 878: PUSH
 879: LD_INT 0
 881: GREATER
 882: PUSH
 883: LD_EXP 12
 887: PUSH
 888: LD_INT 1
 890: GREATER
 891: AND
 892: IFFALSE 969
// begin amtruck2 := CreateVehicle ;
 894: LD_ADDR_EXP 36
 898: PUSH
 899: CALL_OW 45
 903: ST_TO_ADDR
// PlaceHumanInUnit ( Kobra1 [ 2 ] , amtruck2 ) ;
 904: LD_EXP 12
 908: PUSH
 909: LD_INT 2
 911: ARRAY
 912: PPUSH
 913: LD_EXP 36
 917: PPUSH
 918: CALL_OW 52
// SetCargo ( amtruck2 , mat_cans , cans ) ;
 922: LD_EXP 36
 926: PPUSH
 927: LD_INT 1
 929: PPUSH
 930: LD_EXP 37
 934: PPUSH
 935: CALL_OW 290
// SetFuel ( amtruck2 , 50 ) ;
 939: LD_EXP 36
 943: PPUSH
 944: LD_INT 50
 946: PPUSH
 947: CALL_OW 240
// PlaceUnitXY ( amtruck2 , 171 , 115 , false ) ;
 951: LD_EXP 36
 955: PPUSH
 956: LD_INT 171
 958: PPUSH
 959: LD_INT 115
 961: PPUSH
 962: LD_INT 0
 964: PPUSH
 965: CALL_OW 48
// end ; for un in Kobra1 do
 969: LD_ADDR_VAR 0 2
 973: PUSH
 974: LD_EXP 12
 978: PUSH
 979: FOR_IN
 980: IFFALSE 1011
// if not IsInUnit ( un ) then
 982: LD_VAR 0 2
 986: PPUSH
 987: CALL_OW 310
 991: NOT
 992: IFFALSE 1009
// PlaceUnitArea ( un , enterarea , false ) ;
 994: LD_VAR 0 2
 998: PPUSH
 999: LD_INT 19
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
1009: GO 979
1011: POP
1012: POP
// end ;
1013: LD_VAR 0 1
1017: RET
// function prepare_sides ; begin
1018: LD_INT 0
1020: PPUSH
// you = 1 ;
1021: LD_ADDR_EXP 1
1025: PUSH
1026: LD_INT 1
1028: ST_TO_ADDR
// neutral = 4 ;
1029: LD_ADDR_EXP 3
1033: PUSH
1034: LD_INT 4
1036: ST_TO_ADDR
// russians = 3 ;
1037: LD_ADDR_EXP 2
1041: PUSH
1042: LD_INT 3
1044: ST_TO_ADDR
// atack = 0 ;
1045: LD_ADDR_EXP 16
1049: PUSH
1050: LD_INT 0
1052: ST_TO_ADDR
// time_to_return := [ 25 25$0 , 12 12$0 , 2 2$0 ] [ difficulty ] ;
1053: LD_ADDR_EXP 40
1057: PUSH
1058: LD_INT 52500
1060: PUSH
1061: LD_INT 25200
1063: PUSH
1064: LD_INT 4200
1066: PUSH
1067: EMPTY
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_OWVAR 67
1076: ARRAY
1077: ST_TO_ADDR
// time_to_attack := [ 40 40$0 , 25 25$0 , 15 15$0 ] [ difficulty ] ;
1078: LD_ADDR_EXP 41
1082: PUSH
1083: LD_INT 84000
1085: PUSH
1086: LD_INT 52500
1088: PUSH
1089: LD_INT 31500
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: PUSH
1097: LD_OWVAR 67
1101: ARRAY
1102: ST_TO_ADDR
// solar_constructed := false ;
1103: LD_ADDR_EXP 42
1107: PUSH
1108: LD_INT 0
1110: ST_TO_ADDR
// solar_saved := true ;
1111: LD_ADDR_EXP 43
1115: PUSH
1116: LD_INT 1
1118: ST_TO_ADDR
// saved_units = [ ] ;
1119: LD_ADDR_EXP 17
1123: PUSH
1124: EMPTY
1125: ST_TO_ADDR
// time_crates := Rand ( 0 0$20 , 0 0$40 ) ;
1126: LD_ADDR_LOC 1
1130: PUSH
1131: LD_INT 700
1133: PPUSH
1134: LD_INT 1400
1136: PPUSH
1137: CALL_OW 12
1141: ST_TO_ADDR
// mrtvi_lide := 0 ;
1142: LD_ADDR_EXP 18
1146: PUSH
1147: LD_INT 0
1149: ST_TO_ADDR
// Meet_Frank := false ;
1150: LD_ADDR_EXP 44
1154: PUSH
1155: LD_INT 0
1157: ST_TO_ADDR
// base_reached := false ;
1158: LD_ADDR_EXP 45
1162: PUSH
1163: LD_INT 0
1165: ST_TO_ADDR
// cornell_lost := false ;
1166: LD_ADDR_EXP 46
1170: PUSH
1171: LD_INT 0
1173: ST_TO_ADDR
// Dialogue_wait := false ;
1174: LD_ADDR_EXP 39
1178: PUSH
1179: LD_INT 0
1181: ST_TO_ADDR
// forest_force1 = [ forest11 , forest12 ] ;
1182: LD_ADDR_EXP 29
1186: PUSH
1187: LD_INT 26
1189: PUSH
1190: LD_INT 25
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: ST_TO_ADDR
// forest_force2 = [ forest21 , forest22 ] ;
1197: LD_ADDR_EXP 30
1201: PUSH
1202: LD_INT 41
1204: PUSH
1205: LD_INT 42
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// ComEnterUnit ( guard1 , bunker1 ) ;
1212: LD_INT 30
1214: PPUSH
1215: LD_INT 28
1217: PPUSH
1218: CALL_OW 120
// ComEnterUnit ( guard2 , bunker2 ) ;
1222: LD_INT 29
1224: PPUSH
1225: LD_INT 27
1227: PPUSH
1228: CALL_OW 120
// ComEnterUnit ( guard3 , bunker3 ) ;
1232: LD_INT 48
1234: PPUSH
1235: LD_INT 34
1237: PPUSH
1238: CALL_OW 120
// ComEnterUnit ( guard4 , bunker4 ) ;
1242: LD_INT 47
1244: PPUSH
1245: LD_INT 33
1247: PPUSH
1248: CALL_OW 120
// ComEnterUnit ( guard5 , bunker5 ) ;
1252: LD_INT 49
1254: PPUSH
1255: LD_INT 32
1257: PPUSH
1258: CALL_OW 120
// ComEnterUnit ( guard6 , bunker6 ) ;
1262: LD_INT 20
1264: PPUSH
1265: LD_INT 31
1267: PPUSH
1268: CALL_OW 120
// ComEnterUnit ( guard7 , bunker7 ) ;
1272: LD_INT 53
1274: PPUSH
1275: LD_INT 52
1277: PPUSH
1278: CALL_OW 120
// ComEnterUnit ( maker_1 , factory1 ) ;
1282: LD_INT 16
1284: PPUSH
1285: LD_INT 11
1287: PPUSH
1288: CALL_OW 120
// ComEnterUnit ( maker_2 , factory2 ) ;
1292: LD_INT 46
1294: PPUSH
1295: LD_INT 10
1297: PPUSH
1298: CALL_OW 120
// ComEnterUnit ( sci1 , labor1 ) ;
1302: LD_INT 18
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: CALL_OW 120
// ComHold ( am1 ) ;
1312: LD_INT 2
1314: PPUSH
1315: CALL_OW 140
// SetAttitude ( russians , you , att_friend , true ) ;
1319: LD_EXP 2
1323: PPUSH
1324: LD_EXP 1
1328: PPUSH
1329: LD_INT 1
1331: PPUSH
1332: LD_INT 1
1334: PPUSH
1335: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
1339: LD_EXP 1
1343: PPUSH
1344: LD_EXP 3
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: LD_INT 1
1354: PPUSH
1355: CALL_OW 80
// SetAttitude ( russians , neutral , att_friend , true ) ;
1359: LD_EXP 2
1363: PPUSH
1364: LD_EXP 3
1368: PPUSH
1369: LD_INT 1
1371: PPUSH
1372: LD_INT 1
1374: PPUSH
1375: CALL_OW 80
// disable ( 1 ) ;
1379: LD_INT 1
1381: DISABLE_MARKED
// disable ( 2 ) ;
1382: LD_INT 2
1384: DISABLE_MARKED
// disable ( 3 ) ;
1385: LD_INT 3
1387: DISABLE_MARKED
// disable ( 4 ) ;
1388: LD_INT 4
1390: DISABLE_MARKED
// disable ( 5 ) ;
1391: LD_INT 5
1393: DISABLE_MARKED
// disable ( 7 ) ;
1394: LD_INT 7
1396: DISABLE_MARKED
// disable ( 8 ) ;
1397: LD_INT 8
1399: DISABLE_MARKED
// disable ( 10 ) ;
1400: LD_INT 10
1402: DISABLE_MARKED
// enable ( 11 ) ;
1403: LD_INT 11
1405: ENABLE_MARKED
// end ;
1406: LD_VAR 0 1
1410: RET
// starting begin interface_hidden := true ;
1411: LD_ADDR_OWVAR 54
1415: PUSH
1416: LD_INT 1
1418: ST_TO_ADDR
// RandomizeAll ;
1419: CALL_OW 11
// prepare_sides ;
1423: CALL 1018 0 0
// prepare_russian_side ;
1427: CALL 12947 0 0
// fix_difficulty ;
1431: CALL 14460 0 0
// prepare_units ;
1435: CALL 0 0 0
// starting_scene ;
1439: CALL 8505 0 0
// init_hints ;
1443: CALL 14813 0 0
// run_ru_guarding ;
1447: CALL 4033 0 0
// end ;
1451: END
// every 0 0$5 trigger TICK >= time_crates do
1452: LD_OWVAR 1
1456: PUSH
1457: LD_LOC 1
1461: GREATEREQUAL
1462: IFFALSE 1511
1464: GO 1466
1466: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 3 ) , Am_Base , true ) ;
1467: LD_INT 2
1469: PPUSH
1470: LD_INT 3
1472: PPUSH
1473: CALL_OW 12
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: CALL_OW 55
// time_crates := TICK + Rand ( 0 0$50 , 0 0$100 ) ;
1488: LD_ADDR_LOC 1
1492: PUSH
1493: LD_OWVAR 1
1497: PUSH
1498: LD_INT 1750
1500: PPUSH
1501: LD_INT 3500
1503: PPUSH
1504: CALL_OW 12
1508: PLUS
1509: ST_TO_ADDR
// enable ;
1510: ENABLE
// end ;
1511: END
// function Konec_Mise ; var m1 , m2 , m3 , dying_units , units_for_save , medal1 , medal2 , medal3 ; begin
1512: LD_INT 0
1514: PPUSH
1515: PPUSH
1516: PPUSH
1517: PPUSH
1518: PPUSH
1519: PPUSH
1520: PPUSH
1521: PPUSH
1522: PPUSH
// wait ( 5 ) ;
1523: LD_INT 5
1525: PPUSH
1526: CALL_OW 67
// gained_medals := [ ] ;
1530: LD_ADDR_OWVAR 61
1534: PUSH
1535: EMPTY
1536: ST_TO_ADDR
// missing_medals := [ ] ;
1537: LD_ADDR_OWVAR 62
1541: PUSH
1542: EMPTY
1543: ST_TO_ADDR
// dying_units := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_ok ] ] ) diff MacMillan ;
1544: LD_ADDR_VAR 0 5
1548: PUSH
1549: LD_INT 22
1551: PUSH
1552: LD_EXP 1
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 21
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 50
1576: PUSH
1577: EMPTY
1578: LIST
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: LIST
1584: LIST
1585: PPUSH
1586: CALL_OW 69
1590: PUSH
1591: LD_EXP 7
1595: DIFF
1596: ST_TO_ADDR
// mrtvi_lide := mrtvi_lide + dying_units ;
1597: LD_ADDR_EXP 18
1601: PUSH
1602: LD_EXP 18
1606: PUSH
1607: LD_VAR 0 5
1611: PLUS
1612: ST_TO_ADDR
// saved_units := saved_units diff mrtvi_lide ;
1613: LD_ADDR_EXP 17
1617: PUSH
1618: LD_EXP 17
1622: PUSH
1623: LD_EXP 18
1627: DIFF
1628: ST_TO_ADDR
// if IsDead ( MacMillan ) or IsDying ( MacMillan ) then
1629: LD_EXP 7
1633: PPUSH
1634: CALL_OW 301
1638: PUSH
1639: LD_EXP 7
1643: PPUSH
1644: CALL_OW 303
1648: OR
1649: IFFALSE 1660
// begin YouLost ( 0 ) ;
1651: LD_STRING 0
1653: PPUSH
1654: CALL_OW 104
// exit ;
1658: GO 2183
// end ; if saved_units and not base_reached then
1660: LD_EXP 17
1664: PUSH
1665: LD_EXP 45
1669: NOT
1670: AND
1671: IFFALSE 1682
// begin YouLost ( 4 ) ;
1673: LD_STRING 4
1675: PPUSH
1676: CALL_OW 104
// exit ;
1680: GO 2183
// end ; if saved_units < 4 then
1682: LD_EXP 17
1686: PUSH
1687: LD_INT 4
1689: LESS
1690: IFFALSE 1701
// begin YouLost ( 1 ) ;
1692: LD_STRING 1
1694: PPUSH
1695: CALL_OW 104
// exit ;
1699: GO 2183
// end ; if IsOK ( MacMillan ) then
1701: LD_EXP 7
1705: PPUSH
1706: CALL_OW 302
1710: IFFALSE 1758
// begin m1 := IsInUnit ( MacMillan ) ;
1712: LD_ADDR_VAR 0 2
1716: PUSH
1717: LD_EXP 7
1721: PPUSH
1722: CALL_OW 310
1726: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
1727: LD_EXP 7
1731: PPUSH
1732: CALL_OW 64
// if m1 then
1736: LD_VAR 0 2
1740: IFFALSE 1751
// RemoveUnit ( m1 ) ;
1742: LD_VAR 0 2
1746: PPUSH
1747: CALL_OW 64
// wait ( 20 ) ;
1751: LD_INT 20
1753: PPUSH
1754: CALL_OW 67
// end ; if not mrtvi_lide then
1758: LD_EXP 18
1762: NOT
1763: IFFALSE 1773
// medal1 := true ;
1765: LD_ADDR_VAR 0 7
1769: PUSH
1770: LD_INT 1
1772: ST_TO_ADDR
// AddMedal ( No , not mrtvi_lide ) ;
1773: LD_STRING No
1775: PPUSH
1776: LD_EXP 18
1780: NOT
1781: PPUSH
1782: CALL_OW 101
// AddMedal ( Solar1 , solar_constructed ) ;
1786: LD_STRING Solar1
1788: PPUSH
1789: LD_EXP 42
1793: PPUSH
1794: CALL_OW 101
// if solar_constructed then
1798: LD_EXP 42
1802: IFFALSE 1851
// begin medal2 := true ;
1804: LD_ADDR_VAR 0 8
1808: PUSH
1809: LD_INT 1
1811: ST_TO_ADDR
// if solar_saved then
1812: LD_EXP 43
1816: IFFALSE 1838
// begin AddMedal ( Solar2 , 1 ) ;
1818: LD_STRING Solar2
1820: PPUSH
1821: LD_INT 1
1823: PPUSH
1824: CALL_OW 101
// medal3 := true ;
1828: LD_ADDR_VAR 0 9
1832: PUSH
1833: LD_INT 1
1835: ST_TO_ADDR
// end else
1836: GO 1849
// AddMedal ( Solar2 , - 2 ) ;
1838: LD_STRING Solar2
1840: PPUSH
1841: LD_INT 2
1843: NEG
1844: PPUSH
1845: CALL_OW 101
// end else
1849: GO 1862
// AddMedal ( Solar2 , - 1 ) ;
1851: LD_STRING Solar2
1853: PPUSH
1854: LD_INT 1
1856: NEG
1857: PPUSH
1858: CALL_OW 101
// if TICK > time_to_attack then
1862: LD_OWVAR 1
1866: PUSH
1867: LD_EXP 41
1871: GREATER
1872: IFFALSE 1878
// SA_OneStepAhead ;
1874: CALL 14989 0 0
// SA_EndMission ( 1 , 3 , medal1 , medal2 , medal3 ) ;
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 3
1883: PPUSH
1884: LD_VAR 0 7
1888: PPUSH
1889: LD_VAR 0 8
1893: PPUSH
1894: LD_VAR 0 9
1898: PPUSH
1899: CALL 15099 0 5
// GiveMedals ( Main ) ;
1903: LD_STRING Main
1905: PPUSH
1906: CALL_OW 102
// saved_units := saved_units diff 0 ;
1910: LD_ADDR_EXP 17
1914: PUSH
1915: LD_EXP 17
1919: PUSH
1920: LD_INT 0
1922: DIFF
1923: ST_TO_ADDR
// if Meet_Frank then
1924: LD_EXP 44
1928: IFFALSE 1946
// saved_units := saved_units union Frank ;
1930: LD_ADDR_EXP 17
1934: PUSH
1935: LD_EXP 17
1939: PUSH
1940: LD_EXP 11
1944: UNION
1945: ST_TO_ADDR
// RewardPeople ( saved_units union MacMillan ) ;
1946: LD_EXP 17
1950: PUSH
1951: LD_EXP 7
1955: UNION
1956: PPUSH
1957: CALL_OW 43
// DeleteVariable ( us2cans ) ;
1961: LD_STRING us2cans
1963: PPUSH
1964: CALL_OW 41
// DeleteVariable ( us2JMMInVehicle ) ;
1968: LD_STRING us2JMMInVehicle
1970: PPUSH
1971: CALL_OW 41
// DeleteVariable ( us2CyrusInVehicle ) ;
1975: LD_STRING us2CyrusInVehicle
1977: PPUSH
1978: CALL_OW 41
// SaveCharacters ( MacMillan , JMM ) ;
1982: LD_EXP 7
1986: PPUSH
1987: LD_STRING JMM
1989: PPUSH
1990: CALL_OW 38
// SaveCharacters ( Cyrus , Cyrus ) ;
1994: LD_EXP 5
1998: PPUSH
1999: LD_STRING Cyrus
2001: PPUSH
2002: CALL_OW 38
// SaveCharacters ( Bobby , Bobby ) ;
2006: LD_EXP 4
2010: PPUSH
2011: LD_STRING Bobby
2013: PPUSH
2014: CALL_OW 38
// SaveCharacters ( Lisa , Lisa ) ;
2018: LD_EXP 6
2022: PPUSH
2023: LD_STRING Lisa
2025: PPUSH
2026: CALL_OW 38
// SaveCharacters ( Khatam , Khatam ) ;
2030: LD_EXP 10
2034: PPUSH
2035: LD_STRING Khatam
2037: PPUSH
2038: CALL_OW 38
// if Meet_Frank then
2042: LD_EXP 44
2046: IFFALSE 2060
// SaveCharacters ( Frank , Frank ) ;
2048: LD_EXP 11
2052: PPUSH
2053: LD_STRING Frank
2055: PPUSH
2056: CALL_OW 38
// SaveCharacters ( Mikhail , Mikhail ) ;
2060: LD_EXP 21
2064: PPUSH
2065: LD_STRING Mikhail
2067: PPUSH
2068: CALL_OW 38
// SaveCharacters ( Cornell , Cornell ) ;
2072: LD_EXP 8
2076: PPUSH
2077: LD_STRING Cornell
2079: PPUSH
2080: CALL_OW 38
// units_for_save := other_survivors ^ saved_units ;
2084: LD_ADDR_VAR 0 6
2088: PUSH
2089: LD_EXP 13
2093: PUSH
2094: LD_EXP 17
2098: ADD
2099: ST_TO_ADDR
// units_for_save := units_for_save diff [ MacMillan , Frank , Cyrus , Bobby , Lisa , Khatam ] ;
2100: LD_ADDR_VAR 0 6
2104: PUSH
2105: LD_VAR 0 6
2109: PUSH
2110: LD_EXP 7
2114: PUSH
2115: LD_EXP 11
2119: PUSH
2120: LD_EXP 5
2124: PUSH
2125: LD_EXP 4
2129: PUSH
2130: LD_EXP 6
2134: PUSH
2135: LD_EXP 10
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: DIFF
2148: ST_TO_ADDR
// units_for_save := units_for_save union units_for_save ;
2149: LD_ADDR_VAR 0 6
2153: PUSH
2154: LD_VAR 0 6
2158: PUSH
2159: LD_VAR 0 6
2163: UNION
2164: ST_TO_ADDR
// SaveCharacters ( units_for_save , other_survivors ) ;
2165: LD_VAR 0 6
2169: PPUSH
2170: LD_STRING other_survivors
2172: PPUSH
2173: CALL_OW 38
// YouWin ;
2177: CALL_OW 103
// exit ;
2181: GO 2183
// end ;
2183: LD_VAR 0 1
2187: RET
// function return_of_frank ; var koncova_area ; begin
2188: LD_INT 0
2190: PPUSH
2191: PPUSH
// koncova_area := true ;
2192: LD_ADDR_VAR 0 2
2196: PUSH
2197: LD_INT 1
2199: ST_TO_ADDR
// SetSide ( Frank , you ) ;
2200: LD_EXP 11
2204: PPUSH
2205: LD_EXP 1
2209: PPUSH
2210: CALL_OW 235
// case koncova_area of IsInArea ( MacMillan , Top_1 ) :
2214: LD_VAR 0 2
2218: PUSH
2219: LD_EXP 7
2223: PPUSH
2224: LD_INT 13
2226: PPUSH
2227: CALL_OW 308
2231: DOUBLE
2232: EQUAL
2233: IFTRUE 2237
2235: GO 2255
2237: POP
// PlaceUnitArea ( Frank , frank_1 , false ) ; IsInArea ( MacMillan , Top_2 ) :
2238: LD_EXP 11
2242: PPUSH
2243: LD_INT 21
2245: PPUSH
2246: LD_INT 0
2248: PPUSH
2249: CALL_OW 49
2253: GO 2436
2255: LD_EXP 7
2259: PPUSH
2260: LD_INT 14
2262: PPUSH
2263: CALL_OW 308
2267: DOUBLE
2268: EQUAL
2269: IFTRUE 2273
2271: GO 2291
2273: POP
// PlaceUnitArea ( Frank , frank_2 , false ) ; IsInArea ( MacMillan , Top_3 ) :
2274: LD_EXP 11
2278: PPUSH
2279: LD_INT 22
2281: PPUSH
2282: LD_INT 0
2284: PPUSH
2285: CALL_OW 49
2289: GO 2436
2291: LD_EXP 7
2295: PPUSH
2296: LD_INT 15
2298: PPUSH
2299: CALL_OW 308
2303: DOUBLE
2304: EQUAL
2305: IFTRUE 2309
2307: GO 2327
2309: POP
// PlaceUnitArea ( Frank , frank_3 , false ) ; IsInArea ( MacMillan , Top_4 ) :
2310: LD_EXP 11
2314: PPUSH
2315: LD_INT 23
2317: PPUSH
2318: LD_INT 0
2320: PPUSH
2321: CALL_OW 49
2325: GO 2436
2327: LD_EXP 7
2331: PPUSH
2332: LD_INT 16
2334: PPUSH
2335: CALL_OW 308
2339: DOUBLE
2340: EQUAL
2341: IFTRUE 2345
2343: GO 2363
2345: POP
// PlaceUnitArea ( Frank , frank_4 , false ) ; IsInArea ( MacMillan , Top_5 ) :
2346: LD_EXP 11
2350: PPUSH
2351: LD_INT 24
2353: PPUSH
2354: LD_INT 0
2356: PPUSH
2357: CALL_OW 49
2361: GO 2436
2363: LD_EXP 7
2367: PPUSH
2368: LD_INT 17
2370: PPUSH
2371: CALL_OW 308
2375: DOUBLE
2376: EQUAL
2377: IFTRUE 2381
2379: GO 2399
2381: POP
// PlaceUnitArea ( Frank , frank_5 , false ) ; IsInArea ( MacMillan , Top_6 ) :
2382: LD_EXP 11
2386: PPUSH
2387: LD_INT 25
2389: PPUSH
2390: LD_INT 0
2392: PPUSH
2393: CALL_OW 49
2397: GO 2436
2399: LD_EXP 7
2403: PPUSH
2404: LD_INT 18
2406: PPUSH
2407: CALL_OW 308
2411: DOUBLE
2412: EQUAL
2413: IFTRUE 2417
2415: GO 2435
2417: POP
// PlaceUnitArea ( Frank , frank_6 , false ) ; end ;
2418: LD_EXP 11
2422: PPUSH
2423: LD_INT 26
2425: PPUSH
2426: LD_INT 0
2428: PPUSH
2429: CALL_OW 49
2433: GO 2436
2435: POP
// wait ( 10 ) ;
2436: LD_INT 10
2438: PPUSH
2439: CALL_OW 67
// ComRemember ( Frank ) ;
2443: LD_EXP 11
2447: PPUSH
2448: CALL_OW 143
// ComMoveUnit ( Frank , MacMillan ) ;
2452: LD_EXP 11
2456: PPUSH
2457: LD_EXP 7
2461: PPUSH
2462: CALL_OW 112
// Wait ( 0 0$2 ) ;
2466: LD_INT 70
2468: PPUSH
2469: CALL_OW 67
// ComStop ( Frank ) ;
2473: LD_EXP 11
2477: PPUSH
2478: CALL_OW 141
// ComTurnUnit ( Frank , MacMillan ) ;
2482: LD_EXP 11
2486: PPUSH
2487: LD_EXP 7
2491: PPUSH
2492: CALL_OW 119
// CenterOnUnits ( Frank ) ;
2496: LD_EXP 11
2500: PPUSH
2501: CALL_OW 85
// wait ( 20 ) ;
2505: LD_INT 20
2507: PPUSH
2508: CALL_OW 67
// DialogueOn ;
2512: CALL_OW 6
// interface_hidden := true ;
2516: LD_ADDR_OWVAR 54
2520: PUSH
2521: LD_INT 1
2523: ST_TO_ADDR
// Say ( Frank , D6a-Frank-1 ) ;
2524: LD_EXP 11
2528: PPUSH
2529: LD_STRING D6a-Frank-1
2531: PPUSH
2532: CALL_OW 88
// interface_hidden := false ;
2536: LD_ADDR_OWVAR 54
2540: PUSH
2541: LD_INT 0
2543: ST_TO_ADDR
// DialogueOff ;
2544: CALL_OW 7
// ComReturn ( Frank ) ;
2548: LD_EXP 11
2552: PPUSH
2553: CALL_OW 144
// repeat wait ( 10 ) ;
2557: LD_INT 10
2559: PPUSH
2560: CALL_OW 67
// if GetLives ( Frank ) < 900 then
2564: LD_EXP 11
2568: PPUSH
2569: CALL_OW 256
2573: PUSH
2574: LD_INT 900
2576: LESS
2577: IFFALSE 2602
// SetLives ( Frank , GetLives ( Frank ) + 50 ) ;
2579: LD_EXP 11
2583: PPUSH
2584: LD_EXP 11
2588: PPUSH
2589: CALL_OW 256
2593: PUSH
2594: LD_INT 50
2596: PLUS
2597: PPUSH
2598: CALL_OW 234
// until not HasTask ( Frank ) ;
2602: LD_EXP 11
2606: PPUSH
2607: CALL_OW 314
2611: NOT
2612: IFFALSE 2557
// RemoveUnit ( Frank ) ;
2614: LD_EXP 11
2618: PPUSH
2619: CALL_OW 64
// end ;
2623: LD_VAR 0 1
2627: RET
// export function GridY ( un ) ; var veh , grid ; begin
2628: LD_INT 0
2630: PPUSH
2631: PPUSH
2632: PPUSH
// veh := false ;
2633: LD_ADDR_VAR 0 3
2637: PUSH
2638: LD_INT 0
2640: ST_TO_ADDR
// veh := IsInUnit ( un ) ;
2641: LD_ADDR_VAR 0 3
2645: PUSH
2646: LD_VAR 0 1
2650: PPUSH
2651: CALL_OW 310
2655: ST_TO_ADDR
// if veh then
2656: LD_VAR 0 3
2660: IFFALSE 2679
// grid := GetY ( veh ) else
2662: LD_ADDR_VAR 0 4
2666: PUSH
2667: LD_VAR 0 3
2671: PPUSH
2672: CALL_OW 251
2676: ST_TO_ADDR
2677: GO 2694
// grid := GetY ( un ) ;
2679: LD_ADDR_VAR 0 4
2683: PUSH
2684: LD_VAR 0 1
2688: PPUSH
2689: CALL_OW 251
2693: ST_TO_ADDR
// result := grid ;
2694: LD_ADDR_VAR 0 2
2698: PUSH
2699: LD_VAR 0 4
2703: ST_TO_ADDR
// end ;
2704: LD_VAR 0 2
2708: RET
// every 0 0$1 trigger GridY ( MacMillan ) < 18 do var un ;
2709: LD_EXP 7
2713: PPUSH
2714: CALL 2628 0 1
2718: PUSH
2719: LD_INT 18
2721: LESS
2722: IFFALSE 2751
2724: GO 2726
2726: DISABLE
2727: LD_INT 0
2729: PPUSH
// begin if GetSide ( Frank ) = neutral then
2730: LD_EXP 11
2734: PPUSH
2735: CALL_OW 255
2739: PUSH
2740: LD_EXP 3
2744: EQUAL
2745: IFFALSE 2751
// return_of_frank ;
2747: CALL 2188 0 0
// end ;
2751: PPOPN 1
2753: END
// on UnitDestroyed ( un ) do begin if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_human ) then
2754: LD_VAR 0 1
2758: PPUSH
2759: CALL_OW 255
2763: PUSH
2764: LD_EXP 1
2768: EQUAL
2769: PUSH
2770: LD_VAR 0 1
2774: PPUSH
2775: CALL_OW 247
2779: PUSH
2780: LD_INT 1
2782: EQUAL
2783: AND
2784: IFFALSE 2800
// mrtvi_lide := mrtvi_lide + 1 ;
2786: LD_ADDR_EXP 18
2790: PUSH
2791: LD_EXP 18
2795: PUSH
2796: LD_INT 1
2798: PLUS
2799: ST_TO_ADDR
// if un = MacMillan then
2800: LD_VAR 0 1
2804: PUSH
2805: LD_EXP 7
2809: EQUAL
2810: IFFALSE 2816
// Konec_Mise ;
2812: CALL 1512 0 0
// if un = sklad then
2816: LD_VAR 0 1
2820: PUSH
2821: LD_INT 5
2823: EQUAL
2824: IFFALSE 2835
// begin YouLost ( 2 ) ;
2826: LD_STRING 2
2828: PPUSH
2829: CALL_OW 104
// exit ;
2833: GO 2851
// end ; ru_trucks := ru_trucks diff un ;
2835: LD_ADDR_EXP 48
2839: PUSH
2840: LD_EXP 48
2844: PUSH
2845: LD_VAR 0 1
2849: DIFF
2850: ST_TO_ADDR
// end ;
2851: PPOPN 1
2853: END
// every 0 0$5.1 do
2854: GO 2856
2856: DISABLE
// begin if ( ( FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_lives , 0 ] , [ f_type , unit_human ] ] ) diff MacMillan ) + saved_units ) < 4 then
2857: LD_INT 23
2859: PUSH
2860: LD_INT 1
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: PUSH
2867: LD_INT 24
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: EMPTY
2874: LIST
2875: LIST
2876: PUSH
2877: LD_INT 21
2879: PUSH
2880: LD_INT 1
2882: PUSH
2883: EMPTY
2884: LIST
2885: LIST
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: LIST
2891: PPUSH
2892: CALL_OW 69
2896: PUSH
2897: LD_EXP 7
2901: DIFF
2902: PUSH
2903: LD_EXP 17
2907: PLUS
2908: PUSH
2909: LD_INT 4
2911: LESS
2912: IFFALSE 2918
// Konec_Mise ;
2914: CALL 1512 0 0
// enable ;
2918: ENABLE
// end ;
2919: END
// every 0 0$1 trigger IsInArea ( MacMillan , TopBorder ) or IsInArea ( IsInUnit ( MacMillan ) , TopBorder ) do var un , list , car , isin , living ;
2920: LD_EXP 7
2924: PPUSH
2925: LD_INT 1
2927: PPUSH
2928: CALL_OW 308
2932: PUSH
2933: LD_EXP 7
2937: PPUSH
2938: CALL_OW 310
2942: PPUSH
2943: LD_INT 1
2945: PPUSH
2946: CALL_OW 308
2950: OR
2951: IFFALSE 3484
2953: GO 2955
2955: DISABLE
2956: LD_INT 0
2958: PPUSH
2959: PPUSH
2960: PPUSH
2961: PPUSH
2962: PPUSH
// begin living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
2963: LD_ADDR_VAR 0 5
2967: PUSH
2968: LD_INT 22
2970: PUSH
2971: LD_EXP 1
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PUSH
2980: LD_INT 21
2982: PUSH
2983: LD_INT 1
2985: PUSH
2986: EMPTY
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 50
2992: PUSH
2993: EMPTY
2994: LIST
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: LIST
3000: PPUSH
3001: CALL_OW 69
3005: PUSH
3006: LD_EXP 7
3010: DIFF
3011: ST_TO_ADDR
// car := IsInUnit ( MacMillan ) ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: LD_EXP 7
3021: PPUSH
3022: CALL_OW 310
3026: ST_TO_ADDR
// if not living then
3027: LD_VAR 0 5
3031: NOT
3032: IFFALSE 3089
// begin RemoveUnit ( MacMillan ) ;
3034: LD_EXP 7
3038: PPUSH
3039: CALL_OW 64
// if car then
3043: LD_VAR 0 3
3047: IFFALSE 3081
// begin if GetEngine ( car ) = engine_solar then
3049: LD_VAR 0 3
3053: PPUSH
3054: CALL_OW 262
3058: PUSH
3059: LD_INT 2
3061: EQUAL
3062: IFFALSE 3072
// solar_saved := true ;
3064: LD_ADDR_EXP 43
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// RemoveUnit ( car ) ;
3072: LD_VAR 0 3
3076: PPUSH
3077: CALL_OW 64
// end ; Konec_mise ;
3081: CALL 1512 0 0
// exit ;
3085: GO 3484
// end else
3087: GO 3483
// if Query ( Q2 ) = 1 then
3089: LD_STRING Q2
3091: PPUSH
3092: CALL_OW 97
3096: PUSH
3097: LD_INT 1
3099: EQUAL
3100: IFFALSE 3265
// begin repeat wait ( 0 0$1 ) ;
3102: LD_INT 35
3104: PPUSH
3105: CALL_OW 67
// living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff MacMillan ;
3109: LD_ADDR_VAR 0 5
3113: PUSH
3114: LD_INT 22
3116: PUSH
3117: LD_EXP 1
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: LD_INT 21
3128: PUSH
3129: LD_INT 1
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 50
3138: PUSH
3139: EMPTY
3140: LIST
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: PPUSH
3147: CALL_OW 69
3151: PUSH
3152: LD_EXP 7
3156: DIFF
3157: ST_TO_ADDR
// isin := IsInArea ( MacMillan , TopBorder ) ;
3158: LD_ADDR_VAR 0 4
3162: PUSH
3163: LD_EXP 7
3167: PPUSH
3168: LD_INT 1
3170: PPUSH
3171: CALL_OW 308
3175: ST_TO_ADDR
// until not ( living and isin ) ;
3176: LD_VAR 0 5
3180: PUSH
3181: LD_VAR 0 4
3185: AND
3186: NOT
3187: IFFALSE 3102
// if isin then
3189: LD_VAR 0 4
3193: IFFALSE 3263
// begin car := IsInUnit ( MacMillan ) ;
3195: LD_ADDR_VAR 0 3
3199: PUSH
3200: LD_EXP 7
3204: PPUSH
3205: CALL_OW 310
3209: ST_TO_ADDR
// RemoveUnit ( MacMillan ) ;
3210: LD_EXP 7
3214: PPUSH
3215: CALL_OW 64
// if car then
3219: LD_VAR 0 3
3223: IFFALSE 3257
// begin if GetEngine ( car ) = engine_solar then
3225: LD_VAR 0 3
3229: PPUSH
3230: CALL_OW 262
3234: PUSH
3235: LD_INT 2
3237: EQUAL
3238: IFFALSE 3248
// solar_saved := true ;
3240: LD_ADDR_EXP 43
3244: PUSH
3245: LD_INT 1
3247: ST_TO_ADDR
// RemoveUnit ( car ) ;
3248: LD_VAR 0 3
3252: PPUSH
3253: CALL_OW 64
// end ; Konec_mise ;
3257: CALL 1512 0 0
// exit ;
3261: GO 3484
// end ; end else
3263: GO 3483
// begin RemoveUnit ( MacMillan ) ;
3265: LD_EXP 7
3269: PPUSH
3270: CALL_OW 64
// if car then
3274: LD_VAR 0 3
3278: IFFALSE 3312
// begin if GetEngine ( car ) = engine_solar then
3280: LD_VAR 0 3
3284: PPUSH
3285: CALL_OW 262
3289: PUSH
3290: LD_INT 2
3292: EQUAL
3293: IFFALSE 3303
// solar_saved := true ;
3295: LD_ADDR_EXP 43
3299: PUSH
3300: LD_INT 1
3302: ST_TO_ADDR
// RemoveUnit ( car ) ;
3303: LD_VAR 0 3
3307: PPUSH
3308: CALL_OW 64
// end ; ingame_video := true ;
3312: LD_ADDR_OWVAR 52
3316: PUSH
3317: LD_INT 1
3319: ST_TO_ADDR
// interface_hidden := true ;
3320: LD_ADDR_OWVAR 54
3324: PUSH
3325: LD_INT 1
3327: ST_TO_ADDR
// repeat living := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3328: LD_ADDR_VAR 0 5
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_EXP 1
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: PUSH
3345: LD_INT 21
3347: PUSH
3348: LD_INT 1
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: PUSH
3355: LD_INT 50
3357: PUSH
3358: EMPTY
3359: LIST
3360: PUSH
3361: EMPTY
3362: LIST
3363: LIST
3364: LIST
3365: PPUSH
3366: CALL_OW 69
3370: ST_TO_ADDR
// CenterOnNorthestUnit ( living ) ;
3371: LD_VAR 0 5
3375: PPUSH
3376: CALL 3487 0 1
// for un in living do
3380: LD_ADDR_VAR 0 1
3384: PUSH
3385: LD_VAR 0 5
3389: PUSH
3390: FOR_IN
3391: IFFALSE 3453
// ComMoveXY ( un , GetX ( un ) - ( GetY ( un ) div 2 ) + Rand ( - 3 , 3 ) , Rand ( 1 , 2 ) ) ;
3393: LD_VAR 0 1
3397: PPUSH
3398: LD_VAR 0 1
3402: PPUSH
3403: CALL_OW 250
3407: PUSH
3408: LD_VAR 0 1
3412: PPUSH
3413: CALL_OW 251
3417: PUSH
3418: LD_INT 2
3420: DIV
3421: MINUS
3422: PUSH
3423: LD_INT 3
3425: NEG
3426: PPUSH
3427: LD_INT 3
3429: PPUSH
3430: CALL_OW 12
3434: PLUS
3435: PPUSH
3436: LD_INT 1
3438: PPUSH
3439: LD_INT 2
3441: PPUSH
3442: CALL_OW 12
3446: PPUSH
3447: CALL_OW 111
3451: GO 3390
3453: POP
3454: POP
// wait ( 0 0$3 ) ;
3455: LD_INT 105
3457: PPUSH
3458: CALL_OW 67
// until not living ;
3462: LD_VAR 0 5
3466: NOT
3467: IFFALSE 3328
// ingame_video := false ;
3469: LD_ADDR_OWVAR 52
3473: PUSH
3474: LD_INT 0
3476: ST_TO_ADDR
// Konec_mise ;
3477: CALL 1512 0 0
// exit ;
3481: GO 3484
// end ; enable ;
3483: ENABLE
// end ;
3484: PPOPN 5
3486: END
// function CenterOnNorthestUnit ( list ) ; var un , north , x , y , car ; begin
3487: LD_INT 0
3489: PPUSH
3490: PPUSH
3491: PPUSH
3492: PPUSH
3493: PPUSH
3494: PPUSH
// north := 200 ;
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: LD_INT 200
3502: ST_TO_ADDR
// for un in list do
3503: LD_ADDR_VAR 0 3
3507: PUSH
3508: LD_VAR 0 1
3512: PUSH
3513: FOR_IN
3514: IFFALSE 3623
// begin car := IsInUnit ( un ) ;
3516: LD_ADDR_VAR 0 7
3520: PUSH
3521: LD_VAR 0 3
3525: PPUSH
3526: CALL_OW 310
3530: ST_TO_ADDR
// if car then
3531: LD_VAR 0 7
3535: IFFALSE 3569
// begin x := GetX ( car ) ;
3537: LD_ADDR_VAR 0 5
3541: PUSH
3542: LD_VAR 0 7
3546: PPUSH
3547: CALL_OW 250
3551: ST_TO_ADDR
// y := GetY ( car ) ;
3552: LD_ADDR_VAR 0 6
3556: PUSH
3557: LD_VAR 0 7
3561: PPUSH
3562: CALL_OW 251
3566: ST_TO_ADDR
// end else
3567: GO 3599
// begin x := GetX ( un ) ;
3569: LD_ADDR_VAR 0 5
3573: PUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 250
3583: ST_TO_ADDR
// y := GetY ( un ) ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 3
3593: PPUSH
3594: CALL_OW 251
3598: ST_TO_ADDR
// end ; if y < north then
3599: LD_VAR 0 6
3603: PUSH
3604: LD_VAR 0 4
3608: LESS
3609: IFFALSE 3621
// north := un ;
3611: LD_ADDR_VAR 0 4
3615: PUSH
3616: LD_VAR 0 3
3620: ST_TO_ADDR
// end ;
3621: GO 3513
3623: POP
3624: POP
// CenterOnXY ( x - 2 , y - 4 ) ;
3625: LD_VAR 0 5
3629: PUSH
3630: LD_INT 2
3632: MINUS
3633: PPUSH
3634: LD_VAR 0 6
3638: PUSH
3639: LD_INT 4
3641: MINUS
3642: PPUSH
3643: CALL_OW 84
// end ;
3647: LD_VAR 0 2
3651: RET
// every 0 0$1 trigger FilterUnitsInArea ( TopBorder , [ [ f_side , you ] ] ) do var un , car , list ;
3652: LD_INT 1
3654: PPUSH
3655: LD_INT 22
3657: PUSH
3658: LD_EXP 1
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PUSH
3667: EMPTY
3668: LIST
3669: PPUSH
3670: CALL_OW 70
3674: IFFALSE 4030
3676: GO 3678
3678: DISABLE
3679: LD_INT 0
3681: PPUSH
3682: PPUSH
3683: PPUSH
// begin list := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
3684: LD_ADDR_VAR 0 3
3688: PUSH
3689: LD_INT 1
3691: PPUSH
3692: LD_INT 22
3694: PUSH
3695: LD_EXP 1
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 21
3706: PUSH
3707: LD_INT 1
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 50
3716: PUSH
3717: EMPTY
3718: LIST
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: LIST
3724: PPUSH
3725: CALL_OW 70
3729: ST_TO_ADDR
// car := FilterUnitsInArea ( TopBorder , [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_INT 1
3737: PPUSH
3738: LD_INT 22
3740: PUSH
3741: LD_EXP 1
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 21
3752: PUSH
3753: LD_INT 2
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_INT 50
3762: PUSH
3763: EMPTY
3764: LIST
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 70
3775: ST_TO_ADDR
// for un in car do
3776: LD_ADDR_VAR 0 1
3780: PUSH
3781: LD_VAR 0 2
3785: PUSH
3786: FOR_IN
3787: IFFALSE 3823
// if IsDrivenBy ( un ) then
3789: LD_VAR 0 1
3793: PPUSH
3794: CALL_OW 311
3798: IFFALSE 3821
// list := list ^ IsDrivenBy ( un ) ;
3800: LD_ADDR_VAR 0 3
3804: PUSH
3805: LD_VAR 0 3
3809: PUSH
3810: LD_VAR 0 1
3814: PPUSH
3815: CALL_OW 311
3819: ADD
3820: ST_TO_ADDR
3821: GO 3786
3823: POP
3824: POP
// list := list union list ;
3825: LD_ADDR_VAR 0 3
3829: PUSH
3830: LD_VAR 0 3
3834: PUSH
3835: LD_VAR 0 3
3839: UNION
3840: ST_TO_ADDR
// list := list diff [ 0 , MacMillan ] ;
3841: LD_ADDR_VAR 0 3
3845: PUSH
3846: LD_VAR 0 3
3850: PUSH
3851: LD_INT 0
3853: PUSH
3854: LD_EXP 7
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: DIFF
3863: ST_TO_ADDR
// if Frank_Query = 1 then
3864: LD_EXP 47
3868: PUSH
3869: LD_INT 1
3871: EQUAL
3872: IFFALSE 3890
// list := list diff Frank ;
3874: LD_ADDR_VAR 0 3
3878: PUSH
3879: LD_VAR 0 3
3883: PUSH
3884: LD_EXP 11
3888: DIFF
3889: ST_TO_ADDR
// for un in list do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: LD_VAR 0 3
3899: PUSH
3900: FOR_IN
3901: IFFALSE 3983
// begin car := IsInUnit ( un ) ;
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: LD_VAR 0 1
3912: PPUSH
3913: CALL_OW 310
3917: ST_TO_ADDR
// RemoveUnit ( un ) ;
3918: LD_VAR 0 1
3922: PPUSH
3923: CALL_OW 64
// if car then
3927: LD_VAR 0 2
3931: IFFALSE 3965
// begin if GetEngine ( car ) = engine_solar then
3933: LD_VAR 0 2
3937: PPUSH
3938: CALL_OW 262
3942: PUSH
3943: LD_INT 2
3945: EQUAL
3946: IFFALSE 3956
// solar_saved := true ;
3948: LD_ADDR_EXP 43
3952: PUSH
3953: LD_INT 1
3955: ST_TO_ADDR
// RemoveUnit ( car ) ;
3956: LD_VAR 0 2
3960: PPUSH
3961: CALL_OW 64
// end ; saved_units := saved_units union un ;
3965: LD_ADDR_EXP 17
3969: PUSH
3970: LD_EXP 17
3974: PUSH
3975: LD_VAR 0 1
3979: UNION
3980: ST_TO_ADDR
// end ;
3981: GO 3900
3983: POP
3984: POP
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) then
3985: LD_INT 22
3987: PUSH
3988: LD_EXP 1
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: PUSH
3997: LD_INT 21
3999: PUSH
4000: LD_INT 1
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 50
4009: PUSH
4010: EMPTY
4011: LIST
4012: PUSH
4013: EMPTY
4014: LIST
4015: LIST
4016: LIST
4017: PPUSH
4018: CALL_OW 69
4022: NOT
4023: IFFALSE 4029
// Konec_mise ;
4025: CALL 1512 0 0
// enable ;
4029: ENABLE
// end ; end_of_file
4030: PPOPN 3
4032: END
// export function run_ru_guarding ; begin
4033: LD_INT 0
4035: PPUSH
// enable ( 1 ) ;
4036: LD_INT 1
4038: ENABLE_MARKED
// end ;
4039: LD_VAR 0 1
4043: RET
// every 0 0$1 marked 1 do var i , south_guard_way ;
4044: GO 4046
4046: DISABLE
4047: LD_INT 0
4049: PPUSH
4050: PPUSH
// begin south_guard_way = [ 119 , 105 , 102 , 88 , 109 , 106 ] ;
4051: LD_ADDR_VAR 0 2
4055: PUSH
4056: LD_INT 119
4058: PUSH
4059: LD_INT 105
4061: PUSH
4062: LD_INT 102
4064: PUSH
4065: LD_INT 88
4067: PUSH
4068: LD_INT 109
4070: PUSH
4071: LD_INT 106
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: LIST
4078: LIST
4079: LIST
4080: LIST
4081: ST_TO_ADDR
// South_russian_patrol := [ s_guard1 , s_guard2 , s_guard3 , s_guard4 ] diff 0 ;
4082: LD_ADDR_EXP 28
4086: PUSH
4087: LD_EXP 50
4091: PUSH
4092: LD_EXP 51
4096: PUSH
4097: LD_EXP 52
4101: PUSH
4102: LD_EXP 53
4106: PUSH
4107: EMPTY
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_INT 0
4115: DIFF
4116: ST_TO_ADDR
// repeat for i = 1 to ( south_guard_way div 2 ) do
4117: LD_ADDR_VAR 0 1
4121: PUSH
4122: DOUBLE
4123: LD_INT 1
4125: DEC
4126: ST_TO_ADDR
4127: LD_VAR 0 2
4131: PUSH
4132: LD_INT 2
4134: DIV
4135: PUSH
4136: FOR_TO
4137: IFFALSE 4196
// begin AddComAgressiveMove ( South_russian_patrol , south_guard_way [ ( i * 2 ) - 1 ] , south_guard_way [ ( i * 2 ) ] ) ;
4139: LD_EXP 28
4143: PPUSH
4144: LD_VAR 0 2
4148: PUSH
4149: LD_VAR 0 1
4153: PUSH
4154: LD_INT 2
4156: MUL
4157: PUSH
4158: LD_INT 1
4160: MINUS
4161: ARRAY
4162: PPUSH
4163: LD_VAR 0 2
4167: PUSH
4168: LD_VAR 0 1
4172: PUSH
4173: LD_INT 2
4175: MUL
4176: ARRAY
4177: PPUSH
4178: CALL_OW 174
// AddComWait ( South_russian_patrol , 0 0$2 ) ;
4182: LD_EXP 28
4186: PPUSH
4187: LD_INT 70
4189: PPUSH
4190: CALL_OW 202
// end ;
4194: GO 4136
4196: POP
4197: POP
// repeat wait ( 0 0$2 ) ;
4198: LD_INT 70
4200: PPUSH
4201: CALL_OW 67
// until not ( IsBusy ( s_guard1 ) or IsBusy ( s_guard2 ) or IsBusy ( s_guard3 ) or IsBusy ( s_guard4 ) ) ;
4205: LD_EXP 50
4209: PPUSH
4210: CALL_OW 315
4214: PUSH
4215: LD_EXP 51
4219: PPUSH
4220: CALL_OW 315
4224: OR
4225: PUSH
4226: LD_EXP 52
4230: PPUSH
4231: CALL_OW 315
4235: OR
4236: PUSH
4237: LD_EXP 53
4241: PPUSH
4242: CALL_OW 315
4246: OR
4247: NOT
4248: IFFALSE 4198
// until not ( IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) or IsOK ( s_guard1 ) ) ;
4250: LD_EXP 50
4254: PPUSH
4255: CALL_OW 302
4259: PUSH
4260: LD_EXP 50
4264: PPUSH
4265: CALL_OW 302
4269: OR
4270: PUSH
4271: LD_EXP 50
4275: PPUSH
4276: CALL_OW 302
4280: OR
4281: PUSH
4282: LD_EXP 50
4286: PPUSH
4287: CALL_OW 302
4291: OR
4292: NOT
4293: IFFALSE 4117
// end ;
4295: PPOPN 2
4297: END
// every 0 0$1 marked 1 do var x , y , truck_way , patroll ;
4298: GO 4300
4300: DISABLE
4301: LD_INT 0
4303: PPUSH
4304: PPUSH
4305: PPUSH
4306: PPUSH
// begin truck_way = [ 149 , 116 , 148 , 110 , 146 , 107 , 141 , 102 , 132 , 96 , 127 , 91 , 123 , 85 , 122 , 80 , 127 , 76 , 130 , 68 , 129 , 63 , 124 , 55 , 117 , 47 , 116 , 36 , 114 , 28 , 0 , 114 , 28 , 116 , 36 , 117 , 47 , 124 , 55 , 129 , 63 , 130 , 68 , 127 , 76 , 122 , 80 , 123 , 85 , 127 , 91 , 132 , 96 , 141 , 102 , 146 , 107 , 148 , 110 , - 1 ] ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: LD_INT 149
4314: PUSH
4315: LD_INT 116
4317: PUSH
4318: LD_INT 148
4320: PUSH
4321: LD_INT 110
4323: PUSH
4324: LD_INT 146
4326: PUSH
4327: LD_INT 107
4329: PUSH
4330: LD_INT 141
4332: PUSH
4333: LD_INT 102
4335: PUSH
4336: LD_INT 132
4338: PUSH
4339: LD_INT 96
4341: PUSH
4342: LD_INT 127
4344: PUSH
4345: LD_INT 91
4347: PUSH
4348: LD_INT 123
4350: PUSH
4351: LD_INT 85
4353: PUSH
4354: LD_INT 122
4356: PUSH
4357: LD_INT 80
4359: PUSH
4360: LD_INT 127
4362: PUSH
4363: LD_INT 76
4365: PUSH
4366: LD_INT 130
4368: PUSH
4369: LD_INT 68
4371: PUSH
4372: LD_INT 129
4374: PUSH
4375: LD_INT 63
4377: PUSH
4378: LD_INT 124
4380: PUSH
4381: LD_INT 55
4383: PUSH
4384: LD_INT 117
4386: PUSH
4387: LD_INT 47
4389: PUSH
4390: LD_INT 116
4392: PUSH
4393: LD_INT 36
4395: PUSH
4396: LD_INT 114
4398: PUSH
4399: LD_INT 28
4401: PUSH
4402: LD_INT 0
4404: PUSH
4405: LD_INT 114
4407: PUSH
4408: LD_INT 28
4410: PUSH
4411: LD_INT 116
4413: PUSH
4414: LD_INT 36
4416: PUSH
4417: LD_INT 117
4419: PUSH
4420: LD_INT 47
4422: PUSH
4423: LD_INT 124
4425: PUSH
4426: LD_INT 55
4428: PUSH
4429: LD_INT 129
4431: PUSH
4432: LD_INT 63
4434: PUSH
4435: LD_INT 130
4437: PUSH
4438: LD_INT 68
4440: PUSH
4441: LD_INT 127
4443: PUSH
4444: LD_INT 76
4446: PUSH
4447: LD_INT 122
4449: PUSH
4450: LD_INT 80
4452: PUSH
4453: LD_INT 123
4455: PUSH
4456: LD_INT 85
4458: PUSH
4459: LD_INT 127
4461: PUSH
4462: LD_INT 91
4464: PUSH
4465: LD_INT 132
4467: PUSH
4468: LD_INT 96
4470: PUSH
4471: LD_INT 141
4473: PUSH
4474: LD_INT 102
4476: PUSH
4477: LD_INT 146
4479: PUSH
4480: LD_INT 107
4482: PUSH
4483: LD_INT 148
4485: PUSH
4486: LD_INT 110
4488: PUSH
4489: LD_INT 1
4491: NEG
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: ST_TO_ADDR
// patroll := ru_trucks [ 8 ] ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: LD_EXP 48
4564: PUSH
4565: LD_INT 8
4567: ARRAY
4568: ST_TO_ADDR
// repeat x := - 1 ;
4569: LD_ADDR_VAR 0 1
4573: PUSH
4574: LD_INT 1
4576: NEG
4577: ST_TO_ADDR
// for y in truck_way do
4578: LD_ADDR_VAR 0 2
4582: PUSH
4583: LD_VAR 0 3
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4680
// case y of - 1 , 0 :
4591: LD_VAR 0 2
4595: PUSH
4596: LD_INT 1
4598: NEG
4599: DOUBLE
4600: EQUAL
4601: IFTRUE 4611
4603: LD_INT 0
4605: DOUBLE
4606: EQUAL
4607: IFTRUE 4611
4609: GO 4626
4611: POP
// AddComWait ( patroll , 0 0$5 ) ; else
4612: LD_VAR 0 4
4616: PPUSH
4617: LD_INT 175
4619: PPUSH
4620: CALL_OW 202
4624: GO 4678
4626: POP
// if x = - 1 then
4627: LD_VAR 0 1
4631: PUSH
4632: LD_INT 1
4634: NEG
4635: EQUAL
4636: IFFALSE 4650
// x := y else
4638: LD_ADDR_VAR 0 1
4642: PUSH
4643: LD_VAR 0 2
4647: ST_TO_ADDR
4648: GO 4678
// begin AddComAgressiveMove ( patroll , x , y ) ;
4650: LD_VAR 0 4
4654: PPUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: LD_VAR 0 2
4664: PPUSH
4665: CALL_OW 174
// x := - 1 ;
4669: LD_ADDR_VAR 0 1
4673: PUSH
4674: LD_INT 1
4676: NEG
4677: ST_TO_ADDR
// end ; end ;
4678: GO 4588
4680: POP
4681: POP
// repeat if See ( you , patroll ) and See ( russians , MacMillan ) then
4682: LD_EXP 1
4686: PPUSH
4687: LD_VAR 0 4
4691: PPUSH
4692: CALL_OW 292
4696: PUSH
4697: LD_EXP 2
4701: PPUSH
4702: LD_EXP 7
4706: PPUSH
4707: CALL_OW 292
4711: AND
4712: IFFALSE 4799
// repeat if See ( russians , MacMillan ) then
4714: LD_EXP 2
4718: PPUSH
4719: LD_EXP 7
4723: PPUSH
4724: CALL_OW 292
4728: IFFALSE 4759
// ComAgressiveMove ( patroll , GetX ( MacMillan ) , GetY ( MacMillan ) ) ;
4730: LD_VAR 0 4
4734: PPUSH
4735: LD_EXP 7
4739: PPUSH
4740: CALL_OW 250
4744: PPUSH
4745: LD_EXP 7
4749: PPUSH
4750: CALL_OW 251
4754: PPUSH
4755: CALL_OW 114
// wait ( 0 0$1 ) ;
4759: LD_INT 35
4761: PPUSH
4762: CALL_OW 67
// until not ( See ( russians , MacMillan ) or See ( russians , Bobby ) ) ;
4766: LD_EXP 2
4770: PPUSH
4771: LD_EXP 7
4775: PPUSH
4776: CALL_OW 292
4780: PUSH
4781: LD_EXP 2
4785: PPUSH
4786: LD_EXP 4
4790: PPUSH
4791: CALL_OW 292
4795: OR
4796: NOT
4797: IFFALSE 4714
// wait ( 0 0$1 ) ;
4799: LD_INT 35
4801: PPUSH
4802: CALL_OW 67
// until not IsBusy ( patroll ) ;
4806: LD_VAR 0 4
4810: PPUSH
4811: CALL_OW 315
4815: NOT
4816: IFFALSE 4682
// if ( atack = 1 and GetSide ( patroll ) = russians ) then
4818: LD_EXP 16
4822: PUSH
4823: LD_INT 1
4825: EQUAL
4826: PUSH
4827: LD_VAR 0 4
4831: PPUSH
4832: CALL_OW 255
4836: PUSH
4837: LD_EXP 2
4841: EQUAL
4842: AND
4843: IFFALSE 4862
// repeat wait ( 0 0$2 ) ;
4845: LD_INT 70
4847: PPUSH
4848: CALL_OW 67
// until atack = 0 ;
4852: LD_EXP 16
4856: PUSH
4857: LD_INT 0
4859: EQUAL
4860: IFFALSE 4845
// until not IsOK ( patroll ) ;
4862: LD_VAR 0 4
4866: PPUSH
4867: CALL_OW 302
4871: NOT
4872: IFFALSE 4569
// end ;
4874: PPOPN 4
4876: END
// every 0 0$1 marked 1 do var x , y , forest_way1 ;
4877: GO 4879
4879: DISABLE
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// begin forest_way1 = [ 27 , 45 , - 1 , 38 , 49 , 40 , 34 , - 1 , - 1 , 38 , 49 , 27 , 45 , - 1 ] ;
4885: LD_ADDR_VAR 0 3
4889: PUSH
4890: LD_INT 27
4892: PUSH
4893: LD_INT 45
4895: PUSH
4896: LD_INT 1
4898: NEG
4899: PUSH
4900: LD_INT 38
4902: PUSH
4903: LD_INT 49
4905: PUSH
4906: LD_INT 40
4908: PUSH
4909: LD_INT 34
4911: PUSH
4912: LD_INT 1
4914: NEG
4915: PUSH
4916: LD_INT 1
4918: NEG
4919: PUSH
4920: LD_INT 38
4922: PUSH
4923: LD_INT 49
4925: PUSH
4926: LD_INT 27
4928: PUSH
4929: LD_INT 45
4931: PUSH
4932: LD_INT 1
4934: NEG
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: ST_TO_ADDR
// repeat x := - 1 ;
4952: LD_ADDR_VAR 0 1
4956: PUSH
4957: LD_INT 1
4959: NEG
4960: ST_TO_ADDR
// for y in forest_way1 do
4961: LD_ADDR_VAR 0 2
4965: PUSH
4966: LD_VAR 0 3
4970: PUSH
4971: FOR_IN
4972: IFFALSE 5057
// case y of - 1 :
4974: LD_VAR 0 2
4978: PUSH
4979: LD_INT 1
4981: NEG
4982: DOUBLE
4983: EQUAL
4984: IFTRUE 4988
4986: GO 5003
4988: POP
// AddComWait ( forest_force1 , 0 0$2 ) ; else
4989: LD_EXP 29
4993: PPUSH
4994: LD_INT 70
4996: PPUSH
4997: CALL_OW 202
5001: GO 5055
5003: POP
// if x = - 1 then
5004: LD_VAR 0 1
5008: PUSH
5009: LD_INT 1
5011: NEG
5012: EQUAL
5013: IFFALSE 5027
// x := y else
5015: LD_ADDR_VAR 0 1
5019: PUSH
5020: LD_VAR 0 2
5024: ST_TO_ADDR
5025: GO 5055
// begin AddComAgressiveMove ( forest_force1 , x , y ) ;
5027: LD_EXP 29
5031: PPUSH
5032: LD_VAR 0 1
5036: PPUSH
5037: LD_VAR 0 2
5041: PPUSH
5042: CALL_OW 174
// x := - 1 ;
5046: LD_ADDR_VAR 0 1
5050: PUSH
5051: LD_INT 1
5053: NEG
5054: ST_TO_ADDR
// end ; end ;
5055: GO 4971
5057: POP
5058: POP
// repeat wait ( 0 0$2 ) ;
5059: LD_INT 70
5061: PPUSH
5062: CALL_OW 67
// until not ( IsBusy ( forest11 ) or IsBusy ( forest12 ) ) ;
5066: LD_INT 26
5068: PPUSH
5069: CALL_OW 315
5073: PUSH
5074: LD_INT 25
5076: PPUSH
5077: CALL_OW 315
5081: OR
5082: NOT
5083: IFFALSE 5059
// until not ( IsOK ( forest11 ) or IsOK ( forest12 ) ) ;
5085: LD_INT 26
5087: PPUSH
5088: CALL_OW 302
5092: PUSH
5093: LD_INT 25
5095: PPUSH
5096: CALL_OW 302
5100: OR
5101: NOT
5102: IFFALSE 4952
// end ;
5104: PPOPN 3
5106: END
// every 0 0$1 marked 1 do var x , y , forest_way2 ;
5107: GO 5109
5109: DISABLE
5110: LD_INT 0
5112: PPUSH
5113: PPUSH
5114: PPUSH
// begin forest_way2 = [ 38 , 29 , - 1 , 39 , 50 , 53 , 57 , 55 , 39 , - 1 ] ;
5115: LD_ADDR_VAR 0 3
5119: PUSH
5120: LD_INT 38
5122: PUSH
5123: LD_INT 29
5125: PUSH
5126: LD_INT 1
5128: NEG
5129: PUSH
5130: LD_INT 39
5132: PUSH
5133: LD_INT 50
5135: PUSH
5136: LD_INT 53
5138: PUSH
5139: LD_INT 57
5141: PUSH
5142: LD_INT 55
5144: PUSH
5145: LD_INT 39
5147: PUSH
5148: LD_INT 1
5150: NEG
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// repeat x := - 1 ;
5164: LD_ADDR_VAR 0 1
5168: PUSH
5169: LD_INT 1
5171: NEG
5172: ST_TO_ADDR
// for y in forest_way2 do
5173: LD_ADDR_VAR 0 2
5177: PUSH
5178: LD_VAR 0 3
5182: PUSH
5183: FOR_IN
5184: IFFALSE 5269
// case y of - 1 :
5186: LD_VAR 0 2
5190: PUSH
5191: LD_INT 1
5193: NEG
5194: DOUBLE
5195: EQUAL
5196: IFTRUE 5200
5198: GO 5215
5200: POP
// AddComWait ( forest_force2 , 0 0$2 ) ; else
5201: LD_EXP 30
5205: PPUSH
5206: LD_INT 70
5208: PPUSH
5209: CALL_OW 202
5213: GO 5267
5215: POP
// if x = - 1 then
5216: LD_VAR 0 1
5220: PUSH
5221: LD_INT 1
5223: NEG
5224: EQUAL
5225: IFFALSE 5239
// x := y else
5227: LD_ADDR_VAR 0 1
5231: PUSH
5232: LD_VAR 0 2
5236: ST_TO_ADDR
5237: GO 5267
// begin AddComAgressiveMove ( forest_force2 , x , y ) ;
5239: LD_EXP 30
5243: PPUSH
5244: LD_VAR 0 1
5248: PPUSH
5249: LD_VAR 0 2
5253: PPUSH
5254: CALL_OW 174
// x := - 1 ;
5258: LD_ADDR_VAR 0 1
5262: PUSH
5263: LD_INT 1
5265: NEG
5266: ST_TO_ADDR
// end ; end ;
5267: GO 5183
5269: POP
5270: POP
// repeat Wait ( 0 0$2 ) ;
5271: LD_INT 70
5273: PPUSH
5274: CALL_OW 67
// until not ( IsBusy ( forest21 ) or IsBusy ( forest22 ) ) ;
5278: LD_INT 41
5280: PPUSH
5281: CALL_OW 315
5285: PUSH
5286: LD_INT 42
5288: PPUSH
5289: CALL_OW 315
5293: OR
5294: NOT
5295: IFFALSE 5271
// until not ( IsOK ( forest21 ) or IsOK ( forest22 ) ) ;
5297: LD_INT 41
5299: PPUSH
5300: CALL_OW 302
5304: PUSH
5305: LD_INT 42
5307: PPUSH
5308: CALL_OW 302
5312: OR
5313: NOT
5314: IFFALSE 5164
// end ;
5316: PPOPN 3
5318: END
// every 0 0$1 marked 1 do var x , y , grass_way1 ;
5319: GO 5321
5321: DISABLE
5322: LD_INT 0
5324: PPUSH
5325: PPUSH
5326: PPUSH
// begin grass_force1 = [ grass_11 , grass_12 ] ;
5327: LD_ADDR_EXP 31
5331: PUSH
5332: LD_INT 21
5334: PUSH
5335: LD_INT 22
5337: PUSH
5338: EMPTY
5339: LIST
5340: LIST
5341: ST_TO_ADDR
// grass_way1 = [ 77 , 67 , - 1 , 83 , 56 , - 1 , 65 , 49 , - 1 ] ;
5342: LD_ADDR_VAR 0 3
5346: PUSH
5347: LD_INT 77
5349: PUSH
5350: LD_INT 67
5352: PUSH
5353: LD_INT 1
5355: NEG
5356: PUSH
5357: LD_INT 83
5359: PUSH
5360: LD_INT 56
5362: PUSH
5363: LD_INT 1
5365: NEG
5366: PUSH
5367: LD_INT 65
5369: PUSH
5370: LD_INT 49
5372: PUSH
5373: LD_INT 1
5375: NEG
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: LIST
5382: LIST
5383: LIST
5384: LIST
5385: LIST
5386: LIST
5387: ST_TO_ADDR
// repeat x := - 1 ;
5388: LD_ADDR_VAR 0 1
5392: PUSH
5393: LD_INT 1
5395: NEG
5396: ST_TO_ADDR
// for y in grass_way1 do
5397: LD_ADDR_VAR 0 2
5401: PUSH
5402: LD_VAR 0 3
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5519
// case y of - 1 :
5410: LD_VAR 0 2
5414: PUSH
5415: LD_INT 1
5417: NEG
5418: DOUBLE
5419: EQUAL
5420: IFTRUE 5424
5422: GO 5439
5424: POP
// AddComWait ( grass_force1 , 0 0$2 ) ; else
5425: LD_EXP 31
5429: PPUSH
5430: LD_INT 70
5432: PPUSH
5433: CALL_OW 202
5437: GO 5517
5439: POP
// if x = - 1 then
5440: LD_VAR 0 1
5444: PUSH
5445: LD_INT 1
5447: NEG
5448: EQUAL
5449: IFFALSE 5463
// x := y else
5451: LD_ADDR_VAR 0 1
5455: PUSH
5456: LD_VAR 0 2
5460: ST_TO_ADDR
5461: GO 5517
// begin AddComAgressiveMove ( grass_force1 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5463: LD_EXP 31
5467: PPUSH
5468: LD_VAR 0 1
5472: PUSH
5473: LD_INT 1
5475: NEG
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL_OW 12
5484: PLUS
5485: PPUSH
5486: LD_VAR 0 2
5490: PUSH
5491: LD_INT 1
5493: NEG
5494: PPUSH
5495: LD_INT 1
5497: PPUSH
5498: CALL_OW 12
5502: PLUS
5503: PPUSH
5504: CALL_OW 174
// x := - 1 ;
5508: LD_ADDR_VAR 0 1
5512: PUSH
5513: LD_INT 1
5515: NEG
5516: ST_TO_ADDR
// end ; end ;
5517: GO 5407
5519: POP
5520: POP
// repeat Wait ( 0 0$2 ) ;
5521: LD_INT 70
5523: PPUSH
5524: CALL_OW 67
// until not ( IsBusy ( grass_11 ) or IsBusy ( grass_12 ) ) ;
5528: LD_INT 21
5530: PPUSH
5531: CALL_OW 315
5535: PUSH
5536: LD_INT 22
5538: PPUSH
5539: CALL_OW 315
5543: OR
5544: NOT
5545: IFFALSE 5521
// until not ( IsOK ( grass_11 ) or IsOK ( grass_12 ) ) ;
5547: LD_INT 21
5549: PPUSH
5550: CALL_OW 302
5554: PUSH
5555: LD_INT 22
5557: PPUSH
5558: CALL_OW 302
5562: OR
5563: NOT
5564: IFFALSE 5388
// end ;
5566: PPOPN 3
5568: END
// every 0 0$1 marked 1 do var x , y , grass_way2 ;
5569: GO 5571
5571: DISABLE
5572: LD_INT 0
5574: PPUSH
5575: PPUSH
5576: PPUSH
// begin grass_force2 = [ grass_21 , grass_22 ] ;
5577: LD_ADDR_EXP 32
5581: PUSH
5582: LD_INT 23
5584: PUSH
5585: LD_INT 24
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: ST_TO_ADDR
// grass_way2 = [ 129 , 64 , - 1 , 127 , 75 , - 1 , 104 , 62 , - 1 ] ;
5592: LD_ADDR_VAR 0 3
5596: PUSH
5597: LD_INT 129
5599: PUSH
5600: LD_INT 64
5602: PUSH
5603: LD_INT 1
5605: NEG
5606: PUSH
5607: LD_INT 127
5609: PUSH
5610: LD_INT 75
5612: PUSH
5613: LD_INT 1
5615: NEG
5616: PUSH
5617: LD_INT 104
5619: PUSH
5620: LD_INT 62
5622: PUSH
5623: LD_INT 1
5625: NEG
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: ST_TO_ADDR
// repeat x := - 1 ;
5638: LD_ADDR_VAR 0 1
5642: PUSH
5643: LD_INT 1
5645: NEG
5646: ST_TO_ADDR
// for y in grass_way2 do
5647: LD_ADDR_VAR 0 2
5651: PUSH
5652: LD_VAR 0 3
5656: PUSH
5657: FOR_IN
5658: IFFALSE 5769
// case y of - 1 :
5660: LD_VAR 0 2
5664: PUSH
5665: LD_INT 1
5667: NEG
5668: DOUBLE
5669: EQUAL
5670: IFTRUE 5674
5672: GO 5689
5674: POP
// AddComWait ( grass_force2 , 0 0$2 ) ; else
5675: LD_EXP 32
5679: PPUSH
5680: LD_INT 70
5682: PPUSH
5683: CALL_OW 202
5687: GO 5767
5689: POP
// if x = - 1 then
5690: LD_VAR 0 1
5694: PUSH
5695: LD_INT 1
5697: NEG
5698: EQUAL
5699: IFFALSE 5713
// x := y else
5701: LD_ADDR_VAR 0 1
5705: PUSH
5706: LD_VAR 0 2
5710: ST_TO_ADDR
5711: GO 5767
// begin AddComAgressiveMove ( grass_force2 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5713: LD_EXP 32
5717: PPUSH
5718: LD_VAR 0 1
5722: PUSH
5723: LD_INT 1
5725: NEG
5726: PPUSH
5727: LD_INT 1
5729: PPUSH
5730: CALL_OW 12
5734: PLUS
5735: PPUSH
5736: LD_VAR 0 2
5740: PUSH
5741: LD_INT 1
5743: NEG
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: CALL_OW 12
5752: PLUS
5753: PPUSH
5754: CALL_OW 174
// x := - 1 ;
5758: LD_ADDR_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: NEG
5766: ST_TO_ADDR
// end ; end ;
5767: GO 5657
5769: POP
5770: POP
// repeat Wait ( 0 0$2 ) ;
5771: LD_INT 70
5773: PPUSH
5774: CALL_OW 67
// until not ( IsBusy ( grass_21 ) or IsBusy ( grass_22 ) ) ;
5778: LD_INT 23
5780: PPUSH
5781: CALL_OW 315
5785: PUSH
5786: LD_INT 24
5788: PPUSH
5789: CALL_OW 315
5793: OR
5794: NOT
5795: IFFALSE 5771
// until not ( IsOK ( grass_21 ) or IsOK ( grass_22 ) ) ;
5797: LD_INT 23
5799: PPUSH
5800: CALL_OW 302
5804: PUSH
5805: LD_INT 24
5807: PPUSH
5808: CALL_OW 302
5812: OR
5813: NOT
5814: IFFALSE 5638
// end ;
5816: PPOPN 3
5818: END
// every 0 0$1 marked 1 do var x , y , grass_way3 ;
5819: GO 5821
5821: DISABLE
5822: LD_INT 0
5824: PPUSH
5825: PPUSH
5826: PPUSH
// begin grass_force3 = [ grass_31 , grass_32 , grass_33 ] ;
5827: LD_ADDR_EXP 33
5831: PUSH
5832: LD_EXP 60
5836: PUSH
5837: LD_EXP 61
5841: PUSH
5842: LD_EXP 62
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: ST_TO_ADDR
// grass_way3 = [ 73 , 39 , - 1 , 81 , 50 , 88 , 37 , - 1 ] ;
5852: LD_ADDR_VAR 0 3
5856: PUSH
5857: LD_INT 73
5859: PUSH
5860: LD_INT 39
5862: PUSH
5863: LD_INT 1
5865: NEG
5866: PUSH
5867: LD_INT 81
5869: PUSH
5870: LD_INT 50
5872: PUSH
5873: LD_INT 88
5875: PUSH
5876: LD_INT 37
5878: PUSH
5879: LD_INT 1
5881: NEG
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: ST_TO_ADDR
// repeat x := - 1 ;
5893: LD_ADDR_VAR 0 1
5897: PUSH
5898: LD_INT 1
5900: NEG
5901: ST_TO_ADDR
// for y in grass_way3 do
5902: LD_ADDR_VAR 0 2
5906: PUSH
5907: LD_VAR 0 3
5911: PUSH
5912: FOR_IN
5913: IFFALSE 6024
// case y of - 1 :
5915: LD_VAR 0 2
5919: PUSH
5920: LD_INT 1
5922: NEG
5923: DOUBLE
5924: EQUAL
5925: IFTRUE 5929
5927: GO 5944
5929: POP
// AddComWait ( grass_force3 , 0 0$2 ) ; else
5930: LD_EXP 33
5934: PPUSH
5935: LD_INT 70
5937: PPUSH
5938: CALL_OW 202
5942: GO 6022
5944: POP
// if x = - 1 then
5945: LD_VAR 0 1
5949: PUSH
5950: LD_INT 1
5952: NEG
5953: EQUAL
5954: IFFALSE 5968
// x := y else
5956: LD_ADDR_VAR 0 1
5960: PUSH
5961: LD_VAR 0 2
5965: ST_TO_ADDR
5966: GO 6022
// begin AddComMoveXY ( grass_force3 , x + Rand ( - 1 , 1 ) , y + Rand ( - 1 , 1 ) ) ;
5968: LD_EXP 33
5972: PPUSH
5973: LD_VAR 0 1
5977: PUSH
5978: LD_INT 1
5980: NEG
5981: PPUSH
5982: LD_INT 1
5984: PPUSH
5985: CALL_OW 12
5989: PLUS
5990: PPUSH
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: NEG
5999: PPUSH
6000: LD_INT 1
6002: PPUSH
6003: CALL_OW 12
6007: PLUS
6008: PPUSH
6009: CALL_OW 171
// x := - 1 ;
6013: LD_ADDR_VAR 0 1
6017: PUSH
6018: LD_INT 1
6020: NEG
6021: ST_TO_ADDR
// end ; end ;
6022: GO 5912
6024: POP
6025: POP
// repeat Wait ( 0 0$2 ) ;
6026: LD_INT 70
6028: PPUSH
6029: CALL_OW 67
// until not ( IsBusy ( grass_31 ) or IsBusy ( grass_32 ) or IsBusy ( grass_33 ) ) ;
6033: LD_EXP 60
6037: PPUSH
6038: CALL_OW 315
6042: PUSH
6043: LD_EXP 61
6047: PPUSH
6048: CALL_OW 315
6052: OR
6053: PUSH
6054: LD_EXP 62
6058: PPUSH
6059: CALL_OW 315
6063: OR
6064: NOT
6065: IFFALSE 6026
// until not ( IsOK ( grass_31 ) or IsOK ( grass_32 ) or IsOK ( grass_33 ) ) ;
6067: LD_EXP 60
6071: PPUSH
6072: CALL_OW 302
6076: PUSH
6077: LD_EXP 61
6081: PPUSH
6082: CALL_OW 302
6086: OR
6087: PUSH
6088: LD_EXP 62
6092: PPUSH
6093: CALL_OW 302
6097: OR
6098: NOT
6099: IFFALSE 5893
// end ;
6101: PPOPN 3
6103: END
// export function attack_began ; var i , truck_in_battle , russians_trucks , vozidlo ; begin
6104: LD_INT 0
6106: PPUSH
6107: PPUSH
6108: PPUSH
6109: PPUSH
6110: PPUSH
// ComRemember ( ru_trucks ) ;
6111: LD_EXP 48
6115: PPUSH
6116: CALL_OW 143
// ComAgressiveMove ( ru_trucks , 118 , 3 ) ;
6120: LD_EXP 48
6124: PPUSH
6125: LD_INT 118
6127: PPUSH
6128: LD_INT 3
6130: PPUSH
6131: CALL_OW 114
// repeat truck_in_battle := FilterUnitsInArea ( battlefield , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6135: LD_ADDR_VAR 0 3
6139: PUSH
6140: LD_INT 6
6142: PPUSH
6143: LD_INT 22
6145: PUSH
6146: LD_EXP 2
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 21
6157: PUSH
6158: LD_INT 2
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PPUSH
6169: CALL_OW 70
6173: ST_TO_ADDR
// for vozidlo in truck_in_battle do
6174: LD_ADDR_VAR 0 5
6178: PUSH
6179: LD_VAR 0 3
6183: PUSH
6184: FOR_IN
6185: IFFALSE 6198
// RemoveUnit ( vozidlo ) ;
6187: LD_VAR 0 5
6191: PPUSH
6192: CALL_OW 64
6196: GO 6184
6198: POP
6199: POP
// wait ( 0 0$1 ) ;
6200: LD_INT 35
6202: PPUSH
6203: CALL_OW 67
// i := false ;
6207: LD_ADDR_VAR 0 2
6211: PUSH
6212: LD_INT 0
6214: ST_TO_ADDR
// for vozidlo in ru_trucks do
6215: LD_ADDR_VAR 0 5
6219: PUSH
6220: LD_EXP 48
6224: PUSH
6225: FOR_IN
6226: IFFALSE 6251
// i := i or IsOK ( vozidlo ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PUSH
6238: LD_VAR 0 5
6242: PPUSH
6243: CALL_OW 302
6247: OR
6248: ST_TO_ADDR
6249: GO 6225
6251: POP
6252: POP
// until not i ;
6253: LD_VAR 0 2
6257: NOT
6258: IFFALSE 6135
// repeat Wait ( 0 0$10 ) ;
6260: LD_INT 350
6262: PPUSH
6263: CALL_OW 67
// until not atack ;
6267: LD_EXP 16
6271: NOT
6272: IFFALSE 6260
// repeat for vozidlo in ru_trucks do
6274: LD_ADDR_VAR 0 5
6278: PUSH
6279: LD_EXP 48
6283: PUSH
6284: FOR_IN
6285: IFFALSE 6316
// if not IsOK ( vozidlo ) then
6287: LD_VAR 0 5
6291: PPUSH
6292: CALL_OW 302
6296: NOT
6297: IFFALSE 6314
// PlaceUnitArea ( vozidlo , battlefield , false ) ;
6299: LD_VAR 0 5
6303: PPUSH
6304: LD_INT 6
6306: PPUSH
6307: LD_INT 0
6309: PPUSH
6310: CALL_OW 49
6314: GO 6284
6316: POP
6317: POP
// ComReturn ( ru_trucks ) ;
6318: LD_EXP 48
6322: PPUSH
6323: CALL_OW 144
// wait ( 0 0$1 ) ;
6327: LD_INT 35
6329: PPUSH
6330: CALL_OW 67
// i := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
6334: LD_ADDR_VAR 0 2
6338: PUSH
6339: LD_INT 22
6341: PUSH
6342: LD_EXP 2
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: LD_INT 21
6353: PUSH
6354: LD_INT 2
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: PPUSH
6365: CALL_OW 69
6369: ST_TO_ADDR
// until not ( ru_trucks diff i ) ;
6370: LD_EXP 48
6374: PUSH
6375: LD_VAR 0 2
6379: DIFF
6380: NOT
6381: IFFALSE 6274
// end ;
6383: LD_VAR 0 1
6387: RET
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) or ( TICK > [ 15 15$0 , 10 10$0 , 5 5$0 ] [ difficulty ] ) marked 2 do var liv , ran , list , un , agresors , min_time , max_time ;
6388: LD_EXP 7
6392: PPUSH
6393: LD_INT 2
6395: PPUSH
6396: CALL_OW 308
6400: PUSH
6401: LD_OWVAR 1
6405: PUSH
6406: LD_INT 31500
6408: PUSH
6409: LD_INT 21000
6411: PUSH
6412: LD_INT 10500
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_OWVAR 67
6424: ARRAY
6425: GREATER
6426: OR
6427: IFFALSE 7383
6429: GO 6431
6431: DISABLE
6432: LD_INT 0
6434: PPUSH
6435: PPUSH
6436: PPUSH
6437: PPUSH
6438: PPUSH
6439: PPUSH
6440: PPUSH
// begin min_time := [ 4 4$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
6441: LD_ADDR_VAR 0 6
6445: PUSH
6446: LD_INT 8400
6448: PUSH
6449: LD_INT 4200
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_OWVAR 67
6464: ARRAY
6465: ST_TO_ADDR
// max_time := [ 8 8$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
6466: LD_ADDR_VAR 0 7
6470: PUSH
6471: LD_INT 16800
6473: PUSH
6474: LD_INT 8400
6476: PUSH
6477: LD_INT 4200
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: PUSH
6485: LD_OWVAR 67
6489: ARRAY
6490: ST_TO_ADDR
// ran := Rand ( min_time , max_time ) ;
6491: LD_ADDR_VAR 0 2
6495: PUSH
6496: LD_VAR 0 6
6500: PPUSH
6501: LD_VAR 0 7
6505: PPUSH
6506: CALL_OW 12
6510: ST_TO_ADDR
// Wait ( ran ) ;
6511: LD_VAR 0 2
6515: PPUSH
6516: CALL_OW 67
// ComAgressiveMove ( [ patrol1 , patrol2 ] , 130 , 68 ) ;
6520: LD_INT 14
6522: PUSH
6523: LD_INT 15
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PPUSH
6530: LD_INT 130
6532: PPUSH
6533: LD_INT 68
6535: PPUSH
6536: CALL_OW 114
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 124 , 102 ) ;
6540: LD_INT 14
6542: PUSH
6543: LD_INT 15
6545: PUSH
6546: EMPTY
6547: LIST
6548: LIST
6549: PPUSH
6550: LD_INT 124
6552: PPUSH
6553: LD_INT 102
6555: PPUSH
6556: CALL_OW 174
// AddComAgressiveMove ( [ patrol1 , patrol2 ] , 66 , 100 ) ;
6560: LD_INT 14
6562: PUSH
6563: LD_INT 15
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PPUSH
6570: LD_INT 66
6572: PPUSH
6573: LD_INT 100
6575: PPUSH
6576: CALL_OW 174
// wait ( 0 0$15 ) ;
6580: LD_INT 525
6582: PPUSH
6583: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , [ f_class , class_soldier ] , f_not , [ f_side , russians ] ] ) ;
6587: LD_ADDR_VAR 0 3
6591: PUSH
6592: LD_INT 4
6594: PPUSH
6595: LD_INT 21
6597: PUSH
6598: LD_INT 1
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PUSH
6605: LD_INT 25
6607: PUSH
6608: LD_INT 1
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 3
6617: PUSH
6618: LD_INT 22
6620: PUSH
6621: LD_EXP 2
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 70
6640: ST_TO_ADDR
// for un in list do
6641: LD_ADDR_VAR 0 4
6645: PUSH
6646: LD_VAR 0 3
6650: PUSH
6651: FOR_IN
6652: IFFALSE 6670
// PriorityAttack ( russians , un ) ;
6654: LD_EXP 2
6658: PPUSH
6659: LD_VAR 0 4
6663: PPUSH
6664: CALL_OW 470
6668: GO 6651
6670: POP
6671: POP
// repeat wait ( 15 ) ;
6672: LD_INT 15
6674: PPUSH
6675: CALL_OW 67
// list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_human ] , f_not , [ f_side , russians ] , f_not , [ f_nation , nation_nature ] ] ) ;
6679: LD_ADDR_VAR 0 3
6683: PUSH
6684: LD_INT 4
6686: PPUSH
6687: LD_INT 21
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: LD_INT 3
6699: PUSH
6700: LD_INT 22
6702: PUSH
6703: LD_EXP 2
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 3
6714: PUSH
6715: LD_INT 23
6717: PUSH
6718: LD_INT 0
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: PPUSH
6732: CALL_OW 70
6736: ST_TO_ADDR
// agresors := [ ] ;
6737: LD_ADDR_VAR 0 5
6741: PUSH
6742: EMPTY
6743: ST_TO_ADDR
// if IsOK ( patrol1 ) then
6744: LD_INT 14
6746: PPUSH
6747: CALL_OW 302
6751: IFFALSE 6767
// agresors := agresors ^ patrol1 ;
6753: LD_ADDR_VAR 0 5
6757: PUSH
6758: LD_VAR 0 5
6762: PUSH
6763: LD_INT 14
6765: ADD
6766: ST_TO_ADDR
// if IsOK ( patrol2 ) then
6767: LD_INT 15
6769: PPUSH
6770: CALL_OW 302
6774: IFFALSE 6790
// agresors := agresors ^ patrol2 ;
6776: LD_ADDR_VAR 0 5
6780: PUSH
6781: LD_VAR 0 5
6785: PUSH
6786: LD_INT 15
6788: ADD
6789: ST_TO_ADDR
// if not agresors then
6790: LD_VAR 0 5
6794: NOT
6795: IFFALSE 6799
// exit ;
6797: GO 7383
// if list then
6799: LD_VAR 0 3
6803: IFFALSE 6844
// ComAgressiveMove ( agresors , GetX ( list [ 1 ] ) , GetY ( list [ 1 ] ) ) else
6805: LD_VAR 0 5
6809: PPUSH
6810: LD_VAR 0 3
6814: PUSH
6815: LD_INT 1
6817: ARRAY
6818: PPUSH
6819: CALL_OW 250
6823: PPUSH
6824: LD_VAR 0 3
6828: PUSH
6829: LD_INT 1
6831: ARRAY
6832: PPUSH
6833: CALL_OW 251
6837: PPUSH
6838: CALL_OW 114
6842: GO 6936
// begin list := FilterUnitsInArea ( Meeting , [ [ f_type , unit_building ] ] ) ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_INT 4
6851: PPUSH
6852: LD_INT 21
6854: PUSH
6855: LD_INT 3
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: PPUSH
6865: CALL_OW 70
6869: ST_TO_ADDR
// for un in list do
6870: LD_ADDR_VAR 0 4
6874: PUSH
6875: LD_VAR 0 3
6879: PUSH
6880: FOR_IN
6881: IFFALSE 6899
// PriorityAttack ( russians , un ) ;
6883: LD_EXP 2
6887: PPUSH
6888: LD_VAR 0 4
6892: PPUSH
6893: CALL_OW 470
6897: GO 6880
6899: POP
6900: POP
// if list then
6901: LD_VAR 0 3
6905: IFFALSE 6927
// ComAttackUnit ( agresors , list [ 1 ] ) else
6907: LD_VAR 0 5
6911: PPUSH
6912: LD_VAR 0 3
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: CALL_OW 115
6925: GO 6936
// begin YouLost ( 2 ) ;
6927: LD_STRING 2
6929: PPUSH
6930: CALL_OW 104
// exit ;
6934: GO 7383
// end ; end ; until ( GetDistUnits ( NearestUnitToUnit ( list , patrol1 ) , patrol1 ) < 9 ) or ( GetDistUnits ( NearestUnitToUnit ( list , patrol2 ) , patrol2 ) < 9 ) or ( GetLives ( patrol1 ) < 1000 ) or ( GetLives ( patrol2 ) < 1000 ) ;
6936: LD_VAR 0 3
6940: PPUSH
6941: LD_INT 14
6943: PPUSH
6944: CALL_OW 74
6948: PPUSH
6949: LD_INT 14
6951: PPUSH
6952: CALL_OW 296
6956: PUSH
6957: LD_INT 9
6959: LESS
6960: PUSH
6961: LD_VAR 0 3
6965: PPUSH
6966: LD_INT 15
6968: PPUSH
6969: CALL_OW 74
6973: PPUSH
6974: LD_INT 15
6976: PPUSH
6977: CALL_OW 296
6981: PUSH
6982: LD_INT 9
6984: LESS
6985: OR
6986: PUSH
6987: LD_INT 14
6989: PPUSH
6990: CALL_OW 256
6994: PUSH
6995: LD_INT 1000
6997: LESS
6998: OR
6999: PUSH
7000: LD_INT 15
7002: PPUSH
7003: CALL_OW 256
7007: PUSH
7008: LD_INT 1000
7010: LESS
7011: OR
7012: IFFALSE 6672
// CenterOnUnits ( [ patrol1 , patrol2 ] ) ;
7014: LD_INT 14
7016: PUSH
7017: LD_INT 15
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 85
// wait ( 200 - ( difficulty * 45 ) ) ;
7028: LD_INT 200
7030: PUSH
7031: LD_OWVAR 67
7035: PUSH
7036: LD_INT 45
7038: MUL
7039: MINUS
7040: PPUSH
7041: CALL_OW 67
// ComStop ( [ patrol1 , patrol2 ] ) ;
7045: LD_INT 14
7047: PUSH
7048: LD_INT 15
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: PPUSH
7055: CALL_OW 141
// AddComMoveXY ( [ patrol1 , patrol2 ] , 84 , 71 ) ;
7059: LD_INT 14
7061: PUSH
7062: LD_INT 15
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PPUSH
7069: LD_INT 84
7071: PPUSH
7072: LD_INT 71
7074: PPUSH
7075: CALL_OW 171
// AddComWait ( [ patrol1 , patrol2 ] , [ 0 0$6 , 0 0$4 , 0 0$2 ] [ difficulty ] ) ;
7079: LD_INT 14
7081: PUSH
7082: LD_INT 15
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PPUSH
7089: LD_INT 210
7091: PUSH
7092: LD_INT 140
7094: PUSH
7095: LD_INT 70
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: LIST
7102: PUSH
7103: LD_OWVAR 67
7107: ARRAY
7108: PPUSH
7109: CALL_OW 202
// AddComMoveXY ( [ patrol1 , patrol2 ] , 80 , 67 ) ;
7113: LD_INT 14
7115: PUSH
7116: LD_INT 15
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PPUSH
7123: LD_INT 80
7125: PPUSH
7126: LD_INT 67
7128: PPUSH
7129: CALL_OW 171
// AddComMoveXY ( [ patrol1 , patrol2 ] , 45 , 22 ) ;
7133: LD_INT 14
7135: PUSH
7136: LD_INT 15
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PPUSH
7143: LD_INT 45
7145: PPUSH
7146: LD_INT 22
7148: PPUSH
7149: CALL_OW 171
// DialogueOn ;
7153: CALL_OW 6
// if IsOK ( patrol1 ) then
7157: LD_INT 14
7159: PPUSH
7160: CALL_OW 302
7164: IFFALSE 7178
// Say ( patrol1 , D8-Rus1-1 ) else
7166: LD_INT 14
7168: PPUSH
7169: LD_STRING D8-Rus1-1
7171: PPUSH
7172: CALL_OW 88
7176: GO 7188
// Say ( patrol2 , D8-Rus1-1 ) ;
7178: LD_INT 15
7180: PPUSH
7181: LD_STRING D8-Rus1-1
7183: PPUSH
7184: CALL_OW 88
// Say ( MacMillan , D8-JMM-1 ) ;
7188: LD_EXP 7
7192: PPUSH
7193: LD_STRING D8-JMM-1
7195: PPUSH
7196: CALL_OW 88
// DialogueOff ;
7200: CALL_OW 7
// ran := false ;
7204: LD_ADDR_VAR 0 2
7208: PUSH
7209: LD_INT 0
7211: ST_TO_ADDR
// repeat if ( not ran ) and ( ( IsOK ( patrol1 ) and ( GetY ( patrol1 ) < 60 ) ) or ( IsOK ( patrol2 ) and ( GetY ( patrol2 ) < 60 ) ) ) then
7212: LD_VAR 0 2
7216: NOT
7217: PUSH
7218: LD_INT 14
7220: PPUSH
7221: CALL_OW 302
7225: PUSH
7226: LD_INT 14
7228: PPUSH
7229: CALL_OW 251
7233: PUSH
7234: LD_INT 60
7236: LESS
7237: AND
7238: PUSH
7239: LD_INT 15
7241: PPUSH
7242: CALL_OW 302
7246: PUSH
7247: LD_INT 15
7249: PPUSH
7250: CALL_OW 251
7254: PUSH
7255: LD_INT 60
7257: LESS
7258: AND
7259: OR
7260: AND
7261: IFFALSE 7275
// begin ran := true ;
7263: LD_ADDR_VAR 0 2
7267: PUSH
7268: LD_INT 1
7270: ST_TO_ADDR
// talk_about_attack ;
7271: CALL 12763 0 0
// end ; Wait ( 0 0$1 ) ;
7275: LD_INT 35
7277: PPUSH
7278: CALL_OW 67
// until ( not ( IsOK ( patrol1 ) or IsOK ( patrol2 ) ) ) or ( IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) ) ;
7282: LD_INT 14
7284: PPUSH
7285: CALL_OW 302
7289: PUSH
7290: LD_INT 15
7292: PPUSH
7293: CALL_OW 302
7297: OR
7298: NOT
7299: PUSH
7300: LD_INT 14
7302: PPUSH
7303: LD_INT 7
7305: PPUSH
7306: CALL_OW 308
7310: PUSH
7311: LD_INT 15
7313: PPUSH
7314: LD_INT 7
7316: PPUSH
7317: CALL_OW 308
7321: OR
7322: OR
7323: IFFALSE 7212
// Dialogue_wait := true ;
7325: LD_ADDR_EXP 39
7329: PUSH
7330: LD_INT 1
7332: ST_TO_ADDR
// if IsInArea ( patrol1 , problemy ) or IsInArea ( patrol2 , problemy ) then
7333: LD_INT 14
7335: PPUSH
7336: LD_INT 7
7338: PPUSH
7339: CALL_OW 308
7343: PUSH
7344: LD_INT 15
7346: PPUSH
7347: LD_INT 7
7349: PPUSH
7350: CALL_OW 308
7354: OR
7355: IFFALSE 7363
// lets_destroy_americans else
7357: CALL 7386 0 0
7361: GO 7375
// Say ( MacMillan , D8a-JMM-1 ) ;
7363: LD_EXP 7
7367: PPUSH
7368: LD_STRING D8a-JMM-1
7370: PPUSH
7371: CALL_OW 88
// Dialogue_wait := false ;
7375: LD_ADDR_EXP 39
7379: PUSH
7380: LD_INT 0
7382: ST_TO_ADDR
// end ;
7383: PPOPN 7
7385: END
// function lets_destroy_americans ; var i , attackers1 , attackers2 ; begin
7386: LD_INT 0
7388: PPUSH
7389: PPUSH
7390: PPUSH
7391: PPUSH
// PriorityAttack ( russians , sklad ) ;
7392: LD_EXP 2
7396: PPUSH
7397: LD_INT 5
7399: PPUSH
7400: CALL_OW 470
// attackers1 := [ ] ;
7404: LD_ADDR_VAR 0 3
7408: PUSH
7409: EMPTY
7410: ST_TO_ADDR
// attackers2 := [ ] ;
7411: LD_ADDR_VAR 0 4
7415: PUSH
7416: EMPTY
7417: ST_TO_ADDR
// for i in ru_trucks do
7418: LD_ADDR_VAR 0 2
7422: PUSH
7423: LD_EXP 48
7427: PUSH
7428: FOR_IN
7429: IFFALSE 7487
// if ( 0 + attackers1 ) > ( 0 + attackers2 ) then
7431: LD_INT 0
7433: PUSH
7434: LD_VAR 0 3
7438: PLUS
7439: PUSH
7440: LD_INT 0
7442: PUSH
7443: LD_VAR 0 4
7447: PLUS
7448: GREATER
7449: IFFALSE 7469
// attackers2 := attackers2 ^ i else
7451: LD_ADDR_VAR 0 4
7455: PUSH
7456: LD_VAR 0 4
7460: PUSH
7461: LD_VAR 0 2
7465: ADD
7466: ST_TO_ADDR
7467: GO 7485
// attackers1 := attackers1 ^ i ;
7469: LD_ADDR_VAR 0 3
7473: PUSH
7474: LD_VAR 0 3
7478: PUSH
7479: LD_VAR 0 2
7483: ADD
7484: ST_TO_ADDR
7485: GO 7428
7487: POP
7488: POP
// ComRemember ( attackers1 ) ;
7489: LD_VAR 0 3
7493: PPUSH
7494: CALL_OW 143
// ComRemember ( attackers2 ) ;
7498: LD_VAR 0 4
7502: PPUSH
7503: CALL_OW 143
// Attack_US_Base ( attackers1 , attackers2 ) ;
7507: LD_VAR 0 3
7511: PPUSH
7512: LD_VAR 0 4
7516: PPUSH
7517: CALL 7655 0 2
// wait ( 0 0$4 ) ;
7521: LD_INT 140
7523: PPUSH
7524: CALL_OW 67
// ComReturn ( attackers1 ) ;
7528: LD_VAR 0 3
7532: PPUSH
7533: CALL_OW 144
// ComReturn ( attackers2 ) ;
7537: LD_VAR 0 4
7541: PPUSH
7542: CALL_OW 144
// end ;
7546: LD_VAR 0 1
7550: RET
// every 0 0$15 do var un ;
7551: GO 7553
7553: DISABLE
7554: LD_INT 0
7556: PPUSH
// begin for un in ru_trucks do
7557: LD_ADDR_VAR 0 1
7561: PUSH
7562: LD_EXP 48
7566: PUSH
7567: FOR_IN
7568: IFFALSE 7649
// if ( GetFuel ( un ) < 80 ) and ( not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , un , 10 ] ] ) ) then
7570: LD_VAR 0 1
7574: PPUSH
7575: CALL_OW 261
7579: PUSH
7580: LD_INT 80
7582: LESS
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_EXP 1
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 21
7598: PUSH
7599: LD_INT 1
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: LD_INT 91
7608: PUSH
7609: LD_VAR 0 1
7613: PUSH
7614: LD_INT 10
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 69
7631: NOT
7632: AND
7633: IFFALSE 7647
// SetFuel ( un , 100 ) ;
7635: LD_VAR 0 1
7639: PPUSH
7640: LD_INT 100
7642: PPUSH
7643: CALL_OW 240
7647: GO 7567
7649: POP
7650: POP
// enable ;
7651: ENABLE
// end ;
7652: PPOPN 1
7654: END
// function Attack_US_Base ( forces , backup ) ; var un , list , danger , time , driver , attack , retreat , repair ; begin
7655: LD_INT 0
7657: PPUSH
7658: PPUSH
7659: PPUSH
7660: PPUSH
7661: PPUSH
7662: PPUSH
7663: PPUSH
7664: PPUSH
7665: PPUSH
// ComAgressiveMove ( forces , 97 , 69 ) ;
7666: LD_VAR 0 1
7670: PPUSH
7671: LD_INT 97
7673: PPUSH
7674: LD_INT 69
7676: PPUSH
7677: CALL_OW 114
// wait ( 0 0$15 ) ;
7681: LD_INT 525
7683: PPUSH
7684: CALL_OW 67
// attack := forces ;
7688: LD_ADDR_VAR 0 9
7692: PUSH
7693: LD_VAR 0 1
7697: ST_TO_ADDR
// driver := [ ] ;
7698: LD_ADDR_VAR 0 8
7702: PUSH
7703: EMPTY
7704: ST_TO_ADDR
// repair := [ ] ;
7705: LD_ADDR_VAR 0 11
7709: PUSH
7710: EMPTY
7711: ST_TO_ADDR
// danger := false ;
7712: LD_ADDR_VAR 0 6
7716: PUSH
7717: LD_INT 0
7719: ST_TO_ADDR
// time := TICK ;
7720: LD_ADDR_VAR 0 7
7724: PUSH
7725: LD_OWVAR 1
7729: ST_TO_ADDR
// repeat ComAgressiveMove ( attack , 65 , 100 ) ;
7730: LD_VAR 0 9
7734: PPUSH
7735: LD_INT 65
7737: PPUSH
7738: LD_INT 100
7740: PPUSH
7741: CALL_OW 114
// for un in forces do
7745: LD_ADDR_VAR 0 4
7749: PUSH
7750: LD_VAR 0 1
7754: PUSH
7755: FOR_IN
7756: IFFALSE 7859
// begin if ( GetLives ( un ) < 600 ) and ( un in attack ) then
7758: LD_VAR 0 4
7762: PPUSH
7763: CALL_OW 256
7767: PUSH
7768: LD_INT 600
7770: LESS
7771: PUSH
7772: LD_VAR 0 4
7776: PUSH
7777: LD_VAR 0 9
7781: IN
7782: AND
7783: IFFALSE 7829
// begin attack := attack diff un ;
7785: LD_ADDR_VAR 0 9
7789: PUSH
7790: LD_VAR 0 9
7794: PUSH
7795: LD_VAR 0 4
7799: DIFF
7800: ST_TO_ADDR
// retreat := retreat ^ un ;
7801: LD_ADDR_VAR 0 10
7805: PUSH
7806: LD_VAR 0 10
7810: PUSH
7811: LD_VAR 0 4
7815: ADD
7816: ST_TO_ADDR
// ComMoveToArea ( un , ru_repair ) ;
7817: LD_VAR 0 4
7821: PPUSH
7822: LD_INT 27
7824: PPUSH
7825: CALL_OW 113
// end ; if not IsLive ( un ) then
7829: LD_VAR 0 4
7833: PPUSH
7834: CALL_OW 300
7838: NOT
7839: IFFALSE 7857
// forces := forces diff un ;
7841: LD_ADDR_VAR 0 1
7845: PUSH
7846: LD_VAR 0 1
7850: PUSH
7851: LD_VAR 0 4
7855: DIFF
7856: ST_TO_ADDR
// end ;
7857: GO 7755
7859: POP
7860: POP
// for un in retreat do
7861: LD_ADDR_VAR 0 4
7865: PUSH
7866: LD_VAR 0 10
7870: PUSH
7871: FOR_IN
7872: IFFALSE 7936
// if IsInArea ( un , ru_repair ) then
7874: LD_VAR 0 4
7878: PPUSH
7879: LD_INT 27
7881: PPUSH
7882: CALL_OW 308
7886: IFFALSE 7922
// begin retreat := retreat diff un ;
7888: LD_ADDR_VAR 0 10
7892: PUSH
7893: LD_VAR 0 10
7897: PUSH
7898: LD_VAR 0 4
7902: DIFF
7903: ST_TO_ADDR
// repair := repair ^ un ;
7904: LD_ADDR_VAR 0 11
7908: PUSH
7909: LD_VAR 0 11
7913: PUSH
7914: LD_VAR 0 4
7918: ADD
7919: ST_TO_ADDR
// end else
7920: GO 7934
// ComMoveToArea ( un , ru_repair ) ;
7922: LD_VAR 0 4
7926: PPUSH
7927: LD_INT 27
7929: PPUSH
7930: CALL_OW 113
7934: GO 7871
7936: POP
7937: POP
// for un in repair do
7938: LD_ADDR_VAR 0 4
7942: PUSH
7943: LD_VAR 0 11
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7988
// if ( GetLives ( un ) < 1000 ) and IsDrivenBy ( un ) then
7951: LD_VAR 0 4
7955: PPUSH
7956: CALL_OW 256
7960: PUSH
7961: LD_INT 1000
7963: LESS
7964: PUSH
7965: LD_VAR 0 4
7969: PPUSH
7970: CALL_OW 311
7974: AND
7975: IFFALSE 7986
// ComExitVehicle ( un ) ;
7977: LD_VAR 0 4
7981: PPUSH
7982: CALL_OW 121
7986: GO 7948
7988: POP
7989: POP
// list = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] , f_not , [ f_lives , 1000 ] ] ) ;
7990: LD_ADDR_VAR 0 5
7994: PUSH
7995: LD_INT 28
7997: PPUSH
7998: LD_INT 22
8000: PUSH
8001: LD_EXP 2
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: LD_INT 21
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: LD_INT 3
8022: PUSH
8023: LD_INT 24
8025: PUSH
8026: LD_INT 1000
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: PPUSH
8039: CALL_OW 70
8043: ST_TO_ADDR
// driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
8044: LD_ADDR_VAR 0 8
8048: PUSH
8049: LD_INT 28
8051: PPUSH
8052: LD_INT 22
8054: PUSH
8055: LD_EXP 2
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: LD_INT 21
8066: PUSH
8067: LD_INT 1
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 25
8076: PUSH
8077: LD_INT 3
8079: PUSH
8080: EMPTY
8081: LIST
8082: LIST
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 70
8093: ST_TO_ADDR
// danger = FilterUnitsInArea ( repair_around , [ [ f_side , you ] , [ f_ok ] ] ) ;
8094: LD_ADDR_VAR 0 6
8098: PUSH
8099: LD_INT 28
8101: PPUSH
8102: LD_INT 22
8104: PUSH
8105: LD_EXP 1
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: PUSH
8114: LD_INT 50
8116: PUSH
8117: EMPTY
8118: LIST
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL_OW 70
8128: ST_TO_ADDR
// if list and not danger then
8129: LD_VAR 0 5
8133: PUSH
8134: LD_VAR 0 6
8138: NOT
8139: AND
8140: IFFALSE 8162
// ComRepairVehicle ( driver , list [ 1 ] ) else
8142: LD_VAR 0 8
8146: PPUSH
8147: LD_VAR 0 5
8151: PUSH
8152: LD_INT 1
8154: ARRAY
8155: PPUSH
8156: CALL_OW 129
8160: GO 8284
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8162: LD_ADDR_VAR 0 5
8166: PUSH
8167: LD_INT 28
8169: PPUSH
8170: LD_INT 22
8172: PUSH
8173: LD_EXP 2
8177: PUSH
8178: EMPTY
8179: LIST
8180: LIST
8181: PUSH
8182: LD_INT 21
8184: PUSH
8185: LD_INT 2
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PPUSH
8196: CALL_OW 70
8200: ST_TO_ADDR
// for un = 1 to driver do
8201: LD_ADDR_VAR 0 4
8205: PUSH
8206: DOUBLE
8207: LD_INT 1
8209: DEC
8210: ST_TO_ADDR
8211: LD_VAR 0 8
8215: PUSH
8216: FOR_TO
8217: IFFALSE 8259
// if un <= list then
8219: LD_VAR 0 4
8223: PUSH
8224: LD_VAR 0 5
8228: LESSEQUAL
8229: IFFALSE 8257
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8231: LD_VAR 0 8
8235: PUSH
8236: LD_VAR 0 4
8240: ARRAY
8241: PPUSH
8242: LD_VAR 0 5
8246: PUSH
8247: LD_VAR 0 4
8251: ARRAY
8252: PPUSH
8253: CALL_OW 120
8257: GO 8216
8259: POP
8260: POP
// attack := attack union repair ;
8261: LD_ADDR_VAR 0 9
8265: PUSH
8266: LD_VAR 0 9
8270: PUSH
8271: LD_VAR 0 11
8275: UNION
8276: ST_TO_ADDR
// repair := [ ] ;
8277: LD_ADDR_VAR 0 11
8281: PUSH
8282: EMPTY
8283: ST_TO_ADDR
// end ; if not repair then
8284: LD_VAR 0 11
8288: NOT
8289: IFFALSE 8446
// begin driver = FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] ] ) ;
8291: LD_ADDR_VAR 0 8
8295: PUSH
8296: LD_INT 28
8298: PPUSH
8299: LD_INT 22
8301: PUSH
8302: LD_EXP 2
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 21
8313: PUSH
8314: LD_INT 1
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: LD_INT 25
8323: PUSH
8324: LD_INT 3
8326: PUSH
8327: EMPTY
8328: LIST
8329: LIST
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: LIST
8335: PPUSH
8336: CALL_OW 70
8340: ST_TO_ADDR
// if driver then
8341: LD_VAR 0 8
8345: IFFALSE 8446
// begin list := FilterUnitsInArea ( repair_around , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
8347: LD_ADDR_VAR 0 5
8351: PUSH
8352: LD_INT 28
8354: PPUSH
8355: LD_INT 22
8357: PUSH
8358: LD_EXP 2
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 21
8369: PUSH
8370: LD_INT 2
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 70
8385: ST_TO_ADDR
// for un = 1 to driver do
8386: LD_ADDR_VAR 0 4
8390: PUSH
8391: DOUBLE
8392: LD_INT 1
8394: DEC
8395: ST_TO_ADDR
8396: LD_VAR 0 8
8400: PUSH
8401: FOR_TO
8402: IFFALSE 8444
// if un <= list then
8404: LD_VAR 0 4
8408: PUSH
8409: LD_VAR 0 5
8413: LESSEQUAL
8414: IFFALSE 8442
// ComEnterUnit ( driver [ un ] , list [ un ] ) ;
8416: LD_VAR 0 8
8420: PUSH
8421: LD_VAR 0 4
8425: ARRAY
8426: PPUSH
8427: LD_VAR 0 5
8431: PUSH
8432: LD_VAR 0 4
8436: ARRAY
8437: PPUSH
8438: CALL_OW 120
8442: GO 8401
8444: POP
8445: POP
// end ; end ; if ( TICK > ( time + 5 5$0 ) ) and backup then
8446: LD_OWVAR 1
8450: PUSH
8451: LD_VAR 0 7
8455: PUSH
8456: LD_INT 10500
8458: PLUS
8459: GREATER
8460: PUSH
8461: LD_VAR 0 2
8465: AND
8466: IFFALSE 8486
// begin attack := backup ;
8468: LD_ADDR_VAR 0 9
8472: PUSH
8473: LD_VAR 0 2
8477: ST_TO_ADDR
// backup := false ;
8478: LD_ADDR_VAR 0 2
8482: PUSH
8483: LD_INT 0
8485: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
8486: LD_INT 35
8488: PPUSH
8489: CALL_OW 67
// until not forces ;
8493: LD_VAR 0 1
8497: NOT
8498: IFFALSE 7730
// end ; end_of_file
8500: LD_VAR 0 3
8504: RET
// export function starting_scene ; var sol1 , time ; begin
8505: LD_INT 0
8507: PPUSH
8508: PPUSH
8509: PPUSH
// time := TICK ;
8510: LD_ADDR_VAR 0 3
8514: PUSH
8515: LD_OWVAR 1
8519: ST_TO_ADDR
// wait ( 0 0$1 ) ;
8520: LD_INT 35
8522: PPUSH
8523: CALL_OW 67
// if amtruck1 then
8527: LD_EXP 35
8531: IFFALSE 8544
// CenterOnUnits ( amtruck1 ) else
8533: LD_EXP 35
8537: PPUSH
8538: CALL_OW 85
8542: GO 8553
// CenterOnUnits ( MacMillan ) ;
8544: LD_EXP 7
8548: PPUSH
8549: CALL_OW 85
// InGameOn ;
8553: CALL_OW 8
// ComWait ( Kobra1 diff MacMillan , 0 0$0.8 ) ;
8557: LD_EXP 12
8561: PUSH
8562: LD_EXP 7
8566: DIFF
8567: PPUSH
8568: LD_INT 28
8570: PPUSH
8571: CALL_OW 142
// if amtruck1 then
8575: LD_EXP 35
8579: IFFALSE 8632
// begin ComMoveXY ( amtruck1 , 172 , 112 ) ;
8581: LD_EXP 35
8585: PPUSH
8586: LD_INT 172
8588: PPUSH
8589: LD_INT 112
8591: PPUSH
8592: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8596: LD_EXP 12
8600: PUSH
8601: LD_EXP 7
8605: DIFF
8606: PPUSH
8607: LD_EXP 35
8611: PPUSH
8612: CALL_OW 172
// ComTurnUnit ( cornells , amtruck1 ) ;
8616: LD_EXP 14
8620: PPUSH
8621: LD_EXP 35
8625: PPUSH
8626: CALL_OW 119
// end else
8630: GO 8681
// begin ComMoveXY ( MacMillan , 168 , 109 ) ;
8632: LD_EXP 7
8636: PPUSH
8637: LD_INT 168
8639: PPUSH
8640: LD_INT 109
8642: PPUSH
8643: CALL_OW 111
// AddComMoveUnit ( Kobra1 diff MacMillan , amtruck1 ) ;
8647: LD_EXP 12
8651: PUSH
8652: LD_EXP 7
8656: DIFF
8657: PPUSH
8658: LD_EXP 35
8662: PPUSH
8663: CALL_OW 172
// ComTurnUnit ( cornells , MacMillan ) ;
8667: LD_EXP 14
8671: PPUSH
8672: LD_EXP 7
8676: PPUSH
8677: CALL_OW 119
// end ; if amtruck2 then
8681: LD_EXP 36
8685: IFFALSE 8711
// begin ComMoveXY ( amtruck2 , 164 , 110 ) ;
8687: LD_EXP 36
8691: PPUSH
8692: LD_INT 164
8694: PPUSH
8695: LD_INT 110
8697: PPUSH
8698: CALL_OW 111
// AddComExitVehicle ( amtruck2 ) ;
8702: LD_EXP 36
8706: PPUSH
8707: CALL_OW 181
// end ; ComMoveXY ( Cornell , 165 , 105 ) ;
8711: LD_EXP 8
8715: PPUSH
8716: LD_INT 165
8718: PPUSH
8719: LD_INT 105
8721: PPUSH
8722: CALL_OW 111
// wait ( 0 0$1.5 ) ;
8726: LD_INT 52
8728: PPUSH
8729: CALL_OW 67
// ComHold ( Kobra1 diff MacMillan ) ;
8733: LD_EXP 12
8737: PUSH
8738: LD_EXP 7
8742: DIFF
8743: PPUSH
8744: CALL_OW 140
// if amtruck1 then
8748: LD_EXP 35
8752: IFFALSE 8804
// begin repeat Wait ( 0 0$0.5 ) ;
8754: LD_INT 18
8756: PPUSH
8757: CALL_OW 67
// until not IsBusy ( amtruck1 ) ;
8761: LD_EXP 35
8765: PPUSH
8766: CALL_OW 315
8770: NOT
8771: IFFALSE 8754
// ComExitVehicle ( amtruck1 ) ;
8773: LD_EXP 35
8777: PPUSH
8778: CALL_OW 121
// wait ( 0 0$0.2 ) ;
8782: LD_INT 7
8784: PPUSH
8785: CALL_OW 67
// ComMoveXY ( MacMillan , 168 , 109 ) ;
8789: LD_EXP 7
8793: PPUSH
8794: LD_INT 168
8796: PPUSH
8797: LD_INT 109
8799: PPUSH
8800: CALL_OW 111
// end ; repeat Wait ( 0 0$0.5 ) ;
8804: LD_INT 18
8806: PPUSH
8807: CALL_OW 67
// until not IsBusy ( MacMillan ) ;
8811: LD_EXP 7
8815: PPUSH
8816: CALL_OW 315
8820: NOT
8821: IFFALSE 8804
// ComHold ( Kobra1 ) ;
8823: LD_EXP 12
8827: PPUSH
8828: CALL_OW 140
// ComTurnUnit ( MacMillan , Cornell ) ;
8832: LD_EXP 7
8836: PPUSH
8837: LD_EXP 8
8841: PPUSH
8842: CALL_OW 119
// ComTurnUnit ( Cornell , MacMillan ) ;
8846: LD_EXP 8
8850: PPUSH
8851: LD_EXP 7
8855: PPUSH
8856: CALL_OW 119
// Wait ( 0 0$1 ) ;
8860: LD_INT 35
8862: PPUSH
8863: CALL_OW 67
// InGameOff ;
8867: CALL_OW 9
// DialogueOn ;
8871: CALL_OW 6
// interface_hidden := true ;
8875: LD_ADDR_OWVAR 54
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
8883: LD_EXP 7
8887: PPUSH
8888: LD_STRING D1-JMM-1
8890: PPUSH
8891: CALL_OW 88
// Say ( Cornell , D1-Corn-1 ) ;
8895: LD_EXP 8
8899: PPUSH
8900: LD_STRING D1-Corn-1
8902: PPUSH
8903: CALL_OW 88
// ComStop ( cornells ) ;
8907: LD_EXP 14
8911: PPUSH
8912: CALL_OW 141
// Say ( MacMillan , D1-JMM-2 ) ;
8916: LD_EXP 7
8920: PPUSH
8921: LD_STRING D1-JMM-2
8923: PPUSH
8924: CALL_OW 88
// Say ( MacMillan , D1-JMM-2a ) ;
8928: LD_EXP 7
8932: PPUSH
8933: LD_STRING D1-JMM-2a
8935: PPUSH
8936: CALL_OW 88
// Say ( Cornell , D1-Corn-2 ) ;
8940: LD_EXP 8
8944: PPUSH
8945: LD_STRING D1-Corn-2
8947: PPUSH
8948: CALL_OW 88
// if IsOK ( Mikhail ) then
8952: LD_EXP 21
8956: PPUSH
8957: CALL_OW 302
8961: IFFALSE 9086
// begin Say ( Cornell , D1a-Corn-1 ) ;
8963: LD_EXP 8
8967: PPUSH
8968: LD_STRING D1a-Corn-1
8970: PPUSH
8971: CALL_OW 88
// Say ( MacMillan , D1a-JMM-1 ) ;
8975: LD_EXP 7
8979: PPUSH
8980: LD_STRING D1a-JMM-1
8982: PPUSH
8983: CALL_OW 88
// ComMoveXY ( Mikhail , 169 , 107 ) ;
8987: LD_EXP 21
8991: PPUSH
8992: LD_INT 169
8994: PPUSH
8995: LD_INT 107
8997: PPUSH
8998: CALL_OW 111
// Say ( Cornell , D1a-Corn-2 ) ;
9002: LD_EXP 8
9006: PPUSH
9007: LD_STRING D1a-Corn-2
9009: PPUSH
9010: CALL_OW 88
// Say ( MacMillan , D1a-JMM-2 ) ;
9014: LD_EXP 7
9018: PPUSH
9019: LD_STRING D1a-JMM-2
9021: PPUSH
9022: CALL_OW 88
// Say ( Cornell , D1a-Corn-3 ) ;
9026: LD_EXP 8
9030: PPUSH
9031: LD_STRING D1a-Corn-3
9033: PPUSH
9034: CALL_OW 88
// Say ( MacMillan , D1a-JMM-3 ) ;
9038: LD_EXP 7
9042: PPUSH
9043: LD_STRING D1a-JMM-3
9045: PPUSH
9046: CALL_OW 88
// Say ( Cornell , D1a-Corn-4 ) ;
9050: LD_EXP 8
9054: PPUSH
9055: LD_STRING D1a-Corn-4
9057: PPUSH
9058: CALL_OW 88
// Say ( MacMillan , D1a-JMM-4 ) ;
9062: LD_EXP 7
9066: PPUSH
9067: LD_STRING D1a-JMM-4
9069: PPUSH
9070: CALL_OW 88
// Say ( Cornell , D1a-Corn-5 ) ;
9074: LD_EXP 8
9078: PPUSH
9079: LD_STRING D1a-Corn-5
9081: PPUSH
9082: CALL_OW 88
// end ; Say ( MacMillan , D1b-JMM-1 ) ;
9086: LD_EXP 7
9090: PPUSH
9091: LD_STRING D1b-JMM-1
9093: PPUSH
9094: CALL_OW 88
// Say ( Cornell , D1b-Corn-1 ) ;
9098: LD_EXP 8
9102: PPUSH
9103: LD_STRING D1b-Corn-1
9105: PPUSH
9106: CALL_OW 88
// Say ( MacMillan , D1b-JMM-2 ) ;
9110: LD_EXP 7
9114: PPUSH
9115: LD_STRING D1b-JMM-2
9117: PPUSH
9118: CALL_OW 88
// Say ( Cornell , D1b-Corn-2 ) ;
9122: LD_EXP 8
9126: PPUSH
9127: LD_STRING D1b-Corn-2
9129: PPUSH
9130: CALL_OW 88
// Say ( MacMillan , D1b-JMM-3 ) ;
9134: LD_EXP 7
9138: PPUSH
9139: LD_STRING D1b-JMM-3
9141: PPUSH
9142: CALL_OW 88
// SayRadio ( Powell , D1b-Pow-3 ) ;
9146: LD_EXP 9
9150: PPUSH
9151: LD_STRING D1b-Pow-3
9153: PPUSH
9154: CALL_OW 94
// Say ( MacMillan , D1b-JMM-4 ) ;
9158: LD_EXP 7
9162: PPUSH
9163: LD_STRING D1b-JMM-4
9165: PPUSH
9166: CALL_OW 88
// Say ( Cornell , D1b-Corn-4 ) ;
9170: LD_EXP 8
9174: PPUSH
9175: LD_STRING D1b-Corn-4
9177: PPUSH
9178: CALL_OW 88
// if IsOK ( Khatam ) then
9182: LD_EXP 10
9186: PPUSH
9187: CALL_OW 302
9191: IFFALSE 9207
// Say ( Khatam , D1b-Khat-4 ) else
9193: LD_EXP 10
9197: PPUSH
9198: LD_STRING D1b-Khat-4
9200: PPUSH
9201: CALL_OW 88
9205: GO 9254
// begin sol1 := UnitFilter ( cornells , [ f_sex , sex_male ] ) ;
9207: LD_ADDR_VAR 0 2
9211: PUSH
9212: LD_EXP 14
9216: PPUSH
9217: LD_INT 26
9219: PUSH
9220: LD_INT 1
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PPUSH
9227: CALL_OW 72
9231: ST_TO_ADDR
// if sol1 then
9232: LD_VAR 0 2
9236: IFFALSE 9254
// Say ( sol1 [ 1 ] , D1b-Sol1-4 ) ;
9238: LD_VAR 0 2
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_STRING D1b-Sol1-4
9249: PPUSH
9250: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
9254: LD_EXP 5
9258: PPUSH
9259: CALL_OW 302
9263: IFFALSE 9312
// begin Say ( Cyrus , D1b-Cyrus-4 ) ;
9265: LD_EXP 5
9269: PPUSH
9270: LD_STRING D1b-Cyrus-4
9272: PPUSH
9273: CALL_OW 88
// if IsOK ( Lisa ) then
9277: LD_EXP 6
9281: PPUSH
9282: CALL_OW 302
9286: IFFALSE 9312
// begin Say ( Lisa , D1b-Lisa-4 ) ;
9288: LD_EXP 6
9292: PPUSH
9293: LD_STRING D1b-Lisa-4
9295: PPUSH
9296: CALL_OW 88
// Say ( Cyrus , D1b-Cyrus-5 ) ;
9300: LD_EXP 5
9304: PPUSH
9305: LD_STRING D1b-Cyrus-5
9307: PPUSH
9308: CALL_OW 88
// end ; end ; SelectGroup ;
9312: CALL 9554 0 0
// interface_hidden := false ;
9316: LD_ADDR_OWVAR 54
9320: PUSH
9321: LD_INT 0
9323: ST_TO_ADDR
// DialogueOff ;
9324: CALL_OW 7
// InGameOn ;
9328: CALL_OW 8
// enable ( 4 ) ;
9332: LD_INT 4
9334: ENABLE_MARKED
// Say ( MacMillan , D1d-JMM-1 ) ;
9335: LD_EXP 7
9339: PPUSH
9340: LD_STRING D1d-JMM-1
9342: PPUSH
9343: CALL_OW 88
// Say ( Cornell , D1d-Corn-1 ) ;
9347: LD_EXP 8
9351: PPUSH
9352: LD_STRING D1d-Corn-1
9354: PPUSH
9355: CALL_OW 88
// SetSide ( Cornell , neutral ) ;
9359: LD_EXP 8
9363: PPUSH
9364: LD_EXP 3
9368: PPUSH
9369: CALL_OW 235
// if amtruck2 then
9373: LD_EXP 36
9377: IFFALSE 9428
// begin ComEnterUnit ( Cornell , amtruck2 ) ;
9379: LD_EXP 8
9383: PPUSH
9384: LD_EXP 36
9388: PPUSH
9389: CALL_OW 120
// repeat wait ( 0 0$1 ) until IsInUnit ( Cornell ) ;
9393: LD_INT 35
9395: PPUSH
9396: CALL_OW 67
9400: LD_EXP 8
9404: PPUSH
9405: CALL_OW 310
9409: IFFALSE 9393
// ComMoveXY ( amtruck2 , 166 , 95 ) ;
9411: LD_EXP 36
9415: PPUSH
9416: LD_INT 166
9418: PPUSH
9419: LD_INT 95
9421: PPUSH
9422: CALL_OW 111
// end else
9426: GO 9452
// begin ComStop ( Cornell ) ;
9428: LD_EXP 8
9432: PPUSH
9433: CALL_OW 141
// ComMoveXY ( Cornell , 166 , 95 ) ;
9437: LD_EXP 8
9441: PPUSH
9442: LD_INT 166
9444: PPUSH
9445: LD_INT 95
9447: PPUSH
9448: CALL_OW 111
// end ; SaveForQuickRestart ;
9452: CALL_OW 22
// enable ( 8 ) ;
9456: LD_INT 8
9458: ENABLE_MARKED
// enable ( 3 ) ;
9459: LD_INT 3
9461: ENABLE_MARKED
// wait ( 0 0$0.5 ) ;
9462: LD_INT 18
9464: PPUSH
9465: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
9469: LD_STRING M1
9471: PPUSH
9472: CALL_OW 337
// TICK := time ;
9476: LD_ADDR_OWVAR 1
9480: PUSH
9481: LD_VAR 0 3
9485: ST_TO_ADDR
// ComFree ( [ yours ] ) ;
9486: LD_EXP 15
9490: PUSH
9491: EMPTY
9492: LIST
9493: PPUSH
9494: CALL_OW 139
// InGameOff ;
9498: CALL_OW 9
// Wait ( 0 0$5 ) ;
9502: LD_INT 175
9504: PPUSH
9505: CALL_OW 67
// SetAttitude ( russians , you , att_enemy , true ) ;
9509: LD_EXP 2
9513: PPUSH
9514: LD_EXP 1
9518: PPUSH
9519: LD_INT 2
9521: PPUSH
9522: LD_INT 1
9524: PPUSH
9525: CALL_OW 80
// SetAttitude ( russians , neutral , att_enemy , true ) ;
9529: LD_EXP 2
9533: PPUSH
9534: LD_EXP 3
9538: PPUSH
9539: LD_INT 2
9541: PPUSH
9542: LD_INT 1
9544: PPUSH
9545: CALL_OW 80
// end ;
9549: LD_VAR 0 1
9553: RET
// function SelectGroup ; var units ; begin
9554: LD_INT 0
9556: PPUSH
9557: PPUSH
// units := [ MacMillan , sel_changeable ] ^ ( Kobra1 diff [ MacMillan , Mikhail ] ) ^ [ sel_not_hired , sel_not_changeable , Cornell , Mikhail ] ^ [ sel_changeable ] ^ cornells ;
9558: LD_ADDR_VAR 0 2
9562: PUSH
9563: LD_EXP 7
9567: PUSH
9568: LD_INT -3
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PUSH
9575: LD_EXP 12
9579: PUSH
9580: LD_EXP 7
9584: PUSH
9585: LD_EXP 21
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: DIFF
9594: ADD
9595: PUSH
9596: LD_INT -2
9598: PUSH
9599: LD_INT -4
9601: PUSH
9602: LD_EXP 8
9606: PUSH
9607: LD_EXP 21
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: ADD
9618: PUSH
9619: LD_INT -3
9621: PUSH
9622: EMPTY
9623: LIST
9624: ADD
9625: PUSH
9626: LD_EXP 14
9630: ADD
9631: ST_TO_ADDR
// yours := MacMillan ^ CharacterSelection ( Select five characters to go with you , 5 , 5 , units , [ ] ) ;
9632: LD_ADDR_EXP 15
9636: PUSH
9637: LD_EXP 7
9641: PUSH
9642: LD_STRING Select five characters to go with you
9644: PPUSH
9645: LD_INT 5
9647: PPUSH
9648: LD_INT 5
9650: PPUSH
9651: LD_VAR 0 2
9655: PPUSH
9656: EMPTY
9657: PPUSH
9658: CALL_OW 42
9662: ADD
9663: ST_TO_ADDR
// Cornell_group := Kobra1 union cornells diff yours ;
9664: LD_ADDR_EXP 34
9668: PUSH
9669: LD_EXP 12
9673: PUSH
9674: LD_EXP 14
9678: UNION
9679: PUSH
9680: LD_EXP 15
9684: DIFF
9685: ST_TO_ADDR
// end ;
9686: LD_VAR 0 1
9690: RET
// every 0 0$0.5 marked 4 do var pom_replace , lidi_mimo , group_out ;
9691: GO 9693
9693: DISABLE
9694: LD_INT 0
9696: PPUSH
9697: PPUSH
9698: PPUSH
// begin group_out := Cornell_group diff Cornell ;
9699: LD_ADDR_VAR 0 3
9703: PUSH
9704: LD_EXP 34
9708: PUSH
9709: LD_EXP 8
9713: DIFF
9714: ST_TO_ADDR
// SetSide ( Cornell_group , neutral ) ;
9715: LD_EXP 34
9719: PPUSH
9720: LD_EXP 3
9724: PPUSH
9725: CALL_OW 235
// ComMoveXY ( Cornell_group diff Cornell , 165 , 93 ) ;
9729: LD_EXP 34
9733: PUSH
9734: LD_EXP 8
9738: DIFF
9739: PPUSH
9740: LD_INT 165
9742: PPUSH
9743: LD_INT 93
9745: PPUSH
9746: CALL_OW 111
// repeat lidi_mimo := FilterUnitsInArea ( Leaving , [ [ f_side , neutral ] ] ) ;
9750: LD_ADDR_VAR 0 2
9754: PUSH
9755: LD_INT 3
9757: PPUSH
9758: LD_INT 22
9760: PUSH
9761: LD_EXP 3
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PUSH
9770: EMPTY
9771: LIST
9772: PPUSH
9773: CALL_OW 70
9777: ST_TO_ADDR
// group_out := group_out diff lidi_mimo ;
9778: LD_ADDR_VAR 0 3
9782: PUSH
9783: LD_VAR 0 3
9787: PUSH
9788: LD_VAR 0 2
9792: DIFF
9793: ST_TO_ADDR
// if lidi_mimo then
9794: LD_VAR 0 2
9798: IFFALSE 9826
// for pom_replace in lidi_mimo do
9800: LD_ADDR_VAR 0 1
9804: PUSH
9805: LD_VAR 0 2
9809: PUSH
9810: FOR_IN
9811: IFFALSE 9824
// RemoveUnit ( pom_replace ) ;
9813: LD_VAR 0 1
9817: PPUSH
9818: CALL_OW 64
9822: GO 9810
9824: POP
9825: POP
// Wait ( 0 0$0.5 ) ;
9826: LD_INT 18
9828: PPUSH
9829: CALL_OW 67
// until not group_out ;
9833: LD_VAR 0 3
9837: NOT
9838: IFFALSE 9750
// end ;
9840: PPOPN 3
9842: END
// every 0 0$0.5 marked 8 do
9843: GO 9845
9845: DISABLE
// begin repeat if IsInUnit ( Cornell ) then
9846: LD_EXP 8
9850: PPUSH
9851: CALL_OW 310
9855: IFFALSE 9879
// ComMoveXY ( IsInUnit ( Cornell ) , 166 , 95 ) else
9857: LD_EXP 8
9861: PPUSH
9862: CALL_OW 310
9866: PPUSH
9867: LD_INT 166
9869: PPUSH
9870: LD_INT 95
9872: PPUSH
9873: CALL_OW 111
9877: GO 9894
// ComMoveXY ( Cornell , 166 , 95 ) ;
9879: LD_EXP 8
9883: PPUSH
9884: LD_INT 166
9886: PPUSH
9887: LD_INT 95
9889: PPUSH
9890: CALL_OW 111
// Wait ( 0 0$0.5 ) ;
9894: LD_INT 18
9896: PPUSH
9897: CALL_OW 67
// until not ( IsBusy ( Cornell ) or IsBusy ( IsInUnit ( Cornell ) ) ) ;
9901: LD_EXP 8
9905: PPUSH
9906: CALL_OW 315
9910: PUSH
9911: LD_EXP 8
9915: PPUSH
9916: CALL_OW 310
9920: PPUSH
9921: CALL_OW 315
9925: OR
9926: NOT
9927: IFFALSE 9846
// if IsInUnit ( Cornell ) then
9929: LD_EXP 8
9933: PPUSH
9934: CALL_OW 310
9938: IFFALSE 9956
// RemoveUnit ( IsInUnit ( Cornell ) ) else
9940: LD_EXP 8
9944: PPUSH
9945: CALL_OW 310
9949: PPUSH
9950: CALL_OW 64
9954: GO 9965
// RemoveUnit ( Cornell ) ;
9956: LD_EXP 8
9960: PPUSH
9961: CALL_OW 64
// enable ( 3 ) ;
9965: LD_INT 3
9967: ENABLE_MARKED
// end ;
9968: END
// var tick_after ; every 0 0$1 trigger IsInArea ( MacMillan , Meeting ) do
9969: LD_EXP 7
9973: PPUSH
9974: LD_INT 4
9976: PPUSH
9977: CALL_OW 308
9981: IFFALSE 10534
9983: GO 9985
9985: DISABLE
// begin SetSideBase ( GetBase ( sklad ) , you ) ;
9986: LD_INT 5
9988: PPUSH
9989: CALL_OW 274
9993: PPUSH
9994: LD_EXP 1
9998: PPUSH
9999: CALL_OW 236
// SetSide ( [ am1 , am2 , am4 , am5 ] , you ) ;
10003: LD_INT 2
10005: PUSH
10006: LD_INT 3
10008: PUSH
10009: LD_INT 1
10011: PUSH
10012: LD_INT 4
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: PPUSH
10021: LD_EXP 1
10025: PPUSH
10026: CALL_OW 235
// RevealFogArea ( you , Am_Base ) ;
10030: LD_EXP 1
10034: PPUSH
10035: LD_INT 2
10037: PPUSH
10038: CALL_OW 332
// ComMoveUnit ( MacMillan , am1 ) ;
10042: LD_EXP 7
10046: PPUSH
10047: LD_INT 2
10049: PPUSH
10050: CALL_OW 112
// ComMoveUnit ( am1 , MacMillan ) ;
10054: LD_INT 2
10056: PPUSH
10057: LD_EXP 7
10061: PPUSH
10062: CALL_OW 112
// repeat Wait ( 0 0$0.5 ) ;
10066: LD_INT 18
10068: PPUSH
10069: CALL_OW 67
// until GetDistUnits ( MacMillan , am1 ) < 5 ;
10073: LD_EXP 7
10077: PPUSH
10078: LD_INT 2
10080: PPUSH
10081: CALL_OW 296
10085: PUSH
10086: LD_INT 5
10088: LESS
10089: IFFALSE 10066
// ComStop ( [ MacMillan , am1 ] ) ;
10091: LD_EXP 7
10095: PUSH
10096: LD_INT 2
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PPUSH
10103: CALL_OW 141
// CenterOnUnits ( am1 ) ;
10107: LD_INT 2
10109: PPUSH
10110: CALL_OW 85
// ComTurnUnit ( MacMillan , am1 ) ;
10114: LD_EXP 7
10118: PPUSH
10119: LD_INT 2
10121: PPUSH
10122: CALL_OW 119
// ComTurnUnit ( am1 , MacMillan ) ;
10126: LD_INT 2
10128: PPUSH
10129: LD_EXP 7
10133: PPUSH
10134: CALL_OW 119
// ComHold ( [ am1 , am2 , am4 , am5 ] ) ;
10138: LD_INT 2
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 1
10146: PUSH
10147: LD_INT 4
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PPUSH
10156: CALL_OW 140
// Wait ( 0 0$1 ) ;
10160: LD_INT 35
10162: PPUSH
10163: CALL_OW 67
// DialogueOn ;
10167: CALL_OW 6
// interface_hidden := true ;
10171: LD_ADDR_OWVAR 54
10175: PUSH
10176: LD_INT 1
10178: ST_TO_ADDR
// Say ( MacMillan , D2-JMM-1 ) ;
10179: LD_EXP 7
10183: PPUSH
10184: LD_STRING D2-JMM-1
10186: PPUSH
10187: CALL_OW 88
// Say ( am1 , D2-Sol1-1 ) ;
10191: LD_INT 2
10193: PPUSH
10194: LD_STRING D2-Sol1-1
10196: PPUSH
10197: CALL_OW 88
// Say ( MacMillan , D2-JMM-2 ) ;
10201: LD_EXP 7
10205: PPUSH
10206: LD_STRING D2-JMM-2
10208: PPUSH
10209: CALL_OW 88
// Say ( am1 , D2-Sol1-2 ) ;
10213: LD_INT 2
10215: PPUSH
10216: LD_STRING D2-Sol1-2
10218: PPUSH
10219: CALL_OW 88
// Say ( MacMillan , D2-JMM-3 ) ;
10223: LD_EXP 7
10227: PPUSH
10228: LD_STRING D2-JMM-3
10230: PPUSH
10231: CALL_OW 88
// Say ( am1 , D2-Sol1-3 ) ;
10235: LD_INT 2
10237: PPUSH
10238: LD_STRING D2-Sol1-3
10240: PPUSH
10241: CALL_OW 88
// Say ( MacMillan , D2-JMM-4 ) ;
10245: LD_EXP 7
10249: PPUSH
10250: LD_STRING D2-JMM-4
10252: PPUSH
10253: CALL_OW 88
// Say ( am1 , D2-Sol1-4 ) ;
10257: LD_INT 2
10259: PPUSH
10260: LD_STRING D2-Sol1-4
10262: PPUSH
10263: CALL_OW 88
// Say ( MacMillan , D2-JMM-5 ) ;
10267: LD_EXP 7
10271: PPUSH
10272: LD_STRING D2-JMM-5
10274: PPUSH
10275: CALL_OW 88
// async ;
10279: ASYNC
// Say ( am1 , D2-Sol1-5 ) ;
10280: LD_INT 2
10282: PPUSH
10283: LD_STRING D2-Sol1-5
10285: PPUSH
10286: CALL_OW 88
// sync ;
10290: SYNC
// RevealFogArea ( you , panika_1 ) ;
10291: LD_EXP 1
10295: PPUSH
10296: LD_INT 9
10298: PPUSH
10299: CALL_OW 332
// CenterOnXY ( 121 , 51 ) ;
10303: LD_INT 121
10305: PPUSH
10306: LD_INT 51
10308: PPUSH
10309: CALL_OW 84
// DWait ( 0 0$6 ) ;
10313: LD_INT 210
10315: PPUSH
10316: CALL_OW 68
// RevealFogArea ( you , panika_2 ) ;
10320: LD_EXP 1
10324: PPUSH
10325: LD_INT 10
10327: PPUSH
10328: CALL_OW 332
// CenterOnXY ( 90 , 36 ) ;
10332: LD_INT 90
10334: PPUSH
10335: LD_INT 36
10337: PPUSH
10338: CALL_OW 84
// DWait ( 0 0$3 ) ;
10342: LD_INT 105
10344: PPUSH
10345: CALL_OW 68
// async ;
10349: ASYNC
// Say ( MacMillan , D2-JMM-6 ) ;
10350: LD_EXP 7
10354: PPUSH
10355: LD_STRING D2-JMM-6
10357: PPUSH
10358: CALL_OW 88
// sync ;
10362: SYNC
// RevealFogArea ( you , panika_3 ) ;
10363: LD_EXP 1
10367: PPUSH
10368: LD_INT 11
10370: PPUSH
10371: CALL_OW 332
// CenterOnXY ( 58 , 33 ) ;
10375: LD_INT 58
10377: PPUSH
10378: LD_INT 33
10380: PPUSH
10381: CALL_OW 84
// DWait ( 0 0$3 ) ;
10385: LD_INT 105
10387: PPUSH
10388: CALL_OW 68
// RevealFogArea ( you , panika_4 ) ;
10392: LD_EXP 1
10396: PPUSH
10397: LD_INT 12
10399: PPUSH
10400: CALL_OW 332
// CenterOnXY ( 36 , 42 ) ;
10404: LD_INT 36
10406: PPUSH
10407: LD_INT 42
10409: PPUSH
10410: CALL_OW 84
// Say ( am1 , D2-Sol1-6 ) ;
10414: LD_INT 2
10416: PPUSH
10417: LD_STRING D2-Sol1-6
10419: PPUSH
10420: CALL_OW 88
// CenterOnUnits ( MacMillan ) ;
10424: LD_EXP 7
10428: PPUSH
10429: CALL_OW 85
// Say ( MacMillan , D2-JMM-7 ) ;
10433: LD_EXP 7
10437: PPUSH
10438: LD_STRING D2-JMM-7
10440: PPUSH
10441: CALL_OW 88
// Say ( am1 , D2-Sol1-7 ) ;
10445: LD_INT 2
10447: PPUSH
10448: LD_STRING D2-Sol1-7
10450: PPUSH
10451: CALL_OW 88
// Say ( MacMillan , D2-JMM-8 ) ;
10455: LD_EXP 7
10459: PPUSH
10460: LD_STRING D2-JMM-8
10462: PPUSH
10463: CALL_OW 88
// DialogueOff ;
10467: CALL_OW 7
// interface_hidden := false ;
10471: LD_ADDR_OWVAR 54
10475: PUSH
10476: LD_INT 0
10478: ST_TO_ADDR
// ComFree ( [ am1 , am2 , am4 , am5 ] ) ;
10479: LD_INT 2
10481: PUSH
10482: LD_INT 3
10484: PUSH
10485: LD_INT 1
10487: PUSH
10488: LD_INT 4
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: PPUSH
10497: CALL_OW 139
// ChangeMissionObjectives ( MOutCap ) ;
10501: LD_STRING MOutCap
10503: PPUSH
10504: CALL_OW 337
// ChangeMissionObjectives ( MSolar1 ) ;
10508: LD_STRING MSolar1
10510: PPUSH
10511: CALL_OW 337
// Hint ( BuildingBase ) ;
10515: LD_STRING BuildingBase
10517: PPUSH
10518: CALL_OW 339
// base_reached := true ;
10522: LD_ADDR_EXP 45
10526: PUSH
10527: LD_INT 1
10529: ST_TO_ADDR
// talk_about_shipments ;
10530: CALL 10535 0 0
// end ;
10534: END
// function talk_about_shipments ; var fin , m , n ; begin
10535: LD_INT 0
10537: PPUSH
10538: PPUSH
10539: PPUSH
10540: PPUSH
// fin := false ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_INT 0
10548: ST_TO_ADDR
// while not GetResourceArea ( am_base , mat_cans ) do
10549: LD_INT 2
10551: PPUSH
10552: LD_INT 1
10554: PPUSH
10555: CALL_OW 287
10559: NOT
10560: IFFALSE 10571
// wait ( 0 0$3 ) ;
10562: LD_INT 105
10564: PPUSH
10565: CALL_OW 67
10569: GO 10549
// Hint ( Crates ) ;
10571: LD_STRING Crates
10573: PPUSH
10574: CALL_OW 339
// m := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10578: LD_ADDR_VAR 0 3
10582: PUSH
10583: LD_INT 5
10585: PPUSH
10586: CALL_OW 274
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 275
10598: ST_TO_ADDR
// repeat n := GetResourceType ( GetBase ( sklad ) , mat_cans ) ;
10599: LD_ADDR_VAR 0 4
10603: PUSH
10604: LD_INT 5
10606: PPUSH
10607: CALL_OW 274
10611: PPUSH
10612: LD_INT 1
10614: PPUSH
10615: CALL_OW 275
10619: ST_TO_ADDR
// if n > m then
10620: LD_VAR 0 4
10624: PUSH
10625: LD_VAR 0 3
10629: GREATER
10630: IFFALSE 10642
// fin := true else
10632: LD_ADDR_VAR 0 2
10636: PUSH
10637: LD_INT 1
10639: ST_TO_ADDR
10640: GO 10652
// m := n ;
10642: LD_ADDR_VAR 0 3
10646: PUSH
10647: LD_VAR 0 4
10651: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10652: LD_INT 35
10654: PPUSH
10655: CALL_OW 67
// until fin ;
10659: LD_VAR 0 2
10663: IFFALSE 10599
// wait ( 0 0$2 ) ;
10665: LD_INT 70
10667: PPUSH
10668: CALL_OW 67
// DisableExclamations ;
10672: CALL_OW 474
// DialogueOn ;
10676: CALL_OW 6
// interface_hidden := true ;
10680: LD_ADDR_OWVAR 54
10684: PUSH
10685: LD_INT 1
10687: ST_TO_ADDR
// Say ( MacMillan , D2a-JMM-1 ) ;
10688: LD_EXP 7
10692: PPUSH
10693: LD_STRING D2a-JMM-1
10695: PPUSH
10696: CALL_OW 88
// Say ( am5 , D2a-Sci1-1 ) ;
10700: LD_INT 4
10702: PPUSH
10703: LD_STRING D2a-Sci1-1
10705: PPUSH
10706: CALL_OW 88
// Say ( MacMillan , D2a-JMM-2 ) ;
10710: LD_EXP 7
10714: PPUSH
10715: LD_STRING D2a-JMM-2
10717: PPUSH
10718: CALL_OW 88
// Say ( am5 , D2a-Sci1-2 ) ;
10722: LD_INT 4
10724: PPUSH
10725: LD_STRING D2a-Sci1-2
10727: PPUSH
10728: CALL_OW 88
// Say ( MacMillan , D2a-JMM-3 ) ;
10732: LD_EXP 7
10736: PPUSH
10737: LD_STRING D2a-JMM-3
10739: PPUSH
10740: CALL_OW 88
// Say ( am5 , D2a-Sci1-3 ) ;
10744: LD_INT 4
10746: PPUSH
10747: LD_STRING D2a-Sci1-3
10749: PPUSH
10750: CALL_OW 88
// interface_hidden := false ;
10754: LD_ADDR_OWVAR 54
10758: PUSH
10759: LD_INT 0
10761: ST_TO_ADDR
// DialogueOff ;
10762: CALL_OW 7
// EnableExclamations ;
10766: CALL_OW 473
// enable ( 10 ) ;
10770: LD_INT 10
10772: ENABLE_MARKED
// enable ( 2 ) ;
10773: LD_INT 2
10775: ENABLE_MARKED
// end ;
10776: LD_VAR 0 1
10780: RET
// on VehicleConstructed ( vyrobene_auto , tovarna ) marked 10 do begin talk_about_first_car ;
10781: CALL 10806 0 0
// solar_constructed := true ;
10785: LD_ADDR_EXP 42
10789: PUSH
10790: LD_INT 1
10792: ST_TO_ADDR
// ChangeMissionObjectives ( MOutSol ) ;
10793: LD_STRING MOutSol
10795: PPUSH
10796: CALL_OW 337
// disable ( 10 ) ;
10800: LD_INT 10
10802: DISABLE_MARKED
// end ;
10803: PPOPN 2
10805: END
// function talk_about_first_car ; begin
10806: LD_INT 0
10808: PPUSH
// repeat wait ( 0 0$1 ) ;
10809: LD_INT 35
10811: PPUSH
10812: CALL_OW 67
// until not Dialogue_wait ;
10816: LD_EXP 39
10820: NOT
10821: IFFALSE 10809
// Wait ( 0 0$3 ) ;
10823: LD_INT 105
10825: PPUSH
10826: CALL_OW 67
// DialogueOn ;
10830: CALL_OW 6
// interface_hidden := true ;
10834: LD_ADDR_OWVAR 54
10838: PUSH
10839: LD_INT 1
10841: ST_TO_ADDR
// Hint ( Vehicle ) ;
10842: LD_STRING Vehicle
10844: PPUSH
10845: CALL_OW 339
// Say ( MacMillan , D2b-JMM-1 ) ;
10849: LD_EXP 7
10853: PPUSH
10854: LD_STRING D2b-JMM-1
10856: PPUSH
10857: CALL_OW 88
// if IsOK ( am5 ) then
10861: LD_INT 4
10863: PPUSH
10864: CALL_OW 302
10868: IFFALSE 10882
// Say ( am5 , D2b-Sci1-1 ) else
10870: LD_INT 4
10872: PPUSH
10873: LD_STRING D2b-Sci1-1
10875: PPUSH
10876: CALL_OW 88
10880: GO 10894
// Say ( Khatam , D2b-Sci1-1 ) ;
10882: LD_EXP 10
10886: PPUSH
10887: LD_STRING D2b-Sci1-1
10889: PPUSH
10890: CALL_OW 88
// Say ( MacMillan , D2b-JMM-2 ) ;
10894: LD_EXP 7
10898: PPUSH
10899: LD_STRING D2b-JMM-2
10901: PPUSH
10902: CALL_OW 88
// if IsOK ( am5 ) then
10906: LD_INT 4
10908: PPUSH
10909: CALL_OW 302
10913: IFFALSE 10927
// Say ( am5 , D2b-Sci1-2 ) else
10915: LD_INT 4
10917: PPUSH
10918: LD_STRING D2b-Sci1-2
10920: PPUSH
10921: CALL_OW 88
10925: GO 10939
// Say ( Khatam , D2b-Sci1-2 ) ;
10927: LD_EXP 10
10931: PPUSH
10932: LD_STRING D2b-Sci1-2
10934: PPUSH
10935: CALL_OW 88
// Say ( MacMillan , D2b-JMM-3 ) ;
10939: LD_EXP 7
10943: PPUSH
10944: LD_STRING D2b-JMM-3
10946: PPUSH
10947: CALL_OW 88
// interface_hidden := false ;
10951: LD_ADDR_OWVAR 54
10955: PUSH
10956: LD_INT 0
10958: ST_TO_ADDR
// DialogueOff ;
10959: CALL_OW 7
// enable ( 7 ) ;
10963: LD_INT 7
10965: ENABLE_MARKED
// end ;
10966: LD_VAR 0 1
10970: RET
// every 0 0$2 trigger GetEngine ( IsInUnit ( MacMillan ) ) = engine_solar marked 7 do
10971: LD_EXP 7
10975: PPUSH
10976: CALL_OW 310
10980: PPUSH
10981: CALL_OW 262
10985: PUSH
10986: LD_INT 2
10988: EQUAL
10989: IFFALSE 11032
10991: GO 10993
10993: DISABLE
// begin DisableExclamations ;
10994: CALL_OW 474
// Say ( MacMillan , D2c-JMM-1 ) ;
10998: LD_EXP 7
11002: PPUSH
11003: LD_STRING D2c-JMM-1
11005: PPUSH
11006: CALL_OW 88
// if JMMinvehicle then
11010: LD_EXP 19
11014: IFFALSE 11028
// Say ( MacMillan , D2c-JMM-1a ) ;
11016: LD_EXP 7
11020: PPUSH
11021: LD_STRING D2c-JMM-1a
11023: PPUSH
11024: CALL_OW 88
// EnableExclamations ;
11028: CALL_OW 473
// end ;
11032: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Lisa ) ) = engine_solar marked 7 do
11033: LD_EXP 6
11037: PPUSH
11038: CALL_OW 310
11042: PPUSH
11043: CALL_OW 262
11047: PUSH
11048: LD_INT 2
11050: EQUAL
11051: IFFALSE 11225
11053: GO 11055
11055: DISABLE
// begin Wait ( 0 0$2 ) ;
11056: LD_INT 70
11058: PPUSH
11059: CALL_OW 67
// EnableExclamations ;
11063: CALL_OW 473
// async ;
11067: ASYNC
// Say ( Lisa , D2c-Lisa-1 ) ;
11068: LD_EXP 6
11072: PPUSH
11073: LD_STRING D2c-Lisa-1
11075: PPUSH
11076: CALL_OW 88
// sync ;
11080: SYNC
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) - 2 ) ;
11081: LD_EXP 6
11085: PPUSH
11086: LD_EXP 6
11090: PPUSH
11091: CALL_OW 250
11095: PPUSH
11096: LD_EXP 6
11100: PPUSH
11101: CALL_OW 251
11105: PUSH
11106: LD_INT 2
11108: MINUS
11109: PPUSH
11110: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) + 2 , GetY ( Lisa ) + 2 ) ;
11114: LD_EXP 6
11118: PPUSH
11119: LD_EXP 6
11123: PPUSH
11124: CALL_OW 250
11128: PUSH
11129: LD_INT 2
11131: PLUS
11132: PPUSH
11133: LD_EXP 6
11137: PPUSH
11138: CALL_OW 251
11142: PUSH
11143: LD_INT 2
11145: PLUS
11146: PPUSH
11147: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) , GetY ( Lisa ) + 2 ) ;
11151: LD_EXP 6
11155: PPUSH
11156: LD_EXP 6
11160: PPUSH
11161: CALL_OW 250
11165: PPUSH
11166: LD_EXP 6
11170: PPUSH
11171: CALL_OW 251
11175: PUSH
11176: LD_INT 2
11178: PLUS
11179: PPUSH
11180: CALL_OW 171
// AddComMoveXY ( Lisa , GetX ( Lisa ) - 2 , GetY ( Lisa ) - 2 ) ;
11184: LD_EXP 6
11188: PPUSH
11189: LD_EXP 6
11193: PPUSH
11194: CALL_OW 250
11198: PUSH
11199: LD_INT 2
11201: MINUS
11202: PPUSH
11203: LD_EXP 6
11207: PPUSH
11208: CALL_OW 251
11212: PUSH
11213: LD_INT 2
11215: MINUS
11216: PPUSH
11217: CALL_OW 171
// DisableExclamations ;
11221: CALL_OW 474
// end ;
11225: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Cyrus ) ) = engine_solar marked 7 do
11226: LD_EXP 5
11230: PPUSH
11231: CALL_OW 310
11235: PPUSH
11236: CALL_OW 262
11240: PUSH
11241: LD_INT 2
11243: EQUAL
11244: IFFALSE 11287
11246: GO 11248
11248: DISABLE
// begin DisableExclamations ;
11249: CALL_OW 474
// Say ( Cyrus , D2c-Cyrus-1 ) ;
11253: LD_EXP 5
11257: PPUSH
11258: LD_STRING D2c-Cyrus-1
11260: PPUSH
11261: CALL_OW 88
// if Cyrusinvehicle then
11265: LD_EXP 20
11269: IFFALSE 11283
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11271: LD_EXP 5
11275: PPUSH
11276: LD_STRING D2c-Cyrus-1a
11278: PPUSH
11279: CALL_OW 88
// EnableExclamations ;
11283: CALL_OW 473
// end ;
11287: END
// every 0 0$2 trigger GetEngine ( IsInUnit ( Bobby ) ) = engine_solar marked 7 do
11288: LD_EXP 4
11292: PPUSH
11293: CALL_OW 310
11297: PPUSH
11298: CALL_OW 262
11302: PUSH
11303: LD_INT 2
11305: EQUAL
11306: IFFALSE 11331
11308: GO 11310
11310: DISABLE
// begin EnableExclamations ;
11311: CALL_OW 473
// Say ( Bobby , D2c-Bobby-1 ) ;
11315: LD_EXP 4
11319: PPUSH
11320: LD_STRING D2c-Bobby-1
11322: PPUSH
11323: CALL_OW 88
// DisableExclamations ;
11327: CALL_OW 474
// end ;
11331: END
// every 2 2$0 trigger IsInArea ( MacMillan , Am_Base ) marked 2 do var hold_list ;
11332: LD_EXP 7
11336: PPUSH
11337: LD_INT 2
11339: PPUSH
11340: CALL_OW 308
11344: IFFALSE 12200
11346: GO 11348
11348: DISABLE
11349: LD_INT 0
11351: PPUSH
// begin PlaceUnitXY ( Frank , 34 , 65 , false ) ;
11352: LD_EXP 11
11356: PPUSH
11357: LD_INT 34
11359: PPUSH
11360: LD_INT 65
11362: PPUSH
11363: LD_INT 0
11365: PPUSH
11366: CALL_OW 48
// ComMoveXY ( Frank , 50 , 74 ) ;
11370: LD_EXP 11
11374: PPUSH
11375: LD_INT 50
11377: PPUSH
11378: LD_INT 74
11380: PPUSH
11381: CALL_OW 111
// AddComMoveXY ( Frank , 60 , 87 ) ;
11385: LD_EXP 11
11389: PPUSH
11390: LD_INT 60
11392: PPUSH
11393: LD_INT 87
11395: PPUSH
11396: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11400: LD_INT 35
11402: PPUSH
11403: CALL_OW 67
// until not IsBusy ( Frank ) ;
11407: LD_EXP 11
11411: PPUSH
11412: CALL_OW 315
11416: NOT
11417: IFFALSE 11400
// CenterOnUnits ( Frank ) ;
11419: LD_EXP 11
11423: PPUSH
11424: CALL_OW 85
// InGameOn ;
11428: CALL_OW 8
// hold_list := [ Frank ] ;
11432: LD_ADDR_VAR 0 1
11436: PUSH
11437: LD_EXP 11
11441: PUSH
11442: EMPTY
11443: LIST
11444: ST_TO_ADDR
// if IsInArea ( MacMillan , Am_Base ) and not ( GetType ( IsInUnit ( MacMillan ) ) = unit_building ) then
11445: LD_EXP 7
11449: PPUSH
11450: LD_INT 2
11452: PPUSH
11453: CALL_OW 308
11457: PUSH
11458: LD_EXP 7
11462: PPUSH
11463: CALL_OW 310
11467: PPUSH
11468: CALL_OW 247
11472: PUSH
11473: LD_INT 3
11475: EQUAL
11476: NOT
11477: AND
11478: IFFALSE 11511
// begin ComMoveXY ( MacMillan , 62 , 91 ) ;
11480: LD_EXP 7
11484: PPUSH
11485: LD_INT 62
11487: PPUSH
11488: LD_INT 91
11490: PPUSH
11491: CALL_OW 111
// hold_list := hold_list ^ MacMillan ;
11495: LD_ADDR_VAR 0 1
11499: PUSH
11500: LD_VAR 0 1
11504: PUSH
11505: LD_EXP 7
11509: ADD
11510: ST_TO_ADDR
// end ; if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11511: LD_EXP 6
11515: PPUSH
11516: LD_INT 2
11518: PPUSH
11519: CALL_OW 308
11523: PUSH
11524: LD_EXP 6
11528: PPUSH
11529: CALL_OW 310
11533: PPUSH
11534: CALL_OW 247
11538: PUSH
11539: LD_INT 3
11541: EQUAL
11542: NOT
11543: AND
11544: IFFALSE 11577
// begin ComMoveXY ( Lisa , 59 , 90 ) ;
11546: LD_EXP 6
11550: PPUSH
11551: LD_INT 59
11553: PPUSH
11554: LD_INT 90
11556: PPUSH
11557: CALL_OW 111
// hold_list := hold_list ^ Lisa ;
11561: LD_ADDR_VAR 0 1
11565: PUSH
11566: LD_VAR 0 1
11570: PUSH
11571: LD_EXP 6
11575: ADD
11576: ST_TO_ADDR
// end ; if IsInArea ( am1 , Am_Base ) and not ( GetType ( IsInUnit ( am1 ) ) = unit_building ) then
11577: LD_INT 2
11579: PPUSH
11580: LD_INT 2
11582: PPUSH
11583: CALL_OW 308
11587: PUSH
11588: LD_INT 2
11590: PPUSH
11591: CALL_OW 310
11595: PPUSH
11596: CALL_OW 247
11600: PUSH
11601: LD_INT 3
11603: EQUAL
11604: NOT
11605: AND
11606: IFFALSE 11635
// begin ComMoveXY ( am1 , 65 , 91 ) ;
11608: LD_INT 2
11610: PPUSH
11611: LD_INT 65
11613: PPUSH
11614: LD_INT 91
11616: PPUSH
11617: CALL_OW 111
// hold_list := hold_list ^ am1 ;
11621: LD_ADDR_VAR 0 1
11625: PUSH
11626: LD_VAR 0 1
11630: PUSH
11631: LD_INT 2
11633: ADD
11634: ST_TO_ADDR
// end ; Wait ( 0 0$2 ) ;
11635: LD_INT 70
11637: PPUSH
11638: CALL_OW 67
// InGameOff ;
11642: CALL_OW 9
// interface_hidden := true ;
11646: LD_ADDR_OWVAR 54
11650: PUSH
11651: LD_INT 1
11653: ST_TO_ADDR
// DialogueOn ;
11654: CALL_OW 6
// Meet_Frank := true ;
11658: LD_ADDR_EXP 44
11662: PUSH
11663: LD_INT 1
11665: ST_TO_ADDR
// ComHold ( hold_list ) ;
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 140
// AddComTurnUnit ( Frank , MacMillan ) ;
11675: LD_EXP 11
11679: PPUSH
11680: LD_EXP 7
11684: PPUSH
11685: CALL_OW 179
// AddComTurnUnit ( hold_list diff Frank , Frank ) ;
11689: LD_VAR 0 1
11693: PUSH
11694: LD_EXP 11
11698: DIFF
11699: PPUSH
11700: LD_EXP 11
11704: PPUSH
11705: CALL_OW 179
// Say ( MacMillan , D6-JMM-1 ) ;
11709: LD_EXP 7
11713: PPUSH
11714: LD_STRING D6-JMM-1
11716: PPUSH
11717: CALL_OW 88
// Say ( Frank , D6-Frank-1 ) ;
11721: LD_EXP 11
11725: PPUSH
11726: LD_STRING D6-Frank-1
11728: PPUSH
11729: CALL_OW 88
// RevealFogArea ( you , odkryj_mapu ) ;
11733: LD_EXP 1
11737: PPUSH
11738: LD_INT 5
11740: PPUSH
11741: CALL_OW 332
// CenterOnXY ( 33 , 12 ) ;
11745: LD_INT 33
11747: PPUSH
11748: LD_INT 12
11750: PPUSH
11751: CALL_OW 84
// DWait ( 0 0$4 ) ;
11755: LD_INT 140
11757: PPUSH
11758: CALL_OW 68
// CenterOnXY ( 65 , 18 ) ;
11762: LD_INT 65
11764: PPUSH
11765: LD_INT 18
11767: PPUSH
11768: CALL_OW 84
// DWait ( 0 0$3 ) ;
11772: LD_INT 105
11774: PPUSH
11775: CALL_OW 68
// CenterOnUnits ( Frank ) ;
11779: LD_EXP 11
11783: PPUSH
11784: CALL_OW 85
// DWait ( 0 0$4 ) ;
11788: LD_INT 140
11790: PPUSH
11791: CALL_OW 68
// DialogueOff ;
11795: CALL_OW 7
// InGameOn ;
11799: CALL_OW 8
// if IsInArea ( Lisa , Am_Base ) and not ( GetType ( IsInUnit ( Lisa ) ) = unit_building ) then
11803: LD_EXP 6
11807: PPUSH
11808: LD_INT 2
11810: PPUSH
11811: CALL_OW 308
11815: PUSH
11816: LD_EXP 6
11820: PPUSH
11821: CALL_OW 310
11825: PPUSH
11826: CALL_OW 247
11830: PUSH
11831: LD_INT 3
11833: EQUAL
11834: NOT
11835: AND
11836: IFFALSE 11892
// begin ComMoveUnit ( Lisa , Frank ) ;
11838: LD_EXP 6
11842: PPUSH
11843: LD_EXP 11
11847: PPUSH
11848: CALL_OW 112
// Wait ( 40 ) ;
11852: LD_INT 40
11854: PPUSH
11855: CALL_OW 67
// Say ( Lisa , D6-Lisa-1 ) ;
11859: LD_EXP 6
11863: PPUSH
11864: LD_STRING D6-Lisa-1
11866: PPUSH
11867: CALL_OW 88
// Say ( Frank , D6-Frank-2 ) ;
11871: LD_EXP 11
11875: PPUSH
11876: LD_STRING D6-Frank-2
11878: PPUSH
11879: CALL_OW 88
// ComHold ( Lisa ) ;
11883: LD_EXP 6
11887: PPUSH
11888: CALL_OW 140
// end ; InGameOff ;
11892: CALL_OW 9
// DialogueOn ;
11896: CALL_OW 6
// interface_hidden := true ;
11900: LD_ADDR_OWVAR 54
11904: PUSH
11905: LD_INT 1
11907: ST_TO_ADDR
// Say ( am1 , D6-Sol1-2 ) ;
11908: LD_INT 2
11910: PPUSH
11911: LD_STRING D6-Sol1-2
11913: PPUSH
11914: CALL_OW 88
// Say ( MacMillan , D6-JMM-2 ) ;
11918: LD_EXP 7
11922: PPUSH
11923: LD_STRING D6-JMM-2
11925: PPUSH
11926: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
11930: LD_EXP 11
11934: PPUSH
11935: LD_STRING D6-Frank-3
11937: PPUSH
11938: CALL_OW 88
// Say ( MacMillan , D6-JMM-3 ) ;
11942: LD_EXP 7
11946: PPUSH
11947: LD_STRING D6-JMM-3
11949: PPUSH
11950: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
11954: LD_EXP 11
11958: PPUSH
11959: LD_STRING D6-Frank-4
11961: PPUSH
11962: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
11966: LD_EXP 11
11970: PPUSH
11971: LD_STRING D6-Frank-4a
11973: PPUSH
11974: CALL_OW 88
// Say ( MacMillan , D6-JMM-4 ) ;
11978: LD_EXP 7
11982: PPUSH
11983: LD_STRING D6-JMM-4
11985: PPUSH
11986: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
11990: LD_EXP 11
11994: PPUSH
11995: LD_STRING D6-Frank-5
11997: PPUSH
11998: CALL_OW 88
// if IsOK ( Lisa ) then
12002: LD_EXP 6
12006: PPUSH
12007: CALL_OW 302
12011: IFFALSE 12025
// Say ( Lisa , D6-Lisa-5 ) ;
12013: LD_EXP 6
12017: PPUSH
12018: LD_STRING D6-Lisa-5
12020: PPUSH
12021: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
12025: LD_EXP 11
12029: PPUSH
12030: LD_STRING D6-Frank-6
12032: PPUSH
12033: CALL_OW 88
// Say ( MacMillan , D6-JMM-6 ) ;
12037: LD_EXP 7
12041: PPUSH
12042: LD_STRING D6-JMM-6
12044: PPUSH
12045: CALL_OW 88
// Frank_Query := Query ( Q1 ) ;
12049: LD_ADDR_EXP 47
12053: PUSH
12054: LD_STRING Q1
12056: PPUSH
12057: CALL_OW 97
12061: ST_TO_ADDR
// if Frank_Query = 1 then
12062: LD_EXP 47
12066: PUSH
12067: LD_INT 1
12069: EQUAL
12070: IFFALSE 12164
// begin SetSide ( Frank , neutral ) ;
12072: LD_EXP 11
12076: PPUSH
12077: LD_EXP 3
12081: PPUSH
12082: CALL_OW 235
// ComStop ( Lisa ) ;
12086: LD_EXP 6
12090: PPUSH
12091: CALL_OW 141
// ComMoveXY ( Frank , 35 , 68 ) ;
12095: LD_EXP 11
12099: PPUSH
12100: LD_INT 35
12102: PPUSH
12103: LD_INT 68
12105: PPUSH
12106: CALL_OW 111
// Wait ( 0 0$2 ) ;
12110: LD_INT 70
12112: PPUSH
12113: CALL_OW 67
// DialogueOff ;
12117: CALL_OW 7
// interface_hidden := false ;
12121: LD_ADDR_OWVAR 54
12125: PUSH
12126: LD_INT 0
12128: ST_TO_ADDR
// repeat Wait ( 0 0$0.5 ) ;
12129: LD_INT 18
12131: PPUSH
12132: CALL_OW 67
// until IsAt ( Frank , 35 , 68 ) ;
12136: LD_EXP 11
12140: PPUSH
12141: LD_INT 35
12143: PPUSH
12144: LD_INT 68
12146: PPUSH
12147: CALL_OW 307
12151: IFFALSE 12129
// RemoveUnit ( Frank ) ;
12153: LD_EXP 11
12157: PPUSH
12158: CALL_OW 64
// end else
12162: GO 12176
// begin DialogueOff ;
12164: CALL_OW 7
// interface_hidden := false ;
12168: LD_ADDR_OWVAR 54
12172: PUSH
12173: LD_INT 0
12175: ST_TO_ADDR
// end ; ComStop ( hold_list diff Frank ) ;
12176: LD_VAR 0 1
12180: PUSH
12181: LD_EXP 11
12185: DIFF
12186: PPUSH
12187: CALL_OW 141
// ComFree ( hold_list ) ;
12191: LD_VAR 0 1
12195: PPUSH
12196: CALL_OW 139
// end ;
12200: PPOPN 1
12202: END
// every 0 0$5 marked 5 do
12203: GO 12205
12205: DISABLE
// begin wait ( 0 0$10 ) ;
12206: LD_INT 350
12208: PPUSH
12209: CALL_OW 67
// RevealFogArea ( you , odkryj_mapu2 ) ;
12213: LD_EXP 1
12217: PPUSH
12218: LD_INT 8
12220: PPUSH
12221: CALL_OW 332
// SayRadio ( Frank , D3b-Frank-1 ) ;
12225: LD_EXP 11
12229: PPUSH
12230: LD_STRING D3b-Frank-1
12232: PPUSH
12233: CALL_OW 94
// end ;
12237: END
// every 0 0$10 trigger ( TICK > ( time_to_attack - 2 2$30 ) ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) > 5 ) or ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_engine , engine_solar ] ] ) >= FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) ) do
12238: LD_OWVAR 1
12242: PUSH
12243: LD_EXP 41
12247: PUSH
12248: LD_INT 5250
12250: MINUS
12251: GREATER
12252: PUSH
12253: LD_INT 22
12255: PUSH
12256: LD_EXP 1
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 21
12267: PUSH
12268: LD_INT 2
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 32
12277: PUSH
12278: LD_INT 2
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: EMPTY
12286: LIST
12287: LIST
12288: LIST
12289: PPUSH
12290: CALL_OW 69
12294: PUSH
12295: LD_INT 5
12297: GREATER
12298: OR
12299: PUSH
12300: LD_INT 22
12302: PUSH
12303: LD_EXP 1
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 21
12314: PUSH
12315: LD_INT 2
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PUSH
12322: LD_INT 32
12324: PUSH
12325: LD_INT 2
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: EMPTY
12333: LIST
12334: LIST
12335: LIST
12336: PPUSH
12337: CALL_OW 69
12341: PUSH
12342: LD_INT 22
12344: PUSH
12345: LD_EXP 1
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 21
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 50
12366: PUSH
12367: EMPTY
12368: LIST
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: LIST
12374: PPUSH
12375: CALL_OW 69
12379: GREATEREQUAL
12380: OR
12381: IFFALSE 12420
12383: GO 12385
12385: DISABLE
// begin if cornell_lost then
12386: LD_EXP 46
12390: IFFALSE 12394
// exit ;
12392: GO 12420
// time_to_attack := TICK + 2 2$30 ;
12394: LD_ADDR_EXP 41
12398: PUSH
12399: LD_OWVAR 1
12403: PUSH
12404: LD_INT 5250
12406: PLUS
12407: ST_TO_ADDR
// SayRadio ( Cornell , D3-Corn-1 ) ;
12408: LD_EXP 8
12412: PPUSH
12413: LD_STRING D3-Corn-1
12415: PPUSH
12416: CALL_OW 94
// end ;
12420: END
// every 0 0$10 trigger TICK > ( time_to_attack ) do
12421: LD_OWVAR 1
12425: PUSH
12426: LD_EXP 41
12430: GREATER
12431: IFFALSE 12636
12433: GO 12435
12435: DISABLE
// begin if cornell_lost then
12436: LD_EXP 46
12440: IFFALSE 12444
// exit ;
12442: GO 12636
// CenterOnUnits ( MacMillan ) ;
12444: LD_EXP 7
12448: PPUSH
12449: CALL_OW 85
// DisableExclamations ;
12453: CALL_OW 474
// DialogueOn ;
12457: CALL_OW 6
// interface_hidden := true ;
12461: LD_ADDR_OWVAR 54
12465: PUSH
12466: LD_INT 1
12468: ST_TO_ADDR
// SayRadio ( Cornell , D3a-Corn-1 ) ;
12469: LD_EXP 8
12473: PPUSH
12474: LD_STRING D3a-Corn-1
12476: PPUSH
12477: CALL_OW 94
// Say ( MacMillan , D3a-JMM-1 ) ;
12481: LD_EXP 7
12485: PPUSH
12486: LD_STRING D3a-JMM-1
12488: PPUSH
12489: CALL_OW 88
// SayRadio ( Cornell , D3a-Corn-2 ) ;
12493: LD_EXP 8
12497: PPUSH
12498: LD_STRING D3a-Corn-2
12500: PPUSH
12501: CALL_OW 94
// interface_hidden := false ;
12505: LD_ADDR_OWVAR 54
12509: PUSH
12510: LD_INT 0
12512: ST_TO_ADDR
// DialogueOff ;
12513: CALL_OW 7
// EnableExclamations ;
12517: CALL_OW 473
// ChangeMissionObjectives ( MOutWait ) ;
12521: LD_STRING MOutWait
12523: PPUSH
12524: CALL_OW 337
// ChangeMissionObjectives ( M2 ) ;
12528: LD_STRING M2
12530: PPUSH
12531: CALL_OW 337
// SetAreaMapShow ( TopBorder , 1 ) ;
12535: LD_INT 1
12537: PPUSH
12538: LD_INT 1
12540: PPUSH
12541: CALL_OW 424
// if FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] , [ f_nation , nation_american ] ] ) then
12545: LD_INT 22
12547: PUSH
12548: LD_EXP 1
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: PUSH
12557: LD_INT 21
12559: PUSH
12560: LD_INT 2
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: PUSH
12567: LD_INT 23
12569: PUSH
12570: LD_INT 1
12572: PUSH
12573: EMPTY
12574: LIST
12575: LIST
12576: PUSH
12577: EMPTY
12578: LIST
12579: LIST
12580: LIST
12581: PPUSH
12582: CALL_OW 69
12586: IFFALSE 12597
// Hint ( Skills1 ) else
12588: LD_STRING Skills1
12590: PPUSH
12591: CALL_OW 339
12595: GO 12604
// Hint ( Skills2 ) ;
12597: LD_STRING Skills2
12599: PPUSH
12600: CALL_OW 339
// if ( GetSide ( Frank ) = neutral ) then
12604: LD_EXP 11
12608: PPUSH
12609: CALL_OW 255
12613: PUSH
12614: LD_EXP 3
12618: EQUAL
12619: IFFALSE 12624
// enable ( 5 ) ;
12621: LD_INT 5
12623: ENABLE_MARKED
// atack := 1 ;
12624: LD_ADDR_EXP 16
12628: PUSH
12629: LD_INT 1
12631: ST_TO_ADDR
// attack_began ;
12632: CALL 6104 0 0
// end ;
12636: END
// every 0 0$10 trigger TICK > ( time_to_attack + time_to_return - 1 1$0 ) do
12637: LD_OWVAR 1
12641: PUSH
12642: LD_EXP 41
12646: PUSH
12647: LD_EXP 40
12651: PLUS
12652: PUSH
12653: LD_INT 2100
12655: MINUS
12656: GREATER
12657: IFFALSE 12681
12659: GO 12661
12661: DISABLE
// begin if not cornell_lost then
12662: LD_EXP 46
12666: NOT
12667: IFFALSE 12681
// SayRadio ( Cornell , D4-Corn-1 ) ;
12669: LD_EXP 8
12673: PPUSH
12674: LD_STRING D4-Corn-1
12676: PPUSH
12677: CALL_OW 94
// end ;
12681: END
// every 0 0$1 trigger GridY ( MacMillan ) < 10 or TICK > ( time_to_attack + time_to_return ) marked 3 do
12682: LD_EXP 7
12686: PPUSH
12687: CALL 2628 0 1
12691: PUSH
12692: LD_INT 10
12694: LESS
12695: PUSH
12696: LD_OWVAR 1
12700: PUSH
12701: LD_EXP 41
12705: PUSH
12706: LD_EXP 40
12710: PLUS
12711: GREATER
12712: OR
12713: IFFALSE 12762
12715: GO 12717
12717: DISABLE
// begin SayRadio ( Cornell , D5-Corn-1 ) ;
12718: LD_EXP 8
12722: PPUSH
12723: LD_STRING D5-Corn-1
12725: PPUSH
12726: CALL_OW 94
// if TICK < ( 15 15$0 + time_to_return ) then
12730: LD_OWVAR 1
12734: PUSH
12735: LD_INT 31500
12737: PUSH
12738: LD_EXP 40
12742: PLUS
12743: LESS
12744: IFFALSE 12754
// atack := 0 ;
12746: LD_ADDR_EXP 16
12750: PUSH
12751: LD_INT 0
12753: ST_TO_ADDR
// cornell_lost := true ;
12754: LD_ADDR_EXP 46
12758: PUSH
12759: LD_INT 1
12761: ST_TO_ADDR
// end ;
12762: END
// export function talk_about_attack ; begin
12763: LD_INT 0
12765: PPUSH
// DisableExclamations ;
12766: CALL_OW 474
// if IsOK ( patrol1 ) and IsOK ( patrol2 ) then
12770: LD_INT 14
12772: PPUSH
12773: CALL_OW 302
12777: PUSH
12778: LD_INT 15
12780: PPUSH
12781: CALL_OW 302
12785: AND
12786: IFFALSE 12802
// Say ( MacMillan , D8b-JMM-1a ) else
12788: LD_EXP 7
12792: PPUSH
12793: LD_STRING D8b-JMM-1a
12795: PPUSH
12796: CALL_OW 88
12800: GO 12814
// Say ( MacMillan , D8b-JMM-1 ) ;
12802: LD_EXP 7
12806: PPUSH
12807: LD_STRING D8b-JMM-1
12809: PPUSH
12810: CALL_OW 88
// Say ( am1 , D8b-Sol1-1 ) ;
12814: LD_INT 2
12816: PPUSH
12817: LD_STRING D8b-Sol1-1
12819: PPUSH
12820: CALL_OW 88
// if IsOK ( Cyrus ) then
12824: LD_EXP 5
12828: PPUSH
12829: CALL_OW 302
12833: IFFALSE 12847
// Say ( Cyrus , D8b-Cyrus-1 ) ;
12835: LD_EXP 5
12839: PPUSH
12840: LD_STRING D8b-Cyrus-1
12842: PPUSH
12843: CALL_OW 88
// if IsOK ( Bobby ) then
12847: LD_EXP 4
12851: PPUSH
12852: CALL_OW 302
12856: IFFALSE 12870
// Say ( Bobby , D8b-Bobby-1 ) ;
12858: LD_EXP 4
12862: PPUSH
12863: LD_STRING D8b-Bobby-1
12865: PPUSH
12866: CALL_OW 88
// if not ( IsOK ( Cyrus ) or IsOK ( Bobby ) ) then
12870: LD_EXP 5
12874: PPUSH
12875: CALL_OW 302
12879: PUSH
12880: LD_EXP 4
12884: PPUSH
12885: CALL_OW 302
12889: OR
12890: NOT
12891: IFFALSE 12903
// Say ( am2 , D8b-Sol2-1 ) ;
12893: LD_INT 3
12895: PPUSH
12896: LD_STRING D8b-Sol2-1
12898: PPUSH
12899: CALL_OW 88
// Say ( MacMillan , D8b-JMM-2 ) ;
12903: LD_EXP 7
12907: PPUSH
12908: LD_STRING D8b-JMM-2
12910: PPUSH
12911: CALL_OW 88
// if IsOK ( Lisa ) then
12915: LD_EXP 6
12919: PPUSH
12920: CALL_OW 302
12924: IFFALSE 12938
// Say ( Lisa , D8b-Lisa-2 ) ;
12926: LD_EXP 6
12930: PPUSH
12931: LD_STRING D8b-Lisa-2
12933: PPUSH
12934: CALL_OW 88
// EnableExclamations ;
12938: CALL_OW 473
// end ; end_of_file
12942: LD_VAR 0 1
12946: RET
// export ru_trucks , ru_drivers ; var levels , positions ; export s_guard1 , s_guard2 , s_guard3 , s_guard4 , home_11 , home_12 , home_21 , home_22 , home_31 , home_32 , grass_31 , grass_32 , grass_33 ; export function prepare_russian_side ; begin
12947: LD_INT 0
12949: PPUSH
// levels := [ 1 , 3 , 6 ] [ difficulty ] ;
12950: LD_ADDR_LOC 3
12954: PUSH
12955: LD_INT 1
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: LD_INT 6
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: PUSH
12969: LD_OWVAR 67
12973: ARRAY
12974: ST_TO_ADDR
// positions := [ 21 , 14 , 29 , 8 , 49 , 23 , 55 , 13 , 75 , 22 , 93 , 20 , 106 , 20 , 145 , 106 ] ;
12975: LD_ADDR_LOC 4
12979: PUSH
12980: LD_INT 21
12982: PUSH
12983: LD_INT 14
12985: PUSH
12986: LD_INT 29
12988: PUSH
12989: LD_INT 8
12991: PUSH
12992: LD_INT 49
12994: PUSH
12995: LD_INT 23
12997: PUSH
12998: LD_INT 55
13000: PUSH
13001: LD_INT 13
13003: PUSH
13004: LD_INT 75
13006: PUSH
13007: LD_INT 22
13009: PUSH
13010: LD_INT 93
13012: PUSH
13013: LD_INT 20
13015: PUSH
13016: LD_INT 106
13018: PUSH
13019: LD_INT 20
13021: PUSH
13022: LD_INT 145
13024: PUSH
13025: LD_INT 106
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: ST_TO_ADDR
// if difficulty > 1 then
13046: LD_OWVAR 67
13050: PUSH
13051: LD_INT 1
13053: GREATER
13054: IFFALSE 13068
// begin prepare_home1 ;
13056: CALL 13097 0 0
// prepare_home2 ;
13060: CALL 13249 0 0
// prepare_home3 ;
13064: CALL 13401 0 0
// end ; prepare_s_guard ;
13068: CALL 13553 0 0
// prepare_grass3 ;
13072: CALL 13747 0 0
// prepare_drivers ;
13076: CALL 14004 0 0
// prepare_vehicles ;
13080: CALL 14109 0 0
// drivers_into_vehicles ;
13084: CALL 14379 0 0
// place_russian_batery ;
13088: CALL 13916 0 0
// end ;
13092: LD_VAR 0 1
13096: RET
// function prepare_home1 ; var un , sol ; begin
13097: LD_INT 0
13099: PPUSH
13100: PPUSH
13101: PPUSH
// uc_side := russians ;
13102: LD_ADDR_OWVAR 20
13106: PUSH
13107: LD_EXP 2
13111: ST_TO_ADDR
// uc_nation := nation_russian ;
13112: LD_ADDR_OWVAR 21
13116: PUSH
13117: LD_INT 3
13119: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13120: LD_ADDR_VAR 0 2
13124: PUSH
13125: DOUBLE
13126: LD_INT 1
13128: DEC
13129: ST_TO_ADDR
13130: LD_OWVAR 67
13134: PUSH
13135: LD_INT 1
13137: MINUS
13138: PUSH
13139: FOR_TO
13140: IFFALSE 13242
// begin PrepareSoldier ( 0 , levels ) ;
13142: LD_INT 0
13144: PPUSH
13145: LD_LOC 3
13149: PPUSH
13150: CALL_OW 381
// sol := CreateHuman ;
13154: LD_ADDR_VAR 0 3
13158: PUSH
13159: CALL_OW 44
13163: ST_TO_ADDR
// case un of 1 :
13164: LD_VAR 0 2
13168: PUSH
13169: LD_INT 1
13171: DOUBLE
13172: EQUAL
13173: IFTRUE 13177
13175: GO 13190
13177: POP
// home_11 := sol ; 2 :
13178: LD_ADDR_EXP 54
13182: PUSH
13183: LD_VAR 0 3
13187: ST_TO_ADDR
13188: GO 13212
13190: LD_INT 2
13192: DOUBLE
13193: EQUAL
13194: IFTRUE 13198
13196: GO 13211
13198: POP
// home_12 := sol ; end ;
13199: LD_ADDR_EXP 55
13203: PUSH
13204: LD_VAR 0 3
13208: ST_TO_ADDR
13209: GO 13212
13211: POP
// PlaceUnitXYR ( sol , 88 , 23 , 3 , false ) ;
13212: LD_VAR 0 3
13216: PPUSH
13217: LD_INT 88
13219: PPUSH
13220: LD_INT 23
13222: PPUSH
13223: LD_INT 3
13225: PPUSH
13226: LD_INT 0
13228: PPUSH
13229: CALL_OW 50
// wait ( 1 ) ;
13233: LD_INT 1
13235: PPUSH
13236: CALL_OW 67
// end ;
13240: GO 13139
13242: POP
13243: POP
// end ;
13244: LD_VAR 0 1
13248: RET
// function prepare_home2 ; var un , sol ; begin
13249: LD_INT 0
13251: PPUSH
13252: PPUSH
13253: PPUSH
// uc_side := russians ;
13254: LD_ADDR_OWVAR 20
13258: PUSH
13259: LD_EXP 2
13263: ST_TO_ADDR
// uc_nation := nation_russian ;
13264: LD_ADDR_OWVAR 21
13268: PUSH
13269: LD_INT 3
13271: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13272: LD_ADDR_VAR 0 2
13276: PUSH
13277: DOUBLE
13278: LD_INT 1
13280: DEC
13281: ST_TO_ADDR
13282: LD_OWVAR 67
13286: PUSH
13287: LD_INT 1
13289: MINUS
13290: PUSH
13291: FOR_TO
13292: IFFALSE 13394
// begin PrepareSoldier ( 0 , levels ) ;
13294: LD_INT 0
13296: PPUSH
13297: LD_LOC 3
13301: PPUSH
13302: CALL_OW 381
// sol := CreateHuman ;
13306: LD_ADDR_VAR 0 3
13310: PUSH
13311: CALL_OW 44
13315: ST_TO_ADDR
// case un of 1 :
13316: LD_VAR 0 2
13320: PUSH
13321: LD_INT 1
13323: DOUBLE
13324: EQUAL
13325: IFTRUE 13329
13327: GO 13342
13329: POP
// home_21 := sol ; 2 :
13330: LD_ADDR_EXP 56
13334: PUSH
13335: LD_VAR 0 3
13339: ST_TO_ADDR
13340: GO 13364
13342: LD_INT 2
13344: DOUBLE
13345: EQUAL
13346: IFTRUE 13350
13348: GO 13363
13350: POP
// home_22 := sol ; end ;
13351: LD_ADDR_EXP 57
13355: PUSH
13356: LD_VAR 0 3
13360: ST_TO_ADDR
13361: GO 13364
13363: POP
// PlaceUnitXYR ( sol , 69 , 19 , 3 , false ) ;
13364: LD_VAR 0 3
13368: PPUSH
13369: LD_INT 69
13371: PPUSH
13372: LD_INT 19
13374: PPUSH
13375: LD_INT 3
13377: PPUSH
13378: LD_INT 0
13380: PPUSH
13381: CALL_OW 50
// wait ( 1 ) ;
13385: LD_INT 1
13387: PPUSH
13388: CALL_OW 67
// end ;
13392: GO 13291
13394: POP
13395: POP
// end ;
13396: LD_VAR 0 1
13400: RET
// function prepare_home3 ; var un , sol ; begin
13401: LD_INT 0
13403: PPUSH
13404: PPUSH
13405: PPUSH
// uc_side := russians ;
13406: LD_ADDR_OWVAR 20
13410: PUSH
13411: LD_EXP 2
13415: ST_TO_ADDR
// uc_nation := nation_russian ;
13416: LD_ADDR_OWVAR 21
13420: PUSH
13421: LD_INT 3
13423: ST_TO_ADDR
// for un = 1 to ( difficulty - 1 ) do
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: DOUBLE
13430: LD_INT 1
13432: DEC
13433: ST_TO_ADDR
13434: LD_OWVAR 67
13438: PUSH
13439: LD_INT 1
13441: MINUS
13442: PUSH
13443: FOR_TO
13444: IFFALSE 13546
// begin PrepareSoldier ( 0 , levels ) ;
13446: LD_INT 0
13448: PPUSH
13449: LD_LOC 3
13453: PPUSH
13454: CALL_OW 381
// sol := CreateHuman ;
13458: LD_ADDR_VAR 0 3
13462: PUSH
13463: CALL_OW 44
13467: ST_TO_ADDR
// case un of 1 :
13468: LD_VAR 0 2
13472: PUSH
13473: LD_INT 1
13475: DOUBLE
13476: EQUAL
13477: IFTRUE 13481
13479: GO 13494
13481: POP
// home_31 := sol ; 2 :
13482: LD_ADDR_EXP 58
13486: PUSH
13487: LD_VAR 0 3
13491: ST_TO_ADDR
13492: GO 13516
13494: LD_INT 2
13496: DOUBLE
13497: EQUAL
13498: IFTRUE 13502
13500: GO 13515
13502: POP
// home_32 := sol ; end ;
13503: LD_ADDR_EXP 59
13507: PUSH
13508: LD_VAR 0 3
13512: ST_TO_ADDR
13513: GO 13516
13515: POP
// PlaceUnitXYR ( sol , 17 , 10 , 3 , false ) ;
13516: LD_VAR 0 3
13520: PPUSH
13521: LD_INT 17
13523: PPUSH
13524: LD_INT 10
13526: PPUSH
13527: LD_INT 3
13529: PPUSH
13530: LD_INT 0
13532: PPUSH
13533: CALL_OW 50
// wait ( 1 ) ;
13537: LD_INT 1
13539: PPUSH
13540: CALL_OW 67
// end ;
13544: GO 13443
13546: POP
13547: POP
// end ;
13548: LD_VAR 0 1
13552: RET
// function prepare_s_guard ; var un , sol ; begin
13553: LD_INT 0
13555: PPUSH
13556: PPUSH
13557: PPUSH
// uc_side := russians ;
13558: LD_ADDR_OWVAR 20
13562: PUSH
13563: LD_EXP 2
13567: ST_TO_ADDR
// uc_nation := nation_russian ;
13568: LD_ADDR_OWVAR 21
13572: PUSH
13573: LD_INT 3
13575: ST_TO_ADDR
// for un = 1 to ( difficulty + 1 ) do
13576: LD_ADDR_VAR 0 2
13580: PUSH
13581: DOUBLE
13582: LD_INT 1
13584: DEC
13585: ST_TO_ADDR
13586: LD_OWVAR 67
13590: PUSH
13591: LD_INT 1
13593: PLUS
13594: PUSH
13595: FOR_TO
13596: IFFALSE 13740
// begin PrepareSoldier ( 0 , levels ) ;
13598: LD_INT 0
13600: PPUSH
13601: LD_LOC 3
13605: PPUSH
13606: CALL_OW 381
// sol := CreateHuman ;
13610: LD_ADDR_VAR 0 3
13614: PUSH
13615: CALL_OW 44
13619: ST_TO_ADDR
// case un of 1 :
13620: LD_VAR 0 2
13624: PUSH
13625: LD_INT 1
13627: DOUBLE
13628: EQUAL
13629: IFTRUE 13633
13631: GO 13646
13633: POP
// s_guard1 := sol ; 2 :
13634: LD_ADDR_EXP 50
13638: PUSH
13639: LD_VAR 0 3
13643: ST_TO_ADDR
13644: GO 13710
13646: LD_INT 2
13648: DOUBLE
13649: EQUAL
13650: IFTRUE 13654
13652: GO 13667
13654: POP
// s_guard2 := sol ; 3 :
13655: LD_ADDR_EXP 51
13659: PUSH
13660: LD_VAR 0 3
13664: ST_TO_ADDR
13665: GO 13710
13667: LD_INT 3
13669: DOUBLE
13670: EQUAL
13671: IFTRUE 13675
13673: GO 13688
13675: POP
// s_guard3 := sol ; 4 :
13676: LD_ADDR_EXP 52
13680: PUSH
13681: LD_VAR 0 3
13685: ST_TO_ADDR
13686: GO 13710
13688: LD_INT 4
13690: DOUBLE
13691: EQUAL
13692: IFTRUE 13696
13694: GO 13709
13696: POP
// s_guard4 := sol ; end ;
13697: LD_ADDR_EXP 53
13701: PUSH
13702: LD_VAR 0 3
13706: ST_TO_ADDR
13707: GO 13710
13709: POP
// PlaceUnitXYR ( sol , 118 , 105 , 3 , false ) ;
13710: LD_VAR 0 3
13714: PPUSH
13715: LD_INT 118
13717: PPUSH
13718: LD_INT 105
13720: PPUSH
13721: LD_INT 3
13723: PPUSH
13724: LD_INT 0
13726: PPUSH
13727: CALL_OW 50
// wait ( 1 ) ;
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 67
// end ;
13738: GO 13595
13740: POP
13741: POP
// end ;
13742: LD_VAR 0 1
13746: RET
// function prepare_grass3 ; var un , sol ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
13751: PPUSH
// uc_side := russians ;
13752: LD_ADDR_OWVAR 20
13756: PUSH
13757: LD_EXP 2
13761: ST_TO_ADDR
// uc_nation := nation_russian ;
13762: LD_ADDR_OWVAR 21
13766: PUSH
13767: LD_INT 3
13769: ST_TO_ADDR
// for un = 1 to difficulty do
13770: LD_ADDR_VAR 0 2
13774: PUSH
13775: DOUBLE
13776: LD_INT 1
13778: DEC
13779: ST_TO_ADDR
13780: LD_OWVAR 67
13784: PUSH
13785: FOR_TO
13786: IFFALSE 13909
// begin PrepareSoldier ( 0 , levels ) ;
13788: LD_INT 0
13790: PPUSH
13791: LD_LOC 3
13795: PPUSH
13796: CALL_OW 381
// sol := CreateHuman ;
13800: LD_ADDR_VAR 0 3
13804: PUSH
13805: CALL_OW 44
13809: ST_TO_ADDR
// case un of 1 :
13810: LD_VAR 0 2
13814: PUSH
13815: LD_INT 1
13817: DOUBLE
13818: EQUAL
13819: IFTRUE 13823
13821: GO 13836
13823: POP
// grass_31 := sol ; 2 :
13824: LD_ADDR_EXP 60
13828: PUSH
13829: LD_VAR 0 3
13833: ST_TO_ADDR
13834: GO 13879
13836: LD_INT 2
13838: DOUBLE
13839: EQUAL
13840: IFTRUE 13844
13842: GO 13857
13844: POP
// grass_32 := sol ; 3 :
13845: LD_ADDR_EXP 61
13849: PUSH
13850: LD_VAR 0 3
13854: ST_TO_ADDR
13855: GO 13879
13857: LD_INT 3
13859: DOUBLE
13860: EQUAL
13861: IFTRUE 13865
13863: GO 13878
13865: POP
// grass_33 := sol ; end ;
13866: LD_ADDR_EXP 62
13870: PUSH
13871: LD_VAR 0 3
13875: ST_TO_ADDR
13876: GO 13879
13878: POP
// PlaceUnitXYR ( sol , 73 , 38 , 3 , false ) ;
13879: LD_VAR 0 3
13883: PPUSH
13884: LD_INT 73
13886: PPUSH
13887: LD_INT 38
13889: PPUSH
13890: LD_INT 3
13892: PPUSH
13893: LD_INT 0
13895: PPUSH
13896: CALL_OW 50
// wait ( 1 ) ;
13900: LD_INT 1
13902: PPUSH
13903: CALL_OW 67
// end ;
13907: GO 13785
13909: POP
13910: POP
// end ;
13911: LD_VAR 0 1
13915: RET
// function place_russian_batery ; var i ; begin
13916: LD_INT 0
13918: PPUSH
13919: PPUSH
// for i = 1 to 8 do
13920: LD_ADDR_VAR 0 2
13924: PUSH
13925: DOUBLE
13926: LD_INT 1
13928: DEC
13929: ST_TO_ADDR
13930: LD_INT 8
13932: PUSH
13933: FOR_TO
13934: IFFALSE 13997
// begin PlaceUnitXY ( ru_trucks [ i ] , positions [ ( i * 2 ) - 1 ] , positions [ ( i * 2 ) ] , false ) ;
13936: LD_EXP 48
13940: PUSH
13941: LD_VAR 0 2
13945: ARRAY
13946: PPUSH
13947: LD_LOC 4
13951: PUSH
13952: LD_VAR 0 2
13956: PUSH
13957: LD_INT 2
13959: MUL
13960: PUSH
13961: LD_INT 1
13963: MINUS
13964: ARRAY
13965: PPUSH
13966: LD_LOC 4
13970: PUSH
13971: LD_VAR 0 2
13975: PUSH
13976: LD_INT 2
13978: MUL
13979: ARRAY
13980: PPUSH
13981: LD_INT 0
13983: PPUSH
13984: CALL_OW 48
// wait ( 1 ) ;
13988: LD_INT 1
13990: PPUSH
13991: CALL_OW 67
// end ;
13995: GO 13933
13997: POP
13998: POP
// end ;
13999: LD_VAR 0 1
14003: RET
// function prepare_drivers ; var i ; begin
14004: LD_INT 0
14006: PPUSH
14007: PPUSH
// ru_drivers := [ ] ;
14008: LD_ADDR_EXP 49
14012: PUSH
14013: EMPTY
14014: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
14015: LD_ADDR_OWVAR 24
14019: PUSH
14020: LD_INT 0
14022: PPUSH
14023: LD_INT 5
14025: PPUSH
14026: CALL_OW 12
14030: ST_TO_ADDR
// uc_nation = nation_russian ;
14031: LD_ADDR_OWVAR 21
14035: PUSH
14036: LD_INT 3
14038: ST_TO_ADDR
// uc_side = russians ;
14039: LD_ADDR_OWVAR 20
14043: PUSH
14044: LD_EXP 2
14048: ST_TO_ADDR
// for i = 1 to 8 do
14049: LD_ADDR_VAR 0 2
14053: PUSH
14054: DOUBLE
14055: LD_INT 1
14057: DEC
14058: ST_TO_ADDR
14059: LD_INT 8
14061: PUSH
14062: FOR_TO
14063: IFFALSE 14102
// begin PrepareMechanic ( 0 , levels ) ;
14065: LD_INT 0
14067: PPUSH
14068: LD_LOC 3
14072: PPUSH
14073: CALL_OW 383
// ru_drivers := ru_drivers ^ CreateHuman ;
14077: LD_ADDR_EXP 49
14081: PUSH
14082: LD_EXP 49
14086: PUSH
14087: CALL_OW 44
14091: ADD
14092: ST_TO_ADDR
// wait ( 1 ) ;
14093: LD_INT 1
14095: PPUSH
14096: CALL_OW 67
// end ;
14100: GO 14062
14102: POP
14103: POP
// end ;
14104: LD_VAR 0 1
14108: RET
// function prepare_vehicles ; var i , weapon ; begin
14109: LD_INT 0
14111: PPUSH
14112: PPUSH
14113: PPUSH
// ru_trucks := [ ] ;
14114: LD_ADDR_EXP 48
14118: PUSH
14119: EMPTY
14120: ST_TO_ADDR
// weapon := [ 1 , 0 , 0 ] ;
14121: LD_ADDR_VAR 0 3
14125: PUSH
14126: LD_INT 1
14128: PUSH
14129: LD_INT 0
14131: PUSH
14132: LD_INT 0
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: LIST
14139: ST_TO_ADDR
// uc_nation = nation_russian ;
14140: LD_ADDR_OWVAR 21
14144: PUSH
14145: LD_INT 3
14147: ST_TO_ADDR
// uc_side = russians ;
14148: LD_ADDR_OWVAR 20
14152: PUSH
14153: LD_EXP 2
14157: ST_TO_ADDR
// for i = 1 to 8 do
14158: LD_ADDR_VAR 0 2
14162: PUSH
14163: DOUBLE
14164: LD_INT 1
14166: DEC
14167: ST_TO_ADDR
14168: LD_INT 8
14170: PUSH
14171: FOR_TO
14172: IFFALSE 14372
// begin uc_direction = rand ( 0 , 5 ) ;
14174: LD_ADDR_OWVAR 24
14178: PUSH
14179: LD_INT 0
14181: PPUSH
14182: LD_INT 5
14184: PPUSH
14185: CALL_OW 12
14189: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
14190: LD_ADDR_OWVAR 37
14194: PUSH
14195: LD_INT 21
14197: ST_TO_ADDR
// vc_engine := engine_combustion ;
14198: LD_ADDR_OWVAR 39
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// vc_control := control_manual ;
14206: LD_ADDR_OWVAR 38
14210: PUSH
14211: LD_INT 1
14213: ST_TO_ADDR
// case ( i mod difficulty ) + 1 of 1 :
14214: LD_VAR 0 2
14218: PUSH
14219: LD_OWVAR 67
14223: MOD
14224: PUSH
14225: LD_INT 1
14227: PLUS
14228: PUSH
14229: LD_INT 1
14231: DOUBLE
14232: EQUAL
14233: IFTRUE 14237
14235: GO 14268
14237: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 3 ) + 1 ] ; 2 :
14238: LD_ADDR_OWVAR 40
14242: PUSH
14243: LD_INT 42
14245: PUSH
14246: LD_VAR 0 3
14250: PUSH
14251: LD_VAR 0 2
14255: PUSH
14256: LD_INT 3
14258: MOD
14259: PUSH
14260: LD_INT 1
14262: PLUS
14263: ARRAY
14264: PLUS
14265: ST_TO_ADDR
14266: GO 14347
14268: LD_INT 2
14270: DOUBLE
14271: EQUAL
14272: IFTRUE 14276
14274: GO 14307
14276: POP
// vc_weapon := ru_heavy_machine_gun + weapon [ ( i mod 2 ) + 1 ] ; 3 :
14277: LD_ADDR_OWVAR 40
14281: PUSH
14282: LD_INT 42
14284: PUSH
14285: LD_VAR 0 3
14289: PUSH
14290: LD_VAR 0 2
14294: PUSH
14295: LD_INT 2
14297: MOD
14298: PUSH
14299: LD_INT 1
14301: PLUS
14302: ARRAY
14303: PLUS
14304: ST_TO_ADDR
14305: GO 14347
14307: LD_INT 3
14309: DOUBLE
14310: EQUAL
14311: IFTRUE 14315
14313: GO 14346
14315: POP
// vc_weapon := ru_gatling_gun - weapon [ ( i mod 3 ) + 1 ] ; end ;
14316: LD_ADDR_OWVAR 40
14320: PUSH
14321: LD_INT 43
14323: PUSH
14324: LD_VAR 0 3
14328: PUSH
14329: LD_VAR 0 2
14333: PUSH
14334: LD_INT 3
14336: MOD
14337: PUSH
14338: LD_INT 1
14340: PLUS
14341: ARRAY
14342: MINUS
14343: ST_TO_ADDR
14344: GO 14347
14346: POP
// ru_trucks := ru_trucks ^ CreateVehicle ;
14347: LD_ADDR_EXP 48
14351: PUSH
14352: LD_EXP 48
14356: PUSH
14357: CALL_OW 45
14361: ADD
14362: ST_TO_ADDR
// wait ( 1 ) ;
14363: LD_INT 1
14365: PPUSH
14366: CALL_OW 67
// end ;
14370: GO 14171
14372: POP
14373: POP
// end ;
14374: LD_VAR 0 1
14378: RET
// function drivers_into_vehicles ; var i ; begin
14379: LD_INT 0
14381: PPUSH
14382: PPUSH
// for i = 1 to 8 do
14383: LD_ADDR_VAR 0 2
14387: PUSH
14388: DOUBLE
14389: LD_INT 1
14391: DEC
14392: ST_TO_ADDR
14393: LD_INT 8
14395: PUSH
14396: FOR_TO
14397: IFFALSE 14434
// begin PlaceHumanInUnit ( ru_drivers [ i ] , ru_trucks [ i ] ) ;
14399: LD_EXP 49
14403: PUSH
14404: LD_VAR 0 2
14408: ARRAY
14409: PPUSH
14410: LD_EXP 48
14414: PUSH
14415: LD_VAR 0 2
14419: ARRAY
14420: PPUSH
14421: CALL_OW 52
// wait ( 1 ) ;
14425: LD_INT 1
14427: PPUSH
14428: CALL_OW 67
// end ;
14432: GO 14396
14434: POP
14435: POP
// end ; end_of_file
14436: LD_VAR 0 1
14440: RET
// on VehicleCaptured ( v_new , v_old , o_side , hum ) do begin ru_trucks := ru_trucks diff v_old ;
14441: LD_ADDR_EXP 48
14445: PUSH
14446: LD_EXP 48
14450: PUSH
14451: LD_VAR 0 2
14455: DIFF
14456: ST_TO_ADDR
// end ; end_of_file
14457: PPOPN 4
14459: END
// var remove_bunkers , remove_soldiers , remove_drivers , remove_vehicles ; export function fix_difficulty ; begin
14460: LD_INT 0
14462: PPUSH
// remove_bunkers := [ [ bunker2 , bunker3 , bunker5 , bunker6 ] , [ bunker2 , bunker5 ] ] ;
14463: LD_ADDR_LOC 5
14467: PUSH
14468: LD_INT 27
14470: PUSH
14471: LD_INT 34
14473: PUSH
14474: LD_INT 32
14476: PUSH
14477: LD_INT 31
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: PUSH
14486: LD_INT 27
14488: PUSH
14489: LD_INT 32
14491: PUSH
14492: EMPTY
14493: LIST
14494: LIST
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: ST_TO_ADDR
// remove_soldiers := [ [ guard2 , guard3 , guard5 , guard6 ] , [ guard2 , guard5 ] ] ;
14500: LD_ADDR_LOC 6
14504: PUSH
14505: LD_INT 29
14507: PUSH
14508: LD_INT 48
14510: PUSH
14511: LD_INT 49
14513: PUSH
14514: LD_INT 20
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: PUSH
14523: LD_INT 29
14525: PUSH
14526: LD_INT 49
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: ST_TO_ADDR
// remove_drivers := [ [ ru_drivers [ 1 ] , ru_drivers [ 3 ] , ru_drivers [ 5 ] , ru_drivers [ 7 ] , ] , [ ru_drivers [ 2 ] , ru_drivers [ 4 ] , ru_drivers [ 6 ] ] ] ;
14537: LD_ADDR_LOC 7
14541: PUSH
14542: LD_EXP 49
14546: PUSH
14547: LD_INT 1
14549: ARRAY
14550: PUSH
14551: LD_EXP 49
14555: PUSH
14556: LD_INT 3
14558: ARRAY
14559: PUSH
14560: LD_EXP 49
14564: PUSH
14565: LD_INT 5
14567: ARRAY
14568: PUSH
14569: LD_EXP 49
14573: PUSH
14574: LD_INT 7
14576: ARRAY
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: PUSH
14584: LD_EXP 49
14588: PUSH
14589: LD_INT 2
14591: ARRAY
14592: PUSH
14593: LD_EXP 49
14597: PUSH
14598: LD_INT 4
14600: ARRAY
14601: PUSH
14602: LD_EXP 49
14606: PUSH
14607: LD_INT 6
14609: ARRAY
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: LIST
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: ST_TO_ADDR
// remove_vehicles := [ [ ru_trucks [ 1 ] , ru_trucks [ 3 ] , ru_trucks [ 5 ] , ru_trucks [ 7 ] , ] , [ ru_trucks [ 2 ] , ru_trucks [ 4 ] , ru_trucks [ 6 ] ] ] ;
14620: LD_ADDR_LOC 8
14624: PUSH
14625: LD_EXP 48
14629: PUSH
14630: LD_INT 1
14632: ARRAY
14633: PUSH
14634: LD_EXP 48
14638: PUSH
14639: LD_INT 3
14641: ARRAY
14642: PUSH
14643: LD_EXP 48
14647: PUSH
14648: LD_INT 5
14650: ARRAY
14651: PUSH
14652: LD_EXP 48
14656: PUSH
14657: LD_INT 7
14659: ARRAY
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: PUSH
14667: LD_EXP 48
14671: PUSH
14672: LD_INT 2
14674: ARRAY
14675: PUSH
14676: LD_EXP 48
14680: PUSH
14681: LD_INT 4
14683: ARRAY
14684: PUSH
14685: LD_EXP 48
14689: PUSH
14690: LD_INT 6
14692: ARRAY
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: ST_TO_ADDR
// if difficulty < 3 then
14703: LD_OWVAR 67
14707: PUSH
14708: LD_INT 3
14710: LESS
14711: IFFALSE 14773
// begin fce_remove_units ( remove_soldiers [ difficulty ] ) ;
14713: LD_LOC 6
14717: PUSH
14718: LD_OWVAR 67
14722: ARRAY
14723: PPUSH
14724: CALL 14778 0 1
// fce_remove_units ( remove_bunkers [ difficulty ] ) ;
14728: LD_LOC 5
14732: PUSH
14733: LD_OWVAR 67
14737: ARRAY
14738: PPUSH
14739: CALL 14778 0 1
// fce_remove_units ( remove_drivers [ difficulty ] ) ;
14743: LD_LOC 7
14747: PUSH
14748: LD_OWVAR 67
14752: ARRAY
14753: PPUSH
14754: CALL 14778 0 1
// fce_remove_units ( remove_vehicles [ difficulty ] ) ;
14758: LD_LOC 8
14762: PUSH
14763: LD_OWVAR 67
14767: ARRAY
14768: PPUSH
14769: CALL 14778 0 1
// end ; end ;
14773: LD_VAR 0 1
14777: RET
// function fce_remove_units ( list ) ; var un ; begin
14778: LD_INT 0
14780: PPUSH
14781: PPUSH
// for un in list do
14782: LD_ADDR_VAR 0 3
14786: PUSH
14787: LD_VAR 0 1
14791: PUSH
14792: FOR_IN
14793: IFFALSE 14806
// RemoveUnit ( un ) ;
14795: LD_VAR 0 3
14799: PPUSH
14800: CALL_OW 64
14804: GO 14792
14806: POP
14807: POP
// end ; end_of_file
14808: LD_VAR 0 2
14812: RET
// var h_workshop , h_lab ; export function init_hints ; begin
14813: LD_INT 0
14815: PPUSH
// h_workshop := true ;
14816: LD_ADDR_LOC 9
14820: PUSH
14821: LD_INT 1
14823: ST_TO_ADDR
// h_lab := true ;
14824: LD_ADDR_LOC 10
14828: PUSH
14829: LD_INT 1
14831: ST_TO_ADDR
// end ;
14832: LD_VAR 0 1
14836: RET
// on BuildingComplete ( un ) do begin if ( GetBType ( un ) = b_workshop ) and ( h_workshop ) then
14837: LD_VAR 0 1
14841: PPUSH
14842: CALL_OW 266
14846: PUSH
14847: LD_INT 2
14849: EQUAL
14850: PUSH
14851: LD_LOC 9
14855: AND
14856: IFFALSE 14907
// begin h_workshop := false ;
14858: LD_ADDR_LOC 9
14862: PUSH
14863: LD_INT 0
14865: ST_TO_ADDR
// if GetTech ( tech_SolEng , you ) = state_researched then
14866: LD_INT 45
14868: PPUSH
14869: LD_EXP 1
14873: PPUSH
14874: CALL_OW 321
14878: PUSH
14879: LD_INT 2
14881: EQUAL
14882: IFFALSE 14900
// begin Hint ( Workshop2 ) ;
14884: LD_STRING Workshop2
14886: PPUSH
14887: CALL_OW 339
// Hint ( BuildingVehicles ) ;
14891: LD_STRING BuildingVehicles
14893: PPUSH
14894: CALL_OW 339
// end else
14898: GO 14907
// Hint ( Workshop1 ) ;
14900: LD_STRING Workshop1
14902: PPUSH
14903: CALL_OW 339
// end ; if ( GetBType ( un ) = b_lab ) and ( h_lab ) then
14907: LD_VAR 0 1
14911: PPUSH
14912: CALL_OW 266
14916: PUSH
14917: LD_INT 6
14919: EQUAL
14920: PUSH
14921: LD_LOC 10
14925: AND
14926: IFFALSE 14943
// begin h_lab := false ;
14928: LD_ADDR_LOC 10
14932: PUSH
14933: LD_INT 0
14935: ST_TO_ADDR
// Hint ( Laboratory ) ;
14936: LD_STRING Laboratory
14938: PPUSH
14939: CALL_OW 339
// end ; end ;
14943: PPOPN 1
14945: END
// on Contact ( side1 , side2 ) marked 11 do begin Hint ( Shift ) ;
14946: LD_STRING Shift
14948: PPUSH
14949: CALL_OW 339
// disable ( 11 ) ;
14953: LD_INT 11
14955: DISABLE_MARKED
// end ; end_of_file
14956: PPOPN 2
14958: END
// export function SA_Rambo ; begin
14959: LD_INT 0
14961: PPUSH
// SetAchievement ( ACH_RAM ) ;
14962: LD_STRING ACH_RAM
14964: PPUSH
14965: CALL_OW 543
// end ;
14969: LD_VAR 0 1
14973: RET
// export function SA_MotDiv ; begin
14974: LD_INT 0
14976: PPUSH
// SetAchievement ( ACH_DIV ) ;
14977: LD_STRING ACH_DIV
14979: PPUSH
14980: CALL_OW 543
// end ;
14984: LD_VAR 0 1
14988: RET
// export function SA_OneStepAhead ; begin
14989: LD_INT 0
14991: PPUSH
// SetAchievement ( ACH_OSA ) ;
14992: LD_STRING ACH_OSA
14994: PPUSH
14995: CALL_OW 543
// end ;
14999: LD_VAR 0 1
15003: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
15004: LD_INT 22
15006: PUSH
15007: LD_INT 3
15009: PUSH
15010: EMPTY
15011: LIST
15012: LIST
15013: PUSH
15014: LD_INT 30
15016: PUSH
15017: LD_INT 1
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PUSH
15033: LD_INT 0
15035: EQUAL
15036: IFFALSE 15045
15038: GO 15040
15040: DISABLE
// SA_Rambo ;
15041: CALL 14959 0 0
15045: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_nation , nation_american ] ] ) >= 6 do
15046: LD_INT 22
15048: PUSH
15049: LD_INT 1
15051: PUSH
15052: EMPTY
15053: LIST
15054: LIST
15055: PUSH
15056: LD_INT 21
15058: PUSH
15059: LD_INT 2
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: PUSH
15066: LD_INT 23
15068: PUSH
15069: LD_INT 1
15071: PUSH
15072: EMPTY
15073: LIST
15074: LIST
15075: PUSH
15076: EMPTY
15077: LIST
15078: LIST
15079: LIST
15080: PPUSH
15081: CALL_OW 69
15085: PUSH
15086: LD_INT 6
15088: GREATEREQUAL
15089: IFFALSE 15098
15091: GO 15093
15093: DISABLE
// SA_MotDiv ; end_of_file
15094: CALL 14974 0 0
15098: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
15099: LD_INT 0
15101: PPUSH
15102: PPUSH
// if not missionNumber then
15103: LD_VAR 0 2
15107: NOT
15108: IFFALSE 15112
// exit ;
15110: GO 15242
// achiv := false ;
15112: LD_ADDR_VAR 0 7
15116: PUSH
15117: LD_INT 0
15119: ST_TO_ADDR
// case campaignNumber of 1 :
15120: LD_VAR 0 1
15124: PUSH
15125: LD_INT 1
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15144
15133: POP
// achiv := ACH_GOTA ; 2 :
15134: LD_ADDR_VAR 0 7
15138: PUSH
15139: LD_STRING ACH_GOTA
15141: ST_TO_ADDR
15142: GO 15194
15144: LD_INT 2
15146: DOUBLE
15147: EQUAL
15148: IFTRUE 15152
15150: GO 15155
15152: POP
// ; 3 :
15153: GO 15194
15155: LD_INT 3
15157: DOUBLE
15158: EQUAL
15159: IFTRUE 15163
15161: GO 15174
15163: POP
// achiv := ACH_MOTSU ; 4 :
15164: LD_ADDR_VAR 0 7
15168: PUSH
15169: LD_STRING ACH_MOTSU
15171: ST_TO_ADDR
15172: GO 15194
15174: LD_INT 4
15176: DOUBLE
15177: EQUAL
15178: IFTRUE 15182
15180: GO 15193
15182: POP
// achiv := ACH_LOP ; end ;
15183: LD_ADDR_VAR 0 7
15187: PUSH
15188: LD_STRING ACH_LOP
15190: ST_TO_ADDR
15191: GO 15194
15193: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
15194: LD_OWVAR 67
15198: PUSH
15199: LD_INT 3
15201: EQUAL
15202: PUSH
15203: LD_VAR 0 7
15207: AND
15208: PUSH
15209: LD_VAR 0 3
15213: AND
15214: PUSH
15215: LD_VAR 0 4
15219: AND
15220: PUSH
15221: LD_VAR 0 5
15225: AND
15226: IFFALSE 15242
// SetAchievementEX ( achiv , missionNumber ) ;
15228: LD_VAR 0 7
15232: PPUSH
15233: LD_VAR 0 2
15237: PPUSH
15238: CALL_OW 564
// end ;
15242: LD_VAR 0 6
15246: RET
// export function SA_BehemothConstructed ; begin
15247: LD_INT 0
15249: PPUSH
// SetAchievement ( ACH_SMC ) ;
15250: LD_STRING ACH_SMC
15252: PPUSH
15253: CALL_OW 543
// end ;
15257: LD_VAR 0 1
15261: RET

// export rpat1 , phase , patience ; var d1R , d1Ra , d1Rb , d1Rc , run_d1Rb , run_d1Rc ; export function hunters_to_position ; begin
   0: LD_INT 0
   2: PPUSH
// d1R := 0 ;
   3: LD_ADDR_LOC 1
   7: PUSH
   8: LD_INT 0
  10: ST_TO_ADDR
// d1Ra := 0 ;
  11: LD_ADDR_LOC 2
  15: PUSH
  16: LD_INT 0
  18: ST_TO_ADDR
// d1Rb := 0 ;
  19: LD_ADDR_LOC 3
  23: PUSH
  24: LD_INT 0
  26: ST_TO_ADDR
// d1Rc := 0 ;
  27: LD_ADDR_LOC 4
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// ComEnterUnit ( rmech1 , rveh1 ) ;
  35: LD_INT 17
  37: PPUSH
  38: LD_INT 16
  40: PPUSH
  41: CALL_OW 120
// wait ( 0 0$2 ) ;
  45: LD_INT 70
  47: PPUSH
  48: CALL_OW 67
// phase := 1 ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_INT 1
  59: ST_TO_ADDR
// rpat1 := [ rpat1_1 , rpat1_2 , rpat1_3 ] ;
  60: LD_ADDR_EXP 1
  64: PUSH
  65: LD_INT 22
  67: PUSH
  68: LD_INT 19
  70: PUSH
  71: LD_INT 21
  73: PUSH
  74: EMPTY
  75: LIST
  76: LIST
  77: LIST
  78: ST_TO_ADDR
// ComFree ( rpat1 ^ [ rpat2 , rpat3 , rveh1 , rmech1 ] ) ;
  79: LD_EXP 1
  83: PUSH
  84: LD_INT 24
  86: PUSH
  87: LD_INT 25
  89: PUSH
  90: LD_INT 16
  92: PUSH
  93: LD_INT 17
  95: PUSH
  96: EMPTY
  97: LIST
  98: LIST
  99: LIST
 100: LIST
 101: ADD
 102: PPUSH
 103: CALL_OW 139
// AddComAgressiveMove ( rveh1 , 73 , 61 ) ;
 107: LD_INT 16
 109: PPUSH
 110: LD_INT 73
 112: PPUSH
 113: LD_INT 61
 115: PPUSH
 116: CALL_OW 174
// AddComExitVehicle ( rveh1 ) ;
 120: LD_INT 16
 122: PPUSH
 123: CALL_OW 181
// AddComAgressiveMove ( rveh1 , 74 , 63 ) ;
 127: LD_INT 16
 129: PPUSH
 130: LD_INT 74
 132: PPUSH
 133: LD_INT 63
 135: PPUSH
 136: CALL_OW 174
// AddComAgressiveMove ( rpat1 , 92 , 74 ) ;
 140: LD_EXP 1
 144: PPUSH
 145: LD_INT 92
 147: PPUSH
 148: LD_INT 74
 150: PPUSH
 151: CALL_OW 174
// AddComAgressiveMove ( rpat2 , 70 , 63 ) ;
 155: LD_INT 24
 157: PPUSH
 158: LD_INT 70
 160: PPUSH
 161: LD_INT 63
 163: PPUSH
 164: CALL_OW 174
// AddComWait ( rpat3 , 0 0$2 ) ;
 168: LD_INT 25
 170: PPUSH
 171: LD_INT 70
 173: PPUSH
 174: CALL_OW 202
// AddComAgressiveMove ( rpat3 , 67 , 64 ) ;
 178: LD_INT 25
 180: PPUSH
 181: LD_INT 67
 183: PPUSH
 184: LD_INT 64
 186: PPUSH
 187: CALL_OW 174
// end ;
 191: LD_VAR 0 1
 195: RET
// every 0 0$0.5 trigger ( FilterAllUnits ( [ [ f_side , russians ] , [ f_see , you ] ] ) >= 2 ) and IsInArea ( JMM , starthill ) and IsInArea ( JMM , starthill ) do
 196: LD_INT 22
 198: PUSH
 199: LD_EXP 5
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: PUSH
 208: LD_INT 101
 210: PUSH
 211: LD_EXP 6
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: PPUSH
 224: CALL_OW 69
 228: PUSH
 229: LD_INT 2
 231: GREATEREQUAL
 232: PUSH
 233: LD_EXP 8
 237: PPUSH
 238: LD_INT 11
 240: PPUSH
 241: CALL_OW 308
 245: AND
 246: PUSH
 247: LD_EXP 8
 251: PPUSH
 252: LD_INT 11
 254: PPUSH
 255: CALL_OW 308
 259: AND
 260: IFFALSE 310
 262: GO 264
 264: DISABLE
// begin if not FilterAllUnits ( [ [ f_side , you ] , [ f_see , russians ] ] ) then
 265: LD_INT 22
 267: PUSH
 268: LD_EXP 6
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: PUSH
 277: LD_INT 101
 279: PUSH
 280: LD_EXP 5
 284: PUSH
 285: EMPTY
 286: LIST
 287: LIST
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: PPUSH
 293: CALL_OW 69
 297: NOT
 298: IFFALSE 309
// begin Hint ( Visibility2 ) ;
 300: LD_STRING Visibility2
 302: PPUSH
 303: CALL_OW 339
// end else
 307: GO 310
// enable ;
 309: ENABLE
// end ;
 310: END
// every 0 0$0.5 trigger IsAt ( rpat3 , 67 , 64 ) marked 1 do var deltime ;
 311: LD_INT 25
 313: PPUSH
 314: LD_INT 67
 316: PPUSH
 317: LD_INT 64
 319: PPUSH
 320: CALL_OW 307
 324: IFFALSE 451
 326: GO 328
 328: DISABLE
 329: LD_INT 0
 331: PPUSH
// begin if d1R then
 332: LD_LOC 1
 336: IFFALSE 340
// exit ;
 338: GO 451
// deltime := hunt_waiting1 [ difficulty ] ;
 340: LD_ADDR_VAR 0 1
 344: PUSH
 345: LD_EXP 19
 349: PUSH
 350: LD_OWVAR 67
 354: ARRAY
 355: ST_TO_ADDR
// ComWait ( rpat3 , deltime + 0 0$0 ) ;
 356: LD_INT 25
 358: PPUSH
 359: LD_VAR 0 1
 363: PUSH
 364: LD_INT 0
 366: PLUS
 367: PPUSH
 368: CALL_OW 142
// AddComMoveXY ( rpat3 , 79 , 81 ) ;
 372: LD_INT 25
 374: PPUSH
 375: LD_INT 79
 377: PPUSH
 378: LD_INT 81
 380: PPUSH
 381: CALL_OW 171
// ComWait ( rpat2 , deltime + 0 0$2 ) ;
 385: LD_INT 24
 387: PPUSH
 388: LD_VAR 0 1
 392: PUSH
 393: LD_INT 70
 395: PLUS
 396: PPUSH
 397: CALL_OW 142
// AddComMoveXY ( rpat2 , 81 , 80 ) ;
 401: LD_INT 24
 403: PPUSH
 404: LD_INT 81
 406: PPUSH
 407: LD_INT 80
 409: PPUSH
 410: CALL_OW 171
// ComWait ( rpat1 , deltime + 0 0$3.5 ) ;
 414: LD_EXP 1
 418: PPUSH
 419: LD_VAR 0 1
 423: PUSH
 424: LD_INT 122
 426: PLUS
 427: PPUSH
 428: CALL_OW 142
// AddComMoveXY ( rpat1 , 83 , 82 ) ;
 432: LD_EXP 1
 436: PPUSH
 437: LD_INT 83
 439: PPUSH
 440: LD_INT 82
 442: PPUSH
 443: CALL_OW 171
// dialogue_d1R ;
 447: CALL 836 0 0
// end ;
 451: PPOPN 1
 453: END
// function pursue_JMM ; var i ; begin
 454: LD_INT 0
 456: PPUSH
 457: PPUSH
// if not IsInUnit ( rmech1 ) then
 458: LD_INT 17
 460: PPUSH
 461: CALL_OW 310
 465: NOT
 466: IFFALSE 478
// ComEnterUnit ( rmech1 , rveh1 ) ;
 468: LD_INT 17
 470: PPUSH
 471: LD_INT 16
 473: PPUSH
 474: CALL_OW 120
// if phase = 1 then
 478: LD_EXP 2
 482: PUSH
 483: LD_INT 1
 485: EQUAL
 486: IFFALSE 496
// phase := 2 ;
 488: LD_ADDR_EXP 2
 492: PUSH
 493: LD_INT 2
 495: ST_TO_ADDR
// AddComAttackUnit ( rmech1 , JMM ) ;
 496: LD_INT 17
 498: PPUSH
 499: LD_EXP 8
 503: PPUSH
 504: CALL_OW 175
// ComAttackUnit ( rpat1 ^ [ rpat2 , rpat3 ] , JMM ) ;
 508: LD_EXP 1
 512: PUSH
 513: LD_INT 24
 515: PUSH
 516: LD_INT 25
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: ADD
 523: PPUSH
 524: LD_EXP 8
 528: PPUSH
 529: CALL_OW 115
// run_d1Rb := true ;
 533: LD_ADDR_LOC 5
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// for i := 1 to hunting_cycles [ difficulty ] do
 541: LD_ADDR_VAR 0 2
 545: PUSH
 546: DOUBLE
 547: LD_INT 1
 549: DEC
 550: ST_TO_ADDR
 551: LD_EXP 18
 555: PUSH
 556: LD_OWVAR 67
 560: ARRAY
 561: PUSH
 562: FOR_TO
 563: IFFALSE 619
// begin if not See ( russians , JMM ) then
 565: LD_EXP 5
 569: PPUSH
 570: LD_EXP 8
 574: PPUSH
 575: CALL_OW 292
 579: NOT
 580: IFFALSE 610
// begin wait ( 0 0$2 ) ;
 582: LD_INT 70
 584: PPUSH
 585: CALL_OW 67
// if not See ( russians , JMM ) then
 589: LD_EXP 5
 593: PPUSH
 594: LD_EXP 8
 598: PPUSH
 599: CALL_OW 292
 603: NOT
 604: IFFALSE 608
// break ;
 606: GO 619
// end else
 608: GO 617
// wait ( 0 0$2 ) ;
 610: LD_INT 70
 612: PPUSH
 613: CALL_OW 67
// end ;
 617: GO 562
 619: POP
 620: POP
// ComStop ( rpat1 ^ [ rpat2 , rpat3 , rveh1 ] ) ;
 621: LD_EXP 1
 625: PUSH
 626: LD_INT 24
 628: PUSH
 629: LD_INT 25
 631: PUSH
 632: LD_INT 16
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: ADD
 640: PPUSH
 641: CALL_OW 141
// ComWait ( rpat1 ^ [ rpat2 , rpat3 , rveh1 ] , 0 0$5 ) ;
 645: LD_EXP 1
 649: PUSH
 650: LD_INT 24
 652: PUSH
 653: LD_INT 25
 655: PUSH
 656: LD_INT 16
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: ADD
 664: PPUSH
 665: LD_INT 175
 667: PPUSH
 668: CALL_OW 142
// case phase of 2 :
 672: LD_EXP 2
 676: PUSH
 677: LD_INT 2
 679: DOUBLE
 680: EQUAL
 681: IFTRUE 685
 683: GO 727
 685: POP
// begin AddComMoveXY ( rpat1 ^ [ rpat2 , rpat3 ] , 82 , 81 ) ;
 686: LD_EXP 1
 690: PUSH
 691: LD_INT 24
 693: PUSH
 694: LD_INT 25
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: ADD
 701: PPUSH
 702: LD_INT 82
 704: PPUSH
 705: LD_INT 81
 707: PPUSH
 708: CALL_OW 171
// AddComMoveXY ( rveh1 , 73 , 61 ) ;
 712: LD_INT 16
 714: PPUSH
 715: LD_INT 73
 717: PPUSH
 718: LD_INT 61
 720: PPUSH
 721: CALL_OW 171
// end ; 3 :
 725: GO 787
 727: LD_INT 3
 729: DOUBLE
 730: EQUAL
 731: IFTRUE 735
 733: GO 786
 735: POP
// begin AddComMoveXY ( rpat1 , 138 , 90 ) ;
 736: LD_EXP 1
 740: PPUSH
 741: LD_INT 138
 743: PPUSH
 744: LD_INT 90
 746: PPUSH
 747: CALL_OW 171
// AddComMoveXY ( [ rpat2 , rpat3 ] , 23 , 14 ) ;
 751: LD_INT 24
 753: PUSH
 754: LD_INT 25
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: PPUSH
 761: LD_INT 23
 763: PPUSH
 764: LD_INT 14
 766: PPUSH
 767: CALL_OW 171
// ComAgressiveMove ( rveh1 , 130 , 87 ) ;
 771: LD_INT 16
 773: PPUSH
 774: LD_INT 130
 776: PPUSH
 777: LD_INT 87
 779: PPUSH
 780: CALL_OW 114
// end ; end ;
 784: GO 787
 786: POP
// if not See ( russians , JMM ) and IsOk ( JMM ) then
 787: LD_EXP 5
 791: PPUSH
 792: LD_EXP 8
 796: PPUSH
 797: CALL_OW 292
 801: NOT
 802: PUSH
 803: LD_EXP 8
 807: PPUSH
 808: CALL_OW 302
 812: AND
 813: IFFALSE 823
// run_d1Rc := true ;
 815: LD_ADDR_LOC 6
 819: PUSH
 820: LD_INT 1
 822: ST_TO_ADDR
// wait ( 0 0$5.5 ) ;
 823: LD_INT 192
 825: PPUSH
 826: CALL_OW 67
// enable ;
 830: ENABLE
// end ;
 831: LD_VAR 0 1
 835: RET
// function dialogue_d1R ; begin
 836: LD_INT 0
 838: PPUSH
// d1R := true ;
 839: LD_ADDR_LOC 1
 843: PUSH
 844: LD_INT 1
 846: ST_TO_ADDR
// if not See ( russians , JMM ) then
 847: LD_EXP 5
 851: PPUSH
 852: LD_EXP 8
 856: PPUSH
 857: CALL_OW 292
 861: NOT
 862: IFFALSE 901
// begin Say ( rpat3 , D1R-Rus1-1 ) ;
 864: LD_INT 25
 866: PPUSH
 867: LD_STRING D1R-Rus1-1
 869: PPUSH
 870: CALL_OW 88
// if not See ( russians , JMM ) then
 874: LD_EXP 5
 878: PPUSH
 879: LD_EXP 8
 883: PPUSH
 884: CALL_OW 292
 888: NOT
 889: IFFALSE 901
// Say ( rpat2 , D1R-Rus2-1 ) ;
 891: LD_INT 24
 893: PPUSH
 894: LD_STRING D1R-Rus2-1
 896: PPUSH
 897: CALL_OW 88
// end ; end ;
 901: LD_VAR 0 1
 905: RET
// function dialogue_d1Ra ; begin
 906: LD_INT 0
 908: PPUSH
// d1Ra := true ;
 909: LD_ADDR_LOC 2
 913: PUSH
 914: LD_INT 1
 916: ST_TO_ADDR
// d1Rc := d1Rc + 1 ;
 917: LD_ADDR_LOC 4
 921: PUSH
 922: LD_LOC 4
 926: PUSH
 927: LD_INT 1
 929: PLUS
 930: ST_TO_ADDR
// phase := 2 ;
 931: LD_ADDR_EXP 2
 935: PUSH
 936: LD_INT 2
 938: ST_TO_ADDR
// if not See ( russians , JMM ) then
 939: LD_EXP 5
 943: PPUSH
 944: LD_EXP 8
 948: PPUSH
 949: CALL_OW 292
 953: NOT
 954: IFFALSE 993
// begin Say ( rpat3 , D1Ra-Rus1-1 ) ;
 956: LD_INT 25
 958: PPUSH
 959: LD_STRING D1Ra-Rus1-1
 961: PPUSH
 962: CALL_OW 88
// if not See ( russians , JMM ) then
 966: LD_EXP 5
 970: PPUSH
 971: LD_EXP 8
 975: PPUSH
 976: CALL_OW 292
 980: NOT
 981: IFFALSE 993
// Say ( rpat2 , D1Ra-Rus2-1 ) ;
 983: LD_INT 24
 985: PPUSH
 986: LD_STRING D1Ra-Rus2-1
 988: PPUSH
 989: CALL_OW 88
// end ; end ;
 993: LD_VAR 0 1
 997: RET
// function dialogue_d1Rb ( var count ) ; var ok1 , ok2 , k ; begin
 998: LD_INT 0
1000: PPUSH
1001: PPUSH
1002: PPUSH
1003: PPUSH
// if count >= 3 then
1004: LD_FROM_VAR 0 1
1008: PUSH
1009: LD_INT 3
1011: GREATEREQUAL
1012: IFFALSE 1016
// exit ;
1014: GO 1276
// ok1 := IsOk ( rpat2 ) and IsOk ( rpat3 ) ;
1016: LD_ADDR_VAR 0 3
1020: PUSH
1021: LD_INT 24
1023: PPUSH
1024: CALL_OW 302
1028: PUSH
1029: LD_INT 25
1031: PPUSH
1032: CALL_OW 302
1036: AND
1037: ST_TO_ADDR
// ok2 := IsOk ( rpat1_1 ) and IsOk ( rpat1_2 ) ;
1038: LD_ADDR_VAR 0 4
1042: PUSH
1043: LD_INT 22
1045: PPUSH
1046: CALL_OW 302
1050: PUSH
1051: LD_INT 19
1053: PPUSH
1054: CALL_OW 302
1058: AND
1059: ST_TO_ADDR
// if ok1 and ok2 then
1060: LD_VAR 0 3
1064: PUSH
1065: LD_VAR 0 4
1069: AND
1070: IFFALSE 1120
// if GetDistUnits ( JMM , rpat2 ) <= GetDistUnits ( JMM , rpat1_1 ) then
1072: LD_EXP 8
1076: PPUSH
1077: LD_INT 24
1079: PPUSH
1080: CALL_OW 296
1084: PUSH
1085: LD_EXP 8
1089: PPUSH
1090: LD_INT 22
1092: PPUSH
1093: CALL_OW 296
1097: LESSEQUAL
1098: IFFALSE 1110
// k := 1 else
1100: LD_ADDR_VAR 0 5
1104: PUSH
1105: LD_INT 1
1107: ST_TO_ADDR
1108: GO 1118
// k := 2 else
1110: LD_ADDR_VAR 0 5
1114: PUSH
1115: LD_INT 2
1117: ST_TO_ADDR
1118: GO 1160
// if ok1 then
1120: LD_VAR 0 3
1124: IFFALSE 1136
// k := 1 else
1126: LD_ADDR_VAR 0 5
1130: PUSH
1131: LD_INT 1
1133: ST_TO_ADDR
1134: GO 1160
// if ok2 then
1136: LD_VAR 0 4
1140: IFFALSE 1152
// k := 2 else
1142: LD_ADDR_VAR 0 5
1146: PUSH
1147: LD_INT 2
1149: ST_TO_ADDR
1150: GO 1160
// k := 0 ;
1152: LD_ADDR_VAR 0 5
1156: PUSH
1157: LD_INT 0
1159: ST_TO_ADDR
// if k = 1 then
1160: LD_VAR 0 5
1164: PUSH
1165: LD_INT 1
1167: EQUAL
1168: IFFALSE 1212
// begin if count <> 2 then
1170: LD_FROM_VAR 0 1
1174: PUSH
1175: LD_INT 2
1177: NONEQUAL
1178: IFFALSE 1190
// Say ( rpat3 , D1Rb-Rus1-1 ) ;
1180: LD_INT 25
1182: PPUSH
1183: LD_STRING D1Rb-Rus1-1
1185: PPUSH
1186: CALL_OW 88
// if count <> 1 then
1190: LD_FROM_VAR 0 1
1194: PUSH
1195: LD_INT 1
1197: NONEQUAL
1198: IFFALSE 1210
// Say ( rpat2 , D1Rb-Rus2-1 ) ;
1200: LD_INT 24
1202: PPUSH
1203: LD_STRING D1Rb-Rus2-1
1205: PPUSH
1206: CALL_OW 88
// end else
1210: GO 1262
// if k = 2 then
1212: LD_VAR 0 5
1216: PUSH
1217: LD_INT 2
1219: EQUAL
1220: IFFALSE 1262
// begin if count <> 2 then
1222: LD_FROM_VAR 0 1
1226: PUSH
1227: LD_INT 2
1229: NONEQUAL
1230: IFFALSE 1242
// Say ( rpat1_1 , D1Rb-Rus1-1 ) ;
1232: LD_INT 22
1234: PPUSH
1235: LD_STRING D1Rb-Rus1-1
1237: PPUSH
1238: CALL_OW 88
// if count <> 1 then
1242: LD_FROM_VAR 0 1
1246: PUSH
1247: LD_INT 1
1249: NONEQUAL
1250: IFFALSE 1262
// Say ( rpat1_2 , D1Rb-Rus2-1 ) ;
1252: LD_INT 19
1254: PPUSH
1255: LD_STRING D1Rb-Rus2-1
1257: PPUSH
1258: CALL_OW 88
// end ; count := count + 1 ;
1262: LD_VAR 0 1
1266: PUSH
1267: LD_FROM_VAR 0 1
1271: PUSH
1272: LD_INT 1
1274: PLUS
1275: ST_TO_ADDR
// end ;
1276: LD_VAR 0 2
1280: RET
// function dialogue_d1Rc ( var count ) ; var ok1 , ok2 , k ; begin
1281: LD_INT 0
1283: PPUSH
1284: PPUSH
1285: PPUSH
1286: PPUSH
// if count >= 2 then
1287: LD_FROM_VAR 0 1
1291: PUSH
1292: LD_INT 2
1294: GREATEREQUAL
1295: IFFALSE 1299
// exit ;
1297: GO 1539
// ok1 := IsOk ( rpat2 ) and IsOk ( rpat3 ) ;
1299: LD_ADDR_VAR 0 3
1303: PUSH
1304: LD_INT 24
1306: PPUSH
1307: CALL_OW 302
1311: PUSH
1312: LD_INT 25
1314: PPUSH
1315: CALL_OW 302
1319: AND
1320: ST_TO_ADDR
// ok2 := IsOk ( rpat1_1 ) and IsOk ( rpat1_2 ) ;
1321: LD_ADDR_VAR 0 4
1325: PUSH
1326: LD_INT 22
1328: PPUSH
1329: CALL_OW 302
1333: PUSH
1334: LD_INT 19
1336: PPUSH
1337: CALL_OW 302
1341: AND
1342: ST_TO_ADDR
// if ok1 and ok2 then
1343: LD_VAR 0 3
1347: PUSH
1348: LD_VAR 0 4
1352: AND
1353: IFFALSE 1403
// if GetDistUnits ( JMM , rpat2 ) <= GetDistUnits ( JMM , rpat1_1 ) then
1355: LD_EXP 8
1359: PPUSH
1360: LD_INT 24
1362: PPUSH
1363: CALL_OW 296
1367: PUSH
1368: LD_EXP 8
1372: PPUSH
1373: LD_INT 22
1375: PPUSH
1376: CALL_OW 296
1380: LESSEQUAL
1381: IFFALSE 1393
// k := 1 else
1383: LD_ADDR_VAR 0 5
1387: PUSH
1388: LD_INT 1
1390: ST_TO_ADDR
1391: GO 1401
// k := 2 else
1393: LD_ADDR_VAR 0 5
1397: PUSH
1398: LD_INT 2
1400: ST_TO_ADDR
1401: GO 1443
// if ok1 then
1403: LD_VAR 0 3
1407: IFFALSE 1419
// k := 1 else
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_INT 1
1416: ST_TO_ADDR
1417: GO 1443
// if ok2 then
1419: LD_VAR 0 4
1423: IFFALSE 1435
// k := 2 else
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_INT 2
1432: ST_TO_ADDR
1433: GO 1443
// k := 0 ;
1435: LD_ADDR_VAR 0 5
1439: PUSH
1440: LD_INT 0
1442: ST_TO_ADDR
// if k = 1 then
1443: LD_VAR 0 5
1447: PUSH
1448: LD_INT 1
1450: EQUAL
1451: IFFALSE 1485
// begin Say ( rpat3 , D1Rc-Rus1-1 ) ;
1453: LD_INT 25
1455: PPUSH
1456: LD_STRING D1Rc-Rus1-1
1458: PPUSH
1459: CALL_OW 88
// if count <> 1 then
1463: LD_FROM_VAR 0 1
1467: PUSH
1468: LD_INT 1
1470: NONEQUAL
1471: IFFALSE 1483
// Say ( rpat2 , D1Rc-Rus2-1 ) ;
1473: LD_INT 24
1475: PPUSH
1476: LD_STRING D1Rc-Rus2-1
1478: PPUSH
1479: CALL_OW 88
// end else
1483: GO 1525
// if k = 2 then
1485: LD_VAR 0 5
1489: PUSH
1490: LD_INT 2
1492: EQUAL
1493: IFFALSE 1525
// begin Say ( rpat1_1 , D1Rc-Rus1-1 ) ;
1495: LD_INT 22
1497: PPUSH
1498: LD_STRING D1Rc-Rus1-1
1500: PPUSH
1501: CALL_OW 88
// if count <> 1 then
1505: LD_FROM_VAR 0 1
1509: PUSH
1510: LD_INT 1
1512: NONEQUAL
1513: IFFALSE 1525
// Say ( rpat1_2 , D1Rc-Rus2-1 ) ;
1515: LD_INT 19
1517: PPUSH
1518: LD_STRING D1Rc-Rus2-1
1520: PPUSH
1521: CALL_OW 88
// end ; count := count + 1 ;
1525: LD_VAR 0 1
1529: PUSH
1530: LD_FROM_VAR 0 1
1534: PUSH
1535: LD_INT 1
1537: PLUS
1538: ST_TO_ADDR
// end ;
1539: LD_VAR 0 2
1543: RET
// every 0 0$1 trigger See ( russians , JMM ) and ( wait ( 0 0$0.9 ) or true ) and See ( russians , JMM ) marked 2 do
1544: LD_EXP 5
1548: PPUSH
1549: LD_EXP 8
1553: PPUSH
1554: CALL_OW 292
1558: PUSH
1559: LD_INT 32
1561: PPUSH
1562: CALL_OW 67
1566: PUSH
1567: LD_INT 1
1569: OR
1570: AND
1571: PUSH
1572: LD_EXP 5
1576: PPUSH
1577: LD_EXP 8
1581: PPUSH
1582: CALL_OW 292
1586: AND
1587: IFFALSE 1623
1589: GO 1591
1591: DISABLE
// begin d1R := true ;
1592: LD_ADDR_LOC 1
1596: PUSH
1597: LD_INT 1
1599: ST_TO_ADDR
// d1Ra := true ;
1600: LD_ADDR_LOC 2
1604: PUSH
1605: LD_INT 1
1607: ST_TO_ADDR
// patience := 0 ;
1608: LD_ADDR_EXP 3
1612: PUSH
1613: LD_INT 0
1615: ST_TO_ADDR
// disable ( 1 ) ;
1616: LD_INT 1
1618: DISABLE_MARKED
// pursue_JMM ;
1619: CALL 454 0 0
// end ;
1623: END
// every 0 0$0.5 trigger IsAt ( rpat3 , 79 , 81 ) marked 1 do
1624: LD_INT 25
1626: PPUSH
1627: LD_INT 79
1629: PPUSH
1630: LD_INT 81
1632: PPUSH
1633: CALL_OW 307
1637: IFFALSE 1646
1639: GO 1641
1641: DISABLE
// begin dialogue_d1Ra ;
1642: CALL 906 0 0
// end ;
1646: END
// every 0 0$0.5 trigger run_d1Rb do
1647: LD_LOC 5
1651: IFFALSE 1674
1653: GO 1655
1655: DISABLE
// begin dialogue_d1Rb ( d1Rb ) ;
1656: LD_ADDR_LOC 3
1660: PPUSH
1661: CALL 998 0 1
// enable ;
1665: ENABLE
// run_d1Rb := false ;
1666: LD_ADDR_LOC 5
1670: PUSH
1671: LD_INT 0
1673: ST_TO_ADDR
// end ;
1674: END
// every 0 0$0.5 trigger run_d1Rc do
1675: LD_LOC 6
1679: IFFALSE 1702
1681: GO 1683
1683: DISABLE
// begin dialogue_d1Rc ( d1Rc ) ;
1684: LD_ADDR_LOC 4
1688: PPUSH
1689: CALL 1281 0 1
// enable ;
1693: ENABLE
// run_d1Rc := false ;
1694: LD_ADDR_LOC 6
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// end ;
1702: END
// every 0 0$1 trigger ( phase = 2 ) do
1703: LD_EXP 2
1707: PUSH
1708: LD_INT 2
1710: EQUAL
1711: IFFALSE 1814
1713: GO 1715
1715: DISABLE
// begin patience := patience + 1 ;
1716: LD_ADDR_EXP 3
1720: PUSH
1721: LD_EXP 3
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: ST_TO_ADDR
// if patience = hunt_patience [ difficulty ] then
1730: LD_EXP 3
1734: PUSH
1735: LD_EXP 20
1739: PUSH
1740: LD_OWVAR 67
1744: ARRAY
1745: EQUAL
1746: IFFALSE 1813
// begin phase := 3 ;
1748: LD_ADDR_EXP 2
1752: PUSH
1753: LD_INT 3
1755: ST_TO_ADDR
// ComMoveXY ( rpat1 , 130 , 87 ) ;
1756: LD_EXP 1
1760: PPUSH
1761: LD_INT 130
1763: PPUSH
1764: LD_INT 87
1766: PPUSH
1767: CALL_OW 111
// ComMoveXY ( [ rpat2 , rpat3 ] , 23 , 14 ) ;
1771: LD_INT 24
1773: PUSH
1774: LD_INT 25
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PPUSH
1781: LD_INT 23
1783: PPUSH
1784: LD_INT 14
1786: PPUSH
1787: CALL_OW 111
// if not IsInUnit ( rmech1 ) then
1791: LD_INT 17
1793: PPUSH
1794: CALL_OW 310
1798: NOT
1799: IFFALSE 1811
// ComEnterUnit ( rmech1 , rveh1 ) ;
1801: LD_INT 17
1803: PPUSH
1804: LD_INT 16
1806: PPUSH
1807: CALL_OW 120
// end else
1811: GO 1814
// enable ;
1813: ENABLE
// end ;
1814: END
// every 0 0$1 trigger ( phase = 3 ) and IsDrivenBy ( rveh1 ) do var expired , oldx , oldy , oldl , newx , newy , newl , i ;
1815: LD_EXP 2
1819: PUSH
1820: LD_INT 3
1822: EQUAL
1823: PUSH
1824: LD_INT 16
1826: PPUSH
1827: CALL_OW 311
1831: AND
1832: IFFALSE 2620
1834: GO 1836
1836: DISABLE
1837: LD_INT 0
1839: PPUSH
1840: PPUSH
1841: PPUSH
1842: PPUSH
1843: PPUSH
1844: PPUSH
1845: PPUSH
1846: PPUSH
// begin repeat AddComAgressiveMove ( rveh1 , 126 , 86 ) ;
1847: LD_INT 16
1849: PPUSH
1850: LD_INT 126
1852: PPUSH
1853: LD_INT 86
1855: PPUSH
1856: CALL_OW 174
// expired := 0 ;
1860: LD_ADDR_VAR 0 1
1864: PUSH
1865: LD_INT 0
1867: ST_TO_ADDR
// oldx := - 1 ;
1868: LD_ADDR_VAR 0 2
1872: PUSH
1873: LD_INT 1
1875: NEG
1876: ST_TO_ADDR
// oldy := - 1 ;
1877: LD_ADDR_VAR 0 3
1881: PUSH
1882: LD_INT 1
1884: NEG
1885: ST_TO_ADDR
// while not IsAt ( rveh1 , 126 , 86 ) and ( expired < 25 ) do
1886: LD_INT 16
1888: PPUSH
1889: LD_INT 126
1891: PPUSH
1892: LD_INT 86
1894: PPUSH
1895: CALL_OW 307
1899: NOT
1900: PUSH
1901: LD_VAR 0 1
1905: PUSH
1906: LD_INT 25
1908: LESS
1909: AND
1910: IFFALSE 2050
// begin wait ( 0 0$1 ) ;
1912: LD_INT 35
1914: PPUSH
1915: CALL_OW 67
// newx := GetX ( rveh1 ) ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_INT 16
1926: PPUSH
1927: CALL_OW 250
1931: ST_TO_ADDR
// newy := GetY ( rveh1 ) ;
1932: LD_ADDR_VAR 0 6
1936: PUSH
1937: LD_INT 16
1939: PPUSH
1940: CALL_OW 251
1944: ST_TO_ADDR
// newl := GetLives ( rveh1 ) ;
1945: LD_ADDR_VAR 0 7
1949: PUSH
1950: LD_INT 16
1952: PPUSH
1953: CALL_OW 256
1957: ST_TO_ADDR
// if ( oldx = newx ) and ( oldy = newy ) and ( oldl = newl ) then
1958: LD_VAR 0 2
1962: PUSH
1963: LD_VAR 0 5
1967: EQUAL
1968: PUSH
1969: LD_VAR 0 3
1973: PUSH
1974: LD_VAR 0 6
1978: EQUAL
1979: AND
1980: PUSH
1981: LD_VAR 0 4
1985: PUSH
1986: LD_VAR 0 7
1990: EQUAL
1991: AND
1992: IFFALSE 2010
// expired := expired + 1 else
1994: LD_ADDR_VAR 0 1
1998: PUSH
1999: LD_VAR 0 1
2003: PUSH
2004: LD_INT 1
2006: PLUS
2007: ST_TO_ADDR
2008: GO 2018
// expired := 0 ;
2010: LD_ADDR_VAR 0 1
2014: PUSH
2015: LD_INT 0
2017: ST_TO_ADDR
// oldx := newx ;
2018: LD_ADDR_VAR 0 2
2022: PUSH
2023: LD_VAR 0 5
2027: ST_TO_ADDR
// oldy := newy ;
2028: LD_ADDR_VAR 0 3
2032: PUSH
2033: LD_VAR 0 6
2037: ST_TO_ADDR
// oldl := newl ;
2038: LD_ADDR_VAR 0 4
2042: PUSH
2043: LD_VAR 0 7
2047: ST_TO_ADDR
// end ;
2048: GO 1886
// if GetLives ( rveh1 ) < 900 then
2050: LD_INT 16
2052: PPUSH
2053: CALL_OW 256
2057: PUSH
2058: LD_INT 900
2060: LESS
2061: IFFALSE 2120
// begin ComMoveXY ( rveh1 , 136 , 88 ) ;
2063: LD_INT 16
2065: PPUSH
2066: LD_INT 136
2068: PPUSH
2069: LD_INT 88
2071: PPUSH
2072: CALL_OW 111
// AddComExitVehicle ( rveh1 ) ;
2076: LD_INT 16
2078: PPUSH
2079: CALL_OW 181
// repeat wait ( 0 0$0.5 ) ;
2083: LD_INT 18
2085: PPUSH
2086: CALL_OW 67
// until not IsDrivenBy ( rveh1 ) ;
2090: LD_INT 16
2092: PPUSH
2093: CALL_OW 311
2097: NOT
2098: IFFALSE 2083
// setFuel ( rveh1 , 100 ) ;
2100: LD_INT 16
2102: PPUSH
2103: LD_INT 100
2105: PPUSH
2106: CALL_OW 240
// ComRepairVehicle ( rmech1 , rveh1 ) ;
2110: LD_INT 17
2112: PPUSH
2113: LD_INT 16
2115: PPUSH
2116: CALL_OW 129
// end ; wait ( patrol_waits [ difficulty ] [ 1 ] ) ;
2120: LD_EXP 24
2124: PUSH
2125: LD_OWVAR 67
2129: ARRAY
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 67
// i := 0 ;
2139: LD_ADDR_VAR 0 8
2143: PUSH
2144: LD_INT 0
2146: ST_TO_ADDR
// while ( GetLives ( rveh1 ) < 990 ) and not IsDrivenBy ( rveh1 ) and ( i < 60 ) do
2147: LD_INT 16
2149: PPUSH
2150: CALL_OW 256
2154: PUSH
2155: LD_INT 990
2157: LESS
2158: PUSH
2159: LD_INT 16
2161: PPUSH
2162: CALL_OW 311
2166: NOT
2167: AND
2168: PUSH
2169: LD_VAR 0 8
2173: PUSH
2174: LD_INT 60
2176: LESS
2177: AND
2178: IFFALSE 2203
// begin wait ( 0 0$1 ) ;
2180: LD_INT 35
2182: PPUSH
2183: CALL_OW 67
// i := i + 1 ;
2187: LD_ADDR_VAR 0 8
2191: PUSH
2192: LD_VAR 0 8
2196: PUSH
2197: LD_INT 1
2199: PLUS
2200: ST_TO_ADDR
// end ;
2201: GO 2147
// if not IsDrivenBy ( rveh1 ) then
2203: LD_INT 16
2205: PPUSH
2206: CALL_OW 311
2210: NOT
2211: IFFALSE 2223
// ComEnterUnit ( rmech1 , rveh1 ) ;
2213: LD_INT 17
2215: PPUSH
2216: LD_INT 16
2218: PPUSH
2219: CALL_OW 120
// if IsAt ( rveh1 , 126 , 86 ) then
2223: LD_INT 16
2225: PPUSH
2226: LD_INT 126
2228: PPUSH
2229: LD_INT 86
2231: PPUSH
2232: CALL_OW 307
2236: IFFALSE 2248
// setFuel ( rveh1 , 100 ) ;
2238: LD_INT 16
2240: PPUSH
2241: LD_INT 100
2243: PPUSH
2244: CALL_OW 240
// AddComAgressiveMove ( rveh1 , 27 , 18 ) ;
2248: LD_INT 16
2250: PPUSH
2251: LD_INT 27
2253: PPUSH
2254: LD_INT 18
2256: PPUSH
2257: CALL_OW 174
// expired := 0 ;
2261: LD_ADDR_VAR 0 1
2265: PUSH
2266: LD_INT 0
2268: ST_TO_ADDR
// oldx := - 1 ;
2269: LD_ADDR_VAR 0 2
2273: PUSH
2274: LD_INT 1
2276: NEG
2277: ST_TO_ADDR
// oldy := - 1 ;
2278: LD_ADDR_VAR 0 3
2282: PUSH
2283: LD_INT 1
2285: NEG
2286: ST_TO_ADDR
// while not IsAt ( rveh1 , 27 , 18 ) and ( expired < 25 ) do
2287: LD_INT 16
2289: PPUSH
2290: LD_INT 27
2292: PPUSH
2293: LD_INT 18
2295: PPUSH
2296: CALL_OW 307
2300: NOT
2301: PUSH
2302: LD_VAR 0 1
2306: PUSH
2307: LD_INT 25
2309: LESS
2310: AND
2311: IFFALSE 2451
// begin wait ( 0 0$1 ) ;
2313: LD_INT 35
2315: PPUSH
2316: CALL_OW 67
// newx := GetX ( rveh1 ) ;
2320: LD_ADDR_VAR 0 5
2324: PUSH
2325: LD_INT 16
2327: PPUSH
2328: CALL_OW 250
2332: ST_TO_ADDR
// newy := GetY ( rveh1 ) ;
2333: LD_ADDR_VAR 0 6
2337: PUSH
2338: LD_INT 16
2340: PPUSH
2341: CALL_OW 251
2345: ST_TO_ADDR
// newl := GetLives ( rveh1 ) ;
2346: LD_ADDR_VAR 0 7
2350: PUSH
2351: LD_INT 16
2353: PPUSH
2354: CALL_OW 256
2358: ST_TO_ADDR
// if ( oldx = newx ) and ( oldy = newy ) and ( oldl = newl ) then
2359: LD_VAR 0 2
2363: PUSH
2364: LD_VAR 0 5
2368: EQUAL
2369: PUSH
2370: LD_VAR 0 3
2374: PUSH
2375: LD_VAR 0 6
2379: EQUAL
2380: AND
2381: PUSH
2382: LD_VAR 0 4
2386: PUSH
2387: LD_VAR 0 7
2391: EQUAL
2392: AND
2393: IFFALSE 2411
// expired := expired + 1 else
2395: LD_ADDR_VAR 0 1
2399: PUSH
2400: LD_VAR 0 1
2404: PUSH
2405: LD_INT 1
2407: PLUS
2408: ST_TO_ADDR
2409: GO 2419
// expired := 0 ;
2411: LD_ADDR_VAR 0 1
2415: PUSH
2416: LD_INT 0
2418: ST_TO_ADDR
// oldx := newx ;
2419: LD_ADDR_VAR 0 2
2423: PUSH
2424: LD_VAR 0 5
2428: ST_TO_ADDR
// oldy := newy ;
2429: LD_ADDR_VAR 0 3
2433: PUSH
2434: LD_VAR 0 6
2438: ST_TO_ADDR
// oldl := newl ;
2439: LD_ADDR_VAR 0 4
2443: PUSH
2444: LD_VAR 0 7
2448: ST_TO_ADDR
// end ;
2449: GO 2287
// if GetLives ( rveh1 ) < 900 then
2451: LD_INT 16
2453: PPUSH
2454: CALL_OW 256
2458: PUSH
2459: LD_INT 900
2461: LESS
2462: IFFALSE 2508
// begin AddComExitVehicle ( rveh1 ) ;
2464: LD_INT 16
2466: PPUSH
2467: CALL_OW 181
// repeat wait ( 0 0$0.5 ) ;
2471: LD_INT 18
2473: PPUSH
2474: CALL_OW 67
// until not IsDrivenBy ( rveh1 ) ;
2478: LD_INT 16
2480: PPUSH
2481: CALL_OW 311
2485: NOT
2486: IFFALSE 2471
// setFuel ( rveh1 , 100 ) ;
2488: LD_INT 16
2490: PPUSH
2491: LD_INT 100
2493: PPUSH
2494: CALL_OW 240
// ComRepairVehicle ( rmech1 , rveh1 ) ;
2498: LD_INT 17
2500: PPUSH
2501: LD_INT 16
2503: PPUSH
2504: CALL_OW 129
// end ; wait ( patrol_waits [ difficulty ] [ 2 ] ) ;
2508: LD_EXP 24
2512: PUSH
2513: LD_OWVAR 67
2517: ARRAY
2518: PUSH
2519: LD_INT 2
2521: ARRAY
2522: PPUSH
2523: CALL_OW 67
// i := 0 ;
2527: LD_ADDR_VAR 0 8
2531: PUSH
2532: LD_INT 0
2534: ST_TO_ADDR
// while ( GetLives ( rveh1 ) < 990 ) and not IsDrivenBy ( rveh1 ) and ( i < 60 ) do
2535: LD_INT 16
2537: PPUSH
2538: CALL_OW 256
2542: PUSH
2543: LD_INT 990
2545: LESS
2546: PUSH
2547: LD_INT 16
2549: PPUSH
2550: CALL_OW 311
2554: NOT
2555: AND
2556: PUSH
2557: LD_VAR 0 8
2561: PUSH
2562: LD_INT 60
2564: LESS
2565: AND
2566: IFFALSE 2591
// begin wait ( 0 0$1 ) ;
2568: LD_INT 35
2570: PPUSH
2571: CALL_OW 67
// i := i + 1 ;
2575: LD_ADDR_VAR 0 8
2579: PUSH
2580: LD_VAR 0 8
2584: PUSH
2585: LD_INT 1
2587: PLUS
2588: ST_TO_ADDR
// end ;
2589: GO 2535
// if IsAt ( rveh1 , 27 , 18 ) then
2591: LD_INT 16
2593: PPUSH
2594: LD_INT 27
2596: PPUSH
2597: LD_INT 18
2599: PPUSH
2600: CALL_OW 307
2604: IFFALSE 2616
// setFuel ( rveh1 , 100 ) ;
2606: LD_INT 16
2608: PPUSH
2609: LD_INT 100
2611: PPUSH
2612: CALL_OW 240
// until false ;
2616: LD_INT 0
2618: IFFALSE 1847
// end ; end_of_file
2620: PPOPN 8
2622: END
// export demo ; export russians , you , friends ; export JMM , Cyrus , Bobby , Powell , cheater ; export trappers , guard ; export terrainhint , secondaryobj ; export guard_lives , hunting_cycles , hunt_waiting1 , hunt_patience , bobbys_wounds , driver_skills , final_hunt_wait , patrol_waits ; function prepare_difficulty ; begin
2623: LD_INT 0
2625: PPUSH
// guard_lives = [ 450 , 650 , 850 ] ;
2626: LD_ADDR_EXP 17
2630: PUSH
2631: LD_INT 450
2633: PUSH
2634: LD_INT 650
2636: PUSH
2637: LD_INT 850
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: ST_TO_ADDR
// hunting_cycles = [ 3 , 5 , 8 ] ;
2645: LD_ADDR_EXP 18
2649: PUSH
2650: LD_INT 3
2652: PUSH
2653: LD_INT 5
2655: PUSH
2656: LD_INT 8
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: LIST
2663: ST_TO_ADDR
// hunt_waiting1 = [ 0 0$5 , 0 0$3 , 0 0$1 ] ;
2664: LD_ADDR_EXP 19
2668: PUSH
2669: LD_INT 175
2671: PUSH
2672: LD_INT 105
2674: PUSH
2675: LD_INT 35
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: LIST
2682: ST_TO_ADDR
// hunt_patience = [ 17 , 26 , 38 ] ;
2683: LD_ADDR_EXP 20
2687: PUSH
2688: LD_INT 17
2690: PUSH
2691: LD_INT 26
2693: PUSH
2694: LD_INT 38
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: LIST
2701: ST_TO_ADDR
// bobbys_wounds = [ 495 , 470 , 445 ] ;
2702: LD_ADDR_EXP 21
2706: PUSH
2707: LD_INT 495
2709: PUSH
2710: LD_INT 470
2712: PUSH
2713: LD_INT 445
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: LIST
2720: ST_TO_ADDR
// driver_skills = [ 1 , 2 , 3 ] ;
2721: LD_ADDR_EXP 22
2725: PUSH
2726: LD_INT 1
2728: PUSH
2729: LD_INT 2
2731: PUSH
2732: LD_INT 3
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: LIST
2739: ST_TO_ADDR
// final_hunt_wait = [ 0 0$8 , 0 0$4 , 0 0$0 ] ;
2740: LD_ADDR_EXP 23
2744: PUSH
2745: LD_INT 280
2747: PUSH
2748: LD_INT 140
2750: PUSH
2751: LD_INT 0
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: LIST
2758: ST_TO_ADDR
// patrol_waits = [ [ 0 0$10 , 0 0$7 ] , [ 0 0$6 , 0 0$4 ] , [ 0 0$4 , 0 0$2 ] ] ;
2759: LD_ADDR_EXP 24
2763: PUSH
2764: LD_INT 350
2766: PUSH
2767: LD_INT 245
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: LD_INT 210
2776: PUSH
2777: LD_INT 140
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 140
2786: PUSH
2787: LD_INT 70
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: LIST
2798: ST_TO_ADDR
// end ;
2799: LD_VAR 0 1
2803: RET
// function prepare_sides ; begin
2804: LD_INT 0
2806: PPUSH
// you = 1 ;
2807: LD_ADDR_EXP 6
2811: PUSH
2812: LD_INT 1
2814: ST_TO_ADDR
// russians = 3 ;
2815: LD_ADDR_EXP 5
2819: PUSH
2820: LD_INT 3
2822: ST_TO_ADDR
// friends = 4 ;
2823: LD_ADDR_EXP 7
2827: PUSH
2828: LD_INT 4
2830: ST_TO_ADDR
// ComEnterUnit ( rs1 , rb1 ) ;
2831: LD_INT 37
2833: PPUSH
2834: LD_INT 29
2836: PPUSH
2837: CALL_OW 120
// ComEnterUnit ( rs2 , rb2 ) ;
2841: LD_INT 38
2843: PPUSH
2844: LD_INT 30
2846: PPUSH
2847: CALL_OW 120
// ComEnterUnit ( rs3 , rb3 ) ;
2851: LD_INT 57
2853: PPUSH
2854: LD_INT 54
2856: PPUSH
2857: CALL_OW 120
// ComEnterUnit ( rs4 , rb4 ) ;
2861: LD_INT 58
2863: PPUSH
2864: LD_INT 55
2866: PPUSH
2867: CALL_OW 120
// SetSkill ( [ rmech1 , rmech2 , rmech3 , rmech4 , rmech5 ] , skill_mechanical , driver_skills [ difficulty ] ) ;
2871: LD_INT 17
2873: PUSH
2874: LD_INT 43
2876: PUSH
2877: LD_INT 66
2879: PUSH
2880: LD_INT 67
2882: PUSH
2883: LD_INT 68
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_EXP 22
2900: PUSH
2901: LD_OWVAR 67
2905: ARRAY
2906: PPUSH
2907: CALL_OW 237
// ComEnterUnit ( rmech2 , rveh2 ) ;
2911: LD_INT 43
2913: PPUSH
2914: LD_INT 39
2916: PPUSH
2917: CALL_OW 120
// ComEnterUnit ( rmech3 , rveh3 ) ;
2921: LD_INT 66
2923: PPUSH
2924: LD_INT 64
2926: PPUSH
2927: CALL_OW 120
// ComEnterUnit ( rmech4 , rveh4 ) ;
2931: LD_INT 67
2933: PPUSH
2934: LD_INT 63
2936: PPUSH
2937: CALL_OW 120
// ComEnterUnit ( rmech5 , rveh5 ) ;
2941: LD_INT 68
2943: PPUSH
2944: LD_INT 61
2946: PPUSH
2947: CALL_OW 120
// trappers := FilterUnitsInArea ( trap , [ f_side , russians ] ) ;
2951: LD_ADDR_EXP 13
2955: PUSH
2956: LD_INT 6
2958: PPUSH
2959: LD_INT 22
2961: PUSH
2962: LD_EXP 5
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PPUSH
2971: CALL_OW 70
2975: ST_TO_ADDR
// ComCrawl ( trappers ) ;
2976: LD_EXP 13
2980: PPUSH
2981: CALL_OW 137
// end ;
2985: LD_VAR 0 1
2989: RET
// function err ( s ) ; begin
2990: LD_INT 0
2992: PPUSH
// BuildQuery ( s , [ OK ] ) ;
2993: LD_VAR 0 1
2997: PPUSH
2998: LD_STRING OK
3000: PUSH
3001: EMPTY
3002: LIST
3003: PPUSH
3004: CALL_OW 99
// end ;
3008: LD_VAR 0 2
3012: RET
// function prepare_character ( s ) ; begin
3013: LD_INT 0
3015: PPUSH
// if not CheckCharacterSet ( s ) then
3016: LD_VAR 0 1
3020: PPUSH
3021: CALL_OW 29
3025: NOT
3026: IFFALSE 3043
// Err ( Creating  & s ) else
3028: LD_STRING Creating 
3030: PUSH
3031: LD_VAR 0 1
3035: STR
3036: PPUSH
3037: CALL 2990 0 1
3041: GO 3058
// result := CreateCharacter ( s ) ;
3043: LD_ADDR_VAR 0 2
3047: PUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: CALL_OW 34
3057: ST_TO_ADDR
// end ;
3058: LD_VAR 0 2
3062: RET
// function prepare_all ; begin
3063: LD_INT 0
3065: PPUSH
// uc_side := you ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_EXP 6
3075: ST_TO_ADDR
// uc_nation := nation_american ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
3084: LD_ADDR_EXP 8
3088: PUSH
3089: LD_STRING JMM
3091: PPUSH
3092: CALL_OW 34
3096: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
3097: LD_ADDR_EXP 11
3101: PUSH
3102: LD_STRING Powell
3104: PPUSH
3105: CALL_OW 25
3109: ST_TO_ADDR
// uc_side := friends ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_EXP 7
3119: ST_TO_ADDR
// Bobby := NewCharacter ( Bobby ) ;
3120: LD_ADDR_EXP 10
3124: PUSH
3125: LD_STRING Bobby
3127: PPUSH
3128: CALL_OW 25
3132: ST_TO_ADDR
// Cyrus := NewCharacter ( Cyrus ) ;
3133: LD_ADDR_EXP 9
3137: PUSH
3138: LD_STRING Cyrus
3140: PPUSH
3141: CALL_OW 25
3145: ST_TO_ADDR
// SetLives ( Bobby , bobbys_wounds [ difficulty ] ) ;
3146: LD_EXP 10
3150: PPUSH
3151: LD_EXP 21
3155: PUSH
3156: LD_OWVAR 67
3160: ARRAY
3161: PPUSH
3162: CALL_OW 234
// end ;
3166: LD_VAR 0 1
3170: RET
// function prepare_JMM ; begin
3171: LD_INT 0
3173: PPUSH
// uc_side = you ;
3174: LD_ADDR_OWVAR 20
3178: PUSH
3179: LD_EXP 6
3183: ST_TO_ADDR
// uc_nation = nation_american ;
3184: LD_ADDR_OWVAR 21
3188: PUSH
3189: LD_INT 1
3191: ST_TO_ADDR
// uc_direction = 0 ;
3192: LD_ADDR_OWVAR 24
3196: PUSH
3197: LD_INT 0
3199: ST_TO_ADDR
// hc_name = John Macmillan ;
3200: LD_ADDR_OWVAR 26
3204: PUSH
3205: LD_STRING John Macmillan
3207: ST_TO_ADDR
// hc_class = class_soldier ;
3208: LD_ADDR_OWVAR 28
3212: PUSH
3213: LD_INT 1
3215: ST_TO_ADDR
// hc_sex = sex_male ;
3216: LD_ADDR_OWVAR 27
3220: PUSH
3221: LD_INT 1
3223: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
3224: LD_ADDR_OWVAR 29
3228: PUSH
3229: LD_INT 11
3231: PUSH
3232: LD_INT 11
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: ST_TO_ADDR
// hc_basic_skills = [ 2 , 1 , 0 , 0 ] ;
3239: LD_ADDR_OWVAR 30
3243: PUSH
3244: LD_INT 2
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: LD_INT 0
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: ST_TO_ADDR
// hc_skills = [ 2 , 1 , 0 , 0 ] ;
3262: LD_ADDR_OWVAR 31
3266: PUSH
3267: LD_INT 2
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: LD_INT 0
3275: PUSH
3276: LD_INT 0
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: ST_TO_ADDR
// hc_gallery = us ;
3285: LD_ADDR_OWVAR 33
3289: PUSH
3290: LD_STRING us
3292: ST_TO_ADDR
// hc_face_number = 5 ;
3293: LD_ADDR_OWVAR 34
3297: PUSH
3298: LD_INT 5
3300: ST_TO_ADDR
// hc_importance = 110 ;
3301: LD_ADDR_OWVAR 32
3305: PUSH
3306: LD_INT 110
3308: ST_TO_ADDR
// end ;
3309: LD_VAR 0 1
3313: RET
// function prepare_Bobby ; begin
3314: LD_INT 0
3316: PPUSH
// uc_side = friends ;
3317: LD_ADDR_OWVAR 20
3321: PUSH
3322: LD_EXP 7
3326: ST_TO_ADDR
// uc_nation = nation_american ;
3327: LD_ADDR_OWVAR 21
3331: PUSH
3332: LD_INT 1
3334: ST_TO_ADDR
// uc_direction = 0 ;
3335: LD_ADDR_OWVAR 24
3339: PUSH
3340: LD_INT 0
3342: ST_TO_ADDR
// hc_name = Bobby Brandon ;
3343: LD_ADDR_OWVAR 26
3347: PUSH
3348: LD_STRING Bobby Brandon
3350: ST_TO_ADDR
// hc_class = class_soldier ;
3351: LD_ADDR_OWVAR 28
3355: PUSH
3356: LD_INT 1
3358: ST_TO_ADDR
// hc_sex = sex_male ;
3359: LD_ADDR_OWVAR 27
3363: PUSH
3364: LD_INT 1
3366: ST_TO_ADDR
// hc_attr = [ 11 , 10 ] ;
3367: LD_ADDR_OWVAR 29
3371: PUSH
3372: LD_INT 11
3374: PUSH
3375: LD_INT 10
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: ST_TO_ADDR
// hc_basic_skills = [ 1 , 0 , 1 , 1 ] ;
3382: LD_ADDR_OWVAR 30
3386: PUSH
3387: LD_INT 1
3389: PUSH
3390: LD_INT 0
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: LD_INT 1
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: ST_TO_ADDR
// hc_skills = [ 1 , 0 , 1 , 1 ] ;
3405: LD_ADDR_OWVAR 31
3409: PUSH
3410: LD_INT 1
3412: PUSH
3413: LD_INT 0
3415: PUSH
3416: LD_INT 1
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: ST_TO_ADDR
// hc_gallery = us ;
3428: LD_ADDR_OWVAR 33
3432: PUSH
3433: LD_STRING us
3435: ST_TO_ADDR
// hc_face_number = 9 ;
3436: LD_ADDR_OWVAR 34
3440: PUSH
3441: LD_INT 9
3443: ST_TO_ADDR
// hc_importance = 40 ;
3444: LD_ADDR_OWVAR 32
3448: PUSH
3449: LD_INT 40
3451: ST_TO_ADDR
// Bobby := CreateHuman ;
3452: LD_ADDR_EXP 10
3456: PUSH
3457: CALL_OW 44
3461: ST_TO_ADDR
// SetLives ( Bobby , bobbys_wounds [ difficulty ] ) ;
3462: LD_EXP 10
3466: PPUSH
3467: LD_EXP 21
3471: PUSH
3472: LD_OWVAR 67
3476: ARRAY
3477: PPUSH
3478: CALL_OW 234
// end ;
3482: LD_VAR 0 1
3486: RET
// function prepare_Cyrus ; begin
3487: LD_INT 0
3489: PPUSH
// uc_side = friends ;
3490: LD_ADDR_OWVAR 20
3494: PUSH
3495: LD_EXP 7
3499: ST_TO_ADDR
// uc_nation = nation_american ;
3500: LD_ADDR_OWVAR 21
3504: PUSH
3505: LD_INT 1
3507: ST_TO_ADDR
// uc_direction = 0 ;
3508: LD_ADDR_OWVAR 24
3512: PUSH
3513: LD_INT 0
3515: ST_TO_ADDR
// hc_name = Cyrus Parker ;
3516: LD_ADDR_OWVAR 26
3520: PUSH
3521: LD_STRING Cyrus Parker
3523: ST_TO_ADDR
// hc_class = class_soldier ;
3524: LD_ADDR_OWVAR 28
3528: PUSH
3529: LD_INT 1
3531: ST_TO_ADDR
// hc_sex = sex_male ;
3532: LD_ADDR_OWVAR 27
3536: PUSH
3537: LD_INT 1
3539: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
3540: LD_ADDR_OWVAR 29
3544: PUSH
3545: LD_INT 10
3547: PUSH
3548: LD_INT 10
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: ST_TO_ADDR
// hc_basic_skills = [ 1 , 0 , 2 , 0 ] ;
3555: LD_ADDR_OWVAR 30
3559: PUSH
3560: LD_INT 1
3562: PUSH
3563: LD_INT 0
3565: PUSH
3566: LD_INT 2
3568: PUSH
3569: LD_INT 0
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: ST_TO_ADDR
// hc_skills = [ 1 , 0 , 2 , 0 ] ;
3578: LD_ADDR_OWVAR 31
3582: PUSH
3583: LD_INT 1
3585: PUSH
3586: LD_INT 0
3588: PUSH
3589: LD_INT 2
3591: PUSH
3592: LD_INT 0
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: ST_TO_ADDR
// hc_gallery = us ;
3601: LD_ADDR_OWVAR 33
3605: PUSH
3606: LD_STRING us
3608: ST_TO_ADDR
// hc_face_number = 8 ;
3609: LD_ADDR_OWVAR 34
3613: PUSH
3614: LD_INT 8
3616: ST_TO_ADDR
// hc_importance = 40 ;
3617: LD_ADDR_OWVAR 32
3621: PUSH
3622: LD_INT 40
3624: ST_TO_ADDR
// Cyrus := CreateHuman ;
3625: LD_ADDR_EXP 9
3629: PUSH
3630: CALL_OW 44
3634: ST_TO_ADDR
// end ;
3635: LD_VAR 0 1
3639: RET
// function prepare_Powell ; begin
3640: LD_INT 0
3642: PPUSH
// uc_side = you ;
3643: LD_ADDR_OWVAR 20
3647: PUSH
3648: LD_EXP 6
3652: ST_TO_ADDR
// uc_nation = nation_american ;
3653: LD_ADDR_OWVAR 21
3657: PUSH
3658: LD_INT 1
3660: ST_TO_ADDR
// uc_direction = 0 ;
3661: LD_ADDR_OWVAR 24
3665: PUSH
3666: LD_INT 0
3668: ST_TO_ADDR
// hc_name = Arthur Powell ;
3669: LD_ADDR_OWVAR 26
3673: PUSH
3674: LD_STRING Arthur Powell
3676: ST_TO_ADDR
// hc_class = class_soldier ;
3677: LD_ADDR_OWVAR 28
3681: PUSH
3682: LD_INT 1
3684: ST_TO_ADDR
// hc_sex = sex_male ;
3685: LD_ADDR_OWVAR 27
3689: PUSH
3690: LD_INT 1
3692: ST_TO_ADDR
// hc_attr = [ 11 , 10 ] ;
3693: LD_ADDR_OWVAR 29
3697: PUSH
3698: LD_INT 11
3700: PUSH
3701: LD_INT 10
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: ST_TO_ADDR
// hc_basic_skills = [ 2 , 0 , 0 , 0 ] ;
3708: LD_ADDR_OWVAR 30
3712: PUSH
3713: LD_INT 2
3715: PUSH
3716: LD_INT 0
3718: PUSH
3719: LD_INT 0
3721: PUSH
3722: LD_INT 0
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: LIST
3729: LIST
3730: ST_TO_ADDR
// hc_skills = [ 5 , 1 , 2 , 0 ] ;
3731: LD_ADDR_OWVAR 31
3735: PUSH
3736: LD_INT 5
3738: PUSH
3739: LD_INT 1
3741: PUSH
3742: LD_INT 2
3744: PUSH
3745: LD_INT 0
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: LIST
3752: LIST
3753: ST_TO_ADDR
// hc_gallery = us ;
3754: LD_ADDR_OWVAR 33
3758: PUSH
3759: LD_STRING us
3761: ST_TO_ADDR
// hc_face_number = 7 ;
3762: LD_ADDR_OWVAR 34
3766: PUSH
3767: LD_INT 7
3769: ST_TO_ADDR
// hc_importance = 50 ;
3770: LD_ADDR_OWVAR 32
3774: PUSH
3775: LD_INT 50
3777: ST_TO_ADDR
// Powell := CreateHuman ;
3778: LD_ADDR_EXP 11
3782: PUSH
3783: CALL_OW 44
3787: ST_TO_ADDR
// end ;
3788: LD_VAR 0 1
3792: RET
// function prepare_cheater ; begin
3793: LD_INT 0
3795: PPUSH
// uc_side = you ;
3796: LD_ADDR_OWVAR 20
3800: PUSH
3801: LD_EXP 6
3805: ST_TO_ADDR
// uc_nation = nation_american ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_INT 1
3813: ST_TO_ADDR
// uc_direction = 0 ;
3814: LD_ADDR_OWVAR 24
3818: PUSH
3819: LD_INT 0
3821: ST_TO_ADDR
// hc_name =   ;
3822: LD_ADDR_OWVAR 26
3826: PUSH
3827: LD_STRING  
3829: ST_TO_ADDR
// hc_class = class_soldier ;
3830: LD_ADDR_OWVAR 28
3834: PUSH
3835: LD_INT 1
3837: ST_TO_ADDR
// hc_sex = sex_male ;
3838: LD_ADDR_OWVAR 27
3842: PUSH
3843: LD_INT 1
3845: ST_TO_ADDR
// hc_attr = [ 11 , 10 ] ;
3846: LD_ADDR_OWVAR 29
3850: PUSH
3851: LD_INT 11
3853: PUSH
3854: LD_INT 10
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: ST_TO_ADDR
// hc_basic_skills = [ 2 , 0 , 0 , 0 ] ;
3861: LD_ADDR_OWVAR 30
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 0
3871: PUSH
3872: LD_INT 0
3874: PUSH
3875: LD_INT 0
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: ST_TO_ADDR
// hc_skills = [ 5 , 1 , 2 , 0 ] ;
3884: LD_ADDR_OWVAR 31
3888: PUSH
3889: LD_INT 5
3891: PUSH
3892: LD_INT 1
3894: PUSH
3895: LD_INT 2
3897: PUSH
3898: LD_INT 0
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: LIST
3905: LIST
3906: ST_TO_ADDR
// hc_gallery = ru ;
3907: LD_ADDR_OWVAR 33
3911: PUSH
3912: LD_STRING ru
3914: ST_TO_ADDR
// hc_face_number = 4 ;
3915: LD_ADDR_OWVAR 34
3919: PUSH
3920: LD_INT 4
3922: ST_TO_ADDR
// hc_importance = 50 ;
3923: LD_ADDR_OWVAR 32
3927: PUSH
3928: LD_INT 50
3930: ST_TO_ADDR
// cheater := CreateHuman ;
3931: LD_ADDR_EXP 12
3935: PUSH
3936: CALL_OW 44
3940: ST_TO_ADDR
// end ;
3941: LD_VAR 0 1
3945: RET
// function prepare_guard ; var n , i ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
// guard := [ ] ;
3951: LD_ADDR_EXP 14
3955: PUSH
3956: EMPTY
3957: ST_TO_ADDR
// uc_side = russians ;
3958: LD_ADDR_OWVAR 20
3962: PUSH
3963: LD_EXP 5
3967: ST_TO_ADDR
// uc_nation = nation_russian ;
3968: LD_ADDR_OWVAR 21
3972: PUSH
3973: LD_INT 3
3975: ST_TO_ADDR
// uc_direction = 0 ;
3976: LD_ADDR_OWVAR 24
3980: PUSH
3981: LD_INT 0
3983: ST_TO_ADDR
// hc_name =  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// hc_sex = sex_male ;
3992: LD_ADDR_OWVAR 27
3996: PUSH
3997: LD_INT 1
3999: ST_TO_ADDR
// hc_class = class_soldier ;
4000: LD_ADDR_OWVAR 28
4004: PUSH
4005: LD_INT 1
4007: ST_TO_ADDR
// hc_gallery =  ;
4008: LD_ADDR_OWVAR 33
4012: PUSH
4013: LD_STRING 
4015: ST_TO_ADDR
// hc_importance = 0 ;
4016: LD_ADDR_OWVAR 32
4020: PUSH
4021: LD_INT 0
4023: ST_TO_ADDR
// for i := 1 to 2 do
4024: LD_ADDR_VAR 0 3
4028: PUSH
4029: DOUBLE
4030: LD_INT 1
4032: DEC
4033: ST_TO_ADDR
4034: LD_INT 2
4036: PUSH
4037: FOR_TO
4038: IFFALSE 4139
// begin if i = 1 then
4040: LD_VAR 0 3
4044: PUSH
4045: LD_INT 1
4047: EQUAL
4048: IFFALSE 4062
// PrepareSoldier ( sex_female , 1 ) else
4050: LD_INT 2
4052: PPUSH
4053: LD_INT 1
4055: PPUSH
4056: CALL_OW 381
4060: GO 4072
// PrepareSoldier ( sex_male , 1 ) ;
4062: LD_INT 1
4064: PPUSH
4065: LD_INT 1
4067: PPUSH
4068: CALL_OW 381
// hc_attr := [ 9 , 9 ] ;
4072: LD_ADDR_OWVAR 29
4076: PUSH
4077: LD_INT 9
4079: PUSH
4080: LD_INT 9
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: ST_TO_ADDR
// n := CreateHuman ;
4087: LD_ADDR_VAR 0 2
4091: PUSH
4092: CALL_OW 44
4096: ST_TO_ADDR
// PlaceUnitXYR ( n , 94 , 4 , 3 , 0 ) ;
4097: LD_VAR 0 2
4101: PPUSH
4102: LD_INT 94
4104: PPUSH
4105: LD_INT 4
4107: PPUSH
4108: LD_INT 3
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL_OW 50
// guard := guard ^ [ n ] ;
4118: LD_ADDR_EXP 14
4122: PUSH
4123: LD_EXP 14
4127: PUSH
4128: LD_VAR 0 2
4132: PUSH
4133: EMPTY
4134: LIST
4135: ADD
4136: ST_TO_ADDR
// end ;
4137: GO 4037
4139: POP
4140: POP
// end ;
4141: LD_VAR 0 1
4145: RET
// every 0 0$9 do
4146: GO 4148
4148: DISABLE
// begin PlaceUnitXY ( Bobby , 42 , 74 , false ) ;
4149: LD_EXP 10
4153: PPUSH
4154: LD_INT 42
4156: PPUSH
4157: LD_INT 74
4159: PPUSH
4160: LD_INT 0
4162: PPUSH
4163: CALL_OW 48
// AddComWait ( Bobby , 0 0$20 ) ;
4167: LD_EXP 10
4171: PPUSH
4172: LD_INT 700
4174: PPUSH
4175: CALL_OW 202
// AddComMoveXY ( Bobby , 63 , 85 ) ;
4179: LD_EXP 10
4183: PPUSH
4184: LD_INT 63
4186: PPUSH
4187: LD_INT 85
4189: PPUSH
4190: CALL_OW 171
// AddComMoveXY ( Bobby , 72 , 88 ) ;
4194: LD_EXP 10
4198: PPUSH
4199: LD_INT 72
4201: PPUSH
4202: LD_INT 88
4204: PPUSH
4205: CALL_OW 171
// AddComWait ( Bobby , 0 0$5 ) ;
4209: LD_EXP 10
4213: PPUSH
4214: LD_INT 175
4216: PPUSH
4217: CALL_OW 202
// AddComMoveXY ( Bobby , 84 , 81 ) ;
4221: LD_EXP 10
4225: PPUSH
4226: LD_INT 84
4228: PPUSH
4229: LD_INT 81
4231: PPUSH
4232: CALL_OW 171
// end ;
4236: END
// every 0 0$5 do
4237: GO 4239
4239: DISABLE
// begin PlaceUnitXY ( Cyrus , 94 , 44 , false ) ;
4240: LD_EXP 9
4244: PPUSH
4245: LD_INT 94
4247: PPUSH
4248: LD_INT 44
4250: PPUSH
4251: LD_INT 0
4253: PPUSH
4254: CALL_OW 48
// repeat ComMoveXY ( Cyrus , 76 , 41 ) ;
4258: LD_EXP 9
4262: PPUSH
4263: LD_INT 76
4265: PPUSH
4266: LD_INT 41
4268: PPUSH
4269: CALL_OW 111
// AddComMoveXY ( Cyrus , 90 , 41 ) ;
4273: LD_EXP 9
4277: PPUSH
4278: LD_INT 90
4280: PPUSH
4281: LD_INT 41
4283: PPUSH
4284: CALL_OW 171
// repeat wait ( 0 0$0.5 ) ;
4288: LD_INT 18
4290: PPUSH
4291: CALL_OW 67
// until not IsBusy ( Cyrus ) or not IsOk ( Cyrus ) or ( GetSide ( Cyrus ) = you ) ;
4295: LD_EXP 9
4299: PPUSH
4300: CALL_OW 315
4304: NOT
4305: PUSH
4306: LD_EXP 9
4310: PPUSH
4311: CALL_OW 302
4315: NOT
4316: OR
4317: PUSH
4318: LD_EXP 9
4322: PPUSH
4323: CALL_OW 255
4327: PUSH
4328: LD_EXP 6
4332: EQUAL
4333: OR
4334: IFFALSE 4288
// until not IsOk ( Cyrus ) or ( GetSide ( Cyrus ) = you ) ;
4336: LD_EXP 9
4340: PPUSH
4341: CALL_OW 302
4345: NOT
4346: PUSH
4347: LD_EXP 9
4351: PPUSH
4352: CALL_OW 255
4356: PUSH
4357: LD_EXP 6
4361: EQUAL
4362: OR
4363: IFFALSE 4258
// end ;
4365: END
// starting begin demo := false ;
4366: LD_ADDR_EXP 4
4370: PUSH
4371: LD_INT 0
4373: ST_TO_ADDR
// prepare_difficulty ;
4374: CALL 2623 0 0
// prepare_sides ;
4378: CALL 2804 0 0
// prepare_all ;
4382: CALL 3063 0 0
// prepare_cheater ;
4386: CALL 3793 0 0
// prepare_guard ;
4390: CALL 3946 0 0
// dialogue_JMM_appears ;
4394: CALL 4403 0 0
// hunters_to_position ;
4398: CALL 0 0 0
// end ; end_of_file
4402: END
// export spotx , spoty ; export function dialogue_JMM_appears ; begin
4403: LD_INT 0
4405: PPUSH
// InGameOn ;
4406: CALL_OW 8
// CenterNowOnXY ( 78 , 74 ) ;
4410: LD_INT 78
4412: PPUSH
4413: LD_INT 74
4415: PPUSH
4416: CALL_OW 86
// DWait ( 0 0$2 ) ;
4420: LD_INT 70
4422: PPUSH
4423: CALL_OW 68
// PlaceUnitXY ( JMM , 81 , 81 , true ) ;
4427: LD_EXP 8
4431: PPUSH
4432: LD_INT 81
4434: PPUSH
4435: LD_INT 81
4437: PPUSH
4438: LD_INT 1
4440: PPUSH
4441: CALL_OW 48
// DWait ( 0 0$1 ) ;
4445: LD_INT 35
4447: PPUSH
4448: CALL_OW 68
// ComMoveXY ( tiger1 , 111 , 34 ) ;
4452: LD_INT 77
4454: PPUSH
4455: LD_INT 111
4457: PPUSH
4458: LD_INT 34
4460: PPUSH
4461: CALL_OW 111
// DWait ( 0 0$1 ) ;
4465: LD_INT 35
4467: PPUSH
4468: CALL_OW 68
// ComWait ( JMM , 0 0$2 ) ;
4472: LD_EXP 8
4476: PPUSH
4477: LD_INT 70
4479: PPUSH
4480: CALL_OW 142
// AddComMoveXY ( JMM , 80 , 83 ) ;
4484: LD_EXP 8
4488: PPUSH
4489: LD_INT 80
4491: PPUSH
4492: LD_INT 83
4494: PPUSH
4495: CALL_OW 171
// ComWait ( JMM , 0 0$3 ) ;
4499: LD_EXP 8
4503: PPUSH
4504: LD_INT 105
4506: PPUSH
4507: CALL_OW 142
// AddComMoveXY ( JMM , 80 , 78 ) ;
4511: LD_EXP 8
4515: PPUSH
4516: LD_INT 80
4518: PPUSH
4519: LD_INT 78
4521: PPUSH
4522: CALL_OW 171
// AddComWait ( JMM , 0 0$3 ) ;
4526: LD_EXP 8
4530: PPUSH
4531: LD_INT 105
4533: PPUSH
4534: CALL_OW 202
// AddComMoveXY ( JMM , 84 , 80 ) ;
4538: LD_EXP 8
4542: PPUSH
4543: LD_INT 84
4545: PPUSH
4546: LD_INT 80
4548: PPUSH
4549: CALL_OW 171
// AddComWait ( JMM , 0 0$2 ) ;
4553: LD_EXP 8
4557: PPUSH
4558: LD_INT 70
4560: PPUSH
4561: CALL_OW 202
// AddComMoveXY ( JMM , 83 , 81 ) ;
4565: LD_EXP 8
4569: PPUSH
4570: LD_INT 83
4572: PPUSH
4573: LD_INT 81
4575: PPUSH
4576: CALL_OW 171
// ComMoveXY ( JMM , 80 , 77 ) ;
4580: LD_EXP 8
4584: PPUSH
4585: LD_INT 80
4587: PPUSH
4588: LD_INT 77
4590: PPUSH
4591: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
4595: LD_EXP 8
4599: PPUSH
4600: LD_STRING D1-JMM-1
4602: PPUSH
4603: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
4607: LD_INT 18
4609: PPUSH
4610: CALL_OW 68
// Say ( JMM , D1-JMM-1a ) ;
4614: LD_EXP 8
4618: PPUSH
4619: LD_STRING D1-JMM-1a
4621: PPUSH
4622: CALL_OW 88
// DWait ( 0 0$1 ) ;
4626: LD_INT 35
4628: PPUSH
4629: CALL_OW 68
// Say ( JMM , D1-JMM-1b ) ;
4633: LD_EXP 8
4637: PPUSH
4638: LD_STRING D1-JMM-1b
4640: PPUSH
4641: CALL_OW 88
// DWait ( 0 0$0.5 ) ;
4645: LD_INT 18
4647: PPUSH
4648: CALL_OW 68
// Say ( JMM , D1-JMM-1c ) ;
4652: LD_EXP 8
4656: PPUSH
4657: LD_STRING D1-JMM-1c
4659: PPUSH
4660: CALL_OW 88
// SayRadioNoName ( Powell , D1-Pow-1 ) ;
4664: LD_EXP 11
4668: PPUSH
4669: LD_STRING D1-Pow-1
4671: PPUSH
4672: CALL_OW 95
// Say ( JMM , D1-JMM-2 ) ;
4676: LD_EXP 8
4680: PPUSH
4681: LD_STRING D1-JMM-2
4683: PPUSH
4684: CALL_OW 88
// SayRadioNoName ( Powell , D1-Pow-2 ) ;
4688: LD_EXP 11
4692: PPUSH
4693: LD_STRING D1-Pow-2
4695: PPUSH
4696: CALL_OW 95
// ComMoveXY ( JMM , 80 , 77 ) ;
4700: LD_EXP 8
4704: PPUSH
4705: LD_INT 80
4707: PPUSH
4708: LD_INT 77
4710: PPUSH
4711: CALL_OW 111
// Say ( JMM , D1-JMM-3 ) ;
4715: LD_EXP 8
4719: PPUSH
4720: LD_STRING D1-JMM-3
4722: PPUSH
4723: CALL_OW 88
// SayRadioNoName ( Powell , D1-Pow-3 ) ;
4727: LD_EXP 11
4731: PPUSH
4732: LD_STRING D1-Pow-3
4734: PPUSH
4735: CALL_OW 95
// SayEffect ( strelba.wav ) ;
4739: LD_STRING strelba.wav
4741: PPUSH
4742: CALL_OW 96
// Say ( JMM , D1-JMM-4 ) ;
4746: LD_EXP 8
4750: PPUSH
4751: LD_STRING D1-JMM-4
4753: PPUSH
4754: CALL_OW 88
// SaveForQuickRestart ;
4758: CALL_OW 22
// Wait ( 0 0$0.5 ) ;
4762: LD_INT 18
4764: PPUSH
4765: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
4769: LD_STRING M1
4771: PPUSH
4772: CALL_OW 337
// InGameOff ;
4776: CALL_OW 9
// end ;
4780: LD_VAR 0 1
4784: RET
// every 0 0$1 trigger see ( you , Cyrus ) and IsOk ( Cyrus ) do
4785: LD_EXP 6
4789: PPUSH
4790: LD_EXP 9
4794: PPUSH
4795: CALL_OW 292
4799: PUSH
4800: LD_EXP 9
4804: PPUSH
4805: CALL_OW 302
4809: AND
4810: IFFALSE 5108
4812: GO 4814
4814: DISABLE
// begin if see ( russians , JMM ) then
4815: LD_EXP 5
4819: PPUSH
4820: LD_EXP 8
4824: PPUSH
4825: CALL_OW 292
4829: IFFALSE 4863
// begin enable ;
4831: ENABLE
// ComAgressiveMove ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4832: LD_EXP 9
4836: PPUSH
4837: LD_EXP 8
4841: PPUSH
4842: CALL_OW 250
4846: PPUSH
4847: LD_EXP 8
4851: PPUSH
4852: CALL_OW 251
4856: PPUSH
4857: CALL_OW 114
// exit ;
4861: GO 5108
// end ; wait ( 0 0$0.3 ) ;
4863: LD_INT 10
4865: PPUSH
4866: CALL_OW 67
// if see ( russians , JMM ) then
4870: LD_EXP 5
4874: PPUSH
4875: LD_EXP 8
4879: PPUSH
4880: CALL_OW 292
4884: IFFALSE 4918
// begin enable ;
4886: ENABLE
// ComAgressiveMove ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4887: LD_EXP 9
4891: PPUSH
4892: LD_EXP 8
4896: PPUSH
4897: CALL_OW 250
4901: PPUSH
4902: LD_EXP 8
4906: PPUSH
4907: CALL_OW 251
4911: PPUSH
4912: CALL_OW 114
// exit ;
4916: GO 5108
// end ; if not see ( you , Cyrus ) then
4918: LD_EXP 6
4922: PPUSH
4923: LD_EXP 9
4927: PPUSH
4928: CALL_OW 292
4932: NOT
4933: IFFALSE 4938
// begin enable ;
4935: ENABLE
// exit ;
4936: GO 5108
// end ; DialogueOn ;
4938: CALL_OW 6
// CenterOnUnits ( Cyrus ) ;
4942: LD_EXP 9
4946: PPUSH
4947: CALL_OW 85
// Say ( JMM , D5-JMM-1 ) ;
4951: LD_EXP 8
4955: PPUSH
4956: LD_STRING D5-JMM-1
4958: PPUSH
4959: CALL_OW 88
// Say ( Cyrus , D5-Cyrus-1 ) ;
4963: LD_EXP 9
4967: PPUSH
4968: LD_STRING D5-Cyrus-1
4970: PPUSH
4971: CALL_OW 88
// if IsOk ( Bobby ) and ( GetDistUnits ( Cyrus , Bobby ) < 17 ) then
4975: LD_EXP 10
4979: PPUSH
4980: CALL_OW 302
4984: PUSH
4985: LD_EXP 9
4989: PPUSH
4990: LD_EXP 10
4994: PPUSH
4995: CALL_OW 296
4999: PUSH
5000: LD_INT 17
5002: LESS
5003: AND
5004: IFFALSE 5018
// Say ( Bobby , D5-Bobby-1 ) ;
5006: LD_EXP 10
5010: PPUSH
5011: LD_STRING D5-Bobby-1
5013: PPUSH
5014: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5018: LD_EXP 8
5022: PPUSH
5023: LD_STRING D5-JMM-2
5025: PPUSH
5026: CALL_OW 88
// DialogueOff ;
5030: CALL_OW 7
// SetSide ( Cyrus , you ) ;
5034: LD_EXP 9
5038: PPUSH
5039: LD_EXP 6
5043: PPUSH
5044: CALL_OW 235
// ComStop ( Cyrus ) ;
5048: LD_EXP 9
5052: PPUSH
5053: CALL_OW 141
// found := found ^ [ Cyrus ] ;
5057: LD_ADDR_EXP 28
5061: PUSH
5062: LD_EXP 28
5066: PUSH
5067: LD_EXP 9
5071: PUSH
5072: EMPTY
5073: LIST
5074: ADD
5075: ST_TO_ADDR
// if secondaryobj then
5076: LD_EXP 16
5080: IFFALSE 5108
// if found > 1 then
5082: LD_EXP 28
5086: PUSH
5087: LD_INT 1
5089: GREATER
5090: IFFALSE 5101
// ChangeMissionObjectives ( M2c ) else
5092: LD_STRING M2c
5094: PPUSH
5095: CALL_OW 337
5099: GO 5108
// ChangeMissionObjectives ( M2b ) ;
5101: LD_STRING M2b
5103: PPUSH
5104: CALL_OW 337
// end ;
5108: END
// every 0 0$1 trigger see ( you , Bobby ) and IsOk ( Bobby ) do
5109: LD_EXP 6
5113: PPUSH
5114: LD_EXP 10
5118: PPUSH
5119: CALL_OW 292
5123: PUSH
5124: LD_EXP 10
5128: PPUSH
5129: CALL_OW 302
5133: AND
5134: IFFALSE 5519
5136: GO 5138
5138: DISABLE
// begin if see ( russians , JMM ) then
5139: LD_EXP 5
5143: PPUSH
5144: LD_EXP 8
5148: PPUSH
5149: CALL_OW 292
5153: IFFALSE 5187
// begin enable ;
5155: ENABLE
// ComAgressiveMove ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
5156: LD_EXP 10
5160: PPUSH
5161: LD_EXP 8
5165: PPUSH
5166: CALL_OW 250
5170: PPUSH
5171: LD_EXP 8
5175: PPUSH
5176: CALL_OW 251
5180: PPUSH
5181: CALL_OW 114
// exit ;
5185: GO 5519
// end ; wait ( 0 0$0.3 ) ;
5187: LD_INT 10
5189: PPUSH
5190: CALL_OW 67
// if see ( russians , JMM ) then
5194: LD_EXP 5
5198: PPUSH
5199: LD_EXP 8
5203: PPUSH
5204: CALL_OW 292
5208: IFFALSE 5242
// begin enable ;
5210: ENABLE
// ComAgressiveMove ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
5211: LD_EXP 10
5215: PPUSH
5216: LD_EXP 8
5220: PPUSH
5221: CALL_OW 250
5225: PPUSH
5226: LD_EXP 8
5230: PPUSH
5231: CALL_OW 251
5235: PPUSH
5236: CALL_OW 114
// exit ;
5240: GO 5519
// end ; if not see ( you , Bobby ) then
5242: LD_EXP 6
5246: PPUSH
5247: LD_EXP 10
5251: PPUSH
5252: CALL_OW 292
5256: NOT
5257: IFFALSE 5262
// begin enable ;
5259: ENABLE
// exit ;
5260: GO 5519
// end ; DialogueOn ;
5262: CALL_OW 6
// CenterOnUnits ( Bobby ) ;
5266: LD_EXP 10
5270: PPUSH
5271: CALL_OW 85
// Say ( JMM , D2-JMM-1 ) ;
5275: LD_EXP 8
5279: PPUSH
5280: LD_STRING D2-JMM-1
5282: PPUSH
5283: CALL_OW 88
// Say ( Bobby , D2-Bobby-1 ) ;
5287: LD_EXP 10
5291: PPUSH
5292: LD_STRING D2-Bobby-1
5294: PPUSH
5295: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5299: LD_EXP 8
5303: PPUSH
5304: LD_STRING D2-JMM-2
5306: PPUSH
5307: CALL_OW 88
// Say ( Bobby , D2-Bobby-2 ) ;
5311: LD_EXP 10
5315: PPUSH
5316: LD_STRING D2-Bobby-2
5318: PPUSH
5319: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5323: LD_EXP 8
5327: PPUSH
5328: LD_STRING D2-JMM-3
5330: PPUSH
5331: CALL_OW 88
// Say ( Bobby , D2-Bobby-3 ) ;
5335: LD_EXP 10
5339: PPUSH
5340: LD_STRING D2-Bobby-3
5342: PPUSH
5343: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
5347: LD_EXP 8
5351: PPUSH
5352: LD_STRING D2-JMM-4
5354: PPUSH
5355: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
5359: LD_EXP 10
5363: PPUSH
5364: LD_STRING D2-Bobby-4
5366: PPUSH
5367: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
5371: LD_EXP 8
5375: PPUSH
5376: LD_STRING D2-JMM-5
5378: PPUSH
5379: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
5383: LD_EXP 10
5387: PPUSH
5388: LD_STRING D2-Bobby-5
5390: PPUSH
5391: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
5395: LD_EXP 8
5399: PPUSH
5400: LD_STRING D2-JMM-6
5402: PPUSH
5403: CALL_OW 88
// DialogueOff ;
5407: CALL_OW 7
// SetSide ( Bobby , you ) ;
5411: LD_EXP 10
5415: PPUSH
5416: LD_EXP 6
5420: PPUSH
5421: CALL_OW 235
// found := found ^ [ Bobby ] ;
5425: LD_ADDR_EXP 28
5429: PUSH
5430: LD_EXP 28
5434: PUSH
5435: LD_EXP 10
5439: PUSH
5440: EMPTY
5441: LIST
5442: ADD
5443: ST_TO_ADDR
// if secondaryobj then
5444: LD_EXP 16
5448: IFFALSE 5476
// if found > 1 then
5450: LD_EXP 28
5454: PUSH
5455: LD_INT 1
5457: GREATER
5458: IFFALSE 5469
// ChangeMissionObjectives ( M2c ) else
5460: LD_STRING M2c
5462: PPUSH
5463: CALL_OW 337
5467: GO 5476
// ChangeMissionObjectives ( M2b ) ;
5469: LD_STRING M2b
5471: PPUSH
5472: CALL_OW 337
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
5476: LD_EXP 10
5480: PPUSH
5481: LD_EXP 8
5485: PPUSH
5486: CALL_OW 250
5490: PPUSH
5491: LD_EXP 8
5495: PPUSH
5496: CALL_OW 251
5500: PPUSH
5501: CALL_OW 111
// Hint ( Selection2 ) ;
5505: LD_STRING Selection2
5507: PPUSH
5508: CALL_OW 339
// Hint ( Healthbar ) ;
5512: LD_STRING Healthbar
5514: PPUSH
5515: CALL_OW 339
// end ;
5519: END
// every 0 0$1 trigger IsInArea ( JMM , valley ) and IsOk ( Bobby ) and ( Bobby in found ) do
5520: LD_EXP 8
5524: PPUSH
5525: LD_INT 5
5527: PPUSH
5528: CALL_OW 308
5532: PUSH
5533: LD_EXP 10
5537: PPUSH
5538: CALL_OW 302
5542: AND
5543: PUSH
5544: LD_EXP 10
5548: PUSH
5549: LD_EXP 28
5553: IN
5554: AND
5555: IFFALSE 5668
5557: GO 5559
5559: DISABLE
// begin if see ( russians , JMM ) or see ( russians , Bobby ) then
5560: LD_EXP 5
5564: PPUSH
5565: LD_EXP 8
5569: PPUSH
5570: CALL_OW 292
5574: PUSH
5575: LD_EXP 5
5579: PPUSH
5580: LD_EXP 10
5584: PPUSH
5585: CALL_OW 292
5589: OR
5590: IFFALSE 5602
// begin wait ( 0 0$2 ) ;
5592: LD_INT 70
5594: PPUSH
5595: CALL_OW 67
// enable ;
5599: ENABLE
// exit ;
5600: GO 5668
// end ; Say ( JMM , D2a-JMM-1 ) ;
5602: LD_EXP 8
5606: PPUSH
5607: LD_STRING D2a-JMM-1
5609: PPUSH
5610: CALL_OW 88
// if GetDistUnits ( JMM , Bobby ) <= 7 then
5614: LD_EXP 8
5618: PPUSH
5619: LD_EXP 10
5623: PPUSH
5624: CALL_OW 296
5628: PUSH
5629: LD_INT 7
5631: LESSEQUAL
5632: IFFALSE 5646
// Say ( Bobby , D2a-Bobby-1 ) ;
5634: LD_EXP 10
5638: PPUSH
5639: LD_STRING D2a-Bobby-1
5641: PPUSH
5642: CALL_OW 88
// if not terrainhint then
5646: LD_EXP 15
5650: NOT
5651: IFFALSE 5668
// begin Hint ( terrain ) ;
5653: LD_STRING terrain
5655: PPUSH
5656: CALL_OW 339
// terrainhint := true ;
5660: LD_ADDR_EXP 15
5664: PUSH
5665: LD_INT 1
5667: ST_TO_ADDR
// end ; end ;
5668: END
// every 0 0$1 trigger IsInArea ( JMM , rmessage ) do var un , nveh ;
5669: LD_EXP 8
5673: PPUSH
5674: LD_INT 8
5676: PPUSH
5677: CALL_OW 308
5681: IFFALSE 6059
5683: GO 5685
5685: DISABLE
5686: LD_INT 0
5688: PPUSH
5689: PPUSH
// begin if see ( russians , JMM ) then
5690: LD_EXP 5
5694: PPUSH
5695: LD_EXP 8
5699: PPUSH
5700: CALL_OW 292
5704: IFFALSE 5709
// begin enable ;
5706: ENABLE
// exit ;
5707: GO 6059
// end ; DialogueOn ;
5709: CALL_OW 6
// SayRadio ( cheater , D4-Rus3-1 ) ;
5713: LD_EXP 12
5717: PPUSH
5718: LD_STRING D4-Rus3-1
5720: PPUSH
5721: CALL_OW 94
// DialogueOff ;
5725: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
5729: LD_STRING M3a
5731: PPUSH
5732: CALL_OW 337
// SetAreaMapShow ( Shw1 , 0 ) ;
5736: LD_INT 12
5738: PPUSH
5739: LD_INT 0
5741: PPUSH
5742: CALL_OW 424
// SetAreaMapShow ( Shw2 , 1 ) ;
5746: LD_INT 13
5748: PPUSH
5749: LD_INT 1
5751: PPUSH
5752: CALL_OW 424
// wait ( 0 0$10 ) ;
5756: LD_INT 350
5758: PPUSH
5759: CALL_OW 67
// DialogueOn ;
5763: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
5767: LD_EXP 11
5771: PPUSH
5772: LD_STRING D4-Pow-1
5774: PPUSH
5775: CALL_OW 94
// if Query ( Q1 ) = 1 then
5779: LD_STRING Q1
5781: PPUSH
5782: CALL_OW 97
5786: PUSH
5787: LD_INT 1
5789: EQUAL
5790: IFFALSE 6038
// begin Say ( JMM , D4a-JMM-1 ) ;
5792: LD_EXP 8
5796: PPUSH
5797: LD_STRING D4a-JMM-1
5799: PPUSH
5800: CALL_OW 88
// spotx := GetX ( JMM ) ;
5804: LD_ADDR_EXP 25
5808: PUSH
5809: LD_EXP 8
5813: PPUSH
5814: CALL_OW 250
5818: ST_TO_ADDR
// spoty := GetY ( JMM ) ;
5819: LD_ADDR_EXP 26
5823: PUSH
5824: LD_EXP 8
5828: PPUSH
5829: CALL_OW 251
5833: ST_TO_ADDR
// ComRemember ( [ rveh2 , rveh3 , rveh4 , rveh5 ] ) ;
5834: LD_INT 39
5836: PUSH
5837: LD_INT 64
5839: PUSH
5840: LD_INT 63
5842: PUSH
5843: LD_INT 61
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 143
// ComAgressiveMove ( [ rveh2 , rveh3 , rveh4 , rveh5 ] , spotx , spoty ) ;
5856: LD_INT 39
5858: PUSH
5859: LD_INT 64
5861: PUSH
5862: LD_INT 63
5864: PUSH
5865: LD_INT 61
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: PPUSH
5874: LD_EXP 25
5878: PPUSH
5879: LD_EXP 26
5883: PPUSH
5884: CALL_OW 114
// DialogueOff ;
5888: CALL_OW 7
// SA_ChatAndRun ;
5892: CALL 8679 0 0
// ChangeMissionObjectives ( M3b ) ;
5896: LD_STRING M3b
5898: PPUSH
5899: CALL_OW 337
// SetAreaMapShow ( Shw1 , 1 ) ;
5903: LD_INT 12
5905: PPUSH
5906: LD_INT 1
5908: PPUSH
5909: CALL_OW 424
// repeat wait ( 0 0$5 ) ;
5913: LD_INT 175
5915: PPUSH
5916: CALL_OW 67
// nveh := 0 ;
5920: LD_ADDR_VAR 0 2
5924: PUSH
5925: LD_INT 0
5927: ST_TO_ADDR
// for un in [ rveh2 , rveh3 , rveh4 , rveh5 ] do
5928: LD_ADDR_VAR 0 1
5932: PUSH
5933: LD_INT 39
5935: PUSH
5936: LD_INT 64
5938: PUSH
5939: LD_INT 63
5941: PUSH
5942: LD_INT 61
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: PUSH
5951: FOR_IN
5952: IFFALSE 5995
// if GetDistUnitXY ( un , spotx , spoty ) < 10 then
5954: LD_VAR 0 1
5958: PPUSH
5959: LD_EXP 25
5963: PPUSH
5964: LD_EXP 26
5968: PPUSH
5969: CALL_OW 297
5973: PUSH
5974: LD_INT 10
5976: LESS
5977: IFFALSE 5993
// nveh := nveh + 1 ;
5979: LD_ADDR_VAR 0 2
5983: PUSH
5984: LD_VAR 0 2
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: ST_TO_ADDR
5993: GO 5951
5995: POP
5996: POP
// until nveh >= 3 ;
5997: LD_VAR 0 2
6001: PUSH
6002: LD_INT 3
6004: GREATEREQUAL
6005: IFFALSE 5913
// wait ( 0 0$20 ) ;
6007: LD_INT 700
6009: PPUSH
6010: CALL_OW 67
// ComReturn ( [ rveh2 , rveh3 , rveh4 , rveh5 ] ) ;
6014: LD_INT 39
6016: PUSH
6017: LD_INT 64
6019: PUSH
6020: LD_INT 63
6022: PUSH
6023: LD_INT 61
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: LIST
6030: LIST
6031: PPUSH
6032: CALL_OW 144
// end else
6036: GO 6059
// begin DialogueOff ;
6038: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
6042: LD_STRING M3b
6044: PPUSH
6045: CALL_OW 337
// SetAreaMapShow ( Shw1 , 1 ) ;
6049: LD_INT 12
6051: PPUSH
6052: LD_INT 1
6054: PPUSH
6055: CALL_OW 424
// end ; end ;
6059: PPOPN 2
6061: END
// every 0 0$3 trigger ( phase >= 3 ) do var i ;
6062: LD_EXP 2
6066: PUSH
6067: LD_INT 3
6069: GREATEREQUAL
6070: IFFALSE 6291
6072: GO 6074
6074: DISABLE
6075: LD_INT 0
6077: PPUSH
// begin for i := 1 to 10 do
6078: LD_ADDR_VAR 0 1
6082: PUSH
6083: DOUBLE
6084: LD_INT 1
6086: DEC
6087: ST_TO_ADDR
6088: LD_INT 10
6090: PUSH
6091: FOR_TO
6092: IFFALSE 6124
// begin if see ( russians , JMM ) then
6094: LD_EXP 5
6098: PPUSH
6099: LD_EXP 8
6103: PPUSH
6104: CALL_OW 292
6108: IFFALSE 6115
// begin enable ;
6110: ENABLE
// exit ;
6111: POP
6112: POP
6113: GO 6291
// end ; wait ( 0 0$1 ) ;
6115: LD_INT 35
6117: PPUSH
6118: CALL_OW 67
// end ;
6122: GO 6091
6124: POP
6125: POP
// DialogueOn ;
6126: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
6130: LD_EXP 11
6134: PPUSH
6135: LD_STRING D3-Pow-1
6137: PPUSH
6138: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
6142: LD_EXP 8
6146: PPUSH
6147: LD_STRING D3-JMM-1
6149: PPUSH
6150: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
6154: LD_EXP 11
6158: PPUSH
6159: LD_STRING D3-Pow-2
6161: PPUSH
6162: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
6166: LD_EXP 8
6170: PPUSH
6171: LD_STRING D3-JMM-2
6173: PPUSH
6174: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
6178: LD_EXP 11
6182: PPUSH
6183: LD_STRING D3-Pow-3
6185: PPUSH
6186: CALL_OW 94
// secondaryobj := true ;
6190: LD_ADDR_EXP 16
6194: PUSH
6195: LD_INT 1
6197: ST_TO_ADDR
// ChangeMissionObjectives ( M2a ) ;
6198: LD_STRING M2a
6200: PPUSH
6201: CALL_OW 337
// if found > 0 then
6205: LD_EXP 28
6209: PUSH
6210: LD_INT 0
6212: GREATER
6213: IFFALSE 6241
// if found > 1 then
6215: LD_EXP 28
6219: PUSH
6220: LD_INT 1
6222: GREATER
6223: IFFALSE 6234
// ChangeMissionObjectives ( M2c ) else
6225: LD_STRING M2c
6227: PPUSH
6228: CALL_OW 337
6232: GO 6241
// ChangeMissionObjectives ( M2b ) ;
6234: LD_STRING M2b
6236: PPUSH
6237: CALL_OW 337
// ChangeMissionObjectives ( M2 ) ;
6241: LD_STRING M2
6243: PPUSH
6244: CALL_OW 337
// SetAreaMapShow ( Shw1 , 1 ) ;
6248: LD_INT 12
6250: PPUSH
6251: LD_INT 1
6253: PPUSH
6254: CALL_OW 424
// DialogueOff ;
6258: CALL_OW 7
// Hint ( crawling ) ;
6262: LD_STRING crawling
6264: PPUSH
6265: CALL_OW 339
// if not terrainhint then
6269: LD_EXP 15
6273: NOT
6274: IFFALSE 6291
// begin Hint ( terrain ) ;
6276: LD_STRING terrain
6278: PPUSH
6279: CALL_OW 339
// terrainhint := true ;
6283: LD_ADDR_EXP 15
6287: PUSH
6288: LD_INT 1
6290: ST_TO_ADDR
// end ; end ; end_of_file
6291: PPOPN 1
6293: END
// every 0 0$0.3 trigger FilterUnitsInArea ( bigtrap , [ [ f_see , russians ] , [ f_side , you ] ] ) do var target ;
6294: LD_INT 7
6296: PPUSH
6297: LD_INT 101
6299: PUSH
6300: LD_EXP 5
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 22
6311: PUSH
6312: LD_EXP 6
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 70
6329: IFFALSE 6470
6331: GO 6333
6333: DISABLE
6334: LD_INT 0
6336: PPUSH
// begin disable ( 33 ) ;
6337: LD_INT 33
6339: DISABLE_MARKED
// ComWalk ( trappers ) ;
6340: LD_EXP 13
6344: PPUSH
6345: CALL_OW 138
// target := FilterUnitsInArea ( bigtrap , [ [ f_see , russians ] , [ f_side , you ] ] ) [ 1 ] ;
6349: LD_ADDR_VAR 0 1
6353: PUSH
6354: LD_INT 7
6356: PPUSH
6357: LD_INT 101
6359: PUSH
6360: LD_EXP 5
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PUSH
6369: LD_INT 22
6371: PUSH
6372: LD_EXP 6
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PPUSH
6385: CALL_OW 70
6389: PUSH
6390: LD_INT 1
6392: ARRAY
6393: ST_TO_ADDR
// AddComAgressiveMove ( trappers ^ [ rveh4 , rveh5 ] , GetX ( target ) , GetY ( target ) ) ;
6394: LD_EXP 13
6398: PUSH
6399: LD_INT 63
6401: PUSH
6402: LD_INT 61
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: ADD
6409: PPUSH
6410: LD_VAR 0 1
6414: PPUSH
6415: CALL_OW 250
6419: PPUSH
6420: LD_VAR 0 1
6424: PPUSH
6425: CALL_OW 251
6429: PPUSH
6430: CALL_OW 174
// wait ( 0 0$1 ) ;
6434: LD_INT 35
6436: PPUSH
6437: CALL_OW 67
// Say ( JMM , D4b-JMM-1 ) ;
6441: LD_EXP 8
6445: PPUSH
6446: LD_STRING D4b-JMM-1
6448: PPUSH
6449: CALL_OW 88
// SetAreaMapShow ( Shw2 , 0 ) ;
6453: LD_INT 13
6455: PPUSH
6456: LD_INT 0
6458: PPUSH
6459: CALL_OW 424
// ChangeMissionObjectives ( M3c ) ;
6463: LD_STRING M3c
6465: PPUSH
6466: CALL_OW 337
// end ;
6470: PPOPN 1
6472: END
// every 0 0$2 trigger IsInArea ( Bobby , TrapEnd ) or IsInArea ( Cyrus , TrapEnd ) or IsInArea ( JMM , TrapEnd ) marked 33 do
6473: LD_EXP 10
6477: PPUSH
6478: LD_INT 14
6480: PPUSH
6481: CALL_OW 308
6485: PUSH
6486: LD_EXP 9
6490: PPUSH
6491: LD_INT 14
6493: PPUSH
6494: CALL_OW 308
6498: OR
6499: PUSH
6500: LD_EXP 8
6504: PPUSH
6505: LD_INT 14
6507: PPUSH
6508: CALL_OW 308
6512: OR
6513: IFFALSE 6547
6515: GO 6517
6517: DISABLE
// begin Say ( JMM , D4b-JMM-1 ) ;
6518: LD_EXP 8
6522: PPUSH
6523: LD_STRING D4b-JMM-1
6525: PPUSH
6526: CALL_OW 88
// SetAreaMapShow ( Shw2 , 0 ) ;
6530: LD_INT 13
6532: PPUSH
6533: LD_INT 0
6535: PPUSH
6536: CALL_OW 424
// ChangeMissionObjectives ( M3c ) ;
6540: LD_STRING M3c
6542: PPUSH
6543: CALL_OW 337
// end ;
6547: END
// every 0 0$5 trigger GetY ( JMM ) < 50 do
6548: LD_EXP 8
6552: PPUSH
6553: CALL_OW 251
6557: PUSH
6558: LD_INT 50
6560: LESS
6561: IFFALSE 6569
6563: GO 6565
6565: DISABLE
// begin disable ( 2 ) ;
6566: LD_INT 2
6568: DISABLE_MARKED
// end ; end_of_file
6569: END
// export saved ; export found ; export guard_seen ; every 0 0$1 do
6570: GO 6572
6572: DISABLE
// begin if not guard_seen then
6573: LD_EXP 29
6577: NOT
6578: IFFALSE 6601
// begin SetLives ( guard , guard_lives [ difficulty ] ) ;
6580: LD_EXP 14
6584: PPUSH
6585: LD_EXP 17
6589: PUSH
6590: LD_OWVAR 67
6594: ARRAY
6595: PPUSH
6596: CALL_OW 234
// enable ;
6600: ENABLE
// end ; end ;
6601: END
// every 0 0$0.5 trigger ( UnitFilter ( guard , [ f_see , you ] ) > 0 ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_see , russians ] ] ) > 0 ) do var cyr , bob ;
6602: LD_EXP 14
6606: PPUSH
6607: LD_INT 101
6609: PUSH
6610: LD_EXP 6
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PPUSH
6619: CALL_OW 72
6623: PUSH
6624: LD_INT 0
6626: GREATER
6627: PUSH
6628: LD_INT 22
6630: PUSH
6631: LD_EXP 6
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: LD_INT 101
6642: PUSH
6643: LD_EXP 5
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PPUSH
6656: CALL_OW 69
6660: PUSH
6661: LD_INT 0
6663: GREATER
6664: AND
6665: IFFALSE 7039
6667: GO 6669
6669: DISABLE
6670: LD_INT 0
6672: PPUSH
6673: PPUSH
// begin guard_seen := true ;
6674: LD_ADDR_EXP 29
6678: PUSH
6679: LD_INT 1
6681: ST_TO_ADDR
// DialogueOn ;
6682: CALL_OW 6
// wait ( 0 0$0.5 ) ;
6686: LD_INT 18
6688: PPUSH
6689: CALL_OW 67
// Say ( guard [ 1 ] , D6-FRus1-1 ) ;
6693: LD_EXP 14
6697: PUSH
6698: LD_INT 1
6700: ARRAY
6701: PPUSH
6702: LD_STRING D6-FRus1-1
6704: PPUSH
6705: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
6709: LD_EXP 8
6713: PPUSH
6714: LD_STRING D6-JMM-1
6716: PPUSH
6717: CALL_OW 88
// cyr := IsOk ( Cyrus ) and GetSide ( Cyrus ) = you and GetDistUnitXY ( Cyrus , 94 , 5 ) <= 25 ;
6721: LD_ADDR_VAR 0 1
6725: PUSH
6726: LD_EXP 9
6730: PPUSH
6731: CALL_OW 302
6735: PUSH
6736: LD_EXP 9
6740: PPUSH
6741: CALL_OW 255
6745: PUSH
6746: LD_EXP 6
6750: EQUAL
6751: AND
6752: PUSH
6753: LD_EXP 9
6757: PPUSH
6758: LD_INT 94
6760: PPUSH
6761: LD_INT 5
6763: PPUSH
6764: CALL_OW 297
6768: PUSH
6769: LD_INT 25
6771: LESSEQUAL
6772: AND
6773: ST_TO_ADDR
// bob := IsOk ( Bobby ) and GetSide ( Bobby ) = you and GetDistUnitXY ( Bobby , 94 , 5 ) <= 25 ;
6774: LD_ADDR_VAR 0 2
6778: PUSH
6779: LD_EXP 10
6783: PPUSH
6784: CALL_OW 302
6788: PUSH
6789: LD_EXP 10
6793: PPUSH
6794: CALL_OW 255
6798: PUSH
6799: LD_EXP 6
6803: EQUAL
6804: AND
6805: PUSH
6806: LD_EXP 10
6810: PPUSH
6811: LD_INT 94
6813: PPUSH
6814: LD_INT 5
6816: PPUSH
6817: CALL_OW 297
6821: PUSH
6822: LD_INT 25
6824: LESSEQUAL
6825: AND
6826: ST_TO_ADDR
// if cyr and bob then
6827: LD_VAR 0 1
6831: PUSH
6832: LD_VAR 0 2
6836: AND
6837: IFFALSE 6874
// begin async ;
6839: ASYNC
// Say ( Cyrus , D6-Cyrus-1 ) ;
6840: LD_EXP 9
6844: PPUSH
6845: LD_STRING D6-Cyrus-1
6847: PPUSH
6848: CALL_OW 88
// sync ;
6852: SYNC
// wait ( 0 0$0.3 ) ;
6853: LD_INT 10
6855: PPUSH
6856: CALL_OW 67
// SayNoFace ( Bobby , D6-Bobby-1 ) ;
6860: LD_EXP 10
6864: PPUSH
6865: LD_STRING D6-Bobby-1
6867: PPUSH
6868: CALL_OW 89
// end else
6872: GO 6906
// if cyr then
6874: LD_VAR 0 1
6878: IFFALSE 6894
// Say ( Cyrus , D6-Cyrus-1 ) else
6880: LD_EXP 9
6884: PPUSH
6885: LD_STRING D6-Cyrus-1
6887: PPUSH
6888: CALL_OW 88
6892: GO 6906
// Say ( Bobby , D6-Bobby-1 ) ;
6894: LD_EXP 10
6898: PPUSH
6899: LD_STRING D6-Bobby-1
6901: PPUSH
6902: CALL_OW 88
// DialogueOff ;
6906: CALL_OW 7
// wait ( final_hunt_wait [ difficulty ] ) ;
6910: LD_EXP 23
6914: PUSH
6915: LD_OWVAR 67
6919: ARRAY
6920: PPUSH
6921: CALL_OW 67
// ComAgressiveMove ( FilterAllUnits ( [ [ f_side , russians ] , [ f_outside ] ] ) diff guard diff trappers , 95 , 12 ) ;
6925: LD_INT 22
6927: PUSH
6928: LD_EXP 5
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: LD_INT 56
6939: PUSH
6940: EMPTY
6941: LIST
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: PPUSH
6947: CALL_OW 69
6951: PUSH
6952: LD_EXP 14
6956: DIFF
6957: PUSH
6958: LD_EXP 13
6962: DIFF
6963: PPUSH
6964: LD_INT 95
6966: PPUSH
6967: LD_INT 12
6969: PPUSH
6970: CALL_OW 114
// ComAgressiveMove ( FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) , 95 , 15 ) ;
6974: LD_INT 22
6976: PUSH
6977: LD_EXP 5
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: PUSH
6986: LD_INT 21
6988: PUSH
6989: LD_INT 2
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PUSH
6996: EMPTY
6997: LIST
6998: LIST
6999: PPUSH
7000: CALL_OW 69
7004: PPUSH
7005: LD_INT 95
7007: PPUSH
7008: LD_INT 15
7010: PPUSH
7011: CALL_OW 114
// ComWalk ( trappers ) ;
7015: LD_EXP 13
7019: PPUSH
7020: CALL_OW 138
// AddComAgressiveMove ( trappers , 91 , 10 ) ;
7024: LD_EXP 13
7028: PPUSH
7029: LD_INT 91
7031: PPUSH
7032: LD_INT 10
7034: PPUSH
7035: CALL_OW 174
// end ;
7039: PPOPN 2
7041: END
// every 0 0$0.5 trigger not UnitFilter ( guard , [ f_ok ] ) do
7042: LD_EXP 14
7046: PPUSH
7047: LD_INT 50
7049: PUSH
7050: EMPTY
7051: LIST
7052: PPUSH
7053: CALL_OW 72
7057: NOT
7058: IFFALSE 7124
7060: GO 7062
7062: DISABLE
// begin enable ( 42 ) ;
7063: LD_INT 42
7065: ENABLE_MARKED
// if ( IsOk ( Cyrus ) and ( Cyrus in found ) ) or ( IsOk ( Bobby ) and ( Bobby in found ) ) then
7066: LD_EXP 9
7070: PPUSH
7071: CALL_OW 302
7075: PUSH
7076: LD_EXP 9
7080: PUSH
7081: LD_EXP 28
7085: IN
7086: AND
7087: PUSH
7088: LD_EXP 10
7092: PPUSH
7093: CALL_OW 302
7097: PUSH
7098: LD_EXP 10
7102: PUSH
7103: LD_EXP 28
7107: IN
7108: AND
7109: OR
7110: IFFALSE 7124
// Say ( JMM , D6a-JMM-1 ) ;
7112: LD_EXP 8
7116: PPUSH
7117: LD_STRING D6a-JMM-1
7119: PPUSH
7120: CALL_OW 88
// end ;
7124: END
// function escaped ( un ) ; begin
7125: LD_INT 0
7127: PPUSH
// if ( GetType ( un ) = unit_vehicle ) then
7128: LD_VAR 0 1
7132: PPUSH
7133: CALL_OW 247
7137: PUSH
7138: LD_INT 2
7140: EQUAL
7141: IFFALSE 7191
// if IsDrivenBy ( un ) then
7143: LD_VAR 0 1
7147: PPUSH
7148: CALL_OW 311
7152: IFFALSE 7189
// begin saved := saved ^ [ IsDrivenBy ( un ) ] ;
7154: LD_ADDR_EXP 27
7158: PUSH
7159: LD_EXP 27
7163: PUSH
7164: LD_VAR 0 1
7168: PPUSH
7169: CALL_OW 311
7173: PUSH
7174: EMPTY
7175: LIST
7176: ADD
7177: ST_TO_ADDR
// RemoveUnit ( un ) ;
7178: LD_VAR 0 1
7182: PPUSH
7183: CALL_OW 64
// end else
7187: GO 7189
// else
7189: GO 7246
// begin saved := saved ^ [ un ] ;
7191: LD_ADDR_EXP 27
7195: PUSH
7196: LD_EXP 27
7200: PUSH
7201: LD_VAR 0 1
7205: PUSH
7206: EMPTY
7207: LIST
7208: ADD
7209: ST_TO_ADDR
// if IsInUnit ( un ) then
7210: LD_VAR 0 1
7214: PPUSH
7215: CALL_OW 310
7219: IFFALSE 7237
// RemoveUnit ( IsInUnit ( un ) ) else
7221: LD_VAR 0 1
7225: PPUSH
7226: CALL_OW 310
7230: PPUSH
7231: CALL_OW 64
7235: GO 7246
// RemoveUnit ( un ) ;
7237: LD_VAR 0 1
7241: PPUSH
7242: CALL_OW 64
// end ; end ;
7246: LD_VAR 0 2
7250: RET
// function ask_for_waiting ; var all , un , escb , leave , cyr , bob ; begin
7251: LD_INT 0
7253: PPUSH
7254: PPUSH
7255: PPUSH
7256: PPUSH
7257: PPUSH
7258: PPUSH
7259: PPUSH
// all := [ ] ;
7260: LD_ADDR_VAR 0 2
7264: PUSH
7265: EMPTY
7266: ST_TO_ADDR
// if ( Bobby in found ) and IsOk ( Bobby ) then
7267: LD_EXP 10
7271: PUSH
7272: LD_EXP 28
7276: IN
7277: PUSH
7278: LD_EXP 10
7282: PPUSH
7283: CALL_OW 302
7287: AND
7288: IFFALSE 7309
// all := all ^ [ Bobby ] ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: LD_VAR 0 2
7299: PUSH
7300: LD_EXP 10
7304: PUSH
7305: EMPTY
7306: LIST
7307: ADD
7308: ST_TO_ADDR
// if ( Cyrus in found ) and IsOk ( Cyrus ) then
7309: LD_EXP 9
7313: PUSH
7314: LD_EXP 28
7318: IN
7319: PUSH
7320: LD_EXP 9
7324: PPUSH
7325: CALL_OW 302
7329: AND
7330: IFFALSE 7351
// all := all ^ [ Cyrus ] ;
7332: LD_ADDR_VAR 0 2
7336: PUSH
7337: LD_VAR 0 2
7341: PUSH
7342: LD_EXP 9
7346: PUSH
7347: EMPTY
7348: LIST
7349: ADD
7350: ST_TO_ADDR
// if all then
7351: LD_VAR 0 2
7355: IFFALSE 7718
// begin escb := [ ] ;
7357: LD_ADDR_VAR 0 4
7361: PUSH
7362: EMPTY
7363: ST_TO_ADDR
// if IsInArea ( Bobby , escapebig ) then
7364: LD_EXP 10
7368: PPUSH
7369: LD_INT 9
7371: PPUSH
7372: CALL_OW 308
7376: IFFALSE 7397
// escb := escb ^ [ Bobby ] ;
7378: LD_ADDR_VAR 0 4
7382: PUSH
7383: LD_VAR 0 4
7387: PUSH
7388: LD_EXP 10
7392: PUSH
7393: EMPTY
7394: LIST
7395: ADD
7396: ST_TO_ADDR
// if IsInArea ( Cyrus , escapebig ) then
7397: LD_EXP 9
7401: PPUSH
7402: LD_INT 9
7404: PPUSH
7405: CALL_OW 308
7409: IFFALSE 7430
// escb := escb ^ [ Cyrus ] ;
7411: LD_ADDR_VAR 0 4
7415: PUSH
7416: LD_VAR 0 4
7420: PUSH
7421: LD_EXP 9
7425: PUSH
7426: EMPTY
7427: LIST
7428: ADD
7429: ST_TO_ADDR
// if all diff escb then
7430: LD_VAR 0 2
7434: PUSH
7435: LD_VAR 0 4
7439: DIFF
7440: IFFALSE 7475
// if ( Query ( Q2 ) = 2 ) then
7442: LD_STRING Q2
7444: PPUSH
7445: CALL_OW 97
7449: PUSH
7450: LD_INT 2
7452: EQUAL
7453: IFFALSE 7465
// leave := true else
7455: LD_ADDR_VAR 0 5
7459: PUSH
7460: LD_INT 1
7462: ST_TO_ADDR
7463: GO 7473
// leave := false else
7465: LD_ADDR_VAR 0 5
7469: PUSH
7470: LD_INT 0
7472: ST_TO_ADDR
7473: GO 7483
// leave := true ;
7475: LD_ADDR_VAR 0 5
7479: PUSH
7480: LD_INT 1
7482: ST_TO_ADDR
// if leave then
7483: LD_VAR 0 5
7487: IFFALSE 7716
// begin if IsInUnit ( JMM ) then
7489: LD_EXP 8
7493: PPUSH
7494: CALL_OW 310
7498: IFFALSE 7516
// escaped ( IsInUnit ( JMM ) ) else
7500: LD_EXP 8
7504: PPUSH
7505: CALL_OW 310
7509: PPUSH
7510: CALL 7125 0 1
7514: GO 7525
// escaped ( JMM ) ;
7516: LD_EXP 8
7520: PPUSH
7521: CALL 7125 0 1
// InGameOn ;
7525: CALL_OW 8
// repeat cyr := IsOk ( Cyrus ) and ( Cyrus in found ) ;
7529: LD_ADDR_VAR 0 6
7533: PUSH
7534: LD_EXP 9
7538: PPUSH
7539: CALL_OW 302
7543: PUSH
7544: LD_EXP 9
7548: PUSH
7549: LD_EXP 28
7553: IN
7554: AND
7555: ST_TO_ADDR
// bob := IsOk ( Bobby ) and ( Bobby in found ) ;
7556: LD_ADDR_VAR 0 7
7560: PUSH
7561: LD_EXP 10
7565: PPUSH
7566: CALL_OW 302
7570: PUSH
7571: LD_EXP 10
7575: PUSH
7576: LD_EXP 28
7580: IN
7581: AND
7582: ST_TO_ADDR
// if cyr then
7583: LD_VAR 0 6
7587: IFFALSE 7604
// ComMoveXY ( Cyrus , 94 , 1 ) ;
7589: LD_EXP 9
7593: PPUSH
7594: LD_INT 94
7596: PPUSH
7597: LD_INT 1
7599: PPUSH
7600: CALL_OW 111
// if bob then
7604: LD_VAR 0 7
7608: IFFALSE 7625
// ComMoveXY ( Bobby , 94 , 1 ) ;
7610: LD_EXP 10
7614: PPUSH
7615: LD_INT 94
7617: PPUSH
7618: LD_INT 1
7620: PPUSH
7621: CALL_OW 111
// wait ( 0 0$1 ) ;
7625: LD_INT 35
7627: PPUSH
7628: CALL_OW 67
// if IsInArea ( Cyrus , escape ) then
7632: LD_EXP 9
7636: PPUSH
7637: LD_INT 10
7639: PPUSH
7640: CALL_OW 308
7644: IFFALSE 7663
// begin escaped ( Cyrus ) ;
7646: LD_EXP 9
7650: PPUSH
7651: CALL 7125 0 1
// cyr := false ;
7655: LD_ADDR_VAR 0 6
7659: PUSH
7660: LD_INT 0
7662: ST_TO_ADDR
// end ; if IsInArea ( Bobby , escape ) then
7663: LD_EXP 10
7667: PPUSH
7668: LD_INT 10
7670: PPUSH
7671: CALL_OW 308
7675: IFFALSE 7694
// begin escaped ( Bobby ) ;
7677: LD_EXP 10
7681: PPUSH
7682: CALL 7125 0 1
// bob := false ;
7686: LD_ADDR_VAR 0 7
7690: PUSH
7691: LD_INT 0
7693: ST_TO_ADDR
// end ; until not cyr and not bob ;
7694: LD_VAR 0 6
7698: NOT
7699: PUSH
7700: LD_VAR 0 7
7704: NOT
7705: AND
7706: IFFALSE 7529
// InGameOff ;
7708: CALL_OW 9
// vitezstvi ;
7712: CALL 8180 0 0
// end ; end else
7716: GO 7758
// begin if IsInUnit ( JMM ) then
7718: LD_EXP 8
7722: PPUSH
7723: CALL_OW 310
7727: IFFALSE 7745
// escaped ( IsInUnit ( JMM ) ) else
7729: LD_EXP 8
7733: PPUSH
7734: CALL_OW 310
7738: PPUSH
7739: CALL 7125 0 1
7743: GO 7754
// escaped ( JMM ) ;
7745: LD_EXP 8
7749: PPUSH
7750: CALL 7125 0 1
// vitezstvi ;
7754: CALL 8180 0 0
// end ; end ;
7758: LD_VAR 0 1
7762: RET
// every 0 0$0.5 trigger IsInArea ( Bobby , escape ) or IsInArea ( Cyrus , escape ) or ( not ( Bobby in found ) or not IsOk ( Bobby ) ) and ( not ( Cyrus in found ) or not IsOk ( Cyrus ) ) do
7763: LD_EXP 10
7767: PPUSH
7768: LD_INT 10
7770: PPUSH
7771: CALL_OW 308
7775: PUSH
7776: LD_EXP 9
7780: PPUSH
7781: LD_INT 10
7783: PPUSH
7784: CALL_OW 308
7788: OR
7789: PUSH
7790: LD_EXP 10
7794: PUSH
7795: LD_EXP 28
7799: IN
7800: NOT
7801: PUSH
7802: LD_EXP 10
7806: PPUSH
7807: CALL_OW 302
7811: NOT
7812: OR
7813: PUSH
7814: LD_EXP 9
7818: PUSH
7819: LD_EXP 28
7823: IN
7824: NOT
7825: PUSH
7826: LD_EXP 9
7830: PPUSH
7831: CALL_OW 302
7835: NOT
7836: OR
7837: AND
7838: OR
7839: IFFALSE 7978
7841: GO 7843
7843: DISABLE
// begin if IsInArea ( Bobby , escape ) then
7844: LD_EXP 10
7848: PPUSH
7849: LD_INT 10
7851: PPUSH
7852: CALL_OW 308
7856: IFFALSE 7867
// escaped ( Bobby ) ;
7858: LD_EXP 10
7862: PPUSH
7863: CALL 7125 0 1
// if IsInArea ( Cyrus , escape ) then
7867: LD_EXP 9
7871: PPUSH
7872: LD_INT 10
7874: PPUSH
7875: CALL_OW 308
7879: IFFALSE 7890
// escaped ( Cyrus ) ;
7881: LD_EXP 9
7885: PPUSH
7886: CALL 7125 0 1
// if IsInArea ( JMM , escape ) and IsOk ( JMM ) then
7890: LD_EXP 8
7894: PPUSH
7895: LD_INT 10
7897: PPUSH
7898: CALL_OW 308
7902: PUSH
7903: LD_EXP 8
7907: PPUSH
7908: CALL_OW 302
7912: AND
7913: IFFALSE 7921
// ask_for_waiting else
7915: CALL 7251 0 0
7919: GO 7977
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_ok ] ] ) and ( JMM in saved ) then
7921: LD_INT 22
7923: PUSH
7924: LD_EXP 6
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PUSH
7933: LD_INT 21
7935: PUSH
7936: LD_INT 1
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PUSH
7943: LD_INT 50
7945: PUSH
7946: EMPTY
7947: LIST
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: LIST
7953: PPUSH
7954: CALL_OW 69
7958: NOT
7959: PUSH
7960: LD_EXP 8
7964: PUSH
7965: LD_EXP 27
7969: IN
7970: AND
7971: IFFALSE 7977
// vitezstvi ;
7973: CALL 8180 0 0
// enable ;
7977: ENABLE
// end ;
7978: END
// every 0 0$0.7 trigger IsInArea ( JMM , escape ) and IsOk ( JMM ) marked 42 do
7979: LD_EXP 8
7983: PPUSH
7984: LD_INT 10
7986: PPUSH
7987: CALL_OW 308
7991: PUSH
7992: LD_EXP 8
7996: PPUSH
7997: CALL_OW 302
8001: AND
8002: IFFALSE 8179
8004: GO 8006
8006: DISABLE
// begin ask_for_waiting ;
8007: CALL 7251 0 0
// if not JMM in saved then
8011: LD_EXP 8
8015: PUSH
8016: LD_EXP 27
8020: IN
8021: NOT
8022: IFFALSE 8179
// begin repeat wait ( 0 0$0.7 ) ;
8024: LD_INT 24
8026: PPUSH
8027: CALL_OW 67
// if ( not ( Cyrus in found ) or not IsOk ( Cyrus ) or IsInArea ( Cyrus , escapebig ) ) and ( not ( Bobby in found ) or not IsOk ( Bobby ) or IsInArea ( Bobby , escapebig ) ) and IsOk ( JMM ) then
8031: LD_EXP 9
8035: PUSH
8036: LD_EXP 28
8040: IN
8041: NOT
8042: PUSH
8043: LD_EXP 9
8047: PPUSH
8048: CALL_OW 302
8052: NOT
8053: OR
8054: PUSH
8055: LD_EXP 9
8059: PPUSH
8060: LD_INT 9
8062: PPUSH
8063: CALL_OW 308
8067: OR
8068: PUSH
8069: LD_EXP 10
8073: PUSH
8074: LD_EXP 28
8078: IN
8079: NOT
8080: PUSH
8081: LD_EXP 10
8085: PPUSH
8086: CALL_OW 302
8090: NOT
8091: OR
8092: PUSH
8093: LD_EXP 10
8097: PPUSH
8098: LD_INT 9
8100: PPUSH
8101: CALL_OW 308
8105: OR
8106: AND
8107: PUSH
8108: LD_EXP 8
8112: PPUSH
8113: CALL_OW 302
8117: AND
8118: IFFALSE 8124
// ask_for_waiting ;
8120: CALL 7251 0 0
// until ( JMM in saved ) or not IsInArea ( JMM , escape ) or not IsOk ( JMM ) ;
8124: LD_EXP 8
8128: PUSH
8129: LD_EXP 27
8133: IN
8134: PUSH
8135: LD_EXP 8
8139: PPUSH
8140: LD_INT 10
8142: PPUSH
8143: CALL_OW 308
8147: NOT
8148: OR
8149: PUSH
8150: LD_EXP 8
8154: PPUSH
8155: CALL_OW 302
8159: NOT
8160: OR
8161: IFFALSE 8024
// if not IsInArea ( JMM , escape ) then
8163: LD_EXP 8
8167: PPUSH
8168: LD_INT 10
8170: PPUSH
8171: CALL_OW 308
8175: NOT
8176: IFFALSE 8179
// enable ;
8178: ENABLE
// end ; end ;
8179: END
// function vitezstvi ; var medal1 , medal2 , medal3 ; begin
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
// wait ( 0 0$1 ) ;
8186: LD_INT 35
8188: PPUSH
8189: CALL_OW 67
// AddMedal ( JMM , 1 ) ;
8193: LD_STRING JMM
8195: PPUSH
8196: LD_INT 1
8198: PPUSH
8199: CALL_OW 101
// medal1 := true ;
8203: LD_ADDR_VAR 0 2
8207: PUSH
8208: LD_INT 1
8210: ST_TO_ADDR
// medal2 := false ;
8211: LD_ADDR_VAR 0 3
8215: PUSH
8216: LD_INT 0
8218: ST_TO_ADDR
// medal3 := false ;
8219: LD_ADDR_VAR 0 4
8223: PUSH
8224: LD_INT 0
8226: ST_TO_ADDR
// if Bobby in saved then
8227: LD_EXP 10
8231: PUSH
8232: LD_EXP 27
8236: IN
8237: IFFALSE 8259
// begin AddMedal ( Bobby , 1 ) ;
8239: LD_STRING Bobby
8241: PPUSH
8242: LD_INT 1
8244: PPUSH
8245: CALL_OW 101
// medal2 := true ;
8249: LD_ADDR_VAR 0 3
8253: PUSH
8254: LD_INT 1
8256: ST_TO_ADDR
// end else
8257: GO 8295
// if Bobby in found then
8259: LD_EXP 10
8263: PUSH
8264: LD_EXP 28
8268: IN
8269: IFFALSE 8284
// AddMedal ( Bobby , - 2 ) else
8271: LD_STRING Bobby
8273: PPUSH
8274: LD_INT 2
8276: NEG
8277: PPUSH
8278: CALL_OW 101
8282: GO 8295
// AddMedal ( Bobby , - 1 ) ;
8284: LD_STRING Bobby
8286: PPUSH
8287: LD_INT 1
8289: NEG
8290: PPUSH
8291: CALL_OW 101
// if Cyrus in saved then
8295: LD_EXP 9
8299: PUSH
8300: LD_EXP 27
8304: IN
8305: IFFALSE 8327
// begin AddMedal ( Cyrus , 1 ) ;
8307: LD_STRING Cyrus
8309: PPUSH
8310: LD_INT 1
8312: PPUSH
8313: CALL_OW 101
// medal3 := true ;
8317: LD_ADDR_VAR 0 4
8321: PUSH
8322: LD_INT 1
8324: ST_TO_ADDR
// end else
8325: GO 8363
// if Cyrus in found then
8327: LD_EXP 9
8331: PUSH
8332: LD_EXP 28
8336: IN
8337: IFFALSE 8352
// AddMedal ( Cyrus , - 2 ) else
8339: LD_STRING Cyrus
8341: PPUSH
8342: LD_INT 2
8344: NEG
8345: PPUSH
8346: CALL_OW 101
8350: GO 8363
// AddMedal ( Cyrus , - 1 ) ;
8352: LD_STRING Cyrus
8354: PPUSH
8355: LD_INT 1
8357: NEG
8358: PPUSH
8359: CALL_OW 101
// if not Bobby in saved then
8363: LD_EXP 10
8367: PUSH
8368: LD_EXP 27
8372: IN
8373: NOT
8374: IFFALSE 8388
// SetLives ( Bobby , 0 ) ;
8376: LD_EXP 10
8380: PPUSH
8381: LD_INT 0
8383: PPUSH
8384: CALL_OW 234
// if not Cyrus in saved then
8388: LD_EXP 9
8392: PUSH
8393: LD_EXP 27
8397: IN
8398: NOT
8399: IFFALSE 8413
// SetLives ( Cyrus , 0 ) ;
8401: LD_EXP 9
8405: PPUSH
8406: LD_INT 0
8408: PPUSH
8409: CALL_OW 234
// if not medal2 and not medal3 then
8413: LD_VAR 0 3
8417: NOT
8418: PUSH
8419: LD_VAR 0 4
8423: NOT
8424: AND
8425: IFFALSE 8431
// SA_NoOneSave ;
8427: CALL 8649 0 0
// SA_EndMission ( 1 , 1 , medal1 , medal2 , medal3 ) ;
8431: LD_INT 1
8433: PPUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_VAR 0 2
8441: PPUSH
8442: LD_VAR 0 3
8446: PPUSH
8447: LD_VAR 0 4
8451: PPUSH
8452: CALL 8732 0 5
// GiveMedals ( MAIN ) ;
8456: LD_STRING MAIN
8458: PPUSH
8459: CALL_OW 102
// RewardPeople ( JMM union saved ) ;
8463: LD_EXP 8
8467: PUSH
8468: LD_EXP 27
8472: UNION
8473: PPUSH
8474: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
8478: LD_EXP 8
8482: PPUSH
8483: LD_STRING JMM
8485: PPUSH
8486: CALL_OW 38
// SaveCharacters ( Bobby , Bobby ) ;
8490: LD_EXP 10
8494: PPUSH
8495: LD_STRING Bobby
8497: PPUSH
8498: CALL_OW 38
// SaveCharacters ( Cyrus , Cyrus ) ;
8502: LD_EXP 9
8506: PPUSH
8507: LD_STRING Cyrus
8509: PPUSH
8510: CALL_OW 38
// savevariable ( getlives ( bobby ) , lives_bobby ) ;
8514: LD_EXP 10
8518: PPUSH
8519: CALL_OW 256
8523: PPUSH
8524: LD_STRING lives_bobby
8526: PPUSH
8527: CALL_OW 39
// savevariable ( getlives ( cyrus ) , lives_cyrus ) ;
8531: LD_EXP 9
8535: PPUSH
8536: CALL_OW 256
8540: PPUSH
8541: LD_STRING lives_cyrus
8543: PPUSH
8544: CALL_OW 39
// savevariable ( getlives ( jmm ) , lives_jmm ) ;
8548: LD_EXP 8
8552: PPUSH
8553: CALL_OW 256
8557: PPUSH
8558: LD_STRING lives_jmm
8560: PPUSH
8561: CALL_OW 39
// if not demo then
8565: LD_EXP 4
8569: NOT
8570: IFFALSE 8578
// YouWin else
8572: CALL_OW 103
8576: GO 8588
// ChangeMap ( 1 , __Am\04demo ) ;
8578: LD_INT 1
8580: PPUSH
8581: LD_STRING __Am\04demo
8583: PPUSH
8584: CALL_OW 340
// end ;
8588: LD_VAR 0 1
8592: RET
// on UnitGoesToRed ( un ) do begin if un = JMM then
8593: LD_VAR 0 1
8597: PUSH
8598: LD_EXP 8
8602: EQUAL
8603: IFFALSE 8633
// begin if JMM in saved then
8605: LD_EXP 8
8609: PUSH
8610: LD_EXP 27
8614: IN
8615: IFFALSE 8619
// exit ;
8617: GO 8633
// wait ( 0 0$3 ) ;
8619: LD_INT 105
8621: PPUSH
8622: CALL_OW 67
// YouLost ( JMM ) ;
8626: LD_STRING JMM
8628: PPUSH
8629: CALL_OW 104
// end ; end ;
8633: PPOPN 1
8635: END
// on UnitDestroyed ( un ) do begin un := un ;
8636: LD_ADDR_VAR 0 1
8640: PUSH
8641: LD_VAR 0 1
8645: ST_TO_ADDR
// end ; end_of_file
8646: PPOPN 1
8648: END
// export function SA_NoOneSave ; begin
8649: LD_INT 0
8651: PPUSH
// SetAchievement ( ACH_EMH ) ;
8652: LD_STRING ACH_EMH
8654: PPUSH
8655: CALL_OW 543
// end ;
8659: LD_VAR 0 1
8663: RET
// export function SA_CaptureTank ; begin
8664: LD_INT 0
8666: PPUSH
// SetAchievement ( ACH_CMD ) ;
8667: LD_STRING ACH_CMD
8669: PPUSH
8670: CALL_OW 543
// end ;
8674: LD_VAR 0 1
8678: RET
// export function SA_ChatAndRun ; begin
8679: LD_INT 0
8681: PPUSH
// SetAchievement ( ACH_CAR ) ;
8682: LD_STRING ACH_CAR
8684: PPUSH
8685: CALL_OW 543
// end ;
8689: LD_VAR 0 1
8693: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
8694: LD_INT 22
8696: PUSH
8697: LD_INT 1
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: LD_INT 21
8706: PUSH
8707: LD_INT 2
8709: PUSH
8710: EMPTY
8711: LIST
8712: LIST
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PPUSH
8718: CALL_OW 69
8722: IFFALSE 8731
8724: GO 8726
8726: DISABLE
// begin SA_CaptureTank ;
8727: CALL 8664 0 0
// end ; end_of_file
8731: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
8732: LD_INT 0
8734: PPUSH
8735: PPUSH
// if not missionNumber then
8736: LD_VAR 0 2
8740: NOT
8741: IFFALSE 8745
// exit ;
8743: GO 8875
// achiv := false ;
8745: LD_ADDR_VAR 0 7
8749: PUSH
8750: LD_INT 0
8752: ST_TO_ADDR
// case campaignNumber of 1 :
8753: LD_VAR 0 1
8757: PUSH
8758: LD_INT 1
8760: DOUBLE
8761: EQUAL
8762: IFTRUE 8766
8764: GO 8777
8766: POP
// achiv := ACH_GOTA ; 2 :
8767: LD_ADDR_VAR 0 7
8771: PUSH
8772: LD_STRING ACH_GOTA
8774: ST_TO_ADDR
8775: GO 8827
8777: LD_INT 2
8779: DOUBLE
8780: EQUAL
8781: IFTRUE 8785
8783: GO 8788
8785: POP
// ; 3 :
8786: GO 8827
8788: LD_INT 3
8790: DOUBLE
8791: EQUAL
8792: IFTRUE 8796
8794: GO 8807
8796: POP
// achiv := ACH_MOTSU ; 4 :
8797: LD_ADDR_VAR 0 7
8801: PUSH
8802: LD_STRING ACH_MOTSU
8804: ST_TO_ADDR
8805: GO 8827
8807: LD_INT 4
8809: DOUBLE
8810: EQUAL
8811: IFTRUE 8815
8813: GO 8826
8815: POP
// achiv := ACH_LOP ; end ;
8816: LD_ADDR_VAR 0 7
8820: PUSH
8821: LD_STRING ACH_LOP
8823: ST_TO_ADDR
8824: GO 8827
8826: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
8827: LD_OWVAR 67
8831: PUSH
8832: LD_INT 3
8834: EQUAL
8835: PUSH
8836: LD_VAR 0 7
8840: AND
8841: PUSH
8842: LD_VAR 0 3
8846: AND
8847: PUSH
8848: LD_VAR 0 4
8852: AND
8853: PUSH
8854: LD_VAR 0 5
8858: AND
8859: IFFALSE 8875
// SetAchievementEX ( achiv , missionNumber ) ;
8861: LD_VAR 0 7
8865: PPUSH
8866: LD_VAR 0 2
8870: PPUSH
8871: CALL_OW 564
// end ;
8875: LD_VAR 0 6
8879: RET
// export function SA_BehemothConstructed ; begin
8880: LD_INT 0
8882: PPUSH
// SetAchievement ( ACH_SMC ) ;
8883: LD_STRING ACH_SMC
8885: PPUSH
8886: CALL_OW 543
// end ;
8890: LD_VAR 0 1
8894: RET

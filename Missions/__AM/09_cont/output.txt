// export arabi_time ; export utocit ; export last_attack ; export testing ; export lev ; export rusaci_pred_koncem ; function f_testing ; begin
   0: LD_INT 0
   2: PPUSH
// utocit := true ;
   3: LD_ADDR_EXP 2
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// last_attack := true ;
  11: LD_ADDR_EXP 3
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabi_time := 0 ;
  19: LD_ADDR_EXP 1
  23: PUSH
  24: LD_INT 0
  26: ST_TO_ADDR
// testing := false ;
  27: LD_ADDR_EXP 4
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// timer := 3 3$0 ;
  35: LD_ADDR_EXP 62
  39: PUSH
  40: LD_INT 6300
  42: ST_TO_ADDR
// rusaci_pred_koncem := 0 0$20 ;
  43: LD_ADDR_EXP 6
  47: PUSH
  48: LD_INT 700
  50: ST_TO_ADDR
// if not utocit or not last_attack or arabi_time <> 0 then
  51: LD_EXP 2
  55: NOT
  56: PUSH
  57: LD_EXP 3
  61: NOT
  62: OR
  63: PUSH
  64: LD_EXP 1
  68: PUSH
  69: LD_INT 0
  71: NONEQUAL
  72: OR
  73: IFFALSE 90
// begin Msg ( testing version ) ;
  75: LD_STRING testing version
  77: PPUSH
  78: CALL_OW 100
// testing := true ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_INT 1
  89: ST_TO_ADDR
// end ; end ;
  90: LD_VAR 0 1
  94: RET
// every 2 2$0 do
  95: GO 97
  97: DISABLE
// begin end ;
  98: END
// export map_size_x , map_size_y ; export mhmg , mgg , mg , mrl , hgg , hrl , hhg ; export Powell , JMM , Bobby , Cyrus , Donaldson , Brown , Gary ; export FSol1 , Sol1 , Sci1 ; export Eng1 , Eng2 , Eng3 , Eng4 , CarE1 ; export Mec1 , Mec2 , Mec3 , Car1 , Car2 , Car3 ; export Aqr1 , Aqr2 ; export Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 , arabi ; export you , you2 , russians , arabians ; export otherG2 , other_survivors ; export SikorskiDiedIn8 ; export ByloSiberitu ; export EndSiberit ; export PoskytnouInformace ; export NastvalPowella ; export lidi , lidi_base , lidi_eng ; export neco_rikaji ; export timer , TimerEnable ; export counter_time ; export dialog2byl ; export KolikMaBytSiberitu ; export rudepot1 , rumine1 , depot1 ; function load_units_2 ; var kolik , m , n , i , all , k , placing , o ; begin
  99: LD_INT 0
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// InitUc ;
 110: CALL_OW 18
// InitHc ;
 114: CALL_OW 19
// InitVc ;
 118: CALL_OW 20
// kolik := 0 ;
 122: LD_ADDR_VAR 0 2
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// Donaldson := 0 ;
 130: LD_ADDR_EXP 20
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// Brown := 0 ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// Bobby := 0 ;
 146: LD_ADDR_EXP 18
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// Cyrus := 0 ;
 154: LD_ADDR_EXP 19
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// uc_side := you ;
 162: LD_ADDR_OWVAR 20
 166: PUSH
 167: LD_EXP 47
 171: ST_TO_ADDR
// uc_nation := nation_american ;
 172: LD_ADDR_OWVAR 21
 176: PUSH
 177: LD_INT 1
 179: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_STRING JMM
 187: PPUSH
 188: CALL_OW 34
 192: ST_TO_ADDR
// SetClass ( JMM , class_soldier ) ;
 193: LD_EXP 17
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 336
// Powell := NewCharacter ( Powell ) ;
 205: LD_ADDR_EXP 16
 209: PUSH
 210: LD_STRING Powell
 212: PPUSH
 213: CALL_OW 25
 217: ST_TO_ADDR
// uc_side := you2 ;
 218: LD_ADDR_OWVAR 20
 222: PUSH
 223: LD_EXP 48
 227: ST_TO_ADDR
// uc_nation := nation_american ;
 228: LD_ADDR_OWVAR 21
 232: PUSH
 233: LD_INT 1
 235: ST_TO_ADDR
// all := [ ] ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: EMPTY
 242: ST_TO_ADDR
// Gary := NewCharacter ( Gary ) ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_STRING Gary
 250: PPUSH
 251: CALL_OW 25
 255: ST_TO_ADDR
// all := all ^ [ Gary ] ;
 256: LD_ADDR_VAR 0 6
 260: PUSH
 261: LD_VAR 0 6
 265: PUSH
 266: LD_EXP 22
 270: PUSH
 271: EMPTY
 272: LIST
 273: ADD
 274: ST_TO_ADDR
// Cyrus := 0 ;
 275: LD_ADDR_EXP 19
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 283: LD_STRING Cyrus
 285: PPUSH
 286: CALL_OW 29
 290: IFFALSE 366
// if LoadVariable ( CyrusLoc , 1 ) = 1 then
 292: LD_STRING CyrusLoc
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: CALL_OW 30
 302: PUSH
 303: LD_INT 1
 305: EQUAL
 306: IFFALSE 366
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 308: LD_ADDR_EXP 19
 312: PUSH
 313: LD_STRING Cyrus
 315: PPUSH
 316: CALL_OW 34
 320: ST_TO_ADDR
// SetClass ( Cyrus , class_soldier ) ;
 321: LD_EXP 19
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 336
// all := all ^ [ Cyrus ] ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_VAR 0 6
 342: PUSH
 343: LD_EXP 19
 347: PUSH
 348: EMPTY
 349: LIST
 350: ADD
 351: ST_TO_ADDR
// kolik := kolik + 1 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 1
 364: PLUS
 365: ST_TO_ADDR
// end ; Bobby := 0 ;
 366: LD_ADDR_EXP 18
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 374: LD_STRING Bobby
 376: PPUSH
 377: CALL_OW 29
 381: IFFALSE 457
// if LoadVariable ( BobbyLoc , 1 ) = 1 then
 383: LD_STRING BobbyLoc
 385: PPUSH
 386: LD_INT 1
 388: PPUSH
 389: CALL_OW 30
 393: PUSH
 394: LD_INT 1
 396: EQUAL
 397: IFFALSE 457
// begin Bobby := CreateCharacter ( Bobby ) ;
 399: LD_ADDR_EXP 18
 403: PUSH
 404: LD_STRING Bobby
 406: PPUSH
 407: CALL_OW 34
 411: ST_TO_ADDR
// SetClass ( Bobby , class_soldier ) ;
 412: LD_EXP 18
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL_OW 336
// all := all ^ [ Bobby ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 6
 433: PUSH
 434: LD_EXP 18
 438: PUSH
 439: EMPTY
 440: LIST
 441: ADD
 442: ST_TO_ADDR
// kolik := kolik + 1 ;
 443: LD_ADDR_VAR 0 2
 447: PUSH
 448: LD_VAR 0 2
 452: PUSH
 453: LD_INT 1
 455: PLUS
 456: ST_TO_ADDR
// end ; Donaldson := 0 ;
 457: LD_ADDR_EXP 20
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 465: LD_STRING Donaldson
 467: PPUSH
 468: CALL_OW 29
 472: IFFALSE 536
// if LoadVariable ( DonaldsonLoc , 0 ) = 1 then
 474: LD_STRING DonaldsonLoc
 476: PPUSH
 477: LD_INT 0
 479: PPUSH
 480: CALL_OW 30
 484: PUSH
 485: LD_INT 1
 487: EQUAL
 488: IFFALSE 536
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 490: LD_ADDR_EXP 20
 494: PUSH
 495: LD_STRING Donaldson
 497: PPUSH
 498: CALL_OW 34
 502: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 503: LD_ADDR_VAR 0 6
 507: PUSH
 508: LD_VAR 0 6
 512: PUSH
 513: LD_EXP 20
 517: PUSH
 518: EMPTY
 519: LIST
 520: ADD
 521: ST_TO_ADDR
// kolik := kolik + 1 ;
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: LD_VAR 0 2
 531: PUSH
 532: LD_INT 1
 534: PLUS
 535: ST_TO_ADDR
// end ; Brown := 0 ;
 536: LD_ADDR_EXP 21
 540: PUSH
 541: LD_INT 0
 543: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 544: LD_STRING Brown
 546: PPUSH
 547: CALL_OW 29
 551: IFFALSE 625
// if kolik < 3 and LoadVariable ( BrownLoc , 0 ) = 1 then
 553: LD_VAR 0 2
 557: PUSH
 558: LD_INT 3
 560: LESS
 561: PUSH
 562: LD_STRING BrownLoc
 564: PPUSH
 565: LD_INT 0
 567: PPUSH
 568: CALL_OW 30
 572: PUSH
 573: LD_INT 1
 575: EQUAL
 576: AND
 577: IFFALSE 625
// begin Brown := CreateCharacter ( Brown ) ;
 579: LD_ADDR_EXP 21
 583: PUSH
 584: LD_STRING Brown
 586: PPUSH
 587: CALL_OW 34
 591: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 592: LD_ADDR_VAR 0 6
 596: PUSH
 597: LD_VAR 0 6
 601: PUSH
 602: LD_EXP 21
 606: PUSH
 607: EMPTY
 608: LIST
 609: ADD
 610: ST_TO_ADDR
// kolik := kolik + 1 ;
 611: LD_ADDR_VAR 0 2
 615: PUSH
 616: LD_VAR 0 2
 620: PUSH
 621: LD_INT 1
 623: PLUS
 624: ST_TO_ADDR
// end ; neco_rikaji := [ JMM , Gary , Cyrus , Bobby ] diff 0 ;
 625: LD_ADDR_EXP 61
 629: PUSH
 630: LD_EXP 17
 634: PUSH
 635: LD_EXP 22
 639: PUSH
 640: LD_EXP 19
 644: PUSH
 645: LD_EXP 18
 649: PUSH
 650: EMPTY
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PUSH
 656: LD_INT 0
 658: DIFF
 659: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 660: LD_STRING other_survivors
 662: PPUSH
 663: CALL_OW 28
 667: IFFALSE 682
// other_survivors := CreateCharacterSet ( other_survivors ) ;
 669: LD_ADDR_EXP 52
 673: PUSH
 674: LD_STRING other_survivors
 676: PPUSH
 677: CALL_OW 31
 681: ST_TO_ADDR
// for i := ( all + 0 ) to 6 do
 682: LD_ADDR_VAR 0 5
 686: PUSH
 687: DOUBLE
 688: LD_VAR 0 6
 692: PUSH
 693: LD_INT 0
 695: PLUS
 696: DEC
 697: ST_TO_ADDR
 698: LD_INT 6
 700: PUSH
 701: FOR_TO
 702: IFFALSE 752
// begin if other_survivors then
 704: LD_EXP 52
 708: IFFALSE 750
// begin all := all ^ other_survivors [ 1 ] ;
 710: LD_ADDR_VAR 0 6
 714: PUSH
 715: LD_VAR 0 6
 719: PUSH
 720: LD_EXP 52
 724: PUSH
 725: LD_INT 1
 727: ARRAY
 728: ADD
 729: ST_TO_ADDR
// other_survivors := other_survivors diff other_survivors [ 1 ] ;
 730: LD_ADDR_EXP 52
 734: PUSH
 735: LD_EXP 52
 739: PUSH
 740: LD_EXP 52
 744: PUSH
 745: LD_INT 1
 747: ARRAY
 748: DIFF
 749: ST_TO_ADDR
// end ; end ;
 750: GO 701
 752: POP
 753: POP
// for i := ( all + 0 ) to 6 do
 754: LD_ADDR_VAR 0 5
 758: PUSH
 759: DOUBLE
 760: LD_VAR 0 6
 764: PUSH
 765: LD_INT 0
 767: PLUS
 768: DEC
 769: ST_TO_ADDR
 770: LD_INT 6
 772: PUSH
 773: FOR_TO
 774: IFFALSE 804
// begin PrepareSoldier ( 0 , 5 ) ;
 776: LD_INT 0
 778: PPUSH
 779: LD_INT 5
 781: PPUSH
 782: CALL_OW 381
// all := all ^ CreateHuman ;
 786: LD_ADDR_VAR 0 6
 790: PUSH
 791: LD_VAR 0 6
 795: PUSH
 796: CALL_OW 44
 800: ADD
 801: ST_TO_ADDR
// end ;
 802: GO 773
 804: POP
 805: POP
// PrepareScientist ( sex_male , 5 ) ;
 806: LD_INT 1
 808: PPUSH
 809: LD_INT 5
 811: PPUSH
 812: CALL_OW 384
// Sci1 := CreateHuman ;
 816: LD_ADDR_EXP 25
 820: PUSH
 821: CALL_OW 44
 825: ST_TO_ADDR
// all := all ^ Sci1 ;
 826: LD_ADDR_VAR 0 6
 830: PUSH
 831: LD_VAR 0 6
 835: PUSH
 836: LD_EXP 25
 840: ADD
 841: ST_TO_ADDR
// placing := [ [ 93 , 87 ] , [ 96 , 95 ] , [ 90 , 94 ] ] ;
 842: LD_ADDR_VAR 0 8
 846: PUSH
 847: LD_INT 93
 849: PUSH
 850: LD_INT 87
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: PUSH
 857: LD_INT 96
 859: PUSH
 860: LD_INT 95
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PUSH
 867: LD_INT 90
 869: PUSH
 870: LD_INT 94
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: ST_TO_ADDR
// for k in all do
 882: LD_ADDR_VAR 0 7
 886: PUSH
 887: LD_VAR 0 6
 891: PUSH
 892: FOR_IN
 893: IFFALSE 996
// begin o := Rand ( 1 , 3 ) ;
 895: LD_ADDR_VAR 0 9
 899: PUSH
 900: LD_INT 1
 902: PPUSH
 903: LD_INT 3
 905: PPUSH
 906: CALL_OW 12
 910: ST_TO_ADDR
// if GetClass ( k ) = classtype_scientist then
 911: LD_VAR 0 7
 915: PPUSH
 916: CALL_OW 257
 920: PUSH
 921: LD_INT 4
 923: EQUAL
 924: IFFALSE 949
// PlaceUnitXYR ( k , 89 , 84 , 3 , false ) else
 926: LD_VAR 0 7
 930: PPUSH
 931: LD_INT 89
 933: PPUSH
 934: LD_INT 84
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 0
 942: PPUSH
 943: CALL_OW 50
 947: GO 994
// PlaceUnitXYR ( k , placing [ o ] [ 1 ] , placing [ o ] [ 2 ] , 5 , false ) ;
 949: LD_VAR 0 7
 953: PPUSH
 954: LD_VAR 0 8
 958: PUSH
 959: LD_VAR 0 9
 963: ARRAY
 964: PUSH
 965: LD_INT 1
 967: ARRAY
 968: PPUSH
 969: LD_VAR 0 8
 973: PUSH
 974: LD_VAR 0 9
 978: ARRAY
 979: PUSH
 980: LD_INT 2
 982: ARRAY
 983: PPUSH
 984: LD_INT 5
 986: PPUSH
 987: LD_INT 0
 989: PPUSH
 990: CALL_OW 50
// end ;
 994: GO 892
 996: POP
 997: POP
// full_forts ( [ fort1 , fort2 , fort3 ] , UnitFilter ( all , [ [ f_class , class_soldier ] ] ) ) ;
 998: LD_INT 21
1000: PUSH
1001: LD_INT 28
1003: PUSH
1004: LD_INT 86
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: LIST
1011: PPUSH
1012: LD_VAR 0 6
1016: PPUSH
1017: LD_INT 25
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL_OW 72
1034: PPUSH
1035: CALL 12687 0 2
// lidi_base := all ;
1039: LD_ADDR_EXP 59
1043: PUSH
1044: LD_VAR 0 6
1048: ST_TO_ADDR
// lidi := lidi union lidi_base ;
1049: LD_ADDR_EXP 58
1053: PUSH
1054: LD_EXP 58
1058: PUSH
1059: LD_EXP 59
1063: UNION
1064: ST_TO_ADDR
// lidi := lidi ^ JMM ;
1065: LD_ADDR_EXP 58
1069: PUSH
1070: LD_EXP 58
1074: PUSH
1075: LD_EXP 17
1079: ADD
1080: ST_TO_ADDR
// DeleteVariable ( Delta ) ;
1081: LD_STRING Delta
1083: PPUSH
1084: CALL_OW 41
// DeleteCharacters ( Sikorski ) ;
1088: LD_STRING Sikorski
1090: PPUSH
1091: CALL_OW 40
// end ;
1095: LD_VAR 0 1
1099: RET
// function SetDifficulty ; begin
1100: LD_INT 0
1102: PPUSH
// KolikMaBytSiberitu := 60 ;
1103: LD_ADDR_EXP 66
1107: PUSH
1108: LD_INT 60
1110: ST_TO_ADDR
// EndSiberit := [ 150 , 200 , 250 ] [ difficulty ] ;
1111: LD_ADDR_EXP 55
1115: PUSH
1116: LD_INT 150
1118: PUSH
1119: LD_INT 200
1121: PUSH
1122: LD_INT 250
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_OWVAR 67
1134: ARRAY
1135: ST_TO_ADDR
// lev := [ 3 , 5 , 7 ] ;
1136: LD_ADDR_EXP 5
1140: PUSH
1141: LD_INT 3
1143: PUSH
1144: LD_INT 5
1146: PUSH
1147: LD_INT 7
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: ST_TO_ADDR
// end ;
1155: LD_VAR 0 1
1159: RET
// function prepare_your_units ; var i , j ; begin
1160: LD_INT 0
1162: PPUSH
1163: PPUSH
1164: PPUSH
// InitUc ;
1165: CALL_OW 18
// InitHc ;
1169: CALL_OW 19
// uc_side := you2 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_EXP 48
1182: ST_TO_ADDR
// uc_nation := nation_american ;
1183: LD_ADDR_OWVAR 21
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1191: LD_INT 0
1193: PPUSH
1194: LD_INT 4
1196: PPUSH
1197: CALL_OW 382
// Eng1 := CreateHuman ;
1201: LD_ADDR_EXP 26
1205: PUSH
1206: CALL_OW 44
1210: ST_TO_ADDR
// PrepareEngineer ( 0 , 5 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 5
1216: PPUSH
1217: CALL_OW 382
// Eng2 := CreateHuman ;
1221: LD_ADDR_EXP 27
1225: PUSH
1226: CALL_OW 44
1230: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 4
1236: PPUSH
1237: CALL_OW 382
// Eng3 := CreateHuman ;
1241: LD_ADDR_EXP 28
1245: PUSH
1246: CALL_OW 44
1250: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1251: LD_INT 0
1253: PPUSH
1254: LD_INT 4
1256: PPUSH
1257: CALL_OW 382
// Eng4 := CreateHuman ;
1261: LD_ADDR_EXP 29
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1271: LD_ADDR_OWVAR 37
1275: PUSH
1276: LD_INT 2
1278: ST_TO_ADDR
// vc_control := control_manual ;
1279: LD_ADDR_OWVAR 38
1283: PUSH
1284: LD_INT 1
1286: ST_TO_ADDR
// vc_engine := engine_solar ;
1287: LD_ADDR_OWVAR 39
1291: PUSH
1292: LD_INT 2
1294: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1295: LD_ADDR_OWVAR 40
1299: PUSH
1300: LD_INT 12
1302: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1303: LD_ADDR_OWVAR 41
1307: PUSH
1308: LD_INT 60
1310: ST_TO_ADDR
// CarE1 := CreateVehicle ;
1311: LD_ADDR_EXP 30
1315: PUSH
1316: CALL_OW 45
1320: ST_TO_ADDR
// lidi_eng := [ Eng1 , Eng2 , Eng3 ] ;
1321: LD_ADDR_EXP 60
1325: PUSH
1326: LD_EXP 26
1330: PUSH
1331: LD_EXP 27
1335: PUSH
1336: LD_EXP 28
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: ST_TO_ADDR
// lidi := lidi union lidi_eng ;
1346: LD_ADDR_EXP 58
1350: PUSH
1351: LD_EXP 58
1355: PUSH
1356: LD_EXP 60
1360: UNION
1361: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1362: LD_INT 0
1364: PPUSH
1365: LD_INT 4
1367: PPUSH
1368: CALL_OW 383
// Mec1 := CreateHuman ;
1372: LD_ADDR_EXP 31
1376: PUSH
1377: CALL_OW 44
1381: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1382: LD_INT 0
1384: PPUSH
1385: LD_INT 4
1387: PPUSH
1388: CALL_OW 383
// Mec2 := CreateHuman ;
1392: LD_ADDR_EXP 32
1396: PUSH
1397: CALL_OW 44
1401: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1402: LD_INT 0
1404: PPUSH
1405: LD_INT 4
1407: PPUSH
1408: CALL_OW 383
// Mec3 := CreateHuman ;
1412: LD_ADDR_EXP 33
1416: PUSH
1417: CALL_OW 44
1421: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1422: LD_ADDR_OWVAR 37
1426: PUSH
1427: LD_INT 2
1429: ST_TO_ADDR
// vc_control := control_manual ;
1430: LD_ADDR_OWVAR 38
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// vc_engine := engine_solar ;
1438: LD_ADDR_OWVAR 39
1442: PUSH
1443: LD_INT 2
1445: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1446: LD_ADDR_OWVAR 40
1450: PUSH
1451: LD_INT 12
1453: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1454: LD_ADDR_OWVAR 41
1458: PUSH
1459: LD_INT 60
1461: ST_TO_ADDR
// Car1 := CreateVehicle ;
1462: LD_ADDR_EXP 34
1466: PUSH
1467: CALL_OW 45
1471: ST_TO_ADDR
// Car2 := CreateVehicle ;
1472: LD_ADDR_EXP 35
1476: PUSH
1477: CALL_OW 45
1481: ST_TO_ADDR
// Car3 := CreateVehicle ;
1482: LD_ADDR_EXP 36
1486: PUSH
1487: CALL_OW 45
1491: ST_TO_ADDR
// end ;
1492: LD_VAR 0 1
1496: RET
// function prepare_arabians_units ; begin
1497: LD_INT 0
1499: PPUSH
// InitUc ;
1500: CALL_OW 18
// InitHc ;
1504: CALL_OW 19
// uc_side := arabians ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_EXP 50
1517: ST_TO_ADDR
// uc_nation := nation_arabian ;
1518: LD_ADDR_OWVAR 21
1522: PUSH
1523: LD_INT 2
1525: ST_TO_ADDR
// PrepareSoldier ( sex_male , 4 ) ;
1526: LD_INT 1
1528: PPUSH
1529: LD_INT 4
1531: PPUSH
1532: CALL_OW 381
// Ara1 := CreateHuman ;
1536: LD_ADDR_EXP 39
1540: PUSH
1541: CALL_OW 44
1545: ST_TO_ADDR
// hc_name := Louis Gali ;
1546: LD_ADDR_OWVAR 26
1550: PUSH
1551: LD_STRING Louis Gali
1553: ST_TO_ADDR
// PrepareEngineer ( sex_male , 5 ) ;
1554: LD_INT 1
1556: PPUSH
1557: LD_INT 5
1559: PPUSH
1560: CALL_OW 382
// Ara2 := CreateHuman ;
1564: LD_ADDR_EXP 40
1568: PUSH
1569: CALL_OW 44
1573: ST_TO_ADDR
// InitHc ;
1574: CALL_OW 19
// uc_side := arabians ;
1578: LD_ADDR_OWVAR 20
1582: PUSH
1583: LD_EXP 50
1587: ST_TO_ADDR
// uc_nation := nation_arabian ;
1588: LD_ADDR_OWVAR 21
1592: PUSH
1593: LD_INT 2
1595: ST_TO_ADDR
// PrepareSoldier ( sex_female , 4 ) ;
1596: LD_INT 2
1598: PPUSH
1599: LD_INT 4
1601: PPUSH
1602: CALL_OW 381
// Ara3 := CreateHuman ;
1606: LD_ADDR_EXP 41
1610: PUSH
1611: CALL_OW 44
1615: ST_TO_ADDR
// PrepareMechanic ( sex_male , 5 ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 5
1621: PPUSH
1622: CALL_OW 383
// Ara4 := CreateHuman ;
1626: LD_ADDR_EXP 42
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PrepareMechanic ( sex_male , 4 ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 4
1641: PPUSH
1642: CALL_OW 383
// Ara5 := CreateHuman ;
1646: LD_ADDR_EXP 43
1650: PUSH
1651: CALL_OW 44
1655: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1656: LD_ADDR_OWVAR 37
1660: PUSH
1661: LD_INT 14
1663: ST_TO_ADDR
// vc_control := control_manual ;
1664: LD_ADDR_OWVAR 38
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// vc_engine := engine_combustion ;
1672: LD_ADDR_OWVAR 39
1676: PUSH
1677: LD_INT 1
1679: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
1680: LD_ADDR_OWVAR 40
1684: PUSH
1685: LD_INT 26
1687: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1688: LD_ADDR_OWVAR 41
1692: PUSH
1693: LD_INT 9
1695: ST_TO_ADDR
// AraCar1 := CreateVehicle ;
1696: LD_ADDR_EXP 44
1700: PUSH
1701: CALL_OW 45
1705: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1706: LD_ADDR_OWVAR 37
1710: PUSH
1711: LD_INT 14
1713: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1714: LD_ADDR_OWVAR 40
1718: PUSH
1719: LD_INT 32
1721: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1722: LD_ADDR_OWVAR 41
1726: PUSH
1727: LD_INT 9
1729: ST_TO_ADDR
// AraCar2 := CreateVehicle ;
1730: LD_ADDR_EXP 45
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// arabi := [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] ;
1740: LD_ADDR_EXP 46
1744: PUSH
1745: LD_EXP 39
1749: PUSH
1750: LD_EXP 40
1754: PUSH
1755: LD_EXP 41
1759: PUSH
1760: LD_EXP 42
1764: PUSH
1765: LD_EXP 43
1769: PUSH
1770: LD_EXP 44
1774: PUSH
1775: LD_EXP 45
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: ST_TO_ADDR
// PlaceHumanInUnit ( Ara4 , AraCar1 ) ;
1789: LD_EXP 42
1793: PPUSH
1794: LD_EXP 44
1798: PPUSH
1799: CALL_OW 52
// PlaceHumanInUnit ( Ara5 , AraCar2 ) ;
1803: LD_EXP 43
1807: PPUSH
1808: LD_EXP 45
1812: PPUSH
1813: CALL_OW 52
// end ;
1817: LD_VAR 0 1
1821: RET
// function prepare_russians_units ; begin
1822: LD_INT 0
1824: PPUSH
// end ;
1825: LD_VAR 0 1
1829: RET
// starting begin f_testing ;
1830: CALL 0 0 0
// depot1 := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1834: LD_ADDR_EXP 69
1838: PUSH
1839: LD_INT 23
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 30
1851: PUSH
1852: LD_INT 0
1854: PUSH
1855: EMPTY
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: PPUSH
1863: CALL_OW 69
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: ST_TO_ADDR
// rudepot1 := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1872: LD_ADDR_EXP 67
1876: PUSH
1877: LD_INT 23
1879: PUSH
1880: LD_INT 3
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 30
1889: PUSH
1890: LD_INT 0
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PPUSH
1901: CALL_OW 69
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: ST_TO_ADDR
// SetBName ( depot1 , terminal ) ;
1910: LD_EXP 69
1914: PPUSH
1915: LD_STRING terminal
1917: PPUSH
1918: CALL_OW 500
// map_size_x := 70 ;
1922: LD_ADDR_EXP 7
1926: PUSH
1927: LD_INT 70
1929: ST_TO_ADDR
// map_size_y := 140 ;
1930: LD_ADDR_EXP 8
1934: PUSH
1935: LD_INT 140
1937: ST_TO_ADDR
// lidi := [ ] ;
1938: LD_ADDR_EXP 58
1942: PUSH
1943: EMPTY
1944: ST_TO_ADDR
// lidi_base := [ ] ;
1945: LD_ADDR_EXP 59
1949: PUSH
1950: EMPTY
1951: ST_TO_ADDR
// lidi_eng := [ ] ;
1952: LD_ADDR_EXP 60
1956: PUSH
1957: EMPTY
1958: ST_TO_ADDR
// neco_rikaji := [ ] ;
1959: LD_ADDR_EXP 61
1963: PUSH
1964: EMPTY
1965: ST_TO_ADDR
// counter_time := 0 ;
1966: LD_ADDR_EXP 64
1970: PUSH
1971: LD_INT 0
1973: ST_TO_ADDR
// SetDifficulty ;
1974: CALL 1100 0 0
// mhmg := 1 ;
1978: LD_ADDR_EXP 9
1982: PUSH
1983: LD_INT 1
1985: ST_TO_ADDR
// mgg := 2 ;
1986: LD_ADDR_EXP 10
1990: PUSH
1991: LD_INT 2
1993: ST_TO_ADDR
// mg := 3 ;
1994: LD_ADDR_EXP 11
1998: PUSH
1999: LD_INT 3
2001: ST_TO_ADDR
// mrl := 4 ;
2002: LD_ADDR_EXP 12
2006: PUSH
2007: LD_INT 4
2009: ST_TO_ADDR
// hgg := 5 ;
2010: LD_ADDR_EXP 13
2014: PUSH
2015: LD_INT 5
2017: ST_TO_ADDR
// hrl := 6 ;
2018: LD_ADDR_EXP 14
2022: PUSH
2023: LD_INT 6
2025: ST_TO_ADDR
// hhg := 7 ;
2026: LD_ADDR_EXP 15
2030: PUSH
2031: LD_INT 7
2033: ST_TO_ADDR
// you := 1 ;
2034: LD_ADDR_EXP 47
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// you2 := 4 ;
2042: LD_ADDR_EXP 48
2046: PUSH
2047: LD_INT 4
2049: ST_TO_ADDR
// arabians := 2 ;
2050: LD_ADDR_EXP 50
2054: PUSH
2055: LD_INT 2
2057: ST_TO_ADDR
// russians := 3 ;
2058: LD_ADDR_EXP 49
2062: PUSH
2063: LD_INT 3
2065: ST_TO_ADDR
// SetBName ( RuDepot , ovsyenko ) ;
2066: LD_INT 58
2068: PPUSH
2069: LD_STRING ovsyenko
2071: PPUSH
2072: CALL_OW 500
// prepare_your_units ;
2076: CALL 1160 0 0
// prepare_arabians_units ;
2080: CALL 1497 0 0
// prepare_russians_units ;
2084: CALL 1822 0 0
// load_units_2 ;
2088: CALL 99 0 0
// Dialog2 ;
2092: CALL 2973 0 0
// end ;
2096: END
// export function Save ; var sibu ; begin
2097: LD_INT 0
2099: PPUSH
2100: PPUSH
// SaveCharacters ( JMM , JMM ) ;
2101: LD_EXP 17
2105: PPUSH
2106: LD_STRING JMM
2108: PPUSH
2109: CALL_OW 38
// if Bobby then
2113: LD_EXP 18
2117: IFFALSE 2152
// begin SaveCharacters ( Bobby , Bobby ) ;
2119: LD_EXP 18
2123: PPUSH
2124: LD_STRING Bobby
2126: PPUSH
2127: CALL_OW 38
// if IsDead ( Bobby ) then
2131: LD_EXP 18
2135: PPUSH
2136: CALL_OW 301
2140: IFFALSE 2152
// SaveVariable ( 0 , BobbyLoc ) ;
2142: LD_INT 0
2144: PPUSH
2145: LD_STRING BobbyLoc
2147: PPUSH
2148: CALL_OW 39
// end ; if Cyrus then
2152: LD_EXP 19
2156: IFFALSE 2191
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2158: LD_EXP 19
2162: PPUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: CALL_OW 38
// if IsDead ( Cyrus ) then
2170: LD_EXP 19
2174: PPUSH
2175: CALL_OW 301
2179: IFFALSE 2191
// SaveVariable ( 0 , CyrusLoc ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_STRING CyrusLoc
2186: PPUSH
2187: CALL_OW 39
// end ; if Brown then
2191: LD_EXP 21
2195: IFFALSE 2230
// begin SaveCharacters ( Brown , Brown ) ;
2197: LD_EXP 21
2201: PPUSH
2202: LD_STRING Brown
2204: PPUSH
2205: CALL_OW 38
// if IsDead ( Brown ) then
2209: LD_EXP 21
2213: PPUSH
2214: CALL_OW 301
2218: IFFALSE 2230
// SaveVariable ( 0 , BrownLoc ) ;
2220: LD_INT 0
2222: PPUSH
2223: LD_STRING BrownLoc
2225: PPUSH
2226: CALL_OW 39
// end ; if Donaldson then
2230: LD_EXP 20
2234: IFFALSE 2269
// begin SaveCharacters ( Donaldson , Donaldson ) ;
2236: LD_EXP 20
2240: PPUSH
2241: LD_STRING Donaldson
2243: PPUSH
2244: CALL_OW 38
// if IsDead ( Donaldson ) then
2248: LD_EXP 20
2252: PPUSH
2253: CALL_OW 301
2257: IFFALSE 2269
// SaveVariable ( 0 , DonaldsonLoc ) ;
2259: LD_INT 0
2261: PPUSH
2262: LD_STRING DonaldsonLoc
2264: PPUSH
2265: CALL_OW 39
// end ; SaveCharacters ( Gary , Gary ) ;
2269: LD_EXP 22
2273: PPUSH
2274: LD_STRING Gary
2276: PPUSH
2277: CALL_OW 38
// if IsDead ( Gary ) then
2281: LD_EXP 22
2285: PPUSH
2286: CALL_OW 301
2290: IFFALSE 2302
// SaveVariable ( 0 , GaryLoc ) ;
2292: LD_INT 0
2294: PPUSH
2295: LD_STRING GaryLoc
2297: PPUSH
2298: CALL_OW 39
// sibu := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2302: LD_ADDR_VAR 0 2
2306: PUSH
2307: LD_EXP 69
2311: PPUSH
2312: CALL_OW 274
2316: PPUSH
2317: LD_INT 3
2319: PPUSH
2320: CALL_OW 275
2324: ST_TO_ADDR
// if sibu >= 300 then
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 300
2332: GREATEREQUAL
2333: IFFALSE 2347
// begin sibu := 300 ;
2335: LD_ADDR_VAR 0 2
2339: PUSH
2340: LD_INT 300
2342: ST_TO_ADDR
// SA_CollectedSibInTerminal ;
2343: CALL 25822 0 0
// end ; SaveVariable ( sibu , stoupa9_siberit ) ;
2347: LD_VAR 0 2
2351: PPUSH
2352: LD_STRING stoupa9_siberit
2354: PPUSH
2355: CALL_OW 39
// SaveVariable ( ( PoskytnouInformace > 0 ) , stoupa9_informace ) ;
2359: LD_EXP 56
2363: PUSH
2364: LD_INT 0
2366: GREATER
2367: PPUSH
2368: LD_STRING stoupa9_informace
2370: PPUSH
2371: CALL_OW 39
// SaveCharacters ( other_survivors , other_survivors ) ;
2375: LD_EXP 52
2379: PPUSH
2380: LD_STRING other_survivors
2382: PPUSH
2383: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Donaldson , Brown , Bobby , Cyrus , Gary , 0 ] , otherWithJMM ) ;
2387: LD_INT 22
2389: PUSH
2390: LD_EXP 47
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: PUSH
2399: LD_INT 21
2401: PUSH
2402: LD_INT 1
2404: PUSH
2405: EMPTY
2406: LIST
2407: LIST
2408: PUSH
2409: LD_INT 23
2411: PUSH
2412: LD_INT 1
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: PPUSH
2424: CALL_OW 69
2428: PUSH
2429: LD_EXP 17
2433: PUSH
2434: LD_EXP 20
2438: PUSH
2439: LD_EXP 21
2443: PUSH
2444: LD_EXP 18
2448: PUSH
2449: LD_EXP 19
2453: PUSH
2454: LD_EXP 22
2458: PUSH
2459: LD_INT 0
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: DIFF
2471: PPUSH
2472: LD_STRING otherWithJMM
2474: PPUSH
2475: CALL_OW 38
// end ;
2479: LD_VAR 0 1
2483: RET
// every 0 0$3 trigger depot1 do var sib_dep1 ;
2484: LD_EXP 69
2488: IFFALSE 2541
2490: GO 2492
2492: DISABLE
2493: LD_INT 0
2495: PPUSH
// begin sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2496: LD_ADDR_VAR 0 1
2500: PUSH
2501: LD_EXP 69
2505: PPUSH
2506: CALL_OW 274
2510: PPUSH
2511: LD_INT 3
2513: PPUSH
2514: CALL_OW 275
2518: ST_TO_ADDR
// if sib_dep1 >= EndSiberit then
2519: LD_VAR 0 1
2523: PUSH
2524: LD_EXP 55
2528: GREATEREQUAL
2529: IFFALSE 2540
// ChangeMissionObjectives ( M2a ) else
2531: LD_STRING M2a
2533: PPUSH
2534: CALL_OW 337
2538: GO 2541
// enable ;
2540: ENABLE
// end ;
2541: PPOPN 1
2543: END
// export function SetMedals ; var d , sib_dep1 , sib_celkem , i , medal1 , medal2 , medal3 ; begin
2544: LD_INT 0
2546: PPUSH
2547: PPUSH
2548: PPUSH
2549: PPUSH
2550: PPUSH
2551: PPUSH
2552: PPUSH
2553: PPUSH
// d := difficulty - 1 ;
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_OWVAR 67
2563: PUSH
2564: LD_INT 1
2566: MINUS
2567: ST_TO_ADDR
// sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2568: LD_ADDR_VAR 0 3
2572: PUSH
2573: LD_EXP 69
2577: PPUSH
2578: CALL_OW 274
2582: PPUSH
2583: LD_INT 3
2585: PPUSH
2586: CALL_OW 275
2590: ST_TO_ADDR
// sib_celkem := 0 ;
2591: LD_ADDR_VAR 0 4
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
2599: LD_ADDR_VAR 0 5
2603: PUSH
2604: LD_INT 22
2606: PUSH
2607: LD_EXP 47
2611: PUSH
2612: EMPTY
2613: LIST
2614: LIST
2615: PUSH
2616: LD_INT 2
2618: PUSH
2619: LD_INT 30
2621: PUSH
2622: LD_INT 0
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 30
2631: PUSH
2632: LD_INT 1
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: LIST
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PPUSH
2648: CALL_OW 69
2652: PUSH
2653: FOR_IN
2654: IFFALSE 2687
// sib_celkem := sib_celkem + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
2656: LD_ADDR_VAR 0 4
2660: PUSH
2661: LD_VAR 0 4
2665: PUSH
2666: LD_VAR 0 5
2670: PPUSH
2671: CALL_OW 274
2675: PPUSH
2676: LD_INT 3
2678: PPUSH
2679: CALL_OW 275
2683: PLUS
2684: ST_TO_ADDR
2685: GO 2653
2687: POP
2688: POP
// medal1 := false ;
2689: LD_ADDR_VAR 0 6
2693: PUSH
2694: LD_INT 0
2696: ST_TO_ADDR
// if sib_dep1 >= EndSiberit then
2697: LD_VAR 0 3
2701: PUSH
2702: LD_EXP 55
2706: GREATEREQUAL
2707: IFFALSE 2729
// begin medal1 := true ;
2709: LD_ADDR_VAR 0 6
2713: PUSH
2714: LD_INT 1
2716: ST_TO_ADDR
// AddMedal ( MuchSiberite , 1 ) ;
2717: LD_STRING MuchSiberite
2719: PPUSH
2720: LD_INT 1
2722: PPUSH
2723: CALL_OW 101
// end else
2727: GO 2785
// if sib_celkem < EndSiberit then
2729: LD_VAR 0 4
2733: PUSH
2734: LD_EXP 55
2738: LESS
2739: IFFALSE 2764
// AddMedal ( MuchSiberite , - 1 - 2 * d ) else
2741: LD_STRING MuchSiberite
2743: PPUSH
2744: LD_INT 1
2746: NEG
2747: PUSH
2748: LD_INT 2
2750: PUSH
2751: LD_VAR 0 2
2755: MUL
2756: MINUS
2757: PPUSH
2758: CALL_OW 101
2762: GO 2785
// AddMedal ( MuchSiberite , - 2 - 2 * d ) ;
2764: LD_STRING MuchSiberite
2766: PPUSH
2767: LD_INT 2
2769: NEG
2770: PUSH
2771: LD_INT 2
2773: PUSH
2774: LD_VAR 0 2
2778: MUL
2779: MINUS
2780: PPUSH
2781: CALL_OW 101
// medal2 := not NastvalPowella ;
2785: LD_ADDR_VAR 0 7
2789: PUSH
2790: LD_EXP 57
2794: NOT
2795: ST_TO_ADDR
// AddMedal ( EarlySiberite , not NastvalPowella ) ;
2796: LD_STRING EarlySiberite
2798: PPUSH
2799: LD_EXP 57
2803: NOT
2804: PPUSH
2805: CALL_OW 101
// medal3 := PoskytnouInformace > 0 ;
2809: LD_ADDR_VAR 0 8
2813: PUSH
2814: LD_EXP 56
2818: PUSH
2819: LD_INT 0
2821: GREATER
2822: ST_TO_ADDR
// AddMedal ( Information , PoskytnouInformace > 0 ) ;
2823: LD_STRING Information
2825: PPUSH
2826: LD_EXP 56
2830: PUSH
2831: LD_INT 0
2833: GREATER
2834: PPUSH
2835: CALL_OW 101
// SA_EndMission ( 1 , 9 , medal1 , medal2 , medal3 ) ;
2839: LD_INT 1
2841: PPUSH
2842: LD_INT 9
2844: PPUSH
2845: LD_VAR 0 6
2849: PPUSH
2850: LD_VAR 0 7
2854: PPUSH
2855: LD_VAR 0 8
2859: PPUSH
2860: CALL 25837 0 5
// end ;
2864: LD_VAR 0 1
2868: RET
// export Vyhrano ; export function Vyhra ; begin
2869: LD_INT 0
2871: PPUSH
// if not Vyhrano then
2872: LD_EXP 70
2876: NOT
2877: IFFALSE 2967
// begin Vyhrano := true ;
2879: LD_ADDR_EXP 70
2883: PUSH
2884: LD_INT 1
2886: ST_TO_ADDR
// SetMedals ;
2887: CALL 2544 0 0
// GiveMedals ( Main ) ;
2891: LD_STRING Main
2893: PPUSH
2894: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
2898: LD_INT 22
2900: PUSH
2901: LD_EXP 47
2905: PUSH
2906: EMPTY
2907: LIST
2908: LIST
2909: PUSH
2910: LD_INT 21
2912: PUSH
2913: LD_INT 1
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 23
2922: PUSH
2923: LD_INT 1
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: LIST
2934: PPUSH
2935: CALL_OW 69
2939: PPUSH
2940: CALL_OW 43
// Save ;
2944: CALL 2097 0 0
// YouWin ;
2948: CALL_OW 103
// ExclusiveOn ;
2952: CALL_OW 4
// WAIT ( 1 ) ;
2956: LD_INT 1
2958: PPUSH
2959: CALL_OW 67
// ExclusiveOff ;
2963: CALL_OW 5
// end ; end ;
2967: LD_VAR 0 1
2971: RET
// final begin end ; end_of_file
2972: END
// export ArmBuild ; export ArmUpgraded ; export function Dialog2 ; begin
2973: LD_INT 0
2975: PPUSH
// InGameOn ;
2976: CALL_OW 8
// PlaceUnitXYR ( Eng1 , 35 , 8 , 3 , false ) ;
2980: LD_EXP 26
2984: PPUSH
2985: LD_INT 35
2987: PPUSH
2988: LD_INT 8
2990: PPUSH
2991: LD_INT 3
2993: PPUSH
2994: LD_INT 0
2996: PPUSH
2997: CALL_OW 50
// PlaceUnitXYR ( Eng2 , 35 , 8 , 3 , false ) ;
3001: LD_EXP 27
3005: PPUSH
3006: LD_INT 35
3008: PPUSH
3009: LD_INT 8
3011: PPUSH
3012: LD_INT 3
3014: PPUSH
3015: LD_INT 0
3017: PPUSH
3018: CALL_OW 50
// PlaceUnitXYR ( Eng3 , 35 , 8 , 3 , false ) ;
3022: LD_EXP 28
3026: PPUSH
3027: LD_INT 35
3029: PPUSH
3030: LD_INT 8
3032: PPUSH
3033: LD_INT 3
3035: PPUSH
3036: LD_INT 0
3038: PPUSH
3039: CALL_OW 50
// PlaceHumanInUnit ( Eng4 , CarE1 ) ;
3043: LD_EXP 29
3047: PPUSH
3048: LD_EXP 30
3052: PPUSH
3053: CALL_OW 52
// PlaceUnitXY ( CarE1 , 41 , 9 , false ) ;
3057: LD_EXP 30
3061: PPUSH
3062: LD_INT 41
3064: PPUSH
3065: LD_INT 9
3067: PPUSH
3068: LD_INT 0
3070: PPUSH
3071: CALL_OW 48
// ComHold ( CarE1 ) ;
3075: LD_EXP 30
3079: PPUSH
3080: CALL_OW 140
// ComMoveXY ( [ Eng1 , Eng2 , Eng3 ] , 34 , 6 ) ;
3084: LD_EXP 26
3088: PUSH
3089: LD_EXP 27
3093: PUSH
3094: LD_EXP 28
3098: PUSH
3099: EMPTY
3100: LIST
3101: LIST
3102: LIST
3103: PPUSH
3104: LD_INT 34
3106: PPUSH
3107: LD_INT 6
3109: PPUSH
3110: CALL_OW 111
// AddComRepairBuilding ( [ Eng1 , Eng2 , Eng3 ] , Depot1 ) ;
3114: LD_EXP 26
3118: PUSH
3119: LD_EXP 27
3123: PUSH
3124: LD_EXP 28
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: LIST
3133: PPUSH
3134: LD_EXP 69
3138: PPUSH
3139: CALL_OW 190
// ComEnterUnit ( Gary , rudepot1 ) ;
3143: LD_EXP 22
3147: PPUSH
3148: LD_EXP 67
3152: PPUSH
3153: CALL_OW 120
// Wait ( 0 0$1 ) ;
3157: LD_INT 35
3159: PPUSH
3160: CALL_OW 67
// PlaceUnitXY ( JMM , 33 , 1 , false ) ;
3164: LD_EXP 17
3168: PPUSH
3169: LD_INT 33
3171: PPUSH
3172: LD_INT 1
3174: PPUSH
3175: LD_INT 0
3177: PPUSH
3178: CALL_OW 48
// CenterNowOnUnits ( JMM ) ;
3182: LD_EXP 17
3186: PPUSH
3187: CALL_OW 87
// ComMoveXY ( JMM , 34 , 5 ) ;
3191: LD_EXP 17
3195: PPUSH
3196: LD_INT 34
3198: PPUSH
3199: LD_INT 5
3201: PPUSH
3202: CALL_OW 111
// AddComStand ( JMM ) ;
3206: LD_EXP 17
3210: PPUSH
3211: CALL_OW 225
// CreateCratesXY ( 5 , 39 , 10 , false ) ;
3215: LD_INT 5
3217: PPUSH
3218: LD_INT 39
3220: PPUSH
3221: LD_INT 10
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 54
// CreateCratesXY ( 5 , 39 , 11 , false ) ;
3231: LD_INT 5
3233: PPUSH
3234: LD_INT 39
3236: PPUSH
3237: LD_INT 11
3239: PPUSH
3240: LD_INT 0
3242: PPUSH
3243: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 10 , false ) ;
3247: LD_INT 5
3249: PPUSH
3250: LD_INT 38
3252: PPUSH
3253: LD_INT 10
3255: PPUSH
3256: LD_INT 0
3258: PPUSH
3259: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 11 , false ) ;
3263: LD_INT 5
3265: PPUSH
3266: LD_INT 38
3268: PPUSH
3269: LD_INT 11
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 54
// Wait ( 0 0$3 ) ;
3279: LD_INT 105
3281: PPUSH
3282: CALL_OW 67
// ComMoveXY ( CarE1 , 38 , 1 ) ;
3286: LD_EXP 30
3290: PPUSH
3291: LD_INT 38
3293: PPUSH
3294: LD_INT 1
3296: PPUSH
3297: CALL_OW 111
// while GetY ( CarE1 ) > 3 do
3301: LD_EXP 30
3305: PPUSH
3306: CALL_OW 251
3310: PUSH
3311: LD_INT 3
3313: GREATER
3314: IFFALSE 3325
// wait ( 0 0$0.3 ) ;
3316: LD_INT 10
3318: PPUSH
3319: CALL_OW 67
3323: GO 3301
// RemoveUnit ( CarE1 ) ;
3325: LD_EXP 30
3329: PPUSH
3330: CALL_OW 64
// Say ( JMM , D2-JMM-1 ) ;
3334: LD_EXP 17
3338: PPUSH
3339: LD_STRING D2-JMM-1
3341: PPUSH
3342: CALL_OW 88
// Say ( Eng1 , D2-Eng1-1 ) ;
3346: LD_EXP 26
3350: PPUSH
3351: LD_STRING D2-Eng1-1
3353: PPUSH
3354: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3358: LD_EXP 17
3362: PPUSH
3363: LD_STRING D2-JMM-2
3365: PPUSH
3366: CALL_OW 88
// Say ( Eng1 , D2-Eng1-2 ) ;
3370: LD_EXP 26
3374: PPUSH
3375: LD_STRING D2-Eng1-2
3377: PPUSH
3378: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3382: LD_EXP 17
3386: PPUSH
3387: LD_STRING D2-JMM-3
3389: PPUSH
3390: CALL_OW 88
// SetSideBase ( GetBase ( Depot1 ) , you ) ;
3394: LD_EXP 69
3398: PPUSH
3399: CALL_OW 274
3403: PPUSH
3404: LD_EXP 47
3408: PPUSH
3409: CALL_OW 236
// SetSide ( [ Eng1 , Eng2 , Eng3 ] , you ) ;
3413: LD_EXP 26
3417: PUSH
3418: LD_EXP 27
3422: PUSH
3423: LD_EXP 28
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: PPUSH
3433: LD_EXP 47
3437: PPUSH
3438: CALL_OW 235
// SaveForQuickRestart ;
3442: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3446: LD_STRING M1
3448: PPUSH
3449: CALL_OW 337
// InGameOff ;
3453: CALL_OW 9
// end ;
3457: LD_VAR 0 1
3461: RET
// export byld2a ; every 0 0$2 trigger IsInArea ( JMM , base ) marked 30 do
3462: LD_EXP 17
3466: PPUSH
3467: LD_INT 1
3469: PPUSH
3470: CALL_OW 308
3474: IFFALSE 3483
3476: GO 3478
3478: DISABLE
// begin dialog2a ;
3479: CALL 3484 0 0
// end ;
3483: END
// export function dialog2a ; var i ; begin
3484: LD_INT 0
3486: PPUSH
3487: PPUSH
// Wait ( 0 0$1 ) ;
3488: LD_INT 35
3490: PPUSH
3491: CALL_OW 67
// ComMoveUnit ( Gary , JMM ) ;
3495: LD_EXP 22
3499: PPUSH
3500: LD_EXP 17
3504: PPUSH
3505: CALL_OW 112
// byld2a := true ;
3509: LD_ADDR_EXP 73
3513: PUSH
3514: LD_INT 1
3516: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
3517: LD_INT 105
3519: PPUSH
3520: CALL_OW 67
// DialogueOn ;
3524: CALL_OW 6
// Say ( JMM , D2-JMM-3a ) ;
3528: LD_EXP 17
3532: PPUSH
3533: LD_STRING D2-JMM-3a
3535: PPUSH
3536: CALL_OW 88
// SetSideBase ( GetBase ( rudepot1 ) , you ) ;
3540: LD_EXP 67
3544: PPUSH
3545: CALL_OW 274
3549: PPUSH
3550: LD_EXP 47
3554: PPUSH
3555: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you2 ] , [ f_type , unit_building ] ] ) do
3559: LD_ADDR_VAR 0 2
3563: PUSH
3564: LD_INT 22
3566: PUSH
3567: LD_EXP 48
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 21
3578: PUSH
3579: LD_INT 3
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: PPUSH
3590: CALL_OW 69
3594: PUSH
3595: FOR_IN
3596: IFFALSE 3614
// SetSide ( i , you ) ;
3598: LD_VAR 0 2
3602: PPUSH
3603: LD_EXP 47
3607: PPUSH
3608: CALL_OW 235
3612: GO 3595
3614: POP
3615: POP
// SetSide ( lidi_base , you ) ;
3616: LD_EXP 59
3620: PPUSH
3621: LD_EXP 47
3625: PPUSH
3626: CALL_OW 235
// SetResourceType ( GetBase ( rudepot1 ) , mat_siberit , 0 ) ;
3630: LD_EXP 67
3634: PPUSH
3635: CALL_OW 274
3639: PPUSH
3640: LD_INT 3
3642: PPUSH
3643: LD_INT 0
3645: PPUSH
3646: CALL_OW 277
// Say ( Gary , D2-Gary-3 ) ;
3650: LD_EXP 22
3654: PPUSH
3655: LD_STRING D2-Gary-3
3657: PPUSH
3658: CALL_OW 88
// if Bobby then
3662: LD_EXP 18
3666: IFFALSE 3680
// Say ( Bobby , D2-Bobby-3 ) ;
3668: LD_EXP 18
3672: PPUSH
3673: LD_STRING D2-Bobby-3
3675: PPUSH
3676: CALL_OW 88
// if Cyrus then
3680: LD_EXP 19
3684: IFFALSE 3698
// Say ( Cyrus , D2-Cyrus-3 ) ;
3686: LD_EXP 19
3690: PPUSH
3691: LD_STRING D2-Cyrus-3
3693: PPUSH
3694: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3698: LD_EXP 17
3702: PPUSH
3703: LD_STRING D2-JMM-4
3705: PPUSH
3706: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3710: LD_EXP 22
3714: PPUSH
3715: LD_STRING D2-Gary-4
3717: PPUSH
3718: CALL_OW 88
// if Cyrus then
3722: LD_EXP 19
3726: IFFALSE 3742
// Say ( Cyrus , D2-Cyrus-4 ) else
3728: LD_EXP 19
3732: PPUSH
3733: LD_STRING D2-Cyrus-4
3735: PPUSH
3736: CALL_OW 88
3740: GO 3774
// SayAny ( lidi_base diff neco_rikaji , D2-Sol1-4 , you , sex_male , 0 , 0 ) ;
3742: LD_EXP 59
3746: PUSH
3747: LD_EXP 61
3751: DIFF
3752: PPUSH
3753: LD_STRING D2-Sol1-4
3755: PPUSH
3756: LD_EXP 47
3760: PPUSH
3761: LD_INT 1
3763: PPUSH
3764: LD_INT 0
3766: PPUSH
3767: LD_INT 0
3769: PPUSH
3770: CALL 13144 0 6
// Say ( JMM , D2-JMM-5 ) ;
3774: LD_EXP 17
3778: PPUSH
3779: LD_STRING D2-JMM-5
3781: PPUSH
3782: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-5 , you , sex_female , class_engineer , 0 ) ;
3786: LD_EXP 58
3790: PUSH
3791: LD_EXP 61
3795: DIFF
3796: PPUSH
3797: LD_STRING D2-FEng1-5
3799: PPUSH
3800: LD_EXP 47
3804: PPUSH
3805: LD_INT 2
3807: PPUSH
3808: LD_INT 2
3810: PPUSH
3811: LD_INT 0
3813: PPUSH
3814: CALL 13144 0 6
// Say ( JMM , D2-JMM-6 ) ;
3818: LD_EXP 17
3822: PPUSH
3823: LD_STRING D2-JMM-6
3825: PPUSH
3826: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-6 , you , sex_female , class_engineer , 0 ) ;
3830: LD_EXP 58
3834: PUSH
3835: LD_EXP 61
3839: DIFF
3840: PPUSH
3841: LD_STRING D2-FEng1-6
3843: PPUSH
3844: LD_EXP 47
3848: PPUSH
3849: LD_INT 2
3851: PPUSH
3852: LD_INT 2
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL 13144 0 6
// SayAny ( lidi diff neco_rikaji , D2-Eng1-6 , you , sex_male , class_engineer , 0 ) ;
3862: LD_EXP 58
3866: PUSH
3867: LD_EXP 61
3871: DIFF
3872: PPUSH
3873: LD_STRING D2-Eng1-6
3875: PPUSH
3876: LD_EXP 47
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_INT 2
3886: PPUSH
3887: LD_INT 0
3889: PPUSH
3890: CALL 13144 0 6
// Say ( JMM , D2-JMM-7 ) ;
3894: LD_EXP 17
3898: PPUSH
3899: LD_STRING D2-JMM-7
3901: PPUSH
3902: CALL_OW 88
// Say ( Gary , D2-Gary-7 ) ;
3906: LD_EXP 22
3910: PPUSH
3911: LD_STRING D2-Gary-7
3913: PPUSH
3914: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-7 , you , sex_female , class_engineer , 0 ) ;
3918: LD_EXP 58
3922: PUSH
3923: LD_EXP 61
3927: DIFF
3928: PPUSH
3929: LD_STRING D2-FEng1-7
3931: PPUSH
3932: LD_EXP 47
3936: PPUSH
3937: LD_INT 2
3939: PPUSH
3940: LD_INT 2
3942: PPUSH
3943: LD_INT 0
3945: PPUSH
3946: CALL 13144 0 6
// SayAny ( lidi diff neco_rikaji , D2-Sol1-7 , you , sex_male , class_soldier , 0 ) ;
3950: LD_EXP 58
3954: PUSH
3955: LD_EXP 61
3959: DIFF
3960: PPUSH
3961: LD_STRING D2-Sol1-7
3963: PPUSH
3964: LD_EXP 47
3968: PPUSH
3969: LD_INT 1
3971: PPUSH
3972: LD_INT 1
3974: PPUSH
3975: LD_INT 0
3977: PPUSH
3978: CALL 13144 0 6
// Say ( JMM , D2-JMM-8 ) ;
3982: LD_EXP 17
3986: PPUSH
3987: LD_STRING D2-JMM-8
3989: PPUSH
3990: CALL_OW 88
// dialog2byl := true ;
3994: LD_ADDR_EXP 65
3998: PUSH
3999: LD_INT 1
4001: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
4002: LD_STRING M1a
4004: PPUSH
4005: CALL_OW 337
// DialogueOff ;
4009: CALL_OW 7
// MyHint ( SibDet ) ;
4013: LD_STRING SibDet
4015: PPUSH
4016: CALL 14295 0 1
// end ;
4020: LD_VAR 0 1
4024: RET
// every 0 0$5 trigger GetSide ( rudepot1 ) = you and GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) do
4025: LD_EXP 67
4029: PPUSH
4030: CALL_OW 255
4034: PUSH
4035: LD_EXP 47
4039: EQUAL
4040: PUSH
4041: LD_EXP 67
4045: PPUSH
4046: CALL_OW 274
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: CALL_OW 275
4058: AND
4059: IFFALSE 4124
4061: GO 4063
4063: DISABLE
// begin case difficulty of 1 :
4064: LD_OWVAR 67
4068: PUSH
4069: LD_INT 1
4071: DOUBLE
4072: EQUAL
4073: IFTRUE 4077
4075: GO 4087
4077: POP
// ChangeMissionObjectives ( M2easy ) ; 2 :
4078: LD_STRING M2easy
4080: PPUSH
4081: CALL_OW 337
4085: GO 4124
4087: LD_INT 2
4089: DOUBLE
4090: EQUAL
4091: IFTRUE 4095
4093: GO 4105
4095: POP
// ChangeMissionObjectives ( M2 ) ; 3 :
4096: LD_STRING M2
4098: PPUSH
4099: CALL_OW 337
4103: GO 4124
4105: LD_INT 3
4107: DOUBLE
4108: EQUAL
4109: IFTRUE 4113
4111: GO 4123
4113: POP
// ChangeMissionObjectives ( M2hard ) ; end ;
4114: LD_STRING M2hard
4116: PPUSH
4117: CALL_OW 337
4121: GO 4124
4123: POP
// end ;
4124: END
// every 7 7$0 do
4125: GO 4127
4127: DISABLE
// begin DialogueOn ;
4128: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4132: LD_EXP 16
4136: PPUSH
4137: LD_STRING D3-Pow-1
4139: PPUSH
4140: CALL_OW 94
// if dialog2byl then
4144: LD_EXP 65
4148: IFFALSE 4164
// Say ( JMM , D3-JMM-1 ) else
4150: LD_EXP 17
4154: PPUSH
4155: LD_STRING D3-JMM-1
4157: PPUSH
4158: CALL_OW 88
4162: GO 4176
// Say ( JMM , D3-JMM-1a ) ;
4164: LD_EXP 17
4168: PPUSH
4169: LD_STRING D3-JMM-1a
4171: PPUSH
4172: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4176: LD_EXP 17
4180: PPUSH
4181: LD_STRING D3-JMM-1b
4183: PPUSH
4184: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4188: LD_EXP 16
4192: PPUSH
4193: LD_STRING D3-Pow-2
4195: PPUSH
4196: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
4200: LD_STRING M3
4202: PPUSH
4203: CALL_OW 337
// DialogueOff ;
4207: CALL_OW 7
// counter_time := 22 22$0 ;
4211: LD_ADDR_EXP 64
4215: PUSH
4216: LD_INT 46200
4218: ST_TO_ADDR
// end ;
4219: END
// every 22 22$0 do var qr , i , mt ;
4220: GO 4222
4222: DISABLE
4223: LD_INT 0
4225: PPUSH
4226: PPUSH
4227: PPUSH
// begin SetAttitude ( you , you2 , att_neutral , true ) ;
4228: LD_EXP 47
4232: PPUSH
4233: LD_EXP 48
4237: PPUSH
4238: LD_INT 0
4240: PPUSH
4241: LD_INT 1
4243: PPUSH
4244: CALL_OW 80
// ChangeSideFog ( you2 , you ) ;
4248: LD_EXP 48
4252: PPUSH
4253: LD_EXP 47
4257: PPUSH
4258: CALL_OW 343
// PlaceHumanInUnit ( Mec1 , Car1 ) ;
4262: LD_EXP 31
4266: PPUSH
4267: LD_EXP 34
4271: PPUSH
4272: CALL_OW 52
// PlaceHumanInUnit ( Mec2 , Car2 ) ;
4276: LD_EXP 32
4280: PPUSH
4281: LD_EXP 35
4285: PPUSH
4286: CALL_OW 52
// PlaceHumanInUnit ( Mec3 , Car3 ) ;
4290: LD_EXP 33
4294: PPUSH
4295: LD_EXP 36
4299: PPUSH
4300: CALL_OW 52
// if not PlaceUnitXYR ( Car1 , 35 , 1 , 10 , false ) then
4304: LD_EXP 34
4308: PPUSH
4309: LD_INT 35
4311: PPUSH
4312: LD_INT 1
4314: PPUSH
4315: LD_INT 10
4317: PPUSH
4318: LD_INT 0
4320: PPUSH
4321: CALL_OW 50
4325: NOT
4326: IFFALSE 4343
// PlaceUnitArea ( Car1 , odjezd , false ) ;
4328: LD_EXP 34
4332: PPUSH
4333: LD_INT 5
4335: PPUSH
4336: LD_INT 0
4338: PPUSH
4339: CALL_OW 49
// if not PlaceUnitXYR ( Car2 , 35 , 1 , 10 , false ) then
4343: LD_EXP 35
4347: PPUSH
4348: LD_INT 35
4350: PPUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 10
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 50
4364: NOT
4365: IFFALSE 4382
// PlaceUnitArea ( Car2 , odjezd , false ) ;
4367: LD_EXP 35
4371: PPUSH
4372: LD_INT 5
4374: PPUSH
4375: LD_INT 0
4377: PPUSH
4378: CALL_OW 49
// if not PlaceUnitXYR ( Car3 , 35 , 1 , 10 , false ) then
4382: LD_EXP 36
4386: PPUSH
4387: LD_INT 35
4389: PPUSH
4390: LD_INT 1
4392: PPUSH
4393: LD_INT 10
4395: PPUSH
4396: LD_INT 0
4398: PPUSH
4399: CALL_OW 50
4403: NOT
4404: IFFALSE 4421
// PlaceUnitArea ( Car3 , odjezd , false ) ;
4406: LD_EXP 36
4410: PPUSH
4411: LD_INT 5
4413: PPUSH
4414: LD_INT 0
4416: PPUSH
4417: CALL_OW 49
// ComMoveXY ( [ Car1 , Car2 , Car3 ] , 37 , 8 ) ;
4421: LD_EXP 34
4425: PUSH
4426: LD_EXP 35
4430: PUSH
4431: LD_EXP 36
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PPUSH
4441: LD_INT 37
4443: PPUSH
4444: LD_INT 8
4446: PPUSH
4447: CALL_OW 111
// AddComStand ( [ Car1 , Car2 , Car3 ] ) ;
4451: LD_EXP 34
4455: PUSH
4456: LD_EXP 35
4460: PUSH
4461: LD_EXP 36
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: PPUSH
4471: CALL_OW 225
// CenterNowOnUnits ( Car1 ) ;
4475: LD_EXP 34
4479: PPUSH
4480: CALL_OW 87
// Wait ( 0 0$3 ) ;
4484: LD_INT 105
4486: PPUSH
4487: CALL_OW 67
// DialogueOn ;
4491: CALL_OW 6
// Say ( Mec1 , D4-Mech1-1 ) ;
4495: LD_EXP 31
4499: PPUSH
4500: LD_STRING D4-Mech1-1
4502: PPUSH
4503: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4507: LD_EXP 17
4511: PPUSH
4512: LD_STRING D4-JMM-1
4514: PPUSH
4515: CALL_OW 88
// Say ( Mec1 , D4-Mech1-2 ) ;
4519: LD_EXP 31
4523: PPUSH
4524: LD_STRING D4-Mech1-2
4526: PPUSH
4527: CALL_OW 88
// AddResourceType ( GetBase ( Depot1 ) , mat_cans , 300 ) ;
4531: LD_EXP 69
4535: PPUSH
4536: CALL_OW 274
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: LD_INT 300
4546: PPUSH
4547: CALL_OW 276
// qr := 0 ;
4551: LD_ADDR_VAR 0 1
4555: PUSH
4556: LD_INT 0
4558: ST_TO_ADDR
// if KolikMaBytSiberitu > GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4559: LD_EXP 66
4563: PUSH
4564: LD_EXP 69
4568: PPUSH
4569: CALL_OW 274
4573: PPUSH
4574: LD_INT 3
4576: PPUSH
4577: CALL_OW 275
4581: GREATER
4582: IFFALSE 4674
// begin qr := Query ( QWait ) ;
4584: LD_ADDR_VAR 0 1
4588: PUSH
4589: LD_STRING QWait
4591: PPUSH
4592: CALL_OW 97
4596: ST_TO_ADDR
// case qr of 1 :
4597: LD_VAR 0 1
4601: PUSH
4602: LD_INT 1
4604: DOUBLE
4605: EQUAL
4606: IFTRUE 4610
4608: GO 4625
4610: POP
// Say ( JMM , D5a-JMM-1 ) ; 2 :
4611: LD_EXP 17
4615: PPUSH
4616: LD_STRING D5a-JMM-1
4618: PPUSH
4619: CALL_OW 88
4623: GO 4672
4625: LD_INT 2
4627: DOUBLE
4628: EQUAL
4629: IFTRUE 4633
4631: GO 4648
4633: POP
// Say ( JMM , D5b-JMM-1 ) ; 3 :
4634: LD_EXP 17
4638: PPUSH
4639: LD_STRING D5b-JMM-1
4641: PPUSH
4642: CALL_OW 88
4646: GO 4672
4648: LD_INT 3
4650: DOUBLE
4651: EQUAL
4652: IFTRUE 4656
4654: GO 4671
4656: POP
// Say ( JMM , D5c-JMM-1 ) ; end ;
4657: LD_EXP 17
4661: PPUSH
4662: LD_STRING D5c-JMM-1
4664: PPUSH
4665: CALL_OW 88
4669: GO 4672
4671: POP
// end else
4672: GO 4686
// Say ( JMM , D5-JMM-1 ) ;
4674: LD_EXP 17
4678: PPUSH
4679: LD_STRING D5-JMM-1
4681: PPUSH
4682: CALL_OW 88
// DialogueOff ;
4686: CALL_OW 7
// if qr = 1 then
4690: LD_VAR 0 1
4694: PUSH
4695: LD_INT 1
4697: EQUAL
4698: IFFALSE 4721
// begin counter_time := tick + 5 5$0 ;
4700: LD_ADDR_EXP 64
4704: PUSH
4705: LD_OWVAR 1
4709: PUSH
4710: LD_INT 10500
4712: PLUS
4713: ST_TO_ADDR
// Wait ( 5 5$0 ) ;
4714: LD_INT 10500
4716: PPUSH
4717: CALL_OW 67
// end ; if qr = 2 or qr = 3 then
4721: LD_VAR 0 1
4725: PUSH
4726: LD_INT 2
4728: EQUAL
4729: PUSH
4730: LD_VAR 0 1
4734: PUSH
4735: LD_INT 3
4737: EQUAL
4738: OR
4739: IFFALSE 4749
// NastvalPowella := true ;
4741: LD_ADDR_EXP 57
4745: PUSH
4746: LD_INT 1
4748: ST_TO_ADDR
// DialogueOn ;
4749: CALL_OW 6
// if KolikMaBytSiberitu <= GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4753: LD_EXP 66
4757: PUSH
4758: LD_EXP 69
4762: PPUSH
4763: CALL_OW 274
4767: PPUSH
4768: LD_INT 3
4770: PPUSH
4771: CALL_OW 275
4775: LESSEQUAL
4776: IFFALSE 4792
// Say ( Mec1 , D6-Mech1-1 ) else
4778: LD_EXP 31
4782: PPUSH
4783: LD_STRING D6-Mech1-1
4785: PPUSH
4786: CALL_OW 88
4790: GO 4849
// begin NastvalPowella := true ;
4792: LD_ADDR_EXP 57
4796: PUSH
4797: LD_INT 1
4799: ST_TO_ADDR
// if 0 < GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4800: LD_INT 0
4802: PUSH
4803: LD_EXP 69
4807: PPUSH
4808: CALL_OW 274
4812: PPUSH
4813: LD_INT 3
4815: PPUSH
4816: CALL_OW 275
4820: LESS
4821: IFFALSE 4837
// Say ( Mec1 , D6-Mech1-1a ) else
4823: LD_EXP 31
4827: PPUSH
4828: LD_STRING D6-Mech1-1a
4830: PPUSH
4831: CALL_OW 88
4835: GO 4849
// Say ( Mec1 , D6-Mech1-1b ) ;
4837: LD_EXP 31
4841: PPUSH
4842: LD_STRING D6-Mech1-1b
4844: PPUSH
4845: CALL_OW 88
// end ; DialogueOff ;
4849: CALL_OW 7
// counter_time := 0 ;
4853: LD_ADDR_EXP 64
4857: PUSH
4858: LD_INT 0
4860: ST_TO_ADDR
// if GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > KolikMaBytSiberitu then
4861: LD_EXP 69
4865: PPUSH
4866: CALL_OW 274
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: CALL_OW 275
4878: PUSH
4879: LD_EXP 66
4883: GREATER
4884: IFFALSE 4931
// begin SetCargo ( [ Car1 ] , mat_siberit , KolikMaBytSiberitu ) ;
4886: LD_EXP 34
4890: PUSH
4891: EMPTY
4892: LIST
4893: PPUSH
4894: LD_INT 3
4896: PPUSH
4897: LD_EXP 66
4901: PPUSH
4902: CALL_OW 290
// AddResourceType ( GetBase ( Depot1 ) , mat_siberit , - KolikMaBytSiberitu ) ;
4906: LD_EXP 69
4910: PPUSH
4911: CALL_OW 274
4915: PPUSH
4916: LD_INT 3
4918: PPUSH
4919: LD_EXP 66
4923: NEG
4924: PPUSH
4925: CALL_OW 276
// end else
4929: GO 4984
// begin SetCargo ( [ Car1 ] , mat_siberit , GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) ) ;
4931: LD_EXP 34
4935: PUSH
4936: EMPTY
4937: LIST
4938: PPUSH
4939: LD_INT 3
4941: PPUSH
4942: LD_EXP 69
4946: PPUSH
4947: CALL_OW 274
4951: PPUSH
4952: LD_INT 3
4954: PPUSH
4955: CALL_OW 275
4959: PPUSH
4960: CALL_OW 290
// SetResourceType ( GetBase ( Depot1 ) , mat_siberit , 0 ) ;
4964: LD_EXP 69
4968: PPUSH
4969: CALL_OW 274
4973: PPUSH
4974: LD_INT 3
4976: PPUSH
4977: LD_INT 0
4979: PPUSH
4980: CALL_OW 277
// end ; mt := tick + 0 0$20 ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_OWVAR 1
4993: PUSH
4994: LD_INT 700
4996: PLUS
4997: ST_TO_ADDR
// while UnitFilter ( [ Car1 , Car2 , Car3 ] , [ [ f_placed ] ] ) and mt < tick do
4998: LD_EXP 34
5002: PUSH
5003: LD_EXP 35
5007: PUSH
5008: LD_EXP 36
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: LIST
5017: PPUSH
5018: LD_INT 52
5020: PUSH
5021: EMPTY
5022: LIST
5023: PUSH
5024: EMPTY
5025: LIST
5026: PPUSH
5027: CALL_OW 72
5031: PUSH
5032: LD_VAR 0 3
5036: PUSH
5037: LD_OWVAR 1
5041: LESS
5042: AND
5043: IFFALSE 5205
// begin ComMoveToArea ( [ Car1 , Car2 , Car3 ] , odjezd ) ;
5045: LD_EXP 34
5049: PUSH
5050: LD_EXP 35
5054: PUSH
5055: LD_EXP 36
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: LIST
5064: PPUSH
5065: LD_INT 5
5067: PPUSH
5068: CALL_OW 113
// AddComMoveXY ( [ Car1 , Car2 , Car3 ] , 38 , 1 ) ;
5072: LD_EXP 34
5076: PUSH
5077: LD_EXP 35
5081: PUSH
5082: LD_EXP 36
5086: PUSH
5087: EMPTY
5088: LIST
5089: LIST
5090: LIST
5091: PPUSH
5092: LD_INT 38
5094: PPUSH
5095: LD_INT 1
5097: PPUSH
5098: CALL_OW 171
// case true of IsInArea ( Car1 , odjezd ) :
5102: LD_INT 1
5104: PUSH
5105: LD_EXP 34
5109: PPUSH
5110: LD_INT 5
5112: PPUSH
5113: CALL_OW 308
5117: DOUBLE
5118: EQUAL
5119: IFTRUE 5123
5121: GO 5135
5123: POP
// RemoveUnit ( Car1 ) ; IsInArea ( Car2 , odjezd ) :
5124: LD_EXP 34
5128: PPUSH
5129: CALL_OW 64
5133: GO 5196
5135: LD_EXP 35
5139: PPUSH
5140: LD_INT 5
5142: PPUSH
5143: CALL_OW 308
5147: DOUBLE
5148: EQUAL
5149: IFTRUE 5153
5151: GO 5165
5153: POP
// RemoveUnit ( Car2 ) ; IsInArea ( Car3 , odjezd ) :
5154: LD_EXP 35
5158: PPUSH
5159: CALL_OW 64
5163: GO 5196
5165: LD_EXP 36
5169: PPUSH
5170: LD_INT 5
5172: PPUSH
5173: CALL_OW 308
5177: DOUBLE
5178: EQUAL
5179: IFTRUE 5183
5181: GO 5195
5183: POP
// RemoveUnit ( Car3 ) ; end ;
5184: LD_EXP 36
5188: PPUSH
5189: CALL_OW 64
5193: GO 5196
5195: POP
// wait ( 0 0$1 ) ;
5196: LD_INT 35
5198: PPUSH
5199: CALL_OW 67
// end ;
5203: GO 4998
// for i in [ Car1 , Car2 , Car3 , Mec1 , Mec2 , Mec3 ] do
5205: LD_ADDR_VAR 0 2
5209: PUSH
5210: LD_EXP 34
5214: PUSH
5215: LD_EXP 35
5219: PUSH
5220: LD_EXP 36
5224: PUSH
5225: LD_EXP 31
5229: PUSH
5230: LD_EXP 32
5234: PUSH
5235: LD_EXP 33
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: FOR_IN
5249: IFFALSE 5262
// RemoveUnit ( i ) ;
5251: LD_VAR 0 2
5255: PPUSH
5256: CALL_OW 64
5260: GO 5248
5262: POP
5263: POP
// if NastvalPowella then
5264: LD_EXP 57
5268: IFFALSE 5279
// ChangeMissionObjectives ( M3b ) else
5270: LD_STRING M3b
5272: PPUSH
5273: CALL_OW 337
5277: GO 5286
// ChangeMissionObjectives ( M3a ) ;
5279: LD_STRING M3a
5281: PPUSH
5282: CALL_OW 337
// end ;
5286: PPOPN 3
5288: END
// every 0 0$5 trigger GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > 35 do var r ;
5289: LD_EXP 69
5293: PPUSH
5294: CALL_OW 274
5298: PPUSH
5299: LD_INT 3
5301: PPUSH
5302: CALL_OW 275
5306: PUSH
5307: LD_INT 35
5309: GREATER
5310: IFFALSE 5481
5312: GO 5314
5314: DISABLE
5315: LD_INT 0
5317: PPUSH
// begin Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , class_scientistic , 0 ) ;
5318: LD_ADDR_EXP 25
5322: PUSH
5323: LD_EXP 58
5327: PUSH
5328: LD_EXP 61
5332: DIFF
5333: PPUSH
5334: LD_EXP 47
5338: PPUSH
5339: LD_INT 1
5341: PPUSH
5342: LD_INT 4
5344: PPUSH
5345: LD_INT 0
5347: PPUSH
5348: CALL 13224 0 5
5352: ST_TO_ADDR
// if not Sci1 then
5353: LD_EXP 25
5357: NOT
5358: IFFALSE 5395
// Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , 0 , 0 ) ;
5360: LD_ADDR_EXP 25
5364: PUSH
5365: LD_EXP 58
5369: PUSH
5370: LD_EXP 61
5374: DIFF
5375: PPUSH
5376: LD_EXP 47
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: LD_INT 0
5386: PPUSH
5387: LD_INT 0
5389: PPUSH
5390: CALL 13224 0 5
5394: ST_TO_ADDR
// if Sci1 then
5395: LD_EXP 25
5399: IFFALSE 5481
// begin DialogueOn ;
5401: CALL_OW 6
// Say ( Sci1 , D7-Sci1-1 ) ;
5405: LD_EXP 25
5409: PPUSH
5410: LD_STRING D7-Sci1-1
5412: PPUSH
5413: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5417: LD_EXP 17
5421: PPUSH
5422: LD_STRING D7-JMM-1
5424: PPUSH
5425: CALL_OW 88
// Say ( Sci1 , D7-Sci1-2 ) ;
5429: LD_EXP 25
5433: PPUSH
5434: LD_STRING D7-Sci1-2
5436: PPUSH
5437: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5441: LD_EXP 17
5445: PPUSH
5446: LD_STRING D7-JMM-2
5448: PPUSH
5449: CALL_OW 88
// Say ( Sci1 , D7-Sci1-3 ) ;
5453: LD_EXP 25
5457: PPUSH
5458: LD_STRING D7-Sci1-3
5460: PPUSH
5461: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5465: LD_EXP 17
5469: PPUSH
5470: LD_STRING D7-JMM-3
5472: PPUSH
5473: CALL_OW 88
// DialogueOff ;
5477: CALL_OW 7
// end ; end ;
5481: PPOPN 1
5483: END
// export ArmStarted ; export BarStarted ; function odnes_jeden_oil ; var a ; begin
5484: LD_INT 0
5486: PPUSH
5487: PPUSH
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5488: LD_EXP 40
5492: PPUSH
5493: LD_EXP 67
5497: PPUSH
5498: CALL_OW 296
5502: PUSH
5503: LD_INT 4
5505: GREATER
5506: IFFALSE 5531
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5508: LD_EXP 40
5512: PPUSH
5513: LD_EXP 67
5517: PPUSH
5518: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5522: LD_INT 4
5524: PPUSH
5525: CALL_OW 67
// end ;
5529: GO 5488
// ComStop ( Ara2 ) ;
5531: LD_EXP 40
5535: PPUSH
5536: CALL_OW 141
// ComHold ( Ara2 ) ;
5540: LD_EXP 40
5544: PPUSH
5545: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5549: LD_EXP 40
5553: PPUSH
5554: LD_INT 2
5556: PPUSH
5557: LD_INT 10
5559: PPUSH
5560: CALL_OW 290
// a := GetFuel ( AraCar1 ) ;
5564: LD_ADDR_VAR 0 2
5568: PUSH
5569: LD_EXP 44
5573: PPUSH
5574: CALL_OW 261
5578: ST_TO_ADDR
// while GetFuel ( AraCar1 ) <= a do
5579: LD_EXP 44
5583: PPUSH
5584: CALL_OW 261
5588: PUSH
5589: LD_VAR 0 2
5593: LESSEQUAL
5594: IFFALSE 5619
// begin ComRefuel ( Ara2 , AraCar1 ) ;
5596: LD_EXP 40
5600: PPUSH
5601: LD_EXP 44
5605: PPUSH
5606: CALL_OW 150
// wait ( 0 0$1 ) ;
5610: LD_INT 35
5612: PPUSH
5613: CALL_OW 67
// end ;
5617: GO 5579
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5619: LD_EXP 40
5623: PPUSH
5624: LD_INT 2
5626: PPUSH
5627: LD_INT 0
5629: PPUSH
5630: CALL_OW 290
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5634: LD_EXP 40
5638: PPUSH
5639: LD_EXP 67
5643: PPUSH
5644: CALL_OW 296
5648: PUSH
5649: LD_INT 4
5651: GREATER
5652: IFFALSE 5677
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5654: LD_EXP 40
5658: PPUSH
5659: LD_EXP 67
5663: PPUSH
5664: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5668: LD_INT 4
5670: PPUSH
5671: CALL_OW 67
// end ;
5675: GO 5634
// ComStop ( Ara2 ) ;
5677: LD_EXP 40
5681: PPUSH
5682: CALL_OW 141
// ComHold ( Ara2 ) ;
5686: LD_EXP 40
5690: PPUSH
5691: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5695: LD_EXP 40
5699: PPUSH
5700: LD_INT 2
5702: PPUSH
5703: LD_INT 10
5705: PPUSH
5706: CALL_OW 290
// a := GetFuel ( AraCar2 ) ;
5710: LD_ADDR_VAR 0 2
5714: PUSH
5715: LD_EXP 45
5719: PPUSH
5720: CALL_OW 261
5724: ST_TO_ADDR
// while GetFuel ( AraCar2 ) <= a do
5725: LD_EXP 45
5729: PPUSH
5730: CALL_OW 261
5734: PUSH
5735: LD_VAR 0 2
5739: LESSEQUAL
5740: IFFALSE 5765
// begin ComRefuel ( Ara2 , AraCar2 ) ;
5742: LD_EXP 40
5746: PPUSH
5747: LD_EXP 45
5751: PPUSH
5752: CALL_OW 150
// wait ( 0 0$1 ) ;
5756: LD_INT 35
5758: PPUSH
5759: CALL_OW 67
// end ;
5763: GO 5725
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5765: LD_EXP 40
5769: PPUSH
5770: LD_INT 2
5772: PPUSH
5773: LD_INT 0
5775: PPUSH
5776: CALL_OW 290
// ComStop ( Ara2 ) ;
5780: LD_EXP 40
5784: PPUSH
5785: CALL_OW 141
// ComHold ( Ara2 ) ;
5789: LD_EXP 40
5793: PPUSH
5794: CALL_OW 140
// result := true ;
5798: LD_ADDR_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// end ;
5806: LD_VAR 0 1
5810: RET
// function odnes_neco ( mat , kolik ) ; var a , i ; begin
5811: LD_INT 0
5813: PPUSH
5814: PPUSH
5815: PPUSH
// for i := 1 to ( kolik div 10 ) do
5816: LD_ADDR_VAR 0 5
5820: PUSH
5821: DOUBLE
5822: LD_INT 1
5824: DEC
5825: ST_TO_ADDR
5826: LD_VAR 0 2
5830: PUSH
5831: LD_INT 10
5833: DIV
5834: PUSH
5835: FOR_TO
5836: IFFALSE 6009
// begin while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5838: LD_EXP 40
5842: PPUSH
5843: LD_EXP 67
5847: PPUSH
5848: CALL_OW 296
5852: PUSH
5853: LD_INT 4
5855: GREATER
5856: IFFALSE 5881
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5858: LD_EXP 40
5862: PPUSH
5863: LD_EXP 67
5867: PPUSH
5868: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5872: LD_INT 4
5874: PPUSH
5875: CALL_OW 67
// end ;
5879: GO 5838
// ComHold ( Ara2 ) ;
5881: LD_EXP 40
5885: PPUSH
5886: CALL_OW 140
// SetCargo ( Ara2 , mat , 10 ) ;
5890: LD_EXP 40
5894: PPUSH
5895: LD_VAR 0 1
5899: PPUSH
5900: LD_INT 10
5902: PPUSH
5903: CALL_OW 290
// a := GetCargo ( AraCar2 , mat ) ;
5907: LD_ADDR_VAR 0 4
5911: PUSH
5912: LD_EXP 45
5916: PPUSH
5917: LD_VAR 0 1
5921: PPUSH
5922: CALL_OW 289
5926: ST_TO_ADDR
// while GetCargo ( AraCar2 , mat ) <= a do
5927: LD_EXP 45
5931: PPUSH
5932: LD_VAR 0 1
5936: PPUSH
5937: CALL_OW 289
5941: PUSH
5942: LD_VAR 0 4
5946: LESSEQUAL
5947: IFFALSE 5972
// begin ComMoveUnit ( Ara2 , AraCar2 ) ;
5949: LD_EXP 40
5953: PPUSH
5954: LD_EXP 45
5958: PPUSH
5959: CALL_OW 112
// wait ( 0 0$1 ) ;
5963: LD_INT 35
5965: PPUSH
5966: CALL_OW 67
// end ;
5970: GO 5927
// SetCargo ( Ara2 , mat , 0 ) ;
5972: LD_EXP 40
5976: PPUSH
5977: LD_VAR 0 1
5981: PPUSH
5982: LD_INT 0
5984: PPUSH
5985: CALL_OW 290
// ComStop ( Ara2 ) ;
5989: LD_EXP 40
5993: PPUSH
5994: CALL_OW 141
// ComHold ( Ara2 ) ;
5998: LD_EXP 40
6002: PPUSH
6003: CALL_OW 140
// end ;
6007: GO 5835
6009: POP
6010: POP
// result := true ;
6011: LD_ADDR_VAR 0 3
6015: PUSH
6016: LD_INT 1
6018: ST_TO_ADDR
// end ;
6019: LD_VAR 0 3
6023: RET
// every 0 0$1 do var mt ;
6024: GO 6026
6026: DISABLE
6027: LD_INT 0
6029: PPUSH
// begin if arabi_time <> 0 then
6030: LD_EXP 1
6034: PUSH
6035: LD_INT 0
6037: NONEQUAL
6038: IFFALSE 6186
// if arabi_time > 1 then
6040: LD_EXP 1
6044: PUSH
6045: LD_INT 1
6047: GREATER
6048: IFFALSE 6186
// begin wait ( arabi_time ) ;
6050: LD_EXP 1
6054: PPUSH
6055: CALL_OW 67
// mt := tick + 3 3$0 ;
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_OWVAR 1
6068: PUSH
6069: LD_INT 6300
6071: PLUS
6072: ST_TO_ADDR
// while Getside ( rudepot1 ) <> you and mt > tick do
6073: LD_EXP 67
6077: PPUSH
6078: CALL_OW 255
6082: PUSH
6083: LD_EXP 47
6087: NONEQUAL
6088: PUSH
6089: LD_VAR 0 1
6093: PUSH
6094: LD_OWVAR 1
6098: GREATER
6099: AND
6100: IFFALSE 6111
// wait ( 0 0$3 ) ;
6102: LD_INT 105
6104: PPUSH
6105: CALL_OW 67
6109: GO 6073
// if Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 then
6111: LD_EXP 67
6115: PPUSH
6116: CALL_OW 255
6120: PUSH
6121: LD_EXP 47
6125: EQUAL
6126: PUSH
6127: LD_INT 22
6129: PUSH
6130: LD_EXP 47
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PUSH
6139: LD_INT 2
6141: PUSH
6142: LD_INT 21
6144: PUSH
6145: LD_INT 1
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PUSH
6152: LD_INT 21
6154: PUSH
6155: LD_INT 2
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PPUSH
6171: CALL_OW 69
6175: PUSH
6176: LD_INT 0
6178: GREATER
6179: AND
6180: IFFALSE 6186
// arabi ;
6182: CALL 6278 0 0
// end ; end ;
6186: PPOPN 1
6188: END
// every 27 27$0 trigger arabi_time = 0 and Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do
6189: LD_EXP 1
6193: PUSH
6194: LD_INT 0
6196: EQUAL
6197: PUSH
6198: LD_EXP 67
6202: PPUSH
6203: CALL_OW 255
6207: PUSH
6208: LD_EXP 47
6212: EQUAL
6213: AND
6214: PUSH
6215: LD_INT 22
6217: PUSH
6218: LD_EXP 47
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 2
6229: PUSH
6230: LD_INT 21
6232: PUSH
6233: LD_INT 1
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 21
6242: PUSH
6243: LD_INT 2
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PPUSH
6259: CALL_OW 69
6263: PUSH
6264: LD_INT 0
6266: GREATER
6267: AND
6268: IFFALSE 6277
6270: GO 6272
6272: DISABLE
// begin arabi ;
6273: CALL 6278 0 0
// end ;
6277: END
// export kecy , mina1 , mina3 ; function arabi ; var cekani , qr , nabidka , i , a , mytick , to_reach , ara1_faze , ara3_faze , odmitl_v_query ; begin
6278: LD_INT 0
6280: PPUSH
6281: PPUSH
6282: PPUSH
6283: PPUSH
6284: PPUSH
6285: PPUSH
6286: PPUSH
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
// PlaceUnitArea ( Ara1 , rus_mat_l , false ) ;
6291: LD_EXP 39
6295: PPUSH
6296: LD_INT 3
6298: PPUSH
6299: LD_INT 0
6301: PPUSH
6302: CALL_OW 49
// PlaceUnitArea ( Ara2 , rus_mat_l , false ) ;
6306: LD_EXP 40
6310: PPUSH
6311: LD_INT 3
6313: PPUSH
6314: LD_INT 0
6316: PPUSH
6317: CALL_OW 49
// PlaceUnitArea ( Ara3 , rus_mat_l , false ) ;
6321: LD_EXP 41
6325: PPUSH
6326: LD_INT 3
6328: PPUSH
6329: LD_INT 0
6331: PPUSH
6332: CALL_OW 49
// PlaceUnitArea ( AraCar1 , rus_mat_l , false ) ;
6336: LD_EXP 44
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: LD_INT 0
6346: PPUSH
6347: CALL_OW 49
// PlaceUnitArea ( AraCar2 , rus_mat_l , false ) ;
6351: LD_EXP 45
6355: PPUSH
6356: LD_INT 3
6358: PPUSH
6359: LD_INT 0
6361: PPUSH
6362: CALL_OW 49
// ComHold ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] ) ;
6366: LD_EXP 39
6370: PUSH
6371: LD_EXP 40
6375: PUSH
6376: LD_EXP 41
6380: PUSH
6381: LD_EXP 42
6385: PUSH
6386: LD_EXP 43
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: LIST
6396: LIST
6397: PPUSH
6398: CALL_OW 140
// DialogueOn ;
6402: CALL_OW 6
// SayRadio ( Ara1 , D8-Ar1-1 ) ;
6406: LD_EXP 39
6410: PPUSH
6411: LD_STRING D8-Ar1-1
6413: PPUSH
6414: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6418: LD_EXP 17
6422: PPUSH
6423: LD_STRING D8-JMM-1
6425: PPUSH
6426: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-2 ) ;
6430: LD_EXP 39
6434: PPUSH
6435: LD_STRING D8-Ar1-2
6437: PPUSH
6438: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6442: LD_EXP 17
6446: PPUSH
6447: LD_STRING D8-JMM-2
6449: PPUSH
6450: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-3 ) ;
6454: LD_EXP 39
6458: PPUSH
6459: LD_STRING D8-Ar1-3
6461: PPUSH
6462: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6466: LD_EXP 17
6470: PPUSH
6471: LD_STRING D8-JMM-3
6473: PPUSH
6474: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-4 ) ;
6478: LD_EXP 39
6482: PPUSH
6483: LD_STRING D8-Ar1-4
6485: PPUSH
6486: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6490: LD_EXP 17
6494: PPUSH
6495: LD_STRING D8-JMM-4
6497: PPUSH
6498: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-5 ) ;
6502: LD_EXP 39
6506: PPUSH
6507: LD_STRING D8-Ar1-5
6509: PPUSH
6510: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6514: LD_EXP 17
6518: PPUSH
6519: LD_STRING D8-JMM-5
6521: PPUSH
6522: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-6 ) ;
6526: LD_EXP 39
6530: PPUSH
6531: LD_STRING D8-Ar1-6
6533: PPUSH
6534: CALL_OW 94
// SayRadio ( Ara2 , D8-Ar2-6 ) ;
6538: LD_EXP 40
6542: PPUSH
6543: LD_STRING D8-Ar2-6
6545: PPUSH
6546: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6550: LD_EXP 17
6554: PPUSH
6555: LD_STRING D8-JMM-6
6557: PPUSH
6558: CALL_OW 88
// SayRadio ( Ara2 , D8-Ar2-7 ) ;
6562: LD_EXP 40
6566: PPUSH
6567: LD_STRING D8-Ar2-7
6569: PPUSH
6570: CALL_OW 94
// Aqr1 := Query ( QBarracks ) ;
6574: LD_ADDR_EXP 37
6578: PUSH
6579: LD_STRING QBarracks
6581: PPUSH
6582: CALL_OW 97
6586: ST_TO_ADDR
// case Aqr1 of 1 :
6587: LD_EXP 37
6591: PUSH
6592: LD_INT 1
6594: DOUBLE
6595: EQUAL
6596: IFTRUE 6600
6598: GO 6627
6600: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6601: LD_EXP 17
6605: PPUSH
6606: LD_STRING D8a-JMM-1
6608: PPUSH
6609: CALL_OW 88
// SayRadio ( Ara1 , D8a-Ar1-1 ) ;
6613: LD_EXP 39
6617: PPUSH
6618: LD_STRING D8a-Ar1-1
6620: PPUSH
6621: CALL_OW 94
// end ; 2 :
6625: GO 6803
6627: LD_INT 2
6629: DOUBLE
6630: EQUAL
6631: IFTRUE 6635
6633: GO 6759
6635: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6636: LD_EXP 17
6640: PPUSH
6641: LD_STRING D8b-JMM-1
6643: PPUSH
6644: CALL_OW 88
// SayRadio ( Ara1 , D8b-Ar1-1 ) ;
6648: LD_EXP 39
6652: PPUSH
6653: LD_STRING D8b-Ar1-1
6655: PPUSH
6656: CALL_OW 94
// Aqr2 := Query ( QInfo ) ;
6660: LD_ADDR_EXP 38
6664: PUSH
6665: LD_STRING QInfo
6667: PPUSH
6668: CALL_OW 97
6672: ST_TO_ADDR
// case Aqr2 of 1 :
6673: LD_EXP 38
6677: PUSH
6678: LD_INT 1
6680: DOUBLE
6681: EQUAL
6682: IFTRUE 6686
6684: GO 6713
6686: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6687: LD_EXP 17
6691: PPUSH
6692: LD_STRING D8b1-JMM-1
6694: PPUSH
6695: CALL_OW 88
// SayRadio ( Ara1 , D8b1-Ar1-1 ) ;
6699: LD_EXP 39
6703: PPUSH
6704: LD_STRING D8b1-Ar1-1
6706: PPUSH
6707: CALL_OW 94
// end ; 2 :
6711: GO 6757
6713: LD_INT 2
6715: DOUBLE
6716: EQUAL
6717: IFTRUE 6721
6719: GO 6756
6721: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6722: LD_EXP 17
6726: PPUSH
6727: LD_STRING D8b2-JMM-1
6729: PPUSH
6730: CALL_OW 88
// SayRadio ( Ara1 , D8b2-Ar1-1 ) ;
6734: LD_EXP 39
6738: PPUSH
6739: LD_STRING D8b2-Ar1-1
6741: PPUSH
6742: CALL_OW 94
// odmitl_v_query := true ;
6746: LD_ADDR_VAR 0 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// end ; end ;
6754: GO 6757
6756: POP
// end ; 3 :
6757: GO 6803
6759: LD_INT 3
6761: DOUBLE
6762: EQUAL
6763: IFTRUE 6767
6765: GO 6802
6767: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6768: LD_EXP 17
6772: PPUSH
6773: LD_STRING D8c-JMM-1
6775: PPUSH
6776: CALL_OW 88
// odmitl_v_query := true ;
6780: LD_ADDR_VAR 0 11
6784: PUSH
6785: LD_INT 1
6787: ST_TO_ADDR
// SayRadio ( Ara1 , D8c-Ar1-1 ) ;
6788: LD_EXP 39
6792: PPUSH
6793: LD_STRING D8c-Ar1-1
6795: PPUSH
6796: CALL_OW 94
// end ; end ;
6800: GO 6803
6802: POP
// DialogueOff ;
6803: CALL_OW 7
// if Aqr1 = 1 or ( Aqr1 = 2 and Aqr2 = 1 ) then
6807: LD_EXP 37
6811: PUSH
6812: LD_INT 1
6814: EQUAL
6815: PUSH
6816: LD_EXP 37
6820: PUSH
6821: LD_INT 2
6823: EQUAL
6824: PUSH
6825: LD_EXP 38
6829: PUSH
6830: LD_INT 1
6832: EQUAL
6833: AND
6834: OR
6835: IFFALSE 9628
// begin ComMoveToArea ( AraCar1 , pod_base ) ;
6837: LD_EXP 44
6841: PPUSH
6842: LD_INT 30
6844: PPUSH
6845: CALL_OW 113
// wait ( 0 0$1 ) ;
6849: LD_INT 35
6851: PPUSH
6852: CALL_OW 67
// ComMoveToArea ( AraCar2 , pod_base ) ;
6856: LD_EXP 45
6860: PPUSH
6861: LD_INT 30
6863: PPUSH
6864: CALL_OW 113
// ComWait ( [ Ara1 , Ara2 , Ara3 ] , 0 0$4 ) ;
6868: LD_EXP 39
6872: PUSH
6873: LD_EXP 40
6877: PUSH
6878: LD_EXP 41
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: LIST
6887: PPUSH
6888: LD_INT 140
6890: PPUSH
6891: CALL_OW 142
// AddComMoveToArea ( [ Ara1 , Ara2 , Ara3 ] , in_base ) ;
6895: LD_EXP 39
6899: PUSH
6900: LD_EXP 40
6904: PUSH
6905: LD_EXP 41
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PPUSH
6915: LD_INT 21
6917: PPUSH
6918: CALL_OW 173
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 ] , 95 , 98 ) ;
6922: LD_EXP 39
6926: PUSH
6927: LD_EXP 40
6931: PUSH
6932: LD_EXP 41
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: PPUSH
6942: LD_INT 95
6944: PPUSH
6945: LD_INT 98
6947: PPUSH
6948: CALL_OW 171
// AddComMoveToArea ( [ Ara1 , Ara3 ] , for_charge ) ;
6952: LD_EXP 39
6956: PUSH
6957: LD_EXP 41
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PPUSH
6966: LD_INT 29
6968: PPUSH
6969: CALL_OW 173
// AddComPlaceRemoteCharge ( Ara1 , 0 , 0 , rudepot1 ) ;
6973: LD_EXP 39
6977: PPUSH
6978: LD_INT 0
6980: PPUSH
6981: LD_INT 0
6983: PPUSH
6984: LD_EXP 67
6988: PPUSH
6989: CALL_OW 193
// AddComPlaceRemoteCharge ( Ara3 , 0 , 0 , rudepot1 ) ;
6993: LD_EXP 41
6997: PPUSH
6998: LD_INT 0
7000: PPUSH
7001: LD_INT 0
7003: PPUSH
7004: LD_EXP 67
7008: PPUSH
7009: CALL_OW 193
// AddComMoveToArea ( [ Ara1 , Ara3 ] , pod_base ) ;
7013: LD_EXP 39
7017: PUSH
7018: LD_EXP 41
7022: PUSH
7023: EMPTY
7024: LIST
7025: LIST
7026: PPUSH
7027: LD_INT 30
7029: PPUSH
7030: CALL_OW 173
// mytick := tick + 2 2$30 ;
7034: LD_ADDR_VAR 0 7
7038: PUSH
7039: LD_OWVAR 1
7043: PUSH
7044: LD_INT 5250
7046: PLUS
7047: ST_TO_ADDR
// to_reach := [ AraCar1 , AraCar2 , Ara3 , Ara2 , Ara1 ] ;
7048: LD_ADDR_VAR 0 8
7052: PUSH
7053: LD_EXP 44
7057: PUSH
7058: LD_EXP 45
7062: PUSH
7063: LD_EXP 41
7067: PUSH
7068: LD_EXP 40
7072: PUSH
7073: LD_EXP 39
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: LIST
7083: LIST
7084: ST_TO_ADDR
// while mytick > tick and to_reach do
7085: LD_VAR 0 7
7089: PUSH
7090: LD_OWVAR 1
7094: GREATER
7095: PUSH
7096: LD_VAR 0 8
7100: AND
7101: IFFALSE 7361
// begin if IsInArea ( AraCar1 , pod_base ) or not IsOk ( AraCar1 ) then
7103: LD_EXP 44
7107: PPUSH
7108: LD_INT 30
7110: PPUSH
7111: CALL_OW 308
7115: PUSH
7116: LD_EXP 44
7120: PPUSH
7121: CALL_OW 302
7125: NOT
7126: OR
7127: IFFALSE 7148
// to_reach := to_reach diff [ AraCar1 ] ;
7129: LD_ADDR_VAR 0 8
7133: PUSH
7134: LD_VAR 0 8
7138: PUSH
7139: LD_EXP 44
7143: PUSH
7144: EMPTY
7145: LIST
7146: DIFF
7147: ST_TO_ADDR
// if IsInArea ( AraCar2 , pod_base ) or not IsOk ( AraCar2 ) then
7148: LD_EXP 45
7152: PPUSH
7153: LD_INT 30
7155: PPUSH
7156: CALL_OW 308
7160: PUSH
7161: LD_EXP 45
7165: PPUSH
7166: CALL_OW 302
7170: NOT
7171: OR
7172: IFFALSE 7193
// to_reach := to_reach diff [ AraCar2 ] ;
7174: LD_ADDR_VAR 0 8
7178: PUSH
7179: LD_VAR 0 8
7183: PUSH
7184: LD_EXP 45
7188: PUSH
7189: EMPTY
7190: LIST
7191: DIFF
7192: ST_TO_ADDR
// if IsInArea ( Ara1 , in_base ) or not IsOk ( Ara1 ) then
7193: LD_EXP 39
7197: PPUSH
7198: LD_INT 21
7200: PPUSH
7201: CALL_OW 308
7205: PUSH
7206: LD_EXP 39
7210: PPUSH
7211: CALL_OW 302
7215: NOT
7216: OR
7217: IFFALSE 7238
// to_reach := to_reach diff [ Ara1 ] ;
7219: LD_ADDR_VAR 0 8
7223: PUSH
7224: LD_VAR 0 8
7228: PUSH
7229: LD_EXP 39
7233: PUSH
7234: EMPTY
7235: LIST
7236: DIFF
7237: ST_TO_ADDR
// if IsInArea ( Ara2 , in_base ) or not IsOk ( Ara2 ) then
7238: LD_EXP 40
7242: PPUSH
7243: LD_INT 21
7245: PPUSH
7246: CALL_OW 308
7250: PUSH
7251: LD_EXP 40
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7283
// to_reach := to_reach diff [ Ara2 ] ;
7264: LD_ADDR_VAR 0 8
7268: PUSH
7269: LD_VAR 0 8
7273: PUSH
7274: LD_EXP 40
7278: PUSH
7279: EMPTY
7280: LIST
7281: DIFF
7282: ST_TO_ADDR
// if IsInArea ( Ara3 , in_base ) or not IsOk ( Ara3 ) then
7283: LD_EXP 41
7287: PPUSH
7288: LD_INT 21
7290: PPUSH
7291: CALL_OW 308
7295: PUSH
7296: LD_EXP 41
7300: PPUSH
7301: CALL_OW 302
7305: NOT
7306: OR
7307: IFFALSE 7328
// to_reach := to_reach diff [ Ara3 ] ;
7309: LD_ADDR_VAR 0 8
7313: PUSH
7314: LD_VAR 0 8
7318: PUSH
7319: LD_EXP 41
7323: PUSH
7324: EMPTY
7325: LIST
7326: DIFF
7327: ST_TO_ADDR
// ComMoveToArea ( AraCar1 , pod_base ) ;
7328: LD_EXP 44
7332: PPUSH
7333: LD_INT 30
7335: PPUSH
7336: CALL_OW 113
// ComMoveToArea ( AraCar2 , pod_base ) ;
7340: LD_EXP 45
7344: PPUSH
7345: LD_INT 30
7347: PPUSH
7348: CALL_OW 113
// wait ( 0 0$1 ) ;
7352: LD_INT 35
7354: PPUSH
7355: CALL_OW 67
// end ;
7359: GO 7085
// if Aqr1 = 1 then
7361: LD_EXP 37
7365: PUSH
7366: LD_INT 1
7368: EQUAL
7369: IFFALSE 7634
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7371: LD_EXP 67
7375: PPUSH
7376: CALL_OW 274
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: CALL_OW 275
7388: PUSH
7389: LD_INT 60
7391: LESS
7392: IFFALSE 7597
// begin DialogueOn ;
7394: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7398: LD_EXP 41
7402: PPUSH
7403: LD_STRING D9a-FAr1-1
7405: PPUSH
7406: CALL_OW 88
7410: IFFALSE 7424
// Say ( JMM , D9a-JMM-1 ) ;
7412: LD_EXP 17
7416: PPUSH
7417: LD_STRING D9a-JMM-1
7419: PPUSH
7420: CALL_OW 88
// DialogueOff ;
7424: CALL_OW 7
// cekani := 0 ;
7428: LD_ADDR_VAR 0 2
7432: PUSH
7433: LD_INT 0
7435: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 do
7436: LD_VAR 0 2
7440: PUSH
7441: LD_INT 60
7443: LESS
7444: PUSH
7445: LD_EXP 67
7449: PPUSH
7450: CALL_OW 274
7454: PPUSH
7455: LD_INT 2
7457: PPUSH
7458: CALL_OW 275
7462: PUSH
7463: LD_INT 60
7465: LESS
7466: AND
7467: IFFALSE 7492
// begin Wait ( 0 0$1 ) ;
7469: LD_INT 35
7471: PPUSH
7472: CALL_OW 67
// cekani := cekani + 1 ;
7476: LD_ADDR_VAR 0 2
7480: PUSH
7481: LD_VAR 0 2
7485: PUSH
7486: LD_INT 1
7488: PLUS
7489: ST_TO_ADDR
// end ;
7490: GO 7436
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7492: LD_EXP 67
7496: PPUSH
7497: CALL_OW 274
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: CALL_OW 275
7509: PUSH
7510: LD_INT 60
7512: LESS
7513: IFFALSE 7558
// begin DialogueOn ;
7515: CALL_OW 6
// Say ( Ara1 , D9a2-Ar1-1 ) ;
7519: LD_EXP 39
7523: PPUSH
7524: LD_STRING D9a2-Ar1-1
7526: PPUSH
7527: CALL_OW 88
// DialogueOff ;
7531: CALL_OW 7
// Aqr1 := 2 ;
7535: LD_ADDR_EXP 37
7539: PUSH
7540: LD_INT 2
7542: ST_TO_ADDR
// Aqr2 := Query ( QInfo ) ;
7543: LD_ADDR_EXP 38
7547: PUSH
7548: LD_STRING QInfo
7550: PPUSH
7551: CALL_OW 97
7555: ST_TO_ADDR
// end else
7556: GO 7595
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7558: LD_EXP 67
7562: PPUSH
7563: CALL_OW 274
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: LD_INT 60
7573: NEG
7574: PPUSH
7575: CALL_OW 276
// if odnes_jeden_oil then
7579: CALL 5484 0 0
7583: IFFALSE 7595
// if odnes_jeden_oil then
7585: CALL 5484 0 0
7589: IFFALSE 7595
// odnes_jeden_oil ;
7591: CALL 5484 0 0
// end ; end else
7595: GO 7634
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7597: LD_EXP 67
7601: PPUSH
7602: CALL_OW 274
7606: PPUSH
7607: LD_INT 2
7609: PPUSH
7610: LD_INT 60
7612: NEG
7613: PPUSH
7614: CALL_OW 276
// if odnes_jeden_oil then
7618: CALL 5484 0 0
7622: IFFALSE 7634
// if odnes_jeden_oil then
7624: CALL 5484 0 0
7628: IFFALSE 7634
// odnes_jeden_oil ;
7630: CALL 5484 0 0
// end ; end ; if ( Aqr1 = 2 ) and ( Aqr2 = 1 ) then
7634: LD_EXP 37
7638: PUSH
7639: LD_INT 2
7641: EQUAL
7642: PUSH
7643: LD_EXP 38
7647: PUSH
7648: LD_INT 1
7650: EQUAL
7651: AND
7652: IFFALSE 7904
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7654: LD_EXP 67
7658: PPUSH
7659: CALL_OW 274
7663: PPUSH
7664: LD_INT 2
7666: PPUSH
7667: CALL_OW 275
7671: PUSH
7672: LD_INT 20
7674: LESS
7675: IFFALSE 7871
// begin DialogueOn ;
7677: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7681: LD_EXP 41
7685: PPUSH
7686: LD_STRING D9a-FAr1-1
7688: PPUSH
7689: CALL_OW 88
7693: IFFALSE 7707
// Say ( JMM , D9a-JMM-1 ) ;
7695: LD_EXP 17
7699: PPUSH
7700: LD_STRING D9a-JMM-1
7702: PPUSH
7703: CALL_OW 88
// DialogueOff ;
7707: CALL_OW 7
// cekani := 0 ;
7711: LD_ADDR_VAR 0 2
7715: PUSH
7716: LD_INT 0
7718: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 do
7719: LD_VAR 0 2
7723: PUSH
7724: LD_INT 60
7726: LESS
7727: PUSH
7728: LD_EXP 67
7732: PPUSH
7733: CALL_OW 274
7737: PPUSH
7738: LD_INT 2
7740: PPUSH
7741: CALL_OW 275
7745: PUSH
7746: LD_INT 20
7748: LESS
7749: AND
7750: IFFALSE 7775
// begin Wait ( 0 0$1 ) ;
7752: LD_INT 35
7754: PPUSH
7755: CALL_OW 67
// cekani := cekani + 1 ;
7759: LD_ADDR_VAR 0 2
7763: PUSH
7764: LD_VAR 0 2
7768: PUSH
7769: LD_INT 1
7771: PLUS
7772: ST_TO_ADDR
// end ;
7773: GO 7719
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7775: LD_EXP 67
7779: PPUSH
7780: CALL_OW 274
7784: PPUSH
7785: LD_INT 2
7787: PPUSH
7788: CALL_OW 275
7792: PUSH
7793: LD_INT 20
7795: LESS
7796: IFFALSE 7836
// begin DialogueOn ;
7798: CALL_OW 6
// Say ( Ara1 , D9a3-Ar1-1 ) ;
7802: LD_EXP 39
7806: PPUSH
7807: LD_STRING D9a3-Ar1-1
7809: PPUSH
7810: CALL_OW 88
// DialogueOff ;
7814: CALL_OW 7
// Aqr1 := 2 ;
7818: LD_ADDR_EXP 37
7822: PUSH
7823: LD_INT 2
7825: ST_TO_ADDR
// Aqr2 := 0 ;
7826: LD_ADDR_EXP 38
7830: PUSH
7831: LD_INT 0
7833: ST_TO_ADDR
// end else
7834: GO 7869
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7836: LD_EXP 67
7840: PPUSH
7841: CALL_OW 274
7845: PPUSH
7846: LD_INT 2
7848: PPUSH
7849: LD_INT 20
7851: NEG
7852: PPUSH
7853: CALL_OW 276
// odnes_jeden_oil ;
7857: CALL 5484 0 0
// PoskytnouInformace := 1 ;
7861: LD_ADDR_EXP 56
7865: PUSH
7866: LD_INT 1
7868: ST_TO_ADDR
// end ; end else
7869: GO 7904
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7871: LD_EXP 67
7875: PPUSH
7876: CALL_OW 274
7880: PPUSH
7881: LD_INT 2
7883: PPUSH
7884: LD_INT 20
7886: NEG
7887: PPUSH
7888: CALL_OW 276
// odnes_jeden_oil ;
7892: CALL 5484 0 0
// PoskytnouInformace := 1 ;
7896: LD_ADDR_EXP 56
7900: PUSH
7901: LD_INT 1
7903: ST_TO_ADDR
// end ; end ; if Aqr1 = 1 then
7904: LD_EXP 37
7908: PUSH
7909: LD_INT 1
7911: EQUAL
7912: IFFALSE 9352
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
7914: LD_EXP 67
7918: PPUSH
7919: CALL_OW 274
7923: PPUSH
7924: LD_INT 1
7926: PPUSH
7927: CALL_OW 275
7931: PUSH
7932: LD_INT 25
7934: LESS
7935: IFFALSE 7971
// begin DialogueOn ;
7937: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1 ) then
7941: LD_EXP 40
7945: PPUSH
7946: LD_STRING D9b-Ar2-1
7948: PPUSH
7949: CALL_OW 88
7953: IFFALSE 7967
// Say ( JMM , D9b-JMM-1 ) ;
7955: LD_EXP 17
7959: PPUSH
7960: LD_STRING D9b-JMM-1
7962: PPUSH
7963: CALL_OW 88
// DialogueOff ;
7967: CALL_OW 7
// end ; cekani := 0 ;
7971: LD_ADDR_VAR 0 2
7975: PUSH
7976: LD_INT 0
7978: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
7979: LD_VAR 0 2
7983: PUSH
7984: LD_INT 120
7986: LESS
7987: PUSH
7988: LD_EXP 67
7992: PPUSH
7993: CALL_OW 274
7997: PPUSH
7998: LD_INT 1
8000: PPUSH
8001: CALL_OW 275
8005: PUSH
8006: LD_INT 25
8008: LESS
8009: AND
8010: IFFALSE 8035
// begin Wait ( 0 0$1 ) ;
8012: LD_INT 35
8014: PPUSH
8015: CALL_OW 67
// cekani := cekani + 1 ;
8019: LD_ADDR_VAR 0 2
8023: PUSH
8024: LD_VAR 0 2
8028: PUSH
8029: LD_INT 1
8031: PLUS
8032: ST_TO_ADDR
// end ;
8033: GO 7979
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
8035: LD_EXP 67
8039: PPUSH
8040: CALL_OW 274
8044: PPUSH
8045: LD_INT 1
8047: PPUSH
8048: CALL_OW 275
8052: PUSH
8053: LD_INT 25
8055: GREATEREQUAL
8056: IFFALSE 9247
// begin ComMoveXY ( Ara2 , 94 , 101 ) ;
8058: LD_EXP 40
8062: PPUSH
8063: LD_INT 94
8065: PPUSH
8066: LD_INT 101
8068: PPUSH
8069: CALL_OW 111
// while not UnitFilter ( [ Ara2 ] , [ [ f_distxy , 94 , 101 , 2 ] ] ) do
8073: LD_EXP 40
8077: PUSH
8078: EMPTY
8079: LIST
8080: PPUSH
8081: LD_INT 92
8083: PUSH
8084: LD_INT 94
8086: PUSH
8087: LD_INT 101
8089: PUSH
8090: LD_INT 2
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: PUSH
8099: EMPTY
8100: LIST
8101: PPUSH
8102: CALL_OW 72
8106: NOT
8107: IFFALSE 8118
// wait ( 0 0$0.3 ) ;
8109: LD_INT 10
8111: PPUSH
8112: CALL_OW 67
8116: GO 8073
// RemoveEnvironment ( 91 , 99 ) ;
8118: LD_INT 91
8120: PPUSH
8121: LD_INT 99
8123: PPUSH
8124: CALL_OW 347
// RemoveEnvironment ( 91 , 101 ) ;
8128: LD_INT 91
8130: PPUSH
8131: LD_INT 101
8133: PPUSH
8134: CALL_OW 347
// RemoveEnvironment ( 94 , 102 ) ;
8138: LD_INT 94
8140: PPUSH
8141: LD_INT 102
8143: PPUSH
8144: CALL_OW 347
// RemoveEnvironment ( 93 , 100 ) ;
8148: LD_INT 93
8150: PPUSH
8151: LD_INT 100
8153: PPUSH
8154: CALL_OW 347
// SetAttitude ( arabians , you , att_friend , true ) ;
8158: LD_EXP 50
8162: PPUSH
8163: LD_EXP 47
8167: PPUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_INT 1
8173: PPUSH
8174: CALL_OW 80
// while not ArmStarted do
8178: LD_EXP 74
8182: NOT
8183: IFFALSE 8283
// begin wait ( 0 0$0.3 ) ;
8185: LD_INT 10
8187: PPUSH
8188: CALL_OW 67
// SetSide ( ara2 , Getside ( rudepot1 ) ) ;
8192: LD_EXP 40
8196: PPUSH
8197: LD_EXP 67
8201: PPUSH
8202: CALL_OW 255
8206: PPUSH
8207: CALL_OW 235
// ComBuild ( Ara2 , b_armoury , 92 , 101 , 1 ) ;
8211: LD_EXP 40
8215: PPUSH
8216: LD_INT 4
8218: PPUSH
8219: LD_INT 92
8221: PPUSH
8222: LD_INT 101
8224: PPUSH
8225: LD_INT 1
8227: PPUSH
8228: CALL_OW 145
// ComMoveXY ( FilterAllUnits ( [ [ f_distxy , 92 , 101 , 6 ] , [ f_side , arabians ] ] ) , 93 , 90 ) ;
8232: LD_INT 92
8234: PUSH
8235: LD_INT 92
8237: PUSH
8238: LD_INT 101
8240: PUSH
8241: LD_INT 6
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 22
8252: PUSH
8253: LD_EXP 50
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: PPUSH
8266: CALL_OW 69
8270: PPUSH
8271: LD_INT 93
8273: PPUSH
8274: LD_INT 90
8276: PPUSH
8277: CALL_OW 111
// end ;
8281: GO 8178
// SetSide ( ara2 , arabians ) ;
8283: LD_EXP 40
8287: PPUSH
8288: LD_EXP 50
8292: PPUSH
8293: CALL_OW 235
// wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8304: LD_EXP 39
8308: PUSH
8309: LD_EXP 41
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PPUSH
8318: LD_INT 30
8320: PUSH
8321: LD_INT 4
8323: PUSH
8324: EMPTY
8325: LIST
8326: LIST
8327: PUSH
8328: LD_INT 23
8330: PUSH
8331: LD_INT 2
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: EMPTY
8339: LIST
8340: LIST
8341: PPUSH
8342: CALL_OW 69
8346: PPUSH
8347: CALL_OW 112
// while not ArmBuild and FilterAllUnits ( [ [ f_nation , nation_arabian ] , [ f_type , unit_building ] ] ) do
8351: LD_EXP 71
8355: NOT
8356: PUSH
8357: LD_INT 23
8359: PUSH
8360: LD_INT 2
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: LD_INT 21
8369: PUSH
8370: LD_INT 3
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: AND
8386: IFFALSE 8397
// wait ( 0 0$1 ) ;
8388: LD_INT 35
8390: PPUSH
8391: CALL_OW 67
8395: GO 8351
// SetAttitude ( arabians , you , att_neutral , true ) ;
8397: LD_EXP 50
8401: PPUSH
8402: LD_EXP 47
8406: PPUSH
8407: LD_INT 0
8409: PPUSH
8410: LD_INT 1
8412: PPUSH
8413: CALL_OW 80
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
8417: LD_EXP 67
8421: PPUSH
8422: CALL_OW 274
8426: PPUSH
8427: LD_INT 1
8429: PPUSH
8430: CALL_OW 275
8434: PUSH
8435: LD_INT 25
8437: LESS
8438: IFFALSE 8474
// begin DialogueOn ;
8440: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1a ) then
8444: LD_EXP 40
8448: PPUSH
8449: LD_STRING D9b-Ar2-1a
8451: PPUSH
8452: CALL_OW 88
8456: IFFALSE 8470
// Say ( JMM , D9b-JMM-1 ) ;
8458: LD_EXP 17
8462: PPUSH
8463: LD_STRING D9b-JMM-1
8465: PPUSH
8466: CALL_OW 88
// DialogueOff ;
8470: CALL_OW 7
// end ; cekani := 0 ;
8474: LD_ADDR_VAR 0 2
8478: PUSH
8479: LD_INT 0
8481: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
8482: LD_VAR 0 2
8486: PUSH
8487: LD_INT 120
8489: LESS
8490: PUSH
8491: LD_EXP 67
8495: PPUSH
8496: CALL_OW 274
8500: PPUSH
8501: LD_INT 1
8503: PPUSH
8504: CALL_OW 275
8508: PUSH
8509: LD_INT 25
8511: LESS
8512: AND
8513: IFFALSE 8538
// begin Wait ( 0 0$1 ) ;
8515: LD_INT 35
8517: PPUSH
8518: CALL_OW 67
// cekani := cekani + 1 ;
8522: LD_ADDR_VAR 0 2
8526: PUSH
8527: LD_VAR 0 2
8531: PUSH
8532: LD_INT 1
8534: PLUS
8535: ST_TO_ADDR
// end ;
8536: GO 8482
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
8538: LD_EXP 67
8542: PPUSH
8543: CALL_OW 274
8547: PPUSH
8548: LD_INT 1
8550: PPUSH
8551: CALL_OW 275
8555: PUSH
8556: LD_INT 25
8558: GREATEREQUAL
8559: IFFALSE 9247
// begin wait ( 0 0$1 ) ;
8561: LD_INT 35
8563: PPUSH
8564: CALL_OW 67
// SetRestrict ( b_barracks , you , state_enabled ) ;
8568: LD_INT 5
8570: PPUSH
8571: LD_EXP 47
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: CALL_OW 324
// SetAttitude ( arabians , you , att_friend , true ) ;
8583: LD_EXP 50
8587: PPUSH
8588: LD_EXP 47
8592: PPUSH
8593: LD_INT 1
8595: PPUSH
8596: LD_INT 1
8598: PPUSH
8599: CALL_OW 80
// ComUpgrade ( FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8603: LD_INT 30
8605: PUSH
8606: LD_INT 4
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: PUSH
8613: LD_INT 23
8615: PUSH
8616: LD_INT 2
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PPUSH
8627: CALL_OW 69
8631: PPUSH
8632: CALL_OW 146
// wait ( 0 0$1 ) ;
8636: LD_INT 35
8638: PPUSH
8639: CALL_OW 67
// SetTech ( tech_Mortar , you , state_researched ) ;
8643: LD_INT 41
8645: PPUSH
8646: LD_EXP 47
8650: PPUSH
8651: LD_INT 2
8653: PPUSH
8654: CALL_OW 322
// wait ( 0 0$1 ) ;
8658: LD_INT 35
8660: PPUSH
8661: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) ) ;
8665: LD_EXP 39
8669: PUSH
8670: LD_EXP 41
8674: PUSH
8675: EMPTY
8676: LIST
8677: LIST
8678: PPUSH
8679: LD_INT 30
8681: PUSH
8682: LD_INT 5
8684: PUSH
8685: EMPTY
8686: LIST
8687: LIST
8688: PUSH
8689: LD_INT 23
8691: PUSH
8692: LD_INT 2
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PPUSH
8703: CALL_OW 69
8707: PPUSH
8708: CALL_OW 112
// while not ArmUpgraded and FilterAllUnits ( [ [ f_nation , nation_arabian ] , [ f_type , unit_building ] ] ) do
8712: LD_EXP 72
8716: NOT
8717: PUSH
8718: LD_INT 23
8720: PUSH
8721: LD_INT 2
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 21
8730: PUSH
8731: LD_INT 3
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: PPUSH
8742: CALL_OW 69
8746: AND
8747: IFFALSE 8758
// wait ( 0 0$1 ) ;
8749: LD_INT 35
8751: PPUSH
8752: CALL_OW 67
8756: GO 8712
// SetAttitude ( arabians , you , att_neutral , true ) ;
8758: LD_EXP 50
8762: PPUSH
8763: LD_EXP 47
8767: PPUSH
8768: LD_INT 0
8770: PPUSH
8771: LD_INT 1
8773: PPUSH
8774: CALL_OW 80
// DialogueOn ;
8778: CALL_OW 6
// if Say ( Ara2 , D9d-Ar2-1 ) then
8782: LD_EXP 40
8786: PPUSH
8787: LD_STRING D9d-Ar2-1
8789: PPUSH
8790: CALL_OW 88
8794: IFFALSE 8836
// if Say ( Ara1 , D9d-Ar1-1 ) then
8796: LD_EXP 39
8800: PPUSH
8801: LD_STRING D9d-Ar1-1
8803: PPUSH
8804: CALL_OW 88
8808: IFFALSE 8836
// if Say ( JMM , D9d-JMM-1 ) then
8810: LD_EXP 17
8814: PPUSH
8815: LD_STRING D9d-JMM-1
8817: PPUSH
8818: CALL_OW 88
8822: IFFALSE 8836
// Say ( Ara1 , D9d-Ar1-2 ) ;
8824: LD_EXP 39
8828: PPUSH
8829: LD_STRING D9d-Ar1-2
8831: PPUSH
8832: CALL_OW 88
// DialogueOff ;
8836: CALL_OW 7
// nabidka := [ 4 ] ;
8840: LD_ADDR_VAR 0 4
8844: PUSH
8845: LD_INT 4
8847: PUSH
8848: EMPTY
8849: LIST
8850: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) >= 20 then
8851: LD_EXP 67
8855: PPUSH
8856: CALL_OW 274
8860: PPUSH
8861: LD_INT 3
8863: PPUSH
8864: CALL_OW 275
8868: PUSH
8869: LD_INT 20
8871: GREATEREQUAL
8872: IFFALSE 8891
// nabidka := nabidka ^ [ 1 ] ;
8874: LD_ADDR_VAR 0 4
8878: PUSH
8879: LD_VAR 0 4
8883: PUSH
8884: LD_INT 1
8886: PUSH
8887: EMPTY
8888: LIST
8889: ADD
8890: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 50 then
8891: LD_EXP 67
8895: PPUSH
8896: CALL_OW 274
8900: PPUSH
8901: LD_INT 1
8903: PPUSH
8904: CALL_OW 275
8908: PUSH
8909: LD_INT 50
8911: GREATEREQUAL
8912: IFFALSE 8931
// nabidka := nabidka ^ [ 2 ] ;
8914: LD_ADDR_VAR 0 4
8918: PUSH
8919: LD_VAR 0 4
8923: PUSH
8924: LD_INT 2
8926: PUSH
8927: EMPTY
8928: LIST
8929: ADD
8930: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) >= 80 then
8931: LD_EXP 67
8935: PPUSH
8936: CALL_OW 274
8940: PPUSH
8941: LD_INT 2
8943: PPUSH
8944: CALL_OW 275
8948: PUSH
8949: LD_INT 80
8951: GREATEREQUAL
8952: IFFALSE 8971
// nabidka := nabidka ^ [ 3 ] ;
8954: LD_ADDR_VAR 0 4
8958: PUSH
8959: LD_VAR 0 4
8963: PUSH
8964: LD_INT 3
8966: PUSH
8967: EMPTY
8968: LIST
8969: ADD
8970: ST_TO_ADDR
// qr := 4 ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_INT 4
8978: ST_TO_ADDR
// if nabidka > 1 then
8979: LD_VAR 0 4
8983: PUSH
8984: LD_INT 1
8986: GREATER
8987: IFFALSE 9111
// begin qr := SelectiveQuery ( QInfo2 , nabidka ) ;
8989: LD_ADDR_VAR 0 3
8993: PUSH
8994: LD_STRING QInfo2
8996: PPUSH
8997: LD_VAR 0 4
9001: PPUSH
9002: CALL_OW 98
9006: ST_TO_ADDR
// case qr of 1 :
9007: LD_VAR 0 3
9011: PUSH
9012: LD_INT 1
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9044
9020: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_siberit , - 20 ) ; 2 :
9021: LD_EXP 67
9025: PPUSH
9026: CALL_OW 274
9030: PPUSH
9031: LD_INT 3
9033: PPUSH
9034: LD_INT 20
9036: NEG
9037: PPUSH
9038: CALL_OW 276
9042: GO 9109
9044: LD_INT 2
9046: DOUBLE
9047: EQUAL
9048: IFTRUE 9052
9050: GO 9076
9052: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_cans , - 50 ) ; 3 :
9053: LD_EXP 67
9057: PPUSH
9058: CALL_OW 274
9062: PPUSH
9063: LD_INT 1
9065: PPUSH
9066: LD_INT 50
9068: NEG
9069: PPUSH
9070: CALL_OW 276
9074: GO 9109
9076: LD_INT 3
9078: DOUBLE
9079: EQUAL
9080: IFTRUE 9084
9082: GO 9108
9084: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 80 ) ; end ;
9085: LD_EXP 67
9089: PPUSH
9090: CALL_OW 274
9094: PPUSH
9095: LD_INT 2
9097: PPUSH
9098: LD_INT 80
9100: NEG
9101: PPUSH
9102: CALL_OW 276
9106: GO 9109
9108: POP
// end else
9109: GO 9118
// begin Query ( QInfoNothing ) ;
9111: LD_STRING QInfoNothing
9113: PPUSH
9114: CALL_OW 97
// end ; if qr = 4 then
9118: LD_VAR 0 3
9122: PUSH
9123: LD_INT 4
9125: EQUAL
9126: IFFALSE 9150
// begin DialogueOn ;
9128: CALL_OW 6
// Say ( Ara1 , D9f-Ar1-1 ) ;
9132: LD_EXP 39
9136: PPUSH
9137: LD_STRING D9f-Ar1-1
9139: PPUSH
9140: CALL_OW 88
// DialogueOff ;
9144: CALL_OW 7
// end else
9148: GO 9247
// begin case qr of 1 :
9150: LD_VAR 0 3
9154: PUSH
9155: LD_INT 1
9157: DOUBLE
9158: EQUAL
9159: IFTRUE 9163
9161: GO 9176
9163: POP
// odnes_neco ( mat_siberit , 20 ) ; 2 :
9164: LD_INT 3
9166: PPUSH
9167: LD_INT 20
9169: PPUSH
9170: CALL 5811 0 2
9174: GO 9219
9176: LD_INT 2
9178: DOUBLE
9179: EQUAL
9180: IFTRUE 9184
9182: GO 9197
9184: POP
// odnes_neco ( mat_cans , 50 ) ; 3 :
9185: LD_INT 1
9187: PPUSH
9188: LD_INT 50
9190: PPUSH
9191: CALL 5811 0 2
9195: GO 9219
9197: LD_INT 3
9199: DOUBLE
9200: EQUAL
9201: IFTRUE 9205
9203: GO 9218
9205: POP
// odnes_neco ( mat_oil , 80 ) ; end ;
9206: LD_INT 2
9208: PPUSH
9209: LD_INT 80
9211: PPUSH
9212: CALL 5811 0 2
9216: GO 9219
9218: POP
// DialogueOn ;
9219: CALL_OW 6
// Say ( Ara1 , D9e-Ar1-1 ) ;
9223: LD_EXP 39
9227: PPUSH
9228: LD_STRING D9e-Ar1-1
9230: PPUSH
9231: CALL_OW 88
// PoskytnouInformace := 1 ;
9235: LD_ADDR_EXP 56
9239: PUSH
9240: LD_INT 1
9242: ST_TO_ADDR
// DialogueOff ;
9243: CALL_OW 7
// end ; end ; end ; ComExitBuilding ( Ara2 ) ;
9247: LD_EXP 40
9251: PPUSH
9252: CALL_OW 122
// if cekani >= 120 then
9256: LD_VAR 0 2
9260: PUSH
9261: LD_INT 120
9263: GREATEREQUAL
9264: IFFALSE 9352
// begin DialogueOn ;
9266: CALL_OW 6
// if Say ( Ara1 , D9c-Ar1-1 ) then
9270: LD_EXP 39
9274: PPUSH
9275: LD_STRING D9c-Ar1-1
9277: PPUSH
9278: CALL_OW 88
9282: IFFALSE 9348
// if Say ( JMM , D9c-JMM-1 ) then
9284: LD_EXP 17
9288: PPUSH
9289: LD_STRING D9c-JMM-1
9291: PPUSH
9292: CALL_OW 88
9296: IFFALSE 9348
// if Say ( Ara1 , D9c-Ar1-2 ) then
9298: LD_EXP 39
9302: PPUSH
9303: LD_STRING D9c-Ar1-2
9305: PPUSH
9306: CALL_OW 88
9310: IFFALSE 9348
// if Say ( Ara3 , D9c-FAr1-2 ) then
9312: LD_EXP 41
9316: PPUSH
9317: LD_STRING D9c-FAr1-2
9319: PPUSH
9320: CALL_OW 88
9324: IFFALSE 9348
// if Say ( Ara1 , D9c-Ar1-3 ) then
9326: LD_EXP 39
9330: PPUSH
9331: LD_STRING D9c-Ar1-3
9333: PPUSH
9334: CALL_OW 88
9338: IFFALSE 9348
// PoskytnouInformace := 2 ;
9340: LD_ADDR_EXP 56
9344: PUSH
9345: LD_INT 2
9347: ST_TO_ADDR
// DialogueOff ;
9348: CALL_OW 7
// end ; end ; for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
9352: LD_ADDR_VAR 0 5
9356: PUSH
9357: LD_INT 22
9359: PUSH
9360: LD_EXP 50
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PUSH
9369: LD_INT 21
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: PPUSH
9383: CALL_OW 69
9387: PUSH
9388: FOR_IN
9389: IFFALSE 9407
// SetSide ( i , you ) ;
9391: LD_VAR 0 5
9395: PPUSH
9396: LD_EXP 47
9400: PPUSH
9401: CALL_OW 235
9405: GO 9388
9407: POP
9408: POP
// if PoskytnouInformace > 0 and IsLive ( ara1 ) and IsLive ( ara2 ) and IsLive ( ara3 ) then
9409: LD_EXP 56
9413: PUSH
9414: LD_INT 0
9416: GREATER
9417: PUSH
9418: LD_EXP 39
9422: PPUSH
9423: CALL_OW 300
9427: AND
9428: PUSH
9429: LD_EXP 40
9433: PPUSH
9434: CALL_OW 300
9438: AND
9439: PUSH
9440: LD_EXP 41
9444: PPUSH
9445: CALL_OW 300
9449: AND
9450: IFFALSE 9628
// begin DialogueOn ;
9452: CALL_OW 6
// if PoskytnouInformace = 2 then
9456: LD_EXP 56
9460: PUSH
9461: LD_INT 2
9463: EQUAL
9464: IFFALSE 9478
// Say ( JMM , D10a-JMM-1 ) ;
9466: LD_EXP 17
9470: PPUSH
9471: LD_STRING D10a-JMM-1
9473: PPUSH
9474: CALL_OW 88
// if PoskytnouInformace = 1 then
9478: LD_EXP 56
9482: PUSH
9483: LD_INT 1
9485: EQUAL
9486: IFFALSE 9500
// Say ( JMM , D10a-JMM-1 ) ;
9488: LD_EXP 17
9492: PPUSH
9493: LD_STRING D10a-JMM-1
9495: PPUSH
9496: CALL_OW 88
// if Say ( Ara1 , D10a-Ar1-1 ) then
9500: LD_EXP 39
9504: PPUSH
9505: LD_STRING D10a-Ar1-1
9507: PPUSH
9508: CALL_OW 88
9512: IFFALSE 9624
// if Say ( Ara2 , D10a-Ar2-1 ) then
9514: LD_EXP 40
9518: PPUSH
9519: LD_STRING D10a-Ar2-1
9521: PPUSH
9522: CALL_OW 88
9526: IFFALSE 9624
// if Say ( Ara3 , D10a-FAr1-1 ) then
9528: LD_EXP 41
9532: PPUSH
9533: LD_STRING D10a-FAr1-1
9535: PPUSH
9536: CALL_OW 88
9540: IFFALSE 9624
// if Say ( Ara2 , D10a-Ar2-2 ) then
9542: LD_EXP 40
9546: PPUSH
9547: LD_STRING D10a-Ar2-2
9549: PPUSH
9550: CALL_OW 88
9554: IFFALSE 9624
// if Say ( Ara3 , D10a-FAr1-2 ) then
9556: LD_EXP 41
9560: PPUSH
9561: LD_STRING D10a-FAr1-2
9563: PPUSH
9564: CALL_OW 88
9568: IFFALSE 9624
// if Say ( Ara1 , D10a-Ar1-2 ) then
9570: LD_EXP 39
9574: PPUSH
9575: LD_STRING D10a-Ar1-2
9577: PPUSH
9578: CALL_OW 88
9582: IFFALSE 9624
// if Say ( JMM , D10a-JMM-2 ) then
9584: LD_EXP 17
9588: PPUSH
9589: LD_STRING D10a-JMM-2
9591: PPUSH
9592: CALL_OW 88
9596: IFFALSE 9624
// if Say ( Ara1 , D10a-Ar1-3 ) then
9598: LD_EXP 39
9602: PPUSH
9603: LD_STRING D10a-Ar1-3
9605: PPUSH
9606: CALL_OW 88
9610: IFFALSE 9624
// Say ( JMM , D10a-JMM-3 ) ;
9612: LD_EXP 17
9616: PPUSH
9617: LD_STRING D10a-JMM-3
9619: PPUSH
9620: CALL_OW 88
// DialogueOff ;
9624: CALL_OW 7
// end ; end ; if ( Aqr1 = 3 ) or ( Aqr1 = 2 and Aqr2 = 2 ) then
9628: LD_EXP 37
9632: PUSH
9633: LD_INT 3
9635: EQUAL
9636: PUSH
9637: LD_EXP 37
9641: PUSH
9642: LD_INT 2
9644: EQUAL
9645: PUSH
9646: LD_EXP 38
9650: PUSH
9651: LD_INT 2
9653: EQUAL
9654: AND
9655: OR
9656: IFFALSE 10869
// begin ara1_faze := 0 ;
9658: LD_ADDR_VAR 0 9
9662: PUSH
9663: LD_INT 0
9665: ST_TO_ADDR
// ara3_faze := 0 ;
9666: LD_ADDR_VAR 0 10
9670: PUSH
9671: LD_INT 0
9673: ST_TO_ADDR
// while UnitFilter ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
9674: LD_EXP 39
9678: PUSH
9679: LD_EXP 40
9683: PUSH
9684: LD_EXP 41
9688: PUSH
9689: LD_EXP 42
9693: PUSH
9694: LD_EXP 43
9698: PUSH
9699: LD_EXP 44
9703: PUSH
9704: LD_EXP 45
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: PPUSH
9718: LD_INT 50
9720: PUSH
9721: EMPTY
9722: LIST
9723: PPUSH
9724: CALL_OW 72
9728: IFFALSE 10867
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_INT 22
9737: PPUSH
9738: LD_INT 22
9740: PUSH
9741: LD_EXP 50
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: EMPTY
9751: LIST
9752: PPUSH
9753: CALL_OW 70
9757: PUSH
9758: FOR_IN
9759: IFFALSE 9884
// if not ( ( i = Ara1 ) and ( ara1_faze < 2 ) or ( i = Ara3 ) and ( ara3_faze < 2 ) ) then
9761: LD_VAR 0 5
9765: PUSH
9766: LD_EXP 39
9770: EQUAL
9771: PUSH
9772: LD_VAR 0 9
9776: PUSH
9777: LD_INT 2
9779: LESS
9780: AND
9781: PUSH
9782: LD_VAR 0 5
9786: PUSH
9787: LD_EXP 41
9791: EQUAL
9792: PUSH
9793: LD_VAR 0 10
9797: PUSH
9798: LD_INT 2
9800: LESS
9801: AND
9802: OR
9803: NOT
9804: IFFALSE 9882
// begin RemoveUnit ( i ) ;
9806: LD_VAR 0 5
9810: PPUSH
9811: CALL_OW 64
// if i = AraCar1 then
9815: LD_VAR 0 5
9819: PUSH
9820: LD_EXP 44
9824: EQUAL
9825: IFFALSE 9836
// RemoveUnit ( Ara4 ) ;
9827: LD_EXP 42
9831: PPUSH
9832: CALL_OW 64
// if i = AraCar2 then
9836: LD_VAR 0 5
9840: PUSH
9841: LD_EXP 45
9845: EQUAL
9846: IFFALSE 9857
// RemoveUnit ( Ara5 ) ;
9848: LD_EXP 43
9852: PPUSH
9853: CALL_OW 64
// if IsInUnit ( i ) then
9857: LD_VAR 0 5
9861: PPUSH
9862: CALL_OW 310
9866: IFFALSE 9882
// RemoveUnit ( IsInUnit ( i ) ) ;
9868: LD_VAR 0 5
9872: PPUSH
9873: CALL_OW 310
9877: PPUSH
9878: CALL_OW 64
// end ;
9882: GO 9758
9884: POP
9885: POP
// wait ( 0 0$5 ) ;
9886: LD_INT 175
9888: PPUSH
9889: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
9893: LD_EXP 42
9897: PPUSH
9898: CALL_OW 310
9902: NOT
9903: PUSH
9904: LD_EXP 44
9908: PPUSH
9909: CALL_OW 302
9913: NOT
9914: AND
9915: IFFALSE 9929
// ComMoveToArea ( Ara4 , arab_exit ) ;
9917: LD_EXP 42
9921: PPUSH
9922: LD_INT 22
9924: PPUSH
9925: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
9929: LD_EXP 43
9933: PPUSH
9934: CALL_OW 310
9938: NOT
9939: PUSH
9940: LD_EXP 45
9944: PPUSH
9945: CALL_OW 302
9949: NOT
9950: AND
9951: IFFALSE 9965
// ComMoveToArea ( Ara5 , arab_exit ) ;
9953: LD_EXP 43
9957: PPUSH
9958: LD_INT 22
9960: PPUSH
9961: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
9965: LD_EXP 42
9969: PPUSH
9970: CALL_OW 310
9974: NOT
9975: PUSH
9976: LD_EXP 44
9980: PPUSH
9981: CALL_OW 261
9985: PUSH
9986: LD_INT 0
9988: GREATER
9989: AND
9990: PUSH
9991: LD_EXP 44
9995: PPUSH
9996: CALL_OW 302
10000: AND
10001: IFFALSE 10017
// ComEnterUnit ( Ara4 , AraCar1 ) ;
10003: LD_EXP 42
10007: PPUSH
10008: LD_EXP 44
10012: PPUSH
10013: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
10017: LD_EXP 43
10021: PPUSH
10022: CALL_OW 310
10026: NOT
10027: PUSH
10028: LD_EXP 45
10032: PPUSH
10033: CALL_OW 261
10037: PUSH
10038: LD_INT 0
10040: GREATER
10041: AND
10042: PUSH
10043: LD_EXP 45
10047: PPUSH
10048: CALL_OW 302
10052: AND
10053: IFFALSE 10069
// ComEnterUnit ( Ara5 , AraCar2 ) ;
10055: LD_EXP 43
10059: PPUSH
10060: LD_EXP 45
10064: PPUSH
10065: CALL_OW 120
// ComMoveToArea ( [ Ara2 , AraCar1 , AraCar2 ] , arab_exit ) ;
10069: LD_EXP 40
10073: PUSH
10074: LD_EXP 44
10078: PUSH
10079: LD_EXP 45
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: LIST
10088: PPUSH
10089: LD_INT 22
10091: PPUSH
10092: CALL_OW 113
// AddComMoveXY ( [ Ara2 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
10096: LD_EXP 40
10100: PUSH
10101: LD_EXP 44
10105: PUSH
10106: LD_EXP 45
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: PPUSH
10116: LD_INT 37
10118: PPUSH
10119: LD_INT 72
10121: PPUSH
10122: CALL_OW 171
// case true of not IsOk ( Ara1 ) :
10126: LD_INT 1
10128: PUSH
10129: LD_EXP 39
10133: PPUSH
10134: CALL_OW 302
10138: NOT
10139: DOUBLE
10140: EQUAL
10141: IFTRUE 10145
10143: GO 10156
10145: POP
// ara1_faze := 4 ; ( GetDistUnitXY ( Ara1 , 57 , 76 ) < 5 ) and ara1_faze = 2 :
10146: LD_ADDR_VAR 0 9
10150: PUSH
10151: LD_INT 4
10153: ST_TO_ADDR
10154: GO 10304
10156: LD_EXP 39
10160: PPUSH
10161: LD_INT 57
10163: PPUSH
10164: LD_INT 76
10166: PPUSH
10167: CALL_OW 297
10171: PUSH
10172: LD_INT 5
10174: LESS
10175: PUSH
10176: LD_VAR 0 9
10180: PUSH
10181: LD_INT 2
10183: EQUAL
10184: AND
10185: DOUBLE
10186: EQUAL
10187: IFTRUE 10191
10189: GO 10202
10191: POP
// ara1_faze := 3 ; MineOfUnit ( Ara1 ) <> 0 and ara1_faze = 1 :
10192: LD_ADDR_VAR 0 9
10196: PUSH
10197: LD_INT 3
10199: ST_TO_ADDR
10200: GO 10304
10202: LD_EXP 39
10206: PPUSH
10207: CALL_OW 459
10211: PUSH
10212: LD_INT 0
10214: NONEQUAL
10215: PUSH
10216: LD_VAR 0 9
10220: PUSH
10221: LD_INT 1
10223: EQUAL
10224: AND
10225: DOUBLE
10226: EQUAL
10227: IFTRUE 10231
10229: GO 10257
10231: POP
// begin ara1_faze := 2 ;
10232: LD_ADDR_VAR 0 9
10236: PUSH
10237: LD_INT 2
10239: ST_TO_ADDR
// mina1 := MineOfUnit ( Ara1 ) ;
10240: LD_ADDR_EXP 77
10244: PUSH
10245: LD_EXP 39
10249: PPUSH
10250: CALL_OW 459
10254: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara1 , 58 , 76 ) < 5 ) and ara1_faze = 0 :
10255: GO 10304
10257: LD_EXP 39
10261: PPUSH
10262: LD_INT 58
10264: PPUSH
10265: LD_INT 76
10267: PPUSH
10268: CALL_OW 297
10272: PUSH
10273: LD_INT 5
10275: LESS
10276: PUSH
10277: LD_VAR 0 9
10281: PUSH
10282: LD_INT 0
10284: EQUAL
10285: AND
10286: DOUBLE
10287: EQUAL
10288: IFTRUE 10292
10290: GO 10303
10292: POP
// ara1_faze := 1 ; end ;
10293: LD_ADDR_VAR 0 9
10297: PUSH
10298: LD_INT 1
10300: ST_TO_ADDR
10301: GO 10304
10303: POP
// case ara1_faze of 0 :
10304: LD_VAR 0 9
10308: PUSH
10309: LD_INT 0
10311: DOUBLE
10312: EQUAL
10313: IFTRUE 10317
10315: GO 10335
10317: POP
// ComMoveXY ( Ara1 , 58 , 76 ) ; 1 :
10318: LD_EXP 39
10322: PPUSH
10323: LD_INT 58
10325: PPUSH
10326: LD_INT 76
10328: PPUSH
10329: CALL_OW 111
10333: GO 10431
10335: LD_INT 1
10337: DOUBLE
10338: EQUAL
10339: IFTRUE 10343
10341: GO 10366
10343: POP
// ComPlaceRemoteCharge ( Ara1 , 0 , 0 , ruDepot1 ) ; 2 :
10344: LD_EXP 39
10348: PPUSH
10349: LD_INT 0
10351: PPUSH
10352: LD_INT 0
10354: PPUSH
10355: LD_EXP 67
10359: PPUSH
10360: CALL_OW 133
10364: GO 10431
10366: LD_INT 2
10368: DOUBLE
10369: EQUAL
10370: IFTRUE 10374
10372: GO 10392
10374: POP
// ComMoveXY ( Ara1 , 57 , 76 ) ; 3 :
10375: LD_EXP 39
10379: PPUSH
10380: LD_INT 57
10382: PPUSH
10383: LD_INT 76
10385: PPUSH
10386: CALL_OW 111
10390: GO 10431
10392: LD_INT 3
10394: DOUBLE
10395: EQUAL
10396: IFTRUE 10400
10398: GO 10430
10400: POP
// begin ComMoveToArea ( Ara1 , arab_exit ) ;
10401: LD_EXP 39
10405: PPUSH
10406: LD_INT 22
10408: PPUSH
10409: CALL_OW 113
// AddComMoveXY ( Ara1 , 37 , 72 ) ;
10413: LD_EXP 39
10417: PPUSH
10418: LD_INT 37
10420: PPUSH
10421: LD_INT 72
10423: PPUSH
10424: CALL_OW 171
// end ; end ;
10428: GO 10431
10430: POP
// case true of not IsOk ( Ara3 ) :
10431: LD_INT 1
10433: PUSH
10434: LD_EXP 41
10438: PPUSH
10439: CALL_OW 302
10443: NOT
10444: DOUBLE
10445: EQUAL
10446: IFTRUE 10450
10448: GO 10461
10450: POP
// ara3_faze := 4 ; ( GetDistUnitXY ( Ara3 , 58 , 76 ) < 5 ) and ara3_faze = 2 :
10451: LD_ADDR_VAR 0 10
10455: PUSH
10456: LD_INT 4
10458: ST_TO_ADDR
10459: GO 10609
10461: LD_EXP 41
10465: PPUSH
10466: LD_INT 58
10468: PPUSH
10469: LD_INT 76
10471: PPUSH
10472: CALL_OW 297
10476: PUSH
10477: LD_INT 5
10479: LESS
10480: PUSH
10481: LD_VAR 0 10
10485: PUSH
10486: LD_INT 2
10488: EQUAL
10489: AND
10490: DOUBLE
10491: EQUAL
10492: IFTRUE 10496
10494: GO 10507
10496: POP
// ara3_faze := 3 ; MineOfUnit ( Ara3 ) <> 0 and ara3_faze = 1 :
10497: LD_ADDR_VAR 0 10
10501: PUSH
10502: LD_INT 3
10504: ST_TO_ADDR
10505: GO 10609
10507: LD_EXP 41
10511: PPUSH
10512: CALL_OW 459
10516: PUSH
10517: LD_INT 0
10519: NONEQUAL
10520: PUSH
10521: LD_VAR 0 10
10525: PUSH
10526: LD_INT 1
10528: EQUAL
10529: AND
10530: DOUBLE
10531: EQUAL
10532: IFTRUE 10536
10534: GO 10562
10536: POP
// begin ara3_faze := 2 ;
10537: LD_ADDR_VAR 0 10
10541: PUSH
10542: LD_INT 2
10544: ST_TO_ADDR
// mina3 := MineOfUnit ( Ara3 ) ;
10545: LD_ADDR_EXP 78
10549: PUSH
10550: LD_EXP 41
10554: PPUSH
10555: CALL_OW 459
10559: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara3 , 70 , 104 ) < 5 ) and ara3_faze = 0 :
10560: GO 10609
10562: LD_EXP 41
10566: PPUSH
10567: LD_INT 70
10569: PPUSH
10570: LD_INT 104
10572: PPUSH
10573: CALL_OW 297
10577: PUSH
10578: LD_INT 5
10580: LESS
10581: PUSH
10582: LD_VAR 0 10
10586: PUSH
10587: LD_INT 0
10589: EQUAL
10590: AND
10591: DOUBLE
10592: EQUAL
10593: IFTRUE 10597
10595: GO 10608
10597: POP
// ara3_faze := 1 ; end ;
10598: LD_ADDR_VAR 0 10
10602: PUSH
10603: LD_INT 1
10605: ST_TO_ADDR
10606: GO 10609
10608: POP
// case ara3_faze of 0 :
10609: LD_VAR 0 10
10613: PUSH
10614: LD_INT 0
10616: DOUBLE
10617: EQUAL
10618: IFTRUE 10622
10620: GO 10640
10622: POP
// ComMoveXY ( Ara3 , 70 , 104 ) ; 1 :
10623: LD_EXP 41
10627: PPUSH
10628: LD_INT 70
10630: PPUSH
10631: LD_INT 104
10633: PPUSH
10634: CALL_OW 111
10638: GO 10736
10640: LD_INT 1
10642: DOUBLE
10643: EQUAL
10644: IFTRUE 10648
10646: GO 10671
10648: POP
// ComPlaceRemoteCharge ( Ara3 , 0 , 0 , ruDepot1 ) ; 2 :
10649: LD_EXP 41
10653: PPUSH
10654: LD_INT 0
10656: PPUSH
10657: LD_INT 0
10659: PPUSH
10660: LD_EXP 67
10664: PPUSH
10665: CALL_OW 133
10669: GO 10736
10671: LD_INT 2
10673: DOUBLE
10674: EQUAL
10675: IFTRUE 10679
10677: GO 10697
10679: POP
// ComMoveXY ( Ara3 , 58 , 76 ) ; 3 :
10680: LD_EXP 41
10684: PPUSH
10685: LD_INT 58
10687: PPUSH
10688: LD_INT 76
10690: PPUSH
10691: CALL_OW 111
10695: GO 10736
10697: LD_INT 3
10699: DOUBLE
10700: EQUAL
10701: IFTRUE 10705
10703: GO 10735
10705: POP
// begin ComMoveToArea ( Ara3 , arab_exit ) ;
10706: LD_EXP 41
10710: PPUSH
10711: LD_INT 22
10713: PPUSH
10714: CALL_OW 113
// AddComMoveXY ( Ara3 , 37 , 72 ) ;
10718: LD_EXP 41
10722: PPUSH
10723: LD_INT 37
10725: PPUSH
10726: LD_INT 72
10728: PPUSH
10729: CALL_OW 171
// end ; end ;
10733: GO 10736
10735: POP
// if not kecy and ara1_faze >= 3 and ara3_faze >= 3 then
10736: LD_EXP 76
10740: NOT
10741: PUSH
10742: LD_VAR 0 9
10746: PUSH
10747: LD_INT 3
10749: GREATEREQUAL
10750: AND
10751: PUSH
10752: LD_VAR 0 10
10756: PUSH
10757: LD_INT 3
10759: GREATEREQUAL
10760: AND
10761: IFFALSE 10865
// begin if odmitl_v_query then
10763: LD_VAR 0 11
10767: IFFALSE 10783
// Say ( Ara2 , D11b-Ar1-1 ) else
10769: LD_EXP 40
10773: PPUSH
10774: LD_STRING D11b-Ar1-1
10776: PPUSH
10777: CALL_OW 88
10781: GO 10795
// Say ( Ara2 , D11a-Ar1-1 ) ;
10783: LD_EXP 40
10787: PPUSH
10788: LD_STRING D11a-Ar1-1
10790: PPUSH
10791: CALL_OW 88
// if mina1 then
10795: LD_EXP 77
10799: IFFALSE 10826
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
10801: LD_EXP 77
10805: PUSH
10806: LD_INT 1
10808: ARRAY
10809: PPUSH
10810: LD_EXP 77
10814: PUSH
10815: LD_INT 2
10817: ARRAY
10818: PPUSH
10819: LD_INT 1200
10821: PPUSH
10822: CALL_OW 453
// if mina3 then
10826: LD_EXP 78
10830: IFFALSE 10857
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
10832: LD_EXP 78
10836: PUSH
10837: LD_INT 1
10839: ARRAY
10840: PPUSH
10841: LD_EXP 78
10845: PUSH
10846: LD_INT 2
10848: ARRAY
10849: PPUSH
10850: LD_INT 1200
10852: PPUSH
10853: CALL_OW 453
// kecy := true ;
10857: LD_ADDR_EXP 76
10861: PUSH
10862: LD_INT 1
10864: ST_TO_ADDR
// end ; end ;
10865: GO 9674
// end else
10867: GO 11278
// begin while UnitFilter ( [ Ara2 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
10869: LD_EXP 40
10873: PUSH
10874: LD_EXP 44
10878: PUSH
10879: LD_EXP 45
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: LIST
10888: PPUSH
10889: LD_INT 50
10891: PUSH
10892: EMPTY
10893: LIST
10894: PPUSH
10895: CALL_OW 72
10899: IFFALSE 11278
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
10901: LD_ADDR_VAR 0 5
10905: PUSH
10906: LD_INT 22
10908: PPUSH
10909: LD_INT 22
10911: PUSH
10912: LD_EXP 50
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: PPUSH
10924: CALL_OW 70
10928: PUSH
10929: FOR_IN
10930: IFFALSE 11010
// begin RemoveUnit ( i ) ;
10932: LD_VAR 0 5
10936: PPUSH
10937: CALL_OW 64
// if i = AraCar1 then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_EXP 44
10950: EQUAL
10951: IFFALSE 10962
// RemoveUnit ( Ara4 ) ;
10953: LD_EXP 42
10957: PPUSH
10958: CALL_OW 64
// if i = AraCar2 then
10962: LD_VAR 0 5
10966: PUSH
10967: LD_EXP 45
10971: EQUAL
10972: IFFALSE 10983
// RemoveUnit ( Ara5 ) ;
10974: LD_EXP 43
10978: PPUSH
10979: CALL_OW 64
// if IsInUnit ( i ) then
10983: LD_VAR 0 5
10987: PPUSH
10988: CALL_OW 310
10992: IFFALSE 11008
// RemoveUnit ( IsInUnit ( i ) ) ;
10994: LD_VAR 0 5
10998: PPUSH
10999: CALL_OW 310
11003: PPUSH
11004: CALL_OW 64
// end ;
11008: GO 10929
11010: POP
11011: POP
// wait ( 0 0$1 ) ;
11012: LD_INT 35
11014: PPUSH
11015: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
11019: LD_EXP 42
11023: PPUSH
11024: CALL_OW 310
11028: NOT
11029: PUSH
11030: LD_EXP 44
11034: PPUSH
11035: CALL_OW 302
11039: NOT
11040: AND
11041: IFFALSE 11055
// ComMoveToArea ( Ara4 , arab_exit ) ;
11043: LD_EXP 42
11047: PPUSH
11048: LD_INT 22
11050: PPUSH
11051: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
11055: LD_EXP 43
11059: PPUSH
11060: CALL_OW 310
11064: NOT
11065: PUSH
11066: LD_EXP 45
11070: PPUSH
11071: CALL_OW 302
11075: NOT
11076: AND
11077: IFFALSE 11091
// ComMoveToArea ( Ara5 , arab_exit ) ;
11079: LD_EXP 43
11083: PPUSH
11084: LD_INT 22
11086: PPUSH
11087: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
11091: LD_EXP 42
11095: PPUSH
11096: CALL_OW 310
11100: NOT
11101: PUSH
11102: LD_EXP 44
11106: PPUSH
11107: CALL_OW 261
11111: PUSH
11112: LD_INT 0
11114: GREATER
11115: AND
11116: PUSH
11117: LD_EXP 44
11121: PPUSH
11122: CALL_OW 302
11126: AND
11127: IFFALSE 11143
// ComEnterUnit ( Ara4 , AraCar1 ) ;
11129: LD_EXP 42
11133: PPUSH
11134: LD_EXP 44
11138: PPUSH
11139: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
11143: LD_EXP 43
11147: PPUSH
11148: CALL_OW 310
11152: NOT
11153: PUSH
11154: LD_EXP 45
11158: PPUSH
11159: CALL_OW 261
11163: PUSH
11164: LD_INT 0
11166: GREATER
11167: AND
11168: PUSH
11169: LD_EXP 45
11173: PPUSH
11174: CALL_OW 302
11178: AND
11179: IFFALSE 11195
// ComEnterUnit ( Ara5 , AraCar2 ) ;
11181: LD_EXP 43
11185: PPUSH
11186: LD_EXP 45
11190: PPUSH
11191: CALL_OW 120
// ComMoveToArea ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , arab_exit ) ;
11195: LD_EXP 39
11199: PUSH
11200: LD_EXP 40
11204: PUSH
11205: LD_EXP 41
11209: PUSH
11210: LD_EXP 44
11214: PUSH
11215: LD_EXP 45
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: PPUSH
11227: LD_INT 22
11229: PPUSH
11230: CALL_OW 113
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
11234: LD_EXP 39
11238: PUSH
11239: LD_EXP 40
11243: PUSH
11244: LD_EXP 41
11248: PUSH
11249: LD_EXP 44
11253: PUSH
11254: LD_EXP 45
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: PPUSH
11266: LD_INT 37
11268: PPUSH
11269: LD_INT 72
11271: PPUSH
11272: CALL_OW 171
// end ;
11276: GO 10869
// end ; end ;
11278: LD_VAR 0 1
11282: RET
// every 0 0$1 do var who , a_maj_to , a , i ;
11283: GO 11285
11285: DISABLE
11286: LD_INT 0
11288: PPUSH
11289: PPUSH
11290: PPUSH
11291: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
11292: LD_ADDR_VAR 0 3
11296: PUSH
11297: LD_INT 22
11299: PUSH
11300: LD_EXP 47
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: PPUSH
11312: CALL_OW 69
11316: ST_TO_ADDR
// for i in a do
11317: LD_ADDR_VAR 0 4
11321: PUSH
11322: LD_VAR 0 3
11326: PUSH
11327: FOR_IN
11328: IFFALSE 11398
// if WantsToAttack ( i ) in [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] then
11330: LD_VAR 0 4
11334: PPUSH
11335: CALL_OW 319
11339: PUSH
11340: LD_EXP 39
11344: PUSH
11345: LD_EXP 40
11349: PUSH
11350: LD_EXP 41
11354: PUSH
11355: LD_EXP 42
11359: PUSH
11360: LD_EXP 43
11364: PUSH
11365: LD_EXP 44
11369: PUSH
11370: LD_EXP 45
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: IN
11384: IFFALSE 11396
// begin a_maj_to := true ;
11386: LD_ADDR_VAR 0 2
11390: PUSH
11391: LD_INT 1
11393: ST_TO_ADDR
// break ;
11394: GO 11398
// end ;
11396: GO 11327
11398: POP
11399: POP
// if a_maj_to then
11400: LD_VAR 0 2
11404: IFFALSE 11581
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
11406: LD_EXP 47
11410: PPUSH
11411: LD_EXP 50
11415: PPUSH
11416: LD_INT 2
11418: PPUSH
11419: LD_INT 1
11421: PPUSH
11422: CALL_OW 80
// who := WhoSayAny ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] , arabians , sex_male , 0 , 0 ) ;
11426: LD_ADDR_VAR 0 1
11430: PUSH
11431: LD_EXP 39
11435: PUSH
11436: LD_EXP 40
11440: PUSH
11441: LD_EXP 41
11445: PUSH
11446: LD_EXP 42
11450: PUSH
11451: LD_EXP 43
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: PPUSH
11463: LD_EXP 50
11467: PPUSH
11468: LD_INT 1
11470: PPUSH
11471: LD_INT 0
11473: PPUSH
11474: LD_INT 0
11476: PPUSH
11477: CALL 13224 0 5
11481: ST_TO_ADDR
// if not kecy then
11482: LD_EXP 76
11486: NOT
11487: IFFALSE 11579
// begin DialogueOn ;
11489: CALL_OW 6
// Say ( who , D11a-Ar1-1 ) ;
11493: LD_VAR 0 1
11497: PPUSH
11498: LD_STRING D11a-Ar1-1
11500: PPUSH
11501: CALL_OW 88
// DialogueOff ;
11505: CALL_OW 7
// kecy := true ;
11509: LD_ADDR_EXP 76
11513: PUSH
11514: LD_INT 1
11516: ST_TO_ADDR
// if mina1 then
11517: LD_EXP 77
11521: IFFALSE 11548
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
11523: LD_EXP 77
11527: PUSH
11528: LD_INT 1
11530: ARRAY
11531: PPUSH
11532: LD_EXP 77
11536: PUSH
11537: LD_INT 2
11539: ARRAY
11540: PPUSH
11541: LD_INT 1200
11543: PPUSH
11544: CALL_OW 453
// if mina3 then
11548: LD_EXP 78
11552: IFFALSE 11579
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
11554: LD_EXP 78
11558: PUSH
11559: LD_INT 1
11561: ARRAY
11562: PPUSH
11563: LD_EXP 78
11567: PUSH
11568: LD_INT 2
11570: ARRAY
11571: PPUSH
11572: LD_INT 1200
11574: PPUSH
11575: CALL_OW 453
// end ; end else
11579: GO 11582
// enable ;
11581: ENABLE
// end ;
11582: PPOPN 4
11584: END
// every 45 45$30 do
11585: GO 11587
11587: DISABLE
// begin DialogueOn ;
11588: CALL_OW 6
// SayRadio ( Powell , D12-Pow-1 ) ;
11592: LD_EXP 16
11596: PPUSH
11597: LD_STRING D12-Pow-1
11599: PPUSH
11600: CALL_OW 94
// ChangeMissionObjectives ( M4 ) ;
11604: LD_STRING M4
11606: PPUSH
11607: CALL_OW 337
// EndEnable := true ;
11611: LD_ADDR_EXP 80
11615: PUSH
11616: LD_INT 1
11618: ST_TO_ADDR
// SetAreaMapShow ( exit_area , 1 ) ;
11619: LD_INT 32
11621: PPUSH
11622: LD_INT 1
11624: PPUSH
11625: CALL_OW 424
// DialogueOff ;
11629: CALL_OW 7
// end ;
11633: END
// export konec ; every 55 55$0 do
11634: GO 11636
11636: DISABLE
// begin Konec := true ;
11637: LD_ADDR_EXP 79
11641: PUSH
11642: LD_INT 1
11644: ST_TO_ADDR
// end ;
11645: END
// export EndEnable , TimerCas ; every 0 0$1 do var k , br , zbyva ;
11646: GO 11648
11648: DISABLE
11649: LD_INT 0
11651: PPUSH
11652: PPUSH
11653: PPUSH
// begin if testing then
11654: LD_EXP 4
11658: IFFALSE 11714
// display_strings := [ [ game time:  & ( tick div 1 1$0 ) & :  & ( ( tick - ( tick div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] else
11660: LD_ADDR_OWVAR 47
11664: PUSH
11665: LD_STRING game time: 
11667: PUSH
11668: LD_OWVAR 1
11672: PUSH
11673: LD_INT 2100
11675: DIV
11676: STR
11677: PUSH
11678: LD_STRING : 
11680: STR
11681: PUSH
11682: LD_OWVAR 1
11686: PUSH
11687: LD_OWVAR 1
11691: PUSH
11692: LD_INT 2100
11694: DIV
11695: PUSH
11696: LD_INT 2100
11698: MUL
11699: MINUS
11700: PUSH
11701: LD_INT 35
11703: DIV
11704: STR
11705: PUSH
11706: EMPTY
11707: LIST
11708: PUSH
11709: EMPTY
11710: LIST
11711: ST_TO_ADDR
11712: GO 11721
// display_strings := [ ] ;
11714: LD_ADDR_OWVAR 47
11718: PUSH
11719: EMPTY
11720: ST_TO_ADDR
// zbyva := 60 - GetResourceType ( getbase ( depot1 ) , mat_siberit ) ;
11721: LD_ADDR_VAR 0 3
11725: PUSH
11726: LD_INT 60
11728: PUSH
11729: LD_EXP 69
11733: PPUSH
11734: CALL_OW 274
11738: PPUSH
11739: LD_INT 3
11741: PPUSH
11742: CALL_OW 275
11746: MINUS
11747: ST_TO_ADDR
// if zbyva < 0 then
11748: LD_VAR 0 3
11752: PUSH
11753: LD_INT 0
11755: LESS
11756: IFFALSE 11766
// zbyva := 0 ;
11758: LD_ADDR_VAR 0 3
11762: PUSH
11763: LD_INT 0
11765: ST_TO_ADDR
// if counter_time then
11766: LD_EXP 64
11770: IFFALSE 11807
// display_strings := display_strings ^ [ #Am09-1 , zbyva , counter_time - tick ] ;
11772: LD_ADDR_OWVAR 47
11776: PUSH
11777: LD_OWVAR 47
11781: PUSH
11782: LD_STRING #Am09-1
11784: PUSH
11785: LD_VAR 0 3
11789: PUSH
11790: LD_EXP 64
11794: PUSH
11795: LD_OWVAR 1
11799: MINUS
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: LIST
11805: ADD
11806: ST_TO_ADDR
// if Konec and ( IsOK ( JMM ) ) then
11807: LD_EXP 79
11811: PUSH
11812: LD_EXP 17
11816: PPUSH
11817: CALL_OW 302
11821: AND
11822: IFFALSE 11828
// begin Vyhra ;
11824: CALL 2869 0 0
// end ; if TimerEnable then
11828: LD_EXP 63
11832: IFFALSE 11893
// begin if ContactTime ( russians ) > ( TimerCas + 0 0$45 ) then
11834: LD_EXP 49
11838: PPUSH
11839: CALL_OW 462
11843: PUSH
11844: LD_EXP 81
11848: PUSH
11849: LD_INT 1575
11851: PLUS
11852: GREATER
11853: IFFALSE 11893
// begin if GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and ( IsOK ( JMM ) ) then
11855: LD_EXP 69
11859: PPUSH
11860: CALL_OW 274
11864: PPUSH
11865: LD_INT 3
11867: PPUSH
11868: CALL_OW 275
11872: PUSH
11873: LD_INT 20
11875: GREATEREQUAL
11876: PUSH
11877: LD_EXP 17
11881: PPUSH
11882: CALL_OW 302
11886: AND
11887: IFFALSE 11893
// begin Vyhra ;
11889: CALL 2869 0 0
// end ; end ; end ; if EndEnable then
11893: LD_EXP 80
11897: IFFALSE 12086
// begin if timer < 0 then
11899: LD_EXP 62
11903: PUSH
11904: LD_INT 0
11906: LESS
11907: IFFALSE 11917
// timer := 0 ;
11909: LD_ADDR_EXP 62
11913: PUSH
11914: LD_INT 0
11916: ST_TO_ADDR
// timer := timer - 0 0$1 ;
11917: LD_ADDR_EXP 62
11921: PUSH
11922: LD_EXP 62
11926: PUSH
11927: LD_INT 35
11929: MINUS
11930: ST_TO_ADDR
// if testing then
11931: LD_EXP 4
11935: IFFALSE 11991
// display_strings := display_strings ^ [ [ ( timer div 1 1$0 ) & :  & ( ( timer - ( timer div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] ;
11937: LD_ADDR_OWVAR 47
11941: PUSH
11942: LD_OWVAR 47
11946: PUSH
11947: LD_EXP 62
11951: PUSH
11952: LD_INT 2100
11954: DIV
11955: PUSH
11956: LD_STRING : 
11958: STR
11959: PUSH
11960: LD_EXP 62
11964: PUSH
11965: LD_EXP 62
11969: PUSH
11970: LD_INT 2100
11972: DIV
11973: PUSH
11974: LD_INT 2100
11976: MUL
11977: MINUS
11978: PUSH
11979: LD_INT 35
11981: DIV
11982: STR
11983: PUSH
11984: EMPTY
11985: LIST
11986: PUSH
11987: EMPTY
11988: LIST
11989: ADD
11990: ST_TO_ADDR
// if not FilterUnitsExceptArea ( exit_area , [ [ f_ok ] , [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] ] ) and GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and IsInArea ( JMM , exit_area ) then
11991: LD_INT 32
11993: PPUSH
11994: LD_INT 50
11996: PUSH
11997: EMPTY
11998: LIST
11999: PUSH
12000: LD_INT 22
12002: PUSH
12003: LD_EXP 47
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 23
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: LD_INT 21
12024: PUSH
12025: LD_INT 1
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: PPUSH
12038: CALL_OW 71
12042: NOT
12043: PUSH
12044: LD_EXP 69
12048: PPUSH
12049: CALL_OW 274
12053: PPUSH
12054: LD_INT 3
12056: PPUSH
12057: CALL_OW 275
12061: PUSH
12062: LD_INT 20
12064: GREATEREQUAL
12065: AND
12066: PUSH
12067: LD_EXP 17
12071: PPUSH
12072: LD_INT 32
12074: PPUSH
12075: CALL_OW 308
12079: AND
12080: IFFALSE 12086
// Vyhra ;
12082: CALL 2869 0 0
// end ; enable ;
12086: ENABLE
// end ;
12087: PPOPN 3
12089: END
// var was_QE ; function QE ; begin
12090: LD_INT 0
12092: PPUSH
// was_QE := true ;
12093: LD_ADDR_LOC 1
12097: PUSH
12098: LD_INT 1
12100: ST_TO_ADDR
// if Query ( QE ) = 2 then
12101: LD_STRING QE
12103: PPUSH
12104: CALL_OW 97
12108: PUSH
12109: LD_INT 2
12111: EQUAL
12112: IFFALSE 12118
// Vyhra ;
12114: CALL 2869 0 0
// end ; end_of_file
12118: LD_VAR 0 1
12122: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
12123: LD_INT 0
12125: PPUSH
12126: PPUSH
12127: PPUSH
// see_any_r := false ;
12128: LD_ADDR_VAR 0 5
12132: PUSH
12133: LD_INT 0
12135: ST_TO_ADDR
// for sai in sez2 do
12136: LD_ADDR_VAR 0 4
12140: PUSH
12141: LD_VAR 0 2
12145: PUSH
12146: FOR_IN
12147: IFFALSE 12177
// if See ( strana , sai ) then
12149: LD_VAR 0 1
12153: PPUSH
12154: LD_VAR 0 4
12158: PPUSH
12159: CALL_OW 292
12163: IFFALSE 12175
// begin see_any_r := true ;
12165: LD_ADDR_VAR 0 5
12169: PUSH
12170: LD_INT 1
12172: ST_TO_ADDR
// break ;
12173: GO 12177
// end ;
12175: GO 12146
12177: POP
12178: POP
// ; result := see_any_r ;
12179: LD_ADDR_VAR 0 3
12183: PUSH
12184: LD_VAR 0 5
12188: ST_TO_ADDR
// end ;
12189: LD_VAR 0 3
12193: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
12194: LD_INT 0
12196: PPUSH
12197: PPUSH
12198: PPUSH
12199: PPUSH
// for i in who do
12200: LD_ADDR_VAR 0 6
12204: PUSH
12205: LD_VAR 0 1
12209: PUSH
12210: FOR_IN
12211: IFFALSE 12282
// begin for j in what do
12213: LD_ADDR_VAR 0 7
12217: PUSH
12218: LD_VAR 0 3
12222: PUSH
12223: FOR_IN
12224: IFFALSE 12278
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
12226: LD_VAR 0 7
12230: PPUSH
12231: CALL_OW 311
12235: NOT
12236: PUSH
12237: LD_VAR 0 6
12241: PPUSH
12242: LD_VAR 0 7
12246: PPUSH
12247: CALL_OW 296
12251: PUSH
12252: LD_VAR 0 2
12256: LESSEQUAL
12257: AND
12258: IFFALSE 12276
// begin ComEnterUnit ( i , j ) ;
12260: LD_VAR 0 6
12264: PPUSH
12265: LD_VAR 0 7
12269: PPUSH
12270: CALL_OW 120
// break ;
12274: GO 12278
// end ; end ;
12276: GO 12223
12278: POP
12279: POP
// end ;
12280: GO 12210
12282: POP
12283: POP
// end ;
12284: LD_VAR 0 4
12288: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
12289: LD_INT 0
12291: PPUSH
12292: PPUSH
12293: PPUSH
12294: PPUSH
// for i in who do
12295: LD_ADDR_VAR 0 6
12299: PUSH
12300: LD_VAR 0 1
12304: PUSH
12305: FOR_IN
12306: IFFALSE 12405
// begin add := false ;
12308: LD_ADDR_VAR 0 5
12312: PUSH
12313: LD_INT 0
12315: ST_TO_ADDR
// for j in what do
12316: LD_ADDR_VAR 0 7
12320: PUSH
12321: LD_VAR 0 3
12325: PUSH
12326: FOR_IN
12327: IFFALSE 12361
// begin if GetDistUnits ( i , j ) <= dist then
12329: LD_VAR 0 6
12333: PPUSH
12334: LD_VAR 0 7
12338: PPUSH
12339: CALL_OW 296
12343: PUSH
12344: LD_VAR 0 2
12348: LESSEQUAL
12349: IFFALSE 12359
// begin add := true ;
12351: LD_ADDR_VAR 0 5
12355: PUSH
12356: LD_INT 1
12358: ST_TO_ADDR
// end ; end ;
12359: GO 12326
12361: POP
12362: POP
// if add then
12363: LD_VAR 0 5
12367: IFFALSE 12403
// begin if result then
12369: LD_VAR 0 4
12373: IFFALSE 12393
// result := result ^ i else
12375: LD_ADDR_VAR 0 4
12379: PUSH
12380: LD_VAR 0 4
12384: PUSH
12385: LD_VAR 0 6
12389: ADD
12390: ST_TO_ADDR
12391: GO 12403
// result := i ;
12393: LD_ADDR_VAR 0 4
12397: PUSH
12398: LD_VAR 0 6
12402: ST_TO_ADDR
// end ; end ;
12403: GO 12305
12405: POP
12406: POP
// end ;
12407: LD_VAR 0 4
12411: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
12412: LD_INT 0
12414: PPUSH
12415: PPUSH
12416: PPUSH
// i1 := 1 ;
12417: LD_ADDR_VAR 0 5
12421: PUSH
12422: LD_INT 1
12424: ST_TO_ADDR
// while i1 <= path do
12425: LD_VAR 0 5
12429: PUSH
12430: LD_VAR 0 2
12434: LESSEQUAL
12435: IFFALSE 12682
// begin a := path [ i1 ] ;
12437: LD_ADDR_VAR 0 6
12441: PUSH
12442: LD_VAR 0 2
12446: PUSH
12447: LD_VAR 0 5
12451: ARRAY
12452: ST_TO_ADDR
// if a < 0 then
12453: LD_VAR 0 6
12457: PUSH
12458: LD_INT 0
12460: LESS
12461: IFFALSE 12518
// begin while a <= - 1 do
12463: LD_VAR 0 6
12467: PUSH
12468: LD_INT 1
12470: NEG
12471: LESSEQUAL
12472: IFFALSE 12502
// begin a := a + 1 ;
12474: LD_ADDR_VAR 0 6
12478: PUSH
12479: LD_VAR 0 6
12483: PUSH
12484: LD_INT 1
12486: PLUS
12487: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
12488: LD_VAR 0 1
12492: PPUSH
12493: LD_INT 35
12495: PPUSH
12496: CALL_OW 202
// end ;
12500: GO 12463
// i1 := i1 + 1 ;
12502: LD_ADDR_VAR 0 5
12506: PUSH
12507: LD_VAR 0 5
12511: PUSH
12512: LD_INT 1
12514: PLUS
12515: ST_TO_ADDR
// end else
12516: GO 12680
// begin if a = 0 then
12518: LD_VAR 0 6
12522: PUSH
12523: LD_INT 0
12525: EQUAL
12526: IFFALSE 12588
// begin a := path [ i1 + 1 ] ;
12528: LD_ADDR_VAR 0 6
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_VAR 0 5
12542: PUSH
12543: LD_INT 1
12545: PLUS
12546: ARRAY
12547: ST_TO_ADDR
// if a = 0 then
12548: LD_VAR 0 6
12552: PUSH
12553: LD_INT 0
12555: EQUAL
12556: IFFALSE 12567
// AddComReturn ( for_units ) ;
12558: LD_VAR 0 1
12562: PPUSH
12563: CALL_OW 204
// if a = 1 then
12567: LD_VAR 0 6
12571: PUSH
12572: LD_INT 1
12574: EQUAL
12575: IFFALSE 12586
// AddComRemember ( for_units ) ;
12577: LD_VAR 0 1
12581: PPUSH
12582: CALL_OW 203
// end else
12586: GO 12666
// begin if agressive then
12588: LD_VAR 0 3
12592: IFFALSE 12631
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
12594: LD_VAR 0 1
12598: PPUSH
12599: LD_VAR 0 2
12603: PUSH
12604: LD_VAR 0 5
12608: ARRAY
12609: PPUSH
12610: LD_VAR 0 2
12614: PUSH
12615: LD_VAR 0 5
12619: PUSH
12620: LD_INT 1
12622: PLUS
12623: ARRAY
12624: PPUSH
12625: CALL_OW 174
12629: GO 12666
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
12631: LD_VAR 0 1
12635: PPUSH
12636: LD_VAR 0 2
12640: PUSH
12641: LD_VAR 0 5
12645: ARRAY
12646: PPUSH
12647: LD_VAR 0 2
12651: PUSH
12652: LD_VAR 0 5
12656: PUSH
12657: LD_INT 1
12659: PLUS
12660: ARRAY
12661: PPUSH
12662: CALL_OW 171
// end ; i1 := i1 + 2 ;
12666: LD_ADDR_VAR 0 5
12670: PUSH
12671: LD_VAR 0 5
12675: PUSH
12676: LD_INT 2
12678: PLUS
12679: ST_TO_ADDR
// end ; end ;
12680: GO 12425
// end ;
12682: LD_VAR 0 4
12686: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
12687: LD_INT 0
12689: PPUSH
12690: PPUSH
12691: PPUSH
12692: PPUSH
12693: PPUSH
// forts := forts union [ ] ;
12694: LD_ADDR_VAR 0 1
12698: PUSH
12699: LD_VAR 0 1
12703: PUSH
12704: EMPTY
12705: UNION
12706: ST_TO_ADDR
// sols := sols union [ ] ;
12707: LD_ADDR_VAR 0 2
12711: PUSH
12712: LD_VAR 0 2
12716: PUSH
12717: EMPTY
12718: UNION
12719: ST_TO_ADDR
// for i in forts do
12720: LD_ADDR_VAR 0 6
12724: PUSH
12725: LD_VAR 0 1
12729: PUSH
12730: FOR_IN
12731: IFFALSE 12767
// if not UnitsInside ( i ) then
12733: LD_VAR 0 6
12737: PPUSH
12738: CALL_OW 313
12742: NOT
12743: IFFALSE 12765
// empty := add ( empty , i ) ;
12745: LD_ADDR_VAR 0 4
12749: PUSH
12750: LD_VAR 0 4
12754: PPUSH
12755: LD_VAR 0 6
12759: PPUSH
12760: CALL 13086 0 2
12764: ST_TO_ADDR
12765: GO 12730
12767: POP
12768: POP
// for i in sols do
12769: LD_ADDR_VAR 0 6
12773: PUSH
12774: LD_VAR 0 2
12778: PUSH
12779: FOR_IN
12780: IFFALSE 12828
// if not IsInUnit ( i ) and not IsBusy ( i ) then
12782: LD_VAR 0 6
12786: PPUSH
12787: CALL_OW 310
12791: NOT
12792: PUSH
12793: LD_VAR 0 6
12797: PPUSH
12798: CALL_OW 315
12802: NOT
12803: AND
12804: IFFALSE 12826
// free := add ( free , i ) ;
12806: LD_ADDR_VAR 0 5
12810: PUSH
12811: LD_VAR 0 5
12815: PPUSH
12816: LD_VAR 0 6
12820: PPUSH
12821: CALL 13086 0 2
12825: ST_TO_ADDR
12826: GO 12779
12828: POP
12829: POP
// result := forts diff empty ;
12830: LD_ADDR_VAR 0 3
12834: PUSH
12835: LD_VAR 0 1
12839: PUSH
12840: LD_VAR 0 4
12844: DIFF
12845: ST_TO_ADDR
// if empty <= free then
12846: LD_VAR 0 4
12850: PUSH
12851: LD_VAR 0 5
12855: LESSEQUAL
12856: IFFALSE 12870
// konec := empty else
12858: LD_ADDR_VAR 0 7
12862: PUSH
12863: LD_VAR 0 4
12867: ST_TO_ADDR
12868: GO 12880
// konec := free ;
12870: LD_ADDR_VAR 0 7
12874: PUSH
12875: LD_VAR 0 5
12879: ST_TO_ADDR
// for i := 1 to konec do
12880: LD_ADDR_VAR 0 6
12884: PUSH
12885: DOUBLE
12886: LD_INT 1
12888: DEC
12889: ST_TO_ADDR
12890: LD_VAR 0 7
12894: PUSH
12895: FOR_TO
12896: IFFALSE 12952
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
12898: LD_VAR 0 5
12902: PUSH
12903: LD_VAR 0 6
12907: ARRAY
12908: PPUSH
12909: LD_VAR 0 4
12913: PUSH
12914: LD_VAR 0 6
12918: ARRAY
12919: PPUSH
12920: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
12924: LD_ADDR_VAR 0 3
12928: PUSH
12929: LD_VAR 0 3
12933: PPUSH
12934: LD_VAR 0 4
12938: PUSH
12939: LD_VAR 0 6
12943: ARRAY
12944: PPUSH
12945: CALL 13086 0 2
12949: ST_TO_ADDR
// end ;
12950: GO 12895
12952: POP
12953: POP
// end ;
12954: LD_VAR 0 3
12958: RET
// export function TalkOn ; begin
12959: LD_INT 0
12961: PPUSH
// end ;
12962: LD_VAR 0 1
12966: RET
// export function TalkOff ; begin
12967: LD_INT 0
12969: PPUSH
// end ;
12970: LD_VAR 0 1
12974: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
12975: LD_INT 0
12977: PPUSH
12978: PPUSH
12979: PPUSH
12980: PPUSH
// l1 := [ ] ;
12981: LD_ADDR_VAR 0 3
12985: PUSH
12986: EMPTY
12987: ST_TO_ADDR
// l2 := [ ] ;
12988: LD_ADDR_VAR 0 4
12992: PUSH
12993: EMPTY
12994: ST_TO_ADDR
// for i := 1 to list div 2 do
12995: LD_ADDR_VAR 0 5
12999: PUSH
13000: DOUBLE
13001: LD_INT 1
13003: DEC
13004: ST_TO_ADDR
13005: LD_VAR 0 1
13009: PUSH
13010: LD_INT 2
13012: DIV
13013: PUSH
13014: FOR_TO
13015: IFFALSE 13041
// begin l1 := l1 ^ list [ i ] ;
13017: LD_ADDR_VAR 0 3
13021: PUSH
13022: LD_VAR 0 3
13026: PUSH
13027: LD_VAR 0 1
13031: PUSH
13032: LD_VAR 0 5
13036: ARRAY
13037: ADD
13038: ST_TO_ADDR
// end ;
13039: GO 13014
13041: POP
13042: POP
// l2 := list diff l1 ;
13043: LD_ADDR_VAR 0 4
13047: PUSH
13048: LD_VAR 0 1
13052: PUSH
13053: LD_VAR 0 3
13057: DIFF
13058: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
13059: LD_ADDR_VAR 0 2
13063: PUSH
13064: LD_VAR 0 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: PUSH
13072: LD_VAR 0 4
13076: PUSH
13077: EMPTY
13078: LIST
13079: ADD
13080: ST_TO_ADDR
// end ;
13081: LD_VAR 0 2
13085: RET
// export function add ( list , list1 ) ; begin
13086: LD_INT 0
13088: PPUSH
// if list = 0 then
13089: LD_VAR 0 1
13093: PUSH
13094: LD_INT 0
13096: EQUAL
13097: IFFALSE 13106
// list := [ ] ;
13099: LD_ADDR_VAR 0 1
13103: PUSH
13104: EMPTY
13105: ST_TO_ADDR
// if list1 = 0 then
13106: LD_VAR 0 2
13110: PUSH
13111: LD_INT 0
13113: EQUAL
13114: IFFALSE 13123
// list1 := [ ] ;
13116: LD_ADDR_VAR 0 2
13120: PUSH
13121: EMPTY
13122: ST_TO_ADDR
// result := list ^ list1 ;
13123: LD_ADDR_VAR 0 3
13127: PUSH
13128: LD_VAR 0 1
13132: PUSH
13133: LD_VAR 0 2
13137: ADD
13138: ST_TO_ADDR
// end ;
13139: LD_VAR 0 3
13143: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
13144: LD_INT 0
13146: PPUSH
13147: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
13148: LD_ADDR_VAR 0 8
13152: PUSH
13153: LD_VAR 0 1
13157: PPUSH
13158: LD_VAR 0 3
13162: PPUSH
13163: LD_VAR 0 4
13167: PPUSH
13168: LD_VAR 0 5
13172: PPUSH
13173: LD_VAR 0 6
13177: PPUSH
13178: CALL 13224 0 5
13182: ST_TO_ADDR
// if kdo then
13183: LD_VAR 0 8
13187: IFFALSE 13211
// result := Say ( kdo , ident ) else
13189: LD_ADDR_VAR 0 7
13193: PUSH
13194: LD_VAR 0 8
13198: PPUSH
13199: LD_VAR 0 2
13203: PPUSH
13204: CALL_OW 88
13208: ST_TO_ADDR
13209: GO 13219
// result := false ;
13211: LD_ADDR_VAR 0 7
13215: PUSH
13216: LD_INT 0
13218: ST_TO_ADDR
// end ;
13219: LD_VAR 0 7
13223: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
13224: LD_INT 0
13226: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
13227: LD_ADDR_VAR 0 1
13231: PUSH
13232: LD_VAR 0 1
13236: PPUSH
13237: LD_INT 21
13239: PUSH
13240: LD_INT 1
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PUSH
13247: LD_INT 22
13249: PUSH
13250: LD_VAR 0 2
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: PUSH
13259: LD_INT 3
13261: PUSH
13262: LD_INT 23
13264: PUSH
13265: LD_INT 0
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: PPUSH
13278: CALL_OW 72
13282: ST_TO_ADDR
// if sex <> 0 then
13283: LD_VAR 0 3
13287: PUSH
13288: LD_INT 0
13290: NONEQUAL
13291: IFFALSE 13320
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
13293: LD_ADDR_VAR 0 1
13297: PUSH
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 26
13305: PUSH
13306: LD_VAR 0 3
13310: PUSH
13311: EMPTY
13312: LIST
13313: LIST
13314: PPUSH
13315: CALL_OW 72
13319: ST_TO_ADDR
// if Hclass <> 0 then
13320: LD_VAR 0 4
13324: PUSH
13325: LD_INT 0
13327: NONEQUAL
13328: IFFALSE 13357
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
13330: LD_ADDR_VAR 0 1
13334: PUSH
13335: LD_VAR 0 1
13339: PPUSH
13340: LD_INT 25
13342: PUSH
13343: LD_VAR 0 4
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: PPUSH
13352: CALL_OW 72
13356: ST_TO_ADDR
// if index <= 0 then
13357: LD_VAR 0 5
13361: PUSH
13362: LD_INT 0
13364: LESSEQUAL
13365: IFFALSE 13375
// index := 1 ;
13367: LD_ADDR_VAR 0 5
13371: PUSH
13372: LD_INT 1
13374: ST_TO_ADDR
// if lidi >= index then
13375: LD_VAR 0 1
13379: PUSH
13380: LD_VAR 0 5
13384: GREATEREQUAL
13385: IFFALSE 13405
// result := lidi [ index ] else
13387: LD_ADDR_VAR 0 6
13391: PUSH
13392: LD_VAR 0 1
13396: PUSH
13397: LD_VAR 0 5
13401: ARRAY
13402: ST_TO_ADDR
13403: GO 13413
// result := 0 ;
13405: LD_ADDR_VAR 0 6
13409: PUSH
13410: LD_INT 0
13412: ST_TO_ADDR
// end ;
13413: LD_VAR 0 6
13417: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
13418: LD_INT 0
13420: PPUSH
13421: PPUSH
13422: PPUSH
// result := [ ] ;
13423: LD_ADDR_VAR 0 3
13427: PUSH
13428: EMPTY
13429: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
13430: LD_ADDR_VAR 0 4
13434: PUSH
13435: LD_VAR 0 1
13439: PPUSH
13440: EMPTY
13441: PPUSH
13442: CALL_OW 70
13446: ST_TO_ADDR
// for i in inbase do
13447: LD_ADDR_VAR 0 5
13451: PUSH
13452: LD_VAR 0 4
13456: PUSH
13457: FOR_IN
13458: IFFALSE 13531
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
13460: LD_VAR 0 5
13464: PPUSH
13465: CALL_OW 247
13469: PUSH
13470: LD_INT 3
13472: EQUAL
13473: PUSH
13474: LD_VAR 0 5
13478: PPUSH
13479: CALL_OW 247
13483: PUSH
13484: LD_INT 2
13486: EQUAL
13487: OR
13488: IFFALSE 13513
// begin result := result ^ UnitsInside ( i ) ;
13490: LD_ADDR_VAR 0 3
13494: PUSH
13495: LD_VAR 0 3
13499: PUSH
13500: LD_VAR 0 5
13504: PPUSH
13505: CALL_OW 313
13509: ADD
13510: ST_TO_ADDR
// end else
13511: GO 13529
// begin result := result ^ i ;
13513: LD_ADDR_VAR 0 3
13517: PUSH
13518: LD_VAR 0 3
13522: PUSH
13523: LD_VAR 0 5
13527: ADD
13528: ST_TO_ADDR
// end ; end ;
13529: GO 13457
13531: POP
13532: POP
// result := UnitFilter ( result , filter ) ;
13533: LD_ADDR_VAR 0 3
13537: PUSH
13538: LD_VAR 0 3
13542: PPUSH
13543: LD_VAR 0 2
13547: PPUSH
13548: CALL_OW 72
13552: ST_TO_ADDR
// end ;
13553: LD_VAR 0 3
13557: RET
// export function ReverseList ( list ) ; var i ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
// result := [ ] ;
13562: LD_ADDR_VAR 0 2
13566: PUSH
13567: EMPTY
13568: ST_TO_ADDR
// for i := list + 0 downto 1 do
13569: LD_ADDR_VAR 0 3
13573: PUSH
13574: DOUBLE
13575: LD_VAR 0 1
13579: PUSH
13580: LD_INT 0
13582: PLUS
13583: INC
13584: ST_TO_ADDR
13585: LD_INT 1
13587: PUSH
13588: FOR_DOWNTO
13589: IFFALSE 13618
// begin result := result ^ [ list [ i ] ] ;
13591: LD_ADDR_VAR 0 2
13595: PUSH
13596: LD_VAR 0 2
13600: PUSH
13601: LD_VAR 0 1
13605: PUSH
13606: LD_VAR 0 3
13610: ARRAY
13611: PUSH
13612: EMPTY
13613: LIST
13614: ADD
13615: ST_TO_ADDR
// end ;
13616: GO 13588
13618: POP
13619: POP
// end ;
13620: LD_VAR 0 2
13624: RET
// export using8 , using1 , using2 , using3 ; export path8 , path1 , path2 , path3 ; export kdo8 , kdo1 , kdo2 , kdo3 ; export using4 , using5 , using6 , using7 ; export path4 , path5 , path6 , path7 ; export kdo4 , kdo5 , kdo6 , kdo7 ; export function attack ( kdo , path ) ; var i , a ; begin
13625: LD_INT 0
13627: PPUSH
13628: PPUSH
13629: PPUSH
// for i in kdo do
13630: LD_ADDR_VAR 0 4
13634: PUSH
13635: LD_VAR 0 1
13639: PUSH
13640: FOR_IN
13641: IFFALSE 13657
// begin SetTag ( i , 1 ) ;
13643: LD_VAR 0 4
13647: PPUSH
13648: LD_INT 1
13650: PPUSH
13651: CALL_OW 109
// end ;
13655: GO 13640
13657: POP
13658: POP
// while kdo do
13659: LD_VAR 0 1
13663: IFFALSE 13958
// begin for i in kdo do
13665: LD_ADDR_VAR 0 4
13669: PUSH
13670: LD_VAR 0 1
13674: PUSH
13675: FOR_IN
13676: IFFALSE 13947
// begin a := GetTag ( i ) ;
13678: LD_ADDR_VAR 0 5
13682: PUSH
13683: LD_VAR 0 4
13687: PPUSH
13688: CALL_OW 110
13692: ST_TO_ADDR
// if a <= path then
13693: LD_VAR 0 5
13697: PUSH
13698: LD_VAR 0 2
13702: LESSEQUAL
13703: IFFALSE 13931
// begin if not IsDead ( i ) then
13705: LD_VAR 0 4
13709: PPUSH
13710: CALL_OW 301
13714: NOT
13715: IFFALSE 13889
// begin if IsIdle ( i ) then
13717: LD_VAR 0 4
13721: PPUSH
13722: CALL_OW 316
13726: IFFALSE 13887
// begin if a = 1 then
13728: LD_VAR 0 5
13732: PUSH
13733: LD_INT 1
13735: EQUAL
13736: IFFALSE 13777
// begin ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13738: LD_VAR 0 4
13742: PPUSH
13743: LD_VAR 0 2
13747: PUSH
13748: LD_VAR 0 5
13752: ARRAY
13753: PUSH
13754: LD_INT 1
13756: ARRAY
13757: PPUSH
13758: LD_VAR 0 2
13762: PUSH
13763: LD_VAR 0 5
13767: ARRAY
13768: PUSH
13769: LD_INT 2
13771: ARRAY
13772: PPUSH
13773: CALL_OW 114
// end ; if GetDistUnitXY ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) < 5 then
13777: LD_VAR 0 4
13781: PPUSH
13782: LD_VAR 0 2
13786: PUSH
13787: LD_VAR 0 5
13791: ARRAY
13792: PUSH
13793: LD_INT 1
13795: ARRAY
13796: PPUSH
13797: LD_VAR 0 2
13801: PUSH
13802: LD_VAR 0 5
13806: ARRAY
13807: PUSH
13808: LD_INT 2
13810: ARRAY
13811: PPUSH
13812: CALL_OW 297
13816: PUSH
13817: LD_INT 5
13819: LESS
13820: IFFALSE 13887
// begin a := a + 1 ;
13822: LD_ADDR_VAR 0 5
13826: PUSH
13827: LD_VAR 0 5
13831: PUSH
13832: LD_INT 1
13834: PLUS
13835: ST_TO_ADDR
// if a <= path then
13836: LD_VAR 0 5
13840: PUSH
13841: LD_VAR 0 2
13845: LESSEQUAL
13846: IFFALSE 13887
// ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13848: LD_VAR 0 4
13852: PPUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 5
13862: ARRAY
13863: PUSH
13864: LD_INT 1
13866: ARRAY
13867: PPUSH
13868: LD_VAR 0 2
13872: PUSH
13873: LD_VAR 0 5
13877: ARRAY
13878: PUSH
13879: LD_INT 2
13881: ARRAY
13882: PPUSH
13883: CALL_OW 114
// end ; end ; end else
13887: GO 13903
// a := a + 1 ;
13889: LD_ADDR_VAR 0 5
13893: PUSH
13894: LD_VAR 0 5
13898: PUSH
13899: LD_INT 1
13901: PLUS
13902: ST_TO_ADDR
// if a > path then
13903: LD_VAR 0 5
13907: PUSH
13908: LD_VAR 0 2
13912: GREATER
13913: IFFALSE 13931
// kdo := kdo diff i ;
13915: LD_ADDR_VAR 0 1
13919: PUSH
13920: LD_VAR 0 1
13924: PUSH
13925: LD_VAR 0 4
13929: DIFF
13930: ST_TO_ADDR
// end ; SetTag ( i , a ) ;
13931: LD_VAR 0 4
13935: PPUSH
13936: LD_VAR 0 5
13940: PPUSH
13941: CALL_OW 109
// end ;
13945: GO 13675
13947: POP
13948: POP
// wait ( 0 0$1 ) ;
13949: LD_INT 35
13951: PPUSH
13952: CALL_OW 67
// end ;
13956: GO 13659
// end ;
13958: LD_VAR 0 3
13962: RET
// export function AttackBase ( kdo , path ) ; begin
13963: LD_INT 0
13965: PPUSH
// case false of using1 :
13966: LD_INT 0
13968: PUSH
13969: LD_EXP 83
13973: DOUBLE
13974: EQUAL
13975: IFTRUE 13979
13977: GO 14009
13979: POP
// begin kdo1 := kdo ;
13980: LD_ADDR_EXP 91
13984: PUSH
13985: LD_VAR 0 1
13989: ST_TO_ADDR
// path1 := path ;
13990: LD_ADDR_EXP 87
13994: PUSH
13995: LD_VAR 0 2
13999: ST_TO_ADDR
// RaiseSailEvent ( 1 ) ;
14000: LD_INT 1
14002: PPUSH
14003: CALL_OW 427
// end ; using2 :
14007: GO 14290
14009: LD_EXP 84
14013: DOUBLE
14014: EQUAL
14015: IFTRUE 14019
14017: GO 14049
14019: POP
// begin kdo2 := kdo ;
14020: LD_ADDR_EXP 92
14024: PUSH
14025: LD_VAR 0 1
14029: ST_TO_ADDR
// path2 := path ;
14030: LD_ADDR_EXP 88
14034: PUSH
14035: LD_VAR 0 2
14039: ST_TO_ADDR
// RaiseSailEvent ( 2 ) ;
14040: LD_INT 2
14042: PPUSH
14043: CALL_OW 427
// end ; using3 :
14047: GO 14290
14049: LD_EXP 85
14053: DOUBLE
14054: EQUAL
14055: IFTRUE 14059
14057: GO 14089
14059: POP
// begin kdo3 := kdo ;
14060: LD_ADDR_EXP 93
14064: PUSH
14065: LD_VAR 0 1
14069: ST_TO_ADDR
// path3 := path ;
14070: LD_ADDR_EXP 89
14074: PUSH
14075: LD_VAR 0 2
14079: ST_TO_ADDR
// RaiseSailEvent ( 3 ) ;
14080: LD_INT 3
14082: PPUSH
14083: CALL_OW 427
// end ; using4 :
14087: GO 14290
14089: LD_EXP 94
14093: DOUBLE
14094: EQUAL
14095: IFTRUE 14099
14097: GO 14129
14099: POP
// begin kdo4 := kdo ;
14100: LD_ADDR_EXP 102
14104: PUSH
14105: LD_VAR 0 1
14109: ST_TO_ADDR
// path4 := path ;
14110: LD_ADDR_EXP 98
14114: PUSH
14115: LD_VAR 0 2
14119: ST_TO_ADDR
// RaiseSailEvent ( 4 ) ;
14120: LD_INT 4
14122: PPUSH
14123: CALL_OW 427
// end ; using5 :
14127: GO 14290
14129: LD_EXP 95
14133: DOUBLE
14134: EQUAL
14135: IFTRUE 14139
14137: GO 14169
14139: POP
// begin kdo5 := kdo ;
14140: LD_ADDR_EXP 103
14144: PUSH
14145: LD_VAR 0 1
14149: ST_TO_ADDR
// path5 := path ;
14150: LD_ADDR_EXP 99
14154: PUSH
14155: LD_VAR 0 2
14159: ST_TO_ADDR
// RaiseSailEvent ( 5 ) ;
14160: LD_INT 5
14162: PPUSH
14163: CALL_OW 427
// end ; using6 :
14167: GO 14290
14169: LD_EXP 96
14173: DOUBLE
14174: EQUAL
14175: IFTRUE 14179
14177: GO 14209
14179: POP
// begin kdo6 := kdo ;
14180: LD_ADDR_EXP 104
14184: PUSH
14185: LD_VAR 0 1
14189: ST_TO_ADDR
// path6 := path ;
14190: LD_ADDR_EXP 100
14194: PUSH
14195: LD_VAR 0 2
14199: ST_TO_ADDR
// RaiseSailEvent ( 6 ) ;
14200: LD_INT 6
14202: PPUSH
14203: CALL_OW 427
// end ; using7 :
14207: GO 14290
14209: LD_EXP 97
14213: DOUBLE
14214: EQUAL
14215: IFTRUE 14219
14217: GO 14249
14219: POP
// begin kdo7 := kdo ;
14220: LD_ADDR_EXP 105
14224: PUSH
14225: LD_VAR 0 1
14229: ST_TO_ADDR
// path7 := path ;
14230: LD_ADDR_EXP 101
14234: PUSH
14235: LD_VAR 0 2
14239: ST_TO_ADDR
// RaiseSailEvent ( 7 ) ;
14240: LD_INT 7
14242: PPUSH
14243: CALL_OW 427
// end ; using8 :
14247: GO 14290
14249: LD_EXP 82
14253: DOUBLE
14254: EQUAL
14255: IFTRUE 14259
14257: GO 14289
14259: POP
// begin kdo8 := kdo ;
14260: LD_ADDR_EXP 90
14264: PUSH
14265: LD_VAR 0 1
14269: ST_TO_ADDR
// path8 := path ;
14270: LD_ADDR_EXP 86
14274: PUSH
14275: LD_VAR 0 2
14279: ST_TO_ADDR
// RaiseSailEvent ( 8 ) ;
14280: LD_INT 8
14282: PPUSH
14283: CALL_OW 427
// end ; end ;
14287: GO 14290
14289: POP
// end ;
14290: LD_VAR 0 3
14294: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
14295: LD_INT 0
14297: PPUSH
// if not hinty_co_byli then
14298: LD_EXP 106
14302: NOT
14303: IFFALSE 14312
// hinty_co_byli := [ ] ;
14305: LD_ADDR_EXP 106
14309: PUSH
14310: EMPTY
14311: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
14312: LD_VAR 0 1
14316: PUSH
14317: LD_EXP 106
14321: IN
14322: NOT
14323: IFFALSE 14350
// begin hinty_co_byli := hinty_co_byli ^ ident ;
14325: LD_ADDR_EXP 106
14329: PUSH
14330: LD_EXP 106
14334: PUSH
14335: LD_VAR 0 1
14339: ADD
14340: ST_TO_ADDR
// Hint ( ident ) ;
14341: LD_VAR 0 1
14345: PPUSH
14346: CALL_OW 339
// end ; end ; end_of_file
14350: LD_VAR 0 2
14354: RET
// every 0 0$0.3 trigger FilterUnitsInArea ( at_mine , [ [ f_side , you ] , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ] ) do var a ;
14355: LD_INT 20
14357: PPUSH
14358: LD_INT 22
14360: PUSH
14361: LD_EXP 47
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: PUSH
14370: LD_INT 2
14372: PUSH
14373: LD_INT 34
14375: PUSH
14376: LD_INT 44
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 34
14385: PUSH
14386: LD_INT 45
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 34
14395: PUSH
14396: LD_INT 46
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: EMPTY
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PPUSH
14413: CALL_OW 70
14417: IFFALSE 14503
14419: GO 14421
14421: DISABLE
14422: LD_INT 0
14424: PPUSH
// begin if IsLive ( rumine1 ) then
14425: LD_EXP 68
14429: PPUSH
14430: CALL_OW 300
14434: IFFALSE 14502
// begin a := FilterUnitsInArea ( at_mine , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ) ;
14436: LD_ADDR_VAR 0 1
14440: PUSH
14441: LD_INT 20
14443: PPUSH
14444: LD_INT 2
14446: PUSH
14447: LD_INT 34
14449: PUSH
14450: LD_INT 44
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: PUSH
14457: LD_INT 34
14459: PUSH
14460: LD_INT 45
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PUSH
14467: LD_INT 34
14469: PUSH
14470: LD_INT 46
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: PPUSH
14483: CALL_OW 70
14487: ST_TO_ADDR
// ComAttackUnit ( a , rumine1 ) ;
14488: LD_VAR 0 1
14492: PPUSH
14493: LD_EXP 68
14497: PPUSH
14498: CALL_OW 115
// end ; enable ;
14502: ENABLE
// end ;
14503: PPOPN 1
14505: END
// export function rep_car ( i ) ; begin
14506: LD_INT 0
14508: PPUSH
// case true of IsInArea ( i , NearL ) :
14509: LD_INT 1
14511: PUSH
14512: LD_VAR 0 1
14516: PPUSH
14517: LD_INT 16
14519: PPUSH
14520: CALL_OW 308
14524: DOUBLE
14525: EQUAL
14526: IFTRUE 14530
14528: GO 14545
14530: POP
// ComMoveToArea ( i , repL ) ; IsInArea ( i , NearM ) :
14531: LD_VAR 0 1
14535: PPUSH
14536: LD_INT 24
14538: PPUSH
14539: CALL_OW 113
14543: GO 14645
14545: LD_VAR 0 1
14549: PPUSH
14550: LD_INT 17
14552: PPUSH
14553: CALL_OW 308
14557: DOUBLE
14558: EQUAL
14559: IFTRUE 14563
14561: GO 14578
14563: POP
// ComMoveToArea ( i , repM ) ; IsInArea ( i , NearR ) :
14564: LD_VAR 0 1
14568: PPUSH
14569: LD_INT 25
14571: PPUSH
14572: CALL_OW 113
14576: GO 14645
14578: LD_VAR 0 1
14582: PPUSH
14583: LD_INT 18
14585: PPUSH
14586: CALL_OW 308
14590: DOUBLE
14591: EQUAL
14592: IFTRUE 14596
14594: GO 14611
14596: POP
// ComMoveToArea ( i , repR ) ; IsInArea ( i , NearT ) :
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 26
14604: PPUSH
14605: CALL_OW 113
14609: GO 14645
14611: LD_VAR 0 1
14615: PPUSH
14616: LD_INT 19
14618: PPUSH
14619: CALL_OW 308
14623: DOUBLE
14624: EQUAL
14625: IFTRUE 14629
14627: GO 14644
14629: POP
// ComMoveToArea ( i , repL ) ; end ;
14630: LD_VAR 0 1
14634: PPUSH
14635: LD_INT 24
14637: PPUSH
14638: CALL_OW 113
14642: GO 14645
14644: POP
// while not IsIdle ( i ) do
14645: LD_VAR 0 1
14649: PPUSH
14650: CALL_OW 316
14654: NOT
14655: IFFALSE 14666
// wait ( 0 0$1 ) ;
14657: LD_INT 35
14659: PPUSH
14660: CALL_OW 67
14664: GO 14645
// AddComExitVehicle ( UnitsInside ( i ) ) ;
14666: LD_VAR 0 1
14670: PPUSH
14671: CALL_OW 313
14675: PPUSH
14676: CALL_OW 181
// end ;
14680: LD_VAR 0 2
14684: RET
// export function ret_car ( i ) ; begin
14685: LD_INT 0
14687: PPUSH
// ComEnterUnit ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) , i ) , i ) ;
14688: LD_INT 22
14690: PUSH
14691: LD_EXP 49
14695: PUSH
14696: EMPTY
14697: LIST
14698: LIST
14699: PUSH
14700: LD_INT 21
14702: PUSH
14703: LD_INT 1
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PPUSH
14714: CALL_OW 69
14718: PPUSH
14719: LD_VAR 0 1
14723: PPUSH
14724: CALL_OW 74
14728: PPUSH
14729: LD_VAR 0 1
14733: PPUSH
14734: CALL_OW 120
// while not UnitsInside ( i ) do
14738: LD_VAR 0 1
14742: PPUSH
14743: CALL_OW 313
14747: NOT
14748: IFFALSE 14759
// wait ( 0 0$1 ) ;
14750: LD_INT 35
14752: PPUSH
14753: CALL_OW 67
14757: GO 14738
// ComAgressiveMove ( i , 92 , 92 ) ;
14759: LD_VAR 0 1
14763: PPUSH
14764: LD_INT 92
14766: PPUSH
14767: LD_INT 92
14769: PPUSH
14770: CALL_OW 114
// end ;
14774: LD_VAR 0 2
14778: RET
// every 0 0$1 do var vehs , i ;
14779: GO 14781
14781: DISABLE
14782: LD_INT 0
14784: PPUSH
14785: PPUSH
// begin vehs := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
14786: LD_ADDR_VAR 0 1
14790: PUSH
14791: LD_INT 22
14793: PUSH
14794: LD_EXP 49
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: LD_INT 21
14805: PUSH
14806: LD_INT 2
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: EMPTY
14814: LIST
14815: LIST
14816: PPUSH
14817: CALL_OW 69
14821: ST_TO_ADDR
// for i in vehs do
14822: LD_ADDR_VAR 0 2
14826: PUSH
14827: LD_VAR 0 1
14831: PUSH
14832: FOR_IN
14833: IFFALSE 14925
// begin if GetClass ( UnitsInside ( i ) ) = class_mechanic then
14835: LD_VAR 0 2
14839: PPUSH
14840: CALL_OW 313
14844: PPUSH
14845: CALL_OW 257
14849: PUSH
14850: LD_INT 3
14852: EQUAL
14853: IFFALSE 14923
// begin if GetLives ( i ) < 600 then
14855: LD_VAR 0 2
14859: PPUSH
14860: CALL_OW 256
14864: PUSH
14865: LD_INT 600
14867: LESS
14868: IFFALSE 14883
// RaiseSailEvent ( i + 1000 ) ;
14870: LD_VAR 0 2
14874: PUSH
14875: LD_INT 1000
14877: PLUS
14878: PPUSH
14879: CALL_OW 427
// if GetLives ( i ) > 900 and not UnitsInside ( i ) then
14883: LD_VAR 0 2
14887: PPUSH
14888: CALL_OW 256
14892: PUSH
14893: LD_INT 900
14895: GREATER
14896: PUSH
14897: LD_VAR 0 2
14901: PPUSH
14902: CALL_OW 313
14906: NOT
14907: AND
14908: IFFALSE 14923
// RaiseSailEvent ( i + 2000 ) ;
14910: LD_VAR 0 2
14914: PUSH
14915: LD_INT 2000
14917: PLUS
14918: PPUSH
14919: CALL_OW 427
// end ; end ;
14923: GO 14832
14925: POP
14926: POP
// enable ;
14927: ENABLE
// end ;
14928: PPOPN 2
14930: END
// every 10 10$0 trigger utocit do var u1 , u2 , p1 , i , b1 ;
14931: LD_EXP 2
14935: IFFALSE 15413
14937: GO 14939
14939: DISABLE
14940: LD_INT 0
14942: PPUSH
14943: PPUSH
14944: PPUSH
14945: PPUSH
14946: PPUSH
// begin case difficulty of 1 :
14947: LD_OWVAR 67
14951: PUSH
14952: LD_INT 1
14954: DOUBLE
14955: EQUAL
14956: IFTRUE 14960
14958: GO 15025
14960: POP
// begin u1 := CreateVH ( [ mhmg , mhmg ] ) ;
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_EXP 9
14970: PUSH
14971: LD_EXP 9
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL 23251 0 1
14984: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
14985: LD_ADDR_VAR 0 3
14989: PUSH
14990: LD_INT 1
14992: PPUSH
14993: LD_INT 1
14995: PPUSH
14996: CALL 22798 0 2
15000: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
15001: LD_ADDR_VAR 0 5
15005: PUSH
15006: LD_INT 2
15008: PPUSH
15009: CALL 23003 0 1
15013: PUSH
15014: LD_INT 1
15016: PPUSH
15017: CALL 23127 0 1
15021: ADD
15022: ST_TO_ADDR
// end ; 2 :
15023: GO 15184
15025: LD_INT 2
15027: DOUBLE
15028: EQUAL
15029: IFTRUE 15033
15031: GO 15098
15033: POP
// begin u1 := CreateVH ( [ mhmg , mgg ] ) ;
15034: LD_ADDR_VAR 0 1
15038: PUSH
15039: LD_EXP 9
15043: PUSH
15044: LD_EXP 10
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PPUSH
15053: CALL 23251 0 1
15057: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
15058: LD_ADDR_VAR 0 3
15062: PUSH
15063: LD_INT 2
15065: PPUSH
15066: LD_INT 0
15068: PPUSH
15069: CALL 22798 0 2
15073: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15074: LD_ADDR_VAR 0 5
15078: PUSH
15079: LD_INT 3
15081: PPUSH
15082: CALL 23003 0 1
15086: PUSH
15087: LD_INT 2
15089: PPUSH
15090: CALL 23127 0 1
15094: ADD
15095: ST_TO_ADDR
// end ; 3 :
15096: GO 15184
15098: LD_INT 3
15100: DOUBLE
15101: EQUAL
15102: IFTRUE 15106
15104: GO 15183
15106: POP
// begin u1 := CreateVH ( [ mgg ] ) ;
15107: LD_ADDR_VAR 0 1
15111: PUSH
15112: LD_EXP 10
15116: PUSH
15117: EMPTY
15118: LIST
15119: PPUSH
15120: CALL 23251 0 1
15124: ST_TO_ADDR
// u2 := CreateVC ( [ mgg ] ) ;
15125: LD_ADDR_VAR 0 2
15129: PUSH
15130: LD_EXP 10
15134: PUSH
15135: EMPTY
15136: LIST
15137: PPUSH
15138: CALL 23577 0 1
15142: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15143: LD_ADDR_VAR 0 3
15147: PUSH
15148: LD_INT 1
15150: PPUSH
15151: LD_INT 0
15153: PPUSH
15154: CALL 22798 0 2
15158: ST_TO_ADDR
// b1 := CreateB ( 5 ) ^ CreateS ( 3 ) ;
15159: LD_ADDR_VAR 0 5
15163: PUSH
15164: LD_INT 5
15166: PPUSH
15167: CALL 23003 0 1
15171: PUSH
15172: LD_INT 3
15174: PPUSH
15175: CALL 23127 0 1
15179: ADD
15180: ST_TO_ADDR
// end ; end ;
15181: GO 15184
15183: POP
// for i := 1 to u1 do
15184: LD_ADDR_VAR 0 4
15188: PUSH
15189: DOUBLE
15190: LD_INT 1
15192: DEC
15193: ST_TO_ADDR
15194: LD_VAR 0 1
15198: PUSH
15199: FOR_TO
15200: IFFALSE 15230
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15202: LD_VAR 0 3
15206: PUSH
15207: LD_VAR 0 4
15211: ARRAY
15212: PPUSH
15213: LD_VAR 0 1
15217: PUSH
15218: LD_VAR 0 4
15222: ARRAY
15223: PPUSH
15224: CALL_OW 52
// end ;
15228: GO 15199
15230: POP
15231: POP
// for i in u1 do
15232: LD_ADDR_VAR 0 4
15236: PUSH
15237: LD_VAR 0 1
15241: PUSH
15242: FOR_IN
15243: IFFALSE 15262
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15245: LD_VAR 0 4
15249: PPUSH
15250: LD_INT 3
15252: PPUSH
15253: LD_INT 0
15255: PPUSH
15256: CALL 23907 0 3
// end ;
15260: GO 15242
15262: POP
15263: POP
// for i in u2 do
15264: LD_ADDR_VAR 0 4
15268: PUSH
15269: LD_VAR 0 2
15273: PUSH
15274: FOR_IN
15275: IFFALSE 15294
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15277: LD_VAR 0 4
15281: PPUSH
15282: LD_INT 3
15284: PPUSH
15285: LD_INT 0
15287: PPUSH
15288: CALL 23907 0 3
// end ;
15292: GO 15274
15294: POP
15295: POP
// wait ( 0 0$1 ) ;
15296: LD_INT 35
15298: PPUSH
15299: CALL_OW 67
// AttackBase ( u1 ^ u2 , pathBL ^ pathUL ) ;
15303: LD_VAR 0 1
15307: PUSH
15308: LD_VAR 0 2
15312: ADD
15313: PPUSH
15314: LD_EXP 108
15318: PUSH
15319: LD_EXP 111
15323: ADD
15324: PPUSH
15325: CALL 13963 0 2
// for i in b1 do
15329: LD_ADDR_VAR 0 4
15333: PUSH
15334: LD_VAR 0 5
15338: PUSH
15339: FOR_IN
15340: IFFALSE 15359
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15342: LD_VAR 0 4
15346: PPUSH
15347: LD_INT 14
15349: PPUSH
15350: LD_INT 0
15352: PPUSH
15353: CALL 23907 0 3
// end ;
15357: GO 15339
15359: POP
15360: POP
// wait ( 0 0$1 ) ;
15361: LD_INT 35
15363: PPUSH
15364: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15368: LD_VAR 0 5
15372: PPUSH
15373: LD_EXP 118
15377: PPUSH
15378: CALL 13963 0 2
// while not ContactTime ( [ russians ] ) do
15382: LD_EXP 49
15386: PUSH
15387: EMPTY
15388: LIST
15389: PPUSH
15390: CALL_OW 462
15394: NOT
15395: IFFALSE 15406
// wait ( 0 0$1 ) ;
15397: LD_INT 35
15399: PPUSH
15400: CALL_OW 67
15404: GO 15382
// MyHint ( PriorityAttacks ) ;
15406: LD_STRING PriorityAttacks
15408: PPUSH
15409: CALL 14295 0 1
// end ;
15413: PPOPN 5
15415: END
// every 15 15$0 trigger utocit do var u1 , p1 , b1 , i , u2 , u1a ;
15416: LD_EXP 2
15420: IFFALSE 15969
15422: GO 15424
15424: DISABLE
15425: LD_INT 0
15427: PPUSH
15428: PPUSH
15429: PPUSH
15430: PPUSH
15431: PPUSH
15432: PPUSH
// begin case difficulty of 1 :
15433: LD_OWVAR 67
15437: PUSH
15438: LD_INT 1
15440: DOUBLE
15441: EQUAL
15442: IFTRUE 15446
15444: GO 15505
15446: POP
// begin u1 := CreateVH ( [ mg ] ) ;
15447: LD_ADDR_VAR 0 1
15451: PUSH
15452: LD_EXP 11
15456: PUSH
15457: EMPTY
15458: LIST
15459: PPUSH
15460: CALL 23251 0 1
15464: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_INT 1
15472: PPUSH
15473: LD_INT 0
15475: PPUSH
15476: CALL 22798 0 2
15480: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
15481: LD_ADDR_VAR 0 3
15485: PUSH
15486: LD_INT 2
15488: PPUSH
15489: CALL 23003 0 1
15493: PUSH
15494: LD_INT 1
15496: PPUSH
15497: CALL 23127 0 1
15501: ADD
15502: ST_TO_ADDR
// end ; 2 :
15503: GO 15640
15505: LD_INT 2
15507: DOUBLE
15508: EQUAL
15509: IFTRUE 15513
15511: GO 15572
15513: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15514: LD_ADDR_VAR 0 1
15518: PUSH
15519: LD_EXP 12
15523: PUSH
15524: EMPTY
15525: LIST
15526: PPUSH
15527: CALL 23251 0 1
15531: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 1
15539: PPUSH
15540: LD_INT 0
15542: PPUSH
15543: CALL 22798 0 2
15547: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15548: LD_ADDR_VAR 0 3
15552: PUSH
15553: LD_INT 3
15555: PPUSH
15556: CALL 23003 0 1
15560: PUSH
15561: LD_INT 2
15563: PPUSH
15564: CALL 23127 0 1
15568: ADD
15569: ST_TO_ADDR
// end ; 3 :
15570: GO 15640
15572: LD_INT 3
15574: DOUBLE
15575: EQUAL
15576: IFTRUE 15580
15578: GO 15639
15580: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15581: LD_ADDR_VAR 0 1
15585: PUSH
15586: LD_EXP 12
15590: PUSH
15591: EMPTY
15592: LIST
15593: PPUSH
15594: CALL 23251 0 1
15598: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15599: LD_ADDR_VAR 0 2
15603: PUSH
15604: LD_INT 0
15606: PPUSH
15607: LD_INT 1
15609: PPUSH
15610: CALL 22798 0 2
15614: ST_TO_ADDR
// b1 := CreateB ( 4 ) ^ CreateS ( 3 ) ;
15615: LD_ADDR_VAR 0 3
15619: PUSH
15620: LD_INT 4
15622: PPUSH
15623: CALL 23003 0 1
15627: PUSH
15628: LD_INT 3
15630: PPUSH
15631: CALL 23127 0 1
15635: ADD
15636: ST_TO_ADDR
// end ; end ;
15637: GO 15640
15639: POP
// for i in b1 do
15640: LD_ADDR_VAR 0 4
15644: PUSH
15645: LD_VAR 0 3
15649: PUSH
15650: FOR_IN
15651: IFFALSE 15670
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15653: LD_VAR 0 4
15657: PPUSH
15658: LD_INT 14
15660: PPUSH
15661: LD_INT 0
15663: PPUSH
15664: CALL 23907 0 3
// end ;
15668: GO 15650
15670: POP
15671: POP
// wait ( 0 0$1 ) ;
15672: LD_INT 35
15674: PPUSH
15675: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15679: LD_VAR 0 3
15683: PPUSH
15684: LD_EXP 118
15688: PPUSH
15689: CALL 13963 0 2
// for i := 1 to u1 do
15693: LD_ADDR_VAR 0 4
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_VAR 0 1
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15739
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 4
15720: ARRAY
15721: PPUSH
15722: LD_VAR 0 1
15726: PUSH
15727: LD_VAR 0 4
15731: ARRAY
15732: PPUSH
15733: CALL_OW 52
// end ;
15737: GO 15708
15739: POP
15740: POP
// for i in u1 do
15741: LD_ADDR_VAR 0 4
15745: PUSH
15746: LD_VAR 0 1
15750: PUSH
15751: FOR_IN
15752: IFFALSE 15771
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
15754: LD_VAR 0 4
15758: PPUSH
15759: LD_INT 2
15761: PPUSH
15762: LD_INT 0
15764: PPUSH
15765: CALL 23907 0 3
// end ;
15769: GO 15751
15771: POP
15772: POP
// wait ( 0 0$1 ) ;
15773: LD_INT 35
15775: PPUSH
15776: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
15780: LD_VAR 0 1
15784: PPUSH
15785: LD_EXP 109
15789: PUSH
15790: LD_EXP 114
15794: PPUSH
15795: CALL 13558 0 1
15799: ADD
15800: PUSH
15801: LD_EXP 111
15805: ADD
15806: PPUSH
15807: CALL 13963 0 2
// case difficulty of 1 :
15811: LD_OWVAR 67
15815: PUSH
15816: LD_INT 1
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15845
15824: POP
// begin u2 := CreateVC ( [ mg ] ) ;
15825: LD_ADDR_VAR 0 5
15829: PUSH
15830: LD_EXP 11
15834: PUSH
15835: EMPTY
15836: LIST
15837: PPUSH
15838: CALL 23577 0 1
15842: ST_TO_ADDR
// end ; 2 :
15843: GO 15910
15845: LD_INT 2
15847: DOUBLE
15848: EQUAL
15849: IFTRUE 15853
15851: GO 15874
15853: POP
// begin u2 := CreateVC ( [ hhg ] ) ;
15854: LD_ADDR_VAR 0 5
15858: PUSH
15859: LD_EXP 15
15863: PUSH
15864: EMPTY
15865: LIST
15866: PPUSH
15867: CALL 23577 0 1
15871: ST_TO_ADDR
// end ; 3 :
15872: GO 15910
15874: LD_INT 3
15876: DOUBLE
15877: EQUAL
15878: IFTRUE 15882
15880: GO 15909
15882: POP
// begin u2 := CreateVC ( [ mg , hhg ] ) ;
15883: LD_ADDR_VAR 0 5
15887: PUSH
15888: LD_EXP 11
15892: PUSH
15893: LD_EXP 15
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PPUSH
15902: CALL 23577 0 1
15906: ST_TO_ADDR
// end ; end ;
15907: GO 15910
15909: POP
// for i in u2 do
15910: LD_ADDR_VAR 0 4
15914: PUSH
15915: LD_VAR 0 5
15919: PUSH
15920: FOR_IN
15921: IFFALSE 15940
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
15923: LD_VAR 0 4
15927: PPUSH
15928: LD_INT 15
15930: PPUSH
15931: LD_INT 0
15933: PPUSH
15934: CALL 23907 0 3
// end ;
15938: GO 15920
15940: POP
15941: POP
// wait ( 0 0$1 ) ;
15942: LD_INT 35
15944: PPUSH
15945: CALL_OW 67
// AttackBase ( u2 , pathBR ^ pathUR ) ;
15949: LD_VAR 0 5
15953: PPUSH
15954: LD_EXP 110
15958: PUSH
15959: LD_EXP 112
15963: ADD
15964: PPUSH
15965: CALL 13963 0 2
// end ;
15969: PPOPN 6
15971: END
// every 18 18$0 trigger utocit do var u1 , p1 , i , u1a ;
15972: LD_EXP 2
15976: IFFALSE 16702
15978: GO 15980
15980: DISABLE
15981: LD_INT 0
15983: PPUSH
15984: PPUSH
15985: PPUSH
15986: PPUSH
// begin case difficulty of 1 :
15987: LD_OWVAR 67
15991: PUSH
15992: LD_INT 1
15994: DOUBLE
15995: EQUAL
15996: IFTRUE 16000
15998: GO 16055
16000: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
16001: LD_ADDR_VAR 0 1
16005: PUSH
16006: LD_EXP 12
16010: PUSH
16011: EMPTY
16012: LIST
16013: PPUSH
16014: CALL 23251 0 1
16018: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16019: LD_ADDR_VAR 0 4
16023: PUSH
16024: LD_EXP 12
16028: PUSH
16029: EMPTY
16030: LIST
16031: PPUSH
16032: CALL 23577 0 1
16036: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16037: LD_ADDR_VAR 0 2
16041: PUSH
16042: LD_INT 0
16044: PPUSH
16045: LD_INT 1
16047: PPUSH
16048: CALL 22798 0 2
16052: ST_TO_ADDR
// end ; 2 :
16053: GO 16188
16055: LD_INT 2
16057: DOUBLE
16058: EQUAL
16059: IFTRUE 16063
16061: GO 16118
16063: POP
// begin u1 := CreateVH ( [ hrl ] ) ;
16064: LD_ADDR_VAR 0 1
16068: PUSH
16069: LD_EXP 14
16073: PUSH
16074: EMPTY
16075: LIST
16076: PPUSH
16077: CALL 23251 0 1
16081: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16082: LD_ADDR_VAR 0 4
16086: PUSH
16087: LD_EXP 14
16091: PUSH
16092: EMPTY
16093: LIST
16094: PPUSH
16095: CALL 23577 0 1
16099: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16100: LD_ADDR_VAR 0 2
16104: PUSH
16105: LD_INT 0
16107: PPUSH
16108: LD_INT 1
16110: PPUSH
16111: CALL 22798 0 2
16115: ST_TO_ADDR
// end ; 3 :
16116: GO 16188
16118: LD_INT 3
16120: DOUBLE
16121: EQUAL
16122: IFTRUE 16126
16124: GO 16187
16126: POP
// begin u1 := CreateVH ( [ hrl , mrl ] ) ;
16127: LD_ADDR_VAR 0 1
16131: PUSH
16132: LD_EXP 14
16136: PUSH
16137: LD_EXP 12
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: PPUSH
16146: CALL 23251 0 1
16150: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16151: LD_ADDR_VAR 0 4
16155: PUSH
16156: LD_EXP 14
16160: PUSH
16161: EMPTY
16162: LIST
16163: PPUSH
16164: CALL 23577 0 1
16168: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16169: LD_ADDR_VAR 0 2
16173: PUSH
16174: LD_INT 1
16176: PPUSH
16177: LD_INT 1
16179: PPUSH
16180: CALL 22798 0 2
16184: ST_TO_ADDR
// end ; end ;
16185: GO 16188
16187: POP
// for i := 1 to u1 do
16188: LD_ADDR_VAR 0 3
16192: PUSH
16193: DOUBLE
16194: LD_INT 1
16196: DEC
16197: ST_TO_ADDR
16198: LD_VAR 0 1
16202: PUSH
16203: FOR_TO
16204: IFFALSE 16234
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16206: LD_VAR 0 2
16210: PUSH
16211: LD_VAR 0 3
16215: ARRAY
16216: PPUSH
16217: LD_VAR 0 1
16221: PUSH
16222: LD_VAR 0 3
16226: ARRAY
16227: PPUSH
16228: CALL_OW 52
// end ;
16232: GO 16203
16234: POP
16235: POP
// for i in u1 do
16236: LD_ADDR_VAR 0 3
16240: PUSH
16241: LD_VAR 0 1
16245: PUSH
16246: FOR_IN
16247: IFFALSE 16266
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16249: LD_VAR 0 3
16253: PPUSH
16254: LD_INT 3
16256: PPUSH
16257: LD_INT 0
16259: PPUSH
16260: CALL 23907 0 3
// end ;
16264: GO 16246
16266: POP
16267: POP
// for i in u1a do
16268: LD_ADDR_VAR 0 3
16272: PUSH
16273: LD_VAR 0 4
16277: PUSH
16278: FOR_IN
16279: IFFALSE 16298
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16281: LD_VAR 0 3
16285: PPUSH
16286: LD_INT 3
16288: PPUSH
16289: LD_INT 0
16291: PPUSH
16292: CALL 23907 0 3
// end ;
16296: GO 16278
16298: POP
16299: POP
// wait ( 0 0$1 ) ;
16300: LD_INT 35
16302: PPUSH
16303: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
16307: LD_VAR 0 1
16311: PPUSH
16312: LD_EXP 108
16316: PUSH
16317: LD_EXP 111
16321: ADD
16322: PPUSH
16323: CALL 13963 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16327: LD_VAR 0 4
16331: PPUSH
16332: LD_EXP 108
16336: PUSH
16337: LD_EXP 111
16341: ADD
16342: PPUSH
16343: CALL 13963 0 2
// case difficulty of 1 :
16347: LD_OWVAR 67
16351: PUSH
16352: LD_INT 1
16354: DOUBLE
16355: EQUAL
16356: IFTRUE 16360
16358: GO 16404
16360: POP
// begin u1 := CreateVH ( [ mg ] ) ;
16361: LD_ADDR_VAR 0 1
16365: PUSH
16366: LD_EXP 11
16370: PUSH
16371: EMPTY
16372: LIST
16373: PPUSH
16374: CALL 23251 0 1
16378: ST_TO_ADDR
// u1a := [ ] ;
16379: LD_ADDR_VAR 0 4
16383: PUSH
16384: EMPTY
16385: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16386: LD_ADDR_VAR 0 2
16390: PUSH
16391: LD_INT 1
16393: PPUSH
16394: LD_INT 0
16396: PPUSH
16397: CALL 22798 0 2
16401: ST_TO_ADDR
// end ; 2 :
16402: GO 16531
16404: LD_INT 2
16406: DOUBLE
16407: EQUAL
16408: IFTRUE 16412
16410: GO 16467
16412: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16413: LD_ADDR_VAR 0 1
16417: PUSH
16418: LD_EXP 15
16422: PUSH
16423: EMPTY
16424: LIST
16425: PPUSH
16426: CALL 23251 0 1
16430: ST_TO_ADDR
// u1a := CreateVC ( [ mg ] ) ;
16431: LD_ADDR_VAR 0 4
16435: PUSH
16436: LD_EXP 11
16440: PUSH
16441: EMPTY
16442: LIST
16443: PPUSH
16444: CALL 23577 0 1
16448: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16449: LD_ADDR_VAR 0 2
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 0
16459: PPUSH
16460: CALL 22798 0 2
16464: ST_TO_ADDR
// end ; 3 :
16465: GO 16531
16467: LD_INT 3
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 16530
16475: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16476: LD_ADDR_VAR 0 1
16480: PUSH
16481: LD_EXP 15
16485: PUSH
16486: EMPTY
16487: LIST
16488: PPUSH
16489: CALL 23251 0 1
16493: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16494: LD_ADDR_VAR 0 4
16498: PUSH
16499: LD_EXP 14
16503: PUSH
16504: EMPTY
16505: LIST
16506: PPUSH
16507: CALL 23577 0 1
16511: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16512: LD_ADDR_VAR 0 2
16516: PUSH
16517: LD_INT 0
16519: PPUSH
16520: LD_INT 1
16522: PPUSH
16523: CALL 22798 0 2
16527: ST_TO_ADDR
// end ; end ;
16528: GO 16531
16530: POP
// for i := 1 to u1 do
16531: LD_ADDR_VAR 0 3
16535: PUSH
16536: DOUBLE
16537: LD_INT 1
16539: DEC
16540: ST_TO_ADDR
16541: LD_VAR 0 1
16545: PUSH
16546: FOR_TO
16547: IFFALSE 16577
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16549: LD_VAR 0 2
16553: PUSH
16554: LD_VAR 0 3
16558: ARRAY
16559: PPUSH
16560: LD_VAR 0 1
16564: PUSH
16565: LD_VAR 0 3
16569: ARRAY
16570: PPUSH
16571: CALL_OW 52
// end ;
16575: GO 16546
16577: POP
16578: POP
// for i in u1 do
16579: LD_ADDR_VAR 0 3
16583: PUSH
16584: LD_VAR 0 1
16588: PUSH
16589: FOR_IN
16590: IFFALSE 16609
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16592: LD_VAR 0 3
16596: PPUSH
16597: LD_INT 15
16599: PPUSH
16600: LD_INT 0
16602: PPUSH
16603: CALL 23907 0 3
// end ;
16607: GO 16589
16609: POP
16610: POP
// for i in u1a do
16611: LD_ADDR_VAR 0 3
16615: PUSH
16616: LD_VAR 0 4
16620: PUSH
16621: FOR_IN
16622: IFFALSE 16641
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16624: LD_VAR 0 3
16628: PPUSH
16629: LD_INT 15
16631: PPUSH
16632: LD_INT 0
16634: PPUSH
16635: CALL 23907 0 3
// end ;
16639: GO 16621
16641: POP
16642: POP
// wait ( 0 0$1 ) ;
16643: LD_INT 35
16645: PPUSH
16646: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16650: LD_VAR 0 1
16654: PPUSH
16655: LD_EXP 110
16659: PUSH
16660: LD_EXP 116
16664: ADD
16665: PUSH
16666: LD_EXP 113
16670: ADD
16671: PPUSH
16672: CALL 13963 0 2
// AttackBase ( u1a , pathBR ^ pathMR ^ pathUT ) ;
16676: LD_VAR 0 4
16680: PPUSH
16681: LD_EXP 110
16685: PUSH
16686: LD_EXP 116
16690: ADD
16691: PUSH
16692: LD_EXP 113
16696: ADD
16697: PPUSH
16698: CALL 13963 0 2
// end ;
16702: PPOPN 4
16704: END
// every 22 22$0 trigger utocit do var u1 , p1 , i , u1a ;
16705: LD_EXP 2
16709: IFFALSE 17104
16711: GO 16713
16713: DISABLE
16714: LD_INT 0
16716: PPUSH
16717: PPUSH
16718: PPUSH
16719: PPUSH
// begin case difficulty of 1 :
16720: LD_OWVAR 67
16724: PUSH
16725: LD_INT 1
16727: DOUBLE
16728: EQUAL
16729: IFTRUE 16733
16731: GO 16794
16733: POP
// begin u1 := CreateVH ( [ mrl , mrl ] ) ;
16734: LD_ADDR_VAR 0 1
16738: PUSH
16739: LD_EXP 12
16743: PUSH
16744: LD_EXP 12
16748: PUSH
16749: EMPTY
16750: LIST
16751: LIST
16752: PPUSH
16753: CALL 23251 0 1
16757: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16758: LD_ADDR_VAR 0 4
16762: PUSH
16763: LD_EXP 12
16767: PUSH
16768: EMPTY
16769: LIST
16770: PPUSH
16771: CALL 23577 0 1
16775: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
16776: LD_ADDR_VAR 0 2
16780: PUSH
16781: LD_INT 0
16783: PPUSH
16784: LD_INT 2
16786: PPUSH
16787: CALL 22798 0 2
16791: ST_TO_ADDR
// end ; 2 :
16792: GO 16939
16794: LD_INT 2
16796: DOUBLE
16797: EQUAL
16798: IFTRUE 16802
16800: GO 16863
16802: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16803: LD_ADDR_VAR 0 1
16807: PUSH
16808: LD_EXP 14
16812: PUSH
16813: LD_EXP 14
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: PPUSH
16822: CALL 23251 0 1
16826: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16827: LD_ADDR_VAR 0 4
16831: PUSH
16832: LD_EXP 12
16836: PUSH
16837: EMPTY
16838: LIST
16839: PPUSH
16840: CALL 23577 0 1
16844: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
16845: LD_ADDR_VAR 0 2
16849: PUSH
16850: LD_INT 2
16852: PPUSH
16853: LD_INT 0
16855: PPUSH
16856: CALL 22798 0 2
16860: ST_TO_ADDR
// end ; 3 :
16861: GO 16939
16863: LD_INT 3
16865: DOUBLE
16866: EQUAL
16867: IFTRUE 16871
16869: GO 16938
16871: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16872: LD_ADDR_VAR 0 1
16876: PUSH
16877: LD_EXP 14
16881: PUSH
16882: LD_EXP 14
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: PPUSH
16891: CALL 23251 0 1
16895: ST_TO_ADDR
// u1a := CreateVC ( [ hrl , hrl ] ) ;
16896: LD_ADDR_VAR 0 4
16900: PUSH
16901: LD_EXP 14
16905: PUSH
16906: LD_EXP 14
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PPUSH
16915: CALL 23577 0 1
16919: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16920: LD_ADDR_VAR 0 2
16924: PUSH
16925: LD_INT 1
16927: PPUSH
16928: LD_INT 1
16930: PPUSH
16931: CALL 22798 0 2
16935: ST_TO_ADDR
// end ; end ;
16936: GO 16939
16938: POP
// for i := 1 to u1 do
16939: LD_ADDR_VAR 0 3
16943: PUSH
16944: DOUBLE
16945: LD_INT 1
16947: DEC
16948: ST_TO_ADDR
16949: LD_VAR 0 1
16953: PUSH
16954: FOR_TO
16955: IFFALSE 16985
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16957: LD_VAR 0 2
16961: PUSH
16962: LD_VAR 0 3
16966: ARRAY
16967: PPUSH
16968: LD_VAR 0 1
16972: PUSH
16973: LD_VAR 0 3
16977: ARRAY
16978: PPUSH
16979: CALL_OW 52
// end ;
16983: GO 16954
16985: POP
16986: POP
// for i in u1 do
16987: LD_ADDR_VAR 0 3
16991: PUSH
16992: LD_VAR 0 1
16996: PUSH
16997: FOR_IN
16998: IFFALSE 17017
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
17000: LD_VAR 0 3
17004: PPUSH
17005: LD_INT 15
17007: PPUSH
17008: LD_INT 0
17010: PPUSH
17011: CALL 23907 0 3
// end ;
17015: GO 16997
17017: POP
17018: POP
// for i in u1a do
17019: LD_ADDR_VAR 0 3
17023: PUSH
17024: LD_VAR 0 4
17028: PUSH
17029: FOR_IN
17030: IFFALSE 17049
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
17032: LD_VAR 0 3
17036: PPUSH
17037: LD_INT 15
17039: PPUSH
17040: LD_INT 0
17042: PPUSH
17043: CALL 23907 0 3
// end ;
17047: GO 17029
17049: POP
17050: POP
// wait ( 0 0$4 ) ;
17051: LD_INT 140
17053: PPUSH
17054: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
17058: LD_VAR 0 1
17062: PPUSH
17063: LD_EXP 110
17067: PUSH
17068: LD_EXP 116
17072: ADD
17073: PUSH
17074: LD_EXP 113
17078: ADD
17079: PPUSH
17080: CALL 13963 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
17084: LD_VAR 0 4
17088: PPUSH
17089: LD_EXP 108
17093: PUSH
17094: LD_EXP 111
17098: ADD
17099: PPUSH
17100: CALL 13963 0 2
// end ;
17104: PPOPN 4
17106: END
// every 37 37$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , b1 ;
17107: LD_EXP 2
17111: IFFALSE 17771
17113: GO 17115
17115: DISABLE
17116: LD_INT 0
17118: PPUSH
17119: PPUSH
17120: PPUSH
17121: PPUSH
17122: PPUSH
17123: PPUSH
17124: PPUSH
17125: PPUSH
// begin case difficulty of 1 :
17126: LD_OWVAR 67
17130: PUSH
17131: LD_INT 1
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17139
17137: GO 17182
17139: POP
// begin u1 := CreateVC ( [ mg ] ) ;
17140: LD_ADDR_VAR 0 1
17144: PUSH
17145: LD_EXP 11
17149: PUSH
17150: EMPTY
17151: LIST
17152: PPUSH
17153: CALL 23577 0 1
17157: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
17158: LD_ADDR_VAR 0 8
17162: PUSH
17163: LD_INT 2
17165: PPUSH
17166: CALL 23003 0 1
17170: PUSH
17171: LD_INT 1
17173: PPUSH
17174: CALL 23127 0 1
17178: ADD
17179: ST_TO_ADDR
// end ; 2 :
17180: GO 17291
17182: LD_INT 2
17184: DOUBLE
17185: EQUAL
17186: IFTRUE 17190
17188: GO 17233
17190: POP
// begin u1 := CreateVC ( [ hhg ] ) ;
17191: LD_ADDR_VAR 0 1
17195: PUSH
17196: LD_EXP 15
17200: PUSH
17201: EMPTY
17202: LIST
17203: PPUSH
17204: CALL 23577 0 1
17208: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 2 ) ;
17209: LD_ADDR_VAR 0 8
17213: PUSH
17214: LD_INT 2
17216: PPUSH
17217: CALL 23003 0 1
17221: PUSH
17222: LD_INT 2
17224: PPUSH
17225: CALL 23127 0 1
17229: ADD
17230: ST_TO_ADDR
// end ; 3 :
17231: GO 17291
17233: LD_INT 3
17235: DOUBLE
17236: EQUAL
17237: IFTRUE 17241
17239: GO 17290
17241: POP
// begin u1 := CreateVC ( [ hhg , hgg ] ) ;
17242: LD_ADDR_VAR 0 1
17246: PUSH
17247: LD_EXP 15
17251: PUSH
17252: LD_EXP 13
17256: PUSH
17257: EMPTY
17258: LIST
17259: LIST
17260: PPUSH
17261: CALL 23577 0 1
17265: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 3 ) ;
17266: LD_ADDR_VAR 0 8
17270: PUSH
17271: LD_INT 3
17273: PPUSH
17274: CALL 23003 0 1
17278: PUSH
17279: LD_INT 3
17281: PPUSH
17282: CALL 23127 0 1
17286: ADD
17287: ST_TO_ADDR
// end ; end ;
17288: GO 17291
17290: POP
// for i in u1 do
17291: LD_ADDR_VAR 0 3
17295: PUSH
17296: LD_VAR 0 1
17300: PUSH
17301: FOR_IN
17302: IFFALSE 17321
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17304: LD_VAR 0 3
17308: PPUSH
17309: LD_INT 14
17311: PPUSH
17312: LD_INT 0
17314: PPUSH
17315: CALL 23907 0 3
// end ;
17319: GO 17301
17321: POP
17322: POP
// wait ( 0 0$1 ) ;
17323: LD_INT 35
17325: PPUSH
17326: CALL_OW 67
// AttackBase ( u1 , pathUT ^ pathUR ) ;
17330: LD_VAR 0 1
17334: PPUSH
17335: LD_EXP 113
17339: PUSH
17340: LD_EXP 112
17344: ADD
17345: PPUSH
17346: CALL 13963 0 2
// AttackBase ( b1 , pathUT ^ pathUR ) ;
17350: LD_VAR 0 8
17354: PPUSH
17355: LD_EXP 113
17359: PUSH
17360: LD_EXP 112
17364: ADD
17365: PPUSH
17366: CALL 13963 0 2
// case difficulty of 1 :
17370: LD_OWVAR 67
17374: PUSH
17375: LD_INT 1
17377: DOUBLE
17378: EQUAL
17379: IFTRUE 17383
17381: GO 17420
17383: POP
// begin u2 := CreateVH ( [ mgg ] ) ;
17384: LD_ADDR_VAR 0 4
17388: PUSH
17389: LD_EXP 10
17393: PUSH
17394: EMPTY
17395: LIST
17396: PPUSH
17397: CALL 23251 0 1
17401: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
17402: LD_ADDR_VAR 0 5
17406: PUSH
17407: LD_INT 1
17409: PPUSH
17410: LD_INT 0
17412: PPUSH
17413: CALL 22798 0 2
17417: ST_TO_ADDR
// end ; 2 :
17418: GO 17523
17420: LD_INT 2
17422: DOUBLE
17423: EQUAL
17424: IFTRUE 17428
17426: GO 17471
17428: POP
// begin u2 := CreateVH ( [ mgg , mg ] ) ;
17429: LD_ADDR_VAR 0 4
17433: PUSH
17434: LD_EXP 10
17438: PUSH
17439: LD_EXP 11
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PPUSH
17448: CALL 23251 0 1
17452: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17453: LD_ADDR_VAR 0 5
17457: PUSH
17458: LD_INT 0
17460: PPUSH
17461: LD_INT 2
17463: PPUSH
17464: CALL 22798 0 2
17468: ST_TO_ADDR
// end ; 3 :
17469: GO 17523
17471: LD_INT 3
17473: DOUBLE
17474: EQUAL
17475: IFTRUE 17479
17477: GO 17522
17479: POP
// begin u2 := CreateVH ( [ mgg , hhg ] ) ;
17480: LD_ADDR_VAR 0 4
17484: PUSH
17485: LD_EXP 10
17489: PUSH
17490: LD_EXP 15
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL 23251 0 1
17503: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17504: LD_ADDR_VAR 0 5
17508: PUSH
17509: LD_INT 0
17511: PPUSH
17512: LD_INT 2
17514: PPUSH
17515: CALL 22798 0 2
17519: ST_TO_ADDR
// end ; end ;
17520: GO 17523
17522: POP
// for i := 1 to u2 do
17523: LD_ADDR_VAR 0 3
17527: PUSH
17528: DOUBLE
17529: LD_INT 1
17531: DEC
17532: ST_TO_ADDR
17533: LD_VAR 0 4
17537: PUSH
17538: FOR_TO
17539: IFFALSE 17569
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
17541: LD_VAR 0 5
17545: PUSH
17546: LD_VAR 0 3
17550: ARRAY
17551: PPUSH
17552: LD_VAR 0 4
17556: PUSH
17557: LD_VAR 0 3
17561: ARRAY
17562: PPUSH
17563: CALL_OW 52
// end ;
17567: GO 17538
17569: POP
17570: POP
// for i in u2 do
17571: LD_ADDR_VAR 0 3
17575: PUSH
17576: LD_VAR 0 4
17580: PUSH
17581: FOR_IN
17582: IFFALSE 17601
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
17584: LD_VAR 0 3
17588: PPUSH
17589: LD_INT 3
17591: PPUSH
17592: LD_INT 0
17594: PPUSH
17595: CALL 23907 0 3
// end ;
17599: GO 17581
17601: POP
17602: POP
// wait ( 0 0$1 ) ;
17603: LD_INT 35
17605: PPUSH
17606: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
17610: LD_VAR 0 4
17614: PPUSH
17615: LD_EXP 108
17619: PUSH
17620: LD_EXP 111
17624: ADD
17625: PPUSH
17626: CALL 13963 0 2
// case difficulty of 1 :
17630: LD_OWVAR 67
17634: PUSH
17635: LD_INT 1
17637: DOUBLE
17638: EQUAL
17639: IFTRUE 17643
17641: GO 17659
17643: POP
// begin u3 := CreateS ( 1 ) ;
17644: LD_ADDR_VAR 0 6
17648: PUSH
17649: LD_INT 1
17651: PPUSH
17652: CALL 23127 0 1
17656: ST_TO_ADDR
// ; end ; 2 :
17657: GO 17718
17659: LD_INT 2
17661: DOUBLE
17662: EQUAL
17663: IFTRUE 17667
17665: GO 17688
17667: POP
// begin u3 := CreateVC ( [ mgg ] ) ;
17668: LD_ADDR_VAR 0 6
17672: PUSH
17673: LD_EXP 10
17677: PUSH
17678: EMPTY
17679: LIST
17680: PPUSH
17681: CALL 23577 0 1
17685: ST_TO_ADDR
// end ; 3 :
17686: GO 17718
17688: LD_INT 3
17690: DOUBLE
17691: EQUAL
17692: IFTRUE 17696
17694: GO 17717
17696: POP
// begin u3 := CreateVC ( [ hgg ] ) ;
17697: LD_ADDR_VAR 0 6
17701: PUSH
17702: LD_EXP 13
17706: PUSH
17707: EMPTY
17708: LIST
17709: PPUSH
17710: CALL 23577 0 1
17714: ST_TO_ADDR
// end ; end ;
17715: GO 17718
17717: POP
// for i in u3 do
17718: LD_ADDR_VAR 0 3
17722: PUSH
17723: LD_VAR 0 6
17727: PUSH
17728: FOR_IN
17729: IFFALSE 17748
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17731: LD_VAR 0 3
17735: PPUSH
17736: LD_INT 14
17738: PPUSH
17739: LD_INT 0
17741: PPUSH
17742: CALL 23907 0 3
// end ;
17746: GO 17728
17748: POP
17749: POP
// wait ( 0 0$1 ) ;
17750: LD_INT 35
17752: PPUSH
17753: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
17757: LD_VAR 0 6
17761: PPUSH
17762: LD_EXP 117
17766: PPUSH
17767: CALL 13963 0 2
// end ;
17771: PPOPN 8
17773: END
// every 38 38$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
17774: LD_EXP 2
17778: IFFALSE 18239
17780: GO 17782
17782: DISABLE
17783: LD_INT 0
17785: PPUSH
17786: PPUSH
17787: PPUSH
17788: PPUSH
17789: PPUSH
17790: PPUSH
17791: PPUSH
// begin case difficulty of 1 :
17792: LD_OWVAR 67
17796: PUSH
17797: LD_INT 1
17799: DOUBLE
17800: EQUAL
17801: IFTRUE 17805
17803: GO 17842
17805: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: LD_EXP 15
17815: PUSH
17816: EMPTY
17817: LIST
17818: PPUSH
17819: CALL 23251 0 1
17823: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
17824: LD_ADDR_VAR 0 2
17828: PUSH
17829: LD_INT 1
17831: PPUSH
17832: LD_INT 0
17834: PPUSH
17835: CALL 22798 0 2
17839: ST_TO_ADDR
// end ; 2 :
17840: GO 17945
17842: LD_INT 2
17844: DOUBLE
17845: EQUAL
17846: IFTRUE 17850
17848: GO 17893
17850: POP
// begin u1 := CreateVH ( [ mrl , hhg ] ) ;
17851: LD_ADDR_VAR 0 1
17855: PUSH
17856: LD_EXP 12
17860: PUSH
17861: LD_EXP 15
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PPUSH
17870: CALL 23251 0 1
17874: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
17875: LD_ADDR_VAR 0 2
17879: PUSH
17880: LD_INT 1
17882: PPUSH
17883: LD_INT 1
17885: PPUSH
17886: CALL 22798 0 2
17890: ST_TO_ADDR
// end ; 3 :
17891: GO 17945
17893: LD_INT 3
17895: DOUBLE
17896: EQUAL
17897: IFTRUE 17901
17899: GO 17944
17901: POP
// begin u1 := CreateVH ( [ hrl , hhg ] ) ;
17902: LD_ADDR_VAR 0 1
17906: PUSH
17907: LD_EXP 14
17911: PUSH
17912: LD_EXP 15
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PPUSH
17921: CALL 23251 0 1
17925: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
17926: LD_ADDR_VAR 0 2
17930: PUSH
17931: LD_INT 0
17933: PPUSH
17934: LD_INT 2
17936: PPUSH
17937: CALL 22798 0 2
17941: ST_TO_ADDR
// end ; end ;
17942: GO 17945
17944: POP
// for i := 1 to u1 do
17945: LD_ADDR_VAR 0 3
17949: PUSH
17950: DOUBLE
17951: LD_INT 1
17953: DEC
17954: ST_TO_ADDR
17955: LD_VAR 0 1
17959: PUSH
17960: FOR_TO
17961: IFFALSE 17991
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
17963: LD_VAR 0 2
17967: PUSH
17968: LD_VAR 0 3
17972: ARRAY
17973: PPUSH
17974: LD_VAR 0 1
17978: PUSH
17979: LD_VAR 0 3
17983: ARRAY
17984: PPUSH
17985: CALL_OW 52
// end ;
17989: GO 17960
17991: POP
17992: POP
// for i in u1 do
17993: LD_ADDR_VAR 0 3
17997: PUSH
17998: LD_VAR 0 1
18002: PUSH
18003: FOR_IN
18004: IFFALSE 18023
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
18006: LD_VAR 0 3
18010: PPUSH
18011: LD_INT 2
18013: PPUSH
18014: LD_INT 0
18016: PPUSH
18017: CALL 23907 0 3
// end ;
18021: GO 18003
18023: POP
18024: POP
// wait ( 0 0$4 ) ;
18025: LD_INT 140
18027: PPUSH
18028: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
18032: LD_VAR 0 1
18036: PPUSH
18037: LD_EXP 109
18041: PUSH
18042: LD_EXP 114
18046: PPUSH
18047: CALL 13558 0 1
18051: ADD
18052: PUSH
18053: LD_EXP 111
18057: ADD
18058: PPUSH
18059: CALL 13963 0 2
// case difficulty of 1 :
18063: LD_OWVAR 67
18067: PUSH
18068: LD_INT 1
18070: DOUBLE
18071: EQUAL
18072: IFTRUE 18076
18074: GO 18103
18076: POP
// begin u2 := CreateVC ( [ mgg , mrl ] ) ;
18077: LD_ADDR_VAR 0 4
18081: PUSH
18082: LD_EXP 10
18086: PUSH
18087: LD_EXP 12
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: PPUSH
18096: CALL 23577 0 1
18100: ST_TO_ADDR
// end ; 2 :
18101: GO 18174
18103: LD_INT 2
18105: DOUBLE
18106: EQUAL
18107: IFTRUE 18111
18109: GO 18138
18111: POP
// begin u2 := CreateVC ( [ hgg , mrl ] ) ;
18112: LD_ADDR_VAR 0 4
18116: PUSH
18117: LD_EXP 13
18121: PUSH
18122: LD_EXP 12
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: PPUSH
18131: CALL 23577 0 1
18135: ST_TO_ADDR
// end ; 3 :
18136: GO 18174
18138: LD_INT 3
18140: DOUBLE
18141: EQUAL
18142: IFTRUE 18146
18144: GO 18173
18146: POP
// begin u2 := CreateVC ( [ hgg , hrl ] ) ;
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: LD_EXP 13
18156: PUSH
18157: LD_EXP 14
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: PPUSH
18166: CALL 23577 0 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// for i in u2 do
18174: LD_ADDR_VAR 0 3
18178: PUSH
18179: LD_VAR 0 4
18183: PUSH
18184: FOR_IN
18185: IFFALSE 18204
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
18187: LD_VAR 0 3
18191: PPUSH
18192: LD_INT 2
18194: PPUSH
18195: LD_INT 0
18197: PPUSH
18198: CALL 23907 0 3
// end ;
18202: GO 18184
18204: POP
18205: POP
// wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// AttackBase ( u2 , pathBM ^ pathMM ^ pathUR ) ;
18213: LD_VAR 0 4
18217: PPUSH
18218: LD_EXP 109
18222: PUSH
18223: LD_EXP 115
18227: ADD
18228: PUSH
18229: LD_EXP 112
18233: ADD
18234: PPUSH
18235: CALL 13963 0 2
// end ;
18239: PPOPN 7
18241: END
// every 41 41$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
18242: LD_EXP 2
18246: IFFALSE 18442
18248: GO 18250
18250: DISABLE
18251: LD_INT 0
18253: PPUSH
18254: PPUSH
18255: PPUSH
18256: PPUSH
18257: PPUSH
18258: PPUSH
18259: PPUSH
// begin case difficulty of 1 :
18260: LD_OWVAR 67
18264: PUSH
18265: LD_INT 1
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18300
18273: POP
// begin u1 := CreateVC ( [ hrl , mgg ] ) ;
18274: LD_ADDR_VAR 0 1
18278: PUSH
18279: LD_EXP 14
18283: PUSH
18284: LD_EXP 10
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL 23577 0 1
18297: ST_TO_ADDR
// end ; 2 :
18298: GO 18389
18300: LD_INT 2
18302: DOUBLE
18303: EQUAL
18304: IFTRUE 18308
18306: GO 18341
18308: POP
// begin u1 := CreateVC ( [ hrl , hrl , mgg ] ) ;
18309: LD_ADDR_VAR 0 1
18313: PUSH
18314: LD_EXP 14
18318: PUSH
18319: LD_EXP 14
18323: PUSH
18324: LD_EXP 10
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: LIST
18333: PPUSH
18334: CALL 23577 0 1
18338: ST_TO_ADDR
// end ; 3 :
18339: GO 18389
18341: LD_INT 3
18343: DOUBLE
18344: EQUAL
18345: IFTRUE 18349
18347: GO 18388
18349: POP
// begin u1 := CreateVC ( [ hrl , hrl , hhg , mgg ] ) ;
18350: LD_ADDR_VAR 0 1
18354: PUSH
18355: LD_EXP 14
18359: PUSH
18360: LD_EXP 14
18364: PUSH
18365: LD_EXP 15
18369: PUSH
18370: LD_EXP 10
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL 23577 0 1
18385: ST_TO_ADDR
// end ; end ;
18386: GO 18389
18388: POP
// for i in u1 do
18389: LD_ADDR_VAR 0 3
18393: PUSH
18394: LD_VAR 0 1
18398: PUSH
18399: FOR_IN
18400: IFFALSE 18419
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18402: LD_VAR 0 3
18406: PPUSH
18407: LD_INT 14
18409: PPUSH
18410: LD_INT 0
18412: PPUSH
18413: CALL 23907 0 3
// end ;
18417: GO 18399
18419: POP
18420: POP
// wait ( 0 0$4 ) ;
18421: LD_INT 140
18423: PPUSH
18424: CALL_OW 67
// AttackBase ( u1 , pathT ) ;
18428: LD_VAR 0 1
18432: PPUSH
18433: LD_EXP 117
18437: PPUSH
18438: CALL 13963 0 2
// end ;
18442: PPOPN 7
18444: END
// every 44 44$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , u2a ;
18445: LD_EXP 2
18449: IFFALSE 19286
18451: GO 18453
18453: DISABLE
18454: LD_INT 0
18456: PPUSH
18457: PPUSH
18458: PPUSH
18459: PPUSH
18460: PPUSH
18461: PPUSH
18462: PPUSH
18463: PPUSH
// begin case difficulty of 1 :
18464: LD_OWVAR 67
18468: PUSH
18469: LD_INT 1
18471: DOUBLE
18472: EQUAL
18473: IFTRUE 18477
18475: GO 18526
18477: POP
// begin u1 := CreateVH ( [ hrl , mg , mrl ] ) ;
18478: LD_ADDR_VAR 0 1
18482: PUSH
18483: LD_EXP 14
18487: PUSH
18488: LD_EXP 11
18492: PUSH
18493: LD_EXP 12
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: LIST
18502: PPUSH
18503: CALL 23251 0 1
18507: ST_TO_ADDR
// p1 := CreateH ( 2 , 1 ) ;
18508: LD_ADDR_VAR 0 2
18512: PUSH
18513: LD_INT 2
18515: PPUSH
18516: LD_INT 1
18518: PPUSH
18519: CALL 22798 0 2
18523: ST_TO_ADDR
// end ; 2 :
18524: GO 18653
18526: LD_INT 2
18528: DOUBLE
18529: EQUAL
18530: IFTRUE 18534
18532: GO 18589
18534: POP
// begin u1 := CreateVH ( [ hrl , hhg , mrl , mgg ] ) ;
18535: LD_ADDR_VAR 0 1
18539: PUSH
18540: LD_EXP 14
18544: PUSH
18545: LD_EXP 15
18549: PUSH
18550: LD_EXP 12
18554: PUSH
18555: LD_EXP 10
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: LIST
18564: LIST
18565: PPUSH
18566: CALL 23251 0 1
18570: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18571: LD_ADDR_VAR 0 2
18575: PUSH
18576: LD_INT 3
18578: PPUSH
18579: LD_INT 1
18581: PPUSH
18582: CALL 22798 0 2
18586: ST_TO_ADDR
// end ; 3 :
18587: GO 18653
18589: LD_INT 3
18591: DOUBLE
18592: EQUAL
18593: IFTRUE 18597
18595: GO 18652
18597: POP
// begin u1 := CreateVH ( [ hrl , hhg , hrl , hgg ] ) ;
18598: LD_ADDR_VAR 0 1
18602: PUSH
18603: LD_EXP 14
18607: PUSH
18608: LD_EXP 15
18612: PUSH
18613: LD_EXP 14
18617: PUSH
18618: LD_EXP 13
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: PPUSH
18629: CALL 23251 0 1
18633: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18634: LD_ADDR_VAR 0 2
18638: PUSH
18639: LD_INT 3
18641: PPUSH
18642: LD_INT 1
18644: PPUSH
18645: CALL 22798 0 2
18649: ST_TO_ADDR
// end ; end ;
18650: GO 18653
18652: POP
// for i := 1 to u1 do
18653: LD_ADDR_VAR 0 3
18657: PUSH
18658: DOUBLE
18659: LD_INT 1
18661: DEC
18662: ST_TO_ADDR
18663: LD_VAR 0 1
18667: PUSH
18668: FOR_TO
18669: IFFALSE 18699
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
18671: LD_VAR 0 2
18675: PUSH
18676: LD_VAR 0 3
18680: ARRAY
18681: PPUSH
18682: LD_VAR 0 1
18686: PUSH
18687: LD_VAR 0 3
18691: ARRAY
18692: PPUSH
18693: CALL_OW 52
// end ;
18697: GO 18668
18699: POP
18700: POP
// for i in u1 do
18701: LD_ADDR_VAR 0 3
18705: PUSH
18706: LD_VAR 0 1
18710: PUSH
18711: FOR_IN
18712: IFFALSE 18731
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18714: LD_VAR 0 3
18718: PPUSH
18719: LD_INT 14
18721: PPUSH
18722: LD_INT 0
18724: PPUSH
18725: CALL 23907 0 3
// end ;
18729: GO 18711
18731: POP
18732: POP
// wait ( 0 0$1 ) ;
18733: LD_INT 35
18735: PPUSH
18736: CALL_OW 67
// AttackBase ( u1 , pathUT ) ;
18740: LD_VAR 0 1
18744: PPUSH
18745: LD_EXP 113
18749: PPUSH
18750: CALL 13963 0 2
// case difficulty of 1 :
18754: LD_OWVAR 67
18758: PUSH
18759: LD_INT 1
18761: DOUBLE
18762: EQUAL
18763: IFTRUE 18767
18765: GO 18828
18767: POP
// begin u2 := CreateVH ( [ hgg ] ) ;
18768: LD_ADDR_VAR 0 4
18772: PUSH
18773: LD_EXP 13
18777: PUSH
18778: EMPTY
18779: LIST
18780: PPUSH
18781: CALL 23251 0 1
18785: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18786: LD_ADDR_VAR 0 8
18790: PUSH
18791: LD_EXP 11
18795: PUSH
18796: LD_EXP 15
18800: PUSH
18801: EMPTY
18802: LIST
18803: LIST
18804: PPUSH
18805: CALL 23577 0 1
18809: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
18810: LD_ADDR_VAR 0 5
18814: PUSH
18815: LD_INT 1
18817: PPUSH
18818: LD_INT 0
18820: PPUSH
18821: CALL 22798 0 2
18825: ST_TO_ADDR
// end ; 2 :
18826: GO 18979
18828: LD_INT 2
18830: DOUBLE
18831: EQUAL
18832: IFTRUE 18836
18834: GO 18903
18836: POP
// begin u2 := CreateVH ( [ hgg , mrl ] ) ;
18837: LD_ADDR_VAR 0 4
18841: PUSH
18842: LD_EXP 13
18846: PUSH
18847: LD_EXP 12
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: PPUSH
18856: CALL 23251 0 1
18860: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18861: LD_ADDR_VAR 0 8
18865: PUSH
18866: LD_EXP 11
18870: PUSH
18871: LD_EXP 15
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: PPUSH
18880: CALL 23577 0 1
18884: ST_TO_ADDR
// p2 := CreateH ( 1 , 1 ) ;
18885: LD_ADDR_VAR 0 5
18889: PUSH
18890: LD_INT 1
18892: PPUSH
18893: LD_INT 1
18895: PPUSH
18896: CALL 22798 0 2
18900: ST_TO_ADDR
// end ; 3 :
18901: GO 18979
18903: LD_INT 3
18905: DOUBLE
18906: EQUAL
18907: IFTRUE 18911
18909: GO 18978
18911: POP
// begin u2 := CreateVH ( [ hgg , hrl ] ) ;
18912: LD_ADDR_VAR 0 4
18916: PUSH
18917: LD_EXP 13
18921: PUSH
18922: LD_EXP 14
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PPUSH
18931: CALL 23251 0 1
18935: ST_TO_ADDR
// u2a := CreateVC ( [ hhg , hhg ] ) ;
18936: LD_ADDR_VAR 0 8
18940: PUSH
18941: LD_EXP 15
18945: PUSH
18946: LD_EXP 15
18950: PUSH
18951: EMPTY
18952: LIST
18953: LIST
18954: PPUSH
18955: CALL 23577 0 1
18959: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
18960: LD_ADDR_VAR 0 5
18964: PUSH
18965: LD_INT 0
18967: PPUSH
18968: LD_INT 2
18970: PPUSH
18971: CALL 22798 0 2
18975: ST_TO_ADDR
// end ; end ;
18976: GO 18979
18978: POP
// for i := 1 to u2 do
18979: LD_ADDR_VAR 0 3
18983: PUSH
18984: DOUBLE
18985: LD_INT 1
18987: DEC
18988: ST_TO_ADDR
18989: LD_VAR 0 4
18993: PUSH
18994: FOR_TO
18995: IFFALSE 19025
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
18997: LD_VAR 0 5
19001: PUSH
19002: LD_VAR 0 3
19006: ARRAY
19007: PPUSH
19008: LD_VAR 0 4
19012: PUSH
19013: LD_VAR 0 3
19017: ARRAY
19018: PPUSH
19019: CALL_OW 52
// end ;
19023: GO 18994
19025: POP
19026: POP
// for i in u2 ^ u2a do
19027: LD_ADDR_VAR 0 3
19031: PUSH
19032: LD_VAR 0 4
19036: PUSH
19037: LD_VAR 0 8
19041: ADD
19042: PUSH
19043: FOR_IN
19044: IFFALSE 19063
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
19046: LD_VAR 0 3
19050: PPUSH
19051: LD_INT 3
19053: PPUSH
19054: LD_INT 0
19056: PPUSH
19057: CALL 23907 0 3
// end ;
19061: GO 19043
19063: POP
19064: POP
// wait ( 0 0$1 ) ;
19065: LD_INT 35
19067: PPUSH
19068: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
19072: LD_VAR 0 4
19076: PPUSH
19077: LD_EXP 108
19081: PUSH
19082: LD_EXP 111
19086: ADD
19087: PPUSH
19088: CALL 13963 0 2
// case difficulty of 1 :
19092: LD_OWVAR 67
19096: PUSH
19097: LD_INT 1
19099: DOUBLE
19100: EQUAL
19101: IFTRUE 19105
19103: GO 19138
19105: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl ] ) ;
19106: LD_ADDR_VAR 0 6
19110: PUSH
19111: LD_EXP 10
19115: PUSH
19116: LD_EXP 11
19120: PUSH
19121: LD_EXP 12
19125: PUSH
19126: EMPTY
19127: LIST
19128: LIST
19129: LIST
19130: PPUSH
19131: CALL 23577 0 1
19135: ST_TO_ADDR
// end ; 2 :
19136: GO 19233
19138: LD_INT 2
19140: DOUBLE
19141: EQUAL
19142: IFTRUE 19146
19144: GO 19185
19146: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl , hgg ] ) ;
19147: LD_ADDR_VAR 0 6
19151: PUSH
19152: LD_EXP 10
19156: PUSH
19157: LD_EXP 11
19161: PUSH
19162: LD_EXP 12
19166: PUSH
19167: LD_EXP 13
19171: PUSH
19172: EMPTY
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: PPUSH
19178: CALL 23577 0 1
19182: ST_TO_ADDR
// end ; 3 :
19183: GO 19233
19185: LD_INT 3
19187: DOUBLE
19188: EQUAL
19189: IFTRUE 19193
19191: GO 19232
19193: POP
// begin u3 := CreateVC ( [ mgg , mg , hrl , hgg ] ) ;
19194: LD_ADDR_VAR 0 6
19198: PUSH
19199: LD_EXP 10
19203: PUSH
19204: LD_EXP 11
19208: PUSH
19209: LD_EXP 14
19213: PUSH
19214: LD_EXP 13
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: LIST
19223: LIST
19224: PPUSH
19225: CALL 23577 0 1
19229: ST_TO_ADDR
// end ; end ;
19230: GO 19233
19232: POP
// for i in u3 do
19233: LD_ADDR_VAR 0 3
19237: PUSH
19238: LD_VAR 0 6
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19263
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19246: LD_VAR 0 3
19250: PPUSH
19251: LD_INT 14
19253: PPUSH
19254: LD_INT 0
19256: PPUSH
19257: CALL 23907 0 3
// end ;
19261: GO 19243
19263: POP
19264: POP
// wait ( 0 0$1 ) ;
19265: LD_INT 35
19267: PPUSH
19268: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
19272: LD_VAR 0 6
19276: PPUSH
19277: LD_EXP 117
19281: PPUSH
19282: CALL 13963 0 2
// end ;
19286: PPOPN 8
19288: END
// every 0 0$5 trigger last_attack and timer < rusaci_pred_koncem do var u1 , p1 , i , u2 , p2 , u3 , p3 , u4 , p4 ;
19289: LD_EXP 3
19293: PUSH
19294: LD_EXP 62
19298: PUSH
19299: LD_EXP 6
19303: LESS
19304: AND
19305: IFFALSE 20888
19307: GO 19309
19309: DISABLE
19310: LD_INT 0
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
// begin lev := [ 8 , 8 , 8 ] ;
19321: LD_ADDR_EXP 5
19325: PUSH
19326: LD_INT 8
19328: PUSH
19329: LD_INT 8
19331: PUSH
19332: LD_INT 8
19334: PUSH
19335: EMPTY
19336: LIST
19337: LIST
19338: LIST
19339: ST_TO_ADDR
// SetTech ( tech_Comp1 , russians , state_researched ) ;
19340: LD_INT 57
19342: PPUSH
19343: LD_EXP 49
19347: PPUSH
19348: LD_INT 2
19350: PPUSH
19351: CALL_OW 322
// SetTech ( tech_Comp2 , russians , state_researched ) ;
19355: LD_INT 58
19357: PPUSH
19358: LD_EXP 49
19362: PPUSH
19363: LD_INT 2
19365: PPUSH
19366: CALL_OW 322
// SetTech ( tech_Comp3 , russians , state_researched ) ;
19370: LD_INT 59
19372: PPUSH
19373: LD_EXP 49
19377: PPUSH
19378: LD_INT 2
19380: PPUSH
19381: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
19385: LD_INT 51
19387: PPUSH
19388: LD_EXP 49
19392: PPUSH
19393: LD_INT 2
19395: PPUSH
19396: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
19400: LD_INT 52
19402: PPUSH
19403: LD_EXP 49
19407: PPUSH
19408: LD_INT 2
19410: PPUSH
19411: CALL_OW 322
// SetTech ( tech_Weap3 , russians , state_researched ) ;
19415: LD_INT 53
19417: PPUSH
19418: LD_EXP 49
19422: PPUSH
19423: LD_INT 2
19425: PPUSH
19426: CALL_OW 322
// case difficulty of 1 :
19430: LD_OWVAR 67
19434: PUSH
19435: LD_INT 1
19437: DOUBLE
19438: EQUAL
19439: IFTRUE 19443
19441: GO 19482
19443: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19444: LD_ADDR_VAR 0 1
19448: PUSH
19449: LD_EXP 14
19453: PUSH
19454: LD_EXP 14
19458: PUSH
19459: LD_EXP 14
19463: PUSH
19464: LD_EXP 14
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: LIST
19473: LIST
19474: PPUSH
19475: CALL 23577 0 1
19479: ST_TO_ADDR
// end ; 2 :
19480: GO 19577
19482: LD_INT 2
19484: DOUBLE
19485: EQUAL
19486: IFTRUE 19490
19488: GO 19529
19490: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19491: LD_ADDR_VAR 0 1
19495: PUSH
19496: LD_EXP 14
19500: PUSH
19501: LD_EXP 14
19505: PUSH
19506: LD_EXP 14
19510: PUSH
19511: LD_EXP 14
19515: PUSH
19516: EMPTY
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: PPUSH
19522: CALL 23577 0 1
19526: ST_TO_ADDR
// end ; 3 :
19527: GO 19577
19529: LD_INT 3
19531: DOUBLE
19532: EQUAL
19533: IFTRUE 19537
19535: GO 19576
19537: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19538: LD_ADDR_VAR 0 1
19542: PUSH
19543: LD_EXP 14
19547: PUSH
19548: LD_EXP 14
19552: PUSH
19553: LD_EXP 14
19557: PUSH
19558: LD_EXP 14
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: LIST
19567: LIST
19568: PPUSH
19569: CALL 23577 0 1
19573: ST_TO_ADDR
// end ; end ;
19574: GO 19577
19576: POP
// for i in u1 do
19577: LD_ADDR_VAR 0 3
19581: PUSH
19582: LD_VAR 0 1
19586: PUSH
19587: FOR_IN
19588: IFFALSE 19607
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19590: LD_VAR 0 3
19594: PPUSH
19595: LD_INT 14
19597: PPUSH
19598: LD_INT 0
19600: PPUSH
19601: CALL 23907 0 3
// end ;
19605: GO 19587
19607: POP
19608: POP
// wait ( 0 0$1 ) ;
19609: LD_INT 35
19611: PPUSH
19612: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
19616: LD_VAR 0 1
19620: PPUSH
19621: LD_EXP 108
19625: PUSH
19626: LD_EXP 111
19630: ADD
19631: PPUSH
19632: CALL 13963 0 2
// case difficulty of 1 :
19636: LD_OWVAR 67
19640: PUSH
19641: LD_INT 1
19643: DOUBLE
19644: EQUAL
19645: IFTRUE 19649
19647: GO 19698
19649: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19650: LD_ADDR_VAR 0 4
19654: PUSH
19655: LD_EXP 15
19659: PUSH
19660: LD_EXP 15
19664: PUSH
19665: LD_EXP 14
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: PPUSH
19675: CALL 23251 0 1
19679: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19680: LD_ADDR_VAR 0 5
19684: PUSH
19685: LD_INT 0
19687: PPUSH
19688: LD_INT 3
19690: PPUSH
19691: CALL 22798 0 2
19695: ST_TO_ADDR
// end ; 2 :
19696: GO 19813
19698: LD_INT 2
19700: DOUBLE
19701: EQUAL
19702: IFTRUE 19706
19704: GO 19755
19706: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19707: LD_ADDR_VAR 0 4
19711: PUSH
19712: LD_EXP 15
19716: PUSH
19717: LD_EXP 15
19721: PUSH
19722: LD_EXP 14
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: LIST
19731: PPUSH
19732: CALL 23251 0 1
19736: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19737: LD_ADDR_VAR 0 5
19741: PUSH
19742: LD_INT 0
19744: PPUSH
19745: LD_INT 3
19747: PPUSH
19748: CALL 22798 0 2
19752: ST_TO_ADDR
// end ; 3 :
19753: GO 19813
19755: LD_INT 3
19757: DOUBLE
19758: EQUAL
19759: IFTRUE 19763
19761: GO 19812
19763: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19764: LD_ADDR_VAR 0 4
19768: PUSH
19769: LD_EXP 15
19773: PUSH
19774: LD_EXP 15
19778: PUSH
19779: LD_EXP 14
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: LIST
19788: PPUSH
19789: CALL 23251 0 1
19793: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19794: LD_ADDR_VAR 0 5
19798: PUSH
19799: LD_INT 0
19801: PPUSH
19802: LD_INT 3
19804: PPUSH
19805: CALL 22798 0 2
19809: ST_TO_ADDR
// end ; end ;
19810: GO 19813
19812: POP
// for i := 1 to u2 do
19813: LD_ADDR_VAR 0 3
19817: PUSH
19818: DOUBLE
19819: LD_INT 1
19821: DEC
19822: ST_TO_ADDR
19823: LD_VAR 0 4
19827: PUSH
19828: FOR_TO
19829: IFFALSE 19859
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
19831: LD_VAR 0 5
19835: PUSH
19836: LD_VAR 0 3
19840: ARRAY
19841: PPUSH
19842: LD_VAR 0 4
19846: PUSH
19847: LD_VAR 0 3
19851: ARRAY
19852: PPUSH
19853: CALL_OW 52
// end ;
19857: GO 19828
19859: POP
19860: POP
// for i in u2 do
19861: LD_ADDR_VAR 0 3
19865: PUSH
19866: LD_VAR 0 4
19870: PUSH
19871: FOR_IN
19872: IFFALSE 19891
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
19874: LD_VAR 0 3
19878: PPUSH
19879: LD_INT 2
19881: PPUSH
19882: LD_INT 0
19884: PPUSH
19885: CALL 23907 0 3
// end ;
19889: GO 19871
19891: POP
19892: POP
// wait ( 0 0$1 ) ;
19893: LD_INT 35
19895: PPUSH
19896: CALL_OW 67
// AttackBase ( u2 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
19900: LD_VAR 0 4
19904: PPUSH
19905: LD_EXP 109
19909: PUSH
19910: LD_EXP 114
19914: PPUSH
19915: CALL 13558 0 1
19919: ADD
19920: PUSH
19921: LD_EXP 111
19925: ADD
19926: PPUSH
19927: CALL 13963 0 2
// p4 := CreateS ( 3 ) ;
19931: LD_ADDR_VAR 0 9
19935: PUSH
19936: LD_INT 3
19938: PPUSH
19939: CALL 23127 0 1
19943: ST_TO_ADDR
// p4 := p4 ^ CreateB ( 3 ) ;
19944: LD_ADDR_VAR 0 9
19948: PUSH
19949: LD_VAR 0 9
19953: PUSH
19954: LD_INT 3
19956: PPUSH
19957: CALL 23003 0 1
19961: ADD
19962: ST_TO_ADDR
// for i in p4 do
19963: LD_ADDR_VAR 0 3
19967: PUSH
19968: LD_VAR 0 9
19972: PUSH
19973: FOR_IN
19974: IFFALSE 19993
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
19976: LD_VAR 0 3
19980: PPUSH
19981: LD_INT 15
19983: PPUSH
19984: LD_INT 0
19986: PPUSH
19987: CALL 23907 0 3
// end ;
19991: GO 19973
19993: POP
19994: POP
// wait ( 0 0$1 ) ;
19995: LD_INT 35
19997: PPUSH
19998: CALL_OW 67
// AttackBase ( p4 , pathBR ^ pathUR ) ;
20002: LD_VAR 0 9
20006: PPUSH
20007: LD_EXP 110
20011: PUSH
20012: LD_EXP 112
20016: ADD
20017: PPUSH
20018: CALL 13963 0 2
// case difficulty of 1 :
20022: LD_OWVAR 67
20026: PUSH
20027: LD_INT 1
20029: DOUBLE
20030: EQUAL
20031: IFTRUE 20035
20033: GO 20090
20035: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20036: LD_ADDR_VAR 0 6
20040: PUSH
20041: LD_EXP 15
20045: PUSH
20046: LD_EXP 14
20050: PUSH
20051: LD_EXP 15
20055: PUSH
20056: LD_EXP 13
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: PPUSH
20067: CALL 23251 0 1
20071: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20072: LD_ADDR_VAR 0 7
20076: PUSH
20077: LD_INT 0
20079: PPUSH
20080: LD_INT 4
20082: PPUSH
20083: CALL 22798 0 2
20087: ST_TO_ADDR
// end ; 2 :
20088: GO 20217
20090: LD_INT 2
20092: DOUBLE
20093: EQUAL
20094: IFTRUE 20098
20096: GO 20153
20098: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20099: LD_ADDR_VAR 0 6
20103: PUSH
20104: LD_EXP 15
20108: PUSH
20109: LD_EXP 14
20113: PUSH
20114: LD_EXP 15
20118: PUSH
20119: LD_EXP 13
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: PPUSH
20130: CALL 23251 0 1
20134: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20135: LD_ADDR_VAR 0 7
20139: PUSH
20140: LD_INT 0
20142: PPUSH
20143: LD_INT 4
20145: PPUSH
20146: CALL 22798 0 2
20150: ST_TO_ADDR
// end ; 3 :
20151: GO 20217
20153: LD_INT 3
20155: DOUBLE
20156: EQUAL
20157: IFTRUE 20161
20159: GO 20216
20161: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20162: LD_ADDR_VAR 0 6
20166: PUSH
20167: LD_EXP 15
20171: PUSH
20172: LD_EXP 14
20176: PUSH
20177: LD_EXP 15
20181: PUSH
20182: LD_EXP 13
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PPUSH
20193: CALL 23251 0 1
20197: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20198: LD_ADDR_VAR 0 7
20202: PUSH
20203: LD_INT 0
20205: PPUSH
20206: LD_INT 4
20208: PPUSH
20209: CALL 22798 0 2
20213: ST_TO_ADDR
// end ; end ;
20214: GO 20217
20216: POP
// for i := 1 to u3 do
20217: LD_ADDR_VAR 0 3
20221: PUSH
20222: DOUBLE
20223: LD_INT 1
20225: DEC
20226: ST_TO_ADDR
20227: LD_VAR 0 6
20231: PUSH
20232: FOR_TO
20233: IFFALSE 20263
// begin PlaceHumanInUnit ( p3 [ i ] , u3 [ i ] ) ;
20235: LD_VAR 0 7
20239: PUSH
20240: LD_VAR 0 3
20244: ARRAY
20245: PPUSH
20246: LD_VAR 0 6
20250: PUSH
20251: LD_VAR 0 3
20255: ARRAY
20256: PPUSH
20257: CALL_OW 52
// end ;
20261: GO 20232
20263: POP
20264: POP
// for i in u3 do
20265: LD_ADDR_VAR 0 3
20269: PUSH
20270: LD_VAR 0 6
20274: PUSH
20275: FOR_IN
20276: IFFALSE 20295
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20278: LD_VAR 0 3
20282: PPUSH
20283: LD_INT 15
20285: PPUSH
20286: LD_INT 0
20288: PPUSH
20289: CALL 23907 0 3
// end ;
20293: GO 20275
20295: POP
20296: POP
// wait ( 0 0$1 ) ;
20297: LD_INT 35
20299: PPUSH
20300: CALL_OW 67
// AttackBase ( u3 , pathBR ^ pathUR ) ;
20304: LD_VAR 0 6
20308: PPUSH
20309: LD_EXP 110
20313: PUSH
20314: LD_EXP 112
20318: ADD
20319: PPUSH
20320: CALL 13963 0 2
// case difficulty of 1 :
20324: LD_OWVAR 67
20328: PUSH
20329: LD_INT 1
20331: DOUBLE
20332: EQUAL
20333: IFTRUE 20337
20335: GO 20376
20337: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20338: LD_ADDR_VAR 0 8
20342: PUSH
20343: LD_EXP 13
20347: PUSH
20348: LD_EXP 14
20352: PUSH
20353: LD_EXP 15
20357: PUSH
20358: LD_EXP 10
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: PPUSH
20369: CALL 23577 0 1
20373: ST_TO_ADDR
// end ; 2 :
20374: GO 20471
20376: LD_INT 2
20378: DOUBLE
20379: EQUAL
20380: IFTRUE 20384
20382: GO 20423
20384: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20385: LD_ADDR_VAR 0 8
20389: PUSH
20390: LD_EXP 13
20394: PUSH
20395: LD_EXP 14
20399: PUSH
20400: LD_EXP 15
20404: PUSH
20405: LD_EXP 10
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL 23577 0 1
20420: ST_TO_ADDR
// end ; 3 :
20421: GO 20471
20423: LD_INT 3
20425: DOUBLE
20426: EQUAL
20427: IFTRUE 20431
20429: GO 20470
20431: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20432: LD_ADDR_VAR 0 8
20436: PUSH
20437: LD_EXP 13
20441: PUSH
20442: LD_EXP 14
20446: PUSH
20447: LD_EXP 15
20451: PUSH
20452: LD_EXP 10
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: PPUSH
20463: CALL 23577 0 1
20467: ST_TO_ADDR
// end ; end ;
20468: GO 20471
20470: POP
// for i in u4 do
20471: LD_ADDR_VAR 0 3
20475: PUSH
20476: LD_VAR 0 8
20480: PUSH
20481: FOR_IN
20482: IFFALSE 20501
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
20484: LD_VAR 0 3
20488: PPUSH
20489: LD_INT 14
20491: PPUSH
20492: LD_INT 0
20494: PPUSH
20495: CALL 23907 0 3
// end ;
20499: GO 20481
20501: POP
20502: POP
// wait ( 0 0$1 ) ;
20503: LD_INT 35
20505: PPUSH
20506: CALL_OW 67
// AttackBase ( u4 , pathUT ) ;
20510: LD_VAR 0 8
20514: PPUSH
20515: LD_EXP 113
20519: PPUSH
20520: CALL 13963 0 2
// p4 := CreateB ( 3 ) ;
20524: LD_ADDR_VAR 0 9
20528: PUSH
20529: LD_INT 3
20531: PPUSH
20532: CALL 23003 0 1
20536: ST_TO_ADDR
// p4 := p4 ^ CreateS ( 3 ) ;
20537: LD_ADDR_VAR 0 9
20541: PUSH
20542: LD_VAR 0 9
20546: PUSH
20547: LD_INT 3
20549: PPUSH
20550: CALL 23127 0 1
20554: ADD
20555: ST_TO_ADDR
// for i in p4 do
20556: LD_ADDR_VAR 0 3
20560: PUSH
20561: LD_VAR 0 9
20565: PUSH
20566: FOR_IN
20567: IFFALSE 20586
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20569: LD_VAR 0 3
20573: PPUSH
20574: LD_INT 15
20576: PPUSH
20577: LD_INT 0
20579: PPUSH
20580: CALL 23907 0 3
// end ;
20584: GO 20566
20586: POP
20587: POP
// wait ( 0 0$1 ) ;
20588: LD_INT 35
20590: PPUSH
20591: CALL_OW 67
// AttackBase ( p4 , pathUT ) ;
20595: LD_VAR 0 9
20599: PPUSH
20600: LD_EXP 113
20604: PPUSH
20605: CALL 13963 0 2
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_siberite_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_turret ] ] ] ) do
20609: LD_ADDR_VAR 0 3
20613: PUSH
20614: LD_INT 22
20616: PUSH
20617: LD_EXP 47
20621: PUSH
20622: EMPTY
20623: LIST
20624: LIST
20625: PUSH
20626: LD_INT 2
20628: PUSH
20629: LD_INT 30
20631: PUSH
20632: LD_INT 28
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PUSH
20639: LD_INT 30
20641: PUSH
20642: LD_INT 26
20644: PUSH
20645: EMPTY
20646: LIST
20647: LIST
20648: PUSH
20649: LD_INT 30
20651: PUSH
20652: LD_INT 27
20654: PUSH
20655: EMPTY
20656: LIST
20657: LIST
20658: PUSH
20659: LD_INT 30
20661: PUSH
20662: LD_INT 5
20664: PUSH
20665: EMPTY
20666: LIST
20667: LIST
20668: PUSH
20669: LD_INT 30
20671: PUSH
20672: LD_INT 4
20674: PUSH
20675: EMPTY
20676: LIST
20677: LIST
20678: PUSH
20679: LD_INT 30
20681: PUSH
20682: LD_INT 32
20684: PUSH
20685: EMPTY
20686: LIST
20687: LIST
20688: PUSH
20689: LD_INT 30
20691: PUSH
20692: LD_INT 31
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: PUSH
20699: LD_INT 30
20701: PUSH
20702: LD_INT 33
20704: PUSH
20705: EMPTY
20706: LIST
20707: LIST
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: LIST
20714: LIST
20715: LIST
20716: LIST
20717: LIST
20718: LIST
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: PPUSH
20724: CALL_OW 69
20728: PUSH
20729: FOR_IN
20730: IFFALSE 20748
// begin PriorityAttack ( russians , i ) ;
20732: LD_EXP 49
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 470
// end ;
20746: GO 20729
20748: POP
20749: POP
// wait ( 0 0$20 ) ;
20750: LD_INT 700
20752: PPUSH
20753: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_not , [ f_btype , b_warehouse ] ] , [ f_not , [ f_btype , b_depot ] ] ] ) do
20757: LD_ADDR_VAR 0 3
20761: PUSH
20762: LD_INT 22
20764: PUSH
20765: LD_EXP 47
20769: PUSH
20770: EMPTY
20771: LIST
20772: LIST
20773: PUSH
20774: LD_INT 3
20776: PUSH
20777: LD_INT 30
20779: PUSH
20780: LD_INT 1
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: PUSH
20791: LD_INT 3
20793: PUSH
20794: LD_INT 30
20796: PUSH
20797: LD_INT 0
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: LIST
20812: PPUSH
20813: CALL_OW 69
20817: PUSH
20818: FOR_IN
20819: IFFALSE 20837
// begin PriorityAttack ( russians , i ) ;
20821: LD_EXP 49
20825: PPUSH
20826: LD_VAR 0 3
20830: PPUSH
20831: CALL_OW 470
// end ;
20835: GO 20818
20837: POP
20838: POP
// wait ( 0 0$30 ) ;
20839: LD_INT 1050
20841: PPUSH
20842: CALL_OW 67
// if Getside ( rudepot1 ) = you and xxx < 2 then
20846: LD_EXP 67
20850: PPUSH
20851: CALL_OW 255
20855: PUSH
20856: LD_EXP 47
20860: EQUAL
20861: PUSH
20862: LD_EXP 107
20866: PUSH
20867: LD_INT 2
20869: LESS
20870: AND
20871: IFFALSE 20888
// begin xxx := xxx + 1 ;
20873: LD_ADDR_EXP 107
20877: PUSH
20878: LD_EXP 107
20882: PUSH
20883: LD_INT 1
20885: PLUS
20886: ST_TO_ADDR
// enable ;
20887: ENABLE
// end ; end ;
20888: PPOPN 9
20890: END
// export xxx ; every 0 0$15 trigger GetSide ( RuDepot1 ) = you and not FilterHumansInArea ( base , [ f_side , you ] ) do var ing , i , a ;
20891: LD_EXP 67
20895: PPUSH
20896: CALL_OW 255
20900: PUSH
20901: LD_EXP 47
20905: EQUAL
20906: PUSH
20907: LD_INT 1
20909: PPUSH
20910: LD_INT 22
20912: PUSH
20913: LD_EXP 47
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PPUSH
20922: CALL 13418 0 2
20926: NOT
20927: AND
20928: IFFALSE 21194
20930: GO 20932
20932: DISABLE
20933: LD_INT 0
20935: PPUSH
20936: PPUSH
20937: PPUSH
// begin InitUc ;
20938: CALL_OW 18
// InitHc ;
20942: CALL_OW 19
// uc_side := russians ;
20946: LD_ADDR_OWVAR 20
20950: PUSH
20951: LD_EXP 49
20955: ST_TO_ADDR
// uc_nation := nation_russian ;
20956: LD_ADDR_OWVAR 21
20960: PUSH
20961: LD_INT 3
20963: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
20964: LD_INT 0
20966: PPUSH
20967: LD_INT 6
20969: PPUSH
20970: CALL_OW 382
// ing := CreateHuman ;
20974: LD_ADDR_VAR 0 1
20978: PUSH
20979: CALL_OW 44
20983: ST_TO_ADDR
// PlaceUnitXYR ( ing , 137 , 147 , 4 , false ) ;
20984: LD_VAR 0 1
20988: PPUSH
20989: LD_INT 137
20991: PPUSH
20992: LD_INT 147
20994: PPUSH
20995: LD_INT 4
20997: PPUSH
20998: LD_INT 0
21000: PPUSH
21001: CALL_OW 50
// wait ( 0 0$5 ) ;
21005: LD_INT 175
21007: PPUSH
21008: CALL_OW 67
// a := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) ;
21012: LD_ADDR_VAR 0 3
21016: PUSH
21017: LD_INT 22
21019: PUSH
21020: LD_EXP 49
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: PUSH
21029: LD_INT 25
21031: PUSH
21032: LD_INT 2
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: PPUSH
21043: CALL_OW 69
21047: ST_TO_ADDR
// ComMoveUnit ( a , rudepot1 ) ;
21048: LD_VAR 0 3
21052: PPUSH
21053: LD_EXP 67
21057: PPUSH
21058: CALL_OW 112
// wait ( 0 0$20 ) ;
21062: LD_INT 700
21064: PPUSH
21065: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) > 3 then
21069: LD_INT 22
21071: PUSH
21072: LD_EXP 49
21076: PUSH
21077: EMPTY
21078: LIST
21079: LIST
21080: PUSH
21081: LD_INT 25
21083: PUSH
21084: LD_INT 2
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PPUSH
21095: CALL_OW 69
21099: PUSH
21100: LD_INT 3
21102: GREATER
21103: IFFALSE 21193
// begin TimerEnable := true ;
21105: LD_ADDR_EXP 63
21109: PUSH
21110: LD_INT 1
21112: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
21113: LD_ADDR_EXP 81
21117: PUSH
21118: LD_EXP 49
21122: PPUSH
21123: CALL_OW 462
21127: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
21128: LD_EXP 67
21132: PPUSH
21133: CALL_OW 274
21137: PPUSH
21138: LD_EXP 49
21142: PPUSH
21143: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you ] ] ) do
21147: LD_ADDR_VAR 0 2
21151: PUSH
21152: LD_INT 22
21154: PUSH
21155: LD_EXP 47
21159: PUSH
21160: EMPTY
21161: LIST
21162: LIST
21163: PUSH
21164: EMPTY
21165: LIST
21166: PPUSH
21167: CALL_OW 69
21171: PUSH
21172: FOR_IN
21173: IFFALSE 21191
// NormalAttack ( russians , i ) ;
21175: LD_EXP 49
21179: PPUSH
21180: LD_VAR 0 2
21184: PPUSH
21185: CALL_OW 472
21189: GO 21172
21191: POP
21192: POP
// end ; enable ;
21193: ENABLE
// end ;
21194: PPOPN 3
21196: END
// every 0 0$5 do var a ;
21197: GO 21199
21199: DISABLE
21200: LD_INT 0
21202: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , russians ] , [ f_not , [ f_hastask ] ] ] ) ;
21203: LD_ADDR_VAR 0 1
21207: PUSH
21208: LD_INT 22
21210: PUSH
21211: LD_EXP 49
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: LD_INT 3
21222: PUSH
21223: LD_INT 60
21225: PUSH
21226: EMPTY
21227: LIST
21228: PUSH
21229: EMPTY
21230: LIST
21231: LIST
21232: PUSH
21233: EMPTY
21234: LIST
21235: LIST
21236: PPUSH
21237: CALL_OW 69
21241: ST_TO_ADDR
// wait ( 0 0$5 ) ;
21242: LD_INT 175
21244: PPUSH
21245: CALL_OW 67
// a := UnitFilter ( a , [ f_not , [ f_hastask ] ] ) ;
21249: LD_ADDR_VAR 0 1
21253: PUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_INT 3
21261: PUSH
21262: LD_INT 60
21264: PUSH
21265: EMPTY
21266: LIST
21267: PUSH
21268: EMPTY
21269: LIST
21270: LIST
21271: PPUSH
21272: CALL_OW 72
21276: ST_TO_ADDR
// if a then
21277: LD_VAR 0 1
21281: IFFALSE 21349
// begin ComAgressiveMove ( UnitFilter ( a , [ [ f_inarea , top_half ] ] ) , 42 , 10 ) ;
21283: LD_VAR 0 1
21287: PPUSH
21288: LD_INT 95
21290: PUSH
21291: LD_INT 6
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: EMPTY
21299: LIST
21300: PPUSH
21301: CALL_OW 72
21305: PPUSH
21306: LD_INT 42
21308: PPUSH
21309: LD_INT 10
21311: PPUSH
21312: CALL_OW 114
// ComAgressiveMove ( UnitFilter ( a , [ [ f_exceptarea , top_half ] ] ) , 93 , 94 ) ;
21316: LD_VAR 0 1
21320: PPUSH
21321: LD_INT 96
21323: PUSH
21324: LD_INT 6
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: PUSH
21331: EMPTY
21332: LIST
21333: PPUSH
21334: CALL_OW 72
21338: PPUSH
21339: LD_INT 93
21341: PPUSH
21342: LD_INT 94
21344: PPUSH
21345: CALL_OW 114
// end ; enable ;
21349: ENABLE
// end ;
21350: PPOPN 1
21352: END
// export pathBL , pathBM , pathBR , pathUL , pathUR , pathUT , pathML , pathMM , pathMR , pathT ; export pathB1 , pathB2 , pathB3 , pathB4 ; var d ; every 0 0$0.1 do
21353: GO 21355
21355: DISABLE
// begin pathBL := [ [ 62 , 119 ] , [ 73 , 120 ] , [ 78 , 121 ] , [ 80 , 118 ] , [ 80 , 113 ] , [ 80 , 109 ] ] ;
21356: LD_ADDR_EXP 108
21360: PUSH
21361: LD_INT 62
21363: PUSH
21364: LD_INT 119
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PUSH
21371: LD_INT 73
21373: PUSH
21374: LD_INT 120
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: PUSH
21381: LD_INT 78
21383: PUSH
21384: LD_INT 121
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: LD_INT 80
21393: PUSH
21394: LD_INT 118
21396: PUSH
21397: EMPTY
21398: LIST
21399: LIST
21400: PUSH
21401: LD_INT 80
21403: PUSH
21404: LD_INT 113
21406: PUSH
21407: EMPTY
21408: LIST
21409: LIST
21410: PUSH
21411: LD_INT 80
21413: PUSH
21414: LD_INT 109
21416: PUSH
21417: EMPTY
21418: LIST
21419: LIST
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: LIST
21425: LIST
21426: LIST
21427: LIST
21428: ST_TO_ADDR
// pathBM := [ [ 98 , 144 ] , [ 96 , 139 ] , [ 96 , 135 ] , [ 96 , 131 ] , [ 97 , 128 ] , [ 99 , 126 ] , [ 101 , 124 ] ] ;
21429: LD_ADDR_EXP 109
21433: PUSH
21434: LD_INT 98
21436: PUSH
21437: LD_INT 144
21439: PUSH
21440: EMPTY
21441: LIST
21442: LIST
21443: PUSH
21444: LD_INT 96
21446: PUSH
21447: LD_INT 139
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: PUSH
21454: LD_INT 96
21456: PUSH
21457: LD_INT 135
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 96
21466: PUSH
21467: LD_INT 131
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: LD_INT 97
21476: PUSH
21477: LD_INT 128
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: PUSH
21484: LD_INT 99
21486: PUSH
21487: LD_INT 126
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: LD_INT 101
21496: PUSH
21497: LD_INT 124
21499: PUSH
21500: EMPTY
21501: LIST
21502: LIST
21503: PUSH
21504: EMPTY
21505: LIST
21506: LIST
21507: LIST
21508: LIST
21509: LIST
21510: LIST
21511: LIST
21512: ST_TO_ADDR
// pathBR := [ [ 130 , 137 ] , [ 120 , 128 ] ] ;
21513: LD_ADDR_EXP 110
21517: PUSH
21518: LD_INT 130
21520: PUSH
21521: LD_INT 137
21523: PUSH
21524: EMPTY
21525: LIST
21526: LIST
21527: PUSH
21528: LD_INT 120
21530: PUSH
21531: LD_INT 128
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: PUSH
21538: EMPTY
21539: LIST
21540: LIST
21541: ST_TO_ADDR
// pathUL := [ [ 80 , 109 ] , [ 77 , 103 ] , [ 72 , 97 ] , [ 71 , 93 ] , [ 76 , 93 ] , [ 81 , 93 ] , [ 86 , 94 ] , [ 92 , 95 ] ] ;
21542: LD_ADDR_EXP 111
21546: PUSH
21547: LD_INT 80
21549: PUSH
21550: LD_INT 109
21552: PUSH
21553: EMPTY
21554: LIST
21555: LIST
21556: PUSH
21557: LD_INT 77
21559: PUSH
21560: LD_INT 103
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: LD_INT 72
21569: PUSH
21570: LD_INT 97
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 71
21579: PUSH
21580: LD_INT 93
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 76
21589: PUSH
21590: LD_INT 93
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: PUSH
21597: LD_INT 81
21599: PUSH
21600: LD_INT 93
21602: PUSH
21603: EMPTY
21604: LIST
21605: LIST
21606: PUSH
21607: LD_INT 86
21609: PUSH
21610: LD_INT 94
21612: PUSH
21613: EMPTY
21614: LIST
21615: LIST
21616: PUSH
21617: LD_INT 92
21619: PUSH
21620: LD_INT 95
21622: PUSH
21623: EMPTY
21624: LIST
21625: LIST
21626: PUSH
21627: EMPTY
21628: LIST
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: ST_TO_ADDR
// pathUR := [ [ 120 , 128 ] , [ 115 , 123 ] , [ 110 , 118 ] , [ 106 , 114 ] , [ 99 , 107 ] , [ 96 , 100 ] , [ 92 , 95 ] ] ;
21637: LD_ADDR_EXP 112
21641: PUSH
21642: LD_INT 120
21644: PUSH
21645: LD_INT 128
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: PUSH
21652: LD_INT 115
21654: PUSH
21655: LD_INT 123
21657: PUSH
21658: EMPTY
21659: LIST
21660: LIST
21661: PUSH
21662: LD_INT 110
21664: PUSH
21665: LD_INT 118
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: PUSH
21672: LD_INT 106
21674: PUSH
21675: LD_INT 114
21677: PUSH
21678: EMPTY
21679: LIST
21680: LIST
21681: PUSH
21682: LD_INT 99
21684: PUSH
21685: LD_INT 107
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 96
21694: PUSH
21695: LD_INT 100
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: PUSH
21702: LD_INT 92
21704: PUSH
21705: LD_INT 95
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// pathUT := [ [ 111 , 87 ] , [ 107 , 88 ] , [ 103 , 88 ] , [ 100 , 85 ] , [ 95 , 85 ] , [ 91 , 85 ] ] ;
21721: LD_ADDR_EXP 113
21725: PUSH
21726: LD_INT 111
21728: PUSH
21729: LD_INT 87
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: PUSH
21736: LD_INT 107
21738: PUSH
21739: LD_INT 88
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: PUSH
21746: LD_INT 103
21748: PUSH
21749: LD_INT 88
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 100
21758: PUSH
21759: LD_INT 85
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 95
21768: PUSH
21769: LD_INT 85
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: LD_INT 91
21778: PUSH
21779: LD_INT 85
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: LIST
21790: LIST
21791: LIST
21792: LIST
21793: ST_TO_ADDR
// pathML := [ [ 80 , 109 ] , [ 85 , 111 ] , [ 89 , 112 ] , [ 94 , 117 ] , [ 98 , 121 ] , [ 101 , 124 ] ] ;
21794: LD_ADDR_EXP 114
21798: PUSH
21799: LD_INT 80
21801: PUSH
21802: LD_INT 109
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 85
21811: PUSH
21812: LD_INT 111
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 89
21821: PUSH
21822: LD_INT 112
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: PUSH
21829: LD_INT 94
21831: PUSH
21832: LD_INT 117
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: LD_INT 98
21841: PUSH
21842: LD_INT 121
21844: PUSH
21845: EMPTY
21846: LIST
21847: LIST
21848: PUSH
21849: LD_INT 101
21851: PUSH
21852: LD_INT 124
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: LIST
21863: LIST
21864: LIST
21865: LIST
21866: ST_TO_ADDR
// pathMM := [ [ 101 , 124 ] , [ 105 , 125 ] , [ 112 , 128 ] , [ 117 , 129 ] , [ 120 , 128 ] ] ;
21867: LD_ADDR_EXP 115
21871: PUSH
21872: LD_INT 101
21874: PUSH
21875: LD_INT 124
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PUSH
21882: LD_INT 105
21884: PUSH
21885: LD_INT 125
21887: PUSH
21888: EMPTY
21889: LIST
21890: LIST
21891: PUSH
21892: LD_INT 112
21894: PUSH
21895: LD_INT 128
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: PUSH
21902: LD_INT 117
21904: PUSH
21905: LD_INT 129
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: PUSH
21912: LD_INT 120
21914: PUSH
21915: LD_INT 128
21917: PUSH
21918: EMPTY
21919: LIST
21920: LIST
21921: PUSH
21922: EMPTY
21923: LIST
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: ST_TO_ADDR
// pathMR := [ [ 120 , 128 ] , [ 121 , 124 ] , [ 119 , 118 ] , [ 116 , 112 ] , [ 115 , 105 ] , [ 116 , 100 ] , [ 114 , 92 ] , [ 111 , 87 ] ] ;
21929: LD_ADDR_EXP 116
21933: PUSH
21934: LD_INT 120
21936: PUSH
21937: LD_INT 128
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: PUSH
21944: LD_INT 121
21946: PUSH
21947: LD_INT 124
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: LD_INT 119
21956: PUSH
21957: LD_INT 118
21959: PUSH
21960: EMPTY
21961: LIST
21962: LIST
21963: PUSH
21964: LD_INT 116
21966: PUSH
21967: LD_INT 112
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: LD_INT 115
21976: PUSH
21977: LD_INT 105
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: PUSH
21984: LD_INT 116
21986: PUSH
21987: LD_INT 100
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: PUSH
21994: LD_INT 114
21996: PUSH
21997: LD_INT 92
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: PUSH
22004: LD_INT 111
22006: PUSH
22007: LD_INT 87
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: PUSH
22014: EMPTY
22015: LIST
22016: LIST
22017: LIST
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// pathT := [ [ 111 , 87 ] , [ 109 , 82 ] , [ 105 , 77 ] , [ 103 , 71 ] , [ 100 , 65 ] , [ 97 , 62 ] , [ 93 , 61 ] , [ 92 , 56 ] , [ 90 , 52 ] , [ 87 , 48 ] , [ 82 , 46 ] , [ 78 , 44 ] , [ 76 , 37 ] , [ 75 , 33 ] , [ 75 , 29 ] , [ 71 , 25 ] , [ 67 , 23 ] , [ 62 , 22 ] , [ 59 , 23 ] , [ 57 , 26 ] , [ 54 , 37 ] , [ 51 , 29 ] , [ 47 , 26 ] , [ 45 , 23 ] , [ 42 , 18 ] ] ;
22024: LD_ADDR_EXP 117
22028: PUSH
22029: LD_INT 111
22031: PUSH
22032: LD_INT 87
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 109
22041: PUSH
22042: LD_INT 82
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PUSH
22049: LD_INT 105
22051: PUSH
22052: LD_INT 77
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PUSH
22059: LD_INT 103
22061: PUSH
22062: LD_INT 71
22064: PUSH
22065: EMPTY
22066: LIST
22067: LIST
22068: PUSH
22069: LD_INT 100
22071: PUSH
22072: LD_INT 65
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 97
22081: PUSH
22082: LD_INT 62
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PUSH
22089: LD_INT 93
22091: PUSH
22092: LD_INT 61
22094: PUSH
22095: EMPTY
22096: LIST
22097: LIST
22098: PUSH
22099: LD_INT 92
22101: PUSH
22102: LD_INT 56
22104: PUSH
22105: EMPTY
22106: LIST
22107: LIST
22108: PUSH
22109: LD_INT 90
22111: PUSH
22112: LD_INT 52
22114: PUSH
22115: EMPTY
22116: LIST
22117: LIST
22118: PUSH
22119: LD_INT 87
22121: PUSH
22122: LD_INT 48
22124: PUSH
22125: EMPTY
22126: LIST
22127: LIST
22128: PUSH
22129: LD_INT 82
22131: PUSH
22132: LD_INT 46
22134: PUSH
22135: EMPTY
22136: LIST
22137: LIST
22138: PUSH
22139: LD_INT 78
22141: PUSH
22142: LD_INT 44
22144: PUSH
22145: EMPTY
22146: LIST
22147: LIST
22148: PUSH
22149: LD_INT 76
22151: PUSH
22152: LD_INT 37
22154: PUSH
22155: EMPTY
22156: LIST
22157: LIST
22158: PUSH
22159: LD_INT 75
22161: PUSH
22162: LD_INT 33
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: PUSH
22169: LD_INT 75
22171: PUSH
22172: LD_INT 29
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: PUSH
22179: LD_INT 71
22181: PUSH
22182: LD_INT 25
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: PUSH
22189: LD_INT 67
22191: PUSH
22192: LD_INT 23
22194: PUSH
22195: EMPTY
22196: LIST
22197: LIST
22198: PUSH
22199: LD_INT 62
22201: PUSH
22202: LD_INT 22
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PUSH
22209: LD_INT 59
22211: PUSH
22212: LD_INT 23
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: PUSH
22219: LD_INT 57
22221: PUSH
22222: LD_INT 26
22224: PUSH
22225: EMPTY
22226: LIST
22227: LIST
22228: PUSH
22229: LD_INT 54
22231: PUSH
22232: LD_INT 37
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 51
22241: PUSH
22242: LD_INT 29
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: LD_INT 47
22251: PUSH
22252: LD_INT 26
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: PUSH
22259: LD_INT 45
22261: PUSH
22262: LD_INT 23
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: PUSH
22269: LD_INT 42
22271: PUSH
22272: LD_INT 18
22274: PUSH
22275: EMPTY
22276: LIST
22277: LIST
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: LIST
22283: LIST
22284: LIST
22285: LIST
22286: LIST
22287: LIST
22288: LIST
22289: LIST
22290: LIST
22291: LIST
22292: LIST
22293: LIST
22294: LIST
22295: LIST
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: ST_TO_ADDR
// pathB1 := [ [ 97 , 72 ] , [ 84 , 67 ] , [ 84 , 77 ] ] ;
22306: LD_ADDR_EXP 118
22310: PUSH
22311: LD_INT 97
22313: PUSH
22314: LD_INT 72
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: LD_INT 84
22323: PUSH
22324: LD_INT 67
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: PUSH
22331: LD_INT 84
22333: PUSH
22334: LD_INT 77
22336: PUSH
22337: EMPTY
22338: LIST
22339: LIST
22340: PUSH
22341: EMPTY
22342: LIST
22343: LIST
22344: LIST
22345: ST_TO_ADDR
// pathB2 := [ [ 44 , 71 ] , [ 64 , 68 ] , [ 64 , 79 ] ] ;
22346: LD_ADDR_EXP 119
22350: PUSH
22351: LD_INT 44
22353: PUSH
22354: LD_INT 71
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: PUSH
22361: LD_INT 64
22363: PUSH
22364: LD_INT 68
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: PUSH
22371: LD_INT 64
22373: PUSH
22374: LD_INT 79
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: ST_TO_ADDR
// pathB3 := [ [ 91 , 131 ] , [ 93 , 121 ] , [ 94 , 115 ] , [ 107 , 115 ] ] ;
22386: LD_ADDR_EXP 120
22390: PUSH
22391: LD_INT 91
22393: PUSH
22394: LD_INT 131
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: PUSH
22401: LD_INT 93
22403: PUSH
22404: LD_INT 121
22406: PUSH
22407: EMPTY
22408: LIST
22409: LIST
22410: PUSH
22411: LD_INT 94
22413: PUSH
22414: LD_INT 115
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 107
22423: PUSH
22424: LD_INT 115
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: ST_TO_ADDR
// pathB4 := [ [ 126 , 128 ] , [ 116 , 107 ] , [ 107 , 87 ] ] ;
22437: LD_ADDR_EXP 121
22441: PUSH
22442: LD_INT 126
22444: PUSH
22445: LD_INT 128
22447: PUSH
22448: EMPTY
22449: LIST
22450: LIST
22451: PUSH
22452: LD_INT 116
22454: PUSH
22455: LD_INT 107
22457: PUSH
22458: EMPTY
22459: LIST
22460: LIST
22461: PUSH
22462: LD_INT 107
22464: PUSH
22465: LD_INT 87
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: ST_TO_ADDR
// lev := [ 2 , 4 , 7 ] ;
22477: LD_ADDR_EXP 5
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 4
22487: PUSH
22488: LD_INT 7
22490: PUSH
22491: EMPTY
22492: LIST
22493: LIST
22494: LIST
22495: ST_TO_ADDR
// d := difficulty ;
22496: LD_ADDR_LOC 2
22500: PUSH
22501: LD_OWVAR 67
22505: ST_TO_ADDR
// case true of d <= 1 :
22506: LD_INT 1
22508: PUSH
22509: LD_LOC 2
22513: PUSH
22514: LD_INT 1
22516: LESSEQUAL
22517: DOUBLE
22518: EQUAL
22519: IFTRUE 22523
22521: GO 22526
22523: POP
// ; d <= 2 :
22524: GO 22621
22526: LD_LOC 2
22530: PUSH
22531: LD_INT 2
22533: LESSEQUAL
22534: DOUBLE
22535: EQUAL
22536: IFTRUE 22540
22538: GO 22573
22540: POP
// begin SetTech ( tech_Comp1 , russians , state_researched ) ;
22541: LD_INT 57
22543: PPUSH
22544: LD_EXP 49
22548: PPUSH
22549: LD_INT 2
22551: PPUSH
22552: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
22556: LD_INT 51
22558: PPUSH
22559: LD_EXP 49
22563: PPUSH
22564: LD_INT 2
22566: PPUSH
22567: CALL_OW 322
// end ; d <= 3 :
22571: GO 22621
22573: LD_LOC 2
22577: PUSH
22578: LD_INT 3
22580: LESSEQUAL
22581: DOUBLE
22582: EQUAL
22583: IFTRUE 22587
22585: GO 22620
22587: POP
// begin SetTech ( tech_Comp2 , russians , state_researched ) ;
22588: LD_INT 58
22590: PPUSH
22591: LD_EXP 49
22595: PPUSH
22596: LD_INT 2
22598: PPUSH
22599: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
22603: LD_INT 52
22605: PPUSH
22606: LD_EXP 49
22610: PPUSH
22611: LD_INT 2
22613: PPUSH
22614: CALL_OW 322
// end ; end ;
22618: GO 22621
22620: POP
// end ;
22621: END
// every 31 31$0 do
22622: GO 22624
22624: DISABLE
// begin case difficulty of 1 :
22625: LD_OWVAR 67
22629: PUSH
22630: LD_INT 1
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22656
22638: POP
// SetTech ( tech_Comp1 , russians , state_researched ) ; 2 :
22639: LD_INT 57
22641: PPUSH
22642: LD_EXP 49
22646: PPUSH
22647: LD_INT 2
22649: PPUSH
22650: CALL_OW 322
22654: GO 22709
22656: LD_INT 2
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22682
22664: POP
// SetTech ( tech_Comp2 , russians , state_researched ) ; 3 :
22665: LD_INT 58
22667: PPUSH
22668: LD_EXP 49
22672: PPUSH
22673: LD_INT 2
22675: PPUSH
22676: CALL_OW 322
22680: GO 22709
22682: LD_INT 3
22684: DOUBLE
22685: EQUAL
22686: IFTRUE 22690
22688: GO 22708
22690: POP
// SetTech ( tech_Comp3 , russians , state_researched ) ; end ;
22691: LD_INT 59
22693: PPUSH
22694: LD_EXP 49
22698: PPUSH
22699: LD_INT 2
22701: PPUSH
22702: CALL_OW 322
22706: GO 22709
22708: POP
// end ;
22709: END
// every 47 47$0 do
22710: GO 22712
22712: DISABLE
// begin case difficulty of 1 :
22713: LD_OWVAR 67
22717: PUSH
22718: LD_INT 1
22720: DOUBLE
22721: EQUAL
22722: IFTRUE 22726
22724: GO 22744
22726: POP
// SetTech ( tech_Weap1 , russians , state_researched ) ; 2 :
22727: LD_INT 51
22729: PPUSH
22730: LD_EXP 49
22734: PPUSH
22735: LD_INT 2
22737: PPUSH
22738: CALL_OW 322
22742: GO 22797
22744: LD_INT 2
22746: DOUBLE
22747: EQUAL
22748: IFTRUE 22752
22750: GO 22770
22752: POP
// SetTech ( tech_Weap2 , russians , state_researched ) ; 3 :
22753: LD_INT 52
22755: PPUSH
22756: LD_EXP 49
22760: PPUSH
22761: LD_INT 2
22763: PPUSH
22764: CALL_OW 322
22768: GO 22797
22770: LD_INT 3
22772: DOUBLE
22773: EQUAL
22774: IFTRUE 22778
22776: GO 22796
22778: POP
// SetTech ( tech_Weap3 , russians , state_researched ) ; end ;
22779: LD_INT 53
22781: PPUSH
22782: LD_EXP 49
22786: PPUSH
22787: LD_INT 2
22789: PPUSH
22790: CALL_OW 322
22794: GO 22797
22796: POP
// end ;
22797: END
// function CreateH ( sol , mec ) ; var units , i ; begin
22798: LD_INT 0
22800: PPUSH
22801: PPUSH
22802: PPUSH
// units := [ ] ;
22803: LD_ADDR_VAR 0 4
22807: PUSH
22808: EMPTY
22809: ST_TO_ADDR
// for i := 1 to sol do
22810: LD_ADDR_VAR 0 5
22814: PUSH
22815: DOUBLE
22816: LD_INT 1
22818: DEC
22819: ST_TO_ADDR
22820: LD_VAR 0 1
22824: PUSH
22825: FOR_TO
22826: IFFALSE 22897
// begin InitUc ;
22828: CALL_OW 18
// InitHc ;
22832: CALL_OW 19
// uc_nation := nation_russian ;
22836: LD_ADDR_OWVAR 21
22840: PUSH
22841: LD_INT 3
22843: ST_TO_ADDR
// uc_side := russians ;
22844: LD_ADDR_OWVAR 20
22848: PUSH
22849: LD_EXP 49
22853: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22854: LD_INT 0
22856: PPUSH
22857: LD_EXP 5
22861: PUSH
22862: LD_LOC 2
22866: ARRAY
22867: PPUSH
22868: CALL_OW 381
// units := units ^ CreateHuman ;
22872: LD_ADDR_VAR 0 4
22876: PUSH
22877: LD_VAR 0 4
22881: PUSH
22882: CALL_OW 44
22886: ADD
22887: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22888: LD_INT 7
22890: PPUSH
22891: CALL_OW 67
// end ;
22895: GO 22825
22897: POP
22898: POP
// for i := 1 to mec do
22899: LD_ADDR_VAR 0 5
22903: PUSH
22904: DOUBLE
22905: LD_INT 1
22907: DEC
22908: ST_TO_ADDR
22909: LD_VAR 0 2
22913: PUSH
22914: FOR_TO
22915: IFFALSE 22986
// begin InitUc ;
22917: CALL_OW 18
// InitHc ;
22921: CALL_OW 19
// uc_nation := nation_russian ;
22925: LD_ADDR_OWVAR 21
22929: PUSH
22930: LD_INT 3
22932: ST_TO_ADDR
// uc_side := russians ;
22933: LD_ADDR_OWVAR 20
22937: PUSH
22938: LD_EXP 49
22942: ST_TO_ADDR
// PrepareMechanic ( 0 , lev [ d ] ) ;
22943: LD_INT 0
22945: PPUSH
22946: LD_EXP 5
22950: PUSH
22951: LD_LOC 2
22955: ARRAY
22956: PPUSH
22957: CALL_OW 383
// units := units ^ CreateHuman ;
22961: LD_ADDR_VAR 0 4
22965: PUSH
22966: LD_VAR 0 4
22970: PUSH
22971: CALL_OW 44
22975: ADD
22976: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22977: LD_INT 7
22979: PPUSH
22980: CALL_OW 67
// end ;
22984: GO 22914
22986: POP
22987: POP
// result := units ;
22988: LD_ADDR_VAR 0 3
22992: PUSH
22993: LD_VAR 0 4
22997: ST_TO_ADDR
// end ;
22998: LD_VAR 0 3
23002: RET
// function CreateB ( num ) ; var units , i ; begin
23003: LD_INT 0
23005: PPUSH
23006: PPUSH
23007: PPUSH
// units := [ ] ;
23008: LD_ADDR_VAR 0 3
23012: PUSH
23013: EMPTY
23014: ST_TO_ADDR
// for i := 1 to num do
23015: LD_ADDR_VAR 0 4
23019: PUSH
23020: DOUBLE
23021: LD_INT 1
23023: DEC
23024: ST_TO_ADDR
23025: LD_VAR 0 1
23029: PUSH
23030: FOR_TO
23031: IFFALSE 23110
// begin InitUc ;
23033: CALL_OW 18
// InitHc ;
23037: CALL_OW 19
// uc_nation := nation_russian ;
23041: LD_ADDR_OWVAR 21
23045: PUSH
23046: LD_INT 3
23048: ST_TO_ADDR
// uc_side := russians ;
23049: LD_ADDR_OWVAR 20
23053: PUSH
23054: LD_EXP 49
23058: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
23059: LD_INT 0
23061: PPUSH
23062: LD_EXP 5
23066: PUSH
23067: LD_LOC 2
23071: ARRAY
23072: PPUSH
23073: CALL_OW 381
// hc_class := class_bazooker ;
23077: LD_ADDR_OWVAR 28
23081: PUSH
23082: LD_INT 9
23084: ST_TO_ADDR
// units := units ^ CreateHuman ;
23085: LD_ADDR_VAR 0 3
23089: PUSH
23090: LD_VAR 0 3
23094: PUSH
23095: CALL_OW 44
23099: ADD
23100: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23101: LD_INT 7
23103: PPUSH
23104: CALL_OW 67
// end ;
23108: GO 23030
23110: POP
23111: POP
// result := units ;
23112: LD_ADDR_VAR 0 2
23116: PUSH
23117: LD_VAR 0 3
23121: ST_TO_ADDR
// end ;
23122: LD_VAR 0 2
23126: RET
// function CreateS ( num ) ; var units , i ; begin
23127: LD_INT 0
23129: PPUSH
23130: PPUSH
23131: PPUSH
// units := [ ] ;
23132: LD_ADDR_VAR 0 3
23136: PUSH
23137: EMPTY
23138: ST_TO_ADDR
// for i := 1 to num do
23139: LD_ADDR_VAR 0 4
23143: PUSH
23144: DOUBLE
23145: LD_INT 1
23147: DEC
23148: ST_TO_ADDR
23149: LD_VAR 0 1
23153: PUSH
23154: FOR_TO
23155: IFFALSE 23234
// begin InitUc ;
23157: CALL_OW 18
// InitHc ;
23161: CALL_OW 19
// uc_nation := nation_russian ;
23165: LD_ADDR_OWVAR 21
23169: PUSH
23170: LD_INT 3
23172: ST_TO_ADDR
// uc_side := russians ;
23173: LD_ADDR_OWVAR 20
23177: PUSH
23178: LD_EXP 49
23182: ST_TO_ADDR
// hc_class := class_soldier ;
23183: LD_ADDR_OWVAR 28
23187: PUSH
23188: LD_INT 1
23190: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
23191: LD_INT 0
23193: PPUSH
23194: LD_EXP 5
23198: PUSH
23199: LD_LOC 2
23203: ARRAY
23204: PPUSH
23205: CALL_OW 381
// units := units ^ CreateHuman ;
23209: LD_ADDR_VAR 0 3
23213: PUSH
23214: LD_VAR 0 3
23218: PUSH
23219: CALL_OW 44
23223: ADD
23224: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23225: LD_INT 7
23227: PPUSH
23228: CALL_OW 67
// end ;
23232: GO 23154
23234: POP
23235: POP
// result := units ;
23236: LD_ADDR_VAR 0 2
23240: PUSH
23241: LD_VAR 0 3
23245: ST_TO_ADDR
// end ;
23246: LD_VAR 0 2
23250: RET
// function CreateVH ( list ) ; var units , i ; begin
23251: LD_INT 0
23253: PPUSH
23254: PPUSH
23255: PPUSH
// for i in list do
23256: LD_ADDR_VAR 0 4
23260: PUSH
23261: LD_VAR 0 1
23265: PUSH
23266: FOR_IN
23267: IFFALSE 23560
// begin InitUc ;
23269: CALL_OW 18
// InitVc ;
23273: CALL_OW 20
// uc_nation := nation_russian ;
23277: LD_ADDR_OWVAR 21
23281: PUSH
23282: LD_INT 3
23284: ST_TO_ADDR
// uc_side := russians ;
23285: LD_ADDR_OWVAR 20
23289: PUSH
23290: LD_EXP 49
23294: ST_TO_ADDR
// units := [ ] ;
23295: LD_ADDR_VAR 0 3
23299: PUSH
23300: EMPTY
23301: ST_TO_ADDR
// vc_control := control_manual ;
23302: LD_ADDR_OWVAR 38
23306: PUSH
23307: LD_INT 1
23309: ST_TO_ADDR
// vc_engine := engine_combustion ;
23310: LD_ADDR_OWVAR 39
23314: PUSH
23315: LD_INT 1
23317: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23318: LD_ADDR_OWVAR 41
23322: PUSH
23323: LD_INT 75
23325: ST_TO_ADDR
// case i of mhmg :
23326: LD_VAR 0 4
23330: PUSH
23331: LD_EXP 9
23335: DOUBLE
23336: EQUAL
23337: IFTRUE 23341
23339: GO 23360
23341: POP
// begin vc_chassis := ru_medium_tracked ;
23342: LD_ADDR_OWVAR 37
23346: PUSH
23347: LD_INT 22
23349: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23350: LD_ADDR_OWVAR 40
23354: PUSH
23355: LD_INT 42
23357: ST_TO_ADDR
// end ; mgg :
23358: GO 23535
23360: LD_EXP 10
23364: DOUBLE
23365: EQUAL
23366: IFTRUE 23370
23368: GO 23389
23370: POP
// begin vc_chassis := ru_medium_tracked ;
23371: LD_ADDR_OWVAR 37
23375: PUSH
23376: LD_INT 22
23378: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23379: LD_ADDR_OWVAR 40
23383: PUSH
23384: LD_INT 43
23386: ST_TO_ADDR
// end ; mg :
23387: GO 23535
23389: LD_EXP 11
23393: DOUBLE
23394: EQUAL
23395: IFTRUE 23399
23397: GO 23418
23399: POP
// begin vc_chassis := ru_medium_tracked ;
23400: LD_ADDR_OWVAR 37
23404: PUSH
23405: LD_INT 22
23407: ST_TO_ADDR
// vc_weapon := ru_gun ;
23408: LD_ADDR_OWVAR 40
23412: PUSH
23413: LD_INT 44
23415: ST_TO_ADDR
// end ; mrl :
23416: GO 23535
23418: LD_EXP 12
23422: DOUBLE
23423: EQUAL
23424: IFTRUE 23428
23426: GO 23447
23428: POP
// begin vc_chassis := ru_medium_tracked ;
23429: LD_ADDR_OWVAR 37
23433: PUSH
23434: LD_INT 22
23436: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23437: LD_ADDR_OWVAR 40
23441: PUSH
23442: LD_INT 45
23444: ST_TO_ADDR
// end ; hgg :
23445: GO 23535
23447: LD_EXP 13
23451: DOUBLE
23452: EQUAL
23453: IFTRUE 23457
23455: GO 23476
23457: POP
// begin vc_chassis := ru_heavy_tracked ;
23458: LD_ADDR_OWVAR 37
23462: PUSH
23463: LD_INT 24
23465: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23466: LD_ADDR_OWVAR 40
23470: PUSH
23471: LD_INT 43
23473: ST_TO_ADDR
// end ; hrl :
23474: GO 23535
23476: LD_EXP 14
23480: DOUBLE
23481: EQUAL
23482: IFTRUE 23486
23484: GO 23505
23486: POP
// begin vc_chassis := ru_heavy_tracked ;
23487: LD_ADDR_OWVAR 37
23491: PUSH
23492: LD_INT 24
23494: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23495: LD_ADDR_OWVAR 40
23499: PUSH
23500: LD_INT 45
23502: ST_TO_ADDR
// end ; hhg :
23503: GO 23535
23505: LD_EXP 15
23509: DOUBLE
23510: EQUAL
23511: IFTRUE 23515
23513: GO 23534
23515: POP
// begin vc_chassis := ru_heavy_tracked ;
23516: LD_ADDR_OWVAR 37
23520: PUSH
23521: LD_INT 24
23523: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23524: LD_ADDR_OWVAR 40
23528: PUSH
23529: LD_INT 46
23531: ST_TO_ADDR
// end ; end ;
23532: GO 23535
23534: POP
// units := units ^ CreateVehicle ;
23535: LD_ADDR_VAR 0 3
23539: PUSH
23540: LD_VAR 0 3
23544: PUSH
23545: CALL_OW 45
23549: ADD
23550: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23551: LD_INT 7
23553: PPUSH
23554: CALL_OW 67
// end ;
23558: GO 23266
23560: POP
23561: POP
// result := units ;
23562: LD_ADDR_VAR 0 2
23566: PUSH
23567: LD_VAR 0 3
23571: ST_TO_ADDR
// end ;
23572: LD_VAR 0 2
23576: RET
// function CreateVC ( list ) ; var units , i ; begin
23577: LD_INT 0
23579: PPUSH
23580: PPUSH
23581: PPUSH
// units := [ ] ;
23582: LD_ADDR_VAR 0 3
23586: PUSH
23587: EMPTY
23588: ST_TO_ADDR
// for i in list do
23589: LD_ADDR_VAR 0 4
23593: PUSH
23594: LD_VAR 0 1
23598: PUSH
23599: FOR_IN
23600: IFFALSE 23890
// begin InitUc ;
23602: CALL_OW 18
// InitHc ;
23606: CALL_OW 19
// InitVc ;
23610: CALL_OW 20
// uc_nation := nation_russian ;
23614: LD_ADDR_OWVAR 21
23618: PUSH
23619: LD_INT 3
23621: ST_TO_ADDR
// uc_side := russians ;
23622: LD_ADDR_OWVAR 20
23626: PUSH
23627: LD_EXP 49
23631: ST_TO_ADDR
// vc_control := control_computer ;
23632: LD_ADDR_OWVAR 38
23636: PUSH
23637: LD_INT 3
23639: ST_TO_ADDR
// vc_engine := engine_combustion ;
23640: LD_ADDR_OWVAR 39
23644: PUSH
23645: LD_INT 1
23647: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23648: LD_ADDR_OWVAR 41
23652: PUSH
23653: LD_INT 75
23655: ST_TO_ADDR
// case i of mhmg :
23656: LD_VAR 0 4
23660: PUSH
23661: LD_EXP 9
23665: DOUBLE
23666: EQUAL
23667: IFTRUE 23671
23669: GO 23690
23671: POP
// begin vc_chassis := ru_medium_tracked ;
23672: LD_ADDR_OWVAR 37
23676: PUSH
23677: LD_INT 22
23679: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23680: LD_ADDR_OWVAR 40
23684: PUSH
23685: LD_INT 42
23687: ST_TO_ADDR
// end ; mgg :
23688: GO 23865
23690: LD_EXP 10
23694: DOUBLE
23695: EQUAL
23696: IFTRUE 23700
23698: GO 23719
23700: POP
// begin vc_chassis := ru_medium_tracked ;
23701: LD_ADDR_OWVAR 37
23705: PUSH
23706: LD_INT 22
23708: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23709: LD_ADDR_OWVAR 40
23713: PUSH
23714: LD_INT 43
23716: ST_TO_ADDR
// end ; mg :
23717: GO 23865
23719: LD_EXP 11
23723: DOUBLE
23724: EQUAL
23725: IFTRUE 23729
23727: GO 23748
23729: POP
// begin vc_chassis := ru_medium_tracked ;
23730: LD_ADDR_OWVAR 37
23734: PUSH
23735: LD_INT 22
23737: ST_TO_ADDR
// vc_weapon := ru_gun ;
23738: LD_ADDR_OWVAR 40
23742: PUSH
23743: LD_INT 44
23745: ST_TO_ADDR
// end ; mrl :
23746: GO 23865
23748: LD_EXP 12
23752: DOUBLE
23753: EQUAL
23754: IFTRUE 23758
23756: GO 23777
23758: POP
// begin vc_chassis := ru_medium_tracked ;
23759: LD_ADDR_OWVAR 37
23763: PUSH
23764: LD_INT 22
23766: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23767: LD_ADDR_OWVAR 40
23771: PUSH
23772: LD_INT 45
23774: ST_TO_ADDR
// end ; hgg :
23775: GO 23865
23777: LD_EXP 13
23781: DOUBLE
23782: EQUAL
23783: IFTRUE 23787
23785: GO 23806
23787: POP
// begin vc_chassis := ru_heavy_tracked ;
23788: LD_ADDR_OWVAR 37
23792: PUSH
23793: LD_INT 24
23795: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23796: LD_ADDR_OWVAR 40
23800: PUSH
23801: LD_INT 43
23803: ST_TO_ADDR
// end ; hrl :
23804: GO 23865
23806: LD_EXP 14
23810: DOUBLE
23811: EQUAL
23812: IFTRUE 23816
23814: GO 23835
23816: POP
// begin vc_chassis := ru_heavy_tracked ;
23817: LD_ADDR_OWVAR 37
23821: PUSH
23822: LD_INT 24
23824: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23825: LD_ADDR_OWVAR 40
23829: PUSH
23830: LD_INT 45
23832: ST_TO_ADDR
// end ; hhg :
23833: GO 23865
23835: LD_EXP 15
23839: DOUBLE
23840: EQUAL
23841: IFTRUE 23845
23843: GO 23864
23845: POP
// begin vc_chassis := ru_heavy_tracked ;
23846: LD_ADDR_OWVAR 37
23850: PUSH
23851: LD_INT 24
23853: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23854: LD_ADDR_OWVAR 40
23858: PUSH
23859: LD_INT 46
23861: ST_TO_ADDR
// end ; end ;
23862: GO 23865
23864: POP
// units := units ^ CreateVehicle ;
23865: LD_ADDR_VAR 0 3
23869: PUSH
23870: LD_VAR 0 3
23874: PUSH
23875: CALL_OW 45
23879: ADD
23880: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23881: LD_INT 7
23883: PPUSH
23884: CALL_OW 67
// end ;
23888: GO 23599
23890: POP
23891: POP
// result := units ;
23892: LD_ADDR_VAR 0 2
23896: PUSH
23897: LD_VAR 0 3
23901: ST_TO_ADDR
// end ;
23902: LD_VAR 0 2
23906: RET
// function MyPlaceUnitArea ( un , ar , bordr ) ; var h , r ; begin
23907: LD_INT 0
23909: PPUSH
23910: PPUSH
23911: PPUSH
// case ar of rus_mat_l :
23912: LD_VAR 0 2
23916: PUSH
23917: LD_INT 3
23919: DOUBLE
23920: EQUAL
23921: IFTRUE 23925
23923: GO 23943
23925: POP
// h := [ 61 , 119 ] ; rus_mat_m :
23926: LD_ADDR_VAR 0 5
23930: PUSH
23931: LD_INT 61
23933: PUSH
23934: LD_INT 119
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: ST_TO_ADDR
23941: GO 24022
23943: LD_INT 2
23945: DOUBLE
23946: EQUAL
23947: IFTRUE 23951
23949: GO 23969
23951: POP
// h := [ 99 , 148 ] ; rus_mat_r :
23952: LD_ADDR_VAR 0 5
23956: PUSH
23957: LD_INT 99
23959: PUSH
23960: LD_INT 148
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: ST_TO_ADDR
23967: GO 24022
23969: LD_INT 15
23971: DOUBLE
23972: EQUAL
23973: IFTRUE 23977
23975: GO 23995
23977: POP
// h := [ 137 , 148 ] ; rus_mat_t :
23978: LD_ADDR_VAR 0 5
23982: PUSH
23983: LD_INT 137
23985: PUSH
23986: LD_INT 148
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: ST_TO_ADDR
23993: GO 24022
23995: LD_INT 14
23997: DOUBLE
23998: EQUAL
23999: IFTRUE 24003
24001: GO 24021
24003: POP
// h := [ 112 , 87 ] ; end ;
24004: LD_ADDR_VAR 0 5
24008: PUSH
24009: LD_INT 112
24011: PUSH
24012: LD_INT 87
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: ST_TO_ADDR
24019: GO 24022
24021: POP
// r := PlaceUnitArea ( un , ar , bordr ) ;
24022: LD_ADDR_VAR 0 6
24026: PUSH
24027: LD_VAR 0 1
24031: PPUSH
24032: LD_VAR 0 2
24036: PPUSH
24037: LD_VAR 0 3
24041: PPUSH
24042: CALL_OW 49
24046: ST_TO_ADDR
// if not r then
24047: LD_VAR 0 6
24051: NOT
24052: IFFALSE 24095
// r := PlaceUnitXYR ( un , h [ 1 ] , h [ 2 ] , 20 , bordr ) ;
24054: LD_ADDR_VAR 0 6
24058: PUSH
24059: LD_VAR 0 1
24063: PPUSH
24064: LD_VAR 0 5
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_VAR 0 5
24077: PUSH
24078: LD_INT 2
24080: ARRAY
24081: PPUSH
24082: LD_INT 20
24084: PPUSH
24085: LD_VAR 0 3
24089: PPUSH
24090: CALL_OW 50
24094: ST_TO_ADDR
// result := r ;
24095: LD_ADDR_VAR 0 4
24099: PUSH
24100: LD_VAR 0 6
24104: ST_TO_ADDR
// end ; end_of_file
24105: LD_VAR 0 4
24109: RET
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = russians then
24110: LD_VAR 0 1
24114: PPUSH
24115: CALL_OW 255
24119: PUSH
24120: LD_EXP 49
24124: EQUAL
24125: IFFALSE 24139
// ComMoveToArea ( un , before_base ) ;
24127: LD_VAR 0 1
24131: PPUSH
24132: LD_INT 23
24134: PPUSH
24135: CALL_OW 113
// end ;
24139: PPOPN 1
24141: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = russians and GetType ( un ) = unit_human then
24142: LD_VAR 0 1
24146: PPUSH
24147: CALL_OW 255
24151: PUSH
24152: LD_EXP 49
24156: EQUAL
24157: PUSH
24158: LD_VAR 0 1
24162: PPUSH
24163: CALL_OW 247
24167: PUSH
24168: LD_INT 1
24170: EQUAL
24171: AND
24172: IFFALSE 24186
// begin ComMoveToArea ( un , border ) ;
24174: LD_VAR 0 1
24178: PPUSH
24179: LD_INT 28
24181: PPUSH
24182: CALL_OW 113
// end ; end ;
24186: PPOPN 1
24188: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin end ;
24189: PPOPN 4
24191: END
// on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) then
24192: LD_VAR 0 1
24196: PPUSH
24197: LD_INT 30
24199: PUSH
24200: LD_INT 4
24202: PUSH
24203: EMPTY
24204: LIST
24205: LIST
24206: PUSH
24207: LD_INT 23
24209: PUSH
24210: LD_INT 2
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: PPUSH
24221: CALL_OW 72
24225: IFFALSE 24235
// ArmBuild := true ;
24227: LD_ADDR_EXP 71
24231: PUSH
24232: LD_INT 1
24234: ST_TO_ADDR
// if IsDead ( rudepot1 ) and IsInArea ( build , base ) and GetBType ( build ) = b_depot then
24235: LD_EXP 67
24239: PPUSH
24240: CALL_OW 301
24244: PUSH
24245: LD_VAR 0 1
24249: PPUSH
24250: LD_INT 1
24252: PPUSH
24253: CALL_OW 308
24257: AND
24258: PUSH
24259: LD_VAR 0 1
24263: PPUSH
24264: CALL_OW 266
24268: PUSH
24269: LD_INT 0
24271: EQUAL
24272: AND
24273: IFFALSE 24285
// rudepot1 := build ;
24275: LD_ADDR_EXP 67
24279: PUSH
24280: LD_VAR 0 1
24284: ST_TO_ADDR
// if IsInArea ( build , base ) and GetBType ( build ) = b_siberite_mine then
24285: LD_VAR 0 1
24289: PPUSH
24290: LD_INT 1
24292: PPUSH
24293: CALL_OW 308
24297: PUSH
24298: LD_VAR 0 1
24302: PPUSH
24303: CALL_OW 266
24307: PUSH
24308: LD_INT 30
24310: EQUAL
24311: AND
24312: IFFALSE 24324
// rumine1 := build ;
24314: LD_ADDR_EXP 68
24318: PUSH
24319: LD_VAR 0 1
24323: ST_TO_ADDR
// if IsDead ( depot1 ) and IsInArea ( build , top_half ) and GetBType ( build ) = b_depot then
24324: LD_EXP 69
24328: PPUSH
24329: CALL_OW 301
24333: PUSH
24334: LD_VAR 0 1
24338: PPUSH
24339: LD_INT 6
24341: PPUSH
24342: CALL_OW 308
24346: AND
24347: PUSH
24348: LD_VAR 0 1
24352: PPUSH
24353: CALL_OW 266
24357: PUSH
24358: LD_INT 0
24360: EQUAL
24361: AND
24362: IFFALSE 24374
// depot1 := build ;
24364: LD_ADDR_EXP 69
24368: PUSH
24369: LD_VAR 0 1
24373: ST_TO_ADDR
// if GetBType ( build ) = b_workshop then
24374: LD_VAR 0 1
24378: PPUSH
24379: CALL_OW 266
24383: PUSH
24384: LD_INT 2
24386: EQUAL
24387: IFFALSE 24396
// MyHint ( Tracks ) ;
24389: LD_STRING Tracks
24391: PPUSH
24392: CALL 14295 0 1
// end ;
24396: PPOPN 1
24398: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) then
24399: LD_VAR 0 1
24403: PPUSH
24404: LD_INT 30
24406: PUSH
24407: LD_INT 5
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: LD_INT 23
24416: PUSH
24417: LD_INT 2
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: PUSH
24424: EMPTY
24425: LIST
24426: LIST
24427: PPUSH
24428: CALL_OW 72
24432: IFFALSE 24449
// begin ArmUpgraded := true ;
24434: LD_ADDR_EXP 72
24438: PUSH
24439: LD_INT 1
24441: ST_TO_ADDR
// MyHint ( MortarMen ) ;
24442: LD_STRING MortarMen
24444: PPUSH
24445: CALL 14295 0 1
// end ; end ;
24449: PPOPN 1
24451: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibDet then
24452: LD_VAR 0 1
24456: PUSH
24457: LD_INT 20
24459: EQUAL
24460: IFFALSE 24533
// begin if SayAny ( all_units , D13-Sci1-1 , you , 0 , class_scientistic , 0 ) then
24462: LD_OWVAR 3
24466: PPUSH
24467: LD_STRING D13-Sci1-1
24469: PPUSH
24470: LD_EXP 47
24474: PPUSH
24475: LD_INT 0
24477: PPUSH
24478: LD_INT 4
24480: PPUSH
24481: LD_INT 0
24483: PPUSH
24484: CALL 13144 0 6
24488: IFFALSE 24530
// if Say ( JMM , D13-JMM-1 ) then
24490: LD_EXP 17
24494: PPUSH
24495: LD_STRING D13-JMM-1
24497: PPUSH
24498: CALL_OW 88
24502: IFFALSE 24530
// SayAny ( all_units , D13-Sci1-2 , you , 0 , class_scientistic , 0 ) ;
24504: LD_OWVAR 3
24508: PPUSH
24509: LD_STRING D13-Sci1-2
24511: PPUSH
24512: LD_EXP 47
24516: PPUSH
24517: LD_INT 0
24519: PPUSH
24520: LD_INT 4
24522: PPUSH
24523: LD_INT 0
24525: PPUSH
24526: CALL 13144 0 6
// disable ( 20 ) ;
24530: LD_INT 20
24532: DISABLE_MARKED
// end ; end ;
24533: PPOPN 2
24535: END
// on BuildingCaptured ( build , origside , eng ) do begin if not byld2a and origside = you2 then
24536: LD_EXP 73
24540: NOT
24541: PUSH
24542: LD_VAR 0 2
24546: PUSH
24547: LD_EXP 48
24551: EQUAL
24552: AND
24553: IFFALSE 24559
// dialog2a ;
24555: CALL 3484 0 0
// if EndEnable and ( build = rudepot1 ) and origside = you then
24559: LD_EXP 80
24563: PUSH
24564: LD_VAR 0 1
24568: PUSH
24569: LD_EXP 67
24573: EQUAL
24574: AND
24575: PUSH
24576: LD_VAR 0 2
24580: PUSH
24581: LD_EXP 47
24585: EQUAL
24586: AND
24587: IFFALSE 24631
// begin TimerEnable := true ;
24589: LD_ADDR_EXP 63
24593: PUSH
24594: LD_INT 1
24596: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
24597: LD_ADDR_EXP 81
24601: PUSH
24602: LD_EXP 49
24606: PPUSH
24607: CALL_OW 462
24611: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
24612: LD_EXP 67
24616: PPUSH
24617: CALL_OW 274
24621: PPUSH
24622: LD_EXP 49
24626: PPUSH
24627: CALL_OW 236
// end ; end ;
24631: PPOPN 3
24633: END
// on UnitDestroyed ( un ) do begin if un = JMM then
24634: LD_VAR 0 1
24638: PUSH
24639: LD_EXP 17
24643: EQUAL
24644: IFFALSE 24656
// begin disable ( 0 ) ;
24646: LD_INT 0
24648: DISABLE_MARKED
// YouLost ( JMM ) ;
24649: LD_STRING JMM
24651: PPUSH
24652: CALL_OW 104
// end ; end ;
24656: PPOPN 1
24658: END
// on SailEvent ( num ) do begin if ( num div 1000 ) = 1 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 1000
24666: DIV
24667: PUSH
24668: LD_INT 1
24670: EQUAL
24671: IFFALSE 24686
// rep_car ( num - 1000 ) ;
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 1000
24680: MINUS
24681: PPUSH
24682: CALL 14506 0 1
// if ( num div 1000 ) = 2 then
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 1000
24693: DIV
24694: PUSH
24695: LD_INT 2
24697: EQUAL
24698: IFFALSE 24713
// ret_car ( num - 2000 ) ;
24700: LD_VAR 0 1
24704: PUSH
24705: LD_INT 2000
24707: MINUS
24708: PPUSH
24709: CALL 14685 0 1
// case num of 1 :
24713: LD_VAR 0 1
24717: PUSH
24718: LD_INT 1
24720: DOUBLE
24721: EQUAL
24722: IFTRUE 24726
24724: GO 24759
24726: POP
// begin using1 := true ;
24727: LD_ADDR_EXP 83
24731: PUSH
24732: LD_INT 1
24734: ST_TO_ADDR
// Attack ( kdo1 , path1 ) ;
24735: LD_EXP 91
24739: PPUSH
24740: LD_EXP 87
24744: PPUSH
24745: CALL 13625 0 2
// using1 := false ;
24749: LD_ADDR_EXP 83
24753: PUSH
24754: LD_INT 0
24756: ST_TO_ADDR
// end ; 2 :
24757: GO 25054
24759: LD_INT 2
24761: DOUBLE
24762: EQUAL
24763: IFTRUE 24767
24765: GO 24800
24767: POP
// begin using2 := true ;
24768: LD_ADDR_EXP 84
24772: PUSH
24773: LD_INT 1
24775: ST_TO_ADDR
// Attack ( kdo2 , path2 ) ;
24776: LD_EXP 92
24780: PPUSH
24781: LD_EXP 88
24785: PPUSH
24786: CALL 13625 0 2
// using2 := false ;
24790: LD_ADDR_EXP 84
24794: PUSH
24795: LD_INT 0
24797: ST_TO_ADDR
// end ; 3 :
24798: GO 25054
24800: LD_INT 3
24802: DOUBLE
24803: EQUAL
24804: IFTRUE 24808
24806: GO 24841
24808: POP
// begin using3 := true ;
24809: LD_ADDR_EXP 85
24813: PUSH
24814: LD_INT 1
24816: ST_TO_ADDR
// Attack ( kdo3 , path3 ) ;
24817: LD_EXP 93
24821: PPUSH
24822: LD_EXP 89
24826: PPUSH
24827: CALL 13625 0 2
// using3 := false ;
24831: LD_ADDR_EXP 85
24835: PUSH
24836: LD_INT 0
24838: ST_TO_ADDR
// end ; 4 :
24839: GO 25054
24841: LD_INT 4
24843: DOUBLE
24844: EQUAL
24845: IFTRUE 24849
24847: GO 24882
24849: POP
// begin using4 := true ;
24850: LD_ADDR_EXP 94
24854: PUSH
24855: LD_INT 1
24857: ST_TO_ADDR
// Attack ( kdo4 , path4 ) ;
24858: LD_EXP 102
24862: PPUSH
24863: LD_EXP 98
24867: PPUSH
24868: CALL 13625 0 2
// using4 := false ;
24872: LD_ADDR_EXP 94
24876: PUSH
24877: LD_INT 0
24879: ST_TO_ADDR
// end ; 5 :
24880: GO 25054
24882: LD_INT 5
24884: DOUBLE
24885: EQUAL
24886: IFTRUE 24890
24888: GO 24923
24890: POP
// begin using5 := true ;
24891: LD_ADDR_EXP 95
24895: PUSH
24896: LD_INT 1
24898: ST_TO_ADDR
// Attack ( kdo5 , path5 ) ;
24899: LD_EXP 103
24903: PPUSH
24904: LD_EXP 99
24908: PPUSH
24909: CALL 13625 0 2
// using5 := false ;
24913: LD_ADDR_EXP 95
24917: PUSH
24918: LD_INT 0
24920: ST_TO_ADDR
// end ; 6 :
24921: GO 25054
24923: LD_INT 6
24925: DOUBLE
24926: EQUAL
24927: IFTRUE 24931
24929: GO 24964
24931: POP
// begin using6 := true ;
24932: LD_ADDR_EXP 96
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// Attack ( kdo6 , path6 ) ;
24940: LD_EXP 104
24944: PPUSH
24945: LD_EXP 100
24949: PPUSH
24950: CALL 13625 0 2
// using6 := false ;
24954: LD_ADDR_EXP 96
24958: PUSH
24959: LD_INT 0
24961: ST_TO_ADDR
// end ; 7 :
24962: GO 25054
24964: LD_INT 7
24966: DOUBLE
24967: EQUAL
24968: IFTRUE 24972
24970: GO 25005
24972: POP
// begin using7 := true ;
24973: LD_ADDR_EXP 97
24977: PUSH
24978: LD_INT 1
24980: ST_TO_ADDR
// Attack ( kdo7 , path7 ) ;
24981: LD_EXP 105
24985: PPUSH
24986: LD_EXP 101
24990: PPUSH
24991: CALL 13625 0 2
// using7 := false ;
24995: LD_ADDR_EXP 97
24999: PUSH
25000: LD_INT 0
25002: ST_TO_ADDR
// end ; 8 :
25003: GO 25054
25005: LD_INT 8
25007: DOUBLE
25008: EQUAL
25009: IFTRUE 25013
25011: GO 25046
25013: POP
// begin using8 := true ;
25014: LD_ADDR_EXP 82
25018: PUSH
25019: LD_INT 1
25021: ST_TO_ADDR
// Attack ( kdo8 , path8 ) ;
25022: LD_EXP 90
25026: PPUSH
25027: LD_EXP 86
25031: PPUSH
25032: CALL 13625 0 2
// using8 := false ;
25036: LD_ADDR_EXP 82
25040: PUSH
25041: LD_INT 0
25043: ST_TO_ADDR
// end ; else
25044: GO 25054
25046: POP
// Msg ( neni thread na utok ) ; end ;
25047: LD_STRING neni thread na utok
25049: PPUSH
25050: CALL_OW 100
// end ;
25054: PPOPN 1
25056: END
// on BuildingStarted ( b , hum ) do begin if hum = ara2 then
25057: LD_VAR 0 2
25061: PUSH
25062: LD_EXP 40
25066: EQUAL
25067: IFFALSE 25092
// if GetBType ( b ) = b_armoury then
25069: LD_VAR 0 1
25073: PPUSH
25074: CALL_OW 266
25078: PUSH
25079: LD_INT 4
25081: EQUAL
25082: IFFALSE 25092
// ArmStarted := true ;
25084: LD_ADDR_EXP 74
25088: PUSH
25089: LD_INT 1
25091: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
25092: LD_VAR 0 1
25096: PPUSH
25097: CALL_OW 266
25101: PUSH
25102: LD_INT 4
25104: EQUAL
25105: IFFALSE 25115
// BarStarted := true ;
25107: LD_ADDR_EXP 75
25111: PUSH
25112: LD_INT 1
25114: ST_TO_ADDR
// end ;
25115: PPOPN 2
25117: END
// on EndTheMissionRaised ( a ) do begin Vyhra ;
25118: CALL 2869 0 0
// end ; end_of_file
25122: PPOPN 1
25124: END
// var objevovani_zasilek ; every 0 0$0.1 do
25125: GO 25127
25127: DISABLE
// begin objevovani_zasilek := [ 1 , 0 , 2 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] ;
25128: LD_ADDR_LOC 3
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: LD_INT 2
25141: PUSH
25142: LD_INT 0
25144: PUSH
25145: LD_INT 1
25147: PUSH
25148: LD_INT 0
25150: PUSH
25151: LD_INT 0
25153: PUSH
25154: LD_INT 1
25156: PUSH
25157: LD_INT 0
25159: PUSH
25160: LD_INT 0
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: LIST
25167: LIST
25168: LIST
25169: LIST
25170: LIST
25171: LIST
25172: LIST
25173: LIST
25174: ST_TO_ADDR
// Randomize ;
25175: CALL_OW 10
// end ;
25179: END
// every 0 0$10 do
25180: GO 25182
25182: DISABLE
// begin Randomize ;
25183: CALL_OW 10
// enable ;
25187: ENABLE
// end ;
25188: END
// every 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25189: GO 25191
25191: DISABLE
25192: LD_INT 0
25194: PPUSH
25195: PPUSH
25196: PPUSH
25197: PPUSH
25198: PPUSH
25199: PPUSH
25200: PPUSH
25201: PPUSH
// begin min5 := 1 ;
25202: LD_ADDR_VAR 0 8
25206: PUSH
25207: LD_INT 1
25209: ST_TO_ADDR
// cek := [ ] ;
25210: LD_ADDR_VAR 0 5
25214: PUSH
25215: EMPTY
25216: ST_TO_ADDR
// cek2 := [ ] ;
25217: LD_ADDR_VAR 0 6
25221: PUSH
25222: EMPTY
25223: ST_TO_ADDR
// last := 0 ;
25224: LD_ADDR_VAR 0 7
25228: PUSH
25229: LD_INT 0
25231: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25232: LD_ADDR_VAR 0 1
25236: PUSH
25237: LD_LOC 3
25241: PUSH
25242: LD_VAR 0 8
25246: ARRAY
25247: ST_TO_ADDR
// for i := 1 to x do
25248: LD_ADDR_VAR 0 3
25252: PUSH
25253: DOUBLE
25254: LD_INT 1
25256: DEC
25257: ST_TO_ADDR
25258: LD_VAR 0 1
25262: PUSH
25263: FOR_TO
25264: IFFALSE 25290
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25266: LD_ADDR_VAR 0 5
25270: PUSH
25271: LD_VAR 0 5
25275: PUSH
25276: LD_INT 525
25278: PPUSH
25279: LD_INT 10500
25281: PPUSH
25282: CALL_OW 12
25286: ADD
25287: ST_TO_ADDR
25288: GO 25263
25290: POP
25291: POP
// cek := SortListByListAsc ( cek , cek ) ;
25292: LD_ADDR_VAR 0 5
25296: PUSH
25297: LD_VAR 0 5
25301: PPUSH
25302: LD_VAR 0 5
25306: PPUSH
25307: CALL_OW 76
25311: ST_TO_ADDR
// for i in cek do
25312: LD_ADDR_VAR 0 3
25316: PUSH
25317: LD_VAR 0 5
25321: PUSH
25322: FOR_IN
25323: IFFALSE 25359
// begin cek2 := cek2 ^ i - last ;
25325: LD_ADDR_VAR 0 6
25329: PUSH
25330: LD_VAR 0 6
25334: PUSH
25335: LD_VAR 0 3
25339: PUSH
25340: LD_VAR 0 7
25344: MINUS
25345: ADD
25346: ST_TO_ADDR
// last := i ;
25347: LD_ADDR_VAR 0 7
25351: PUSH
25352: LD_VAR 0 3
25356: ST_TO_ADDR
// end ;
25357: GO 25322
25359: POP
25360: POP
// for i := 1 to x do
25361: LD_ADDR_VAR 0 3
25365: PUSH
25366: DOUBLE
25367: LD_INT 1
25369: DEC
25370: ST_TO_ADDR
25371: LD_VAR 0 1
25375: PUSH
25376: FOR_TO
25377: IFFALSE 25406
// begin CreateCratesAnywhere ( 5 , true ) ;
25379: LD_INT 5
25381: PPUSH
25382: LD_INT 1
25384: PPUSH
25385: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25389: LD_VAR 0 6
25393: PUSH
25394: LD_VAR 0 3
25398: ARRAY
25399: PPUSH
25400: CALL_OW 67
// end ;
25404: GO 25376
25406: POP
25407: POP
// end ;
25408: PPOPN 8
25410: END
// every 5 5$0 + 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25411: GO 25413
25413: DISABLE
25414: LD_INT 0
25416: PPUSH
25417: PPUSH
25418: PPUSH
25419: PPUSH
25420: PPUSH
25421: PPUSH
25422: PPUSH
25423: PPUSH
// begin min5 := tick div 5 5$0 ;
25424: LD_ADDR_VAR 0 8
25428: PUSH
25429: LD_OWVAR 1
25433: PUSH
25434: LD_INT 10500
25436: DIV
25437: ST_TO_ADDR
// cek := [ ] ;
25438: LD_ADDR_VAR 0 5
25442: PUSH
25443: EMPTY
25444: ST_TO_ADDR
// cek2 := [ ] ;
25445: LD_ADDR_VAR 0 6
25449: PUSH
25450: EMPTY
25451: ST_TO_ADDR
// last := 0 ;
25452: LD_ADDR_VAR 0 7
25456: PUSH
25457: LD_INT 0
25459: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25460: LD_ADDR_VAR 0 1
25464: PUSH
25465: LD_LOC 3
25469: PUSH
25470: LD_VAR 0 8
25474: ARRAY
25475: ST_TO_ADDR
// for i := 1 to x do
25476: LD_ADDR_VAR 0 3
25480: PUSH
25481: DOUBLE
25482: LD_INT 1
25484: DEC
25485: ST_TO_ADDR
25486: LD_VAR 0 1
25490: PUSH
25491: FOR_TO
25492: IFFALSE 25518
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25494: LD_ADDR_VAR 0 5
25498: PUSH
25499: LD_VAR 0 5
25503: PUSH
25504: LD_INT 525
25506: PPUSH
25507: LD_INT 10500
25509: PPUSH
25510: CALL_OW 12
25514: ADD
25515: ST_TO_ADDR
25516: GO 25491
25518: POP
25519: POP
// cek := SortListByListAsc ( cek , cek ) ;
25520: LD_ADDR_VAR 0 5
25524: PUSH
25525: LD_VAR 0 5
25529: PPUSH
25530: LD_VAR 0 5
25534: PPUSH
25535: CALL_OW 76
25539: ST_TO_ADDR
// for i in cek do
25540: LD_ADDR_VAR 0 3
25544: PUSH
25545: LD_VAR 0 5
25549: PUSH
25550: FOR_IN
25551: IFFALSE 25587
// begin cek2 := cek2 ^ i - last ;
25553: LD_ADDR_VAR 0 6
25557: PUSH
25558: LD_VAR 0 6
25562: PUSH
25563: LD_VAR 0 3
25567: PUSH
25568: LD_VAR 0 7
25572: MINUS
25573: ADD
25574: ST_TO_ADDR
// last := i ;
25575: LD_ADDR_VAR 0 7
25579: PUSH
25580: LD_VAR 0 3
25584: ST_TO_ADDR
// end ;
25585: GO 25550
25587: POP
25588: POP
// for i := 1 to x do
25589: LD_ADDR_VAR 0 3
25593: PUSH
25594: DOUBLE
25595: LD_INT 1
25597: DEC
25598: ST_TO_ADDR
25599: LD_VAR 0 1
25603: PUSH
25604: FOR_TO
25605: IFFALSE 25634
// begin CreateCratesAnywhere ( 5 , true ) ;
25607: LD_INT 5
25609: PPUSH
25610: LD_INT 1
25612: PPUSH
25613: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25617: LD_VAR 0 6
25621: PUSH
25622: LD_VAR 0 3
25626: ARRAY
25627: PPUSH
25628: CALL_OW 67
// end ;
25632: GO 25604
25634: POP
25635: POP
// if min5 < 10 then
25636: LD_VAR 0 8
25640: PUSH
25641: LD_INT 10
25643: LESS
25644: IFFALSE 25647
// enable ;
25646: ENABLE
// end ; end_of_file
25647: PPOPN 8
25649: END
// every 0 0$2 + 0 0$0.1 do
25650: GO 25652
25652: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25653: LD_INT 22
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: LD_INT 25
25668: PUSH
25669: LD_INT 12
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 25
25678: PUSH
25679: LD_INT 16
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 25
25688: PUSH
25689: LD_INT 15
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 25
25698: PUSH
25699: LD_INT 17
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: PPUSH
25717: CALL_OW 69
25721: PUSH
25722: LD_INT 22
25724: PUSH
25725: LD_INT 1
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 21
25734: PUSH
25735: LD_INT 1
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 3
25744: PUSH
25745: LD_INT 2
25747: PUSH
25748: LD_INT 25
25750: PUSH
25751: LD_INT 12
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: PUSH
25758: LD_INT 25
25760: PUSH
25761: LD_INT 16
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 25
25770: PUSH
25771: LD_INT 15
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: LD_INT 25
25780: PUSH
25781: LD_INT 17
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: LIST
25792: LIST
25793: LIST
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: PPUSH
25804: CALL_OW 69
25808: GREATER
25809: IFFALSE 25820
// begin SetAchievement ( ACH_POTA ) ;
25811: LD_STRING ACH_POTA
25813: PPUSH
25814: CALL_OW 543
// exit ;
25818: GO 25821
// end ; enable ;
25820: ENABLE
// end ;
25821: END
// export function SA_CollectedSibInTerminal ; begin
25822: LD_INT 0
25824: PPUSH
// SetAchievement ( ACH_MGT ) ;
25825: LD_STRING ACH_MGT
25827: PPUSH
25828: CALL_OW 543
// end ; end_of_file
25832: LD_VAR 0 1
25836: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
25837: LD_INT 0
25839: PPUSH
25840: PPUSH
// if not missionNumber then
25841: LD_VAR 0 2
25845: NOT
25846: IFFALSE 25850
// exit ;
25848: GO 25980
// achiv := false ;
25850: LD_ADDR_VAR 0 7
25854: PUSH
25855: LD_INT 0
25857: ST_TO_ADDR
// case campaignNumber of 1 :
25858: LD_VAR 0 1
25862: PUSH
25863: LD_INT 1
25865: DOUBLE
25866: EQUAL
25867: IFTRUE 25871
25869: GO 25882
25871: POP
// achiv := ACH_GOTA ; 2 :
25872: LD_ADDR_VAR 0 7
25876: PUSH
25877: LD_STRING ACH_GOTA
25879: ST_TO_ADDR
25880: GO 25932
25882: LD_INT 2
25884: DOUBLE
25885: EQUAL
25886: IFTRUE 25890
25888: GO 25893
25890: POP
// ; 3 :
25891: GO 25932
25893: LD_INT 3
25895: DOUBLE
25896: EQUAL
25897: IFTRUE 25901
25899: GO 25912
25901: POP
// achiv := ACH_MOTSU ; 4 :
25902: LD_ADDR_VAR 0 7
25906: PUSH
25907: LD_STRING ACH_MOTSU
25909: ST_TO_ADDR
25910: GO 25932
25912: LD_INT 4
25914: DOUBLE
25915: EQUAL
25916: IFTRUE 25920
25918: GO 25931
25920: POP
// achiv := ACH_LOP ; end ;
25921: LD_ADDR_VAR 0 7
25925: PUSH
25926: LD_STRING ACH_LOP
25928: ST_TO_ADDR
25929: GO 25932
25931: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
25932: LD_OWVAR 67
25936: PUSH
25937: LD_INT 3
25939: EQUAL
25940: PUSH
25941: LD_VAR 0 7
25945: AND
25946: PUSH
25947: LD_VAR 0 3
25951: AND
25952: PUSH
25953: LD_VAR 0 4
25957: AND
25958: PUSH
25959: LD_VAR 0 5
25963: AND
25964: IFFALSE 25980
// SetAchievementEX ( achiv , missionNumber ) ;
25966: LD_VAR 0 7
25970: PPUSH
25971: LD_VAR 0 2
25975: PPUSH
25976: CALL_OW 564
// end ;
25980: LD_VAR 0 6
25984: RET
// export function SA_BehemothConstructed ; begin
25985: LD_INT 0
25987: PPUSH
// SetAchievement ( ACH_SMC ) ;
25988: LD_STRING ACH_SMC
25990: PPUSH
25991: CALL_OW 543
// end ;
25995: LD_VAR 0 1
25999: RET

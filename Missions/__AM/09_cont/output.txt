// export arabi_time ; export utocit ; export last_attack ; export testing ; export lev ; export rusaci_pred_koncem ; function f_testing ; begin
   0: LD_INT 0
   2: PPUSH
// utocit := true ;
   3: LD_ADDR_EXP 2
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// last_attack := true ;
  11: LD_ADDR_EXP 3
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabi_time := 0 ;
  19: LD_ADDR_EXP 1
  23: PUSH
  24: LD_INT 0
  26: ST_TO_ADDR
// testing := false ;
  27: LD_ADDR_EXP 4
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// timer := 3 3$0 ;
  35: LD_ADDR_EXP 62
  39: PUSH
  40: LD_INT 6300
  42: ST_TO_ADDR
// rusaci_pred_koncem := 0 0$20 ;
  43: LD_ADDR_EXP 6
  47: PUSH
  48: LD_INT 700
  50: ST_TO_ADDR
// if not utocit or not last_attack or arabi_time <> 0 then
  51: LD_EXP 2
  55: NOT
  56: PUSH
  57: LD_EXP 3
  61: NOT
  62: OR
  63: PUSH
  64: LD_EXP 1
  68: PUSH
  69: LD_INT 0
  71: NONEQUAL
  72: OR
  73: IFFALSE 90
// begin Msg ( testing version ) ;
  75: LD_STRING testing version
  77: PPUSH
  78: CALL_OW 100
// testing := true ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_INT 1
  89: ST_TO_ADDR
// end ; end ;
  90: LD_VAR 0 1
  94: RET
// every 2 2$0 do
  95: GO 97
  97: DISABLE
// begin end ;
  98: END
// export map_size_x , map_size_y ; export mhmg , mgg , mg , mrl , hgg , hrl , hhg ; export Powell , JMM , Bobby , Cyrus , Donaldson , Brown , Gary ; export FSol1 , Sol1 , Sci1 ; export Eng1 , Eng2 , Eng3 , Eng4 , CarE1 ; export Mec1 , Mec2 , Mec3 , Car1 , Car2 , Car3 ; export Aqr1 , Aqr2 ; export Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 , arabi ; export you , you2 , russians , arabians ; export otherG2 , other_survivors ; export SikorskiDiedIn8 ; export ByloSiberitu ; export EndSiberit ; export PoskytnouInformace ; export NastvalPowella ; export lidi , lidi_base , lidi_eng ; export neco_rikaji ; export timer , TimerEnable ; export counter_time ; export dialog2byl ; export KolikMaBytSiberitu ; export rudepot1 , rumine1 , depot1 ; function load_units_2 ; var kolik , m , n , i , all , k , placing , o ; begin
  99: LD_INT 0
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// InitUc ;
 110: CALL_OW 18
// InitHc ;
 114: CALL_OW 19
// InitVc ;
 118: CALL_OW 20
// kolik := 0 ;
 122: LD_ADDR_VAR 0 2
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// Donaldson := 0 ;
 130: LD_ADDR_EXP 20
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// Brown := 0 ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// Bobby := 0 ;
 146: LD_ADDR_EXP 18
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// Cyrus := 0 ;
 154: LD_ADDR_EXP 19
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// uc_side := you ;
 162: LD_ADDR_OWVAR 20
 166: PUSH
 167: LD_EXP 47
 171: ST_TO_ADDR
// uc_nation := nation_american ;
 172: LD_ADDR_OWVAR 21
 176: PUSH
 177: LD_INT 1
 179: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_STRING JMM
 187: PPUSH
 188: CALL_OW 34
 192: ST_TO_ADDR
// SetClass ( JMM , class_soldier ) ;
 193: LD_EXP 17
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 336
// Powell := NewCharacter ( Powell ) ;
 205: LD_ADDR_EXP 16
 209: PUSH
 210: LD_STRING Powell
 212: PPUSH
 213: CALL_OW 25
 217: ST_TO_ADDR
// uc_side := you2 ;
 218: LD_ADDR_OWVAR 20
 222: PUSH
 223: LD_EXP 48
 227: ST_TO_ADDR
// uc_nation := nation_american ;
 228: LD_ADDR_OWVAR 21
 232: PUSH
 233: LD_INT 1
 235: ST_TO_ADDR
// all := [ ] ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: EMPTY
 242: ST_TO_ADDR
// Gary := NewCharacter ( Gary ) ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_STRING Gary
 250: PPUSH
 251: CALL_OW 25
 255: ST_TO_ADDR
// all := all ^ [ Gary ] ;
 256: LD_ADDR_VAR 0 6
 260: PUSH
 261: LD_VAR 0 6
 265: PUSH
 266: LD_EXP 22
 270: PUSH
 271: EMPTY
 272: LIST
 273: ADD
 274: ST_TO_ADDR
// Cyrus := 0 ;
 275: LD_ADDR_EXP 19
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 283: LD_STRING Cyrus
 285: PPUSH
 286: CALL_OW 29
 290: IFFALSE 366
// if LoadVariable ( CyrusLoc , 1 ) = 1 then
 292: LD_STRING CyrusLoc
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: CALL_OW 30
 302: PUSH
 303: LD_INT 1
 305: EQUAL
 306: IFFALSE 366
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 308: LD_ADDR_EXP 19
 312: PUSH
 313: LD_STRING Cyrus
 315: PPUSH
 316: CALL_OW 34
 320: ST_TO_ADDR
// SetClass ( Cyrus , class_soldier ) ;
 321: LD_EXP 19
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 336
// all := all ^ [ Cyrus ] ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_VAR 0 6
 342: PUSH
 343: LD_EXP 19
 347: PUSH
 348: EMPTY
 349: LIST
 350: ADD
 351: ST_TO_ADDR
// kolik := kolik + 1 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 1
 364: PLUS
 365: ST_TO_ADDR
// end ; Bobby := 0 ;
 366: LD_ADDR_EXP 18
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 374: LD_STRING Bobby
 376: PPUSH
 377: CALL_OW 29
 381: IFFALSE 457
// if LoadVariable ( BobbyLoc , 1 ) = 1 then
 383: LD_STRING BobbyLoc
 385: PPUSH
 386: LD_INT 1
 388: PPUSH
 389: CALL_OW 30
 393: PUSH
 394: LD_INT 1
 396: EQUAL
 397: IFFALSE 457
// begin Bobby := CreateCharacter ( Bobby ) ;
 399: LD_ADDR_EXP 18
 403: PUSH
 404: LD_STRING Bobby
 406: PPUSH
 407: CALL_OW 34
 411: ST_TO_ADDR
// SetClass ( Bobby , class_soldier ) ;
 412: LD_EXP 18
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL_OW 336
// all := all ^ [ Bobby ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 6
 433: PUSH
 434: LD_EXP 18
 438: PUSH
 439: EMPTY
 440: LIST
 441: ADD
 442: ST_TO_ADDR
// kolik := kolik + 1 ;
 443: LD_ADDR_VAR 0 2
 447: PUSH
 448: LD_VAR 0 2
 452: PUSH
 453: LD_INT 1
 455: PLUS
 456: ST_TO_ADDR
// end ; Donaldson := 0 ;
 457: LD_ADDR_EXP 20
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 465: LD_STRING Donaldson
 467: PPUSH
 468: CALL_OW 29
 472: IFFALSE 536
// if LoadVariable ( DonaldsonLoc , 0 ) = 1 then
 474: LD_STRING DonaldsonLoc
 476: PPUSH
 477: LD_INT 0
 479: PPUSH
 480: CALL_OW 30
 484: PUSH
 485: LD_INT 1
 487: EQUAL
 488: IFFALSE 536
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 490: LD_ADDR_EXP 20
 494: PUSH
 495: LD_STRING Donaldson
 497: PPUSH
 498: CALL_OW 34
 502: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 503: LD_ADDR_VAR 0 6
 507: PUSH
 508: LD_VAR 0 6
 512: PUSH
 513: LD_EXP 20
 517: PUSH
 518: EMPTY
 519: LIST
 520: ADD
 521: ST_TO_ADDR
// kolik := kolik + 1 ;
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: LD_VAR 0 2
 531: PUSH
 532: LD_INT 1
 534: PLUS
 535: ST_TO_ADDR
// end ; Brown := 0 ;
 536: LD_ADDR_EXP 21
 540: PUSH
 541: LD_INT 0
 543: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 544: LD_STRING Brown
 546: PPUSH
 547: CALL_OW 29
 551: IFFALSE 625
// if kolik < 3 and LoadVariable ( BrownLoc , 0 ) = 1 then
 553: LD_VAR 0 2
 557: PUSH
 558: LD_INT 3
 560: LESS
 561: PUSH
 562: LD_STRING BrownLoc
 564: PPUSH
 565: LD_INT 0
 567: PPUSH
 568: CALL_OW 30
 572: PUSH
 573: LD_INT 1
 575: EQUAL
 576: AND
 577: IFFALSE 625
// begin Brown := CreateCharacter ( Brown ) ;
 579: LD_ADDR_EXP 21
 583: PUSH
 584: LD_STRING Brown
 586: PPUSH
 587: CALL_OW 34
 591: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 592: LD_ADDR_VAR 0 6
 596: PUSH
 597: LD_VAR 0 6
 601: PUSH
 602: LD_EXP 21
 606: PUSH
 607: EMPTY
 608: LIST
 609: ADD
 610: ST_TO_ADDR
// kolik := kolik + 1 ;
 611: LD_ADDR_VAR 0 2
 615: PUSH
 616: LD_VAR 0 2
 620: PUSH
 621: LD_INT 1
 623: PLUS
 624: ST_TO_ADDR
// end ; neco_rikaji := [ JMM , Gary , Cyrus , Bobby ] diff 0 ;
 625: LD_ADDR_EXP 61
 629: PUSH
 630: LD_EXP 17
 634: PUSH
 635: LD_EXP 22
 639: PUSH
 640: LD_EXP 19
 644: PUSH
 645: LD_EXP 18
 649: PUSH
 650: EMPTY
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PUSH
 656: LD_INT 0
 658: DIFF
 659: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 660: LD_STRING other_survivors
 662: PPUSH
 663: CALL_OW 28
 667: IFFALSE 682
// other_survivors := CreateCharacterSet ( other_survivors ) ;
 669: LD_ADDR_EXP 52
 673: PUSH
 674: LD_STRING other_survivors
 676: PPUSH
 677: CALL_OW 31
 681: ST_TO_ADDR
// for i := ( all + 0 ) to 6 do
 682: LD_ADDR_VAR 0 5
 686: PUSH
 687: DOUBLE
 688: LD_VAR 0 6
 692: PUSH
 693: LD_INT 0
 695: PLUS
 696: DEC
 697: ST_TO_ADDR
 698: LD_INT 6
 700: PUSH
 701: FOR_TO
 702: IFFALSE 752
// begin if other_survivors then
 704: LD_EXP 52
 708: IFFALSE 750
// begin all := all ^ other_survivors [ 1 ] ;
 710: LD_ADDR_VAR 0 6
 714: PUSH
 715: LD_VAR 0 6
 719: PUSH
 720: LD_EXP 52
 724: PUSH
 725: LD_INT 1
 727: ARRAY
 728: ADD
 729: ST_TO_ADDR
// other_survivors := other_survivors diff other_survivors [ 1 ] ;
 730: LD_ADDR_EXP 52
 734: PUSH
 735: LD_EXP 52
 739: PUSH
 740: LD_EXP 52
 744: PUSH
 745: LD_INT 1
 747: ARRAY
 748: DIFF
 749: ST_TO_ADDR
// end ; end ;
 750: GO 701
 752: POP
 753: POP
// for i := ( all + 0 ) to 6 do
 754: LD_ADDR_VAR 0 5
 758: PUSH
 759: DOUBLE
 760: LD_VAR 0 6
 764: PUSH
 765: LD_INT 0
 767: PLUS
 768: DEC
 769: ST_TO_ADDR
 770: LD_INT 6
 772: PUSH
 773: FOR_TO
 774: IFFALSE 804
// begin PrepareSoldier ( 0 , 5 ) ;
 776: LD_INT 0
 778: PPUSH
 779: LD_INT 5
 781: PPUSH
 782: CALL_OW 381
// all := all ^ CreateHuman ;
 786: LD_ADDR_VAR 0 6
 790: PUSH
 791: LD_VAR 0 6
 795: PUSH
 796: CALL_OW 44
 800: ADD
 801: ST_TO_ADDR
// end ;
 802: GO 773
 804: POP
 805: POP
// PrepareScientist ( sex_male , 5 ) ;
 806: LD_INT 1
 808: PPUSH
 809: LD_INT 5
 811: PPUSH
 812: CALL_OW 384
// Sci1 := CreateHuman ;
 816: LD_ADDR_EXP 25
 820: PUSH
 821: CALL_OW 44
 825: ST_TO_ADDR
// all := all ^ Sci1 ;
 826: LD_ADDR_VAR 0 6
 830: PUSH
 831: LD_VAR 0 6
 835: PUSH
 836: LD_EXP 25
 840: ADD
 841: ST_TO_ADDR
// placing := [ [ 93 , 87 ] , [ 96 , 95 ] , [ 90 , 94 ] ] ;
 842: LD_ADDR_VAR 0 8
 846: PUSH
 847: LD_INT 93
 849: PUSH
 850: LD_INT 87
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: PUSH
 857: LD_INT 96
 859: PUSH
 860: LD_INT 95
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PUSH
 867: LD_INT 90
 869: PUSH
 870: LD_INT 94
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: ST_TO_ADDR
// for k in all do
 882: LD_ADDR_VAR 0 7
 886: PUSH
 887: LD_VAR 0 6
 891: PUSH
 892: FOR_IN
 893: IFFALSE 996
// begin o := Rand ( 1 , 3 ) ;
 895: LD_ADDR_VAR 0 9
 899: PUSH
 900: LD_INT 1
 902: PPUSH
 903: LD_INT 3
 905: PPUSH
 906: CALL_OW 12
 910: ST_TO_ADDR
// if GetClass ( k ) = classtype_scientist then
 911: LD_VAR 0 7
 915: PPUSH
 916: CALL_OW 257
 920: PUSH
 921: LD_INT 4
 923: EQUAL
 924: IFFALSE 949
// PlaceUnitXYR ( k , 89 , 84 , 3 , false ) else
 926: LD_VAR 0 7
 930: PPUSH
 931: LD_INT 89
 933: PPUSH
 934: LD_INT 84
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 0
 942: PPUSH
 943: CALL_OW 50
 947: GO 994
// PlaceUnitXYR ( k , placing [ o ] [ 1 ] , placing [ o ] [ 2 ] , 5 , false ) ;
 949: LD_VAR 0 7
 953: PPUSH
 954: LD_VAR 0 8
 958: PUSH
 959: LD_VAR 0 9
 963: ARRAY
 964: PUSH
 965: LD_INT 1
 967: ARRAY
 968: PPUSH
 969: LD_VAR 0 8
 973: PUSH
 974: LD_VAR 0 9
 978: ARRAY
 979: PUSH
 980: LD_INT 2
 982: ARRAY
 983: PPUSH
 984: LD_INT 5
 986: PPUSH
 987: LD_INT 0
 989: PPUSH
 990: CALL_OW 50
// end ;
 994: GO 892
 996: POP
 997: POP
// full_forts ( [ fort1 , fort2 , fort3 ] , UnitFilter ( all , [ [ f_class , class_soldier ] ] ) ) ;
 998: LD_INT 21
1000: PUSH
1001: LD_INT 28
1003: PUSH
1004: LD_INT 86
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: LIST
1011: PPUSH
1012: LD_VAR 0 6
1016: PPUSH
1017: LD_INT 25
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL_OW 72
1034: PPUSH
1035: CALL 12614 0 2
// lidi_base := all ;
1039: LD_ADDR_EXP 59
1043: PUSH
1044: LD_VAR 0 6
1048: ST_TO_ADDR
// lidi := lidi union lidi_base ;
1049: LD_ADDR_EXP 58
1053: PUSH
1054: LD_EXP 58
1058: PUSH
1059: LD_EXP 59
1063: UNION
1064: ST_TO_ADDR
// lidi := lidi ^ JMM ;
1065: LD_ADDR_EXP 58
1069: PUSH
1070: LD_EXP 58
1074: PUSH
1075: LD_EXP 17
1079: ADD
1080: ST_TO_ADDR
// DeleteVariable ( Delta ) ;
1081: LD_STRING Delta
1083: PPUSH
1084: CALL_OW 41
// DeleteCharacters ( Sikorski ) ;
1088: LD_STRING Sikorski
1090: PPUSH
1091: CALL_OW 40
// end ;
1095: LD_VAR 0 1
1099: RET
// function SetDifficulty ; begin
1100: LD_INT 0
1102: PPUSH
// KolikMaBytSiberitu := 60 ;
1103: LD_ADDR_EXP 66
1107: PUSH
1108: LD_INT 60
1110: ST_TO_ADDR
// EndSiberit := [ 150 , 200 , 250 ] [ difficulty ] ;
1111: LD_ADDR_EXP 55
1115: PUSH
1116: LD_INT 150
1118: PUSH
1119: LD_INT 200
1121: PUSH
1122: LD_INT 250
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_OWVAR 67
1134: ARRAY
1135: ST_TO_ADDR
// lev := [ 3 , 5 , 7 ] ;
1136: LD_ADDR_EXP 5
1140: PUSH
1141: LD_INT 3
1143: PUSH
1144: LD_INT 5
1146: PUSH
1147: LD_INT 7
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: ST_TO_ADDR
// end ;
1155: LD_VAR 0 1
1159: RET
// function prepare_your_units ; var i , j ; begin
1160: LD_INT 0
1162: PPUSH
1163: PPUSH
1164: PPUSH
// InitUc ;
1165: CALL_OW 18
// InitHc ;
1169: CALL_OW 19
// uc_side := you2 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_EXP 48
1182: ST_TO_ADDR
// uc_nation := nation_american ;
1183: LD_ADDR_OWVAR 21
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1191: LD_INT 0
1193: PPUSH
1194: LD_INT 4
1196: PPUSH
1197: CALL_OW 382
// Eng1 := CreateHuman ;
1201: LD_ADDR_EXP 26
1205: PUSH
1206: CALL_OW 44
1210: ST_TO_ADDR
// PrepareEngineer ( 0 , 5 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 5
1216: PPUSH
1217: CALL_OW 382
// Eng2 := CreateHuman ;
1221: LD_ADDR_EXP 27
1225: PUSH
1226: CALL_OW 44
1230: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 4
1236: PPUSH
1237: CALL_OW 382
// Eng3 := CreateHuman ;
1241: LD_ADDR_EXP 28
1245: PUSH
1246: CALL_OW 44
1250: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1251: LD_INT 0
1253: PPUSH
1254: LD_INT 4
1256: PPUSH
1257: CALL_OW 382
// Eng4 := CreateHuman ;
1261: LD_ADDR_EXP 29
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1271: LD_ADDR_OWVAR 37
1275: PUSH
1276: LD_INT 2
1278: ST_TO_ADDR
// vc_control := control_manual ;
1279: LD_ADDR_OWVAR 38
1283: PUSH
1284: LD_INT 1
1286: ST_TO_ADDR
// vc_engine := engine_solar ;
1287: LD_ADDR_OWVAR 39
1291: PUSH
1292: LD_INT 2
1294: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1295: LD_ADDR_OWVAR 40
1299: PUSH
1300: LD_INT 12
1302: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1303: LD_ADDR_OWVAR 41
1307: PUSH
1308: LD_INT 60
1310: ST_TO_ADDR
// CarE1 := CreateVehicle ;
1311: LD_ADDR_EXP 30
1315: PUSH
1316: CALL_OW 45
1320: ST_TO_ADDR
// lidi_eng := [ Eng1 , Eng2 , Eng3 ] ;
1321: LD_ADDR_EXP 60
1325: PUSH
1326: LD_EXP 26
1330: PUSH
1331: LD_EXP 27
1335: PUSH
1336: LD_EXP 28
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: ST_TO_ADDR
// lidi := lidi union lidi_eng ;
1346: LD_ADDR_EXP 58
1350: PUSH
1351: LD_EXP 58
1355: PUSH
1356: LD_EXP 60
1360: UNION
1361: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1362: LD_INT 0
1364: PPUSH
1365: LD_INT 4
1367: PPUSH
1368: CALL_OW 383
// Mec1 := CreateHuman ;
1372: LD_ADDR_EXP 31
1376: PUSH
1377: CALL_OW 44
1381: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1382: LD_INT 0
1384: PPUSH
1385: LD_INT 4
1387: PPUSH
1388: CALL_OW 383
// Mec2 := CreateHuman ;
1392: LD_ADDR_EXP 32
1396: PUSH
1397: CALL_OW 44
1401: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1402: LD_INT 0
1404: PPUSH
1405: LD_INT 4
1407: PPUSH
1408: CALL_OW 383
// Mec3 := CreateHuman ;
1412: LD_ADDR_EXP 33
1416: PUSH
1417: CALL_OW 44
1421: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1422: LD_ADDR_OWVAR 37
1426: PUSH
1427: LD_INT 2
1429: ST_TO_ADDR
// vc_control := control_manual ;
1430: LD_ADDR_OWVAR 38
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// vc_engine := engine_solar ;
1438: LD_ADDR_OWVAR 39
1442: PUSH
1443: LD_INT 2
1445: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1446: LD_ADDR_OWVAR 40
1450: PUSH
1451: LD_INT 12
1453: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1454: LD_ADDR_OWVAR 41
1458: PUSH
1459: LD_INT 60
1461: ST_TO_ADDR
// Car1 := CreateVehicle ;
1462: LD_ADDR_EXP 34
1466: PUSH
1467: CALL_OW 45
1471: ST_TO_ADDR
// Car2 := CreateVehicle ;
1472: LD_ADDR_EXP 35
1476: PUSH
1477: CALL_OW 45
1481: ST_TO_ADDR
// Car3 := CreateVehicle ;
1482: LD_ADDR_EXP 36
1486: PUSH
1487: CALL_OW 45
1491: ST_TO_ADDR
// end ;
1492: LD_VAR 0 1
1496: RET
// function prepare_arabians_units ; begin
1497: LD_INT 0
1499: PPUSH
// InitUc ;
1500: CALL_OW 18
// InitHc ;
1504: CALL_OW 19
// uc_side := arabians ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_EXP 50
1517: ST_TO_ADDR
// uc_nation := nation_arabian ;
1518: LD_ADDR_OWVAR 21
1522: PUSH
1523: LD_INT 2
1525: ST_TO_ADDR
// PrepareSoldier ( sex_male , 4 ) ;
1526: LD_INT 1
1528: PPUSH
1529: LD_INT 4
1531: PPUSH
1532: CALL_OW 381
// Ara1 := CreateHuman ;
1536: LD_ADDR_EXP 39
1540: PUSH
1541: CALL_OW 44
1545: ST_TO_ADDR
// hc_name := Louis Gali ;
1546: LD_ADDR_OWVAR 26
1550: PUSH
1551: LD_STRING Louis Gali
1553: ST_TO_ADDR
// PrepareEngineer ( sex_male , 5 ) ;
1554: LD_INT 1
1556: PPUSH
1557: LD_INT 5
1559: PPUSH
1560: CALL_OW 382
// Ara2 := CreateHuman ;
1564: LD_ADDR_EXP 40
1568: PUSH
1569: CALL_OW 44
1573: ST_TO_ADDR
// InitHc ;
1574: CALL_OW 19
// uc_side := arabians ;
1578: LD_ADDR_OWVAR 20
1582: PUSH
1583: LD_EXP 50
1587: ST_TO_ADDR
// uc_nation := nation_arabian ;
1588: LD_ADDR_OWVAR 21
1592: PUSH
1593: LD_INT 2
1595: ST_TO_ADDR
// PrepareSoldier ( sex_female , 4 ) ;
1596: LD_INT 2
1598: PPUSH
1599: LD_INT 4
1601: PPUSH
1602: CALL_OW 381
// Ara3 := CreateHuman ;
1606: LD_ADDR_EXP 41
1610: PUSH
1611: CALL_OW 44
1615: ST_TO_ADDR
// PrepareMechanic ( sex_male , 5 ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 5
1621: PPUSH
1622: CALL_OW 383
// Ara4 := CreateHuman ;
1626: LD_ADDR_EXP 42
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PrepareMechanic ( sex_male , 4 ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 4
1641: PPUSH
1642: CALL_OW 383
// Ara5 := CreateHuman ;
1646: LD_ADDR_EXP 43
1650: PUSH
1651: CALL_OW 44
1655: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1656: LD_ADDR_OWVAR 37
1660: PUSH
1661: LD_INT 14
1663: ST_TO_ADDR
// vc_control := control_manual ;
1664: LD_ADDR_OWVAR 38
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// vc_engine := engine_combustion ;
1672: LD_ADDR_OWVAR 39
1676: PUSH
1677: LD_INT 1
1679: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
1680: LD_ADDR_OWVAR 40
1684: PUSH
1685: LD_INT 26
1687: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1688: LD_ADDR_OWVAR 41
1692: PUSH
1693: LD_INT 9
1695: ST_TO_ADDR
// AraCar1 := CreateVehicle ;
1696: LD_ADDR_EXP 44
1700: PUSH
1701: CALL_OW 45
1705: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1706: LD_ADDR_OWVAR 37
1710: PUSH
1711: LD_INT 14
1713: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1714: LD_ADDR_OWVAR 40
1718: PUSH
1719: LD_INT 32
1721: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1722: LD_ADDR_OWVAR 41
1726: PUSH
1727: LD_INT 9
1729: ST_TO_ADDR
// AraCar2 := CreateVehicle ;
1730: LD_ADDR_EXP 45
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// arabi := [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] ;
1740: LD_ADDR_EXP 46
1744: PUSH
1745: LD_EXP 39
1749: PUSH
1750: LD_EXP 40
1754: PUSH
1755: LD_EXP 41
1759: PUSH
1760: LD_EXP 42
1764: PUSH
1765: LD_EXP 43
1769: PUSH
1770: LD_EXP 44
1774: PUSH
1775: LD_EXP 45
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: ST_TO_ADDR
// PlaceHumanInUnit ( Ara4 , AraCar1 ) ;
1789: LD_EXP 42
1793: PPUSH
1794: LD_EXP 44
1798: PPUSH
1799: CALL_OW 52
// PlaceHumanInUnit ( Ara5 , AraCar2 ) ;
1803: LD_EXP 43
1807: PPUSH
1808: LD_EXP 45
1812: PPUSH
1813: CALL_OW 52
// end ;
1817: LD_VAR 0 1
1821: RET
// function prepare_russians_units ; begin
1822: LD_INT 0
1824: PPUSH
// end ;
1825: LD_VAR 0 1
1829: RET
// starting begin f_testing ;
1830: CALL 0 0 0
// depot1 := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1834: LD_ADDR_EXP 69
1838: PUSH
1839: LD_INT 23
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 30
1851: PUSH
1852: LD_INT 0
1854: PUSH
1855: EMPTY
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: PPUSH
1863: CALL_OW 69
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: ST_TO_ADDR
// rudepot1 := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1872: LD_ADDR_EXP 67
1876: PUSH
1877: LD_INT 23
1879: PUSH
1880: LD_INT 3
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 30
1889: PUSH
1890: LD_INT 0
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PPUSH
1901: CALL_OW 69
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: ST_TO_ADDR
// SetBName ( depot1 , terminal ) ;
1910: LD_EXP 69
1914: PPUSH
1915: LD_STRING terminal
1917: PPUSH
1918: CALL_OW 500
// map_size_x := 70 ;
1922: LD_ADDR_EXP 7
1926: PUSH
1927: LD_INT 70
1929: ST_TO_ADDR
// map_size_y := 140 ;
1930: LD_ADDR_EXP 8
1934: PUSH
1935: LD_INT 140
1937: ST_TO_ADDR
// lidi := [ ] ;
1938: LD_ADDR_EXP 58
1942: PUSH
1943: EMPTY
1944: ST_TO_ADDR
// lidi_base := [ ] ;
1945: LD_ADDR_EXP 59
1949: PUSH
1950: EMPTY
1951: ST_TO_ADDR
// lidi_eng := [ ] ;
1952: LD_ADDR_EXP 60
1956: PUSH
1957: EMPTY
1958: ST_TO_ADDR
// neco_rikaji := [ ] ;
1959: LD_ADDR_EXP 61
1963: PUSH
1964: EMPTY
1965: ST_TO_ADDR
// counter_time := 0 ;
1966: LD_ADDR_EXP 64
1970: PUSH
1971: LD_INT 0
1973: ST_TO_ADDR
// SetDifficulty ;
1974: CALL 1100 0 0
// mhmg := 1 ;
1978: LD_ADDR_EXP 9
1982: PUSH
1983: LD_INT 1
1985: ST_TO_ADDR
// mgg := 2 ;
1986: LD_ADDR_EXP 10
1990: PUSH
1991: LD_INT 2
1993: ST_TO_ADDR
// mg := 3 ;
1994: LD_ADDR_EXP 11
1998: PUSH
1999: LD_INT 3
2001: ST_TO_ADDR
// mrl := 4 ;
2002: LD_ADDR_EXP 12
2006: PUSH
2007: LD_INT 4
2009: ST_TO_ADDR
// hgg := 5 ;
2010: LD_ADDR_EXP 13
2014: PUSH
2015: LD_INT 5
2017: ST_TO_ADDR
// hrl := 6 ;
2018: LD_ADDR_EXP 14
2022: PUSH
2023: LD_INT 6
2025: ST_TO_ADDR
// hhg := 7 ;
2026: LD_ADDR_EXP 15
2030: PUSH
2031: LD_INT 7
2033: ST_TO_ADDR
// you := 1 ;
2034: LD_ADDR_EXP 47
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// you2 := 4 ;
2042: LD_ADDR_EXP 48
2046: PUSH
2047: LD_INT 4
2049: ST_TO_ADDR
// arabians := 2 ;
2050: LD_ADDR_EXP 50
2054: PUSH
2055: LD_INT 2
2057: ST_TO_ADDR
// russians := 3 ;
2058: LD_ADDR_EXP 49
2062: PUSH
2063: LD_INT 3
2065: ST_TO_ADDR
// SetBName ( RuDepot , ovsyenko ) ;
2066: LD_INT 58
2068: PPUSH
2069: LD_STRING ovsyenko
2071: PPUSH
2072: CALL_OW 500
// prepare_your_units ;
2076: CALL 1160 0 0
// prepare_arabians_units ;
2080: CALL 1497 0 0
// prepare_russians_units ;
2084: CALL 1822 0 0
// load_units_2 ;
2088: CALL 99 0 0
// Dialog2 ;
2092: CALL 2900 0 0
// end ;
2096: END
// export function Save ; var sibu ; begin
2097: LD_INT 0
2099: PPUSH
2100: PPUSH
// SaveCharacters ( JMM , JMM ) ;
2101: LD_EXP 17
2105: PPUSH
2106: LD_STRING JMM
2108: PPUSH
2109: CALL_OW 38
// if Bobby then
2113: LD_EXP 18
2117: IFFALSE 2152
// begin SaveCharacters ( Bobby , Bobby ) ;
2119: LD_EXP 18
2123: PPUSH
2124: LD_STRING Bobby
2126: PPUSH
2127: CALL_OW 38
// if IsDead ( Bobby ) then
2131: LD_EXP 18
2135: PPUSH
2136: CALL_OW 301
2140: IFFALSE 2152
// SaveVariable ( 0 , BobbyLoc ) ;
2142: LD_INT 0
2144: PPUSH
2145: LD_STRING BobbyLoc
2147: PPUSH
2148: CALL_OW 39
// end ; if Cyrus then
2152: LD_EXP 19
2156: IFFALSE 2191
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2158: LD_EXP 19
2162: PPUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: CALL_OW 38
// if IsDead ( Cyrus ) then
2170: LD_EXP 19
2174: PPUSH
2175: CALL_OW 301
2179: IFFALSE 2191
// SaveVariable ( 0 , CyrusLoc ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_STRING CyrusLoc
2186: PPUSH
2187: CALL_OW 39
// end ; if Brown then
2191: LD_EXP 21
2195: IFFALSE 2230
// begin SaveCharacters ( Brown , Brown ) ;
2197: LD_EXP 21
2201: PPUSH
2202: LD_STRING Brown
2204: PPUSH
2205: CALL_OW 38
// if IsDead ( Brown ) then
2209: LD_EXP 21
2213: PPUSH
2214: CALL_OW 301
2218: IFFALSE 2230
// SaveVariable ( 0 , BrownLoc ) ;
2220: LD_INT 0
2222: PPUSH
2223: LD_STRING BrownLoc
2225: PPUSH
2226: CALL_OW 39
// end ; if Donaldson then
2230: LD_EXP 20
2234: IFFALSE 2269
// begin SaveCharacters ( Donaldson , Donaldson ) ;
2236: LD_EXP 20
2240: PPUSH
2241: LD_STRING Donaldson
2243: PPUSH
2244: CALL_OW 38
// if IsDead ( Donaldson ) then
2248: LD_EXP 20
2252: PPUSH
2253: CALL_OW 301
2257: IFFALSE 2269
// SaveVariable ( 0 , DonaldsonLoc ) ;
2259: LD_INT 0
2261: PPUSH
2262: LD_STRING DonaldsonLoc
2264: PPUSH
2265: CALL_OW 39
// end ; SaveCharacters ( Gary , Gary ) ;
2269: LD_EXP 22
2273: PPUSH
2274: LD_STRING Gary
2276: PPUSH
2277: CALL_OW 38
// if IsDead ( Gary ) then
2281: LD_EXP 22
2285: PPUSH
2286: CALL_OW 301
2290: IFFALSE 2302
// SaveVariable ( 0 , GaryLoc ) ;
2292: LD_INT 0
2294: PPUSH
2295: LD_STRING GaryLoc
2297: PPUSH
2298: CALL_OW 39
// sibu := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2302: LD_ADDR_VAR 0 2
2306: PUSH
2307: LD_EXP 69
2311: PPUSH
2312: CALL_OW 274
2316: PPUSH
2317: LD_INT 3
2319: PPUSH
2320: CALL_OW 275
2324: ST_TO_ADDR
// if sibu > 300 then
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 300
2332: GREATER
2333: IFFALSE 2343
// sibu := 300 ;
2335: LD_ADDR_VAR 0 2
2339: PUSH
2340: LD_INT 300
2342: ST_TO_ADDR
// SaveVariable ( sibu , stoupa9_siberit ) ;
2343: LD_VAR 0 2
2347: PPUSH
2348: LD_STRING stoupa9_siberit
2350: PPUSH
2351: CALL_OW 39
// SaveVariable ( ( PoskytnouInformace > 0 ) , stoupa9_informace ) ;
2355: LD_EXP 56
2359: PUSH
2360: LD_INT 0
2362: GREATER
2363: PPUSH
2364: LD_STRING stoupa9_informace
2366: PPUSH
2367: CALL_OW 39
// SaveCharacters ( other_survivors , other_survivors ) ;
2371: LD_EXP 52
2375: PPUSH
2376: LD_STRING other_survivors
2378: PPUSH
2379: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Donaldson , Brown , Bobby , Cyrus , Gary , 0 ] , otherWithJMM ) ;
2383: LD_INT 22
2385: PUSH
2386: LD_EXP 47
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: LD_INT 21
2397: PUSH
2398: LD_INT 1
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: LD_INT 23
2407: PUSH
2408: LD_INT 1
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: LIST
2419: PPUSH
2420: CALL_OW 69
2424: PUSH
2425: LD_EXP 17
2429: PUSH
2430: LD_EXP 20
2434: PUSH
2435: LD_EXP 21
2439: PUSH
2440: LD_EXP 18
2444: PUSH
2445: LD_EXP 19
2449: PUSH
2450: LD_EXP 22
2454: PUSH
2455: LD_INT 0
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: LIST
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: DIFF
2467: PPUSH
2468: LD_STRING otherWithJMM
2470: PPUSH
2471: CALL_OW 38
// end ;
2475: LD_VAR 0 1
2479: RET
// every 0 0$3 trigger depot1 do var sib_dep1 ;
2480: LD_EXP 69
2484: IFFALSE 2537
2486: GO 2488
2488: DISABLE
2489: LD_INT 0
2491: PPUSH
// begin sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_EXP 69
2501: PPUSH
2502: CALL_OW 274
2506: PPUSH
2507: LD_INT 3
2509: PPUSH
2510: CALL_OW 275
2514: ST_TO_ADDR
// if sib_dep1 >= EndSiberit then
2515: LD_VAR 0 1
2519: PUSH
2520: LD_EXP 55
2524: GREATEREQUAL
2525: IFFALSE 2536
// ChangeMissionObjectives ( M2a ) else
2527: LD_STRING M2a
2529: PPUSH
2530: CALL_OW 337
2534: GO 2537
// enable ;
2536: ENABLE
// end ;
2537: PPOPN 1
2539: END
// export function SetMedals ; var d , sib_dep1 , sib_celkem , i ; begin
2540: LD_INT 0
2542: PPUSH
2543: PPUSH
2544: PPUSH
2545: PPUSH
2546: PPUSH
// d := difficulty - 1 ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_OWVAR 67
2556: PUSH
2557: LD_INT 1
2559: MINUS
2560: ST_TO_ADDR
// sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2561: LD_ADDR_VAR 0 3
2565: PUSH
2566: LD_EXP 69
2570: PPUSH
2571: CALL_OW 274
2575: PPUSH
2576: LD_INT 3
2578: PPUSH
2579: CALL_OW 275
2583: ST_TO_ADDR
// sib_celkem := 0 ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_INT 0
2591: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_INT 22
2599: PUSH
2600: LD_EXP 47
2604: PUSH
2605: EMPTY
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 2
2611: PUSH
2612: LD_INT 30
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PUSH
2622: LD_INT 30
2624: PUSH
2625: LD_INT 1
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PPUSH
2641: CALL_OW 69
2645: PUSH
2646: FOR_IN
2647: IFFALSE 2680
// sib_celkem := sib_celkem + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
2649: LD_ADDR_VAR 0 4
2653: PUSH
2654: LD_VAR 0 4
2658: PUSH
2659: LD_VAR 0 5
2663: PPUSH
2664: CALL_OW 274
2668: PPUSH
2669: LD_INT 3
2671: PPUSH
2672: CALL_OW 275
2676: PLUS
2677: ST_TO_ADDR
2678: GO 2646
2680: POP
2681: POP
// if sib_dep1 >= EndSiberit then
2682: LD_VAR 0 3
2686: PUSH
2687: LD_EXP 55
2691: GREATEREQUAL
2692: IFFALSE 2706
// AddMedal ( MuchSiberite , 1 ) else
2694: LD_STRING MuchSiberite
2696: PPUSH
2697: LD_INT 1
2699: PPUSH
2700: CALL_OW 101
2704: GO 2762
// if sib_celkem < EndSiberit then
2706: LD_VAR 0 4
2710: PUSH
2711: LD_EXP 55
2715: LESS
2716: IFFALSE 2741
// AddMedal ( MuchSiberite , - 1 - 2 * d ) else
2718: LD_STRING MuchSiberite
2720: PPUSH
2721: LD_INT 1
2723: NEG
2724: PUSH
2725: LD_INT 2
2727: PUSH
2728: LD_VAR 0 2
2732: MUL
2733: MINUS
2734: PPUSH
2735: CALL_OW 101
2739: GO 2762
// AddMedal ( MuchSiberite , - 2 - 2 * d ) ;
2741: LD_STRING MuchSiberite
2743: PPUSH
2744: LD_INT 2
2746: NEG
2747: PUSH
2748: LD_INT 2
2750: PUSH
2751: LD_VAR 0 2
2755: MUL
2756: MINUS
2757: PPUSH
2758: CALL_OW 101
// AddMedal ( EarlySiberite , not NastvalPowella ) ;
2762: LD_STRING EarlySiberite
2764: PPUSH
2765: LD_EXP 57
2769: NOT
2770: PPUSH
2771: CALL_OW 101
// AddMedal ( Information , PoskytnouInformace > 0 ) ;
2775: LD_STRING Information
2777: PPUSH
2778: LD_EXP 56
2782: PUSH
2783: LD_INT 0
2785: GREATER
2786: PPUSH
2787: CALL_OW 101
// end ;
2791: LD_VAR 0 1
2795: RET
// export Vyhrano ; export function Vyhra ; begin
2796: LD_INT 0
2798: PPUSH
// if not Vyhrano then
2799: LD_EXP 70
2803: NOT
2804: IFFALSE 2894
// begin Vyhrano := true ;
2806: LD_ADDR_EXP 70
2810: PUSH
2811: LD_INT 1
2813: ST_TO_ADDR
// SetMedals ;
2814: CALL 2540 0 0
// GiveMedals ( Main ) ;
2818: LD_STRING Main
2820: PPUSH
2821: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
2825: LD_INT 22
2827: PUSH
2828: LD_EXP 47
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 21
2839: PUSH
2840: LD_INT 1
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 23
2849: PUSH
2850: LD_INT 1
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: PPUSH
2867: CALL_OW 43
// Save ;
2871: CALL 2097 0 0
// YouWin ;
2875: CALL_OW 103
// ExclusiveOn ;
2879: CALL_OW 4
// WAIT ( 1 ) ;
2883: LD_INT 1
2885: PPUSH
2886: CALL_OW 67
// ExclusiveOff ;
2890: CALL_OW 5
// end ; end ;
2894: LD_VAR 0 1
2898: RET
// final begin end ; end_of_file
2899: END
// export ArmBuild ; export ArmUpgraded ; export function Dialog2 ; begin
2900: LD_INT 0
2902: PPUSH
// InGameOn ;
2903: CALL_OW 8
// PlaceUnitXYR ( Eng1 , 35 , 8 , 3 , false ) ;
2907: LD_EXP 26
2911: PPUSH
2912: LD_INT 35
2914: PPUSH
2915: LD_INT 8
2917: PPUSH
2918: LD_INT 3
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 50
// PlaceUnitXYR ( Eng2 , 35 , 8 , 3 , false ) ;
2928: LD_EXP 27
2932: PPUSH
2933: LD_INT 35
2935: PPUSH
2936: LD_INT 8
2938: PPUSH
2939: LD_INT 3
2941: PPUSH
2942: LD_INT 0
2944: PPUSH
2945: CALL_OW 50
// PlaceUnitXYR ( Eng3 , 35 , 8 , 3 , false ) ;
2949: LD_EXP 28
2953: PPUSH
2954: LD_INT 35
2956: PPUSH
2957: LD_INT 8
2959: PPUSH
2960: LD_INT 3
2962: PPUSH
2963: LD_INT 0
2965: PPUSH
2966: CALL_OW 50
// PlaceHumanInUnit ( Eng4 , CarE1 ) ;
2970: LD_EXP 29
2974: PPUSH
2975: LD_EXP 30
2979: PPUSH
2980: CALL_OW 52
// PlaceUnitXY ( CarE1 , 41 , 9 , false ) ;
2984: LD_EXP 30
2988: PPUSH
2989: LD_INT 41
2991: PPUSH
2992: LD_INT 9
2994: PPUSH
2995: LD_INT 0
2997: PPUSH
2998: CALL_OW 48
// ComHold ( CarE1 ) ;
3002: LD_EXP 30
3006: PPUSH
3007: CALL_OW 140
// ComMoveXY ( [ Eng1 , Eng2 , Eng3 ] , 34 , 6 ) ;
3011: LD_EXP 26
3015: PUSH
3016: LD_EXP 27
3020: PUSH
3021: LD_EXP 28
3025: PUSH
3026: EMPTY
3027: LIST
3028: LIST
3029: LIST
3030: PPUSH
3031: LD_INT 34
3033: PPUSH
3034: LD_INT 6
3036: PPUSH
3037: CALL_OW 111
// AddComRepairBuilding ( [ Eng1 , Eng2 , Eng3 ] , Depot1 ) ;
3041: LD_EXP 26
3045: PUSH
3046: LD_EXP 27
3050: PUSH
3051: LD_EXP 28
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: PPUSH
3061: LD_EXP 69
3065: PPUSH
3066: CALL_OW 190
// ComEnterUnit ( Gary , rudepot1 ) ;
3070: LD_EXP 22
3074: PPUSH
3075: LD_EXP 67
3079: PPUSH
3080: CALL_OW 120
// Wait ( 0 0$1 ) ;
3084: LD_INT 35
3086: PPUSH
3087: CALL_OW 67
// PlaceUnitXY ( JMM , 33 , 1 , false ) ;
3091: LD_EXP 17
3095: PPUSH
3096: LD_INT 33
3098: PPUSH
3099: LD_INT 1
3101: PPUSH
3102: LD_INT 0
3104: PPUSH
3105: CALL_OW 48
// CenterNowOnUnits ( JMM ) ;
3109: LD_EXP 17
3113: PPUSH
3114: CALL_OW 87
// ComMoveXY ( JMM , 34 , 5 ) ;
3118: LD_EXP 17
3122: PPUSH
3123: LD_INT 34
3125: PPUSH
3126: LD_INT 5
3128: PPUSH
3129: CALL_OW 111
// AddComStand ( JMM ) ;
3133: LD_EXP 17
3137: PPUSH
3138: CALL_OW 225
// CreateCratesXY ( 5 , 39 , 10 , false ) ;
3142: LD_INT 5
3144: PPUSH
3145: LD_INT 39
3147: PPUSH
3148: LD_INT 10
3150: PPUSH
3151: LD_INT 0
3153: PPUSH
3154: CALL_OW 54
// CreateCratesXY ( 5 , 39 , 11 , false ) ;
3158: LD_INT 5
3160: PPUSH
3161: LD_INT 39
3163: PPUSH
3164: LD_INT 11
3166: PPUSH
3167: LD_INT 0
3169: PPUSH
3170: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 10 , false ) ;
3174: LD_INT 5
3176: PPUSH
3177: LD_INT 38
3179: PPUSH
3180: LD_INT 10
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 11 , false ) ;
3190: LD_INT 5
3192: PPUSH
3193: LD_INT 38
3195: PPUSH
3196: LD_INT 11
3198: PPUSH
3199: LD_INT 0
3201: PPUSH
3202: CALL_OW 54
// Wait ( 0 0$3 ) ;
3206: LD_INT 105
3208: PPUSH
3209: CALL_OW 67
// ComMoveXY ( CarE1 , 38 , 1 ) ;
3213: LD_EXP 30
3217: PPUSH
3218: LD_INT 38
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: CALL_OW 111
// while GetY ( CarE1 ) > 3 do
3228: LD_EXP 30
3232: PPUSH
3233: CALL_OW 251
3237: PUSH
3238: LD_INT 3
3240: GREATER
3241: IFFALSE 3252
// wait ( 0 0$0.3 ) ;
3243: LD_INT 10
3245: PPUSH
3246: CALL_OW 67
3250: GO 3228
// RemoveUnit ( CarE1 ) ;
3252: LD_EXP 30
3256: PPUSH
3257: CALL_OW 64
// Say ( JMM , D2-JMM-1 ) ;
3261: LD_EXP 17
3265: PPUSH
3266: LD_STRING D2-JMM-1
3268: PPUSH
3269: CALL_OW 88
// Say ( Eng1 , D2-Eng1-1 ) ;
3273: LD_EXP 26
3277: PPUSH
3278: LD_STRING D2-Eng1-1
3280: PPUSH
3281: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3285: LD_EXP 17
3289: PPUSH
3290: LD_STRING D2-JMM-2
3292: PPUSH
3293: CALL_OW 88
// Say ( Eng1 , D2-Eng1-2 ) ;
3297: LD_EXP 26
3301: PPUSH
3302: LD_STRING D2-Eng1-2
3304: PPUSH
3305: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3309: LD_EXP 17
3313: PPUSH
3314: LD_STRING D2-JMM-3
3316: PPUSH
3317: CALL_OW 88
// SetSideBase ( GetBase ( Depot1 ) , you ) ;
3321: LD_EXP 69
3325: PPUSH
3326: CALL_OW 274
3330: PPUSH
3331: LD_EXP 47
3335: PPUSH
3336: CALL_OW 236
// SetSide ( [ Eng1 , Eng2 , Eng3 ] , you ) ;
3340: LD_EXP 26
3344: PUSH
3345: LD_EXP 27
3349: PUSH
3350: LD_EXP 28
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: PPUSH
3360: LD_EXP 47
3364: PPUSH
3365: CALL_OW 235
// SaveForQuickRestart ;
3369: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3373: LD_STRING M1
3375: PPUSH
3376: CALL_OW 337
// InGameOff ;
3380: CALL_OW 9
// end ;
3384: LD_VAR 0 1
3388: RET
// export byld2a ; every 0 0$2 trigger IsInArea ( JMM , base ) marked 30 do
3389: LD_EXP 17
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: CALL_OW 308
3401: IFFALSE 3410
3403: GO 3405
3405: DISABLE
// begin dialog2a ;
3406: CALL 3411 0 0
// end ;
3410: END
// export function dialog2a ; var i ; begin
3411: LD_INT 0
3413: PPUSH
3414: PPUSH
// Wait ( 0 0$1 ) ;
3415: LD_INT 35
3417: PPUSH
3418: CALL_OW 67
// ComMoveUnit ( Gary , JMM ) ;
3422: LD_EXP 22
3426: PPUSH
3427: LD_EXP 17
3431: PPUSH
3432: CALL_OW 112
// byld2a := true ;
3436: LD_ADDR_EXP 73
3440: PUSH
3441: LD_INT 1
3443: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
3444: LD_INT 105
3446: PPUSH
3447: CALL_OW 67
// DialogueOn ;
3451: CALL_OW 6
// Say ( JMM , D2-JMM-3a ) ;
3455: LD_EXP 17
3459: PPUSH
3460: LD_STRING D2-JMM-3a
3462: PPUSH
3463: CALL_OW 88
// SetSideBase ( GetBase ( rudepot1 ) , you ) ;
3467: LD_EXP 67
3471: PPUSH
3472: CALL_OW 274
3476: PPUSH
3477: LD_EXP 47
3481: PPUSH
3482: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you2 ] , [ f_type , unit_building ] ] ) do
3486: LD_ADDR_VAR 0 2
3490: PUSH
3491: LD_INT 22
3493: PUSH
3494: LD_EXP 48
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: LD_INT 21
3505: PUSH
3506: LD_INT 3
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PPUSH
3517: CALL_OW 69
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3541
// SetSide ( i , you ) ;
3525: LD_VAR 0 2
3529: PPUSH
3530: LD_EXP 47
3534: PPUSH
3535: CALL_OW 235
3539: GO 3522
3541: POP
3542: POP
// SetSide ( lidi_base , you ) ;
3543: LD_EXP 59
3547: PPUSH
3548: LD_EXP 47
3552: PPUSH
3553: CALL_OW 235
// SetResourceType ( GetBase ( rudepot1 ) , mat_siberit , 0 ) ;
3557: LD_EXP 67
3561: PPUSH
3562: CALL_OW 274
3566: PPUSH
3567: LD_INT 3
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 277
// Say ( Gary , D2-Gary-3 ) ;
3577: LD_EXP 22
3581: PPUSH
3582: LD_STRING D2-Gary-3
3584: PPUSH
3585: CALL_OW 88
// if Bobby then
3589: LD_EXP 18
3593: IFFALSE 3607
// Say ( Bobby , D2-Bobby-3 ) ;
3595: LD_EXP 18
3599: PPUSH
3600: LD_STRING D2-Bobby-3
3602: PPUSH
3603: CALL_OW 88
// if Cyrus then
3607: LD_EXP 19
3611: IFFALSE 3625
// Say ( Cyrus , D2-Cyrus-3 ) ;
3613: LD_EXP 19
3617: PPUSH
3618: LD_STRING D2-Cyrus-3
3620: PPUSH
3621: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3625: LD_EXP 17
3629: PPUSH
3630: LD_STRING D2-JMM-4
3632: PPUSH
3633: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3637: LD_EXP 22
3641: PPUSH
3642: LD_STRING D2-Gary-4
3644: PPUSH
3645: CALL_OW 88
// if Cyrus then
3649: LD_EXP 19
3653: IFFALSE 3669
// Say ( Cyrus , D2-Cyrus-4 ) else
3655: LD_EXP 19
3659: PPUSH
3660: LD_STRING D2-Cyrus-4
3662: PPUSH
3663: CALL_OW 88
3667: GO 3701
// SayAny ( lidi_base diff neco_rikaji , D2-Sol1-4 , you , sex_male , 0 , 0 ) ;
3669: LD_EXP 59
3673: PUSH
3674: LD_EXP 61
3678: DIFF
3679: PPUSH
3680: LD_STRING D2-Sol1-4
3682: PPUSH
3683: LD_EXP 47
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL 13071 0 6
// Say ( JMM , D2-JMM-5 ) ;
3701: LD_EXP 17
3705: PPUSH
3706: LD_STRING D2-JMM-5
3708: PPUSH
3709: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-5 , you , sex_female , class_engineer , 0 ) ;
3713: LD_EXP 58
3717: PUSH
3718: LD_EXP 61
3722: DIFF
3723: PPUSH
3724: LD_STRING D2-FEng1-5
3726: PPUSH
3727: LD_EXP 47
3731: PPUSH
3732: LD_INT 2
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: LD_INT 0
3740: PPUSH
3741: CALL 13071 0 6
// Say ( JMM , D2-JMM-6 ) ;
3745: LD_EXP 17
3749: PPUSH
3750: LD_STRING D2-JMM-6
3752: PPUSH
3753: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-6 , you , sex_female , class_engineer , 0 ) ;
3757: LD_EXP 58
3761: PUSH
3762: LD_EXP 61
3766: DIFF
3767: PPUSH
3768: LD_STRING D2-FEng1-6
3770: PPUSH
3771: LD_EXP 47
3775: PPUSH
3776: LD_INT 2
3778: PPUSH
3779: LD_INT 2
3781: PPUSH
3782: LD_INT 0
3784: PPUSH
3785: CALL 13071 0 6
// SayAny ( lidi diff neco_rikaji , D2-Eng1-6 , you , sex_male , class_engineer , 0 ) ;
3789: LD_EXP 58
3793: PUSH
3794: LD_EXP 61
3798: DIFF
3799: PPUSH
3800: LD_STRING D2-Eng1-6
3802: PPUSH
3803: LD_EXP 47
3807: PPUSH
3808: LD_INT 1
3810: PPUSH
3811: LD_INT 2
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL 13071 0 6
// Say ( JMM , D2-JMM-7 ) ;
3821: LD_EXP 17
3825: PPUSH
3826: LD_STRING D2-JMM-7
3828: PPUSH
3829: CALL_OW 88
// Say ( Gary , D2-Gary-7 ) ;
3833: LD_EXP 22
3837: PPUSH
3838: LD_STRING D2-Gary-7
3840: PPUSH
3841: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-7 , you , sex_female , class_engineer , 0 ) ;
3845: LD_EXP 58
3849: PUSH
3850: LD_EXP 61
3854: DIFF
3855: PPUSH
3856: LD_STRING D2-FEng1-7
3858: PPUSH
3859: LD_EXP 47
3863: PPUSH
3864: LD_INT 2
3866: PPUSH
3867: LD_INT 2
3869: PPUSH
3870: LD_INT 0
3872: PPUSH
3873: CALL 13071 0 6
// SayAny ( lidi diff neco_rikaji , D2-Sol1-7 , you , sex_male , class_soldier , 0 ) ;
3877: LD_EXP 58
3881: PUSH
3882: LD_EXP 61
3886: DIFF
3887: PPUSH
3888: LD_STRING D2-Sol1-7
3890: PPUSH
3891: LD_EXP 47
3895: PPUSH
3896: LD_INT 1
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: LD_INT 0
3904: PPUSH
3905: CALL 13071 0 6
// Say ( JMM , D2-JMM-8 ) ;
3909: LD_EXP 17
3913: PPUSH
3914: LD_STRING D2-JMM-8
3916: PPUSH
3917: CALL_OW 88
// dialog2byl := true ;
3921: LD_ADDR_EXP 65
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
3929: LD_STRING M1a
3931: PPUSH
3932: CALL_OW 337
// DialogueOff ;
3936: CALL_OW 7
// MyHint ( SibDet ) ;
3940: LD_STRING SibDet
3942: PPUSH
3943: CALL 14222 0 1
// end ;
3947: LD_VAR 0 1
3951: RET
// every 0 0$5 trigger GetSide ( rudepot1 ) = you and GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) do
3952: LD_EXP 67
3956: PPUSH
3957: CALL_OW 255
3961: PUSH
3962: LD_EXP 47
3966: EQUAL
3967: PUSH
3968: LD_EXP 67
3972: PPUSH
3973: CALL_OW 274
3977: PPUSH
3978: LD_INT 3
3980: PPUSH
3981: CALL_OW 275
3985: AND
3986: IFFALSE 4051
3988: GO 3990
3990: DISABLE
// begin case difficulty of 1 :
3991: LD_OWVAR 67
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4014
4004: POP
// ChangeMissionObjectives ( M2easy ) ; 2 :
4005: LD_STRING M2easy
4007: PPUSH
4008: CALL_OW 337
4012: GO 4051
4014: LD_INT 2
4016: DOUBLE
4017: EQUAL
4018: IFTRUE 4022
4020: GO 4032
4022: POP
// ChangeMissionObjectives ( M2 ) ; 3 :
4023: LD_STRING M2
4025: PPUSH
4026: CALL_OW 337
4030: GO 4051
4032: LD_INT 3
4034: DOUBLE
4035: EQUAL
4036: IFTRUE 4040
4038: GO 4050
4040: POP
// ChangeMissionObjectives ( M2hard ) ; end ;
4041: LD_STRING M2hard
4043: PPUSH
4044: CALL_OW 337
4048: GO 4051
4050: POP
// end ;
4051: END
// every 7 7$0 do
4052: GO 4054
4054: DISABLE
// begin DialogueOn ;
4055: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4059: LD_EXP 16
4063: PPUSH
4064: LD_STRING D3-Pow-1
4066: PPUSH
4067: CALL_OW 94
// if dialog2byl then
4071: LD_EXP 65
4075: IFFALSE 4091
// Say ( JMM , D3-JMM-1 ) else
4077: LD_EXP 17
4081: PPUSH
4082: LD_STRING D3-JMM-1
4084: PPUSH
4085: CALL_OW 88
4089: GO 4103
// Say ( JMM , D3-JMM-1a ) ;
4091: LD_EXP 17
4095: PPUSH
4096: LD_STRING D3-JMM-1a
4098: PPUSH
4099: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4103: LD_EXP 17
4107: PPUSH
4108: LD_STRING D3-JMM-1b
4110: PPUSH
4111: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4115: LD_EXP 16
4119: PPUSH
4120: LD_STRING D3-Pow-2
4122: PPUSH
4123: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
4127: LD_STRING M3
4129: PPUSH
4130: CALL_OW 337
// DialogueOff ;
4134: CALL_OW 7
// counter_time := 22 22$0 ;
4138: LD_ADDR_EXP 64
4142: PUSH
4143: LD_INT 46200
4145: ST_TO_ADDR
// end ;
4146: END
// every 22 22$0 do var qr , i , mt ;
4147: GO 4149
4149: DISABLE
4150: LD_INT 0
4152: PPUSH
4153: PPUSH
4154: PPUSH
// begin SetAttitude ( you , you2 , att_neutral , true ) ;
4155: LD_EXP 47
4159: PPUSH
4160: LD_EXP 48
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: LD_INT 1
4170: PPUSH
4171: CALL_OW 80
// ChangeSideFog ( you2 , you ) ;
4175: LD_EXP 48
4179: PPUSH
4180: LD_EXP 47
4184: PPUSH
4185: CALL_OW 343
// PlaceHumanInUnit ( Mec1 , Car1 ) ;
4189: LD_EXP 31
4193: PPUSH
4194: LD_EXP 34
4198: PPUSH
4199: CALL_OW 52
// PlaceHumanInUnit ( Mec2 , Car2 ) ;
4203: LD_EXP 32
4207: PPUSH
4208: LD_EXP 35
4212: PPUSH
4213: CALL_OW 52
// PlaceHumanInUnit ( Mec3 , Car3 ) ;
4217: LD_EXP 33
4221: PPUSH
4222: LD_EXP 36
4226: PPUSH
4227: CALL_OW 52
// if not PlaceUnitXYR ( Car1 , 35 , 1 , 10 , false ) then
4231: LD_EXP 34
4235: PPUSH
4236: LD_INT 35
4238: PPUSH
4239: LD_INT 1
4241: PPUSH
4242: LD_INT 10
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: CALL_OW 50
4252: NOT
4253: IFFALSE 4270
// PlaceUnitArea ( Car1 , odjezd , false ) ;
4255: LD_EXP 34
4259: PPUSH
4260: LD_INT 5
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 49
// if not PlaceUnitXYR ( Car2 , 35 , 1 , 10 , false ) then
4270: LD_EXP 35
4274: PPUSH
4275: LD_INT 35
4277: PPUSH
4278: LD_INT 1
4280: PPUSH
4281: LD_INT 10
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 50
4291: NOT
4292: IFFALSE 4309
// PlaceUnitArea ( Car2 , odjezd , false ) ;
4294: LD_EXP 35
4298: PPUSH
4299: LD_INT 5
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: CALL_OW 49
// if not PlaceUnitXYR ( Car3 , 35 , 1 , 10 , false ) then
4309: LD_EXP 36
4313: PPUSH
4314: LD_INT 35
4316: PPUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 10
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: CALL_OW 50
4330: NOT
4331: IFFALSE 4348
// PlaceUnitArea ( Car3 , odjezd , false ) ;
4333: LD_EXP 36
4337: PPUSH
4338: LD_INT 5
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 49
// ComMoveXY ( [ Car1 , Car2 , Car3 ] , 37 , 8 ) ;
4348: LD_EXP 34
4352: PUSH
4353: LD_EXP 35
4357: PUSH
4358: LD_EXP 36
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: PPUSH
4368: LD_INT 37
4370: PPUSH
4371: LD_INT 8
4373: PPUSH
4374: CALL_OW 111
// AddComStand ( [ Car1 , Car2 , Car3 ] ) ;
4378: LD_EXP 34
4382: PUSH
4383: LD_EXP 35
4387: PUSH
4388: LD_EXP 36
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: LIST
4397: PPUSH
4398: CALL_OW 225
// CenterNowOnUnits ( Car1 ) ;
4402: LD_EXP 34
4406: PPUSH
4407: CALL_OW 87
// Wait ( 0 0$3 ) ;
4411: LD_INT 105
4413: PPUSH
4414: CALL_OW 67
// DialogueOn ;
4418: CALL_OW 6
// Say ( Mec1 , D4-Mech1-1 ) ;
4422: LD_EXP 31
4426: PPUSH
4427: LD_STRING D4-Mech1-1
4429: PPUSH
4430: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4434: LD_EXP 17
4438: PPUSH
4439: LD_STRING D4-JMM-1
4441: PPUSH
4442: CALL_OW 88
// Say ( Mec1 , D4-Mech1-2 ) ;
4446: LD_EXP 31
4450: PPUSH
4451: LD_STRING D4-Mech1-2
4453: PPUSH
4454: CALL_OW 88
// AddResourceType ( GetBase ( Depot1 ) , mat_cans , 300 ) ;
4458: LD_EXP 69
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: LD_INT 300
4473: PPUSH
4474: CALL_OW 276
// qr := 0 ;
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// if KolikMaBytSiberitu > GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4486: LD_EXP 66
4490: PUSH
4491: LD_EXP 69
4495: PPUSH
4496: CALL_OW 274
4500: PPUSH
4501: LD_INT 3
4503: PPUSH
4504: CALL_OW 275
4508: GREATER
4509: IFFALSE 4601
// begin qr := Query ( QWait ) ;
4511: LD_ADDR_VAR 0 1
4515: PUSH
4516: LD_STRING QWait
4518: PPUSH
4519: CALL_OW 97
4523: ST_TO_ADDR
// case qr of 1 :
4524: LD_VAR 0 1
4528: PUSH
4529: LD_INT 1
4531: DOUBLE
4532: EQUAL
4533: IFTRUE 4537
4535: GO 4552
4537: POP
// Say ( JMM , D5a-JMM-1 ) ; 2 :
4538: LD_EXP 17
4542: PPUSH
4543: LD_STRING D5a-JMM-1
4545: PPUSH
4546: CALL_OW 88
4550: GO 4599
4552: LD_INT 2
4554: DOUBLE
4555: EQUAL
4556: IFTRUE 4560
4558: GO 4575
4560: POP
// Say ( JMM , D5b-JMM-1 ) ; 3 :
4561: LD_EXP 17
4565: PPUSH
4566: LD_STRING D5b-JMM-1
4568: PPUSH
4569: CALL_OW 88
4573: GO 4599
4575: LD_INT 3
4577: DOUBLE
4578: EQUAL
4579: IFTRUE 4583
4581: GO 4598
4583: POP
// Say ( JMM , D5c-JMM-1 ) ; end ;
4584: LD_EXP 17
4588: PPUSH
4589: LD_STRING D5c-JMM-1
4591: PPUSH
4592: CALL_OW 88
4596: GO 4599
4598: POP
// end else
4599: GO 4613
// Say ( JMM , D5-JMM-1 ) ;
4601: LD_EXP 17
4605: PPUSH
4606: LD_STRING D5-JMM-1
4608: PPUSH
4609: CALL_OW 88
// DialogueOff ;
4613: CALL_OW 7
// if qr = 1 then
4617: LD_VAR 0 1
4621: PUSH
4622: LD_INT 1
4624: EQUAL
4625: IFFALSE 4648
// begin counter_time := tick + 5 5$0 ;
4627: LD_ADDR_EXP 64
4631: PUSH
4632: LD_OWVAR 1
4636: PUSH
4637: LD_INT 10500
4639: PLUS
4640: ST_TO_ADDR
// Wait ( 5 5$0 ) ;
4641: LD_INT 10500
4643: PPUSH
4644: CALL_OW 67
// end ; if qr = 2 or qr = 3 then
4648: LD_VAR 0 1
4652: PUSH
4653: LD_INT 2
4655: EQUAL
4656: PUSH
4657: LD_VAR 0 1
4661: PUSH
4662: LD_INT 3
4664: EQUAL
4665: OR
4666: IFFALSE 4676
// NastvalPowella := true ;
4668: LD_ADDR_EXP 57
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// DialogueOn ;
4676: CALL_OW 6
// if KolikMaBytSiberitu <= GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4680: LD_EXP 66
4684: PUSH
4685: LD_EXP 69
4689: PPUSH
4690: CALL_OW 274
4694: PPUSH
4695: LD_INT 3
4697: PPUSH
4698: CALL_OW 275
4702: LESSEQUAL
4703: IFFALSE 4719
// Say ( Mec1 , D6-Mech1-1 ) else
4705: LD_EXP 31
4709: PPUSH
4710: LD_STRING D6-Mech1-1
4712: PPUSH
4713: CALL_OW 88
4717: GO 4776
// begin NastvalPowella := true ;
4719: LD_ADDR_EXP 57
4723: PUSH
4724: LD_INT 1
4726: ST_TO_ADDR
// if 0 < GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4727: LD_INT 0
4729: PUSH
4730: LD_EXP 69
4734: PPUSH
4735: CALL_OW 274
4739: PPUSH
4740: LD_INT 3
4742: PPUSH
4743: CALL_OW 275
4747: LESS
4748: IFFALSE 4764
// Say ( Mec1 , D6-Mech1-1a ) else
4750: LD_EXP 31
4754: PPUSH
4755: LD_STRING D6-Mech1-1a
4757: PPUSH
4758: CALL_OW 88
4762: GO 4776
// Say ( Mec1 , D6-Mech1-1b ) ;
4764: LD_EXP 31
4768: PPUSH
4769: LD_STRING D6-Mech1-1b
4771: PPUSH
4772: CALL_OW 88
// end ; DialogueOff ;
4776: CALL_OW 7
// counter_time := 0 ;
4780: LD_ADDR_EXP 64
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// if GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > KolikMaBytSiberitu then
4788: LD_EXP 69
4792: PPUSH
4793: CALL_OW 274
4797: PPUSH
4798: LD_INT 3
4800: PPUSH
4801: CALL_OW 275
4805: PUSH
4806: LD_EXP 66
4810: GREATER
4811: IFFALSE 4858
// begin SetCargo ( [ Car1 ] , mat_siberit , KolikMaBytSiberitu ) ;
4813: LD_EXP 34
4817: PUSH
4818: EMPTY
4819: LIST
4820: PPUSH
4821: LD_INT 3
4823: PPUSH
4824: LD_EXP 66
4828: PPUSH
4829: CALL_OW 290
// AddResourceType ( GetBase ( Depot1 ) , mat_siberit , - KolikMaBytSiberitu ) ;
4833: LD_EXP 69
4837: PPUSH
4838: CALL_OW 274
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_EXP 66
4850: NEG
4851: PPUSH
4852: CALL_OW 276
// end else
4856: GO 4911
// begin SetCargo ( [ Car1 ] , mat_siberit , GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) ) ;
4858: LD_EXP 34
4862: PUSH
4863: EMPTY
4864: LIST
4865: PPUSH
4866: LD_INT 3
4868: PPUSH
4869: LD_EXP 69
4873: PPUSH
4874: CALL_OW 274
4878: PPUSH
4879: LD_INT 3
4881: PPUSH
4882: CALL_OW 275
4886: PPUSH
4887: CALL_OW 290
// SetResourceType ( GetBase ( Depot1 ) , mat_siberit , 0 ) ;
4891: LD_EXP 69
4895: PPUSH
4896: CALL_OW 274
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 0
4906: PPUSH
4907: CALL_OW 277
// end ; mt := tick + 0 0$20 ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_OWVAR 1
4920: PUSH
4921: LD_INT 700
4923: PLUS
4924: ST_TO_ADDR
// while UnitFilter ( [ Car1 , Car2 , Car3 ] , [ [ f_placed ] ] ) and mt < tick do
4925: LD_EXP 34
4929: PUSH
4930: LD_EXP 35
4934: PUSH
4935: LD_EXP 36
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: PPUSH
4945: LD_INT 52
4947: PUSH
4948: EMPTY
4949: LIST
4950: PUSH
4951: EMPTY
4952: LIST
4953: PPUSH
4954: CALL_OW 72
4958: PUSH
4959: LD_VAR 0 3
4963: PUSH
4964: LD_OWVAR 1
4968: LESS
4969: AND
4970: IFFALSE 5132
// begin ComMoveToArea ( [ Car1 , Car2 , Car3 ] , odjezd ) ;
4972: LD_EXP 34
4976: PUSH
4977: LD_EXP 35
4981: PUSH
4982: LD_EXP 36
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: PPUSH
4992: LD_INT 5
4994: PPUSH
4995: CALL_OW 113
// AddComMoveXY ( [ Car1 , Car2 , Car3 ] , 38 , 1 ) ;
4999: LD_EXP 34
5003: PUSH
5004: LD_EXP 35
5008: PUSH
5009: LD_EXP 36
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: PPUSH
5019: LD_INT 38
5021: PPUSH
5022: LD_INT 1
5024: PPUSH
5025: CALL_OW 171
// case true of IsInArea ( Car1 , odjezd ) :
5029: LD_INT 1
5031: PUSH
5032: LD_EXP 34
5036: PPUSH
5037: LD_INT 5
5039: PPUSH
5040: CALL_OW 308
5044: DOUBLE
5045: EQUAL
5046: IFTRUE 5050
5048: GO 5062
5050: POP
// RemoveUnit ( Car1 ) ; IsInArea ( Car2 , odjezd ) :
5051: LD_EXP 34
5055: PPUSH
5056: CALL_OW 64
5060: GO 5123
5062: LD_EXP 35
5066: PPUSH
5067: LD_INT 5
5069: PPUSH
5070: CALL_OW 308
5074: DOUBLE
5075: EQUAL
5076: IFTRUE 5080
5078: GO 5092
5080: POP
// RemoveUnit ( Car2 ) ; IsInArea ( Car3 , odjezd ) :
5081: LD_EXP 35
5085: PPUSH
5086: CALL_OW 64
5090: GO 5123
5092: LD_EXP 36
5096: PPUSH
5097: LD_INT 5
5099: PPUSH
5100: CALL_OW 308
5104: DOUBLE
5105: EQUAL
5106: IFTRUE 5110
5108: GO 5122
5110: POP
// RemoveUnit ( Car3 ) ; end ;
5111: LD_EXP 36
5115: PPUSH
5116: CALL_OW 64
5120: GO 5123
5122: POP
// wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// end ;
5130: GO 4925
// for i in [ Car1 , Car2 , Car3 , Mec1 , Mec2 , Mec3 ] do
5132: LD_ADDR_VAR 0 2
5136: PUSH
5137: LD_EXP 34
5141: PUSH
5142: LD_EXP 35
5146: PUSH
5147: LD_EXP 36
5151: PUSH
5152: LD_EXP 31
5156: PUSH
5157: LD_EXP 32
5161: PUSH
5162: LD_EXP 33
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: FOR_IN
5176: IFFALSE 5189
// RemoveUnit ( i ) ;
5178: LD_VAR 0 2
5182: PPUSH
5183: CALL_OW 64
5187: GO 5175
5189: POP
5190: POP
// if NastvalPowella then
5191: LD_EXP 57
5195: IFFALSE 5206
// ChangeMissionObjectives ( M3b ) else
5197: LD_STRING M3b
5199: PPUSH
5200: CALL_OW 337
5204: GO 5213
// ChangeMissionObjectives ( M3a ) ;
5206: LD_STRING M3a
5208: PPUSH
5209: CALL_OW 337
// end ;
5213: PPOPN 3
5215: END
// every 0 0$5 trigger GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > 35 do var r ;
5216: LD_EXP 69
5220: PPUSH
5221: CALL_OW 274
5225: PPUSH
5226: LD_INT 3
5228: PPUSH
5229: CALL_OW 275
5233: PUSH
5234: LD_INT 35
5236: GREATER
5237: IFFALSE 5408
5239: GO 5241
5241: DISABLE
5242: LD_INT 0
5244: PPUSH
// begin Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , class_scientistic , 0 ) ;
5245: LD_ADDR_EXP 25
5249: PUSH
5250: LD_EXP 58
5254: PUSH
5255: LD_EXP 61
5259: DIFF
5260: PPUSH
5261: LD_EXP 47
5265: PPUSH
5266: LD_INT 1
5268: PPUSH
5269: LD_INT 4
5271: PPUSH
5272: LD_INT 0
5274: PPUSH
5275: CALL 13151 0 5
5279: ST_TO_ADDR
// if not Sci1 then
5280: LD_EXP 25
5284: NOT
5285: IFFALSE 5322
// Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , 0 , 0 ) ;
5287: LD_ADDR_EXP 25
5291: PUSH
5292: LD_EXP 58
5296: PUSH
5297: LD_EXP 61
5301: DIFF
5302: PPUSH
5303: LD_EXP 47
5307: PPUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 0
5313: PPUSH
5314: LD_INT 0
5316: PPUSH
5317: CALL 13151 0 5
5321: ST_TO_ADDR
// if Sci1 then
5322: LD_EXP 25
5326: IFFALSE 5408
// begin DialogueOn ;
5328: CALL_OW 6
// Say ( Sci1 , D7-Sci1-1 ) ;
5332: LD_EXP 25
5336: PPUSH
5337: LD_STRING D7-Sci1-1
5339: PPUSH
5340: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5344: LD_EXP 17
5348: PPUSH
5349: LD_STRING D7-JMM-1
5351: PPUSH
5352: CALL_OW 88
// Say ( Sci1 , D7-Sci1-2 ) ;
5356: LD_EXP 25
5360: PPUSH
5361: LD_STRING D7-Sci1-2
5363: PPUSH
5364: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5368: LD_EXP 17
5372: PPUSH
5373: LD_STRING D7-JMM-2
5375: PPUSH
5376: CALL_OW 88
// Say ( Sci1 , D7-Sci1-3 ) ;
5380: LD_EXP 25
5384: PPUSH
5385: LD_STRING D7-Sci1-3
5387: PPUSH
5388: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5392: LD_EXP 17
5396: PPUSH
5397: LD_STRING D7-JMM-3
5399: PPUSH
5400: CALL_OW 88
// DialogueOff ;
5404: CALL_OW 7
// end ; end ;
5408: PPOPN 1
5410: END
// export ArmStarted ; export BarStarted ; function odnes_jeden_oil ; var a ; begin
5411: LD_INT 0
5413: PPUSH
5414: PPUSH
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5415: LD_EXP 40
5419: PPUSH
5420: LD_EXP 67
5424: PPUSH
5425: CALL_OW 296
5429: PUSH
5430: LD_INT 4
5432: GREATER
5433: IFFALSE 5458
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5435: LD_EXP 40
5439: PPUSH
5440: LD_EXP 67
5444: PPUSH
5445: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5449: LD_INT 4
5451: PPUSH
5452: CALL_OW 67
// end ;
5456: GO 5415
// ComStop ( Ara2 ) ;
5458: LD_EXP 40
5462: PPUSH
5463: CALL_OW 141
// ComHold ( Ara2 ) ;
5467: LD_EXP 40
5471: PPUSH
5472: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5476: LD_EXP 40
5480: PPUSH
5481: LD_INT 2
5483: PPUSH
5484: LD_INT 10
5486: PPUSH
5487: CALL_OW 290
// a := GetFuel ( AraCar1 ) ;
5491: LD_ADDR_VAR 0 2
5495: PUSH
5496: LD_EXP 44
5500: PPUSH
5501: CALL_OW 261
5505: ST_TO_ADDR
// while GetFuel ( AraCar1 ) <= a do
5506: LD_EXP 44
5510: PPUSH
5511: CALL_OW 261
5515: PUSH
5516: LD_VAR 0 2
5520: LESSEQUAL
5521: IFFALSE 5546
// begin ComRefuel ( Ara2 , AraCar1 ) ;
5523: LD_EXP 40
5527: PPUSH
5528: LD_EXP 44
5532: PPUSH
5533: CALL_OW 150
// wait ( 0 0$1 ) ;
5537: LD_INT 35
5539: PPUSH
5540: CALL_OW 67
// end ;
5544: GO 5506
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5546: LD_EXP 40
5550: PPUSH
5551: LD_INT 2
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: CALL_OW 290
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5561: LD_EXP 40
5565: PPUSH
5566: LD_EXP 67
5570: PPUSH
5571: CALL_OW 296
5575: PUSH
5576: LD_INT 4
5578: GREATER
5579: IFFALSE 5604
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5581: LD_EXP 40
5585: PPUSH
5586: LD_EXP 67
5590: PPUSH
5591: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5595: LD_INT 4
5597: PPUSH
5598: CALL_OW 67
// end ;
5602: GO 5561
// ComStop ( Ara2 ) ;
5604: LD_EXP 40
5608: PPUSH
5609: CALL_OW 141
// ComHold ( Ara2 ) ;
5613: LD_EXP 40
5617: PPUSH
5618: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5622: LD_EXP 40
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 290
// a := GetFuel ( AraCar2 ) ;
5637: LD_ADDR_VAR 0 2
5641: PUSH
5642: LD_EXP 45
5646: PPUSH
5647: CALL_OW 261
5651: ST_TO_ADDR
// while GetFuel ( AraCar2 ) <= a do
5652: LD_EXP 45
5656: PPUSH
5657: CALL_OW 261
5661: PUSH
5662: LD_VAR 0 2
5666: LESSEQUAL
5667: IFFALSE 5692
// begin ComRefuel ( Ara2 , AraCar2 ) ;
5669: LD_EXP 40
5673: PPUSH
5674: LD_EXP 45
5678: PPUSH
5679: CALL_OW 150
// wait ( 0 0$1 ) ;
5683: LD_INT 35
5685: PPUSH
5686: CALL_OW 67
// end ;
5690: GO 5652
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5692: LD_EXP 40
5696: PPUSH
5697: LD_INT 2
5699: PPUSH
5700: LD_INT 0
5702: PPUSH
5703: CALL_OW 290
// ComStop ( Ara2 ) ;
5707: LD_EXP 40
5711: PPUSH
5712: CALL_OW 141
// ComHold ( Ara2 ) ;
5716: LD_EXP 40
5720: PPUSH
5721: CALL_OW 140
// result := true ;
5725: LD_ADDR_VAR 0 1
5729: PUSH
5730: LD_INT 1
5732: ST_TO_ADDR
// end ;
5733: LD_VAR 0 1
5737: RET
// function odnes_neco ( mat , kolik ) ; var a , i ; begin
5738: LD_INT 0
5740: PPUSH
5741: PPUSH
5742: PPUSH
// for i := 1 to ( kolik div 10 ) do
5743: LD_ADDR_VAR 0 5
5747: PUSH
5748: DOUBLE
5749: LD_INT 1
5751: DEC
5752: ST_TO_ADDR
5753: LD_VAR 0 2
5757: PUSH
5758: LD_INT 10
5760: DIV
5761: PUSH
5762: FOR_TO
5763: IFFALSE 5936
// begin while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5765: LD_EXP 40
5769: PPUSH
5770: LD_EXP 67
5774: PPUSH
5775: CALL_OW 296
5779: PUSH
5780: LD_INT 4
5782: GREATER
5783: IFFALSE 5808
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5785: LD_EXP 40
5789: PPUSH
5790: LD_EXP 67
5794: PPUSH
5795: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5799: LD_INT 4
5801: PPUSH
5802: CALL_OW 67
// end ;
5806: GO 5765
// ComHold ( Ara2 ) ;
5808: LD_EXP 40
5812: PPUSH
5813: CALL_OW 140
// SetCargo ( Ara2 , mat , 10 ) ;
5817: LD_EXP 40
5821: PPUSH
5822: LD_VAR 0 1
5826: PPUSH
5827: LD_INT 10
5829: PPUSH
5830: CALL_OW 290
// a := GetCargo ( AraCar2 , mat ) ;
5834: LD_ADDR_VAR 0 4
5838: PUSH
5839: LD_EXP 45
5843: PPUSH
5844: LD_VAR 0 1
5848: PPUSH
5849: CALL_OW 289
5853: ST_TO_ADDR
// while GetCargo ( AraCar2 , mat ) <= a do
5854: LD_EXP 45
5858: PPUSH
5859: LD_VAR 0 1
5863: PPUSH
5864: CALL_OW 289
5868: PUSH
5869: LD_VAR 0 4
5873: LESSEQUAL
5874: IFFALSE 5899
// begin ComMoveUnit ( Ara2 , AraCar2 ) ;
5876: LD_EXP 40
5880: PPUSH
5881: LD_EXP 45
5885: PPUSH
5886: CALL_OW 112
// wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// end ;
5897: GO 5854
// SetCargo ( Ara2 , mat , 0 ) ;
5899: LD_EXP 40
5903: PPUSH
5904: LD_VAR 0 1
5908: PPUSH
5909: LD_INT 0
5911: PPUSH
5912: CALL_OW 290
// ComStop ( Ara2 ) ;
5916: LD_EXP 40
5920: PPUSH
5921: CALL_OW 141
// ComHold ( Ara2 ) ;
5925: LD_EXP 40
5929: PPUSH
5930: CALL_OW 140
// end ;
5934: GO 5762
5936: POP
5937: POP
// result := true ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 1
5945: ST_TO_ADDR
// end ;
5946: LD_VAR 0 3
5950: RET
// every 0 0$1 do var mt ;
5951: GO 5953
5953: DISABLE
5954: LD_INT 0
5956: PPUSH
// begin if arabi_time <> 0 then
5957: LD_EXP 1
5961: PUSH
5962: LD_INT 0
5964: NONEQUAL
5965: IFFALSE 6113
// if arabi_time > 1 then
5967: LD_EXP 1
5971: PUSH
5972: LD_INT 1
5974: GREATER
5975: IFFALSE 6113
// begin wait ( arabi_time ) ;
5977: LD_EXP 1
5981: PPUSH
5982: CALL_OW 67
// mt := tick + 3 3$0 ;
5986: LD_ADDR_VAR 0 1
5990: PUSH
5991: LD_OWVAR 1
5995: PUSH
5996: LD_INT 6300
5998: PLUS
5999: ST_TO_ADDR
// while Getside ( rudepot1 ) <> you and mt > tick do
6000: LD_EXP 67
6004: PPUSH
6005: CALL_OW 255
6009: PUSH
6010: LD_EXP 47
6014: NONEQUAL
6015: PUSH
6016: LD_VAR 0 1
6020: PUSH
6021: LD_OWVAR 1
6025: GREATER
6026: AND
6027: IFFALSE 6038
// wait ( 0 0$3 ) ;
6029: LD_INT 105
6031: PPUSH
6032: CALL_OW 67
6036: GO 6000
// if Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 then
6038: LD_EXP 67
6042: PPUSH
6043: CALL_OW 255
6047: PUSH
6048: LD_EXP 47
6052: EQUAL
6053: PUSH
6054: LD_INT 22
6056: PUSH
6057: LD_EXP 47
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 2
6068: PUSH
6069: LD_INT 21
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 21
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PPUSH
6098: CALL_OW 69
6102: PUSH
6103: LD_INT 0
6105: GREATER
6106: AND
6107: IFFALSE 6113
// arabi ;
6109: CALL 6205 0 0
// end ; end ;
6113: PPOPN 1
6115: END
// every 27 27$0 trigger arabi_time = 0 and Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do
6116: LD_EXP 1
6120: PUSH
6121: LD_INT 0
6123: EQUAL
6124: PUSH
6125: LD_EXP 67
6129: PPUSH
6130: CALL_OW 255
6134: PUSH
6135: LD_EXP 47
6139: EQUAL
6140: AND
6141: PUSH
6142: LD_INT 22
6144: PUSH
6145: LD_EXP 47
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 21
6159: PUSH
6160: LD_INT 1
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_INT 21
6169: PUSH
6170: LD_INT 2
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PUSH
6191: LD_INT 0
6193: GREATER
6194: AND
6195: IFFALSE 6204
6197: GO 6199
6199: DISABLE
// begin arabi ;
6200: CALL 6205 0 0
// end ;
6204: END
// export kecy , mina1 , mina3 ; function arabi ; var cekani , qr , nabidka , i , a , mytick , to_reach , ara1_faze , ara3_faze , odmitl_v_query ; begin
6205: LD_INT 0
6207: PPUSH
6208: PPUSH
6209: PPUSH
6210: PPUSH
6211: PPUSH
6212: PPUSH
6213: PPUSH
6214: PPUSH
6215: PPUSH
6216: PPUSH
6217: PPUSH
// PlaceUnitArea ( Ara1 , rus_mat_l , false ) ;
6218: LD_EXP 39
6222: PPUSH
6223: LD_INT 3
6225: PPUSH
6226: LD_INT 0
6228: PPUSH
6229: CALL_OW 49
// PlaceUnitArea ( Ara2 , rus_mat_l , false ) ;
6233: LD_EXP 40
6237: PPUSH
6238: LD_INT 3
6240: PPUSH
6241: LD_INT 0
6243: PPUSH
6244: CALL_OW 49
// PlaceUnitArea ( Ara3 , rus_mat_l , false ) ;
6248: LD_EXP 41
6252: PPUSH
6253: LD_INT 3
6255: PPUSH
6256: LD_INT 0
6258: PPUSH
6259: CALL_OW 49
// PlaceUnitArea ( AraCar1 , rus_mat_l , false ) ;
6263: LD_EXP 44
6267: PPUSH
6268: LD_INT 3
6270: PPUSH
6271: LD_INT 0
6273: PPUSH
6274: CALL_OW 49
// PlaceUnitArea ( AraCar2 , rus_mat_l , false ) ;
6278: LD_EXP 45
6282: PPUSH
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 0
6288: PPUSH
6289: CALL_OW 49
// ComHold ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] ) ;
6293: LD_EXP 39
6297: PUSH
6298: LD_EXP 40
6302: PUSH
6303: LD_EXP 41
6307: PUSH
6308: LD_EXP 42
6312: PUSH
6313: LD_EXP 43
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 140
// DialogueOn ;
6329: CALL_OW 6
// SayRadio ( Ara1 , D8-Ar1-1 ) ;
6333: LD_EXP 39
6337: PPUSH
6338: LD_STRING D8-Ar1-1
6340: PPUSH
6341: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6345: LD_EXP 17
6349: PPUSH
6350: LD_STRING D8-JMM-1
6352: PPUSH
6353: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-2 ) ;
6357: LD_EXP 39
6361: PPUSH
6362: LD_STRING D8-Ar1-2
6364: PPUSH
6365: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6369: LD_EXP 17
6373: PPUSH
6374: LD_STRING D8-JMM-2
6376: PPUSH
6377: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-3 ) ;
6381: LD_EXP 39
6385: PPUSH
6386: LD_STRING D8-Ar1-3
6388: PPUSH
6389: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6393: LD_EXP 17
6397: PPUSH
6398: LD_STRING D8-JMM-3
6400: PPUSH
6401: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-4 ) ;
6405: LD_EXP 39
6409: PPUSH
6410: LD_STRING D8-Ar1-4
6412: PPUSH
6413: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6417: LD_EXP 17
6421: PPUSH
6422: LD_STRING D8-JMM-4
6424: PPUSH
6425: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-5 ) ;
6429: LD_EXP 39
6433: PPUSH
6434: LD_STRING D8-Ar1-5
6436: PPUSH
6437: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6441: LD_EXP 17
6445: PPUSH
6446: LD_STRING D8-JMM-5
6448: PPUSH
6449: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-6 ) ;
6453: LD_EXP 39
6457: PPUSH
6458: LD_STRING D8-Ar1-6
6460: PPUSH
6461: CALL_OW 94
// SayRadio ( Ara2 , D8-Ar2-6 ) ;
6465: LD_EXP 40
6469: PPUSH
6470: LD_STRING D8-Ar2-6
6472: PPUSH
6473: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6477: LD_EXP 17
6481: PPUSH
6482: LD_STRING D8-JMM-6
6484: PPUSH
6485: CALL_OW 88
// SayRadio ( Ara2 , D8-Ar2-7 ) ;
6489: LD_EXP 40
6493: PPUSH
6494: LD_STRING D8-Ar2-7
6496: PPUSH
6497: CALL_OW 94
// Aqr1 := Query ( QBarracks ) ;
6501: LD_ADDR_EXP 37
6505: PUSH
6506: LD_STRING QBarracks
6508: PPUSH
6509: CALL_OW 97
6513: ST_TO_ADDR
// case Aqr1 of 1 :
6514: LD_EXP 37
6518: PUSH
6519: LD_INT 1
6521: DOUBLE
6522: EQUAL
6523: IFTRUE 6527
6525: GO 6554
6527: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6528: LD_EXP 17
6532: PPUSH
6533: LD_STRING D8a-JMM-1
6535: PPUSH
6536: CALL_OW 88
// SayRadio ( Ara1 , D8a-Ar1-1 ) ;
6540: LD_EXP 39
6544: PPUSH
6545: LD_STRING D8a-Ar1-1
6547: PPUSH
6548: CALL_OW 94
// end ; 2 :
6552: GO 6730
6554: LD_INT 2
6556: DOUBLE
6557: EQUAL
6558: IFTRUE 6562
6560: GO 6686
6562: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6563: LD_EXP 17
6567: PPUSH
6568: LD_STRING D8b-JMM-1
6570: PPUSH
6571: CALL_OW 88
// SayRadio ( Ara1 , D8b-Ar1-1 ) ;
6575: LD_EXP 39
6579: PPUSH
6580: LD_STRING D8b-Ar1-1
6582: PPUSH
6583: CALL_OW 94
// Aqr2 := Query ( QInfo ) ;
6587: LD_ADDR_EXP 38
6591: PUSH
6592: LD_STRING QInfo
6594: PPUSH
6595: CALL_OW 97
6599: ST_TO_ADDR
// case Aqr2 of 1 :
6600: LD_EXP 38
6604: PUSH
6605: LD_INT 1
6607: DOUBLE
6608: EQUAL
6609: IFTRUE 6613
6611: GO 6640
6613: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6614: LD_EXP 17
6618: PPUSH
6619: LD_STRING D8b1-JMM-1
6621: PPUSH
6622: CALL_OW 88
// SayRadio ( Ara1 , D8b1-Ar1-1 ) ;
6626: LD_EXP 39
6630: PPUSH
6631: LD_STRING D8b1-Ar1-1
6633: PPUSH
6634: CALL_OW 94
// end ; 2 :
6638: GO 6684
6640: LD_INT 2
6642: DOUBLE
6643: EQUAL
6644: IFTRUE 6648
6646: GO 6683
6648: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6649: LD_EXP 17
6653: PPUSH
6654: LD_STRING D8b2-JMM-1
6656: PPUSH
6657: CALL_OW 88
// SayRadio ( Ara1 , D8b2-Ar1-1 ) ;
6661: LD_EXP 39
6665: PPUSH
6666: LD_STRING D8b2-Ar1-1
6668: PPUSH
6669: CALL_OW 94
// odmitl_v_query := true ;
6673: LD_ADDR_VAR 0 11
6677: PUSH
6678: LD_INT 1
6680: ST_TO_ADDR
// end ; end ;
6681: GO 6684
6683: POP
// end ; 3 :
6684: GO 6730
6686: LD_INT 3
6688: DOUBLE
6689: EQUAL
6690: IFTRUE 6694
6692: GO 6729
6694: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6695: LD_EXP 17
6699: PPUSH
6700: LD_STRING D8c-JMM-1
6702: PPUSH
6703: CALL_OW 88
// odmitl_v_query := true ;
6707: LD_ADDR_VAR 0 11
6711: PUSH
6712: LD_INT 1
6714: ST_TO_ADDR
// SayRadio ( Ara1 , D8c-Ar1-1 ) ;
6715: LD_EXP 39
6719: PPUSH
6720: LD_STRING D8c-Ar1-1
6722: PPUSH
6723: CALL_OW 94
// end ; end ;
6727: GO 6730
6729: POP
// DialogueOff ;
6730: CALL_OW 7
// if Aqr1 = 1 or ( Aqr1 = 2 and Aqr2 = 1 ) then
6734: LD_EXP 37
6738: PUSH
6739: LD_INT 1
6741: EQUAL
6742: PUSH
6743: LD_EXP 37
6747: PUSH
6748: LD_INT 2
6750: EQUAL
6751: PUSH
6752: LD_EXP 38
6756: PUSH
6757: LD_INT 1
6759: EQUAL
6760: AND
6761: OR
6762: IFFALSE 9555
// begin ComMoveToArea ( AraCar1 , pod_base ) ;
6764: LD_EXP 44
6768: PPUSH
6769: LD_INT 30
6771: PPUSH
6772: CALL_OW 113
// wait ( 0 0$1 ) ;
6776: LD_INT 35
6778: PPUSH
6779: CALL_OW 67
// ComMoveToArea ( AraCar2 , pod_base ) ;
6783: LD_EXP 45
6787: PPUSH
6788: LD_INT 30
6790: PPUSH
6791: CALL_OW 113
// ComWait ( [ Ara1 , Ara2 , Ara3 ] , 0 0$4 ) ;
6795: LD_EXP 39
6799: PUSH
6800: LD_EXP 40
6804: PUSH
6805: LD_EXP 41
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PPUSH
6815: LD_INT 140
6817: PPUSH
6818: CALL_OW 142
// AddComMoveToArea ( [ Ara1 , Ara2 , Ara3 ] , in_base ) ;
6822: LD_EXP 39
6826: PUSH
6827: LD_EXP 40
6831: PUSH
6832: LD_EXP 41
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: LIST
6841: PPUSH
6842: LD_INT 21
6844: PPUSH
6845: CALL_OW 173
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 ] , 95 , 98 ) ;
6849: LD_EXP 39
6853: PUSH
6854: LD_EXP 40
6858: PUSH
6859: LD_EXP 41
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: LIST
6868: PPUSH
6869: LD_INT 95
6871: PPUSH
6872: LD_INT 98
6874: PPUSH
6875: CALL_OW 171
// AddComMoveToArea ( [ Ara1 , Ara3 ] , for_charge ) ;
6879: LD_EXP 39
6883: PUSH
6884: LD_EXP 41
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PPUSH
6893: LD_INT 29
6895: PPUSH
6896: CALL_OW 173
// AddComPlaceRemoteCharge ( Ara1 , 0 , 0 , rudepot1 ) ;
6900: LD_EXP 39
6904: PPUSH
6905: LD_INT 0
6907: PPUSH
6908: LD_INT 0
6910: PPUSH
6911: LD_EXP 67
6915: PPUSH
6916: CALL_OW 193
// AddComPlaceRemoteCharge ( Ara3 , 0 , 0 , rudepot1 ) ;
6920: LD_EXP 41
6924: PPUSH
6925: LD_INT 0
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: LD_EXP 67
6935: PPUSH
6936: CALL_OW 193
// AddComMoveToArea ( [ Ara1 , Ara3 ] , pod_base ) ;
6940: LD_EXP 39
6944: PUSH
6945: LD_EXP 41
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: PPUSH
6954: LD_INT 30
6956: PPUSH
6957: CALL_OW 173
// mytick := tick + 2 2$30 ;
6961: LD_ADDR_VAR 0 7
6965: PUSH
6966: LD_OWVAR 1
6970: PUSH
6971: LD_INT 5250
6973: PLUS
6974: ST_TO_ADDR
// to_reach := [ AraCar1 , AraCar2 , Ara3 , Ara2 , Ara1 ] ;
6975: LD_ADDR_VAR 0 8
6979: PUSH
6980: LD_EXP 44
6984: PUSH
6985: LD_EXP 45
6989: PUSH
6990: LD_EXP 41
6994: PUSH
6995: LD_EXP 40
6999: PUSH
7000: LD_EXP 39
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: LIST
7009: LIST
7010: LIST
7011: ST_TO_ADDR
// while mytick > tick and to_reach do
7012: LD_VAR 0 7
7016: PUSH
7017: LD_OWVAR 1
7021: GREATER
7022: PUSH
7023: LD_VAR 0 8
7027: AND
7028: IFFALSE 7288
// begin if IsInArea ( AraCar1 , pod_base ) or not IsOk ( AraCar1 ) then
7030: LD_EXP 44
7034: PPUSH
7035: LD_INT 30
7037: PPUSH
7038: CALL_OW 308
7042: PUSH
7043: LD_EXP 44
7047: PPUSH
7048: CALL_OW 302
7052: NOT
7053: OR
7054: IFFALSE 7075
// to_reach := to_reach diff [ AraCar1 ] ;
7056: LD_ADDR_VAR 0 8
7060: PUSH
7061: LD_VAR 0 8
7065: PUSH
7066: LD_EXP 44
7070: PUSH
7071: EMPTY
7072: LIST
7073: DIFF
7074: ST_TO_ADDR
// if IsInArea ( AraCar2 , pod_base ) or not IsOk ( AraCar2 ) then
7075: LD_EXP 45
7079: PPUSH
7080: LD_INT 30
7082: PPUSH
7083: CALL_OW 308
7087: PUSH
7088: LD_EXP 45
7092: PPUSH
7093: CALL_OW 302
7097: NOT
7098: OR
7099: IFFALSE 7120
// to_reach := to_reach diff [ AraCar2 ] ;
7101: LD_ADDR_VAR 0 8
7105: PUSH
7106: LD_VAR 0 8
7110: PUSH
7111: LD_EXP 45
7115: PUSH
7116: EMPTY
7117: LIST
7118: DIFF
7119: ST_TO_ADDR
// if IsInArea ( Ara1 , in_base ) or not IsOk ( Ara1 ) then
7120: LD_EXP 39
7124: PPUSH
7125: LD_INT 21
7127: PPUSH
7128: CALL_OW 308
7132: PUSH
7133: LD_EXP 39
7137: PPUSH
7138: CALL_OW 302
7142: NOT
7143: OR
7144: IFFALSE 7165
// to_reach := to_reach diff [ Ara1 ] ;
7146: LD_ADDR_VAR 0 8
7150: PUSH
7151: LD_VAR 0 8
7155: PUSH
7156: LD_EXP 39
7160: PUSH
7161: EMPTY
7162: LIST
7163: DIFF
7164: ST_TO_ADDR
// if IsInArea ( Ara2 , in_base ) or not IsOk ( Ara2 ) then
7165: LD_EXP 40
7169: PPUSH
7170: LD_INT 21
7172: PPUSH
7173: CALL_OW 308
7177: PUSH
7178: LD_EXP 40
7182: PPUSH
7183: CALL_OW 302
7187: NOT
7188: OR
7189: IFFALSE 7210
// to_reach := to_reach diff [ Ara2 ] ;
7191: LD_ADDR_VAR 0 8
7195: PUSH
7196: LD_VAR 0 8
7200: PUSH
7201: LD_EXP 40
7205: PUSH
7206: EMPTY
7207: LIST
7208: DIFF
7209: ST_TO_ADDR
// if IsInArea ( Ara3 , in_base ) or not IsOk ( Ara3 ) then
7210: LD_EXP 41
7214: PPUSH
7215: LD_INT 21
7217: PPUSH
7218: CALL_OW 308
7222: PUSH
7223: LD_EXP 41
7227: PPUSH
7228: CALL_OW 302
7232: NOT
7233: OR
7234: IFFALSE 7255
// to_reach := to_reach diff [ Ara3 ] ;
7236: LD_ADDR_VAR 0 8
7240: PUSH
7241: LD_VAR 0 8
7245: PUSH
7246: LD_EXP 41
7250: PUSH
7251: EMPTY
7252: LIST
7253: DIFF
7254: ST_TO_ADDR
// ComMoveToArea ( AraCar1 , pod_base ) ;
7255: LD_EXP 44
7259: PPUSH
7260: LD_INT 30
7262: PPUSH
7263: CALL_OW 113
// ComMoveToArea ( AraCar2 , pod_base ) ;
7267: LD_EXP 45
7271: PPUSH
7272: LD_INT 30
7274: PPUSH
7275: CALL_OW 113
// wait ( 0 0$1 ) ;
7279: LD_INT 35
7281: PPUSH
7282: CALL_OW 67
// end ;
7286: GO 7012
// if Aqr1 = 1 then
7288: LD_EXP 37
7292: PUSH
7293: LD_INT 1
7295: EQUAL
7296: IFFALSE 7561
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7298: LD_EXP 67
7302: PPUSH
7303: CALL_OW 274
7307: PPUSH
7308: LD_INT 2
7310: PPUSH
7311: CALL_OW 275
7315: PUSH
7316: LD_INT 60
7318: LESS
7319: IFFALSE 7524
// begin DialogueOn ;
7321: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7325: LD_EXP 41
7329: PPUSH
7330: LD_STRING D9a-FAr1-1
7332: PPUSH
7333: CALL_OW 88
7337: IFFALSE 7351
// Say ( JMM , D9a-JMM-1 ) ;
7339: LD_EXP 17
7343: PPUSH
7344: LD_STRING D9a-JMM-1
7346: PPUSH
7347: CALL_OW 88
// DialogueOff ;
7351: CALL_OW 7
// cekani := 0 ;
7355: LD_ADDR_VAR 0 2
7359: PUSH
7360: LD_INT 0
7362: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 do
7363: LD_VAR 0 2
7367: PUSH
7368: LD_INT 60
7370: LESS
7371: PUSH
7372: LD_EXP 67
7376: PPUSH
7377: CALL_OW 274
7381: PPUSH
7382: LD_INT 2
7384: PPUSH
7385: CALL_OW 275
7389: PUSH
7390: LD_INT 60
7392: LESS
7393: AND
7394: IFFALSE 7419
// begin Wait ( 0 0$1 ) ;
7396: LD_INT 35
7398: PPUSH
7399: CALL_OW 67
// cekani := cekani + 1 ;
7403: LD_ADDR_VAR 0 2
7407: PUSH
7408: LD_VAR 0 2
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: ST_TO_ADDR
// end ;
7417: GO 7363
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7419: LD_EXP 67
7423: PPUSH
7424: CALL_OW 274
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: CALL_OW 275
7436: PUSH
7437: LD_INT 60
7439: LESS
7440: IFFALSE 7485
// begin DialogueOn ;
7442: CALL_OW 6
// Say ( Ara1 , D9a2-Ar1-1 ) ;
7446: LD_EXP 39
7450: PPUSH
7451: LD_STRING D9a2-Ar1-1
7453: PPUSH
7454: CALL_OW 88
// DialogueOff ;
7458: CALL_OW 7
// Aqr1 := 2 ;
7462: LD_ADDR_EXP 37
7466: PUSH
7467: LD_INT 2
7469: ST_TO_ADDR
// Aqr2 := Query ( QInfo ) ;
7470: LD_ADDR_EXP 38
7474: PUSH
7475: LD_STRING QInfo
7477: PPUSH
7478: CALL_OW 97
7482: ST_TO_ADDR
// end else
7483: GO 7522
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7485: LD_EXP 67
7489: PPUSH
7490: CALL_OW 274
7494: PPUSH
7495: LD_INT 2
7497: PPUSH
7498: LD_INT 60
7500: NEG
7501: PPUSH
7502: CALL_OW 276
// if odnes_jeden_oil then
7506: CALL 5411 0 0
7510: IFFALSE 7522
// if odnes_jeden_oil then
7512: CALL 5411 0 0
7516: IFFALSE 7522
// odnes_jeden_oil ;
7518: CALL 5411 0 0
// end ; end else
7522: GO 7561
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7524: LD_EXP 67
7528: PPUSH
7529: CALL_OW 274
7533: PPUSH
7534: LD_INT 2
7536: PPUSH
7537: LD_INT 60
7539: NEG
7540: PPUSH
7541: CALL_OW 276
// if odnes_jeden_oil then
7545: CALL 5411 0 0
7549: IFFALSE 7561
// if odnes_jeden_oil then
7551: CALL 5411 0 0
7555: IFFALSE 7561
// odnes_jeden_oil ;
7557: CALL 5411 0 0
// end ; end ; if ( Aqr1 = 2 ) and ( Aqr2 = 1 ) then
7561: LD_EXP 37
7565: PUSH
7566: LD_INT 2
7568: EQUAL
7569: PUSH
7570: LD_EXP 38
7574: PUSH
7575: LD_INT 1
7577: EQUAL
7578: AND
7579: IFFALSE 7831
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7581: LD_EXP 67
7585: PPUSH
7586: CALL_OW 274
7590: PPUSH
7591: LD_INT 2
7593: PPUSH
7594: CALL_OW 275
7598: PUSH
7599: LD_INT 20
7601: LESS
7602: IFFALSE 7798
// begin DialogueOn ;
7604: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7608: LD_EXP 41
7612: PPUSH
7613: LD_STRING D9a-FAr1-1
7615: PPUSH
7616: CALL_OW 88
7620: IFFALSE 7634
// Say ( JMM , D9a-JMM-1 ) ;
7622: LD_EXP 17
7626: PPUSH
7627: LD_STRING D9a-JMM-1
7629: PPUSH
7630: CALL_OW 88
// DialogueOff ;
7634: CALL_OW 7
// cekani := 0 ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 0
7645: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 do
7646: LD_VAR 0 2
7650: PUSH
7651: LD_INT 60
7653: LESS
7654: PUSH
7655: LD_EXP 67
7659: PPUSH
7660: CALL_OW 274
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: CALL_OW 275
7672: PUSH
7673: LD_INT 20
7675: LESS
7676: AND
7677: IFFALSE 7702
// begin Wait ( 0 0$1 ) ;
7679: LD_INT 35
7681: PPUSH
7682: CALL_OW 67
// cekani := cekani + 1 ;
7686: LD_ADDR_VAR 0 2
7690: PUSH
7691: LD_VAR 0 2
7695: PUSH
7696: LD_INT 1
7698: PLUS
7699: ST_TO_ADDR
// end ;
7700: GO 7646
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7702: LD_EXP 67
7706: PPUSH
7707: CALL_OW 274
7711: PPUSH
7712: LD_INT 2
7714: PPUSH
7715: CALL_OW 275
7719: PUSH
7720: LD_INT 20
7722: LESS
7723: IFFALSE 7763
// begin DialogueOn ;
7725: CALL_OW 6
// Say ( Ara1 , D9a3-Ar1-1 ) ;
7729: LD_EXP 39
7733: PPUSH
7734: LD_STRING D9a3-Ar1-1
7736: PPUSH
7737: CALL_OW 88
// DialogueOff ;
7741: CALL_OW 7
// Aqr1 := 2 ;
7745: LD_ADDR_EXP 37
7749: PUSH
7750: LD_INT 2
7752: ST_TO_ADDR
// Aqr2 := 0 ;
7753: LD_ADDR_EXP 38
7757: PUSH
7758: LD_INT 0
7760: ST_TO_ADDR
// end else
7761: GO 7796
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7763: LD_EXP 67
7767: PPUSH
7768: CALL_OW 274
7772: PPUSH
7773: LD_INT 2
7775: PPUSH
7776: LD_INT 20
7778: NEG
7779: PPUSH
7780: CALL_OW 276
// odnes_jeden_oil ;
7784: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7788: LD_ADDR_EXP 56
7792: PUSH
7793: LD_INT 1
7795: ST_TO_ADDR
// end ; end else
7796: GO 7831
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7798: LD_EXP 67
7802: PPUSH
7803: CALL_OW 274
7807: PPUSH
7808: LD_INT 2
7810: PPUSH
7811: LD_INT 20
7813: NEG
7814: PPUSH
7815: CALL_OW 276
// odnes_jeden_oil ;
7819: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7823: LD_ADDR_EXP 56
7827: PUSH
7828: LD_INT 1
7830: ST_TO_ADDR
// end ; end ; if Aqr1 = 1 then
7831: LD_EXP 37
7835: PUSH
7836: LD_INT 1
7838: EQUAL
7839: IFFALSE 9279
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
7841: LD_EXP 67
7845: PPUSH
7846: CALL_OW 274
7850: PPUSH
7851: LD_INT 1
7853: PPUSH
7854: CALL_OW 275
7858: PUSH
7859: LD_INT 25
7861: LESS
7862: IFFALSE 7898
// begin DialogueOn ;
7864: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1 ) then
7868: LD_EXP 40
7872: PPUSH
7873: LD_STRING D9b-Ar2-1
7875: PPUSH
7876: CALL_OW 88
7880: IFFALSE 7894
// Say ( JMM , D9b-JMM-1 ) ;
7882: LD_EXP 17
7886: PPUSH
7887: LD_STRING D9b-JMM-1
7889: PPUSH
7890: CALL_OW 88
// DialogueOff ;
7894: CALL_OW 7
// end ; cekani := 0 ;
7898: LD_ADDR_VAR 0 2
7902: PUSH
7903: LD_INT 0
7905: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
7906: LD_VAR 0 2
7910: PUSH
7911: LD_INT 120
7913: LESS
7914: PUSH
7915: LD_EXP 67
7919: PPUSH
7920: CALL_OW 274
7924: PPUSH
7925: LD_INT 1
7927: PPUSH
7928: CALL_OW 275
7932: PUSH
7933: LD_INT 25
7935: LESS
7936: AND
7937: IFFALSE 7962
// begin Wait ( 0 0$1 ) ;
7939: LD_INT 35
7941: PPUSH
7942: CALL_OW 67
// cekani := cekani + 1 ;
7946: LD_ADDR_VAR 0 2
7950: PUSH
7951: LD_VAR 0 2
7955: PUSH
7956: LD_INT 1
7958: PLUS
7959: ST_TO_ADDR
// end ;
7960: GO 7906
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
7962: LD_EXP 67
7966: PPUSH
7967: CALL_OW 274
7971: PPUSH
7972: LD_INT 1
7974: PPUSH
7975: CALL_OW 275
7979: PUSH
7980: LD_INT 25
7982: GREATEREQUAL
7983: IFFALSE 9174
// begin ComMoveXY ( Ara2 , 94 , 101 ) ;
7985: LD_EXP 40
7989: PPUSH
7990: LD_INT 94
7992: PPUSH
7993: LD_INT 101
7995: PPUSH
7996: CALL_OW 111
// while not UnitFilter ( [ Ara2 ] , [ [ f_distxy , 94 , 101 , 2 ] ] ) do
8000: LD_EXP 40
8004: PUSH
8005: EMPTY
8006: LIST
8007: PPUSH
8008: LD_INT 92
8010: PUSH
8011: LD_INT 94
8013: PUSH
8014: LD_INT 101
8016: PUSH
8017: LD_INT 2
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: PPUSH
8029: CALL_OW 72
8033: NOT
8034: IFFALSE 8045
// wait ( 0 0$0.3 ) ;
8036: LD_INT 10
8038: PPUSH
8039: CALL_OW 67
8043: GO 8000
// RemoveEnvironment ( 91 , 99 ) ;
8045: LD_INT 91
8047: PPUSH
8048: LD_INT 99
8050: PPUSH
8051: CALL_OW 347
// RemoveEnvironment ( 91 , 101 ) ;
8055: LD_INT 91
8057: PPUSH
8058: LD_INT 101
8060: PPUSH
8061: CALL_OW 347
// RemoveEnvironment ( 94 , 102 ) ;
8065: LD_INT 94
8067: PPUSH
8068: LD_INT 102
8070: PPUSH
8071: CALL_OW 347
// RemoveEnvironment ( 93 , 100 ) ;
8075: LD_INT 93
8077: PPUSH
8078: LD_INT 100
8080: PPUSH
8081: CALL_OW 347
// SetAttitude ( arabians , you , att_friend , true ) ;
8085: LD_EXP 50
8089: PPUSH
8090: LD_EXP 47
8094: PPUSH
8095: LD_INT 1
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 80
// while not ArmStarted do
8105: LD_EXP 74
8109: NOT
8110: IFFALSE 8210
// begin wait ( 0 0$0.3 ) ;
8112: LD_INT 10
8114: PPUSH
8115: CALL_OW 67
// SetSide ( ara2 , Getside ( rudepot1 ) ) ;
8119: LD_EXP 40
8123: PPUSH
8124: LD_EXP 67
8128: PPUSH
8129: CALL_OW 255
8133: PPUSH
8134: CALL_OW 235
// ComBuild ( Ara2 , b_armoury , 92 , 101 , 1 ) ;
8138: LD_EXP 40
8142: PPUSH
8143: LD_INT 4
8145: PPUSH
8146: LD_INT 92
8148: PPUSH
8149: LD_INT 101
8151: PPUSH
8152: LD_INT 1
8154: PPUSH
8155: CALL_OW 145
// ComMoveXY ( FilterAllUnits ( [ [ f_distxy , 92 , 101 , 6 ] , [ f_side , arabians ] ] ) , 93 , 90 ) ;
8159: LD_INT 92
8161: PUSH
8162: LD_INT 92
8164: PUSH
8165: LD_INT 101
8167: PUSH
8168: LD_INT 6
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 22
8179: PUSH
8180: LD_EXP 50
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PPUSH
8193: CALL_OW 69
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: LD_INT 90
8203: PPUSH
8204: CALL_OW 111
// end ;
8208: GO 8105
// SetSide ( ara2 , arabians ) ;
8210: LD_EXP 40
8214: PPUSH
8215: LD_EXP 50
8219: PPUSH
8220: CALL_OW 235
// wait ( 0 0$1 ) ;
8224: LD_INT 35
8226: PPUSH
8227: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8231: LD_EXP 39
8235: PUSH
8236: LD_EXP 41
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PPUSH
8245: LD_INT 30
8247: PUSH
8248: LD_INT 4
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PUSH
8255: LD_INT 23
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PPUSH
8269: CALL_OW 69
8273: PPUSH
8274: CALL_OW 112
// while not ArmBuild and FilterAllUnits ( [ [ f_nation , nation_arabian ] , [ f_type , unit_building ] ] ) do
8278: LD_EXP 71
8282: NOT
8283: PUSH
8284: LD_INT 23
8286: PUSH
8287: LD_INT 2
8289: PUSH
8290: EMPTY
8291: LIST
8292: LIST
8293: PUSH
8294: LD_INT 21
8296: PUSH
8297: LD_INT 3
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PPUSH
8308: CALL_OW 69
8312: AND
8313: IFFALSE 8324
// wait ( 0 0$1 ) ;
8315: LD_INT 35
8317: PPUSH
8318: CALL_OW 67
8322: GO 8278
// SetAttitude ( arabians , you , att_neutral , true ) ;
8324: LD_EXP 50
8328: PPUSH
8329: LD_EXP 47
8333: PPUSH
8334: LD_INT 0
8336: PPUSH
8337: LD_INT 1
8339: PPUSH
8340: CALL_OW 80
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
8344: LD_EXP 67
8348: PPUSH
8349: CALL_OW 274
8353: PPUSH
8354: LD_INT 1
8356: PPUSH
8357: CALL_OW 275
8361: PUSH
8362: LD_INT 25
8364: LESS
8365: IFFALSE 8401
// begin DialogueOn ;
8367: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1a ) then
8371: LD_EXP 40
8375: PPUSH
8376: LD_STRING D9b-Ar2-1a
8378: PPUSH
8379: CALL_OW 88
8383: IFFALSE 8397
// Say ( JMM , D9b-JMM-1 ) ;
8385: LD_EXP 17
8389: PPUSH
8390: LD_STRING D9b-JMM-1
8392: PPUSH
8393: CALL_OW 88
// DialogueOff ;
8397: CALL_OW 7
// end ; cekani := 0 ;
8401: LD_ADDR_VAR 0 2
8405: PUSH
8406: LD_INT 0
8408: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
8409: LD_VAR 0 2
8413: PUSH
8414: LD_INT 120
8416: LESS
8417: PUSH
8418: LD_EXP 67
8422: PPUSH
8423: CALL_OW 274
8427: PPUSH
8428: LD_INT 1
8430: PPUSH
8431: CALL_OW 275
8435: PUSH
8436: LD_INT 25
8438: LESS
8439: AND
8440: IFFALSE 8465
// begin Wait ( 0 0$1 ) ;
8442: LD_INT 35
8444: PPUSH
8445: CALL_OW 67
// cekani := cekani + 1 ;
8449: LD_ADDR_VAR 0 2
8453: PUSH
8454: LD_VAR 0 2
8458: PUSH
8459: LD_INT 1
8461: PLUS
8462: ST_TO_ADDR
// end ;
8463: GO 8409
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
8465: LD_EXP 67
8469: PPUSH
8470: CALL_OW 274
8474: PPUSH
8475: LD_INT 1
8477: PPUSH
8478: CALL_OW 275
8482: PUSH
8483: LD_INT 25
8485: GREATEREQUAL
8486: IFFALSE 9174
// begin wait ( 0 0$1 ) ;
8488: LD_INT 35
8490: PPUSH
8491: CALL_OW 67
// SetRestrict ( b_barracks , you , state_enabled ) ;
8495: LD_INT 5
8497: PPUSH
8498: LD_EXP 47
8502: PPUSH
8503: LD_INT 1
8505: PPUSH
8506: CALL_OW 324
// SetAttitude ( arabians , you , att_friend , true ) ;
8510: LD_EXP 50
8514: PPUSH
8515: LD_EXP 47
8519: PPUSH
8520: LD_INT 1
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 80
// ComUpgrade ( FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8530: LD_INT 30
8532: PUSH
8533: LD_INT 4
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: PUSH
8540: LD_INT 23
8542: PUSH
8543: LD_INT 2
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 69
8558: PPUSH
8559: CALL_OW 146
// wait ( 0 0$1 ) ;
8563: LD_INT 35
8565: PPUSH
8566: CALL_OW 67
// SetTech ( tech_Mortar , you , state_researched ) ;
8570: LD_INT 41
8572: PPUSH
8573: LD_EXP 47
8577: PPUSH
8578: LD_INT 2
8580: PPUSH
8581: CALL_OW 322
// wait ( 0 0$1 ) ;
8585: LD_INT 35
8587: PPUSH
8588: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) ) ;
8592: LD_EXP 39
8596: PUSH
8597: LD_EXP 41
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PPUSH
8606: LD_INT 30
8608: PUSH
8609: LD_INT 5
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PUSH
8616: LD_INT 23
8618: PUSH
8619: LD_INT 2
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PPUSH
8630: CALL_OW 69
8634: PPUSH
8635: CALL_OW 112
// while not ArmUpgraded and FilterAllUnits ( [ [ f_nation , nation_arabian ] , [ f_type , unit_building ] ] ) do
8639: LD_EXP 72
8643: NOT
8644: PUSH
8645: LD_INT 23
8647: PUSH
8648: LD_INT 2
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: LD_INT 21
8657: PUSH
8658: LD_INT 3
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: PUSH
8665: EMPTY
8666: LIST
8667: LIST
8668: PPUSH
8669: CALL_OW 69
8673: AND
8674: IFFALSE 8685
// wait ( 0 0$1 ) ;
8676: LD_INT 35
8678: PPUSH
8679: CALL_OW 67
8683: GO 8639
// SetAttitude ( arabians , you , att_neutral , true ) ;
8685: LD_EXP 50
8689: PPUSH
8690: LD_EXP 47
8694: PPUSH
8695: LD_INT 0
8697: PPUSH
8698: LD_INT 1
8700: PPUSH
8701: CALL_OW 80
// DialogueOn ;
8705: CALL_OW 6
// if Say ( Ara2 , D9d-Ar2-1 ) then
8709: LD_EXP 40
8713: PPUSH
8714: LD_STRING D9d-Ar2-1
8716: PPUSH
8717: CALL_OW 88
8721: IFFALSE 8763
// if Say ( Ara1 , D9d-Ar1-1 ) then
8723: LD_EXP 39
8727: PPUSH
8728: LD_STRING D9d-Ar1-1
8730: PPUSH
8731: CALL_OW 88
8735: IFFALSE 8763
// if Say ( JMM , D9d-JMM-1 ) then
8737: LD_EXP 17
8741: PPUSH
8742: LD_STRING D9d-JMM-1
8744: PPUSH
8745: CALL_OW 88
8749: IFFALSE 8763
// Say ( Ara1 , D9d-Ar1-2 ) ;
8751: LD_EXP 39
8755: PPUSH
8756: LD_STRING D9d-Ar1-2
8758: PPUSH
8759: CALL_OW 88
// DialogueOff ;
8763: CALL_OW 7
// nabidka := [ 4 ] ;
8767: LD_ADDR_VAR 0 4
8771: PUSH
8772: LD_INT 4
8774: PUSH
8775: EMPTY
8776: LIST
8777: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) >= 20 then
8778: LD_EXP 67
8782: PPUSH
8783: CALL_OW 274
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: CALL_OW 275
8795: PUSH
8796: LD_INT 20
8798: GREATEREQUAL
8799: IFFALSE 8818
// nabidka := nabidka ^ [ 1 ] ;
8801: LD_ADDR_VAR 0 4
8805: PUSH
8806: LD_VAR 0 4
8810: PUSH
8811: LD_INT 1
8813: PUSH
8814: EMPTY
8815: LIST
8816: ADD
8817: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 50 then
8818: LD_EXP 67
8822: PPUSH
8823: CALL_OW 274
8827: PPUSH
8828: LD_INT 1
8830: PPUSH
8831: CALL_OW 275
8835: PUSH
8836: LD_INT 50
8838: GREATEREQUAL
8839: IFFALSE 8858
// nabidka := nabidka ^ [ 2 ] ;
8841: LD_ADDR_VAR 0 4
8845: PUSH
8846: LD_VAR 0 4
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: EMPTY
8855: LIST
8856: ADD
8857: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) >= 80 then
8858: LD_EXP 67
8862: PPUSH
8863: CALL_OW 274
8867: PPUSH
8868: LD_INT 2
8870: PPUSH
8871: CALL_OW 275
8875: PUSH
8876: LD_INT 80
8878: GREATEREQUAL
8879: IFFALSE 8898
// nabidka := nabidka ^ [ 3 ] ;
8881: LD_ADDR_VAR 0 4
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 3
8893: PUSH
8894: EMPTY
8895: LIST
8896: ADD
8897: ST_TO_ADDR
// qr := 4 ;
8898: LD_ADDR_VAR 0 3
8902: PUSH
8903: LD_INT 4
8905: ST_TO_ADDR
// if nabidka > 1 then
8906: LD_VAR 0 4
8910: PUSH
8911: LD_INT 1
8913: GREATER
8914: IFFALSE 9038
// begin qr := SelectiveQuery ( QInfo2 , nabidka ) ;
8916: LD_ADDR_VAR 0 3
8920: PUSH
8921: LD_STRING QInfo2
8923: PPUSH
8924: LD_VAR 0 4
8928: PPUSH
8929: CALL_OW 98
8933: ST_TO_ADDR
// case qr of 1 :
8934: LD_VAR 0 3
8938: PUSH
8939: LD_INT 1
8941: DOUBLE
8942: EQUAL
8943: IFTRUE 8947
8945: GO 8971
8947: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_siberit , - 20 ) ; 2 :
8948: LD_EXP 67
8952: PPUSH
8953: CALL_OW 274
8957: PPUSH
8958: LD_INT 3
8960: PPUSH
8961: LD_INT 20
8963: NEG
8964: PPUSH
8965: CALL_OW 276
8969: GO 9036
8971: LD_INT 2
8973: DOUBLE
8974: EQUAL
8975: IFTRUE 8979
8977: GO 9003
8979: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_cans , - 50 ) ; 3 :
8980: LD_EXP 67
8984: PPUSH
8985: CALL_OW 274
8989: PPUSH
8990: LD_INT 1
8992: PPUSH
8993: LD_INT 50
8995: NEG
8996: PPUSH
8997: CALL_OW 276
9001: GO 9036
9003: LD_INT 3
9005: DOUBLE
9006: EQUAL
9007: IFTRUE 9011
9009: GO 9035
9011: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 80 ) ; end ;
9012: LD_EXP 67
9016: PPUSH
9017: CALL_OW 274
9021: PPUSH
9022: LD_INT 2
9024: PPUSH
9025: LD_INT 80
9027: NEG
9028: PPUSH
9029: CALL_OW 276
9033: GO 9036
9035: POP
// end else
9036: GO 9045
// begin Query ( QInfoNothing ) ;
9038: LD_STRING QInfoNothing
9040: PPUSH
9041: CALL_OW 97
// end ; if qr = 4 then
9045: LD_VAR 0 3
9049: PUSH
9050: LD_INT 4
9052: EQUAL
9053: IFFALSE 9077
// begin DialogueOn ;
9055: CALL_OW 6
// Say ( Ara1 , D9f-Ar1-1 ) ;
9059: LD_EXP 39
9063: PPUSH
9064: LD_STRING D9f-Ar1-1
9066: PPUSH
9067: CALL_OW 88
// DialogueOff ;
9071: CALL_OW 7
// end else
9075: GO 9174
// begin case qr of 1 :
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 1
9084: DOUBLE
9085: EQUAL
9086: IFTRUE 9090
9088: GO 9103
9090: POP
// odnes_neco ( mat_siberit , 20 ) ; 2 :
9091: LD_INT 3
9093: PPUSH
9094: LD_INT 20
9096: PPUSH
9097: CALL 5738 0 2
9101: GO 9146
9103: LD_INT 2
9105: DOUBLE
9106: EQUAL
9107: IFTRUE 9111
9109: GO 9124
9111: POP
// odnes_neco ( mat_cans , 50 ) ; 3 :
9112: LD_INT 1
9114: PPUSH
9115: LD_INT 50
9117: PPUSH
9118: CALL 5738 0 2
9122: GO 9146
9124: LD_INT 3
9126: DOUBLE
9127: EQUAL
9128: IFTRUE 9132
9130: GO 9145
9132: POP
// odnes_neco ( mat_oil , 80 ) ; end ;
9133: LD_INT 2
9135: PPUSH
9136: LD_INT 80
9138: PPUSH
9139: CALL 5738 0 2
9143: GO 9146
9145: POP
// DialogueOn ;
9146: CALL_OW 6
// Say ( Ara1 , D9e-Ar1-1 ) ;
9150: LD_EXP 39
9154: PPUSH
9155: LD_STRING D9e-Ar1-1
9157: PPUSH
9158: CALL_OW 88
// PoskytnouInformace := 1 ;
9162: LD_ADDR_EXP 56
9166: PUSH
9167: LD_INT 1
9169: ST_TO_ADDR
// DialogueOff ;
9170: CALL_OW 7
// end ; end ; end ; ComExitBuilding ( Ara2 ) ;
9174: LD_EXP 40
9178: PPUSH
9179: CALL_OW 122
// if cekani >= 120 then
9183: LD_VAR 0 2
9187: PUSH
9188: LD_INT 120
9190: GREATEREQUAL
9191: IFFALSE 9279
// begin DialogueOn ;
9193: CALL_OW 6
// if Say ( Ara1 , D9c-Ar1-1 ) then
9197: LD_EXP 39
9201: PPUSH
9202: LD_STRING D9c-Ar1-1
9204: PPUSH
9205: CALL_OW 88
9209: IFFALSE 9275
// if Say ( JMM , D9c-JMM-1 ) then
9211: LD_EXP 17
9215: PPUSH
9216: LD_STRING D9c-JMM-1
9218: PPUSH
9219: CALL_OW 88
9223: IFFALSE 9275
// if Say ( Ara1 , D9c-Ar1-2 ) then
9225: LD_EXP 39
9229: PPUSH
9230: LD_STRING D9c-Ar1-2
9232: PPUSH
9233: CALL_OW 88
9237: IFFALSE 9275
// if Say ( Ara3 , D9c-FAr1-2 ) then
9239: LD_EXP 41
9243: PPUSH
9244: LD_STRING D9c-FAr1-2
9246: PPUSH
9247: CALL_OW 88
9251: IFFALSE 9275
// if Say ( Ara1 , D9c-Ar1-3 ) then
9253: LD_EXP 39
9257: PPUSH
9258: LD_STRING D9c-Ar1-3
9260: PPUSH
9261: CALL_OW 88
9265: IFFALSE 9275
// PoskytnouInformace := 2 ;
9267: LD_ADDR_EXP 56
9271: PUSH
9272: LD_INT 2
9274: ST_TO_ADDR
// DialogueOff ;
9275: CALL_OW 7
// end ; end ; for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
9279: LD_ADDR_VAR 0 5
9283: PUSH
9284: LD_INT 22
9286: PUSH
9287: LD_EXP 50
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PUSH
9296: LD_INT 21
9298: PUSH
9299: LD_INT 3
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: PPUSH
9310: CALL_OW 69
9314: PUSH
9315: FOR_IN
9316: IFFALSE 9334
// SetSide ( i , you ) ;
9318: LD_VAR 0 5
9322: PPUSH
9323: LD_EXP 47
9327: PPUSH
9328: CALL_OW 235
9332: GO 9315
9334: POP
9335: POP
// if PoskytnouInformace > 0 and IsLive ( ara1 ) and IsLive ( ara2 ) and IsLive ( ara3 ) then
9336: LD_EXP 56
9340: PUSH
9341: LD_INT 0
9343: GREATER
9344: PUSH
9345: LD_EXP 39
9349: PPUSH
9350: CALL_OW 300
9354: AND
9355: PUSH
9356: LD_EXP 40
9360: PPUSH
9361: CALL_OW 300
9365: AND
9366: PUSH
9367: LD_EXP 41
9371: PPUSH
9372: CALL_OW 300
9376: AND
9377: IFFALSE 9555
// begin DialogueOn ;
9379: CALL_OW 6
// if PoskytnouInformace = 2 then
9383: LD_EXP 56
9387: PUSH
9388: LD_INT 2
9390: EQUAL
9391: IFFALSE 9405
// Say ( JMM , D10a-JMM-1 ) ;
9393: LD_EXP 17
9397: PPUSH
9398: LD_STRING D10a-JMM-1
9400: PPUSH
9401: CALL_OW 88
// if PoskytnouInformace = 1 then
9405: LD_EXP 56
9409: PUSH
9410: LD_INT 1
9412: EQUAL
9413: IFFALSE 9427
// Say ( JMM , D10a-JMM-1 ) ;
9415: LD_EXP 17
9419: PPUSH
9420: LD_STRING D10a-JMM-1
9422: PPUSH
9423: CALL_OW 88
// if Say ( Ara1 , D10a-Ar1-1 ) then
9427: LD_EXP 39
9431: PPUSH
9432: LD_STRING D10a-Ar1-1
9434: PPUSH
9435: CALL_OW 88
9439: IFFALSE 9551
// if Say ( Ara2 , D10a-Ar2-1 ) then
9441: LD_EXP 40
9445: PPUSH
9446: LD_STRING D10a-Ar2-1
9448: PPUSH
9449: CALL_OW 88
9453: IFFALSE 9551
// if Say ( Ara3 , D10a-FAr1-1 ) then
9455: LD_EXP 41
9459: PPUSH
9460: LD_STRING D10a-FAr1-1
9462: PPUSH
9463: CALL_OW 88
9467: IFFALSE 9551
// if Say ( Ara2 , D10a-Ar2-2 ) then
9469: LD_EXP 40
9473: PPUSH
9474: LD_STRING D10a-Ar2-2
9476: PPUSH
9477: CALL_OW 88
9481: IFFALSE 9551
// if Say ( Ara3 , D10a-FAr1-2 ) then
9483: LD_EXP 41
9487: PPUSH
9488: LD_STRING D10a-FAr1-2
9490: PPUSH
9491: CALL_OW 88
9495: IFFALSE 9551
// if Say ( Ara1 , D10a-Ar1-2 ) then
9497: LD_EXP 39
9501: PPUSH
9502: LD_STRING D10a-Ar1-2
9504: PPUSH
9505: CALL_OW 88
9509: IFFALSE 9551
// if Say ( JMM , D10a-JMM-2 ) then
9511: LD_EXP 17
9515: PPUSH
9516: LD_STRING D10a-JMM-2
9518: PPUSH
9519: CALL_OW 88
9523: IFFALSE 9551
// if Say ( Ara1 , D10a-Ar1-3 ) then
9525: LD_EXP 39
9529: PPUSH
9530: LD_STRING D10a-Ar1-3
9532: PPUSH
9533: CALL_OW 88
9537: IFFALSE 9551
// Say ( JMM , D10a-JMM-3 ) ;
9539: LD_EXP 17
9543: PPUSH
9544: LD_STRING D10a-JMM-3
9546: PPUSH
9547: CALL_OW 88
// DialogueOff ;
9551: CALL_OW 7
// end ; end ; if ( Aqr1 = 3 ) or ( Aqr1 = 2 and Aqr2 = 2 ) then
9555: LD_EXP 37
9559: PUSH
9560: LD_INT 3
9562: EQUAL
9563: PUSH
9564: LD_EXP 37
9568: PUSH
9569: LD_INT 2
9571: EQUAL
9572: PUSH
9573: LD_EXP 38
9577: PUSH
9578: LD_INT 2
9580: EQUAL
9581: AND
9582: OR
9583: IFFALSE 10796
// begin ara1_faze := 0 ;
9585: LD_ADDR_VAR 0 9
9589: PUSH
9590: LD_INT 0
9592: ST_TO_ADDR
// ara3_faze := 0 ;
9593: LD_ADDR_VAR 0 10
9597: PUSH
9598: LD_INT 0
9600: ST_TO_ADDR
// while UnitFilter ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
9601: LD_EXP 39
9605: PUSH
9606: LD_EXP 40
9610: PUSH
9611: LD_EXP 41
9615: PUSH
9616: LD_EXP 42
9620: PUSH
9621: LD_EXP 43
9625: PUSH
9626: LD_EXP 44
9630: PUSH
9631: LD_EXP 45
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: PPUSH
9645: LD_INT 50
9647: PUSH
9648: EMPTY
9649: LIST
9650: PPUSH
9651: CALL_OW 72
9655: IFFALSE 10794
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_INT 22
9664: PPUSH
9665: LD_INT 22
9667: PUSH
9668: LD_EXP 50
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: EMPTY
9678: LIST
9679: PPUSH
9680: CALL_OW 70
9684: PUSH
9685: FOR_IN
9686: IFFALSE 9811
// if not ( ( i = Ara1 ) and ( ara1_faze < 2 ) or ( i = Ara3 ) and ( ara3_faze < 2 ) ) then
9688: LD_VAR 0 5
9692: PUSH
9693: LD_EXP 39
9697: EQUAL
9698: PUSH
9699: LD_VAR 0 9
9703: PUSH
9704: LD_INT 2
9706: LESS
9707: AND
9708: PUSH
9709: LD_VAR 0 5
9713: PUSH
9714: LD_EXP 41
9718: EQUAL
9719: PUSH
9720: LD_VAR 0 10
9724: PUSH
9725: LD_INT 2
9727: LESS
9728: AND
9729: OR
9730: NOT
9731: IFFALSE 9809
// begin RemoveUnit ( i ) ;
9733: LD_VAR 0 5
9737: PPUSH
9738: CALL_OW 64
// if i = AraCar1 then
9742: LD_VAR 0 5
9746: PUSH
9747: LD_EXP 44
9751: EQUAL
9752: IFFALSE 9763
// RemoveUnit ( Ara4 ) ;
9754: LD_EXP 42
9758: PPUSH
9759: CALL_OW 64
// if i = AraCar2 then
9763: LD_VAR 0 5
9767: PUSH
9768: LD_EXP 45
9772: EQUAL
9773: IFFALSE 9784
// RemoveUnit ( Ara5 ) ;
9775: LD_EXP 43
9779: PPUSH
9780: CALL_OW 64
// if IsInUnit ( i ) then
9784: LD_VAR 0 5
9788: PPUSH
9789: CALL_OW 310
9793: IFFALSE 9809
// RemoveUnit ( IsInUnit ( i ) ) ;
9795: LD_VAR 0 5
9799: PPUSH
9800: CALL_OW 310
9804: PPUSH
9805: CALL_OW 64
// end ;
9809: GO 9685
9811: POP
9812: POP
// wait ( 0 0$5 ) ;
9813: LD_INT 175
9815: PPUSH
9816: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
9820: LD_EXP 42
9824: PPUSH
9825: CALL_OW 310
9829: NOT
9830: PUSH
9831: LD_EXP 44
9835: PPUSH
9836: CALL_OW 302
9840: NOT
9841: AND
9842: IFFALSE 9856
// ComMoveToArea ( Ara4 , arab_exit ) ;
9844: LD_EXP 42
9848: PPUSH
9849: LD_INT 22
9851: PPUSH
9852: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
9856: LD_EXP 43
9860: PPUSH
9861: CALL_OW 310
9865: NOT
9866: PUSH
9867: LD_EXP 45
9871: PPUSH
9872: CALL_OW 302
9876: NOT
9877: AND
9878: IFFALSE 9892
// ComMoveToArea ( Ara5 , arab_exit ) ;
9880: LD_EXP 43
9884: PPUSH
9885: LD_INT 22
9887: PPUSH
9888: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
9892: LD_EXP 42
9896: PPUSH
9897: CALL_OW 310
9901: NOT
9902: PUSH
9903: LD_EXP 44
9907: PPUSH
9908: CALL_OW 261
9912: PUSH
9913: LD_INT 0
9915: GREATER
9916: AND
9917: PUSH
9918: LD_EXP 44
9922: PPUSH
9923: CALL_OW 302
9927: AND
9928: IFFALSE 9944
// ComEnterUnit ( Ara4 , AraCar1 ) ;
9930: LD_EXP 42
9934: PPUSH
9935: LD_EXP 44
9939: PPUSH
9940: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
9944: LD_EXP 43
9948: PPUSH
9949: CALL_OW 310
9953: NOT
9954: PUSH
9955: LD_EXP 45
9959: PPUSH
9960: CALL_OW 261
9964: PUSH
9965: LD_INT 0
9967: GREATER
9968: AND
9969: PUSH
9970: LD_EXP 45
9974: PPUSH
9975: CALL_OW 302
9979: AND
9980: IFFALSE 9996
// ComEnterUnit ( Ara5 , AraCar2 ) ;
9982: LD_EXP 43
9986: PPUSH
9987: LD_EXP 45
9991: PPUSH
9992: CALL_OW 120
// ComMoveToArea ( [ Ara2 , AraCar1 , AraCar2 ] , arab_exit ) ;
9996: LD_EXP 40
10000: PUSH
10001: LD_EXP 44
10005: PUSH
10006: LD_EXP 45
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: LIST
10015: PPUSH
10016: LD_INT 22
10018: PPUSH
10019: CALL_OW 113
// AddComMoveXY ( [ Ara2 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
10023: LD_EXP 40
10027: PUSH
10028: LD_EXP 44
10032: PUSH
10033: LD_EXP 45
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: LIST
10042: PPUSH
10043: LD_INT 37
10045: PPUSH
10046: LD_INT 72
10048: PPUSH
10049: CALL_OW 171
// case true of not IsOk ( Ara1 ) :
10053: LD_INT 1
10055: PUSH
10056: LD_EXP 39
10060: PPUSH
10061: CALL_OW 302
10065: NOT
10066: DOUBLE
10067: EQUAL
10068: IFTRUE 10072
10070: GO 10083
10072: POP
// ara1_faze := 4 ; ( GetDistUnitXY ( Ara1 , 57 , 76 ) < 5 ) and ara1_faze = 2 :
10073: LD_ADDR_VAR 0 9
10077: PUSH
10078: LD_INT 4
10080: ST_TO_ADDR
10081: GO 10231
10083: LD_EXP 39
10087: PPUSH
10088: LD_INT 57
10090: PPUSH
10091: LD_INT 76
10093: PPUSH
10094: CALL_OW 297
10098: PUSH
10099: LD_INT 5
10101: LESS
10102: PUSH
10103: LD_VAR 0 9
10107: PUSH
10108: LD_INT 2
10110: EQUAL
10111: AND
10112: DOUBLE
10113: EQUAL
10114: IFTRUE 10118
10116: GO 10129
10118: POP
// ara1_faze := 3 ; MineOfUnit ( Ara1 ) <> 0 and ara1_faze = 1 :
10119: LD_ADDR_VAR 0 9
10123: PUSH
10124: LD_INT 3
10126: ST_TO_ADDR
10127: GO 10231
10129: LD_EXP 39
10133: PPUSH
10134: CALL_OW 459
10138: PUSH
10139: LD_INT 0
10141: NONEQUAL
10142: PUSH
10143: LD_VAR 0 9
10147: PUSH
10148: LD_INT 1
10150: EQUAL
10151: AND
10152: DOUBLE
10153: EQUAL
10154: IFTRUE 10158
10156: GO 10184
10158: POP
// begin ara1_faze := 2 ;
10159: LD_ADDR_VAR 0 9
10163: PUSH
10164: LD_INT 2
10166: ST_TO_ADDR
// mina1 := MineOfUnit ( Ara1 ) ;
10167: LD_ADDR_EXP 77
10171: PUSH
10172: LD_EXP 39
10176: PPUSH
10177: CALL_OW 459
10181: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara1 , 58 , 76 ) < 5 ) and ara1_faze = 0 :
10182: GO 10231
10184: LD_EXP 39
10188: PPUSH
10189: LD_INT 58
10191: PPUSH
10192: LD_INT 76
10194: PPUSH
10195: CALL_OW 297
10199: PUSH
10200: LD_INT 5
10202: LESS
10203: PUSH
10204: LD_VAR 0 9
10208: PUSH
10209: LD_INT 0
10211: EQUAL
10212: AND
10213: DOUBLE
10214: EQUAL
10215: IFTRUE 10219
10217: GO 10230
10219: POP
// ara1_faze := 1 ; end ;
10220: LD_ADDR_VAR 0 9
10224: PUSH
10225: LD_INT 1
10227: ST_TO_ADDR
10228: GO 10231
10230: POP
// case ara1_faze of 0 :
10231: LD_VAR 0 9
10235: PUSH
10236: LD_INT 0
10238: DOUBLE
10239: EQUAL
10240: IFTRUE 10244
10242: GO 10262
10244: POP
// ComMoveXY ( Ara1 , 58 , 76 ) ; 1 :
10245: LD_EXP 39
10249: PPUSH
10250: LD_INT 58
10252: PPUSH
10253: LD_INT 76
10255: PPUSH
10256: CALL_OW 111
10260: GO 10358
10262: LD_INT 1
10264: DOUBLE
10265: EQUAL
10266: IFTRUE 10270
10268: GO 10293
10270: POP
// ComPlaceRemoteCharge ( Ara1 , 0 , 0 , ruDepot1 ) ; 2 :
10271: LD_EXP 39
10275: PPUSH
10276: LD_INT 0
10278: PPUSH
10279: LD_INT 0
10281: PPUSH
10282: LD_EXP 67
10286: PPUSH
10287: CALL_OW 133
10291: GO 10358
10293: LD_INT 2
10295: DOUBLE
10296: EQUAL
10297: IFTRUE 10301
10299: GO 10319
10301: POP
// ComMoveXY ( Ara1 , 57 , 76 ) ; 3 :
10302: LD_EXP 39
10306: PPUSH
10307: LD_INT 57
10309: PPUSH
10310: LD_INT 76
10312: PPUSH
10313: CALL_OW 111
10317: GO 10358
10319: LD_INT 3
10321: DOUBLE
10322: EQUAL
10323: IFTRUE 10327
10325: GO 10357
10327: POP
// begin ComMoveToArea ( Ara1 , arab_exit ) ;
10328: LD_EXP 39
10332: PPUSH
10333: LD_INT 22
10335: PPUSH
10336: CALL_OW 113
// AddComMoveXY ( Ara1 , 37 , 72 ) ;
10340: LD_EXP 39
10344: PPUSH
10345: LD_INT 37
10347: PPUSH
10348: LD_INT 72
10350: PPUSH
10351: CALL_OW 171
// end ; end ;
10355: GO 10358
10357: POP
// case true of not IsOk ( Ara3 ) :
10358: LD_INT 1
10360: PUSH
10361: LD_EXP 41
10365: PPUSH
10366: CALL_OW 302
10370: NOT
10371: DOUBLE
10372: EQUAL
10373: IFTRUE 10377
10375: GO 10388
10377: POP
// ara3_faze := 4 ; ( GetDistUnitXY ( Ara3 , 58 , 76 ) < 5 ) and ara3_faze = 2 :
10378: LD_ADDR_VAR 0 10
10382: PUSH
10383: LD_INT 4
10385: ST_TO_ADDR
10386: GO 10536
10388: LD_EXP 41
10392: PPUSH
10393: LD_INT 58
10395: PPUSH
10396: LD_INT 76
10398: PPUSH
10399: CALL_OW 297
10403: PUSH
10404: LD_INT 5
10406: LESS
10407: PUSH
10408: LD_VAR 0 10
10412: PUSH
10413: LD_INT 2
10415: EQUAL
10416: AND
10417: DOUBLE
10418: EQUAL
10419: IFTRUE 10423
10421: GO 10434
10423: POP
// ara3_faze := 3 ; MineOfUnit ( Ara3 ) <> 0 and ara3_faze = 1 :
10424: LD_ADDR_VAR 0 10
10428: PUSH
10429: LD_INT 3
10431: ST_TO_ADDR
10432: GO 10536
10434: LD_EXP 41
10438: PPUSH
10439: CALL_OW 459
10443: PUSH
10444: LD_INT 0
10446: NONEQUAL
10447: PUSH
10448: LD_VAR 0 10
10452: PUSH
10453: LD_INT 1
10455: EQUAL
10456: AND
10457: DOUBLE
10458: EQUAL
10459: IFTRUE 10463
10461: GO 10489
10463: POP
// begin ara3_faze := 2 ;
10464: LD_ADDR_VAR 0 10
10468: PUSH
10469: LD_INT 2
10471: ST_TO_ADDR
// mina3 := MineOfUnit ( Ara3 ) ;
10472: LD_ADDR_EXP 78
10476: PUSH
10477: LD_EXP 41
10481: PPUSH
10482: CALL_OW 459
10486: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara3 , 70 , 104 ) < 5 ) and ara3_faze = 0 :
10487: GO 10536
10489: LD_EXP 41
10493: PPUSH
10494: LD_INT 70
10496: PPUSH
10497: LD_INT 104
10499: PPUSH
10500: CALL_OW 297
10504: PUSH
10505: LD_INT 5
10507: LESS
10508: PUSH
10509: LD_VAR 0 10
10513: PUSH
10514: LD_INT 0
10516: EQUAL
10517: AND
10518: DOUBLE
10519: EQUAL
10520: IFTRUE 10524
10522: GO 10535
10524: POP
// ara3_faze := 1 ; end ;
10525: LD_ADDR_VAR 0 10
10529: PUSH
10530: LD_INT 1
10532: ST_TO_ADDR
10533: GO 10536
10535: POP
// case ara3_faze of 0 :
10536: LD_VAR 0 10
10540: PUSH
10541: LD_INT 0
10543: DOUBLE
10544: EQUAL
10545: IFTRUE 10549
10547: GO 10567
10549: POP
// ComMoveXY ( Ara3 , 70 , 104 ) ; 1 :
10550: LD_EXP 41
10554: PPUSH
10555: LD_INT 70
10557: PPUSH
10558: LD_INT 104
10560: PPUSH
10561: CALL_OW 111
10565: GO 10663
10567: LD_INT 1
10569: DOUBLE
10570: EQUAL
10571: IFTRUE 10575
10573: GO 10598
10575: POP
// ComPlaceRemoteCharge ( Ara3 , 0 , 0 , ruDepot1 ) ; 2 :
10576: LD_EXP 41
10580: PPUSH
10581: LD_INT 0
10583: PPUSH
10584: LD_INT 0
10586: PPUSH
10587: LD_EXP 67
10591: PPUSH
10592: CALL_OW 133
10596: GO 10663
10598: LD_INT 2
10600: DOUBLE
10601: EQUAL
10602: IFTRUE 10606
10604: GO 10624
10606: POP
// ComMoveXY ( Ara3 , 58 , 76 ) ; 3 :
10607: LD_EXP 41
10611: PPUSH
10612: LD_INT 58
10614: PPUSH
10615: LD_INT 76
10617: PPUSH
10618: CALL_OW 111
10622: GO 10663
10624: LD_INT 3
10626: DOUBLE
10627: EQUAL
10628: IFTRUE 10632
10630: GO 10662
10632: POP
// begin ComMoveToArea ( Ara3 , arab_exit ) ;
10633: LD_EXP 41
10637: PPUSH
10638: LD_INT 22
10640: PPUSH
10641: CALL_OW 113
// AddComMoveXY ( Ara3 , 37 , 72 ) ;
10645: LD_EXP 41
10649: PPUSH
10650: LD_INT 37
10652: PPUSH
10653: LD_INT 72
10655: PPUSH
10656: CALL_OW 171
// end ; end ;
10660: GO 10663
10662: POP
// if not kecy and ara1_faze >= 3 and ara3_faze >= 3 then
10663: LD_EXP 76
10667: NOT
10668: PUSH
10669: LD_VAR 0 9
10673: PUSH
10674: LD_INT 3
10676: GREATEREQUAL
10677: AND
10678: PUSH
10679: LD_VAR 0 10
10683: PUSH
10684: LD_INT 3
10686: GREATEREQUAL
10687: AND
10688: IFFALSE 10792
// begin if odmitl_v_query then
10690: LD_VAR 0 11
10694: IFFALSE 10710
// Say ( Ara2 , D11b-Ar1-1 ) else
10696: LD_EXP 40
10700: PPUSH
10701: LD_STRING D11b-Ar1-1
10703: PPUSH
10704: CALL_OW 88
10708: GO 10722
// Say ( Ara2 , D11a-Ar1-1 ) ;
10710: LD_EXP 40
10714: PPUSH
10715: LD_STRING D11a-Ar1-1
10717: PPUSH
10718: CALL_OW 88
// if mina1 then
10722: LD_EXP 77
10726: IFFALSE 10753
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
10728: LD_EXP 77
10732: PUSH
10733: LD_INT 1
10735: ARRAY
10736: PPUSH
10737: LD_EXP 77
10741: PUSH
10742: LD_INT 2
10744: ARRAY
10745: PPUSH
10746: LD_INT 1200
10748: PPUSH
10749: CALL_OW 453
// if mina3 then
10753: LD_EXP 78
10757: IFFALSE 10784
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
10759: LD_EXP 78
10763: PUSH
10764: LD_INT 1
10766: ARRAY
10767: PPUSH
10768: LD_EXP 78
10772: PUSH
10773: LD_INT 2
10775: ARRAY
10776: PPUSH
10777: LD_INT 1200
10779: PPUSH
10780: CALL_OW 453
// kecy := true ;
10784: LD_ADDR_EXP 76
10788: PUSH
10789: LD_INT 1
10791: ST_TO_ADDR
// end ; end ;
10792: GO 9601
// end else
10794: GO 11205
// begin while UnitFilter ( [ Ara2 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
10796: LD_EXP 40
10800: PUSH
10801: LD_EXP 44
10805: PUSH
10806: LD_EXP 45
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: LIST
10815: PPUSH
10816: LD_INT 50
10818: PUSH
10819: EMPTY
10820: LIST
10821: PPUSH
10822: CALL_OW 72
10826: IFFALSE 11205
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
10828: LD_ADDR_VAR 0 5
10832: PUSH
10833: LD_INT 22
10835: PPUSH
10836: LD_INT 22
10838: PUSH
10839: LD_EXP 50
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PUSH
10848: EMPTY
10849: LIST
10850: PPUSH
10851: CALL_OW 70
10855: PUSH
10856: FOR_IN
10857: IFFALSE 10937
// begin RemoveUnit ( i ) ;
10859: LD_VAR 0 5
10863: PPUSH
10864: CALL_OW 64
// if i = AraCar1 then
10868: LD_VAR 0 5
10872: PUSH
10873: LD_EXP 44
10877: EQUAL
10878: IFFALSE 10889
// RemoveUnit ( Ara4 ) ;
10880: LD_EXP 42
10884: PPUSH
10885: CALL_OW 64
// if i = AraCar2 then
10889: LD_VAR 0 5
10893: PUSH
10894: LD_EXP 45
10898: EQUAL
10899: IFFALSE 10910
// RemoveUnit ( Ara5 ) ;
10901: LD_EXP 43
10905: PPUSH
10906: CALL_OW 64
// if IsInUnit ( i ) then
10910: LD_VAR 0 5
10914: PPUSH
10915: CALL_OW 310
10919: IFFALSE 10935
// RemoveUnit ( IsInUnit ( i ) ) ;
10921: LD_VAR 0 5
10925: PPUSH
10926: CALL_OW 310
10930: PPUSH
10931: CALL_OW 64
// end ;
10935: GO 10856
10937: POP
10938: POP
// wait ( 0 0$1 ) ;
10939: LD_INT 35
10941: PPUSH
10942: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
10946: LD_EXP 42
10950: PPUSH
10951: CALL_OW 310
10955: NOT
10956: PUSH
10957: LD_EXP 44
10961: PPUSH
10962: CALL_OW 302
10966: NOT
10967: AND
10968: IFFALSE 10982
// ComMoveToArea ( Ara4 , arab_exit ) ;
10970: LD_EXP 42
10974: PPUSH
10975: LD_INT 22
10977: PPUSH
10978: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
10982: LD_EXP 43
10986: PPUSH
10987: CALL_OW 310
10991: NOT
10992: PUSH
10993: LD_EXP 45
10997: PPUSH
10998: CALL_OW 302
11002: NOT
11003: AND
11004: IFFALSE 11018
// ComMoveToArea ( Ara5 , arab_exit ) ;
11006: LD_EXP 43
11010: PPUSH
11011: LD_INT 22
11013: PPUSH
11014: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
11018: LD_EXP 42
11022: PPUSH
11023: CALL_OW 310
11027: NOT
11028: PUSH
11029: LD_EXP 44
11033: PPUSH
11034: CALL_OW 261
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: AND
11043: PUSH
11044: LD_EXP 44
11048: PPUSH
11049: CALL_OW 302
11053: AND
11054: IFFALSE 11070
// ComEnterUnit ( Ara4 , AraCar1 ) ;
11056: LD_EXP 42
11060: PPUSH
11061: LD_EXP 44
11065: PPUSH
11066: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
11070: LD_EXP 43
11074: PPUSH
11075: CALL_OW 310
11079: NOT
11080: PUSH
11081: LD_EXP 45
11085: PPUSH
11086: CALL_OW 261
11090: PUSH
11091: LD_INT 0
11093: GREATER
11094: AND
11095: PUSH
11096: LD_EXP 45
11100: PPUSH
11101: CALL_OW 302
11105: AND
11106: IFFALSE 11122
// ComEnterUnit ( Ara5 , AraCar2 ) ;
11108: LD_EXP 43
11112: PPUSH
11113: LD_EXP 45
11117: PPUSH
11118: CALL_OW 120
// ComMoveToArea ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , arab_exit ) ;
11122: LD_EXP 39
11126: PUSH
11127: LD_EXP 40
11131: PUSH
11132: LD_EXP 41
11136: PUSH
11137: LD_EXP 44
11141: PUSH
11142: LD_EXP 45
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: PPUSH
11154: LD_INT 22
11156: PPUSH
11157: CALL_OW 113
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
11161: LD_EXP 39
11165: PUSH
11166: LD_EXP 40
11170: PUSH
11171: LD_EXP 41
11175: PUSH
11176: LD_EXP 44
11180: PUSH
11181: LD_EXP 45
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: LIST
11192: PPUSH
11193: LD_INT 37
11195: PPUSH
11196: LD_INT 72
11198: PPUSH
11199: CALL_OW 171
// end ;
11203: GO 10796
// end ; end ;
11205: LD_VAR 0 1
11209: RET
// every 0 0$1 do var who , a_maj_to , a , i ;
11210: GO 11212
11212: DISABLE
11213: LD_INT 0
11215: PPUSH
11216: PPUSH
11217: PPUSH
11218: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
11219: LD_ADDR_VAR 0 3
11223: PUSH
11224: LD_INT 22
11226: PUSH
11227: LD_EXP 47
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: PUSH
11236: EMPTY
11237: LIST
11238: PPUSH
11239: CALL_OW 69
11243: ST_TO_ADDR
// for i in a do
11244: LD_ADDR_VAR 0 4
11248: PUSH
11249: LD_VAR 0 3
11253: PUSH
11254: FOR_IN
11255: IFFALSE 11325
// if WantsToAttack ( i ) in [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] then
11257: LD_VAR 0 4
11261: PPUSH
11262: CALL_OW 319
11266: PUSH
11267: LD_EXP 39
11271: PUSH
11272: LD_EXP 40
11276: PUSH
11277: LD_EXP 41
11281: PUSH
11282: LD_EXP 42
11286: PUSH
11287: LD_EXP 43
11291: PUSH
11292: LD_EXP 44
11296: PUSH
11297: LD_EXP 45
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: IN
11311: IFFALSE 11323
// begin a_maj_to := true ;
11313: LD_ADDR_VAR 0 2
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// break ;
11321: GO 11325
// end ;
11323: GO 11254
11325: POP
11326: POP
// if a_maj_to then
11327: LD_VAR 0 2
11331: IFFALSE 11508
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
11333: LD_EXP 47
11337: PPUSH
11338: LD_EXP 50
11342: PPUSH
11343: LD_INT 2
11345: PPUSH
11346: LD_INT 1
11348: PPUSH
11349: CALL_OW 80
// who := WhoSayAny ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] , arabians , sex_male , 0 , 0 ) ;
11353: LD_ADDR_VAR 0 1
11357: PUSH
11358: LD_EXP 39
11362: PUSH
11363: LD_EXP 40
11367: PUSH
11368: LD_EXP 41
11372: PUSH
11373: LD_EXP 42
11377: PUSH
11378: LD_EXP 43
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: PPUSH
11390: LD_EXP 50
11394: PPUSH
11395: LD_INT 1
11397: PPUSH
11398: LD_INT 0
11400: PPUSH
11401: LD_INT 0
11403: PPUSH
11404: CALL 13151 0 5
11408: ST_TO_ADDR
// if not kecy then
11409: LD_EXP 76
11413: NOT
11414: IFFALSE 11506
// begin DialogueOn ;
11416: CALL_OW 6
// Say ( who , D11a-Ar1-1 ) ;
11420: LD_VAR 0 1
11424: PPUSH
11425: LD_STRING D11a-Ar1-1
11427: PPUSH
11428: CALL_OW 88
// DialogueOff ;
11432: CALL_OW 7
// kecy := true ;
11436: LD_ADDR_EXP 76
11440: PUSH
11441: LD_INT 1
11443: ST_TO_ADDR
// if mina1 then
11444: LD_EXP 77
11448: IFFALSE 11475
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
11450: LD_EXP 77
11454: PUSH
11455: LD_INT 1
11457: ARRAY
11458: PPUSH
11459: LD_EXP 77
11463: PUSH
11464: LD_INT 2
11466: ARRAY
11467: PPUSH
11468: LD_INT 1200
11470: PPUSH
11471: CALL_OW 453
// if mina3 then
11475: LD_EXP 78
11479: IFFALSE 11506
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
11481: LD_EXP 78
11485: PUSH
11486: LD_INT 1
11488: ARRAY
11489: PPUSH
11490: LD_EXP 78
11494: PUSH
11495: LD_INT 2
11497: ARRAY
11498: PPUSH
11499: LD_INT 1200
11501: PPUSH
11502: CALL_OW 453
// end ; end else
11506: GO 11509
// enable ;
11508: ENABLE
// end ;
11509: PPOPN 4
11511: END
// every 45 45$30 do
11512: GO 11514
11514: DISABLE
// begin DialogueOn ;
11515: CALL_OW 6
// SayRadio ( Powell , D12-Pow-1 ) ;
11519: LD_EXP 16
11523: PPUSH
11524: LD_STRING D12-Pow-1
11526: PPUSH
11527: CALL_OW 94
// ChangeMissionObjectives ( M4 ) ;
11531: LD_STRING M4
11533: PPUSH
11534: CALL_OW 337
// EndEnable := true ;
11538: LD_ADDR_EXP 80
11542: PUSH
11543: LD_INT 1
11545: ST_TO_ADDR
// SetAreaMapShow ( exit_area , 1 ) ;
11546: LD_INT 32
11548: PPUSH
11549: LD_INT 1
11551: PPUSH
11552: CALL_OW 424
// DialogueOff ;
11556: CALL_OW 7
// end ;
11560: END
// export konec ; every 55 55$0 do
11561: GO 11563
11563: DISABLE
// begin Konec := true ;
11564: LD_ADDR_EXP 79
11568: PUSH
11569: LD_INT 1
11571: ST_TO_ADDR
// end ;
11572: END
// export EndEnable , TimerCas ; every 0 0$1 do var k , br , zbyva ;
11573: GO 11575
11575: DISABLE
11576: LD_INT 0
11578: PPUSH
11579: PPUSH
11580: PPUSH
// begin if testing then
11581: LD_EXP 4
11585: IFFALSE 11641
// display_strings := [ [ game time:  & ( tick div 1 1$0 ) & :  & ( ( tick - ( tick div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] else
11587: LD_ADDR_OWVAR 47
11591: PUSH
11592: LD_STRING game time: 
11594: PUSH
11595: LD_OWVAR 1
11599: PUSH
11600: LD_INT 2100
11602: DIV
11603: STR
11604: PUSH
11605: LD_STRING : 
11607: STR
11608: PUSH
11609: LD_OWVAR 1
11613: PUSH
11614: LD_OWVAR 1
11618: PUSH
11619: LD_INT 2100
11621: DIV
11622: PUSH
11623: LD_INT 2100
11625: MUL
11626: MINUS
11627: PUSH
11628: LD_INT 35
11630: DIV
11631: STR
11632: PUSH
11633: EMPTY
11634: LIST
11635: PUSH
11636: EMPTY
11637: LIST
11638: ST_TO_ADDR
11639: GO 11648
// display_strings := [ ] ;
11641: LD_ADDR_OWVAR 47
11645: PUSH
11646: EMPTY
11647: ST_TO_ADDR
// zbyva := 60 - GetResourceType ( getbase ( depot1 ) , mat_siberit ) ;
11648: LD_ADDR_VAR 0 3
11652: PUSH
11653: LD_INT 60
11655: PUSH
11656: LD_EXP 69
11660: PPUSH
11661: CALL_OW 274
11665: PPUSH
11666: LD_INT 3
11668: PPUSH
11669: CALL_OW 275
11673: MINUS
11674: ST_TO_ADDR
// if zbyva < 0 then
11675: LD_VAR 0 3
11679: PUSH
11680: LD_INT 0
11682: LESS
11683: IFFALSE 11693
// zbyva := 0 ;
11685: LD_ADDR_VAR 0 3
11689: PUSH
11690: LD_INT 0
11692: ST_TO_ADDR
// if counter_time then
11693: LD_EXP 64
11697: IFFALSE 11734
// display_strings := display_strings ^ [ #Am09-1 , zbyva , counter_time - tick ] ;
11699: LD_ADDR_OWVAR 47
11703: PUSH
11704: LD_OWVAR 47
11708: PUSH
11709: LD_STRING #Am09-1
11711: PUSH
11712: LD_VAR 0 3
11716: PUSH
11717: LD_EXP 64
11721: PUSH
11722: LD_OWVAR 1
11726: MINUS
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: LIST
11732: ADD
11733: ST_TO_ADDR
// if Konec and ( IsOK ( JMM ) ) then
11734: LD_EXP 79
11738: PUSH
11739: LD_EXP 17
11743: PPUSH
11744: CALL_OW 302
11748: AND
11749: IFFALSE 11755
// begin Vyhra ;
11751: CALL 2796 0 0
// end ; if TimerEnable then
11755: LD_EXP 63
11759: IFFALSE 11820
// begin if ContactTime ( russians ) > ( TimerCas + 0 0$45 ) then
11761: LD_EXP 49
11765: PPUSH
11766: CALL_OW 462
11770: PUSH
11771: LD_EXP 81
11775: PUSH
11776: LD_INT 1575
11778: PLUS
11779: GREATER
11780: IFFALSE 11820
// begin if GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and ( IsOK ( JMM ) ) then
11782: LD_EXP 69
11786: PPUSH
11787: CALL_OW 274
11791: PPUSH
11792: LD_INT 3
11794: PPUSH
11795: CALL_OW 275
11799: PUSH
11800: LD_INT 20
11802: GREATEREQUAL
11803: PUSH
11804: LD_EXP 17
11808: PPUSH
11809: CALL_OW 302
11813: AND
11814: IFFALSE 11820
// begin Vyhra ;
11816: CALL 2796 0 0
// end ; end ; end ; if EndEnable then
11820: LD_EXP 80
11824: IFFALSE 12013
// begin if timer < 0 then
11826: LD_EXP 62
11830: PUSH
11831: LD_INT 0
11833: LESS
11834: IFFALSE 11844
// timer := 0 ;
11836: LD_ADDR_EXP 62
11840: PUSH
11841: LD_INT 0
11843: ST_TO_ADDR
// timer := timer - 0 0$1 ;
11844: LD_ADDR_EXP 62
11848: PUSH
11849: LD_EXP 62
11853: PUSH
11854: LD_INT 35
11856: MINUS
11857: ST_TO_ADDR
// if testing then
11858: LD_EXP 4
11862: IFFALSE 11918
// display_strings := display_strings ^ [ [ ( timer div 1 1$0 ) & :  & ( ( timer - ( timer div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] ;
11864: LD_ADDR_OWVAR 47
11868: PUSH
11869: LD_OWVAR 47
11873: PUSH
11874: LD_EXP 62
11878: PUSH
11879: LD_INT 2100
11881: DIV
11882: PUSH
11883: LD_STRING : 
11885: STR
11886: PUSH
11887: LD_EXP 62
11891: PUSH
11892: LD_EXP 62
11896: PUSH
11897: LD_INT 2100
11899: DIV
11900: PUSH
11901: LD_INT 2100
11903: MUL
11904: MINUS
11905: PUSH
11906: LD_INT 35
11908: DIV
11909: STR
11910: PUSH
11911: EMPTY
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: ADD
11917: ST_TO_ADDR
// if not FilterUnitsExceptArea ( exit_area , [ [ f_ok ] , [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] ] ) and GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and IsInArea ( JMM , exit_area ) then
11918: LD_INT 32
11920: PPUSH
11921: LD_INT 50
11923: PUSH
11924: EMPTY
11925: LIST
11926: PUSH
11927: LD_INT 22
11929: PUSH
11930: LD_EXP 47
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 23
11941: PUSH
11942: LD_INT 1
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 21
11951: PUSH
11952: LD_INT 1
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: PPUSH
11965: CALL_OW 71
11969: NOT
11970: PUSH
11971: LD_EXP 69
11975: PPUSH
11976: CALL_OW 274
11980: PPUSH
11981: LD_INT 3
11983: PPUSH
11984: CALL_OW 275
11988: PUSH
11989: LD_INT 20
11991: GREATEREQUAL
11992: AND
11993: PUSH
11994: LD_EXP 17
11998: PPUSH
11999: LD_INT 32
12001: PPUSH
12002: CALL_OW 308
12006: AND
12007: IFFALSE 12013
// Vyhra ;
12009: CALL 2796 0 0
// end ; enable ;
12013: ENABLE
// end ;
12014: PPOPN 3
12016: END
// var was_QE ; function QE ; begin
12017: LD_INT 0
12019: PPUSH
// was_QE := true ;
12020: LD_ADDR_LOC 1
12024: PUSH
12025: LD_INT 1
12027: ST_TO_ADDR
// if Query ( QE ) = 2 then
12028: LD_STRING QE
12030: PPUSH
12031: CALL_OW 97
12035: PUSH
12036: LD_INT 2
12038: EQUAL
12039: IFFALSE 12045
// Vyhra ;
12041: CALL 2796 0 0
// end ; end_of_file
12045: LD_VAR 0 1
12049: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
12050: LD_INT 0
12052: PPUSH
12053: PPUSH
12054: PPUSH
// see_any_r := false ;
12055: LD_ADDR_VAR 0 5
12059: PUSH
12060: LD_INT 0
12062: ST_TO_ADDR
// for sai in sez2 do
12063: LD_ADDR_VAR 0 4
12067: PUSH
12068: LD_VAR 0 2
12072: PUSH
12073: FOR_IN
12074: IFFALSE 12104
// if See ( strana , sai ) then
12076: LD_VAR 0 1
12080: PPUSH
12081: LD_VAR 0 4
12085: PPUSH
12086: CALL_OW 292
12090: IFFALSE 12102
// begin see_any_r := true ;
12092: LD_ADDR_VAR 0 5
12096: PUSH
12097: LD_INT 1
12099: ST_TO_ADDR
// break ;
12100: GO 12104
// end ;
12102: GO 12073
12104: POP
12105: POP
// ; result := see_any_r ;
12106: LD_ADDR_VAR 0 3
12110: PUSH
12111: LD_VAR 0 5
12115: ST_TO_ADDR
// end ;
12116: LD_VAR 0 3
12120: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
12121: LD_INT 0
12123: PPUSH
12124: PPUSH
12125: PPUSH
12126: PPUSH
// for i in who do
12127: LD_ADDR_VAR 0 6
12131: PUSH
12132: LD_VAR 0 1
12136: PUSH
12137: FOR_IN
12138: IFFALSE 12209
// begin for j in what do
12140: LD_ADDR_VAR 0 7
12144: PUSH
12145: LD_VAR 0 3
12149: PUSH
12150: FOR_IN
12151: IFFALSE 12205
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
12153: LD_VAR 0 7
12157: PPUSH
12158: CALL_OW 311
12162: NOT
12163: PUSH
12164: LD_VAR 0 6
12168: PPUSH
12169: LD_VAR 0 7
12173: PPUSH
12174: CALL_OW 296
12178: PUSH
12179: LD_VAR 0 2
12183: LESSEQUAL
12184: AND
12185: IFFALSE 12203
// begin ComEnterUnit ( i , j ) ;
12187: LD_VAR 0 6
12191: PPUSH
12192: LD_VAR 0 7
12196: PPUSH
12197: CALL_OW 120
// break ;
12201: GO 12205
// end ; end ;
12203: GO 12150
12205: POP
12206: POP
// end ;
12207: GO 12137
12209: POP
12210: POP
// end ;
12211: LD_VAR 0 4
12215: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
12216: LD_INT 0
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
// for i in who do
12222: LD_ADDR_VAR 0 6
12226: PUSH
12227: LD_VAR 0 1
12231: PUSH
12232: FOR_IN
12233: IFFALSE 12332
// begin add := false ;
12235: LD_ADDR_VAR 0 5
12239: PUSH
12240: LD_INT 0
12242: ST_TO_ADDR
// for j in what do
12243: LD_ADDR_VAR 0 7
12247: PUSH
12248: LD_VAR 0 3
12252: PUSH
12253: FOR_IN
12254: IFFALSE 12288
// begin if GetDistUnits ( i , j ) <= dist then
12256: LD_VAR 0 6
12260: PPUSH
12261: LD_VAR 0 7
12265: PPUSH
12266: CALL_OW 296
12270: PUSH
12271: LD_VAR 0 2
12275: LESSEQUAL
12276: IFFALSE 12286
// begin add := true ;
12278: LD_ADDR_VAR 0 5
12282: PUSH
12283: LD_INT 1
12285: ST_TO_ADDR
// end ; end ;
12286: GO 12253
12288: POP
12289: POP
// if add then
12290: LD_VAR 0 5
12294: IFFALSE 12330
// begin if result then
12296: LD_VAR 0 4
12300: IFFALSE 12320
// result := result ^ i else
12302: LD_ADDR_VAR 0 4
12306: PUSH
12307: LD_VAR 0 4
12311: PUSH
12312: LD_VAR 0 6
12316: ADD
12317: ST_TO_ADDR
12318: GO 12330
// result := i ;
12320: LD_ADDR_VAR 0 4
12324: PUSH
12325: LD_VAR 0 6
12329: ST_TO_ADDR
// end ; end ;
12330: GO 12232
12332: POP
12333: POP
// end ;
12334: LD_VAR 0 4
12338: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
12339: LD_INT 0
12341: PPUSH
12342: PPUSH
12343: PPUSH
// i1 := 1 ;
12344: LD_ADDR_VAR 0 5
12348: PUSH
12349: LD_INT 1
12351: ST_TO_ADDR
// while i1 <= path do
12352: LD_VAR 0 5
12356: PUSH
12357: LD_VAR 0 2
12361: LESSEQUAL
12362: IFFALSE 12609
// begin a := path [ i1 ] ;
12364: LD_ADDR_VAR 0 6
12368: PUSH
12369: LD_VAR 0 2
12373: PUSH
12374: LD_VAR 0 5
12378: ARRAY
12379: ST_TO_ADDR
// if a < 0 then
12380: LD_VAR 0 6
12384: PUSH
12385: LD_INT 0
12387: LESS
12388: IFFALSE 12445
// begin while a <= - 1 do
12390: LD_VAR 0 6
12394: PUSH
12395: LD_INT 1
12397: NEG
12398: LESSEQUAL
12399: IFFALSE 12429
// begin a := a + 1 ;
12401: LD_ADDR_VAR 0 6
12405: PUSH
12406: LD_VAR 0 6
12410: PUSH
12411: LD_INT 1
12413: PLUS
12414: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
12415: LD_VAR 0 1
12419: PPUSH
12420: LD_INT 35
12422: PPUSH
12423: CALL_OW 202
// end ;
12427: GO 12390
// i1 := i1 + 1 ;
12429: LD_ADDR_VAR 0 5
12433: PUSH
12434: LD_VAR 0 5
12438: PUSH
12439: LD_INT 1
12441: PLUS
12442: ST_TO_ADDR
// end else
12443: GO 12607
// begin if a = 0 then
12445: LD_VAR 0 6
12449: PUSH
12450: LD_INT 0
12452: EQUAL
12453: IFFALSE 12515
// begin a := path [ i1 + 1 ] ;
12455: LD_ADDR_VAR 0 6
12459: PUSH
12460: LD_VAR 0 2
12464: PUSH
12465: LD_VAR 0 5
12469: PUSH
12470: LD_INT 1
12472: PLUS
12473: ARRAY
12474: ST_TO_ADDR
// if a = 0 then
12475: LD_VAR 0 6
12479: PUSH
12480: LD_INT 0
12482: EQUAL
12483: IFFALSE 12494
// AddComReturn ( for_units ) ;
12485: LD_VAR 0 1
12489: PPUSH
12490: CALL_OW 204
// if a = 1 then
12494: LD_VAR 0 6
12498: PUSH
12499: LD_INT 1
12501: EQUAL
12502: IFFALSE 12513
// AddComRemember ( for_units ) ;
12504: LD_VAR 0 1
12508: PPUSH
12509: CALL_OW 203
// end else
12513: GO 12593
// begin if agressive then
12515: LD_VAR 0 3
12519: IFFALSE 12558
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
12521: LD_VAR 0 1
12525: PPUSH
12526: LD_VAR 0 2
12530: PUSH
12531: LD_VAR 0 5
12535: ARRAY
12536: PPUSH
12537: LD_VAR 0 2
12541: PUSH
12542: LD_VAR 0 5
12546: PUSH
12547: LD_INT 1
12549: PLUS
12550: ARRAY
12551: PPUSH
12552: CALL_OW 174
12556: GO 12593
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
12558: LD_VAR 0 1
12562: PPUSH
12563: LD_VAR 0 2
12567: PUSH
12568: LD_VAR 0 5
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 2
12578: PUSH
12579: LD_VAR 0 5
12583: PUSH
12584: LD_INT 1
12586: PLUS
12587: ARRAY
12588: PPUSH
12589: CALL_OW 171
// end ; i1 := i1 + 2 ;
12593: LD_ADDR_VAR 0 5
12597: PUSH
12598: LD_VAR 0 5
12602: PUSH
12603: LD_INT 2
12605: PLUS
12606: ST_TO_ADDR
// end ; end ;
12607: GO 12352
// end ;
12609: LD_VAR 0 4
12613: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
12614: LD_INT 0
12616: PPUSH
12617: PPUSH
12618: PPUSH
12619: PPUSH
12620: PPUSH
// forts := forts union [ ] ;
12621: LD_ADDR_VAR 0 1
12625: PUSH
12626: LD_VAR 0 1
12630: PUSH
12631: EMPTY
12632: UNION
12633: ST_TO_ADDR
// sols := sols union [ ] ;
12634: LD_ADDR_VAR 0 2
12638: PUSH
12639: LD_VAR 0 2
12643: PUSH
12644: EMPTY
12645: UNION
12646: ST_TO_ADDR
// for i in forts do
12647: LD_ADDR_VAR 0 6
12651: PUSH
12652: LD_VAR 0 1
12656: PUSH
12657: FOR_IN
12658: IFFALSE 12694
// if not UnitsInside ( i ) then
12660: LD_VAR 0 6
12664: PPUSH
12665: CALL_OW 313
12669: NOT
12670: IFFALSE 12692
// empty := add ( empty , i ) ;
12672: LD_ADDR_VAR 0 4
12676: PUSH
12677: LD_VAR 0 4
12681: PPUSH
12682: LD_VAR 0 6
12686: PPUSH
12687: CALL 13013 0 2
12691: ST_TO_ADDR
12692: GO 12657
12694: POP
12695: POP
// for i in sols do
12696: LD_ADDR_VAR 0 6
12700: PUSH
12701: LD_VAR 0 2
12705: PUSH
12706: FOR_IN
12707: IFFALSE 12755
// if not IsInUnit ( i ) and not IsBusy ( i ) then
12709: LD_VAR 0 6
12713: PPUSH
12714: CALL_OW 310
12718: NOT
12719: PUSH
12720: LD_VAR 0 6
12724: PPUSH
12725: CALL_OW 315
12729: NOT
12730: AND
12731: IFFALSE 12753
// free := add ( free , i ) ;
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PPUSH
12743: LD_VAR 0 6
12747: PPUSH
12748: CALL 13013 0 2
12752: ST_TO_ADDR
12753: GO 12706
12755: POP
12756: POP
// result := forts diff empty ;
12757: LD_ADDR_VAR 0 3
12761: PUSH
12762: LD_VAR 0 1
12766: PUSH
12767: LD_VAR 0 4
12771: DIFF
12772: ST_TO_ADDR
// if empty <= free then
12773: LD_VAR 0 4
12777: PUSH
12778: LD_VAR 0 5
12782: LESSEQUAL
12783: IFFALSE 12797
// konec := empty else
12785: LD_ADDR_VAR 0 7
12789: PUSH
12790: LD_VAR 0 4
12794: ST_TO_ADDR
12795: GO 12807
// konec := free ;
12797: LD_ADDR_VAR 0 7
12801: PUSH
12802: LD_VAR 0 5
12806: ST_TO_ADDR
// for i := 1 to konec do
12807: LD_ADDR_VAR 0 6
12811: PUSH
12812: DOUBLE
12813: LD_INT 1
12815: DEC
12816: ST_TO_ADDR
12817: LD_VAR 0 7
12821: PUSH
12822: FOR_TO
12823: IFFALSE 12879
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
12825: LD_VAR 0 5
12829: PUSH
12830: LD_VAR 0 6
12834: ARRAY
12835: PPUSH
12836: LD_VAR 0 4
12840: PUSH
12841: LD_VAR 0 6
12845: ARRAY
12846: PPUSH
12847: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
12851: LD_ADDR_VAR 0 3
12855: PUSH
12856: LD_VAR 0 3
12860: PPUSH
12861: LD_VAR 0 4
12865: PUSH
12866: LD_VAR 0 6
12870: ARRAY
12871: PPUSH
12872: CALL 13013 0 2
12876: ST_TO_ADDR
// end ;
12877: GO 12822
12879: POP
12880: POP
// end ;
12881: LD_VAR 0 3
12885: RET
// export function TalkOn ; begin
12886: LD_INT 0
12888: PPUSH
// end ;
12889: LD_VAR 0 1
12893: RET
// export function TalkOff ; begin
12894: LD_INT 0
12896: PPUSH
// end ;
12897: LD_VAR 0 1
12901: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
12902: LD_INT 0
12904: PPUSH
12905: PPUSH
12906: PPUSH
12907: PPUSH
// l1 := [ ] ;
12908: LD_ADDR_VAR 0 3
12912: PUSH
12913: EMPTY
12914: ST_TO_ADDR
// l2 := [ ] ;
12915: LD_ADDR_VAR 0 4
12919: PUSH
12920: EMPTY
12921: ST_TO_ADDR
// for i := 1 to list div 2 do
12922: LD_ADDR_VAR 0 5
12926: PUSH
12927: DOUBLE
12928: LD_INT 1
12930: DEC
12931: ST_TO_ADDR
12932: LD_VAR 0 1
12936: PUSH
12937: LD_INT 2
12939: DIV
12940: PUSH
12941: FOR_TO
12942: IFFALSE 12968
// begin l1 := l1 ^ list [ i ] ;
12944: LD_ADDR_VAR 0 3
12948: PUSH
12949: LD_VAR 0 3
12953: PUSH
12954: LD_VAR 0 1
12958: PUSH
12959: LD_VAR 0 5
12963: ARRAY
12964: ADD
12965: ST_TO_ADDR
// end ;
12966: GO 12941
12968: POP
12969: POP
// l2 := list diff l1 ;
12970: LD_ADDR_VAR 0 4
12974: PUSH
12975: LD_VAR 0 1
12979: PUSH
12980: LD_VAR 0 3
12984: DIFF
12985: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
12986: LD_ADDR_VAR 0 2
12990: PUSH
12991: LD_VAR 0 3
12995: PUSH
12996: EMPTY
12997: LIST
12998: PUSH
12999: LD_VAR 0 4
13003: PUSH
13004: EMPTY
13005: LIST
13006: ADD
13007: ST_TO_ADDR
// end ;
13008: LD_VAR 0 2
13012: RET
// export function add ( list , list1 ) ; begin
13013: LD_INT 0
13015: PPUSH
// if list = 0 then
13016: LD_VAR 0 1
13020: PUSH
13021: LD_INT 0
13023: EQUAL
13024: IFFALSE 13033
// list := [ ] ;
13026: LD_ADDR_VAR 0 1
13030: PUSH
13031: EMPTY
13032: ST_TO_ADDR
// if list1 = 0 then
13033: LD_VAR 0 2
13037: PUSH
13038: LD_INT 0
13040: EQUAL
13041: IFFALSE 13050
// list1 := [ ] ;
13043: LD_ADDR_VAR 0 2
13047: PUSH
13048: EMPTY
13049: ST_TO_ADDR
// result := list ^ list1 ;
13050: LD_ADDR_VAR 0 3
13054: PUSH
13055: LD_VAR 0 1
13059: PUSH
13060: LD_VAR 0 2
13064: ADD
13065: ST_TO_ADDR
// end ;
13066: LD_VAR 0 3
13070: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
13071: LD_INT 0
13073: PPUSH
13074: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
13075: LD_ADDR_VAR 0 8
13079: PUSH
13080: LD_VAR 0 1
13084: PPUSH
13085: LD_VAR 0 3
13089: PPUSH
13090: LD_VAR 0 4
13094: PPUSH
13095: LD_VAR 0 5
13099: PPUSH
13100: LD_VAR 0 6
13104: PPUSH
13105: CALL 13151 0 5
13109: ST_TO_ADDR
// if kdo then
13110: LD_VAR 0 8
13114: IFFALSE 13138
// result := Say ( kdo , ident ) else
13116: LD_ADDR_VAR 0 7
13120: PUSH
13121: LD_VAR 0 8
13125: PPUSH
13126: LD_VAR 0 2
13130: PPUSH
13131: CALL_OW 88
13135: ST_TO_ADDR
13136: GO 13146
// result := false ;
13138: LD_ADDR_VAR 0 7
13142: PUSH
13143: LD_INT 0
13145: ST_TO_ADDR
// end ;
13146: LD_VAR 0 7
13150: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
13151: LD_INT 0
13153: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
13154: LD_ADDR_VAR 0 1
13158: PUSH
13159: LD_VAR 0 1
13163: PPUSH
13164: LD_INT 21
13166: PUSH
13167: LD_INT 1
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: LD_INT 22
13176: PUSH
13177: LD_VAR 0 2
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 3
13188: PUSH
13189: LD_INT 23
13191: PUSH
13192: LD_INT 0
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: PPUSH
13205: CALL_OW 72
13209: ST_TO_ADDR
// if sex <> 0 then
13210: LD_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: NONEQUAL
13218: IFFALSE 13247
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
13220: LD_ADDR_VAR 0 1
13224: PUSH
13225: LD_VAR 0 1
13229: PPUSH
13230: LD_INT 26
13232: PUSH
13233: LD_VAR 0 3
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PPUSH
13242: CALL_OW 72
13246: ST_TO_ADDR
// if Hclass <> 0 then
13247: LD_VAR 0 4
13251: PUSH
13252: LD_INT 0
13254: NONEQUAL
13255: IFFALSE 13284
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
13257: LD_ADDR_VAR 0 1
13261: PUSH
13262: LD_VAR 0 1
13266: PPUSH
13267: LD_INT 25
13269: PUSH
13270: LD_VAR 0 4
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: PPUSH
13279: CALL_OW 72
13283: ST_TO_ADDR
// if index <= 0 then
13284: LD_VAR 0 5
13288: PUSH
13289: LD_INT 0
13291: LESSEQUAL
13292: IFFALSE 13302
// index := 1 ;
13294: LD_ADDR_VAR 0 5
13298: PUSH
13299: LD_INT 1
13301: ST_TO_ADDR
// if lidi >= index then
13302: LD_VAR 0 1
13306: PUSH
13307: LD_VAR 0 5
13311: GREATEREQUAL
13312: IFFALSE 13332
// result := lidi [ index ] else
13314: LD_ADDR_VAR 0 6
13318: PUSH
13319: LD_VAR 0 1
13323: PUSH
13324: LD_VAR 0 5
13328: ARRAY
13329: ST_TO_ADDR
13330: GO 13340
// result := 0 ;
13332: LD_ADDR_VAR 0 6
13336: PUSH
13337: LD_INT 0
13339: ST_TO_ADDR
// end ;
13340: LD_VAR 0 6
13344: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
13345: LD_INT 0
13347: PPUSH
13348: PPUSH
13349: PPUSH
// result := [ ] ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: EMPTY
13356: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
13357: LD_ADDR_VAR 0 4
13361: PUSH
13362: LD_VAR 0 1
13366: PPUSH
13367: EMPTY
13368: PPUSH
13369: CALL_OW 70
13373: ST_TO_ADDR
// for i in inbase do
13374: LD_ADDR_VAR 0 5
13378: PUSH
13379: LD_VAR 0 4
13383: PUSH
13384: FOR_IN
13385: IFFALSE 13458
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
13387: LD_VAR 0 5
13391: PPUSH
13392: CALL_OW 247
13396: PUSH
13397: LD_INT 3
13399: EQUAL
13400: PUSH
13401: LD_VAR 0 5
13405: PPUSH
13406: CALL_OW 247
13410: PUSH
13411: LD_INT 2
13413: EQUAL
13414: OR
13415: IFFALSE 13440
// begin result := result ^ UnitsInside ( i ) ;
13417: LD_ADDR_VAR 0 3
13421: PUSH
13422: LD_VAR 0 3
13426: PUSH
13427: LD_VAR 0 5
13431: PPUSH
13432: CALL_OW 313
13436: ADD
13437: ST_TO_ADDR
// end else
13438: GO 13456
// begin result := result ^ i ;
13440: LD_ADDR_VAR 0 3
13444: PUSH
13445: LD_VAR 0 3
13449: PUSH
13450: LD_VAR 0 5
13454: ADD
13455: ST_TO_ADDR
// end ; end ;
13456: GO 13384
13458: POP
13459: POP
// result := UnitFilter ( result , filter ) ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PPUSH
13470: LD_VAR 0 2
13474: PPUSH
13475: CALL_OW 72
13479: ST_TO_ADDR
// end ;
13480: LD_VAR 0 3
13484: RET
// export function ReverseList ( list ) ; var i ; begin
13485: LD_INT 0
13487: PPUSH
13488: PPUSH
// result := [ ] ;
13489: LD_ADDR_VAR 0 2
13493: PUSH
13494: EMPTY
13495: ST_TO_ADDR
// for i := list + 0 downto 1 do
13496: LD_ADDR_VAR 0 3
13500: PUSH
13501: DOUBLE
13502: LD_VAR 0 1
13506: PUSH
13507: LD_INT 0
13509: PLUS
13510: INC
13511: ST_TO_ADDR
13512: LD_INT 1
13514: PUSH
13515: FOR_DOWNTO
13516: IFFALSE 13545
// begin result := result ^ [ list [ i ] ] ;
13518: LD_ADDR_VAR 0 2
13522: PUSH
13523: LD_VAR 0 2
13527: PUSH
13528: LD_VAR 0 1
13532: PUSH
13533: LD_VAR 0 3
13537: ARRAY
13538: PUSH
13539: EMPTY
13540: LIST
13541: ADD
13542: ST_TO_ADDR
// end ;
13543: GO 13515
13545: POP
13546: POP
// end ;
13547: LD_VAR 0 2
13551: RET
// export using8 , using1 , using2 , using3 ; export path8 , path1 , path2 , path3 ; export kdo8 , kdo1 , kdo2 , kdo3 ; export using4 , using5 , using6 , using7 ; export path4 , path5 , path6 , path7 ; export kdo4 , kdo5 , kdo6 , kdo7 ; export function attack ( kdo , path ) ; var i , a ; begin
13552: LD_INT 0
13554: PPUSH
13555: PPUSH
13556: PPUSH
// for i in kdo do
13557: LD_ADDR_VAR 0 4
13561: PUSH
13562: LD_VAR 0 1
13566: PUSH
13567: FOR_IN
13568: IFFALSE 13584
// begin SetTag ( i , 1 ) ;
13570: LD_VAR 0 4
13574: PPUSH
13575: LD_INT 1
13577: PPUSH
13578: CALL_OW 109
// end ;
13582: GO 13567
13584: POP
13585: POP
// while kdo do
13586: LD_VAR 0 1
13590: IFFALSE 13885
// begin for i in kdo do
13592: LD_ADDR_VAR 0 4
13596: PUSH
13597: LD_VAR 0 1
13601: PUSH
13602: FOR_IN
13603: IFFALSE 13874
// begin a := GetTag ( i ) ;
13605: LD_ADDR_VAR 0 5
13609: PUSH
13610: LD_VAR 0 4
13614: PPUSH
13615: CALL_OW 110
13619: ST_TO_ADDR
// if a <= path then
13620: LD_VAR 0 5
13624: PUSH
13625: LD_VAR 0 2
13629: LESSEQUAL
13630: IFFALSE 13858
// begin if not IsDead ( i ) then
13632: LD_VAR 0 4
13636: PPUSH
13637: CALL_OW 301
13641: NOT
13642: IFFALSE 13816
// begin if IsIdle ( i ) then
13644: LD_VAR 0 4
13648: PPUSH
13649: CALL_OW 316
13653: IFFALSE 13814
// begin if a = 1 then
13655: LD_VAR 0 5
13659: PUSH
13660: LD_INT 1
13662: EQUAL
13663: IFFALSE 13704
// begin ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13665: LD_VAR 0 4
13669: PPUSH
13670: LD_VAR 0 2
13674: PUSH
13675: LD_VAR 0 5
13679: ARRAY
13680: PUSH
13681: LD_INT 1
13683: ARRAY
13684: PPUSH
13685: LD_VAR 0 2
13689: PUSH
13690: LD_VAR 0 5
13694: ARRAY
13695: PUSH
13696: LD_INT 2
13698: ARRAY
13699: PPUSH
13700: CALL_OW 114
// end ; if GetDistUnitXY ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) < 5 then
13704: LD_VAR 0 4
13708: PPUSH
13709: LD_VAR 0 2
13713: PUSH
13714: LD_VAR 0 5
13718: ARRAY
13719: PUSH
13720: LD_INT 1
13722: ARRAY
13723: PPUSH
13724: LD_VAR 0 2
13728: PUSH
13729: LD_VAR 0 5
13733: ARRAY
13734: PUSH
13735: LD_INT 2
13737: ARRAY
13738: PPUSH
13739: CALL_OW 297
13743: PUSH
13744: LD_INT 5
13746: LESS
13747: IFFALSE 13814
// begin a := a + 1 ;
13749: LD_ADDR_VAR 0 5
13753: PUSH
13754: LD_VAR 0 5
13758: PUSH
13759: LD_INT 1
13761: PLUS
13762: ST_TO_ADDR
// if a <= path then
13763: LD_VAR 0 5
13767: PUSH
13768: LD_VAR 0 2
13772: LESSEQUAL
13773: IFFALSE 13814
// ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13775: LD_VAR 0 4
13779: PPUSH
13780: LD_VAR 0 2
13784: PUSH
13785: LD_VAR 0 5
13789: ARRAY
13790: PUSH
13791: LD_INT 1
13793: ARRAY
13794: PPUSH
13795: LD_VAR 0 2
13799: PUSH
13800: LD_VAR 0 5
13804: ARRAY
13805: PUSH
13806: LD_INT 2
13808: ARRAY
13809: PPUSH
13810: CALL_OW 114
// end ; end ; end else
13814: GO 13830
// a := a + 1 ;
13816: LD_ADDR_VAR 0 5
13820: PUSH
13821: LD_VAR 0 5
13825: PUSH
13826: LD_INT 1
13828: PLUS
13829: ST_TO_ADDR
// if a > path then
13830: LD_VAR 0 5
13834: PUSH
13835: LD_VAR 0 2
13839: GREATER
13840: IFFALSE 13858
// kdo := kdo diff i ;
13842: LD_ADDR_VAR 0 1
13846: PUSH
13847: LD_VAR 0 1
13851: PUSH
13852: LD_VAR 0 4
13856: DIFF
13857: ST_TO_ADDR
// end ; SetTag ( i , a ) ;
13858: LD_VAR 0 4
13862: PPUSH
13863: LD_VAR 0 5
13867: PPUSH
13868: CALL_OW 109
// end ;
13872: GO 13602
13874: POP
13875: POP
// wait ( 0 0$1 ) ;
13876: LD_INT 35
13878: PPUSH
13879: CALL_OW 67
// end ;
13883: GO 13586
// end ;
13885: LD_VAR 0 3
13889: RET
// export function AttackBase ( kdo , path ) ; begin
13890: LD_INT 0
13892: PPUSH
// case false of using1 :
13893: LD_INT 0
13895: PUSH
13896: LD_EXP 83
13900: DOUBLE
13901: EQUAL
13902: IFTRUE 13906
13904: GO 13936
13906: POP
// begin kdo1 := kdo ;
13907: LD_ADDR_EXP 91
13911: PUSH
13912: LD_VAR 0 1
13916: ST_TO_ADDR
// path1 := path ;
13917: LD_ADDR_EXP 87
13921: PUSH
13922: LD_VAR 0 2
13926: ST_TO_ADDR
// RaiseSailEvent ( 1 ) ;
13927: LD_INT 1
13929: PPUSH
13930: CALL_OW 427
// end ; using2 :
13934: GO 14217
13936: LD_EXP 84
13940: DOUBLE
13941: EQUAL
13942: IFTRUE 13946
13944: GO 13976
13946: POP
// begin kdo2 := kdo ;
13947: LD_ADDR_EXP 92
13951: PUSH
13952: LD_VAR 0 1
13956: ST_TO_ADDR
// path2 := path ;
13957: LD_ADDR_EXP 88
13961: PUSH
13962: LD_VAR 0 2
13966: ST_TO_ADDR
// RaiseSailEvent ( 2 ) ;
13967: LD_INT 2
13969: PPUSH
13970: CALL_OW 427
// end ; using3 :
13974: GO 14217
13976: LD_EXP 85
13980: DOUBLE
13981: EQUAL
13982: IFTRUE 13986
13984: GO 14016
13986: POP
// begin kdo3 := kdo ;
13987: LD_ADDR_EXP 93
13991: PUSH
13992: LD_VAR 0 1
13996: ST_TO_ADDR
// path3 := path ;
13997: LD_ADDR_EXP 89
14001: PUSH
14002: LD_VAR 0 2
14006: ST_TO_ADDR
// RaiseSailEvent ( 3 ) ;
14007: LD_INT 3
14009: PPUSH
14010: CALL_OW 427
// end ; using4 :
14014: GO 14217
14016: LD_EXP 94
14020: DOUBLE
14021: EQUAL
14022: IFTRUE 14026
14024: GO 14056
14026: POP
// begin kdo4 := kdo ;
14027: LD_ADDR_EXP 102
14031: PUSH
14032: LD_VAR 0 1
14036: ST_TO_ADDR
// path4 := path ;
14037: LD_ADDR_EXP 98
14041: PUSH
14042: LD_VAR 0 2
14046: ST_TO_ADDR
// RaiseSailEvent ( 4 ) ;
14047: LD_INT 4
14049: PPUSH
14050: CALL_OW 427
// end ; using5 :
14054: GO 14217
14056: LD_EXP 95
14060: DOUBLE
14061: EQUAL
14062: IFTRUE 14066
14064: GO 14096
14066: POP
// begin kdo5 := kdo ;
14067: LD_ADDR_EXP 103
14071: PUSH
14072: LD_VAR 0 1
14076: ST_TO_ADDR
// path5 := path ;
14077: LD_ADDR_EXP 99
14081: PUSH
14082: LD_VAR 0 2
14086: ST_TO_ADDR
// RaiseSailEvent ( 5 ) ;
14087: LD_INT 5
14089: PPUSH
14090: CALL_OW 427
// end ; using6 :
14094: GO 14217
14096: LD_EXP 96
14100: DOUBLE
14101: EQUAL
14102: IFTRUE 14106
14104: GO 14136
14106: POP
// begin kdo6 := kdo ;
14107: LD_ADDR_EXP 104
14111: PUSH
14112: LD_VAR 0 1
14116: ST_TO_ADDR
// path6 := path ;
14117: LD_ADDR_EXP 100
14121: PUSH
14122: LD_VAR 0 2
14126: ST_TO_ADDR
// RaiseSailEvent ( 6 ) ;
14127: LD_INT 6
14129: PPUSH
14130: CALL_OW 427
// end ; using7 :
14134: GO 14217
14136: LD_EXP 97
14140: DOUBLE
14141: EQUAL
14142: IFTRUE 14146
14144: GO 14176
14146: POP
// begin kdo7 := kdo ;
14147: LD_ADDR_EXP 105
14151: PUSH
14152: LD_VAR 0 1
14156: ST_TO_ADDR
// path7 := path ;
14157: LD_ADDR_EXP 101
14161: PUSH
14162: LD_VAR 0 2
14166: ST_TO_ADDR
// RaiseSailEvent ( 7 ) ;
14167: LD_INT 7
14169: PPUSH
14170: CALL_OW 427
// end ; using8 :
14174: GO 14217
14176: LD_EXP 82
14180: DOUBLE
14181: EQUAL
14182: IFTRUE 14186
14184: GO 14216
14186: POP
// begin kdo8 := kdo ;
14187: LD_ADDR_EXP 90
14191: PUSH
14192: LD_VAR 0 1
14196: ST_TO_ADDR
// path8 := path ;
14197: LD_ADDR_EXP 86
14201: PUSH
14202: LD_VAR 0 2
14206: ST_TO_ADDR
// RaiseSailEvent ( 8 ) ;
14207: LD_INT 8
14209: PPUSH
14210: CALL_OW 427
// end ; end ;
14214: GO 14217
14216: POP
// end ;
14217: LD_VAR 0 3
14221: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
14222: LD_INT 0
14224: PPUSH
// if not hinty_co_byli then
14225: LD_EXP 106
14229: NOT
14230: IFFALSE 14239
// hinty_co_byli := [ ] ;
14232: LD_ADDR_EXP 106
14236: PUSH
14237: EMPTY
14238: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
14239: LD_VAR 0 1
14243: PUSH
14244: LD_EXP 106
14248: IN
14249: NOT
14250: IFFALSE 14277
// begin hinty_co_byli := hinty_co_byli ^ ident ;
14252: LD_ADDR_EXP 106
14256: PUSH
14257: LD_EXP 106
14261: PUSH
14262: LD_VAR 0 1
14266: ADD
14267: ST_TO_ADDR
// Hint ( ident ) ;
14268: LD_VAR 0 1
14272: PPUSH
14273: CALL_OW 339
// end ; end ; end_of_file
14277: LD_VAR 0 2
14281: RET
// every 0 0$0.3 trigger FilterUnitsInArea ( at_mine , [ [ f_side , you ] , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ] ) do var a ;
14282: LD_INT 20
14284: PPUSH
14285: LD_INT 22
14287: PUSH
14288: LD_EXP 47
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: LD_INT 2
14299: PUSH
14300: LD_INT 34
14302: PUSH
14303: LD_INT 44
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: PUSH
14310: LD_INT 34
14312: PUSH
14313: LD_INT 45
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: LD_INT 34
14322: PUSH
14323: LD_INT 46
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 70
14344: IFFALSE 14430
14346: GO 14348
14348: DISABLE
14349: LD_INT 0
14351: PPUSH
// begin if IsLive ( rumine1 ) then
14352: LD_EXP 68
14356: PPUSH
14357: CALL_OW 300
14361: IFFALSE 14429
// begin a := FilterUnitsInArea ( at_mine , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ) ;
14363: LD_ADDR_VAR 0 1
14367: PUSH
14368: LD_INT 20
14370: PPUSH
14371: LD_INT 2
14373: PUSH
14374: LD_INT 34
14376: PUSH
14377: LD_INT 44
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 34
14386: PUSH
14387: LD_INT 45
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 34
14396: PUSH
14397: LD_INT 46
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: PPUSH
14410: CALL_OW 70
14414: ST_TO_ADDR
// ComAttackUnit ( a , rumine1 ) ;
14415: LD_VAR 0 1
14419: PPUSH
14420: LD_EXP 68
14424: PPUSH
14425: CALL_OW 115
// end ; enable ;
14429: ENABLE
// end ;
14430: PPOPN 1
14432: END
// export function rep_car ( i ) ; begin
14433: LD_INT 0
14435: PPUSH
// case true of IsInArea ( i , NearL ) :
14436: LD_INT 1
14438: PUSH
14439: LD_VAR 0 1
14443: PPUSH
14444: LD_INT 16
14446: PPUSH
14447: CALL_OW 308
14451: DOUBLE
14452: EQUAL
14453: IFTRUE 14457
14455: GO 14472
14457: POP
// ComMoveToArea ( i , repL ) ; IsInArea ( i , NearM ) :
14458: LD_VAR 0 1
14462: PPUSH
14463: LD_INT 24
14465: PPUSH
14466: CALL_OW 113
14470: GO 14572
14472: LD_VAR 0 1
14476: PPUSH
14477: LD_INT 17
14479: PPUSH
14480: CALL_OW 308
14484: DOUBLE
14485: EQUAL
14486: IFTRUE 14490
14488: GO 14505
14490: POP
// ComMoveToArea ( i , repM ) ; IsInArea ( i , NearR ) :
14491: LD_VAR 0 1
14495: PPUSH
14496: LD_INT 25
14498: PPUSH
14499: CALL_OW 113
14503: GO 14572
14505: LD_VAR 0 1
14509: PPUSH
14510: LD_INT 18
14512: PPUSH
14513: CALL_OW 308
14517: DOUBLE
14518: EQUAL
14519: IFTRUE 14523
14521: GO 14538
14523: POP
// ComMoveToArea ( i , repR ) ; IsInArea ( i , NearT ) :
14524: LD_VAR 0 1
14528: PPUSH
14529: LD_INT 26
14531: PPUSH
14532: CALL_OW 113
14536: GO 14572
14538: LD_VAR 0 1
14542: PPUSH
14543: LD_INT 19
14545: PPUSH
14546: CALL_OW 308
14550: DOUBLE
14551: EQUAL
14552: IFTRUE 14556
14554: GO 14571
14556: POP
// ComMoveToArea ( i , repL ) ; end ;
14557: LD_VAR 0 1
14561: PPUSH
14562: LD_INT 24
14564: PPUSH
14565: CALL_OW 113
14569: GO 14572
14571: POP
// while not IsIdle ( i ) do
14572: LD_VAR 0 1
14576: PPUSH
14577: CALL_OW 316
14581: NOT
14582: IFFALSE 14593
// wait ( 0 0$1 ) ;
14584: LD_INT 35
14586: PPUSH
14587: CALL_OW 67
14591: GO 14572
// AddComExitVehicle ( UnitsInside ( i ) ) ;
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 313
14602: PPUSH
14603: CALL_OW 181
// end ;
14607: LD_VAR 0 2
14611: RET
// export function ret_car ( i ) ; begin
14612: LD_INT 0
14614: PPUSH
// ComEnterUnit ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) , i ) , i ) ;
14615: LD_INT 22
14617: PUSH
14618: LD_EXP 49
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 1
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: PPUSH
14646: LD_VAR 0 1
14650: PPUSH
14651: CALL_OW 74
14655: PPUSH
14656: LD_VAR 0 1
14660: PPUSH
14661: CALL_OW 120
// while not UnitsInside ( i ) do
14665: LD_VAR 0 1
14669: PPUSH
14670: CALL_OW 313
14674: NOT
14675: IFFALSE 14686
// wait ( 0 0$1 ) ;
14677: LD_INT 35
14679: PPUSH
14680: CALL_OW 67
14684: GO 14665
// ComAgressiveMove ( i , 92 , 92 ) ;
14686: LD_VAR 0 1
14690: PPUSH
14691: LD_INT 92
14693: PPUSH
14694: LD_INT 92
14696: PPUSH
14697: CALL_OW 114
// end ;
14701: LD_VAR 0 2
14705: RET
// every 0 0$1 do var vehs , i ;
14706: GO 14708
14708: DISABLE
14709: LD_INT 0
14711: PPUSH
14712: PPUSH
// begin vehs := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
14713: LD_ADDR_VAR 0 1
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_EXP 49
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: LD_INT 21
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: PPUSH
14744: CALL_OW 69
14748: ST_TO_ADDR
// for i in vehs do
14749: LD_ADDR_VAR 0 2
14753: PUSH
14754: LD_VAR 0 1
14758: PUSH
14759: FOR_IN
14760: IFFALSE 14852
// begin if GetClass ( UnitsInside ( i ) ) = class_mechanic then
14762: LD_VAR 0 2
14766: PPUSH
14767: CALL_OW 313
14771: PPUSH
14772: CALL_OW 257
14776: PUSH
14777: LD_INT 3
14779: EQUAL
14780: IFFALSE 14850
// begin if GetLives ( i ) < 600 then
14782: LD_VAR 0 2
14786: PPUSH
14787: CALL_OW 256
14791: PUSH
14792: LD_INT 600
14794: LESS
14795: IFFALSE 14810
// RaiseSailEvent ( i + 1000 ) ;
14797: LD_VAR 0 2
14801: PUSH
14802: LD_INT 1000
14804: PLUS
14805: PPUSH
14806: CALL_OW 427
// if GetLives ( i ) > 900 and not UnitsInside ( i ) then
14810: LD_VAR 0 2
14814: PPUSH
14815: CALL_OW 256
14819: PUSH
14820: LD_INT 900
14822: GREATER
14823: PUSH
14824: LD_VAR 0 2
14828: PPUSH
14829: CALL_OW 313
14833: NOT
14834: AND
14835: IFFALSE 14850
// RaiseSailEvent ( i + 2000 ) ;
14837: LD_VAR 0 2
14841: PUSH
14842: LD_INT 2000
14844: PLUS
14845: PPUSH
14846: CALL_OW 427
// end ; end ;
14850: GO 14759
14852: POP
14853: POP
// enable ;
14854: ENABLE
// end ;
14855: PPOPN 2
14857: END
// every 10 10$0 trigger utocit do var u1 , u2 , p1 , i , b1 ;
14858: LD_EXP 2
14862: IFFALSE 15340
14864: GO 14866
14866: DISABLE
14867: LD_INT 0
14869: PPUSH
14870: PPUSH
14871: PPUSH
14872: PPUSH
14873: PPUSH
// begin case difficulty of 1 :
14874: LD_OWVAR 67
14878: PUSH
14879: LD_INT 1
14881: DOUBLE
14882: EQUAL
14883: IFTRUE 14887
14885: GO 14952
14887: POP
// begin u1 := CreateVH ( [ mhmg , mhmg ] ) ;
14888: LD_ADDR_VAR 0 1
14892: PUSH
14893: LD_EXP 9
14897: PUSH
14898: LD_EXP 9
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PPUSH
14907: CALL 23178 0 1
14911: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
14912: LD_ADDR_VAR 0 3
14916: PUSH
14917: LD_INT 1
14919: PPUSH
14920: LD_INT 1
14922: PPUSH
14923: CALL 22725 0 2
14927: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
14928: LD_ADDR_VAR 0 5
14932: PUSH
14933: LD_INT 2
14935: PPUSH
14936: CALL 22930 0 1
14940: PUSH
14941: LD_INT 1
14943: PPUSH
14944: CALL 23054 0 1
14948: ADD
14949: ST_TO_ADDR
// end ; 2 :
14950: GO 15111
14952: LD_INT 2
14954: DOUBLE
14955: EQUAL
14956: IFTRUE 14960
14958: GO 15025
14960: POP
// begin u1 := CreateVH ( [ mhmg , mgg ] ) ;
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_EXP 9
14970: PUSH
14971: LD_EXP 10
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL 23178 0 1
14984: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
14985: LD_ADDR_VAR 0 3
14989: PUSH
14990: LD_INT 2
14992: PPUSH
14993: LD_INT 0
14995: PPUSH
14996: CALL 22725 0 2
15000: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15001: LD_ADDR_VAR 0 5
15005: PUSH
15006: LD_INT 3
15008: PPUSH
15009: CALL 22930 0 1
15013: PUSH
15014: LD_INT 2
15016: PPUSH
15017: CALL 23054 0 1
15021: ADD
15022: ST_TO_ADDR
// end ; 3 :
15023: GO 15111
15025: LD_INT 3
15027: DOUBLE
15028: EQUAL
15029: IFTRUE 15033
15031: GO 15110
15033: POP
// begin u1 := CreateVH ( [ mgg ] ) ;
15034: LD_ADDR_VAR 0 1
15038: PUSH
15039: LD_EXP 10
15043: PUSH
15044: EMPTY
15045: LIST
15046: PPUSH
15047: CALL 23178 0 1
15051: ST_TO_ADDR
// u2 := CreateVC ( [ mgg ] ) ;
15052: LD_ADDR_VAR 0 2
15056: PUSH
15057: LD_EXP 10
15061: PUSH
15062: EMPTY
15063: LIST
15064: PPUSH
15065: CALL 23504 0 1
15069: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15070: LD_ADDR_VAR 0 3
15074: PUSH
15075: LD_INT 1
15077: PPUSH
15078: LD_INT 0
15080: PPUSH
15081: CALL 22725 0 2
15085: ST_TO_ADDR
// b1 := CreateB ( 5 ) ^ CreateS ( 3 ) ;
15086: LD_ADDR_VAR 0 5
15090: PUSH
15091: LD_INT 5
15093: PPUSH
15094: CALL 22930 0 1
15098: PUSH
15099: LD_INT 3
15101: PPUSH
15102: CALL 23054 0 1
15106: ADD
15107: ST_TO_ADDR
// end ; end ;
15108: GO 15111
15110: POP
// for i := 1 to u1 do
15111: LD_ADDR_VAR 0 4
15115: PUSH
15116: DOUBLE
15117: LD_INT 1
15119: DEC
15120: ST_TO_ADDR
15121: LD_VAR 0 1
15125: PUSH
15126: FOR_TO
15127: IFFALSE 15157
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15129: LD_VAR 0 3
15133: PUSH
15134: LD_VAR 0 4
15138: ARRAY
15139: PPUSH
15140: LD_VAR 0 1
15144: PUSH
15145: LD_VAR 0 4
15149: ARRAY
15150: PPUSH
15151: CALL_OW 52
// end ;
15155: GO 15126
15157: POP
15158: POP
// for i in u1 do
15159: LD_ADDR_VAR 0 4
15163: PUSH
15164: LD_VAR 0 1
15168: PUSH
15169: FOR_IN
15170: IFFALSE 15189
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15172: LD_VAR 0 4
15176: PPUSH
15177: LD_INT 3
15179: PPUSH
15180: LD_INT 0
15182: PPUSH
15183: CALL 23834 0 3
// end ;
15187: GO 15169
15189: POP
15190: POP
// for i in u2 do
15191: LD_ADDR_VAR 0 4
15195: PUSH
15196: LD_VAR 0 2
15200: PUSH
15201: FOR_IN
15202: IFFALSE 15221
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15204: LD_VAR 0 4
15208: PPUSH
15209: LD_INT 3
15211: PPUSH
15212: LD_INT 0
15214: PPUSH
15215: CALL 23834 0 3
// end ;
15219: GO 15201
15221: POP
15222: POP
// wait ( 0 0$1 ) ;
15223: LD_INT 35
15225: PPUSH
15226: CALL_OW 67
// AttackBase ( u1 ^ u2 , pathBL ^ pathUL ) ;
15230: LD_VAR 0 1
15234: PUSH
15235: LD_VAR 0 2
15239: ADD
15240: PPUSH
15241: LD_EXP 108
15245: PUSH
15246: LD_EXP 111
15250: ADD
15251: PPUSH
15252: CALL 13890 0 2
// for i in b1 do
15256: LD_ADDR_VAR 0 4
15260: PUSH
15261: LD_VAR 0 5
15265: PUSH
15266: FOR_IN
15267: IFFALSE 15286
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15269: LD_VAR 0 4
15273: PPUSH
15274: LD_INT 14
15276: PPUSH
15277: LD_INT 0
15279: PPUSH
15280: CALL 23834 0 3
// end ;
15284: GO 15266
15286: POP
15287: POP
// wait ( 0 0$1 ) ;
15288: LD_INT 35
15290: PPUSH
15291: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15295: LD_VAR 0 5
15299: PPUSH
15300: LD_EXP 118
15304: PPUSH
15305: CALL 13890 0 2
// while not ContactTime ( [ russians ] ) do
15309: LD_EXP 49
15313: PUSH
15314: EMPTY
15315: LIST
15316: PPUSH
15317: CALL_OW 462
15321: NOT
15322: IFFALSE 15333
// wait ( 0 0$1 ) ;
15324: LD_INT 35
15326: PPUSH
15327: CALL_OW 67
15331: GO 15309
// MyHint ( PriorityAttacks ) ;
15333: LD_STRING PriorityAttacks
15335: PPUSH
15336: CALL 14222 0 1
// end ;
15340: PPOPN 5
15342: END
// every 15 15$0 trigger utocit do var u1 , p1 , b1 , i , u2 , u1a ;
15343: LD_EXP 2
15347: IFFALSE 15896
15349: GO 15351
15351: DISABLE
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
15358: PPUSH
15359: PPUSH
// begin case difficulty of 1 :
15360: LD_OWVAR 67
15364: PUSH
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15432
15373: POP
// begin u1 := CreateVH ( [ mg ] ) ;
15374: LD_ADDR_VAR 0 1
15378: PUSH
15379: LD_EXP 11
15383: PUSH
15384: EMPTY
15385: LIST
15386: PPUSH
15387: CALL 23178 0 1
15391: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15392: LD_ADDR_VAR 0 2
15396: PUSH
15397: LD_INT 1
15399: PPUSH
15400: LD_INT 0
15402: PPUSH
15403: CALL 22725 0 2
15407: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
15408: LD_ADDR_VAR 0 3
15412: PUSH
15413: LD_INT 2
15415: PPUSH
15416: CALL 22930 0 1
15420: PUSH
15421: LD_INT 1
15423: PPUSH
15424: CALL 23054 0 1
15428: ADD
15429: ST_TO_ADDR
// end ; 2 :
15430: GO 15567
15432: LD_INT 2
15434: DOUBLE
15435: EQUAL
15436: IFTRUE 15440
15438: GO 15499
15440: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15441: LD_ADDR_VAR 0 1
15445: PUSH
15446: LD_EXP 12
15450: PUSH
15451: EMPTY
15452: LIST
15453: PPUSH
15454: CALL 23178 0 1
15458: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15459: LD_ADDR_VAR 0 2
15463: PUSH
15464: LD_INT 1
15466: PPUSH
15467: LD_INT 0
15469: PPUSH
15470: CALL 22725 0 2
15474: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15475: LD_ADDR_VAR 0 3
15479: PUSH
15480: LD_INT 3
15482: PPUSH
15483: CALL 22930 0 1
15487: PUSH
15488: LD_INT 2
15490: PPUSH
15491: CALL 23054 0 1
15495: ADD
15496: ST_TO_ADDR
// end ; 3 :
15497: GO 15567
15499: LD_INT 3
15501: DOUBLE
15502: EQUAL
15503: IFTRUE 15507
15505: GO 15566
15507: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15508: LD_ADDR_VAR 0 1
15512: PUSH
15513: LD_EXP 12
15517: PUSH
15518: EMPTY
15519: LIST
15520: PPUSH
15521: CALL 23178 0 1
15525: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15526: LD_ADDR_VAR 0 2
15530: PUSH
15531: LD_INT 0
15533: PPUSH
15534: LD_INT 1
15536: PPUSH
15537: CALL 22725 0 2
15541: ST_TO_ADDR
// b1 := CreateB ( 4 ) ^ CreateS ( 3 ) ;
15542: LD_ADDR_VAR 0 3
15546: PUSH
15547: LD_INT 4
15549: PPUSH
15550: CALL 22930 0 1
15554: PUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 23054 0 1
15562: ADD
15563: ST_TO_ADDR
// end ; end ;
15564: GO 15567
15566: POP
// for i in b1 do
15567: LD_ADDR_VAR 0 4
15571: PUSH
15572: LD_VAR 0 3
15576: PUSH
15577: FOR_IN
15578: IFFALSE 15597
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15580: LD_VAR 0 4
15584: PPUSH
15585: LD_INT 14
15587: PPUSH
15588: LD_INT 0
15590: PPUSH
15591: CALL 23834 0 3
// end ;
15595: GO 15577
15597: POP
15598: POP
// wait ( 0 0$1 ) ;
15599: LD_INT 35
15601: PPUSH
15602: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15606: LD_VAR 0 3
15610: PPUSH
15611: LD_EXP 118
15615: PPUSH
15616: CALL 13890 0 2
// for i := 1 to u1 do
15620: LD_ADDR_VAR 0 4
15624: PUSH
15625: DOUBLE
15626: LD_INT 1
15628: DEC
15629: ST_TO_ADDR
15630: LD_VAR 0 1
15634: PUSH
15635: FOR_TO
15636: IFFALSE 15666
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15638: LD_VAR 0 2
15642: PUSH
15643: LD_VAR 0 4
15647: ARRAY
15648: PPUSH
15649: LD_VAR 0 1
15653: PUSH
15654: LD_VAR 0 4
15658: ARRAY
15659: PPUSH
15660: CALL_OW 52
// end ;
15664: GO 15635
15666: POP
15667: POP
// for i in u1 do
15668: LD_ADDR_VAR 0 4
15672: PUSH
15673: LD_VAR 0 1
15677: PUSH
15678: FOR_IN
15679: IFFALSE 15698
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
15681: LD_VAR 0 4
15685: PPUSH
15686: LD_INT 2
15688: PPUSH
15689: LD_INT 0
15691: PPUSH
15692: CALL 23834 0 3
// end ;
15696: GO 15678
15698: POP
15699: POP
// wait ( 0 0$1 ) ;
15700: LD_INT 35
15702: PPUSH
15703: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
15707: LD_VAR 0 1
15711: PPUSH
15712: LD_EXP 109
15716: PUSH
15717: LD_EXP 114
15721: PPUSH
15722: CALL 13485 0 1
15726: ADD
15727: PUSH
15728: LD_EXP 111
15732: ADD
15733: PPUSH
15734: CALL 13890 0 2
// case difficulty of 1 :
15738: LD_OWVAR 67
15742: PUSH
15743: LD_INT 1
15745: DOUBLE
15746: EQUAL
15747: IFTRUE 15751
15749: GO 15772
15751: POP
// begin u2 := CreateVC ( [ mg ] ) ;
15752: LD_ADDR_VAR 0 5
15756: PUSH
15757: LD_EXP 11
15761: PUSH
15762: EMPTY
15763: LIST
15764: PPUSH
15765: CALL 23504 0 1
15769: ST_TO_ADDR
// end ; 2 :
15770: GO 15837
15772: LD_INT 2
15774: DOUBLE
15775: EQUAL
15776: IFTRUE 15780
15778: GO 15801
15780: POP
// begin u2 := CreateVC ( [ hhg ] ) ;
15781: LD_ADDR_VAR 0 5
15785: PUSH
15786: LD_EXP 15
15790: PUSH
15791: EMPTY
15792: LIST
15793: PPUSH
15794: CALL 23504 0 1
15798: ST_TO_ADDR
// end ; 3 :
15799: GO 15837
15801: LD_INT 3
15803: DOUBLE
15804: EQUAL
15805: IFTRUE 15809
15807: GO 15836
15809: POP
// begin u2 := CreateVC ( [ mg , hhg ] ) ;
15810: LD_ADDR_VAR 0 5
15814: PUSH
15815: LD_EXP 11
15819: PUSH
15820: LD_EXP 15
15824: PUSH
15825: EMPTY
15826: LIST
15827: LIST
15828: PPUSH
15829: CALL 23504 0 1
15833: ST_TO_ADDR
// end ; end ;
15834: GO 15837
15836: POP
// for i in u2 do
15837: LD_ADDR_VAR 0 4
15841: PUSH
15842: LD_VAR 0 5
15846: PUSH
15847: FOR_IN
15848: IFFALSE 15867
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
15850: LD_VAR 0 4
15854: PPUSH
15855: LD_INT 15
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 23834 0 3
// end ;
15865: GO 15847
15867: POP
15868: POP
// wait ( 0 0$1 ) ;
15869: LD_INT 35
15871: PPUSH
15872: CALL_OW 67
// AttackBase ( u2 , pathBR ^ pathUR ) ;
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_EXP 110
15885: PUSH
15886: LD_EXP 112
15890: ADD
15891: PPUSH
15892: CALL 13890 0 2
// end ;
15896: PPOPN 6
15898: END
// every 18 18$0 trigger utocit do var u1 , p1 , i , u1a ;
15899: LD_EXP 2
15903: IFFALSE 16629
15905: GO 15907
15907: DISABLE
15908: LD_INT 0
15910: PPUSH
15911: PPUSH
15912: PPUSH
15913: PPUSH
// begin case difficulty of 1 :
15914: LD_OWVAR 67
15918: PUSH
15919: LD_INT 1
15921: DOUBLE
15922: EQUAL
15923: IFTRUE 15927
15925: GO 15982
15927: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15928: LD_ADDR_VAR 0 1
15932: PUSH
15933: LD_EXP 12
15937: PUSH
15938: EMPTY
15939: LIST
15940: PPUSH
15941: CALL 23178 0 1
15945: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
15946: LD_ADDR_VAR 0 4
15950: PUSH
15951: LD_EXP 12
15955: PUSH
15956: EMPTY
15957: LIST
15958: PPUSH
15959: CALL 23504 0 1
15963: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15964: LD_ADDR_VAR 0 2
15968: PUSH
15969: LD_INT 0
15971: PPUSH
15972: LD_INT 1
15974: PPUSH
15975: CALL 22725 0 2
15979: ST_TO_ADDR
// end ; 2 :
15980: GO 16115
15982: LD_INT 2
15984: DOUBLE
15985: EQUAL
15986: IFTRUE 15990
15988: GO 16045
15990: POP
// begin u1 := CreateVH ( [ hrl ] ) ;
15991: LD_ADDR_VAR 0 1
15995: PUSH
15996: LD_EXP 14
16000: PUSH
16001: EMPTY
16002: LIST
16003: PPUSH
16004: CALL 23178 0 1
16008: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16009: LD_ADDR_VAR 0 4
16013: PUSH
16014: LD_EXP 14
16018: PUSH
16019: EMPTY
16020: LIST
16021: PPUSH
16022: CALL 23504 0 1
16026: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16027: LD_ADDR_VAR 0 2
16031: PUSH
16032: LD_INT 0
16034: PPUSH
16035: LD_INT 1
16037: PPUSH
16038: CALL 22725 0 2
16042: ST_TO_ADDR
// end ; 3 :
16043: GO 16115
16045: LD_INT 3
16047: DOUBLE
16048: EQUAL
16049: IFTRUE 16053
16051: GO 16114
16053: POP
// begin u1 := CreateVH ( [ hrl , mrl ] ) ;
16054: LD_ADDR_VAR 0 1
16058: PUSH
16059: LD_EXP 14
16063: PUSH
16064: LD_EXP 12
16068: PUSH
16069: EMPTY
16070: LIST
16071: LIST
16072: PPUSH
16073: CALL 23178 0 1
16077: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16078: LD_ADDR_VAR 0 4
16082: PUSH
16083: LD_EXP 14
16087: PUSH
16088: EMPTY
16089: LIST
16090: PPUSH
16091: CALL 23504 0 1
16095: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16096: LD_ADDR_VAR 0 2
16100: PUSH
16101: LD_INT 1
16103: PPUSH
16104: LD_INT 1
16106: PPUSH
16107: CALL 22725 0 2
16111: ST_TO_ADDR
// end ; end ;
16112: GO 16115
16114: POP
// for i := 1 to u1 do
16115: LD_ADDR_VAR 0 3
16119: PUSH
16120: DOUBLE
16121: LD_INT 1
16123: DEC
16124: ST_TO_ADDR
16125: LD_VAR 0 1
16129: PUSH
16130: FOR_TO
16131: IFFALSE 16161
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16133: LD_VAR 0 2
16137: PUSH
16138: LD_VAR 0 3
16142: ARRAY
16143: PPUSH
16144: LD_VAR 0 1
16148: PUSH
16149: LD_VAR 0 3
16153: ARRAY
16154: PPUSH
16155: CALL_OW 52
// end ;
16159: GO 16130
16161: POP
16162: POP
// for i in u1 do
16163: LD_ADDR_VAR 0 3
16167: PUSH
16168: LD_VAR 0 1
16172: PUSH
16173: FOR_IN
16174: IFFALSE 16193
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16176: LD_VAR 0 3
16180: PPUSH
16181: LD_INT 3
16183: PPUSH
16184: LD_INT 0
16186: PPUSH
16187: CALL 23834 0 3
// end ;
16191: GO 16173
16193: POP
16194: POP
// for i in u1a do
16195: LD_ADDR_VAR 0 3
16199: PUSH
16200: LD_VAR 0 4
16204: PUSH
16205: FOR_IN
16206: IFFALSE 16225
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16208: LD_VAR 0 3
16212: PPUSH
16213: LD_INT 3
16215: PPUSH
16216: LD_INT 0
16218: PPUSH
16219: CALL 23834 0 3
// end ;
16223: GO 16205
16225: POP
16226: POP
// wait ( 0 0$1 ) ;
16227: LD_INT 35
16229: PPUSH
16230: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_EXP 108
16243: PUSH
16244: LD_EXP 111
16248: ADD
16249: PPUSH
16250: CALL 13890 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16254: LD_VAR 0 4
16258: PPUSH
16259: LD_EXP 108
16263: PUSH
16264: LD_EXP 111
16268: ADD
16269: PPUSH
16270: CALL 13890 0 2
// case difficulty of 1 :
16274: LD_OWVAR 67
16278: PUSH
16279: LD_INT 1
16281: DOUBLE
16282: EQUAL
16283: IFTRUE 16287
16285: GO 16331
16287: POP
// begin u1 := CreateVH ( [ mg ] ) ;
16288: LD_ADDR_VAR 0 1
16292: PUSH
16293: LD_EXP 11
16297: PUSH
16298: EMPTY
16299: LIST
16300: PPUSH
16301: CALL 23178 0 1
16305: ST_TO_ADDR
// u1a := [ ] ;
16306: LD_ADDR_VAR 0 4
16310: PUSH
16311: EMPTY
16312: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16313: LD_ADDR_VAR 0 2
16317: PUSH
16318: LD_INT 1
16320: PPUSH
16321: LD_INT 0
16323: PPUSH
16324: CALL 22725 0 2
16328: ST_TO_ADDR
// end ; 2 :
16329: GO 16458
16331: LD_INT 2
16333: DOUBLE
16334: EQUAL
16335: IFTRUE 16339
16337: GO 16394
16339: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16340: LD_ADDR_VAR 0 1
16344: PUSH
16345: LD_EXP 15
16349: PUSH
16350: EMPTY
16351: LIST
16352: PPUSH
16353: CALL 23178 0 1
16357: ST_TO_ADDR
// u1a := CreateVC ( [ mg ] ) ;
16358: LD_ADDR_VAR 0 4
16362: PUSH
16363: LD_EXP 11
16367: PUSH
16368: EMPTY
16369: LIST
16370: PPUSH
16371: CALL 23504 0 1
16375: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16376: LD_ADDR_VAR 0 2
16380: PUSH
16381: LD_INT 1
16383: PPUSH
16384: LD_INT 0
16386: PPUSH
16387: CALL 22725 0 2
16391: ST_TO_ADDR
// end ; 3 :
16392: GO 16458
16394: LD_INT 3
16396: DOUBLE
16397: EQUAL
16398: IFTRUE 16402
16400: GO 16457
16402: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16403: LD_ADDR_VAR 0 1
16407: PUSH
16408: LD_EXP 15
16412: PUSH
16413: EMPTY
16414: LIST
16415: PPUSH
16416: CALL 23178 0 1
16420: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16421: LD_ADDR_VAR 0 4
16425: PUSH
16426: LD_EXP 14
16430: PUSH
16431: EMPTY
16432: LIST
16433: PPUSH
16434: CALL 23504 0 1
16438: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16439: LD_ADDR_VAR 0 2
16443: PUSH
16444: LD_INT 0
16446: PPUSH
16447: LD_INT 1
16449: PPUSH
16450: CALL 22725 0 2
16454: ST_TO_ADDR
// end ; end ;
16455: GO 16458
16457: POP
// for i := 1 to u1 do
16458: LD_ADDR_VAR 0 3
16462: PUSH
16463: DOUBLE
16464: LD_INT 1
16466: DEC
16467: ST_TO_ADDR
16468: LD_VAR 0 1
16472: PUSH
16473: FOR_TO
16474: IFFALSE 16504
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16476: LD_VAR 0 2
16480: PUSH
16481: LD_VAR 0 3
16485: ARRAY
16486: PPUSH
16487: LD_VAR 0 1
16491: PUSH
16492: LD_VAR 0 3
16496: ARRAY
16497: PPUSH
16498: CALL_OW 52
// end ;
16502: GO 16473
16504: POP
16505: POP
// for i in u1 do
16506: LD_ADDR_VAR 0 3
16510: PUSH
16511: LD_VAR 0 1
16515: PUSH
16516: FOR_IN
16517: IFFALSE 16536
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16519: LD_VAR 0 3
16523: PPUSH
16524: LD_INT 15
16526: PPUSH
16527: LD_INT 0
16529: PPUSH
16530: CALL 23834 0 3
// end ;
16534: GO 16516
16536: POP
16537: POP
// for i in u1a do
16538: LD_ADDR_VAR 0 3
16542: PUSH
16543: LD_VAR 0 4
16547: PUSH
16548: FOR_IN
16549: IFFALSE 16568
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16551: LD_VAR 0 3
16555: PPUSH
16556: LD_INT 15
16558: PPUSH
16559: LD_INT 0
16561: PPUSH
16562: CALL 23834 0 3
// end ;
16566: GO 16548
16568: POP
16569: POP
// wait ( 0 0$1 ) ;
16570: LD_INT 35
16572: PPUSH
16573: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16577: LD_VAR 0 1
16581: PPUSH
16582: LD_EXP 110
16586: PUSH
16587: LD_EXP 116
16591: ADD
16592: PUSH
16593: LD_EXP 113
16597: ADD
16598: PPUSH
16599: CALL 13890 0 2
// AttackBase ( u1a , pathBR ^ pathMR ^ pathUT ) ;
16603: LD_VAR 0 4
16607: PPUSH
16608: LD_EXP 110
16612: PUSH
16613: LD_EXP 116
16617: ADD
16618: PUSH
16619: LD_EXP 113
16623: ADD
16624: PPUSH
16625: CALL 13890 0 2
// end ;
16629: PPOPN 4
16631: END
// every 22 22$0 trigger utocit do var u1 , p1 , i , u1a ;
16632: LD_EXP 2
16636: IFFALSE 17031
16638: GO 16640
16640: DISABLE
16641: LD_INT 0
16643: PPUSH
16644: PPUSH
16645: PPUSH
16646: PPUSH
// begin case difficulty of 1 :
16647: LD_OWVAR 67
16651: PUSH
16652: LD_INT 1
16654: DOUBLE
16655: EQUAL
16656: IFTRUE 16660
16658: GO 16721
16660: POP
// begin u1 := CreateVH ( [ mrl , mrl ] ) ;
16661: LD_ADDR_VAR 0 1
16665: PUSH
16666: LD_EXP 12
16670: PUSH
16671: LD_EXP 12
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL 23178 0 1
16684: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16685: LD_ADDR_VAR 0 4
16689: PUSH
16690: LD_EXP 12
16694: PUSH
16695: EMPTY
16696: LIST
16697: PPUSH
16698: CALL 23504 0 1
16702: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
16703: LD_ADDR_VAR 0 2
16707: PUSH
16708: LD_INT 0
16710: PPUSH
16711: LD_INT 2
16713: PPUSH
16714: CALL 22725 0 2
16718: ST_TO_ADDR
// end ; 2 :
16719: GO 16866
16721: LD_INT 2
16723: DOUBLE
16724: EQUAL
16725: IFTRUE 16729
16727: GO 16790
16729: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16730: LD_ADDR_VAR 0 1
16734: PUSH
16735: LD_EXP 14
16739: PUSH
16740: LD_EXP 14
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PPUSH
16749: CALL 23178 0 1
16753: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16754: LD_ADDR_VAR 0 4
16758: PUSH
16759: LD_EXP 12
16763: PUSH
16764: EMPTY
16765: LIST
16766: PPUSH
16767: CALL 23504 0 1
16771: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_INT 2
16779: PPUSH
16780: LD_INT 0
16782: PPUSH
16783: CALL 22725 0 2
16787: ST_TO_ADDR
// end ; 3 :
16788: GO 16866
16790: LD_INT 3
16792: DOUBLE
16793: EQUAL
16794: IFTRUE 16798
16796: GO 16865
16798: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16799: LD_ADDR_VAR 0 1
16803: PUSH
16804: LD_EXP 14
16808: PUSH
16809: LD_EXP 14
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PPUSH
16818: CALL 23178 0 1
16822: ST_TO_ADDR
// u1a := CreateVC ( [ hrl , hrl ] ) ;
16823: LD_ADDR_VAR 0 4
16827: PUSH
16828: LD_EXP 14
16832: PUSH
16833: LD_EXP 14
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PPUSH
16842: CALL 23504 0 1
16846: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16847: LD_ADDR_VAR 0 2
16851: PUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: CALL 22725 0 2
16862: ST_TO_ADDR
// end ; end ;
16863: GO 16866
16865: POP
// for i := 1 to u1 do
16866: LD_ADDR_VAR 0 3
16870: PUSH
16871: DOUBLE
16872: LD_INT 1
16874: DEC
16875: ST_TO_ADDR
16876: LD_VAR 0 1
16880: PUSH
16881: FOR_TO
16882: IFFALSE 16912
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16884: LD_VAR 0 2
16888: PUSH
16889: LD_VAR 0 3
16893: ARRAY
16894: PPUSH
16895: LD_VAR 0 1
16899: PUSH
16900: LD_VAR 0 3
16904: ARRAY
16905: PPUSH
16906: CALL_OW 52
// end ;
16910: GO 16881
16912: POP
16913: POP
// for i in u1 do
16914: LD_ADDR_VAR 0 3
16918: PUSH
16919: LD_VAR 0 1
16923: PUSH
16924: FOR_IN
16925: IFFALSE 16944
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16927: LD_VAR 0 3
16931: PPUSH
16932: LD_INT 15
16934: PPUSH
16935: LD_INT 0
16937: PPUSH
16938: CALL 23834 0 3
// end ;
16942: GO 16924
16944: POP
16945: POP
// for i in u1a do
16946: LD_ADDR_VAR 0 3
16950: PUSH
16951: LD_VAR 0 4
16955: PUSH
16956: FOR_IN
16957: IFFALSE 16976
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16959: LD_VAR 0 3
16963: PPUSH
16964: LD_INT 15
16966: PPUSH
16967: LD_INT 0
16969: PPUSH
16970: CALL 23834 0 3
// end ;
16974: GO 16956
16976: POP
16977: POP
// wait ( 0 0$4 ) ;
16978: LD_INT 140
16980: PPUSH
16981: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16985: LD_VAR 0 1
16989: PPUSH
16990: LD_EXP 110
16994: PUSH
16995: LD_EXP 116
16999: ADD
17000: PUSH
17001: LD_EXP 113
17005: ADD
17006: PPUSH
17007: CALL 13890 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
17011: LD_VAR 0 4
17015: PPUSH
17016: LD_EXP 108
17020: PUSH
17021: LD_EXP 111
17025: ADD
17026: PPUSH
17027: CALL 13890 0 2
// end ;
17031: PPOPN 4
17033: END
// every 37 37$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , b1 ;
17034: LD_EXP 2
17038: IFFALSE 17698
17040: GO 17042
17042: DISABLE
17043: LD_INT 0
17045: PPUSH
17046: PPUSH
17047: PPUSH
17048: PPUSH
17049: PPUSH
17050: PPUSH
17051: PPUSH
17052: PPUSH
// begin case difficulty of 1 :
17053: LD_OWVAR 67
17057: PUSH
17058: LD_INT 1
17060: DOUBLE
17061: EQUAL
17062: IFTRUE 17066
17064: GO 17109
17066: POP
// begin u1 := CreateVC ( [ mg ] ) ;
17067: LD_ADDR_VAR 0 1
17071: PUSH
17072: LD_EXP 11
17076: PUSH
17077: EMPTY
17078: LIST
17079: PPUSH
17080: CALL 23504 0 1
17084: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
17085: LD_ADDR_VAR 0 8
17089: PUSH
17090: LD_INT 2
17092: PPUSH
17093: CALL 22930 0 1
17097: PUSH
17098: LD_INT 1
17100: PPUSH
17101: CALL 23054 0 1
17105: ADD
17106: ST_TO_ADDR
// end ; 2 :
17107: GO 17218
17109: LD_INT 2
17111: DOUBLE
17112: EQUAL
17113: IFTRUE 17117
17115: GO 17160
17117: POP
// begin u1 := CreateVC ( [ hhg ] ) ;
17118: LD_ADDR_VAR 0 1
17122: PUSH
17123: LD_EXP 15
17127: PUSH
17128: EMPTY
17129: LIST
17130: PPUSH
17131: CALL 23504 0 1
17135: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 2 ) ;
17136: LD_ADDR_VAR 0 8
17140: PUSH
17141: LD_INT 2
17143: PPUSH
17144: CALL 22930 0 1
17148: PUSH
17149: LD_INT 2
17151: PPUSH
17152: CALL 23054 0 1
17156: ADD
17157: ST_TO_ADDR
// end ; 3 :
17158: GO 17218
17160: LD_INT 3
17162: DOUBLE
17163: EQUAL
17164: IFTRUE 17168
17166: GO 17217
17168: POP
// begin u1 := CreateVC ( [ hhg , hgg ] ) ;
17169: LD_ADDR_VAR 0 1
17173: PUSH
17174: LD_EXP 15
17178: PUSH
17179: LD_EXP 13
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: PPUSH
17188: CALL 23504 0 1
17192: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 3 ) ;
17193: LD_ADDR_VAR 0 8
17197: PUSH
17198: LD_INT 3
17200: PPUSH
17201: CALL 22930 0 1
17205: PUSH
17206: LD_INT 3
17208: PPUSH
17209: CALL 23054 0 1
17213: ADD
17214: ST_TO_ADDR
// end ; end ;
17215: GO 17218
17217: POP
// for i in u1 do
17218: LD_ADDR_VAR 0 3
17222: PUSH
17223: LD_VAR 0 1
17227: PUSH
17228: FOR_IN
17229: IFFALSE 17248
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17231: LD_VAR 0 3
17235: PPUSH
17236: LD_INT 14
17238: PPUSH
17239: LD_INT 0
17241: PPUSH
17242: CALL 23834 0 3
// end ;
17246: GO 17228
17248: POP
17249: POP
// wait ( 0 0$1 ) ;
17250: LD_INT 35
17252: PPUSH
17253: CALL_OW 67
// AttackBase ( u1 , pathUT ^ pathUR ) ;
17257: LD_VAR 0 1
17261: PPUSH
17262: LD_EXP 113
17266: PUSH
17267: LD_EXP 112
17271: ADD
17272: PPUSH
17273: CALL 13890 0 2
// AttackBase ( b1 , pathUT ^ pathUR ) ;
17277: LD_VAR 0 8
17281: PPUSH
17282: LD_EXP 113
17286: PUSH
17287: LD_EXP 112
17291: ADD
17292: PPUSH
17293: CALL 13890 0 2
// case difficulty of 1 :
17297: LD_OWVAR 67
17301: PUSH
17302: LD_INT 1
17304: DOUBLE
17305: EQUAL
17306: IFTRUE 17310
17308: GO 17347
17310: POP
// begin u2 := CreateVH ( [ mgg ] ) ;
17311: LD_ADDR_VAR 0 4
17315: PUSH
17316: LD_EXP 10
17320: PUSH
17321: EMPTY
17322: LIST
17323: PPUSH
17324: CALL 23178 0 1
17328: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
17329: LD_ADDR_VAR 0 5
17333: PUSH
17334: LD_INT 1
17336: PPUSH
17337: LD_INT 0
17339: PPUSH
17340: CALL 22725 0 2
17344: ST_TO_ADDR
// end ; 2 :
17345: GO 17450
17347: LD_INT 2
17349: DOUBLE
17350: EQUAL
17351: IFTRUE 17355
17353: GO 17398
17355: POP
// begin u2 := CreateVH ( [ mgg , mg ] ) ;
17356: LD_ADDR_VAR 0 4
17360: PUSH
17361: LD_EXP 10
17365: PUSH
17366: LD_EXP 11
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PPUSH
17375: CALL 23178 0 1
17379: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17380: LD_ADDR_VAR 0 5
17384: PUSH
17385: LD_INT 0
17387: PPUSH
17388: LD_INT 2
17390: PPUSH
17391: CALL 22725 0 2
17395: ST_TO_ADDR
// end ; 3 :
17396: GO 17450
17398: LD_INT 3
17400: DOUBLE
17401: EQUAL
17402: IFTRUE 17406
17404: GO 17449
17406: POP
// begin u2 := CreateVH ( [ mgg , hhg ] ) ;
17407: LD_ADDR_VAR 0 4
17411: PUSH
17412: LD_EXP 10
17416: PUSH
17417: LD_EXP 15
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: PPUSH
17426: CALL 23178 0 1
17430: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17431: LD_ADDR_VAR 0 5
17435: PUSH
17436: LD_INT 0
17438: PPUSH
17439: LD_INT 2
17441: PPUSH
17442: CALL 22725 0 2
17446: ST_TO_ADDR
// end ; end ;
17447: GO 17450
17449: POP
// for i := 1 to u2 do
17450: LD_ADDR_VAR 0 3
17454: PUSH
17455: DOUBLE
17456: LD_INT 1
17458: DEC
17459: ST_TO_ADDR
17460: LD_VAR 0 4
17464: PUSH
17465: FOR_TO
17466: IFFALSE 17496
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
17468: LD_VAR 0 5
17472: PUSH
17473: LD_VAR 0 3
17477: ARRAY
17478: PPUSH
17479: LD_VAR 0 4
17483: PUSH
17484: LD_VAR 0 3
17488: ARRAY
17489: PPUSH
17490: CALL_OW 52
// end ;
17494: GO 17465
17496: POP
17497: POP
// for i in u2 do
17498: LD_ADDR_VAR 0 3
17502: PUSH
17503: LD_VAR 0 4
17507: PUSH
17508: FOR_IN
17509: IFFALSE 17528
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
17511: LD_VAR 0 3
17515: PPUSH
17516: LD_INT 3
17518: PPUSH
17519: LD_INT 0
17521: PPUSH
17522: CALL 23834 0 3
// end ;
17526: GO 17508
17528: POP
17529: POP
// wait ( 0 0$1 ) ;
17530: LD_INT 35
17532: PPUSH
17533: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
17537: LD_VAR 0 4
17541: PPUSH
17542: LD_EXP 108
17546: PUSH
17547: LD_EXP 111
17551: ADD
17552: PPUSH
17553: CALL 13890 0 2
// case difficulty of 1 :
17557: LD_OWVAR 67
17561: PUSH
17562: LD_INT 1
17564: DOUBLE
17565: EQUAL
17566: IFTRUE 17570
17568: GO 17586
17570: POP
// begin u3 := CreateS ( 1 ) ;
17571: LD_ADDR_VAR 0 6
17575: PUSH
17576: LD_INT 1
17578: PPUSH
17579: CALL 23054 0 1
17583: ST_TO_ADDR
// ; end ; 2 :
17584: GO 17645
17586: LD_INT 2
17588: DOUBLE
17589: EQUAL
17590: IFTRUE 17594
17592: GO 17615
17594: POP
// begin u3 := CreateVC ( [ mgg ] ) ;
17595: LD_ADDR_VAR 0 6
17599: PUSH
17600: LD_EXP 10
17604: PUSH
17605: EMPTY
17606: LIST
17607: PPUSH
17608: CALL 23504 0 1
17612: ST_TO_ADDR
// end ; 3 :
17613: GO 17645
17615: LD_INT 3
17617: DOUBLE
17618: EQUAL
17619: IFTRUE 17623
17621: GO 17644
17623: POP
// begin u3 := CreateVC ( [ hgg ] ) ;
17624: LD_ADDR_VAR 0 6
17628: PUSH
17629: LD_EXP 13
17633: PUSH
17634: EMPTY
17635: LIST
17636: PPUSH
17637: CALL 23504 0 1
17641: ST_TO_ADDR
// end ; end ;
17642: GO 17645
17644: POP
// for i in u3 do
17645: LD_ADDR_VAR 0 3
17649: PUSH
17650: LD_VAR 0 6
17654: PUSH
17655: FOR_IN
17656: IFFALSE 17675
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17658: LD_VAR 0 3
17662: PPUSH
17663: LD_INT 14
17665: PPUSH
17666: LD_INT 0
17668: PPUSH
17669: CALL 23834 0 3
// end ;
17673: GO 17655
17675: POP
17676: POP
// wait ( 0 0$1 ) ;
17677: LD_INT 35
17679: PPUSH
17680: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
17684: LD_VAR 0 6
17688: PPUSH
17689: LD_EXP 117
17693: PPUSH
17694: CALL 13890 0 2
// end ;
17698: PPOPN 8
17700: END
// every 38 38$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
17701: LD_EXP 2
17705: IFFALSE 18166
17707: GO 17709
17709: DISABLE
17710: LD_INT 0
17712: PPUSH
17713: PPUSH
17714: PPUSH
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
// begin case difficulty of 1 :
17719: LD_OWVAR 67
17723: PUSH
17724: LD_INT 1
17726: DOUBLE
17727: EQUAL
17728: IFTRUE 17732
17730: GO 17769
17732: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
17733: LD_ADDR_VAR 0 1
17737: PUSH
17738: LD_EXP 15
17742: PUSH
17743: EMPTY
17744: LIST
17745: PPUSH
17746: CALL 23178 0 1
17750: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
17751: LD_ADDR_VAR 0 2
17755: PUSH
17756: LD_INT 1
17758: PPUSH
17759: LD_INT 0
17761: PPUSH
17762: CALL 22725 0 2
17766: ST_TO_ADDR
// end ; 2 :
17767: GO 17872
17769: LD_INT 2
17771: DOUBLE
17772: EQUAL
17773: IFTRUE 17777
17775: GO 17820
17777: POP
// begin u1 := CreateVH ( [ mrl , hhg ] ) ;
17778: LD_ADDR_VAR 0 1
17782: PUSH
17783: LD_EXP 12
17787: PUSH
17788: LD_EXP 15
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PPUSH
17797: CALL 23178 0 1
17801: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
17802: LD_ADDR_VAR 0 2
17806: PUSH
17807: LD_INT 1
17809: PPUSH
17810: LD_INT 1
17812: PPUSH
17813: CALL 22725 0 2
17817: ST_TO_ADDR
// end ; 3 :
17818: GO 17872
17820: LD_INT 3
17822: DOUBLE
17823: EQUAL
17824: IFTRUE 17828
17826: GO 17871
17828: POP
// begin u1 := CreateVH ( [ hrl , hhg ] ) ;
17829: LD_ADDR_VAR 0 1
17833: PUSH
17834: LD_EXP 14
17838: PUSH
17839: LD_EXP 15
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: PPUSH
17848: CALL 23178 0 1
17852: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
17853: LD_ADDR_VAR 0 2
17857: PUSH
17858: LD_INT 0
17860: PPUSH
17861: LD_INT 2
17863: PPUSH
17864: CALL 22725 0 2
17868: ST_TO_ADDR
// end ; end ;
17869: GO 17872
17871: POP
// for i := 1 to u1 do
17872: LD_ADDR_VAR 0 3
17876: PUSH
17877: DOUBLE
17878: LD_INT 1
17880: DEC
17881: ST_TO_ADDR
17882: LD_VAR 0 1
17886: PUSH
17887: FOR_TO
17888: IFFALSE 17918
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
17890: LD_VAR 0 2
17894: PUSH
17895: LD_VAR 0 3
17899: ARRAY
17900: PPUSH
17901: LD_VAR 0 1
17905: PUSH
17906: LD_VAR 0 3
17910: ARRAY
17911: PPUSH
17912: CALL_OW 52
// end ;
17916: GO 17887
17918: POP
17919: POP
// for i in u1 do
17920: LD_ADDR_VAR 0 3
17924: PUSH
17925: LD_VAR 0 1
17929: PUSH
17930: FOR_IN
17931: IFFALSE 17950
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
17933: LD_VAR 0 3
17937: PPUSH
17938: LD_INT 2
17940: PPUSH
17941: LD_INT 0
17943: PPUSH
17944: CALL 23834 0 3
// end ;
17948: GO 17930
17950: POP
17951: POP
// wait ( 0 0$4 ) ;
17952: LD_INT 140
17954: PPUSH
17955: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
17959: LD_VAR 0 1
17963: PPUSH
17964: LD_EXP 109
17968: PUSH
17969: LD_EXP 114
17973: PPUSH
17974: CALL 13485 0 1
17978: ADD
17979: PUSH
17980: LD_EXP 111
17984: ADD
17985: PPUSH
17986: CALL 13890 0 2
// case difficulty of 1 :
17990: LD_OWVAR 67
17994: PUSH
17995: LD_INT 1
17997: DOUBLE
17998: EQUAL
17999: IFTRUE 18003
18001: GO 18030
18003: POP
// begin u2 := CreateVC ( [ mgg , mrl ] ) ;
18004: LD_ADDR_VAR 0 4
18008: PUSH
18009: LD_EXP 10
18013: PUSH
18014: LD_EXP 12
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 23504 0 1
18027: ST_TO_ADDR
// end ; 2 :
18028: GO 18101
18030: LD_INT 2
18032: DOUBLE
18033: EQUAL
18034: IFTRUE 18038
18036: GO 18065
18038: POP
// begin u2 := CreateVC ( [ hgg , mrl ] ) ;
18039: LD_ADDR_VAR 0 4
18043: PUSH
18044: LD_EXP 13
18048: PUSH
18049: LD_EXP 12
18053: PUSH
18054: EMPTY
18055: LIST
18056: LIST
18057: PPUSH
18058: CALL 23504 0 1
18062: ST_TO_ADDR
// end ; 3 :
18063: GO 18101
18065: LD_INT 3
18067: DOUBLE
18068: EQUAL
18069: IFTRUE 18073
18071: GO 18100
18073: POP
// begin u2 := CreateVC ( [ hgg , hrl ] ) ;
18074: LD_ADDR_VAR 0 4
18078: PUSH
18079: LD_EXP 13
18083: PUSH
18084: LD_EXP 14
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PPUSH
18093: CALL 23504 0 1
18097: ST_TO_ADDR
// end ; end ;
18098: GO 18101
18100: POP
// for i in u2 do
18101: LD_ADDR_VAR 0 3
18105: PUSH
18106: LD_VAR 0 4
18110: PUSH
18111: FOR_IN
18112: IFFALSE 18131
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
18114: LD_VAR 0 3
18118: PPUSH
18119: LD_INT 2
18121: PPUSH
18122: LD_INT 0
18124: PPUSH
18125: CALL 23834 0 3
// end ;
18129: GO 18111
18131: POP
18132: POP
// wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// AttackBase ( u2 , pathBM ^ pathMM ^ pathUR ) ;
18140: LD_VAR 0 4
18144: PPUSH
18145: LD_EXP 109
18149: PUSH
18150: LD_EXP 115
18154: ADD
18155: PUSH
18156: LD_EXP 112
18160: ADD
18161: PPUSH
18162: CALL 13890 0 2
// end ;
18166: PPOPN 7
18168: END
// every 41 41$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
18169: LD_EXP 2
18173: IFFALSE 18369
18175: GO 18177
18177: DISABLE
18178: LD_INT 0
18180: PPUSH
18181: PPUSH
18182: PPUSH
18183: PPUSH
18184: PPUSH
18185: PPUSH
18186: PPUSH
// begin case difficulty of 1 :
18187: LD_OWVAR 67
18191: PUSH
18192: LD_INT 1
18194: DOUBLE
18195: EQUAL
18196: IFTRUE 18200
18198: GO 18227
18200: POP
// begin u1 := CreateVC ( [ hrl , mgg ] ) ;
18201: LD_ADDR_VAR 0 1
18205: PUSH
18206: LD_EXP 14
18210: PUSH
18211: LD_EXP 10
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: PPUSH
18220: CALL 23504 0 1
18224: ST_TO_ADDR
// end ; 2 :
18225: GO 18316
18227: LD_INT 2
18229: DOUBLE
18230: EQUAL
18231: IFTRUE 18235
18233: GO 18268
18235: POP
// begin u1 := CreateVC ( [ hrl , hrl , mgg ] ) ;
18236: LD_ADDR_VAR 0 1
18240: PUSH
18241: LD_EXP 14
18245: PUSH
18246: LD_EXP 14
18250: PUSH
18251: LD_EXP 10
18255: PUSH
18256: EMPTY
18257: LIST
18258: LIST
18259: LIST
18260: PPUSH
18261: CALL 23504 0 1
18265: ST_TO_ADDR
// end ; 3 :
18266: GO 18316
18268: LD_INT 3
18270: DOUBLE
18271: EQUAL
18272: IFTRUE 18276
18274: GO 18315
18276: POP
// begin u1 := CreateVC ( [ hrl , hrl , hhg , mgg ] ) ;
18277: LD_ADDR_VAR 0 1
18281: PUSH
18282: LD_EXP 14
18286: PUSH
18287: LD_EXP 14
18291: PUSH
18292: LD_EXP 15
18296: PUSH
18297: LD_EXP 10
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: PPUSH
18308: CALL 23504 0 1
18312: ST_TO_ADDR
// end ; end ;
18313: GO 18316
18315: POP
// for i in u1 do
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PUSH
18326: FOR_IN
18327: IFFALSE 18346
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18329: LD_VAR 0 3
18333: PPUSH
18334: LD_INT 14
18336: PPUSH
18337: LD_INT 0
18339: PPUSH
18340: CALL 23834 0 3
// end ;
18344: GO 18326
18346: POP
18347: POP
// wait ( 0 0$4 ) ;
18348: LD_INT 140
18350: PPUSH
18351: CALL_OW 67
// AttackBase ( u1 , pathT ) ;
18355: LD_VAR 0 1
18359: PPUSH
18360: LD_EXP 117
18364: PPUSH
18365: CALL 13890 0 2
// end ;
18369: PPOPN 7
18371: END
// every 44 44$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , u2a ;
18372: LD_EXP 2
18376: IFFALSE 19213
18378: GO 18380
18380: DISABLE
18381: LD_INT 0
18383: PPUSH
18384: PPUSH
18385: PPUSH
18386: PPUSH
18387: PPUSH
18388: PPUSH
18389: PPUSH
18390: PPUSH
// begin case difficulty of 1 :
18391: LD_OWVAR 67
18395: PUSH
18396: LD_INT 1
18398: DOUBLE
18399: EQUAL
18400: IFTRUE 18404
18402: GO 18453
18404: POP
// begin u1 := CreateVH ( [ hrl , mg , mrl ] ) ;
18405: LD_ADDR_VAR 0 1
18409: PUSH
18410: LD_EXP 14
18414: PUSH
18415: LD_EXP 11
18419: PUSH
18420: LD_EXP 12
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: LIST
18429: PPUSH
18430: CALL 23178 0 1
18434: ST_TO_ADDR
// p1 := CreateH ( 2 , 1 ) ;
18435: LD_ADDR_VAR 0 2
18439: PUSH
18440: LD_INT 2
18442: PPUSH
18443: LD_INT 1
18445: PPUSH
18446: CALL 22725 0 2
18450: ST_TO_ADDR
// end ; 2 :
18451: GO 18580
18453: LD_INT 2
18455: DOUBLE
18456: EQUAL
18457: IFTRUE 18461
18459: GO 18516
18461: POP
// begin u1 := CreateVH ( [ hrl , hhg , mrl , mgg ] ) ;
18462: LD_ADDR_VAR 0 1
18466: PUSH
18467: LD_EXP 14
18471: PUSH
18472: LD_EXP 15
18476: PUSH
18477: LD_EXP 12
18481: PUSH
18482: LD_EXP 10
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: LIST
18491: LIST
18492: PPUSH
18493: CALL 23178 0 1
18497: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18498: LD_ADDR_VAR 0 2
18502: PUSH
18503: LD_INT 3
18505: PPUSH
18506: LD_INT 1
18508: PPUSH
18509: CALL 22725 0 2
18513: ST_TO_ADDR
// end ; 3 :
18514: GO 18580
18516: LD_INT 3
18518: DOUBLE
18519: EQUAL
18520: IFTRUE 18524
18522: GO 18579
18524: POP
// begin u1 := CreateVH ( [ hrl , hhg , hrl , hgg ] ) ;
18525: LD_ADDR_VAR 0 1
18529: PUSH
18530: LD_EXP 14
18534: PUSH
18535: LD_EXP 15
18539: PUSH
18540: LD_EXP 14
18544: PUSH
18545: LD_EXP 13
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: PPUSH
18556: CALL 23178 0 1
18560: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18561: LD_ADDR_VAR 0 2
18565: PUSH
18566: LD_INT 3
18568: PPUSH
18569: LD_INT 1
18571: PPUSH
18572: CALL 22725 0 2
18576: ST_TO_ADDR
// end ; end ;
18577: GO 18580
18579: POP
// for i := 1 to u1 do
18580: LD_ADDR_VAR 0 3
18584: PUSH
18585: DOUBLE
18586: LD_INT 1
18588: DEC
18589: ST_TO_ADDR
18590: LD_VAR 0 1
18594: PUSH
18595: FOR_TO
18596: IFFALSE 18626
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
18598: LD_VAR 0 2
18602: PUSH
18603: LD_VAR 0 3
18607: ARRAY
18608: PPUSH
18609: LD_VAR 0 1
18613: PUSH
18614: LD_VAR 0 3
18618: ARRAY
18619: PPUSH
18620: CALL_OW 52
// end ;
18624: GO 18595
18626: POP
18627: POP
// for i in u1 do
18628: LD_ADDR_VAR 0 3
18632: PUSH
18633: LD_VAR 0 1
18637: PUSH
18638: FOR_IN
18639: IFFALSE 18658
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18641: LD_VAR 0 3
18645: PPUSH
18646: LD_INT 14
18648: PPUSH
18649: LD_INT 0
18651: PPUSH
18652: CALL 23834 0 3
// end ;
18656: GO 18638
18658: POP
18659: POP
// wait ( 0 0$1 ) ;
18660: LD_INT 35
18662: PPUSH
18663: CALL_OW 67
// AttackBase ( u1 , pathUT ) ;
18667: LD_VAR 0 1
18671: PPUSH
18672: LD_EXP 113
18676: PPUSH
18677: CALL 13890 0 2
// case difficulty of 1 :
18681: LD_OWVAR 67
18685: PUSH
18686: LD_INT 1
18688: DOUBLE
18689: EQUAL
18690: IFTRUE 18694
18692: GO 18755
18694: POP
// begin u2 := CreateVH ( [ hgg ] ) ;
18695: LD_ADDR_VAR 0 4
18699: PUSH
18700: LD_EXP 13
18704: PUSH
18705: EMPTY
18706: LIST
18707: PPUSH
18708: CALL 23178 0 1
18712: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18713: LD_ADDR_VAR 0 8
18717: PUSH
18718: LD_EXP 11
18722: PUSH
18723: LD_EXP 15
18727: PUSH
18728: EMPTY
18729: LIST
18730: LIST
18731: PPUSH
18732: CALL 23504 0 1
18736: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
18737: LD_ADDR_VAR 0 5
18741: PUSH
18742: LD_INT 1
18744: PPUSH
18745: LD_INT 0
18747: PPUSH
18748: CALL 22725 0 2
18752: ST_TO_ADDR
// end ; 2 :
18753: GO 18906
18755: LD_INT 2
18757: DOUBLE
18758: EQUAL
18759: IFTRUE 18763
18761: GO 18830
18763: POP
// begin u2 := CreateVH ( [ hgg , mrl ] ) ;
18764: LD_ADDR_VAR 0 4
18768: PUSH
18769: LD_EXP 13
18773: PUSH
18774: LD_EXP 12
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL 23178 0 1
18787: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18788: LD_ADDR_VAR 0 8
18792: PUSH
18793: LD_EXP 11
18797: PUSH
18798: LD_EXP 15
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PPUSH
18807: CALL 23504 0 1
18811: ST_TO_ADDR
// p2 := CreateH ( 1 , 1 ) ;
18812: LD_ADDR_VAR 0 5
18816: PUSH
18817: LD_INT 1
18819: PPUSH
18820: LD_INT 1
18822: PPUSH
18823: CALL 22725 0 2
18827: ST_TO_ADDR
// end ; 3 :
18828: GO 18906
18830: LD_INT 3
18832: DOUBLE
18833: EQUAL
18834: IFTRUE 18838
18836: GO 18905
18838: POP
// begin u2 := CreateVH ( [ hgg , hrl ] ) ;
18839: LD_ADDR_VAR 0 4
18843: PUSH
18844: LD_EXP 13
18848: PUSH
18849: LD_EXP 14
18853: PUSH
18854: EMPTY
18855: LIST
18856: LIST
18857: PPUSH
18858: CALL 23178 0 1
18862: ST_TO_ADDR
// u2a := CreateVC ( [ hhg , hhg ] ) ;
18863: LD_ADDR_VAR 0 8
18867: PUSH
18868: LD_EXP 15
18872: PUSH
18873: LD_EXP 15
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PPUSH
18882: CALL 23504 0 1
18886: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
18887: LD_ADDR_VAR 0 5
18891: PUSH
18892: LD_INT 0
18894: PPUSH
18895: LD_INT 2
18897: PPUSH
18898: CALL 22725 0 2
18902: ST_TO_ADDR
// end ; end ;
18903: GO 18906
18905: POP
// for i := 1 to u2 do
18906: LD_ADDR_VAR 0 3
18910: PUSH
18911: DOUBLE
18912: LD_INT 1
18914: DEC
18915: ST_TO_ADDR
18916: LD_VAR 0 4
18920: PUSH
18921: FOR_TO
18922: IFFALSE 18952
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
18924: LD_VAR 0 5
18928: PUSH
18929: LD_VAR 0 3
18933: ARRAY
18934: PPUSH
18935: LD_VAR 0 4
18939: PUSH
18940: LD_VAR 0 3
18944: ARRAY
18945: PPUSH
18946: CALL_OW 52
// end ;
18950: GO 18921
18952: POP
18953: POP
// for i in u2 ^ u2a do
18954: LD_ADDR_VAR 0 3
18958: PUSH
18959: LD_VAR 0 4
18963: PUSH
18964: LD_VAR 0 8
18968: ADD
18969: PUSH
18970: FOR_IN
18971: IFFALSE 18990
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
18973: LD_VAR 0 3
18977: PPUSH
18978: LD_INT 3
18980: PPUSH
18981: LD_INT 0
18983: PPUSH
18984: CALL 23834 0 3
// end ;
18988: GO 18970
18990: POP
18991: POP
// wait ( 0 0$1 ) ;
18992: LD_INT 35
18994: PPUSH
18995: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
18999: LD_VAR 0 4
19003: PPUSH
19004: LD_EXP 108
19008: PUSH
19009: LD_EXP 111
19013: ADD
19014: PPUSH
19015: CALL 13890 0 2
// case difficulty of 1 :
19019: LD_OWVAR 67
19023: PUSH
19024: LD_INT 1
19026: DOUBLE
19027: EQUAL
19028: IFTRUE 19032
19030: GO 19065
19032: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl ] ) ;
19033: LD_ADDR_VAR 0 6
19037: PUSH
19038: LD_EXP 10
19042: PUSH
19043: LD_EXP 11
19047: PUSH
19048: LD_EXP 12
19052: PUSH
19053: EMPTY
19054: LIST
19055: LIST
19056: LIST
19057: PPUSH
19058: CALL 23504 0 1
19062: ST_TO_ADDR
// end ; 2 :
19063: GO 19160
19065: LD_INT 2
19067: DOUBLE
19068: EQUAL
19069: IFTRUE 19073
19071: GO 19112
19073: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl , hgg ] ) ;
19074: LD_ADDR_VAR 0 6
19078: PUSH
19079: LD_EXP 10
19083: PUSH
19084: LD_EXP 11
19088: PUSH
19089: LD_EXP 12
19093: PUSH
19094: LD_EXP 13
19098: PUSH
19099: EMPTY
19100: LIST
19101: LIST
19102: LIST
19103: LIST
19104: PPUSH
19105: CALL 23504 0 1
19109: ST_TO_ADDR
// end ; 3 :
19110: GO 19160
19112: LD_INT 3
19114: DOUBLE
19115: EQUAL
19116: IFTRUE 19120
19118: GO 19159
19120: POP
// begin u3 := CreateVC ( [ mgg , mg , hrl , hgg ] ) ;
19121: LD_ADDR_VAR 0 6
19125: PUSH
19126: LD_EXP 10
19130: PUSH
19131: LD_EXP 11
19135: PUSH
19136: LD_EXP 14
19140: PUSH
19141: LD_EXP 13
19145: PUSH
19146: EMPTY
19147: LIST
19148: LIST
19149: LIST
19150: LIST
19151: PPUSH
19152: CALL 23504 0 1
19156: ST_TO_ADDR
// end ; end ;
19157: GO 19160
19159: POP
// for i in u3 do
19160: LD_ADDR_VAR 0 3
19164: PUSH
19165: LD_VAR 0 6
19169: PUSH
19170: FOR_IN
19171: IFFALSE 19190
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19173: LD_VAR 0 3
19177: PPUSH
19178: LD_INT 14
19180: PPUSH
19181: LD_INT 0
19183: PPUSH
19184: CALL 23834 0 3
// end ;
19188: GO 19170
19190: POP
19191: POP
// wait ( 0 0$1 ) ;
19192: LD_INT 35
19194: PPUSH
19195: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
19199: LD_VAR 0 6
19203: PPUSH
19204: LD_EXP 117
19208: PPUSH
19209: CALL 13890 0 2
// end ;
19213: PPOPN 8
19215: END
// every 0 0$5 trigger last_attack and timer < rusaci_pred_koncem do var u1 , p1 , i , u2 , p2 , u3 , p3 , u4 , p4 ;
19216: LD_EXP 3
19220: PUSH
19221: LD_EXP 62
19225: PUSH
19226: LD_EXP 6
19230: LESS
19231: AND
19232: IFFALSE 20815
19234: GO 19236
19236: DISABLE
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
19244: PPUSH
19245: PPUSH
19246: PPUSH
19247: PPUSH
// begin lev := [ 8 , 8 , 8 ] ;
19248: LD_ADDR_EXP 5
19252: PUSH
19253: LD_INT 8
19255: PUSH
19256: LD_INT 8
19258: PUSH
19259: LD_INT 8
19261: PUSH
19262: EMPTY
19263: LIST
19264: LIST
19265: LIST
19266: ST_TO_ADDR
// SetTech ( tech_Comp1 , russians , state_researched ) ;
19267: LD_INT 57
19269: PPUSH
19270: LD_EXP 49
19274: PPUSH
19275: LD_INT 2
19277: PPUSH
19278: CALL_OW 322
// SetTech ( tech_Comp2 , russians , state_researched ) ;
19282: LD_INT 58
19284: PPUSH
19285: LD_EXP 49
19289: PPUSH
19290: LD_INT 2
19292: PPUSH
19293: CALL_OW 322
// SetTech ( tech_Comp3 , russians , state_researched ) ;
19297: LD_INT 59
19299: PPUSH
19300: LD_EXP 49
19304: PPUSH
19305: LD_INT 2
19307: PPUSH
19308: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
19312: LD_INT 51
19314: PPUSH
19315: LD_EXP 49
19319: PPUSH
19320: LD_INT 2
19322: PPUSH
19323: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
19327: LD_INT 52
19329: PPUSH
19330: LD_EXP 49
19334: PPUSH
19335: LD_INT 2
19337: PPUSH
19338: CALL_OW 322
// SetTech ( tech_Weap3 , russians , state_researched ) ;
19342: LD_INT 53
19344: PPUSH
19345: LD_EXP 49
19349: PPUSH
19350: LD_INT 2
19352: PPUSH
19353: CALL_OW 322
// case difficulty of 1 :
19357: LD_OWVAR 67
19361: PUSH
19362: LD_INT 1
19364: DOUBLE
19365: EQUAL
19366: IFTRUE 19370
19368: GO 19409
19370: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19371: LD_ADDR_VAR 0 1
19375: PUSH
19376: LD_EXP 14
19380: PUSH
19381: LD_EXP 14
19385: PUSH
19386: LD_EXP 14
19390: PUSH
19391: LD_EXP 14
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 23504 0 1
19406: ST_TO_ADDR
// end ; 2 :
19407: GO 19504
19409: LD_INT 2
19411: DOUBLE
19412: EQUAL
19413: IFTRUE 19417
19415: GO 19456
19417: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19418: LD_ADDR_VAR 0 1
19422: PUSH
19423: LD_EXP 14
19427: PUSH
19428: LD_EXP 14
19432: PUSH
19433: LD_EXP 14
19437: PUSH
19438: LD_EXP 14
19442: PUSH
19443: EMPTY
19444: LIST
19445: LIST
19446: LIST
19447: LIST
19448: PPUSH
19449: CALL 23504 0 1
19453: ST_TO_ADDR
// end ; 3 :
19454: GO 19504
19456: LD_INT 3
19458: DOUBLE
19459: EQUAL
19460: IFTRUE 19464
19462: GO 19503
19464: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19465: LD_ADDR_VAR 0 1
19469: PUSH
19470: LD_EXP 14
19474: PUSH
19475: LD_EXP 14
19479: PUSH
19480: LD_EXP 14
19484: PUSH
19485: LD_EXP 14
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: PPUSH
19496: CALL 23504 0 1
19500: ST_TO_ADDR
// end ; end ;
19501: GO 19504
19503: POP
// for i in u1 do
19504: LD_ADDR_VAR 0 3
19508: PUSH
19509: LD_VAR 0 1
19513: PUSH
19514: FOR_IN
19515: IFFALSE 19534
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19517: LD_VAR 0 3
19521: PPUSH
19522: LD_INT 14
19524: PPUSH
19525: LD_INT 0
19527: PPUSH
19528: CALL 23834 0 3
// end ;
19532: GO 19514
19534: POP
19535: POP
// wait ( 0 0$1 ) ;
19536: LD_INT 35
19538: PPUSH
19539: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
19543: LD_VAR 0 1
19547: PPUSH
19548: LD_EXP 108
19552: PUSH
19553: LD_EXP 111
19557: ADD
19558: PPUSH
19559: CALL 13890 0 2
// case difficulty of 1 :
19563: LD_OWVAR 67
19567: PUSH
19568: LD_INT 1
19570: DOUBLE
19571: EQUAL
19572: IFTRUE 19576
19574: GO 19625
19576: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19577: LD_ADDR_VAR 0 4
19581: PUSH
19582: LD_EXP 15
19586: PUSH
19587: LD_EXP 15
19591: PUSH
19592: LD_EXP 14
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PPUSH
19602: CALL 23178 0 1
19606: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19607: LD_ADDR_VAR 0 5
19611: PUSH
19612: LD_INT 0
19614: PPUSH
19615: LD_INT 3
19617: PPUSH
19618: CALL 22725 0 2
19622: ST_TO_ADDR
// end ; 2 :
19623: GO 19740
19625: LD_INT 2
19627: DOUBLE
19628: EQUAL
19629: IFTRUE 19633
19631: GO 19682
19633: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19634: LD_ADDR_VAR 0 4
19638: PUSH
19639: LD_EXP 15
19643: PUSH
19644: LD_EXP 15
19648: PUSH
19649: LD_EXP 14
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: PPUSH
19659: CALL 23178 0 1
19663: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19664: LD_ADDR_VAR 0 5
19668: PUSH
19669: LD_INT 0
19671: PPUSH
19672: LD_INT 3
19674: PPUSH
19675: CALL 22725 0 2
19679: ST_TO_ADDR
// end ; 3 :
19680: GO 19740
19682: LD_INT 3
19684: DOUBLE
19685: EQUAL
19686: IFTRUE 19690
19688: GO 19739
19690: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19691: LD_ADDR_VAR 0 4
19695: PUSH
19696: LD_EXP 15
19700: PUSH
19701: LD_EXP 15
19705: PUSH
19706: LD_EXP 14
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: LIST
19715: PPUSH
19716: CALL 23178 0 1
19720: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19721: LD_ADDR_VAR 0 5
19725: PUSH
19726: LD_INT 0
19728: PPUSH
19729: LD_INT 3
19731: PPUSH
19732: CALL 22725 0 2
19736: ST_TO_ADDR
// end ; end ;
19737: GO 19740
19739: POP
// for i := 1 to u2 do
19740: LD_ADDR_VAR 0 3
19744: PUSH
19745: DOUBLE
19746: LD_INT 1
19748: DEC
19749: ST_TO_ADDR
19750: LD_VAR 0 4
19754: PUSH
19755: FOR_TO
19756: IFFALSE 19786
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
19758: LD_VAR 0 5
19762: PUSH
19763: LD_VAR 0 3
19767: ARRAY
19768: PPUSH
19769: LD_VAR 0 4
19773: PUSH
19774: LD_VAR 0 3
19778: ARRAY
19779: PPUSH
19780: CALL_OW 52
// end ;
19784: GO 19755
19786: POP
19787: POP
// for i in u2 do
19788: LD_ADDR_VAR 0 3
19792: PUSH
19793: LD_VAR 0 4
19797: PUSH
19798: FOR_IN
19799: IFFALSE 19818
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
19801: LD_VAR 0 3
19805: PPUSH
19806: LD_INT 2
19808: PPUSH
19809: LD_INT 0
19811: PPUSH
19812: CALL 23834 0 3
// end ;
19816: GO 19798
19818: POP
19819: POP
// wait ( 0 0$1 ) ;
19820: LD_INT 35
19822: PPUSH
19823: CALL_OW 67
// AttackBase ( u2 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
19827: LD_VAR 0 4
19831: PPUSH
19832: LD_EXP 109
19836: PUSH
19837: LD_EXP 114
19841: PPUSH
19842: CALL 13485 0 1
19846: ADD
19847: PUSH
19848: LD_EXP 111
19852: ADD
19853: PPUSH
19854: CALL 13890 0 2
// p4 := CreateS ( 3 ) ;
19858: LD_ADDR_VAR 0 9
19862: PUSH
19863: LD_INT 3
19865: PPUSH
19866: CALL 23054 0 1
19870: ST_TO_ADDR
// p4 := p4 ^ CreateB ( 3 ) ;
19871: LD_ADDR_VAR 0 9
19875: PUSH
19876: LD_VAR 0 9
19880: PUSH
19881: LD_INT 3
19883: PPUSH
19884: CALL 22930 0 1
19888: ADD
19889: ST_TO_ADDR
// for i in p4 do
19890: LD_ADDR_VAR 0 3
19894: PUSH
19895: LD_VAR 0 9
19899: PUSH
19900: FOR_IN
19901: IFFALSE 19920
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
19903: LD_VAR 0 3
19907: PPUSH
19908: LD_INT 15
19910: PPUSH
19911: LD_INT 0
19913: PPUSH
19914: CALL 23834 0 3
// end ;
19918: GO 19900
19920: POP
19921: POP
// wait ( 0 0$1 ) ;
19922: LD_INT 35
19924: PPUSH
19925: CALL_OW 67
// AttackBase ( p4 , pathBR ^ pathUR ) ;
19929: LD_VAR 0 9
19933: PPUSH
19934: LD_EXP 110
19938: PUSH
19939: LD_EXP 112
19943: ADD
19944: PPUSH
19945: CALL 13890 0 2
// case difficulty of 1 :
19949: LD_OWVAR 67
19953: PUSH
19954: LD_INT 1
19956: DOUBLE
19957: EQUAL
19958: IFTRUE 19962
19960: GO 20017
19962: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19963: LD_ADDR_VAR 0 6
19967: PUSH
19968: LD_EXP 15
19972: PUSH
19973: LD_EXP 14
19977: PUSH
19978: LD_EXP 15
19982: PUSH
19983: LD_EXP 13
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: PPUSH
19994: CALL 23178 0 1
19998: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
19999: LD_ADDR_VAR 0 7
20003: PUSH
20004: LD_INT 0
20006: PPUSH
20007: LD_INT 4
20009: PPUSH
20010: CALL 22725 0 2
20014: ST_TO_ADDR
// end ; 2 :
20015: GO 20144
20017: LD_INT 2
20019: DOUBLE
20020: EQUAL
20021: IFTRUE 20025
20023: GO 20080
20025: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20026: LD_ADDR_VAR 0 6
20030: PUSH
20031: LD_EXP 15
20035: PUSH
20036: LD_EXP 14
20040: PUSH
20041: LD_EXP 15
20045: PUSH
20046: LD_EXP 13
20050: PUSH
20051: EMPTY
20052: LIST
20053: LIST
20054: LIST
20055: LIST
20056: PPUSH
20057: CALL 23178 0 1
20061: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20062: LD_ADDR_VAR 0 7
20066: PUSH
20067: LD_INT 0
20069: PPUSH
20070: LD_INT 4
20072: PPUSH
20073: CALL 22725 0 2
20077: ST_TO_ADDR
// end ; 3 :
20078: GO 20144
20080: LD_INT 3
20082: DOUBLE
20083: EQUAL
20084: IFTRUE 20088
20086: GO 20143
20088: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20089: LD_ADDR_VAR 0 6
20093: PUSH
20094: LD_EXP 15
20098: PUSH
20099: LD_EXP 14
20103: PUSH
20104: LD_EXP 15
20108: PUSH
20109: LD_EXP 13
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL 23178 0 1
20124: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20125: LD_ADDR_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: PPUSH
20133: LD_INT 4
20135: PPUSH
20136: CALL 22725 0 2
20140: ST_TO_ADDR
// end ; end ;
20141: GO 20144
20143: POP
// for i := 1 to u3 do
20144: LD_ADDR_VAR 0 3
20148: PUSH
20149: DOUBLE
20150: LD_INT 1
20152: DEC
20153: ST_TO_ADDR
20154: LD_VAR 0 6
20158: PUSH
20159: FOR_TO
20160: IFFALSE 20190
// begin PlaceHumanInUnit ( p3 [ i ] , u3 [ i ] ) ;
20162: LD_VAR 0 7
20166: PUSH
20167: LD_VAR 0 3
20171: ARRAY
20172: PPUSH
20173: LD_VAR 0 6
20177: PUSH
20178: LD_VAR 0 3
20182: ARRAY
20183: PPUSH
20184: CALL_OW 52
// end ;
20188: GO 20159
20190: POP
20191: POP
// for i in u3 do
20192: LD_ADDR_VAR 0 3
20196: PUSH
20197: LD_VAR 0 6
20201: PUSH
20202: FOR_IN
20203: IFFALSE 20222
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20205: LD_VAR 0 3
20209: PPUSH
20210: LD_INT 15
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL 23834 0 3
// end ;
20220: GO 20202
20222: POP
20223: POP
// wait ( 0 0$1 ) ;
20224: LD_INT 35
20226: PPUSH
20227: CALL_OW 67
// AttackBase ( u3 , pathBR ^ pathUR ) ;
20231: LD_VAR 0 6
20235: PPUSH
20236: LD_EXP 110
20240: PUSH
20241: LD_EXP 112
20245: ADD
20246: PPUSH
20247: CALL 13890 0 2
// case difficulty of 1 :
20251: LD_OWVAR 67
20255: PUSH
20256: LD_INT 1
20258: DOUBLE
20259: EQUAL
20260: IFTRUE 20264
20262: GO 20303
20264: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20265: LD_ADDR_VAR 0 8
20269: PUSH
20270: LD_EXP 13
20274: PUSH
20275: LD_EXP 14
20279: PUSH
20280: LD_EXP 15
20284: PUSH
20285: LD_EXP 10
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: LIST
20294: LIST
20295: PPUSH
20296: CALL 23504 0 1
20300: ST_TO_ADDR
// end ; 2 :
20301: GO 20398
20303: LD_INT 2
20305: DOUBLE
20306: EQUAL
20307: IFTRUE 20311
20309: GO 20350
20311: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20312: LD_ADDR_VAR 0 8
20316: PUSH
20317: LD_EXP 13
20321: PUSH
20322: LD_EXP 14
20326: PUSH
20327: LD_EXP 15
20331: PUSH
20332: LD_EXP 10
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 23504 0 1
20347: ST_TO_ADDR
// end ; 3 :
20348: GO 20398
20350: LD_INT 3
20352: DOUBLE
20353: EQUAL
20354: IFTRUE 20358
20356: GO 20397
20358: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20359: LD_ADDR_VAR 0 8
20363: PUSH
20364: LD_EXP 13
20368: PUSH
20369: LD_EXP 14
20373: PUSH
20374: LD_EXP 15
20378: PUSH
20379: LD_EXP 10
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: PPUSH
20390: CALL 23504 0 1
20394: ST_TO_ADDR
// end ; end ;
20395: GO 20398
20397: POP
// for i in u4 do
20398: LD_ADDR_VAR 0 3
20402: PUSH
20403: LD_VAR 0 8
20407: PUSH
20408: FOR_IN
20409: IFFALSE 20428
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
20411: LD_VAR 0 3
20415: PPUSH
20416: LD_INT 14
20418: PPUSH
20419: LD_INT 0
20421: PPUSH
20422: CALL 23834 0 3
// end ;
20426: GO 20408
20428: POP
20429: POP
// wait ( 0 0$1 ) ;
20430: LD_INT 35
20432: PPUSH
20433: CALL_OW 67
// AttackBase ( u4 , pathUT ) ;
20437: LD_VAR 0 8
20441: PPUSH
20442: LD_EXP 113
20446: PPUSH
20447: CALL 13890 0 2
// p4 := CreateB ( 3 ) ;
20451: LD_ADDR_VAR 0 9
20455: PUSH
20456: LD_INT 3
20458: PPUSH
20459: CALL 22930 0 1
20463: ST_TO_ADDR
// p4 := p4 ^ CreateS ( 3 ) ;
20464: LD_ADDR_VAR 0 9
20468: PUSH
20469: LD_VAR 0 9
20473: PUSH
20474: LD_INT 3
20476: PPUSH
20477: CALL 23054 0 1
20481: ADD
20482: ST_TO_ADDR
// for i in p4 do
20483: LD_ADDR_VAR 0 3
20487: PUSH
20488: LD_VAR 0 9
20492: PUSH
20493: FOR_IN
20494: IFFALSE 20513
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20496: LD_VAR 0 3
20500: PPUSH
20501: LD_INT 15
20503: PPUSH
20504: LD_INT 0
20506: PPUSH
20507: CALL 23834 0 3
// end ;
20511: GO 20493
20513: POP
20514: POP
// wait ( 0 0$1 ) ;
20515: LD_INT 35
20517: PPUSH
20518: CALL_OW 67
// AttackBase ( p4 , pathUT ) ;
20522: LD_VAR 0 9
20526: PPUSH
20527: LD_EXP 113
20531: PPUSH
20532: CALL 13890 0 2
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_siberite_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_turret ] ] ] ) do
20536: LD_ADDR_VAR 0 3
20540: PUSH
20541: LD_INT 22
20543: PUSH
20544: LD_EXP 47
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 2
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 28
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: LD_INT 30
20568: PUSH
20569: LD_INT 26
20571: PUSH
20572: EMPTY
20573: LIST
20574: LIST
20575: PUSH
20576: LD_INT 30
20578: PUSH
20579: LD_INT 27
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: PUSH
20586: LD_INT 30
20588: PUSH
20589: LD_INT 5
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 4
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: LD_INT 30
20608: PUSH
20609: LD_INT 32
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: PUSH
20616: LD_INT 30
20618: PUSH
20619: LD_INT 31
20621: PUSH
20622: EMPTY
20623: LIST
20624: LIST
20625: PUSH
20626: LD_INT 30
20628: PUSH
20629: LD_INT 33
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: PPUSH
20651: CALL_OW 69
20655: PUSH
20656: FOR_IN
20657: IFFALSE 20675
// begin PriorityAttack ( russians , i ) ;
20659: LD_EXP 49
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL_OW 470
// end ;
20673: GO 20656
20675: POP
20676: POP
// wait ( 0 0$20 ) ;
20677: LD_INT 700
20679: PPUSH
20680: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_not , [ f_btype , b_warehouse ] ] , [ f_not , [ f_btype , b_depot ] ] ] ) do
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 22
20691: PUSH
20692: LD_EXP 47
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: LD_INT 3
20703: PUSH
20704: LD_INT 30
20706: PUSH
20707: LD_INT 1
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: PUSH
20714: EMPTY
20715: LIST
20716: LIST
20717: PUSH
20718: LD_INT 3
20720: PUSH
20721: LD_INT 30
20723: PUSH
20724: LD_INT 0
20726: PUSH
20727: EMPTY
20728: LIST
20729: LIST
20730: PUSH
20731: EMPTY
20732: LIST
20733: LIST
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: LIST
20739: PPUSH
20740: CALL_OW 69
20744: PUSH
20745: FOR_IN
20746: IFFALSE 20764
// begin PriorityAttack ( russians , i ) ;
20748: LD_EXP 49
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 470
// end ;
20762: GO 20745
20764: POP
20765: POP
// wait ( 0 0$30 ) ;
20766: LD_INT 1050
20768: PPUSH
20769: CALL_OW 67
// if Getside ( rudepot1 ) = you and xxx < 2 then
20773: LD_EXP 67
20777: PPUSH
20778: CALL_OW 255
20782: PUSH
20783: LD_EXP 47
20787: EQUAL
20788: PUSH
20789: LD_EXP 107
20793: PUSH
20794: LD_INT 2
20796: LESS
20797: AND
20798: IFFALSE 20815
// begin xxx := xxx + 1 ;
20800: LD_ADDR_EXP 107
20804: PUSH
20805: LD_EXP 107
20809: PUSH
20810: LD_INT 1
20812: PLUS
20813: ST_TO_ADDR
// enable ;
20814: ENABLE
// end ; end ;
20815: PPOPN 9
20817: END
// export xxx ; every 0 0$15 trigger GetSide ( RuDepot1 ) = you and not FilterHumansInArea ( base , [ f_side , you ] ) do var ing , i , a ;
20818: LD_EXP 67
20822: PPUSH
20823: CALL_OW 255
20827: PUSH
20828: LD_EXP 47
20832: EQUAL
20833: PUSH
20834: LD_INT 1
20836: PPUSH
20837: LD_INT 22
20839: PUSH
20840: LD_EXP 47
20844: PUSH
20845: EMPTY
20846: LIST
20847: LIST
20848: PPUSH
20849: CALL 13345 0 2
20853: NOT
20854: AND
20855: IFFALSE 21121
20857: GO 20859
20859: DISABLE
20860: LD_INT 0
20862: PPUSH
20863: PPUSH
20864: PPUSH
// begin InitUc ;
20865: CALL_OW 18
// InitHc ;
20869: CALL_OW 19
// uc_side := russians ;
20873: LD_ADDR_OWVAR 20
20877: PUSH
20878: LD_EXP 49
20882: ST_TO_ADDR
// uc_nation := nation_russian ;
20883: LD_ADDR_OWVAR 21
20887: PUSH
20888: LD_INT 3
20890: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
20891: LD_INT 0
20893: PPUSH
20894: LD_INT 6
20896: PPUSH
20897: CALL_OW 382
// ing := CreateHuman ;
20901: LD_ADDR_VAR 0 1
20905: PUSH
20906: CALL_OW 44
20910: ST_TO_ADDR
// PlaceUnitXYR ( ing , 137 , 147 , 4 , false ) ;
20911: LD_VAR 0 1
20915: PPUSH
20916: LD_INT 137
20918: PPUSH
20919: LD_INT 147
20921: PPUSH
20922: LD_INT 4
20924: PPUSH
20925: LD_INT 0
20927: PPUSH
20928: CALL_OW 50
// wait ( 0 0$5 ) ;
20932: LD_INT 175
20934: PPUSH
20935: CALL_OW 67
// a := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) ;
20939: LD_ADDR_VAR 0 3
20943: PUSH
20944: LD_INT 22
20946: PUSH
20947: LD_EXP 49
20951: PUSH
20952: EMPTY
20953: LIST
20954: LIST
20955: PUSH
20956: LD_INT 25
20958: PUSH
20959: LD_INT 2
20961: PUSH
20962: EMPTY
20963: LIST
20964: LIST
20965: PUSH
20966: EMPTY
20967: LIST
20968: LIST
20969: PPUSH
20970: CALL_OW 69
20974: ST_TO_ADDR
// ComMoveUnit ( a , rudepot1 ) ;
20975: LD_VAR 0 3
20979: PPUSH
20980: LD_EXP 67
20984: PPUSH
20985: CALL_OW 112
// wait ( 0 0$20 ) ;
20989: LD_INT 700
20991: PPUSH
20992: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) > 3 then
20996: LD_INT 22
20998: PUSH
20999: LD_EXP 49
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PUSH
21008: LD_INT 25
21010: PUSH
21011: LD_INT 2
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: PPUSH
21022: CALL_OW 69
21026: PUSH
21027: LD_INT 3
21029: GREATER
21030: IFFALSE 21120
// begin TimerEnable := true ;
21032: LD_ADDR_EXP 63
21036: PUSH
21037: LD_INT 1
21039: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
21040: LD_ADDR_EXP 81
21044: PUSH
21045: LD_EXP 49
21049: PPUSH
21050: CALL_OW 462
21054: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
21055: LD_EXP 67
21059: PPUSH
21060: CALL_OW 274
21064: PPUSH
21065: LD_EXP 49
21069: PPUSH
21070: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you ] ] ) do
21074: LD_ADDR_VAR 0 2
21078: PUSH
21079: LD_INT 22
21081: PUSH
21082: LD_EXP 47
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: PUSH
21091: EMPTY
21092: LIST
21093: PPUSH
21094: CALL_OW 69
21098: PUSH
21099: FOR_IN
21100: IFFALSE 21118
// NormalAttack ( russians , i ) ;
21102: LD_EXP 49
21106: PPUSH
21107: LD_VAR 0 2
21111: PPUSH
21112: CALL_OW 472
21116: GO 21099
21118: POP
21119: POP
// end ; enable ;
21120: ENABLE
// end ;
21121: PPOPN 3
21123: END
// every 0 0$5 do var a ;
21124: GO 21126
21126: DISABLE
21127: LD_INT 0
21129: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , russians ] , [ f_not , [ f_hastask ] ] ] ) ;
21130: LD_ADDR_VAR 0 1
21134: PUSH
21135: LD_INT 22
21137: PUSH
21138: LD_EXP 49
21142: PUSH
21143: EMPTY
21144: LIST
21145: LIST
21146: PUSH
21147: LD_INT 3
21149: PUSH
21150: LD_INT 60
21152: PUSH
21153: EMPTY
21154: LIST
21155: PUSH
21156: EMPTY
21157: LIST
21158: LIST
21159: PUSH
21160: EMPTY
21161: LIST
21162: LIST
21163: PPUSH
21164: CALL_OW 69
21168: ST_TO_ADDR
// wait ( 0 0$5 ) ;
21169: LD_INT 175
21171: PPUSH
21172: CALL_OW 67
// a := UnitFilter ( a , [ f_not , [ f_hastask ] ] ) ;
21176: LD_ADDR_VAR 0 1
21180: PUSH
21181: LD_VAR 0 1
21185: PPUSH
21186: LD_INT 3
21188: PUSH
21189: LD_INT 60
21191: PUSH
21192: EMPTY
21193: LIST
21194: PUSH
21195: EMPTY
21196: LIST
21197: LIST
21198: PPUSH
21199: CALL_OW 72
21203: ST_TO_ADDR
// if a then
21204: LD_VAR 0 1
21208: IFFALSE 21276
// begin ComAgressiveMove ( UnitFilter ( a , [ [ f_inarea , top_half ] ] ) , 42 , 10 ) ;
21210: LD_VAR 0 1
21214: PPUSH
21215: LD_INT 95
21217: PUSH
21218: LD_INT 6
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: PUSH
21225: EMPTY
21226: LIST
21227: PPUSH
21228: CALL_OW 72
21232: PPUSH
21233: LD_INT 42
21235: PPUSH
21236: LD_INT 10
21238: PPUSH
21239: CALL_OW 114
// ComAgressiveMove ( UnitFilter ( a , [ [ f_exceptarea , top_half ] ] ) , 93 , 94 ) ;
21243: LD_VAR 0 1
21247: PPUSH
21248: LD_INT 96
21250: PUSH
21251: LD_INT 6
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: PUSH
21258: EMPTY
21259: LIST
21260: PPUSH
21261: CALL_OW 72
21265: PPUSH
21266: LD_INT 93
21268: PPUSH
21269: LD_INT 94
21271: PPUSH
21272: CALL_OW 114
// end ; enable ;
21276: ENABLE
// end ;
21277: PPOPN 1
21279: END
// export pathBL , pathBM , pathBR , pathUL , pathUR , pathUT , pathML , pathMM , pathMR , pathT ; export pathB1 , pathB2 , pathB3 , pathB4 ; var d ; every 0 0$0.1 do
21280: GO 21282
21282: DISABLE
// begin pathBL := [ [ 62 , 119 ] , [ 73 , 120 ] , [ 78 , 121 ] , [ 80 , 118 ] , [ 80 , 113 ] , [ 80 , 109 ] ] ;
21283: LD_ADDR_EXP 108
21287: PUSH
21288: LD_INT 62
21290: PUSH
21291: LD_INT 119
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: LD_INT 73
21300: PUSH
21301: LD_INT 120
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 78
21310: PUSH
21311: LD_INT 121
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 80
21320: PUSH
21321: LD_INT 118
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: PUSH
21328: LD_INT 80
21330: PUSH
21331: LD_INT 113
21333: PUSH
21334: EMPTY
21335: LIST
21336: LIST
21337: PUSH
21338: LD_INT 80
21340: PUSH
21341: LD_INT 109
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: ST_TO_ADDR
// pathBM := [ [ 98 , 144 ] , [ 96 , 139 ] , [ 96 , 135 ] , [ 96 , 131 ] , [ 97 , 128 ] , [ 99 , 126 ] , [ 101 , 124 ] ] ;
21356: LD_ADDR_EXP 109
21360: PUSH
21361: LD_INT 98
21363: PUSH
21364: LD_INT 144
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PUSH
21371: LD_INT 96
21373: PUSH
21374: LD_INT 139
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: PUSH
21381: LD_INT 96
21383: PUSH
21384: LD_INT 135
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: LD_INT 96
21393: PUSH
21394: LD_INT 131
21396: PUSH
21397: EMPTY
21398: LIST
21399: LIST
21400: PUSH
21401: LD_INT 97
21403: PUSH
21404: LD_INT 128
21406: PUSH
21407: EMPTY
21408: LIST
21409: LIST
21410: PUSH
21411: LD_INT 99
21413: PUSH
21414: LD_INT 126
21416: PUSH
21417: EMPTY
21418: LIST
21419: LIST
21420: PUSH
21421: LD_INT 101
21423: PUSH
21424: LD_INT 124
21426: PUSH
21427: EMPTY
21428: LIST
21429: LIST
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: ST_TO_ADDR
// pathBR := [ [ 130 , 137 ] , [ 120 , 128 ] ] ;
21440: LD_ADDR_EXP 110
21444: PUSH
21445: LD_INT 130
21447: PUSH
21448: LD_INT 137
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: PUSH
21455: LD_INT 120
21457: PUSH
21458: LD_INT 128
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: PUSH
21465: EMPTY
21466: LIST
21467: LIST
21468: ST_TO_ADDR
// pathUL := [ [ 80 , 109 ] , [ 77 , 103 ] , [ 72 , 97 ] , [ 71 , 93 ] , [ 76 , 93 ] , [ 81 , 93 ] , [ 86 , 94 ] , [ 92 , 95 ] ] ;
21469: LD_ADDR_EXP 111
21473: PUSH
21474: LD_INT 80
21476: PUSH
21477: LD_INT 109
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: PUSH
21484: LD_INT 77
21486: PUSH
21487: LD_INT 103
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: LD_INT 72
21496: PUSH
21497: LD_INT 97
21499: PUSH
21500: EMPTY
21501: LIST
21502: LIST
21503: PUSH
21504: LD_INT 71
21506: PUSH
21507: LD_INT 93
21509: PUSH
21510: EMPTY
21511: LIST
21512: LIST
21513: PUSH
21514: LD_INT 76
21516: PUSH
21517: LD_INT 93
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: PUSH
21524: LD_INT 81
21526: PUSH
21527: LD_INT 93
21529: PUSH
21530: EMPTY
21531: LIST
21532: LIST
21533: PUSH
21534: LD_INT 86
21536: PUSH
21537: LD_INT 94
21539: PUSH
21540: EMPTY
21541: LIST
21542: LIST
21543: PUSH
21544: LD_INT 92
21546: PUSH
21547: LD_INT 95
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: LIST
21558: LIST
21559: LIST
21560: LIST
21561: LIST
21562: LIST
21563: ST_TO_ADDR
// pathUR := [ [ 120 , 128 ] , [ 115 , 123 ] , [ 110 , 118 ] , [ 106 , 114 ] , [ 99 , 107 ] , [ 96 , 100 ] , [ 92 , 95 ] ] ;
21564: LD_ADDR_EXP 112
21568: PUSH
21569: LD_INT 120
21571: PUSH
21572: LD_INT 128
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: LD_INT 115
21581: PUSH
21582: LD_INT 123
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 110
21591: PUSH
21592: LD_INT 118
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 106
21601: PUSH
21602: LD_INT 114
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: PUSH
21609: LD_INT 99
21611: PUSH
21612: LD_INT 107
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 96
21621: PUSH
21622: LD_INT 100
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 92
21631: PUSH
21632: LD_INT 95
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: LIST
21643: LIST
21644: LIST
21645: LIST
21646: LIST
21647: ST_TO_ADDR
// pathUT := [ [ 111 , 87 ] , [ 107 , 88 ] , [ 103 , 88 ] , [ 100 , 85 ] , [ 95 , 85 ] , [ 91 , 85 ] ] ;
21648: LD_ADDR_EXP 113
21652: PUSH
21653: LD_INT 111
21655: PUSH
21656: LD_INT 87
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: PUSH
21663: LD_INT 107
21665: PUSH
21666: LD_INT 88
21668: PUSH
21669: EMPTY
21670: LIST
21671: LIST
21672: PUSH
21673: LD_INT 103
21675: PUSH
21676: LD_INT 88
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 100
21685: PUSH
21686: LD_INT 85
21688: PUSH
21689: EMPTY
21690: LIST
21691: LIST
21692: PUSH
21693: LD_INT 95
21695: PUSH
21696: LD_INT 85
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PUSH
21703: LD_INT 91
21705: PUSH
21706: LD_INT 85
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PUSH
21713: EMPTY
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// pathML := [ [ 80 , 109 ] , [ 85 , 111 ] , [ 89 , 112 ] , [ 94 , 117 ] , [ 98 , 121 ] , [ 101 , 124 ] ] ;
21721: LD_ADDR_EXP 114
21725: PUSH
21726: LD_INT 80
21728: PUSH
21729: LD_INT 109
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: PUSH
21736: LD_INT 85
21738: PUSH
21739: LD_INT 111
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: PUSH
21746: LD_INT 89
21748: PUSH
21749: LD_INT 112
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 94
21758: PUSH
21759: LD_INT 117
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 98
21768: PUSH
21769: LD_INT 121
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: LD_INT 101
21778: PUSH
21779: LD_INT 124
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: LIST
21790: LIST
21791: LIST
21792: LIST
21793: ST_TO_ADDR
// pathMM := [ [ 101 , 124 ] , [ 105 , 125 ] , [ 112 , 128 ] , [ 117 , 129 ] , [ 120 , 128 ] ] ;
21794: LD_ADDR_EXP 115
21798: PUSH
21799: LD_INT 101
21801: PUSH
21802: LD_INT 124
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 105
21811: PUSH
21812: LD_INT 125
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 112
21821: PUSH
21822: LD_INT 128
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: PUSH
21829: LD_INT 117
21831: PUSH
21832: LD_INT 129
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: LD_INT 120
21841: PUSH
21842: LD_INT 128
21844: PUSH
21845: EMPTY
21846: LIST
21847: LIST
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: LIST
21853: LIST
21854: LIST
21855: ST_TO_ADDR
// pathMR := [ [ 120 , 128 ] , [ 121 , 124 ] , [ 119 , 118 ] , [ 116 , 112 ] , [ 115 , 105 ] , [ 116 , 100 ] , [ 114 , 92 ] , [ 111 , 87 ] ] ;
21856: LD_ADDR_EXP 116
21860: PUSH
21861: LD_INT 120
21863: PUSH
21864: LD_INT 128
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: LD_INT 121
21873: PUSH
21874: LD_INT 124
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: LD_INT 119
21883: PUSH
21884: LD_INT 118
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: LD_INT 116
21893: PUSH
21894: LD_INT 112
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: LD_INT 115
21903: PUSH
21904: LD_INT 105
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: LD_INT 116
21913: PUSH
21914: LD_INT 100
21916: PUSH
21917: EMPTY
21918: LIST
21919: LIST
21920: PUSH
21921: LD_INT 114
21923: PUSH
21924: LD_INT 92
21926: PUSH
21927: EMPTY
21928: LIST
21929: LIST
21930: PUSH
21931: LD_INT 111
21933: PUSH
21934: LD_INT 87
21936: PUSH
21937: EMPTY
21938: LIST
21939: LIST
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: ST_TO_ADDR
// pathT := [ [ 111 , 87 ] , [ 109 , 82 ] , [ 105 , 77 ] , [ 103 , 71 ] , [ 100 , 65 ] , [ 97 , 62 ] , [ 93 , 61 ] , [ 92 , 56 ] , [ 90 , 52 ] , [ 87 , 48 ] , [ 82 , 46 ] , [ 78 , 44 ] , [ 76 , 37 ] , [ 75 , 33 ] , [ 75 , 29 ] , [ 71 , 25 ] , [ 67 , 23 ] , [ 62 , 22 ] , [ 59 , 23 ] , [ 57 , 26 ] , [ 54 , 37 ] , [ 51 , 29 ] , [ 47 , 26 ] , [ 45 , 23 ] , [ 42 , 18 ] ] ;
21951: LD_ADDR_EXP 117
21955: PUSH
21956: LD_INT 111
21958: PUSH
21959: LD_INT 87
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: PUSH
21966: LD_INT 109
21968: PUSH
21969: LD_INT 82
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PUSH
21976: LD_INT 105
21978: PUSH
21979: LD_INT 77
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: PUSH
21986: LD_INT 103
21988: PUSH
21989: LD_INT 71
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: LD_INT 100
21998: PUSH
21999: LD_INT 65
22001: PUSH
22002: EMPTY
22003: LIST
22004: LIST
22005: PUSH
22006: LD_INT 97
22008: PUSH
22009: LD_INT 62
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 93
22018: PUSH
22019: LD_INT 61
22021: PUSH
22022: EMPTY
22023: LIST
22024: LIST
22025: PUSH
22026: LD_INT 92
22028: PUSH
22029: LD_INT 56
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: PUSH
22036: LD_INT 90
22038: PUSH
22039: LD_INT 52
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: PUSH
22046: LD_INT 87
22048: PUSH
22049: LD_INT 48
22051: PUSH
22052: EMPTY
22053: LIST
22054: LIST
22055: PUSH
22056: LD_INT 82
22058: PUSH
22059: LD_INT 46
22061: PUSH
22062: EMPTY
22063: LIST
22064: LIST
22065: PUSH
22066: LD_INT 78
22068: PUSH
22069: LD_INT 44
22071: PUSH
22072: EMPTY
22073: LIST
22074: LIST
22075: PUSH
22076: LD_INT 76
22078: PUSH
22079: LD_INT 37
22081: PUSH
22082: EMPTY
22083: LIST
22084: LIST
22085: PUSH
22086: LD_INT 75
22088: PUSH
22089: LD_INT 33
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: PUSH
22096: LD_INT 75
22098: PUSH
22099: LD_INT 29
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PUSH
22106: LD_INT 71
22108: PUSH
22109: LD_INT 25
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: PUSH
22116: LD_INT 67
22118: PUSH
22119: LD_INT 23
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: LD_INT 62
22128: PUSH
22129: LD_INT 22
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: LD_INT 59
22138: PUSH
22139: LD_INT 23
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PUSH
22146: LD_INT 57
22148: PUSH
22149: LD_INT 26
22151: PUSH
22152: EMPTY
22153: LIST
22154: LIST
22155: PUSH
22156: LD_INT 54
22158: PUSH
22159: LD_INT 37
22161: PUSH
22162: EMPTY
22163: LIST
22164: LIST
22165: PUSH
22166: LD_INT 51
22168: PUSH
22169: LD_INT 29
22171: PUSH
22172: EMPTY
22173: LIST
22174: LIST
22175: PUSH
22176: LD_INT 47
22178: PUSH
22179: LD_INT 26
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: PUSH
22186: LD_INT 45
22188: PUSH
22189: LD_INT 23
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: LD_INT 42
22198: PUSH
22199: LD_INT 18
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: LIST
22218: LIST
22219: LIST
22220: LIST
22221: LIST
22222: LIST
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: LIST
22232: ST_TO_ADDR
// pathB1 := [ [ 97 , 72 ] , [ 84 , 67 ] , [ 84 , 77 ] ] ;
22233: LD_ADDR_EXP 118
22237: PUSH
22238: LD_INT 97
22240: PUSH
22241: LD_INT 72
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PUSH
22248: LD_INT 84
22250: PUSH
22251: LD_INT 67
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PUSH
22258: LD_INT 84
22260: PUSH
22261: LD_INT 77
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: LIST
22272: ST_TO_ADDR
// pathB2 := [ [ 44 , 71 ] , [ 64 , 68 ] , [ 64 , 79 ] ] ;
22273: LD_ADDR_EXP 119
22277: PUSH
22278: LD_INT 44
22280: PUSH
22281: LD_INT 71
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PUSH
22288: LD_INT 64
22290: PUSH
22291: LD_INT 68
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PUSH
22298: LD_INT 64
22300: PUSH
22301: LD_INT 79
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: EMPTY
22309: LIST
22310: LIST
22311: LIST
22312: ST_TO_ADDR
// pathB3 := [ [ 91 , 131 ] , [ 93 , 121 ] , [ 94 , 115 ] , [ 107 , 115 ] ] ;
22313: LD_ADDR_EXP 120
22317: PUSH
22318: LD_INT 91
22320: PUSH
22321: LD_INT 131
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 93
22330: PUSH
22331: LD_INT 121
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: LD_INT 94
22340: PUSH
22341: LD_INT 115
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: PUSH
22348: LD_INT 107
22350: PUSH
22351: LD_INT 115
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: ST_TO_ADDR
// pathB4 := [ [ 126 , 128 ] , [ 116 , 107 ] , [ 107 , 87 ] ] ;
22364: LD_ADDR_EXP 121
22368: PUSH
22369: LD_INT 126
22371: PUSH
22372: LD_INT 128
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: PUSH
22379: LD_INT 116
22381: PUSH
22382: LD_INT 107
22384: PUSH
22385: EMPTY
22386: LIST
22387: LIST
22388: PUSH
22389: LD_INT 107
22391: PUSH
22392: LD_INT 87
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: LIST
22403: ST_TO_ADDR
// lev := [ 2 , 4 , 7 ] ;
22404: LD_ADDR_EXP 5
22408: PUSH
22409: LD_INT 2
22411: PUSH
22412: LD_INT 4
22414: PUSH
22415: LD_INT 7
22417: PUSH
22418: EMPTY
22419: LIST
22420: LIST
22421: LIST
22422: ST_TO_ADDR
// d := difficulty ;
22423: LD_ADDR_LOC 2
22427: PUSH
22428: LD_OWVAR 67
22432: ST_TO_ADDR
// case true of d <= 1 :
22433: LD_INT 1
22435: PUSH
22436: LD_LOC 2
22440: PUSH
22441: LD_INT 1
22443: LESSEQUAL
22444: DOUBLE
22445: EQUAL
22446: IFTRUE 22450
22448: GO 22453
22450: POP
// ; d <= 2 :
22451: GO 22548
22453: LD_LOC 2
22457: PUSH
22458: LD_INT 2
22460: LESSEQUAL
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22500
22467: POP
// begin SetTech ( tech_Comp1 , russians , state_researched ) ;
22468: LD_INT 57
22470: PPUSH
22471: LD_EXP 49
22475: PPUSH
22476: LD_INT 2
22478: PPUSH
22479: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
22483: LD_INT 51
22485: PPUSH
22486: LD_EXP 49
22490: PPUSH
22491: LD_INT 2
22493: PPUSH
22494: CALL_OW 322
// end ; d <= 3 :
22498: GO 22548
22500: LD_LOC 2
22504: PUSH
22505: LD_INT 3
22507: LESSEQUAL
22508: DOUBLE
22509: EQUAL
22510: IFTRUE 22514
22512: GO 22547
22514: POP
// begin SetTech ( tech_Comp2 , russians , state_researched ) ;
22515: LD_INT 58
22517: PPUSH
22518: LD_EXP 49
22522: PPUSH
22523: LD_INT 2
22525: PPUSH
22526: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
22530: LD_INT 52
22532: PPUSH
22533: LD_EXP 49
22537: PPUSH
22538: LD_INT 2
22540: PPUSH
22541: CALL_OW 322
// end ; end ;
22545: GO 22548
22547: POP
// end ;
22548: END
// every 31 31$0 do
22549: GO 22551
22551: DISABLE
// begin case difficulty of 1 :
22552: LD_OWVAR 67
22556: PUSH
22557: LD_INT 1
22559: DOUBLE
22560: EQUAL
22561: IFTRUE 22565
22563: GO 22583
22565: POP
// SetTech ( tech_Comp1 , russians , state_researched ) ; 2 :
22566: LD_INT 57
22568: PPUSH
22569: LD_EXP 49
22573: PPUSH
22574: LD_INT 2
22576: PPUSH
22577: CALL_OW 322
22581: GO 22636
22583: LD_INT 2
22585: DOUBLE
22586: EQUAL
22587: IFTRUE 22591
22589: GO 22609
22591: POP
// SetTech ( tech_Comp2 , russians , state_researched ) ; 3 :
22592: LD_INT 58
22594: PPUSH
22595: LD_EXP 49
22599: PPUSH
22600: LD_INT 2
22602: PPUSH
22603: CALL_OW 322
22607: GO 22636
22609: LD_INT 3
22611: DOUBLE
22612: EQUAL
22613: IFTRUE 22617
22615: GO 22635
22617: POP
// SetTech ( tech_Comp3 , russians , state_researched ) ; end ;
22618: LD_INT 59
22620: PPUSH
22621: LD_EXP 49
22625: PPUSH
22626: LD_INT 2
22628: PPUSH
22629: CALL_OW 322
22633: GO 22636
22635: POP
// end ;
22636: END
// every 47 47$0 do
22637: GO 22639
22639: DISABLE
// begin case difficulty of 1 :
22640: LD_OWVAR 67
22644: PUSH
22645: LD_INT 1
22647: DOUBLE
22648: EQUAL
22649: IFTRUE 22653
22651: GO 22671
22653: POP
// SetTech ( tech_Weap1 , russians , state_researched ) ; 2 :
22654: LD_INT 51
22656: PPUSH
22657: LD_EXP 49
22661: PPUSH
22662: LD_INT 2
22664: PPUSH
22665: CALL_OW 322
22669: GO 22724
22671: LD_INT 2
22673: DOUBLE
22674: EQUAL
22675: IFTRUE 22679
22677: GO 22697
22679: POP
// SetTech ( tech_Weap2 , russians , state_researched ) ; 3 :
22680: LD_INT 52
22682: PPUSH
22683: LD_EXP 49
22687: PPUSH
22688: LD_INT 2
22690: PPUSH
22691: CALL_OW 322
22695: GO 22724
22697: LD_INT 3
22699: DOUBLE
22700: EQUAL
22701: IFTRUE 22705
22703: GO 22723
22705: POP
// SetTech ( tech_Weap3 , russians , state_researched ) ; end ;
22706: LD_INT 53
22708: PPUSH
22709: LD_EXP 49
22713: PPUSH
22714: LD_INT 2
22716: PPUSH
22717: CALL_OW 322
22721: GO 22724
22723: POP
// end ;
22724: END
// function CreateH ( sol , mec ) ; var units , i ; begin
22725: LD_INT 0
22727: PPUSH
22728: PPUSH
22729: PPUSH
// units := [ ] ;
22730: LD_ADDR_VAR 0 4
22734: PUSH
22735: EMPTY
22736: ST_TO_ADDR
// for i := 1 to sol do
22737: LD_ADDR_VAR 0 5
22741: PUSH
22742: DOUBLE
22743: LD_INT 1
22745: DEC
22746: ST_TO_ADDR
22747: LD_VAR 0 1
22751: PUSH
22752: FOR_TO
22753: IFFALSE 22824
// begin InitUc ;
22755: CALL_OW 18
// InitHc ;
22759: CALL_OW 19
// uc_nation := nation_russian ;
22763: LD_ADDR_OWVAR 21
22767: PUSH
22768: LD_INT 3
22770: ST_TO_ADDR
// uc_side := russians ;
22771: LD_ADDR_OWVAR 20
22775: PUSH
22776: LD_EXP 49
22780: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22781: LD_INT 0
22783: PPUSH
22784: LD_EXP 5
22788: PUSH
22789: LD_LOC 2
22793: ARRAY
22794: PPUSH
22795: CALL_OW 381
// units := units ^ CreateHuman ;
22799: LD_ADDR_VAR 0 4
22803: PUSH
22804: LD_VAR 0 4
22808: PUSH
22809: CALL_OW 44
22813: ADD
22814: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22815: LD_INT 7
22817: PPUSH
22818: CALL_OW 67
// end ;
22822: GO 22752
22824: POP
22825: POP
// for i := 1 to mec do
22826: LD_ADDR_VAR 0 5
22830: PUSH
22831: DOUBLE
22832: LD_INT 1
22834: DEC
22835: ST_TO_ADDR
22836: LD_VAR 0 2
22840: PUSH
22841: FOR_TO
22842: IFFALSE 22913
// begin InitUc ;
22844: CALL_OW 18
// InitHc ;
22848: CALL_OW 19
// uc_nation := nation_russian ;
22852: LD_ADDR_OWVAR 21
22856: PUSH
22857: LD_INT 3
22859: ST_TO_ADDR
// uc_side := russians ;
22860: LD_ADDR_OWVAR 20
22864: PUSH
22865: LD_EXP 49
22869: ST_TO_ADDR
// PrepareMechanic ( 0 , lev [ d ] ) ;
22870: LD_INT 0
22872: PPUSH
22873: LD_EXP 5
22877: PUSH
22878: LD_LOC 2
22882: ARRAY
22883: PPUSH
22884: CALL_OW 383
// units := units ^ CreateHuman ;
22888: LD_ADDR_VAR 0 4
22892: PUSH
22893: LD_VAR 0 4
22897: PUSH
22898: CALL_OW 44
22902: ADD
22903: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22904: LD_INT 7
22906: PPUSH
22907: CALL_OW 67
// end ;
22911: GO 22841
22913: POP
22914: POP
// result := units ;
22915: LD_ADDR_VAR 0 3
22919: PUSH
22920: LD_VAR 0 4
22924: ST_TO_ADDR
// end ;
22925: LD_VAR 0 3
22929: RET
// function CreateB ( num ) ; var units , i ; begin
22930: LD_INT 0
22932: PPUSH
22933: PPUSH
22934: PPUSH
// units := [ ] ;
22935: LD_ADDR_VAR 0 3
22939: PUSH
22940: EMPTY
22941: ST_TO_ADDR
// for i := 1 to num do
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: DOUBLE
22948: LD_INT 1
22950: DEC
22951: ST_TO_ADDR
22952: LD_VAR 0 1
22956: PUSH
22957: FOR_TO
22958: IFFALSE 23037
// begin InitUc ;
22960: CALL_OW 18
// InitHc ;
22964: CALL_OW 19
// uc_nation := nation_russian ;
22968: LD_ADDR_OWVAR 21
22972: PUSH
22973: LD_INT 3
22975: ST_TO_ADDR
// uc_side := russians ;
22976: LD_ADDR_OWVAR 20
22980: PUSH
22981: LD_EXP 49
22985: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22986: LD_INT 0
22988: PPUSH
22989: LD_EXP 5
22993: PUSH
22994: LD_LOC 2
22998: ARRAY
22999: PPUSH
23000: CALL_OW 381
// hc_class := class_bazooker ;
23004: LD_ADDR_OWVAR 28
23008: PUSH
23009: LD_INT 9
23011: ST_TO_ADDR
// units := units ^ CreateHuman ;
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_VAR 0 3
23021: PUSH
23022: CALL_OW 44
23026: ADD
23027: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23028: LD_INT 7
23030: PPUSH
23031: CALL_OW 67
// end ;
23035: GO 22957
23037: POP
23038: POP
// result := units ;
23039: LD_ADDR_VAR 0 2
23043: PUSH
23044: LD_VAR 0 3
23048: ST_TO_ADDR
// end ;
23049: LD_VAR 0 2
23053: RET
// function CreateS ( num ) ; var units , i ; begin
23054: LD_INT 0
23056: PPUSH
23057: PPUSH
23058: PPUSH
// units := [ ] ;
23059: LD_ADDR_VAR 0 3
23063: PUSH
23064: EMPTY
23065: ST_TO_ADDR
// for i := 1 to num do
23066: LD_ADDR_VAR 0 4
23070: PUSH
23071: DOUBLE
23072: LD_INT 1
23074: DEC
23075: ST_TO_ADDR
23076: LD_VAR 0 1
23080: PUSH
23081: FOR_TO
23082: IFFALSE 23161
// begin InitUc ;
23084: CALL_OW 18
// InitHc ;
23088: CALL_OW 19
// uc_nation := nation_russian ;
23092: LD_ADDR_OWVAR 21
23096: PUSH
23097: LD_INT 3
23099: ST_TO_ADDR
// uc_side := russians ;
23100: LD_ADDR_OWVAR 20
23104: PUSH
23105: LD_EXP 49
23109: ST_TO_ADDR
// hc_class := class_soldier ;
23110: LD_ADDR_OWVAR 28
23114: PUSH
23115: LD_INT 1
23117: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
23118: LD_INT 0
23120: PPUSH
23121: LD_EXP 5
23125: PUSH
23126: LD_LOC 2
23130: ARRAY
23131: PPUSH
23132: CALL_OW 381
// units := units ^ CreateHuman ;
23136: LD_ADDR_VAR 0 3
23140: PUSH
23141: LD_VAR 0 3
23145: PUSH
23146: CALL_OW 44
23150: ADD
23151: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23152: LD_INT 7
23154: PPUSH
23155: CALL_OW 67
// end ;
23159: GO 23081
23161: POP
23162: POP
// result := units ;
23163: LD_ADDR_VAR 0 2
23167: PUSH
23168: LD_VAR 0 3
23172: ST_TO_ADDR
// end ;
23173: LD_VAR 0 2
23177: RET
// function CreateVH ( list ) ; var units , i ; begin
23178: LD_INT 0
23180: PPUSH
23181: PPUSH
23182: PPUSH
// for i in list do
23183: LD_ADDR_VAR 0 4
23187: PUSH
23188: LD_VAR 0 1
23192: PUSH
23193: FOR_IN
23194: IFFALSE 23487
// begin InitUc ;
23196: CALL_OW 18
// InitVc ;
23200: CALL_OW 20
// uc_nation := nation_russian ;
23204: LD_ADDR_OWVAR 21
23208: PUSH
23209: LD_INT 3
23211: ST_TO_ADDR
// uc_side := russians ;
23212: LD_ADDR_OWVAR 20
23216: PUSH
23217: LD_EXP 49
23221: ST_TO_ADDR
// units := [ ] ;
23222: LD_ADDR_VAR 0 3
23226: PUSH
23227: EMPTY
23228: ST_TO_ADDR
// vc_control := control_manual ;
23229: LD_ADDR_OWVAR 38
23233: PUSH
23234: LD_INT 1
23236: ST_TO_ADDR
// vc_engine := engine_combustion ;
23237: LD_ADDR_OWVAR 39
23241: PUSH
23242: LD_INT 1
23244: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23245: LD_ADDR_OWVAR 41
23249: PUSH
23250: LD_INT 75
23252: ST_TO_ADDR
// case i of mhmg :
23253: LD_VAR 0 4
23257: PUSH
23258: LD_EXP 9
23262: DOUBLE
23263: EQUAL
23264: IFTRUE 23268
23266: GO 23287
23268: POP
// begin vc_chassis := ru_medium_tracked ;
23269: LD_ADDR_OWVAR 37
23273: PUSH
23274: LD_INT 22
23276: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23277: LD_ADDR_OWVAR 40
23281: PUSH
23282: LD_INT 42
23284: ST_TO_ADDR
// end ; mgg :
23285: GO 23462
23287: LD_EXP 10
23291: DOUBLE
23292: EQUAL
23293: IFTRUE 23297
23295: GO 23316
23297: POP
// begin vc_chassis := ru_medium_tracked ;
23298: LD_ADDR_OWVAR 37
23302: PUSH
23303: LD_INT 22
23305: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23306: LD_ADDR_OWVAR 40
23310: PUSH
23311: LD_INT 43
23313: ST_TO_ADDR
// end ; mg :
23314: GO 23462
23316: LD_EXP 11
23320: DOUBLE
23321: EQUAL
23322: IFTRUE 23326
23324: GO 23345
23326: POP
// begin vc_chassis := ru_medium_tracked ;
23327: LD_ADDR_OWVAR 37
23331: PUSH
23332: LD_INT 22
23334: ST_TO_ADDR
// vc_weapon := ru_gun ;
23335: LD_ADDR_OWVAR 40
23339: PUSH
23340: LD_INT 44
23342: ST_TO_ADDR
// end ; mrl :
23343: GO 23462
23345: LD_EXP 12
23349: DOUBLE
23350: EQUAL
23351: IFTRUE 23355
23353: GO 23374
23355: POP
// begin vc_chassis := ru_medium_tracked ;
23356: LD_ADDR_OWVAR 37
23360: PUSH
23361: LD_INT 22
23363: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23364: LD_ADDR_OWVAR 40
23368: PUSH
23369: LD_INT 45
23371: ST_TO_ADDR
// end ; hgg :
23372: GO 23462
23374: LD_EXP 13
23378: DOUBLE
23379: EQUAL
23380: IFTRUE 23384
23382: GO 23403
23384: POP
// begin vc_chassis := ru_heavy_tracked ;
23385: LD_ADDR_OWVAR 37
23389: PUSH
23390: LD_INT 24
23392: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23393: LD_ADDR_OWVAR 40
23397: PUSH
23398: LD_INT 43
23400: ST_TO_ADDR
// end ; hrl :
23401: GO 23462
23403: LD_EXP 14
23407: DOUBLE
23408: EQUAL
23409: IFTRUE 23413
23411: GO 23432
23413: POP
// begin vc_chassis := ru_heavy_tracked ;
23414: LD_ADDR_OWVAR 37
23418: PUSH
23419: LD_INT 24
23421: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23422: LD_ADDR_OWVAR 40
23426: PUSH
23427: LD_INT 45
23429: ST_TO_ADDR
// end ; hhg :
23430: GO 23462
23432: LD_EXP 15
23436: DOUBLE
23437: EQUAL
23438: IFTRUE 23442
23440: GO 23461
23442: POP
// begin vc_chassis := ru_heavy_tracked ;
23443: LD_ADDR_OWVAR 37
23447: PUSH
23448: LD_INT 24
23450: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23451: LD_ADDR_OWVAR 40
23455: PUSH
23456: LD_INT 46
23458: ST_TO_ADDR
// end ; end ;
23459: GO 23462
23461: POP
// units := units ^ CreateVehicle ;
23462: LD_ADDR_VAR 0 3
23466: PUSH
23467: LD_VAR 0 3
23471: PUSH
23472: CALL_OW 45
23476: ADD
23477: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23478: LD_INT 7
23480: PPUSH
23481: CALL_OW 67
// end ;
23485: GO 23193
23487: POP
23488: POP
// result := units ;
23489: LD_ADDR_VAR 0 2
23493: PUSH
23494: LD_VAR 0 3
23498: ST_TO_ADDR
// end ;
23499: LD_VAR 0 2
23503: RET
// function CreateVC ( list ) ; var units , i ; begin
23504: LD_INT 0
23506: PPUSH
23507: PPUSH
23508: PPUSH
// units := [ ] ;
23509: LD_ADDR_VAR 0 3
23513: PUSH
23514: EMPTY
23515: ST_TO_ADDR
// for i in list do
23516: LD_ADDR_VAR 0 4
23520: PUSH
23521: LD_VAR 0 1
23525: PUSH
23526: FOR_IN
23527: IFFALSE 23817
// begin InitUc ;
23529: CALL_OW 18
// InitHc ;
23533: CALL_OW 19
// InitVc ;
23537: CALL_OW 20
// uc_nation := nation_russian ;
23541: LD_ADDR_OWVAR 21
23545: PUSH
23546: LD_INT 3
23548: ST_TO_ADDR
// uc_side := russians ;
23549: LD_ADDR_OWVAR 20
23553: PUSH
23554: LD_EXP 49
23558: ST_TO_ADDR
// vc_control := control_computer ;
23559: LD_ADDR_OWVAR 38
23563: PUSH
23564: LD_INT 3
23566: ST_TO_ADDR
// vc_engine := engine_combustion ;
23567: LD_ADDR_OWVAR 39
23571: PUSH
23572: LD_INT 1
23574: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23575: LD_ADDR_OWVAR 41
23579: PUSH
23580: LD_INT 75
23582: ST_TO_ADDR
// case i of mhmg :
23583: LD_VAR 0 4
23587: PUSH
23588: LD_EXP 9
23592: DOUBLE
23593: EQUAL
23594: IFTRUE 23598
23596: GO 23617
23598: POP
// begin vc_chassis := ru_medium_tracked ;
23599: LD_ADDR_OWVAR 37
23603: PUSH
23604: LD_INT 22
23606: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23607: LD_ADDR_OWVAR 40
23611: PUSH
23612: LD_INT 42
23614: ST_TO_ADDR
// end ; mgg :
23615: GO 23792
23617: LD_EXP 10
23621: DOUBLE
23622: EQUAL
23623: IFTRUE 23627
23625: GO 23646
23627: POP
// begin vc_chassis := ru_medium_tracked ;
23628: LD_ADDR_OWVAR 37
23632: PUSH
23633: LD_INT 22
23635: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23636: LD_ADDR_OWVAR 40
23640: PUSH
23641: LD_INT 43
23643: ST_TO_ADDR
// end ; mg :
23644: GO 23792
23646: LD_EXP 11
23650: DOUBLE
23651: EQUAL
23652: IFTRUE 23656
23654: GO 23675
23656: POP
// begin vc_chassis := ru_medium_tracked ;
23657: LD_ADDR_OWVAR 37
23661: PUSH
23662: LD_INT 22
23664: ST_TO_ADDR
// vc_weapon := ru_gun ;
23665: LD_ADDR_OWVAR 40
23669: PUSH
23670: LD_INT 44
23672: ST_TO_ADDR
// end ; mrl :
23673: GO 23792
23675: LD_EXP 12
23679: DOUBLE
23680: EQUAL
23681: IFTRUE 23685
23683: GO 23704
23685: POP
// begin vc_chassis := ru_medium_tracked ;
23686: LD_ADDR_OWVAR 37
23690: PUSH
23691: LD_INT 22
23693: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23694: LD_ADDR_OWVAR 40
23698: PUSH
23699: LD_INT 45
23701: ST_TO_ADDR
// end ; hgg :
23702: GO 23792
23704: LD_EXP 13
23708: DOUBLE
23709: EQUAL
23710: IFTRUE 23714
23712: GO 23733
23714: POP
// begin vc_chassis := ru_heavy_tracked ;
23715: LD_ADDR_OWVAR 37
23719: PUSH
23720: LD_INT 24
23722: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23723: LD_ADDR_OWVAR 40
23727: PUSH
23728: LD_INT 43
23730: ST_TO_ADDR
// end ; hrl :
23731: GO 23792
23733: LD_EXP 14
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23762
23743: POP
// begin vc_chassis := ru_heavy_tracked ;
23744: LD_ADDR_OWVAR 37
23748: PUSH
23749: LD_INT 24
23751: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23752: LD_ADDR_OWVAR 40
23756: PUSH
23757: LD_INT 45
23759: ST_TO_ADDR
// end ; hhg :
23760: GO 23792
23762: LD_EXP 15
23766: DOUBLE
23767: EQUAL
23768: IFTRUE 23772
23770: GO 23791
23772: POP
// begin vc_chassis := ru_heavy_tracked ;
23773: LD_ADDR_OWVAR 37
23777: PUSH
23778: LD_INT 24
23780: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23781: LD_ADDR_OWVAR 40
23785: PUSH
23786: LD_INT 46
23788: ST_TO_ADDR
// end ; end ;
23789: GO 23792
23791: POP
// units := units ^ CreateVehicle ;
23792: LD_ADDR_VAR 0 3
23796: PUSH
23797: LD_VAR 0 3
23801: PUSH
23802: CALL_OW 45
23806: ADD
23807: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23808: LD_INT 7
23810: PPUSH
23811: CALL_OW 67
// end ;
23815: GO 23526
23817: POP
23818: POP
// result := units ;
23819: LD_ADDR_VAR 0 2
23823: PUSH
23824: LD_VAR 0 3
23828: ST_TO_ADDR
// end ;
23829: LD_VAR 0 2
23833: RET
// function MyPlaceUnitArea ( un , ar , bordr ) ; var h , r ; begin
23834: LD_INT 0
23836: PPUSH
23837: PPUSH
23838: PPUSH
// case ar of rus_mat_l :
23839: LD_VAR 0 2
23843: PUSH
23844: LD_INT 3
23846: DOUBLE
23847: EQUAL
23848: IFTRUE 23852
23850: GO 23870
23852: POP
// h := [ 61 , 119 ] ; rus_mat_m :
23853: LD_ADDR_VAR 0 5
23857: PUSH
23858: LD_INT 61
23860: PUSH
23861: LD_INT 119
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: ST_TO_ADDR
23868: GO 23949
23870: LD_INT 2
23872: DOUBLE
23873: EQUAL
23874: IFTRUE 23878
23876: GO 23896
23878: POP
// h := [ 99 , 148 ] ; rus_mat_r :
23879: LD_ADDR_VAR 0 5
23883: PUSH
23884: LD_INT 99
23886: PUSH
23887: LD_INT 148
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: ST_TO_ADDR
23894: GO 23949
23896: LD_INT 15
23898: DOUBLE
23899: EQUAL
23900: IFTRUE 23904
23902: GO 23922
23904: POP
// h := [ 137 , 148 ] ; rus_mat_t :
23905: LD_ADDR_VAR 0 5
23909: PUSH
23910: LD_INT 137
23912: PUSH
23913: LD_INT 148
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: ST_TO_ADDR
23920: GO 23949
23922: LD_INT 14
23924: DOUBLE
23925: EQUAL
23926: IFTRUE 23930
23928: GO 23948
23930: POP
// h := [ 112 , 87 ] ; end ;
23931: LD_ADDR_VAR 0 5
23935: PUSH
23936: LD_INT 112
23938: PUSH
23939: LD_INT 87
23941: PUSH
23942: EMPTY
23943: LIST
23944: LIST
23945: ST_TO_ADDR
23946: GO 23949
23948: POP
// r := PlaceUnitArea ( un , ar , bordr ) ;
23949: LD_ADDR_VAR 0 6
23953: PUSH
23954: LD_VAR 0 1
23958: PPUSH
23959: LD_VAR 0 2
23963: PPUSH
23964: LD_VAR 0 3
23968: PPUSH
23969: CALL_OW 49
23973: ST_TO_ADDR
// if not r then
23974: LD_VAR 0 6
23978: NOT
23979: IFFALSE 24022
// r := PlaceUnitXYR ( un , h [ 1 ] , h [ 2 ] , 20 , bordr ) ;
23981: LD_ADDR_VAR 0 6
23985: PUSH
23986: LD_VAR 0 1
23990: PPUSH
23991: LD_VAR 0 5
23995: PUSH
23996: LD_INT 1
23998: ARRAY
23999: PPUSH
24000: LD_VAR 0 5
24004: PUSH
24005: LD_INT 2
24007: ARRAY
24008: PPUSH
24009: LD_INT 20
24011: PPUSH
24012: LD_VAR 0 3
24016: PPUSH
24017: CALL_OW 50
24021: ST_TO_ADDR
// result := r ;
24022: LD_ADDR_VAR 0 4
24026: PUSH
24027: LD_VAR 0 6
24031: ST_TO_ADDR
// end ; end_of_file
24032: LD_VAR 0 4
24036: RET
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = russians then
24037: LD_VAR 0 1
24041: PPUSH
24042: CALL_OW 255
24046: PUSH
24047: LD_EXP 49
24051: EQUAL
24052: IFFALSE 24066
// ComMoveToArea ( un , before_base ) ;
24054: LD_VAR 0 1
24058: PPUSH
24059: LD_INT 23
24061: PPUSH
24062: CALL_OW 113
// end ;
24066: PPOPN 1
24068: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = russians and GetType ( un ) = unit_human then
24069: LD_VAR 0 1
24073: PPUSH
24074: CALL_OW 255
24078: PUSH
24079: LD_EXP 49
24083: EQUAL
24084: PUSH
24085: LD_VAR 0 1
24089: PPUSH
24090: CALL_OW 247
24094: PUSH
24095: LD_INT 1
24097: EQUAL
24098: AND
24099: IFFALSE 24113
// begin ComMoveToArea ( un , border ) ;
24101: LD_VAR 0 1
24105: PPUSH
24106: LD_INT 28
24108: PPUSH
24109: CALL_OW 113
// end ; end ;
24113: PPOPN 1
24115: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin end ;
24116: PPOPN 4
24118: END
// on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) then
24119: LD_VAR 0 1
24123: PPUSH
24124: LD_INT 30
24126: PUSH
24127: LD_INT 4
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PUSH
24134: LD_INT 23
24136: PUSH
24137: LD_INT 2
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PPUSH
24148: CALL_OW 72
24152: IFFALSE 24162
// ArmBuild := true ;
24154: LD_ADDR_EXP 71
24158: PUSH
24159: LD_INT 1
24161: ST_TO_ADDR
// if IsDead ( rudepot1 ) and IsInArea ( build , base ) and GetBType ( build ) = b_depot then
24162: LD_EXP 67
24166: PPUSH
24167: CALL_OW 301
24171: PUSH
24172: LD_VAR 0 1
24176: PPUSH
24177: LD_INT 1
24179: PPUSH
24180: CALL_OW 308
24184: AND
24185: PUSH
24186: LD_VAR 0 1
24190: PPUSH
24191: CALL_OW 266
24195: PUSH
24196: LD_INT 0
24198: EQUAL
24199: AND
24200: IFFALSE 24212
// rudepot1 := build ;
24202: LD_ADDR_EXP 67
24206: PUSH
24207: LD_VAR 0 1
24211: ST_TO_ADDR
// if IsInArea ( build , base ) and GetBType ( build ) = b_siberite_mine then
24212: LD_VAR 0 1
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 308
24224: PUSH
24225: LD_VAR 0 1
24229: PPUSH
24230: CALL_OW 266
24234: PUSH
24235: LD_INT 30
24237: EQUAL
24238: AND
24239: IFFALSE 24251
// rumine1 := build ;
24241: LD_ADDR_EXP 68
24245: PUSH
24246: LD_VAR 0 1
24250: ST_TO_ADDR
// if IsDead ( depot1 ) and IsInArea ( build , top_half ) and GetBType ( build ) = b_depot then
24251: LD_EXP 69
24255: PPUSH
24256: CALL_OW 301
24260: PUSH
24261: LD_VAR 0 1
24265: PPUSH
24266: LD_INT 6
24268: PPUSH
24269: CALL_OW 308
24273: AND
24274: PUSH
24275: LD_VAR 0 1
24279: PPUSH
24280: CALL_OW 266
24284: PUSH
24285: LD_INT 0
24287: EQUAL
24288: AND
24289: IFFALSE 24301
// depot1 := build ;
24291: LD_ADDR_EXP 69
24295: PUSH
24296: LD_VAR 0 1
24300: ST_TO_ADDR
// if GetBType ( build ) = b_workshop then
24301: LD_VAR 0 1
24305: PPUSH
24306: CALL_OW 266
24310: PUSH
24311: LD_INT 2
24313: EQUAL
24314: IFFALSE 24323
// MyHint ( Tracks ) ;
24316: LD_STRING Tracks
24318: PPUSH
24319: CALL 14222 0 1
// end ;
24323: PPOPN 1
24325: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) then
24326: LD_VAR 0 1
24330: PPUSH
24331: LD_INT 30
24333: PUSH
24334: LD_INT 5
24336: PUSH
24337: EMPTY
24338: LIST
24339: LIST
24340: PUSH
24341: LD_INT 23
24343: PUSH
24344: LD_INT 2
24346: PUSH
24347: EMPTY
24348: LIST
24349: LIST
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PPUSH
24355: CALL_OW 72
24359: IFFALSE 24376
// begin ArmUpgraded := true ;
24361: LD_ADDR_EXP 72
24365: PUSH
24366: LD_INT 1
24368: ST_TO_ADDR
// MyHint ( MortarMen ) ;
24369: LD_STRING MortarMen
24371: PPUSH
24372: CALL 14222 0 1
// end ; end ;
24376: PPOPN 1
24378: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibDet then
24379: LD_VAR 0 1
24383: PUSH
24384: LD_INT 20
24386: EQUAL
24387: IFFALSE 24460
// begin if SayAny ( all_units , D13-Sci1-1 , you , 0 , class_scientistic , 0 ) then
24389: LD_OWVAR 3
24393: PPUSH
24394: LD_STRING D13-Sci1-1
24396: PPUSH
24397: LD_EXP 47
24401: PPUSH
24402: LD_INT 0
24404: PPUSH
24405: LD_INT 4
24407: PPUSH
24408: LD_INT 0
24410: PPUSH
24411: CALL 13071 0 6
24415: IFFALSE 24457
// if Say ( JMM , D13-JMM-1 ) then
24417: LD_EXP 17
24421: PPUSH
24422: LD_STRING D13-JMM-1
24424: PPUSH
24425: CALL_OW 88
24429: IFFALSE 24457
// SayAny ( all_units , D13-Sci1-2 , you , 0 , class_scientistic , 0 ) ;
24431: LD_OWVAR 3
24435: PPUSH
24436: LD_STRING D13-Sci1-2
24438: PPUSH
24439: LD_EXP 47
24443: PPUSH
24444: LD_INT 0
24446: PPUSH
24447: LD_INT 4
24449: PPUSH
24450: LD_INT 0
24452: PPUSH
24453: CALL 13071 0 6
// disable ( 20 ) ;
24457: LD_INT 20
24459: DISABLE_MARKED
// end ; end ;
24460: PPOPN 2
24462: END
// on BuildingCaptured ( build , origside , eng ) do begin if not byld2a and origside = you2 then
24463: LD_EXP 73
24467: NOT
24468: PUSH
24469: LD_VAR 0 2
24473: PUSH
24474: LD_EXP 48
24478: EQUAL
24479: AND
24480: IFFALSE 24486
// dialog2a ;
24482: CALL 3411 0 0
// if EndEnable and ( build = rudepot1 ) and origside = you then
24486: LD_EXP 80
24490: PUSH
24491: LD_VAR 0 1
24495: PUSH
24496: LD_EXP 67
24500: EQUAL
24501: AND
24502: PUSH
24503: LD_VAR 0 2
24507: PUSH
24508: LD_EXP 47
24512: EQUAL
24513: AND
24514: IFFALSE 24558
// begin TimerEnable := true ;
24516: LD_ADDR_EXP 63
24520: PUSH
24521: LD_INT 1
24523: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
24524: LD_ADDR_EXP 81
24528: PUSH
24529: LD_EXP 49
24533: PPUSH
24534: CALL_OW 462
24538: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
24539: LD_EXP 67
24543: PPUSH
24544: CALL_OW 274
24548: PPUSH
24549: LD_EXP 49
24553: PPUSH
24554: CALL_OW 236
// end ; end ;
24558: PPOPN 3
24560: END
// on UnitDestroyed ( un ) do begin if un = JMM then
24561: LD_VAR 0 1
24565: PUSH
24566: LD_EXP 17
24570: EQUAL
24571: IFFALSE 24583
// begin disable ( 0 ) ;
24573: LD_INT 0
24575: DISABLE_MARKED
// YouLost ( JMM ) ;
24576: LD_STRING JMM
24578: PPUSH
24579: CALL_OW 104
// end ; end ;
24583: PPOPN 1
24585: END
// on SailEvent ( num ) do begin if ( num div 1000 ) = 1 then
24586: LD_VAR 0 1
24590: PUSH
24591: LD_INT 1000
24593: DIV
24594: PUSH
24595: LD_INT 1
24597: EQUAL
24598: IFFALSE 24613
// rep_car ( num - 1000 ) ;
24600: LD_VAR 0 1
24604: PUSH
24605: LD_INT 1000
24607: MINUS
24608: PPUSH
24609: CALL 14433 0 1
// if ( num div 1000 ) = 2 then
24613: LD_VAR 0 1
24617: PUSH
24618: LD_INT 1000
24620: DIV
24621: PUSH
24622: LD_INT 2
24624: EQUAL
24625: IFFALSE 24640
// ret_car ( num - 2000 ) ;
24627: LD_VAR 0 1
24631: PUSH
24632: LD_INT 2000
24634: MINUS
24635: PPUSH
24636: CALL 14612 0 1
// case num of 1 :
24640: LD_VAR 0 1
24644: PUSH
24645: LD_INT 1
24647: DOUBLE
24648: EQUAL
24649: IFTRUE 24653
24651: GO 24686
24653: POP
// begin using1 := true ;
24654: LD_ADDR_EXP 83
24658: PUSH
24659: LD_INT 1
24661: ST_TO_ADDR
// Attack ( kdo1 , path1 ) ;
24662: LD_EXP 91
24666: PPUSH
24667: LD_EXP 87
24671: PPUSH
24672: CALL 13552 0 2
// using1 := false ;
24676: LD_ADDR_EXP 83
24680: PUSH
24681: LD_INT 0
24683: ST_TO_ADDR
// end ; 2 :
24684: GO 24981
24686: LD_INT 2
24688: DOUBLE
24689: EQUAL
24690: IFTRUE 24694
24692: GO 24727
24694: POP
// begin using2 := true ;
24695: LD_ADDR_EXP 84
24699: PUSH
24700: LD_INT 1
24702: ST_TO_ADDR
// Attack ( kdo2 , path2 ) ;
24703: LD_EXP 92
24707: PPUSH
24708: LD_EXP 88
24712: PPUSH
24713: CALL 13552 0 2
// using2 := false ;
24717: LD_ADDR_EXP 84
24721: PUSH
24722: LD_INT 0
24724: ST_TO_ADDR
// end ; 3 :
24725: GO 24981
24727: LD_INT 3
24729: DOUBLE
24730: EQUAL
24731: IFTRUE 24735
24733: GO 24768
24735: POP
// begin using3 := true ;
24736: LD_ADDR_EXP 85
24740: PUSH
24741: LD_INT 1
24743: ST_TO_ADDR
// Attack ( kdo3 , path3 ) ;
24744: LD_EXP 93
24748: PPUSH
24749: LD_EXP 89
24753: PPUSH
24754: CALL 13552 0 2
// using3 := false ;
24758: LD_ADDR_EXP 85
24762: PUSH
24763: LD_INT 0
24765: ST_TO_ADDR
// end ; 4 :
24766: GO 24981
24768: LD_INT 4
24770: DOUBLE
24771: EQUAL
24772: IFTRUE 24776
24774: GO 24809
24776: POP
// begin using4 := true ;
24777: LD_ADDR_EXP 94
24781: PUSH
24782: LD_INT 1
24784: ST_TO_ADDR
// Attack ( kdo4 , path4 ) ;
24785: LD_EXP 102
24789: PPUSH
24790: LD_EXP 98
24794: PPUSH
24795: CALL 13552 0 2
// using4 := false ;
24799: LD_ADDR_EXP 94
24803: PUSH
24804: LD_INT 0
24806: ST_TO_ADDR
// end ; 5 :
24807: GO 24981
24809: LD_INT 5
24811: DOUBLE
24812: EQUAL
24813: IFTRUE 24817
24815: GO 24850
24817: POP
// begin using5 := true ;
24818: LD_ADDR_EXP 95
24822: PUSH
24823: LD_INT 1
24825: ST_TO_ADDR
// Attack ( kdo5 , path5 ) ;
24826: LD_EXP 103
24830: PPUSH
24831: LD_EXP 99
24835: PPUSH
24836: CALL 13552 0 2
// using5 := false ;
24840: LD_ADDR_EXP 95
24844: PUSH
24845: LD_INT 0
24847: ST_TO_ADDR
// end ; 6 :
24848: GO 24981
24850: LD_INT 6
24852: DOUBLE
24853: EQUAL
24854: IFTRUE 24858
24856: GO 24891
24858: POP
// begin using6 := true ;
24859: LD_ADDR_EXP 96
24863: PUSH
24864: LD_INT 1
24866: ST_TO_ADDR
// Attack ( kdo6 , path6 ) ;
24867: LD_EXP 104
24871: PPUSH
24872: LD_EXP 100
24876: PPUSH
24877: CALL 13552 0 2
// using6 := false ;
24881: LD_ADDR_EXP 96
24885: PUSH
24886: LD_INT 0
24888: ST_TO_ADDR
// end ; 7 :
24889: GO 24981
24891: LD_INT 7
24893: DOUBLE
24894: EQUAL
24895: IFTRUE 24899
24897: GO 24932
24899: POP
// begin using7 := true ;
24900: LD_ADDR_EXP 97
24904: PUSH
24905: LD_INT 1
24907: ST_TO_ADDR
// Attack ( kdo7 , path7 ) ;
24908: LD_EXP 105
24912: PPUSH
24913: LD_EXP 101
24917: PPUSH
24918: CALL 13552 0 2
// using7 := false ;
24922: LD_ADDR_EXP 97
24926: PUSH
24927: LD_INT 0
24929: ST_TO_ADDR
// end ; 8 :
24930: GO 24981
24932: LD_INT 8
24934: DOUBLE
24935: EQUAL
24936: IFTRUE 24940
24938: GO 24973
24940: POP
// begin using8 := true ;
24941: LD_ADDR_EXP 82
24945: PUSH
24946: LD_INT 1
24948: ST_TO_ADDR
// Attack ( kdo8 , path8 ) ;
24949: LD_EXP 90
24953: PPUSH
24954: LD_EXP 86
24958: PPUSH
24959: CALL 13552 0 2
// using8 := false ;
24963: LD_ADDR_EXP 82
24967: PUSH
24968: LD_INT 0
24970: ST_TO_ADDR
// end ; else
24971: GO 24981
24973: POP
// Msg ( neni thread na utok ) ; end ;
24974: LD_STRING neni thread na utok
24976: PPUSH
24977: CALL_OW 100
// end ;
24981: PPOPN 1
24983: END
// on BuildingStarted ( b , hum ) do begin if hum = ara2 then
24984: LD_VAR 0 2
24988: PUSH
24989: LD_EXP 40
24993: EQUAL
24994: IFFALSE 25019
// if GetBType ( b ) = b_armoury then
24996: LD_VAR 0 1
25000: PPUSH
25001: CALL_OW 266
25005: PUSH
25006: LD_INT 4
25008: EQUAL
25009: IFFALSE 25019
// ArmStarted := true ;
25011: LD_ADDR_EXP 74
25015: PUSH
25016: LD_INT 1
25018: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
25019: LD_VAR 0 1
25023: PPUSH
25024: CALL_OW 266
25028: PUSH
25029: LD_INT 4
25031: EQUAL
25032: IFFALSE 25042
// BarStarted := true ;
25034: LD_ADDR_EXP 75
25038: PUSH
25039: LD_INT 1
25041: ST_TO_ADDR
// end ;
25042: PPOPN 2
25044: END
// on EndTheMissionRaised ( a ) do begin Vyhra ;
25045: CALL 2796 0 0
// end ; end_of_file
25049: PPOPN 1
25051: END
// var objevovani_zasilek ; every 0 0$0.1 do
25052: GO 25054
25054: DISABLE
// begin objevovani_zasilek := [ 1 , 0 , 2 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] ;
25055: LD_ADDR_LOC 3
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: LD_INT 0
25065: PUSH
25066: LD_INT 2
25068: PUSH
25069: LD_INT 0
25071: PUSH
25072: LD_INT 1
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: LD_INT 0
25080: PUSH
25081: LD_INT 1
25083: PUSH
25084: LD_INT 0
25086: PUSH
25087: LD_INT 0
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: LIST
25094: LIST
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: ST_TO_ADDR
// Randomize ;
25102: CALL_OW 10
// end ;
25106: END
// every 0 0$10 do
25107: GO 25109
25109: DISABLE
// begin Randomize ;
25110: CALL_OW 10
// enable ;
25114: ENABLE
// end ;
25115: END
// every 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25116: GO 25118
25118: DISABLE
25119: LD_INT 0
25121: PPUSH
25122: PPUSH
25123: PPUSH
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
// begin min5 := 1 ;
25129: LD_ADDR_VAR 0 8
25133: PUSH
25134: LD_INT 1
25136: ST_TO_ADDR
// cek := [ ] ;
25137: LD_ADDR_VAR 0 5
25141: PUSH
25142: EMPTY
25143: ST_TO_ADDR
// cek2 := [ ] ;
25144: LD_ADDR_VAR 0 6
25148: PUSH
25149: EMPTY
25150: ST_TO_ADDR
// last := 0 ;
25151: LD_ADDR_VAR 0 7
25155: PUSH
25156: LD_INT 0
25158: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25159: LD_ADDR_VAR 0 1
25163: PUSH
25164: LD_LOC 3
25168: PUSH
25169: LD_VAR 0 8
25173: ARRAY
25174: ST_TO_ADDR
// for i := 1 to x do
25175: LD_ADDR_VAR 0 3
25179: PUSH
25180: DOUBLE
25181: LD_INT 1
25183: DEC
25184: ST_TO_ADDR
25185: LD_VAR 0 1
25189: PUSH
25190: FOR_TO
25191: IFFALSE 25217
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25193: LD_ADDR_VAR 0 5
25197: PUSH
25198: LD_VAR 0 5
25202: PUSH
25203: LD_INT 525
25205: PPUSH
25206: LD_INT 10500
25208: PPUSH
25209: CALL_OW 12
25213: ADD
25214: ST_TO_ADDR
25215: GO 25190
25217: POP
25218: POP
// cek := SortListByListAsc ( cek , cek ) ;
25219: LD_ADDR_VAR 0 5
25223: PUSH
25224: LD_VAR 0 5
25228: PPUSH
25229: LD_VAR 0 5
25233: PPUSH
25234: CALL_OW 76
25238: ST_TO_ADDR
// for i in cek do
25239: LD_ADDR_VAR 0 3
25243: PUSH
25244: LD_VAR 0 5
25248: PUSH
25249: FOR_IN
25250: IFFALSE 25286
// begin cek2 := cek2 ^ i - last ;
25252: LD_ADDR_VAR 0 6
25256: PUSH
25257: LD_VAR 0 6
25261: PUSH
25262: LD_VAR 0 3
25266: PUSH
25267: LD_VAR 0 7
25271: MINUS
25272: ADD
25273: ST_TO_ADDR
// last := i ;
25274: LD_ADDR_VAR 0 7
25278: PUSH
25279: LD_VAR 0 3
25283: ST_TO_ADDR
// end ;
25284: GO 25249
25286: POP
25287: POP
// for i := 1 to x do
25288: LD_ADDR_VAR 0 3
25292: PUSH
25293: DOUBLE
25294: LD_INT 1
25296: DEC
25297: ST_TO_ADDR
25298: LD_VAR 0 1
25302: PUSH
25303: FOR_TO
25304: IFFALSE 25333
// begin CreateCratesAnywhere ( 5 , true ) ;
25306: LD_INT 5
25308: PPUSH
25309: LD_INT 1
25311: PPUSH
25312: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25316: LD_VAR 0 6
25320: PUSH
25321: LD_VAR 0 3
25325: ARRAY
25326: PPUSH
25327: CALL_OW 67
// end ;
25331: GO 25303
25333: POP
25334: POP
// end ;
25335: PPOPN 8
25337: END
// every 5 5$0 + 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25338: GO 25340
25340: DISABLE
25341: LD_INT 0
25343: PPUSH
25344: PPUSH
25345: PPUSH
25346: PPUSH
25347: PPUSH
25348: PPUSH
25349: PPUSH
25350: PPUSH
// begin min5 := tick div 5 5$0 ;
25351: LD_ADDR_VAR 0 8
25355: PUSH
25356: LD_OWVAR 1
25360: PUSH
25361: LD_INT 10500
25363: DIV
25364: ST_TO_ADDR
// cek := [ ] ;
25365: LD_ADDR_VAR 0 5
25369: PUSH
25370: EMPTY
25371: ST_TO_ADDR
// cek2 := [ ] ;
25372: LD_ADDR_VAR 0 6
25376: PUSH
25377: EMPTY
25378: ST_TO_ADDR
// last := 0 ;
25379: LD_ADDR_VAR 0 7
25383: PUSH
25384: LD_INT 0
25386: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25387: LD_ADDR_VAR 0 1
25391: PUSH
25392: LD_LOC 3
25396: PUSH
25397: LD_VAR 0 8
25401: ARRAY
25402: ST_TO_ADDR
// for i := 1 to x do
25403: LD_ADDR_VAR 0 3
25407: PUSH
25408: DOUBLE
25409: LD_INT 1
25411: DEC
25412: ST_TO_ADDR
25413: LD_VAR 0 1
25417: PUSH
25418: FOR_TO
25419: IFFALSE 25445
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25421: LD_ADDR_VAR 0 5
25425: PUSH
25426: LD_VAR 0 5
25430: PUSH
25431: LD_INT 525
25433: PPUSH
25434: LD_INT 10500
25436: PPUSH
25437: CALL_OW 12
25441: ADD
25442: ST_TO_ADDR
25443: GO 25418
25445: POP
25446: POP
// cek := SortListByListAsc ( cek , cek ) ;
25447: LD_ADDR_VAR 0 5
25451: PUSH
25452: LD_VAR 0 5
25456: PPUSH
25457: LD_VAR 0 5
25461: PPUSH
25462: CALL_OW 76
25466: ST_TO_ADDR
// for i in cek do
25467: LD_ADDR_VAR 0 3
25471: PUSH
25472: LD_VAR 0 5
25476: PUSH
25477: FOR_IN
25478: IFFALSE 25514
// begin cek2 := cek2 ^ i - last ;
25480: LD_ADDR_VAR 0 6
25484: PUSH
25485: LD_VAR 0 6
25489: PUSH
25490: LD_VAR 0 3
25494: PUSH
25495: LD_VAR 0 7
25499: MINUS
25500: ADD
25501: ST_TO_ADDR
// last := i ;
25502: LD_ADDR_VAR 0 7
25506: PUSH
25507: LD_VAR 0 3
25511: ST_TO_ADDR
// end ;
25512: GO 25477
25514: POP
25515: POP
// for i := 1 to x do
25516: LD_ADDR_VAR 0 3
25520: PUSH
25521: DOUBLE
25522: LD_INT 1
25524: DEC
25525: ST_TO_ADDR
25526: LD_VAR 0 1
25530: PUSH
25531: FOR_TO
25532: IFFALSE 25561
// begin CreateCratesAnywhere ( 5 , true ) ;
25534: LD_INT 5
25536: PPUSH
25537: LD_INT 1
25539: PPUSH
25540: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25544: LD_VAR 0 6
25548: PUSH
25549: LD_VAR 0 3
25553: ARRAY
25554: PPUSH
25555: CALL_OW 67
// end ;
25559: GO 25531
25561: POP
25562: POP
// if min5 < 10 then
25563: LD_VAR 0 8
25567: PUSH
25568: LD_INT 10
25570: LESS
25571: IFFALSE 25574
// enable ;
25573: ENABLE
// end ; end_of_file
25574: PPOPN 8
25576: END
// every 0 0$2 + 0 0$0.1 do
25577: GO 25579
25579: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25580: LD_INT 22
25582: PUSH
25583: LD_INT 1
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 2
25592: PUSH
25593: LD_INT 25
25595: PUSH
25596: LD_INT 12
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 25
25605: PUSH
25606: LD_INT 16
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 25
25615: PUSH
25616: LD_INT 15
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 25
25625: PUSH
25626: LD_INT 17
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: LIST
25637: LIST
25638: LIST
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PPUSH
25644: CALL_OW 69
25648: PUSH
25649: LD_INT 22
25651: PUSH
25652: LD_INT 1
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PUSH
25659: LD_INT 21
25661: PUSH
25662: LD_INT 1
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: LD_INT 3
25671: PUSH
25672: LD_INT 2
25674: PUSH
25675: LD_INT 25
25677: PUSH
25678: LD_INT 12
25680: PUSH
25681: EMPTY
25682: LIST
25683: LIST
25684: PUSH
25685: LD_INT 25
25687: PUSH
25688: LD_INT 16
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: PUSH
25695: LD_INT 25
25697: PUSH
25698: LD_INT 15
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: PUSH
25705: LD_INT 25
25707: PUSH
25708: LD_INT 17
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 69
25735: GREATER
25736: IFFALSE 25747
// begin SetAchievement ( ACH_POTA ) ;
25738: LD_STRING ACH_POTA
25740: PPUSH
25741: CALL_OW 543
// exit ;
25745: GO 25748
// end ; enable ;
25747: ENABLE
// end ;
25748: END

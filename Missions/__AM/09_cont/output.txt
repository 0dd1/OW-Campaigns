// export arabi_time ; export utocit ; export last_attack ; export testing ; export lev ; export rusaci_pred_koncem ; function f_testing ; begin
   0: LD_INT 0
   2: PPUSH
// utocit := true ;
   3: LD_ADDR_EXP 2
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// last_attack := true ;
  11: LD_ADDR_EXP 3
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabi_time := 0 ;
  19: LD_ADDR_EXP 1
  23: PUSH
  24: LD_INT 0
  26: ST_TO_ADDR
// testing := false ;
  27: LD_ADDR_EXP 4
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// timer := 3 3$0 ;
  35: LD_ADDR_EXP 62
  39: PUSH
  40: LD_INT 6300
  42: ST_TO_ADDR
// rusaci_pred_koncem := 0 0$20 ;
  43: LD_ADDR_EXP 6
  47: PUSH
  48: LD_INT 700
  50: ST_TO_ADDR
// if not utocit or not last_attack or arabi_time <> 0 then
  51: LD_EXP 2
  55: NOT
  56: PUSH
  57: LD_EXP 3
  61: NOT
  62: OR
  63: PUSH
  64: LD_EXP 1
  68: PUSH
  69: LD_INT 0
  71: NONEQUAL
  72: OR
  73: IFFALSE 90
// begin Msg ( testing version ) ;
  75: LD_STRING testing version
  77: PPUSH
  78: CALL_OW 100
// testing := true ;
  82: LD_ADDR_EXP 4
  86: PUSH
  87: LD_INT 1
  89: ST_TO_ADDR
// end ; end ;
  90: LD_VAR 0 1
  94: RET
// every 2 2$0 do
  95: GO 97
  97: DISABLE
// begin end ;
  98: END
// export map_size_x , map_size_y ; export mhmg , mgg , mg , mrl , hgg , hrl , hhg ; export Powell , JMM , Bobby , Cyrus , Donaldson , Brown , Gary ; export FSol1 , Sol1 , Sci1 ; export Eng1 , Eng2 , Eng3 , Eng4 , CarE1 ; export Mec1 , Mec2 , Mec3 , Car1 , Car2 , Car3 ; export Aqr1 , Aqr2 ; export Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 , arabi ; export you , you2 , russians , arabians ; export otherG2 , other_survivors ; export SikorskiDiedIn8 ; export ByloSiberitu ; export EndSiberit ; export PoskytnouInformace ; export NastvalPowella ; export lidi , lidi_base , lidi_eng ; export neco_rikaji ; export timer , TimerEnable ; export counter_time ; export dialog2byl ; export KolikMaBytSiberitu ; export rudepot1 , rumine1 , depot1 ; function load_units_2 ; var kolik , m , n , i , all , k , placing , o ; begin
  99: LD_INT 0
 101: PPUSH
 102: PPUSH
 103: PPUSH
 104: PPUSH
 105: PPUSH
 106: PPUSH
 107: PPUSH
 108: PPUSH
 109: PPUSH
// InitUc ;
 110: CALL_OW 18
// InitHc ;
 114: CALL_OW 19
// InitVc ;
 118: CALL_OW 20
// kolik := 0 ;
 122: LD_ADDR_VAR 0 2
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// Donaldson := 0 ;
 130: LD_ADDR_EXP 20
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// Brown := 0 ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// Bobby := 0 ;
 146: LD_ADDR_EXP 18
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// Cyrus := 0 ;
 154: LD_ADDR_EXP 19
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// uc_side := you ;
 162: LD_ADDR_OWVAR 20
 166: PUSH
 167: LD_EXP 47
 171: ST_TO_ADDR
// uc_nation := nation_american ;
 172: LD_ADDR_OWVAR 21
 176: PUSH
 177: LD_INT 1
 179: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 180: LD_ADDR_EXP 17
 184: PUSH
 185: LD_STRING JMM
 187: PPUSH
 188: CALL_OW 34
 192: ST_TO_ADDR
// SetClass ( JMM , class_soldier ) ;
 193: LD_EXP 17
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 336
// Powell := NewCharacter ( Powell ) ;
 205: LD_ADDR_EXP 16
 209: PUSH
 210: LD_STRING Powell
 212: PPUSH
 213: CALL_OW 25
 217: ST_TO_ADDR
// uc_side := you2 ;
 218: LD_ADDR_OWVAR 20
 222: PUSH
 223: LD_EXP 48
 227: ST_TO_ADDR
// uc_nation := nation_american ;
 228: LD_ADDR_OWVAR 21
 232: PUSH
 233: LD_INT 1
 235: ST_TO_ADDR
// all := [ ] ;
 236: LD_ADDR_VAR 0 6
 240: PUSH
 241: EMPTY
 242: ST_TO_ADDR
// Gary := NewCharacter ( Gary ) ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_STRING Gary
 250: PPUSH
 251: CALL_OW 25
 255: ST_TO_ADDR
// all := all ^ [ Gary ] ;
 256: LD_ADDR_VAR 0 6
 260: PUSH
 261: LD_VAR 0 6
 265: PUSH
 266: LD_EXP 22
 270: PUSH
 271: EMPTY
 272: LIST
 273: ADD
 274: ST_TO_ADDR
// Cyrus := 0 ;
 275: LD_ADDR_EXP 19
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 283: LD_STRING Cyrus
 285: PPUSH
 286: CALL_OW 29
 290: IFFALSE 366
// if LoadVariable ( CyrusLoc , 1 ) = 1 then
 292: LD_STRING CyrusLoc
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: CALL_OW 30
 302: PUSH
 303: LD_INT 1
 305: EQUAL
 306: IFFALSE 366
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 308: LD_ADDR_EXP 19
 312: PUSH
 313: LD_STRING Cyrus
 315: PPUSH
 316: CALL_OW 34
 320: ST_TO_ADDR
// SetClass ( Cyrus , class_soldier ) ;
 321: LD_EXP 19
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 336
// all := all ^ [ Cyrus ] ;
 333: LD_ADDR_VAR 0 6
 337: PUSH
 338: LD_VAR 0 6
 342: PUSH
 343: LD_EXP 19
 347: PUSH
 348: EMPTY
 349: LIST
 350: ADD
 351: ST_TO_ADDR
// kolik := kolik + 1 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 1
 364: PLUS
 365: ST_TO_ADDR
// end ; Bobby := 0 ;
 366: LD_ADDR_EXP 18
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 374: LD_STRING Bobby
 376: PPUSH
 377: CALL_OW 29
 381: IFFALSE 457
// if LoadVariable ( BobbyLoc , 1 ) = 1 then
 383: LD_STRING BobbyLoc
 385: PPUSH
 386: LD_INT 1
 388: PPUSH
 389: CALL_OW 30
 393: PUSH
 394: LD_INT 1
 396: EQUAL
 397: IFFALSE 457
// begin Bobby := CreateCharacter ( Bobby ) ;
 399: LD_ADDR_EXP 18
 403: PUSH
 404: LD_STRING Bobby
 406: PPUSH
 407: CALL_OW 34
 411: ST_TO_ADDR
// SetClass ( Bobby , class_soldier ) ;
 412: LD_EXP 18
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL_OW 336
// all := all ^ [ Bobby ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 6
 433: PUSH
 434: LD_EXP 18
 438: PUSH
 439: EMPTY
 440: LIST
 441: ADD
 442: ST_TO_ADDR
// kolik := kolik + 1 ;
 443: LD_ADDR_VAR 0 2
 447: PUSH
 448: LD_VAR 0 2
 452: PUSH
 453: LD_INT 1
 455: PLUS
 456: ST_TO_ADDR
// end ; Donaldson := 0 ;
 457: LD_ADDR_EXP 20
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 465: LD_STRING Donaldson
 467: PPUSH
 468: CALL_OW 29
 472: IFFALSE 536
// if LoadVariable ( DonaldsonLoc , 0 ) = 1 then
 474: LD_STRING DonaldsonLoc
 476: PPUSH
 477: LD_INT 0
 479: PPUSH
 480: CALL_OW 30
 484: PUSH
 485: LD_INT 1
 487: EQUAL
 488: IFFALSE 536
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 490: LD_ADDR_EXP 20
 494: PUSH
 495: LD_STRING Donaldson
 497: PPUSH
 498: CALL_OW 34
 502: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 503: LD_ADDR_VAR 0 6
 507: PUSH
 508: LD_VAR 0 6
 512: PUSH
 513: LD_EXP 20
 517: PUSH
 518: EMPTY
 519: LIST
 520: ADD
 521: ST_TO_ADDR
// kolik := kolik + 1 ;
 522: LD_ADDR_VAR 0 2
 526: PUSH
 527: LD_VAR 0 2
 531: PUSH
 532: LD_INT 1
 534: PLUS
 535: ST_TO_ADDR
// end ; Brown := 0 ;
 536: LD_ADDR_EXP 21
 540: PUSH
 541: LD_INT 0
 543: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 544: LD_STRING Brown
 546: PPUSH
 547: CALL_OW 29
 551: IFFALSE 625
// if kolik < 3 and LoadVariable ( BrownLoc , 0 ) = 1 then
 553: LD_VAR 0 2
 557: PUSH
 558: LD_INT 3
 560: LESS
 561: PUSH
 562: LD_STRING BrownLoc
 564: PPUSH
 565: LD_INT 0
 567: PPUSH
 568: CALL_OW 30
 572: PUSH
 573: LD_INT 1
 575: EQUAL
 576: AND
 577: IFFALSE 625
// begin Brown := CreateCharacter ( Brown ) ;
 579: LD_ADDR_EXP 21
 583: PUSH
 584: LD_STRING Brown
 586: PPUSH
 587: CALL_OW 34
 591: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 592: LD_ADDR_VAR 0 6
 596: PUSH
 597: LD_VAR 0 6
 601: PUSH
 602: LD_EXP 21
 606: PUSH
 607: EMPTY
 608: LIST
 609: ADD
 610: ST_TO_ADDR
// kolik := kolik + 1 ;
 611: LD_ADDR_VAR 0 2
 615: PUSH
 616: LD_VAR 0 2
 620: PUSH
 621: LD_INT 1
 623: PLUS
 624: ST_TO_ADDR
// end ; neco_rikaji := [ JMM , Gary , Cyrus , Bobby ] diff 0 ;
 625: LD_ADDR_EXP 61
 629: PUSH
 630: LD_EXP 17
 634: PUSH
 635: LD_EXP 22
 639: PUSH
 640: LD_EXP 19
 644: PUSH
 645: LD_EXP 18
 649: PUSH
 650: EMPTY
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PUSH
 656: LD_INT 0
 658: DIFF
 659: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 660: LD_STRING other_survivors
 662: PPUSH
 663: CALL_OW 28
 667: IFFALSE 682
// other_survivors := CreateCharacterSet ( other_survivors ) ;
 669: LD_ADDR_EXP 52
 673: PUSH
 674: LD_STRING other_survivors
 676: PPUSH
 677: CALL_OW 31
 681: ST_TO_ADDR
// for i := ( all + 0 ) to 6 do
 682: LD_ADDR_VAR 0 5
 686: PUSH
 687: DOUBLE
 688: LD_VAR 0 6
 692: PUSH
 693: LD_INT 0
 695: PLUS
 696: DEC
 697: ST_TO_ADDR
 698: LD_INT 6
 700: PUSH
 701: FOR_TO
 702: IFFALSE 752
// begin if other_survivors then
 704: LD_EXP 52
 708: IFFALSE 750
// begin all := all ^ other_survivors [ 1 ] ;
 710: LD_ADDR_VAR 0 6
 714: PUSH
 715: LD_VAR 0 6
 719: PUSH
 720: LD_EXP 52
 724: PUSH
 725: LD_INT 1
 727: ARRAY
 728: ADD
 729: ST_TO_ADDR
// other_survivors := other_survivors diff other_survivors [ 1 ] ;
 730: LD_ADDR_EXP 52
 734: PUSH
 735: LD_EXP 52
 739: PUSH
 740: LD_EXP 52
 744: PUSH
 745: LD_INT 1
 747: ARRAY
 748: DIFF
 749: ST_TO_ADDR
// end ; end ;
 750: GO 701
 752: POP
 753: POP
// for i := ( all + 0 ) to 6 do
 754: LD_ADDR_VAR 0 5
 758: PUSH
 759: DOUBLE
 760: LD_VAR 0 6
 764: PUSH
 765: LD_INT 0
 767: PLUS
 768: DEC
 769: ST_TO_ADDR
 770: LD_INT 6
 772: PUSH
 773: FOR_TO
 774: IFFALSE 804
// begin PrepareSoldier ( 0 , 5 ) ;
 776: LD_INT 0
 778: PPUSH
 779: LD_INT 5
 781: PPUSH
 782: CALL_OW 381
// all := all ^ CreateHuman ;
 786: LD_ADDR_VAR 0 6
 790: PUSH
 791: LD_VAR 0 6
 795: PUSH
 796: CALL_OW 44
 800: ADD
 801: ST_TO_ADDR
// end ;
 802: GO 773
 804: POP
 805: POP
// PrepareScientist ( sex_male , 5 ) ;
 806: LD_INT 1
 808: PPUSH
 809: LD_INT 5
 811: PPUSH
 812: CALL_OW 384
// Sci1 := CreateHuman ;
 816: LD_ADDR_EXP 25
 820: PUSH
 821: CALL_OW 44
 825: ST_TO_ADDR
// all := all ^ Sci1 ;
 826: LD_ADDR_VAR 0 6
 830: PUSH
 831: LD_VAR 0 6
 835: PUSH
 836: LD_EXP 25
 840: ADD
 841: ST_TO_ADDR
// placing := [ [ 93 , 87 ] , [ 96 , 95 ] , [ 90 , 94 ] ] ;
 842: LD_ADDR_VAR 0 8
 846: PUSH
 847: LD_INT 93
 849: PUSH
 850: LD_INT 87
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: PUSH
 857: LD_INT 96
 859: PUSH
 860: LD_INT 95
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PUSH
 867: LD_INT 90
 869: PUSH
 870: LD_INT 94
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: ST_TO_ADDR
// for k in all do
 882: LD_ADDR_VAR 0 7
 886: PUSH
 887: LD_VAR 0 6
 891: PUSH
 892: FOR_IN
 893: IFFALSE 996
// begin o := Rand ( 1 , 3 ) ;
 895: LD_ADDR_VAR 0 9
 899: PUSH
 900: LD_INT 1
 902: PPUSH
 903: LD_INT 3
 905: PPUSH
 906: CALL_OW 12
 910: ST_TO_ADDR
// if GetClass ( k ) = classtype_scientist then
 911: LD_VAR 0 7
 915: PPUSH
 916: CALL_OW 257
 920: PUSH
 921: LD_INT 4
 923: EQUAL
 924: IFFALSE 949
// PlaceUnitXYR ( k , 89 , 84 , 3 , false ) else
 926: LD_VAR 0 7
 930: PPUSH
 931: LD_INT 89
 933: PPUSH
 934: LD_INT 84
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 0
 942: PPUSH
 943: CALL_OW 50
 947: GO 994
// PlaceUnitXYR ( k , placing [ o ] [ 1 ] , placing [ o ] [ 2 ] , 5 , false ) ;
 949: LD_VAR 0 7
 953: PPUSH
 954: LD_VAR 0 8
 958: PUSH
 959: LD_VAR 0 9
 963: ARRAY
 964: PUSH
 965: LD_INT 1
 967: ARRAY
 968: PPUSH
 969: LD_VAR 0 8
 973: PUSH
 974: LD_VAR 0 9
 978: ARRAY
 979: PUSH
 980: LD_INT 2
 982: ARRAY
 983: PPUSH
 984: LD_INT 5
 986: PPUSH
 987: LD_INT 0
 989: PPUSH
 990: CALL_OW 50
// end ;
 994: GO 892
 996: POP
 997: POP
// full_forts ( [ fort1 , fort2 , fort3 ] , UnitFilter ( all , [ [ f_class , class_soldier ] ] ) ) ;
 998: LD_INT 21
1000: PUSH
1001: LD_INT 28
1003: PUSH
1004: LD_INT 86
1006: PUSH
1007: EMPTY
1008: LIST
1009: LIST
1010: LIST
1011: PPUSH
1012: LD_VAR 0 6
1016: PPUSH
1017: LD_INT 25
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL_OW 72
1034: PPUSH
1035: CALL 12554 0 2
// lidi_base := all ;
1039: LD_ADDR_EXP 59
1043: PUSH
1044: LD_VAR 0 6
1048: ST_TO_ADDR
// lidi := lidi union lidi_base ;
1049: LD_ADDR_EXP 58
1053: PUSH
1054: LD_EXP 58
1058: PUSH
1059: LD_EXP 59
1063: UNION
1064: ST_TO_ADDR
// lidi := lidi ^ JMM ;
1065: LD_ADDR_EXP 58
1069: PUSH
1070: LD_EXP 58
1074: PUSH
1075: LD_EXP 17
1079: ADD
1080: ST_TO_ADDR
// DeleteVariable ( Delta ) ;
1081: LD_STRING Delta
1083: PPUSH
1084: CALL_OW 41
// DeleteCharacters ( Sikorski ) ;
1088: LD_STRING Sikorski
1090: PPUSH
1091: CALL_OW 40
// end ;
1095: LD_VAR 0 1
1099: RET
// function SetDifficulty ; begin
1100: LD_INT 0
1102: PPUSH
// KolikMaBytSiberitu := 60 ;
1103: LD_ADDR_EXP 66
1107: PUSH
1108: LD_INT 60
1110: ST_TO_ADDR
// EndSiberit := [ 150 , 200 , 250 ] [ difficulty ] ;
1111: LD_ADDR_EXP 55
1115: PUSH
1116: LD_INT 150
1118: PUSH
1119: LD_INT 200
1121: PUSH
1122: LD_INT 250
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_OWVAR 67
1134: ARRAY
1135: ST_TO_ADDR
// lev := [ 3 , 5 , 7 ] ;
1136: LD_ADDR_EXP 5
1140: PUSH
1141: LD_INT 3
1143: PUSH
1144: LD_INT 5
1146: PUSH
1147: LD_INT 7
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: ST_TO_ADDR
// end ;
1155: LD_VAR 0 1
1159: RET
// function prepare_your_units ; var i , j ; begin
1160: LD_INT 0
1162: PPUSH
1163: PPUSH
1164: PPUSH
// InitUc ;
1165: CALL_OW 18
// InitHc ;
1169: CALL_OW 19
// uc_side := you2 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_EXP 48
1182: ST_TO_ADDR
// uc_nation := nation_american ;
1183: LD_ADDR_OWVAR 21
1187: PUSH
1188: LD_INT 1
1190: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1191: LD_INT 0
1193: PPUSH
1194: LD_INT 4
1196: PPUSH
1197: CALL_OW 382
// Eng1 := CreateHuman ;
1201: LD_ADDR_EXP 26
1205: PUSH
1206: CALL_OW 44
1210: ST_TO_ADDR
// PrepareEngineer ( 0 , 5 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 5
1216: PPUSH
1217: CALL_OW 382
// Eng2 := CreateHuman ;
1221: LD_ADDR_EXP 27
1225: PUSH
1226: CALL_OW 44
1230: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1231: LD_INT 0
1233: PPUSH
1234: LD_INT 4
1236: PPUSH
1237: CALL_OW 382
// Eng3 := CreateHuman ;
1241: LD_ADDR_EXP 28
1245: PUSH
1246: CALL_OW 44
1250: ST_TO_ADDR
// PrepareEngineer ( 0 , 4 ) ;
1251: LD_INT 0
1253: PPUSH
1254: LD_INT 4
1256: PPUSH
1257: CALL_OW 382
// Eng4 := CreateHuman ;
1261: LD_ADDR_EXP 29
1265: PUSH
1266: CALL_OW 44
1270: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1271: LD_ADDR_OWVAR 37
1275: PUSH
1276: LD_INT 2
1278: ST_TO_ADDR
// vc_control := control_manual ;
1279: LD_ADDR_OWVAR 38
1283: PUSH
1284: LD_INT 1
1286: ST_TO_ADDR
// vc_engine := engine_solar ;
1287: LD_ADDR_OWVAR 39
1291: PUSH
1292: LD_INT 2
1294: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1295: LD_ADDR_OWVAR 40
1299: PUSH
1300: LD_INT 12
1302: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1303: LD_ADDR_OWVAR 41
1307: PUSH
1308: LD_INT 60
1310: ST_TO_ADDR
// CarE1 := CreateVehicle ;
1311: LD_ADDR_EXP 30
1315: PUSH
1316: CALL_OW 45
1320: ST_TO_ADDR
// lidi_eng := [ Eng1 , Eng2 , Eng3 ] ;
1321: LD_ADDR_EXP 60
1325: PUSH
1326: LD_EXP 26
1330: PUSH
1331: LD_EXP 27
1335: PUSH
1336: LD_EXP 28
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: ST_TO_ADDR
// lidi := lidi union lidi_eng ;
1346: LD_ADDR_EXP 58
1350: PUSH
1351: LD_EXP 58
1355: PUSH
1356: LD_EXP 60
1360: UNION
1361: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1362: LD_INT 0
1364: PPUSH
1365: LD_INT 4
1367: PPUSH
1368: CALL_OW 383
// Mec1 := CreateHuman ;
1372: LD_ADDR_EXP 31
1376: PUSH
1377: CALL_OW 44
1381: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1382: LD_INT 0
1384: PPUSH
1385: LD_INT 4
1387: PPUSH
1388: CALL_OW 383
// Mec2 := CreateHuman ;
1392: LD_ADDR_EXP 32
1396: PUSH
1397: CALL_OW 44
1401: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
1402: LD_INT 0
1404: PPUSH
1405: LD_INT 4
1407: PPUSH
1408: CALL_OW 383
// Mec3 := CreateHuman ;
1412: LD_ADDR_EXP 33
1416: PUSH
1417: CALL_OW 44
1421: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
1422: LD_ADDR_OWVAR 37
1426: PUSH
1427: LD_INT 2
1429: ST_TO_ADDR
// vc_control := control_manual ;
1430: LD_ADDR_OWVAR 38
1434: PUSH
1435: LD_INT 1
1437: ST_TO_ADDR
// vc_engine := engine_solar ;
1438: LD_ADDR_OWVAR 39
1442: PUSH
1443: LD_INT 2
1445: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
1446: LD_ADDR_OWVAR 40
1450: PUSH
1451: LD_INT 12
1453: ST_TO_ADDR
// vc_fuel_battery := 60 ;
1454: LD_ADDR_OWVAR 41
1458: PUSH
1459: LD_INT 60
1461: ST_TO_ADDR
// Car1 := CreateVehicle ;
1462: LD_ADDR_EXP 34
1466: PUSH
1467: CALL_OW 45
1471: ST_TO_ADDR
// Car2 := CreateVehicle ;
1472: LD_ADDR_EXP 35
1476: PUSH
1477: CALL_OW 45
1481: ST_TO_ADDR
// Car3 := CreateVehicle ;
1482: LD_ADDR_EXP 36
1486: PUSH
1487: CALL_OW 45
1491: ST_TO_ADDR
// end ;
1492: LD_VAR 0 1
1496: RET
// function prepare_arabians_units ; begin
1497: LD_INT 0
1499: PPUSH
// InitUc ;
1500: CALL_OW 18
// InitHc ;
1504: CALL_OW 19
// uc_side := arabians ;
1508: LD_ADDR_OWVAR 20
1512: PUSH
1513: LD_EXP 50
1517: ST_TO_ADDR
// uc_nation := nation_arabian ;
1518: LD_ADDR_OWVAR 21
1522: PUSH
1523: LD_INT 2
1525: ST_TO_ADDR
// PrepareSoldier ( sex_male , 4 ) ;
1526: LD_INT 1
1528: PPUSH
1529: LD_INT 4
1531: PPUSH
1532: CALL_OW 381
// Ara1 := CreateHuman ;
1536: LD_ADDR_EXP 39
1540: PUSH
1541: CALL_OW 44
1545: ST_TO_ADDR
// hc_name := Louis Gali ;
1546: LD_ADDR_OWVAR 26
1550: PUSH
1551: LD_STRING Louis Gali
1553: ST_TO_ADDR
// PrepareEngineer ( sex_male , 5 ) ;
1554: LD_INT 1
1556: PPUSH
1557: LD_INT 5
1559: PPUSH
1560: CALL_OW 382
// Ara2 := CreateHuman ;
1564: LD_ADDR_EXP 40
1568: PUSH
1569: CALL_OW 44
1573: ST_TO_ADDR
// InitHc ;
1574: CALL_OW 19
// uc_side := arabians ;
1578: LD_ADDR_OWVAR 20
1582: PUSH
1583: LD_EXP 50
1587: ST_TO_ADDR
// uc_nation := nation_arabian ;
1588: LD_ADDR_OWVAR 21
1592: PUSH
1593: LD_INT 2
1595: ST_TO_ADDR
// PrepareSoldier ( sex_female , 4 ) ;
1596: LD_INT 2
1598: PPUSH
1599: LD_INT 4
1601: PPUSH
1602: CALL_OW 381
// Ara3 := CreateHuman ;
1606: LD_ADDR_EXP 41
1610: PUSH
1611: CALL_OW 44
1615: ST_TO_ADDR
// PrepareMechanic ( sex_male , 5 ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 5
1621: PPUSH
1622: CALL_OW 383
// Ara4 := CreateHuman ;
1626: LD_ADDR_EXP 42
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PrepareMechanic ( sex_male , 4 ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 4
1641: PPUSH
1642: CALL_OW 383
// Ara5 := CreateHuman ;
1646: LD_ADDR_EXP 43
1650: PUSH
1651: CALL_OW 44
1655: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1656: LD_ADDR_OWVAR 37
1660: PUSH
1661: LD_INT 14
1663: ST_TO_ADDR
// vc_control := control_manual ;
1664: LD_ADDR_OWVAR 38
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// vc_engine := engine_combustion ;
1672: LD_ADDR_OWVAR 39
1676: PUSH
1677: LD_INT 1
1679: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
1680: LD_ADDR_OWVAR 40
1684: PUSH
1685: LD_INT 26
1687: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1688: LD_ADDR_OWVAR 41
1692: PUSH
1693: LD_INT 9
1695: ST_TO_ADDR
// AraCar1 := CreateVehicle ;
1696: LD_ADDR_EXP 44
1700: PUSH
1701: CALL_OW 45
1705: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
1706: LD_ADDR_OWVAR 37
1710: PUSH
1711: LD_INT 14
1713: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
1714: LD_ADDR_OWVAR 40
1718: PUSH
1719: LD_INT 32
1721: ST_TO_ADDR
// vc_fuel_battery := 9 ;
1722: LD_ADDR_OWVAR 41
1726: PUSH
1727: LD_INT 9
1729: ST_TO_ADDR
// AraCar2 := CreateVehicle ;
1730: LD_ADDR_EXP 45
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// arabi := [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] ;
1740: LD_ADDR_EXP 46
1744: PUSH
1745: LD_EXP 39
1749: PUSH
1750: LD_EXP 40
1754: PUSH
1755: LD_EXP 41
1759: PUSH
1760: LD_EXP 42
1764: PUSH
1765: LD_EXP 43
1769: PUSH
1770: LD_EXP 44
1774: PUSH
1775: LD_EXP 45
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: ST_TO_ADDR
// PlaceHumanInUnit ( Ara4 , AraCar1 ) ;
1789: LD_EXP 42
1793: PPUSH
1794: LD_EXP 44
1798: PPUSH
1799: CALL_OW 52
// PlaceHumanInUnit ( Ara5 , AraCar2 ) ;
1803: LD_EXP 43
1807: PPUSH
1808: LD_EXP 45
1812: PPUSH
1813: CALL_OW 52
// end ;
1817: LD_VAR 0 1
1821: RET
// function prepare_russians_units ; begin
1822: LD_INT 0
1824: PPUSH
// end ;
1825: LD_VAR 0 1
1829: RET
// starting begin f_testing ;
1830: CALL 0 0 0
// depot1 := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1834: LD_ADDR_EXP 69
1838: PUSH
1839: LD_INT 23
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 30
1851: PUSH
1852: LD_INT 0
1854: PUSH
1855: EMPTY
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: PPUSH
1863: CALL_OW 69
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: ST_TO_ADDR
// rudepot1 := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
1872: LD_ADDR_EXP 67
1876: PUSH
1877: LD_INT 23
1879: PUSH
1880: LD_INT 3
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 30
1889: PUSH
1890: LD_INT 0
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PPUSH
1901: CALL_OW 69
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: ST_TO_ADDR
// SetBName ( depot1 , terminal ) ;
1910: LD_EXP 69
1914: PPUSH
1915: LD_STRING terminal
1917: PPUSH
1918: CALL_OW 500
// map_size_x := 70 ;
1922: LD_ADDR_EXP 7
1926: PUSH
1927: LD_INT 70
1929: ST_TO_ADDR
// map_size_y := 140 ;
1930: LD_ADDR_EXP 8
1934: PUSH
1935: LD_INT 140
1937: ST_TO_ADDR
// lidi := [ ] ;
1938: LD_ADDR_EXP 58
1942: PUSH
1943: EMPTY
1944: ST_TO_ADDR
// lidi_base := [ ] ;
1945: LD_ADDR_EXP 59
1949: PUSH
1950: EMPTY
1951: ST_TO_ADDR
// lidi_eng := [ ] ;
1952: LD_ADDR_EXP 60
1956: PUSH
1957: EMPTY
1958: ST_TO_ADDR
// neco_rikaji := [ ] ;
1959: LD_ADDR_EXP 61
1963: PUSH
1964: EMPTY
1965: ST_TO_ADDR
// counter_time := 0 ;
1966: LD_ADDR_EXP 64
1970: PUSH
1971: LD_INT 0
1973: ST_TO_ADDR
// SetDifficulty ;
1974: CALL 1100 0 0
// mhmg := 1 ;
1978: LD_ADDR_EXP 9
1982: PUSH
1983: LD_INT 1
1985: ST_TO_ADDR
// mgg := 2 ;
1986: LD_ADDR_EXP 10
1990: PUSH
1991: LD_INT 2
1993: ST_TO_ADDR
// mg := 3 ;
1994: LD_ADDR_EXP 11
1998: PUSH
1999: LD_INT 3
2001: ST_TO_ADDR
// mrl := 4 ;
2002: LD_ADDR_EXP 12
2006: PUSH
2007: LD_INT 4
2009: ST_TO_ADDR
// hgg := 5 ;
2010: LD_ADDR_EXP 13
2014: PUSH
2015: LD_INT 5
2017: ST_TO_ADDR
// hrl := 6 ;
2018: LD_ADDR_EXP 14
2022: PUSH
2023: LD_INT 6
2025: ST_TO_ADDR
// hhg := 7 ;
2026: LD_ADDR_EXP 15
2030: PUSH
2031: LD_INT 7
2033: ST_TO_ADDR
// you := 1 ;
2034: LD_ADDR_EXP 47
2038: PUSH
2039: LD_INT 1
2041: ST_TO_ADDR
// you2 := 4 ;
2042: LD_ADDR_EXP 48
2046: PUSH
2047: LD_INT 4
2049: ST_TO_ADDR
// arabians := 2 ;
2050: LD_ADDR_EXP 50
2054: PUSH
2055: LD_INT 2
2057: ST_TO_ADDR
// russians := 3 ;
2058: LD_ADDR_EXP 49
2062: PUSH
2063: LD_INT 3
2065: ST_TO_ADDR
// SetBName ( RuDepot , ovsyenko ) ;
2066: LD_INT 58
2068: PPUSH
2069: LD_STRING ovsyenko
2071: PPUSH
2072: CALL_OW 500
// prepare_your_units ;
2076: CALL 1160 0 0
// prepare_arabians_units ;
2080: CALL 1497 0 0
// prepare_russians_units ;
2084: CALL 1822 0 0
// load_units_2 ;
2088: CALL 99 0 0
// Dialog2 ;
2092: CALL 2900 0 0
// end ;
2096: END
// export function Save ; var sibu ; begin
2097: LD_INT 0
2099: PPUSH
2100: PPUSH
// SaveCharacters ( JMM , JMM ) ;
2101: LD_EXP 17
2105: PPUSH
2106: LD_STRING JMM
2108: PPUSH
2109: CALL_OW 38
// if Bobby then
2113: LD_EXP 18
2117: IFFALSE 2152
// begin SaveCharacters ( Bobby , Bobby ) ;
2119: LD_EXP 18
2123: PPUSH
2124: LD_STRING Bobby
2126: PPUSH
2127: CALL_OW 38
// if IsDead ( Bobby ) then
2131: LD_EXP 18
2135: PPUSH
2136: CALL_OW 301
2140: IFFALSE 2152
// SaveVariable ( 0 , BobbyLoc ) ;
2142: LD_INT 0
2144: PPUSH
2145: LD_STRING BobbyLoc
2147: PPUSH
2148: CALL_OW 39
// end ; if Cyrus then
2152: LD_EXP 19
2156: IFFALSE 2191
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2158: LD_EXP 19
2162: PPUSH
2163: LD_STRING Cyrus
2165: PPUSH
2166: CALL_OW 38
// if IsDead ( Cyrus ) then
2170: LD_EXP 19
2174: PPUSH
2175: CALL_OW 301
2179: IFFALSE 2191
// SaveVariable ( 0 , CyrusLoc ) ;
2181: LD_INT 0
2183: PPUSH
2184: LD_STRING CyrusLoc
2186: PPUSH
2187: CALL_OW 39
// end ; if Brown then
2191: LD_EXP 21
2195: IFFALSE 2230
// begin SaveCharacters ( Brown , Brown ) ;
2197: LD_EXP 21
2201: PPUSH
2202: LD_STRING Brown
2204: PPUSH
2205: CALL_OW 38
// if IsDead ( Brown ) then
2209: LD_EXP 21
2213: PPUSH
2214: CALL_OW 301
2218: IFFALSE 2230
// SaveVariable ( 0 , BrownLoc ) ;
2220: LD_INT 0
2222: PPUSH
2223: LD_STRING BrownLoc
2225: PPUSH
2226: CALL_OW 39
// end ; if Donaldson then
2230: LD_EXP 20
2234: IFFALSE 2269
// begin SaveCharacters ( Donaldson , Donaldson ) ;
2236: LD_EXP 20
2240: PPUSH
2241: LD_STRING Donaldson
2243: PPUSH
2244: CALL_OW 38
// if IsDead ( Donaldson ) then
2248: LD_EXP 20
2252: PPUSH
2253: CALL_OW 301
2257: IFFALSE 2269
// SaveVariable ( 0 , DonaldsonLoc ) ;
2259: LD_INT 0
2261: PPUSH
2262: LD_STRING DonaldsonLoc
2264: PPUSH
2265: CALL_OW 39
// end ; SaveCharacters ( Gary , Gary ) ;
2269: LD_EXP 22
2273: PPUSH
2274: LD_STRING Gary
2276: PPUSH
2277: CALL_OW 38
// if IsDead ( Gary ) then
2281: LD_EXP 22
2285: PPUSH
2286: CALL_OW 301
2290: IFFALSE 2302
// SaveVariable ( 0 , GaryLoc ) ;
2292: LD_INT 0
2294: PPUSH
2295: LD_STRING GaryLoc
2297: PPUSH
2298: CALL_OW 39
// sibu := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2302: LD_ADDR_VAR 0 2
2306: PUSH
2307: LD_EXP 69
2311: PPUSH
2312: CALL_OW 274
2316: PPUSH
2317: LD_INT 3
2319: PPUSH
2320: CALL_OW 275
2324: ST_TO_ADDR
// if sibu > 300 then
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 300
2332: GREATER
2333: IFFALSE 2343
// sibu := 300 ;
2335: LD_ADDR_VAR 0 2
2339: PUSH
2340: LD_INT 300
2342: ST_TO_ADDR
// SaveVariable ( sibu , stoupa9_siberit ) ;
2343: LD_VAR 0 2
2347: PPUSH
2348: LD_STRING stoupa9_siberit
2350: PPUSH
2351: CALL_OW 39
// SaveVariable ( ( PoskytnouInformace > 0 ) , stoupa9_informace ) ;
2355: LD_EXP 56
2359: PUSH
2360: LD_INT 0
2362: GREATER
2363: PPUSH
2364: LD_STRING stoupa9_informace
2366: PPUSH
2367: CALL_OW 39
// SaveCharacters ( other_survivors , other_survivors ) ;
2371: LD_EXP 52
2375: PPUSH
2376: LD_STRING other_survivors
2378: PPUSH
2379: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Donaldson , Brown , Bobby , Cyrus , Gary , 0 ] , otherWithJMM ) ;
2383: LD_INT 22
2385: PUSH
2386: LD_EXP 47
2390: PUSH
2391: EMPTY
2392: LIST
2393: LIST
2394: PUSH
2395: LD_INT 21
2397: PUSH
2398: LD_INT 1
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: LD_INT 23
2407: PUSH
2408: LD_INT 1
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: LIST
2419: PPUSH
2420: CALL_OW 69
2424: PUSH
2425: LD_EXP 17
2429: PUSH
2430: LD_EXP 20
2434: PUSH
2435: LD_EXP 21
2439: PUSH
2440: LD_EXP 18
2444: PUSH
2445: LD_EXP 19
2449: PUSH
2450: LD_EXP 22
2454: PUSH
2455: LD_INT 0
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: LIST
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: DIFF
2467: PPUSH
2468: LD_STRING otherWithJMM
2470: PPUSH
2471: CALL_OW 38
// end ;
2475: LD_VAR 0 1
2479: RET
// every 0 0$3 trigger depot1 do var sib_dep1 ;
2480: LD_EXP 69
2484: IFFALSE 2537
2486: GO 2488
2488: DISABLE
2489: LD_INT 0
2491: PPUSH
// begin sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2492: LD_ADDR_VAR 0 1
2496: PUSH
2497: LD_EXP 69
2501: PPUSH
2502: CALL_OW 274
2506: PPUSH
2507: LD_INT 3
2509: PPUSH
2510: CALL_OW 275
2514: ST_TO_ADDR
// if sib_dep1 >= EndSiberit then
2515: LD_VAR 0 1
2519: PUSH
2520: LD_EXP 55
2524: GREATEREQUAL
2525: IFFALSE 2536
// ChangeMissionObjectives ( M2a ) else
2527: LD_STRING M2a
2529: PPUSH
2530: CALL_OW 337
2534: GO 2537
// enable ;
2536: ENABLE
// end ;
2537: PPOPN 1
2539: END
// export function SetMedals ; var d , sib_dep1 , sib_celkem , i ; begin
2540: LD_INT 0
2542: PPUSH
2543: PPUSH
2544: PPUSH
2545: PPUSH
2546: PPUSH
// d := difficulty - 1 ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_OWVAR 67
2556: PUSH
2557: LD_INT 1
2559: MINUS
2560: ST_TO_ADDR
// sib_dep1 := GetResourceType ( GetBase ( depot1 ) , mat_siberit ) ;
2561: LD_ADDR_VAR 0 3
2565: PUSH
2566: LD_EXP 69
2570: PPUSH
2571: CALL_OW 274
2575: PPUSH
2576: LD_INT 3
2578: PPUSH
2579: CALL_OW 275
2583: ST_TO_ADDR
// sib_celkem := 0 ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_INT 0
2591: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_INT 22
2599: PUSH
2600: LD_EXP 47
2604: PUSH
2605: EMPTY
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 2
2611: PUSH
2612: LD_INT 30
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: PUSH
2622: LD_INT 30
2624: PUSH
2625: LD_INT 1
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: LIST
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PPUSH
2641: CALL_OW 69
2645: PUSH
2646: FOR_IN
2647: IFFALSE 2680
// sib_celkem := sib_celkem + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
2649: LD_ADDR_VAR 0 4
2653: PUSH
2654: LD_VAR 0 4
2658: PUSH
2659: LD_VAR 0 5
2663: PPUSH
2664: CALL_OW 274
2668: PPUSH
2669: LD_INT 3
2671: PPUSH
2672: CALL_OW 275
2676: PLUS
2677: ST_TO_ADDR
2678: GO 2646
2680: POP
2681: POP
// if sib_dep1 >= EndSiberit then
2682: LD_VAR 0 3
2686: PUSH
2687: LD_EXP 55
2691: GREATEREQUAL
2692: IFFALSE 2706
// AddMedal ( MuchSiberite , 1 ) else
2694: LD_STRING MuchSiberite
2696: PPUSH
2697: LD_INT 1
2699: PPUSH
2700: CALL_OW 101
2704: GO 2762
// if sib_celkem < EndSiberit then
2706: LD_VAR 0 4
2710: PUSH
2711: LD_EXP 55
2715: LESS
2716: IFFALSE 2741
// AddMedal ( MuchSiberite , - 1 - 2 * d ) else
2718: LD_STRING MuchSiberite
2720: PPUSH
2721: LD_INT 1
2723: NEG
2724: PUSH
2725: LD_INT 2
2727: PUSH
2728: LD_VAR 0 2
2732: MUL
2733: MINUS
2734: PPUSH
2735: CALL_OW 101
2739: GO 2762
// AddMedal ( MuchSiberite , - 2 - 2 * d ) ;
2741: LD_STRING MuchSiberite
2743: PPUSH
2744: LD_INT 2
2746: NEG
2747: PUSH
2748: LD_INT 2
2750: PUSH
2751: LD_VAR 0 2
2755: MUL
2756: MINUS
2757: PPUSH
2758: CALL_OW 101
// AddMedal ( EarlySiberite , not NastvalPowella ) ;
2762: LD_STRING EarlySiberite
2764: PPUSH
2765: LD_EXP 57
2769: NOT
2770: PPUSH
2771: CALL_OW 101
// AddMedal ( Information , PoskytnouInformace > 0 ) ;
2775: LD_STRING Information
2777: PPUSH
2778: LD_EXP 56
2782: PUSH
2783: LD_INT 0
2785: GREATER
2786: PPUSH
2787: CALL_OW 101
// end ;
2791: LD_VAR 0 1
2795: RET
// export Vyhrano ; export function Vyhra ; begin
2796: LD_INT 0
2798: PPUSH
// if not Vyhrano then
2799: LD_EXP 70
2803: NOT
2804: IFFALSE 2894
// begin Vyhrano := true ;
2806: LD_ADDR_EXP 70
2810: PUSH
2811: LD_INT 1
2813: ST_TO_ADDR
// SetMedals ;
2814: CALL 2540 0 0
// GiveMedals ( Main ) ;
2818: LD_STRING Main
2820: PPUSH
2821: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
2825: LD_INT 22
2827: PUSH
2828: LD_EXP 47
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 21
2839: PUSH
2840: LD_INT 1
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 23
2849: PUSH
2850: LD_INT 1
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: PPUSH
2867: CALL_OW 43
// Save ;
2871: CALL 2097 0 0
// YouWin ;
2875: CALL_OW 103
// ExclusiveOn ;
2879: CALL_OW 4
// WAIT ( 1 ) ;
2883: LD_INT 1
2885: PPUSH
2886: CALL_OW 67
// ExclusiveOff ;
2890: CALL_OW 5
// end ; end ;
2894: LD_VAR 0 1
2898: RET
// final begin end ; end_of_file
2899: END
// export ArmBuild ; export ArmUpgraded ; export function Dialog2 ; begin
2900: LD_INT 0
2902: PPUSH
// InGameOn ;
2903: CALL_OW 8
// PlaceUnitXYR ( Eng1 , 35 , 8 , 3 , false ) ;
2907: LD_EXP 26
2911: PPUSH
2912: LD_INT 35
2914: PPUSH
2915: LD_INT 8
2917: PPUSH
2918: LD_INT 3
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 50
// PlaceUnitXYR ( Eng2 , 35 , 8 , 3 , false ) ;
2928: LD_EXP 27
2932: PPUSH
2933: LD_INT 35
2935: PPUSH
2936: LD_INT 8
2938: PPUSH
2939: LD_INT 3
2941: PPUSH
2942: LD_INT 0
2944: PPUSH
2945: CALL_OW 50
// PlaceUnitXYR ( Eng3 , 35 , 8 , 3 , false ) ;
2949: LD_EXP 28
2953: PPUSH
2954: LD_INT 35
2956: PPUSH
2957: LD_INT 8
2959: PPUSH
2960: LD_INT 3
2962: PPUSH
2963: LD_INT 0
2965: PPUSH
2966: CALL_OW 50
// PlaceHumanInUnit ( Eng4 , CarE1 ) ;
2970: LD_EXP 29
2974: PPUSH
2975: LD_EXP 30
2979: PPUSH
2980: CALL_OW 52
// PlaceUnitXY ( CarE1 , 41 , 9 , false ) ;
2984: LD_EXP 30
2988: PPUSH
2989: LD_INT 41
2991: PPUSH
2992: LD_INT 9
2994: PPUSH
2995: LD_INT 0
2997: PPUSH
2998: CALL_OW 48
// ComHold ( CarE1 ) ;
3002: LD_EXP 30
3006: PPUSH
3007: CALL_OW 140
// ComMoveXY ( [ Eng1 , Eng2 , Eng3 ] , 34 , 6 ) ;
3011: LD_EXP 26
3015: PUSH
3016: LD_EXP 27
3020: PUSH
3021: LD_EXP 28
3025: PUSH
3026: EMPTY
3027: LIST
3028: LIST
3029: LIST
3030: PPUSH
3031: LD_INT 34
3033: PPUSH
3034: LD_INT 6
3036: PPUSH
3037: CALL_OW 111
// AddComRepairBuilding ( [ Eng1 , Eng2 , Eng3 ] , Depot1 ) ;
3041: LD_EXP 26
3045: PUSH
3046: LD_EXP 27
3050: PUSH
3051: LD_EXP 28
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: PPUSH
3061: LD_EXP 69
3065: PPUSH
3066: CALL_OW 190
// ComEnterUnit ( Gary , rudepot1 ) ;
3070: LD_EXP 22
3074: PPUSH
3075: LD_EXP 67
3079: PPUSH
3080: CALL_OW 120
// Wait ( 0 0$1 ) ;
3084: LD_INT 35
3086: PPUSH
3087: CALL_OW 67
// PlaceUnitXY ( JMM , 33 , 1 , false ) ;
3091: LD_EXP 17
3095: PPUSH
3096: LD_INT 33
3098: PPUSH
3099: LD_INT 1
3101: PPUSH
3102: LD_INT 0
3104: PPUSH
3105: CALL_OW 48
// CenterNowOnUnits ( JMM ) ;
3109: LD_EXP 17
3113: PPUSH
3114: CALL_OW 87
// ComMoveXY ( JMM , 34 , 5 ) ;
3118: LD_EXP 17
3122: PPUSH
3123: LD_INT 34
3125: PPUSH
3126: LD_INT 5
3128: PPUSH
3129: CALL_OW 111
// AddComStand ( JMM ) ;
3133: LD_EXP 17
3137: PPUSH
3138: CALL_OW 225
// CreateCratesXY ( 5 , 39 , 10 , false ) ;
3142: LD_INT 5
3144: PPUSH
3145: LD_INT 39
3147: PPUSH
3148: LD_INT 10
3150: PPUSH
3151: LD_INT 0
3153: PPUSH
3154: CALL_OW 54
// CreateCratesXY ( 5 , 39 , 11 , false ) ;
3158: LD_INT 5
3160: PPUSH
3161: LD_INT 39
3163: PPUSH
3164: LD_INT 11
3166: PPUSH
3167: LD_INT 0
3169: PPUSH
3170: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 10 , false ) ;
3174: LD_INT 5
3176: PPUSH
3177: LD_INT 38
3179: PPUSH
3180: LD_INT 10
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 54
// CreateCratesXY ( 5 , 38 , 11 , false ) ;
3190: LD_INT 5
3192: PPUSH
3193: LD_INT 38
3195: PPUSH
3196: LD_INT 11
3198: PPUSH
3199: LD_INT 0
3201: PPUSH
3202: CALL_OW 54
// Wait ( 0 0$3 ) ;
3206: LD_INT 105
3208: PPUSH
3209: CALL_OW 67
// ComMoveXY ( CarE1 , 38 , 1 ) ;
3213: LD_EXP 30
3217: PPUSH
3218: LD_INT 38
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: CALL_OW 111
// while GetY ( CarE1 ) > 3 do
3228: LD_EXP 30
3232: PPUSH
3233: CALL_OW 251
3237: PUSH
3238: LD_INT 3
3240: GREATER
3241: IFFALSE 3252
// wait ( 0 0$0.3 ) ;
3243: LD_INT 10
3245: PPUSH
3246: CALL_OW 67
3250: GO 3228
// RemoveUnit ( CarE1 ) ;
3252: LD_EXP 30
3256: PPUSH
3257: CALL_OW 64
// Say ( JMM , D2-JMM-1 ) ;
3261: LD_EXP 17
3265: PPUSH
3266: LD_STRING D2-JMM-1
3268: PPUSH
3269: CALL_OW 88
// Say ( Eng1 , D2-Eng1-1 ) ;
3273: LD_EXP 26
3277: PPUSH
3278: LD_STRING D2-Eng1-1
3280: PPUSH
3281: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3285: LD_EXP 17
3289: PPUSH
3290: LD_STRING D2-JMM-2
3292: PPUSH
3293: CALL_OW 88
// Say ( Eng1 , D2-Eng1-2 ) ;
3297: LD_EXP 26
3301: PPUSH
3302: LD_STRING D2-Eng1-2
3304: PPUSH
3305: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3309: LD_EXP 17
3313: PPUSH
3314: LD_STRING D2-JMM-3
3316: PPUSH
3317: CALL_OW 88
// SetSideBase ( GetBase ( Depot1 ) , you ) ;
3321: LD_EXP 69
3325: PPUSH
3326: CALL_OW 274
3330: PPUSH
3331: LD_EXP 47
3335: PPUSH
3336: CALL_OW 236
// SetSide ( [ Eng1 , Eng2 , Eng3 ] , you ) ;
3340: LD_EXP 26
3344: PUSH
3345: LD_EXP 27
3349: PUSH
3350: LD_EXP 28
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: PPUSH
3360: LD_EXP 47
3364: PPUSH
3365: CALL_OW 235
// SaveForQuickRestart ;
3369: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3373: LD_STRING M1
3375: PPUSH
3376: CALL_OW 337
// InGameOff ;
3380: CALL_OW 9
// end ;
3384: LD_VAR 0 1
3388: RET
// export byld2a ; every 0 0$2 trigger IsInArea ( JMM , base ) marked 30 do
3389: LD_EXP 17
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: CALL_OW 308
3401: IFFALSE 3410
3403: GO 3405
3405: DISABLE
// begin dialog2a ;
3406: CALL 3411 0 0
// end ;
3410: END
// export function dialog2a ; var i ; begin
3411: LD_INT 0
3413: PPUSH
3414: PPUSH
// Wait ( 0 0$1 ) ;
3415: LD_INT 35
3417: PPUSH
3418: CALL_OW 67
// ComMoveUnit ( Gary , JMM ) ;
3422: LD_EXP 22
3426: PPUSH
3427: LD_EXP 17
3431: PPUSH
3432: CALL_OW 112
// byld2a := true ;
3436: LD_ADDR_EXP 73
3440: PUSH
3441: LD_INT 1
3443: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
3444: LD_INT 105
3446: PPUSH
3447: CALL_OW 67
// DialogueOn ;
3451: CALL_OW 6
// Say ( JMM , D2-JMM-3a ) ;
3455: LD_EXP 17
3459: PPUSH
3460: LD_STRING D2-JMM-3a
3462: PPUSH
3463: CALL_OW 88
// SetSideBase ( GetBase ( rudepot1 ) , you ) ;
3467: LD_EXP 67
3471: PPUSH
3472: CALL_OW 274
3476: PPUSH
3477: LD_EXP 47
3481: PPUSH
3482: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you2 ] , [ f_type , unit_building ] ] ) do
3486: LD_ADDR_VAR 0 2
3490: PUSH
3491: LD_INT 22
3493: PUSH
3494: LD_EXP 48
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PUSH
3503: LD_INT 21
3505: PUSH
3506: LD_INT 3
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PPUSH
3517: CALL_OW 69
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3541
// SetSide ( i , you ) ;
3525: LD_VAR 0 2
3529: PPUSH
3530: LD_EXP 47
3534: PPUSH
3535: CALL_OW 235
3539: GO 3522
3541: POP
3542: POP
// SetSide ( lidi_base , you ) ;
3543: LD_EXP 59
3547: PPUSH
3548: LD_EXP 47
3552: PPUSH
3553: CALL_OW 235
// SetResourceType ( GetBase ( rudepot1 ) , mat_siberit , 0 ) ;
3557: LD_EXP 67
3561: PPUSH
3562: CALL_OW 274
3566: PPUSH
3567: LD_INT 3
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 277
// Say ( Gary , D2-Gary-3 ) ;
3577: LD_EXP 22
3581: PPUSH
3582: LD_STRING D2-Gary-3
3584: PPUSH
3585: CALL_OW 88
// if Bobby then
3589: LD_EXP 18
3593: IFFALSE 3607
// Say ( Bobby , D2-Bobby-3 ) ;
3595: LD_EXP 18
3599: PPUSH
3600: LD_STRING D2-Bobby-3
3602: PPUSH
3603: CALL_OW 88
// if Cyrus then
3607: LD_EXP 19
3611: IFFALSE 3625
// Say ( Cyrus , D2-Cyrus-3 ) ;
3613: LD_EXP 19
3617: PPUSH
3618: LD_STRING D2-Cyrus-3
3620: PPUSH
3621: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3625: LD_EXP 17
3629: PPUSH
3630: LD_STRING D2-JMM-4
3632: PPUSH
3633: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3637: LD_EXP 22
3641: PPUSH
3642: LD_STRING D2-Gary-4
3644: PPUSH
3645: CALL_OW 88
// if Cyrus then
3649: LD_EXP 19
3653: IFFALSE 3669
// Say ( Cyrus , D2-Cyrus-4 ) else
3655: LD_EXP 19
3659: PPUSH
3660: LD_STRING D2-Cyrus-4
3662: PPUSH
3663: CALL_OW 88
3667: GO 3701
// SayAny ( lidi_base diff neco_rikaji , D2-Sol1-4 , you , sex_male , 0 , 0 ) ;
3669: LD_EXP 59
3673: PUSH
3674: LD_EXP 61
3678: DIFF
3679: PPUSH
3680: LD_STRING D2-Sol1-4
3682: PPUSH
3683: LD_EXP 47
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL 13011 0 6
// Say ( JMM , D2-JMM-5 ) ;
3701: LD_EXP 17
3705: PPUSH
3706: LD_STRING D2-JMM-5
3708: PPUSH
3709: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-5 , you , sex_female , class_engineer , 0 ) ;
3713: LD_EXP 58
3717: PUSH
3718: LD_EXP 61
3722: DIFF
3723: PPUSH
3724: LD_STRING D2-FEng1-5
3726: PPUSH
3727: LD_EXP 47
3731: PPUSH
3732: LD_INT 2
3734: PPUSH
3735: LD_INT 2
3737: PPUSH
3738: LD_INT 0
3740: PPUSH
3741: CALL 13011 0 6
// Say ( JMM , D2-JMM-6 ) ;
3745: LD_EXP 17
3749: PPUSH
3750: LD_STRING D2-JMM-6
3752: PPUSH
3753: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-6 , you , sex_female , class_engineer , 0 ) ;
3757: LD_EXP 58
3761: PUSH
3762: LD_EXP 61
3766: DIFF
3767: PPUSH
3768: LD_STRING D2-FEng1-6
3770: PPUSH
3771: LD_EXP 47
3775: PPUSH
3776: LD_INT 2
3778: PPUSH
3779: LD_INT 2
3781: PPUSH
3782: LD_INT 0
3784: PPUSH
3785: CALL 13011 0 6
// SayAny ( lidi diff neco_rikaji , D2-Eng1-6 , you , sex_male , class_engineer , 0 ) ;
3789: LD_EXP 58
3793: PUSH
3794: LD_EXP 61
3798: DIFF
3799: PPUSH
3800: LD_STRING D2-Eng1-6
3802: PPUSH
3803: LD_EXP 47
3807: PPUSH
3808: LD_INT 1
3810: PPUSH
3811: LD_INT 2
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL 13011 0 6
// Say ( JMM , D2-JMM-7 ) ;
3821: LD_EXP 17
3825: PPUSH
3826: LD_STRING D2-JMM-7
3828: PPUSH
3829: CALL_OW 88
// Say ( Gary , D2-Gary-7 ) ;
3833: LD_EXP 22
3837: PPUSH
3838: LD_STRING D2-Gary-7
3840: PPUSH
3841: CALL_OW 88
// SayAny ( lidi diff neco_rikaji , D2-FEng1-7 , you , sex_female , class_engineer , 0 ) ;
3845: LD_EXP 58
3849: PUSH
3850: LD_EXP 61
3854: DIFF
3855: PPUSH
3856: LD_STRING D2-FEng1-7
3858: PPUSH
3859: LD_EXP 47
3863: PPUSH
3864: LD_INT 2
3866: PPUSH
3867: LD_INT 2
3869: PPUSH
3870: LD_INT 0
3872: PPUSH
3873: CALL 13011 0 6
// SayAny ( lidi diff neco_rikaji , D2-Sol1-7 , you , sex_male , class_soldier , 0 ) ;
3877: LD_EXP 58
3881: PUSH
3882: LD_EXP 61
3886: DIFF
3887: PPUSH
3888: LD_STRING D2-Sol1-7
3890: PPUSH
3891: LD_EXP 47
3895: PPUSH
3896: LD_INT 1
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: LD_INT 0
3904: PPUSH
3905: CALL 13011 0 6
// Say ( JMM , D2-JMM-8 ) ;
3909: LD_EXP 17
3913: PPUSH
3914: LD_STRING D2-JMM-8
3916: PPUSH
3917: CALL_OW 88
// dialog2byl := true ;
3921: LD_ADDR_EXP 65
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
3929: LD_STRING M1a
3931: PPUSH
3932: CALL_OW 337
// DialogueOff ;
3936: CALL_OW 7
// MyHint ( SibDet ) ;
3940: LD_STRING SibDet
3942: PPUSH
3943: CALL 14162 0 1
// end ;
3947: LD_VAR 0 1
3951: RET
// every 0 0$5 trigger GetSide ( rudepot1 ) = you and GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) do
3952: LD_EXP 67
3956: PPUSH
3957: CALL_OW 255
3961: PUSH
3962: LD_EXP 47
3966: EQUAL
3967: PUSH
3968: LD_EXP 67
3972: PPUSH
3973: CALL_OW 274
3977: PPUSH
3978: LD_INT 3
3980: PPUSH
3981: CALL_OW 275
3985: AND
3986: IFFALSE 4051
3988: GO 3990
3990: DISABLE
// begin case difficulty of 1 :
3991: LD_OWVAR 67
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4014
4004: POP
// ChangeMissionObjectives ( M2easy ) ; 2 :
4005: LD_STRING M2easy
4007: PPUSH
4008: CALL_OW 337
4012: GO 4051
4014: LD_INT 2
4016: DOUBLE
4017: EQUAL
4018: IFTRUE 4022
4020: GO 4032
4022: POP
// ChangeMissionObjectives ( M2 ) ; 3 :
4023: LD_STRING M2
4025: PPUSH
4026: CALL_OW 337
4030: GO 4051
4032: LD_INT 3
4034: DOUBLE
4035: EQUAL
4036: IFTRUE 4040
4038: GO 4050
4040: POP
// ChangeMissionObjectives ( M2hard ) ; end ;
4041: LD_STRING M2hard
4043: PPUSH
4044: CALL_OW 337
4048: GO 4051
4050: POP
// end ;
4051: END
// every 7 7$0 do
4052: GO 4054
4054: DISABLE
// begin DialogueOn ;
4055: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4059: LD_EXP 16
4063: PPUSH
4064: LD_STRING D3-Pow-1
4066: PPUSH
4067: CALL_OW 94
// if dialog2byl then
4071: LD_EXP 65
4075: IFFALSE 4091
// Say ( JMM , D3-JMM-1 ) else
4077: LD_EXP 17
4081: PPUSH
4082: LD_STRING D3-JMM-1
4084: PPUSH
4085: CALL_OW 88
4089: GO 4103
// Say ( JMM , D3-JMM-1a ) ;
4091: LD_EXP 17
4095: PPUSH
4096: LD_STRING D3-JMM-1a
4098: PPUSH
4099: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4103: LD_EXP 17
4107: PPUSH
4108: LD_STRING D3-JMM-1b
4110: PPUSH
4111: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4115: LD_EXP 16
4119: PPUSH
4120: LD_STRING D3-Pow-2
4122: PPUSH
4123: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
4127: LD_STRING M3
4129: PPUSH
4130: CALL_OW 337
// DialogueOff ;
4134: CALL_OW 7
// counter_time := 22 22$0 ;
4138: LD_ADDR_EXP 64
4142: PUSH
4143: LD_INT 46200
4145: ST_TO_ADDR
// end ;
4146: END
// every 22 22$0 do var qr , i , mt ;
4147: GO 4149
4149: DISABLE
4150: LD_INT 0
4152: PPUSH
4153: PPUSH
4154: PPUSH
// begin SetAttitude ( you , you2 , att_neutral , true ) ;
4155: LD_EXP 47
4159: PPUSH
4160: LD_EXP 48
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: LD_INT 1
4170: PPUSH
4171: CALL_OW 80
// ChangeSideFog ( you2 , you ) ;
4175: LD_EXP 48
4179: PPUSH
4180: LD_EXP 47
4184: PPUSH
4185: CALL_OW 343
// PlaceHumanInUnit ( Mec1 , Car1 ) ;
4189: LD_EXP 31
4193: PPUSH
4194: LD_EXP 34
4198: PPUSH
4199: CALL_OW 52
// PlaceHumanInUnit ( Mec2 , Car2 ) ;
4203: LD_EXP 32
4207: PPUSH
4208: LD_EXP 35
4212: PPUSH
4213: CALL_OW 52
// PlaceHumanInUnit ( Mec3 , Car3 ) ;
4217: LD_EXP 33
4221: PPUSH
4222: LD_EXP 36
4226: PPUSH
4227: CALL_OW 52
// if not PlaceUnitXYR ( Car1 , 35 , 1 , 10 , false ) then
4231: LD_EXP 34
4235: PPUSH
4236: LD_INT 35
4238: PPUSH
4239: LD_INT 1
4241: PPUSH
4242: LD_INT 10
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: CALL_OW 50
4252: NOT
4253: IFFALSE 4270
// PlaceUnitArea ( Car1 , odjezd , false ) ;
4255: LD_EXP 34
4259: PPUSH
4260: LD_INT 5
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 49
// if not PlaceUnitXYR ( Car2 , 35 , 1 , 10 , false ) then
4270: LD_EXP 35
4274: PPUSH
4275: LD_INT 35
4277: PPUSH
4278: LD_INT 1
4280: PPUSH
4281: LD_INT 10
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 50
4291: NOT
4292: IFFALSE 4309
// PlaceUnitArea ( Car2 , odjezd , false ) ;
4294: LD_EXP 35
4298: PPUSH
4299: LD_INT 5
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: CALL_OW 49
// if not PlaceUnitXYR ( Car3 , 35 , 1 , 10 , false ) then
4309: LD_EXP 36
4313: PPUSH
4314: LD_INT 35
4316: PPUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 10
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: CALL_OW 50
4330: NOT
4331: IFFALSE 4348
// PlaceUnitArea ( Car3 , odjezd , false ) ;
4333: LD_EXP 36
4337: PPUSH
4338: LD_INT 5
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 49
// ComMoveXY ( [ Car1 , Car2 , Car3 ] , 37 , 8 ) ;
4348: LD_EXP 34
4352: PUSH
4353: LD_EXP 35
4357: PUSH
4358: LD_EXP 36
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: PPUSH
4368: LD_INT 37
4370: PPUSH
4371: LD_INT 8
4373: PPUSH
4374: CALL_OW 111
// AddComStand ( [ Car1 , Car2 , Car3 ] ) ;
4378: LD_EXP 34
4382: PUSH
4383: LD_EXP 35
4387: PUSH
4388: LD_EXP 36
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: LIST
4397: PPUSH
4398: CALL_OW 225
// CenterNowOnUnits ( Car1 ) ;
4402: LD_EXP 34
4406: PPUSH
4407: CALL_OW 87
// Wait ( 0 0$3 ) ;
4411: LD_INT 105
4413: PPUSH
4414: CALL_OW 67
// DialogueOn ;
4418: CALL_OW 6
// Say ( Mec1 , D4-Mech1-1 ) ;
4422: LD_EXP 31
4426: PPUSH
4427: LD_STRING D4-Mech1-1
4429: PPUSH
4430: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4434: LD_EXP 17
4438: PPUSH
4439: LD_STRING D4-JMM-1
4441: PPUSH
4442: CALL_OW 88
// Say ( Mec1 , D4-Mech1-2 ) ;
4446: LD_EXP 31
4450: PPUSH
4451: LD_STRING D4-Mech1-2
4453: PPUSH
4454: CALL_OW 88
// AddResourceType ( GetBase ( Depot1 ) , mat_cans , 300 ) ;
4458: LD_EXP 69
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: LD_INT 300
4473: PPUSH
4474: CALL_OW 276
// qr := 0 ;
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// if KolikMaBytSiberitu > GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4486: LD_EXP 66
4490: PUSH
4491: LD_EXP 69
4495: PPUSH
4496: CALL_OW 274
4500: PPUSH
4501: LD_INT 3
4503: PPUSH
4504: CALL_OW 275
4508: GREATER
4509: IFFALSE 4601
// begin qr := Query ( QWait ) ;
4511: LD_ADDR_VAR 0 1
4515: PUSH
4516: LD_STRING QWait
4518: PPUSH
4519: CALL_OW 97
4523: ST_TO_ADDR
// case qr of 1 :
4524: LD_VAR 0 1
4528: PUSH
4529: LD_INT 1
4531: DOUBLE
4532: EQUAL
4533: IFTRUE 4537
4535: GO 4552
4537: POP
// Say ( JMM , D5a-JMM-1 ) ; 2 :
4538: LD_EXP 17
4542: PPUSH
4543: LD_STRING D5a-JMM-1
4545: PPUSH
4546: CALL_OW 88
4550: GO 4599
4552: LD_INT 2
4554: DOUBLE
4555: EQUAL
4556: IFTRUE 4560
4558: GO 4575
4560: POP
// Say ( JMM , D5b-JMM-1 ) ; 3 :
4561: LD_EXP 17
4565: PPUSH
4566: LD_STRING D5b-JMM-1
4568: PPUSH
4569: CALL_OW 88
4573: GO 4599
4575: LD_INT 3
4577: DOUBLE
4578: EQUAL
4579: IFTRUE 4583
4581: GO 4598
4583: POP
// Say ( JMM , D5c-JMM-1 ) ; end ;
4584: LD_EXP 17
4588: PPUSH
4589: LD_STRING D5c-JMM-1
4591: PPUSH
4592: CALL_OW 88
4596: GO 4599
4598: POP
// end else
4599: GO 4613
// Say ( JMM , D5-JMM-1 ) ;
4601: LD_EXP 17
4605: PPUSH
4606: LD_STRING D5-JMM-1
4608: PPUSH
4609: CALL_OW 88
// DialogueOff ;
4613: CALL_OW 7
// if qr = 1 then
4617: LD_VAR 0 1
4621: PUSH
4622: LD_INT 1
4624: EQUAL
4625: IFFALSE 4648
// begin counter_time := tick + 5 5$0 ;
4627: LD_ADDR_EXP 64
4631: PUSH
4632: LD_OWVAR 1
4636: PUSH
4637: LD_INT 10500
4639: PLUS
4640: ST_TO_ADDR
// Wait ( 5 5$0 ) ;
4641: LD_INT 10500
4643: PPUSH
4644: CALL_OW 67
// end ; if qr = 2 or qr = 3 then
4648: LD_VAR 0 1
4652: PUSH
4653: LD_INT 2
4655: EQUAL
4656: PUSH
4657: LD_VAR 0 1
4661: PUSH
4662: LD_INT 3
4664: EQUAL
4665: OR
4666: IFFALSE 4676
// NastvalPowella := true ;
4668: LD_ADDR_EXP 57
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// DialogueOn ;
4676: CALL_OW 6
// if KolikMaBytSiberitu <= GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4680: LD_EXP 66
4684: PUSH
4685: LD_EXP 69
4689: PPUSH
4690: CALL_OW 274
4694: PPUSH
4695: LD_INT 3
4697: PPUSH
4698: CALL_OW 275
4702: LESSEQUAL
4703: IFFALSE 4719
// Say ( Mec1 , D6-Mech1-1 ) else
4705: LD_EXP 31
4709: PPUSH
4710: LD_STRING D6-Mech1-1
4712: PPUSH
4713: CALL_OW 88
4717: GO 4776
// begin NastvalPowella := true ;
4719: LD_ADDR_EXP 57
4723: PUSH
4724: LD_INT 1
4726: ST_TO_ADDR
// if 0 < GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) then
4727: LD_INT 0
4729: PUSH
4730: LD_EXP 69
4734: PPUSH
4735: CALL_OW 274
4739: PPUSH
4740: LD_INT 3
4742: PPUSH
4743: CALL_OW 275
4747: LESS
4748: IFFALSE 4764
// Say ( Mec1 , D6-Mech1-1a ) else
4750: LD_EXP 31
4754: PPUSH
4755: LD_STRING D6-Mech1-1a
4757: PPUSH
4758: CALL_OW 88
4762: GO 4776
// Say ( Mec1 , D6-Mech1-1b ) ;
4764: LD_EXP 31
4768: PPUSH
4769: LD_STRING D6-Mech1-1b
4771: PPUSH
4772: CALL_OW 88
// end ; DialogueOff ;
4776: CALL_OW 7
// counter_time := 0 ;
4780: LD_ADDR_EXP 64
4784: PUSH
4785: LD_INT 0
4787: ST_TO_ADDR
// if GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > KolikMaBytSiberitu then
4788: LD_EXP 69
4792: PPUSH
4793: CALL_OW 274
4797: PPUSH
4798: LD_INT 3
4800: PPUSH
4801: CALL_OW 275
4805: PUSH
4806: LD_EXP 66
4810: GREATER
4811: IFFALSE 4858
// begin SetCargo ( [ Car1 ] , mat_siberit , KolikMaBytSiberitu ) ;
4813: LD_EXP 34
4817: PUSH
4818: EMPTY
4819: LIST
4820: PPUSH
4821: LD_INT 3
4823: PPUSH
4824: LD_EXP 66
4828: PPUSH
4829: CALL_OW 290
// AddResourceType ( GetBase ( Depot1 ) , mat_siberit , - KolikMaBytSiberitu ) ;
4833: LD_EXP 69
4837: PPUSH
4838: CALL_OW 274
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_EXP 66
4850: NEG
4851: PPUSH
4852: CALL_OW 276
// end else
4856: GO 4911
// begin SetCargo ( [ Car1 ] , mat_siberit , GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) ) ;
4858: LD_EXP 34
4862: PUSH
4863: EMPTY
4864: LIST
4865: PPUSH
4866: LD_INT 3
4868: PPUSH
4869: LD_EXP 69
4873: PPUSH
4874: CALL_OW 274
4878: PPUSH
4879: LD_INT 3
4881: PPUSH
4882: CALL_OW 275
4886: PPUSH
4887: CALL_OW 290
// SetResourceType ( GetBase ( Depot1 ) , mat_siberit , 0 ) ;
4891: LD_EXP 69
4895: PPUSH
4896: CALL_OW 274
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 0
4906: PPUSH
4907: CALL_OW 277
// end ; mt := tick + 0 0$20 ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_OWVAR 1
4920: PUSH
4921: LD_INT 700
4923: PLUS
4924: ST_TO_ADDR
// while UnitFilter ( [ Car1 , Car2 , Car3 ] , [ [ f_placed ] ] ) and mt < tick do
4925: LD_EXP 34
4929: PUSH
4930: LD_EXP 35
4934: PUSH
4935: LD_EXP 36
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: PPUSH
4945: LD_INT 52
4947: PUSH
4948: EMPTY
4949: LIST
4950: PUSH
4951: EMPTY
4952: LIST
4953: PPUSH
4954: CALL_OW 72
4958: PUSH
4959: LD_VAR 0 3
4963: PUSH
4964: LD_OWVAR 1
4968: LESS
4969: AND
4970: IFFALSE 5132
// begin ComMoveToArea ( [ Car1 , Car2 , Car3 ] , odjezd ) ;
4972: LD_EXP 34
4976: PUSH
4977: LD_EXP 35
4981: PUSH
4982: LD_EXP 36
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: PPUSH
4992: LD_INT 5
4994: PPUSH
4995: CALL_OW 113
// AddComMoveXY ( [ Car1 , Car2 , Car3 ] , 38 , 1 ) ;
4999: LD_EXP 34
5003: PUSH
5004: LD_EXP 35
5008: PUSH
5009: LD_EXP 36
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: PPUSH
5019: LD_INT 38
5021: PPUSH
5022: LD_INT 1
5024: PPUSH
5025: CALL_OW 171
// case true of IsInArea ( Car1 , odjezd ) :
5029: LD_INT 1
5031: PUSH
5032: LD_EXP 34
5036: PPUSH
5037: LD_INT 5
5039: PPUSH
5040: CALL_OW 308
5044: DOUBLE
5045: EQUAL
5046: IFTRUE 5050
5048: GO 5062
5050: POP
// RemoveUnit ( Car1 ) ; IsInArea ( Car2 , odjezd ) :
5051: LD_EXP 34
5055: PPUSH
5056: CALL_OW 64
5060: GO 5123
5062: LD_EXP 35
5066: PPUSH
5067: LD_INT 5
5069: PPUSH
5070: CALL_OW 308
5074: DOUBLE
5075: EQUAL
5076: IFTRUE 5080
5078: GO 5092
5080: POP
// RemoveUnit ( Car2 ) ; IsInArea ( Car3 , odjezd ) :
5081: LD_EXP 35
5085: PPUSH
5086: CALL_OW 64
5090: GO 5123
5092: LD_EXP 36
5096: PPUSH
5097: LD_INT 5
5099: PPUSH
5100: CALL_OW 308
5104: DOUBLE
5105: EQUAL
5106: IFTRUE 5110
5108: GO 5122
5110: POP
// RemoveUnit ( Car3 ) ; end ;
5111: LD_EXP 36
5115: PPUSH
5116: CALL_OW 64
5120: GO 5123
5122: POP
// wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// end ;
5130: GO 4925
// for i in [ Car1 , Car2 , Car3 , Mec1 , Mec2 , Mec3 ] do
5132: LD_ADDR_VAR 0 2
5136: PUSH
5137: LD_EXP 34
5141: PUSH
5142: LD_EXP 35
5146: PUSH
5147: LD_EXP 36
5151: PUSH
5152: LD_EXP 31
5156: PUSH
5157: LD_EXP 32
5161: PUSH
5162: LD_EXP 33
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: FOR_IN
5176: IFFALSE 5189
// RemoveUnit ( i ) ;
5178: LD_VAR 0 2
5182: PPUSH
5183: CALL_OW 64
5187: GO 5175
5189: POP
5190: POP
// if NastvalPowella then
5191: LD_EXP 57
5195: IFFALSE 5206
// ChangeMissionObjectives ( M3b ) else
5197: LD_STRING M3b
5199: PPUSH
5200: CALL_OW 337
5204: GO 5213
// ChangeMissionObjectives ( M3a ) ;
5206: LD_STRING M3a
5208: PPUSH
5209: CALL_OW 337
// end ;
5213: PPOPN 3
5215: END
// every 0 0$5 trigger GetResourceType ( GetBase ( Depot1 ) , mat_siberit ) > 35 do var r ;
5216: LD_EXP 69
5220: PPUSH
5221: CALL_OW 274
5225: PPUSH
5226: LD_INT 3
5228: PPUSH
5229: CALL_OW 275
5233: PUSH
5234: LD_INT 35
5236: GREATER
5237: IFFALSE 5408
5239: GO 5241
5241: DISABLE
5242: LD_INT 0
5244: PPUSH
// begin Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , class_scientistic , 0 ) ;
5245: LD_ADDR_EXP 25
5249: PUSH
5250: LD_EXP 58
5254: PUSH
5255: LD_EXP 61
5259: DIFF
5260: PPUSH
5261: LD_EXP 47
5265: PPUSH
5266: LD_INT 1
5268: PPUSH
5269: LD_INT 4
5271: PPUSH
5272: LD_INT 0
5274: PPUSH
5275: CALL 13091 0 5
5279: ST_TO_ADDR
// if not Sci1 then
5280: LD_EXP 25
5284: NOT
5285: IFFALSE 5322
// Sci1 := WhoSayAny ( lidi diff neco_rikaji , you , sex_male , 0 , 0 ) ;
5287: LD_ADDR_EXP 25
5291: PUSH
5292: LD_EXP 58
5296: PUSH
5297: LD_EXP 61
5301: DIFF
5302: PPUSH
5303: LD_EXP 47
5307: PPUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 0
5313: PPUSH
5314: LD_INT 0
5316: PPUSH
5317: CALL 13091 0 5
5321: ST_TO_ADDR
// if Sci1 then
5322: LD_EXP 25
5326: IFFALSE 5408
// begin DialogueOn ;
5328: CALL_OW 6
// Say ( Sci1 , D7-Sci1-1 ) ;
5332: LD_EXP 25
5336: PPUSH
5337: LD_STRING D7-Sci1-1
5339: PPUSH
5340: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
5344: LD_EXP 17
5348: PPUSH
5349: LD_STRING D7-JMM-1
5351: PPUSH
5352: CALL_OW 88
// Say ( Sci1 , D7-Sci1-2 ) ;
5356: LD_EXP 25
5360: PPUSH
5361: LD_STRING D7-Sci1-2
5363: PPUSH
5364: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
5368: LD_EXP 17
5372: PPUSH
5373: LD_STRING D7-JMM-2
5375: PPUSH
5376: CALL_OW 88
// Say ( Sci1 , D7-Sci1-3 ) ;
5380: LD_EXP 25
5384: PPUSH
5385: LD_STRING D7-Sci1-3
5387: PPUSH
5388: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
5392: LD_EXP 17
5396: PPUSH
5397: LD_STRING D7-JMM-3
5399: PPUSH
5400: CALL_OW 88
// DialogueOff ;
5404: CALL_OW 7
// end ; end ;
5408: PPOPN 1
5410: END
// export ArmStarted ; export BarStarted ; function odnes_jeden_oil ; var a ; begin
5411: LD_INT 0
5413: PPUSH
5414: PPUSH
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5415: LD_EXP 40
5419: PPUSH
5420: LD_EXP 67
5424: PPUSH
5425: CALL_OW 296
5429: PUSH
5430: LD_INT 4
5432: GREATER
5433: IFFALSE 5458
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5435: LD_EXP 40
5439: PPUSH
5440: LD_EXP 67
5444: PPUSH
5445: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5449: LD_INT 4
5451: PPUSH
5452: CALL_OW 67
// end ;
5456: GO 5415
// ComStop ( Ara2 ) ;
5458: LD_EXP 40
5462: PPUSH
5463: CALL_OW 141
// ComHold ( Ara2 ) ;
5467: LD_EXP 40
5471: PPUSH
5472: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5476: LD_EXP 40
5480: PPUSH
5481: LD_INT 2
5483: PPUSH
5484: LD_INT 10
5486: PPUSH
5487: CALL_OW 290
// a := GetFuel ( AraCar1 ) ;
5491: LD_ADDR_VAR 0 2
5495: PUSH
5496: LD_EXP 44
5500: PPUSH
5501: CALL_OW 261
5505: ST_TO_ADDR
// while GetFuel ( AraCar1 ) <= a do
5506: LD_EXP 44
5510: PPUSH
5511: CALL_OW 261
5515: PUSH
5516: LD_VAR 0 2
5520: LESSEQUAL
5521: IFFALSE 5546
// begin ComRefuel ( Ara2 , AraCar1 ) ;
5523: LD_EXP 40
5527: PPUSH
5528: LD_EXP 44
5532: PPUSH
5533: CALL_OW 150
// wait ( 0 0$1 ) ;
5537: LD_INT 35
5539: PPUSH
5540: CALL_OW 67
// end ;
5544: GO 5506
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5546: LD_EXP 40
5550: PPUSH
5551: LD_INT 2
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: CALL_OW 290
// while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5561: LD_EXP 40
5565: PPUSH
5566: LD_EXP 67
5570: PPUSH
5571: CALL_OW 296
5575: PUSH
5576: LD_INT 4
5578: GREATER
5579: IFFALSE 5604
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5581: LD_EXP 40
5585: PPUSH
5586: LD_EXP 67
5590: PPUSH
5591: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5595: LD_INT 4
5597: PPUSH
5598: CALL_OW 67
// end ;
5602: GO 5561
// ComStop ( Ara2 ) ;
5604: LD_EXP 40
5608: PPUSH
5609: CALL_OW 141
// ComHold ( Ara2 ) ;
5613: LD_EXP 40
5617: PPUSH
5618: CALL_OW 140
// SetCargo ( Ara2 , mat_oil , 10 ) ;
5622: LD_EXP 40
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 290
// a := GetFuel ( AraCar2 ) ;
5637: LD_ADDR_VAR 0 2
5641: PUSH
5642: LD_EXP 45
5646: PPUSH
5647: CALL_OW 261
5651: ST_TO_ADDR
// while GetFuel ( AraCar2 ) <= a do
5652: LD_EXP 45
5656: PPUSH
5657: CALL_OW 261
5661: PUSH
5662: LD_VAR 0 2
5666: LESSEQUAL
5667: IFFALSE 5692
// begin ComRefuel ( Ara2 , AraCar2 ) ;
5669: LD_EXP 40
5673: PPUSH
5674: LD_EXP 45
5678: PPUSH
5679: CALL_OW 150
// wait ( 0 0$1 ) ;
5683: LD_INT 35
5685: PPUSH
5686: CALL_OW 67
// end ;
5690: GO 5652
// SetCargo ( Ara2 , mat_oil , 0 ) ;
5692: LD_EXP 40
5696: PPUSH
5697: LD_INT 2
5699: PPUSH
5700: LD_INT 0
5702: PPUSH
5703: CALL_OW 290
// ComStop ( Ara2 ) ;
5707: LD_EXP 40
5711: PPUSH
5712: CALL_OW 141
// ComHold ( Ara2 ) ;
5716: LD_EXP 40
5720: PPUSH
5721: CALL_OW 140
// result := true ;
5725: LD_ADDR_VAR 0 1
5729: PUSH
5730: LD_INT 1
5732: ST_TO_ADDR
// end ;
5733: LD_VAR 0 1
5737: RET
// function odnes_neco ( mat , kolik ) ; var a , i ; begin
5738: LD_INT 0
5740: PPUSH
5741: PPUSH
5742: PPUSH
// for i := 1 to ( kolik div 10 ) do
5743: LD_ADDR_VAR 0 5
5747: PUSH
5748: DOUBLE
5749: LD_INT 1
5751: DEC
5752: ST_TO_ADDR
5753: LD_VAR 0 2
5757: PUSH
5758: LD_INT 10
5760: DIV
5761: PUSH
5762: FOR_TO
5763: IFFALSE 5936
// begin while GetDistUnits ( Ara2 , rudepot1 ) > 4 do
5765: LD_EXP 40
5769: PPUSH
5770: LD_EXP 67
5774: PPUSH
5775: CALL_OW 296
5779: PUSH
5780: LD_INT 4
5782: GREATER
5783: IFFALSE 5808
// begin ComMoveUnit ( Ara2 , rudepot1 ) ;
5785: LD_EXP 40
5789: PPUSH
5790: LD_EXP 67
5794: PPUSH
5795: CALL_OW 112
// wait ( 0 0$0.1 ) ;
5799: LD_INT 4
5801: PPUSH
5802: CALL_OW 67
// end ;
5806: GO 5765
// ComHold ( Ara2 ) ;
5808: LD_EXP 40
5812: PPUSH
5813: CALL_OW 140
// SetCargo ( Ara2 , mat , 10 ) ;
5817: LD_EXP 40
5821: PPUSH
5822: LD_VAR 0 1
5826: PPUSH
5827: LD_INT 10
5829: PPUSH
5830: CALL_OW 290
// a := GetCargo ( AraCar2 , mat ) ;
5834: LD_ADDR_VAR 0 4
5838: PUSH
5839: LD_EXP 45
5843: PPUSH
5844: LD_VAR 0 1
5848: PPUSH
5849: CALL_OW 289
5853: ST_TO_ADDR
// while GetCargo ( AraCar2 , mat ) <= a do
5854: LD_EXP 45
5858: PPUSH
5859: LD_VAR 0 1
5863: PPUSH
5864: CALL_OW 289
5868: PUSH
5869: LD_VAR 0 4
5873: LESSEQUAL
5874: IFFALSE 5899
// begin ComMoveUnit ( Ara2 , AraCar2 ) ;
5876: LD_EXP 40
5880: PPUSH
5881: LD_EXP 45
5885: PPUSH
5886: CALL_OW 112
// wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// end ;
5897: GO 5854
// SetCargo ( Ara2 , mat , 0 ) ;
5899: LD_EXP 40
5903: PPUSH
5904: LD_VAR 0 1
5908: PPUSH
5909: LD_INT 0
5911: PPUSH
5912: CALL_OW 290
// ComStop ( Ara2 ) ;
5916: LD_EXP 40
5920: PPUSH
5921: CALL_OW 141
// ComHold ( Ara2 ) ;
5925: LD_EXP 40
5929: PPUSH
5930: CALL_OW 140
// end ;
5934: GO 5762
5936: POP
5937: POP
// result := true ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 1
5945: ST_TO_ADDR
// end ;
5946: LD_VAR 0 3
5950: RET
// every 0 0$1 do var mt ;
5951: GO 5953
5953: DISABLE
5954: LD_INT 0
5956: PPUSH
// begin if arabi_time <> 0 then
5957: LD_EXP 1
5961: PUSH
5962: LD_INT 0
5964: NONEQUAL
5965: IFFALSE 6113
// if arabi_time > 1 then
5967: LD_EXP 1
5971: PUSH
5972: LD_INT 1
5974: GREATER
5975: IFFALSE 6113
// begin wait ( arabi_time ) ;
5977: LD_EXP 1
5981: PPUSH
5982: CALL_OW 67
// mt := tick + 3 3$0 ;
5986: LD_ADDR_VAR 0 1
5990: PUSH
5991: LD_OWVAR 1
5995: PUSH
5996: LD_INT 6300
5998: PLUS
5999: ST_TO_ADDR
// while Getside ( rudepot1 ) <> you and mt > tick do
6000: LD_EXP 67
6004: PPUSH
6005: CALL_OW 255
6009: PUSH
6010: LD_EXP 47
6014: NONEQUAL
6015: PUSH
6016: LD_VAR 0 1
6020: PUSH
6021: LD_OWVAR 1
6025: GREATER
6026: AND
6027: IFFALSE 6038
// wait ( 0 0$3 ) ;
6029: LD_INT 105
6031: PPUSH
6032: CALL_OW 67
6036: GO 6000
// if Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 then
6038: LD_EXP 67
6042: PPUSH
6043: CALL_OW 255
6047: PUSH
6048: LD_EXP 47
6052: EQUAL
6053: PUSH
6054: LD_INT 22
6056: PUSH
6057: LD_EXP 47
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 2
6068: PUSH
6069: LD_INT 21
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 21
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PPUSH
6098: CALL_OW 69
6102: PUSH
6103: LD_INT 0
6105: GREATER
6106: AND
6107: IFFALSE 6113
// arabi ;
6109: CALL 6205 0 0
// end ; end ;
6113: PPOPN 1
6115: END
// every 27 27$0 trigger arabi_time = 0 and Getside ( rudepot1 ) = you and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do
6116: LD_EXP 1
6120: PUSH
6121: LD_INT 0
6123: EQUAL
6124: PUSH
6125: LD_EXP 67
6129: PPUSH
6130: CALL_OW 255
6134: PUSH
6135: LD_EXP 47
6139: EQUAL
6140: AND
6141: PUSH
6142: LD_INT 22
6144: PUSH
6145: LD_EXP 47
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 21
6159: PUSH
6160: LD_INT 1
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_INT 21
6169: PUSH
6170: LD_INT 2
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PPUSH
6186: CALL_OW 69
6190: PUSH
6191: LD_INT 0
6193: GREATER
6194: AND
6195: IFFALSE 6204
6197: GO 6199
6199: DISABLE
// begin arabi ;
6200: CALL 6205 0 0
// end ;
6204: END
// export kecy , mina1 , mina3 ; function arabi ; var cekani , qr , nabidka , i , a , mytick , to_reach , ara1_faze , ara3_faze , odmitl_v_query ; begin
6205: LD_INT 0
6207: PPUSH
6208: PPUSH
6209: PPUSH
6210: PPUSH
6211: PPUSH
6212: PPUSH
6213: PPUSH
6214: PPUSH
6215: PPUSH
6216: PPUSH
6217: PPUSH
// PlaceUnitArea ( Ara1 , rus_mat_l , false ) ;
6218: LD_EXP 39
6222: PPUSH
6223: LD_INT 3
6225: PPUSH
6226: LD_INT 0
6228: PPUSH
6229: CALL_OW 49
// PlaceUnitArea ( Ara2 , rus_mat_l , false ) ;
6233: LD_EXP 40
6237: PPUSH
6238: LD_INT 3
6240: PPUSH
6241: LD_INT 0
6243: PPUSH
6244: CALL_OW 49
// PlaceUnitArea ( Ara3 , rus_mat_l , false ) ;
6248: LD_EXP 41
6252: PPUSH
6253: LD_INT 3
6255: PPUSH
6256: LD_INT 0
6258: PPUSH
6259: CALL_OW 49
// PlaceUnitArea ( AraCar1 , rus_mat_l , false ) ;
6263: LD_EXP 44
6267: PPUSH
6268: LD_INT 3
6270: PPUSH
6271: LD_INT 0
6273: PPUSH
6274: CALL_OW 49
// PlaceUnitArea ( AraCar2 , rus_mat_l , false ) ;
6278: LD_EXP 45
6282: PPUSH
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 0
6288: PPUSH
6289: CALL_OW 49
// ComHold ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] ) ;
6293: LD_EXP 39
6297: PUSH
6298: LD_EXP 40
6302: PUSH
6303: LD_EXP 41
6307: PUSH
6308: LD_EXP 42
6312: PUSH
6313: LD_EXP 43
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 140
// DialogueOn ;
6329: CALL_OW 6
// SayRadio ( Ara1 , D8-Ar1-1 ) ;
6333: LD_EXP 39
6337: PPUSH
6338: LD_STRING D8-Ar1-1
6340: PPUSH
6341: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6345: LD_EXP 17
6349: PPUSH
6350: LD_STRING D8-JMM-1
6352: PPUSH
6353: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-2 ) ;
6357: LD_EXP 39
6361: PPUSH
6362: LD_STRING D8-Ar1-2
6364: PPUSH
6365: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6369: LD_EXP 17
6373: PPUSH
6374: LD_STRING D8-JMM-2
6376: PPUSH
6377: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-3 ) ;
6381: LD_EXP 39
6385: PPUSH
6386: LD_STRING D8-Ar1-3
6388: PPUSH
6389: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6393: LD_EXP 17
6397: PPUSH
6398: LD_STRING D8-JMM-3
6400: PPUSH
6401: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-4 ) ;
6405: LD_EXP 39
6409: PPUSH
6410: LD_STRING D8-Ar1-4
6412: PPUSH
6413: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6417: LD_EXP 17
6421: PPUSH
6422: LD_STRING D8-JMM-4
6424: PPUSH
6425: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-5 ) ;
6429: LD_EXP 39
6433: PPUSH
6434: LD_STRING D8-Ar1-5
6436: PPUSH
6437: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6441: LD_EXP 17
6445: PPUSH
6446: LD_STRING D8-JMM-5
6448: PPUSH
6449: CALL_OW 88
// SayRadio ( Ara1 , D8-Ar1-6 ) ;
6453: LD_EXP 39
6457: PPUSH
6458: LD_STRING D8-Ar1-6
6460: PPUSH
6461: CALL_OW 94
// SayRadio ( Ara2 , D8-Ar2-6 ) ;
6465: LD_EXP 40
6469: PPUSH
6470: LD_STRING D8-Ar2-6
6472: PPUSH
6473: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6477: LD_EXP 17
6481: PPUSH
6482: LD_STRING D8-JMM-6
6484: PPUSH
6485: CALL_OW 88
// SayRadio ( Ara2 , D8-Ar2-7 ) ;
6489: LD_EXP 40
6493: PPUSH
6494: LD_STRING D8-Ar2-7
6496: PPUSH
6497: CALL_OW 94
// Aqr1 := Query ( QBarracks ) ;
6501: LD_ADDR_EXP 37
6505: PUSH
6506: LD_STRING QBarracks
6508: PPUSH
6509: CALL_OW 97
6513: ST_TO_ADDR
// case Aqr1 of 1 :
6514: LD_EXP 37
6518: PUSH
6519: LD_INT 1
6521: DOUBLE
6522: EQUAL
6523: IFTRUE 6527
6525: GO 6554
6527: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6528: LD_EXP 17
6532: PPUSH
6533: LD_STRING D8a-JMM-1
6535: PPUSH
6536: CALL_OW 88
// SayRadio ( Ara1 , D8a-Ar1-1 ) ;
6540: LD_EXP 39
6544: PPUSH
6545: LD_STRING D8a-Ar1-1
6547: PPUSH
6548: CALL_OW 94
// end ; 2 :
6552: GO 6730
6554: LD_INT 2
6556: DOUBLE
6557: EQUAL
6558: IFTRUE 6562
6560: GO 6686
6562: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6563: LD_EXP 17
6567: PPUSH
6568: LD_STRING D8b-JMM-1
6570: PPUSH
6571: CALL_OW 88
// SayRadio ( Ara1 , D8b-Ar1-1 ) ;
6575: LD_EXP 39
6579: PPUSH
6580: LD_STRING D8b-Ar1-1
6582: PPUSH
6583: CALL_OW 94
// Aqr2 := Query ( QInfo ) ;
6587: LD_ADDR_EXP 38
6591: PUSH
6592: LD_STRING QInfo
6594: PPUSH
6595: CALL_OW 97
6599: ST_TO_ADDR
// case Aqr2 of 1 :
6600: LD_EXP 38
6604: PUSH
6605: LD_INT 1
6607: DOUBLE
6608: EQUAL
6609: IFTRUE 6613
6611: GO 6640
6613: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6614: LD_EXP 17
6618: PPUSH
6619: LD_STRING D8b1-JMM-1
6621: PPUSH
6622: CALL_OW 88
// SayRadio ( Ara1 , D8b1-Ar1-1 ) ;
6626: LD_EXP 39
6630: PPUSH
6631: LD_STRING D8b1-Ar1-1
6633: PPUSH
6634: CALL_OW 94
// end ; 2 :
6638: GO 6684
6640: LD_INT 2
6642: DOUBLE
6643: EQUAL
6644: IFTRUE 6648
6646: GO 6683
6648: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6649: LD_EXP 17
6653: PPUSH
6654: LD_STRING D8b2-JMM-1
6656: PPUSH
6657: CALL_OW 88
// SayRadio ( Ara1 , D8b2-Ar1-1 ) ;
6661: LD_EXP 39
6665: PPUSH
6666: LD_STRING D8b2-Ar1-1
6668: PPUSH
6669: CALL_OW 94
// odmitl_v_query := true ;
6673: LD_ADDR_VAR 0 11
6677: PUSH
6678: LD_INT 1
6680: ST_TO_ADDR
// end ; end ;
6681: GO 6684
6683: POP
// end ; 3 :
6684: GO 6730
6686: LD_INT 3
6688: DOUBLE
6689: EQUAL
6690: IFTRUE 6694
6692: GO 6729
6694: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6695: LD_EXP 17
6699: PPUSH
6700: LD_STRING D8c-JMM-1
6702: PPUSH
6703: CALL_OW 88
// odmitl_v_query := true ;
6707: LD_ADDR_VAR 0 11
6711: PUSH
6712: LD_INT 1
6714: ST_TO_ADDR
// SayRadio ( Ara1 , D8c-Ar1-1 ) ;
6715: LD_EXP 39
6719: PPUSH
6720: LD_STRING D8c-Ar1-1
6722: PPUSH
6723: CALL_OW 94
// end ; end ;
6727: GO 6730
6729: POP
// DialogueOff ;
6730: CALL_OW 7
// if Aqr1 = 1 or ( Aqr1 = 2 and Aqr2 = 1 ) then
6734: LD_EXP 37
6738: PUSH
6739: LD_INT 1
6741: EQUAL
6742: PUSH
6743: LD_EXP 37
6747: PUSH
6748: LD_INT 2
6750: EQUAL
6751: PUSH
6752: LD_EXP 38
6756: PUSH
6757: LD_INT 1
6759: EQUAL
6760: AND
6761: OR
6762: IFFALSE 9495
// begin ComMoveToArea ( AraCar1 , pod_base ) ;
6764: LD_EXP 44
6768: PPUSH
6769: LD_INT 30
6771: PPUSH
6772: CALL_OW 113
// wait ( 0 0$1 ) ;
6776: LD_INT 35
6778: PPUSH
6779: CALL_OW 67
// ComMoveToArea ( AraCar2 , pod_base ) ;
6783: LD_EXP 45
6787: PPUSH
6788: LD_INT 30
6790: PPUSH
6791: CALL_OW 113
// ComWait ( [ Ara1 , Ara2 , Ara3 ] , 0 0$4 ) ;
6795: LD_EXP 39
6799: PUSH
6800: LD_EXP 40
6804: PUSH
6805: LD_EXP 41
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PPUSH
6815: LD_INT 140
6817: PPUSH
6818: CALL_OW 142
// AddComMoveToArea ( [ Ara1 , Ara2 , Ara3 ] , in_base ) ;
6822: LD_EXP 39
6826: PUSH
6827: LD_EXP 40
6831: PUSH
6832: LD_EXP 41
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: LIST
6841: PPUSH
6842: LD_INT 21
6844: PPUSH
6845: CALL_OW 173
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 ] , 95 , 98 ) ;
6849: LD_EXP 39
6853: PUSH
6854: LD_EXP 40
6858: PUSH
6859: LD_EXP 41
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: LIST
6868: PPUSH
6869: LD_INT 95
6871: PPUSH
6872: LD_INT 98
6874: PPUSH
6875: CALL_OW 171
// AddComMoveToArea ( [ Ara1 , Ara3 ] , for_charge ) ;
6879: LD_EXP 39
6883: PUSH
6884: LD_EXP 41
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PPUSH
6893: LD_INT 29
6895: PPUSH
6896: CALL_OW 173
// AddComPlaceRemoteCharge ( Ara1 , 0 , 0 , rudepot1 ) ;
6900: LD_EXP 39
6904: PPUSH
6905: LD_INT 0
6907: PPUSH
6908: LD_INT 0
6910: PPUSH
6911: LD_EXP 67
6915: PPUSH
6916: CALL_OW 193
// AddComPlaceRemoteCharge ( Ara3 , 0 , 0 , rudepot1 ) ;
6920: LD_EXP 41
6924: PPUSH
6925: LD_INT 0
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: LD_EXP 67
6935: PPUSH
6936: CALL_OW 193
// AddComMoveToArea ( [ Ara1 , Ara3 ] , pod_base ) ;
6940: LD_EXP 39
6944: PUSH
6945: LD_EXP 41
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: PPUSH
6954: LD_INT 30
6956: PPUSH
6957: CALL_OW 173
// mytick := tick + 2 2$30 ;
6961: LD_ADDR_VAR 0 7
6965: PUSH
6966: LD_OWVAR 1
6970: PUSH
6971: LD_INT 5250
6973: PLUS
6974: ST_TO_ADDR
// to_reach := [ AraCar1 , AraCar2 , Ara3 , Ara2 , Ara1 ] ;
6975: LD_ADDR_VAR 0 8
6979: PUSH
6980: LD_EXP 44
6984: PUSH
6985: LD_EXP 45
6989: PUSH
6990: LD_EXP 41
6994: PUSH
6995: LD_EXP 40
6999: PUSH
7000: LD_EXP 39
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: LIST
7009: LIST
7010: LIST
7011: ST_TO_ADDR
// while mytick > tick and to_reach do
7012: LD_VAR 0 7
7016: PUSH
7017: LD_OWVAR 1
7021: GREATER
7022: PUSH
7023: LD_VAR 0 8
7027: AND
7028: IFFALSE 7288
// begin if IsInArea ( AraCar1 , pod_base ) or not IsOk ( AraCar1 ) then
7030: LD_EXP 44
7034: PPUSH
7035: LD_INT 30
7037: PPUSH
7038: CALL_OW 308
7042: PUSH
7043: LD_EXP 44
7047: PPUSH
7048: CALL_OW 302
7052: NOT
7053: OR
7054: IFFALSE 7075
// to_reach := to_reach diff [ AraCar1 ] ;
7056: LD_ADDR_VAR 0 8
7060: PUSH
7061: LD_VAR 0 8
7065: PUSH
7066: LD_EXP 44
7070: PUSH
7071: EMPTY
7072: LIST
7073: DIFF
7074: ST_TO_ADDR
// if IsInArea ( AraCar2 , pod_base ) or not IsOk ( AraCar2 ) then
7075: LD_EXP 45
7079: PPUSH
7080: LD_INT 30
7082: PPUSH
7083: CALL_OW 308
7087: PUSH
7088: LD_EXP 45
7092: PPUSH
7093: CALL_OW 302
7097: NOT
7098: OR
7099: IFFALSE 7120
// to_reach := to_reach diff [ AraCar2 ] ;
7101: LD_ADDR_VAR 0 8
7105: PUSH
7106: LD_VAR 0 8
7110: PUSH
7111: LD_EXP 45
7115: PUSH
7116: EMPTY
7117: LIST
7118: DIFF
7119: ST_TO_ADDR
// if IsInArea ( Ara1 , in_base ) or not IsOk ( Ara1 ) then
7120: LD_EXP 39
7124: PPUSH
7125: LD_INT 21
7127: PPUSH
7128: CALL_OW 308
7132: PUSH
7133: LD_EXP 39
7137: PPUSH
7138: CALL_OW 302
7142: NOT
7143: OR
7144: IFFALSE 7165
// to_reach := to_reach diff [ Ara1 ] ;
7146: LD_ADDR_VAR 0 8
7150: PUSH
7151: LD_VAR 0 8
7155: PUSH
7156: LD_EXP 39
7160: PUSH
7161: EMPTY
7162: LIST
7163: DIFF
7164: ST_TO_ADDR
// if IsInArea ( Ara2 , in_base ) or not IsOk ( Ara2 ) then
7165: LD_EXP 40
7169: PPUSH
7170: LD_INT 21
7172: PPUSH
7173: CALL_OW 308
7177: PUSH
7178: LD_EXP 40
7182: PPUSH
7183: CALL_OW 302
7187: NOT
7188: OR
7189: IFFALSE 7210
// to_reach := to_reach diff [ Ara2 ] ;
7191: LD_ADDR_VAR 0 8
7195: PUSH
7196: LD_VAR 0 8
7200: PUSH
7201: LD_EXP 40
7205: PUSH
7206: EMPTY
7207: LIST
7208: DIFF
7209: ST_TO_ADDR
// if IsInArea ( Ara3 , in_base ) or not IsOk ( Ara3 ) then
7210: LD_EXP 41
7214: PPUSH
7215: LD_INT 21
7217: PPUSH
7218: CALL_OW 308
7222: PUSH
7223: LD_EXP 41
7227: PPUSH
7228: CALL_OW 302
7232: NOT
7233: OR
7234: IFFALSE 7255
// to_reach := to_reach diff [ Ara3 ] ;
7236: LD_ADDR_VAR 0 8
7240: PUSH
7241: LD_VAR 0 8
7245: PUSH
7246: LD_EXP 41
7250: PUSH
7251: EMPTY
7252: LIST
7253: DIFF
7254: ST_TO_ADDR
// ComMoveToArea ( AraCar1 , pod_base ) ;
7255: LD_EXP 44
7259: PPUSH
7260: LD_INT 30
7262: PPUSH
7263: CALL_OW 113
// ComMoveToArea ( AraCar2 , pod_base ) ;
7267: LD_EXP 45
7271: PPUSH
7272: LD_INT 30
7274: PPUSH
7275: CALL_OW 113
// wait ( 0 0$1 ) ;
7279: LD_INT 35
7281: PPUSH
7282: CALL_OW 67
// end ;
7286: GO 7012
// if Aqr1 = 1 then
7288: LD_EXP 37
7292: PUSH
7293: LD_INT 1
7295: EQUAL
7296: IFFALSE 7561
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7298: LD_EXP 67
7302: PPUSH
7303: CALL_OW 274
7307: PPUSH
7308: LD_INT 2
7310: PPUSH
7311: CALL_OW 275
7315: PUSH
7316: LD_INT 60
7318: LESS
7319: IFFALSE 7524
// begin DialogueOn ;
7321: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7325: LD_EXP 41
7329: PPUSH
7330: LD_STRING D9a-FAr1-1
7332: PPUSH
7333: CALL_OW 88
7337: IFFALSE 7351
// Say ( JMM , D9a-JMM-1 ) ;
7339: LD_EXP 17
7343: PPUSH
7344: LD_STRING D9a-JMM-1
7346: PPUSH
7347: CALL_OW 88
// DialogueOff ;
7351: CALL_OW 7
// cekani := 0 ;
7355: LD_ADDR_VAR 0 2
7359: PUSH
7360: LD_INT 0
7362: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 do
7363: LD_VAR 0 2
7367: PUSH
7368: LD_INT 60
7370: LESS
7371: PUSH
7372: LD_EXP 67
7376: PPUSH
7377: CALL_OW 274
7381: PPUSH
7382: LD_INT 2
7384: PPUSH
7385: CALL_OW 275
7389: PUSH
7390: LD_INT 60
7392: LESS
7393: AND
7394: IFFALSE 7419
// begin Wait ( 0 0$1 ) ;
7396: LD_INT 35
7398: PPUSH
7399: CALL_OW 67
// cekani := cekani + 1 ;
7403: LD_ADDR_VAR 0 2
7407: PUSH
7408: LD_VAR 0 2
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: ST_TO_ADDR
// end ;
7417: GO 7363
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 60 then
7419: LD_EXP 67
7423: PPUSH
7424: CALL_OW 274
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: CALL_OW 275
7436: PUSH
7437: LD_INT 60
7439: LESS
7440: IFFALSE 7485
// begin DialogueOn ;
7442: CALL_OW 6
// Say ( Ara1 , D9a2-Ar1-1 ) ;
7446: LD_EXP 39
7450: PPUSH
7451: LD_STRING D9a2-Ar1-1
7453: PPUSH
7454: CALL_OW 88
// DialogueOff ;
7458: CALL_OW 7
// Aqr1 := 2 ;
7462: LD_ADDR_EXP 37
7466: PUSH
7467: LD_INT 2
7469: ST_TO_ADDR
// Aqr2 := Query ( QInfo ) ;
7470: LD_ADDR_EXP 38
7474: PUSH
7475: LD_STRING QInfo
7477: PPUSH
7478: CALL_OW 97
7482: ST_TO_ADDR
// end else
7483: GO 7522
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7485: LD_EXP 67
7489: PPUSH
7490: CALL_OW 274
7494: PPUSH
7495: LD_INT 2
7497: PPUSH
7498: LD_INT 60
7500: NEG
7501: PPUSH
7502: CALL_OW 276
// if odnes_jeden_oil then
7506: CALL 5411 0 0
7510: IFFALSE 7522
// if odnes_jeden_oil then
7512: CALL 5411 0 0
7516: IFFALSE 7522
// odnes_jeden_oil ;
7518: CALL 5411 0 0
// end ; end else
7522: GO 7561
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 60 ) ;
7524: LD_EXP 67
7528: PPUSH
7529: CALL_OW 274
7533: PPUSH
7534: LD_INT 2
7536: PPUSH
7537: LD_INT 60
7539: NEG
7540: PPUSH
7541: CALL_OW 276
// if odnes_jeden_oil then
7545: CALL 5411 0 0
7549: IFFALSE 7561
// if odnes_jeden_oil then
7551: CALL 5411 0 0
7555: IFFALSE 7561
// odnes_jeden_oil ;
7557: CALL 5411 0 0
// end ; end ; if ( Aqr1 = 2 ) and ( Aqr2 = 1 ) then
7561: LD_EXP 37
7565: PUSH
7566: LD_INT 2
7568: EQUAL
7569: PUSH
7570: LD_EXP 38
7574: PUSH
7575: LD_INT 1
7577: EQUAL
7578: AND
7579: IFFALSE 7831
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7581: LD_EXP 67
7585: PPUSH
7586: CALL_OW 274
7590: PPUSH
7591: LD_INT 2
7593: PPUSH
7594: CALL_OW 275
7598: PUSH
7599: LD_INT 20
7601: LESS
7602: IFFALSE 7798
// begin DialogueOn ;
7604: CALL_OW 6
// if Say ( Ara3 , D9a-FAr1-1 ) then
7608: LD_EXP 41
7612: PPUSH
7613: LD_STRING D9a-FAr1-1
7615: PPUSH
7616: CALL_OW 88
7620: IFFALSE 7634
// Say ( JMM , D9a-JMM-1 ) ;
7622: LD_EXP 17
7626: PPUSH
7627: LD_STRING D9a-JMM-1
7629: PPUSH
7630: CALL_OW 88
// DialogueOff ;
7634: CALL_OW 7
// cekani := 0 ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 0
7645: ST_TO_ADDR
// while cekani < 60 and GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 do
7646: LD_VAR 0 2
7650: PUSH
7651: LD_INT 60
7653: LESS
7654: PUSH
7655: LD_EXP 67
7659: PPUSH
7660: CALL_OW 274
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: CALL_OW 275
7672: PUSH
7673: LD_INT 20
7675: LESS
7676: AND
7677: IFFALSE 7702
// begin Wait ( 0 0$1 ) ;
7679: LD_INT 35
7681: PPUSH
7682: CALL_OW 67
// cekani := cekani + 1 ;
7686: LD_ADDR_VAR 0 2
7690: PUSH
7691: LD_VAR 0 2
7695: PUSH
7696: LD_INT 1
7698: PLUS
7699: ST_TO_ADDR
// end ;
7700: GO 7646
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) < 20 then
7702: LD_EXP 67
7706: PPUSH
7707: CALL_OW 274
7711: PPUSH
7712: LD_INT 2
7714: PPUSH
7715: CALL_OW 275
7719: PUSH
7720: LD_INT 20
7722: LESS
7723: IFFALSE 7763
// begin DialogueOn ;
7725: CALL_OW 6
// Say ( Ara1 , D9a3-Ar1-1 ) ;
7729: LD_EXP 39
7733: PPUSH
7734: LD_STRING D9a3-Ar1-1
7736: PPUSH
7737: CALL_OW 88
// DialogueOff ;
7741: CALL_OW 7
// Aqr1 := 2 ;
7745: LD_ADDR_EXP 37
7749: PUSH
7750: LD_INT 2
7752: ST_TO_ADDR
// Aqr2 := 0 ;
7753: LD_ADDR_EXP 38
7757: PUSH
7758: LD_INT 0
7760: ST_TO_ADDR
// end else
7761: GO 7796
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7763: LD_EXP 67
7767: PPUSH
7768: CALL_OW 274
7772: PPUSH
7773: LD_INT 2
7775: PPUSH
7776: LD_INT 20
7778: NEG
7779: PPUSH
7780: CALL_OW 276
// odnes_jeden_oil ;
7784: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7788: LD_ADDR_EXP 56
7792: PUSH
7793: LD_INT 1
7795: ST_TO_ADDR
// end ; end else
7796: GO 7831
// begin AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 20 ) ;
7798: LD_EXP 67
7802: PPUSH
7803: CALL_OW 274
7807: PPUSH
7808: LD_INT 2
7810: PPUSH
7811: LD_INT 20
7813: NEG
7814: PPUSH
7815: CALL_OW 276
// odnes_jeden_oil ;
7819: CALL 5411 0 0
// PoskytnouInformace := 1 ;
7823: LD_ADDR_EXP 56
7827: PUSH
7828: LD_INT 1
7830: ST_TO_ADDR
// end ; end ; if Aqr1 = 1 then
7831: LD_EXP 37
7835: PUSH
7836: LD_INT 1
7838: EQUAL
7839: IFFALSE 9219
// begin if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
7841: LD_EXP 67
7845: PPUSH
7846: CALL_OW 274
7850: PPUSH
7851: LD_INT 1
7853: PPUSH
7854: CALL_OW 275
7858: PUSH
7859: LD_INT 25
7861: LESS
7862: IFFALSE 7898
// begin DialogueOn ;
7864: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1 ) then
7868: LD_EXP 40
7872: PPUSH
7873: LD_STRING D9b-Ar2-1
7875: PPUSH
7876: CALL_OW 88
7880: IFFALSE 7894
// Say ( JMM , D9b-JMM-1 ) ;
7882: LD_EXP 17
7886: PPUSH
7887: LD_STRING D9b-JMM-1
7889: PPUSH
7890: CALL_OW 88
// DialogueOff ;
7894: CALL_OW 7
// end ; cekani := 0 ;
7898: LD_ADDR_VAR 0 2
7902: PUSH
7903: LD_INT 0
7905: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
7906: LD_VAR 0 2
7910: PUSH
7911: LD_INT 120
7913: LESS
7914: PUSH
7915: LD_EXP 67
7919: PPUSH
7920: CALL_OW 274
7924: PPUSH
7925: LD_INT 1
7927: PPUSH
7928: CALL_OW 275
7932: PUSH
7933: LD_INT 25
7935: LESS
7936: AND
7937: IFFALSE 7962
// begin Wait ( 0 0$1 ) ;
7939: LD_INT 35
7941: PPUSH
7942: CALL_OW 67
// cekani := cekani + 1 ;
7946: LD_ADDR_VAR 0 2
7950: PUSH
7951: LD_VAR 0 2
7955: PUSH
7956: LD_INT 1
7958: PLUS
7959: ST_TO_ADDR
// end ;
7960: GO 7906
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
7962: LD_EXP 67
7966: PPUSH
7967: CALL_OW 274
7971: PPUSH
7972: LD_INT 1
7974: PPUSH
7975: CALL_OW 275
7979: PUSH
7980: LD_INT 25
7982: GREATEREQUAL
7983: IFFALSE 9114
// begin ComMoveXY ( Ara2 , 94 , 101 ) ;
7985: LD_EXP 40
7989: PPUSH
7990: LD_INT 94
7992: PPUSH
7993: LD_INT 101
7995: PPUSH
7996: CALL_OW 111
// while not UnitFilter ( [ Ara2 ] , [ [ f_distxy , 94 , 101 , 2 ] ] ) do
8000: LD_EXP 40
8004: PUSH
8005: EMPTY
8006: LIST
8007: PPUSH
8008: LD_INT 92
8010: PUSH
8011: LD_INT 94
8013: PUSH
8014: LD_INT 101
8016: PUSH
8017: LD_INT 2
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: PPUSH
8029: CALL_OW 72
8033: NOT
8034: IFFALSE 8045
// wait ( 0 0$0.3 ) ;
8036: LD_INT 10
8038: PPUSH
8039: CALL_OW 67
8043: GO 8000
// RemoveEnvironment ( 91 , 99 ) ;
8045: LD_INT 91
8047: PPUSH
8048: LD_INT 99
8050: PPUSH
8051: CALL_OW 347
// RemoveEnvironment ( 91 , 101 ) ;
8055: LD_INT 91
8057: PPUSH
8058: LD_INT 101
8060: PPUSH
8061: CALL_OW 347
// RemoveEnvironment ( 94 , 102 ) ;
8065: LD_INT 94
8067: PPUSH
8068: LD_INT 102
8070: PPUSH
8071: CALL_OW 347
// RemoveEnvironment ( 93 , 100 ) ;
8075: LD_INT 93
8077: PPUSH
8078: LD_INT 100
8080: PPUSH
8081: CALL_OW 347
// SetAttitude ( arabians , you , att_friend , true ) ;
8085: LD_EXP 50
8089: PPUSH
8090: LD_EXP 47
8094: PPUSH
8095: LD_INT 1
8097: PPUSH
8098: LD_INT 1
8100: PPUSH
8101: CALL_OW 80
// while not ArmStarted do
8105: LD_EXP 74
8109: NOT
8110: IFFALSE 8210
// begin wait ( 0 0$0.3 ) ;
8112: LD_INT 10
8114: PPUSH
8115: CALL_OW 67
// SetSide ( ara2 , Getside ( rudepot1 ) ) ;
8119: LD_EXP 40
8123: PPUSH
8124: LD_EXP 67
8128: PPUSH
8129: CALL_OW 255
8133: PPUSH
8134: CALL_OW 235
// ComBuild ( Ara2 , b_armoury , 92 , 101 , 1 ) ;
8138: LD_EXP 40
8142: PPUSH
8143: LD_INT 4
8145: PPUSH
8146: LD_INT 92
8148: PPUSH
8149: LD_INT 101
8151: PPUSH
8152: LD_INT 1
8154: PPUSH
8155: CALL_OW 145
// ComMoveXY ( FilterAllUnits ( [ [ f_distxy , 92 , 101 , 6 ] , [ f_side , arabians ] ] ) , 93 , 90 ) ;
8159: LD_INT 92
8161: PUSH
8162: LD_INT 92
8164: PUSH
8165: LD_INT 101
8167: PUSH
8168: LD_INT 6
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 22
8179: PUSH
8180: LD_EXP 50
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PPUSH
8193: CALL_OW 69
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: LD_INT 90
8203: PPUSH
8204: CALL_OW 111
// end ;
8208: GO 8105
// SetSide ( ara2 , arabians ) ;
8210: LD_EXP 40
8214: PPUSH
8215: LD_EXP 50
8219: PPUSH
8220: CALL_OW 235
// wait ( 0 0$1 ) ;
8224: LD_INT 35
8226: PPUSH
8227: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8231: LD_EXP 39
8235: PUSH
8236: LD_EXP 41
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PPUSH
8245: LD_INT 30
8247: PUSH
8248: LD_INT 4
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PUSH
8255: LD_INT 23
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PPUSH
8269: CALL_OW 69
8273: PPUSH
8274: CALL_OW 112
// while not ArmBuild do
8278: LD_EXP 71
8282: NOT
8283: IFFALSE 8294
// wait ( 0 0$1 ) ;
8285: LD_INT 35
8287: PPUSH
8288: CALL_OW 67
8292: GO 8278
// SetAttitude ( arabians , you , att_neutral , true ) ;
8294: LD_EXP 50
8298: PPUSH
8299: LD_EXP 47
8303: PPUSH
8304: LD_INT 0
8306: PPUSH
8307: LD_INT 1
8309: PPUSH
8310: CALL_OW 80
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 then
8314: LD_EXP 67
8318: PPUSH
8319: CALL_OW 274
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: CALL_OW 275
8331: PUSH
8332: LD_INT 25
8334: LESS
8335: IFFALSE 8371
// begin DialogueOn ;
8337: CALL_OW 6
// if Say ( Ara2 , D9b-Ar2-1a ) then
8341: LD_EXP 40
8345: PPUSH
8346: LD_STRING D9b-Ar2-1a
8348: PPUSH
8349: CALL_OW 88
8353: IFFALSE 8367
// Say ( JMM , D9b-JMM-1 ) ;
8355: LD_EXP 17
8359: PPUSH
8360: LD_STRING D9b-JMM-1
8362: PPUSH
8363: CALL_OW 88
// DialogueOff ;
8367: CALL_OW 7
// end ; cekani := 0 ;
8371: LD_ADDR_VAR 0 2
8375: PUSH
8376: LD_INT 0
8378: ST_TO_ADDR
// while cekani < 120 and GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) < 25 do
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 120
8386: LESS
8387: PUSH
8388: LD_EXP 67
8392: PPUSH
8393: CALL_OW 274
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: CALL_OW 275
8405: PUSH
8406: LD_INT 25
8408: LESS
8409: AND
8410: IFFALSE 8435
// begin Wait ( 0 0$1 ) ;
8412: LD_INT 35
8414: PPUSH
8415: CALL_OW 67
// cekani := cekani + 1 ;
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_VAR 0 2
8428: PUSH
8429: LD_INT 1
8431: PLUS
8432: ST_TO_ADDR
// end ;
8433: GO 8379
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 25 then
8435: LD_EXP 67
8439: PPUSH
8440: CALL_OW 274
8444: PPUSH
8445: LD_INT 1
8447: PPUSH
8448: CALL_OW 275
8452: PUSH
8453: LD_INT 25
8455: GREATEREQUAL
8456: IFFALSE 9114
// begin wait ( 0 0$1 ) ;
8458: LD_INT 35
8460: PPUSH
8461: CALL_OW 67
// SetRestrict ( b_barracks , you , state_enabled ) ;
8465: LD_INT 5
8467: PPUSH
8468: LD_EXP 47
8472: PPUSH
8473: LD_INT 1
8475: PPUSH
8476: CALL_OW 324
// SetAttitude ( arabians , you , att_friend , true ) ;
8480: LD_EXP 50
8484: PPUSH
8485: LD_EXP 47
8489: PPUSH
8490: LD_INT 1
8492: PPUSH
8493: LD_INT 1
8495: PPUSH
8496: CALL_OW 80
// ComUpgrade ( FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ) ;
8500: LD_INT 30
8502: PUSH
8503: LD_INT 4
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 23
8512: PUSH
8513: LD_INT 2
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PPUSH
8524: CALL_OW 69
8528: PPUSH
8529: CALL_OW 146
// wait ( 0 0$1 ) ;
8533: LD_INT 35
8535: PPUSH
8536: CALL_OW 67
// SetTech ( tech_Mortar , you , state_researched ) ;
8540: LD_INT 41
8542: PPUSH
8543: LD_EXP 47
8547: PPUSH
8548: LD_INT 2
8550: PPUSH
8551: CALL_OW 322
// wait ( 0 0$1 ) ;
8555: LD_INT 35
8557: PPUSH
8558: CALL_OW 67
// ComMoveUnit ( [ ara1 , ara3 ] , FilterAllUnits ( [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) ) ;
8562: LD_EXP 39
8566: PUSH
8567: LD_EXP 41
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: PPUSH
8576: LD_INT 30
8578: PUSH
8579: LD_INT 5
8581: PUSH
8582: EMPTY
8583: LIST
8584: LIST
8585: PUSH
8586: LD_INT 23
8588: PUSH
8589: LD_INT 2
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PPUSH
8600: CALL_OW 69
8604: PPUSH
8605: CALL_OW 112
// while not ArmUpgraded do
8609: LD_EXP 72
8613: NOT
8614: IFFALSE 8625
// wait ( 0 0$1 ) ;
8616: LD_INT 35
8618: PPUSH
8619: CALL_OW 67
8623: GO 8609
// SetAttitude ( arabians , you , att_neutral , true ) ;
8625: LD_EXP 50
8629: PPUSH
8630: LD_EXP 47
8634: PPUSH
8635: LD_INT 0
8637: PPUSH
8638: LD_INT 1
8640: PPUSH
8641: CALL_OW 80
// DialogueOn ;
8645: CALL_OW 6
// if Say ( Ara2 , D9d-Ar2-1 ) then
8649: LD_EXP 40
8653: PPUSH
8654: LD_STRING D9d-Ar2-1
8656: PPUSH
8657: CALL_OW 88
8661: IFFALSE 8703
// if Say ( Ara1 , D9d-Ar1-1 ) then
8663: LD_EXP 39
8667: PPUSH
8668: LD_STRING D9d-Ar1-1
8670: PPUSH
8671: CALL_OW 88
8675: IFFALSE 8703
// if Say ( JMM , D9d-JMM-1 ) then
8677: LD_EXP 17
8681: PPUSH
8682: LD_STRING D9d-JMM-1
8684: PPUSH
8685: CALL_OW 88
8689: IFFALSE 8703
// Say ( Ara1 , D9d-Ar1-2 ) ;
8691: LD_EXP 39
8695: PPUSH
8696: LD_STRING D9d-Ar1-2
8698: PPUSH
8699: CALL_OW 88
// DialogueOff ;
8703: CALL_OW 7
// nabidka := [ 4 ] ;
8707: LD_ADDR_VAR 0 4
8711: PUSH
8712: LD_INT 4
8714: PUSH
8715: EMPTY
8716: LIST
8717: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_siberit ) >= 20 then
8718: LD_EXP 67
8722: PPUSH
8723: CALL_OW 274
8727: PPUSH
8728: LD_INT 3
8730: PPUSH
8731: CALL_OW 275
8735: PUSH
8736: LD_INT 20
8738: GREATEREQUAL
8739: IFFALSE 8758
// nabidka := nabidka ^ [ 1 ] ;
8741: LD_ADDR_VAR 0 4
8745: PUSH
8746: LD_VAR 0 4
8750: PUSH
8751: LD_INT 1
8753: PUSH
8754: EMPTY
8755: LIST
8756: ADD
8757: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_cans ) >= 50 then
8758: LD_EXP 67
8762: PPUSH
8763: CALL_OW 274
8767: PPUSH
8768: LD_INT 1
8770: PPUSH
8771: CALL_OW 275
8775: PUSH
8776: LD_INT 50
8778: GREATEREQUAL
8779: IFFALSE 8798
// nabidka := nabidka ^ [ 2 ] ;
8781: LD_ADDR_VAR 0 4
8785: PUSH
8786: LD_VAR 0 4
8790: PUSH
8791: LD_INT 2
8793: PUSH
8794: EMPTY
8795: LIST
8796: ADD
8797: ST_TO_ADDR
// if GetResourceType ( GetBase ( rudepot1 ) , mat_oil ) >= 80 then
8798: LD_EXP 67
8802: PPUSH
8803: CALL_OW 274
8807: PPUSH
8808: LD_INT 2
8810: PPUSH
8811: CALL_OW 275
8815: PUSH
8816: LD_INT 80
8818: GREATEREQUAL
8819: IFFALSE 8838
// nabidka := nabidka ^ [ 3 ] ;
8821: LD_ADDR_VAR 0 4
8825: PUSH
8826: LD_VAR 0 4
8830: PUSH
8831: LD_INT 3
8833: PUSH
8834: EMPTY
8835: LIST
8836: ADD
8837: ST_TO_ADDR
// qr := 4 ;
8838: LD_ADDR_VAR 0 3
8842: PUSH
8843: LD_INT 4
8845: ST_TO_ADDR
// if nabidka > 1 then
8846: LD_VAR 0 4
8850: PUSH
8851: LD_INT 1
8853: GREATER
8854: IFFALSE 8978
// begin qr := SelectiveQuery ( QInfo2 , nabidka ) ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_STRING QInfo2
8863: PPUSH
8864: LD_VAR 0 4
8868: PPUSH
8869: CALL_OW 98
8873: ST_TO_ADDR
// case qr of 1 :
8874: LD_VAR 0 3
8878: PUSH
8879: LD_INT 1
8881: DOUBLE
8882: EQUAL
8883: IFTRUE 8887
8885: GO 8911
8887: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_siberit , - 20 ) ; 2 :
8888: LD_EXP 67
8892: PPUSH
8893: CALL_OW 274
8897: PPUSH
8898: LD_INT 3
8900: PPUSH
8901: LD_INT 20
8903: NEG
8904: PPUSH
8905: CALL_OW 276
8909: GO 8976
8911: LD_INT 2
8913: DOUBLE
8914: EQUAL
8915: IFTRUE 8919
8917: GO 8943
8919: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_cans , - 50 ) ; 3 :
8920: LD_EXP 67
8924: PPUSH
8925: CALL_OW 274
8929: PPUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 50
8935: NEG
8936: PPUSH
8937: CALL_OW 276
8941: GO 8976
8943: LD_INT 3
8945: DOUBLE
8946: EQUAL
8947: IFTRUE 8951
8949: GO 8975
8951: POP
// AddResourceType ( GetBase ( rudepot1 ) , mat_oil , - 80 ) ; end ;
8952: LD_EXP 67
8956: PPUSH
8957: CALL_OW 274
8961: PPUSH
8962: LD_INT 2
8964: PPUSH
8965: LD_INT 80
8967: NEG
8968: PPUSH
8969: CALL_OW 276
8973: GO 8976
8975: POP
// end else
8976: GO 8985
// begin Query ( QInfoNothing ) ;
8978: LD_STRING QInfoNothing
8980: PPUSH
8981: CALL_OW 97
// end ; if qr = 4 then
8985: LD_VAR 0 3
8989: PUSH
8990: LD_INT 4
8992: EQUAL
8993: IFFALSE 9017
// begin DialogueOn ;
8995: CALL_OW 6
// Say ( Ara1 , D9f-Ar1-1 ) ;
8999: LD_EXP 39
9003: PPUSH
9004: LD_STRING D9f-Ar1-1
9006: PPUSH
9007: CALL_OW 88
// DialogueOff ;
9011: CALL_OW 7
// end else
9015: GO 9114
// begin case qr of 1 :
9017: LD_VAR 0 3
9021: PUSH
9022: LD_INT 1
9024: DOUBLE
9025: EQUAL
9026: IFTRUE 9030
9028: GO 9043
9030: POP
// odnes_neco ( mat_siberit , 20 ) ; 2 :
9031: LD_INT 3
9033: PPUSH
9034: LD_INT 20
9036: PPUSH
9037: CALL 5738 0 2
9041: GO 9086
9043: LD_INT 2
9045: DOUBLE
9046: EQUAL
9047: IFTRUE 9051
9049: GO 9064
9051: POP
// odnes_neco ( mat_cans , 50 ) ; 3 :
9052: LD_INT 1
9054: PPUSH
9055: LD_INT 50
9057: PPUSH
9058: CALL 5738 0 2
9062: GO 9086
9064: LD_INT 3
9066: DOUBLE
9067: EQUAL
9068: IFTRUE 9072
9070: GO 9085
9072: POP
// odnes_neco ( mat_oil , 80 ) ; end ;
9073: LD_INT 2
9075: PPUSH
9076: LD_INT 80
9078: PPUSH
9079: CALL 5738 0 2
9083: GO 9086
9085: POP
// DialogueOn ;
9086: CALL_OW 6
// Say ( Ara1 , D9e-Ar1-1 ) ;
9090: LD_EXP 39
9094: PPUSH
9095: LD_STRING D9e-Ar1-1
9097: PPUSH
9098: CALL_OW 88
// PoskytnouInformace := 1 ;
9102: LD_ADDR_EXP 56
9106: PUSH
9107: LD_INT 1
9109: ST_TO_ADDR
// DialogueOff ;
9110: CALL_OW 7
// end ; end ; end ; ComExitBuilding ( Ara2 ) ;
9114: LD_EXP 40
9118: PPUSH
9119: CALL_OW 122
// if cekani >= 120 then
9123: LD_VAR 0 2
9127: PUSH
9128: LD_INT 120
9130: GREATEREQUAL
9131: IFFALSE 9219
// begin DialogueOn ;
9133: CALL_OW 6
// if Say ( Ara1 , D9c-Ar1-1 ) then
9137: LD_EXP 39
9141: PPUSH
9142: LD_STRING D9c-Ar1-1
9144: PPUSH
9145: CALL_OW 88
9149: IFFALSE 9215
// if Say ( JMM , D9c-JMM-1 ) then
9151: LD_EXP 17
9155: PPUSH
9156: LD_STRING D9c-JMM-1
9158: PPUSH
9159: CALL_OW 88
9163: IFFALSE 9215
// if Say ( Ara1 , D9c-Ar1-2 ) then
9165: LD_EXP 39
9169: PPUSH
9170: LD_STRING D9c-Ar1-2
9172: PPUSH
9173: CALL_OW 88
9177: IFFALSE 9215
// if Say ( Ara3 , D9c-FAr1-2 ) then
9179: LD_EXP 41
9183: PPUSH
9184: LD_STRING D9c-FAr1-2
9186: PPUSH
9187: CALL_OW 88
9191: IFFALSE 9215
// if Say ( Ara1 , D9c-Ar1-3 ) then
9193: LD_EXP 39
9197: PPUSH
9198: LD_STRING D9c-Ar1-3
9200: PPUSH
9201: CALL_OW 88
9205: IFFALSE 9215
// PoskytnouInformace := 2 ;
9207: LD_ADDR_EXP 56
9211: PUSH
9212: LD_INT 2
9214: ST_TO_ADDR
// DialogueOff ;
9215: CALL_OW 7
// end ; end ; for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
9219: LD_ADDR_VAR 0 5
9223: PUSH
9224: LD_INT 22
9226: PUSH
9227: LD_EXP 50
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PUSH
9236: LD_INT 21
9238: PUSH
9239: LD_INT 3
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: PPUSH
9250: CALL_OW 69
9254: PUSH
9255: FOR_IN
9256: IFFALSE 9274
// SetSide ( i , you ) ;
9258: LD_VAR 0 5
9262: PPUSH
9263: LD_EXP 47
9267: PPUSH
9268: CALL_OW 235
9272: GO 9255
9274: POP
9275: POP
// if PoskytnouInformace > 0 and IsLive ( ara1 ) and IsLive ( ara2 ) and IsLive ( ara3 ) then
9276: LD_EXP 56
9280: PUSH
9281: LD_INT 0
9283: GREATER
9284: PUSH
9285: LD_EXP 39
9289: PPUSH
9290: CALL_OW 300
9294: AND
9295: PUSH
9296: LD_EXP 40
9300: PPUSH
9301: CALL_OW 300
9305: AND
9306: PUSH
9307: LD_EXP 41
9311: PPUSH
9312: CALL_OW 300
9316: AND
9317: IFFALSE 9495
// begin DialogueOn ;
9319: CALL_OW 6
// if PoskytnouInformace = 2 then
9323: LD_EXP 56
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9345
// Say ( JMM , D10a-JMM-1 ) ;
9333: LD_EXP 17
9337: PPUSH
9338: LD_STRING D10a-JMM-1
9340: PPUSH
9341: CALL_OW 88
// if PoskytnouInformace = 1 then
9345: LD_EXP 56
9349: PUSH
9350: LD_INT 1
9352: EQUAL
9353: IFFALSE 9367
// Say ( JMM , D10a-JMM-1 ) ;
9355: LD_EXP 17
9359: PPUSH
9360: LD_STRING D10a-JMM-1
9362: PPUSH
9363: CALL_OW 88
// if Say ( Ara1 , D10a-Ar1-1 ) then
9367: LD_EXP 39
9371: PPUSH
9372: LD_STRING D10a-Ar1-1
9374: PPUSH
9375: CALL_OW 88
9379: IFFALSE 9491
// if Say ( Ara2 , D10a-Ar2-1 ) then
9381: LD_EXP 40
9385: PPUSH
9386: LD_STRING D10a-Ar2-1
9388: PPUSH
9389: CALL_OW 88
9393: IFFALSE 9491
// if Say ( Ara3 , D10a-FAr1-1 ) then
9395: LD_EXP 41
9399: PPUSH
9400: LD_STRING D10a-FAr1-1
9402: PPUSH
9403: CALL_OW 88
9407: IFFALSE 9491
// if Say ( Ara2 , D10a-Ar2-2 ) then
9409: LD_EXP 40
9413: PPUSH
9414: LD_STRING D10a-Ar2-2
9416: PPUSH
9417: CALL_OW 88
9421: IFFALSE 9491
// if Say ( Ara3 , D10a-FAr1-2 ) then
9423: LD_EXP 41
9427: PPUSH
9428: LD_STRING D10a-FAr1-2
9430: PPUSH
9431: CALL_OW 88
9435: IFFALSE 9491
// if Say ( Ara1 , D10a-Ar1-2 ) then
9437: LD_EXP 39
9441: PPUSH
9442: LD_STRING D10a-Ar1-2
9444: PPUSH
9445: CALL_OW 88
9449: IFFALSE 9491
// if Say ( JMM , D10a-JMM-2 ) then
9451: LD_EXP 17
9455: PPUSH
9456: LD_STRING D10a-JMM-2
9458: PPUSH
9459: CALL_OW 88
9463: IFFALSE 9491
// if Say ( Ara1 , D10a-Ar1-3 ) then
9465: LD_EXP 39
9469: PPUSH
9470: LD_STRING D10a-Ar1-3
9472: PPUSH
9473: CALL_OW 88
9477: IFFALSE 9491
// Say ( JMM , D10a-JMM-3 ) ;
9479: LD_EXP 17
9483: PPUSH
9484: LD_STRING D10a-JMM-3
9486: PPUSH
9487: CALL_OW 88
// DialogueOff ;
9491: CALL_OW 7
// end ; end ; if ( Aqr1 = 3 ) or ( Aqr1 = 2 and Aqr2 = 2 ) then
9495: LD_EXP 37
9499: PUSH
9500: LD_INT 3
9502: EQUAL
9503: PUSH
9504: LD_EXP 37
9508: PUSH
9509: LD_INT 2
9511: EQUAL
9512: PUSH
9513: LD_EXP 38
9517: PUSH
9518: LD_INT 2
9520: EQUAL
9521: AND
9522: OR
9523: IFFALSE 10736
// begin ara1_faze := 0 ;
9525: LD_ADDR_VAR 0 9
9529: PUSH
9530: LD_INT 0
9532: ST_TO_ADDR
// ara3_faze := 0 ;
9533: LD_ADDR_VAR 0 10
9537: PUSH
9538: LD_INT 0
9540: ST_TO_ADDR
// while UnitFilter ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
9541: LD_EXP 39
9545: PUSH
9546: LD_EXP 40
9550: PUSH
9551: LD_EXP 41
9555: PUSH
9556: LD_EXP 42
9560: PUSH
9561: LD_EXP 43
9565: PUSH
9566: LD_EXP 44
9570: PUSH
9571: LD_EXP 45
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: PPUSH
9585: LD_INT 50
9587: PUSH
9588: EMPTY
9589: LIST
9590: PPUSH
9591: CALL_OW 72
9595: IFFALSE 10734
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
9597: LD_ADDR_VAR 0 5
9601: PUSH
9602: LD_INT 22
9604: PPUSH
9605: LD_INT 22
9607: PUSH
9608: LD_EXP 50
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: EMPTY
9618: LIST
9619: PPUSH
9620: CALL_OW 70
9624: PUSH
9625: FOR_IN
9626: IFFALSE 9751
// if not ( ( i = Ara1 ) and ( ara1_faze < 2 ) or ( i = Ara3 ) and ( ara3_faze < 2 ) ) then
9628: LD_VAR 0 5
9632: PUSH
9633: LD_EXP 39
9637: EQUAL
9638: PUSH
9639: LD_VAR 0 9
9643: PUSH
9644: LD_INT 2
9646: LESS
9647: AND
9648: PUSH
9649: LD_VAR 0 5
9653: PUSH
9654: LD_EXP 41
9658: EQUAL
9659: PUSH
9660: LD_VAR 0 10
9664: PUSH
9665: LD_INT 2
9667: LESS
9668: AND
9669: OR
9670: NOT
9671: IFFALSE 9749
// begin RemoveUnit ( i ) ;
9673: LD_VAR 0 5
9677: PPUSH
9678: CALL_OW 64
// if i = AraCar1 then
9682: LD_VAR 0 5
9686: PUSH
9687: LD_EXP 44
9691: EQUAL
9692: IFFALSE 9703
// RemoveUnit ( Ara4 ) ;
9694: LD_EXP 42
9698: PPUSH
9699: CALL_OW 64
// if i = AraCar2 then
9703: LD_VAR 0 5
9707: PUSH
9708: LD_EXP 45
9712: EQUAL
9713: IFFALSE 9724
// RemoveUnit ( Ara5 ) ;
9715: LD_EXP 43
9719: PPUSH
9720: CALL_OW 64
// if IsInUnit ( i ) then
9724: LD_VAR 0 5
9728: PPUSH
9729: CALL_OW 310
9733: IFFALSE 9749
// RemoveUnit ( IsInUnit ( i ) ) ;
9735: LD_VAR 0 5
9739: PPUSH
9740: CALL_OW 310
9744: PPUSH
9745: CALL_OW 64
// end ;
9749: GO 9625
9751: POP
9752: POP
// wait ( 0 0$5 ) ;
9753: LD_INT 175
9755: PPUSH
9756: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
9760: LD_EXP 42
9764: PPUSH
9765: CALL_OW 310
9769: NOT
9770: PUSH
9771: LD_EXP 44
9775: PPUSH
9776: CALL_OW 302
9780: NOT
9781: AND
9782: IFFALSE 9796
// ComMoveToArea ( Ara4 , arab_exit ) ;
9784: LD_EXP 42
9788: PPUSH
9789: LD_INT 22
9791: PPUSH
9792: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
9796: LD_EXP 43
9800: PPUSH
9801: CALL_OW 310
9805: NOT
9806: PUSH
9807: LD_EXP 45
9811: PPUSH
9812: CALL_OW 302
9816: NOT
9817: AND
9818: IFFALSE 9832
// ComMoveToArea ( Ara5 , arab_exit ) ;
9820: LD_EXP 43
9824: PPUSH
9825: LD_INT 22
9827: PPUSH
9828: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
9832: LD_EXP 42
9836: PPUSH
9837: CALL_OW 310
9841: NOT
9842: PUSH
9843: LD_EXP 44
9847: PPUSH
9848: CALL_OW 261
9852: PUSH
9853: LD_INT 0
9855: GREATER
9856: AND
9857: PUSH
9858: LD_EXP 44
9862: PPUSH
9863: CALL_OW 302
9867: AND
9868: IFFALSE 9884
// ComEnterUnit ( Ara4 , AraCar1 ) ;
9870: LD_EXP 42
9874: PPUSH
9875: LD_EXP 44
9879: PPUSH
9880: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
9884: LD_EXP 43
9888: PPUSH
9889: CALL_OW 310
9893: NOT
9894: PUSH
9895: LD_EXP 45
9899: PPUSH
9900: CALL_OW 261
9904: PUSH
9905: LD_INT 0
9907: GREATER
9908: AND
9909: PUSH
9910: LD_EXP 45
9914: PPUSH
9915: CALL_OW 302
9919: AND
9920: IFFALSE 9936
// ComEnterUnit ( Ara5 , AraCar2 ) ;
9922: LD_EXP 43
9926: PPUSH
9927: LD_EXP 45
9931: PPUSH
9932: CALL_OW 120
// ComMoveToArea ( [ Ara2 , AraCar1 , AraCar2 ] , arab_exit ) ;
9936: LD_EXP 40
9940: PUSH
9941: LD_EXP 44
9945: PUSH
9946: LD_EXP 45
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: LIST
9955: PPUSH
9956: LD_INT 22
9958: PPUSH
9959: CALL_OW 113
// AddComMoveXY ( [ Ara2 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
9963: LD_EXP 40
9967: PUSH
9968: LD_EXP 44
9972: PUSH
9973: LD_EXP 45
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: LIST
9982: PPUSH
9983: LD_INT 37
9985: PPUSH
9986: LD_INT 72
9988: PPUSH
9989: CALL_OW 171
// case true of not IsOk ( Ara1 ) :
9993: LD_INT 1
9995: PUSH
9996: LD_EXP 39
10000: PPUSH
10001: CALL_OW 302
10005: NOT
10006: DOUBLE
10007: EQUAL
10008: IFTRUE 10012
10010: GO 10023
10012: POP
// ara1_faze := 4 ; ( GetDistUnitXY ( Ara1 , 57 , 76 ) < 5 ) and ara1_faze = 2 :
10013: LD_ADDR_VAR 0 9
10017: PUSH
10018: LD_INT 4
10020: ST_TO_ADDR
10021: GO 10171
10023: LD_EXP 39
10027: PPUSH
10028: LD_INT 57
10030: PPUSH
10031: LD_INT 76
10033: PPUSH
10034: CALL_OW 297
10038: PUSH
10039: LD_INT 5
10041: LESS
10042: PUSH
10043: LD_VAR 0 9
10047: PUSH
10048: LD_INT 2
10050: EQUAL
10051: AND
10052: DOUBLE
10053: EQUAL
10054: IFTRUE 10058
10056: GO 10069
10058: POP
// ara1_faze := 3 ; MineOfUnit ( Ara1 ) <> 0 and ara1_faze = 1 :
10059: LD_ADDR_VAR 0 9
10063: PUSH
10064: LD_INT 3
10066: ST_TO_ADDR
10067: GO 10171
10069: LD_EXP 39
10073: PPUSH
10074: CALL_OW 459
10078: PUSH
10079: LD_INT 0
10081: NONEQUAL
10082: PUSH
10083: LD_VAR 0 9
10087: PUSH
10088: LD_INT 1
10090: EQUAL
10091: AND
10092: DOUBLE
10093: EQUAL
10094: IFTRUE 10098
10096: GO 10124
10098: POP
// begin ara1_faze := 2 ;
10099: LD_ADDR_VAR 0 9
10103: PUSH
10104: LD_INT 2
10106: ST_TO_ADDR
// mina1 := MineOfUnit ( Ara1 ) ;
10107: LD_ADDR_EXP 77
10111: PUSH
10112: LD_EXP 39
10116: PPUSH
10117: CALL_OW 459
10121: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara1 , 58 , 76 ) < 5 ) and ara1_faze = 0 :
10122: GO 10171
10124: LD_EXP 39
10128: PPUSH
10129: LD_INT 58
10131: PPUSH
10132: LD_INT 76
10134: PPUSH
10135: CALL_OW 297
10139: PUSH
10140: LD_INT 5
10142: LESS
10143: PUSH
10144: LD_VAR 0 9
10148: PUSH
10149: LD_INT 0
10151: EQUAL
10152: AND
10153: DOUBLE
10154: EQUAL
10155: IFTRUE 10159
10157: GO 10170
10159: POP
// ara1_faze := 1 ; end ;
10160: LD_ADDR_VAR 0 9
10164: PUSH
10165: LD_INT 1
10167: ST_TO_ADDR
10168: GO 10171
10170: POP
// case ara1_faze of 0 :
10171: LD_VAR 0 9
10175: PUSH
10176: LD_INT 0
10178: DOUBLE
10179: EQUAL
10180: IFTRUE 10184
10182: GO 10202
10184: POP
// ComMoveXY ( Ara1 , 58 , 76 ) ; 1 :
10185: LD_EXP 39
10189: PPUSH
10190: LD_INT 58
10192: PPUSH
10193: LD_INT 76
10195: PPUSH
10196: CALL_OW 111
10200: GO 10298
10202: LD_INT 1
10204: DOUBLE
10205: EQUAL
10206: IFTRUE 10210
10208: GO 10233
10210: POP
// ComPlaceRemoteCharge ( Ara1 , 0 , 0 , ruDepot1 ) ; 2 :
10211: LD_EXP 39
10215: PPUSH
10216: LD_INT 0
10218: PPUSH
10219: LD_INT 0
10221: PPUSH
10222: LD_EXP 67
10226: PPUSH
10227: CALL_OW 133
10231: GO 10298
10233: LD_INT 2
10235: DOUBLE
10236: EQUAL
10237: IFTRUE 10241
10239: GO 10259
10241: POP
// ComMoveXY ( Ara1 , 57 , 76 ) ; 3 :
10242: LD_EXP 39
10246: PPUSH
10247: LD_INT 57
10249: PPUSH
10250: LD_INT 76
10252: PPUSH
10253: CALL_OW 111
10257: GO 10298
10259: LD_INT 3
10261: DOUBLE
10262: EQUAL
10263: IFTRUE 10267
10265: GO 10297
10267: POP
// begin ComMoveToArea ( Ara1 , arab_exit ) ;
10268: LD_EXP 39
10272: PPUSH
10273: LD_INT 22
10275: PPUSH
10276: CALL_OW 113
// AddComMoveXY ( Ara1 , 37 , 72 ) ;
10280: LD_EXP 39
10284: PPUSH
10285: LD_INT 37
10287: PPUSH
10288: LD_INT 72
10290: PPUSH
10291: CALL_OW 171
// end ; end ;
10295: GO 10298
10297: POP
// case true of not IsOk ( Ara3 ) :
10298: LD_INT 1
10300: PUSH
10301: LD_EXP 41
10305: PPUSH
10306: CALL_OW 302
10310: NOT
10311: DOUBLE
10312: EQUAL
10313: IFTRUE 10317
10315: GO 10328
10317: POP
// ara3_faze := 4 ; ( GetDistUnitXY ( Ara3 , 58 , 76 ) < 5 ) and ara3_faze = 2 :
10318: LD_ADDR_VAR 0 10
10322: PUSH
10323: LD_INT 4
10325: ST_TO_ADDR
10326: GO 10476
10328: LD_EXP 41
10332: PPUSH
10333: LD_INT 58
10335: PPUSH
10336: LD_INT 76
10338: PPUSH
10339: CALL_OW 297
10343: PUSH
10344: LD_INT 5
10346: LESS
10347: PUSH
10348: LD_VAR 0 10
10352: PUSH
10353: LD_INT 2
10355: EQUAL
10356: AND
10357: DOUBLE
10358: EQUAL
10359: IFTRUE 10363
10361: GO 10374
10363: POP
// ara3_faze := 3 ; MineOfUnit ( Ara3 ) <> 0 and ara3_faze = 1 :
10364: LD_ADDR_VAR 0 10
10368: PUSH
10369: LD_INT 3
10371: ST_TO_ADDR
10372: GO 10476
10374: LD_EXP 41
10378: PPUSH
10379: CALL_OW 459
10383: PUSH
10384: LD_INT 0
10386: NONEQUAL
10387: PUSH
10388: LD_VAR 0 10
10392: PUSH
10393: LD_INT 1
10395: EQUAL
10396: AND
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10429
10403: POP
// begin ara3_faze := 2 ;
10404: LD_ADDR_VAR 0 10
10408: PUSH
10409: LD_INT 2
10411: ST_TO_ADDR
// mina3 := MineOfUnit ( Ara3 ) ;
10412: LD_ADDR_EXP 78
10416: PUSH
10417: LD_EXP 41
10421: PPUSH
10422: CALL_OW 459
10426: ST_TO_ADDR
// end ; ( GetDistUnitXY ( Ara3 , 70 , 104 ) < 5 ) and ara3_faze = 0 :
10427: GO 10476
10429: LD_EXP 41
10433: PPUSH
10434: LD_INT 70
10436: PPUSH
10437: LD_INT 104
10439: PPUSH
10440: CALL_OW 297
10444: PUSH
10445: LD_INT 5
10447: LESS
10448: PUSH
10449: LD_VAR 0 10
10453: PUSH
10454: LD_INT 0
10456: EQUAL
10457: AND
10458: DOUBLE
10459: EQUAL
10460: IFTRUE 10464
10462: GO 10475
10464: POP
// ara3_faze := 1 ; end ;
10465: LD_ADDR_VAR 0 10
10469: PUSH
10470: LD_INT 1
10472: ST_TO_ADDR
10473: GO 10476
10475: POP
// case ara3_faze of 0 :
10476: LD_VAR 0 10
10480: PUSH
10481: LD_INT 0
10483: DOUBLE
10484: EQUAL
10485: IFTRUE 10489
10487: GO 10507
10489: POP
// ComMoveXY ( Ara3 , 70 , 104 ) ; 1 :
10490: LD_EXP 41
10494: PPUSH
10495: LD_INT 70
10497: PPUSH
10498: LD_INT 104
10500: PPUSH
10501: CALL_OW 111
10505: GO 10603
10507: LD_INT 1
10509: DOUBLE
10510: EQUAL
10511: IFTRUE 10515
10513: GO 10538
10515: POP
// ComPlaceRemoteCharge ( Ara3 , 0 , 0 , ruDepot1 ) ; 2 :
10516: LD_EXP 41
10520: PPUSH
10521: LD_INT 0
10523: PPUSH
10524: LD_INT 0
10526: PPUSH
10527: LD_EXP 67
10531: PPUSH
10532: CALL_OW 133
10536: GO 10603
10538: LD_INT 2
10540: DOUBLE
10541: EQUAL
10542: IFTRUE 10546
10544: GO 10564
10546: POP
// ComMoveXY ( Ara3 , 58 , 76 ) ; 3 :
10547: LD_EXP 41
10551: PPUSH
10552: LD_INT 58
10554: PPUSH
10555: LD_INT 76
10557: PPUSH
10558: CALL_OW 111
10562: GO 10603
10564: LD_INT 3
10566: DOUBLE
10567: EQUAL
10568: IFTRUE 10572
10570: GO 10602
10572: POP
// begin ComMoveToArea ( Ara3 , arab_exit ) ;
10573: LD_EXP 41
10577: PPUSH
10578: LD_INT 22
10580: PPUSH
10581: CALL_OW 113
// AddComMoveXY ( Ara3 , 37 , 72 ) ;
10585: LD_EXP 41
10589: PPUSH
10590: LD_INT 37
10592: PPUSH
10593: LD_INT 72
10595: PPUSH
10596: CALL_OW 171
// end ; end ;
10600: GO 10603
10602: POP
// if not kecy and ara1_faze >= 3 and ara3_faze >= 3 then
10603: LD_EXP 76
10607: NOT
10608: PUSH
10609: LD_VAR 0 9
10613: PUSH
10614: LD_INT 3
10616: GREATEREQUAL
10617: AND
10618: PUSH
10619: LD_VAR 0 10
10623: PUSH
10624: LD_INT 3
10626: GREATEREQUAL
10627: AND
10628: IFFALSE 10732
// begin if odmitl_v_query then
10630: LD_VAR 0 11
10634: IFFALSE 10650
// Say ( Ara2 , D11b-Ar1-1 ) else
10636: LD_EXP 40
10640: PPUSH
10641: LD_STRING D11b-Ar1-1
10643: PPUSH
10644: CALL_OW 88
10648: GO 10662
// Say ( Ara2 , D11a-Ar1-1 ) ;
10650: LD_EXP 40
10654: PPUSH
10655: LD_STRING D11a-Ar1-1
10657: PPUSH
10658: CALL_OW 88
// if mina1 then
10662: LD_EXP 77
10666: IFFALSE 10693
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
10668: LD_EXP 77
10672: PUSH
10673: LD_INT 1
10675: ARRAY
10676: PPUSH
10677: LD_EXP 77
10681: PUSH
10682: LD_INT 2
10684: ARRAY
10685: PPUSH
10686: LD_INT 1200
10688: PPUSH
10689: CALL_OW 453
// if mina3 then
10693: LD_EXP 78
10697: IFFALSE 10724
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
10699: LD_EXP 78
10703: PUSH
10704: LD_INT 1
10706: ARRAY
10707: PPUSH
10708: LD_EXP 78
10712: PUSH
10713: LD_INT 2
10715: ARRAY
10716: PPUSH
10717: LD_INT 1200
10719: PPUSH
10720: CALL_OW 453
// kecy := true ;
10724: LD_ADDR_EXP 76
10728: PUSH
10729: LD_INT 1
10731: ST_TO_ADDR
// end ; end ;
10732: GO 9541
// end else
10734: GO 11145
// begin while UnitFilter ( [ Ara2 , AraCar1 , AraCar2 ] , [ f_ok ] ) do
10736: LD_EXP 40
10740: PUSH
10741: LD_EXP 44
10745: PUSH
10746: LD_EXP 45
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: LIST
10755: PPUSH
10756: LD_INT 50
10758: PUSH
10759: EMPTY
10760: LIST
10761: PPUSH
10762: CALL_OW 72
10766: IFFALSE 11145
// begin for i in FilterUnitsInArea ( arab_exit , [ [ f_side , arabians ] ] ) do
10768: LD_ADDR_VAR 0 5
10772: PUSH
10773: LD_INT 22
10775: PPUSH
10776: LD_INT 22
10778: PUSH
10779: LD_EXP 50
10783: PUSH
10784: EMPTY
10785: LIST
10786: LIST
10787: PUSH
10788: EMPTY
10789: LIST
10790: PPUSH
10791: CALL_OW 70
10795: PUSH
10796: FOR_IN
10797: IFFALSE 10877
// begin RemoveUnit ( i ) ;
10799: LD_VAR 0 5
10803: PPUSH
10804: CALL_OW 64
// if i = AraCar1 then
10808: LD_VAR 0 5
10812: PUSH
10813: LD_EXP 44
10817: EQUAL
10818: IFFALSE 10829
// RemoveUnit ( Ara4 ) ;
10820: LD_EXP 42
10824: PPUSH
10825: CALL_OW 64
// if i = AraCar2 then
10829: LD_VAR 0 5
10833: PUSH
10834: LD_EXP 45
10838: EQUAL
10839: IFFALSE 10850
// RemoveUnit ( Ara5 ) ;
10841: LD_EXP 43
10845: PPUSH
10846: CALL_OW 64
// if IsInUnit ( i ) then
10850: LD_VAR 0 5
10854: PPUSH
10855: CALL_OW 310
10859: IFFALSE 10875
// RemoveUnit ( IsInUnit ( i ) ) ;
10861: LD_VAR 0 5
10865: PPUSH
10866: CALL_OW 310
10870: PPUSH
10871: CALL_OW 64
// end ;
10875: GO 10796
10877: POP
10878: POP
// wait ( 0 0$1 ) ;
10879: LD_INT 35
10881: PPUSH
10882: CALL_OW 67
// if not IsInUnit ( Ara4 ) and not IsOK ( AraCar1 ) then
10886: LD_EXP 42
10890: PPUSH
10891: CALL_OW 310
10895: NOT
10896: PUSH
10897: LD_EXP 44
10901: PPUSH
10902: CALL_OW 302
10906: NOT
10907: AND
10908: IFFALSE 10922
// ComMoveToArea ( Ara4 , arab_exit ) ;
10910: LD_EXP 42
10914: PPUSH
10915: LD_INT 22
10917: PPUSH
10918: CALL_OW 113
// if not IsInUnit ( Ara5 ) and not IsOK ( AraCar2 ) then
10922: LD_EXP 43
10926: PPUSH
10927: CALL_OW 310
10931: NOT
10932: PUSH
10933: LD_EXP 45
10937: PPUSH
10938: CALL_OW 302
10942: NOT
10943: AND
10944: IFFALSE 10958
// ComMoveToArea ( Ara5 , arab_exit ) ;
10946: LD_EXP 43
10950: PPUSH
10951: LD_INT 22
10953: PPUSH
10954: CALL_OW 113
// if not IsInUnit ( Ara4 ) and GetFuel ( AraCar1 ) > 0 and IsOK ( AraCar1 ) then
10958: LD_EXP 42
10962: PPUSH
10963: CALL_OW 310
10967: NOT
10968: PUSH
10969: LD_EXP 44
10973: PPUSH
10974: CALL_OW 261
10978: PUSH
10979: LD_INT 0
10981: GREATER
10982: AND
10983: PUSH
10984: LD_EXP 44
10988: PPUSH
10989: CALL_OW 302
10993: AND
10994: IFFALSE 11010
// ComEnterUnit ( Ara4 , AraCar1 ) ;
10996: LD_EXP 42
11000: PPUSH
11001: LD_EXP 44
11005: PPUSH
11006: CALL_OW 120
// if not IsInUnit ( Ara5 ) and GetFuel ( AraCar2 ) > 0 and IsOK ( AraCar2 ) then
11010: LD_EXP 43
11014: PPUSH
11015: CALL_OW 310
11019: NOT
11020: PUSH
11021: LD_EXP 45
11025: PPUSH
11026: CALL_OW 261
11030: PUSH
11031: LD_INT 0
11033: GREATER
11034: AND
11035: PUSH
11036: LD_EXP 45
11040: PPUSH
11041: CALL_OW 302
11045: AND
11046: IFFALSE 11062
// ComEnterUnit ( Ara5 , AraCar2 ) ;
11048: LD_EXP 43
11052: PPUSH
11053: LD_EXP 45
11057: PPUSH
11058: CALL_OW 120
// ComMoveToArea ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , arab_exit ) ;
11062: LD_EXP 39
11066: PUSH
11067: LD_EXP 40
11071: PUSH
11072: LD_EXP 41
11076: PUSH
11077: LD_EXP 44
11081: PUSH
11082: LD_EXP 45
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: LIST
11093: PPUSH
11094: LD_INT 22
11096: PPUSH
11097: CALL_OW 113
// AddComMoveXY ( [ Ara1 , Ara2 , Ara3 , AraCar1 , AraCar2 ] , 37 , 72 ) ;
11101: LD_EXP 39
11105: PUSH
11106: LD_EXP 40
11110: PUSH
11111: LD_EXP 41
11115: PUSH
11116: LD_EXP 44
11120: PUSH
11121: LD_EXP 45
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: LIST
11130: LIST
11131: LIST
11132: PPUSH
11133: LD_INT 37
11135: PPUSH
11136: LD_INT 72
11138: PPUSH
11139: CALL_OW 171
// end ;
11143: GO 10736
// end ; end ;
11145: LD_VAR 0 1
11149: RET
// every 0 0$1 do var who , a_maj_to , a , i ;
11150: GO 11152
11152: DISABLE
11153: LD_INT 0
11155: PPUSH
11156: PPUSH
11157: PPUSH
11158: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
11159: LD_ADDR_VAR 0 3
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_EXP 47
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: EMPTY
11177: LIST
11178: PPUSH
11179: CALL_OW 69
11183: ST_TO_ADDR
// for i in a do
11184: LD_ADDR_VAR 0 4
11188: PUSH
11189: LD_VAR 0 3
11193: PUSH
11194: FOR_IN
11195: IFFALSE 11265
// if WantsToAttack ( i ) in [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 , AraCar1 , AraCar2 ] then
11197: LD_VAR 0 4
11201: PPUSH
11202: CALL_OW 319
11206: PUSH
11207: LD_EXP 39
11211: PUSH
11212: LD_EXP 40
11216: PUSH
11217: LD_EXP 41
11221: PUSH
11222: LD_EXP 42
11226: PUSH
11227: LD_EXP 43
11231: PUSH
11232: LD_EXP 44
11236: PUSH
11237: LD_EXP 45
11241: PUSH
11242: EMPTY
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: IN
11251: IFFALSE 11263
// begin a_maj_to := true ;
11253: LD_ADDR_VAR 0 2
11257: PUSH
11258: LD_INT 1
11260: ST_TO_ADDR
// break ;
11261: GO 11265
// end ;
11263: GO 11194
11265: POP
11266: POP
// if a_maj_to then
11267: LD_VAR 0 2
11271: IFFALSE 11448
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
11273: LD_EXP 47
11277: PPUSH
11278: LD_EXP 50
11282: PPUSH
11283: LD_INT 2
11285: PPUSH
11286: LD_INT 1
11288: PPUSH
11289: CALL_OW 80
// who := WhoSayAny ( [ Ara1 , Ara2 , Ara3 , Ara4 , Ara5 ] , arabians , sex_male , 0 , 0 ) ;
11293: LD_ADDR_VAR 0 1
11297: PUSH
11298: LD_EXP 39
11302: PUSH
11303: LD_EXP 40
11307: PUSH
11308: LD_EXP 41
11312: PUSH
11313: LD_EXP 42
11317: PUSH
11318: LD_EXP 43
11322: PUSH
11323: EMPTY
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: PPUSH
11330: LD_EXP 50
11334: PPUSH
11335: LD_INT 1
11337: PPUSH
11338: LD_INT 0
11340: PPUSH
11341: LD_INT 0
11343: PPUSH
11344: CALL 13091 0 5
11348: ST_TO_ADDR
// if not kecy then
11349: LD_EXP 76
11353: NOT
11354: IFFALSE 11446
// begin DialogueOn ;
11356: CALL_OW 6
// Say ( who , D11a-Ar1-1 ) ;
11360: LD_VAR 0 1
11364: PPUSH
11365: LD_STRING D11a-Ar1-1
11367: PPUSH
11368: CALL_OW 88
// DialogueOff ;
11372: CALL_OW 7
// kecy := true ;
11376: LD_ADDR_EXP 76
11380: PUSH
11381: LD_INT 1
11383: ST_TO_ADDR
// if mina1 then
11384: LD_EXP 77
11388: IFFALSE 11415
// MineExplosion ( mina1 [ 1 ] , mina1 [ 2 ] , 1200 ) ;
11390: LD_EXP 77
11394: PUSH
11395: LD_INT 1
11397: ARRAY
11398: PPUSH
11399: LD_EXP 77
11403: PUSH
11404: LD_INT 2
11406: ARRAY
11407: PPUSH
11408: LD_INT 1200
11410: PPUSH
11411: CALL_OW 453
// if mina3 then
11415: LD_EXP 78
11419: IFFALSE 11446
// MineExplosion ( mina3 [ 1 ] , mina3 [ 2 ] , 1200 ) ;
11421: LD_EXP 78
11425: PUSH
11426: LD_INT 1
11428: ARRAY
11429: PPUSH
11430: LD_EXP 78
11434: PUSH
11435: LD_INT 2
11437: ARRAY
11438: PPUSH
11439: LD_INT 1200
11441: PPUSH
11442: CALL_OW 453
// end ; end else
11446: GO 11449
// enable ;
11448: ENABLE
// end ;
11449: PPOPN 4
11451: END
// every 45 45$30 do
11452: GO 11454
11454: DISABLE
// begin DialogueOn ;
11455: CALL_OW 6
// SayRadio ( Powell , D12-Pow-1 ) ;
11459: LD_EXP 16
11463: PPUSH
11464: LD_STRING D12-Pow-1
11466: PPUSH
11467: CALL_OW 94
// ChangeMissionObjectives ( M4 ) ;
11471: LD_STRING M4
11473: PPUSH
11474: CALL_OW 337
// EndEnable := true ;
11478: LD_ADDR_EXP 80
11482: PUSH
11483: LD_INT 1
11485: ST_TO_ADDR
// SetAreaMapShow ( exit_area , 1 ) ;
11486: LD_INT 32
11488: PPUSH
11489: LD_INT 1
11491: PPUSH
11492: CALL_OW 424
// DialogueOff ;
11496: CALL_OW 7
// end ;
11500: END
// export konec ; every 55 55$0 do
11501: GO 11503
11503: DISABLE
// begin Konec := true ;
11504: LD_ADDR_EXP 79
11508: PUSH
11509: LD_INT 1
11511: ST_TO_ADDR
// end ;
11512: END
// export EndEnable , TimerCas ; every 0 0$1 do var k , br , zbyva ;
11513: GO 11515
11515: DISABLE
11516: LD_INT 0
11518: PPUSH
11519: PPUSH
11520: PPUSH
// begin if testing then
11521: LD_EXP 4
11525: IFFALSE 11581
// display_strings := [ [ game time:  & ( tick div 1 1$0 ) & :  & ( ( tick - ( tick div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] else
11527: LD_ADDR_OWVAR 47
11531: PUSH
11532: LD_STRING game time: 
11534: PUSH
11535: LD_OWVAR 1
11539: PUSH
11540: LD_INT 2100
11542: DIV
11543: STR
11544: PUSH
11545: LD_STRING : 
11547: STR
11548: PUSH
11549: LD_OWVAR 1
11553: PUSH
11554: LD_OWVAR 1
11558: PUSH
11559: LD_INT 2100
11561: DIV
11562: PUSH
11563: LD_INT 2100
11565: MUL
11566: MINUS
11567: PUSH
11568: LD_INT 35
11570: DIV
11571: STR
11572: PUSH
11573: EMPTY
11574: LIST
11575: PUSH
11576: EMPTY
11577: LIST
11578: ST_TO_ADDR
11579: GO 11588
// display_strings := [ ] ;
11581: LD_ADDR_OWVAR 47
11585: PUSH
11586: EMPTY
11587: ST_TO_ADDR
// zbyva := 60 - GetResourceType ( getbase ( depot1 ) , mat_siberit ) ;
11588: LD_ADDR_VAR 0 3
11592: PUSH
11593: LD_INT 60
11595: PUSH
11596: LD_EXP 69
11600: PPUSH
11601: CALL_OW 274
11605: PPUSH
11606: LD_INT 3
11608: PPUSH
11609: CALL_OW 275
11613: MINUS
11614: ST_TO_ADDR
// if zbyva < 0 then
11615: LD_VAR 0 3
11619: PUSH
11620: LD_INT 0
11622: LESS
11623: IFFALSE 11633
// zbyva := 0 ;
11625: LD_ADDR_VAR 0 3
11629: PUSH
11630: LD_INT 0
11632: ST_TO_ADDR
// if counter_time then
11633: LD_EXP 64
11637: IFFALSE 11674
// display_strings := display_strings ^ [ #Am09-1 , zbyva , counter_time - tick ] ;
11639: LD_ADDR_OWVAR 47
11643: PUSH
11644: LD_OWVAR 47
11648: PUSH
11649: LD_STRING #Am09-1
11651: PUSH
11652: LD_VAR 0 3
11656: PUSH
11657: LD_EXP 64
11661: PUSH
11662: LD_OWVAR 1
11666: MINUS
11667: PUSH
11668: EMPTY
11669: LIST
11670: LIST
11671: LIST
11672: ADD
11673: ST_TO_ADDR
// if Konec and ( IsOK ( JMM ) ) then
11674: LD_EXP 79
11678: PUSH
11679: LD_EXP 17
11683: PPUSH
11684: CALL_OW 302
11688: AND
11689: IFFALSE 11695
// begin Vyhra ;
11691: CALL 2796 0 0
// end ; if TimerEnable then
11695: LD_EXP 63
11699: IFFALSE 11760
// begin if ContactTime ( russians ) > ( TimerCas + 0 0$45 ) then
11701: LD_EXP 49
11705: PPUSH
11706: CALL_OW 462
11710: PUSH
11711: LD_EXP 81
11715: PUSH
11716: LD_INT 1575
11718: PLUS
11719: GREATER
11720: IFFALSE 11760
// begin if GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and ( IsOK ( JMM ) ) then
11722: LD_EXP 69
11726: PPUSH
11727: CALL_OW 274
11731: PPUSH
11732: LD_INT 3
11734: PPUSH
11735: CALL_OW 275
11739: PUSH
11740: LD_INT 20
11742: GREATEREQUAL
11743: PUSH
11744: LD_EXP 17
11748: PPUSH
11749: CALL_OW 302
11753: AND
11754: IFFALSE 11760
// begin Vyhra ;
11756: CALL 2796 0 0
// end ; end ; end ; if EndEnable then
11760: LD_EXP 80
11764: IFFALSE 11953
// begin if timer < 0 then
11766: LD_EXP 62
11770: PUSH
11771: LD_INT 0
11773: LESS
11774: IFFALSE 11784
// timer := 0 ;
11776: LD_ADDR_EXP 62
11780: PUSH
11781: LD_INT 0
11783: ST_TO_ADDR
// timer := timer - 0 0$1 ;
11784: LD_ADDR_EXP 62
11788: PUSH
11789: LD_EXP 62
11793: PUSH
11794: LD_INT 35
11796: MINUS
11797: ST_TO_ADDR
// if testing then
11798: LD_EXP 4
11802: IFFALSE 11858
// display_strings := display_strings ^ [ [ ( timer div 1 1$0 ) & :  & ( ( timer - ( timer div 1 1$0 ) * 1 1$0 ) div 0 0$1 ) ] ] ;
11804: LD_ADDR_OWVAR 47
11808: PUSH
11809: LD_OWVAR 47
11813: PUSH
11814: LD_EXP 62
11818: PUSH
11819: LD_INT 2100
11821: DIV
11822: PUSH
11823: LD_STRING : 
11825: STR
11826: PUSH
11827: LD_EXP 62
11831: PUSH
11832: LD_EXP 62
11836: PUSH
11837: LD_INT 2100
11839: DIV
11840: PUSH
11841: LD_INT 2100
11843: MUL
11844: MINUS
11845: PUSH
11846: LD_INT 35
11848: DIV
11849: STR
11850: PUSH
11851: EMPTY
11852: LIST
11853: PUSH
11854: EMPTY
11855: LIST
11856: ADD
11857: ST_TO_ADDR
// if not FilterUnitsExceptArea ( exit_area , [ [ f_ok ] , [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] ] ) and GetResourceType ( GetBase ( depot1 ) , mat_siberit ) >= 20 and IsInArea ( JMM , exit_area ) then
11858: LD_INT 32
11860: PPUSH
11861: LD_INT 50
11863: PUSH
11864: EMPTY
11865: LIST
11866: PUSH
11867: LD_INT 22
11869: PUSH
11870: LD_EXP 47
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 23
11881: PUSH
11882: LD_INT 1
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 21
11891: PUSH
11892: LD_INT 1
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: LIST
11903: LIST
11904: PPUSH
11905: CALL_OW 71
11909: NOT
11910: PUSH
11911: LD_EXP 69
11915: PPUSH
11916: CALL_OW 274
11920: PPUSH
11921: LD_INT 3
11923: PPUSH
11924: CALL_OW 275
11928: PUSH
11929: LD_INT 20
11931: GREATEREQUAL
11932: AND
11933: PUSH
11934: LD_EXP 17
11938: PPUSH
11939: LD_INT 32
11941: PPUSH
11942: CALL_OW 308
11946: AND
11947: IFFALSE 11953
// Vyhra ;
11949: CALL 2796 0 0
// end ; enable ;
11953: ENABLE
// end ;
11954: PPOPN 3
11956: END
// var was_QE ; function QE ; begin
11957: LD_INT 0
11959: PPUSH
// was_QE := true ;
11960: LD_ADDR_LOC 1
11964: PUSH
11965: LD_INT 1
11967: ST_TO_ADDR
// if Query ( QE ) = 2 then
11968: LD_STRING QE
11970: PPUSH
11971: CALL_OW 97
11975: PUSH
11976: LD_INT 2
11978: EQUAL
11979: IFFALSE 11985
// Vyhra ;
11981: CALL 2796 0 0
// end ; end_of_file
11985: LD_VAR 0 1
11989: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
11990: LD_INT 0
11992: PPUSH
11993: PPUSH
11994: PPUSH
// see_any_r := false ;
11995: LD_ADDR_VAR 0 5
11999: PUSH
12000: LD_INT 0
12002: ST_TO_ADDR
// for sai in sez2 do
12003: LD_ADDR_VAR 0 4
12007: PUSH
12008: LD_VAR 0 2
12012: PUSH
12013: FOR_IN
12014: IFFALSE 12044
// if See ( strana , sai ) then
12016: LD_VAR 0 1
12020: PPUSH
12021: LD_VAR 0 4
12025: PPUSH
12026: CALL_OW 292
12030: IFFALSE 12042
// begin see_any_r := true ;
12032: LD_ADDR_VAR 0 5
12036: PUSH
12037: LD_INT 1
12039: ST_TO_ADDR
// break ;
12040: GO 12044
// end ;
12042: GO 12013
12044: POP
12045: POP
// ; result := see_any_r ;
12046: LD_ADDR_VAR 0 3
12050: PUSH
12051: LD_VAR 0 5
12055: ST_TO_ADDR
// end ;
12056: LD_VAR 0 3
12060: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
12061: LD_INT 0
12063: PPUSH
12064: PPUSH
12065: PPUSH
12066: PPUSH
// for i in who do
12067: LD_ADDR_VAR 0 6
12071: PUSH
12072: LD_VAR 0 1
12076: PUSH
12077: FOR_IN
12078: IFFALSE 12149
// begin for j in what do
12080: LD_ADDR_VAR 0 7
12084: PUSH
12085: LD_VAR 0 3
12089: PUSH
12090: FOR_IN
12091: IFFALSE 12145
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
12093: LD_VAR 0 7
12097: PPUSH
12098: CALL_OW 311
12102: NOT
12103: PUSH
12104: LD_VAR 0 6
12108: PPUSH
12109: LD_VAR 0 7
12113: PPUSH
12114: CALL_OW 296
12118: PUSH
12119: LD_VAR 0 2
12123: LESSEQUAL
12124: AND
12125: IFFALSE 12143
// begin ComEnterUnit ( i , j ) ;
12127: LD_VAR 0 6
12131: PPUSH
12132: LD_VAR 0 7
12136: PPUSH
12137: CALL_OW 120
// break ;
12141: GO 12145
// end ; end ;
12143: GO 12090
12145: POP
12146: POP
// end ;
12147: GO 12077
12149: POP
12150: POP
// end ;
12151: LD_VAR 0 4
12155: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
12156: LD_INT 0
12158: PPUSH
12159: PPUSH
12160: PPUSH
12161: PPUSH
// for i in who do
12162: LD_ADDR_VAR 0 6
12166: PUSH
12167: LD_VAR 0 1
12171: PUSH
12172: FOR_IN
12173: IFFALSE 12272
// begin add := false ;
12175: LD_ADDR_VAR 0 5
12179: PUSH
12180: LD_INT 0
12182: ST_TO_ADDR
// for j in what do
12183: LD_ADDR_VAR 0 7
12187: PUSH
12188: LD_VAR 0 3
12192: PUSH
12193: FOR_IN
12194: IFFALSE 12228
// begin if GetDistUnits ( i , j ) <= dist then
12196: LD_VAR 0 6
12200: PPUSH
12201: LD_VAR 0 7
12205: PPUSH
12206: CALL_OW 296
12210: PUSH
12211: LD_VAR 0 2
12215: LESSEQUAL
12216: IFFALSE 12226
// begin add := true ;
12218: LD_ADDR_VAR 0 5
12222: PUSH
12223: LD_INT 1
12225: ST_TO_ADDR
// end ; end ;
12226: GO 12193
12228: POP
12229: POP
// if add then
12230: LD_VAR 0 5
12234: IFFALSE 12270
// begin if result then
12236: LD_VAR 0 4
12240: IFFALSE 12260
// result := result ^ i else
12242: LD_ADDR_VAR 0 4
12246: PUSH
12247: LD_VAR 0 4
12251: PUSH
12252: LD_VAR 0 6
12256: ADD
12257: ST_TO_ADDR
12258: GO 12270
// result := i ;
12260: LD_ADDR_VAR 0 4
12264: PUSH
12265: LD_VAR 0 6
12269: ST_TO_ADDR
// end ; end ;
12270: GO 12172
12272: POP
12273: POP
// end ;
12274: LD_VAR 0 4
12278: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
12279: LD_INT 0
12281: PPUSH
12282: PPUSH
12283: PPUSH
// i1 := 1 ;
12284: LD_ADDR_VAR 0 5
12288: PUSH
12289: LD_INT 1
12291: ST_TO_ADDR
// while i1 <= path do
12292: LD_VAR 0 5
12296: PUSH
12297: LD_VAR 0 2
12301: LESSEQUAL
12302: IFFALSE 12549
// begin a := path [ i1 ] ;
12304: LD_ADDR_VAR 0 6
12308: PUSH
12309: LD_VAR 0 2
12313: PUSH
12314: LD_VAR 0 5
12318: ARRAY
12319: ST_TO_ADDR
// if a < 0 then
12320: LD_VAR 0 6
12324: PUSH
12325: LD_INT 0
12327: LESS
12328: IFFALSE 12385
// begin while a <= - 1 do
12330: LD_VAR 0 6
12334: PUSH
12335: LD_INT 1
12337: NEG
12338: LESSEQUAL
12339: IFFALSE 12369
// begin a := a + 1 ;
12341: LD_ADDR_VAR 0 6
12345: PUSH
12346: LD_VAR 0 6
12350: PUSH
12351: LD_INT 1
12353: PLUS
12354: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
12355: LD_VAR 0 1
12359: PPUSH
12360: LD_INT 35
12362: PPUSH
12363: CALL_OW 202
// end ;
12367: GO 12330
// i1 := i1 + 1 ;
12369: LD_ADDR_VAR 0 5
12373: PUSH
12374: LD_VAR 0 5
12378: PUSH
12379: LD_INT 1
12381: PLUS
12382: ST_TO_ADDR
// end else
12383: GO 12547
// begin if a = 0 then
12385: LD_VAR 0 6
12389: PUSH
12390: LD_INT 0
12392: EQUAL
12393: IFFALSE 12455
// begin a := path [ i1 + 1 ] ;
12395: LD_ADDR_VAR 0 6
12399: PUSH
12400: LD_VAR 0 2
12404: PUSH
12405: LD_VAR 0 5
12409: PUSH
12410: LD_INT 1
12412: PLUS
12413: ARRAY
12414: ST_TO_ADDR
// if a = 0 then
12415: LD_VAR 0 6
12419: PUSH
12420: LD_INT 0
12422: EQUAL
12423: IFFALSE 12434
// AddComReturn ( for_units ) ;
12425: LD_VAR 0 1
12429: PPUSH
12430: CALL_OW 204
// if a = 1 then
12434: LD_VAR 0 6
12438: PUSH
12439: LD_INT 1
12441: EQUAL
12442: IFFALSE 12453
// AddComRemember ( for_units ) ;
12444: LD_VAR 0 1
12448: PPUSH
12449: CALL_OW 203
// end else
12453: GO 12533
// begin if agressive then
12455: LD_VAR 0 3
12459: IFFALSE 12498
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
12461: LD_VAR 0 1
12465: PPUSH
12466: LD_VAR 0 2
12470: PUSH
12471: LD_VAR 0 5
12475: ARRAY
12476: PPUSH
12477: LD_VAR 0 2
12481: PUSH
12482: LD_VAR 0 5
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ARRAY
12491: PPUSH
12492: CALL_OW 174
12496: GO 12533
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
12498: LD_VAR 0 1
12502: PPUSH
12503: LD_VAR 0 2
12507: PUSH
12508: LD_VAR 0 5
12512: ARRAY
12513: PPUSH
12514: LD_VAR 0 2
12518: PUSH
12519: LD_VAR 0 5
12523: PUSH
12524: LD_INT 1
12526: PLUS
12527: ARRAY
12528: PPUSH
12529: CALL_OW 171
// end ; i1 := i1 + 2 ;
12533: LD_ADDR_VAR 0 5
12537: PUSH
12538: LD_VAR 0 5
12542: PUSH
12543: LD_INT 2
12545: PLUS
12546: ST_TO_ADDR
// end ; end ;
12547: GO 12292
// end ;
12549: LD_VAR 0 4
12553: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
12554: LD_INT 0
12556: PPUSH
12557: PPUSH
12558: PPUSH
12559: PPUSH
12560: PPUSH
// forts := forts union [ ] ;
12561: LD_ADDR_VAR 0 1
12565: PUSH
12566: LD_VAR 0 1
12570: PUSH
12571: EMPTY
12572: UNION
12573: ST_TO_ADDR
// sols := sols union [ ] ;
12574: LD_ADDR_VAR 0 2
12578: PUSH
12579: LD_VAR 0 2
12583: PUSH
12584: EMPTY
12585: UNION
12586: ST_TO_ADDR
// for i in forts do
12587: LD_ADDR_VAR 0 6
12591: PUSH
12592: LD_VAR 0 1
12596: PUSH
12597: FOR_IN
12598: IFFALSE 12634
// if not UnitsInside ( i ) then
12600: LD_VAR 0 6
12604: PPUSH
12605: CALL_OW 313
12609: NOT
12610: IFFALSE 12632
// empty := add ( empty , i ) ;
12612: LD_ADDR_VAR 0 4
12616: PUSH
12617: LD_VAR 0 4
12621: PPUSH
12622: LD_VAR 0 6
12626: PPUSH
12627: CALL 12953 0 2
12631: ST_TO_ADDR
12632: GO 12597
12634: POP
12635: POP
// for i in sols do
12636: LD_ADDR_VAR 0 6
12640: PUSH
12641: LD_VAR 0 2
12645: PUSH
12646: FOR_IN
12647: IFFALSE 12695
// if not IsInUnit ( i ) and not IsBusy ( i ) then
12649: LD_VAR 0 6
12653: PPUSH
12654: CALL_OW 310
12658: NOT
12659: PUSH
12660: LD_VAR 0 6
12664: PPUSH
12665: CALL_OW 315
12669: NOT
12670: AND
12671: IFFALSE 12693
// free := add ( free , i ) ;
12673: LD_ADDR_VAR 0 5
12677: PUSH
12678: LD_VAR 0 5
12682: PPUSH
12683: LD_VAR 0 6
12687: PPUSH
12688: CALL 12953 0 2
12692: ST_TO_ADDR
12693: GO 12646
12695: POP
12696: POP
// result := forts diff empty ;
12697: LD_ADDR_VAR 0 3
12701: PUSH
12702: LD_VAR 0 1
12706: PUSH
12707: LD_VAR 0 4
12711: DIFF
12712: ST_TO_ADDR
// if empty <= free then
12713: LD_VAR 0 4
12717: PUSH
12718: LD_VAR 0 5
12722: LESSEQUAL
12723: IFFALSE 12737
// konec := empty else
12725: LD_ADDR_VAR 0 7
12729: PUSH
12730: LD_VAR 0 4
12734: ST_TO_ADDR
12735: GO 12747
// konec := free ;
12737: LD_ADDR_VAR 0 7
12741: PUSH
12742: LD_VAR 0 5
12746: ST_TO_ADDR
// for i := 1 to konec do
12747: LD_ADDR_VAR 0 6
12751: PUSH
12752: DOUBLE
12753: LD_INT 1
12755: DEC
12756: ST_TO_ADDR
12757: LD_VAR 0 7
12761: PUSH
12762: FOR_TO
12763: IFFALSE 12819
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
12765: LD_VAR 0 5
12769: PUSH
12770: LD_VAR 0 6
12774: ARRAY
12775: PPUSH
12776: LD_VAR 0 4
12780: PUSH
12781: LD_VAR 0 6
12785: ARRAY
12786: PPUSH
12787: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PPUSH
12801: LD_VAR 0 4
12805: PUSH
12806: LD_VAR 0 6
12810: ARRAY
12811: PPUSH
12812: CALL 12953 0 2
12816: ST_TO_ADDR
// end ;
12817: GO 12762
12819: POP
12820: POP
// end ;
12821: LD_VAR 0 3
12825: RET
// export function TalkOn ; begin
12826: LD_INT 0
12828: PPUSH
// end ;
12829: LD_VAR 0 1
12833: RET
// export function TalkOff ; begin
12834: LD_INT 0
12836: PPUSH
// end ;
12837: LD_VAR 0 1
12841: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
12842: LD_INT 0
12844: PPUSH
12845: PPUSH
12846: PPUSH
12847: PPUSH
// l1 := [ ] ;
12848: LD_ADDR_VAR 0 3
12852: PUSH
12853: EMPTY
12854: ST_TO_ADDR
// l2 := [ ] ;
12855: LD_ADDR_VAR 0 4
12859: PUSH
12860: EMPTY
12861: ST_TO_ADDR
// for i := 1 to list div 2 do
12862: LD_ADDR_VAR 0 5
12866: PUSH
12867: DOUBLE
12868: LD_INT 1
12870: DEC
12871: ST_TO_ADDR
12872: LD_VAR 0 1
12876: PUSH
12877: LD_INT 2
12879: DIV
12880: PUSH
12881: FOR_TO
12882: IFFALSE 12908
// begin l1 := l1 ^ list [ i ] ;
12884: LD_ADDR_VAR 0 3
12888: PUSH
12889: LD_VAR 0 3
12893: PUSH
12894: LD_VAR 0 1
12898: PUSH
12899: LD_VAR 0 5
12903: ARRAY
12904: ADD
12905: ST_TO_ADDR
// end ;
12906: GO 12881
12908: POP
12909: POP
// l2 := list diff l1 ;
12910: LD_ADDR_VAR 0 4
12914: PUSH
12915: LD_VAR 0 1
12919: PUSH
12920: LD_VAR 0 3
12924: DIFF
12925: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_VAR 0 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: PUSH
12939: LD_VAR 0 4
12943: PUSH
12944: EMPTY
12945: LIST
12946: ADD
12947: ST_TO_ADDR
// end ;
12948: LD_VAR 0 2
12952: RET
// export function add ( list , list1 ) ; begin
12953: LD_INT 0
12955: PPUSH
// if list = 0 then
12956: LD_VAR 0 1
12960: PUSH
12961: LD_INT 0
12963: EQUAL
12964: IFFALSE 12973
// list := [ ] ;
12966: LD_ADDR_VAR 0 1
12970: PUSH
12971: EMPTY
12972: ST_TO_ADDR
// if list1 = 0 then
12973: LD_VAR 0 2
12977: PUSH
12978: LD_INT 0
12980: EQUAL
12981: IFFALSE 12990
// list1 := [ ] ;
12983: LD_ADDR_VAR 0 2
12987: PUSH
12988: EMPTY
12989: ST_TO_ADDR
// result := list ^ list1 ;
12990: LD_ADDR_VAR 0 3
12994: PUSH
12995: LD_VAR 0 1
12999: PUSH
13000: LD_VAR 0 2
13004: ADD
13005: ST_TO_ADDR
// end ;
13006: LD_VAR 0 3
13010: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
13011: LD_INT 0
13013: PPUSH
13014: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
13015: LD_ADDR_VAR 0 8
13019: PUSH
13020: LD_VAR 0 1
13024: PPUSH
13025: LD_VAR 0 3
13029: PPUSH
13030: LD_VAR 0 4
13034: PPUSH
13035: LD_VAR 0 5
13039: PPUSH
13040: LD_VAR 0 6
13044: PPUSH
13045: CALL 13091 0 5
13049: ST_TO_ADDR
// if kdo then
13050: LD_VAR 0 8
13054: IFFALSE 13078
// result := Say ( kdo , ident ) else
13056: LD_ADDR_VAR 0 7
13060: PUSH
13061: LD_VAR 0 8
13065: PPUSH
13066: LD_VAR 0 2
13070: PPUSH
13071: CALL_OW 88
13075: ST_TO_ADDR
13076: GO 13086
// result := false ;
13078: LD_ADDR_VAR 0 7
13082: PUSH
13083: LD_INT 0
13085: ST_TO_ADDR
// end ;
13086: LD_VAR 0 7
13090: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
13091: LD_INT 0
13093: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
13094: LD_ADDR_VAR 0 1
13098: PUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: LD_INT 21
13106: PUSH
13107: LD_INT 1
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 22
13116: PUSH
13117: LD_VAR 0 2
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PUSH
13126: LD_INT 3
13128: PUSH
13129: LD_INT 23
13131: PUSH
13132: LD_INT 0
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PPUSH
13145: CALL_OW 72
13149: ST_TO_ADDR
// if sex <> 0 then
13150: LD_VAR 0 3
13154: PUSH
13155: LD_INT 0
13157: NONEQUAL
13158: IFFALSE 13187
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_VAR 0 1
13169: PPUSH
13170: LD_INT 26
13172: PUSH
13173: LD_VAR 0 3
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: PPUSH
13182: CALL_OW 72
13186: ST_TO_ADDR
// if Hclass <> 0 then
13187: LD_VAR 0 4
13191: PUSH
13192: LD_INT 0
13194: NONEQUAL
13195: IFFALSE 13224
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
13197: LD_ADDR_VAR 0 1
13201: PUSH
13202: LD_VAR 0 1
13206: PPUSH
13207: LD_INT 25
13209: PUSH
13210: LD_VAR 0 4
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: PPUSH
13219: CALL_OW 72
13223: ST_TO_ADDR
// if index <= 0 then
13224: LD_VAR 0 5
13228: PUSH
13229: LD_INT 0
13231: LESSEQUAL
13232: IFFALSE 13242
// index := 1 ;
13234: LD_ADDR_VAR 0 5
13238: PUSH
13239: LD_INT 1
13241: ST_TO_ADDR
// if lidi >= index then
13242: LD_VAR 0 1
13246: PUSH
13247: LD_VAR 0 5
13251: GREATEREQUAL
13252: IFFALSE 13272
// result := lidi [ index ] else
13254: LD_ADDR_VAR 0 6
13258: PUSH
13259: LD_VAR 0 1
13263: PUSH
13264: LD_VAR 0 5
13268: ARRAY
13269: ST_TO_ADDR
13270: GO 13280
// result := 0 ;
13272: LD_ADDR_VAR 0 6
13276: PUSH
13277: LD_INT 0
13279: ST_TO_ADDR
// end ;
13280: LD_VAR 0 6
13284: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
13285: LD_INT 0
13287: PPUSH
13288: PPUSH
13289: PPUSH
// result := [ ] ;
13290: LD_ADDR_VAR 0 3
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: LD_VAR 0 1
13306: PPUSH
13307: EMPTY
13308: PPUSH
13309: CALL_OW 70
13313: ST_TO_ADDR
// for i in inbase do
13314: LD_ADDR_VAR 0 5
13318: PUSH
13319: LD_VAR 0 4
13323: PUSH
13324: FOR_IN
13325: IFFALSE 13398
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
13327: LD_VAR 0 5
13331: PPUSH
13332: CALL_OW 247
13336: PUSH
13337: LD_INT 3
13339: EQUAL
13340: PUSH
13341: LD_VAR 0 5
13345: PPUSH
13346: CALL_OW 247
13350: PUSH
13351: LD_INT 2
13353: EQUAL
13354: OR
13355: IFFALSE 13380
// begin result := result ^ UnitsInside ( i ) ;
13357: LD_ADDR_VAR 0 3
13361: PUSH
13362: LD_VAR 0 3
13366: PUSH
13367: LD_VAR 0 5
13371: PPUSH
13372: CALL_OW 313
13376: ADD
13377: ST_TO_ADDR
// end else
13378: GO 13396
// begin result := result ^ i ;
13380: LD_ADDR_VAR 0 3
13384: PUSH
13385: LD_VAR 0 3
13389: PUSH
13390: LD_VAR 0 5
13394: ADD
13395: ST_TO_ADDR
// end ; end ;
13396: GO 13324
13398: POP
13399: POP
// result := UnitFilter ( result , filter ) ;
13400: LD_ADDR_VAR 0 3
13404: PUSH
13405: LD_VAR 0 3
13409: PPUSH
13410: LD_VAR 0 2
13414: PPUSH
13415: CALL_OW 72
13419: ST_TO_ADDR
// end ;
13420: LD_VAR 0 3
13424: RET
// export function ReverseList ( list ) ; var i ; begin
13425: LD_INT 0
13427: PPUSH
13428: PPUSH
// result := [ ] ;
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: EMPTY
13435: ST_TO_ADDR
// for i := list + 0 downto 1 do
13436: LD_ADDR_VAR 0 3
13440: PUSH
13441: DOUBLE
13442: LD_VAR 0 1
13446: PUSH
13447: LD_INT 0
13449: PLUS
13450: INC
13451: ST_TO_ADDR
13452: LD_INT 1
13454: PUSH
13455: FOR_DOWNTO
13456: IFFALSE 13485
// begin result := result ^ [ list [ i ] ] ;
13458: LD_ADDR_VAR 0 2
13462: PUSH
13463: LD_VAR 0 2
13467: PUSH
13468: LD_VAR 0 1
13472: PUSH
13473: LD_VAR 0 3
13477: ARRAY
13478: PUSH
13479: EMPTY
13480: LIST
13481: ADD
13482: ST_TO_ADDR
// end ;
13483: GO 13455
13485: POP
13486: POP
// end ;
13487: LD_VAR 0 2
13491: RET
// export using8 , using1 , using2 , using3 ; export path8 , path1 , path2 , path3 ; export kdo8 , kdo1 , kdo2 , kdo3 ; export using4 , using5 , using6 , using7 ; export path4 , path5 , path6 , path7 ; export kdo4 , kdo5 , kdo6 , kdo7 ; export function attack ( kdo , path ) ; var i , a ; begin
13492: LD_INT 0
13494: PPUSH
13495: PPUSH
13496: PPUSH
// for i in kdo do
13497: LD_ADDR_VAR 0 4
13501: PUSH
13502: LD_VAR 0 1
13506: PUSH
13507: FOR_IN
13508: IFFALSE 13524
// begin SetTag ( i , 1 ) ;
13510: LD_VAR 0 4
13514: PPUSH
13515: LD_INT 1
13517: PPUSH
13518: CALL_OW 109
// end ;
13522: GO 13507
13524: POP
13525: POP
// while kdo do
13526: LD_VAR 0 1
13530: IFFALSE 13825
// begin for i in kdo do
13532: LD_ADDR_VAR 0 4
13536: PUSH
13537: LD_VAR 0 1
13541: PUSH
13542: FOR_IN
13543: IFFALSE 13814
// begin a := GetTag ( i ) ;
13545: LD_ADDR_VAR 0 5
13549: PUSH
13550: LD_VAR 0 4
13554: PPUSH
13555: CALL_OW 110
13559: ST_TO_ADDR
// if a <= path then
13560: LD_VAR 0 5
13564: PUSH
13565: LD_VAR 0 2
13569: LESSEQUAL
13570: IFFALSE 13798
// begin if not IsDead ( i ) then
13572: LD_VAR 0 4
13576: PPUSH
13577: CALL_OW 301
13581: NOT
13582: IFFALSE 13756
// begin if IsIdle ( i ) then
13584: LD_VAR 0 4
13588: PPUSH
13589: CALL_OW 316
13593: IFFALSE 13754
// begin if a = 1 then
13595: LD_VAR 0 5
13599: PUSH
13600: LD_INT 1
13602: EQUAL
13603: IFFALSE 13644
// begin ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13605: LD_VAR 0 4
13609: PPUSH
13610: LD_VAR 0 2
13614: PUSH
13615: LD_VAR 0 5
13619: ARRAY
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PPUSH
13625: LD_VAR 0 2
13629: PUSH
13630: LD_VAR 0 5
13634: ARRAY
13635: PUSH
13636: LD_INT 2
13638: ARRAY
13639: PPUSH
13640: CALL_OW 114
// end ; if GetDistUnitXY ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) < 5 then
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 2
13653: PUSH
13654: LD_VAR 0 5
13658: ARRAY
13659: PUSH
13660: LD_INT 1
13662: ARRAY
13663: PPUSH
13664: LD_VAR 0 2
13668: PUSH
13669: LD_VAR 0 5
13673: ARRAY
13674: PUSH
13675: LD_INT 2
13677: ARRAY
13678: PPUSH
13679: CALL_OW 297
13683: PUSH
13684: LD_INT 5
13686: LESS
13687: IFFALSE 13754
// begin a := a + 1 ;
13689: LD_ADDR_VAR 0 5
13693: PUSH
13694: LD_VAR 0 5
13698: PUSH
13699: LD_INT 1
13701: PLUS
13702: ST_TO_ADDR
// if a <= path then
13703: LD_VAR 0 5
13707: PUSH
13708: LD_VAR 0 2
13712: LESSEQUAL
13713: IFFALSE 13754
// ComAgressiveMove ( i , path [ a ] [ 1 ] , path [ a ] [ 2 ] ) ;
13715: LD_VAR 0 4
13719: PPUSH
13720: LD_VAR 0 2
13724: PUSH
13725: LD_VAR 0 5
13729: ARRAY
13730: PUSH
13731: LD_INT 1
13733: ARRAY
13734: PPUSH
13735: LD_VAR 0 2
13739: PUSH
13740: LD_VAR 0 5
13744: ARRAY
13745: PUSH
13746: LD_INT 2
13748: ARRAY
13749: PPUSH
13750: CALL_OW 114
// end ; end ; end else
13754: GO 13770
// a := a + 1 ;
13756: LD_ADDR_VAR 0 5
13760: PUSH
13761: LD_VAR 0 5
13765: PUSH
13766: LD_INT 1
13768: PLUS
13769: ST_TO_ADDR
// if a > path then
13770: LD_VAR 0 5
13774: PUSH
13775: LD_VAR 0 2
13779: GREATER
13780: IFFALSE 13798
// kdo := kdo diff i ;
13782: LD_ADDR_VAR 0 1
13786: PUSH
13787: LD_VAR 0 1
13791: PUSH
13792: LD_VAR 0 4
13796: DIFF
13797: ST_TO_ADDR
// end ; SetTag ( i , a ) ;
13798: LD_VAR 0 4
13802: PPUSH
13803: LD_VAR 0 5
13807: PPUSH
13808: CALL_OW 109
// end ;
13812: GO 13542
13814: POP
13815: POP
// wait ( 0 0$1 ) ;
13816: LD_INT 35
13818: PPUSH
13819: CALL_OW 67
// end ;
13823: GO 13526
// end ;
13825: LD_VAR 0 3
13829: RET
// export function AttackBase ( kdo , path ) ; begin
13830: LD_INT 0
13832: PPUSH
// case false of using1 :
13833: LD_INT 0
13835: PUSH
13836: LD_EXP 83
13840: DOUBLE
13841: EQUAL
13842: IFTRUE 13846
13844: GO 13876
13846: POP
// begin kdo1 := kdo ;
13847: LD_ADDR_EXP 91
13851: PUSH
13852: LD_VAR 0 1
13856: ST_TO_ADDR
// path1 := path ;
13857: LD_ADDR_EXP 87
13861: PUSH
13862: LD_VAR 0 2
13866: ST_TO_ADDR
// RaiseSailEvent ( 1 ) ;
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 427
// end ; using2 :
13874: GO 14157
13876: LD_EXP 84
13880: DOUBLE
13881: EQUAL
13882: IFTRUE 13886
13884: GO 13916
13886: POP
// begin kdo2 := kdo ;
13887: LD_ADDR_EXP 92
13891: PUSH
13892: LD_VAR 0 1
13896: ST_TO_ADDR
// path2 := path ;
13897: LD_ADDR_EXP 88
13901: PUSH
13902: LD_VAR 0 2
13906: ST_TO_ADDR
// RaiseSailEvent ( 2 ) ;
13907: LD_INT 2
13909: PPUSH
13910: CALL_OW 427
// end ; using3 :
13914: GO 14157
13916: LD_EXP 85
13920: DOUBLE
13921: EQUAL
13922: IFTRUE 13926
13924: GO 13956
13926: POP
// begin kdo3 := kdo ;
13927: LD_ADDR_EXP 93
13931: PUSH
13932: LD_VAR 0 1
13936: ST_TO_ADDR
// path3 := path ;
13937: LD_ADDR_EXP 89
13941: PUSH
13942: LD_VAR 0 2
13946: ST_TO_ADDR
// RaiseSailEvent ( 3 ) ;
13947: LD_INT 3
13949: PPUSH
13950: CALL_OW 427
// end ; using4 :
13954: GO 14157
13956: LD_EXP 94
13960: DOUBLE
13961: EQUAL
13962: IFTRUE 13966
13964: GO 13996
13966: POP
// begin kdo4 := kdo ;
13967: LD_ADDR_EXP 102
13971: PUSH
13972: LD_VAR 0 1
13976: ST_TO_ADDR
// path4 := path ;
13977: LD_ADDR_EXP 98
13981: PUSH
13982: LD_VAR 0 2
13986: ST_TO_ADDR
// RaiseSailEvent ( 4 ) ;
13987: LD_INT 4
13989: PPUSH
13990: CALL_OW 427
// end ; using5 :
13994: GO 14157
13996: LD_EXP 95
14000: DOUBLE
14001: EQUAL
14002: IFTRUE 14006
14004: GO 14036
14006: POP
// begin kdo5 := kdo ;
14007: LD_ADDR_EXP 103
14011: PUSH
14012: LD_VAR 0 1
14016: ST_TO_ADDR
// path5 := path ;
14017: LD_ADDR_EXP 99
14021: PUSH
14022: LD_VAR 0 2
14026: ST_TO_ADDR
// RaiseSailEvent ( 5 ) ;
14027: LD_INT 5
14029: PPUSH
14030: CALL_OW 427
// end ; using6 :
14034: GO 14157
14036: LD_EXP 96
14040: DOUBLE
14041: EQUAL
14042: IFTRUE 14046
14044: GO 14076
14046: POP
// begin kdo6 := kdo ;
14047: LD_ADDR_EXP 104
14051: PUSH
14052: LD_VAR 0 1
14056: ST_TO_ADDR
// path6 := path ;
14057: LD_ADDR_EXP 100
14061: PUSH
14062: LD_VAR 0 2
14066: ST_TO_ADDR
// RaiseSailEvent ( 6 ) ;
14067: LD_INT 6
14069: PPUSH
14070: CALL_OW 427
// end ; using7 :
14074: GO 14157
14076: LD_EXP 97
14080: DOUBLE
14081: EQUAL
14082: IFTRUE 14086
14084: GO 14116
14086: POP
// begin kdo7 := kdo ;
14087: LD_ADDR_EXP 105
14091: PUSH
14092: LD_VAR 0 1
14096: ST_TO_ADDR
// path7 := path ;
14097: LD_ADDR_EXP 101
14101: PUSH
14102: LD_VAR 0 2
14106: ST_TO_ADDR
// RaiseSailEvent ( 7 ) ;
14107: LD_INT 7
14109: PPUSH
14110: CALL_OW 427
// end ; using8 :
14114: GO 14157
14116: LD_EXP 82
14120: DOUBLE
14121: EQUAL
14122: IFTRUE 14126
14124: GO 14156
14126: POP
// begin kdo8 := kdo ;
14127: LD_ADDR_EXP 90
14131: PUSH
14132: LD_VAR 0 1
14136: ST_TO_ADDR
// path8 := path ;
14137: LD_ADDR_EXP 86
14141: PUSH
14142: LD_VAR 0 2
14146: ST_TO_ADDR
// RaiseSailEvent ( 8 ) ;
14147: LD_INT 8
14149: PPUSH
14150: CALL_OW 427
// end ; end ;
14154: GO 14157
14156: POP
// end ;
14157: LD_VAR 0 3
14161: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
14162: LD_INT 0
14164: PPUSH
// if not hinty_co_byli then
14165: LD_EXP 106
14169: NOT
14170: IFFALSE 14179
// hinty_co_byli := [ ] ;
14172: LD_ADDR_EXP 106
14176: PUSH
14177: EMPTY
14178: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
14179: LD_VAR 0 1
14183: PUSH
14184: LD_EXP 106
14188: IN
14189: NOT
14190: IFFALSE 14217
// begin hinty_co_byli := hinty_co_byli ^ ident ;
14192: LD_ADDR_EXP 106
14196: PUSH
14197: LD_EXP 106
14201: PUSH
14202: LD_VAR 0 1
14206: ADD
14207: ST_TO_ADDR
// Hint ( ident ) ;
14208: LD_VAR 0 1
14212: PPUSH
14213: CALL_OW 339
// end ; end ; end_of_file
14217: LD_VAR 0 2
14221: RET
// every 0 0$0.3 trigger FilterUnitsInArea ( at_mine , [ [ f_side , you ] , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ] ) do var a ;
14222: LD_INT 20
14224: PPUSH
14225: LD_INT 22
14227: PUSH
14228: LD_EXP 47
14232: PUSH
14233: EMPTY
14234: LIST
14235: LIST
14236: PUSH
14237: LD_INT 2
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 44
14245: PUSH
14246: EMPTY
14247: LIST
14248: LIST
14249: PUSH
14250: LD_INT 34
14252: PUSH
14253: LD_INT 45
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: PUSH
14260: LD_INT 34
14262: PUSH
14263: LD_INT 46
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PPUSH
14280: CALL_OW 70
14284: IFFALSE 14370
14286: GO 14288
14288: DISABLE
14289: LD_INT 0
14291: PPUSH
// begin if IsLive ( rumine1 ) then
14292: LD_EXP 68
14296: PPUSH
14297: CALL_OW 300
14301: IFFALSE 14369
// begin a := FilterUnitsInArea ( at_mine , [ f_or , [ f_weapon , ru_gun ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ru_heavy_gun ] ] ) ;
14303: LD_ADDR_VAR 0 1
14307: PUSH
14308: LD_INT 20
14310: PPUSH
14311: LD_INT 2
14313: PUSH
14314: LD_INT 34
14316: PUSH
14317: LD_INT 44
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: PUSH
14324: LD_INT 34
14326: PUSH
14327: LD_INT 45
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 34
14336: PUSH
14337: LD_INT 46
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: PPUSH
14350: CALL_OW 70
14354: ST_TO_ADDR
// ComAttackUnit ( a , rumine1 ) ;
14355: LD_VAR 0 1
14359: PPUSH
14360: LD_EXP 68
14364: PPUSH
14365: CALL_OW 115
// end ; enable ;
14369: ENABLE
// end ;
14370: PPOPN 1
14372: END
// export function rep_car ( i ) ; begin
14373: LD_INT 0
14375: PPUSH
// case true of IsInArea ( i , NearL ) :
14376: LD_INT 1
14378: PUSH
14379: LD_VAR 0 1
14383: PPUSH
14384: LD_INT 16
14386: PPUSH
14387: CALL_OW 308
14391: DOUBLE
14392: EQUAL
14393: IFTRUE 14397
14395: GO 14412
14397: POP
// ComMoveToArea ( i , repL ) ; IsInArea ( i , NearM ) :
14398: LD_VAR 0 1
14402: PPUSH
14403: LD_INT 24
14405: PPUSH
14406: CALL_OW 113
14410: GO 14512
14412: LD_VAR 0 1
14416: PPUSH
14417: LD_INT 17
14419: PPUSH
14420: CALL_OW 308
14424: DOUBLE
14425: EQUAL
14426: IFTRUE 14430
14428: GO 14445
14430: POP
// ComMoveToArea ( i , repM ) ; IsInArea ( i , NearR ) :
14431: LD_VAR 0 1
14435: PPUSH
14436: LD_INT 25
14438: PPUSH
14439: CALL_OW 113
14443: GO 14512
14445: LD_VAR 0 1
14449: PPUSH
14450: LD_INT 18
14452: PPUSH
14453: CALL_OW 308
14457: DOUBLE
14458: EQUAL
14459: IFTRUE 14463
14461: GO 14478
14463: POP
// ComMoveToArea ( i , repR ) ; IsInArea ( i , NearT ) :
14464: LD_VAR 0 1
14468: PPUSH
14469: LD_INT 26
14471: PPUSH
14472: CALL_OW 113
14476: GO 14512
14478: LD_VAR 0 1
14482: PPUSH
14483: LD_INT 19
14485: PPUSH
14486: CALL_OW 308
14490: DOUBLE
14491: EQUAL
14492: IFTRUE 14496
14494: GO 14511
14496: POP
// ComMoveToArea ( i , repL ) ; end ;
14497: LD_VAR 0 1
14501: PPUSH
14502: LD_INT 24
14504: PPUSH
14505: CALL_OW 113
14509: GO 14512
14511: POP
// while not IsIdle ( i ) do
14512: LD_VAR 0 1
14516: PPUSH
14517: CALL_OW 316
14521: NOT
14522: IFFALSE 14533
// wait ( 0 0$1 ) ;
14524: LD_INT 35
14526: PPUSH
14527: CALL_OW 67
14531: GO 14512
// AddComExitVehicle ( UnitsInside ( i ) ) ;
14533: LD_VAR 0 1
14537: PPUSH
14538: CALL_OW 313
14542: PPUSH
14543: CALL_OW 181
// end ;
14547: LD_VAR 0 2
14551: RET
// export function ret_car ( i ) ; begin
14552: LD_INT 0
14554: PPUSH
// ComEnterUnit ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) , i ) , i ) ;
14555: LD_INT 22
14557: PUSH
14558: LD_EXP 49
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 21
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 69
14585: PPUSH
14586: LD_VAR 0 1
14590: PPUSH
14591: CALL_OW 74
14595: PPUSH
14596: LD_VAR 0 1
14600: PPUSH
14601: CALL_OW 120
// while not UnitsInside ( i ) do
14605: LD_VAR 0 1
14609: PPUSH
14610: CALL_OW 313
14614: NOT
14615: IFFALSE 14626
// wait ( 0 0$1 ) ;
14617: LD_INT 35
14619: PPUSH
14620: CALL_OW 67
14624: GO 14605
// ComAgressiveMove ( i , 92 , 92 ) ;
14626: LD_VAR 0 1
14630: PPUSH
14631: LD_INT 92
14633: PPUSH
14634: LD_INT 92
14636: PPUSH
14637: CALL_OW 114
// end ;
14641: LD_VAR 0 2
14645: RET
// every 0 0$1 do var vehs , i ;
14646: GO 14648
14648: DISABLE
14649: LD_INT 0
14651: PPUSH
14652: PPUSH
// begin vehs := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
14653: LD_ADDR_VAR 0 1
14657: PUSH
14658: LD_INT 22
14660: PUSH
14661: LD_EXP 49
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: LD_INT 21
14672: PUSH
14673: LD_INT 2
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: ST_TO_ADDR
// for i in vehs do
14689: LD_ADDR_VAR 0 2
14693: PUSH
14694: LD_VAR 0 1
14698: PUSH
14699: FOR_IN
14700: IFFALSE 14792
// begin if GetClass ( UnitsInside ( i ) ) = class_mechanic then
14702: LD_VAR 0 2
14706: PPUSH
14707: CALL_OW 313
14711: PPUSH
14712: CALL_OW 257
14716: PUSH
14717: LD_INT 3
14719: EQUAL
14720: IFFALSE 14790
// begin if GetLives ( i ) < 600 then
14722: LD_VAR 0 2
14726: PPUSH
14727: CALL_OW 256
14731: PUSH
14732: LD_INT 600
14734: LESS
14735: IFFALSE 14750
// RaiseSailEvent ( i + 1000 ) ;
14737: LD_VAR 0 2
14741: PUSH
14742: LD_INT 1000
14744: PLUS
14745: PPUSH
14746: CALL_OW 427
// if GetLives ( i ) > 900 and not UnitsInside ( i ) then
14750: LD_VAR 0 2
14754: PPUSH
14755: CALL_OW 256
14759: PUSH
14760: LD_INT 900
14762: GREATER
14763: PUSH
14764: LD_VAR 0 2
14768: PPUSH
14769: CALL_OW 313
14773: NOT
14774: AND
14775: IFFALSE 14790
// RaiseSailEvent ( i + 2000 ) ;
14777: LD_VAR 0 2
14781: PUSH
14782: LD_INT 2000
14784: PLUS
14785: PPUSH
14786: CALL_OW 427
// end ; end ;
14790: GO 14699
14792: POP
14793: POP
// enable ;
14794: ENABLE
// end ;
14795: PPOPN 2
14797: END
// every 10 10$0 trigger utocit do var u1 , u2 , p1 , i , b1 ;
14798: LD_EXP 2
14802: IFFALSE 15280
14804: GO 14806
14806: DISABLE
14807: LD_INT 0
14809: PPUSH
14810: PPUSH
14811: PPUSH
14812: PPUSH
14813: PPUSH
// begin case difficulty of 1 :
14814: LD_OWVAR 67
14818: PUSH
14819: LD_INT 1
14821: DOUBLE
14822: EQUAL
14823: IFTRUE 14827
14825: GO 14892
14827: POP
// begin u1 := CreateVH ( [ mhmg , mhmg ] ) ;
14828: LD_ADDR_VAR 0 1
14832: PUSH
14833: LD_EXP 9
14837: PUSH
14838: LD_EXP 9
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PPUSH
14847: CALL 23118 0 1
14851: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
14852: LD_ADDR_VAR 0 3
14856: PUSH
14857: LD_INT 1
14859: PPUSH
14860: LD_INT 1
14862: PPUSH
14863: CALL 22665 0 2
14867: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
14868: LD_ADDR_VAR 0 5
14872: PUSH
14873: LD_INT 2
14875: PPUSH
14876: CALL 22870 0 1
14880: PUSH
14881: LD_INT 1
14883: PPUSH
14884: CALL 22994 0 1
14888: ADD
14889: ST_TO_ADDR
// end ; 2 :
14890: GO 15051
14892: LD_INT 2
14894: DOUBLE
14895: EQUAL
14896: IFTRUE 14900
14898: GO 14965
14900: POP
// begin u1 := CreateVH ( [ mhmg , mgg ] ) ;
14901: LD_ADDR_VAR 0 1
14905: PUSH
14906: LD_EXP 9
14910: PUSH
14911: LD_EXP 10
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PPUSH
14920: CALL 23118 0 1
14924: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
14925: LD_ADDR_VAR 0 3
14929: PUSH
14930: LD_INT 2
14932: PPUSH
14933: LD_INT 0
14935: PPUSH
14936: CALL 22665 0 2
14940: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
14941: LD_ADDR_VAR 0 5
14945: PUSH
14946: LD_INT 3
14948: PPUSH
14949: CALL 22870 0 1
14953: PUSH
14954: LD_INT 2
14956: PPUSH
14957: CALL 22994 0 1
14961: ADD
14962: ST_TO_ADDR
// end ; 3 :
14963: GO 15051
14965: LD_INT 3
14967: DOUBLE
14968: EQUAL
14969: IFTRUE 14973
14971: GO 15050
14973: POP
// begin u1 := CreateVH ( [ mgg ] ) ;
14974: LD_ADDR_VAR 0 1
14978: PUSH
14979: LD_EXP 10
14983: PUSH
14984: EMPTY
14985: LIST
14986: PPUSH
14987: CALL 23118 0 1
14991: ST_TO_ADDR
// u2 := CreateVC ( [ mgg ] ) ;
14992: LD_ADDR_VAR 0 2
14996: PUSH
14997: LD_EXP 10
15001: PUSH
15002: EMPTY
15003: LIST
15004: PPUSH
15005: CALL 23444 0 1
15009: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_INT 1
15017: PPUSH
15018: LD_INT 0
15020: PPUSH
15021: CALL 22665 0 2
15025: ST_TO_ADDR
// b1 := CreateB ( 5 ) ^ CreateS ( 3 ) ;
15026: LD_ADDR_VAR 0 5
15030: PUSH
15031: LD_INT 5
15033: PPUSH
15034: CALL 22870 0 1
15038: PUSH
15039: LD_INT 3
15041: PPUSH
15042: CALL 22994 0 1
15046: ADD
15047: ST_TO_ADDR
// end ; end ;
15048: GO 15051
15050: POP
// for i := 1 to u1 do
15051: LD_ADDR_VAR 0 4
15055: PUSH
15056: DOUBLE
15057: LD_INT 1
15059: DEC
15060: ST_TO_ADDR
15061: LD_VAR 0 1
15065: PUSH
15066: FOR_TO
15067: IFFALSE 15097
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15069: LD_VAR 0 3
15073: PUSH
15074: LD_VAR 0 4
15078: ARRAY
15079: PPUSH
15080: LD_VAR 0 1
15084: PUSH
15085: LD_VAR 0 4
15089: ARRAY
15090: PPUSH
15091: CALL_OW 52
// end ;
15095: GO 15066
15097: POP
15098: POP
// for i in u1 do
15099: LD_ADDR_VAR 0 4
15103: PUSH
15104: LD_VAR 0 1
15108: PUSH
15109: FOR_IN
15110: IFFALSE 15129
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15112: LD_VAR 0 4
15116: PPUSH
15117: LD_INT 3
15119: PPUSH
15120: LD_INT 0
15122: PPUSH
15123: CALL 23774 0 3
// end ;
15127: GO 15109
15129: POP
15130: POP
// for i in u2 do
15131: LD_ADDR_VAR 0 4
15135: PUSH
15136: LD_VAR 0 2
15140: PUSH
15141: FOR_IN
15142: IFFALSE 15161
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
15144: LD_VAR 0 4
15148: PPUSH
15149: LD_INT 3
15151: PPUSH
15152: LD_INT 0
15154: PPUSH
15155: CALL 23774 0 3
// end ;
15159: GO 15141
15161: POP
15162: POP
// wait ( 0 0$1 ) ;
15163: LD_INT 35
15165: PPUSH
15166: CALL_OW 67
// AttackBase ( u1 ^ u2 , pathBL ^ pathUL ) ;
15170: LD_VAR 0 1
15174: PUSH
15175: LD_VAR 0 2
15179: ADD
15180: PPUSH
15181: LD_EXP 108
15185: PUSH
15186: LD_EXP 111
15190: ADD
15191: PPUSH
15192: CALL 13830 0 2
// for i in b1 do
15196: LD_ADDR_VAR 0 4
15200: PUSH
15201: LD_VAR 0 5
15205: PUSH
15206: FOR_IN
15207: IFFALSE 15226
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15209: LD_VAR 0 4
15213: PPUSH
15214: LD_INT 14
15216: PPUSH
15217: LD_INT 0
15219: PPUSH
15220: CALL 23774 0 3
// end ;
15224: GO 15206
15226: POP
15227: POP
// wait ( 0 0$1 ) ;
15228: LD_INT 35
15230: PPUSH
15231: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15235: LD_VAR 0 5
15239: PPUSH
15240: LD_EXP 118
15244: PPUSH
15245: CALL 13830 0 2
// while not ContactTime ( [ russians ] ) do
15249: LD_EXP 49
15253: PUSH
15254: EMPTY
15255: LIST
15256: PPUSH
15257: CALL_OW 462
15261: NOT
15262: IFFALSE 15273
// wait ( 0 0$1 ) ;
15264: LD_INT 35
15266: PPUSH
15267: CALL_OW 67
15271: GO 15249
// MyHint ( PriorityAttacks ) ;
15273: LD_STRING PriorityAttacks
15275: PPUSH
15276: CALL 14162 0 1
// end ;
15280: PPOPN 5
15282: END
// every 15 15$0 trigger utocit do var u1 , p1 , b1 , i , u2 , u1a ;
15283: LD_EXP 2
15287: IFFALSE 15836
15289: GO 15291
15291: DISABLE
15292: LD_INT 0
15294: PPUSH
15295: PPUSH
15296: PPUSH
15297: PPUSH
15298: PPUSH
15299: PPUSH
// begin case difficulty of 1 :
15300: LD_OWVAR 67
15304: PUSH
15305: LD_INT 1
15307: DOUBLE
15308: EQUAL
15309: IFTRUE 15313
15311: GO 15372
15313: POP
// begin u1 := CreateVH ( [ mg ] ) ;
15314: LD_ADDR_VAR 0 1
15318: PUSH
15319: LD_EXP 11
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL 23118 0 1
15331: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15332: LD_ADDR_VAR 0 2
15336: PUSH
15337: LD_INT 1
15339: PPUSH
15340: LD_INT 0
15342: PPUSH
15343: CALL 22665 0 2
15347: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
15348: LD_ADDR_VAR 0 3
15352: PUSH
15353: LD_INT 2
15355: PPUSH
15356: CALL 22870 0 1
15360: PUSH
15361: LD_INT 1
15363: PPUSH
15364: CALL 22994 0 1
15368: ADD
15369: ST_TO_ADDR
// end ; 2 :
15370: GO 15507
15372: LD_INT 2
15374: DOUBLE
15375: EQUAL
15376: IFTRUE 15380
15378: GO 15439
15380: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15381: LD_ADDR_VAR 0 1
15385: PUSH
15386: LD_EXP 12
15390: PUSH
15391: EMPTY
15392: LIST
15393: PPUSH
15394: CALL 23118 0 1
15398: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
15399: LD_ADDR_VAR 0 2
15403: PUSH
15404: LD_INT 1
15406: PPUSH
15407: LD_INT 0
15409: PPUSH
15410: CALL 22665 0 2
15414: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 2 ) ;
15415: LD_ADDR_VAR 0 3
15419: PUSH
15420: LD_INT 3
15422: PPUSH
15423: CALL 22870 0 1
15427: PUSH
15428: LD_INT 2
15430: PPUSH
15431: CALL 22994 0 1
15435: ADD
15436: ST_TO_ADDR
// end ; 3 :
15437: GO 15507
15439: LD_INT 3
15441: DOUBLE
15442: EQUAL
15443: IFTRUE 15447
15445: GO 15506
15447: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15448: LD_ADDR_VAR 0 1
15452: PUSH
15453: LD_EXP 12
15457: PUSH
15458: EMPTY
15459: LIST
15460: PPUSH
15461: CALL 23118 0 1
15465: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15466: LD_ADDR_VAR 0 2
15470: PUSH
15471: LD_INT 0
15473: PPUSH
15474: LD_INT 1
15476: PPUSH
15477: CALL 22665 0 2
15481: ST_TO_ADDR
// b1 := CreateB ( 4 ) ^ CreateS ( 3 ) ;
15482: LD_ADDR_VAR 0 3
15486: PUSH
15487: LD_INT 4
15489: PPUSH
15490: CALL 22870 0 1
15494: PUSH
15495: LD_INT 3
15497: PPUSH
15498: CALL 22994 0 1
15502: ADD
15503: ST_TO_ADDR
// end ; end ;
15504: GO 15507
15506: POP
// for i in b1 do
15507: LD_ADDR_VAR 0 4
15511: PUSH
15512: LD_VAR 0 3
15516: PUSH
15517: FOR_IN
15518: IFFALSE 15537
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
15520: LD_VAR 0 4
15524: PPUSH
15525: LD_INT 14
15527: PPUSH
15528: LD_INT 0
15530: PPUSH
15531: CALL 23774 0 3
// end ;
15535: GO 15517
15537: POP
15538: POP
// wait ( 0 0$1 ) ;
15539: LD_INT 35
15541: PPUSH
15542: CALL_OW 67
// AttackBase ( b1 , pathB1 ) ;
15546: LD_VAR 0 3
15550: PPUSH
15551: LD_EXP 118
15555: PPUSH
15556: CALL 13830 0 2
// for i := 1 to u1 do
15560: LD_ADDR_VAR 0 4
15564: PUSH
15565: DOUBLE
15566: LD_INT 1
15568: DEC
15569: ST_TO_ADDR
15570: LD_VAR 0 1
15574: PUSH
15575: FOR_TO
15576: IFFALSE 15606
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
15578: LD_VAR 0 2
15582: PUSH
15583: LD_VAR 0 4
15587: ARRAY
15588: PPUSH
15589: LD_VAR 0 1
15593: PUSH
15594: LD_VAR 0 4
15598: ARRAY
15599: PPUSH
15600: CALL_OW 52
// end ;
15604: GO 15575
15606: POP
15607: POP
// for i in u1 do
15608: LD_ADDR_VAR 0 4
15612: PUSH
15613: LD_VAR 0 1
15617: PUSH
15618: FOR_IN
15619: IFFALSE 15638
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
15621: LD_VAR 0 4
15625: PPUSH
15626: LD_INT 2
15628: PPUSH
15629: LD_INT 0
15631: PPUSH
15632: CALL 23774 0 3
// end ;
15636: GO 15618
15638: POP
15639: POP
// wait ( 0 0$1 ) ;
15640: LD_INT 35
15642: PPUSH
15643: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
15647: LD_VAR 0 1
15651: PPUSH
15652: LD_EXP 109
15656: PUSH
15657: LD_EXP 114
15661: PPUSH
15662: CALL 13425 0 1
15666: ADD
15667: PUSH
15668: LD_EXP 111
15672: ADD
15673: PPUSH
15674: CALL 13830 0 2
// case difficulty of 1 :
15678: LD_OWVAR 67
15682: PUSH
15683: LD_INT 1
15685: DOUBLE
15686: EQUAL
15687: IFTRUE 15691
15689: GO 15712
15691: POP
// begin u2 := CreateVC ( [ mg ] ) ;
15692: LD_ADDR_VAR 0 5
15696: PUSH
15697: LD_EXP 11
15701: PUSH
15702: EMPTY
15703: LIST
15704: PPUSH
15705: CALL 23444 0 1
15709: ST_TO_ADDR
// end ; 2 :
15710: GO 15777
15712: LD_INT 2
15714: DOUBLE
15715: EQUAL
15716: IFTRUE 15720
15718: GO 15741
15720: POP
// begin u2 := CreateVC ( [ hhg ] ) ;
15721: LD_ADDR_VAR 0 5
15725: PUSH
15726: LD_EXP 15
15730: PUSH
15731: EMPTY
15732: LIST
15733: PPUSH
15734: CALL 23444 0 1
15738: ST_TO_ADDR
// end ; 3 :
15739: GO 15777
15741: LD_INT 3
15743: DOUBLE
15744: EQUAL
15745: IFTRUE 15749
15747: GO 15776
15749: POP
// begin u2 := CreateVC ( [ mg , hhg ] ) ;
15750: LD_ADDR_VAR 0 5
15754: PUSH
15755: LD_EXP 11
15759: PUSH
15760: LD_EXP 15
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: PPUSH
15769: CALL 23444 0 1
15773: ST_TO_ADDR
// end ; end ;
15774: GO 15777
15776: POP
// for i in u2 do
15777: LD_ADDR_VAR 0 4
15781: PUSH
15782: LD_VAR 0 5
15786: PUSH
15787: FOR_IN
15788: IFFALSE 15807
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
15790: LD_VAR 0 4
15794: PPUSH
15795: LD_INT 15
15797: PPUSH
15798: LD_INT 0
15800: PPUSH
15801: CALL 23774 0 3
// end ;
15805: GO 15787
15807: POP
15808: POP
// wait ( 0 0$1 ) ;
15809: LD_INT 35
15811: PPUSH
15812: CALL_OW 67
// AttackBase ( u2 , pathBR ^ pathUR ) ;
15816: LD_VAR 0 5
15820: PPUSH
15821: LD_EXP 110
15825: PUSH
15826: LD_EXP 112
15830: ADD
15831: PPUSH
15832: CALL 13830 0 2
// end ;
15836: PPOPN 6
15838: END
// every 18 18$0 trigger utocit do var u1 , p1 , i , u1a ;
15839: LD_EXP 2
15843: IFFALSE 16569
15845: GO 15847
15847: DISABLE
15848: LD_INT 0
15850: PPUSH
15851: PPUSH
15852: PPUSH
15853: PPUSH
// begin case difficulty of 1 :
15854: LD_OWVAR 67
15858: PUSH
15859: LD_INT 1
15861: DOUBLE
15862: EQUAL
15863: IFTRUE 15867
15865: GO 15922
15867: POP
// begin u1 := CreateVH ( [ mrl ] ) ;
15868: LD_ADDR_VAR 0 1
15872: PUSH
15873: LD_EXP 12
15877: PUSH
15878: EMPTY
15879: LIST
15880: PPUSH
15881: CALL 23118 0 1
15885: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
15886: LD_ADDR_VAR 0 4
15890: PUSH
15891: LD_EXP 12
15895: PUSH
15896: EMPTY
15897: LIST
15898: PPUSH
15899: CALL 23444 0 1
15903: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15904: LD_ADDR_VAR 0 2
15908: PUSH
15909: LD_INT 0
15911: PPUSH
15912: LD_INT 1
15914: PPUSH
15915: CALL 22665 0 2
15919: ST_TO_ADDR
// end ; 2 :
15920: GO 16055
15922: LD_INT 2
15924: DOUBLE
15925: EQUAL
15926: IFTRUE 15930
15928: GO 15985
15930: POP
// begin u1 := CreateVH ( [ hrl ] ) ;
15931: LD_ADDR_VAR 0 1
15935: PUSH
15936: LD_EXP 14
15940: PUSH
15941: EMPTY
15942: LIST
15943: PPUSH
15944: CALL 23118 0 1
15948: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
15949: LD_ADDR_VAR 0 4
15953: PUSH
15954: LD_EXP 14
15958: PUSH
15959: EMPTY
15960: LIST
15961: PPUSH
15962: CALL 23444 0 1
15966: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
15967: LD_ADDR_VAR 0 2
15971: PUSH
15972: LD_INT 0
15974: PPUSH
15975: LD_INT 1
15977: PPUSH
15978: CALL 22665 0 2
15982: ST_TO_ADDR
// end ; 3 :
15983: GO 16055
15985: LD_INT 3
15987: DOUBLE
15988: EQUAL
15989: IFTRUE 15993
15991: GO 16054
15993: POP
// begin u1 := CreateVH ( [ hrl , mrl ] ) ;
15994: LD_ADDR_VAR 0 1
15998: PUSH
15999: LD_EXP 14
16003: PUSH
16004: LD_EXP 12
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PPUSH
16013: CALL 23118 0 1
16017: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_EXP 14
16027: PUSH
16028: EMPTY
16029: LIST
16030: PPUSH
16031: CALL 23444 0 1
16035: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16036: LD_ADDR_VAR 0 2
16040: PUSH
16041: LD_INT 1
16043: PPUSH
16044: LD_INT 1
16046: PPUSH
16047: CALL 22665 0 2
16051: ST_TO_ADDR
// end ; end ;
16052: GO 16055
16054: POP
// for i := 1 to u1 do
16055: LD_ADDR_VAR 0 3
16059: PUSH
16060: DOUBLE
16061: LD_INT 1
16063: DEC
16064: ST_TO_ADDR
16065: LD_VAR 0 1
16069: PUSH
16070: FOR_TO
16071: IFFALSE 16101
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16073: LD_VAR 0 2
16077: PUSH
16078: LD_VAR 0 3
16082: ARRAY
16083: PPUSH
16084: LD_VAR 0 1
16088: PUSH
16089: LD_VAR 0 3
16093: ARRAY
16094: PPUSH
16095: CALL_OW 52
// end ;
16099: GO 16070
16101: POP
16102: POP
// for i in u1 do
16103: LD_ADDR_VAR 0 3
16107: PUSH
16108: LD_VAR 0 1
16112: PUSH
16113: FOR_IN
16114: IFFALSE 16133
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16116: LD_VAR 0 3
16120: PPUSH
16121: LD_INT 3
16123: PPUSH
16124: LD_INT 0
16126: PPUSH
16127: CALL 23774 0 3
// end ;
16131: GO 16113
16133: POP
16134: POP
// for i in u1a do
16135: LD_ADDR_VAR 0 3
16139: PUSH
16140: LD_VAR 0 4
16144: PUSH
16145: FOR_IN
16146: IFFALSE 16165
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
16148: LD_VAR 0 3
16152: PPUSH
16153: LD_INT 3
16155: PPUSH
16156: LD_INT 0
16158: PPUSH
16159: CALL 23774 0 3
// end ;
16163: GO 16145
16165: POP
16166: POP
// wait ( 0 0$1 ) ;
16167: LD_INT 35
16169: PPUSH
16170: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
16174: LD_VAR 0 1
16178: PPUSH
16179: LD_EXP 108
16183: PUSH
16184: LD_EXP 111
16188: ADD
16189: PPUSH
16190: CALL 13830 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16194: LD_VAR 0 4
16198: PPUSH
16199: LD_EXP 108
16203: PUSH
16204: LD_EXP 111
16208: ADD
16209: PPUSH
16210: CALL 13830 0 2
// case difficulty of 1 :
16214: LD_OWVAR 67
16218: PUSH
16219: LD_INT 1
16221: DOUBLE
16222: EQUAL
16223: IFTRUE 16227
16225: GO 16271
16227: POP
// begin u1 := CreateVH ( [ mg ] ) ;
16228: LD_ADDR_VAR 0 1
16232: PUSH
16233: LD_EXP 11
16237: PUSH
16238: EMPTY
16239: LIST
16240: PPUSH
16241: CALL 23118 0 1
16245: ST_TO_ADDR
// u1a := [ ] ;
16246: LD_ADDR_VAR 0 4
16250: PUSH
16251: EMPTY
16252: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16253: LD_ADDR_VAR 0 2
16257: PUSH
16258: LD_INT 1
16260: PPUSH
16261: LD_INT 0
16263: PPUSH
16264: CALL 22665 0 2
16268: ST_TO_ADDR
// end ; 2 :
16269: GO 16398
16271: LD_INT 2
16273: DOUBLE
16274: EQUAL
16275: IFTRUE 16279
16277: GO 16334
16279: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16280: LD_ADDR_VAR 0 1
16284: PUSH
16285: LD_EXP 15
16289: PUSH
16290: EMPTY
16291: LIST
16292: PPUSH
16293: CALL 23118 0 1
16297: ST_TO_ADDR
// u1a := CreateVC ( [ mg ] ) ;
16298: LD_ADDR_VAR 0 4
16302: PUSH
16303: LD_EXP 11
16307: PUSH
16308: EMPTY
16309: LIST
16310: PPUSH
16311: CALL 23444 0 1
16315: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
16316: LD_ADDR_VAR 0 2
16320: PUSH
16321: LD_INT 1
16323: PPUSH
16324: LD_INT 0
16326: PPUSH
16327: CALL 22665 0 2
16331: ST_TO_ADDR
// end ; 3 :
16332: GO 16398
16334: LD_INT 3
16336: DOUBLE
16337: EQUAL
16338: IFTRUE 16342
16340: GO 16397
16342: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
16343: LD_ADDR_VAR 0 1
16347: PUSH
16348: LD_EXP 15
16352: PUSH
16353: EMPTY
16354: LIST
16355: PPUSH
16356: CALL 23118 0 1
16360: ST_TO_ADDR
// u1a := CreateVC ( [ hrl ] ) ;
16361: LD_ADDR_VAR 0 4
16365: PUSH
16366: LD_EXP 14
16370: PUSH
16371: EMPTY
16372: LIST
16373: PPUSH
16374: CALL 23444 0 1
16378: ST_TO_ADDR
// p1 := CreateH ( 0 , 1 ) ;
16379: LD_ADDR_VAR 0 2
16383: PUSH
16384: LD_INT 0
16386: PPUSH
16387: LD_INT 1
16389: PPUSH
16390: CALL 22665 0 2
16394: ST_TO_ADDR
// end ; end ;
16395: GO 16398
16397: POP
// for i := 1 to u1 do
16398: LD_ADDR_VAR 0 3
16402: PUSH
16403: DOUBLE
16404: LD_INT 1
16406: DEC
16407: ST_TO_ADDR
16408: LD_VAR 0 1
16412: PUSH
16413: FOR_TO
16414: IFFALSE 16444
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16416: LD_VAR 0 2
16420: PUSH
16421: LD_VAR 0 3
16425: ARRAY
16426: PPUSH
16427: LD_VAR 0 1
16431: PUSH
16432: LD_VAR 0 3
16436: ARRAY
16437: PPUSH
16438: CALL_OW 52
// end ;
16442: GO 16413
16444: POP
16445: POP
// for i in u1 do
16446: LD_ADDR_VAR 0 3
16450: PUSH
16451: LD_VAR 0 1
16455: PUSH
16456: FOR_IN
16457: IFFALSE 16476
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16459: LD_VAR 0 3
16463: PPUSH
16464: LD_INT 15
16466: PPUSH
16467: LD_INT 0
16469: PPUSH
16470: CALL 23774 0 3
// end ;
16474: GO 16456
16476: POP
16477: POP
// for i in u1a do
16478: LD_ADDR_VAR 0 3
16482: PUSH
16483: LD_VAR 0 4
16487: PUSH
16488: FOR_IN
16489: IFFALSE 16508
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16491: LD_VAR 0 3
16495: PPUSH
16496: LD_INT 15
16498: PPUSH
16499: LD_INT 0
16501: PPUSH
16502: CALL 23774 0 3
// end ;
16506: GO 16488
16508: POP
16509: POP
// wait ( 0 0$1 ) ;
16510: LD_INT 35
16512: PPUSH
16513: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16517: LD_VAR 0 1
16521: PPUSH
16522: LD_EXP 110
16526: PUSH
16527: LD_EXP 116
16531: ADD
16532: PUSH
16533: LD_EXP 113
16537: ADD
16538: PPUSH
16539: CALL 13830 0 2
// AttackBase ( u1a , pathBR ^ pathMR ^ pathUT ) ;
16543: LD_VAR 0 4
16547: PPUSH
16548: LD_EXP 110
16552: PUSH
16553: LD_EXP 116
16557: ADD
16558: PUSH
16559: LD_EXP 113
16563: ADD
16564: PPUSH
16565: CALL 13830 0 2
// end ;
16569: PPOPN 4
16571: END
// every 22 22$0 trigger utocit do var u1 , p1 , i , u1a ;
16572: LD_EXP 2
16576: IFFALSE 16971
16578: GO 16580
16580: DISABLE
16581: LD_INT 0
16583: PPUSH
16584: PPUSH
16585: PPUSH
16586: PPUSH
// begin case difficulty of 1 :
16587: LD_OWVAR 67
16591: PUSH
16592: LD_INT 1
16594: DOUBLE
16595: EQUAL
16596: IFTRUE 16600
16598: GO 16661
16600: POP
// begin u1 := CreateVH ( [ mrl , mrl ] ) ;
16601: LD_ADDR_VAR 0 1
16605: PUSH
16606: LD_EXP 12
16610: PUSH
16611: LD_EXP 12
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PPUSH
16620: CALL 23118 0 1
16624: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16625: LD_ADDR_VAR 0 4
16629: PUSH
16630: LD_EXP 12
16634: PUSH
16635: EMPTY
16636: LIST
16637: PPUSH
16638: CALL 23444 0 1
16642: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
16643: LD_ADDR_VAR 0 2
16647: PUSH
16648: LD_INT 0
16650: PPUSH
16651: LD_INT 2
16653: PPUSH
16654: CALL 22665 0 2
16658: ST_TO_ADDR
// end ; 2 :
16659: GO 16806
16661: LD_INT 2
16663: DOUBLE
16664: EQUAL
16665: IFTRUE 16669
16667: GO 16730
16669: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16670: LD_ADDR_VAR 0 1
16674: PUSH
16675: LD_EXP 14
16679: PUSH
16680: LD_EXP 14
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 23118 0 1
16693: ST_TO_ADDR
// u1a := CreateVC ( [ mrl ] ) ;
16694: LD_ADDR_VAR 0 4
16698: PUSH
16699: LD_EXP 12
16703: PUSH
16704: EMPTY
16705: LIST
16706: PPUSH
16707: CALL 23444 0 1
16711: ST_TO_ADDR
// p1 := CreateH ( 2 , 0 ) ;
16712: LD_ADDR_VAR 0 2
16716: PUSH
16717: LD_INT 2
16719: PPUSH
16720: LD_INT 0
16722: PPUSH
16723: CALL 22665 0 2
16727: ST_TO_ADDR
// end ; 3 :
16728: GO 16806
16730: LD_INT 3
16732: DOUBLE
16733: EQUAL
16734: IFTRUE 16738
16736: GO 16805
16738: POP
// begin u1 := CreateVH ( [ hrl , hrl ] ) ;
16739: LD_ADDR_VAR 0 1
16743: PUSH
16744: LD_EXP 14
16748: PUSH
16749: LD_EXP 14
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: PPUSH
16758: CALL 23118 0 1
16762: ST_TO_ADDR
// u1a := CreateVC ( [ hrl , hrl ] ) ;
16763: LD_ADDR_VAR 0 4
16767: PUSH
16768: LD_EXP 14
16772: PUSH
16773: LD_EXP 14
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PPUSH
16782: CALL 23444 0 1
16786: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
16787: LD_ADDR_VAR 0 2
16791: PUSH
16792: LD_INT 1
16794: PPUSH
16795: LD_INT 1
16797: PPUSH
16798: CALL 22665 0 2
16802: ST_TO_ADDR
// end ; end ;
16803: GO 16806
16805: POP
// for i := 1 to u1 do
16806: LD_ADDR_VAR 0 3
16810: PUSH
16811: DOUBLE
16812: LD_INT 1
16814: DEC
16815: ST_TO_ADDR
16816: LD_VAR 0 1
16820: PUSH
16821: FOR_TO
16822: IFFALSE 16852
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
16824: LD_VAR 0 2
16828: PUSH
16829: LD_VAR 0 3
16833: ARRAY
16834: PPUSH
16835: LD_VAR 0 1
16839: PUSH
16840: LD_VAR 0 3
16844: ARRAY
16845: PPUSH
16846: CALL_OW 52
// end ;
16850: GO 16821
16852: POP
16853: POP
// for i in u1 do
16854: LD_ADDR_VAR 0 3
16858: PUSH
16859: LD_VAR 0 1
16863: PUSH
16864: FOR_IN
16865: IFFALSE 16884
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16867: LD_VAR 0 3
16871: PPUSH
16872: LD_INT 15
16874: PPUSH
16875: LD_INT 0
16877: PPUSH
16878: CALL 23774 0 3
// end ;
16882: GO 16864
16884: POP
16885: POP
// for i in u1a do
16886: LD_ADDR_VAR 0 3
16890: PUSH
16891: LD_VAR 0 4
16895: PUSH
16896: FOR_IN
16897: IFFALSE 16916
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
16899: LD_VAR 0 3
16903: PPUSH
16904: LD_INT 15
16906: PPUSH
16907: LD_INT 0
16909: PPUSH
16910: CALL 23774 0 3
// end ;
16914: GO 16896
16916: POP
16917: POP
// wait ( 0 0$4 ) ;
16918: LD_INT 140
16920: PPUSH
16921: CALL_OW 67
// AttackBase ( u1 , pathBR ^ pathMR ^ pathUT ) ;
16925: LD_VAR 0 1
16929: PPUSH
16930: LD_EXP 110
16934: PUSH
16935: LD_EXP 116
16939: ADD
16940: PUSH
16941: LD_EXP 113
16945: ADD
16946: PPUSH
16947: CALL 13830 0 2
// AttackBase ( u1a , pathBL ^ pathUL ) ;
16951: LD_VAR 0 4
16955: PPUSH
16956: LD_EXP 108
16960: PUSH
16961: LD_EXP 111
16965: ADD
16966: PPUSH
16967: CALL 13830 0 2
// end ;
16971: PPOPN 4
16973: END
// every 37 37$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , b1 ;
16974: LD_EXP 2
16978: IFFALSE 17638
16980: GO 16982
16982: DISABLE
16983: LD_INT 0
16985: PPUSH
16986: PPUSH
16987: PPUSH
16988: PPUSH
16989: PPUSH
16990: PPUSH
16991: PPUSH
16992: PPUSH
// begin case difficulty of 1 :
16993: LD_OWVAR 67
16997: PUSH
16998: LD_INT 1
17000: DOUBLE
17001: EQUAL
17002: IFTRUE 17006
17004: GO 17049
17006: POP
// begin u1 := CreateVC ( [ mg ] ) ;
17007: LD_ADDR_VAR 0 1
17011: PUSH
17012: LD_EXP 11
17016: PUSH
17017: EMPTY
17018: LIST
17019: PPUSH
17020: CALL 23444 0 1
17024: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 1 ) ;
17025: LD_ADDR_VAR 0 8
17029: PUSH
17030: LD_INT 2
17032: PPUSH
17033: CALL 22870 0 1
17037: PUSH
17038: LD_INT 1
17040: PPUSH
17041: CALL 22994 0 1
17045: ADD
17046: ST_TO_ADDR
// end ; 2 :
17047: GO 17158
17049: LD_INT 2
17051: DOUBLE
17052: EQUAL
17053: IFTRUE 17057
17055: GO 17100
17057: POP
// begin u1 := CreateVC ( [ hhg ] ) ;
17058: LD_ADDR_VAR 0 1
17062: PUSH
17063: LD_EXP 15
17067: PUSH
17068: EMPTY
17069: LIST
17070: PPUSH
17071: CALL 23444 0 1
17075: ST_TO_ADDR
// b1 := CreateB ( 2 ) ^ CreateS ( 2 ) ;
17076: LD_ADDR_VAR 0 8
17080: PUSH
17081: LD_INT 2
17083: PPUSH
17084: CALL 22870 0 1
17088: PUSH
17089: LD_INT 2
17091: PPUSH
17092: CALL 22994 0 1
17096: ADD
17097: ST_TO_ADDR
// end ; 3 :
17098: GO 17158
17100: LD_INT 3
17102: DOUBLE
17103: EQUAL
17104: IFTRUE 17108
17106: GO 17157
17108: POP
// begin u1 := CreateVC ( [ hhg , hgg ] ) ;
17109: LD_ADDR_VAR 0 1
17113: PUSH
17114: LD_EXP 15
17118: PUSH
17119: LD_EXP 13
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PPUSH
17128: CALL 23444 0 1
17132: ST_TO_ADDR
// b1 := CreateB ( 3 ) ^ CreateS ( 3 ) ;
17133: LD_ADDR_VAR 0 8
17137: PUSH
17138: LD_INT 3
17140: PPUSH
17141: CALL 22870 0 1
17145: PUSH
17146: LD_INT 3
17148: PPUSH
17149: CALL 22994 0 1
17153: ADD
17154: ST_TO_ADDR
// end ; end ;
17155: GO 17158
17157: POP
// for i in u1 do
17158: LD_ADDR_VAR 0 3
17162: PUSH
17163: LD_VAR 0 1
17167: PUSH
17168: FOR_IN
17169: IFFALSE 17188
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17171: LD_VAR 0 3
17175: PPUSH
17176: LD_INT 14
17178: PPUSH
17179: LD_INT 0
17181: PPUSH
17182: CALL 23774 0 3
// end ;
17186: GO 17168
17188: POP
17189: POP
// wait ( 0 0$1 ) ;
17190: LD_INT 35
17192: PPUSH
17193: CALL_OW 67
// AttackBase ( u1 , pathUT ^ pathUR ) ;
17197: LD_VAR 0 1
17201: PPUSH
17202: LD_EXP 113
17206: PUSH
17207: LD_EXP 112
17211: ADD
17212: PPUSH
17213: CALL 13830 0 2
// AttackBase ( b1 , pathUT ^ pathUR ) ;
17217: LD_VAR 0 8
17221: PPUSH
17222: LD_EXP 113
17226: PUSH
17227: LD_EXP 112
17231: ADD
17232: PPUSH
17233: CALL 13830 0 2
// case difficulty of 1 :
17237: LD_OWVAR 67
17241: PUSH
17242: LD_INT 1
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17287
17250: POP
// begin u2 := CreateVH ( [ mgg ] ) ;
17251: LD_ADDR_VAR 0 4
17255: PUSH
17256: LD_EXP 10
17260: PUSH
17261: EMPTY
17262: LIST
17263: PPUSH
17264: CALL 23118 0 1
17268: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
17269: LD_ADDR_VAR 0 5
17273: PUSH
17274: LD_INT 1
17276: PPUSH
17277: LD_INT 0
17279: PPUSH
17280: CALL 22665 0 2
17284: ST_TO_ADDR
// end ; 2 :
17285: GO 17390
17287: LD_INT 2
17289: DOUBLE
17290: EQUAL
17291: IFTRUE 17295
17293: GO 17338
17295: POP
// begin u2 := CreateVH ( [ mgg , mg ] ) ;
17296: LD_ADDR_VAR 0 4
17300: PUSH
17301: LD_EXP 10
17305: PUSH
17306: LD_EXP 11
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: PPUSH
17315: CALL 23118 0 1
17319: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17320: LD_ADDR_VAR 0 5
17324: PUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 2
17330: PPUSH
17331: CALL 22665 0 2
17335: ST_TO_ADDR
// end ; 3 :
17336: GO 17390
17338: LD_INT 3
17340: DOUBLE
17341: EQUAL
17342: IFTRUE 17346
17344: GO 17389
17346: POP
// begin u2 := CreateVH ( [ mgg , hhg ] ) ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_EXP 10
17356: PUSH
17357: LD_EXP 15
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: PPUSH
17366: CALL 23118 0 1
17370: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
17371: LD_ADDR_VAR 0 5
17375: PUSH
17376: LD_INT 0
17378: PPUSH
17379: LD_INT 2
17381: PPUSH
17382: CALL 22665 0 2
17386: ST_TO_ADDR
// end ; end ;
17387: GO 17390
17389: POP
// for i := 1 to u2 do
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: DOUBLE
17396: LD_INT 1
17398: DEC
17399: ST_TO_ADDR
17400: LD_VAR 0 4
17404: PUSH
17405: FOR_TO
17406: IFFALSE 17436
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
17408: LD_VAR 0 5
17412: PUSH
17413: LD_VAR 0 3
17417: ARRAY
17418: PPUSH
17419: LD_VAR 0 4
17423: PUSH
17424: LD_VAR 0 3
17428: ARRAY
17429: PPUSH
17430: CALL_OW 52
// end ;
17434: GO 17405
17436: POP
17437: POP
// for i in u2 do
17438: LD_ADDR_VAR 0 3
17442: PUSH
17443: LD_VAR 0 4
17447: PUSH
17448: FOR_IN
17449: IFFALSE 17468
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
17451: LD_VAR 0 3
17455: PPUSH
17456: LD_INT 3
17458: PPUSH
17459: LD_INT 0
17461: PPUSH
17462: CALL 23774 0 3
// end ;
17466: GO 17448
17468: POP
17469: POP
// wait ( 0 0$1 ) ;
17470: LD_INT 35
17472: PPUSH
17473: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
17477: LD_VAR 0 4
17481: PPUSH
17482: LD_EXP 108
17486: PUSH
17487: LD_EXP 111
17491: ADD
17492: PPUSH
17493: CALL 13830 0 2
// case difficulty of 1 :
17497: LD_OWVAR 67
17501: PUSH
17502: LD_INT 1
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17526
17510: POP
// begin u3 := CreateS ( 1 ) ;
17511: LD_ADDR_VAR 0 6
17515: PUSH
17516: LD_INT 1
17518: PPUSH
17519: CALL 22994 0 1
17523: ST_TO_ADDR
// ; end ; 2 :
17524: GO 17585
17526: LD_INT 2
17528: DOUBLE
17529: EQUAL
17530: IFTRUE 17534
17532: GO 17555
17534: POP
// begin u3 := CreateVC ( [ mgg ] ) ;
17535: LD_ADDR_VAR 0 6
17539: PUSH
17540: LD_EXP 10
17544: PUSH
17545: EMPTY
17546: LIST
17547: PPUSH
17548: CALL 23444 0 1
17552: ST_TO_ADDR
// end ; 3 :
17553: GO 17585
17555: LD_INT 3
17557: DOUBLE
17558: EQUAL
17559: IFTRUE 17563
17561: GO 17584
17563: POP
// begin u3 := CreateVC ( [ hgg ] ) ;
17564: LD_ADDR_VAR 0 6
17568: PUSH
17569: LD_EXP 13
17573: PUSH
17574: EMPTY
17575: LIST
17576: PPUSH
17577: CALL 23444 0 1
17581: ST_TO_ADDR
// end ; end ;
17582: GO 17585
17584: POP
// for i in u3 do
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 6
17594: PUSH
17595: FOR_IN
17596: IFFALSE 17615
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
17598: LD_VAR 0 3
17602: PPUSH
17603: LD_INT 14
17605: PPUSH
17606: LD_INT 0
17608: PPUSH
17609: CALL 23774 0 3
// end ;
17613: GO 17595
17615: POP
17616: POP
// wait ( 0 0$1 ) ;
17617: LD_INT 35
17619: PPUSH
17620: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
17624: LD_VAR 0 6
17628: PPUSH
17629: LD_EXP 117
17633: PPUSH
17634: CALL 13830 0 2
// end ;
17638: PPOPN 8
17640: END
// every 38 38$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
17641: LD_EXP 2
17645: IFFALSE 18106
17647: GO 17649
17649: DISABLE
17650: LD_INT 0
17652: PPUSH
17653: PPUSH
17654: PPUSH
17655: PPUSH
17656: PPUSH
17657: PPUSH
17658: PPUSH
// begin case difficulty of 1 :
17659: LD_OWVAR 67
17663: PUSH
17664: LD_INT 1
17666: DOUBLE
17667: EQUAL
17668: IFTRUE 17672
17670: GO 17709
17672: POP
// begin u1 := CreateVH ( [ hhg ] ) ;
17673: LD_ADDR_VAR 0 1
17677: PUSH
17678: LD_EXP 15
17682: PUSH
17683: EMPTY
17684: LIST
17685: PPUSH
17686: CALL 23118 0 1
17690: ST_TO_ADDR
// p1 := CreateH ( 1 , 0 ) ;
17691: LD_ADDR_VAR 0 2
17695: PUSH
17696: LD_INT 1
17698: PPUSH
17699: LD_INT 0
17701: PPUSH
17702: CALL 22665 0 2
17706: ST_TO_ADDR
// end ; 2 :
17707: GO 17812
17709: LD_INT 2
17711: DOUBLE
17712: EQUAL
17713: IFTRUE 17717
17715: GO 17760
17717: POP
// begin u1 := CreateVH ( [ mrl , hhg ] ) ;
17718: LD_ADDR_VAR 0 1
17722: PUSH
17723: LD_EXP 12
17727: PUSH
17728: LD_EXP 15
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: PPUSH
17737: CALL 23118 0 1
17741: ST_TO_ADDR
// p1 := CreateH ( 1 , 1 ) ;
17742: LD_ADDR_VAR 0 2
17746: PUSH
17747: LD_INT 1
17749: PPUSH
17750: LD_INT 1
17752: PPUSH
17753: CALL 22665 0 2
17757: ST_TO_ADDR
// end ; 3 :
17758: GO 17812
17760: LD_INT 3
17762: DOUBLE
17763: EQUAL
17764: IFTRUE 17768
17766: GO 17811
17768: POP
// begin u1 := CreateVH ( [ hrl , hhg ] ) ;
17769: LD_ADDR_VAR 0 1
17773: PUSH
17774: LD_EXP 14
17778: PUSH
17779: LD_EXP 15
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PPUSH
17788: CALL 23118 0 1
17792: ST_TO_ADDR
// p1 := CreateH ( 0 , 2 ) ;
17793: LD_ADDR_VAR 0 2
17797: PUSH
17798: LD_INT 0
17800: PPUSH
17801: LD_INT 2
17803: PPUSH
17804: CALL 22665 0 2
17808: ST_TO_ADDR
// end ; end ;
17809: GO 17812
17811: POP
// for i := 1 to u1 do
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: DOUBLE
17818: LD_INT 1
17820: DEC
17821: ST_TO_ADDR
17822: LD_VAR 0 1
17826: PUSH
17827: FOR_TO
17828: IFFALSE 17858
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
17830: LD_VAR 0 2
17834: PUSH
17835: LD_VAR 0 3
17839: ARRAY
17840: PPUSH
17841: LD_VAR 0 1
17845: PUSH
17846: LD_VAR 0 3
17850: ARRAY
17851: PPUSH
17852: CALL_OW 52
// end ;
17856: GO 17827
17858: POP
17859: POP
// for i in u1 do
17860: LD_ADDR_VAR 0 3
17864: PUSH
17865: LD_VAR 0 1
17869: PUSH
17870: FOR_IN
17871: IFFALSE 17890
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
17873: LD_VAR 0 3
17877: PPUSH
17878: LD_INT 2
17880: PPUSH
17881: LD_INT 0
17883: PPUSH
17884: CALL 23774 0 3
// end ;
17888: GO 17870
17890: POP
17891: POP
// wait ( 0 0$4 ) ;
17892: LD_INT 140
17894: PPUSH
17895: CALL_OW 67
// AttackBase ( u1 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
17899: LD_VAR 0 1
17903: PPUSH
17904: LD_EXP 109
17908: PUSH
17909: LD_EXP 114
17913: PPUSH
17914: CALL 13425 0 1
17918: ADD
17919: PUSH
17920: LD_EXP 111
17924: ADD
17925: PPUSH
17926: CALL 13830 0 2
// case difficulty of 1 :
17930: LD_OWVAR 67
17934: PUSH
17935: LD_INT 1
17937: DOUBLE
17938: EQUAL
17939: IFTRUE 17943
17941: GO 17970
17943: POP
// begin u2 := CreateVC ( [ mgg , mrl ] ) ;
17944: LD_ADDR_VAR 0 4
17948: PUSH
17949: LD_EXP 10
17953: PUSH
17954: LD_EXP 12
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: PPUSH
17963: CALL 23444 0 1
17967: ST_TO_ADDR
// end ; 2 :
17968: GO 18041
17970: LD_INT 2
17972: DOUBLE
17973: EQUAL
17974: IFTRUE 17978
17976: GO 18005
17978: POP
// begin u2 := CreateVC ( [ hgg , mrl ] ) ;
17979: LD_ADDR_VAR 0 4
17983: PUSH
17984: LD_EXP 13
17988: PUSH
17989: LD_EXP 12
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: PPUSH
17998: CALL 23444 0 1
18002: ST_TO_ADDR
// end ; 3 :
18003: GO 18041
18005: LD_INT 3
18007: DOUBLE
18008: EQUAL
18009: IFTRUE 18013
18011: GO 18040
18013: POP
// begin u2 := CreateVC ( [ hgg , hrl ] ) ;
18014: LD_ADDR_VAR 0 4
18018: PUSH
18019: LD_EXP 13
18023: PUSH
18024: LD_EXP 14
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: PPUSH
18033: CALL 23444 0 1
18037: ST_TO_ADDR
// end ; end ;
18038: GO 18041
18040: POP
// for i in u2 do
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: LD_VAR 0 4
18050: PUSH
18051: FOR_IN
18052: IFFALSE 18071
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
18054: LD_VAR 0 3
18058: PPUSH
18059: LD_INT 2
18061: PPUSH
18062: LD_INT 0
18064: PPUSH
18065: CALL 23774 0 3
// end ;
18069: GO 18051
18071: POP
18072: POP
// wait ( 0 0$1 ) ;
18073: LD_INT 35
18075: PPUSH
18076: CALL_OW 67
// AttackBase ( u2 , pathBM ^ pathMM ^ pathUR ) ;
18080: LD_VAR 0 4
18084: PPUSH
18085: LD_EXP 109
18089: PUSH
18090: LD_EXP 115
18094: ADD
18095: PUSH
18096: LD_EXP 112
18100: ADD
18101: PPUSH
18102: CALL 13830 0 2
// end ;
18106: PPOPN 7
18108: END
// every 41 41$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 ;
18109: LD_EXP 2
18113: IFFALSE 18309
18115: GO 18117
18117: DISABLE
18118: LD_INT 0
18120: PPUSH
18121: PPUSH
18122: PPUSH
18123: PPUSH
18124: PPUSH
18125: PPUSH
18126: PPUSH
// begin case difficulty of 1 :
18127: LD_OWVAR 67
18131: PUSH
18132: LD_INT 1
18134: DOUBLE
18135: EQUAL
18136: IFTRUE 18140
18138: GO 18167
18140: POP
// begin u1 := CreateVC ( [ hrl , mgg ] ) ;
18141: LD_ADDR_VAR 0 1
18145: PUSH
18146: LD_EXP 14
18150: PUSH
18151: LD_EXP 10
18155: PUSH
18156: EMPTY
18157: LIST
18158: LIST
18159: PPUSH
18160: CALL 23444 0 1
18164: ST_TO_ADDR
// end ; 2 :
18165: GO 18256
18167: LD_INT 2
18169: DOUBLE
18170: EQUAL
18171: IFTRUE 18175
18173: GO 18208
18175: POP
// begin u1 := CreateVC ( [ hrl , hrl , mgg ] ) ;
18176: LD_ADDR_VAR 0 1
18180: PUSH
18181: LD_EXP 14
18185: PUSH
18186: LD_EXP 14
18190: PUSH
18191: LD_EXP 10
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: LIST
18200: PPUSH
18201: CALL 23444 0 1
18205: ST_TO_ADDR
// end ; 3 :
18206: GO 18256
18208: LD_INT 3
18210: DOUBLE
18211: EQUAL
18212: IFTRUE 18216
18214: GO 18255
18216: POP
// begin u1 := CreateVC ( [ hrl , hrl , hhg , mgg ] ) ;
18217: LD_ADDR_VAR 0 1
18221: PUSH
18222: LD_EXP 14
18226: PUSH
18227: LD_EXP 14
18231: PUSH
18232: LD_EXP 15
18236: PUSH
18237: LD_EXP 10
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: PPUSH
18248: CALL 23444 0 1
18252: ST_TO_ADDR
// end ; end ;
18253: GO 18256
18255: POP
// for i in u1 do
18256: LD_ADDR_VAR 0 3
18260: PUSH
18261: LD_VAR 0 1
18265: PUSH
18266: FOR_IN
18267: IFFALSE 18286
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18269: LD_VAR 0 3
18273: PPUSH
18274: LD_INT 14
18276: PPUSH
18277: LD_INT 0
18279: PPUSH
18280: CALL 23774 0 3
// end ;
18284: GO 18266
18286: POP
18287: POP
// wait ( 0 0$4 ) ;
18288: LD_INT 140
18290: PPUSH
18291: CALL_OW 67
// AttackBase ( u1 , pathT ) ;
18295: LD_VAR 0 1
18299: PPUSH
18300: LD_EXP 117
18304: PPUSH
18305: CALL 13830 0 2
// end ;
18309: PPOPN 7
18311: END
// every 44 44$0 trigger utocit do var u1 , p1 , i , u2 , p2 , u3 , p3 , u2a ;
18312: LD_EXP 2
18316: IFFALSE 19153
18318: GO 18320
18320: DISABLE
18321: LD_INT 0
18323: PPUSH
18324: PPUSH
18325: PPUSH
18326: PPUSH
18327: PPUSH
18328: PPUSH
18329: PPUSH
18330: PPUSH
// begin case difficulty of 1 :
18331: LD_OWVAR 67
18335: PUSH
18336: LD_INT 1
18338: DOUBLE
18339: EQUAL
18340: IFTRUE 18344
18342: GO 18393
18344: POP
// begin u1 := CreateVH ( [ hrl , mg , mrl ] ) ;
18345: LD_ADDR_VAR 0 1
18349: PUSH
18350: LD_EXP 14
18354: PUSH
18355: LD_EXP 11
18359: PUSH
18360: LD_EXP 12
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: PPUSH
18370: CALL 23118 0 1
18374: ST_TO_ADDR
// p1 := CreateH ( 2 , 1 ) ;
18375: LD_ADDR_VAR 0 2
18379: PUSH
18380: LD_INT 2
18382: PPUSH
18383: LD_INT 1
18385: PPUSH
18386: CALL 22665 0 2
18390: ST_TO_ADDR
// end ; 2 :
18391: GO 18520
18393: LD_INT 2
18395: DOUBLE
18396: EQUAL
18397: IFTRUE 18401
18399: GO 18456
18401: POP
// begin u1 := CreateVH ( [ hrl , hhg , mrl , mgg ] ) ;
18402: LD_ADDR_VAR 0 1
18406: PUSH
18407: LD_EXP 14
18411: PUSH
18412: LD_EXP 15
18416: PUSH
18417: LD_EXP 12
18421: PUSH
18422: LD_EXP 10
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: PPUSH
18433: CALL 23118 0 1
18437: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18438: LD_ADDR_VAR 0 2
18442: PUSH
18443: LD_INT 3
18445: PPUSH
18446: LD_INT 1
18448: PPUSH
18449: CALL 22665 0 2
18453: ST_TO_ADDR
// end ; 3 :
18454: GO 18520
18456: LD_INT 3
18458: DOUBLE
18459: EQUAL
18460: IFTRUE 18464
18462: GO 18519
18464: POP
// begin u1 := CreateVH ( [ hrl , hhg , hrl , hgg ] ) ;
18465: LD_ADDR_VAR 0 1
18469: PUSH
18470: LD_EXP 14
18474: PUSH
18475: LD_EXP 15
18479: PUSH
18480: LD_EXP 14
18484: PUSH
18485: LD_EXP 13
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: PPUSH
18496: CALL 23118 0 1
18500: ST_TO_ADDR
// p1 := CreateH ( 3 , 1 ) ;
18501: LD_ADDR_VAR 0 2
18505: PUSH
18506: LD_INT 3
18508: PPUSH
18509: LD_INT 1
18511: PPUSH
18512: CALL 22665 0 2
18516: ST_TO_ADDR
// end ; end ;
18517: GO 18520
18519: POP
// for i := 1 to u1 do
18520: LD_ADDR_VAR 0 3
18524: PUSH
18525: DOUBLE
18526: LD_INT 1
18528: DEC
18529: ST_TO_ADDR
18530: LD_VAR 0 1
18534: PUSH
18535: FOR_TO
18536: IFFALSE 18566
// begin PlaceHumanInUnit ( p1 [ i ] , u1 [ i ] ) ;
18538: LD_VAR 0 2
18542: PUSH
18543: LD_VAR 0 3
18547: ARRAY
18548: PPUSH
18549: LD_VAR 0 1
18553: PUSH
18554: LD_VAR 0 3
18558: ARRAY
18559: PPUSH
18560: CALL_OW 52
// end ;
18564: GO 18535
18566: POP
18567: POP
// for i in u1 do
18568: LD_ADDR_VAR 0 3
18572: PUSH
18573: LD_VAR 0 1
18577: PUSH
18578: FOR_IN
18579: IFFALSE 18598
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
18581: LD_VAR 0 3
18585: PPUSH
18586: LD_INT 14
18588: PPUSH
18589: LD_INT 0
18591: PPUSH
18592: CALL 23774 0 3
// end ;
18596: GO 18578
18598: POP
18599: POP
// wait ( 0 0$1 ) ;
18600: LD_INT 35
18602: PPUSH
18603: CALL_OW 67
// AttackBase ( u1 , pathUT ) ;
18607: LD_VAR 0 1
18611: PPUSH
18612: LD_EXP 113
18616: PPUSH
18617: CALL 13830 0 2
// case difficulty of 1 :
18621: LD_OWVAR 67
18625: PUSH
18626: LD_INT 1
18628: DOUBLE
18629: EQUAL
18630: IFTRUE 18634
18632: GO 18695
18634: POP
// begin u2 := CreateVH ( [ hgg ] ) ;
18635: LD_ADDR_VAR 0 4
18639: PUSH
18640: LD_EXP 13
18644: PUSH
18645: EMPTY
18646: LIST
18647: PPUSH
18648: CALL 23118 0 1
18652: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18653: LD_ADDR_VAR 0 8
18657: PUSH
18658: LD_EXP 11
18662: PUSH
18663: LD_EXP 15
18667: PUSH
18668: EMPTY
18669: LIST
18670: LIST
18671: PPUSH
18672: CALL 23444 0 1
18676: ST_TO_ADDR
// p2 := CreateH ( 1 , 0 ) ;
18677: LD_ADDR_VAR 0 5
18681: PUSH
18682: LD_INT 1
18684: PPUSH
18685: LD_INT 0
18687: PPUSH
18688: CALL 22665 0 2
18692: ST_TO_ADDR
// end ; 2 :
18693: GO 18846
18695: LD_INT 2
18697: DOUBLE
18698: EQUAL
18699: IFTRUE 18703
18701: GO 18770
18703: POP
// begin u2 := CreateVH ( [ hgg , mrl ] ) ;
18704: LD_ADDR_VAR 0 4
18708: PUSH
18709: LD_EXP 13
18713: PUSH
18714: LD_EXP 12
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL 23118 0 1
18727: ST_TO_ADDR
// u2a := CreateVC ( [ mg , hhg ] ) ;
18728: LD_ADDR_VAR 0 8
18732: PUSH
18733: LD_EXP 11
18737: PUSH
18738: LD_EXP 15
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: PPUSH
18747: CALL 23444 0 1
18751: ST_TO_ADDR
// p2 := CreateH ( 1 , 1 ) ;
18752: LD_ADDR_VAR 0 5
18756: PUSH
18757: LD_INT 1
18759: PPUSH
18760: LD_INT 1
18762: PPUSH
18763: CALL 22665 0 2
18767: ST_TO_ADDR
// end ; 3 :
18768: GO 18846
18770: LD_INT 3
18772: DOUBLE
18773: EQUAL
18774: IFTRUE 18778
18776: GO 18845
18778: POP
// begin u2 := CreateVH ( [ hgg , hrl ] ) ;
18779: LD_ADDR_VAR 0 4
18783: PUSH
18784: LD_EXP 13
18788: PUSH
18789: LD_EXP 14
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: PPUSH
18798: CALL 23118 0 1
18802: ST_TO_ADDR
// u2a := CreateVC ( [ hhg , hhg ] ) ;
18803: LD_ADDR_VAR 0 8
18807: PUSH
18808: LD_EXP 15
18812: PUSH
18813: LD_EXP 15
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PPUSH
18822: CALL 23444 0 1
18826: ST_TO_ADDR
// p2 := CreateH ( 0 , 2 ) ;
18827: LD_ADDR_VAR 0 5
18831: PUSH
18832: LD_INT 0
18834: PPUSH
18835: LD_INT 2
18837: PPUSH
18838: CALL 22665 0 2
18842: ST_TO_ADDR
// end ; end ;
18843: GO 18846
18845: POP
// for i := 1 to u2 do
18846: LD_ADDR_VAR 0 3
18850: PUSH
18851: DOUBLE
18852: LD_INT 1
18854: DEC
18855: ST_TO_ADDR
18856: LD_VAR 0 4
18860: PUSH
18861: FOR_TO
18862: IFFALSE 18892
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
18864: LD_VAR 0 5
18868: PUSH
18869: LD_VAR 0 3
18873: ARRAY
18874: PPUSH
18875: LD_VAR 0 4
18879: PUSH
18880: LD_VAR 0 3
18884: ARRAY
18885: PPUSH
18886: CALL_OW 52
// end ;
18890: GO 18861
18892: POP
18893: POP
// for i in u2 ^ u2a do
18894: LD_ADDR_VAR 0 3
18898: PUSH
18899: LD_VAR 0 4
18903: PUSH
18904: LD_VAR 0 8
18908: ADD
18909: PUSH
18910: FOR_IN
18911: IFFALSE 18930
// begin MyPlaceUnitArea ( i , rus_mat_l , false ) ;
18913: LD_VAR 0 3
18917: PPUSH
18918: LD_INT 3
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: CALL 23774 0 3
// end ;
18928: GO 18910
18930: POP
18931: POP
// wait ( 0 0$1 ) ;
18932: LD_INT 35
18934: PPUSH
18935: CALL_OW 67
// AttackBase ( u2 , pathBL ^ pathUL ) ;
18939: LD_VAR 0 4
18943: PPUSH
18944: LD_EXP 108
18948: PUSH
18949: LD_EXP 111
18953: ADD
18954: PPUSH
18955: CALL 13830 0 2
// case difficulty of 1 :
18959: LD_OWVAR 67
18963: PUSH
18964: LD_INT 1
18966: DOUBLE
18967: EQUAL
18968: IFTRUE 18972
18970: GO 19005
18972: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl ] ) ;
18973: LD_ADDR_VAR 0 6
18977: PUSH
18978: LD_EXP 10
18982: PUSH
18983: LD_EXP 11
18987: PUSH
18988: LD_EXP 12
18992: PUSH
18993: EMPTY
18994: LIST
18995: LIST
18996: LIST
18997: PPUSH
18998: CALL 23444 0 1
19002: ST_TO_ADDR
// end ; 2 :
19003: GO 19100
19005: LD_INT 2
19007: DOUBLE
19008: EQUAL
19009: IFTRUE 19013
19011: GO 19052
19013: POP
// begin u3 := CreateVC ( [ mgg , mg , mrl , hgg ] ) ;
19014: LD_ADDR_VAR 0 6
19018: PUSH
19019: LD_EXP 10
19023: PUSH
19024: LD_EXP 11
19028: PUSH
19029: LD_EXP 12
19033: PUSH
19034: LD_EXP 13
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: PPUSH
19045: CALL 23444 0 1
19049: ST_TO_ADDR
// end ; 3 :
19050: GO 19100
19052: LD_INT 3
19054: DOUBLE
19055: EQUAL
19056: IFTRUE 19060
19058: GO 19099
19060: POP
// begin u3 := CreateVC ( [ mgg , mg , hrl , hgg ] ) ;
19061: LD_ADDR_VAR 0 6
19065: PUSH
19066: LD_EXP 10
19070: PUSH
19071: LD_EXP 11
19075: PUSH
19076: LD_EXP 14
19080: PUSH
19081: LD_EXP 13
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: PPUSH
19092: CALL 23444 0 1
19096: ST_TO_ADDR
// end ; end ;
19097: GO 19100
19099: POP
// for i in u3 do
19100: LD_ADDR_VAR 0 3
19104: PUSH
19105: LD_VAR 0 6
19109: PUSH
19110: FOR_IN
19111: IFFALSE 19130
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19113: LD_VAR 0 3
19117: PPUSH
19118: LD_INT 14
19120: PPUSH
19121: LD_INT 0
19123: PPUSH
19124: CALL 23774 0 3
// end ;
19128: GO 19110
19130: POP
19131: POP
// wait ( 0 0$1 ) ;
19132: LD_INT 35
19134: PPUSH
19135: CALL_OW 67
// AttackBase ( u3 , pathT ) ;
19139: LD_VAR 0 6
19143: PPUSH
19144: LD_EXP 117
19148: PPUSH
19149: CALL 13830 0 2
// end ;
19153: PPOPN 8
19155: END
// every 0 0$5 trigger last_attack and timer < rusaci_pred_koncem do var u1 , p1 , i , u2 , p2 , u3 , p3 , u4 , p4 ;
19156: LD_EXP 3
19160: PUSH
19161: LD_EXP 62
19165: PUSH
19166: LD_EXP 6
19170: LESS
19171: AND
19172: IFFALSE 20755
19174: GO 19176
19176: DISABLE
19177: LD_INT 0
19179: PPUSH
19180: PPUSH
19181: PPUSH
19182: PPUSH
19183: PPUSH
19184: PPUSH
19185: PPUSH
19186: PPUSH
19187: PPUSH
// begin lev := [ 8 , 8 , 8 ] ;
19188: LD_ADDR_EXP 5
19192: PUSH
19193: LD_INT 8
19195: PUSH
19196: LD_INT 8
19198: PUSH
19199: LD_INT 8
19201: PUSH
19202: EMPTY
19203: LIST
19204: LIST
19205: LIST
19206: ST_TO_ADDR
// SetTech ( tech_Comp1 , russians , state_researched ) ;
19207: LD_INT 57
19209: PPUSH
19210: LD_EXP 49
19214: PPUSH
19215: LD_INT 2
19217: PPUSH
19218: CALL_OW 322
// SetTech ( tech_Comp2 , russians , state_researched ) ;
19222: LD_INT 58
19224: PPUSH
19225: LD_EXP 49
19229: PPUSH
19230: LD_INT 2
19232: PPUSH
19233: CALL_OW 322
// SetTech ( tech_Comp3 , russians , state_researched ) ;
19237: LD_INT 59
19239: PPUSH
19240: LD_EXP 49
19244: PPUSH
19245: LD_INT 2
19247: PPUSH
19248: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
19252: LD_INT 51
19254: PPUSH
19255: LD_EXP 49
19259: PPUSH
19260: LD_INT 2
19262: PPUSH
19263: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
19267: LD_INT 52
19269: PPUSH
19270: LD_EXP 49
19274: PPUSH
19275: LD_INT 2
19277: PPUSH
19278: CALL_OW 322
// SetTech ( tech_Weap3 , russians , state_researched ) ;
19282: LD_INT 53
19284: PPUSH
19285: LD_EXP 49
19289: PPUSH
19290: LD_INT 2
19292: PPUSH
19293: CALL_OW 322
// case difficulty of 1 :
19297: LD_OWVAR 67
19301: PUSH
19302: LD_INT 1
19304: DOUBLE
19305: EQUAL
19306: IFTRUE 19310
19308: GO 19349
19310: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19311: LD_ADDR_VAR 0 1
19315: PUSH
19316: LD_EXP 14
19320: PUSH
19321: LD_EXP 14
19325: PUSH
19326: LD_EXP 14
19330: PUSH
19331: LD_EXP 14
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: LIST
19340: LIST
19341: PPUSH
19342: CALL 23444 0 1
19346: ST_TO_ADDR
// end ; 2 :
19347: GO 19444
19349: LD_INT 2
19351: DOUBLE
19352: EQUAL
19353: IFTRUE 19357
19355: GO 19396
19357: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19358: LD_ADDR_VAR 0 1
19362: PUSH
19363: LD_EXP 14
19367: PUSH
19368: LD_EXP 14
19372: PUSH
19373: LD_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: EMPTY
19384: LIST
19385: LIST
19386: LIST
19387: LIST
19388: PPUSH
19389: CALL 23444 0 1
19393: ST_TO_ADDR
// end ; 3 :
19394: GO 19444
19396: LD_INT 3
19398: DOUBLE
19399: EQUAL
19400: IFTRUE 19404
19402: GO 19443
19404: POP
// begin u1 := CreateVC ( [ hrl , hrl , hrl , hrl ] ) ;
19405: LD_ADDR_VAR 0 1
19409: PUSH
19410: LD_EXP 14
19414: PUSH
19415: LD_EXP 14
19419: PUSH
19420: LD_EXP 14
19424: PUSH
19425: LD_EXP 14
19429: PUSH
19430: EMPTY
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: PPUSH
19436: CALL 23444 0 1
19440: ST_TO_ADDR
// end ; end ;
19441: GO 19444
19443: POP
// for i in u1 do
19444: LD_ADDR_VAR 0 3
19448: PUSH
19449: LD_VAR 0 1
19453: PUSH
19454: FOR_IN
19455: IFFALSE 19474
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
19457: LD_VAR 0 3
19461: PPUSH
19462: LD_INT 14
19464: PPUSH
19465: LD_INT 0
19467: PPUSH
19468: CALL 23774 0 3
// end ;
19472: GO 19454
19474: POP
19475: POP
// wait ( 0 0$1 ) ;
19476: LD_INT 35
19478: PPUSH
19479: CALL_OW 67
// AttackBase ( u1 , pathBL ^ pathUL ) ;
19483: LD_VAR 0 1
19487: PPUSH
19488: LD_EXP 108
19492: PUSH
19493: LD_EXP 111
19497: ADD
19498: PPUSH
19499: CALL 13830 0 2
// case difficulty of 1 :
19503: LD_OWVAR 67
19507: PUSH
19508: LD_INT 1
19510: DOUBLE
19511: EQUAL
19512: IFTRUE 19516
19514: GO 19565
19516: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19517: LD_ADDR_VAR 0 4
19521: PUSH
19522: LD_EXP 15
19526: PUSH
19527: LD_EXP 15
19531: PUSH
19532: LD_EXP 14
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: LIST
19541: PPUSH
19542: CALL 23118 0 1
19546: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19547: LD_ADDR_VAR 0 5
19551: PUSH
19552: LD_INT 0
19554: PPUSH
19555: LD_INT 3
19557: PPUSH
19558: CALL 22665 0 2
19562: ST_TO_ADDR
// end ; 2 :
19563: GO 19680
19565: LD_INT 2
19567: DOUBLE
19568: EQUAL
19569: IFTRUE 19573
19571: GO 19622
19573: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19574: LD_ADDR_VAR 0 4
19578: PUSH
19579: LD_EXP 15
19583: PUSH
19584: LD_EXP 15
19588: PUSH
19589: LD_EXP 14
19593: PUSH
19594: EMPTY
19595: LIST
19596: LIST
19597: LIST
19598: PPUSH
19599: CALL 23118 0 1
19603: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19604: LD_ADDR_VAR 0 5
19608: PUSH
19609: LD_INT 0
19611: PPUSH
19612: LD_INT 3
19614: PPUSH
19615: CALL 22665 0 2
19619: ST_TO_ADDR
// end ; 3 :
19620: GO 19680
19622: LD_INT 3
19624: DOUBLE
19625: EQUAL
19626: IFTRUE 19630
19628: GO 19679
19630: POP
// begin u2 := CreateVH ( [ hhg , hhg , hrl ] ) ;
19631: LD_ADDR_VAR 0 4
19635: PUSH
19636: LD_EXP 15
19640: PUSH
19641: LD_EXP 15
19645: PUSH
19646: LD_EXP 14
19650: PUSH
19651: EMPTY
19652: LIST
19653: LIST
19654: LIST
19655: PPUSH
19656: CALL 23118 0 1
19660: ST_TO_ADDR
// p2 := CreateH ( 0 , 3 ) ;
19661: LD_ADDR_VAR 0 5
19665: PUSH
19666: LD_INT 0
19668: PPUSH
19669: LD_INT 3
19671: PPUSH
19672: CALL 22665 0 2
19676: ST_TO_ADDR
// end ; end ;
19677: GO 19680
19679: POP
// for i := 1 to u2 do
19680: LD_ADDR_VAR 0 3
19684: PUSH
19685: DOUBLE
19686: LD_INT 1
19688: DEC
19689: ST_TO_ADDR
19690: LD_VAR 0 4
19694: PUSH
19695: FOR_TO
19696: IFFALSE 19726
// begin PlaceHumanInUnit ( p2 [ i ] , u2 [ i ] ) ;
19698: LD_VAR 0 5
19702: PUSH
19703: LD_VAR 0 3
19707: ARRAY
19708: PPUSH
19709: LD_VAR 0 4
19713: PUSH
19714: LD_VAR 0 3
19718: ARRAY
19719: PPUSH
19720: CALL_OW 52
// end ;
19724: GO 19695
19726: POP
19727: POP
// for i in u2 do
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_VAR 0 4
19737: PUSH
19738: FOR_IN
19739: IFFALSE 19758
// begin MyPlaceUnitArea ( i , rus_mat_m , false ) ;
19741: LD_VAR 0 3
19745: PPUSH
19746: LD_INT 2
19748: PPUSH
19749: LD_INT 0
19751: PPUSH
19752: CALL 23774 0 3
// end ;
19756: GO 19738
19758: POP
19759: POP
// wait ( 0 0$1 ) ;
19760: LD_INT 35
19762: PPUSH
19763: CALL_OW 67
// AttackBase ( u2 , pathBM ^ ReverseList ( pathML ) ^ pathUL ) ;
19767: LD_VAR 0 4
19771: PPUSH
19772: LD_EXP 109
19776: PUSH
19777: LD_EXP 114
19781: PPUSH
19782: CALL 13425 0 1
19786: ADD
19787: PUSH
19788: LD_EXP 111
19792: ADD
19793: PPUSH
19794: CALL 13830 0 2
// p4 := CreateS ( 3 ) ;
19798: LD_ADDR_VAR 0 9
19802: PUSH
19803: LD_INT 3
19805: PPUSH
19806: CALL 22994 0 1
19810: ST_TO_ADDR
// p4 := p4 ^ CreateB ( 3 ) ;
19811: LD_ADDR_VAR 0 9
19815: PUSH
19816: LD_VAR 0 9
19820: PUSH
19821: LD_INT 3
19823: PPUSH
19824: CALL 22870 0 1
19828: ADD
19829: ST_TO_ADDR
// for i in p4 do
19830: LD_ADDR_VAR 0 3
19834: PUSH
19835: LD_VAR 0 9
19839: PUSH
19840: FOR_IN
19841: IFFALSE 19860
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
19843: LD_VAR 0 3
19847: PPUSH
19848: LD_INT 15
19850: PPUSH
19851: LD_INT 0
19853: PPUSH
19854: CALL 23774 0 3
// end ;
19858: GO 19840
19860: POP
19861: POP
// wait ( 0 0$1 ) ;
19862: LD_INT 35
19864: PPUSH
19865: CALL_OW 67
// AttackBase ( p4 , pathBR ^ pathUR ) ;
19869: LD_VAR 0 9
19873: PPUSH
19874: LD_EXP 110
19878: PUSH
19879: LD_EXP 112
19883: ADD
19884: PPUSH
19885: CALL 13830 0 2
// case difficulty of 1 :
19889: LD_OWVAR 67
19893: PUSH
19894: LD_INT 1
19896: DOUBLE
19897: EQUAL
19898: IFTRUE 19902
19900: GO 19957
19902: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19903: LD_ADDR_VAR 0 6
19907: PUSH
19908: LD_EXP 15
19912: PUSH
19913: LD_EXP 14
19917: PUSH
19918: LD_EXP 15
19922: PUSH
19923: LD_EXP 13
19927: PUSH
19928: EMPTY
19929: LIST
19930: LIST
19931: LIST
19932: LIST
19933: PPUSH
19934: CALL 23118 0 1
19938: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
19939: LD_ADDR_VAR 0 7
19943: PUSH
19944: LD_INT 0
19946: PPUSH
19947: LD_INT 4
19949: PPUSH
19950: CALL 22665 0 2
19954: ST_TO_ADDR
// end ; 2 :
19955: GO 20084
19957: LD_INT 2
19959: DOUBLE
19960: EQUAL
19961: IFTRUE 19965
19963: GO 20020
19965: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
19966: LD_ADDR_VAR 0 6
19970: PUSH
19971: LD_EXP 15
19975: PUSH
19976: LD_EXP 14
19980: PUSH
19981: LD_EXP 15
19985: PUSH
19986: LD_EXP 13
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: PPUSH
19997: CALL 23118 0 1
20001: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20002: LD_ADDR_VAR 0 7
20006: PUSH
20007: LD_INT 0
20009: PPUSH
20010: LD_INT 4
20012: PPUSH
20013: CALL 22665 0 2
20017: ST_TO_ADDR
// end ; 3 :
20018: GO 20084
20020: LD_INT 3
20022: DOUBLE
20023: EQUAL
20024: IFTRUE 20028
20026: GO 20083
20028: POP
// begin u3 := CreateVH ( [ hhg , hrl , hhg , hgg ] ) ;
20029: LD_ADDR_VAR 0 6
20033: PUSH
20034: LD_EXP 15
20038: PUSH
20039: LD_EXP 14
20043: PUSH
20044: LD_EXP 15
20048: PUSH
20049: LD_EXP 13
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: PPUSH
20060: CALL 23118 0 1
20064: ST_TO_ADDR
// p3 := CreateH ( 0 , 4 ) ;
20065: LD_ADDR_VAR 0 7
20069: PUSH
20070: LD_INT 0
20072: PPUSH
20073: LD_INT 4
20075: PPUSH
20076: CALL 22665 0 2
20080: ST_TO_ADDR
// end ; end ;
20081: GO 20084
20083: POP
// for i := 1 to u3 do
20084: LD_ADDR_VAR 0 3
20088: PUSH
20089: DOUBLE
20090: LD_INT 1
20092: DEC
20093: ST_TO_ADDR
20094: LD_VAR 0 6
20098: PUSH
20099: FOR_TO
20100: IFFALSE 20130
// begin PlaceHumanInUnit ( p3 [ i ] , u3 [ i ] ) ;
20102: LD_VAR 0 7
20106: PUSH
20107: LD_VAR 0 3
20111: ARRAY
20112: PPUSH
20113: LD_VAR 0 6
20117: PUSH
20118: LD_VAR 0 3
20122: ARRAY
20123: PPUSH
20124: CALL_OW 52
// end ;
20128: GO 20099
20130: POP
20131: POP
// for i in u3 do
20132: LD_ADDR_VAR 0 3
20136: PUSH
20137: LD_VAR 0 6
20141: PUSH
20142: FOR_IN
20143: IFFALSE 20162
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20145: LD_VAR 0 3
20149: PPUSH
20150: LD_INT 15
20152: PPUSH
20153: LD_INT 0
20155: PPUSH
20156: CALL 23774 0 3
// end ;
20160: GO 20142
20162: POP
20163: POP
// wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// AttackBase ( u3 , pathBR ^ pathUR ) ;
20171: LD_VAR 0 6
20175: PPUSH
20176: LD_EXP 110
20180: PUSH
20181: LD_EXP 112
20185: ADD
20186: PPUSH
20187: CALL 13830 0 2
// case difficulty of 1 :
20191: LD_OWVAR 67
20195: PUSH
20196: LD_INT 1
20198: DOUBLE
20199: EQUAL
20200: IFTRUE 20204
20202: GO 20243
20204: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20205: LD_ADDR_VAR 0 8
20209: PUSH
20210: LD_EXP 13
20214: PUSH
20215: LD_EXP 14
20219: PUSH
20220: LD_EXP 15
20224: PUSH
20225: LD_EXP 10
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: PPUSH
20236: CALL 23444 0 1
20240: ST_TO_ADDR
// end ; 2 :
20241: GO 20338
20243: LD_INT 2
20245: DOUBLE
20246: EQUAL
20247: IFTRUE 20251
20249: GO 20290
20251: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20252: LD_ADDR_VAR 0 8
20256: PUSH
20257: LD_EXP 13
20261: PUSH
20262: LD_EXP 14
20266: PUSH
20267: LD_EXP 15
20271: PUSH
20272: LD_EXP 10
20276: PUSH
20277: EMPTY
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: PPUSH
20283: CALL 23444 0 1
20287: ST_TO_ADDR
// end ; 3 :
20288: GO 20338
20290: LD_INT 3
20292: DOUBLE
20293: EQUAL
20294: IFTRUE 20298
20296: GO 20337
20298: POP
// begin u4 := CreateVC ( [ hgg , hrl , hhg , mgg ] ) ;
20299: LD_ADDR_VAR 0 8
20303: PUSH
20304: LD_EXP 13
20308: PUSH
20309: LD_EXP 14
20313: PUSH
20314: LD_EXP 15
20318: PUSH
20319: LD_EXP 10
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: PPUSH
20330: CALL 23444 0 1
20334: ST_TO_ADDR
// end ; end ;
20335: GO 20338
20337: POP
// for i in u4 do
20338: LD_ADDR_VAR 0 3
20342: PUSH
20343: LD_VAR 0 8
20347: PUSH
20348: FOR_IN
20349: IFFALSE 20368
// begin MyPlaceUnitArea ( i , rus_mat_t , false ) ;
20351: LD_VAR 0 3
20355: PPUSH
20356: LD_INT 14
20358: PPUSH
20359: LD_INT 0
20361: PPUSH
20362: CALL 23774 0 3
// end ;
20366: GO 20348
20368: POP
20369: POP
// wait ( 0 0$1 ) ;
20370: LD_INT 35
20372: PPUSH
20373: CALL_OW 67
// AttackBase ( u4 , pathUT ) ;
20377: LD_VAR 0 8
20381: PPUSH
20382: LD_EXP 113
20386: PPUSH
20387: CALL 13830 0 2
// p4 := CreateB ( 3 ) ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 3
20398: PPUSH
20399: CALL 22870 0 1
20403: ST_TO_ADDR
// p4 := p4 ^ CreateS ( 3 ) ;
20404: LD_ADDR_VAR 0 9
20408: PUSH
20409: LD_VAR 0 9
20413: PUSH
20414: LD_INT 3
20416: PPUSH
20417: CALL 22994 0 1
20421: ADD
20422: ST_TO_ADDR
// for i in p4 do
20423: LD_ADDR_VAR 0 3
20427: PUSH
20428: LD_VAR 0 9
20432: PUSH
20433: FOR_IN
20434: IFFALSE 20453
// begin MyPlaceUnitArea ( i , rus_mat_r , false ) ;
20436: LD_VAR 0 3
20440: PPUSH
20441: LD_INT 15
20443: PPUSH
20444: LD_INT 0
20446: PPUSH
20447: CALL 23774 0 3
// end ;
20451: GO 20433
20453: POP
20454: POP
// wait ( 0 0$1 ) ;
20455: LD_INT 35
20457: PPUSH
20458: CALL_OW 67
// AttackBase ( p4 , pathUT ) ;
20462: LD_VAR 0 9
20466: PPUSH
20467: LD_EXP 113
20471: PPUSH
20472: CALL 13830 0 2
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_siberite_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_turret ] ] ] ) do
20476: LD_ADDR_VAR 0 3
20480: PUSH
20481: LD_INT 22
20483: PUSH
20484: LD_EXP 47
20488: PUSH
20489: EMPTY
20490: LIST
20491: LIST
20492: PUSH
20493: LD_INT 2
20495: PUSH
20496: LD_INT 30
20498: PUSH
20499: LD_INT 28
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: LD_INT 30
20508: PUSH
20509: LD_INT 26
20511: PUSH
20512: EMPTY
20513: LIST
20514: LIST
20515: PUSH
20516: LD_INT 30
20518: PUSH
20519: LD_INT 27
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 30
20528: PUSH
20529: LD_INT 5
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: PUSH
20536: LD_INT 30
20538: PUSH
20539: LD_INT 4
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: PUSH
20546: LD_INT 30
20548: PUSH
20549: LD_INT 32
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 31
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: LD_INT 30
20568: PUSH
20569: LD_INT 33
20571: PUSH
20572: EMPTY
20573: LIST
20574: LIST
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: PPUSH
20591: CALL_OW 69
20595: PUSH
20596: FOR_IN
20597: IFFALSE 20615
// begin PriorityAttack ( russians , i ) ;
20599: LD_EXP 49
20603: PPUSH
20604: LD_VAR 0 3
20608: PPUSH
20609: CALL_OW 470
// end ;
20613: GO 20596
20615: POP
20616: POP
// wait ( 0 0$20 ) ;
20617: LD_INT 700
20619: PPUSH
20620: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_not , [ f_btype , b_warehouse ] ] , [ f_not , [ f_btype , b_depot ] ] ] ) do
20624: LD_ADDR_VAR 0 3
20628: PUSH
20629: LD_INT 22
20631: PUSH
20632: LD_EXP 47
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: PUSH
20641: LD_INT 3
20643: PUSH
20644: LD_INT 30
20646: PUSH
20647: LD_INT 1
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: PUSH
20654: EMPTY
20655: LIST
20656: LIST
20657: PUSH
20658: LD_INT 3
20660: PUSH
20661: LD_INT 30
20663: PUSH
20664: LD_INT 0
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: PUSH
20675: EMPTY
20676: LIST
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: FOR_IN
20686: IFFALSE 20704
// begin PriorityAttack ( russians , i ) ;
20688: LD_EXP 49
20692: PPUSH
20693: LD_VAR 0 3
20697: PPUSH
20698: CALL_OW 470
// end ;
20702: GO 20685
20704: POP
20705: POP
// wait ( 0 0$30 ) ;
20706: LD_INT 1050
20708: PPUSH
20709: CALL_OW 67
// if Getside ( rudepot1 ) = you and xxx < 2 then
20713: LD_EXP 67
20717: PPUSH
20718: CALL_OW 255
20722: PUSH
20723: LD_EXP 47
20727: EQUAL
20728: PUSH
20729: LD_EXP 107
20733: PUSH
20734: LD_INT 2
20736: LESS
20737: AND
20738: IFFALSE 20755
// begin xxx := xxx + 1 ;
20740: LD_ADDR_EXP 107
20744: PUSH
20745: LD_EXP 107
20749: PUSH
20750: LD_INT 1
20752: PLUS
20753: ST_TO_ADDR
// enable ;
20754: ENABLE
// end ; end ;
20755: PPOPN 9
20757: END
// export xxx ; every 0 0$15 trigger GetSide ( RuDepot1 ) = you and not FilterHumansInArea ( base , [ f_side , you ] ) do var ing , i , a ;
20758: LD_EXP 67
20762: PPUSH
20763: CALL_OW 255
20767: PUSH
20768: LD_EXP 47
20772: EQUAL
20773: PUSH
20774: LD_INT 1
20776: PPUSH
20777: LD_INT 22
20779: PUSH
20780: LD_EXP 47
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: PPUSH
20789: CALL 13285 0 2
20793: NOT
20794: AND
20795: IFFALSE 21061
20797: GO 20799
20799: DISABLE
20800: LD_INT 0
20802: PPUSH
20803: PPUSH
20804: PPUSH
// begin InitUc ;
20805: CALL_OW 18
// InitHc ;
20809: CALL_OW 19
// uc_side := russians ;
20813: LD_ADDR_OWVAR 20
20817: PUSH
20818: LD_EXP 49
20822: ST_TO_ADDR
// uc_nation := nation_russian ;
20823: LD_ADDR_OWVAR 21
20827: PUSH
20828: LD_INT 3
20830: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
20831: LD_INT 0
20833: PPUSH
20834: LD_INT 6
20836: PPUSH
20837: CALL_OW 382
// ing := CreateHuman ;
20841: LD_ADDR_VAR 0 1
20845: PUSH
20846: CALL_OW 44
20850: ST_TO_ADDR
// PlaceUnitXYR ( ing , 137 , 147 , 4 , false ) ;
20851: LD_VAR 0 1
20855: PPUSH
20856: LD_INT 137
20858: PPUSH
20859: LD_INT 147
20861: PPUSH
20862: LD_INT 4
20864: PPUSH
20865: LD_INT 0
20867: PPUSH
20868: CALL_OW 50
// wait ( 0 0$5 ) ;
20872: LD_INT 175
20874: PPUSH
20875: CALL_OW 67
// a := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) ;
20879: LD_ADDR_VAR 0 3
20883: PUSH
20884: LD_INT 22
20886: PUSH
20887: LD_EXP 49
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: PUSH
20896: LD_INT 25
20898: PUSH
20899: LD_INT 2
20901: PUSH
20902: EMPTY
20903: LIST
20904: LIST
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: PPUSH
20910: CALL_OW 69
20914: ST_TO_ADDR
// ComMoveUnit ( a , rudepot1 ) ;
20915: LD_VAR 0 3
20919: PPUSH
20920: LD_EXP 67
20924: PPUSH
20925: CALL_OW 112
// wait ( 0 0$20 ) ;
20929: LD_INT 700
20931: PPUSH
20932: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) > 3 then
20936: LD_INT 22
20938: PUSH
20939: LD_EXP 49
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PUSH
20948: LD_INT 25
20950: PUSH
20951: LD_INT 2
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PPUSH
20962: CALL_OW 69
20966: PUSH
20967: LD_INT 3
20969: GREATER
20970: IFFALSE 21060
// begin TimerEnable := true ;
20972: LD_ADDR_EXP 63
20976: PUSH
20977: LD_INT 1
20979: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
20980: LD_ADDR_EXP 81
20984: PUSH
20985: LD_EXP 49
20989: PPUSH
20990: CALL_OW 462
20994: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
20995: LD_EXP 67
20999: PPUSH
21000: CALL_OW 274
21004: PPUSH
21005: LD_EXP 49
21009: PPUSH
21010: CALL_OW 236
// for i in FilterAllUnits ( [ [ f_side , you ] ] ) do
21014: LD_ADDR_VAR 0 2
21018: PUSH
21019: LD_INT 22
21021: PUSH
21022: LD_EXP 47
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: PUSH
21031: EMPTY
21032: LIST
21033: PPUSH
21034: CALL_OW 69
21038: PUSH
21039: FOR_IN
21040: IFFALSE 21058
// NormalAttack ( russians , i ) ;
21042: LD_EXP 49
21046: PPUSH
21047: LD_VAR 0 2
21051: PPUSH
21052: CALL_OW 472
21056: GO 21039
21058: POP
21059: POP
// end ; enable ;
21060: ENABLE
// end ;
21061: PPOPN 3
21063: END
// every 0 0$5 do var a ;
21064: GO 21066
21066: DISABLE
21067: LD_INT 0
21069: PPUSH
// begin a := FilterAllUnits ( [ [ f_side , russians ] , [ f_not , [ f_hastask ] ] ] ) ;
21070: LD_ADDR_VAR 0 1
21074: PUSH
21075: LD_INT 22
21077: PUSH
21078: LD_EXP 49
21082: PUSH
21083: EMPTY
21084: LIST
21085: LIST
21086: PUSH
21087: LD_INT 3
21089: PUSH
21090: LD_INT 60
21092: PUSH
21093: EMPTY
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PPUSH
21104: CALL_OW 69
21108: ST_TO_ADDR
// wait ( 0 0$5 ) ;
21109: LD_INT 175
21111: PPUSH
21112: CALL_OW 67
// a := UnitFilter ( a , [ f_not , [ f_hastask ] ] ) ;
21116: LD_ADDR_VAR 0 1
21120: PUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: LD_INT 3
21128: PUSH
21129: LD_INT 60
21131: PUSH
21132: EMPTY
21133: LIST
21134: PUSH
21135: EMPTY
21136: LIST
21137: LIST
21138: PPUSH
21139: CALL_OW 72
21143: ST_TO_ADDR
// if a then
21144: LD_VAR 0 1
21148: IFFALSE 21216
// begin ComAgressiveMove ( UnitFilter ( a , [ [ f_inarea , top_half ] ] ) , 42 , 10 ) ;
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 95
21157: PUSH
21158: LD_INT 6
21160: PUSH
21161: EMPTY
21162: LIST
21163: LIST
21164: PUSH
21165: EMPTY
21166: LIST
21167: PPUSH
21168: CALL_OW 72
21172: PPUSH
21173: LD_INT 42
21175: PPUSH
21176: LD_INT 10
21178: PPUSH
21179: CALL_OW 114
// ComAgressiveMove ( UnitFilter ( a , [ [ f_exceptarea , top_half ] ] ) , 93 , 94 ) ;
21183: LD_VAR 0 1
21187: PPUSH
21188: LD_INT 96
21190: PUSH
21191: LD_INT 6
21193: PUSH
21194: EMPTY
21195: LIST
21196: LIST
21197: PUSH
21198: EMPTY
21199: LIST
21200: PPUSH
21201: CALL_OW 72
21205: PPUSH
21206: LD_INT 93
21208: PPUSH
21209: LD_INT 94
21211: PPUSH
21212: CALL_OW 114
// end ; enable ;
21216: ENABLE
// end ;
21217: PPOPN 1
21219: END
// export pathBL , pathBM , pathBR , pathUL , pathUR , pathUT , pathML , pathMM , pathMR , pathT ; export pathB1 , pathB2 , pathB3 , pathB4 ; var d ; every 0 0$0.1 do
21220: GO 21222
21222: DISABLE
// begin pathBL := [ [ 62 , 119 ] , [ 73 , 120 ] , [ 78 , 121 ] , [ 80 , 118 ] , [ 80 , 113 ] , [ 80 , 109 ] ] ;
21223: LD_ADDR_EXP 108
21227: PUSH
21228: LD_INT 62
21230: PUSH
21231: LD_INT 119
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: LD_INT 73
21240: PUSH
21241: LD_INT 120
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PUSH
21248: LD_INT 78
21250: PUSH
21251: LD_INT 121
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: PUSH
21258: LD_INT 80
21260: PUSH
21261: LD_INT 118
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 80
21270: PUSH
21271: LD_INT 113
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 80
21280: PUSH
21281: LD_INT 109
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: LIST
21292: LIST
21293: LIST
21294: LIST
21295: ST_TO_ADDR
// pathBM := [ [ 98 , 144 ] , [ 96 , 139 ] , [ 96 , 135 ] , [ 96 , 131 ] , [ 97 , 128 ] , [ 99 , 126 ] , [ 101 , 124 ] ] ;
21296: LD_ADDR_EXP 109
21300: PUSH
21301: LD_INT 98
21303: PUSH
21304: LD_INT 144
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: PUSH
21311: LD_INT 96
21313: PUSH
21314: LD_INT 139
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: PUSH
21321: LD_INT 96
21323: PUSH
21324: LD_INT 135
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: PUSH
21331: LD_INT 96
21333: PUSH
21334: LD_INT 131
21336: PUSH
21337: EMPTY
21338: LIST
21339: LIST
21340: PUSH
21341: LD_INT 97
21343: PUSH
21344: LD_INT 128
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PUSH
21351: LD_INT 99
21353: PUSH
21354: LD_INT 126
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PUSH
21361: LD_INT 101
21363: PUSH
21364: LD_INT 124
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: ST_TO_ADDR
// pathBR := [ [ 130 , 137 ] , [ 120 , 128 ] ] ;
21380: LD_ADDR_EXP 110
21384: PUSH
21385: LD_INT 130
21387: PUSH
21388: LD_INT 137
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: LD_INT 120
21397: PUSH
21398: LD_INT 128
21400: PUSH
21401: EMPTY
21402: LIST
21403: LIST
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: ST_TO_ADDR
// pathUL := [ [ 80 , 109 ] , [ 77 , 103 ] , [ 72 , 97 ] , [ 71 , 93 ] , [ 76 , 93 ] , [ 81 , 93 ] , [ 86 , 94 ] , [ 92 , 95 ] ] ;
21409: LD_ADDR_EXP 111
21413: PUSH
21414: LD_INT 80
21416: PUSH
21417: LD_INT 109
21419: PUSH
21420: EMPTY
21421: LIST
21422: LIST
21423: PUSH
21424: LD_INT 77
21426: PUSH
21427: LD_INT 103
21429: PUSH
21430: EMPTY
21431: LIST
21432: LIST
21433: PUSH
21434: LD_INT 72
21436: PUSH
21437: LD_INT 97
21439: PUSH
21440: EMPTY
21441: LIST
21442: LIST
21443: PUSH
21444: LD_INT 71
21446: PUSH
21447: LD_INT 93
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: PUSH
21454: LD_INT 76
21456: PUSH
21457: LD_INT 93
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 81
21466: PUSH
21467: LD_INT 93
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: LD_INT 86
21476: PUSH
21477: LD_INT 94
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: PUSH
21484: LD_INT 92
21486: PUSH
21487: LD_INT 95
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: LIST
21498: LIST
21499: LIST
21500: LIST
21501: LIST
21502: LIST
21503: ST_TO_ADDR
// pathUR := [ [ 120 , 128 ] , [ 115 , 123 ] , [ 110 , 118 ] , [ 106 , 114 ] , [ 99 , 107 ] , [ 96 , 100 ] , [ 92 , 95 ] ] ;
21504: LD_ADDR_EXP 112
21508: PUSH
21509: LD_INT 120
21511: PUSH
21512: LD_INT 128
21514: PUSH
21515: EMPTY
21516: LIST
21517: LIST
21518: PUSH
21519: LD_INT 115
21521: PUSH
21522: LD_INT 123
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: PUSH
21529: LD_INT 110
21531: PUSH
21532: LD_INT 118
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 106
21541: PUSH
21542: LD_INT 114
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: LD_INT 99
21551: PUSH
21552: LD_INT 107
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: LD_INT 96
21561: PUSH
21562: LD_INT 100
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: LD_INT 92
21571: PUSH
21572: LD_INT 95
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: ST_TO_ADDR
// pathUT := [ [ 111 , 87 ] , [ 107 , 88 ] , [ 103 , 88 ] , [ 100 , 85 ] , [ 95 , 85 ] , [ 91 , 85 ] ] ;
21588: LD_ADDR_EXP 113
21592: PUSH
21593: LD_INT 111
21595: PUSH
21596: LD_INT 87
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: PUSH
21603: LD_INT 107
21605: PUSH
21606: LD_INT 88
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 103
21615: PUSH
21616: LD_INT 88
21618: PUSH
21619: EMPTY
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 100
21625: PUSH
21626: LD_INT 85
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PUSH
21633: LD_INT 95
21635: PUSH
21636: LD_INT 85
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: LD_INT 91
21645: PUSH
21646: LD_INT 85
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: ST_TO_ADDR
// pathML := [ [ 80 , 109 ] , [ 85 , 111 ] , [ 89 , 112 ] , [ 94 , 117 ] , [ 98 , 121 ] , [ 101 , 124 ] ] ;
21661: LD_ADDR_EXP 114
21665: PUSH
21666: LD_INT 80
21668: PUSH
21669: LD_INT 109
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: LD_INT 85
21678: PUSH
21679: LD_INT 111
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PUSH
21686: LD_INT 89
21688: PUSH
21689: LD_INT 112
21691: PUSH
21692: EMPTY
21693: LIST
21694: LIST
21695: PUSH
21696: LD_INT 94
21698: PUSH
21699: LD_INT 117
21701: PUSH
21702: EMPTY
21703: LIST
21704: LIST
21705: PUSH
21706: LD_INT 98
21708: PUSH
21709: LD_INT 121
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PUSH
21716: LD_INT 101
21718: PUSH
21719: LD_INT 124
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: LIST
21730: LIST
21731: LIST
21732: LIST
21733: ST_TO_ADDR
// pathMM := [ [ 101 , 124 ] , [ 105 , 125 ] , [ 112 , 128 ] , [ 117 , 129 ] , [ 120 , 128 ] ] ;
21734: LD_ADDR_EXP 115
21738: PUSH
21739: LD_INT 101
21741: PUSH
21742: LD_INT 124
21744: PUSH
21745: EMPTY
21746: LIST
21747: LIST
21748: PUSH
21749: LD_INT 105
21751: PUSH
21752: LD_INT 125
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 112
21761: PUSH
21762: LD_INT 128
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 117
21771: PUSH
21772: LD_INT 129
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: PUSH
21779: LD_INT 120
21781: PUSH
21782: LD_INT 128
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: LIST
21794: LIST
21795: ST_TO_ADDR
// pathMR := [ [ 120 , 128 ] , [ 121 , 124 ] , [ 119 , 118 ] , [ 116 , 112 ] , [ 115 , 105 ] , [ 116 , 100 ] , [ 114 , 92 ] , [ 111 , 87 ] ] ;
21796: LD_ADDR_EXP 116
21800: PUSH
21801: LD_INT 120
21803: PUSH
21804: LD_INT 128
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: PUSH
21811: LD_INT 121
21813: PUSH
21814: LD_INT 124
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PUSH
21821: LD_INT 119
21823: PUSH
21824: LD_INT 118
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_INT 116
21833: PUSH
21834: LD_INT 112
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: PUSH
21841: LD_INT 115
21843: PUSH
21844: LD_INT 105
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: PUSH
21851: LD_INT 116
21853: PUSH
21854: LD_INT 100
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: PUSH
21861: LD_INT 114
21863: PUSH
21864: LD_INT 92
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: LD_INT 111
21873: PUSH
21874: LD_INT 87
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: LIST
21887: LIST
21888: LIST
21889: LIST
21890: ST_TO_ADDR
// pathT := [ [ 111 , 87 ] , [ 109 , 82 ] , [ 105 , 77 ] , [ 103 , 71 ] , [ 100 , 65 ] , [ 97 , 62 ] , [ 93 , 61 ] , [ 92 , 56 ] , [ 90 , 52 ] , [ 87 , 48 ] , [ 82 , 46 ] , [ 78 , 44 ] , [ 76 , 37 ] , [ 75 , 33 ] , [ 75 , 29 ] , [ 71 , 25 ] , [ 67 , 23 ] , [ 62 , 22 ] , [ 59 , 23 ] , [ 57 , 26 ] , [ 54 , 37 ] , [ 51 , 29 ] , [ 47 , 26 ] , [ 45 , 23 ] , [ 42 , 18 ] ] ;
21891: LD_ADDR_EXP 117
21895: PUSH
21896: LD_INT 111
21898: PUSH
21899: LD_INT 87
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: PUSH
21906: LD_INT 109
21908: PUSH
21909: LD_INT 82
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: LD_INT 105
21918: PUSH
21919: LD_INT 77
21921: PUSH
21922: EMPTY
21923: LIST
21924: LIST
21925: PUSH
21926: LD_INT 103
21928: PUSH
21929: LD_INT 71
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: PUSH
21936: LD_INT 100
21938: PUSH
21939: LD_INT 65
21941: PUSH
21942: EMPTY
21943: LIST
21944: LIST
21945: PUSH
21946: LD_INT 97
21948: PUSH
21949: LD_INT 62
21951: PUSH
21952: EMPTY
21953: LIST
21954: LIST
21955: PUSH
21956: LD_INT 93
21958: PUSH
21959: LD_INT 61
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: PUSH
21966: LD_INT 92
21968: PUSH
21969: LD_INT 56
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PUSH
21976: LD_INT 90
21978: PUSH
21979: LD_INT 52
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: PUSH
21986: LD_INT 87
21988: PUSH
21989: LD_INT 48
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: LD_INT 82
21998: PUSH
21999: LD_INT 46
22001: PUSH
22002: EMPTY
22003: LIST
22004: LIST
22005: PUSH
22006: LD_INT 78
22008: PUSH
22009: LD_INT 44
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 76
22018: PUSH
22019: LD_INT 37
22021: PUSH
22022: EMPTY
22023: LIST
22024: LIST
22025: PUSH
22026: LD_INT 75
22028: PUSH
22029: LD_INT 33
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: PUSH
22036: LD_INT 75
22038: PUSH
22039: LD_INT 29
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: PUSH
22046: LD_INT 71
22048: PUSH
22049: LD_INT 25
22051: PUSH
22052: EMPTY
22053: LIST
22054: LIST
22055: PUSH
22056: LD_INT 67
22058: PUSH
22059: LD_INT 23
22061: PUSH
22062: EMPTY
22063: LIST
22064: LIST
22065: PUSH
22066: LD_INT 62
22068: PUSH
22069: LD_INT 22
22071: PUSH
22072: EMPTY
22073: LIST
22074: LIST
22075: PUSH
22076: LD_INT 59
22078: PUSH
22079: LD_INT 23
22081: PUSH
22082: EMPTY
22083: LIST
22084: LIST
22085: PUSH
22086: LD_INT 57
22088: PUSH
22089: LD_INT 26
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: PUSH
22096: LD_INT 54
22098: PUSH
22099: LD_INT 37
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PUSH
22106: LD_INT 51
22108: PUSH
22109: LD_INT 29
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: PUSH
22116: LD_INT 47
22118: PUSH
22119: LD_INT 26
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: LD_INT 45
22128: PUSH
22129: LD_INT 23
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: LD_INT 42
22138: PUSH
22139: LD_INT 18
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PUSH
22146: EMPTY
22147: LIST
22148: LIST
22149: LIST
22150: LIST
22151: LIST
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: LIST
22164: LIST
22165: LIST
22166: LIST
22167: LIST
22168: LIST
22169: LIST
22170: LIST
22171: LIST
22172: ST_TO_ADDR
// pathB1 := [ [ 97 , 72 ] , [ 84 , 67 ] , [ 84 , 77 ] ] ;
22173: LD_ADDR_EXP 118
22177: PUSH
22178: LD_INT 97
22180: PUSH
22181: LD_INT 72
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: PUSH
22188: LD_INT 84
22190: PUSH
22191: LD_INT 67
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: PUSH
22198: LD_INT 84
22200: PUSH
22201: LD_INT 77
22203: PUSH
22204: EMPTY
22205: LIST
22206: LIST
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: ST_TO_ADDR
// pathB2 := [ [ 44 , 71 ] , [ 64 , 68 ] , [ 64 , 79 ] ] ;
22213: LD_ADDR_EXP 119
22217: PUSH
22218: LD_INT 44
22220: PUSH
22221: LD_INT 71
22223: PUSH
22224: EMPTY
22225: LIST
22226: LIST
22227: PUSH
22228: LD_INT 64
22230: PUSH
22231: LD_INT 68
22233: PUSH
22234: EMPTY
22235: LIST
22236: LIST
22237: PUSH
22238: LD_INT 64
22240: PUSH
22241: LD_INT 79
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: LIST
22252: ST_TO_ADDR
// pathB3 := [ [ 91 , 131 ] , [ 93 , 121 ] , [ 94 , 115 ] , [ 107 , 115 ] ] ;
22253: LD_ADDR_EXP 120
22257: PUSH
22258: LD_INT 91
22260: PUSH
22261: LD_INT 131
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: PUSH
22268: LD_INT 93
22270: PUSH
22271: LD_INT 121
22273: PUSH
22274: EMPTY
22275: LIST
22276: LIST
22277: PUSH
22278: LD_INT 94
22280: PUSH
22281: LD_INT 115
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PUSH
22288: LD_INT 107
22290: PUSH
22291: LD_INT 115
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PUSH
22298: EMPTY
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: ST_TO_ADDR
// pathB4 := [ [ 126 , 128 ] , [ 116 , 107 ] , [ 107 , 87 ] ] ;
22304: LD_ADDR_EXP 121
22308: PUSH
22309: LD_INT 126
22311: PUSH
22312: LD_INT 128
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: PUSH
22319: LD_INT 116
22321: PUSH
22322: LD_INT 107
22324: PUSH
22325: EMPTY
22326: LIST
22327: LIST
22328: PUSH
22329: LD_INT 107
22331: PUSH
22332: LD_INT 87
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PUSH
22339: EMPTY
22340: LIST
22341: LIST
22342: LIST
22343: ST_TO_ADDR
// lev := [ 2 , 4 , 7 ] ;
22344: LD_ADDR_EXP 5
22348: PUSH
22349: LD_INT 2
22351: PUSH
22352: LD_INT 4
22354: PUSH
22355: LD_INT 7
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: ST_TO_ADDR
// d := difficulty ;
22363: LD_ADDR_LOC 2
22367: PUSH
22368: LD_OWVAR 67
22372: ST_TO_ADDR
// case true of d <= 1 :
22373: LD_INT 1
22375: PUSH
22376: LD_LOC 2
22380: PUSH
22381: LD_INT 1
22383: LESSEQUAL
22384: DOUBLE
22385: EQUAL
22386: IFTRUE 22390
22388: GO 22393
22390: POP
// ; d <= 2 :
22391: GO 22488
22393: LD_LOC 2
22397: PUSH
22398: LD_INT 2
22400: LESSEQUAL
22401: DOUBLE
22402: EQUAL
22403: IFTRUE 22407
22405: GO 22440
22407: POP
// begin SetTech ( tech_Comp1 , russians , state_researched ) ;
22408: LD_INT 57
22410: PPUSH
22411: LD_EXP 49
22415: PPUSH
22416: LD_INT 2
22418: PPUSH
22419: CALL_OW 322
// SetTech ( tech_Weap1 , russians , state_researched ) ;
22423: LD_INT 51
22425: PPUSH
22426: LD_EXP 49
22430: PPUSH
22431: LD_INT 2
22433: PPUSH
22434: CALL_OW 322
// end ; d <= 3 :
22438: GO 22488
22440: LD_LOC 2
22444: PUSH
22445: LD_INT 3
22447: LESSEQUAL
22448: DOUBLE
22449: EQUAL
22450: IFTRUE 22454
22452: GO 22487
22454: POP
// begin SetTech ( tech_Comp2 , russians , state_researched ) ;
22455: LD_INT 58
22457: PPUSH
22458: LD_EXP 49
22462: PPUSH
22463: LD_INT 2
22465: PPUSH
22466: CALL_OW 322
// SetTech ( tech_Weap2 , russians , state_researched ) ;
22470: LD_INT 52
22472: PPUSH
22473: LD_EXP 49
22477: PPUSH
22478: LD_INT 2
22480: PPUSH
22481: CALL_OW 322
// end ; end ;
22485: GO 22488
22487: POP
// end ;
22488: END
// every 31 31$0 do
22489: GO 22491
22491: DISABLE
// begin case difficulty of 1 :
22492: LD_OWVAR 67
22496: PUSH
22497: LD_INT 1
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22523
22505: POP
// SetTech ( tech_Comp1 , russians , state_researched ) ; 2 :
22506: LD_INT 57
22508: PPUSH
22509: LD_EXP 49
22513: PPUSH
22514: LD_INT 2
22516: PPUSH
22517: CALL_OW 322
22521: GO 22576
22523: LD_INT 2
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22549
22531: POP
// SetTech ( tech_Comp2 , russians , state_researched ) ; 3 :
22532: LD_INT 58
22534: PPUSH
22535: LD_EXP 49
22539: PPUSH
22540: LD_INT 2
22542: PPUSH
22543: CALL_OW 322
22547: GO 22576
22549: LD_INT 3
22551: DOUBLE
22552: EQUAL
22553: IFTRUE 22557
22555: GO 22575
22557: POP
// SetTech ( tech_Comp3 , russians , state_researched ) ; end ;
22558: LD_INT 59
22560: PPUSH
22561: LD_EXP 49
22565: PPUSH
22566: LD_INT 2
22568: PPUSH
22569: CALL_OW 322
22573: GO 22576
22575: POP
// end ;
22576: END
// every 47 47$0 do
22577: GO 22579
22579: DISABLE
// begin case difficulty of 1 :
22580: LD_OWVAR 67
22584: PUSH
22585: LD_INT 1
22587: DOUBLE
22588: EQUAL
22589: IFTRUE 22593
22591: GO 22611
22593: POP
// SetTech ( tech_Weap1 , russians , state_researched ) ; 2 :
22594: LD_INT 51
22596: PPUSH
22597: LD_EXP 49
22601: PPUSH
22602: LD_INT 2
22604: PPUSH
22605: CALL_OW 322
22609: GO 22664
22611: LD_INT 2
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22637
22619: POP
// SetTech ( tech_Weap2 , russians , state_researched ) ; 3 :
22620: LD_INT 52
22622: PPUSH
22623: LD_EXP 49
22627: PPUSH
22628: LD_INT 2
22630: PPUSH
22631: CALL_OW 322
22635: GO 22664
22637: LD_INT 3
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22663
22645: POP
// SetTech ( tech_Weap3 , russians , state_researched ) ; end ;
22646: LD_INT 53
22648: PPUSH
22649: LD_EXP 49
22653: PPUSH
22654: LD_INT 2
22656: PPUSH
22657: CALL_OW 322
22661: GO 22664
22663: POP
// end ;
22664: END
// function CreateH ( sol , mec ) ; var units , i ; begin
22665: LD_INT 0
22667: PPUSH
22668: PPUSH
22669: PPUSH
// units := [ ] ;
22670: LD_ADDR_VAR 0 4
22674: PUSH
22675: EMPTY
22676: ST_TO_ADDR
// for i := 1 to sol do
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: DOUBLE
22683: LD_INT 1
22685: DEC
22686: ST_TO_ADDR
22687: LD_VAR 0 1
22691: PUSH
22692: FOR_TO
22693: IFFALSE 22764
// begin InitUc ;
22695: CALL_OW 18
// InitHc ;
22699: CALL_OW 19
// uc_nation := nation_russian ;
22703: LD_ADDR_OWVAR 21
22707: PUSH
22708: LD_INT 3
22710: ST_TO_ADDR
// uc_side := russians ;
22711: LD_ADDR_OWVAR 20
22715: PUSH
22716: LD_EXP 49
22720: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22721: LD_INT 0
22723: PPUSH
22724: LD_EXP 5
22728: PUSH
22729: LD_LOC 2
22733: ARRAY
22734: PPUSH
22735: CALL_OW 381
// units := units ^ CreateHuman ;
22739: LD_ADDR_VAR 0 4
22743: PUSH
22744: LD_VAR 0 4
22748: PUSH
22749: CALL_OW 44
22753: ADD
22754: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22755: LD_INT 7
22757: PPUSH
22758: CALL_OW 67
// end ;
22762: GO 22692
22764: POP
22765: POP
// for i := 1 to mec do
22766: LD_ADDR_VAR 0 5
22770: PUSH
22771: DOUBLE
22772: LD_INT 1
22774: DEC
22775: ST_TO_ADDR
22776: LD_VAR 0 2
22780: PUSH
22781: FOR_TO
22782: IFFALSE 22853
// begin InitUc ;
22784: CALL_OW 18
// InitHc ;
22788: CALL_OW 19
// uc_nation := nation_russian ;
22792: LD_ADDR_OWVAR 21
22796: PUSH
22797: LD_INT 3
22799: ST_TO_ADDR
// uc_side := russians ;
22800: LD_ADDR_OWVAR 20
22804: PUSH
22805: LD_EXP 49
22809: ST_TO_ADDR
// PrepareMechanic ( 0 , lev [ d ] ) ;
22810: LD_INT 0
22812: PPUSH
22813: LD_EXP 5
22817: PUSH
22818: LD_LOC 2
22822: ARRAY
22823: PPUSH
22824: CALL_OW 383
// units := units ^ CreateHuman ;
22828: LD_ADDR_VAR 0 4
22832: PUSH
22833: LD_VAR 0 4
22837: PUSH
22838: CALL_OW 44
22842: ADD
22843: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22844: LD_INT 7
22846: PPUSH
22847: CALL_OW 67
// end ;
22851: GO 22781
22853: POP
22854: POP
// result := units ;
22855: LD_ADDR_VAR 0 3
22859: PUSH
22860: LD_VAR 0 4
22864: ST_TO_ADDR
// end ;
22865: LD_VAR 0 3
22869: RET
// function CreateB ( num ) ; var units , i ; begin
22870: LD_INT 0
22872: PPUSH
22873: PPUSH
22874: PPUSH
// units := [ ] ;
22875: LD_ADDR_VAR 0 3
22879: PUSH
22880: EMPTY
22881: ST_TO_ADDR
// for i := 1 to num do
22882: LD_ADDR_VAR 0 4
22886: PUSH
22887: DOUBLE
22888: LD_INT 1
22890: DEC
22891: ST_TO_ADDR
22892: LD_VAR 0 1
22896: PUSH
22897: FOR_TO
22898: IFFALSE 22977
// begin InitUc ;
22900: CALL_OW 18
// InitHc ;
22904: CALL_OW 19
// uc_nation := nation_russian ;
22908: LD_ADDR_OWVAR 21
22912: PUSH
22913: LD_INT 3
22915: ST_TO_ADDR
// uc_side := russians ;
22916: LD_ADDR_OWVAR 20
22920: PUSH
22921: LD_EXP 49
22925: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
22926: LD_INT 0
22928: PPUSH
22929: LD_EXP 5
22933: PUSH
22934: LD_LOC 2
22938: ARRAY
22939: PPUSH
22940: CALL_OW 381
// hc_class := class_bazooker ;
22944: LD_ADDR_OWVAR 28
22948: PUSH
22949: LD_INT 9
22951: ST_TO_ADDR
// units := units ^ CreateHuman ;
22952: LD_ADDR_VAR 0 3
22956: PUSH
22957: LD_VAR 0 3
22961: PUSH
22962: CALL_OW 44
22966: ADD
22967: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
22968: LD_INT 7
22970: PPUSH
22971: CALL_OW 67
// end ;
22975: GO 22897
22977: POP
22978: POP
// result := units ;
22979: LD_ADDR_VAR 0 2
22983: PUSH
22984: LD_VAR 0 3
22988: ST_TO_ADDR
// end ;
22989: LD_VAR 0 2
22993: RET
// function CreateS ( num ) ; var units , i ; begin
22994: LD_INT 0
22996: PPUSH
22997: PPUSH
22998: PPUSH
// units := [ ] ;
22999: LD_ADDR_VAR 0 3
23003: PUSH
23004: EMPTY
23005: ST_TO_ADDR
// for i := 1 to num do
23006: LD_ADDR_VAR 0 4
23010: PUSH
23011: DOUBLE
23012: LD_INT 1
23014: DEC
23015: ST_TO_ADDR
23016: LD_VAR 0 1
23020: PUSH
23021: FOR_TO
23022: IFFALSE 23101
// begin InitUc ;
23024: CALL_OW 18
// InitHc ;
23028: CALL_OW 19
// uc_nation := nation_russian ;
23032: LD_ADDR_OWVAR 21
23036: PUSH
23037: LD_INT 3
23039: ST_TO_ADDR
// uc_side := russians ;
23040: LD_ADDR_OWVAR 20
23044: PUSH
23045: LD_EXP 49
23049: ST_TO_ADDR
// hc_class := class_soldier ;
23050: LD_ADDR_OWVAR 28
23054: PUSH
23055: LD_INT 1
23057: ST_TO_ADDR
// PrepareSoldier ( 0 , lev [ d ] ) ;
23058: LD_INT 0
23060: PPUSH
23061: LD_EXP 5
23065: PUSH
23066: LD_LOC 2
23070: ARRAY
23071: PPUSH
23072: CALL_OW 381
// units := units ^ CreateHuman ;
23076: LD_ADDR_VAR 0 3
23080: PUSH
23081: LD_VAR 0 3
23085: PUSH
23086: CALL_OW 44
23090: ADD
23091: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23092: LD_INT 7
23094: PPUSH
23095: CALL_OW 67
// end ;
23099: GO 23021
23101: POP
23102: POP
// result := units ;
23103: LD_ADDR_VAR 0 2
23107: PUSH
23108: LD_VAR 0 3
23112: ST_TO_ADDR
// end ;
23113: LD_VAR 0 2
23117: RET
// function CreateVH ( list ) ; var units , i ; begin
23118: LD_INT 0
23120: PPUSH
23121: PPUSH
23122: PPUSH
// for i in list do
23123: LD_ADDR_VAR 0 4
23127: PUSH
23128: LD_VAR 0 1
23132: PUSH
23133: FOR_IN
23134: IFFALSE 23427
// begin InitUc ;
23136: CALL_OW 18
// InitVc ;
23140: CALL_OW 20
// uc_nation := nation_russian ;
23144: LD_ADDR_OWVAR 21
23148: PUSH
23149: LD_INT 3
23151: ST_TO_ADDR
// uc_side := russians ;
23152: LD_ADDR_OWVAR 20
23156: PUSH
23157: LD_EXP 49
23161: ST_TO_ADDR
// units := [ ] ;
23162: LD_ADDR_VAR 0 3
23166: PUSH
23167: EMPTY
23168: ST_TO_ADDR
// vc_control := control_manual ;
23169: LD_ADDR_OWVAR 38
23173: PUSH
23174: LD_INT 1
23176: ST_TO_ADDR
// vc_engine := engine_combustion ;
23177: LD_ADDR_OWVAR 39
23181: PUSH
23182: LD_INT 1
23184: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23185: LD_ADDR_OWVAR 41
23189: PUSH
23190: LD_INT 75
23192: ST_TO_ADDR
// case i of mhmg :
23193: LD_VAR 0 4
23197: PUSH
23198: LD_EXP 9
23202: DOUBLE
23203: EQUAL
23204: IFTRUE 23208
23206: GO 23227
23208: POP
// begin vc_chassis := ru_medium_tracked ;
23209: LD_ADDR_OWVAR 37
23213: PUSH
23214: LD_INT 22
23216: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23217: LD_ADDR_OWVAR 40
23221: PUSH
23222: LD_INT 42
23224: ST_TO_ADDR
// end ; mgg :
23225: GO 23402
23227: LD_EXP 10
23231: DOUBLE
23232: EQUAL
23233: IFTRUE 23237
23235: GO 23256
23237: POP
// begin vc_chassis := ru_medium_tracked ;
23238: LD_ADDR_OWVAR 37
23242: PUSH
23243: LD_INT 22
23245: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23246: LD_ADDR_OWVAR 40
23250: PUSH
23251: LD_INT 43
23253: ST_TO_ADDR
// end ; mg :
23254: GO 23402
23256: LD_EXP 11
23260: DOUBLE
23261: EQUAL
23262: IFTRUE 23266
23264: GO 23285
23266: POP
// begin vc_chassis := ru_medium_tracked ;
23267: LD_ADDR_OWVAR 37
23271: PUSH
23272: LD_INT 22
23274: ST_TO_ADDR
// vc_weapon := ru_gun ;
23275: LD_ADDR_OWVAR 40
23279: PUSH
23280: LD_INT 44
23282: ST_TO_ADDR
// end ; mrl :
23283: GO 23402
23285: LD_EXP 12
23289: DOUBLE
23290: EQUAL
23291: IFTRUE 23295
23293: GO 23314
23295: POP
// begin vc_chassis := ru_medium_tracked ;
23296: LD_ADDR_OWVAR 37
23300: PUSH
23301: LD_INT 22
23303: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23304: LD_ADDR_OWVAR 40
23308: PUSH
23309: LD_INT 45
23311: ST_TO_ADDR
// end ; hgg :
23312: GO 23402
23314: LD_EXP 13
23318: DOUBLE
23319: EQUAL
23320: IFTRUE 23324
23322: GO 23343
23324: POP
// begin vc_chassis := ru_heavy_tracked ;
23325: LD_ADDR_OWVAR 37
23329: PUSH
23330: LD_INT 24
23332: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23333: LD_ADDR_OWVAR 40
23337: PUSH
23338: LD_INT 43
23340: ST_TO_ADDR
// end ; hrl :
23341: GO 23402
23343: LD_EXP 14
23347: DOUBLE
23348: EQUAL
23349: IFTRUE 23353
23351: GO 23372
23353: POP
// begin vc_chassis := ru_heavy_tracked ;
23354: LD_ADDR_OWVAR 37
23358: PUSH
23359: LD_INT 24
23361: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23362: LD_ADDR_OWVAR 40
23366: PUSH
23367: LD_INT 45
23369: ST_TO_ADDR
// end ; hhg :
23370: GO 23402
23372: LD_EXP 15
23376: DOUBLE
23377: EQUAL
23378: IFTRUE 23382
23380: GO 23401
23382: POP
// begin vc_chassis := ru_heavy_tracked ;
23383: LD_ADDR_OWVAR 37
23387: PUSH
23388: LD_INT 24
23390: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23391: LD_ADDR_OWVAR 40
23395: PUSH
23396: LD_INT 46
23398: ST_TO_ADDR
// end ; end ;
23399: GO 23402
23401: POP
// units := units ^ CreateVehicle ;
23402: LD_ADDR_VAR 0 3
23406: PUSH
23407: LD_VAR 0 3
23411: PUSH
23412: CALL_OW 45
23416: ADD
23417: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23418: LD_INT 7
23420: PPUSH
23421: CALL_OW 67
// end ;
23425: GO 23133
23427: POP
23428: POP
// result := units ;
23429: LD_ADDR_VAR 0 2
23433: PUSH
23434: LD_VAR 0 3
23438: ST_TO_ADDR
// end ;
23439: LD_VAR 0 2
23443: RET
// function CreateVC ( list ) ; var units , i ; begin
23444: LD_INT 0
23446: PPUSH
23447: PPUSH
23448: PPUSH
// units := [ ] ;
23449: LD_ADDR_VAR 0 3
23453: PUSH
23454: EMPTY
23455: ST_TO_ADDR
// for i in list do
23456: LD_ADDR_VAR 0 4
23460: PUSH
23461: LD_VAR 0 1
23465: PUSH
23466: FOR_IN
23467: IFFALSE 23757
// begin InitUc ;
23469: CALL_OW 18
// InitHc ;
23473: CALL_OW 19
// InitVc ;
23477: CALL_OW 20
// uc_nation := nation_russian ;
23481: LD_ADDR_OWVAR 21
23485: PUSH
23486: LD_INT 3
23488: ST_TO_ADDR
// uc_side := russians ;
23489: LD_ADDR_OWVAR 20
23493: PUSH
23494: LD_EXP 49
23498: ST_TO_ADDR
// vc_control := control_computer ;
23499: LD_ADDR_OWVAR 38
23503: PUSH
23504: LD_INT 3
23506: ST_TO_ADDR
// vc_engine := engine_combustion ;
23507: LD_ADDR_OWVAR 39
23511: PUSH
23512: LD_INT 1
23514: ST_TO_ADDR
// vc_fuel_battery := 75 ;
23515: LD_ADDR_OWVAR 41
23519: PUSH
23520: LD_INT 75
23522: ST_TO_ADDR
// case i of mhmg :
23523: LD_VAR 0 4
23527: PUSH
23528: LD_EXP 9
23532: DOUBLE
23533: EQUAL
23534: IFTRUE 23538
23536: GO 23557
23538: POP
// begin vc_chassis := ru_medium_tracked ;
23539: LD_ADDR_OWVAR 37
23543: PUSH
23544: LD_INT 22
23546: ST_TO_ADDR
// vc_weapon := ru_heavy_machine_gun ;
23547: LD_ADDR_OWVAR 40
23551: PUSH
23552: LD_INT 42
23554: ST_TO_ADDR
// end ; mgg :
23555: GO 23732
23557: LD_EXP 10
23561: DOUBLE
23562: EQUAL
23563: IFTRUE 23567
23565: GO 23586
23567: POP
// begin vc_chassis := ru_medium_tracked ;
23568: LD_ADDR_OWVAR 37
23572: PUSH
23573: LD_INT 22
23575: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23576: LD_ADDR_OWVAR 40
23580: PUSH
23581: LD_INT 43
23583: ST_TO_ADDR
// end ; mg :
23584: GO 23732
23586: LD_EXP 11
23590: DOUBLE
23591: EQUAL
23592: IFTRUE 23596
23594: GO 23615
23596: POP
// begin vc_chassis := ru_medium_tracked ;
23597: LD_ADDR_OWVAR 37
23601: PUSH
23602: LD_INT 22
23604: ST_TO_ADDR
// vc_weapon := ru_gun ;
23605: LD_ADDR_OWVAR 40
23609: PUSH
23610: LD_INT 44
23612: ST_TO_ADDR
// end ; mrl :
23613: GO 23732
23615: LD_EXP 12
23619: DOUBLE
23620: EQUAL
23621: IFTRUE 23625
23623: GO 23644
23625: POP
// begin vc_chassis := ru_medium_tracked ;
23626: LD_ADDR_OWVAR 37
23630: PUSH
23631: LD_INT 22
23633: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23634: LD_ADDR_OWVAR 40
23638: PUSH
23639: LD_INT 45
23641: ST_TO_ADDR
// end ; hgg :
23642: GO 23732
23644: LD_EXP 13
23648: DOUBLE
23649: EQUAL
23650: IFTRUE 23654
23652: GO 23673
23654: POP
// begin vc_chassis := ru_heavy_tracked ;
23655: LD_ADDR_OWVAR 37
23659: PUSH
23660: LD_INT 24
23662: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
23663: LD_ADDR_OWVAR 40
23667: PUSH
23668: LD_INT 43
23670: ST_TO_ADDR
// end ; hrl :
23671: GO 23732
23673: LD_EXP 14
23677: DOUBLE
23678: EQUAL
23679: IFTRUE 23683
23681: GO 23702
23683: POP
// begin vc_chassis := ru_heavy_tracked ;
23684: LD_ADDR_OWVAR 37
23688: PUSH
23689: LD_INT 24
23691: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
23692: LD_ADDR_OWVAR 40
23696: PUSH
23697: LD_INT 45
23699: ST_TO_ADDR
// end ; hhg :
23700: GO 23732
23702: LD_EXP 15
23706: DOUBLE
23707: EQUAL
23708: IFTRUE 23712
23710: GO 23731
23712: POP
// begin vc_chassis := ru_heavy_tracked ;
23713: LD_ADDR_OWVAR 37
23717: PUSH
23718: LD_INT 24
23720: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
23721: LD_ADDR_OWVAR 40
23725: PUSH
23726: LD_INT 46
23728: ST_TO_ADDR
// end ; end ;
23729: GO 23732
23731: POP
// units := units ^ CreateVehicle ;
23732: LD_ADDR_VAR 0 3
23736: PUSH
23737: LD_VAR 0 3
23741: PUSH
23742: CALL_OW 45
23746: ADD
23747: ST_TO_ADDR
// wait ( 0 0$0.2 ) ;
23748: LD_INT 7
23750: PPUSH
23751: CALL_OW 67
// end ;
23755: GO 23466
23757: POP
23758: POP
// result := units ;
23759: LD_ADDR_VAR 0 2
23763: PUSH
23764: LD_VAR 0 3
23768: ST_TO_ADDR
// end ;
23769: LD_VAR 0 2
23773: RET
// function MyPlaceUnitArea ( un , ar , bordr ) ; var h , r ; begin
23774: LD_INT 0
23776: PPUSH
23777: PPUSH
23778: PPUSH
// case ar of rus_mat_l :
23779: LD_VAR 0 2
23783: PUSH
23784: LD_INT 3
23786: DOUBLE
23787: EQUAL
23788: IFTRUE 23792
23790: GO 23810
23792: POP
// h := [ 61 , 119 ] ; rus_mat_m :
23793: LD_ADDR_VAR 0 5
23797: PUSH
23798: LD_INT 61
23800: PUSH
23801: LD_INT 119
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: ST_TO_ADDR
23808: GO 23889
23810: LD_INT 2
23812: DOUBLE
23813: EQUAL
23814: IFTRUE 23818
23816: GO 23836
23818: POP
// h := [ 99 , 148 ] ; rus_mat_r :
23819: LD_ADDR_VAR 0 5
23823: PUSH
23824: LD_INT 99
23826: PUSH
23827: LD_INT 148
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: ST_TO_ADDR
23834: GO 23889
23836: LD_INT 15
23838: DOUBLE
23839: EQUAL
23840: IFTRUE 23844
23842: GO 23862
23844: POP
// h := [ 137 , 148 ] ; rus_mat_t :
23845: LD_ADDR_VAR 0 5
23849: PUSH
23850: LD_INT 137
23852: PUSH
23853: LD_INT 148
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: ST_TO_ADDR
23860: GO 23889
23862: LD_INT 14
23864: DOUBLE
23865: EQUAL
23866: IFTRUE 23870
23868: GO 23888
23870: POP
// h := [ 112 , 87 ] ; end ;
23871: LD_ADDR_VAR 0 5
23875: PUSH
23876: LD_INT 112
23878: PUSH
23879: LD_INT 87
23881: PUSH
23882: EMPTY
23883: LIST
23884: LIST
23885: ST_TO_ADDR
23886: GO 23889
23888: POP
// r := PlaceUnitArea ( un , ar , bordr ) ;
23889: LD_ADDR_VAR 0 6
23893: PUSH
23894: LD_VAR 0 1
23898: PPUSH
23899: LD_VAR 0 2
23903: PPUSH
23904: LD_VAR 0 3
23908: PPUSH
23909: CALL_OW 49
23913: ST_TO_ADDR
// if not r then
23914: LD_VAR 0 6
23918: NOT
23919: IFFALSE 23962
// r := PlaceUnitXYR ( un , h [ 1 ] , h [ 2 ] , 20 , bordr ) ;
23921: LD_ADDR_VAR 0 6
23925: PUSH
23926: LD_VAR 0 1
23930: PPUSH
23931: LD_VAR 0 5
23935: PUSH
23936: LD_INT 1
23938: ARRAY
23939: PPUSH
23940: LD_VAR 0 5
23944: PUSH
23945: LD_INT 2
23947: ARRAY
23948: PPUSH
23949: LD_INT 20
23951: PPUSH
23952: LD_VAR 0 3
23956: PPUSH
23957: CALL_OW 50
23961: ST_TO_ADDR
// result := r ;
23962: LD_ADDR_VAR 0 4
23966: PUSH
23967: LD_VAR 0 6
23971: ST_TO_ADDR
// end ; end_of_file
23972: LD_VAR 0 4
23976: RET
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = russians then
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL_OW 255
23986: PUSH
23987: LD_EXP 49
23991: EQUAL
23992: IFFALSE 24006
// ComMoveToArea ( un , before_base ) ;
23994: LD_VAR 0 1
23998: PPUSH
23999: LD_INT 23
24001: PPUSH
24002: CALL_OW 113
// end ;
24006: PPOPN 1
24008: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = russians and GetType ( un ) = unit_human then
24009: LD_VAR 0 1
24013: PPUSH
24014: CALL_OW 255
24018: PUSH
24019: LD_EXP 49
24023: EQUAL
24024: PUSH
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL_OW 247
24034: PUSH
24035: LD_INT 1
24037: EQUAL
24038: AND
24039: IFFALSE 24053
// begin ComMoveToArea ( un , border ) ;
24041: LD_VAR 0 1
24045: PPUSH
24046: LD_INT 28
24048: PPUSH
24049: CALL_OW 113
// end ; end ;
24053: PPOPN 1
24055: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin end ;
24056: PPOPN 4
24058: END
// on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) then
24059: LD_VAR 0 1
24063: PPUSH
24064: LD_INT 30
24066: PUSH
24067: LD_INT 4
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 23
24076: PUSH
24077: LD_INT 2
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PPUSH
24088: CALL_OW 72
24092: IFFALSE 24102
// ArmBuild := true ;
24094: LD_ADDR_EXP 71
24098: PUSH
24099: LD_INT 1
24101: ST_TO_ADDR
// if IsDead ( rudepot1 ) and IsInArea ( build , base ) and GetBType ( build ) = b_depot then
24102: LD_EXP 67
24106: PPUSH
24107: CALL_OW 301
24111: PUSH
24112: LD_VAR 0 1
24116: PPUSH
24117: LD_INT 1
24119: PPUSH
24120: CALL_OW 308
24124: AND
24125: PUSH
24126: LD_VAR 0 1
24130: PPUSH
24131: CALL_OW 266
24135: PUSH
24136: LD_INT 0
24138: EQUAL
24139: AND
24140: IFFALSE 24152
// rudepot1 := build ;
24142: LD_ADDR_EXP 67
24146: PUSH
24147: LD_VAR 0 1
24151: ST_TO_ADDR
// if IsInArea ( build , base ) and GetBType ( build ) = b_siberite_mine then
24152: LD_VAR 0 1
24156: PPUSH
24157: LD_INT 1
24159: PPUSH
24160: CALL_OW 308
24164: PUSH
24165: LD_VAR 0 1
24169: PPUSH
24170: CALL_OW 266
24174: PUSH
24175: LD_INT 30
24177: EQUAL
24178: AND
24179: IFFALSE 24191
// rumine1 := build ;
24181: LD_ADDR_EXP 68
24185: PUSH
24186: LD_VAR 0 1
24190: ST_TO_ADDR
// if IsDead ( depot1 ) and IsInArea ( build , top_half ) and GetBType ( build ) = b_depot then
24191: LD_EXP 69
24195: PPUSH
24196: CALL_OW 301
24200: PUSH
24201: LD_VAR 0 1
24205: PPUSH
24206: LD_INT 6
24208: PPUSH
24209: CALL_OW 308
24213: AND
24214: PUSH
24215: LD_VAR 0 1
24219: PPUSH
24220: CALL_OW 266
24224: PUSH
24225: LD_INT 0
24227: EQUAL
24228: AND
24229: IFFALSE 24241
// depot1 := build ;
24231: LD_ADDR_EXP 69
24235: PUSH
24236: LD_VAR 0 1
24240: ST_TO_ADDR
// if GetBType ( build ) = b_workshop then
24241: LD_VAR 0 1
24245: PPUSH
24246: CALL_OW 266
24250: PUSH
24251: LD_INT 2
24253: EQUAL
24254: IFFALSE 24263
// MyHint ( Tracks ) ;
24256: LD_STRING Tracks
24258: PPUSH
24259: CALL 14162 0 1
// end ;
24263: PPOPN 1
24265: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_barracks ] , [ f_nation , nation_arabian ] ] ) then
24266: LD_VAR 0 1
24270: PPUSH
24271: LD_INT 30
24273: PUSH
24274: LD_INT 5
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: PUSH
24281: LD_INT 23
24283: PUSH
24284: LD_INT 2
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 72
24299: IFFALSE 24316
// begin ArmUpgraded := true ;
24301: LD_ADDR_EXP 72
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// MyHint ( MortarMen ) ;
24309: LD_STRING MortarMen
24311: PPUSH
24312: CALL 14162 0 1
// end ; end ;
24316: PPOPN 1
24318: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibDet then
24319: LD_VAR 0 1
24323: PUSH
24324: LD_INT 20
24326: EQUAL
24327: IFFALSE 24400
// begin if SayAny ( all_units , D13-Sci1-1 , you , 0 , class_scientistic , 0 ) then
24329: LD_OWVAR 3
24333: PPUSH
24334: LD_STRING D13-Sci1-1
24336: PPUSH
24337: LD_EXP 47
24341: PPUSH
24342: LD_INT 0
24344: PPUSH
24345: LD_INT 4
24347: PPUSH
24348: LD_INT 0
24350: PPUSH
24351: CALL 13011 0 6
24355: IFFALSE 24397
// if Say ( JMM , D13-JMM-1 ) then
24357: LD_EXP 17
24361: PPUSH
24362: LD_STRING D13-JMM-1
24364: PPUSH
24365: CALL_OW 88
24369: IFFALSE 24397
// SayAny ( all_units , D13-Sci1-2 , you , 0 , class_scientistic , 0 ) ;
24371: LD_OWVAR 3
24375: PPUSH
24376: LD_STRING D13-Sci1-2
24378: PPUSH
24379: LD_EXP 47
24383: PPUSH
24384: LD_INT 0
24386: PPUSH
24387: LD_INT 4
24389: PPUSH
24390: LD_INT 0
24392: PPUSH
24393: CALL 13011 0 6
// disable ( 20 ) ;
24397: LD_INT 20
24399: DISABLE_MARKED
// end ; end ;
24400: PPOPN 2
24402: END
// on BuildingCaptured ( build , origside , eng ) do begin if not byld2a and origside = you2 then
24403: LD_EXP 73
24407: NOT
24408: PUSH
24409: LD_VAR 0 2
24413: PUSH
24414: LD_EXP 48
24418: EQUAL
24419: AND
24420: IFFALSE 24426
// dialog2a ;
24422: CALL 3411 0 0
// if EndEnable and ( build = rudepot1 ) and origside = you then
24426: LD_EXP 80
24430: PUSH
24431: LD_VAR 0 1
24435: PUSH
24436: LD_EXP 67
24440: EQUAL
24441: AND
24442: PUSH
24443: LD_VAR 0 2
24447: PUSH
24448: LD_EXP 47
24452: EQUAL
24453: AND
24454: IFFALSE 24498
// begin TimerEnable := true ;
24456: LD_ADDR_EXP 63
24460: PUSH
24461: LD_INT 1
24463: ST_TO_ADDR
// TimerCas := ContactTime ( russians ) ;
24464: LD_ADDR_EXP 81
24468: PUSH
24469: LD_EXP 49
24473: PPUSH
24474: CALL_OW 462
24478: ST_TO_ADDR
// SetSideBase ( GetBase ( rudepot1 ) , russians ) ;
24479: LD_EXP 67
24483: PPUSH
24484: CALL_OW 274
24488: PPUSH
24489: LD_EXP 49
24493: PPUSH
24494: CALL_OW 236
// end ; end ;
24498: PPOPN 3
24500: END
// on UnitDestroyed ( un ) do begin if un = JMM then
24501: LD_VAR 0 1
24505: PUSH
24506: LD_EXP 17
24510: EQUAL
24511: IFFALSE 24523
// begin disable ( 0 ) ;
24513: LD_INT 0
24515: DISABLE_MARKED
// YouLost ( JMM ) ;
24516: LD_STRING JMM
24518: PPUSH
24519: CALL_OW 104
// end ; end ;
24523: PPOPN 1
24525: END
// on SailEvent ( num ) do begin if ( num div 1000 ) = 1 then
24526: LD_VAR 0 1
24530: PUSH
24531: LD_INT 1000
24533: DIV
24534: PUSH
24535: LD_INT 1
24537: EQUAL
24538: IFFALSE 24553
// rep_car ( num - 1000 ) ;
24540: LD_VAR 0 1
24544: PUSH
24545: LD_INT 1000
24547: MINUS
24548: PPUSH
24549: CALL 14373 0 1
// if ( num div 1000 ) = 2 then
24553: LD_VAR 0 1
24557: PUSH
24558: LD_INT 1000
24560: DIV
24561: PUSH
24562: LD_INT 2
24564: EQUAL
24565: IFFALSE 24580
// ret_car ( num - 2000 ) ;
24567: LD_VAR 0 1
24571: PUSH
24572: LD_INT 2000
24574: MINUS
24575: PPUSH
24576: CALL 14552 0 1
// case num of 1 :
24580: LD_VAR 0 1
24584: PUSH
24585: LD_INT 1
24587: DOUBLE
24588: EQUAL
24589: IFTRUE 24593
24591: GO 24626
24593: POP
// begin using1 := true ;
24594: LD_ADDR_EXP 83
24598: PUSH
24599: LD_INT 1
24601: ST_TO_ADDR
// Attack ( kdo1 , path1 ) ;
24602: LD_EXP 91
24606: PPUSH
24607: LD_EXP 87
24611: PPUSH
24612: CALL 13492 0 2
// using1 := false ;
24616: LD_ADDR_EXP 83
24620: PUSH
24621: LD_INT 0
24623: ST_TO_ADDR
// end ; 2 :
24624: GO 24921
24626: LD_INT 2
24628: DOUBLE
24629: EQUAL
24630: IFTRUE 24634
24632: GO 24667
24634: POP
// begin using2 := true ;
24635: LD_ADDR_EXP 84
24639: PUSH
24640: LD_INT 1
24642: ST_TO_ADDR
// Attack ( kdo2 , path2 ) ;
24643: LD_EXP 92
24647: PPUSH
24648: LD_EXP 88
24652: PPUSH
24653: CALL 13492 0 2
// using2 := false ;
24657: LD_ADDR_EXP 84
24661: PUSH
24662: LD_INT 0
24664: ST_TO_ADDR
// end ; 3 :
24665: GO 24921
24667: LD_INT 3
24669: DOUBLE
24670: EQUAL
24671: IFTRUE 24675
24673: GO 24708
24675: POP
// begin using3 := true ;
24676: LD_ADDR_EXP 85
24680: PUSH
24681: LD_INT 1
24683: ST_TO_ADDR
// Attack ( kdo3 , path3 ) ;
24684: LD_EXP 93
24688: PPUSH
24689: LD_EXP 89
24693: PPUSH
24694: CALL 13492 0 2
// using3 := false ;
24698: LD_ADDR_EXP 85
24702: PUSH
24703: LD_INT 0
24705: ST_TO_ADDR
// end ; 4 :
24706: GO 24921
24708: LD_INT 4
24710: DOUBLE
24711: EQUAL
24712: IFTRUE 24716
24714: GO 24749
24716: POP
// begin using4 := true ;
24717: LD_ADDR_EXP 94
24721: PUSH
24722: LD_INT 1
24724: ST_TO_ADDR
// Attack ( kdo4 , path4 ) ;
24725: LD_EXP 102
24729: PPUSH
24730: LD_EXP 98
24734: PPUSH
24735: CALL 13492 0 2
// using4 := false ;
24739: LD_ADDR_EXP 94
24743: PUSH
24744: LD_INT 0
24746: ST_TO_ADDR
// end ; 5 :
24747: GO 24921
24749: LD_INT 5
24751: DOUBLE
24752: EQUAL
24753: IFTRUE 24757
24755: GO 24790
24757: POP
// begin using5 := true ;
24758: LD_ADDR_EXP 95
24762: PUSH
24763: LD_INT 1
24765: ST_TO_ADDR
// Attack ( kdo5 , path5 ) ;
24766: LD_EXP 103
24770: PPUSH
24771: LD_EXP 99
24775: PPUSH
24776: CALL 13492 0 2
// using5 := false ;
24780: LD_ADDR_EXP 95
24784: PUSH
24785: LD_INT 0
24787: ST_TO_ADDR
// end ; 6 :
24788: GO 24921
24790: LD_INT 6
24792: DOUBLE
24793: EQUAL
24794: IFTRUE 24798
24796: GO 24831
24798: POP
// begin using6 := true ;
24799: LD_ADDR_EXP 96
24803: PUSH
24804: LD_INT 1
24806: ST_TO_ADDR
// Attack ( kdo6 , path6 ) ;
24807: LD_EXP 104
24811: PPUSH
24812: LD_EXP 100
24816: PPUSH
24817: CALL 13492 0 2
// using6 := false ;
24821: LD_ADDR_EXP 96
24825: PUSH
24826: LD_INT 0
24828: ST_TO_ADDR
// end ; 7 :
24829: GO 24921
24831: LD_INT 7
24833: DOUBLE
24834: EQUAL
24835: IFTRUE 24839
24837: GO 24872
24839: POP
// begin using7 := true ;
24840: LD_ADDR_EXP 97
24844: PUSH
24845: LD_INT 1
24847: ST_TO_ADDR
// Attack ( kdo7 , path7 ) ;
24848: LD_EXP 105
24852: PPUSH
24853: LD_EXP 101
24857: PPUSH
24858: CALL 13492 0 2
// using7 := false ;
24862: LD_ADDR_EXP 97
24866: PUSH
24867: LD_INT 0
24869: ST_TO_ADDR
// end ; 8 :
24870: GO 24921
24872: LD_INT 8
24874: DOUBLE
24875: EQUAL
24876: IFTRUE 24880
24878: GO 24913
24880: POP
// begin using8 := true ;
24881: LD_ADDR_EXP 82
24885: PUSH
24886: LD_INT 1
24888: ST_TO_ADDR
// Attack ( kdo8 , path8 ) ;
24889: LD_EXP 90
24893: PPUSH
24894: LD_EXP 86
24898: PPUSH
24899: CALL 13492 0 2
// using8 := false ;
24903: LD_ADDR_EXP 82
24907: PUSH
24908: LD_INT 0
24910: ST_TO_ADDR
// end ; else
24911: GO 24921
24913: POP
// Msg ( neni thread na utok ) ; end ;
24914: LD_STRING neni thread na utok
24916: PPUSH
24917: CALL_OW 100
// end ;
24921: PPOPN 1
24923: END
// on BuildingStarted ( b , hum ) do begin if hum = ara2 then
24924: LD_VAR 0 2
24928: PUSH
24929: LD_EXP 40
24933: EQUAL
24934: IFFALSE 24959
// if GetBType ( b ) = b_armoury then
24936: LD_VAR 0 1
24940: PPUSH
24941: CALL_OW 266
24945: PUSH
24946: LD_INT 4
24948: EQUAL
24949: IFFALSE 24959
// ArmStarted := true ;
24951: LD_ADDR_EXP 74
24955: PUSH
24956: LD_INT 1
24958: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
24959: LD_VAR 0 1
24963: PPUSH
24964: CALL_OW 266
24968: PUSH
24969: LD_INT 4
24971: EQUAL
24972: IFFALSE 24982
// BarStarted := true ;
24974: LD_ADDR_EXP 75
24978: PUSH
24979: LD_INT 1
24981: ST_TO_ADDR
// end ;
24982: PPOPN 2
24984: END
// on EndTheMissionRaised ( a ) do begin Vyhra ;
24985: CALL 2796 0 0
// end ; end_of_file
24989: PPOPN 1
24991: END
// var objevovani_zasilek ; every 0 0$0.1 do
24992: GO 24994
24994: DISABLE
// begin objevovani_zasilek := [ 1 , 0 , 2 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] ;
24995: LD_ADDR_LOC 3
24999: PUSH
25000: LD_INT 1
25002: PUSH
25003: LD_INT 0
25005: PUSH
25006: LD_INT 2
25008: PUSH
25009: LD_INT 0
25011: PUSH
25012: LD_INT 1
25014: PUSH
25015: LD_INT 0
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 1
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 0
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: LIST
25041: ST_TO_ADDR
// Randomize ;
25042: CALL_OW 10
// end ;
25046: END
// every 0 0$10 do
25047: GO 25049
25049: DISABLE
// begin Randomize ;
25050: CALL_OW 10
// enable ;
25054: ENABLE
// end ;
25055: END
// every 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25056: GO 25058
25058: DISABLE
25059: LD_INT 0
25061: PPUSH
25062: PPUSH
25063: PPUSH
25064: PPUSH
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
// begin min5 := 1 ;
25069: LD_ADDR_VAR 0 8
25073: PUSH
25074: LD_INT 1
25076: ST_TO_ADDR
// cek := [ ] ;
25077: LD_ADDR_VAR 0 5
25081: PUSH
25082: EMPTY
25083: ST_TO_ADDR
// cek2 := [ ] ;
25084: LD_ADDR_VAR 0 6
25088: PUSH
25089: EMPTY
25090: ST_TO_ADDR
// last := 0 ;
25091: LD_ADDR_VAR 0 7
25095: PUSH
25096: LD_INT 0
25098: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25099: LD_ADDR_VAR 0 1
25103: PUSH
25104: LD_LOC 3
25108: PUSH
25109: LD_VAR 0 8
25113: ARRAY
25114: ST_TO_ADDR
// for i := 1 to x do
25115: LD_ADDR_VAR 0 3
25119: PUSH
25120: DOUBLE
25121: LD_INT 1
25123: DEC
25124: ST_TO_ADDR
25125: LD_VAR 0 1
25129: PUSH
25130: FOR_TO
25131: IFFALSE 25157
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25133: LD_ADDR_VAR 0 5
25137: PUSH
25138: LD_VAR 0 5
25142: PUSH
25143: LD_INT 525
25145: PPUSH
25146: LD_INT 10500
25148: PPUSH
25149: CALL_OW 12
25153: ADD
25154: ST_TO_ADDR
25155: GO 25130
25157: POP
25158: POP
// cek := SortListByListAsc ( cek , cek ) ;
25159: LD_ADDR_VAR 0 5
25163: PUSH
25164: LD_VAR 0 5
25168: PPUSH
25169: LD_VAR 0 5
25173: PPUSH
25174: CALL_OW 76
25178: ST_TO_ADDR
// for i in cek do
25179: LD_ADDR_VAR 0 3
25183: PUSH
25184: LD_VAR 0 5
25188: PUSH
25189: FOR_IN
25190: IFFALSE 25226
// begin cek2 := cek2 ^ i - last ;
25192: LD_ADDR_VAR 0 6
25196: PUSH
25197: LD_VAR 0 6
25201: PUSH
25202: LD_VAR 0 3
25206: PUSH
25207: LD_VAR 0 7
25211: MINUS
25212: ADD
25213: ST_TO_ADDR
// last := i ;
25214: LD_ADDR_VAR 0 7
25218: PUSH
25219: LD_VAR 0 3
25223: ST_TO_ADDR
// end ;
25224: GO 25189
25226: POP
25227: POP
// for i := 1 to x do
25228: LD_ADDR_VAR 0 3
25232: PUSH
25233: DOUBLE
25234: LD_INT 1
25236: DEC
25237: ST_TO_ADDR
25238: LD_VAR 0 1
25242: PUSH
25243: FOR_TO
25244: IFFALSE 25273
// begin CreateCratesAnywhere ( 5 , true ) ;
25246: LD_INT 5
25248: PPUSH
25249: LD_INT 1
25251: PPUSH
25252: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25256: LD_VAR 0 6
25260: PUSH
25261: LD_VAR 0 3
25265: ARRAY
25266: PPUSH
25267: CALL_OW 67
// end ;
25271: GO 25243
25273: POP
25274: POP
// end ;
25275: PPOPN 8
25277: END
// every 5 5$0 + 0 0$15 do var x , w , i , hex , cek , cek2 , last , min5 ;
25278: GO 25280
25280: DISABLE
25281: LD_INT 0
25283: PPUSH
25284: PPUSH
25285: PPUSH
25286: PPUSH
25287: PPUSH
25288: PPUSH
25289: PPUSH
25290: PPUSH
// begin min5 := tick div 5 5$0 ;
25291: LD_ADDR_VAR 0 8
25295: PUSH
25296: LD_OWVAR 1
25300: PUSH
25301: LD_INT 10500
25303: DIV
25304: ST_TO_ADDR
// cek := [ ] ;
25305: LD_ADDR_VAR 0 5
25309: PUSH
25310: EMPTY
25311: ST_TO_ADDR
// cek2 := [ ] ;
25312: LD_ADDR_VAR 0 6
25316: PUSH
25317: EMPTY
25318: ST_TO_ADDR
// last := 0 ;
25319: LD_ADDR_VAR 0 7
25323: PUSH
25324: LD_INT 0
25326: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
25327: LD_ADDR_VAR 0 1
25331: PUSH
25332: LD_LOC 3
25336: PUSH
25337: LD_VAR 0 8
25341: ARRAY
25342: ST_TO_ADDR
// for i := 1 to x do
25343: LD_ADDR_VAR 0 3
25347: PUSH
25348: DOUBLE
25349: LD_INT 1
25351: DEC
25352: ST_TO_ADDR
25353: LD_VAR 0 1
25357: PUSH
25358: FOR_TO
25359: IFFALSE 25385
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
25361: LD_ADDR_VAR 0 5
25365: PUSH
25366: LD_VAR 0 5
25370: PUSH
25371: LD_INT 525
25373: PPUSH
25374: LD_INT 10500
25376: PPUSH
25377: CALL_OW 12
25381: ADD
25382: ST_TO_ADDR
25383: GO 25358
25385: POP
25386: POP
// cek := SortListByListAsc ( cek , cek ) ;
25387: LD_ADDR_VAR 0 5
25391: PUSH
25392: LD_VAR 0 5
25396: PPUSH
25397: LD_VAR 0 5
25401: PPUSH
25402: CALL_OW 76
25406: ST_TO_ADDR
// for i in cek do
25407: LD_ADDR_VAR 0 3
25411: PUSH
25412: LD_VAR 0 5
25416: PUSH
25417: FOR_IN
25418: IFFALSE 25454
// begin cek2 := cek2 ^ i - last ;
25420: LD_ADDR_VAR 0 6
25424: PUSH
25425: LD_VAR 0 6
25429: PUSH
25430: LD_VAR 0 3
25434: PUSH
25435: LD_VAR 0 7
25439: MINUS
25440: ADD
25441: ST_TO_ADDR
// last := i ;
25442: LD_ADDR_VAR 0 7
25446: PUSH
25447: LD_VAR 0 3
25451: ST_TO_ADDR
// end ;
25452: GO 25417
25454: POP
25455: POP
// for i := 1 to x do
25456: LD_ADDR_VAR 0 3
25460: PUSH
25461: DOUBLE
25462: LD_INT 1
25464: DEC
25465: ST_TO_ADDR
25466: LD_VAR 0 1
25470: PUSH
25471: FOR_TO
25472: IFFALSE 25501
// begin CreateCratesAnywhere ( 5 , true ) ;
25474: LD_INT 5
25476: PPUSH
25477: LD_INT 1
25479: PPUSH
25480: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
25484: LD_VAR 0 6
25488: PUSH
25489: LD_VAR 0 3
25493: ARRAY
25494: PPUSH
25495: CALL_OW 67
// end ;
25499: GO 25471
25501: POP
25502: POP
// if min5 < 10 then
25503: LD_VAR 0 8
25507: PUSH
25508: LD_INT 10
25510: LESS
25511: IFFALSE 25514
// enable ;
25513: ENABLE
// end ; end_of_file
25514: PPOPN 8
25516: END
// every 0 0$2 + 0 0$0.1 do
25517: GO 25519
25519: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25520: LD_INT 22
25522: PUSH
25523: LD_INT 1
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 2
25532: PUSH
25533: LD_INT 25
25535: PUSH
25536: LD_INT 12
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 25
25545: PUSH
25546: LD_INT 16
25548: PUSH
25549: EMPTY
25550: LIST
25551: LIST
25552: PUSH
25553: LD_INT 25
25555: PUSH
25556: LD_INT 15
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: PUSH
25563: LD_INT 25
25565: PUSH
25566: LD_INT 17
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: EMPTY
25574: LIST
25575: LIST
25576: LIST
25577: LIST
25578: LIST
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: PPUSH
25584: CALL_OW 69
25588: PUSH
25589: LD_INT 22
25591: PUSH
25592: LD_INT 1
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: LD_INT 21
25601: PUSH
25602: LD_INT 1
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 3
25611: PUSH
25612: LD_INT 2
25614: PUSH
25615: LD_INT 25
25617: PUSH
25618: LD_INT 12
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: LD_INT 25
25627: PUSH
25628: LD_INT 16
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: LD_INT 25
25637: PUSH
25638: LD_INT 15
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: PUSH
25645: LD_INT 25
25647: PUSH
25648: LD_INT 17
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: LIST
25670: PPUSH
25671: CALL_OW 69
25675: GREATER
25676: IFFALSE 25687
// begin SetAchievement ( ACH_POTA ) ;
25678: LD_STRING ACH_POTA
25680: PPUSH
25681: CALL_OW 543
// exit ;
25685: GO 25688
// end ; enable ;
25687: ENABLE
// end ;
25688: END

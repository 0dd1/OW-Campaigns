// export you , russians , arabians , you2 ; export apemans ; export prilet_tvoji ; export prilet_rusaci ; export prilet_arabi ; export all , other ; export not_char , used , opicaci ; export zgamy2 ; export JMM ; export Har ; export RadioSci ; export Sol1 , Eng1 ; export Frank , Lisa ; export Cyrus , Bobby , Donaldson , Brown , Denis , Gladstone ; export MSol1 , MSol2 , MSol3 , MEng1 , MMec1 , Joan ; export Op1 , Op2 , Op3 , Op4 , Op5 ; export RMSo1 , RMSo2 , RMEn1 , RMMe1 ; export Kurt ; export Car1 , Car2 ; export Denis_P , Kurt_P , Joan_P , Lisa_P , Frank_P ; export MaterialNavic ; export DialogInProgress ; export map_size_x , map_size_y ; export start_game ; export test_JMM_Joan ; export before_d6 ; export act_Lisa_JMM ; export hledani ; export attacky ; export more_scouting ; export go_up ; export attacking ; export under_attack ; export odplata_1 ; export odplata_2 ; export attack_to_scouting ; export start_scouting ; export WasD11aa , WasD11ab , WasD11b , WasD11c , WasD11d , WasD11e , WasD11f ; export crates ; export list_of_R1_query ; export Gamma3_lab_upgraded_to_opto ; export Gamma3_lab_upgraded_to_weapon ; export radar_invented ; export vzit_opicaku ; export remote_tried ; export Gamma2Commander ; export NavicLidi ; export KurtTryToEscape ; starting begin disable ( 33 ) ;
   0: LD_INT 33
   2: DISABLE_MARKED
// disable_prediction := true ;
   3: LD_ADDR_OWVAR 50
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// map_size_x := 100 ;
  11: LD_ADDR_EXP 53
  15: PUSH
  16: LD_INT 100
  18: ST_TO_ADDR
// map_size_y := 100 ;
  19: LD_ADDR_EXP 54
  23: PUSH
  24: LD_INT 100
  26: ST_TO_ADDR
// prepare_sides ;
  27: CALL 2061 0 0
// load_characters ;
  31: CALL 268 0 0
// prepare_russian_units ;
  35: CALL 1690 0 0
// prepare_arabian_units ;
  39: CALL 2016 0 0
// if radar_invented then
  43: LD_EXP 80
  47: IFFALSE 64
// SetTech ( tech_Radar , you , state_researched ) ;
  49: LD_INT 6
  51: PPUSH
  52: LD_EXP 1
  56: PPUSH
  57: LD_INT 2
  59: PPUSH
  60: CALL_OW 322
// Gamma3_lab_upgraded_to_opto := false ;
  64: LD_ADDR_EXP 78
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// Gamma3_lab_upgraded_to_weapon := false ;
  72: LD_ADDR_EXP 79
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// SetDifficulty ;
  80: CALL 2161 0 0
// apemans := FilterAllUnits ( [ f_nation , nation_nature ] ) ;
  84: LD_ADDR_EXP 5
  88: PUSH
  89: LD_INT 23
  91: PUSH
  92: LD_INT 0
  94: PUSH
  95: EMPTY
  96: LIST
  97: LIST
  98: PPUSH
  99: CALL_OW 69
 103: ST_TO_ADDR
// Kurt_P := false ;
 104: LD_ADDR_EXP 47
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// Joan_P := false ;
 112: LD_ADDR_EXP 48
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// start_game := false ;
 120: LD_ADDR_EXP 55
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// test_JMM_Joan := false ;
 128: LD_ADDR_EXP 56
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// before_d6 := false ;
 136: LD_ADDR_EXP 57
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// act_Lisa_JMM := false ;
 144: LD_ADDR_EXP 58
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// hledani := false ;
 152: LD_ADDR_EXP 59
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// more_scouting := false ;
 160: LD_ADDR_EXP 61
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// go_up := false ;
 168: LD_ADDR_EXP 62
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// WasD11aa := false ;
 176: LD_ADDR_EXP 69
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// WasD11ab := false ;
 184: LD_ADDR_EXP 70
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// WasD11b := false ;
 192: LD_ADDR_EXP 71
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// WasD11c := false ;
 200: LD_ADDR_EXP 72
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// WasD11d := false ;
 208: LD_ADDR_EXP 73
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// WasD11e := false ;
 216: LD_ADDR_EXP 74
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// WasD11f := false ;
 224: LD_ADDR_EXP 75
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// crates := [ ] ;
 232: LD_ADDR_EXP 76
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// attacky := 0 ;
 239: LD_ADDR_EXP 60
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// attacking := false ;
 247: LD_ADDR_EXP 63
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// under_attack := false ;
 255: LD_ADDR_EXP 64
 259: PUSH
 260: LD_INT 0
 262: ST_TO_ADDR
// Dialog1 ;
 263: CALL 4285 0 0
// end ;
 267: END
// function load_characters ; begin
 268: LD_INT 0
 270: PPUSH
// InitUc ;
 271: CALL_OW 18
// InitHc ;
 275: CALL_OW 19
// InitVc ;
 279: CALL_OW 20
// uc_side := arabians ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_EXP 3
 292: ST_TO_ADDR
// uc_nation := nation_arabian ;
 293: LD_ADDR_OWVAR 21
 297: PUSH
 298: LD_INT 2
 300: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
 301: LD_ADDR_EXP 43
 305: PUSH
 306: LD_STRING Kurt
 308: PPUSH
 309: CALL_OW 25
 313: ST_TO_ADDR
// uc_side := you ;
 314: LD_ADDR_OWVAR 20
 318: PUSH
 319: LD_EXP 1
 323: ST_TO_ADDR
// uc_nation := nation_american ;
 324: LD_ADDR_OWVAR 21
 328: PUSH
 329: LD_INT 1
 331: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 332: LD_ADDR_EXP 15
 336: PUSH
 337: LD_STRING JMM
 339: PPUSH
 340: CALL_OW 34
 344: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 345: LD_ADDR_EXP 16
 349: PUSH
 350: LD_STRING Harisson
 352: PPUSH
 353: CALL_OW 25
 357: ST_TO_ADDR
// if TestCharacters ( other_from5to6 ) then
 358: LD_STRING other_from5to6
 360: PPUSH
 361: CALL_OW 28
 365: IFFALSE 382
// all := CreateCharacterSet ( other_from5to6 ) else
 367: LD_ADDR_EXP 9
 371: PUSH
 372: LD_STRING other_from5to6
 374: PPUSH
 375: CALL_OW 31
 379: ST_TO_ADDR
 380: GO 389
// all := [ ] ;
 382: LD_ADDR_EXP 9
 386: PUSH
 387: EMPTY
 388: ST_TO_ADDR
// if CheckCharacterSet ( radiosci_from5to6 ) then
 389: LD_STRING radiosci_from5to6
 391: PPUSH
 392: CALL_OW 29
 396: IFFALSE 413
// RadioSci := CreateCharacter ( radiosci_from5to6 ) else
 398: LD_ADDR_EXP 17
 402: PUSH
 403: LD_STRING radiosci_from5to6
 405: PPUSH
 406: CALL_OW 34
 410: ST_TO_ADDR
 411: GO 433
// begin PrepareScientist ( sex_male , 10 ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 10
 418: PPUSH
 419: CALL_OW 384
// RadioSci := CreateHuman ;
 423: LD_ADDR_EXP 17
 427: PUSH
 428: CALL_OW 44
 432: ST_TO_ADDR
// end ; DeleteCharacters ( radiosci_from5to6 ) ;
 433: LD_STRING radiosci_from5to6
 435: PPUSH
 436: CALL_OW 40
// other := all ;
 440: LD_ADDR_EXP 10
 444: PUSH
 445: LD_EXP 9
 449: ST_TO_ADDR
// radar_invented := LoadVariable ( RadarDeveloped , false ) ;
 450: LD_ADDR_EXP 80
 454: PUSH
 455: LD_STRING RadarDeveloped
 457: PPUSH
 458: LD_INT 0
 460: PPUSH
 461: CALL_OW 30
 465: ST_TO_ADDR
// Gamma2Commander := LoadVariable ( Gamma2Commander , 3 ) ;
 466: LD_ADDR_EXP 83
 470: PUSH
 471: LD_STRING Gamma2Commander
 473: PPUSH
 474: LD_INT 3
 476: PPUSH
 477: CALL_OW 30
 481: ST_TO_ADDR
// opicaci := [ ] ;
 482: LD_ADDR_EXP 13
 486: PUSH
 487: EMPTY
 488: ST_TO_ADDR
// if CheckCharacterSet ( opicaci ) then
 489: LD_STRING opicaci
 491: PPUSH
 492: CALL_OW 29
 496: IFFALSE 511
// opicaci := CreateCharacterSet ( opicaci ) ;
 498: LD_ADDR_EXP 13
 502: PUSH
 503: LD_STRING opicaci
 505: PPUSH
 506: CALL_OW 31
 510: ST_TO_ADDR
// Lisa := 0 ;
 511: LD_ADDR_EXP 21
 515: PUSH
 516: LD_INT 0
 518: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 519: LD_STRING Lisa
 521: PPUSH
 522: CALL_OW 29
 526: IFFALSE 584
// if LoadVariable ( LisaLoc , 0 ) = 8 then
 528: LD_STRING LisaLoc
 530: PPUSH
 531: LD_INT 0
 533: PPUSH
 534: CALL_OW 30
 538: PUSH
 539: LD_INT 8
 541: EQUAL
 542: IFFALSE 584
// begin Lisa := CreateCharacter ( Lisa ) ;
 544: LD_ADDR_EXP 21
 548: PUSH
 549: LD_STRING Lisa
 551: PPUSH
 552: CALL_OW 34
 556: ST_TO_ADDR
// Lisa_P := true ;
 557: LD_ADDR_EXP 49
 561: PUSH
 562: LD_INT 1
 564: ST_TO_ADDR
// all := all ^ [ Lisa ] ;
 565: LD_ADDR_EXP 9
 569: PUSH
 570: LD_EXP 9
 574: PUSH
 575: LD_EXP 21
 579: PUSH
 580: EMPTY
 581: LIST
 582: ADD
 583: ST_TO_ADDR
// end ; Cyrus := 0 ;
 584: LD_ADDR_EXP 22
 588: PUSH
 589: LD_INT 0
 591: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 592: LD_STRING Cyrus
 594: PPUSH
 595: CALL_OW 29
 599: IFFALSE 649
// if LoadVariable ( CyrusLoc , 0 ) = 8 then
 601: LD_STRING CyrusLoc
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 30
 611: PUSH
 612: LD_INT 8
 614: EQUAL
 615: IFFALSE 649
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 617: LD_ADDR_EXP 22
 621: PUSH
 622: LD_STRING Cyrus
 624: PPUSH
 625: CALL_OW 34
 629: ST_TO_ADDR
// all := all ^ [ Cyrus ] ;
 630: LD_ADDR_EXP 9
 634: PUSH
 635: LD_EXP 9
 639: PUSH
 640: LD_EXP 22
 644: PUSH
 645: EMPTY
 646: LIST
 647: ADD
 648: ST_TO_ADDR
// end ; Bobby := 0 ;
 649: LD_ADDR_EXP 23
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 657: LD_STRING Bobby
 659: PPUSH
 660: CALL_OW 29
 664: IFFALSE 714
// if LoadVariable ( BobbyLoc , 0 ) = 8 then
 666: LD_STRING BobbyLoc
 668: PPUSH
 669: LD_INT 0
 671: PPUSH
 672: CALL_OW 30
 676: PUSH
 677: LD_INT 8
 679: EQUAL
 680: IFFALSE 714
// begin Bobby := CreateCharacter ( Bobby ) ;
 682: LD_ADDR_EXP 23
 686: PUSH
 687: LD_STRING Bobby
 689: PPUSH
 690: CALL_OW 34
 694: ST_TO_ADDR
// all := all ^ [ Bobby ] ;
 695: LD_ADDR_EXP 9
 699: PUSH
 700: LD_EXP 9
 704: PUSH
 705: LD_EXP 23
 709: PUSH
 710: EMPTY
 711: LIST
 712: ADD
 713: ST_TO_ADDR
// end ; Frank := 0 ;
 714: LD_ADDR_EXP 20
 718: PUSH
 719: LD_INT 0
 721: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 722: LD_STRING Frank
 724: PPUSH
 725: CALL_OW 29
 729: IFFALSE 787
// if LoadVariable ( FrankLoc , 0 ) = 8 then
 731: LD_STRING FrankLoc
 733: PPUSH
 734: LD_INT 0
 736: PPUSH
 737: CALL_OW 30
 741: PUSH
 742: LD_INT 8
 744: EQUAL
 745: IFFALSE 787
// begin Frank := CreateCharacter ( Frank ) ;
 747: LD_ADDR_EXP 20
 751: PUSH
 752: LD_STRING Frank
 754: PPUSH
 755: CALL_OW 34
 759: ST_TO_ADDR
// Frank_P := true ;
 760: LD_ADDR_EXP 50
 764: PUSH
 765: LD_INT 1
 767: ST_TO_ADDR
// all := all ^ [ Frank ] ;
 768: LD_ADDR_EXP 9
 772: PUSH
 773: LD_EXP 9
 777: PUSH
 778: LD_EXP 20
 782: PUSH
 783: EMPTY
 784: LIST
 785: ADD
 786: ST_TO_ADDR
// end ; Donaldson := 0 ;
 787: LD_ADDR_EXP 24
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 795: LD_STRING Donaldson
 797: PPUSH
 798: CALL_OW 29
 802: IFFALSE 852
// if LoadVariable ( DonaldsonLoc , 0 ) = 8 then
 804: LD_STRING DonaldsonLoc
 806: PPUSH
 807: LD_INT 0
 809: PPUSH
 810: CALL_OW 30
 814: PUSH
 815: LD_INT 8
 817: EQUAL
 818: IFFALSE 852
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 820: LD_ADDR_EXP 24
 824: PUSH
 825: LD_STRING Donaldson
 827: PPUSH
 828: CALL_OW 34
 832: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 833: LD_ADDR_EXP 9
 837: PUSH
 838: LD_EXP 9
 842: PUSH
 843: LD_EXP 24
 847: PUSH
 848: EMPTY
 849: LIST
 850: ADD
 851: ST_TO_ADDR
// end ; Brown := 0 ;
 852: LD_ADDR_EXP 25
 856: PUSH
 857: LD_INT 0
 859: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 860: LD_STRING Brown
 862: PPUSH
 863: CALL_OW 29
 867: IFFALSE 917
// if LoadVariable ( BrownLoc , 0 ) = 8 then
 869: LD_STRING BrownLoc
 871: PPUSH
 872: LD_INT 0
 874: PPUSH
 875: CALL_OW 30
 879: PUSH
 880: LD_INT 8
 882: EQUAL
 883: IFFALSE 917
// begin Brown := CreateCharacter ( Brown ) ;
 885: LD_ADDR_EXP 25
 889: PUSH
 890: LD_STRING Brown
 892: PPUSH
 893: CALL_OW 34
 897: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 898: LD_ADDR_EXP 9
 902: PUSH
 903: LD_EXP 9
 907: PUSH
 908: LD_EXP 25
 912: PUSH
 913: EMPTY
 914: LIST
 915: ADD
 916: ST_TO_ADDR
// end ; Denis := 0 ;
 917: LD_ADDR_EXP 26
 921: PUSH
 922: LD_INT 0
 924: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 925: LD_STRING Denis
 927: PPUSH
 928: CALL_OW 29
 932: IFFALSE 971
// if LoadVariable ( DenisLoc , 0 ) = 8 then
 934: LD_STRING DenisLoc
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL_OW 30
 944: PUSH
 945: LD_INT 8
 947: EQUAL
 948: IFFALSE 971
// begin Denis := CreateCharacter ( Denis ) ;
 950: LD_ADDR_EXP 26
 954: PUSH
 955: LD_STRING Denis
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// Denis_P := true ;
 963: LD_ADDR_EXP 46
 967: PUSH
 968: LD_INT 1
 970: ST_TO_ADDR
// end ; Gladstone := 0 ;
 971: LD_ADDR_EXP 27
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 979: LD_STRING Gladstone
 981: PPUSH
 982: CALL_OW 29
 986: IFFALSE 1036
// if LoadVariable ( GladstoneLoc , 0 ) = 8 then
 988: LD_STRING GladstoneLoc
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 30
 998: PUSH
 999: LD_INT 8
1001: EQUAL
1002: IFFALSE 1036
// begin Gladstone := CreateCharacter ( Gladstone ) ;
1004: LD_ADDR_EXP 27
1008: PUSH
1009: LD_STRING Gladstone
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// all := all ^ [ Gladstone ] ;
1017: LD_ADDR_EXP 9
1021: PUSH
1022: LD_EXP 9
1026: PUSH
1027: LD_EXP 27
1031: PUSH
1032: EMPTY
1033: LIST
1034: ADD
1035: ST_TO_ADDR
// end ; uc_side := you2 ;
1036: LD_ADDR_OWVAR 20
1040: PUSH
1041: LD_EXP 4
1045: ST_TO_ADDR
// Joan := NewCharacter ( Joan ) ;
1046: LD_ADDR_EXP 33
1050: PUSH
1051: LD_STRING Joan
1053: PPUSH
1054: CALL_OW 25
1058: ST_TO_ADDR
// SetLives ( Joan , hranice_umirani - 1 ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 250
1066: PUSH
1067: LD_INT 1
1069: MINUS
1070: PPUSH
1071: CALL_OW 234
// uc_side := you ;
1075: LD_ADDR_OWVAR 20
1079: PUSH
1080: LD_EXP 1
1084: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1085: LD_ADDR_OWVAR 37
1089: PUSH
1090: LD_INT 1
1092: ST_TO_ADDR
// vc_control := control_manual ;
1093: LD_ADDR_OWVAR 38
1097: PUSH
1098: LD_INT 1
1100: ST_TO_ADDR
// vc_engine := engine_solar ;
1101: LD_ADDR_OWVAR 39
1105: PUSH
1106: LD_INT 2
1108: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1109: LD_ADDR_OWVAR 40
1113: PUSH
1114: LD_INT 2
1116: ST_TO_ADDR
// Car1 := CreateVehicle ;
1117: LD_ADDR_EXP 44
1121: PUSH
1122: CALL_OW 45
1126: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1127: LD_ADDR_OWVAR 37
1131: PUSH
1132: LD_INT 1
1134: ST_TO_ADDR
// vc_control := control_manual ;
1135: LD_ADDR_OWVAR 38
1139: PUSH
1140: LD_INT 1
1142: ST_TO_ADDR
// vc_engine := engine_solar ;
1143: LD_ADDR_OWVAR 39
1147: PUSH
1148: LD_INT 2
1150: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1151: LD_ADDR_OWVAR 40
1155: PUSH
1156: LD_INT 2
1158: ST_TO_ADDR
// Car2 := CreateVehicle ;
1159: LD_ADDR_EXP 45
1163: PUSH
1164: CALL_OW 45
1168: ST_TO_ADDR
// uc_nation := nation_american ;
1169: LD_ADDR_OWVAR 21
1173: PUSH
1174: LD_INT 1
1176: ST_TO_ADDR
// hc_sex := sex_female ;
1177: LD_ADDR_OWVAR 27
1181: PUSH
1182: LD_INT 2
1184: ST_TO_ADDR
// hc_class := class_soldier ;
1185: LD_ADDR_OWVAR 28
1189: PUSH
1190: LD_INT 1
1192: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1193: LD_ADDR_OWVAR 29
1197: PUSH
1198: LD_INT 10
1200: PUSH
1201: LD_INT 10
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: ST_TO_ADDR
// hc_skills := [ 4 , 2 , 1 , 0 ] ;
1208: LD_ADDR_OWVAR 31
1212: PUSH
1213: LD_INT 4
1215: PUSH
1216: LD_INT 2
1218: PUSH
1219: LD_INT 1
1221: PUSH
1222: LD_INT 0
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: ST_TO_ADDR
// Sol1 := CreateHuman ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: CALL_OW 44
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// hc_class := class_engineer ;
1249: LD_ADDR_OWVAR 28
1253: PUSH
1254: LD_INT 2
1256: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1257: LD_ADDR_OWVAR 29
1261: PUSH
1262: LD_INT 10
1264: PUSH
1265: LD_INT 10
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 0 , 0 ] ;
1272: LD_ADDR_OWVAR 31
1276: PUSH
1277: LD_INT 3
1279: PUSH
1280: LD_INT 4
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: LD_INT 0
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: ST_TO_ADDR
// Eng1 := CreateHuman ;
1295: LD_ADDR_EXP 19
1299: PUSH
1300: CALL_OW 44
1304: ST_TO_ADDR
// zgamy2 := [ Sol1 , Eng1 ] ;
1305: LD_ADDR_EXP 14
1309: PUSH
1310: LD_EXP 18
1314: PUSH
1315: LD_EXP 19
1319: PUSH
1320: EMPTY
1321: LIST
1322: LIST
1323: ST_TO_ADDR
// hc_sex := sex_female ;
1324: LD_ADDR_OWVAR 27
1328: PUSH
1329: LD_INT 2
1331: ST_TO_ADDR
// hc_class := class_soldier ;
1332: LD_ADDR_OWVAR 28
1336: PUSH
1337: LD_INT 1
1339: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1340: LD_ADDR_OWVAR 29
1344: PUSH
1345: LD_INT 10
1347: PUSH
1348: LD_INT 10
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1355: LD_ADDR_OWVAR 31
1359: PUSH
1360: LD_INT 1
1362: PUSH
1363: LD_INT 1
1365: PUSH
1366: LD_INT 0
1368: PUSH
1369: LD_INT 0
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: ST_TO_ADDR
// MSol1 := CreateHuman ;
1378: LD_ADDR_EXP 28
1382: PUSH
1383: CALL_OW 44
1387: ST_TO_ADDR
// hc_sex := sex_male ;
1388: LD_ADDR_OWVAR 27
1392: PUSH
1393: LD_INT 1
1395: ST_TO_ADDR
// hc_class := class_soldier ;
1396: LD_ADDR_OWVAR 28
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1404: LD_ADDR_OWVAR 29
1408: PUSH
1409: LD_INT 10
1411: PUSH
1412: LD_INT 10
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1419: LD_ADDR_OWVAR 31
1423: PUSH
1424: LD_INT 2
1426: PUSH
1427: LD_INT 0
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 0
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: ST_TO_ADDR
// MSol2 := CreateHuman ;
1442: LD_ADDR_EXP 29
1446: PUSH
1447: CALL_OW 44
1451: ST_TO_ADDR
// hc_sex := sex_male ;
1452: LD_ADDR_OWVAR 27
1456: PUSH
1457: LD_INT 1
1459: ST_TO_ADDR
// hc_class := class_soldier ;
1460: LD_ADDR_OWVAR 28
1464: PUSH
1465: LD_INT 1
1467: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1468: LD_ADDR_OWVAR 29
1472: PUSH
1473: LD_INT 10
1475: PUSH
1476: LD_INT 10
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1483: LD_ADDR_OWVAR 31
1487: PUSH
1488: LD_INT 2
1490: PUSH
1491: LD_INT 0
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 0
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: ST_TO_ADDR
// MSol3 := CreateHuman ;
1506: LD_ADDR_EXP 30
1510: PUSH
1511: CALL_OW 44
1515: ST_TO_ADDR
// hc_sex := sex_female ;
1516: LD_ADDR_OWVAR 27
1520: PUSH
1521: LD_INT 2
1523: ST_TO_ADDR
// hc_class := class_engineer ;
1524: LD_ADDR_OWVAR 28
1528: PUSH
1529: LD_INT 2
1531: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1532: LD_ADDR_OWVAR 29
1536: PUSH
1537: LD_INT 9
1539: PUSH
1540: LD_INT 10
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1547: LD_ADDR_OWVAR 31
1551: PUSH
1552: LD_INT 0
1554: PUSH
1555: LD_INT 2
1557: PUSH
1558: LD_INT 0
1560: PUSH
1561: LD_INT 0
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: LIST
1569: ST_TO_ADDR
// MEng1 := CreateHuman ;
1570: LD_ADDR_EXP 31
1574: PUSH
1575: CALL_OW 44
1579: ST_TO_ADDR
// hc_sex := sex_male ;
1580: LD_ADDR_OWVAR 27
1584: PUSH
1585: LD_INT 1
1587: ST_TO_ADDR
// hc_class := class_mechanic ;
1588: LD_ADDR_OWVAR 28
1592: PUSH
1593: LD_INT 3
1595: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1596: LD_ADDR_OWVAR 29
1600: PUSH
1601: LD_INT 10
1603: PUSH
1604: LD_INT 9
1606: PUSH
1607: EMPTY
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1611: LD_ADDR_OWVAR 31
1615: PUSH
1616: LD_INT 0
1618: PUSH
1619: LD_INT 0
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 0
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: ST_TO_ADDR
// MMec1 := CreateHuman ;
1634: LD_ADDR_EXP 32
1638: PUSH
1639: CALL_OW 44
1643: ST_TO_ADDR
// prilet_tvoji := [ MSol1 , MSol2 , MEng1 , MMec1 ] ;
1644: LD_ADDR_EXP 6
1648: PUSH
1649: LD_EXP 28
1653: PUSH
1654: LD_EXP 29
1658: PUSH
1659: LD_EXP 31
1663: PUSH
1664: LD_EXP 32
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: ST_TO_ADDR
// NavicLidi := prilet_tvoji ;
1675: LD_ADDR_EXP 84
1679: PUSH
1680: LD_EXP 6
1684: ST_TO_ADDR
// end ;
1685: LD_VAR 0 1
1689: RET
// function prepare_russian_units ; begin
1690: LD_INT 0
1692: PPUSH
// InitUc ;
1693: CALL_OW 18
// InitHc ;
1697: CALL_OW 19
// InitVc ;
1701: CALL_OW 20
// uc_nation := nation_russian ;
1705: LD_ADDR_OWVAR 21
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// uc_side := russians ;
1713: LD_ADDR_OWVAR 20
1717: PUSH
1718: LD_EXP 2
1722: ST_TO_ADDR
// hc_sex := sex_female ;
1723: LD_ADDR_OWVAR 27
1727: PUSH
1728: LD_INT 2
1730: ST_TO_ADDR
// hc_class := class_soldier ;
1731: LD_ADDR_OWVAR 28
1735: PUSH
1736: LD_INT 1
1738: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1739: LD_ADDR_OWVAR 29
1743: PUSH
1744: LD_INT 10
1746: PUSH
1747: LD_INT 10
1749: PUSH
1750: EMPTY
1751: LIST
1752: LIST
1753: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1754: LD_ADDR_OWVAR 31
1758: PUSH
1759: LD_INT 1
1761: PUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 0
1767: PUSH
1768: LD_INT 0
1770: PUSH
1771: EMPTY
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: ST_TO_ADDR
// RMSo1 := CreateHuman ;
1777: LD_ADDR_EXP 39
1781: PUSH
1782: CALL_OW 44
1786: ST_TO_ADDR
// hc_sex := sex_male ;
1787: LD_ADDR_OWVAR 27
1791: PUSH
1792: LD_INT 1
1794: ST_TO_ADDR
// hc_class := class_soldier ;
1795: LD_ADDR_OWVAR 28
1799: PUSH
1800: LD_INT 1
1802: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1803: LD_ADDR_OWVAR 29
1807: PUSH
1808: LD_INT 10
1810: PUSH
1811: LD_INT 10
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1818: LD_ADDR_OWVAR 31
1822: PUSH
1823: LD_INT 2
1825: PUSH
1826: LD_INT 0
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: ST_TO_ADDR
// RMSo2 := CreateHuman ;
1841: LD_ADDR_EXP 40
1845: PUSH
1846: CALL_OW 44
1850: ST_TO_ADDR
// hc_sex := sex_female ;
1851: LD_ADDR_OWVAR 27
1855: PUSH
1856: LD_INT 2
1858: ST_TO_ADDR
// hc_class := class_engineer ;
1859: LD_ADDR_OWVAR 28
1863: PUSH
1864: LD_INT 2
1866: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1867: LD_ADDR_OWVAR 29
1871: PUSH
1872: LD_INT 9
1874: PUSH
1875: LD_INT 10
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1882: LD_ADDR_OWVAR 31
1886: PUSH
1887: LD_INT 0
1889: PUSH
1890: LD_INT 2
1892: PUSH
1893: LD_INT 0
1895: PUSH
1896: LD_INT 0
1898: PUSH
1899: EMPTY
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: ST_TO_ADDR
// RMEn1 := CreateHuman ;
1905: LD_ADDR_EXP 41
1909: PUSH
1910: CALL_OW 44
1914: ST_TO_ADDR
// hc_sex := sex_male ;
1915: LD_ADDR_OWVAR 27
1919: PUSH
1920: LD_INT 1
1922: ST_TO_ADDR
// hc_class := class_mechanic ;
1923: LD_ADDR_OWVAR 28
1927: PUSH
1928: LD_INT 3
1930: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1931: LD_ADDR_OWVAR 29
1935: PUSH
1936: LD_INT 10
1938: PUSH
1939: LD_INT 9
1941: PUSH
1942: EMPTY
1943: LIST
1944: LIST
1945: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1946: LD_ADDR_OWVAR 31
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: LD_INT 0
1956: PUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 0
1962: PUSH
1963: EMPTY
1964: LIST
1965: LIST
1966: LIST
1967: LIST
1968: ST_TO_ADDR
// RMMe1 := CreateHuman ;
1969: LD_ADDR_EXP 42
1973: PUSH
1974: CALL_OW 44
1978: ST_TO_ADDR
// prilet_rusaci := [ RMSo1 , RMSo2 , RMMe1 ] ;
1979: LD_ADDR_EXP 7
1983: PUSH
1984: LD_EXP 39
1988: PUSH
1989: LD_EXP 40
1993: PUSH
1994: LD_EXP 42
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: ST_TO_ADDR
// prilet_arabi := [ ] ;
2004: LD_ADDR_EXP 8
2008: PUSH
2009: EMPTY
2010: ST_TO_ADDR
// end ;
2011: LD_VAR 0 1
2015: RET
// function prepare_arabian_units ; begin
2016: LD_INT 0
2018: PPUSH
// InitUc ;
2019: CALL_OW 18
// InitHc ;
2023: CALL_OW 19
// InitVc ;
2027: CALL_OW 20
// uc_nation := nation_arabian ;
2031: LD_ADDR_OWVAR 21
2035: PUSH
2036: LD_INT 2
2038: ST_TO_ADDR
// uc_side := arabians ;
2039: LD_ADDR_OWVAR 20
2043: PUSH
2044: LD_EXP 3
2048: ST_TO_ADDR
// prilet_arabi := [ ] ;
2049: LD_ADDR_EXP 8
2053: PUSH
2054: EMPTY
2055: ST_TO_ADDR
// end ;
2056: LD_VAR 0 1
2060: RET
// function prepare_sides ; begin
2061: LD_INT 0
2063: PPUSH
// you := 1 ;
2064: LD_ADDR_EXP 1
2068: PUSH
2069: LD_INT 1
2071: ST_TO_ADDR
// you2 := 4 ;
2072: LD_ADDR_EXP 4
2076: PUSH
2077: LD_INT 4
2079: ST_TO_ADDR
// arabians := 2 ;
2080: LD_ADDR_EXP 3
2084: PUSH
2085: LD_INT 2
2087: ST_TO_ADDR
// russians := 3 ;
2088: LD_ADDR_EXP 2
2092: PUSH
2093: LD_INT 3
2095: ST_TO_ADDR
// SetAttitude ( russians , you , att_enemy , true ) ;
2096: LD_EXP 2
2100: PPUSH
2101: LD_EXP 1
2105: PPUSH
2106: LD_INT 2
2108: PPUSH
2109: LD_INT 1
2111: PPUSH
2112: CALL_OW 80
// SetAttitude ( arabians , you , att_neutral , true ) ;
2116: LD_EXP 3
2120: PPUSH
2121: LD_EXP 1
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: CALL_OW 80
// SetAttitude ( arabians , russians , att_enemy , true ) ;
2136: LD_EXP 3
2140: PPUSH
2141: LD_EXP 2
2145: PPUSH
2146: LD_INT 2
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: CALL_OW 80
// end ;
2156: LD_VAR 0 1
2160: RET
// function SetDifficulty ; var t1 ; begin
2161: LD_INT 0
2163: PPUSH
2164: PPUSH
// MaterialNavic := [ 350 , 500 , 700 ] [ difficulty ] ;
2165: LD_ADDR_EXP 51
2169: PUSH
2170: LD_INT 350
2172: PUSH
2173: LD_INT 500
2175: PUSH
2176: LD_INT 700
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: LIST
2183: PUSH
2184: LD_OWVAR 67
2188: ARRAY
2189: ST_TO_ADDR
// odplata_1 := [ 130 , 90 , 75 ] [ difficulty ] ;
2190: LD_ADDR_EXP 65
2194: PUSH
2195: LD_INT 130
2197: PUSH
2198: LD_INT 90
2200: PUSH
2201: LD_INT 75
2203: PUSH
2204: EMPTY
2205: LIST
2206: LIST
2207: LIST
2208: PUSH
2209: LD_OWVAR 67
2213: ARRAY
2214: ST_TO_ADDR
// odplata_2 := [ 350 , 250 , 150 ] [ difficulty ] ;
2215: LD_ADDR_EXP 66
2219: PUSH
2220: LD_INT 350
2222: PUSH
2223: LD_INT 250
2225: PUSH
2226: LD_INT 150
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: LD_OWVAR 67
2238: ARRAY
2239: ST_TO_ADDR
// attack_to_scouting := [ 15 , 10 , 5 ] [ difficulty ] ;
2240: LD_ADDR_EXP 67
2244: PUSH
2245: LD_INT 15
2247: PUSH
2248: LD_INT 10
2250: PUSH
2251: LD_INT 5
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: LIST
2258: PUSH
2259: LD_OWVAR 67
2263: ARRAY
2264: ST_TO_ADDR
// start_scouting := [ 5 5$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
2265: LD_ADDR_EXP 68
2269: PUSH
2270: LD_INT 10500
2272: PUSH
2273: LD_INT 4200
2275: PUSH
2276: LD_INT 0
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: PUSH
2284: LD_OWVAR 67
2288: ARRAY
2289: ST_TO_ADDR
// case difficulty of 1 :
2290: LD_OWVAR 67
2294: PUSH
2295: LD_INT 1
2297: DOUBLE
2298: EQUAL
2299: IFTRUE 2303
2301: GO 2695
2303: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: LD_INT 22
2311: PUSH
2312: LD_EXP 2
2316: PUSH
2317: EMPTY
2318: LIST
2319: LIST
2320: PUSH
2321: LD_INT 21
2323: PUSH
2324: LD_INT 1
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PUSH
2331: EMPTY
2332: LIST
2333: LIST
2334: PPUSH
2335: CALL_OW 69
2339: PUSH
2340: FOR_IN
2341: IFFALSE 2403
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 3 ) ;
2343: LD_VAR 0 2
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: CALL_OW 260
2363: PUSH
2364: LD_INT 3
2366: MINUS
2367: PPUSH
2368: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 2 ) ;
2372: LD_VAR 0 2
2376: PPUSH
2377: LD_INT 2
2379: PPUSH
2380: LD_VAR 0 2
2384: PPUSH
2385: LD_INT 2
2387: PPUSH
2388: CALL_OW 260
2392: PUSH
2393: LD_INT 2
2395: MINUS
2396: PPUSH
2397: CALL_OW 239
// end ;
2401: GO 2340
2403: POP
2404: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_EXP 2
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: PUSH
2422: LD_INT 25
2424: PUSH
2425: LD_INT 1
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PUSH
2441: FOR_IN
2442: IFFALSE 2475
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) - 1 ) ;
2444: LD_VAR 0 2
2448: PPUSH
2449: LD_INT 1
2451: PPUSH
2452: LD_VAR 0 2
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: CALL_OW 259
2464: PUSH
2465: LD_INT 1
2467: MINUS
2468: PPUSH
2469: CALL_OW 237
// end ;
2473: GO 2441
2475: POP
2476: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2477: LD_ADDR_VAR 0 2
2481: PUSH
2482: LD_INT 22
2484: PUSH
2485: LD_EXP 2
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: PUSH
2494: LD_INT 25
2496: PUSH
2497: LD_INT 2
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PPUSH
2508: CALL_OW 69
2512: PUSH
2513: FOR_IN
2514: IFFALSE 2547
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2516: LD_VAR 0 2
2520: PPUSH
2521: LD_INT 2
2523: PPUSH
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 2
2531: PPUSH
2532: CALL_OW 259
2536: PUSH
2537: LD_INT 2
2539: PLUS
2540: PPUSH
2541: CALL_OW 237
// end ;
2545: GO 2513
2547: POP
2548: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2549: LD_ADDR_VAR 0 2
2553: PUSH
2554: LD_INT 22
2556: PUSH
2557: LD_EXP 2
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 25
2568: PUSH
2569: LD_INT 3
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PPUSH
2580: CALL_OW 69
2584: PUSH
2585: FOR_IN
2586: IFFALSE 2619
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) - 1 ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: LD_INT 3
2595: PPUSH
2596: LD_VAR 0 2
2600: PPUSH
2601: LD_INT 3
2603: PPUSH
2604: CALL_OW 259
2608: PUSH
2609: LD_INT 1
2611: MINUS
2612: PPUSH
2613: CALL_OW 237
// end ;
2617: GO 2585
2619: POP
2620: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
2621: LD_ADDR_VAR 0 2
2625: PUSH
2626: LD_INT 22
2628: PUSH
2629: LD_EXP 2
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 25
2640: PUSH
2641: LD_INT 4
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PPUSH
2652: CALL_OW 69
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2691
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) - 1 ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 4
2667: PPUSH
2668: LD_VAR 0 2
2672: PPUSH
2673: LD_INT 4
2675: PPUSH
2676: CALL_OW 259
2680: PUSH
2681: LD_INT 1
2683: MINUS
2684: PPUSH
2685: CALL_OW 237
// end ;
2689: GO 2657
2691: POP
2692: POP
// end ; 2 :
2693: GO 3546
2695: LD_INT 2
2697: DOUBLE
2698: EQUAL
2699: IFTRUE 2703
2701: GO 3116
2703: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2704: LD_ADDR_VAR 0 2
2708: PUSH
2709: LD_INT 22
2711: PUSH
2712: LD_EXP 2
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PUSH
2721: LD_INT 21
2723: PUSH
2724: LD_INT 1
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: PPUSH
2735: CALL_OW 69
2739: PUSH
2740: FOR_IN
2741: IFFALSE 2828
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 1 ) ;
2743: LD_VAR 0 2
2747: PPUSH
2748: LD_INT 1
2750: PPUSH
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 260
2763: PUSH
2764: LD_INT 1
2766: MINUS
2767: PPUSH
2768: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 1 ) ;
2772: LD_VAR 0 2
2776: PPUSH
2777: LD_INT 2
2779: PPUSH
2780: LD_VAR 0 2
2784: PPUSH
2785: LD_INT 2
2787: PPUSH
2788: CALL_OW 260
2792: PUSH
2793: LD_INT 1
2795: MINUS
2796: PPUSH
2797: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) ) ;
2801: LD_VAR 0 2
2805: PPUSH
2806: LD_INT 1
2808: PPUSH
2809: LD_VAR 0 2
2813: PPUSH
2814: LD_INT 1
2816: PPUSH
2817: CALL_OW 259
2821: PPUSH
2822: CALL_OW 237
// end ;
2826: GO 2740
2828: POP
2829: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2830: LD_ADDR_VAR 0 2
2834: PUSH
2835: LD_INT 22
2837: PUSH
2838: LD_EXP 2
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 25
2849: PUSH
2850: LD_INT 1
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: PUSH
2866: FOR_IN
2867: IFFALSE 2900
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
2869: LD_VAR 0 2
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_VAR 0 2
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: CALL_OW 259
2889: PUSH
2890: LD_INT 1
2892: PLUS
2893: PPUSH
2894: CALL_OW 237
// end ;
2898: GO 2866
2900: POP
2901: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2902: LD_ADDR_VAR 0 2
2906: PUSH
2907: LD_INT 22
2909: PUSH
2910: LD_EXP 2
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 25
2921: PUSH
2922: LD_INT 2
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: EMPTY
2930: LIST
2931: LIST
2932: PPUSH
2933: CALL_OW 69
2937: PUSH
2938: FOR_IN
2939: IFFALSE 2972
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2941: LD_VAR 0 2
2945: PPUSH
2946: LD_INT 2
2948: PPUSH
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 259
2961: PUSH
2962: LD_INT 2
2964: PLUS
2965: PPUSH
2966: CALL_OW 237
// end ;
2970: GO 2938
2972: POP
2973: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2974: LD_ADDR_VAR 0 2
2978: PUSH
2979: LD_INT 22
2981: PUSH
2982: LD_EXP 2
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: PUSH
2991: LD_INT 25
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL_OW 69
3009: PUSH
3010: FOR_IN
3011: IFFALSE 3040
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) ) ;
3013: LD_VAR 0 2
3017: PPUSH
3018: LD_INT 3
3020: PPUSH
3021: LD_VAR 0 2
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: CALL_OW 259
3033: PPUSH
3034: CALL_OW 237
// end ;
3038: GO 3010
3040: POP
3041: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3042: LD_ADDR_VAR 0 2
3046: PUSH
3047: LD_INT 22
3049: PUSH
3050: LD_EXP 2
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: LD_INT 25
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 69
3077: PUSH
3078: FOR_IN
3079: IFFALSE 3112
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 1 ) ;
3081: LD_VAR 0 2
3085: PPUSH
3086: LD_INT 4
3088: PPUSH
3089: LD_VAR 0 2
3093: PPUSH
3094: LD_INT 4
3096: PPUSH
3097: CALL_OW 259
3101: PUSH
3102: LD_INT 1
3104: PLUS
3105: PPUSH
3106: CALL_OW 237
// end ;
3110: GO 3078
3112: POP
3113: POP
// end ; 3 :
3114: GO 3546
3116: LD_INT 3
3118: DOUBLE
3119: EQUAL
3120: IFTRUE 3124
3122: GO 3545
3124: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: LD_INT 22
3132: PUSH
3133: LD_EXP 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: LD_INT 21
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: PPUSH
3156: CALL_OW 69
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3253
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) + 1 ) ;
3164: LD_VAR 0 2
3168: PPUSH
3169: LD_INT 1
3171: PPUSH
3172: LD_VAR 0 2
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: CALL_OW 260
3184: PUSH
3185: LD_INT 1
3187: PLUS
3188: PPUSH
3189: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) + 1 ) ;
3193: LD_VAR 0 2
3197: PPUSH
3198: LD_INT 2
3200: PPUSH
3201: LD_VAR 0 2
3205: PPUSH
3206: LD_INT 2
3208: PPUSH
3209: CALL_OW 260
3213: PUSH
3214: LD_INT 1
3216: PLUS
3217: PPUSH
3218: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
3222: LD_VAR 0 2
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: LD_VAR 0 2
3234: PPUSH
3235: LD_INT 1
3237: PPUSH
3238: CALL_OW 259
3242: PUSH
3243: LD_INT 1
3245: PLUS
3246: PPUSH
3247: CALL_OW 237
// end ;
3251: GO 3161
3253: POP
3254: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
3255: LD_ADDR_VAR 0 2
3259: PUSH
3260: LD_INT 22
3262: PUSH
3263: LD_EXP 2
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PUSH
3272: LD_INT 25
3274: PUSH
3275: LD_INT 1
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PPUSH
3286: CALL_OW 69
3290: PUSH
3291: FOR_IN
3292: IFFALSE 3325
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 2 ) ;
3294: LD_VAR 0 2
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: LD_VAR 0 2
3306: PPUSH
3307: LD_INT 1
3309: PPUSH
3310: CALL_OW 259
3314: PUSH
3315: LD_INT 2
3317: PLUS
3318: PPUSH
3319: CALL_OW 237
// end ;
3323: GO 3291
3325: POP
3326: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
3327: LD_ADDR_VAR 0 2
3331: PUSH
3332: LD_INT 22
3334: PUSH
3335: LD_EXP 2
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 25
3346: PUSH
3347: LD_INT 2
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: PPUSH
3358: CALL_OW 69
3362: PUSH
3363: FOR_IN
3364: IFFALSE 3397
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
3366: LD_VAR 0 2
3370: PPUSH
3371: LD_INT 2
3373: PPUSH
3374: LD_VAR 0 2
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: CALL_OW 259
3386: PUSH
3387: LD_INT 2
3389: PLUS
3390: PPUSH
3391: CALL_OW 237
// end ;
3395: GO 3363
3397: POP
3398: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
3399: LD_ADDR_VAR 0 2
3403: PUSH
3404: LD_INT 22
3406: PUSH
3407: LD_EXP 2
3411: PUSH
3412: EMPTY
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 25
3418: PUSH
3419: LD_INT 3
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: PPUSH
3430: CALL_OW 69
3434: PUSH
3435: FOR_IN
3436: IFFALSE 3469
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) + 2 ) ;
3438: LD_VAR 0 2
3442: PPUSH
3443: LD_INT 3
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: CALL_OW 259
3458: PUSH
3459: LD_INT 2
3461: PLUS
3462: PPUSH
3463: CALL_OW 237
// end ;
3467: GO 3435
3469: POP
3470: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3471: LD_ADDR_VAR 0 2
3475: PUSH
3476: LD_INT 22
3478: PUSH
3479: LD_EXP 2
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 25
3490: PUSH
3491: LD_INT 4
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: PPUSH
3502: CALL_OW 69
3506: PUSH
3507: FOR_IN
3508: IFFALSE 3541
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 2 ) ;
3510: LD_VAR 0 2
3514: PPUSH
3515: LD_INT 4
3517: PPUSH
3518: LD_VAR 0 2
3522: PPUSH
3523: LD_INT 4
3525: PPUSH
3526: CALL_OW 259
3530: PUSH
3531: LD_INT 2
3533: PLUS
3534: PPUSH
3535: CALL_OW 237
// end ;
3539: GO 3507
3541: POP
3542: POP
// end ; end ;
3543: GO 3546
3545: POP
// end ;
3546: LD_VAR 0 1
3550: RET
// every 50 50$0 do var bases , i , mat ;
3551: GO 3553
3553: DISABLE
3554: LD_INT 0
3556: PPUSH
3557: PPUSH
3558: PPUSH
// begin if count_crates < MaterialNavic then
3559: CALL 25859 0 0
3563: PUSH
3564: LD_EXP 51
3568: LESS
3569: IFFALSE 3583
// begin disable ( 0 ) ;
3571: LD_INT 0
3573: DISABLE_MARKED
// YouLost ( matmin ) ;
3574: LD_STRING matmin
3576: PPUSH
3577: CALL_OW 104
// end else
3581: GO 3658
// begin disable ( 0 ) ;
3583: LD_INT 0
3585: DISABLE_MARKED
// SetMedals ;
3586: CALL 4143 0 0
// GiveMedals ( Main ) ;
3590: LD_STRING Main
3592: PPUSH
3593: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_ok ] , [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3597: LD_INT 50
3599: PUSH
3600: EMPTY
3601: LIST
3602: PUSH
3603: LD_INT 22
3605: PUSH
3606: LD_EXP 1
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: LD_INT 21
3617: PUSH
3618: LD_INT 1
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 23
3627: PUSH
3628: LD_INT 1
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: PPUSH
3641: CALL_OW 69
3645: PPUSH
3646: CALL_OW 43
// Save ;
3650: CALL 3661 0 0
// YouWin ;
3654: CALL_OW 103
// end ; end ;
3658: PPOPN 3
3660: END
// export function Save ; begin
3661: LD_INT 0
3663: PPUSH
// SaveCharacters ( JMM , JMM ) ;
3664: LD_EXP 15
3668: PPUSH
3669: LD_STRING JMM
3671: PPUSH
3672: CALL_OW 38
// SaveCharacters ( Kurt , Kurt ) ;
3676: LD_EXP 43
3680: PPUSH
3681: LD_STRING Kurt
3683: PPUSH
3684: CALL_OW 38
// SaveVariable ( not IsDead ( Kurt ) , KurtLeaves ) ;
3688: LD_EXP 43
3692: PPUSH
3693: CALL_OW 301
3697: NOT
3698: PPUSH
3699: LD_STRING KurtLeaves
3701: PPUSH
3702: CALL_OW 39
// SaveVariable ( KurtTryToEscape and not IsDead ( Kurt ) , KurtEscapes ) ;
3706: LD_EXP 85
3710: PUSH
3711: LD_EXP 43
3715: PPUSH
3716: CALL_OW 301
3720: NOT
3721: AND
3722: PPUSH
3723: LD_STRING KurtEscapes
3725: PPUSH
3726: CALL_OW 39
// SaveVariable ( remote_tried , RemoteUsed ) ;
3730: LD_EXP 82
3734: PPUSH
3735: LD_STRING RemoteUsed
3737: PPUSH
3738: CALL_OW 39
// SaveVariable ( Researched ( you , tech_RemCont ) , RemoteDeveloped ) ;
3742: LD_EXP 1
3746: PPUSH
3747: LD_INT 15
3749: PPUSH
3750: CALL_OW 325
3754: PPUSH
3755: LD_STRING RemoteDeveloped
3757: PPUSH
3758: CALL_OW 39
// if Lisa then
3762: LD_EXP 21
3766: IFFALSE 3790
// begin SaveCharacters ( Lisa , Lisa ) ;
3768: LD_EXP 21
3772: PPUSH
3773: LD_STRING Lisa
3775: PPUSH
3776: CALL_OW 38
// SaveVariable ( 9 , LisaLoc ) ;
3780: LD_INT 9
3782: PPUSH
3783: LD_STRING LisaLoc
3785: PPUSH
3786: CALL_OW 39
// end ; if Frank then
3790: LD_EXP 20
3794: IFFALSE 3818
// begin SaveCharacters ( Frank , Frank ) ;
3796: LD_EXP 20
3800: PPUSH
3801: LD_STRING Frank
3803: PPUSH
3804: CALL_OW 38
// SaveVariable ( 9 , FrankLoc ) ;
3808: LD_INT 9
3810: PPUSH
3811: LD_STRING FrankLoc
3813: PPUSH
3814: CALL_OW 39
// end ; if Donaldson then
3818: LD_EXP 24
3822: IFFALSE 3846
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3824: LD_EXP 24
3828: PPUSH
3829: LD_STRING Donaldson
3831: PPUSH
3832: CALL_OW 38
// SaveVariable ( 9 , DonaldsonLoc ) ;
3836: LD_INT 9
3838: PPUSH
3839: LD_STRING DonaldsonLoc
3841: PPUSH
3842: CALL_OW 39
// end ; if Brown then
3846: LD_EXP 25
3850: IFFALSE 3874
// begin SaveCharacters ( Brown , Brown ) ;
3852: LD_EXP 25
3856: PPUSH
3857: LD_STRING Brown
3859: PPUSH
3860: CALL_OW 38
// SaveVariable ( 9 , BrownLoc ) ;
3864: LD_INT 9
3866: PPUSH
3867: LD_STRING BrownLoc
3869: PPUSH
3870: CALL_OW 39
// end ; if Gladstone then
3874: LD_EXP 27
3878: IFFALSE 3902
// begin SaveCharacters ( Gladstone , Gladstone ) ;
3880: LD_EXP 27
3884: PPUSH
3885: LD_STRING Gladstone
3887: PPUSH
3888: CALL_OW 38
// SaveVariable ( 9 , GladstoneLoc ) ;
3892: LD_INT 9
3894: PPUSH
3895: LD_STRING GladstoneLoc
3897: PPUSH
3898: CALL_OW 39
// end ; SaveCharacters ( Joan , Joan ) ;
3902: LD_EXP 33
3906: PPUSH
3907: LD_STRING Joan
3909: PPUSH
3910: CALL_OW 38
// SaveVariable ( 9 , JoanLoc ) ;
3914: LD_INT 9
3916: PPUSH
3917: LD_STRING JoanLoc
3919: PPUSH
3920: CALL_OW 39
// if Denis then
3924: LD_EXP 26
3928: IFFALSE 3952
// begin SaveCharacters ( Denis , Denis ) ;
3930: LD_EXP 26
3934: PPUSH
3935: LD_STRING Denis
3937: PPUSH
3938: CALL_OW 38
// SaveVariable ( 9 , DenisLoc ) ;
3942: LD_INT 9
3944: PPUSH
3945: LD_STRING DenisLoc
3947: PPUSH
3948: CALL_OW 39
// end ; if Bobby then
3952: LD_EXP 23
3956: IFFALSE 3980
// begin SaveCharacters ( Bobby , Bobby ) ;
3958: LD_EXP 23
3962: PPUSH
3963: LD_STRING Bobby
3965: PPUSH
3966: CALL_OW 38
// SaveVariable ( 9 , BobbyLoc ) ;
3970: LD_INT 9
3972: PPUSH
3973: LD_STRING BobbyLoc
3975: PPUSH
3976: CALL_OW 39
// end ; if Cyrus then
3980: LD_EXP 22
3984: IFFALSE 4008
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3986: LD_EXP 22
3990: PPUSH
3991: LD_STRING Cyrus
3993: PPUSH
3994: CALL_OW 38
// SaveVariable ( 9 , CyrusLoc ) ;
3998: LD_INT 9
4000: PPUSH
4001: LD_STRING CyrusLoc
4003: PPUSH
4004: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Donaldson , Brown , Gladstone , Joan , Denis , Bobby , Cyrus , 0 ] , OtherUnplaced ) ;
4008: LD_INT 22
4010: PUSH
4011: LD_EXP 1
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: PUSH
4020: LD_INT 21
4022: PUSH
4023: LD_INT 1
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: PUSH
4030: LD_INT 23
4032: PUSH
4033: LD_INT 1
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: LIST
4044: PPUSH
4045: CALL_OW 69
4049: PUSH
4050: LD_EXP 15
4054: PUSH
4055: LD_EXP 21
4059: PUSH
4060: LD_EXP 20
4064: PUSH
4065: LD_EXP 24
4069: PUSH
4070: LD_EXP 25
4074: PUSH
4075: LD_EXP 27
4079: PUSH
4080: LD_EXP 33
4084: PUSH
4085: LD_EXP 26
4089: PUSH
4090: LD_EXP 23
4094: PUSH
4095: LD_EXP 22
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: DIFF
4116: PPUSH
4117: LD_STRING OtherUnplaced
4119: PPUSH
4120: CALL_OW 38
// DeleteCharacters ( opicaci ) ;
4124: LD_STRING opicaci
4126: PPUSH
4127: CALL_OW 40
// DeleteCharacters ( other_from5to6 ) ;
4131: LD_STRING other_from5to6
4133: PPUSH
4134: CALL_OW 40
// end ;
4138: LD_VAR 0 1
4142: RET
// export function SetMedals ; begin
4143: LD_INT 0
4145: PPUSH
// AddMedal ( cans , count_crates >= ( MaterialNavic + 100 ) ) ;
4146: LD_STRING cans
4148: PPUSH
4149: CALL 25859 0 0
4153: PUSH
4154: LD_EXP 51
4158: PUSH
4159: LD_INT 100
4161: PLUS
4162: GREATEREQUAL
4163: PPUSH
4164: CALL_OW 101
// if count_crates >= 1000 then
4168: CALL 25859 0 0
4172: PUSH
4173: LD_INT 1000
4175: GREATEREQUAL
4176: IFFALSE 4182
// SA_On1000CratesGathered ;
4178: CALL 26923 0 0
// NavicLidi := UnitFilter ( NavicLidi , [ f_ok ] ) ;
4182: LD_ADDR_EXP 84
4186: PUSH
4187: LD_EXP 84
4191: PPUSH
4192: LD_INT 50
4194: PUSH
4195: EMPTY
4196: LIST
4197: PPUSH
4198: CALL_OW 72
4202: ST_TO_ADDR
// AddMedal ( people , NavicLidi >= 3 ) ;
4203: LD_STRING people
4205: PPUSH
4206: LD_EXP 84
4210: PUSH
4211: LD_INT 3
4213: GREATEREQUAL
4214: PPUSH
4215: CALL_OW 101
// if remote_tried then
4219: LD_EXP 82
4223: IFFALSE 4237
// AddMedal ( remote , 1 ) else
4225: LD_STRING remote
4227: PPUSH
4228: LD_INT 1
4230: PPUSH
4231: CALL_OW 101
4235: GO 4279
// begin if GetTech ( tech_RemCont , you ) = state_researched then
4237: LD_INT 15
4239: PPUSH
4240: LD_EXP 1
4244: PPUSH
4245: CALL_OW 321
4249: PUSH
4250: LD_INT 2
4252: EQUAL
4253: IFFALSE 4268
// AddMedal ( remote , - 2 ) else
4255: LD_STRING remote
4257: PPUSH
4258: LD_INT 2
4260: NEG
4261: PPUSH
4262: CALL_OW 101
4266: GO 4279
// AddMedal ( remote , - 1 ) ;
4268: LD_STRING remote
4270: PPUSH
4271: LD_INT 1
4273: NEG
4274: PPUSH
4275: CALL_OW 101
// end ; end ;
4279: LD_VAR 0 1
4283: RET
// final begin end ; end_of_file
4284: END
// export mytick ; export function Dialog1 ; var Sci , i ; begin
4285: LD_INT 0
4287: PPUSH
4288: PPUSH
4289: PPUSH
// used := all ^ [ JMM ] ;
4290: LD_ADDR_EXP 12
4294: PUSH
4295: LD_EXP 9
4299: PUSH
4300: LD_EXP 15
4304: PUSH
4305: EMPTY
4306: LIST
4307: ADD
4308: ST_TO_ADDR
// if Lisa in used then
4309: LD_EXP 21
4313: PUSH
4314: LD_EXP 12
4318: IN
4319: IFFALSE 4329
// Lisa_P := true ;
4321: LD_ADDR_EXP 49
4325: PUSH
4326: LD_INT 1
4328: ST_TO_ADDR
// if Frank in used then
4329: LD_EXP 20
4333: PUSH
4334: LD_EXP 12
4338: IN
4339: IFFALSE 4349
// Frank_P := true ;
4341: LD_ADDR_EXP 50
4345: PUSH
4346: LD_INT 1
4348: ST_TO_ADDR
// opicaci := Delete ( opicaci , 3 ) ;
4349: LD_ADDR_EXP 13
4353: PUSH
4354: LD_EXP 13
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 3
4366: ST_TO_ADDR
// used := used ^ opicaci ;
4367: LD_ADDR_EXP 12
4371: PUSH
4372: LD_EXP 12
4376: PUSH
4377: LD_EXP 13
4381: ADD
4382: ST_TO_ADDR
// used := used union zgamy2 ;
4383: LD_ADDR_EXP 12
4387: PUSH
4388: LD_EXP 12
4392: PUSH
4393: LD_EXP 14
4397: UNION
4398: ST_TO_ADDR
// not_char := used diff [ JMM , Lisa , Frank ] ;
4399: LD_ADDR_EXP 11
4403: PUSH
4404: LD_EXP 12
4408: PUSH
4409: LD_EXP 15
4413: PUSH
4414: LD_EXP 21
4418: PUSH
4419: LD_EXP 20
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: DIFF
4429: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Gladstone , Denis , Brown , Donaldson ] ;
4430: LD_ADDR_EXP 11
4434: PUSH
4435: LD_EXP 11
4439: PUSH
4440: LD_EXP 22
4444: PUSH
4445: LD_EXP 23
4449: PUSH
4450: LD_EXP 27
4454: PUSH
4455: LD_EXP 26
4459: PUSH
4460: LD_EXP 25
4464: PUSH
4465: LD_EXP 24
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: DIFF
4478: ST_TO_ADDR
// if Brown in used then
4479: LD_EXP 25
4483: PUSH
4484: LD_EXP 12
4488: IN
4489: IFFALSE 4510
// not_char := not_char ^ [ Brown ] ;
4491: LD_ADDR_EXP 11
4495: PUSH
4496: LD_EXP 11
4500: PUSH
4501: LD_EXP 25
4505: PUSH
4506: EMPTY
4507: LIST
4508: ADD
4509: ST_TO_ADDR
// if Donaldson in used then
4510: LD_EXP 24
4514: PUSH
4515: LD_EXP 12
4519: IN
4520: IFFALSE 4541
// not_char := not_char ^ [ Donaldson ] ;
4522: LD_ADDR_EXP 11
4526: PUSH
4527: LD_EXP 11
4531: PUSH
4532: LD_EXP 24
4536: PUSH
4537: EMPTY
4538: LIST
4539: ADD
4540: ST_TO_ADDR
// if Cyrus in used then
4541: LD_EXP 22
4545: PUSH
4546: LD_EXP 12
4550: IN
4551: IFFALSE 4572
// not_char := not_char ^ [ Cyrus ] ;
4553: LD_ADDR_EXP 11
4557: PUSH
4558: LD_EXP 11
4562: PUSH
4563: LD_EXP 22
4567: PUSH
4568: EMPTY
4569: LIST
4570: ADD
4571: ST_TO_ADDR
// if Bobby in used then
4572: LD_EXP 23
4576: PUSH
4577: LD_EXP 12
4581: IN
4582: IFFALSE 4603
// not_char := not_char ^ [ Bobby ] ;
4584: LD_ADDR_EXP 11
4588: PUSH
4589: LD_EXP 11
4593: PUSH
4594: LD_EXP 23
4598: PUSH
4599: EMPTY
4600: LIST
4601: ADD
4602: ST_TO_ADDR
// if Gladstone in used then
4603: LD_EXP 27
4607: PUSH
4608: LD_EXP 12
4612: IN
4613: IFFALSE 4634
// not_char := not_char ^ [ Gladstone ] ;
4615: LD_ADDR_EXP 11
4619: PUSH
4620: LD_EXP 11
4624: PUSH
4625: LD_EXP 27
4629: PUSH
4630: EMPTY
4631: LIST
4632: ADD
4633: ST_TO_ADDR
// if Denis in used then
4634: LD_EXP 26
4638: PUSH
4639: LD_EXP 12
4643: IN
4644: IFFALSE 4665
// not_char := not_char ^ [ Denis ] ;
4646: LD_ADDR_EXP 11
4650: PUSH
4651: LD_EXP 11
4655: PUSH
4656: LD_EXP 26
4660: PUSH
4661: EMPTY
4662: LIST
4663: ADD
4664: ST_TO_ADDR
// SaveForQuickRestart ;
4665: CALL_OW 22
// Wait ( 0 0$1.0 ) ;
4669: LD_INT 35
4671: PPUSH
4672: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
4676: LD_STRING M1
4678: PPUSH
4679: CALL_OW 337
// case difficulty of 1 :
4683: LD_OWVAR 67
4687: PUSH
4688: LD_INT 1
4690: DOUBLE
4691: EQUAL
4692: IFTRUE 4696
4694: GO 4706
4696: POP
// ChangeMissionObjectives ( M1-1 ) ; 2 :
4697: LD_STRING M1-1
4699: PPUSH
4700: CALL_OW 337
4704: GO 4743
4706: LD_INT 2
4708: DOUBLE
4709: EQUAL
4710: IFTRUE 4714
4712: GO 4724
4714: POP
// ChangeMissionObjectives ( M1-2 ) ; 3 :
4715: LD_STRING M1-2
4717: PPUSH
4718: CALL_OW 337
4722: GO 4743
4724: LD_INT 3
4726: DOUBLE
4727: EQUAL
4728: IFTRUE 4732
4730: GO 4742
4732: POP
// ChangeMissionObjectives ( M1-3 ) ; end ;
4733: LD_STRING M1-3
4735: PPUSH
4736: CALL_OW 337
4740: GO 4743
4742: POP
// ChangeMissionObjectives ( M1cont ) ;
4743: LD_STRING M1cont
4745: PPUSH
4746: CALL_OW 337
// PlaceHumanInUnit ( zgamy2 [ 1 ] , Car1 ) ;
4750: LD_EXP 14
4754: PUSH
4755: LD_INT 1
4757: ARRAY
4758: PPUSH
4759: LD_EXP 44
4763: PPUSH
4764: CALL_OW 52
// PlaceHumanInUnit ( zgamy2 [ 2 ] , Car2 ) ;
4768: LD_EXP 14
4772: PUSH
4773: LD_INT 2
4775: ARRAY
4776: PPUSH
4777: LD_EXP 45
4781: PPUSH
4782: CALL_OW 52
// PlaceUnitXYR ( Car1 , 13 , 3 , 8 , false ) ;
4786: LD_EXP 44
4790: PPUSH
4791: LD_INT 13
4793: PPUSH
4794: LD_INT 3
4796: PPUSH
4797: LD_INT 8
4799: PPUSH
4800: LD_INT 0
4802: PPUSH
4803: CALL_OW 50
// PlaceUnitXYR ( Car2 , 13 , 3 , 8 , false ) ;
4807: LD_EXP 45
4811: PPUSH
4812: LD_INT 13
4814: PPUSH
4815: LD_INT 3
4817: PPUSH
4818: LD_INT 8
4820: PPUSH
4821: LD_INT 0
4823: PPUSH
4824: CALL_OW 50
// for i := 1 to used diff ( zgamy2 ^ [ Car1 , Car2 ] ) do
4828: LD_ADDR_VAR 0 3
4832: PUSH
4833: DOUBLE
4834: LD_INT 1
4836: DEC
4837: ST_TO_ADDR
4838: LD_EXP 12
4842: PUSH
4843: LD_EXP 14
4847: PUSH
4848: LD_EXP 44
4852: PUSH
4853: LD_EXP 45
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: ADD
4862: DIFF
4863: PUSH
4864: FOR_TO
4865: IFFALSE 4896
// PlaceUnitXYR ( used [ i ] , 70 , 3 , 8 , false ) ;
4867: LD_EXP 12
4871: PUSH
4872: LD_VAR 0 3
4876: ARRAY
4877: PPUSH
4878: LD_INT 70
4880: PPUSH
4881: LD_INT 3
4883: PPUSH
4884: LD_INT 8
4886: PPUSH
4887: LD_INT 0
4889: PPUSH
4890: CALL_OW 50
4894: GO 4864
4896: POP
4897: POP
// mytick := tick ;
4898: LD_ADDR_EXP 86
4902: PUSH
4903: LD_OWVAR 1
4907: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
4908: LD_EXP 15
4912: PPUSH
4913: CALL_OW 87
// Wait ( 0 0$3 ) ;
4917: LD_INT 105
4919: PPUSH
4920: CALL_OW 67
// talkOn ;
4924: CALL 17029 0 0
// Say ( zgamy2 [ 2 ] , DEng-Eng1-1 ) ;
4928: LD_EXP 14
4932: PUSH
4933: LD_INT 2
4935: ARRAY
4936: PPUSH
4937: LD_STRING DEng-Eng1-1
4939: PPUSH
4940: CALL_OW 88
// talkOff ;
4944: CALL 17045 0 0
// CenterOnUnits ( Car1 ) ;
4948: LD_EXP 44
4952: PPUSH
4953: CALL_OW 85
// InGameOff ;
4957: CALL_OW 9
// start_game := true ;
4961: LD_ADDR_EXP 55
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// end ;
4969: LD_VAR 0 1
4973: RET
// every 1 1$20 do
4974: GO 4976
4976: DISABLE
// begin DialogueOn ;
4977: CALL_OW 6
// SayRadio ( Har , DRem-Har-1 ) ;
4981: LD_EXP 16
4985: PPUSH
4986: LD_STRING DRem-Har-1
4988: PPUSH
4989: CALL_OW 94
// if attacky then
4993: LD_EXP 60
4997: IFFALSE 5013
// Say ( JMM , DRem-JMM-1 ) else
4999: LD_EXP 15
5003: PPUSH
5004: LD_STRING DRem-JMM-1
5006: PPUSH
5007: CALL_OW 88
5011: GO 5025
// Say ( JMM , DRem-JMM-1a ) ;
5013: LD_EXP 15
5017: PPUSH
5018: LD_STRING DRem-JMM-1a
5020: PPUSH
5021: CALL_OW 88
// SayRadio ( Har , DRem-Har-2 ) ;
5025: LD_EXP 16
5029: PPUSH
5030: LD_STRING DRem-Har-2
5032: PPUSH
5033: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5037: LD_STRING Denis
5039: PPUSH
5040: CALL_OW 29
5044: IFFALSE 5060
// Say ( JMM , DRem-JMM-2 ) else
5046: LD_EXP 15
5050: PPUSH
5051: LD_STRING DRem-JMM-2
5053: PPUSH
5054: CALL_OW 88
5058: GO 5072
// Say ( JMM , DRem-JMM-2a ) ;
5060: LD_EXP 15
5064: PPUSH
5065: LD_STRING DRem-JMM-2a
5067: PPUSH
5068: CALL_OW 88
// SayRadio ( Har , DRem-Har-3 ) ;
5072: LD_EXP 16
5076: PPUSH
5077: LD_STRING DRem-Har-3
5079: PPUSH
5080: CALL_OW 94
// Say ( JMM , DRem-JMM-3 ) ;
5084: LD_EXP 15
5088: PPUSH
5089: LD_STRING DRem-JMM-3
5091: PPUSH
5092: CALL_OW 88
// SayRadio ( Har , DRem-Har-4 ) ;
5096: LD_EXP 16
5100: PPUSH
5101: LD_STRING DRem-Har-4
5103: PPUSH
5104: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5108: LD_STRING Denis
5110: PPUSH
5111: CALL_OW 29
5115: IFFALSE 5141
// begin Say ( JMM , DRem-JMM-4 ) ;
5117: LD_EXP 15
5121: PPUSH
5122: LD_STRING DRem-JMM-4
5124: PPUSH
5125: CALL_OW 88
// SayRadio ( Har , DRem-Har-5 ) ;
5129: LD_EXP 16
5133: PPUSH
5134: LD_STRING DRem-Har-5
5136: PPUSH
5137: CALL_OW 94
// end ; DialogueOff ;
5141: CALL_OW 7
// ChangeMissionObjectives ( MR ) ;
5145: LD_STRING MR
5147: PPUSH
5148: CALL_OW 337
// if CheckCharacterSet ( Denis ) then
5152: LD_STRING Denis
5154: PPUSH
5155: CALL_OW 29
5159: IFFALSE 5207
// begin InitUc ;
5161: CALL_OW 18
// InitHc ;
5165: CALL_OW 19
// uc_side := you2 ;
5169: LD_ADDR_OWVAR 20
5173: PUSH
5174: LD_EXP 4
5178: ST_TO_ADDR
// uc_nation := nation_american ;
5179: LD_ADDR_OWVAR 21
5183: PUSH
5184: LD_INT 1
5186: ST_TO_ADDR
// Denis := CreateCharacterWithClass ( Denis , class_scientistic ) ;
5187: LD_ADDR_EXP 26
5191: PUSH
5192: LD_STRING Denis
5194: PPUSH
5195: LD_INT 4
5197: PPUSH
5198: CALL_OW 35
5202: ST_TO_ADDR
// DialogDenis ;
5203: CALL 5208 0 0
// end ; end ;
5207: END
// function DialogDenis ; var depot , nekdo , mytick ; begin
5208: LD_INT 0
5210: PPUSH
5211: PPUSH
5212: PPUSH
5213: PPUSH
// wait ( 9 9$0 ) ;
5214: LD_INT 18900
5216: PPUSH
5217: CALL_OW 67
// depot := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5221: LD_ADDR_VAR 0 2
5225: PUSH
5226: LD_INT 22
5228: PUSH
5229: LD_EXP 1
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: LD_INT 2
5240: PUSH
5241: LD_INT 30
5243: PUSH
5244: LD_INT 0
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 30
5253: PUSH
5254: LD_INT 1
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PPUSH
5270: CALL_OW 69
5274: ST_TO_ADDR
// if depot then
5275: LD_VAR 0 2
5279: IFFALSE 5295
// depot := depot [ 1 ] ;
5281: LD_ADDR_VAR 0 2
5285: PUSH
5286: LD_VAR 0 2
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: ST_TO_ADDR
// mytick := tick + 0 0$15 ;
5295: LD_ADDR_VAR 0 4
5299: PUSH
5300: LD_OWVAR 1
5304: PUSH
5305: LD_INT 525
5307: PLUS
5308: ST_TO_ADDR
// PlaceUnitArea ( Denis , denis_come , false ) ;
5309: LD_EXP 26
5313: PPUSH
5314: LD_INT 9
5316: PPUSH
5317: LD_INT 0
5319: PPUSH
5320: CALL_OW 49
// case true of GetDistUnits ( Denis , JMM ) < 20 :
5324: LD_INT 1
5326: PUSH
5327: LD_EXP 26
5331: PPUSH
5332: LD_EXP 15
5336: PPUSH
5337: CALL_OW 296
5341: PUSH
5342: LD_INT 20
5344: LESS
5345: DOUBLE
5346: EQUAL
5347: IFTRUE 5351
5349: GO 5420
5351: POP
// begin ComMoveUnit ( Denis , JMM ) ;
5352: LD_EXP 26
5356: PPUSH
5357: LD_EXP 15
5361: PPUSH
5362: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and tick < mytick do
5366: LD_EXP 26
5370: PPUSH
5371: LD_VAR 0 2
5375: PPUSH
5376: CALL_OW 296
5380: PUSH
5381: LD_INT 5
5383: GREATER
5384: PUSH
5385: LD_EXP 26
5389: PPUSH
5390: CALL_OW 302
5394: AND
5395: PUSH
5396: LD_OWVAR 1
5400: PUSH
5401: LD_VAR 0 4
5405: LESS
5406: AND
5407: IFFALSE 5418
// begin wait ( 0 0$1 ) ;
5409: LD_INT 35
5411: PPUSH
5412: CALL_OW 67
// end ;
5416: GO 5366
// end ; GetDistUnits ( Denis , depot ) < 20 :
5418: GO 5637
5420: LD_EXP 26
5424: PPUSH
5425: LD_VAR 0 2
5429: PPUSH
5430: CALL_OW 296
5434: PUSH
5435: LD_INT 20
5437: LESS
5438: DOUBLE
5439: EQUAL
5440: IFTRUE 5444
5442: GO 5524
5444: POP
// begin ComMoveUnit ( Denis , depot ) ;
5445: LD_EXP 26
5449: PPUSH
5450: LD_VAR 0 2
5454: PPUSH
5455: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and IsOk ( depot ) and tick < mytick do
5459: LD_EXP 26
5463: PPUSH
5464: LD_VAR 0 2
5468: PPUSH
5469: CALL_OW 296
5473: PUSH
5474: LD_INT 5
5476: GREATER
5477: PUSH
5478: LD_EXP 26
5482: PPUSH
5483: CALL_OW 302
5487: AND
5488: PUSH
5489: LD_VAR 0 2
5493: PPUSH
5494: CALL_OW 302
5498: AND
5499: PUSH
5500: LD_OWVAR 1
5504: PUSH
5505: LD_VAR 0 4
5509: LESS
5510: AND
5511: IFFALSE 5522
// begin wait ( 0 0$1 ) ;
5513: LD_INT 35
5515: PPUSH
5516: CALL_OW 67
// end ;
5520: GO 5459
// end ; else
5522: GO 5637
5524: POP
// begin nekdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) , denis ) ;
5525: LD_ADDR_VAR 0 3
5529: PUSH
5530: LD_INT 22
5532: PUSH
5533: LD_EXP 1
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 21
5544: PUSH
5545: LD_INT 1
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PPUSH
5556: CALL_OW 69
5560: PPUSH
5561: LD_EXP 26
5565: PPUSH
5566: CALL_OW 74
5570: ST_TO_ADDR
// ComMoveUnit ( Denis , nekdo ) ;
5571: LD_EXP 26
5575: PPUSH
5576: LD_VAR 0 3
5580: PPUSH
5581: CALL_OW 112
// while GetDistUnits ( Denis , nekdo ) > 5 and IsOK ( nekdo ) and tick < mytick do
5585: LD_EXP 26
5589: PPUSH
5590: LD_VAR 0 3
5594: PPUSH
5595: CALL_OW 296
5599: PUSH
5600: LD_INT 5
5602: GREATER
5603: PUSH
5604: LD_VAR 0 3
5608: PPUSH
5609: CALL_OW 302
5613: AND
5614: PUSH
5615: LD_OWVAR 1
5619: PUSH
5620: LD_VAR 0 4
5624: LESS
5625: AND
5626: IFFALSE 5637
// begin wait ( 0 0$1 ) ;
5628: LD_INT 35
5630: PPUSH
5631: CALL_OW 67
// end ;
5635: GO 5585
// end ; end ; ComStop ( Denis ) ;
5637: LD_EXP 26
5641: PPUSH
5642: CALL_OW 141
// SetSide ( Denis , you ) ;
5646: LD_EXP 26
5650: PPUSH
5651: LD_EXP 1
5655: PPUSH
5656: CALL_OW 235
// if IsLive ( Denis ) then
5660: LD_EXP 26
5664: PPUSH
5665: CALL_OW 300
5669: IFFALSE 5763
// begin enable ( 33 ) ;
5671: LD_INT 33
5673: ENABLE_MARKED
// DialogueOn ;
5674: CALL_OW 6
// CenterOnUnits ( Denis ) ;
5678: LD_EXP 26
5682: PPUSH
5683: CALL_OW 85
// Say ( Denis , DDen-Den-1 ) ;
5687: LD_EXP 26
5691: PPUSH
5692: LD_STRING DDen-Den-1
5694: PPUSH
5695: CALL_OW 88
// Say ( JMM , DDen-JMM-1 ) ;
5699: LD_EXP 15
5703: PPUSH
5704: LD_STRING DDen-JMM-1
5706: PPUSH
5707: CALL_OW 88
// Say ( Denis , DDen-Den-2 ) ;
5711: LD_EXP 26
5715: PPUSH
5716: LD_STRING DDen-Den-2
5718: PPUSH
5719: CALL_OW 88
// Say ( JMM , DDen-JMM-2 ) ;
5723: LD_EXP 15
5727: PPUSH
5728: LD_STRING DDen-JMM-2
5730: PPUSH
5731: CALL_OW 88
// Say ( Denis , DDen-Den-3 ) ;
5735: LD_EXP 26
5739: PPUSH
5740: LD_STRING DDen-Den-3
5742: PPUSH
5743: CALL_OW 88
// Say ( JMM , DDen-JMM-3 ) ;
5747: LD_EXP 15
5751: PPUSH
5752: LD_STRING DDen-JMM-3
5754: PPUSH
5755: CALL_OW 88
// DialogueOff ;
5759: CALL_OW 7
// end ; end ;
5763: LD_VAR 0 1
5767: RET
// export was_dialogR0 ; export function DialogR0 ; var kdo1 , kdo2 , r ; begin
5768: LD_INT 0
5770: PPUSH
5771: PPUSH
5772: PPUSH
5773: PPUSH
// if not was_dialogR0 then
5774: LD_EXP 87
5778: NOT
5779: IFFALSE 6091
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
5781: LD_ADDR_VAR 0 2
5785: PUSH
5786: LD_EXP 11
5790: PPUSH
5791: LD_EXP 1
5795: PPUSH
5796: LD_INT 1
5798: PPUSH
5799: LD_INT 0
5801: PPUSH
5802: LD_INT 1
5804: PPUSH
5805: CALL 17141 0 5
5809: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
5810: LD_ADDR_VAR 0 3
5814: PUSH
5815: LD_EXP 11
5819: PPUSH
5820: LD_EXP 1
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: LD_INT 0
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 17141 0 5
5838: ST_TO_ADDR
// if not kdo1 then
5839: LD_VAR 0 2
5843: NOT
5844: IFFALSE 5896
// kdo1 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 1 ) ;
5846: LD_ADDR_VAR 0 2
5850: PUSH
5851: CALL 13393 0 0
5855: PUSH
5856: LD_EXP 15
5860: PUSH
5861: LD_EXP 22
5865: PUSH
5866: LD_EXP 26
5870: PUSH
5871: EMPTY
5872: LIST
5873: LIST
5874: LIST
5875: DIFF
5876: PPUSH
5877: LD_EXP 1
5881: PPUSH
5882: LD_INT 1
5884: PPUSH
5885: LD_INT 0
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: CALL 17141 0 5
5895: ST_TO_ADDR
// if not kdo2 then
5896: LD_VAR 0 3
5900: NOT
5901: IFFALSE 5953
// kdo2 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 2 ) ;
5903: LD_ADDR_VAR 0 3
5907: PUSH
5908: CALL 13393 0 0
5912: PUSH
5913: LD_EXP 15
5917: PUSH
5918: LD_EXP 22
5922: PUSH
5923: LD_EXP 26
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: DIFF
5933: PPUSH
5934: LD_EXP 1
5938: PPUSH
5939: LD_INT 1
5941: PPUSH
5942: LD_INT 0
5944: PPUSH
5945: LD_INT 2
5947: PPUSH
5948: CALL 17141 0 5
5952: ST_TO_ADDR
// TalkOn ;
5953: CALL 17029 0 0
// if IsOK ( Lisa ) then
5957: LD_EXP 21
5961: PPUSH
5962: CALL_OW 302
5966: IFFALSE 5988
// r := Say ( Lisa , DR0-Lisa-1 ) else
5968: LD_ADDR_VAR 0 4
5972: PUSH
5973: LD_EXP 21
5977: PPUSH
5978: LD_STRING DR0-Lisa-1
5980: PPUSH
5981: CALL_OW 88
5985: ST_TO_ADDR
5986: GO 6006
// r := Say ( kdo1 , DR0-Sol1-1 ) ;
5988: LD_ADDR_VAR 0 4
5992: PUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_STRING DR0-Sol1-1
6000: PPUSH
6001: CALL_OW 88
6005: ST_TO_ADDR
// if r then
6006: LD_VAR 0 4
6010: IFFALSE 6061
// if IsOK ( Cyrus ) then
6012: LD_EXP 22
6016: PPUSH
6017: CALL_OW 302
6021: IFFALSE 6043
// r := Say ( Cyrus , DR0-Cyrus-1 ) else
6023: LD_ADDR_VAR 0 4
6027: PUSH
6028: LD_EXP 22
6032: PPUSH
6033: LD_STRING DR0-Cyrus-1
6035: PPUSH
6036: CALL_OW 88
6040: ST_TO_ADDR
6041: GO 6061
// r := Say ( kdo2 , DR0-Sol2-1 ) ;
6043: LD_ADDR_VAR 0 4
6047: PUSH
6048: LD_VAR 0 3
6052: PPUSH
6053: LD_STRING DR0-Sol2-1
6055: PPUSH
6056: CALL_OW 88
6060: ST_TO_ADDR
// if r then
6061: LD_VAR 0 4
6065: IFFALSE 6079
// Say ( JMM , DR0-JMM-1 ) ;
6067: LD_EXP 15
6071: PPUSH
6072: LD_STRING DR0-JMM-1
6074: PPUSH
6075: CALL_OW 88
// TalkOff ;
6079: CALL 17045 0 0
// was_dialogR0 := true ;
6083: LD_ADDR_EXP 87
6087: PUSH
6088: LD_INT 1
6090: ST_TO_ADDR
// end ; end ;
6091: LD_VAR 0 1
6095: RET
// function MajiOpto ; var i ; begin
6096: LD_INT 0
6098: PPUSH
6099: PPUSH
// result := false ;
6100: LD_ADDR_VAR 0 1
6104: PUSH
6105: LD_INT 0
6107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
6108: LD_ADDR_VAR 0 2
6112: PUSH
6113: LD_INT 22
6115: PUSH
6116: LD_EXP 1
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 2
6127: PUSH
6128: LD_INT 30
6130: PUSH
6131: LD_INT 7
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 30
6140: PUSH
6141: LD_INT 8
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 69
6161: PUSH
6162: FOR_IN
6163: IFFALSE 6213
// if ( GetLabKind ( i , 1 ) = b_lab_opto ) or ( GetLabKind ( i , 2 ) = b_lab_opto ) then
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 1
6172: PPUSH
6173: CALL_OW 268
6177: PUSH
6178: LD_INT 15
6180: EQUAL
6181: PUSH
6182: LD_VAR 0 2
6186: PPUSH
6187: LD_INT 2
6189: PPUSH
6190: CALL_OW 268
6194: PUSH
6195: LD_INT 15
6197: EQUAL
6198: OR
6199: IFFALSE 6211
// begin result := true ;
6201: LD_ADDR_VAR 0 1
6205: PUSH
6206: LD_INT 1
6208: ST_TO_ADDR
// break ;
6209: GO 6213
// end ;
6211: GO 6162
6213: POP
6214: POP
// end ;
6215: LD_VAR 0 1
6219: RET
// every 0 0$7 trigger MajiOpto and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] ] ] ) marked 33 do
6220: CALL 6096 0 0
6224: PUSH
6225: LD_INT 22
6227: PUSH
6228: LD_EXP 1
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PUSH
6237: LD_INT 2
6239: PUSH
6240: LD_INT 30
6242: PUSH
6243: LD_INT 26
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: PUSH
6250: LD_INT 30
6252: PUSH
6253: LD_INT 27
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: LIST
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PPUSH
6269: CALL_OW 69
6273: AND
6274: IFFALSE 6324
6276: GO 6278
6278: DISABLE
// begin if IsOK ( Denis ) then
6279: LD_EXP 26
6283: PPUSH
6284: CALL_OW 302
6288: IFFALSE 6324
// begin DialogueOn ;
6290: CALL_OW 6
// if Say ( Denis , DR1-Den-1 ) then
6294: LD_EXP 26
6298: PPUSH
6299: LD_STRING DR1-Den-1
6301: PPUSH
6302: CALL_OW 88
6306: IFFALSE 6320
// Say ( JMM , DR1-JMM-1 ) ;
6308: LD_EXP 15
6312: PPUSH
6313: LD_STRING DR1-JMM-1
6315: PPUSH
6316: CALL_OW 88
// DialogueOff ;
6320: CALL_OW 7
// end ; end ;
6324: END
// function ScisInLabs ; var labs , i , inlabs ; begin
6325: LD_INT 0
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
// inlabs := [ ] ;
6331: LD_ADDR_VAR 0 4
6335: PUSH
6336: EMPTY
6337: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_INT 22
6345: PUSH
6346: LD_EXP 1
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: PUSH
6355: LD_INT 2
6357: PUSH
6358: LD_INT 30
6360: PUSH
6361: LD_INT 6
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 30
6370: PUSH
6371: LD_INT 7
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 30
6380: PUSH
6381: LD_INT 8
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: PPUSH
6398: CALL_OW 69
6402: ST_TO_ADDR
// for i in labs do
6403: LD_ADDR_VAR 0 3
6407: PUSH
6408: LD_VAR 0 2
6412: PUSH
6413: FOR_IN
6414: IFFALSE 6439
// inlabs := inlabs ^ UnitsInside ( i ) ;
6416: LD_ADDR_VAR 0 4
6420: PUSH
6421: LD_VAR 0 4
6425: PUSH
6426: LD_VAR 0 3
6430: PPUSH
6431: CALL_OW 313
6435: ADD
6436: ST_TO_ADDR
6437: GO 6413
6439: POP
6440: POP
// result := UnitFilter ( inlabs , [ f_class , class_scientistic ] ) ;
6441: LD_ADDR_VAR 0 1
6445: PUSH
6446: LD_VAR 0 4
6450: PPUSH
6451: LD_INT 25
6453: PUSH
6454: LD_INT 4
6456: PUSH
6457: EMPTY
6458: LIST
6459: LIST
6460: PPUSH
6461: CALL_OW 72
6465: ST_TO_ADDR
// end ;
6466: LD_VAR 0 1
6470: RET
// export function DialogR2 ; var scis , r ; begin
6471: LD_INT 0
6473: PPUSH
6474: PPUSH
6475: PPUSH
// scis := ScisInLabs ;
6476: LD_ADDR_VAR 0 2
6480: PUSH
6481: CALL 6325 0 0
6485: ST_TO_ADDR
// if scis isect ( not_char union Denis ) then
6486: LD_VAR 0 2
6490: PUSH
6491: LD_EXP 11
6495: PUSH
6496: LD_EXP 26
6500: UNION
6501: ISECT
6502: IFFALSE 6526
// scis := scis isect ( not_char union Denis ) ;
6504: LD_ADDR_VAR 0 2
6508: PUSH
6509: LD_VAR 0 2
6513: PUSH
6514: LD_EXP 11
6518: PUSH
6519: LD_EXP 26
6523: UNION
6524: ISECT
6525: ST_TO_ADDR
// if scis then
6526: LD_VAR 0 2
6530: IFFALSE 6713
// begin DialogueOn ;
6532: CALL_OW 6
// if not IsDead ( Denis ) and ( Denis in scis ) then
6536: LD_EXP 26
6540: PPUSH
6541: CALL_OW 301
6545: NOT
6546: PUSH
6547: LD_EXP 26
6551: PUSH
6552: LD_VAR 0 2
6556: IN
6557: AND
6558: IFFALSE 6580
// r := Say ( Denis , DR2-Den-1 ) else
6560: LD_ADDR_VAR 0 3
6564: PUSH
6565: LD_EXP 26
6569: PPUSH
6570: LD_STRING DR2-Den-1
6572: PPUSH
6573: CALL_OW 88
6577: ST_TO_ADDR
6578: GO 6645
// if GetSex ( scis [ 1 ] ) = sex_male then
6580: LD_VAR 0 2
6584: PUSH
6585: LD_INT 1
6587: ARRAY
6588: PPUSH
6589: CALL_OW 258
6593: PUSH
6594: LD_INT 1
6596: EQUAL
6597: IFFALSE 6623
// r := Say ( scis [ 1 ] , DR2-Sci1-1 ) else
6599: LD_ADDR_VAR 0 3
6603: PUSH
6604: LD_VAR 0 2
6608: PUSH
6609: LD_INT 1
6611: ARRAY
6612: PPUSH
6613: LD_STRING DR2-Sci1-1
6615: PPUSH
6616: CALL_OW 88
6620: ST_TO_ADDR
6621: GO 6645
// r := Say ( scis [ 1 ] , DR2-FSci1-1 ) ;
6623: LD_ADDR_VAR 0 3
6627: PUSH
6628: LD_VAR 0 2
6632: PUSH
6633: LD_INT 1
6635: ARRAY
6636: PPUSH
6637: LD_STRING DR2-FSci1-1
6639: PPUSH
6640: CALL_OW 88
6644: ST_TO_ADDR
// if r then
6645: LD_VAR 0 3
6649: IFFALSE 6663
// Say ( JMM , DR2-JMM-1 ) ;
6651: LD_EXP 15
6655: PPUSH
6656: LD_STRING DR2-JMM-1
6658: PPUSH
6659: CALL_OW 88
// if r then
6663: LD_VAR 0 3
6667: IFFALSE 6709
// if SayAny ( not_char , DR2-Sol1-1 , you , sex_male , 0 , 0 ) then
6669: LD_EXP 11
6673: PPUSH
6674: LD_STRING DR2-Sol1-1
6676: PPUSH
6677: LD_EXP 1
6681: PPUSH
6682: LD_INT 1
6684: PPUSH
6685: LD_INT 0
6687: PPUSH
6688: LD_INT 0
6690: PPUSH
6691: CALL 17061 0 6
6695: IFFALSE 6709
// Say ( JMM , DR2-JMM-2 ) ;
6697: LD_EXP 15
6701: PPUSH
6702: LD_STRING DR2-JMM-2
6704: PPUSH
6705: CALL_OW 88
// DialogueOff ;
6709: CALL_OW 7
// end ; end ;
6713: LD_VAR 0 1
6717: RET
// export function DialogKurt ( kdo ) ; var qr , mytick ; var JeMM , JeF ; begin
6718: LD_INT 0
6720: PPUSH
6721: PPUSH
6722: PPUSH
6723: PPUSH
6724: PPUSH
// DialogInProgress := true ;
6725: LD_ADDR_EXP 52
6729: PUSH
6730: LD_INT 1
6732: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_outside ] , [ f_nation , nation_american ] , [ f_alive ] ] ) , Kurt ) ;
6733: LD_ADDR_VAR 0 1
6737: PUSH
6738: LD_INT 22
6740: PUSH
6741: LD_EXP 1
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: PUSH
6750: LD_INT 21
6752: PUSH
6753: LD_INT 1
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: PUSH
6760: LD_INT 56
6762: PUSH
6763: EMPTY
6764: LIST
6765: PUSH
6766: LD_INT 23
6768: PUSH
6769: LD_INT 1
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 51
6778: PUSH
6779: EMPTY
6780: LIST
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: LIST
6786: LIST
6787: LIST
6788: PPUSH
6789: CALL_OW 69
6793: PPUSH
6794: LD_EXP 43
6798: PPUSH
6799: CALL_OW 74
6803: ST_TO_ADDR
// JeF := ( GetSex ( kdo ) = sex_female ) ;
6804: LD_ADDR_VAR 0 6
6808: PUSH
6809: LD_VAR 0 1
6813: PPUSH
6814: CALL_OW 258
6818: PUSH
6819: LD_INT 2
6821: EQUAL
6822: ST_TO_ADDR
// JeMM := ( kdo = JMM ) ;
6823: LD_ADDR_VAR 0 5
6827: PUSH
6828: LD_VAR 0 1
6832: PUSH
6833: LD_EXP 15
6837: EQUAL
6838: ST_TO_ADDR
// InGameOn ;
6839: CALL_OW 8
// CenterOnUnits ( Kurt ) ;
6843: LD_EXP 43
6847: PPUSH
6848: CALL_OW 85
// Wait ( 0 0$4 ) ;
6852: LD_INT 140
6854: PPUSH
6855: CALL_OW 67
// ComMoveUnit ( kdo , Kurt ) ;
6859: LD_VAR 0 1
6863: PPUSH
6864: LD_EXP 43
6868: PPUSH
6869: CALL_OW 112
// AddComTurnUnit ( kdo , Kurt ) ;
6873: LD_VAR 0 1
6877: PPUSH
6878: LD_EXP 43
6882: PPUSH
6883: CALL_OW 179
// AddComHold ( kdo ) ;
6887: LD_VAR 0 1
6891: PPUSH
6892: CALL_OW 200
// ComMoveUnit ( Kurt , kdo ) ;
6896: LD_EXP 43
6900: PPUSH
6901: LD_VAR 0 1
6905: PPUSH
6906: CALL_OW 112
// AddComTurnUnit ( Kurt , kdo ) ;
6910: LD_EXP 43
6914: PPUSH
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 179
// AddComHold ( Kurt ) ;
6924: LD_EXP 43
6928: PPUSH
6929: CALL_OW 200
// mytick := tick + 0 0$15 ;
6933: LD_ADDR_VAR 0 4
6937: PUSH
6938: LD_OWVAR 1
6942: PUSH
6943: LD_INT 525
6945: PLUS
6946: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Kurt , kdo ) > 4 do
6947: LD_VAR 0 4
6951: PUSH
6952: LD_OWVAR 1
6956: GREATER
6957: PUSH
6958: LD_EXP 43
6962: PPUSH
6963: LD_VAR 0 1
6967: PPUSH
6968: CALL_OW 296
6972: PUSH
6973: LD_INT 4
6975: GREATER
6976: AND
6977: IFFALSE 6988
// Wait ( 0 0$1 ) ;
6979: LD_INT 35
6981: PPUSH
6982: CALL_OW 67
6986: GO 6947
// InGameOff ;
6988: CALL_OW 9
// if IsLive ( Kurt ) and IsLive ( kdo ) then
6992: LD_EXP 43
6996: PPUSH
6997: CALL_OW 300
7001: PUSH
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 300
7011: AND
7012: IFFALSE 8268
// begin DialogueOn ;
7014: CALL_OW 6
// if JeMM then
7018: LD_VAR 0 5
7022: IFFALSE 7352
// begin Say ( Kurt , D2-Kurt-1 ) ;
7024: LD_EXP 43
7028: PPUSH
7029: LD_STRING D2-Kurt-1
7031: PPUSH
7032: CALL_OW 88
// Say ( kdo , D2-JMM-1 ) ;
7036: LD_VAR 0 1
7040: PPUSH
7041: LD_STRING D2-JMM-1
7043: PPUSH
7044: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7048: LD_EXP 43
7052: PPUSH
7053: LD_STRING D2-Kurt-2
7055: PPUSH
7056: CALL_OW 88
// Say ( kdo , D2-JMM-2 ) ;
7060: LD_VAR 0 1
7064: PPUSH
7065: LD_STRING D2-JMM-2
7067: PPUSH
7068: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7072: LD_EXP 43
7076: PPUSH
7077: LD_STRING D2-Kurt-3
7079: PPUSH
7080: CALL_OW 88
// Say ( kdo , D2-JMM-3 ) ;
7084: LD_VAR 0 1
7088: PPUSH
7089: LD_STRING D2-JMM-3
7091: PPUSH
7092: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7096: LD_EXP 43
7100: PPUSH
7101: LD_STRING D2-Kurt-4
7103: PPUSH
7104: CALL_OW 88
// Say ( kdo , D2-JMM-4 ) ;
7108: LD_VAR 0 1
7112: PPUSH
7113: LD_STRING D2-JMM-4
7115: PPUSH
7116: CALL_OW 88
// qr := Query ( QKill ) ;
7120: LD_ADDR_VAR 0 3
7124: PUSH
7125: LD_STRING QKill
7127: PPUSH
7128: CALL_OW 97
7132: ST_TO_ADDR
// case qr of 1 :
7133: LD_VAR 0 3
7137: PUSH
7138: LD_INT 1
7140: DOUBLE
7141: EQUAL
7142: IFTRUE 7146
7144: GO 7161
7146: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7147: LD_EXP 43
7151: PPUSH
7152: LD_STRING D2a-Kurt-1
7154: PPUSH
7155: CALL_OW 88
// end ; 2 :
7159: GO 7263
7161: LD_INT 2
7163: DOUBLE
7164: EQUAL
7165: IFTRUE 7169
7167: GO 7227
7169: POP
// begin Say ( kdo , D2b-JMM-1 ) ;
7170: LD_VAR 0 1
7174: PPUSH
7175: LD_STRING D2b-JMM-1
7177: PPUSH
7178: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7182: LD_EXP 43
7186: PPUSH
7187: LD_STRING D2b-Kurt-1
7189: PPUSH
7190: CALL_OW 88
// Say ( kdo , D2b-JMM-2 ) ;
7194: LD_VAR 0 1
7198: PPUSH
7199: LD_STRING D2b-JMM-2
7201: PPUSH
7202: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7206: LD_EXP 43
7210: PPUSH
7211: LD_STRING D2b-Kurt-2
7213: PPUSH
7214: CALL_OW 88
// SayEffect ( Kurtfire.wav ) ;
7218: LD_STRING Kurtfire.wav
7220: PPUSH
7221: CALL_OW 96
// end ; 3 :
7225: GO 7263
7227: LD_INT 3
7229: DOUBLE
7230: EQUAL
7231: IFTRUE 7235
7233: GO 7262
7235: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7236: LD_VAR 0 1
7240: PPUSH
7241: LD_STRING D2c-JMM-1
7243: PPUSH
7244: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7248: LD_EXP 43
7252: PPUSH
7253: LD_STRING D2c-Kurt-1
7255: PPUSH
7256: CALL_OW 88
// end ; end ;
7260: GO 7263
7262: POP
// if qr = 2 then
7263: LD_VAR 0 3
7267: PUSH
7268: LD_INT 2
7270: EQUAL
7271: IFFALSE 7350
// begin qr := Query ( QKill2 ) ;
7273: LD_ADDR_VAR 0 3
7277: PUSH
7278: LD_STRING QKill2
7280: PPUSH
7281: CALL_OW 97
7285: ST_TO_ADDR
// case qr of 1 :
7286: LD_VAR 0 3
7290: PUSH
7291: LD_INT 1
7293: DOUBLE
7294: EQUAL
7295: IFTRUE 7299
7297: GO 7314
7299: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7300: LD_EXP 43
7304: PPUSH
7305: LD_STRING D2a-Kurt-1
7307: PPUSH
7308: CALL_OW 88
// end ; 2 :
7312: GO 7350
7314: LD_INT 2
7316: DOUBLE
7317: EQUAL
7318: IFTRUE 7322
7320: GO 7349
7322: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7323: LD_VAR 0 1
7327: PPUSH
7328: LD_STRING D2c-JMM-1
7330: PPUSH
7331: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7335: LD_EXP 43
7339: PPUSH
7340: LD_STRING D2c-Kurt-1
7342: PPUSH
7343: CALL_OW 88
// end ; end ;
7347: GO 7350
7349: POP
// end ; end else
7350: GO 8046
// if JeF then
7352: LD_VAR 0 6
7356: IFFALSE 7703
// begin Say ( Kurt , D2-Kurt-1 ) ;
7358: LD_EXP 43
7362: PPUSH
7363: LD_STRING D2-Kurt-1
7365: PPUSH
7366: CALL_OW 88
// Say ( kdo , D2-FSol1-1 ) ;
7370: LD_VAR 0 1
7374: PPUSH
7375: LD_STRING D2-FSol1-1
7377: PPUSH
7378: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7382: LD_EXP 43
7386: PPUSH
7387: LD_STRING D2-Kurt-2
7389: PPUSH
7390: CALL_OW 88
// Say ( kdo , D2-FSol1-2 ) ;
7394: LD_VAR 0 1
7398: PPUSH
7399: LD_STRING D2-FSol1-2
7401: PPUSH
7402: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7406: LD_EXP 43
7410: PPUSH
7411: LD_STRING D2-Kurt-3
7413: PPUSH
7414: CALL_OW 88
// Say ( kdo , D2-FSol1-3 ) ;
7418: LD_VAR 0 1
7422: PPUSH
7423: LD_STRING D2-FSol1-3
7425: PPUSH
7426: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7430: LD_EXP 43
7434: PPUSH
7435: LD_STRING D2-Kurt-4
7437: PPUSH
7438: CALL_OW 88
// Say ( kdo , D2-FSol1-4 ) ;
7442: LD_VAR 0 1
7446: PPUSH
7447: LD_STRING D2-FSol1-4
7449: PPUSH
7450: CALL_OW 88
// Say ( kdo , D2-FSol1-5 ) ;
7454: LD_VAR 0 1
7458: PPUSH
7459: LD_STRING D2-FSol1-5
7461: PPUSH
7462: CALL_OW 88
// qr := Query ( QKill ) ;
7466: LD_ADDR_VAR 0 3
7470: PUSH
7471: LD_STRING QKill
7473: PPUSH
7474: CALL_OW 97
7478: ST_TO_ADDR
// case qr of 1 :
7479: LD_VAR 0 3
7483: PUSH
7484: LD_INT 1
7486: DOUBLE
7487: EQUAL
7488: IFTRUE 7492
7490: GO 7507
7492: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7493: LD_EXP 43
7497: PPUSH
7498: LD_STRING D2a-Kurt-1
7500: PPUSH
7501: CALL_OW 88
// end ; 2 :
7505: GO 7614
7507: LD_INT 2
7509: DOUBLE
7510: EQUAL
7511: IFTRUE 7515
7513: GO 7578
7515: POP
// begin Say ( kdo , D2b-FSol1-1 ) ;
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_STRING D2b-FSol1-1
7523: PPUSH
7524: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7528: LD_EXP 43
7532: PPUSH
7533: LD_STRING D2b-Kurt-1
7535: PPUSH
7536: CALL_OW 88
// Say ( kdo , D2b-FSol1-2 ) ;
7540: LD_VAR 0 1
7544: PPUSH
7545: LD_STRING D2b-FSol1-2
7547: PPUSH
7548: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7552: LD_EXP 43
7556: PPUSH
7557: LD_STRING D2b-Kurt-2
7559: PPUSH
7560: CALL_OW 88
// Say ( kdo , D2b-FSol1-3 ) ;
7564: LD_VAR 0 1
7568: PPUSH
7569: LD_STRING D2b-FSol1-3
7571: PPUSH
7572: CALL_OW 88
// end ; 3 :
7576: GO 7614
7578: LD_INT 3
7580: DOUBLE
7581: EQUAL
7582: IFTRUE 7586
7584: GO 7613
7586: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7587: LD_VAR 0 1
7591: PPUSH
7592: LD_STRING D2c-FSol1-1
7594: PPUSH
7595: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7599: LD_EXP 43
7603: PPUSH
7604: LD_STRING D2c-Kurt-1
7606: PPUSH
7607: CALL_OW 88
// end ; end ;
7611: GO 7614
7613: POP
// if qr = 2 then
7614: LD_VAR 0 3
7618: PUSH
7619: LD_INT 2
7621: EQUAL
7622: IFFALSE 7701
// begin qr := Query ( QKill2 ) ;
7624: LD_ADDR_VAR 0 3
7628: PUSH
7629: LD_STRING QKill2
7631: PPUSH
7632: CALL_OW 97
7636: ST_TO_ADDR
// case qr of 1 :
7637: LD_VAR 0 3
7641: PUSH
7642: LD_INT 1
7644: DOUBLE
7645: EQUAL
7646: IFTRUE 7650
7648: GO 7665
7650: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7651: LD_EXP 43
7655: PPUSH
7656: LD_STRING D2a-Kurt-1
7658: PPUSH
7659: CALL_OW 88
// end ; 2 :
7663: GO 7701
7665: LD_INT 2
7667: DOUBLE
7668: EQUAL
7669: IFTRUE 7673
7671: GO 7700
7673: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7674: LD_VAR 0 1
7678: PPUSH
7679: LD_STRING D2c-FSol1-1
7681: PPUSH
7682: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7686: LD_EXP 43
7690: PPUSH
7691: LD_STRING D2c-Kurt-1
7693: PPUSH
7694: CALL_OW 88
// end ; end ;
7698: GO 7701
7700: POP
// end ; end else
7701: GO 8046
// begin Say ( Kurt , D2-Kurt-1 ) ;
7703: LD_EXP 43
7707: PPUSH
7708: LD_STRING D2-Kurt-1
7710: PPUSH
7711: CALL_OW 88
// Say ( kdo , D2-Sol1-1 ) ;
7715: LD_VAR 0 1
7719: PPUSH
7720: LD_STRING D2-Sol1-1
7722: PPUSH
7723: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7727: LD_EXP 43
7731: PPUSH
7732: LD_STRING D2-Kurt-2
7734: PPUSH
7735: CALL_OW 88
// Say ( kdo , D2-Sol1-2 ) ;
7739: LD_VAR 0 1
7743: PPUSH
7744: LD_STRING D2-Sol1-2
7746: PPUSH
7747: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7751: LD_EXP 43
7755: PPUSH
7756: LD_STRING D2-Kurt-3
7758: PPUSH
7759: CALL_OW 88
// Say ( kdo , D2-Sol1-3 ) ;
7763: LD_VAR 0 1
7767: PPUSH
7768: LD_STRING D2-Sol1-3
7770: PPUSH
7771: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7775: LD_EXP 43
7779: PPUSH
7780: LD_STRING D2-Kurt-4
7782: PPUSH
7783: CALL_OW 88
// Say ( kdo , D2-Sol1-4 ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_STRING D2-Sol1-4
7794: PPUSH
7795: CALL_OW 88
// Say ( kdo , D2-Sol1-5 ) ;
7799: LD_VAR 0 1
7803: PPUSH
7804: LD_STRING D2-Sol1-5
7806: PPUSH
7807: CALL_OW 88
// qr := Query ( QKill ) ;
7811: LD_ADDR_VAR 0 3
7815: PUSH
7816: LD_STRING QKill
7818: PPUSH
7819: CALL_OW 97
7823: ST_TO_ADDR
// case qr of 1 :
7824: LD_VAR 0 3
7828: PUSH
7829: LD_INT 1
7831: DOUBLE
7832: EQUAL
7833: IFTRUE 7837
7835: GO 7852
7837: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7838: LD_EXP 43
7842: PPUSH
7843: LD_STRING D2a-Kurt-1
7845: PPUSH
7846: CALL_OW 88
// end ; 2 :
7850: GO 7959
7852: LD_INT 2
7854: DOUBLE
7855: EQUAL
7856: IFTRUE 7860
7858: GO 7923
7860: POP
// begin Say ( kdo , D2b-Sol1-1 ) ;
7861: LD_VAR 0 1
7865: PPUSH
7866: LD_STRING D2b-Sol1-1
7868: PPUSH
7869: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7873: LD_EXP 43
7877: PPUSH
7878: LD_STRING D2b-Kurt-1
7880: PPUSH
7881: CALL_OW 88
// Say ( kdo , D2b-Sol1-2 ) ;
7885: LD_VAR 0 1
7889: PPUSH
7890: LD_STRING D2b-Sol1-2
7892: PPUSH
7893: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7897: LD_EXP 43
7901: PPUSH
7902: LD_STRING D2b-Kurt-2
7904: PPUSH
7905: CALL_OW 88
// Say ( kdo , D2b-Sol1-3 ) ;
7909: LD_VAR 0 1
7913: PPUSH
7914: LD_STRING D2b-Sol1-3
7916: PPUSH
7917: CALL_OW 88
// end ; 3 :
7921: GO 7959
7923: LD_INT 3
7925: DOUBLE
7926: EQUAL
7927: IFTRUE 7931
7929: GO 7958
7931: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
7932: LD_VAR 0 1
7936: PPUSH
7937: LD_STRING D2c-Sol1-1
7939: PPUSH
7940: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7944: LD_EXP 43
7948: PPUSH
7949: LD_STRING D2c-Kurt-1
7951: PPUSH
7952: CALL_OW 88
// end ; end ;
7956: GO 7959
7958: POP
// if qr = 2 then
7959: LD_VAR 0 3
7963: PUSH
7964: LD_INT 2
7966: EQUAL
7967: IFFALSE 8046
// begin qr := Query ( QKill2 ) ;
7969: LD_ADDR_VAR 0 3
7973: PUSH
7974: LD_STRING QKill2
7976: PPUSH
7977: CALL_OW 97
7981: ST_TO_ADDR
// case qr of 1 :
7982: LD_VAR 0 3
7986: PUSH
7987: LD_INT 1
7989: DOUBLE
7990: EQUAL
7991: IFTRUE 7995
7993: GO 8010
7995: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7996: LD_EXP 43
8000: PPUSH
8001: LD_STRING D2a-Kurt-1
8003: PPUSH
8004: CALL_OW 88
// end ; 2 :
8008: GO 8046
8010: LD_INT 2
8012: DOUBLE
8013: EQUAL
8014: IFTRUE 8018
8016: GO 8045
8018: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8019: LD_VAR 0 1
8023: PPUSH
8024: LD_STRING D2c-Sol1-1
8026: PPUSH
8027: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8031: LD_EXP 43
8035: PPUSH
8036: LD_STRING D2c-Kurt-1
8038: PPUSH
8039: CALL_OW 88
// end ; end ;
8043: GO 8046
8045: POP
// end ; end ; DialogueOff ;
8046: CALL_OW 7
// if qr = 1 then
8050: LD_VAR 0 3
8054: PUSH
8055: LD_INT 1
8057: EQUAL
8058: IFFALSE 8160
// begin KurtTryToEscape := true ;
8060: LD_ADDR_EXP 85
8064: PUSH
8065: LD_INT 1
8067: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
8068: LD_EXP 3
8072: PPUSH
8073: LD_EXP 1
8077: PPUSH
8078: LD_INT 2
8080: PPUSH
8081: LD_INT 1
8083: PPUSH
8084: CALL_OW 80
// ComAttackUnit ( kdo , Kurt ) ;
8088: LD_VAR 0 1
8092: PPUSH
8093: LD_EXP 43
8097: PPUSH
8098: CALL_OW 115
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) do
8102: LD_EXP 43
8106: PPUSH
8107: LD_INT 10
8109: PPUSH
8110: CALL_OW 308
8114: NOT
8115: PUSH
8116: LD_EXP 43
8120: PPUSH
8121: CALL_OW 300
8125: AND
8126: IFFALSE 8149
// begin ComMoveToArea ( Kurt , border ) ;
8128: LD_EXP 43
8132: PPUSH
8133: LD_INT 10
8135: PPUSH
8136: CALL_OW 113
// wait ( 0 0$1 ) ;
8140: LD_INT 35
8142: PPUSH
8143: CALL_OW 67
// end ;
8147: GO 8102
// RemoveUnit ( Kurt ) ;
8149: LD_EXP 43
8153: PPUSH
8154: CALL_OW 64
// end else
8158: GO 8268
// begin SA_OnKurtSpared ;
8160: CALL 26908 0 0
// mytick := tick + 0 0$20 ;
8164: LD_ADDR_VAR 0 4
8168: PUSH
8169: LD_OWVAR 1
8173: PUSH
8174: LD_INT 700
8176: PLUS
8177: ST_TO_ADDR
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) and mytick > tick do
8178: LD_EXP 43
8182: PPUSH
8183: LD_INT 10
8185: PPUSH
8186: CALL_OW 308
8190: NOT
8191: PUSH
8192: LD_EXP 43
8196: PPUSH
8197: CALL_OW 300
8201: AND
8202: PUSH
8203: LD_VAR 0 4
8207: PUSH
8208: LD_OWVAR 1
8212: GREATER
8213: AND
8214: IFFALSE 8237
// begin ComMoveToArea ( Kurt , border ) ;
8216: LD_EXP 43
8220: PPUSH
8221: LD_INT 10
8223: PPUSH
8224: CALL_OW 113
// wait ( 0 0$1 ) ;
8228: LD_INT 35
8230: PPUSH
8231: CALL_OW 67
// end ;
8235: GO 8178
// if IsPlaced ( Kurt ) and IsLive ( kurt ) then
8237: LD_EXP 43
8241: PPUSH
8242: CALL_OW 305
8246: PUSH
8247: LD_EXP 43
8251: PPUSH
8252: CALL_OW 300
8256: AND
8257: IFFALSE 8268
// RemoveUnit ( Kurt ) ;
8259: LD_EXP 43
8263: PPUSH
8264: CALL_OW 64
// end ; end ; DialogInProgress := false ;
8268: LD_ADDR_EXP 52
8272: PUSH
8273: LD_INT 0
8275: ST_TO_ADDR
// end ;
8276: LD_VAR 0 2
8280: RET
// every 0 0$10 trigger GetAttitude ( arabians , you ) = att_enemy do
8281: LD_EXP 3
8285: PPUSH
8286: LD_EXP 1
8290: PPUSH
8291: CALL_OW 81
8295: PUSH
8296: LD_INT 2
8298: EQUAL
8299: IFFALSE 8312
8301: GO 8303
8303: DISABLE
// begin KurtTryToEscape := true ;
8304: LD_ADDR_EXP 85
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// end ;
8312: END
// export function DialogJoan ( kdo ) ; var mytick ; begin
8313: LD_INT 0
8315: PPUSH
8316: PPUSH
// DialogInProgress := true ;
8317: LD_ADDR_EXP 52
8321: PUSH
8322: LD_INT 1
8324: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8325: LD_ADDR_VAR 0 1
8329: PUSH
8330: LD_INT 26
8332: PUSH
8333: LD_INT 1
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: LD_INT 22
8342: PUSH
8343: LD_EXP 1
8347: PUSH
8348: EMPTY
8349: LIST
8350: LIST
8351: PUSH
8352: LD_INT 21
8354: PUSH
8355: LD_INT 1
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PUSH
8362: LD_INT 3
8364: PUSH
8365: LD_INT 54
8367: PUSH
8368: EMPTY
8369: LIST
8370: PUSH
8371: LD_INT 3
8373: PUSH
8374: LD_INT 55
8376: PUSH
8377: EMPTY
8378: LIST
8379: PUSH
8380: LD_INT 3
8382: PUSH
8383: LD_INT 23
8385: PUSH
8386: LD_INT 0
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: PUSH
8393: LD_INT 51
8395: PUSH
8396: EMPTY
8397: LIST
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: LIST
8403: LIST
8404: LIST
8405: LIST
8406: LIST
8407: LIST
8408: LIST
8409: LIST
8410: PPUSH
8411: CALL_OW 69
8415: PUSH
8416: LD_EXP 33
8420: DIFF
8421: PPUSH
8422: LD_EXP 33
8426: PPUSH
8427: CALL_OW 74
8431: ST_TO_ADDR
// InGameOn ;
8432: CALL_OW 8
// CenterOnUnits ( Joan ) ;
8436: LD_EXP 33
8440: PPUSH
8441: CALL_OW 85
// DoNotAttack ( russians , Joan ) ;
8445: LD_EXP 2
8449: PPUSH
8450: LD_EXP 33
8454: PPUSH
8455: CALL_OW 471
// Wait ( 0 0$5 ) ;
8459: LD_INT 175
8461: PPUSH
8462: CALL_OW 67
// SetLives ( Joan , hranice_umirani + 50 ) ;
8466: LD_EXP 33
8470: PPUSH
8471: LD_INT 250
8473: PUSH
8474: LD_INT 50
8476: PLUS
8477: PPUSH
8478: CALL_OW 234
// AddComMoveUnit ( Joan , kdo ) ;
8482: LD_EXP 33
8486: PPUSH
8487: LD_VAR 0 1
8491: PPUSH
8492: CALL_OW 172
// AddComTurnUnit ( Joan , kdo ) ;
8496: LD_EXP 33
8500: PPUSH
8501: LD_VAR 0 1
8505: PPUSH
8506: CALL_OW 179
// AddComHold ( Joan ) ;
8510: LD_EXP 33
8514: PPUSH
8515: CALL_OW 200
// ComMoveUnit ( kdo , Joan ) ;
8519: LD_VAR 0 1
8523: PPUSH
8524: LD_EXP 33
8528: PPUSH
8529: CALL_OW 112
// AddComTurnUnit ( kdo , Joan ) ;
8533: LD_VAR 0 1
8537: PPUSH
8538: LD_EXP 33
8542: PPUSH
8543: CALL_OW 179
// AddComHold ( kdo ) ;
8547: LD_VAR 0 1
8551: PPUSH
8552: CALL_OW 200
// mytick := tick + 0 0$15 ;
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: LD_OWVAR 1
8565: PUSH
8566: LD_INT 525
8568: PLUS
8569: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , kdo ) > 4 and IsOK ( kdo ) do
8570: LD_VAR 0 3
8574: PUSH
8575: LD_OWVAR 1
8579: GREATER
8580: PUSH
8581: LD_EXP 33
8585: PPUSH
8586: LD_VAR 0 1
8590: PPUSH
8591: CALL_OW 296
8595: PUSH
8596: LD_INT 4
8598: GREATER
8599: AND
8600: PUSH
8601: LD_VAR 0 1
8605: PPUSH
8606: CALL_OW 302
8610: AND
8611: IFFALSE 8622
// Wait ( 0 0$1 ) ;
8613: LD_INT 35
8615: PPUSH
8616: CALL_OW 67
8620: GO 8570
// if not IsOK ( kdo ) then
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 302
8631: NOT
8632: IFFALSE 8741
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8634: LD_ADDR_VAR 0 1
8638: PUSH
8639: LD_INT 26
8641: PUSH
8642: LD_INT 1
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 22
8651: PUSH
8652: LD_EXP 1
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 21
8663: PUSH
8664: LD_INT 1
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 3
8673: PUSH
8674: LD_INT 54
8676: PUSH
8677: EMPTY
8678: LIST
8679: PUSH
8680: LD_INT 3
8682: PUSH
8683: LD_INT 55
8685: PUSH
8686: EMPTY
8687: LIST
8688: PUSH
8689: LD_INT 3
8691: PUSH
8692: LD_INT 23
8694: PUSH
8695: LD_INT 0
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: PUSH
8702: LD_INT 51
8704: PUSH
8705: EMPTY
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: LIST
8718: LIST
8719: PPUSH
8720: CALL_OW 69
8724: PUSH
8725: LD_EXP 33
8729: DIFF
8730: PPUSH
8731: LD_EXP 33
8735: PPUSH
8736: CALL_OW 74
8740: ST_TO_ADDR
// InGameOff ;
8741: CALL_OW 9
// if IsLive ( Joan ) and IsLive ( kdo ) then
8745: LD_EXP 33
8749: PPUSH
8750: CALL_OW 300
8754: PUSH
8755: LD_VAR 0 1
8759: PPUSH
8760: CALL_OW 300
8764: AND
8765: IFFALSE 9127
// begin DialogueOn ;
8767: CALL_OW 6
// if kdo = JMM then
8771: LD_VAR 0 1
8775: PUSH
8776: LD_EXP 15
8780: EQUAL
8781: IFFALSE 8857
// begin Say ( kdo , D5b-JMM-1 ) ;
8783: LD_VAR 0 1
8787: PPUSH
8788: LD_STRING D5b-JMM-1
8790: PPUSH
8791: CALL_OW 88
// Say ( Joan , D5b-Joan-1 ) ;
8795: LD_EXP 33
8799: PPUSH
8800: LD_STRING D5b-Joan-1
8802: PPUSH
8803: CALL_OW 88
// Say ( kdo , D5b-JMM-2 ) ;
8807: LD_VAR 0 1
8811: PPUSH
8812: LD_STRING D5b-JMM-2
8814: PPUSH
8815: CALL_OW 88
// Say ( Joan , D5b-Joan-2 ) ;
8819: LD_EXP 33
8823: PPUSH
8824: LD_STRING D5b-Joan-2
8826: PPUSH
8827: CALL_OW 88
// Say ( kdo , D5b-JMM-3 ) ;
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_STRING D5b-JMM-3
8838: PPUSH
8839: CALL_OW 88
// Say ( Joan , D5b-Joan-3 ) ;
8843: LD_EXP 33
8847: PPUSH
8848: LD_STRING D5b-Joan-3
8850: PPUSH
8851: CALL_OW 88
// end else
8855: GO 9127
// begin Say ( kdo , D5a-Sol1-1 ) ;
8857: LD_VAR 0 1
8861: PPUSH
8862: LD_STRING D5a-Sol1-1
8864: PPUSH
8865: CALL_OW 88
// Say ( Joan , D5a-Joan-1 ) ;
8869: LD_EXP 33
8873: PPUSH
8874: LD_STRING D5a-Joan-1
8876: PPUSH
8877: CALL_OW 88
// Say ( kdo , D5a-Sol1-2 ) ;
8881: LD_VAR 0 1
8885: PPUSH
8886: LD_STRING D5a-Sol1-2
8888: PPUSH
8889: CALL_OW 88
// Say ( Joan , D5a-Joan-2 ) ;
8893: LD_EXP 33
8897: PPUSH
8898: LD_STRING D5a-Joan-2
8900: PPUSH
8901: CALL_OW 88
// Say ( kdo , D5a-Sol1-3 ) ;
8905: LD_VAR 0 1
8909: PPUSH
8910: LD_STRING D5a-Sol1-3
8912: PPUSH
8913: CALL_OW 88
// Say ( Joan , D5a-Joan-3 ) ;
8917: LD_EXP 33
8921: PPUSH
8922: LD_STRING D5a-Joan-3
8924: PPUSH
8925: CALL_OW 88
// Say ( kdo , D5a-Sol1-4 ) ;
8929: LD_VAR 0 1
8933: PPUSH
8934: LD_STRING D5a-Sol1-4
8936: PPUSH
8937: CALL_OW 88
// ComMoveUnit ( [ kdo , Joan ] , JMM ) ;
8941: LD_VAR 0 1
8945: PUSH
8946: LD_EXP 33
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: PPUSH
8955: LD_EXP 15
8959: PPUSH
8960: CALL_OW 112
// AddComHold ( [ kdo , Joan ] ) ;
8964: LD_VAR 0 1
8968: PUSH
8969: LD_EXP 33
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PPUSH
8978: CALL_OW 200
// DialogueOff ;
8982: CALL_OW 7
// mytick := tick + 0 0$15 ;
8986: LD_ADDR_VAR 0 3
8990: PUSH
8991: LD_OWVAR 1
8995: PUSH
8996: LD_INT 525
8998: PLUS
8999: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , JMM ) > 5 do
9000: LD_VAR 0 3
9004: PUSH
9005: LD_OWVAR 1
9009: GREATER
9010: PUSH
9011: LD_EXP 33
9015: PPUSH
9016: LD_EXP 15
9020: PPUSH
9021: CALL_OW 296
9025: PUSH
9026: LD_INT 5
9028: GREATER
9029: AND
9030: IFFALSE 9041
// Wait ( 0 0$1 ) ;
9032: LD_INT 35
9034: PPUSH
9035: CALL_OW 67
9039: GO 9000
// DialogueOn ;
9041: CALL_OW 6
// if IsLive ( Joan ) and IsLive ( JMM ) then
9045: LD_EXP 33
9049: PPUSH
9050: CALL_OW 300
9054: PUSH
9055: LD_EXP 15
9059: PPUSH
9060: CALL_OW 300
9064: AND
9065: IFFALSE 9127
// begin Say ( Joan , D5a-Joan-4 ) ;
9067: LD_EXP 33
9071: PPUSH
9072: LD_STRING D5a-Joan-4
9074: PPUSH
9075: CALL_OW 88
// Say ( JMM , D5a-JMM-4 ) ;
9079: LD_EXP 15
9083: PPUSH
9084: LD_STRING D5a-JMM-4
9086: PPUSH
9087: CALL_OW 88
// Say ( Joan , D5a-Joan-5 ) ;
9091: LD_EXP 33
9095: PPUSH
9096: LD_STRING D5a-Joan-5
9098: PPUSH
9099: CALL_OW 88
// Say ( JMM , D5a-JMM-5 ) ;
9103: LD_EXP 15
9107: PPUSH
9108: LD_STRING D5a-JMM-5
9110: PPUSH
9111: CALL_OW 88
// Say ( Joan , D5a-Joan-6 ) ;
9115: LD_EXP 33
9119: PPUSH
9120: LD_STRING D5a-Joan-6
9122: PPUSH
9123: CALL_OW 88
// end ; end ; end ; Dialog6 ;
9127: CALL 9136 0 0
// end ;
9131: LD_VAR 0 2
9135: RET
// function Dialog6 ; begin
9136: LD_INT 0
9138: PPUSH
// if IsLive ( Joan ) then
9139: LD_EXP 33
9143: PPUSH
9144: CALL_OW 300
9148: IFFALSE 9298
// begin ComStop ( [ Joan , JMM ] ) ;
9150: LD_EXP 33
9154: PUSH
9155: LD_EXP 15
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 141
// ComTurnUnit ( JMM , Joan ) ;
9168: LD_EXP 15
9172: PPUSH
9173: LD_EXP 33
9177: PPUSH
9178: CALL_OW 119
// ComTurnUnit ( Joan , JMM ) ;
9182: LD_EXP 33
9186: PPUSH
9187: LD_EXP 15
9191: PPUSH
9192: CALL_OW 119
// AddComHold ( [ JMM , Joan ] ) ;
9196: LD_EXP 15
9200: PUSH
9201: LD_EXP 33
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 200
// Say ( JMM , D6-JMM-1 ) ;
9214: LD_EXP 15
9218: PPUSH
9219: LD_STRING D6-JMM-1
9221: PPUSH
9222: CALL_OW 88
// Say ( Joan , D6-Joan-1 ) ;
9226: LD_EXP 33
9230: PPUSH
9231: LD_STRING D6-Joan-1
9233: PPUSH
9234: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9238: LD_EXP 15
9242: PPUSH
9243: LD_STRING D6-JMM-2
9245: PPUSH
9246: CALL_OW 88
// Say ( Joan , D6-Joan-2 ) ;
9250: LD_EXP 33
9254: PPUSH
9255: LD_STRING D6-Joan-2
9257: PPUSH
9258: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9262: LD_EXP 15
9266: PPUSH
9267: LD_STRING D6-JMM-3
9269: PPUSH
9270: CALL_OW 88
// Say ( Joan , D6-Joan-3 ) ;
9274: LD_EXP 33
9278: PPUSH
9279: LD_STRING D6-Joan-3
9281: PPUSH
9282: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9286: LD_EXP 15
9290: PPUSH
9291: LD_STRING D6-JMM-4
9293: PPUSH
9294: CALL_OW 88
// end ; DialogueOff ;
9298: CALL_OW 7
// ChangeMissionObjectives ( MJ ) ;
9302: LD_STRING MJ
9304: PPUSH
9305: CALL_OW 337
// SetSide ( Joan , you ) ;
9309: LD_EXP 33
9313: PPUSH
9314: LD_EXP 1
9318: PPUSH
9319: CALL_OW 235
// NormalAttack ( russians , Joan ) ;
9323: LD_EXP 2
9327: PPUSH
9328: LD_EXP 33
9332: PPUSH
9333: CALL_OW 472
// if IsLive ( Lisa ) then
9337: LD_EXP 21
9341: PPUSH
9342: CALL_OW 300
9346: IFFALSE 9356
// act_Lisa_JMM := true ;
9348: LD_ADDR_EXP 58
9352: PUSH
9353: LD_INT 1
9355: ST_TO_ADDR
// DialogInProgress := false ;
9356: LD_ADDR_EXP 52
9360: PUSH
9361: LD_INT 0
9363: ST_TO_ADDR
// end ;
9364: LD_VAR 0 1
9368: RET
// every 1 1$0 trigger act_Lisa_JMM do
9369: LD_EXP 58
9373: IFFALSE 9535
9375: GO 9377
9377: DISABLE
// begin Wait ( 3 3$0 ) ;
9378: LD_INT 6300
9380: PPUSH
9381: CALL_OW 67
// if IsLive ( Joan ) and IsLive ( Lisa ) then
9385: LD_EXP 33
9389: PPUSH
9390: CALL_OW 300
9394: PUSH
9395: LD_EXP 21
9399: PPUSH
9400: CALL_OW 300
9404: AND
9405: IFFALSE 9535
// begin DialogueOn ;
9407: CALL_OW 6
// Say ( Lisa , D7-Lisa-1 ) ;
9411: LD_EXP 21
9415: PPUSH
9416: LD_STRING D7-Lisa-1
9418: PPUSH
9419: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
9423: LD_EXP 15
9427: PPUSH
9428: LD_STRING D7-JMM-1
9430: PPUSH
9431: CALL_OW 88
// Say ( Lisa , D7-Lisa-2 ) ;
9435: LD_EXP 21
9439: PPUSH
9440: LD_STRING D7-Lisa-2
9442: PPUSH
9443: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
9447: LD_EXP 15
9451: PPUSH
9452: LD_STRING D7-JMM-2
9454: PPUSH
9455: CALL_OW 88
// Say ( Lisa , D7-Lisa-3 ) ;
9459: LD_EXP 21
9463: PPUSH
9464: LD_STRING D7-Lisa-3
9466: PPUSH
9467: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
9471: LD_EXP 15
9475: PPUSH
9476: LD_STRING D7-JMM-3
9478: PPUSH
9479: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
9483: LD_EXP 21
9487: PPUSH
9488: LD_STRING D7-Lisa-4
9490: PPUSH
9491: CALL_OW 88
// Say ( JMM , D7-JMM-4 ) ;
9495: LD_EXP 15
9499: PPUSH
9500: LD_STRING D7-JMM-4
9502: PPUSH
9503: CALL_OW 88
// Say ( JMM , D7-JMM-4a ) ;
9507: LD_EXP 15
9511: PPUSH
9512: LD_STRING D7-JMM-4a
9514: PPUSH
9515: CALL_OW 88
// Say ( Lisa , D7-Lisa-5 ) ;
9519: LD_EXP 21
9523: PPUSH
9524: LD_STRING D7-Lisa-5
9526: PPUSH
9527: CALL_OW 88
// DialogueOff ;
9531: CALL_OW 7
// end ; end ;
9535: END
// every 0 0$1.0 trigger Joan_P and not IsLive ( Joan ) do
9536: LD_EXP 48
9540: PUSH
9541: LD_EXP 33
9545: PPUSH
9546: CALL_OW 300
9550: NOT
9551: AND
9552: IFFALSE 9564
9554: GO 9556
9556: DISABLE
// begin ChangeMissionObjectives ( MJa ) ;
9557: LD_STRING MJa
9559: PPUSH
9560: CALL_OW 337
// end ;
9564: END
// every 0 0$10.0 trigger not bojujese and IsOk ( Frank ) and UnitFilter ( apemans , [ f_side , you ] ) do var kdo , kdo2 ;
9565: CALL 13338 0 0
9569: NOT
9570: PUSH
9571: LD_EXP 20
9575: PPUSH
9576: CALL_OW 302
9580: AND
9581: PUSH
9582: LD_EXP 5
9586: PPUSH
9587: LD_INT 22
9589: PUSH
9590: LD_EXP 1
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 72
9603: AND
9604: IFFALSE 9908
9606: GO 9608
9608: DISABLE
9609: LD_INT 0
9611: PPUSH
9612: PPUSH
// begin while DialogInProgress do
9613: LD_EXP 52
9617: IFFALSE 9628
// Wait ( 0 0$5 ) ;
9619: LD_INT 175
9621: PPUSH
9622: CALL_OW 67
9626: GO 9613
// kdo := WhoSayAny ( not_char , you , 0 , 0 , 1 ) ;
9628: LD_ADDR_VAR 0 1
9632: PUSH
9633: LD_EXP 11
9637: PPUSH
9638: LD_EXP 1
9642: PPUSH
9643: LD_INT 0
9645: PPUSH
9646: LD_INT 0
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL 17141 0 5
9656: ST_TO_ADDR
// if not kdo then
9657: LD_VAR 0 1
9661: NOT
9662: IFFALSE 9693
// kdo := WhoSayAny ( TvojiLidi , you , 0 , 0 , 1 ) ;
9664: LD_ADDR_VAR 0 1
9668: PUSH
9669: CALL 13393 0 0
9673: PPUSH
9674: LD_EXP 1
9678: PPUSH
9679: LD_INT 0
9681: PPUSH
9682: LD_INT 0
9684: PPUSH
9685: LD_INT 1
9687: PPUSH
9688: CALL 17141 0 5
9692: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , 0 , 0 , 2 ) ;
9693: LD_ADDR_VAR 0 2
9697: PUSH
9698: LD_EXP 11
9702: PPUSH
9703: LD_EXP 1
9707: PPUSH
9708: LD_INT 0
9710: PPUSH
9711: LD_INT 0
9713: PPUSH
9714: LD_INT 2
9716: PPUSH
9717: CALL 17141 0 5
9721: ST_TO_ADDR
// if not kdo then
9722: LD_VAR 0 1
9726: NOT
9727: IFFALSE 9758
// kdo2 := WhoSayAny ( TvojiLidi , you , 0 , 0 , 2 ) ;
9729: LD_ADDR_VAR 0 2
9733: PUSH
9734: CALL 13393 0 0
9738: PPUSH
9739: LD_EXP 1
9743: PPUSH
9744: LD_INT 0
9746: PPUSH
9747: LD_INT 0
9749: PPUSH
9750: LD_INT 2
9752: PPUSH
9753: CALL 17141 0 5
9757: ST_TO_ADDR
// if IsOk ( Frank ) then
9758: LD_EXP 20
9762: PPUSH
9763: CALL_OW 302
9767: IFFALSE 9908
// begin TalkOn ;
9769: CALL 17029 0 0
// Say ( Frank , D10-Frank-1 ) ;
9773: LD_EXP 20
9777: PPUSH
9778: LD_STRING D10-Frank-1
9780: PPUSH
9781: CALL_OW 88
// if GetSex ( kdo ) = sex_male then
9785: LD_VAR 0 1
9789: PPUSH
9790: CALL_OW 258
9794: PUSH
9795: LD_INT 1
9797: EQUAL
9798: IFFALSE 9814
// Say ( kdo , D10-Sol1-1 ) else
9800: LD_VAR 0 1
9804: PPUSH
9805: LD_STRING D10-Sol1-1
9807: PPUSH
9808: CALL_OW 88
9812: GO 9826
// Say ( kdo , D10-FSol1-1 ) ;
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_STRING D10-FSol1-1
9821: PPUSH
9822: CALL_OW 88
// Say ( Frank , D10-Frank-2 ) ;
9826: LD_EXP 20
9830: PPUSH
9831: LD_STRING D10-Frank-2
9833: PPUSH
9834: CALL_OW 88
// if IsOk ( Lisa ) then
9838: LD_EXP 21
9842: PPUSH
9843: CALL_OW 302
9847: IFFALSE 9863
// Say ( Lisa , D10-Lisa-2 ) else
9849: LD_EXP 21
9853: PPUSH
9854: LD_STRING D10-Lisa-2
9856: PPUSH
9857: CALL_OW 88
9861: GO 9904
// if GetSex ( kdo2 ) = sex_male then
9863: LD_VAR 0 2
9867: PPUSH
9868: CALL_OW 258
9872: PUSH
9873: LD_INT 1
9875: EQUAL
9876: IFFALSE 9892
// Say ( kdo2 , D10-Sol1-2 ) else
9878: LD_VAR 0 2
9882: PPUSH
9883: LD_STRING D10-Sol1-2
9885: PPUSH
9886: CALL_OW 88
9890: GO 9904
// Say ( kdo2 , D10-FSol1-2 ) ;
9892: LD_VAR 0 2
9896: PPUSH
9897: LD_STRING D10-FSol1-2
9899: PPUSH
9900: CALL_OW 88
// TalkOff ;
9904: CALL 17045 0 0
// end ; end ;
9908: PPOPN 2
9910: END
// export function Dialog11aa ( kdo ) ; begin
9911: LD_INT 0
9913: PPUSH
// DialogueOn ;
9914: CALL_OW 6
// Say ( kdo , D11a-Sol2-1 ) ;
9918: LD_VAR 0 1
9922: PPUSH
9923: LD_STRING D11a-Sol2-1
9925: PPUSH
9926: CALL_OW 88
// WasD11aa := true ;
9930: LD_ADDR_EXP 69
9934: PUSH
9935: LD_INT 1
9937: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9938: LD_INT 35
9940: PPUSH
9941: CALL_OW 67
// DialogueOff ;
9945: CALL_OW 7
// end ;
9949: LD_VAR 0 2
9953: RET
// export function Dialog11ab ( kdo ) ; begin
9954: LD_INT 0
9956: PPUSH
// DialogueOn ;
9957: CALL_OW 6
// Say ( kdo , D11a-FSol2-1 ) ;
9961: LD_VAR 0 1
9965: PPUSH
9966: LD_STRING D11a-FSol2-1
9968: PPUSH
9969: CALL_OW 88
// WasD11ab := true ;
9973: LD_ADDR_EXP 70
9977: PUSH
9978: LD_INT 1
9980: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9981: LD_INT 35
9983: PPUSH
9984: CALL_OW 67
// DialogueOff ;
9988: CALL_OW 7
// end ;
9992: LD_VAR 0 2
9996: RET
// export function Dialog11b ( kdo ) ; begin
9997: LD_INT 0
9999: PPUSH
// DialogueOn ;
10000: CALL_OW 6
// Say ( kdo , D11b-Sol3-1 ) ;
10004: LD_VAR 0 1
10008: PPUSH
10009: LD_STRING D11b-Sol3-1
10011: PPUSH
10012: CALL_OW 88
// Say ( JMM , D11b-JMM-1 ) ;
10016: LD_EXP 15
10020: PPUSH
10021: LD_STRING D11b-JMM-1
10023: PPUSH
10024: CALL_OW 88
// WasD11b := true ;
10028: LD_ADDR_EXP 71
10032: PUSH
10033: LD_INT 1
10035: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10036: LD_INT 35
10038: PPUSH
10039: CALL_OW 67
// DialogueOff ;
10043: CALL_OW 7
// end ;
10047: LD_VAR 0 2
10051: RET
// export function Dialog11c ( kdo ) ; var dep ; begin
10052: LD_INT 0
10054: PPUSH
10055: PPUSH
// DialogueOn ;
10056: CALL_OW 6
// Say ( kdo , D11c-FSol3-1 ) ;
10060: LD_VAR 0 1
10064: PPUSH
10065: LD_STRING D11c-FSol3-1
10067: PPUSH
10068: CALL_OW 88
// dep := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
10072: LD_ADDR_VAR 0 3
10076: PUSH
10077: LD_INT 22
10079: PUSH
10080: LD_EXP 1
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PUSH
10089: LD_INT 2
10091: PUSH
10092: LD_INT 30
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 30
10104: PUSH
10105: LD_INT 0
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: LIST
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 69
10125: ST_TO_ADDR
// if dep then
10126: LD_VAR 0 3
10130: IFFALSE 10168
// if GetDistUnits ( kdo , dep [ 1 ] ) > 30 then
10132: LD_VAR 0 1
10136: PPUSH
10137: LD_VAR 0 3
10141: PUSH
10142: LD_INT 1
10144: ARRAY
10145: PPUSH
10146: CALL_OW 296
10150: PUSH
10151: LD_INT 30
10153: GREATER
10154: IFFALSE 10168
// Say ( JMM , D11c-JMM-1 ) ;
10156: LD_EXP 15
10160: PPUSH
10161: LD_STRING D11c-JMM-1
10163: PPUSH
10164: CALL_OW 88
// WasD11c := true ;
10168: LD_ADDR_EXP 72
10172: PUSH
10173: LD_INT 1
10175: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10176: LD_INT 35
10178: PPUSH
10179: CALL_OW 67
// DialogueOff ;
10183: CALL_OW 7
// end ;
10187: LD_VAR 0 2
10191: RET
// export function Dialog11d ( kdo ) ; begin
10192: LD_INT 0
10194: PPUSH
// DialogueOn ;
10195: CALL_OW 6
// Say ( kdo , D11d-Sol4-1 ) ;
10199: LD_VAR 0 1
10203: PPUSH
10204: LD_STRING D11d-Sol4-1
10206: PPUSH
10207: CALL_OW 88
// Say ( JMM , D11d-JMM-1 ) ;
10211: LD_EXP 15
10215: PPUSH
10216: LD_STRING D11d-JMM-1
10218: PPUSH
10219: CALL_OW 88
// WasD11d := true ;
10223: LD_ADDR_EXP 73
10227: PUSH
10228: LD_INT 1
10230: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10231: LD_INT 35
10233: PPUSH
10234: CALL_OW 67
// DialogueOff ;
10238: CALL_OW 7
// end ;
10242: LD_VAR 0 2
10246: RET
// export function Dialog11e ( kdo ) ; begin
10247: LD_INT 0
10249: PPUSH
// DialogueOn ;
10250: CALL_OW 6
// Say ( kdo , D11e-FSol4-1 ) ;
10254: LD_VAR 0 1
10258: PPUSH
10259: LD_STRING D11e-FSol4-1
10261: PPUSH
10262: CALL_OW 88
// WasD11e := true ;
10266: LD_ADDR_EXP 74
10270: PUSH
10271: LD_INT 1
10273: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10274: LD_INT 35
10276: PPUSH
10277: CALL_OW 67
// DialogueOff ;
10281: CALL_OW 7
// end ;
10285: LD_VAR 0 2
10289: RET
// export function Dialog11f ( kdo ) ; begin
10290: LD_INT 0
10292: PPUSH
// DialogueOn ;
10293: CALL_OW 6
// Say ( kdo , D11f-Sol5-1 ) ;
10297: LD_VAR 0 1
10301: PPUSH
10302: LD_STRING D11f-Sol5-1
10304: PPUSH
10305: CALL_OW 88
// WasD11f := true ;
10309: LD_ADDR_EXP 75
10313: PUSH
10314: LD_INT 1
10316: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10317: LD_INT 35
10319: PPUSH
10320: CALL_OW 67
// DialogueOff ;
10324: CALL_OW 7
// end ;
10328: LD_VAR 0 2
10332: RET
// every 0 0$3 trigger FilterAllUnits ( [ [ f_control , control_remote ] ] ) and not FilterAllUnits ( [ [ f_btype , b_control_tower ] ] ) do var a ;
10333: LD_INT 33
10335: PUSH
10336: LD_INT 2
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PUSH
10343: EMPTY
10344: LIST
10345: PPUSH
10346: CALL_OW 69
10350: PUSH
10351: LD_INT 30
10353: PUSH
10354: LD_INT 36
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: PUSH
10361: EMPTY
10362: LIST
10363: PPUSH
10364: CALL_OW 69
10368: NOT
10369: AND
10370: IFFALSE 10483
10372: GO 10374
10374: DISABLE
10375: LD_INT 0
10377: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10378: LD_ADDR_VAR 0 1
10382: PUSH
10383: LD_EXP 11
10387: PPUSH
10388: LD_EXP 1
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: LD_INT 3
10398: PPUSH
10399: LD_INT 0
10401: PPUSH
10402: CALL 17141 0 5
10406: ST_TO_ADDR
// TalkOn ;
10407: CALL 17029 0 0
// if a then
10411: LD_VAR 0 1
10415: IFFALSE 10472
// if not SayAny ( a , D3a-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10417: LD_VAR 0 1
10421: PPUSH
10422: LD_STRING D3a-Mech1-1
10424: PPUSH
10425: LD_EXP 1
10429: PPUSH
10430: LD_INT 1
10432: PPUSH
10433: LD_INT 3
10435: PPUSH
10436: LD_INT 0
10438: PPUSH
10439: CALL 17061 0 6
10443: NOT
10444: IFFALSE 10472
// SayAny ( a , D3a-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10446: LD_VAR 0 1
10450: PPUSH
10451: LD_STRING D3a-FMech1-1
10453: PPUSH
10454: LD_EXP 1
10458: PPUSH
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 3
10464: PPUSH
10465: LD_INT 0
10467: PPUSH
10468: CALL 17061 0 6
// TalkOff ;
10472: CALL 17045 0 0
// MyHint ( Linking ) ;
10476: LD_STRING Linking
10478: PPUSH
10479: CALL 17504 0 1
// end ;
10483: PPOPN 1
10485: END
// every 0 0$3 trigger not FilterAllUnits ( [ f_control , control_remote ] ) and maj_ct do var a ;
10486: LD_INT 33
10488: PUSH
10489: LD_INT 2
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: PPUSH
10496: CALL_OW 69
10500: NOT
10501: PUSH
10502: LD_EXP 94
10506: AND
10507: IFFALSE 10620
10509: GO 10511
10511: DISABLE
10512: LD_INT 0
10514: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10515: LD_ADDR_VAR 0 1
10519: PUSH
10520: LD_EXP 11
10524: PPUSH
10525: LD_EXP 1
10529: PPUSH
10530: LD_INT 0
10532: PPUSH
10533: LD_INT 3
10535: PPUSH
10536: LD_INT 0
10538: PPUSH
10539: CALL 17141 0 5
10543: ST_TO_ADDR
// TalkOn ;
10544: CALL 17029 0 0
// if a then
10548: LD_VAR 0 1
10552: IFFALSE 10609
// if not SayAny ( a , D3b-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10554: LD_VAR 0 1
10558: PPUSH
10559: LD_STRING D3b-Mech1-1
10561: PPUSH
10562: LD_EXP 1
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: LD_INT 3
10572: PPUSH
10573: LD_INT 0
10575: PPUSH
10576: CALL 17061 0 6
10580: NOT
10581: IFFALSE 10609
// SayAny ( a , D3b-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_STRING D3b-FMech1-1
10590: PPUSH
10591: LD_EXP 1
10595: PPUSH
10596: LD_INT 2
10598: PPUSH
10599: LD_INT 3
10601: PPUSH
10602: LD_INT 0
10604: PPUSH
10605: CALL 17061 0 6
// TalkOff ;
10609: CALL 17045 0 0
// MyHint ( Linking ) ;
10613: LD_STRING Linking
10615: PPUSH
10616: CALL 17504 0 1
// end ;
10620: PPOPN 1
10622: END
// every 0 0$3 do var who , i ;
10623: GO 10625
10625: DISABLE
10626: LD_INT 0
10628: PPUSH
10629: PPUSH
// begin who := [ ] ;
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: EMPTY
10636: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_btype , b_control_tower ] ) do
10637: LD_ADDR_VAR 0 2
10641: PUSH
10642: LD_INT 30
10644: PUSH
10645: LD_INT 36
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PPUSH
10652: CALL_OW 69
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10698
// who := who ^ UnitFilter ( UnitsInside ( i ) , [ f_class , class_mechanic ] ) ;
10660: LD_ADDR_VAR 0 1
10664: PUSH
10665: LD_VAR 0 1
10669: PUSH
10670: LD_VAR 0 2
10674: PPUSH
10675: CALL_OW 313
10679: PPUSH
10680: LD_INT 25
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: EMPTY
10687: LIST
10688: LIST
10689: PPUSH
10690: CALL_OW 72
10694: ADD
10695: ST_TO_ADDR
10696: GO 10657
10698: POP
10699: POP
// if FilterAllUnits ( [ f_control , control_remote ] ) and who then
10700: LD_INT 33
10702: PUSH
10703: LD_INT 2
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PPUSH
10710: CALL_OW 69
10714: PUSH
10715: LD_VAR 0 1
10719: AND
10720: IFFALSE 10832
// begin TalkOn ;
10722: CALL 17029 0 0
// who := who [ 1 ] ;
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_VAR 0 1
10735: PUSH
10736: LD_INT 1
10738: ARRAY
10739: ST_TO_ADDR
// if JMM in who then
10740: LD_EXP 15
10744: PUSH
10745: LD_VAR 0 1
10749: IN
10750: IFFALSE 10766
// Say ( JMM , D4a-JMM-1 ) else
10752: LD_EXP 15
10756: PPUSH
10757: LD_STRING D4a-JMM-1
10759: PPUSH
10760: CALL_OW 88
10764: GO 10811
// begin if GetSex ( who [ 1 ] ) = sex_male then
10766: LD_VAR 0 1
10770: PUSH
10771: LD_INT 1
10773: ARRAY
10774: PPUSH
10775: CALL_OW 258
10779: PUSH
10780: LD_INT 1
10782: EQUAL
10783: IFFALSE 10799
// Say ( who , D4a-Mech1-1 ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_STRING D4a-Mech1-1
10792: PPUSH
10793: CALL_OW 88
10797: GO 10811
// Say ( who , D4a-FMech1-1 ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_STRING D4a-FMech1-1
10806: PPUSH
10807: CALL_OW 88
// end ; remote_tried := true ;
10811: LD_ADDR_EXP 82
10815: PUSH
10816: LD_INT 1
10818: ST_TO_ADDR
// TalkOff ;
10819: CALL 17045 0 0
// MyHint ( Linking ) ;
10823: LD_STRING Linking
10825: PPUSH
10826: CALL 17504 0 1
// end else
10830: GO 10833
// enable ;
10832: ENABLE
// end ;
10833: PPOPN 2
10835: END
// every 0 0$3 do var who , facts , rems , ok , i , j ;
10836: GO 10838
10838: DISABLE
10839: LD_INT 0
10841: PPUSH
10842: PPUSH
10843: PPUSH
10844: PPUSH
10845: PPUSH
10846: PPUSH
// begin who := [ ] ;
10847: LD_ADDR_VAR 0 1
10851: PUSH
10852: EMPTY
10853: ST_TO_ADDR
// facts := FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_factory ] ] ) ;
10854: LD_ADDR_VAR 0 2
10858: PUSH
10859: LD_INT 22
10861: PUSH
10862: LD_EXP 1
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 30
10873: PUSH
10874: LD_INT 3
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 69
10889: ST_TO_ADDR
// rems := FilterAllUnits ( [ f_control , control_remote ] ) ;
10890: LD_ADDR_VAR 0 3
10894: PUSH
10895: LD_INT 33
10897: PUSH
10898: LD_INT 2
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: PPUSH
10905: CALL_OW 69
10909: ST_TO_ADDR
// for i in facts do
10910: LD_ADDR_VAR 0 5
10914: PUSH
10915: LD_VAR 0 2
10919: PUSH
10920: FOR_IN
10921: IFFALSE 10972
// for j in rems do
10923: LD_ADDR_VAR 0 6
10927: PUSH
10928: LD_VAR 0 3
10932: PUSH
10933: FOR_IN
10934: IFFALSE 10968
// if GetDistUnits ( i , j ) > 9 then
10936: LD_VAR 0 5
10940: PPUSH
10941: LD_VAR 0 6
10945: PPUSH
10946: CALL_OW 296
10950: PUSH
10951: LD_INT 9
10953: GREATER
10954: IFFALSE 10966
// ok := j ;
10956: LD_ADDR_VAR 0 4
10960: PUSH
10961: LD_VAR 0 6
10965: ST_TO_ADDR
10966: GO 10933
10968: POP
10969: POP
10970: GO 10920
10972: POP
10973: POP
// if ok then
10974: LD_VAR 0 4
10978: IFFALSE 11083
// begin TalkOn ;
10980: CALL 17029 0 0
// who := IsControledBy ( ok ) ;
10984: LD_ADDR_VAR 0 1
10988: PUSH
10989: LD_VAR 0 4
10993: PPUSH
10994: CALL_OW 312
10998: ST_TO_ADDR
// if JMM in who then
10999: LD_EXP 15
11003: PUSH
11004: LD_VAR 0 1
11008: IN
11009: IFFALSE 11025
// Say ( JMM , D4b-JMM-1 ) else
11011: LD_EXP 15
11015: PPUSH
11016: LD_STRING D4b-JMM-1
11018: PPUSH
11019: CALL_OW 88
11023: GO 11070
// begin if GetSex ( who [ 1 ] ) = sex_male then
11025: LD_VAR 0 1
11029: PUSH
11030: LD_INT 1
11032: ARRAY
11033: PPUSH
11034: CALL_OW 258
11038: PUSH
11039: LD_INT 1
11041: EQUAL
11042: IFFALSE 11058
// Say ( who , D4b-Mech1-1 ) else
11044: LD_VAR 0 1
11048: PPUSH
11049: LD_STRING D4b-Mech1-1
11051: PPUSH
11052: CALL_OW 88
11056: GO 11070
// Say ( who , D4b-FMech1-1 ) ;
11058: LD_VAR 0 1
11062: PPUSH
11063: LD_STRING D4b-FMech1-1
11065: PPUSH
11066: CALL_OW 88
// end ; TalkOff ;
11070: CALL 17045 0 0
// MyHint ( RemoteControlling ) ;
11074: LD_STRING RemoteControlling
11076: PPUSH
11077: CALL 17504 0 1
// end else
11081: GO 11084
// enable ;
11083: ENABLE
// end ;
11084: PPOPN 6
11086: END
// every 4 4$30 do
11087: GO 11089
11089: DISABLE
// begin TalkOn ;
11090: CALL 17029 0 0
// SayRadio ( RadioSci , D12a-Sci-1 ) ;
11094: LD_EXP 17
11098: PPUSH
11099: LD_STRING D12a-Sci-1
11101: PPUSH
11102: CALL_OW 94
// Say ( JMM , D12a-JMM-1 ) ;
11106: LD_EXP 15
11110: PPUSH
11111: LD_STRING D12a-JMM-1
11113: PPUSH
11114: CALL_OW 88
// TalkOff ;
11118: CALL 17045 0 0
// end ;
11122: END
// every 14 14$0 do
11123: GO 11125
11125: DISABLE
// begin TalkOn ;
11126: CALL 17029 0 0
// SayRadio ( RadioSci , D12b-Sci-1 ) ;
11130: LD_EXP 17
11134: PPUSH
11135: LD_STRING D12b-Sci-1
11137: PPUSH
11138: CALL_OW 94
// TalkOff ;
11142: CALL 17045 0 0
// end ;
11146: END
// every 16 16$0 do
11147: GO 11149
11149: DISABLE
// begin TalkOn ;
11150: CALL 17029 0 0
// SayRadio ( RadioSci , D12c-Sci-1 ) ;
11154: LD_EXP 17
11158: PPUSH
11159: LD_STRING D12c-Sci-1
11161: PPUSH
11162: CALL_OW 94
// TalkOff ;
11166: CALL 17045 0 0
// end ;
11170: END
// every 34 34$0 do
11171: GO 11173
11173: DISABLE
// begin TalkOn ;
11174: CALL 17029 0 0
// SayRadio ( RadioSci , D12d-Sci-1 ) ;
11178: LD_EXP 17
11182: PPUSH
11183: LD_STRING D12d-Sci-1
11185: PPUSH
11186: CALL_OW 94
// TalkOff ;
11190: CALL 17045 0 0
// end ;
11194: END
// every 46 46$0 do
11195: GO 11197
11197: DISABLE
// begin TalkOn ;
11198: CALL 17029 0 0
// SayRadio ( RadioSci , D12e-Sci-1 ) ;
11202: LD_EXP 17
11206: PPUSH
11207: LD_STRING D12e-Sci-1
11209: PPUSH
11210: CALL_OW 94
// Say ( JMM , D12e-JMM-1 ) ;
11214: LD_EXP 15
11218: PPUSH
11219: LD_STRING D12e-JMM-1
11221: PPUSH
11222: CALL_OW 88
// TalkOff ;
11226: CALL 17045 0 0
// end ;
11230: END
// on DestinationUnreachable ( unit ) do begin if unit = Kurt then
11231: LD_VAR 0 1
11235: PUSH
11236: LD_EXP 43
11240: EQUAL
11241: IFFALSE 11255
// begin ComMoveToArea ( Kurt , border ) ;
11243: LD_EXP 43
11247: PPUSH
11248: LD_INT 10
11250: PPUSH
11251: CALL_OW 113
// end ; end ; end_of_file
11255: PPOPN 1
11257: END
// var objevovani_zasilek ; every 0 0$0.1 do
11258: GO 11260
11260: DISABLE
// begin objevovani_zasilek := [ [ 4 , 3 , 7 , 2 , 0 , 2 , 5 , 3 , 1 , 1 ] , [ 4 , 4 , 8 , 2 , 0 , 2 , 5 , 4 , 2 , 1 ] , [ 4 , 3 , 8 , 1 , 0 , 2 , 6 , 5 , 3 , 1 ] ] [ difficulty ] ;
11261: LD_ADDR_LOC 1
11265: PUSH
11266: LD_INT 4
11268: PUSH
11269: LD_INT 3
11271: PUSH
11272: LD_INT 7
11274: PUSH
11275: LD_INT 2
11277: PUSH
11278: LD_INT 0
11280: PUSH
11281: LD_INT 2
11283: PUSH
11284: LD_INT 5
11286: PUSH
11287: LD_INT 3
11289: PUSH
11290: LD_INT 1
11292: PUSH
11293: LD_INT 1
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PUSH
11308: LD_INT 4
11310: PUSH
11311: LD_INT 4
11313: PUSH
11314: LD_INT 8
11316: PUSH
11317: LD_INT 2
11319: PUSH
11320: LD_INT 0
11322: PUSH
11323: LD_INT 2
11325: PUSH
11326: LD_INT 5
11328: PUSH
11329: LD_INT 4
11331: PUSH
11332: LD_INT 2
11334: PUSH
11335: LD_INT 1
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 4
11352: PUSH
11353: LD_INT 3
11355: PUSH
11356: LD_INT 8
11358: PUSH
11359: LD_INT 1
11361: PUSH
11362: LD_INT 0
11364: PUSH
11365: LD_INT 2
11367: PUSH
11368: LD_INT 6
11370: PUSH
11371: LD_INT 5
11373: PUSH
11374: LD_INT 3
11376: PUSH
11377: LD_INT 1
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: LIST
11396: PUSH
11397: LD_OWVAR 67
11401: ARRAY
11402: ST_TO_ADDR
// Randomize ;
11403: CALL_OW 10
// end ;
11407: END
// every 0 0$10 do
11408: GO 11410
11410: DISABLE
// begin Randomize ;
11411: CALL_OW 10
// enable ;
11415: ENABLE
// end ;
11416: END
// every 0 0$1 trigger start_game do
11417: LD_EXP 55
11421: IFFALSE 11465
11423: GO 11425
11425: DISABLE
// begin Wait ( Rand ( 0 0$10 , 0 0$25 ) ) ;
11426: LD_INT 350
11428: PPUSH
11429: LD_INT 875
11431: PPUSH
11432: CALL_OW 12
11436: PPUSH
11437: CALL_OW 67
// CreateCratesArea ( 5 , first_crate , true ) ;
11441: LD_INT 5
11443: PPUSH
11444: LD_INT 3
11446: PPUSH
11447: LD_INT 1
11449: PPUSH
11450: CALL_OW 55
// wait ( 0 0$5 ) ;
11454: LD_INT 175
11456: PPUSH
11457: CALL_OW 67
// DialogR0 ;
11461: CALL 5768 0 0
// end ;
11465: END
// every 0 0$15 do
11466: GO 11468
11468: DISABLE
// begin bum_bedny ;
11469: CALL 11483 0 0
// end ;
11473: END
// every 5 5$0 + 0 0$20 marked 567 do
11474: GO 11476
11476: DISABLE
// begin enable ;
11477: ENABLE
// bum_bedny ;
11478: CALL 11483 0 0
// end ;
11482: END
// function bum_bedny ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
11483: LD_INT 0
11485: PPUSH
11486: PPUSH
11487: PPUSH
11488: PPUSH
11489: PPUSH
11490: PPUSH
11491: PPUSH
11492: PPUSH
11493: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
11494: LD_ADDR_VAR 0 9
11498: PUSH
11499: LD_OWVAR 1
11503: PUSH
11504: LD_INT 10500
11506: DIV
11507: PUSH
11508: LD_INT 1
11510: PLUS
11511: ST_TO_ADDR
// cek := [ ] ;
11512: LD_ADDR_VAR 0 6
11516: PUSH
11517: EMPTY
11518: ST_TO_ADDR
// cek2 := [ ] ;
11519: LD_ADDR_VAR 0 7
11523: PUSH
11524: EMPTY
11525: ST_TO_ADDR
// last := 0 ;
11526: LD_ADDR_VAR 0 8
11530: PUSH
11531: LD_INT 0
11533: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
11534: LD_ADDR_VAR 0 2
11538: PUSH
11539: LD_LOC 1
11543: PUSH
11544: LD_VAR 0 9
11548: ARRAY
11549: ST_TO_ADDR
// for i := 1 to x * 2 do
11550: LD_ADDR_VAR 0 4
11554: PUSH
11555: DOUBLE
11556: LD_INT 1
11558: DEC
11559: ST_TO_ADDR
11560: LD_VAR 0 2
11564: PUSH
11565: LD_INT 2
11567: MUL
11568: PUSH
11569: FOR_TO
11570: IFFALSE 11596
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
11572: LD_ADDR_VAR 0 6
11576: PUSH
11577: LD_VAR 0 6
11581: PUSH
11582: LD_INT 525
11584: PPUSH
11585: LD_INT 10500
11587: PPUSH
11588: CALL_OW 12
11592: ADD
11593: ST_TO_ADDR
11594: GO 11569
11596: POP
11597: POP
// cek := SortListByListAsc ( cek , cek ) ;
11598: LD_ADDR_VAR 0 6
11602: PUSH
11603: LD_VAR 0 6
11607: PPUSH
11608: LD_VAR 0 6
11612: PPUSH
11613: CALL_OW 76
11617: ST_TO_ADDR
// for i in cek do
11618: LD_ADDR_VAR 0 4
11622: PUSH
11623: LD_VAR 0 6
11627: PUSH
11628: FOR_IN
11629: IFFALSE 11665
// begin cek2 := cek2 ^ i - last ;
11631: LD_ADDR_VAR 0 7
11635: PUSH
11636: LD_VAR 0 7
11640: PUSH
11641: LD_VAR 0 4
11645: PUSH
11646: LD_VAR 0 8
11650: MINUS
11651: ADD
11652: ST_TO_ADDR
// last := i ;
11653: LD_ADDR_VAR 0 8
11657: PUSH
11658: LD_VAR 0 4
11662: ST_TO_ADDR
// end ;
11663: GO 11628
11665: POP
11666: POP
// for i := 1 to x do
11667: LD_ADDR_VAR 0 4
11671: PUSH
11672: DOUBLE
11673: LD_INT 1
11675: DEC
11676: ST_TO_ADDR
11677: LD_VAR 0 2
11681: PUSH
11682: FOR_TO
11683: IFFALSE 11912
// begin hex := RandHexArea ( bottom_bigger , false ) ;
11685: LD_ADDR_VAR 0 5
11689: PUSH
11690: LD_INT 8
11692: PPUSH
11693: LD_INT 0
11695: PPUSH
11696: CALL_OW 16
11700: ST_TO_ADDR
// crates := crates ^ [ hex ] ;
11701: LD_ADDR_EXP 76
11705: PUSH
11706: LD_EXP 76
11710: PUSH
11711: LD_VAR 0 5
11715: PUSH
11716: EMPTY
11717: LIST
11718: ADD
11719: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11720: LD_INT 5
11722: PPUSH
11723: LD_VAR 0 5
11727: PUSH
11728: LD_INT 1
11730: ARRAY
11731: PPUSH
11732: LD_VAR 0 5
11736: PUSH
11737: LD_INT 2
11739: ARRAY
11740: PPUSH
11741: LD_INT 1
11743: PPUSH
11744: CALL_OW 54
// Wait ( cek2 [ i * 2 - 1 ] ) ;
11748: LD_VAR 0 7
11752: PUSH
11753: LD_VAR 0 4
11757: PUSH
11758: LD_INT 2
11760: MUL
11761: PUSH
11762: LD_INT 1
11764: MINUS
11765: ARRAY
11766: PPUSH
11767: CALL_OW 67
// hex := RandHexArea ( top_bigger , false ) ;
11771: LD_ADDR_VAR 0 5
11775: PUSH
11776: LD_INT 7
11778: PPUSH
11779: LD_INT 0
11781: PPUSH
11782: CALL_OW 16
11786: ST_TO_ADDR
// if more_scouting then
11787: LD_EXP 61
11791: IFFALSE 11812
// crates := crates ^ [ hex ] ;
11793: LD_ADDR_EXP 76
11797: PUSH
11798: LD_EXP 76
11802: PUSH
11803: LD_VAR 0 5
11807: PUSH
11808: EMPTY
11809: LIST
11810: ADD
11811: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11812: LD_INT 5
11814: PPUSH
11815: LD_VAR 0 5
11819: PUSH
11820: LD_INT 1
11822: ARRAY
11823: PPUSH
11824: LD_VAR 0 5
11828: PUSH
11829: LD_INT 2
11831: ARRAY
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: CALL_OW 54
// if not was_dialogR0 and GetDistUnitXY ( JMM , hex [ 1 ] , hex [ 2 ] ) > 30 then
11840: LD_EXP 87
11844: NOT
11845: PUSH
11846: LD_EXP 15
11850: PPUSH
11851: LD_VAR 0 5
11855: PUSH
11856: LD_INT 1
11858: ARRAY
11859: PPUSH
11860: LD_VAR 0 5
11864: PUSH
11865: LD_INT 2
11867: ARRAY
11868: PPUSH
11869: CALL_OW 297
11873: PUSH
11874: LD_INT 30
11876: GREATER
11877: AND
11878: IFFALSE 11891
// begin wait ( 0 0$6 ) ;
11880: LD_INT 210
11882: PPUSH
11883: CALL_OW 67
// DialogR0 ;
11887: CALL 5768 0 0
// end ; Wait ( cek2 [ i * 2 ] ) ;
11891: LD_VAR 0 7
11895: PUSH
11896: LD_VAR 0 4
11900: PUSH
11901: LD_INT 2
11903: MUL
11904: ARRAY
11905: PPUSH
11906: CALL_OW 67
// end ;
11910: GO 11682
11912: POP
11913: POP
// if min5 = ( objevovani_zasilek + 0 ) then
11914: LD_VAR 0 9
11918: PUSH
11919: LD_LOC 1
11923: PUSH
11924: LD_INT 0
11926: PLUS
11927: EQUAL
11928: IFFALSE 11933
// disable ( 567 ) ;
11930: LD_INT 567
11932: DISABLE_MARKED
// end ;
11933: LD_VAR 0 1
11937: RET
// every 5 5$0 + 5 5$20 trigger start_game do var a , un , counter , h ;
11938: LD_EXP 55
11942: IFFALSE 12753
11944: GO 11946
11946: DISABLE
11947: LD_INT 0
11949: PPUSH
11950: PPUSH
11951: PPUSH
11952: PPUSH
// begin a := prilet_rusaci union prilet_tvoji ;
11953: LD_ADDR_VAR 0 1
11957: PUSH
11958: LD_EXP 7
11962: PUSH
11963: LD_EXP 6
11967: UNION
11968: ST_TO_ADDR
// if a then
11969: LD_VAR 0 1
11973: IFFALSE 12753
// begin un := a [ Rand ( 1 , ( a + 0 ) ) ] ;
11975: LD_ADDR_VAR 0 2
11979: PUSH
11980: LD_VAR 0 1
11984: PUSH
11985: LD_INT 1
11987: PPUSH
11988: LD_VAR 0 1
11992: PUSH
11993: LD_INT 0
11995: PLUS
11996: PPUSH
11997: CALL_OW 12
12001: ARRAY
12002: ST_TO_ADDR
// if prilet_tvoji = 2 and Getside ( un ) = you then
12003: LD_EXP 6
12007: PUSH
12008: LD_INT 2
12010: EQUAL
12011: PUSH
12012: LD_VAR 0 2
12016: PPUSH
12017: CALL_OW 255
12021: PUSH
12022: LD_EXP 1
12026: EQUAL
12027: AND
12028: IFFALSE 12047
// begin PlaceUnitArea ( un , lidi_base , true ) ;
12030: LD_VAR 0 2
12034: PPUSH
12035: LD_INT 15
12037: PPUSH
12038: LD_INT 1
12040: PPUSH
12041: CALL_OW 49
// end else
12045: GO 12375
// begin if Rand ( 1 , 2 ) = 1 then
12047: LD_INT 1
12049: PPUSH
12050: LD_INT 2
12052: PPUSH
12053: CALL_OW 12
12057: PUSH
12058: LD_INT 1
12060: EQUAL
12061: IFFALSE 12220
// begin counter := 0 ;
12063: LD_ADDR_VAR 0 3
12067: PUSH
12068: LD_INT 0
12070: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_bottom , false ) ;
12071: LD_ADDR_VAR 0 4
12075: PUSH
12076: LD_INT 14
12078: PPUSH
12079: LD_INT 0
12081: PPUSH
12082: CALL_OW 16
12086: ST_TO_ADDR
// counter := counter + 1 ;
12087: LD_ADDR_VAR 0 3
12091: PUSH
12092: LD_VAR 0 3
12096: PUSH
12097: LD_INT 1
12099: PLUS
12100: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12101: LD_VAR 0 2
12105: PPUSH
12106: CALL_OW 255
12110: PUSH
12111: LD_EXP 2
12115: EQUAL
12116: PUSH
12117: LD_VAR 0 3
12121: PUSH
12122: LD_INT 200
12124: GREATER
12125: OR
12126: PUSH
12127: LD_EXP 2
12131: PPUSH
12132: LD_VAR 0 4
12136: PUSH
12137: LD_INT 1
12139: ARRAY
12140: PPUSH
12141: LD_VAR 0 4
12145: PUSH
12146: LD_INT 2
12148: ARRAY
12149: PPUSH
12150: CALL_OW 293
12154: NOT
12155: OR
12156: IFFALSE 12071
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12158: LD_VAR 0 2
12162: PPUSH
12163: LD_VAR 0 4
12167: PUSH
12168: LD_INT 1
12170: ARRAY
12171: PPUSH
12172: LD_VAR 0 4
12176: PUSH
12177: LD_INT 2
12179: ARRAY
12180: PPUSH
12181: LD_INT 1
12183: PPUSH
12184: CALL_OW 48
12188: PUSH
12189: LD_VAR 0 3
12193: PUSH
12194: LD_INT 200
12196: GREATER
12197: OR
12198: IFFALSE 12071
// if counter > 200 then
12200: LD_VAR 0 3
12204: PUSH
12205: LD_INT 200
12207: GREATER
12208: IFFALSE 12218
// un := 0 ;
12210: LD_ADDR_VAR 0 2
12214: PUSH
12215: LD_INT 0
12217: ST_TO_ADDR
// end else
12218: GO 12375
// begin counter := 0 ;
12220: LD_ADDR_VAR 0 3
12224: PUSH
12225: LD_INT 0
12227: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_top , false ) ;
12228: LD_ADDR_VAR 0 4
12232: PUSH
12233: LD_INT 17
12235: PPUSH
12236: LD_INT 0
12238: PPUSH
12239: CALL_OW 16
12243: ST_TO_ADDR
// counter := counter + 1 ;
12244: LD_ADDR_VAR 0 3
12248: PUSH
12249: LD_VAR 0 3
12253: PUSH
12254: LD_INT 1
12256: PLUS
12257: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12258: LD_VAR 0 2
12262: PPUSH
12263: CALL_OW 255
12267: PUSH
12268: LD_EXP 2
12272: EQUAL
12273: PUSH
12274: LD_VAR 0 3
12278: PUSH
12279: LD_INT 200
12281: GREATER
12282: OR
12283: PUSH
12284: LD_EXP 2
12288: PPUSH
12289: LD_VAR 0 4
12293: PUSH
12294: LD_INT 1
12296: ARRAY
12297: PPUSH
12298: LD_VAR 0 4
12302: PUSH
12303: LD_INT 2
12305: ARRAY
12306: PPUSH
12307: CALL_OW 293
12311: NOT
12312: OR
12313: IFFALSE 12228
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12315: LD_VAR 0 2
12319: PPUSH
12320: LD_VAR 0 4
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 4
12333: PUSH
12334: LD_INT 2
12336: ARRAY
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 48
12345: PUSH
12346: LD_VAR 0 3
12350: PUSH
12351: LD_INT 200
12353: GREATER
12354: OR
12355: IFFALSE 12228
// if counter > 200 then
12357: LD_VAR 0 3
12361: PUSH
12362: LD_INT 200
12364: GREATER
12365: IFFALSE 12375
// un := 0 ;
12367: LD_ADDR_VAR 0 2
12371: PUSH
12372: LD_INT 0
12374: ST_TO_ADDR
// end ; end ; Wait ( 0 0$4 ) ;
12375: LD_INT 140
12377: PPUSH
12378: CALL_OW 67
// if un in prilet_rusaci then
12382: LD_VAR 0 2
12386: PUSH
12387: LD_EXP 7
12391: IN
12392: IFFALSE 12556
// begin prilet_rusaci := prilet_rusaci diff un ;
12394: LD_ADDR_EXP 7
12398: PUSH
12399: LD_EXP 7
12403: PUSH
12404: LD_VAR 0 2
12408: DIFF
12409: ST_TO_ADDR
// ComWait ( un , 0 0$3 ) ;
12410: LD_VAR 0 2
12414: PPUSH
12415: LD_INT 105
12417: PPUSH
12418: CALL_OW 142
// AddComMoveXY ( un , 122 , 84 ) ;
12422: LD_VAR 0 2
12426: PPUSH
12427: LD_INT 122
12429: PPUSH
12430: LD_INT 84
12432: PPUSH
12433: CALL_OW 171
// case GetClass ( un ) of class_soldier :
12437: LD_VAR 0 2
12441: PPUSH
12442: CALL_OW 257
12446: PUSH
12447: LD_INT 1
12449: DOUBLE
12450: EQUAL
12451: IFTRUE 12455
12453: GO 12474
12455: POP
// sol := sol ^ un ; class_engineer :
12456: LD_ADDR_EXP 90
12460: PUSH
12461: LD_EXP 90
12465: PUSH
12466: LD_VAR 0 2
12470: ADD
12471: ST_TO_ADDR
12472: GO 12556
12474: LD_INT 2
12476: DOUBLE
12477: EQUAL
12478: IFTRUE 12482
12480: GO 12501
12482: POP
// eng := eng ^ un ; class_scientistic :
12483: LD_ADDR_EXP 93
12487: PUSH
12488: LD_EXP 93
12492: PUSH
12493: LD_VAR 0 2
12497: ADD
12498: ST_TO_ADDR
12499: GO 12556
12501: LD_INT 4
12503: DOUBLE
12504: EQUAL
12505: IFTRUE 12509
12507: GO 12528
12509: POP
// sci := sci ^ un ; class_mechanic :
12510: LD_ADDR_EXP 91
12514: PUSH
12515: LD_EXP 91
12519: PUSH
12520: LD_VAR 0 2
12524: ADD
12525: ST_TO_ADDR
12526: GO 12556
12528: LD_INT 3
12530: DOUBLE
12531: EQUAL
12532: IFTRUE 12536
12534: GO 12555
12536: POP
// mec := mec ^ un ; end ;
12537: LD_ADDR_EXP 92
12541: PUSH
12542: LD_EXP 92
12546: PUSH
12547: LD_VAR 0 2
12551: ADD
12552: ST_TO_ADDR
12553: GO 12556
12555: POP
// end ; if un in prilet_tvoji then
12556: LD_VAR 0 2
12560: PUSH
12561: LD_EXP 6
12565: IN
12566: IFFALSE 12752
// begin prilet_tvoji := prilet_tvoji diff un ;
12568: LD_ADDR_EXP 6
12572: PUSH
12573: LD_EXP 6
12577: PUSH
12578: LD_VAR 0 2
12582: DIFF
12583: ST_TO_ADDR
// if IsInArea ( un , base ) then
12584: LD_VAR 0 2
12588: PPUSH
12589: LD_INT 5
12591: PPUSH
12592: CALL_OW 308
12596: IFFALSE 12649
// begin if GetSex ( un ) = sex_male then
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 258
12607: PUSH
12608: LD_INT 1
12610: EQUAL
12611: IFFALSE 12647
// if not WasD11aa then
12613: LD_EXP 69
12617: NOT
12618: IFFALSE 12631
// Dialog11aa ( un ) else
12620: LD_VAR 0 2
12624: PPUSH
12625: CALL 9911 0 1
12629: GO 12647
// if not WasD11ab then
12631: LD_EXP 70
12635: NOT
12636: IFFALSE 12647
// Dialog11ab ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL 9954 0 1
// end else
12647: GO 12752
// begin if GetSex ( un ) = sex_female then
12649: LD_VAR 0 2
12653: PPUSH
12654: CALL_OW 258
12658: PUSH
12659: LD_INT 2
12661: EQUAL
12662: IFFALSE 12700
// begin if not WasD11c then
12664: LD_EXP 72
12668: NOT
12669: IFFALSE 12682
// Dialog11c ( un ) else
12671: LD_VAR 0 2
12675: PPUSH
12676: CALL 10052 0 1
12680: GO 12698
// if not WasD11e then
12682: LD_EXP 74
12686: NOT
12687: IFFALSE 12698
// Dialog11e ( un ) ;
12689: LD_VAR 0 2
12693: PPUSH
12694: CALL 10247 0 1
// end else
12698: GO 12752
// begin if not WasD11b then
12700: LD_EXP 71
12704: NOT
12705: IFFALSE 12718
// Dialog11b ( un ) else
12707: LD_VAR 0 2
12711: PPUSH
12712: CALL 9997 0 1
12716: GO 12752
// if not WasD11d then
12718: LD_EXP 73
12722: NOT
12723: IFFALSE 12736
// Dialog11d ( un ) else
12725: LD_VAR 0 2
12729: PPUSH
12730: CALL 10192 0 1
12734: GO 12752
// if not WasD11f then
12736: LD_EXP 75
12740: NOT
12741: IFFALSE 12752
// Dialog11f ( un ) ;
12743: LD_VAR 0 2
12747: PPUSH
12748: CALL 10290 0 1
// end ; end ; end ; enable ;
12752: ENABLE
// end ; end ;
12753: PPOPN 4
12755: END
// every 10 10$0 + 2 2$30 trigger start_game do var a4 , b4 , b5 , c4 , d4 , ia4 , max4 , h ;
12756: LD_EXP 55
12760: IFFALSE 13312
12762: GO 12764
12764: DISABLE
12765: LD_INT 0
12767: PPUSH
12768: PPUSH
12769: PPUSH
12770: PPUSH
12771: PPUSH
12772: PPUSH
12773: PPUSH
12774: PPUSH
// begin ne_v_boji ;
12775: CALL 13315 0 0
// repeat wait ( 0 0$3 ) ;
12779: LD_INT 105
12781: PPUSH
12782: CALL_OW 67
// b4 := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Joan ] ;
12786: LD_ADDR_VAR 0 2
12790: PUSH
12791: LD_INT 22
12793: PUSH
12794: LD_EXP 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 23
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 21
12815: PUSH
12816: LD_INT 1
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: LD_INT 50
12825: PUSH
12826: EMPTY
12827: LIST
12828: PUSH
12829: LD_INT 56
12831: PUSH
12832: EMPTY
12833: LIST
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: PPUSH
12842: CALL_OW 69
12846: PUSH
12847: LD_EXP 15
12851: PUSH
12852: LD_EXP 33
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: DIFF
12861: ST_TO_ADDR
// until b4 and not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , [ f_occupied ] ] , [ f_dist , JMM , 40 ] ] ) ;
12862: LD_VAR 0 2
12866: PUSH
12867: LD_INT 22
12869: PUSH
12870: LD_EXP 2
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: PUSH
12879: LD_INT 2
12881: PUSH
12882: LD_INT 21
12884: PUSH
12885: LD_INT 1
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 21
12894: PUSH
12895: LD_INT 2
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 21
12904: PUSH
12905: LD_INT 3
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 59
12914: PUSH
12915: EMPTY
12916: LIST
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: PUSH
12925: LD_INT 91
12927: PUSH
12928: LD_EXP 15
12932: PUSH
12933: LD_INT 40
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: LIST
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: PPUSH
12946: CALL_OW 69
12950: NOT
12951: AND
12952: IFFALSE 12779
// max4 := 1000 ;
12954: LD_ADDR_VAR 0 7
12958: PUSH
12959: LD_INT 1000
12961: ST_TO_ADDR
// if Rand ( 1 , 5 ) <= 4 then
12962: LD_INT 1
12964: PPUSH
12965: LD_INT 5
12967: PPUSH
12968: CALL_OW 12
12972: PUSH
12973: LD_INT 4
12975: LESSEQUAL
12976: IFFALSE 13057
// begin for ia4 in b4 do
12978: LD_ADDR_VAR 0 6
12982: PUSH
12983: LD_VAR 0 2
12987: PUSH
12988: FOR_IN
12989: IFFALSE 13055
// begin d4 := GetDistUnits ( JMM , ia4 ) ;
12991: LD_ADDR_VAR 0 5
12995: PUSH
12996: LD_EXP 15
13000: PPUSH
13001: LD_VAR 0 6
13005: PPUSH
13006: CALL_OW 296
13010: ST_TO_ADDR
// if d4 > 5 and d4 < max4 then
13011: LD_VAR 0 5
13015: PUSH
13016: LD_INT 5
13018: GREATER
13019: PUSH
13020: LD_VAR 0 5
13024: PUSH
13025: LD_VAR 0 7
13029: LESS
13030: AND
13031: IFFALSE 13053
// begin max4 := d4 ;
13033: LD_ADDR_VAR 0 7
13037: PUSH
13038: LD_VAR 0 5
13042: ST_TO_ADDR
// c4 := ia4 ;
13043: LD_ADDR_VAR 0 4
13047: PUSH
13048: LD_VAR 0 6
13052: ST_TO_ADDR
// end ; end ;
13053: GO 12988
13055: POP
13056: POP
// end ; if max4 > 11 then
13057: LD_VAR 0 7
13061: PUSH
13062: LD_INT 11
13064: GREATER
13065: IFFALSE 13077
// c4 := JMM ;
13067: LD_ADDR_VAR 0 4
13071: PUSH
13072: LD_EXP 15
13076: ST_TO_ADDR
// a4 := 0 ;
13077: LD_ADDR_VAR 0 1
13081: PUSH
13082: LD_INT 0
13084: ST_TO_ADDR
// if not Kurt_P and not Joan_P then
13085: LD_EXP 47
13089: NOT
13090: PUSH
13091: LD_EXP 48
13095: NOT
13096: AND
13097: IFFALSE 13115
// a4 := Rand ( 1 , 2 ) ;
13099: LD_ADDR_VAR 0 1
13103: PUSH
13104: LD_INT 1
13106: PPUSH
13107: LD_INT 2
13109: PPUSH
13110: CALL_OW 12
13114: ST_TO_ADDR
// if ( not Kurt_P and a4 = 0 ) or a4 = 1 then
13115: LD_EXP 47
13119: NOT
13120: PUSH
13121: LD_VAR 0 1
13125: PUSH
13126: LD_INT 0
13128: EQUAL
13129: AND
13130: PUSH
13131: LD_VAR 0 1
13135: PUSH
13136: LD_INT 1
13138: EQUAL
13139: OR
13140: IFFALSE 13216
// begin SetAttitude ( arabians , you , att_friend , true ) ;
13142: LD_EXP 3
13146: PPUSH
13147: LD_EXP 1
13151: PPUSH
13152: LD_INT 1
13154: PPUSH
13155: LD_INT 1
13157: PPUSH
13158: CALL_OW 80
// if PlaceUnitXYR ( Kurt , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13162: LD_EXP 43
13166: PPUSH
13167: LD_VAR 0 4
13171: PPUSH
13172: CALL_OW 250
13176: PPUSH
13177: LD_VAR 0 4
13181: PPUSH
13182: CALL_OW 251
13186: PPUSH
13187: LD_INT 8
13189: PPUSH
13190: LD_INT 1
13192: PPUSH
13193: CALL_OW 50
13197: IFFALSE 13216
// begin Kurt_P := true ;
13199: LD_ADDR_EXP 47
13203: PUSH
13204: LD_INT 1
13206: ST_TO_ADDR
// DialogKurt ( c4 ) ;
13207: LD_VAR 0 4
13211: PPUSH
13212: CALL 6718 0 1
// end ; end ; if ( not Joan_P and a4 = 0 ) or a4 = 2 then
13216: LD_EXP 48
13220: NOT
13221: PUSH
13222: LD_VAR 0 1
13226: PUSH
13227: LD_INT 0
13229: EQUAL
13230: AND
13231: PUSH
13232: LD_VAR 0 1
13236: PUSH
13237: LD_INT 2
13239: EQUAL
13240: OR
13241: IFFALSE 13297
// begin if PlaceUnitXYR ( Joan , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13243: LD_EXP 33
13247: PPUSH
13248: LD_VAR 0 4
13252: PPUSH
13253: CALL_OW 250
13257: PPUSH
13258: LD_VAR 0 4
13262: PPUSH
13263: CALL_OW 251
13267: PPUSH
13268: LD_INT 8
13270: PPUSH
13271: LD_INT 1
13273: PPUSH
13274: CALL_OW 50
13278: IFFALSE 13297
// begin Joan_P := true ;
13280: LD_ADDR_EXP 48
13284: PUSH
13285: LD_INT 1
13287: ST_TO_ADDR
// DialogJoan ( c4 ) ;
13288: LD_VAR 0 4
13292: PPUSH
13293: CALL 8313 0 1
// end ; end ; if not Kurt_P or not Joan_P then
13297: LD_EXP 47
13301: NOT
13302: PUSH
13303: LD_EXP 48
13307: NOT
13308: OR
13309: IFFALSE 13312
// enable ;
13311: ENABLE
// end ; end_of_file
13312: PPOPN 8
13314: END
// export function ne_v_boji ; begin
13315: LD_INT 0
13317: PPUSH
// while bojujese do
13318: CALL 13338 0 0
13322: IFFALSE 13333
// wait ( 0 0$4 ) ;
13324: LD_INT 140
13326: PPUSH
13327: CALL_OW 67
13331: GO 13318
// end ;
13333: LD_VAR 0 1
13337: RET
// export function bojujese ; begin
13338: LD_INT 0
13340: PPUSH
// result := true and not FilterAllUnits ( [ [ f_dist , JMM , 40 ] , [ f_side , russians ] ] ) ;
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: LD_INT 91
13351: PUSH
13352: LD_EXP 15
13356: PUSH
13357: LD_INT 40
13359: PUSH
13360: EMPTY
13361: LIST
13362: LIST
13363: LIST
13364: PUSH
13365: LD_INT 22
13367: PUSH
13368: LD_EXP 2
13372: PUSH
13373: EMPTY
13374: LIST
13375: LIST
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PPUSH
13381: CALL_OW 69
13385: NOT
13386: AND
13387: ST_TO_ADDR
// end ;
13388: LD_VAR 0 1
13392: RET
// export function TvojiLidi ; begin
13393: LD_INT 0
13395: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13396: LD_ADDR_VAR 0 1
13400: PUSH
13401: LD_INT 22
13403: PUSH
13404: LD_EXP 1
13408: PUSH
13409: EMPTY
13410: LIST
13411: LIST
13412: PUSH
13413: LD_INT 21
13415: PUSH
13416: LD_INT 1
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: PPUSH
13427: CALL_OW 69
13431: ST_TO_ADDR
// end ;
13432: LD_VAR 0 1
13436: RET
// export function filter_type_unit ( from_units , human , vehicle , building ) ; var temp1 , temp2 , temp3 ; var un2 ; begin
13437: LD_INT 0
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// if human then
13444: LD_VAR 0 2
13448: IFFALSE 13475
// begin temp1 := UnitFilter ( from_units , [ f_type , unit_human ] ) ;
13450: LD_ADDR_VAR 0 6
13454: PUSH
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_INT 21
13462: PUSH
13463: LD_INT 1
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PPUSH
13470: CALL_OW 72
13474: ST_TO_ADDR
// end ; if vehicle then
13475: LD_VAR 0 3
13479: IFFALSE 13506
// begin temp2 := UnitFilter ( from_units , [ f_type , unit_vehicle ] ) ;
13481: LD_ADDR_VAR 0 7
13485: PUSH
13486: LD_VAR 0 1
13490: PPUSH
13491: LD_INT 21
13493: PUSH
13494: LD_INT 2
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PPUSH
13501: CALL_OW 72
13505: ST_TO_ADDR
// end ; if building then
13506: LD_VAR 0 4
13510: IFFALSE 13537
// begin temp3 := UnitFilter ( from_units , [ f_type , unit_building ] ) ;
13512: LD_ADDR_VAR 0 8
13516: PUSH
13517: LD_VAR 0 1
13521: PPUSH
13522: LD_INT 21
13524: PUSH
13525: LD_INT 3
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 72
13536: ST_TO_ADDR
// end ; temp1 := add ( temp1 , temp2 ) ;
13537: LD_ADDR_VAR 0 6
13541: PUSH
13542: LD_VAR 0 6
13546: PPUSH
13547: LD_VAR 0 7
13551: PPUSH
13552: CALL 17335 0 2
13556: ST_TO_ADDR
// temp1 := add ( temp1 , temp3 ) ;
13557: LD_ADDR_VAR 0 6
13561: PUSH
13562: LD_VAR 0 6
13566: PPUSH
13567: LD_VAR 0 8
13571: PPUSH
13572: CALL 17335 0 2
13576: ST_TO_ADDR
// result := temp1 ;
13577: LD_ADDR_VAR 0 5
13581: PUSH
13582: LD_VAR 0 6
13586: ST_TO_ADDR
// end ;
13587: LD_VAR 0 5
13591: RET
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
13592: LD_INT 0
13594: PPUSH
13595: PPUSH
13596: PPUSH
13597: PPUSH
13598: PPUSH
13599: PPUSH
13600: PPUSH
13601: PPUSH
13602: PPUSH
13603: PPUSH
13604: PPUSH
13605: PPUSH
13606: PPUSH
13607: PPUSH
13608: PPUSH
// for for_unit in for_units do
13609: LD_ADDR_VAR 0 22
13613: PUSH
13614: LD_VAR 0 5
13618: PUSH
13619: FOR_IN
13620: IFFALSE 14142
// begin x := px ;
13622: LD_ADDR_VAR 0 9
13626: PUSH
13627: LD_VAR 0 1
13631: ST_TO_ADDR
// y := py ;
13632: LD_ADDR_VAR 0 10
13636: PUSH
13637: LD_VAR 0 2
13641: ST_TO_ADDR
// lx := px ;
13642: LD_ADDR_VAR 0 13
13646: PUSH
13647: LD_VAR 0 1
13651: ST_TO_ADDR
// ly := py ;
13652: LD_ADDR_VAR 0 14
13656: PUSH
13657: LD_VAR 0 2
13661: ST_TO_ADDR
// for j2 := 1 to hloubka do
13662: LD_ADDR_VAR 0 18
13666: PUSH
13667: DOUBLE
13668: LD_INT 1
13670: DEC
13671: ST_TO_ADDR
13672: LD_VAR 0 3
13676: PUSH
13677: FOR_TO
13678: IFFALSE 14010
// begin howgood := 50000 ;
13680: LD_ADDR_VAR 0 15
13684: PUSH
13685: LD_INT 50000
13687: ST_TO_ADDR
// smer := 0 ;
13688: LD_ADDR_VAR 0 16
13692: PUSH
13693: LD_INT 0
13695: ST_TO_ADDR
// kolem := 0 ;
13696: LD_ADDR_VAR 0 21
13700: PUSH
13701: LD_INT 0
13703: ST_TO_ADDR
// for i2 := 0 to 5 do
13704: LD_ADDR_VAR 0 17
13708: PUSH
13709: DOUBLE
13710: LD_INT 0
13712: DEC
13713: ST_TO_ADDR
13714: LD_INT 5
13716: PUSH
13717: FOR_TO
13718: IFFALSE 13912
// begin x2 := ShiftX ( x , i2 , krok ) ;
13720: LD_ADDR_VAR 0 11
13724: PUSH
13725: LD_VAR 0 9
13729: PPUSH
13730: LD_VAR 0 17
13734: PPUSH
13735: LD_VAR 0 4
13739: PPUSH
13740: CALL_OW 272
13744: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
13745: LD_ADDR_VAR 0 12
13749: PUSH
13750: LD_VAR 0 10
13754: PPUSH
13755: LD_VAR 0 17
13759: PPUSH
13760: LD_VAR 0 4
13764: PPUSH
13765: CALL_OW 273
13769: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
13770: LD_ADDR_VAR 0 20
13774: PUSH
13775: LD_VAR 0 6
13779: PPUSH
13780: LD_VAR 0 11
13784: PPUSH
13785: LD_VAR 0 12
13789: PPUSH
13790: CALL_OW 293
13794: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
13795: LD_VAR 0 20
13799: PUSH
13800: LD_VAR 0 15
13804: LESS
13805: PUSH
13806: LD_VAR 0 1
13810: PPUSH
13811: LD_VAR 0 2
13815: PPUSH
13816: LD_VAR 0 9
13820: PPUSH
13821: LD_VAR 0 10
13825: PPUSH
13826: CALL_OW 298
13830: PUSH
13831: LD_VAR 0 1
13835: PPUSH
13836: LD_VAR 0 2
13840: PPUSH
13841: LD_VAR 0 11
13845: PPUSH
13846: LD_VAR 0 12
13850: PPUSH
13851: CALL_OW 298
13855: LESS
13856: AND
13857: IFFALSE 13894
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
13859: LD_ADDR_VAR 0 15
13863: PUSH
13864: LD_VAR 0 6
13868: PPUSH
13869: LD_VAR 0 11
13873: PPUSH
13874: LD_VAR 0 12
13878: PPUSH
13879: CALL_OW 293
13883: ST_TO_ADDR
// smer := i2 ;
13884: LD_ADDR_VAR 0 16
13888: PUSH
13889: LD_VAR 0 17
13893: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
13894: LD_ADDR_VAR 0 21
13898: PUSH
13899: LD_VAR 0 21
13903: PUSH
13904: LD_VAR 0 20
13908: PLUS
13909: ST_TO_ADDR
// end ;
13910: GO 13717
13912: POP
13913: POP
// x := ShiftX ( x , smer , krok ) ;
13914: LD_ADDR_VAR 0 9
13918: PUSH
13919: LD_VAR 0 9
13923: PPUSH
13924: LD_VAR 0 16
13928: PPUSH
13929: LD_VAR 0 4
13933: PPUSH
13934: CALL_OW 272
13938: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
13939: LD_ADDR_VAR 0 10
13943: PUSH
13944: LD_VAR 0 10
13948: PPUSH
13949: LD_VAR 0 16
13953: PPUSH
13954: LD_VAR 0 4
13958: PPUSH
13959: CALL_OW 273
13963: ST_TO_ADDR
// lx := lx ^ x ;
13964: LD_ADDR_VAR 0 13
13968: PUSH
13969: LD_VAR 0 13
13973: PUSH
13974: LD_VAR 0 9
13978: ADD
13979: ST_TO_ADDR
// ly := ly ^ y ;
13980: LD_ADDR_VAR 0 14
13984: PUSH
13985: LD_VAR 0 14
13989: PUSH
13990: LD_VAR 0 10
13994: ADD
13995: ST_TO_ADDR
// if kolem = 0 then
13996: LD_VAR 0 21
14000: PUSH
14001: LD_INT 0
14003: EQUAL
14004: IFFALSE 14008
// break ;
14006: GO 14010
// end ;
14008: GO 13677
14010: POP
14011: POP
// for j2 := ( lx + 0 ) downto 1 do
14012: LD_ADDR_VAR 0 18
14016: PUSH
14017: DOUBLE
14018: LD_VAR 0 13
14022: PUSH
14023: LD_INT 0
14025: PLUS
14026: INC
14027: ST_TO_ADDR
14028: LD_INT 1
14030: PUSH
14031: FOR_DOWNTO
14032: IFFALSE 14138
// begin if queue and j2 = ( lx + 0 ) then
14034: LD_VAR 0 7
14038: PUSH
14039: LD_VAR 0 18
14043: PUSH
14044: LD_VAR 0 13
14048: PUSH
14049: LD_INT 0
14051: PLUS
14052: EQUAL
14053: AND
14054: IFFALSE 14089
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
14056: LD_VAR 0 22
14060: PPUSH
14061: LD_VAR 0 13
14065: PUSH
14066: LD_VAR 0 18
14070: ARRAY
14071: PPUSH
14072: LD_VAR 0 14
14076: PUSH
14077: LD_VAR 0 18
14081: ARRAY
14082: PPUSH
14083: CALL_OW 111
14087: GO 14136
// begin com_queue := true ;
14089: LD_ADDR_OWVAR 49
14093: PUSH
14094: LD_INT 1
14096: ST_TO_ADDR
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
14097: LD_VAR 0 22
14101: PPUSH
14102: LD_VAR 0 13
14106: PUSH
14107: LD_VAR 0 18
14111: ARRAY
14112: PPUSH
14113: LD_VAR 0 14
14117: PUSH
14118: LD_VAR 0 18
14122: ARRAY
14123: PPUSH
14124: CALL_OW 111
// com_queue := false ;
14128: LD_ADDR_OWVAR 49
14132: PUSH
14133: LD_INT 0
14135: ST_TO_ADDR
// end ; end ;
14136: GO 14031
14138: POP
14139: POP
// end ;
14140: GO 13619
14142: POP
14143: POP
// end ;
14144: LD_VAR 0 8
14148: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
14149: LD_INT 0
14151: PPUSH
14152: PPUSH
14153: PPUSH
14154: PPUSH
// for for_unit in for_units do
14155: LD_ADDR_VAR 0 5
14159: PUSH
14160: LD_VAR 0 1
14164: PUSH
14165: FOR_IN
14166: IFFALSE 14229
// begin unx := GetX ( for_unit ) ;
14168: LD_ADDR_VAR 0 6
14172: PUSH
14173: LD_VAR 0 5
14177: PPUSH
14178: CALL_OW 250
14182: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
14183: LD_ADDR_VAR 0 7
14187: PUSH
14188: LD_VAR 0 5
14192: PPUSH
14193: CALL_OW 251
14197: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
14198: LD_VAR 0 6
14202: PPUSH
14203: LD_VAR 0 7
14207: PPUSH
14208: LD_VAR 0 5
14212: PPUSH
14213: LD_VAR 0 2
14217: PPUSH
14218: LD_VAR 0 3
14222: PPUSH
14223: CALL 14236 0 5
// end ;
14227: GO 14165
14229: POP
14230: POP
// end ;
14231: LD_VAR 0 4
14235: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
14236: LD_INT 0
14238: PPUSH
14239: PPUSH
14240: PPUSH
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
// for for_unit in for_units do
14245: LD_ADDR_VAR 0 12
14249: PUSH
14250: LD_VAR 0 3
14254: PUSH
14255: FOR_IN
14256: IFFALSE 14972
// begin foundswD := 50000 ;
14258: LD_ADDR_VAR 0 9
14262: PUSH
14263: LD_INT 50000
14265: ST_TO_ADDR
// eswTX := 0 ;
14266: LD_ADDR_VAR 0 10
14270: PUSH
14271: LD_INT 0
14273: ST_TO_ADDR
// eswTY := 0 ;
14274: LD_ADDR_VAR 0 11
14278: PUSH
14279: LD_INT 0
14281: ST_TO_ADDR
// while eswTX < map_size_x do
14282: LD_VAR 0 10
14286: PUSH
14287: LD_EXP 53
14291: LESS
14292: IFFALSE 14392
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14294: LD_VAR 0 1
14298: PPUSH
14299: LD_VAR 0 2
14303: PPUSH
14304: LD_VAR 0 10
14308: PPUSH
14309: LD_VAR 0 11
14313: PPUSH
14314: CALL_OW 298
14318: PUSH
14319: LD_VAR 0 9
14323: LESS
14324: IFFALSE 14376
// begin foundswX := eswTX ;
14326: LD_ADDR_VAR 0 7
14330: PUSH
14331: LD_VAR 0 10
14335: ST_TO_ADDR
// foundswY := eswTY ;
14336: LD_ADDR_VAR 0 8
14340: PUSH
14341: LD_VAR 0 11
14345: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14346: LD_ADDR_VAR 0 9
14350: PUSH
14351: LD_VAR 0 1
14355: PPUSH
14356: LD_VAR 0 2
14360: PPUSH
14361: LD_VAR 0 10
14365: PPUSH
14366: LD_VAR 0 11
14370: PPUSH
14371: CALL_OW 298
14375: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14376: LD_ADDR_VAR 0 10
14380: PUSH
14381: LD_VAR 0 10
14385: PUSH
14386: LD_INT 10
14388: PLUS
14389: ST_TO_ADDR
// end ;
14390: GO 14282
// eswTX := map_size_x div 2 ;
14392: LD_ADDR_VAR 0 10
14396: PUSH
14397: LD_EXP 53
14401: PUSH
14402: LD_INT 2
14404: DIV
14405: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
14406: LD_ADDR_VAR 0 11
14410: PUSH
14411: LD_EXP 54
14415: PUSH
14416: LD_INT 1
14418: MINUS
14419: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
14420: LD_VAR 0 10
14424: PUSH
14425: LD_EXP 53
14429: PUSH
14430: LD_EXP 53
14434: PUSH
14435: LD_INT 2
14437: DIV
14438: PLUS
14439: LESS
14440: IFFALSE 14540
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14442: LD_VAR 0 1
14446: PPUSH
14447: LD_VAR 0 2
14451: PPUSH
14452: LD_VAR 0 10
14456: PPUSH
14457: LD_VAR 0 11
14461: PPUSH
14462: CALL_OW 298
14466: PUSH
14467: LD_VAR 0 9
14471: LESS
14472: IFFALSE 14524
// begin foundswX := eswTX ;
14474: LD_ADDR_VAR 0 7
14478: PUSH
14479: LD_VAR 0 10
14483: ST_TO_ADDR
// foundswY := eswTY ;
14484: LD_ADDR_VAR 0 8
14488: PUSH
14489: LD_VAR 0 11
14493: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14494: LD_ADDR_VAR 0 9
14498: PUSH
14499: LD_VAR 0 1
14503: PPUSH
14504: LD_VAR 0 2
14508: PPUSH
14509: LD_VAR 0 10
14513: PPUSH
14514: LD_VAR 0 11
14518: PPUSH
14519: CALL_OW 298
14523: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14524: LD_ADDR_VAR 0 10
14528: PUSH
14529: LD_VAR 0 10
14533: PUSH
14534: LD_INT 10
14536: PLUS
14537: ST_TO_ADDR
// end ;
14538: GO 14420
// eswTX := 0 ;
14540: LD_ADDR_VAR 0 10
14544: PUSH
14545: LD_INT 0
14547: ST_TO_ADDR
// eswTY := 0 ;
14548: LD_ADDR_VAR 0 11
14552: PUSH
14553: LD_INT 0
14555: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14556: LD_VAR 0 11
14560: PUSH
14561: LD_EXP 54
14565: LESS
14566: IFFALSE 14680
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14568: LD_VAR 0 1
14572: PPUSH
14573: LD_VAR 0 2
14577: PPUSH
14578: LD_VAR 0 10
14582: PPUSH
14583: LD_VAR 0 11
14587: PPUSH
14588: CALL_OW 298
14592: PUSH
14593: LD_VAR 0 9
14597: LESS
14598: IFFALSE 14650
// begin foundswX := eswTX ;
14600: LD_ADDR_VAR 0 7
14604: PUSH
14605: LD_VAR 0 10
14609: ST_TO_ADDR
// foundswY := eswTY ;
14610: LD_ADDR_VAR 0 8
14614: PUSH
14615: LD_VAR 0 11
14619: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14620: LD_ADDR_VAR 0 9
14624: PUSH
14625: LD_VAR 0 1
14629: PPUSH
14630: LD_VAR 0 2
14634: PPUSH
14635: LD_VAR 0 10
14639: PPUSH
14640: LD_VAR 0 11
14644: PPUSH
14645: CALL_OW 298
14649: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14650: LD_ADDR_VAR 0 11
14654: PUSH
14655: LD_VAR 0 11
14659: PUSH
14660: LD_INT 10
14662: PLUS
14663: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14664: LD_ADDR_VAR 0 10
14668: PUSH
14669: LD_VAR 0 10
14673: PUSH
14674: LD_INT 5
14676: PLUS
14677: ST_TO_ADDR
// end ;
14678: GO 14556
// eswTX := map_size_x ;
14680: LD_ADDR_VAR 0 10
14684: PUSH
14685: LD_EXP 53
14689: ST_TO_ADDR
// eswTY := 1 ;
14690: LD_ADDR_VAR 0 11
14694: PUSH
14695: LD_INT 1
14697: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14698: LD_VAR 0 11
14702: PUSH
14703: LD_EXP 54
14707: LESS
14708: IFFALSE 14822
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14710: LD_VAR 0 1
14714: PPUSH
14715: LD_VAR 0 2
14719: PPUSH
14720: LD_VAR 0 10
14724: PPUSH
14725: LD_VAR 0 11
14729: PPUSH
14730: CALL_OW 298
14734: PUSH
14735: LD_VAR 0 9
14739: LESS
14740: IFFALSE 14792
// begin foundswX := eswTX ;
14742: LD_ADDR_VAR 0 7
14746: PUSH
14747: LD_VAR 0 10
14751: ST_TO_ADDR
// foundswY := eswTY ;
14752: LD_ADDR_VAR 0 8
14756: PUSH
14757: LD_VAR 0 11
14761: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14762: LD_ADDR_VAR 0 9
14766: PUSH
14767: LD_VAR 0 1
14771: PPUSH
14772: LD_VAR 0 2
14776: PPUSH
14777: LD_VAR 0 10
14781: PPUSH
14782: LD_VAR 0 11
14786: PPUSH
14787: CALL_OW 298
14791: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14792: LD_ADDR_VAR 0 11
14796: PUSH
14797: LD_VAR 0 11
14801: PUSH
14802: LD_INT 10
14804: PLUS
14805: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14806: LD_ADDR_VAR 0 10
14810: PUSH
14811: LD_VAR 0 10
14815: PUSH
14816: LD_INT 5
14818: PLUS
14819: ST_TO_ADDR
// end ;
14820: GO 14698
// if queue then
14822: LD_VAR 0 4
14826: IFFALSE 14900
// begin if agressive then
14828: LD_VAR 0 5
14832: IFFALSE 14867
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
14834: LD_VAR 0 12
14838: PPUSH
14839: LD_VAR 0 7
14843: PPUSH
14844: LD_VAR 0 8
14848: PPUSH
14849: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
14853: LD_VAR 0 12
14857: PPUSH
14858: LD_INT 10
14860: PPUSH
14861: CALL_OW 173
// end else
14865: GO 14898
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
14867: LD_VAR 0 12
14871: PPUSH
14872: LD_VAR 0 7
14876: PPUSH
14877: LD_VAR 0 8
14881: PPUSH
14882: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
14886: LD_VAR 0 12
14890: PPUSH
14891: LD_INT 10
14893: PPUSH
14894: CALL_OW 173
// end ; end else
14898: GO 14970
// begin if agressive then
14900: LD_VAR 0 5
14904: IFFALSE 14939
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
14906: LD_VAR 0 12
14910: PPUSH
14911: LD_VAR 0 7
14915: PPUSH
14916: LD_VAR 0 8
14920: PPUSH
14921: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
14925: LD_VAR 0 12
14929: PPUSH
14930: LD_INT 10
14932: PPUSH
14933: CALL_OW 173
// end else
14937: GO 14970
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
14939: LD_VAR 0 12
14943: PPUSH
14944: LD_VAR 0 7
14948: PPUSH
14949: LD_VAR 0 8
14953: PPUSH
14954: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
14958: LD_VAR 0 12
14962: PPUSH
14963: LD_INT 10
14965: PPUSH
14966: CALL_OW 173
// end ; end ; end ;
14970: GO 14255
14972: POP
14973: POP
// end ;
14974: LD_VAR 0 6
14978: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
14979: LD_INT 0
14981: PPUSH
14982: PPUSH
14983: PPUSH
// see_any_r := false ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 0
14991: ST_TO_ADDR
// for sai in sez2 do
14992: LD_ADDR_VAR 0 4
14996: PUSH
14997: LD_VAR 0 2
15001: PUSH
15002: FOR_IN
15003: IFFALSE 15033
// if See ( strana , sai ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_VAR 0 4
15014: PPUSH
15015: CALL_OW 292
15019: IFFALSE 15031
// begin see_any_r := true ;
15021: LD_ADDR_VAR 0 5
15025: PUSH
15026: LD_INT 1
15028: ST_TO_ADDR
// break ;
15029: GO 15033
// end ;
15031: GO 15002
15033: POP
15034: POP
// ; result := see_any_r ;
15035: LD_ADDR_VAR 0 3
15039: PUSH
15040: LD_VAR 0 5
15044: ST_TO_ADDR
// end ;
15045: LD_VAR 0 3
15049: RET
// export function nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ; var list , list2 ; var un1 , vzdal ; var count ; begin
15050: LD_INT 0
15052: PPUSH
15053: PPUSH
15054: PPUSH
15055: PPUSH
15056: PPUSH
15057: PPUSH
// un1 := 1 ;
15058: LD_ADDR_VAR 0 11
15062: PUSH
15063: LD_INT 1
15065: ST_TO_ADDR
// count := 0 ;
15066: LD_ADDR_VAR 0 13
15070: PUSH
15071: LD_INT 0
15073: ST_TO_ADDR
// if pocet > from_units then
15074: LD_VAR 0 5
15078: PUSH
15079: LD_VAR 0 1
15083: GREATER
15084: IFFALSE 15100
// pocet := ( from_units + 0 ) ;
15086: LD_ADDR_VAR 0 5
15090: PUSH
15091: LD_VAR 0 1
15095: PUSH
15096: LD_INT 0
15098: PLUS
15099: ST_TO_ADDR
// while un1 <= pocet or count <= pocet do
15100: LD_VAR 0 11
15104: PUSH
15105: LD_VAR 0 5
15109: LESSEQUAL
15110: PUSH
15111: LD_VAR 0 13
15115: PUSH
15116: LD_VAR 0 5
15120: LESSEQUAL
15121: OR
15122: IFFALSE 15275
// begin vzdal := GetDistUnitXY ( un1 , x , y ) ;
15124: LD_ADDR_VAR 0 12
15128: PUSH
15129: LD_VAR 0 11
15133: PPUSH
15134: LD_VAR 0 2
15138: PPUSH
15139: LD_VAR 0 3
15143: PPUSH
15144: CALL_OW 297
15148: ST_TO_ADDR
// if vzdal <= max_vzdal then
15149: LD_VAR 0 12
15153: PUSH
15154: LD_VAR 0 7
15158: LESSEQUAL
15159: IFFALSE 15259
// begin if un1 > skip then
15161: LD_VAR 0 11
15165: PUSH
15166: LD_VAR 0 4
15170: GREATER
15171: IFFALSE 15259
// begin if list then
15173: LD_VAR 0 9
15177: IFFALSE 15219
// begin list := list ^ from_units [ un1 ] ;
15179: LD_ADDR_VAR 0 9
15183: PUSH
15184: LD_VAR 0 9
15188: PUSH
15189: LD_VAR 0 1
15193: PUSH
15194: LD_VAR 0 11
15198: ARRAY
15199: ADD
15200: ST_TO_ADDR
// list2 := list2 ^ vzdal ;
15201: LD_ADDR_VAR 0 10
15205: PUSH
15206: LD_VAR 0 10
15210: PUSH
15211: LD_VAR 0 12
15215: ADD
15216: ST_TO_ADDR
// end else
15217: GO 15245
// begin list := from_units [ un1 ] ;
15219: LD_ADDR_VAR 0 9
15223: PUSH
15224: LD_VAR 0 1
15228: PUSH
15229: LD_VAR 0 11
15233: ARRAY
15234: ST_TO_ADDR
// list2 := vzdal ;
15235: LD_ADDR_VAR 0 10
15239: PUSH
15240: LD_VAR 0 12
15244: ST_TO_ADDR
// end ; count := count + 1 ;
15245: LD_ADDR_VAR 0 13
15249: PUSH
15250: LD_VAR 0 13
15254: PUSH
15255: LD_INT 1
15257: PLUS
15258: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
15259: LD_ADDR_VAR 0 11
15263: PUSH
15264: LD_VAR 0 11
15268: PUSH
15269: LD_INT 1
15271: PLUS
15272: ST_TO_ADDR
// end ;
15273: GO 15100
// result := list ;
15275: LD_ADDR_VAR 0 8
15279: PUSH
15280: LD_VAR 0 9
15284: ST_TO_ADDR
// end ;
15285: LD_VAR 0 8
15289: RET
// export function nearest_units_unit ( from_units , for_unit , skip , pocet , min_vzdal , max_vzdal ) ; var x , y ; begin
15290: LD_INT 0
15292: PPUSH
15293: PPUSH
15294: PPUSH
// x := GetX ( for_unit ) ;
15295: LD_ADDR_VAR 0 8
15299: PUSH
15300: LD_VAR 0 2
15304: PPUSH
15305: CALL_OW 250
15309: ST_TO_ADDR
// y := GetY ( for_unit ) ;
15310: LD_ADDR_VAR 0 9
15314: PUSH
15315: LD_VAR 0 2
15319: PPUSH
15320: CALL_OW 251
15324: ST_TO_ADDR
// result := nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ;
15325: LD_ADDR_VAR 0 7
15329: PUSH
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 8
15339: PPUSH
15340: LD_VAR 0 9
15344: PPUSH
15345: LD_VAR 0 3
15349: PPUSH
15350: LD_VAR 0 4
15354: PPUSH
15355: LD_VAR 0 5
15359: PPUSH
15360: LD_VAR 0 6
15364: PPUSH
15365: CALL 15050 0 7
15369: ST_TO_ADDR
// end ;
15370: LD_VAR 0 7
15374: RET
// export function nearest_ememies_xy ( side , x , y , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15375: LD_INT 0
15377: PPUSH
15378: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15379: LD_ADDR_VAR 0 11
15383: PUSH
15384: LD_INT 22
15386: PUSH
15387: LD_VAR 0 1
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: PPUSH
15396: CALL_OW 69
15400: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15401: LD_ADDR_VAR 0 11
15405: PUSH
15406: LD_VAR 0 11
15410: PPUSH
15411: LD_VAR 0 7
15415: PPUSH
15416: LD_VAR 0 8
15420: PPUSH
15421: LD_VAR 0 9
15425: PPUSH
15426: CALL 13437 0 4
15430: ST_TO_ADDR
// nearest_units_xy ( from_units , x , y , skip , pocet , 1 , max_vzdal ) ;
15431: LD_VAR 0 11
15435: PPUSH
15436: LD_VAR 0 2
15440: PPUSH
15441: LD_VAR 0 3
15445: PPUSH
15446: LD_VAR 0 4
15450: PPUSH
15451: LD_VAR 0 5
15455: PPUSH
15456: LD_INT 1
15458: PPUSH
15459: LD_VAR 0 6
15463: PPUSH
15464: CALL 15050 0 7
// end ;
15468: LD_VAR 0 10
15472: RET
// export function nearest_ememies_unit ( side , for_unit , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15473: LD_INT 0
15475: PPUSH
15476: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15477: LD_ADDR_VAR 0 10
15481: PUSH
15482: LD_INT 22
15484: PUSH
15485: LD_VAR 0 1
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PPUSH
15494: CALL_OW 69
15498: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15499: LD_ADDR_VAR 0 10
15503: PUSH
15504: LD_VAR 0 10
15508: PPUSH
15509: LD_VAR 0 6
15513: PPUSH
15514: LD_VAR 0 7
15518: PPUSH
15519: LD_VAR 0 8
15523: PPUSH
15524: CALL 13437 0 4
15528: ST_TO_ADDR
// nearest_units_unit ( from_units , for_unit , skip , pocet , 1 , max_vzdal ) ;
15529: LD_VAR 0 10
15533: PPUSH
15534: LD_VAR 0 2
15538: PPUSH
15539: LD_VAR 0 3
15543: PPUSH
15544: LD_VAR 0 4
15548: PPUSH
15549: LD_INT 1
15551: PPUSH
15552: LD_VAR 0 5
15556: PPUSH
15557: CALL 15290 0 6
// end ;
15561: LD_VAR 0 9
15565: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
15566: LD_INT 0
15568: PPUSH
15569: PPUSH
15570: PPUSH
15571: PPUSH
// for i in who do
15572: LD_ADDR_VAR 0 6
15576: PUSH
15577: LD_VAR 0 1
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15654
// begin for j in what do
15585: LD_ADDR_VAR 0 7
15589: PUSH
15590: LD_VAR 0 3
15594: PUSH
15595: FOR_IN
15596: IFFALSE 15650
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
15598: LD_VAR 0 7
15602: PPUSH
15603: CALL_OW 311
15607: NOT
15608: PUSH
15609: LD_VAR 0 6
15613: PPUSH
15614: LD_VAR 0 7
15618: PPUSH
15619: CALL_OW 296
15623: PUSH
15624: LD_VAR 0 2
15628: LESSEQUAL
15629: AND
15630: IFFALSE 15648
// begin ComEnterUnit ( i , j ) ;
15632: LD_VAR 0 6
15636: PPUSH
15637: LD_VAR 0 7
15641: PPUSH
15642: CALL_OW 120
// break ;
15646: GO 15650
// end ; end ;
15648: GO 15595
15650: POP
15651: POP
// end ;
15652: GO 15582
15654: POP
15655: POP
// end ;
15656: LD_VAR 0 4
15660: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
15661: LD_INT 0
15663: PPUSH
15664: PPUSH
15665: PPUSH
15666: PPUSH
// for i in who do
15667: LD_ADDR_VAR 0 6
15671: PUSH
15672: LD_VAR 0 1
15676: PUSH
15677: FOR_IN
15678: IFFALSE 15777
// begin add := false ;
15680: LD_ADDR_VAR 0 5
15684: PUSH
15685: LD_INT 0
15687: ST_TO_ADDR
// for j in what do
15688: LD_ADDR_VAR 0 7
15692: PUSH
15693: LD_VAR 0 3
15697: PUSH
15698: FOR_IN
15699: IFFALSE 15733
// begin if GetDistUnits ( i , j ) <= dist then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 296
15715: PUSH
15716: LD_VAR 0 2
15720: LESSEQUAL
15721: IFFALSE 15731
// begin add := true ;
15723: LD_ADDR_VAR 0 5
15727: PUSH
15728: LD_INT 1
15730: ST_TO_ADDR
// end ; end ;
15731: GO 15698
15733: POP
15734: POP
// if add then
15735: LD_VAR 0 5
15739: IFFALSE 15775
// begin if result then
15741: LD_VAR 0 4
15745: IFFALSE 15765
// result := result ^ i else
15747: LD_ADDR_VAR 0 4
15751: PUSH
15752: LD_VAR 0 4
15756: PUSH
15757: LD_VAR 0 6
15761: ADD
15762: ST_TO_ADDR
15763: GO 15775
// result := i ;
15765: LD_ADDR_VAR 0 4
15769: PUSH
15770: LD_VAR 0 6
15774: ST_TO_ADDR
// end ; end ;
15775: GO 15677
15777: POP
15778: POP
// end ;
15779: LD_VAR 0 4
15783: RET
// export function comqb ; begin
15784: LD_INT 0
15786: PPUSH
// com_queue := true ;
15787: LD_ADDR_OWVAR 49
15791: PUSH
15792: LD_INT 1
15794: ST_TO_ADDR
// end ;
15795: LD_VAR 0 1
15799: RET
// export function comqe ; begin
15800: LD_INT 0
15802: PPUSH
// com_queue := false ;
15803: LD_ADDR_OWVAR 49
15807: PUSH
15808: LD_INT 0
15810: ST_TO_ADDR
// end ;
15811: LD_VAR 0 1
15815: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a , x , y ; begin
15816: LD_INT 0
15818: PPUSH
15819: PPUSH
15820: PPUSH
15821: PPUSH
15822: PPUSH
// for_units := UnitFilter ( for_units , [ f_alive ] ) ;
15823: LD_ADDR_VAR 0 1
15827: PUSH
15828: LD_VAR 0 1
15832: PPUSH
15833: LD_INT 51
15835: PUSH
15836: EMPTY
15837: LIST
15838: PPUSH
15839: CALL_OW 72
15843: ST_TO_ADDR
// i1 := 1 ;
15844: LD_ADDR_VAR 0 5
15848: PUSH
15849: LD_INT 1
15851: ST_TO_ADDR
// while i1 <= path do
15852: LD_VAR 0 5
15856: PUSH
15857: LD_VAR 0 2
15861: LESSEQUAL
15862: IFFALSE 16158
// begin a := path [ i1 ] ;
15864: LD_ADDR_VAR 0 6
15868: PUSH
15869: LD_VAR 0 2
15873: PUSH
15874: LD_VAR 0 5
15878: ARRAY
15879: ST_TO_ADDR
// if a < 0 then
15880: LD_VAR 0 6
15884: PUSH
15885: LD_INT 0
15887: LESS
15888: IFFALSE 15945
// begin while a <= - 1 do
15890: LD_VAR 0 6
15894: PUSH
15895: LD_INT 1
15897: NEG
15898: LESSEQUAL
15899: IFFALSE 15929
// begin a := a + 1 ;
15901: LD_ADDR_VAR 0 6
15905: PUSH
15906: LD_VAR 0 6
15910: PUSH
15911: LD_INT 1
15913: PLUS
15914: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
15915: LD_VAR 0 1
15919: PPUSH
15920: LD_INT 35
15922: PPUSH
15923: CALL_OW 202
// end ;
15927: GO 15890
// i1 := i1 + 1 ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_VAR 0 5
15938: PUSH
15939: LD_INT 1
15941: PLUS
15942: ST_TO_ADDR
// end else
15943: GO 16156
// begin if a = 0 then
15945: LD_VAR 0 6
15949: PUSH
15950: LD_INT 0
15952: EQUAL
15953: IFFALSE 16015
// begin a := path [ i1 + 1 ] ;
15955: LD_ADDR_VAR 0 6
15959: PUSH
15960: LD_VAR 0 2
15964: PUSH
15965: LD_VAR 0 5
15969: PUSH
15970: LD_INT 1
15972: PLUS
15973: ARRAY
15974: ST_TO_ADDR
// if a = 0 then
15975: LD_VAR 0 6
15979: PUSH
15980: LD_INT 0
15982: EQUAL
15983: IFFALSE 15994
// AddComReturn ( for_units ) ;
15985: LD_VAR 0 1
15989: PPUSH
15990: CALL_OW 204
// if a = 1 then
15994: LD_VAR 0 6
15998: PUSH
15999: LD_INT 1
16001: EQUAL
16002: IFFALSE 16013
// AddComRemember ( for_units ) ;
16004: LD_VAR 0 1
16008: PPUSH
16009: CALL_OW 203
// end else
16013: GO 16142
// begin x := path [ i1 ] ;
16015: LD_ADDR_VAR 0 7
16019: PUSH
16020: LD_VAR 0 2
16024: PUSH
16025: LD_VAR 0 5
16029: ARRAY
16030: ST_TO_ADDR
// y := path [ i1 + 1 ] ;
16031: LD_ADDR_VAR 0 8
16035: PUSH
16036: LD_VAR 0 2
16040: PUSH
16041: LD_VAR 0 5
16045: PUSH
16046: LD_INT 1
16048: PLUS
16049: ARRAY
16050: ST_TO_ADDR
// if x <= 3 and y <= 3 then
16051: LD_VAR 0 7
16055: PUSH
16056: LD_INT 3
16058: LESSEQUAL
16059: PUSH
16060: LD_VAR 0 8
16064: PUSH
16065: LD_INT 3
16067: LESSEQUAL
16068: AND
16069: IFFALSE 16096
// begin Msg ( kam to jedes (take path) ) ;
16071: LD_STRING kam to jedes (take path)
16073: PPUSH
16074: CALL_OW 100
// Msg ( [ x , y ] ) ;
16078: LD_VAR 0 7
16082: PUSH
16083: LD_VAR 0 8
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PPUSH
16092: CALL_OW 100
// end ; if agressive then
16096: LD_VAR 0 3
16100: IFFALSE 16123
// AddComAgressiveMove ( for_units , x , y ) else
16102: LD_VAR 0 1
16106: PPUSH
16107: LD_VAR 0 7
16111: PPUSH
16112: LD_VAR 0 8
16116: PPUSH
16117: CALL_OW 174
16121: GO 16142
// AddComMoveXY ( for_units , x , y ) ;
16123: LD_VAR 0 1
16127: PPUSH
16128: LD_VAR 0 7
16132: PPUSH
16133: LD_VAR 0 8
16137: PPUSH
16138: CALL_OW 171
// end ; i1 := i1 + 2 ;
16142: LD_ADDR_VAR 0 5
16146: PUSH
16147: LD_VAR 0 5
16151: PUSH
16152: LD_INT 2
16154: PLUS
16155: ST_TO_ADDR
// end ; end ;
16156: GO 15852
// end ;
16158: LD_VAR 0 4
16162: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
16163: LD_INT 0
16165: PPUSH
16166: PPUSH
16167: PPUSH
16168: PPUSH
16169: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
16170: LD_ADDR_VAR 0 1
16174: PUSH
16175: LD_VAR 0 1
16179: PPUSH
16180: LD_INT 51
16182: PUSH
16183: EMPTY
16184: LIST
16185: PPUSH
16186: CALL_OW 72
16190: PUSH
16191: EMPTY
16192: UNION
16193: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
16194: LD_ADDR_VAR 0 2
16198: PUSH
16199: LD_VAR 0 2
16203: PPUSH
16204: LD_INT 51
16206: PUSH
16207: EMPTY
16208: LIST
16209: PPUSH
16210: CALL_OW 72
16214: PUSH
16215: EMPTY
16216: UNION
16217: ST_TO_ADDR
// for i in cars do
16218: LD_ADDR_VAR 0 7
16222: PUSH
16223: LD_VAR 0 1
16227: PUSH
16228: FOR_IN
16229: IFFALSE 16265
// if not IsDrivenBy ( i ) then
16231: LD_VAR 0 7
16235: PPUSH
16236: CALL_OW 311
16240: NOT
16241: IFFALSE 16263
// empty := add ( empty , i ) ;
16243: LD_ADDR_VAR 0 5
16247: PUSH
16248: LD_VAR 0 5
16252: PPUSH
16253: LD_VAR 0 7
16257: PPUSH
16258: CALL 17335 0 2
16262: ST_TO_ADDR
16263: GO 16228
16265: POP
16266: POP
// if take_out then
16267: LD_VAR 0 3
16271: IFFALSE 16330
// begin for i in drivers do
16273: LD_ADDR_VAR 0 7
16277: PUSH
16278: LD_VAR 0 2
16282: PUSH
16283: FOR_IN
16284: IFFALSE 16326
// if not ( IsInUnit ( i ) in cars ) then
16286: LD_VAR 0 7
16290: PPUSH
16291: CALL_OW 310
16295: PUSH
16296: LD_VAR 0 1
16300: IN
16301: NOT
16302: IFFALSE 16324
// free := add ( free , i ) ;
16304: LD_ADDR_VAR 0 6
16308: PUSH
16309: LD_VAR 0 6
16313: PPUSH
16314: LD_VAR 0 7
16318: PPUSH
16319: CALL 17335 0 2
16323: ST_TO_ADDR
16324: GO 16283
16326: POP
16327: POP
// end else
16328: GO 16379
// begin for i in drivers do
16330: LD_ADDR_VAR 0 7
16334: PUSH
16335: LD_VAR 0 2
16339: PUSH
16340: FOR_IN
16341: IFFALSE 16377
// if not IsInUnit ( i ) then
16343: LD_VAR 0 7
16347: PPUSH
16348: CALL_OW 310
16352: NOT
16353: IFFALSE 16375
// free := add ( free , i ) ;
16355: LD_ADDR_VAR 0 6
16359: PUSH
16360: LD_VAR 0 6
16364: PPUSH
16365: LD_VAR 0 7
16369: PPUSH
16370: CALL 17335 0 2
16374: ST_TO_ADDR
16375: GO 16340
16377: POP
16378: POP
// end ; result := cars diff empty ;
16379: LD_ADDR_VAR 0 4
16383: PUSH
16384: LD_VAR 0 1
16388: PUSH
16389: LD_VAR 0 5
16393: DIFF
16394: ST_TO_ADDR
// if empty <= free then
16395: LD_VAR 0 5
16399: PUSH
16400: LD_VAR 0 6
16404: LESSEQUAL
16405: IFFALSE 16419
// konec := empty else
16407: LD_ADDR_VAR 0 8
16411: PUSH
16412: LD_VAR 0 5
16416: ST_TO_ADDR
16417: GO 16429
// konec := free ;
16419: LD_ADDR_VAR 0 8
16423: PUSH
16424: LD_VAR 0 6
16428: ST_TO_ADDR
// for i := 1 to konec do
16429: LD_ADDR_VAR 0 7
16433: PUSH
16434: DOUBLE
16435: LD_INT 1
16437: DEC
16438: ST_TO_ADDR
16439: LD_VAR 0 8
16443: PUSH
16444: FOR_TO
16445: IFFALSE 16501
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16447: LD_VAR 0 6
16451: PUSH
16452: LD_VAR 0 7
16456: ARRAY
16457: PPUSH
16458: LD_VAR 0 5
16462: PUSH
16463: LD_VAR 0 7
16467: ARRAY
16468: PPUSH
16469: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16473: LD_ADDR_VAR 0 4
16477: PUSH
16478: LD_VAR 0 4
16482: PPUSH
16483: LD_VAR 0 5
16487: PUSH
16488: LD_VAR 0 7
16492: ARRAY
16493: PPUSH
16494: CALL 17335 0 2
16498: ST_TO_ADDR
// end ;
16499: GO 16444
16501: POP
16502: POP
// end ;
16503: LD_VAR 0 4
16507: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
16508: LD_INT 0
16510: PPUSH
16511: PPUSH
16512: PPUSH
16513: PPUSH
16514: PPUSH
// forts := forts union [ ] ;
16515: LD_ADDR_VAR 0 1
16519: PUSH
16520: LD_VAR 0 1
16524: PUSH
16525: EMPTY
16526: UNION
16527: ST_TO_ADDR
// sols := sols union [ ] ;
16528: LD_ADDR_VAR 0 2
16532: PUSH
16533: LD_VAR 0 2
16537: PUSH
16538: EMPTY
16539: UNION
16540: ST_TO_ADDR
// for i in forts do
16541: LD_ADDR_VAR 0 6
16545: PUSH
16546: LD_VAR 0 1
16550: PUSH
16551: FOR_IN
16552: IFFALSE 16588
// if not UnitsInside ( i ) then
16554: LD_VAR 0 6
16558: PPUSH
16559: CALL_OW 313
16563: NOT
16564: IFFALSE 16586
// empty := add ( empty , i ) ;
16566: LD_ADDR_VAR 0 4
16570: PUSH
16571: LD_VAR 0 4
16575: PPUSH
16576: LD_VAR 0 6
16580: PPUSH
16581: CALL 17335 0 2
16585: ST_TO_ADDR
16586: GO 16551
16588: POP
16589: POP
// for i in sols do
16590: LD_ADDR_VAR 0 6
16594: PUSH
16595: LD_VAR 0 2
16599: PUSH
16600: FOR_IN
16601: IFFALSE 16649
// if not IsInUnit ( i ) and not IsBusy ( i ) then
16603: LD_VAR 0 6
16607: PPUSH
16608: CALL_OW 310
16612: NOT
16613: PUSH
16614: LD_VAR 0 6
16618: PPUSH
16619: CALL_OW 315
16623: NOT
16624: AND
16625: IFFALSE 16647
// free := add ( free , i ) ;
16627: LD_ADDR_VAR 0 5
16631: PUSH
16632: LD_VAR 0 5
16636: PPUSH
16637: LD_VAR 0 6
16641: PPUSH
16642: CALL 17335 0 2
16646: ST_TO_ADDR
16647: GO 16600
16649: POP
16650: POP
// result := forts diff empty ;
16651: LD_ADDR_VAR 0 3
16655: PUSH
16656: LD_VAR 0 1
16660: PUSH
16661: LD_VAR 0 4
16665: DIFF
16666: ST_TO_ADDR
// if empty <= free then
16667: LD_VAR 0 4
16671: PUSH
16672: LD_VAR 0 5
16676: LESSEQUAL
16677: IFFALSE 16691
// konec := empty else
16679: LD_ADDR_VAR 0 7
16683: PUSH
16684: LD_VAR 0 4
16688: ST_TO_ADDR
16689: GO 16701
// konec := free ;
16691: LD_ADDR_VAR 0 7
16695: PUSH
16696: LD_VAR 0 5
16700: ST_TO_ADDR
// for i := 1 to konec do
16701: LD_ADDR_VAR 0 6
16705: PUSH
16706: DOUBLE
16707: LD_INT 1
16709: DEC
16710: ST_TO_ADDR
16711: LD_VAR 0 7
16715: PUSH
16716: FOR_TO
16717: IFFALSE 16773
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16719: LD_VAR 0 5
16723: PUSH
16724: LD_VAR 0 6
16728: ARRAY
16729: PPUSH
16730: LD_VAR 0 4
16734: PUSH
16735: LD_VAR 0 6
16739: ARRAY
16740: PPUSH
16741: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16745: LD_ADDR_VAR 0 3
16749: PUSH
16750: LD_VAR 0 3
16754: PPUSH
16755: LD_VAR 0 4
16759: PUSH
16760: LD_VAR 0 6
16764: ARRAY
16765: PPUSH
16766: CALL 17335 0 2
16770: ST_TO_ADDR
// end ;
16771: GO 16716
16773: POP
16774: POP
// end ;
16775: LD_VAR 0 3
16779: RET
// export function depart ( cars , drivers , path , argessive , take_out ) ; var pojedou ; begin
16780: LD_INT 0
16782: PPUSH
16783: PPUSH
// pojedou := find_drivers ( cars , drivers , take_out ) ;
16784: LD_ADDR_VAR 0 7
16788: PUSH
16789: LD_VAR 0 1
16793: PPUSH
16794: LD_VAR 0 2
16798: PPUSH
16799: LD_VAR 0 5
16803: PPUSH
16804: CALL 16163 0 3
16808: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
16809: LD_VAR 0 7
16813: PPUSH
16814: CALL 16842 0 1
// take_path ( pojedou , path , argessive ) ;
16818: LD_VAR 0 7
16822: PPUSH
16823: LD_VAR 0 3
16827: PPUSH
16828: LD_VAR 0 4
16832: PPUSH
16833: CALL 15816 0 3
// end ;
16837: LD_VAR 0 6
16841: RET
// export function wait_for_drivers ( cars ) ; var i , vsichni_ready , k ; begin
16842: LD_INT 0
16844: PPUSH
16845: PPUSH
16846: PPUSH
16847: PPUSH
// k := 0 ;
16848: LD_ADDR_VAR 0 5
16852: PUSH
16853: LD_INT 0
16855: ST_TO_ADDR
// while not vsichni_ready do
16856: LD_VAR 0 4
16860: NOT
16861: IFFALSE 16931
// begin vsichni_ready := true ;
16863: LD_ADDR_VAR 0 4
16867: PUSH
16868: LD_INT 1
16870: ST_TO_ADDR
// k := k + 1 ;
16871: LD_ADDR_VAR 0 5
16875: PUSH
16876: LD_VAR 0 5
16880: PUSH
16881: LD_INT 1
16883: PLUS
16884: ST_TO_ADDR
// for i in cars do
16885: LD_ADDR_VAR 0 3
16889: PUSH
16890: LD_VAR 0 1
16894: PUSH
16895: FOR_IN
16896: IFFALSE 16920
// if not IsDrivenBy ( i ) then
16898: LD_VAR 0 3
16902: PPUSH
16903: CALL_OW 311
16907: NOT
16908: IFFALSE 16918
// vsichni_ready := false ;
16910: LD_ADDR_VAR 0 4
16914: PUSH
16915: LD_INT 0
16917: ST_TO_ADDR
16918: GO 16895
16920: POP
16921: POP
// wait ( 0 0$1.0 ) ;
16922: LD_INT 35
16924: PPUSH
16925: CALL_OW 67
// end ;
16929: GO 16856
// end ;
16931: LD_VAR 0 2
16935: RET
// export function rand_xy_in_map ; var x , y ; begin
16936: LD_INT 0
16938: PPUSH
16939: PPUSH
16940: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
16941: LD_ADDR_VAR 0 3
16945: PUSH
16946: LD_INT 2
16948: PPUSH
16949: LD_EXP 54
16953: PUSH
16954: LD_INT 2
16956: MINUS
16957: PPUSH
16958: CALL_OW 12
16962: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
16963: LD_ADDR_VAR 0 2
16967: PUSH
16968: LD_VAR 0 3
16972: PUSH
16973: LD_INT 2
16975: DIV
16976: PUSH
16977: LD_INT 2
16979: PLUS
16980: PPUSH
16981: LD_EXP 53
16985: PUSH
16986: LD_VAR 0 3
16990: PUSH
16991: LD_INT 2
16993: DIV
16994: PLUS
16995: PUSH
16996: LD_INT 2
16998: MINUS
16999: PPUSH
17000: CALL_OW 12
17004: ST_TO_ADDR
// result := [ x , y ] ;
17005: LD_ADDR_VAR 0 1
17009: PUSH
17010: LD_VAR 0 2
17014: PUSH
17015: LD_VAR 0 3
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: ST_TO_ADDR
// end ;
17024: LD_VAR 0 1
17028: RET
// export function TalkOn ; begin
17029: LD_INT 0
17031: PPUSH
// stop_talking := true ;
17032: LD_ADDR_OWVAR 56
17036: PUSH
17037: LD_INT 1
17039: ST_TO_ADDR
// end ;
17040: LD_VAR 0 1
17044: RET
// export function TalkOff ; begin
17045: LD_INT 0
17047: PPUSH
// stop_talking := false ;
17048: LD_ADDR_OWVAR 56
17052: PUSH
17053: LD_INT 0
17055: ST_TO_ADDR
// end ;
17056: LD_VAR 0 1
17060: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
17061: LD_INT 0
17063: PPUSH
17064: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
17065: LD_ADDR_VAR 0 8
17069: PUSH
17070: LD_VAR 0 1
17074: PPUSH
17075: LD_VAR 0 3
17079: PPUSH
17080: LD_VAR 0 4
17084: PPUSH
17085: LD_VAR 0 5
17089: PPUSH
17090: LD_VAR 0 6
17094: PPUSH
17095: CALL 17141 0 5
17099: ST_TO_ADDR
// if kdo then
17100: LD_VAR 0 8
17104: IFFALSE 17128
// result := Say ( kdo , ident ) else
17106: LD_ADDR_VAR 0 7
17110: PUSH
17111: LD_VAR 0 8
17115: PPUSH
17116: LD_VAR 0 2
17120: PPUSH
17121: CALL_OW 88
17125: ST_TO_ADDR
17126: GO 17136
// result := false ;
17128: LD_ADDR_VAR 0 7
17132: PUSH
17133: LD_INT 0
17135: ST_TO_ADDR
// end ;
17136: LD_VAR 0 7
17140: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
17141: LD_INT 0
17143: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
17144: LD_ADDR_VAR 0 1
17148: PUSH
17149: LD_VAR 0 1
17153: PPUSH
17154: LD_INT 21
17156: PUSH
17157: LD_INT 1
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: PUSH
17164: LD_INT 22
17166: PUSH
17167: LD_VAR 0 2
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 3
17178: PUSH
17179: LD_INT 23
17181: PUSH
17182: LD_INT 0
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: PPUSH
17195: CALL_OW 72
17199: ST_TO_ADDR
// if sex <> 0 then
17200: LD_VAR 0 3
17204: PUSH
17205: LD_INT 0
17207: NONEQUAL
17208: IFFALSE 17237
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_VAR 0 1
17219: PPUSH
17220: LD_INT 26
17222: PUSH
17223: LD_VAR 0 3
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PPUSH
17232: CALL_OW 72
17236: ST_TO_ADDR
// if Hclass <> 0 then
17237: LD_VAR 0 4
17241: PUSH
17242: LD_INT 0
17244: NONEQUAL
17245: IFFALSE 17274
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
17247: LD_ADDR_VAR 0 1
17251: PUSH
17252: LD_VAR 0 1
17256: PPUSH
17257: LD_INT 25
17259: PUSH
17260: LD_VAR 0 4
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 72
17273: ST_TO_ADDR
// if index <= 0 then
17274: LD_VAR 0 5
17278: PUSH
17279: LD_INT 0
17281: LESSEQUAL
17282: IFFALSE 17292
// index := 1 ;
17284: LD_ADDR_VAR 0 5
17288: PUSH
17289: LD_INT 1
17291: ST_TO_ADDR
// if lidi >= index then
17292: LD_VAR 0 1
17296: PUSH
17297: LD_VAR 0 5
17301: GREATEREQUAL
17302: IFFALSE 17322
// result := lidi [ index ] else
17304: LD_ADDR_VAR 0 6
17308: PUSH
17309: LD_VAR 0 1
17313: PUSH
17314: LD_VAR 0 5
17318: ARRAY
17319: ST_TO_ADDR
17320: GO 17330
// result := 0 ;
17322: LD_ADDR_VAR 0 6
17326: PUSH
17327: LD_INT 0
17329: ST_TO_ADDR
// end ;
17330: LD_VAR 0 6
17334: RET
// export function add ( list , list1 ) ; begin
17335: LD_INT 0
17337: PPUSH
// if list = 0 then
17338: LD_VAR 0 1
17342: PUSH
17343: LD_INT 0
17345: EQUAL
17346: IFFALSE 17355
// list := [ ] ;
17348: LD_ADDR_VAR 0 1
17352: PUSH
17353: EMPTY
17354: ST_TO_ADDR
// if list1 = 0 then
17355: LD_VAR 0 2
17359: PUSH
17360: LD_INT 0
17362: EQUAL
17363: IFFALSE 17372
// list1 := [ ] ;
17365: LD_ADDR_VAR 0 2
17369: PUSH
17370: EMPTY
17371: ST_TO_ADDR
// result := list ^ list1 ;
17372: LD_ADDR_VAR 0 3
17376: PUSH
17377: LD_VAR 0 1
17381: PUSH
17382: LD_VAR 0 2
17386: ADD
17387: ST_TO_ADDR
// end ;
17388: LD_VAR 0 3
17392: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
17393: LD_INT 0
17395: PPUSH
17396: PPUSH
17397: PPUSH
17398: PPUSH
// l1 := [ ] ;
17399: LD_ADDR_VAR 0 3
17403: PUSH
17404: EMPTY
17405: ST_TO_ADDR
// l2 := [ ] ;
17406: LD_ADDR_VAR 0 4
17410: PUSH
17411: EMPTY
17412: ST_TO_ADDR
// for i := 1 to list div 2 do
17413: LD_ADDR_VAR 0 5
17417: PUSH
17418: DOUBLE
17419: LD_INT 1
17421: DEC
17422: ST_TO_ADDR
17423: LD_VAR 0 1
17427: PUSH
17428: LD_INT 2
17430: DIV
17431: PUSH
17432: FOR_TO
17433: IFFALSE 17459
// begin l1 := l1 ^ list [ i ] ;
17435: LD_ADDR_VAR 0 3
17439: PUSH
17440: LD_VAR 0 3
17444: PUSH
17445: LD_VAR 0 1
17449: PUSH
17450: LD_VAR 0 5
17454: ARRAY
17455: ADD
17456: ST_TO_ADDR
// end ;
17457: GO 17432
17459: POP
17460: POP
// l2 := list diff l1 ;
17461: LD_ADDR_VAR 0 4
17465: PUSH
17466: LD_VAR 0 1
17470: PUSH
17471: LD_VAR 0 3
17475: DIFF
17476: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
17477: LD_ADDR_VAR 0 2
17481: PUSH
17482: LD_VAR 0 3
17486: PUSH
17487: EMPTY
17488: LIST
17489: PUSH
17490: LD_VAR 0 4
17494: PUSH
17495: EMPTY
17496: LIST
17497: ADD
17498: ST_TO_ADDR
// end ;
17499: LD_VAR 0 2
17503: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
17504: LD_INT 0
17506: PPUSH
// if not hinty_co_byli then
17507: LD_EXP 88
17511: NOT
17512: IFFALSE 17521
// hinty_co_byli := [ ] ;
17514: LD_ADDR_EXP 88
17518: PUSH
17519: EMPTY
17520: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
17521: LD_VAR 0 1
17525: PUSH
17526: LD_EXP 88
17530: IN
17531: NOT
17532: IFFALSE 17559
// begin hinty_co_byli := hinty_co_byli ^ ident ;
17534: LD_ADDR_EXP 88
17538: PUSH
17539: LD_EXP 88
17543: PUSH
17544: LD_VAR 0 1
17548: ADD
17549: ST_TO_ADDR
// Hint ( ident ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: CALL_OW 339
// end ; end ; end_of_file
17559: LD_VAR 0 2
17563: RET
// export people , sol , sci , mec , eng ; var cars , cargo , scout , attack , defence ; var scout1 , scout2 ; var builds , forts ; var scout1_pb , scout1_pr , scout1_ptr1 , scout1_ptl1 , scout1_ptr2 , scout1_pta , scout1_pl , scout1_pa , scout1_pd1 , scout1_pd2 ; var broken ; var attack_l , attack_m , attack_r ; var to_defence , to_attack , to_scout , to_cargo ; var sec ; every 0 0$0.1 do var temp1 ;
17564: GO 17566
17566: DISABLE
17567: LD_INT 0
17569: PPUSH
// begin to_defence := false ;
17570: LD_ADDR_LOC 25
17574: PUSH
17575: LD_INT 0
17577: ST_TO_ADDR
// to_attack := false ;
17578: LD_ADDR_LOC 26
17582: PUSH
17583: LD_INT 0
17585: ST_TO_ADDR
// to_scout := false ;
17586: LD_ADDR_LOC 27
17590: PUSH
17591: LD_INT 0
17593: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ f_side , russians ] ) ;
17594: LD_ADDR_VAR 0 1
17598: PUSH
17599: LD_INT 22
17601: PUSH
17602: LD_EXP 2
17606: PUSH
17607: EMPTY
17608: LIST
17609: LIST
17610: PPUSH
17611: CALL_OW 69
17615: ST_TO_ADDR
// ComRemember ( temp1 ) ;
17616: LD_VAR 0 1
17620: PPUSH
17621: CALL_OW 143
// people := UnitFilter ( temp1 , [ f_type , unit_human ] ) ;
17625: LD_ADDR_EXP 89
17629: PUSH
17630: LD_VAR 0 1
17634: PPUSH
17635: LD_INT 21
17637: PUSH
17638: LD_INT 1
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 72
17649: ST_TO_ADDR
// sol := UnitFilter ( people , [ f_class , class_soldier ] ) ;
17650: LD_ADDR_EXP 90
17654: PUSH
17655: LD_EXP 89
17659: PPUSH
17660: LD_INT 25
17662: PUSH
17663: LD_INT 1
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: PPUSH
17670: CALL_OW 72
17674: ST_TO_ADDR
// sci := UnitFilter ( people , [ f_class , class_scientistic ] ) ;
17675: LD_ADDR_EXP 91
17679: PUSH
17680: LD_EXP 89
17684: PPUSH
17685: LD_INT 25
17687: PUSH
17688: LD_INT 4
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: PPUSH
17695: CALL_OW 72
17699: ST_TO_ADDR
// mec := UnitFilter ( people , [ f_class , class_mechanic ] ) ;
17700: LD_ADDR_EXP 92
17704: PUSH
17705: LD_EXP 89
17709: PPUSH
17710: LD_INT 25
17712: PUSH
17713: LD_INT 3
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: PPUSH
17720: CALL_OW 72
17724: ST_TO_ADDR
// eng := UnitFilter ( people , [ f_class , class_engineer ] ) ;
17725: LD_ADDR_EXP 93
17729: PUSH
17730: LD_EXP 89
17734: PPUSH
17735: LD_INT 25
17737: PUSH
17738: LD_INT 2
17740: PUSH
17741: EMPTY
17742: LIST
17743: LIST
17744: PPUSH
17745: CALL_OW 72
17749: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ f_type , unit_vehicle ] ) ;
17750: LD_ADDR_LOC 2
17754: PUSH
17755: LD_VAR 0 1
17759: PPUSH
17760: LD_INT 21
17762: PUSH
17763: LD_INT 2
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PPUSH
17770: CALL_OW 72
17774: ST_TO_ADDR
// broken := [ ] ;
17775: LD_ADDR_LOC 21
17779: PUSH
17780: EMPTY
17781: ST_TO_ADDR
// cargo := [ cargo_1 ] ;
17782: LD_ADDR_LOC 3
17786: PUSH
17787: LD_INT 11
17789: PUSH
17790: EMPTY
17791: LIST
17792: ST_TO_ADDR
// scout := [ scout_1 , scout_2 ] ;
17793: LD_ADDR_LOC 4
17797: PUSH
17798: LD_INT 10
17800: PUSH
17801: LD_INT 42
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: ST_TO_ADDR
// scout1 := [ scout_1 ] ;
17808: LD_ADDR_LOC 7
17812: PUSH
17813: LD_INT 10
17815: PUSH
17816: EMPTY
17817: LIST
17818: ST_TO_ADDR
// scout2 := [ scout_2 ] ;
17819: LD_ADDR_LOC 8
17823: PUSH
17824: LD_INT 42
17826: PUSH
17827: EMPTY
17828: LIST
17829: ST_TO_ADDR
// defence := [ scout_2 , defence_1 , defence_2 ] ;
17830: LD_ADDR_LOC 6
17834: PUSH
17835: LD_INT 42
17837: PUSH
17838: LD_INT 12
17840: PUSH
17841: LD_INT 43
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: LIST
17848: ST_TO_ADDR
// attack := [ scout_1 , scout_2 , defence_1 ] ;
17849: LD_ADDR_LOC 5
17853: PUSH
17854: LD_INT 10
17856: PUSH
17857: LD_INT 42
17859: PUSH
17860: LD_INT 12
17862: PUSH
17863: EMPTY
17864: LIST
17865: LIST
17866: LIST
17867: ST_TO_ADDR
// builds := UnitFilter ( temp1 , [ f_type , unit_building ] ) ;
17868: LD_ADDR_LOC 9
17872: PUSH
17873: LD_VAR 0 1
17877: PPUSH
17878: LD_INT 21
17880: PUSH
17881: LD_INT 3
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PPUSH
17888: CALL_OW 72
17892: ST_TO_ADDR
// forts := [ fort1 , fort2 , fort3 , fort4 , fort5 ] ;
17893: LD_ADDR_LOC 10
17897: PUSH
17898: LD_INT 3
17900: PUSH
17901: LD_INT 2
17903: PUSH
17904: LD_INT 39
17906: PUSH
17907: LD_INT 4
17909: PUSH
17910: LD_INT 45
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: LIST
17917: LIST
17918: LIST
17919: ST_TO_ADDR
// scout1_pb := [ 92 , 53 ] ;
17920: LD_ADDR_LOC 11
17924: PUSH
17925: LD_INT 92
17927: PUSH
17928: LD_INT 53
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: ST_TO_ADDR
// scout1_pr := [ 102 , 56 , 110 , 59 , 119 , 60 , 120 , 64 , 109 , 60 , 98 , 55 ] ;
17935: LD_ADDR_LOC 12
17939: PUSH
17940: LD_INT 102
17942: PUSH
17943: LD_INT 56
17945: PUSH
17946: LD_INT 110
17948: PUSH
17949: LD_INT 59
17951: PUSH
17952: LD_INT 119
17954: PUSH
17955: LD_INT 60
17957: PUSH
17958: LD_INT 120
17960: PUSH
17961: LD_INT 64
17963: PUSH
17964: LD_INT 109
17966: PUSH
17967: LD_INT 60
17969: PUSH
17970: LD_INT 98
17972: PUSH
17973: LD_INT 55
17975: PUSH
17976: EMPTY
17977: LIST
17978: LIST
17979: LIST
17980: LIST
17981: LIST
17982: LIST
17983: LIST
17984: LIST
17985: LIST
17986: LIST
17987: LIST
17988: LIST
17989: ST_TO_ADDR
// scout1_ptr1 := [ 95 , 50 , 92 , 46 , 90 , 39 , 87 , 30 , - 8 , 97 , 25 , 80 , 32 , 82 , 42 ] ;
17990: LD_ADDR_LOC 13
17994: PUSH
17995: LD_INT 95
17997: PUSH
17998: LD_INT 50
18000: PUSH
18001: LD_INT 92
18003: PUSH
18004: LD_INT 46
18006: PUSH
18007: LD_INT 90
18009: PUSH
18010: LD_INT 39
18012: PUSH
18013: LD_INT 87
18015: PUSH
18016: LD_INT 30
18018: PUSH
18019: LD_INT 8
18021: NEG
18022: PUSH
18023: LD_INT 97
18025: PUSH
18026: LD_INT 25
18028: PUSH
18029: LD_INT 80
18031: PUSH
18032: LD_INT 32
18034: PUSH
18035: LD_INT 82
18037: PUSH
18038: LD_INT 42
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: ST_TO_ADDR
// scout1_ptr2 := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 69 , 21 , 82 , 39 , 87 , 48 ] ;
18058: LD_ADDR_LOC 15
18062: PUSH
18063: LD_INT 90
18065: PUSH
18066: LD_INT 42
18068: PUSH
18069: LD_INT 91
18071: PUSH
18072: LD_INT 30
18074: PUSH
18075: LD_INT 81
18077: PUSH
18078: LD_INT 13
18080: PUSH
18081: LD_INT 68
18083: PUSH
18084: LD_INT 12
18086: PUSH
18087: LD_INT 67
18089: PUSH
18090: LD_INT 21
18092: PUSH
18093: LD_INT 57
18095: PUSH
18096: LD_INT 25
18098: PUSH
18099: LD_INT 69
18101: PUSH
18102: LD_INT 21
18104: PUSH
18105: LD_INT 82
18107: PUSH
18108: LD_INT 39
18110: PUSH
18111: LD_INT 87
18113: PUSH
18114: LD_INT 48
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: LIST
18130: LIST
18131: LIST
18132: LIST
18133: LIST
18134: LIST
18135: LIST
18136: ST_TO_ADDR
// scout1_pta := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 41 , 20 , 29 , 23 , 42 , 41 , 85 , 49 ] ;
18137: LD_ADDR_LOC 16
18141: PUSH
18142: LD_INT 90
18144: PUSH
18145: LD_INT 42
18147: PUSH
18148: LD_INT 91
18150: PUSH
18151: LD_INT 30
18153: PUSH
18154: LD_INT 81
18156: PUSH
18157: LD_INT 13
18159: PUSH
18160: LD_INT 68
18162: PUSH
18163: LD_INT 12
18165: PUSH
18166: LD_INT 67
18168: PUSH
18169: LD_INT 21
18171: PUSH
18172: LD_INT 57
18174: PUSH
18175: LD_INT 25
18177: PUSH
18178: LD_INT 41
18180: PUSH
18181: LD_INT 20
18183: PUSH
18184: LD_INT 29
18186: PUSH
18187: LD_INT 23
18189: PUSH
18190: LD_INT 42
18192: PUSH
18193: LD_INT 41
18195: PUSH
18196: LD_INT 85
18198: PUSH
18199: LD_INT 49
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: ST_TO_ADDR
// scout1_ptl1 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 30 , 25 , 31 , 16 , 34 , 36 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18224: LD_ADDR_LOC 14
18228: PUSH
18229: LD_INT 68
18231: PUSH
18232: LD_INT 88
18234: PUSH
18235: LD_INT 51
18237: PUSH
18238: LD_INT 78
18240: PUSH
18241: LD_INT 40
18243: PUSH
18244: LD_INT 57
18246: PUSH
18247: LD_INT 43
18249: PUSH
18250: LD_INT 42
18252: PUSH
18253: LD_INT 30
18255: PUSH
18256: LD_INT 25
18258: PUSH
18259: LD_INT 31
18261: PUSH
18262: LD_INT 16
18264: PUSH
18265: LD_INT 34
18267: PUSH
18268: LD_INT 36
18270: PUSH
18271: LD_INT 45
18273: PUSH
18274: LD_INT 69
18276: PUSH
18277: LD_INT 64
18279: PUSH
18280: LD_INT 87
18282: PUSH
18283: LD_INT 98
18285: PUSH
18286: LD_INT 97
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: LIST
18299: LIST
18300: LIST
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: LIST
18308: LIST
18309: LIST
18310: ST_TO_ADDR
// scout1_pl := [ 84 , 50 , 70 , 47 , 67 , 46 , 62 , 49 , 55 , 49 , - 5 , 50 , 43 , 60 , 49 , 71 , 47 , 83 , 49 ] ;
18311: LD_ADDR_LOC 17
18315: PUSH
18316: LD_INT 84
18318: PUSH
18319: LD_INT 50
18321: PUSH
18322: LD_INT 70
18324: PUSH
18325: LD_INT 47
18327: PUSH
18328: LD_INT 67
18330: PUSH
18331: LD_INT 46
18333: PUSH
18334: LD_INT 62
18336: PUSH
18337: LD_INT 49
18339: PUSH
18340: LD_INT 55
18342: PUSH
18343: LD_INT 49
18345: PUSH
18346: LD_INT 5
18348: NEG
18349: PUSH
18350: LD_INT 50
18352: PUSH
18353: LD_INT 43
18355: PUSH
18356: LD_INT 60
18358: PUSH
18359: LD_INT 49
18361: PUSH
18362: LD_INT 71
18364: PUSH
18365: LD_INT 47
18367: PUSH
18368: LD_INT 83
18370: PUSH
18371: LD_INT 49
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: LIST
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: ST_TO_ADDR
// scout1_pa := [ 84 , 50 , 70 , 47 , 60 , 44 , 53 , 44 , 43 , 41 , 39 , 57 , 43 , 71 , 52 , 82 , 63 , 87 , 109 , 95 ] ;
18395: LD_ADDR_LOC 18
18399: PUSH
18400: LD_INT 84
18402: PUSH
18403: LD_INT 50
18405: PUSH
18406: LD_INT 70
18408: PUSH
18409: LD_INT 47
18411: PUSH
18412: LD_INT 60
18414: PUSH
18415: LD_INT 44
18417: PUSH
18418: LD_INT 53
18420: PUSH
18421: LD_INT 44
18423: PUSH
18424: LD_INT 43
18426: PUSH
18427: LD_INT 41
18429: PUSH
18430: LD_INT 39
18432: PUSH
18433: LD_INT 57
18435: PUSH
18436: LD_INT 43
18438: PUSH
18439: LD_INT 71
18441: PUSH
18442: LD_INT 52
18444: PUSH
18445: LD_INT 82
18447: PUSH
18448: LD_INT 63
18450: PUSH
18451: LD_INT 87
18453: PUSH
18454: LD_INT 109
18456: PUSH
18457: LD_INT 95
18459: PUSH
18460: EMPTY
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: LIST
18478: LIST
18479: LIST
18480: LIST
18481: ST_TO_ADDR
// scout1_pd1 := [ 71 , 81 , 62 , 63 , 61 , 74 , 79 , 96 ] ;
18482: LD_ADDR_LOC 19
18486: PUSH
18487: LD_INT 71
18489: PUSH
18490: LD_INT 81
18492: PUSH
18493: LD_INT 62
18495: PUSH
18496: LD_INT 63
18498: PUSH
18499: LD_INT 61
18501: PUSH
18502: LD_INT 74
18504: PUSH
18505: LD_INT 79
18507: PUSH
18508: LD_INT 96
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: LIST
18520: ST_TO_ADDR
// scout1_pd2 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18521: LD_ADDR_LOC 20
18525: PUSH
18526: LD_INT 68
18528: PUSH
18529: LD_INT 88
18531: PUSH
18532: LD_INT 51
18534: PUSH
18535: LD_INT 78
18537: PUSH
18538: LD_INT 40
18540: PUSH
18541: LD_INT 57
18543: PUSH
18544: LD_INT 43
18546: PUSH
18547: LD_INT 42
18549: PUSH
18550: LD_INT 45
18552: PUSH
18553: LD_INT 69
18555: PUSH
18556: LD_INT 64
18558: PUSH
18559: LD_INT 87
18561: PUSH
18562: LD_INT 98
18564: PUSH
18565: LD_INT 97
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: LIST
18583: ST_TO_ADDR
// attack_l := [ 60 , 86 , 37 , 44 ] ;
18584: LD_ADDR_LOC 22
18588: PUSH
18589: LD_INT 60
18591: PUSH
18592: LD_INT 86
18594: PUSH
18595: LD_INT 37
18597: PUSH
18598: LD_INT 44
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: ST_TO_ADDR
// attack_m := [ 89 , 53 , 41 , 42 ] ;
18607: LD_ADDR_LOC 23
18611: PUSH
18612: LD_INT 89
18614: PUSH
18615: LD_INT 53
18617: PUSH
18618: LD_INT 41
18620: PUSH
18621: LD_INT 42
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: ST_TO_ADDR
// attack_r := [ 88 , 55 , 82 , 13 ] ;
18630: LD_ADDR_LOC 24
18634: PUSH
18635: LD_INT 88
18637: PUSH
18638: LD_INT 55
18640: PUSH
18641: LD_INT 82
18643: PUSH
18644: LD_INT 13
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
// end ;
18653: PPOPN 1
18655: END
// every 0 0$6.0 do
18656: GO 18658
18658: DISABLE
// begin depart ( scout diff broken , sol union mec , scout1_pb , true , false ) ;
18659: LD_LOC 4
18663: PUSH
18664: LD_LOC 21
18668: DIFF
18669: PPUSH
18670: LD_EXP 90
18674: PUSH
18675: LD_EXP 92
18679: UNION
18680: PPUSH
18681: LD_LOC 11
18685: PPUSH
18686: LD_INT 1
18688: PPUSH
18689: LD_INT 0
18691: PPUSH
18692: CALL 16780 0 5
// take_path ( scout1 diff broken , scout1_pr , true ) ;
18696: LD_LOC 7
18700: PUSH
18701: LD_LOC 21
18705: DIFF
18706: PPUSH
18707: LD_LOC 12
18711: PPUSH
18712: LD_INT 1
18714: PPUSH
18715: CALL 15816 0 3
// take_path ( scout2 diff broken , scout1_pl , true ) ;
18719: LD_LOC 8
18723: PUSH
18724: LD_LOC 21
18728: DIFF
18729: PPUSH
18730: LD_LOC 17
18734: PPUSH
18735: LD_INT 1
18737: PPUSH
18738: CALL 15816 0 3
// AddComReturn ( scout diff broken ) ;
18742: LD_LOC 4
18746: PUSH
18747: LD_LOC 21
18751: DIFF
18752: PPUSH
18753: CALL_OW 204
// end ;
18757: END
// every 0 0$56.0 + 0 0$10 do var x , ok , i ;
18758: GO 18760
18760: DISABLE
18761: LD_INT 0
18763: PPUSH
18764: PPUSH
18765: PPUSH
// begin ok := true ;
18766: LD_ADDR_VAR 0 2
18770: PUSH
18771: LD_INT 1
18773: ST_TO_ADDR
// for i in scout do
18774: LD_ADDR_VAR 0 3
18778: PUSH
18779: LD_LOC 4
18783: PUSH
18784: FOR_IN
18785: IFFALSE 18808
// begin if HasTask ( i ) then
18787: LD_VAR 0 3
18791: PPUSH
18792: CALL_OW 314
18796: IFFALSE 18806
// ok := false ;
18798: LD_ADDR_VAR 0 2
18802: PUSH
18803: LD_INT 0
18805: ST_TO_ADDR
// end ;
18806: GO 18784
18808: POP
18809: POP
// if ok then
18810: LD_VAR 0 2
18814: IFFALSE 19706
// begin x := Rand ( 1 , 7 ) ;
18816: LD_ADDR_VAR 0 1
18820: PUSH
18821: LD_INT 1
18823: PPUSH
18824: LD_INT 7
18826: PPUSH
18827: CALL_OW 12
18831: ST_TO_ADDR
// if go_up then
18832: LD_EXP 62
18836: IFFALSE 18862
// begin x := Rand ( 3 , 4 ) ;
18838: LD_ADDR_VAR 0 1
18842: PUSH
18843: LD_INT 3
18845: PPUSH
18846: LD_INT 4
18848: PPUSH
18849: CALL_OW 12
18853: ST_TO_ADDR
// go_up := false ;
18854: LD_ADDR_EXP 62
18858: PUSH
18859: LD_INT 0
18861: ST_TO_ADDR
// end ; case x of 1 :
18862: LD_VAR 0 1
18866: PUSH
18867: LD_INT 1
18869: DOUBLE
18870: EQUAL
18871: IFTRUE 18875
18873: GO 19007
18875: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
18876: LD_LOC 7
18880: PUSH
18881: LD_LOC 21
18885: DIFF
18886: PPUSH
18887: LD_EXP 90
18891: PPUSH
18892: LD_LOC 11
18896: PPUSH
18897: LD_INT 1
18899: PPUSH
18900: LD_INT 0
18902: PPUSH
18903: CALL 16780 0 5
// if more_scouting then
18907: LD_EXP 61
18911: IFFALSE 18936
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
18913: LD_LOC 7
18917: PUSH
18918: LD_LOC 21
18922: DIFF
18923: PPUSH
18924: LD_LOC 13
18928: PPUSH
18929: LD_INT 1
18931: PPUSH
18932: CALL 15816 0 3
// take_path ( scout1 diff broken , scout1_pl , true ) ;
18936: LD_LOC 7
18940: PUSH
18941: LD_LOC 21
18945: DIFF
18946: PPUSH
18947: LD_LOC 17
18951: PPUSH
18952: LD_INT 1
18954: PPUSH
18955: CALL 15816 0 3
// depart ( scout2 diff broken , sol , scout1_pd1 , true , false ) ;
18959: LD_LOC 8
18963: PUSH
18964: LD_LOC 21
18968: DIFF
18969: PPUSH
18970: LD_EXP 90
18974: PPUSH
18975: LD_LOC 19
18979: PPUSH
18980: LD_INT 1
18982: PPUSH
18983: LD_INT 0
18985: PPUSH
18986: CALL 16780 0 5
// AddComReturn ( scout diff broken ) ;
18990: LD_LOC 4
18994: PUSH
18995: LD_LOC 21
18999: DIFF
19000: PPUSH
19001: CALL_OW 204
// end ; 2 :
19005: GO 19706
19007: LD_INT 2
19009: DOUBLE
19010: EQUAL
19011: IFTRUE 19015
19013: GO 19124
19015: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
19016: LD_LOC 7
19020: PUSH
19021: LD_LOC 21
19025: DIFF
19026: PPUSH
19027: LD_EXP 90
19031: PPUSH
19032: LD_LOC 11
19036: PPUSH
19037: LD_INT 1
19039: PPUSH
19040: LD_INT 0
19042: PPUSH
19043: CALL 16780 0 5
// if more_scouting then
19047: LD_EXP 61
19051: IFFALSE 19076
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19053: LD_LOC 7
19057: PUSH
19058: LD_LOC 21
19062: DIFF
19063: PPUSH
19064: LD_LOC 13
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL 15816 0 3
// depart ( scout2 diff broken , sol , scout1_pd2 , true , false ) ;
19076: LD_LOC 8
19080: PUSH
19081: LD_LOC 21
19085: DIFF
19086: PPUSH
19087: LD_EXP 90
19091: PPUSH
19092: LD_LOC 20
19096: PPUSH
19097: LD_INT 1
19099: PPUSH
19100: LD_INT 0
19102: PPUSH
19103: CALL 16780 0 5
// AddComReturn ( scout1 diff broken ) ;
19107: LD_LOC 7
19111: PUSH
19112: LD_LOC 21
19116: DIFF
19117: PPUSH
19118: CALL_OW 204
// end ; 3 :
19122: GO 19706
19124: LD_INT 3
19126: DOUBLE
19127: EQUAL
19128: IFTRUE 19132
19130: GO 19210
19132: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19133: LD_LOC 4
19137: PUSH
19138: LD_LOC 21
19142: DIFF
19143: PPUSH
19144: LD_EXP 90
19148: PPUSH
19149: LD_LOC 11
19153: PPUSH
19154: LD_INT 1
19156: PPUSH
19157: LD_INT 0
19159: PPUSH
19160: CALL 16780 0 5
// if more_scouting then
19164: LD_EXP 61
19168: IFFALSE 19193
// take_path ( scout diff broken , scout1_ptr2 , true ) ;
19170: LD_LOC 4
19174: PUSH
19175: LD_LOC 21
19179: DIFF
19180: PPUSH
19181: LD_LOC 15
19185: PPUSH
19186: LD_INT 1
19188: PPUSH
19189: CALL 15816 0 3
// AddComReturn ( scout diff broken ) ;
19193: LD_LOC 4
19197: PUSH
19198: LD_LOC 21
19202: DIFF
19203: PPUSH
19204: CALL_OW 204
// end ; 4 :
19208: GO 19706
19210: LD_INT 4
19212: DOUBLE
19213: EQUAL
19214: IFTRUE 19218
19216: GO 19337
19218: POP
// begin if more_scouting then
19219: LD_EXP 61
19223: IFFALSE 19258
// depart ( scout diff broken , sol , scout1_pta , true , false ) else
19225: LD_LOC 4
19229: PUSH
19230: LD_LOC 21
19234: DIFF
19235: PPUSH
19236: LD_EXP 90
19240: PPUSH
19241: LD_LOC 16
19245: PPUSH
19246: LD_INT 1
19248: PPUSH
19249: LD_INT 0
19251: PPUSH
19252: CALL 16780 0 5
19256: GO 19320
// begin depart ( scout1 diff broken , sol , scout1_pd2 , true , false ) ;
19258: LD_LOC 7
19262: PUSH
19263: LD_LOC 21
19267: DIFF
19268: PPUSH
19269: LD_EXP 90
19273: PPUSH
19274: LD_LOC 20
19278: PPUSH
19279: LD_INT 1
19281: PPUSH
19282: LD_INT 0
19284: PPUSH
19285: CALL 16780 0 5
// depart ( scout2 diff broken , sol , scout1_ptr1 , true , false ) ;
19289: LD_LOC 8
19293: PUSH
19294: LD_LOC 21
19298: DIFF
19299: PPUSH
19300: LD_EXP 90
19304: PPUSH
19305: LD_LOC 13
19309: PPUSH
19310: LD_INT 1
19312: PPUSH
19313: LD_INT 0
19315: PPUSH
19316: CALL 16780 0 5
// end ; AddComReturn ( scout diff broken ) ;
19320: LD_LOC 4
19324: PUSH
19325: LD_LOC 21
19329: DIFF
19330: PPUSH
19331: CALL_OW 204
// end ; 5 :
19335: GO 19706
19337: LD_INT 5
19339: DOUBLE
19340: EQUAL
19341: IFTRUE 19345
19343: GO 19489
19345: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19346: LD_LOC 4
19350: PUSH
19351: LD_LOC 21
19355: DIFF
19356: PPUSH
19357: LD_EXP 90
19361: PPUSH
19362: LD_LOC 11
19366: PPUSH
19367: LD_INT 1
19369: PPUSH
19370: LD_INT 0
19372: PPUSH
19373: CALL 16780 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19377: LD_LOC 7
19381: PUSH
19382: LD_LOC 21
19386: DIFF
19387: PPUSH
19388: LD_LOC 17
19392: PPUSH
19393: LD_INT 1
19395: PPUSH
19396: CALL 15816 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19400: LD_LOC 8
19404: PUSH
19405: LD_LOC 21
19409: DIFF
19410: PPUSH
19411: LD_INT 20
19413: PPUSH
19414: CALL_OW 202
// if more_scouting then
19418: LD_EXP 61
19422: IFFALSE 19449
// take_path ( scout2 diff broken , scout1_ptl1 , true ) else
19424: LD_LOC 8
19428: PUSH
19429: LD_LOC 21
19433: DIFF
19434: PPUSH
19435: LD_LOC 14
19439: PPUSH
19440: LD_INT 1
19442: PPUSH
19443: CALL 15816 0 3
19447: GO 19472
// take_path ( scout2 diff broken , scout1_pd2 , true ) ;
19449: LD_LOC 8
19453: PUSH
19454: LD_LOC 21
19458: DIFF
19459: PPUSH
19460: LD_LOC 20
19464: PPUSH
19465: LD_INT 1
19467: PPUSH
19468: CALL 15816 0 3
// AddComReturn ( scout diff broken ) ;
19472: LD_LOC 4
19476: PUSH
19477: LD_LOC 21
19481: DIFF
19482: PPUSH
19483: CALL_OW 204
// end ; 6 :
19487: GO 19706
19489: LD_INT 6
19491: DOUBLE
19492: EQUAL
19493: IFTRUE 19497
19495: GO 19587
19497: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19498: LD_LOC 4
19502: PUSH
19503: LD_LOC 21
19507: DIFF
19508: PPUSH
19509: LD_EXP 90
19513: PPUSH
19514: LD_LOC 11
19518: PPUSH
19519: LD_INT 1
19521: PPUSH
19522: LD_INT 0
19524: PPUSH
19525: CALL 16780 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19529: LD_LOC 7
19533: PUSH
19534: LD_LOC 21
19538: DIFF
19539: PPUSH
19540: LD_LOC 17
19544: PPUSH
19545: LD_INT 1
19547: PPUSH
19548: CALL 15816 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19552: LD_LOC 8
19556: PUSH
19557: LD_LOC 21
19561: DIFF
19562: PPUSH
19563: LD_INT 20
19565: PPUSH
19566: CALL_OW 202
// AddComReturn ( scout diff broken ) ;
19570: LD_LOC 4
19574: PUSH
19575: LD_LOC 21
19579: DIFF
19580: PPUSH
19581: CALL_OW 204
// end ; 7 :
19585: GO 19706
19587: LD_INT 7
19589: DOUBLE
19590: EQUAL
19591: IFTRUE 19595
19593: GO 19705
19595: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19596: LD_LOC 4
19600: PUSH
19601: LD_LOC 21
19605: DIFF
19606: PPUSH
19607: LD_EXP 90
19611: PPUSH
19612: LD_LOC 11
19616: PPUSH
19617: LD_INT 1
19619: PPUSH
19620: LD_INT 0
19622: PPUSH
19623: CALL 16780 0 5
// take_path ( scout1 diff broken , scout1_pa , true ) ;
19627: LD_LOC 7
19631: PUSH
19632: LD_LOC 21
19636: DIFF
19637: PPUSH
19638: LD_LOC 18
19642: PPUSH
19643: LD_INT 1
19645: PPUSH
19646: CALL 15816 0 3
// AddComReturn ( scout2 diff broken ) ;
19650: LD_LOC 8
19654: PUSH
19655: LD_LOC 21
19659: DIFF
19660: PPUSH
19661: CALL_OW 204
// take_path ( scout2 diff broken , scout1_pd1 , true ) ;
19665: LD_LOC 8
19669: PUSH
19670: LD_LOC 21
19674: DIFF
19675: PPUSH
19676: LD_LOC 19
19680: PPUSH
19681: LD_INT 1
19683: PPUSH
19684: CALL 15816 0 3
// AddComReturn ( scout diff broken ) ;
19688: LD_LOC 4
19692: PUSH
19693: LD_LOC 21
19697: DIFF
19698: PPUSH
19699: CALL_OW 204
// end ; end ;
19703: GO 19706
19705: POP
// end ; enable ;
19706: ENABLE
// end ;
19707: PPOPN 3
19709: END
// every 0 0$7.0 do
19710: GO 19712
19712: DISABLE
// begin full_forts ( forts , sol ) ;
19713: LD_LOC 10
19717: PPUSH
19718: LD_EXP 90
19722: PPUSH
19723: CALL 16508 0 2
// enable ;
19727: ENABLE
// end ;
19728: END
// every 0 0$5.0 do var i ;
19729: GO 19731
19731: DISABLE
19732: LD_INT 0
19734: PPUSH
// begin for i in mec do
19735: LD_ADDR_VAR 0 1
19739: PUSH
19740: LD_EXP 92
19744: PUSH
19745: FOR_IN
19746: IFFALSE 19806
// begin if not IsBusy ( i ) or not IsInArea ( i , base ) and GetSide ( i ) <> you then
19748: LD_VAR 0 1
19752: PPUSH
19753: CALL_OW 315
19757: NOT
19758: PUSH
19759: LD_VAR 0 1
19763: PPUSH
19764: LD_INT 5
19766: PPUSH
19767: CALL_OW 308
19771: NOT
19772: PUSH
19773: LD_VAR 0 1
19777: PPUSH
19778: CALL_OW 255
19782: PUSH
19783: LD_EXP 1
19787: NONEQUAL
19788: AND
19789: OR
19790: IFFALSE 19804
// ComEnterUnit ( i , fact1 ) ;
19792: LD_VAR 0 1
19796: PPUSH
19797: LD_INT 35
19799: PPUSH
19800: CALL_OW 120
// end ;
19804: GO 19745
19806: POP
19807: POP
// enable ;
19808: ENABLE
// end ;
19809: PPOPN 1
19811: END
// every 0 0$5.0 do var i ;
19812: GO 19814
19814: DISABLE
19815: LD_INT 0
19817: PPUSH
// begin if under_attack then
19818: LD_EXP 64
19822: IFFALSE 19884
// for i in eng do
19824: LD_ADDR_VAR 0 1
19828: PUSH
19829: LD_EXP 93
19833: PUSH
19834: FOR_IN
19835: IFFALSE 19880
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
19837: LD_VAR 0 1
19841: PPUSH
19842: CALL_OW 315
19846: NOT
19847: PUSH
19848: LD_VAR 0 1
19852: PPUSH
19853: CALL_OW 255
19857: PUSH
19858: LD_EXP 1
19862: NONEQUAL
19863: AND
19864: IFFALSE 19878
// ComEnterUnit ( i , depot1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_INT 1
19873: PPUSH
19874: CALL_OW 120
// end else
19878: GO 19834
19880: POP
19881: POP
19882: GO 19891
// ComExitBuilding ( depot1 ) ;
19884: LD_INT 1
19886: PPUSH
19887: CALL_OW 122
// enable ;
19891: ENABLE
// end ;
19892: PPOPN 1
19894: END
// every 0 0$5.0 do var i ;
19895: GO 19897
19897: DISABLE
19898: LD_INT 0
19900: PPUSH
// begin for i in sci do
19901: LD_ADDR_VAR 0 1
19905: PUSH
19906: LD_EXP 91
19910: PUSH
19911: FOR_IN
19912: IFFALSE 19957
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
19914: LD_VAR 0 1
19918: PPUSH
19919: CALL_OW 315
19923: NOT
19924: PUSH
19925: LD_VAR 0 1
19929: PPUSH
19930: CALL_OW 255
19934: PUSH
19935: LD_EXP 1
19939: NONEQUAL
19940: AND
19941: IFFALSE 19955
// ComEnterUnit ( i , lab1 ) ;
19943: LD_VAR 0 1
19947: PPUSH
19948: LD_INT 6
19950: PPUSH
19951: CALL_OW 120
// end ;
19955: GO 19911
19957: POP
19958: POP
// enable ;
19959: ENABLE
// end ;
19960: PPOPN 1
19962: END
// every 0 0$1.0 do var set_fuel , fuel ;
19963: GO 19965
19965: DISABLE
19966: LD_INT 0
19968: PPUSH
19969: PPUSH
// begin for set_fuel in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
19970: LD_ADDR_VAR 0 1
19974: PUSH
19975: LD_INT 5
19977: PPUSH
19978: LD_INT 21
19980: PUSH
19981: LD_INT 2
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: PUSH
19988: LD_INT 22
19990: PUSH
19991: LD_EXP 2
19995: PUSH
19996: EMPTY
19997: LIST
19998: LIST
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: PPUSH
20004: CALL_OW 70
20008: PUSH
20009: FOR_IN
20010: IFFALSE 20057
// begin fuel := GetFuel ( set_fuel ) ;
20012: LD_ADDR_VAR 0 2
20016: PUSH
20017: LD_VAR 0 1
20021: PPUSH
20022: CALL_OW 261
20026: ST_TO_ADDR
// if fuel <= 80 then
20027: LD_VAR 0 2
20031: PUSH
20032: LD_INT 80
20034: LESSEQUAL
20035: IFFALSE 20055
// SetFuel ( set_fuel , fuel + 20 ) ;
20037: LD_VAR 0 1
20041: PPUSH
20042: LD_VAR 0 2
20046: PUSH
20047: LD_INT 20
20049: PLUS
20050: PPUSH
20051: CALL_OW 240
// end ;
20055: GO 20009
20057: POP
20058: POP
// enable ;
20059: ENABLE
// end ;
20060: PPOPN 2
20062: END
// every 0 0$1.0 do var to_rep , prednost ;
20063: GO 20065
20065: DISABLE
20066: LD_INT 0
20068: PPUSH
20069: PPUSH
// begin prednost := FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) isect broken ;
20070: LD_ADDR_VAR 0 2
20074: PUSH
20075: LD_INT 5
20077: PPUSH
20078: LD_INT 21
20080: PUSH
20081: LD_INT 2
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_EXP 2
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: PPUSH
20104: CALL_OW 70
20108: PUSH
20109: LD_LOC 21
20113: ISECT
20114: ST_TO_ADDR
// if prednost then
20115: LD_VAR 0 2
20119: IFFALSE 20272
// for to_rep in prednost do
20121: LD_ADDR_VAR 0 1
20125: PUSH
20126: LD_VAR 0 2
20130: PUSH
20131: FOR_IN
20132: IFFALSE 20268
// begin if IsInArea ( to_rep , base ) then
20134: LD_VAR 0 1
20138: PPUSH
20139: LD_INT 5
20141: PPUSH
20142: CALL_OW 308
20146: IFFALSE 20266
// if GetLives ( to_rep ) < 1000 then
20148: LD_VAR 0 1
20152: PPUSH
20153: CALL_OW 256
20157: PUSH
20158: LD_INT 1000
20160: LESS
20161: IFFALSE 20241
// begin ComExitBuilding ( mec ) ;
20163: LD_EXP 92
20167: PPUSH
20168: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20172: LD_EXP 92
20176: PPUSH
20177: LD_VAR 0 1
20181: PPUSH
20182: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20186: LD_VAR 0 1
20190: PPUSH
20191: CALL_OW 311
20195: PPUSH
20196: CALL_OW 257
20200: PUSH
20201: LD_INT 3
20203: EQUAL
20204: IFFALSE 20239
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20206: LD_VAR 0 1
20210: PPUSH
20211: CALL_OW 311
20215: PPUSH
20216: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20220: LD_VAR 0 1
20224: PPUSH
20225: CALL_OW 311
20229: PPUSH
20230: LD_VAR 0 1
20234: PPUSH
20235: CALL_OW 189
// end ; end else
20239: GO 20266
// begin broken := broken diff to_rep ;
20241: LD_ADDR_LOC 21
20245: PUSH
20246: LD_LOC 21
20250: PUSH
20251: LD_VAR 0 1
20255: DIFF
20256: ST_TO_ADDR
// ComReturn ( to_rep ) ;
20257: LD_VAR 0 1
20261: PPUSH
20262: CALL_OW 144
// end ; end else
20266: GO 20131
20268: POP
20269: POP
20270: GO 20423
// for to_rep in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20272: LD_ADDR_VAR 0 1
20276: PUSH
20277: LD_INT 5
20279: PPUSH
20280: LD_INT 21
20282: PUSH
20283: LD_INT 2
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 22
20292: PUSH
20293: LD_EXP 2
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: PPUSH
20306: CALL_OW 70
20310: PUSH
20311: FOR_IN
20312: IFFALSE 20421
// begin if IsInArea ( to_rep , base ) then
20314: LD_VAR 0 1
20318: PPUSH
20319: LD_INT 5
20321: PPUSH
20322: CALL_OW 308
20326: IFFALSE 20419
// if GetLives ( to_rep ) < 1000 then
20328: LD_VAR 0 1
20332: PPUSH
20333: CALL_OW 256
20337: PUSH
20338: LD_INT 1000
20340: LESS
20341: IFFALSE 20419
// begin ComExitBuilding ( mec ) ;
20343: LD_EXP 92
20347: PPUSH
20348: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20352: LD_EXP 92
20356: PPUSH
20357: LD_VAR 0 1
20361: PPUSH
20362: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20366: LD_VAR 0 1
20370: PPUSH
20371: CALL_OW 311
20375: PPUSH
20376: CALL_OW 257
20380: PUSH
20381: LD_INT 3
20383: EQUAL
20384: IFFALSE 20419
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20386: LD_VAR 0 1
20390: PPUSH
20391: CALL_OW 311
20395: PPUSH
20396: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20400: LD_VAR 0 1
20404: PPUSH
20405: CALL_OW 311
20409: PPUSH
20410: LD_VAR 0 1
20414: PPUSH
20415: CALL_OW 189
// end ; end ; end ;
20419: GO 20311
20421: POP
20422: POP
// enable ;
20423: ENABLE
// end ;
20424: PPOPN 2
20426: END
// every 0 0$0.5 do var i , a ;
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
// begin for i in cars do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_LOC 2
20443: PUSH
20444: FOR_IN
20445: IFFALSE 20553
// begin if GetLives ( i ) < 550 then
20447: LD_VAR 0 1
20451: PPUSH
20452: CALL_OW 256
20456: PUSH
20457: LD_INT 550
20459: LESS
20460: IFFALSE 20493
// begin ComMoveXY ( i , 112 , 89 ) ;
20462: LD_VAR 0 1
20466: PPUSH
20467: LD_INT 112
20469: PPUSH
20470: LD_INT 89
20472: PPUSH
20473: CALL_OW 111
// broken := broken union i ;
20477: LD_ADDR_LOC 21
20481: PUSH
20482: LD_LOC 21
20486: PUSH
20487: LD_VAR 0 1
20491: UNION
20492: ST_TO_ADDR
// end ; if i in cargo and GetLives ( i ) < 800 then
20493: LD_VAR 0 1
20497: PUSH
20498: LD_LOC 3
20502: IN
20503: PUSH
20504: LD_VAR 0 1
20508: PPUSH
20509: CALL_OW 256
20513: PUSH
20514: LD_INT 800
20516: LESS
20517: AND
20518: IFFALSE 20551
// begin ComMoveXY ( i , 112 , 89 ) ;
20520: LD_VAR 0 1
20524: PPUSH
20525: LD_INT 112
20527: PPUSH
20528: LD_INT 89
20530: PPUSH
20531: CALL_OW 111
// broken := broken union i ;
20535: LD_ADDR_LOC 21
20539: PUSH
20540: LD_LOC 21
20544: PUSH
20545: LD_VAR 0 1
20549: UNION
20550: ST_TO_ADDR
// end ; end ;
20551: GO 20444
20553: POP
20554: POP
// enable ;
20555: ENABLE
// end ;
20556: PPOPN 2
20558: END
// var zasek_cargo ; every 1 1$0 do var j , pojedou , new ;
20559: GO 20561
20561: DISABLE
20562: LD_INT 0
20564: PPUSH
20565: PPUSH
20566: PPUSH
// begin SetFuel ( cargo , 100 ) ;
20567: LD_LOC 3
20571: PPUSH
20572: LD_INT 100
20574: PPUSH
20575: CALL_OW 240
// if not HasTask ( Cargo ) and GetLives ( Cargo ) >= 900 and crates >= 2 then
20579: LD_LOC 3
20583: PPUSH
20584: CALL_OW 314
20588: NOT
20589: PUSH
20590: LD_LOC 3
20594: PPUSH
20595: CALL_OW 256
20599: PUSH
20600: LD_INT 900
20602: GREATEREQUAL
20603: AND
20604: PUSH
20605: LD_EXP 76
20609: PUSH
20610: LD_INT 2
20612: GREATEREQUAL
20613: AND
20614: IFFALSE 20829
// begin new := [ ] ;
20616: LD_ADDR_VAR 0 3
20620: PUSH
20621: EMPTY
20622: ST_TO_ADDR
// pojedou := find_drivers ( cargo , sol , false ) ;
20623: LD_ADDR_VAR 0 2
20627: PUSH
20628: LD_LOC 3
20632: PPUSH
20633: LD_EXP 90
20637: PPUSH
20638: LD_INT 0
20640: PPUSH
20641: CALL 16163 0 3
20645: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20646: LD_VAR 0 2
20650: PPUSH
20651: CALL 16842 0 1
// for j := 1 to 2 do
20655: LD_ADDR_VAR 0 1
20659: PUSH
20660: DOUBLE
20661: LD_INT 1
20663: DEC
20664: ST_TO_ADDR
20665: LD_INT 2
20667: PUSH
20668: FOR_TO
20669: IFFALSE 20751
// begin if InArea ( crates [ j ] [ 1 ] , crates [ j ] [ 2 ] , pod_cestou ) then
20671: LD_EXP 76
20675: PUSH
20676: LD_VAR 0 1
20680: ARRAY
20681: PUSH
20682: LD_INT 1
20684: ARRAY
20685: PPUSH
20686: LD_EXP 76
20690: PUSH
20691: LD_VAR 0 1
20695: ARRAY
20696: PUSH
20697: LD_INT 2
20699: ARRAY
20700: PPUSH
20701: LD_INT 6
20703: PPUSH
20704: CALL_OW 309
20708: IFFALSE 20749
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
20710: LD_VAR 0 2
20714: PPUSH
20715: LD_EXP 76
20719: PUSH
20720: LD_VAR 0 1
20724: ARRAY
20725: PUSH
20726: LD_INT 1
20728: ARRAY
20729: PPUSH
20730: LD_EXP 76
20734: PUSH
20735: LD_VAR 0 1
20739: ARRAY
20740: PUSH
20741: LD_INT 2
20743: ARRAY
20744: PPUSH
20745: CALL_OW 177
// end ; end ;
20749: GO 20668
20751: POP
20752: POP
// for j := 3 to crates do
20753: LD_ADDR_VAR 0 1
20757: PUSH
20758: DOUBLE
20759: LD_INT 3
20761: DEC
20762: ST_TO_ADDR
20763: LD_EXP 76
20767: PUSH
20768: FOR_TO
20769: IFFALSE 20798
// begin new := new ^ [ crates [ j ] ] ;
20771: LD_ADDR_VAR 0 3
20775: PUSH
20776: LD_VAR 0 3
20780: PUSH
20781: LD_EXP 76
20785: PUSH
20786: LD_VAR 0 1
20790: ARRAY
20791: PUSH
20792: EMPTY
20793: LIST
20794: ADD
20795: ST_TO_ADDR
// end ;
20796: GO 20768
20798: POP
20799: POP
// crates := new ;
20800: LD_ADDR_EXP 76
20804: PUSH
20805: LD_VAR 0 3
20809: ST_TO_ADDR
// AddComReturn ( pojedou ) ;
20810: LD_VAR 0 2
20814: PPUSH
20815: CALL_OW 204
// zasek_cargo := 1 ;
20819: LD_ADDR_LOC 30
20823: PUSH
20824: LD_INT 1
20826: ST_TO_ADDR
// end else
20827: GO 20894
// begin zasek_cargo := zasek_cargo + 1 ;
20829: LD_ADDR_LOC 30
20833: PUSH
20834: LD_LOC 30
20838: PUSH
20839: LD_INT 1
20841: PLUS
20842: ST_TO_ADDR
// if zasek_cargo > 5 then
20843: LD_LOC 30
20847: PUSH
20848: LD_INT 5
20850: GREATER
20851: IFFALSE 20894
// begin pojedou := find_drivers ( cargo , sol , false ) ;
20853: LD_ADDR_VAR 0 2
20857: PUSH
20858: LD_LOC 3
20862: PPUSH
20863: LD_EXP 90
20867: PPUSH
20868: LD_INT 0
20870: PPUSH
20871: CALL 16163 0 3
20875: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20876: LD_VAR 0 2
20880: PPUSH
20881: CALL 16842 0 1
// ComReturn ( cargo ) ;
20885: LD_LOC 3
20889: PPUSH
20890: CALL_OW 144
// end ; end ; enable ;
20894: ENABLE
// end ;
20895: PPOPN 3
20897: END
// every 0 0$1 do var rusi , i ;
20898: GO 20900
20900: DISABLE
20901: LD_INT 0
20903: PPUSH
20904: PPUSH
// begin rusi := FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , russians ] , [ f_see , you ] ] ) ;
20905: LD_ADDR_VAR 0 1
20909: PUSH
20910: LD_INT 3
20912: PUSH
20913: LD_INT 21
20915: PUSH
20916: LD_INT 3
20918: PUSH
20919: EMPTY
20920: LIST
20921: LIST
20922: PUSH
20923: LD_INT 22
20925: PUSH
20926: LD_EXP 2
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: LD_INT 101
20937: PUSH
20938: LD_EXP 1
20942: PUSH
20943: EMPTY
20944: LIST
20945: LIST
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: PPUSH
20953: CALL_OW 69
20957: ST_TO_ADDR
// if rusi then
20958: LD_VAR 0 1
20962: IFFALSE 21162
// begin if FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_see , russians ] ] ) diff prilet_tvoji then
20964: LD_INT 3
20966: PUSH
20967: LD_INT 21
20969: PUSH
20970: LD_INT 3
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PUSH
20977: LD_INT 22
20979: PUSH
20980: LD_EXP 1
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: PUSH
20989: LD_INT 101
20991: PUSH
20992: LD_EXP 2
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: PPUSH
21007: CALL_OW 69
21011: PUSH
21012: LD_EXP 6
21016: DIFF
21017: IFFALSE 21162
// begin attacky := attacky + 1 ;
21019: LD_ADDR_EXP 60
21023: PUSH
21024: LD_EXP 60
21028: PUSH
21029: LD_INT 1
21031: PLUS
21032: ST_TO_ADDR
// if not more_scouting and attacky > attack_to_scouting then
21033: LD_EXP 61
21037: NOT
21038: PUSH
21039: LD_EXP 60
21043: PUSH
21044: LD_EXP 67
21048: GREATER
21049: AND
21050: IFFALSE 21068
// begin more_scouting := true ;
21052: LD_ADDR_EXP 61
21056: PUSH
21057: LD_INT 1
21059: ST_TO_ADDR
// go_up := true ;
21060: LD_ADDR_EXP 62
21064: PUSH
21065: LD_INT 1
21067: ST_TO_ADDR
// end ; for i in scout diff broken do
21068: LD_ADDR_VAR 0 2
21072: PUSH
21073: LD_LOC 4
21077: PUSH
21078: LD_LOC 21
21082: DIFF
21083: PUSH
21084: FOR_IN
21085: IFFALSE 21160
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_dist , i , 8 ] ] ) , i ) ) ;
21087: LD_VAR 0 2
21091: PPUSH
21092: LD_INT 3
21094: PUSH
21095: LD_INT 21
21097: PUSH
21098: LD_INT 3
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: LD_INT 22
21107: PUSH
21108: LD_EXP 1
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: PUSH
21117: LD_INT 91
21119: PUSH
21120: LD_VAR 0 2
21124: PUSH
21125: LD_INT 8
21127: PUSH
21128: EMPTY
21129: LIST
21130: LIST
21131: LIST
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: LIST
21137: LIST
21138: PPUSH
21139: CALL_OW 69
21143: PPUSH
21144: LD_VAR 0 2
21148: PPUSH
21149: CALL_OW 74
21153: PPUSH
21154: CALL_OW 115
// end ;
21158: GO 21084
21160: POP
21161: POP
// end ; end ; enable ;
21162: ENABLE
// end ;
21163: PPOPN 2
21165: END
// every 13 13$0 do
21166: GO 21168
21168: DISABLE
// begin wait ( start_scouting ) ;
21169: LD_EXP 68
21173: PPUSH
21174: CALL_OW 67
// more_scouting := true ;
21178: LD_ADDR_EXP 61
21182: PUSH
21183: LD_INT 1
21185: ST_TO_ADDR
// go_up := true ;
21186: LD_ADDR_EXP 62
21190: PUSH
21191: LD_INT 1
21193: ST_TO_ADDR
// end ;
21194: END
// every 0 0$3 + 0 0$30 do var all1 , all , parked , ridici , i , rid , c ;
21195: GO 21197
21197: DISABLE
21198: LD_INT 0
21200: PPUSH
21201: PPUSH
21202: PPUSH
21203: PPUSH
21204: PPUSH
21205: PPUSH
21206: PPUSH
// begin all1 := FilterUnitsInArea ( near_base , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21207: LD_ADDR_VAR 0 1
21211: PUSH
21212: LD_INT 4
21214: PPUSH
21215: LD_INT 22
21217: PUSH
21218: LD_EXP 2
21222: PUSH
21223: EMPTY
21224: LIST
21225: LIST
21226: PUSH
21227: LD_INT 21
21229: PUSH
21230: LD_INT 2
21232: PUSH
21233: EMPTY
21234: LIST
21235: LIST
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: PPUSH
21241: CALL_OW 70
21245: ST_TO_ADDR
// for i in all1 do
21246: LD_ADDR_VAR 0 5
21250: PUSH
21251: LD_VAR 0 1
21255: PUSH
21256: FOR_IN
21257: IFFALSE 21292
// if not UnitsInside ( i ) then
21259: LD_VAR 0 5
21263: PPUSH
21264: CALL_OW 313
21268: NOT
21269: IFFALSE 21290
// all := all ^ [ i ] ;
21271: LD_ADDR_VAR 0 2
21275: PUSH
21276: LD_VAR 0 2
21280: PUSH
21281: LD_VAR 0 5
21285: PUSH
21286: EMPTY
21287: LIST
21288: ADD
21289: ST_TO_ADDR
21290: GO 21256
21292: POP
21293: POP
// parked := FilterUnitsInArea ( parkoviste , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21294: LD_ADDR_VAR 0 3
21298: PUSH
21299: LD_INT 13
21301: PPUSH
21302: LD_INT 22
21304: PUSH
21305: LD_EXP 2
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: PUSH
21314: LD_INT 21
21316: PUSH
21317: LD_INT 2
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: PPUSH
21328: CALL_OW 70
21332: ST_TO_ADDR
// ridici := UnitFilter ( sol ^ sci ^ eng , [ f_outside ] ) ;
21333: LD_ADDR_VAR 0 4
21337: PUSH
21338: LD_EXP 90
21342: PUSH
21343: LD_EXP 91
21347: ADD
21348: PUSH
21349: LD_EXP 93
21353: ADD
21354: PPUSH
21355: LD_INT 56
21357: PUSH
21358: EMPTY
21359: LIST
21360: PPUSH
21361: CALL_OW 72
21365: ST_TO_ADDR
// all := all diff parked ;
21366: LD_ADDR_VAR 0 2
21370: PUSH
21371: LD_VAR 0 2
21375: PUSH
21376: LD_VAR 0 3
21380: DIFF
21381: ST_TO_ADDR
// all := all diff [ 0 ] ;
21382: LD_ADDR_VAR 0 2
21386: PUSH
21387: LD_VAR 0 2
21391: PUSH
21392: LD_INT 0
21394: PUSH
21395: EMPTY
21396: LIST
21397: DIFF
21398: ST_TO_ADDR
// all := all diff cargo ;
21399: LD_ADDR_VAR 0 2
21403: PUSH
21404: LD_VAR 0 2
21408: PUSH
21409: LD_LOC 3
21413: DIFF
21414: ST_TO_ADDR
// if ridici then
21415: LD_VAR 0 4
21419: IFFALSE 22148
// for i in all do
21421: LD_ADDR_VAR 0 5
21425: PUSH
21426: LD_VAR 0 2
21430: PUSH
21431: FOR_IN
21432: IFFALSE 22146
// begin rid := ridici [ 1 ] ;
21434: LD_ADDR_VAR 0 6
21438: PUSH
21439: LD_VAR 0 4
21443: PUSH
21444: LD_INT 1
21446: ARRAY
21447: ST_TO_ADDR
// ridici := ridici diff rid ;
21448: LD_ADDR_VAR 0 4
21452: PUSH
21453: LD_VAR 0 4
21457: PUSH
21458: LD_VAR 0 6
21462: DIFF
21463: ST_TO_ADDR
// sol := sol diff rid ;
21464: LD_ADDR_EXP 90
21468: PUSH
21469: LD_EXP 90
21473: PUSH
21474: LD_VAR 0 6
21478: DIFF
21479: ST_TO_ADDR
// sci := sci diff rid ;
21480: LD_ADDR_EXP 91
21484: PUSH
21485: LD_EXP 91
21489: PUSH
21490: LD_VAR 0 6
21494: DIFF
21495: ST_TO_ADDR
// eng := eng diff rid ;
21496: LD_ADDR_EXP 93
21500: PUSH
21501: LD_EXP 93
21505: PUSH
21506: LD_VAR 0 6
21510: DIFF
21511: ST_TO_ADDR
// case true of i in scout1 :
21512: LD_INT 1
21514: PUSH
21515: LD_VAR 0 5
21519: PUSH
21520: LD_LOC 7
21524: IN
21525: DOUBLE
21526: EQUAL
21527: IFTRUE 21531
21529: GO 21558
21531: POP
// begin scout1 := scout1 diff i ;
21532: LD_ADDR_LOC 7
21536: PUSH
21537: LD_LOC 7
21541: PUSH
21542: LD_VAR 0 5
21546: DIFF
21547: ST_TO_ADDR
// c := 1 ;
21548: LD_ADDR_VAR 0 7
21552: PUSH
21553: LD_INT 1
21555: ST_TO_ADDR
// end ; i in scout2 :
21556: GO 21774
21558: LD_VAR 0 5
21562: PUSH
21563: LD_LOC 8
21567: IN
21568: DOUBLE
21569: EQUAL
21570: IFTRUE 21574
21572: GO 21601
21574: POP
// begin scout2 := scout2 diff i ;
21575: LD_ADDR_LOC 8
21579: PUSH
21580: LD_LOC 8
21584: PUSH
21585: LD_VAR 0 5
21589: DIFF
21590: ST_TO_ADDR
// c := 2 ;
21591: LD_ADDR_VAR 0 7
21595: PUSH
21596: LD_INT 2
21598: ST_TO_ADDR
// end ; i in scout :
21599: GO 21774
21601: LD_VAR 0 5
21605: PUSH
21606: LD_LOC 4
21610: IN
21611: DOUBLE
21612: EQUAL
21613: IFTRUE 21617
21615: GO 21644
21617: POP
// begin scout := scout diff i ;
21618: LD_ADDR_LOC 4
21622: PUSH
21623: LD_LOC 4
21627: PUSH
21628: LD_VAR 0 5
21632: DIFF
21633: ST_TO_ADDR
// c := 3 ;
21634: LD_ADDR_VAR 0 7
21638: PUSH
21639: LD_INT 3
21641: ST_TO_ADDR
// end ; i in attack :
21642: GO 21774
21644: LD_VAR 0 5
21648: PUSH
21649: LD_LOC 5
21653: IN
21654: DOUBLE
21655: EQUAL
21656: IFTRUE 21660
21658: GO 21687
21660: POP
// begin attack := attack diff i ;
21661: LD_ADDR_LOC 5
21665: PUSH
21666: LD_LOC 5
21670: PUSH
21671: LD_VAR 0 5
21675: DIFF
21676: ST_TO_ADDR
// c := 4 ;
21677: LD_ADDR_VAR 0 7
21681: PUSH
21682: LD_INT 4
21684: ST_TO_ADDR
// end ; i in defence :
21685: GO 21774
21687: LD_VAR 0 5
21691: PUSH
21692: LD_LOC 6
21696: IN
21697: DOUBLE
21698: EQUAL
21699: IFTRUE 21703
21701: GO 21730
21703: POP
// begin defence := defence diff i ;
21704: LD_ADDR_LOC 6
21708: PUSH
21709: LD_LOC 6
21713: PUSH
21714: LD_VAR 0 5
21718: DIFF
21719: ST_TO_ADDR
// c := 4 ;
21720: LD_ADDR_VAR 0 7
21724: PUSH
21725: LD_INT 4
21727: ST_TO_ADDR
// end ; i in cargo :
21728: GO 21774
21730: LD_VAR 0 5
21734: PUSH
21735: LD_LOC 3
21739: IN
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21773
21746: POP
// begin cargo := cargo diff i ;
21747: LD_ADDR_LOC 3
21751: PUSH
21752: LD_LOC 3
21756: PUSH
21757: LD_VAR 0 5
21761: DIFF
21762: ST_TO_ADDR
// c := 5 ;
21763: LD_ADDR_VAR 0 7
21767: PUSH
21768: LD_INT 5
21770: ST_TO_ADDR
// end ; end ;
21771: GO 21774
21773: POP
// ComEnterUnit ( rid , i ) ;
21774: LD_VAR 0 6
21778: PPUSH
21779: LD_VAR 0 5
21783: PPUSH
21784: CALL_OW 120
// while not UnitsInside ( i ) do
21788: LD_VAR 0 5
21792: PPUSH
21793: CALL_OW 313
21797: NOT
21798: IFFALSE 21809
// wait ( 0 0$1 ) ;
21800: LD_INT 35
21802: PPUSH
21803: CALL_OW 67
21807: GO 21788
// ComMoveToArea ( i , parkoviste ) ;
21809: LD_VAR 0 5
21813: PPUSH
21814: LD_INT 13
21816: PPUSH
21817: CALL_OW 113
// while not IsInArea ( i , parkoviste ) do
21821: LD_VAR 0 5
21825: PPUSH
21826: LD_INT 13
21828: PPUSH
21829: CALL_OW 308
21833: NOT
21834: IFFALSE 21845
// wait ( 0 0$1 ) ;
21836: LD_INT 35
21838: PPUSH
21839: CALL_OW 67
21843: GO 21821
// ComExitVehicle ( i ) ;
21845: LD_VAR 0 5
21849: PPUSH
21850: CALL_OW 121
// while UnitsInside ( i ) do
21854: LD_VAR 0 5
21858: PPUSH
21859: CALL_OW 313
21863: IFFALSE 21874
// wait ( 0 0$1 ) ;
21865: LD_INT 35
21867: PPUSH
21868: CALL_OW 67
21872: GO 21854
// ComReturn ( rid ) ;
21874: LD_VAR 0 6
21878: PPUSH
21879: CALL_OW 144
// case c of 1 :
21883: LD_VAR 0 7
21887: PUSH
21888: LD_INT 1
21890: DOUBLE
21891: EQUAL
21892: IFTRUE 21896
21894: GO 21915
21896: POP
// begin scout1 := scout1 ^ i ;
21897: LD_ADDR_LOC 7
21901: PUSH
21902: LD_LOC 7
21906: PUSH
21907: LD_VAR 0 5
21911: ADD
21912: ST_TO_ADDR
// end ; 2 :
21913: GO 22051
21915: LD_INT 2
21917: DOUBLE
21918: EQUAL
21919: IFTRUE 21923
21921: GO 21942
21923: POP
// begin scout2 := scout2 ^ i ;
21924: LD_ADDR_LOC 8
21928: PUSH
21929: LD_LOC 8
21933: PUSH
21934: LD_VAR 0 5
21938: ADD
21939: ST_TO_ADDR
// end ; 3 :
21940: GO 22051
21942: LD_INT 3
21944: DOUBLE
21945: EQUAL
21946: IFTRUE 21950
21948: GO 21969
21950: POP
// begin scout := scout ^ i ;
21951: LD_ADDR_LOC 4
21955: PUSH
21956: LD_LOC 4
21960: PUSH
21961: LD_VAR 0 5
21965: ADD
21966: ST_TO_ADDR
// end ; 4 :
21967: GO 22051
21969: LD_INT 4
21971: DOUBLE
21972: EQUAL
21973: IFTRUE 21977
21975: GO 21996
21977: POP
// begin attack := attack ^ i ;
21978: LD_ADDR_LOC 5
21982: PUSH
21983: LD_LOC 5
21987: PUSH
21988: LD_VAR 0 5
21992: ADD
21993: ST_TO_ADDR
// end ; 5 :
21994: GO 22051
21996: LD_INT 5
21998: DOUBLE
21999: EQUAL
22000: IFTRUE 22004
22002: GO 22023
22004: POP
// begin defence := defence ^ i ;
22005: LD_ADDR_LOC 6
22009: PUSH
22010: LD_LOC 6
22014: PUSH
22015: LD_VAR 0 5
22019: ADD
22020: ST_TO_ADDR
// end ; 6 :
22021: GO 22051
22023: LD_INT 6
22025: DOUBLE
22026: EQUAL
22027: IFTRUE 22031
22029: GO 22050
22031: POP
// begin cargo := cargo ^ i ;
22032: LD_ADDR_LOC 3
22036: PUSH
22037: LD_LOC 3
22041: PUSH
22042: LD_VAR 0 5
22046: ADD
22047: ST_TO_ADDR
// end ; end ;
22048: GO 22051
22050: POP
// if GetClass ( rid ) = class_soldier then
22051: LD_VAR 0 6
22055: PPUSH
22056: CALL_OW 257
22060: PUSH
22061: LD_INT 1
22063: EQUAL
22064: IFFALSE 22082
// sol := sol union rid ;
22066: LD_ADDR_EXP 90
22070: PUSH
22071: LD_EXP 90
22075: PUSH
22076: LD_VAR 0 6
22080: UNION
22081: ST_TO_ADDR
// if GetClass ( rid ) = class_scientistic then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 257
22091: PUSH
22092: LD_INT 4
22094: EQUAL
22095: IFFALSE 22113
// sci := sci union rid ;
22097: LD_ADDR_EXP 91
22101: PUSH
22102: LD_EXP 91
22106: PUSH
22107: LD_VAR 0 6
22111: UNION
22112: ST_TO_ADDR
// if GetClass ( rid ) = class_engineer then
22113: LD_VAR 0 6
22117: PPUSH
22118: CALL_OW 257
22122: PUSH
22123: LD_INT 2
22125: EQUAL
22126: IFFALSE 22144
// eng := eng union rid ;
22128: LD_ADDR_EXP 93
22132: PUSH
22133: LD_EXP 93
22137: PUSH
22138: LD_VAR 0 6
22142: UNION
22143: ST_TO_ADDR
// end ;
22144: GO 21431
22146: POP
22147: POP
// enable ;
22148: ENABLE
// end ;
22149: PPOPN 7
22151: END
// var add_h ; every 0 0$15.0 do var a ;
22152: GO 22154
22154: DISABLE
22155: LD_INT 0
22157: PPUSH
// begin if not IsBusy ( fact1 ) and GetSide ( fact1 ) <> you then
22158: LD_INT 35
22160: PPUSH
22161: CALL_OW 315
22165: NOT
22166: PUSH
22167: LD_INT 35
22169: PPUSH
22170: CALL_OW 255
22174: PUSH
22175: LD_EXP 1
22179: NONEQUAL
22180: AND
22181: IFFALSE 23009
// begin if attacky > 70 and defence < 4 then
22183: LD_EXP 60
22187: PUSH
22188: LD_INT 70
22190: GREATER
22191: PUSH
22192: LD_LOC 6
22196: PUSH
22197: LD_INT 4
22199: LESS
22200: AND
22201: IFFALSE 22271
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22203: LD_INT 5
22205: PPUSH
22206: LD_INT 25
22208: PUSH
22209: LD_INT 3
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PUSH
22216: LD_INT 22
22218: PUSH
22219: LD_EXP 2
22223: PUSH
22224: EMPTY
22225: LIST
22226: LIST
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PPUSH
22232: CALL_OW 70
22236: PPUSH
22237: LD_INT 35
22239: PPUSH
22240: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_gun ) ;
22244: LD_INT 35
22246: PPUSH
22247: LD_INT 24
22249: PPUSH
22250: LD_INT 1
22252: PPUSH
22253: LD_INT 1
22255: PPUSH
22256: LD_INT 46
22258: PPUSH
22259: CALL_OW 125
// to_defence := true ;
22263: LD_ADDR_LOC 25
22267: PUSH
22268: LD_INT 1
22270: ST_TO_ADDR
// end ; if attacky > 30 and scout < 2 then
22271: LD_EXP 60
22275: PUSH
22276: LD_INT 30
22278: GREATER
22279: PUSH
22280: LD_LOC 4
22284: PUSH
22285: LD_INT 2
22287: LESS
22288: AND
22289: IFFALSE 22367
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22291: LD_INT 5
22293: PPUSH
22294: LD_INT 25
22296: PUSH
22297: LD_INT 3
22299: PUSH
22300: EMPTY
22301: LIST
22302: LIST
22303: PUSH
22304: LD_INT 22
22306: PUSH
22307: LD_EXP 2
22311: PUSH
22312: EMPTY
22313: LIST
22314: LIST
22315: PUSH
22316: EMPTY
22317: LIST
22318: LIST
22319: PPUSH
22320: CALL_OW 70
22324: PPUSH
22325: LD_INT 35
22327: PPUSH
22328: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22332: LD_INT 35
22334: PPUSH
22335: LD_INT 22
22337: PPUSH
22338: LD_INT 1
22340: PPUSH
22341: LD_INT 1
22343: PPUSH
22344: LD_INT 42
22346: PPUSH
22347: CALL_OW 125
// to_scout := true ;
22351: LD_ADDR_LOC 27
22355: PUSH
22356: LD_INT 1
22358: ST_TO_ADDR
// to_attack := true ;
22359: LD_ADDR_LOC 26
22363: PUSH
22364: LD_INT 1
22366: ST_TO_ADDR
// end ; if attacky > 90 and attack < 4 then
22367: LD_EXP 60
22371: PUSH
22372: LD_INT 90
22374: GREATER
22375: PUSH
22376: LD_LOC 5
22380: PUSH
22381: LD_INT 4
22383: LESS
22384: AND
22385: IFFALSE 22455
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22387: LD_INT 5
22389: PPUSH
22390: LD_INT 25
22392: PUSH
22393: LD_INT 3
22395: PUSH
22396: EMPTY
22397: LIST
22398: LIST
22399: PUSH
22400: LD_INT 22
22402: PUSH
22403: LD_EXP 2
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: PPUSH
22416: CALL_OW 70
22420: PPUSH
22421: LD_INT 35
22423: PPUSH
22424: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22428: LD_INT 35
22430: PPUSH
22431: LD_INT 24
22433: PPUSH
22434: LD_INT 1
22436: PPUSH
22437: LD_INT 1
22439: PPUSH
22440: LD_INT 42
22442: PPUSH
22443: CALL_OW 125
// to_attack := true ;
22447: LD_ADDR_LOC 26
22451: PUSH
22452: LD_INT 1
22454: ST_TO_ADDR
// end ; if cargo < 1 then
22455: LD_LOC 3
22459: PUSH
22460: LD_INT 1
22462: LESS
22463: IFFALSE 22533
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22465: LD_INT 5
22467: PPUSH
22468: LD_INT 25
22470: PUSH
22471: LD_INT 3
22473: PUSH
22474: EMPTY
22475: LIST
22476: LIST
22477: PUSH
22478: LD_INT 22
22480: PUSH
22481: LD_EXP 2
22485: PUSH
22486: EMPTY
22487: LIST
22488: LIST
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: PPUSH
22494: CALL_OW 70
22498: PPUSH
22499: LD_INT 35
22501: PPUSH
22502: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_cargo_bay ) ;
22506: LD_INT 35
22508: PPUSH
22509: LD_INT 22
22511: PPUSH
22512: LD_INT 1
22514: PPUSH
22515: LD_INT 1
22517: PPUSH
22518: LD_INT 51
22520: PPUSH
22521: CALL_OW 125
// to_cargo := true ;
22525: LD_ADDR_LOC 28
22529: PUSH
22530: LD_INT 1
22532: ST_TO_ADDR
// end ; if ( sol + mec + eng + sci > 8 ) and ( add_h < 6 ) then
22533: LD_EXP 90
22537: PUSH
22538: LD_EXP 92
22542: PLUS
22543: PUSH
22544: LD_EXP 93
22548: PLUS
22549: PUSH
22550: LD_EXP 91
22554: PLUS
22555: PUSH
22556: LD_INT 8
22558: GREATER
22559: PUSH
22560: LD_LOC 31
22564: PUSH
22565: LD_INT 6
22567: LESS
22568: AND
22569: IFFALSE 23009
// begin add_h := add_h + 1 ;
22571: LD_ADDR_LOC 31
22575: PUSH
22576: LD_LOC 31
22580: PUSH
22581: LD_INT 1
22583: PLUS
22584: ST_TO_ADDR
// if sol < 8 then
22585: LD_EXP 90
22589: PUSH
22590: LD_INT 8
22592: LESS
22593: IFFALSE 22699
// begin InitUc ;
22595: CALL_OW 18
// InitHc ;
22599: CALL_OW 19
// uc_nation := nation_russian ;
22603: LD_ADDR_OWVAR 21
22607: PUSH
22608: LD_INT 3
22610: ST_TO_ADDR
// uc_side := russians ;
22611: LD_ADDR_OWVAR 20
22615: PUSH
22616: LD_EXP 2
22620: ST_TO_ADDR
// PrepareSoldier ( 0 , 6 ) ;
22621: LD_INT 0
22623: PPUSH
22624: LD_INT 6
22626: PPUSH
22627: CALL_OW 381
// a := CreateHuman ;
22631: LD_ADDR_VAR 0 1
22635: PUSH
22636: CALL_OW 44
22640: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22641: LD_VAR 0 1
22645: PPUSH
22646: LD_INT 119
22648: PPUSH
22649: LD_INT 98
22651: PPUSH
22652: LD_INT 5
22654: PPUSH
22655: LD_INT 0
22657: PPUSH
22658: CALL_OW 50
// wait ( 0 0$6 ) ;
22662: LD_INT 210
22664: PPUSH
22665: CALL_OW 67
// sol := sol ^ a ;
22669: LD_ADDR_EXP 90
22673: PUSH
22674: LD_EXP 90
22678: PUSH
22679: LD_VAR 0 1
22683: ADD
22684: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22685: LD_VAR 0 1
22689: PPUSH
22690: LD_INT 5
22692: PPUSH
22693: CALL_OW 113
// end else
22697: GO 23009
// if mec < 2 then
22699: LD_EXP 92
22703: PUSH
22704: LD_INT 2
22706: LESS
22707: IFFALSE 22803
// begin InitUc ;
22709: CALL_OW 18
// InitHc ;
22713: CALL_OW 19
// uc_nation := nation_russian ;
22717: LD_ADDR_OWVAR 21
22721: PUSH
22722: LD_INT 3
22724: ST_TO_ADDR
// PrepareMechanic ( 0 , 6 ) ;
22725: LD_INT 0
22727: PPUSH
22728: LD_INT 6
22730: PPUSH
22731: CALL_OW 383
// a := CreateHuman ;
22735: LD_ADDR_VAR 0 1
22739: PUSH
22740: CALL_OW 44
22744: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22745: LD_VAR 0 1
22749: PPUSH
22750: LD_INT 119
22752: PPUSH
22753: LD_INT 98
22755: PPUSH
22756: LD_INT 5
22758: PPUSH
22759: LD_INT 0
22761: PPUSH
22762: CALL_OW 50
// wait ( 0 0$6 ) ;
22766: LD_INT 210
22768: PPUSH
22769: CALL_OW 67
// mec := mec ^ a ;
22773: LD_ADDR_EXP 92
22777: PUSH
22778: LD_EXP 92
22782: PUSH
22783: LD_VAR 0 1
22787: ADD
22788: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22789: LD_VAR 0 1
22793: PPUSH
22794: LD_INT 5
22796: PPUSH
22797: CALL_OW 113
// end else
22801: GO 23009
// if eng < 1 then
22803: LD_EXP 93
22807: PUSH
22808: LD_INT 1
22810: LESS
22811: IFFALSE 22907
// begin InitUc ;
22813: CALL_OW 18
// InitHc ;
22817: CALL_OW 19
// uc_nation := nation_russian ;
22821: LD_ADDR_OWVAR 21
22825: PUSH
22826: LD_INT 3
22828: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
22829: LD_INT 0
22831: PPUSH
22832: LD_INT 6
22834: PPUSH
22835: CALL_OW 382
// a := CreateHuman ;
22839: LD_ADDR_VAR 0 1
22843: PUSH
22844: CALL_OW 44
22848: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
22849: LD_VAR 0 1
22853: PPUSH
22854: LD_INT 119
22856: PPUSH
22857: LD_INT 99
22859: PPUSH
22860: LD_INT 5
22862: PPUSH
22863: LD_INT 0
22865: PPUSH
22866: CALL_OW 50
// wait ( 0 0$6 ) ;
22870: LD_INT 210
22872: PPUSH
22873: CALL_OW 67
// eng := eng ^ a ;
22877: LD_ADDR_EXP 93
22881: PUSH
22882: LD_EXP 93
22886: PUSH
22887: LD_VAR 0 1
22891: ADD
22892: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22893: LD_VAR 0 1
22897: PPUSH
22898: LD_INT 5
22900: PPUSH
22901: CALL_OW 113
// end else
22905: GO 23009
// if sci < 1 then
22907: LD_EXP 91
22911: PUSH
22912: LD_INT 1
22914: LESS
22915: IFFALSE 23009
// begin InitUc ;
22917: CALL_OW 18
// InitHc ;
22921: CALL_OW 19
// uc_nation := nation_russian ;
22925: LD_ADDR_OWVAR 21
22929: PUSH
22930: LD_INT 3
22932: ST_TO_ADDR
// PrepareScientist ( 0 , 6 ) ;
22933: LD_INT 0
22935: PPUSH
22936: LD_INT 6
22938: PPUSH
22939: CALL_OW 384
// a := CreateHuman ;
22943: LD_ADDR_VAR 0 1
22947: PUSH
22948: CALL_OW 44
22952: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
22953: LD_VAR 0 1
22957: PPUSH
22958: LD_INT 119
22960: PPUSH
22961: LD_INT 99
22963: PPUSH
22964: LD_INT 5
22966: PPUSH
22967: LD_INT 0
22969: PPUSH
22970: CALL_OW 50
// wait ( 0 0$6 ) ;
22974: LD_INT 210
22976: PPUSH
22977: CALL_OW 67
// sci := sci ^ a ;
22981: LD_ADDR_EXP 91
22985: PUSH
22986: LD_EXP 91
22990: PUSH
22991: LD_VAR 0 1
22995: ADD
22996: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22997: LD_VAR 0 1
23001: PPUSH
23002: LD_INT 5
23004: PPUSH
23005: CALL_OW 113
// end ; end ; end ; enable ;
23009: ENABLE
// end ;
23010: PPOPN 1
23012: END
// every 0 0$3 do var sc ;
23013: GO 23015
23015: DISABLE
23016: LD_INT 0
23018: PPUSH
// begin sol := UnitFilter ( sol , [ f_alive ] ) ;
23019: LD_ADDR_EXP 90
23023: PUSH
23024: LD_EXP 90
23028: PPUSH
23029: LD_INT 51
23031: PUSH
23032: EMPTY
23033: LIST
23034: PPUSH
23035: CALL_OW 72
23039: ST_TO_ADDR
// eng := UnitFilter ( eng , [ f_alive ] ) ;
23040: LD_ADDR_EXP 93
23044: PUSH
23045: LD_EXP 93
23049: PPUSH
23050: LD_INT 51
23052: PUSH
23053: EMPTY
23054: LIST
23055: PPUSH
23056: CALL_OW 72
23060: ST_TO_ADDR
// mec := UnitFilter ( mec , [ f_alive ] ) ;
23061: LD_ADDR_EXP 92
23065: PUSH
23066: LD_EXP 92
23070: PPUSH
23071: LD_INT 51
23073: PUSH
23074: EMPTY
23075: LIST
23076: PPUSH
23077: CALL_OW 72
23081: ST_TO_ADDR
// sci := UnitFilter ( sci , [ f_alive ] ) ;
23082: LD_ADDR_EXP 91
23086: PUSH
23087: LD_EXP 91
23091: PPUSH
23092: LD_INT 51
23094: PUSH
23095: EMPTY
23096: LIST
23097: PPUSH
23098: CALL_OW 72
23102: ST_TO_ADDR
// defence := UnitFilter ( defence , [ f_alive ] ) ;
23103: LD_ADDR_LOC 6
23107: PUSH
23108: LD_LOC 6
23112: PPUSH
23113: LD_INT 51
23115: PUSH
23116: EMPTY
23117: LIST
23118: PPUSH
23119: CALL_OW 72
23123: ST_TO_ADDR
// cargo := UnitFilter ( cargo , [ f_alive ] ) ;
23124: LD_ADDR_LOC 3
23128: PUSH
23129: LD_LOC 3
23133: PPUSH
23134: LD_INT 51
23136: PUSH
23137: EMPTY
23138: LIST
23139: PPUSH
23140: CALL_OW 72
23144: ST_TO_ADDR
// attack := UnitFilter ( attack , [ f_alive ] ) ;
23145: LD_ADDR_LOC 5
23149: PUSH
23150: LD_LOC 5
23154: PPUSH
23155: LD_INT 51
23157: PUSH
23158: EMPTY
23159: LIST
23160: PPUSH
23161: CALL_OW 72
23165: ST_TO_ADDR
// scout := UnitFilter ( scout , [ f_alive ] ) ;
23166: LD_ADDR_LOC 4
23170: PUSH
23171: LD_LOC 4
23175: PPUSH
23176: LD_INT 51
23178: PUSH
23179: EMPTY
23180: LIST
23181: PPUSH
23182: CALL_OW 72
23186: ST_TO_ADDR
// broken := UnitFilter ( broken , [ f_alive ] ) ;
23187: LD_ADDR_LOC 21
23191: PUSH
23192: LD_LOC 21
23196: PPUSH
23197: LD_INT 51
23199: PUSH
23200: EMPTY
23201: LIST
23202: PPUSH
23203: CALL_OW 72
23207: ST_TO_ADDR
// sc := split ( scout ) ;
23208: LD_ADDR_VAR 0 1
23212: PUSH
23213: LD_LOC 4
23217: PPUSH
23218: CALL 17393 0 1
23222: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23223: LD_ADDR_LOC 7
23227: PUSH
23228: LD_VAR 0 1
23232: PUSH
23233: LD_INT 1
23235: ARRAY
23236: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23237: LD_ADDR_LOC 8
23241: PUSH
23242: LD_VAR 0 1
23246: PUSH
23247: LD_INT 2
23249: ARRAY
23250: ST_TO_ADDR
// forts := UnitFilter ( forts , [ f_alive ] ) ;
23251: LD_ADDR_LOC 10
23255: PUSH
23256: LD_LOC 10
23260: PPUSH
23261: LD_INT 51
23263: PUSH
23264: EMPTY
23265: LIST
23266: PPUSH
23267: CALL_OW 72
23271: ST_TO_ADDR
// end ;
23272: PPOPN 1
23274: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = russians then
23275: LD_VAR 0 3
23279: PUSH
23280: LD_EXP 2
23284: EQUAL
23285: IFFALSE 23463
// begin sol := sol diff vehold ;
23287: LD_ADDR_EXP 90
23291: PUSH
23292: LD_EXP 90
23296: PUSH
23297: LD_VAR 0 2
23301: DIFF
23302: ST_TO_ADDR
// eng := eng diff vehold ;
23303: LD_ADDR_EXP 93
23307: PUSH
23308: LD_EXP 93
23312: PUSH
23313: LD_VAR 0 2
23317: DIFF
23318: ST_TO_ADDR
// mec := mec diff vehold ;
23319: LD_ADDR_EXP 92
23323: PUSH
23324: LD_EXP 92
23328: PUSH
23329: LD_VAR 0 2
23333: DIFF
23334: ST_TO_ADDR
// sci := sci diff vehold ;
23335: LD_ADDR_EXP 91
23339: PUSH
23340: LD_EXP 91
23344: PUSH
23345: LD_VAR 0 2
23349: DIFF
23350: ST_TO_ADDR
// defence := defence diff vehold ;
23351: LD_ADDR_LOC 6
23355: PUSH
23356: LD_LOC 6
23360: PUSH
23361: LD_VAR 0 2
23365: DIFF
23366: ST_TO_ADDR
// cargo := cargo diff vehold ;
23367: LD_ADDR_LOC 3
23371: PUSH
23372: LD_LOC 3
23376: PUSH
23377: LD_VAR 0 2
23381: DIFF
23382: ST_TO_ADDR
// attack := attack diff vehold ;
23383: LD_ADDR_LOC 5
23387: PUSH
23388: LD_LOC 5
23392: PUSH
23393: LD_VAR 0 2
23397: DIFF
23398: ST_TO_ADDR
// scout := scout diff vehold ;
23399: LD_ADDR_LOC 4
23403: PUSH
23404: LD_LOC 4
23408: PUSH
23409: LD_VAR 0 2
23413: DIFF
23414: ST_TO_ADDR
// broken := broken diff vehold ;
23415: LD_ADDR_LOC 21
23419: PUSH
23420: LD_LOC 21
23424: PUSH
23425: LD_VAR 0 2
23429: DIFF
23430: ST_TO_ADDR
// scout1 := scout1 diff vehold ;
23431: LD_ADDR_LOC 7
23435: PUSH
23436: LD_LOC 7
23440: PUSH
23441: LD_VAR 0 2
23445: DIFF
23446: ST_TO_ADDR
// scout2 := scout2 diff vehold ;
23447: LD_ADDR_LOC 8
23451: PUSH
23452: LD_LOC 8
23456: PUSH
23457: LD_VAR 0 2
23461: DIFF
23462: ST_TO_ADDR
// end ; end ;
23463: PPOPN 4
23465: END
// on UnitDestroyed ( un ) do begin if un = JMM then
23466: LD_VAR 0 1
23470: PUSH
23471: LD_EXP 15
23475: EQUAL
23476: IFFALSE 23488
// begin disable ( 0 ) ;
23478: LD_INT 0
23480: DISABLE_MARKED
// YouLost ( JMM ) ;
23481: LD_STRING JMM
23483: PPUSH
23484: CALL_OW 104
// end ; sol := sol diff un ;
23488: LD_ADDR_EXP 90
23492: PUSH
23493: LD_EXP 90
23497: PUSH
23498: LD_VAR 0 1
23502: DIFF
23503: ST_TO_ADDR
// eng := eng diff un ;
23504: LD_ADDR_EXP 93
23508: PUSH
23509: LD_EXP 93
23513: PUSH
23514: LD_VAR 0 1
23518: DIFF
23519: ST_TO_ADDR
// mec := mec diff un ;
23520: LD_ADDR_EXP 92
23524: PUSH
23525: LD_EXP 92
23529: PUSH
23530: LD_VAR 0 1
23534: DIFF
23535: ST_TO_ADDR
// sci := sci diff un ;
23536: LD_ADDR_EXP 91
23540: PUSH
23541: LD_EXP 91
23545: PUSH
23546: LD_VAR 0 1
23550: DIFF
23551: ST_TO_ADDR
// defence := defence diff un ;
23552: LD_ADDR_LOC 6
23556: PUSH
23557: LD_LOC 6
23561: PUSH
23562: LD_VAR 0 1
23566: DIFF
23567: ST_TO_ADDR
// cargo := cargo diff un ;
23568: LD_ADDR_LOC 3
23572: PUSH
23573: LD_LOC 3
23577: PUSH
23578: LD_VAR 0 1
23582: DIFF
23583: ST_TO_ADDR
// attack := attack diff un ;
23584: LD_ADDR_LOC 5
23588: PUSH
23589: LD_LOC 5
23593: PUSH
23594: LD_VAR 0 1
23598: DIFF
23599: ST_TO_ADDR
// scout := scout diff un ;
23600: LD_ADDR_LOC 4
23604: PUSH
23605: LD_LOC 4
23609: PUSH
23610: LD_VAR 0 1
23614: DIFF
23615: ST_TO_ADDR
// broken := broken diff un ;
23616: LD_ADDR_LOC 21
23620: PUSH
23621: LD_LOC 21
23625: PUSH
23626: LD_VAR 0 1
23630: DIFF
23631: ST_TO_ADDR
// scout1 := scout1 diff un ;
23632: LD_ADDR_LOC 7
23636: PUSH
23637: LD_LOC 7
23641: PUSH
23642: LD_VAR 0 1
23646: DIFF
23647: ST_TO_ADDR
// scout2 := scout2 diff un ;
23648: LD_ADDR_LOC 8
23652: PUSH
23653: LD_LOC 8
23657: PUSH
23658: LD_VAR 0 1
23662: DIFF
23663: ST_TO_ADDR
// forts := forts diff un ;
23664: LD_ADDR_LOC 10
23668: PUSH
23669: LD_LOC 10
23673: PUSH
23674: LD_VAR 0 1
23678: DIFF
23679: ST_TO_ADDR
// end ;
23680: PPOPN 1
23682: END
// on VehicleConstructed ( veh , fact ) do var i , sc ;
23683: LD_INT 0
23685: PPUSH
23686: PPUSH
// begin if GetSide ( fact ) = russians then
23687: LD_VAR 0 2
23691: PPUSH
23692: CALL_OW 255
23696: PUSH
23697: LD_EXP 2
23701: EQUAL
23702: IFFALSE 23921
// begin ComMoveToArea ( veh , parkoviste ) ;
23704: LD_VAR 0 1
23708: PPUSH
23709: LD_INT 13
23711: PPUSH
23712: CALL_OW 113
// while not IsInArea ( veh , parkoviste ) do
23716: LD_VAR 0 1
23720: PPUSH
23721: LD_INT 13
23723: PPUSH
23724: CALL_OW 308
23728: NOT
23729: IFFALSE 23740
// Wait ( 0 0$1 ) ;
23731: LD_INT 35
23733: PPUSH
23734: CALL_OW 67
23738: GO 23716
// ComExitVehicle ( veh ) ;
23740: LD_VAR 0 1
23744: PPUSH
23745: CALL_OW 121
// ComRemember ( veh ) ;
23749: LD_VAR 0 1
23753: PPUSH
23754: CALL_OW 143
// if to_defence then
23758: LD_LOC 25
23762: IFFALSE 23780
// begin defence := defence union veh ;
23764: LD_ADDR_LOC 6
23768: PUSH
23769: LD_LOC 6
23773: PUSH
23774: LD_VAR 0 1
23778: UNION
23779: ST_TO_ADDR
// end ; if to_cargo then
23780: LD_LOC 28
23784: IFFALSE 23802
// begin cargo := cargo union veh ;
23786: LD_ADDR_LOC 3
23790: PUSH
23791: LD_LOC 3
23795: PUSH
23796: LD_VAR 0 1
23800: UNION
23801: ST_TO_ADDR
// end ; if to_attack then
23802: LD_LOC 26
23806: IFFALSE 23824
// begin attack := attack union veh ;
23808: LD_ADDR_LOC 5
23812: PUSH
23813: LD_LOC 5
23817: PUSH
23818: LD_VAR 0 1
23822: UNION
23823: ST_TO_ADDR
// end ; if to_scout then
23824: LD_LOC 27
23828: IFFALSE 23889
// begin scout := scout union veh ;
23830: LD_ADDR_LOC 4
23834: PUSH
23835: LD_LOC 4
23839: PUSH
23840: LD_VAR 0 1
23844: UNION
23845: ST_TO_ADDR
// sc := split ( scout ) ;
23846: LD_ADDR_VAR 0 4
23850: PUSH
23851: LD_LOC 4
23855: PPUSH
23856: CALL 17393 0 1
23860: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23861: LD_ADDR_LOC 7
23865: PUSH
23866: LD_VAR 0 4
23870: PUSH
23871: LD_INT 1
23873: ARRAY
23874: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23875: LD_ADDR_LOC 8
23879: PUSH
23880: LD_VAR 0 4
23884: PUSH
23885: LD_INT 2
23887: ARRAY
23888: ST_TO_ADDR
// end ; to_cargo := false ;
23889: LD_ADDR_LOC 28
23893: PUSH
23894: LD_INT 0
23896: ST_TO_ADDR
// to_scout := false ;
23897: LD_ADDR_LOC 27
23901: PUSH
23902: LD_INT 0
23904: ST_TO_ADDR
// to_attack := false ;
23905: LD_ADDR_LOC 26
23909: PUSH
23910: LD_INT 0
23912: ST_TO_ADDR
// to_defence := false ;
23913: LD_ADDR_LOC 25
23917: PUSH
23918: LD_INT 0
23920: ST_TO_ADDR
// end ; end ;
23921: PPOPN 4
23923: END
// every 0 0$30 trigger attacky > odplata_1 do var ubase ;
23924: LD_EXP 60
23928: PUSH
23929: LD_EXP 65
23933: GREATER
23934: IFFALSE 24181
23936: GO 23938
23938: DISABLE
23939: LD_INT 0
23941: PPUSH
// begin attacky := 0 ;
23942: LD_ADDR_EXP 60
23946: PUSH
23947: LD_INT 0
23949: ST_TO_ADDR
// more_scouting := false ;
23950: LD_ADDR_EXP 61
23954: PUSH
23955: LD_INT 0
23957: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
23958: LD_ADDR_VAR 0 1
23962: PUSH
23963: LD_INT 21
23965: PUSH
23966: LD_INT 3
23968: PUSH
23969: EMPTY
23970: LIST
23971: LIST
23972: PUSH
23973: LD_INT 22
23975: PUSH
23976: LD_EXP 1
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: ST_TO_ADDR
// if ubase then
23994: LD_VAR 0 1
23998: IFFALSE 24181
// begin case Rand ( 1 , 3 ) of 1 :
24000: LD_INT 1
24002: PPUSH
24003: LD_INT 3
24005: PPUSH
24006: CALL_OW 12
24010: PUSH
24011: LD_INT 1
24013: DOUBLE
24014: EQUAL
24015: IFTRUE 24019
24017: GO 24053
24019: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24020: LD_LOC 5
24024: PUSH
24025: LD_LOC 21
24029: DIFF
24030: PPUSH
24031: LD_EXP 90
24035: PPUSH
24036: LD_LOC 22
24040: PPUSH
24041: LD_INT 1
24043: PPUSH
24044: LD_INT 0
24046: PPUSH
24047: CALL 16780 0 5
24051: GO 24138
24053: LD_INT 2
24055: DOUBLE
24056: EQUAL
24057: IFTRUE 24061
24059: GO 24095
24061: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24062: LD_LOC 5
24066: PUSH
24067: LD_LOC 21
24071: DIFF
24072: PPUSH
24073: LD_EXP 90
24077: PPUSH
24078: LD_LOC 23
24082: PPUSH
24083: LD_INT 1
24085: PPUSH
24086: LD_INT 0
24088: PPUSH
24089: CALL 16780 0 5
24093: GO 24138
24095: LD_INT 3
24097: DOUBLE
24098: EQUAL
24099: IFTRUE 24103
24101: GO 24137
24103: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24104: LD_LOC 5
24108: PUSH
24109: LD_LOC 21
24113: DIFF
24114: PPUSH
24115: LD_EXP 90
24119: PPUSH
24120: LD_LOC 24
24124: PPUSH
24125: LD_INT 1
24127: PPUSH
24128: LD_INT 0
24130: PPUSH
24131: CALL 16780 0 5
24135: GO 24138
24137: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24138: LD_LOC 5
24142: PUSH
24143: LD_LOC 21
24147: DIFF
24148: PPUSH
24149: LD_VAR 0 1
24153: PUSH
24154: LD_INT 1
24156: ARRAY
24157: PPUSH
24158: CALL_OW 250
24162: PPUSH
24163: LD_VAR 0 1
24167: PUSH
24168: LD_INT 1
24170: ARRAY
24171: PPUSH
24172: CALL_OW 251
24176: PPUSH
24177: CALL_OW 174
// end ; end ;
24181: PPOPN 1
24183: END
// every 4 4$30 trigger attacky > odplata_2 do var ubase ;
24184: LD_EXP 60
24188: PUSH
24189: LD_EXP 66
24193: GREATER
24194: IFFALSE 24434
24196: GO 24198
24198: DISABLE
24199: LD_INT 0
24201: PPUSH
// begin attacky := 0 ;
24202: LD_ADDR_EXP 60
24206: PUSH
24207: LD_INT 0
24209: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24210: LD_ADDR_VAR 0 1
24214: PUSH
24215: LD_INT 21
24217: PUSH
24218: LD_INT 3
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 22
24227: PUSH
24228: LD_EXP 1
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PPUSH
24241: CALL_OW 69
24245: ST_TO_ADDR
// if ubase then
24246: LD_VAR 0 1
24250: IFFALSE 24433
// begin case Rand ( 1 , 3 ) of 1 :
24252: LD_INT 1
24254: PPUSH
24255: LD_INT 3
24257: PPUSH
24258: CALL_OW 12
24262: PUSH
24263: LD_INT 1
24265: DOUBLE
24266: EQUAL
24267: IFTRUE 24271
24269: GO 24305
24271: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24272: LD_LOC 5
24276: PUSH
24277: LD_LOC 21
24281: DIFF
24282: PPUSH
24283: LD_EXP 90
24287: PPUSH
24288: LD_LOC 22
24292: PPUSH
24293: LD_INT 1
24295: PPUSH
24296: LD_INT 0
24298: PPUSH
24299: CALL 16780 0 5
24303: GO 24390
24305: LD_INT 2
24307: DOUBLE
24308: EQUAL
24309: IFTRUE 24313
24311: GO 24347
24313: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24314: LD_LOC 5
24318: PUSH
24319: LD_LOC 21
24323: DIFF
24324: PPUSH
24325: LD_EXP 90
24329: PPUSH
24330: LD_LOC 23
24334: PPUSH
24335: LD_INT 1
24337: PPUSH
24338: LD_INT 0
24340: PPUSH
24341: CALL 16780 0 5
24345: GO 24390
24347: LD_INT 3
24349: DOUBLE
24350: EQUAL
24351: IFTRUE 24355
24353: GO 24389
24355: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24356: LD_LOC 5
24360: PUSH
24361: LD_LOC 21
24365: DIFF
24366: PPUSH
24367: LD_EXP 90
24371: PPUSH
24372: LD_LOC 24
24376: PPUSH
24377: LD_INT 1
24379: PPUSH
24380: LD_INT 0
24382: PPUSH
24383: CALL 16780 0 5
24387: GO 24390
24389: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24390: LD_LOC 5
24394: PUSH
24395: LD_LOC 21
24399: DIFF
24400: PPUSH
24401: LD_VAR 0 1
24405: PUSH
24406: LD_INT 1
24408: ARRAY
24409: PPUSH
24410: CALL_OW 250
24414: PPUSH
24415: LD_VAR 0 1
24419: PUSH
24420: LD_INT 1
24422: ARRAY
24423: PPUSH
24424: CALL_OW 251
24428: PPUSH
24429: CALL_OW 174
// end ; enable ;
24433: ENABLE
// end ;
24434: PPOPN 1
24436: END
// every 8 8$30 trigger more_scouting do var ubase , a ;
24437: LD_EXP 61
24441: IFFALSE 24684
24443: GO 24445
24445: DISABLE
24446: LD_INT 0
24448: PPUSH
24449: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24450: LD_ADDR_VAR 0 1
24454: PUSH
24455: LD_INT 21
24457: PUSH
24458: LD_INT 3
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 22
24467: PUSH
24468: LD_EXP 1
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PPUSH
24481: CALL_OW 69
24485: ST_TO_ADDR
// a := attack diff broken ;
24486: LD_ADDR_VAR 0 2
24490: PUSH
24491: LD_LOC 5
24495: PUSH
24496: LD_LOC 21
24500: DIFF
24501: ST_TO_ADDR
// a := split ( a ) ;
24502: LD_ADDR_VAR 0 2
24506: PUSH
24507: LD_VAR 0 2
24511: PPUSH
24512: CALL 17393 0 1
24516: ST_TO_ADDR
// if ubase then
24517: LD_VAR 0 1
24521: IFFALSE 24684
// begin case Rand ( 1 , 3 ) of 1 :
24523: LD_INT 1
24525: PPUSH
24526: LD_INT 3
24528: PPUSH
24529: CALL_OW 12
24533: PUSH
24534: LD_INT 1
24536: DOUBLE
24537: EQUAL
24538: IFTRUE 24542
24540: GO 24570
24542: POP
// depart ( a , sol , attack_l , true , false ) ; 2 :
24543: LD_VAR 0 2
24547: PPUSH
24548: LD_EXP 90
24552: PPUSH
24553: LD_LOC 22
24557: PPUSH
24558: LD_INT 1
24560: PPUSH
24561: LD_INT 0
24563: PPUSH
24564: CALL 16780 0 5
24568: GO 24643
24570: LD_INT 2
24572: DOUBLE
24573: EQUAL
24574: IFTRUE 24578
24576: GO 24606
24578: POP
// depart ( a , sol , attack_m , true , false ) ; 3 :
24579: LD_VAR 0 2
24583: PPUSH
24584: LD_EXP 90
24588: PPUSH
24589: LD_LOC 23
24593: PPUSH
24594: LD_INT 1
24596: PPUSH
24597: LD_INT 0
24599: PPUSH
24600: CALL 16780 0 5
24604: GO 24643
24606: LD_INT 3
24608: DOUBLE
24609: EQUAL
24610: IFTRUE 24614
24612: GO 24642
24614: POP
// depart ( a , sol , attack_r , true , false ) ; end ;
24615: LD_VAR 0 2
24619: PPUSH
24620: LD_EXP 90
24624: PPUSH
24625: LD_LOC 24
24629: PPUSH
24630: LD_INT 1
24632: PPUSH
24633: LD_INT 0
24635: PPUSH
24636: CALL 16780 0 5
24640: GO 24643
24642: POP
// AddComAgressiveMove ( a [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24643: LD_VAR 0 2
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: PPUSH
24652: LD_VAR 0 1
24656: PUSH
24657: LD_INT 1
24659: ARRAY
24660: PPUSH
24661: CALL_OW 250
24665: PPUSH
24666: LD_VAR 0 1
24670: PUSH
24671: LD_INT 1
24673: ARRAY
24674: PPUSH
24675: CALL_OW 251
24679: PPUSH
24680: CALL_OW 174
// end ; end ;
24684: PPOPN 2
24686: END
// every 16 16$30 trigger more_scouting do var ubase , at ;
24687: LD_EXP 61
24691: IFFALSE 25109
24693: GO 24695
24695: DISABLE
24696: LD_INT 0
24698: PPUSH
24699: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24700: LD_ADDR_VAR 0 1
24704: PUSH
24705: LD_INT 21
24707: PUSH
24708: LD_INT 3
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: LD_INT 22
24717: PUSH
24718: LD_EXP 1
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PPUSH
24731: CALL_OW 69
24735: ST_TO_ADDR
// if ubase then
24736: LD_VAR 0 1
24740: IFFALSE 25109
// begin at := split ( attack diff broken ) ;
24742: LD_ADDR_VAR 0 2
24746: PUSH
24747: LD_LOC 5
24751: PUSH
24752: LD_LOC 21
24756: DIFF
24757: PPUSH
24758: CALL 17393 0 1
24762: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
24763: LD_INT 1
24765: PPUSH
24766: LD_INT 3
24768: PPUSH
24769: CALL_OW 12
24773: PUSH
24774: LD_INT 1
24776: DOUBLE
24777: EQUAL
24778: IFTRUE 24782
24780: GO 24814
24782: POP
// depart ( at [ 1 ] , sol , attack_l , true , false ) ; 2 :
24783: LD_VAR 0 2
24787: PUSH
24788: LD_INT 1
24790: ARRAY
24791: PPUSH
24792: LD_EXP 90
24796: PPUSH
24797: LD_LOC 22
24801: PPUSH
24802: LD_INT 1
24804: PPUSH
24805: LD_INT 0
24807: PPUSH
24808: CALL 16780 0 5
24812: GO 24895
24814: LD_INT 2
24816: DOUBLE
24817: EQUAL
24818: IFTRUE 24822
24820: GO 24854
24822: POP
// depart ( at [ 1 ] , sol , attack_m , true , false ) ; 3 :
24823: LD_VAR 0 2
24827: PUSH
24828: LD_INT 1
24830: ARRAY
24831: PPUSH
24832: LD_EXP 90
24836: PPUSH
24837: LD_LOC 23
24841: PPUSH
24842: LD_INT 1
24844: PPUSH
24845: LD_INT 0
24847: PPUSH
24848: CALL 16780 0 5
24852: GO 24895
24854: LD_INT 3
24856: DOUBLE
24857: EQUAL
24858: IFTRUE 24862
24860: GO 24894
24862: POP
// depart ( at [ 1 ] , sol , attack_r , true , false ) ; end ;
24863: LD_VAR 0 2
24867: PUSH
24868: LD_INT 1
24870: ARRAY
24871: PPUSH
24872: LD_EXP 90
24876: PPUSH
24877: LD_LOC 24
24881: PPUSH
24882: LD_INT 1
24884: PPUSH
24885: LD_INT 0
24887: PPUSH
24888: CALL 16780 0 5
24892: GO 24895
24894: POP
// case Rand ( 1 , 3 ) of 1 :
24895: LD_INT 1
24897: PPUSH
24898: LD_INT 3
24900: PPUSH
24901: CALL_OW 12
24905: PUSH
24906: LD_INT 1
24908: DOUBLE
24909: EQUAL
24910: IFTRUE 24914
24912: GO 24946
24914: POP
// depart ( at [ 2 ] , sol , attack_l , true , false ) ; 2 :
24915: LD_VAR 0 2
24919: PUSH
24920: LD_INT 2
24922: ARRAY
24923: PPUSH
24924: LD_EXP 90
24928: PPUSH
24929: LD_LOC 22
24933: PPUSH
24934: LD_INT 1
24936: PPUSH
24937: LD_INT 0
24939: PPUSH
24940: CALL 16780 0 5
24944: GO 25027
24946: LD_INT 2
24948: DOUBLE
24949: EQUAL
24950: IFTRUE 24954
24952: GO 24986
24954: POP
// depart ( at [ 2 ] , sol , attack_m , true , false ) ; 3 :
24955: LD_VAR 0 2
24959: PUSH
24960: LD_INT 2
24962: ARRAY
24963: PPUSH
24964: LD_EXP 90
24968: PPUSH
24969: LD_LOC 23
24973: PPUSH
24974: LD_INT 1
24976: PPUSH
24977: LD_INT 0
24979: PPUSH
24980: CALL 16780 0 5
24984: GO 25027
24986: LD_INT 3
24988: DOUBLE
24989: EQUAL
24990: IFTRUE 24994
24992: GO 25026
24994: POP
// depart ( at [ 2 ] , sol , attack_r , true , false ) ; end ;
24995: LD_VAR 0 2
24999: PUSH
25000: LD_INT 2
25002: ARRAY
25003: PPUSH
25004: LD_EXP 90
25008: PPUSH
25009: LD_LOC 24
25013: PPUSH
25014: LD_INT 1
25016: PPUSH
25017: LD_INT 0
25019: PPUSH
25020: CALL 16780 0 5
25024: GO 25027
25026: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 1
25034: ARRAY
25035: PPUSH
25036: LD_VAR 0 1
25040: PUSH
25041: LD_INT 1
25043: ARRAY
25044: PPUSH
25045: CALL_OW 250
25049: PPUSH
25050: LD_VAR 0 1
25054: PUSH
25055: LD_INT 1
25057: ARRAY
25058: PPUSH
25059: CALL_OW 251
25063: PPUSH
25064: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25068: LD_VAR 0 2
25072: PUSH
25073: LD_INT 2
25075: ARRAY
25076: PPUSH
25077: LD_VAR 0 1
25081: PUSH
25082: LD_INT 1
25084: ARRAY
25085: PPUSH
25086: CALL_OW 250
25090: PPUSH
25091: LD_VAR 0 1
25095: PUSH
25096: LD_INT 1
25098: ARRAY
25099: PPUSH
25100: CALL_OW 251
25104: PPUSH
25105: CALL_OW 174
// end ; end ;
25109: PPOPN 2
25111: END
// every 32 32$30 do var ubase ;
25112: GO 25114
25114: DISABLE
25115: LD_INT 0
25117: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25118: LD_ADDR_VAR 0 1
25122: PUSH
25123: LD_INT 21
25125: PUSH
25126: LD_INT 3
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: LD_INT 22
25135: PUSH
25136: LD_EXP 1
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: PPUSH
25149: CALL_OW 69
25153: ST_TO_ADDR
// if ubase then
25154: LD_VAR 0 1
25158: IFFALSE 25359
// begin case Rand ( 1 , 3 ) of 1 :
25160: LD_INT 1
25162: PPUSH
25163: LD_INT 3
25165: PPUSH
25166: CALL_OW 12
25170: PUSH
25171: LD_INT 1
25173: DOUBLE
25174: EQUAL
25175: IFTRUE 25179
25177: GO 25219
25179: POP
// depart ( attack diff broken , sol ^ sci , attack_l , true , false ) ; 2 :
25180: LD_LOC 5
25184: PUSH
25185: LD_LOC 21
25189: DIFF
25190: PPUSH
25191: LD_EXP 90
25195: PUSH
25196: LD_EXP 91
25200: ADD
25201: PPUSH
25202: LD_LOC 22
25206: PPUSH
25207: LD_INT 1
25209: PPUSH
25210: LD_INT 0
25212: PPUSH
25213: CALL 16780 0 5
25217: GO 25316
25219: LD_INT 2
25221: DOUBLE
25222: EQUAL
25223: IFTRUE 25227
25225: GO 25267
25227: POP
// depart ( attack diff broken , sol ^ sci , attack_m , true , false ) ; 3 :
25228: LD_LOC 5
25232: PUSH
25233: LD_LOC 21
25237: DIFF
25238: PPUSH
25239: LD_EXP 90
25243: PUSH
25244: LD_EXP 91
25248: ADD
25249: PPUSH
25250: LD_LOC 23
25254: PPUSH
25255: LD_INT 1
25257: PPUSH
25258: LD_INT 0
25260: PPUSH
25261: CALL 16780 0 5
25265: GO 25316
25267: LD_INT 3
25269: DOUBLE
25270: EQUAL
25271: IFTRUE 25275
25273: GO 25315
25275: POP
// depart ( attack diff broken , sol ^ sci , attack_r , true , false ) ; end ;
25276: LD_LOC 5
25280: PUSH
25281: LD_LOC 21
25285: DIFF
25286: PPUSH
25287: LD_EXP 90
25291: PUSH
25292: LD_EXP 91
25296: ADD
25297: PPUSH
25298: LD_LOC 24
25302: PPUSH
25303: LD_INT 1
25305: PPUSH
25306: LD_INT 0
25308: PPUSH
25309: CALL 16780 0 5
25313: GO 25316
25315: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25316: LD_LOC 5
25320: PUSH
25321: LD_LOC 21
25325: DIFF
25326: PPUSH
25327: LD_VAR 0 1
25331: PUSH
25332: LD_INT 1
25334: ARRAY
25335: PPUSH
25336: CALL_OW 250
25340: PPUSH
25341: LD_VAR 0 1
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: PPUSH
25350: CALL_OW 251
25354: PPUSH
25355: CALL_OW 174
// end ; end ;
25359: PPOPN 1
25361: END
// every 40 40$30 do var ubase , at ;
25362: GO 25364
25364: DISABLE
25365: LD_INT 0
25367: PPUSH
25368: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25369: LD_ADDR_VAR 0 1
25373: PUSH
25374: LD_INT 21
25376: PUSH
25377: LD_INT 3
25379: PUSH
25380: EMPTY
25381: LIST
25382: LIST
25383: PUSH
25384: LD_INT 22
25386: PUSH
25387: LD_EXP 1
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PPUSH
25400: CALL_OW 69
25404: ST_TO_ADDR
// if ubase then
25405: LD_VAR 0 1
25409: IFFALSE 25856
// begin at := split ( ( attack union scout ) diff broken ) ;
25411: LD_ADDR_VAR 0 2
25415: PUSH
25416: LD_LOC 5
25420: PUSH
25421: LD_LOC 4
25425: UNION
25426: PUSH
25427: LD_LOC 21
25431: DIFF
25432: PPUSH
25433: CALL 17393 0 1
25437: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
25438: LD_INT 1
25440: PPUSH
25441: LD_INT 3
25443: PPUSH
25444: CALL_OW 12
25448: PUSH
25449: LD_INT 1
25451: DOUBLE
25452: EQUAL
25453: IFTRUE 25457
25455: GO 25501
25457: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25458: LD_VAR 0 2
25462: PUSH
25463: LD_INT 1
25465: ARRAY
25466: PPUSH
25467: LD_EXP 90
25471: PUSH
25472: LD_EXP 91
25476: ADD
25477: PUSH
25478: LD_EXP 93
25482: ADD
25483: PPUSH
25484: LD_LOC 22
25488: PPUSH
25489: LD_INT 1
25491: PPUSH
25492: LD_INT 0
25494: PPUSH
25495: CALL 16780 0 5
25499: GO 25606
25501: LD_INT 2
25503: DOUBLE
25504: EQUAL
25505: IFTRUE 25509
25507: GO 25553
25509: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25510: LD_VAR 0 2
25514: PUSH
25515: LD_INT 1
25517: ARRAY
25518: PPUSH
25519: LD_EXP 90
25523: PUSH
25524: LD_EXP 91
25528: ADD
25529: PUSH
25530: LD_EXP 93
25534: ADD
25535: PPUSH
25536: LD_LOC 23
25540: PPUSH
25541: LD_INT 1
25543: PPUSH
25544: LD_INT 0
25546: PPUSH
25547: CALL 16780 0 5
25551: GO 25606
25553: LD_INT 3
25555: DOUBLE
25556: EQUAL
25557: IFTRUE 25561
25559: GO 25605
25561: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25562: LD_VAR 0 2
25566: PUSH
25567: LD_INT 1
25569: ARRAY
25570: PPUSH
25571: LD_EXP 90
25575: PUSH
25576: LD_EXP 91
25580: ADD
25581: PUSH
25582: LD_EXP 93
25586: ADD
25587: PPUSH
25588: LD_LOC 24
25592: PPUSH
25593: LD_INT 1
25595: PPUSH
25596: LD_INT 0
25598: PPUSH
25599: CALL 16780 0 5
25603: GO 25606
25605: POP
// case Rand ( 1 , 3 ) of 1 :
25606: LD_INT 1
25608: PPUSH
25609: LD_INT 3
25611: PPUSH
25612: CALL_OW 12
25616: PUSH
25617: LD_INT 1
25619: DOUBLE
25620: EQUAL
25621: IFTRUE 25625
25623: GO 25669
25625: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25626: LD_VAR 0 2
25630: PUSH
25631: LD_INT 2
25633: ARRAY
25634: PPUSH
25635: LD_EXP 90
25639: PUSH
25640: LD_EXP 91
25644: ADD
25645: PUSH
25646: LD_EXP 93
25650: ADD
25651: PPUSH
25652: LD_LOC 22
25656: PPUSH
25657: LD_INT 1
25659: PPUSH
25660: LD_INT 0
25662: PPUSH
25663: CALL 16780 0 5
25667: GO 25774
25669: LD_INT 2
25671: DOUBLE
25672: EQUAL
25673: IFTRUE 25677
25675: GO 25721
25677: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25678: LD_VAR 0 2
25682: PUSH
25683: LD_INT 2
25685: ARRAY
25686: PPUSH
25687: LD_EXP 90
25691: PUSH
25692: LD_EXP 91
25696: ADD
25697: PUSH
25698: LD_EXP 93
25702: ADD
25703: PPUSH
25704: LD_LOC 23
25708: PPUSH
25709: LD_INT 1
25711: PPUSH
25712: LD_INT 0
25714: PPUSH
25715: CALL 16780 0 5
25719: GO 25774
25721: LD_INT 3
25723: DOUBLE
25724: EQUAL
25725: IFTRUE 25729
25727: GO 25773
25729: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25730: LD_VAR 0 2
25734: PUSH
25735: LD_INT 2
25737: ARRAY
25738: PPUSH
25739: LD_EXP 90
25743: PUSH
25744: LD_EXP 91
25748: ADD
25749: PUSH
25750: LD_EXP 93
25754: ADD
25755: PPUSH
25756: LD_LOC 24
25760: PPUSH
25761: LD_INT 1
25763: PPUSH
25764: LD_INT 0
25766: PPUSH
25767: CALL 16780 0 5
25771: GO 25774
25773: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25774: LD_VAR 0 2
25778: PUSH
25779: LD_INT 1
25781: ARRAY
25782: PPUSH
25783: LD_VAR 0 1
25787: PUSH
25788: LD_INT 1
25790: ARRAY
25791: PPUSH
25792: CALL_OW 250
25796: PPUSH
25797: LD_VAR 0 1
25801: PUSH
25802: LD_INT 1
25804: ARRAY
25805: PPUSH
25806: CALL_OW 251
25810: PPUSH
25811: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25815: LD_VAR 0 2
25819: PUSH
25820: LD_INT 2
25822: ARRAY
25823: PPUSH
25824: LD_VAR 0 1
25828: PUSH
25829: LD_INT 1
25831: ARRAY
25832: PPUSH
25833: CALL_OW 250
25837: PPUSH
25838: LD_VAR 0 1
25842: PUSH
25843: LD_INT 1
25845: ARRAY
25846: PPUSH
25847: CALL_OW 251
25851: PPUSH
25852: CALL_OW 174
// end ; end ;
25856: PPOPN 2
25858: END
// export function count_crates ; var deps , i ; begin
25859: LD_INT 0
25861: PPUSH
25862: PPUSH
25863: PPUSH
// deps := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25864: LD_ADDR_VAR 0 2
25868: PUSH
25869: LD_INT 22
25871: PUSH
25872: LD_EXP 1
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: LD_INT 2
25883: PUSH
25884: LD_INT 30
25886: PUSH
25887: LD_INT 0
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 30
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: LIST
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 69
25917: ST_TO_ADDR
// for i in deps do
25918: LD_ADDR_VAR 0 3
25922: PUSH
25923: LD_VAR 0 2
25927: PUSH
25928: FOR_IN
25929: IFFALSE 25962
// result := result + GetResourceType ( GetBase ( i ) , mat_cans ) ;
25931: LD_ADDR_VAR 0 1
25935: PUSH
25936: LD_VAR 0 1
25940: PUSH
25941: LD_VAR 0 3
25945: PPUSH
25946: CALL_OW 274
25950: PPUSH
25951: LD_INT 1
25953: PPUSH
25954: CALL_OW 275
25958: PLUS
25959: ST_TO_ADDR
25960: GO 25928
25962: POP
25963: POP
// end ;
25964: LD_VAR 0 1
25968: RET
// every 0 0$1 do var zbyva , prebyva ;
25969: GO 25971
25971: DISABLE
25972: LD_INT 0
25974: PPUSH
25975: PPUSH
// begin sec := sec + 1 ;
25976: LD_ADDR_LOC 29
25980: PUSH
25981: LD_LOC 29
25985: PUSH
25986: LD_INT 1
25988: PLUS
25989: ST_TO_ADDR
// zbyva := MaterialNavic - count_crates ;
25990: LD_ADDR_VAR 0 1
25994: PUSH
25995: LD_EXP 51
25999: PUSH
26000: CALL 25859 0 0
26004: MINUS
26005: ST_TO_ADDR
// if zbyva < 0 then
26006: LD_VAR 0 1
26010: PUSH
26011: LD_INT 0
26013: LESS
26014: IFFALSE 26039
// begin prebyva := zbyva * ( - 1 ) ;
26016: LD_ADDR_VAR 0 2
26020: PUSH
26021: LD_VAR 0 1
26025: PUSH
26026: LD_INT 1
26028: NEG
26029: MUL
26030: ST_TO_ADDR
// zbyva := 0 ;
26031: LD_ADDR_VAR 0 1
26035: PUSH
26036: LD_INT 0
26038: ST_TO_ADDR
// end ; display_strings := [ #Am06-1 , zbyva , #Am06-2 , 50 50$0 - ( tick - mytick ) ] ;
26039: LD_ADDR_OWVAR 47
26043: PUSH
26044: LD_STRING #Am06-1
26046: PUSH
26047: LD_VAR 0 1
26051: PUSH
26052: LD_STRING #Am06-2
26054: PUSH
26055: LD_INT 105000
26057: PUSH
26058: LD_OWVAR 1
26062: PUSH
26063: LD_EXP 86
26067: MINUS
26068: MINUS
26069: PUSH
26070: EMPTY
26071: LIST
26072: LIST
26073: LIST
26074: LIST
26075: ST_TO_ADDR
// enable ;
26076: ENABLE
// end ;
26077: PPOPN 2
26079: END
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26080: LD_INT 4
26082: PPUSH
26083: LD_INT 22
26085: PUSH
26086: LD_EXP 1
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PPUSH
26095: CALL_OW 70
26099: IFFALSE 26174
26101: GO 26103
26103: DISABLE
26104: LD_INT 0
26106: PPUSH
// begin under_attack := true ;
26107: LD_ADDR_EXP 64
26111: PUSH
26112: LD_INT 1
26114: ST_TO_ADDR
// for i in FilterUnitsInArea ( near_base , [ f_side , you ] ) do
26115: LD_ADDR_VAR 0 1
26119: PUSH
26120: LD_INT 4
26122: PPUSH
26123: LD_INT 22
26125: PUSH
26126: LD_EXP 1
26130: PUSH
26131: EMPTY
26132: LIST
26133: LIST
26134: PPUSH
26135: CALL_OW 70
26139: PUSH
26140: FOR_IN
26141: IFFALSE 26171
// ComAttackUnit ( defence union attack union scout , i ) ;
26143: LD_LOC 6
26147: PUSH
26148: LD_LOC 5
26152: UNION
26153: PUSH
26154: LD_LOC 4
26158: UNION
26159: PPUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: CALL_OW 115
26169: GO 26140
26171: POP
26172: POP
// enable ;
26173: ENABLE
// end ;
26174: PPOPN 1
26176: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26177: LD_INT 4
26179: PPUSH
26180: LD_INT 22
26182: PUSH
26183: LD_EXP 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: PPUSH
26192: CALL_OW 70
26196: NOT
26197: IFFALSE 26214
26199: GO 26201
26201: DISABLE
26202: LD_INT 0
26204: PPUSH
// begin under_attack := false ;
26205: LD_ADDR_EXP 64
26209: PUSH
26210: LD_INT 0
26212: ST_TO_ADDR
// enable ;
26213: ENABLE
// end ; end_of_file
26214: PPOPN 1
26216: END
// var BaseBuild ; every 0 0$1.0 do var set_fuel , fuel , depot ;
26217: GO 26219
26219: DISABLE
26220: LD_INT 0
26222: PPUSH
26223: PPUSH
26224: PPUSH
// begin for depot in FilterAllUnits ( [ [ f_btype , b_depot ] , [ f_side , you ] ] ) do
26225: LD_ADDR_VAR 0 3
26229: PUSH
26230: LD_INT 30
26232: PUSH
26233: LD_INT 0
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: PUSH
26240: LD_INT 22
26242: PUSH
26243: LD_EXP 1
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PPUSH
26256: CALL_OW 69
26260: PUSH
26261: FOR_IN
26262: IFFALSE 26369
// for set_fuel in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] , [ f_dist , depot , 8 ] ] ) do
26264: LD_ADDR_VAR 0 1
26268: PUSH
26269: LD_INT 21
26271: PUSH
26272: LD_INT 2
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 22
26281: PUSH
26282: LD_EXP 1
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 91
26293: PUSH
26294: LD_VAR 0 3
26298: PUSH
26299: LD_INT 8
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: LIST
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: LIST
26311: PPUSH
26312: CALL_OW 69
26316: PUSH
26317: FOR_IN
26318: IFFALSE 26365
// begin fuel := GetFuel ( set_fuel ) ;
26320: LD_ADDR_VAR 0 2
26324: PUSH
26325: LD_VAR 0 1
26329: PPUSH
26330: CALL_OW 261
26334: ST_TO_ADDR
// if fuel <= 80 then
26335: LD_VAR 0 2
26339: PUSH
26340: LD_INT 80
26342: LESSEQUAL
26343: IFFALSE 26363
// SetFuel ( set_fuel , fuel + 20 ) ;
26345: LD_VAR 0 1
26349: PPUSH
26350: LD_VAR 0 2
26354: PUSH
26355: LD_INT 20
26357: PLUS
26358: PPUSH
26359: CALL_OW 240
// end ;
26363: GO 26317
26365: POP
26366: POP
26367: GO 26261
26369: POP
26370: POP
// enable ;
26371: ENABLE
// end ;
26372: PPOPN 3
26374: END
// export maj_ct ; on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) then
26375: LD_VAR 0 1
26379: PPUSH
26380: LD_INT 22
26382: PUSH
26383: LD_EXP 1
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: PUSH
26392: LD_INT 30
26394: PUSH
26395: LD_INT 0
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PPUSH
26406: CALL_OW 72
26410: IFFALSE 26474
// begin BaseBuild := true ;
26412: LD_ADDR_LOC 32
26416: PUSH
26417: LD_INT 1
26419: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
26420: LD_STRING M1a
26422: PPUSH
26423: CALL_OW 337
// Setbname ( UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) [ 1 ] , epsilon ) ;
26427: LD_VAR 0 1
26431: PPUSH
26432: LD_INT 22
26434: PUSH
26435: LD_EXP 1
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 30
26446: PUSH
26447: LD_INT 0
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PPUSH
26458: CALL_OW 72
26462: PUSH
26463: LD_INT 1
26465: ARRAY
26466: PPUSH
26467: LD_STRING epsilon
26469: PPUSH
26470: CALL_OW 500
// end ; if GetBType ( build ) = b_control_tower then
26474: LD_VAR 0 1
26478: PPUSH
26479: CALL_OW 266
26483: PUSH
26484: LD_INT 36
26486: EQUAL
26487: IFFALSE 26497
// maj_ct := true ;
26489: LD_ADDR_EXP 94
26493: PUSH
26494: LD_INT 1
26496: ST_TO_ADDR
// end ;
26497: PPOPN 1
26499: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_factory ] ] ) then
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 22
26507: PUSH
26508: LD_EXP 1
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 30
26519: PUSH
26520: LD_INT 3
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PPUSH
26531: CALL_OW 72
26535: IFFALSE 26544
// MyHint ( NonCombat ) ;
26537: LD_STRING NonCombat
26539: PPUSH
26540: CALL 17504 0 1
// end ;
26544: PPOPN 1
26546: END
// every 0 0$3 do var ok , sez , i ;
26547: GO 26549
26549: DISABLE
26550: LD_INT 0
26552: PPUSH
26553: PPUSH
26554: PPUSH
// begin sez := [ ] ;
26555: LD_ADDR_VAR 0 2
26559: PUSH
26560: EMPTY
26561: ST_TO_ADDR
// ok := false ;
26562: LD_ADDR_VAR 0 1
26566: PUSH
26567: LD_INT 0
26569: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_control , control_remote ] ) do
26570: LD_ADDR_VAR 0 3
26574: PUSH
26575: LD_INT 33
26577: PUSH
26578: LD_INT 2
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PPUSH
26585: CALL_OW 69
26589: PUSH
26590: FOR_IN
26591: IFFALSE 26640
// begin if IsControledBy ( i ) in sez then
26593: LD_VAR 0 3
26597: PPUSH
26598: CALL_OW 312
26602: PUSH
26603: LD_VAR 0 2
26607: IN
26608: IFFALSE 26622
// begin ok := true ;
26610: LD_ADDR_VAR 0 1
26614: PUSH
26615: LD_INT 1
26617: ST_TO_ADDR
// break ;
26618: GO 26640
// end else
26620: GO 26638
// sez := sez ^ i ;
26622: LD_ADDR_VAR 0 2
26626: PUSH
26627: LD_VAR 0 2
26631: PUSH
26632: LD_VAR 0 3
26636: ADD
26637: ST_TO_ADDR
// end ;
26638: GO 26590
26640: POP
26641: POP
// if ok then
26642: LD_VAR 0 1
26646: IFFALSE 26657
// begin ChangeMissionObjectives ( MRa ) ;
26648: LD_STRING MRa
26650: PPUSH
26651: CALL_OW 337
// end else
26655: GO 26658
// enable ;
26657: ENABLE
// end ;
26658: PPOPN 3
26660: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_RemCont and GetSide ( lab ) = you then
26661: LD_VAR 0 1
26665: PUSH
26666: LD_INT 15
26668: EQUAL
26669: PUSH
26670: LD_VAR 0 2
26674: PPUSH
26675: CALL_OW 255
26679: PUSH
26680: LD_EXP 1
26684: EQUAL
26685: AND
26686: IFFALSE 26699
// begin DialogR2 ;
26688: CALL 6471 0 0
// MyHint ( RemoteControlTower ) ;
26692: LD_STRING RemoteControlTower
26694: PPUSH
26695: CALL 17504 0 1
// end ; if tech = tech_MatDet and GetSide ( lab ) = you then
26699: LD_VAR 0 1
26703: PUSH
26704: LD_INT 7
26706: EQUAL
26707: PUSH
26708: LD_VAR 0 2
26712: PPUSH
26713: CALL_OW 255
26717: PUSH
26718: LD_EXP 1
26722: EQUAL
26723: AND
26724: IFFALSE 26733
// begin MyHint ( MaterialisationDetection ) ;
26726: LD_STRING MaterialisationDetection
26728: PPUSH
26729: CALL 17504 0 1
// end ; end ; end_of_file
26733: PPOPN 2
26735: END
// every 0 0$2 + 0 0$0.1 do
26736: GO 26738
26738: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
26739: LD_INT 22
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: LD_INT 2
26751: PUSH
26752: LD_INT 25
26754: PUSH
26755: LD_INT 12
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 25
26764: PUSH
26765: LD_INT 16
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 25
26774: PUSH
26775: LD_INT 15
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 25
26784: PUSH
26785: LD_INT 17
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: LIST
26796: LIST
26797: LIST
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PPUSH
26803: CALL_OW 69
26807: PUSH
26808: LD_INT 22
26810: PUSH
26811: LD_INT 1
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: LD_INT 21
26820: PUSH
26821: LD_INT 1
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: PUSH
26828: LD_INT 3
26830: PUSH
26831: LD_INT 2
26833: PUSH
26834: LD_INT 25
26836: PUSH
26837: LD_INT 12
26839: PUSH
26840: EMPTY
26841: LIST
26842: LIST
26843: PUSH
26844: LD_INT 25
26846: PUSH
26847: LD_INT 16
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 25
26856: PUSH
26857: LD_INT 15
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: LD_INT 25
26866: PUSH
26867: LD_INT 17
26869: PUSH
26870: EMPTY
26871: LIST
26872: LIST
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: LIST
26878: LIST
26879: LIST
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: LIST
26889: PPUSH
26890: CALL_OW 69
26894: GREATER
26895: IFFALSE 26906
// begin SetAchievement ( ACH_POTA ) ;
26897: LD_STRING ACH_POTA
26899: PPUSH
26900: CALL_OW 543
// exit ;
26904: GO 26907
// end ; enable ;
26906: ENABLE
// end ;
26907: END
// export function SA_OnKurtSpared ; begin
26908: LD_INT 0
26910: PPUSH
// SetAchievement ( ACH_MER ) ;
26911: LD_STRING ACH_MER
26913: PPUSH
26914: CALL_OW 543
// end ;
26918: LD_VAR 0 1
26922: RET
// export function SA_On1000CratesGathered ; begin
26923: LD_INT 0
26925: PPUSH
// SetAchievement ( ACH_CAP ) ;
26926: LD_STRING ACH_CAP
26928: PPUSH
26929: CALL_OW 543
// end ;
26933: LD_VAR 0 1
26937: RET

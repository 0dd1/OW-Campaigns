// export you , russians , arabians , you2 ; export apemans ; export prilet_tvoji ; export prilet_rusaci ; export prilet_arabi ; export all , other ; export not_char , used , opicaci ; export zgamy2 ; export JMM ; export Har ; export RadioSci ; export Sol1 , Eng1 ; export Frank , Lisa ; export Cyrus , Bobby , Donaldson , Brown , Denis , Gladstone ; export MSol1 , MSol2 , MSol3 , MEng1 , MMec1 , Joan ; export Op1 , Op2 , Op3 , Op4 , Op5 ; export RMSo1 , RMSo2 , RMEn1 , RMMe1 ; export Kurt ; export Car1 , Car2 ; export Denis_P , Kurt_P , Joan_P , Lisa_P , Frank_P ; export MaterialNavic ; export DialogInProgress ; export map_size_x , map_size_y ; export start_game ; export test_JMM_Joan ; export before_d6 ; export act_Lisa_JMM ; export hledani ; export attacky ; export more_scouting ; export go_up ; export attacking ; export under_attack ; export odplata_1 ; export odplata_2 ; export attack_to_scouting ; export start_scouting ; export WasD11aa , WasD11ab , WasD11b , WasD11c , WasD11d , WasD11e , WasD11f ; export crates ; export list_of_R1_query ; export Gamma3_lab_upgraded_to_opto ; export Gamma3_lab_upgraded_to_weapon ; export radar_invented ; export vzit_opicaku ; export remote_tried ; export Gamma2Commander ; export NavicLidi ; export KurtTryToEscape ; starting begin disable ( 33 ) ;
   0: LD_INT 33
   2: DISABLE_MARKED
// disable_prediction := true ;
   3: LD_ADDR_OWVAR 50
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// map_size_x := 100 ;
  11: LD_ADDR_EXP 53
  15: PUSH
  16: LD_INT 100
  18: ST_TO_ADDR
// map_size_y := 100 ;
  19: LD_ADDR_EXP 54
  23: PUSH
  24: LD_INT 100
  26: ST_TO_ADDR
// prepare_sides ;
  27: CALL 2061 0 0
// load_characters ;
  31: CALL 268 0 0
// prepare_russian_units ;
  35: CALL 1690 0 0
// prepare_arabian_units ;
  39: CALL 2016 0 0
// if radar_invented then
  43: LD_EXP 80
  47: IFFALSE 64
// SetTech ( tech_Radar , you , state_researched ) ;
  49: LD_INT 6
  51: PPUSH
  52: LD_EXP 1
  56: PPUSH
  57: LD_INT 2
  59: PPUSH
  60: CALL_OW 322
// Gamma3_lab_upgraded_to_opto := false ;
  64: LD_ADDR_EXP 78
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// Gamma3_lab_upgraded_to_weapon := false ;
  72: LD_ADDR_EXP 79
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// SetDifficulty ;
  80: CALL 2161 0 0
// apemans := FilterAllUnits ( [ f_nation , nation_nature ] ) ;
  84: LD_ADDR_EXP 5
  88: PUSH
  89: LD_INT 23
  91: PUSH
  92: LD_INT 0
  94: PUSH
  95: EMPTY
  96: LIST
  97: LIST
  98: PPUSH
  99: CALL_OW 69
 103: ST_TO_ADDR
// Kurt_P := false ;
 104: LD_ADDR_EXP 47
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// Joan_P := false ;
 112: LD_ADDR_EXP 48
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// start_game := false ;
 120: LD_ADDR_EXP 55
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// test_JMM_Joan := false ;
 128: LD_ADDR_EXP 56
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// before_d6 := false ;
 136: LD_ADDR_EXP 57
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// act_Lisa_JMM := false ;
 144: LD_ADDR_EXP 58
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// hledani := false ;
 152: LD_ADDR_EXP 59
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// more_scouting := false ;
 160: LD_ADDR_EXP 61
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// go_up := false ;
 168: LD_ADDR_EXP 62
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// WasD11aa := false ;
 176: LD_ADDR_EXP 69
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// WasD11ab := false ;
 184: LD_ADDR_EXP 70
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// WasD11b := false ;
 192: LD_ADDR_EXP 71
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// WasD11c := false ;
 200: LD_ADDR_EXP 72
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// WasD11d := false ;
 208: LD_ADDR_EXP 73
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// WasD11e := false ;
 216: LD_ADDR_EXP 74
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// WasD11f := false ;
 224: LD_ADDR_EXP 75
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// crates := [ ] ;
 232: LD_ADDR_EXP 76
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// attacky := 0 ;
 239: LD_ADDR_EXP 60
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// attacking := false ;
 247: LD_ADDR_EXP 63
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// under_attack := false ;
 255: LD_ADDR_EXP 64
 259: PUSH
 260: LD_INT 0
 262: ST_TO_ADDR
// Dialog1 ;
 263: CALL 4388 0 0
// end ;
 267: END
// function load_characters ; begin
 268: LD_INT 0
 270: PPUSH
// InitUc ;
 271: CALL_OW 18
// InitHc ;
 275: CALL_OW 19
// InitVc ;
 279: CALL_OW 20
// uc_side := arabians ;
 283: LD_ADDR_OWVAR 20
 287: PUSH
 288: LD_EXP 3
 292: ST_TO_ADDR
// uc_nation := nation_arabian ;
 293: LD_ADDR_OWVAR 21
 297: PUSH
 298: LD_INT 2
 300: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
 301: LD_ADDR_EXP 43
 305: PUSH
 306: LD_STRING Kurt
 308: PPUSH
 309: CALL_OW 25
 313: ST_TO_ADDR
// uc_side := you ;
 314: LD_ADDR_OWVAR 20
 318: PUSH
 319: LD_EXP 1
 323: ST_TO_ADDR
// uc_nation := nation_american ;
 324: LD_ADDR_OWVAR 21
 328: PUSH
 329: LD_INT 1
 331: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 332: LD_ADDR_EXP 15
 336: PUSH
 337: LD_STRING JMM
 339: PPUSH
 340: CALL_OW 34
 344: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 345: LD_ADDR_EXP 16
 349: PUSH
 350: LD_STRING Harisson
 352: PPUSH
 353: CALL_OW 25
 357: ST_TO_ADDR
// if TestCharacters ( other_from5to6 ) then
 358: LD_STRING other_from5to6
 360: PPUSH
 361: CALL_OW 28
 365: IFFALSE 382
// all := CreateCharacterSet ( other_from5to6 ) else
 367: LD_ADDR_EXP 9
 371: PUSH
 372: LD_STRING other_from5to6
 374: PPUSH
 375: CALL_OW 31
 379: ST_TO_ADDR
 380: GO 389
// all := [ ] ;
 382: LD_ADDR_EXP 9
 386: PUSH
 387: EMPTY
 388: ST_TO_ADDR
// if CheckCharacterSet ( radiosci_from5to6 ) then
 389: LD_STRING radiosci_from5to6
 391: PPUSH
 392: CALL_OW 29
 396: IFFALSE 413
// RadioSci := CreateCharacter ( radiosci_from5to6 ) else
 398: LD_ADDR_EXP 17
 402: PUSH
 403: LD_STRING radiosci_from5to6
 405: PPUSH
 406: CALL_OW 34
 410: ST_TO_ADDR
 411: GO 433
// begin PrepareScientist ( sex_male , 10 ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 10
 418: PPUSH
 419: CALL_OW 384
// RadioSci := CreateHuman ;
 423: LD_ADDR_EXP 17
 427: PUSH
 428: CALL_OW 44
 432: ST_TO_ADDR
// end ; DeleteCharacters ( radiosci_from5to6 ) ;
 433: LD_STRING radiosci_from5to6
 435: PPUSH
 436: CALL_OW 40
// other := all ;
 440: LD_ADDR_EXP 10
 444: PUSH
 445: LD_EXP 9
 449: ST_TO_ADDR
// radar_invented := LoadVariable ( RadarDeveloped , false ) ;
 450: LD_ADDR_EXP 80
 454: PUSH
 455: LD_STRING RadarDeveloped
 457: PPUSH
 458: LD_INT 0
 460: PPUSH
 461: CALL_OW 30
 465: ST_TO_ADDR
// Gamma2Commander := LoadVariable ( Gamma2Commander , 3 ) ;
 466: LD_ADDR_EXP 83
 470: PUSH
 471: LD_STRING Gamma2Commander
 473: PPUSH
 474: LD_INT 3
 476: PPUSH
 477: CALL_OW 30
 481: ST_TO_ADDR
// opicaci := [ ] ;
 482: LD_ADDR_EXP 13
 486: PUSH
 487: EMPTY
 488: ST_TO_ADDR
// if CheckCharacterSet ( opicaci ) then
 489: LD_STRING opicaci
 491: PPUSH
 492: CALL_OW 29
 496: IFFALSE 511
// opicaci := CreateCharacterSet ( opicaci ) ;
 498: LD_ADDR_EXP 13
 502: PUSH
 503: LD_STRING opicaci
 505: PPUSH
 506: CALL_OW 31
 510: ST_TO_ADDR
// Lisa := 0 ;
 511: LD_ADDR_EXP 21
 515: PUSH
 516: LD_INT 0
 518: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 519: LD_STRING Lisa
 521: PPUSH
 522: CALL_OW 29
 526: IFFALSE 584
// if LoadVariable ( LisaLoc , 0 ) = 8 then
 528: LD_STRING LisaLoc
 530: PPUSH
 531: LD_INT 0
 533: PPUSH
 534: CALL_OW 30
 538: PUSH
 539: LD_INT 8
 541: EQUAL
 542: IFFALSE 584
// begin Lisa := CreateCharacter ( Lisa ) ;
 544: LD_ADDR_EXP 21
 548: PUSH
 549: LD_STRING Lisa
 551: PPUSH
 552: CALL_OW 34
 556: ST_TO_ADDR
// Lisa_P := true ;
 557: LD_ADDR_EXP 49
 561: PUSH
 562: LD_INT 1
 564: ST_TO_ADDR
// all := all ^ [ Lisa ] ;
 565: LD_ADDR_EXP 9
 569: PUSH
 570: LD_EXP 9
 574: PUSH
 575: LD_EXP 21
 579: PUSH
 580: EMPTY
 581: LIST
 582: ADD
 583: ST_TO_ADDR
// end ; Cyrus := 0 ;
 584: LD_ADDR_EXP 22
 588: PUSH
 589: LD_INT 0
 591: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 592: LD_STRING Cyrus
 594: PPUSH
 595: CALL_OW 29
 599: IFFALSE 649
// if LoadVariable ( CyrusLoc , 0 ) = 8 then
 601: LD_STRING CyrusLoc
 603: PPUSH
 604: LD_INT 0
 606: PPUSH
 607: CALL_OW 30
 611: PUSH
 612: LD_INT 8
 614: EQUAL
 615: IFFALSE 649
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 617: LD_ADDR_EXP 22
 621: PUSH
 622: LD_STRING Cyrus
 624: PPUSH
 625: CALL_OW 34
 629: ST_TO_ADDR
// all := all ^ [ Cyrus ] ;
 630: LD_ADDR_EXP 9
 634: PUSH
 635: LD_EXP 9
 639: PUSH
 640: LD_EXP 22
 644: PUSH
 645: EMPTY
 646: LIST
 647: ADD
 648: ST_TO_ADDR
// end ; Bobby := 0 ;
 649: LD_ADDR_EXP 23
 653: PUSH
 654: LD_INT 0
 656: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 657: LD_STRING Bobby
 659: PPUSH
 660: CALL_OW 29
 664: IFFALSE 714
// if LoadVariable ( BobbyLoc , 0 ) = 8 then
 666: LD_STRING BobbyLoc
 668: PPUSH
 669: LD_INT 0
 671: PPUSH
 672: CALL_OW 30
 676: PUSH
 677: LD_INT 8
 679: EQUAL
 680: IFFALSE 714
// begin Bobby := CreateCharacter ( Bobby ) ;
 682: LD_ADDR_EXP 23
 686: PUSH
 687: LD_STRING Bobby
 689: PPUSH
 690: CALL_OW 34
 694: ST_TO_ADDR
// all := all ^ [ Bobby ] ;
 695: LD_ADDR_EXP 9
 699: PUSH
 700: LD_EXP 9
 704: PUSH
 705: LD_EXP 23
 709: PUSH
 710: EMPTY
 711: LIST
 712: ADD
 713: ST_TO_ADDR
// end ; Frank := 0 ;
 714: LD_ADDR_EXP 20
 718: PUSH
 719: LD_INT 0
 721: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 722: LD_STRING Frank
 724: PPUSH
 725: CALL_OW 29
 729: IFFALSE 787
// if LoadVariable ( FrankLoc , 0 ) = 8 then
 731: LD_STRING FrankLoc
 733: PPUSH
 734: LD_INT 0
 736: PPUSH
 737: CALL_OW 30
 741: PUSH
 742: LD_INT 8
 744: EQUAL
 745: IFFALSE 787
// begin Frank := CreateCharacter ( Frank ) ;
 747: LD_ADDR_EXP 20
 751: PUSH
 752: LD_STRING Frank
 754: PPUSH
 755: CALL_OW 34
 759: ST_TO_ADDR
// Frank_P := true ;
 760: LD_ADDR_EXP 50
 764: PUSH
 765: LD_INT 1
 767: ST_TO_ADDR
// all := all ^ [ Frank ] ;
 768: LD_ADDR_EXP 9
 772: PUSH
 773: LD_EXP 9
 777: PUSH
 778: LD_EXP 20
 782: PUSH
 783: EMPTY
 784: LIST
 785: ADD
 786: ST_TO_ADDR
// end ; Donaldson := 0 ;
 787: LD_ADDR_EXP 24
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 795: LD_STRING Donaldson
 797: PPUSH
 798: CALL_OW 29
 802: IFFALSE 852
// if LoadVariable ( DonaldsonLoc , 0 ) = 8 then
 804: LD_STRING DonaldsonLoc
 806: PPUSH
 807: LD_INT 0
 809: PPUSH
 810: CALL_OW 30
 814: PUSH
 815: LD_INT 8
 817: EQUAL
 818: IFFALSE 852
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 820: LD_ADDR_EXP 24
 824: PUSH
 825: LD_STRING Donaldson
 827: PPUSH
 828: CALL_OW 34
 832: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 833: LD_ADDR_EXP 9
 837: PUSH
 838: LD_EXP 9
 842: PUSH
 843: LD_EXP 24
 847: PUSH
 848: EMPTY
 849: LIST
 850: ADD
 851: ST_TO_ADDR
// end ; Brown := 0 ;
 852: LD_ADDR_EXP 25
 856: PUSH
 857: LD_INT 0
 859: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 860: LD_STRING Brown
 862: PPUSH
 863: CALL_OW 29
 867: IFFALSE 917
// if LoadVariable ( BrownLoc , 0 ) = 8 then
 869: LD_STRING BrownLoc
 871: PPUSH
 872: LD_INT 0
 874: PPUSH
 875: CALL_OW 30
 879: PUSH
 880: LD_INT 8
 882: EQUAL
 883: IFFALSE 917
// begin Brown := CreateCharacter ( Brown ) ;
 885: LD_ADDR_EXP 25
 889: PUSH
 890: LD_STRING Brown
 892: PPUSH
 893: CALL_OW 34
 897: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 898: LD_ADDR_EXP 9
 902: PUSH
 903: LD_EXP 9
 907: PUSH
 908: LD_EXP 25
 912: PUSH
 913: EMPTY
 914: LIST
 915: ADD
 916: ST_TO_ADDR
// end ; Denis := 0 ;
 917: LD_ADDR_EXP 26
 921: PUSH
 922: LD_INT 0
 924: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 925: LD_STRING Denis
 927: PPUSH
 928: CALL_OW 29
 932: IFFALSE 971
// if LoadVariable ( DenisLoc , 0 ) = 8 then
 934: LD_STRING DenisLoc
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL_OW 30
 944: PUSH
 945: LD_INT 8
 947: EQUAL
 948: IFFALSE 971
// begin Denis := CreateCharacter ( Denis ) ;
 950: LD_ADDR_EXP 26
 954: PUSH
 955: LD_STRING Denis
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// Denis_P := true ;
 963: LD_ADDR_EXP 46
 967: PUSH
 968: LD_INT 1
 970: ST_TO_ADDR
// end ; Gladstone := 0 ;
 971: LD_ADDR_EXP 27
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 979: LD_STRING Gladstone
 981: PPUSH
 982: CALL_OW 29
 986: IFFALSE 1036
// if LoadVariable ( GladstoneLoc , 0 ) = 8 then
 988: LD_STRING GladstoneLoc
 990: PPUSH
 991: LD_INT 0
 993: PPUSH
 994: CALL_OW 30
 998: PUSH
 999: LD_INT 8
1001: EQUAL
1002: IFFALSE 1036
// begin Gladstone := CreateCharacter ( Gladstone ) ;
1004: LD_ADDR_EXP 27
1008: PUSH
1009: LD_STRING Gladstone
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// all := all ^ [ Gladstone ] ;
1017: LD_ADDR_EXP 9
1021: PUSH
1022: LD_EXP 9
1026: PUSH
1027: LD_EXP 27
1031: PUSH
1032: EMPTY
1033: LIST
1034: ADD
1035: ST_TO_ADDR
// end ; uc_side := you2 ;
1036: LD_ADDR_OWVAR 20
1040: PUSH
1041: LD_EXP 4
1045: ST_TO_ADDR
// Joan := NewCharacter ( Joan ) ;
1046: LD_ADDR_EXP 33
1050: PUSH
1051: LD_STRING Joan
1053: PPUSH
1054: CALL_OW 25
1058: ST_TO_ADDR
// SetLives ( Joan , hranice_umirani - 1 ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 250
1066: PUSH
1067: LD_INT 1
1069: MINUS
1070: PPUSH
1071: CALL_OW 234
// uc_side := you ;
1075: LD_ADDR_OWVAR 20
1079: PUSH
1080: LD_EXP 1
1084: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1085: LD_ADDR_OWVAR 37
1089: PUSH
1090: LD_INT 1
1092: ST_TO_ADDR
// vc_control := control_manual ;
1093: LD_ADDR_OWVAR 38
1097: PUSH
1098: LD_INT 1
1100: ST_TO_ADDR
// vc_engine := engine_solar ;
1101: LD_ADDR_OWVAR 39
1105: PUSH
1106: LD_INT 2
1108: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1109: LD_ADDR_OWVAR 40
1113: PUSH
1114: LD_INT 2
1116: ST_TO_ADDR
// Car1 := CreateVehicle ;
1117: LD_ADDR_EXP 44
1121: PUSH
1122: CALL_OW 45
1126: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1127: LD_ADDR_OWVAR 37
1131: PUSH
1132: LD_INT 1
1134: ST_TO_ADDR
// vc_control := control_manual ;
1135: LD_ADDR_OWVAR 38
1139: PUSH
1140: LD_INT 1
1142: ST_TO_ADDR
// vc_engine := engine_solar ;
1143: LD_ADDR_OWVAR 39
1147: PUSH
1148: LD_INT 2
1150: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1151: LD_ADDR_OWVAR 40
1155: PUSH
1156: LD_INT 2
1158: ST_TO_ADDR
// Car2 := CreateVehicle ;
1159: LD_ADDR_EXP 45
1163: PUSH
1164: CALL_OW 45
1168: ST_TO_ADDR
// uc_nation := nation_american ;
1169: LD_ADDR_OWVAR 21
1173: PUSH
1174: LD_INT 1
1176: ST_TO_ADDR
// hc_sex := sex_female ;
1177: LD_ADDR_OWVAR 27
1181: PUSH
1182: LD_INT 2
1184: ST_TO_ADDR
// hc_class := class_soldier ;
1185: LD_ADDR_OWVAR 28
1189: PUSH
1190: LD_INT 1
1192: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1193: LD_ADDR_OWVAR 29
1197: PUSH
1198: LD_INT 10
1200: PUSH
1201: LD_INT 10
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: ST_TO_ADDR
// hc_skills := [ 4 , 2 , 1 , 0 ] ;
1208: LD_ADDR_OWVAR 31
1212: PUSH
1213: LD_INT 4
1215: PUSH
1216: LD_INT 2
1218: PUSH
1219: LD_INT 1
1221: PUSH
1222: LD_INT 0
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: ST_TO_ADDR
// Sol1 := CreateHuman ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: CALL_OW 44
1240: ST_TO_ADDR
// hc_sex := sex_male ;
1241: LD_ADDR_OWVAR 27
1245: PUSH
1246: LD_INT 1
1248: ST_TO_ADDR
// hc_class := class_engineer ;
1249: LD_ADDR_OWVAR 28
1253: PUSH
1254: LD_INT 2
1256: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1257: LD_ADDR_OWVAR 29
1261: PUSH
1262: LD_INT 10
1264: PUSH
1265: LD_INT 10
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 0 , 0 ] ;
1272: LD_ADDR_OWVAR 31
1276: PUSH
1277: LD_INT 3
1279: PUSH
1280: LD_INT 4
1282: PUSH
1283: LD_INT 0
1285: PUSH
1286: LD_INT 0
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: ST_TO_ADDR
// Eng1 := CreateHuman ;
1295: LD_ADDR_EXP 19
1299: PUSH
1300: CALL_OW 44
1304: ST_TO_ADDR
// zgamy2 := [ Sol1 , Eng1 ] ;
1305: LD_ADDR_EXP 14
1309: PUSH
1310: LD_EXP 18
1314: PUSH
1315: LD_EXP 19
1319: PUSH
1320: EMPTY
1321: LIST
1322: LIST
1323: ST_TO_ADDR
// hc_sex := sex_female ;
1324: LD_ADDR_OWVAR 27
1328: PUSH
1329: LD_INT 2
1331: ST_TO_ADDR
// hc_class := class_soldier ;
1332: LD_ADDR_OWVAR 28
1336: PUSH
1337: LD_INT 1
1339: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1340: LD_ADDR_OWVAR 29
1344: PUSH
1345: LD_INT 10
1347: PUSH
1348: LD_INT 10
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1355: LD_ADDR_OWVAR 31
1359: PUSH
1360: LD_INT 1
1362: PUSH
1363: LD_INT 1
1365: PUSH
1366: LD_INT 0
1368: PUSH
1369: LD_INT 0
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: ST_TO_ADDR
// MSol1 := CreateHuman ;
1378: LD_ADDR_EXP 28
1382: PUSH
1383: CALL_OW 44
1387: ST_TO_ADDR
// hc_sex := sex_male ;
1388: LD_ADDR_OWVAR 27
1392: PUSH
1393: LD_INT 1
1395: ST_TO_ADDR
// hc_class := class_soldier ;
1396: LD_ADDR_OWVAR 28
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1404: LD_ADDR_OWVAR 29
1408: PUSH
1409: LD_INT 10
1411: PUSH
1412: LD_INT 10
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1419: LD_ADDR_OWVAR 31
1423: PUSH
1424: LD_INT 2
1426: PUSH
1427: LD_INT 0
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 0
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: ST_TO_ADDR
// MSol2 := CreateHuman ;
1442: LD_ADDR_EXP 29
1446: PUSH
1447: CALL_OW 44
1451: ST_TO_ADDR
// hc_sex := sex_male ;
1452: LD_ADDR_OWVAR 27
1456: PUSH
1457: LD_INT 1
1459: ST_TO_ADDR
// hc_class := class_soldier ;
1460: LD_ADDR_OWVAR 28
1464: PUSH
1465: LD_INT 1
1467: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1468: LD_ADDR_OWVAR 29
1472: PUSH
1473: LD_INT 10
1475: PUSH
1476: LD_INT 10
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1483: LD_ADDR_OWVAR 31
1487: PUSH
1488: LD_INT 2
1490: PUSH
1491: LD_INT 0
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 0
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: ST_TO_ADDR
// MSol3 := CreateHuman ;
1506: LD_ADDR_EXP 30
1510: PUSH
1511: CALL_OW 44
1515: ST_TO_ADDR
// hc_sex := sex_female ;
1516: LD_ADDR_OWVAR 27
1520: PUSH
1521: LD_INT 2
1523: ST_TO_ADDR
// hc_class := class_engineer ;
1524: LD_ADDR_OWVAR 28
1528: PUSH
1529: LD_INT 2
1531: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1532: LD_ADDR_OWVAR 29
1536: PUSH
1537: LD_INT 9
1539: PUSH
1540: LD_INT 10
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1547: LD_ADDR_OWVAR 31
1551: PUSH
1552: LD_INT 0
1554: PUSH
1555: LD_INT 2
1557: PUSH
1558: LD_INT 0
1560: PUSH
1561: LD_INT 0
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: LIST
1569: ST_TO_ADDR
// MEng1 := CreateHuman ;
1570: LD_ADDR_EXP 31
1574: PUSH
1575: CALL_OW 44
1579: ST_TO_ADDR
// hc_sex := sex_male ;
1580: LD_ADDR_OWVAR 27
1584: PUSH
1585: LD_INT 1
1587: ST_TO_ADDR
// hc_class := class_mechanic ;
1588: LD_ADDR_OWVAR 28
1592: PUSH
1593: LD_INT 3
1595: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1596: LD_ADDR_OWVAR 29
1600: PUSH
1601: LD_INT 10
1603: PUSH
1604: LD_INT 9
1606: PUSH
1607: EMPTY
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1611: LD_ADDR_OWVAR 31
1615: PUSH
1616: LD_INT 0
1618: PUSH
1619: LD_INT 0
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 0
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: ST_TO_ADDR
// MMec1 := CreateHuman ;
1634: LD_ADDR_EXP 32
1638: PUSH
1639: CALL_OW 44
1643: ST_TO_ADDR
// prilet_tvoji := [ MSol1 , MSol2 , MEng1 , MMec1 ] ;
1644: LD_ADDR_EXP 6
1648: PUSH
1649: LD_EXP 28
1653: PUSH
1654: LD_EXP 29
1658: PUSH
1659: LD_EXP 31
1663: PUSH
1664: LD_EXP 32
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: ST_TO_ADDR
// NavicLidi := prilet_tvoji ;
1675: LD_ADDR_EXP 84
1679: PUSH
1680: LD_EXP 6
1684: ST_TO_ADDR
// end ;
1685: LD_VAR 0 1
1689: RET
// function prepare_russian_units ; begin
1690: LD_INT 0
1692: PPUSH
// InitUc ;
1693: CALL_OW 18
// InitHc ;
1697: CALL_OW 19
// InitVc ;
1701: CALL_OW 20
// uc_nation := nation_russian ;
1705: LD_ADDR_OWVAR 21
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// uc_side := russians ;
1713: LD_ADDR_OWVAR 20
1717: PUSH
1718: LD_EXP 2
1722: ST_TO_ADDR
// hc_sex := sex_female ;
1723: LD_ADDR_OWVAR 27
1727: PUSH
1728: LD_INT 2
1730: ST_TO_ADDR
// hc_class := class_soldier ;
1731: LD_ADDR_OWVAR 28
1735: PUSH
1736: LD_INT 1
1738: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1739: LD_ADDR_OWVAR 29
1743: PUSH
1744: LD_INT 10
1746: PUSH
1747: LD_INT 10
1749: PUSH
1750: EMPTY
1751: LIST
1752: LIST
1753: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1754: LD_ADDR_OWVAR 31
1758: PUSH
1759: LD_INT 1
1761: PUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 0
1767: PUSH
1768: LD_INT 0
1770: PUSH
1771: EMPTY
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: ST_TO_ADDR
// RMSo1 := CreateHuman ;
1777: LD_ADDR_EXP 39
1781: PUSH
1782: CALL_OW 44
1786: ST_TO_ADDR
// hc_sex := sex_male ;
1787: LD_ADDR_OWVAR 27
1791: PUSH
1792: LD_INT 1
1794: ST_TO_ADDR
// hc_class := class_soldier ;
1795: LD_ADDR_OWVAR 28
1799: PUSH
1800: LD_INT 1
1802: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1803: LD_ADDR_OWVAR 29
1807: PUSH
1808: LD_INT 10
1810: PUSH
1811: LD_INT 10
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1818: LD_ADDR_OWVAR 31
1822: PUSH
1823: LD_INT 2
1825: PUSH
1826: LD_INT 0
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: ST_TO_ADDR
// RMSo2 := CreateHuman ;
1841: LD_ADDR_EXP 40
1845: PUSH
1846: CALL_OW 44
1850: ST_TO_ADDR
// hc_sex := sex_female ;
1851: LD_ADDR_OWVAR 27
1855: PUSH
1856: LD_INT 2
1858: ST_TO_ADDR
// hc_class := class_engineer ;
1859: LD_ADDR_OWVAR 28
1863: PUSH
1864: LD_INT 2
1866: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1867: LD_ADDR_OWVAR 29
1871: PUSH
1872: LD_INT 9
1874: PUSH
1875: LD_INT 10
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1882: LD_ADDR_OWVAR 31
1886: PUSH
1887: LD_INT 0
1889: PUSH
1890: LD_INT 2
1892: PUSH
1893: LD_INT 0
1895: PUSH
1896: LD_INT 0
1898: PUSH
1899: EMPTY
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: ST_TO_ADDR
// RMEn1 := CreateHuman ;
1905: LD_ADDR_EXP 41
1909: PUSH
1910: CALL_OW 44
1914: ST_TO_ADDR
// hc_sex := sex_male ;
1915: LD_ADDR_OWVAR 27
1919: PUSH
1920: LD_INT 1
1922: ST_TO_ADDR
// hc_class := class_mechanic ;
1923: LD_ADDR_OWVAR 28
1927: PUSH
1928: LD_INT 3
1930: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1931: LD_ADDR_OWVAR 29
1935: PUSH
1936: LD_INT 10
1938: PUSH
1939: LD_INT 9
1941: PUSH
1942: EMPTY
1943: LIST
1944: LIST
1945: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1946: LD_ADDR_OWVAR 31
1950: PUSH
1951: LD_INT 0
1953: PUSH
1954: LD_INT 0
1956: PUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 0
1962: PUSH
1963: EMPTY
1964: LIST
1965: LIST
1966: LIST
1967: LIST
1968: ST_TO_ADDR
// RMMe1 := CreateHuman ;
1969: LD_ADDR_EXP 42
1973: PUSH
1974: CALL_OW 44
1978: ST_TO_ADDR
// prilet_rusaci := [ RMSo1 , RMSo2 , RMMe1 ] ;
1979: LD_ADDR_EXP 7
1983: PUSH
1984: LD_EXP 39
1988: PUSH
1989: LD_EXP 40
1993: PUSH
1994: LD_EXP 42
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: ST_TO_ADDR
// prilet_arabi := [ ] ;
2004: LD_ADDR_EXP 8
2008: PUSH
2009: EMPTY
2010: ST_TO_ADDR
// end ;
2011: LD_VAR 0 1
2015: RET
// function prepare_arabian_units ; begin
2016: LD_INT 0
2018: PPUSH
// InitUc ;
2019: CALL_OW 18
// InitHc ;
2023: CALL_OW 19
// InitVc ;
2027: CALL_OW 20
// uc_nation := nation_arabian ;
2031: LD_ADDR_OWVAR 21
2035: PUSH
2036: LD_INT 2
2038: ST_TO_ADDR
// uc_side := arabians ;
2039: LD_ADDR_OWVAR 20
2043: PUSH
2044: LD_EXP 3
2048: ST_TO_ADDR
// prilet_arabi := [ ] ;
2049: LD_ADDR_EXP 8
2053: PUSH
2054: EMPTY
2055: ST_TO_ADDR
// end ;
2056: LD_VAR 0 1
2060: RET
// function prepare_sides ; begin
2061: LD_INT 0
2063: PPUSH
// you := 1 ;
2064: LD_ADDR_EXP 1
2068: PUSH
2069: LD_INT 1
2071: ST_TO_ADDR
// you2 := 4 ;
2072: LD_ADDR_EXP 4
2076: PUSH
2077: LD_INT 4
2079: ST_TO_ADDR
// arabians := 2 ;
2080: LD_ADDR_EXP 3
2084: PUSH
2085: LD_INT 2
2087: ST_TO_ADDR
// russians := 3 ;
2088: LD_ADDR_EXP 2
2092: PUSH
2093: LD_INT 3
2095: ST_TO_ADDR
// SetAttitude ( russians , you , att_enemy , true ) ;
2096: LD_EXP 2
2100: PPUSH
2101: LD_EXP 1
2105: PPUSH
2106: LD_INT 2
2108: PPUSH
2109: LD_INT 1
2111: PPUSH
2112: CALL_OW 80
// SetAttitude ( arabians , you , att_neutral , true ) ;
2116: LD_EXP 3
2120: PPUSH
2121: LD_EXP 1
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: CALL_OW 80
// SetAttitude ( arabians , russians , att_enemy , true ) ;
2136: LD_EXP 3
2140: PPUSH
2141: LD_EXP 2
2145: PPUSH
2146: LD_INT 2
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: CALL_OW 80
// end ;
2156: LD_VAR 0 1
2160: RET
// function SetDifficulty ; var t1 ; begin
2161: LD_INT 0
2163: PPUSH
2164: PPUSH
// MaterialNavic := [ 350 , 500 , 700 ] [ difficulty ] ;
2165: LD_ADDR_EXP 51
2169: PUSH
2170: LD_INT 350
2172: PUSH
2173: LD_INT 500
2175: PUSH
2176: LD_INT 700
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: LIST
2183: PUSH
2184: LD_OWVAR 67
2188: ARRAY
2189: ST_TO_ADDR
// odplata_1 := [ 130 , 90 , 75 ] [ difficulty ] ;
2190: LD_ADDR_EXP 65
2194: PUSH
2195: LD_INT 130
2197: PUSH
2198: LD_INT 90
2200: PUSH
2201: LD_INT 75
2203: PUSH
2204: EMPTY
2205: LIST
2206: LIST
2207: LIST
2208: PUSH
2209: LD_OWVAR 67
2213: ARRAY
2214: ST_TO_ADDR
// odplata_2 := [ 350 , 250 , 150 ] [ difficulty ] ;
2215: LD_ADDR_EXP 66
2219: PUSH
2220: LD_INT 350
2222: PUSH
2223: LD_INT 250
2225: PUSH
2226: LD_INT 150
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: LD_OWVAR 67
2238: ARRAY
2239: ST_TO_ADDR
// attack_to_scouting := [ 15 , 10 , 5 ] [ difficulty ] ;
2240: LD_ADDR_EXP 67
2244: PUSH
2245: LD_INT 15
2247: PUSH
2248: LD_INT 10
2250: PUSH
2251: LD_INT 5
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: LIST
2258: PUSH
2259: LD_OWVAR 67
2263: ARRAY
2264: ST_TO_ADDR
// start_scouting := [ 5 5$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
2265: LD_ADDR_EXP 68
2269: PUSH
2270: LD_INT 10500
2272: PUSH
2273: LD_INT 4200
2275: PUSH
2276: LD_INT 0
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: PUSH
2284: LD_OWVAR 67
2288: ARRAY
2289: ST_TO_ADDR
// case difficulty of 1 :
2290: LD_OWVAR 67
2294: PUSH
2295: LD_INT 1
2297: DOUBLE
2298: EQUAL
2299: IFTRUE 2303
2301: GO 2695
2303: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: LD_INT 22
2311: PUSH
2312: LD_EXP 2
2316: PUSH
2317: EMPTY
2318: LIST
2319: LIST
2320: PUSH
2321: LD_INT 21
2323: PUSH
2324: LD_INT 1
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PUSH
2331: EMPTY
2332: LIST
2333: LIST
2334: PPUSH
2335: CALL_OW 69
2339: PUSH
2340: FOR_IN
2341: IFFALSE 2403
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 3 ) ;
2343: LD_VAR 0 2
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: CALL_OW 260
2363: PUSH
2364: LD_INT 3
2366: MINUS
2367: PPUSH
2368: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 2 ) ;
2372: LD_VAR 0 2
2376: PPUSH
2377: LD_INT 2
2379: PPUSH
2380: LD_VAR 0 2
2384: PPUSH
2385: LD_INT 2
2387: PPUSH
2388: CALL_OW 260
2392: PUSH
2393: LD_INT 2
2395: MINUS
2396: PPUSH
2397: CALL_OW 239
// end ;
2401: GO 2340
2403: POP
2404: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_EXP 2
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: PUSH
2422: LD_INT 25
2424: PUSH
2425: LD_INT 1
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PUSH
2441: FOR_IN
2442: IFFALSE 2475
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) - 1 ) ;
2444: LD_VAR 0 2
2448: PPUSH
2449: LD_INT 1
2451: PPUSH
2452: LD_VAR 0 2
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: CALL_OW 259
2464: PUSH
2465: LD_INT 1
2467: MINUS
2468: PPUSH
2469: CALL_OW 237
// end ;
2473: GO 2441
2475: POP
2476: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2477: LD_ADDR_VAR 0 2
2481: PUSH
2482: LD_INT 22
2484: PUSH
2485: LD_EXP 2
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: PUSH
2494: LD_INT 25
2496: PUSH
2497: LD_INT 2
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PPUSH
2508: CALL_OW 69
2512: PUSH
2513: FOR_IN
2514: IFFALSE 2547
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2516: LD_VAR 0 2
2520: PPUSH
2521: LD_INT 2
2523: PPUSH
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 2
2531: PPUSH
2532: CALL_OW 259
2536: PUSH
2537: LD_INT 2
2539: PLUS
2540: PPUSH
2541: CALL_OW 237
// end ;
2545: GO 2513
2547: POP
2548: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2549: LD_ADDR_VAR 0 2
2553: PUSH
2554: LD_INT 22
2556: PUSH
2557: LD_EXP 2
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 25
2568: PUSH
2569: LD_INT 3
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PPUSH
2580: CALL_OW 69
2584: PUSH
2585: FOR_IN
2586: IFFALSE 2619
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) - 1 ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: LD_INT 3
2595: PPUSH
2596: LD_VAR 0 2
2600: PPUSH
2601: LD_INT 3
2603: PPUSH
2604: CALL_OW 259
2608: PUSH
2609: LD_INT 1
2611: MINUS
2612: PPUSH
2613: CALL_OW 237
// end ;
2617: GO 2585
2619: POP
2620: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
2621: LD_ADDR_VAR 0 2
2625: PUSH
2626: LD_INT 22
2628: PUSH
2629: LD_EXP 2
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 25
2640: PUSH
2641: LD_INT 4
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PPUSH
2652: CALL_OW 69
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2691
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) - 1 ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 4
2667: PPUSH
2668: LD_VAR 0 2
2672: PPUSH
2673: LD_INT 4
2675: PPUSH
2676: CALL_OW 259
2680: PUSH
2681: LD_INT 1
2683: MINUS
2684: PPUSH
2685: CALL_OW 237
// end ;
2689: GO 2657
2691: POP
2692: POP
// end ; 2 :
2693: GO 3546
2695: LD_INT 2
2697: DOUBLE
2698: EQUAL
2699: IFTRUE 2703
2701: GO 3116
2703: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2704: LD_ADDR_VAR 0 2
2708: PUSH
2709: LD_INT 22
2711: PUSH
2712: LD_EXP 2
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PUSH
2721: LD_INT 21
2723: PUSH
2724: LD_INT 1
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: PPUSH
2735: CALL_OW 69
2739: PUSH
2740: FOR_IN
2741: IFFALSE 2828
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 1 ) ;
2743: LD_VAR 0 2
2747: PPUSH
2748: LD_INT 1
2750: PPUSH
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 260
2763: PUSH
2764: LD_INT 1
2766: MINUS
2767: PPUSH
2768: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 1 ) ;
2772: LD_VAR 0 2
2776: PPUSH
2777: LD_INT 2
2779: PPUSH
2780: LD_VAR 0 2
2784: PPUSH
2785: LD_INT 2
2787: PPUSH
2788: CALL_OW 260
2792: PUSH
2793: LD_INT 1
2795: MINUS
2796: PPUSH
2797: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) ) ;
2801: LD_VAR 0 2
2805: PPUSH
2806: LD_INT 1
2808: PPUSH
2809: LD_VAR 0 2
2813: PPUSH
2814: LD_INT 1
2816: PPUSH
2817: CALL_OW 259
2821: PPUSH
2822: CALL_OW 237
// end ;
2826: GO 2740
2828: POP
2829: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2830: LD_ADDR_VAR 0 2
2834: PUSH
2835: LD_INT 22
2837: PUSH
2838: LD_EXP 2
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 25
2849: PUSH
2850: LD_INT 1
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: PUSH
2866: FOR_IN
2867: IFFALSE 2900
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
2869: LD_VAR 0 2
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_VAR 0 2
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: CALL_OW 259
2889: PUSH
2890: LD_INT 1
2892: PLUS
2893: PPUSH
2894: CALL_OW 237
// end ;
2898: GO 2866
2900: POP
2901: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2902: LD_ADDR_VAR 0 2
2906: PUSH
2907: LD_INT 22
2909: PUSH
2910: LD_EXP 2
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 25
2921: PUSH
2922: LD_INT 2
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: EMPTY
2930: LIST
2931: LIST
2932: PPUSH
2933: CALL_OW 69
2937: PUSH
2938: FOR_IN
2939: IFFALSE 2972
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2941: LD_VAR 0 2
2945: PPUSH
2946: LD_INT 2
2948: PPUSH
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 259
2961: PUSH
2962: LD_INT 2
2964: PLUS
2965: PPUSH
2966: CALL_OW 237
// end ;
2970: GO 2938
2972: POP
2973: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2974: LD_ADDR_VAR 0 2
2978: PUSH
2979: LD_INT 22
2981: PUSH
2982: LD_EXP 2
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: PUSH
2991: LD_INT 25
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL_OW 69
3009: PUSH
3010: FOR_IN
3011: IFFALSE 3040
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) ) ;
3013: LD_VAR 0 2
3017: PPUSH
3018: LD_INT 3
3020: PPUSH
3021: LD_VAR 0 2
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: CALL_OW 259
3033: PPUSH
3034: CALL_OW 237
// end ;
3038: GO 3010
3040: POP
3041: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3042: LD_ADDR_VAR 0 2
3046: PUSH
3047: LD_INT 22
3049: PUSH
3050: LD_EXP 2
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: LD_INT 25
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 69
3077: PUSH
3078: FOR_IN
3079: IFFALSE 3112
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 1 ) ;
3081: LD_VAR 0 2
3085: PPUSH
3086: LD_INT 4
3088: PPUSH
3089: LD_VAR 0 2
3093: PPUSH
3094: LD_INT 4
3096: PPUSH
3097: CALL_OW 259
3101: PUSH
3102: LD_INT 1
3104: PLUS
3105: PPUSH
3106: CALL_OW 237
// end ;
3110: GO 3078
3112: POP
3113: POP
// end ; 3 :
3114: GO 3546
3116: LD_INT 3
3118: DOUBLE
3119: EQUAL
3120: IFTRUE 3124
3122: GO 3545
3124: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: LD_INT 22
3132: PUSH
3133: LD_EXP 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: LD_INT 21
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: PPUSH
3156: CALL_OW 69
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3253
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) + 1 ) ;
3164: LD_VAR 0 2
3168: PPUSH
3169: LD_INT 1
3171: PPUSH
3172: LD_VAR 0 2
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: CALL_OW 260
3184: PUSH
3185: LD_INT 1
3187: PLUS
3188: PPUSH
3189: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) + 1 ) ;
3193: LD_VAR 0 2
3197: PPUSH
3198: LD_INT 2
3200: PPUSH
3201: LD_VAR 0 2
3205: PPUSH
3206: LD_INT 2
3208: PPUSH
3209: CALL_OW 260
3213: PUSH
3214: LD_INT 1
3216: PLUS
3217: PPUSH
3218: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
3222: LD_VAR 0 2
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: LD_VAR 0 2
3234: PPUSH
3235: LD_INT 1
3237: PPUSH
3238: CALL_OW 259
3242: PUSH
3243: LD_INT 1
3245: PLUS
3246: PPUSH
3247: CALL_OW 237
// end ;
3251: GO 3161
3253: POP
3254: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
3255: LD_ADDR_VAR 0 2
3259: PUSH
3260: LD_INT 22
3262: PUSH
3263: LD_EXP 2
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PUSH
3272: LD_INT 25
3274: PUSH
3275: LD_INT 1
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: PPUSH
3286: CALL_OW 69
3290: PUSH
3291: FOR_IN
3292: IFFALSE 3325
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 2 ) ;
3294: LD_VAR 0 2
3298: PPUSH
3299: LD_INT 1
3301: PPUSH
3302: LD_VAR 0 2
3306: PPUSH
3307: LD_INT 1
3309: PPUSH
3310: CALL_OW 259
3314: PUSH
3315: LD_INT 2
3317: PLUS
3318: PPUSH
3319: CALL_OW 237
// end ;
3323: GO 3291
3325: POP
3326: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
3327: LD_ADDR_VAR 0 2
3331: PUSH
3332: LD_INT 22
3334: PUSH
3335: LD_EXP 2
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 25
3346: PUSH
3347: LD_INT 2
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: PPUSH
3358: CALL_OW 69
3362: PUSH
3363: FOR_IN
3364: IFFALSE 3397
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
3366: LD_VAR 0 2
3370: PPUSH
3371: LD_INT 2
3373: PPUSH
3374: LD_VAR 0 2
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: CALL_OW 259
3386: PUSH
3387: LD_INT 2
3389: PLUS
3390: PPUSH
3391: CALL_OW 237
// end ;
3395: GO 3363
3397: POP
3398: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
3399: LD_ADDR_VAR 0 2
3403: PUSH
3404: LD_INT 22
3406: PUSH
3407: LD_EXP 2
3411: PUSH
3412: EMPTY
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 25
3418: PUSH
3419: LD_INT 3
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: PPUSH
3430: CALL_OW 69
3434: PUSH
3435: FOR_IN
3436: IFFALSE 3469
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) + 2 ) ;
3438: LD_VAR 0 2
3442: PPUSH
3443: LD_INT 3
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: CALL_OW 259
3458: PUSH
3459: LD_INT 2
3461: PLUS
3462: PPUSH
3463: CALL_OW 237
// end ;
3467: GO 3435
3469: POP
3470: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3471: LD_ADDR_VAR 0 2
3475: PUSH
3476: LD_INT 22
3478: PUSH
3479: LD_EXP 2
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 25
3490: PUSH
3491: LD_INT 4
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: PPUSH
3502: CALL_OW 69
3506: PUSH
3507: FOR_IN
3508: IFFALSE 3541
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 2 ) ;
3510: LD_VAR 0 2
3514: PPUSH
3515: LD_INT 4
3517: PPUSH
3518: LD_VAR 0 2
3522: PPUSH
3523: LD_INT 4
3525: PPUSH
3526: CALL_OW 259
3530: PUSH
3531: LD_INT 2
3533: PLUS
3534: PPUSH
3535: CALL_OW 237
// end ;
3539: GO 3507
3541: POP
3542: POP
// end ; end ;
3543: GO 3546
3545: POP
// end ;
3546: LD_VAR 0 1
3550: RET
// every 50 50$0 do var bases , i , mat ;
3551: GO 3553
3553: DISABLE
3554: LD_INT 0
3556: PPUSH
3557: PPUSH
3558: PPUSH
// begin if count_crates < MaterialNavic then
3559: CALL 25980 0 0
3563: PUSH
3564: LD_EXP 51
3568: LESS
3569: IFFALSE 3583
// begin disable ( 0 ) ;
3571: LD_INT 0
3573: DISABLE_MARKED
// YouLost ( matmin ) ;
3574: LD_STRING matmin
3576: PPUSH
3577: CALL_OW 104
// end else
3581: GO 3658
// begin disable ( 0 ) ;
3583: LD_INT 0
3585: DISABLE_MARKED
// SetMedals ;
3586: CALL 4143 0 0
// GiveMedals ( Main ) ;
3590: LD_STRING Main
3592: PPUSH
3593: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_ok ] , [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3597: LD_INT 50
3599: PUSH
3600: EMPTY
3601: LIST
3602: PUSH
3603: LD_INT 22
3605: PUSH
3606: LD_EXP 1
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: LD_INT 21
3617: PUSH
3618: LD_INT 1
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 23
3627: PUSH
3628: LD_INT 1
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: PPUSH
3641: CALL_OW 69
3645: PPUSH
3646: CALL_OW 43
// Save ;
3650: CALL 3661 0 0
// YouWin ;
3654: CALL_OW 103
// end ; end ;
3658: PPOPN 3
3660: END
// export function Save ; begin
3661: LD_INT 0
3663: PPUSH
// SaveCharacters ( JMM , JMM ) ;
3664: LD_EXP 15
3668: PPUSH
3669: LD_STRING JMM
3671: PPUSH
3672: CALL_OW 38
// SaveCharacters ( Kurt , Kurt ) ;
3676: LD_EXP 43
3680: PPUSH
3681: LD_STRING Kurt
3683: PPUSH
3684: CALL_OW 38
// SaveVariable ( not IsDead ( Kurt ) , KurtLeaves ) ;
3688: LD_EXP 43
3692: PPUSH
3693: CALL_OW 301
3697: NOT
3698: PPUSH
3699: LD_STRING KurtLeaves
3701: PPUSH
3702: CALL_OW 39
// SaveVariable ( KurtTryToEscape and not IsDead ( Kurt ) , KurtEscapes ) ;
3706: LD_EXP 85
3710: PUSH
3711: LD_EXP 43
3715: PPUSH
3716: CALL_OW 301
3720: NOT
3721: AND
3722: PPUSH
3723: LD_STRING KurtEscapes
3725: PPUSH
3726: CALL_OW 39
// SaveVariable ( remote_tried , RemoteUsed ) ;
3730: LD_EXP 82
3734: PPUSH
3735: LD_STRING RemoteUsed
3737: PPUSH
3738: CALL_OW 39
// SaveVariable ( Researched ( you , tech_RemCont ) , RemoteDeveloped ) ;
3742: LD_EXP 1
3746: PPUSH
3747: LD_INT 15
3749: PPUSH
3750: CALL_OW 325
3754: PPUSH
3755: LD_STRING RemoteDeveloped
3757: PPUSH
3758: CALL_OW 39
// if Lisa then
3762: LD_EXP 21
3766: IFFALSE 3790
// begin SaveCharacters ( Lisa , Lisa ) ;
3768: LD_EXP 21
3772: PPUSH
3773: LD_STRING Lisa
3775: PPUSH
3776: CALL_OW 38
// SaveVariable ( 9 , LisaLoc ) ;
3780: LD_INT 9
3782: PPUSH
3783: LD_STRING LisaLoc
3785: PPUSH
3786: CALL_OW 39
// end ; if Frank then
3790: LD_EXP 20
3794: IFFALSE 3818
// begin SaveCharacters ( Frank , Frank ) ;
3796: LD_EXP 20
3800: PPUSH
3801: LD_STRING Frank
3803: PPUSH
3804: CALL_OW 38
// SaveVariable ( 9 , FrankLoc ) ;
3808: LD_INT 9
3810: PPUSH
3811: LD_STRING FrankLoc
3813: PPUSH
3814: CALL_OW 39
// end ; if Donaldson then
3818: LD_EXP 24
3822: IFFALSE 3846
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3824: LD_EXP 24
3828: PPUSH
3829: LD_STRING Donaldson
3831: PPUSH
3832: CALL_OW 38
// SaveVariable ( 9 , DonaldsonLoc ) ;
3836: LD_INT 9
3838: PPUSH
3839: LD_STRING DonaldsonLoc
3841: PPUSH
3842: CALL_OW 39
// end ; if Brown then
3846: LD_EXP 25
3850: IFFALSE 3874
// begin SaveCharacters ( Brown , Brown ) ;
3852: LD_EXP 25
3856: PPUSH
3857: LD_STRING Brown
3859: PPUSH
3860: CALL_OW 38
// SaveVariable ( 9 , BrownLoc ) ;
3864: LD_INT 9
3866: PPUSH
3867: LD_STRING BrownLoc
3869: PPUSH
3870: CALL_OW 39
// end ; if Gladstone then
3874: LD_EXP 27
3878: IFFALSE 3902
// begin SaveCharacters ( Gladstone , Gladstone ) ;
3880: LD_EXP 27
3884: PPUSH
3885: LD_STRING Gladstone
3887: PPUSH
3888: CALL_OW 38
// SaveVariable ( 9 , GladstoneLoc ) ;
3892: LD_INT 9
3894: PPUSH
3895: LD_STRING GladstoneLoc
3897: PPUSH
3898: CALL_OW 39
// end ; SaveCharacters ( Joan , Joan ) ;
3902: LD_EXP 33
3906: PPUSH
3907: LD_STRING Joan
3909: PPUSH
3910: CALL_OW 38
// SaveVariable ( 9 , JoanLoc ) ;
3914: LD_INT 9
3916: PPUSH
3917: LD_STRING JoanLoc
3919: PPUSH
3920: CALL_OW 39
// if Denis then
3924: LD_EXP 26
3928: IFFALSE 3952
// begin SaveCharacters ( Denis , Denis ) ;
3930: LD_EXP 26
3934: PPUSH
3935: LD_STRING Denis
3937: PPUSH
3938: CALL_OW 38
// SaveVariable ( 9 , DenisLoc ) ;
3942: LD_INT 9
3944: PPUSH
3945: LD_STRING DenisLoc
3947: PPUSH
3948: CALL_OW 39
// end ; if Bobby then
3952: LD_EXP 23
3956: IFFALSE 3980
// begin SaveCharacters ( Bobby , Bobby ) ;
3958: LD_EXP 23
3962: PPUSH
3963: LD_STRING Bobby
3965: PPUSH
3966: CALL_OW 38
// SaveVariable ( 9 , BobbyLoc ) ;
3970: LD_INT 9
3972: PPUSH
3973: LD_STRING BobbyLoc
3975: PPUSH
3976: CALL_OW 39
// end ; if Cyrus then
3980: LD_EXP 22
3984: IFFALSE 4008
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3986: LD_EXP 22
3990: PPUSH
3991: LD_STRING Cyrus
3993: PPUSH
3994: CALL_OW 38
// SaveVariable ( 9 , CyrusLoc ) ;
3998: LD_INT 9
4000: PPUSH
4001: LD_STRING CyrusLoc
4003: PPUSH
4004: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Donaldson , Brown , Gladstone , Joan , Denis , Bobby , Cyrus , 0 ] , OtherUnplaced ) ;
4008: LD_INT 22
4010: PUSH
4011: LD_EXP 1
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: PUSH
4020: LD_INT 21
4022: PUSH
4023: LD_INT 1
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: PUSH
4030: LD_INT 23
4032: PUSH
4033: LD_INT 1
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: LIST
4044: PPUSH
4045: CALL_OW 69
4049: PUSH
4050: LD_EXP 15
4054: PUSH
4055: LD_EXP 21
4059: PUSH
4060: LD_EXP 20
4064: PUSH
4065: LD_EXP 24
4069: PUSH
4070: LD_EXP 25
4074: PUSH
4075: LD_EXP 27
4079: PUSH
4080: LD_EXP 33
4084: PUSH
4085: LD_EXP 26
4089: PUSH
4090: LD_EXP 23
4094: PUSH
4095: LD_EXP 22
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: DIFF
4116: PPUSH
4117: LD_STRING OtherUnplaced
4119: PPUSH
4120: CALL_OW 38
// DeleteCharacters ( opicaci ) ;
4124: LD_STRING opicaci
4126: PPUSH
4127: CALL_OW 40
// DeleteCharacters ( other_from5to6 ) ;
4131: LD_STRING other_from5to6
4133: PPUSH
4134: CALL_OW 40
// end ;
4138: LD_VAR 0 1
4142: RET
// export function SetMedals ; var medal1 , medal2 , medal3 ; begin
4143: LD_INT 0
4145: PPUSH
4146: PPUSH
4147: PPUSH
4148: PPUSH
// medal1 := false ;
4149: LD_ADDR_VAR 0 2
4153: PUSH
4154: LD_INT 0
4156: ST_TO_ADDR
// medal2 := false ;
4157: LD_ADDR_VAR 0 3
4161: PUSH
4162: LD_INT 0
4164: ST_TO_ADDR
// medal3 := false ;
4165: LD_ADDR_VAR 0 4
4169: PUSH
4170: LD_INT 0
4172: ST_TO_ADDR
// AddMedal ( cans , count_crates >= ( MaterialNavic + 100 ) ) ;
4173: LD_STRING cans
4175: PPUSH
4176: CALL 25980 0 0
4180: PUSH
4181: LD_EXP 51
4185: PUSH
4186: LD_INT 100
4188: PLUS
4189: GREATEREQUAL
4190: PPUSH
4191: CALL_OW 101
// medal1 := count_crates >= ( MaterialNavic + 100 ) ;
4195: LD_ADDR_VAR 0 2
4199: PUSH
4200: CALL 25980 0 0
4204: PUSH
4205: LD_EXP 51
4209: PUSH
4210: LD_INT 100
4212: PLUS
4213: GREATEREQUAL
4214: ST_TO_ADDR
// SA_CratesGathered ( count_crates ) ;
4215: CALL 25980 0 0
4219: PPUSH
4220: CALL 27074 0 1
// if count_crates >= 1000 then
4224: CALL 25980 0 0
4228: PUSH
4229: LD_INT 1000
4231: GREATEREQUAL
4232: IFFALSE 4238
// SA_On1000CratesGathered ;
4234: CALL 27059 0 0
// NavicLidi := UnitFilter ( NavicLidi , [ f_ok ] ) ;
4238: LD_ADDR_EXP 84
4242: PUSH
4243: LD_EXP 84
4247: PPUSH
4248: LD_INT 50
4250: PUSH
4251: EMPTY
4252: LIST
4253: PPUSH
4254: CALL_OW 72
4258: ST_TO_ADDR
// AddMedal ( people , NavicLidi >= 3 ) ;
4259: LD_STRING people
4261: PPUSH
4262: LD_EXP 84
4266: PUSH
4267: LD_INT 3
4269: GREATEREQUAL
4270: PPUSH
4271: CALL_OW 101
// medal2 := NavicLidi >= 3 ;
4275: LD_ADDR_VAR 0 3
4279: PUSH
4280: LD_EXP 84
4284: PUSH
4285: LD_INT 3
4287: GREATEREQUAL
4288: ST_TO_ADDR
// if remote_tried then
4289: LD_EXP 82
4293: IFFALSE 4315
// begin AddMedal ( remote , 1 ) ;
4295: LD_STRING remote
4297: PPUSH
4298: LD_INT 1
4300: PPUSH
4301: CALL_OW 101
// medal3 := true ;
4305: LD_ADDR_VAR 0 4
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// end else
4313: GO 4357
// begin if GetTech ( tech_RemCont , you ) = state_researched then
4315: LD_INT 15
4317: PPUSH
4318: LD_EXP 1
4322: PPUSH
4323: CALL_OW 321
4327: PUSH
4328: LD_INT 2
4330: EQUAL
4331: IFFALSE 4346
// AddMedal ( remote , - 2 ) else
4333: LD_STRING remote
4335: PPUSH
4336: LD_INT 2
4338: NEG
4339: PPUSH
4340: CALL_OW 101
4344: GO 4357
// AddMedal ( remote , - 1 ) ;
4346: LD_STRING remote
4348: PPUSH
4349: LD_INT 1
4351: NEG
4352: PPUSH
4353: CALL_OW 101
// end ; SA_EndMission ( 1 , 6 , medal1 , medal2 , medal3 ) ;
4357: LD_INT 1
4359: PPUSH
4360: LD_INT 6
4362: PPUSH
4363: LD_VAR 0 2
4367: PPUSH
4368: LD_VAR 0 3
4372: PPUSH
4373: LD_VAR 0 4
4377: PPUSH
4378: CALL 27094 0 5
// end ;
4382: LD_VAR 0 1
4386: RET
// final begin end ; end_of_file
4387: END
// export mytick ; export function Dialog1 ; var Sci , i ; begin
4388: LD_INT 0
4390: PPUSH
4391: PPUSH
4392: PPUSH
// used := all ^ [ JMM ] ;
4393: LD_ADDR_EXP 12
4397: PUSH
4398: LD_EXP 9
4402: PUSH
4403: LD_EXP 15
4407: PUSH
4408: EMPTY
4409: LIST
4410: ADD
4411: ST_TO_ADDR
// if Lisa in used then
4412: LD_EXP 21
4416: PUSH
4417: LD_EXP 12
4421: IN
4422: IFFALSE 4432
// Lisa_P := true ;
4424: LD_ADDR_EXP 49
4428: PUSH
4429: LD_INT 1
4431: ST_TO_ADDR
// if Frank in used then
4432: LD_EXP 20
4436: PUSH
4437: LD_EXP 12
4441: IN
4442: IFFALSE 4452
// Frank_P := true ;
4444: LD_ADDR_EXP 50
4448: PUSH
4449: LD_INT 1
4451: ST_TO_ADDR
// opicaci := Delete ( opicaci , 3 ) ;
4452: LD_ADDR_EXP 13
4456: PUSH
4457: LD_EXP 13
4461: PPUSH
4462: LD_INT 3
4464: PPUSH
4465: CALL_OW 3
4469: ST_TO_ADDR
// used := used ^ opicaci ;
4470: LD_ADDR_EXP 12
4474: PUSH
4475: LD_EXP 12
4479: PUSH
4480: LD_EXP 13
4484: ADD
4485: ST_TO_ADDR
// used := used union zgamy2 ;
4486: LD_ADDR_EXP 12
4490: PUSH
4491: LD_EXP 12
4495: PUSH
4496: LD_EXP 14
4500: UNION
4501: ST_TO_ADDR
// not_char := used diff [ JMM , Lisa , Frank ] ;
4502: LD_ADDR_EXP 11
4506: PUSH
4507: LD_EXP 12
4511: PUSH
4512: LD_EXP 15
4516: PUSH
4517: LD_EXP 21
4521: PUSH
4522: LD_EXP 20
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: LIST
4531: DIFF
4532: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Gladstone , Denis , Brown , Donaldson ] ;
4533: LD_ADDR_EXP 11
4537: PUSH
4538: LD_EXP 11
4542: PUSH
4543: LD_EXP 22
4547: PUSH
4548: LD_EXP 23
4552: PUSH
4553: LD_EXP 27
4557: PUSH
4558: LD_EXP 26
4562: PUSH
4563: LD_EXP 25
4567: PUSH
4568: LD_EXP 24
4572: PUSH
4573: EMPTY
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: DIFF
4581: ST_TO_ADDR
// if Brown in used then
4582: LD_EXP 25
4586: PUSH
4587: LD_EXP 12
4591: IN
4592: IFFALSE 4613
// not_char := not_char ^ [ Brown ] ;
4594: LD_ADDR_EXP 11
4598: PUSH
4599: LD_EXP 11
4603: PUSH
4604: LD_EXP 25
4608: PUSH
4609: EMPTY
4610: LIST
4611: ADD
4612: ST_TO_ADDR
// if Donaldson in used then
4613: LD_EXP 24
4617: PUSH
4618: LD_EXP 12
4622: IN
4623: IFFALSE 4644
// not_char := not_char ^ [ Donaldson ] ;
4625: LD_ADDR_EXP 11
4629: PUSH
4630: LD_EXP 11
4634: PUSH
4635: LD_EXP 24
4639: PUSH
4640: EMPTY
4641: LIST
4642: ADD
4643: ST_TO_ADDR
// if Cyrus in used then
4644: LD_EXP 22
4648: PUSH
4649: LD_EXP 12
4653: IN
4654: IFFALSE 4675
// not_char := not_char ^ [ Cyrus ] ;
4656: LD_ADDR_EXP 11
4660: PUSH
4661: LD_EXP 11
4665: PUSH
4666: LD_EXP 22
4670: PUSH
4671: EMPTY
4672: LIST
4673: ADD
4674: ST_TO_ADDR
// if Bobby in used then
4675: LD_EXP 23
4679: PUSH
4680: LD_EXP 12
4684: IN
4685: IFFALSE 4706
// not_char := not_char ^ [ Bobby ] ;
4687: LD_ADDR_EXP 11
4691: PUSH
4692: LD_EXP 11
4696: PUSH
4697: LD_EXP 23
4701: PUSH
4702: EMPTY
4703: LIST
4704: ADD
4705: ST_TO_ADDR
// if Gladstone in used then
4706: LD_EXP 27
4710: PUSH
4711: LD_EXP 12
4715: IN
4716: IFFALSE 4737
// not_char := not_char ^ [ Gladstone ] ;
4718: LD_ADDR_EXP 11
4722: PUSH
4723: LD_EXP 11
4727: PUSH
4728: LD_EXP 27
4732: PUSH
4733: EMPTY
4734: LIST
4735: ADD
4736: ST_TO_ADDR
// if Denis in used then
4737: LD_EXP 26
4741: PUSH
4742: LD_EXP 12
4746: IN
4747: IFFALSE 4768
// not_char := not_char ^ [ Denis ] ;
4749: LD_ADDR_EXP 11
4753: PUSH
4754: LD_EXP 11
4758: PUSH
4759: LD_EXP 26
4763: PUSH
4764: EMPTY
4765: LIST
4766: ADD
4767: ST_TO_ADDR
// SaveForQuickRestart ;
4768: CALL_OW 22
// Wait ( 0 0$1.0 ) ;
4772: LD_INT 35
4774: PPUSH
4775: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
4779: LD_STRING M1
4781: PPUSH
4782: CALL_OW 337
// case difficulty of 1 :
4786: LD_OWVAR 67
4790: PUSH
4791: LD_INT 1
4793: DOUBLE
4794: EQUAL
4795: IFTRUE 4799
4797: GO 4809
4799: POP
// ChangeMissionObjectives ( M1-1 ) ; 2 :
4800: LD_STRING M1-1
4802: PPUSH
4803: CALL_OW 337
4807: GO 4846
4809: LD_INT 2
4811: DOUBLE
4812: EQUAL
4813: IFTRUE 4817
4815: GO 4827
4817: POP
// ChangeMissionObjectives ( M1-2 ) ; 3 :
4818: LD_STRING M1-2
4820: PPUSH
4821: CALL_OW 337
4825: GO 4846
4827: LD_INT 3
4829: DOUBLE
4830: EQUAL
4831: IFTRUE 4835
4833: GO 4845
4835: POP
// ChangeMissionObjectives ( M1-3 ) ; end ;
4836: LD_STRING M1-3
4838: PPUSH
4839: CALL_OW 337
4843: GO 4846
4845: POP
// ChangeMissionObjectives ( M1cont ) ;
4846: LD_STRING M1cont
4848: PPUSH
4849: CALL_OW 337
// PlaceHumanInUnit ( zgamy2 [ 1 ] , Car1 ) ;
4853: LD_EXP 14
4857: PUSH
4858: LD_INT 1
4860: ARRAY
4861: PPUSH
4862: LD_EXP 44
4866: PPUSH
4867: CALL_OW 52
// PlaceHumanInUnit ( zgamy2 [ 2 ] , Car2 ) ;
4871: LD_EXP 14
4875: PUSH
4876: LD_INT 2
4878: ARRAY
4879: PPUSH
4880: LD_EXP 45
4884: PPUSH
4885: CALL_OW 52
// PlaceUnitXYR ( Car1 , 13 , 3 , 8 , false ) ;
4889: LD_EXP 44
4893: PPUSH
4894: LD_INT 13
4896: PPUSH
4897: LD_INT 3
4899: PPUSH
4900: LD_INT 8
4902: PPUSH
4903: LD_INT 0
4905: PPUSH
4906: CALL_OW 50
// PlaceUnitXYR ( Car2 , 13 , 3 , 8 , false ) ;
4910: LD_EXP 45
4914: PPUSH
4915: LD_INT 13
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: LD_INT 8
4923: PPUSH
4924: LD_INT 0
4926: PPUSH
4927: CALL_OW 50
// for i := 1 to used diff ( zgamy2 ^ [ Car1 , Car2 ] ) do
4931: LD_ADDR_VAR 0 3
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_EXP 12
4945: PUSH
4946: LD_EXP 14
4950: PUSH
4951: LD_EXP 44
4955: PUSH
4956: LD_EXP 45
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: ADD
4965: DIFF
4966: PUSH
4967: FOR_TO
4968: IFFALSE 4999
// PlaceUnitXYR ( used [ i ] , 70 , 3 , 8 , false ) ;
4970: LD_EXP 12
4974: PUSH
4975: LD_VAR 0 3
4979: ARRAY
4980: PPUSH
4981: LD_INT 70
4983: PPUSH
4984: LD_INT 3
4986: PPUSH
4987: LD_INT 8
4989: PPUSH
4990: LD_INT 0
4992: PPUSH
4993: CALL_OW 50
4997: GO 4967
4999: POP
5000: POP
// mytick := tick ;
5001: LD_ADDR_EXP 86
5005: PUSH
5006: LD_OWVAR 1
5010: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
5011: LD_EXP 15
5015: PPUSH
5016: CALL_OW 87
// Wait ( 0 0$3 ) ;
5020: LD_INT 105
5022: PPUSH
5023: CALL_OW 67
// talkOn ;
5027: CALL 17132 0 0
// Say ( zgamy2 [ 2 ] , DEng-Eng1-1 ) ;
5031: LD_EXP 14
5035: PUSH
5036: LD_INT 2
5038: ARRAY
5039: PPUSH
5040: LD_STRING DEng-Eng1-1
5042: PPUSH
5043: CALL_OW 88
// talkOff ;
5047: CALL 17148 0 0
// CenterOnUnits ( Car1 ) ;
5051: LD_EXP 44
5055: PPUSH
5056: CALL_OW 85
// InGameOff ;
5060: CALL_OW 9
// start_game := true ;
5064: LD_ADDR_EXP 55
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// end ;
5072: LD_VAR 0 1
5076: RET
// every 1 1$20 do
5077: GO 5079
5079: DISABLE
// begin DialogueOn ;
5080: CALL_OW 6
// SayRadio ( Har , DRem-Har-1 ) ;
5084: LD_EXP 16
5088: PPUSH
5089: LD_STRING DRem-Har-1
5091: PPUSH
5092: CALL_OW 94
// if attacky then
5096: LD_EXP 60
5100: IFFALSE 5116
// Say ( JMM , DRem-JMM-1 ) else
5102: LD_EXP 15
5106: PPUSH
5107: LD_STRING DRem-JMM-1
5109: PPUSH
5110: CALL_OW 88
5114: GO 5128
// Say ( JMM , DRem-JMM-1a ) ;
5116: LD_EXP 15
5120: PPUSH
5121: LD_STRING DRem-JMM-1a
5123: PPUSH
5124: CALL_OW 88
// SayRadio ( Har , DRem-Har-2 ) ;
5128: LD_EXP 16
5132: PPUSH
5133: LD_STRING DRem-Har-2
5135: PPUSH
5136: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5140: LD_STRING Denis
5142: PPUSH
5143: CALL_OW 29
5147: IFFALSE 5163
// Say ( JMM , DRem-JMM-2 ) else
5149: LD_EXP 15
5153: PPUSH
5154: LD_STRING DRem-JMM-2
5156: PPUSH
5157: CALL_OW 88
5161: GO 5175
// Say ( JMM , DRem-JMM-2a ) ;
5163: LD_EXP 15
5167: PPUSH
5168: LD_STRING DRem-JMM-2a
5170: PPUSH
5171: CALL_OW 88
// SayRadio ( Har , DRem-Har-3 ) ;
5175: LD_EXP 16
5179: PPUSH
5180: LD_STRING DRem-Har-3
5182: PPUSH
5183: CALL_OW 94
// Say ( JMM , DRem-JMM-3 ) ;
5187: LD_EXP 15
5191: PPUSH
5192: LD_STRING DRem-JMM-3
5194: PPUSH
5195: CALL_OW 88
// SayRadio ( Har , DRem-Har-4 ) ;
5199: LD_EXP 16
5203: PPUSH
5204: LD_STRING DRem-Har-4
5206: PPUSH
5207: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5211: LD_STRING Denis
5213: PPUSH
5214: CALL_OW 29
5218: IFFALSE 5244
// begin Say ( JMM , DRem-JMM-4 ) ;
5220: LD_EXP 15
5224: PPUSH
5225: LD_STRING DRem-JMM-4
5227: PPUSH
5228: CALL_OW 88
// SayRadio ( Har , DRem-Har-5 ) ;
5232: LD_EXP 16
5236: PPUSH
5237: LD_STRING DRem-Har-5
5239: PPUSH
5240: CALL_OW 94
// end ; DialogueOff ;
5244: CALL_OW 7
// ChangeMissionObjectives ( MR ) ;
5248: LD_STRING MR
5250: PPUSH
5251: CALL_OW 337
// if CheckCharacterSet ( Denis ) then
5255: LD_STRING Denis
5257: PPUSH
5258: CALL_OW 29
5262: IFFALSE 5310
// begin InitUc ;
5264: CALL_OW 18
// InitHc ;
5268: CALL_OW 19
// uc_side := you2 ;
5272: LD_ADDR_OWVAR 20
5276: PUSH
5277: LD_EXP 4
5281: ST_TO_ADDR
// uc_nation := nation_american ;
5282: LD_ADDR_OWVAR 21
5286: PUSH
5287: LD_INT 1
5289: ST_TO_ADDR
// Denis := CreateCharacterWithClass ( Denis , class_scientistic ) ;
5290: LD_ADDR_EXP 26
5294: PUSH
5295: LD_STRING Denis
5297: PPUSH
5298: LD_INT 4
5300: PPUSH
5301: CALL_OW 35
5305: ST_TO_ADDR
// DialogDenis ;
5306: CALL 5311 0 0
// end ; end ;
5310: END
// function DialogDenis ; var depot , nekdo , mytick ; begin
5311: LD_INT 0
5313: PPUSH
5314: PPUSH
5315: PPUSH
5316: PPUSH
// wait ( 9 9$0 ) ;
5317: LD_INT 18900
5319: PPUSH
5320: CALL_OW 67
// depot := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5324: LD_ADDR_VAR 0 2
5328: PUSH
5329: LD_INT 22
5331: PUSH
5332: LD_EXP 1
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 2
5343: PUSH
5344: LD_INT 30
5346: PUSH
5347: LD_INT 0
5349: PUSH
5350: EMPTY
5351: LIST
5352: LIST
5353: PUSH
5354: LD_INT 30
5356: PUSH
5357: LD_INT 1
5359: PUSH
5360: EMPTY
5361: LIST
5362: LIST
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: LIST
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL_OW 69
5377: ST_TO_ADDR
// if depot then
5378: LD_VAR 0 2
5382: IFFALSE 5398
// depot := depot [ 1 ] ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 2
5393: PUSH
5394: LD_INT 1
5396: ARRAY
5397: ST_TO_ADDR
// mytick := tick + 0 0$15 ;
5398: LD_ADDR_VAR 0 4
5402: PUSH
5403: LD_OWVAR 1
5407: PUSH
5408: LD_INT 525
5410: PLUS
5411: ST_TO_ADDR
// PlaceUnitArea ( Denis , denis_come , false ) ;
5412: LD_EXP 26
5416: PPUSH
5417: LD_INT 9
5419: PPUSH
5420: LD_INT 0
5422: PPUSH
5423: CALL_OW 49
// case true of GetDistUnits ( Denis , JMM ) < 20 :
5427: LD_INT 1
5429: PUSH
5430: LD_EXP 26
5434: PPUSH
5435: LD_EXP 15
5439: PPUSH
5440: CALL_OW 296
5444: PUSH
5445: LD_INT 20
5447: LESS
5448: DOUBLE
5449: EQUAL
5450: IFTRUE 5454
5452: GO 5523
5454: POP
// begin ComMoveUnit ( Denis , JMM ) ;
5455: LD_EXP 26
5459: PPUSH
5460: LD_EXP 15
5464: PPUSH
5465: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and tick < mytick do
5469: LD_EXP 26
5473: PPUSH
5474: LD_VAR 0 2
5478: PPUSH
5479: CALL_OW 296
5483: PUSH
5484: LD_INT 5
5486: GREATER
5487: PUSH
5488: LD_EXP 26
5492: PPUSH
5493: CALL_OW 302
5497: AND
5498: PUSH
5499: LD_OWVAR 1
5503: PUSH
5504: LD_VAR 0 4
5508: LESS
5509: AND
5510: IFFALSE 5521
// begin wait ( 0 0$1 ) ;
5512: LD_INT 35
5514: PPUSH
5515: CALL_OW 67
// end ;
5519: GO 5469
// end ; GetDistUnits ( Denis , depot ) < 20 :
5521: GO 5740
5523: LD_EXP 26
5527: PPUSH
5528: LD_VAR 0 2
5532: PPUSH
5533: CALL_OW 296
5537: PUSH
5538: LD_INT 20
5540: LESS
5541: DOUBLE
5542: EQUAL
5543: IFTRUE 5547
5545: GO 5627
5547: POP
// begin ComMoveUnit ( Denis , depot ) ;
5548: LD_EXP 26
5552: PPUSH
5553: LD_VAR 0 2
5557: PPUSH
5558: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and IsOk ( depot ) and tick < mytick do
5562: LD_EXP 26
5566: PPUSH
5567: LD_VAR 0 2
5571: PPUSH
5572: CALL_OW 296
5576: PUSH
5577: LD_INT 5
5579: GREATER
5580: PUSH
5581: LD_EXP 26
5585: PPUSH
5586: CALL_OW 302
5590: AND
5591: PUSH
5592: LD_VAR 0 2
5596: PPUSH
5597: CALL_OW 302
5601: AND
5602: PUSH
5603: LD_OWVAR 1
5607: PUSH
5608: LD_VAR 0 4
5612: LESS
5613: AND
5614: IFFALSE 5625
// begin wait ( 0 0$1 ) ;
5616: LD_INT 35
5618: PPUSH
5619: CALL_OW 67
// end ;
5623: GO 5562
// end ; else
5625: GO 5740
5627: POP
// begin nekdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) , denis ) ;
5628: LD_ADDR_VAR 0 3
5632: PUSH
5633: LD_INT 22
5635: PUSH
5636: LD_EXP 1
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PUSH
5645: LD_INT 21
5647: PUSH
5648: LD_INT 1
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PPUSH
5659: CALL_OW 69
5663: PPUSH
5664: LD_EXP 26
5668: PPUSH
5669: CALL_OW 74
5673: ST_TO_ADDR
// ComMoveUnit ( Denis , nekdo ) ;
5674: LD_EXP 26
5678: PPUSH
5679: LD_VAR 0 3
5683: PPUSH
5684: CALL_OW 112
// while GetDistUnits ( Denis , nekdo ) > 5 and IsOK ( nekdo ) and tick < mytick do
5688: LD_EXP 26
5692: PPUSH
5693: LD_VAR 0 3
5697: PPUSH
5698: CALL_OW 296
5702: PUSH
5703: LD_INT 5
5705: GREATER
5706: PUSH
5707: LD_VAR 0 3
5711: PPUSH
5712: CALL_OW 302
5716: AND
5717: PUSH
5718: LD_OWVAR 1
5722: PUSH
5723: LD_VAR 0 4
5727: LESS
5728: AND
5729: IFFALSE 5740
// begin wait ( 0 0$1 ) ;
5731: LD_INT 35
5733: PPUSH
5734: CALL_OW 67
// end ;
5738: GO 5688
// end ; end ; ComStop ( Denis ) ;
5740: LD_EXP 26
5744: PPUSH
5745: CALL_OW 141
// SetSide ( Denis , you ) ;
5749: LD_EXP 26
5753: PPUSH
5754: LD_EXP 1
5758: PPUSH
5759: CALL_OW 235
// if IsLive ( Denis ) then
5763: LD_EXP 26
5767: PPUSH
5768: CALL_OW 300
5772: IFFALSE 5866
// begin enable ( 33 ) ;
5774: LD_INT 33
5776: ENABLE_MARKED
// DialogueOn ;
5777: CALL_OW 6
// CenterOnUnits ( Denis ) ;
5781: LD_EXP 26
5785: PPUSH
5786: CALL_OW 85
// Say ( Denis , DDen-Den-1 ) ;
5790: LD_EXP 26
5794: PPUSH
5795: LD_STRING DDen-Den-1
5797: PPUSH
5798: CALL_OW 88
// Say ( JMM , DDen-JMM-1 ) ;
5802: LD_EXP 15
5806: PPUSH
5807: LD_STRING DDen-JMM-1
5809: PPUSH
5810: CALL_OW 88
// Say ( Denis , DDen-Den-2 ) ;
5814: LD_EXP 26
5818: PPUSH
5819: LD_STRING DDen-Den-2
5821: PPUSH
5822: CALL_OW 88
// Say ( JMM , DDen-JMM-2 ) ;
5826: LD_EXP 15
5830: PPUSH
5831: LD_STRING DDen-JMM-2
5833: PPUSH
5834: CALL_OW 88
// Say ( Denis , DDen-Den-3 ) ;
5838: LD_EXP 26
5842: PPUSH
5843: LD_STRING DDen-Den-3
5845: PPUSH
5846: CALL_OW 88
// Say ( JMM , DDen-JMM-3 ) ;
5850: LD_EXP 15
5854: PPUSH
5855: LD_STRING DDen-JMM-3
5857: PPUSH
5858: CALL_OW 88
// DialogueOff ;
5862: CALL_OW 7
// end ; end ;
5866: LD_VAR 0 1
5870: RET
// export was_dialogR0 ; export function DialogR0 ; var kdo1 , kdo2 , r ; begin
5871: LD_INT 0
5873: PPUSH
5874: PPUSH
5875: PPUSH
5876: PPUSH
// if not was_dialogR0 then
5877: LD_EXP 87
5881: NOT
5882: IFFALSE 6194
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
5884: LD_ADDR_VAR 0 2
5888: PUSH
5889: LD_EXP 11
5893: PPUSH
5894: LD_EXP 1
5898: PPUSH
5899: LD_INT 1
5901: PPUSH
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 1
5907: PPUSH
5908: CALL 17244 0 5
5912: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
5913: LD_ADDR_VAR 0 3
5917: PUSH
5918: LD_EXP 11
5922: PPUSH
5923: LD_EXP 1
5927: PPUSH
5928: LD_INT 1
5930: PPUSH
5931: LD_INT 0
5933: PPUSH
5934: LD_INT 2
5936: PPUSH
5937: CALL 17244 0 5
5941: ST_TO_ADDR
// if not kdo1 then
5942: LD_VAR 0 2
5946: NOT
5947: IFFALSE 5999
// kdo1 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 1 ) ;
5949: LD_ADDR_VAR 0 2
5953: PUSH
5954: CALL 13496 0 0
5958: PUSH
5959: LD_EXP 15
5963: PUSH
5964: LD_EXP 22
5968: PUSH
5969: LD_EXP 26
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: DIFF
5979: PPUSH
5980: LD_EXP 1
5984: PPUSH
5985: LD_INT 1
5987: PPUSH
5988: LD_INT 0
5990: PPUSH
5991: LD_INT 1
5993: PPUSH
5994: CALL 17244 0 5
5998: ST_TO_ADDR
// if not kdo2 then
5999: LD_VAR 0 3
6003: NOT
6004: IFFALSE 6056
// kdo2 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 2 ) ;
6006: LD_ADDR_VAR 0 3
6010: PUSH
6011: CALL 13496 0 0
6015: PUSH
6016: LD_EXP 15
6020: PUSH
6021: LD_EXP 22
6025: PUSH
6026: LD_EXP 26
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: DIFF
6036: PPUSH
6037: LD_EXP 1
6041: PPUSH
6042: LD_INT 1
6044: PPUSH
6045: LD_INT 0
6047: PPUSH
6048: LD_INT 2
6050: PPUSH
6051: CALL 17244 0 5
6055: ST_TO_ADDR
// TalkOn ;
6056: CALL 17132 0 0
// if IsOK ( Lisa ) then
6060: LD_EXP 21
6064: PPUSH
6065: CALL_OW 302
6069: IFFALSE 6091
// r := Say ( Lisa , DR0-Lisa-1 ) else
6071: LD_ADDR_VAR 0 4
6075: PUSH
6076: LD_EXP 21
6080: PPUSH
6081: LD_STRING DR0-Lisa-1
6083: PPUSH
6084: CALL_OW 88
6088: ST_TO_ADDR
6089: GO 6109
// r := Say ( kdo1 , DR0-Sol1-1 ) ;
6091: LD_ADDR_VAR 0 4
6095: PUSH
6096: LD_VAR 0 2
6100: PPUSH
6101: LD_STRING DR0-Sol1-1
6103: PPUSH
6104: CALL_OW 88
6108: ST_TO_ADDR
// if r then
6109: LD_VAR 0 4
6113: IFFALSE 6164
// if IsOK ( Cyrus ) then
6115: LD_EXP 22
6119: PPUSH
6120: CALL_OW 302
6124: IFFALSE 6146
// r := Say ( Cyrus , DR0-Cyrus-1 ) else
6126: LD_ADDR_VAR 0 4
6130: PUSH
6131: LD_EXP 22
6135: PPUSH
6136: LD_STRING DR0-Cyrus-1
6138: PPUSH
6139: CALL_OW 88
6143: ST_TO_ADDR
6144: GO 6164
// r := Say ( kdo2 , DR0-Sol2-1 ) ;
6146: LD_ADDR_VAR 0 4
6150: PUSH
6151: LD_VAR 0 3
6155: PPUSH
6156: LD_STRING DR0-Sol2-1
6158: PPUSH
6159: CALL_OW 88
6163: ST_TO_ADDR
// if r then
6164: LD_VAR 0 4
6168: IFFALSE 6182
// Say ( JMM , DR0-JMM-1 ) ;
6170: LD_EXP 15
6174: PPUSH
6175: LD_STRING DR0-JMM-1
6177: PPUSH
6178: CALL_OW 88
// TalkOff ;
6182: CALL 17148 0 0
// was_dialogR0 := true ;
6186: LD_ADDR_EXP 87
6190: PUSH
6191: LD_INT 1
6193: ST_TO_ADDR
// end ; end ;
6194: LD_VAR 0 1
6198: RET
// function MajiOpto ; var i ; begin
6199: LD_INT 0
6201: PPUSH
6202: PPUSH
// result := false ;
6203: LD_ADDR_VAR 0 1
6207: PUSH
6208: LD_INT 0
6210: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
6211: LD_ADDR_VAR 0 2
6215: PUSH
6216: LD_INT 22
6218: PUSH
6219: LD_EXP 1
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 2
6230: PUSH
6231: LD_INT 30
6233: PUSH
6234: LD_INT 7
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 30
6243: PUSH
6244: LD_INT 8
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PUSH
6265: FOR_IN
6266: IFFALSE 6316
// if ( GetLabKind ( i , 1 ) = b_lab_opto ) or ( GetLabKind ( i , 2 ) = b_lab_opto ) then
6268: LD_VAR 0 2
6272: PPUSH
6273: LD_INT 1
6275: PPUSH
6276: CALL_OW 268
6280: PUSH
6281: LD_INT 15
6283: EQUAL
6284: PUSH
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 2
6292: PPUSH
6293: CALL_OW 268
6297: PUSH
6298: LD_INT 15
6300: EQUAL
6301: OR
6302: IFFALSE 6314
// begin result := true ;
6304: LD_ADDR_VAR 0 1
6308: PUSH
6309: LD_INT 1
6311: ST_TO_ADDR
// break ;
6312: GO 6316
// end ;
6314: GO 6265
6316: POP
6317: POP
// end ;
6318: LD_VAR 0 1
6322: RET
// every 0 0$7 trigger MajiOpto and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] ] ] ) marked 33 do
6323: CALL 6199 0 0
6327: PUSH
6328: LD_INT 22
6330: PUSH
6331: LD_EXP 1
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 2
6342: PUSH
6343: LD_INT 30
6345: PUSH
6346: LD_INT 26
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 30
6355: PUSH
6356: LD_INT 27
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: EMPTY
6369: LIST
6370: LIST
6371: PPUSH
6372: CALL_OW 69
6376: AND
6377: IFFALSE 6427
6379: GO 6381
6381: DISABLE
// begin if IsOK ( Denis ) then
6382: LD_EXP 26
6386: PPUSH
6387: CALL_OW 302
6391: IFFALSE 6427
// begin DialogueOn ;
6393: CALL_OW 6
// if Say ( Denis , DR1-Den-1 ) then
6397: LD_EXP 26
6401: PPUSH
6402: LD_STRING DR1-Den-1
6404: PPUSH
6405: CALL_OW 88
6409: IFFALSE 6423
// Say ( JMM , DR1-JMM-1 ) ;
6411: LD_EXP 15
6415: PPUSH
6416: LD_STRING DR1-JMM-1
6418: PPUSH
6419: CALL_OW 88
// DialogueOff ;
6423: CALL_OW 7
// end ; end ;
6427: END
// function ScisInLabs ; var labs , i , inlabs ; begin
6428: LD_INT 0
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
// inlabs := [ ] ;
6434: LD_ADDR_VAR 0 4
6438: PUSH
6439: EMPTY
6440: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
6441: LD_ADDR_VAR 0 2
6445: PUSH
6446: LD_INT 22
6448: PUSH
6449: LD_EXP 1
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PUSH
6458: LD_INT 2
6460: PUSH
6461: LD_INT 30
6463: PUSH
6464: LD_INT 6
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 30
6473: PUSH
6474: LD_INT 7
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: PUSH
6481: LD_INT 30
6483: PUSH
6484: LD_INT 8
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: PPUSH
6501: CALL_OW 69
6505: ST_TO_ADDR
// for i in labs do
6506: LD_ADDR_VAR 0 3
6510: PUSH
6511: LD_VAR 0 2
6515: PUSH
6516: FOR_IN
6517: IFFALSE 6542
// inlabs := inlabs ^ UnitsInside ( i ) ;
6519: LD_ADDR_VAR 0 4
6523: PUSH
6524: LD_VAR 0 4
6528: PUSH
6529: LD_VAR 0 3
6533: PPUSH
6534: CALL_OW 313
6538: ADD
6539: ST_TO_ADDR
6540: GO 6516
6542: POP
6543: POP
// result := UnitFilter ( inlabs , [ f_class , class_scientistic ] ) ;
6544: LD_ADDR_VAR 0 1
6548: PUSH
6549: LD_VAR 0 4
6553: PPUSH
6554: LD_INT 25
6556: PUSH
6557: LD_INT 4
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 72
6568: ST_TO_ADDR
// end ;
6569: LD_VAR 0 1
6573: RET
// export function DialogR2 ; var scis , r ; begin
6574: LD_INT 0
6576: PPUSH
6577: PPUSH
6578: PPUSH
// scis := ScisInLabs ;
6579: LD_ADDR_VAR 0 2
6583: PUSH
6584: CALL 6428 0 0
6588: ST_TO_ADDR
// if scis isect ( not_char union Denis ) then
6589: LD_VAR 0 2
6593: PUSH
6594: LD_EXP 11
6598: PUSH
6599: LD_EXP 26
6603: UNION
6604: ISECT
6605: IFFALSE 6629
// scis := scis isect ( not_char union Denis ) ;
6607: LD_ADDR_VAR 0 2
6611: PUSH
6612: LD_VAR 0 2
6616: PUSH
6617: LD_EXP 11
6621: PUSH
6622: LD_EXP 26
6626: UNION
6627: ISECT
6628: ST_TO_ADDR
// if scis then
6629: LD_VAR 0 2
6633: IFFALSE 6816
// begin DialogueOn ;
6635: CALL_OW 6
// if not IsDead ( Denis ) and ( Denis in scis ) then
6639: LD_EXP 26
6643: PPUSH
6644: CALL_OW 301
6648: NOT
6649: PUSH
6650: LD_EXP 26
6654: PUSH
6655: LD_VAR 0 2
6659: IN
6660: AND
6661: IFFALSE 6683
// r := Say ( Denis , DR2-Den-1 ) else
6663: LD_ADDR_VAR 0 3
6667: PUSH
6668: LD_EXP 26
6672: PPUSH
6673: LD_STRING DR2-Den-1
6675: PPUSH
6676: CALL_OW 88
6680: ST_TO_ADDR
6681: GO 6748
// if GetSex ( scis [ 1 ] ) = sex_male then
6683: LD_VAR 0 2
6687: PUSH
6688: LD_INT 1
6690: ARRAY
6691: PPUSH
6692: CALL_OW 258
6696: PUSH
6697: LD_INT 1
6699: EQUAL
6700: IFFALSE 6726
// r := Say ( scis [ 1 ] , DR2-Sci1-1 ) else
6702: LD_ADDR_VAR 0 3
6706: PUSH
6707: LD_VAR 0 2
6711: PUSH
6712: LD_INT 1
6714: ARRAY
6715: PPUSH
6716: LD_STRING DR2-Sci1-1
6718: PPUSH
6719: CALL_OW 88
6723: ST_TO_ADDR
6724: GO 6748
// r := Say ( scis [ 1 ] , DR2-FSci1-1 ) ;
6726: LD_ADDR_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: PUSH
6736: LD_INT 1
6738: ARRAY
6739: PPUSH
6740: LD_STRING DR2-FSci1-1
6742: PPUSH
6743: CALL_OW 88
6747: ST_TO_ADDR
// if r then
6748: LD_VAR 0 3
6752: IFFALSE 6766
// Say ( JMM , DR2-JMM-1 ) ;
6754: LD_EXP 15
6758: PPUSH
6759: LD_STRING DR2-JMM-1
6761: PPUSH
6762: CALL_OW 88
// if r then
6766: LD_VAR 0 3
6770: IFFALSE 6812
// if SayAny ( not_char , DR2-Sol1-1 , you , sex_male , 0 , 0 ) then
6772: LD_EXP 11
6776: PPUSH
6777: LD_STRING DR2-Sol1-1
6779: PPUSH
6780: LD_EXP 1
6784: PPUSH
6785: LD_INT 1
6787: PPUSH
6788: LD_INT 0
6790: PPUSH
6791: LD_INT 0
6793: PPUSH
6794: CALL 17164 0 6
6798: IFFALSE 6812
// Say ( JMM , DR2-JMM-2 ) ;
6800: LD_EXP 15
6804: PPUSH
6805: LD_STRING DR2-JMM-2
6807: PPUSH
6808: CALL_OW 88
// DialogueOff ;
6812: CALL_OW 7
// end ; end ;
6816: LD_VAR 0 1
6820: RET
// export function DialogKurt ( kdo ) ; var qr , mytick ; var JeMM , JeF ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// DialogInProgress := true ;
6828: LD_ADDR_EXP 52
6832: PUSH
6833: LD_INT 1
6835: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_outside ] , [ f_nation , nation_american ] , [ f_alive ] ] ) , Kurt ) ;
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_INT 22
6843: PUSH
6844: LD_EXP 1
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PUSH
6853: LD_INT 21
6855: PUSH
6856: LD_INT 1
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: PUSH
6863: LD_INT 56
6865: PUSH
6866: EMPTY
6867: LIST
6868: PUSH
6869: LD_INT 23
6871: PUSH
6872: LD_INT 1
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PUSH
6879: LD_INT 51
6881: PUSH
6882: EMPTY
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL_OW 69
6896: PPUSH
6897: LD_EXP 43
6901: PPUSH
6902: CALL_OW 74
6906: ST_TO_ADDR
// JeF := ( GetSex ( kdo ) = sex_female ) ;
6907: LD_ADDR_VAR 0 6
6911: PUSH
6912: LD_VAR 0 1
6916: PPUSH
6917: CALL_OW 258
6921: PUSH
6922: LD_INT 2
6924: EQUAL
6925: ST_TO_ADDR
// JeMM := ( kdo = JMM ) ;
6926: LD_ADDR_VAR 0 5
6930: PUSH
6931: LD_VAR 0 1
6935: PUSH
6936: LD_EXP 15
6940: EQUAL
6941: ST_TO_ADDR
// InGameOn ;
6942: CALL_OW 8
// CenterOnUnits ( Kurt ) ;
6946: LD_EXP 43
6950: PPUSH
6951: CALL_OW 85
// Wait ( 0 0$4 ) ;
6955: LD_INT 140
6957: PPUSH
6958: CALL_OW 67
// ComMoveUnit ( kdo , Kurt ) ;
6962: LD_VAR 0 1
6966: PPUSH
6967: LD_EXP 43
6971: PPUSH
6972: CALL_OW 112
// AddComTurnUnit ( kdo , Kurt ) ;
6976: LD_VAR 0 1
6980: PPUSH
6981: LD_EXP 43
6985: PPUSH
6986: CALL_OW 179
// AddComHold ( kdo ) ;
6990: LD_VAR 0 1
6994: PPUSH
6995: CALL_OW 200
// ComMoveUnit ( Kurt , kdo ) ;
6999: LD_EXP 43
7003: PPUSH
7004: LD_VAR 0 1
7008: PPUSH
7009: CALL_OW 112
// AddComTurnUnit ( Kurt , kdo ) ;
7013: LD_EXP 43
7017: PPUSH
7018: LD_VAR 0 1
7022: PPUSH
7023: CALL_OW 179
// AddComHold ( Kurt ) ;
7027: LD_EXP 43
7031: PPUSH
7032: CALL_OW 200
// mytick := tick + 0 0$15 ;
7036: LD_ADDR_VAR 0 4
7040: PUSH
7041: LD_OWVAR 1
7045: PUSH
7046: LD_INT 525
7048: PLUS
7049: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Kurt , kdo ) > 4 do
7050: LD_VAR 0 4
7054: PUSH
7055: LD_OWVAR 1
7059: GREATER
7060: PUSH
7061: LD_EXP 43
7065: PPUSH
7066: LD_VAR 0 1
7070: PPUSH
7071: CALL_OW 296
7075: PUSH
7076: LD_INT 4
7078: GREATER
7079: AND
7080: IFFALSE 7091
// Wait ( 0 0$1 ) ;
7082: LD_INT 35
7084: PPUSH
7085: CALL_OW 67
7089: GO 7050
// InGameOff ;
7091: CALL_OW 9
// if IsLive ( Kurt ) and IsLive ( kdo ) then
7095: LD_EXP 43
7099: PPUSH
7100: CALL_OW 300
7104: PUSH
7105: LD_VAR 0 1
7109: PPUSH
7110: CALL_OW 300
7114: AND
7115: IFFALSE 8371
// begin DialogueOn ;
7117: CALL_OW 6
// if JeMM then
7121: LD_VAR 0 5
7125: IFFALSE 7455
// begin Say ( Kurt , D2-Kurt-1 ) ;
7127: LD_EXP 43
7131: PPUSH
7132: LD_STRING D2-Kurt-1
7134: PPUSH
7135: CALL_OW 88
// Say ( kdo , D2-JMM-1 ) ;
7139: LD_VAR 0 1
7143: PPUSH
7144: LD_STRING D2-JMM-1
7146: PPUSH
7147: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7151: LD_EXP 43
7155: PPUSH
7156: LD_STRING D2-Kurt-2
7158: PPUSH
7159: CALL_OW 88
// Say ( kdo , D2-JMM-2 ) ;
7163: LD_VAR 0 1
7167: PPUSH
7168: LD_STRING D2-JMM-2
7170: PPUSH
7171: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7175: LD_EXP 43
7179: PPUSH
7180: LD_STRING D2-Kurt-3
7182: PPUSH
7183: CALL_OW 88
// Say ( kdo , D2-JMM-3 ) ;
7187: LD_VAR 0 1
7191: PPUSH
7192: LD_STRING D2-JMM-3
7194: PPUSH
7195: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7199: LD_EXP 43
7203: PPUSH
7204: LD_STRING D2-Kurt-4
7206: PPUSH
7207: CALL_OW 88
// Say ( kdo , D2-JMM-4 ) ;
7211: LD_VAR 0 1
7215: PPUSH
7216: LD_STRING D2-JMM-4
7218: PPUSH
7219: CALL_OW 88
// qr := Query ( QKill ) ;
7223: LD_ADDR_VAR 0 3
7227: PUSH
7228: LD_STRING QKill
7230: PPUSH
7231: CALL_OW 97
7235: ST_TO_ADDR
// case qr of 1 :
7236: LD_VAR 0 3
7240: PUSH
7241: LD_INT 1
7243: DOUBLE
7244: EQUAL
7245: IFTRUE 7249
7247: GO 7264
7249: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7250: LD_EXP 43
7254: PPUSH
7255: LD_STRING D2a-Kurt-1
7257: PPUSH
7258: CALL_OW 88
// end ; 2 :
7262: GO 7366
7264: LD_INT 2
7266: DOUBLE
7267: EQUAL
7268: IFTRUE 7272
7270: GO 7330
7272: POP
// begin Say ( kdo , D2b-JMM-1 ) ;
7273: LD_VAR 0 1
7277: PPUSH
7278: LD_STRING D2b-JMM-1
7280: PPUSH
7281: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7285: LD_EXP 43
7289: PPUSH
7290: LD_STRING D2b-Kurt-1
7292: PPUSH
7293: CALL_OW 88
// Say ( kdo , D2b-JMM-2 ) ;
7297: LD_VAR 0 1
7301: PPUSH
7302: LD_STRING D2b-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7309: LD_EXP 43
7313: PPUSH
7314: LD_STRING D2b-Kurt-2
7316: PPUSH
7317: CALL_OW 88
// SayEffect ( Kurtfire.wav ) ;
7321: LD_STRING Kurtfire.wav
7323: PPUSH
7324: CALL_OW 96
// end ; 3 :
7328: GO 7366
7330: LD_INT 3
7332: DOUBLE
7333: EQUAL
7334: IFTRUE 7338
7336: GO 7365
7338: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_STRING D2c-JMM-1
7346: PPUSH
7347: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7351: LD_EXP 43
7355: PPUSH
7356: LD_STRING D2c-Kurt-1
7358: PPUSH
7359: CALL_OW 88
// end ; end ;
7363: GO 7366
7365: POP
// if qr = 2 then
7366: LD_VAR 0 3
7370: PUSH
7371: LD_INT 2
7373: EQUAL
7374: IFFALSE 7453
// begin qr := Query ( QKill2 ) ;
7376: LD_ADDR_VAR 0 3
7380: PUSH
7381: LD_STRING QKill2
7383: PPUSH
7384: CALL_OW 97
7388: ST_TO_ADDR
// case qr of 1 :
7389: LD_VAR 0 3
7393: PUSH
7394: LD_INT 1
7396: DOUBLE
7397: EQUAL
7398: IFTRUE 7402
7400: GO 7417
7402: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7403: LD_EXP 43
7407: PPUSH
7408: LD_STRING D2a-Kurt-1
7410: PPUSH
7411: CALL_OW 88
// end ; 2 :
7415: GO 7453
7417: LD_INT 2
7419: DOUBLE
7420: EQUAL
7421: IFTRUE 7425
7423: GO 7452
7425: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7426: LD_VAR 0 1
7430: PPUSH
7431: LD_STRING D2c-JMM-1
7433: PPUSH
7434: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7438: LD_EXP 43
7442: PPUSH
7443: LD_STRING D2c-Kurt-1
7445: PPUSH
7446: CALL_OW 88
// end ; end ;
7450: GO 7453
7452: POP
// end ; end else
7453: GO 8149
// if JeF then
7455: LD_VAR 0 6
7459: IFFALSE 7806
// begin Say ( Kurt , D2-Kurt-1 ) ;
7461: LD_EXP 43
7465: PPUSH
7466: LD_STRING D2-Kurt-1
7468: PPUSH
7469: CALL_OW 88
// Say ( kdo , D2-FSol1-1 ) ;
7473: LD_VAR 0 1
7477: PPUSH
7478: LD_STRING D2-FSol1-1
7480: PPUSH
7481: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7485: LD_EXP 43
7489: PPUSH
7490: LD_STRING D2-Kurt-2
7492: PPUSH
7493: CALL_OW 88
// Say ( kdo , D2-FSol1-2 ) ;
7497: LD_VAR 0 1
7501: PPUSH
7502: LD_STRING D2-FSol1-2
7504: PPUSH
7505: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7509: LD_EXP 43
7513: PPUSH
7514: LD_STRING D2-Kurt-3
7516: PPUSH
7517: CALL_OW 88
// Say ( kdo , D2-FSol1-3 ) ;
7521: LD_VAR 0 1
7525: PPUSH
7526: LD_STRING D2-FSol1-3
7528: PPUSH
7529: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7533: LD_EXP 43
7537: PPUSH
7538: LD_STRING D2-Kurt-4
7540: PPUSH
7541: CALL_OW 88
// Say ( kdo , D2-FSol1-4 ) ;
7545: LD_VAR 0 1
7549: PPUSH
7550: LD_STRING D2-FSol1-4
7552: PPUSH
7553: CALL_OW 88
// Say ( kdo , D2-FSol1-5 ) ;
7557: LD_VAR 0 1
7561: PPUSH
7562: LD_STRING D2-FSol1-5
7564: PPUSH
7565: CALL_OW 88
// qr := Query ( QKill ) ;
7569: LD_ADDR_VAR 0 3
7573: PUSH
7574: LD_STRING QKill
7576: PPUSH
7577: CALL_OW 97
7581: ST_TO_ADDR
// case qr of 1 :
7582: LD_VAR 0 3
7586: PUSH
7587: LD_INT 1
7589: DOUBLE
7590: EQUAL
7591: IFTRUE 7595
7593: GO 7610
7595: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7596: LD_EXP 43
7600: PPUSH
7601: LD_STRING D2a-Kurt-1
7603: PPUSH
7604: CALL_OW 88
// end ; 2 :
7608: GO 7717
7610: LD_INT 2
7612: DOUBLE
7613: EQUAL
7614: IFTRUE 7618
7616: GO 7681
7618: POP
// begin Say ( kdo , D2b-FSol1-1 ) ;
7619: LD_VAR 0 1
7623: PPUSH
7624: LD_STRING D2b-FSol1-1
7626: PPUSH
7627: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7631: LD_EXP 43
7635: PPUSH
7636: LD_STRING D2b-Kurt-1
7638: PPUSH
7639: CALL_OW 88
// Say ( kdo , D2b-FSol1-2 ) ;
7643: LD_VAR 0 1
7647: PPUSH
7648: LD_STRING D2b-FSol1-2
7650: PPUSH
7651: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7655: LD_EXP 43
7659: PPUSH
7660: LD_STRING D2b-Kurt-2
7662: PPUSH
7663: CALL_OW 88
// Say ( kdo , D2b-FSol1-3 ) ;
7667: LD_VAR 0 1
7671: PPUSH
7672: LD_STRING D2b-FSol1-3
7674: PPUSH
7675: CALL_OW 88
// end ; 3 :
7679: GO 7717
7681: LD_INT 3
7683: DOUBLE
7684: EQUAL
7685: IFTRUE 7689
7687: GO 7716
7689: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7690: LD_VAR 0 1
7694: PPUSH
7695: LD_STRING D2c-FSol1-1
7697: PPUSH
7698: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7702: LD_EXP 43
7706: PPUSH
7707: LD_STRING D2c-Kurt-1
7709: PPUSH
7710: CALL_OW 88
// end ; end ;
7714: GO 7717
7716: POP
// if qr = 2 then
7717: LD_VAR 0 3
7721: PUSH
7722: LD_INT 2
7724: EQUAL
7725: IFFALSE 7804
// begin qr := Query ( QKill2 ) ;
7727: LD_ADDR_VAR 0 3
7731: PUSH
7732: LD_STRING QKill2
7734: PPUSH
7735: CALL_OW 97
7739: ST_TO_ADDR
// case qr of 1 :
7740: LD_VAR 0 3
7744: PUSH
7745: LD_INT 1
7747: DOUBLE
7748: EQUAL
7749: IFTRUE 7753
7751: GO 7768
7753: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7754: LD_EXP 43
7758: PPUSH
7759: LD_STRING D2a-Kurt-1
7761: PPUSH
7762: CALL_OW 88
// end ; 2 :
7766: GO 7804
7768: LD_INT 2
7770: DOUBLE
7771: EQUAL
7772: IFTRUE 7776
7774: GO 7803
7776: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7777: LD_VAR 0 1
7781: PPUSH
7782: LD_STRING D2c-FSol1-1
7784: PPUSH
7785: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7789: LD_EXP 43
7793: PPUSH
7794: LD_STRING D2c-Kurt-1
7796: PPUSH
7797: CALL_OW 88
// end ; end ;
7801: GO 7804
7803: POP
// end ; end else
7804: GO 8149
// begin Say ( Kurt , D2-Kurt-1 ) ;
7806: LD_EXP 43
7810: PPUSH
7811: LD_STRING D2-Kurt-1
7813: PPUSH
7814: CALL_OW 88
// Say ( kdo , D2-Sol1-1 ) ;
7818: LD_VAR 0 1
7822: PPUSH
7823: LD_STRING D2-Sol1-1
7825: PPUSH
7826: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7830: LD_EXP 43
7834: PPUSH
7835: LD_STRING D2-Kurt-2
7837: PPUSH
7838: CALL_OW 88
// Say ( kdo , D2-Sol1-2 ) ;
7842: LD_VAR 0 1
7846: PPUSH
7847: LD_STRING D2-Sol1-2
7849: PPUSH
7850: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7854: LD_EXP 43
7858: PPUSH
7859: LD_STRING D2-Kurt-3
7861: PPUSH
7862: CALL_OW 88
// Say ( kdo , D2-Sol1-3 ) ;
7866: LD_VAR 0 1
7870: PPUSH
7871: LD_STRING D2-Sol1-3
7873: PPUSH
7874: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7878: LD_EXP 43
7882: PPUSH
7883: LD_STRING D2-Kurt-4
7885: PPUSH
7886: CALL_OW 88
// Say ( kdo , D2-Sol1-4 ) ;
7890: LD_VAR 0 1
7894: PPUSH
7895: LD_STRING D2-Sol1-4
7897: PPUSH
7898: CALL_OW 88
// Say ( kdo , D2-Sol1-5 ) ;
7902: LD_VAR 0 1
7906: PPUSH
7907: LD_STRING D2-Sol1-5
7909: PPUSH
7910: CALL_OW 88
// qr := Query ( QKill ) ;
7914: LD_ADDR_VAR 0 3
7918: PUSH
7919: LD_STRING QKill
7921: PPUSH
7922: CALL_OW 97
7926: ST_TO_ADDR
// case qr of 1 :
7927: LD_VAR 0 3
7931: PUSH
7932: LD_INT 1
7934: DOUBLE
7935: EQUAL
7936: IFTRUE 7940
7938: GO 7955
7940: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7941: LD_EXP 43
7945: PPUSH
7946: LD_STRING D2a-Kurt-1
7948: PPUSH
7949: CALL_OW 88
// end ; 2 :
7953: GO 8062
7955: LD_INT 2
7957: DOUBLE
7958: EQUAL
7959: IFTRUE 7963
7961: GO 8026
7963: POP
// begin Say ( kdo , D2b-Sol1-1 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_STRING D2b-Sol1-1
7971: PPUSH
7972: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7976: LD_EXP 43
7980: PPUSH
7981: LD_STRING D2b-Kurt-1
7983: PPUSH
7984: CALL_OW 88
// Say ( kdo , D2b-Sol1-2 ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: LD_STRING D2b-Sol1-2
7995: PPUSH
7996: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
8000: LD_EXP 43
8004: PPUSH
8005: LD_STRING D2b-Kurt-2
8007: PPUSH
8008: CALL_OW 88
// Say ( kdo , D2b-Sol1-3 ) ;
8012: LD_VAR 0 1
8016: PPUSH
8017: LD_STRING D2b-Sol1-3
8019: PPUSH
8020: CALL_OW 88
// end ; 3 :
8024: GO 8062
8026: LD_INT 3
8028: DOUBLE
8029: EQUAL
8030: IFTRUE 8034
8032: GO 8061
8034: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8035: LD_VAR 0 1
8039: PPUSH
8040: LD_STRING D2c-Sol1-1
8042: PPUSH
8043: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8047: LD_EXP 43
8051: PPUSH
8052: LD_STRING D2c-Kurt-1
8054: PPUSH
8055: CALL_OW 88
// end ; end ;
8059: GO 8062
8061: POP
// if qr = 2 then
8062: LD_VAR 0 3
8066: PUSH
8067: LD_INT 2
8069: EQUAL
8070: IFFALSE 8149
// begin qr := Query ( QKill2 ) ;
8072: LD_ADDR_VAR 0 3
8076: PUSH
8077: LD_STRING QKill2
8079: PPUSH
8080: CALL_OW 97
8084: ST_TO_ADDR
// case qr of 1 :
8085: LD_VAR 0 3
8089: PUSH
8090: LD_INT 1
8092: DOUBLE
8093: EQUAL
8094: IFTRUE 8098
8096: GO 8113
8098: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
8099: LD_EXP 43
8103: PPUSH
8104: LD_STRING D2a-Kurt-1
8106: PPUSH
8107: CALL_OW 88
// end ; 2 :
8111: GO 8149
8113: LD_INT 2
8115: DOUBLE
8116: EQUAL
8117: IFTRUE 8121
8119: GO 8148
8121: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8122: LD_VAR 0 1
8126: PPUSH
8127: LD_STRING D2c-Sol1-1
8129: PPUSH
8130: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8134: LD_EXP 43
8138: PPUSH
8139: LD_STRING D2c-Kurt-1
8141: PPUSH
8142: CALL_OW 88
// end ; end ;
8146: GO 8149
8148: POP
// end ; end ; DialogueOff ;
8149: CALL_OW 7
// if qr = 1 then
8153: LD_VAR 0 3
8157: PUSH
8158: LD_INT 1
8160: EQUAL
8161: IFFALSE 8263
// begin KurtTryToEscape := true ;
8163: LD_ADDR_EXP 85
8167: PUSH
8168: LD_INT 1
8170: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
8171: LD_EXP 3
8175: PPUSH
8176: LD_EXP 1
8180: PPUSH
8181: LD_INT 2
8183: PPUSH
8184: LD_INT 1
8186: PPUSH
8187: CALL_OW 80
// ComAttackUnit ( kdo , Kurt ) ;
8191: LD_VAR 0 1
8195: PPUSH
8196: LD_EXP 43
8200: PPUSH
8201: CALL_OW 115
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) do
8205: LD_EXP 43
8209: PPUSH
8210: LD_INT 10
8212: PPUSH
8213: CALL_OW 308
8217: NOT
8218: PUSH
8219: LD_EXP 43
8223: PPUSH
8224: CALL_OW 300
8228: AND
8229: IFFALSE 8252
// begin ComMoveToArea ( Kurt , border ) ;
8231: LD_EXP 43
8235: PPUSH
8236: LD_INT 10
8238: PPUSH
8239: CALL_OW 113
// wait ( 0 0$1 ) ;
8243: LD_INT 35
8245: PPUSH
8246: CALL_OW 67
// end ;
8250: GO 8205
// RemoveUnit ( Kurt ) ;
8252: LD_EXP 43
8256: PPUSH
8257: CALL_OW 64
// end else
8261: GO 8371
// begin SA_OnKurtSpared ;
8263: CALL 27029 0 0
// mytick := tick + 0 0$20 ;
8267: LD_ADDR_VAR 0 4
8271: PUSH
8272: LD_OWVAR 1
8276: PUSH
8277: LD_INT 700
8279: PLUS
8280: ST_TO_ADDR
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) and mytick > tick do
8281: LD_EXP 43
8285: PPUSH
8286: LD_INT 10
8288: PPUSH
8289: CALL_OW 308
8293: NOT
8294: PUSH
8295: LD_EXP 43
8299: PPUSH
8300: CALL_OW 300
8304: AND
8305: PUSH
8306: LD_VAR 0 4
8310: PUSH
8311: LD_OWVAR 1
8315: GREATER
8316: AND
8317: IFFALSE 8340
// begin ComMoveToArea ( Kurt , border ) ;
8319: LD_EXP 43
8323: PPUSH
8324: LD_INT 10
8326: PPUSH
8327: CALL_OW 113
// wait ( 0 0$1 ) ;
8331: LD_INT 35
8333: PPUSH
8334: CALL_OW 67
// end ;
8338: GO 8281
// if IsPlaced ( Kurt ) and IsLive ( kurt ) then
8340: LD_EXP 43
8344: PPUSH
8345: CALL_OW 305
8349: PUSH
8350: LD_EXP 43
8354: PPUSH
8355: CALL_OW 300
8359: AND
8360: IFFALSE 8371
// RemoveUnit ( Kurt ) ;
8362: LD_EXP 43
8366: PPUSH
8367: CALL_OW 64
// end ; end ; DialogInProgress := false ;
8371: LD_ADDR_EXP 52
8375: PUSH
8376: LD_INT 0
8378: ST_TO_ADDR
// end ;
8379: LD_VAR 0 2
8383: RET
// every 0 0$10 trigger GetAttitude ( arabians , you ) = att_enemy do
8384: LD_EXP 3
8388: PPUSH
8389: LD_EXP 1
8393: PPUSH
8394: CALL_OW 81
8398: PUSH
8399: LD_INT 2
8401: EQUAL
8402: IFFALSE 8415
8404: GO 8406
8406: DISABLE
// begin KurtTryToEscape := true ;
8407: LD_ADDR_EXP 85
8411: PUSH
8412: LD_INT 1
8414: ST_TO_ADDR
// end ;
8415: END
// export function DialogJoan ( kdo ) ; var mytick ; begin
8416: LD_INT 0
8418: PPUSH
8419: PPUSH
// DialogInProgress := true ;
8420: LD_ADDR_EXP 52
8424: PUSH
8425: LD_INT 1
8427: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8428: LD_ADDR_VAR 0 1
8432: PUSH
8433: LD_INT 26
8435: PUSH
8436: LD_INT 1
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PUSH
8443: LD_INT 22
8445: PUSH
8446: LD_EXP 1
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: LD_INT 21
8457: PUSH
8458: LD_INT 1
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 3
8467: PUSH
8468: LD_INT 54
8470: PUSH
8471: EMPTY
8472: LIST
8473: PUSH
8474: LD_INT 3
8476: PUSH
8477: LD_INT 55
8479: PUSH
8480: EMPTY
8481: LIST
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: LD_INT 23
8488: PUSH
8489: LD_INT 0
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: PUSH
8496: LD_INT 51
8498: PUSH
8499: EMPTY
8500: LIST
8501: PUSH
8502: EMPTY
8503: LIST
8504: LIST
8505: LIST
8506: LIST
8507: LIST
8508: LIST
8509: LIST
8510: LIST
8511: LIST
8512: LIST
8513: PPUSH
8514: CALL_OW 69
8518: PUSH
8519: LD_EXP 33
8523: DIFF
8524: PPUSH
8525: LD_EXP 33
8529: PPUSH
8530: CALL_OW 74
8534: ST_TO_ADDR
// InGameOn ;
8535: CALL_OW 8
// CenterOnUnits ( Joan ) ;
8539: LD_EXP 33
8543: PPUSH
8544: CALL_OW 85
// DoNotAttack ( russians , Joan ) ;
8548: LD_EXP 2
8552: PPUSH
8553: LD_EXP 33
8557: PPUSH
8558: CALL_OW 471
// Wait ( 0 0$5 ) ;
8562: LD_INT 175
8564: PPUSH
8565: CALL_OW 67
// SetLives ( Joan , hranice_umirani + 50 ) ;
8569: LD_EXP 33
8573: PPUSH
8574: LD_INT 250
8576: PUSH
8577: LD_INT 50
8579: PLUS
8580: PPUSH
8581: CALL_OW 234
// AddComMoveUnit ( Joan , kdo ) ;
8585: LD_EXP 33
8589: PPUSH
8590: LD_VAR 0 1
8594: PPUSH
8595: CALL_OW 172
// AddComTurnUnit ( Joan , kdo ) ;
8599: LD_EXP 33
8603: PPUSH
8604: LD_VAR 0 1
8608: PPUSH
8609: CALL_OW 179
// AddComHold ( Joan ) ;
8613: LD_EXP 33
8617: PPUSH
8618: CALL_OW 200
// ComMoveUnit ( kdo , Joan ) ;
8622: LD_VAR 0 1
8626: PPUSH
8627: LD_EXP 33
8631: PPUSH
8632: CALL_OW 112
// AddComTurnUnit ( kdo , Joan ) ;
8636: LD_VAR 0 1
8640: PPUSH
8641: LD_EXP 33
8645: PPUSH
8646: CALL_OW 179
// AddComHold ( kdo ) ;
8650: LD_VAR 0 1
8654: PPUSH
8655: CALL_OW 200
// mytick := tick + 0 0$15 ;
8659: LD_ADDR_VAR 0 3
8663: PUSH
8664: LD_OWVAR 1
8668: PUSH
8669: LD_INT 525
8671: PLUS
8672: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , kdo ) > 4 and IsOK ( kdo ) do
8673: LD_VAR 0 3
8677: PUSH
8678: LD_OWVAR 1
8682: GREATER
8683: PUSH
8684: LD_EXP 33
8688: PPUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 296
8698: PUSH
8699: LD_INT 4
8701: GREATER
8702: AND
8703: PUSH
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 302
8713: AND
8714: IFFALSE 8725
// Wait ( 0 0$1 ) ;
8716: LD_INT 35
8718: PPUSH
8719: CALL_OW 67
8723: GO 8673
// if not IsOK ( kdo ) then
8725: LD_VAR 0 1
8729: PPUSH
8730: CALL_OW 302
8734: NOT
8735: IFFALSE 8844
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8737: LD_ADDR_VAR 0 1
8741: PUSH
8742: LD_INT 26
8744: PUSH
8745: LD_INT 1
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_EXP 1
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: PUSH
8764: LD_INT 21
8766: PUSH
8767: LD_INT 1
8769: PUSH
8770: EMPTY
8771: LIST
8772: LIST
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: LD_INT 54
8779: PUSH
8780: EMPTY
8781: LIST
8782: PUSH
8783: LD_INT 3
8785: PUSH
8786: LD_INT 55
8788: PUSH
8789: EMPTY
8790: LIST
8791: PUSH
8792: LD_INT 3
8794: PUSH
8795: LD_INT 23
8797: PUSH
8798: LD_INT 0
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 51
8807: PUSH
8808: EMPTY
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PUSH
8828: LD_EXP 33
8832: DIFF
8833: PPUSH
8834: LD_EXP 33
8838: PPUSH
8839: CALL_OW 74
8843: ST_TO_ADDR
// InGameOff ;
8844: CALL_OW 9
// if IsLive ( Joan ) and IsLive ( kdo ) then
8848: LD_EXP 33
8852: PPUSH
8853: CALL_OW 300
8857: PUSH
8858: LD_VAR 0 1
8862: PPUSH
8863: CALL_OW 300
8867: AND
8868: IFFALSE 9230
// begin DialogueOn ;
8870: CALL_OW 6
// if kdo = JMM then
8874: LD_VAR 0 1
8878: PUSH
8879: LD_EXP 15
8883: EQUAL
8884: IFFALSE 8960
// begin Say ( kdo , D5b-JMM-1 ) ;
8886: LD_VAR 0 1
8890: PPUSH
8891: LD_STRING D5b-JMM-1
8893: PPUSH
8894: CALL_OW 88
// Say ( Joan , D5b-Joan-1 ) ;
8898: LD_EXP 33
8902: PPUSH
8903: LD_STRING D5b-Joan-1
8905: PPUSH
8906: CALL_OW 88
// Say ( kdo , D5b-JMM-2 ) ;
8910: LD_VAR 0 1
8914: PPUSH
8915: LD_STRING D5b-JMM-2
8917: PPUSH
8918: CALL_OW 88
// Say ( Joan , D5b-Joan-2 ) ;
8922: LD_EXP 33
8926: PPUSH
8927: LD_STRING D5b-Joan-2
8929: PPUSH
8930: CALL_OW 88
// Say ( kdo , D5b-JMM-3 ) ;
8934: LD_VAR 0 1
8938: PPUSH
8939: LD_STRING D5b-JMM-3
8941: PPUSH
8942: CALL_OW 88
// Say ( Joan , D5b-Joan-3 ) ;
8946: LD_EXP 33
8950: PPUSH
8951: LD_STRING D5b-Joan-3
8953: PPUSH
8954: CALL_OW 88
// end else
8958: GO 9230
// begin Say ( kdo , D5a-Sol1-1 ) ;
8960: LD_VAR 0 1
8964: PPUSH
8965: LD_STRING D5a-Sol1-1
8967: PPUSH
8968: CALL_OW 88
// Say ( Joan , D5a-Joan-1 ) ;
8972: LD_EXP 33
8976: PPUSH
8977: LD_STRING D5a-Joan-1
8979: PPUSH
8980: CALL_OW 88
// Say ( kdo , D5a-Sol1-2 ) ;
8984: LD_VAR 0 1
8988: PPUSH
8989: LD_STRING D5a-Sol1-2
8991: PPUSH
8992: CALL_OW 88
// Say ( Joan , D5a-Joan-2 ) ;
8996: LD_EXP 33
9000: PPUSH
9001: LD_STRING D5a-Joan-2
9003: PPUSH
9004: CALL_OW 88
// Say ( kdo , D5a-Sol1-3 ) ;
9008: LD_VAR 0 1
9012: PPUSH
9013: LD_STRING D5a-Sol1-3
9015: PPUSH
9016: CALL_OW 88
// Say ( Joan , D5a-Joan-3 ) ;
9020: LD_EXP 33
9024: PPUSH
9025: LD_STRING D5a-Joan-3
9027: PPUSH
9028: CALL_OW 88
// Say ( kdo , D5a-Sol1-4 ) ;
9032: LD_VAR 0 1
9036: PPUSH
9037: LD_STRING D5a-Sol1-4
9039: PPUSH
9040: CALL_OW 88
// ComMoveUnit ( [ kdo , Joan ] , JMM ) ;
9044: LD_VAR 0 1
9048: PUSH
9049: LD_EXP 33
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: LD_EXP 15
9062: PPUSH
9063: CALL_OW 112
// AddComHold ( [ kdo , Joan ] ) ;
9067: LD_VAR 0 1
9071: PUSH
9072: LD_EXP 33
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PPUSH
9081: CALL_OW 200
// DialogueOff ;
9085: CALL_OW 7
// mytick := tick + 0 0$15 ;
9089: LD_ADDR_VAR 0 3
9093: PUSH
9094: LD_OWVAR 1
9098: PUSH
9099: LD_INT 525
9101: PLUS
9102: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , JMM ) > 5 do
9103: LD_VAR 0 3
9107: PUSH
9108: LD_OWVAR 1
9112: GREATER
9113: PUSH
9114: LD_EXP 33
9118: PPUSH
9119: LD_EXP 15
9123: PPUSH
9124: CALL_OW 296
9128: PUSH
9129: LD_INT 5
9131: GREATER
9132: AND
9133: IFFALSE 9144
// Wait ( 0 0$1 ) ;
9135: LD_INT 35
9137: PPUSH
9138: CALL_OW 67
9142: GO 9103
// DialogueOn ;
9144: CALL_OW 6
// if IsLive ( Joan ) and IsLive ( JMM ) then
9148: LD_EXP 33
9152: PPUSH
9153: CALL_OW 300
9157: PUSH
9158: LD_EXP 15
9162: PPUSH
9163: CALL_OW 300
9167: AND
9168: IFFALSE 9230
// begin Say ( Joan , D5a-Joan-4 ) ;
9170: LD_EXP 33
9174: PPUSH
9175: LD_STRING D5a-Joan-4
9177: PPUSH
9178: CALL_OW 88
// Say ( JMM , D5a-JMM-4 ) ;
9182: LD_EXP 15
9186: PPUSH
9187: LD_STRING D5a-JMM-4
9189: PPUSH
9190: CALL_OW 88
// Say ( Joan , D5a-Joan-5 ) ;
9194: LD_EXP 33
9198: PPUSH
9199: LD_STRING D5a-Joan-5
9201: PPUSH
9202: CALL_OW 88
// Say ( JMM , D5a-JMM-5 ) ;
9206: LD_EXP 15
9210: PPUSH
9211: LD_STRING D5a-JMM-5
9213: PPUSH
9214: CALL_OW 88
// Say ( Joan , D5a-Joan-6 ) ;
9218: LD_EXP 33
9222: PPUSH
9223: LD_STRING D5a-Joan-6
9225: PPUSH
9226: CALL_OW 88
// end ; end ; end ; Dialog6 ;
9230: CALL 9239 0 0
// end ;
9234: LD_VAR 0 2
9238: RET
// function Dialog6 ; begin
9239: LD_INT 0
9241: PPUSH
// if IsLive ( Joan ) then
9242: LD_EXP 33
9246: PPUSH
9247: CALL_OW 300
9251: IFFALSE 9401
// begin ComStop ( [ Joan , JMM ] ) ;
9253: LD_EXP 33
9257: PUSH
9258: LD_EXP 15
9262: PUSH
9263: EMPTY
9264: LIST
9265: LIST
9266: PPUSH
9267: CALL_OW 141
// ComTurnUnit ( JMM , Joan ) ;
9271: LD_EXP 15
9275: PPUSH
9276: LD_EXP 33
9280: PPUSH
9281: CALL_OW 119
// ComTurnUnit ( Joan , JMM ) ;
9285: LD_EXP 33
9289: PPUSH
9290: LD_EXP 15
9294: PPUSH
9295: CALL_OW 119
// AddComHold ( [ JMM , Joan ] ) ;
9299: LD_EXP 15
9303: PUSH
9304: LD_EXP 33
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: PPUSH
9313: CALL_OW 200
// Say ( JMM , D6-JMM-1 ) ;
9317: LD_EXP 15
9321: PPUSH
9322: LD_STRING D6-JMM-1
9324: PPUSH
9325: CALL_OW 88
// Say ( Joan , D6-Joan-1 ) ;
9329: LD_EXP 33
9333: PPUSH
9334: LD_STRING D6-Joan-1
9336: PPUSH
9337: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9341: LD_EXP 15
9345: PPUSH
9346: LD_STRING D6-JMM-2
9348: PPUSH
9349: CALL_OW 88
// Say ( Joan , D6-Joan-2 ) ;
9353: LD_EXP 33
9357: PPUSH
9358: LD_STRING D6-Joan-2
9360: PPUSH
9361: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9365: LD_EXP 15
9369: PPUSH
9370: LD_STRING D6-JMM-3
9372: PPUSH
9373: CALL_OW 88
// Say ( Joan , D6-Joan-3 ) ;
9377: LD_EXP 33
9381: PPUSH
9382: LD_STRING D6-Joan-3
9384: PPUSH
9385: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9389: LD_EXP 15
9393: PPUSH
9394: LD_STRING D6-JMM-4
9396: PPUSH
9397: CALL_OW 88
// end ; DialogueOff ;
9401: CALL_OW 7
// ChangeMissionObjectives ( MJ ) ;
9405: LD_STRING MJ
9407: PPUSH
9408: CALL_OW 337
// SetSide ( Joan , you ) ;
9412: LD_EXP 33
9416: PPUSH
9417: LD_EXP 1
9421: PPUSH
9422: CALL_OW 235
// NormalAttack ( russians , Joan ) ;
9426: LD_EXP 2
9430: PPUSH
9431: LD_EXP 33
9435: PPUSH
9436: CALL_OW 472
// if IsLive ( Lisa ) then
9440: LD_EXP 21
9444: PPUSH
9445: CALL_OW 300
9449: IFFALSE 9459
// act_Lisa_JMM := true ;
9451: LD_ADDR_EXP 58
9455: PUSH
9456: LD_INT 1
9458: ST_TO_ADDR
// DialogInProgress := false ;
9459: LD_ADDR_EXP 52
9463: PUSH
9464: LD_INT 0
9466: ST_TO_ADDR
// end ;
9467: LD_VAR 0 1
9471: RET
// every 1 1$0 trigger act_Lisa_JMM do
9472: LD_EXP 58
9476: IFFALSE 9638
9478: GO 9480
9480: DISABLE
// begin Wait ( 3 3$0 ) ;
9481: LD_INT 6300
9483: PPUSH
9484: CALL_OW 67
// if IsLive ( Joan ) and IsLive ( Lisa ) then
9488: LD_EXP 33
9492: PPUSH
9493: CALL_OW 300
9497: PUSH
9498: LD_EXP 21
9502: PPUSH
9503: CALL_OW 300
9507: AND
9508: IFFALSE 9638
// begin DialogueOn ;
9510: CALL_OW 6
// Say ( Lisa , D7-Lisa-1 ) ;
9514: LD_EXP 21
9518: PPUSH
9519: LD_STRING D7-Lisa-1
9521: PPUSH
9522: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
9526: LD_EXP 15
9530: PPUSH
9531: LD_STRING D7-JMM-1
9533: PPUSH
9534: CALL_OW 88
// Say ( Lisa , D7-Lisa-2 ) ;
9538: LD_EXP 21
9542: PPUSH
9543: LD_STRING D7-Lisa-2
9545: PPUSH
9546: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
9550: LD_EXP 15
9554: PPUSH
9555: LD_STRING D7-JMM-2
9557: PPUSH
9558: CALL_OW 88
// Say ( Lisa , D7-Lisa-3 ) ;
9562: LD_EXP 21
9566: PPUSH
9567: LD_STRING D7-Lisa-3
9569: PPUSH
9570: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
9574: LD_EXP 15
9578: PPUSH
9579: LD_STRING D7-JMM-3
9581: PPUSH
9582: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
9586: LD_EXP 21
9590: PPUSH
9591: LD_STRING D7-Lisa-4
9593: PPUSH
9594: CALL_OW 88
// Say ( JMM , D7-JMM-4 ) ;
9598: LD_EXP 15
9602: PPUSH
9603: LD_STRING D7-JMM-4
9605: PPUSH
9606: CALL_OW 88
// Say ( JMM , D7-JMM-4a ) ;
9610: LD_EXP 15
9614: PPUSH
9615: LD_STRING D7-JMM-4a
9617: PPUSH
9618: CALL_OW 88
// Say ( Lisa , D7-Lisa-5 ) ;
9622: LD_EXP 21
9626: PPUSH
9627: LD_STRING D7-Lisa-5
9629: PPUSH
9630: CALL_OW 88
// DialogueOff ;
9634: CALL_OW 7
// end ; end ;
9638: END
// every 0 0$1.0 trigger Joan_P and not IsLive ( Joan ) do
9639: LD_EXP 48
9643: PUSH
9644: LD_EXP 33
9648: PPUSH
9649: CALL_OW 300
9653: NOT
9654: AND
9655: IFFALSE 9667
9657: GO 9659
9659: DISABLE
// begin ChangeMissionObjectives ( MJa ) ;
9660: LD_STRING MJa
9662: PPUSH
9663: CALL_OW 337
// end ;
9667: END
// every 0 0$10.0 trigger not bojujese and IsOk ( Frank ) and UnitFilter ( apemans , [ f_side , you ] ) do var kdo , kdo2 ;
9668: CALL 13441 0 0
9672: NOT
9673: PUSH
9674: LD_EXP 20
9678: PPUSH
9679: CALL_OW 302
9683: AND
9684: PUSH
9685: LD_EXP 5
9689: PPUSH
9690: LD_INT 22
9692: PUSH
9693: LD_EXP 1
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 72
9706: AND
9707: IFFALSE 10011
9709: GO 9711
9711: DISABLE
9712: LD_INT 0
9714: PPUSH
9715: PPUSH
// begin while DialogInProgress do
9716: LD_EXP 52
9720: IFFALSE 9731
// Wait ( 0 0$5 ) ;
9722: LD_INT 175
9724: PPUSH
9725: CALL_OW 67
9729: GO 9716
// kdo := WhoSayAny ( not_char , you , 0 , 0 , 1 ) ;
9731: LD_ADDR_VAR 0 1
9735: PUSH
9736: LD_EXP 11
9740: PPUSH
9741: LD_EXP 1
9745: PPUSH
9746: LD_INT 0
9748: PPUSH
9749: LD_INT 0
9751: PPUSH
9752: LD_INT 1
9754: PPUSH
9755: CALL 17244 0 5
9759: ST_TO_ADDR
// if not kdo then
9760: LD_VAR 0 1
9764: NOT
9765: IFFALSE 9796
// kdo := WhoSayAny ( TvojiLidi , you , 0 , 0 , 1 ) ;
9767: LD_ADDR_VAR 0 1
9771: PUSH
9772: CALL 13496 0 0
9776: PPUSH
9777: LD_EXP 1
9781: PPUSH
9782: LD_INT 0
9784: PPUSH
9785: LD_INT 0
9787: PPUSH
9788: LD_INT 1
9790: PPUSH
9791: CALL 17244 0 5
9795: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , 0 , 0 , 2 ) ;
9796: LD_ADDR_VAR 0 2
9800: PUSH
9801: LD_EXP 11
9805: PPUSH
9806: LD_EXP 1
9810: PPUSH
9811: LD_INT 0
9813: PPUSH
9814: LD_INT 0
9816: PPUSH
9817: LD_INT 2
9819: PPUSH
9820: CALL 17244 0 5
9824: ST_TO_ADDR
// if not kdo then
9825: LD_VAR 0 1
9829: NOT
9830: IFFALSE 9861
// kdo2 := WhoSayAny ( TvojiLidi , you , 0 , 0 , 2 ) ;
9832: LD_ADDR_VAR 0 2
9836: PUSH
9837: CALL 13496 0 0
9841: PPUSH
9842: LD_EXP 1
9846: PPUSH
9847: LD_INT 0
9849: PPUSH
9850: LD_INT 0
9852: PPUSH
9853: LD_INT 2
9855: PPUSH
9856: CALL 17244 0 5
9860: ST_TO_ADDR
// if IsOk ( Frank ) then
9861: LD_EXP 20
9865: PPUSH
9866: CALL_OW 302
9870: IFFALSE 10011
// begin TalkOn ;
9872: CALL 17132 0 0
// Say ( Frank , D10-Frank-1 ) ;
9876: LD_EXP 20
9880: PPUSH
9881: LD_STRING D10-Frank-1
9883: PPUSH
9884: CALL_OW 88
// if GetSex ( kdo ) = sex_male then
9888: LD_VAR 0 1
9892: PPUSH
9893: CALL_OW 258
9897: PUSH
9898: LD_INT 1
9900: EQUAL
9901: IFFALSE 9917
// Say ( kdo , D10-Sol1-1 ) else
9903: LD_VAR 0 1
9907: PPUSH
9908: LD_STRING D10-Sol1-1
9910: PPUSH
9911: CALL_OW 88
9915: GO 9929
// Say ( kdo , D10-FSol1-1 ) ;
9917: LD_VAR 0 1
9921: PPUSH
9922: LD_STRING D10-FSol1-1
9924: PPUSH
9925: CALL_OW 88
// Say ( Frank , D10-Frank-2 ) ;
9929: LD_EXP 20
9933: PPUSH
9934: LD_STRING D10-Frank-2
9936: PPUSH
9937: CALL_OW 88
// if IsOk ( Lisa ) then
9941: LD_EXP 21
9945: PPUSH
9946: CALL_OW 302
9950: IFFALSE 9966
// Say ( Lisa , D10-Lisa-2 ) else
9952: LD_EXP 21
9956: PPUSH
9957: LD_STRING D10-Lisa-2
9959: PPUSH
9960: CALL_OW 88
9964: GO 10007
// if GetSex ( kdo2 ) = sex_male then
9966: LD_VAR 0 2
9970: PPUSH
9971: CALL_OW 258
9975: PUSH
9976: LD_INT 1
9978: EQUAL
9979: IFFALSE 9995
// Say ( kdo2 , D10-Sol1-2 ) else
9981: LD_VAR 0 2
9985: PPUSH
9986: LD_STRING D10-Sol1-2
9988: PPUSH
9989: CALL_OW 88
9993: GO 10007
// Say ( kdo2 , D10-FSol1-2 ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_STRING D10-FSol1-2
10002: PPUSH
10003: CALL_OW 88
// TalkOff ;
10007: CALL 17148 0 0
// end ; end ;
10011: PPOPN 2
10013: END
// export function Dialog11aa ( kdo ) ; begin
10014: LD_INT 0
10016: PPUSH
// DialogueOn ;
10017: CALL_OW 6
// Say ( kdo , D11a-Sol2-1 ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_STRING D11a-Sol2-1
10028: PPUSH
10029: CALL_OW 88
// WasD11aa := true ;
10033: LD_ADDR_EXP 69
10037: PUSH
10038: LD_INT 1
10040: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10041: LD_INT 35
10043: PPUSH
10044: CALL_OW 67
// DialogueOff ;
10048: CALL_OW 7
// end ;
10052: LD_VAR 0 2
10056: RET
// export function Dialog11ab ( kdo ) ; begin
10057: LD_INT 0
10059: PPUSH
// DialogueOn ;
10060: CALL_OW 6
// Say ( kdo , D11a-FSol2-1 ) ;
10064: LD_VAR 0 1
10068: PPUSH
10069: LD_STRING D11a-FSol2-1
10071: PPUSH
10072: CALL_OW 88
// WasD11ab := true ;
10076: LD_ADDR_EXP 70
10080: PUSH
10081: LD_INT 1
10083: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10084: LD_INT 35
10086: PPUSH
10087: CALL_OW 67
// DialogueOff ;
10091: CALL_OW 7
// end ;
10095: LD_VAR 0 2
10099: RET
// export function Dialog11b ( kdo ) ; begin
10100: LD_INT 0
10102: PPUSH
// DialogueOn ;
10103: CALL_OW 6
// Say ( kdo , D11b-Sol3-1 ) ;
10107: LD_VAR 0 1
10111: PPUSH
10112: LD_STRING D11b-Sol3-1
10114: PPUSH
10115: CALL_OW 88
// Say ( JMM , D11b-JMM-1 ) ;
10119: LD_EXP 15
10123: PPUSH
10124: LD_STRING D11b-JMM-1
10126: PPUSH
10127: CALL_OW 88
// WasD11b := true ;
10131: LD_ADDR_EXP 71
10135: PUSH
10136: LD_INT 1
10138: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10139: LD_INT 35
10141: PPUSH
10142: CALL_OW 67
// DialogueOff ;
10146: CALL_OW 7
// end ;
10150: LD_VAR 0 2
10154: RET
// export function Dialog11c ( kdo ) ; var dep ; begin
10155: LD_INT 0
10157: PPUSH
10158: PPUSH
// DialogueOn ;
10159: CALL_OW 6
// Say ( kdo , D11c-FSol3-1 ) ;
10163: LD_VAR 0 1
10167: PPUSH
10168: LD_STRING D11c-FSol3-1
10170: PPUSH
10171: CALL_OW 88
// dep := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
10175: LD_ADDR_VAR 0 3
10179: PUSH
10180: LD_INT 22
10182: PUSH
10183: LD_EXP 1
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 2
10194: PUSH
10195: LD_INT 30
10197: PUSH
10198: LD_INT 1
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 30
10207: PUSH
10208: LD_INT 0
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: PUSH
10220: EMPTY
10221: LIST
10222: LIST
10223: PPUSH
10224: CALL_OW 69
10228: ST_TO_ADDR
// if dep then
10229: LD_VAR 0 3
10233: IFFALSE 10271
// if GetDistUnits ( kdo , dep [ 1 ] ) > 30 then
10235: LD_VAR 0 1
10239: PPUSH
10240: LD_VAR 0 3
10244: PUSH
10245: LD_INT 1
10247: ARRAY
10248: PPUSH
10249: CALL_OW 296
10253: PUSH
10254: LD_INT 30
10256: GREATER
10257: IFFALSE 10271
// Say ( JMM , D11c-JMM-1 ) ;
10259: LD_EXP 15
10263: PPUSH
10264: LD_STRING D11c-JMM-1
10266: PPUSH
10267: CALL_OW 88
// WasD11c := true ;
10271: LD_ADDR_EXP 72
10275: PUSH
10276: LD_INT 1
10278: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10279: LD_INT 35
10281: PPUSH
10282: CALL_OW 67
// DialogueOff ;
10286: CALL_OW 7
// end ;
10290: LD_VAR 0 2
10294: RET
// export function Dialog11d ( kdo ) ; begin
10295: LD_INT 0
10297: PPUSH
// DialogueOn ;
10298: CALL_OW 6
// Say ( kdo , D11d-Sol4-1 ) ;
10302: LD_VAR 0 1
10306: PPUSH
10307: LD_STRING D11d-Sol4-1
10309: PPUSH
10310: CALL_OW 88
// Say ( JMM , D11d-JMM-1 ) ;
10314: LD_EXP 15
10318: PPUSH
10319: LD_STRING D11d-JMM-1
10321: PPUSH
10322: CALL_OW 88
// WasD11d := true ;
10326: LD_ADDR_EXP 73
10330: PUSH
10331: LD_INT 1
10333: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10334: LD_INT 35
10336: PPUSH
10337: CALL_OW 67
// DialogueOff ;
10341: CALL_OW 7
// end ;
10345: LD_VAR 0 2
10349: RET
// export function Dialog11e ( kdo ) ; begin
10350: LD_INT 0
10352: PPUSH
// DialogueOn ;
10353: CALL_OW 6
// Say ( kdo , D11e-FSol4-1 ) ;
10357: LD_VAR 0 1
10361: PPUSH
10362: LD_STRING D11e-FSol4-1
10364: PPUSH
10365: CALL_OW 88
// WasD11e := true ;
10369: LD_ADDR_EXP 74
10373: PUSH
10374: LD_INT 1
10376: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10377: LD_INT 35
10379: PPUSH
10380: CALL_OW 67
// DialogueOff ;
10384: CALL_OW 7
// end ;
10388: LD_VAR 0 2
10392: RET
// export function Dialog11f ( kdo ) ; begin
10393: LD_INT 0
10395: PPUSH
// DialogueOn ;
10396: CALL_OW 6
// Say ( kdo , D11f-Sol5-1 ) ;
10400: LD_VAR 0 1
10404: PPUSH
10405: LD_STRING D11f-Sol5-1
10407: PPUSH
10408: CALL_OW 88
// WasD11f := true ;
10412: LD_ADDR_EXP 75
10416: PUSH
10417: LD_INT 1
10419: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10420: LD_INT 35
10422: PPUSH
10423: CALL_OW 67
// DialogueOff ;
10427: CALL_OW 7
// end ;
10431: LD_VAR 0 2
10435: RET
// every 0 0$3 trigger FilterAllUnits ( [ [ f_control , control_remote ] ] ) and not FilterAllUnits ( [ [ f_btype , b_control_tower ] ] ) do var a ;
10436: LD_INT 33
10438: PUSH
10439: LD_INT 2
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: PUSH
10446: EMPTY
10447: LIST
10448: PPUSH
10449: CALL_OW 69
10453: PUSH
10454: LD_INT 30
10456: PUSH
10457: LD_INT 36
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: PPUSH
10467: CALL_OW 69
10471: NOT
10472: AND
10473: IFFALSE 10586
10475: GO 10477
10477: DISABLE
10478: LD_INT 0
10480: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10481: LD_ADDR_VAR 0 1
10485: PUSH
10486: LD_EXP 11
10490: PPUSH
10491: LD_EXP 1
10495: PPUSH
10496: LD_INT 0
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 0
10504: PPUSH
10505: CALL 17244 0 5
10509: ST_TO_ADDR
// TalkOn ;
10510: CALL 17132 0 0
// if a then
10514: LD_VAR 0 1
10518: IFFALSE 10575
// if not SayAny ( a , D3a-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10520: LD_VAR 0 1
10524: PPUSH
10525: LD_STRING D3a-Mech1-1
10527: PPUSH
10528: LD_EXP 1
10532: PPUSH
10533: LD_INT 1
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: LD_INT 0
10541: PPUSH
10542: CALL 17164 0 6
10546: NOT
10547: IFFALSE 10575
// SayAny ( a , D3a-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10549: LD_VAR 0 1
10553: PPUSH
10554: LD_STRING D3a-FMech1-1
10556: PPUSH
10557: LD_EXP 1
10561: PPUSH
10562: LD_INT 2
10564: PPUSH
10565: LD_INT 3
10567: PPUSH
10568: LD_INT 0
10570: PPUSH
10571: CALL 17164 0 6
// TalkOff ;
10575: CALL 17148 0 0
// MyHint ( Linking ) ;
10579: LD_STRING Linking
10581: PPUSH
10582: CALL 17607 0 1
// end ;
10586: PPOPN 1
10588: END
// every 0 0$3 trigger not FilterAllUnits ( [ f_control , control_remote ] ) and maj_ct do var a ;
10589: LD_INT 33
10591: PUSH
10592: LD_INT 2
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: PPUSH
10599: CALL_OW 69
10603: NOT
10604: PUSH
10605: LD_EXP 94
10609: AND
10610: IFFALSE 10723
10612: GO 10614
10614: DISABLE
10615: LD_INT 0
10617: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10618: LD_ADDR_VAR 0 1
10622: PUSH
10623: LD_EXP 11
10627: PPUSH
10628: LD_EXP 1
10632: PPUSH
10633: LD_INT 0
10635: PPUSH
10636: LD_INT 3
10638: PPUSH
10639: LD_INT 0
10641: PPUSH
10642: CALL 17244 0 5
10646: ST_TO_ADDR
// TalkOn ;
10647: CALL 17132 0 0
// if a then
10651: LD_VAR 0 1
10655: IFFALSE 10712
// if not SayAny ( a , D3b-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10657: LD_VAR 0 1
10661: PPUSH
10662: LD_STRING D3b-Mech1-1
10664: PPUSH
10665: LD_EXP 1
10669: PPUSH
10670: LD_INT 1
10672: PPUSH
10673: LD_INT 3
10675: PPUSH
10676: LD_INT 0
10678: PPUSH
10679: CALL 17164 0 6
10683: NOT
10684: IFFALSE 10712
// SayAny ( a , D3b-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10686: LD_VAR 0 1
10690: PPUSH
10691: LD_STRING D3b-FMech1-1
10693: PPUSH
10694: LD_EXP 1
10698: PPUSH
10699: LD_INT 2
10701: PPUSH
10702: LD_INT 3
10704: PPUSH
10705: LD_INT 0
10707: PPUSH
10708: CALL 17164 0 6
// TalkOff ;
10712: CALL 17148 0 0
// MyHint ( Linking ) ;
10716: LD_STRING Linking
10718: PPUSH
10719: CALL 17607 0 1
// end ;
10723: PPOPN 1
10725: END
// every 0 0$3 do var who , i ;
10726: GO 10728
10728: DISABLE
10729: LD_INT 0
10731: PPUSH
10732: PPUSH
// begin who := [ ] ;
10733: LD_ADDR_VAR 0 1
10737: PUSH
10738: EMPTY
10739: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_btype , b_control_tower ] ) do
10740: LD_ADDR_VAR 0 2
10744: PUSH
10745: LD_INT 30
10747: PUSH
10748: LD_INT 36
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: PPUSH
10755: CALL_OW 69
10759: PUSH
10760: FOR_IN
10761: IFFALSE 10801
// who := who ^ UnitFilter ( UnitsInside ( i ) , [ f_class , class_mechanic ] ) ;
10763: LD_ADDR_VAR 0 1
10767: PUSH
10768: LD_VAR 0 1
10772: PUSH
10773: LD_VAR 0 2
10777: PPUSH
10778: CALL_OW 313
10782: PPUSH
10783: LD_INT 25
10785: PUSH
10786: LD_INT 3
10788: PUSH
10789: EMPTY
10790: LIST
10791: LIST
10792: PPUSH
10793: CALL_OW 72
10797: ADD
10798: ST_TO_ADDR
10799: GO 10760
10801: POP
10802: POP
// if FilterAllUnits ( [ f_control , control_remote ] ) and who then
10803: LD_INT 33
10805: PUSH
10806: LD_INT 2
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PPUSH
10813: CALL_OW 69
10817: PUSH
10818: LD_VAR 0 1
10822: AND
10823: IFFALSE 10935
// begin TalkOn ;
10825: CALL 17132 0 0
// who := who [ 1 ] ;
10829: LD_ADDR_VAR 0 1
10833: PUSH
10834: LD_VAR 0 1
10838: PUSH
10839: LD_INT 1
10841: ARRAY
10842: ST_TO_ADDR
// if JMM in who then
10843: LD_EXP 15
10847: PUSH
10848: LD_VAR 0 1
10852: IN
10853: IFFALSE 10869
// Say ( JMM , D4a-JMM-1 ) else
10855: LD_EXP 15
10859: PPUSH
10860: LD_STRING D4a-JMM-1
10862: PPUSH
10863: CALL_OW 88
10867: GO 10914
// begin if GetSex ( who [ 1 ] ) = sex_male then
10869: LD_VAR 0 1
10873: PUSH
10874: LD_INT 1
10876: ARRAY
10877: PPUSH
10878: CALL_OW 258
10882: PUSH
10883: LD_INT 1
10885: EQUAL
10886: IFFALSE 10902
// Say ( who , D4a-Mech1-1 ) else
10888: LD_VAR 0 1
10892: PPUSH
10893: LD_STRING D4a-Mech1-1
10895: PPUSH
10896: CALL_OW 88
10900: GO 10914
// Say ( who , D4a-FMech1-1 ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_STRING D4a-FMech1-1
10909: PPUSH
10910: CALL_OW 88
// end ; remote_tried := true ;
10914: LD_ADDR_EXP 82
10918: PUSH
10919: LD_INT 1
10921: ST_TO_ADDR
// TalkOff ;
10922: CALL 17148 0 0
// MyHint ( Linking ) ;
10926: LD_STRING Linking
10928: PPUSH
10929: CALL 17607 0 1
// end else
10933: GO 10936
// enable ;
10935: ENABLE
// end ;
10936: PPOPN 2
10938: END
// every 0 0$3 do var who , facts , rems , ok , i , j ;
10939: GO 10941
10941: DISABLE
10942: LD_INT 0
10944: PPUSH
10945: PPUSH
10946: PPUSH
10947: PPUSH
10948: PPUSH
10949: PPUSH
// begin who := [ ] ;
10950: LD_ADDR_VAR 0 1
10954: PUSH
10955: EMPTY
10956: ST_TO_ADDR
// facts := FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_factory ] ] ) ;
10957: LD_ADDR_VAR 0 2
10961: PUSH
10962: LD_INT 22
10964: PUSH
10965: LD_EXP 1
10969: PUSH
10970: EMPTY
10971: LIST
10972: LIST
10973: PUSH
10974: LD_INT 30
10976: PUSH
10977: LD_INT 3
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: PPUSH
10988: CALL_OW 69
10992: ST_TO_ADDR
// rems := FilterAllUnits ( [ f_control , control_remote ] ) ;
10993: LD_ADDR_VAR 0 3
10997: PUSH
10998: LD_INT 33
11000: PUSH
11001: LD_INT 2
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: ST_TO_ADDR
// for i in facts do
11013: LD_ADDR_VAR 0 5
11017: PUSH
11018: LD_VAR 0 2
11022: PUSH
11023: FOR_IN
11024: IFFALSE 11075
// for j in rems do
11026: LD_ADDR_VAR 0 6
11030: PUSH
11031: LD_VAR 0 3
11035: PUSH
11036: FOR_IN
11037: IFFALSE 11071
// if GetDistUnits ( i , j ) > 9 then
11039: LD_VAR 0 5
11043: PPUSH
11044: LD_VAR 0 6
11048: PPUSH
11049: CALL_OW 296
11053: PUSH
11054: LD_INT 9
11056: GREATER
11057: IFFALSE 11069
// ok := j ;
11059: LD_ADDR_VAR 0 4
11063: PUSH
11064: LD_VAR 0 6
11068: ST_TO_ADDR
11069: GO 11036
11071: POP
11072: POP
11073: GO 11023
11075: POP
11076: POP
// if ok then
11077: LD_VAR 0 4
11081: IFFALSE 11186
// begin TalkOn ;
11083: CALL 17132 0 0
// who := IsControledBy ( ok ) ;
11087: LD_ADDR_VAR 0 1
11091: PUSH
11092: LD_VAR 0 4
11096: PPUSH
11097: CALL_OW 312
11101: ST_TO_ADDR
// if JMM in who then
11102: LD_EXP 15
11106: PUSH
11107: LD_VAR 0 1
11111: IN
11112: IFFALSE 11128
// Say ( JMM , D4b-JMM-1 ) else
11114: LD_EXP 15
11118: PPUSH
11119: LD_STRING D4b-JMM-1
11121: PPUSH
11122: CALL_OW 88
11126: GO 11173
// begin if GetSex ( who [ 1 ] ) = sex_male then
11128: LD_VAR 0 1
11132: PUSH
11133: LD_INT 1
11135: ARRAY
11136: PPUSH
11137: CALL_OW 258
11141: PUSH
11142: LD_INT 1
11144: EQUAL
11145: IFFALSE 11161
// Say ( who , D4b-Mech1-1 ) else
11147: LD_VAR 0 1
11151: PPUSH
11152: LD_STRING D4b-Mech1-1
11154: PPUSH
11155: CALL_OW 88
11159: GO 11173
// Say ( who , D4b-FMech1-1 ) ;
11161: LD_VAR 0 1
11165: PPUSH
11166: LD_STRING D4b-FMech1-1
11168: PPUSH
11169: CALL_OW 88
// end ; TalkOff ;
11173: CALL 17148 0 0
// MyHint ( RemoteControlling ) ;
11177: LD_STRING RemoteControlling
11179: PPUSH
11180: CALL 17607 0 1
// end else
11184: GO 11187
// enable ;
11186: ENABLE
// end ;
11187: PPOPN 6
11189: END
// every 4 4$30 do
11190: GO 11192
11192: DISABLE
// begin TalkOn ;
11193: CALL 17132 0 0
// SayRadio ( RadioSci , D12a-Sci-1 ) ;
11197: LD_EXP 17
11201: PPUSH
11202: LD_STRING D12a-Sci-1
11204: PPUSH
11205: CALL_OW 94
// Say ( JMM , D12a-JMM-1 ) ;
11209: LD_EXP 15
11213: PPUSH
11214: LD_STRING D12a-JMM-1
11216: PPUSH
11217: CALL_OW 88
// TalkOff ;
11221: CALL 17148 0 0
// end ;
11225: END
// every 14 14$0 do
11226: GO 11228
11228: DISABLE
// begin TalkOn ;
11229: CALL 17132 0 0
// SayRadio ( RadioSci , D12b-Sci-1 ) ;
11233: LD_EXP 17
11237: PPUSH
11238: LD_STRING D12b-Sci-1
11240: PPUSH
11241: CALL_OW 94
// TalkOff ;
11245: CALL 17148 0 0
// end ;
11249: END
// every 16 16$0 do
11250: GO 11252
11252: DISABLE
// begin TalkOn ;
11253: CALL 17132 0 0
// SayRadio ( RadioSci , D12c-Sci-1 ) ;
11257: LD_EXP 17
11261: PPUSH
11262: LD_STRING D12c-Sci-1
11264: PPUSH
11265: CALL_OW 94
// TalkOff ;
11269: CALL 17148 0 0
// end ;
11273: END
// every 34 34$0 do
11274: GO 11276
11276: DISABLE
// begin TalkOn ;
11277: CALL 17132 0 0
// SayRadio ( RadioSci , D12d-Sci-1 ) ;
11281: LD_EXP 17
11285: PPUSH
11286: LD_STRING D12d-Sci-1
11288: PPUSH
11289: CALL_OW 94
// TalkOff ;
11293: CALL 17148 0 0
// end ;
11297: END
// every 46 46$0 do
11298: GO 11300
11300: DISABLE
// begin TalkOn ;
11301: CALL 17132 0 0
// SayRadio ( RadioSci , D12e-Sci-1 ) ;
11305: LD_EXP 17
11309: PPUSH
11310: LD_STRING D12e-Sci-1
11312: PPUSH
11313: CALL_OW 94
// Say ( JMM , D12e-JMM-1 ) ;
11317: LD_EXP 15
11321: PPUSH
11322: LD_STRING D12e-JMM-1
11324: PPUSH
11325: CALL_OW 88
// TalkOff ;
11329: CALL 17148 0 0
// end ;
11333: END
// on DestinationUnreachable ( unit ) do begin if unit = Kurt then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 43
11343: EQUAL
11344: IFFALSE 11358
// begin ComMoveToArea ( Kurt , border ) ;
11346: LD_EXP 43
11350: PPUSH
11351: LD_INT 10
11353: PPUSH
11354: CALL_OW 113
// end ; end ; end_of_file
11358: PPOPN 1
11360: END
// var objevovani_zasilek ; every 0 0$0.1 do
11361: GO 11363
11363: DISABLE
// begin objevovani_zasilek := [ [ 4 , 3 , 7 , 2 , 0 , 2 , 5 , 3 , 1 , 1 ] , [ 4 , 4 , 8 , 2 , 0 , 2 , 5 , 4 , 2 , 1 ] , [ 4 , 3 , 8 , 1 , 0 , 2 , 6 , 5 , 3 , 1 ] ] [ difficulty ] ;
11364: LD_ADDR_LOC 1
11368: PUSH
11369: LD_INT 4
11371: PUSH
11372: LD_INT 3
11374: PUSH
11375: LD_INT 7
11377: PUSH
11378: LD_INT 2
11380: PUSH
11381: LD_INT 0
11383: PUSH
11384: LD_INT 2
11386: PUSH
11387: LD_INT 5
11389: PUSH
11390: LD_INT 3
11392: PUSH
11393: LD_INT 1
11395: PUSH
11396: LD_INT 1
11398: PUSH
11399: EMPTY
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 4
11413: PUSH
11414: LD_INT 4
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: LD_INT 0
11425: PUSH
11426: LD_INT 2
11428: PUSH
11429: LD_INT 5
11431: PUSH
11432: LD_INT 4
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: LD_INT 1
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 4
11455: PUSH
11456: LD_INT 3
11458: PUSH
11459: LD_INT 8
11461: PUSH
11462: LD_INT 1
11464: PUSH
11465: LD_INT 0
11467: PUSH
11468: LD_INT 2
11470: PUSH
11471: LD_INT 6
11473: PUSH
11474: LD_INT 5
11476: PUSH
11477: LD_INT 3
11479: PUSH
11480: LD_INT 1
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: LIST
11499: PUSH
11500: LD_OWVAR 67
11504: ARRAY
11505: ST_TO_ADDR
// Randomize ;
11506: CALL_OW 10
// end ;
11510: END
// every 0 0$10 do
11511: GO 11513
11513: DISABLE
// begin Randomize ;
11514: CALL_OW 10
// enable ;
11518: ENABLE
// end ;
11519: END
// every 0 0$1 trigger start_game do
11520: LD_EXP 55
11524: IFFALSE 11568
11526: GO 11528
11528: DISABLE
// begin Wait ( Rand ( 0 0$10 , 0 0$25 ) ) ;
11529: LD_INT 350
11531: PPUSH
11532: LD_INT 875
11534: PPUSH
11535: CALL_OW 12
11539: PPUSH
11540: CALL_OW 67
// CreateCratesArea ( 5 , first_crate , true ) ;
11544: LD_INT 5
11546: PPUSH
11547: LD_INT 3
11549: PPUSH
11550: LD_INT 1
11552: PPUSH
11553: CALL_OW 55
// wait ( 0 0$5 ) ;
11557: LD_INT 175
11559: PPUSH
11560: CALL_OW 67
// DialogR0 ;
11564: CALL 5871 0 0
// end ;
11568: END
// every 0 0$15 do
11569: GO 11571
11571: DISABLE
// begin bum_bedny ;
11572: CALL 11586 0 0
// end ;
11576: END
// every 5 5$0 + 0 0$20 marked 567 do
11577: GO 11579
11579: DISABLE
// begin enable ;
11580: ENABLE
// bum_bedny ;
11581: CALL 11586 0 0
// end ;
11585: END
// function bum_bedny ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
11586: LD_INT 0
11588: PPUSH
11589: PPUSH
11590: PPUSH
11591: PPUSH
11592: PPUSH
11593: PPUSH
11594: PPUSH
11595: PPUSH
11596: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
11597: LD_ADDR_VAR 0 9
11601: PUSH
11602: LD_OWVAR 1
11606: PUSH
11607: LD_INT 10500
11609: DIV
11610: PUSH
11611: LD_INT 1
11613: PLUS
11614: ST_TO_ADDR
// cek := [ ] ;
11615: LD_ADDR_VAR 0 6
11619: PUSH
11620: EMPTY
11621: ST_TO_ADDR
// cek2 := [ ] ;
11622: LD_ADDR_VAR 0 7
11626: PUSH
11627: EMPTY
11628: ST_TO_ADDR
// last := 0 ;
11629: LD_ADDR_VAR 0 8
11633: PUSH
11634: LD_INT 0
11636: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_LOC 1
11646: PUSH
11647: LD_VAR 0 9
11651: ARRAY
11652: ST_TO_ADDR
// for i := 1 to x * 2 do
11653: LD_ADDR_VAR 0 4
11657: PUSH
11658: DOUBLE
11659: LD_INT 1
11661: DEC
11662: ST_TO_ADDR
11663: LD_VAR 0 2
11667: PUSH
11668: LD_INT 2
11670: MUL
11671: PUSH
11672: FOR_TO
11673: IFFALSE 11699
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
11675: LD_ADDR_VAR 0 6
11679: PUSH
11680: LD_VAR 0 6
11684: PUSH
11685: LD_INT 525
11687: PPUSH
11688: LD_INT 10500
11690: PPUSH
11691: CALL_OW 12
11695: ADD
11696: ST_TO_ADDR
11697: GO 11672
11699: POP
11700: POP
// cek := SortListByListAsc ( cek , cek ) ;
11701: LD_ADDR_VAR 0 6
11705: PUSH
11706: LD_VAR 0 6
11710: PPUSH
11711: LD_VAR 0 6
11715: PPUSH
11716: CALL_OW 76
11720: ST_TO_ADDR
// for i in cek do
11721: LD_ADDR_VAR 0 4
11725: PUSH
11726: LD_VAR 0 6
11730: PUSH
11731: FOR_IN
11732: IFFALSE 11768
// begin cek2 := cek2 ^ i - last ;
11734: LD_ADDR_VAR 0 7
11738: PUSH
11739: LD_VAR 0 7
11743: PUSH
11744: LD_VAR 0 4
11748: PUSH
11749: LD_VAR 0 8
11753: MINUS
11754: ADD
11755: ST_TO_ADDR
// last := i ;
11756: LD_ADDR_VAR 0 8
11760: PUSH
11761: LD_VAR 0 4
11765: ST_TO_ADDR
// end ;
11766: GO 11731
11768: POP
11769: POP
// for i := 1 to x do
11770: LD_ADDR_VAR 0 4
11774: PUSH
11775: DOUBLE
11776: LD_INT 1
11778: DEC
11779: ST_TO_ADDR
11780: LD_VAR 0 2
11784: PUSH
11785: FOR_TO
11786: IFFALSE 12015
// begin hex := RandHexArea ( bottom_bigger , false ) ;
11788: LD_ADDR_VAR 0 5
11792: PUSH
11793: LD_INT 8
11795: PPUSH
11796: LD_INT 0
11798: PPUSH
11799: CALL_OW 16
11803: ST_TO_ADDR
// crates := crates ^ [ hex ] ;
11804: LD_ADDR_EXP 76
11808: PUSH
11809: LD_EXP 76
11813: PUSH
11814: LD_VAR 0 5
11818: PUSH
11819: EMPTY
11820: LIST
11821: ADD
11822: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11823: LD_INT 5
11825: PPUSH
11826: LD_VAR 0 5
11830: PUSH
11831: LD_INT 1
11833: ARRAY
11834: PPUSH
11835: LD_VAR 0 5
11839: PUSH
11840: LD_INT 2
11842: ARRAY
11843: PPUSH
11844: LD_INT 1
11846: PPUSH
11847: CALL_OW 54
// Wait ( cek2 [ i * 2 - 1 ] ) ;
11851: LD_VAR 0 7
11855: PUSH
11856: LD_VAR 0 4
11860: PUSH
11861: LD_INT 2
11863: MUL
11864: PUSH
11865: LD_INT 1
11867: MINUS
11868: ARRAY
11869: PPUSH
11870: CALL_OW 67
// hex := RandHexArea ( top_bigger , false ) ;
11874: LD_ADDR_VAR 0 5
11878: PUSH
11879: LD_INT 7
11881: PPUSH
11882: LD_INT 0
11884: PPUSH
11885: CALL_OW 16
11889: ST_TO_ADDR
// if more_scouting then
11890: LD_EXP 61
11894: IFFALSE 11915
// crates := crates ^ [ hex ] ;
11896: LD_ADDR_EXP 76
11900: PUSH
11901: LD_EXP 76
11905: PUSH
11906: LD_VAR 0 5
11910: PUSH
11911: EMPTY
11912: LIST
11913: ADD
11914: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11915: LD_INT 5
11917: PPUSH
11918: LD_VAR 0 5
11922: PUSH
11923: LD_INT 1
11925: ARRAY
11926: PPUSH
11927: LD_VAR 0 5
11931: PUSH
11932: LD_INT 2
11934: ARRAY
11935: PPUSH
11936: LD_INT 1
11938: PPUSH
11939: CALL_OW 54
// if not was_dialogR0 and GetDistUnitXY ( JMM , hex [ 1 ] , hex [ 2 ] ) > 30 then
11943: LD_EXP 87
11947: NOT
11948: PUSH
11949: LD_EXP 15
11953: PPUSH
11954: LD_VAR 0 5
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: LD_VAR 0 5
11967: PUSH
11968: LD_INT 2
11970: ARRAY
11971: PPUSH
11972: CALL_OW 297
11976: PUSH
11977: LD_INT 30
11979: GREATER
11980: AND
11981: IFFALSE 11994
// begin wait ( 0 0$6 ) ;
11983: LD_INT 210
11985: PPUSH
11986: CALL_OW 67
// DialogR0 ;
11990: CALL 5871 0 0
// end ; Wait ( cek2 [ i * 2 ] ) ;
11994: LD_VAR 0 7
11998: PUSH
11999: LD_VAR 0 4
12003: PUSH
12004: LD_INT 2
12006: MUL
12007: ARRAY
12008: PPUSH
12009: CALL_OW 67
// end ;
12013: GO 11785
12015: POP
12016: POP
// if min5 = ( objevovani_zasilek + 0 ) then
12017: LD_VAR 0 9
12021: PUSH
12022: LD_LOC 1
12026: PUSH
12027: LD_INT 0
12029: PLUS
12030: EQUAL
12031: IFFALSE 12036
// disable ( 567 ) ;
12033: LD_INT 567
12035: DISABLE_MARKED
// end ;
12036: LD_VAR 0 1
12040: RET
// every 5 5$0 + 5 5$20 trigger start_game do var a , un , counter , h ;
12041: LD_EXP 55
12045: IFFALSE 12856
12047: GO 12049
12049: DISABLE
12050: LD_INT 0
12052: PPUSH
12053: PPUSH
12054: PPUSH
12055: PPUSH
// begin a := prilet_rusaci union prilet_tvoji ;
12056: LD_ADDR_VAR 0 1
12060: PUSH
12061: LD_EXP 7
12065: PUSH
12066: LD_EXP 6
12070: UNION
12071: ST_TO_ADDR
// if a then
12072: LD_VAR 0 1
12076: IFFALSE 12856
// begin un := a [ Rand ( 1 , ( a + 0 ) ) ] ;
12078: LD_ADDR_VAR 0 2
12082: PUSH
12083: LD_VAR 0 1
12087: PUSH
12088: LD_INT 1
12090: PPUSH
12091: LD_VAR 0 1
12095: PUSH
12096: LD_INT 0
12098: PLUS
12099: PPUSH
12100: CALL_OW 12
12104: ARRAY
12105: ST_TO_ADDR
// if prilet_tvoji = 2 and Getside ( un ) = you then
12106: LD_EXP 6
12110: PUSH
12111: LD_INT 2
12113: EQUAL
12114: PUSH
12115: LD_VAR 0 2
12119: PPUSH
12120: CALL_OW 255
12124: PUSH
12125: LD_EXP 1
12129: EQUAL
12130: AND
12131: IFFALSE 12150
// begin PlaceUnitArea ( un , lidi_base , true ) ;
12133: LD_VAR 0 2
12137: PPUSH
12138: LD_INT 15
12140: PPUSH
12141: LD_INT 1
12143: PPUSH
12144: CALL_OW 49
// end else
12148: GO 12478
// begin if Rand ( 1 , 2 ) = 1 then
12150: LD_INT 1
12152: PPUSH
12153: LD_INT 2
12155: PPUSH
12156: CALL_OW 12
12160: PUSH
12161: LD_INT 1
12163: EQUAL
12164: IFFALSE 12323
// begin counter := 0 ;
12166: LD_ADDR_VAR 0 3
12170: PUSH
12171: LD_INT 0
12173: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_bottom , false ) ;
12174: LD_ADDR_VAR 0 4
12178: PUSH
12179: LD_INT 14
12181: PPUSH
12182: LD_INT 0
12184: PPUSH
12185: CALL_OW 16
12189: ST_TO_ADDR
// counter := counter + 1 ;
12190: LD_ADDR_VAR 0 3
12194: PUSH
12195: LD_VAR 0 3
12199: PUSH
12200: LD_INT 1
12202: PLUS
12203: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12204: LD_VAR 0 2
12208: PPUSH
12209: CALL_OW 255
12213: PUSH
12214: LD_EXP 2
12218: EQUAL
12219: PUSH
12220: LD_VAR 0 3
12224: PUSH
12225: LD_INT 200
12227: GREATER
12228: OR
12229: PUSH
12230: LD_EXP 2
12234: PPUSH
12235: LD_VAR 0 4
12239: PUSH
12240: LD_INT 1
12242: ARRAY
12243: PPUSH
12244: LD_VAR 0 4
12248: PUSH
12249: LD_INT 2
12251: ARRAY
12252: PPUSH
12253: CALL_OW 293
12257: NOT
12258: OR
12259: IFFALSE 12174
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12261: LD_VAR 0 2
12265: PPUSH
12266: LD_VAR 0 4
12270: PUSH
12271: LD_INT 1
12273: ARRAY
12274: PPUSH
12275: LD_VAR 0 4
12279: PUSH
12280: LD_INT 2
12282: ARRAY
12283: PPUSH
12284: LD_INT 1
12286: PPUSH
12287: CALL_OW 48
12291: PUSH
12292: LD_VAR 0 3
12296: PUSH
12297: LD_INT 200
12299: GREATER
12300: OR
12301: IFFALSE 12174
// if counter > 200 then
12303: LD_VAR 0 3
12307: PUSH
12308: LD_INT 200
12310: GREATER
12311: IFFALSE 12321
// un := 0 ;
12313: LD_ADDR_VAR 0 2
12317: PUSH
12318: LD_INT 0
12320: ST_TO_ADDR
// end else
12321: GO 12478
// begin counter := 0 ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_INT 0
12330: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_top , false ) ;
12331: LD_ADDR_VAR 0 4
12335: PUSH
12336: LD_INT 17
12338: PPUSH
12339: LD_INT 0
12341: PPUSH
12342: CALL_OW 16
12346: ST_TO_ADDR
// counter := counter + 1 ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: LD_VAR 0 3
12356: PUSH
12357: LD_INT 1
12359: PLUS
12360: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12361: LD_VAR 0 2
12365: PPUSH
12366: CALL_OW 255
12370: PUSH
12371: LD_EXP 2
12375: EQUAL
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: LD_INT 200
12384: GREATER
12385: OR
12386: PUSH
12387: LD_EXP 2
12391: PPUSH
12392: LD_VAR 0 4
12396: PUSH
12397: LD_INT 1
12399: ARRAY
12400: PPUSH
12401: LD_VAR 0 4
12405: PUSH
12406: LD_INT 2
12408: ARRAY
12409: PPUSH
12410: CALL_OW 293
12414: NOT
12415: OR
12416: IFFALSE 12331
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12418: LD_VAR 0 2
12422: PPUSH
12423: LD_VAR 0 4
12427: PUSH
12428: LD_INT 1
12430: ARRAY
12431: PPUSH
12432: LD_VAR 0 4
12436: PUSH
12437: LD_INT 2
12439: ARRAY
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: CALL_OW 48
12448: PUSH
12449: LD_VAR 0 3
12453: PUSH
12454: LD_INT 200
12456: GREATER
12457: OR
12458: IFFALSE 12331
// if counter > 200 then
12460: LD_VAR 0 3
12464: PUSH
12465: LD_INT 200
12467: GREATER
12468: IFFALSE 12478
// un := 0 ;
12470: LD_ADDR_VAR 0 2
12474: PUSH
12475: LD_INT 0
12477: ST_TO_ADDR
// end ; end ; Wait ( 0 0$4 ) ;
12478: LD_INT 140
12480: PPUSH
12481: CALL_OW 67
// if un in prilet_rusaci then
12485: LD_VAR 0 2
12489: PUSH
12490: LD_EXP 7
12494: IN
12495: IFFALSE 12659
// begin prilet_rusaci := prilet_rusaci diff un ;
12497: LD_ADDR_EXP 7
12501: PUSH
12502: LD_EXP 7
12506: PUSH
12507: LD_VAR 0 2
12511: DIFF
12512: ST_TO_ADDR
// ComWait ( un , 0 0$3 ) ;
12513: LD_VAR 0 2
12517: PPUSH
12518: LD_INT 105
12520: PPUSH
12521: CALL_OW 142
// AddComMoveXY ( un , 122 , 84 ) ;
12525: LD_VAR 0 2
12529: PPUSH
12530: LD_INT 122
12532: PPUSH
12533: LD_INT 84
12535: PPUSH
12536: CALL_OW 171
// case GetClass ( un ) of class_soldier :
12540: LD_VAR 0 2
12544: PPUSH
12545: CALL_OW 257
12549: PUSH
12550: LD_INT 1
12552: DOUBLE
12553: EQUAL
12554: IFTRUE 12558
12556: GO 12577
12558: POP
// sol := sol ^ un ; class_engineer :
12559: LD_ADDR_EXP 90
12563: PUSH
12564: LD_EXP 90
12568: PUSH
12569: LD_VAR 0 2
12573: ADD
12574: ST_TO_ADDR
12575: GO 12659
12577: LD_INT 2
12579: DOUBLE
12580: EQUAL
12581: IFTRUE 12585
12583: GO 12604
12585: POP
// eng := eng ^ un ; class_scientistic :
12586: LD_ADDR_EXP 93
12590: PUSH
12591: LD_EXP 93
12595: PUSH
12596: LD_VAR 0 2
12600: ADD
12601: ST_TO_ADDR
12602: GO 12659
12604: LD_INT 4
12606: DOUBLE
12607: EQUAL
12608: IFTRUE 12612
12610: GO 12631
12612: POP
// sci := sci ^ un ; class_mechanic :
12613: LD_ADDR_EXP 91
12617: PUSH
12618: LD_EXP 91
12622: PUSH
12623: LD_VAR 0 2
12627: ADD
12628: ST_TO_ADDR
12629: GO 12659
12631: LD_INT 3
12633: DOUBLE
12634: EQUAL
12635: IFTRUE 12639
12637: GO 12658
12639: POP
// mec := mec ^ un ; end ;
12640: LD_ADDR_EXP 92
12644: PUSH
12645: LD_EXP 92
12649: PUSH
12650: LD_VAR 0 2
12654: ADD
12655: ST_TO_ADDR
12656: GO 12659
12658: POP
// end ; if un in prilet_tvoji then
12659: LD_VAR 0 2
12663: PUSH
12664: LD_EXP 6
12668: IN
12669: IFFALSE 12855
// begin prilet_tvoji := prilet_tvoji diff un ;
12671: LD_ADDR_EXP 6
12675: PUSH
12676: LD_EXP 6
12680: PUSH
12681: LD_VAR 0 2
12685: DIFF
12686: ST_TO_ADDR
// if IsInArea ( un , base ) then
12687: LD_VAR 0 2
12691: PPUSH
12692: LD_INT 5
12694: PPUSH
12695: CALL_OW 308
12699: IFFALSE 12752
// begin if GetSex ( un ) = sex_male then
12701: LD_VAR 0 2
12705: PPUSH
12706: CALL_OW 258
12710: PUSH
12711: LD_INT 1
12713: EQUAL
12714: IFFALSE 12750
// if not WasD11aa then
12716: LD_EXP 69
12720: NOT
12721: IFFALSE 12734
// Dialog11aa ( un ) else
12723: LD_VAR 0 2
12727: PPUSH
12728: CALL 10014 0 1
12732: GO 12750
// if not WasD11ab then
12734: LD_EXP 70
12738: NOT
12739: IFFALSE 12750
// Dialog11ab ( un ) ;
12741: LD_VAR 0 2
12745: PPUSH
12746: CALL 10057 0 1
// end else
12750: GO 12855
// begin if GetSex ( un ) = sex_female then
12752: LD_VAR 0 2
12756: PPUSH
12757: CALL_OW 258
12761: PUSH
12762: LD_INT 2
12764: EQUAL
12765: IFFALSE 12803
// begin if not WasD11c then
12767: LD_EXP 72
12771: NOT
12772: IFFALSE 12785
// Dialog11c ( un ) else
12774: LD_VAR 0 2
12778: PPUSH
12779: CALL 10155 0 1
12783: GO 12801
// if not WasD11e then
12785: LD_EXP 74
12789: NOT
12790: IFFALSE 12801
// Dialog11e ( un ) ;
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 10350 0 1
// end else
12801: GO 12855
// begin if not WasD11b then
12803: LD_EXP 71
12807: NOT
12808: IFFALSE 12821
// Dialog11b ( un ) else
12810: LD_VAR 0 2
12814: PPUSH
12815: CALL 10100 0 1
12819: GO 12855
// if not WasD11d then
12821: LD_EXP 73
12825: NOT
12826: IFFALSE 12839
// Dialog11d ( un ) else
12828: LD_VAR 0 2
12832: PPUSH
12833: CALL 10295 0 1
12837: GO 12855
// if not WasD11f then
12839: LD_EXP 75
12843: NOT
12844: IFFALSE 12855
// Dialog11f ( un ) ;
12846: LD_VAR 0 2
12850: PPUSH
12851: CALL 10393 0 1
// end ; end ; end ; enable ;
12855: ENABLE
// end ; end ;
12856: PPOPN 4
12858: END
// every 10 10$0 + 2 2$30 trigger start_game do var a4 , b4 , b5 , c4 , d4 , ia4 , max4 , h ;
12859: LD_EXP 55
12863: IFFALSE 13415
12865: GO 12867
12867: DISABLE
12868: LD_INT 0
12870: PPUSH
12871: PPUSH
12872: PPUSH
12873: PPUSH
12874: PPUSH
12875: PPUSH
12876: PPUSH
12877: PPUSH
// begin ne_v_boji ;
12878: CALL 13418 0 0
// repeat wait ( 0 0$3 ) ;
12882: LD_INT 105
12884: PPUSH
12885: CALL_OW 67
// b4 := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Joan ] ;
12889: LD_ADDR_VAR 0 2
12893: PUSH
12894: LD_INT 22
12896: PUSH
12897: LD_EXP 1
12901: PUSH
12902: EMPTY
12903: LIST
12904: LIST
12905: PUSH
12906: LD_INT 23
12908: PUSH
12909: LD_INT 1
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 21
12918: PUSH
12919: LD_INT 1
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 50
12928: PUSH
12929: EMPTY
12930: LIST
12931: PUSH
12932: LD_INT 56
12934: PUSH
12935: EMPTY
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: PPUSH
12945: CALL_OW 69
12949: PUSH
12950: LD_EXP 15
12954: PUSH
12955: LD_EXP 33
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: DIFF
12964: ST_TO_ADDR
// until b4 and not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , [ f_occupied ] ] , [ f_dist , JMM , 40 ] ] ) ;
12965: LD_VAR 0 2
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_EXP 2
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 2
12984: PUSH
12985: LD_INT 21
12987: PUSH
12988: LD_INT 1
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 21
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: LD_INT 21
13007: PUSH
13008: LD_INT 3
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 59
13017: PUSH
13018: EMPTY
13019: LIST
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 91
13030: PUSH
13031: LD_EXP 15
13035: PUSH
13036: LD_INT 40
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: PPUSH
13049: CALL_OW 69
13053: NOT
13054: AND
13055: IFFALSE 12882
// max4 := 1000 ;
13057: LD_ADDR_VAR 0 7
13061: PUSH
13062: LD_INT 1000
13064: ST_TO_ADDR
// if Rand ( 1 , 5 ) <= 4 then
13065: LD_INT 1
13067: PPUSH
13068: LD_INT 5
13070: PPUSH
13071: CALL_OW 12
13075: PUSH
13076: LD_INT 4
13078: LESSEQUAL
13079: IFFALSE 13160
// begin for ia4 in b4 do
13081: LD_ADDR_VAR 0 6
13085: PUSH
13086: LD_VAR 0 2
13090: PUSH
13091: FOR_IN
13092: IFFALSE 13158
// begin d4 := GetDistUnits ( JMM , ia4 ) ;
13094: LD_ADDR_VAR 0 5
13098: PUSH
13099: LD_EXP 15
13103: PPUSH
13104: LD_VAR 0 6
13108: PPUSH
13109: CALL_OW 296
13113: ST_TO_ADDR
// if d4 > 5 and d4 < max4 then
13114: LD_VAR 0 5
13118: PUSH
13119: LD_INT 5
13121: GREATER
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: LESS
13133: AND
13134: IFFALSE 13156
// begin max4 := d4 ;
13136: LD_ADDR_VAR 0 7
13140: PUSH
13141: LD_VAR 0 5
13145: ST_TO_ADDR
// c4 := ia4 ;
13146: LD_ADDR_VAR 0 4
13150: PUSH
13151: LD_VAR 0 6
13155: ST_TO_ADDR
// end ; end ;
13156: GO 13091
13158: POP
13159: POP
// end ; if max4 > 11 then
13160: LD_VAR 0 7
13164: PUSH
13165: LD_INT 11
13167: GREATER
13168: IFFALSE 13180
// c4 := JMM ;
13170: LD_ADDR_VAR 0 4
13174: PUSH
13175: LD_EXP 15
13179: ST_TO_ADDR
// a4 := 0 ;
13180: LD_ADDR_VAR 0 1
13184: PUSH
13185: LD_INT 0
13187: ST_TO_ADDR
// if not Kurt_P and not Joan_P then
13188: LD_EXP 47
13192: NOT
13193: PUSH
13194: LD_EXP 48
13198: NOT
13199: AND
13200: IFFALSE 13218
// a4 := Rand ( 1 , 2 ) ;
13202: LD_ADDR_VAR 0 1
13206: PUSH
13207: LD_INT 1
13209: PPUSH
13210: LD_INT 2
13212: PPUSH
13213: CALL_OW 12
13217: ST_TO_ADDR
// if ( not Kurt_P and a4 = 0 ) or a4 = 1 then
13218: LD_EXP 47
13222: NOT
13223: PUSH
13224: LD_VAR 0 1
13228: PUSH
13229: LD_INT 0
13231: EQUAL
13232: AND
13233: PUSH
13234: LD_VAR 0 1
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: OR
13243: IFFALSE 13319
// begin SetAttitude ( arabians , you , att_friend , true ) ;
13245: LD_EXP 3
13249: PPUSH
13250: LD_EXP 1
13254: PPUSH
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: CALL_OW 80
// if PlaceUnitXYR ( Kurt , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13265: LD_EXP 43
13269: PPUSH
13270: LD_VAR 0 4
13274: PPUSH
13275: CALL_OW 250
13279: PPUSH
13280: LD_VAR 0 4
13284: PPUSH
13285: CALL_OW 251
13289: PPUSH
13290: LD_INT 8
13292: PPUSH
13293: LD_INT 1
13295: PPUSH
13296: CALL_OW 50
13300: IFFALSE 13319
// begin Kurt_P := true ;
13302: LD_ADDR_EXP 47
13306: PUSH
13307: LD_INT 1
13309: ST_TO_ADDR
// DialogKurt ( c4 ) ;
13310: LD_VAR 0 4
13314: PPUSH
13315: CALL 6821 0 1
// end ; end ; if ( not Joan_P and a4 = 0 ) or a4 = 2 then
13319: LD_EXP 48
13323: NOT
13324: PUSH
13325: LD_VAR 0 1
13329: PUSH
13330: LD_INT 0
13332: EQUAL
13333: AND
13334: PUSH
13335: LD_VAR 0 1
13339: PUSH
13340: LD_INT 2
13342: EQUAL
13343: OR
13344: IFFALSE 13400
// begin if PlaceUnitXYR ( Joan , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13346: LD_EXP 33
13350: PPUSH
13351: LD_VAR 0 4
13355: PPUSH
13356: CALL_OW 250
13360: PPUSH
13361: LD_VAR 0 4
13365: PPUSH
13366: CALL_OW 251
13370: PPUSH
13371: LD_INT 8
13373: PPUSH
13374: LD_INT 1
13376: PPUSH
13377: CALL_OW 50
13381: IFFALSE 13400
// begin Joan_P := true ;
13383: LD_ADDR_EXP 48
13387: PUSH
13388: LD_INT 1
13390: ST_TO_ADDR
// DialogJoan ( c4 ) ;
13391: LD_VAR 0 4
13395: PPUSH
13396: CALL 8416 0 1
// end ; end ; if not Kurt_P or not Joan_P then
13400: LD_EXP 47
13404: NOT
13405: PUSH
13406: LD_EXP 48
13410: NOT
13411: OR
13412: IFFALSE 13415
// enable ;
13414: ENABLE
// end ; end_of_file
13415: PPOPN 8
13417: END
// export function ne_v_boji ; begin
13418: LD_INT 0
13420: PPUSH
// while bojujese do
13421: CALL 13441 0 0
13425: IFFALSE 13436
// wait ( 0 0$4 ) ;
13427: LD_INT 140
13429: PPUSH
13430: CALL_OW 67
13434: GO 13421
// end ;
13436: LD_VAR 0 1
13440: RET
// export function bojujese ; begin
13441: LD_INT 0
13443: PPUSH
// result := true and not FilterAllUnits ( [ [ f_dist , JMM , 40 ] , [ f_side , russians ] ] ) ;
13444: LD_ADDR_VAR 0 1
13448: PUSH
13449: LD_INT 1
13451: PUSH
13452: LD_INT 91
13454: PUSH
13455: LD_EXP 15
13459: PUSH
13460: LD_INT 40
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 22
13470: PUSH
13471: LD_EXP 2
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PPUSH
13484: CALL_OW 69
13488: NOT
13489: AND
13490: ST_TO_ADDR
// end ;
13491: LD_VAR 0 1
13495: RET
// export function TvojiLidi ; begin
13496: LD_INT 0
13498: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13499: LD_ADDR_VAR 0 1
13503: PUSH
13504: LD_INT 22
13506: PUSH
13507: LD_EXP 1
13511: PUSH
13512: EMPTY
13513: LIST
13514: LIST
13515: PUSH
13516: LD_INT 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: PPUSH
13530: CALL_OW 69
13534: ST_TO_ADDR
// end ;
13535: LD_VAR 0 1
13539: RET
// export function filter_type_unit ( from_units , human , vehicle , building ) ; var temp1 , temp2 , temp3 ; var un2 ; begin
13540: LD_INT 0
13542: PPUSH
13543: PPUSH
13544: PPUSH
13545: PPUSH
13546: PPUSH
// if human then
13547: LD_VAR 0 2
13551: IFFALSE 13578
// begin temp1 := UnitFilter ( from_units , [ f_type , unit_human ] ) ;
13553: LD_ADDR_VAR 0 6
13557: PUSH
13558: LD_VAR 0 1
13562: PPUSH
13563: LD_INT 21
13565: PUSH
13566: LD_INT 1
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 72
13577: ST_TO_ADDR
// end ; if vehicle then
13578: LD_VAR 0 3
13582: IFFALSE 13609
// begin temp2 := UnitFilter ( from_units , [ f_type , unit_vehicle ] ) ;
13584: LD_ADDR_VAR 0 7
13588: PUSH
13589: LD_VAR 0 1
13593: PPUSH
13594: LD_INT 21
13596: PUSH
13597: LD_INT 2
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PPUSH
13604: CALL_OW 72
13608: ST_TO_ADDR
// end ; if building then
13609: LD_VAR 0 4
13613: IFFALSE 13640
// begin temp3 := UnitFilter ( from_units , [ f_type , unit_building ] ) ;
13615: LD_ADDR_VAR 0 8
13619: PUSH
13620: LD_VAR 0 1
13624: PPUSH
13625: LD_INT 21
13627: PUSH
13628: LD_INT 3
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 72
13639: ST_TO_ADDR
// end ; temp1 := add ( temp1 , temp2 ) ;
13640: LD_ADDR_VAR 0 6
13644: PUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 7
13654: PPUSH
13655: CALL 17438 0 2
13659: ST_TO_ADDR
// temp1 := add ( temp1 , temp3 ) ;
13660: LD_ADDR_VAR 0 6
13664: PUSH
13665: LD_VAR 0 6
13669: PPUSH
13670: LD_VAR 0 8
13674: PPUSH
13675: CALL 17438 0 2
13679: ST_TO_ADDR
// result := temp1 ;
13680: LD_ADDR_VAR 0 5
13684: PUSH
13685: LD_VAR 0 6
13689: ST_TO_ADDR
// end ;
13690: LD_VAR 0 5
13694: RET
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
13695: LD_INT 0
13697: PPUSH
13698: PPUSH
13699: PPUSH
13700: PPUSH
13701: PPUSH
13702: PPUSH
13703: PPUSH
13704: PPUSH
13705: PPUSH
13706: PPUSH
13707: PPUSH
13708: PPUSH
13709: PPUSH
13710: PPUSH
13711: PPUSH
// for for_unit in for_units do
13712: LD_ADDR_VAR 0 22
13716: PUSH
13717: LD_VAR 0 5
13721: PUSH
13722: FOR_IN
13723: IFFALSE 14245
// begin x := px ;
13725: LD_ADDR_VAR 0 9
13729: PUSH
13730: LD_VAR 0 1
13734: ST_TO_ADDR
// y := py ;
13735: LD_ADDR_VAR 0 10
13739: PUSH
13740: LD_VAR 0 2
13744: ST_TO_ADDR
// lx := px ;
13745: LD_ADDR_VAR 0 13
13749: PUSH
13750: LD_VAR 0 1
13754: ST_TO_ADDR
// ly := py ;
13755: LD_ADDR_VAR 0 14
13759: PUSH
13760: LD_VAR 0 2
13764: ST_TO_ADDR
// for j2 := 1 to hloubka do
13765: LD_ADDR_VAR 0 18
13769: PUSH
13770: DOUBLE
13771: LD_INT 1
13773: DEC
13774: ST_TO_ADDR
13775: LD_VAR 0 3
13779: PUSH
13780: FOR_TO
13781: IFFALSE 14113
// begin howgood := 50000 ;
13783: LD_ADDR_VAR 0 15
13787: PUSH
13788: LD_INT 50000
13790: ST_TO_ADDR
// smer := 0 ;
13791: LD_ADDR_VAR 0 16
13795: PUSH
13796: LD_INT 0
13798: ST_TO_ADDR
// kolem := 0 ;
13799: LD_ADDR_VAR 0 21
13803: PUSH
13804: LD_INT 0
13806: ST_TO_ADDR
// for i2 := 0 to 5 do
13807: LD_ADDR_VAR 0 17
13811: PUSH
13812: DOUBLE
13813: LD_INT 0
13815: DEC
13816: ST_TO_ADDR
13817: LD_INT 5
13819: PUSH
13820: FOR_TO
13821: IFFALSE 14015
// begin x2 := ShiftX ( x , i2 , krok ) ;
13823: LD_ADDR_VAR 0 11
13827: PUSH
13828: LD_VAR 0 9
13832: PPUSH
13833: LD_VAR 0 17
13837: PPUSH
13838: LD_VAR 0 4
13842: PPUSH
13843: CALL_OW 272
13847: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
13848: LD_ADDR_VAR 0 12
13852: PUSH
13853: LD_VAR 0 10
13857: PPUSH
13858: LD_VAR 0 17
13862: PPUSH
13863: LD_VAR 0 4
13867: PPUSH
13868: CALL_OW 273
13872: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
13873: LD_ADDR_VAR 0 20
13877: PUSH
13878: LD_VAR 0 6
13882: PPUSH
13883: LD_VAR 0 11
13887: PPUSH
13888: LD_VAR 0 12
13892: PPUSH
13893: CALL_OW 293
13897: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
13898: LD_VAR 0 20
13902: PUSH
13903: LD_VAR 0 15
13907: LESS
13908: PUSH
13909: LD_VAR 0 1
13913: PPUSH
13914: LD_VAR 0 2
13918: PPUSH
13919: LD_VAR 0 9
13923: PPUSH
13924: LD_VAR 0 10
13928: PPUSH
13929: CALL_OW 298
13933: PUSH
13934: LD_VAR 0 1
13938: PPUSH
13939: LD_VAR 0 2
13943: PPUSH
13944: LD_VAR 0 11
13948: PPUSH
13949: LD_VAR 0 12
13953: PPUSH
13954: CALL_OW 298
13958: LESS
13959: AND
13960: IFFALSE 13997
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
13962: LD_ADDR_VAR 0 15
13966: PUSH
13967: LD_VAR 0 6
13971: PPUSH
13972: LD_VAR 0 11
13976: PPUSH
13977: LD_VAR 0 12
13981: PPUSH
13982: CALL_OW 293
13986: ST_TO_ADDR
// smer := i2 ;
13987: LD_ADDR_VAR 0 16
13991: PUSH
13992: LD_VAR 0 17
13996: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
13997: LD_ADDR_VAR 0 21
14001: PUSH
14002: LD_VAR 0 21
14006: PUSH
14007: LD_VAR 0 20
14011: PLUS
14012: ST_TO_ADDR
// end ;
14013: GO 13820
14015: POP
14016: POP
// x := ShiftX ( x , smer , krok ) ;
14017: LD_ADDR_VAR 0 9
14021: PUSH
14022: LD_VAR 0 9
14026: PPUSH
14027: LD_VAR 0 16
14031: PPUSH
14032: LD_VAR 0 4
14036: PPUSH
14037: CALL_OW 272
14041: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
14042: LD_ADDR_VAR 0 10
14046: PUSH
14047: LD_VAR 0 10
14051: PPUSH
14052: LD_VAR 0 16
14056: PPUSH
14057: LD_VAR 0 4
14061: PPUSH
14062: CALL_OW 273
14066: ST_TO_ADDR
// lx := lx ^ x ;
14067: LD_ADDR_VAR 0 13
14071: PUSH
14072: LD_VAR 0 13
14076: PUSH
14077: LD_VAR 0 9
14081: ADD
14082: ST_TO_ADDR
// ly := ly ^ y ;
14083: LD_ADDR_VAR 0 14
14087: PUSH
14088: LD_VAR 0 14
14092: PUSH
14093: LD_VAR 0 10
14097: ADD
14098: ST_TO_ADDR
// if kolem = 0 then
14099: LD_VAR 0 21
14103: PUSH
14104: LD_INT 0
14106: EQUAL
14107: IFFALSE 14111
// break ;
14109: GO 14113
// end ;
14111: GO 13780
14113: POP
14114: POP
// for j2 := ( lx + 0 ) downto 1 do
14115: LD_ADDR_VAR 0 18
14119: PUSH
14120: DOUBLE
14121: LD_VAR 0 13
14125: PUSH
14126: LD_INT 0
14128: PLUS
14129: INC
14130: ST_TO_ADDR
14131: LD_INT 1
14133: PUSH
14134: FOR_DOWNTO
14135: IFFALSE 14241
// begin if queue and j2 = ( lx + 0 ) then
14137: LD_VAR 0 7
14141: PUSH
14142: LD_VAR 0 18
14146: PUSH
14147: LD_VAR 0 13
14151: PUSH
14152: LD_INT 0
14154: PLUS
14155: EQUAL
14156: AND
14157: IFFALSE 14192
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
14159: LD_VAR 0 22
14163: PPUSH
14164: LD_VAR 0 13
14168: PUSH
14169: LD_VAR 0 18
14173: ARRAY
14174: PPUSH
14175: LD_VAR 0 14
14179: PUSH
14180: LD_VAR 0 18
14184: ARRAY
14185: PPUSH
14186: CALL_OW 111
14190: GO 14239
// begin com_queue := true ;
14192: LD_ADDR_OWVAR 49
14196: PUSH
14197: LD_INT 1
14199: ST_TO_ADDR
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
14200: LD_VAR 0 22
14204: PPUSH
14205: LD_VAR 0 13
14209: PUSH
14210: LD_VAR 0 18
14214: ARRAY
14215: PPUSH
14216: LD_VAR 0 14
14220: PUSH
14221: LD_VAR 0 18
14225: ARRAY
14226: PPUSH
14227: CALL_OW 111
// com_queue := false ;
14231: LD_ADDR_OWVAR 49
14235: PUSH
14236: LD_INT 0
14238: ST_TO_ADDR
// end ; end ;
14239: GO 14134
14241: POP
14242: POP
// end ;
14243: GO 13722
14245: POP
14246: POP
// end ;
14247: LD_VAR 0 8
14251: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
14252: LD_INT 0
14254: PPUSH
14255: PPUSH
14256: PPUSH
14257: PPUSH
// for for_unit in for_units do
14258: LD_ADDR_VAR 0 5
14262: PUSH
14263: LD_VAR 0 1
14267: PUSH
14268: FOR_IN
14269: IFFALSE 14332
// begin unx := GetX ( for_unit ) ;
14271: LD_ADDR_VAR 0 6
14275: PUSH
14276: LD_VAR 0 5
14280: PPUSH
14281: CALL_OW 250
14285: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
14286: LD_ADDR_VAR 0 7
14290: PUSH
14291: LD_VAR 0 5
14295: PPUSH
14296: CALL_OW 251
14300: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
14301: LD_VAR 0 6
14305: PPUSH
14306: LD_VAR 0 7
14310: PPUSH
14311: LD_VAR 0 5
14315: PPUSH
14316: LD_VAR 0 2
14320: PPUSH
14321: LD_VAR 0 3
14325: PPUSH
14326: CALL 14339 0 5
// end ;
14330: GO 14268
14332: POP
14333: POP
// end ;
14334: LD_VAR 0 4
14338: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
14339: LD_INT 0
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
14345: PPUSH
14346: PPUSH
14347: PPUSH
// for for_unit in for_units do
14348: LD_ADDR_VAR 0 12
14352: PUSH
14353: LD_VAR 0 3
14357: PUSH
14358: FOR_IN
14359: IFFALSE 15075
// begin foundswD := 50000 ;
14361: LD_ADDR_VAR 0 9
14365: PUSH
14366: LD_INT 50000
14368: ST_TO_ADDR
// eswTX := 0 ;
14369: LD_ADDR_VAR 0 10
14373: PUSH
14374: LD_INT 0
14376: ST_TO_ADDR
// eswTY := 0 ;
14377: LD_ADDR_VAR 0 11
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// while eswTX < map_size_x do
14385: LD_VAR 0 10
14389: PUSH
14390: LD_EXP 53
14394: LESS
14395: IFFALSE 14495
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14397: LD_VAR 0 1
14401: PPUSH
14402: LD_VAR 0 2
14406: PPUSH
14407: LD_VAR 0 10
14411: PPUSH
14412: LD_VAR 0 11
14416: PPUSH
14417: CALL_OW 298
14421: PUSH
14422: LD_VAR 0 9
14426: LESS
14427: IFFALSE 14479
// begin foundswX := eswTX ;
14429: LD_ADDR_VAR 0 7
14433: PUSH
14434: LD_VAR 0 10
14438: ST_TO_ADDR
// foundswY := eswTY ;
14439: LD_ADDR_VAR 0 8
14443: PUSH
14444: LD_VAR 0 11
14448: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14449: LD_ADDR_VAR 0 9
14453: PUSH
14454: LD_VAR 0 1
14458: PPUSH
14459: LD_VAR 0 2
14463: PPUSH
14464: LD_VAR 0 10
14468: PPUSH
14469: LD_VAR 0 11
14473: PPUSH
14474: CALL_OW 298
14478: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14479: LD_ADDR_VAR 0 10
14483: PUSH
14484: LD_VAR 0 10
14488: PUSH
14489: LD_INT 10
14491: PLUS
14492: ST_TO_ADDR
// end ;
14493: GO 14385
// eswTX := map_size_x div 2 ;
14495: LD_ADDR_VAR 0 10
14499: PUSH
14500: LD_EXP 53
14504: PUSH
14505: LD_INT 2
14507: DIV
14508: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
14509: LD_ADDR_VAR 0 11
14513: PUSH
14514: LD_EXP 54
14518: PUSH
14519: LD_INT 1
14521: MINUS
14522: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
14523: LD_VAR 0 10
14527: PUSH
14528: LD_EXP 53
14532: PUSH
14533: LD_EXP 53
14537: PUSH
14538: LD_INT 2
14540: DIV
14541: PLUS
14542: LESS
14543: IFFALSE 14643
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14545: LD_VAR 0 1
14549: PPUSH
14550: LD_VAR 0 2
14554: PPUSH
14555: LD_VAR 0 10
14559: PPUSH
14560: LD_VAR 0 11
14564: PPUSH
14565: CALL_OW 298
14569: PUSH
14570: LD_VAR 0 9
14574: LESS
14575: IFFALSE 14627
// begin foundswX := eswTX ;
14577: LD_ADDR_VAR 0 7
14581: PUSH
14582: LD_VAR 0 10
14586: ST_TO_ADDR
// foundswY := eswTY ;
14587: LD_ADDR_VAR 0 8
14591: PUSH
14592: LD_VAR 0 11
14596: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: LD_VAR 0 2
14611: PPUSH
14612: LD_VAR 0 10
14616: PPUSH
14617: LD_VAR 0 11
14621: PPUSH
14622: CALL_OW 298
14626: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14627: LD_ADDR_VAR 0 10
14631: PUSH
14632: LD_VAR 0 10
14636: PUSH
14637: LD_INT 10
14639: PLUS
14640: ST_TO_ADDR
// end ;
14641: GO 14523
// eswTX := 0 ;
14643: LD_ADDR_VAR 0 10
14647: PUSH
14648: LD_INT 0
14650: ST_TO_ADDR
// eswTY := 0 ;
14651: LD_ADDR_VAR 0 11
14655: PUSH
14656: LD_INT 0
14658: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14659: LD_VAR 0 11
14663: PUSH
14664: LD_EXP 54
14668: LESS
14669: IFFALSE 14783
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14671: LD_VAR 0 1
14675: PPUSH
14676: LD_VAR 0 2
14680: PPUSH
14681: LD_VAR 0 10
14685: PPUSH
14686: LD_VAR 0 11
14690: PPUSH
14691: CALL_OW 298
14695: PUSH
14696: LD_VAR 0 9
14700: LESS
14701: IFFALSE 14753
// begin foundswX := eswTX ;
14703: LD_ADDR_VAR 0 7
14707: PUSH
14708: LD_VAR 0 10
14712: ST_TO_ADDR
// foundswY := eswTY ;
14713: LD_ADDR_VAR 0 8
14717: PUSH
14718: LD_VAR 0 11
14722: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14723: LD_ADDR_VAR 0 9
14727: PUSH
14728: LD_VAR 0 1
14732: PPUSH
14733: LD_VAR 0 2
14737: PPUSH
14738: LD_VAR 0 10
14742: PPUSH
14743: LD_VAR 0 11
14747: PPUSH
14748: CALL_OW 298
14752: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14753: LD_ADDR_VAR 0 11
14757: PUSH
14758: LD_VAR 0 11
14762: PUSH
14763: LD_INT 10
14765: PLUS
14766: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14767: LD_ADDR_VAR 0 10
14771: PUSH
14772: LD_VAR 0 10
14776: PUSH
14777: LD_INT 5
14779: PLUS
14780: ST_TO_ADDR
// end ;
14781: GO 14659
// eswTX := map_size_x ;
14783: LD_ADDR_VAR 0 10
14787: PUSH
14788: LD_EXP 53
14792: ST_TO_ADDR
// eswTY := 1 ;
14793: LD_ADDR_VAR 0 11
14797: PUSH
14798: LD_INT 1
14800: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14801: LD_VAR 0 11
14805: PUSH
14806: LD_EXP 54
14810: LESS
14811: IFFALSE 14925
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14813: LD_VAR 0 1
14817: PPUSH
14818: LD_VAR 0 2
14822: PPUSH
14823: LD_VAR 0 10
14827: PPUSH
14828: LD_VAR 0 11
14832: PPUSH
14833: CALL_OW 298
14837: PUSH
14838: LD_VAR 0 9
14842: LESS
14843: IFFALSE 14895
// begin foundswX := eswTX ;
14845: LD_ADDR_VAR 0 7
14849: PUSH
14850: LD_VAR 0 10
14854: ST_TO_ADDR
// foundswY := eswTY ;
14855: LD_ADDR_VAR 0 8
14859: PUSH
14860: LD_VAR 0 11
14864: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14865: LD_ADDR_VAR 0 9
14869: PUSH
14870: LD_VAR 0 1
14874: PPUSH
14875: LD_VAR 0 2
14879: PPUSH
14880: LD_VAR 0 10
14884: PPUSH
14885: LD_VAR 0 11
14889: PPUSH
14890: CALL_OW 298
14894: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14895: LD_ADDR_VAR 0 11
14899: PUSH
14900: LD_VAR 0 11
14904: PUSH
14905: LD_INT 10
14907: PLUS
14908: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14909: LD_ADDR_VAR 0 10
14913: PUSH
14914: LD_VAR 0 10
14918: PUSH
14919: LD_INT 5
14921: PLUS
14922: ST_TO_ADDR
// end ;
14923: GO 14801
// if queue then
14925: LD_VAR 0 4
14929: IFFALSE 15003
// begin if agressive then
14931: LD_VAR 0 5
14935: IFFALSE 14970
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
14937: LD_VAR 0 12
14941: PPUSH
14942: LD_VAR 0 7
14946: PPUSH
14947: LD_VAR 0 8
14951: PPUSH
14952: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
14956: LD_VAR 0 12
14960: PPUSH
14961: LD_INT 10
14963: PPUSH
14964: CALL_OW 173
// end else
14968: GO 15001
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
14970: LD_VAR 0 12
14974: PPUSH
14975: LD_VAR 0 7
14979: PPUSH
14980: LD_VAR 0 8
14984: PPUSH
14985: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
14989: LD_VAR 0 12
14993: PPUSH
14994: LD_INT 10
14996: PPUSH
14997: CALL_OW 173
// end ; end else
15001: GO 15073
// begin if agressive then
15003: LD_VAR 0 5
15007: IFFALSE 15042
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
15009: LD_VAR 0 12
15013: PPUSH
15014: LD_VAR 0 7
15018: PPUSH
15019: LD_VAR 0 8
15023: PPUSH
15024: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
15028: LD_VAR 0 12
15032: PPUSH
15033: LD_INT 10
15035: PPUSH
15036: CALL_OW 173
// end else
15040: GO 15073
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
15042: LD_VAR 0 12
15046: PPUSH
15047: LD_VAR 0 7
15051: PPUSH
15052: LD_VAR 0 8
15056: PPUSH
15057: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
15061: LD_VAR 0 12
15065: PPUSH
15066: LD_INT 10
15068: PPUSH
15069: CALL_OW 173
// end ; end ; end ;
15073: GO 14358
15075: POP
15076: POP
// end ;
15077: LD_VAR 0 6
15081: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
15082: LD_INT 0
15084: PPUSH
15085: PPUSH
15086: PPUSH
// see_any_r := false ;
15087: LD_ADDR_VAR 0 5
15091: PUSH
15092: LD_INT 0
15094: ST_TO_ADDR
// for sai in sez2 do
15095: LD_ADDR_VAR 0 4
15099: PUSH
15100: LD_VAR 0 2
15104: PUSH
15105: FOR_IN
15106: IFFALSE 15136
// if See ( strana , sai ) then
15108: LD_VAR 0 1
15112: PPUSH
15113: LD_VAR 0 4
15117: PPUSH
15118: CALL_OW 292
15122: IFFALSE 15134
// begin see_any_r := true ;
15124: LD_ADDR_VAR 0 5
15128: PUSH
15129: LD_INT 1
15131: ST_TO_ADDR
// break ;
15132: GO 15136
// end ;
15134: GO 15105
15136: POP
15137: POP
// ; result := see_any_r ;
15138: LD_ADDR_VAR 0 3
15142: PUSH
15143: LD_VAR 0 5
15147: ST_TO_ADDR
// end ;
15148: LD_VAR 0 3
15152: RET
// export function nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ; var list , list2 ; var un1 , vzdal ; var count ; begin
15153: LD_INT 0
15155: PPUSH
15156: PPUSH
15157: PPUSH
15158: PPUSH
15159: PPUSH
15160: PPUSH
// un1 := 1 ;
15161: LD_ADDR_VAR 0 11
15165: PUSH
15166: LD_INT 1
15168: ST_TO_ADDR
// count := 0 ;
15169: LD_ADDR_VAR 0 13
15173: PUSH
15174: LD_INT 0
15176: ST_TO_ADDR
// if pocet > from_units then
15177: LD_VAR 0 5
15181: PUSH
15182: LD_VAR 0 1
15186: GREATER
15187: IFFALSE 15203
// pocet := ( from_units + 0 ) ;
15189: LD_ADDR_VAR 0 5
15193: PUSH
15194: LD_VAR 0 1
15198: PUSH
15199: LD_INT 0
15201: PLUS
15202: ST_TO_ADDR
// while un1 <= pocet or count <= pocet do
15203: LD_VAR 0 11
15207: PUSH
15208: LD_VAR 0 5
15212: LESSEQUAL
15213: PUSH
15214: LD_VAR 0 13
15218: PUSH
15219: LD_VAR 0 5
15223: LESSEQUAL
15224: OR
15225: IFFALSE 15378
// begin vzdal := GetDistUnitXY ( un1 , x , y ) ;
15227: LD_ADDR_VAR 0 12
15231: PUSH
15232: LD_VAR 0 11
15236: PPUSH
15237: LD_VAR 0 2
15241: PPUSH
15242: LD_VAR 0 3
15246: PPUSH
15247: CALL_OW 297
15251: ST_TO_ADDR
// if vzdal <= max_vzdal then
15252: LD_VAR 0 12
15256: PUSH
15257: LD_VAR 0 7
15261: LESSEQUAL
15262: IFFALSE 15362
// begin if un1 > skip then
15264: LD_VAR 0 11
15268: PUSH
15269: LD_VAR 0 4
15273: GREATER
15274: IFFALSE 15362
// begin if list then
15276: LD_VAR 0 9
15280: IFFALSE 15322
// begin list := list ^ from_units [ un1 ] ;
15282: LD_ADDR_VAR 0 9
15286: PUSH
15287: LD_VAR 0 9
15291: PUSH
15292: LD_VAR 0 1
15296: PUSH
15297: LD_VAR 0 11
15301: ARRAY
15302: ADD
15303: ST_TO_ADDR
// list2 := list2 ^ vzdal ;
15304: LD_ADDR_VAR 0 10
15308: PUSH
15309: LD_VAR 0 10
15313: PUSH
15314: LD_VAR 0 12
15318: ADD
15319: ST_TO_ADDR
// end else
15320: GO 15348
// begin list := from_units [ un1 ] ;
15322: LD_ADDR_VAR 0 9
15326: PUSH
15327: LD_VAR 0 1
15331: PUSH
15332: LD_VAR 0 11
15336: ARRAY
15337: ST_TO_ADDR
// list2 := vzdal ;
15338: LD_ADDR_VAR 0 10
15342: PUSH
15343: LD_VAR 0 12
15347: ST_TO_ADDR
// end ; count := count + 1 ;
15348: LD_ADDR_VAR 0 13
15352: PUSH
15353: LD_VAR 0 13
15357: PUSH
15358: LD_INT 1
15360: PLUS
15361: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
15362: LD_ADDR_VAR 0 11
15366: PUSH
15367: LD_VAR 0 11
15371: PUSH
15372: LD_INT 1
15374: PLUS
15375: ST_TO_ADDR
// end ;
15376: GO 15203
// result := list ;
15378: LD_ADDR_VAR 0 8
15382: PUSH
15383: LD_VAR 0 9
15387: ST_TO_ADDR
// end ;
15388: LD_VAR 0 8
15392: RET
// export function nearest_units_unit ( from_units , for_unit , skip , pocet , min_vzdal , max_vzdal ) ; var x , y ; begin
15393: LD_INT 0
15395: PPUSH
15396: PPUSH
15397: PPUSH
// x := GetX ( for_unit ) ;
15398: LD_ADDR_VAR 0 8
15402: PUSH
15403: LD_VAR 0 2
15407: PPUSH
15408: CALL_OW 250
15412: ST_TO_ADDR
// y := GetY ( for_unit ) ;
15413: LD_ADDR_VAR 0 9
15417: PUSH
15418: LD_VAR 0 2
15422: PPUSH
15423: CALL_OW 251
15427: ST_TO_ADDR
// result := nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ;
15428: LD_ADDR_VAR 0 7
15432: PUSH
15433: LD_VAR 0 1
15437: PPUSH
15438: LD_VAR 0 8
15442: PPUSH
15443: LD_VAR 0 9
15447: PPUSH
15448: LD_VAR 0 3
15452: PPUSH
15453: LD_VAR 0 4
15457: PPUSH
15458: LD_VAR 0 5
15462: PPUSH
15463: LD_VAR 0 6
15467: PPUSH
15468: CALL 15153 0 7
15472: ST_TO_ADDR
// end ;
15473: LD_VAR 0 7
15477: RET
// export function nearest_ememies_xy ( side , x , y , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15478: LD_INT 0
15480: PPUSH
15481: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15482: LD_ADDR_VAR 0 11
15486: PUSH
15487: LD_INT 22
15489: PUSH
15490: LD_VAR 0 1
15494: PUSH
15495: EMPTY
15496: LIST
15497: LIST
15498: PPUSH
15499: CALL_OW 69
15503: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15504: LD_ADDR_VAR 0 11
15508: PUSH
15509: LD_VAR 0 11
15513: PPUSH
15514: LD_VAR 0 7
15518: PPUSH
15519: LD_VAR 0 8
15523: PPUSH
15524: LD_VAR 0 9
15528: PPUSH
15529: CALL 13540 0 4
15533: ST_TO_ADDR
// nearest_units_xy ( from_units , x , y , skip , pocet , 1 , max_vzdal ) ;
15534: LD_VAR 0 11
15538: PPUSH
15539: LD_VAR 0 2
15543: PPUSH
15544: LD_VAR 0 3
15548: PPUSH
15549: LD_VAR 0 4
15553: PPUSH
15554: LD_VAR 0 5
15558: PPUSH
15559: LD_INT 1
15561: PPUSH
15562: LD_VAR 0 6
15566: PPUSH
15567: CALL 15153 0 7
// end ;
15571: LD_VAR 0 10
15575: RET
// export function nearest_ememies_unit ( side , for_unit , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15576: LD_INT 0
15578: PPUSH
15579: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15580: LD_ADDR_VAR 0 10
15584: PUSH
15585: LD_INT 22
15587: PUSH
15588: LD_VAR 0 1
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: PPUSH
15597: CALL_OW 69
15601: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15602: LD_ADDR_VAR 0 10
15606: PUSH
15607: LD_VAR 0 10
15611: PPUSH
15612: LD_VAR 0 6
15616: PPUSH
15617: LD_VAR 0 7
15621: PPUSH
15622: LD_VAR 0 8
15626: PPUSH
15627: CALL 13540 0 4
15631: ST_TO_ADDR
// nearest_units_unit ( from_units , for_unit , skip , pocet , 1 , max_vzdal ) ;
15632: LD_VAR 0 10
15636: PPUSH
15637: LD_VAR 0 2
15641: PPUSH
15642: LD_VAR 0 3
15646: PPUSH
15647: LD_VAR 0 4
15651: PPUSH
15652: LD_INT 1
15654: PPUSH
15655: LD_VAR 0 5
15659: PPUSH
15660: CALL 15393 0 6
// end ;
15664: LD_VAR 0 9
15668: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
15669: LD_INT 0
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
// for i in who do
15675: LD_ADDR_VAR 0 6
15679: PUSH
15680: LD_VAR 0 1
15684: PUSH
15685: FOR_IN
15686: IFFALSE 15757
// begin for j in what do
15688: LD_ADDR_VAR 0 7
15692: PUSH
15693: LD_VAR 0 3
15697: PUSH
15698: FOR_IN
15699: IFFALSE 15753
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
15701: LD_VAR 0 7
15705: PPUSH
15706: CALL_OW 311
15710: NOT
15711: PUSH
15712: LD_VAR 0 6
15716: PPUSH
15717: LD_VAR 0 7
15721: PPUSH
15722: CALL_OW 296
15726: PUSH
15727: LD_VAR 0 2
15731: LESSEQUAL
15732: AND
15733: IFFALSE 15751
// begin ComEnterUnit ( i , j ) ;
15735: LD_VAR 0 6
15739: PPUSH
15740: LD_VAR 0 7
15744: PPUSH
15745: CALL_OW 120
// break ;
15749: GO 15753
// end ; end ;
15751: GO 15698
15753: POP
15754: POP
// end ;
15755: GO 15685
15757: POP
15758: POP
// end ;
15759: LD_VAR 0 4
15763: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
15764: LD_INT 0
15766: PPUSH
15767: PPUSH
15768: PPUSH
15769: PPUSH
// for i in who do
15770: LD_ADDR_VAR 0 6
15774: PUSH
15775: LD_VAR 0 1
15779: PUSH
15780: FOR_IN
15781: IFFALSE 15880
// begin add := false ;
15783: LD_ADDR_VAR 0 5
15787: PUSH
15788: LD_INT 0
15790: ST_TO_ADDR
// for j in what do
15791: LD_ADDR_VAR 0 7
15795: PUSH
15796: LD_VAR 0 3
15800: PUSH
15801: FOR_IN
15802: IFFALSE 15836
// begin if GetDistUnits ( i , j ) <= dist then
15804: LD_VAR 0 6
15808: PPUSH
15809: LD_VAR 0 7
15813: PPUSH
15814: CALL_OW 296
15818: PUSH
15819: LD_VAR 0 2
15823: LESSEQUAL
15824: IFFALSE 15834
// begin add := true ;
15826: LD_ADDR_VAR 0 5
15830: PUSH
15831: LD_INT 1
15833: ST_TO_ADDR
// end ; end ;
15834: GO 15801
15836: POP
15837: POP
// if add then
15838: LD_VAR 0 5
15842: IFFALSE 15878
// begin if result then
15844: LD_VAR 0 4
15848: IFFALSE 15868
// result := result ^ i else
15850: LD_ADDR_VAR 0 4
15854: PUSH
15855: LD_VAR 0 4
15859: PUSH
15860: LD_VAR 0 6
15864: ADD
15865: ST_TO_ADDR
15866: GO 15878
// result := i ;
15868: LD_ADDR_VAR 0 4
15872: PUSH
15873: LD_VAR 0 6
15877: ST_TO_ADDR
// end ; end ;
15878: GO 15780
15880: POP
15881: POP
// end ;
15882: LD_VAR 0 4
15886: RET
// export function comqb ; begin
15887: LD_INT 0
15889: PPUSH
// com_queue := true ;
15890: LD_ADDR_OWVAR 49
15894: PUSH
15895: LD_INT 1
15897: ST_TO_ADDR
// end ;
15898: LD_VAR 0 1
15902: RET
// export function comqe ; begin
15903: LD_INT 0
15905: PPUSH
// com_queue := false ;
15906: LD_ADDR_OWVAR 49
15910: PUSH
15911: LD_INT 0
15913: ST_TO_ADDR
// end ;
15914: LD_VAR 0 1
15918: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a , x , y ; begin
15919: LD_INT 0
15921: PPUSH
15922: PPUSH
15923: PPUSH
15924: PPUSH
15925: PPUSH
// for_units := UnitFilter ( for_units , [ f_alive ] ) ;
15926: LD_ADDR_VAR 0 1
15930: PUSH
15931: LD_VAR 0 1
15935: PPUSH
15936: LD_INT 51
15938: PUSH
15939: EMPTY
15940: LIST
15941: PPUSH
15942: CALL_OW 72
15946: ST_TO_ADDR
// i1 := 1 ;
15947: LD_ADDR_VAR 0 5
15951: PUSH
15952: LD_INT 1
15954: ST_TO_ADDR
// while i1 <= path do
15955: LD_VAR 0 5
15959: PUSH
15960: LD_VAR 0 2
15964: LESSEQUAL
15965: IFFALSE 16261
// begin a := path [ i1 ] ;
15967: LD_ADDR_VAR 0 6
15971: PUSH
15972: LD_VAR 0 2
15976: PUSH
15977: LD_VAR 0 5
15981: ARRAY
15982: ST_TO_ADDR
// if a < 0 then
15983: LD_VAR 0 6
15987: PUSH
15988: LD_INT 0
15990: LESS
15991: IFFALSE 16048
// begin while a <= - 1 do
15993: LD_VAR 0 6
15997: PUSH
15998: LD_INT 1
16000: NEG
16001: LESSEQUAL
16002: IFFALSE 16032
// begin a := a + 1 ;
16004: LD_ADDR_VAR 0 6
16008: PUSH
16009: LD_VAR 0 6
16013: PUSH
16014: LD_INT 1
16016: PLUS
16017: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
16018: LD_VAR 0 1
16022: PPUSH
16023: LD_INT 35
16025: PPUSH
16026: CALL_OW 202
// end ;
16030: GO 15993
// i1 := i1 + 1 ;
16032: LD_ADDR_VAR 0 5
16036: PUSH
16037: LD_VAR 0 5
16041: PUSH
16042: LD_INT 1
16044: PLUS
16045: ST_TO_ADDR
// end else
16046: GO 16259
// begin if a = 0 then
16048: LD_VAR 0 6
16052: PUSH
16053: LD_INT 0
16055: EQUAL
16056: IFFALSE 16118
// begin a := path [ i1 + 1 ] ;
16058: LD_ADDR_VAR 0 6
16062: PUSH
16063: LD_VAR 0 2
16067: PUSH
16068: LD_VAR 0 5
16072: PUSH
16073: LD_INT 1
16075: PLUS
16076: ARRAY
16077: ST_TO_ADDR
// if a = 0 then
16078: LD_VAR 0 6
16082: PUSH
16083: LD_INT 0
16085: EQUAL
16086: IFFALSE 16097
// AddComReturn ( for_units ) ;
16088: LD_VAR 0 1
16092: PPUSH
16093: CALL_OW 204
// if a = 1 then
16097: LD_VAR 0 6
16101: PUSH
16102: LD_INT 1
16104: EQUAL
16105: IFFALSE 16116
// AddComRemember ( for_units ) ;
16107: LD_VAR 0 1
16111: PPUSH
16112: CALL_OW 203
// end else
16116: GO 16245
// begin x := path [ i1 ] ;
16118: LD_ADDR_VAR 0 7
16122: PUSH
16123: LD_VAR 0 2
16127: PUSH
16128: LD_VAR 0 5
16132: ARRAY
16133: ST_TO_ADDR
// y := path [ i1 + 1 ] ;
16134: LD_ADDR_VAR 0 8
16138: PUSH
16139: LD_VAR 0 2
16143: PUSH
16144: LD_VAR 0 5
16148: PUSH
16149: LD_INT 1
16151: PLUS
16152: ARRAY
16153: ST_TO_ADDR
// if x <= 3 and y <= 3 then
16154: LD_VAR 0 7
16158: PUSH
16159: LD_INT 3
16161: LESSEQUAL
16162: PUSH
16163: LD_VAR 0 8
16167: PUSH
16168: LD_INT 3
16170: LESSEQUAL
16171: AND
16172: IFFALSE 16199
// begin Msg ( kam to jedes (take path) ) ;
16174: LD_STRING kam to jedes (take path)
16176: PPUSH
16177: CALL_OW 100
// Msg ( [ x , y ] ) ;
16181: LD_VAR 0 7
16185: PUSH
16186: LD_VAR 0 8
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PPUSH
16195: CALL_OW 100
// end ; if agressive then
16199: LD_VAR 0 3
16203: IFFALSE 16226
// AddComAgressiveMove ( for_units , x , y ) else
16205: LD_VAR 0 1
16209: PPUSH
16210: LD_VAR 0 7
16214: PPUSH
16215: LD_VAR 0 8
16219: PPUSH
16220: CALL_OW 174
16224: GO 16245
// AddComMoveXY ( for_units , x , y ) ;
16226: LD_VAR 0 1
16230: PPUSH
16231: LD_VAR 0 7
16235: PPUSH
16236: LD_VAR 0 8
16240: PPUSH
16241: CALL_OW 171
// end ; i1 := i1 + 2 ;
16245: LD_ADDR_VAR 0 5
16249: PUSH
16250: LD_VAR 0 5
16254: PUSH
16255: LD_INT 2
16257: PLUS
16258: ST_TO_ADDR
// end ; end ;
16259: GO 15955
// end ;
16261: LD_VAR 0 4
16265: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
16266: LD_INT 0
16268: PPUSH
16269: PPUSH
16270: PPUSH
16271: PPUSH
16272: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
16273: LD_ADDR_VAR 0 1
16277: PUSH
16278: LD_VAR 0 1
16282: PPUSH
16283: LD_INT 51
16285: PUSH
16286: EMPTY
16287: LIST
16288: PPUSH
16289: CALL_OW 72
16293: PUSH
16294: EMPTY
16295: UNION
16296: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
16297: LD_ADDR_VAR 0 2
16301: PUSH
16302: LD_VAR 0 2
16306: PPUSH
16307: LD_INT 51
16309: PUSH
16310: EMPTY
16311: LIST
16312: PPUSH
16313: CALL_OW 72
16317: PUSH
16318: EMPTY
16319: UNION
16320: ST_TO_ADDR
// for i in cars do
16321: LD_ADDR_VAR 0 7
16325: PUSH
16326: LD_VAR 0 1
16330: PUSH
16331: FOR_IN
16332: IFFALSE 16368
// if not IsDrivenBy ( i ) then
16334: LD_VAR 0 7
16338: PPUSH
16339: CALL_OW 311
16343: NOT
16344: IFFALSE 16366
// empty := add ( empty , i ) ;
16346: LD_ADDR_VAR 0 5
16350: PUSH
16351: LD_VAR 0 5
16355: PPUSH
16356: LD_VAR 0 7
16360: PPUSH
16361: CALL 17438 0 2
16365: ST_TO_ADDR
16366: GO 16331
16368: POP
16369: POP
// if take_out then
16370: LD_VAR 0 3
16374: IFFALSE 16433
// begin for i in drivers do
16376: LD_ADDR_VAR 0 7
16380: PUSH
16381: LD_VAR 0 2
16385: PUSH
16386: FOR_IN
16387: IFFALSE 16429
// if not ( IsInUnit ( i ) in cars ) then
16389: LD_VAR 0 7
16393: PPUSH
16394: CALL_OW 310
16398: PUSH
16399: LD_VAR 0 1
16403: IN
16404: NOT
16405: IFFALSE 16427
// free := add ( free , i ) ;
16407: LD_ADDR_VAR 0 6
16411: PUSH
16412: LD_VAR 0 6
16416: PPUSH
16417: LD_VAR 0 7
16421: PPUSH
16422: CALL 17438 0 2
16426: ST_TO_ADDR
16427: GO 16386
16429: POP
16430: POP
// end else
16431: GO 16482
// begin for i in drivers do
16433: LD_ADDR_VAR 0 7
16437: PUSH
16438: LD_VAR 0 2
16442: PUSH
16443: FOR_IN
16444: IFFALSE 16480
// if not IsInUnit ( i ) then
16446: LD_VAR 0 7
16450: PPUSH
16451: CALL_OW 310
16455: NOT
16456: IFFALSE 16478
// free := add ( free , i ) ;
16458: LD_ADDR_VAR 0 6
16462: PUSH
16463: LD_VAR 0 6
16467: PPUSH
16468: LD_VAR 0 7
16472: PPUSH
16473: CALL 17438 0 2
16477: ST_TO_ADDR
16478: GO 16443
16480: POP
16481: POP
// end ; result := cars diff empty ;
16482: LD_ADDR_VAR 0 4
16486: PUSH
16487: LD_VAR 0 1
16491: PUSH
16492: LD_VAR 0 5
16496: DIFF
16497: ST_TO_ADDR
// if empty <= free then
16498: LD_VAR 0 5
16502: PUSH
16503: LD_VAR 0 6
16507: LESSEQUAL
16508: IFFALSE 16522
// konec := empty else
16510: LD_ADDR_VAR 0 8
16514: PUSH
16515: LD_VAR 0 5
16519: ST_TO_ADDR
16520: GO 16532
// konec := free ;
16522: LD_ADDR_VAR 0 8
16526: PUSH
16527: LD_VAR 0 6
16531: ST_TO_ADDR
// for i := 1 to konec do
16532: LD_ADDR_VAR 0 7
16536: PUSH
16537: DOUBLE
16538: LD_INT 1
16540: DEC
16541: ST_TO_ADDR
16542: LD_VAR 0 8
16546: PUSH
16547: FOR_TO
16548: IFFALSE 16604
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16550: LD_VAR 0 6
16554: PUSH
16555: LD_VAR 0 7
16559: ARRAY
16560: PPUSH
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 7
16570: ARRAY
16571: PPUSH
16572: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16576: LD_ADDR_VAR 0 4
16580: PUSH
16581: LD_VAR 0 4
16585: PPUSH
16586: LD_VAR 0 5
16590: PUSH
16591: LD_VAR 0 7
16595: ARRAY
16596: PPUSH
16597: CALL 17438 0 2
16601: ST_TO_ADDR
// end ;
16602: GO 16547
16604: POP
16605: POP
// end ;
16606: LD_VAR 0 4
16610: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
16611: LD_INT 0
16613: PPUSH
16614: PPUSH
16615: PPUSH
16616: PPUSH
16617: PPUSH
// forts := forts union [ ] ;
16618: LD_ADDR_VAR 0 1
16622: PUSH
16623: LD_VAR 0 1
16627: PUSH
16628: EMPTY
16629: UNION
16630: ST_TO_ADDR
// sols := sols union [ ] ;
16631: LD_ADDR_VAR 0 2
16635: PUSH
16636: LD_VAR 0 2
16640: PUSH
16641: EMPTY
16642: UNION
16643: ST_TO_ADDR
// for i in forts do
16644: LD_ADDR_VAR 0 6
16648: PUSH
16649: LD_VAR 0 1
16653: PUSH
16654: FOR_IN
16655: IFFALSE 16691
// if not UnitsInside ( i ) then
16657: LD_VAR 0 6
16661: PPUSH
16662: CALL_OW 313
16666: NOT
16667: IFFALSE 16689
// empty := add ( empty , i ) ;
16669: LD_ADDR_VAR 0 4
16673: PUSH
16674: LD_VAR 0 4
16678: PPUSH
16679: LD_VAR 0 6
16683: PPUSH
16684: CALL 17438 0 2
16688: ST_TO_ADDR
16689: GO 16654
16691: POP
16692: POP
// for i in sols do
16693: LD_ADDR_VAR 0 6
16697: PUSH
16698: LD_VAR 0 2
16702: PUSH
16703: FOR_IN
16704: IFFALSE 16752
// if not IsInUnit ( i ) and not IsBusy ( i ) then
16706: LD_VAR 0 6
16710: PPUSH
16711: CALL_OW 310
16715: NOT
16716: PUSH
16717: LD_VAR 0 6
16721: PPUSH
16722: CALL_OW 315
16726: NOT
16727: AND
16728: IFFALSE 16750
// free := add ( free , i ) ;
16730: LD_ADDR_VAR 0 5
16734: PUSH
16735: LD_VAR 0 5
16739: PPUSH
16740: LD_VAR 0 6
16744: PPUSH
16745: CALL 17438 0 2
16749: ST_TO_ADDR
16750: GO 16703
16752: POP
16753: POP
// result := forts diff empty ;
16754: LD_ADDR_VAR 0 3
16758: PUSH
16759: LD_VAR 0 1
16763: PUSH
16764: LD_VAR 0 4
16768: DIFF
16769: ST_TO_ADDR
// if empty <= free then
16770: LD_VAR 0 4
16774: PUSH
16775: LD_VAR 0 5
16779: LESSEQUAL
16780: IFFALSE 16794
// konec := empty else
16782: LD_ADDR_VAR 0 7
16786: PUSH
16787: LD_VAR 0 4
16791: ST_TO_ADDR
16792: GO 16804
// konec := free ;
16794: LD_ADDR_VAR 0 7
16798: PUSH
16799: LD_VAR 0 5
16803: ST_TO_ADDR
// for i := 1 to konec do
16804: LD_ADDR_VAR 0 6
16808: PUSH
16809: DOUBLE
16810: LD_INT 1
16812: DEC
16813: ST_TO_ADDR
16814: LD_VAR 0 7
16818: PUSH
16819: FOR_TO
16820: IFFALSE 16876
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16822: LD_VAR 0 5
16826: PUSH
16827: LD_VAR 0 6
16831: ARRAY
16832: PPUSH
16833: LD_VAR 0 4
16837: PUSH
16838: LD_VAR 0 6
16842: ARRAY
16843: PPUSH
16844: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16848: LD_ADDR_VAR 0 3
16852: PUSH
16853: LD_VAR 0 3
16857: PPUSH
16858: LD_VAR 0 4
16862: PUSH
16863: LD_VAR 0 6
16867: ARRAY
16868: PPUSH
16869: CALL 17438 0 2
16873: ST_TO_ADDR
// end ;
16874: GO 16819
16876: POP
16877: POP
// end ;
16878: LD_VAR 0 3
16882: RET
// export function depart ( cars , drivers , path , argessive , take_out ) ; var pojedou ; begin
16883: LD_INT 0
16885: PPUSH
16886: PPUSH
// pojedou := find_drivers ( cars , drivers , take_out ) ;
16887: LD_ADDR_VAR 0 7
16891: PUSH
16892: LD_VAR 0 1
16896: PPUSH
16897: LD_VAR 0 2
16901: PPUSH
16902: LD_VAR 0 5
16906: PPUSH
16907: CALL 16266 0 3
16911: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
16912: LD_VAR 0 7
16916: PPUSH
16917: CALL 16945 0 1
// take_path ( pojedou , path , argessive ) ;
16921: LD_VAR 0 7
16925: PPUSH
16926: LD_VAR 0 3
16930: PPUSH
16931: LD_VAR 0 4
16935: PPUSH
16936: CALL 15919 0 3
// end ;
16940: LD_VAR 0 6
16944: RET
// export function wait_for_drivers ( cars ) ; var i , vsichni_ready , k ; begin
16945: LD_INT 0
16947: PPUSH
16948: PPUSH
16949: PPUSH
16950: PPUSH
// k := 0 ;
16951: LD_ADDR_VAR 0 5
16955: PUSH
16956: LD_INT 0
16958: ST_TO_ADDR
// while not vsichni_ready do
16959: LD_VAR 0 4
16963: NOT
16964: IFFALSE 17034
// begin vsichni_ready := true ;
16966: LD_ADDR_VAR 0 4
16970: PUSH
16971: LD_INT 1
16973: ST_TO_ADDR
// k := k + 1 ;
16974: LD_ADDR_VAR 0 5
16978: PUSH
16979: LD_VAR 0 5
16983: PUSH
16984: LD_INT 1
16986: PLUS
16987: ST_TO_ADDR
// for i in cars do
16988: LD_ADDR_VAR 0 3
16992: PUSH
16993: LD_VAR 0 1
16997: PUSH
16998: FOR_IN
16999: IFFALSE 17023
// if not IsDrivenBy ( i ) then
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 311
17010: NOT
17011: IFFALSE 17021
// vsichni_ready := false ;
17013: LD_ADDR_VAR 0 4
17017: PUSH
17018: LD_INT 0
17020: ST_TO_ADDR
17021: GO 16998
17023: POP
17024: POP
// wait ( 0 0$1.0 ) ;
17025: LD_INT 35
17027: PPUSH
17028: CALL_OW 67
// end ;
17032: GO 16959
// end ;
17034: LD_VAR 0 2
17038: RET
// export function rand_xy_in_map ; var x , y ; begin
17039: LD_INT 0
17041: PPUSH
17042: PPUSH
17043: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
17044: LD_ADDR_VAR 0 3
17048: PUSH
17049: LD_INT 2
17051: PPUSH
17052: LD_EXP 54
17056: PUSH
17057: LD_INT 2
17059: MINUS
17060: PPUSH
17061: CALL_OW 12
17065: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
17066: LD_ADDR_VAR 0 2
17070: PUSH
17071: LD_VAR 0 3
17075: PUSH
17076: LD_INT 2
17078: DIV
17079: PUSH
17080: LD_INT 2
17082: PLUS
17083: PPUSH
17084: LD_EXP 53
17088: PUSH
17089: LD_VAR 0 3
17093: PUSH
17094: LD_INT 2
17096: DIV
17097: PLUS
17098: PUSH
17099: LD_INT 2
17101: MINUS
17102: PPUSH
17103: CALL_OW 12
17107: ST_TO_ADDR
// result := [ x , y ] ;
17108: LD_ADDR_VAR 0 1
17112: PUSH
17113: LD_VAR 0 2
17117: PUSH
17118: LD_VAR 0 3
17122: PUSH
17123: EMPTY
17124: LIST
17125: LIST
17126: ST_TO_ADDR
// end ;
17127: LD_VAR 0 1
17131: RET
// export function TalkOn ; begin
17132: LD_INT 0
17134: PPUSH
// stop_talking := true ;
17135: LD_ADDR_OWVAR 56
17139: PUSH
17140: LD_INT 1
17142: ST_TO_ADDR
// end ;
17143: LD_VAR 0 1
17147: RET
// export function TalkOff ; begin
17148: LD_INT 0
17150: PPUSH
// stop_talking := false ;
17151: LD_ADDR_OWVAR 56
17155: PUSH
17156: LD_INT 0
17158: ST_TO_ADDR
// end ;
17159: LD_VAR 0 1
17163: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
17164: LD_INT 0
17166: PPUSH
17167: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
17168: LD_ADDR_VAR 0 8
17172: PUSH
17173: LD_VAR 0 1
17177: PPUSH
17178: LD_VAR 0 3
17182: PPUSH
17183: LD_VAR 0 4
17187: PPUSH
17188: LD_VAR 0 5
17192: PPUSH
17193: LD_VAR 0 6
17197: PPUSH
17198: CALL 17244 0 5
17202: ST_TO_ADDR
// if kdo then
17203: LD_VAR 0 8
17207: IFFALSE 17231
// result := Say ( kdo , ident ) else
17209: LD_ADDR_VAR 0 7
17213: PUSH
17214: LD_VAR 0 8
17218: PPUSH
17219: LD_VAR 0 2
17223: PPUSH
17224: CALL_OW 88
17228: ST_TO_ADDR
17229: GO 17239
// result := false ;
17231: LD_ADDR_VAR 0 7
17235: PUSH
17236: LD_INT 0
17238: ST_TO_ADDR
// end ;
17239: LD_VAR 0 7
17243: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
17244: LD_INT 0
17246: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
17247: LD_ADDR_VAR 0 1
17251: PUSH
17252: LD_VAR 0 1
17256: PPUSH
17257: LD_INT 21
17259: PUSH
17260: LD_INT 1
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PUSH
17267: LD_INT 22
17269: PUSH
17270: LD_VAR 0 2
17274: PUSH
17275: EMPTY
17276: LIST
17277: LIST
17278: PUSH
17279: LD_INT 3
17281: PUSH
17282: LD_INT 23
17284: PUSH
17285: LD_INT 0
17287: PUSH
17288: EMPTY
17289: LIST
17290: LIST
17291: PUSH
17292: EMPTY
17293: LIST
17294: LIST
17295: LIST
17296: LIST
17297: PPUSH
17298: CALL_OW 72
17302: ST_TO_ADDR
// if sex <> 0 then
17303: LD_VAR 0 3
17307: PUSH
17308: LD_INT 0
17310: NONEQUAL
17311: IFFALSE 17340
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
17313: LD_ADDR_VAR 0 1
17317: PUSH
17318: LD_VAR 0 1
17322: PPUSH
17323: LD_INT 26
17325: PUSH
17326: LD_VAR 0 3
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: PPUSH
17335: CALL_OW 72
17339: ST_TO_ADDR
// if Hclass <> 0 then
17340: LD_VAR 0 4
17344: PUSH
17345: LD_INT 0
17347: NONEQUAL
17348: IFFALSE 17377
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
17350: LD_ADDR_VAR 0 1
17354: PUSH
17355: LD_VAR 0 1
17359: PPUSH
17360: LD_INT 25
17362: PUSH
17363: LD_VAR 0 4
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: PPUSH
17372: CALL_OW 72
17376: ST_TO_ADDR
// if index <= 0 then
17377: LD_VAR 0 5
17381: PUSH
17382: LD_INT 0
17384: LESSEQUAL
17385: IFFALSE 17395
// index := 1 ;
17387: LD_ADDR_VAR 0 5
17391: PUSH
17392: LD_INT 1
17394: ST_TO_ADDR
// if lidi >= index then
17395: LD_VAR 0 1
17399: PUSH
17400: LD_VAR 0 5
17404: GREATEREQUAL
17405: IFFALSE 17425
// result := lidi [ index ] else
17407: LD_ADDR_VAR 0 6
17411: PUSH
17412: LD_VAR 0 1
17416: PUSH
17417: LD_VAR 0 5
17421: ARRAY
17422: ST_TO_ADDR
17423: GO 17433
// result := 0 ;
17425: LD_ADDR_VAR 0 6
17429: PUSH
17430: LD_INT 0
17432: ST_TO_ADDR
// end ;
17433: LD_VAR 0 6
17437: RET
// export function add ( list , list1 ) ; begin
17438: LD_INT 0
17440: PPUSH
// if list = 0 then
17441: LD_VAR 0 1
17445: PUSH
17446: LD_INT 0
17448: EQUAL
17449: IFFALSE 17458
// list := [ ] ;
17451: LD_ADDR_VAR 0 1
17455: PUSH
17456: EMPTY
17457: ST_TO_ADDR
// if list1 = 0 then
17458: LD_VAR 0 2
17462: PUSH
17463: LD_INT 0
17465: EQUAL
17466: IFFALSE 17475
// list1 := [ ] ;
17468: LD_ADDR_VAR 0 2
17472: PUSH
17473: EMPTY
17474: ST_TO_ADDR
// result := list ^ list1 ;
17475: LD_ADDR_VAR 0 3
17479: PUSH
17480: LD_VAR 0 1
17484: PUSH
17485: LD_VAR 0 2
17489: ADD
17490: ST_TO_ADDR
// end ;
17491: LD_VAR 0 3
17495: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
17496: LD_INT 0
17498: PPUSH
17499: PPUSH
17500: PPUSH
17501: PPUSH
// l1 := [ ] ;
17502: LD_ADDR_VAR 0 3
17506: PUSH
17507: EMPTY
17508: ST_TO_ADDR
// l2 := [ ] ;
17509: LD_ADDR_VAR 0 4
17513: PUSH
17514: EMPTY
17515: ST_TO_ADDR
// for i := 1 to list div 2 do
17516: LD_ADDR_VAR 0 5
17520: PUSH
17521: DOUBLE
17522: LD_INT 1
17524: DEC
17525: ST_TO_ADDR
17526: LD_VAR 0 1
17530: PUSH
17531: LD_INT 2
17533: DIV
17534: PUSH
17535: FOR_TO
17536: IFFALSE 17562
// begin l1 := l1 ^ list [ i ] ;
17538: LD_ADDR_VAR 0 3
17542: PUSH
17543: LD_VAR 0 3
17547: PUSH
17548: LD_VAR 0 1
17552: PUSH
17553: LD_VAR 0 5
17557: ARRAY
17558: ADD
17559: ST_TO_ADDR
// end ;
17560: GO 17535
17562: POP
17563: POP
// l2 := list diff l1 ;
17564: LD_ADDR_VAR 0 4
17568: PUSH
17569: LD_VAR 0 1
17573: PUSH
17574: LD_VAR 0 3
17578: DIFF
17579: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
17580: LD_ADDR_VAR 0 2
17584: PUSH
17585: LD_VAR 0 3
17589: PUSH
17590: EMPTY
17591: LIST
17592: PUSH
17593: LD_VAR 0 4
17597: PUSH
17598: EMPTY
17599: LIST
17600: ADD
17601: ST_TO_ADDR
// end ;
17602: LD_VAR 0 2
17606: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
17607: LD_INT 0
17609: PPUSH
// if not hinty_co_byli then
17610: LD_EXP 88
17614: NOT
17615: IFFALSE 17624
// hinty_co_byli := [ ] ;
17617: LD_ADDR_EXP 88
17621: PUSH
17622: EMPTY
17623: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
17624: LD_VAR 0 1
17628: PUSH
17629: LD_EXP 88
17633: IN
17634: NOT
17635: IFFALSE 17662
// begin hinty_co_byli := hinty_co_byli ^ ident ;
17637: LD_ADDR_EXP 88
17641: PUSH
17642: LD_EXP 88
17646: PUSH
17647: LD_VAR 0 1
17651: ADD
17652: ST_TO_ADDR
// Hint ( ident ) ;
17653: LD_VAR 0 1
17657: PPUSH
17658: CALL_OW 339
// end ; end ; end_of_file
17662: LD_VAR 0 2
17666: RET
// export people , sol , sci , mec , eng ; var cars , cargo , scout , attack , defence ; var scout1 , scout2 ; var builds , forts ; var scout1_pb , scout1_pr , scout1_ptr1 , scout1_ptl1 , scout1_ptr2 , scout1_pta , scout1_pl , scout1_pa , scout1_pd1 , scout1_pd2 ; var broken ; var attack_l , attack_m , attack_r ; var to_defence , to_attack , to_scout , to_cargo ; var sec ; every 0 0$0.1 do var temp1 ;
17667: GO 17669
17669: DISABLE
17670: LD_INT 0
17672: PPUSH
// begin to_defence := false ;
17673: LD_ADDR_LOC 25
17677: PUSH
17678: LD_INT 0
17680: ST_TO_ADDR
// to_attack := false ;
17681: LD_ADDR_LOC 26
17685: PUSH
17686: LD_INT 0
17688: ST_TO_ADDR
// to_scout := false ;
17689: LD_ADDR_LOC 27
17693: PUSH
17694: LD_INT 0
17696: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ f_side , russians ] ) ;
17697: LD_ADDR_VAR 0 1
17701: PUSH
17702: LD_INT 22
17704: PUSH
17705: LD_EXP 2
17709: PUSH
17710: EMPTY
17711: LIST
17712: LIST
17713: PPUSH
17714: CALL_OW 69
17718: ST_TO_ADDR
// ComRemember ( temp1 ) ;
17719: LD_VAR 0 1
17723: PPUSH
17724: CALL_OW 143
// people := UnitFilter ( temp1 , [ f_type , unit_human ] ) ;
17728: LD_ADDR_EXP 89
17732: PUSH
17733: LD_VAR 0 1
17737: PPUSH
17738: LD_INT 21
17740: PUSH
17741: LD_INT 1
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: PPUSH
17748: CALL_OW 72
17752: ST_TO_ADDR
// sol := UnitFilter ( people , [ f_class , class_soldier ] ) ;
17753: LD_ADDR_EXP 90
17757: PUSH
17758: LD_EXP 89
17762: PPUSH
17763: LD_INT 25
17765: PUSH
17766: LD_INT 1
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PPUSH
17773: CALL_OW 72
17777: ST_TO_ADDR
// sci := UnitFilter ( people , [ f_class , class_scientistic ] ) ;
17778: LD_ADDR_EXP 91
17782: PUSH
17783: LD_EXP 89
17787: PPUSH
17788: LD_INT 25
17790: PUSH
17791: LD_INT 4
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: PPUSH
17798: CALL_OW 72
17802: ST_TO_ADDR
// mec := UnitFilter ( people , [ f_class , class_mechanic ] ) ;
17803: LD_ADDR_EXP 92
17807: PUSH
17808: LD_EXP 89
17812: PPUSH
17813: LD_INT 25
17815: PUSH
17816: LD_INT 3
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PPUSH
17823: CALL_OW 72
17827: ST_TO_ADDR
// eng := UnitFilter ( people , [ f_class , class_engineer ] ) ;
17828: LD_ADDR_EXP 93
17832: PUSH
17833: LD_EXP 89
17837: PPUSH
17838: LD_INT 25
17840: PUSH
17841: LD_INT 2
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: PPUSH
17848: CALL_OW 72
17852: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ f_type , unit_vehicle ] ) ;
17853: LD_ADDR_LOC 2
17857: PUSH
17858: LD_VAR 0 1
17862: PPUSH
17863: LD_INT 21
17865: PUSH
17866: LD_INT 2
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: PPUSH
17873: CALL_OW 72
17877: ST_TO_ADDR
// broken := [ ] ;
17878: LD_ADDR_LOC 21
17882: PUSH
17883: EMPTY
17884: ST_TO_ADDR
// cargo := [ cargo_1 ] ;
17885: LD_ADDR_LOC 3
17889: PUSH
17890: LD_INT 11
17892: PUSH
17893: EMPTY
17894: LIST
17895: ST_TO_ADDR
// scout := [ scout_1 , scout_2 ] ;
17896: LD_ADDR_LOC 4
17900: PUSH
17901: LD_INT 10
17903: PUSH
17904: LD_INT 42
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: ST_TO_ADDR
// scout1 := [ scout_1 ] ;
17911: LD_ADDR_LOC 7
17915: PUSH
17916: LD_INT 10
17918: PUSH
17919: EMPTY
17920: LIST
17921: ST_TO_ADDR
// scout2 := [ scout_2 ] ;
17922: LD_ADDR_LOC 8
17926: PUSH
17927: LD_INT 42
17929: PUSH
17930: EMPTY
17931: LIST
17932: ST_TO_ADDR
// defence := [ scout_2 , defence_1 , defence_2 ] ;
17933: LD_ADDR_LOC 6
17937: PUSH
17938: LD_INT 42
17940: PUSH
17941: LD_INT 12
17943: PUSH
17944: LD_INT 43
17946: PUSH
17947: EMPTY
17948: LIST
17949: LIST
17950: LIST
17951: ST_TO_ADDR
// attack := [ scout_1 , scout_2 , defence_1 ] ;
17952: LD_ADDR_LOC 5
17956: PUSH
17957: LD_INT 10
17959: PUSH
17960: LD_INT 42
17962: PUSH
17963: LD_INT 12
17965: PUSH
17966: EMPTY
17967: LIST
17968: LIST
17969: LIST
17970: ST_TO_ADDR
// builds := UnitFilter ( temp1 , [ f_type , unit_building ] ) ;
17971: LD_ADDR_LOC 9
17975: PUSH
17976: LD_VAR 0 1
17980: PPUSH
17981: LD_INT 21
17983: PUSH
17984: LD_INT 3
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: PPUSH
17991: CALL_OW 72
17995: ST_TO_ADDR
// forts := [ fort1 , fort2 , fort3 , fort4 , fort5 ] ;
17996: LD_ADDR_LOC 10
18000: PUSH
18001: LD_INT 3
18003: PUSH
18004: LD_INT 2
18006: PUSH
18007: LD_INT 39
18009: PUSH
18010: LD_INT 4
18012: PUSH
18013: LD_INT 45
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: ST_TO_ADDR
// scout1_pb := [ 92 , 53 ] ;
18023: LD_ADDR_LOC 11
18027: PUSH
18028: LD_INT 92
18030: PUSH
18031: LD_INT 53
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: ST_TO_ADDR
// scout1_pr := [ 102 , 56 , 110 , 59 , 119 , 60 , 120 , 64 , 109 , 60 , 98 , 55 ] ;
18038: LD_ADDR_LOC 12
18042: PUSH
18043: LD_INT 102
18045: PUSH
18046: LD_INT 56
18048: PUSH
18049: LD_INT 110
18051: PUSH
18052: LD_INT 59
18054: PUSH
18055: LD_INT 119
18057: PUSH
18058: LD_INT 60
18060: PUSH
18061: LD_INT 120
18063: PUSH
18064: LD_INT 64
18066: PUSH
18067: LD_INT 109
18069: PUSH
18070: LD_INT 60
18072: PUSH
18073: LD_INT 98
18075: PUSH
18076: LD_INT 55
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: ST_TO_ADDR
// scout1_ptr1 := [ 95 , 50 , 92 , 46 , 90 , 39 , 87 , 30 , - 8 , 97 , 25 , 80 , 32 , 82 , 42 ] ;
18093: LD_ADDR_LOC 13
18097: PUSH
18098: LD_INT 95
18100: PUSH
18101: LD_INT 50
18103: PUSH
18104: LD_INT 92
18106: PUSH
18107: LD_INT 46
18109: PUSH
18110: LD_INT 90
18112: PUSH
18113: LD_INT 39
18115: PUSH
18116: LD_INT 87
18118: PUSH
18119: LD_INT 30
18121: PUSH
18122: LD_INT 8
18124: NEG
18125: PUSH
18126: LD_INT 97
18128: PUSH
18129: LD_INT 25
18131: PUSH
18132: LD_INT 80
18134: PUSH
18135: LD_INT 32
18137: PUSH
18138: LD_INT 82
18140: PUSH
18141: LD_INT 42
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: LIST
18151: LIST
18152: LIST
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: LIST
18160: ST_TO_ADDR
// scout1_ptr2 := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 69 , 21 , 82 , 39 , 87 , 48 ] ;
18161: LD_ADDR_LOC 15
18165: PUSH
18166: LD_INT 90
18168: PUSH
18169: LD_INT 42
18171: PUSH
18172: LD_INT 91
18174: PUSH
18175: LD_INT 30
18177: PUSH
18178: LD_INT 81
18180: PUSH
18181: LD_INT 13
18183: PUSH
18184: LD_INT 68
18186: PUSH
18187: LD_INT 12
18189: PUSH
18190: LD_INT 67
18192: PUSH
18193: LD_INT 21
18195: PUSH
18196: LD_INT 57
18198: PUSH
18199: LD_INT 25
18201: PUSH
18202: LD_INT 69
18204: PUSH
18205: LD_INT 21
18207: PUSH
18208: LD_INT 82
18210: PUSH
18211: LD_INT 39
18213: PUSH
18214: LD_INT 87
18216: PUSH
18217: LD_INT 48
18219: PUSH
18220: EMPTY
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: ST_TO_ADDR
// scout1_pta := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 41 , 20 , 29 , 23 , 42 , 41 , 85 , 49 ] ;
18240: LD_ADDR_LOC 16
18244: PUSH
18245: LD_INT 90
18247: PUSH
18248: LD_INT 42
18250: PUSH
18251: LD_INT 91
18253: PUSH
18254: LD_INT 30
18256: PUSH
18257: LD_INT 81
18259: PUSH
18260: LD_INT 13
18262: PUSH
18263: LD_INT 68
18265: PUSH
18266: LD_INT 12
18268: PUSH
18269: LD_INT 67
18271: PUSH
18272: LD_INT 21
18274: PUSH
18275: LD_INT 57
18277: PUSH
18278: LD_INT 25
18280: PUSH
18281: LD_INT 41
18283: PUSH
18284: LD_INT 20
18286: PUSH
18287: LD_INT 29
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 42
18295: PUSH
18296: LD_INT 41
18298: PUSH
18299: LD_INT 85
18301: PUSH
18302: LD_INT 49
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: LIST
18309: LIST
18310: LIST
18311: LIST
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: LIST
18326: ST_TO_ADDR
// scout1_ptl1 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 30 , 25 , 31 , 16 , 34 , 36 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18327: LD_ADDR_LOC 14
18331: PUSH
18332: LD_INT 68
18334: PUSH
18335: LD_INT 88
18337: PUSH
18338: LD_INT 51
18340: PUSH
18341: LD_INT 78
18343: PUSH
18344: LD_INT 40
18346: PUSH
18347: LD_INT 57
18349: PUSH
18350: LD_INT 43
18352: PUSH
18353: LD_INT 42
18355: PUSH
18356: LD_INT 30
18358: PUSH
18359: LD_INT 25
18361: PUSH
18362: LD_INT 31
18364: PUSH
18365: LD_INT 16
18367: PUSH
18368: LD_INT 34
18370: PUSH
18371: LD_INT 36
18373: PUSH
18374: LD_INT 45
18376: PUSH
18377: LD_INT 69
18379: PUSH
18380: LD_INT 64
18382: PUSH
18383: LD_INT 87
18385: PUSH
18386: LD_INT 98
18388: PUSH
18389: LD_INT 97
18391: PUSH
18392: EMPTY
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// scout1_pl := [ 84 , 50 , 70 , 47 , 67 , 46 , 62 , 49 , 55 , 49 , - 5 , 50 , 43 , 60 , 49 , 71 , 47 , 83 , 49 ] ;
18414: LD_ADDR_LOC 17
18418: PUSH
18419: LD_INT 84
18421: PUSH
18422: LD_INT 50
18424: PUSH
18425: LD_INT 70
18427: PUSH
18428: LD_INT 47
18430: PUSH
18431: LD_INT 67
18433: PUSH
18434: LD_INT 46
18436: PUSH
18437: LD_INT 62
18439: PUSH
18440: LD_INT 49
18442: PUSH
18443: LD_INT 55
18445: PUSH
18446: LD_INT 49
18448: PUSH
18449: LD_INT 5
18451: NEG
18452: PUSH
18453: LD_INT 50
18455: PUSH
18456: LD_INT 43
18458: PUSH
18459: LD_INT 60
18461: PUSH
18462: LD_INT 49
18464: PUSH
18465: LD_INT 71
18467: PUSH
18468: LD_INT 47
18470: PUSH
18471: LD_INT 83
18473: PUSH
18474: LD_INT 49
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: LIST
18486: LIST
18487: LIST
18488: LIST
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: LIST
18496: LIST
18497: ST_TO_ADDR
// scout1_pa := [ 84 , 50 , 70 , 47 , 60 , 44 , 53 , 44 , 43 , 41 , 39 , 57 , 43 , 71 , 52 , 82 , 63 , 87 , 109 , 95 ] ;
18498: LD_ADDR_LOC 18
18502: PUSH
18503: LD_INT 84
18505: PUSH
18506: LD_INT 50
18508: PUSH
18509: LD_INT 70
18511: PUSH
18512: LD_INT 47
18514: PUSH
18515: LD_INT 60
18517: PUSH
18518: LD_INT 44
18520: PUSH
18521: LD_INT 53
18523: PUSH
18524: LD_INT 44
18526: PUSH
18527: LD_INT 43
18529: PUSH
18530: LD_INT 41
18532: PUSH
18533: LD_INT 39
18535: PUSH
18536: LD_INT 57
18538: PUSH
18539: LD_INT 43
18541: PUSH
18542: LD_INT 71
18544: PUSH
18545: LD_INT 52
18547: PUSH
18548: LD_INT 82
18550: PUSH
18551: LD_INT 63
18553: PUSH
18554: LD_INT 87
18556: PUSH
18557: LD_INT 109
18559: PUSH
18560: LD_INT 95
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: LIST
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: ST_TO_ADDR
// scout1_pd1 := [ 71 , 81 , 62 , 63 , 61 , 74 , 79 , 96 ] ;
18585: LD_ADDR_LOC 19
18589: PUSH
18590: LD_INT 71
18592: PUSH
18593: LD_INT 81
18595: PUSH
18596: LD_INT 62
18598: PUSH
18599: LD_INT 63
18601: PUSH
18602: LD_INT 61
18604: PUSH
18605: LD_INT 74
18607: PUSH
18608: LD_INT 79
18610: PUSH
18611: LD_INT 96
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: ST_TO_ADDR
// scout1_pd2 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18624: LD_ADDR_LOC 20
18628: PUSH
18629: LD_INT 68
18631: PUSH
18632: LD_INT 88
18634: PUSH
18635: LD_INT 51
18637: PUSH
18638: LD_INT 78
18640: PUSH
18641: LD_INT 40
18643: PUSH
18644: LD_INT 57
18646: PUSH
18647: LD_INT 43
18649: PUSH
18650: LD_INT 42
18652: PUSH
18653: LD_INT 45
18655: PUSH
18656: LD_INT 69
18658: PUSH
18659: LD_INT 64
18661: PUSH
18662: LD_INT 87
18664: PUSH
18665: LD_INT 98
18667: PUSH
18668: LD_INT 97
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: LIST
18675: LIST
18676: LIST
18677: LIST
18678: LIST
18679: LIST
18680: LIST
18681: LIST
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: ST_TO_ADDR
// attack_l := [ 60 , 86 , 37 , 44 ] ;
18687: LD_ADDR_LOC 22
18691: PUSH
18692: LD_INT 60
18694: PUSH
18695: LD_INT 86
18697: PUSH
18698: LD_INT 37
18700: PUSH
18701: LD_INT 44
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
// attack_m := [ 89 , 53 , 41 , 42 ] ;
18710: LD_ADDR_LOC 23
18714: PUSH
18715: LD_INT 89
18717: PUSH
18718: LD_INT 53
18720: PUSH
18721: LD_INT 41
18723: PUSH
18724: LD_INT 42
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: ST_TO_ADDR
// attack_r := [ 88 , 55 , 82 , 13 ] ;
18733: LD_ADDR_LOC 24
18737: PUSH
18738: LD_INT 88
18740: PUSH
18741: LD_INT 55
18743: PUSH
18744: LD_INT 82
18746: PUSH
18747: LD_INT 13
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: LIST
18754: LIST
18755: ST_TO_ADDR
// end ;
18756: PPOPN 1
18758: END
// every 0 0$6.0 do
18759: GO 18761
18761: DISABLE
// begin depart ( scout diff broken , sol union mec , scout1_pb , true , false ) ;
18762: LD_LOC 4
18766: PUSH
18767: LD_LOC 21
18771: DIFF
18772: PPUSH
18773: LD_EXP 90
18777: PUSH
18778: LD_EXP 92
18782: UNION
18783: PPUSH
18784: LD_LOC 11
18788: PPUSH
18789: LD_INT 1
18791: PPUSH
18792: LD_INT 0
18794: PPUSH
18795: CALL 16883 0 5
// take_path ( scout1 diff broken , scout1_pr , true ) ;
18799: LD_LOC 7
18803: PUSH
18804: LD_LOC 21
18808: DIFF
18809: PPUSH
18810: LD_LOC 12
18814: PPUSH
18815: LD_INT 1
18817: PPUSH
18818: CALL 15919 0 3
// take_path ( scout2 diff broken , scout1_pl , true ) ;
18822: LD_LOC 8
18826: PUSH
18827: LD_LOC 21
18831: DIFF
18832: PPUSH
18833: LD_LOC 17
18837: PPUSH
18838: LD_INT 1
18840: PPUSH
18841: CALL 15919 0 3
// AddComReturn ( scout diff broken ) ;
18845: LD_LOC 4
18849: PUSH
18850: LD_LOC 21
18854: DIFF
18855: PPUSH
18856: CALL_OW 204
// end ;
18860: END
// every 0 0$56.0 + 0 0$10 do var x , ok , i ;
18861: GO 18863
18863: DISABLE
18864: LD_INT 0
18866: PPUSH
18867: PPUSH
18868: PPUSH
// begin ok := true ;
18869: LD_ADDR_VAR 0 2
18873: PUSH
18874: LD_INT 1
18876: ST_TO_ADDR
// for i in scout do
18877: LD_ADDR_VAR 0 3
18881: PUSH
18882: LD_LOC 4
18886: PUSH
18887: FOR_IN
18888: IFFALSE 18911
// begin if HasTask ( i ) then
18890: LD_VAR 0 3
18894: PPUSH
18895: CALL_OW 314
18899: IFFALSE 18909
// ok := false ;
18901: LD_ADDR_VAR 0 2
18905: PUSH
18906: LD_INT 0
18908: ST_TO_ADDR
// end ;
18909: GO 18887
18911: POP
18912: POP
// if ok then
18913: LD_VAR 0 2
18917: IFFALSE 19809
// begin x := Rand ( 1 , 7 ) ;
18919: LD_ADDR_VAR 0 1
18923: PUSH
18924: LD_INT 1
18926: PPUSH
18927: LD_INT 7
18929: PPUSH
18930: CALL_OW 12
18934: ST_TO_ADDR
// if go_up then
18935: LD_EXP 62
18939: IFFALSE 18965
// begin x := Rand ( 3 , 4 ) ;
18941: LD_ADDR_VAR 0 1
18945: PUSH
18946: LD_INT 3
18948: PPUSH
18949: LD_INT 4
18951: PPUSH
18952: CALL_OW 12
18956: ST_TO_ADDR
// go_up := false ;
18957: LD_ADDR_EXP 62
18961: PUSH
18962: LD_INT 0
18964: ST_TO_ADDR
// end ; case x of 1 :
18965: LD_VAR 0 1
18969: PUSH
18970: LD_INT 1
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19110
18978: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
18979: LD_LOC 7
18983: PUSH
18984: LD_LOC 21
18988: DIFF
18989: PPUSH
18990: LD_EXP 90
18994: PPUSH
18995: LD_LOC 11
18999: PPUSH
19000: LD_INT 1
19002: PPUSH
19003: LD_INT 0
19005: PPUSH
19006: CALL 16883 0 5
// if more_scouting then
19010: LD_EXP 61
19014: IFFALSE 19039
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19016: LD_LOC 7
19020: PUSH
19021: LD_LOC 21
19025: DIFF
19026: PPUSH
19027: LD_LOC 13
19031: PPUSH
19032: LD_INT 1
19034: PPUSH
19035: CALL 15919 0 3
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19039: LD_LOC 7
19043: PUSH
19044: LD_LOC 21
19048: DIFF
19049: PPUSH
19050: LD_LOC 17
19054: PPUSH
19055: LD_INT 1
19057: PPUSH
19058: CALL 15919 0 3
// depart ( scout2 diff broken , sol , scout1_pd1 , true , false ) ;
19062: LD_LOC 8
19066: PUSH
19067: LD_LOC 21
19071: DIFF
19072: PPUSH
19073: LD_EXP 90
19077: PPUSH
19078: LD_LOC 19
19082: PPUSH
19083: LD_INT 1
19085: PPUSH
19086: LD_INT 0
19088: PPUSH
19089: CALL 16883 0 5
// AddComReturn ( scout diff broken ) ;
19093: LD_LOC 4
19097: PUSH
19098: LD_LOC 21
19102: DIFF
19103: PPUSH
19104: CALL_OW 204
// end ; 2 :
19108: GO 19809
19110: LD_INT 2
19112: DOUBLE
19113: EQUAL
19114: IFTRUE 19118
19116: GO 19227
19118: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
19119: LD_LOC 7
19123: PUSH
19124: LD_LOC 21
19128: DIFF
19129: PPUSH
19130: LD_EXP 90
19134: PPUSH
19135: LD_LOC 11
19139: PPUSH
19140: LD_INT 1
19142: PPUSH
19143: LD_INT 0
19145: PPUSH
19146: CALL 16883 0 5
// if more_scouting then
19150: LD_EXP 61
19154: IFFALSE 19179
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19156: LD_LOC 7
19160: PUSH
19161: LD_LOC 21
19165: DIFF
19166: PPUSH
19167: LD_LOC 13
19171: PPUSH
19172: LD_INT 1
19174: PPUSH
19175: CALL 15919 0 3
// depart ( scout2 diff broken , sol , scout1_pd2 , true , false ) ;
19179: LD_LOC 8
19183: PUSH
19184: LD_LOC 21
19188: DIFF
19189: PPUSH
19190: LD_EXP 90
19194: PPUSH
19195: LD_LOC 20
19199: PPUSH
19200: LD_INT 1
19202: PPUSH
19203: LD_INT 0
19205: PPUSH
19206: CALL 16883 0 5
// AddComReturn ( scout1 diff broken ) ;
19210: LD_LOC 7
19214: PUSH
19215: LD_LOC 21
19219: DIFF
19220: PPUSH
19221: CALL_OW 204
// end ; 3 :
19225: GO 19809
19227: LD_INT 3
19229: DOUBLE
19230: EQUAL
19231: IFTRUE 19235
19233: GO 19313
19235: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19236: LD_LOC 4
19240: PUSH
19241: LD_LOC 21
19245: DIFF
19246: PPUSH
19247: LD_EXP 90
19251: PPUSH
19252: LD_LOC 11
19256: PPUSH
19257: LD_INT 1
19259: PPUSH
19260: LD_INT 0
19262: PPUSH
19263: CALL 16883 0 5
// if more_scouting then
19267: LD_EXP 61
19271: IFFALSE 19296
// take_path ( scout diff broken , scout1_ptr2 , true ) ;
19273: LD_LOC 4
19277: PUSH
19278: LD_LOC 21
19282: DIFF
19283: PPUSH
19284: LD_LOC 15
19288: PPUSH
19289: LD_INT 1
19291: PPUSH
19292: CALL 15919 0 3
// AddComReturn ( scout diff broken ) ;
19296: LD_LOC 4
19300: PUSH
19301: LD_LOC 21
19305: DIFF
19306: PPUSH
19307: CALL_OW 204
// end ; 4 :
19311: GO 19809
19313: LD_INT 4
19315: DOUBLE
19316: EQUAL
19317: IFTRUE 19321
19319: GO 19440
19321: POP
// begin if more_scouting then
19322: LD_EXP 61
19326: IFFALSE 19361
// depart ( scout diff broken , sol , scout1_pta , true , false ) else
19328: LD_LOC 4
19332: PUSH
19333: LD_LOC 21
19337: DIFF
19338: PPUSH
19339: LD_EXP 90
19343: PPUSH
19344: LD_LOC 16
19348: PPUSH
19349: LD_INT 1
19351: PPUSH
19352: LD_INT 0
19354: PPUSH
19355: CALL 16883 0 5
19359: GO 19423
// begin depart ( scout1 diff broken , sol , scout1_pd2 , true , false ) ;
19361: LD_LOC 7
19365: PUSH
19366: LD_LOC 21
19370: DIFF
19371: PPUSH
19372: LD_EXP 90
19376: PPUSH
19377: LD_LOC 20
19381: PPUSH
19382: LD_INT 1
19384: PPUSH
19385: LD_INT 0
19387: PPUSH
19388: CALL 16883 0 5
// depart ( scout2 diff broken , sol , scout1_ptr1 , true , false ) ;
19392: LD_LOC 8
19396: PUSH
19397: LD_LOC 21
19401: DIFF
19402: PPUSH
19403: LD_EXP 90
19407: PPUSH
19408: LD_LOC 13
19412: PPUSH
19413: LD_INT 1
19415: PPUSH
19416: LD_INT 0
19418: PPUSH
19419: CALL 16883 0 5
// end ; AddComReturn ( scout diff broken ) ;
19423: LD_LOC 4
19427: PUSH
19428: LD_LOC 21
19432: DIFF
19433: PPUSH
19434: CALL_OW 204
// end ; 5 :
19438: GO 19809
19440: LD_INT 5
19442: DOUBLE
19443: EQUAL
19444: IFTRUE 19448
19446: GO 19592
19448: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19449: LD_LOC 4
19453: PUSH
19454: LD_LOC 21
19458: DIFF
19459: PPUSH
19460: LD_EXP 90
19464: PPUSH
19465: LD_LOC 11
19469: PPUSH
19470: LD_INT 1
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL 16883 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19480: LD_LOC 7
19484: PUSH
19485: LD_LOC 21
19489: DIFF
19490: PPUSH
19491: LD_LOC 17
19495: PPUSH
19496: LD_INT 1
19498: PPUSH
19499: CALL 15919 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19503: LD_LOC 8
19507: PUSH
19508: LD_LOC 21
19512: DIFF
19513: PPUSH
19514: LD_INT 20
19516: PPUSH
19517: CALL_OW 202
// if more_scouting then
19521: LD_EXP 61
19525: IFFALSE 19552
// take_path ( scout2 diff broken , scout1_ptl1 , true ) else
19527: LD_LOC 8
19531: PUSH
19532: LD_LOC 21
19536: DIFF
19537: PPUSH
19538: LD_LOC 14
19542: PPUSH
19543: LD_INT 1
19545: PPUSH
19546: CALL 15919 0 3
19550: GO 19575
// take_path ( scout2 diff broken , scout1_pd2 , true ) ;
19552: LD_LOC 8
19556: PUSH
19557: LD_LOC 21
19561: DIFF
19562: PPUSH
19563: LD_LOC 20
19567: PPUSH
19568: LD_INT 1
19570: PPUSH
19571: CALL 15919 0 3
// AddComReturn ( scout diff broken ) ;
19575: LD_LOC 4
19579: PUSH
19580: LD_LOC 21
19584: DIFF
19585: PPUSH
19586: CALL_OW 204
// end ; 6 :
19590: GO 19809
19592: LD_INT 6
19594: DOUBLE
19595: EQUAL
19596: IFTRUE 19600
19598: GO 19690
19600: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19601: LD_LOC 4
19605: PUSH
19606: LD_LOC 21
19610: DIFF
19611: PPUSH
19612: LD_EXP 90
19616: PPUSH
19617: LD_LOC 11
19621: PPUSH
19622: LD_INT 1
19624: PPUSH
19625: LD_INT 0
19627: PPUSH
19628: CALL 16883 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19632: LD_LOC 7
19636: PUSH
19637: LD_LOC 21
19641: DIFF
19642: PPUSH
19643: LD_LOC 17
19647: PPUSH
19648: LD_INT 1
19650: PPUSH
19651: CALL 15919 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19655: LD_LOC 8
19659: PUSH
19660: LD_LOC 21
19664: DIFF
19665: PPUSH
19666: LD_INT 20
19668: PPUSH
19669: CALL_OW 202
// AddComReturn ( scout diff broken ) ;
19673: LD_LOC 4
19677: PUSH
19678: LD_LOC 21
19682: DIFF
19683: PPUSH
19684: CALL_OW 204
// end ; 7 :
19688: GO 19809
19690: LD_INT 7
19692: DOUBLE
19693: EQUAL
19694: IFTRUE 19698
19696: GO 19808
19698: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19699: LD_LOC 4
19703: PUSH
19704: LD_LOC 21
19708: DIFF
19709: PPUSH
19710: LD_EXP 90
19714: PPUSH
19715: LD_LOC 11
19719: PPUSH
19720: LD_INT 1
19722: PPUSH
19723: LD_INT 0
19725: PPUSH
19726: CALL 16883 0 5
// take_path ( scout1 diff broken , scout1_pa , true ) ;
19730: LD_LOC 7
19734: PUSH
19735: LD_LOC 21
19739: DIFF
19740: PPUSH
19741: LD_LOC 18
19745: PPUSH
19746: LD_INT 1
19748: PPUSH
19749: CALL 15919 0 3
// AddComReturn ( scout2 diff broken ) ;
19753: LD_LOC 8
19757: PUSH
19758: LD_LOC 21
19762: DIFF
19763: PPUSH
19764: CALL_OW 204
// take_path ( scout2 diff broken , scout1_pd1 , true ) ;
19768: LD_LOC 8
19772: PUSH
19773: LD_LOC 21
19777: DIFF
19778: PPUSH
19779: LD_LOC 19
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: CALL 15919 0 3
// AddComReturn ( scout diff broken ) ;
19791: LD_LOC 4
19795: PUSH
19796: LD_LOC 21
19800: DIFF
19801: PPUSH
19802: CALL_OW 204
// end ; end ;
19806: GO 19809
19808: POP
// end ; enable ;
19809: ENABLE
// end ;
19810: PPOPN 3
19812: END
// every 0 0$7.0 do
19813: GO 19815
19815: DISABLE
// begin full_forts ( forts , sol ) ;
19816: LD_LOC 10
19820: PPUSH
19821: LD_EXP 90
19825: PPUSH
19826: CALL 16611 0 2
// enable ;
19830: ENABLE
// end ;
19831: END
// every 0 0$5.0 do var i ;
19832: GO 19834
19834: DISABLE
19835: LD_INT 0
19837: PPUSH
// begin for i in mec do
19838: LD_ADDR_VAR 0 1
19842: PUSH
19843: LD_EXP 92
19847: PUSH
19848: FOR_IN
19849: IFFALSE 19909
// begin if not IsBusy ( i ) or not IsInArea ( i , base ) and GetSide ( i ) <> you then
19851: LD_VAR 0 1
19855: PPUSH
19856: CALL_OW 315
19860: NOT
19861: PUSH
19862: LD_VAR 0 1
19866: PPUSH
19867: LD_INT 5
19869: PPUSH
19870: CALL_OW 308
19874: NOT
19875: PUSH
19876: LD_VAR 0 1
19880: PPUSH
19881: CALL_OW 255
19885: PUSH
19886: LD_EXP 1
19890: NONEQUAL
19891: AND
19892: OR
19893: IFFALSE 19907
// ComEnterUnit ( i , fact1 ) ;
19895: LD_VAR 0 1
19899: PPUSH
19900: LD_INT 35
19902: PPUSH
19903: CALL_OW 120
// end ;
19907: GO 19848
19909: POP
19910: POP
// enable ;
19911: ENABLE
// end ;
19912: PPOPN 1
19914: END
// every 0 0$5.0 do var i ;
19915: GO 19917
19917: DISABLE
19918: LD_INT 0
19920: PPUSH
// begin if under_attack then
19921: LD_EXP 64
19925: IFFALSE 19987
// for i in eng do
19927: LD_ADDR_VAR 0 1
19931: PUSH
19932: LD_EXP 93
19936: PUSH
19937: FOR_IN
19938: IFFALSE 19983
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
19940: LD_VAR 0 1
19944: PPUSH
19945: CALL_OW 315
19949: NOT
19950: PUSH
19951: LD_VAR 0 1
19955: PPUSH
19956: CALL_OW 255
19960: PUSH
19961: LD_EXP 1
19965: NONEQUAL
19966: AND
19967: IFFALSE 19981
// ComEnterUnit ( i , depot1 ) ;
19969: LD_VAR 0 1
19973: PPUSH
19974: LD_INT 1
19976: PPUSH
19977: CALL_OW 120
// end else
19981: GO 19937
19983: POP
19984: POP
19985: GO 19994
// ComExitBuilding ( depot1 ) ;
19987: LD_INT 1
19989: PPUSH
19990: CALL_OW 122
// enable ;
19994: ENABLE
// end ;
19995: PPOPN 1
19997: END
// every 0 0$5.0 do var i ;
19998: GO 20000
20000: DISABLE
20001: LD_INT 0
20003: PPUSH
// begin for i in sci do
20004: LD_ADDR_VAR 0 1
20008: PUSH
20009: LD_EXP 91
20013: PUSH
20014: FOR_IN
20015: IFFALSE 20060
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
20017: LD_VAR 0 1
20021: PPUSH
20022: CALL_OW 315
20026: NOT
20027: PUSH
20028: LD_VAR 0 1
20032: PPUSH
20033: CALL_OW 255
20037: PUSH
20038: LD_EXP 1
20042: NONEQUAL
20043: AND
20044: IFFALSE 20058
// ComEnterUnit ( i , lab1 ) ;
20046: LD_VAR 0 1
20050: PPUSH
20051: LD_INT 6
20053: PPUSH
20054: CALL_OW 120
// end ;
20058: GO 20014
20060: POP
20061: POP
// enable ;
20062: ENABLE
// end ;
20063: PPOPN 1
20065: END
// every 0 0$1.0 do var set_fuel , fuel ;
20066: GO 20068
20068: DISABLE
20069: LD_INT 0
20071: PPUSH
20072: PPUSH
// begin for set_fuel in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20073: LD_ADDR_VAR 0 1
20077: PUSH
20078: LD_INT 5
20080: PPUSH
20081: LD_INT 21
20083: PUSH
20084: LD_INT 2
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PUSH
20091: LD_INT 22
20093: PUSH
20094: LD_EXP 2
20098: PUSH
20099: EMPTY
20100: LIST
20101: LIST
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: PPUSH
20107: CALL_OW 70
20111: PUSH
20112: FOR_IN
20113: IFFALSE 20160
// begin fuel := GetFuel ( set_fuel ) ;
20115: LD_ADDR_VAR 0 2
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: CALL_OW 261
20129: ST_TO_ADDR
// if fuel <= 80 then
20130: LD_VAR 0 2
20134: PUSH
20135: LD_INT 80
20137: LESSEQUAL
20138: IFFALSE 20158
// SetFuel ( set_fuel , fuel + 20 ) ;
20140: LD_VAR 0 1
20144: PPUSH
20145: LD_VAR 0 2
20149: PUSH
20150: LD_INT 20
20152: PLUS
20153: PPUSH
20154: CALL_OW 240
// end ;
20158: GO 20112
20160: POP
20161: POP
// enable ;
20162: ENABLE
// end ;
20163: PPOPN 2
20165: END
// every 0 0$1.0 do var to_rep , prednost ;
20166: GO 20168
20168: DISABLE
20169: LD_INT 0
20171: PPUSH
20172: PPUSH
// begin prednost := FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) isect broken ;
20173: LD_ADDR_VAR 0 2
20177: PUSH
20178: LD_INT 5
20180: PPUSH
20181: LD_INT 21
20183: PUSH
20184: LD_INT 2
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: PUSH
20191: LD_INT 22
20193: PUSH
20194: LD_EXP 2
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: PUSH
20203: EMPTY
20204: LIST
20205: LIST
20206: PPUSH
20207: CALL_OW 70
20211: PUSH
20212: LD_LOC 21
20216: ISECT
20217: ST_TO_ADDR
// if prednost then
20218: LD_VAR 0 2
20222: IFFALSE 20375
// for to_rep in prednost do
20224: LD_ADDR_VAR 0 1
20228: PUSH
20229: LD_VAR 0 2
20233: PUSH
20234: FOR_IN
20235: IFFALSE 20371
// begin if IsInArea ( to_rep , base ) then
20237: LD_VAR 0 1
20241: PPUSH
20242: LD_INT 5
20244: PPUSH
20245: CALL_OW 308
20249: IFFALSE 20369
// if GetLives ( to_rep ) < 1000 then
20251: LD_VAR 0 1
20255: PPUSH
20256: CALL_OW 256
20260: PUSH
20261: LD_INT 1000
20263: LESS
20264: IFFALSE 20344
// begin ComExitBuilding ( mec ) ;
20266: LD_EXP 92
20270: PPUSH
20271: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20275: LD_EXP 92
20279: PPUSH
20280: LD_VAR 0 1
20284: PPUSH
20285: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20289: LD_VAR 0 1
20293: PPUSH
20294: CALL_OW 311
20298: PPUSH
20299: CALL_OW 257
20303: PUSH
20304: LD_INT 3
20306: EQUAL
20307: IFFALSE 20342
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20309: LD_VAR 0 1
20313: PPUSH
20314: CALL_OW 311
20318: PPUSH
20319: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20323: LD_VAR 0 1
20327: PPUSH
20328: CALL_OW 311
20332: PPUSH
20333: LD_VAR 0 1
20337: PPUSH
20338: CALL_OW 189
// end ; end else
20342: GO 20369
// begin broken := broken diff to_rep ;
20344: LD_ADDR_LOC 21
20348: PUSH
20349: LD_LOC 21
20353: PUSH
20354: LD_VAR 0 1
20358: DIFF
20359: ST_TO_ADDR
// ComReturn ( to_rep ) ;
20360: LD_VAR 0 1
20364: PPUSH
20365: CALL_OW 144
// end ; end else
20369: GO 20234
20371: POP
20372: POP
20373: GO 20526
// for to_rep in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20375: LD_ADDR_VAR 0 1
20379: PUSH
20380: LD_INT 5
20382: PPUSH
20383: LD_INT 21
20385: PUSH
20386: LD_INT 2
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: LD_INT 22
20395: PUSH
20396: LD_EXP 2
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PPUSH
20409: CALL_OW 70
20413: PUSH
20414: FOR_IN
20415: IFFALSE 20524
// begin if IsInArea ( to_rep , base ) then
20417: LD_VAR 0 1
20421: PPUSH
20422: LD_INT 5
20424: PPUSH
20425: CALL_OW 308
20429: IFFALSE 20522
// if GetLives ( to_rep ) < 1000 then
20431: LD_VAR 0 1
20435: PPUSH
20436: CALL_OW 256
20440: PUSH
20441: LD_INT 1000
20443: LESS
20444: IFFALSE 20522
// begin ComExitBuilding ( mec ) ;
20446: LD_EXP 92
20450: PPUSH
20451: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20455: LD_EXP 92
20459: PPUSH
20460: LD_VAR 0 1
20464: PPUSH
20465: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20469: LD_VAR 0 1
20473: PPUSH
20474: CALL_OW 311
20478: PPUSH
20479: CALL_OW 257
20483: PUSH
20484: LD_INT 3
20486: EQUAL
20487: IFFALSE 20522
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20489: LD_VAR 0 1
20493: PPUSH
20494: CALL_OW 311
20498: PPUSH
20499: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20503: LD_VAR 0 1
20507: PPUSH
20508: CALL_OW 311
20512: PPUSH
20513: LD_VAR 0 1
20517: PPUSH
20518: CALL_OW 189
// end ; end ; end ;
20522: GO 20414
20524: POP
20525: POP
// enable ;
20526: ENABLE
// end ;
20527: PPOPN 2
20529: END
// every 0 0$0.5 do var i , a ;
20530: GO 20532
20532: DISABLE
20533: LD_INT 0
20535: PPUSH
20536: PPUSH
// begin for i in cars do
20537: LD_ADDR_VAR 0 1
20541: PUSH
20542: LD_LOC 2
20546: PUSH
20547: FOR_IN
20548: IFFALSE 20656
// begin if GetLives ( i ) < 550 then
20550: LD_VAR 0 1
20554: PPUSH
20555: CALL_OW 256
20559: PUSH
20560: LD_INT 550
20562: LESS
20563: IFFALSE 20596
// begin ComMoveXY ( i , 112 , 89 ) ;
20565: LD_VAR 0 1
20569: PPUSH
20570: LD_INT 112
20572: PPUSH
20573: LD_INT 89
20575: PPUSH
20576: CALL_OW 111
// broken := broken union i ;
20580: LD_ADDR_LOC 21
20584: PUSH
20585: LD_LOC 21
20589: PUSH
20590: LD_VAR 0 1
20594: UNION
20595: ST_TO_ADDR
// end ; if i in cargo and GetLives ( i ) < 800 then
20596: LD_VAR 0 1
20600: PUSH
20601: LD_LOC 3
20605: IN
20606: PUSH
20607: LD_VAR 0 1
20611: PPUSH
20612: CALL_OW 256
20616: PUSH
20617: LD_INT 800
20619: LESS
20620: AND
20621: IFFALSE 20654
// begin ComMoveXY ( i , 112 , 89 ) ;
20623: LD_VAR 0 1
20627: PPUSH
20628: LD_INT 112
20630: PPUSH
20631: LD_INT 89
20633: PPUSH
20634: CALL_OW 111
// broken := broken union i ;
20638: LD_ADDR_LOC 21
20642: PUSH
20643: LD_LOC 21
20647: PUSH
20648: LD_VAR 0 1
20652: UNION
20653: ST_TO_ADDR
// end ; end ;
20654: GO 20547
20656: POP
20657: POP
// enable ;
20658: ENABLE
// end ;
20659: PPOPN 2
20661: END
// var zasek_cargo ; every 1 1$0 do var j , pojedou , new ;
20662: GO 20664
20664: DISABLE
20665: LD_INT 0
20667: PPUSH
20668: PPUSH
20669: PPUSH
// begin SetFuel ( cargo , 100 ) ;
20670: LD_LOC 3
20674: PPUSH
20675: LD_INT 100
20677: PPUSH
20678: CALL_OW 240
// if not HasTask ( Cargo ) and GetLives ( Cargo ) >= 900 and crates >= 2 then
20682: LD_LOC 3
20686: PPUSH
20687: CALL_OW 314
20691: NOT
20692: PUSH
20693: LD_LOC 3
20697: PPUSH
20698: CALL_OW 256
20702: PUSH
20703: LD_INT 900
20705: GREATEREQUAL
20706: AND
20707: PUSH
20708: LD_EXP 76
20712: PUSH
20713: LD_INT 2
20715: GREATEREQUAL
20716: AND
20717: IFFALSE 20932
// begin new := [ ] ;
20719: LD_ADDR_VAR 0 3
20723: PUSH
20724: EMPTY
20725: ST_TO_ADDR
// pojedou := find_drivers ( cargo , sol , false ) ;
20726: LD_ADDR_VAR 0 2
20730: PUSH
20731: LD_LOC 3
20735: PPUSH
20736: LD_EXP 90
20740: PPUSH
20741: LD_INT 0
20743: PPUSH
20744: CALL 16266 0 3
20748: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20749: LD_VAR 0 2
20753: PPUSH
20754: CALL 16945 0 1
// for j := 1 to 2 do
20758: LD_ADDR_VAR 0 1
20762: PUSH
20763: DOUBLE
20764: LD_INT 1
20766: DEC
20767: ST_TO_ADDR
20768: LD_INT 2
20770: PUSH
20771: FOR_TO
20772: IFFALSE 20854
// begin if InArea ( crates [ j ] [ 1 ] , crates [ j ] [ 2 ] , pod_cestou ) then
20774: LD_EXP 76
20778: PUSH
20779: LD_VAR 0 1
20783: ARRAY
20784: PUSH
20785: LD_INT 1
20787: ARRAY
20788: PPUSH
20789: LD_EXP 76
20793: PUSH
20794: LD_VAR 0 1
20798: ARRAY
20799: PUSH
20800: LD_INT 2
20802: ARRAY
20803: PPUSH
20804: LD_INT 6
20806: PPUSH
20807: CALL_OW 309
20811: IFFALSE 20852
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
20813: LD_VAR 0 2
20817: PPUSH
20818: LD_EXP 76
20822: PUSH
20823: LD_VAR 0 1
20827: ARRAY
20828: PUSH
20829: LD_INT 1
20831: ARRAY
20832: PPUSH
20833: LD_EXP 76
20837: PUSH
20838: LD_VAR 0 1
20842: ARRAY
20843: PUSH
20844: LD_INT 2
20846: ARRAY
20847: PPUSH
20848: CALL_OW 177
// end ; end ;
20852: GO 20771
20854: POP
20855: POP
// for j := 3 to crates do
20856: LD_ADDR_VAR 0 1
20860: PUSH
20861: DOUBLE
20862: LD_INT 3
20864: DEC
20865: ST_TO_ADDR
20866: LD_EXP 76
20870: PUSH
20871: FOR_TO
20872: IFFALSE 20901
// begin new := new ^ [ crates [ j ] ] ;
20874: LD_ADDR_VAR 0 3
20878: PUSH
20879: LD_VAR 0 3
20883: PUSH
20884: LD_EXP 76
20888: PUSH
20889: LD_VAR 0 1
20893: ARRAY
20894: PUSH
20895: EMPTY
20896: LIST
20897: ADD
20898: ST_TO_ADDR
// end ;
20899: GO 20871
20901: POP
20902: POP
// crates := new ;
20903: LD_ADDR_EXP 76
20907: PUSH
20908: LD_VAR 0 3
20912: ST_TO_ADDR
// AddComReturn ( pojedou ) ;
20913: LD_VAR 0 2
20917: PPUSH
20918: CALL_OW 204
// zasek_cargo := 1 ;
20922: LD_ADDR_LOC 30
20926: PUSH
20927: LD_INT 1
20929: ST_TO_ADDR
// end else
20930: GO 20997
// begin zasek_cargo := zasek_cargo + 1 ;
20932: LD_ADDR_LOC 30
20936: PUSH
20937: LD_LOC 30
20941: PUSH
20942: LD_INT 1
20944: PLUS
20945: ST_TO_ADDR
// if zasek_cargo > 5 then
20946: LD_LOC 30
20950: PUSH
20951: LD_INT 5
20953: GREATER
20954: IFFALSE 20997
// begin pojedou := find_drivers ( cargo , sol , false ) ;
20956: LD_ADDR_VAR 0 2
20960: PUSH
20961: LD_LOC 3
20965: PPUSH
20966: LD_EXP 90
20970: PPUSH
20971: LD_INT 0
20973: PPUSH
20974: CALL 16266 0 3
20978: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20979: LD_VAR 0 2
20983: PPUSH
20984: CALL 16945 0 1
// ComReturn ( cargo ) ;
20988: LD_LOC 3
20992: PPUSH
20993: CALL_OW 144
// end ; end ; enable ;
20997: ENABLE
// end ;
20998: PPOPN 3
21000: END
// every 0 0$1 do var rusi , i ;
21001: GO 21003
21003: DISABLE
21004: LD_INT 0
21006: PPUSH
21007: PPUSH
// begin rusi := FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , russians ] , [ f_see , you ] ] ) ;
21008: LD_ADDR_VAR 0 1
21012: PUSH
21013: LD_INT 3
21015: PUSH
21016: LD_INT 21
21018: PUSH
21019: LD_INT 3
21021: PUSH
21022: EMPTY
21023: LIST
21024: LIST
21025: PUSH
21026: LD_INT 22
21028: PUSH
21029: LD_EXP 2
21033: PUSH
21034: EMPTY
21035: LIST
21036: LIST
21037: PUSH
21038: LD_INT 101
21040: PUSH
21041: LD_EXP 1
21045: PUSH
21046: EMPTY
21047: LIST
21048: LIST
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: LIST
21054: LIST
21055: PPUSH
21056: CALL_OW 69
21060: ST_TO_ADDR
// if rusi then
21061: LD_VAR 0 1
21065: IFFALSE 21265
// begin if FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_see , russians ] ] ) diff prilet_tvoji then
21067: LD_INT 3
21069: PUSH
21070: LD_INT 21
21072: PUSH
21073: LD_INT 3
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PUSH
21080: LD_INT 22
21082: PUSH
21083: LD_EXP 1
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: PUSH
21092: LD_INT 101
21094: PUSH
21095: LD_EXP 2
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: LIST
21108: LIST
21109: PPUSH
21110: CALL_OW 69
21114: PUSH
21115: LD_EXP 6
21119: DIFF
21120: IFFALSE 21265
// begin attacky := attacky + 1 ;
21122: LD_ADDR_EXP 60
21126: PUSH
21127: LD_EXP 60
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: ST_TO_ADDR
// if not more_scouting and attacky > attack_to_scouting then
21136: LD_EXP 61
21140: NOT
21141: PUSH
21142: LD_EXP 60
21146: PUSH
21147: LD_EXP 67
21151: GREATER
21152: AND
21153: IFFALSE 21171
// begin more_scouting := true ;
21155: LD_ADDR_EXP 61
21159: PUSH
21160: LD_INT 1
21162: ST_TO_ADDR
// go_up := true ;
21163: LD_ADDR_EXP 62
21167: PUSH
21168: LD_INT 1
21170: ST_TO_ADDR
// end ; for i in scout diff broken do
21171: LD_ADDR_VAR 0 2
21175: PUSH
21176: LD_LOC 4
21180: PUSH
21181: LD_LOC 21
21185: DIFF
21186: PUSH
21187: FOR_IN
21188: IFFALSE 21263
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_dist , i , 8 ] ] ) , i ) ) ;
21190: LD_VAR 0 2
21194: PPUSH
21195: LD_INT 3
21197: PUSH
21198: LD_INT 21
21200: PUSH
21201: LD_INT 3
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: PUSH
21208: LD_INT 22
21210: PUSH
21211: LD_EXP 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: LD_INT 91
21222: PUSH
21223: LD_VAR 0 2
21227: PUSH
21228: LD_INT 8
21230: PUSH
21231: EMPTY
21232: LIST
21233: LIST
21234: LIST
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: PPUSH
21242: CALL_OW 69
21246: PPUSH
21247: LD_VAR 0 2
21251: PPUSH
21252: CALL_OW 74
21256: PPUSH
21257: CALL_OW 115
// end ;
21261: GO 21187
21263: POP
21264: POP
// end ; end ; enable ;
21265: ENABLE
// end ;
21266: PPOPN 2
21268: END
// every 13 13$0 do
21269: GO 21271
21271: DISABLE
// begin wait ( start_scouting ) ;
21272: LD_EXP 68
21276: PPUSH
21277: CALL_OW 67
// more_scouting := true ;
21281: LD_ADDR_EXP 61
21285: PUSH
21286: LD_INT 1
21288: ST_TO_ADDR
// go_up := true ;
21289: LD_ADDR_EXP 62
21293: PUSH
21294: LD_INT 1
21296: ST_TO_ADDR
// end ;
21297: END
// every 0 0$3 + 0 0$30 do var all1 , all , parked , ridici , i , rid , c ;
21298: GO 21300
21300: DISABLE
21301: LD_INT 0
21303: PPUSH
21304: PPUSH
21305: PPUSH
21306: PPUSH
21307: PPUSH
21308: PPUSH
21309: PPUSH
// begin all1 := FilterUnitsInArea ( near_base , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21310: LD_ADDR_VAR 0 1
21314: PUSH
21315: LD_INT 4
21317: PPUSH
21318: LD_INT 22
21320: PUSH
21321: LD_EXP 2
21325: PUSH
21326: EMPTY
21327: LIST
21328: LIST
21329: PUSH
21330: LD_INT 21
21332: PUSH
21333: LD_INT 2
21335: PUSH
21336: EMPTY
21337: LIST
21338: LIST
21339: PUSH
21340: EMPTY
21341: LIST
21342: LIST
21343: PPUSH
21344: CALL_OW 70
21348: ST_TO_ADDR
// for i in all1 do
21349: LD_ADDR_VAR 0 5
21353: PUSH
21354: LD_VAR 0 1
21358: PUSH
21359: FOR_IN
21360: IFFALSE 21395
// if not UnitsInside ( i ) then
21362: LD_VAR 0 5
21366: PPUSH
21367: CALL_OW 313
21371: NOT
21372: IFFALSE 21393
// all := all ^ [ i ] ;
21374: LD_ADDR_VAR 0 2
21378: PUSH
21379: LD_VAR 0 2
21383: PUSH
21384: LD_VAR 0 5
21388: PUSH
21389: EMPTY
21390: LIST
21391: ADD
21392: ST_TO_ADDR
21393: GO 21359
21395: POP
21396: POP
// parked := FilterUnitsInArea ( parkoviste , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21397: LD_ADDR_VAR 0 3
21401: PUSH
21402: LD_INT 13
21404: PPUSH
21405: LD_INT 22
21407: PUSH
21408: LD_EXP 2
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: PUSH
21417: LD_INT 21
21419: PUSH
21420: LD_INT 2
21422: PUSH
21423: EMPTY
21424: LIST
21425: LIST
21426: PUSH
21427: EMPTY
21428: LIST
21429: LIST
21430: PPUSH
21431: CALL_OW 70
21435: ST_TO_ADDR
// ridici := UnitFilter ( sol ^ sci ^ eng , [ f_outside ] ) ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_EXP 90
21445: PUSH
21446: LD_EXP 91
21450: ADD
21451: PUSH
21452: LD_EXP 93
21456: ADD
21457: PPUSH
21458: LD_INT 56
21460: PUSH
21461: EMPTY
21462: LIST
21463: PPUSH
21464: CALL_OW 72
21468: ST_TO_ADDR
// all := all diff parked ;
21469: LD_ADDR_VAR 0 2
21473: PUSH
21474: LD_VAR 0 2
21478: PUSH
21479: LD_VAR 0 3
21483: DIFF
21484: ST_TO_ADDR
// all := all diff [ 0 ] ;
21485: LD_ADDR_VAR 0 2
21489: PUSH
21490: LD_VAR 0 2
21494: PUSH
21495: LD_INT 0
21497: PUSH
21498: EMPTY
21499: LIST
21500: DIFF
21501: ST_TO_ADDR
// all := all diff cargo ;
21502: LD_ADDR_VAR 0 2
21506: PUSH
21507: LD_VAR 0 2
21511: PUSH
21512: LD_LOC 3
21516: DIFF
21517: ST_TO_ADDR
// if ridici then
21518: LD_VAR 0 4
21522: IFFALSE 22251
// for i in all do
21524: LD_ADDR_VAR 0 5
21528: PUSH
21529: LD_VAR 0 2
21533: PUSH
21534: FOR_IN
21535: IFFALSE 22249
// begin rid := ridici [ 1 ] ;
21537: LD_ADDR_VAR 0 6
21541: PUSH
21542: LD_VAR 0 4
21546: PUSH
21547: LD_INT 1
21549: ARRAY
21550: ST_TO_ADDR
// ridici := ridici diff rid ;
21551: LD_ADDR_VAR 0 4
21555: PUSH
21556: LD_VAR 0 4
21560: PUSH
21561: LD_VAR 0 6
21565: DIFF
21566: ST_TO_ADDR
// sol := sol diff rid ;
21567: LD_ADDR_EXP 90
21571: PUSH
21572: LD_EXP 90
21576: PUSH
21577: LD_VAR 0 6
21581: DIFF
21582: ST_TO_ADDR
// sci := sci diff rid ;
21583: LD_ADDR_EXP 91
21587: PUSH
21588: LD_EXP 91
21592: PUSH
21593: LD_VAR 0 6
21597: DIFF
21598: ST_TO_ADDR
// eng := eng diff rid ;
21599: LD_ADDR_EXP 93
21603: PUSH
21604: LD_EXP 93
21608: PUSH
21609: LD_VAR 0 6
21613: DIFF
21614: ST_TO_ADDR
// case true of i in scout1 :
21615: LD_INT 1
21617: PUSH
21618: LD_VAR 0 5
21622: PUSH
21623: LD_LOC 7
21627: IN
21628: DOUBLE
21629: EQUAL
21630: IFTRUE 21634
21632: GO 21661
21634: POP
// begin scout1 := scout1 diff i ;
21635: LD_ADDR_LOC 7
21639: PUSH
21640: LD_LOC 7
21644: PUSH
21645: LD_VAR 0 5
21649: DIFF
21650: ST_TO_ADDR
// c := 1 ;
21651: LD_ADDR_VAR 0 7
21655: PUSH
21656: LD_INT 1
21658: ST_TO_ADDR
// end ; i in scout2 :
21659: GO 21877
21661: LD_VAR 0 5
21665: PUSH
21666: LD_LOC 8
21670: IN
21671: DOUBLE
21672: EQUAL
21673: IFTRUE 21677
21675: GO 21704
21677: POP
// begin scout2 := scout2 diff i ;
21678: LD_ADDR_LOC 8
21682: PUSH
21683: LD_LOC 8
21687: PUSH
21688: LD_VAR 0 5
21692: DIFF
21693: ST_TO_ADDR
// c := 2 ;
21694: LD_ADDR_VAR 0 7
21698: PUSH
21699: LD_INT 2
21701: ST_TO_ADDR
// end ; i in scout :
21702: GO 21877
21704: LD_VAR 0 5
21708: PUSH
21709: LD_LOC 4
21713: IN
21714: DOUBLE
21715: EQUAL
21716: IFTRUE 21720
21718: GO 21747
21720: POP
// begin scout := scout diff i ;
21721: LD_ADDR_LOC 4
21725: PUSH
21726: LD_LOC 4
21730: PUSH
21731: LD_VAR 0 5
21735: DIFF
21736: ST_TO_ADDR
// c := 3 ;
21737: LD_ADDR_VAR 0 7
21741: PUSH
21742: LD_INT 3
21744: ST_TO_ADDR
// end ; i in attack :
21745: GO 21877
21747: LD_VAR 0 5
21751: PUSH
21752: LD_LOC 5
21756: IN
21757: DOUBLE
21758: EQUAL
21759: IFTRUE 21763
21761: GO 21790
21763: POP
// begin attack := attack diff i ;
21764: LD_ADDR_LOC 5
21768: PUSH
21769: LD_LOC 5
21773: PUSH
21774: LD_VAR 0 5
21778: DIFF
21779: ST_TO_ADDR
// c := 4 ;
21780: LD_ADDR_VAR 0 7
21784: PUSH
21785: LD_INT 4
21787: ST_TO_ADDR
// end ; i in defence :
21788: GO 21877
21790: LD_VAR 0 5
21794: PUSH
21795: LD_LOC 6
21799: IN
21800: DOUBLE
21801: EQUAL
21802: IFTRUE 21806
21804: GO 21833
21806: POP
// begin defence := defence diff i ;
21807: LD_ADDR_LOC 6
21811: PUSH
21812: LD_LOC 6
21816: PUSH
21817: LD_VAR 0 5
21821: DIFF
21822: ST_TO_ADDR
// c := 4 ;
21823: LD_ADDR_VAR 0 7
21827: PUSH
21828: LD_INT 4
21830: ST_TO_ADDR
// end ; i in cargo :
21831: GO 21877
21833: LD_VAR 0 5
21837: PUSH
21838: LD_LOC 3
21842: IN
21843: DOUBLE
21844: EQUAL
21845: IFTRUE 21849
21847: GO 21876
21849: POP
// begin cargo := cargo diff i ;
21850: LD_ADDR_LOC 3
21854: PUSH
21855: LD_LOC 3
21859: PUSH
21860: LD_VAR 0 5
21864: DIFF
21865: ST_TO_ADDR
// c := 5 ;
21866: LD_ADDR_VAR 0 7
21870: PUSH
21871: LD_INT 5
21873: ST_TO_ADDR
// end ; end ;
21874: GO 21877
21876: POP
// ComEnterUnit ( rid , i ) ;
21877: LD_VAR 0 6
21881: PPUSH
21882: LD_VAR 0 5
21886: PPUSH
21887: CALL_OW 120
// while not UnitsInside ( i ) do
21891: LD_VAR 0 5
21895: PPUSH
21896: CALL_OW 313
21900: NOT
21901: IFFALSE 21912
// wait ( 0 0$1 ) ;
21903: LD_INT 35
21905: PPUSH
21906: CALL_OW 67
21910: GO 21891
// ComMoveToArea ( i , parkoviste ) ;
21912: LD_VAR 0 5
21916: PPUSH
21917: LD_INT 13
21919: PPUSH
21920: CALL_OW 113
// while not IsInArea ( i , parkoviste ) do
21924: LD_VAR 0 5
21928: PPUSH
21929: LD_INT 13
21931: PPUSH
21932: CALL_OW 308
21936: NOT
21937: IFFALSE 21948
// wait ( 0 0$1 ) ;
21939: LD_INT 35
21941: PPUSH
21942: CALL_OW 67
21946: GO 21924
// ComExitVehicle ( i ) ;
21948: LD_VAR 0 5
21952: PPUSH
21953: CALL_OW 121
// while UnitsInside ( i ) do
21957: LD_VAR 0 5
21961: PPUSH
21962: CALL_OW 313
21966: IFFALSE 21977
// wait ( 0 0$1 ) ;
21968: LD_INT 35
21970: PPUSH
21971: CALL_OW 67
21975: GO 21957
// ComReturn ( rid ) ;
21977: LD_VAR 0 6
21981: PPUSH
21982: CALL_OW 144
// case c of 1 :
21986: LD_VAR 0 7
21990: PUSH
21991: LD_INT 1
21993: DOUBLE
21994: EQUAL
21995: IFTRUE 21999
21997: GO 22018
21999: POP
// begin scout1 := scout1 ^ i ;
22000: LD_ADDR_LOC 7
22004: PUSH
22005: LD_LOC 7
22009: PUSH
22010: LD_VAR 0 5
22014: ADD
22015: ST_TO_ADDR
// end ; 2 :
22016: GO 22154
22018: LD_INT 2
22020: DOUBLE
22021: EQUAL
22022: IFTRUE 22026
22024: GO 22045
22026: POP
// begin scout2 := scout2 ^ i ;
22027: LD_ADDR_LOC 8
22031: PUSH
22032: LD_LOC 8
22036: PUSH
22037: LD_VAR 0 5
22041: ADD
22042: ST_TO_ADDR
// end ; 3 :
22043: GO 22154
22045: LD_INT 3
22047: DOUBLE
22048: EQUAL
22049: IFTRUE 22053
22051: GO 22072
22053: POP
// begin scout := scout ^ i ;
22054: LD_ADDR_LOC 4
22058: PUSH
22059: LD_LOC 4
22063: PUSH
22064: LD_VAR 0 5
22068: ADD
22069: ST_TO_ADDR
// end ; 4 :
22070: GO 22154
22072: LD_INT 4
22074: DOUBLE
22075: EQUAL
22076: IFTRUE 22080
22078: GO 22099
22080: POP
// begin attack := attack ^ i ;
22081: LD_ADDR_LOC 5
22085: PUSH
22086: LD_LOC 5
22090: PUSH
22091: LD_VAR 0 5
22095: ADD
22096: ST_TO_ADDR
// end ; 5 :
22097: GO 22154
22099: LD_INT 5
22101: DOUBLE
22102: EQUAL
22103: IFTRUE 22107
22105: GO 22126
22107: POP
// begin defence := defence ^ i ;
22108: LD_ADDR_LOC 6
22112: PUSH
22113: LD_LOC 6
22117: PUSH
22118: LD_VAR 0 5
22122: ADD
22123: ST_TO_ADDR
// end ; 6 :
22124: GO 22154
22126: LD_INT 6
22128: DOUBLE
22129: EQUAL
22130: IFTRUE 22134
22132: GO 22153
22134: POP
// begin cargo := cargo ^ i ;
22135: LD_ADDR_LOC 3
22139: PUSH
22140: LD_LOC 3
22144: PUSH
22145: LD_VAR 0 5
22149: ADD
22150: ST_TO_ADDR
// end ; end ;
22151: GO 22154
22153: POP
// if GetClass ( rid ) = class_soldier then
22154: LD_VAR 0 6
22158: PPUSH
22159: CALL_OW 257
22163: PUSH
22164: LD_INT 1
22166: EQUAL
22167: IFFALSE 22185
// sol := sol union rid ;
22169: LD_ADDR_EXP 90
22173: PUSH
22174: LD_EXP 90
22178: PUSH
22179: LD_VAR 0 6
22183: UNION
22184: ST_TO_ADDR
// if GetClass ( rid ) = class_scientistic then
22185: LD_VAR 0 6
22189: PPUSH
22190: CALL_OW 257
22194: PUSH
22195: LD_INT 4
22197: EQUAL
22198: IFFALSE 22216
// sci := sci union rid ;
22200: LD_ADDR_EXP 91
22204: PUSH
22205: LD_EXP 91
22209: PUSH
22210: LD_VAR 0 6
22214: UNION
22215: ST_TO_ADDR
// if GetClass ( rid ) = class_engineer then
22216: LD_VAR 0 6
22220: PPUSH
22221: CALL_OW 257
22225: PUSH
22226: LD_INT 2
22228: EQUAL
22229: IFFALSE 22247
// eng := eng union rid ;
22231: LD_ADDR_EXP 93
22235: PUSH
22236: LD_EXP 93
22240: PUSH
22241: LD_VAR 0 6
22245: UNION
22246: ST_TO_ADDR
// end ;
22247: GO 21534
22249: POP
22250: POP
// enable ;
22251: ENABLE
// end ;
22252: PPOPN 7
22254: END
// var add_h ; every 0 0$15.0 do var a ;
22255: GO 22257
22257: DISABLE
22258: LD_INT 0
22260: PPUSH
// begin if not IsBusy ( fact1 ) and GetSide ( fact1 ) <> you then
22261: LD_INT 35
22263: PPUSH
22264: CALL_OW 315
22268: NOT
22269: PUSH
22270: LD_INT 35
22272: PPUSH
22273: CALL_OW 255
22277: PUSH
22278: LD_EXP 1
22282: NONEQUAL
22283: AND
22284: IFFALSE 23112
// begin if attacky > 70 and defence < 4 then
22286: LD_EXP 60
22290: PUSH
22291: LD_INT 70
22293: GREATER
22294: PUSH
22295: LD_LOC 6
22299: PUSH
22300: LD_INT 4
22302: LESS
22303: AND
22304: IFFALSE 22374
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22306: LD_INT 5
22308: PPUSH
22309: LD_INT 25
22311: PUSH
22312: LD_INT 3
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: PUSH
22319: LD_INT 22
22321: PUSH
22322: LD_EXP 2
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: PUSH
22331: EMPTY
22332: LIST
22333: LIST
22334: PPUSH
22335: CALL_OW 70
22339: PPUSH
22340: LD_INT 35
22342: PPUSH
22343: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_gun ) ;
22347: LD_INT 35
22349: PPUSH
22350: LD_INT 24
22352: PPUSH
22353: LD_INT 1
22355: PPUSH
22356: LD_INT 1
22358: PPUSH
22359: LD_INT 46
22361: PPUSH
22362: CALL_OW 125
// to_defence := true ;
22366: LD_ADDR_LOC 25
22370: PUSH
22371: LD_INT 1
22373: ST_TO_ADDR
// end ; if attacky > 30 and scout < 2 then
22374: LD_EXP 60
22378: PUSH
22379: LD_INT 30
22381: GREATER
22382: PUSH
22383: LD_LOC 4
22387: PUSH
22388: LD_INT 2
22390: LESS
22391: AND
22392: IFFALSE 22470
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22394: LD_INT 5
22396: PPUSH
22397: LD_INT 25
22399: PUSH
22400: LD_INT 3
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 22
22409: PUSH
22410: LD_EXP 2
22414: PUSH
22415: EMPTY
22416: LIST
22417: LIST
22418: PUSH
22419: EMPTY
22420: LIST
22421: LIST
22422: PPUSH
22423: CALL_OW 70
22427: PPUSH
22428: LD_INT 35
22430: PPUSH
22431: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22435: LD_INT 35
22437: PPUSH
22438: LD_INT 22
22440: PPUSH
22441: LD_INT 1
22443: PPUSH
22444: LD_INT 1
22446: PPUSH
22447: LD_INT 42
22449: PPUSH
22450: CALL_OW 125
// to_scout := true ;
22454: LD_ADDR_LOC 27
22458: PUSH
22459: LD_INT 1
22461: ST_TO_ADDR
// to_attack := true ;
22462: LD_ADDR_LOC 26
22466: PUSH
22467: LD_INT 1
22469: ST_TO_ADDR
// end ; if attacky > 90 and attack < 4 then
22470: LD_EXP 60
22474: PUSH
22475: LD_INT 90
22477: GREATER
22478: PUSH
22479: LD_LOC 5
22483: PUSH
22484: LD_INT 4
22486: LESS
22487: AND
22488: IFFALSE 22558
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22490: LD_INT 5
22492: PPUSH
22493: LD_INT 25
22495: PUSH
22496: LD_INT 3
22498: PUSH
22499: EMPTY
22500: LIST
22501: LIST
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_EXP 2
22510: PUSH
22511: EMPTY
22512: LIST
22513: LIST
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PPUSH
22519: CALL_OW 70
22523: PPUSH
22524: LD_INT 35
22526: PPUSH
22527: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22531: LD_INT 35
22533: PPUSH
22534: LD_INT 24
22536: PPUSH
22537: LD_INT 1
22539: PPUSH
22540: LD_INT 1
22542: PPUSH
22543: LD_INT 42
22545: PPUSH
22546: CALL_OW 125
// to_attack := true ;
22550: LD_ADDR_LOC 26
22554: PUSH
22555: LD_INT 1
22557: ST_TO_ADDR
// end ; if cargo < 1 then
22558: LD_LOC 3
22562: PUSH
22563: LD_INT 1
22565: LESS
22566: IFFALSE 22636
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22568: LD_INT 5
22570: PPUSH
22571: LD_INT 25
22573: PUSH
22574: LD_INT 3
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PUSH
22581: LD_INT 22
22583: PUSH
22584: LD_EXP 2
22588: PUSH
22589: EMPTY
22590: LIST
22591: LIST
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: PPUSH
22597: CALL_OW 70
22601: PPUSH
22602: LD_INT 35
22604: PPUSH
22605: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_cargo_bay ) ;
22609: LD_INT 35
22611: PPUSH
22612: LD_INT 22
22614: PPUSH
22615: LD_INT 1
22617: PPUSH
22618: LD_INT 1
22620: PPUSH
22621: LD_INT 51
22623: PPUSH
22624: CALL_OW 125
// to_cargo := true ;
22628: LD_ADDR_LOC 28
22632: PUSH
22633: LD_INT 1
22635: ST_TO_ADDR
// end ; if ( sol + mec + eng + sci > 8 ) and ( add_h < 6 ) then
22636: LD_EXP 90
22640: PUSH
22641: LD_EXP 92
22645: PLUS
22646: PUSH
22647: LD_EXP 93
22651: PLUS
22652: PUSH
22653: LD_EXP 91
22657: PLUS
22658: PUSH
22659: LD_INT 8
22661: GREATER
22662: PUSH
22663: LD_LOC 31
22667: PUSH
22668: LD_INT 6
22670: LESS
22671: AND
22672: IFFALSE 23112
// begin add_h := add_h + 1 ;
22674: LD_ADDR_LOC 31
22678: PUSH
22679: LD_LOC 31
22683: PUSH
22684: LD_INT 1
22686: PLUS
22687: ST_TO_ADDR
// if sol < 8 then
22688: LD_EXP 90
22692: PUSH
22693: LD_INT 8
22695: LESS
22696: IFFALSE 22802
// begin InitUc ;
22698: CALL_OW 18
// InitHc ;
22702: CALL_OW 19
// uc_nation := nation_russian ;
22706: LD_ADDR_OWVAR 21
22710: PUSH
22711: LD_INT 3
22713: ST_TO_ADDR
// uc_side := russians ;
22714: LD_ADDR_OWVAR 20
22718: PUSH
22719: LD_EXP 2
22723: ST_TO_ADDR
// PrepareSoldier ( 0 , 6 ) ;
22724: LD_INT 0
22726: PPUSH
22727: LD_INT 6
22729: PPUSH
22730: CALL_OW 381
// a := CreateHuman ;
22734: LD_ADDR_VAR 0 1
22738: PUSH
22739: CALL_OW 44
22743: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22744: LD_VAR 0 1
22748: PPUSH
22749: LD_INT 119
22751: PPUSH
22752: LD_INT 98
22754: PPUSH
22755: LD_INT 5
22757: PPUSH
22758: LD_INT 0
22760: PPUSH
22761: CALL_OW 50
// wait ( 0 0$6 ) ;
22765: LD_INT 210
22767: PPUSH
22768: CALL_OW 67
// sol := sol ^ a ;
22772: LD_ADDR_EXP 90
22776: PUSH
22777: LD_EXP 90
22781: PUSH
22782: LD_VAR 0 1
22786: ADD
22787: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_INT 5
22795: PPUSH
22796: CALL_OW 113
// end else
22800: GO 23112
// if mec < 2 then
22802: LD_EXP 92
22806: PUSH
22807: LD_INT 2
22809: LESS
22810: IFFALSE 22906
// begin InitUc ;
22812: CALL_OW 18
// InitHc ;
22816: CALL_OW 19
// uc_nation := nation_russian ;
22820: LD_ADDR_OWVAR 21
22824: PUSH
22825: LD_INT 3
22827: ST_TO_ADDR
// PrepareMechanic ( 0 , 6 ) ;
22828: LD_INT 0
22830: PPUSH
22831: LD_INT 6
22833: PPUSH
22834: CALL_OW 383
// a := CreateHuman ;
22838: LD_ADDR_VAR 0 1
22842: PUSH
22843: CALL_OW 44
22847: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22848: LD_VAR 0 1
22852: PPUSH
22853: LD_INT 119
22855: PPUSH
22856: LD_INT 98
22858: PPUSH
22859: LD_INT 5
22861: PPUSH
22862: LD_INT 0
22864: PPUSH
22865: CALL_OW 50
// wait ( 0 0$6 ) ;
22869: LD_INT 210
22871: PPUSH
22872: CALL_OW 67
// mec := mec ^ a ;
22876: LD_ADDR_EXP 92
22880: PUSH
22881: LD_EXP 92
22885: PUSH
22886: LD_VAR 0 1
22890: ADD
22891: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22892: LD_VAR 0 1
22896: PPUSH
22897: LD_INT 5
22899: PPUSH
22900: CALL_OW 113
// end else
22904: GO 23112
// if eng < 1 then
22906: LD_EXP 93
22910: PUSH
22911: LD_INT 1
22913: LESS
22914: IFFALSE 23010
// begin InitUc ;
22916: CALL_OW 18
// InitHc ;
22920: CALL_OW 19
// uc_nation := nation_russian ;
22924: LD_ADDR_OWVAR 21
22928: PUSH
22929: LD_INT 3
22931: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
22932: LD_INT 0
22934: PPUSH
22935: LD_INT 6
22937: PPUSH
22938: CALL_OW 382
// a := CreateHuman ;
22942: LD_ADDR_VAR 0 1
22946: PUSH
22947: CALL_OW 44
22951: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
22952: LD_VAR 0 1
22956: PPUSH
22957: LD_INT 119
22959: PPUSH
22960: LD_INT 99
22962: PPUSH
22963: LD_INT 5
22965: PPUSH
22966: LD_INT 0
22968: PPUSH
22969: CALL_OW 50
// wait ( 0 0$6 ) ;
22973: LD_INT 210
22975: PPUSH
22976: CALL_OW 67
// eng := eng ^ a ;
22980: LD_ADDR_EXP 93
22984: PUSH
22985: LD_EXP 93
22989: PUSH
22990: LD_VAR 0 1
22994: ADD
22995: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22996: LD_VAR 0 1
23000: PPUSH
23001: LD_INT 5
23003: PPUSH
23004: CALL_OW 113
// end else
23008: GO 23112
// if sci < 1 then
23010: LD_EXP 91
23014: PUSH
23015: LD_INT 1
23017: LESS
23018: IFFALSE 23112
// begin InitUc ;
23020: CALL_OW 18
// InitHc ;
23024: CALL_OW 19
// uc_nation := nation_russian ;
23028: LD_ADDR_OWVAR 21
23032: PUSH
23033: LD_INT 3
23035: ST_TO_ADDR
// PrepareScientist ( 0 , 6 ) ;
23036: LD_INT 0
23038: PPUSH
23039: LD_INT 6
23041: PPUSH
23042: CALL_OW 384
// a := CreateHuman ;
23046: LD_ADDR_VAR 0 1
23050: PUSH
23051: CALL_OW 44
23055: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
23056: LD_VAR 0 1
23060: PPUSH
23061: LD_INT 119
23063: PPUSH
23064: LD_INT 99
23066: PPUSH
23067: LD_INT 5
23069: PPUSH
23070: LD_INT 0
23072: PPUSH
23073: CALL_OW 50
// wait ( 0 0$6 ) ;
23077: LD_INT 210
23079: PPUSH
23080: CALL_OW 67
// sci := sci ^ a ;
23084: LD_ADDR_EXP 91
23088: PUSH
23089: LD_EXP 91
23093: PUSH
23094: LD_VAR 0 1
23098: ADD
23099: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23100: LD_VAR 0 1
23104: PPUSH
23105: LD_INT 5
23107: PPUSH
23108: CALL_OW 113
// end ; end ; end ; enable ;
23112: ENABLE
// end ;
23113: PPOPN 1
23115: END
// every 0 0$3 do var sc ;
23116: GO 23118
23118: DISABLE
23119: LD_INT 0
23121: PPUSH
// begin sol := UnitFilter ( sol , [ f_alive ] ) ;
23122: LD_ADDR_EXP 90
23126: PUSH
23127: LD_EXP 90
23131: PPUSH
23132: LD_INT 51
23134: PUSH
23135: EMPTY
23136: LIST
23137: PPUSH
23138: CALL_OW 72
23142: ST_TO_ADDR
// eng := UnitFilter ( eng , [ f_alive ] ) ;
23143: LD_ADDR_EXP 93
23147: PUSH
23148: LD_EXP 93
23152: PPUSH
23153: LD_INT 51
23155: PUSH
23156: EMPTY
23157: LIST
23158: PPUSH
23159: CALL_OW 72
23163: ST_TO_ADDR
// mec := UnitFilter ( mec , [ f_alive ] ) ;
23164: LD_ADDR_EXP 92
23168: PUSH
23169: LD_EXP 92
23173: PPUSH
23174: LD_INT 51
23176: PUSH
23177: EMPTY
23178: LIST
23179: PPUSH
23180: CALL_OW 72
23184: ST_TO_ADDR
// sci := UnitFilter ( sci , [ f_alive ] ) ;
23185: LD_ADDR_EXP 91
23189: PUSH
23190: LD_EXP 91
23194: PPUSH
23195: LD_INT 51
23197: PUSH
23198: EMPTY
23199: LIST
23200: PPUSH
23201: CALL_OW 72
23205: ST_TO_ADDR
// defence := UnitFilter ( defence , [ f_alive ] ) ;
23206: LD_ADDR_LOC 6
23210: PUSH
23211: LD_LOC 6
23215: PPUSH
23216: LD_INT 51
23218: PUSH
23219: EMPTY
23220: LIST
23221: PPUSH
23222: CALL_OW 72
23226: ST_TO_ADDR
// cargo := UnitFilter ( cargo , [ f_alive ] ) ;
23227: LD_ADDR_LOC 3
23231: PUSH
23232: LD_LOC 3
23236: PPUSH
23237: LD_INT 51
23239: PUSH
23240: EMPTY
23241: LIST
23242: PPUSH
23243: CALL_OW 72
23247: ST_TO_ADDR
// attack := UnitFilter ( attack , [ f_alive ] ) ;
23248: LD_ADDR_LOC 5
23252: PUSH
23253: LD_LOC 5
23257: PPUSH
23258: LD_INT 51
23260: PUSH
23261: EMPTY
23262: LIST
23263: PPUSH
23264: CALL_OW 72
23268: ST_TO_ADDR
// scout := UnitFilter ( scout , [ f_alive ] ) ;
23269: LD_ADDR_LOC 4
23273: PUSH
23274: LD_LOC 4
23278: PPUSH
23279: LD_INT 51
23281: PUSH
23282: EMPTY
23283: LIST
23284: PPUSH
23285: CALL_OW 72
23289: ST_TO_ADDR
// broken := UnitFilter ( broken , [ f_alive ] ) ;
23290: LD_ADDR_LOC 21
23294: PUSH
23295: LD_LOC 21
23299: PPUSH
23300: LD_INT 51
23302: PUSH
23303: EMPTY
23304: LIST
23305: PPUSH
23306: CALL_OW 72
23310: ST_TO_ADDR
// sc := split ( scout ) ;
23311: LD_ADDR_VAR 0 1
23315: PUSH
23316: LD_LOC 4
23320: PPUSH
23321: CALL 17496 0 1
23325: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23326: LD_ADDR_LOC 7
23330: PUSH
23331: LD_VAR 0 1
23335: PUSH
23336: LD_INT 1
23338: ARRAY
23339: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23340: LD_ADDR_LOC 8
23344: PUSH
23345: LD_VAR 0 1
23349: PUSH
23350: LD_INT 2
23352: ARRAY
23353: ST_TO_ADDR
// forts := UnitFilter ( forts , [ f_alive ] ) ;
23354: LD_ADDR_LOC 10
23358: PUSH
23359: LD_LOC 10
23363: PPUSH
23364: LD_INT 51
23366: PUSH
23367: EMPTY
23368: LIST
23369: PPUSH
23370: CALL_OW 72
23374: ST_TO_ADDR
// end ;
23375: PPOPN 1
23377: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = russians then
23378: LD_VAR 0 3
23382: PUSH
23383: LD_EXP 2
23387: EQUAL
23388: IFFALSE 23566
// begin sol := sol diff vehold ;
23390: LD_ADDR_EXP 90
23394: PUSH
23395: LD_EXP 90
23399: PUSH
23400: LD_VAR 0 2
23404: DIFF
23405: ST_TO_ADDR
// eng := eng diff vehold ;
23406: LD_ADDR_EXP 93
23410: PUSH
23411: LD_EXP 93
23415: PUSH
23416: LD_VAR 0 2
23420: DIFF
23421: ST_TO_ADDR
// mec := mec diff vehold ;
23422: LD_ADDR_EXP 92
23426: PUSH
23427: LD_EXP 92
23431: PUSH
23432: LD_VAR 0 2
23436: DIFF
23437: ST_TO_ADDR
// sci := sci diff vehold ;
23438: LD_ADDR_EXP 91
23442: PUSH
23443: LD_EXP 91
23447: PUSH
23448: LD_VAR 0 2
23452: DIFF
23453: ST_TO_ADDR
// defence := defence diff vehold ;
23454: LD_ADDR_LOC 6
23458: PUSH
23459: LD_LOC 6
23463: PUSH
23464: LD_VAR 0 2
23468: DIFF
23469: ST_TO_ADDR
// cargo := cargo diff vehold ;
23470: LD_ADDR_LOC 3
23474: PUSH
23475: LD_LOC 3
23479: PUSH
23480: LD_VAR 0 2
23484: DIFF
23485: ST_TO_ADDR
// attack := attack diff vehold ;
23486: LD_ADDR_LOC 5
23490: PUSH
23491: LD_LOC 5
23495: PUSH
23496: LD_VAR 0 2
23500: DIFF
23501: ST_TO_ADDR
// scout := scout diff vehold ;
23502: LD_ADDR_LOC 4
23506: PUSH
23507: LD_LOC 4
23511: PUSH
23512: LD_VAR 0 2
23516: DIFF
23517: ST_TO_ADDR
// broken := broken diff vehold ;
23518: LD_ADDR_LOC 21
23522: PUSH
23523: LD_LOC 21
23527: PUSH
23528: LD_VAR 0 2
23532: DIFF
23533: ST_TO_ADDR
// scout1 := scout1 diff vehold ;
23534: LD_ADDR_LOC 7
23538: PUSH
23539: LD_LOC 7
23543: PUSH
23544: LD_VAR 0 2
23548: DIFF
23549: ST_TO_ADDR
// scout2 := scout2 diff vehold ;
23550: LD_ADDR_LOC 8
23554: PUSH
23555: LD_LOC 8
23559: PUSH
23560: LD_VAR 0 2
23564: DIFF
23565: ST_TO_ADDR
// end ; end ;
23566: PPOPN 4
23568: END
// on UnitDestroyed ( un ) do begin if un = JMM then
23569: LD_VAR 0 1
23573: PUSH
23574: LD_EXP 15
23578: EQUAL
23579: IFFALSE 23591
// begin disable ( 0 ) ;
23581: LD_INT 0
23583: DISABLE_MARKED
// YouLost ( JMM ) ;
23584: LD_STRING JMM
23586: PPUSH
23587: CALL_OW 104
// end ; if un = Kurt then
23591: LD_VAR 0 1
23595: PUSH
23596: LD_EXP 43
23600: EQUAL
23601: IFFALSE 23609
// begin SA_OnKurtKilled ;
23603: CALL 27044 0 0
// exit ;
23607: GO 23801
// end ; sol := sol diff un ;
23609: LD_ADDR_EXP 90
23613: PUSH
23614: LD_EXP 90
23618: PUSH
23619: LD_VAR 0 1
23623: DIFF
23624: ST_TO_ADDR
// eng := eng diff un ;
23625: LD_ADDR_EXP 93
23629: PUSH
23630: LD_EXP 93
23634: PUSH
23635: LD_VAR 0 1
23639: DIFF
23640: ST_TO_ADDR
// mec := mec diff un ;
23641: LD_ADDR_EXP 92
23645: PUSH
23646: LD_EXP 92
23650: PUSH
23651: LD_VAR 0 1
23655: DIFF
23656: ST_TO_ADDR
// sci := sci diff un ;
23657: LD_ADDR_EXP 91
23661: PUSH
23662: LD_EXP 91
23666: PUSH
23667: LD_VAR 0 1
23671: DIFF
23672: ST_TO_ADDR
// defence := defence diff un ;
23673: LD_ADDR_LOC 6
23677: PUSH
23678: LD_LOC 6
23682: PUSH
23683: LD_VAR 0 1
23687: DIFF
23688: ST_TO_ADDR
// cargo := cargo diff un ;
23689: LD_ADDR_LOC 3
23693: PUSH
23694: LD_LOC 3
23698: PUSH
23699: LD_VAR 0 1
23703: DIFF
23704: ST_TO_ADDR
// attack := attack diff un ;
23705: LD_ADDR_LOC 5
23709: PUSH
23710: LD_LOC 5
23714: PUSH
23715: LD_VAR 0 1
23719: DIFF
23720: ST_TO_ADDR
// scout := scout diff un ;
23721: LD_ADDR_LOC 4
23725: PUSH
23726: LD_LOC 4
23730: PUSH
23731: LD_VAR 0 1
23735: DIFF
23736: ST_TO_ADDR
// broken := broken diff un ;
23737: LD_ADDR_LOC 21
23741: PUSH
23742: LD_LOC 21
23746: PUSH
23747: LD_VAR 0 1
23751: DIFF
23752: ST_TO_ADDR
// scout1 := scout1 diff un ;
23753: LD_ADDR_LOC 7
23757: PUSH
23758: LD_LOC 7
23762: PUSH
23763: LD_VAR 0 1
23767: DIFF
23768: ST_TO_ADDR
// scout2 := scout2 diff un ;
23769: LD_ADDR_LOC 8
23773: PUSH
23774: LD_LOC 8
23778: PUSH
23779: LD_VAR 0 1
23783: DIFF
23784: ST_TO_ADDR
// forts := forts diff un ;
23785: LD_ADDR_LOC 10
23789: PUSH
23790: LD_LOC 10
23794: PUSH
23795: LD_VAR 0 1
23799: DIFF
23800: ST_TO_ADDR
// end ;
23801: PPOPN 1
23803: END
// on VehicleConstructed ( veh , fact ) do var i , sc ;
23804: LD_INT 0
23806: PPUSH
23807: PPUSH
// begin if GetSide ( fact ) = russians then
23808: LD_VAR 0 2
23812: PPUSH
23813: CALL_OW 255
23817: PUSH
23818: LD_EXP 2
23822: EQUAL
23823: IFFALSE 24042
// begin ComMoveToArea ( veh , parkoviste ) ;
23825: LD_VAR 0 1
23829: PPUSH
23830: LD_INT 13
23832: PPUSH
23833: CALL_OW 113
// while not IsInArea ( veh , parkoviste ) do
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 13
23844: PPUSH
23845: CALL_OW 308
23849: NOT
23850: IFFALSE 23861
// Wait ( 0 0$1 ) ;
23852: LD_INT 35
23854: PPUSH
23855: CALL_OW 67
23859: GO 23837
// ComExitVehicle ( veh ) ;
23861: LD_VAR 0 1
23865: PPUSH
23866: CALL_OW 121
// ComRemember ( veh ) ;
23870: LD_VAR 0 1
23874: PPUSH
23875: CALL_OW 143
// if to_defence then
23879: LD_LOC 25
23883: IFFALSE 23901
// begin defence := defence union veh ;
23885: LD_ADDR_LOC 6
23889: PUSH
23890: LD_LOC 6
23894: PUSH
23895: LD_VAR 0 1
23899: UNION
23900: ST_TO_ADDR
// end ; if to_cargo then
23901: LD_LOC 28
23905: IFFALSE 23923
// begin cargo := cargo union veh ;
23907: LD_ADDR_LOC 3
23911: PUSH
23912: LD_LOC 3
23916: PUSH
23917: LD_VAR 0 1
23921: UNION
23922: ST_TO_ADDR
// end ; if to_attack then
23923: LD_LOC 26
23927: IFFALSE 23945
// begin attack := attack union veh ;
23929: LD_ADDR_LOC 5
23933: PUSH
23934: LD_LOC 5
23938: PUSH
23939: LD_VAR 0 1
23943: UNION
23944: ST_TO_ADDR
// end ; if to_scout then
23945: LD_LOC 27
23949: IFFALSE 24010
// begin scout := scout union veh ;
23951: LD_ADDR_LOC 4
23955: PUSH
23956: LD_LOC 4
23960: PUSH
23961: LD_VAR 0 1
23965: UNION
23966: ST_TO_ADDR
// sc := split ( scout ) ;
23967: LD_ADDR_VAR 0 4
23971: PUSH
23972: LD_LOC 4
23976: PPUSH
23977: CALL 17496 0 1
23981: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23982: LD_ADDR_LOC 7
23986: PUSH
23987: LD_VAR 0 4
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23996: LD_ADDR_LOC 8
24000: PUSH
24001: LD_VAR 0 4
24005: PUSH
24006: LD_INT 2
24008: ARRAY
24009: ST_TO_ADDR
// end ; to_cargo := false ;
24010: LD_ADDR_LOC 28
24014: PUSH
24015: LD_INT 0
24017: ST_TO_ADDR
// to_scout := false ;
24018: LD_ADDR_LOC 27
24022: PUSH
24023: LD_INT 0
24025: ST_TO_ADDR
// to_attack := false ;
24026: LD_ADDR_LOC 26
24030: PUSH
24031: LD_INT 0
24033: ST_TO_ADDR
// to_defence := false ;
24034: LD_ADDR_LOC 25
24038: PUSH
24039: LD_INT 0
24041: ST_TO_ADDR
// end ; end ;
24042: PPOPN 4
24044: END
// every 0 0$30 trigger attacky > odplata_1 do var ubase ;
24045: LD_EXP 60
24049: PUSH
24050: LD_EXP 65
24054: GREATER
24055: IFFALSE 24302
24057: GO 24059
24059: DISABLE
24060: LD_INT 0
24062: PPUSH
// begin attacky := 0 ;
24063: LD_ADDR_EXP 60
24067: PUSH
24068: LD_INT 0
24070: ST_TO_ADDR
// more_scouting := false ;
24071: LD_ADDR_EXP 61
24075: PUSH
24076: LD_INT 0
24078: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24079: LD_ADDR_VAR 0 1
24083: PUSH
24084: LD_INT 21
24086: PUSH
24087: LD_INT 3
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: LD_INT 22
24096: PUSH
24097: LD_EXP 1
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: PPUSH
24110: CALL_OW 69
24114: ST_TO_ADDR
// if ubase then
24115: LD_VAR 0 1
24119: IFFALSE 24302
// begin case Rand ( 1 , 3 ) of 1 :
24121: LD_INT 1
24123: PPUSH
24124: LD_INT 3
24126: PPUSH
24127: CALL_OW 12
24131: PUSH
24132: LD_INT 1
24134: DOUBLE
24135: EQUAL
24136: IFTRUE 24140
24138: GO 24174
24140: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24141: LD_LOC 5
24145: PUSH
24146: LD_LOC 21
24150: DIFF
24151: PPUSH
24152: LD_EXP 90
24156: PPUSH
24157: LD_LOC 22
24161: PPUSH
24162: LD_INT 1
24164: PPUSH
24165: LD_INT 0
24167: PPUSH
24168: CALL 16883 0 5
24172: GO 24259
24174: LD_INT 2
24176: DOUBLE
24177: EQUAL
24178: IFTRUE 24182
24180: GO 24216
24182: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24183: LD_LOC 5
24187: PUSH
24188: LD_LOC 21
24192: DIFF
24193: PPUSH
24194: LD_EXP 90
24198: PPUSH
24199: LD_LOC 23
24203: PPUSH
24204: LD_INT 1
24206: PPUSH
24207: LD_INT 0
24209: PPUSH
24210: CALL 16883 0 5
24214: GO 24259
24216: LD_INT 3
24218: DOUBLE
24219: EQUAL
24220: IFTRUE 24224
24222: GO 24258
24224: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24225: LD_LOC 5
24229: PUSH
24230: LD_LOC 21
24234: DIFF
24235: PPUSH
24236: LD_EXP 90
24240: PPUSH
24241: LD_LOC 24
24245: PPUSH
24246: LD_INT 1
24248: PPUSH
24249: LD_INT 0
24251: PPUSH
24252: CALL 16883 0 5
24256: GO 24259
24258: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24259: LD_LOC 5
24263: PUSH
24264: LD_LOC 21
24268: DIFF
24269: PPUSH
24270: LD_VAR 0 1
24274: PUSH
24275: LD_INT 1
24277: ARRAY
24278: PPUSH
24279: CALL_OW 250
24283: PPUSH
24284: LD_VAR 0 1
24288: PUSH
24289: LD_INT 1
24291: ARRAY
24292: PPUSH
24293: CALL_OW 251
24297: PPUSH
24298: CALL_OW 174
// end ; end ;
24302: PPOPN 1
24304: END
// every 4 4$30 trigger attacky > odplata_2 do var ubase ;
24305: LD_EXP 60
24309: PUSH
24310: LD_EXP 66
24314: GREATER
24315: IFFALSE 24555
24317: GO 24319
24319: DISABLE
24320: LD_INT 0
24322: PPUSH
// begin attacky := 0 ;
24323: LD_ADDR_EXP 60
24327: PUSH
24328: LD_INT 0
24330: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24331: LD_ADDR_VAR 0 1
24335: PUSH
24336: LD_INT 21
24338: PUSH
24339: LD_INT 3
24341: PUSH
24342: EMPTY
24343: LIST
24344: LIST
24345: PUSH
24346: LD_INT 22
24348: PUSH
24349: LD_EXP 1
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PPUSH
24362: CALL_OW 69
24366: ST_TO_ADDR
// if ubase then
24367: LD_VAR 0 1
24371: IFFALSE 24554
// begin case Rand ( 1 , 3 ) of 1 :
24373: LD_INT 1
24375: PPUSH
24376: LD_INT 3
24378: PPUSH
24379: CALL_OW 12
24383: PUSH
24384: LD_INT 1
24386: DOUBLE
24387: EQUAL
24388: IFTRUE 24392
24390: GO 24426
24392: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24393: LD_LOC 5
24397: PUSH
24398: LD_LOC 21
24402: DIFF
24403: PPUSH
24404: LD_EXP 90
24408: PPUSH
24409: LD_LOC 22
24413: PPUSH
24414: LD_INT 1
24416: PPUSH
24417: LD_INT 0
24419: PPUSH
24420: CALL 16883 0 5
24424: GO 24511
24426: LD_INT 2
24428: DOUBLE
24429: EQUAL
24430: IFTRUE 24434
24432: GO 24468
24434: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24435: LD_LOC 5
24439: PUSH
24440: LD_LOC 21
24444: DIFF
24445: PPUSH
24446: LD_EXP 90
24450: PPUSH
24451: LD_LOC 23
24455: PPUSH
24456: LD_INT 1
24458: PPUSH
24459: LD_INT 0
24461: PPUSH
24462: CALL 16883 0 5
24466: GO 24511
24468: LD_INT 3
24470: DOUBLE
24471: EQUAL
24472: IFTRUE 24476
24474: GO 24510
24476: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24477: LD_LOC 5
24481: PUSH
24482: LD_LOC 21
24486: DIFF
24487: PPUSH
24488: LD_EXP 90
24492: PPUSH
24493: LD_LOC 24
24497: PPUSH
24498: LD_INT 1
24500: PPUSH
24501: LD_INT 0
24503: PPUSH
24504: CALL 16883 0 5
24508: GO 24511
24510: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24511: LD_LOC 5
24515: PUSH
24516: LD_LOC 21
24520: DIFF
24521: PPUSH
24522: LD_VAR 0 1
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: PPUSH
24531: CALL_OW 250
24535: PPUSH
24536: LD_VAR 0 1
24540: PUSH
24541: LD_INT 1
24543: ARRAY
24544: PPUSH
24545: CALL_OW 251
24549: PPUSH
24550: CALL_OW 174
// end ; enable ;
24554: ENABLE
// end ;
24555: PPOPN 1
24557: END
// every 8 8$30 trigger more_scouting do var ubase , a ;
24558: LD_EXP 61
24562: IFFALSE 24805
24564: GO 24566
24566: DISABLE
24567: LD_INT 0
24569: PPUSH
24570: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24571: LD_ADDR_VAR 0 1
24575: PUSH
24576: LD_INT 21
24578: PUSH
24579: LD_INT 3
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 22
24588: PUSH
24589: LD_EXP 1
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PPUSH
24602: CALL_OW 69
24606: ST_TO_ADDR
// a := attack diff broken ;
24607: LD_ADDR_VAR 0 2
24611: PUSH
24612: LD_LOC 5
24616: PUSH
24617: LD_LOC 21
24621: DIFF
24622: ST_TO_ADDR
// a := split ( a ) ;
24623: LD_ADDR_VAR 0 2
24627: PUSH
24628: LD_VAR 0 2
24632: PPUSH
24633: CALL 17496 0 1
24637: ST_TO_ADDR
// if ubase then
24638: LD_VAR 0 1
24642: IFFALSE 24805
// begin case Rand ( 1 , 3 ) of 1 :
24644: LD_INT 1
24646: PPUSH
24647: LD_INT 3
24649: PPUSH
24650: CALL_OW 12
24654: PUSH
24655: LD_INT 1
24657: DOUBLE
24658: EQUAL
24659: IFTRUE 24663
24661: GO 24691
24663: POP
// depart ( a , sol , attack_l , true , false ) ; 2 :
24664: LD_VAR 0 2
24668: PPUSH
24669: LD_EXP 90
24673: PPUSH
24674: LD_LOC 22
24678: PPUSH
24679: LD_INT 1
24681: PPUSH
24682: LD_INT 0
24684: PPUSH
24685: CALL 16883 0 5
24689: GO 24764
24691: LD_INT 2
24693: DOUBLE
24694: EQUAL
24695: IFTRUE 24699
24697: GO 24727
24699: POP
// depart ( a , sol , attack_m , true , false ) ; 3 :
24700: LD_VAR 0 2
24704: PPUSH
24705: LD_EXP 90
24709: PPUSH
24710: LD_LOC 23
24714: PPUSH
24715: LD_INT 1
24717: PPUSH
24718: LD_INT 0
24720: PPUSH
24721: CALL 16883 0 5
24725: GO 24764
24727: LD_INT 3
24729: DOUBLE
24730: EQUAL
24731: IFTRUE 24735
24733: GO 24763
24735: POP
// depart ( a , sol , attack_r , true , false ) ; end ;
24736: LD_VAR 0 2
24740: PPUSH
24741: LD_EXP 90
24745: PPUSH
24746: LD_LOC 24
24750: PPUSH
24751: LD_INT 1
24753: PPUSH
24754: LD_INT 0
24756: PPUSH
24757: CALL 16883 0 5
24761: GO 24764
24763: POP
// AddComAgressiveMove ( a [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24764: LD_VAR 0 2
24768: PUSH
24769: LD_INT 1
24771: ARRAY
24772: PPUSH
24773: LD_VAR 0 1
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: CALL_OW 250
24786: PPUSH
24787: LD_VAR 0 1
24791: PUSH
24792: LD_INT 1
24794: ARRAY
24795: PPUSH
24796: CALL_OW 251
24800: PPUSH
24801: CALL_OW 174
// end ; end ;
24805: PPOPN 2
24807: END
// every 16 16$30 trigger more_scouting do var ubase , at ;
24808: LD_EXP 61
24812: IFFALSE 25230
24814: GO 24816
24816: DISABLE
24817: LD_INT 0
24819: PPUSH
24820: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24821: LD_ADDR_VAR 0 1
24825: PUSH
24826: LD_INT 21
24828: PUSH
24829: LD_INT 3
24831: PUSH
24832: EMPTY
24833: LIST
24834: LIST
24835: PUSH
24836: LD_INT 22
24838: PUSH
24839: LD_EXP 1
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: PPUSH
24852: CALL_OW 69
24856: ST_TO_ADDR
// if ubase then
24857: LD_VAR 0 1
24861: IFFALSE 25230
// begin at := split ( attack diff broken ) ;
24863: LD_ADDR_VAR 0 2
24867: PUSH
24868: LD_LOC 5
24872: PUSH
24873: LD_LOC 21
24877: DIFF
24878: PPUSH
24879: CALL 17496 0 1
24883: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
24884: LD_INT 1
24886: PPUSH
24887: LD_INT 3
24889: PPUSH
24890: CALL_OW 12
24894: PUSH
24895: LD_INT 1
24897: DOUBLE
24898: EQUAL
24899: IFTRUE 24903
24901: GO 24935
24903: POP
// depart ( at [ 1 ] , sol , attack_l , true , false ) ; 2 :
24904: LD_VAR 0 2
24908: PUSH
24909: LD_INT 1
24911: ARRAY
24912: PPUSH
24913: LD_EXP 90
24917: PPUSH
24918: LD_LOC 22
24922: PPUSH
24923: LD_INT 1
24925: PPUSH
24926: LD_INT 0
24928: PPUSH
24929: CALL 16883 0 5
24933: GO 25016
24935: LD_INT 2
24937: DOUBLE
24938: EQUAL
24939: IFTRUE 24943
24941: GO 24975
24943: POP
// depart ( at [ 1 ] , sol , attack_m , true , false ) ; 3 :
24944: LD_VAR 0 2
24948: PUSH
24949: LD_INT 1
24951: ARRAY
24952: PPUSH
24953: LD_EXP 90
24957: PPUSH
24958: LD_LOC 23
24962: PPUSH
24963: LD_INT 1
24965: PPUSH
24966: LD_INT 0
24968: PPUSH
24969: CALL 16883 0 5
24973: GO 25016
24975: LD_INT 3
24977: DOUBLE
24978: EQUAL
24979: IFTRUE 24983
24981: GO 25015
24983: POP
// depart ( at [ 1 ] , sol , attack_r , true , false ) ; end ;
24984: LD_VAR 0 2
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: LD_EXP 90
24997: PPUSH
24998: LD_LOC 24
25002: PPUSH
25003: LD_INT 1
25005: PPUSH
25006: LD_INT 0
25008: PPUSH
25009: CALL 16883 0 5
25013: GO 25016
25015: POP
// case Rand ( 1 , 3 ) of 1 :
25016: LD_INT 1
25018: PPUSH
25019: LD_INT 3
25021: PPUSH
25022: CALL_OW 12
25026: PUSH
25027: LD_INT 1
25029: DOUBLE
25030: EQUAL
25031: IFTRUE 25035
25033: GO 25067
25035: POP
// depart ( at [ 2 ] , sol , attack_l , true , false ) ; 2 :
25036: LD_VAR 0 2
25040: PUSH
25041: LD_INT 2
25043: ARRAY
25044: PPUSH
25045: LD_EXP 90
25049: PPUSH
25050: LD_LOC 22
25054: PPUSH
25055: LD_INT 1
25057: PPUSH
25058: LD_INT 0
25060: PPUSH
25061: CALL 16883 0 5
25065: GO 25148
25067: LD_INT 2
25069: DOUBLE
25070: EQUAL
25071: IFTRUE 25075
25073: GO 25107
25075: POP
// depart ( at [ 2 ] , sol , attack_m , true , false ) ; 3 :
25076: LD_VAR 0 2
25080: PUSH
25081: LD_INT 2
25083: ARRAY
25084: PPUSH
25085: LD_EXP 90
25089: PPUSH
25090: LD_LOC 23
25094: PPUSH
25095: LD_INT 1
25097: PPUSH
25098: LD_INT 0
25100: PPUSH
25101: CALL 16883 0 5
25105: GO 25148
25107: LD_INT 3
25109: DOUBLE
25110: EQUAL
25111: IFTRUE 25115
25113: GO 25147
25115: POP
// depart ( at [ 2 ] , sol , attack_r , true , false ) ; end ;
25116: LD_VAR 0 2
25120: PUSH
25121: LD_INT 2
25123: ARRAY
25124: PPUSH
25125: LD_EXP 90
25129: PPUSH
25130: LD_LOC 24
25134: PPUSH
25135: LD_INT 1
25137: PPUSH
25138: LD_INT 0
25140: PPUSH
25141: CALL 16883 0 5
25145: GO 25148
25147: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25148: LD_VAR 0 2
25152: PUSH
25153: LD_INT 1
25155: ARRAY
25156: PPUSH
25157: LD_VAR 0 1
25161: PUSH
25162: LD_INT 1
25164: ARRAY
25165: PPUSH
25166: CALL_OW 250
25170: PPUSH
25171: LD_VAR 0 1
25175: PUSH
25176: LD_INT 1
25178: ARRAY
25179: PPUSH
25180: CALL_OW 251
25184: PPUSH
25185: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25189: LD_VAR 0 2
25193: PUSH
25194: LD_INT 2
25196: ARRAY
25197: PPUSH
25198: LD_VAR 0 1
25202: PUSH
25203: LD_INT 1
25205: ARRAY
25206: PPUSH
25207: CALL_OW 250
25211: PPUSH
25212: LD_VAR 0 1
25216: PUSH
25217: LD_INT 1
25219: ARRAY
25220: PPUSH
25221: CALL_OW 251
25225: PPUSH
25226: CALL_OW 174
// end ; end ;
25230: PPOPN 2
25232: END
// every 32 32$30 do var ubase ;
25233: GO 25235
25235: DISABLE
25236: LD_INT 0
25238: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25239: LD_ADDR_VAR 0 1
25243: PUSH
25244: LD_INT 21
25246: PUSH
25247: LD_INT 3
25249: PUSH
25250: EMPTY
25251: LIST
25252: LIST
25253: PUSH
25254: LD_INT 22
25256: PUSH
25257: LD_EXP 1
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PPUSH
25270: CALL_OW 69
25274: ST_TO_ADDR
// if ubase then
25275: LD_VAR 0 1
25279: IFFALSE 25480
// begin case Rand ( 1 , 3 ) of 1 :
25281: LD_INT 1
25283: PPUSH
25284: LD_INT 3
25286: PPUSH
25287: CALL_OW 12
25291: PUSH
25292: LD_INT 1
25294: DOUBLE
25295: EQUAL
25296: IFTRUE 25300
25298: GO 25340
25300: POP
// depart ( attack diff broken , sol ^ sci , attack_l , true , false ) ; 2 :
25301: LD_LOC 5
25305: PUSH
25306: LD_LOC 21
25310: DIFF
25311: PPUSH
25312: LD_EXP 90
25316: PUSH
25317: LD_EXP 91
25321: ADD
25322: PPUSH
25323: LD_LOC 22
25327: PPUSH
25328: LD_INT 1
25330: PPUSH
25331: LD_INT 0
25333: PPUSH
25334: CALL 16883 0 5
25338: GO 25437
25340: LD_INT 2
25342: DOUBLE
25343: EQUAL
25344: IFTRUE 25348
25346: GO 25388
25348: POP
// depart ( attack diff broken , sol ^ sci , attack_m , true , false ) ; 3 :
25349: LD_LOC 5
25353: PUSH
25354: LD_LOC 21
25358: DIFF
25359: PPUSH
25360: LD_EXP 90
25364: PUSH
25365: LD_EXP 91
25369: ADD
25370: PPUSH
25371: LD_LOC 23
25375: PPUSH
25376: LD_INT 1
25378: PPUSH
25379: LD_INT 0
25381: PPUSH
25382: CALL 16883 0 5
25386: GO 25437
25388: LD_INT 3
25390: DOUBLE
25391: EQUAL
25392: IFTRUE 25396
25394: GO 25436
25396: POP
// depart ( attack diff broken , sol ^ sci , attack_r , true , false ) ; end ;
25397: LD_LOC 5
25401: PUSH
25402: LD_LOC 21
25406: DIFF
25407: PPUSH
25408: LD_EXP 90
25412: PUSH
25413: LD_EXP 91
25417: ADD
25418: PPUSH
25419: LD_LOC 24
25423: PPUSH
25424: LD_INT 1
25426: PPUSH
25427: LD_INT 0
25429: PPUSH
25430: CALL 16883 0 5
25434: GO 25437
25436: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25437: LD_LOC 5
25441: PUSH
25442: LD_LOC 21
25446: DIFF
25447: PPUSH
25448: LD_VAR 0 1
25452: PUSH
25453: LD_INT 1
25455: ARRAY
25456: PPUSH
25457: CALL_OW 250
25461: PPUSH
25462: LD_VAR 0 1
25466: PUSH
25467: LD_INT 1
25469: ARRAY
25470: PPUSH
25471: CALL_OW 251
25475: PPUSH
25476: CALL_OW 174
// end ; end ;
25480: PPOPN 1
25482: END
// every 40 40$30 do var ubase , at ;
25483: GO 25485
25485: DISABLE
25486: LD_INT 0
25488: PPUSH
25489: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25490: LD_ADDR_VAR 0 1
25494: PUSH
25495: LD_INT 21
25497: PUSH
25498: LD_INT 3
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 22
25507: PUSH
25508: LD_EXP 1
25512: PUSH
25513: EMPTY
25514: LIST
25515: LIST
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PPUSH
25521: CALL_OW 69
25525: ST_TO_ADDR
// if ubase then
25526: LD_VAR 0 1
25530: IFFALSE 25977
// begin at := split ( ( attack union scout ) diff broken ) ;
25532: LD_ADDR_VAR 0 2
25536: PUSH
25537: LD_LOC 5
25541: PUSH
25542: LD_LOC 4
25546: UNION
25547: PUSH
25548: LD_LOC 21
25552: DIFF
25553: PPUSH
25554: CALL 17496 0 1
25558: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
25559: LD_INT 1
25561: PPUSH
25562: LD_INT 3
25564: PPUSH
25565: CALL_OW 12
25569: PUSH
25570: LD_INT 1
25572: DOUBLE
25573: EQUAL
25574: IFTRUE 25578
25576: GO 25622
25578: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25579: LD_VAR 0 2
25583: PUSH
25584: LD_INT 1
25586: ARRAY
25587: PPUSH
25588: LD_EXP 90
25592: PUSH
25593: LD_EXP 91
25597: ADD
25598: PUSH
25599: LD_EXP 93
25603: ADD
25604: PPUSH
25605: LD_LOC 22
25609: PPUSH
25610: LD_INT 1
25612: PPUSH
25613: LD_INT 0
25615: PPUSH
25616: CALL 16883 0 5
25620: GO 25727
25622: LD_INT 2
25624: DOUBLE
25625: EQUAL
25626: IFTRUE 25630
25628: GO 25674
25630: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25631: LD_VAR 0 2
25635: PUSH
25636: LD_INT 1
25638: ARRAY
25639: PPUSH
25640: LD_EXP 90
25644: PUSH
25645: LD_EXP 91
25649: ADD
25650: PUSH
25651: LD_EXP 93
25655: ADD
25656: PPUSH
25657: LD_LOC 23
25661: PPUSH
25662: LD_INT 1
25664: PPUSH
25665: LD_INT 0
25667: PPUSH
25668: CALL 16883 0 5
25672: GO 25727
25674: LD_INT 3
25676: DOUBLE
25677: EQUAL
25678: IFTRUE 25682
25680: GO 25726
25682: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25683: LD_VAR 0 2
25687: PUSH
25688: LD_INT 1
25690: ARRAY
25691: PPUSH
25692: LD_EXP 90
25696: PUSH
25697: LD_EXP 91
25701: ADD
25702: PUSH
25703: LD_EXP 93
25707: ADD
25708: PPUSH
25709: LD_LOC 24
25713: PPUSH
25714: LD_INT 1
25716: PPUSH
25717: LD_INT 0
25719: PPUSH
25720: CALL 16883 0 5
25724: GO 25727
25726: POP
// case Rand ( 1 , 3 ) of 1 :
25727: LD_INT 1
25729: PPUSH
25730: LD_INT 3
25732: PPUSH
25733: CALL_OW 12
25737: PUSH
25738: LD_INT 1
25740: DOUBLE
25741: EQUAL
25742: IFTRUE 25746
25744: GO 25790
25746: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25747: LD_VAR 0 2
25751: PUSH
25752: LD_INT 2
25754: ARRAY
25755: PPUSH
25756: LD_EXP 90
25760: PUSH
25761: LD_EXP 91
25765: ADD
25766: PUSH
25767: LD_EXP 93
25771: ADD
25772: PPUSH
25773: LD_LOC 22
25777: PPUSH
25778: LD_INT 1
25780: PPUSH
25781: LD_INT 0
25783: PPUSH
25784: CALL 16883 0 5
25788: GO 25895
25790: LD_INT 2
25792: DOUBLE
25793: EQUAL
25794: IFTRUE 25798
25796: GO 25842
25798: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25799: LD_VAR 0 2
25803: PUSH
25804: LD_INT 2
25806: ARRAY
25807: PPUSH
25808: LD_EXP 90
25812: PUSH
25813: LD_EXP 91
25817: ADD
25818: PUSH
25819: LD_EXP 93
25823: ADD
25824: PPUSH
25825: LD_LOC 23
25829: PPUSH
25830: LD_INT 1
25832: PPUSH
25833: LD_INT 0
25835: PPUSH
25836: CALL 16883 0 5
25840: GO 25895
25842: LD_INT 3
25844: DOUBLE
25845: EQUAL
25846: IFTRUE 25850
25848: GO 25894
25850: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25851: LD_VAR 0 2
25855: PUSH
25856: LD_INT 2
25858: ARRAY
25859: PPUSH
25860: LD_EXP 90
25864: PUSH
25865: LD_EXP 91
25869: ADD
25870: PUSH
25871: LD_EXP 93
25875: ADD
25876: PPUSH
25877: LD_LOC 24
25881: PPUSH
25882: LD_INT 1
25884: PPUSH
25885: LD_INT 0
25887: PPUSH
25888: CALL 16883 0 5
25892: GO 25895
25894: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25895: LD_VAR 0 2
25899: PUSH
25900: LD_INT 1
25902: ARRAY
25903: PPUSH
25904: LD_VAR 0 1
25908: PUSH
25909: LD_INT 1
25911: ARRAY
25912: PPUSH
25913: CALL_OW 250
25917: PPUSH
25918: LD_VAR 0 1
25922: PUSH
25923: LD_INT 1
25925: ARRAY
25926: PPUSH
25927: CALL_OW 251
25931: PPUSH
25932: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25936: LD_VAR 0 2
25940: PUSH
25941: LD_INT 2
25943: ARRAY
25944: PPUSH
25945: LD_VAR 0 1
25949: PUSH
25950: LD_INT 1
25952: ARRAY
25953: PPUSH
25954: CALL_OW 250
25958: PPUSH
25959: LD_VAR 0 1
25963: PUSH
25964: LD_INT 1
25966: ARRAY
25967: PPUSH
25968: CALL_OW 251
25972: PPUSH
25973: CALL_OW 174
// end ; end ;
25977: PPOPN 2
25979: END
// export function count_crates ; var deps , i ; begin
25980: LD_INT 0
25982: PPUSH
25983: PPUSH
25984: PPUSH
// deps := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25985: LD_ADDR_VAR 0 2
25989: PUSH
25990: LD_INT 22
25992: PUSH
25993: LD_EXP 1
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PUSH
26002: LD_INT 2
26004: PUSH
26005: LD_INT 30
26007: PUSH
26008: LD_INT 0
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 30
26017: PUSH
26018: LD_INT 1
26020: PUSH
26021: EMPTY
26022: LIST
26023: LIST
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: LIST
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PPUSH
26034: CALL_OW 69
26038: ST_TO_ADDR
// for i in deps do
26039: LD_ADDR_VAR 0 3
26043: PUSH
26044: LD_VAR 0 2
26048: PUSH
26049: FOR_IN
26050: IFFALSE 26083
// result := result + GetResourceType ( GetBase ( i ) , mat_cans ) ;
26052: LD_ADDR_VAR 0 1
26056: PUSH
26057: LD_VAR 0 1
26061: PUSH
26062: LD_VAR 0 3
26066: PPUSH
26067: CALL_OW 274
26071: PPUSH
26072: LD_INT 1
26074: PPUSH
26075: CALL_OW 275
26079: PLUS
26080: ST_TO_ADDR
26081: GO 26049
26083: POP
26084: POP
// end ;
26085: LD_VAR 0 1
26089: RET
// every 0 0$1 do var zbyva , prebyva ;
26090: GO 26092
26092: DISABLE
26093: LD_INT 0
26095: PPUSH
26096: PPUSH
// begin sec := sec + 1 ;
26097: LD_ADDR_LOC 29
26101: PUSH
26102: LD_LOC 29
26106: PUSH
26107: LD_INT 1
26109: PLUS
26110: ST_TO_ADDR
// zbyva := MaterialNavic - count_crates ;
26111: LD_ADDR_VAR 0 1
26115: PUSH
26116: LD_EXP 51
26120: PUSH
26121: CALL 25980 0 0
26125: MINUS
26126: ST_TO_ADDR
// if zbyva < 0 then
26127: LD_VAR 0 1
26131: PUSH
26132: LD_INT 0
26134: LESS
26135: IFFALSE 26160
// begin prebyva := zbyva * ( - 1 ) ;
26137: LD_ADDR_VAR 0 2
26141: PUSH
26142: LD_VAR 0 1
26146: PUSH
26147: LD_INT 1
26149: NEG
26150: MUL
26151: ST_TO_ADDR
// zbyva := 0 ;
26152: LD_ADDR_VAR 0 1
26156: PUSH
26157: LD_INT 0
26159: ST_TO_ADDR
// end ; display_strings := [ #Am06-1 , zbyva , #Am06-2 , 50 50$0 - ( tick - mytick ) ] ;
26160: LD_ADDR_OWVAR 47
26164: PUSH
26165: LD_STRING #Am06-1
26167: PUSH
26168: LD_VAR 0 1
26172: PUSH
26173: LD_STRING #Am06-2
26175: PUSH
26176: LD_INT 105000
26178: PUSH
26179: LD_OWVAR 1
26183: PUSH
26184: LD_EXP 86
26188: MINUS
26189: MINUS
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: LIST
26195: LIST
26196: ST_TO_ADDR
// enable ;
26197: ENABLE
// end ;
26198: PPOPN 2
26200: END
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26201: LD_INT 4
26203: PPUSH
26204: LD_INT 22
26206: PUSH
26207: LD_EXP 1
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PPUSH
26216: CALL_OW 70
26220: IFFALSE 26295
26222: GO 26224
26224: DISABLE
26225: LD_INT 0
26227: PPUSH
// begin under_attack := true ;
26228: LD_ADDR_EXP 64
26232: PUSH
26233: LD_INT 1
26235: ST_TO_ADDR
// for i in FilterUnitsInArea ( near_base , [ f_side , you ] ) do
26236: LD_ADDR_VAR 0 1
26240: PUSH
26241: LD_INT 4
26243: PPUSH
26244: LD_INT 22
26246: PUSH
26247: LD_EXP 1
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PPUSH
26256: CALL_OW 70
26260: PUSH
26261: FOR_IN
26262: IFFALSE 26292
// ComAttackUnit ( defence union attack union scout , i ) ;
26264: LD_LOC 6
26268: PUSH
26269: LD_LOC 5
26273: UNION
26274: PUSH
26275: LD_LOC 4
26279: UNION
26280: PPUSH
26281: LD_VAR 0 1
26285: PPUSH
26286: CALL_OW 115
26290: GO 26261
26292: POP
26293: POP
// enable ;
26294: ENABLE
// end ;
26295: PPOPN 1
26297: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26298: LD_INT 4
26300: PPUSH
26301: LD_INT 22
26303: PUSH
26304: LD_EXP 1
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PPUSH
26313: CALL_OW 70
26317: NOT
26318: IFFALSE 26335
26320: GO 26322
26322: DISABLE
26323: LD_INT 0
26325: PPUSH
// begin under_attack := false ;
26326: LD_ADDR_EXP 64
26330: PUSH
26331: LD_INT 0
26333: ST_TO_ADDR
// enable ;
26334: ENABLE
// end ; end_of_file
26335: PPOPN 1
26337: END
// var BaseBuild ; every 0 0$1.0 do var set_fuel , fuel , depot ;
26338: GO 26340
26340: DISABLE
26341: LD_INT 0
26343: PPUSH
26344: PPUSH
26345: PPUSH
// begin for depot in FilterAllUnits ( [ [ f_btype , b_depot ] , [ f_side , you ] ] ) do
26346: LD_ADDR_VAR 0 3
26350: PUSH
26351: LD_INT 30
26353: PUSH
26354: LD_INT 0
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 22
26363: PUSH
26364: LD_EXP 1
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PPUSH
26377: CALL_OW 69
26381: PUSH
26382: FOR_IN
26383: IFFALSE 26490
// for set_fuel in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] , [ f_dist , depot , 8 ] ] ) do
26385: LD_ADDR_VAR 0 1
26389: PUSH
26390: LD_INT 21
26392: PUSH
26393: LD_INT 2
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: LD_INT 22
26402: PUSH
26403: LD_EXP 1
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PUSH
26412: LD_INT 91
26414: PUSH
26415: LD_VAR 0 3
26419: PUSH
26420: LD_INT 8
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: LIST
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: LIST
26432: PPUSH
26433: CALL_OW 69
26437: PUSH
26438: FOR_IN
26439: IFFALSE 26486
// begin fuel := GetFuel ( set_fuel ) ;
26441: LD_ADDR_VAR 0 2
26445: PUSH
26446: LD_VAR 0 1
26450: PPUSH
26451: CALL_OW 261
26455: ST_TO_ADDR
// if fuel <= 80 then
26456: LD_VAR 0 2
26460: PUSH
26461: LD_INT 80
26463: LESSEQUAL
26464: IFFALSE 26484
// SetFuel ( set_fuel , fuel + 20 ) ;
26466: LD_VAR 0 1
26470: PPUSH
26471: LD_VAR 0 2
26475: PUSH
26476: LD_INT 20
26478: PLUS
26479: PPUSH
26480: CALL_OW 240
// end ;
26484: GO 26438
26486: POP
26487: POP
26488: GO 26382
26490: POP
26491: POP
// enable ;
26492: ENABLE
// end ;
26493: PPOPN 3
26495: END
// export maj_ct ; on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) then
26496: LD_VAR 0 1
26500: PPUSH
26501: LD_INT 22
26503: PUSH
26504: LD_EXP 1
26508: PUSH
26509: EMPTY
26510: LIST
26511: LIST
26512: PUSH
26513: LD_INT 30
26515: PUSH
26516: LD_INT 0
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 72
26531: IFFALSE 26595
// begin BaseBuild := true ;
26533: LD_ADDR_LOC 32
26537: PUSH
26538: LD_INT 1
26540: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
26541: LD_STRING M1a
26543: PPUSH
26544: CALL_OW 337
// Setbname ( UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) [ 1 ] , epsilon ) ;
26548: LD_VAR 0 1
26552: PPUSH
26553: LD_INT 22
26555: PUSH
26556: LD_EXP 1
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 30
26567: PUSH
26568: LD_INT 0
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PPUSH
26579: CALL_OW 72
26583: PUSH
26584: LD_INT 1
26586: ARRAY
26587: PPUSH
26588: LD_STRING epsilon
26590: PPUSH
26591: CALL_OW 500
// end ; if GetBType ( build ) = b_control_tower then
26595: LD_VAR 0 1
26599: PPUSH
26600: CALL_OW 266
26604: PUSH
26605: LD_INT 36
26607: EQUAL
26608: IFFALSE 26618
// maj_ct := true ;
26610: LD_ADDR_EXP 94
26614: PUSH
26615: LD_INT 1
26617: ST_TO_ADDR
// end ;
26618: PPOPN 1
26620: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_factory ] ] ) then
26621: LD_VAR 0 1
26625: PPUSH
26626: LD_INT 22
26628: PUSH
26629: LD_EXP 1
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 30
26640: PUSH
26641: LD_INT 3
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: EMPTY
26649: LIST
26650: LIST
26651: PPUSH
26652: CALL_OW 72
26656: IFFALSE 26665
// MyHint ( NonCombat ) ;
26658: LD_STRING NonCombat
26660: PPUSH
26661: CALL 17607 0 1
// end ;
26665: PPOPN 1
26667: END
// every 0 0$3 do var ok , sez , i ;
26668: GO 26670
26670: DISABLE
26671: LD_INT 0
26673: PPUSH
26674: PPUSH
26675: PPUSH
// begin sez := [ ] ;
26676: LD_ADDR_VAR 0 2
26680: PUSH
26681: EMPTY
26682: ST_TO_ADDR
// ok := false ;
26683: LD_ADDR_VAR 0 1
26687: PUSH
26688: LD_INT 0
26690: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_control , control_remote ] ) do
26691: LD_ADDR_VAR 0 3
26695: PUSH
26696: LD_INT 33
26698: PUSH
26699: LD_INT 2
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL_OW 69
26710: PUSH
26711: FOR_IN
26712: IFFALSE 26761
// begin if IsControledBy ( i ) in sez then
26714: LD_VAR 0 3
26718: PPUSH
26719: CALL_OW 312
26723: PUSH
26724: LD_VAR 0 2
26728: IN
26729: IFFALSE 26743
// begin ok := true ;
26731: LD_ADDR_VAR 0 1
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// break ;
26739: GO 26761
// end else
26741: GO 26759
// sez := sez ^ i ;
26743: LD_ADDR_VAR 0 2
26747: PUSH
26748: LD_VAR 0 2
26752: PUSH
26753: LD_VAR 0 3
26757: ADD
26758: ST_TO_ADDR
// end ;
26759: GO 26711
26761: POP
26762: POP
// if ok then
26763: LD_VAR 0 1
26767: IFFALSE 26778
// begin ChangeMissionObjectives ( MRa ) ;
26769: LD_STRING MRa
26771: PPUSH
26772: CALL_OW 337
// end else
26776: GO 26779
// enable ;
26778: ENABLE
// end ;
26779: PPOPN 3
26781: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_RemCont and GetSide ( lab ) = you then
26782: LD_VAR 0 1
26786: PUSH
26787: LD_INT 15
26789: EQUAL
26790: PUSH
26791: LD_VAR 0 2
26795: PPUSH
26796: CALL_OW 255
26800: PUSH
26801: LD_EXP 1
26805: EQUAL
26806: AND
26807: IFFALSE 26820
// begin DialogR2 ;
26809: CALL 6574 0 0
// MyHint ( RemoteControlTower ) ;
26813: LD_STRING RemoteControlTower
26815: PPUSH
26816: CALL 17607 0 1
// end ; if tech = tech_MatDet and GetSide ( lab ) = you then
26820: LD_VAR 0 1
26824: PUSH
26825: LD_INT 7
26827: EQUAL
26828: PUSH
26829: LD_VAR 0 2
26833: PPUSH
26834: CALL_OW 255
26838: PUSH
26839: LD_EXP 1
26843: EQUAL
26844: AND
26845: IFFALSE 26854
// begin MyHint ( MaterialisationDetection ) ;
26847: LD_STRING MaterialisationDetection
26849: PPUSH
26850: CALL 17607 0 1
// end ; end ; end_of_file
26854: PPOPN 2
26856: END
// every 0 0$2 + 0 0$0.1 do
26857: GO 26859
26859: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
26860: LD_INT 22
26862: PUSH
26863: LD_INT 1
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: PUSH
26870: LD_INT 2
26872: PUSH
26873: LD_INT 25
26875: PUSH
26876: LD_INT 12
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 25
26885: PUSH
26886: LD_INT 16
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PUSH
26893: LD_INT 25
26895: PUSH
26896: LD_INT 15
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 25
26905: PUSH
26906: LD_INT 17
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PPUSH
26924: CALL_OW 69
26928: PUSH
26929: LD_INT 22
26931: PUSH
26932: LD_INT 1
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 21
26941: PUSH
26942: LD_INT 1
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 3
26951: PUSH
26952: LD_INT 2
26954: PUSH
26955: LD_INT 25
26957: PUSH
26958: LD_INT 12
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: PUSH
26965: LD_INT 25
26967: PUSH
26968: LD_INT 16
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 25
26977: PUSH
26978: LD_INT 15
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 25
26987: PUSH
26988: LD_INT 17
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: LIST
26999: LIST
27000: LIST
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: LIST
27010: PPUSH
27011: CALL_OW 69
27015: GREATER
27016: IFFALSE 27027
// begin SetAchievement ( ACH_POTA ) ;
27018: LD_STRING ACH_POTA
27020: PPUSH
27021: CALL_OW 543
// exit ;
27025: GO 27028
// end ; enable ;
27027: ENABLE
// end ;
27028: END
// export function SA_OnKurtSpared ; begin
27029: LD_INT 0
27031: PPUSH
// SetAchievement ( ACH_MER ) ;
27032: LD_STRING ACH_MER
27034: PPUSH
27035: CALL_OW 543
// end ;
27039: LD_VAR 0 1
27043: RET
// export function SA_OnKurtKilled ; begin
27044: LD_INT 0
27046: PPUSH
// SetAchievement ( ACH_MEL ) ;
27047: LD_STRING ACH_MEL
27049: PPUSH
27050: CALL_OW 543
// end ;
27054: LD_VAR 0 1
27058: RET
// export function SA_On1000CratesGathered ; begin
27059: LD_INT 0
27061: PPUSH
// SetAchievement ( ACH_CAP ) ;
27062: LD_STRING ACH_CAP
27064: PPUSH
27065: CALL_OW 543
// end ;
27069: LD_VAR 0 1
27073: RET
// export function SA_CratesGathered ( count_crates ) ; begin
27074: LD_INT 0
27076: PPUSH
// SetAchievementEX ( ACH_CAP , count_crates ) ;
27077: LD_STRING ACH_CAP
27079: PPUSH
27080: LD_VAR 0 1
27084: PPUSH
27085: CALL_OW 564
// end ; end_of_file
27089: LD_VAR 0 2
27093: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
27094: LD_INT 0
27096: PPUSH
27097: PPUSH
// if not missionNumber then
27098: LD_VAR 0 2
27102: NOT
27103: IFFALSE 27107
// exit ;
27105: GO 27208
// achiv := false ;
27107: LD_ADDR_VAR 0 7
27111: PUSH
27112: LD_INT 0
27114: ST_TO_ADDR
// case campaignNumber of 1 :
27115: LD_VAR 0 1
27119: PUSH
27120: LD_INT 1
27122: DOUBLE
27123: EQUAL
27124: IFTRUE 27128
27126: GO 27139
27128: POP
// achiv := ACH_GOTA ; 2 :
27129: LD_ADDR_VAR 0 7
27133: PUSH
27134: LD_STRING ACH_GOTA
27136: ST_TO_ADDR
27137: GO 27170
27139: LD_INT 2
27141: DOUBLE
27142: EQUAL
27143: IFTRUE 27147
27145: GO 27150
27147: POP
// ; 3 :
27148: GO 27170
27150: LD_INT 3
27152: DOUBLE
27153: EQUAL
27154: IFTRUE 27158
27156: GO 27169
27158: POP
// achiv := ACH_MOTRF ; end ;
27159: LD_ADDR_VAR 0 7
27163: PUSH
27164: LD_STRING ACH_MOTRF
27166: ST_TO_ADDR
27167: GO 27170
27169: POP
// if achiv and medal1 and medal2 and medal3 then
27170: LD_VAR 0 7
27174: PUSH
27175: LD_VAR 0 3
27179: AND
27180: PUSH
27181: LD_VAR 0 4
27185: AND
27186: PUSH
27187: LD_VAR 0 5
27191: AND
27192: IFFALSE 27208
// SetAchievementEX ( achiv , missionNumber ) ;
27194: LD_VAR 0 7
27198: PPUSH
27199: LD_VAR 0 2
27203: PPUSH
27204: CALL_OW 564
// end ;
27208: LD_VAR 0 6
27212: RET

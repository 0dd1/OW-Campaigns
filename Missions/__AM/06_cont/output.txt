// export you , russians , arabians , you2 ; export apemans ; export prilet_tvoji ; export prilet_rusaci ; export prilet_arabi ; export all , other ; export not_char , used , opicaci ; export zgamy2 ; export JMM ; export Har ; export RadioSci ; export Sol1 , Eng1 ; export Frank , Lisa ; export Cyrus , Bobby , Donaldson , Brown , Denis , Gladstone ; export MSol1 , MSol2 , MSol3 , MEng1 , MMec1 , Joan ; export Op1 , Op2 , Op3 , Op4 , Op5 ; export RMSo1 , RMSo2 , RMEn1 , RMMe1 ; export Kurt ; export Car1 , Car2 ; export Denis_P , Kurt_P , Joan_P , Lisa_P , Frank_P ; export MaterialNavic ; export DialogInProgress ; export map_size_x , map_size_y ; export start_game ; export test_JMM_Joan ; export before_d6 ; export act_Lisa_JMM ; export hledani ; export attacky ; export more_scouting ; export go_up ; export attacking ; export under_attack ; export odplata_1 ; export odplata_2 ; export attack_to_scouting ; export start_scouting ; export WasD11aa , WasD11ab , WasD11b , WasD11c , WasD11d , WasD11e , WasD11f ; export crates ; export list_of_R1_query ; export Gamma3_lab_upgraded_to_opto ; export Gamma3_lab_upgraded_to_weapon ; export radar_invented ; export vzit_opicaku ; export remote_tried ; export Gamma2Commander ; export NavicLidi ; export KurtTryToEscape ; export noBodyLeft ; starting begin disable ( 33 ) ;
   0: LD_INT 33
   2: DISABLE_MARKED
// disable_prediction := true ;
   3: LD_ADDR_OWVAR 50
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// map_size_x := 100 ;
  11: LD_ADDR_EXP 53
  15: PUSH
  16: LD_INT 100
  18: ST_TO_ADDR
// map_size_y := 100 ;
  19: LD_ADDR_EXP 54
  23: PUSH
  24: LD_INT 100
  26: ST_TO_ADDR
// noBodyLeft := true ;
  27: LD_ADDR_EXP 86
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// prepare_sides ;
  35: CALL 2069 0 0
// load_characters ;
  39: CALL 276 0 0
// prepare_russian_units ;
  43: CALL 1698 0 0
// prepare_arabian_units ;
  47: CALL 2024 0 0
// if radar_invented then
  51: LD_EXP 80
  55: IFFALSE 72
// SetTech ( tech_Radar , you , state_researched ) ;
  57: LD_INT 6
  59: PPUSH
  60: LD_EXP 1
  64: PPUSH
  65: LD_INT 2
  67: PPUSH
  68: CALL_OW 322
// Gamma3_lab_upgraded_to_opto := false ;
  72: LD_ADDR_EXP 78
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// Gamma3_lab_upgraded_to_weapon := false ;
  80: LD_ADDR_EXP 79
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// SetDifficulty ;
  88: CALL 2169 0 0
// apemans := FilterAllUnits ( [ f_nation , nation_nature ] ) ;
  92: LD_ADDR_EXP 5
  96: PUSH
  97: LD_INT 23
  99: PUSH
 100: LD_INT 0
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: PPUSH
 107: CALL_OW 69
 111: ST_TO_ADDR
// Kurt_P := false ;
 112: LD_ADDR_EXP 47
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// Joan_P := false ;
 120: LD_ADDR_EXP 48
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// start_game := false ;
 128: LD_ADDR_EXP 55
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// test_JMM_Joan := false ;
 136: LD_ADDR_EXP 56
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// before_d6 := false ;
 144: LD_ADDR_EXP 57
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// act_Lisa_JMM := false ;
 152: LD_ADDR_EXP 58
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// hledani := false ;
 160: LD_ADDR_EXP 59
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// more_scouting := false ;
 168: LD_ADDR_EXP 61
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// go_up := false ;
 176: LD_ADDR_EXP 62
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// WasD11aa := false ;
 184: LD_ADDR_EXP 69
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// WasD11ab := false ;
 192: LD_ADDR_EXP 70
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// WasD11b := false ;
 200: LD_ADDR_EXP 71
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// WasD11c := false ;
 208: LD_ADDR_EXP 72
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// WasD11d := false ;
 216: LD_ADDR_EXP 73
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// WasD11e := false ;
 224: LD_ADDR_EXP 74
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// WasD11f := false ;
 232: LD_ADDR_EXP 75
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// crates := [ ] ;
 240: LD_ADDR_EXP 76
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// attacky := 0 ;
 247: LD_ADDR_EXP 60
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// attacking := false ;
 255: LD_ADDR_EXP 63
 259: PUSH
 260: LD_INT 0
 262: ST_TO_ADDR
// under_attack := false ;
 263: LD_ADDR_EXP 64
 267: PUSH
 268: LD_INT 0
 270: ST_TO_ADDR
// Dialog1 ;
 271: CALL 4406 0 0
// end ;
 275: END
// function load_characters ; begin
 276: LD_INT 0
 278: PPUSH
// InitUc ;
 279: CALL_OW 18
// InitHc ;
 283: CALL_OW 19
// InitVc ;
 287: CALL_OW 20
// uc_side := arabians ;
 291: LD_ADDR_OWVAR 20
 295: PUSH
 296: LD_EXP 3
 300: ST_TO_ADDR
// uc_nation := nation_arabian ;
 301: LD_ADDR_OWVAR 21
 305: PUSH
 306: LD_INT 2
 308: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
 309: LD_ADDR_EXP 43
 313: PUSH
 314: LD_STRING Kurt
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// uc_side := you ;
 322: LD_ADDR_OWVAR 20
 326: PUSH
 327: LD_EXP 1
 331: ST_TO_ADDR
// uc_nation := nation_american ;
 332: LD_ADDR_OWVAR 21
 336: PUSH
 337: LD_INT 1
 339: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 340: LD_ADDR_EXP 15
 344: PUSH
 345: LD_STRING JMM
 347: PPUSH
 348: CALL_OW 34
 352: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 353: LD_ADDR_EXP 16
 357: PUSH
 358: LD_STRING Harisson
 360: PPUSH
 361: CALL_OW 25
 365: ST_TO_ADDR
// if TestCharacters ( other_from5to6 ) then
 366: LD_STRING other_from5to6
 368: PPUSH
 369: CALL_OW 28
 373: IFFALSE 390
// all := CreateCharacterSet ( other_from5to6 ) else
 375: LD_ADDR_EXP 9
 379: PUSH
 380: LD_STRING other_from5to6
 382: PPUSH
 383: CALL_OW 31
 387: ST_TO_ADDR
 388: GO 397
// all := [ ] ;
 390: LD_ADDR_EXP 9
 394: PUSH
 395: EMPTY
 396: ST_TO_ADDR
// if CheckCharacterSet ( radiosci_from5to6 ) then
 397: LD_STRING radiosci_from5to6
 399: PPUSH
 400: CALL_OW 29
 404: IFFALSE 421
// RadioSci := CreateCharacter ( radiosci_from5to6 ) else
 406: LD_ADDR_EXP 17
 410: PUSH
 411: LD_STRING radiosci_from5to6
 413: PPUSH
 414: CALL_OW 34
 418: ST_TO_ADDR
 419: GO 441
// begin PrepareScientist ( sex_male , 10 ) ;
 421: LD_INT 1
 423: PPUSH
 424: LD_INT 10
 426: PPUSH
 427: CALL_OW 384
// RadioSci := CreateHuman ;
 431: LD_ADDR_EXP 17
 435: PUSH
 436: CALL_OW 44
 440: ST_TO_ADDR
// end ; DeleteCharacters ( radiosci_from5to6 ) ;
 441: LD_STRING radiosci_from5to6
 443: PPUSH
 444: CALL_OW 40
// other := all ;
 448: LD_ADDR_EXP 10
 452: PUSH
 453: LD_EXP 9
 457: ST_TO_ADDR
// radar_invented := LoadVariable ( RadarDeveloped , false ) ;
 458: LD_ADDR_EXP 80
 462: PUSH
 463: LD_STRING RadarDeveloped
 465: PPUSH
 466: LD_INT 0
 468: PPUSH
 469: CALL_OW 30
 473: ST_TO_ADDR
// Gamma2Commander := LoadVariable ( Gamma2Commander , 3 ) ;
 474: LD_ADDR_EXP 83
 478: PUSH
 479: LD_STRING Gamma2Commander
 481: PPUSH
 482: LD_INT 3
 484: PPUSH
 485: CALL_OW 30
 489: ST_TO_ADDR
// opicaci := [ ] ;
 490: LD_ADDR_EXP 13
 494: PUSH
 495: EMPTY
 496: ST_TO_ADDR
// if CheckCharacterSet ( opicaci ) then
 497: LD_STRING opicaci
 499: PPUSH
 500: CALL_OW 29
 504: IFFALSE 519
// opicaci := CreateCharacterSet ( opicaci ) ;
 506: LD_ADDR_EXP 13
 510: PUSH
 511: LD_STRING opicaci
 513: PPUSH
 514: CALL_OW 31
 518: ST_TO_ADDR
// Lisa := 0 ;
 519: LD_ADDR_EXP 21
 523: PUSH
 524: LD_INT 0
 526: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 527: LD_STRING Lisa
 529: PPUSH
 530: CALL_OW 29
 534: IFFALSE 592
// if LoadVariable ( LisaLoc , 0 ) = 8 then
 536: LD_STRING LisaLoc
 538: PPUSH
 539: LD_INT 0
 541: PPUSH
 542: CALL_OW 30
 546: PUSH
 547: LD_INT 8
 549: EQUAL
 550: IFFALSE 592
// begin Lisa := CreateCharacter ( Lisa ) ;
 552: LD_ADDR_EXP 21
 556: PUSH
 557: LD_STRING Lisa
 559: PPUSH
 560: CALL_OW 34
 564: ST_TO_ADDR
// Lisa_P := true ;
 565: LD_ADDR_EXP 49
 569: PUSH
 570: LD_INT 1
 572: ST_TO_ADDR
// all := all ^ [ Lisa ] ;
 573: LD_ADDR_EXP 9
 577: PUSH
 578: LD_EXP 9
 582: PUSH
 583: LD_EXP 21
 587: PUSH
 588: EMPTY
 589: LIST
 590: ADD
 591: ST_TO_ADDR
// end ; Cyrus := 0 ;
 592: LD_ADDR_EXP 22
 596: PUSH
 597: LD_INT 0
 599: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 600: LD_STRING Cyrus
 602: PPUSH
 603: CALL_OW 29
 607: IFFALSE 657
// if LoadVariable ( CyrusLoc , 0 ) = 8 then
 609: LD_STRING CyrusLoc
 611: PPUSH
 612: LD_INT 0
 614: PPUSH
 615: CALL_OW 30
 619: PUSH
 620: LD_INT 8
 622: EQUAL
 623: IFFALSE 657
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 625: LD_ADDR_EXP 22
 629: PUSH
 630: LD_STRING Cyrus
 632: PPUSH
 633: CALL_OW 34
 637: ST_TO_ADDR
// all := all ^ [ Cyrus ] ;
 638: LD_ADDR_EXP 9
 642: PUSH
 643: LD_EXP 9
 647: PUSH
 648: LD_EXP 22
 652: PUSH
 653: EMPTY
 654: LIST
 655: ADD
 656: ST_TO_ADDR
// end ; Bobby := 0 ;
 657: LD_ADDR_EXP 23
 661: PUSH
 662: LD_INT 0
 664: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 665: LD_STRING Bobby
 667: PPUSH
 668: CALL_OW 29
 672: IFFALSE 722
// if LoadVariable ( BobbyLoc , 0 ) = 8 then
 674: LD_STRING BobbyLoc
 676: PPUSH
 677: LD_INT 0
 679: PPUSH
 680: CALL_OW 30
 684: PUSH
 685: LD_INT 8
 687: EQUAL
 688: IFFALSE 722
// begin Bobby := CreateCharacter ( Bobby ) ;
 690: LD_ADDR_EXP 23
 694: PUSH
 695: LD_STRING Bobby
 697: PPUSH
 698: CALL_OW 34
 702: ST_TO_ADDR
// all := all ^ [ Bobby ] ;
 703: LD_ADDR_EXP 9
 707: PUSH
 708: LD_EXP 9
 712: PUSH
 713: LD_EXP 23
 717: PUSH
 718: EMPTY
 719: LIST
 720: ADD
 721: ST_TO_ADDR
// end ; Frank := 0 ;
 722: LD_ADDR_EXP 20
 726: PUSH
 727: LD_INT 0
 729: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 730: LD_STRING Frank
 732: PPUSH
 733: CALL_OW 29
 737: IFFALSE 795
// if LoadVariable ( FrankLoc , 0 ) = 8 then
 739: LD_STRING FrankLoc
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 30
 749: PUSH
 750: LD_INT 8
 752: EQUAL
 753: IFFALSE 795
// begin Frank := CreateCharacter ( Frank ) ;
 755: LD_ADDR_EXP 20
 759: PUSH
 760: LD_STRING Frank
 762: PPUSH
 763: CALL_OW 34
 767: ST_TO_ADDR
// Frank_P := true ;
 768: LD_ADDR_EXP 50
 772: PUSH
 773: LD_INT 1
 775: ST_TO_ADDR
// all := all ^ [ Frank ] ;
 776: LD_ADDR_EXP 9
 780: PUSH
 781: LD_EXP 9
 785: PUSH
 786: LD_EXP 20
 790: PUSH
 791: EMPTY
 792: LIST
 793: ADD
 794: ST_TO_ADDR
// end ; Donaldson := 0 ;
 795: LD_ADDR_EXP 24
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 803: LD_STRING Donaldson
 805: PPUSH
 806: CALL_OW 29
 810: IFFALSE 860
// if LoadVariable ( DonaldsonLoc , 0 ) = 8 then
 812: LD_STRING DonaldsonLoc
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL_OW 30
 822: PUSH
 823: LD_INT 8
 825: EQUAL
 826: IFFALSE 860
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 828: LD_ADDR_EXP 24
 832: PUSH
 833: LD_STRING Donaldson
 835: PPUSH
 836: CALL_OW 34
 840: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 841: LD_ADDR_EXP 9
 845: PUSH
 846: LD_EXP 9
 850: PUSH
 851: LD_EXP 24
 855: PUSH
 856: EMPTY
 857: LIST
 858: ADD
 859: ST_TO_ADDR
// end ; Brown := 0 ;
 860: LD_ADDR_EXP 25
 864: PUSH
 865: LD_INT 0
 867: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 868: LD_STRING Brown
 870: PPUSH
 871: CALL_OW 29
 875: IFFALSE 925
// if LoadVariable ( BrownLoc , 0 ) = 8 then
 877: LD_STRING BrownLoc
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL_OW 30
 887: PUSH
 888: LD_INT 8
 890: EQUAL
 891: IFFALSE 925
// begin Brown := CreateCharacter ( Brown ) ;
 893: LD_ADDR_EXP 25
 897: PUSH
 898: LD_STRING Brown
 900: PPUSH
 901: CALL_OW 34
 905: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_EXP 9
 915: PUSH
 916: LD_EXP 25
 920: PUSH
 921: EMPTY
 922: LIST
 923: ADD
 924: ST_TO_ADDR
// end ; Denis := 0 ;
 925: LD_ADDR_EXP 26
 929: PUSH
 930: LD_INT 0
 932: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 933: LD_STRING Denis
 935: PPUSH
 936: CALL_OW 29
 940: IFFALSE 979
// if LoadVariable ( DenisLoc , 0 ) = 8 then
 942: LD_STRING DenisLoc
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 30
 952: PUSH
 953: LD_INT 8
 955: EQUAL
 956: IFFALSE 979
// begin Denis := CreateCharacter ( Denis ) ;
 958: LD_ADDR_EXP 26
 962: PUSH
 963: LD_STRING Denis
 965: PPUSH
 966: CALL_OW 34
 970: ST_TO_ADDR
// Denis_P := true ;
 971: LD_ADDR_EXP 46
 975: PUSH
 976: LD_INT 1
 978: ST_TO_ADDR
// end ; Gladstone := 0 ;
 979: LD_ADDR_EXP 27
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 987: LD_STRING Gladstone
 989: PPUSH
 990: CALL_OW 29
 994: IFFALSE 1044
// if LoadVariable ( GladstoneLoc , 0 ) = 8 then
 996: LD_STRING GladstoneLoc
 998: PPUSH
 999: LD_INT 0
1001: PPUSH
1002: CALL_OW 30
1006: PUSH
1007: LD_INT 8
1009: EQUAL
1010: IFFALSE 1044
// begin Gladstone := CreateCharacter ( Gladstone ) ;
1012: LD_ADDR_EXP 27
1016: PUSH
1017: LD_STRING Gladstone
1019: PPUSH
1020: CALL_OW 34
1024: ST_TO_ADDR
// all := all ^ [ Gladstone ] ;
1025: LD_ADDR_EXP 9
1029: PUSH
1030: LD_EXP 9
1034: PUSH
1035: LD_EXP 27
1039: PUSH
1040: EMPTY
1041: LIST
1042: ADD
1043: ST_TO_ADDR
// end ; uc_side := you2 ;
1044: LD_ADDR_OWVAR 20
1048: PUSH
1049: LD_EXP 4
1053: ST_TO_ADDR
// Joan := NewCharacter ( Joan ) ;
1054: LD_ADDR_EXP 33
1058: PUSH
1059: LD_STRING Joan
1061: PPUSH
1062: CALL_OW 25
1066: ST_TO_ADDR
// SetLives ( Joan , hranice_umirani - 1 ) ;
1067: LD_EXP 33
1071: PPUSH
1072: LD_INT 250
1074: PUSH
1075: LD_INT 1
1077: MINUS
1078: PPUSH
1079: CALL_OW 234
// uc_side := you ;
1083: LD_ADDR_OWVAR 20
1087: PUSH
1088: LD_EXP 1
1092: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1093: LD_ADDR_OWVAR 37
1097: PUSH
1098: LD_INT 1
1100: ST_TO_ADDR
// vc_control := control_manual ;
1101: LD_ADDR_OWVAR 38
1105: PUSH
1106: LD_INT 1
1108: ST_TO_ADDR
// vc_engine := engine_solar ;
1109: LD_ADDR_OWVAR 39
1113: PUSH
1114: LD_INT 2
1116: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1117: LD_ADDR_OWVAR 40
1121: PUSH
1122: LD_INT 2
1124: ST_TO_ADDR
// Car1 := CreateVehicle ;
1125: LD_ADDR_EXP 44
1129: PUSH
1130: CALL_OW 45
1134: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1135: LD_ADDR_OWVAR 37
1139: PUSH
1140: LD_INT 1
1142: ST_TO_ADDR
// vc_control := control_manual ;
1143: LD_ADDR_OWVAR 38
1147: PUSH
1148: LD_INT 1
1150: ST_TO_ADDR
// vc_engine := engine_solar ;
1151: LD_ADDR_OWVAR 39
1155: PUSH
1156: LD_INT 2
1158: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1159: LD_ADDR_OWVAR 40
1163: PUSH
1164: LD_INT 2
1166: ST_TO_ADDR
// Car2 := CreateVehicle ;
1167: LD_ADDR_EXP 45
1171: PUSH
1172: CALL_OW 45
1176: ST_TO_ADDR
// uc_nation := nation_american ;
1177: LD_ADDR_OWVAR 21
1181: PUSH
1182: LD_INT 1
1184: ST_TO_ADDR
// hc_sex := sex_female ;
1185: LD_ADDR_OWVAR 27
1189: PUSH
1190: LD_INT 2
1192: ST_TO_ADDR
// hc_class := class_soldier ;
1193: LD_ADDR_OWVAR 28
1197: PUSH
1198: LD_INT 1
1200: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1201: LD_ADDR_OWVAR 29
1205: PUSH
1206: LD_INT 10
1208: PUSH
1209: LD_INT 10
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: ST_TO_ADDR
// hc_skills := [ 4 , 2 , 1 , 0 ] ;
1216: LD_ADDR_OWVAR 31
1220: PUSH
1221: LD_INT 4
1223: PUSH
1224: LD_INT 2
1226: PUSH
1227: LD_INT 1
1229: PUSH
1230: LD_INT 0
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: ST_TO_ADDR
// Sol1 := CreateHuman ;
1239: LD_ADDR_EXP 18
1243: PUSH
1244: CALL_OW 44
1248: ST_TO_ADDR
// hc_sex := sex_male ;
1249: LD_ADDR_OWVAR 27
1253: PUSH
1254: LD_INT 1
1256: ST_TO_ADDR
// hc_class := class_engineer ;
1257: LD_ADDR_OWVAR 28
1261: PUSH
1262: LD_INT 2
1264: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1265: LD_ADDR_OWVAR 29
1269: PUSH
1270: LD_INT 10
1272: PUSH
1273: LD_INT 10
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 0 , 0 ] ;
1280: LD_ADDR_OWVAR 31
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 0
1293: PUSH
1294: LD_INT 0
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: ST_TO_ADDR
// Eng1 := CreateHuman ;
1303: LD_ADDR_EXP 19
1307: PUSH
1308: CALL_OW 44
1312: ST_TO_ADDR
// zgamy2 := [ Sol1 , Eng1 ] ;
1313: LD_ADDR_EXP 14
1317: PUSH
1318: LD_EXP 18
1322: PUSH
1323: LD_EXP 19
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: ST_TO_ADDR
// hc_sex := sex_female ;
1332: LD_ADDR_OWVAR 27
1336: PUSH
1337: LD_INT 2
1339: ST_TO_ADDR
// hc_class := class_soldier ;
1340: LD_ADDR_OWVAR 28
1344: PUSH
1345: LD_INT 1
1347: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1348: LD_ADDR_OWVAR 29
1352: PUSH
1353: LD_INT 10
1355: PUSH
1356: LD_INT 10
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1363: LD_ADDR_OWVAR 31
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: LD_INT 1
1373: PUSH
1374: LD_INT 0
1376: PUSH
1377: LD_INT 0
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: ST_TO_ADDR
// MSol1 := CreateHuman ;
1386: LD_ADDR_EXP 28
1390: PUSH
1391: CALL_OW 44
1395: ST_TO_ADDR
// hc_sex := sex_male ;
1396: LD_ADDR_OWVAR 27
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// hc_class := class_soldier ;
1404: LD_ADDR_OWVAR 28
1408: PUSH
1409: LD_INT 1
1411: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1412: LD_ADDR_OWVAR 29
1416: PUSH
1417: LD_INT 10
1419: PUSH
1420: LD_INT 10
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1427: LD_ADDR_OWVAR 31
1431: PUSH
1432: LD_INT 2
1434: PUSH
1435: LD_INT 0
1437: PUSH
1438: LD_INT 1
1440: PUSH
1441: LD_INT 0
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: ST_TO_ADDR
// MSol2 := CreateHuman ;
1450: LD_ADDR_EXP 29
1454: PUSH
1455: CALL_OW 44
1459: ST_TO_ADDR
// hc_sex := sex_male ;
1460: LD_ADDR_OWVAR 27
1464: PUSH
1465: LD_INT 1
1467: ST_TO_ADDR
// hc_class := class_soldier ;
1468: LD_ADDR_OWVAR 28
1472: PUSH
1473: LD_INT 1
1475: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1476: LD_ADDR_OWVAR 29
1480: PUSH
1481: LD_INT 10
1483: PUSH
1484: LD_INT 10
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1491: LD_ADDR_OWVAR 31
1495: PUSH
1496: LD_INT 2
1498: PUSH
1499: LD_INT 0
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 0
1507: PUSH
1508: EMPTY
1509: LIST
1510: LIST
1511: LIST
1512: LIST
1513: ST_TO_ADDR
// MSol3 := CreateHuman ;
1514: LD_ADDR_EXP 30
1518: PUSH
1519: CALL_OW 44
1523: ST_TO_ADDR
// hc_sex := sex_female ;
1524: LD_ADDR_OWVAR 27
1528: PUSH
1529: LD_INT 2
1531: ST_TO_ADDR
// hc_class := class_engineer ;
1532: LD_ADDR_OWVAR 28
1536: PUSH
1537: LD_INT 2
1539: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1540: LD_ADDR_OWVAR 29
1544: PUSH
1545: LD_INT 9
1547: PUSH
1548: LD_INT 10
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1555: LD_ADDR_OWVAR 31
1559: PUSH
1560: LD_INT 0
1562: PUSH
1563: LD_INT 2
1565: PUSH
1566: LD_INT 0
1568: PUSH
1569: LD_INT 0
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: LIST
1576: LIST
1577: ST_TO_ADDR
// MEng1 := CreateHuman ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: CALL_OW 44
1587: ST_TO_ADDR
// hc_sex := sex_male ;
1588: LD_ADDR_OWVAR 27
1592: PUSH
1593: LD_INT 1
1595: ST_TO_ADDR
// hc_class := class_mechanic ;
1596: LD_ADDR_OWVAR 28
1600: PUSH
1601: LD_INT 3
1603: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1604: LD_ADDR_OWVAR 29
1608: PUSH
1609: LD_INT 10
1611: PUSH
1612: LD_INT 9
1614: PUSH
1615: EMPTY
1616: LIST
1617: LIST
1618: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1619: LD_ADDR_OWVAR 31
1623: PUSH
1624: LD_INT 0
1626: PUSH
1627: LD_INT 0
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 0
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: ST_TO_ADDR
// MMec1 := CreateHuman ;
1642: LD_ADDR_EXP 32
1646: PUSH
1647: CALL_OW 44
1651: ST_TO_ADDR
// prilet_tvoji := [ MSol1 , MSol2 , MEng1 , MMec1 ] ;
1652: LD_ADDR_EXP 6
1656: PUSH
1657: LD_EXP 28
1661: PUSH
1662: LD_EXP 29
1666: PUSH
1667: LD_EXP 31
1671: PUSH
1672: LD_EXP 32
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: ST_TO_ADDR
// NavicLidi := prilet_tvoji ;
1683: LD_ADDR_EXP 84
1687: PUSH
1688: LD_EXP 6
1692: ST_TO_ADDR
// end ;
1693: LD_VAR 0 1
1697: RET
// function prepare_russian_units ; begin
1698: LD_INT 0
1700: PPUSH
// InitUc ;
1701: CALL_OW 18
// InitHc ;
1705: CALL_OW 19
// InitVc ;
1709: CALL_OW 20
// uc_nation := nation_russian ;
1713: LD_ADDR_OWVAR 21
1717: PUSH
1718: LD_INT 3
1720: ST_TO_ADDR
// uc_side := russians ;
1721: LD_ADDR_OWVAR 20
1725: PUSH
1726: LD_EXP 2
1730: ST_TO_ADDR
// hc_sex := sex_female ;
1731: LD_ADDR_OWVAR 27
1735: PUSH
1736: LD_INT 2
1738: ST_TO_ADDR
// hc_class := class_soldier ;
1739: LD_ADDR_OWVAR 28
1743: PUSH
1744: LD_INT 1
1746: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1747: LD_ADDR_OWVAR 29
1751: PUSH
1752: LD_INT 10
1754: PUSH
1755: LD_INT 10
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1762: LD_ADDR_OWVAR 31
1766: PUSH
1767: LD_INT 1
1769: PUSH
1770: LD_INT 1
1772: PUSH
1773: LD_INT 0
1775: PUSH
1776: LD_INT 0
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: ST_TO_ADDR
// RMSo1 := CreateHuman ;
1785: LD_ADDR_EXP 39
1789: PUSH
1790: CALL_OW 44
1794: ST_TO_ADDR
// hc_sex := sex_male ;
1795: LD_ADDR_OWVAR 27
1799: PUSH
1800: LD_INT 1
1802: ST_TO_ADDR
// hc_class := class_soldier ;
1803: LD_ADDR_OWVAR 28
1807: PUSH
1808: LD_INT 1
1810: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1811: LD_ADDR_OWVAR 29
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: LD_INT 10
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1826: LD_ADDR_OWVAR 31
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: LD_INT 0
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 0
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: ST_TO_ADDR
// RMSo2 := CreateHuman ;
1849: LD_ADDR_EXP 40
1853: PUSH
1854: CALL_OW 44
1858: ST_TO_ADDR
// hc_sex := sex_female ;
1859: LD_ADDR_OWVAR 27
1863: PUSH
1864: LD_INT 2
1866: ST_TO_ADDR
// hc_class := class_engineer ;
1867: LD_ADDR_OWVAR 28
1871: PUSH
1872: LD_INT 2
1874: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1875: LD_ADDR_OWVAR 29
1879: PUSH
1880: LD_INT 9
1882: PUSH
1883: LD_INT 10
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1890: LD_ADDR_OWVAR 31
1894: PUSH
1895: LD_INT 0
1897: PUSH
1898: LD_INT 2
1900: PUSH
1901: LD_INT 0
1903: PUSH
1904: LD_INT 0
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: ST_TO_ADDR
// RMEn1 := CreateHuman ;
1913: LD_ADDR_EXP 41
1917: PUSH
1918: CALL_OW 44
1922: ST_TO_ADDR
// hc_sex := sex_male ;
1923: LD_ADDR_OWVAR 27
1927: PUSH
1928: LD_INT 1
1930: ST_TO_ADDR
// hc_class := class_mechanic ;
1931: LD_ADDR_OWVAR 28
1935: PUSH
1936: LD_INT 3
1938: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1939: LD_ADDR_OWVAR 29
1943: PUSH
1944: LD_INT 10
1946: PUSH
1947: LD_INT 9
1949: PUSH
1950: EMPTY
1951: LIST
1952: LIST
1953: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1954: LD_ADDR_OWVAR 31
1958: PUSH
1959: LD_INT 0
1961: PUSH
1962: LD_INT 0
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 0
1970: PUSH
1971: EMPTY
1972: LIST
1973: LIST
1974: LIST
1975: LIST
1976: ST_TO_ADDR
// RMMe1 := CreateHuman ;
1977: LD_ADDR_EXP 42
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// prilet_rusaci := [ RMSo1 , RMSo2 , RMMe1 ] ;
1987: LD_ADDR_EXP 7
1991: PUSH
1992: LD_EXP 39
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: LD_EXP 42
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// prilet_arabi := [ ] ;
2012: LD_ADDR_EXP 8
2016: PUSH
2017: EMPTY
2018: ST_TO_ADDR
// end ;
2019: LD_VAR 0 1
2023: RET
// function prepare_arabian_units ; begin
2024: LD_INT 0
2026: PPUSH
// InitUc ;
2027: CALL_OW 18
// InitHc ;
2031: CALL_OW 19
// InitVc ;
2035: CALL_OW 20
// uc_nation := nation_arabian ;
2039: LD_ADDR_OWVAR 21
2043: PUSH
2044: LD_INT 2
2046: ST_TO_ADDR
// uc_side := arabians ;
2047: LD_ADDR_OWVAR 20
2051: PUSH
2052: LD_EXP 3
2056: ST_TO_ADDR
// prilet_arabi := [ ] ;
2057: LD_ADDR_EXP 8
2061: PUSH
2062: EMPTY
2063: ST_TO_ADDR
// end ;
2064: LD_VAR 0 1
2068: RET
// function prepare_sides ; begin
2069: LD_INT 0
2071: PPUSH
// you := 1 ;
2072: LD_ADDR_EXP 1
2076: PUSH
2077: LD_INT 1
2079: ST_TO_ADDR
// you2 := 4 ;
2080: LD_ADDR_EXP 4
2084: PUSH
2085: LD_INT 4
2087: ST_TO_ADDR
// arabians := 2 ;
2088: LD_ADDR_EXP 3
2092: PUSH
2093: LD_INT 2
2095: ST_TO_ADDR
// russians := 3 ;
2096: LD_ADDR_EXP 2
2100: PUSH
2101: LD_INT 3
2103: ST_TO_ADDR
// SetAttitude ( russians , you , att_enemy , true ) ;
2104: LD_EXP 2
2108: PPUSH
2109: LD_EXP 1
2113: PPUSH
2114: LD_INT 2
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: CALL_OW 80
// SetAttitude ( arabians , you , att_neutral , true ) ;
2124: LD_EXP 3
2128: PPUSH
2129: LD_EXP 1
2133: PPUSH
2134: LD_INT 0
2136: PPUSH
2137: LD_INT 1
2139: PPUSH
2140: CALL_OW 80
// SetAttitude ( arabians , russians , att_enemy , true ) ;
2144: LD_EXP 3
2148: PPUSH
2149: LD_EXP 2
2153: PPUSH
2154: LD_INT 2
2156: PPUSH
2157: LD_INT 1
2159: PPUSH
2160: CALL_OW 80
// end ;
2164: LD_VAR 0 1
2168: RET
// function SetDifficulty ; var t1 ; begin
2169: LD_INT 0
2171: PPUSH
2172: PPUSH
// MaterialNavic := [ 350 , 500 , 700 ] [ difficulty ] ;
2173: LD_ADDR_EXP 51
2177: PUSH
2178: LD_INT 350
2180: PUSH
2181: LD_INT 500
2183: PUSH
2184: LD_INT 700
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: LIST
2191: PUSH
2192: LD_OWVAR 67
2196: ARRAY
2197: ST_TO_ADDR
// odplata_1 := [ 130 , 90 , 75 ] [ difficulty ] ;
2198: LD_ADDR_EXP 65
2202: PUSH
2203: LD_INT 130
2205: PUSH
2206: LD_INT 90
2208: PUSH
2209: LD_INT 75
2211: PUSH
2212: EMPTY
2213: LIST
2214: LIST
2215: LIST
2216: PUSH
2217: LD_OWVAR 67
2221: ARRAY
2222: ST_TO_ADDR
// odplata_2 := [ 350 , 250 , 150 ] [ difficulty ] ;
2223: LD_ADDR_EXP 66
2227: PUSH
2228: LD_INT 350
2230: PUSH
2231: LD_INT 250
2233: PUSH
2234: LD_INT 150
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: LD_OWVAR 67
2246: ARRAY
2247: ST_TO_ADDR
// attack_to_scouting := [ 15 , 10 , 5 ] [ difficulty ] ;
2248: LD_ADDR_EXP 67
2252: PUSH
2253: LD_INT 15
2255: PUSH
2256: LD_INT 10
2258: PUSH
2259: LD_INT 5
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: PUSH
2267: LD_OWVAR 67
2271: ARRAY
2272: ST_TO_ADDR
// start_scouting := [ 5 5$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
2273: LD_ADDR_EXP 68
2277: PUSH
2278: LD_INT 10500
2280: PUSH
2281: LD_INT 4200
2283: PUSH
2284: LD_INT 0
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// case difficulty of 1 :
2298: LD_OWVAR 67
2302: PUSH
2303: LD_INT 1
2305: DOUBLE
2306: EQUAL
2307: IFTRUE 2311
2309: GO 2703
2311: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2312: LD_ADDR_VAR 0 2
2316: PUSH
2317: LD_INT 22
2319: PUSH
2320: LD_EXP 2
2324: PUSH
2325: EMPTY
2326: LIST
2327: LIST
2328: PUSH
2329: LD_INT 21
2331: PUSH
2332: LD_INT 1
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: PPUSH
2343: CALL_OW 69
2347: PUSH
2348: FOR_IN
2349: IFFALSE 2411
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 3 ) ;
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_VAR 0 2
2363: PPUSH
2364: LD_INT 1
2366: PPUSH
2367: CALL_OW 260
2371: PUSH
2372: LD_INT 3
2374: MINUS
2375: PPUSH
2376: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 2 ) ;
2380: LD_VAR 0 2
2384: PPUSH
2385: LD_INT 2
2387: PPUSH
2388: LD_VAR 0 2
2392: PPUSH
2393: LD_INT 2
2395: PPUSH
2396: CALL_OW 260
2400: PUSH
2401: LD_INT 2
2403: MINUS
2404: PPUSH
2405: CALL_OW 239
// end ;
2409: GO 2348
2411: POP
2412: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_INT 22
2420: PUSH
2421: LD_EXP 2
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PUSH
2430: LD_INT 25
2432: PUSH
2433: LD_INT 1
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PPUSH
2444: CALL_OW 69
2448: PUSH
2449: FOR_IN
2450: IFFALSE 2483
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) - 1 ) ;
2452: LD_VAR 0 2
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 1
2467: PPUSH
2468: CALL_OW 259
2472: PUSH
2473: LD_INT 1
2475: MINUS
2476: PPUSH
2477: CALL_OW 237
// end ;
2481: GO 2449
2483: POP
2484: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_INT 22
2492: PUSH
2493: LD_EXP 2
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: LD_INT 25
2504: PUSH
2505: LD_INT 2
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PPUSH
2516: CALL_OW 69
2520: PUSH
2521: FOR_IN
2522: IFFALSE 2555
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 2
2531: PPUSH
2532: LD_VAR 0 2
2536: PPUSH
2537: LD_INT 2
2539: PPUSH
2540: CALL_OW 259
2544: PUSH
2545: LD_INT 2
2547: PLUS
2548: PPUSH
2549: CALL_OW 237
// end ;
2553: GO 2521
2555: POP
2556: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2557: LD_ADDR_VAR 0 2
2561: PUSH
2562: LD_INT 22
2564: PUSH
2565: LD_EXP 2
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PUSH
2574: LD_INT 25
2576: PUSH
2577: LD_INT 3
2579: PUSH
2580: EMPTY
2581: LIST
2582: LIST
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 69
2592: PUSH
2593: FOR_IN
2594: IFFALSE 2627
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) - 1 ) ;
2596: LD_VAR 0 2
2600: PPUSH
2601: LD_INT 3
2603: PPUSH
2604: LD_VAR 0 2
2608: PPUSH
2609: LD_INT 3
2611: PPUSH
2612: CALL_OW 259
2616: PUSH
2617: LD_INT 1
2619: MINUS
2620: PPUSH
2621: CALL_OW 237
// end ;
2625: GO 2593
2627: POP
2628: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
2629: LD_ADDR_VAR 0 2
2633: PUSH
2634: LD_INT 22
2636: PUSH
2637: LD_EXP 2
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: PUSH
2646: LD_INT 25
2648: PUSH
2649: LD_INT 4
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: PPUSH
2660: CALL_OW 69
2664: PUSH
2665: FOR_IN
2666: IFFALSE 2699
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) - 1 ) ;
2668: LD_VAR 0 2
2672: PPUSH
2673: LD_INT 4
2675: PPUSH
2676: LD_VAR 0 2
2680: PPUSH
2681: LD_INT 4
2683: PPUSH
2684: CALL_OW 259
2688: PUSH
2689: LD_INT 1
2691: MINUS
2692: PPUSH
2693: CALL_OW 237
// end ;
2697: GO 2665
2699: POP
2700: POP
// end ; 2 :
2701: GO 3554
2703: LD_INT 2
2705: DOUBLE
2706: EQUAL
2707: IFTRUE 2711
2709: GO 3124
2711: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2712: LD_ADDR_VAR 0 2
2716: PUSH
2717: LD_INT 22
2719: PUSH
2720: LD_EXP 2
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 21
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2836
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 1 ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: LD_VAR 0 2
2763: PPUSH
2764: LD_INT 1
2766: PPUSH
2767: CALL_OW 260
2771: PUSH
2772: LD_INT 1
2774: MINUS
2775: PPUSH
2776: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 1 ) ;
2780: LD_VAR 0 2
2784: PPUSH
2785: LD_INT 2
2787: PPUSH
2788: LD_VAR 0 2
2792: PPUSH
2793: LD_INT 2
2795: PPUSH
2796: CALL_OW 260
2800: PUSH
2801: LD_INT 1
2803: MINUS
2804: PPUSH
2805: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) ) ;
2809: LD_VAR 0 2
2813: PPUSH
2814: LD_INT 1
2816: PPUSH
2817: LD_VAR 0 2
2821: PPUSH
2822: LD_INT 1
2824: PPUSH
2825: CALL_OW 259
2829: PPUSH
2830: CALL_OW 237
// end ;
2834: GO 2748
2836: POP
2837: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2838: LD_ADDR_VAR 0 2
2842: PUSH
2843: LD_INT 22
2845: PUSH
2846: LD_EXP 2
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: LD_INT 25
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PPUSH
2869: CALL_OW 69
2873: PUSH
2874: FOR_IN
2875: IFFALSE 2908
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
2877: LD_VAR 0 2
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_VAR 0 2
2889: PPUSH
2890: LD_INT 1
2892: PPUSH
2893: CALL_OW 259
2897: PUSH
2898: LD_INT 1
2900: PLUS
2901: PPUSH
2902: CALL_OW 237
// end ;
2906: GO 2874
2908: POP
2909: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2910: LD_ADDR_VAR 0 2
2914: PUSH
2915: LD_INT 22
2917: PUSH
2918: LD_EXP 2
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 25
2929: PUSH
2930: LD_INT 2
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: PUSH
2946: FOR_IN
2947: IFFALSE 2980
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_VAR 0 2
2961: PPUSH
2962: LD_INT 2
2964: PPUSH
2965: CALL_OW 259
2969: PUSH
2970: LD_INT 2
2972: PLUS
2973: PPUSH
2974: CALL_OW 237
// end ;
2978: GO 2946
2980: POP
2981: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2982: LD_ADDR_VAR 0 2
2986: PUSH
2987: LD_INT 22
2989: PUSH
2990: LD_EXP 2
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: LD_INT 25
3001: PUSH
3002: LD_INT 3
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PPUSH
3013: CALL_OW 69
3017: PUSH
3018: FOR_IN
3019: IFFALSE 3048
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) ) ;
3021: LD_VAR 0 2
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: LD_VAR 0 2
3033: PPUSH
3034: LD_INT 3
3036: PPUSH
3037: CALL_OW 259
3041: PPUSH
3042: CALL_OW 237
// end ;
3046: GO 3018
3048: POP
3049: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3050: LD_ADDR_VAR 0 2
3054: PUSH
3055: LD_INT 22
3057: PUSH
3058: LD_EXP 2
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 25
3069: PUSH
3070: LD_INT 4
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: CALL_OW 69
3085: PUSH
3086: FOR_IN
3087: IFFALSE 3120
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 1 ) ;
3089: LD_VAR 0 2
3093: PPUSH
3094: LD_INT 4
3096: PPUSH
3097: LD_VAR 0 2
3101: PPUSH
3102: LD_INT 4
3104: PPUSH
3105: CALL_OW 259
3109: PUSH
3110: LD_INT 1
3112: PLUS
3113: PPUSH
3114: CALL_OW 237
// end ;
3118: GO 3086
3120: POP
3121: POP
// end ; 3 :
3122: GO 3554
3124: LD_INT 3
3126: DOUBLE
3127: EQUAL
3128: IFTRUE 3132
3130: GO 3553
3132: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
3133: LD_ADDR_VAR 0 2
3137: PUSH
3138: LD_INT 22
3140: PUSH
3141: LD_EXP 2
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 21
3152: PUSH
3153: LD_INT 1
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 69
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3261
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) + 1 ) ;
3172: LD_VAR 0 2
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: LD_VAR 0 2
3184: PPUSH
3185: LD_INT 1
3187: PPUSH
3188: CALL_OW 260
3192: PUSH
3193: LD_INT 1
3195: PLUS
3196: PPUSH
3197: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) + 1 ) ;
3201: LD_VAR 0 2
3205: PPUSH
3206: LD_INT 2
3208: PPUSH
3209: LD_VAR 0 2
3213: PPUSH
3214: LD_INT 2
3216: PPUSH
3217: CALL_OW 260
3221: PUSH
3222: LD_INT 1
3224: PLUS
3225: PPUSH
3226: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
3230: LD_VAR 0 2
3234: PPUSH
3235: LD_INT 1
3237: PPUSH
3238: LD_VAR 0 2
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: CALL_OW 259
3250: PUSH
3251: LD_INT 1
3253: PLUS
3254: PPUSH
3255: CALL_OW 237
// end ;
3259: GO 3169
3261: POP
3262: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
3263: LD_ADDR_VAR 0 2
3267: PUSH
3268: LD_INT 22
3270: PUSH
3271: LD_EXP 2
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: LD_INT 25
3282: PUSH
3283: LD_INT 1
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PPUSH
3294: CALL_OW 69
3298: PUSH
3299: FOR_IN
3300: IFFALSE 3333
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 2 ) ;
3302: LD_VAR 0 2
3306: PPUSH
3307: LD_INT 1
3309: PPUSH
3310: LD_VAR 0 2
3314: PPUSH
3315: LD_INT 1
3317: PPUSH
3318: CALL_OW 259
3322: PUSH
3323: LD_INT 2
3325: PLUS
3326: PPUSH
3327: CALL_OW 237
// end ;
3331: GO 3299
3333: POP
3334: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
3335: LD_ADDR_VAR 0 2
3339: PUSH
3340: LD_INT 22
3342: PUSH
3343: LD_EXP 2
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PUSH
3352: LD_INT 25
3354: PUSH
3355: LD_INT 2
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PPUSH
3366: CALL_OW 69
3370: PUSH
3371: FOR_IN
3372: IFFALSE 3405
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
3374: LD_VAR 0 2
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: LD_VAR 0 2
3386: PPUSH
3387: LD_INT 2
3389: PPUSH
3390: CALL_OW 259
3394: PUSH
3395: LD_INT 2
3397: PLUS
3398: PPUSH
3399: CALL_OW 237
// end ;
3403: GO 3371
3405: POP
3406: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
3407: LD_ADDR_VAR 0 2
3411: PUSH
3412: LD_INT 22
3414: PUSH
3415: LD_EXP 2
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PUSH
3424: LD_INT 25
3426: PUSH
3427: LD_INT 3
3429: PUSH
3430: EMPTY
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: PPUSH
3438: CALL_OW 69
3442: PUSH
3443: FOR_IN
3444: IFFALSE 3477
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) + 2 ) ;
3446: LD_VAR 0 2
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_VAR 0 2
3458: PPUSH
3459: LD_INT 3
3461: PPUSH
3462: CALL_OW 259
3466: PUSH
3467: LD_INT 2
3469: PLUS
3470: PPUSH
3471: CALL_OW 237
// end ;
3475: GO 3443
3477: POP
3478: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3479: LD_ADDR_VAR 0 2
3483: PUSH
3484: LD_INT 22
3486: PUSH
3487: LD_EXP 2
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: PUSH
3496: LD_INT 25
3498: PUSH
3499: LD_INT 4
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: PPUSH
3510: CALL_OW 69
3514: PUSH
3515: FOR_IN
3516: IFFALSE 3549
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 2 ) ;
3518: LD_VAR 0 2
3522: PPUSH
3523: LD_INT 4
3525: PPUSH
3526: LD_VAR 0 2
3530: PPUSH
3531: LD_INT 4
3533: PPUSH
3534: CALL_OW 259
3538: PUSH
3539: LD_INT 2
3541: PLUS
3542: PPUSH
3543: CALL_OW 237
// end ;
3547: GO 3515
3549: POP
3550: POP
// end ; end ;
3551: GO 3554
3553: POP
// end ;
3554: LD_VAR 0 1
3558: RET
// every 50 50$0 do var bases , i , mat ;
3559: GO 3561
3561: DISABLE
3562: LD_INT 0
3564: PPUSH
3565: PPUSH
3566: PPUSH
// begin if count_crates < MaterialNavic then
3567: CALL 26034 0 0
3571: PUSH
3572: LD_EXP 51
3576: LESS
3577: IFFALSE 3591
// begin disable ( 0 ) ;
3579: LD_INT 0
3581: DISABLE_MARKED
// YouLost ( matmin ) ;
3582: LD_STRING matmin
3584: PPUSH
3585: CALL_OW 104
// end else
3589: GO 3666
// begin disable ( 0 ) ;
3591: LD_INT 0
3593: DISABLE_MARKED
// SetMedals ;
3594: CALL 4151 0 0
// GiveMedals ( Main ) ;
3598: LD_STRING Main
3600: PPUSH
3601: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_ok ] , [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3605: LD_INT 50
3607: PUSH
3608: EMPTY
3609: LIST
3610: PUSH
3611: LD_INT 22
3613: PUSH
3614: LD_EXP 1
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PUSH
3623: LD_INT 21
3625: PUSH
3626: LD_INT 1
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: PUSH
3633: LD_INT 23
3635: PUSH
3636: LD_INT 1
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: PPUSH
3649: CALL_OW 69
3653: PPUSH
3654: CALL_OW 43
// Save ;
3658: CALL 3669 0 0
// YouWin ;
3662: CALL_OW 103
// end ; end ;
3666: PPOPN 3
3668: END
// export function Save ; begin
3669: LD_INT 0
3671: PPUSH
// SaveCharacters ( JMM , JMM ) ;
3672: LD_EXP 15
3676: PPUSH
3677: LD_STRING JMM
3679: PPUSH
3680: CALL_OW 38
// SaveCharacters ( Kurt , Kurt ) ;
3684: LD_EXP 43
3688: PPUSH
3689: LD_STRING Kurt
3691: PPUSH
3692: CALL_OW 38
// SaveVariable ( not IsDead ( Kurt ) , KurtLeaves ) ;
3696: LD_EXP 43
3700: PPUSH
3701: CALL_OW 301
3705: NOT
3706: PPUSH
3707: LD_STRING KurtLeaves
3709: PPUSH
3710: CALL_OW 39
// SaveVariable ( KurtTryToEscape and not IsDead ( Kurt ) , KurtEscapes ) ;
3714: LD_EXP 85
3718: PUSH
3719: LD_EXP 43
3723: PPUSH
3724: CALL_OW 301
3728: NOT
3729: AND
3730: PPUSH
3731: LD_STRING KurtEscapes
3733: PPUSH
3734: CALL_OW 39
// SaveVariable ( remote_tried , RemoteUsed ) ;
3738: LD_EXP 82
3742: PPUSH
3743: LD_STRING RemoteUsed
3745: PPUSH
3746: CALL_OW 39
// SaveVariable ( Researched ( you , tech_RemCont ) , RemoteDeveloped ) ;
3750: LD_EXP 1
3754: PPUSH
3755: LD_INT 15
3757: PPUSH
3758: CALL_OW 325
3762: PPUSH
3763: LD_STRING RemoteDeveloped
3765: PPUSH
3766: CALL_OW 39
// if Lisa then
3770: LD_EXP 21
3774: IFFALSE 3798
// begin SaveCharacters ( Lisa , Lisa ) ;
3776: LD_EXP 21
3780: PPUSH
3781: LD_STRING Lisa
3783: PPUSH
3784: CALL_OW 38
// SaveVariable ( 9 , LisaLoc ) ;
3788: LD_INT 9
3790: PPUSH
3791: LD_STRING LisaLoc
3793: PPUSH
3794: CALL_OW 39
// end ; if Frank then
3798: LD_EXP 20
3802: IFFALSE 3826
// begin SaveCharacters ( Frank , Frank ) ;
3804: LD_EXP 20
3808: PPUSH
3809: LD_STRING Frank
3811: PPUSH
3812: CALL_OW 38
// SaveVariable ( 9 , FrankLoc ) ;
3816: LD_INT 9
3818: PPUSH
3819: LD_STRING FrankLoc
3821: PPUSH
3822: CALL_OW 39
// end ; if Donaldson then
3826: LD_EXP 24
3830: IFFALSE 3854
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3832: LD_EXP 24
3836: PPUSH
3837: LD_STRING Donaldson
3839: PPUSH
3840: CALL_OW 38
// SaveVariable ( 9 , DonaldsonLoc ) ;
3844: LD_INT 9
3846: PPUSH
3847: LD_STRING DonaldsonLoc
3849: PPUSH
3850: CALL_OW 39
// end ; if Brown then
3854: LD_EXP 25
3858: IFFALSE 3882
// begin SaveCharacters ( Brown , Brown ) ;
3860: LD_EXP 25
3864: PPUSH
3865: LD_STRING Brown
3867: PPUSH
3868: CALL_OW 38
// SaveVariable ( 9 , BrownLoc ) ;
3872: LD_INT 9
3874: PPUSH
3875: LD_STRING BrownLoc
3877: PPUSH
3878: CALL_OW 39
// end ; if Gladstone then
3882: LD_EXP 27
3886: IFFALSE 3910
// begin SaveCharacters ( Gladstone , Gladstone ) ;
3888: LD_EXP 27
3892: PPUSH
3893: LD_STRING Gladstone
3895: PPUSH
3896: CALL_OW 38
// SaveVariable ( 9 , GladstoneLoc ) ;
3900: LD_INT 9
3902: PPUSH
3903: LD_STRING GladstoneLoc
3905: PPUSH
3906: CALL_OW 39
// end ; SaveCharacters ( Joan , Joan ) ;
3910: LD_EXP 33
3914: PPUSH
3915: LD_STRING Joan
3917: PPUSH
3918: CALL_OW 38
// SaveVariable ( 9 , JoanLoc ) ;
3922: LD_INT 9
3924: PPUSH
3925: LD_STRING JoanLoc
3927: PPUSH
3928: CALL_OW 39
// if Denis then
3932: LD_EXP 26
3936: IFFALSE 3960
// begin SaveCharacters ( Denis , Denis ) ;
3938: LD_EXP 26
3942: PPUSH
3943: LD_STRING Denis
3945: PPUSH
3946: CALL_OW 38
// SaveVariable ( 9 , DenisLoc ) ;
3950: LD_INT 9
3952: PPUSH
3953: LD_STRING DenisLoc
3955: PPUSH
3956: CALL_OW 39
// end ; if Bobby then
3960: LD_EXP 23
3964: IFFALSE 3988
// begin SaveCharacters ( Bobby , Bobby ) ;
3966: LD_EXP 23
3970: PPUSH
3971: LD_STRING Bobby
3973: PPUSH
3974: CALL_OW 38
// SaveVariable ( 9 , BobbyLoc ) ;
3978: LD_INT 9
3980: PPUSH
3981: LD_STRING BobbyLoc
3983: PPUSH
3984: CALL_OW 39
// end ; if Cyrus then
3988: LD_EXP 22
3992: IFFALSE 4016
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3994: LD_EXP 22
3998: PPUSH
3999: LD_STRING Cyrus
4001: PPUSH
4002: CALL_OW 38
// SaveVariable ( 9 , CyrusLoc ) ;
4006: LD_INT 9
4008: PPUSH
4009: LD_STRING CyrusLoc
4011: PPUSH
4012: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Donaldson , Brown , Gladstone , Joan , Denis , Bobby , Cyrus , 0 ] , OtherUnplaced ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_EXP 1
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: PUSH
4028: LD_INT 21
4030: PUSH
4031: LD_INT 1
4033: PUSH
4034: EMPTY
4035: LIST
4036: LIST
4037: PUSH
4038: LD_INT 23
4040: PUSH
4041: LD_INT 1
4043: PUSH
4044: EMPTY
4045: LIST
4046: LIST
4047: PUSH
4048: EMPTY
4049: LIST
4050: LIST
4051: LIST
4052: PPUSH
4053: CALL_OW 69
4057: PUSH
4058: LD_EXP 15
4062: PUSH
4063: LD_EXP 21
4067: PUSH
4068: LD_EXP 20
4072: PUSH
4073: LD_EXP 24
4077: PUSH
4078: LD_EXP 25
4082: PUSH
4083: LD_EXP 27
4087: PUSH
4088: LD_EXP 33
4092: PUSH
4093: LD_EXP 26
4097: PUSH
4098: LD_EXP 23
4102: PUSH
4103: LD_EXP 22
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: EMPTY
4112: LIST
4113: LIST
4114: LIST
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: LIST
4121: LIST
4122: LIST
4123: DIFF
4124: PPUSH
4125: LD_STRING OtherUnplaced
4127: PPUSH
4128: CALL_OW 38
// DeleteCharacters ( opicaci ) ;
4132: LD_STRING opicaci
4134: PPUSH
4135: CALL_OW 40
// DeleteCharacters ( other_from5to6 ) ;
4139: LD_STRING other_from5to6
4141: PPUSH
4142: CALL_OW 40
// end ;
4146: LD_VAR 0 1
4150: RET
// export function SetMedals ; var medal1 , medal2 , medal3 ; begin
4151: LD_INT 0
4153: PPUSH
4154: PPUSH
4155: PPUSH
4156: PPUSH
// medal1 := false ;
4157: LD_ADDR_VAR 0 2
4161: PUSH
4162: LD_INT 0
4164: ST_TO_ADDR
// medal2 := false ;
4165: LD_ADDR_VAR 0 3
4169: PUSH
4170: LD_INT 0
4172: ST_TO_ADDR
// medal3 := false ;
4173: LD_ADDR_VAR 0 4
4177: PUSH
4178: LD_INT 0
4180: ST_TO_ADDR
// AddMedal ( cans , count_crates >= ( MaterialNavic + 100 ) ) ;
4181: LD_STRING cans
4183: PPUSH
4184: CALL 26034 0 0
4188: PUSH
4189: LD_EXP 51
4193: PUSH
4194: LD_INT 100
4196: PLUS
4197: GREATEREQUAL
4198: PPUSH
4199: CALL_OW 101
// medal1 := count_crates >= ( MaterialNavic + 100 ) ;
4203: LD_ADDR_VAR 0 2
4207: PUSH
4208: CALL 26034 0 0
4212: PUSH
4213: LD_EXP 51
4217: PUSH
4218: LD_INT 100
4220: PLUS
4221: GREATEREQUAL
4222: ST_TO_ADDR
// SA_CratesGathered ( count_crates ) ;
4223: CALL 26034 0 0
4227: PPUSH
4228: CALL 27128 0 1
// if count_crates >= 1000 then
4232: CALL 26034 0 0
4236: PUSH
4237: LD_INT 1000
4239: GREATEREQUAL
4240: IFFALSE 4246
// SA_On1000CratesGathered ;
4242: CALL 27113 0 0
// NavicLidi := UnitFilter ( NavicLidi , [ f_ok ] ) ;
4246: LD_ADDR_EXP 84
4250: PUSH
4251: LD_EXP 84
4255: PPUSH
4256: LD_INT 50
4258: PUSH
4259: EMPTY
4260: LIST
4261: PPUSH
4262: CALL_OW 72
4266: ST_TO_ADDR
// AddMedal ( people , NavicLidi >= 3 ) ;
4267: LD_STRING people
4269: PPUSH
4270: LD_EXP 84
4274: PUSH
4275: LD_INT 3
4277: GREATEREQUAL
4278: PPUSH
4279: CALL_OW 101
// medal2 := NavicLidi >= 3 ;
4283: LD_ADDR_VAR 0 3
4287: PUSH
4288: LD_EXP 84
4292: PUSH
4293: LD_INT 3
4295: GREATEREQUAL
4296: ST_TO_ADDR
// if noBodyLeft then
4297: LD_EXP 86
4301: IFFALSE 4307
// SA_NoBodyLeft ;
4303: CALL 27148 0 0
// if remote_tried then
4307: LD_EXP 82
4311: IFFALSE 4333
// begin AddMedal ( remote , 1 ) ;
4313: LD_STRING remote
4315: PPUSH
4316: LD_INT 1
4318: PPUSH
4319: CALL_OW 101
// medal3 := true ;
4323: LD_ADDR_VAR 0 4
4327: PUSH
4328: LD_INT 1
4330: ST_TO_ADDR
// end else
4331: GO 4375
// begin if GetTech ( tech_RemCont , you ) = state_researched then
4333: LD_INT 15
4335: PPUSH
4336: LD_EXP 1
4340: PPUSH
4341: CALL_OW 321
4345: PUSH
4346: LD_INT 2
4348: EQUAL
4349: IFFALSE 4364
// AddMedal ( remote , - 2 ) else
4351: LD_STRING remote
4353: PPUSH
4354: LD_INT 2
4356: NEG
4357: PPUSH
4358: CALL_OW 101
4362: GO 4375
// AddMedal ( remote , - 1 ) ;
4364: LD_STRING remote
4366: PPUSH
4367: LD_INT 1
4369: NEG
4370: PPUSH
4371: CALL_OW 101
// end ; SA_EndMission ( 1 , 6 , medal1 , medal2 , medal3 ) ;
4375: LD_INT 1
4377: PPUSH
4378: LD_INT 6
4380: PPUSH
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: LD_VAR 0 4
4395: PPUSH
4396: CALL 27178 0 5
// end ;
4400: LD_VAR 0 1
4404: RET
// final begin end ; end_of_file
4405: END
// export mytick ; export function Dialog1 ; var Sci , i ; begin
4406: LD_INT 0
4408: PPUSH
4409: PPUSH
4410: PPUSH
// used := all ^ [ JMM ] ;
4411: LD_ADDR_EXP 12
4415: PUSH
4416: LD_EXP 9
4420: PUSH
4421: LD_EXP 15
4425: PUSH
4426: EMPTY
4427: LIST
4428: ADD
4429: ST_TO_ADDR
// if Lisa in used then
4430: LD_EXP 21
4434: PUSH
4435: LD_EXP 12
4439: IN
4440: IFFALSE 4450
// Lisa_P := true ;
4442: LD_ADDR_EXP 49
4446: PUSH
4447: LD_INT 1
4449: ST_TO_ADDR
// if Frank in used then
4450: LD_EXP 20
4454: PUSH
4455: LD_EXP 12
4459: IN
4460: IFFALSE 4470
// Frank_P := true ;
4462: LD_ADDR_EXP 50
4466: PUSH
4467: LD_INT 1
4469: ST_TO_ADDR
// opicaci := Delete ( opicaci , 3 ) ;
4470: LD_ADDR_EXP 13
4474: PUSH
4475: LD_EXP 13
4479: PPUSH
4480: LD_INT 3
4482: PPUSH
4483: CALL_OW 3
4487: ST_TO_ADDR
// used := used ^ opicaci ;
4488: LD_ADDR_EXP 12
4492: PUSH
4493: LD_EXP 12
4497: PUSH
4498: LD_EXP 13
4502: ADD
4503: ST_TO_ADDR
// used := used union zgamy2 ;
4504: LD_ADDR_EXP 12
4508: PUSH
4509: LD_EXP 12
4513: PUSH
4514: LD_EXP 14
4518: UNION
4519: ST_TO_ADDR
// not_char := used diff [ JMM , Lisa , Frank ] ;
4520: LD_ADDR_EXP 11
4524: PUSH
4525: LD_EXP 12
4529: PUSH
4530: LD_EXP 15
4534: PUSH
4535: LD_EXP 21
4539: PUSH
4540: LD_EXP 20
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: DIFF
4550: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Gladstone , Denis , Brown , Donaldson ] ;
4551: LD_ADDR_EXP 11
4555: PUSH
4556: LD_EXP 11
4560: PUSH
4561: LD_EXP 22
4565: PUSH
4566: LD_EXP 23
4570: PUSH
4571: LD_EXP 27
4575: PUSH
4576: LD_EXP 26
4580: PUSH
4581: LD_EXP 25
4585: PUSH
4586: LD_EXP 24
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: LIST
4596: LIST
4597: LIST
4598: DIFF
4599: ST_TO_ADDR
// if Brown in used then
4600: LD_EXP 25
4604: PUSH
4605: LD_EXP 12
4609: IN
4610: IFFALSE 4631
// not_char := not_char ^ [ Brown ] ;
4612: LD_ADDR_EXP 11
4616: PUSH
4617: LD_EXP 11
4621: PUSH
4622: LD_EXP 25
4626: PUSH
4627: EMPTY
4628: LIST
4629: ADD
4630: ST_TO_ADDR
// if Donaldson in used then
4631: LD_EXP 24
4635: PUSH
4636: LD_EXP 12
4640: IN
4641: IFFALSE 4662
// not_char := not_char ^ [ Donaldson ] ;
4643: LD_ADDR_EXP 11
4647: PUSH
4648: LD_EXP 11
4652: PUSH
4653: LD_EXP 24
4657: PUSH
4658: EMPTY
4659: LIST
4660: ADD
4661: ST_TO_ADDR
// if Cyrus in used then
4662: LD_EXP 22
4666: PUSH
4667: LD_EXP 12
4671: IN
4672: IFFALSE 4693
// not_char := not_char ^ [ Cyrus ] ;
4674: LD_ADDR_EXP 11
4678: PUSH
4679: LD_EXP 11
4683: PUSH
4684: LD_EXP 22
4688: PUSH
4689: EMPTY
4690: LIST
4691: ADD
4692: ST_TO_ADDR
// if Bobby in used then
4693: LD_EXP 23
4697: PUSH
4698: LD_EXP 12
4702: IN
4703: IFFALSE 4724
// not_char := not_char ^ [ Bobby ] ;
4705: LD_ADDR_EXP 11
4709: PUSH
4710: LD_EXP 11
4714: PUSH
4715: LD_EXP 23
4719: PUSH
4720: EMPTY
4721: LIST
4722: ADD
4723: ST_TO_ADDR
// if Gladstone in used then
4724: LD_EXP 27
4728: PUSH
4729: LD_EXP 12
4733: IN
4734: IFFALSE 4755
// not_char := not_char ^ [ Gladstone ] ;
4736: LD_ADDR_EXP 11
4740: PUSH
4741: LD_EXP 11
4745: PUSH
4746: LD_EXP 27
4750: PUSH
4751: EMPTY
4752: LIST
4753: ADD
4754: ST_TO_ADDR
// if Denis in used then
4755: LD_EXP 26
4759: PUSH
4760: LD_EXP 12
4764: IN
4765: IFFALSE 4786
// not_char := not_char ^ [ Denis ] ;
4767: LD_ADDR_EXP 11
4771: PUSH
4772: LD_EXP 11
4776: PUSH
4777: LD_EXP 26
4781: PUSH
4782: EMPTY
4783: LIST
4784: ADD
4785: ST_TO_ADDR
// SaveForQuickRestart ;
4786: CALL_OW 22
// Wait ( 0 0$1.0 ) ;
4790: LD_INT 35
4792: PPUSH
4793: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
4797: LD_STRING M1
4799: PPUSH
4800: CALL_OW 337
// case difficulty of 1 :
4804: LD_OWVAR 67
4808: PUSH
4809: LD_INT 1
4811: DOUBLE
4812: EQUAL
4813: IFTRUE 4817
4815: GO 4827
4817: POP
// ChangeMissionObjectives ( M1-1 ) ; 2 :
4818: LD_STRING M1-1
4820: PPUSH
4821: CALL_OW 337
4825: GO 4864
4827: LD_INT 2
4829: DOUBLE
4830: EQUAL
4831: IFTRUE 4835
4833: GO 4845
4835: POP
// ChangeMissionObjectives ( M1-2 ) ; 3 :
4836: LD_STRING M1-2
4838: PPUSH
4839: CALL_OW 337
4843: GO 4864
4845: LD_INT 3
4847: DOUBLE
4848: EQUAL
4849: IFTRUE 4853
4851: GO 4863
4853: POP
// ChangeMissionObjectives ( M1-3 ) ; end ;
4854: LD_STRING M1-3
4856: PPUSH
4857: CALL_OW 337
4861: GO 4864
4863: POP
// ChangeMissionObjectives ( M1cont ) ;
4864: LD_STRING M1cont
4866: PPUSH
4867: CALL_OW 337
// PlaceHumanInUnit ( zgamy2 [ 1 ] , Car1 ) ;
4871: LD_EXP 14
4875: PUSH
4876: LD_INT 1
4878: ARRAY
4879: PPUSH
4880: LD_EXP 44
4884: PPUSH
4885: CALL_OW 52
// PlaceHumanInUnit ( zgamy2 [ 2 ] , Car2 ) ;
4889: LD_EXP 14
4893: PUSH
4894: LD_INT 2
4896: ARRAY
4897: PPUSH
4898: LD_EXP 45
4902: PPUSH
4903: CALL_OW 52
// PlaceUnitXYR ( Car1 , 13 , 3 , 8 , false ) ;
4907: LD_EXP 44
4911: PPUSH
4912: LD_INT 13
4914: PPUSH
4915: LD_INT 3
4917: PPUSH
4918: LD_INT 8
4920: PPUSH
4921: LD_INT 0
4923: PPUSH
4924: CALL_OW 50
// PlaceUnitXYR ( Car2 , 13 , 3 , 8 , false ) ;
4928: LD_EXP 45
4932: PPUSH
4933: LD_INT 13
4935: PPUSH
4936: LD_INT 3
4938: PPUSH
4939: LD_INT 8
4941: PPUSH
4942: LD_INT 0
4944: PPUSH
4945: CALL_OW 50
// for i := 1 to used diff ( zgamy2 ^ [ Car1 , Car2 ] ) do
4949: LD_ADDR_VAR 0 3
4953: PUSH
4954: DOUBLE
4955: LD_INT 1
4957: DEC
4958: ST_TO_ADDR
4959: LD_EXP 12
4963: PUSH
4964: LD_EXP 14
4968: PUSH
4969: LD_EXP 44
4973: PUSH
4974: LD_EXP 45
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: ADD
4983: DIFF
4984: PUSH
4985: FOR_TO
4986: IFFALSE 5017
// PlaceUnitXYR ( used [ i ] , 70 , 3 , 8 , false ) ;
4988: LD_EXP 12
4992: PUSH
4993: LD_VAR 0 3
4997: ARRAY
4998: PPUSH
4999: LD_INT 70
5001: PPUSH
5002: LD_INT 3
5004: PPUSH
5005: LD_INT 8
5007: PPUSH
5008: LD_INT 0
5010: PPUSH
5011: CALL_OW 50
5015: GO 4985
5017: POP
5018: POP
// mytick := tick ;
5019: LD_ADDR_EXP 87
5023: PUSH
5024: LD_OWVAR 1
5028: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
5029: LD_EXP 15
5033: PPUSH
5034: CALL_OW 87
// Wait ( 0 0$3 ) ;
5038: LD_INT 105
5040: PPUSH
5041: CALL_OW 67
// talkOn ;
5045: CALL 17150 0 0
// Say ( zgamy2 [ 2 ] , DEng-Eng1-1 ) ;
5049: LD_EXP 14
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_STRING DEng-Eng1-1
5060: PPUSH
5061: CALL_OW 88
// talkOff ;
5065: CALL 17166 0 0
// CenterOnUnits ( Car1 ) ;
5069: LD_EXP 44
5073: PPUSH
5074: CALL_OW 85
// InGameOff ;
5078: CALL_OW 9
// start_game := true ;
5082: LD_ADDR_EXP 55
5086: PUSH
5087: LD_INT 1
5089: ST_TO_ADDR
// end ;
5090: LD_VAR 0 1
5094: RET
// every 1 1$20 do
5095: GO 5097
5097: DISABLE
// begin DialogueOn ;
5098: CALL_OW 6
// SayRadio ( Har , DRem-Har-1 ) ;
5102: LD_EXP 16
5106: PPUSH
5107: LD_STRING DRem-Har-1
5109: PPUSH
5110: CALL_OW 94
// if attacky then
5114: LD_EXP 60
5118: IFFALSE 5134
// Say ( JMM , DRem-JMM-1 ) else
5120: LD_EXP 15
5124: PPUSH
5125: LD_STRING DRem-JMM-1
5127: PPUSH
5128: CALL_OW 88
5132: GO 5146
// Say ( JMM , DRem-JMM-1a ) ;
5134: LD_EXP 15
5138: PPUSH
5139: LD_STRING DRem-JMM-1a
5141: PPUSH
5142: CALL_OW 88
// SayRadio ( Har , DRem-Har-2 ) ;
5146: LD_EXP 16
5150: PPUSH
5151: LD_STRING DRem-Har-2
5153: PPUSH
5154: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5158: LD_STRING Denis
5160: PPUSH
5161: CALL_OW 29
5165: IFFALSE 5181
// Say ( JMM , DRem-JMM-2 ) else
5167: LD_EXP 15
5171: PPUSH
5172: LD_STRING DRem-JMM-2
5174: PPUSH
5175: CALL_OW 88
5179: GO 5193
// Say ( JMM , DRem-JMM-2a ) ;
5181: LD_EXP 15
5185: PPUSH
5186: LD_STRING DRem-JMM-2a
5188: PPUSH
5189: CALL_OW 88
// SayRadio ( Har , DRem-Har-3 ) ;
5193: LD_EXP 16
5197: PPUSH
5198: LD_STRING DRem-Har-3
5200: PPUSH
5201: CALL_OW 94
// Say ( JMM , DRem-JMM-3 ) ;
5205: LD_EXP 15
5209: PPUSH
5210: LD_STRING DRem-JMM-3
5212: PPUSH
5213: CALL_OW 88
// SayRadio ( Har , DRem-Har-4 ) ;
5217: LD_EXP 16
5221: PPUSH
5222: LD_STRING DRem-Har-4
5224: PPUSH
5225: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5229: LD_STRING Denis
5231: PPUSH
5232: CALL_OW 29
5236: IFFALSE 5262
// begin Say ( JMM , DRem-JMM-4 ) ;
5238: LD_EXP 15
5242: PPUSH
5243: LD_STRING DRem-JMM-4
5245: PPUSH
5246: CALL_OW 88
// SayRadio ( Har , DRem-Har-5 ) ;
5250: LD_EXP 16
5254: PPUSH
5255: LD_STRING DRem-Har-5
5257: PPUSH
5258: CALL_OW 94
// end ; DialogueOff ;
5262: CALL_OW 7
// ChangeMissionObjectives ( MR ) ;
5266: LD_STRING MR
5268: PPUSH
5269: CALL_OW 337
// if CheckCharacterSet ( Denis ) then
5273: LD_STRING Denis
5275: PPUSH
5276: CALL_OW 29
5280: IFFALSE 5328
// begin InitUc ;
5282: CALL_OW 18
// InitHc ;
5286: CALL_OW 19
// uc_side := you2 ;
5290: LD_ADDR_OWVAR 20
5294: PUSH
5295: LD_EXP 4
5299: ST_TO_ADDR
// uc_nation := nation_american ;
5300: LD_ADDR_OWVAR 21
5304: PUSH
5305: LD_INT 1
5307: ST_TO_ADDR
// Denis := CreateCharacterWithClass ( Denis , class_scientistic ) ;
5308: LD_ADDR_EXP 26
5312: PUSH
5313: LD_STRING Denis
5315: PPUSH
5316: LD_INT 4
5318: PPUSH
5319: CALL_OW 35
5323: ST_TO_ADDR
// DialogDenis ;
5324: CALL 5329 0 0
// end ; end ;
5328: END
// function DialogDenis ; var depot , nekdo , mytick ; begin
5329: LD_INT 0
5331: PPUSH
5332: PPUSH
5333: PPUSH
5334: PPUSH
// wait ( 9 9$0 ) ;
5335: LD_INT 18900
5337: PPUSH
5338: CALL_OW 67
// depot := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5342: LD_ADDR_VAR 0 2
5346: PUSH
5347: LD_INT 22
5349: PUSH
5350: LD_EXP 1
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: LD_INT 2
5361: PUSH
5362: LD_INT 30
5364: PUSH
5365: LD_INT 0
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: PUSH
5372: LD_INT 30
5374: PUSH
5375: LD_INT 1
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: LIST
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PPUSH
5391: CALL_OW 69
5395: ST_TO_ADDR
// if depot then
5396: LD_VAR 0 2
5400: IFFALSE 5416
// depot := depot [ 1 ] ;
5402: LD_ADDR_VAR 0 2
5406: PUSH
5407: LD_VAR 0 2
5411: PUSH
5412: LD_INT 1
5414: ARRAY
5415: ST_TO_ADDR
// mytick := tick + 0 0$15 ;
5416: LD_ADDR_VAR 0 4
5420: PUSH
5421: LD_OWVAR 1
5425: PUSH
5426: LD_INT 525
5428: PLUS
5429: ST_TO_ADDR
// PlaceUnitArea ( Denis , denis_come , false ) ;
5430: LD_EXP 26
5434: PPUSH
5435: LD_INT 9
5437: PPUSH
5438: LD_INT 0
5440: PPUSH
5441: CALL_OW 49
// case true of GetDistUnits ( Denis , JMM ) < 20 :
5445: LD_INT 1
5447: PUSH
5448: LD_EXP 26
5452: PPUSH
5453: LD_EXP 15
5457: PPUSH
5458: CALL_OW 296
5462: PUSH
5463: LD_INT 20
5465: LESS
5466: DOUBLE
5467: EQUAL
5468: IFTRUE 5472
5470: GO 5541
5472: POP
// begin ComMoveUnit ( Denis , JMM ) ;
5473: LD_EXP 26
5477: PPUSH
5478: LD_EXP 15
5482: PPUSH
5483: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and tick < mytick do
5487: LD_EXP 26
5491: PPUSH
5492: LD_VAR 0 2
5496: PPUSH
5497: CALL_OW 296
5501: PUSH
5502: LD_INT 5
5504: GREATER
5505: PUSH
5506: LD_EXP 26
5510: PPUSH
5511: CALL_OW 302
5515: AND
5516: PUSH
5517: LD_OWVAR 1
5521: PUSH
5522: LD_VAR 0 4
5526: LESS
5527: AND
5528: IFFALSE 5539
// begin wait ( 0 0$1 ) ;
5530: LD_INT 35
5532: PPUSH
5533: CALL_OW 67
// end ;
5537: GO 5487
// end ; GetDistUnits ( Denis , depot ) < 20 :
5539: GO 5758
5541: LD_EXP 26
5545: PPUSH
5546: LD_VAR 0 2
5550: PPUSH
5551: CALL_OW 296
5555: PUSH
5556: LD_INT 20
5558: LESS
5559: DOUBLE
5560: EQUAL
5561: IFTRUE 5565
5563: GO 5645
5565: POP
// begin ComMoveUnit ( Denis , depot ) ;
5566: LD_EXP 26
5570: PPUSH
5571: LD_VAR 0 2
5575: PPUSH
5576: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and IsOk ( depot ) and tick < mytick do
5580: LD_EXP 26
5584: PPUSH
5585: LD_VAR 0 2
5589: PPUSH
5590: CALL_OW 296
5594: PUSH
5595: LD_INT 5
5597: GREATER
5598: PUSH
5599: LD_EXP 26
5603: PPUSH
5604: CALL_OW 302
5608: AND
5609: PUSH
5610: LD_VAR 0 2
5614: PPUSH
5615: CALL_OW 302
5619: AND
5620: PUSH
5621: LD_OWVAR 1
5625: PUSH
5626: LD_VAR 0 4
5630: LESS
5631: AND
5632: IFFALSE 5643
// begin wait ( 0 0$1 ) ;
5634: LD_INT 35
5636: PPUSH
5637: CALL_OW 67
// end ;
5641: GO 5580
// end ; else
5643: GO 5758
5645: POP
// begin nekdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) , denis ) ;
5646: LD_ADDR_VAR 0 3
5650: PUSH
5651: LD_INT 22
5653: PUSH
5654: LD_EXP 1
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: PUSH
5663: LD_INT 21
5665: PUSH
5666: LD_INT 1
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: PPUSH
5677: CALL_OW 69
5681: PPUSH
5682: LD_EXP 26
5686: PPUSH
5687: CALL_OW 74
5691: ST_TO_ADDR
// ComMoveUnit ( Denis , nekdo ) ;
5692: LD_EXP 26
5696: PPUSH
5697: LD_VAR 0 3
5701: PPUSH
5702: CALL_OW 112
// while GetDistUnits ( Denis , nekdo ) > 5 and IsOK ( nekdo ) and tick < mytick do
5706: LD_EXP 26
5710: PPUSH
5711: LD_VAR 0 3
5715: PPUSH
5716: CALL_OW 296
5720: PUSH
5721: LD_INT 5
5723: GREATER
5724: PUSH
5725: LD_VAR 0 3
5729: PPUSH
5730: CALL_OW 302
5734: AND
5735: PUSH
5736: LD_OWVAR 1
5740: PUSH
5741: LD_VAR 0 4
5745: LESS
5746: AND
5747: IFFALSE 5758
// begin wait ( 0 0$1 ) ;
5749: LD_INT 35
5751: PPUSH
5752: CALL_OW 67
// end ;
5756: GO 5706
// end ; end ; ComStop ( Denis ) ;
5758: LD_EXP 26
5762: PPUSH
5763: CALL_OW 141
// SetSide ( Denis , you ) ;
5767: LD_EXP 26
5771: PPUSH
5772: LD_EXP 1
5776: PPUSH
5777: CALL_OW 235
// if IsLive ( Denis ) then
5781: LD_EXP 26
5785: PPUSH
5786: CALL_OW 300
5790: IFFALSE 5884
// begin enable ( 33 ) ;
5792: LD_INT 33
5794: ENABLE_MARKED
// DialogueOn ;
5795: CALL_OW 6
// CenterOnUnits ( Denis ) ;
5799: LD_EXP 26
5803: PPUSH
5804: CALL_OW 85
// Say ( Denis , DDen-Den-1 ) ;
5808: LD_EXP 26
5812: PPUSH
5813: LD_STRING DDen-Den-1
5815: PPUSH
5816: CALL_OW 88
// Say ( JMM , DDen-JMM-1 ) ;
5820: LD_EXP 15
5824: PPUSH
5825: LD_STRING DDen-JMM-1
5827: PPUSH
5828: CALL_OW 88
// Say ( Denis , DDen-Den-2 ) ;
5832: LD_EXP 26
5836: PPUSH
5837: LD_STRING DDen-Den-2
5839: PPUSH
5840: CALL_OW 88
// Say ( JMM , DDen-JMM-2 ) ;
5844: LD_EXP 15
5848: PPUSH
5849: LD_STRING DDen-JMM-2
5851: PPUSH
5852: CALL_OW 88
// Say ( Denis , DDen-Den-3 ) ;
5856: LD_EXP 26
5860: PPUSH
5861: LD_STRING DDen-Den-3
5863: PPUSH
5864: CALL_OW 88
// Say ( JMM , DDen-JMM-3 ) ;
5868: LD_EXP 15
5872: PPUSH
5873: LD_STRING DDen-JMM-3
5875: PPUSH
5876: CALL_OW 88
// DialogueOff ;
5880: CALL_OW 7
// end ; end ;
5884: LD_VAR 0 1
5888: RET
// export was_dialogR0 ; export function DialogR0 ; var kdo1 , kdo2 , r ; begin
5889: LD_INT 0
5891: PPUSH
5892: PPUSH
5893: PPUSH
5894: PPUSH
// if not was_dialogR0 then
5895: LD_EXP 88
5899: NOT
5900: IFFALSE 6212
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
5902: LD_ADDR_VAR 0 2
5906: PUSH
5907: LD_EXP 11
5911: PPUSH
5912: LD_EXP 1
5916: PPUSH
5917: LD_INT 1
5919: PPUSH
5920: LD_INT 0
5922: PPUSH
5923: LD_INT 1
5925: PPUSH
5926: CALL 17262 0 5
5930: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
5931: LD_ADDR_VAR 0 3
5935: PUSH
5936: LD_EXP 11
5940: PPUSH
5941: LD_EXP 1
5945: PPUSH
5946: LD_INT 1
5948: PPUSH
5949: LD_INT 0
5951: PPUSH
5952: LD_INT 2
5954: PPUSH
5955: CALL 17262 0 5
5959: ST_TO_ADDR
// if not kdo1 then
5960: LD_VAR 0 2
5964: NOT
5965: IFFALSE 6017
// kdo1 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 1 ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: CALL 13514 0 0
5976: PUSH
5977: LD_EXP 15
5981: PUSH
5982: LD_EXP 22
5986: PUSH
5987: LD_EXP 26
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: LIST
5996: DIFF
5997: PPUSH
5998: LD_EXP 1
6002: PPUSH
6003: LD_INT 1
6005: PPUSH
6006: LD_INT 0
6008: PPUSH
6009: LD_INT 1
6011: PPUSH
6012: CALL 17262 0 5
6016: ST_TO_ADDR
// if not kdo2 then
6017: LD_VAR 0 3
6021: NOT
6022: IFFALSE 6074
// kdo2 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 2 ) ;
6024: LD_ADDR_VAR 0 3
6028: PUSH
6029: CALL 13514 0 0
6033: PUSH
6034: LD_EXP 15
6038: PUSH
6039: LD_EXP 22
6043: PUSH
6044: LD_EXP 26
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: DIFF
6054: PPUSH
6055: LD_EXP 1
6059: PPUSH
6060: LD_INT 1
6062: PPUSH
6063: LD_INT 0
6065: PPUSH
6066: LD_INT 2
6068: PPUSH
6069: CALL 17262 0 5
6073: ST_TO_ADDR
// TalkOn ;
6074: CALL 17150 0 0
// if IsOK ( Lisa ) then
6078: LD_EXP 21
6082: PPUSH
6083: CALL_OW 302
6087: IFFALSE 6109
// r := Say ( Lisa , DR0-Lisa-1 ) else
6089: LD_ADDR_VAR 0 4
6093: PUSH
6094: LD_EXP 21
6098: PPUSH
6099: LD_STRING DR0-Lisa-1
6101: PPUSH
6102: CALL_OW 88
6106: ST_TO_ADDR
6107: GO 6127
// r := Say ( kdo1 , DR0-Sol1-1 ) ;
6109: LD_ADDR_VAR 0 4
6113: PUSH
6114: LD_VAR 0 2
6118: PPUSH
6119: LD_STRING DR0-Sol1-1
6121: PPUSH
6122: CALL_OW 88
6126: ST_TO_ADDR
// if r then
6127: LD_VAR 0 4
6131: IFFALSE 6182
// if IsOK ( Cyrus ) then
6133: LD_EXP 22
6137: PPUSH
6138: CALL_OW 302
6142: IFFALSE 6164
// r := Say ( Cyrus , DR0-Cyrus-1 ) else
6144: LD_ADDR_VAR 0 4
6148: PUSH
6149: LD_EXP 22
6153: PPUSH
6154: LD_STRING DR0-Cyrus-1
6156: PPUSH
6157: CALL_OW 88
6161: ST_TO_ADDR
6162: GO 6182
// r := Say ( kdo2 , DR0-Sol2-1 ) ;
6164: LD_ADDR_VAR 0 4
6168: PUSH
6169: LD_VAR 0 3
6173: PPUSH
6174: LD_STRING DR0-Sol2-1
6176: PPUSH
6177: CALL_OW 88
6181: ST_TO_ADDR
// if r then
6182: LD_VAR 0 4
6186: IFFALSE 6200
// Say ( JMM , DR0-JMM-1 ) ;
6188: LD_EXP 15
6192: PPUSH
6193: LD_STRING DR0-JMM-1
6195: PPUSH
6196: CALL_OW 88
// TalkOff ;
6200: CALL 17166 0 0
// was_dialogR0 := true ;
6204: LD_ADDR_EXP 88
6208: PUSH
6209: LD_INT 1
6211: ST_TO_ADDR
// end ; end ;
6212: LD_VAR 0 1
6216: RET
// function MajiOpto ; var i ; begin
6217: LD_INT 0
6219: PPUSH
6220: PPUSH
// result := false ;
6221: LD_ADDR_VAR 0 1
6225: PUSH
6226: LD_INT 0
6228: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
6229: LD_ADDR_VAR 0 2
6233: PUSH
6234: LD_INT 22
6236: PUSH
6237: LD_EXP 1
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 2
6248: PUSH
6249: LD_INT 30
6251: PUSH
6252: LD_INT 7
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: LD_INT 30
6261: PUSH
6262: LD_INT 8
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: PPUSH
6278: CALL_OW 69
6282: PUSH
6283: FOR_IN
6284: IFFALSE 6334
// if ( GetLabKind ( i , 1 ) = b_lab_opto ) or ( GetLabKind ( i , 2 ) = b_lab_opto ) then
6286: LD_VAR 0 2
6290: PPUSH
6291: LD_INT 1
6293: PPUSH
6294: CALL_OW 268
6298: PUSH
6299: LD_INT 15
6301: EQUAL
6302: PUSH
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 2
6310: PPUSH
6311: CALL_OW 268
6315: PUSH
6316: LD_INT 15
6318: EQUAL
6319: OR
6320: IFFALSE 6332
// begin result := true ;
6322: LD_ADDR_VAR 0 1
6326: PUSH
6327: LD_INT 1
6329: ST_TO_ADDR
// break ;
6330: GO 6334
// end ;
6332: GO 6283
6334: POP
6335: POP
// end ;
6336: LD_VAR 0 1
6340: RET
// every 0 0$7 trigger MajiOpto and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] ] ] ) marked 33 do
6341: CALL 6217 0 0
6345: PUSH
6346: LD_INT 22
6348: PUSH
6349: LD_EXP 1
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 2
6360: PUSH
6361: LD_INT 30
6363: PUSH
6364: LD_INT 26
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PUSH
6371: LD_INT 30
6373: PUSH
6374: LD_INT 27
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: LIST
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PPUSH
6390: CALL_OW 69
6394: AND
6395: IFFALSE 6445
6397: GO 6399
6399: DISABLE
// begin if IsOK ( Denis ) then
6400: LD_EXP 26
6404: PPUSH
6405: CALL_OW 302
6409: IFFALSE 6445
// begin DialogueOn ;
6411: CALL_OW 6
// if Say ( Denis , DR1-Den-1 ) then
6415: LD_EXP 26
6419: PPUSH
6420: LD_STRING DR1-Den-1
6422: PPUSH
6423: CALL_OW 88
6427: IFFALSE 6441
// Say ( JMM , DR1-JMM-1 ) ;
6429: LD_EXP 15
6433: PPUSH
6434: LD_STRING DR1-JMM-1
6436: PPUSH
6437: CALL_OW 88
// DialogueOff ;
6441: CALL_OW 7
// end ; end ;
6445: END
// function ScisInLabs ; var labs , i , inlabs ; begin
6446: LD_INT 0
6448: PPUSH
6449: PPUSH
6450: PPUSH
6451: PPUSH
// inlabs := [ ] ;
6452: LD_ADDR_VAR 0 4
6456: PUSH
6457: EMPTY
6458: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
6459: LD_ADDR_VAR 0 2
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: LD_EXP 1
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PUSH
6476: LD_INT 2
6478: PUSH
6479: LD_INT 30
6481: PUSH
6482: LD_INT 6
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 30
6491: PUSH
6492: LD_INT 7
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: PUSH
6499: LD_INT 30
6501: PUSH
6502: LD_INT 8
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: LIST
6513: LIST
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: PPUSH
6519: CALL_OW 69
6523: ST_TO_ADDR
// for i in labs do
6524: LD_ADDR_VAR 0 3
6528: PUSH
6529: LD_VAR 0 2
6533: PUSH
6534: FOR_IN
6535: IFFALSE 6560
// inlabs := inlabs ^ UnitsInside ( i ) ;
6537: LD_ADDR_VAR 0 4
6541: PUSH
6542: LD_VAR 0 4
6546: PUSH
6547: LD_VAR 0 3
6551: PPUSH
6552: CALL_OW 313
6556: ADD
6557: ST_TO_ADDR
6558: GO 6534
6560: POP
6561: POP
// result := UnitFilter ( inlabs , [ f_class , class_scientistic ] ) ;
6562: LD_ADDR_VAR 0 1
6566: PUSH
6567: LD_VAR 0 4
6571: PPUSH
6572: LD_INT 25
6574: PUSH
6575: LD_INT 4
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PPUSH
6582: CALL_OW 72
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 1
6591: RET
// export function DialogR2 ; var scis , r ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// scis := ScisInLabs ;
6597: LD_ADDR_VAR 0 2
6601: PUSH
6602: CALL 6446 0 0
6606: ST_TO_ADDR
// if scis isect ( not_char union Denis ) then
6607: LD_VAR 0 2
6611: PUSH
6612: LD_EXP 11
6616: PUSH
6617: LD_EXP 26
6621: UNION
6622: ISECT
6623: IFFALSE 6647
// scis := scis isect ( not_char union Denis ) ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: LD_VAR 0 2
6634: PUSH
6635: LD_EXP 11
6639: PUSH
6640: LD_EXP 26
6644: UNION
6645: ISECT
6646: ST_TO_ADDR
// if scis then
6647: LD_VAR 0 2
6651: IFFALSE 6834
// begin DialogueOn ;
6653: CALL_OW 6
// if not IsDead ( Denis ) and ( Denis in scis ) then
6657: LD_EXP 26
6661: PPUSH
6662: CALL_OW 301
6666: NOT
6667: PUSH
6668: LD_EXP 26
6672: PUSH
6673: LD_VAR 0 2
6677: IN
6678: AND
6679: IFFALSE 6701
// r := Say ( Denis , DR2-Den-1 ) else
6681: LD_ADDR_VAR 0 3
6685: PUSH
6686: LD_EXP 26
6690: PPUSH
6691: LD_STRING DR2-Den-1
6693: PPUSH
6694: CALL_OW 88
6698: ST_TO_ADDR
6699: GO 6766
// if GetSex ( scis [ 1 ] ) = sex_male then
6701: LD_VAR 0 2
6705: PUSH
6706: LD_INT 1
6708: ARRAY
6709: PPUSH
6710: CALL_OW 258
6714: PUSH
6715: LD_INT 1
6717: EQUAL
6718: IFFALSE 6744
// r := Say ( scis [ 1 ] , DR2-Sci1-1 ) else
6720: LD_ADDR_VAR 0 3
6724: PUSH
6725: LD_VAR 0 2
6729: PUSH
6730: LD_INT 1
6732: ARRAY
6733: PPUSH
6734: LD_STRING DR2-Sci1-1
6736: PPUSH
6737: CALL_OW 88
6741: ST_TO_ADDR
6742: GO 6766
// r := Say ( scis [ 1 ] , DR2-FSci1-1 ) ;
6744: LD_ADDR_VAR 0 3
6748: PUSH
6749: LD_VAR 0 2
6753: PUSH
6754: LD_INT 1
6756: ARRAY
6757: PPUSH
6758: LD_STRING DR2-FSci1-1
6760: PPUSH
6761: CALL_OW 88
6765: ST_TO_ADDR
// if r then
6766: LD_VAR 0 3
6770: IFFALSE 6784
// Say ( JMM , DR2-JMM-1 ) ;
6772: LD_EXP 15
6776: PPUSH
6777: LD_STRING DR2-JMM-1
6779: PPUSH
6780: CALL_OW 88
// if r then
6784: LD_VAR 0 3
6788: IFFALSE 6830
// if SayAny ( not_char , DR2-Sol1-1 , you , sex_male , 0 , 0 ) then
6790: LD_EXP 11
6794: PPUSH
6795: LD_STRING DR2-Sol1-1
6797: PPUSH
6798: LD_EXP 1
6802: PPUSH
6803: LD_INT 1
6805: PPUSH
6806: LD_INT 0
6808: PPUSH
6809: LD_INT 0
6811: PPUSH
6812: CALL 17182 0 6
6816: IFFALSE 6830
// Say ( JMM , DR2-JMM-2 ) ;
6818: LD_EXP 15
6822: PPUSH
6823: LD_STRING DR2-JMM-2
6825: PPUSH
6826: CALL_OW 88
// DialogueOff ;
6830: CALL_OW 7
// end ; end ;
6834: LD_VAR 0 1
6838: RET
// export function DialogKurt ( kdo ) ; var qr , mytick ; var JeMM , JeF ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// DialogInProgress := true ;
6846: LD_ADDR_EXP 52
6850: PUSH
6851: LD_INT 1
6853: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_outside ] , [ f_nation , nation_american ] , [ f_alive ] ] ) , Kurt ) ;
6854: LD_ADDR_VAR 0 1
6858: PUSH
6859: LD_INT 22
6861: PUSH
6862: LD_EXP 1
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: PUSH
6871: LD_INT 21
6873: PUSH
6874: LD_INT 1
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PUSH
6881: LD_INT 56
6883: PUSH
6884: EMPTY
6885: LIST
6886: PUSH
6887: LD_INT 23
6889: PUSH
6890: LD_INT 1
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: LD_INT 51
6899: PUSH
6900: EMPTY
6901: LIST
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: PPUSH
6910: CALL_OW 69
6914: PPUSH
6915: LD_EXP 43
6919: PPUSH
6920: CALL_OW 74
6924: ST_TO_ADDR
// JeF := ( GetSex ( kdo ) = sex_female ) ;
6925: LD_ADDR_VAR 0 6
6929: PUSH
6930: LD_VAR 0 1
6934: PPUSH
6935: CALL_OW 258
6939: PUSH
6940: LD_INT 2
6942: EQUAL
6943: ST_TO_ADDR
// JeMM := ( kdo = JMM ) ;
6944: LD_ADDR_VAR 0 5
6948: PUSH
6949: LD_VAR 0 1
6953: PUSH
6954: LD_EXP 15
6958: EQUAL
6959: ST_TO_ADDR
// InGameOn ;
6960: CALL_OW 8
// CenterOnUnits ( Kurt ) ;
6964: LD_EXP 43
6968: PPUSH
6969: CALL_OW 85
// Wait ( 0 0$4 ) ;
6973: LD_INT 140
6975: PPUSH
6976: CALL_OW 67
// ComMoveUnit ( kdo , Kurt ) ;
6980: LD_VAR 0 1
6984: PPUSH
6985: LD_EXP 43
6989: PPUSH
6990: CALL_OW 112
// AddComTurnUnit ( kdo , Kurt ) ;
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_EXP 43
7003: PPUSH
7004: CALL_OW 179
// AddComHold ( kdo ) ;
7008: LD_VAR 0 1
7012: PPUSH
7013: CALL_OW 200
// ComMoveUnit ( Kurt , kdo ) ;
7017: LD_EXP 43
7021: PPUSH
7022: LD_VAR 0 1
7026: PPUSH
7027: CALL_OW 112
// AddComTurnUnit ( Kurt , kdo ) ;
7031: LD_EXP 43
7035: PPUSH
7036: LD_VAR 0 1
7040: PPUSH
7041: CALL_OW 179
// AddComHold ( Kurt ) ;
7045: LD_EXP 43
7049: PPUSH
7050: CALL_OW 200
// mytick := tick + 0 0$15 ;
7054: LD_ADDR_VAR 0 4
7058: PUSH
7059: LD_OWVAR 1
7063: PUSH
7064: LD_INT 525
7066: PLUS
7067: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Kurt , kdo ) > 4 do
7068: LD_VAR 0 4
7072: PUSH
7073: LD_OWVAR 1
7077: GREATER
7078: PUSH
7079: LD_EXP 43
7083: PPUSH
7084: LD_VAR 0 1
7088: PPUSH
7089: CALL_OW 296
7093: PUSH
7094: LD_INT 4
7096: GREATER
7097: AND
7098: IFFALSE 7109
// Wait ( 0 0$1 ) ;
7100: LD_INT 35
7102: PPUSH
7103: CALL_OW 67
7107: GO 7068
// InGameOff ;
7109: CALL_OW 9
// if IsLive ( Kurt ) and IsLive ( kdo ) then
7113: LD_EXP 43
7117: PPUSH
7118: CALL_OW 300
7122: PUSH
7123: LD_VAR 0 1
7127: PPUSH
7128: CALL_OW 300
7132: AND
7133: IFFALSE 8389
// begin DialogueOn ;
7135: CALL_OW 6
// if JeMM then
7139: LD_VAR 0 5
7143: IFFALSE 7473
// begin Say ( Kurt , D2-Kurt-1 ) ;
7145: LD_EXP 43
7149: PPUSH
7150: LD_STRING D2-Kurt-1
7152: PPUSH
7153: CALL_OW 88
// Say ( kdo , D2-JMM-1 ) ;
7157: LD_VAR 0 1
7161: PPUSH
7162: LD_STRING D2-JMM-1
7164: PPUSH
7165: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7169: LD_EXP 43
7173: PPUSH
7174: LD_STRING D2-Kurt-2
7176: PPUSH
7177: CALL_OW 88
// Say ( kdo , D2-JMM-2 ) ;
7181: LD_VAR 0 1
7185: PPUSH
7186: LD_STRING D2-JMM-2
7188: PPUSH
7189: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7193: LD_EXP 43
7197: PPUSH
7198: LD_STRING D2-Kurt-3
7200: PPUSH
7201: CALL_OW 88
// Say ( kdo , D2-JMM-3 ) ;
7205: LD_VAR 0 1
7209: PPUSH
7210: LD_STRING D2-JMM-3
7212: PPUSH
7213: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7217: LD_EXP 43
7221: PPUSH
7222: LD_STRING D2-Kurt-4
7224: PPUSH
7225: CALL_OW 88
// Say ( kdo , D2-JMM-4 ) ;
7229: LD_VAR 0 1
7233: PPUSH
7234: LD_STRING D2-JMM-4
7236: PPUSH
7237: CALL_OW 88
// qr := Query ( QKill ) ;
7241: LD_ADDR_VAR 0 3
7245: PUSH
7246: LD_STRING QKill
7248: PPUSH
7249: CALL_OW 97
7253: ST_TO_ADDR
// case qr of 1 :
7254: LD_VAR 0 3
7258: PUSH
7259: LD_INT 1
7261: DOUBLE
7262: EQUAL
7263: IFTRUE 7267
7265: GO 7282
7267: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7268: LD_EXP 43
7272: PPUSH
7273: LD_STRING D2a-Kurt-1
7275: PPUSH
7276: CALL_OW 88
// end ; 2 :
7280: GO 7384
7282: LD_INT 2
7284: DOUBLE
7285: EQUAL
7286: IFTRUE 7290
7288: GO 7348
7290: POP
// begin Say ( kdo , D2b-JMM-1 ) ;
7291: LD_VAR 0 1
7295: PPUSH
7296: LD_STRING D2b-JMM-1
7298: PPUSH
7299: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7303: LD_EXP 43
7307: PPUSH
7308: LD_STRING D2b-Kurt-1
7310: PPUSH
7311: CALL_OW 88
// Say ( kdo , D2b-JMM-2 ) ;
7315: LD_VAR 0 1
7319: PPUSH
7320: LD_STRING D2b-JMM-2
7322: PPUSH
7323: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7327: LD_EXP 43
7331: PPUSH
7332: LD_STRING D2b-Kurt-2
7334: PPUSH
7335: CALL_OW 88
// SayEffect ( Kurtfire.wav ) ;
7339: LD_STRING Kurtfire.wav
7341: PPUSH
7342: CALL_OW 96
// end ; 3 :
7346: GO 7384
7348: LD_INT 3
7350: DOUBLE
7351: EQUAL
7352: IFTRUE 7356
7354: GO 7383
7356: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7357: LD_VAR 0 1
7361: PPUSH
7362: LD_STRING D2c-JMM-1
7364: PPUSH
7365: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7369: LD_EXP 43
7373: PPUSH
7374: LD_STRING D2c-Kurt-1
7376: PPUSH
7377: CALL_OW 88
// end ; end ;
7381: GO 7384
7383: POP
// if qr = 2 then
7384: LD_VAR 0 3
7388: PUSH
7389: LD_INT 2
7391: EQUAL
7392: IFFALSE 7471
// begin qr := Query ( QKill2 ) ;
7394: LD_ADDR_VAR 0 3
7398: PUSH
7399: LD_STRING QKill2
7401: PPUSH
7402: CALL_OW 97
7406: ST_TO_ADDR
// case qr of 1 :
7407: LD_VAR 0 3
7411: PUSH
7412: LD_INT 1
7414: DOUBLE
7415: EQUAL
7416: IFTRUE 7420
7418: GO 7435
7420: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7421: LD_EXP 43
7425: PPUSH
7426: LD_STRING D2a-Kurt-1
7428: PPUSH
7429: CALL_OW 88
// end ; 2 :
7433: GO 7471
7435: LD_INT 2
7437: DOUBLE
7438: EQUAL
7439: IFTRUE 7443
7441: GO 7470
7443: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7444: LD_VAR 0 1
7448: PPUSH
7449: LD_STRING D2c-JMM-1
7451: PPUSH
7452: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7456: LD_EXP 43
7460: PPUSH
7461: LD_STRING D2c-Kurt-1
7463: PPUSH
7464: CALL_OW 88
// end ; end ;
7468: GO 7471
7470: POP
// end ; end else
7471: GO 8167
// if JeF then
7473: LD_VAR 0 6
7477: IFFALSE 7824
// begin Say ( Kurt , D2-Kurt-1 ) ;
7479: LD_EXP 43
7483: PPUSH
7484: LD_STRING D2-Kurt-1
7486: PPUSH
7487: CALL_OW 88
// Say ( kdo , D2-FSol1-1 ) ;
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_STRING D2-FSol1-1
7498: PPUSH
7499: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7503: LD_EXP 43
7507: PPUSH
7508: LD_STRING D2-Kurt-2
7510: PPUSH
7511: CALL_OW 88
// Say ( kdo , D2-FSol1-2 ) ;
7515: LD_VAR 0 1
7519: PPUSH
7520: LD_STRING D2-FSol1-2
7522: PPUSH
7523: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7527: LD_EXP 43
7531: PPUSH
7532: LD_STRING D2-Kurt-3
7534: PPUSH
7535: CALL_OW 88
// Say ( kdo , D2-FSol1-3 ) ;
7539: LD_VAR 0 1
7543: PPUSH
7544: LD_STRING D2-FSol1-3
7546: PPUSH
7547: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7551: LD_EXP 43
7555: PPUSH
7556: LD_STRING D2-Kurt-4
7558: PPUSH
7559: CALL_OW 88
// Say ( kdo , D2-FSol1-4 ) ;
7563: LD_VAR 0 1
7567: PPUSH
7568: LD_STRING D2-FSol1-4
7570: PPUSH
7571: CALL_OW 88
// Say ( kdo , D2-FSol1-5 ) ;
7575: LD_VAR 0 1
7579: PPUSH
7580: LD_STRING D2-FSol1-5
7582: PPUSH
7583: CALL_OW 88
// qr := Query ( QKill ) ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_STRING QKill
7594: PPUSH
7595: CALL_OW 97
7599: ST_TO_ADDR
// case qr of 1 :
7600: LD_VAR 0 3
7604: PUSH
7605: LD_INT 1
7607: DOUBLE
7608: EQUAL
7609: IFTRUE 7613
7611: GO 7628
7613: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7614: LD_EXP 43
7618: PPUSH
7619: LD_STRING D2a-Kurt-1
7621: PPUSH
7622: CALL_OW 88
// end ; 2 :
7626: GO 7735
7628: LD_INT 2
7630: DOUBLE
7631: EQUAL
7632: IFTRUE 7636
7634: GO 7699
7636: POP
// begin Say ( kdo , D2b-FSol1-1 ) ;
7637: LD_VAR 0 1
7641: PPUSH
7642: LD_STRING D2b-FSol1-1
7644: PPUSH
7645: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7649: LD_EXP 43
7653: PPUSH
7654: LD_STRING D2b-Kurt-1
7656: PPUSH
7657: CALL_OW 88
// Say ( kdo , D2b-FSol1-2 ) ;
7661: LD_VAR 0 1
7665: PPUSH
7666: LD_STRING D2b-FSol1-2
7668: PPUSH
7669: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7673: LD_EXP 43
7677: PPUSH
7678: LD_STRING D2b-Kurt-2
7680: PPUSH
7681: CALL_OW 88
// Say ( kdo , D2b-FSol1-3 ) ;
7685: LD_VAR 0 1
7689: PPUSH
7690: LD_STRING D2b-FSol1-3
7692: PPUSH
7693: CALL_OW 88
// end ; 3 :
7697: GO 7735
7699: LD_INT 3
7701: DOUBLE
7702: EQUAL
7703: IFTRUE 7707
7705: GO 7734
7707: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7708: LD_VAR 0 1
7712: PPUSH
7713: LD_STRING D2c-FSol1-1
7715: PPUSH
7716: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7720: LD_EXP 43
7724: PPUSH
7725: LD_STRING D2c-Kurt-1
7727: PPUSH
7728: CALL_OW 88
// end ; end ;
7732: GO 7735
7734: POP
// if qr = 2 then
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 2
7742: EQUAL
7743: IFFALSE 7822
// begin qr := Query ( QKill2 ) ;
7745: LD_ADDR_VAR 0 3
7749: PUSH
7750: LD_STRING QKill2
7752: PPUSH
7753: CALL_OW 97
7757: ST_TO_ADDR
// case qr of 1 :
7758: LD_VAR 0 3
7762: PUSH
7763: LD_INT 1
7765: DOUBLE
7766: EQUAL
7767: IFTRUE 7771
7769: GO 7786
7771: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7772: LD_EXP 43
7776: PPUSH
7777: LD_STRING D2a-Kurt-1
7779: PPUSH
7780: CALL_OW 88
// end ; 2 :
7784: GO 7822
7786: LD_INT 2
7788: DOUBLE
7789: EQUAL
7790: IFTRUE 7794
7792: GO 7821
7794: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7795: LD_VAR 0 1
7799: PPUSH
7800: LD_STRING D2c-FSol1-1
7802: PPUSH
7803: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7807: LD_EXP 43
7811: PPUSH
7812: LD_STRING D2c-Kurt-1
7814: PPUSH
7815: CALL_OW 88
// end ; end ;
7819: GO 7822
7821: POP
// end ; end else
7822: GO 8167
// begin Say ( Kurt , D2-Kurt-1 ) ;
7824: LD_EXP 43
7828: PPUSH
7829: LD_STRING D2-Kurt-1
7831: PPUSH
7832: CALL_OW 88
// Say ( kdo , D2-Sol1-1 ) ;
7836: LD_VAR 0 1
7840: PPUSH
7841: LD_STRING D2-Sol1-1
7843: PPUSH
7844: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7848: LD_EXP 43
7852: PPUSH
7853: LD_STRING D2-Kurt-2
7855: PPUSH
7856: CALL_OW 88
// Say ( kdo , D2-Sol1-2 ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: LD_STRING D2-Sol1-2
7867: PPUSH
7868: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7872: LD_EXP 43
7876: PPUSH
7877: LD_STRING D2-Kurt-3
7879: PPUSH
7880: CALL_OW 88
// Say ( kdo , D2-Sol1-3 ) ;
7884: LD_VAR 0 1
7888: PPUSH
7889: LD_STRING D2-Sol1-3
7891: PPUSH
7892: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7896: LD_EXP 43
7900: PPUSH
7901: LD_STRING D2-Kurt-4
7903: PPUSH
7904: CALL_OW 88
// Say ( kdo , D2-Sol1-4 ) ;
7908: LD_VAR 0 1
7912: PPUSH
7913: LD_STRING D2-Sol1-4
7915: PPUSH
7916: CALL_OW 88
// Say ( kdo , D2-Sol1-5 ) ;
7920: LD_VAR 0 1
7924: PPUSH
7925: LD_STRING D2-Sol1-5
7927: PPUSH
7928: CALL_OW 88
// qr := Query ( QKill ) ;
7932: LD_ADDR_VAR 0 3
7936: PUSH
7937: LD_STRING QKill
7939: PPUSH
7940: CALL_OW 97
7944: ST_TO_ADDR
// case qr of 1 :
7945: LD_VAR 0 3
7949: PUSH
7950: LD_INT 1
7952: DOUBLE
7953: EQUAL
7954: IFTRUE 7958
7956: GO 7973
7958: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7959: LD_EXP 43
7963: PPUSH
7964: LD_STRING D2a-Kurt-1
7966: PPUSH
7967: CALL_OW 88
// end ; 2 :
7971: GO 8080
7973: LD_INT 2
7975: DOUBLE
7976: EQUAL
7977: IFTRUE 7981
7979: GO 8044
7981: POP
// begin Say ( kdo , D2b-Sol1-1 ) ;
7982: LD_VAR 0 1
7986: PPUSH
7987: LD_STRING D2b-Sol1-1
7989: PPUSH
7990: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7994: LD_EXP 43
7998: PPUSH
7999: LD_STRING D2b-Kurt-1
8001: PPUSH
8002: CALL_OW 88
// Say ( kdo , D2b-Sol1-2 ) ;
8006: LD_VAR 0 1
8010: PPUSH
8011: LD_STRING D2b-Sol1-2
8013: PPUSH
8014: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
8018: LD_EXP 43
8022: PPUSH
8023: LD_STRING D2b-Kurt-2
8025: PPUSH
8026: CALL_OW 88
// Say ( kdo , D2b-Sol1-3 ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_STRING D2b-Sol1-3
8037: PPUSH
8038: CALL_OW 88
// end ; 3 :
8042: GO 8080
8044: LD_INT 3
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8079
8052: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8053: LD_VAR 0 1
8057: PPUSH
8058: LD_STRING D2c-Sol1-1
8060: PPUSH
8061: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8065: LD_EXP 43
8069: PPUSH
8070: LD_STRING D2c-Kurt-1
8072: PPUSH
8073: CALL_OW 88
// end ; end ;
8077: GO 8080
8079: POP
// if qr = 2 then
8080: LD_VAR 0 3
8084: PUSH
8085: LD_INT 2
8087: EQUAL
8088: IFFALSE 8167
// begin qr := Query ( QKill2 ) ;
8090: LD_ADDR_VAR 0 3
8094: PUSH
8095: LD_STRING QKill2
8097: PPUSH
8098: CALL_OW 97
8102: ST_TO_ADDR
// case qr of 1 :
8103: LD_VAR 0 3
8107: PUSH
8108: LD_INT 1
8110: DOUBLE
8111: EQUAL
8112: IFTRUE 8116
8114: GO 8131
8116: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
8117: LD_EXP 43
8121: PPUSH
8122: LD_STRING D2a-Kurt-1
8124: PPUSH
8125: CALL_OW 88
// end ; 2 :
8129: GO 8167
8131: LD_INT 2
8133: DOUBLE
8134: EQUAL
8135: IFTRUE 8139
8137: GO 8166
8139: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8140: LD_VAR 0 1
8144: PPUSH
8145: LD_STRING D2c-Sol1-1
8147: PPUSH
8148: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8152: LD_EXP 43
8156: PPUSH
8157: LD_STRING D2c-Kurt-1
8159: PPUSH
8160: CALL_OW 88
// end ; end ;
8164: GO 8167
8166: POP
// end ; end ; DialogueOff ;
8167: CALL_OW 7
// if qr = 1 then
8171: LD_VAR 0 3
8175: PUSH
8176: LD_INT 1
8178: EQUAL
8179: IFFALSE 8281
// begin KurtTryToEscape := true ;
8181: LD_ADDR_EXP 85
8185: PUSH
8186: LD_INT 1
8188: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
8189: LD_EXP 3
8193: PPUSH
8194: LD_EXP 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: LD_INT 1
8204: PPUSH
8205: CALL_OW 80
// ComAttackUnit ( kdo , Kurt ) ;
8209: LD_VAR 0 1
8213: PPUSH
8214: LD_EXP 43
8218: PPUSH
8219: CALL_OW 115
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) do
8223: LD_EXP 43
8227: PPUSH
8228: LD_INT 10
8230: PPUSH
8231: CALL_OW 308
8235: NOT
8236: PUSH
8237: LD_EXP 43
8241: PPUSH
8242: CALL_OW 300
8246: AND
8247: IFFALSE 8270
// begin ComMoveToArea ( Kurt , border ) ;
8249: LD_EXP 43
8253: PPUSH
8254: LD_INT 10
8256: PPUSH
8257: CALL_OW 113
// wait ( 0 0$1 ) ;
8261: LD_INT 35
8263: PPUSH
8264: CALL_OW 67
// end ;
8268: GO 8223
// RemoveUnit ( Kurt ) ;
8270: LD_EXP 43
8274: PPUSH
8275: CALL_OW 64
// end else
8279: GO 8389
// begin SA_OnKurtSpared ;
8281: CALL 27083 0 0
// mytick := tick + 0 0$20 ;
8285: LD_ADDR_VAR 0 4
8289: PUSH
8290: LD_OWVAR 1
8294: PUSH
8295: LD_INT 700
8297: PLUS
8298: ST_TO_ADDR
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) and mytick > tick do
8299: LD_EXP 43
8303: PPUSH
8304: LD_INT 10
8306: PPUSH
8307: CALL_OW 308
8311: NOT
8312: PUSH
8313: LD_EXP 43
8317: PPUSH
8318: CALL_OW 300
8322: AND
8323: PUSH
8324: LD_VAR 0 4
8328: PUSH
8329: LD_OWVAR 1
8333: GREATER
8334: AND
8335: IFFALSE 8358
// begin ComMoveToArea ( Kurt , border ) ;
8337: LD_EXP 43
8341: PPUSH
8342: LD_INT 10
8344: PPUSH
8345: CALL_OW 113
// wait ( 0 0$1 ) ;
8349: LD_INT 35
8351: PPUSH
8352: CALL_OW 67
// end ;
8356: GO 8299
// if IsPlaced ( Kurt ) and IsLive ( kurt ) then
8358: LD_EXP 43
8362: PPUSH
8363: CALL_OW 305
8367: PUSH
8368: LD_EXP 43
8372: PPUSH
8373: CALL_OW 300
8377: AND
8378: IFFALSE 8389
// RemoveUnit ( Kurt ) ;
8380: LD_EXP 43
8384: PPUSH
8385: CALL_OW 64
// end ; end ; DialogInProgress := false ;
8389: LD_ADDR_EXP 52
8393: PUSH
8394: LD_INT 0
8396: ST_TO_ADDR
// end ;
8397: LD_VAR 0 2
8401: RET
// every 0 0$10 trigger GetAttitude ( arabians , you ) = att_enemy do
8402: LD_EXP 3
8406: PPUSH
8407: LD_EXP 1
8411: PPUSH
8412: CALL_OW 81
8416: PUSH
8417: LD_INT 2
8419: EQUAL
8420: IFFALSE 8433
8422: GO 8424
8424: DISABLE
// begin KurtTryToEscape := true ;
8425: LD_ADDR_EXP 85
8429: PUSH
8430: LD_INT 1
8432: ST_TO_ADDR
// end ;
8433: END
// export function DialogJoan ( kdo ) ; var mytick ; begin
8434: LD_INT 0
8436: PPUSH
8437: PPUSH
// DialogInProgress := true ;
8438: LD_ADDR_EXP 52
8442: PUSH
8443: LD_INT 1
8445: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8446: LD_ADDR_VAR 0 1
8450: PUSH
8451: LD_INT 26
8453: PUSH
8454: LD_INT 1
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 22
8463: PUSH
8464: LD_EXP 1
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 21
8475: PUSH
8476: LD_INT 1
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: LD_INT 54
8488: PUSH
8489: EMPTY
8490: LIST
8491: PUSH
8492: LD_INT 3
8494: PUSH
8495: LD_INT 55
8497: PUSH
8498: EMPTY
8499: LIST
8500: PUSH
8501: LD_INT 3
8503: PUSH
8504: LD_INT 23
8506: PUSH
8507: LD_INT 0
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 51
8516: PUSH
8517: EMPTY
8518: LIST
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: PPUSH
8532: CALL_OW 69
8536: PUSH
8537: LD_EXP 33
8541: DIFF
8542: PPUSH
8543: LD_EXP 33
8547: PPUSH
8548: CALL_OW 74
8552: ST_TO_ADDR
// InGameOn ;
8553: CALL_OW 8
// CenterOnUnits ( Joan ) ;
8557: LD_EXP 33
8561: PPUSH
8562: CALL_OW 85
// DoNotAttack ( russians , Joan ) ;
8566: LD_EXP 2
8570: PPUSH
8571: LD_EXP 33
8575: PPUSH
8576: CALL_OW 471
// Wait ( 0 0$5 ) ;
8580: LD_INT 175
8582: PPUSH
8583: CALL_OW 67
// SetLives ( Joan , hranice_umirani + 50 ) ;
8587: LD_EXP 33
8591: PPUSH
8592: LD_INT 250
8594: PUSH
8595: LD_INT 50
8597: PLUS
8598: PPUSH
8599: CALL_OW 234
// AddComMoveUnit ( Joan , kdo ) ;
8603: LD_EXP 33
8607: PPUSH
8608: LD_VAR 0 1
8612: PPUSH
8613: CALL_OW 172
// AddComTurnUnit ( Joan , kdo ) ;
8617: LD_EXP 33
8621: PPUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 179
// AddComHold ( Joan ) ;
8631: LD_EXP 33
8635: PPUSH
8636: CALL_OW 200
// ComMoveUnit ( kdo , Joan ) ;
8640: LD_VAR 0 1
8644: PPUSH
8645: LD_EXP 33
8649: PPUSH
8650: CALL_OW 112
// AddComTurnUnit ( kdo , Joan ) ;
8654: LD_VAR 0 1
8658: PPUSH
8659: LD_EXP 33
8663: PPUSH
8664: CALL_OW 179
// AddComHold ( kdo ) ;
8668: LD_VAR 0 1
8672: PPUSH
8673: CALL_OW 200
// mytick := tick + 0 0$15 ;
8677: LD_ADDR_VAR 0 3
8681: PUSH
8682: LD_OWVAR 1
8686: PUSH
8687: LD_INT 525
8689: PLUS
8690: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , kdo ) > 4 and IsOK ( kdo ) do
8691: LD_VAR 0 3
8695: PUSH
8696: LD_OWVAR 1
8700: GREATER
8701: PUSH
8702: LD_EXP 33
8706: PPUSH
8707: LD_VAR 0 1
8711: PPUSH
8712: CALL_OW 296
8716: PUSH
8717: LD_INT 4
8719: GREATER
8720: AND
8721: PUSH
8722: LD_VAR 0 1
8726: PPUSH
8727: CALL_OW 302
8731: AND
8732: IFFALSE 8743
// Wait ( 0 0$1 ) ;
8734: LD_INT 35
8736: PPUSH
8737: CALL_OW 67
8741: GO 8691
// if not IsOK ( kdo ) then
8743: LD_VAR 0 1
8747: PPUSH
8748: CALL_OW 302
8752: NOT
8753: IFFALSE 8862
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8755: LD_ADDR_VAR 0 1
8759: PUSH
8760: LD_INT 26
8762: PUSH
8763: LD_INT 1
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: PUSH
8770: LD_INT 22
8772: PUSH
8773: LD_EXP 1
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 21
8784: PUSH
8785: LD_INT 1
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: LD_INT 3
8794: PUSH
8795: LD_INT 54
8797: PUSH
8798: EMPTY
8799: LIST
8800: PUSH
8801: LD_INT 3
8803: PUSH
8804: LD_INT 55
8806: PUSH
8807: EMPTY
8808: LIST
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: LD_INT 23
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: PUSH
8823: LD_INT 51
8825: PUSH
8826: EMPTY
8827: LIST
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: PPUSH
8841: CALL_OW 69
8845: PUSH
8846: LD_EXP 33
8850: DIFF
8851: PPUSH
8852: LD_EXP 33
8856: PPUSH
8857: CALL_OW 74
8861: ST_TO_ADDR
// InGameOff ;
8862: CALL_OW 9
// if IsLive ( Joan ) and IsLive ( kdo ) then
8866: LD_EXP 33
8870: PPUSH
8871: CALL_OW 300
8875: PUSH
8876: LD_VAR 0 1
8880: PPUSH
8881: CALL_OW 300
8885: AND
8886: IFFALSE 9248
// begin DialogueOn ;
8888: CALL_OW 6
// if kdo = JMM then
8892: LD_VAR 0 1
8896: PUSH
8897: LD_EXP 15
8901: EQUAL
8902: IFFALSE 8978
// begin Say ( kdo , D5b-JMM-1 ) ;
8904: LD_VAR 0 1
8908: PPUSH
8909: LD_STRING D5b-JMM-1
8911: PPUSH
8912: CALL_OW 88
// Say ( Joan , D5b-Joan-1 ) ;
8916: LD_EXP 33
8920: PPUSH
8921: LD_STRING D5b-Joan-1
8923: PPUSH
8924: CALL_OW 88
// Say ( kdo , D5b-JMM-2 ) ;
8928: LD_VAR 0 1
8932: PPUSH
8933: LD_STRING D5b-JMM-2
8935: PPUSH
8936: CALL_OW 88
// Say ( Joan , D5b-Joan-2 ) ;
8940: LD_EXP 33
8944: PPUSH
8945: LD_STRING D5b-Joan-2
8947: PPUSH
8948: CALL_OW 88
// Say ( kdo , D5b-JMM-3 ) ;
8952: LD_VAR 0 1
8956: PPUSH
8957: LD_STRING D5b-JMM-3
8959: PPUSH
8960: CALL_OW 88
// Say ( Joan , D5b-Joan-3 ) ;
8964: LD_EXP 33
8968: PPUSH
8969: LD_STRING D5b-Joan-3
8971: PPUSH
8972: CALL_OW 88
// end else
8976: GO 9248
// begin Say ( kdo , D5a-Sol1-1 ) ;
8978: LD_VAR 0 1
8982: PPUSH
8983: LD_STRING D5a-Sol1-1
8985: PPUSH
8986: CALL_OW 88
// Say ( Joan , D5a-Joan-1 ) ;
8990: LD_EXP 33
8994: PPUSH
8995: LD_STRING D5a-Joan-1
8997: PPUSH
8998: CALL_OW 88
// Say ( kdo , D5a-Sol1-2 ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: LD_STRING D5a-Sol1-2
9009: PPUSH
9010: CALL_OW 88
// Say ( Joan , D5a-Joan-2 ) ;
9014: LD_EXP 33
9018: PPUSH
9019: LD_STRING D5a-Joan-2
9021: PPUSH
9022: CALL_OW 88
// Say ( kdo , D5a-Sol1-3 ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_STRING D5a-Sol1-3
9033: PPUSH
9034: CALL_OW 88
// Say ( Joan , D5a-Joan-3 ) ;
9038: LD_EXP 33
9042: PPUSH
9043: LD_STRING D5a-Joan-3
9045: PPUSH
9046: CALL_OW 88
// Say ( kdo , D5a-Sol1-4 ) ;
9050: LD_VAR 0 1
9054: PPUSH
9055: LD_STRING D5a-Sol1-4
9057: PPUSH
9058: CALL_OW 88
// ComMoveUnit ( [ kdo , Joan ] , JMM ) ;
9062: LD_VAR 0 1
9066: PUSH
9067: LD_EXP 33
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: PPUSH
9076: LD_EXP 15
9080: PPUSH
9081: CALL_OW 112
// AddComHold ( [ kdo , Joan ] ) ;
9085: LD_VAR 0 1
9089: PUSH
9090: LD_EXP 33
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: PPUSH
9099: CALL_OW 200
// DialogueOff ;
9103: CALL_OW 7
// mytick := tick + 0 0$15 ;
9107: LD_ADDR_VAR 0 3
9111: PUSH
9112: LD_OWVAR 1
9116: PUSH
9117: LD_INT 525
9119: PLUS
9120: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , JMM ) > 5 do
9121: LD_VAR 0 3
9125: PUSH
9126: LD_OWVAR 1
9130: GREATER
9131: PUSH
9132: LD_EXP 33
9136: PPUSH
9137: LD_EXP 15
9141: PPUSH
9142: CALL_OW 296
9146: PUSH
9147: LD_INT 5
9149: GREATER
9150: AND
9151: IFFALSE 9162
// Wait ( 0 0$1 ) ;
9153: LD_INT 35
9155: PPUSH
9156: CALL_OW 67
9160: GO 9121
// DialogueOn ;
9162: CALL_OW 6
// if IsLive ( Joan ) and IsLive ( JMM ) then
9166: LD_EXP 33
9170: PPUSH
9171: CALL_OW 300
9175: PUSH
9176: LD_EXP 15
9180: PPUSH
9181: CALL_OW 300
9185: AND
9186: IFFALSE 9248
// begin Say ( Joan , D5a-Joan-4 ) ;
9188: LD_EXP 33
9192: PPUSH
9193: LD_STRING D5a-Joan-4
9195: PPUSH
9196: CALL_OW 88
// Say ( JMM , D5a-JMM-4 ) ;
9200: LD_EXP 15
9204: PPUSH
9205: LD_STRING D5a-JMM-4
9207: PPUSH
9208: CALL_OW 88
// Say ( Joan , D5a-Joan-5 ) ;
9212: LD_EXP 33
9216: PPUSH
9217: LD_STRING D5a-Joan-5
9219: PPUSH
9220: CALL_OW 88
// Say ( JMM , D5a-JMM-5 ) ;
9224: LD_EXP 15
9228: PPUSH
9229: LD_STRING D5a-JMM-5
9231: PPUSH
9232: CALL_OW 88
// Say ( Joan , D5a-Joan-6 ) ;
9236: LD_EXP 33
9240: PPUSH
9241: LD_STRING D5a-Joan-6
9243: PPUSH
9244: CALL_OW 88
// end ; end ; end ; Dialog6 ;
9248: CALL 9257 0 0
// end ;
9252: LD_VAR 0 2
9256: RET
// function Dialog6 ; begin
9257: LD_INT 0
9259: PPUSH
// if IsLive ( Joan ) then
9260: LD_EXP 33
9264: PPUSH
9265: CALL_OW 300
9269: IFFALSE 9419
// begin ComStop ( [ Joan , JMM ] ) ;
9271: LD_EXP 33
9275: PUSH
9276: LD_EXP 15
9280: PUSH
9281: EMPTY
9282: LIST
9283: LIST
9284: PPUSH
9285: CALL_OW 141
// ComTurnUnit ( JMM , Joan ) ;
9289: LD_EXP 15
9293: PPUSH
9294: LD_EXP 33
9298: PPUSH
9299: CALL_OW 119
// ComTurnUnit ( Joan , JMM ) ;
9303: LD_EXP 33
9307: PPUSH
9308: LD_EXP 15
9312: PPUSH
9313: CALL_OW 119
// AddComHold ( [ JMM , Joan ] ) ;
9317: LD_EXP 15
9321: PUSH
9322: LD_EXP 33
9326: PUSH
9327: EMPTY
9328: LIST
9329: LIST
9330: PPUSH
9331: CALL_OW 200
// Say ( JMM , D6-JMM-1 ) ;
9335: LD_EXP 15
9339: PPUSH
9340: LD_STRING D6-JMM-1
9342: PPUSH
9343: CALL_OW 88
// Say ( Joan , D6-Joan-1 ) ;
9347: LD_EXP 33
9351: PPUSH
9352: LD_STRING D6-Joan-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D6-JMM-2
9366: PPUSH
9367: CALL_OW 88
// Say ( Joan , D6-Joan-2 ) ;
9371: LD_EXP 33
9375: PPUSH
9376: LD_STRING D6-Joan-2
9378: PPUSH
9379: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9383: LD_EXP 15
9387: PPUSH
9388: LD_STRING D6-JMM-3
9390: PPUSH
9391: CALL_OW 88
// Say ( Joan , D6-Joan-3 ) ;
9395: LD_EXP 33
9399: PPUSH
9400: LD_STRING D6-Joan-3
9402: PPUSH
9403: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9407: LD_EXP 15
9411: PPUSH
9412: LD_STRING D6-JMM-4
9414: PPUSH
9415: CALL_OW 88
// end ; DialogueOff ;
9419: CALL_OW 7
// ChangeMissionObjectives ( MJ ) ;
9423: LD_STRING MJ
9425: PPUSH
9426: CALL_OW 337
// SetSide ( Joan , you ) ;
9430: LD_EXP 33
9434: PPUSH
9435: LD_EXP 1
9439: PPUSH
9440: CALL_OW 235
// NormalAttack ( russians , Joan ) ;
9444: LD_EXP 2
9448: PPUSH
9449: LD_EXP 33
9453: PPUSH
9454: CALL_OW 472
// if IsLive ( Lisa ) then
9458: LD_EXP 21
9462: PPUSH
9463: CALL_OW 300
9467: IFFALSE 9477
// act_Lisa_JMM := true ;
9469: LD_ADDR_EXP 58
9473: PUSH
9474: LD_INT 1
9476: ST_TO_ADDR
// DialogInProgress := false ;
9477: LD_ADDR_EXP 52
9481: PUSH
9482: LD_INT 0
9484: ST_TO_ADDR
// end ;
9485: LD_VAR 0 1
9489: RET
// every 1 1$0 trigger act_Lisa_JMM do
9490: LD_EXP 58
9494: IFFALSE 9656
9496: GO 9498
9498: DISABLE
// begin Wait ( 3 3$0 ) ;
9499: LD_INT 6300
9501: PPUSH
9502: CALL_OW 67
// if IsLive ( Joan ) and IsLive ( Lisa ) then
9506: LD_EXP 33
9510: PPUSH
9511: CALL_OW 300
9515: PUSH
9516: LD_EXP 21
9520: PPUSH
9521: CALL_OW 300
9525: AND
9526: IFFALSE 9656
// begin DialogueOn ;
9528: CALL_OW 6
// Say ( Lisa , D7-Lisa-1 ) ;
9532: LD_EXP 21
9536: PPUSH
9537: LD_STRING D7-Lisa-1
9539: PPUSH
9540: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
9544: LD_EXP 15
9548: PPUSH
9549: LD_STRING D7-JMM-1
9551: PPUSH
9552: CALL_OW 88
// Say ( Lisa , D7-Lisa-2 ) ;
9556: LD_EXP 21
9560: PPUSH
9561: LD_STRING D7-Lisa-2
9563: PPUSH
9564: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
9568: LD_EXP 15
9572: PPUSH
9573: LD_STRING D7-JMM-2
9575: PPUSH
9576: CALL_OW 88
// Say ( Lisa , D7-Lisa-3 ) ;
9580: LD_EXP 21
9584: PPUSH
9585: LD_STRING D7-Lisa-3
9587: PPUSH
9588: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
9592: LD_EXP 15
9596: PPUSH
9597: LD_STRING D7-JMM-3
9599: PPUSH
9600: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
9604: LD_EXP 21
9608: PPUSH
9609: LD_STRING D7-Lisa-4
9611: PPUSH
9612: CALL_OW 88
// Say ( JMM , D7-JMM-4 ) ;
9616: LD_EXP 15
9620: PPUSH
9621: LD_STRING D7-JMM-4
9623: PPUSH
9624: CALL_OW 88
// Say ( JMM , D7-JMM-4a ) ;
9628: LD_EXP 15
9632: PPUSH
9633: LD_STRING D7-JMM-4a
9635: PPUSH
9636: CALL_OW 88
// Say ( Lisa , D7-Lisa-5 ) ;
9640: LD_EXP 21
9644: PPUSH
9645: LD_STRING D7-Lisa-5
9647: PPUSH
9648: CALL_OW 88
// DialogueOff ;
9652: CALL_OW 7
// end ; end ;
9656: END
// every 0 0$1.0 trigger Joan_P and not IsLive ( Joan ) do
9657: LD_EXP 48
9661: PUSH
9662: LD_EXP 33
9666: PPUSH
9667: CALL_OW 300
9671: NOT
9672: AND
9673: IFFALSE 9685
9675: GO 9677
9677: DISABLE
// begin ChangeMissionObjectives ( MJa ) ;
9678: LD_STRING MJa
9680: PPUSH
9681: CALL_OW 337
// end ;
9685: END
// every 0 0$10.0 trigger not bojujese and IsOk ( Frank ) and UnitFilter ( apemans , [ f_side , you ] ) do var kdo , kdo2 ;
9686: CALL 13459 0 0
9690: NOT
9691: PUSH
9692: LD_EXP 20
9696: PPUSH
9697: CALL_OW 302
9701: AND
9702: PUSH
9703: LD_EXP 5
9707: PPUSH
9708: LD_INT 22
9710: PUSH
9711: LD_EXP 1
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PPUSH
9720: CALL_OW 72
9724: AND
9725: IFFALSE 10029
9727: GO 9729
9729: DISABLE
9730: LD_INT 0
9732: PPUSH
9733: PPUSH
// begin while DialogInProgress do
9734: LD_EXP 52
9738: IFFALSE 9749
// Wait ( 0 0$5 ) ;
9740: LD_INT 175
9742: PPUSH
9743: CALL_OW 67
9747: GO 9734
// kdo := WhoSayAny ( not_char , you , 0 , 0 , 1 ) ;
9749: LD_ADDR_VAR 0 1
9753: PUSH
9754: LD_EXP 11
9758: PPUSH
9759: LD_EXP 1
9763: PPUSH
9764: LD_INT 0
9766: PPUSH
9767: LD_INT 0
9769: PPUSH
9770: LD_INT 1
9772: PPUSH
9773: CALL 17262 0 5
9777: ST_TO_ADDR
// if not kdo then
9778: LD_VAR 0 1
9782: NOT
9783: IFFALSE 9814
// kdo := WhoSayAny ( TvojiLidi , you , 0 , 0 , 1 ) ;
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: CALL 13514 0 0
9794: PPUSH
9795: LD_EXP 1
9799: PPUSH
9800: LD_INT 0
9802: PPUSH
9803: LD_INT 0
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 17262 0 5
9813: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , 0 , 0 , 2 ) ;
9814: LD_ADDR_VAR 0 2
9818: PUSH
9819: LD_EXP 11
9823: PPUSH
9824: LD_EXP 1
9828: PPUSH
9829: LD_INT 0
9831: PPUSH
9832: LD_INT 0
9834: PPUSH
9835: LD_INT 2
9837: PPUSH
9838: CALL 17262 0 5
9842: ST_TO_ADDR
// if not kdo then
9843: LD_VAR 0 1
9847: NOT
9848: IFFALSE 9879
// kdo2 := WhoSayAny ( TvojiLidi , you , 0 , 0 , 2 ) ;
9850: LD_ADDR_VAR 0 2
9854: PUSH
9855: CALL 13514 0 0
9859: PPUSH
9860: LD_EXP 1
9864: PPUSH
9865: LD_INT 0
9867: PPUSH
9868: LD_INT 0
9870: PPUSH
9871: LD_INT 2
9873: PPUSH
9874: CALL 17262 0 5
9878: ST_TO_ADDR
// if IsOk ( Frank ) then
9879: LD_EXP 20
9883: PPUSH
9884: CALL_OW 302
9888: IFFALSE 10029
// begin TalkOn ;
9890: CALL 17150 0 0
// Say ( Frank , D10-Frank-1 ) ;
9894: LD_EXP 20
9898: PPUSH
9899: LD_STRING D10-Frank-1
9901: PPUSH
9902: CALL_OW 88
// if GetSex ( kdo ) = sex_male then
9906: LD_VAR 0 1
9910: PPUSH
9911: CALL_OW 258
9915: PUSH
9916: LD_INT 1
9918: EQUAL
9919: IFFALSE 9935
// Say ( kdo , D10-Sol1-1 ) else
9921: LD_VAR 0 1
9925: PPUSH
9926: LD_STRING D10-Sol1-1
9928: PPUSH
9929: CALL_OW 88
9933: GO 9947
// Say ( kdo , D10-FSol1-1 ) ;
9935: LD_VAR 0 1
9939: PPUSH
9940: LD_STRING D10-FSol1-1
9942: PPUSH
9943: CALL_OW 88
// Say ( Frank , D10-Frank-2 ) ;
9947: LD_EXP 20
9951: PPUSH
9952: LD_STRING D10-Frank-2
9954: PPUSH
9955: CALL_OW 88
// if IsOk ( Lisa ) then
9959: LD_EXP 21
9963: PPUSH
9964: CALL_OW 302
9968: IFFALSE 9984
// Say ( Lisa , D10-Lisa-2 ) else
9970: LD_EXP 21
9974: PPUSH
9975: LD_STRING D10-Lisa-2
9977: PPUSH
9978: CALL_OW 88
9982: GO 10025
// if GetSex ( kdo2 ) = sex_male then
9984: LD_VAR 0 2
9988: PPUSH
9989: CALL_OW 258
9993: PUSH
9994: LD_INT 1
9996: EQUAL
9997: IFFALSE 10013
// Say ( kdo2 , D10-Sol1-2 ) else
9999: LD_VAR 0 2
10003: PPUSH
10004: LD_STRING D10-Sol1-2
10006: PPUSH
10007: CALL_OW 88
10011: GO 10025
// Say ( kdo2 , D10-FSol1-2 ) ;
10013: LD_VAR 0 2
10017: PPUSH
10018: LD_STRING D10-FSol1-2
10020: PPUSH
10021: CALL_OW 88
// TalkOff ;
10025: CALL 17166 0 0
// end ; end ;
10029: PPOPN 2
10031: END
// export function Dialog11aa ( kdo ) ; begin
10032: LD_INT 0
10034: PPUSH
// DialogueOn ;
10035: CALL_OW 6
// Say ( kdo , D11a-Sol2-1 ) ;
10039: LD_VAR 0 1
10043: PPUSH
10044: LD_STRING D11a-Sol2-1
10046: PPUSH
10047: CALL_OW 88
// WasD11aa := true ;
10051: LD_ADDR_EXP 69
10055: PUSH
10056: LD_INT 1
10058: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10059: LD_INT 35
10061: PPUSH
10062: CALL_OW 67
// DialogueOff ;
10066: CALL_OW 7
// end ;
10070: LD_VAR 0 2
10074: RET
// export function Dialog11ab ( kdo ) ; begin
10075: LD_INT 0
10077: PPUSH
// DialogueOn ;
10078: CALL_OW 6
// Say ( kdo , D11a-FSol2-1 ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_STRING D11a-FSol2-1
10089: PPUSH
10090: CALL_OW 88
// WasD11ab := true ;
10094: LD_ADDR_EXP 70
10098: PUSH
10099: LD_INT 1
10101: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10102: LD_INT 35
10104: PPUSH
10105: CALL_OW 67
// DialogueOff ;
10109: CALL_OW 7
// end ;
10113: LD_VAR 0 2
10117: RET
// export function Dialog11b ( kdo ) ; begin
10118: LD_INT 0
10120: PPUSH
// DialogueOn ;
10121: CALL_OW 6
// Say ( kdo , D11b-Sol3-1 ) ;
10125: LD_VAR 0 1
10129: PPUSH
10130: LD_STRING D11b-Sol3-1
10132: PPUSH
10133: CALL_OW 88
// Say ( JMM , D11b-JMM-1 ) ;
10137: LD_EXP 15
10141: PPUSH
10142: LD_STRING D11b-JMM-1
10144: PPUSH
10145: CALL_OW 88
// WasD11b := true ;
10149: LD_ADDR_EXP 71
10153: PUSH
10154: LD_INT 1
10156: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10157: LD_INT 35
10159: PPUSH
10160: CALL_OW 67
// DialogueOff ;
10164: CALL_OW 7
// end ;
10168: LD_VAR 0 2
10172: RET
// export function Dialog11c ( kdo ) ; var dep ; begin
10173: LD_INT 0
10175: PPUSH
10176: PPUSH
// DialogueOn ;
10177: CALL_OW 6
// Say ( kdo , D11c-FSol3-1 ) ;
10181: LD_VAR 0 1
10185: PPUSH
10186: LD_STRING D11c-FSol3-1
10188: PPUSH
10189: CALL_OW 88
// dep := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
10193: LD_ADDR_VAR 0 3
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_EXP 1
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 2
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 30
10225: PUSH
10226: LD_INT 0
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: ST_TO_ADDR
// if dep then
10247: LD_VAR 0 3
10251: IFFALSE 10289
// if GetDistUnits ( kdo , dep [ 1 ] ) > 30 then
10253: LD_VAR 0 1
10257: PPUSH
10258: LD_VAR 0 3
10262: PUSH
10263: LD_INT 1
10265: ARRAY
10266: PPUSH
10267: CALL_OW 296
10271: PUSH
10272: LD_INT 30
10274: GREATER
10275: IFFALSE 10289
// Say ( JMM , D11c-JMM-1 ) ;
10277: LD_EXP 15
10281: PPUSH
10282: LD_STRING D11c-JMM-1
10284: PPUSH
10285: CALL_OW 88
// WasD11c := true ;
10289: LD_ADDR_EXP 72
10293: PUSH
10294: LD_INT 1
10296: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10297: LD_INT 35
10299: PPUSH
10300: CALL_OW 67
// DialogueOff ;
10304: CALL_OW 7
// end ;
10308: LD_VAR 0 2
10312: RET
// export function Dialog11d ( kdo ) ; begin
10313: LD_INT 0
10315: PPUSH
// DialogueOn ;
10316: CALL_OW 6
// Say ( kdo , D11d-Sol4-1 ) ;
10320: LD_VAR 0 1
10324: PPUSH
10325: LD_STRING D11d-Sol4-1
10327: PPUSH
10328: CALL_OW 88
// Say ( JMM , D11d-JMM-1 ) ;
10332: LD_EXP 15
10336: PPUSH
10337: LD_STRING D11d-JMM-1
10339: PPUSH
10340: CALL_OW 88
// WasD11d := true ;
10344: LD_ADDR_EXP 73
10348: PUSH
10349: LD_INT 1
10351: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10352: LD_INT 35
10354: PPUSH
10355: CALL_OW 67
// DialogueOff ;
10359: CALL_OW 7
// end ;
10363: LD_VAR 0 2
10367: RET
// export function Dialog11e ( kdo ) ; begin
10368: LD_INT 0
10370: PPUSH
// DialogueOn ;
10371: CALL_OW 6
// Say ( kdo , D11e-FSol4-1 ) ;
10375: LD_VAR 0 1
10379: PPUSH
10380: LD_STRING D11e-FSol4-1
10382: PPUSH
10383: CALL_OW 88
// WasD11e := true ;
10387: LD_ADDR_EXP 74
10391: PUSH
10392: LD_INT 1
10394: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10395: LD_INT 35
10397: PPUSH
10398: CALL_OW 67
// DialogueOff ;
10402: CALL_OW 7
// end ;
10406: LD_VAR 0 2
10410: RET
// export function Dialog11f ( kdo ) ; begin
10411: LD_INT 0
10413: PPUSH
// DialogueOn ;
10414: CALL_OW 6
// Say ( kdo , D11f-Sol5-1 ) ;
10418: LD_VAR 0 1
10422: PPUSH
10423: LD_STRING D11f-Sol5-1
10425: PPUSH
10426: CALL_OW 88
// WasD11f := true ;
10430: LD_ADDR_EXP 75
10434: PUSH
10435: LD_INT 1
10437: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10438: LD_INT 35
10440: PPUSH
10441: CALL_OW 67
// DialogueOff ;
10445: CALL_OW 7
// end ;
10449: LD_VAR 0 2
10453: RET
// every 0 0$3 trigger FilterAllUnits ( [ [ f_control , control_remote ] ] ) and not FilterAllUnits ( [ [ f_btype , b_control_tower ] ] ) do var a ;
10454: LD_INT 33
10456: PUSH
10457: LD_INT 2
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: PPUSH
10467: CALL_OW 69
10471: PUSH
10472: LD_INT 30
10474: PUSH
10475: LD_INT 36
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: EMPTY
10483: LIST
10484: PPUSH
10485: CALL_OW 69
10489: NOT
10490: AND
10491: IFFALSE 10604
10493: GO 10495
10495: DISABLE
10496: LD_INT 0
10498: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10499: LD_ADDR_VAR 0 1
10503: PUSH
10504: LD_EXP 11
10508: PPUSH
10509: LD_EXP 1
10513: PPUSH
10514: LD_INT 0
10516: PPUSH
10517: LD_INT 3
10519: PPUSH
10520: LD_INT 0
10522: PPUSH
10523: CALL 17262 0 5
10527: ST_TO_ADDR
// TalkOn ;
10528: CALL 17150 0 0
// if a then
10532: LD_VAR 0 1
10536: IFFALSE 10593
// if not SayAny ( a , D3a-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10538: LD_VAR 0 1
10542: PPUSH
10543: LD_STRING D3a-Mech1-1
10545: PPUSH
10546: LD_EXP 1
10550: PPUSH
10551: LD_INT 1
10553: PPUSH
10554: LD_INT 3
10556: PPUSH
10557: LD_INT 0
10559: PPUSH
10560: CALL 17182 0 6
10564: NOT
10565: IFFALSE 10593
// SayAny ( a , D3a-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_STRING D3a-FMech1-1
10574: PPUSH
10575: LD_EXP 1
10579: PPUSH
10580: LD_INT 2
10582: PPUSH
10583: LD_INT 3
10585: PPUSH
10586: LD_INT 0
10588: PPUSH
10589: CALL 17182 0 6
// TalkOff ;
10593: CALL 17166 0 0
// MyHint ( Linking ) ;
10597: LD_STRING Linking
10599: PPUSH
10600: CALL 17625 0 1
// end ;
10604: PPOPN 1
10606: END
// every 0 0$3 trigger not FilterAllUnits ( [ f_control , control_remote ] ) and maj_ct do var a ;
10607: LD_INT 33
10609: PUSH
10610: LD_INT 2
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PPUSH
10617: CALL_OW 69
10621: NOT
10622: PUSH
10623: LD_EXP 95
10627: AND
10628: IFFALSE 10741
10630: GO 10632
10632: DISABLE
10633: LD_INT 0
10635: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_EXP 11
10645: PPUSH
10646: LD_EXP 1
10650: PPUSH
10651: LD_INT 0
10653: PPUSH
10654: LD_INT 3
10656: PPUSH
10657: LD_INT 0
10659: PPUSH
10660: CALL 17262 0 5
10664: ST_TO_ADDR
// TalkOn ;
10665: CALL 17150 0 0
// if a then
10669: LD_VAR 0 1
10673: IFFALSE 10730
// if not SayAny ( a , D3b-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10675: LD_VAR 0 1
10679: PPUSH
10680: LD_STRING D3b-Mech1-1
10682: PPUSH
10683: LD_EXP 1
10687: PPUSH
10688: LD_INT 1
10690: PPUSH
10691: LD_INT 3
10693: PPUSH
10694: LD_INT 0
10696: PPUSH
10697: CALL 17182 0 6
10701: NOT
10702: IFFALSE 10730
// SayAny ( a , D3b-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10704: LD_VAR 0 1
10708: PPUSH
10709: LD_STRING D3b-FMech1-1
10711: PPUSH
10712: LD_EXP 1
10716: PPUSH
10717: LD_INT 2
10719: PPUSH
10720: LD_INT 3
10722: PPUSH
10723: LD_INT 0
10725: PPUSH
10726: CALL 17182 0 6
// TalkOff ;
10730: CALL 17166 0 0
// MyHint ( Linking ) ;
10734: LD_STRING Linking
10736: PPUSH
10737: CALL 17625 0 1
// end ;
10741: PPOPN 1
10743: END
// every 0 0$3 do var who , i ;
10744: GO 10746
10746: DISABLE
10747: LD_INT 0
10749: PPUSH
10750: PPUSH
// begin who := [ ] ;
10751: LD_ADDR_VAR 0 1
10755: PUSH
10756: EMPTY
10757: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_btype , b_control_tower ] ) do
10758: LD_ADDR_VAR 0 2
10762: PUSH
10763: LD_INT 30
10765: PUSH
10766: LD_INT 36
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PPUSH
10773: CALL_OW 69
10777: PUSH
10778: FOR_IN
10779: IFFALSE 10819
// who := who ^ UnitFilter ( UnitsInside ( i ) , [ f_class , class_mechanic ] ) ;
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 1
10790: PUSH
10791: LD_VAR 0 2
10795: PPUSH
10796: CALL_OW 313
10800: PPUSH
10801: LD_INT 25
10803: PUSH
10804: LD_INT 3
10806: PUSH
10807: EMPTY
10808: LIST
10809: LIST
10810: PPUSH
10811: CALL_OW 72
10815: ADD
10816: ST_TO_ADDR
10817: GO 10778
10819: POP
10820: POP
// if FilterAllUnits ( [ f_control , control_remote ] ) and who then
10821: LD_INT 33
10823: PUSH
10824: LD_INT 2
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PPUSH
10831: CALL_OW 69
10835: PUSH
10836: LD_VAR 0 1
10840: AND
10841: IFFALSE 10953
// begin TalkOn ;
10843: CALL 17150 0 0
// who := who [ 1 ] ;
10847: LD_ADDR_VAR 0 1
10851: PUSH
10852: LD_VAR 0 1
10856: PUSH
10857: LD_INT 1
10859: ARRAY
10860: ST_TO_ADDR
// if JMM in who then
10861: LD_EXP 15
10865: PUSH
10866: LD_VAR 0 1
10870: IN
10871: IFFALSE 10887
// Say ( JMM , D4a-JMM-1 ) else
10873: LD_EXP 15
10877: PPUSH
10878: LD_STRING D4a-JMM-1
10880: PPUSH
10881: CALL_OW 88
10885: GO 10932
// begin if GetSex ( who [ 1 ] ) = sex_male then
10887: LD_VAR 0 1
10891: PUSH
10892: LD_INT 1
10894: ARRAY
10895: PPUSH
10896: CALL_OW 258
10900: PUSH
10901: LD_INT 1
10903: EQUAL
10904: IFFALSE 10920
// Say ( who , D4a-Mech1-1 ) else
10906: LD_VAR 0 1
10910: PPUSH
10911: LD_STRING D4a-Mech1-1
10913: PPUSH
10914: CALL_OW 88
10918: GO 10932
// Say ( who , D4a-FMech1-1 ) ;
10920: LD_VAR 0 1
10924: PPUSH
10925: LD_STRING D4a-FMech1-1
10927: PPUSH
10928: CALL_OW 88
// end ; remote_tried := true ;
10932: LD_ADDR_EXP 82
10936: PUSH
10937: LD_INT 1
10939: ST_TO_ADDR
// TalkOff ;
10940: CALL 17166 0 0
// MyHint ( Linking ) ;
10944: LD_STRING Linking
10946: PPUSH
10947: CALL 17625 0 1
// end else
10951: GO 10954
// enable ;
10953: ENABLE
// end ;
10954: PPOPN 2
10956: END
// every 0 0$3 do var who , facts , rems , ok , i , j ;
10957: GO 10959
10959: DISABLE
10960: LD_INT 0
10962: PPUSH
10963: PPUSH
10964: PPUSH
10965: PPUSH
10966: PPUSH
10967: PPUSH
// begin who := [ ] ;
10968: LD_ADDR_VAR 0 1
10972: PUSH
10973: EMPTY
10974: ST_TO_ADDR
// facts := FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_factory ] ] ) ;
10975: LD_ADDR_VAR 0 2
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_EXP 1
10987: PUSH
10988: EMPTY
10989: LIST
10990: LIST
10991: PUSH
10992: LD_INT 30
10994: PUSH
10995: LD_INT 3
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PPUSH
11006: CALL_OW 69
11010: ST_TO_ADDR
// rems := FilterAllUnits ( [ f_control , control_remote ] ) ;
11011: LD_ADDR_VAR 0 3
11015: PUSH
11016: LD_INT 33
11018: PUSH
11019: LD_INT 2
11021: PUSH
11022: EMPTY
11023: LIST
11024: LIST
11025: PPUSH
11026: CALL_OW 69
11030: ST_TO_ADDR
// for i in facts do
11031: LD_ADDR_VAR 0 5
11035: PUSH
11036: LD_VAR 0 2
11040: PUSH
11041: FOR_IN
11042: IFFALSE 11093
// for j in rems do
11044: LD_ADDR_VAR 0 6
11048: PUSH
11049: LD_VAR 0 3
11053: PUSH
11054: FOR_IN
11055: IFFALSE 11089
// if GetDistUnits ( i , j ) > 9 then
11057: LD_VAR 0 5
11061: PPUSH
11062: LD_VAR 0 6
11066: PPUSH
11067: CALL_OW 296
11071: PUSH
11072: LD_INT 9
11074: GREATER
11075: IFFALSE 11087
// ok := j ;
11077: LD_ADDR_VAR 0 4
11081: PUSH
11082: LD_VAR 0 6
11086: ST_TO_ADDR
11087: GO 11054
11089: POP
11090: POP
11091: GO 11041
11093: POP
11094: POP
// if ok then
11095: LD_VAR 0 4
11099: IFFALSE 11204
// begin TalkOn ;
11101: CALL 17150 0 0
// who := IsControledBy ( ok ) ;
11105: LD_ADDR_VAR 0 1
11109: PUSH
11110: LD_VAR 0 4
11114: PPUSH
11115: CALL_OW 312
11119: ST_TO_ADDR
// if JMM in who then
11120: LD_EXP 15
11124: PUSH
11125: LD_VAR 0 1
11129: IN
11130: IFFALSE 11146
// Say ( JMM , D4b-JMM-1 ) else
11132: LD_EXP 15
11136: PPUSH
11137: LD_STRING D4b-JMM-1
11139: PPUSH
11140: CALL_OW 88
11144: GO 11191
// begin if GetSex ( who [ 1 ] ) = sex_male then
11146: LD_VAR 0 1
11150: PUSH
11151: LD_INT 1
11153: ARRAY
11154: PPUSH
11155: CALL_OW 258
11159: PUSH
11160: LD_INT 1
11162: EQUAL
11163: IFFALSE 11179
// Say ( who , D4b-Mech1-1 ) else
11165: LD_VAR 0 1
11169: PPUSH
11170: LD_STRING D4b-Mech1-1
11172: PPUSH
11173: CALL_OW 88
11177: GO 11191
// Say ( who , D4b-FMech1-1 ) ;
11179: LD_VAR 0 1
11183: PPUSH
11184: LD_STRING D4b-FMech1-1
11186: PPUSH
11187: CALL_OW 88
// end ; TalkOff ;
11191: CALL 17166 0 0
// MyHint ( RemoteControlling ) ;
11195: LD_STRING RemoteControlling
11197: PPUSH
11198: CALL 17625 0 1
// end else
11202: GO 11205
// enable ;
11204: ENABLE
// end ;
11205: PPOPN 6
11207: END
// every 4 4$30 do
11208: GO 11210
11210: DISABLE
// begin TalkOn ;
11211: CALL 17150 0 0
// SayRadio ( RadioSci , D12a-Sci-1 ) ;
11215: LD_EXP 17
11219: PPUSH
11220: LD_STRING D12a-Sci-1
11222: PPUSH
11223: CALL_OW 94
// Say ( JMM , D12a-JMM-1 ) ;
11227: LD_EXP 15
11231: PPUSH
11232: LD_STRING D12a-JMM-1
11234: PPUSH
11235: CALL_OW 88
// TalkOff ;
11239: CALL 17166 0 0
// end ;
11243: END
// every 14 14$0 do
11244: GO 11246
11246: DISABLE
// begin TalkOn ;
11247: CALL 17150 0 0
// SayRadio ( RadioSci , D12b-Sci-1 ) ;
11251: LD_EXP 17
11255: PPUSH
11256: LD_STRING D12b-Sci-1
11258: PPUSH
11259: CALL_OW 94
// TalkOff ;
11263: CALL 17166 0 0
// end ;
11267: END
// every 16 16$0 do
11268: GO 11270
11270: DISABLE
// begin TalkOn ;
11271: CALL 17150 0 0
// SayRadio ( RadioSci , D12c-Sci-1 ) ;
11275: LD_EXP 17
11279: PPUSH
11280: LD_STRING D12c-Sci-1
11282: PPUSH
11283: CALL_OW 94
// TalkOff ;
11287: CALL 17166 0 0
// end ;
11291: END
// every 34 34$0 do
11292: GO 11294
11294: DISABLE
// begin TalkOn ;
11295: CALL 17150 0 0
// SayRadio ( RadioSci , D12d-Sci-1 ) ;
11299: LD_EXP 17
11303: PPUSH
11304: LD_STRING D12d-Sci-1
11306: PPUSH
11307: CALL_OW 94
// TalkOff ;
11311: CALL 17166 0 0
// end ;
11315: END
// every 46 46$0 do
11316: GO 11318
11318: DISABLE
// begin TalkOn ;
11319: CALL 17150 0 0
// SayRadio ( RadioSci , D12e-Sci-1 ) ;
11323: LD_EXP 17
11327: PPUSH
11328: LD_STRING D12e-Sci-1
11330: PPUSH
11331: CALL_OW 94
// Say ( JMM , D12e-JMM-1 ) ;
11335: LD_EXP 15
11339: PPUSH
11340: LD_STRING D12e-JMM-1
11342: PPUSH
11343: CALL_OW 88
// TalkOff ;
11347: CALL 17166 0 0
// end ;
11351: END
// on DestinationUnreachable ( unit ) do begin if unit = Kurt then
11352: LD_VAR 0 1
11356: PUSH
11357: LD_EXP 43
11361: EQUAL
11362: IFFALSE 11376
// begin ComMoveToArea ( Kurt , border ) ;
11364: LD_EXP 43
11368: PPUSH
11369: LD_INT 10
11371: PPUSH
11372: CALL_OW 113
// end ; end ; end_of_file
11376: PPOPN 1
11378: END
// var objevovani_zasilek ; every 0 0$0.1 do
11379: GO 11381
11381: DISABLE
// begin objevovani_zasilek := [ [ 4 , 3 , 7 , 2 , 0 , 2 , 5 , 3 , 1 , 1 ] , [ 4 , 4 , 8 , 2 , 0 , 2 , 5 , 4 , 2 , 1 ] , [ 4 , 3 , 8 , 1 , 0 , 2 , 6 , 5 , 3 , 1 ] ] [ difficulty ] ;
11382: LD_ADDR_LOC 1
11386: PUSH
11387: LD_INT 4
11389: PUSH
11390: LD_INT 3
11392: PUSH
11393: LD_INT 7
11395: PUSH
11396: LD_INT 2
11398: PUSH
11399: LD_INT 0
11401: PUSH
11402: LD_INT 2
11404: PUSH
11405: LD_INT 5
11407: PUSH
11408: LD_INT 3
11410: PUSH
11411: LD_INT 1
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: PUSH
11429: LD_INT 4
11431: PUSH
11432: LD_INT 4
11434: PUSH
11435: LD_INT 8
11437: PUSH
11438: LD_INT 2
11440: PUSH
11441: LD_INT 0
11443: PUSH
11444: LD_INT 2
11446: PUSH
11447: LD_INT 5
11449: PUSH
11450: LD_INT 4
11452: PUSH
11453: LD_INT 2
11455: PUSH
11456: LD_INT 1
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: LIST
11466: LIST
11467: LIST
11468: LIST
11469: LIST
11470: PUSH
11471: LD_INT 4
11473: PUSH
11474: LD_INT 3
11476: PUSH
11477: LD_INT 8
11479: PUSH
11480: LD_INT 1
11482: PUSH
11483: LD_INT 0
11485: PUSH
11486: LD_INT 2
11488: PUSH
11489: LD_INT 6
11491: PUSH
11492: LD_INT 5
11494: PUSH
11495: LD_INT 3
11497: PUSH
11498: LD_INT 1
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: LIST
11517: PUSH
11518: LD_OWVAR 67
11522: ARRAY
11523: ST_TO_ADDR
// Randomize ;
11524: CALL_OW 10
// end ;
11528: END
// every 0 0$10 do
11529: GO 11531
11531: DISABLE
// begin Randomize ;
11532: CALL_OW 10
// enable ;
11536: ENABLE
// end ;
11537: END
// every 0 0$1 trigger start_game do
11538: LD_EXP 55
11542: IFFALSE 11586
11544: GO 11546
11546: DISABLE
// begin Wait ( Rand ( 0 0$10 , 0 0$25 ) ) ;
11547: LD_INT 350
11549: PPUSH
11550: LD_INT 875
11552: PPUSH
11553: CALL_OW 12
11557: PPUSH
11558: CALL_OW 67
// CreateCratesArea ( 5 , first_crate , true ) ;
11562: LD_INT 5
11564: PPUSH
11565: LD_INT 3
11567: PPUSH
11568: LD_INT 1
11570: PPUSH
11571: CALL_OW 55
// wait ( 0 0$5 ) ;
11575: LD_INT 175
11577: PPUSH
11578: CALL_OW 67
// DialogR0 ;
11582: CALL 5889 0 0
// end ;
11586: END
// every 0 0$15 do
11587: GO 11589
11589: DISABLE
// begin bum_bedny ;
11590: CALL 11604 0 0
// end ;
11594: END
// every 5 5$0 + 0 0$20 marked 567 do
11595: GO 11597
11597: DISABLE
// begin enable ;
11598: ENABLE
// bum_bedny ;
11599: CALL 11604 0 0
// end ;
11603: END
// function bum_bedny ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
11604: LD_INT 0
11606: PPUSH
11607: PPUSH
11608: PPUSH
11609: PPUSH
11610: PPUSH
11611: PPUSH
11612: PPUSH
11613: PPUSH
11614: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
11615: LD_ADDR_VAR 0 9
11619: PUSH
11620: LD_OWVAR 1
11624: PUSH
11625: LD_INT 10500
11627: DIV
11628: PUSH
11629: LD_INT 1
11631: PLUS
11632: ST_TO_ADDR
// cek := [ ] ;
11633: LD_ADDR_VAR 0 6
11637: PUSH
11638: EMPTY
11639: ST_TO_ADDR
// cek2 := [ ] ;
11640: LD_ADDR_VAR 0 7
11644: PUSH
11645: EMPTY
11646: ST_TO_ADDR
// last := 0 ;
11647: LD_ADDR_VAR 0 8
11651: PUSH
11652: LD_INT 0
11654: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
11655: LD_ADDR_VAR 0 2
11659: PUSH
11660: LD_LOC 1
11664: PUSH
11665: LD_VAR 0 9
11669: ARRAY
11670: ST_TO_ADDR
// for i := 1 to x * 2 do
11671: LD_ADDR_VAR 0 4
11675: PUSH
11676: DOUBLE
11677: LD_INT 1
11679: DEC
11680: ST_TO_ADDR
11681: LD_VAR 0 2
11685: PUSH
11686: LD_INT 2
11688: MUL
11689: PUSH
11690: FOR_TO
11691: IFFALSE 11717
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
11693: LD_ADDR_VAR 0 6
11697: PUSH
11698: LD_VAR 0 6
11702: PUSH
11703: LD_INT 525
11705: PPUSH
11706: LD_INT 10500
11708: PPUSH
11709: CALL_OW 12
11713: ADD
11714: ST_TO_ADDR
11715: GO 11690
11717: POP
11718: POP
// cek := SortListByListAsc ( cek , cek ) ;
11719: LD_ADDR_VAR 0 6
11723: PUSH
11724: LD_VAR 0 6
11728: PPUSH
11729: LD_VAR 0 6
11733: PPUSH
11734: CALL_OW 76
11738: ST_TO_ADDR
// for i in cek do
11739: LD_ADDR_VAR 0 4
11743: PUSH
11744: LD_VAR 0 6
11748: PUSH
11749: FOR_IN
11750: IFFALSE 11786
// begin cek2 := cek2 ^ i - last ;
11752: LD_ADDR_VAR 0 7
11756: PUSH
11757: LD_VAR 0 7
11761: PUSH
11762: LD_VAR 0 4
11766: PUSH
11767: LD_VAR 0 8
11771: MINUS
11772: ADD
11773: ST_TO_ADDR
// last := i ;
11774: LD_ADDR_VAR 0 8
11778: PUSH
11779: LD_VAR 0 4
11783: ST_TO_ADDR
// end ;
11784: GO 11749
11786: POP
11787: POP
// for i := 1 to x do
11788: LD_ADDR_VAR 0 4
11792: PUSH
11793: DOUBLE
11794: LD_INT 1
11796: DEC
11797: ST_TO_ADDR
11798: LD_VAR 0 2
11802: PUSH
11803: FOR_TO
11804: IFFALSE 12033
// begin hex := RandHexArea ( bottom_bigger , false ) ;
11806: LD_ADDR_VAR 0 5
11810: PUSH
11811: LD_INT 8
11813: PPUSH
11814: LD_INT 0
11816: PPUSH
11817: CALL_OW 16
11821: ST_TO_ADDR
// crates := crates ^ [ hex ] ;
11822: LD_ADDR_EXP 76
11826: PUSH
11827: LD_EXP 76
11831: PUSH
11832: LD_VAR 0 5
11836: PUSH
11837: EMPTY
11838: LIST
11839: ADD
11840: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11841: LD_INT 5
11843: PPUSH
11844: LD_VAR 0 5
11848: PUSH
11849: LD_INT 1
11851: ARRAY
11852: PPUSH
11853: LD_VAR 0 5
11857: PUSH
11858: LD_INT 2
11860: ARRAY
11861: PPUSH
11862: LD_INT 1
11864: PPUSH
11865: CALL_OW 54
// Wait ( cek2 [ i * 2 - 1 ] ) ;
11869: LD_VAR 0 7
11873: PUSH
11874: LD_VAR 0 4
11878: PUSH
11879: LD_INT 2
11881: MUL
11882: PUSH
11883: LD_INT 1
11885: MINUS
11886: ARRAY
11887: PPUSH
11888: CALL_OW 67
// hex := RandHexArea ( top_bigger , false ) ;
11892: LD_ADDR_VAR 0 5
11896: PUSH
11897: LD_INT 7
11899: PPUSH
11900: LD_INT 0
11902: PPUSH
11903: CALL_OW 16
11907: ST_TO_ADDR
// if more_scouting then
11908: LD_EXP 61
11912: IFFALSE 11933
// crates := crates ^ [ hex ] ;
11914: LD_ADDR_EXP 76
11918: PUSH
11919: LD_EXP 76
11923: PUSH
11924: LD_VAR 0 5
11928: PUSH
11929: EMPTY
11930: LIST
11931: ADD
11932: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11933: LD_INT 5
11935: PPUSH
11936: LD_VAR 0 5
11940: PUSH
11941: LD_INT 1
11943: ARRAY
11944: PPUSH
11945: LD_VAR 0 5
11949: PUSH
11950: LD_INT 2
11952: ARRAY
11953: PPUSH
11954: LD_INT 1
11956: PPUSH
11957: CALL_OW 54
// if not was_dialogR0 and GetDistUnitXY ( JMM , hex [ 1 ] , hex [ 2 ] ) > 30 then
11961: LD_EXP 88
11965: NOT
11966: PUSH
11967: LD_EXP 15
11971: PPUSH
11972: LD_VAR 0 5
11976: PUSH
11977: LD_INT 1
11979: ARRAY
11980: PPUSH
11981: LD_VAR 0 5
11985: PUSH
11986: LD_INT 2
11988: ARRAY
11989: PPUSH
11990: CALL_OW 297
11994: PUSH
11995: LD_INT 30
11997: GREATER
11998: AND
11999: IFFALSE 12012
// begin wait ( 0 0$6 ) ;
12001: LD_INT 210
12003: PPUSH
12004: CALL_OW 67
// DialogR0 ;
12008: CALL 5889 0 0
// end ; Wait ( cek2 [ i * 2 ] ) ;
12012: LD_VAR 0 7
12016: PUSH
12017: LD_VAR 0 4
12021: PUSH
12022: LD_INT 2
12024: MUL
12025: ARRAY
12026: PPUSH
12027: CALL_OW 67
// end ;
12031: GO 11803
12033: POP
12034: POP
// if min5 = ( objevovani_zasilek + 0 ) then
12035: LD_VAR 0 9
12039: PUSH
12040: LD_LOC 1
12044: PUSH
12045: LD_INT 0
12047: PLUS
12048: EQUAL
12049: IFFALSE 12054
// disable ( 567 ) ;
12051: LD_INT 567
12053: DISABLE_MARKED
// end ;
12054: LD_VAR 0 1
12058: RET
// every 5 5$0 + 5 5$20 trigger start_game do var a , un , counter , h ;
12059: LD_EXP 55
12063: IFFALSE 12874
12065: GO 12067
12067: DISABLE
12068: LD_INT 0
12070: PPUSH
12071: PPUSH
12072: PPUSH
12073: PPUSH
// begin a := prilet_rusaci union prilet_tvoji ;
12074: LD_ADDR_VAR 0 1
12078: PUSH
12079: LD_EXP 7
12083: PUSH
12084: LD_EXP 6
12088: UNION
12089: ST_TO_ADDR
// if a then
12090: LD_VAR 0 1
12094: IFFALSE 12874
// begin un := a [ Rand ( 1 , ( a + 0 ) ) ] ;
12096: LD_ADDR_VAR 0 2
12100: PUSH
12101: LD_VAR 0 1
12105: PUSH
12106: LD_INT 1
12108: PPUSH
12109: LD_VAR 0 1
12113: PUSH
12114: LD_INT 0
12116: PLUS
12117: PPUSH
12118: CALL_OW 12
12122: ARRAY
12123: ST_TO_ADDR
// if prilet_tvoji = 2 and Getside ( un ) = you then
12124: LD_EXP 6
12128: PUSH
12129: LD_INT 2
12131: EQUAL
12132: PUSH
12133: LD_VAR 0 2
12137: PPUSH
12138: CALL_OW 255
12142: PUSH
12143: LD_EXP 1
12147: EQUAL
12148: AND
12149: IFFALSE 12168
// begin PlaceUnitArea ( un , lidi_base , true ) ;
12151: LD_VAR 0 2
12155: PPUSH
12156: LD_INT 15
12158: PPUSH
12159: LD_INT 1
12161: PPUSH
12162: CALL_OW 49
// end else
12166: GO 12496
// begin if Rand ( 1 , 2 ) = 1 then
12168: LD_INT 1
12170: PPUSH
12171: LD_INT 2
12173: PPUSH
12174: CALL_OW 12
12178: PUSH
12179: LD_INT 1
12181: EQUAL
12182: IFFALSE 12341
// begin counter := 0 ;
12184: LD_ADDR_VAR 0 3
12188: PUSH
12189: LD_INT 0
12191: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_bottom , false ) ;
12192: LD_ADDR_VAR 0 4
12196: PUSH
12197: LD_INT 14
12199: PPUSH
12200: LD_INT 0
12202: PPUSH
12203: CALL_OW 16
12207: ST_TO_ADDR
// counter := counter + 1 ;
12208: LD_ADDR_VAR 0 3
12212: PUSH
12213: LD_VAR 0 3
12217: PUSH
12218: LD_INT 1
12220: PLUS
12221: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12222: LD_VAR 0 2
12226: PPUSH
12227: CALL_OW 255
12231: PUSH
12232: LD_EXP 2
12236: EQUAL
12237: PUSH
12238: LD_VAR 0 3
12242: PUSH
12243: LD_INT 200
12245: GREATER
12246: OR
12247: PUSH
12248: LD_EXP 2
12252: PPUSH
12253: LD_VAR 0 4
12257: PUSH
12258: LD_INT 1
12260: ARRAY
12261: PPUSH
12262: LD_VAR 0 4
12266: PUSH
12267: LD_INT 2
12269: ARRAY
12270: PPUSH
12271: CALL_OW 293
12275: NOT
12276: OR
12277: IFFALSE 12192
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12279: LD_VAR 0 2
12283: PPUSH
12284: LD_VAR 0 4
12288: PUSH
12289: LD_INT 1
12291: ARRAY
12292: PPUSH
12293: LD_VAR 0 4
12297: PUSH
12298: LD_INT 2
12300: ARRAY
12301: PPUSH
12302: LD_INT 1
12304: PPUSH
12305: CALL_OW 48
12309: PUSH
12310: LD_VAR 0 3
12314: PUSH
12315: LD_INT 200
12317: GREATER
12318: OR
12319: IFFALSE 12192
// if counter > 200 then
12321: LD_VAR 0 3
12325: PUSH
12326: LD_INT 200
12328: GREATER
12329: IFFALSE 12339
// un := 0 ;
12331: LD_ADDR_VAR 0 2
12335: PUSH
12336: LD_INT 0
12338: ST_TO_ADDR
// end else
12339: GO 12496
// begin counter := 0 ;
12341: LD_ADDR_VAR 0 3
12345: PUSH
12346: LD_INT 0
12348: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_top , false ) ;
12349: LD_ADDR_VAR 0 4
12353: PUSH
12354: LD_INT 17
12356: PPUSH
12357: LD_INT 0
12359: PPUSH
12360: CALL_OW 16
12364: ST_TO_ADDR
// counter := counter + 1 ;
12365: LD_ADDR_VAR 0 3
12369: PUSH
12370: LD_VAR 0 3
12374: PUSH
12375: LD_INT 1
12377: PLUS
12378: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12379: LD_VAR 0 2
12383: PPUSH
12384: CALL_OW 255
12388: PUSH
12389: LD_EXP 2
12393: EQUAL
12394: PUSH
12395: LD_VAR 0 3
12399: PUSH
12400: LD_INT 200
12402: GREATER
12403: OR
12404: PUSH
12405: LD_EXP 2
12409: PPUSH
12410: LD_VAR 0 4
12414: PUSH
12415: LD_INT 1
12417: ARRAY
12418: PPUSH
12419: LD_VAR 0 4
12423: PUSH
12424: LD_INT 2
12426: ARRAY
12427: PPUSH
12428: CALL_OW 293
12432: NOT
12433: OR
12434: IFFALSE 12349
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 4
12445: PUSH
12446: LD_INT 1
12448: ARRAY
12449: PPUSH
12450: LD_VAR 0 4
12454: PUSH
12455: LD_INT 2
12457: ARRAY
12458: PPUSH
12459: LD_INT 1
12461: PPUSH
12462: CALL_OW 48
12466: PUSH
12467: LD_VAR 0 3
12471: PUSH
12472: LD_INT 200
12474: GREATER
12475: OR
12476: IFFALSE 12349
// if counter > 200 then
12478: LD_VAR 0 3
12482: PUSH
12483: LD_INT 200
12485: GREATER
12486: IFFALSE 12496
// un := 0 ;
12488: LD_ADDR_VAR 0 2
12492: PUSH
12493: LD_INT 0
12495: ST_TO_ADDR
// end ; end ; Wait ( 0 0$4 ) ;
12496: LD_INT 140
12498: PPUSH
12499: CALL_OW 67
// if un in prilet_rusaci then
12503: LD_VAR 0 2
12507: PUSH
12508: LD_EXP 7
12512: IN
12513: IFFALSE 12677
// begin prilet_rusaci := prilet_rusaci diff un ;
12515: LD_ADDR_EXP 7
12519: PUSH
12520: LD_EXP 7
12524: PUSH
12525: LD_VAR 0 2
12529: DIFF
12530: ST_TO_ADDR
// ComWait ( un , 0 0$3 ) ;
12531: LD_VAR 0 2
12535: PPUSH
12536: LD_INT 105
12538: PPUSH
12539: CALL_OW 142
// AddComMoveXY ( un , 122 , 84 ) ;
12543: LD_VAR 0 2
12547: PPUSH
12548: LD_INT 122
12550: PPUSH
12551: LD_INT 84
12553: PPUSH
12554: CALL_OW 171
// case GetClass ( un ) of class_soldier :
12558: LD_VAR 0 2
12562: PPUSH
12563: CALL_OW 257
12567: PUSH
12568: LD_INT 1
12570: DOUBLE
12571: EQUAL
12572: IFTRUE 12576
12574: GO 12595
12576: POP
// sol := sol ^ un ; class_engineer :
12577: LD_ADDR_EXP 91
12581: PUSH
12582: LD_EXP 91
12586: PUSH
12587: LD_VAR 0 2
12591: ADD
12592: ST_TO_ADDR
12593: GO 12677
12595: LD_INT 2
12597: DOUBLE
12598: EQUAL
12599: IFTRUE 12603
12601: GO 12622
12603: POP
// eng := eng ^ un ; class_scientistic :
12604: LD_ADDR_EXP 94
12608: PUSH
12609: LD_EXP 94
12613: PUSH
12614: LD_VAR 0 2
12618: ADD
12619: ST_TO_ADDR
12620: GO 12677
12622: LD_INT 4
12624: DOUBLE
12625: EQUAL
12626: IFTRUE 12630
12628: GO 12649
12630: POP
// sci := sci ^ un ; class_mechanic :
12631: LD_ADDR_EXP 92
12635: PUSH
12636: LD_EXP 92
12640: PUSH
12641: LD_VAR 0 2
12645: ADD
12646: ST_TO_ADDR
12647: GO 12677
12649: LD_INT 3
12651: DOUBLE
12652: EQUAL
12653: IFTRUE 12657
12655: GO 12676
12657: POP
// mec := mec ^ un ; end ;
12658: LD_ADDR_EXP 93
12662: PUSH
12663: LD_EXP 93
12667: PUSH
12668: LD_VAR 0 2
12672: ADD
12673: ST_TO_ADDR
12674: GO 12677
12676: POP
// end ; if un in prilet_tvoji then
12677: LD_VAR 0 2
12681: PUSH
12682: LD_EXP 6
12686: IN
12687: IFFALSE 12873
// begin prilet_tvoji := prilet_tvoji diff un ;
12689: LD_ADDR_EXP 6
12693: PUSH
12694: LD_EXP 6
12698: PUSH
12699: LD_VAR 0 2
12703: DIFF
12704: ST_TO_ADDR
// if IsInArea ( un , base ) then
12705: LD_VAR 0 2
12709: PPUSH
12710: LD_INT 5
12712: PPUSH
12713: CALL_OW 308
12717: IFFALSE 12770
// begin if GetSex ( un ) = sex_male then
12719: LD_VAR 0 2
12723: PPUSH
12724: CALL_OW 258
12728: PUSH
12729: LD_INT 1
12731: EQUAL
12732: IFFALSE 12768
// if not WasD11aa then
12734: LD_EXP 69
12738: NOT
12739: IFFALSE 12752
// Dialog11aa ( un ) else
12741: LD_VAR 0 2
12745: PPUSH
12746: CALL 10032 0 1
12750: GO 12768
// if not WasD11ab then
12752: LD_EXP 70
12756: NOT
12757: IFFALSE 12768
// Dialog11ab ( un ) ;
12759: LD_VAR 0 2
12763: PPUSH
12764: CALL 10075 0 1
// end else
12768: GO 12873
// begin if GetSex ( un ) = sex_female then
12770: LD_VAR 0 2
12774: PPUSH
12775: CALL_OW 258
12779: PUSH
12780: LD_INT 2
12782: EQUAL
12783: IFFALSE 12821
// begin if not WasD11c then
12785: LD_EXP 72
12789: NOT
12790: IFFALSE 12803
// Dialog11c ( un ) else
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 10173 0 1
12801: GO 12819
// if not WasD11e then
12803: LD_EXP 74
12807: NOT
12808: IFFALSE 12819
// Dialog11e ( un ) ;
12810: LD_VAR 0 2
12814: PPUSH
12815: CALL 10368 0 1
// end else
12819: GO 12873
// begin if not WasD11b then
12821: LD_EXP 71
12825: NOT
12826: IFFALSE 12839
// Dialog11b ( un ) else
12828: LD_VAR 0 2
12832: PPUSH
12833: CALL 10118 0 1
12837: GO 12873
// if not WasD11d then
12839: LD_EXP 73
12843: NOT
12844: IFFALSE 12857
// Dialog11d ( un ) else
12846: LD_VAR 0 2
12850: PPUSH
12851: CALL 10313 0 1
12855: GO 12873
// if not WasD11f then
12857: LD_EXP 75
12861: NOT
12862: IFFALSE 12873
// Dialog11f ( un ) ;
12864: LD_VAR 0 2
12868: PPUSH
12869: CALL 10411 0 1
// end ; end ; end ; enable ;
12873: ENABLE
// end ; end ;
12874: PPOPN 4
12876: END
// every 10 10$0 + 2 2$30 trigger start_game do var a4 , b4 , b5 , c4 , d4 , ia4 , max4 , h ;
12877: LD_EXP 55
12881: IFFALSE 13433
12883: GO 12885
12885: DISABLE
12886: LD_INT 0
12888: PPUSH
12889: PPUSH
12890: PPUSH
12891: PPUSH
12892: PPUSH
12893: PPUSH
12894: PPUSH
12895: PPUSH
// begin ne_v_boji ;
12896: CALL 13436 0 0
// repeat wait ( 0 0$3 ) ;
12900: LD_INT 105
12902: PPUSH
12903: CALL_OW 67
// b4 := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Joan ] ;
12907: LD_ADDR_VAR 0 2
12911: PUSH
12912: LD_INT 22
12914: PUSH
12915: LD_EXP 1
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 23
12926: PUSH
12927: LD_INT 1
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 21
12936: PUSH
12937: LD_INT 1
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 50
12946: PUSH
12947: EMPTY
12948: LIST
12949: PUSH
12950: LD_INT 56
12952: PUSH
12953: EMPTY
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PPUSH
12963: CALL_OW 69
12967: PUSH
12968: LD_EXP 15
12972: PUSH
12973: LD_EXP 33
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: DIFF
12982: ST_TO_ADDR
// until b4 and not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , [ f_occupied ] ] , [ f_dist , JMM , 40 ] ] ) ;
12983: LD_VAR 0 2
12987: PUSH
12988: LD_INT 22
12990: PUSH
12991: LD_EXP 2
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 2
13002: PUSH
13003: LD_INT 21
13005: PUSH
13006: LD_INT 1
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 21
13015: PUSH
13016: LD_INT 2
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 21
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 59
13035: PUSH
13036: EMPTY
13037: LIST
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PUSH
13046: LD_INT 91
13048: PUSH
13049: LD_EXP 15
13053: PUSH
13054: LD_INT 40
13056: PUSH
13057: EMPTY
13058: LIST
13059: LIST
13060: LIST
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: LIST
13066: PPUSH
13067: CALL_OW 69
13071: NOT
13072: AND
13073: IFFALSE 12900
// max4 := 1000 ;
13075: LD_ADDR_VAR 0 7
13079: PUSH
13080: LD_INT 1000
13082: ST_TO_ADDR
// if Rand ( 1 , 5 ) <= 4 then
13083: LD_INT 1
13085: PPUSH
13086: LD_INT 5
13088: PPUSH
13089: CALL_OW 12
13093: PUSH
13094: LD_INT 4
13096: LESSEQUAL
13097: IFFALSE 13178
// begin for ia4 in b4 do
13099: LD_ADDR_VAR 0 6
13103: PUSH
13104: LD_VAR 0 2
13108: PUSH
13109: FOR_IN
13110: IFFALSE 13176
// begin d4 := GetDistUnits ( JMM , ia4 ) ;
13112: LD_ADDR_VAR 0 5
13116: PUSH
13117: LD_EXP 15
13121: PPUSH
13122: LD_VAR 0 6
13126: PPUSH
13127: CALL_OW 296
13131: ST_TO_ADDR
// if d4 > 5 and d4 < max4 then
13132: LD_VAR 0 5
13136: PUSH
13137: LD_INT 5
13139: GREATER
13140: PUSH
13141: LD_VAR 0 5
13145: PUSH
13146: LD_VAR 0 7
13150: LESS
13151: AND
13152: IFFALSE 13174
// begin max4 := d4 ;
13154: LD_ADDR_VAR 0 7
13158: PUSH
13159: LD_VAR 0 5
13163: ST_TO_ADDR
// c4 := ia4 ;
13164: LD_ADDR_VAR 0 4
13168: PUSH
13169: LD_VAR 0 6
13173: ST_TO_ADDR
// end ; end ;
13174: GO 13109
13176: POP
13177: POP
// end ; if max4 > 11 then
13178: LD_VAR 0 7
13182: PUSH
13183: LD_INT 11
13185: GREATER
13186: IFFALSE 13198
// c4 := JMM ;
13188: LD_ADDR_VAR 0 4
13192: PUSH
13193: LD_EXP 15
13197: ST_TO_ADDR
// a4 := 0 ;
13198: LD_ADDR_VAR 0 1
13202: PUSH
13203: LD_INT 0
13205: ST_TO_ADDR
// if not Kurt_P and not Joan_P then
13206: LD_EXP 47
13210: NOT
13211: PUSH
13212: LD_EXP 48
13216: NOT
13217: AND
13218: IFFALSE 13236
// a4 := Rand ( 1 , 2 ) ;
13220: LD_ADDR_VAR 0 1
13224: PUSH
13225: LD_INT 1
13227: PPUSH
13228: LD_INT 2
13230: PPUSH
13231: CALL_OW 12
13235: ST_TO_ADDR
// if ( not Kurt_P and a4 = 0 ) or a4 = 1 then
13236: LD_EXP 47
13240: NOT
13241: PUSH
13242: LD_VAR 0 1
13246: PUSH
13247: LD_INT 0
13249: EQUAL
13250: AND
13251: PUSH
13252: LD_VAR 0 1
13256: PUSH
13257: LD_INT 1
13259: EQUAL
13260: OR
13261: IFFALSE 13337
// begin SetAttitude ( arabians , you , att_friend , true ) ;
13263: LD_EXP 3
13267: PPUSH
13268: LD_EXP 1
13272: PPUSH
13273: LD_INT 1
13275: PPUSH
13276: LD_INT 1
13278: PPUSH
13279: CALL_OW 80
// if PlaceUnitXYR ( Kurt , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13283: LD_EXP 43
13287: PPUSH
13288: LD_VAR 0 4
13292: PPUSH
13293: CALL_OW 250
13297: PPUSH
13298: LD_VAR 0 4
13302: PPUSH
13303: CALL_OW 251
13307: PPUSH
13308: LD_INT 8
13310: PPUSH
13311: LD_INT 1
13313: PPUSH
13314: CALL_OW 50
13318: IFFALSE 13337
// begin Kurt_P := true ;
13320: LD_ADDR_EXP 47
13324: PUSH
13325: LD_INT 1
13327: ST_TO_ADDR
// DialogKurt ( c4 ) ;
13328: LD_VAR 0 4
13332: PPUSH
13333: CALL 6839 0 1
// end ; end ; if ( not Joan_P and a4 = 0 ) or a4 = 2 then
13337: LD_EXP 48
13341: NOT
13342: PUSH
13343: LD_VAR 0 1
13347: PUSH
13348: LD_INT 0
13350: EQUAL
13351: AND
13352: PUSH
13353: LD_VAR 0 1
13357: PUSH
13358: LD_INT 2
13360: EQUAL
13361: OR
13362: IFFALSE 13418
// begin if PlaceUnitXYR ( Joan , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13364: LD_EXP 33
13368: PPUSH
13369: LD_VAR 0 4
13373: PPUSH
13374: CALL_OW 250
13378: PPUSH
13379: LD_VAR 0 4
13383: PPUSH
13384: CALL_OW 251
13388: PPUSH
13389: LD_INT 8
13391: PPUSH
13392: LD_INT 1
13394: PPUSH
13395: CALL_OW 50
13399: IFFALSE 13418
// begin Joan_P := true ;
13401: LD_ADDR_EXP 48
13405: PUSH
13406: LD_INT 1
13408: ST_TO_ADDR
// DialogJoan ( c4 ) ;
13409: LD_VAR 0 4
13413: PPUSH
13414: CALL 8434 0 1
// end ; end ; if not Kurt_P or not Joan_P then
13418: LD_EXP 47
13422: NOT
13423: PUSH
13424: LD_EXP 48
13428: NOT
13429: OR
13430: IFFALSE 13433
// enable ;
13432: ENABLE
// end ; end_of_file
13433: PPOPN 8
13435: END
// export function ne_v_boji ; begin
13436: LD_INT 0
13438: PPUSH
// while bojujese do
13439: CALL 13459 0 0
13443: IFFALSE 13454
// wait ( 0 0$4 ) ;
13445: LD_INT 140
13447: PPUSH
13448: CALL_OW 67
13452: GO 13439
// end ;
13454: LD_VAR 0 1
13458: RET
// export function bojujese ; begin
13459: LD_INT 0
13461: PPUSH
// result := true and not FilterAllUnits ( [ [ f_dist , JMM , 40 ] , [ f_side , russians ] ] ) ;
13462: LD_ADDR_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: LD_INT 91
13472: PUSH
13473: LD_EXP 15
13477: PUSH
13478: LD_INT 40
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: LIST
13485: PUSH
13486: LD_INT 22
13488: PUSH
13489: LD_EXP 2
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: PPUSH
13502: CALL_OW 69
13506: NOT
13507: AND
13508: ST_TO_ADDR
// end ;
13509: LD_VAR 0 1
13513: RET
// export function TvojiLidi ; begin
13514: LD_INT 0
13516: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13517: LD_ADDR_VAR 0 1
13521: PUSH
13522: LD_INT 22
13524: PUSH
13525: LD_EXP 1
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: LD_INT 21
13536: PUSH
13537: LD_INT 1
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: PPUSH
13548: CALL_OW 69
13552: ST_TO_ADDR
// end ;
13553: LD_VAR 0 1
13557: RET
// export function filter_type_unit ( from_units , human , vehicle , building ) ; var temp1 , temp2 , temp3 ; var un2 ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
13562: PPUSH
13563: PPUSH
13564: PPUSH
// if human then
13565: LD_VAR 0 2
13569: IFFALSE 13596
// begin temp1 := UnitFilter ( from_units , [ f_type , unit_human ] ) ;
13571: LD_ADDR_VAR 0 6
13575: PUSH
13576: LD_VAR 0 1
13580: PPUSH
13581: LD_INT 21
13583: PUSH
13584: LD_INT 1
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PPUSH
13591: CALL_OW 72
13595: ST_TO_ADDR
// end ; if vehicle then
13596: LD_VAR 0 3
13600: IFFALSE 13627
// begin temp2 := UnitFilter ( from_units , [ f_type , unit_vehicle ] ) ;
13602: LD_ADDR_VAR 0 7
13606: PUSH
13607: LD_VAR 0 1
13611: PPUSH
13612: LD_INT 21
13614: PUSH
13615: LD_INT 2
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// end ; if building then
13627: LD_VAR 0 4
13631: IFFALSE 13658
// begin temp3 := UnitFilter ( from_units , [ f_type , unit_building ] ) ;
13633: LD_ADDR_VAR 0 8
13637: PUSH
13638: LD_VAR 0 1
13642: PPUSH
13643: LD_INT 21
13645: PUSH
13646: LD_INT 3
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PPUSH
13653: CALL_OW 72
13657: ST_TO_ADDR
// end ; temp1 := add ( temp1 , temp2 ) ;
13658: LD_ADDR_VAR 0 6
13662: PUSH
13663: LD_VAR 0 6
13667: PPUSH
13668: LD_VAR 0 7
13672: PPUSH
13673: CALL 17456 0 2
13677: ST_TO_ADDR
// temp1 := add ( temp1 , temp3 ) ;
13678: LD_ADDR_VAR 0 6
13682: PUSH
13683: LD_VAR 0 6
13687: PPUSH
13688: LD_VAR 0 8
13692: PPUSH
13693: CALL 17456 0 2
13697: ST_TO_ADDR
// result := temp1 ;
13698: LD_ADDR_VAR 0 5
13702: PUSH
13703: LD_VAR 0 6
13707: ST_TO_ADDR
// end ;
13708: LD_VAR 0 5
13712: RET
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
13713: LD_INT 0
13715: PPUSH
13716: PPUSH
13717: PPUSH
13718: PPUSH
13719: PPUSH
13720: PPUSH
13721: PPUSH
13722: PPUSH
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// for for_unit in for_units do
13730: LD_ADDR_VAR 0 22
13734: PUSH
13735: LD_VAR 0 5
13739: PUSH
13740: FOR_IN
13741: IFFALSE 14263
// begin x := px ;
13743: LD_ADDR_VAR 0 9
13747: PUSH
13748: LD_VAR 0 1
13752: ST_TO_ADDR
// y := py ;
13753: LD_ADDR_VAR 0 10
13757: PUSH
13758: LD_VAR 0 2
13762: ST_TO_ADDR
// lx := px ;
13763: LD_ADDR_VAR 0 13
13767: PUSH
13768: LD_VAR 0 1
13772: ST_TO_ADDR
// ly := py ;
13773: LD_ADDR_VAR 0 14
13777: PUSH
13778: LD_VAR 0 2
13782: ST_TO_ADDR
// for j2 := 1 to hloubka do
13783: LD_ADDR_VAR 0 18
13787: PUSH
13788: DOUBLE
13789: LD_INT 1
13791: DEC
13792: ST_TO_ADDR
13793: LD_VAR 0 3
13797: PUSH
13798: FOR_TO
13799: IFFALSE 14131
// begin howgood := 50000 ;
13801: LD_ADDR_VAR 0 15
13805: PUSH
13806: LD_INT 50000
13808: ST_TO_ADDR
// smer := 0 ;
13809: LD_ADDR_VAR 0 16
13813: PUSH
13814: LD_INT 0
13816: ST_TO_ADDR
// kolem := 0 ;
13817: LD_ADDR_VAR 0 21
13821: PUSH
13822: LD_INT 0
13824: ST_TO_ADDR
// for i2 := 0 to 5 do
13825: LD_ADDR_VAR 0 17
13829: PUSH
13830: DOUBLE
13831: LD_INT 0
13833: DEC
13834: ST_TO_ADDR
13835: LD_INT 5
13837: PUSH
13838: FOR_TO
13839: IFFALSE 14033
// begin x2 := ShiftX ( x , i2 , krok ) ;
13841: LD_ADDR_VAR 0 11
13845: PUSH
13846: LD_VAR 0 9
13850: PPUSH
13851: LD_VAR 0 17
13855: PPUSH
13856: LD_VAR 0 4
13860: PPUSH
13861: CALL_OW 272
13865: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
13866: LD_ADDR_VAR 0 12
13870: PUSH
13871: LD_VAR 0 10
13875: PPUSH
13876: LD_VAR 0 17
13880: PPUSH
13881: LD_VAR 0 4
13885: PPUSH
13886: CALL_OW 273
13890: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
13891: LD_ADDR_VAR 0 20
13895: PUSH
13896: LD_VAR 0 6
13900: PPUSH
13901: LD_VAR 0 11
13905: PPUSH
13906: LD_VAR 0 12
13910: PPUSH
13911: CALL_OW 293
13915: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
13916: LD_VAR 0 20
13920: PUSH
13921: LD_VAR 0 15
13925: LESS
13926: PUSH
13927: LD_VAR 0 1
13931: PPUSH
13932: LD_VAR 0 2
13936: PPUSH
13937: LD_VAR 0 9
13941: PPUSH
13942: LD_VAR 0 10
13946: PPUSH
13947: CALL_OW 298
13951: PUSH
13952: LD_VAR 0 1
13956: PPUSH
13957: LD_VAR 0 2
13961: PPUSH
13962: LD_VAR 0 11
13966: PPUSH
13967: LD_VAR 0 12
13971: PPUSH
13972: CALL_OW 298
13976: LESS
13977: AND
13978: IFFALSE 14015
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
13980: LD_ADDR_VAR 0 15
13984: PUSH
13985: LD_VAR 0 6
13989: PPUSH
13990: LD_VAR 0 11
13994: PPUSH
13995: LD_VAR 0 12
13999: PPUSH
14000: CALL_OW 293
14004: ST_TO_ADDR
// smer := i2 ;
14005: LD_ADDR_VAR 0 16
14009: PUSH
14010: LD_VAR 0 17
14014: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
14015: LD_ADDR_VAR 0 21
14019: PUSH
14020: LD_VAR 0 21
14024: PUSH
14025: LD_VAR 0 20
14029: PLUS
14030: ST_TO_ADDR
// end ;
14031: GO 13838
14033: POP
14034: POP
// x := ShiftX ( x , smer , krok ) ;
14035: LD_ADDR_VAR 0 9
14039: PUSH
14040: LD_VAR 0 9
14044: PPUSH
14045: LD_VAR 0 16
14049: PPUSH
14050: LD_VAR 0 4
14054: PPUSH
14055: CALL_OW 272
14059: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
14060: LD_ADDR_VAR 0 10
14064: PUSH
14065: LD_VAR 0 10
14069: PPUSH
14070: LD_VAR 0 16
14074: PPUSH
14075: LD_VAR 0 4
14079: PPUSH
14080: CALL_OW 273
14084: ST_TO_ADDR
// lx := lx ^ x ;
14085: LD_ADDR_VAR 0 13
14089: PUSH
14090: LD_VAR 0 13
14094: PUSH
14095: LD_VAR 0 9
14099: ADD
14100: ST_TO_ADDR
// ly := ly ^ y ;
14101: LD_ADDR_VAR 0 14
14105: PUSH
14106: LD_VAR 0 14
14110: PUSH
14111: LD_VAR 0 10
14115: ADD
14116: ST_TO_ADDR
// if kolem = 0 then
14117: LD_VAR 0 21
14121: PUSH
14122: LD_INT 0
14124: EQUAL
14125: IFFALSE 14129
// break ;
14127: GO 14131
// end ;
14129: GO 13798
14131: POP
14132: POP
// for j2 := ( lx + 0 ) downto 1 do
14133: LD_ADDR_VAR 0 18
14137: PUSH
14138: DOUBLE
14139: LD_VAR 0 13
14143: PUSH
14144: LD_INT 0
14146: PLUS
14147: INC
14148: ST_TO_ADDR
14149: LD_INT 1
14151: PUSH
14152: FOR_DOWNTO
14153: IFFALSE 14259
// begin if queue and j2 = ( lx + 0 ) then
14155: LD_VAR 0 7
14159: PUSH
14160: LD_VAR 0 18
14164: PUSH
14165: LD_VAR 0 13
14169: PUSH
14170: LD_INT 0
14172: PLUS
14173: EQUAL
14174: AND
14175: IFFALSE 14210
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
14177: LD_VAR 0 22
14181: PPUSH
14182: LD_VAR 0 13
14186: PUSH
14187: LD_VAR 0 18
14191: ARRAY
14192: PPUSH
14193: LD_VAR 0 14
14197: PUSH
14198: LD_VAR 0 18
14202: ARRAY
14203: PPUSH
14204: CALL_OW 111
14208: GO 14257
// begin com_queue := true ;
14210: LD_ADDR_OWVAR 49
14214: PUSH
14215: LD_INT 1
14217: ST_TO_ADDR
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
14218: LD_VAR 0 22
14222: PPUSH
14223: LD_VAR 0 13
14227: PUSH
14228: LD_VAR 0 18
14232: ARRAY
14233: PPUSH
14234: LD_VAR 0 14
14238: PUSH
14239: LD_VAR 0 18
14243: ARRAY
14244: PPUSH
14245: CALL_OW 111
// com_queue := false ;
14249: LD_ADDR_OWVAR 49
14253: PUSH
14254: LD_INT 0
14256: ST_TO_ADDR
// end ; end ;
14257: GO 14152
14259: POP
14260: POP
// end ;
14261: GO 13740
14263: POP
14264: POP
// end ;
14265: LD_VAR 0 8
14269: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
14270: LD_INT 0
14272: PPUSH
14273: PPUSH
14274: PPUSH
14275: PPUSH
// for for_unit in for_units do
14276: LD_ADDR_VAR 0 5
14280: PUSH
14281: LD_VAR 0 1
14285: PUSH
14286: FOR_IN
14287: IFFALSE 14350
// begin unx := GetX ( for_unit ) ;
14289: LD_ADDR_VAR 0 6
14293: PUSH
14294: LD_VAR 0 5
14298: PPUSH
14299: CALL_OW 250
14303: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
14304: LD_ADDR_VAR 0 7
14308: PUSH
14309: LD_VAR 0 5
14313: PPUSH
14314: CALL_OW 251
14318: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
14319: LD_VAR 0 6
14323: PPUSH
14324: LD_VAR 0 7
14328: PPUSH
14329: LD_VAR 0 5
14333: PPUSH
14334: LD_VAR 0 2
14338: PPUSH
14339: LD_VAR 0 3
14343: PPUSH
14344: CALL 14357 0 5
// end ;
14348: GO 14286
14350: POP
14351: POP
// end ;
14352: LD_VAR 0 4
14356: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
14362: PPUSH
14363: PPUSH
14364: PPUSH
14365: PPUSH
// for for_unit in for_units do
14366: LD_ADDR_VAR 0 12
14370: PUSH
14371: LD_VAR 0 3
14375: PUSH
14376: FOR_IN
14377: IFFALSE 15093
// begin foundswD := 50000 ;
14379: LD_ADDR_VAR 0 9
14383: PUSH
14384: LD_INT 50000
14386: ST_TO_ADDR
// eswTX := 0 ;
14387: LD_ADDR_VAR 0 10
14391: PUSH
14392: LD_INT 0
14394: ST_TO_ADDR
// eswTY := 0 ;
14395: LD_ADDR_VAR 0 11
14399: PUSH
14400: LD_INT 0
14402: ST_TO_ADDR
// while eswTX < map_size_x do
14403: LD_VAR 0 10
14407: PUSH
14408: LD_EXP 53
14412: LESS
14413: IFFALSE 14513
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14415: LD_VAR 0 1
14419: PPUSH
14420: LD_VAR 0 2
14424: PPUSH
14425: LD_VAR 0 10
14429: PPUSH
14430: LD_VAR 0 11
14434: PPUSH
14435: CALL_OW 298
14439: PUSH
14440: LD_VAR 0 9
14444: LESS
14445: IFFALSE 14497
// begin foundswX := eswTX ;
14447: LD_ADDR_VAR 0 7
14451: PUSH
14452: LD_VAR 0 10
14456: ST_TO_ADDR
// foundswY := eswTY ;
14457: LD_ADDR_VAR 0 8
14461: PUSH
14462: LD_VAR 0 11
14466: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14467: LD_ADDR_VAR 0 9
14471: PUSH
14472: LD_VAR 0 1
14476: PPUSH
14477: LD_VAR 0 2
14481: PPUSH
14482: LD_VAR 0 10
14486: PPUSH
14487: LD_VAR 0 11
14491: PPUSH
14492: CALL_OW 298
14496: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14497: LD_ADDR_VAR 0 10
14501: PUSH
14502: LD_VAR 0 10
14506: PUSH
14507: LD_INT 10
14509: PLUS
14510: ST_TO_ADDR
// end ;
14511: GO 14403
// eswTX := map_size_x div 2 ;
14513: LD_ADDR_VAR 0 10
14517: PUSH
14518: LD_EXP 53
14522: PUSH
14523: LD_INT 2
14525: DIV
14526: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
14527: LD_ADDR_VAR 0 11
14531: PUSH
14532: LD_EXP 54
14536: PUSH
14537: LD_INT 1
14539: MINUS
14540: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
14541: LD_VAR 0 10
14545: PUSH
14546: LD_EXP 53
14550: PUSH
14551: LD_EXP 53
14555: PUSH
14556: LD_INT 2
14558: DIV
14559: PLUS
14560: LESS
14561: IFFALSE 14661
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_VAR 0 2
14572: PPUSH
14573: LD_VAR 0 10
14577: PPUSH
14578: LD_VAR 0 11
14582: PPUSH
14583: CALL_OW 298
14587: PUSH
14588: LD_VAR 0 9
14592: LESS
14593: IFFALSE 14645
// begin foundswX := eswTX ;
14595: LD_ADDR_VAR 0 7
14599: PUSH
14600: LD_VAR 0 10
14604: ST_TO_ADDR
// foundswY := eswTY ;
14605: LD_ADDR_VAR 0 8
14609: PUSH
14610: LD_VAR 0 11
14614: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14615: LD_ADDR_VAR 0 9
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: LD_VAR 0 2
14629: PPUSH
14630: LD_VAR 0 10
14634: PPUSH
14635: LD_VAR 0 11
14639: PPUSH
14640: CALL_OW 298
14644: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14645: LD_ADDR_VAR 0 10
14649: PUSH
14650: LD_VAR 0 10
14654: PUSH
14655: LD_INT 10
14657: PLUS
14658: ST_TO_ADDR
// end ;
14659: GO 14541
// eswTX := 0 ;
14661: LD_ADDR_VAR 0 10
14665: PUSH
14666: LD_INT 0
14668: ST_TO_ADDR
// eswTY := 0 ;
14669: LD_ADDR_VAR 0 11
14673: PUSH
14674: LD_INT 0
14676: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14677: LD_VAR 0 11
14681: PUSH
14682: LD_EXP 54
14686: LESS
14687: IFFALSE 14801
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14689: LD_VAR 0 1
14693: PPUSH
14694: LD_VAR 0 2
14698: PPUSH
14699: LD_VAR 0 10
14703: PPUSH
14704: LD_VAR 0 11
14708: PPUSH
14709: CALL_OW 298
14713: PUSH
14714: LD_VAR 0 9
14718: LESS
14719: IFFALSE 14771
// begin foundswX := eswTX ;
14721: LD_ADDR_VAR 0 7
14725: PUSH
14726: LD_VAR 0 10
14730: ST_TO_ADDR
// foundswY := eswTY ;
14731: LD_ADDR_VAR 0 8
14735: PUSH
14736: LD_VAR 0 11
14740: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14741: LD_ADDR_VAR 0 9
14745: PUSH
14746: LD_VAR 0 1
14750: PPUSH
14751: LD_VAR 0 2
14755: PPUSH
14756: LD_VAR 0 10
14760: PPUSH
14761: LD_VAR 0 11
14765: PPUSH
14766: CALL_OW 298
14770: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14771: LD_ADDR_VAR 0 11
14775: PUSH
14776: LD_VAR 0 11
14780: PUSH
14781: LD_INT 10
14783: PLUS
14784: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14785: LD_ADDR_VAR 0 10
14789: PUSH
14790: LD_VAR 0 10
14794: PUSH
14795: LD_INT 5
14797: PLUS
14798: ST_TO_ADDR
// end ;
14799: GO 14677
// eswTX := map_size_x ;
14801: LD_ADDR_VAR 0 10
14805: PUSH
14806: LD_EXP 53
14810: ST_TO_ADDR
// eswTY := 1 ;
14811: LD_ADDR_VAR 0 11
14815: PUSH
14816: LD_INT 1
14818: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14819: LD_VAR 0 11
14823: PUSH
14824: LD_EXP 54
14828: LESS
14829: IFFALSE 14943
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14831: LD_VAR 0 1
14835: PPUSH
14836: LD_VAR 0 2
14840: PPUSH
14841: LD_VAR 0 10
14845: PPUSH
14846: LD_VAR 0 11
14850: PPUSH
14851: CALL_OW 298
14855: PUSH
14856: LD_VAR 0 9
14860: LESS
14861: IFFALSE 14913
// begin foundswX := eswTX ;
14863: LD_ADDR_VAR 0 7
14867: PUSH
14868: LD_VAR 0 10
14872: ST_TO_ADDR
// foundswY := eswTY ;
14873: LD_ADDR_VAR 0 8
14877: PUSH
14878: LD_VAR 0 11
14882: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14883: LD_ADDR_VAR 0 9
14887: PUSH
14888: LD_VAR 0 1
14892: PPUSH
14893: LD_VAR 0 2
14897: PPUSH
14898: LD_VAR 0 10
14902: PPUSH
14903: LD_VAR 0 11
14907: PPUSH
14908: CALL_OW 298
14912: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14913: LD_ADDR_VAR 0 11
14917: PUSH
14918: LD_VAR 0 11
14922: PUSH
14923: LD_INT 10
14925: PLUS
14926: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14927: LD_ADDR_VAR 0 10
14931: PUSH
14932: LD_VAR 0 10
14936: PUSH
14937: LD_INT 5
14939: PLUS
14940: ST_TO_ADDR
// end ;
14941: GO 14819
// if queue then
14943: LD_VAR 0 4
14947: IFFALSE 15021
// begin if agressive then
14949: LD_VAR 0 5
14953: IFFALSE 14988
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
14955: LD_VAR 0 12
14959: PPUSH
14960: LD_VAR 0 7
14964: PPUSH
14965: LD_VAR 0 8
14969: PPUSH
14970: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
14974: LD_VAR 0 12
14978: PPUSH
14979: LD_INT 10
14981: PPUSH
14982: CALL_OW 173
// end else
14986: GO 15019
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
14988: LD_VAR 0 12
14992: PPUSH
14993: LD_VAR 0 7
14997: PPUSH
14998: LD_VAR 0 8
15002: PPUSH
15003: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
15007: LD_VAR 0 12
15011: PPUSH
15012: LD_INT 10
15014: PPUSH
15015: CALL_OW 173
// end ; end else
15019: GO 15091
// begin if agressive then
15021: LD_VAR 0 5
15025: IFFALSE 15060
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
15027: LD_VAR 0 12
15031: PPUSH
15032: LD_VAR 0 7
15036: PPUSH
15037: LD_VAR 0 8
15041: PPUSH
15042: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
15046: LD_VAR 0 12
15050: PPUSH
15051: LD_INT 10
15053: PPUSH
15054: CALL_OW 173
// end else
15058: GO 15091
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
15060: LD_VAR 0 12
15064: PPUSH
15065: LD_VAR 0 7
15069: PPUSH
15070: LD_VAR 0 8
15074: PPUSH
15075: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
15079: LD_VAR 0 12
15083: PPUSH
15084: LD_INT 10
15086: PPUSH
15087: CALL_OW 173
// end ; end ; end ;
15091: GO 14376
15093: POP
15094: POP
// end ;
15095: LD_VAR 0 6
15099: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
15100: LD_INT 0
15102: PPUSH
15103: PPUSH
15104: PPUSH
// see_any_r := false ;
15105: LD_ADDR_VAR 0 5
15109: PUSH
15110: LD_INT 0
15112: ST_TO_ADDR
// for sai in sez2 do
15113: LD_ADDR_VAR 0 4
15117: PUSH
15118: LD_VAR 0 2
15122: PUSH
15123: FOR_IN
15124: IFFALSE 15154
// if See ( strana , sai ) then
15126: LD_VAR 0 1
15130: PPUSH
15131: LD_VAR 0 4
15135: PPUSH
15136: CALL_OW 292
15140: IFFALSE 15152
// begin see_any_r := true ;
15142: LD_ADDR_VAR 0 5
15146: PUSH
15147: LD_INT 1
15149: ST_TO_ADDR
// break ;
15150: GO 15154
// end ;
15152: GO 15123
15154: POP
15155: POP
// ; result := see_any_r ;
15156: LD_ADDR_VAR 0 3
15160: PUSH
15161: LD_VAR 0 5
15165: ST_TO_ADDR
// end ;
15166: LD_VAR 0 3
15170: RET
// export function nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ; var list , list2 ; var un1 , vzdal ; var count ; begin
15171: LD_INT 0
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
15177: PPUSH
15178: PPUSH
// un1 := 1 ;
15179: LD_ADDR_VAR 0 11
15183: PUSH
15184: LD_INT 1
15186: ST_TO_ADDR
// count := 0 ;
15187: LD_ADDR_VAR 0 13
15191: PUSH
15192: LD_INT 0
15194: ST_TO_ADDR
// if pocet > from_units then
15195: LD_VAR 0 5
15199: PUSH
15200: LD_VAR 0 1
15204: GREATER
15205: IFFALSE 15221
// pocet := ( from_units + 0 ) ;
15207: LD_ADDR_VAR 0 5
15211: PUSH
15212: LD_VAR 0 1
15216: PUSH
15217: LD_INT 0
15219: PLUS
15220: ST_TO_ADDR
// while un1 <= pocet or count <= pocet do
15221: LD_VAR 0 11
15225: PUSH
15226: LD_VAR 0 5
15230: LESSEQUAL
15231: PUSH
15232: LD_VAR 0 13
15236: PUSH
15237: LD_VAR 0 5
15241: LESSEQUAL
15242: OR
15243: IFFALSE 15396
// begin vzdal := GetDistUnitXY ( un1 , x , y ) ;
15245: LD_ADDR_VAR 0 12
15249: PUSH
15250: LD_VAR 0 11
15254: PPUSH
15255: LD_VAR 0 2
15259: PPUSH
15260: LD_VAR 0 3
15264: PPUSH
15265: CALL_OW 297
15269: ST_TO_ADDR
// if vzdal <= max_vzdal then
15270: LD_VAR 0 12
15274: PUSH
15275: LD_VAR 0 7
15279: LESSEQUAL
15280: IFFALSE 15380
// begin if un1 > skip then
15282: LD_VAR 0 11
15286: PUSH
15287: LD_VAR 0 4
15291: GREATER
15292: IFFALSE 15380
// begin if list then
15294: LD_VAR 0 9
15298: IFFALSE 15340
// begin list := list ^ from_units [ un1 ] ;
15300: LD_ADDR_VAR 0 9
15304: PUSH
15305: LD_VAR 0 9
15309: PUSH
15310: LD_VAR 0 1
15314: PUSH
15315: LD_VAR 0 11
15319: ARRAY
15320: ADD
15321: ST_TO_ADDR
// list2 := list2 ^ vzdal ;
15322: LD_ADDR_VAR 0 10
15326: PUSH
15327: LD_VAR 0 10
15331: PUSH
15332: LD_VAR 0 12
15336: ADD
15337: ST_TO_ADDR
// end else
15338: GO 15366
// begin list := from_units [ un1 ] ;
15340: LD_ADDR_VAR 0 9
15344: PUSH
15345: LD_VAR 0 1
15349: PUSH
15350: LD_VAR 0 11
15354: ARRAY
15355: ST_TO_ADDR
// list2 := vzdal ;
15356: LD_ADDR_VAR 0 10
15360: PUSH
15361: LD_VAR 0 12
15365: ST_TO_ADDR
// end ; count := count + 1 ;
15366: LD_ADDR_VAR 0 13
15370: PUSH
15371: LD_VAR 0 13
15375: PUSH
15376: LD_INT 1
15378: PLUS
15379: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
15380: LD_ADDR_VAR 0 11
15384: PUSH
15385: LD_VAR 0 11
15389: PUSH
15390: LD_INT 1
15392: PLUS
15393: ST_TO_ADDR
// end ;
15394: GO 15221
// result := list ;
15396: LD_ADDR_VAR 0 8
15400: PUSH
15401: LD_VAR 0 9
15405: ST_TO_ADDR
// end ;
15406: LD_VAR 0 8
15410: RET
// export function nearest_units_unit ( from_units , for_unit , skip , pocet , min_vzdal , max_vzdal ) ; var x , y ; begin
15411: LD_INT 0
15413: PPUSH
15414: PPUSH
15415: PPUSH
// x := GetX ( for_unit ) ;
15416: LD_ADDR_VAR 0 8
15420: PUSH
15421: LD_VAR 0 2
15425: PPUSH
15426: CALL_OW 250
15430: ST_TO_ADDR
// y := GetY ( for_unit ) ;
15431: LD_ADDR_VAR 0 9
15435: PUSH
15436: LD_VAR 0 2
15440: PPUSH
15441: CALL_OW 251
15445: ST_TO_ADDR
// result := nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ;
15446: LD_ADDR_VAR 0 7
15450: PUSH
15451: LD_VAR 0 1
15455: PPUSH
15456: LD_VAR 0 8
15460: PPUSH
15461: LD_VAR 0 9
15465: PPUSH
15466: LD_VAR 0 3
15470: PPUSH
15471: LD_VAR 0 4
15475: PPUSH
15476: LD_VAR 0 5
15480: PPUSH
15481: LD_VAR 0 6
15485: PPUSH
15486: CALL 15171 0 7
15490: ST_TO_ADDR
// end ;
15491: LD_VAR 0 7
15495: RET
// export function nearest_ememies_xy ( side , x , y , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15496: LD_INT 0
15498: PPUSH
15499: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15500: LD_ADDR_VAR 0 11
15504: PUSH
15505: LD_INT 22
15507: PUSH
15508: LD_VAR 0 1
15512: PUSH
15513: EMPTY
15514: LIST
15515: LIST
15516: PPUSH
15517: CALL_OW 69
15521: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15522: LD_ADDR_VAR 0 11
15526: PUSH
15527: LD_VAR 0 11
15531: PPUSH
15532: LD_VAR 0 7
15536: PPUSH
15537: LD_VAR 0 8
15541: PPUSH
15542: LD_VAR 0 9
15546: PPUSH
15547: CALL 13558 0 4
15551: ST_TO_ADDR
// nearest_units_xy ( from_units , x , y , skip , pocet , 1 , max_vzdal ) ;
15552: LD_VAR 0 11
15556: PPUSH
15557: LD_VAR 0 2
15561: PPUSH
15562: LD_VAR 0 3
15566: PPUSH
15567: LD_VAR 0 4
15571: PPUSH
15572: LD_VAR 0 5
15576: PPUSH
15577: LD_INT 1
15579: PPUSH
15580: LD_VAR 0 6
15584: PPUSH
15585: CALL 15171 0 7
// end ;
15589: LD_VAR 0 10
15593: RET
// export function nearest_ememies_unit ( side , for_unit , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15598: LD_ADDR_VAR 0 10
15602: PUSH
15603: LD_INT 22
15605: PUSH
15606: LD_VAR 0 1
15610: PUSH
15611: EMPTY
15612: LIST
15613: LIST
15614: PPUSH
15615: CALL_OW 69
15619: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15620: LD_ADDR_VAR 0 10
15624: PUSH
15625: LD_VAR 0 10
15629: PPUSH
15630: LD_VAR 0 6
15634: PPUSH
15635: LD_VAR 0 7
15639: PPUSH
15640: LD_VAR 0 8
15644: PPUSH
15645: CALL 13558 0 4
15649: ST_TO_ADDR
// nearest_units_unit ( from_units , for_unit , skip , pocet , 1 , max_vzdal ) ;
15650: LD_VAR 0 10
15654: PPUSH
15655: LD_VAR 0 2
15659: PPUSH
15660: LD_VAR 0 3
15664: PPUSH
15665: LD_VAR 0 4
15669: PPUSH
15670: LD_INT 1
15672: PPUSH
15673: LD_VAR 0 5
15677: PPUSH
15678: CALL 15411 0 6
// end ;
15682: LD_VAR 0 9
15686: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
15687: LD_INT 0
15689: PPUSH
15690: PPUSH
15691: PPUSH
15692: PPUSH
// for i in who do
15693: LD_ADDR_VAR 0 6
15697: PUSH
15698: LD_VAR 0 1
15702: PUSH
15703: FOR_IN
15704: IFFALSE 15775
// begin for j in what do
15706: LD_ADDR_VAR 0 7
15710: PUSH
15711: LD_VAR 0 3
15715: PUSH
15716: FOR_IN
15717: IFFALSE 15771
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
15719: LD_VAR 0 7
15723: PPUSH
15724: CALL_OW 311
15728: NOT
15729: PUSH
15730: LD_VAR 0 6
15734: PPUSH
15735: LD_VAR 0 7
15739: PPUSH
15740: CALL_OW 296
15744: PUSH
15745: LD_VAR 0 2
15749: LESSEQUAL
15750: AND
15751: IFFALSE 15769
// begin ComEnterUnit ( i , j ) ;
15753: LD_VAR 0 6
15757: PPUSH
15758: LD_VAR 0 7
15762: PPUSH
15763: CALL_OW 120
// break ;
15767: GO 15771
// end ; end ;
15769: GO 15716
15771: POP
15772: POP
// end ;
15773: GO 15703
15775: POP
15776: POP
// end ;
15777: LD_VAR 0 4
15781: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
15782: LD_INT 0
15784: PPUSH
15785: PPUSH
15786: PPUSH
15787: PPUSH
// for i in who do
15788: LD_ADDR_VAR 0 6
15792: PUSH
15793: LD_VAR 0 1
15797: PUSH
15798: FOR_IN
15799: IFFALSE 15898
// begin add := false ;
15801: LD_ADDR_VAR 0 5
15805: PUSH
15806: LD_INT 0
15808: ST_TO_ADDR
// for j in what do
15809: LD_ADDR_VAR 0 7
15813: PUSH
15814: LD_VAR 0 3
15818: PUSH
15819: FOR_IN
15820: IFFALSE 15854
// begin if GetDistUnits ( i , j ) <= dist then
15822: LD_VAR 0 6
15826: PPUSH
15827: LD_VAR 0 7
15831: PPUSH
15832: CALL_OW 296
15836: PUSH
15837: LD_VAR 0 2
15841: LESSEQUAL
15842: IFFALSE 15852
// begin add := true ;
15844: LD_ADDR_VAR 0 5
15848: PUSH
15849: LD_INT 1
15851: ST_TO_ADDR
// end ; end ;
15852: GO 15819
15854: POP
15855: POP
// if add then
15856: LD_VAR 0 5
15860: IFFALSE 15896
// begin if result then
15862: LD_VAR 0 4
15866: IFFALSE 15886
// result := result ^ i else
15868: LD_ADDR_VAR 0 4
15872: PUSH
15873: LD_VAR 0 4
15877: PUSH
15878: LD_VAR 0 6
15882: ADD
15883: ST_TO_ADDR
15884: GO 15896
// result := i ;
15886: LD_ADDR_VAR 0 4
15890: PUSH
15891: LD_VAR 0 6
15895: ST_TO_ADDR
// end ; end ;
15896: GO 15798
15898: POP
15899: POP
// end ;
15900: LD_VAR 0 4
15904: RET
// export function comqb ; begin
15905: LD_INT 0
15907: PPUSH
// com_queue := true ;
15908: LD_ADDR_OWVAR 49
15912: PUSH
15913: LD_INT 1
15915: ST_TO_ADDR
// end ;
15916: LD_VAR 0 1
15920: RET
// export function comqe ; begin
15921: LD_INT 0
15923: PPUSH
// com_queue := false ;
15924: LD_ADDR_OWVAR 49
15928: PUSH
15929: LD_INT 0
15931: ST_TO_ADDR
// end ;
15932: LD_VAR 0 1
15936: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a , x , y ; begin
15937: LD_INT 0
15939: PPUSH
15940: PPUSH
15941: PPUSH
15942: PPUSH
15943: PPUSH
// for_units := UnitFilter ( for_units , [ f_alive ] ) ;
15944: LD_ADDR_VAR 0 1
15948: PUSH
15949: LD_VAR 0 1
15953: PPUSH
15954: LD_INT 51
15956: PUSH
15957: EMPTY
15958: LIST
15959: PPUSH
15960: CALL_OW 72
15964: ST_TO_ADDR
// i1 := 1 ;
15965: LD_ADDR_VAR 0 5
15969: PUSH
15970: LD_INT 1
15972: ST_TO_ADDR
// while i1 <= path do
15973: LD_VAR 0 5
15977: PUSH
15978: LD_VAR 0 2
15982: LESSEQUAL
15983: IFFALSE 16279
// begin a := path [ i1 ] ;
15985: LD_ADDR_VAR 0 6
15989: PUSH
15990: LD_VAR 0 2
15994: PUSH
15995: LD_VAR 0 5
15999: ARRAY
16000: ST_TO_ADDR
// if a < 0 then
16001: LD_VAR 0 6
16005: PUSH
16006: LD_INT 0
16008: LESS
16009: IFFALSE 16066
// begin while a <= - 1 do
16011: LD_VAR 0 6
16015: PUSH
16016: LD_INT 1
16018: NEG
16019: LESSEQUAL
16020: IFFALSE 16050
// begin a := a + 1 ;
16022: LD_ADDR_VAR 0 6
16026: PUSH
16027: LD_VAR 0 6
16031: PUSH
16032: LD_INT 1
16034: PLUS
16035: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 35
16043: PPUSH
16044: CALL_OW 202
// end ;
16048: GO 16011
// i1 := i1 + 1 ;
16050: LD_ADDR_VAR 0 5
16054: PUSH
16055: LD_VAR 0 5
16059: PUSH
16060: LD_INT 1
16062: PLUS
16063: ST_TO_ADDR
// end else
16064: GO 16277
// begin if a = 0 then
16066: LD_VAR 0 6
16070: PUSH
16071: LD_INT 0
16073: EQUAL
16074: IFFALSE 16136
// begin a := path [ i1 + 1 ] ;
16076: LD_ADDR_VAR 0 6
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_VAR 0 5
16090: PUSH
16091: LD_INT 1
16093: PLUS
16094: ARRAY
16095: ST_TO_ADDR
// if a = 0 then
16096: LD_VAR 0 6
16100: PUSH
16101: LD_INT 0
16103: EQUAL
16104: IFFALSE 16115
// AddComReturn ( for_units ) ;
16106: LD_VAR 0 1
16110: PPUSH
16111: CALL_OW 204
// if a = 1 then
16115: LD_VAR 0 6
16119: PUSH
16120: LD_INT 1
16122: EQUAL
16123: IFFALSE 16134
// AddComRemember ( for_units ) ;
16125: LD_VAR 0 1
16129: PPUSH
16130: CALL_OW 203
// end else
16134: GO 16263
// begin x := path [ i1 ] ;
16136: LD_ADDR_VAR 0 7
16140: PUSH
16141: LD_VAR 0 2
16145: PUSH
16146: LD_VAR 0 5
16150: ARRAY
16151: ST_TO_ADDR
// y := path [ i1 + 1 ] ;
16152: LD_ADDR_VAR 0 8
16156: PUSH
16157: LD_VAR 0 2
16161: PUSH
16162: LD_VAR 0 5
16166: PUSH
16167: LD_INT 1
16169: PLUS
16170: ARRAY
16171: ST_TO_ADDR
// if x <= 3 and y <= 3 then
16172: LD_VAR 0 7
16176: PUSH
16177: LD_INT 3
16179: LESSEQUAL
16180: PUSH
16181: LD_VAR 0 8
16185: PUSH
16186: LD_INT 3
16188: LESSEQUAL
16189: AND
16190: IFFALSE 16217
// begin Msg ( kam to jedes (take path) ) ;
16192: LD_STRING kam to jedes (take path)
16194: PPUSH
16195: CALL_OW 100
// Msg ( [ x , y ] ) ;
16199: LD_VAR 0 7
16203: PUSH
16204: LD_VAR 0 8
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 100
// end ; if agressive then
16217: LD_VAR 0 3
16221: IFFALSE 16244
// AddComAgressiveMove ( for_units , x , y ) else
16223: LD_VAR 0 1
16227: PPUSH
16228: LD_VAR 0 7
16232: PPUSH
16233: LD_VAR 0 8
16237: PPUSH
16238: CALL_OW 174
16242: GO 16263
// AddComMoveXY ( for_units , x , y ) ;
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_VAR 0 7
16253: PPUSH
16254: LD_VAR 0 8
16258: PPUSH
16259: CALL_OW 171
// end ; i1 := i1 + 2 ;
16263: LD_ADDR_VAR 0 5
16267: PUSH
16268: LD_VAR 0 5
16272: PUSH
16273: LD_INT 2
16275: PLUS
16276: ST_TO_ADDR
// end ; end ;
16277: GO 15973
// end ;
16279: LD_VAR 0 4
16283: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
16284: LD_INT 0
16286: PPUSH
16287: PPUSH
16288: PPUSH
16289: PPUSH
16290: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
16291: LD_ADDR_VAR 0 1
16295: PUSH
16296: LD_VAR 0 1
16300: PPUSH
16301: LD_INT 51
16303: PUSH
16304: EMPTY
16305: LIST
16306: PPUSH
16307: CALL_OW 72
16311: PUSH
16312: EMPTY
16313: UNION
16314: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
16315: LD_ADDR_VAR 0 2
16319: PUSH
16320: LD_VAR 0 2
16324: PPUSH
16325: LD_INT 51
16327: PUSH
16328: EMPTY
16329: LIST
16330: PPUSH
16331: CALL_OW 72
16335: PUSH
16336: EMPTY
16337: UNION
16338: ST_TO_ADDR
// for i in cars do
16339: LD_ADDR_VAR 0 7
16343: PUSH
16344: LD_VAR 0 1
16348: PUSH
16349: FOR_IN
16350: IFFALSE 16386
// if not IsDrivenBy ( i ) then
16352: LD_VAR 0 7
16356: PPUSH
16357: CALL_OW 311
16361: NOT
16362: IFFALSE 16384
// empty := add ( empty , i ) ;
16364: LD_ADDR_VAR 0 5
16368: PUSH
16369: LD_VAR 0 5
16373: PPUSH
16374: LD_VAR 0 7
16378: PPUSH
16379: CALL 17456 0 2
16383: ST_TO_ADDR
16384: GO 16349
16386: POP
16387: POP
// if take_out then
16388: LD_VAR 0 3
16392: IFFALSE 16451
// begin for i in drivers do
16394: LD_ADDR_VAR 0 7
16398: PUSH
16399: LD_VAR 0 2
16403: PUSH
16404: FOR_IN
16405: IFFALSE 16447
// if not ( IsInUnit ( i ) in cars ) then
16407: LD_VAR 0 7
16411: PPUSH
16412: CALL_OW 310
16416: PUSH
16417: LD_VAR 0 1
16421: IN
16422: NOT
16423: IFFALSE 16445
// free := add ( free , i ) ;
16425: LD_ADDR_VAR 0 6
16429: PUSH
16430: LD_VAR 0 6
16434: PPUSH
16435: LD_VAR 0 7
16439: PPUSH
16440: CALL 17456 0 2
16444: ST_TO_ADDR
16445: GO 16404
16447: POP
16448: POP
// end else
16449: GO 16500
// begin for i in drivers do
16451: LD_ADDR_VAR 0 7
16455: PUSH
16456: LD_VAR 0 2
16460: PUSH
16461: FOR_IN
16462: IFFALSE 16498
// if not IsInUnit ( i ) then
16464: LD_VAR 0 7
16468: PPUSH
16469: CALL_OW 310
16473: NOT
16474: IFFALSE 16496
// free := add ( free , i ) ;
16476: LD_ADDR_VAR 0 6
16480: PUSH
16481: LD_VAR 0 6
16485: PPUSH
16486: LD_VAR 0 7
16490: PPUSH
16491: CALL 17456 0 2
16495: ST_TO_ADDR
16496: GO 16461
16498: POP
16499: POP
// end ; result := cars diff empty ;
16500: LD_ADDR_VAR 0 4
16504: PUSH
16505: LD_VAR 0 1
16509: PUSH
16510: LD_VAR 0 5
16514: DIFF
16515: ST_TO_ADDR
// if empty <= free then
16516: LD_VAR 0 5
16520: PUSH
16521: LD_VAR 0 6
16525: LESSEQUAL
16526: IFFALSE 16540
// konec := empty else
16528: LD_ADDR_VAR 0 8
16532: PUSH
16533: LD_VAR 0 5
16537: ST_TO_ADDR
16538: GO 16550
// konec := free ;
16540: LD_ADDR_VAR 0 8
16544: PUSH
16545: LD_VAR 0 6
16549: ST_TO_ADDR
// for i := 1 to konec do
16550: LD_ADDR_VAR 0 7
16554: PUSH
16555: DOUBLE
16556: LD_INT 1
16558: DEC
16559: ST_TO_ADDR
16560: LD_VAR 0 8
16564: PUSH
16565: FOR_TO
16566: IFFALSE 16622
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16568: LD_VAR 0 6
16572: PUSH
16573: LD_VAR 0 7
16577: ARRAY
16578: PPUSH
16579: LD_VAR 0 5
16583: PUSH
16584: LD_VAR 0 7
16588: ARRAY
16589: PPUSH
16590: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16594: LD_ADDR_VAR 0 4
16598: PUSH
16599: LD_VAR 0 4
16603: PPUSH
16604: LD_VAR 0 5
16608: PUSH
16609: LD_VAR 0 7
16613: ARRAY
16614: PPUSH
16615: CALL 17456 0 2
16619: ST_TO_ADDR
// end ;
16620: GO 16565
16622: POP
16623: POP
// end ;
16624: LD_VAR 0 4
16628: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
16629: LD_INT 0
16631: PPUSH
16632: PPUSH
16633: PPUSH
16634: PPUSH
16635: PPUSH
// forts := forts union [ ] ;
16636: LD_ADDR_VAR 0 1
16640: PUSH
16641: LD_VAR 0 1
16645: PUSH
16646: EMPTY
16647: UNION
16648: ST_TO_ADDR
// sols := sols union [ ] ;
16649: LD_ADDR_VAR 0 2
16653: PUSH
16654: LD_VAR 0 2
16658: PUSH
16659: EMPTY
16660: UNION
16661: ST_TO_ADDR
// for i in forts do
16662: LD_ADDR_VAR 0 6
16666: PUSH
16667: LD_VAR 0 1
16671: PUSH
16672: FOR_IN
16673: IFFALSE 16709
// if not UnitsInside ( i ) then
16675: LD_VAR 0 6
16679: PPUSH
16680: CALL_OW 313
16684: NOT
16685: IFFALSE 16707
// empty := add ( empty , i ) ;
16687: LD_ADDR_VAR 0 4
16691: PUSH
16692: LD_VAR 0 4
16696: PPUSH
16697: LD_VAR 0 6
16701: PPUSH
16702: CALL 17456 0 2
16706: ST_TO_ADDR
16707: GO 16672
16709: POP
16710: POP
// for i in sols do
16711: LD_ADDR_VAR 0 6
16715: PUSH
16716: LD_VAR 0 2
16720: PUSH
16721: FOR_IN
16722: IFFALSE 16770
// if not IsInUnit ( i ) and not IsBusy ( i ) then
16724: LD_VAR 0 6
16728: PPUSH
16729: CALL_OW 310
16733: NOT
16734: PUSH
16735: LD_VAR 0 6
16739: PPUSH
16740: CALL_OW 315
16744: NOT
16745: AND
16746: IFFALSE 16768
// free := add ( free , i ) ;
16748: LD_ADDR_VAR 0 5
16752: PUSH
16753: LD_VAR 0 5
16757: PPUSH
16758: LD_VAR 0 6
16762: PPUSH
16763: CALL 17456 0 2
16767: ST_TO_ADDR
16768: GO 16721
16770: POP
16771: POP
// result := forts diff empty ;
16772: LD_ADDR_VAR 0 3
16776: PUSH
16777: LD_VAR 0 1
16781: PUSH
16782: LD_VAR 0 4
16786: DIFF
16787: ST_TO_ADDR
// if empty <= free then
16788: LD_VAR 0 4
16792: PUSH
16793: LD_VAR 0 5
16797: LESSEQUAL
16798: IFFALSE 16812
// konec := empty else
16800: LD_ADDR_VAR 0 7
16804: PUSH
16805: LD_VAR 0 4
16809: ST_TO_ADDR
16810: GO 16822
// konec := free ;
16812: LD_ADDR_VAR 0 7
16816: PUSH
16817: LD_VAR 0 5
16821: ST_TO_ADDR
// for i := 1 to konec do
16822: LD_ADDR_VAR 0 6
16826: PUSH
16827: DOUBLE
16828: LD_INT 1
16830: DEC
16831: ST_TO_ADDR
16832: LD_VAR 0 7
16836: PUSH
16837: FOR_TO
16838: IFFALSE 16894
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16840: LD_VAR 0 5
16844: PUSH
16845: LD_VAR 0 6
16849: ARRAY
16850: PPUSH
16851: LD_VAR 0 4
16855: PUSH
16856: LD_VAR 0 6
16860: ARRAY
16861: PPUSH
16862: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16866: LD_ADDR_VAR 0 3
16870: PUSH
16871: LD_VAR 0 3
16875: PPUSH
16876: LD_VAR 0 4
16880: PUSH
16881: LD_VAR 0 6
16885: ARRAY
16886: PPUSH
16887: CALL 17456 0 2
16891: ST_TO_ADDR
// end ;
16892: GO 16837
16894: POP
16895: POP
// end ;
16896: LD_VAR 0 3
16900: RET
// export function depart ( cars , drivers , path , argessive , take_out ) ; var pojedou ; begin
16901: LD_INT 0
16903: PPUSH
16904: PPUSH
// pojedou := find_drivers ( cars , drivers , take_out ) ;
16905: LD_ADDR_VAR 0 7
16909: PUSH
16910: LD_VAR 0 1
16914: PPUSH
16915: LD_VAR 0 2
16919: PPUSH
16920: LD_VAR 0 5
16924: PPUSH
16925: CALL 16284 0 3
16929: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
16930: LD_VAR 0 7
16934: PPUSH
16935: CALL 16963 0 1
// take_path ( pojedou , path , argessive ) ;
16939: LD_VAR 0 7
16943: PPUSH
16944: LD_VAR 0 3
16948: PPUSH
16949: LD_VAR 0 4
16953: PPUSH
16954: CALL 15937 0 3
// end ;
16958: LD_VAR 0 6
16962: RET
// export function wait_for_drivers ( cars ) ; var i , vsichni_ready , k ; begin
16963: LD_INT 0
16965: PPUSH
16966: PPUSH
16967: PPUSH
16968: PPUSH
// k := 0 ;
16969: LD_ADDR_VAR 0 5
16973: PUSH
16974: LD_INT 0
16976: ST_TO_ADDR
// while not vsichni_ready do
16977: LD_VAR 0 4
16981: NOT
16982: IFFALSE 17052
// begin vsichni_ready := true ;
16984: LD_ADDR_VAR 0 4
16988: PUSH
16989: LD_INT 1
16991: ST_TO_ADDR
// k := k + 1 ;
16992: LD_ADDR_VAR 0 5
16996: PUSH
16997: LD_VAR 0 5
17001: PUSH
17002: LD_INT 1
17004: PLUS
17005: ST_TO_ADDR
// for i in cars do
17006: LD_ADDR_VAR 0 3
17010: PUSH
17011: LD_VAR 0 1
17015: PUSH
17016: FOR_IN
17017: IFFALSE 17041
// if not IsDrivenBy ( i ) then
17019: LD_VAR 0 3
17023: PPUSH
17024: CALL_OW 311
17028: NOT
17029: IFFALSE 17039
// vsichni_ready := false ;
17031: LD_ADDR_VAR 0 4
17035: PUSH
17036: LD_INT 0
17038: ST_TO_ADDR
17039: GO 17016
17041: POP
17042: POP
// wait ( 0 0$1.0 ) ;
17043: LD_INT 35
17045: PPUSH
17046: CALL_OW 67
// end ;
17050: GO 16977
// end ;
17052: LD_VAR 0 2
17056: RET
// export function rand_xy_in_map ; var x , y ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
17062: LD_ADDR_VAR 0 3
17066: PUSH
17067: LD_INT 2
17069: PPUSH
17070: LD_EXP 54
17074: PUSH
17075: LD_INT 2
17077: MINUS
17078: PPUSH
17079: CALL_OW 12
17083: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
17084: LD_ADDR_VAR 0 2
17088: PUSH
17089: LD_VAR 0 3
17093: PUSH
17094: LD_INT 2
17096: DIV
17097: PUSH
17098: LD_INT 2
17100: PLUS
17101: PPUSH
17102: LD_EXP 53
17106: PUSH
17107: LD_VAR 0 3
17111: PUSH
17112: LD_INT 2
17114: DIV
17115: PLUS
17116: PUSH
17117: LD_INT 2
17119: MINUS
17120: PPUSH
17121: CALL_OW 12
17125: ST_TO_ADDR
// result := [ x , y ] ;
17126: LD_ADDR_VAR 0 1
17130: PUSH
17131: LD_VAR 0 2
17135: PUSH
17136: LD_VAR 0 3
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: ST_TO_ADDR
// end ;
17145: LD_VAR 0 1
17149: RET
// export function TalkOn ; begin
17150: LD_INT 0
17152: PPUSH
// stop_talking := true ;
17153: LD_ADDR_OWVAR 56
17157: PUSH
17158: LD_INT 1
17160: ST_TO_ADDR
// end ;
17161: LD_VAR 0 1
17165: RET
// export function TalkOff ; begin
17166: LD_INT 0
17168: PPUSH
// stop_talking := false ;
17169: LD_ADDR_OWVAR 56
17173: PUSH
17174: LD_INT 0
17176: ST_TO_ADDR
// end ;
17177: LD_VAR 0 1
17181: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
17182: LD_INT 0
17184: PPUSH
17185: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
17186: LD_ADDR_VAR 0 8
17190: PUSH
17191: LD_VAR 0 1
17195: PPUSH
17196: LD_VAR 0 3
17200: PPUSH
17201: LD_VAR 0 4
17205: PPUSH
17206: LD_VAR 0 5
17210: PPUSH
17211: LD_VAR 0 6
17215: PPUSH
17216: CALL 17262 0 5
17220: ST_TO_ADDR
// if kdo then
17221: LD_VAR 0 8
17225: IFFALSE 17249
// result := Say ( kdo , ident ) else
17227: LD_ADDR_VAR 0 7
17231: PUSH
17232: LD_VAR 0 8
17236: PPUSH
17237: LD_VAR 0 2
17241: PPUSH
17242: CALL_OW 88
17246: ST_TO_ADDR
17247: GO 17257
// result := false ;
17249: LD_ADDR_VAR 0 7
17253: PUSH
17254: LD_INT 0
17256: ST_TO_ADDR
// end ;
17257: LD_VAR 0 7
17261: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
17262: LD_INT 0
17264: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
17265: LD_ADDR_VAR 0 1
17269: PUSH
17270: LD_VAR 0 1
17274: PPUSH
17275: LD_INT 21
17277: PUSH
17278: LD_INT 1
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PUSH
17285: LD_INT 22
17287: PUSH
17288: LD_VAR 0 2
17292: PUSH
17293: EMPTY
17294: LIST
17295: LIST
17296: PUSH
17297: LD_INT 3
17299: PUSH
17300: LD_INT 23
17302: PUSH
17303: LD_INT 0
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: LIST
17314: LIST
17315: PPUSH
17316: CALL_OW 72
17320: ST_TO_ADDR
// if sex <> 0 then
17321: LD_VAR 0 3
17325: PUSH
17326: LD_INT 0
17328: NONEQUAL
17329: IFFALSE 17358
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
17331: LD_ADDR_VAR 0 1
17335: PUSH
17336: LD_VAR 0 1
17340: PPUSH
17341: LD_INT 26
17343: PUSH
17344: LD_VAR 0 3
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: PPUSH
17353: CALL_OW 72
17357: ST_TO_ADDR
// if Hclass <> 0 then
17358: LD_VAR 0 4
17362: PUSH
17363: LD_INT 0
17365: NONEQUAL
17366: IFFALSE 17395
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
17368: LD_ADDR_VAR 0 1
17372: PUSH
17373: LD_VAR 0 1
17377: PPUSH
17378: LD_INT 25
17380: PUSH
17381: LD_VAR 0 4
17385: PUSH
17386: EMPTY
17387: LIST
17388: LIST
17389: PPUSH
17390: CALL_OW 72
17394: ST_TO_ADDR
// if index <= 0 then
17395: LD_VAR 0 5
17399: PUSH
17400: LD_INT 0
17402: LESSEQUAL
17403: IFFALSE 17413
// index := 1 ;
17405: LD_ADDR_VAR 0 5
17409: PUSH
17410: LD_INT 1
17412: ST_TO_ADDR
// if lidi >= index then
17413: LD_VAR 0 1
17417: PUSH
17418: LD_VAR 0 5
17422: GREATEREQUAL
17423: IFFALSE 17443
// result := lidi [ index ] else
17425: LD_ADDR_VAR 0 6
17429: PUSH
17430: LD_VAR 0 1
17434: PUSH
17435: LD_VAR 0 5
17439: ARRAY
17440: ST_TO_ADDR
17441: GO 17451
// result := 0 ;
17443: LD_ADDR_VAR 0 6
17447: PUSH
17448: LD_INT 0
17450: ST_TO_ADDR
// end ;
17451: LD_VAR 0 6
17455: RET
// export function add ( list , list1 ) ; begin
17456: LD_INT 0
17458: PPUSH
// if list = 0 then
17459: LD_VAR 0 1
17463: PUSH
17464: LD_INT 0
17466: EQUAL
17467: IFFALSE 17476
// list := [ ] ;
17469: LD_ADDR_VAR 0 1
17473: PUSH
17474: EMPTY
17475: ST_TO_ADDR
// if list1 = 0 then
17476: LD_VAR 0 2
17480: PUSH
17481: LD_INT 0
17483: EQUAL
17484: IFFALSE 17493
// list1 := [ ] ;
17486: LD_ADDR_VAR 0 2
17490: PUSH
17491: EMPTY
17492: ST_TO_ADDR
// result := list ^ list1 ;
17493: LD_ADDR_VAR 0 3
17497: PUSH
17498: LD_VAR 0 1
17502: PUSH
17503: LD_VAR 0 2
17507: ADD
17508: ST_TO_ADDR
// end ;
17509: LD_VAR 0 3
17513: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
17514: LD_INT 0
17516: PPUSH
17517: PPUSH
17518: PPUSH
17519: PPUSH
// l1 := [ ] ;
17520: LD_ADDR_VAR 0 3
17524: PUSH
17525: EMPTY
17526: ST_TO_ADDR
// l2 := [ ] ;
17527: LD_ADDR_VAR 0 4
17531: PUSH
17532: EMPTY
17533: ST_TO_ADDR
// for i := 1 to list div 2 do
17534: LD_ADDR_VAR 0 5
17538: PUSH
17539: DOUBLE
17540: LD_INT 1
17542: DEC
17543: ST_TO_ADDR
17544: LD_VAR 0 1
17548: PUSH
17549: LD_INT 2
17551: DIV
17552: PUSH
17553: FOR_TO
17554: IFFALSE 17580
// begin l1 := l1 ^ list [ i ] ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_VAR 0 3
17565: PUSH
17566: LD_VAR 0 1
17570: PUSH
17571: LD_VAR 0 5
17575: ARRAY
17576: ADD
17577: ST_TO_ADDR
// end ;
17578: GO 17553
17580: POP
17581: POP
// l2 := list diff l1 ;
17582: LD_ADDR_VAR 0 4
17586: PUSH
17587: LD_VAR 0 1
17591: PUSH
17592: LD_VAR 0 3
17596: DIFF
17597: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
17598: LD_ADDR_VAR 0 2
17602: PUSH
17603: LD_VAR 0 3
17607: PUSH
17608: EMPTY
17609: LIST
17610: PUSH
17611: LD_VAR 0 4
17615: PUSH
17616: EMPTY
17617: LIST
17618: ADD
17619: ST_TO_ADDR
// end ;
17620: LD_VAR 0 2
17624: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
17625: LD_INT 0
17627: PPUSH
// if not hinty_co_byli then
17628: LD_EXP 89
17632: NOT
17633: IFFALSE 17642
// hinty_co_byli := [ ] ;
17635: LD_ADDR_EXP 89
17639: PUSH
17640: EMPTY
17641: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
17642: LD_VAR 0 1
17646: PUSH
17647: LD_EXP 89
17651: IN
17652: NOT
17653: IFFALSE 17680
// begin hinty_co_byli := hinty_co_byli ^ ident ;
17655: LD_ADDR_EXP 89
17659: PUSH
17660: LD_EXP 89
17664: PUSH
17665: LD_VAR 0 1
17669: ADD
17670: ST_TO_ADDR
// Hint ( ident ) ;
17671: LD_VAR 0 1
17675: PPUSH
17676: CALL_OW 339
// end ; end ; end_of_file
17680: LD_VAR 0 2
17684: RET
// export people , sol , sci , mec , eng ; var cars , cargo , scout , attack , defence ; var scout1 , scout2 ; var builds , forts ; var scout1_pb , scout1_pr , scout1_ptr1 , scout1_ptl1 , scout1_ptr2 , scout1_pta , scout1_pl , scout1_pa , scout1_pd1 , scout1_pd2 ; var broken ; var attack_l , attack_m , attack_r ; var to_defence , to_attack , to_scout , to_cargo ; var sec ; every 0 0$0.1 do var temp1 ;
17685: GO 17687
17687: DISABLE
17688: LD_INT 0
17690: PPUSH
// begin to_defence := false ;
17691: LD_ADDR_LOC 25
17695: PUSH
17696: LD_INT 0
17698: ST_TO_ADDR
// to_attack := false ;
17699: LD_ADDR_LOC 26
17703: PUSH
17704: LD_INT 0
17706: ST_TO_ADDR
// to_scout := false ;
17707: LD_ADDR_LOC 27
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ f_side , russians ] ) ;
17715: LD_ADDR_VAR 0 1
17719: PUSH
17720: LD_INT 22
17722: PUSH
17723: LD_EXP 2
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: PPUSH
17732: CALL_OW 69
17736: ST_TO_ADDR
// ComRemember ( temp1 ) ;
17737: LD_VAR 0 1
17741: PPUSH
17742: CALL_OW 143
// people := UnitFilter ( temp1 , [ f_type , unit_human ] ) ;
17746: LD_ADDR_EXP 90
17750: PUSH
17751: LD_VAR 0 1
17755: PPUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 1
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PPUSH
17766: CALL_OW 72
17770: ST_TO_ADDR
// sol := UnitFilter ( people , [ f_class , class_soldier ] ) ;
17771: LD_ADDR_EXP 91
17775: PUSH
17776: LD_EXP 90
17780: PPUSH
17781: LD_INT 25
17783: PUSH
17784: LD_INT 1
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: PPUSH
17791: CALL_OW 72
17795: ST_TO_ADDR
// sci := UnitFilter ( people , [ f_class , class_scientistic ] ) ;
17796: LD_ADDR_EXP 92
17800: PUSH
17801: LD_EXP 90
17805: PPUSH
17806: LD_INT 25
17808: PUSH
17809: LD_INT 4
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: PPUSH
17816: CALL_OW 72
17820: ST_TO_ADDR
// mec := UnitFilter ( people , [ f_class , class_mechanic ] ) ;
17821: LD_ADDR_EXP 93
17825: PUSH
17826: LD_EXP 90
17830: PPUSH
17831: LD_INT 25
17833: PUSH
17834: LD_INT 3
17836: PUSH
17837: EMPTY
17838: LIST
17839: LIST
17840: PPUSH
17841: CALL_OW 72
17845: ST_TO_ADDR
// eng := UnitFilter ( people , [ f_class , class_engineer ] ) ;
17846: LD_ADDR_EXP 94
17850: PUSH
17851: LD_EXP 90
17855: PPUSH
17856: LD_INT 25
17858: PUSH
17859: LD_INT 2
17861: PUSH
17862: EMPTY
17863: LIST
17864: LIST
17865: PPUSH
17866: CALL_OW 72
17870: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ f_type , unit_vehicle ] ) ;
17871: LD_ADDR_LOC 2
17875: PUSH
17876: LD_VAR 0 1
17880: PPUSH
17881: LD_INT 21
17883: PUSH
17884: LD_INT 2
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: PPUSH
17891: CALL_OW 72
17895: ST_TO_ADDR
// broken := [ ] ;
17896: LD_ADDR_LOC 21
17900: PUSH
17901: EMPTY
17902: ST_TO_ADDR
// cargo := [ cargo_1 ] ;
17903: LD_ADDR_LOC 3
17907: PUSH
17908: LD_INT 11
17910: PUSH
17911: EMPTY
17912: LIST
17913: ST_TO_ADDR
// scout := [ scout_1 , scout_2 ] ;
17914: LD_ADDR_LOC 4
17918: PUSH
17919: LD_INT 10
17921: PUSH
17922: LD_INT 42
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: ST_TO_ADDR
// scout1 := [ scout_1 ] ;
17929: LD_ADDR_LOC 7
17933: PUSH
17934: LD_INT 10
17936: PUSH
17937: EMPTY
17938: LIST
17939: ST_TO_ADDR
// scout2 := [ scout_2 ] ;
17940: LD_ADDR_LOC 8
17944: PUSH
17945: LD_INT 42
17947: PUSH
17948: EMPTY
17949: LIST
17950: ST_TO_ADDR
// defence := [ scout_2 , defence_1 , defence_2 ] ;
17951: LD_ADDR_LOC 6
17955: PUSH
17956: LD_INT 42
17958: PUSH
17959: LD_INT 12
17961: PUSH
17962: LD_INT 43
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
// attack := [ scout_1 , scout_2 , defence_1 ] ;
17970: LD_ADDR_LOC 5
17974: PUSH
17975: LD_INT 10
17977: PUSH
17978: LD_INT 42
17980: PUSH
17981: LD_INT 12
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: ST_TO_ADDR
// builds := UnitFilter ( temp1 , [ f_type , unit_building ] ) ;
17989: LD_ADDR_LOC 9
17993: PUSH
17994: LD_VAR 0 1
17998: PPUSH
17999: LD_INT 21
18001: PUSH
18002: LD_INT 3
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PPUSH
18009: CALL_OW 72
18013: ST_TO_ADDR
// forts := [ fort1 , fort2 , fort3 , fort4 , fort5 ] ;
18014: LD_ADDR_LOC 10
18018: PUSH
18019: LD_INT 3
18021: PUSH
18022: LD_INT 2
18024: PUSH
18025: LD_INT 39
18027: PUSH
18028: LD_INT 4
18030: PUSH
18031: LD_INT 45
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: ST_TO_ADDR
// scout1_pb := [ 92 , 53 ] ;
18041: LD_ADDR_LOC 11
18045: PUSH
18046: LD_INT 92
18048: PUSH
18049: LD_INT 53
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: ST_TO_ADDR
// scout1_pr := [ 102 , 56 , 110 , 59 , 119 , 60 , 120 , 64 , 109 , 60 , 98 , 55 ] ;
18056: LD_ADDR_LOC 12
18060: PUSH
18061: LD_INT 102
18063: PUSH
18064: LD_INT 56
18066: PUSH
18067: LD_INT 110
18069: PUSH
18070: LD_INT 59
18072: PUSH
18073: LD_INT 119
18075: PUSH
18076: LD_INT 60
18078: PUSH
18079: LD_INT 120
18081: PUSH
18082: LD_INT 64
18084: PUSH
18085: LD_INT 109
18087: PUSH
18088: LD_INT 60
18090: PUSH
18091: LD_INT 98
18093: PUSH
18094: LD_INT 55
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: ST_TO_ADDR
// scout1_ptr1 := [ 95 , 50 , 92 , 46 , 90 , 39 , 87 , 30 , - 8 , 97 , 25 , 80 , 32 , 82 , 42 ] ;
18111: LD_ADDR_LOC 13
18115: PUSH
18116: LD_INT 95
18118: PUSH
18119: LD_INT 50
18121: PUSH
18122: LD_INT 92
18124: PUSH
18125: LD_INT 46
18127: PUSH
18128: LD_INT 90
18130: PUSH
18131: LD_INT 39
18133: PUSH
18134: LD_INT 87
18136: PUSH
18137: LD_INT 30
18139: PUSH
18140: LD_INT 8
18142: NEG
18143: PUSH
18144: LD_INT 97
18146: PUSH
18147: LD_INT 25
18149: PUSH
18150: LD_INT 80
18152: PUSH
18153: LD_INT 32
18155: PUSH
18156: LD_INT 82
18158: PUSH
18159: LD_INT 42
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: LIST
18167: LIST
18168: LIST
18169: LIST
18170: LIST
18171: LIST
18172: LIST
18173: LIST
18174: LIST
18175: LIST
18176: LIST
18177: LIST
18178: ST_TO_ADDR
// scout1_ptr2 := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 69 , 21 , 82 , 39 , 87 , 48 ] ;
18179: LD_ADDR_LOC 15
18183: PUSH
18184: LD_INT 90
18186: PUSH
18187: LD_INT 42
18189: PUSH
18190: LD_INT 91
18192: PUSH
18193: LD_INT 30
18195: PUSH
18196: LD_INT 81
18198: PUSH
18199: LD_INT 13
18201: PUSH
18202: LD_INT 68
18204: PUSH
18205: LD_INT 12
18207: PUSH
18208: LD_INT 67
18210: PUSH
18211: LD_INT 21
18213: PUSH
18214: LD_INT 57
18216: PUSH
18217: LD_INT 25
18219: PUSH
18220: LD_INT 69
18222: PUSH
18223: LD_INT 21
18225: PUSH
18226: LD_INT 82
18228: PUSH
18229: LD_INT 39
18231: PUSH
18232: LD_INT 87
18234: PUSH
18235: LD_INT 48
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: ST_TO_ADDR
// scout1_pta := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 41 , 20 , 29 , 23 , 42 , 41 , 85 , 49 ] ;
18258: LD_ADDR_LOC 16
18262: PUSH
18263: LD_INT 90
18265: PUSH
18266: LD_INT 42
18268: PUSH
18269: LD_INT 91
18271: PUSH
18272: LD_INT 30
18274: PUSH
18275: LD_INT 81
18277: PUSH
18278: LD_INT 13
18280: PUSH
18281: LD_INT 68
18283: PUSH
18284: LD_INT 12
18286: PUSH
18287: LD_INT 67
18289: PUSH
18290: LD_INT 21
18292: PUSH
18293: LD_INT 57
18295: PUSH
18296: LD_INT 25
18298: PUSH
18299: LD_INT 41
18301: PUSH
18302: LD_INT 20
18304: PUSH
18305: LD_INT 29
18307: PUSH
18308: LD_INT 23
18310: PUSH
18311: LD_INT 42
18313: PUSH
18314: LD_INT 41
18316: PUSH
18317: LD_INT 85
18319: PUSH
18320: LD_INT 49
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: LIST
18330: LIST
18331: LIST
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: LIST
18343: LIST
18344: ST_TO_ADDR
// scout1_ptl1 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 30 , 25 , 31 , 16 , 34 , 36 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18345: LD_ADDR_LOC 14
18349: PUSH
18350: LD_INT 68
18352: PUSH
18353: LD_INT 88
18355: PUSH
18356: LD_INT 51
18358: PUSH
18359: LD_INT 78
18361: PUSH
18362: LD_INT 40
18364: PUSH
18365: LD_INT 57
18367: PUSH
18368: LD_INT 43
18370: PUSH
18371: LD_INT 42
18373: PUSH
18374: LD_INT 30
18376: PUSH
18377: LD_INT 25
18379: PUSH
18380: LD_INT 31
18382: PUSH
18383: LD_INT 16
18385: PUSH
18386: LD_INT 34
18388: PUSH
18389: LD_INT 36
18391: PUSH
18392: LD_INT 45
18394: PUSH
18395: LD_INT 69
18397: PUSH
18398: LD_INT 64
18400: PUSH
18401: LD_INT 87
18403: PUSH
18404: LD_INT 98
18406: PUSH
18407: LD_INT 97
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: LIST
18424: LIST
18425: LIST
18426: LIST
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: ST_TO_ADDR
// scout1_pl := [ 84 , 50 , 70 , 47 , 67 , 46 , 62 , 49 , 55 , 49 , - 5 , 50 , 43 , 60 , 49 , 71 , 47 , 83 , 49 ] ;
18432: LD_ADDR_LOC 17
18436: PUSH
18437: LD_INT 84
18439: PUSH
18440: LD_INT 50
18442: PUSH
18443: LD_INT 70
18445: PUSH
18446: LD_INT 47
18448: PUSH
18449: LD_INT 67
18451: PUSH
18452: LD_INT 46
18454: PUSH
18455: LD_INT 62
18457: PUSH
18458: LD_INT 49
18460: PUSH
18461: LD_INT 55
18463: PUSH
18464: LD_INT 49
18466: PUSH
18467: LD_INT 5
18469: NEG
18470: PUSH
18471: LD_INT 50
18473: PUSH
18474: LD_INT 43
18476: PUSH
18477: LD_INT 60
18479: PUSH
18480: LD_INT 49
18482: PUSH
18483: LD_INT 71
18485: PUSH
18486: LD_INT 47
18488: PUSH
18489: LD_INT 83
18491: PUSH
18492: LD_INT 49
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: ST_TO_ADDR
// scout1_pa := [ 84 , 50 , 70 , 47 , 60 , 44 , 53 , 44 , 43 , 41 , 39 , 57 , 43 , 71 , 52 , 82 , 63 , 87 , 109 , 95 ] ;
18516: LD_ADDR_LOC 18
18520: PUSH
18521: LD_INT 84
18523: PUSH
18524: LD_INT 50
18526: PUSH
18527: LD_INT 70
18529: PUSH
18530: LD_INT 47
18532: PUSH
18533: LD_INT 60
18535: PUSH
18536: LD_INT 44
18538: PUSH
18539: LD_INT 53
18541: PUSH
18542: LD_INT 44
18544: PUSH
18545: LD_INT 43
18547: PUSH
18548: LD_INT 41
18550: PUSH
18551: LD_INT 39
18553: PUSH
18554: LD_INT 57
18556: PUSH
18557: LD_INT 43
18559: PUSH
18560: LD_INT 71
18562: PUSH
18563: LD_INT 52
18565: PUSH
18566: LD_INT 82
18568: PUSH
18569: LD_INT 63
18571: PUSH
18572: LD_INT 87
18574: PUSH
18575: LD_INT 109
18577: PUSH
18578: LD_INT 95
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: LIST
18600: LIST
18601: LIST
18602: ST_TO_ADDR
// scout1_pd1 := [ 71 , 81 , 62 , 63 , 61 , 74 , 79 , 96 ] ;
18603: LD_ADDR_LOC 19
18607: PUSH
18608: LD_INT 71
18610: PUSH
18611: LD_INT 81
18613: PUSH
18614: LD_INT 62
18616: PUSH
18617: LD_INT 63
18619: PUSH
18620: LD_INT 61
18622: PUSH
18623: LD_INT 74
18625: PUSH
18626: LD_INT 79
18628: PUSH
18629: LD_INT 96
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: ST_TO_ADDR
// scout1_pd2 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18642: LD_ADDR_LOC 20
18646: PUSH
18647: LD_INT 68
18649: PUSH
18650: LD_INT 88
18652: PUSH
18653: LD_INT 51
18655: PUSH
18656: LD_INT 78
18658: PUSH
18659: LD_INT 40
18661: PUSH
18662: LD_INT 57
18664: PUSH
18665: LD_INT 43
18667: PUSH
18668: LD_INT 42
18670: PUSH
18671: LD_INT 45
18673: PUSH
18674: LD_INT 69
18676: PUSH
18677: LD_INT 64
18679: PUSH
18680: LD_INT 87
18682: PUSH
18683: LD_INT 98
18685: PUSH
18686: LD_INT 97
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: LIST
18701: LIST
18702: LIST
18703: LIST
18704: ST_TO_ADDR
// attack_l := [ 60 , 86 , 37 , 44 ] ;
18705: LD_ADDR_LOC 22
18709: PUSH
18710: LD_INT 60
18712: PUSH
18713: LD_INT 86
18715: PUSH
18716: LD_INT 37
18718: PUSH
18719: LD_INT 44
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: ST_TO_ADDR
// attack_m := [ 89 , 53 , 41 , 42 ] ;
18728: LD_ADDR_LOC 23
18732: PUSH
18733: LD_INT 89
18735: PUSH
18736: LD_INT 53
18738: PUSH
18739: LD_INT 41
18741: PUSH
18742: LD_INT 42
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: ST_TO_ADDR
// attack_r := [ 88 , 55 , 82 , 13 ] ;
18751: LD_ADDR_LOC 24
18755: PUSH
18756: LD_INT 88
18758: PUSH
18759: LD_INT 55
18761: PUSH
18762: LD_INT 82
18764: PUSH
18765: LD_INT 13
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: ST_TO_ADDR
// end ;
18774: PPOPN 1
18776: END
// every 0 0$6.0 do
18777: GO 18779
18779: DISABLE
// begin depart ( scout diff broken , sol union mec , scout1_pb , true , false ) ;
18780: LD_LOC 4
18784: PUSH
18785: LD_LOC 21
18789: DIFF
18790: PPUSH
18791: LD_EXP 91
18795: PUSH
18796: LD_EXP 93
18800: UNION
18801: PPUSH
18802: LD_LOC 11
18806: PPUSH
18807: LD_INT 1
18809: PPUSH
18810: LD_INT 0
18812: PPUSH
18813: CALL 16901 0 5
// take_path ( scout1 diff broken , scout1_pr , true ) ;
18817: LD_LOC 7
18821: PUSH
18822: LD_LOC 21
18826: DIFF
18827: PPUSH
18828: LD_LOC 12
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: CALL 15937 0 3
// take_path ( scout2 diff broken , scout1_pl , true ) ;
18840: LD_LOC 8
18844: PUSH
18845: LD_LOC 21
18849: DIFF
18850: PPUSH
18851: LD_LOC 17
18855: PPUSH
18856: LD_INT 1
18858: PPUSH
18859: CALL 15937 0 3
// AddComReturn ( scout diff broken ) ;
18863: LD_LOC 4
18867: PUSH
18868: LD_LOC 21
18872: DIFF
18873: PPUSH
18874: CALL_OW 204
// end ;
18878: END
// every 0 0$56.0 + 0 0$10 do var x , ok , i ;
18879: GO 18881
18881: DISABLE
18882: LD_INT 0
18884: PPUSH
18885: PPUSH
18886: PPUSH
// begin ok := true ;
18887: LD_ADDR_VAR 0 2
18891: PUSH
18892: LD_INT 1
18894: ST_TO_ADDR
// for i in scout do
18895: LD_ADDR_VAR 0 3
18899: PUSH
18900: LD_LOC 4
18904: PUSH
18905: FOR_IN
18906: IFFALSE 18929
// begin if HasTask ( i ) then
18908: LD_VAR 0 3
18912: PPUSH
18913: CALL_OW 314
18917: IFFALSE 18927
// ok := false ;
18919: LD_ADDR_VAR 0 2
18923: PUSH
18924: LD_INT 0
18926: ST_TO_ADDR
// end ;
18927: GO 18905
18929: POP
18930: POP
// if ok then
18931: LD_VAR 0 2
18935: IFFALSE 19827
// begin x := Rand ( 1 , 7 ) ;
18937: LD_ADDR_VAR 0 1
18941: PUSH
18942: LD_INT 1
18944: PPUSH
18945: LD_INT 7
18947: PPUSH
18948: CALL_OW 12
18952: ST_TO_ADDR
// if go_up then
18953: LD_EXP 62
18957: IFFALSE 18983
// begin x := Rand ( 3 , 4 ) ;
18959: LD_ADDR_VAR 0 1
18963: PUSH
18964: LD_INT 3
18966: PPUSH
18967: LD_INT 4
18969: PPUSH
18970: CALL_OW 12
18974: ST_TO_ADDR
// go_up := false ;
18975: LD_ADDR_EXP 62
18979: PUSH
18980: LD_INT 0
18982: ST_TO_ADDR
// end ; case x of 1 :
18983: LD_VAR 0 1
18987: PUSH
18988: LD_INT 1
18990: DOUBLE
18991: EQUAL
18992: IFTRUE 18996
18994: GO 19128
18996: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
18997: LD_LOC 7
19001: PUSH
19002: LD_LOC 21
19006: DIFF
19007: PPUSH
19008: LD_EXP 91
19012: PPUSH
19013: LD_LOC 11
19017: PPUSH
19018: LD_INT 1
19020: PPUSH
19021: LD_INT 0
19023: PPUSH
19024: CALL 16901 0 5
// if more_scouting then
19028: LD_EXP 61
19032: IFFALSE 19057
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19034: LD_LOC 7
19038: PUSH
19039: LD_LOC 21
19043: DIFF
19044: PPUSH
19045: LD_LOC 13
19049: PPUSH
19050: LD_INT 1
19052: PPUSH
19053: CALL 15937 0 3
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19057: LD_LOC 7
19061: PUSH
19062: LD_LOC 21
19066: DIFF
19067: PPUSH
19068: LD_LOC 17
19072: PPUSH
19073: LD_INT 1
19075: PPUSH
19076: CALL 15937 0 3
// depart ( scout2 diff broken , sol , scout1_pd1 , true , false ) ;
19080: LD_LOC 8
19084: PUSH
19085: LD_LOC 21
19089: DIFF
19090: PPUSH
19091: LD_EXP 91
19095: PPUSH
19096: LD_LOC 19
19100: PPUSH
19101: LD_INT 1
19103: PPUSH
19104: LD_INT 0
19106: PPUSH
19107: CALL 16901 0 5
// AddComReturn ( scout diff broken ) ;
19111: LD_LOC 4
19115: PUSH
19116: LD_LOC 21
19120: DIFF
19121: PPUSH
19122: CALL_OW 204
// end ; 2 :
19126: GO 19827
19128: LD_INT 2
19130: DOUBLE
19131: EQUAL
19132: IFTRUE 19136
19134: GO 19245
19136: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
19137: LD_LOC 7
19141: PUSH
19142: LD_LOC 21
19146: DIFF
19147: PPUSH
19148: LD_EXP 91
19152: PPUSH
19153: LD_LOC 11
19157: PPUSH
19158: LD_INT 1
19160: PPUSH
19161: LD_INT 0
19163: PPUSH
19164: CALL 16901 0 5
// if more_scouting then
19168: LD_EXP 61
19172: IFFALSE 19197
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19174: LD_LOC 7
19178: PUSH
19179: LD_LOC 21
19183: DIFF
19184: PPUSH
19185: LD_LOC 13
19189: PPUSH
19190: LD_INT 1
19192: PPUSH
19193: CALL 15937 0 3
// depart ( scout2 diff broken , sol , scout1_pd2 , true , false ) ;
19197: LD_LOC 8
19201: PUSH
19202: LD_LOC 21
19206: DIFF
19207: PPUSH
19208: LD_EXP 91
19212: PPUSH
19213: LD_LOC 20
19217: PPUSH
19218: LD_INT 1
19220: PPUSH
19221: LD_INT 0
19223: PPUSH
19224: CALL 16901 0 5
// AddComReturn ( scout1 diff broken ) ;
19228: LD_LOC 7
19232: PUSH
19233: LD_LOC 21
19237: DIFF
19238: PPUSH
19239: CALL_OW 204
// end ; 3 :
19243: GO 19827
19245: LD_INT 3
19247: DOUBLE
19248: EQUAL
19249: IFTRUE 19253
19251: GO 19331
19253: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19254: LD_LOC 4
19258: PUSH
19259: LD_LOC 21
19263: DIFF
19264: PPUSH
19265: LD_EXP 91
19269: PPUSH
19270: LD_LOC 11
19274: PPUSH
19275: LD_INT 1
19277: PPUSH
19278: LD_INT 0
19280: PPUSH
19281: CALL 16901 0 5
// if more_scouting then
19285: LD_EXP 61
19289: IFFALSE 19314
// take_path ( scout diff broken , scout1_ptr2 , true ) ;
19291: LD_LOC 4
19295: PUSH
19296: LD_LOC 21
19300: DIFF
19301: PPUSH
19302: LD_LOC 15
19306: PPUSH
19307: LD_INT 1
19309: PPUSH
19310: CALL 15937 0 3
// AddComReturn ( scout diff broken ) ;
19314: LD_LOC 4
19318: PUSH
19319: LD_LOC 21
19323: DIFF
19324: PPUSH
19325: CALL_OW 204
// end ; 4 :
19329: GO 19827
19331: LD_INT 4
19333: DOUBLE
19334: EQUAL
19335: IFTRUE 19339
19337: GO 19458
19339: POP
// begin if more_scouting then
19340: LD_EXP 61
19344: IFFALSE 19379
// depart ( scout diff broken , sol , scout1_pta , true , false ) else
19346: LD_LOC 4
19350: PUSH
19351: LD_LOC 21
19355: DIFF
19356: PPUSH
19357: LD_EXP 91
19361: PPUSH
19362: LD_LOC 16
19366: PPUSH
19367: LD_INT 1
19369: PPUSH
19370: LD_INT 0
19372: PPUSH
19373: CALL 16901 0 5
19377: GO 19441
// begin depart ( scout1 diff broken , sol , scout1_pd2 , true , false ) ;
19379: LD_LOC 7
19383: PUSH
19384: LD_LOC 21
19388: DIFF
19389: PPUSH
19390: LD_EXP 91
19394: PPUSH
19395: LD_LOC 20
19399: PPUSH
19400: LD_INT 1
19402: PPUSH
19403: LD_INT 0
19405: PPUSH
19406: CALL 16901 0 5
// depart ( scout2 diff broken , sol , scout1_ptr1 , true , false ) ;
19410: LD_LOC 8
19414: PUSH
19415: LD_LOC 21
19419: DIFF
19420: PPUSH
19421: LD_EXP 91
19425: PPUSH
19426: LD_LOC 13
19430: PPUSH
19431: LD_INT 1
19433: PPUSH
19434: LD_INT 0
19436: PPUSH
19437: CALL 16901 0 5
// end ; AddComReturn ( scout diff broken ) ;
19441: LD_LOC 4
19445: PUSH
19446: LD_LOC 21
19450: DIFF
19451: PPUSH
19452: CALL_OW 204
// end ; 5 :
19456: GO 19827
19458: LD_INT 5
19460: DOUBLE
19461: EQUAL
19462: IFTRUE 19466
19464: GO 19610
19466: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19467: LD_LOC 4
19471: PUSH
19472: LD_LOC 21
19476: DIFF
19477: PPUSH
19478: LD_EXP 91
19482: PPUSH
19483: LD_LOC 11
19487: PPUSH
19488: LD_INT 1
19490: PPUSH
19491: LD_INT 0
19493: PPUSH
19494: CALL 16901 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19498: LD_LOC 7
19502: PUSH
19503: LD_LOC 21
19507: DIFF
19508: PPUSH
19509: LD_LOC 17
19513: PPUSH
19514: LD_INT 1
19516: PPUSH
19517: CALL 15937 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19521: LD_LOC 8
19525: PUSH
19526: LD_LOC 21
19530: DIFF
19531: PPUSH
19532: LD_INT 20
19534: PPUSH
19535: CALL_OW 202
// if more_scouting then
19539: LD_EXP 61
19543: IFFALSE 19570
// take_path ( scout2 diff broken , scout1_ptl1 , true ) else
19545: LD_LOC 8
19549: PUSH
19550: LD_LOC 21
19554: DIFF
19555: PPUSH
19556: LD_LOC 14
19560: PPUSH
19561: LD_INT 1
19563: PPUSH
19564: CALL 15937 0 3
19568: GO 19593
// take_path ( scout2 diff broken , scout1_pd2 , true ) ;
19570: LD_LOC 8
19574: PUSH
19575: LD_LOC 21
19579: DIFF
19580: PPUSH
19581: LD_LOC 20
19585: PPUSH
19586: LD_INT 1
19588: PPUSH
19589: CALL 15937 0 3
// AddComReturn ( scout diff broken ) ;
19593: LD_LOC 4
19597: PUSH
19598: LD_LOC 21
19602: DIFF
19603: PPUSH
19604: CALL_OW 204
// end ; 6 :
19608: GO 19827
19610: LD_INT 6
19612: DOUBLE
19613: EQUAL
19614: IFTRUE 19618
19616: GO 19708
19618: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19619: LD_LOC 4
19623: PUSH
19624: LD_LOC 21
19628: DIFF
19629: PPUSH
19630: LD_EXP 91
19634: PPUSH
19635: LD_LOC 11
19639: PPUSH
19640: LD_INT 1
19642: PPUSH
19643: LD_INT 0
19645: PPUSH
19646: CALL 16901 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19650: LD_LOC 7
19654: PUSH
19655: LD_LOC 21
19659: DIFF
19660: PPUSH
19661: LD_LOC 17
19665: PPUSH
19666: LD_INT 1
19668: PPUSH
19669: CALL 15937 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19673: LD_LOC 8
19677: PUSH
19678: LD_LOC 21
19682: DIFF
19683: PPUSH
19684: LD_INT 20
19686: PPUSH
19687: CALL_OW 202
// AddComReturn ( scout diff broken ) ;
19691: LD_LOC 4
19695: PUSH
19696: LD_LOC 21
19700: DIFF
19701: PPUSH
19702: CALL_OW 204
// end ; 7 :
19706: GO 19827
19708: LD_INT 7
19710: DOUBLE
19711: EQUAL
19712: IFTRUE 19716
19714: GO 19826
19716: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19717: LD_LOC 4
19721: PUSH
19722: LD_LOC 21
19726: DIFF
19727: PPUSH
19728: LD_EXP 91
19732: PPUSH
19733: LD_LOC 11
19737: PPUSH
19738: LD_INT 1
19740: PPUSH
19741: LD_INT 0
19743: PPUSH
19744: CALL 16901 0 5
// take_path ( scout1 diff broken , scout1_pa , true ) ;
19748: LD_LOC 7
19752: PUSH
19753: LD_LOC 21
19757: DIFF
19758: PPUSH
19759: LD_LOC 18
19763: PPUSH
19764: LD_INT 1
19766: PPUSH
19767: CALL 15937 0 3
// AddComReturn ( scout2 diff broken ) ;
19771: LD_LOC 8
19775: PUSH
19776: LD_LOC 21
19780: DIFF
19781: PPUSH
19782: CALL_OW 204
// take_path ( scout2 diff broken , scout1_pd1 , true ) ;
19786: LD_LOC 8
19790: PUSH
19791: LD_LOC 21
19795: DIFF
19796: PPUSH
19797: LD_LOC 19
19801: PPUSH
19802: LD_INT 1
19804: PPUSH
19805: CALL 15937 0 3
// AddComReturn ( scout diff broken ) ;
19809: LD_LOC 4
19813: PUSH
19814: LD_LOC 21
19818: DIFF
19819: PPUSH
19820: CALL_OW 204
// end ; end ;
19824: GO 19827
19826: POP
// end ; enable ;
19827: ENABLE
// end ;
19828: PPOPN 3
19830: END
// every 0 0$7.0 do
19831: GO 19833
19833: DISABLE
// begin full_forts ( forts , sol ) ;
19834: LD_LOC 10
19838: PPUSH
19839: LD_EXP 91
19843: PPUSH
19844: CALL 16629 0 2
// enable ;
19848: ENABLE
// end ;
19849: END
// every 0 0$5.0 do var i ;
19850: GO 19852
19852: DISABLE
19853: LD_INT 0
19855: PPUSH
// begin for i in mec do
19856: LD_ADDR_VAR 0 1
19860: PUSH
19861: LD_EXP 93
19865: PUSH
19866: FOR_IN
19867: IFFALSE 19927
// begin if not IsBusy ( i ) or not IsInArea ( i , base ) and GetSide ( i ) <> you then
19869: LD_VAR 0 1
19873: PPUSH
19874: CALL_OW 315
19878: NOT
19879: PUSH
19880: LD_VAR 0 1
19884: PPUSH
19885: LD_INT 5
19887: PPUSH
19888: CALL_OW 308
19892: NOT
19893: PUSH
19894: LD_VAR 0 1
19898: PPUSH
19899: CALL_OW 255
19903: PUSH
19904: LD_EXP 1
19908: NONEQUAL
19909: AND
19910: OR
19911: IFFALSE 19925
// ComEnterUnit ( i , fact1 ) ;
19913: LD_VAR 0 1
19917: PPUSH
19918: LD_INT 35
19920: PPUSH
19921: CALL_OW 120
// end ;
19925: GO 19866
19927: POP
19928: POP
// enable ;
19929: ENABLE
// end ;
19930: PPOPN 1
19932: END
// every 0 0$5.0 do var i ;
19933: GO 19935
19935: DISABLE
19936: LD_INT 0
19938: PPUSH
// begin if under_attack then
19939: LD_EXP 64
19943: IFFALSE 20005
// for i in eng do
19945: LD_ADDR_VAR 0 1
19949: PUSH
19950: LD_EXP 94
19954: PUSH
19955: FOR_IN
19956: IFFALSE 20001
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
19958: LD_VAR 0 1
19962: PPUSH
19963: CALL_OW 315
19967: NOT
19968: PUSH
19969: LD_VAR 0 1
19973: PPUSH
19974: CALL_OW 255
19978: PUSH
19979: LD_EXP 1
19983: NONEQUAL
19984: AND
19985: IFFALSE 19999
// ComEnterUnit ( i , depot1 ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_INT 1
19994: PPUSH
19995: CALL_OW 120
// end else
19999: GO 19955
20001: POP
20002: POP
20003: GO 20012
// ComExitBuilding ( depot1 ) ;
20005: LD_INT 1
20007: PPUSH
20008: CALL_OW 122
// enable ;
20012: ENABLE
// end ;
20013: PPOPN 1
20015: END
// every 0 0$5.0 do var i ;
20016: GO 20018
20018: DISABLE
20019: LD_INT 0
20021: PPUSH
// begin for i in sci do
20022: LD_ADDR_VAR 0 1
20026: PUSH
20027: LD_EXP 92
20031: PUSH
20032: FOR_IN
20033: IFFALSE 20078
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 315
20044: NOT
20045: PUSH
20046: LD_VAR 0 1
20050: PPUSH
20051: CALL_OW 255
20055: PUSH
20056: LD_EXP 1
20060: NONEQUAL
20061: AND
20062: IFFALSE 20076
// ComEnterUnit ( i , lab1 ) ;
20064: LD_VAR 0 1
20068: PPUSH
20069: LD_INT 6
20071: PPUSH
20072: CALL_OW 120
// end ;
20076: GO 20032
20078: POP
20079: POP
// enable ;
20080: ENABLE
// end ;
20081: PPOPN 1
20083: END
// every 0 0$1.0 do var set_fuel , fuel ;
20084: GO 20086
20086: DISABLE
20087: LD_INT 0
20089: PPUSH
20090: PPUSH
// begin for set_fuel in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20091: LD_ADDR_VAR 0 1
20095: PUSH
20096: LD_INT 5
20098: PPUSH
20099: LD_INT 21
20101: PUSH
20102: LD_INT 2
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 22
20111: PUSH
20112: LD_EXP 2
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: PPUSH
20125: CALL_OW 70
20129: PUSH
20130: FOR_IN
20131: IFFALSE 20178
// begin fuel := GetFuel ( set_fuel ) ;
20133: LD_ADDR_VAR 0 2
20137: PUSH
20138: LD_VAR 0 1
20142: PPUSH
20143: CALL_OW 261
20147: ST_TO_ADDR
// if fuel <= 80 then
20148: LD_VAR 0 2
20152: PUSH
20153: LD_INT 80
20155: LESSEQUAL
20156: IFFALSE 20176
// SetFuel ( set_fuel , fuel + 20 ) ;
20158: LD_VAR 0 1
20162: PPUSH
20163: LD_VAR 0 2
20167: PUSH
20168: LD_INT 20
20170: PLUS
20171: PPUSH
20172: CALL_OW 240
// end ;
20176: GO 20130
20178: POP
20179: POP
// enable ;
20180: ENABLE
// end ;
20181: PPOPN 2
20183: END
// every 0 0$1.0 do var to_rep , prednost ;
20184: GO 20186
20186: DISABLE
20187: LD_INT 0
20189: PPUSH
20190: PPUSH
// begin prednost := FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) isect broken ;
20191: LD_ADDR_VAR 0 2
20195: PUSH
20196: LD_INT 5
20198: PPUSH
20199: LD_INT 21
20201: PUSH
20202: LD_INT 2
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PUSH
20209: LD_INT 22
20211: PUSH
20212: LD_EXP 2
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PPUSH
20225: CALL_OW 70
20229: PUSH
20230: LD_LOC 21
20234: ISECT
20235: ST_TO_ADDR
// if prednost then
20236: LD_VAR 0 2
20240: IFFALSE 20393
// for to_rep in prednost do
20242: LD_ADDR_VAR 0 1
20246: PUSH
20247: LD_VAR 0 2
20251: PUSH
20252: FOR_IN
20253: IFFALSE 20389
// begin if IsInArea ( to_rep , base ) then
20255: LD_VAR 0 1
20259: PPUSH
20260: LD_INT 5
20262: PPUSH
20263: CALL_OW 308
20267: IFFALSE 20387
// if GetLives ( to_rep ) < 1000 then
20269: LD_VAR 0 1
20273: PPUSH
20274: CALL_OW 256
20278: PUSH
20279: LD_INT 1000
20281: LESS
20282: IFFALSE 20362
// begin ComExitBuilding ( mec ) ;
20284: LD_EXP 93
20288: PPUSH
20289: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20293: LD_EXP 93
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20307: LD_VAR 0 1
20311: PPUSH
20312: CALL_OW 311
20316: PPUSH
20317: CALL_OW 257
20321: PUSH
20322: LD_INT 3
20324: EQUAL
20325: IFFALSE 20360
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20327: LD_VAR 0 1
20331: PPUSH
20332: CALL_OW 311
20336: PPUSH
20337: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20341: LD_VAR 0 1
20345: PPUSH
20346: CALL_OW 311
20350: PPUSH
20351: LD_VAR 0 1
20355: PPUSH
20356: CALL_OW 189
// end ; end else
20360: GO 20387
// begin broken := broken diff to_rep ;
20362: LD_ADDR_LOC 21
20366: PUSH
20367: LD_LOC 21
20371: PUSH
20372: LD_VAR 0 1
20376: DIFF
20377: ST_TO_ADDR
// ComReturn ( to_rep ) ;
20378: LD_VAR 0 1
20382: PPUSH
20383: CALL_OW 144
// end ; end else
20387: GO 20252
20389: POP
20390: POP
20391: GO 20544
// for to_rep in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20393: LD_ADDR_VAR 0 1
20397: PUSH
20398: LD_INT 5
20400: PPUSH
20401: LD_INT 21
20403: PUSH
20404: LD_INT 2
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: PUSH
20411: LD_INT 22
20413: PUSH
20414: LD_EXP 2
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: PPUSH
20427: CALL_OW 70
20431: PUSH
20432: FOR_IN
20433: IFFALSE 20542
// begin if IsInArea ( to_rep , base ) then
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 5
20442: PPUSH
20443: CALL_OW 308
20447: IFFALSE 20540
// if GetLives ( to_rep ) < 1000 then
20449: LD_VAR 0 1
20453: PPUSH
20454: CALL_OW 256
20458: PUSH
20459: LD_INT 1000
20461: LESS
20462: IFFALSE 20540
// begin ComExitBuilding ( mec ) ;
20464: LD_EXP 93
20468: PPUSH
20469: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20473: LD_EXP 93
20477: PPUSH
20478: LD_VAR 0 1
20482: PPUSH
20483: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20487: LD_VAR 0 1
20491: PPUSH
20492: CALL_OW 311
20496: PPUSH
20497: CALL_OW 257
20501: PUSH
20502: LD_INT 3
20504: EQUAL
20505: IFFALSE 20540
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20507: LD_VAR 0 1
20511: PPUSH
20512: CALL_OW 311
20516: PPUSH
20517: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20521: LD_VAR 0 1
20525: PPUSH
20526: CALL_OW 311
20530: PPUSH
20531: LD_VAR 0 1
20535: PPUSH
20536: CALL_OW 189
// end ; end ; end ;
20540: GO 20432
20542: POP
20543: POP
// enable ;
20544: ENABLE
// end ;
20545: PPOPN 2
20547: END
// every 0 0$0.5 do var i , a ;
20548: GO 20550
20550: DISABLE
20551: LD_INT 0
20553: PPUSH
20554: PPUSH
// begin for i in cars do
20555: LD_ADDR_VAR 0 1
20559: PUSH
20560: LD_LOC 2
20564: PUSH
20565: FOR_IN
20566: IFFALSE 20674
// begin if GetLives ( i ) < 550 then
20568: LD_VAR 0 1
20572: PPUSH
20573: CALL_OW 256
20577: PUSH
20578: LD_INT 550
20580: LESS
20581: IFFALSE 20614
// begin ComMoveXY ( i , 112 , 89 ) ;
20583: LD_VAR 0 1
20587: PPUSH
20588: LD_INT 112
20590: PPUSH
20591: LD_INT 89
20593: PPUSH
20594: CALL_OW 111
// broken := broken union i ;
20598: LD_ADDR_LOC 21
20602: PUSH
20603: LD_LOC 21
20607: PUSH
20608: LD_VAR 0 1
20612: UNION
20613: ST_TO_ADDR
// end ; if i in cargo and GetLives ( i ) < 800 then
20614: LD_VAR 0 1
20618: PUSH
20619: LD_LOC 3
20623: IN
20624: PUSH
20625: LD_VAR 0 1
20629: PPUSH
20630: CALL_OW 256
20634: PUSH
20635: LD_INT 800
20637: LESS
20638: AND
20639: IFFALSE 20672
// begin ComMoveXY ( i , 112 , 89 ) ;
20641: LD_VAR 0 1
20645: PPUSH
20646: LD_INT 112
20648: PPUSH
20649: LD_INT 89
20651: PPUSH
20652: CALL_OW 111
// broken := broken union i ;
20656: LD_ADDR_LOC 21
20660: PUSH
20661: LD_LOC 21
20665: PUSH
20666: LD_VAR 0 1
20670: UNION
20671: ST_TO_ADDR
// end ; end ;
20672: GO 20565
20674: POP
20675: POP
// enable ;
20676: ENABLE
// end ;
20677: PPOPN 2
20679: END
// var zasek_cargo ; every 1 1$0 do var j , pojedou , new ;
20680: GO 20682
20682: DISABLE
20683: LD_INT 0
20685: PPUSH
20686: PPUSH
20687: PPUSH
// begin SetFuel ( cargo , 100 ) ;
20688: LD_LOC 3
20692: PPUSH
20693: LD_INT 100
20695: PPUSH
20696: CALL_OW 240
// if not HasTask ( Cargo ) and GetLives ( Cargo ) >= 900 and crates >= 2 then
20700: LD_LOC 3
20704: PPUSH
20705: CALL_OW 314
20709: NOT
20710: PUSH
20711: LD_LOC 3
20715: PPUSH
20716: CALL_OW 256
20720: PUSH
20721: LD_INT 900
20723: GREATEREQUAL
20724: AND
20725: PUSH
20726: LD_EXP 76
20730: PUSH
20731: LD_INT 2
20733: GREATEREQUAL
20734: AND
20735: IFFALSE 20950
// begin new := [ ] ;
20737: LD_ADDR_VAR 0 3
20741: PUSH
20742: EMPTY
20743: ST_TO_ADDR
// pojedou := find_drivers ( cargo , sol , false ) ;
20744: LD_ADDR_VAR 0 2
20748: PUSH
20749: LD_LOC 3
20753: PPUSH
20754: LD_EXP 91
20758: PPUSH
20759: LD_INT 0
20761: PPUSH
20762: CALL 16284 0 3
20766: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20767: LD_VAR 0 2
20771: PPUSH
20772: CALL 16963 0 1
// for j := 1 to 2 do
20776: LD_ADDR_VAR 0 1
20780: PUSH
20781: DOUBLE
20782: LD_INT 1
20784: DEC
20785: ST_TO_ADDR
20786: LD_INT 2
20788: PUSH
20789: FOR_TO
20790: IFFALSE 20872
// begin if InArea ( crates [ j ] [ 1 ] , crates [ j ] [ 2 ] , pod_cestou ) then
20792: LD_EXP 76
20796: PUSH
20797: LD_VAR 0 1
20801: ARRAY
20802: PUSH
20803: LD_INT 1
20805: ARRAY
20806: PPUSH
20807: LD_EXP 76
20811: PUSH
20812: LD_VAR 0 1
20816: ARRAY
20817: PUSH
20818: LD_INT 2
20820: ARRAY
20821: PPUSH
20822: LD_INT 6
20824: PPUSH
20825: CALL_OW 309
20829: IFFALSE 20870
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
20831: LD_VAR 0 2
20835: PPUSH
20836: LD_EXP 76
20840: PUSH
20841: LD_VAR 0 1
20845: ARRAY
20846: PUSH
20847: LD_INT 1
20849: ARRAY
20850: PPUSH
20851: LD_EXP 76
20855: PUSH
20856: LD_VAR 0 1
20860: ARRAY
20861: PUSH
20862: LD_INT 2
20864: ARRAY
20865: PPUSH
20866: CALL_OW 177
// end ; end ;
20870: GO 20789
20872: POP
20873: POP
// for j := 3 to crates do
20874: LD_ADDR_VAR 0 1
20878: PUSH
20879: DOUBLE
20880: LD_INT 3
20882: DEC
20883: ST_TO_ADDR
20884: LD_EXP 76
20888: PUSH
20889: FOR_TO
20890: IFFALSE 20919
// begin new := new ^ [ crates [ j ] ] ;
20892: LD_ADDR_VAR 0 3
20896: PUSH
20897: LD_VAR 0 3
20901: PUSH
20902: LD_EXP 76
20906: PUSH
20907: LD_VAR 0 1
20911: ARRAY
20912: PUSH
20913: EMPTY
20914: LIST
20915: ADD
20916: ST_TO_ADDR
// end ;
20917: GO 20889
20919: POP
20920: POP
// crates := new ;
20921: LD_ADDR_EXP 76
20925: PUSH
20926: LD_VAR 0 3
20930: ST_TO_ADDR
// AddComReturn ( pojedou ) ;
20931: LD_VAR 0 2
20935: PPUSH
20936: CALL_OW 204
// zasek_cargo := 1 ;
20940: LD_ADDR_LOC 30
20944: PUSH
20945: LD_INT 1
20947: ST_TO_ADDR
// end else
20948: GO 21015
// begin zasek_cargo := zasek_cargo + 1 ;
20950: LD_ADDR_LOC 30
20954: PUSH
20955: LD_LOC 30
20959: PUSH
20960: LD_INT 1
20962: PLUS
20963: ST_TO_ADDR
// if zasek_cargo > 5 then
20964: LD_LOC 30
20968: PUSH
20969: LD_INT 5
20971: GREATER
20972: IFFALSE 21015
// begin pojedou := find_drivers ( cargo , sol , false ) ;
20974: LD_ADDR_VAR 0 2
20978: PUSH
20979: LD_LOC 3
20983: PPUSH
20984: LD_EXP 91
20988: PPUSH
20989: LD_INT 0
20991: PPUSH
20992: CALL 16284 0 3
20996: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20997: LD_VAR 0 2
21001: PPUSH
21002: CALL 16963 0 1
// ComReturn ( cargo ) ;
21006: LD_LOC 3
21010: PPUSH
21011: CALL_OW 144
// end ; end ; enable ;
21015: ENABLE
// end ;
21016: PPOPN 3
21018: END
// every 0 0$1 do var rusi , i ;
21019: GO 21021
21021: DISABLE
21022: LD_INT 0
21024: PPUSH
21025: PPUSH
// begin rusi := FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , russians ] , [ f_see , you ] ] ) ;
21026: LD_ADDR_VAR 0 1
21030: PUSH
21031: LD_INT 3
21033: PUSH
21034: LD_INT 21
21036: PUSH
21037: LD_INT 3
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: PUSH
21044: LD_INT 22
21046: PUSH
21047: LD_EXP 2
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: PUSH
21056: LD_INT 101
21058: PUSH
21059: LD_EXP 1
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: PUSH
21068: EMPTY
21069: LIST
21070: LIST
21071: LIST
21072: LIST
21073: PPUSH
21074: CALL_OW 69
21078: ST_TO_ADDR
// if rusi then
21079: LD_VAR 0 1
21083: IFFALSE 21283
// begin if FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_see , russians ] ] ) diff prilet_tvoji then
21085: LD_INT 3
21087: PUSH
21088: LD_INT 21
21090: PUSH
21091: LD_INT 3
21093: PUSH
21094: EMPTY
21095: LIST
21096: LIST
21097: PUSH
21098: LD_INT 22
21100: PUSH
21101: LD_EXP 1
21105: PUSH
21106: EMPTY
21107: LIST
21108: LIST
21109: PUSH
21110: LD_INT 101
21112: PUSH
21113: LD_EXP 2
21117: PUSH
21118: EMPTY
21119: LIST
21120: LIST
21121: PUSH
21122: EMPTY
21123: LIST
21124: LIST
21125: LIST
21126: LIST
21127: PPUSH
21128: CALL_OW 69
21132: PUSH
21133: LD_EXP 6
21137: DIFF
21138: IFFALSE 21283
// begin attacky := attacky + 1 ;
21140: LD_ADDR_EXP 60
21144: PUSH
21145: LD_EXP 60
21149: PUSH
21150: LD_INT 1
21152: PLUS
21153: ST_TO_ADDR
// if not more_scouting and attacky > attack_to_scouting then
21154: LD_EXP 61
21158: NOT
21159: PUSH
21160: LD_EXP 60
21164: PUSH
21165: LD_EXP 67
21169: GREATER
21170: AND
21171: IFFALSE 21189
// begin more_scouting := true ;
21173: LD_ADDR_EXP 61
21177: PUSH
21178: LD_INT 1
21180: ST_TO_ADDR
// go_up := true ;
21181: LD_ADDR_EXP 62
21185: PUSH
21186: LD_INT 1
21188: ST_TO_ADDR
// end ; for i in scout diff broken do
21189: LD_ADDR_VAR 0 2
21193: PUSH
21194: LD_LOC 4
21198: PUSH
21199: LD_LOC 21
21203: DIFF
21204: PUSH
21205: FOR_IN
21206: IFFALSE 21281
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_dist , i , 8 ] ] ) , i ) ) ;
21208: LD_VAR 0 2
21212: PPUSH
21213: LD_INT 3
21215: PUSH
21216: LD_INT 21
21218: PUSH
21219: LD_INT 3
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: PUSH
21226: LD_INT 22
21228: PUSH
21229: LD_EXP 1
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: LD_INT 91
21240: PUSH
21241: LD_VAR 0 2
21245: PUSH
21246: LD_INT 8
21248: PUSH
21249: EMPTY
21250: LIST
21251: LIST
21252: LIST
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: LIST
21258: LIST
21259: PPUSH
21260: CALL_OW 69
21264: PPUSH
21265: LD_VAR 0 2
21269: PPUSH
21270: CALL_OW 74
21274: PPUSH
21275: CALL_OW 115
// end ;
21279: GO 21205
21281: POP
21282: POP
// end ; end ; enable ;
21283: ENABLE
// end ;
21284: PPOPN 2
21286: END
// every 13 13$0 do
21287: GO 21289
21289: DISABLE
// begin wait ( start_scouting ) ;
21290: LD_EXP 68
21294: PPUSH
21295: CALL_OW 67
// more_scouting := true ;
21299: LD_ADDR_EXP 61
21303: PUSH
21304: LD_INT 1
21306: ST_TO_ADDR
// go_up := true ;
21307: LD_ADDR_EXP 62
21311: PUSH
21312: LD_INT 1
21314: ST_TO_ADDR
// end ;
21315: END
// every 0 0$3 + 0 0$30 do var all1 , all , parked , ridici , i , rid , c ;
21316: GO 21318
21318: DISABLE
21319: LD_INT 0
21321: PPUSH
21322: PPUSH
21323: PPUSH
21324: PPUSH
21325: PPUSH
21326: PPUSH
21327: PPUSH
// begin all1 := FilterUnitsInArea ( near_base , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21328: LD_ADDR_VAR 0 1
21332: PUSH
21333: LD_INT 4
21335: PPUSH
21336: LD_INT 22
21338: PUSH
21339: LD_EXP 2
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: PUSH
21348: LD_INT 21
21350: PUSH
21351: LD_INT 2
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 70
21366: ST_TO_ADDR
// for i in all1 do
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_VAR 0 1
21376: PUSH
21377: FOR_IN
21378: IFFALSE 21413
// if not UnitsInside ( i ) then
21380: LD_VAR 0 5
21384: PPUSH
21385: CALL_OW 313
21389: NOT
21390: IFFALSE 21411
// all := all ^ [ i ] ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 2
21401: PUSH
21402: LD_VAR 0 5
21406: PUSH
21407: EMPTY
21408: LIST
21409: ADD
21410: ST_TO_ADDR
21411: GO 21377
21413: POP
21414: POP
// parked := FilterUnitsInArea ( parkoviste , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_INT 13
21422: PPUSH
21423: LD_INT 22
21425: PUSH
21426: LD_EXP 2
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: PUSH
21435: LD_INT 21
21437: PUSH
21438: LD_INT 2
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: PPUSH
21449: CALL_OW 70
21453: ST_TO_ADDR
// ridici := UnitFilter ( sol ^ sci ^ eng , [ f_outside ] ) ;
21454: LD_ADDR_VAR 0 4
21458: PUSH
21459: LD_EXP 91
21463: PUSH
21464: LD_EXP 92
21468: ADD
21469: PUSH
21470: LD_EXP 94
21474: ADD
21475: PPUSH
21476: LD_INT 56
21478: PUSH
21479: EMPTY
21480: LIST
21481: PPUSH
21482: CALL_OW 72
21486: ST_TO_ADDR
// all := all diff parked ;
21487: LD_ADDR_VAR 0 2
21491: PUSH
21492: LD_VAR 0 2
21496: PUSH
21497: LD_VAR 0 3
21501: DIFF
21502: ST_TO_ADDR
// all := all diff [ 0 ] ;
21503: LD_ADDR_VAR 0 2
21507: PUSH
21508: LD_VAR 0 2
21512: PUSH
21513: LD_INT 0
21515: PUSH
21516: EMPTY
21517: LIST
21518: DIFF
21519: ST_TO_ADDR
// all := all diff cargo ;
21520: LD_ADDR_VAR 0 2
21524: PUSH
21525: LD_VAR 0 2
21529: PUSH
21530: LD_LOC 3
21534: DIFF
21535: ST_TO_ADDR
// if ridici then
21536: LD_VAR 0 4
21540: IFFALSE 22269
// for i in all do
21542: LD_ADDR_VAR 0 5
21546: PUSH
21547: LD_VAR 0 2
21551: PUSH
21552: FOR_IN
21553: IFFALSE 22267
// begin rid := ridici [ 1 ] ;
21555: LD_ADDR_VAR 0 6
21559: PUSH
21560: LD_VAR 0 4
21564: PUSH
21565: LD_INT 1
21567: ARRAY
21568: ST_TO_ADDR
// ridici := ridici diff rid ;
21569: LD_ADDR_VAR 0 4
21573: PUSH
21574: LD_VAR 0 4
21578: PUSH
21579: LD_VAR 0 6
21583: DIFF
21584: ST_TO_ADDR
// sol := sol diff rid ;
21585: LD_ADDR_EXP 91
21589: PUSH
21590: LD_EXP 91
21594: PUSH
21595: LD_VAR 0 6
21599: DIFF
21600: ST_TO_ADDR
// sci := sci diff rid ;
21601: LD_ADDR_EXP 92
21605: PUSH
21606: LD_EXP 92
21610: PUSH
21611: LD_VAR 0 6
21615: DIFF
21616: ST_TO_ADDR
// eng := eng diff rid ;
21617: LD_ADDR_EXP 94
21621: PUSH
21622: LD_EXP 94
21626: PUSH
21627: LD_VAR 0 6
21631: DIFF
21632: ST_TO_ADDR
// case true of i in scout1 :
21633: LD_INT 1
21635: PUSH
21636: LD_VAR 0 5
21640: PUSH
21641: LD_LOC 7
21645: IN
21646: DOUBLE
21647: EQUAL
21648: IFTRUE 21652
21650: GO 21679
21652: POP
// begin scout1 := scout1 diff i ;
21653: LD_ADDR_LOC 7
21657: PUSH
21658: LD_LOC 7
21662: PUSH
21663: LD_VAR 0 5
21667: DIFF
21668: ST_TO_ADDR
// c := 1 ;
21669: LD_ADDR_VAR 0 7
21673: PUSH
21674: LD_INT 1
21676: ST_TO_ADDR
// end ; i in scout2 :
21677: GO 21895
21679: LD_VAR 0 5
21683: PUSH
21684: LD_LOC 8
21688: IN
21689: DOUBLE
21690: EQUAL
21691: IFTRUE 21695
21693: GO 21722
21695: POP
// begin scout2 := scout2 diff i ;
21696: LD_ADDR_LOC 8
21700: PUSH
21701: LD_LOC 8
21705: PUSH
21706: LD_VAR 0 5
21710: DIFF
21711: ST_TO_ADDR
// c := 2 ;
21712: LD_ADDR_VAR 0 7
21716: PUSH
21717: LD_INT 2
21719: ST_TO_ADDR
// end ; i in scout :
21720: GO 21895
21722: LD_VAR 0 5
21726: PUSH
21727: LD_LOC 4
21731: IN
21732: DOUBLE
21733: EQUAL
21734: IFTRUE 21738
21736: GO 21765
21738: POP
// begin scout := scout diff i ;
21739: LD_ADDR_LOC 4
21743: PUSH
21744: LD_LOC 4
21748: PUSH
21749: LD_VAR 0 5
21753: DIFF
21754: ST_TO_ADDR
// c := 3 ;
21755: LD_ADDR_VAR 0 7
21759: PUSH
21760: LD_INT 3
21762: ST_TO_ADDR
// end ; i in attack :
21763: GO 21895
21765: LD_VAR 0 5
21769: PUSH
21770: LD_LOC 5
21774: IN
21775: DOUBLE
21776: EQUAL
21777: IFTRUE 21781
21779: GO 21808
21781: POP
// begin attack := attack diff i ;
21782: LD_ADDR_LOC 5
21786: PUSH
21787: LD_LOC 5
21791: PUSH
21792: LD_VAR 0 5
21796: DIFF
21797: ST_TO_ADDR
// c := 4 ;
21798: LD_ADDR_VAR 0 7
21802: PUSH
21803: LD_INT 4
21805: ST_TO_ADDR
// end ; i in defence :
21806: GO 21895
21808: LD_VAR 0 5
21812: PUSH
21813: LD_LOC 6
21817: IN
21818: DOUBLE
21819: EQUAL
21820: IFTRUE 21824
21822: GO 21851
21824: POP
// begin defence := defence diff i ;
21825: LD_ADDR_LOC 6
21829: PUSH
21830: LD_LOC 6
21834: PUSH
21835: LD_VAR 0 5
21839: DIFF
21840: ST_TO_ADDR
// c := 4 ;
21841: LD_ADDR_VAR 0 7
21845: PUSH
21846: LD_INT 4
21848: ST_TO_ADDR
// end ; i in cargo :
21849: GO 21895
21851: LD_VAR 0 5
21855: PUSH
21856: LD_LOC 3
21860: IN
21861: DOUBLE
21862: EQUAL
21863: IFTRUE 21867
21865: GO 21894
21867: POP
// begin cargo := cargo diff i ;
21868: LD_ADDR_LOC 3
21872: PUSH
21873: LD_LOC 3
21877: PUSH
21878: LD_VAR 0 5
21882: DIFF
21883: ST_TO_ADDR
// c := 5 ;
21884: LD_ADDR_VAR 0 7
21888: PUSH
21889: LD_INT 5
21891: ST_TO_ADDR
// end ; end ;
21892: GO 21895
21894: POP
// ComEnterUnit ( rid , i ) ;
21895: LD_VAR 0 6
21899: PPUSH
21900: LD_VAR 0 5
21904: PPUSH
21905: CALL_OW 120
// while not UnitsInside ( i ) do
21909: LD_VAR 0 5
21913: PPUSH
21914: CALL_OW 313
21918: NOT
21919: IFFALSE 21930
// wait ( 0 0$1 ) ;
21921: LD_INT 35
21923: PPUSH
21924: CALL_OW 67
21928: GO 21909
// ComMoveToArea ( i , parkoviste ) ;
21930: LD_VAR 0 5
21934: PPUSH
21935: LD_INT 13
21937: PPUSH
21938: CALL_OW 113
// while not IsInArea ( i , parkoviste ) do
21942: LD_VAR 0 5
21946: PPUSH
21947: LD_INT 13
21949: PPUSH
21950: CALL_OW 308
21954: NOT
21955: IFFALSE 21966
// wait ( 0 0$1 ) ;
21957: LD_INT 35
21959: PPUSH
21960: CALL_OW 67
21964: GO 21942
// ComExitVehicle ( i ) ;
21966: LD_VAR 0 5
21970: PPUSH
21971: CALL_OW 121
// while UnitsInside ( i ) do
21975: LD_VAR 0 5
21979: PPUSH
21980: CALL_OW 313
21984: IFFALSE 21995
// wait ( 0 0$1 ) ;
21986: LD_INT 35
21988: PPUSH
21989: CALL_OW 67
21993: GO 21975
// ComReturn ( rid ) ;
21995: LD_VAR 0 6
21999: PPUSH
22000: CALL_OW 144
// case c of 1 :
22004: LD_VAR 0 7
22008: PUSH
22009: LD_INT 1
22011: DOUBLE
22012: EQUAL
22013: IFTRUE 22017
22015: GO 22036
22017: POP
// begin scout1 := scout1 ^ i ;
22018: LD_ADDR_LOC 7
22022: PUSH
22023: LD_LOC 7
22027: PUSH
22028: LD_VAR 0 5
22032: ADD
22033: ST_TO_ADDR
// end ; 2 :
22034: GO 22172
22036: LD_INT 2
22038: DOUBLE
22039: EQUAL
22040: IFTRUE 22044
22042: GO 22063
22044: POP
// begin scout2 := scout2 ^ i ;
22045: LD_ADDR_LOC 8
22049: PUSH
22050: LD_LOC 8
22054: PUSH
22055: LD_VAR 0 5
22059: ADD
22060: ST_TO_ADDR
// end ; 3 :
22061: GO 22172
22063: LD_INT 3
22065: DOUBLE
22066: EQUAL
22067: IFTRUE 22071
22069: GO 22090
22071: POP
// begin scout := scout ^ i ;
22072: LD_ADDR_LOC 4
22076: PUSH
22077: LD_LOC 4
22081: PUSH
22082: LD_VAR 0 5
22086: ADD
22087: ST_TO_ADDR
// end ; 4 :
22088: GO 22172
22090: LD_INT 4
22092: DOUBLE
22093: EQUAL
22094: IFTRUE 22098
22096: GO 22117
22098: POP
// begin attack := attack ^ i ;
22099: LD_ADDR_LOC 5
22103: PUSH
22104: LD_LOC 5
22108: PUSH
22109: LD_VAR 0 5
22113: ADD
22114: ST_TO_ADDR
// end ; 5 :
22115: GO 22172
22117: LD_INT 5
22119: DOUBLE
22120: EQUAL
22121: IFTRUE 22125
22123: GO 22144
22125: POP
// begin defence := defence ^ i ;
22126: LD_ADDR_LOC 6
22130: PUSH
22131: LD_LOC 6
22135: PUSH
22136: LD_VAR 0 5
22140: ADD
22141: ST_TO_ADDR
// end ; 6 :
22142: GO 22172
22144: LD_INT 6
22146: DOUBLE
22147: EQUAL
22148: IFTRUE 22152
22150: GO 22171
22152: POP
// begin cargo := cargo ^ i ;
22153: LD_ADDR_LOC 3
22157: PUSH
22158: LD_LOC 3
22162: PUSH
22163: LD_VAR 0 5
22167: ADD
22168: ST_TO_ADDR
// end ; end ;
22169: GO 22172
22171: POP
// if GetClass ( rid ) = class_soldier then
22172: LD_VAR 0 6
22176: PPUSH
22177: CALL_OW 257
22181: PUSH
22182: LD_INT 1
22184: EQUAL
22185: IFFALSE 22203
// sol := sol union rid ;
22187: LD_ADDR_EXP 91
22191: PUSH
22192: LD_EXP 91
22196: PUSH
22197: LD_VAR 0 6
22201: UNION
22202: ST_TO_ADDR
// if GetClass ( rid ) = class_scientistic then
22203: LD_VAR 0 6
22207: PPUSH
22208: CALL_OW 257
22212: PUSH
22213: LD_INT 4
22215: EQUAL
22216: IFFALSE 22234
// sci := sci union rid ;
22218: LD_ADDR_EXP 92
22222: PUSH
22223: LD_EXP 92
22227: PUSH
22228: LD_VAR 0 6
22232: UNION
22233: ST_TO_ADDR
// if GetClass ( rid ) = class_engineer then
22234: LD_VAR 0 6
22238: PPUSH
22239: CALL_OW 257
22243: PUSH
22244: LD_INT 2
22246: EQUAL
22247: IFFALSE 22265
// eng := eng union rid ;
22249: LD_ADDR_EXP 94
22253: PUSH
22254: LD_EXP 94
22258: PUSH
22259: LD_VAR 0 6
22263: UNION
22264: ST_TO_ADDR
// end ;
22265: GO 21552
22267: POP
22268: POP
// enable ;
22269: ENABLE
// end ;
22270: PPOPN 7
22272: END
// var add_h ; every 0 0$15.0 do var a ;
22273: GO 22275
22275: DISABLE
22276: LD_INT 0
22278: PPUSH
// begin if not IsBusy ( fact1 ) and GetSide ( fact1 ) <> you then
22279: LD_INT 35
22281: PPUSH
22282: CALL_OW 315
22286: NOT
22287: PUSH
22288: LD_INT 35
22290: PPUSH
22291: CALL_OW 255
22295: PUSH
22296: LD_EXP 1
22300: NONEQUAL
22301: AND
22302: IFFALSE 23130
// begin if attacky > 70 and defence < 4 then
22304: LD_EXP 60
22308: PUSH
22309: LD_INT 70
22311: GREATER
22312: PUSH
22313: LD_LOC 6
22317: PUSH
22318: LD_INT 4
22320: LESS
22321: AND
22322: IFFALSE 22392
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22324: LD_INT 5
22326: PPUSH
22327: LD_INT 25
22329: PUSH
22330: LD_INT 3
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 22
22339: PUSH
22340: LD_EXP 2
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PPUSH
22353: CALL_OW 70
22357: PPUSH
22358: LD_INT 35
22360: PPUSH
22361: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_gun ) ;
22365: LD_INT 35
22367: PPUSH
22368: LD_INT 24
22370: PPUSH
22371: LD_INT 1
22373: PPUSH
22374: LD_INT 1
22376: PPUSH
22377: LD_INT 46
22379: PPUSH
22380: CALL_OW 125
// to_defence := true ;
22384: LD_ADDR_LOC 25
22388: PUSH
22389: LD_INT 1
22391: ST_TO_ADDR
// end ; if attacky > 30 and scout < 2 then
22392: LD_EXP 60
22396: PUSH
22397: LD_INT 30
22399: GREATER
22400: PUSH
22401: LD_LOC 4
22405: PUSH
22406: LD_INT 2
22408: LESS
22409: AND
22410: IFFALSE 22488
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22412: LD_INT 5
22414: PPUSH
22415: LD_INT 25
22417: PUSH
22418: LD_INT 3
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: LD_INT 22
22427: PUSH
22428: LD_EXP 2
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: PPUSH
22441: CALL_OW 70
22445: PPUSH
22446: LD_INT 35
22448: PPUSH
22449: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22453: LD_INT 35
22455: PPUSH
22456: LD_INT 22
22458: PPUSH
22459: LD_INT 1
22461: PPUSH
22462: LD_INT 1
22464: PPUSH
22465: LD_INT 42
22467: PPUSH
22468: CALL_OW 125
// to_scout := true ;
22472: LD_ADDR_LOC 27
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
// to_attack := true ;
22480: LD_ADDR_LOC 26
22484: PUSH
22485: LD_INT 1
22487: ST_TO_ADDR
// end ; if attacky > 90 and attack < 4 then
22488: LD_EXP 60
22492: PUSH
22493: LD_INT 90
22495: GREATER
22496: PUSH
22497: LD_LOC 5
22501: PUSH
22502: LD_INT 4
22504: LESS
22505: AND
22506: IFFALSE 22576
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22508: LD_INT 5
22510: PPUSH
22511: LD_INT 25
22513: PUSH
22514: LD_INT 3
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: PUSH
22521: LD_INT 22
22523: PUSH
22524: LD_EXP 2
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 70
22541: PPUSH
22542: LD_INT 35
22544: PPUSH
22545: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22549: LD_INT 35
22551: PPUSH
22552: LD_INT 24
22554: PPUSH
22555: LD_INT 1
22557: PPUSH
22558: LD_INT 1
22560: PPUSH
22561: LD_INT 42
22563: PPUSH
22564: CALL_OW 125
// to_attack := true ;
22568: LD_ADDR_LOC 26
22572: PUSH
22573: LD_INT 1
22575: ST_TO_ADDR
// end ; if cargo < 1 then
22576: LD_LOC 3
22580: PUSH
22581: LD_INT 1
22583: LESS
22584: IFFALSE 22654
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22586: LD_INT 5
22588: PPUSH
22589: LD_INT 25
22591: PUSH
22592: LD_INT 3
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 22
22601: PUSH
22602: LD_EXP 2
22606: PUSH
22607: EMPTY
22608: LIST
22609: LIST
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PPUSH
22615: CALL_OW 70
22619: PPUSH
22620: LD_INT 35
22622: PPUSH
22623: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_cargo_bay ) ;
22627: LD_INT 35
22629: PPUSH
22630: LD_INT 22
22632: PPUSH
22633: LD_INT 1
22635: PPUSH
22636: LD_INT 1
22638: PPUSH
22639: LD_INT 51
22641: PPUSH
22642: CALL_OW 125
// to_cargo := true ;
22646: LD_ADDR_LOC 28
22650: PUSH
22651: LD_INT 1
22653: ST_TO_ADDR
// end ; if ( sol + mec + eng + sci > 8 ) and ( add_h < 6 ) then
22654: LD_EXP 91
22658: PUSH
22659: LD_EXP 93
22663: PLUS
22664: PUSH
22665: LD_EXP 94
22669: PLUS
22670: PUSH
22671: LD_EXP 92
22675: PLUS
22676: PUSH
22677: LD_INT 8
22679: GREATER
22680: PUSH
22681: LD_LOC 31
22685: PUSH
22686: LD_INT 6
22688: LESS
22689: AND
22690: IFFALSE 23130
// begin add_h := add_h + 1 ;
22692: LD_ADDR_LOC 31
22696: PUSH
22697: LD_LOC 31
22701: PUSH
22702: LD_INT 1
22704: PLUS
22705: ST_TO_ADDR
// if sol < 8 then
22706: LD_EXP 91
22710: PUSH
22711: LD_INT 8
22713: LESS
22714: IFFALSE 22820
// begin InitUc ;
22716: CALL_OW 18
// InitHc ;
22720: CALL_OW 19
// uc_nation := nation_russian ;
22724: LD_ADDR_OWVAR 21
22728: PUSH
22729: LD_INT 3
22731: ST_TO_ADDR
// uc_side := russians ;
22732: LD_ADDR_OWVAR 20
22736: PUSH
22737: LD_EXP 2
22741: ST_TO_ADDR
// PrepareSoldier ( 0 , 6 ) ;
22742: LD_INT 0
22744: PPUSH
22745: LD_INT 6
22747: PPUSH
22748: CALL_OW 381
// a := CreateHuman ;
22752: LD_ADDR_VAR 0 1
22756: PUSH
22757: CALL_OW 44
22761: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22762: LD_VAR 0 1
22766: PPUSH
22767: LD_INT 119
22769: PPUSH
22770: LD_INT 98
22772: PPUSH
22773: LD_INT 5
22775: PPUSH
22776: LD_INT 0
22778: PPUSH
22779: CALL_OW 50
// wait ( 0 0$6 ) ;
22783: LD_INT 210
22785: PPUSH
22786: CALL_OW 67
// sol := sol ^ a ;
22790: LD_ADDR_EXP 91
22794: PUSH
22795: LD_EXP 91
22799: PUSH
22800: LD_VAR 0 1
22804: ADD
22805: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22806: LD_VAR 0 1
22810: PPUSH
22811: LD_INT 5
22813: PPUSH
22814: CALL_OW 113
// end else
22818: GO 23130
// if mec < 2 then
22820: LD_EXP 93
22824: PUSH
22825: LD_INT 2
22827: LESS
22828: IFFALSE 22924
// begin InitUc ;
22830: CALL_OW 18
// InitHc ;
22834: CALL_OW 19
// uc_nation := nation_russian ;
22838: LD_ADDR_OWVAR 21
22842: PUSH
22843: LD_INT 3
22845: ST_TO_ADDR
// PrepareMechanic ( 0 , 6 ) ;
22846: LD_INT 0
22848: PPUSH
22849: LD_INT 6
22851: PPUSH
22852: CALL_OW 383
// a := CreateHuman ;
22856: LD_ADDR_VAR 0 1
22860: PUSH
22861: CALL_OW 44
22865: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22866: LD_VAR 0 1
22870: PPUSH
22871: LD_INT 119
22873: PPUSH
22874: LD_INT 98
22876: PPUSH
22877: LD_INT 5
22879: PPUSH
22880: LD_INT 0
22882: PPUSH
22883: CALL_OW 50
// wait ( 0 0$6 ) ;
22887: LD_INT 210
22889: PPUSH
22890: CALL_OW 67
// mec := mec ^ a ;
22894: LD_ADDR_EXP 93
22898: PUSH
22899: LD_EXP 93
22903: PUSH
22904: LD_VAR 0 1
22908: ADD
22909: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22910: LD_VAR 0 1
22914: PPUSH
22915: LD_INT 5
22917: PPUSH
22918: CALL_OW 113
// end else
22922: GO 23130
// if eng < 1 then
22924: LD_EXP 94
22928: PUSH
22929: LD_INT 1
22931: LESS
22932: IFFALSE 23028
// begin InitUc ;
22934: CALL_OW 18
// InitHc ;
22938: CALL_OW 19
// uc_nation := nation_russian ;
22942: LD_ADDR_OWVAR 21
22946: PUSH
22947: LD_INT 3
22949: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
22950: LD_INT 0
22952: PPUSH
22953: LD_INT 6
22955: PPUSH
22956: CALL_OW 382
// a := CreateHuman ;
22960: LD_ADDR_VAR 0 1
22964: PUSH
22965: CALL_OW 44
22969: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
22970: LD_VAR 0 1
22974: PPUSH
22975: LD_INT 119
22977: PPUSH
22978: LD_INT 99
22980: PPUSH
22981: LD_INT 5
22983: PPUSH
22984: LD_INT 0
22986: PPUSH
22987: CALL_OW 50
// wait ( 0 0$6 ) ;
22991: LD_INT 210
22993: PPUSH
22994: CALL_OW 67
// eng := eng ^ a ;
22998: LD_ADDR_EXP 94
23002: PUSH
23003: LD_EXP 94
23007: PUSH
23008: LD_VAR 0 1
23012: ADD
23013: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23014: LD_VAR 0 1
23018: PPUSH
23019: LD_INT 5
23021: PPUSH
23022: CALL_OW 113
// end else
23026: GO 23130
// if sci < 1 then
23028: LD_EXP 92
23032: PUSH
23033: LD_INT 1
23035: LESS
23036: IFFALSE 23130
// begin InitUc ;
23038: CALL_OW 18
// InitHc ;
23042: CALL_OW 19
// uc_nation := nation_russian ;
23046: LD_ADDR_OWVAR 21
23050: PUSH
23051: LD_INT 3
23053: ST_TO_ADDR
// PrepareScientist ( 0 , 6 ) ;
23054: LD_INT 0
23056: PPUSH
23057: LD_INT 6
23059: PPUSH
23060: CALL_OW 384
// a := CreateHuman ;
23064: LD_ADDR_VAR 0 1
23068: PUSH
23069: CALL_OW 44
23073: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
23074: LD_VAR 0 1
23078: PPUSH
23079: LD_INT 119
23081: PPUSH
23082: LD_INT 99
23084: PPUSH
23085: LD_INT 5
23087: PPUSH
23088: LD_INT 0
23090: PPUSH
23091: CALL_OW 50
// wait ( 0 0$6 ) ;
23095: LD_INT 210
23097: PPUSH
23098: CALL_OW 67
// sci := sci ^ a ;
23102: LD_ADDR_EXP 92
23106: PUSH
23107: LD_EXP 92
23111: PUSH
23112: LD_VAR 0 1
23116: ADD
23117: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23118: LD_VAR 0 1
23122: PPUSH
23123: LD_INT 5
23125: PPUSH
23126: CALL_OW 113
// end ; end ; end ; enable ;
23130: ENABLE
// end ;
23131: PPOPN 1
23133: END
// every 0 0$3 do var sc ;
23134: GO 23136
23136: DISABLE
23137: LD_INT 0
23139: PPUSH
// begin sol := UnitFilter ( sol , [ f_alive ] ) ;
23140: LD_ADDR_EXP 91
23144: PUSH
23145: LD_EXP 91
23149: PPUSH
23150: LD_INT 51
23152: PUSH
23153: EMPTY
23154: LIST
23155: PPUSH
23156: CALL_OW 72
23160: ST_TO_ADDR
// eng := UnitFilter ( eng , [ f_alive ] ) ;
23161: LD_ADDR_EXP 94
23165: PUSH
23166: LD_EXP 94
23170: PPUSH
23171: LD_INT 51
23173: PUSH
23174: EMPTY
23175: LIST
23176: PPUSH
23177: CALL_OW 72
23181: ST_TO_ADDR
// mec := UnitFilter ( mec , [ f_alive ] ) ;
23182: LD_ADDR_EXP 93
23186: PUSH
23187: LD_EXP 93
23191: PPUSH
23192: LD_INT 51
23194: PUSH
23195: EMPTY
23196: LIST
23197: PPUSH
23198: CALL_OW 72
23202: ST_TO_ADDR
// sci := UnitFilter ( sci , [ f_alive ] ) ;
23203: LD_ADDR_EXP 92
23207: PUSH
23208: LD_EXP 92
23212: PPUSH
23213: LD_INT 51
23215: PUSH
23216: EMPTY
23217: LIST
23218: PPUSH
23219: CALL_OW 72
23223: ST_TO_ADDR
// defence := UnitFilter ( defence , [ f_alive ] ) ;
23224: LD_ADDR_LOC 6
23228: PUSH
23229: LD_LOC 6
23233: PPUSH
23234: LD_INT 51
23236: PUSH
23237: EMPTY
23238: LIST
23239: PPUSH
23240: CALL_OW 72
23244: ST_TO_ADDR
// cargo := UnitFilter ( cargo , [ f_alive ] ) ;
23245: LD_ADDR_LOC 3
23249: PUSH
23250: LD_LOC 3
23254: PPUSH
23255: LD_INT 51
23257: PUSH
23258: EMPTY
23259: LIST
23260: PPUSH
23261: CALL_OW 72
23265: ST_TO_ADDR
// attack := UnitFilter ( attack , [ f_alive ] ) ;
23266: LD_ADDR_LOC 5
23270: PUSH
23271: LD_LOC 5
23275: PPUSH
23276: LD_INT 51
23278: PUSH
23279: EMPTY
23280: LIST
23281: PPUSH
23282: CALL_OW 72
23286: ST_TO_ADDR
// scout := UnitFilter ( scout , [ f_alive ] ) ;
23287: LD_ADDR_LOC 4
23291: PUSH
23292: LD_LOC 4
23296: PPUSH
23297: LD_INT 51
23299: PUSH
23300: EMPTY
23301: LIST
23302: PPUSH
23303: CALL_OW 72
23307: ST_TO_ADDR
// broken := UnitFilter ( broken , [ f_alive ] ) ;
23308: LD_ADDR_LOC 21
23312: PUSH
23313: LD_LOC 21
23317: PPUSH
23318: LD_INT 51
23320: PUSH
23321: EMPTY
23322: LIST
23323: PPUSH
23324: CALL_OW 72
23328: ST_TO_ADDR
// sc := split ( scout ) ;
23329: LD_ADDR_VAR 0 1
23333: PUSH
23334: LD_LOC 4
23338: PPUSH
23339: CALL 17514 0 1
23343: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23344: LD_ADDR_LOC 7
23348: PUSH
23349: LD_VAR 0 1
23353: PUSH
23354: LD_INT 1
23356: ARRAY
23357: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23358: LD_ADDR_LOC 8
23362: PUSH
23363: LD_VAR 0 1
23367: PUSH
23368: LD_INT 2
23370: ARRAY
23371: ST_TO_ADDR
// forts := UnitFilter ( forts , [ f_alive ] ) ;
23372: LD_ADDR_LOC 10
23376: PUSH
23377: LD_LOC 10
23381: PPUSH
23382: LD_INT 51
23384: PUSH
23385: EMPTY
23386: LIST
23387: PPUSH
23388: CALL_OW 72
23392: ST_TO_ADDR
// end ;
23393: PPOPN 1
23395: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = russians then
23396: LD_VAR 0 3
23400: PUSH
23401: LD_EXP 2
23405: EQUAL
23406: IFFALSE 23584
// begin sol := sol diff vehold ;
23408: LD_ADDR_EXP 91
23412: PUSH
23413: LD_EXP 91
23417: PUSH
23418: LD_VAR 0 2
23422: DIFF
23423: ST_TO_ADDR
// eng := eng diff vehold ;
23424: LD_ADDR_EXP 94
23428: PUSH
23429: LD_EXP 94
23433: PUSH
23434: LD_VAR 0 2
23438: DIFF
23439: ST_TO_ADDR
// mec := mec diff vehold ;
23440: LD_ADDR_EXP 93
23444: PUSH
23445: LD_EXP 93
23449: PUSH
23450: LD_VAR 0 2
23454: DIFF
23455: ST_TO_ADDR
// sci := sci diff vehold ;
23456: LD_ADDR_EXP 92
23460: PUSH
23461: LD_EXP 92
23465: PUSH
23466: LD_VAR 0 2
23470: DIFF
23471: ST_TO_ADDR
// defence := defence diff vehold ;
23472: LD_ADDR_LOC 6
23476: PUSH
23477: LD_LOC 6
23481: PUSH
23482: LD_VAR 0 2
23486: DIFF
23487: ST_TO_ADDR
// cargo := cargo diff vehold ;
23488: LD_ADDR_LOC 3
23492: PUSH
23493: LD_LOC 3
23497: PUSH
23498: LD_VAR 0 2
23502: DIFF
23503: ST_TO_ADDR
// attack := attack diff vehold ;
23504: LD_ADDR_LOC 5
23508: PUSH
23509: LD_LOC 5
23513: PUSH
23514: LD_VAR 0 2
23518: DIFF
23519: ST_TO_ADDR
// scout := scout diff vehold ;
23520: LD_ADDR_LOC 4
23524: PUSH
23525: LD_LOC 4
23529: PUSH
23530: LD_VAR 0 2
23534: DIFF
23535: ST_TO_ADDR
// broken := broken diff vehold ;
23536: LD_ADDR_LOC 21
23540: PUSH
23541: LD_LOC 21
23545: PUSH
23546: LD_VAR 0 2
23550: DIFF
23551: ST_TO_ADDR
// scout1 := scout1 diff vehold ;
23552: LD_ADDR_LOC 7
23556: PUSH
23557: LD_LOC 7
23561: PUSH
23562: LD_VAR 0 2
23566: DIFF
23567: ST_TO_ADDR
// scout2 := scout2 diff vehold ;
23568: LD_ADDR_LOC 8
23572: PUSH
23573: LD_LOC 8
23577: PUSH
23578: LD_VAR 0 2
23582: DIFF
23583: ST_TO_ADDR
// end ; end ;
23584: PPOPN 4
23586: END
// on UnitDestroyed ( un ) do begin if un = JMM then
23587: LD_VAR 0 1
23591: PUSH
23592: LD_EXP 15
23596: EQUAL
23597: IFFALSE 23609
// begin disable ( 0 ) ;
23599: LD_INT 0
23601: DISABLE_MARKED
// YouLost ( JMM ) ;
23602: LD_STRING JMM
23604: PPUSH
23605: CALL_OW 104
// end ; if un = Kurt then
23609: LD_VAR 0 1
23613: PUSH
23614: LD_EXP 43
23618: EQUAL
23619: IFFALSE 23627
// begin SA_OnKurtKilled ;
23621: CALL 27098 0 0
// exit ;
23625: GO 23855
// end ; if un = Joan then
23627: LD_VAR 0 1
23631: PUSH
23632: LD_EXP 33
23636: EQUAL
23637: IFFALSE 23643
// SA_JoanDead ;
23639: CALL 27163 0 0
// if un in NavicLidi then
23643: LD_VAR 0 1
23647: PUSH
23648: LD_EXP 84
23652: IN
23653: IFFALSE 23663
// noBodyLeft := false ;
23655: LD_ADDR_EXP 86
23659: PUSH
23660: LD_INT 0
23662: ST_TO_ADDR
// sol := sol diff un ;
23663: LD_ADDR_EXP 91
23667: PUSH
23668: LD_EXP 91
23672: PUSH
23673: LD_VAR 0 1
23677: DIFF
23678: ST_TO_ADDR
// eng := eng diff un ;
23679: LD_ADDR_EXP 94
23683: PUSH
23684: LD_EXP 94
23688: PUSH
23689: LD_VAR 0 1
23693: DIFF
23694: ST_TO_ADDR
// mec := mec diff un ;
23695: LD_ADDR_EXP 93
23699: PUSH
23700: LD_EXP 93
23704: PUSH
23705: LD_VAR 0 1
23709: DIFF
23710: ST_TO_ADDR
// sci := sci diff un ;
23711: LD_ADDR_EXP 92
23715: PUSH
23716: LD_EXP 92
23720: PUSH
23721: LD_VAR 0 1
23725: DIFF
23726: ST_TO_ADDR
// defence := defence diff un ;
23727: LD_ADDR_LOC 6
23731: PUSH
23732: LD_LOC 6
23736: PUSH
23737: LD_VAR 0 1
23741: DIFF
23742: ST_TO_ADDR
// cargo := cargo diff un ;
23743: LD_ADDR_LOC 3
23747: PUSH
23748: LD_LOC 3
23752: PUSH
23753: LD_VAR 0 1
23757: DIFF
23758: ST_TO_ADDR
// attack := attack diff un ;
23759: LD_ADDR_LOC 5
23763: PUSH
23764: LD_LOC 5
23768: PUSH
23769: LD_VAR 0 1
23773: DIFF
23774: ST_TO_ADDR
// scout := scout diff un ;
23775: LD_ADDR_LOC 4
23779: PUSH
23780: LD_LOC 4
23784: PUSH
23785: LD_VAR 0 1
23789: DIFF
23790: ST_TO_ADDR
// broken := broken diff un ;
23791: LD_ADDR_LOC 21
23795: PUSH
23796: LD_LOC 21
23800: PUSH
23801: LD_VAR 0 1
23805: DIFF
23806: ST_TO_ADDR
// scout1 := scout1 diff un ;
23807: LD_ADDR_LOC 7
23811: PUSH
23812: LD_LOC 7
23816: PUSH
23817: LD_VAR 0 1
23821: DIFF
23822: ST_TO_ADDR
// scout2 := scout2 diff un ;
23823: LD_ADDR_LOC 8
23827: PUSH
23828: LD_LOC 8
23832: PUSH
23833: LD_VAR 0 1
23837: DIFF
23838: ST_TO_ADDR
// forts := forts diff un ;
23839: LD_ADDR_LOC 10
23843: PUSH
23844: LD_LOC 10
23848: PUSH
23849: LD_VAR 0 1
23853: DIFF
23854: ST_TO_ADDR
// end ;
23855: PPOPN 1
23857: END
// on VehicleConstructed ( veh , fact ) do var i , sc ;
23858: LD_INT 0
23860: PPUSH
23861: PPUSH
// begin if GetSide ( fact ) = russians then
23862: LD_VAR 0 2
23866: PPUSH
23867: CALL_OW 255
23871: PUSH
23872: LD_EXP 2
23876: EQUAL
23877: IFFALSE 24096
// begin ComMoveToArea ( veh , parkoviste ) ;
23879: LD_VAR 0 1
23883: PPUSH
23884: LD_INT 13
23886: PPUSH
23887: CALL_OW 113
// while not IsInArea ( veh , parkoviste ) do
23891: LD_VAR 0 1
23895: PPUSH
23896: LD_INT 13
23898: PPUSH
23899: CALL_OW 308
23903: NOT
23904: IFFALSE 23915
// Wait ( 0 0$1 ) ;
23906: LD_INT 35
23908: PPUSH
23909: CALL_OW 67
23913: GO 23891
// ComExitVehicle ( veh ) ;
23915: LD_VAR 0 1
23919: PPUSH
23920: CALL_OW 121
// ComRemember ( veh ) ;
23924: LD_VAR 0 1
23928: PPUSH
23929: CALL_OW 143
// if to_defence then
23933: LD_LOC 25
23937: IFFALSE 23955
// begin defence := defence union veh ;
23939: LD_ADDR_LOC 6
23943: PUSH
23944: LD_LOC 6
23948: PUSH
23949: LD_VAR 0 1
23953: UNION
23954: ST_TO_ADDR
// end ; if to_cargo then
23955: LD_LOC 28
23959: IFFALSE 23977
// begin cargo := cargo union veh ;
23961: LD_ADDR_LOC 3
23965: PUSH
23966: LD_LOC 3
23970: PUSH
23971: LD_VAR 0 1
23975: UNION
23976: ST_TO_ADDR
// end ; if to_attack then
23977: LD_LOC 26
23981: IFFALSE 23999
// begin attack := attack union veh ;
23983: LD_ADDR_LOC 5
23987: PUSH
23988: LD_LOC 5
23992: PUSH
23993: LD_VAR 0 1
23997: UNION
23998: ST_TO_ADDR
// end ; if to_scout then
23999: LD_LOC 27
24003: IFFALSE 24064
// begin scout := scout union veh ;
24005: LD_ADDR_LOC 4
24009: PUSH
24010: LD_LOC 4
24014: PUSH
24015: LD_VAR 0 1
24019: UNION
24020: ST_TO_ADDR
// sc := split ( scout ) ;
24021: LD_ADDR_VAR 0 4
24025: PUSH
24026: LD_LOC 4
24030: PPUSH
24031: CALL 17514 0 1
24035: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
24036: LD_ADDR_LOC 7
24040: PUSH
24041: LD_VAR 0 4
24045: PUSH
24046: LD_INT 1
24048: ARRAY
24049: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
24050: LD_ADDR_LOC 8
24054: PUSH
24055: LD_VAR 0 4
24059: PUSH
24060: LD_INT 2
24062: ARRAY
24063: ST_TO_ADDR
// end ; to_cargo := false ;
24064: LD_ADDR_LOC 28
24068: PUSH
24069: LD_INT 0
24071: ST_TO_ADDR
// to_scout := false ;
24072: LD_ADDR_LOC 27
24076: PUSH
24077: LD_INT 0
24079: ST_TO_ADDR
// to_attack := false ;
24080: LD_ADDR_LOC 26
24084: PUSH
24085: LD_INT 0
24087: ST_TO_ADDR
// to_defence := false ;
24088: LD_ADDR_LOC 25
24092: PUSH
24093: LD_INT 0
24095: ST_TO_ADDR
// end ; end ;
24096: PPOPN 4
24098: END
// every 0 0$30 trigger attacky > odplata_1 do var ubase ;
24099: LD_EXP 60
24103: PUSH
24104: LD_EXP 65
24108: GREATER
24109: IFFALSE 24356
24111: GO 24113
24113: DISABLE
24114: LD_INT 0
24116: PPUSH
// begin attacky := 0 ;
24117: LD_ADDR_EXP 60
24121: PUSH
24122: LD_INT 0
24124: ST_TO_ADDR
// more_scouting := false ;
24125: LD_ADDR_EXP 61
24129: PUSH
24130: LD_INT 0
24132: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24133: LD_ADDR_VAR 0 1
24137: PUSH
24138: LD_INT 21
24140: PUSH
24141: LD_INT 3
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: LD_INT 22
24150: PUSH
24151: LD_EXP 1
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PPUSH
24164: CALL_OW 69
24168: ST_TO_ADDR
// if ubase then
24169: LD_VAR 0 1
24173: IFFALSE 24356
// begin case Rand ( 1 , 3 ) of 1 :
24175: LD_INT 1
24177: PPUSH
24178: LD_INT 3
24180: PPUSH
24181: CALL_OW 12
24185: PUSH
24186: LD_INT 1
24188: DOUBLE
24189: EQUAL
24190: IFTRUE 24194
24192: GO 24228
24194: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24195: LD_LOC 5
24199: PUSH
24200: LD_LOC 21
24204: DIFF
24205: PPUSH
24206: LD_EXP 91
24210: PPUSH
24211: LD_LOC 22
24215: PPUSH
24216: LD_INT 1
24218: PPUSH
24219: LD_INT 0
24221: PPUSH
24222: CALL 16901 0 5
24226: GO 24313
24228: LD_INT 2
24230: DOUBLE
24231: EQUAL
24232: IFTRUE 24236
24234: GO 24270
24236: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24237: LD_LOC 5
24241: PUSH
24242: LD_LOC 21
24246: DIFF
24247: PPUSH
24248: LD_EXP 91
24252: PPUSH
24253: LD_LOC 23
24257: PPUSH
24258: LD_INT 1
24260: PPUSH
24261: LD_INT 0
24263: PPUSH
24264: CALL 16901 0 5
24268: GO 24313
24270: LD_INT 3
24272: DOUBLE
24273: EQUAL
24274: IFTRUE 24278
24276: GO 24312
24278: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24279: LD_LOC 5
24283: PUSH
24284: LD_LOC 21
24288: DIFF
24289: PPUSH
24290: LD_EXP 91
24294: PPUSH
24295: LD_LOC 24
24299: PPUSH
24300: LD_INT 1
24302: PPUSH
24303: LD_INT 0
24305: PPUSH
24306: CALL 16901 0 5
24310: GO 24313
24312: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24313: LD_LOC 5
24317: PUSH
24318: LD_LOC 21
24322: DIFF
24323: PPUSH
24324: LD_VAR 0 1
24328: PUSH
24329: LD_INT 1
24331: ARRAY
24332: PPUSH
24333: CALL_OW 250
24337: PPUSH
24338: LD_VAR 0 1
24342: PUSH
24343: LD_INT 1
24345: ARRAY
24346: PPUSH
24347: CALL_OW 251
24351: PPUSH
24352: CALL_OW 174
// end ; end ;
24356: PPOPN 1
24358: END
// every 4 4$30 trigger attacky > odplata_2 do var ubase ;
24359: LD_EXP 60
24363: PUSH
24364: LD_EXP 66
24368: GREATER
24369: IFFALSE 24609
24371: GO 24373
24373: DISABLE
24374: LD_INT 0
24376: PPUSH
// begin attacky := 0 ;
24377: LD_ADDR_EXP 60
24381: PUSH
24382: LD_INT 0
24384: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24385: LD_ADDR_VAR 0 1
24389: PUSH
24390: LD_INT 21
24392: PUSH
24393: LD_INT 3
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 22
24402: PUSH
24403: LD_EXP 1
24407: PUSH
24408: EMPTY
24409: LIST
24410: LIST
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PPUSH
24416: CALL_OW 69
24420: ST_TO_ADDR
// if ubase then
24421: LD_VAR 0 1
24425: IFFALSE 24608
// begin case Rand ( 1 , 3 ) of 1 :
24427: LD_INT 1
24429: PPUSH
24430: LD_INT 3
24432: PPUSH
24433: CALL_OW 12
24437: PUSH
24438: LD_INT 1
24440: DOUBLE
24441: EQUAL
24442: IFTRUE 24446
24444: GO 24480
24446: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24447: LD_LOC 5
24451: PUSH
24452: LD_LOC 21
24456: DIFF
24457: PPUSH
24458: LD_EXP 91
24462: PPUSH
24463: LD_LOC 22
24467: PPUSH
24468: LD_INT 1
24470: PPUSH
24471: LD_INT 0
24473: PPUSH
24474: CALL 16901 0 5
24478: GO 24565
24480: LD_INT 2
24482: DOUBLE
24483: EQUAL
24484: IFTRUE 24488
24486: GO 24522
24488: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24489: LD_LOC 5
24493: PUSH
24494: LD_LOC 21
24498: DIFF
24499: PPUSH
24500: LD_EXP 91
24504: PPUSH
24505: LD_LOC 23
24509: PPUSH
24510: LD_INT 1
24512: PPUSH
24513: LD_INT 0
24515: PPUSH
24516: CALL 16901 0 5
24520: GO 24565
24522: LD_INT 3
24524: DOUBLE
24525: EQUAL
24526: IFTRUE 24530
24528: GO 24564
24530: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24531: LD_LOC 5
24535: PUSH
24536: LD_LOC 21
24540: DIFF
24541: PPUSH
24542: LD_EXP 91
24546: PPUSH
24547: LD_LOC 24
24551: PPUSH
24552: LD_INT 1
24554: PPUSH
24555: LD_INT 0
24557: PPUSH
24558: CALL 16901 0 5
24562: GO 24565
24564: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24565: LD_LOC 5
24569: PUSH
24570: LD_LOC 21
24574: DIFF
24575: PPUSH
24576: LD_VAR 0 1
24580: PUSH
24581: LD_INT 1
24583: ARRAY
24584: PPUSH
24585: CALL_OW 250
24589: PPUSH
24590: LD_VAR 0 1
24594: PUSH
24595: LD_INT 1
24597: ARRAY
24598: PPUSH
24599: CALL_OW 251
24603: PPUSH
24604: CALL_OW 174
// end ; enable ;
24608: ENABLE
// end ;
24609: PPOPN 1
24611: END
// every 8 8$30 trigger more_scouting do var ubase , a ;
24612: LD_EXP 61
24616: IFFALSE 24859
24618: GO 24620
24620: DISABLE
24621: LD_INT 0
24623: PPUSH
24624: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24625: LD_ADDR_VAR 0 1
24629: PUSH
24630: LD_INT 21
24632: PUSH
24633: LD_INT 3
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 22
24642: PUSH
24643: LD_EXP 1
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: EMPTY
24653: LIST
24654: LIST
24655: PPUSH
24656: CALL_OW 69
24660: ST_TO_ADDR
// a := attack diff broken ;
24661: LD_ADDR_VAR 0 2
24665: PUSH
24666: LD_LOC 5
24670: PUSH
24671: LD_LOC 21
24675: DIFF
24676: ST_TO_ADDR
// a := split ( a ) ;
24677: LD_ADDR_VAR 0 2
24681: PUSH
24682: LD_VAR 0 2
24686: PPUSH
24687: CALL 17514 0 1
24691: ST_TO_ADDR
// if ubase then
24692: LD_VAR 0 1
24696: IFFALSE 24859
// begin case Rand ( 1 , 3 ) of 1 :
24698: LD_INT 1
24700: PPUSH
24701: LD_INT 3
24703: PPUSH
24704: CALL_OW 12
24708: PUSH
24709: LD_INT 1
24711: DOUBLE
24712: EQUAL
24713: IFTRUE 24717
24715: GO 24745
24717: POP
// depart ( a , sol , attack_l , true , false ) ; 2 :
24718: LD_VAR 0 2
24722: PPUSH
24723: LD_EXP 91
24727: PPUSH
24728: LD_LOC 22
24732: PPUSH
24733: LD_INT 1
24735: PPUSH
24736: LD_INT 0
24738: PPUSH
24739: CALL 16901 0 5
24743: GO 24818
24745: LD_INT 2
24747: DOUBLE
24748: EQUAL
24749: IFTRUE 24753
24751: GO 24781
24753: POP
// depart ( a , sol , attack_m , true , false ) ; 3 :
24754: LD_VAR 0 2
24758: PPUSH
24759: LD_EXP 91
24763: PPUSH
24764: LD_LOC 23
24768: PPUSH
24769: LD_INT 1
24771: PPUSH
24772: LD_INT 0
24774: PPUSH
24775: CALL 16901 0 5
24779: GO 24818
24781: LD_INT 3
24783: DOUBLE
24784: EQUAL
24785: IFTRUE 24789
24787: GO 24817
24789: POP
// depart ( a , sol , attack_r , true , false ) ; end ;
24790: LD_VAR 0 2
24794: PPUSH
24795: LD_EXP 91
24799: PPUSH
24800: LD_LOC 24
24804: PPUSH
24805: LD_INT 1
24807: PPUSH
24808: LD_INT 0
24810: PPUSH
24811: CALL 16901 0 5
24815: GO 24818
24817: POP
// AddComAgressiveMove ( a [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24818: LD_VAR 0 2
24822: PUSH
24823: LD_INT 1
24825: ARRAY
24826: PPUSH
24827: LD_VAR 0 1
24831: PUSH
24832: LD_INT 1
24834: ARRAY
24835: PPUSH
24836: CALL_OW 250
24840: PPUSH
24841: LD_VAR 0 1
24845: PUSH
24846: LD_INT 1
24848: ARRAY
24849: PPUSH
24850: CALL_OW 251
24854: PPUSH
24855: CALL_OW 174
// end ; end ;
24859: PPOPN 2
24861: END
// every 16 16$30 trigger more_scouting do var ubase , at ;
24862: LD_EXP 61
24866: IFFALSE 25284
24868: GO 24870
24870: DISABLE
24871: LD_INT 0
24873: PPUSH
24874: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24875: LD_ADDR_VAR 0 1
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 3
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 22
24892: PUSH
24893: LD_EXP 1
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PPUSH
24906: CALL_OW 69
24910: ST_TO_ADDR
// if ubase then
24911: LD_VAR 0 1
24915: IFFALSE 25284
// begin at := split ( attack diff broken ) ;
24917: LD_ADDR_VAR 0 2
24921: PUSH
24922: LD_LOC 5
24926: PUSH
24927: LD_LOC 21
24931: DIFF
24932: PPUSH
24933: CALL 17514 0 1
24937: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
24938: LD_INT 1
24940: PPUSH
24941: LD_INT 3
24943: PPUSH
24944: CALL_OW 12
24948: PUSH
24949: LD_INT 1
24951: DOUBLE
24952: EQUAL
24953: IFTRUE 24957
24955: GO 24989
24957: POP
// depart ( at [ 1 ] , sol , attack_l , true , false ) ; 2 :
24958: LD_VAR 0 2
24962: PUSH
24963: LD_INT 1
24965: ARRAY
24966: PPUSH
24967: LD_EXP 91
24971: PPUSH
24972: LD_LOC 22
24976: PPUSH
24977: LD_INT 1
24979: PPUSH
24980: LD_INT 0
24982: PPUSH
24983: CALL 16901 0 5
24987: GO 25070
24989: LD_INT 2
24991: DOUBLE
24992: EQUAL
24993: IFTRUE 24997
24995: GO 25029
24997: POP
// depart ( at [ 1 ] , sol , attack_m , true , false ) ; 3 :
24998: LD_VAR 0 2
25002: PUSH
25003: LD_INT 1
25005: ARRAY
25006: PPUSH
25007: LD_EXP 91
25011: PPUSH
25012: LD_LOC 23
25016: PPUSH
25017: LD_INT 1
25019: PPUSH
25020: LD_INT 0
25022: PPUSH
25023: CALL 16901 0 5
25027: GO 25070
25029: LD_INT 3
25031: DOUBLE
25032: EQUAL
25033: IFTRUE 25037
25035: GO 25069
25037: POP
// depart ( at [ 1 ] , sol , attack_r , true , false ) ; end ;
25038: LD_VAR 0 2
25042: PUSH
25043: LD_INT 1
25045: ARRAY
25046: PPUSH
25047: LD_EXP 91
25051: PPUSH
25052: LD_LOC 24
25056: PPUSH
25057: LD_INT 1
25059: PPUSH
25060: LD_INT 0
25062: PPUSH
25063: CALL 16901 0 5
25067: GO 25070
25069: POP
// case Rand ( 1 , 3 ) of 1 :
25070: LD_INT 1
25072: PPUSH
25073: LD_INT 3
25075: PPUSH
25076: CALL_OW 12
25080: PUSH
25081: LD_INT 1
25083: DOUBLE
25084: EQUAL
25085: IFTRUE 25089
25087: GO 25121
25089: POP
// depart ( at [ 2 ] , sol , attack_l , true , false ) ; 2 :
25090: LD_VAR 0 2
25094: PUSH
25095: LD_INT 2
25097: ARRAY
25098: PPUSH
25099: LD_EXP 91
25103: PPUSH
25104: LD_LOC 22
25108: PPUSH
25109: LD_INT 1
25111: PPUSH
25112: LD_INT 0
25114: PPUSH
25115: CALL 16901 0 5
25119: GO 25202
25121: LD_INT 2
25123: DOUBLE
25124: EQUAL
25125: IFTRUE 25129
25127: GO 25161
25129: POP
// depart ( at [ 2 ] , sol , attack_m , true , false ) ; 3 :
25130: LD_VAR 0 2
25134: PUSH
25135: LD_INT 2
25137: ARRAY
25138: PPUSH
25139: LD_EXP 91
25143: PPUSH
25144: LD_LOC 23
25148: PPUSH
25149: LD_INT 1
25151: PPUSH
25152: LD_INT 0
25154: PPUSH
25155: CALL 16901 0 5
25159: GO 25202
25161: LD_INT 3
25163: DOUBLE
25164: EQUAL
25165: IFTRUE 25169
25167: GO 25201
25169: POP
// depart ( at [ 2 ] , sol , attack_r , true , false ) ; end ;
25170: LD_VAR 0 2
25174: PUSH
25175: LD_INT 2
25177: ARRAY
25178: PPUSH
25179: LD_EXP 91
25183: PPUSH
25184: LD_LOC 24
25188: PPUSH
25189: LD_INT 1
25191: PPUSH
25192: LD_INT 0
25194: PPUSH
25195: CALL 16901 0 5
25199: GO 25202
25201: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25202: LD_VAR 0 2
25206: PUSH
25207: LD_INT 1
25209: ARRAY
25210: PPUSH
25211: LD_VAR 0 1
25215: PUSH
25216: LD_INT 1
25218: ARRAY
25219: PPUSH
25220: CALL_OW 250
25224: PPUSH
25225: LD_VAR 0 1
25229: PUSH
25230: LD_INT 1
25232: ARRAY
25233: PPUSH
25234: CALL_OW 251
25238: PPUSH
25239: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25243: LD_VAR 0 2
25247: PUSH
25248: LD_INT 2
25250: ARRAY
25251: PPUSH
25252: LD_VAR 0 1
25256: PUSH
25257: LD_INT 1
25259: ARRAY
25260: PPUSH
25261: CALL_OW 250
25265: PPUSH
25266: LD_VAR 0 1
25270: PUSH
25271: LD_INT 1
25273: ARRAY
25274: PPUSH
25275: CALL_OW 251
25279: PPUSH
25280: CALL_OW 174
// end ; end ;
25284: PPOPN 2
25286: END
// every 32 32$30 do var ubase ;
25287: GO 25289
25289: DISABLE
25290: LD_INT 0
25292: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25293: LD_ADDR_VAR 0 1
25297: PUSH
25298: LD_INT 21
25300: PUSH
25301: LD_INT 3
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 22
25310: PUSH
25311: LD_EXP 1
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PPUSH
25324: CALL_OW 69
25328: ST_TO_ADDR
// if ubase then
25329: LD_VAR 0 1
25333: IFFALSE 25534
// begin case Rand ( 1 , 3 ) of 1 :
25335: LD_INT 1
25337: PPUSH
25338: LD_INT 3
25340: PPUSH
25341: CALL_OW 12
25345: PUSH
25346: LD_INT 1
25348: DOUBLE
25349: EQUAL
25350: IFTRUE 25354
25352: GO 25394
25354: POP
// depart ( attack diff broken , sol ^ sci , attack_l , true , false ) ; 2 :
25355: LD_LOC 5
25359: PUSH
25360: LD_LOC 21
25364: DIFF
25365: PPUSH
25366: LD_EXP 91
25370: PUSH
25371: LD_EXP 92
25375: ADD
25376: PPUSH
25377: LD_LOC 22
25381: PPUSH
25382: LD_INT 1
25384: PPUSH
25385: LD_INT 0
25387: PPUSH
25388: CALL 16901 0 5
25392: GO 25491
25394: LD_INT 2
25396: DOUBLE
25397: EQUAL
25398: IFTRUE 25402
25400: GO 25442
25402: POP
// depart ( attack diff broken , sol ^ sci , attack_m , true , false ) ; 3 :
25403: LD_LOC 5
25407: PUSH
25408: LD_LOC 21
25412: DIFF
25413: PPUSH
25414: LD_EXP 91
25418: PUSH
25419: LD_EXP 92
25423: ADD
25424: PPUSH
25425: LD_LOC 23
25429: PPUSH
25430: LD_INT 1
25432: PPUSH
25433: LD_INT 0
25435: PPUSH
25436: CALL 16901 0 5
25440: GO 25491
25442: LD_INT 3
25444: DOUBLE
25445: EQUAL
25446: IFTRUE 25450
25448: GO 25490
25450: POP
// depart ( attack diff broken , sol ^ sci , attack_r , true , false ) ; end ;
25451: LD_LOC 5
25455: PUSH
25456: LD_LOC 21
25460: DIFF
25461: PPUSH
25462: LD_EXP 91
25466: PUSH
25467: LD_EXP 92
25471: ADD
25472: PPUSH
25473: LD_LOC 24
25477: PPUSH
25478: LD_INT 1
25480: PPUSH
25481: LD_INT 0
25483: PPUSH
25484: CALL 16901 0 5
25488: GO 25491
25490: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25491: LD_LOC 5
25495: PUSH
25496: LD_LOC 21
25500: DIFF
25501: PPUSH
25502: LD_VAR 0 1
25506: PUSH
25507: LD_INT 1
25509: ARRAY
25510: PPUSH
25511: CALL_OW 250
25515: PPUSH
25516: LD_VAR 0 1
25520: PUSH
25521: LD_INT 1
25523: ARRAY
25524: PPUSH
25525: CALL_OW 251
25529: PPUSH
25530: CALL_OW 174
// end ; end ;
25534: PPOPN 1
25536: END
// every 40 40$30 do var ubase , at ;
25537: GO 25539
25539: DISABLE
25540: LD_INT 0
25542: PPUSH
25543: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25544: LD_ADDR_VAR 0 1
25548: PUSH
25549: LD_INT 21
25551: PUSH
25552: LD_INT 3
25554: PUSH
25555: EMPTY
25556: LIST
25557: LIST
25558: PUSH
25559: LD_INT 22
25561: PUSH
25562: LD_EXP 1
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PPUSH
25575: CALL_OW 69
25579: ST_TO_ADDR
// if ubase then
25580: LD_VAR 0 1
25584: IFFALSE 26031
// begin at := split ( ( attack union scout ) diff broken ) ;
25586: LD_ADDR_VAR 0 2
25590: PUSH
25591: LD_LOC 5
25595: PUSH
25596: LD_LOC 4
25600: UNION
25601: PUSH
25602: LD_LOC 21
25606: DIFF
25607: PPUSH
25608: CALL 17514 0 1
25612: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
25613: LD_INT 1
25615: PPUSH
25616: LD_INT 3
25618: PPUSH
25619: CALL_OW 12
25623: PUSH
25624: LD_INT 1
25626: DOUBLE
25627: EQUAL
25628: IFTRUE 25632
25630: GO 25676
25632: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25633: LD_VAR 0 2
25637: PUSH
25638: LD_INT 1
25640: ARRAY
25641: PPUSH
25642: LD_EXP 91
25646: PUSH
25647: LD_EXP 92
25651: ADD
25652: PUSH
25653: LD_EXP 94
25657: ADD
25658: PPUSH
25659: LD_LOC 22
25663: PPUSH
25664: LD_INT 1
25666: PPUSH
25667: LD_INT 0
25669: PPUSH
25670: CALL 16901 0 5
25674: GO 25781
25676: LD_INT 2
25678: DOUBLE
25679: EQUAL
25680: IFTRUE 25684
25682: GO 25728
25684: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25685: LD_VAR 0 2
25689: PUSH
25690: LD_INT 1
25692: ARRAY
25693: PPUSH
25694: LD_EXP 91
25698: PUSH
25699: LD_EXP 92
25703: ADD
25704: PUSH
25705: LD_EXP 94
25709: ADD
25710: PPUSH
25711: LD_LOC 23
25715: PPUSH
25716: LD_INT 1
25718: PPUSH
25719: LD_INT 0
25721: PPUSH
25722: CALL 16901 0 5
25726: GO 25781
25728: LD_INT 3
25730: DOUBLE
25731: EQUAL
25732: IFTRUE 25736
25734: GO 25780
25736: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25737: LD_VAR 0 2
25741: PUSH
25742: LD_INT 1
25744: ARRAY
25745: PPUSH
25746: LD_EXP 91
25750: PUSH
25751: LD_EXP 92
25755: ADD
25756: PUSH
25757: LD_EXP 94
25761: ADD
25762: PPUSH
25763: LD_LOC 24
25767: PPUSH
25768: LD_INT 1
25770: PPUSH
25771: LD_INT 0
25773: PPUSH
25774: CALL 16901 0 5
25778: GO 25781
25780: POP
// case Rand ( 1 , 3 ) of 1 :
25781: LD_INT 1
25783: PPUSH
25784: LD_INT 3
25786: PPUSH
25787: CALL_OW 12
25791: PUSH
25792: LD_INT 1
25794: DOUBLE
25795: EQUAL
25796: IFTRUE 25800
25798: GO 25844
25800: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25801: LD_VAR 0 2
25805: PUSH
25806: LD_INT 2
25808: ARRAY
25809: PPUSH
25810: LD_EXP 91
25814: PUSH
25815: LD_EXP 92
25819: ADD
25820: PUSH
25821: LD_EXP 94
25825: ADD
25826: PPUSH
25827: LD_LOC 22
25831: PPUSH
25832: LD_INT 1
25834: PPUSH
25835: LD_INT 0
25837: PPUSH
25838: CALL 16901 0 5
25842: GO 25949
25844: LD_INT 2
25846: DOUBLE
25847: EQUAL
25848: IFTRUE 25852
25850: GO 25896
25852: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25853: LD_VAR 0 2
25857: PUSH
25858: LD_INT 2
25860: ARRAY
25861: PPUSH
25862: LD_EXP 91
25866: PUSH
25867: LD_EXP 92
25871: ADD
25872: PUSH
25873: LD_EXP 94
25877: ADD
25878: PPUSH
25879: LD_LOC 23
25883: PPUSH
25884: LD_INT 1
25886: PPUSH
25887: LD_INT 0
25889: PPUSH
25890: CALL 16901 0 5
25894: GO 25949
25896: LD_INT 3
25898: DOUBLE
25899: EQUAL
25900: IFTRUE 25904
25902: GO 25948
25904: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25905: LD_VAR 0 2
25909: PUSH
25910: LD_INT 2
25912: ARRAY
25913: PPUSH
25914: LD_EXP 91
25918: PUSH
25919: LD_EXP 92
25923: ADD
25924: PUSH
25925: LD_EXP 94
25929: ADD
25930: PPUSH
25931: LD_LOC 24
25935: PPUSH
25936: LD_INT 1
25938: PPUSH
25939: LD_INT 0
25941: PPUSH
25942: CALL 16901 0 5
25946: GO 25949
25948: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25949: LD_VAR 0 2
25953: PUSH
25954: LD_INT 1
25956: ARRAY
25957: PPUSH
25958: LD_VAR 0 1
25962: PUSH
25963: LD_INT 1
25965: ARRAY
25966: PPUSH
25967: CALL_OW 250
25971: PPUSH
25972: LD_VAR 0 1
25976: PUSH
25977: LD_INT 1
25979: ARRAY
25980: PPUSH
25981: CALL_OW 251
25985: PPUSH
25986: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25990: LD_VAR 0 2
25994: PUSH
25995: LD_INT 2
25997: ARRAY
25998: PPUSH
25999: LD_VAR 0 1
26003: PUSH
26004: LD_INT 1
26006: ARRAY
26007: PPUSH
26008: CALL_OW 250
26012: PPUSH
26013: LD_VAR 0 1
26017: PUSH
26018: LD_INT 1
26020: ARRAY
26021: PPUSH
26022: CALL_OW 251
26026: PPUSH
26027: CALL_OW 174
// end ; end ;
26031: PPOPN 2
26033: END
// export function count_crates ; var deps , i ; begin
26034: LD_INT 0
26036: PPUSH
26037: PPUSH
26038: PPUSH
// deps := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26039: LD_ADDR_VAR 0 2
26043: PUSH
26044: LD_INT 22
26046: PUSH
26047: LD_EXP 1
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PUSH
26056: LD_INT 2
26058: PUSH
26059: LD_INT 30
26061: PUSH
26062: LD_INT 0
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 30
26071: PUSH
26072: LD_INT 1
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: LIST
26083: PUSH
26084: EMPTY
26085: LIST
26086: LIST
26087: PPUSH
26088: CALL_OW 69
26092: ST_TO_ADDR
// for i in deps do
26093: LD_ADDR_VAR 0 3
26097: PUSH
26098: LD_VAR 0 2
26102: PUSH
26103: FOR_IN
26104: IFFALSE 26137
// result := result + GetResourceType ( GetBase ( i ) , mat_cans ) ;
26106: LD_ADDR_VAR 0 1
26110: PUSH
26111: LD_VAR 0 1
26115: PUSH
26116: LD_VAR 0 3
26120: PPUSH
26121: CALL_OW 274
26125: PPUSH
26126: LD_INT 1
26128: PPUSH
26129: CALL_OW 275
26133: PLUS
26134: ST_TO_ADDR
26135: GO 26103
26137: POP
26138: POP
// end ;
26139: LD_VAR 0 1
26143: RET
// every 0 0$1 do var zbyva , prebyva ;
26144: GO 26146
26146: DISABLE
26147: LD_INT 0
26149: PPUSH
26150: PPUSH
// begin sec := sec + 1 ;
26151: LD_ADDR_LOC 29
26155: PUSH
26156: LD_LOC 29
26160: PUSH
26161: LD_INT 1
26163: PLUS
26164: ST_TO_ADDR
// zbyva := MaterialNavic - count_crates ;
26165: LD_ADDR_VAR 0 1
26169: PUSH
26170: LD_EXP 51
26174: PUSH
26175: CALL 26034 0 0
26179: MINUS
26180: ST_TO_ADDR
// if zbyva < 0 then
26181: LD_VAR 0 1
26185: PUSH
26186: LD_INT 0
26188: LESS
26189: IFFALSE 26214
// begin prebyva := zbyva * ( - 1 ) ;
26191: LD_ADDR_VAR 0 2
26195: PUSH
26196: LD_VAR 0 1
26200: PUSH
26201: LD_INT 1
26203: NEG
26204: MUL
26205: ST_TO_ADDR
// zbyva := 0 ;
26206: LD_ADDR_VAR 0 1
26210: PUSH
26211: LD_INT 0
26213: ST_TO_ADDR
// end ; display_strings := [ #Am06-1 , zbyva , #Am06-2 , 50 50$0 - ( tick - mytick ) ] ;
26214: LD_ADDR_OWVAR 47
26218: PUSH
26219: LD_STRING #Am06-1
26221: PUSH
26222: LD_VAR 0 1
26226: PUSH
26227: LD_STRING #Am06-2
26229: PUSH
26230: LD_INT 105000
26232: PUSH
26233: LD_OWVAR 1
26237: PUSH
26238: LD_EXP 87
26242: MINUS
26243: MINUS
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: ST_TO_ADDR
// enable ;
26251: ENABLE
// end ;
26252: PPOPN 2
26254: END
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26255: LD_INT 4
26257: PPUSH
26258: LD_INT 22
26260: PUSH
26261: LD_EXP 1
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PPUSH
26270: CALL_OW 70
26274: IFFALSE 26349
26276: GO 26278
26278: DISABLE
26279: LD_INT 0
26281: PPUSH
// begin under_attack := true ;
26282: LD_ADDR_EXP 64
26286: PUSH
26287: LD_INT 1
26289: ST_TO_ADDR
// for i in FilterUnitsInArea ( near_base , [ f_side , you ] ) do
26290: LD_ADDR_VAR 0 1
26294: PUSH
26295: LD_INT 4
26297: PPUSH
26298: LD_INT 22
26300: PUSH
26301: LD_EXP 1
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PPUSH
26310: CALL_OW 70
26314: PUSH
26315: FOR_IN
26316: IFFALSE 26346
// ComAttackUnit ( defence union attack union scout , i ) ;
26318: LD_LOC 6
26322: PUSH
26323: LD_LOC 5
26327: UNION
26328: PUSH
26329: LD_LOC 4
26333: UNION
26334: PPUSH
26335: LD_VAR 0 1
26339: PPUSH
26340: CALL_OW 115
26344: GO 26315
26346: POP
26347: POP
// enable ;
26348: ENABLE
// end ;
26349: PPOPN 1
26351: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26352: LD_INT 4
26354: PPUSH
26355: LD_INT 22
26357: PUSH
26358: LD_EXP 1
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PPUSH
26367: CALL_OW 70
26371: NOT
26372: IFFALSE 26389
26374: GO 26376
26376: DISABLE
26377: LD_INT 0
26379: PPUSH
// begin under_attack := false ;
26380: LD_ADDR_EXP 64
26384: PUSH
26385: LD_INT 0
26387: ST_TO_ADDR
// enable ;
26388: ENABLE
// end ; end_of_file
26389: PPOPN 1
26391: END
// var BaseBuild ; every 0 0$1.0 do var set_fuel , fuel , depot ;
26392: GO 26394
26394: DISABLE
26395: LD_INT 0
26397: PPUSH
26398: PPUSH
26399: PPUSH
// begin for depot in FilterAllUnits ( [ [ f_btype , b_depot ] , [ f_side , you ] ] ) do
26400: LD_ADDR_VAR 0 3
26404: PUSH
26405: LD_INT 30
26407: PUSH
26408: LD_INT 0
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 22
26417: PUSH
26418: LD_EXP 1
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PPUSH
26431: CALL_OW 69
26435: PUSH
26436: FOR_IN
26437: IFFALSE 26544
// for set_fuel in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] , [ f_dist , depot , 8 ] ] ) do
26439: LD_ADDR_VAR 0 1
26443: PUSH
26444: LD_INT 21
26446: PUSH
26447: LD_INT 2
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 22
26456: PUSH
26457: LD_EXP 1
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: LD_INT 91
26468: PUSH
26469: LD_VAR 0 3
26473: PUSH
26474: LD_INT 8
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: LIST
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: PPUSH
26487: CALL_OW 69
26491: PUSH
26492: FOR_IN
26493: IFFALSE 26540
// begin fuel := GetFuel ( set_fuel ) ;
26495: LD_ADDR_VAR 0 2
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: CALL_OW 261
26509: ST_TO_ADDR
// if fuel <= 80 then
26510: LD_VAR 0 2
26514: PUSH
26515: LD_INT 80
26517: LESSEQUAL
26518: IFFALSE 26538
// SetFuel ( set_fuel , fuel + 20 ) ;
26520: LD_VAR 0 1
26524: PPUSH
26525: LD_VAR 0 2
26529: PUSH
26530: LD_INT 20
26532: PLUS
26533: PPUSH
26534: CALL_OW 240
// end ;
26538: GO 26492
26540: POP
26541: POP
26542: GO 26436
26544: POP
26545: POP
// enable ;
26546: ENABLE
// end ;
26547: PPOPN 3
26549: END
// export maj_ct ; on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) then
26550: LD_VAR 0 1
26554: PPUSH
26555: LD_INT 22
26557: PUSH
26558: LD_EXP 1
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 30
26569: PUSH
26570: LD_INT 0
26572: PUSH
26573: EMPTY
26574: LIST
26575: LIST
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PPUSH
26581: CALL_OW 72
26585: IFFALSE 26649
// begin BaseBuild := true ;
26587: LD_ADDR_LOC 32
26591: PUSH
26592: LD_INT 1
26594: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
26595: LD_STRING M1a
26597: PPUSH
26598: CALL_OW 337
// Setbname ( UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) [ 1 ] , epsilon ) ;
26602: LD_VAR 0 1
26606: PPUSH
26607: LD_INT 22
26609: PUSH
26610: LD_EXP 1
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: LD_INT 30
26621: PUSH
26622: LD_INT 0
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PPUSH
26633: CALL_OW 72
26637: PUSH
26638: LD_INT 1
26640: ARRAY
26641: PPUSH
26642: LD_STRING epsilon
26644: PPUSH
26645: CALL_OW 500
// end ; if GetBType ( build ) = b_control_tower then
26649: LD_VAR 0 1
26653: PPUSH
26654: CALL_OW 266
26658: PUSH
26659: LD_INT 36
26661: EQUAL
26662: IFFALSE 26672
// maj_ct := true ;
26664: LD_ADDR_EXP 95
26668: PUSH
26669: LD_INT 1
26671: ST_TO_ADDR
// end ;
26672: PPOPN 1
26674: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_factory ] ] ) then
26675: LD_VAR 0 1
26679: PPUSH
26680: LD_INT 22
26682: PUSH
26683: LD_EXP 1
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 30
26694: PUSH
26695: LD_INT 3
26697: PUSH
26698: EMPTY
26699: LIST
26700: LIST
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL_OW 72
26710: IFFALSE 26719
// MyHint ( NonCombat ) ;
26712: LD_STRING NonCombat
26714: PPUSH
26715: CALL 17625 0 1
// end ;
26719: PPOPN 1
26721: END
// every 0 0$3 do var ok , sez , i ;
26722: GO 26724
26724: DISABLE
26725: LD_INT 0
26727: PPUSH
26728: PPUSH
26729: PPUSH
// begin sez := [ ] ;
26730: LD_ADDR_VAR 0 2
26734: PUSH
26735: EMPTY
26736: ST_TO_ADDR
// ok := false ;
26737: LD_ADDR_VAR 0 1
26741: PUSH
26742: LD_INT 0
26744: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_control , control_remote ] ) do
26745: LD_ADDR_VAR 0 3
26749: PUSH
26750: LD_INT 33
26752: PUSH
26753: LD_INT 2
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PPUSH
26760: CALL_OW 69
26764: PUSH
26765: FOR_IN
26766: IFFALSE 26815
// begin if IsControledBy ( i ) in sez then
26768: LD_VAR 0 3
26772: PPUSH
26773: CALL_OW 312
26777: PUSH
26778: LD_VAR 0 2
26782: IN
26783: IFFALSE 26797
// begin ok := true ;
26785: LD_ADDR_VAR 0 1
26789: PUSH
26790: LD_INT 1
26792: ST_TO_ADDR
// break ;
26793: GO 26815
// end else
26795: GO 26813
// sez := sez ^ i ;
26797: LD_ADDR_VAR 0 2
26801: PUSH
26802: LD_VAR 0 2
26806: PUSH
26807: LD_VAR 0 3
26811: ADD
26812: ST_TO_ADDR
// end ;
26813: GO 26765
26815: POP
26816: POP
// if ok then
26817: LD_VAR 0 1
26821: IFFALSE 26832
// begin ChangeMissionObjectives ( MRa ) ;
26823: LD_STRING MRa
26825: PPUSH
26826: CALL_OW 337
// end else
26830: GO 26833
// enable ;
26832: ENABLE
// end ;
26833: PPOPN 3
26835: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_RemCont and GetSide ( lab ) = you then
26836: LD_VAR 0 1
26840: PUSH
26841: LD_INT 15
26843: EQUAL
26844: PUSH
26845: LD_VAR 0 2
26849: PPUSH
26850: CALL_OW 255
26854: PUSH
26855: LD_EXP 1
26859: EQUAL
26860: AND
26861: IFFALSE 26874
// begin DialogR2 ;
26863: CALL 6592 0 0
// MyHint ( RemoteControlTower ) ;
26867: LD_STRING RemoteControlTower
26869: PPUSH
26870: CALL 17625 0 1
// end ; if tech = tech_MatDet and GetSide ( lab ) = you then
26874: LD_VAR 0 1
26878: PUSH
26879: LD_INT 7
26881: EQUAL
26882: PUSH
26883: LD_VAR 0 2
26887: PPUSH
26888: CALL_OW 255
26892: PUSH
26893: LD_EXP 1
26897: EQUAL
26898: AND
26899: IFFALSE 26908
// begin MyHint ( MaterialisationDetection ) ;
26901: LD_STRING MaterialisationDetection
26903: PPUSH
26904: CALL 17625 0 1
// end ; end ; end_of_file
26908: PPOPN 2
26910: END
// every 0 0$2 + 0 0$0.1 do
26911: GO 26913
26913: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
26914: LD_INT 22
26916: PUSH
26917: LD_INT 1
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: LD_INT 25
26929: PUSH
26930: LD_INT 12
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: PUSH
26937: LD_INT 25
26939: PUSH
26940: LD_INT 16
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: LD_INT 25
26949: PUSH
26950: LD_INT 15
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: LD_INT 25
26959: PUSH
26960: LD_INT 17
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: LIST
26971: LIST
26972: LIST
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PPUSH
26978: CALL_OW 69
26982: PUSH
26983: LD_INT 22
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PUSH
26993: LD_INT 21
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 3
27005: PUSH
27006: LD_INT 2
27008: PUSH
27009: LD_INT 25
27011: PUSH
27012: LD_INT 12
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: PUSH
27019: LD_INT 25
27021: PUSH
27022: LD_INT 16
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PUSH
27029: LD_INT 25
27031: PUSH
27032: LD_INT 15
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 25
27041: PUSH
27042: LD_INT 17
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: LIST
27053: LIST
27054: LIST
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: LIST
27064: PPUSH
27065: CALL_OW 69
27069: GREATER
27070: IFFALSE 27081
// begin SetAchievement ( ACH_POTA ) ;
27072: LD_STRING ACH_POTA
27074: PPUSH
27075: CALL_OW 543
// exit ;
27079: GO 27082
// end ; enable ;
27081: ENABLE
// end ;
27082: END
// export function SA_OnKurtSpared ; begin
27083: LD_INT 0
27085: PPUSH
// SetAchievement ( ACH_MER ) ;
27086: LD_STRING ACH_MER
27088: PPUSH
27089: CALL_OW 543
// end ;
27093: LD_VAR 0 1
27097: RET
// export function SA_OnKurtKilled ; begin
27098: LD_INT 0
27100: PPUSH
// SetAchievement ( ACH_MEL ) ;
27101: LD_STRING ACH_MEL
27103: PPUSH
27104: CALL_OW 543
// end ;
27108: LD_VAR 0 1
27112: RET
// export function SA_On1000CratesGathered ; begin
27113: LD_INT 0
27115: PPUSH
// SetAchievement ( ACH_CAP ) ;
27116: LD_STRING ACH_CAP
27118: PPUSH
27119: CALL_OW 543
// end ;
27123: LD_VAR 0 1
27127: RET
// export function SA_CratesGathered ( count_crates ) ; begin
27128: LD_INT 0
27130: PPUSH
// SetAchievementEX ( ACH_CAP , count_crates ) ;
27131: LD_STRING ACH_CAP
27133: PPUSH
27134: LD_VAR 0 1
27138: PPUSH
27139: CALL_OW 564
// end ;
27143: LD_VAR 0 2
27147: RET
// export function SA_NobodyLeft ; begin
27148: LD_INT 0
27150: PPUSH
// SetAchievement ( ACH_NLB ) ;
27151: LD_STRING ACH_NLB
27153: PPUSH
27154: CALL_OW 543
// end ;
27158: LD_VAR 0 1
27162: RET
// export function SA_JoanDead ; begin
27163: LD_INT 0
27165: PPUSH
// SetAchievement ( ACH_IFL ) ;
27166: LD_STRING ACH_IFL
27168: PPUSH
27169: CALL_OW 543
// end ; end_of_file
27173: LD_VAR 0 1
27177: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
27178: LD_INT 0
27180: PPUSH
27181: PPUSH
// if not missionNumber then
27182: LD_VAR 0 2
27186: NOT
27187: IFFALSE 27191
// exit ;
27189: GO 27321
// achiv := false ;
27191: LD_ADDR_VAR 0 7
27195: PUSH
27196: LD_INT 0
27198: ST_TO_ADDR
// case campaignNumber of 1 :
27199: LD_VAR 0 1
27203: PUSH
27204: LD_INT 1
27206: DOUBLE
27207: EQUAL
27208: IFTRUE 27212
27210: GO 27223
27212: POP
// achiv := ACH_GOTA ; 2 :
27213: LD_ADDR_VAR 0 7
27217: PUSH
27218: LD_STRING ACH_GOTA
27220: ST_TO_ADDR
27221: GO 27273
27223: LD_INT 2
27225: DOUBLE
27226: EQUAL
27227: IFTRUE 27231
27229: GO 27234
27231: POP
// ; 3 :
27232: GO 27273
27234: LD_INT 3
27236: DOUBLE
27237: EQUAL
27238: IFTRUE 27242
27240: GO 27253
27242: POP
// achiv := ACH_MOTSU ; 4 :
27243: LD_ADDR_VAR 0 7
27247: PUSH
27248: LD_STRING ACH_MOTSU
27250: ST_TO_ADDR
27251: GO 27273
27253: LD_INT 4
27255: DOUBLE
27256: EQUAL
27257: IFTRUE 27261
27259: GO 27272
27261: POP
// achiv := ACH_LOP ; end ;
27262: LD_ADDR_VAR 0 7
27266: PUSH
27267: LD_STRING ACH_LOP
27269: ST_TO_ADDR
27270: GO 27273
27272: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
27273: LD_OWVAR 67
27277: PUSH
27278: LD_INT 3
27280: EQUAL
27281: PUSH
27282: LD_VAR 0 7
27286: AND
27287: PUSH
27288: LD_VAR 0 3
27292: AND
27293: PUSH
27294: LD_VAR 0 4
27298: AND
27299: PUSH
27300: LD_VAR 0 5
27304: AND
27305: IFFALSE 27321
// SetAchievementEX ( achiv , missionNumber ) ;
27307: LD_VAR 0 7
27311: PPUSH
27312: LD_VAR 0 2
27316: PPUSH
27317: CALL_OW 564
// end ;
27321: LD_VAR 0 6
27325: RET
// export function SA_BehemothConstructed ; begin
27326: LD_INT 0
27328: PPUSH
// SetAchievement ( ACH_SMC ) ;
27329: LD_STRING ACH_SMC
27331: PPUSH
27332: CALL_OW 543
// end ;
27336: LD_VAR 0 1
27340: RET

// export you , ru , us , ar , ar_al , neutral , camp ; export cpu_list ; export ru_nation , us_nation , ar_nation ; export Burlak , MacMillan , Roth , Gossudarov ; export Petrosyan , Belkov , Kirilenkova , Gnyevko , Gladkov , Dolgov , Gleb , Kapitsova , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Bystrov , Lipshchin , Fadeev ; export Bobby , Brown , Cornell , Connie , Cyrus , Denis , Donaldson , Frank , Gary , Gladstone , Joan , Lisa , Peterson , Simms , VanHouten , Yamoko ; export Omar , OmarKilled , NegotiationOffered , OmarWillTryContaminateMotherlode ; export Powell , Platonov ; export aliance_forces ; export finalize ; export prefered_control ; export siberite_rocket_send ; function prepare_us_units ; begin
   0: LD_INT 0
   2: PPUSH
// Powell := NewCharacter ( Powell ) ;
   3: LD_ADDR_EXP 55
   7: PUSH
   8: LD_STRING Powell
  10: PPUSH
  11: CALL_OW 25
  15: ST_TO_ADDR
// SetSide ( Powell , us ) ;
  16: LD_EXP 55
  20: PPUSH
  21: LD_EXP 3
  25: PPUSH
  26: CALL_OW 235
// end ;
  30: LD_VAR 0 1
  34: RET
// function prepare_ru_units ; begin
  35: LD_INT 0
  37: PPUSH
// Platonov := NewCharacter ( Platonov ) ;
  38: LD_ADDR_EXP 56
  42: PUSH
  43: LD_STRING Platonov
  45: PPUSH
  46: CALL_OW 25
  50: ST_TO_ADDR
// SetSide ( Platonov , ru ) ;
  51: LD_EXP 56
  55: PPUSH
  56: LD_EXP 2
  60: PPUSH
  61: CALL_OW 235
// end ;
  65: LD_VAR 0 1
  69: RET
// function prepare_ar_units ; begin
  70: LD_INT 0
  72: PPUSH
// OmarWillTryContaminateMotherlode = false ;
  73: LD_ADDR_EXP 54
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// if difficulty >= 2 then
  81: LD_OWVAR 67
  85: PUSH
  86: LD_INT 2
  88: GREATEREQUAL
  89: IFFALSE 106
// SetTech ( tech_stimdrugs , ar_al , state_researched ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_EXP 5
  98: PPUSH
  99: LD_INT 2
 101: PPUSH
 102: CALL_OW 322
// if camp = 6 then
 106: LD_EXP 7
 110: PUSH
 111: LD_INT 6
 113: EQUAL
 114: IFFALSE 134
// OmarKilled := LoadVariable ( OmarKilled , true ) else
 116: LD_ADDR_EXP 52
 120: PUSH
 121: LD_STRING OmarKilled
 123: PPUSH
 124: LD_INT 1
 126: PPUSH
 127: CALL_OW 30
 131: ST_TO_ADDR
 132: GO 142
// OmarKilled = false ;
 134: LD_ADDR_EXP 52
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// if OmarKilled then
 142: LD_EXP 52
 146: IFFALSE 158
// begin Omar = 0 ;
 148: LD_ADDR_EXP 51
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// exit ;
 156: GO 244
// end ; if TestCharacters ( Omar ) then
 158: LD_STRING Omar
 160: PPUSH
 161: CALL_OW 28
 165: IFFALSE 182
// Omar := CreateCharacter ( Omar ) else
 167: LD_ADDR_EXP 51
 171: PUSH
 172: LD_STRING Omar
 174: PPUSH
 175: CALL_OW 34
 179: ST_TO_ADDR
 180: GO 195
// Omar = NewCharacter ( Omar ) ;
 182: LD_ADDR_EXP 51
 186: PUSH
 187: LD_STRING Omar
 189: PPUSH
 190: CALL_OW 25
 194: ST_TO_ADDR
// SetSide ( Omar , ar_al ) ;
 195: LD_EXP 51
 199: PPUSH
 200: LD_EXP 5
 204: PPUSH
 205: CALL_OW 235
// NegotiationOffered := LoadVariable ( NegotiationsOffered , false ) ;
 209: LD_ADDR_EXP 53
 213: PUSH
 214: LD_STRING NegotiationsOffered
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// if NegotiationOffered then
 225: LD_EXP 53
 229: IFFALSE 236
// enable ( 2 ) else
 231: LD_INT 2
 233: ENABLE_MARKED
 234: GO 244
// OmarWillTryContaminateMotherlode = true ;
 236: LD_ADDR_EXP 54
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// end ;
 244: LD_VAR 0 1
 248: RET
// function prepare_al_units ; var un , count , i , nations , art_loaded , selected , aliance , pom_list , veh_cargo , veh_basic , veh_battle , vehicles , veh_list , JMM_car , Bur_car ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
// nations := [ nation_american , nation_russian ] ;
 267: LD_ADDR_VAR 0 5
 271: PUSH
 272: LD_INT 1
 274: PUSH
 275: LD_INT 3
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: ST_TO_ADDR
// uc_side := you ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_EXP 1
 291: ST_TO_ADDR
// aliance_forces := [ ] ;
 292: LD_ADDR_EXP 57
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// load_all_aliance ;
 299: CALL 2772 0 0
// aliance := [ ] ;
 303: LD_ADDR_VAR 0 8
 307: PUSH
 308: EMPTY
 309: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 310: LD_ADDR_EXP 12
 314: PUSH
 315: LD_STRING Burlak
 317: PPUSH
 318: CALL_OW 34
 322: ST_TO_ADDR
// aliance := aliance ^ Burlak ;
 323: LD_ADDR_VAR 0 8
 327: PUSH
 328: LD_VAR 0 8
 332: PUSH
 333: LD_EXP 12
 337: ADD
 338: ST_TO_ADDR
// if TestCharacters ( JMM ) and CheckCharacterSet ( JMM ) then
 339: LD_STRING JMM
 341: PPUSH
 342: CALL_OW 28
 346: PUSH
 347: LD_STRING JMM
 349: PPUSH
 350: CALL_OW 29
 354: AND
 355: IFFALSE 398
// begin MacMillan := CreateCharacter ( JMM ) ;
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING JMM
 364: PPUSH
 365: CALL_OW 34
 369: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
 370: LD_EXP 13
 374: PPUSH
 375: LD_INT 2
 377: PPUSH
 378: CALL_OW 336
// aliance := aliance ^ MacMillan ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_VAR 0 8
 391: PUSH
 392: LD_EXP 13
 396: ADD
 397: ST_TO_ADDR
// end ; if TestCharacters ( Roth ) and CheckCharacterSet ( Roth ) then
 398: LD_STRING Roth
 400: PPUSH
 401: CALL_OW 28
 405: PUSH
 406: LD_STRING Roth
 408: PPUSH
 409: CALL_OW 29
 413: AND
 414: IFFALSE 457
// begin Roth := CreateCharacter ( Roth ) ;
 416: LD_ADDR_EXP 14
 420: PUSH
 421: LD_STRING Roth
 423: PPUSH
 424: CALL_OW 34
 428: ST_TO_ADDR
// SetClass ( Roth , class_scientistic ) ;
 429: LD_EXP 14
 433: PPUSH
 434: LD_INT 4
 436: PPUSH
 437: CALL_OW 336
// aliance := aliance ^ Roth ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_VAR 0 8
 450: PUSH
 451: LD_EXP 14
 455: ADD
 456: ST_TO_ADDR
// end ; if TestCharacters ( Gossudarov ) and CheckCharacterSet ( Gossudarov ) then
 457: LD_STRING Gossudarov
 459: PPUSH
 460: CALL_OW 28
 464: PUSH
 465: LD_STRING Gossudarov
 467: PPUSH
 468: CALL_OW 29
 472: AND
 473: IFFALSE 516
// begin Gossudarov := CreateCharacter ( Gossudarov ) ;
 475: LD_ADDR_EXP 15
 479: PUSH
 480: LD_STRING Gossudarov
 482: PPUSH
 483: CALL_OW 34
 487: ST_TO_ADDR
// SetClass ( Gossudarov , class_scientistic ) ;
 488: LD_EXP 15
 492: PPUSH
 493: LD_INT 4
 495: PPUSH
 496: CALL_OW 336
// aliance := aliance ^ Gossudarov ;
 500: LD_ADDR_VAR 0 8
 504: PUSH
 505: LD_VAR 0 8
 509: PUSH
 510: LD_EXP 15
 514: ADD
 515: ST_TO_ADDR
// end ; if aliance < 20 then
 516: LD_VAR 0 8
 520: PUSH
 521: LD_INT 20
 523: LESS
 524: IFFALSE 585
// for i = aliance to 20 do
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: DOUBLE
 532: LD_VAR 0 8
 536: DEC
 537: ST_TO_ADDR
 538: LD_INT 20
 540: PUSH
 541: FOR_TO
 542: IFFALSE 583
// begin PrepareHuman ( 0 , 0 , 6 ) ;
 544: LD_INT 0
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: CALL_OW 380
// hc_last_mission := 15 ;
 557: LD_ADDR_OWVAR 36
 561: PUSH
 562: LD_INT 15
 564: ST_TO_ADDR
// aliance_forces := aliance_forces ^ CreateHuman ;
 565: LD_ADDR_EXP 57
 569: PUSH
 570: LD_EXP 57
 574: PUSH
 575: CALL_OW 44
 579: ADD
 580: ST_TO_ADDR
// end ;
 581: GO 541
 583: POP
 584: POP
// selected := CharacterSelection (  , 12 - aliance , 12 - aliance , aliance ^ [ sel_not_hired , sel_changeable , sel_change_class ] ^ aliance_forces , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
 585: LD_ADDR_VAR 0 7
 589: PUSH
 590: LD_STRING 
 592: PPUSH
 593: LD_INT 12
 595: PUSH
 596: LD_VAR 0 8
 600: MINUS
 601: PPUSH
 602: LD_INT 12
 604: PUSH
 605: LD_VAR 0 8
 609: MINUS
 610: PPUSH
 611: LD_VAR 0 8
 615: PUSH
 616: LD_INT -2
 618: PUSH
 619: LD_INT -3
 621: PUSH
 622: LD_INT -5
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: ADD
 630: PUSH
 631: LD_EXP 57
 635: ADD
 636: PPUSH
 637: LD_INT 1
 639: PUSH
 640: LD_INT 2
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL_OW 42
 659: ST_TO_ADDR
// aliance_forces := aliance ^ selected ;
 660: LD_ADDR_EXP 57
 664: PUSH
 665: LD_VAR 0 8
 669: PUSH
 670: LD_VAR 0 7
 674: ADD
 675: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 676: LD_ADDR_VAR 0 15
 680: PUSH
 681: LD_STRING JMM_car
 683: PPUSH
 684: LD_INT 3
 686: PUSH
 687: LD_INT 1
 689: PUSH
 690: LD_INT 1
 692: PUSH
 693: LD_INT 12
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PPUSH
 702: CALL_OW 30
 706: ST_TO_ADDR
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 707: LD_ADDR_VAR 0 16
 711: PUSH
 712: LD_STRING Bur_car
 714: PPUSH
 715: LD_INT 22
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 1
 723: PUSH
 724: LD_INT 45
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PPUSH
 733: CALL_OW 30
 737: ST_TO_ADDR
// if ( JMM_car [ 1 ] = 0 ) then
 738: LD_VAR 0 15
 742: PUSH
 743: LD_INT 1
 745: ARRAY
 746: PUSH
 747: LD_INT 0
 749: EQUAL
 750: IFFALSE 775
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 752: LD_ADDR_VAR 0 15
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 1
 762: PUSH
 763: LD_INT 1
 765: PUSH
 766: LD_INT 12
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: ST_TO_ADDR
// if ( Bur_car [ 1 ] = 0 ) then
 775: LD_VAR 0 16
 779: PUSH
 780: LD_INT 1
 782: ARRAY
 783: PUSH
 784: LD_INT 0
 786: EQUAL
 787: IFFALSE 812
// Bur_car := [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ;
 789: LD_ADDR_VAR 0 16
 793: PUSH
 794: LD_INT 22
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: LD_INT 1
 802: PUSH
 803: LD_INT 45
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: ST_TO_ADDR
// if not ( ( JMM_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) or ( Bur_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) ) then
 812: LD_VAR 0 15
 816: PUSH
 817: LD_INT 4
 819: ARRAY
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 51
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: IN
 831: PUSH
 832: LD_VAR 0 16
 836: PUSH
 837: LD_INT 4
 839: ARRAY
 840: PUSH
 841: LD_INT 12
 843: PUSH
 844: LD_INT 51
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: IN
 851: OR
 852: NOT
 853: IFFALSE 878
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 855: LD_ADDR_VAR 0 15
 859: PUSH
 860: LD_INT 3
 862: PUSH
 863: LD_INT 1
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 12
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: LIST
 877: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 878: LD_VAR 0 15
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PUSH
 887: LD_INT 1
 889: PUSH
 890: LD_INT 2
 892: PUSH
 893: LD_INT 3
 895: PUSH
 896: LD_INT 4
 898: PUSH
 899: LD_INT 5
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: IN
 909: IFFALSE 921
// uc_nation := nation_american else
 911: LD_ADDR_OWVAR 21
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
 919: GO 929
// uc_nation := nation_russian ;
 921: LD_ADDR_OWVAR 21
 925: PUSH
 926: LD_INT 3
 928: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
 929: LD_ADDR_OWVAR 24
 933: PUSH
 934: LD_INT 2
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: CALL_OW 12
 944: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 945: LD_ADDR_OWVAR 37
 949: PUSH
 950: LD_VAR 0 15
 954: PUSH
 955: LD_INT 1
 957: ARRAY
 958: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 959: LD_ADDR_OWVAR 39
 963: PUSH
 964: LD_VAR 0 15
 968: PUSH
 969: LD_INT 2
 971: ARRAY
 972: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 973: LD_ADDR_OWVAR 38
 977: PUSH
 978: LD_VAR 0 15
 982: PUSH
 983: LD_INT 3
 985: ARRAY
 986: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 987: LD_ADDR_OWVAR 40
 991: PUSH
 992: LD_VAR 0 15
 996: PUSH
 997: LD_INT 4
 999: ARRAY
1000: ST_TO_ADDR
// un := CreateVehicle ;
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: CALL_OW 45
1010: ST_TO_ADDR
// art_loaded := false ;
1011: LD_ADDR_VAR 0 6
1015: PUSH
1016: LD_INT 0
1018: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , un ) ;
1019: LD_EXP 13
1023: PPUSH
1024: LD_VAR 0 2
1028: PPUSH
1029: CALL_OW 52
// PlaceUnitArea ( un , jmm_starting , false ) ;
1033: LD_VAR 0 2
1037: PPUSH
1038: LD_INT 27
1040: PPUSH
1041: LD_INT 0
1043: PPUSH
1044: CALL_OW 49
// if GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] then
1048: LD_VAR 0 2
1052: PPUSH
1053: CALL_OW 264
1057: PUSH
1058: LD_INT 12
1060: PUSH
1061: LD_INT 51
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: IN
1068: IFFALSE 1093
// begin SetCargo ( un , mat_artefact , 50 ) ;
1070: LD_VAR 0 2
1074: PPUSH
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 50
1080: PPUSH
1081: CALL_OW 290
// art_loaded := true ;
1085: LD_ADDR_VAR 0 6
1089: PUSH
1090: LD_INT 1
1092: ST_TO_ADDR
// end ; if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
1093: LD_VAR 0 16
1097: PUSH
1098: LD_INT 1
1100: ARRAY
1101: PUSH
1102: LD_INT 21
1104: PUSH
1105: LD_INT 22
1107: PUSH
1108: LD_INT 23
1110: PUSH
1111: LD_INT 24
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: IN
1120: IFFALSE 1132
// uc_nation := nation_russian else
1122: LD_ADDR_OWVAR 21
1126: PUSH
1127: LD_INT 3
1129: ST_TO_ADDR
1130: GO 1140
// uc_nation := nation_american ;
1132: LD_ADDR_OWVAR 21
1136: PUSH
1137: LD_INT 1
1139: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
1140: LD_ADDR_OWVAR 24
1144: PUSH
1145: LD_INT 2
1147: PPUSH
1148: LD_INT 3
1150: PPUSH
1151: CALL_OW 12
1155: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
1156: LD_ADDR_OWVAR 37
1160: PUSH
1161: LD_VAR 0 16
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
1170: LD_ADDR_OWVAR 39
1174: PUSH
1175: LD_VAR 0 16
1179: PUSH
1180: LD_INT 2
1182: ARRAY
1183: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
1184: LD_ADDR_OWVAR 38
1188: PUSH
1189: LD_VAR 0 16
1193: PUSH
1194: LD_INT 3
1196: ARRAY
1197: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
1198: LD_ADDR_OWVAR 40
1202: PUSH
1203: LD_VAR 0 16
1207: PUSH
1208: LD_INT 4
1210: ARRAY
1211: ST_TO_ADDR
// un := CreateVehicle ;
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: CALL_OW 45
1221: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , un ) ;
1222: LD_EXP 12
1226: PPUSH
1227: LD_VAR 0 2
1231: PPUSH
1232: CALL_OW 52
// PlaceUnitArea ( un , burlak_starting , false ) ;
1236: LD_VAR 0 2
1240: PPUSH
1241: LD_INT 10
1243: PPUSH
1244: LD_INT 0
1246: PPUSH
1247: CALL_OW 49
// if ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) and not art_loaded then
1251: LD_VAR 0 2
1255: PPUSH
1256: CALL_OW 264
1260: PUSH
1261: LD_INT 12
1263: PUSH
1264: LD_INT 51
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: IN
1271: PUSH
1272: LD_VAR 0 6
1276: NOT
1277: AND
1278: IFFALSE 1295
// SetCargo ( un , mat_artefact , 50 ) ;
1280: LD_VAR 0 2
1284: PPUSH
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 50
1290: PPUSH
1291: CALL_OW 290
// veh_cargo := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_cargo_bay ] , [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay ] ] ;
1295: LD_ADDR_VAR 0 10
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: LD_INT 3
1311: PUSH
1312: LD_INT 12
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: PUSH
1322: LD_INT 1
1324: PUSH
1325: LD_INT 3
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: LD_INT 1
1333: PUSH
1334: LD_INT 12
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 3
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 3
1352: PUSH
1353: LD_INT 3
1355: PUSH
1356: LD_INT 51
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 22
1371: PUSH
1372: LD_INT 3
1374: PUSH
1375: LD_INT 1
1377: PUSH
1378: LD_INT 51
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: ST_TO_ADDR
// veh_basic := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_crane ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_bulldozer ] , ] ;
1394: LD_ADDR_VAR 0 11
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 3
1410: PUSH
1411: LD_INT 13
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: PUSH
1421: LD_INT 3
1423: PUSH
1424: LD_INT 24
1426: PUSH
1427: LD_INT 3
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 53
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: ST_TO_ADDR
// veh_battle := [ [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_american , us_medium_tracked , engine_siberite , control_manual , us_laser ] , [ nation_american , us_heavy_tracked , engine_siberite , control_manual , us_heavy_gun ] , [ nation_american , us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_russian , ru_medium_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_gun ] , [ nation_russian , ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun ] , ] ;
1447: LD_ADDR_VAR 0 12
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 3
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 1
1463: PUSH
1464: LD_INT 7
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PUSH
1474: LD_INT 1
1476: PUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 3
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 9
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 3
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: LIST
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 5
1523: PUSH
1524: LD_INT 1
1526: PUSH
1527: LD_INT 1
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 21
1545: PUSH
1546: LD_INT 1
1548: PUSH
1549: LD_INT 1
1551: PUSH
1552: LD_INT 45
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 3
1564: PUSH
1565: LD_INT 22
1567: PUSH
1568: LD_INT 3
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: LD_INT 44
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: PUSH
1584: LD_INT 3
1586: PUSH
1587: LD_INT 23
1589: PUSH
1590: LD_INT 1
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: LD_INT 46
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: PUSH
1606: LD_INT 3
1608: PUSH
1609: LD_INT 24
1611: PUSH
1612: LD_INT 3
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: LD_INT 46
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: ST_TO_ADDR
// veh_list := [ ] ;
1638: LD_ADDR_VAR 0 14
1642: PUSH
1643: EMPTY
1644: ST_TO_ADDR
// count := 0 ;
1645: LD_ADDR_VAR 0 3
1649: PUSH
1650: LD_INT 0
1652: ST_TO_ADDR
// for i = 3 to 4 do
1653: LD_ADDR_VAR 0 4
1657: PUSH
1658: DOUBLE
1659: LD_INT 3
1661: DEC
1662: ST_TO_ADDR
1663: LD_INT 4
1665: PUSH
1666: FOR_TO
1667: IFFALSE 1852
// begin uc_direction := Rand ( 2 , 3 ) ;
1669: LD_ADDR_OWVAR 24
1673: PUSH
1674: LD_INT 2
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// un := veh_cargo [ Rand ( 1 , veh_cargo ) ] ;
1685: LD_ADDR_VAR 0 2
1689: PUSH
1690: LD_VAR 0 10
1694: PUSH
1695: LD_INT 1
1697: PPUSH
1698: LD_VAR 0 10
1702: PPUSH
1703: CALL_OW 12
1707: ARRAY
1708: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1709: LD_ADDR_OWVAR 21
1713: PUSH
1714: LD_VAR 0 2
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1723: LD_ADDR_OWVAR 37
1727: PUSH
1728: LD_VAR 0 2
1732: PUSH
1733: LD_INT 2
1735: ARRAY
1736: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1737: LD_ADDR_OWVAR 39
1741: PUSH
1742: LD_VAR 0 2
1746: PUSH
1747: LD_INT 3
1749: ARRAY
1750: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1751: LD_ADDR_OWVAR 38
1755: PUSH
1756: LD_VAR 0 2
1760: PUSH
1761: LD_INT 4
1763: ARRAY
1764: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1765: LD_ADDR_OWVAR 40
1769: PUSH
1770: LD_VAR 0 2
1774: PUSH
1775: LD_INT 5
1777: ARRAY
1778: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1779: LD_ADDR_VAR 0 14
1783: PUSH
1784: LD_VAR 0 14
1788: PUSH
1789: CALL_OW 45
1793: ADD
1794: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1795: LD_VAR 0 2
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: PUSH
1804: LD_INT 1
1806: EQUAL
1807: IFFALSE 1823
// count := count + 1 ;
1809: LD_ADDR_VAR 0 3
1813: PUSH
1814: LD_VAR 0 3
1818: PUSH
1819: LD_INT 1
1821: PLUS
1822: ST_TO_ADDR
// SetCargo ( veh_list [ veh_list ] , mat_artefact , i * 10 ) ;
1823: LD_VAR 0 14
1827: PUSH
1828: LD_VAR 0 14
1832: ARRAY
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_VAR 0 4
1841: PUSH
1842: LD_INT 10
1844: MUL
1845: PPUSH
1846: CALL_OW 290
// end ;
1850: GO 1666
1852: POP
1853: POP
// for un in veh_basic do
1854: LD_ADDR_VAR 0 2
1858: PUSH
1859: LD_VAR 0 11
1863: PUSH
1864: FOR_IN
1865: IFFALSE 1999
// begin uc_direction := Rand ( 2 , 3 ) ;
1867: LD_ADDR_OWVAR 24
1871: PUSH
1872: LD_INT 2
1874: PPUSH
1875: LD_INT 3
1877: PPUSH
1878: CALL_OW 12
1882: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1883: LD_ADDR_OWVAR 21
1887: PUSH
1888: LD_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: ARRAY
1896: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1897: LD_ADDR_OWVAR 37
1901: PUSH
1902: LD_VAR 0 2
1906: PUSH
1907: LD_INT 2
1909: ARRAY
1910: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1911: LD_ADDR_OWVAR 39
1915: PUSH
1916: LD_VAR 0 2
1920: PUSH
1921: LD_INT 3
1923: ARRAY
1924: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1925: LD_ADDR_OWVAR 38
1929: PUSH
1930: LD_VAR 0 2
1934: PUSH
1935: LD_INT 4
1937: ARRAY
1938: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1939: LD_ADDR_OWVAR 40
1943: PUSH
1944: LD_VAR 0 2
1948: PUSH
1949: LD_INT 5
1951: ARRAY
1952: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1953: LD_ADDR_VAR 0 14
1957: PUSH
1958: LD_VAR 0 14
1962: PUSH
1963: CALL_OW 45
1967: ADD
1968: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1969: LD_VAR 0 2
1973: PUSH
1974: LD_INT 4
1976: ARRAY
1977: PUSH
1978: LD_INT 1
1980: EQUAL
1981: IFFALSE 1997
// count := count + 1 ;
1983: LD_ADDR_VAR 0 3
1987: PUSH
1988: LD_VAR 0 3
1992: PUSH
1993: LD_INT 1
1995: PLUS
1996: ST_TO_ADDR
// end ;
1997: GO 1864
1999: POP
2000: POP
// count := aliance_forces - 2 - count ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: LD_EXP 57
2010: PUSH
2011: LD_INT 2
2013: MINUS
2014: PUSH
2015: LD_VAR 0 3
2019: MINUS
2020: ST_TO_ADDR
// for i = 1 to count do
2021: LD_ADDR_VAR 0 4
2025: PUSH
2026: DOUBLE
2027: LD_INT 1
2029: DEC
2030: ST_TO_ADDR
2031: LD_VAR 0 3
2035: PUSH
2036: FOR_TO
2037: IFFALSE 2167
// begin uc_direction := Rand ( 2 , 3 ) ;
2039: LD_ADDR_OWVAR 24
2043: PUSH
2044: LD_INT 2
2046: PPUSH
2047: LD_INT 3
2049: PPUSH
2050: CALL_OW 12
2054: ST_TO_ADDR
// un := veh_battle [ Rand ( 1 , veh_battle ) ] ;
2055: LD_ADDR_VAR 0 2
2059: PUSH
2060: LD_VAR 0 12
2064: PUSH
2065: LD_INT 1
2067: PPUSH
2068: LD_VAR 0 12
2072: PPUSH
2073: CALL_OW 12
2077: ARRAY
2078: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
2079: LD_ADDR_OWVAR 21
2083: PUSH
2084: LD_VAR 0 2
2088: PUSH
2089: LD_INT 1
2091: ARRAY
2092: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
2093: LD_ADDR_OWVAR 37
2097: PUSH
2098: LD_VAR 0 2
2102: PUSH
2103: LD_INT 2
2105: ARRAY
2106: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
2107: LD_ADDR_OWVAR 39
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: LD_INT 3
2119: ARRAY
2120: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2121: LD_ADDR_OWVAR 38
2125: PUSH
2126: LD_VAR 0 2
2130: PUSH
2131: LD_INT 4
2133: ARRAY
2134: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2135: LD_ADDR_OWVAR 40
2139: PUSH
2140: LD_VAR 0 2
2144: PUSH
2145: LD_INT 5
2147: ARRAY
2148: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2149: LD_ADDR_VAR 0 14
2153: PUSH
2154: LD_VAR 0 14
2158: PUSH
2159: CALL_OW 45
2163: ADD
2164: ST_TO_ADDR
// end ;
2165: GO 2036
2167: POP
2168: POP
// pom_list := aliance_forces diff [ MacMillan , Burlak ] ;
2169: LD_ADDR_VAR 0 9
2173: PUSH
2174: LD_EXP 57
2178: PUSH
2179: LD_EXP 13
2183: PUSH
2184: LD_EXP 12
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: DIFF
2193: ST_TO_ADDR
// i := 1 ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// for un in veh_list do
2202: LD_ADDR_VAR 0 2
2206: PUSH
2207: LD_VAR 0 14
2211: PUSH
2212: FOR_IN
2213: IFFALSE 2314
// begin uc_direction := Rand ( 2 , 3 ) ;
2215: LD_ADDR_OWVAR 24
2219: PUSH
2220: LD_INT 2
2222: PPUSH
2223: LD_INT 3
2225: PPUSH
2226: CALL_OW 12
2230: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
2231: LD_VAR 0 2
2235: PPUSH
2236: CALL_OW 263
2240: PUSH
2241: LD_INT 1
2243: EQUAL
2244: IFFALSE 2297
// begin PlaceHumanInUnit ( pom_list [ i ] , un ) ;
2246: LD_VAR 0 9
2250: PUSH
2251: LD_VAR 0 4
2255: ARRAY
2256: PPUSH
2257: LD_VAR 0 2
2261: PPUSH
2262: CALL_OW 52
// PlaceUnitArea ( un , starting_area , false ) ;
2266: LD_VAR 0 2
2270: PPUSH
2271: LD_INT 7
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 49
// i := i + 1 ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: LD_INT 1
2293: PLUS
2294: ST_TO_ADDR
// end else
2295: GO 2312
// PlaceUnitArea ( un , starting_area , false ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_INT 7
2304: PPUSH
2305: LD_INT 0
2307: PPUSH
2308: CALL_OW 49
// end ;
2312: GO 2212
2314: POP
2315: POP
// ComEnterUnit ( uss_ape , uss ) ;
2316: LD_INT 146
2318: PPUSH
2319: LD_INT 38
2321: PPUSH
2322: CALL_OW 120
// end ;
2326: LD_VAR 0 1
2330: RET
// function prepare_sides ; begin
2331: LD_INT 0
2333: PPUSH
// neutral := 0 ;
2334: LD_ADDR_EXP 6
2338: PUSH
2339: LD_INT 0
2341: ST_TO_ADDR
// you := 7 ;
2342: LD_ADDR_EXP 1
2346: PUSH
2347: LD_INT 7
2349: ST_TO_ADDR
// camp := 4 ;
2350: LD_ADDR_EXP 7
2354: PUSH
2355: LD_INT 4
2357: ST_TO_ADDR
// ru := 3 ;
2358: LD_ADDR_EXP 2
2362: PUSH
2363: LD_INT 3
2365: ST_TO_ADDR
// us := 1 ;
2366: LD_ADDR_EXP 3
2370: PUSH
2371: LD_INT 1
2373: ST_TO_ADDR
// ar := 2 ;
2374: LD_ADDR_EXP 4
2378: PUSH
2379: LD_INT 2
2381: ST_TO_ADDR
// ar_al := 5 ;
2382: LD_ADDR_EXP 5
2386: PUSH
2387: LD_INT 5
2389: ST_TO_ADDR
// cpu_list := [ us , ar , ru ] ;
2390: LD_ADDR_EXP 8
2394: PUSH
2395: LD_EXP 3
2399: PUSH
2400: LD_EXP 4
2404: PUSH
2405: LD_EXP 2
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: ST_TO_ADDR
// ru_nation := nation_russian ;
2415: LD_ADDR_EXP 9
2419: PUSH
2420: LD_INT 3
2422: ST_TO_ADDR
// us_nation := nation_american ;
2423: LD_ADDR_EXP 10
2427: PUSH
2428: LD_INT 1
2430: ST_TO_ADDR
// ar_nation := nation_arabian ;
2431: LD_ADDR_EXP 11
2435: PUSH
2436: LD_INT 2
2438: ST_TO_ADDR
// finalize := 0 ;
2439: LD_ADDR_EXP 58
2443: PUSH
2444: LD_INT 0
2446: ST_TO_ADDR
// siberite_rocket_send := false ;
2447: LD_ADDR_EXP 60
2451: PUSH
2452: LD_INT 0
2454: ST_TO_ADDR
// disable ( 1 ) ;
2455: LD_INT 1
2457: DISABLE_MARKED
// disable ( 2 ) ;
2458: LD_INT 2
2460: DISABLE_MARKED
// disable ( 4 ) ;
2461: LD_INT 4
2463: DISABLE_MARKED
// disable ( 5 ) ;
2464: LD_INT 5
2466: DISABLE_MARKED
// disable ( 24 ) ;
2467: LD_INT 24
2469: DISABLE_MARKED
// disable ( 25 ) ;
2470: LD_INT 25
2472: DISABLE_MARKED
// disable ( 26 ) ;
2473: LD_INT 26
2475: DISABLE_MARKED
// disable ( 222 ) ;
2476: LD_INT 222
2478: DISABLE_MARKED
// disable ( 223 ) ;
2479: LD_INT 223
2481: DISABLE_MARKED
// SetAttitude ( you , ru , att_enemy , true ) ;
2482: LD_EXP 1
2486: PPUSH
2487: LD_EXP 2
2491: PPUSH
2492: LD_INT 2
2494: PPUSH
2495: LD_INT 1
2497: PPUSH
2498: CALL_OW 80
// SetAttitude ( you , us , att_enemy , true ) ;
2502: LD_EXP 1
2506: PPUSH
2507: LD_EXP 3
2511: PPUSH
2512: LD_INT 2
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 80
// SetAttitude ( you , ar , att_enemy , true ) ;
2522: LD_EXP 1
2526: PPUSH
2527: LD_EXP 4
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: CALL_OW 80
// SetAttitude ( you , neutral , att_neutral , true ) ;
2542: LD_EXP 1
2546: PPUSH
2547: LD_EXP 6
2551: PPUSH
2552: LD_INT 0
2554: PPUSH
2555: LD_INT 1
2557: PPUSH
2558: CALL_OW 80
// SetAttitude ( you , ar_al , att_enemy , true ) ;
2562: LD_EXP 1
2566: PPUSH
2567: LD_EXP 5
2571: PPUSH
2572: LD_INT 2
2574: PPUSH
2575: LD_INT 1
2577: PPUSH
2578: CALL_OW 80
// SetAttitude ( ru , us , att_enemy , true ) ;
2582: LD_EXP 2
2586: PPUSH
2587: LD_EXP 3
2591: PPUSH
2592: LD_INT 2
2594: PPUSH
2595: LD_INT 1
2597: PPUSH
2598: CALL_OW 80
// SetAttitude ( ru , ar , att_enemy , true ) ;
2602: LD_EXP 2
2606: PPUSH
2607: LD_EXP 4
2611: PPUSH
2612: LD_INT 2
2614: PPUSH
2615: LD_INT 1
2617: PPUSH
2618: CALL_OW 80
// SetAttitude ( us , ar , att_enemy , true ) ;
2622: LD_EXP 3
2626: PPUSH
2627: LD_EXP 4
2631: PPUSH
2632: LD_INT 2
2634: PPUSH
2635: LD_INT 1
2637: PPUSH
2638: CALL_OW 80
// SetAttitude ( ru , ar_al , att_enemy , true ) ;
2642: LD_EXP 2
2646: PPUSH
2647: LD_EXP 5
2651: PPUSH
2652: LD_INT 2
2654: PPUSH
2655: LD_INT 1
2657: PPUSH
2658: CALL_OW 80
// SetAttitude ( us , ar_al , att_enemy , true ) ;
2662: LD_EXP 3
2666: PPUSH
2667: LD_EXP 5
2671: PPUSH
2672: LD_INT 2
2674: PPUSH
2675: LD_INT 1
2677: PPUSH
2678: CALL_OW 80
// end ;
2682: LD_VAR 0 1
2686: RET
// starting begin RandomizeAll ;
2687: CALL_OW 11
// prepare_sides ;
2691: CALL 2331 0 0
// prepare_us_units ;
2695: CALL 0 0 0
// prepare_ru_units ;
2699: CALL 35 0 0
// prepare_ar_units ;
2703: CALL 70 0 0
// prepare_al_units ;
2707: CALL 249 0 0
// prepare_apemans ;
2711: CALL 7126 0 0
// create_russians ;
2715: CALL 4649 0 0
// create_americans ;
2719: CALL 5349 0 0
// create_arabians ;
2723: CALL 6100 0 0
// init_distribution ;
2727: CALL 26356 0 0
// init_defend ;
2731: CALL 18161 0 0
// init_attack ;
2735: CALL 20774 0 0
// init_keep_base ;
2739: CALL 32229 0 0
// init_research ;
2743: CALL 23953 0 0
// init_manufacture ;
2747: CALL 26703 0 0
// init_crates_loading ;
2751: CALL 32635 0 0
// init_crates_collecting ;
2755: CALL 33372 0 0
// init_alien_research ;
2759: CALL 36896 0 0
// init_sib_rocket ;
2763: CALL 36065 0 0
// starting_scene ;
2767: CALL 7358 0 0
// end ; end_of_file
2771: END
// export function load_all_aliance ; begin
2772: LD_INT 0
2774: PPUSH
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) then
2775: LD_STRING Belkov
2777: PPUSH
2778: CALL_OW 28
2782: PUSH
2783: LD_STRING Belkov
2785: PPUSH
2786: CALL_OW 29
2790: AND
2791: IFFALSE 2822
// begin Belkov := CreateCharacter ( Belkov ) ;
2793: LD_ADDR_EXP 17
2797: PUSH
2798: LD_STRING Belkov
2800: PPUSH
2801: CALL_OW 34
2805: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Belkov ;
2806: LD_ADDR_EXP 57
2810: PUSH
2811: LD_EXP 57
2815: PUSH
2816: LD_EXP 17
2820: ADD
2821: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) then
2822: LD_STRING Petrosyan
2824: PPUSH
2825: CALL_OW 28
2829: PUSH
2830: LD_STRING Petrosyan
2832: PPUSH
2833: CALL_OW 29
2837: AND
2838: IFFALSE 2869
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
2840: LD_ADDR_EXP 16
2844: PUSH
2845: LD_STRING Petrosyan
2847: PPUSH
2848: CALL_OW 34
2852: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrosyan ;
2853: LD_ADDR_EXP 57
2857: PUSH
2858: LD_EXP 57
2862: PUSH
2863: LD_EXP 16
2867: ADD
2868: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) then
2869: LD_STRING Kirilenkova
2871: PPUSH
2872: CALL_OW 28
2876: PUSH
2877: LD_STRING Kirilenkova
2879: PPUSH
2880: CALL_OW 29
2884: AND
2885: IFFALSE 2916
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
2887: LD_ADDR_EXP 18
2891: PUSH
2892: LD_STRING Kirilenkova
2894: PPUSH
2895: CALL_OW 34
2899: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kirilenkova ;
2900: LD_ADDR_EXP 57
2904: PUSH
2905: LD_EXP 57
2909: PUSH
2910: LD_EXP 18
2914: ADD
2915: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) then
2916: LD_STRING Gnyevko
2918: PPUSH
2919: CALL_OW 28
2923: PUSH
2924: LD_STRING Gnyevko
2926: PPUSH
2927: CALL_OW 29
2931: AND
2932: IFFALSE 2963
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
2934: LD_ADDR_EXP 19
2938: PUSH
2939: LD_STRING Gnyevko
2941: PPUSH
2942: CALL_OW 34
2946: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gnyevko ;
2947: LD_ADDR_EXP 57
2951: PUSH
2952: LD_EXP 57
2956: PUSH
2957: LD_EXP 19
2961: ADD
2962: ST_TO_ADDR
// end ; if TestCharacters ( Gladkov ) and CheckCharacterSet ( Gladkov ) then
2963: LD_STRING Gladkov
2965: PPUSH
2966: CALL_OW 28
2970: PUSH
2971: LD_STRING Gladkov
2973: PPUSH
2974: CALL_OW 29
2978: AND
2979: IFFALSE 3010
// begin Gladkov := CreateCharacter ( Gladkov ) ;
2981: LD_ADDR_EXP 20
2985: PUSH
2986: LD_STRING Gladkov
2988: PPUSH
2989: CALL_OW 34
2993: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladkov ;
2994: LD_ADDR_EXP 57
2998: PUSH
2999: LD_EXP 57
3003: PUSH
3004: LD_EXP 20
3008: ADD
3009: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) then
3010: LD_STRING Dolgov
3012: PPUSH
3013: CALL_OW 28
3017: PUSH
3018: LD_STRING Dolgov
3020: PPUSH
3021: CALL_OW 29
3025: AND
3026: IFFALSE 3057
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3028: LD_ADDR_EXP 21
3032: PUSH
3033: LD_STRING Dolgov
3035: PPUSH
3036: CALL_OW 34
3040: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Dolgov ;
3041: LD_ADDR_EXP 57
3045: PUSH
3046: LD_EXP 57
3050: PUSH
3051: LD_EXP 21
3055: ADD
3056: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) then
3057: LD_STRING Gleb
3059: PPUSH
3060: CALL_OW 28
3064: PUSH
3065: LD_STRING Gleb
3067: PPUSH
3068: CALL_OW 29
3072: AND
3073: IFFALSE 3104
// begin Gleb := CreateCharacter ( Gleb ) ;
3075: LD_ADDR_EXP 22
3079: PUSH
3080: LD_STRING Gleb
3082: PPUSH
3083: CALL_OW 34
3087: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gleb ;
3088: LD_ADDR_EXP 57
3092: PUSH
3093: LD_EXP 57
3097: PUSH
3098: LD_EXP 22
3102: ADD
3103: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) then
3104: LD_STRING Kapitsova
3106: PPUSH
3107: CALL_OW 28
3111: PUSH
3112: LD_STRING Kapitsova
3114: PPUSH
3115: CALL_OW 29
3119: AND
3120: IFFALSE 3151
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3122: LD_ADDR_EXP 23
3126: PUSH
3127: LD_STRING Kapitsova
3129: PPUSH
3130: CALL_OW 34
3134: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kapitsova ;
3135: LD_ADDR_EXP 57
3139: PUSH
3140: LD_EXP 57
3144: PUSH
3145: LD_EXP 23
3149: ADD
3150: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) then
3151: LD_STRING Kuzmov
3153: PPUSH
3154: CALL_OW 28
3158: PUSH
3159: LD_STRING Kuzmov
3161: PPUSH
3162: CALL_OW 29
3166: AND
3167: IFFALSE 3198
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3169: LD_ADDR_EXP 24
3173: PUSH
3174: LD_STRING Kuzmov
3176: PPUSH
3177: CALL_OW 34
3181: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kuzmov ;
3182: LD_ADDR_EXP 57
3186: PUSH
3187: LD_EXP 57
3191: PUSH
3192: LD_EXP 24
3196: ADD
3197: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) then
3198: LD_STRING Kovalyuk
3200: PPUSH
3201: CALL_OW 28
3205: PUSH
3206: LD_STRING Kovalyuk
3208: PPUSH
3209: CALL_OW 29
3213: AND
3214: IFFALSE 3245
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
3216: LD_ADDR_EXP 25
3220: PUSH
3221: LD_STRING Kovalyuk
3223: PPUSH
3224: CALL_OW 34
3228: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kovalyuk ;
3229: LD_ADDR_EXP 57
3233: PUSH
3234: LD_EXP 57
3238: PUSH
3239: LD_EXP 25
3243: ADD
3244: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) then
3245: LD_STRING Scholtze
3247: PPUSH
3248: CALL_OW 28
3252: PUSH
3253: LD_STRING Scholtze
3255: PPUSH
3256: CALL_OW 29
3260: AND
3261: IFFALSE 3292
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3263: LD_ADDR_EXP 26
3267: PUSH
3268: LD_STRING Scholtze
3270: PPUSH
3271: CALL_OW 34
3275: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Scholtze ;
3276: LD_ADDR_EXP 57
3280: PUSH
3281: LD_EXP 57
3285: PUSH
3286: LD_EXP 26
3290: ADD
3291: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) then
3292: LD_STRING Karamazov
3294: PPUSH
3295: CALL_OW 28
3299: PUSH
3300: LD_STRING Karamazov
3302: PPUSH
3303: CALL_OW 29
3307: AND
3308: IFFALSE 3339
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3310: LD_ADDR_EXP 27
3314: PUSH
3315: LD_STRING Karamazov
3317: PPUSH
3318: CALL_OW 34
3322: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Karamazov ;
3323: LD_ADDR_EXP 57
3327: PUSH
3328: LD_EXP 57
3332: PUSH
3333: LD_EXP 27
3337: ADD
3338: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) then
3339: LD_STRING Titov
3341: PPUSH
3342: CALL_OW 28
3346: PUSH
3347: LD_STRING Titov
3349: PPUSH
3350: CALL_OW 29
3354: AND
3355: IFFALSE 3386
// begin Titov := CreateCharacter ( Titov ) ;
3357: LD_ADDR_EXP 28
3361: PUSH
3362: LD_STRING Titov
3364: PPUSH
3365: CALL_OW 34
3369: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Titov ;
3370: LD_ADDR_EXP 57
3374: PUSH
3375: LD_EXP 57
3379: PUSH
3380: LD_EXP 28
3384: ADD
3385: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) then
3386: LD_STRING Oblukov
3388: PPUSH
3389: CALL_OW 28
3393: PUSH
3394: LD_STRING Oblukov
3396: PPUSH
3397: CALL_OW 29
3401: AND
3402: IFFALSE 3433
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3404: LD_ADDR_EXP 29
3408: PUSH
3409: LD_STRING Oblukov
3411: PPUSH
3412: CALL_OW 34
3416: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Oblukov ;
3417: LD_ADDR_EXP 57
3421: PUSH
3422: LD_EXP 57
3426: PUSH
3427: LD_EXP 29
3431: ADD
3432: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) then
3433: LD_STRING Kozlov
3435: PPUSH
3436: CALL_OW 28
3440: PUSH
3441: LD_STRING Kozlov
3443: PPUSH
3444: CALL_OW 29
3448: AND
3449: IFFALSE 3480
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3451: LD_ADDR_EXP 30
3455: PUSH
3456: LD_STRING Kozlov
3458: PPUSH
3459: CALL_OW 34
3463: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kozlov ;
3464: LD_ADDR_EXP 57
3468: PUSH
3469: LD_EXP 57
3473: PUSH
3474: LD_EXP 30
3478: ADD
3479: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) then
3480: LD_STRING Petrovova
3482: PPUSH
3483: CALL_OW 28
3487: PUSH
3488: LD_STRING Petrovova
3490: PPUSH
3491: CALL_OW 29
3495: AND
3496: IFFALSE 3527
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3498: LD_ADDR_EXP 31
3502: PUSH
3503: LD_STRING Petrovova
3505: PPUSH
3506: CALL_OW 34
3510: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrovova ;
3511: LD_ADDR_EXP 57
3515: PUSH
3516: LD_EXP 57
3520: PUSH
3521: LD_EXP 31
3525: ADD
3526: ST_TO_ADDR
// end ; if TestCharacters ( Bystrov ) and CheckCharacterSet ( Bystrov ) then
3527: LD_STRING Bystrov
3529: PPUSH
3530: CALL_OW 28
3534: PUSH
3535: LD_STRING Bystrov
3537: PPUSH
3538: CALL_OW 29
3542: AND
3543: IFFALSE 3574
// begin Bystrov := CreateCharacter ( Bystrov ) ;
3545: LD_ADDR_EXP 32
3549: PUSH
3550: LD_STRING Bystrov
3552: PPUSH
3553: CALL_OW 34
3557: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bystrov ;
3558: LD_ADDR_EXP 57
3562: PUSH
3563: LD_EXP 57
3567: PUSH
3568: LD_EXP 32
3572: ADD
3573: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) then
3574: LD_STRING Lipshchin
3576: PPUSH
3577: CALL_OW 28
3581: PUSH
3582: LD_STRING Lipshchin
3584: PPUSH
3585: CALL_OW 29
3589: AND
3590: IFFALSE 3621
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3592: LD_ADDR_EXP 33
3596: PUSH
3597: LD_STRING Lipshchin
3599: PPUSH
3600: CALL_OW 34
3604: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lipshchin ;
3605: LD_ADDR_EXP 57
3609: PUSH
3610: LD_EXP 57
3614: PUSH
3615: LD_EXP 33
3619: ADD
3620: ST_TO_ADDR
// end ; if TestCharacters ( Fadeev ) and CheckCharacterSet ( Fadeev ) then
3621: LD_STRING Fadeev
3623: PPUSH
3624: CALL_OW 28
3628: PUSH
3629: LD_STRING Fadeev
3631: PPUSH
3632: CALL_OW 29
3636: AND
3637: IFFALSE 3668
// begin Fadeev := CreateCharacter ( Fadeev ) ;
3639: LD_ADDR_EXP 34
3643: PUSH
3644: LD_STRING Fadeev
3646: PPUSH
3647: CALL_OW 34
3651: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Fadeev ;
3652: LD_ADDR_EXP 57
3656: PUSH
3657: LD_EXP 57
3661: PUSH
3662: LD_EXP 34
3666: ADD
3667: ST_TO_ADDR
// end ; if TestCharacters ( Bobby ) and CheckCharacterSet ( Bobby ) then
3668: LD_STRING Bobby
3670: PPUSH
3671: CALL_OW 28
3675: PUSH
3676: LD_STRING Bobby
3678: PPUSH
3679: CALL_OW 29
3683: AND
3684: IFFALSE 3715
// begin Bobby := CreateCharacter ( Bobby ) ;
3686: LD_ADDR_EXP 35
3690: PUSH
3691: LD_STRING Bobby
3693: PPUSH
3694: CALL_OW 34
3698: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bobby ;
3699: LD_ADDR_EXP 57
3703: PUSH
3704: LD_EXP 57
3708: PUSH
3709: LD_EXP 35
3713: ADD
3714: ST_TO_ADDR
// end ; if TestCharacters ( Brown ) and CheckCharacterSet ( Brown ) then
3715: LD_STRING Brown
3717: PPUSH
3718: CALL_OW 28
3722: PUSH
3723: LD_STRING Brown
3725: PPUSH
3726: CALL_OW 29
3730: AND
3731: IFFALSE 3762
// begin Brown := CreateCharacter ( Brown ) ;
3733: LD_ADDR_EXP 36
3737: PUSH
3738: LD_STRING Brown
3740: PPUSH
3741: CALL_OW 34
3745: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Brown ;
3746: LD_ADDR_EXP 57
3750: PUSH
3751: LD_EXP 57
3755: PUSH
3756: LD_EXP 36
3760: ADD
3761: ST_TO_ADDR
// end ; if TestCharacters ( Cornell ) and CheckCharacterSet ( Cornell ) then
3762: LD_STRING Cornell
3764: PPUSH
3765: CALL_OW 28
3769: PUSH
3770: LD_STRING Cornell
3772: PPUSH
3773: CALL_OW 29
3777: AND
3778: IFFALSE 3809
// begin Cornell := CreateCharacter ( Cornell ) ;
3780: LD_ADDR_EXP 37
3784: PUSH
3785: LD_STRING Cornell
3787: PPUSH
3788: CALL_OW 34
3792: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cornell ;
3793: LD_ADDR_EXP 57
3797: PUSH
3798: LD_EXP 57
3802: PUSH
3803: LD_EXP 37
3807: ADD
3808: ST_TO_ADDR
// end ; if TestCharacters ( Coonie ) and CheckCharacterSet ( Coonie ) then
3809: LD_STRING Coonie
3811: PPUSH
3812: CALL_OW 28
3816: PUSH
3817: LD_STRING Coonie
3819: PPUSH
3820: CALL_OW 29
3824: AND
3825: IFFALSE 3856
// begin Connie := CreateCharacter ( Coonie ) ;
3827: LD_ADDR_EXP 38
3831: PUSH
3832: LD_STRING Coonie
3834: PPUSH
3835: CALL_OW 34
3839: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Connie ;
3840: LD_ADDR_EXP 57
3844: PUSH
3845: LD_EXP 57
3849: PUSH
3850: LD_EXP 38
3854: ADD
3855: ST_TO_ADDR
// end ; if TestCharacters ( Cyrus ) and CheckCharacterSet ( Cyrus ) then
3856: LD_STRING Cyrus
3858: PPUSH
3859: CALL_OW 28
3863: PUSH
3864: LD_STRING Cyrus
3866: PPUSH
3867: CALL_OW 29
3871: AND
3872: IFFALSE 3903
// begin Cyrus := CreateCharacter ( Cyrus ) ;
3874: LD_ADDR_EXP 39
3878: PUSH
3879: LD_STRING Cyrus
3881: PPUSH
3882: CALL_OW 34
3886: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cyrus ;
3887: LD_ADDR_EXP 57
3891: PUSH
3892: LD_EXP 57
3896: PUSH
3897: LD_EXP 39
3901: ADD
3902: ST_TO_ADDR
// end ; if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
3903: LD_STRING Denis
3905: PPUSH
3906: CALL_OW 28
3910: PUSH
3911: LD_STRING Denis
3913: PPUSH
3914: CALL_OW 29
3918: AND
3919: IFFALSE 3950
// begin Denis := CreateCharacter ( Denis ) ;
3921: LD_ADDR_EXP 40
3925: PUSH
3926: LD_STRING Denis
3928: PPUSH
3929: CALL_OW 34
3933: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Denis ;
3934: LD_ADDR_EXP 57
3938: PUSH
3939: LD_EXP 57
3943: PUSH
3944: LD_EXP 40
3948: ADD
3949: ST_TO_ADDR
// end ; if TestCharacters ( Donaldson ) and CheckCharacterSet ( Donaldson ) then
3950: LD_STRING Donaldson
3952: PPUSH
3953: CALL_OW 28
3957: PUSH
3958: LD_STRING Donaldson
3960: PPUSH
3961: CALL_OW 29
3965: AND
3966: IFFALSE 3997
// begin Donaldson := CreateCharacter ( Donaldson ) ;
3968: LD_ADDR_EXP 41
3972: PUSH
3973: LD_STRING Donaldson
3975: PPUSH
3976: CALL_OW 34
3980: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Donaldson ;
3981: LD_ADDR_EXP 57
3985: PUSH
3986: LD_EXP 57
3990: PUSH
3991: LD_EXP 41
3995: ADD
3996: ST_TO_ADDR
// end ; if TestCharacters ( Frank ) and CheckCharacterSet ( Frank ) then
3997: LD_STRING Frank
3999: PPUSH
4000: CALL_OW 28
4004: PUSH
4005: LD_STRING Frank
4007: PPUSH
4008: CALL_OW 29
4012: AND
4013: IFFALSE 4044
// begin Frank := CreateCharacter ( Frank ) ;
4015: LD_ADDR_EXP 42
4019: PUSH
4020: LD_STRING Frank
4022: PPUSH
4023: CALL_OW 34
4027: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Frank ;
4028: LD_ADDR_EXP 57
4032: PUSH
4033: LD_EXP 57
4037: PUSH
4038: LD_EXP 42
4042: ADD
4043: ST_TO_ADDR
// end ; if TestCharacters ( Gary ) and CheckCharacterSet ( Gary ) then
4044: LD_STRING Gary
4046: PPUSH
4047: CALL_OW 28
4051: PUSH
4052: LD_STRING Gary
4054: PPUSH
4055: CALL_OW 29
4059: AND
4060: IFFALSE 4091
// begin Gary := CreateCharacter ( Gary ) ;
4062: LD_ADDR_EXP 43
4066: PUSH
4067: LD_STRING Gary
4069: PPUSH
4070: CALL_OW 34
4074: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gary ;
4075: LD_ADDR_EXP 57
4079: PUSH
4080: LD_EXP 57
4084: PUSH
4085: LD_EXP 43
4089: ADD
4090: ST_TO_ADDR
// end ; if TestCharacters ( Gladstone ) and CheckCharacterSet ( Gladstone ) then
4091: LD_STRING Gladstone
4093: PPUSH
4094: CALL_OW 28
4098: PUSH
4099: LD_STRING Gladstone
4101: PPUSH
4102: CALL_OW 29
4106: AND
4107: IFFALSE 4138
// begin Gladstone := CreateCharacter ( Gladstone ) ;
4109: LD_ADDR_EXP 44
4113: PUSH
4114: LD_STRING Gladstone
4116: PPUSH
4117: CALL_OW 34
4121: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladstone ;
4122: LD_ADDR_EXP 57
4126: PUSH
4127: LD_EXP 57
4131: PUSH
4132: LD_EXP 44
4136: ADD
4137: ST_TO_ADDR
// end ; if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) and camp = 4 then
4138: LD_STRING Joan
4140: PPUSH
4141: CALL_OW 28
4145: PUSH
4146: LD_STRING Joan
4148: PPUSH
4149: CALL_OW 29
4153: AND
4154: PUSH
4155: LD_EXP 7
4159: PUSH
4160: LD_INT 4
4162: EQUAL
4163: AND
4164: IFFALSE 4195
// begin Joan := CreateCharacter ( Joan ) ;
4166: LD_ADDR_EXP 45
4170: PUSH
4171: LD_STRING Joan
4173: PPUSH
4174: CALL_OW 34
4178: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Joan ;
4179: LD_ADDR_EXP 57
4183: PUSH
4184: LD_EXP 57
4188: PUSH
4189: LD_EXP 45
4193: ADD
4194: ST_TO_ADDR
// end ; if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
4195: LD_STRING Lisa
4197: PPUSH
4198: CALL_OW 28
4202: PUSH
4203: LD_STRING Lisa
4205: PPUSH
4206: CALL_OW 29
4210: AND
4211: IFFALSE 4242
// begin Lisa := CreateCharacter ( Lisa ) ;
4213: LD_ADDR_EXP 46
4217: PUSH
4218: LD_STRING Lisa
4220: PPUSH
4221: CALL_OW 34
4225: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lisa ;
4226: LD_ADDR_EXP 57
4230: PUSH
4231: LD_EXP 57
4235: PUSH
4236: LD_EXP 46
4240: ADD
4241: ST_TO_ADDR
// end ; if TestCharacters ( Peterson ) and CheckCharacterSet ( Peterson ) then
4242: LD_STRING Peterson
4244: PPUSH
4245: CALL_OW 28
4249: PUSH
4250: LD_STRING Peterson
4252: PPUSH
4253: CALL_OW 29
4257: AND
4258: IFFALSE 4289
// begin Peterson := CreateCharacter ( Peterson ) ;
4260: LD_ADDR_EXP 47
4264: PUSH
4265: LD_STRING Peterson
4267: PPUSH
4268: CALL_OW 34
4272: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Peterson ;
4273: LD_ADDR_EXP 57
4277: PUSH
4278: LD_EXP 57
4282: PUSH
4283: LD_EXP 47
4287: ADD
4288: ST_TO_ADDR
// end ; if TestCharacters ( Simms ) and CheckCharacterSet ( Simms ) then
4289: LD_STRING Simms
4291: PPUSH
4292: CALL_OW 28
4296: PUSH
4297: LD_STRING Simms
4299: PPUSH
4300: CALL_OW 29
4304: AND
4305: IFFALSE 4336
// begin Simms := CreateCharacter ( Simms ) ;
4307: LD_ADDR_EXP 48
4311: PUSH
4312: LD_STRING Simms
4314: PPUSH
4315: CALL_OW 34
4319: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Simms ;
4320: LD_ADDR_EXP 57
4324: PUSH
4325: LD_EXP 57
4329: PUSH
4330: LD_EXP 48
4334: ADD
4335: ST_TO_ADDR
// end ; if TestCharacters ( VanHouten ) and CheckCharacterSet ( VanHouten ) then
4336: LD_STRING VanHouten
4338: PPUSH
4339: CALL_OW 28
4343: PUSH
4344: LD_STRING VanHouten
4346: PPUSH
4347: CALL_OW 29
4351: AND
4352: IFFALSE 4383
// begin VanHouten := CreateCharacter ( VanHouten ) ;
4354: LD_ADDR_EXP 49
4358: PUSH
4359: LD_STRING VanHouten
4361: PPUSH
4362: CALL_OW 34
4366: ST_TO_ADDR
// aliance_forces := aliance_forces ^ VanHouten ;
4367: LD_ADDR_EXP 57
4371: PUSH
4372: LD_EXP 57
4376: PUSH
4377: LD_EXP 49
4381: ADD
4382: ST_TO_ADDR
// end ; if TestCharacters ( Yamoko ) and CheckCharacterSet ( Yamoko ) then
4383: LD_STRING Yamoko
4385: PPUSH
4386: CALL_OW 28
4390: PUSH
4391: LD_STRING Yamoko
4393: PPUSH
4394: CALL_OW 29
4398: AND
4399: IFFALSE 4430
// begin Yamoko := CreateCharacter ( Yamoko ) ;
4401: LD_ADDR_EXP 50
4405: PUSH
4406: LD_STRING Yamoko
4408: PPUSH
4409: CALL_OW 34
4413: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Yamoko ;
4414: LD_ADDR_EXP 57
4418: PUSH
4419: LD_EXP 57
4423: PUSH
4424: LD_EXP 50
4428: ADD
4429: ST_TO_ADDR
// end ; DisableAllBazookers ;
4430: CALL 4562 0 0
// if camp = 4 then
4434: LD_EXP 7
4438: PUSH
4439: LD_INT 4
4441: EQUAL
4442: IFFALSE 4448
// sort_aliance_by_the_nation ;
4444: CALL 4453 0 0
// end ;
4448: LD_VAR 0 1
4452: RET
// function sort_aliance_by_the_nation ; var un , us_list , ru_list ; begin
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
// us_list := [ ] ;
4459: LD_ADDR_VAR 0 3
4463: PUSH
4464: EMPTY
4465: ST_TO_ADDR
// ru_list := [ ] ;
4466: LD_ADDR_VAR 0 4
4470: PUSH
4471: EMPTY
4472: ST_TO_ADDR
// for un in aliance_forces do
4473: LD_ADDR_VAR 0 2
4477: PUSH
4478: LD_EXP 57
4482: PUSH
4483: FOR_IN
4484: IFFALSE 4539
// if GetNation ( un ) = us then
4486: LD_VAR 0 2
4490: PPUSH
4491: CALL_OW 248
4495: PUSH
4496: LD_EXP 3
4500: EQUAL
4501: IFFALSE 4521
// us_list := us_list ^ un else
4503: LD_ADDR_VAR 0 3
4507: PUSH
4508: LD_VAR 0 3
4512: PUSH
4513: LD_VAR 0 2
4517: ADD
4518: ST_TO_ADDR
4519: GO 4537
// ru_list := ru_list ^ un ;
4521: LD_ADDR_VAR 0 4
4525: PUSH
4526: LD_VAR 0 4
4530: PUSH
4531: LD_VAR 0 2
4535: ADD
4536: ST_TO_ADDR
4537: GO 4483
4539: POP
4540: POP
// aliance_forces := us_list ^ ru_list ;
4541: LD_ADDR_EXP 57
4545: PUSH
4546: LD_VAR 0 3
4550: PUSH
4551: LD_VAR 0 4
4555: ADD
4556: ST_TO_ADDR
// end ;
4557: LD_VAR 0 1
4561: RET
// function DisableAllBazookers ; var list , un ; begin
4562: LD_INT 0
4564: PPUSH
4565: PPUSH
4566: PPUSH
// list := [ ] ;
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: EMPTY
4573: ST_TO_ADDR
// for un in aliance_forces do
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: LD_EXP 57
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4632
// begin if GetClass ( un ) = class_bazooker then
4587: LD_VAR 0 3
4591: PPUSH
4592: CALL_OW 257
4596: PUSH
4597: LD_INT 9
4599: EQUAL
4600: IFFALSE 4614
// SetClass ( un , class_soldier ) ;
4602: LD_VAR 0 3
4606: PPUSH
4607: LD_INT 1
4609: PPUSH
4610: CALL_OW 336
// list := list ^ un ;
4614: LD_ADDR_VAR 0 2
4618: PUSH
4619: LD_VAR 0 2
4623: PUSH
4624: LD_VAR 0 3
4628: ADD
4629: ST_TO_ADDR
// end ;
4630: GO 4584
4632: POP
4633: POP
// aliance_forces := list ;
4634: LD_ADDR_EXP 57
4638: PUSH
4639: LD_VAR 0 2
4643: ST_TO_ADDR
// end ; end_of_file
4644: LD_VAR 0 1
4648: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_russians ; var un , class_list , members ; begin
4649: LD_INT 0
4651: PPUSH
4652: PPUSH
4653: PPUSH
4654: PPUSH
// cpu_side := ru ;
4655: LD_ADDR_LOC 1
4659: PUSH
4660: LD_EXP 2
4664: ST_TO_ADDR
// cpu_nation := nation_russian ;
4665: LD_ADDR_LOC 2
4669: PUSH
4670: LD_INT 3
4672: ST_TO_ADDR
// cpu_base := ru_create ;
4673: LD_ADDR_LOC 3
4677: PUSH
4678: LD_INT 17
4680: ST_TO_ADDR
// members := difficulty * 2 ;
4681: LD_ADDR_VAR 0 4
4685: PUSH
4686: LD_OWVAR 67
4690: PUSH
4691: LD_INT 2
4693: MUL
4694: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: LD_INT 3
4705: PUSH
4706: LD_INT 4
4708: PUSH
4709: LD_INT 2
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: LIST
4717: ST_TO_ADDR
// for un in class_list do
4718: LD_ADDR_VAR 0 2
4722: PUSH
4723: LD_VAR 0 3
4727: PUSH
4728: FOR_IN
4729: IFFALSE 4762
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
4731: LD_LOC 1
4735: PPUSH
4736: LD_LOC 2
4740: PPUSH
4741: LD_VAR 0 2
4745: PPUSH
4746: LD_VAR 0 4
4750: PPUSH
4751: LD_LOC 3
4755: PPUSH
4756: CALL 6800 0 5
4760: GO 4728
4762: POP
4763: POP
// place_all_soldiers ;
4764: CALL 4781 0 0
// place_all_scientistics ;
4768: CALL 4989 0 0
// place_all_mechanics ;
4772: CALL 5178 0 0
// end ;
4776: LD_VAR 0 1
4780: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
4781: LD_INT 0
4783: PPUSH
4784: PPUSH
4785: PPUSH
4786: PPUSH
4787: PPUSH
4788: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
4789: LD_ADDR_VAR 0 6
4793: PUSH
4794: LD_INT 22
4796: PUSH
4797: LD_LOC 1
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PUSH
4806: LD_INT 30
4808: PUSH
4809: LD_INT 32
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_INT 22
4832: PUSH
4833: LD_LOC 1
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 25
4844: PUSH
4845: LD_INT 1
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// if buildings >= units then
4861: LD_VAR 0 6
4865: PUSH
4866: LD_VAR 0 5
4870: GREATEREQUAL
4871: IFFALSE 4889
// max := 0 + units else
4873: LD_ADDR_VAR 0 4
4877: PUSH
4878: LD_INT 0
4880: PUSH
4881: LD_VAR 0 5
4885: PLUS
4886: ST_TO_ADDR
4887: GO 4903
// max := 0 + buildings ;
4889: LD_ADDR_VAR 0 4
4893: PUSH
4894: LD_INT 0
4896: PUSH
4897: LD_VAR 0 6
4901: PLUS
4902: ST_TO_ADDR
// i = 1 ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 1
4910: ST_TO_ADDR
// for un in units do
4911: LD_ADDR_VAR 0 2
4915: PUSH
4916: LD_VAR 0 5
4920: PUSH
4921: FOR_IN
4922: IFFALSE 4982
// begin if i <= max then
4924: LD_VAR 0 3
4928: PUSH
4929: LD_VAR 0 4
4933: LESSEQUAL
4934: IFFALSE 4966
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_VAR 0 6
4945: PUSH
4946: LD_VAR 0 3
4950: PUSH
4951: LD_VAR 0 6
4955: MOD
4956: PUSH
4957: LD_INT 1
4959: PLUS
4960: ARRAY
4961: PPUSH
4962: CALL_OW 120
// i := i + 1 ;
4966: LD_ADDR_VAR 0 3
4970: PUSH
4971: LD_VAR 0 3
4975: PUSH
4976: LD_INT 1
4978: PLUS
4979: ST_TO_ADDR
// end ;
4980: GO 4921
4982: POP
4983: POP
// end ;
4984: LD_VAR 0 1
4988: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
4989: LD_INT 0
4991: PPUSH
4992: PPUSH
4993: PPUSH
4994: PPUSH
4995: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
4996: LD_ADDR_VAR 0 5
5000: PUSH
5001: LD_INT 22
5003: PUSH
5004: LD_LOC 1
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 30
5018: PUSH
5019: LD_INT 8
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 30
5028: PUSH
5029: LD_INT 6
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: LIST
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PPUSH
5045: CALL_OW 69
5049: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5050: LD_ADDR_VAR 0 4
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_LOC 1
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PUSH
5067: LD_INT 25
5069: PUSH
5070: LD_INT 4
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PPUSH
5081: CALL_OW 69
5085: ST_TO_ADDR
// i = 1 ;
5086: LD_ADDR_VAR 0 3
5090: PUSH
5091: LD_INT 1
5093: ST_TO_ADDR
// for un in units do
5094: LD_ADDR_VAR 0 2
5098: PUSH
5099: LD_VAR 0 4
5103: PUSH
5104: FOR_IN
5105: IFFALSE 5171
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5107: LD_VAR 0 2
5111: PPUSH
5112: LD_VAR 0 5
5116: PUSH
5117: LD_VAR 0 3
5121: PUSH
5122: LD_VAR 0 5
5126: MOD
5127: PUSH
5128: LD_INT 1
5130: PLUS
5131: ARRAY
5132: PPUSH
5133: CALL_OW 120
// i := i + 1 ;
5137: LD_ADDR_VAR 0 3
5141: PUSH
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ST_TO_ADDR
// if i > ( units div 2 ) then
5151: LD_VAR 0 3
5155: PUSH
5156: LD_VAR 0 4
5160: PUSH
5161: LD_INT 2
5163: DIV
5164: GREATER
5165: IFFALSE 5169
// break ;
5167: GO 5171
// end ;
5169: GO 5104
5171: POP
5172: POP
// end ;
5173: LD_VAR 0 1
5177: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5178: LD_INT 0
5180: PPUSH
5181: PPUSH
5182: PPUSH
5183: PPUSH
5184: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5185: LD_ADDR_VAR 0 5
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_LOC 1
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: PUSH
5202: LD_INT 2
5204: PUSH
5205: LD_INT 30
5207: PUSH
5208: LD_INT 2
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 3
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: PPUSH
5234: CALL_OW 69
5238: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5239: LD_ADDR_VAR 0 4
5243: PUSH
5244: LD_INT 22
5246: PUSH
5247: LD_LOC 1
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: PUSH
5256: LD_INT 25
5258: PUSH
5259: LD_INT 3
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PPUSH
5270: CALL_OW 69
5274: ST_TO_ADDR
// i = 1 ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// for un in units do
5283: LD_ADDR_VAR 0 2
5287: PUSH
5288: LD_VAR 0 4
5292: PUSH
5293: FOR_IN
5294: IFFALSE 5342
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5296: LD_VAR 0 2
5300: PPUSH
5301: LD_VAR 0 5
5305: PUSH
5306: LD_VAR 0 3
5310: PUSH
5311: LD_VAR 0 5
5315: MOD
5316: PUSH
5317: LD_INT 1
5319: PLUS
5320: ARRAY
5321: PPUSH
5322: CALL_OW 120
// i := i + 1 ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_VAR 0 3
5335: PUSH
5336: LD_INT 1
5338: PLUS
5339: ST_TO_ADDR
// end ;
5340: GO 5293
5342: POP
5343: POP
// end ; end_of_file
5344: LD_VAR 0 1
5348: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_americans ; var un , class_list , members ; begin
5349: LD_INT 0
5351: PPUSH
5352: PPUSH
5353: PPUSH
5354: PPUSH
// cpu_side := us ;
5355: LD_ADDR_LOC 4
5359: PUSH
5360: LD_EXP 3
5364: ST_TO_ADDR
// cpu_nation := nation_american ;
5365: LD_ADDR_LOC 5
5369: PUSH
5370: LD_INT 1
5372: ST_TO_ADDR
// cpu_base := us_create ;
5373: LD_ADDR_LOC 6
5377: PUSH
5378: LD_INT 18
5380: ST_TO_ADDR
// members := difficulty * 2 ;
5381: LD_ADDR_VAR 0 4
5385: PUSH
5386: LD_OWVAR 67
5390: PUSH
5391: LD_INT 2
5393: MUL
5394: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
5395: LD_ADDR_VAR 0 3
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 3
5405: PUSH
5406: LD_INT 4
5408: PUSH
5409: LD_INT 2
5411: PUSH
5412: EMPTY
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: ST_TO_ADDR
// for un in class_list do
5418: LD_ADDR_VAR 0 2
5422: PUSH
5423: LD_VAR 0 3
5427: PUSH
5428: FOR_IN
5429: IFFALSE 5462
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5431: LD_LOC 4
5435: PPUSH
5436: LD_LOC 5
5440: PPUSH
5441: LD_VAR 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: LD_LOC 6
5455: PPUSH
5456: CALL 6800 0 5
5460: GO 5428
5462: POP
5463: POP
// create_units ( cpu_side , cpu_nation , class_mechanic , 2 , cpu_base ) ;
5464: LD_LOC 4
5468: PPUSH
5469: LD_LOC 5
5473: PPUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 2
5479: PPUSH
5480: LD_LOC 6
5484: PPUSH
5485: CALL 6800 0 5
// SetResourceVisibility ( 43 , 81 , 1 ) ;
5489: LD_INT 43
5491: PPUSH
5492: LD_INT 81
5494: PPUSH
5495: LD_INT 1
5497: PPUSH
5498: CALL_OW 441
// SetResourceVisibility ( 30 , 49 , 1 ) ;
5502: LD_INT 30
5504: PPUSH
5505: LD_INT 49
5507: PPUSH
5508: LD_INT 1
5510: PPUSH
5511: CALL_OW 441
// place_all_soldiers ;
5515: CALL 5532 0 0
// place_all_scientistics ;
5519: CALL 5740 0 0
// place_all_mechanics ;
5523: CALL 5929 0 0
// end ;
5527: LD_VAR 0 1
5531: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5532: LD_INT 0
5534: PPUSH
5535: PPUSH
5536: PPUSH
5537: PPUSH
5538: PPUSH
5539: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_INT 22
5547: PUSH
5548: LD_LOC 4
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 30
5559: PUSH
5560: LD_INT 32
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PPUSH
5571: CALL_OW 69
5575: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5576: LD_ADDR_VAR 0 5
5580: PUSH
5581: LD_INT 22
5583: PUSH
5584: LD_LOC 4
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 25
5595: PUSH
5596: LD_INT 1
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// if buildings >= units then
5612: LD_VAR 0 6
5616: PUSH
5617: LD_VAR 0 5
5621: GREATEREQUAL
5622: IFFALSE 5640
// max := 0 + units else
5624: LD_ADDR_VAR 0 4
5628: PUSH
5629: LD_INT 0
5631: PUSH
5632: LD_VAR 0 5
5636: PLUS
5637: ST_TO_ADDR
5638: GO 5654
// max := 0 + buildings ;
5640: LD_ADDR_VAR 0 4
5644: PUSH
5645: LD_INT 0
5647: PUSH
5648: LD_VAR 0 6
5652: PLUS
5653: ST_TO_ADDR
// i = 1 ;
5654: LD_ADDR_VAR 0 3
5658: PUSH
5659: LD_INT 1
5661: ST_TO_ADDR
// for un in units do
5662: LD_ADDR_VAR 0 2
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: FOR_IN
5673: IFFALSE 5733
// begin if i <= max then
5675: LD_VAR 0 3
5679: PUSH
5680: LD_VAR 0 4
5684: LESSEQUAL
5685: IFFALSE 5717
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5687: LD_VAR 0 2
5691: PPUSH
5692: LD_VAR 0 6
5696: PUSH
5697: LD_VAR 0 3
5701: PUSH
5702: LD_VAR 0 6
5706: MOD
5707: PUSH
5708: LD_INT 1
5710: PLUS
5711: ARRAY
5712: PPUSH
5713: CALL_OW 120
// i := i + 1 ;
5717: LD_ADDR_VAR 0 3
5721: PUSH
5722: LD_VAR 0 3
5726: PUSH
5727: LD_INT 1
5729: PLUS
5730: ST_TO_ADDR
// end ;
5731: GO 5672
5733: POP
5734: POP
// end ;
5735: LD_VAR 0 1
5739: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5740: LD_INT 0
5742: PPUSH
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5747: LD_ADDR_VAR 0 5
5751: PUSH
5752: LD_INT 22
5754: PUSH
5755: LD_LOC 4
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: LD_INT 2
5766: PUSH
5767: LD_INT 30
5769: PUSH
5770: LD_INT 8
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 30
5779: PUSH
5780: LD_INT 6
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PPUSH
5796: CALL_OW 69
5800: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5801: LD_ADDR_VAR 0 4
5805: PUSH
5806: LD_INT 22
5808: PUSH
5809: LD_LOC 4
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 25
5820: PUSH
5821: LD_INT 4
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL_OW 69
5836: ST_TO_ADDR
// i = 1 ;
5837: LD_ADDR_VAR 0 3
5841: PUSH
5842: LD_INT 1
5844: ST_TO_ADDR
// for un in units do
5845: LD_ADDR_VAR 0 2
5849: PUSH
5850: LD_VAR 0 4
5854: PUSH
5855: FOR_IN
5856: IFFALSE 5922
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5858: LD_VAR 0 2
5862: PPUSH
5863: LD_VAR 0 5
5867: PUSH
5868: LD_VAR 0 3
5872: PUSH
5873: LD_VAR 0 5
5877: MOD
5878: PUSH
5879: LD_INT 1
5881: PLUS
5882: ARRAY
5883: PPUSH
5884: CALL_OW 120
// i := i + 1 ;
5888: LD_ADDR_VAR 0 3
5892: PUSH
5893: LD_VAR 0 3
5897: PUSH
5898: LD_INT 1
5900: PLUS
5901: ST_TO_ADDR
// if i > ( units div 2 ) then
5902: LD_VAR 0 3
5906: PUSH
5907: LD_VAR 0 4
5911: PUSH
5912: LD_INT 2
5914: DIV
5915: GREATER
5916: IFFALSE 5920
// break ;
5918: GO 5922
// end ;
5920: GO 5855
5922: POP
5923: POP
// end ;
5924: LD_VAR 0 1
5928: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5929: LD_INT 0
5931: PPUSH
5932: PPUSH
5933: PPUSH
5934: PPUSH
5935: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5936: LD_ADDR_VAR 0 5
5940: PUSH
5941: LD_INT 22
5943: PUSH
5944: LD_LOC 4
5948: PUSH
5949: EMPTY
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 2
5955: PUSH
5956: LD_INT 30
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: LD_INT 30
5968: PUSH
5969: LD_INT 3
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PPUSH
5985: CALL_OW 69
5989: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5990: LD_ADDR_VAR 0 4
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_LOC 4
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: LD_INT 25
6009: PUSH
6010: LD_INT 3
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: PPUSH
6021: CALL_OW 69
6025: ST_TO_ADDR
// i = 1 ;
6026: LD_ADDR_VAR 0 3
6030: PUSH
6031: LD_INT 1
6033: ST_TO_ADDR
// for un in units do
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 4
6043: PUSH
6044: FOR_IN
6045: IFFALSE 6093
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6047: LD_VAR 0 2
6051: PPUSH
6052: LD_VAR 0 5
6056: PUSH
6057: LD_VAR 0 3
6061: PUSH
6062: LD_VAR 0 5
6066: MOD
6067: PUSH
6068: LD_INT 1
6070: PLUS
6071: ARRAY
6072: PPUSH
6073: CALL_OW 120
// i := i + 1 ;
6077: LD_ADDR_VAR 0 3
6081: PUSH
6082: LD_VAR 0 3
6086: PUSH
6087: LD_INT 1
6089: PLUS
6090: ST_TO_ADDR
// end ;
6091: GO 6044
6093: POP
6094: POP
// end ; end_of_file
6095: LD_VAR 0 1
6099: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_arabians ; var un , class_list , members ; begin
6100: LD_INT 0
6102: PPUSH
6103: PPUSH
6104: PPUSH
6105: PPUSH
// cpu_side := ar ;
6106: LD_ADDR_LOC 7
6110: PUSH
6111: LD_EXP 4
6115: ST_TO_ADDR
// cpu_nation := nation_arabian ;
6116: LD_ADDR_LOC 8
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// cpu_base := ar_create ;
6124: LD_ADDR_LOC 9
6128: PUSH
6129: LD_INT 19
6131: ST_TO_ADDR
// members := difficulty + 1 ;
6132: LD_ADDR_VAR 0 4
6136: PUSH
6137: LD_OWVAR 67
6141: PUSH
6142: LD_INT 1
6144: PLUS
6145: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
6146: LD_ADDR_VAR 0 3
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 3
6156: PUSH
6157: LD_INT 4
6159: PUSH
6160: LD_INT 2
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: ST_TO_ADDR
// for un in class_list do
6169: LD_ADDR_VAR 0 2
6173: PUSH
6174: LD_VAR 0 3
6178: PUSH
6179: FOR_IN
6180: IFFALSE 6213
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
6182: LD_LOC 7
6186: PPUSH
6187: LD_LOC 8
6191: PPUSH
6192: LD_VAR 0 2
6196: PPUSH
6197: LD_VAR 0 4
6201: PPUSH
6202: LD_LOC 9
6206: PPUSH
6207: CALL 6800 0 5
6211: GO 6179
6213: POP
6214: POP
// place_all_soldiers ;
6215: CALL 6232 0 0
// place_all_scientistics ;
6219: CALL 6440 0 0
// place_all_mechanics ;
6223: CALL 6629 0 0
// end ;
6227: LD_VAR 0 1
6231: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
6232: LD_INT 0
6234: PPUSH
6235: PPUSH
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
6240: LD_ADDR_VAR 0 6
6244: PUSH
6245: LD_INT 22
6247: PUSH
6248: LD_LOC 7
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: PUSH
6257: LD_INT 30
6259: PUSH
6260: LD_INT 32
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PPUSH
6271: CALL_OW 69
6275: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
6276: LD_ADDR_VAR 0 5
6280: PUSH
6281: LD_INT 22
6283: PUSH
6284: LD_LOC 7
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PUSH
6293: LD_INT 25
6295: PUSH
6296: LD_INT 1
6298: PUSH
6299: EMPTY
6300: LIST
6301: LIST
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PPUSH
6307: CALL_OW 69
6311: ST_TO_ADDR
// if buildings >= units then
6312: LD_VAR 0 6
6316: PUSH
6317: LD_VAR 0 5
6321: GREATEREQUAL
6322: IFFALSE 6340
// max := 0 + units else
6324: LD_ADDR_VAR 0 4
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_VAR 0 5
6336: PLUS
6337: ST_TO_ADDR
6338: GO 6354
// max := 0 + buildings ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_VAR 0 6
6352: PLUS
6353: ST_TO_ADDR
// i = 1 ;
6354: LD_ADDR_VAR 0 3
6358: PUSH
6359: LD_INT 1
6361: ST_TO_ADDR
// for un in units do
6362: LD_ADDR_VAR 0 2
6366: PUSH
6367: LD_VAR 0 5
6371: PUSH
6372: FOR_IN
6373: IFFALSE 6433
// begin if i <= max then
6375: LD_VAR 0 3
6379: PUSH
6380: LD_VAR 0 4
6384: LESSEQUAL
6385: IFFALSE 6417
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6387: LD_VAR 0 2
6391: PPUSH
6392: LD_VAR 0 6
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_VAR 0 6
6406: MOD
6407: PUSH
6408: LD_INT 1
6410: PLUS
6411: ARRAY
6412: PPUSH
6413: CALL_OW 120
// i := i + 1 ;
6417: LD_ADDR_VAR 0 3
6421: PUSH
6422: LD_VAR 0 3
6426: PUSH
6427: LD_INT 1
6429: PLUS
6430: ST_TO_ADDR
// end ;
6431: GO 6372
6433: POP
6434: POP
// end ;
6435: LD_VAR 0 1
6439: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6440: LD_INT 0
6442: PPUSH
6443: PPUSH
6444: PPUSH
6445: PPUSH
6446: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6447: LD_ADDR_VAR 0 5
6451: PUSH
6452: LD_INT 22
6454: PUSH
6455: LD_LOC 7
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 2
6466: PUSH
6467: LD_INT 30
6469: PUSH
6470: LD_INT 8
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 30
6479: PUSH
6480: LD_INT 6
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: PPUSH
6496: CALL_OW 69
6500: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6501: LD_ADDR_VAR 0 4
6505: PUSH
6506: LD_INT 22
6508: PUSH
6509: LD_LOC 7
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 25
6520: PUSH
6521: LD_INT 4
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PPUSH
6532: CALL_OW 69
6536: ST_TO_ADDR
// i = 1 ;
6537: LD_ADDR_VAR 0 3
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// for un in units do
6545: LD_ADDR_VAR 0 2
6549: PUSH
6550: LD_VAR 0 4
6554: PUSH
6555: FOR_IN
6556: IFFALSE 6622
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6558: LD_VAR 0 2
6562: PPUSH
6563: LD_VAR 0 5
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 5
6577: MOD
6578: PUSH
6579: LD_INT 1
6581: PLUS
6582: ARRAY
6583: PPUSH
6584: CALL_OW 120
// i := i + 1 ;
6588: LD_ADDR_VAR 0 3
6592: PUSH
6593: LD_VAR 0 3
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: ST_TO_ADDR
// if i > ( units div 2 ) then
6602: LD_VAR 0 3
6606: PUSH
6607: LD_VAR 0 4
6611: PUSH
6612: LD_INT 2
6614: DIV
6615: GREATER
6616: IFFALSE 6620
// break ;
6618: GO 6622
// end ;
6620: GO 6555
6622: POP
6623: POP
// end ;
6624: LD_VAR 0 1
6628: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6629: LD_INT 0
6631: PPUSH
6632: PPUSH
6633: PPUSH
6634: PPUSH
6635: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6636: LD_ADDR_VAR 0 5
6640: PUSH
6641: LD_INT 22
6643: PUSH
6644: LD_LOC 7
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 2
6655: PUSH
6656: LD_INT 30
6658: PUSH
6659: LD_INT 2
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: LD_INT 30
6668: PUSH
6669: LD_INT 3
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL_OW 69
6689: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6690: LD_ADDR_VAR 0 4
6694: PUSH
6695: LD_INT 22
6697: PUSH
6698: LD_LOC 7
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: LD_INT 25
6709: PUSH
6710: LD_INT 3
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PPUSH
6721: CALL_OW 69
6725: ST_TO_ADDR
// i = 1 ;
6726: LD_ADDR_VAR 0 3
6730: PUSH
6731: LD_INT 1
6733: ST_TO_ADDR
// for un in units do
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 4
6743: PUSH
6744: FOR_IN
6745: IFFALSE 6793
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6747: LD_VAR 0 2
6751: PPUSH
6752: LD_VAR 0 5
6756: PUSH
6757: LD_VAR 0 3
6761: PUSH
6762: LD_VAR 0 5
6766: MOD
6767: PUSH
6768: LD_INT 1
6770: PLUS
6771: ARRAY
6772: PPUSH
6773: CALL_OW 120
// i := i + 1 ;
6777: LD_ADDR_VAR 0 3
6781: PUSH
6782: LD_VAR 0 3
6786: PUSH
6787: LD_INT 1
6789: PLUS
6790: ST_TO_ADDR
// end ;
6791: GO 6744
6793: POP
6794: POP
// end ; end_of_file
6795: LD_VAR 0 1
6799: RET
// export function create_units ( side , nation , class_n , num , area ) ; var i , un , lev ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
6805: PPUSH
// if class_n = class_scientistic then
6806: LD_VAR 0 3
6810: PUSH
6811: LD_INT 4
6813: EQUAL
6814: IFFALSE 6868
// begin lev := [ 3 , 6 , 10 ] [ difficulty ] ;
6816: LD_ADDR_VAR 0 9
6820: PUSH
6821: LD_INT 3
6823: PUSH
6824: LD_INT 6
6826: PUSH
6827: LD_INT 10
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: PUSH
6835: LD_OWVAR 67
6839: ARRAY
6840: ST_TO_ADDR
// num := [ 2 , 4 , 6 ] [ difficulty ] ;
6841: LD_ADDR_VAR 0 4
6845: PUSH
6846: LD_INT 2
6848: PUSH
6849: LD_INT 4
6851: PUSH
6852: LD_INT 6
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: PUSH
6860: LD_OWVAR 67
6864: ARRAY
6865: ST_TO_ADDR
// end else
6866: GO 6938
// if class_n = class_soldier then
6868: LD_VAR 0 3
6872: PUSH
6873: LD_INT 1
6875: EQUAL
6876: IFFALSE 6913
// begin lev := [ 5 , 7 , 10 ] [ difficulty ] ;
6878: LD_ADDR_VAR 0 9
6882: PUSH
6883: LD_INT 5
6885: PUSH
6886: LD_INT 7
6888: PUSH
6889: LD_INT 10
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: PUSH
6897: LD_OWVAR 67
6901: ARRAY
6902: ST_TO_ADDR
// num := 6 ;
6903: LD_ADDR_VAR 0 4
6907: PUSH
6908: LD_INT 6
6910: ST_TO_ADDR
// end else
6911: GO 6938
// lev := [ 4 , 6 , 10 ] [ difficulty ] ;
6913: LD_ADDR_VAR 0 9
6917: PUSH
6918: LD_INT 4
6920: PUSH
6921: LD_INT 6
6923: PUSH
6924: LD_INT 10
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: PUSH
6932: LD_OWVAR 67
6936: ARRAY
6937: ST_TO_ADDR
// uc_side := side ;
6938: LD_ADDR_OWVAR 20
6942: PUSH
6943: LD_VAR 0 1
6947: ST_TO_ADDR
// uc_nation := nation ;
6948: LD_ADDR_OWVAR 21
6952: PUSH
6953: LD_VAR 0 2
6957: ST_TO_ADDR
// for i = 1 to num do
6958: LD_ADDR_VAR 0 7
6962: PUSH
6963: DOUBLE
6964: LD_INT 1
6966: DEC
6967: ST_TO_ADDR
6968: LD_VAR 0 4
6972: PUSH
6973: FOR_TO
6974: IFFALSE 7119
// begin uc_direction := Rand ( 0 , 5 ) ;
6976: LD_ADDR_OWVAR 24
6980: PUSH
6981: LD_INT 0
6983: PPUSH
6984: LD_INT 5
6986: PPUSH
6987: CALL_OW 12
6991: ST_TO_ADDR
// case class_n of 1 :
6992: LD_VAR 0 3
6996: PUSH
6997: LD_INT 1
6999: DOUBLE
7000: EQUAL
7001: IFTRUE 7005
7003: GO 7020
7005: POP
// PrepareSoldier ( 0 , lev ) ; 2 :
7006: LD_INT 0
7008: PPUSH
7009: LD_VAR 0 9
7013: PPUSH
7014: CALL_OW 381
7018: GO 7090
7020: LD_INT 2
7022: DOUBLE
7023: EQUAL
7024: IFTRUE 7028
7026: GO 7043
7028: POP
// PrepareEngineer ( 0 , lev ) ; 3 :
7029: LD_INT 0
7031: PPUSH
7032: LD_VAR 0 9
7036: PPUSH
7037: CALL_OW 382
7041: GO 7090
7043: LD_INT 3
7045: DOUBLE
7046: EQUAL
7047: IFTRUE 7051
7049: GO 7066
7051: POP
// PrepareMechanic ( 0 , lev ) ; 4 :
7052: LD_INT 0
7054: PPUSH
7055: LD_VAR 0 9
7059: PPUSH
7060: CALL_OW 383
7064: GO 7090
7066: LD_INT 4
7068: DOUBLE
7069: EQUAL
7070: IFTRUE 7074
7072: GO 7089
7074: POP
// PrepareScientist ( 0 , lev ) ; end ;
7075: LD_INT 0
7077: PPUSH
7078: LD_VAR 0 9
7082: PPUSH
7083: CALL_OW 384
7087: GO 7090
7089: POP
// un := CreateHuman ;
7090: LD_ADDR_VAR 0 8
7094: PUSH
7095: CALL_OW 44
7099: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7100: LD_VAR 0 8
7104: PPUSH
7105: LD_VAR 0 5
7109: PPUSH
7110: LD_INT 0
7112: PPUSH
7113: CALL_OW 49
// end ;
7117: GO 6973
7119: POP
7120: POP
// end ;
7121: LD_VAR 0 6
7125: RET
// export function prepare_apemans ; var ape , i ; begin
7126: LD_INT 0
7128: PPUSH
7129: PPUSH
7130: PPUSH
// for i = 1 to ( 6 - difficulty ) do
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: DOUBLE
7137: LD_INT 1
7139: DEC
7140: ST_TO_ADDR
7141: LD_INT 6
7143: PUSH
7144: LD_OWVAR 67
7148: MINUS
7149: PUSH
7150: FOR_TO
7151: IFFALSE 7351
// begin uc_side := neutral ;
7153: LD_ADDR_OWVAR 20
7157: PUSH
7158: LD_EXP 6
7162: ST_TO_ADDR
// uc_nation := nation_nature ;
7163: LD_ADDR_OWVAR 21
7167: PUSH
7168: LD_INT 0
7170: ST_TO_ADDR
// hc_class := class_apeman ;
7171: LD_ADDR_OWVAR 28
7175: PUSH
7176: LD_INT 12
7178: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) ] ;
7179: LD_ADDR_OWVAR 30
7183: PUSH
7184: LD_INT 1
7186: PPUSH
7187: LD_INT 2
7189: PPUSH
7190: CALL_OW 12
7194: PUSH
7195: LD_INT 1
7197: PPUSH
7198: LD_INT 2
7200: PPUSH
7201: CALL_OW 12
7205: PUSH
7206: LD_INT 1
7208: PPUSH
7209: LD_INT 2
7211: PPUSH
7212: CALL_OW 12
7216: PUSH
7217: LD_INT 1
7219: PPUSH
7220: LD_INT 2
7222: PPUSH
7223: CALL_OW 12
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: LIST
7232: LIST
7233: ST_TO_ADDR
// hc_skills := [ 3 , 3 , 3 , 3 ] ;
7234: LD_ADDR_OWVAR 31
7238: PUSH
7239: LD_INT 3
7241: PUSH
7242: LD_INT 3
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: LIST
7255: LIST
7256: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
7257: LD_ADDR_OWVAR 29
7261: PUSH
7262: LD_INT 10
7264: PUSH
7265: LD_INT 12
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: ST_TO_ADDR
// hc_sex := [ sex_female , sex_male ] [ Rand ( 1 , 2 ) ] ;
7272: LD_ADDR_OWVAR 27
7276: PUSH
7277: LD_INT 2
7279: PUSH
7280: LD_INT 1
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: PUSH
7287: LD_INT 1
7289: PPUSH
7290: LD_INT 2
7292: PPUSH
7293: CALL_OW 12
7297: ARRAY
7298: ST_TO_ADDR
// hc_importance := 0 ;
7299: LD_ADDR_OWVAR 32
7303: PUSH
7304: LD_INT 0
7306: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
7307: LD_ADDR_OWVAR 35
7311: PUSH
7312: LD_INT 20
7314: NEG
7315: PPUSH
7316: LD_INT 20
7318: PPUSH
7319: CALL_OW 12
7323: ST_TO_ADDR
// ape := CreateHuman ;
7324: LD_ADDR_VAR 0 2
7328: PUSH
7329: CALL_OW 44
7333: ST_TO_ADDR
// PlaceUnitArea ( ape , apeman_forest , false ) ;
7334: LD_VAR 0 2
7338: PPUSH
7339: LD_INT 32
7341: PPUSH
7342: LD_INT 0
7344: PPUSH
7345: CALL_OW 49
// end ;
7349: GO 7150
7351: POP
7352: POP
// end ; end_of_file
7353: LD_VAR 0 1
7357: RET
// var alien_tower_spoted ; export function starting_scene ; var check_time ; begin
7358: LD_INT 0
7360: PPUSH
7361: PPUSH
// CenterNowOnXY ( 75 , 27 ) ;
7362: LD_INT 75
7364: PPUSH
7365: LD_INT 27
7367: PPUSH
7368: CALL_OW 86
// wait ( 0 0$1 ) ;
7372: LD_INT 35
7374: PPUSH
7375: CALL_OW 67
// InGameOn ;
7379: CALL_OW 8
// ComMoveToArea ( IsInUnit ( Burlak ) , burlak_panorama_area ) ;
7383: LD_EXP 12
7387: PPUSH
7388: CALL_OW 310
7392: PPUSH
7393: LD_INT 8
7395: PPUSH
7396: CALL_OW 113
// ComMoveToArea ( IsInUnit ( MacMillan ) , jmm_panorama_area ) ;
7400: LD_EXP 13
7404: PPUSH
7405: CALL_OW 310
7409: PPUSH
7410: LD_INT 28
7412: PPUSH
7413: CALL_OW 113
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
7417: LD_EXP 13
7421: PUSH
7422: LD_EXP 12
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PPUSH
7431: CALL_OW 85
// repeat wait ( 20 ) ;
7435: LD_INT 20
7437: PPUSH
7438: CALL_OW 67
// until IsInArea ( Burlak , burlak_panorama_area ) and IsInArea ( MacMillan , jmm_panorama_area ) ;
7442: LD_EXP 12
7446: PPUSH
7447: LD_INT 8
7449: PPUSH
7450: CALL_OW 308
7454: PUSH
7455: LD_EXP 13
7459: PPUSH
7460: LD_INT 28
7462: PPUSH
7463: CALL_OW 308
7467: AND
7468: IFFALSE 7435
// ComExitVehicle ( [ Burlak , MacMillan ] ) ;
7470: LD_EXP 12
7474: PUSH
7475: LD_EXP 13
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PPUSH
7484: CALL_OW 121
// while IsInUnit ( Burlak ) or IsInUnit ( MacMillan ) do
7488: LD_EXP 12
7492: PPUSH
7493: CALL_OW 310
7497: PUSH
7498: LD_EXP 13
7502: PPUSH
7503: CALL_OW 310
7507: OR
7508: IFFALSE 7519
// wait ( 5 ) ;
7510: LD_INT 5
7512: PPUSH
7513: CALL_OW 67
7517: GO 7488
// wait ( 10 ) ;
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 67
// ComMoveToArea ( Burlak , burlak_talking_panorama ) ;
7526: LD_EXP 12
7530: PPUSH
7531: LD_INT 9
7533: PPUSH
7534: CALL_OW 113
// ComMoveToArea ( MacMillan , jmm_talking_panorama ) ;
7538: LD_EXP 13
7542: PPUSH
7543: LD_INT 29
7545: PPUSH
7546: CALL_OW 113
// check_time := TICK ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: LD_OWVAR 1
7559: ST_TO_ADDR
// repeat ComHold ( FilterUnitsInArea ( burlak_talking_panorama , [ [ f_side , you ] ] ) ) ;
7560: LD_INT 9
7562: PPUSH
7563: LD_INT 22
7565: PUSH
7566: LD_EXP 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: PPUSH
7578: CALL_OW 70
7582: PPUSH
7583: CALL_OW 140
// ComHold ( FilterUnitsInArea ( jmm_talking_panorama , [ [ f_side , you ] ] ) ) ;
7587: LD_INT 29
7589: PPUSH
7590: LD_INT 22
7592: PUSH
7593: LD_EXP 1
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: EMPTY
7603: LIST
7604: PPUSH
7605: CALL_OW 70
7609: PPUSH
7610: CALL_OW 140
// wait ( 0 0$1 ) ;
7614: LD_INT 35
7616: PPUSH
7617: CALL_OW 67
// until ( IsInArea ( Burlak , burlak_talking_panorama ) and IsInArea ( MacMillan , jmm_talking_panorama ) ) or ( check_time < ( TICK - 0 0$4 ) ) ;
7621: LD_EXP 12
7625: PPUSH
7626: LD_INT 9
7628: PPUSH
7629: CALL_OW 308
7633: PUSH
7634: LD_EXP 13
7638: PPUSH
7639: LD_INT 29
7641: PPUSH
7642: CALL_OW 308
7646: AND
7647: PUSH
7648: LD_VAR 0 2
7652: PUSH
7653: LD_OWVAR 1
7657: PUSH
7658: LD_INT 140
7660: MINUS
7661: LESS
7662: OR
7663: IFFALSE 7560
// ComTurnUnit ( MacMillan , Burlak ) ;
7665: LD_EXP 13
7669: PPUSH
7670: LD_EXP 12
7674: PPUSH
7675: CALL_OW 119
// ComTurnUnit ( Burlak , MacMillan ) ;
7679: LD_EXP 12
7683: PPUSH
7684: LD_EXP 13
7688: PPUSH
7689: CALL_OW 119
// CenterOnXY ( 77 , 31 ) ;
7693: LD_INT 77
7695: PPUSH
7696: LD_INT 31
7698: PPUSH
7699: CALL_OW 84
// wait ( 10 ) ;
7703: LD_INT 10
7705: PPUSH
7706: CALL_OW 67
// InGameOff ;
7710: CALL_OW 9
// DialogueOn ;
7714: CALL_OW 6
// interface_hidden := true ;
7718: LD_ADDR_OWVAR 54
7722: PUSH
7723: LD_INT 1
7725: ST_TO_ADDR
// case camp of 4 :
7726: LD_EXP 7
7730: PUSH
7731: LD_INT 4
7733: DOUBLE
7734: EQUAL
7735: IFTRUE 7739
7737: GO 7790
7739: POP
// begin Say ( MacMillan , DStart-JMM-JMM-1 ) ;
7740: LD_EXP 13
7744: PPUSH
7745: LD_STRING DStart-JMM-JMM-1
7747: PPUSH
7748: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
7752: LD_EXP 12
7756: PPUSH
7757: LD_STRING DStart-JMM-Bur-1
7759: PPUSH
7760: CALL_OW 88
// Say ( MacMillan , DStart-JMM-JMM-2 ) ;
7764: LD_EXP 13
7768: PPUSH
7769: LD_STRING DStart-JMM-JMM-2
7771: PPUSH
7772: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
7776: LD_EXP 12
7780: PPUSH
7781: LD_STRING DStart-JMM-Bur-2
7783: PPUSH
7784: CALL_OW 88
// end ; 6 :
7788: GO 7838
7790: LD_INT 6
7792: DOUBLE
7793: EQUAL
7794: IFTRUE 7798
7796: GO 7837
7798: POP
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
7799: LD_EXP 12
7803: PPUSH
7804: LD_STRING DStart-Burlak-Bur-1
7806: PPUSH
7807: CALL_OW 88
// Say ( Macmillan , DStart-Burlak-JMM-1 ) ;
7811: LD_EXP 13
7815: PPUSH
7816: LD_STRING DStart-Burlak-JMM-1
7818: PPUSH
7819: CALL_OW 88
// Say ( Burlak , DStart-Burlak-Bur-2 ) ;
7823: LD_EXP 12
7827: PPUSH
7828: LD_STRING DStart-Burlak-Bur-2
7830: PPUSH
7831: CALL_OW 88
// end ; end ;
7835: GO 7838
7837: POP
// SaveForQuickRestart ;
7838: CALL_OW 22
// wait ( 20 ) ;
7842: LD_INT 20
7844: PPUSH
7845: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
7849: LD_STRING MStart
7851: PPUSH
7852: CALL_OW 337
// interface_hidden := false ;
7856: LD_ADDR_OWVAR 54
7860: PUSH
7861: LD_INT 0
7863: ST_TO_ADDR
// DialogueOff ;
7864: CALL_OW 7
// us_researched := false ;
7868: LD_ADDR_EXP 61
7872: PUSH
7873: LD_INT 0
7875: ST_TO_ADDR
// us_researched := true ;
7876: LD_ADDR_EXP 61
7880: PUSH
7881: LD_INT 1
7883: ST_TO_ADDR
// omar_in_contact := false ;
7884: LD_ADDR_EXP 64
7888: PUSH
7889: LD_INT 0
7891: ST_TO_ADDR
// alien_tower_spoted := false ;
7892: LD_ADDR_LOC 10
7896: PUSH
7897: LD_INT 0
7899: ST_TO_ADDR
// one_enabled := false ;
7900: LD_ADDR_EXP 63
7904: PUSH
7905: LD_INT 0
7907: ST_TO_ADDR
// end ;
7908: LD_VAR 0 1
7912: RET
// every 0 0$2.3 trigger See ( you , al_tower ) do var un , sol , sci ;
7913: LD_EXP 1
7917: PPUSH
7918: LD_INT 108
7920: PPUSH
7921: CALL_OW 292
7925: IFFALSE 8431
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
// begin repeat wait ( 0 0$1 ) ;
7935: LD_INT 35
7937: PPUSH
7938: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] , f_not , [ f_inside ] ] ) ;
7942: LD_INT 22
7944: PUSH
7945: LD_EXP 4
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: LD_INT 21
7956: PUSH
7957: LD_INT 1
7959: PUSH
7960: EMPTY
7961: LIST
7962: LIST
7963: PUSH
7964: LD_INT 50
7966: PUSH
7967: EMPTY
7968: LIST
7969: PUSH
7970: LD_INT 3
7972: PUSH
7973: LD_INT 54
7975: PUSH
7976: EMPTY
7977: LIST
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: LIST
7983: LIST
7984: LIST
7985: PPUSH
7986: CALL_OW 69
7990: NOT
7991: IFFALSE 7935
// wait ( 0 0$1 ) ;
7993: LD_INT 35
7995: PPUSH
7996: CALL_OW 67
// cpu_list := cpu_list diff ar ;
8000: LD_ADDR_EXP 8
8004: PUSH
8005: LD_EXP 8
8009: PUSH
8010: LD_EXP 4
8014: DIFF
8015: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8016: LD_ADDR_VAR 0 1
8020: PUSH
8021: LD_INT 22
8023: PUSH
8024: LD_EXP 1
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 26
8035: PUSH
8036: LD_INT 1
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: PUSH
8052: LD_EXP 13
8056: PUSH
8057: LD_EXP 12
8061: PUSH
8062: LD_EXP 14
8066: PUSH
8067: LD_EXP 15
8071: PUSH
8072: LD_INT 0
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: LIST
8081: DIFF
8082: ST_TO_ADDR
// if un then
8083: LD_VAR 0 1
8087: IFFALSE 8107
// sol := FindMaxSkill ( un , skill_combat ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 1
8098: PPUSH
8099: LD_INT 1
8101: PPUSH
8102: CALL_OW 433
8106: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , sol , 0 ] ;
8107: LD_ADDR_VAR 0 1
8111: PUSH
8112: LD_INT 22
8114: PUSH
8115: LD_EXP 1
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 26
8126: PUSH
8127: LD_INT 1
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: PUSH
8143: LD_EXP 13
8147: PUSH
8148: LD_EXP 12
8152: PUSH
8153: LD_EXP 14
8157: PUSH
8158: LD_EXP 15
8162: PUSH
8163: LD_VAR 0 2
8167: PUSH
8168: LD_INT 0
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: LIST
8178: DIFF
8179: ST_TO_ADDR
// if un then
8180: LD_VAR 0 1
8184: IFFALSE 8204
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8186: LD_ADDR_VAR 0 3
8190: PUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: LD_INT 4
8198: PPUSH
8199: CALL_OW 433
8203: ST_TO_ADDR
// PlaceSeeing ( 248 , 183 , you , 10 ) ;
8204: LD_INT 248
8206: PPUSH
8207: LD_INT 183
8209: PPUSH
8210: LD_EXP 1
8214: PPUSH
8215: LD_INT 10
8217: PPUSH
8218: CALL_OW 330
// CenterOnUnits ( al_tower ) ;
8222: LD_INT 108
8224: PPUSH
8225: CALL_OW 85
// DialogueOn ;
8229: CALL_OW 6
// interface_hidden := true ;
8233: LD_ADDR_OWVAR 54
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// Say ( sol , DAlienBase-Rsol1-1 ) ;
8241: LD_VAR 0 2
8245: PPUSH
8246: LD_STRING DAlienBase-Rsol1-1
8248: PPUSH
8249: CALL_OW 88
// case camp of 4 :
8253: LD_EXP 7
8257: PUSH
8258: LD_INT 4
8260: DOUBLE
8261: EQUAL
8262: IFTRUE 8266
8264: GO 8317
8266: POP
// begin Say ( MacMillan , DAlienBase-JMM-1 ) ;
8267: LD_EXP 13
8271: PPUSH
8272: LD_STRING DAlienBase-JMM-1
8274: PPUSH
8275: CALL_OW 88
// Say ( Roth , DAlienBase-Roth-1 ) ;
8279: LD_EXP 14
8283: PPUSH
8284: LD_STRING DAlienBase-Roth-1
8286: PPUSH
8287: CALL_OW 88
// if not IsOK ( Roth ) then
8291: LD_EXP 14
8295: PPUSH
8296: CALL_OW 302
8300: NOT
8301: IFFALSE 8315
// Say ( sci , DAlienBase-Sci1-1 ) ;
8303: LD_VAR 0 3
8307: PPUSH
8308: LD_STRING DAlienBase-Sci1-1
8310: PPUSH
8311: CALL_OW 88
// end ; 6 :
8315: GO 8377
8317: LD_INT 6
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8376
8325: POP
// begin Say ( Burlak , DAlienBase-Bur-1 ) ;
8326: LD_EXP 12
8330: PPUSH
8331: LD_STRING DAlienBase-Bur-1
8333: PPUSH
8334: CALL_OW 88
// Say ( Gossudarov , DAlienBase-Gos-1 ) ;
8338: LD_EXP 15
8342: PPUSH
8343: LD_STRING DAlienBase-Gos-1
8345: PPUSH
8346: CALL_OW 88
// if not IsOK ( Gossudarov ) then
8350: LD_EXP 15
8354: PPUSH
8355: CALL_OW 302
8359: NOT
8360: IFFALSE 8374
// Say ( sci , DAlienBase-Sci1-1 ) ;
8362: LD_VAR 0 3
8366: PPUSH
8367: LD_STRING DAlienBase-Sci1-1
8369: PPUSH
8370: CALL_OW 88
// end ; end ;
8374: GO 8377
8376: POP
// SetSide ( al_tower , you ) ;
8377: LD_INT 108
8379: PPUSH
8380: LD_EXP 1
8384: PPUSH
8385: CALL_OW 235
// RemoveSeeing ( 248 , 183 , you ) ;
8389: LD_INT 248
8391: PPUSH
8392: LD_INT 183
8394: PPUSH
8395: LD_EXP 1
8399: PPUSH
8400: CALL_OW 331
// interface_hidden := false ;
8404: LD_ADDR_OWVAR 54
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// DialogueOff ;
8412: CALL_OW 7
// Hint ( ArtefactBuilding ) ;
8416: LD_STRING ArtefactBuilding
8418: PPUSH
8419: CALL_OW 339
// alien_tower_spoted := true ;
8423: LD_ADDR_LOC 10
8427: PUSH
8428: LD_INT 1
8430: ST_TO_ADDR
// end ;
8431: PPOPN 3
8433: END
// every 0 0$4.6 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] , [ f_lives , 1000 ] ] ) and alien_tower_spoted do var un , sci ;
8434: LD_INT 22
8436: PUSH
8437: LD_EXP 1
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: LD_INT 2
8448: PUSH
8449: LD_INT 30
8451: PUSH
8452: LD_INT 6
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PUSH
8459: LD_INT 30
8461: PUSH
8462: LD_INT 7
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: LIST
8473: PUSH
8474: LD_INT 24
8476: PUSH
8477: LD_INT 1000
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: PUSH
8494: LD_LOC 10
8498: AND
8499: IFFALSE 8767
8501: GO 8503
8503: DISABLE
8504: LD_INT 0
8506: PPUSH
8507: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_EXP 1
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 26
8527: PUSH
8528: LD_INT 1
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PPUSH
8539: CALL_OW 69
8543: PUSH
8544: LD_EXP 13
8548: PUSH
8549: LD_EXP 12
8553: PUSH
8554: LD_EXP 14
8558: PUSH
8559: LD_EXP 15
8563: PUSH
8564: LD_INT 0
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: LIST
8573: DIFF
8574: ST_TO_ADDR
// if un then
8575: LD_VAR 0 1
8579: IFFALSE 8599
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_VAR 0 1
8590: PPUSH
8591: LD_INT 4
8593: PPUSH
8594: CALL_OW 433
8598: ST_TO_ADDR
// CenterOnUnits ( al_tower ) ;
8599: LD_INT 108
8601: PPUSH
8602: CALL_OW 85
// DialogueOn ;
8606: CALL_OW 6
// interface_hidden := true ;
8610: LD_ADDR_OWVAR 54
8614: PUSH
8615: LD_INT 1
8617: ST_TO_ADDR
// case camp of 4 :
8618: LD_EXP 7
8622: PUSH
8623: LD_INT 4
8625: DOUBLE
8626: EQUAL
8627: IFTRUE 8631
8629: GO 8671
8631: POP
// if IsOK ( Gossudarov ) then
8632: LD_EXP 15
8636: PPUSH
8637: CALL_OW 302
8641: IFFALSE 8657
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
8643: LD_EXP 15
8647: PPUSH
8648: LD_STRING DAlieBaseNotReady-Gos-1
8650: PPUSH
8651: CALL_OW 88
8655: GO 8669
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) ; 6 :
8657: LD_EXP 14
8661: PPUSH
8662: LD_STRING DAlieBaseNotReady-Roth-1
8664: PPUSH
8665: CALL_OW 88
8669: GO 8720
8671: LD_INT 6
8673: DOUBLE
8674: EQUAL
8675: IFTRUE 8679
8677: GO 8719
8679: POP
// if IsOK ( Roth ) then
8680: LD_EXP 14
8684: PPUSH
8685: CALL_OW 302
8689: IFFALSE 8705
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
8691: LD_EXP 14
8695: PPUSH
8696: LD_STRING DAlieBaseNotReady-Roth-1
8698: PPUSH
8699: CALL_OW 88
8703: GO 8717
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) ; end ;
8705: LD_EXP 15
8709: PPUSH
8710: LD_STRING DAlieBaseNotReady-Gos-1
8712: PPUSH
8713: CALL_OW 88
8717: GO 8720
8719: POP
// if not ( IsOK ( Gossudarov ) or IsOK ( Roth ) ) then
8720: LD_EXP 15
8724: PPUSH
8725: CALL_OW 302
8729: PUSH
8730: LD_EXP 14
8734: PPUSH
8735: CALL_OW 302
8739: OR
8740: NOT
8741: IFFALSE 8755
// Say ( sci , DAlieBaseNotReady-RSci1-1 ) ;
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_STRING DAlieBaseNotReady-RSci1-1
8750: PPUSH
8751: CALL_OW 88
// interface_hidden := false ;
8755: LD_ADDR_OWVAR 54
8759: PUSH
8760: LD_INT 0
8762: ST_TO_ADDR
// DialogueOff ;
8763: CALL_OW 7
// end ;
8767: PPOPN 2
8769: END
// every 0 0$8.7 trigger GetTech ( tech_Artifact , you ) = state_researched do var un , lab , list ;
8770: LD_INT 24
8772: PPUSH
8773: LD_EXP 1
8777: PPUSH
8778: CALL_OW 321
8782: PUSH
8783: LD_INT 2
8785: EQUAL
8786: IFFALSE 8924
8788: GO 8790
8790: DISABLE
8791: LD_INT 0
8793: PPUSH
8794: PPUSH
8795: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
8796: LD_ADDR_VAR 0 3
8800: PUSH
8801: LD_INT 22
8803: PUSH
8804: LD_EXP 1
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 2
8815: PUSH
8816: LD_INT 30
8818: PUSH
8819: LD_INT 6
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: LD_INT 30
8828: PUSH
8829: LD_INT 7
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 30
8838: PUSH
8839: LD_INT 8
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: PPUSH
8856: CALL_OW 69
8860: ST_TO_ADDR
// lab := false ;
8861: LD_ADDR_VAR 0 2
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// for un in list do
8869: LD_ADDR_VAR 0 1
8873: PUSH
8874: LD_VAR 0 3
8878: PUSH
8879: FOR_IN
8880: IFFALSE 8909
// if GetLives ( un ) = 1000 then
8882: LD_VAR 0 1
8886: PPUSH
8887: CALL_OW 256
8891: PUSH
8892: LD_INT 1000
8894: EQUAL
8895: IFFALSE 8907
// lab := un ;
8897: LD_ADDR_VAR 0 2
8901: PUSH
8902: LD_VAR 0 1
8906: ST_TO_ADDR
8907: GO 8879
8909: POP
8910: POP
// if lab then
8911: LD_VAR 0 2
8915: IFFALSE 8923
// begin Talking_About_Artefact ;
8917: CALL 8927 0 0
// exit ;
8921: GO 8924
// end ; enable ;
8923: ENABLE
// end ;
8924: PPOPN 3
8926: END
// export function Talking_About_Artefact ; var un , ru_sci , us_sci , your_depot ; begin
8927: LD_INT 0
8929: PPUSH
8930: PPUSH
8931: PPUSH
8932: PPUSH
8933: PPUSH
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_INT 22
8941: PUSH
8942: LD_EXP 1
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: LD_INT 23
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 26
8963: PUSH
8964: LD_INT 1
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: LIST
8975: PPUSH
8976: CALL_OW 69
8980: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8981: LD_ADDR_VAR 0 2
8985: PUSH
8986: LD_VAR 0 2
8990: PUSH
8991: LD_EXP 13
8995: PUSH
8996: LD_EXP 12
9000: PUSH
9001: LD_EXP 14
9005: PUSH
9006: LD_EXP 15
9010: PUSH
9011: LD_INT 0
9013: PUSH
9014: EMPTY
9015: LIST
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: DIFF
9021: ST_TO_ADDR
// if un then
9022: LD_VAR 0 2
9026: IFFALSE 9046
// ru_sci := FindMaxSkill ( un , skill_scientistic ) ;
9028: LD_ADDR_VAR 0 3
9032: PUSH
9033: LD_VAR 0 2
9037: PPUSH
9038: LD_INT 4
9040: PPUSH
9041: CALL_OW 433
9045: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9046: LD_ADDR_VAR 0 2
9050: PUSH
9051: LD_INT 22
9053: PUSH
9054: LD_EXP 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: LD_INT 23
9065: PUSH
9066: LD_INT 1
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: PUSH
9073: LD_INT 26
9075: PUSH
9076: LD_INT 1
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9093: LD_ADDR_VAR 0 2
9097: PUSH
9098: LD_VAR 0 2
9102: PUSH
9103: LD_EXP 13
9107: PUSH
9108: LD_EXP 12
9112: PUSH
9113: LD_EXP 14
9117: PUSH
9118: LD_EXP 15
9122: PUSH
9123: LD_INT 0
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: LIST
9130: LIST
9131: LIST
9132: DIFF
9133: ST_TO_ADDR
// if un then
9134: LD_VAR 0 2
9138: IFFALSE 9158
// us_sci := FindMaxSkill ( un , skill_scientistic ) ;
9140: LD_ADDR_VAR 0 4
9144: PUSH
9145: LD_VAR 0 2
9149: PPUSH
9150: LD_INT 4
9152: PPUSH
9153: CALL_OW 433
9157: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_INT 22
9165: PUSH
9166: LD_EXP 1
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: LD_INT 30
9180: PUSH
9181: LD_INT 0
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PUSH
9188: LD_INT 30
9190: PUSH
9191: LD_INT 1
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: LIST
9202: PUSH
9203: EMPTY
9204: LIST
9205: LIST
9206: PPUSH
9207: CALL_OW 69
9211: ST_TO_ADDR
// if un then
9212: LD_VAR 0 2
9216: IFFALSE 9232
// your_depot := un [ 1 ] ;
9218: LD_ADDR_VAR 0 5
9222: PUSH
9223: LD_VAR 0 2
9227: PUSH
9228: LD_INT 1
9230: ARRAY
9231: ST_TO_ADDR
// CenterOnUnits ( Burlak ) ;
9232: LD_EXP 12
9236: PPUSH
9237: CALL_OW 85
// DialogueOn ;
9241: CALL_OW 6
// interface_hidden := true ;
9245: LD_ADDR_OWVAR 54
9249: PUSH
9250: LD_INT 1
9252: ST_TO_ADDR
// Say ( ru_sci , DArtefTechnology-RSci1-1 ) ;
9253: LD_VAR 0 3
9257: PPUSH
9258: LD_STRING DArtefTechnology-RSci1-1
9260: PPUSH
9261: CALL_OW 88
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
9265: LD_EXP 12
9269: PPUSH
9270: LD_STRING DArtefTechnology-Bur-1
9272: PPUSH
9273: CALL_OW 88
// Say ( ru_sci , DArtefTechnology-RSci1-2 ) ;
9277: LD_VAR 0 3
9281: PPUSH
9282: LD_STRING DArtefTechnology-RSci1-2
9284: PPUSH
9285: CALL_OW 88
// Say ( us_sci , DArtefTechnology-Sci1-2 ) ;
9289: LD_VAR 0 4
9293: PPUSH
9294: LD_STRING DArtefTechnology-Sci1-2
9296: PPUSH
9297: CALL_OW 88
// case camp of 4 :
9301: LD_EXP 7
9305: PUSH
9306: LD_INT 4
9308: DOUBLE
9309: EQUAL
9310: IFTRUE 9314
9312: GO 9329
9314: POP
// Say ( MacMillan , DArtefTechnology-JMM-2 ) ; 6 :
9315: LD_EXP 13
9319: PPUSH
9320: LD_STRING DArtefTechnology-JMM-2
9322: PPUSH
9323: CALL_OW 88
9327: GO 9353
9329: LD_INT 6
9331: DOUBLE
9332: EQUAL
9333: IFTRUE 9337
9335: GO 9352
9337: POP
// Say ( Burlak , DArtefTechnology-Bur-2 ) ; end ;
9338: LD_EXP 12
9342: PPUSH
9343: LD_STRING DArtefTechnology-Bur-2
9345: PPUSH
9346: CALL_OW 88
9350: GO 9353
9352: POP
// Say ( ru_sci , DArtefTechnology-RSci1-3 ) ;
9353: LD_VAR 0 3
9357: PPUSH
9358: LD_STRING DArtefTechnology-RSci1-3
9360: PPUSH
9361: CALL_OW 88
// if GetDistUnits ( your_depot , al_tower ) < 30 then
9365: LD_VAR 0 5
9369: PPUSH
9370: LD_INT 108
9372: PPUSH
9373: CALL_OW 296
9377: PUSH
9378: LD_INT 30
9380: LESS
9381: IFFALSE 9397
// Say ( us_sci , DArtefTechnology-Sci1-3 ) else
9383: LD_VAR 0 4
9387: PPUSH
9388: LD_STRING DArtefTechnology-Sci1-3
9390: PPUSH
9391: CALL_OW 88
9395: GO 9409
// Say ( us_sci , DArtefTechnology-Sci1-3a ) ;
9397: LD_VAR 0 4
9401: PPUSH
9402: LD_STRING DArtefTechnology-Sci1-3a
9404: PPUSH
9405: CALL_OW 88
// interface_hidden := false ;
9409: LD_ADDR_OWVAR 54
9413: PUSH
9414: LD_INT 0
9416: ST_TO_ADDR
// DialogueOff ;
9417: CALL_OW 7
// end ; end_of_file
9421: LD_VAR 0 1
9425: RET
// export us_researched , ru_researched ; export one_enabled ; every 0 0$1.1 do var un , sci ;
9426: GO 9428
9428: DISABLE
9429: LD_INT 0
9431: PPUSH
9432: PPUSH
// begin exit ;
9433: GO 9679
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9435: LD_ADDR_VAR 0 1
9439: PUSH
9440: LD_INT 22
9442: PUSH
9443: LD_EXP 1
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 23
9454: PUSH
9455: LD_INT 1
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PUSH
9462: LD_INT 26
9464: PUSH
9465: LD_INT 1
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PUSH
9472: EMPTY
9473: LIST
9474: LIST
9475: LIST
9476: PPUSH
9477: CALL_OW 69
9481: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9482: LD_ADDR_VAR 0 1
9486: PUSH
9487: LD_VAR 0 1
9491: PUSH
9492: LD_EXP 13
9496: PUSH
9497: LD_EXP 12
9501: PUSH
9502: LD_EXP 14
9506: PUSH
9507: LD_EXP 15
9511: PUSH
9512: LD_INT 0
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: DIFF
9522: ST_TO_ADDR
// if un then
9523: LD_VAR 0 1
9527: IFFALSE 9547
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9529: LD_ADDR_VAR 0 2
9533: PUSH
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_INT 4
9541: PPUSH
9542: CALL_OW 433
9546: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
9547: LD_EXP 13
9551: PUSH
9552: LD_EXP 12
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 85
// DialogueOn ;
9565: CALL_OW 6
// interface_hidden := true ;
9569: LD_ADDR_OWVAR 54
9573: PUSH
9574: LD_INT 1
9576: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAm-Sci1-1 ) ;
9577: LD_VAR 0 2
9581: PPUSH
9582: LD_STRING DArtefTechnologyAm-Sci1-1
9584: PPUSH
9585: CALL_OW 88
// case camp of 4 :
9589: LD_EXP 7
9593: PUSH
9594: LD_INT 4
9596: DOUBLE
9597: EQUAL
9598: IFTRUE 9602
9600: GO 9617
9602: POP
// Say ( MacMillan , DArtefTechnologyAm-JMM-1 ) ; 6 :
9603: LD_EXP 13
9607: PPUSH
9608: LD_STRING DArtefTechnologyAm-JMM-1
9610: PPUSH
9611: CALL_OW 88
9615: GO 9641
9617: LD_INT 6
9619: DOUBLE
9620: EQUAL
9621: IFTRUE 9625
9623: GO 9640
9625: POP
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ; end ;
9626: LD_EXP 12
9630: PPUSH
9631: LD_STRING DArtefTechnologyAm-Bur-1
9633: PPUSH
9634: CALL_OW 88
9638: GO 9641
9640: POP
// interface_hidden := false ;
9641: LD_ADDR_OWVAR 54
9645: PUSH
9646: LD_INT 0
9648: ST_TO_ADDR
// DialogueOff ;
9649: CALL_OW 7
// if not one_enabled then
9653: LD_EXP 63
9657: NOT
9658: IFFALSE 9671
// begin enable ( 1 ) ;
9660: LD_INT 1
9662: ENABLE_MARKED
// one_enabled := true ;
9663: LD_ADDR_EXP 63
9667: PUSH
9668: LD_INT 1
9670: ST_TO_ADDR
// end ; us_researched := true ;
9671: LD_ADDR_EXP 61
9675: PUSH
9676: LD_INT 1
9678: ST_TO_ADDR
// end ;
9679: PPOPN 2
9681: END
// every 0 0$1.3 do var un , sci ;
9682: GO 9684
9684: DISABLE
9685: LD_INT 0
9687: PPUSH
9688: PPUSH
// begin exit ;
9689: GO 9947
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9691: LD_ADDR_VAR 0 1
9695: PUSH
9696: LD_INT 22
9698: PUSH
9699: LD_EXP 1
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: PUSH
9708: LD_INT 23
9710: PUSH
9711: LD_INT 3
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 26
9720: PUSH
9721: LD_INT 1
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: LIST
9732: PPUSH
9733: CALL_OW 69
9737: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9738: LD_ADDR_VAR 0 1
9742: PUSH
9743: LD_VAR 0 1
9747: PUSH
9748: LD_EXP 13
9752: PUSH
9753: LD_EXP 12
9757: PUSH
9758: LD_EXP 14
9762: PUSH
9763: LD_EXP 15
9767: PUSH
9768: LD_INT 0
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: LIST
9777: DIFF
9778: ST_TO_ADDR
// if un then
9779: LD_VAR 0 1
9783: IFFALSE 9803
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9785: LD_ADDR_VAR 0 2
9789: PUSH
9790: LD_VAR 0 1
9794: PPUSH
9795: LD_INT 4
9797: PPUSH
9798: CALL_OW 433
9802: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , sci ] ) ;
9803: LD_EXP 13
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PPUSH
9817: CALL_OW 85
// DialogueOn ;
9821: CALL_OW 6
// interface_hidden := true ;
9825: LD_ADDR_OWVAR 54
9829: PUSH
9830: LD_INT 1
9832: ST_TO_ADDR
// Say ( sci , DArtefTechnologyRu-RSci1-1 ) ;
9833: LD_VAR 0 2
9837: PPUSH
9838: LD_STRING DArtefTechnologyRu-RSci1-1
9840: PPUSH
9841: CALL_OW 88
// case camp of 4 :
9845: LD_EXP 7
9849: PUSH
9850: LD_INT 4
9852: DOUBLE
9853: EQUAL
9854: IFTRUE 9858
9856: GO 9873
9858: POP
// Say ( MacMillan , DArtefTechnologyRu-JMM-1 ) ; 6 :
9859: LD_EXP 13
9863: PPUSH
9864: LD_STRING DArtefTechnologyRu-JMM-1
9866: PPUSH
9867: CALL_OW 88
9871: GO 9897
9873: LD_INT 6
9875: DOUBLE
9876: EQUAL
9877: IFTRUE 9881
9879: GO 9896
9881: POP
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ; end ;
9882: LD_EXP 12
9886: PPUSH
9887: LD_STRING DArtefTechnologyRu-Bur-1
9889: PPUSH
9890: CALL_OW 88
9894: GO 9897
9896: POP
// Say ( sci , DArtefTechnologyRu-RSci1-2 ) ;
9897: LD_VAR 0 2
9901: PPUSH
9902: LD_STRING DArtefTechnologyRu-RSci1-2
9904: PPUSH
9905: CALL_OW 88
// interface_hidden := false ;
9909: LD_ADDR_OWVAR 54
9913: PUSH
9914: LD_INT 0
9916: ST_TO_ADDR
// DialogueOff ;
9917: CALL_OW 7
// if not one_enabled then
9921: LD_EXP 63
9925: NOT
9926: IFFALSE 9939
// begin enable ( 1 ) ;
9928: LD_INT 1
9930: ENABLE_MARKED
// one_enabled := true ;
9931: LD_ADDR_EXP 63
9935: PUSH
9936: LD_INT 1
9938: ST_TO_ADDR
// end ; ru_researched := true ;
9939: LD_ADDR_EXP 62
9943: PUSH
9944: LD_INT 1
9946: ST_TO_ADDR
// end ;
9947: PPOPN 2
9949: END
// every 0 0$5.3 trigger ( GetSide ( al_tower ) = you ) and ( GetTag ( 81 ) or GetTag ( 181 ) ) marked 1 do var un , sci ;
9950: LD_INT 108
9952: PPUSH
9953: CALL_OW 255
9957: PUSH
9958: LD_EXP 1
9962: EQUAL
9963: PUSH
9964: LD_INT 81
9966: PPUSH
9967: CALL_OW 110
9971: PUSH
9972: LD_INT 181
9974: PPUSH
9975: CALL_OW 110
9979: OR
9980: AND
9981: IFFALSE 10225
9983: GO 9985
9985: DISABLE
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
// begin un := [ ] ;
9990: LD_ADDR_VAR 0 1
9994: PUSH
9995: EMPTY
9996: ST_TO_ADDR
// if us_researched then
9997: LD_EXP 61
10001: IFFALSE 10056
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
10003: LD_ADDR_VAR 0 1
10007: PUSH
10008: LD_VAR 0 1
10012: PUSH
10013: LD_INT 22
10015: PUSH
10016: LD_EXP 1
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PUSH
10025: LD_INT 23
10027: PUSH
10028: LD_INT 1
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 26
10037: PUSH
10038: LD_INT 1
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: LIST
10049: PPUSH
10050: CALL_OW 69
10054: ADD
10055: ST_TO_ADDR
// if ru_researched then
10056: LD_EXP 62
10060: IFFALSE 10115
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10062: LD_ADDR_VAR 0 1
10066: PUSH
10067: LD_VAR 0 1
10071: PUSH
10072: LD_INT 22
10074: PUSH
10075: LD_EXP 1
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 1
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: ADD
10114: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 1
10124: PUSH
10125: LD_EXP 13
10129: PUSH
10130: LD_EXP 12
10134: PUSH
10135: LD_EXP 14
10139: PUSH
10140: LD_EXP 15
10144: PUSH
10145: LD_INT 0
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: DIFF
10155: ST_TO_ADDR
// if un then
10156: LD_VAR 0 1
10160: IFFALSE 10180
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10162: LD_ADDR_VAR 0 2
10166: PUSH
10167: LD_VAR 0 1
10171: PPUSH
10172: LD_INT 4
10174: PPUSH
10175: CALL_OW 433
10179: ST_TO_ADDR
// CenterOnUnits ( sci ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: CALL_OW 85
// DialogueOn ;
10189: CALL_OW 6
// interface_hidden := true ;
10193: LD_ADDR_OWVAR 54
10197: PUSH
10198: LD_INT 1
10200: ST_TO_ADDR
// Say ( sci , DArtefTechnologyArStart-Sci1-1 ) ;
10201: LD_VAR 0 2
10205: PPUSH
10206: LD_STRING DArtefTechnologyArStart-Sci1-1
10208: PPUSH
10209: CALL_OW 88
// interface_hidden := false ;
10213: LD_ADDR_OWVAR 54
10217: PUSH
10218: LD_INT 0
10220: ST_TO_ADDR
// DialogueOff ;
10221: CALL_OW 7
// end ;
10225: PPOPN 2
10227: END
// every 0 0$3.9 trigger GetTag ( 281 ) do var un , sci ;
10228: LD_INT 281
10230: PPUSH
10231: CALL_OW 110
10235: IFFALSE 10596
10237: GO 10239
10239: DISABLE
10240: LD_INT 0
10242: PPUSH
10243: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10244: LD_ADDR_VAR 0 1
10248: PUSH
10249: LD_INT 22
10251: PUSH
10252: LD_EXP 1
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 23
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 26
10273: PUSH
10274: LD_INT 1
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10291: LD_ADDR_VAR 0 1
10295: PUSH
10296: LD_VAR 0 1
10300: PUSH
10301: LD_EXP 13
10305: PUSH
10306: LD_EXP 12
10310: PUSH
10311: LD_EXP 14
10315: PUSH
10316: LD_EXP 15
10320: PUSH
10321: LD_INT 0
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: DIFF
10331: ST_TO_ADDR
// if un then
10332: LD_VAR 0 1
10336: IFFALSE 10358
// sci := FindMaxSkill ( un , skill_scientistic ) else
10338: LD_ADDR_VAR 0 2
10342: PUSH
10343: LD_VAR 0 1
10347: PPUSH
10348: LD_INT 4
10350: PPUSH
10351: CALL_OW 433
10355: ST_TO_ADDR
10356: GO 10360
// exit ;
10358: GO 10596
// CenterOnUnits ( [ MacMillan , Burlak , sci ] ) ;
10360: LD_EXP 13
10364: PUSH
10365: LD_EXP 12
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 85
// DialogueOn ;
10384: CALL_OW 6
// interface_hidden := true ;
10388: LD_ADDR_OWVAR 54
10392: PUSH
10393: LD_INT 1
10395: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAr-RSci1-1 ) ;
10396: LD_VAR 0 2
10400: PPUSH
10401: LD_STRING DArtefTechnologyAr-RSci1-1
10403: PPUSH
10404: CALL_OW 88
// case camp of 4 :
10408: LD_EXP 7
10412: PUSH
10413: LD_INT 4
10415: DOUBLE
10416: EQUAL
10417: IFTRUE 10421
10419: GO 10436
10421: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-1 ) ; 6 :
10422: LD_EXP 13
10426: PPUSH
10427: LD_STRING DArtefTechnologyAr-JMM-1
10429: PPUSH
10430: CALL_OW 88
10434: GO 10460
10436: LD_INT 6
10438: DOUBLE
10439: EQUAL
10440: IFTRUE 10444
10442: GO 10459
10444: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-1 ) ; end ;
10445: LD_EXP 12
10449: PPUSH
10450: LD_STRING DArtefTechnologyAr-Bur-1
10452: PPUSH
10453: CALL_OW 88
10457: GO 10460
10459: POP
// Say ( sci , DArtefTechnologyAr-RSci1-2 ) ;
10460: LD_VAR 0 2
10464: PPUSH
10465: LD_STRING DArtefTechnologyAr-RSci1-2
10467: PPUSH
10468: CALL_OW 88
// case camp of 4 :
10472: LD_EXP 7
10476: PUSH
10477: LD_INT 4
10479: DOUBLE
10480: EQUAL
10481: IFTRUE 10485
10483: GO 10500
10485: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-2 ) ; 6 :
10486: LD_EXP 13
10490: PPUSH
10491: LD_STRING DArtefTechnologyAr-JMM-2
10493: PPUSH
10494: CALL_OW 88
10498: GO 10524
10500: LD_INT 6
10502: DOUBLE
10503: EQUAL
10504: IFTRUE 10508
10506: GO 10523
10508: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-2 ) ; end ;
10509: LD_EXP 12
10513: PPUSH
10514: LD_STRING DArtefTechnologyAr-Bur-2
10516: PPUSH
10517: CALL_OW 88
10521: GO 10524
10523: POP
// Say ( sci , DArtefTechnologyAr-RSci1-3 ) ;
10524: LD_VAR 0 2
10528: PPUSH
10529: LD_STRING DArtefTechnologyAr-RSci1-3
10531: PPUSH
10532: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-3 ) ;
10536: LD_EXP 13
10540: PPUSH
10541: LD_STRING DArtefTechnologyAr-JMM-3
10543: PPUSH
10544: CALL_OW 88
// Say ( sci , DArtefTechnologyAr-RSci1-4 ) ;
10548: LD_VAR 0 2
10552: PPUSH
10553: LD_STRING DArtefTechnologyAr-RSci1-4
10555: PPUSH
10556: CALL_OW 88
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
10560: LD_EXP 12
10564: PPUSH
10565: LD_STRING DArtefTechnologyAr-Bur-4
10567: PPUSH
10568: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-4 ) ;
10572: LD_EXP 13
10576: PPUSH
10577: LD_STRING DArtefTechnologyAr-JMM-4
10579: PPUSH
10580: CALL_OW 88
// interface_hidden := false ;
10584: LD_ADDR_OWVAR 54
10588: PUSH
10589: LD_INT 0
10591: ST_TO_ADDR
// DialogueOff ;
10592: CALL_OW 7
// end ; end_of_file
10596: PPOPN 2
10598: END
// export omar_in_contact ; var sib_list ; every 0 0$2 + 0 0$0.4 trigger FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] ] ) = 0 marked 2 do var answer ;
10599: LD_INT 22
10601: PUSH
10602: LD_EXP 4
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 21
10613: PUSH
10614: LD_INT 1
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 50
10623: PUSH
10624: EMPTY
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: PUSH
10637: LD_INT 0
10639: EQUAL
10640: IFFALSE 11071
10642: GO 10644
10644: DISABLE
10645: LD_INT 0
10647: PPUSH
// begin Omar_Arrive ;
10648: CALL 11074 0 0
// CenterOnUnits ( Omar ) ;
10652: LD_EXP 51
10656: PPUSH
10657: CALL_OW 85
// DialogueOn ;
10661: CALL_OW 6
// interface_hidden := true ;
10665: LD_ADDR_OWVAR 54
10669: PUSH
10670: LD_INT 1
10672: ST_TO_ADDR
// Say ( Omar , DOmar-Omar-1 ) ;
10673: LD_EXP 51
10677: PPUSH
10678: LD_STRING DOmar-Omar-1
10680: PPUSH
10681: CALL_OW 88
// case camp of 4 :
10685: LD_EXP 7
10689: PUSH
10690: LD_INT 4
10692: DOUBLE
10693: EQUAL
10694: IFTRUE 10698
10696: GO 10713
10698: POP
// Say ( MacMillan , DOmar-JMM-1 ) ; 6 :
10699: LD_EXP 13
10703: PPUSH
10704: LD_STRING DOmar-JMM-1
10706: PPUSH
10707: CALL_OW 88
10711: GO 10737
10713: LD_INT 6
10715: DOUBLE
10716: EQUAL
10717: IFTRUE 10721
10719: GO 10736
10721: POP
// Say ( Burlak , DOmar-Bur-1 ) ; end ;
10722: LD_EXP 12
10726: PPUSH
10727: LD_STRING DOmar-Bur-1
10729: PPUSH
10730: CALL_OW 88
10734: GO 10737
10736: POP
// Say ( Omar , DOmar-Omar-2 ) ;
10737: LD_EXP 51
10741: PPUSH
10742: LD_STRING DOmar-Omar-2
10744: PPUSH
10745: CALL_OW 88
// case camp of 4 :
10749: LD_EXP 7
10753: PUSH
10754: LD_INT 4
10756: DOUBLE
10757: EQUAL
10758: IFTRUE 10762
10760: GO 10777
10762: POP
// Say ( MacMillan , DOmar-JMM-2 ) ; 6 :
10763: LD_EXP 13
10767: PPUSH
10768: LD_STRING DOmar-JMM-2
10770: PPUSH
10771: CALL_OW 88
10775: GO 10801
10777: LD_INT 6
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10800
10785: POP
// Say ( Burlak , DOmar-Bur-2 ) ; end ;
10786: LD_EXP 12
10790: PPUSH
10791: LD_STRING DOmar-Bur-2
10793: PPUSH
10794: CALL_OW 88
10798: GO 10801
10800: POP
// Say ( Omar , DOmar-Omar-3 ) ;
10801: LD_EXP 51
10805: PPUSH
10806: LD_STRING DOmar-Omar-3
10808: PPUSH
10809: CALL_OW 88
// case camp of 4 :
10813: LD_EXP 7
10817: PUSH
10818: LD_INT 4
10820: DOUBLE
10821: EQUAL
10822: IFTRUE 10826
10824: GO 10841
10826: POP
// Say ( MacMillan , DOmar-JMM-3 ) ; 6 :
10827: LD_EXP 13
10831: PPUSH
10832: LD_STRING DOmar-JMM-3
10834: PPUSH
10835: CALL_OW 88
10839: GO 10865
10841: LD_INT 6
10843: DOUBLE
10844: EQUAL
10845: IFTRUE 10849
10847: GO 10864
10849: POP
// Say ( Burlak , DOmar-Bur-3 ) ; end ;
10850: LD_EXP 12
10854: PPUSH
10855: LD_STRING DOmar-Bur-3
10857: PPUSH
10858: CALL_OW 88
10862: GO 10865
10864: POP
// Say ( Omar , DOmar-Omar-4 ) ;
10865: LD_EXP 51
10869: PPUSH
10870: LD_STRING DOmar-Omar-4
10872: PPUSH
10873: CALL_OW 88
// answer = Query ( QAccept ) ;
10877: LD_ADDR_VAR 0 1
10881: PUSH
10882: LD_STRING QAccept
10884: PPUSH
10885: CALL_OW 97
10889: ST_TO_ADDR
// case answer of 1 :
10890: LD_VAR 0 1
10894: PUSH
10895: LD_INT 1
10897: DOUBLE
10898: EQUAL
10899: IFTRUE 10903
10901: GO 10981
10903: POP
// begin case camp of 4 :
10904: LD_EXP 7
10908: PUSH
10909: LD_INT 4
10911: DOUBLE
10912: EQUAL
10913: IFTRUE 10917
10915: GO 10932
10917: POP
// Say ( MacMillan , DQrAccept#1-JMM-1 ) ; 6 :
10918: LD_EXP 13
10922: PPUSH
10923: LD_STRING DQrAccept#1-JMM-1
10925: PPUSH
10926: CALL_OW 88
10930: GO 10956
10932: LD_INT 6
10934: DOUBLE
10935: EQUAL
10936: IFTRUE 10940
10938: GO 10955
10940: POP
// Say ( Burlak , DQrAccept#1-Bur-1 ) ; end ;
10941: LD_EXP 12
10945: PPUSH
10946: LD_STRING DQrAccept#1-Bur-1
10948: PPUSH
10949: CALL_OW 88
10953: GO 10956
10955: POP
// SetSide ( Omar , you ) ;
10956: LD_EXP 51
10960: PPUSH
10961: LD_EXP 1
10965: PPUSH
10966: CALL_OW 235
// ComStop ( Omar ) ;
10970: LD_EXP 51
10974: PPUSH
10975: CALL_OW 141
// end ; 2 :
10979: GO 11045
10981: LD_INT 2
10983: DOUBLE
10984: EQUAL
10985: IFTRUE 10989
10987: GO 11044
10989: POP
// begin case camp of 4 :
10990: LD_EXP 7
10994: PUSH
10995: LD_INT 4
10997: DOUBLE
10998: EQUAL
10999: IFTRUE 11003
11001: GO 11018
11003: POP
// Say ( MacMillan , DQrAccept#2-JMM-1 ) ; 6 :
11004: LD_EXP 13
11008: PPUSH
11009: LD_STRING DQrAccept#2-JMM-1
11011: PPUSH
11012: CALL_OW 88
11016: GO 11042
11018: LD_INT 6
11020: DOUBLE
11021: EQUAL
11022: IFTRUE 11026
11024: GO 11041
11026: POP
// Say ( Burlak , DQrAccept#2-Bur-1 ) ; end ;
11027: LD_EXP 12
11031: PPUSH
11032: LD_STRING DQrAccept#2-Bur-1
11034: PPUSH
11035: CALL_OW 88
11039: GO 11042
11041: POP
// end ; end ;
11042: GO 11045
11044: POP
// interface_hidden := false ;
11045: LD_ADDR_OWVAR 54
11049: PUSH
11050: LD_INT 0
11052: ST_TO_ADDR
// DialogueOff ;
11053: CALL_OW 7
// if answer = 2 then
11057: LD_VAR 0 1
11061: PUSH
11062: LD_INT 2
11064: EQUAL
11065: IFFALSE 11071
// Omar_Leave ;
11067: CALL 11123 0 0
// end ;
11071: PPOPN 1
11073: END
// function Omar_Arrive ; var un ; begin
11074: LD_INT 0
11076: PPUSH
11077: PPUSH
// PlaceUnitArea ( Omar , omar_place , false ) ;
11078: LD_EXP 51
11082: PPUSH
11083: LD_INT 4
11085: PPUSH
11086: LD_INT 0
11088: PPUSH
11089: CALL_OW 49
// repeat ComMoveToArea ( Omar , teleport_area ) ;
11093: LD_EXP 51
11097: PPUSH
11098: LD_INT 24
11100: PPUSH
11101: CALL_OW 113
// wait ( 0 0$1 ) ;
11105: LD_INT 35
11107: PPUSH
11108: CALL_OW 67
// until omar_in_contact ;
11112: LD_EXP 64
11116: IFFALSE 11093
// end ;
11118: LD_VAR 0 1
11122: RET
// function Omar_Leave ; begin
11123: LD_INT 0
11125: PPUSH
// repeat ComMoveToArea ( Omar , omar_place ) ;
11126: LD_EXP 51
11130: PPUSH
11131: LD_INT 4
11133: PPUSH
11134: CALL_OW 113
// wait ( 0 0$1 ) ;
11138: LD_INT 35
11140: PPUSH
11141: CALL_OW 67
// until IsInArea ( Omar , omar_place ) ;
11145: LD_EXP 51
11149: PPUSH
11150: LD_INT 4
11152: PPUSH
11153: CALL_OW 308
11157: IFFALSE 11126
// RemoveUnit ( Omar ) ;
11159: LD_EXP 51
11163: PPUSH
11164: CALL_OW 64
// end ;
11168: LD_VAR 0 1
11172: RET
// every 0 0$3.7 trigger OmarWillTryContaminateMotherlode and ( FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 or finalize = 2 ) do var best_sib , see_him ;
11173: LD_EXP 54
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_EXP 2
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PUSH
11190: LD_INT 2
11192: PUSH
11193: LD_INT 30
11195: PUSH
11196: LD_INT 0
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 30
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: PUSH
11227: LD_INT 0
11229: EQUAL
11230: PUSH
11231: LD_EXP 58
11235: PUSH
11236: LD_INT 2
11238: EQUAL
11239: OR
11240: AND
11241: IFFALSE 11391
11243: GO 11245
11245: DISABLE
11246: LD_INT 0
11248: PPUSH
11249: PPUSH
// begin sib_list := get_sib_list ;
11250: LD_ADDR_LOC 11
11254: PUSH
11255: CALL 11636 0 0
11259: ST_TO_ADDR
// SetClass ( Omar , class_scientistic ) ;
11260: LD_EXP 51
11264: PPUSH
11265: LD_INT 4
11267: PPUSH
11268: CALL_OW 336
// PlaceUnitArea ( Omar , omar_infested , false ) ;
11272: LD_EXP 51
11276: PPUSH
11277: LD_INT 5
11279: PPUSH
11280: LD_INT 0
11282: PPUSH
11283: CALL_OW 49
// see_him := false ;
11287: LD_ADDR_VAR 0 2
11291: PUSH
11292: LD_INT 0
11294: ST_TO_ADDR
// repeat best_sib := get_best_sib ( sib_list ) ;
11295: LD_ADDR_VAR 0 1
11299: PUSH
11300: LD_LOC 11
11304: PPUSH
11305: CALL 11776 0 1
11309: ST_TO_ADDR
// ComContaminate ( Omar , best_sib [ 1 ] , best_sib [ 2 ] ) ;
11310: LD_EXP 51
11314: PPUSH
11315: LD_VAR 0 1
11319: PUSH
11320: LD_INT 1
11322: ARRAY
11323: PPUSH
11324: LD_VAR 0 1
11328: PUSH
11329: LD_INT 2
11331: ARRAY
11332: PPUSH
11333: CALL_OW 158
// if ( not see_him ) and See ( you , Omar ) then
11337: LD_VAR 0 2
11341: NOT
11342: PUSH
11343: LD_EXP 1
11347: PPUSH
11348: LD_EXP 51
11352: PPUSH
11353: CALL_OW 292
11357: AND
11358: IFFALSE 11372
// begin talking_to_omar ;
11360: CALL 11394 0 0
// see_him := true ;
11364: LD_ADDR_VAR 0 2
11368: PUSH
11369: LD_INT 1
11371: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
11372: LD_INT 35
11374: PPUSH
11375: CALL_OW 67
// until not IsLive ( Omar ) ;
11379: LD_EXP 51
11383: PPUSH
11384: CALL_OW 300
11388: NOT
11389: IFFALSE 11295
// end ;
11391: PPOPN 2
11393: END
// function talking_to_omar ; begin
11394: LD_INT 0
11396: PPUSH
// CenterOnUnits ( Omar ) ;
11397: LD_EXP 51
11401: PPUSH
11402: CALL_OW 85
// DialogueOn ;
11406: CALL_OW 6
// interface_hidden := true ;
11410: LD_ADDR_OWVAR 54
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// case camp of 4 :
11418: LD_EXP 7
11422: PUSH
11423: LD_INT 4
11425: DOUBLE
11426: EQUAL
11427: IFTRUE 11431
11429: GO 11446
11431: POP
// Say ( MacMillan , DOmarContam-JMM-1 ) ; 6 :
11432: LD_EXP 13
11436: PPUSH
11437: LD_STRING DOmarContam-JMM-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11470
11446: LD_INT 6
11448: DOUBLE
11449: EQUAL
11450: IFTRUE 11454
11452: GO 11469
11454: POP
// Say ( Burlak , DOmarContam-Bur-1 ) ; end ;
11455: LD_EXP 12
11459: PPUSH
11460: LD_STRING DOmarContam-Bur-1
11462: PPUSH
11463: CALL_OW 88
11467: GO 11470
11469: POP
// Say ( Omar , DOmarContam-Omar-1 ) ;
11470: LD_EXP 51
11474: PPUSH
11475: LD_STRING DOmarContam-Omar-1
11477: PPUSH
11478: CALL_OW 88
// case camp of 4 :
11482: LD_EXP 7
11486: PUSH
11487: LD_INT 4
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11510
11495: POP
// Say ( MacMillan , DOmarContam-JMM-2 ) ; 6 :
11496: LD_EXP 13
11500: PPUSH
11501: LD_STRING DOmarContam-JMM-2
11503: PPUSH
11504: CALL_OW 88
11508: GO 11534
11510: LD_INT 6
11512: DOUBLE
11513: EQUAL
11514: IFTRUE 11518
11516: GO 11533
11518: POP
// Say ( Burlak , DOmarContam-Bur-2 ) ; end ;
11519: LD_EXP 12
11523: PPUSH
11524: LD_STRING DOmarContam-Bur-2
11526: PPUSH
11527: CALL_OW 88
11531: GO 11534
11533: POP
// interface_hidden := false ;
11534: LD_ADDR_OWVAR 54
11538: PUSH
11539: LD_INT 0
11541: ST_TO_ADDR
// DialogueOff ;
11542: CALL_OW 7
// end ;
11546: LD_VAR 0 1
11550: RET
// on SibDepositContaminated ( sib , x , y ) do var list , un ;
11551: LD_INT 0
11553: PPUSH
11554: PPUSH
// begin InGameOn ;
11555: CALL_OW 8
// CenterOnXY ( x , y ) ;
11559: LD_VAR 0 2
11563: PPUSH
11564: LD_VAR 0 3
11568: PPUSH
11569: CALL_OW 84
// PlaceSeeing ( x , y , you , - 10 ) ;
11573: LD_VAR 0 2
11577: PPUSH
11578: LD_VAR 0 3
11582: PPUSH
11583: LD_EXP 1
11587: PPUSH
11588: LD_INT 10
11590: NEG
11591: PPUSH
11592: CALL_OW 330
// wait ( 0 0$7 ) ;
11596: LD_INT 245
11598: PPUSH
11599: CALL_OW 67
// Mission_Failed ( 5 ) ;
11603: LD_INT 5
11605: PPUSH
11606: CALL 13747 0 1
// RemoveSeeing ( x , y , you ) ;
11610: LD_VAR 0 2
11614: PPUSH
11615: LD_VAR 0 3
11619: PPUSH
11620: LD_EXP 1
11624: PPUSH
11625: CALL_OW 331
// InGameOff ;
11629: CALL_OW 9
// end ;
11633: PPOPN 5
11635: END
// function get_sib_list ; var list , un , vysledek ; begin
11636: LD_INT 0
11638: PPUSH
11639: PPUSH
11640: PPUSH
11641: PPUSH
// vysledek := [ ] ;
11642: LD_ADDR_VAR 0 4
11646: PUSH
11647: EMPTY
11648: ST_TO_ADDR
// list := GetListOfResourcesInArea ( ru_base ) ;
11649: LD_ADDR_VAR 0 2
11653: PUSH
11654: LD_INT 12
11656: PPUSH
11657: CALL_OW 442
11661: ST_TO_ADDR
// for un = 1 to ( list div 3 ) do
11662: LD_ADDR_VAR 0 3
11666: PUSH
11667: DOUBLE
11668: LD_INT 1
11670: DEC
11671: ST_TO_ADDR
11672: LD_VAR 0 2
11676: PUSH
11677: LD_INT 3
11679: DIV
11680: PUSH
11681: FOR_TO
11682: IFFALSE 11759
// if list [ ( un * 3 ) ] = source_siberium then
11684: LD_VAR 0 2
11688: PUSH
11689: LD_VAR 0 3
11693: PUSH
11694: LD_INT 3
11696: MUL
11697: ARRAY
11698: PUSH
11699: LD_INT 2
11701: EQUAL
11702: IFFALSE 11757
// vysledek := vysledek ^ [ list [ ( un * 3 ) - 2 ] , list [ ( un * 3 ) - 1 ] ] ;
11704: LD_ADDR_VAR 0 4
11708: PUSH
11709: LD_VAR 0 4
11713: PUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_VAR 0 3
11723: PUSH
11724: LD_INT 3
11726: MUL
11727: PUSH
11728: LD_INT 2
11730: MINUS
11731: ARRAY
11732: PUSH
11733: LD_VAR 0 2
11737: PUSH
11738: LD_VAR 0 3
11742: PUSH
11743: LD_INT 3
11745: MUL
11746: PUSH
11747: LD_INT 1
11749: MINUS
11750: ARRAY
11751: PUSH
11752: EMPTY
11753: LIST
11754: LIST
11755: ADD
11756: ST_TO_ADDR
11757: GO 11681
11759: POP
11760: POP
// result := vysledek ;
11761: LD_ADDR_VAR 0 1
11765: PUSH
11766: LD_VAR 0 4
11770: ST_TO_ADDR
// end ;
11771: LD_VAR 0 1
11775: RET
// function get_best_sib ( sib_list ) ; var un , min , x , y , dist , vysledek , b ; begin
11776: LD_INT 0
11778: PPUSH
11779: PPUSH
11780: PPUSH
11781: PPUSH
11782: PPUSH
11783: PPUSH
11784: PPUSH
11785: PPUSH
// min := [ - 1 , - 1 , - 1 ] ;
11786: LD_ADDR_VAR 0 4
11790: PUSH
11791: LD_INT 1
11793: NEG
11794: PUSH
11795: LD_INT 1
11797: NEG
11798: PUSH
11799: LD_INT 1
11801: NEG
11802: PUSH
11803: EMPTY
11804: LIST
11805: LIST
11806: LIST
11807: ST_TO_ADDR
// for un = 1 to ( sib_list div 2 ) do
11808: LD_ADDR_VAR 0 3
11812: PUSH
11813: DOUBLE
11814: LD_INT 1
11816: DEC
11817: ST_TO_ADDR
11818: LD_VAR 0 1
11822: PUSH
11823: LD_INT 2
11825: DIV
11826: PUSH
11827: FOR_TO
11828: IFFALSE 12001
// begin x := sib_list [ ( un * 2 ) - 1 ] ;
11830: LD_ADDR_VAR 0 5
11834: PUSH
11835: LD_VAR 0 1
11839: PUSH
11840: LD_VAR 0 3
11844: PUSH
11845: LD_INT 2
11847: MUL
11848: PUSH
11849: LD_INT 1
11851: MINUS
11852: ARRAY
11853: ST_TO_ADDR
// y := sib_list [ ( un * 2 ) ] ;
11854: LD_ADDR_VAR 0 6
11858: PUSH
11859: LD_VAR 0 1
11863: PUSH
11864: LD_VAR 0 3
11868: PUSH
11869: LD_INT 2
11871: MUL
11872: ARRAY
11873: ST_TO_ADDR
// dist := GetDistUnitXY ( Omar , x , y ) ;
11874: LD_ADDR_VAR 0 7
11878: PUSH
11879: LD_EXP 51
11883: PPUSH
11884: LD_VAR 0 5
11888: PPUSH
11889: LD_VAR 0 6
11893: PPUSH
11894: CALL_OW 297
11898: ST_TO_ADDR
// b = HexInfo ( x , y ) ;
11899: LD_ADDR_VAR 0 9
11903: PUSH
11904: LD_VAR 0 5
11908: PPUSH
11909: LD_VAR 0 6
11913: PPUSH
11914: CALL_OW 428
11918: ST_TO_ADDR
// if ( ( min [ 3 ] < 0 ) or ( dist < min [ 3 ] ) ) and ( b = 0 or GetBType ( b ) = b_siberite_mine ) then
11919: LD_VAR 0 4
11923: PUSH
11924: LD_INT 3
11926: ARRAY
11927: PUSH
11928: LD_INT 0
11930: LESS
11931: PUSH
11932: LD_VAR 0 7
11936: PUSH
11937: LD_VAR 0 4
11941: PUSH
11942: LD_INT 3
11944: ARRAY
11945: LESS
11946: OR
11947: PUSH
11948: LD_VAR 0 9
11952: PUSH
11953: LD_INT 0
11955: EQUAL
11956: PUSH
11957: LD_VAR 0 9
11961: PPUSH
11962: CALL_OW 266
11966: PUSH
11967: LD_INT 30
11969: EQUAL
11970: OR
11971: AND
11972: IFFALSE 11999
// min := [ x , y , dist ] ;
11974: LD_ADDR_VAR 0 4
11978: PUSH
11979: LD_VAR 0 5
11983: PUSH
11984: LD_VAR 0 6
11988: PUSH
11989: LD_VAR 0 7
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: ST_TO_ADDR
// end ;
11999: GO 11827
12001: POP
12002: POP
// vysledek := [ min [ 1 ] , min [ 2 ] ] ;
12003: LD_ADDR_VAR 0 8
12007: PUSH
12008: LD_VAR 0 4
12012: PUSH
12013: LD_INT 1
12015: ARRAY
12016: PUSH
12017: LD_VAR 0 4
12021: PUSH
12022: LD_INT 2
12024: ARRAY
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: ST_TO_ADDR
// result := vysledek ;
12030: LD_ADDR_VAR 0 2
12034: PUSH
12035: LD_VAR 0 8
12039: ST_TO_ADDR
// end ; end_of_file
12040: LD_VAR 0 2
12044: RET
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibFiss then
12045: LD_VAR 0 1
12049: PUSH
12050: LD_INT 25
12052: EQUAL
12053: IFFALSE 12094
// case GetSide ( lab ) of 1 :
12055: LD_VAR 0 2
12059: PPUSH
12060: CALL_OW 255
12064: PUSH
12065: LD_INT 1
12067: DOUBLE
12068: EQUAL
12069: IFTRUE 12073
12071: GO 12079
12073: POP
// enable ( 4 ) ; 3 :
12074: LD_INT 4
12076: ENABLE_MARKED
12077: GO 12094
12079: LD_INT 3
12081: DOUBLE
12082: EQUAL
12083: IFTRUE 12087
12085: GO 12093
12087: POP
// enable ( 5 ) ; end ;
12088: LD_INT 5
12090: ENABLE_MARKED
12091: GO 12094
12093: POP
// wait ( 10 ) ;
12094: LD_INT 10
12096: PPUSH
12097: CALL_OW 67
// if not IsBusy ( lab ) then
12101: LD_VAR 0 2
12105: PPUSH
12106: CALL_OW 315
12110: NOT
12111: IFFALSE 12138
// begin labs_in_use := labs_in_use diff lab ;
12113: LD_ADDR_EXP 79
12117: PUSH
12118: LD_EXP 79
12122: PUSH
12123: LD_VAR 0 2
12127: DIFF
12128: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 40076 0 1
// end ; end ;
12138: PPOPN 2
12140: END
// on ResearchStarted ( tech , lab ) do var un , side ;
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin labs_in_use := labs_in_use ^ lab ;
12145: LD_ADDR_EXP 79
12149: PUSH
12150: LD_EXP 79
12154: PUSH
12155: LD_VAR 0 2
12159: ADD
12160: ST_TO_ADDR
// side := GetSide ( lab ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 2
12170: PPUSH
12171: CALL_OW 255
12175: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
12176: LD_ADDR_VAR 0 3
12180: PUSH
12181: DOUBLE
12182: LD_INT 0
12184: DEC
12185: ST_TO_ADDR
12186: LD_EXP 76
12190: PUSH
12191: LD_INT 1
12193: MINUS
12194: PUSH
12195: FOR_TO
12196: IFFALSE 12275
// if lab in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
12198: LD_VAR 0 2
12202: PUSH
12203: LD_VAR 0 3
12207: PUSH
12208: LD_INT 100
12210: MUL
12211: PUSH
12212: LD_INT 11
12214: PLUS
12215: PPUSH
12216: CALL_OW 110
12220: PUSH
12221: LD_VAR 0 3
12225: PUSH
12226: LD_INT 100
12228: MUL
12229: PUSH
12230: LD_VAR 0 4
12234: PUSH
12235: LD_INT 10
12237: MUL
12238: PLUS
12239: PUSH
12240: LD_INT 15
12242: PLUS
12243: PPUSH
12244: CALL_OW 110
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: IN
12253: IFFALSE 12273
// DeInit_Lab ( side , un + 1 ) ;
12255: LD_VAR 0 4
12259: PPUSH
12260: LD_VAR 0 3
12264: PUSH
12265: LD_INT 1
12267: PLUS
12268: PPUSH
12269: CALL 39937 0 2
12273: GO 12195
12275: POP
12276: POP
// end ;
12277: PPOPN 4
12279: END
// on ResearchCancel ( tech , lab ) do begin wait ( 10 ) ;
12280: LD_INT 10
12282: PPUSH
12283: CALL_OW 67
// if not IsBusy ( lab ) then
12287: LD_VAR 0 2
12291: PPUSH
12292: CALL_OW 315
12296: NOT
12297: IFFALSE 12324
// begin labs_in_use := labs_in_use diff lab ;
12299: LD_ADDR_EXP 79
12303: PUSH
12304: LD_EXP 79
12308: PUSH
12309: LD_VAR 0 2
12313: DIFF
12314: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12315: LD_VAR 0 2
12319: PPUSH
12320: CALL 40076 0 1
// end ; end ;
12324: PPOPN 2
12326: END
// on UnitDestroyed ( un ) do begin if un = MacMillan then
12327: LD_VAR 0 1
12331: PUSH
12332: LD_EXP 13
12336: EQUAL
12337: IFFALSE 12346
// Mission_failed ( 1 ) ;
12339: LD_INT 1
12341: PPUSH
12342: CALL 13747 0 1
// if un = Burlak then
12346: LD_VAR 0 1
12350: PUSH
12351: LD_EXP 12
12355: EQUAL
12356: IFFALSE 12365
// Mission_failed ( 2 ) ;
12358: LD_INT 2
12360: PPUSH
12361: CALL 13747 0 1
// Update_defend ( un ) ;
12365: LD_VAR 0 1
12369: PPUSH
12370: CALL 20671 0 1
// end ;
12374: PPOPN 1
12376: END
// on UnitGoesToRed ( un ) do begin if ( un = MacMillan ) and not Doctors_available ( MacMillan ) then
12377: LD_VAR 0 1
12381: PUSH
12382: LD_EXP 13
12386: EQUAL
12387: PUSH
12388: LD_EXP 13
12392: PPUSH
12393: CALL 12529 0 1
12397: NOT
12398: AND
12399: IFFALSE 12408
// Mission_failed ( 1 ) ;
12401: LD_INT 1
12403: PPUSH
12404: CALL 13747 0 1
// if ( un = Burlak ) and not Doctors_available ( Burlak ) then
12408: LD_VAR 0 1
12412: PUSH
12413: LD_EXP 12
12417: EQUAL
12418: PUSH
12419: LD_EXP 12
12423: PPUSH
12424: CALL 12529 0 1
12428: NOT
12429: AND
12430: IFFALSE 12439
// Mission_failed ( 2 ) ;
12432: LD_INT 2
12434: PPUSH
12435: CALL 13747 0 1
// if ( GetSide ( un ) = us ) and ( GetControl ( un ) = control_remote ) then
12439: LD_VAR 0 1
12443: PPUSH
12444: CALL_OW 255
12448: PUSH
12449: LD_EXP 3
12453: EQUAL
12454: PUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 263
12464: PUSH
12465: LD_INT 2
12467: EQUAL
12468: AND
12469: IFFALSE 12487
// begin ComUnlink ( un ) ;
12471: LD_VAR 0 1
12475: PPUSH
12476: CALL_OW 136
// check_remote ( 0 ) ;
12480: LD_INT 0
12482: PPUSH
12483: CALL 35190 0 1
// end ; if GetUnitMc ( un ) then
12487: LD_VAR 0 1
12491: PPUSH
12492: CALL_OW 388
12496: IFFALSE 12517
// RemoveMcUnits ( GetUnitMc ( un ) , un ) ;
12498: LD_VAR 0 1
12502: PPUSH
12503: CALL_OW 388
12507: PPUSH
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 391
// Update_defend ( un ) ;
12517: LD_VAR 0 1
12521: PPUSH
12522: CALL 20671 0 1
// end ;
12526: PPOPN 1
12528: END
// function Doctors_available ( geroj ) ; var list , un , vysledek ; begin
12529: LD_INT 0
12531: PPUSH
12532: PPUSH
12533: PPUSH
12534: PPUSH
// vysledek := false ;
12535: LD_ADDR_VAR 0 5
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12543: LD_ADDR_VAR 0 3
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_EXP 1
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 25
12562: PUSH
12563: LD_INT 4
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PPUSH
12574: CALL_OW 69
12578: ST_TO_ADDR
// if list then
12579: LD_VAR 0 3
12583: IFFALSE 12593
// vysledek := true ;
12585: LD_ADDR_VAR 0 5
12589: PUSH
12590: LD_INT 1
12592: ST_TO_ADDR
// if ( not vysledek ) and ( IsInArea ( geroj , ar_crates ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_lab ] ] ) ) then
12593: LD_VAR 0 5
12597: NOT
12598: PUSH
12599: LD_VAR 0 1
12603: PPUSH
12604: LD_INT 3
12606: PPUSH
12607: CALL_OW 308
12611: AND
12612: PUSH
12613: LD_INT 22
12615: PUSH
12616: LD_EXP 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 21
12627: PUSH
12628: LD_INT 1
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PPUSH
12639: CALL_OW 69
12643: AND
12644: PUSH
12645: LD_INT 22
12647: PUSH
12648: LD_EXP 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 30
12659: PUSH
12660: LD_INT 6
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PPUSH
12671: CALL_OW 69
12675: AND
12676: IFFALSE 12686
// vysledek := true ;
12678: LD_ADDR_VAR 0 5
12682: PUSH
12683: LD_INT 1
12685: ST_TO_ADDR
// result := vysledek ;
12686: LD_ADDR_VAR 0 2
12690: PUSH
12691: LD_VAR 0 5
12695: ST_TO_ADDR
// end ;
12696: LD_VAR 0 2
12700: RET
// on Contact ( side1 , side2 ) do begin if ( side1 in [ ar_al , you ] ) and ( side2 in [ ar_al , you ] ) then
12701: LD_VAR 0 1
12705: PUSH
12706: LD_EXP 5
12710: PUSH
12711: LD_EXP 1
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: IN
12720: PUSH
12721: LD_VAR 0 2
12725: PUSH
12726: LD_EXP 5
12730: PUSH
12731: LD_EXP 1
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: IN
12740: AND
12741: IFFALSE 12751
// omar_in_contact := true ;
12743: LD_ADDR_EXP 64
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// end ;
12751: PPOPN 2
12753: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
12754: LD_VAR 0 1
12758: PPUSH
12759: CALL_OW 141
// if ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay ] ) then
12763: LD_VAR 0 1
12767: PPUSH
12768: CALL_OW 247
12772: PUSH
12773: LD_INT 2
12775: EQUAL
12776: PUSH
12777: LD_VAR 0 1
12781: PPUSH
12782: CALL_OW 264
12786: PUSH
12787: LD_INT 12
12789: PUSH
12790: LD_INT 51
12792: PUSH
12793: LD_INT 32
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: LIST
12800: IN
12801: AND
12802: IFFALSE 12818
// remove_bad_crates ( GetSide ( un ) ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: CALL_OW 255
12813: PPUSH
12814: CALL 34497 0 1
// end ;
12818: PPOPN 1
12820: END
// on VehicleConstructed ( veh , fac ) do var side , list , tower ;
12821: LD_INT 0
12823: PPUSH
12824: PPUSH
12825: PPUSH
// begin side := GetSide ( fac ) ;
12826: LD_ADDR_VAR 0 3
12830: PUSH
12831: LD_VAR 0 2
12835: PPUSH
12836: CALL_OW 255
12840: ST_TO_ADDR
// case side of 1 :
12841: LD_VAR 0 3
12845: PUSH
12846: LD_INT 1
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12980
12854: POP
// begin check_remote ( veh ) ;
12855: LD_VAR 0 1
12859: PPUSH
12860: CALL 35190 0 1
// list := ready_forces [ side ] ^ veh ;
12864: LD_ADDR_VAR 0 4
12868: PUSH
12869: LD_EXP 65
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: PUSH
12880: LD_VAR 0 1
12884: ADD
12885: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , list ) ;
12886: LD_ADDR_EXP 65
12890: PUSH
12891: LD_EXP 65
12895: PPUSH
12896: LD_VAR 0 3
12900: PPUSH
12901: LD_VAR 0 4
12905: PPUSH
12906: CALL_OW 1
12910: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_control_tower ] ] ) ;
12911: LD_ADDR_VAR 0 5
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_VAR 0 3
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 30
12930: PUSH
12931: LD_INT 36
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PPUSH
12942: CALL_OW 69
12946: ST_TO_ADDR
// AddComMoveToArea ( veh , us_parking ) ;
12947: LD_VAR 0 1
12951: PPUSH
12952: LD_INT 22
12954: PPUSH
12955: CALL_OW 173
// if GetWeapon ( veh ) = us_siberium_rocket then
12959: LD_VAR 0 1
12963: PPUSH
12964: CALL_OW 264
12968: PUSH
12969: LD_INT 8
12971: EQUAL
12972: IFFALSE 12978
// US_Wins ;
12974: CALL 13141 0 0
// end ; 2 :
12978: GO 13138
12980: LD_INT 2
12982: DOUBLE
12983: EQUAL
12984: IFTRUE 12988
12986: GO 13003
12988: POP
// ComMoveToArea ( veh , ar_parking ) ; 3 :
12989: LD_VAR 0 1
12993: PPUSH
12994: LD_INT 23
12996: PPUSH
12997: CALL_OW 113
13001: GO 13138
13003: LD_INT 3
13005: DOUBLE
13006: EQUAL
13007: IFTRUE 13011
13009: GO 13137
13011: POP
// begin if GetWeapon ( veh ) = ru_siberium_rocket then
13012: LD_VAR 0 1
13016: PPUSH
13017: CALL_OW 264
13021: PUSH
13022: LD_INT 48
13024: EQUAL
13025: IFFALSE 13056
// begin if us in cpu_list then
13027: LD_EXP 3
13031: PUSH
13032: LD_EXP 8
13036: IN
13037: IFFALSE 13050
// send_sib_to_US ( veh ) else
13039: LD_VAR 0 1
13043: PPUSH
13044: CALL 36606 0 1
13048: GO 13054
// RU_Wins ;
13050: CALL 13331 0 0
// end else
13054: GO 13135
// begin list := ready_forces [ side ] ^ veh ;
13056: LD_ADDR_VAR 0 4
13060: PUSH
13061: LD_EXP 65
13065: PUSH
13066: LD_VAR 0 3
13070: ARRAY
13071: PUSH
13072: LD_VAR 0 1
13076: ADD
13077: ST_TO_ADDR
// ready_forces := Delete ( ready_forces , side ) ;
13078: LD_ADDR_EXP 65
13082: PUSH
13083: LD_EXP 65
13087: PPUSH
13088: LD_VAR 0 3
13092: PPUSH
13093: CALL_OW 3
13097: ST_TO_ADDR
// ready_forces := Insert ( ready_forces , side , list ) ;
13098: LD_ADDR_EXP 65
13102: PUSH
13103: LD_EXP 65
13107: PPUSH
13108: LD_VAR 0 3
13112: PPUSH
13113: LD_VAR 0 4
13117: PPUSH
13118: CALL_OW 2
13122: ST_TO_ADDR
// ComMoveToArea ( veh , ru_parking ) ;
13123: LD_VAR 0 1
13127: PPUSH
13128: LD_INT 21
13130: PPUSH
13131: CALL_OW 113
// end ; end ; end ;
13135: GO 13138
13137: POP
// end ; end_of_file
13138: PPOPN 5
13140: END
// export function US_Wins ; begin
13141: LD_INT 0
13143: PPUSH
// DialogueOn ;
13144: CALL_OW 6
// if camp = 6 then
13148: LD_EXP 7
13152: PUSH
13153: LD_INT 6
13155: EQUAL
13156: IFFALSE 13169
// CenterOnUnits ( Burlak ) else
13158: LD_EXP 12
13162: PPUSH
13163: CALL_OW 85
13167: GO 13178
// CenterOnUnits ( MacMillan ) ;
13169: LD_EXP 13
13173: PPUSH
13174: CALL_OW 85
// wait ( 0 0$1 ) ;
13178: LD_INT 35
13180: PPUSH
13181: CALL_OW 67
// interface_hidden := true ;
13185: LD_ADDR_OWVAR 54
13189: PUSH
13190: LD_INT 1
13192: ST_TO_ADDR
// Say ( Powell , DWinAmericans-Pow-1 ) ;
13193: LD_EXP 55
13197: PPUSH
13198: LD_STRING DWinAmericans-Pow-1
13200: PPUSH
13201: CALL_OW 88
// case camp of 4 :
13205: LD_EXP 7
13209: PUSH
13210: LD_INT 4
13212: DOUBLE
13213: EQUAL
13214: IFTRUE 13218
13216: GO 13258
13218: POP
// if IsOK ( MacMillan ) then
13219: LD_EXP 13
13223: PPUSH
13224: CALL_OW 302
13228: IFFALSE 13244
// Say ( MacMillan , DWinAmericans-JMM-1 ) else
13230: LD_EXP 13
13234: PPUSH
13235: LD_STRING DWinAmericans-JMM-1
13237: PPUSH
13238: CALL_OW 88
13242: GO 13256
// Say ( Burlak , DWinAmericans-Bur-1 ) ; 6 :
13244: LD_EXP 12
13248: PPUSH
13249: LD_STRING DWinAmericans-Bur-1
13251: PPUSH
13252: CALL_OW 88
13256: GO 13307
13258: LD_INT 6
13260: DOUBLE
13261: EQUAL
13262: IFTRUE 13266
13264: GO 13306
13266: POP
// if IsOK ( Burlak ) then
13267: LD_EXP 12
13271: PPUSH
13272: CALL_OW 302
13276: IFFALSE 13292
// Say ( Burlak , DWinAmericans-Bur-1 ) else
13278: LD_EXP 12
13282: PPUSH
13283: LD_STRING DWinAmericans-Bur-1
13285: PPUSH
13286: CALL_OW 88
13290: GO 13304
// Say ( MacMillan , DWinAmericans-JMM-1 ) ; end ;
13292: LD_EXP 13
13296: PPUSH
13297: LD_STRING DWinAmericans-JMM-1
13299: PPUSH
13300: CALL_OW 88
13304: GO 13307
13306: POP
// interface_hidden := false ;
13307: LD_ADDR_OWVAR 54
13311: PUSH
13312: LD_INT 0
13314: ST_TO_ADDR
// DialogueOff ;
13315: CALL_OW 7
// Mission_failed ( 3 ) ;
13319: LD_INT 3
13321: PPUSH
13322: CALL 13747 0 1
// end ;
13326: LD_VAR 0 1
13330: RET
// export function RU_Wins ; begin
13331: LD_INT 0
13333: PPUSH
// if camp = 6 then
13334: LD_EXP 7
13338: PUSH
13339: LD_INT 6
13341: EQUAL
13342: IFFALSE 13355
// CenterOnUnits ( Burlak ) else
13344: LD_EXP 12
13348: PPUSH
13349: CALL_OW 85
13353: GO 13364
// CenterOnUnits ( MacMillan ) ;
13355: LD_EXP 13
13359: PPUSH
13360: CALL_OW 85
// DialogueOn ;
13364: CALL_OW 6
// InGameOn ;
13368: CALL_OW 8
// wait ( 0 0$1 ) ;
13372: LD_INT 35
13374: PPUSH
13375: CALL_OW 67
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13379: LD_EXP 56
13383: PPUSH
13384: LD_STRING DWinRussians-Pla-1
13386: PPUSH
13387: CALL_OW 94
// case camp of 4 :
13391: LD_EXP 7
13395: PUSH
13396: LD_INT 4
13398: DOUBLE
13399: EQUAL
13400: IFTRUE 13404
13402: GO 13444
13404: POP
// if IsOK ( MacMillan ) then
13405: LD_EXP 13
13409: PPUSH
13410: CALL_OW 302
13414: IFFALSE 13430
// Say ( MacMillan , DWinRussians-JMM-1 ) else
13416: LD_EXP 13
13420: PPUSH
13421: LD_STRING DWinRussians-JMM-1
13423: PPUSH
13424: CALL_OW 88
13428: GO 13442
// Say ( Burlak , DWinRussians-Bur-1 ) ; 6 :
13430: LD_EXP 12
13434: PPUSH
13435: LD_STRING DWinRussians-Bur-1
13437: PPUSH
13438: CALL_OW 88
13442: GO 13493
13444: LD_INT 6
13446: DOUBLE
13447: EQUAL
13448: IFTRUE 13452
13450: GO 13492
13452: POP
// if IsOK ( Burlak ) then
13453: LD_EXP 12
13457: PPUSH
13458: CALL_OW 302
13462: IFFALSE 13478
// Say ( Burlak , DWinRussians-Bur-1 ) else
13464: LD_EXP 12
13468: PPUSH
13469: LD_STRING DWinRussians-Bur-1
13471: PPUSH
13472: CALL_OW 88
13476: GO 13490
// Say ( MacMillan , DWinRussians-JMM-1 ) ; end ;
13478: LD_EXP 13
13482: PPUSH
13483: LD_STRING DWinRussians-JMM-1
13485: PPUSH
13486: CALL_OW 88
13490: GO 13493
13492: POP
// DialogueOff ;
13493: CALL_OW 7
// InGameOff ;
13497: CALL_OW 9
// Mission_failed ( 4 ) ;
13501: LD_INT 4
13503: PPUSH
13504: CALL 13747 0 1
// end ;
13508: LD_VAR 0 1
13512: RET
// on SiberiteRocketExploded ( un , x , y ) do begin InGameOn ;
13513: CALL_OW 8
// siberite_rocket_send := true ;
13517: LD_ADDR_EXP 60
13521: PUSH
13522: LD_INT 1
13524: ST_TO_ADDR
// wait ( 0 0$7 ) ;
13525: LD_INT 245
13527: PPUSH
13528: CALL_OW 67
// RU_Wins ;
13532: CALL 13331 0 0
// end ; end_of_file
13536: PPOPN 3
13538: END
// every 0 0$1 trigger finalize = 2 and ( not OmarWillTryContaminateMotherlode or GetLives ( Omar ) = 0 ) do
13539: LD_EXP 58
13543: PUSH
13544: LD_INT 2
13546: EQUAL
13547: PUSH
13548: LD_EXP 54
13552: NOT
13553: PUSH
13554: LD_EXP 51
13558: PPUSH
13559: CALL_OW 256
13563: PUSH
13564: LD_INT 0
13566: EQUAL
13567: OR
13568: AND
13569: IFFALSE 13585
13571: GO 13573
13573: DISABLE
// begin wait ( 0 0$1 ) ;
13574: LD_INT 35
13576: PPUSH
13577: CALL_OW 67
// Konec_Mise ;
13581: CALL 13586 0 0
// end ;
13585: END
// function Konec_Mise ; var campaign_loading , campaign_lost , another_campaign ; begin
13586: LD_INT 0
13588: PPUSH
13589: PPUSH
13590: PPUSH
13591: PPUSH
// lets_talking ;
13592: CALL 16125 0 0
// another_campaign := true ;
13596: LD_ADDR_VAR 0 4
13600: PUSH
13601: LD_INT 1
13603: ST_TO_ADDR
// gained_medals := [ ] ;
13604: LD_ADDR_OWVAR 61
13608: PUSH
13609: EMPTY
13610: ST_TO_ADDR
// missing_medals := [ ] ;
13611: LD_ADDR_OWVAR 62
13615: PUSH
13616: EMPTY
13617: ST_TO_ADDR
// AddMedal ( Hero , another_campaign ) ;
13618: LD_STRING Hero
13620: PPUSH
13621: LD_VAR 0 4
13625: PPUSH
13626: CALL_OW 101
// AddMedal ( Artefact , GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ) ;
13630: LD_STRING Artefact
13632: PPUSH
13633: LD_INT 81
13635: PPUSH
13636: CALL_OW 110
13640: PUSH
13641: LD_INT 181
13643: PPUSH
13644: CALL_OW 110
13648: AND
13649: PUSH
13650: LD_INT 281
13652: PPUSH
13653: CALL_OW 110
13657: AND
13658: PPUSH
13659: CALL_OW 101
// case camp of 4 :
13663: LD_EXP 7
13667: PUSH
13668: LD_INT 4
13670: DOUBLE
13671: EQUAL
13672: IFTRUE 13676
13674: GO 13696
13676: POP
// AddMedal ( ReconcileBurlak , IsOK ( Burlak ) ) ; 6 :
13677: LD_STRING ReconcileBurlak
13679: PPUSH
13680: LD_EXP 12
13684: PPUSH
13685: CALL_OW 302
13689: PPUSH
13690: CALL_OW 101
13694: GO 13725
13696: LD_INT 6
13698: DOUBLE
13699: EQUAL
13700: IFTRUE 13704
13702: GO 13724
13704: POP
// AddMedal ( ReconcileJMM , IsOK ( MacMillan ) ) ; end ;
13705: LD_STRING ReconcileJMM
13707: PPUSH
13708: LD_EXP 13
13712: PPUSH
13713: CALL_OW 302
13717: PPUSH
13718: CALL_OW 101
13722: GO 13725
13724: POP
// SA_OnMissionComplete ;
13725: CALL 42327 0 0
// GiveMedals ( Main ) ;
13729: LD_STRING Main
13731: PPUSH
13732: CALL_OW 102
// YouWin ;
13736: CALL_OW 103
// exit ;
13740: GO 13742
// end ;
13742: LD_VAR 0 1
13746: RET
// export function Mission_Failed ( how ) ; begin
13747: LD_INT 0
13749: PPUSH
// case how of 1 :
13750: LD_VAR 0 1
13754: PUSH
13755: LD_INT 1
13757: DOUBLE
13758: EQUAL
13759: IFTRUE 13763
13761: GO 13773
13763: POP
// YouLost ( JMM ) ; 2 :
13764: LD_STRING JMM
13766: PPUSH
13767: CALL_OW 104
13771: GO 13846
13773: LD_INT 2
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13791
13781: POP
// YouLost ( Burlak ) ; 3 :
13782: LD_STRING Burlak
13784: PPUSH
13785: CALL_OW 104
13789: GO 13846
13791: LD_INT 3
13793: DOUBLE
13794: EQUAL
13795: IFTRUE 13799
13797: GO 13809
13799: POP
// YouLost ( AmBomb ) ; 4 :
13800: LD_STRING AmBomb
13802: PPUSH
13803: CALL_OW 104
13807: GO 13846
13809: LD_INT 4
13811: DOUBLE
13812: EQUAL
13813: IFTRUE 13817
13815: GO 13827
13817: POP
// YouLost ( RuBomb ) ; 5 :
13818: LD_STRING RuBomb
13820: PPUSH
13821: CALL_OW 104
13825: GO 13846
13827: LD_INT 5
13829: DOUBLE
13830: EQUAL
13831: IFTRUE 13835
13833: GO 13845
13835: POP
// YouLost ( MothContaminate ) ; end ;
13836: LD_STRING MothContaminate
13838: PPUSH
13839: CALL_OW 104
13843: GO 13846
13845: POP
// end ; end_of_file
13846: LD_VAR 0 2
13850: RET
// function Base_Destroyed ( side ) ; var un , list , vysledek ; begin
13851: LD_INT 0
13853: PPUSH
13854: PPUSH
13855: PPUSH
13856: PPUSH
// vysledek := false ;
13857: LD_ADDR_VAR 0 5
13861: PUSH
13862: LD_INT 0
13864: ST_TO_ADDR
// if not ( FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] ] ) or FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ) then
13865: LD_INT 22
13867: PUSH
13868: LD_VAR 0 1
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: PUSH
13877: LD_INT 2
13879: PUSH
13880: LD_INT 30
13882: PUSH
13883: LD_INT 0
13885: PUSH
13886: EMPTY
13887: LIST
13888: LIST
13889: PUSH
13890: LD_INT 30
13892: PUSH
13893: LD_INT 1
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: LIST
13904: PUSH
13905: LD_INT 50
13907: PUSH
13908: EMPTY
13909: LIST
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: LIST
13915: PPUSH
13916: CALL_OW 69
13920: PUSH
13921: LD_INT 22
13923: PUSH
13924: LD_VAR 0 1
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PUSH
13933: LD_INT 25
13935: PUSH
13936: LD_INT 2
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: PUSH
13943: LD_INT 50
13945: PUSH
13946: EMPTY
13947: LIST
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: LIST
13953: PPUSH
13954: CALL_OW 69
13958: OR
13959: NOT
13960: IFFALSE 13970
// vysledek := true ;
13962: LD_ADDR_VAR 0 5
13966: PUSH
13967: LD_INT 1
13969: ST_TO_ADDR
// if not vysledek then
13970: LD_VAR 0 5
13974: NOT
13975: IFFALSE 14038
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
13977: LD_ADDR_VAR 0 4
13981: PUSH
13982: LD_INT 22
13984: PUSH
13985: LD_VAR 0 1
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: LD_INT 21
13996: PUSH
13997: LD_INT 1
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: PUSH
14004: LD_INT 50
14006: PUSH
14007: EMPTY
14008: LIST
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: LIST
14014: PPUSH
14015: CALL_OW 69
14019: ST_TO_ADDR
// if list < 3 then
14020: LD_VAR 0 4
14024: PUSH
14025: LD_INT 3
14027: LESS
14028: IFFALSE 14038
// vysledek := true ;
14030: LD_ADDR_VAR 0 5
14034: PUSH
14035: LD_INT 1
14037: ST_TO_ADDR
// end ; if not vysledek then
14038: LD_VAR 0 5
14042: NOT
14043: IFFALSE 14173
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_ok ] ] ) ;
14045: LD_ADDR_VAR 0 4
14049: PUSH
14050: LD_INT 22
14052: PUSH
14053: LD_VAR 0 1
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: LD_INT 2
14064: PUSH
14065: LD_INT 30
14067: PUSH
14068: LD_INT 32
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: PUSH
14075: LD_INT 30
14077: PUSH
14078: LD_INT 33
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 50
14092: PUSH
14093: EMPTY
14094: LIST
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: PPUSH
14101: CALL_OW 69
14105: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_INT 22
14113: PUSH
14114: LD_VAR 0 1
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: PUSH
14123: LD_INT 21
14125: PUSH
14126: LD_INT 2
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PUSH
14133: LD_INT 50
14135: PUSH
14136: EMPTY
14137: LIST
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: LIST
14143: PPUSH
14144: CALL_OW 69
14148: ST_TO_ADDR
// if ( un + list ) < 5 then
14149: LD_VAR 0 3
14153: PUSH
14154: LD_VAR 0 4
14158: PLUS
14159: PUSH
14160: LD_INT 5
14162: LESS
14163: IFFALSE 14173
// vysledek := true ;
14165: LD_ADDR_VAR 0 5
14169: PUSH
14170: LD_INT 1
14172: ST_TO_ADDR
// end ; if not vysledek then
14173: LD_VAR 0 5
14177: NOT
14178: IFFALSE 14267
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] , [ f_ok ] ] ) ;
14180: LD_ADDR_VAR 0 4
14184: PUSH
14185: LD_INT 22
14187: PUSH
14188: LD_VAR 0 1
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: PUSH
14197: LD_INT 2
14199: PUSH
14200: LD_INT 30
14202: PUSH
14203: LD_INT 27
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: PUSH
14210: LD_INT 30
14212: PUSH
14213: LD_INT 26
14215: PUSH
14216: EMPTY
14217: LIST
14218: LIST
14219: PUSH
14220: LD_INT 30
14222: PUSH
14223: LD_INT 28
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 50
14238: PUSH
14239: EMPTY
14240: LIST
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: LIST
14246: PPUSH
14247: CALL_OW 69
14251: ST_TO_ADDR
// if not list then
14252: LD_VAR 0 4
14256: NOT
14257: IFFALSE 14267
// vysledek := 0 ;
14259: LD_ADDR_VAR 0 5
14263: PUSH
14264: LD_INT 0
14266: ST_TO_ADDR
// end ; result := vysledek ;
14267: LD_ADDR_VAR 0 2
14271: PUSH
14272: LD_VAR 0 5
14276: ST_TO_ADDR
// end ;
14277: LD_VAR 0 2
14281: RET
// every 0 0$2.1 trigger Base_Destroyed ( us ) and not siberite_rocket_send do var sol , un , list ;
14282: LD_EXP 3
14286: PPUSH
14287: CALL 13851 0 1
14291: PUSH
14292: LD_EXP 60
14296: NOT
14297: AND
14298: IFFALSE 14865
14300: GO 14302
14302: DISABLE
14303: LD_INT 0
14305: PPUSH
14306: PPUSH
14307: PPUSH
// begin if IsOK ( Powell ) then
14308: LD_EXP 55
14312: PPUSH
14313: CALL_OW 302
14317: IFFALSE 14395
// begin CenterOnUnits ( Powell ) ;
14319: LD_EXP 55
14323: PPUSH
14324: CALL_OW 85
// DialogueOn ;
14328: CALL_OW 6
// interface_hidden := true ;
14332: LD_ADDR_OWVAR 54
14336: PUSH
14337: LD_INT 1
14339: ST_TO_ADDR
// Say ( Powell , DSurrenderAmericans-Pow-1 ) ;
14340: LD_EXP 55
14344: PPUSH
14345: LD_STRING DSurrenderAmericans-Pow-1
14347: PPUSH
14348: CALL_OW 88
// Say ( MacMillan , DSurrenderAmericans-JMM-1 ) ;
14352: LD_EXP 13
14356: PPUSH
14357: LD_STRING DSurrenderAmericans-JMM-1
14359: PPUSH
14360: CALL_OW 88
// interface_hidden := false ;
14364: LD_ADDR_OWVAR 54
14368: PUSH
14369: LD_INT 0
14371: ST_TO_ADDR
// DialogueOff ;
14372: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
14376: LD_INT 35
14378: PPUSH
14379: CALL_OW 67
// until not IsOK ( Powell ) ;
14383: LD_EXP 55
14387: PPUSH
14388: CALL_OW 302
14392: NOT
14393: IFFALSE 14376
// end ; cpu_list := cpu_list diff us ;
14395: LD_ADDR_EXP 8
14399: PUSH
14400: LD_EXP 8
14404: PUSH
14405: LD_EXP 3
14409: DIFF
14410: ST_TO_ADDR
// SetAttitude ( you , us , att_friend , true ) ;
14411: LD_EXP 1
14415: PPUSH
14416: LD_EXP 3
14420: PPUSH
14421: LD_INT 1
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: CALL_OW 80
// sol := FindLastMohycane ( us ) ;
14431: LD_ADDR_VAR 0 1
14435: PUSH
14436: LD_EXP 3
14440: PPUSH
14441: CALL 15741 0 1
14445: ST_TO_ADDR
// if IsOK ( sol ) then
14446: LD_VAR 0 1
14450: PPUSH
14451: CALL_OW 302
14455: IFFALSE 14466
// ComExitBuilding ( sol ) ;
14457: LD_VAR 0 1
14461: PPUSH
14462: CALL_OW 122
// while not See ( you , sol ) do
14466: LD_EXP 1
14470: PPUSH
14471: LD_VAR 0 1
14475: PPUSH
14476: CALL_OW 292
14480: NOT
14481: IFFALSE 14548
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
14483: LD_ADDR_VAR 0 2
14487: PUSH
14488: LD_INT 22
14490: PUSH
14491: LD_EXP 1
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PUSH
14500: LD_INT 50
14502: PUSH
14503: EMPTY
14504: LIST
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
14515: LD_VAR 0 1
14519: PPUSH
14520: LD_VAR 0 2
14524: PPUSH
14525: LD_VAR 0 1
14529: PPUSH
14530: CALL_OW 74
14534: PPUSH
14535: CALL_OW 112
// wait ( 0 0$1 ) ;
14539: LD_INT 35
14541: PPUSH
14542: CALL_OW 67
// end ;
14546: GO 14466
// CenterOnUnits ( sol ) ;
14548: LD_VAR 0 1
14552: PPUSH
14553: CALL_OW 85
// DialogueOn ;
14557: CALL_OW 6
// interface_hidden := true ;
14561: LD_ADDR_OWVAR 54
14565: PUSH
14566: LD_INT 1
14568: ST_TO_ADDR
// case camp of 4 :
14569: LD_EXP 7
14573: PUSH
14574: LD_INT 4
14576: DOUBLE
14577: EQUAL
14578: IFTRUE 14582
14580: GO 14597
14582: POP
// Say ( sol , DSurrenderAmericans-Sol1-1a ) ; 6 :
14583: LD_VAR 0 1
14587: PPUSH
14588: LD_STRING DSurrenderAmericans-Sol1-1a
14590: PPUSH
14591: CALL_OW 88
14595: GO 14621
14597: LD_INT 6
14599: DOUBLE
14600: EQUAL
14601: IFTRUE 14605
14603: GO 14620
14605: POP
// Say ( sol , DSurrenderAmericans-Sol1-1 ) ; end ;
14606: LD_VAR 0 1
14610: PPUSH
14611: LD_STRING DSurrenderAmericans-Sol1-1
14613: PPUSH
14614: CALL_OW 88
14618: GO 14621
14620: POP
// interface_hidden := false ;
14621: LD_ADDR_OWVAR 54
14625: PUSH
14626: LD_INT 0
14628: ST_TO_ADDR
// DialogueOff ;
14629: CALL_OW 7
// finalize := finalize + 1 ;
14633: LD_ADDR_EXP 58
14637: PUSH
14638: LD_EXP 58
14642: PUSH
14643: LD_INT 1
14645: PLUS
14646: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , us ] , f_not , [ f_type , unit_human ] ] ) ;
14647: LD_ADDR_VAR 0 3
14651: PUSH
14652: LD_INT 22
14654: PUSH
14655: LD_EXP 3
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: LD_INT 3
14666: PUSH
14667: LD_INT 21
14669: PUSH
14670: LD_INT 1
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: LIST
14681: PPUSH
14682: CALL_OW 69
14686: ST_TO_ADDR
// SetSide ( list , you ) ;
14687: LD_VAR 0 3
14691: PPUSH
14692: LD_EXP 1
14696: PPUSH
14697: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
14701: LD_VAR 0 3
14705: PPUSH
14706: LD_INT 21
14708: PUSH
14709: LD_INT 2
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: PPUSH
14716: CALL_OW 72
14720: PPUSH
14721: CALL 14868 0 1
// repeat list := FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 22
14732: PUSH
14733: LD_EXP 3
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PUSH
14742: LD_INT 21
14744: PUSH
14745: LD_INT 1
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PUSH
14752: LD_INT 50
14754: PUSH
14755: EMPTY
14756: LIST
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: LIST
14762: PPUSH
14763: CALL_OW 69
14767: ST_TO_ADDR
// ComMoveToArea ( list , am_leaving_area ) ;
14768: LD_VAR 0 3
14772: PPUSH
14773: LD_INT 30
14775: PPUSH
14776: CALL_OW 113
// if list then
14780: LD_VAR 0 3
14784: IFFALSE 14793
// wait ( 0 0$2 ) ;
14786: LD_INT 70
14788: PPUSH
14789: CALL_OW 67
// sol := FilterUnitsInArea ( am_leaving_area , [ [ f_side , us ] , [ f_type , unit_human ] ] ) ;
14793: LD_ADDR_VAR 0 1
14797: PUSH
14798: LD_INT 30
14800: PPUSH
14801: LD_INT 22
14803: PUSH
14804: LD_EXP 3
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 21
14815: PUSH
14816: LD_INT 1
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: EMPTY
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 70
14831: ST_TO_ADDR
// for un in sol do
14832: LD_ADDR_VAR 0 2
14836: PUSH
14837: LD_VAR 0 1
14841: PUSH
14842: FOR_IN
14843: IFFALSE 14856
// RemoveUnit ( un ) ;
14845: LD_VAR 0 2
14849: PPUSH
14850: CALL_OW 64
14854: GO 14842
14856: POP
14857: POP
// until not list ;
14858: LD_VAR 0 3
14862: NOT
14863: IFFALSE 14725
// end ;
14865: PPOPN 3
14867: END
// function DestroyAndReplaceVehicles ( list ) ; var i , x , y , driver , veh ; begin
14868: LD_INT 0
14870: PPUSH
14871: PPUSH
14872: PPUSH
14873: PPUSH
14874: PPUSH
14875: PPUSH
// for i in list do
14876: LD_ADDR_VAR 0 3
14880: PUSH
14881: LD_VAR 0 1
14885: PUSH
14886: FOR_IN
14887: IFFALSE 15148
// begin InitUc ;
14889: CALL_OW 18
// InitVc ;
14893: CALL_OW 20
// uc_nation = GetNation ( i ) ;
14897: LD_ADDR_OWVAR 21
14901: PUSH
14902: LD_VAR 0 3
14906: PPUSH
14907: CALL_OW 248
14911: ST_TO_ADDR
// uc_side = GetSide ( i ) ;
14912: LD_ADDR_OWVAR 20
14916: PUSH
14917: LD_VAR 0 3
14921: PPUSH
14922: CALL_OW 255
14926: ST_TO_ADDR
// uc_direction = GetDir ( i ) ;
14927: LD_ADDR_OWVAR 24
14931: PUSH
14932: LD_VAR 0 3
14936: PPUSH
14937: CALL_OW 254
14941: ST_TO_ADDR
// vc_chassis = GetChassis ( i ) ;
14942: LD_ADDR_OWVAR 37
14946: PUSH
14947: LD_VAR 0 3
14951: PPUSH
14952: CALL_OW 265
14956: ST_TO_ADDR
// vc_engine = GetEngine ( i ) ;
14957: LD_ADDR_OWVAR 39
14961: PUSH
14962: LD_VAR 0 3
14966: PPUSH
14967: CALL_OW 262
14971: ST_TO_ADDR
// vc_weapon = GetWeapon ( i ) ;
14972: LD_ADDR_OWVAR 40
14976: PUSH
14977: LD_VAR 0 3
14981: PPUSH
14982: CALL_OW 264
14986: ST_TO_ADDR
// vc_control = GetControl ( i ) ;
14987: LD_ADDR_OWVAR 38
14991: PUSH
14992: LD_VAR 0 3
14996: PPUSH
14997: CALL_OW 263
15001: ST_TO_ADDR
// vc_fuel_battery = GetFuel ( i ) ;
15002: LD_ADDR_OWVAR 41
15006: PUSH
15007: LD_VAR 0 3
15011: PPUSH
15012: CALL_OW 261
15016: ST_TO_ADDR
// x = GetX ( i ) ;
15017: LD_ADDR_VAR 0 4
15021: PUSH
15022: LD_VAR 0 3
15026: PPUSH
15027: CALL_OW 250
15031: ST_TO_ADDR
// y = GetY ( i ) ;
15032: LD_ADDR_VAR 0 5
15036: PUSH
15037: LD_VAR 0 3
15041: PPUSH
15042: CALL_OW 251
15046: ST_TO_ADDR
// driver = IsDrivenBy ( i ) ;
15047: LD_ADDR_VAR 0 6
15051: PUSH
15052: LD_VAR 0 3
15056: PPUSH
15057: CALL_OW 311
15061: ST_TO_ADDR
// if driver > 0 then
15062: LD_VAR 0 6
15066: PUSH
15067: LD_INT 0
15069: GREATER
15070: IFFALSE 15081
// RemoveUnit ( driver ) ;
15072: LD_VAR 0 6
15076: PPUSH
15077: CALL_OW 64
// DestroyUnit ( i ) ;
15081: LD_VAR 0 3
15085: PPUSH
15086: CALL_OW 65
// veh = CreateVehicle ;
15090: LD_ADDR_VAR 0 7
15094: PUSH
15095: CALL_OW 45
15099: ST_TO_ADDR
// PlaceUnitXY ( veh , x , y , false ) ;
15100: LD_VAR 0 7
15104: PPUSH
15105: LD_VAR 0 4
15109: PPUSH
15110: LD_VAR 0 5
15114: PPUSH
15115: LD_INT 0
15117: PPUSH
15118: CALL_OW 48
// if driver > 0 then
15122: LD_VAR 0 6
15126: PUSH
15127: LD_INT 0
15129: GREATER
15130: IFFALSE 15146
// PlaceHumanInUnit ( driver , veh ) ;
15132: LD_VAR 0 6
15136: PPUSH
15137: LD_VAR 0 7
15141: PPUSH
15142: CALL_OW 52
// end ;
15146: GO 14886
15148: POP
15149: POP
// end ;
15150: LD_VAR 0 2
15154: RET
// every 0 0$2.3 trigger Base_Destroyed ( ru ) and not siberite_rocket_send do var list , sol , un ;
15155: LD_EXP 2
15159: PPUSH
15160: CALL 13851 0 1
15164: PUSH
15165: LD_EXP 60
15169: NOT
15170: AND
15171: IFFALSE 15738
15173: GO 15175
15175: DISABLE
15176: LD_INT 0
15178: PPUSH
15179: PPUSH
15180: PPUSH
// begin if IsOK ( Platonov ) then
15181: LD_EXP 56
15185: PPUSH
15186: CALL_OW 302
15190: IFFALSE 15268
// begin CenterOnUnits ( Platonov ) ;
15192: LD_EXP 56
15196: PPUSH
15197: CALL_OW 85
// DialogueOn ;
15201: CALL_OW 6
// interface_hidden := true ;
15205: LD_ADDR_OWVAR 54
15209: PUSH
15210: LD_INT 1
15212: ST_TO_ADDR
// Say ( Platonov , DSurrenderRussians-Pla-1 ) ;
15213: LD_EXP 56
15217: PPUSH
15218: LD_STRING DSurrenderRussians-Pla-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15225: LD_EXP 12
15229: PPUSH
15230: LD_STRING DSurrenderRussians-Bur-1
15232: PPUSH
15233: CALL_OW 88
// interface_hidden := false ;
15237: LD_ADDR_OWVAR 54
15241: PUSH
15242: LD_INT 0
15244: ST_TO_ADDR
// DialogueOff ;
15245: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
15249: LD_INT 35
15251: PPUSH
15252: CALL_OW 67
// until not IsOK ( Platonov ) ;
15256: LD_EXP 56
15260: PPUSH
15261: CALL_OW 302
15265: NOT
15266: IFFALSE 15249
// end ; cpu_list := cpu_list diff ru ;
15268: LD_ADDR_EXP 8
15272: PUSH
15273: LD_EXP 8
15277: PUSH
15278: LD_EXP 2
15282: DIFF
15283: ST_TO_ADDR
// SetAttitude ( you , ru , att_friend , true ) ;
15284: LD_EXP 1
15288: PPUSH
15289: LD_EXP 2
15293: PPUSH
15294: LD_INT 1
15296: PPUSH
15297: LD_INT 1
15299: PPUSH
15300: CALL_OW 80
// sol := FindLastMohycane ( ru ) ;
15304: LD_ADDR_VAR 0 2
15308: PUSH
15309: LD_EXP 2
15313: PPUSH
15314: CALL 15741 0 1
15318: ST_TO_ADDR
// if IsOK ( sol ) then
15319: LD_VAR 0 2
15323: PPUSH
15324: CALL_OW 302
15328: IFFALSE 15339
// ComExitBuilding ( sol ) ;
15330: LD_VAR 0 2
15334: PPUSH
15335: CALL_OW 122
// while not See ( you , sol ) do
15339: LD_EXP 1
15343: PPUSH
15344: LD_VAR 0 2
15348: PPUSH
15349: CALL_OW 292
15353: NOT
15354: IFFALSE 15421
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
15356: LD_ADDR_VAR 0 3
15360: PUSH
15361: LD_INT 22
15363: PUSH
15364: LD_EXP 1
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: PUSH
15373: LD_INT 50
15375: PUSH
15376: EMPTY
15377: LIST
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PPUSH
15383: CALL_OW 69
15387: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
15388: LD_VAR 0 2
15392: PPUSH
15393: LD_VAR 0 3
15397: PPUSH
15398: LD_VAR 0 2
15402: PPUSH
15403: CALL_OW 74
15407: PPUSH
15408: CALL_OW 112
// wait ( 0 0$1 ) ;
15412: LD_INT 35
15414: PPUSH
15415: CALL_OW 67
// end ;
15419: GO 15339
// CenterOnUnits ( sol ) ;
15421: LD_VAR 0 2
15425: PPUSH
15426: CALL_OW 85
// DialogueOn ;
15430: CALL_OW 6
// interface_hidden := true ;
15434: LD_ADDR_OWVAR 54
15438: PUSH
15439: LD_INT 1
15441: ST_TO_ADDR
// case camp of 4 :
15442: LD_EXP 7
15446: PUSH
15447: LD_INT 4
15449: DOUBLE
15450: EQUAL
15451: IFTRUE 15455
15453: GO 15470
15455: POP
// Say ( sol , DSurrenderRussians-Rsol1-1a ) ; 6 :
15456: LD_VAR 0 2
15460: PPUSH
15461: LD_STRING DSurrenderRussians-Rsol1-1a
15463: PPUSH
15464: CALL_OW 88
15468: GO 15494
15470: LD_INT 6
15472: DOUBLE
15473: EQUAL
15474: IFTRUE 15478
15476: GO 15493
15478: POP
// Say ( sol , DSurrenderRussians-Rsol1-1 ) ; end ;
15479: LD_VAR 0 2
15483: PPUSH
15484: LD_STRING DSurrenderRussians-Rsol1-1
15486: PPUSH
15487: CALL_OW 88
15491: GO 15494
15493: POP
// interface_hidden := false ;
15494: LD_ADDR_OWVAR 54
15498: PUSH
15499: LD_INT 0
15501: ST_TO_ADDR
// DialogueOff ;
15502: CALL_OW 7
// finalize := finalize + 1 ;
15506: LD_ADDR_EXP 58
15510: PUSH
15511: LD_EXP 58
15515: PUSH
15516: LD_INT 1
15518: PLUS
15519: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , ru ] , f_not , [ f_type , unit_human ] ] ) ;
15520: LD_ADDR_VAR 0 1
15524: PUSH
15525: LD_INT 22
15527: PUSH
15528: LD_EXP 2
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PUSH
15537: LD_INT 3
15539: PUSH
15540: LD_INT 21
15542: PUSH
15543: LD_INT 1
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: LIST
15554: PPUSH
15555: CALL_OW 69
15559: ST_TO_ADDR
// SetSide ( list , you ) ;
15560: LD_VAR 0 1
15564: PPUSH
15565: LD_EXP 1
15569: PPUSH
15570: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15574: LD_VAR 0 1
15578: PPUSH
15579: LD_INT 21
15581: PUSH
15582: LD_INT 2
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 72
15593: PPUSH
15594: CALL 14868 0 1
// repeat list := FilterAllUnits ( [ [ f_side , ru ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
15598: LD_ADDR_VAR 0 1
15602: PUSH
15603: LD_INT 22
15605: PUSH
15606: LD_EXP 2
15610: PUSH
15611: EMPTY
15612: LIST
15613: LIST
15614: PUSH
15615: LD_INT 21
15617: PUSH
15618: LD_INT 1
15620: PUSH
15621: EMPTY
15622: LIST
15623: LIST
15624: PUSH
15625: LD_INT 50
15627: PUSH
15628: EMPTY
15629: LIST
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: LIST
15635: PPUSH
15636: CALL_OW 69
15640: ST_TO_ADDR
// ComMoveToArea ( list , ru_leaving_area ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: LD_INT 31
15648: PPUSH
15649: CALL_OW 113
// if list then
15653: LD_VAR 0 1
15657: IFFALSE 15666
// wait ( 0 0$2 ) ;
15659: LD_INT 70
15661: PPUSH
15662: CALL_OW 67
// sol := FilterUnitsInArea ( ru_leaving_area , [ [ f_side , ru ] , [ f_type , unit_human ] ] ) ;
15666: LD_ADDR_VAR 0 2
15670: PUSH
15671: LD_INT 31
15673: PPUSH
15674: LD_INT 22
15676: PUSH
15677: LD_EXP 2
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PUSH
15686: LD_INT 21
15688: PUSH
15689: LD_INT 1
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 70
15704: ST_TO_ADDR
// for un in sol do
15705: LD_ADDR_VAR 0 3
15709: PUSH
15710: LD_VAR 0 2
15714: PUSH
15715: FOR_IN
15716: IFFALSE 15729
// RemoveUnit ( un ) ;
15718: LD_VAR 0 3
15722: PPUSH
15723: CALL_OW 64
15727: GO 15715
15729: POP
15730: POP
// until not list ;
15731: LD_VAR 0 1
15735: NOT
15736: IFFALSE 15598
// end ;
15738: PPOPN 3
15740: END
// function FindLastMohycane ( side ) ; var area , un , list , build , unseen , vysledek ; begin
15741: LD_INT 0
15743: PPUSH
15744: PPUSH
15745: PPUSH
15746: PPUSH
15747: PPUSH
15748: PPUSH
15749: PPUSH
// case side of us :
15750: LD_VAR 0 1
15754: PUSH
15755: LD_EXP 3
15759: DOUBLE
15760: EQUAL
15761: IFTRUE 15765
15763: GO 15776
15765: POP
// area := us_base ; ru :
15766: LD_ADDR_VAR 0 3
15770: PUSH
15771: LD_INT 11
15773: ST_TO_ADDR
15774: GO 15798
15776: LD_EXP 2
15780: DOUBLE
15781: EQUAL
15782: IFTRUE 15786
15784: GO 15797
15786: POP
// area := ru_base ; end ;
15787: LD_ADDR_VAR 0 3
15791: PUSH
15792: LD_INT 12
15794: ST_TO_ADDR
15795: GO 15798
15797: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
15798: LD_ADDR_VAR 0 5
15802: PUSH
15803: LD_INT 22
15805: PUSH
15806: LD_VAR 0 1
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: LD_INT 21
15817: PUSH
15818: LD_INT 1
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PUSH
15825: LD_INT 26
15827: PUSH
15828: LD_INT 1
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 50
15837: PUSH
15838: EMPTY
15839: LIST
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: LIST
15845: LIST
15846: PPUSH
15847: CALL_OW 69
15851: PUSH
15852: LD_INT 22
15854: PUSH
15855: LD_VAR 0 1
15859: PUSH
15860: EMPTY
15861: LIST
15862: LIST
15863: PUSH
15864: LD_INT 2
15866: PUSH
15867: LD_INT 25
15869: PUSH
15870: LD_INT 12
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: PUSH
15877: LD_INT 25
15879: PUSH
15880: LD_INT 15
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 16
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 17
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: LIST
15911: LIST
15912: LIST
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PPUSH
15918: CALL_OW 69
15922: DIFF
15923: ST_TO_ADDR
// if list then
15924: LD_VAR 0 5
15928: IFFALSE 15950
// vysledek := FindMaxSkill ( list , skill_combat ) else
15930: LD_ADDR_VAR 0 8
15934: PUSH
15935: LD_VAR 0 5
15939: PPUSH
15940: LD_INT 1
15942: PPUSH
15943: CALL_OW 433
15947: ST_TO_ADDR
15948: GO 16110
// begin unseen := 0 ;
15950: LD_ADDR_VAR 0 7
15954: PUSH
15955: LD_INT 0
15957: ST_TO_ADDR
// build := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_ok ] ] ) ;
15958: LD_ADDR_VAR 0 6
15962: PUSH
15963: LD_INT 22
15965: PUSH
15966: LD_VAR 0 1
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: PUSH
15975: LD_INT 58
15977: PUSH
15978: EMPTY
15979: LIST
15980: PUSH
15981: LD_INT 50
15983: PUSH
15984: EMPTY
15985: LIST
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: PPUSH
15992: CALL_OW 69
15996: ST_TO_ADDR
// for un in build do
15997: LD_ADDR_VAR 0 4
16001: PUSH
16002: LD_VAR 0 6
16006: PUSH
16007: FOR_IN
16008: IFFALSE 16041
// if not See ( you , un ) then
16010: LD_EXP 1
16014: PPUSH
16015: LD_VAR 0 4
16019: PPUSH
16020: CALL_OW 292
16024: NOT
16025: IFFALSE 16039
// begin unseen := un ;
16027: LD_ADDR_VAR 0 7
16031: PUSH
16032: LD_VAR 0 4
16036: ST_TO_ADDR
// break ;
16037: GO 16041
// end ;
16039: GO 16007
16041: POP
16042: POP
// if ( not unseen ) and build then
16043: LD_VAR 0 7
16047: NOT
16048: PUSH
16049: LD_VAR 0 6
16053: AND
16054: IFFALSE 16070
// unseen := build [ 1 ] ;
16056: LD_ADDR_VAR 0 7
16060: PUSH
16061: LD_VAR 0 6
16065: PUSH
16066: LD_INT 1
16068: ARRAY
16069: ST_TO_ADDR
// if unseen then
16070: LD_VAR 0 7
16074: IFFALSE 16110
// begin PrepareSoldier ( sex_male , 5 ) ;
16076: LD_INT 1
16078: PPUSH
16079: LD_INT 5
16081: PPUSH
16082: CALL_OW 381
// vysledek := CreateHuman ;
16086: LD_ADDR_VAR 0 8
16090: PUSH
16091: CALL_OW 44
16095: ST_TO_ADDR
// PlaceHumanInUnit ( vysledek , unseen ) ;
16096: LD_VAR 0 8
16100: PPUSH
16101: LD_VAR 0 7
16105: PPUSH
16106: CALL_OW 52
// end ; end ; result := vysledek ;
16110: LD_ADDR_VAR 0 2
16114: PUSH
16115: LD_VAR 0 8
16119: ST_TO_ADDR
// end ; end_of_file
16120: LD_VAR 0 2
16124: RET
// export function lets_talking ; begin
16125: LD_INT 0
16127: PPUSH
// DialogueOn ;
16128: CALL_OW 6
// interface_hidden := true ;
16132: LD_ADDR_OWVAR 54
16136: PUSH
16137: LD_INT 1
16139: ST_TO_ADDR
// case camp of 4 :
16140: LD_EXP 7
16144: PUSH
16145: LD_INT 4
16147: DOUBLE
16148: EQUAL
16149: IFTRUE 16153
16151: GO 16160
16153: POP
// us_talking ; 6 :
16154: CALL 17225 0 0
16158: GO 16176
16160: LD_INT 6
16162: DOUBLE
16163: EQUAL
16164: IFTRUE 16168
16166: GO 16175
16168: POP
// ru_talking ; end ;
16169: CALL 16193 0 0
16173: GO 16176
16175: POP
// interface_hidden := false ;
16176: LD_ADDR_OWVAR 54
16180: PUSH
16181: LD_INT 0
16183: ST_TO_ADDR
// DialogueOff ;
16184: CALL_OW 7
// end ;
16188: LD_VAR 0 1
16192: RET
// function ru_talking ; begin
16193: LD_INT 0
16195: PPUSH
// if IsOK ( Burlak ) then
16196: LD_EXP 12
16200: PPUSH
16201: CALL_OW 302
16205: IFFALSE 16228
// begin CenterOnUnits ( Burlak ) ;
16207: LD_EXP 12
16211: PPUSH
16212: CALL_OW 85
// Say ( Burlak , DEnd-Burlak-Bur-1 ) ;
16216: LD_EXP 12
16220: PPUSH
16221: LD_STRING DEnd-Burlak-Bur-1
16223: PPUSH
16224: CALL_OW 88
// end ; if IsOK ( Petrosyan ) then
16228: LD_EXP 16
16232: PPUSH
16233: CALL_OW 302
16237: IFFALSE 16260
// begin CenterOnUnits ( Petrosyan ) ;
16239: LD_EXP 16
16243: PPUSH
16244: CALL_OW 85
// Say ( Petrosyan , DEnd-Burlak-Pty-1 ) ;
16248: LD_EXP 16
16252: PPUSH
16253: LD_STRING DEnd-Burlak-Pty-1
16255: PPUSH
16256: CALL_OW 88
// end ; if IsOK ( Belkov ) then
16260: LD_EXP 17
16264: PPUSH
16265: CALL_OW 302
16269: IFFALSE 16292
// begin CenterOnUnits ( Belkov ) ;
16271: LD_EXP 17
16275: PPUSH
16276: CALL_OW 85
// Say ( Belkov , DEnd-Burlak-Bel-1 ) ;
16280: LD_EXP 17
16284: PPUSH
16285: LD_STRING DEnd-Burlak-Bel-1
16287: PPUSH
16288: CALL_OW 88
// end ; if IsOK ( Kirilenkova ) then
16292: LD_EXP 18
16296: PPUSH
16297: CALL_OW 302
16301: IFFALSE 16324
// begin CenterOnUnits ( Kirilenkova ) ;
16303: LD_EXP 18
16307: PPUSH
16308: CALL_OW 85
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16312: LD_EXP 18
16316: PPUSH
16317: LD_STRING DEnd-Burlak-Kir-1
16319: PPUSH
16320: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
16324: LD_EXP 19
16328: PPUSH
16329: CALL_OW 302
16333: IFFALSE 16356
// begin CenterOnUnits ( Gnyevko ) ;
16335: LD_EXP 19
16339: PPUSH
16340: CALL_OW 85
// Say ( Gnyevko , DEnd-Burlak-Gny-1 ) ;
16344: LD_EXP 19
16348: PPUSH
16349: LD_STRING DEnd-Burlak-Gny-1
16351: PPUSH
16352: CALL_OW 88
// end ; if IsOK ( Gladkov ) then
16356: LD_EXP 20
16360: PPUSH
16361: CALL_OW 302
16365: IFFALSE 16388
// begin CenterOnUnits ( Gladkov ) ;
16367: LD_EXP 20
16371: PPUSH
16372: CALL_OW 85
// Say ( Gladkov , DEnd-Burlak-Gla-1 ) ;
16376: LD_EXP 20
16380: PPUSH
16381: LD_STRING DEnd-Burlak-Gla-1
16383: PPUSH
16384: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
16388: LD_EXP 21
16392: PPUSH
16393: CALL_OW 302
16397: IFFALSE 16420
// begin CenterOnUnits ( Dolgov ) ;
16399: LD_EXP 21
16403: PPUSH
16404: CALL_OW 85
// Say ( Dolgov , DEnd-Burlak-Dol-1 ) ;
16408: LD_EXP 21
16412: PPUSH
16413: LD_STRING DEnd-Burlak-Dol-1
16415: PPUSH
16416: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
16420: LD_EXP 23
16424: PPUSH
16425: CALL_OW 302
16429: IFFALSE 16452
// begin CenterOnUnits ( Kapitsova ) ;
16431: LD_EXP 23
16435: PPUSH
16436: CALL_OW 85
// Say ( Kapitsova , DEnd-Burlak-Kap-1 ) ;
16440: LD_EXP 23
16444: PPUSH
16445: LD_STRING DEnd-Burlak-Kap-1
16447: PPUSH
16448: CALL_OW 88
// end ; if IsOK ( Gleb ) then
16452: LD_EXP 22
16456: PPUSH
16457: CALL_OW 302
16461: IFFALSE 16484
// begin CenterOnUnits ( Gleb ) ;
16463: LD_EXP 22
16467: PPUSH
16468: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
16472: LD_EXP 22
16476: PPUSH
16477: LD_STRING DEnd-JMM-Glb-1
16479: PPUSH
16480: CALL_OW 88
// end ; if IsOK ( Kuzmov ) then
16484: LD_EXP 24
16488: PPUSH
16489: CALL_OW 302
16493: IFFALSE 16516
// begin CenterOnUnits ( Kuzmov ) ;
16495: LD_EXP 24
16499: PPUSH
16500: CALL_OW 85
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16504: LD_EXP 24
16508: PPUSH
16509: LD_STRING DEnd-Burlak-Kuz-1
16511: PPUSH
16512: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
16516: LD_EXP 25
16520: PPUSH
16521: CALL_OW 302
16525: IFFALSE 16548
// begin CenterOnUnits ( Kovalyuk ) ;
16527: LD_EXP 25
16531: PPUSH
16532: CALL_OW 85
// Say ( Kovalyuk , DEnd-Burlak-Kov-1 ) ;
16536: LD_EXP 25
16540: PPUSH
16541: LD_STRING DEnd-Burlak-Kov-1
16543: PPUSH
16544: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
16548: LD_EXP 26
16552: PPUSH
16553: CALL_OW 302
16557: IFFALSE 16580
// begin CenterOnUnits ( Scholtze ) ;
16559: LD_EXP 26
16563: PPUSH
16564: CALL_OW 85
// Say ( Scholtze , DEnd-Burlak-Sch-1 ) ;
16568: LD_EXP 26
16572: PPUSH
16573: LD_STRING DEnd-Burlak-Sch-1
16575: PPUSH
16576: CALL_OW 88
// end ; if IsOK ( Karamazov ) then
16580: LD_EXP 27
16584: PPUSH
16585: CALL_OW 302
16589: IFFALSE 16612
// begin CenterOnUnits ( Karamazov ) ;
16591: LD_EXP 27
16595: PPUSH
16596: CALL_OW 85
// Say ( Karamazov , DEnd-Burlak-Kar-1 ) ;
16600: LD_EXP 27
16604: PPUSH
16605: LD_STRING DEnd-Burlak-Kar-1
16607: PPUSH
16608: CALL_OW 88
// end ; if IsOK ( Titov ) then
16612: LD_EXP 28
16616: PPUSH
16617: CALL_OW 302
16621: IFFALSE 16644
// begin CenterOnUnits ( Titov ) ;
16623: LD_EXP 28
16627: PPUSH
16628: CALL_OW 85
// Say ( Titov , DEnd-Burlak-Tit-1 ) ;
16632: LD_EXP 28
16636: PPUSH
16637: LD_STRING DEnd-Burlak-Tit-1
16639: PPUSH
16640: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
16644: LD_EXP 29
16648: PPUSH
16649: CALL_OW 302
16653: IFFALSE 16676
// begin CenterOnUnits ( Oblukov ) ;
16655: LD_EXP 29
16659: PPUSH
16660: CALL_OW 85
// Say ( Oblukov , DEnd-Burlak-Obl-1 ) ;
16664: LD_EXP 29
16668: PPUSH
16669: LD_STRING DEnd-Burlak-Obl-1
16671: PPUSH
16672: CALL_OW 88
// end ; if IsOK ( Kozlov ) then
16676: LD_EXP 30
16680: PPUSH
16681: CALL_OW 302
16685: IFFALSE 16708
// begin CenterOnUnits ( Kozlov ) ;
16687: LD_EXP 30
16691: PPUSH
16692: CALL_OW 85
// Say ( Kozlov , DEnd-Burlak-Koz-1 ) ;
16696: LD_EXP 30
16700: PPUSH
16701: LD_STRING DEnd-Burlak-Koz-1
16703: PPUSH
16704: CALL_OW 88
// end ; if IsOK ( Petrovova ) then
16708: LD_EXP 31
16712: PPUSH
16713: CALL_OW 302
16717: IFFALSE 16740
// begin CenterOnUnits ( Petrovova ) ;
16719: LD_EXP 31
16723: PPUSH
16724: CALL_OW 85
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16728: LD_EXP 31
16732: PPUSH
16733: LD_STRING DEnd-Burlak-Ptr-1
16735: PPUSH
16736: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
16740: LD_EXP 32
16744: PPUSH
16745: CALL_OW 302
16749: IFFALSE 16772
// begin CenterOnUnits ( Bystrov ) ;
16751: LD_EXP 32
16755: PPUSH
16756: CALL_OW 85
// Say ( Bystrov , DEnd-Burlak-Bys-1 ) ;
16760: LD_EXP 32
16764: PPUSH
16765: LD_STRING DEnd-Burlak-Bys-1
16767: PPUSH
16768: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
16772: LD_EXP 33
16776: PPUSH
16777: CALL_OW 302
16781: IFFALSE 16804
// begin CenterOnUnits ( Lipshchin ) ;
16783: LD_EXP 33
16787: PPUSH
16788: CALL_OW 85
// Say ( Lipshchin , DEnd-Burlak-Lip-1 ) ;
16792: LD_EXP 33
16796: PPUSH
16797: LD_STRING DEnd-Burlak-Lip-1
16799: PPUSH
16800: CALL_OW 88
// end ; if IsOK ( Fadeev ) then
16804: LD_EXP 34
16808: PPUSH
16809: CALL_OW 302
16813: IFFALSE 16836
// begin CenterOnUnits ( Fadeev ) ;
16815: LD_EXP 34
16819: PPUSH
16820: CALL_OW 85
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16824: LD_EXP 34
16828: PPUSH
16829: LD_STRING DEnd-Burlak-Fad-1
16831: PPUSH
16832: CALL_OW 88
// end ; if IsOK ( MacMillan ) then
16836: LD_EXP 13
16840: PPUSH
16841: CALL_OW 302
16845: IFFALSE 16868
// begin CenterOnUnits ( MacMillan ) ;
16847: LD_EXP 13
16851: PPUSH
16852: CALL_OW 85
// Say ( MacMillan , DEnd-Burlak-JMM-1 ) ;
16856: LD_EXP 13
16860: PPUSH
16861: LD_STRING DEnd-Burlak-JMM-1
16863: PPUSH
16864: CALL_OW 88
// end ; if IsOK ( Lisa ) then
16868: LD_EXP 46
16872: PPUSH
16873: CALL_OW 302
16877: IFFALSE 16900
// begin CenterOnUnits ( Lisa ) ;
16879: LD_EXP 46
16883: PPUSH
16884: CALL_OW 85
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16888: LD_EXP 46
16892: PPUSH
16893: LD_STRING DEnd-Burlak-Lisa-1
16895: PPUSH
16896: CALL_OW 88
// end ; if IsOK ( Joan ) then
16900: LD_EXP 45
16904: PPUSH
16905: CALL_OW 302
16909: IFFALSE 16932
// begin CenterOnUnits ( Joan ) ;
16911: LD_EXP 45
16915: PPUSH
16916: CALL_OW 85
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
16920: LD_EXP 45
16924: PPUSH
16925: LD_STRING DEnd-Burlak-Joan-1
16927: PPUSH
16928: CALL_OW 88
// end ; if IsOK ( Frank ) then
16932: LD_EXP 42
16936: PPUSH
16937: CALL_OW 302
16941: IFFALSE 16964
// begin CenterOnUnits ( Frank ) ;
16943: LD_EXP 42
16947: PPUSH
16948: CALL_OW 85
// Say ( Frank , DEnd-Burlak-Frank-1 ) ;
16952: LD_EXP 42
16956: PPUSH
16957: LD_STRING DEnd-Burlak-Frank-1
16959: PPUSH
16960: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
16964: LD_EXP 39
16968: PPUSH
16969: CALL_OW 302
16973: IFFALSE 16996
// begin CenterOnUnits ( Cyrus ) ;
16975: LD_EXP 39
16979: PPUSH
16980: CALL_OW 85
// Say ( Cyrus , DEnd-Burlak-Cyrus-1 ) ;
16984: LD_EXP 39
16988: PPUSH
16989: LD_STRING DEnd-Burlak-Cyrus-1
16991: PPUSH
16992: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
16996: LD_EXP 41
17000: PPUSH
17001: CALL_OW 302
17005: IFFALSE 17028
// begin CenterOnUnits ( Donaldson ) ;
17007: LD_EXP 41
17011: PPUSH
17012: CALL_OW 85
// Say ( Donaldson , DEnd-Burlak-Don-1 ) ;
17016: LD_EXP 41
17020: PPUSH
17021: LD_STRING DEnd-Burlak-Don-1
17023: PPUSH
17024: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17028: LD_EXP 35
17032: PPUSH
17033: CALL_OW 302
17037: IFFALSE 17060
// begin CenterOnUnits ( Bobby ) ;
17039: LD_EXP 35
17043: PPUSH
17044: CALL_OW 85
// Say ( Bobby , DEnd-Burlak-Bobby-1 ) ;
17048: LD_EXP 35
17052: PPUSH
17053: LD_STRING DEnd-Burlak-Bobby-1
17055: PPUSH
17056: CALL_OW 88
// end ; if IsOK ( Denis ) then
17060: LD_EXP 40
17064: PPUSH
17065: CALL_OW 302
17069: IFFALSE 17092
// begin CenterOnUnits ( Denis ) ;
17071: LD_EXP 40
17075: PPUSH
17076: CALL_OW 85
// Say ( Denis , DEnd-Burlak-Den-1 ) ;
17080: LD_EXP 40
17084: PPUSH
17085: LD_STRING DEnd-Burlak-Den-1
17087: PPUSH
17088: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17092: LD_EXP 44
17096: PPUSH
17097: CALL_OW 302
17101: IFFALSE 17124
// begin CenterOnUnits ( Gladstone ) ;
17103: LD_EXP 44
17107: PPUSH
17108: CALL_OW 85
// Say ( Gladstone , DEnd-Burlak-Glad-1 ) ;
17112: LD_EXP 44
17116: PPUSH
17117: LD_STRING DEnd-Burlak-Glad-1
17119: PPUSH
17120: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17124: LD_EXP 50
17128: PPUSH
17129: CALL_OW 302
17133: IFFALSE 17156
// begin CenterOnUnits ( Yamoko ) ;
17135: LD_EXP 50
17139: PPUSH
17140: CALL_OW 85
// Say ( Yamoko , DEnd-Burlak-Yam-1 ) ;
17144: LD_EXP 50
17148: PPUSH
17149: LD_STRING DEnd-Burlak-Yam-1
17151: PPUSH
17152: CALL_OW 88
// end ; if IsOK ( Brown ) then
17156: LD_EXP 36
17160: PPUSH
17161: CALL_OW 302
17165: IFFALSE 17188
// begin CenterOnUnits ( Brown ) ;
17167: LD_EXP 36
17171: PPUSH
17172: CALL_OW 85
// Say ( Brown , DEnd-Burlak-Brown-1 ) ;
17176: LD_EXP 36
17180: PPUSH
17181: LD_STRING DEnd-Burlak-Brown-1
17183: PPUSH
17184: CALL_OW 88
// end ; if IsOK ( Roth ) then
17188: LD_EXP 14
17192: PPUSH
17193: CALL_OW 302
17197: IFFALSE 17220
// begin CenterOnUnits ( Roth ) ;
17199: LD_EXP 14
17203: PPUSH
17204: CALL_OW 85
// Say ( Roth , DEnd-Burlak-Roth-1 ) ;
17208: LD_EXP 14
17212: PPUSH
17213: LD_STRING DEnd-Burlak-Roth-1
17215: PPUSH
17216: CALL_OW 88
// end ; end ;
17220: LD_VAR 0 1
17224: RET
// function us_talking ; begin
17225: LD_INT 0
17227: PPUSH
// if IsOK ( MacMillan ) then
17228: LD_EXP 13
17232: PPUSH
17233: CALL_OW 302
17237: IFFALSE 17260
// begin CenterOnUnits ( MacMillan ) ;
17239: LD_EXP 13
17243: PPUSH
17244: CALL_OW 85
// Say ( MacMillan , DEnd-JMM-JMM-1 ) ;
17248: LD_EXP 13
17252: PPUSH
17253: LD_STRING DEnd-JMM-JMM-1
17255: PPUSH
17256: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17260: LD_EXP 46
17264: PPUSH
17265: CALL_OW 302
17269: IFFALSE 17292
// begin CenterOnUnits ( Lisa ) ;
17271: LD_EXP 46
17275: PPUSH
17276: CALL_OW 85
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17280: LD_EXP 46
17284: PPUSH
17285: LD_STRING DEnd-JMM-Lisa-1
17287: PPUSH
17288: CALL_OW 88
// end ; if IsOK ( Joan ) then
17292: LD_EXP 45
17296: PPUSH
17297: CALL_OW 302
17301: IFFALSE 17324
// begin CenterOnUnits ( Joan ) ;
17303: LD_EXP 45
17307: PPUSH
17308: CALL_OW 85
// Say ( Joan , DEnd-JMM-Joan-1 ) ;
17312: LD_EXP 45
17316: PPUSH
17317: LD_STRING DEnd-JMM-Joan-1
17319: PPUSH
17320: CALL_OW 88
// end ; if IsOK ( Frank ) then
17324: LD_EXP 42
17328: PPUSH
17329: CALL_OW 302
17333: IFFALSE 17356
// begin CenterOnUnits ( Frank ) ;
17335: LD_EXP 42
17339: PPUSH
17340: CALL_OW 85
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17344: LD_EXP 42
17348: PPUSH
17349: LD_STRING DEnd-JMM-Frank-1
17351: PPUSH
17352: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17356: LD_EXP 39
17360: PPUSH
17361: CALL_OW 302
17365: IFFALSE 17388
// begin CenterOnUnits ( Cyrus ) ;
17367: LD_EXP 39
17371: PPUSH
17372: CALL_OW 85
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17376: LD_EXP 39
17380: PPUSH
17381: LD_STRING DEnd-JMM-Cyrus-1
17383: PPUSH
17384: CALL_OW 88
// end ; if IsOK ( Cornell ) then
17388: LD_EXP 37
17392: PPUSH
17393: CALL_OW 302
17397: IFFALSE 17420
// begin CenterOnUnits ( Cornell ) ;
17399: LD_EXP 37
17403: PPUSH
17404: CALL_OW 85
// Say ( Cornell , DEnd-JMM-Corn-1 ) ;
17408: LD_EXP 37
17412: PPUSH
17413: LD_STRING DEnd-JMM-Corn-1
17415: PPUSH
17416: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17420: LD_EXP 41
17424: PPUSH
17425: CALL_OW 302
17429: IFFALSE 17452
// begin CenterOnUnits ( Donaldson ) ;
17431: LD_EXP 41
17435: PPUSH
17436: CALL_OW 85
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17440: LD_EXP 41
17444: PPUSH
17445: LD_STRING DEnd-JMM-Don-1
17447: PPUSH
17448: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17452: LD_EXP 35
17456: PPUSH
17457: CALL_OW 302
17461: IFFALSE 17484
// begin CenterOnUnits ( Bobby ) ;
17463: LD_EXP 35
17467: PPUSH
17468: CALL_OW 85
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17472: LD_EXP 35
17476: PPUSH
17477: LD_STRING DEnd-JMM-Bobby-1
17479: PPUSH
17480: CALL_OW 88
// end ; if IsOK ( Denis ) then
17484: LD_EXP 40
17488: PPUSH
17489: CALL_OW 302
17493: IFFALSE 17516
// begin CenterOnUnits ( Denis ) ;
17495: LD_EXP 40
17499: PPUSH
17500: CALL_OW 85
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17504: LD_EXP 40
17508: PPUSH
17509: LD_STRING DEnd-JMM-Den-1
17511: PPUSH
17512: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17516: LD_EXP 44
17520: PPUSH
17521: CALL_OW 302
17525: IFFALSE 17548
// begin CenterOnUnits ( Gladstone ) ;
17527: LD_EXP 44
17531: PPUSH
17532: CALL_OW 85
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17536: LD_EXP 44
17540: PPUSH
17541: LD_STRING DEnd-JMM-Glad-1
17543: PPUSH
17544: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17548: LD_EXP 50
17552: PPUSH
17553: CALL_OW 302
17557: IFFALSE 17580
// begin CenterOnUnits ( Yamoko ) ;
17559: LD_EXP 50
17563: PPUSH
17564: CALL_OW 85
// Say ( Yamoko , DEnd-JMM-Yam-1 ) ;
17568: LD_EXP 50
17572: PPUSH
17573: LD_STRING DEnd-JMM-Yam-1
17575: PPUSH
17576: CALL_OW 88
// end ; if IsOK ( Brown ) then
17580: LD_EXP 36
17584: PPUSH
17585: CALL_OW 302
17589: IFFALSE 17612
// begin CenterOnUnits ( Brown ) ;
17591: LD_EXP 36
17595: PPUSH
17596: CALL_OW 85
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17600: LD_EXP 36
17604: PPUSH
17605: LD_STRING DEnd-JMM-Brown-1
17607: PPUSH
17608: CALL_OW 88
// end ; if IsOK ( Roth ) then
17612: LD_EXP 14
17616: PPUSH
17617: CALL_OW 302
17621: IFFALSE 17644
// begin CenterOnUnits ( Roth ) ;
17623: LD_EXP 14
17627: PPUSH
17628: CALL_OW 85
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
17632: LD_EXP 14
17636: PPUSH
17637: LD_STRING DEnd-JMM-Roth-1
17639: PPUSH
17640: CALL_OW 88
// end ; if IsOK ( Connie ) then
17644: LD_EXP 38
17648: PPUSH
17649: CALL_OW 302
17653: IFFALSE 17676
// begin CenterOnUnits ( Connie ) ;
17655: LD_EXP 38
17659: PPUSH
17660: CALL_OW 85
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17664: LD_EXP 38
17668: PPUSH
17669: LD_STRING DEnd-JMM-Con-1
17671: PPUSH
17672: CALL_OW 88
// end ; if IsOK ( Gary ) then
17676: LD_EXP 43
17680: PPUSH
17681: CALL_OW 302
17685: IFFALSE 17708
// begin CenterOnUnits ( Gary ) ;
17687: LD_EXP 43
17691: PPUSH
17692: CALL_OW 85
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17696: LD_EXP 43
17700: PPUSH
17701: LD_STRING DEnd-JMM-Gary-1
17703: PPUSH
17704: CALL_OW 88
// end ; if IsOK ( Simms ) then
17708: LD_EXP 48
17712: PPUSH
17713: CALL_OW 302
17717: IFFALSE 17740
// begin CenterOnUnits ( Simms ) ;
17719: LD_EXP 48
17723: PPUSH
17724: CALL_OW 85
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17728: LD_EXP 48
17732: PPUSH
17733: LD_STRING DEnd-JMM-Sim-1
17735: PPUSH
17736: CALL_OW 88
// end ; if IsOK ( VanHouten ) then
17740: LD_EXP 49
17744: PPUSH
17745: CALL_OW 302
17749: IFFALSE 17772
// begin CenterOnUnits ( VanHouten ) ;
17751: LD_EXP 49
17755: PPUSH
17756: CALL_OW 85
// Say ( VanHouten , DEnd-JMM-VanH-1 ) ;
17760: LD_EXP 49
17764: PPUSH
17765: LD_STRING DEnd-JMM-VanH-1
17767: PPUSH
17768: CALL_OW 88
// end ; if IsOK ( Burlak ) then
17772: LD_EXP 12
17776: PPUSH
17777: CALL_OW 302
17781: IFFALSE 17804
// begin CenterOnUnits ( Burlak ) ;
17783: LD_EXP 12
17787: PPUSH
17788: CALL_OW 85
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17792: LD_EXP 12
17796: PPUSH
17797: LD_STRING DEnd-JMM-Bur-1
17799: PPUSH
17800: CALL_OW 88
// end ; if IsOK ( Belkov ) then
17804: LD_EXP 17
17808: PPUSH
17809: CALL_OW 302
17813: IFFALSE 17836
// begin CenterOnUnits ( Belkov ) ;
17815: LD_EXP 17
17819: PPUSH
17820: CALL_OW 85
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17824: LD_EXP 17
17828: PPUSH
17829: LD_STRING DEnd-JMM-Bel-1
17831: PPUSH
17832: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
17836: LD_EXP 19
17840: PPUSH
17841: CALL_OW 302
17845: IFFALSE 17868
// begin CenterOnUnits ( Gnyevko ) ;
17847: LD_EXP 19
17851: PPUSH
17852: CALL_OW 85
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17856: LD_EXP 19
17860: PPUSH
17861: LD_STRING DEnd-JMM-Gny-1
17863: PPUSH
17864: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
17868: LD_EXP 21
17872: PPUSH
17873: CALL_OW 302
17877: IFFALSE 17900
// begin CenterOnUnits ( Dolgov ) ;
17879: LD_EXP 21
17883: PPUSH
17884: CALL_OW 85
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17888: LD_EXP 21
17892: PPUSH
17893: LD_STRING DEnd-JMM-Dol-1
17895: PPUSH
17896: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
17900: LD_EXP 23
17904: PPUSH
17905: CALL_OW 302
17909: IFFALSE 17932
// begin CenterOnUnits ( Kapitsova ) ;
17911: LD_EXP 23
17915: PPUSH
17916: CALL_OW 85
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17920: LD_EXP 23
17924: PPUSH
17925: LD_STRING DEnd-JMM-Kap-1
17927: PPUSH
17928: CALL_OW 88
// end ; if IsOK ( Gleb ) then
17932: LD_EXP 22
17936: PPUSH
17937: CALL_OW 302
17941: IFFALSE 17964
// begin CenterOnUnits ( Gleb ) ;
17943: LD_EXP 22
17947: PPUSH
17948: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
17952: LD_EXP 22
17956: PPUSH
17957: LD_STRING DEnd-JMM-Glb-1
17959: PPUSH
17960: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
17964: LD_EXP 25
17968: PPUSH
17969: CALL_OW 302
17973: IFFALSE 17996
// begin CenterOnUnits ( Kovalyuk ) ;
17975: LD_EXP 25
17979: PPUSH
17980: CALL_OW 85
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17984: LD_EXP 25
17988: PPUSH
17989: LD_STRING DEnd-JMM-Kov-1
17991: PPUSH
17992: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
17996: LD_EXP 26
18000: PPUSH
18001: CALL_OW 302
18005: IFFALSE 18028
// begin CenterOnUnits ( Scholtze ) ;
18007: LD_EXP 26
18011: PPUSH
18012: CALL_OW 85
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18016: LD_EXP 26
18020: PPUSH
18021: LD_STRING DEnd-JMM-Sch-1
18023: PPUSH
18024: CALL_OW 88
// end ; if IsOK ( Titov ) then
18028: LD_EXP 28
18032: PPUSH
18033: CALL_OW 302
18037: IFFALSE 18060
// begin CenterOnUnits ( Titov ) ;
18039: LD_EXP 28
18043: PPUSH
18044: CALL_OW 85
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18048: LD_EXP 28
18052: PPUSH
18053: LD_STRING DEnd-JMM-Tit-1
18055: PPUSH
18056: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
18060: LD_EXP 29
18064: PPUSH
18065: CALL_OW 302
18069: IFFALSE 18092
// begin CenterOnUnits ( Oblukov ) ;
18071: LD_EXP 29
18075: PPUSH
18076: CALL_OW 85
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18080: LD_EXP 29
18084: PPUSH
18085: LD_STRING DEnd-JMM-Obl-1
18087: PPUSH
18088: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
18092: LD_EXP 32
18096: PPUSH
18097: CALL_OW 302
18101: IFFALSE 18124
// begin CenterOnUnits ( Bystrov ) ;
18103: LD_EXP 32
18107: PPUSH
18108: CALL_OW 85
// Say ( Bystrov , DEnd-JMM-Bys-1 ) ;
18112: LD_EXP 32
18116: PPUSH
18117: LD_STRING DEnd-JMM-Bys-1
18119: PPUSH
18120: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
18124: LD_EXP 33
18128: PPUSH
18129: CALL_OW 302
18133: IFFALSE 18156
// begin CenterOnUnits ( Lipshchin ) ;
18135: LD_EXP 33
18139: PPUSH
18140: CALL_OW 85
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18144: LD_EXP 33
18148: PPUSH
18149: LD_STRING DEnd-JMM-Lip-1
18151: PPUSH
18152: CALL_OW 88
// end ; end ; end_of_file
18156: LD_VAR 0 1
18160: RET
// var id_reg , id_def ; var BaseArea , DefendArea , Heal ; var docs ; var healing_un , wounded_un ; var central_base , mc_id_defend ; export function init_defend ; var side ; begin
18161: LD_INT 0
18163: PPUSH
18164: PPUSH
// BaseArea := [ us_base , ar_base , ru_base ] ;
18165: LD_ADDR_LOC 14
18169: PUSH
18170: LD_INT 11
18172: PUSH
18173: LD_INT 13
18175: PUSH
18176: LD_INT 12
18178: PUSH
18179: EMPTY
18180: LIST
18181: LIST
18182: LIST
18183: ST_TO_ADDR
// DefendArea := [ us_defend_base , ar_defend_base , ru_base ] ;
18184: LD_ADDR_LOC 15
18188: PUSH
18189: LD_INT 36
18191: PUSH
18192: LD_INT 37
18194: PUSH
18195: LD_INT 12
18197: PUSH
18198: EMPTY
18199: LIST
18200: LIST
18201: LIST
18202: ST_TO_ADDR
// Heal := [ us_heal , ar_heal , ru_heal ] ;
18203: LD_ADDR_LOC 16
18207: PUSH
18208: LD_INT 16
18210: PUSH
18211: LD_INT 14
18213: PUSH
18214: LD_INT 15
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: LIST
18221: ST_TO_ADDR
// docs := [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
18222: LD_ADDR_LOC 17
18226: PUSH
18227: EMPTY
18228: PUSH
18229: EMPTY
18230: PUSH
18231: EMPTY
18232: PUSH
18233: EMPTY
18234: PUSH
18235: EMPTY
18236: PUSH
18237: EMPTY
18238: PUSH
18239: EMPTY
18240: PUSH
18241: EMPTY
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: ST_TO_ADDR
// central_base := [ [ 44 , 62 ] , [ 251 , 193 ] , [ 177 , 72 ] ] ;
18253: LD_ADDR_LOC 20
18257: PUSH
18258: LD_INT 44
18260: PUSH
18261: LD_INT 62
18263: PUSH
18264: EMPTY
18265: LIST
18266: LIST
18267: PUSH
18268: LD_INT 251
18270: PUSH
18271: LD_INT 193
18273: PUSH
18274: EMPTY
18275: LIST
18276: LIST
18277: PUSH
18278: LD_INT 177
18280: PUSH
18281: LD_INT 72
18283: PUSH
18284: EMPTY
18285: LIST
18286: LIST
18287: PUSH
18288: EMPTY
18289: LIST
18290: LIST
18291: LIST
18292: ST_TO_ADDR
// healing_un := [ ] ;
18293: LD_ADDR_LOC 18
18297: PUSH
18298: EMPTY
18299: ST_TO_ADDR
// wounded_un := [ ] ;
18300: LD_ADDR_LOC 19
18304: PUSH
18305: EMPTY
18306: ST_TO_ADDR
// mc_id_defend := false ;
18307: LD_ADDR_LOC 21
18311: PUSH
18312: LD_INT 0
18314: ST_TO_ADDR
// start_defend ;
18315: CALL 18575 0 0
// end ;
18319: LD_VAR 0 1
18323: RET
// function prepare_defend ( side ) ; var seznam , def_buildings , def_vehicles , def_peoples ; begin
18324: LD_INT 0
18326: PPUSH
18327: PPUSH
18328: PPUSH
18329: PPUSH
18330: PPUSH
// def_buildings := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
18331: LD_ADDR_VAR 0 4
18335: PUSH
18336: LD_INT 22
18338: PUSH
18339: LD_VAR 0 1
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: PUSH
18348: LD_INT 2
18350: PUSH
18351: LD_INT 30
18353: PUSH
18354: LD_INT 32
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: PUSH
18361: LD_INT 30
18363: PUSH
18364: LD_INT 31
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: LIST
18375: PUSH
18376: EMPTY
18377: LIST
18378: LIST
18379: PPUSH
18380: CALL_OW 69
18384: ST_TO_ADDR
// def_peoples := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_class , class_scientistic ] ] ) ;
18385: LD_ADDR_VAR 0 6
18389: PUSH
18390: LD_INT 22
18392: PUSH
18393: LD_VAR 0 1
18397: PUSH
18398: EMPTY
18399: LIST
18400: LIST
18401: PUSH
18402: LD_INT 21
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PUSH
18412: LD_INT 3
18414: PUSH
18415: LD_INT 25
18417: PUSH
18418: LD_INT 4
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: LIST
18429: LIST
18430: PPUSH
18431: CALL_OW 69
18435: ST_TO_ADDR
// def_vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , f_not , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) ;
18436: LD_ADDR_VAR 0 5
18440: PUSH
18441: LD_INT 22
18443: PUSH
18444: LD_VAR 0 1
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 21
18455: PUSH
18456: LD_INT 2
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: LD_INT 3
18465: PUSH
18466: LD_INT 2
18468: PUSH
18469: LD_INT 34
18471: PUSH
18472: LD_INT 12
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PUSH
18479: LD_INT 34
18481: PUSH
18482: LD_INT 13
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: PUSH
18489: LD_INT 34
18491: PUSH
18492: LD_INT 32
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 34
18501: PUSH
18502: LD_INT 51
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: LD_INT 34
18511: PUSH
18512: LD_INT 52
18514: PUSH
18515: EMPTY
18516: LIST
18517: LIST
18518: PUSH
18519: EMPTY
18520: LIST
18521: LIST
18522: LIST
18523: LIST
18524: LIST
18525: LIST
18526: PUSH
18527: EMPTY
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: PPUSH
18533: CALL_OW 69
18537: ST_TO_ADDR
// seznam := def_buildings ^ def_peoples ^ def_vehicles ;
18538: LD_ADDR_VAR 0 3
18542: PUSH
18543: LD_VAR 0 4
18547: PUSH
18548: LD_VAR 0 6
18552: ADD
18553: PUSH
18554: LD_VAR 0 5
18558: ADD
18559: ST_TO_ADDR
// result := seznam ;
18560: LD_ADDR_VAR 0 2
18564: PUSH
18565: LD_VAR 0 3
18569: ST_TO_ADDR
// end ;
18570: LD_VAR 0 2
18574: RET
// function start_defend ; var side ; begin
18575: LD_INT 0
18577: PPUSH
18578: PPUSH
// id_reg := [ ] ;
18579: LD_ADDR_LOC 12
18583: PUSH
18584: EMPTY
18585: ST_TO_ADDR
// id_def := [ ] ;
18586: LD_ADDR_LOC 13
18590: PUSH
18591: EMPTY
18592: ST_TO_ADDR
// for side = 1 to 8 do
18593: LD_ADDR_VAR 0 2
18597: PUSH
18598: DOUBLE
18599: LD_INT 1
18601: DEC
18602: ST_TO_ADDR
18603: LD_INT 8
18605: PUSH
18606: FOR_TO
18607: IFFALSE 18863
// if side in cpu_list then
18609: LD_VAR 0 2
18613: PUSH
18614: LD_EXP 8
18618: IN
18619: IFFALSE 18827
// begin id_reg := id_reg ^ McRegistry ( 1 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , BaseArea [ side ] ] , [ mc_reg_area_to_protect , BaseArea [ side ] ] , [ mc_reg_units_to_protect , prepare_defend ( side ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
18621: LD_ADDR_LOC 12
18625: PUSH
18626: LD_LOC 12
18630: PUSH
18631: LD_INT 1
18633: PPUSH
18634: LD_INT 1
18636: PUSH
18637: LD_INT 35
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: PUSH
18644: LD_INT 5
18646: PUSH
18647: LD_INT 140
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PUSH
18654: LD_INT 2
18656: PUSH
18657: LD_LOC 14
18661: PUSH
18662: LD_VAR 0 2
18666: ARRAY
18667: PUSH
18668: EMPTY
18669: LIST
18670: LIST
18671: PUSH
18672: LD_INT 3
18674: PUSH
18675: LD_LOC 14
18679: PUSH
18680: LD_VAR 0 2
18684: ARRAY
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PUSH
18690: LD_INT 4
18692: PUSH
18693: LD_VAR 0 2
18697: PPUSH
18698: CALL 18324 0 1
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: PUSH
18707: LD_INT 8
18709: PUSH
18710: LD_INT 7
18712: NEG
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: LIST
18718: LIST
18719: LIST
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL_OW 399
18727: ADD
18728: ST_TO_ADDR
// id_def := id_def ^ McDefend ( 200 , id_reg , prepare_defend ( side ) , [ [ mc_def_advantage , 5000 ] , [ mc_area_dont_leave , BaseArea [ side ] ] , [ mc_retreat_area_people , Heal [ side ] ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
18729: LD_ADDR_LOC 13
18733: PUSH
18734: LD_LOC 13
18738: PUSH
18739: LD_INT 200
18741: PPUSH
18742: LD_LOC 12
18746: PPUSH
18747: LD_VAR 0 2
18751: PPUSH
18752: CALL 18324 0 1
18756: PPUSH
18757: LD_INT 1
18759: PUSH
18760: LD_INT 5000
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 2
18769: PUSH
18770: LD_LOC 14
18774: PUSH
18775: LD_VAR 0 2
18779: ARRAY
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: LD_INT 7
18787: PUSH
18788: LD_LOC 16
18792: PUSH
18793: LD_VAR 0 2
18797: ARRAY
18798: PUSH
18799: EMPTY
18800: LIST
18801: LIST
18802: PUSH
18803: LD_INT 5
18805: PUSH
18806: LD_INT 600
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: PPUSH
18819: CALL_OW 401
18823: ADD
18824: ST_TO_ADDR
// end else
18825: GO 18861
// begin id_reg := id_reg ^ [ 0 ] ;
18827: LD_ADDR_LOC 12
18831: PUSH
18832: LD_LOC 12
18836: PUSH
18837: LD_INT 0
18839: PUSH
18840: EMPTY
18841: LIST
18842: ADD
18843: ST_TO_ADDR
// id_def := id_reg ^ [ 0 ] ;
18844: LD_ADDR_LOC 13
18848: PUSH
18849: LD_LOC 12
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: ADD
18860: ST_TO_ADDR
// end ;
18861: GO 18606
18863: POP
18864: POP
// end ;
18865: LD_VAR 0 1
18869: RET
// on McRegistryResultChanges ( mcid , n , s ) do var side ;
18870: LD_INT 0
18872: PPUSH
// begin for side = 1 to id_reg do
18873: LD_ADDR_VAR 0 4
18877: PUSH
18878: DOUBLE
18879: LD_INT 1
18881: DEC
18882: ST_TO_ADDR
18883: LD_LOC 12
18887: PUSH
18888: FOR_TO
18889: IFFALSE 18941
// if id_reg [ side ] = mcid then
18891: LD_LOC 12
18895: PUSH
18896: LD_VAR 0 4
18900: ARRAY
18901: PUSH
18902: LD_VAR 0 1
18906: EQUAL
18907: IFFALSE 18939
// begin AddMcUnits ( mcid , prepare_defend ( side ) ) ;
18909: LD_VAR 0 1
18913: PPUSH
18914: LD_VAR 0 4
18918: PPUSH
18919: CALL 18324 0 1
18923: PPUSH
18924: CALL_OW 390
// SendForces ( side ) ;
18928: LD_VAR 0 4
18932: PPUSH
18933: CALL 20086 0 1
// break ;
18937: GO 18941
// end ;
18939: GO 18888
18941: POP
18942: POP
// end ;
18943: PPOPN 4
18945: END
// every 0 0$7.7 do var side , list ;
18946: GO 18948
18948: DISABLE
18949: LD_INT 0
18951: PPUSH
18952: PPUSH
// begin list := [ ] ;
18953: LD_ADDR_VAR 0 2
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// for side = 1 to 8 do
18960: LD_ADDR_VAR 0 1
18964: PUSH
18965: DOUBLE
18966: LD_INT 1
18968: DEC
18969: ST_TO_ADDR
18970: LD_INT 8
18972: PUSH
18973: FOR_TO
18974: IFFALSE 19119
// if ( not side in cpu_list ) and id_reg [ side ] then
18976: LD_VAR 0 1
18980: PUSH
18981: LD_EXP 8
18985: IN
18986: NOT
18987: PUSH
18988: LD_LOC 12
18992: PUSH
18993: LD_VAR 0 1
18997: ARRAY
18998: AND
18999: IFFALSE 19117
// begin KillMc ( id_reg [ side ] ) ;
19001: LD_LOC 12
19005: PUSH
19006: LD_VAR 0 1
19010: ARRAY
19011: PPUSH
19012: CALL_OW 387
// id_reg := Delete ( id_reg , side ) ;
19016: LD_ADDR_LOC 12
19020: PUSH
19021: LD_LOC 12
19025: PPUSH
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 3
19035: ST_TO_ADDR
// id_reg := Insert ( id_reg , side , 0 ) ;
19036: LD_ADDR_LOC 12
19040: PUSH
19041: LD_LOC 12
19045: PPUSH
19046: LD_VAR 0 1
19050: PPUSH
19051: LD_INT 0
19053: PPUSH
19054: CALL_OW 2
19058: ST_TO_ADDR
// KillMc ( id_def [ side ] ) ;
19059: LD_LOC 13
19063: PUSH
19064: LD_VAR 0 1
19068: ARRAY
19069: PPUSH
19070: CALL_OW 387
// id_def := Delete ( id_def , side ) ;
19074: LD_ADDR_LOC 13
19078: PUSH
19079: LD_LOC 13
19083: PPUSH
19084: LD_VAR 0 1
19088: PPUSH
19089: CALL_OW 3
19093: ST_TO_ADDR
// id_def := Insert ( id_def , side , 0 ) ;
19094: LD_ADDR_LOC 13
19098: PUSH
19099: LD_LOC 13
19103: PPUSH
19104: LD_VAR 0 1
19108: PPUSH
19109: LD_INT 0
19111: PPUSH
19112: CALL_OW 2
19116: ST_TO_ADDR
// end ;
19117: GO 18973
19119: POP
19120: POP
// enable ;
19121: ENABLE
// end ;
19122: PPOPN 2
19124: END
// every 0 0$5.3 do var side , sci , list , wounded , un ;
19125: GO 19127
19127: DISABLE
19128: LD_INT 0
19130: PPUSH
19131: PPUSH
19132: PPUSH
19133: PPUSH
19134: PPUSH
// begin for side = 1 to 8 do
19135: LD_ADDR_VAR 0 1
19139: PUSH
19140: DOUBLE
19141: LD_INT 1
19143: DEC
19144: ST_TO_ADDR
19145: LD_INT 8
19147: PUSH
19148: FOR_TO
19149: IFFALSE 19583
// if side in cpu_list then
19151: LD_VAR 0 1
19155: PUSH
19156: LD_EXP 8
19160: IN
19161: IFFALSE 19581
// begin wounded := FilterUnitsInArea ( Heal [ side ] , [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 1000 ] ] ) ;
19163: LD_ADDR_VAR 0 4
19167: PUSH
19168: LD_LOC 16
19172: PUSH
19173: LD_VAR 0 1
19177: ARRAY
19178: PPUSH
19179: LD_INT 22
19181: PUSH
19182: LD_VAR 0 1
19186: PUSH
19187: EMPTY
19188: LIST
19189: LIST
19190: PUSH
19191: LD_INT 21
19193: PUSH
19194: LD_INT 1
19196: PUSH
19197: EMPTY
19198: LIST
19199: LIST
19200: PUSH
19201: LD_INT 3
19203: PUSH
19204: LD_INT 24
19206: PUSH
19207: LD_INT 1000
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: LIST
19218: LIST
19219: PPUSH
19220: CALL_OW 70
19224: ST_TO_ADDR
// if wounded then
19225: LD_VAR 0 4
19229: IFFALSE 19439
// begin if not docs [ side ] then
19231: LD_LOC 17
19235: PUSH
19236: LD_VAR 0 1
19240: ARRAY
19241: NOT
19242: IFFALSE 19406
// begin sci := request_people ( side , class_scientistic , 5 ) ;
19244: LD_ADDR_VAR 0 2
19248: PUSH
19249: LD_VAR 0 1
19253: PPUSH
19254: LD_INT 4
19256: PPUSH
19257: LD_INT 5
19259: PPUSH
19260: CALL 26408 0 3
19264: ST_TO_ADDR
// docs := Delete ( docs , side ) ;
19265: LD_ADDR_LOC 17
19269: PUSH
19270: LD_LOC 17
19274: PPUSH
19275: LD_VAR 0 1
19279: PPUSH
19280: CALL_OW 3
19284: ST_TO_ADDR
// docs := Insert ( docs , side , sci ) ;
19285: LD_ADDR_LOC 17
19289: PUSH
19290: LD_LOC 17
19294: PPUSH
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 2
19304: PPUSH
19305: CALL_OW 2
19309: ST_TO_ADDR
// list := reserved_people [ side ] ^ sci ;
19310: LD_ADDR_VAR 0 3
19314: PUSH
19315: LD_EXP 71
19319: PUSH
19320: LD_VAR 0 1
19324: ARRAY
19325: PUSH
19326: LD_VAR 0 2
19330: ADD
19331: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19332: LD_ADDR_EXP 71
19336: PUSH
19337: LD_EXP 71
19341: PPUSH
19342: LD_VAR 0 1
19346: PPUSH
19347: CALL_OW 3
19351: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19352: LD_ADDR_EXP 71
19356: PUSH
19357: LD_EXP 71
19361: PPUSH
19362: LD_VAR 0 1
19366: PPUSH
19367: LD_VAR 0 3
19371: PPUSH
19372: CALL_OW 2
19376: ST_TO_ADDR
// ComRemember ( sci ) ;
19377: LD_VAR 0 2
19381: PPUSH
19382: CALL_OW 143
// ComMoveToArea ( sci , Heal [ side ] ) ;
19386: LD_VAR 0 2
19390: PPUSH
19391: LD_LOC 16
19395: PUSH
19396: LD_VAR 0 1
19400: ARRAY
19401: PPUSH
19402: CALL_OW 113
// end ; for un in wounded do
19406: LD_ADDR_VAR 0 5
19410: PUSH
19411: LD_VAR 0 4
19415: PUSH
19416: FOR_IN
19417: IFFALSE 19435
// AddComHeal ( sci , un ) ;
19419: LD_VAR 0 2
19423: PPUSH
19424: LD_VAR 0 5
19428: PPUSH
19429: CALL_OW 188
19433: GO 19416
19435: POP
19436: POP
// end else
19437: GO 19581
// if docs [ side ] then
19439: LD_LOC 17
19443: PUSH
19444: LD_VAR 0 1
19448: ARRAY
19449: IFFALSE 19581
// begin list := reserved_people [ side ] diff docs [ side ] ;
19451: LD_ADDR_VAR 0 3
19455: PUSH
19456: LD_EXP 71
19460: PUSH
19461: LD_VAR 0 1
19465: ARRAY
19466: PUSH
19467: LD_LOC 17
19471: PUSH
19472: LD_VAR 0 1
19476: ARRAY
19477: DIFF
19478: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19479: LD_ADDR_EXP 71
19483: PUSH
19484: LD_EXP 71
19488: PPUSH
19489: LD_VAR 0 1
19493: PPUSH
19494: CALL_OW 3
19498: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19499: LD_ADDR_EXP 71
19503: PUSH
19504: LD_EXP 71
19508: PPUSH
19509: LD_VAR 0 1
19513: PPUSH
19514: LD_VAR 0 3
19518: PPUSH
19519: CALL_OW 2
19523: ST_TO_ADDR
// ComReturn ( docs [ side ] ) ;
19524: LD_LOC 17
19528: PUSH
19529: LD_VAR 0 1
19533: ARRAY
19534: PPUSH
19535: CALL_OW 144
// docs := Delete ( docs , side ) ;
19539: LD_ADDR_LOC 17
19543: PUSH
19544: LD_LOC 17
19548: PPUSH
19549: LD_VAR 0 1
19553: PPUSH
19554: CALL_OW 3
19558: ST_TO_ADDR
// docs := Insert ( docs , side , [ ] ) ;
19559: LD_ADDR_LOC 17
19563: PUSH
19564: LD_LOC 17
19568: PPUSH
19569: LD_VAR 0 1
19573: PPUSH
19574: EMPTY
19575: PPUSH
19576: CALL_OW 2
19580: ST_TO_ADDR
// end ; end ;
19581: GO 19148
19583: POP
19584: POP
// enable ;
19585: ENABLE
// end ;
19586: PPOPN 5
19588: END
// every 0 0$3.1 do var list , self ;
19589: GO 19591
19591: DISABLE
19592: LD_INT 0
19594: PPUSH
19595: PPUSH
// begin list := FilterUnitsInArea ( ar_base , [ [ f_side , you ] , [ f_ok ] ] ) ;
19596: LD_ADDR_VAR 0 1
19600: PUSH
19601: LD_INT 13
19603: PPUSH
19604: LD_INT 22
19606: PUSH
19607: LD_EXP 1
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: PUSH
19616: LD_INT 50
19618: PUSH
19619: EMPTY
19620: LIST
19621: PUSH
19622: EMPTY
19623: LIST
19624: LIST
19625: PPUSH
19626: CALL_OW 70
19630: ST_TO_ADDR
// if list then
19631: LD_VAR 0 1
19635: IFFALSE 19732
// begin self := FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_vehicle ] , [ f_weapon , ar_selfpropelled_bomb ] ] ) ;
19637: LD_ADDR_VAR 0 2
19641: PUSH
19642: LD_INT 22
19644: PUSH
19645: LD_EXP 4
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: PUSH
19654: LD_INT 21
19656: PUSH
19657: LD_INT 2
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: PUSH
19664: LD_INT 34
19666: PUSH
19667: LD_INT 29
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: LIST
19678: PPUSH
19679: CALL_OW 69
19683: ST_TO_ADDR
// if self then
19684: LD_VAR 0 2
19688: IFFALSE 19706
// self := self [ 1 ] else
19690: LD_ADDR_VAR 0 2
19694: PUSH
19695: LD_VAR 0 2
19699: PUSH
19700: LD_INT 1
19702: ARRAY
19703: ST_TO_ADDR
19704: GO 19708
// exit ;
19706: GO 19733
// ComAttackUnit ( self , NearestUnitToUnit ( list , self ) ) ;
19708: LD_VAR 0 2
19712: PPUSH
19713: LD_VAR 0 1
19717: PPUSH
19718: LD_VAR 0 2
19722: PPUSH
19723: CALL_OW 74
19727: PPUSH
19728: CALL_OW 115
// ; end ; enable ;
19732: ENABLE
// end ;
19733: PPOPN 2
19735: END
// every 0 0$3 do var side , list ;
19736: GO 19738
19738: DISABLE
19739: LD_INT 0
19741: PPUSH
19742: PPUSH
// begin for side in cpu_list do
19743: LD_ADDR_VAR 0 1
19747: PUSH
19748: LD_EXP 8
19752: PUSH
19753: FOR_IN
19754: IFFALSE 19843
// if side then
19756: LD_VAR 0 1
19760: IFFALSE 19841
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 800 ] ] ) diff healing_un ;
19762: LD_ADDR_VAR 0 2
19766: PUSH
19767: LD_INT 22
19769: PUSH
19770: LD_VAR 0 1
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 21
19781: PUSH
19782: LD_INT 1
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 24
19794: PUSH
19795: LD_INT 800
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: PPUSH
19808: CALL_OW 69
19812: PUSH
19813: LD_LOC 18
19817: DIFF
19818: ST_TO_ADDR
// if list then
19819: LD_VAR 0 2
19823: IFFALSE 19841
// wounded_un := wounded_un ^ list ;
19825: LD_ADDR_LOC 19
19829: PUSH
19830: LD_LOC 19
19834: PUSH
19835: LD_VAR 0 2
19839: ADD
19840: ST_TO_ADDR
// end ;
19841: GO 19753
19843: POP
19844: POP
// enable ;
19845: ENABLE
// end ;
19846: PPOPN 2
19848: END
// every 0 0$2 do var list , un ;
19849: GO 19851
19851: DISABLE
19852: LD_INT 0
19854: PPUSH
19855: PPUSH
// begin for un in wounded_un do
19856: LD_ADDR_VAR 0 2
19860: PUSH
19861: LD_LOC 19
19865: PUSH
19866: FOR_IN
19867: IFFALSE 19953
// if not ( un in healing_un ) then
19869: LD_VAR 0 2
19873: PUSH
19874: LD_LOC 18
19878: IN
19879: NOT
19880: IFFALSE 19951
// begin healing_un := healing_un ^ un ;
19882: LD_ADDR_LOC 18
19886: PUSH
19887: LD_LOC 18
19891: PUSH
19892: LD_VAR 0 2
19896: ADD
19897: ST_TO_ADDR
// McCustom ( 100 , un ) ;
19898: LD_INT 100
19900: PPUSH
19901: LD_VAR 0 2
19905: PPUSH
19906: CALL_OW 416
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
19910: LD_VAR 0 2
19914: PPUSH
19915: LD_LOC 16
19919: PUSH
19920: LD_VAR 0 2
19924: PPUSH
19925: CALL_OW 255
19929: ARRAY
19930: PPUSH
19931: CALL_OW 113
// wounded_un := wounded_un diff un ;
19935: LD_ADDR_LOC 19
19939: PUSH
19940: LD_LOC 19
19944: PUSH
19945: LD_VAR 0 2
19949: DIFF
19950: ST_TO_ADDR
// end ;
19951: GO 19866
19953: POP
19954: POP
// enable ;
19955: ENABLE
// end ;
19956: PPOPN 2
19958: END
// every 0 0$2 + 0 0$1 do var un ;
19959: GO 19961
19961: DISABLE
19962: LD_INT 0
19964: PPUSH
// begin for un in healing_un do
19965: LD_ADDR_VAR 0 1
19969: PUSH
19970: LD_LOC 18
19974: PUSH
19975: FOR_IN
19976: IFFALSE 20080
// if GetLives ( un ) = 1000 then
19978: LD_VAR 0 1
19982: PPUSH
19983: CALL_OW 256
19987: PUSH
19988: LD_INT 1000
19990: EQUAL
19991: IFFALSE 20025
// begin KillMc ( GetUnitMc ( un ) ) ;
19993: LD_VAR 0 1
19997: PPUSH
19998: CALL_OW 388
20002: PPUSH
20003: CALL_OW 387
// healing_un := healing_un diff un ;
20007: LD_ADDR_LOC 18
20011: PUSH
20012: LD_LOC 18
20016: PUSH
20017: LD_VAR 0 1
20021: DIFF
20022: ST_TO_ADDR
// end else
20023: GO 20078
// if not IsInArea ( un , Heal [ GetSide ( un ) ] ) then
20025: LD_VAR 0 1
20029: PPUSH
20030: LD_LOC 16
20034: PUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 255
20044: ARRAY
20045: PPUSH
20046: CALL_OW 308
20050: NOT
20051: IFFALSE 20078
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20053: LD_VAR 0 1
20057: PPUSH
20058: LD_LOC 16
20062: PUSH
20063: LD_VAR 0 1
20067: PPUSH
20068: CALL_OW 255
20072: ARRAY
20073: PPUSH
20074: CALL_OW 113
20078: GO 19975
20080: POP
20081: POP
// enable ;
20082: ENABLE
// end ;
20083: PPOPN 1
20085: END
// function SendForces ( side ) ; var un , list , target , defenders ; begin
20086: LD_INT 0
20088: PPUSH
20089: PPUSH
20090: PPUSH
20091: PPUSH
20092: PPUSH
// ComRemember ( defend_forces [ side ] ) ;
20093: LD_EXP 68
20097: PUSH
20098: LD_VAR 0 1
20102: ARRAY
20103: PPUSH
20104: CALL_OW 143
// if ExistMc ( mc_id_defend ) then
20108: LD_LOC 21
20112: PPUSH
20113: CALL_OW 386
20117: IFFALSE 20128
// KillMc ( mc_id_defend ) ;
20119: LD_LOC 21
20123: PPUSH
20124: CALL_OW 387
// mc_id_defend := McCustom ( 500 , defend_forces [ side ] ) ;
20128: LD_ADDR_LOC 21
20132: PUSH
20133: LD_INT 500
20135: PPUSH
20136: LD_EXP 68
20140: PUSH
20141: LD_VAR 0 1
20145: ARRAY
20146: PPUSH
20147: CALL_OW 416
20151: ST_TO_ADDR
// wait ( 1 ) ;
20152: LD_INT 1
20154: PPUSH
20155: CALL_OW 67
// repeat list := FilterUnitsInArea ( DefendArea [ side ] , [ [ f_side , you ] , [ f_ok ] ] ) ;
20159: LD_ADDR_VAR 0 4
20163: PUSH
20164: LD_LOC 15
20168: PUSH
20169: LD_VAR 0 1
20173: ARRAY
20174: PPUSH
20175: LD_INT 22
20177: PUSH
20178: LD_EXP 1
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: PUSH
20187: LD_INT 50
20189: PUSH
20190: EMPTY
20191: LIST
20192: PUSH
20193: EMPTY
20194: LIST
20195: LIST
20196: PPUSH
20197: CALL_OW 70
20201: ST_TO_ADDR
// target := NearestUnitToXY ( list , central_base [ side ] [ 1 ] , central_base [ side ] [ 2 ] ) ;
20202: LD_ADDR_VAR 0 5
20206: PUSH
20207: LD_VAR 0 4
20211: PPUSH
20212: LD_LOC 20
20216: PUSH
20217: LD_VAR 0 1
20221: ARRAY
20222: PUSH
20223: LD_INT 1
20225: ARRAY
20226: PPUSH
20227: LD_LOC 20
20231: PUSH
20232: LD_VAR 0 1
20236: ARRAY
20237: PUSH
20238: LD_INT 2
20240: ARRAY
20241: PPUSH
20242: CALL_OW 73
20246: ST_TO_ADDR
// defenders := prepare_defend ( side ) ;
20247: LD_ADDR_VAR 0 6
20251: PUSH
20252: LD_VAR 0 1
20256: PPUSH
20257: CALL 18324 0 1
20261: ST_TO_ADDR
// if list = 0 or defenders = 0 then
20262: LD_VAR 0 4
20266: PUSH
20267: LD_INT 0
20269: EQUAL
20270: PUSH
20271: LD_VAR 0 6
20275: PUSH
20276: LD_INT 0
20278: EQUAL
20279: OR
20280: IFFALSE 20284
// break ;
20282: GO 20399
// for un in defenders do
20284: LD_ADDR_VAR 0 3
20288: PUSH
20289: LD_VAR 0 6
20293: PUSH
20294: FOR_IN
20295: IFFALSE 20386
// if GetWeapon ( un ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ru_rocket ] then
20297: LD_VAR 0 3
20301: PPUSH
20302: CALL_OW 264
20306: PUSH
20307: LD_INT 7
20309: PUSH
20310: LD_INT 28
20312: PUSH
20313: LD_INT 45
20315: PUSH
20316: LD_INT 47
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: IN
20325: IFFALSE 20364
// ComAttackPlace ( defend_forces [ side ] , GetX ( target ) , GetY ( target ) ) else
20327: LD_EXP 68
20331: PUSH
20332: LD_VAR 0 1
20336: ARRAY
20337: PPUSH
20338: LD_VAR 0 5
20342: PPUSH
20343: CALL_OW 250
20347: PPUSH
20348: LD_VAR 0 5
20352: PPUSH
20353: CALL_OW 251
20357: PPUSH
20358: CALL_OW 116
20362: GO 20384
// ComAttackUnit ( defend_forces [ side ] , target ) ;
20364: LD_EXP 68
20368: PUSH
20369: LD_VAR 0 1
20373: ARRAY
20374: PPUSH
20375: LD_VAR 0 5
20379: PPUSH
20380: CALL_OW 115
20384: GO 20294
20386: POP
20387: POP
// wait ( 50 ) ;
20388: LD_INT 50
20390: PPUSH
20391: CALL_OW 67
// until false ;
20395: LD_INT 0
20397: IFFALSE 20159
// KillMc ( mc_id_defend ) ;
20399: LD_LOC 21
20403: PPUSH
20404: CALL_OW 387
// mc_id_defend := false ;
20408: LD_ADDR_LOC 21
20412: PUSH
20413: LD_INT 0
20415: ST_TO_ADDR
// wait ( 2 ) ;
20416: LD_INT 2
20418: PPUSH
20419: CALL_OW 67
// ComReturn ( defend_forces [ side ] ) ;
20423: LD_EXP 68
20427: PUSH
20428: LD_VAR 0 1
20432: ARRAY
20433: PPUSH
20434: CALL_OW 144
// end ;
20438: LD_VAR 0 2
20442: RET
// every 0 0$5.1 do var side ;
20443: GO 20445
20445: DISABLE
20446: LD_INT 0
20448: PPUSH
// begin for side = 1 to 3 do
20449: LD_ADDR_VAR 0 1
20453: PUSH
20454: DOUBLE
20455: LD_INT 1
20457: DEC
20458: ST_TO_ADDR
20459: LD_INT 3
20461: PUSH
20462: FOR_TO
20463: IFFALSE 20665
// if ( not defend_forces [ side ] ) and ready_forces [ side ] then
20465: LD_EXP 68
20469: PUSH
20470: LD_VAR 0 1
20474: ARRAY
20475: NOT
20476: PUSH
20477: LD_EXP 65
20481: PUSH
20482: LD_VAR 0 1
20486: ARRAY
20487: AND
20488: IFFALSE 20663
// begin defend_forces := Replace ( defend_forces , side , ready_forces [ side ] ) ;
20490: LD_ADDR_EXP 68
20494: PUSH
20495: LD_EXP 68
20499: PPUSH
20500: LD_VAR 0 1
20504: PPUSH
20505: LD_EXP 65
20509: PUSH
20510: LD_VAR 0 1
20514: ARRAY
20515: PPUSH
20516: CALL_OW 1
20520: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
20521: LD_ADDR_EXP 65
20525: PUSH
20526: LD_EXP 65
20530: PPUSH
20531: LD_VAR 0 1
20535: PPUSH
20536: EMPTY
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// jammed_forces := Replace ( jammed_forces , side , jammed_forces [ side ] diff defend_forces [ side ] ) ;
20543: LD_ADDR_EXP 69
20547: PUSH
20548: LD_EXP 69
20552: PPUSH
20553: LD_VAR 0 1
20557: PPUSH
20558: LD_EXP 69
20562: PUSH
20563: LD_VAR 0 1
20567: ARRAY
20568: PUSH
20569: LD_EXP 68
20573: PUSH
20574: LD_VAR 0 1
20578: ARRAY
20579: DIFF
20580: PPUSH
20581: CALL_OW 1
20585: ST_TO_ADDR
// case side of 1 :
20586: LD_VAR 0 1
20590: PUSH
20591: LD_INT 1
20593: DOUBLE
20594: EQUAL
20595: IFTRUE 20599
20597: GO 20623
20599: POP
// ComMoveXY ( defend_forces [ side ] , 40 , 46 ) ; 3 :
20600: LD_EXP 68
20604: PUSH
20605: LD_VAR 0 1
20609: ARRAY
20610: PPUSH
20611: LD_INT 40
20613: PPUSH
20614: LD_INT 46
20616: PPUSH
20617: CALL_OW 111
20621: GO 20656
20623: LD_INT 3
20625: DOUBLE
20626: EQUAL
20627: IFTRUE 20631
20629: GO 20655
20631: POP
// ComMoveXY ( defend_forces [ side ] , 175 , 50 ) ; end ;
20632: LD_EXP 68
20636: PUSH
20637: LD_VAR 0 1
20641: ARRAY
20642: PPUSH
20643: LD_INT 175
20645: PPUSH
20646: LD_INT 50
20648: PPUSH
20649: CALL_OW 111
20653: GO 20656
20655: POP
// wait ( 2 ) ;
20656: LD_INT 2
20658: PPUSH
20659: CALL_OW 67
// end ;
20663: GO 20462
20665: POP
20666: POP
// enable ;
20667: ENABLE
// end ;
20668: PPOPN 1
20670: END
// export function Update_defend ( un ) ; var side ; begin
20671: LD_INT 0
20673: PPUSH
20674: PPUSH
// if GetSide ( un ) = you then
20675: LD_VAR 0 1
20679: PPUSH
20680: CALL_OW 255
20684: PUSH
20685: LD_EXP 1
20689: EQUAL
20690: IFFALSE 20694
// exit ;
20692: GO 20769
// for side = 1 to 3 do
20694: LD_ADDR_VAR 0 3
20698: PUSH
20699: DOUBLE
20700: LD_INT 1
20702: DEC
20703: ST_TO_ADDR
20704: LD_INT 3
20706: PUSH
20707: FOR_TO
20708: IFFALSE 20767
// if un in defend_forces [ side ] then
20710: LD_VAR 0 1
20714: PUSH
20715: LD_EXP 68
20719: PUSH
20720: LD_VAR 0 3
20724: ARRAY
20725: IN
20726: IFFALSE 20765
// defend_forces := Replace ( defend_forces , side , defend_forces [ side ] diff un ) ;
20728: LD_ADDR_EXP 68
20732: PUSH
20733: LD_EXP 68
20737: PPUSH
20738: LD_VAR 0 3
20742: PPUSH
20743: LD_EXP 68
20747: PUSH
20748: LD_VAR 0 3
20752: ARRAY
20753: PUSH
20754: LD_VAR 0 1
20758: DIFF
20759: PPUSH
20760: CALL_OW 1
20764: ST_TO_ADDR
20765: GO 20707
20767: POP
20768: POP
// end ; end_of_file
20769: LD_VAR 0 2
20773: RET
// export ready_forces , attack_forces , retreat_forces , defend_forces , jammed_forces ; var us_ru , us_ar , ru_us , ru_ar ; var last_ar_attack , attack_timing , attack_limit ; var al_eliminate ; var pocet_odebrani ; export function init_attack ; var side ; begin
20774: LD_INT 0
20776: PPUSH
20777: PPUSH
// ready_forces = [ ] ;
20778: LD_ADDR_EXP 65
20782: PUSH
20783: EMPTY
20784: ST_TO_ADDR
// attack_forces = [ ] ;
20785: LD_ADDR_EXP 66
20789: PUSH
20790: EMPTY
20791: ST_TO_ADDR
// retreat_forces = [ ] ;
20792: LD_ADDR_EXP 67
20796: PUSH
20797: EMPTY
20798: ST_TO_ADDR
// defend_forces = [ ] ;
20799: LD_ADDR_EXP 68
20803: PUSH
20804: EMPTY
20805: ST_TO_ADDR
// for side = 1 to 8 do
20806: LD_ADDR_VAR 0 2
20810: PUSH
20811: DOUBLE
20812: LD_INT 1
20814: DEC
20815: ST_TO_ADDR
20816: LD_INT 8
20818: PUSH
20819: FOR_TO
20820: IFFALSE 20904
// begin ready_forces = ready_forces ^ [ [ ] ] ;
20822: LD_ADDR_EXP 65
20826: PUSH
20827: LD_EXP 65
20831: PUSH
20832: EMPTY
20833: PUSH
20834: EMPTY
20835: LIST
20836: ADD
20837: ST_TO_ADDR
// attack_forces = attack_forces ^ [ [ ] ] ;
20838: LD_ADDR_EXP 66
20842: PUSH
20843: LD_EXP 66
20847: PUSH
20848: EMPTY
20849: PUSH
20850: EMPTY
20851: LIST
20852: ADD
20853: ST_TO_ADDR
// retreat_forces = retreat_forces ^ [ [ ] ] ;
20854: LD_ADDR_EXP 67
20858: PUSH
20859: LD_EXP 67
20863: PUSH
20864: EMPTY
20865: PUSH
20866: EMPTY
20867: LIST
20868: ADD
20869: ST_TO_ADDR
// defend_forces = defend_forces ^ [ [ ] ] ;
20870: LD_ADDR_EXP 68
20874: PUSH
20875: LD_EXP 68
20879: PUSH
20880: EMPTY
20881: PUSH
20882: EMPTY
20883: LIST
20884: ADD
20885: ST_TO_ADDR
// jammed_forces = jammed_forces ^ [ [ ] ] ;
20886: LD_ADDR_EXP 69
20890: PUSH
20891: LD_EXP 69
20895: PUSH
20896: EMPTY
20897: PUSH
20898: EMPTY
20899: LIST
20900: ADD
20901: ST_TO_ADDR
// end ;
20902: GO 20819
20904: POP
20905: POP
// us_ru := [ [ 76 , 61 ] , [ 121 , 55 ] , [ 171 , 59 ] , [ 190 , 90 ] ] ;
20906: LD_ADDR_LOC 22
20910: PUSH
20911: LD_INT 76
20913: PUSH
20914: LD_INT 61
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 121
20923: PUSH
20924: LD_INT 55
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: PUSH
20931: LD_INT 171
20933: PUSH
20934: LD_INT 59
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PUSH
20941: LD_INT 190
20943: PUSH
20944: LD_INT 90
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: LIST
20955: LIST
20956: ST_TO_ADDR
// us_ar := [ [ [ 78 , 69 ] , [ 121 , 116 ] , [ 155 , 137 ] , [ 190 , 170 ] , [ 242 , 187 ] ] , [ [ 72 , 106 ] , [ 111 , 176 ] , [ 163 , 184 ] , [ 215 , 191 ] , [ 242 , 187 ] ] ] ;
20957: LD_ADDR_LOC 23
20961: PUSH
20962: LD_INT 78
20964: PUSH
20965: LD_INT 69
20967: PUSH
20968: EMPTY
20969: LIST
20970: LIST
20971: PUSH
20972: LD_INT 121
20974: PUSH
20975: LD_INT 116
20977: PUSH
20978: EMPTY
20979: LIST
20980: LIST
20981: PUSH
20982: LD_INT 155
20984: PUSH
20985: LD_INT 137
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: PUSH
20992: LD_INT 190
20994: PUSH
20995: LD_INT 170
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: PUSH
21002: LD_INT 242
21004: PUSH
21005: LD_INT 187
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: LIST
21016: LIST
21017: LIST
21018: PUSH
21019: LD_INT 72
21021: PUSH
21022: LD_INT 106
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: PUSH
21029: LD_INT 111
21031: PUSH
21032: LD_INT 176
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: PUSH
21039: LD_INT 163
21041: PUSH
21042: LD_INT 184
21044: PUSH
21045: EMPTY
21046: LIST
21047: LIST
21048: PUSH
21049: LD_INT 215
21051: PUSH
21052: LD_INT 191
21054: PUSH
21055: EMPTY
21056: LIST
21057: LIST
21058: PUSH
21059: LD_INT 242
21061: PUSH
21062: LD_INT 187
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: LIST
21073: LIST
21074: LIST
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: ST_TO_ADDR
// ru_us := [ [ 118 , 63 ] , [ 78 , 57 ] , [ 30 , 44 ] , [ 56 , 83 ] ] ;
21080: LD_ADDR_LOC 24
21084: PUSH
21085: LD_INT 118
21087: PUSH
21088: LD_INT 63
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PUSH
21095: LD_INT 78
21097: PUSH
21098: LD_INT 57
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: LD_INT 30
21107: PUSH
21108: LD_INT 44
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: PUSH
21115: LD_INT 56
21117: PUSH
21118: LD_INT 83
21120: PUSH
21121: EMPTY
21122: LIST
21123: LIST
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: ST_TO_ADDR
// ru_ar := [ [ [ 142 , 65 ] , [ 160 , 140 ] , [ 255 , 196 ] ] , [ [ 125 , 58 ] , [ 106 , 93 ] , [ 126 , 154 ] , [ 121 , 182 ] , [ 167 , 180 ] , [ 251 , 187 ] ] ] ;
21131: LD_ADDR_LOC 25
21135: PUSH
21136: LD_INT 142
21138: PUSH
21139: LD_INT 65
21141: PUSH
21142: EMPTY
21143: LIST
21144: LIST
21145: PUSH
21146: LD_INT 160
21148: PUSH
21149: LD_INT 140
21151: PUSH
21152: EMPTY
21153: LIST
21154: LIST
21155: PUSH
21156: LD_INT 255
21158: PUSH
21159: LD_INT 196
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: LIST
21170: PUSH
21171: LD_INT 125
21173: PUSH
21174: LD_INT 58
21176: PUSH
21177: EMPTY
21178: LIST
21179: LIST
21180: PUSH
21181: LD_INT 106
21183: PUSH
21184: LD_INT 93
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: PUSH
21191: LD_INT 126
21193: PUSH
21194: LD_INT 154
21196: PUSH
21197: EMPTY
21198: LIST
21199: LIST
21200: PUSH
21201: LD_INT 121
21203: PUSH
21204: LD_INT 182
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 167
21213: PUSH
21214: LD_INT 180
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: PUSH
21221: LD_INT 251
21223: PUSH
21224: LD_INT 187
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: EMPTY
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: ST_TO_ADDR
// al_eliminate = [ [ 88 , 53 ] , [ 49 , 10 ] , [ 83 , 13 ] ] ;
21243: LD_ADDR_LOC 29
21247: PUSH
21248: LD_INT 88
21250: PUSH
21251: LD_INT 53
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: PUSH
21258: LD_INT 49
21260: PUSH
21261: LD_INT 10
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 83
21270: PUSH
21271: LD_INT 13
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: LIST
21282: ST_TO_ADDR
// attack_timing = [ 50 , 40 , 30 ] [ difficulty ] ;
21283: LD_ADDR_LOC 27
21287: PUSH
21288: LD_INT 50
21290: PUSH
21291: LD_INT 40
21293: PUSH
21294: LD_INT 30
21296: PUSH
21297: EMPTY
21298: LIST
21299: LIST
21300: LIST
21301: PUSH
21302: LD_OWVAR 67
21306: ARRAY
21307: ST_TO_ADDR
// attack_limit = 0 ;
21308: LD_ADDR_LOC 28
21312: PUSH
21313: LD_INT 0
21315: ST_TO_ADDR
// last_ar_attack = TICK ;
21316: LD_ADDR_LOC 26
21320: PUSH
21321: LD_OWVAR 1
21325: ST_TO_ADDR
// pocet_odebrani = 0 ;
21326: LD_ADDR_LOC 30
21330: PUSH
21331: LD_INT 0
21333: ST_TO_ADDR
// end ;
21334: LD_VAR 0 1
21338: RET
// every 0 0$15.4 do var active_side , num_forces ;
21339: GO 21341
21341: DISABLE
21342: LD_INT 0
21344: PPUSH
21345: PPUSH
// begin num_forces := define_forces_strenght ;
21346: LD_ADDR_VAR 0 2
21350: PUSH
21351: CALL 21411 0 0
21355: ST_TO_ADDR
// for active_side in cpu_list do
21356: LD_ADDR_VAR 0 1
21360: PUSH
21361: LD_EXP 8
21365: PUSH
21366: FOR_IN
21367: IFFALSE 21405
// if ready_forces [ active_side ] >= num_forces then
21369: LD_EXP 65
21373: PUSH
21374: LD_VAR 0 1
21378: ARRAY
21379: PUSH
21380: LD_VAR 0 2
21384: GREATEREQUAL
21385: IFFALSE 21403
// begin let_the_war_begin ( active_side ) ;
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL 22874 0 1
// wait ( 1 ) ;
21396: LD_INT 1
21398: PPUSH
21399: CALL_OW 67
// end ;
21403: GO 21366
21405: POP
21406: POP
// enable ;
21407: ENABLE
// end ;
21408: PPOPN 2
21410: END
// function define_forces_strenght ; var num ; begin
21411: LD_INT 0
21413: PPUSH
21414: PPUSH
// num := 3 ;
21415: LD_ADDR_VAR 0 2
21419: PUSH
21420: LD_INT 3
21422: ST_TO_ADDR
// if TICK > 7 7$0 then
21423: LD_OWVAR 1
21427: PUSH
21428: LD_INT 14700
21430: GREATER
21431: IFFALSE 21441
// num := 4 ;
21433: LD_ADDR_VAR 0 2
21437: PUSH
21438: LD_INT 4
21440: ST_TO_ADDR
// if TICK > 14 14$0 then
21441: LD_OWVAR 1
21445: PUSH
21446: LD_INT 29400
21448: GREATER
21449: IFFALSE 21459
// num := 6 ;
21451: LD_ADDR_VAR 0 2
21455: PUSH
21456: LD_INT 6
21458: ST_TO_ADDR
// result := num ;
21459: LD_ADDR_VAR 0 1
21463: PUSH
21464: LD_VAR 0 2
21468: ST_TO_ADDR
// end ;
21469: LD_VAR 0 1
21473: RET
// function define_target_priority ; var target ; begin
21474: LD_INT 0
21476: PPUSH
21477: PPUSH
// target := Rand ( 0 , attack_timing ) ;
21478: LD_ADDR_VAR 0 2
21482: PUSH
21483: LD_INT 0
21485: PPUSH
21486: LD_LOC 27
21490: PPUSH
21491: CALL_OW 12
21495: ST_TO_ADDR
// if target > attack_limit then
21496: LD_VAR 0 2
21500: PUSH
21501: LD_LOC 28
21505: GREATER
21506: IFFALSE 21518
// target := false else
21508: LD_ADDR_VAR 0 2
21512: PUSH
21513: LD_INT 0
21515: ST_TO_ADDR
21516: GO 21526
// target := true ;
21518: LD_ADDR_VAR 0 2
21522: PUSH
21523: LD_INT 1
21525: ST_TO_ADDR
// result := target ;
21526: LD_ADDR_VAR 0 1
21530: PUSH
21531: LD_VAR 0 2
21535: ST_TO_ADDR
// end ;
21536: LD_VAR 0 1
21540: RET
// every 1 1$0 trigger attack_timing > attack_limit do
21541: LD_LOC 27
21545: PUSH
21546: LD_LOC 28
21550: GREATER
21551: IFFALSE 21585
21553: GO 21555
21555: DISABLE
// begin attack_timing := attack_timing - 1 ;
21556: LD_ADDR_LOC 27
21560: PUSH
21561: LD_LOC 27
21565: PUSH
21566: LD_INT 1
21568: MINUS
21569: ST_TO_ADDR
// attack_limit := attack_limit + 1 ;
21570: LD_ADDR_LOC 28
21574: PUSH
21575: LD_LOC 28
21579: PUSH
21580: LD_INT 1
21582: PLUS
21583: ST_TO_ADDR
// enable ;
21584: ENABLE
// end ;
21585: END
// function Select_Weakest_Base ( areas ) ; var selected , un , list ; begin
21586: LD_INT 0
21588: PPUSH
21589: PPUSH
21590: PPUSH
21591: PPUSH
// selected := false ;
21592: LD_ADDR_VAR 0 3
21596: PUSH
21597: LD_INT 0
21599: ST_TO_ADDR
// for un in areas do
21600: LD_ADDR_VAR 0 4
21604: PUSH
21605: LD_VAR 0 1
21609: PUSH
21610: FOR_IN
21611: IFFALSE 21738
// begin list := FilterUnitsInArea ( un , [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
21613: LD_ADDR_VAR 0 5
21617: PUSH
21618: LD_VAR 0 4
21622: PPUSH
21623: LD_INT 22
21625: PUSH
21626: LD_EXP 1
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 21
21637: PUSH
21638: LD_INT 3
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PUSH
21645: LD_INT 2
21647: PUSH
21648: LD_INT 30
21650: PUSH
21651: LD_INT 33
21653: PUSH
21654: EMPTY
21655: LIST
21656: LIST
21657: PUSH
21658: LD_INT 30
21660: PUSH
21661: LD_INT 32
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: LIST
21672: PUSH
21673: EMPTY
21674: LIST
21675: LIST
21676: LIST
21677: PPUSH
21678: CALL_OW 70
21682: ST_TO_ADDR
// if ( not selected ) or ( selected [ 1 ] < list ) then
21683: LD_VAR 0 3
21687: NOT
21688: PUSH
21689: LD_VAR 0 3
21693: PUSH
21694: LD_INT 1
21696: ARRAY
21697: PUSH
21698: LD_VAR 0 5
21702: LESS
21703: OR
21704: IFFALSE 21729
// selected := [ list + 0 , un ] ;
21706: LD_ADDR_VAR 0 3
21710: PUSH
21711: LD_VAR 0 5
21715: PUSH
21716: LD_INT 0
21718: PLUS
21719: PUSH
21720: LD_VAR 0 4
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: ST_TO_ADDR
// wait ( 1 ) ;
21729: LD_INT 1
21731: PPUSH
21732: CALL_OW 67
// end ;
21736: GO 21610
21738: POP
21739: POP
// if selected then
21740: LD_VAR 0 3
21744: IFFALSE 21760
// selected := selected [ 2 ] ;
21746: LD_ADDR_VAR 0 3
21750: PUSH
21751: LD_VAR 0 3
21755: PUSH
21756: LD_INT 2
21758: ARRAY
21759: ST_TO_ADDR
// result := selected ;
21760: LD_ADDR_VAR 0 2
21764: PUSH
21765: LD_VAR 0 3
21769: ST_TO_ADDR
// end ;
21770: LD_VAR 0 2
21774: RET
// function Find_Player_Base ; var list , un , goal , areas , defend_tought ; begin
21775: LD_INT 0
21777: PPUSH
21778: PPUSH
21779: PPUSH
21780: PPUSH
21781: PPUSH
21782: PPUSH
// goal := false ;
21783: LD_ADDR_VAR 0 4
21787: PUSH
21788: LD_INT 0
21790: ST_TO_ADDR
// areas := [ ] ;
21791: LD_ADDR_VAR 0 5
21795: PUSH
21796: EMPTY
21797: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21798: LD_ADDR_VAR 0 2
21802: PUSH
21803: LD_INT 22
21805: PUSH
21806: LD_EXP 1
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: PUSH
21815: LD_INT 21
21817: PUSH
21818: LD_INT 3
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: PUSH
21825: LD_INT 2
21827: PUSH
21828: LD_INT 30
21830: PUSH
21831: LD_INT 0
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PUSH
21838: LD_INT 30
21840: PUSH
21841: LD_INT 1
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: LIST
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: LIST
21857: PPUSH
21858: CALL_OW 69
21862: ST_TO_ADDR
// for un in list do
21863: LD_ADDR_VAR 0 3
21867: PUSH
21868: LD_VAR 0 2
21872: PUSH
21873: FOR_IN
21874: IFFALSE 21973
// begin if IsInArea ( un , ar_base ) then
21876: LD_VAR 0 3
21880: PPUSH
21881: LD_INT 13
21883: PPUSH
21884: CALL_OW 308
21888: IFFALSE 21906
// areas := areas ^ ar_base else
21890: LD_ADDR_VAR 0 5
21894: PUSH
21895: LD_VAR 0 5
21899: PUSH
21900: LD_INT 13
21902: ADD
21903: ST_TO_ADDR
21904: GO 21964
// if IsInArea ( un , us_base ) then
21906: LD_VAR 0 3
21910: PPUSH
21911: LD_INT 11
21913: PPUSH
21914: CALL_OW 308
21918: IFFALSE 21936
// areas := areas ^ us_base else
21920: LD_ADDR_VAR 0 5
21924: PUSH
21925: LD_VAR 0 5
21929: PUSH
21930: LD_INT 11
21932: ADD
21933: ST_TO_ADDR
21934: GO 21964
// if IsInArea ( un , ru_base ) then
21936: LD_VAR 0 3
21940: PPUSH
21941: LD_INT 12
21943: PPUSH
21944: CALL_OW 308
21948: IFFALSE 21964
// areas := areas ^ ru_base ;
21950: LD_ADDR_VAR 0 5
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 12
21962: ADD
21963: ST_TO_ADDR
// wait ( 1 ) ;
21964: LD_INT 1
21966: PPUSH
21967: CALL_OW 67
// end ;
21971: GO 21873
21973: POP
21974: POP
// if ( not areas ) or ( areas > 1 ) then
21975: LD_VAR 0 5
21979: NOT
21980: PUSH
21981: LD_VAR 0 5
21985: PUSH
21986: LD_INT 1
21988: GREATER
21989: OR
21990: IFFALSE 22009
// goal := Select_Weakest_Base ( areas ) else
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 5
22001: PPUSH
22002: CALL 21586 0 1
22006: ST_TO_ADDR
22007: GO 22023
// goal := areas [ 1 ] ;
22009: LD_ADDR_VAR 0 4
22013: PUSH
22014: LD_VAR 0 5
22018: PUSH
22019: LD_INT 1
22021: ARRAY
22022: ST_TO_ADDR
// result := goal ;
22023: LD_ADDR_VAR 0 1
22027: PUSH
22028: LD_VAR 0 4
22032: ST_TO_ADDR
// end ;
22033: LD_VAR 0 1
22037: RET
// function GetUnitArea ( un ) ; var area ; begin
22038: LD_INT 0
22040: PPUSH
22041: PPUSH
// case un of 1 :
22042: LD_VAR 0 1
22046: PUSH
22047: LD_INT 1
22049: DOUBLE
22050: EQUAL
22051: IFTRUE 22055
22053: GO 22066
22055: POP
// area := us_base ; 2 :
22056: LD_ADDR_VAR 0 3
22060: PUSH
22061: LD_INT 11
22063: ST_TO_ADDR
22064: GO 22105
22066: LD_INT 2
22068: DOUBLE
22069: EQUAL
22070: IFTRUE 22074
22072: GO 22085
22074: POP
// area := ar_base ; 3 :
22075: LD_ADDR_VAR 0 3
22079: PUSH
22080: LD_INT 13
22082: ST_TO_ADDR
22083: GO 22105
22085: LD_INT 3
22087: DOUBLE
22088: EQUAL
22089: IFTRUE 22093
22091: GO 22104
22093: POP
// area := ru_base ; end ;
22094: LD_ADDR_VAR 0 3
22098: PUSH
22099: LD_INT 12
22101: ST_TO_ADDR
22102: GO 22105
22104: POP
// result := area ;
22105: LD_ADDR_VAR 0 2
22109: PUSH
22110: LD_VAR 0 3
22114: ST_TO_ADDR
// end ;
22115: LD_VAR 0 2
22119: RET
// function Find_CPU_Target ( side ) ; var un , goal , bases , list ; begin
22120: LD_INT 0
22122: PPUSH
22123: PPUSH
22124: PPUSH
22125: PPUSH
22126: PPUSH
// bases := [ ] ;
22127: LD_ADDR_VAR 0 5
22131: PUSH
22132: EMPTY
22133: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22134: LD_ADDR_VAR 0 6
22138: PUSH
22139: LD_INT 21
22141: PUSH
22142: LD_INT 3
22144: PUSH
22145: EMPTY
22146: LIST
22147: LIST
22148: PUSH
22149: LD_INT 2
22151: PUSH
22152: LD_INT 30
22154: PUSH
22155: LD_INT 0
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: PUSH
22162: LD_INT 30
22164: PUSH
22165: LD_INT 1
22167: PUSH
22168: EMPTY
22169: LIST
22170: LIST
22171: PUSH
22172: EMPTY
22173: LIST
22174: LIST
22175: LIST
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PPUSH
22181: CALL_OW 69
22185: ST_TO_ADDR
// for un in list do
22186: LD_ADDR_VAR 0 3
22190: PUSH
22191: LD_VAR 0 6
22195: PUSH
22196: FOR_IN
22197: IFFALSE 22239
// if GetSide ( un ) <> side then
22199: LD_VAR 0 3
22203: PPUSH
22204: CALL_OW 255
22208: PUSH
22209: LD_VAR 0 1
22213: NONEQUAL
22214: IFFALSE 22237
// bases := bases ^ GetSide ( un ) ;
22216: LD_ADDR_VAR 0 5
22220: PUSH
22221: LD_VAR 0 5
22225: PUSH
22226: LD_VAR 0 3
22230: PPUSH
22231: CALL_OW 255
22235: ADD
22236: ST_TO_ADDR
22237: GO 22196
22239: POP
22240: POP
// bases := bases diff you ;
22241: LD_ADDR_VAR 0 5
22245: PUSH
22246: LD_VAR 0 5
22250: PUSH
22251: LD_EXP 1
22255: DIFF
22256: ST_TO_ADDR
// if bases then
22257: LD_VAR 0 5
22261: IFFALSE 22345
// begin if ( bases diff ar ) and Rand ( 0 , 2 ) then
22263: LD_VAR 0 5
22267: PUSH
22268: LD_EXP 4
22272: DIFF
22273: PUSH
22274: LD_INT 0
22276: PPUSH
22277: LD_INT 2
22279: PPUSH
22280: CALL_OW 12
22284: AND
22285: IFFALSE 22314
// goal := GetUnitArea ( ( bases diff ar ) [ 1 ] ) else
22287: LD_ADDR_VAR 0 4
22291: PUSH
22292: LD_VAR 0 5
22296: PUSH
22297: LD_EXP 4
22301: DIFF
22302: PUSH
22303: LD_INT 1
22305: ARRAY
22306: PPUSH
22307: CALL 22038 0 1
22311: ST_TO_ADDR
22312: GO 22343
// goal := GetUnitArea ( bases [ Rand ( 1 , bases ) ] ) ;
22314: LD_ADDR_VAR 0 4
22318: PUSH
22319: LD_VAR 0 5
22323: PUSH
22324: LD_INT 1
22326: PPUSH
22327: LD_VAR 0 5
22331: PPUSH
22332: CALL_OW 12
22336: ARRAY
22337: PPUSH
22338: CALL 22038 0 1
22342: ST_TO_ADDR
// end else
22343: GO 22355
// goal := Find_Player_Base ;
22345: LD_ADDR_VAR 0 4
22349: PUSH
22350: CALL 21775 0 0
22354: ST_TO_ADDR
// result := goal ;
22355: LD_ADDR_VAR 0 2
22359: PUSH
22360: LD_VAR 0 4
22364: ST_TO_ADDR
// end ;
22365: LD_VAR 0 2
22369: RET
// function Wrong_Base ; var un , vysledek ; begin
22370: LD_INT 0
22372: PPUSH
22373: PPUSH
22374: PPUSH
// un := FilterUnitsInArea ( top_area , [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
22375: LD_ADDR_VAR 0 2
22379: PUSH
22380: LD_INT 20
22382: PPUSH
22383: LD_INT 22
22385: PUSH
22386: LD_EXP 1
22390: PUSH
22391: EMPTY
22392: LIST
22393: LIST
22394: PUSH
22395: LD_INT 21
22397: PUSH
22398: LD_INT 3
22400: PUSH
22401: EMPTY
22402: LIST
22403: LIST
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PPUSH
22409: CALL_OW 70
22413: ST_TO_ADDR
// if un then
22414: LD_VAR 0 2
22418: IFFALSE 22430
// vysledek := true else
22420: LD_ADDR_VAR 0 3
22424: PUSH
22425: LD_INT 1
22427: ST_TO_ADDR
22428: GO 22438
// vysledek := false ;
22430: LD_ADDR_VAR 0 3
22434: PUSH
22435: LD_INT 0
22437: ST_TO_ADDR
// result := vysledek ;
22438: LD_ADDR_VAR 0 1
22442: PUSH
22443: LD_VAR 0 3
22447: ST_TO_ADDR
// end ;
22448: LD_VAR 0 1
22452: RET
// function All_Tracked ( list ) ; var un , vysledek ; begin
22453: LD_INT 0
22455: PPUSH
22456: PPUSH
22457: PPUSH
// vysledek := true ;
22458: LD_ADDR_VAR 0 4
22462: PUSH
22463: LD_INT 1
22465: ST_TO_ADDR
// for un in list do
22466: LD_ADDR_VAR 0 3
22470: PUSH
22471: LD_VAR 0 1
22475: PUSH
22476: FOR_IN
22477: IFFALSE 22517
// if GetChassis ( un ) in [ us_light_wheeled , us_medium_wheeled , ru_medium_wheeled ] then
22479: LD_VAR 0 3
22483: PPUSH
22484: CALL_OW 265
22488: PUSH
22489: LD_INT 1
22491: PUSH
22492: LD_INT 2
22494: PUSH
22495: LD_INT 21
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: LIST
22502: IN
22503: IFFALSE 22515
// begin vysledek := false ;
22505: LD_ADDR_VAR 0 4
22509: PUSH
22510: LD_INT 0
22512: ST_TO_ADDR
// break ;
22513: GO 22517
// end ;
22515: GO 22476
22517: POP
22518: POP
// result := vysledek ;
22519: LD_ADDR_VAR 0 2
22523: PUSH
22524: LD_VAR 0 4
22528: ST_TO_ADDR
// end ;
22529: LD_VAR 0 2
22533: RET
// function Send_US_Forces ( target , side ) ; begin
22534: LD_INT 0
22536: PPUSH
// if target = ar_base then
22537: LD_VAR 0 1
22541: PUSH
22542: LD_INT 13
22544: EQUAL
22545: IFFALSE 22658
// begin if All_tracked ( attack_forces [ side ] ) then
22547: LD_EXP 66
22551: PUSH
22552: LD_VAR 0 2
22556: ARRAY
22557: PPUSH
22558: CALL 22453 0 1
22562: IFFALSE 22611
// McMove ( 15 , attack_forces [ side ] , us_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22564: LD_INT 15
22566: PPUSH
22567: LD_EXP 66
22571: PUSH
22572: LD_VAR 0 2
22576: ARRAY
22577: PPUSH
22578: LD_LOC 23
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: PPUSH
22587: LD_INT 3
22589: PUSH
22590: LD_INT 5
22592: PUSH
22593: LD_INT 6
22595: PUSH
22596: LD_INT 7
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: PPUSH
22605: CALL_OW 398
22609: GO 22656
// McMove ( 15 , attack_forces [ side ] , us_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22611: LD_INT 15
22613: PPUSH
22614: LD_EXP 66
22618: PUSH
22619: LD_VAR 0 2
22623: ARRAY
22624: PPUSH
22625: LD_LOC 23
22629: PUSH
22630: LD_INT 2
22632: ARRAY
22633: PPUSH
22634: LD_INT 3
22636: PUSH
22637: LD_INT 5
22639: PUSH
22640: LD_INT 6
22642: PUSH
22643: LD_INT 7
22645: PUSH
22646: EMPTY
22647: LIST
22648: LIST
22649: LIST
22650: LIST
22651: PPUSH
22652: CALL_OW 398
// end else
22656: GO 22699
// McMove ( 15 , attack_forces [ side ] , us_ru , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22658: LD_INT 15
22660: PPUSH
22661: LD_EXP 66
22665: PUSH
22666: LD_VAR 0 2
22670: ARRAY
22671: PPUSH
22672: LD_LOC 22
22676: PPUSH
22677: LD_INT 3
22679: PUSH
22680: LD_INT 5
22682: PUSH
22683: LD_INT 6
22685: PUSH
22686: LD_INT 7
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: LIST
22693: LIST
22694: PPUSH
22695: CALL_OW 398
// end ;
22699: LD_VAR 0 3
22703: RET
// function Send_RU_Forces ( target , side ) ; begin
22704: LD_INT 0
22706: PPUSH
// if target = ar_base then
22707: LD_VAR 0 1
22711: PUSH
22712: LD_INT 13
22714: EQUAL
22715: IFFALSE 22828
// begin if All_tracked ( attack_forces [ side ] ) then
22717: LD_EXP 66
22721: PUSH
22722: LD_VAR 0 2
22726: ARRAY
22727: PPUSH
22728: CALL 22453 0 1
22732: IFFALSE 22781
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22734: LD_INT 15
22736: PPUSH
22737: LD_EXP 66
22741: PUSH
22742: LD_VAR 0 2
22746: ARRAY
22747: PPUSH
22748: LD_LOC 25
22752: PUSH
22753: LD_INT 1
22755: ARRAY
22756: PPUSH
22757: LD_INT 3
22759: PUSH
22760: LD_INT 5
22762: PUSH
22763: LD_INT 6
22765: PUSH
22766: LD_INT 7
22768: PUSH
22769: EMPTY
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: PPUSH
22775: CALL_OW 398
22779: GO 22826
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22781: LD_INT 15
22783: PPUSH
22784: LD_EXP 66
22788: PUSH
22789: LD_VAR 0 2
22793: ARRAY
22794: PPUSH
22795: LD_LOC 25
22799: PUSH
22800: LD_INT 2
22802: ARRAY
22803: PPUSH
22804: LD_INT 3
22806: PUSH
22807: LD_INT 5
22809: PUSH
22810: LD_INT 6
22812: PUSH
22813: LD_INT 7
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: LIST
22820: LIST
22821: PPUSH
22822: CALL_OW 398
// end else
22826: GO 22869
// McMove ( 15 , attack_forces [ side ] , ru_us , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22828: LD_INT 15
22830: PPUSH
22831: LD_EXP 66
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: LD_LOC 24
22846: PPUSH
22847: LD_INT 3
22849: PUSH
22850: LD_INT 5
22852: PUSH
22853: LD_INT 6
22855: PUSH
22856: LD_INT 7
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 398
// end ;
22869: LD_VAR 0 3
22873: RET
// function let_the_war_begin ( side ) ; var target ; begin
22874: LD_INT 0
22876: PPUSH
22877: PPUSH
// target := false ;
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_INT 0
22885: ST_TO_ADDR
// if define_target_priority then
22886: CALL 21474 0 0
22890: IFFALSE 22902
// target := Find_Player_Base ;
22892: LD_ADDR_VAR 0 3
22896: PUSH
22897: CALL 21775 0 0
22901: ST_TO_ADDR
// if not target then
22902: LD_VAR 0 3
22906: NOT
22907: IFFALSE 22924
// target := Find_CPU_Target ( side ) ;
22909: LD_ADDR_VAR 0 3
22913: PUSH
22914: LD_VAR 0 1
22918: PPUSH
22919: CALL 22120 0 1
22923: ST_TO_ADDR
// if not target then
22924: LD_VAR 0 3
22928: NOT
22929: IFFALSE 22933
// exit ;
22931: GO 23156
// attack_forces := Replace ( attack_forces , side , ready_forces [ side ] ) ;
22933: LD_ADDR_EXP 66
22937: PUSH
22938: LD_EXP 66
22942: PPUSH
22943: LD_VAR 0 1
22947: PPUSH
22948: LD_EXP 65
22952: PUSH
22953: LD_VAR 0 1
22957: ARRAY
22958: PPUSH
22959: CALL_OW 1
22963: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
22964: LD_ADDR_EXP 65
22968: PUSH
22969: LD_EXP 65
22973: PPUSH
22974: LD_VAR 0 1
22978: PPUSH
22979: EMPTY
22980: PPUSH
22981: CALL_OW 1
22985: ST_TO_ADDR
// jammed_forces := Insert ( jammed_forces , side , jammed_forces [ side ] ^ attack_forces [ side ] ) ;
22986: LD_ADDR_EXP 69
22990: PUSH
22991: LD_EXP 69
22995: PPUSH
22996: LD_VAR 0 1
23000: PPUSH
23001: LD_EXP 69
23005: PUSH
23006: LD_VAR 0 1
23010: ARRAY
23011: PUSH
23012: LD_EXP 66
23016: PUSH
23017: LD_VAR 0 1
23021: ARRAY
23022: ADD
23023: PPUSH
23024: CALL_OW 2
23028: ST_TO_ADDR
// case side of 1 :
23029: LD_VAR 0 1
23033: PUSH
23034: LD_INT 1
23036: DOUBLE
23037: EQUAL
23038: IFTRUE 23042
23040: GO 23048
23042: POP
// enable ( 222 ) ; 3 :
23043: LD_INT 222
23045: ENABLE_MARKED
23046: GO 23063
23048: LD_INT 3
23050: DOUBLE
23051: EQUAL
23052: IFTRUE 23056
23054: GO 23062
23056: POP
// enable ( 223 ) ; end ;
23057: LD_INT 223
23059: ENABLE_MARKED
23060: GO 23063
23062: POP
// if Wrong_Base then
23063: CALL 22370 0 0
23067: IFFALSE 23100
// McMove ( 15 , attack_forces [ side ] , al_eliminate , [ mc_move_dontcapture ] ) else
23069: LD_INT 15
23071: PPUSH
23072: LD_EXP 66
23076: PUSH
23077: LD_VAR 0 1
23081: ARRAY
23082: PPUSH
23083: LD_LOC 29
23087: PPUSH
23088: LD_INT 5
23090: PUSH
23091: EMPTY
23092: LIST
23093: PPUSH
23094: CALL_OW 398
23098: GO 23156
// case side of 1 :
23100: LD_VAR 0 1
23104: PUSH
23105: LD_INT 1
23107: DOUBLE
23108: EQUAL
23109: IFTRUE 23113
23111: GO 23130
23113: POP
// Send_US_Forces ( target , side ) ; 3 :
23114: LD_VAR 0 3
23118: PPUSH
23119: LD_VAR 0 1
23123: PPUSH
23124: CALL 22534 0 2
23128: GO 23156
23130: LD_INT 3
23132: DOUBLE
23133: EQUAL
23134: IFTRUE 23138
23136: GO 23155
23138: POP
// Send_RU_Forces ( target , side ) ; end ;
23139: LD_VAR 0 3
23143: PPUSH
23144: LD_VAR 0 1
23148: PPUSH
23149: CALL 22704 0 2
23153: GO 23156
23155: POP
// end ;
23156: LD_VAR 0 2
23160: RET
// every 88 marked 222 do var list , late , un , i ;
23161: GO 23163
23163: DISABLE
23164: LD_INT 0
23166: PPUSH
23167: PPUSH
23168: PPUSH
23169: PPUSH
// begin wait ( 1 1$20 ) ;
23170: LD_INT 2800
23172: PPUSH
23173: CALL_OW 67
// list := FilterUnitsInArea ( us_tinny , [ [ f_side , us ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23177: LD_ADDR_VAR 0 1
23181: PUSH
23182: LD_INT 41
23184: PPUSH
23185: LD_INT 22
23187: PUSH
23188: LD_EXP 3
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: PUSH
23197: LD_INT 21
23199: PUSH
23200: LD_INT 2
23202: PUSH
23203: EMPTY
23204: LIST
23205: LIST
23206: PUSH
23207: LD_INT 50
23209: PUSH
23210: EMPTY
23211: LIST
23212: PUSH
23213: EMPTY
23214: LIST
23215: LIST
23216: LIST
23217: PPUSH
23218: CALL_OW 70
23222: ST_TO_ADDR
// late := jammed_forces [ us ] isect list ;
23223: LD_ADDR_VAR 0 2
23227: PUSH
23228: LD_EXP 69
23232: PUSH
23233: LD_EXP 3
23237: ARRAY
23238: PUSH
23239: LD_VAR 0 1
23243: ISECT
23244: ST_TO_ADDR
// if not late then
23245: LD_VAR 0 2
23249: NOT
23250: IFFALSE 23276
// begin jammed_forces := Replace ( jammed_forces , us , [ ] ) ;
23252: LD_ADDR_EXP 69
23256: PUSH
23257: LD_EXP 69
23261: PPUSH
23262: LD_EXP 3
23266: PPUSH
23267: EMPTY
23268: PPUSH
23269: CALL_OW 1
23273: ST_TO_ADDR
// exit ;
23274: GO 23554
// end ; if FilterUnitsInArea ( us_base , [ [ f_side , you ] ] ) then
23276: LD_INT 11
23278: PPUSH
23279: LD_INT 22
23281: PUSH
23282: LD_EXP 1
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: PUSH
23291: EMPTY
23292: LIST
23293: PPUSH
23294: CALL_OW 70
23298: IFFALSE 23303
// begin enable ;
23300: ENABLE
// exit ;
23301: GO 23554
// end ; for un in late do
23303: LD_ADDR_VAR 0 3
23307: PUSH
23308: LD_VAR 0 2
23312: PUSH
23313: FOR_IN
23314: IFFALSE 23343
// if GetUnitMc ( un ) then
23316: LD_VAR 0 3
23320: PPUSH
23321: CALL_OW 388
23325: IFFALSE 23341
// KillMc ( GetUnitMc ( un ) ) ;
23327: LD_VAR 0 3
23331: PPUSH
23332: CALL_OW 388
23336: PPUSH
23337: CALL_OW 387
23341: GO 23313
23343: POP
23344: POP
// while GetTag ( 83 ) do
23345: LD_INT 83
23347: PPUSH
23348: CALL_OW 110
23352: IFFALSE 23363
// wait ( 0 0$1 ) ;
23354: LD_INT 35
23356: PPUSH
23357: CALL_OW 67
23361: GO 23345
// i := 1 ;
23363: LD_ADDR_VAR 0 4
23367: PUSH
23368: LD_INT 1
23370: ST_TO_ADDR
// for un in jammed_forces [ us ] do
23371: LD_ADDR_VAR 0 3
23375: PUSH
23376: LD_EXP 69
23380: PUSH
23381: LD_EXP 3
23385: ARRAY
23386: PUSH
23387: FOR_IN
23388: IFFALSE 23493
// begin if ( i mod 2 ) and not See ( you , un ) then
23390: LD_VAR 0 4
23394: PUSH
23395: LD_INT 2
23397: MOD
23398: PUSH
23399: LD_EXP 1
23403: PPUSH
23404: LD_VAR 0 3
23408: PPUSH
23409: CALL_OW 292
23413: NOT
23414: AND
23415: IFFALSE 23477
// begin jammed_forces := Replace ( jammed_forces , us , jammed_forces [ us ] diff un ) ;
23417: LD_ADDR_EXP 69
23421: PUSH
23422: LD_EXP 69
23426: PPUSH
23427: LD_EXP 3
23431: PPUSH
23432: LD_EXP 69
23436: PUSH
23437: LD_EXP 3
23441: ARRAY
23442: PUSH
23443: LD_VAR 0 3
23447: DIFF
23448: PPUSH
23449: CALL_OW 1
23453: ST_TO_ADDR
// KillUnit ( un ) ;
23454: LD_VAR 0 3
23458: PPUSH
23459: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23463: LD_ADDR_LOC 30
23467: PUSH
23468: LD_LOC 30
23472: PUSH
23473: LD_INT 1
23475: PLUS
23476: ST_TO_ADDR
// end ; i := i + 1 ;
23477: LD_ADDR_VAR 0 4
23481: PUSH
23482: LD_VAR 0 4
23486: PUSH
23487: LD_INT 1
23489: PLUS
23490: ST_TO_ADDR
// end ;
23491: GO 23387
23493: POP
23494: POP
// wait ( 0 0$10 ) ;
23495: LD_INT 350
23497: PPUSH
23498: CALL_OW 67
// ready_forces := Replace ( ready_forces , us , ready_forces [ us ] union jammed_forces [ us ] ) ;
23502: LD_ADDR_EXP 65
23506: PUSH
23507: LD_EXP 65
23511: PPUSH
23512: LD_EXP 3
23516: PPUSH
23517: LD_EXP 65
23521: PUSH
23522: LD_EXP 3
23526: ARRAY
23527: PUSH
23528: LD_EXP 69
23532: PUSH
23533: LD_EXP 3
23537: ARRAY
23538: UNION
23539: PPUSH
23540: CALL_OW 1
23544: ST_TO_ADDR
// let_the_war_begin ( us ) ;
23545: LD_EXP 3
23549: PPUSH
23550: CALL 22874 0 1
// end ;
23554: PPOPN 4
23556: END
// every 91 marked 223 do var list , late , un , i ;
23557: GO 23559
23559: DISABLE
23560: LD_INT 0
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
// begin wait ( 1 1$20 ) ;
23566: LD_INT 2800
23568: PPUSH
23569: CALL_OW 67
// list := FilterUnitsInArea ( ru_tinny , [ [ f_side , ru ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23573: LD_ADDR_VAR 0 1
23577: PUSH
23578: LD_INT 40
23580: PPUSH
23581: LD_INT 22
23583: PUSH
23584: LD_EXP 2
23588: PUSH
23589: EMPTY
23590: LIST
23591: LIST
23592: PUSH
23593: LD_INT 21
23595: PUSH
23596: LD_INT 2
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: PUSH
23603: LD_INT 50
23605: PUSH
23606: EMPTY
23607: LIST
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: LIST
23613: PPUSH
23614: CALL_OW 70
23618: ST_TO_ADDR
// late := jammed_forces [ ru ] isect list ;
23619: LD_ADDR_VAR 0 2
23623: PUSH
23624: LD_EXP 69
23628: PUSH
23629: LD_EXP 2
23633: ARRAY
23634: PUSH
23635: LD_VAR 0 1
23639: ISECT
23640: ST_TO_ADDR
// if not late then
23641: LD_VAR 0 2
23645: NOT
23646: IFFALSE 23672
// begin jammed_forces := Replace ( jammed_forces , ru , [ ] ) ;
23648: LD_ADDR_EXP 69
23652: PUSH
23653: LD_EXP 69
23657: PPUSH
23658: LD_EXP 2
23662: PPUSH
23663: EMPTY
23664: PPUSH
23665: CALL_OW 1
23669: ST_TO_ADDR
// exit ;
23670: GO 23950
// end ; if FilterUnitsInArea ( ru_base , [ [ f_side , you ] ] ) then
23672: LD_INT 12
23674: PPUSH
23675: LD_INT 22
23677: PUSH
23678: LD_EXP 1
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: PUSH
23687: EMPTY
23688: LIST
23689: PPUSH
23690: CALL_OW 70
23694: IFFALSE 23699
// begin enable ;
23696: ENABLE
// exit ;
23697: GO 23950
// end ; for un in late do
23699: LD_ADDR_VAR 0 3
23703: PUSH
23704: LD_VAR 0 2
23708: PUSH
23709: FOR_IN
23710: IFFALSE 23739
// if GetUnitMc ( un ) then
23712: LD_VAR 0 3
23716: PPUSH
23717: CALL_OW 388
23721: IFFALSE 23737
// KillMc ( GetUnitMc ( un ) ) ;
23723: LD_VAR 0 3
23727: PPUSH
23728: CALL_OW 388
23732: PPUSH
23733: CALL_OW 387
23737: GO 23709
23739: POP
23740: POP
// while GetTag ( 83 ) do
23741: LD_INT 83
23743: PPUSH
23744: CALL_OW 110
23748: IFFALSE 23759
// wait ( 0 0$1 ) ;
23750: LD_INT 35
23752: PPUSH
23753: CALL_OW 67
23757: GO 23741
// i := 1 ;
23759: LD_ADDR_VAR 0 4
23763: PUSH
23764: LD_INT 1
23766: ST_TO_ADDR
// for un in jammed_forces [ ru ] do
23767: LD_ADDR_VAR 0 3
23771: PUSH
23772: LD_EXP 69
23776: PUSH
23777: LD_EXP 2
23781: ARRAY
23782: PUSH
23783: FOR_IN
23784: IFFALSE 23889
// begin if ( i mod 2 ) and not See ( you , un ) then
23786: LD_VAR 0 4
23790: PUSH
23791: LD_INT 2
23793: MOD
23794: PUSH
23795: LD_EXP 1
23799: PPUSH
23800: LD_VAR 0 3
23804: PPUSH
23805: CALL_OW 292
23809: NOT
23810: AND
23811: IFFALSE 23873
// begin jammed_forces := Replace ( jammed_forces , ru , jammed_forces [ ru ] diff un ) ;
23813: LD_ADDR_EXP 69
23817: PUSH
23818: LD_EXP 69
23822: PPUSH
23823: LD_EXP 2
23827: PPUSH
23828: LD_EXP 69
23832: PUSH
23833: LD_EXP 2
23837: ARRAY
23838: PUSH
23839: LD_VAR 0 3
23843: DIFF
23844: PPUSH
23845: CALL_OW 1
23849: ST_TO_ADDR
// KillUnit ( un ) ;
23850: LD_VAR 0 3
23854: PPUSH
23855: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23859: LD_ADDR_LOC 30
23863: PUSH
23864: LD_LOC 30
23868: PUSH
23869: LD_INT 1
23871: PLUS
23872: ST_TO_ADDR
// end ; i := i + 1 ;
23873: LD_ADDR_VAR 0 4
23877: PUSH
23878: LD_VAR 0 4
23882: PUSH
23883: LD_INT 1
23885: PLUS
23886: ST_TO_ADDR
// end ;
23887: GO 23783
23889: POP
23890: POP
// wait ( 0 0$10 ) ;
23891: LD_INT 350
23893: PPUSH
23894: CALL_OW 67
// ready_forces := Replace ( ready_forces , ru , ready_forces [ ru ] union jammed_forces [ ru ] ) ;
23898: LD_ADDR_EXP 65
23902: PUSH
23903: LD_EXP 65
23907: PPUSH
23908: LD_EXP 2
23912: PPUSH
23913: LD_EXP 65
23917: PUSH
23918: LD_EXP 2
23922: ARRAY
23923: PUSH
23924: LD_EXP 69
23928: PUSH
23929: LD_EXP 2
23933: ARRAY
23934: UNION
23935: PPUSH
23936: CALL_OW 1
23940: ST_TO_ADDR
// let_the_war_begin ( ru ) ;
23941: LD_EXP 2
23945: PPUSH
23946: CALL 22874 0 1
// end ; end_of_file
23950: PPOPN 4
23952: END
// var tech_list , weap_list , sib_list , comp_list , opto_list , bio_list , space_list ; var utech_basic , utech_weap , utech_sib , utech_comp , utech_bio , utech_space , utech_opto ; var basic_tech , upgrade_tech ; var first_technology , last_technology , recomended_technology ; export scientistic_wanted ; var all_invented ; export function init_research ; begin
23953: LD_INT 0
23955: PPUSH
// all_invented := [ false , false , false , false , false , false , false , false ] ;
23956: LD_ADDR_LOC 50
23960: PUSH
23961: LD_INT 0
23963: PUSH
23964: LD_INT 0
23966: PUSH
23967: LD_INT 0
23969: PUSH
23970: LD_INT 0
23972: PUSH
23973: LD_INT 0
23975: PUSH
23976: LD_INT 0
23978: PUSH
23979: LD_INT 0
23981: PUSH
23982: LD_INT 0
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: ST_TO_ADDR
// tech_list := [ tech_SolPow , tech_SolEng , tech_OilPow , tech_OilEng , tech_SibDet , tech_ApeLang , tech_ApePsych , tech_ApeAgres ] ;
23995: LD_ADDR_LOC 31
23999: PUSH
24000: LD_INT 35
24002: PUSH
24003: LD_INT 45
24005: PUSH
24006: LD_INT 46
24008: PUSH
24009: LD_INT 47
24011: PUSH
24012: LD_INT 20
24014: PUSH
24015: LD_INT 1
24017: PUSH
24018: LD_INT 2
24020: PUSH
24021: LD_INT 11
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: LIST
24029: LIST
24030: LIST
24031: LIST
24032: LIST
24033: ST_TO_ADDR
// weap_list := [ tech_Gatling , tech_Gun , tech_Explos , tech_AdvMet , tech_Rocket , tech_AdvRocket , tech_Bazooka , tech_Mortar , tech_AdvChassis , tech_Soporific , tech_Flame , tech_Behemoth , tech_SelfDest ] ;
24034: LD_ADDR_LOC 32
24038: PUSH
24039: LD_INT 69
24041: PUSH
24042: LD_INT 39
24044: PUSH
24045: LD_INT 42
24047: PUSH
24048: LD_INT 34
24050: PUSH
24051: LD_INT 40
24053: PUSH
24054: LD_INT 71
24056: PUSH
24057: LD_INT 44
24059: PUSH
24060: LD_INT 41
24062: PUSH
24063: LD_INT 36
24065: PUSH
24066: LD_INT 13
24068: PUSH
24069: LD_INT 70
24071: PUSH
24072: LD_INT 23
24074: PUSH
24075: LD_INT 43
24077: PUSH
24078: EMPTY
24079: LIST
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: ST_TO_ADDR
// sib_list := [ tech_SibPow , tech_SibEng , tech_SibFiss ] ;
24093: LD_ADDR_LOC 33
24097: PUSH
24098: LD_INT 21
24100: PUSH
24101: LD_INT 22
24103: PUSH
24104: LD_INT 25
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: LIST
24111: ST_TO_ADDR
// comp_list := [ tech_AI , tech_AdvAI , tech_Virus , tech_TargTeleport ] ;
24112: LD_ADDR_LOC 34
24116: PUSH
24117: LD_INT 32
24119: PUSH
24120: LD_INT 27
24122: PUSH
24123: LD_INT 33
24125: PUSH
24126: LD_INT 38
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: ST_TO_ADDR
// opto_list := [ tech_Radar , tech_LasSight , tech_RemCont , tech_Laser , tech_MatDet , tech_PartInvis , tech_RemCharge ] ;
24135: LD_ADDR_LOC 35
24139: PUSH
24140: LD_INT 6
24142: PUSH
24143: LD_INT 12
24145: PUSH
24146: LD_INT 15
24148: PUSH
24149: LD_INT 10
24151: PUSH
24152: LD_INT 7
24154: PUSH
24155: LD_INT 16
24157: PUSH
24158: LD_INT 18
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: ST_TO_ADDR
// bio_list := [ tech_ApeNeural , tech_ApeBrain , tech_StimDrugs , tech_BioDet ] ;
24170: LD_ADDR_LOC 36
24174: PUSH
24175: LD_INT 3
24177: PUSH
24178: LD_INT 4
24180: PUSH
24181: LD_INT 5
24183: PUSH
24184: LD_INT 8
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: LIST
24191: LIST
24192: ST_TO_ADDR
// space_list := [ tech_TauField , tech_Lapser , tech_LimTeleport , tech_TauRad , tech_SpacAnom ] ;
24193: LD_ADDR_LOC 37
24197: PUSH
24198: LD_INT 30
24200: PUSH
24201: LD_INT 31
24203: PUSH
24204: LD_INT 37
24206: PUSH
24207: LD_INT 28
24209: PUSH
24210: LD_INT 29
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: LIST
24219: ST_TO_ADDR
// basic_tech := [ tech_list , weap_list , sib_list , comp_list , bio_list , space_list , opto_list ] ;
24220: LD_ADDR_LOC 45
24224: PUSH
24225: LD_LOC 31
24229: PUSH
24230: LD_LOC 32
24234: PUSH
24235: LD_LOC 33
24239: PUSH
24240: LD_LOC 34
24244: PUSH
24245: LD_LOC 36
24249: PUSH
24250: LD_LOC 37
24254: PUSH
24255: LD_LOC 35
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: LIST
24264: LIST
24265: LIST
24266: LIST
24267: LIST
24268: ST_TO_ADDR
// utech_basic := [ tech_Tech1 , tech_Tech2 , tech_Tech3 ] ;
24269: LD_ADDR_LOC 38
24273: PUSH
24274: LD_INT 48
24276: PUSH
24277: LD_INT 49
24279: PUSH
24280: LD_INT 50
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: LIST
24287: ST_TO_ADDR
// utech_weap := [ tech_Weap1 , tech_Weap2 , tech_Weap3 ] ;
24288: LD_ADDR_LOC 39
24292: PUSH
24293: LD_INT 51
24295: PUSH
24296: LD_INT 52
24298: PUSH
24299: LD_INT 53
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: LIST
24306: ST_TO_ADDR
// utech_sib := [ tech_Sib1 , tech_Sib2 , tech_Sib3 ] ;
24307: LD_ADDR_LOC 40
24311: PUSH
24312: LD_INT 54
24314: PUSH
24315: LD_INT 55
24317: PUSH
24318: LD_INT 56
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: ST_TO_ADDR
// utech_comp := [ tech_Comp1 , tech_Comp2 , tech_Comp3 ] ;
24326: LD_ADDR_LOC 41
24330: PUSH
24331: LD_INT 57
24333: PUSH
24334: LD_INT 58
24336: PUSH
24337: LD_INT 59
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: ST_TO_ADDR
// utech_bio := [ tech_Bio1 , tech_Bio2 , tech_Bio3 ] ;
24345: LD_ADDR_LOC 42
24349: PUSH
24350: LD_INT 66
24352: PUSH
24353: LD_INT 67
24355: PUSH
24356: LD_INT 68
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: LIST
24363: ST_TO_ADDR
// utech_space := [ tech_ST1 , tech_ST2 , tech_ST3 ] ;
24364: LD_ADDR_LOC 43
24368: PUSH
24369: LD_INT 63
24371: PUSH
24372: LD_INT 64
24374: PUSH
24375: LD_INT 65
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: LIST
24382: ST_TO_ADDR
// utech_opto := [ tech_Opto1 , tech_Opto2 , tech_Opto3 ] ;
24383: LD_ADDR_LOC 44
24387: PUSH
24388: LD_INT 60
24390: PUSH
24391: LD_INT 61
24393: PUSH
24394: LD_INT 62
24396: PUSH
24397: EMPTY
24398: LIST
24399: LIST
24400: LIST
24401: ST_TO_ADDR
// end ;
24402: LD_VAR 0 1
24406: RET
// function init_upgrade_by_nations ( side_nation ) ; begin
24407: LD_INT 0
24409: PPUSH
// first_technology := [ tech_SolPow , tech_OilPow , tech_OilEng , tech_SibDet , tech_SibPow , tech_AI , tech_AdvAI ] ;
24410: LD_ADDR_LOC 47
24414: PUSH
24415: LD_INT 35
24417: PUSH
24418: LD_INT 46
24420: PUSH
24421: LD_INT 47
24423: PUSH
24424: LD_INT 20
24426: PUSH
24427: LD_INT 21
24429: PUSH
24430: LD_INT 32
24432: PUSH
24433: LD_INT 27
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: LIST
24442: LIST
24443: LIST
24444: ST_TO_ADDR
// last_technology := [ tech_ApeBrain , tech_Flame , tech_Soporific , tech_SibFiss ] ;
24445: LD_ADDR_LOC 48
24449: PUSH
24450: LD_INT 4
24452: PUSH
24453: LD_INT 70
24455: PUSH
24456: LD_INT 13
24458: PUSH
24459: LD_INT 25
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: ST_TO_ADDR
// recomended_technology := [ tech_Gun , tech_Tech1 , tech_Comp1 , tech_Tech2 , tech_Comp2 , tech_Tech3 , tech_Comp3 ] ;
24468: LD_ADDR_LOC 49
24472: PUSH
24473: LD_INT 39
24475: PUSH
24476: LD_INT 48
24478: PUSH
24479: LD_INT 57
24481: PUSH
24482: LD_INT 49
24484: PUSH
24485: LD_INT 58
24487: PUSH
24488: LD_INT 50
24490: PUSH
24491: LD_INT 59
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: LIST
24500: LIST
24501: LIST
24502: ST_TO_ADDR
// case side_nation of 1 :
24503: LD_VAR 0 1
24507: PUSH
24508: LD_INT 1
24510: DOUBLE
24511: EQUAL
24512: IFTRUE 24516
24514: GO 24556
24516: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_opto ] ; 2 :
24517: LD_ADDR_LOC 46
24521: PUSH
24522: LD_LOC 38
24526: PUSH
24527: LD_LOC 39
24531: PUSH
24532: LD_LOC 40
24536: PUSH
24537: LD_LOC 41
24541: PUSH
24542: LD_LOC 44
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: LIST
24551: LIST
24552: LIST
24553: ST_TO_ADDR
24554: GO 24653
24556: LD_INT 2
24558: DOUBLE
24559: EQUAL
24560: IFTRUE 24564
24562: GO 24604
24564: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_bio , utech_opto ] ; 3 :
24565: LD_ADDR_LOC 46
24569: PUSH
24570: LD_LOC 38
24574: PUSH
24575: LD_LOC 39
24579: PUSH
24580: LD_LOC 40
24584: PUSH
24585: LD_LOC 42
24589: PUSH
24590: LD_LOC 44
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: LIST
24599: LIST
24600: LIST
24601: ST_TO_ADDR
24602: GO 24653
24604: LD_INT 3
24606: DOUBLE
24607: EQUAL
24608: IFTRUE 24612
24610: GO 24652
24612: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_space ] ; end ;
24613: LD_ADDR_LOC 46
24617: PUSH
24618: LD_LOC 38
24622: PUSH
24623: LD_LOC 39
24627: PUSH
24628: LD_LOC 40
24632: PUSH
24633: LD_LOC 41
24637: PUSH
24638: LD_LOC 43
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: LIST
24649: ST_TO_ADDR
24650: GO 24653
24652: POP
// end ;
24653: LD_VAR 0 2
24657: RET
// every 0 0$5.5 do var un , active_side , active_nation , lab_list , still_researching ;
24658: GO 24660
24660: DISABLE
24661: LD_INT 0
24663: PPUSH
24664: PPUSH
24665: PPUSH
24666: PPUSH
24667: PPUSH
// begin for active_side in cpu_list do
24668: LD_ADDR_VAR 0 2
24672: PUSH
24673: LD_EXP 8
24677: PUSH
24678: FOR_IN
24679: IFFALSE 24788
// begin still_researching := false ;
24681: LD_ADDR_VAR 0 5
24685: PUSH
24686: LD_INT 0
24688: ST_TO_ADDR
// lab_list := get_labs ( active_side ) ;
24689: LD_ADDR_VAR 0 4
24693: PUSH
24694: LD_VAR 0 2
24698: PPUSH
24699: CALL 24875 0 1
24703: ST_TO_ADDR
// for un in lab_list do
24704: LD_ADDR_VAR 0 1
24708: PUSH
24709: LD_VAR 0 4
24713: PUSH
24714: FOR_IN
24715: IFFALSE 24742
// if BuildingStatus ( un ) = bs_working then
24717: LD_VAR 0 1
24721: PPUSH
24722: CALL_OW 461
24726: PUSH
24727: LD_INT 3
24729: EQUAL
24730: IFFALSE 24740
// still_researching := true ;
24732: LD_ADDR_VAR 0 5
24736: PUSH
24737: LD_INT 1
24739: ST_TO_ADDR
24740: GO 24714
24742: POP
24743: POP
// active_nation := GetCPUNation ( active_side ) ;
24744: LD_ADDR_VAR 0 3
24748: PUSH
24749: LD_VAR 0 2
24753: PPUSH
24754: CALL 26476 0 1
24758: ST_TO_ADDR
// if ( not still_researching ) and active_nation then
24759: LD_VAR 0 5
24763: NOT
24764: PUSH
24765: LD_VAR 0 3
24769: AND
24770: IFFALSE 24786
// start_new_research ( active_side , active_nation ) ;
24772: LD_VAR 0 2
24776: PPUSH
24777: LD_VAR 0 3
24781: PPUSH
24782: CALL 24948 0 2
// end ;
24786: GO 24678
24788: POP
24789: POP
// if ( cpu_list ) and ( not all_cpu_invented ) then
24790: LD_EXP 8
24794: PUSH
24795: CALL 24807 0 0
24799: NOT
24800: AND
24801: IFFALSE 24804
// enable ;
24803: ENABLE
// end ;
24804: PPOPN 5
24806: END
// function all_cpu_invented ; var un , vysledek ; begin
24807: LD_INT 0
24809: PPUSH
24810: PPUSH
24811: PPUSH
// vysledek := true ;
24812: LD_ADDR_VAR 0 3
24816: PUSH
24817: LD_INT 1
24819: ST_TO_ADDR
// for un in cpu_list do
24820: LD_ADDR_VAR 0 2
24824: PUSH
24825: LD_EXP 8
24829: PUSH
24830: FOR_IN
24831: IFFALSE 24858
// if not all_invented [ un ] then
24833: LD_LOC 50
24837: PUSH
24838: LD_VAR 0 2
24842: ARRAY
24843: NOT
24844: IFFALSE 24856
// begin vysledek := false ;
24846: LD_ADDR_VAR 0 3
24850: PUSH
24851: LD_INT 0
24853: ST_TO_ADDR
// break ;
24854: GO 24858
// end ;
24856: GO 24830
24858: POP
24859: POP
// result := vysledek ;
24860: LD_ADDR_VAR 0 1
24864: PUSH
24865: LD_VAR 0 3
24869: ST_TO_ADDR
// end ;
24870: LD_VAR 0 1
24874: RET
// function get_labs ( side ) ; var lab_list ; begin
24875: LD_INT 0
24877: PPUSH
24878: PPUSH
// lab_list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
24879: LD_ADDR_VAR 0 3
24883: PUSH
24884: LD_INT 22
24886: PUSH
24887: LD_VAR 0 1
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: LD_INT 2
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: LD_INT 8
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 30
24911: PUSH
24912: LD_INT 6
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PPUSH
24928: CALL_OW 69
24932: ST_TO_ADDR
// result := lab_list ;
24933: LD_ADDR_VAR 0 2
24937: PUSH
24938: LD_VAR 0 3
24942: ST_TO_ADDR
// end ;
24943: LD_VAR 0 2
24947: RET
// function start_new_research ( side , nation ) ; var lab_list , possible , to_research , lab , scientistic ; begin
24948: LD_INT 0
24950: PPUSH
24951: PPUSH
24952: PPUSH
24953: PPUSH
24954: PPUSH
24955: PPUSH
// scientistic := request_people ( side , class_scientistic , 1 ) ;
24956: LD_ADDR_VAR 0 8
24960: PUSH
24961: LD_VAR 0 1
24965: PPUSH
24966: LD_INT 4
24968: PPUSH
24969: LD_INT 1
24971: PPUSH
24972: CALL 26408 0 3
24976: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
24977: LD_ADDR_VAR 0 4
24981: PUSH
24982: LD_VAR 0 1
24986: PPUSH
24987: CALL 24875 0 1
24991: ST_TO_ADDR
// init_upgrade_by_nations ( nation ) ;
24992: LD_VAR 0 2
24996: PPUSH
24997: CALL 24407 0 1
// possible := get_possible_research ( side ) ;
25001: LD_ADDR_VAR 0 5
25005: PUSH
25006: LD_VAR 0 1
25010: PPUSH
25011: CALL 25095 0 1
25015: ST_TO_ADDR
// to_research := select_next_technology ( side , possible ) ;
25016: LD_ADDR_VAR 0 6
25020: PUSH
25021: LD_VAR 0 1
25025: PPUSH
25026: LD_VAR 0 5
25030: PPUSH
25031: CALL 25546 0 2
25035: ST_TO_ADDR
// lab := research_possible ( side , to_research ) ;
25036: LD_ADDR_VAR 0 7
25040: PUSH
25041: LD_VAR 0 1
25045: PPUSH
25046: LD_VAR 0 6
25050: PPUSH
25051: CALL 26105 0 2
25055: ST_TO_ADDR
// if lab then
25056: LD_VAR 0 7
25060: IFFALSE 25090
// begin transfer_scientistic ( scientistic , lab ) ;
25062: LD_VAR 0 8
25066: PPUSH
25067: LD_VAR 0 7
25071: PPUSH
25072: CALL 26226 0 2
// begin_of_research ( lab , to_research ) ;
25076: LD_VAR 0 7
25080: PPUSH
25081: LD_VAR 0 6
25085: PPUSH
25086: CALL 26334 0 2
// end ; end ;
25090: LD_VAR 0 3
25094: RET
// function get_possible_research ( side ) ; var un , vysledek , lab_list , upgrade ; begin
25095: LD_INT 0
25097: PPUSH
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
// vysledek := [ ] ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: EMPTY
25108: ST_TO_ADDR
// upgrade := [ ] ;
25109: LD_ADDR_VAR 0 6
25113: PUSH
25114: EMPTY
25115: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25116: LD_ADDR_VAR 0 5
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL 24875 0 1
25130: ST_TO_ADDR
// for un in lab_list do
25131: LD_ADDR_VAR 0 3
25135: PUSH
25136: LD_VAR 0 5
25140: PUSH
25141: FOR_IN
25142: IFFALSE 25184
// upgrade := upgrade ^ GetLabKind ( un , 1 ) ^ GetLabKind ( un , 2 ) ;
25144: LD_ADDR_VAR 0 6
25148: PUSH
25149: LD_VAR 0 6
25153: PUSH
25154: LD_VAR 0 3
25158: PPUSH
25159: LD_INT 1
25161: PPUSH
25162: CALL_OW 268
25166: ADD
25167: PUSH
25168: LD_VAR 0 3
25172: PPUSH
25173: LD_INT 2
25175: PPUSH
25176: CALL_OW 268
25180: ADD
25181: ST_TO_ADDR
25182: GO 25141
25184: POP
25185: POP
// for un in upgrade do
25186: LD_ADDR_VAR 0 3
25190: PUSH
25191: LD_VAR 0 6
25195: PUSH
25196: FOR_IN
25197: IFFALSE 25221
// vysledek := vysledek ^ ( un - 8 ) ;
25199: LD_ADDR_VAR 0 4
25203: PUSH
25204: LD_VAR 0 4
25208: PUSH
25209: LD_VAR 0 3
25213: PUSH
25214: LD_INT 8
25216: MINUS
25217: ADD
25218: ST_TO_ADDR
25219: GO 25196
25221: POP
25222: POP
// result := vysledek ;
25223: LD_ADDR_VAR 0 2
25227: PUSH
25228: LD_VAR 0 4
25232: ST_TO_ADDR
// end ;
25233: LD_VAR 0 2
25237: RET
// function shake_it_baby ( list ) ; var vysledek , pom , i , n ; begin
25238: LD_INT 0
25240: PPUSH
25241: PPUSH
25242: PPUSH
25243: PPUSH
25244: PPUSH
// vysledek := [ ] ;
25245: LD_ADDR_VAR 0 3
25249: PUSH
25250: EMPTY
25251: ST_TO_ADDR
// for i = 1 to list do
25252: LD_ADDR_VAR 0 5
25256: PUSH
25257: DOUBLE
25258: LD_INT 1
25260: DEC
25261: ST_TO_ADDR
25262: LD_VAR 0 1
25266: PUSH
25267: FOR_TO
25268: IFFALSE 25342
// begin n := Rand ( 1 , list ) ;
25270: LD_ADDR_VAR 0 6
25274: PUSH
25275: LD_INT 1
25277: PPUSH
25278: LD_VAR 0 1
25282: PPUSH
25283: CALL_OW 12
25287: ST_TO_ADDR
// pom := list [ n ] ;
25288: LD_ADDR_VAR 0 4
25292: PUSH
25293: LD_VAR 0 1
25297: PUSH
25298: LD_VAR 0 6
25302: ARRAY
25303: ST_TO_ADDR
// list := Delete ( list , n ) ;
25304: LD_ADDR_VAR 0 1
25308: PUSH
25309: LD_VAR 0 1
25313: PPUSH
25314: LD_VAR 0 6
25318: PPUSH
25319: CALL_OW 3
25323: ST_TO_ADDR
// vysledek := vysledek ^ pom ;
25324: LD_ADDR_VAR 0 3
25328: PUSH
25329: LD_VAR 0 3
25333: PUSH
25334: LD_VAR 0 4
25338: ADD
25339: ST_TO_ADDR
// end ;
25340: GO 25267
25342: POP
25343: POP
// result := vysledek ;
25344: LD_ADDR_VAR 0 2
25348: PUSH
25349: LD_VAR 0 3
25353: ST_TO_ADDR
// end ;
25354: LD_VAR 0 2
25358: RET
// function GetBasicTechnology ; var list , un , vysledek ; begin
25359: LD_INT 0
25361: PPUSH
25362: PPUSH
25363: PPUSH
25364: PPUSH
// list := [ ] ;
25365: LD_ADDR_VAR 0 2
25369: PUSH
25370: EMPTY
25371: ST_TO_ADDR
// for un in basic_tech do
25372: LD_ADDR_VAR 0 3
25376: PUSH
25377: LD_LOC 45
25381: PUSH
25382: FOR_IN
25383: IFFALSE 25412
// if un then
25385: LD_VAR 0 3
25389: IFFALSE 25410
// list := list ^ [ un ] ;
25391: LD_ADDR_VAR 0 2
25395: PUSH
25396: LD_VAR 0 2
25400: PUSH
25401: LD_VAR 0 3
25405: PUSH
25406: EMPTY
25407: LIST
25408: ADD
25409: ST_TO_ADDR
25410: GO 25382
25412: POP
25413: POP
// if list > 1 then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_INT 1
25421: GREATER
25422: IFFALSE 25439
// vysledek := shake_it_baby ( list ) ;
25424: LD_ADDR_VAR 0 4
25428: PUSH
25429: LD_VAR 0 2
25433: PPUSH
25434: CALL 25238 0 1
25438: ST_TO_ADDR
// result := vysledek ;
25439: LD_ADDR_VAR 0 1
25443: PUSH
25444: LD_VAR 0 4
25448: ST_TO_ADDR
// end ;
25449: LD_VAR 0 1
25453: RET
// function GetUpgradeTechnology ; var list , un , vysledek ; begin
25454: LD_INT 0
25456: PPUSH
25457: PPUSH
25458: PPUSH
25459: PPUSH
// vysledek := [ ] ;
25460: LD_ADDR_VAR 0 4
25464: PUSH
25465: EMPTY
25466: ST_TO_ADDR
// list := [ ] ;
25467: LD_ADDR_VAR 0 2
25471: PUSH
25472: EMPTY
25473: ST_TO_ADDR
// for un in upgrade_tech do
25474: LD_ADDR_VAR 0 3
25478: PUSH
25479: LD_LOC 46
25483: PUSH
25484: FOR_IN
25485: IFFALSE 25514
// if un then
25487: LD_VAR 0 3
25491: IFFALSE 25512
// list := list ^ [ un ] ;
25493: LD_ADDR_VAR 0 2
25497: PUSH
25498: LD_VAR 0 2
25502: PUSH
25503: LD_VAR 0 3
25507: PUSH
25508: EMPTY
25509: LIST
25510: ADD
25511: ST_TO_ADDR
25512: GO 25484
25514: POP
25515: POP
// vysledek := shake_it_baby ( list ) ;
25516: LD_ADDR_VAR 0 4
25520: PUSH
25521: LD_VAR 0 2
25525: PPUSH
25526: CALL 25238 0 1
25530: ST_TO_ADDR
// result := vysledek ;
25531: LD_ADDR_VAR 0 1
25535: PUSH
25536: LD_VAR 0 4
25540: ST_TO_ADDR
// end ;
25541: LD_VAR 0 1
25545: RET
// function select_next_technology ( side , possible ) ; var un , pom , new , vysledek , select ; begin
25546: LD_INT 0
25548: PPUSH
25549: PPUSH
25550: PPUSH
25551: PPUSH
25552: PPUSH
25553: PPUSH
// new := true ;
25554: LD_ADDR_VAR 0 6
25558: PUSH
25559: LD_INT 1
25561: ST_TO_ADDR
// vysledek := [ ] ;
25562: LD_ADDR_VAR 0 7
25566: PUSH
25567: EMPTY
25568: ST_TO_ADDR
// select := [ ] ;
25569: LD_ADDR_VAR 0 8
25573: PUSH
25574: EMPTY
25575: ST_TO_ADDR
// for un in first_technology do
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_LOC 47
25585: PUSH
25586: FOR_IN
25587: IFFALSE 25629
// begin pom := research_possible ( side , un ) ;
25589: LD_ADDR_VAR 0 5
25593: PUSH
25594: LD_VAR 0 1
25598: PPUSH
25599: LD_VAR 0 4
25603: PPUSH
25604: CALL 26105 0 2
25608: ST_TO_ADDR
// if pom then
25609: LD_VAR 0 5
25613: IFFALSE 25627
// begin vysledek := un ;
25615: LD_ADDR_VAR 0 7
25619: PUSH
25620: LD_VAR 0 4
25624: ST_TO_ADDR
// break ;
25625: GO 25629
// end ; end ;
25627: GO 25586
25629: POP
25630: POP
// if not first_technology then
25631: LD_LOC 47
25635: NOT
25636: IFFALSE 25646
// new := false ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_INT 0
25645: ST_TO_ADDR
// if not vysledek and ( Rand ( 0 , 10 ) < 3 ) then
25646: LD_VAR 0 7
25650: NOT
25651: PUSH
25652: LD_INT 0
25654: PPUSH
25655: LD_INT 10
25657: PPUSH
25658: CALL_OW 12
25662: PUSH
25663: LD_INT 3
25665: LESS
25666: AND
25667: IFFALSE 25724
// for un in recomended_technology do
25669: LD_ADDR_VAR 0 4
25673: PUSH
25674: LD_LOC 49
25678: PUSH
25679: FOR_IN
25680: IFFALSE 25722
// begin pom := research_possible ( side , un ) ;
25682: LD_ADDR_VAR 0 5
25686: PUSH
25687: LD_VAR 0 1
25691: PPUSH
25692: LD_VAR 0 4
25696: PPUSH
25697: CALL 26105 0 2
25701: ST_TO_ADDR
// if pom then
25702: LD_VAR 0 5
25706: IFFALSE 25720
// begin vysledek := un ;
25708: LD_ADDR_VAR 0 7
25712: PUSH
25713: LD_VAR 0 4
25717: ST_TO_ADDR
// break ;
25718: GO 25722
// end ; end ;
25720: GO 25679
25722: POP
25723: POP
// if not recomended_technology then
25724: LD_LOC 49
25728: NOT
25729: IFFALSE 25739
// new := false ;
25731: LD_ADDR_VAR 0 6
25735: PUSH
25736: LD_INT 0
25738: ST_TO_ADDR
// if not vysledek then
25739: LD_VAR 0 7
25743: NOT
25744: IFFALSE 25831
// begin select := GetBasicTechnology ;
25746: LD_ADDR_VAR 0 8
25750: PUSH
25751: CALL 25359 0 0
25755: ST_TO_ADDR
// for un in select do
25756: LD_ADDR_VAR 0 4
25760: PUSH
25761: LD_VAR 0 8
25765: PUSH
25766: FOR_IN
25767: IFFALSE 25829
// begin pom := [ ] ;
25769: LD_ADDR_VAR 0 5
25773: PUSH
25774: EMPTY
25775: ST_TO_ADDR
// if not un in last_technology then
25776: LD_VAR 0 4
25780: PUSH
25781: LD_LOC 48
25785: IN
25786: NOT
25787: IFFALSE 25809
// pom := research_possible ( side , un ) ;
25789: LD_ADDR_VAR 0 5
25793: PUSH
25794: LD_VAR 0 1
25798: PPUSH
25799: LD_VAR 0 4
25803: PPUSH
25804: CALL 26105 0 2
25808: ST_TO_ADDR
// if pom then
25809: LD_VAR 0 5
25813: IFFALSE 25827
// begin vysledek := un ;
25815: LD_ADDR_VAR 0 7
25819: PUSH
25820: LD_VAR 0 4
25824: ST_TO_ADDR
// break ;
25825: GO 25829
// end ; end ;
25827: GO 25766
25829: POP
25830: POP
// end ; if not select then
25831: LD_VAR 0 8
25835: NOT
25836: IFFALSE 25846
// new := false ;
25838: LD_ADDR_VAR 0 6
25842: PUSH
25843: LD_INT 0
25845: ST_TO_ADDR
// if not vysledek then
25846: LD_VAR 0 7
25850: NOT
25851: IFFALSE 25938
// begin select := GetUpgradeTechnology ;
25853: LD_ADDR_VAR 0 8
25857: PUSH
25858: CALL 25454 0 0
25862: ST_TO_ADDR
// for un in select do
25863: LD_ADDR_VAR 0 4
25867: PUSH
25868: LD_VAR 0 8
25872: PUSH
25873: FOR_IN
25874: IFFALSE 25936
// begin pom := [ ] ;
25876: LD_ADDR_VAR 0 5
25880: PUSH
25881: EMPTY
25882: ST_TO_ADDR
// if not un in last_technology then
25883: LD_VAR 0 4
25887: PUSH
25888: LD_LOC 48
25892: IN
25893: NOT
25894: IFFALSE 25916
// pom := research_possible ( side , un ) ;
25896: LD_ADDR_VAR 0 5
25900: PUSH
25901: LD_VAR 0 1
25905: PPUSH
25906: LD_VAR 0 4
25910: PPUSH
25911: CALL 26105 0 2
25915: ST_TO_ADDR
// if pom then
25916: LD_VAR 0 5
25920: IFFALSE 25934
// begin vysledek := un ;
25922: LD_ADDR_VAR 0 7
25926: PUSH
25927: LD_VAR 0 4
25931: ST_TO_ADDR
// break ;
25932: GO 25936
// end ; end ;
25934: GO 25873
25936: POP
25937: POP
// end ; if not select then
25938: LD_VAR 0 8
25942: NOT
25943: IFFALSE 25953
// new := false ;
25945: LD_ADDR_VAR 0 6
25949: PUSH
25950: LD_INT 0
25952: ST_TO_ADDR
// if not vysledek then
25953: LD_VAR 0 7
25957: NOT
25958: IFFALSE 26015
// for un in last_technology do
25960: LD_ADDR_VAR 0 4
25964: PUSH
25965: LD_LOC 48
25969: PUSH
25970: FOR_IN
25971: IFFALSE 26013
// begin pom := research_possible ( side , un ) ;
25973: LD_ADDR_VAR 0 5
25977: PUSH
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_VAR 0 4
25987: PPUSH
25988: CALL 26105 0 2
25992: ST_TO_ADDR
// if pom then
25993: LD_VAR 0 5
25997: IFFALSE 26011
// begin vysledek := un ;
25999: LD_ADDR_VAR 0 7
26003: PUSH
26004: LD_VAR 0 4
26008: ST_TO_ADDR
// break ;
26009: GO 26013
// end ; end ;
26011: GO 25970
26013: POP
26014: POP
// if not last_technology then
26015: LD_LOC 48
26019: NOT
26020: IFFALSE 26030
// new := false ;
26022: LD_ADDR_VAR 0 6
26026: PUSH
26027: LD_INT 0
26029: ST_TO_ADDR
// if not ( vysledek or new ) then
26030: LD_VAR 0 7
26034: PUSH
26035: LD_VAR 0 6
26039: OR
26040: NOT
26041: IFFALSE 26090
// begin all_invented := Insert ( all_invented , side , true ) ;
26043: LD_ADDR_LOC 50
26047: PUSH
26048: LD_LOC 50
26052: PPUSH
26053: LD_VAR 0 1
26057: PPUSH
26058: LD_INT 1
26060: PPUSH
26061: CALL_OW 2
26065: ST_TO_ADDR
// all_invented := Delete ( all_invented , side + 1 ) ;
26066: LD_ADDR_LOC 50
26070: PUSH
26071: LD_LOC 50
26075: PPUSH
26076: LD_VAR 0 1
26080: PUSH
26081: LD_INT 1
26083: PLUS
26084: PPUSH
26085: CALL_OW 3
26089: ST_TO_ADDR
// end ; result := vysledek ;
26090: LD_ADDR_VAR 0 3
26094: PUSH
26095: LD_VAR 0 7
26099: ST_TO_ADDR
// end ;
26100: LD_VAR 0 3
26104: RET
// function research_possible ( side , tech ) ; var un , vysledek , lab_list ; begin
26105: LD_INT 0
26107: PPUSH
26108: PPUSH
26109: PPUSH
26110: PPUSH
// lab_list := get_labs ( side ) ;
26111: LD_ADDR_VAR 0 6
26115: PUSH
26116: LD_VAR 0 1
26120: PPUSH
26121: CALL 24875 0 1
26125: ST_TO_ADDR
// if GetTech ( tech , side ) in [ state_disabled , state_researched ] then
26126: LD_VAR 0 2
26130: PPUSH
26131: LD_VAR 0 1
26135: PPUSH
26136: CALL_OW 321
26140: PUSH
26141: LD_INT 0
26143: PUSH
26144: LD_INT 2
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: IN
26151: IFFALSE 26162
// vysledek := [ ] else
26153: LD_ADDR_VAR 0 5
26157: PUSH
26158: EMPTY
26159: ST_TO_ADDR
26160: GO 26211
// for un in lab_list do
26162: LD_ADDR_VAR 0 4
26166: PUSH
26167: LD_VAR 0 6
26171: PUSH
26172: FOR_IN
26173: IFFALSE 26209
// if CanBeResearched ( un , tech ) then
26175: LD_VAR 0 4
26179: PPUSH
26180: LD_VAR 0 2
26184: PPUSH
26185: CALL_OW 430
26189: IFFALSE 26207
// vysledek := vysledek ^ un ;
26191: LD_ADDR_VAR 0 5
26195: PUSH
26196: LD_VAR 0 5
26200: PUSH
26201: LD_VAR 0 4
26205: ADD
26206: ST_TO_ADDR
26207: GO 26172
26209: POP
26210: POP
// result := vysledek ;
26211: LD_ADDR_VAR 0 3
26215: PUSH
26216: LD_VAR 0 5
26220: ST_TO_ADDR
// end ;
26221: LD_VAR 0 3
26225: RET
// function transfer_scientistic ( scients , to_lab ) ; var un , i ; begin
26226: LD_INT 0
26228: PPUSH
26229: PPUSH
26230: PPUSH
// i = 1 ;
26231: LD_ADDR_VAR 0 5
26235: PUSH
26236: LD_INT 1
26238: ST_TO_ADDR
// to_lab := to_lab diff [ 0 ] ;
26239: LD_ADDR_VAR 0 2
26243: PUSH
26244: LD_VAR 0 2
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: EMPTY
26253: LIST
26254: DIFF
26255: ST_TO_ADDR
// for un in scients do
26256: LD_ADDR_VAR 0 4
26260: PUSH
26261: LD_VAR 0 1
26265: PUSH
26266: FOR_IN
26267: IFFALSE 26315
// begin ComEnterUnit ( un , to_lab [ ( i mod to_lab ) + 1 ] ) ;
26269: LD_VAR 0 4
26273: PPUSH
26274: LD_VAR 0 2
26278: PUSH
26279: LD_VAR 0 5
26283: PUSH
26284: LD_VAR 0 2
26288: MOD
26289: PUSH
26290: LD_INT 1
26292: PLUS
26293: ARRAY
26294: PPUSH
26295: CALL_OW 120
// i := i + 1 ;
26299: LD_ADDR_VAR 0 5
26303: PUSH
26304: LD_VAR 0 5
26308: PUSH
26309: LD_INT 1
26311: PLUS
26312: ST_TO_ADDR
// end ;
26313: GO 26266
26315: POP
26316: POP
// AddComChangeProfession ( scients , class_scientistic ) ;
26317: LD_VAR 0 1
26321: PPUSH
26322: LD_INT 4
26324: PPUSH
26325: CALL_OW 183
// end ;
26329: LD_VAR 0 3
26333: RET
// function begin_of_research ( lab , to_research ) ; begin
26334: LD_INT 0
26336: PPUSH
// ComResearch ( lab , to_research ) ;
26337: LD_VAR 0 1
26341: PPUSH
26342: LD_VAR 0 2
26346: PPUSH
26347: CALL_OW 124
// end ; end_of_file
26351: LD_VAR 0 3
26355: RET
// export reserved_people ; var vysledek ; export function init_distribution ; var un ; begin
26356: LD_INT 0
26358: PPUSH
26359: PPUSH
// reserved_people := [ ] ;
26360: LD_ADDR_EXP 71
26364: PUSH
26365: EMPTY
26366: ST_TO_ADDR
// for un = 1 to 8 do
26367: LD_ADDR_VAR 0 2
26371: PUSH
26372: DOUBLE
26373: LD_INT 1
26375: DEC
26376: ST_TO_ADDR
26377: LD_INT 8
26379: PUSH
26380: FOR_TO
26381: IFFALSE 26401
// reserved_people := reserved_people ^ [ [ ] ] ;
26383: LD_ADDR_EXP 71
26387: PUSH
26388: LD_EXP 71
26392: PUSH
26393: EMPTY
26394: PUSH
26395: EMPTY
26396: LIST
26397: ADD
26398: ST_TO_ADDR
26399: GO 26380
26401: POP
26402: POP
// end ;
26403: LD_VAR 0 1
26407: RET
// export function request_people ( side , man_class , priority ) ; begin
26408: LD_INT 0
26410: PPUSH
// vysledek := FilterAllUnits ( [ [ f_side , side ] , [ f_class , man_class ] ] ) diff reserved_people [ side ] ;
26411: LD_ADDR_LOC 51
26415: PUSH
26416: LD_INT 22
26418: PUSH
26419: LD_VAR 0 1
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 25
26430: PUSH
26431: LD_VAR 0 2
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PPUSH
26444: CALL_OW 69
26448: PUSH
26449: LD_EXP 71
26453: PUSH
26454: LD_VAR 0 1
26458: ARRAY
26459: DIFF
26460: ST_TO_ADDR
// result := vysledek ;
26461: LD_ADDR_VAR 0 4
26465: PUSH
26466: LD_LOC 51
26470: ST_TO_ADDR
// end ;
26471: LD_VAR 0 4
26475: RET
// export function GetCPUNation ( side ) ; var un , vysledek ; begin
26476: LD_INT 0
26478: PPUSH
26479: PPUSH
26480: PPUSH
// un := FilterAllUnits ( [ [ f_side , side ] ] ) ;
26481: LD_ADDR_VAR 0 3
26485: PUSH
26486: LD_INT 22
26488: PUSH
26489: LD_VAR 0 1
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: PPUSH
26501: CALL_OW 69
26505: ST_TO_ADDR
// if un then
26506: LD_VAR 0 3
26510: IFFALSE 26533
// vysledek := GetSide ( un [ 1 ] ) else
26512: LD_ADDR_VAR 0 4
26516: PUSH
26517: LD_VAR 0 3
26521: PUSH
26522: LD_INT 1
26524: ARRAY
26525: PPUSH
26526: CALL_OW 255
26530: ST_TO_ADDR
26531: GO 26541
// vysledek := false ;
26533: LD_ADDR_VAR 0 4
26537: PUSH
26538: LD_INT 0
26540: ST_TO_ADDR
// result := vysledek ;
26541: LD_ADDR_VAR 0 2
26545: PUSH
26546: LD_VAR 0 4
26550: ST_TO_ADDR
// end ; end_of_file
26551: LD_VAR 0 2
26555: RET
// var us_weapons , ar_weapons , ru_weapons ; var sib_engine , oil_engine ; var prefered ; var main_extensions ; var hovers_recomended , flat_land ; export mechanics_wanted , extension_wanted ; function init_priority ( side , side_nation ) ; var us_main_control ; begin
26556: LD_INT 0
26558: PPUSH
26559: PPUSH
// us_main_control := b_ext_computer ;
26560: LD_ADDR_VAR 0 4
26564: PUSH
26565: LD_INT 24
26567: ST_TO_ADDR
// prefered_control := control_computer ;
26568: LD_ADDR_EXP 59
26572: PUSH
26573: LD_INT 3
26575: ST_TO_ADDR
// case side_nation of 1 :
26576: LD_VAR 0 2
26580: PUSH
26581: LD_INT 1
26583: DOUBLE
26584: EQUAL
26585: IFTRUE 26589
26587: GO 26621
26589: POP
// main_extensions := [ b_ext_track , b_ext_siberium , b_ext_laser , b_ext_rocket , us_main_control ] ; 2 :
26590: LD_ADDR_LOC 58
26594: PUSH
26595: LD_INT 16
26597: PUSH
26598: LD_INT 21
26600: PUSH
26601: LD_INT 25
26603: PUSH
26604: LD_INT 18
26606: PUSH
26607: LD_VAR 0 4
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: LIST
26618: ST_TO_ADDR
26619: GO 26698
26621: LD_INT 2
26623: DOUBLE
26624: EQUAL
26625: IFTRUE 26629
26627: GO 26659
26629: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar , b_ext_siberium ] ; 3 :
26630: LD_ADDR_LOC 58
26634: PUSH
26635: LD_INT 16
26637: PUSH
26638: LD_INT 17
26640: PUSH
26641: LD_INT 18
26643: PUSH
26644: LD_INT 20
26646: PUSH
26647: LD_INT 21
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: ST_TO_ADDR
26657: GO 26698
26659: LD_INT 3
26661: DOUBLE
26662: EQUAL
26663: IFTRUE 26667
26665: GO 26697
26667: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ; end ;
26668: LD_ADDR_LOC 58
26672: PUSH
26673: LD_INT 16
26675: PUSH
26676: LD_INT 17
26678: PUSH
26679: LD_INT 18
26681: PUSH
26682: LD_INT 24
26684: PUSH
26685: LD_INT 21
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: LIST
26692: LIST
26693: LIST
26694: ST_TO_ADDR
26695: GO 26698
26697: POP
// end ;
26698: LD_VAR 0 3
26702: RET
// export function init_manufacture ; begin
26703: LD_INT 0
26705: PPUSH
// hovers_recomended := false ;
26706: LD_ADDR_LOC 59
26710: PUSH
26711: LD_INT 0
26713: ST_TO_ADDR
// flat_land := false ;
26714: LD_ADDR_LOC 60
26718: PUSH
26719: LD_INT 0
26721: ST_TO_ADDR
// sib_engine := 10 ;
26722: LD_ADDR_LOC 55
26726: PUSH
26727: LD_INT 10
26729: ST_TO_ADDR
// oil_engine := 30 ;
26730: LD_ADDR_LOC 56
26734: PUSH
26735: LD_INT 30
26737: ST_TO_ADDR
// us_weapons := [ [ [ us_machine_gun , [ ] , 0 ] , [ us_light_gun , [ tech_Gun ] , b_ext_gun ] , [ us_radar , [ tech_Radar ] , b_ext_radar ] , [ us_crane , [ ] , b_ext_noncombat ] ] , [ [ us_gatling_gun , [ tech_Gatling ] , 0 ] , [ us_double_gun , [ tech_Gun ] , b_ext_gun ] , [ us_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ us_laser , [ tech_Laser ] , b_ext_laser ] , [ us_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ us_bulldozer , [ ] , b_ext_noncombat ] , [ us_siberium_rocket , [ tech_SibEng , tech_Rocket ] , b_ext_siberium ] , [ us_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] ] ] ;
26738: LD_ADDR_LOC 52
26742: PUSH
26743: LD_INT 2
26745: PUSH
26746: EMPTY
26747: PUSH
26748: LD_INT 0
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 3
26758: PUSH
26759: LD_INT 39
26761: PUSH
26762: EMPTY
26763: LIST
26764: PUSH
26765: LD_INT 17
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: LIST
26772: PUSH
26773: LD_INT 11
26775: PUSH
26776: LD_INT 6
26778: PUSH
26779: EMPTY
26780: LIST
26781: PUSH
26782: LD_INT 20
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 13
26792: PUSH
26793: EMPTY
26794: PUSH
26795: LD_INT 19
26797: PUSH
26798: EMPTY
26799: LIST
26800: LIST
26801: LIST
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: LIST
26807: LIST
26808: PUSH
26809: LD_INT 4
26811: PUSH
26812: LD_INT 69
26814: PUSH
26815: EMPTY
26816: LIST
26817: PUSH
26818: LD_INT 0
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 5
26828: PUSH
26829: LD_INT 39
26831: PUSH
26832: EMPTY
26833: LIST
26834: PUSH
26835: LD_INT 17
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 7
26845: PUSH
26846: LD_INT 40
26848: PUSH
26849: EMPTY
26850: LIST
26851: PUSH
26852: LD_INT 18
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: LIST
26859: PUSH
26860: LD_INT 9
26862: PUSH
26863: LD_INT 10
26865: PUSH
26866: EMPTY
26867: LIST
26868: PUSH
26869: LD_INT 25
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 12
26879: PUSH
26880: EMPTY
26881: PUSH
26882: LD_INT 19
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: LIST
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 14
26899: PUSH
26900: EMPTY
26901: PUSH
26902: LD_INT 19
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 8
26912: PUSH
26913: LD_INT 22
26915: PUSH
26916: LD_INT 40
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 21
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 6
26933: PUSH
26934: LD_INT 34
26936: PUSH
26937: EMPTY
26938: LIST
26939: PUSH
26940: LD_INT 17
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: LIST
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: LIST
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: LIST
26957: ST_TO_ADDR
// ar_weapons := [ [ [ ar_multimissile_ballista , [ ] , 0 ] , [ ar_double_machine_gun , [ ] , 0 ] , [ ar_light_gun , [ tech_Gun ] , b_ext_gun ] ] , [ [ ar_gatling_gun , [ tech_Gatling ] , 0 ] , [ ar_flame_thrower , [ tech_Flame ] , b_ext_stitch ] , [ ar_gun , [ tech_Gun ] , b_ext_gun ] , [ ar_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ar_selfpropelled_bomb , [ tech_Explos ] , b_ext_siberium ] , [ ar_radar , [ tech_Radar ] , b_ext_radar ] , [ ar_control_tower , [ tech_RemCont ] , b_ext_radar ] , [ ar_cargo_bay , [ ] , b_ext_stitch ] ] , [ ] ] ;
26958: LD_ADDR_LOC 53
26962: PUSH
26963: LD_INT 22
26965: PUSH
26966: EMPTY
26967: PUSH
26968: LD_INT 0
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 24
26978: PUSH
26979: EMPTY
26980: PUSH
26981: LD_INT 0
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: LIST
26988: PUSH
26989: LD_INT 23
26991: PUSH
26992: LD_INT 39
26994: PUSH
26995: EMPTY
26996: LIST
26997: PUSH
26998: LD_INT 17
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: LIST
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: LIST
27010: PUSH
27011: LD_INT 25
27013: PUSH
27014: LD_INT 69
27016: PUSH
27017: EMPTY
27018: LIST
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: LIST
27027: PUSH
27028: LD_INT 26
27030: PUSH
27031: LD_INT 70
27033: PUSH
27034: EMPTY
27035: LIST
27036: PUSH
27037: LD_INT 23
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: LIST
27044: PUSH
27045: LD_INT 27
27047: PUSH
27048: LD_INT 39
27050: PUSH
27051: EMPTY
27052: LIST
27053: PUSH
27054: LD_INT 17
27056: PUSH
27057: EMPTY
27058: LIST
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 28
27064: PUSH
27065: LD_INT 40
27067: PUSH
27068: EMPTY
27069: LIST
27070: PUSH
27071: LD_INT 18
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 29
27081: PUSH
27082: LD_INT 42
27084: PUSH
27085: EMPTY
27086: LIST
27087: PUSH
27088: LD_INT 21
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: LIST
27095: PUSH
27096: LD_INT 30
27098: PUSH
27099: LD_INT 6
27101: PUSH
27102: EMPTY
27103: LIST
27104: PUSH
27105: LD_INT 20
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 31
27115: PUSH
27116: LD_INT 15
27118: PUSH
27119: EMPTY
27120: LIST
27121: PUSH
27122: LD_INT 20
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: LIST
27129: PUSH
27130: LD_INT 32
27132: PUSH
27133: EMPTY
27134: PUSH
27135: LD_INT 23
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: LIST
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: PUSH
27153: EMPTY
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: LIST
27159: ST_TO_ADDR
// ru_weapons := [ [ ] , [ [ ru_heavy_machine_gun , [ ] , 0 ] , [ ru_gatling_gun , [ tech_Gatling ] , 0 ] , [ ru_gun , [ tech_Gun ] , b_ext_gun ] , [ ru_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ru_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ ru_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] , [ ru_rocket , [ tech_AdvRocket ] , b_ext_rocket ] , [ ru_siberium_rocket , [ tech_SibEng , tech_SibFiss ] , b_ext_siberium ] , [ ru_time_lapser , [ tech_Lapser ] , b_ext_siberium ] , [ ru_bulldozer , [ ] , b_ext_noncombat ] ] ] ;
27160: LD_ADDR_LOC 54
27164: PUSH
27165: EMPTY
27166: PUSH
27167: LD_INT 42
27169: PUSH
27170: EMPTY
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 43
27182: PUSH
27183: LD_INT 69
27185: PUSH
27186: EMPTY
27187: LIST
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 44
27199: PUSH
27200: LD_INT 39
27202: PUSH
27203: EMPTY
27204: LIST
27205: PUSH
27206: LD_INT 17
27208: PUSH
27209: EMPTY
27210: LIST
27211: LIST
27212: LIST
27213: PUSH
27214: LD_INT 45
27216: PUSH
27217: LD_INT 40
27219: PUSH
27220: EMPTY
27221: LIST
27222: PUSH
27223: LD_INT 18
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 51
27233: PUSH
27234: EMPTY
27235: PUSH
27236: LD_INT 19
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: LIST
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 46
27253: PUSH
27254: LD_INT 34
27256: PUSH
27257: EMPTY
27258: LIST
27259: PUSH
27260: LD_INT 17
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 47
27270: PUSH
27271: LD_INT 71
27273: PUSH
27274: EMPTY
27275: LIST
27276: PUSH
27277: LD_INT 18
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: LIST
27284: PUSH
27285: LD_INT 48
27287: PUSH
27288: LD_INT 22
27290: PUSH
27291: LD_INT 25
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: LD_INT 21
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 49
27308: PUSH
27309: LD_INT 31
27311: PUSH
27312: EMPTY
27313: LIST
27314: PUSH
27315: LD_INT 21
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: LIST
27322: PUSH
27323: LD_INT 53
27325: PUSH
27326: EMPTY
27327: PUSH
27328: LD_INT 19
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: LIST
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: LIST
27340: LIST
27341: LIST
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: LIST
27347: ST_TO_ADDR
// end ;
27348: LD_VAR 0 1
27352: RET
// function init_prefered_vehicles ( side_nation ) ; begin
27353: LD_INT 0
27355: PPUSH
// case side_nation of 1 :
27356: LD_VAR 0 1
27360: PUSH
27361: LD_INT 1
27363: DOUBLE
27364: EQUAL
27365: IFTRUE 27369
27367: GO 27453
27369: POP
// prefered := [ [ [ us_medium_wheeled , us_medium_wheeled , us_morphling ] [ difficulty ] , 0 , control_remote , us_laser ] , [ us_morphling , 0 , control_remote , us_heavy_gun ] , [ us_morphling , 0 , control_remote , us_rocket_launcher ] ] ; 2 :
27370: LD_ADDR_LOC 57
27374: PUSH
27375: LD_INT 2
27377: PUSH
27378: LD_INT 2
27380: PUSH
27381: LD_INT 5
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: PUSH
27389: LD_OWVAR 67
27393: ARRAY
27394: PUSH
27395: LD_INT 0
27397: PUSH
27398: LD_INT 2
27400: PUSH
27401: LD_INT 9
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 5
27412: PUSH
27413: LD_INT 0
27415: PUSH
27416: LD_INT 2
27418: PUSH
27419: LD_INT 6
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 5
27430: PUSH
27431: LD_INT 0
27433: PUSH
27434: LD_INT 2
27436: PUSH
27437: LD_INT 7
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: LIST
27444: LIST
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: LIST
27450: ST_TO_ADDR
27451: GO 27566
27453: LD_INT 2
27455: DOUBLE
27456: EQUAL
27457: IFTRUE 27461
27459: GO 27509
27461: POP
// prefered := [ [ ar_medium_trike , 0 , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , 0 , control_remote , ar_gun ] ] ; 3 :
27462: LD_ADDR_LOC 57
27466: PUSH
27467: LD_INT 13
27469: PUSH
27470: LD_INT 0
27472: PUSH
27473: LD_INT 2
27475: PUSH
27476: LD_INT 28
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 13
27487: PUSH
27488: LD_INT 0
27490: PUSH
27491: LD_INT 2
27493: PUSH
27494: LD_INT 27
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: LIST
27501: LIST
27502: PUSH
27503: EMPTY
27504: LIST
27505: LIST
27506: ST_TO_ADDR
27507: GO 27566
27509: LD_INT 3
27511: DOUBLE
27512: EQUAL
27513: IFTRUE 27517
27515: GO 27565
27517: POP
// prefered := [ [ 0 , engine_siberite , control_computer , ru_heavy_gun ] , [ 0 , engine_siberite , control_computer , ru_rocket ] ] ; end ;
27518: LD_ADDR_LOC 57
27522: PUSH
27523: LD_INT 0
27525: PUSH
27526: LD_INT 3
27528: PUSH
27529: LD_INT 3
27531: PUSH
27532: LD_INT 46
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: PUSH
27541: LD_INT 0
27543: PUSH
27544: LD_INT 3
27546: PUSH
27547: LD_INT 3
27549: PUSH
27550: LD_INT 47
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: ST_TO_ADDR
27563: GO 27566
27565: POP
// end ;
27566: LD_VAR 0 2
27570: RET
// every 0 0$1.9 do var un , factories , active_side , active_nation , wait_timers , construction_order_given ;
27571: GO 27573
27573: DISABLE
27574: LD_INT 0
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
// begin wait_timers = [ ] ;
27582: LD_ADDR_VAR 0 5
27586: PUSH
27587: EMPTY
27588: ST_TO_ADDR
// for un = 1 to 8 do
27589: LD_ADDR_VAR 0 1
27593: PUSH
27594: DOUBLE
27595: LD_INT 1
27597: DEC
27598: ST_TO_ADDR
27599: LD_INT 8
27601: PUSH
27602: FOR_TO
27603: IFFALSE 27621
// wait_timers = wait_timers ^ 0 0$15.9 ;
27605: LD_ADDR_VAR 0 5
27609: PUSH
27610: LD_VAR 0 5
27614: PUSH
27615: LD_INT 557
27617: ADD
27618: ST_TO_ADDR
27619: GO 27602
27621: POP
27622: POP
// repeat wait ( 0 0$1 ) ;
27623: LD_INT 35
27625: PPUSH
27626: CALL_OW 67
// for active_side in cpu_list do
27630: LD_ADDR_VAR 0 3
27634: PUSH
27635: LD_EXP 8
27639: PUSH
27640: FOR_IN
27641: IFFALSE 27994
// begin if wait_timers [ active_side ] > 0 0$0 then
27643: LD_VAR 0 5
27647: PUSH
27648: LD_VAR 0 3
27652: ARRAY
27653: PUSH
27654: LD_INT 0
27656: GREATER
27657: IFFALSE 27696
// begin wait_timers = Replace ( wait_timers , active_side , wait_timers [ active_side ] - 0 0$1 ) ;
27659: LD_ADDR_VAR 0 5
27663: PUSH
27664: LD_VAR 0 5
27668: PPUSH
27669: LD_VAR 0 3
27673: PPUSH
27674: LD_VAR 0 5
27678: PUSH
27679: LD_VAR 0 3
27683: ARRAY
27684: PUSH
27685: LD_INT 35
27687: MINUS
27688: PPUSH
27689: CALL_OW 1
27693: ST_TO_ADDR
// continue ;
27694: GO 27640
// end ; if ( Get_Resources ( active_side ) [ 2 ] > 29 ) or ( Get_resources ( active_side ) [ 3 ] > 9 ) then
27696: LD_VAR 0 3
27700: PPUSH
27701: CALL 28003 0 1
27705: PUSH
27706: LD_INT 2
27708: ARRAY
27709: PUSH
27710: LD_INT 29
27712: GREATER
27713: PUSH
27714: LD_VAR 0 3
27718: PPUSH
27719: CALL 28003 0 1
27723: PUSH
27724: LD_INT 3
27726: ARRAY
27727: PUSH
27728: LD_INT 9
27730: GREATER
27731: OR
27732: IFFALSE 27992
// begin case active_side of us :
27734: LD_VAR 0 3
27738: PUSH
27739: LD_EXP 3
27743: DOUBLE
27744: EQUAL
27745: IFTRUE 27749
27747: GO 27760
27749: POP
// if us_sib_wait then
27750: LD_EXP 74
27754: IFFALSE 27758
// continue ; ru :
27756: GO 27640
27758: GO 27782
27760: LD_EXP 2
27764: DOUBLE
27765: EQUAL
27766: IFTRUE 27770
27768: GO 27781
27770: POP
// if ru_sib_wait then
27771: LD_EXP 75
27775: IFFALSE 27779
// continue ; end ;
27777: GO 27640
27779: GO 27782
27781: POP
// factories := FilterAllUnits ( [ [ f_side , active_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
27782: LD_ADDR_VAR 0 2
27786: PUSH
27787: LD_INT 22
27789: PUSH
27790: LD_VAR 0 3
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: LD_INT 2
27801: PUSH
27802: LD_INT 30
27804: PUSH
27805: LD_INT 2
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 30
27814: PUSH
27815: LD_INT 3
27817: PUSH
27818: EMPTY
27819: LIST
27820: LIST
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: LIST
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 69
27835: ST_TO_ADDR
// if factories = 0 then
27836: LD_VAR 0 2
27840: PUSH
27841: LD_INT 0
27843: EQUAL
27844: IFFALSE 27848
// continue ;
27846: GO 27640
// un = factories [ 1 ] ;
27848: LD_ADDR_VAR 0 1
27852: PUSH
27853: LD_VAR 0 2
27857: PUSH
27858: LD_INT 1
27860: ARRAY
27861: ST_TO_ADDR
// active_nation := GetCPUNation ( active_side ) ;
27862: LD_ADDR_VAR 0 4
27866: PUSH
27867: LD_VAR 0 3
27871: PPUSH
27872: CALL 26476 0 1
27876: ST_TO_ADDR
// init_priority ( active_side , active_nation ) ;
27877: LD_VAR 0 3
27881: PPUSH
27882: LD_VAR 0 4
27886: PPUSH
27887: CALL 26556 0 2
// init_prefered_vehicles ( active_nation ) ;
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL 27353 0 1
// if not BuildingStatus ( un ) = bs_working then
27900: LD_VAR 0 1
27904: PPUSH
27905: CALL_OW 461
27909: PUSH
27910: LD_INT 3
27912: EQUAL
27913: NOT
27914: IFFALSE 27992
// begin construction_order_given = build_new_vehicle ( active_side , active_nation , un ) ;
27916: LD_ADDR_VAR 0 6
27920: PUSH
27921: LD_VAR 0 3
27925: PPUSH
27926: LD_VAR 0 4
27930: PPUSH
27931: LD_VAR 0 1
27935: PPUSH
27936: CALL 28121 0 3
27940: ST_TO_ADDR
// if construction_order_given then
27941: LD_VAR 0 6
27945: IFFALSE 27992
// begin wait ( 10 ) ;
27947: LD_INT 10
27949: PPUSH
27950: CALL_OW 67
// if BuildingStatus ( un ) = bs_working then
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 461
27963: PUSH
27964: LD_INT 3
27966: EQUAL
27967: IFFALSE 27992
// wait_timers = Replace ( wait_timers , active_side , 0 0$15.9 ) ;
27969: LD_ADDR_VAR 0 5
27973: PUSH
27974: LD_VAR 0 5
27978: PPUSH
27979: LD_VAR 0 3
27983: PPUSH
27984: LD_INT 557
27986: PPUSH
27987: CALL_OW 1
27991: ST_TO_ADDR
// end ; end ; end ; end ;
27992: GO 27640
27994: POP
27995: POP
// until false ;
27996: LD_INT 0
27998: IFFALSE 27623
// end ;
28000: PPOPN 6
28002: END
// function Get_Resources ( side ) ; var depots ; begin
28003: LD_INT 0
28005: PPUSH
28006: PPUSH
// depots = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28007: LD_ADDR_VAR 0 3
28011: PUSH
28012: LD_INT 22
28014: PUSH
28015: LD_VAR 0 1
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 2
28026: PUSH
28027: LD_INT 30
28029: PUSH
28030: LD_INT 0
28032: PUSH
28033: EMPTY
28034: LIST
28035: LIST
28036: PUSH
28037: LD_INT 30
28039: PUSH
28040: LD_INT 1
28042: PUSH
28043: EMPTY
28044: LIST
28045: LIST
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: LIST
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PPUSH
28056: CALL_OW 69
28060: ST_TO_ADDR
// if depots > 0 then
28061: LD_VAR 0 3
28065: PUSH
28066: LD_INT 0
28068: GREATER
28069: IFFALSE 28097
// result := GetResources ( GetBase ( depots [ 1 ] ) ) else
28071: LD_ADDR_VAR 0 2
28075: PUSH
28076: LD_VAR 0 3
28080: PUSH
28081: LD_INT 1
28083: ARRAY
28084: PPUSH
28085: CALL_OW 274
28089: PPUSH
28090: CALL_OW 279
28094: ST_TO_ADDR
28095: GO 28116
// result = [ 0 , 0 , 0 ] ;
28097: LD_ADDR_VAR 0 2
28101: PUSH
28102: LD_INT 0
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: LD_INT 0
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: LIST
28115: ST_TO_ADDR
// end ;
28116: LD_VAR 0 2
28120: RET
// function build_new_vehicle ( side , nation , factory ) ; var can_made , mechanics , wanted ; begin
28121: LD_INT 0
28123: PPUSH
28124: PPUSH
28125: PPUSH
28126: PPUSH
// result = false ;
28127: LD_ADDR_VAR 0 4
28131: PUSH
28132: LD_INT 0
28134: ST_TO_ADDR
// mechanics := request_people ( side , class_mechanic , 1 ) ;
28135: LD_ADDR_VAR 0 6
28139: PUSH
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 3
28147: PPUSH
28148: LD_INT 1
28150: PPUSH
28151: CALL 26408 0 3
28155: ST_TO_ADDR
// can_made := get_progress ( side , nation , factory ) ;
28156: LD_ADDR_VAR 0 5
28160: PUSH
28161: LD_VAR 0 1
28165: PPUSH
28166: LD_VAR 0 2
28170: PPUSH
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL 28292 0 3
28180: ST_TO_ADDR
// if can_made then
28181: LD_VAR 0 5
28185: IFFALSE 28268
// begin wanted := get_next_vehicle ( side , nation , factory , can_made ) ;
28187: LD_ADDR_VAR 0 7
28191: PUSH
28192: LD_VAR 0 1
28196: PPUSH
28197: LD_VAR 0 2
28201: PPUSH
28202: LD_VAR 0 3
28206: PPUSH
28207: LD_VAR 0 5
28211: PPUSH
28212: CALL 28771 0 4
28216: ST_TO_ADDR
// if transfer_mechanics ( side , mechanics , factory , wanted ) then
28217: LD_VAR 0 1
28221: PPUSH
28222: LD_VAR 0 6
28226: PPUSH
28227: LD_VAR 0 3
28231: PPUSH
28232: LD_VAR 0 7
28236: PPUSH
28237: CALL 31240 0 4
28241: IFFALSE 28268
// result = start_building_vehicle ( nation , factory , wanted ) ;
28243: LD_ADDR_VAR 0 4
28247: PUSH
28248: LD_VAR 0 2
28252: PPUSH
28253: LD_VAR 0 3
28257: PPUSH
28258: LD_VAR 0 7
28262: PPUSH
28263: CALL 31672 0 3
28267: ST_TO_ADDR
// end ; cleanup_extensions ( side , nation , factory ) ;
28268: LD_VAR 0 1
28272: PPUSH
28273: LD_VAR 0 2
28277: PPUSH
28278: LD_VAR 0 3
28282: PPUSH
28283: CALL 31906 0 3
// end ;
28287: LD_VAR 0 4
28291: RET
// function get_progress ( side , nation , factory ) ; var vysledek , chassis , weapon , list ; begin
28292: LD_INT 0
28294: PPUSH
28295: PPUSH
28296: PPUSH
28297: PPUSH
28298: PPUSH
// vysledek := [ ] ;
28299: LD_ADDR_VAR 0 5
28303: PUSH
28304: EMPTY
28305: ST_TO_ADDR
// list := [ ] ;
28306: LD_ADDR_VAR 0 8
28310: PUSH
28311: EMPTY
28312: ST_TO_ADDR
// case nation of 1 :
28313: LD_VAR 0 2
28317: PUSH
28318: LD_INT 1
28320: DOUBLE
28321: EQUAL
28322: IFTRUE 28326
28324: GO 28339
28326: POP
// list := us_weapons ; 2 :
28327: LD_ADDR_VAR 0 8
28331: PUSH
28332: LD_LOC 52
28336: ST_TO_ADDR
28337: GO 28382
28339: LD_INT 2
28341: DOUBLE
28342: EQUAL
28343: IFTRUE 28347
28345: GO 28360
28347: POP
// list := ar_weapons ; 3 :
28348: LD_ADDR_VAR 0 8
28352: PUSH
28353: LD_LOC 53
28357: ST_TO_ADDR
28358: GO 28382
28360: LD_INT 3
28362: DOUBLE
28363: EQUAL
28364: IFTRUE 28368
28366: GO 28381
28368: POP
// list := ru_weapons ; end ;
28369: LD_ADDR_VAR 0 8
28373: PUSH
28374: LD_LOC 54
28378: ST_TO_ADDR
28379: GO 28382
28381: POP
// for chassis = 1 to 3 do
28382: LD_ADDR_VAR 0 6
28386: PUSH
28387: DOUBLE
28388: LD_INT 1
28390: DEC
28391: ST_TO_ADDR
28392: LD_INT 3
28394: PUSH
28395: FOR_TO
28396: IFFALSE 28558
// if ( chassis < 3 ) or ( nation = nation_russian ) or ( TrackExtension ( factory ) ) then
28398: LD_VAR 0 6
28402: PUSH
28403: LD_INT 3
28405: LESS
28406: PUSH
28407: LD_VAR 0 2
28411: PUSH
28412: LD_INT 3
28414: EQUAL
28415: OR
28416: PUSH
28417: LD_VAR 0 3
28421: PPUSH
28422: CALL 29466 0 1
28426: OR
28427: IFFALSE 28556
// for weapon in list [ chassis ] do
28429: LD_ADDR_VAR 0 7
28433: PUSH
28434: LD_VAR 0 8
28438: PUSH
28439: LD_VAR 0 6
28443: ARRAY
28444: PUSH
28445: FOR_IN
28446: IFFALSE 28554
// if Technology_Researched ( side , weapon [ 2 ] ) or not weapon [ 2 ] then
28448: LD_VAR 0 1
28452: PPUSH
28453: LD_VAR 0 7
28457: PUSH
28458: LD_INT 2
28460: ARRAY
28461: PPUSH
28462: CALL 28575 0 2
28466: PUSH
28467: LD_VAR 0 7
28471: PUSH
28472: LD_INT 2
28474: ARRAY
28475: NOT
28476: OR
28477: IFFALSE 28552
// begin if ExtensionBuild ( factory , weapon [ 3 ] ) or not weapon [ 3 ] then
28479: LD_VAR 0 3
28483: PPUSH
28484: LD_VAR 0 7
28488: PUSH
28489: LD_INT 3
28491: ARRAY
28492: PPUSH
28493: CALL 28645 0 2
28497: PUSH
28498: LD_VAR 0 7
28502: PUSH
28503: LD_INT 3
28505: ARRAY
28506: NOT
28507: OR
28508: IFFALSE 28532
// vysledek := vysledek ^ weapon [ 1 ] else
28510: LD_ADDR_VAR 0 5
28514: PUSH
28515: LD_VAR 0 5
28519: PUSH
28520: LD_VAR 0 7
28524: PUSH
28525: LD_INT 1
28527: ARRAY
28528: ADD
28529: ST_TO_ADDR
28530: GO 28552
// extension_wanted := extension_wanted ^ weapon [ 3 ] ;
28532: LD_ADDR_EXP 73
28536: PUSH
28537: LD_EXP 73
28541: PUSH
28542: LD_VAR 0 7
28546: PUSH
28547: LD_INT 3
28549: ARRAY
28550: ADD
28551: ST_TO_ADDR
// end ;
28552: GO 28445
28554: POP
28555: POP
28556: GO 28395
28558: POP
28559: POP
// result := vysledek ;
28560: LD_ADDR_VAR 0 4
28564: PUSH
28565: LD_VAR 0 5
28569: ST_TO_ADDR
// end ;
28570: LD_VAR 0 4
28574: RET
// function Technology_Researched ( side , list ) ; var tech , vysledek ; begin
28575: LD_INT 0
28577: PPUSH
28578: PPUSH
28579: PPUSH
// vysledek := true ;
28580: LD_ADDR_VAR 0 5
28584: PUSH
28585: LD_INT 1
28587: ST_TO_ADDR
// for tech in list do
28588: LD_ADDR_VAR 0 4
28592: PUSH
28593: LD_VAR 0 2
28597: PUSH
28598: FOR_IN
28599: IFFALSE 28628
// if not Researched ( side , tech ) then
28601: LD_VAR 0 1
28605: PPUSH
28606: LD_VAR 0 4
28610: PPUSH
28611: CALL_OW 325
28615: NOT
28616: IFFALSE 28626
// vysledek := false ;
28618: LD_ADDR_VAR 0 5
28622: PUSH
28623: LD_INT 0
28625: ST_TO_ADDR
28626: GO 28598
28628: POP
28629: POP
// result := vysledek ;
28630: LD_ADDR_VAR 0 3
28634: PUSH
28635: LD_VAR 0 5
28639: ST_TO_ADDR
// end ;
28640: LD_VAR 0 3
28644: RET
// function ExtensionBuild ( factory , extension ) ; var i , vysledek , list ; begin
28645: LD_INT 0
28647: PPUSH
28648: PPUSH
28649: PPUSH
28650: PPUSH
// vysledek := false ;
28651: LD_ADDR_VAR 0 5
28655: PUSH
28656: LD_INT 0
28658: ST_TO_ADDR
// if extension > 0 then
28659: LD_VAR 0 2
28663: PUSH
28664: LD_INT 0
28666: GREATER
28667: IFFALSE 28748
// begin list := GetExtPositions ( factory ) ;
28669: LD_ADDR_VAR 0 6
28673: PUSH
28674: LD_VAR 0 1
28678: PPUSH
28679: CALL_OW 270
28683: ST_TO_ADDR
// for i in list do
28684: LD_ADDR_VAR 0 4
28688: PUSH
28689: LD_VAR 0 6
28693: PUSH
28694: FOR_IN
28695: IFFALSE 28744
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = extension then
28697: LD_VAR 0 4
28701: PUSH
28702: LD_INT 1
28704: ARRAY
28705: PPUSH
28706: LD_VAR 0 4
28710: PUSH
28711: LD_INT 2
28713: ARRAY
28714: PPUSH
28715: CALL_OW 428
28719: PPUSH
28720: CALL_OW 266
28724: PUSH
28725: LD_VAR 0 2
28729: EQUAL
28730: IFFALSE 28742
// begin vysledek := true ;
28732: LD_ADDR_VAR 0 5
28736: PUSH
28737: LD_INT 1
28739: ST_TO_ADDR
// break ;
28740: GO 28744
// end ;
28742: GO 28694
28744: POP
28745: POP
// end else
28746: GO 28756
// vysledek := true ;
28748: LD_ADDR_VAR 0 5
28752: PUSH
28753: LD_INT 1
28755: ST_TO_ADDR
// result := vysledek ;
28756: LD_ADDR_VAR 0 3
28760: PUSH
28761: LD_VAR 0 5
28765: ST_TO_ADDR
// end ;
28766: LD_VAR 0 3
28770: RET
// function get_next_vehicle ( side , nation , factory , possible ) ; var un , pom , list , cargo_bay , crane , nation_cargo , nation_crane , weapon_prefered , weapon_else , vysledek ; begin
28771: LD_INT 0
28773: PPUSH
28774: PPUSH
28775: PPUSH
28776: PPUSH
28777: PPUSH
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
// vysledek := [ ] ;
28784: LD_ADDR_VAR 0 15
28788: PUSH
28789: EMPTY
28790: ST_TO_ADDR
// case nation of 1 :
28791: LD_VAR 0 2
28795: PUSH
28796: LD_INT 1
28798: DOUBLE
28799: EQUAL
28800: IFTRUE 28804
28802: GO 28833
28804: POP
// begin list := us_weapons ;
28805: LD_ADDR_VAR 0 8
28809: PUSH
28810: LD_LOC 52
28814: ST_TO_ADDR
// nation_cargo := us_cargo_bay ;
28815: LD_ADDR_VAR 0 11
28819: PUSH
28820: LD_INT 12
28822: ST_TO_ADDR
// nation_crane := us_crane ;
28823: LD_ADDR_VAR 0 12
28827: PUSH
28828: LD_INT 13
28830: ST_TO_ADDR
// end ; 2 :
28831: GO 28908
28833: LD_INT 2
28835: DOUBLE
28836: EQUAL
28837: IFTRUE 28841
28839: GO 28870
28841: POP
// begin list := ar_weapons ;
28842: LD_ADDR_VAR 0 8
28846: PUSH
28847: LD_LOC 53
28851: ST_TO_ADDR
// nation_cargo := ar_cargo_bay ;
28852: LD_ADDR_VAR 0 11
28856: PUSH
28857: LD_INT 32
28859: ST_TO_ADDR
// nation_crane := 0 ;
28860: LD_ADDR_VAR 0 12
28864: PUSH
28865: LD_INT 0
28867: ST_TO_ADDR
// end ; 3 :
28868: GO 28908
28870: LD_INT 3
28872: DOUBLE
28873: EQUAL
28874: IFTRUE 28878
28876: GO 28907
28878: POP
// begin list := ru_weapons ;
28879: LD_ADDR_VAR 0 8
28883: PUSH
28884: LD_LOC 54
28888: ST_TO_ADDR
// nation_cargo := ru_cargo_bay ;
28889: LD_ADDR_VAR 0 11
28893: PUSH
28894: LD_INT 51
28896: ST_TO_ADDR
// nation_crane := ru_crane ;
28897: LD_ADDR_VAR 0 12
28901: PUSH
28902: LD_INT 52
28904: ST_TO_ADDR
// end ; end ;
28905: GO 28908
28907: POP
// pom := AvailableWeaponList ( factory ) ;
28908: LD_ADDR_VAR 0 7
28912: PUSH
28913: LD_VAR 0 3
28917: PPUSH
28918: CALL_OW 478
28922: ST_TO_ADDR
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
28923: LD_ADDR_VAR 0 9
28927: PUSH
28928: LD_INT 22
28930: PUSH
28931: LD_VAR 0 1
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 21
28942: PUSH
28943: LD_INT 2
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 34
28952: PUSH
28953: LD_VAR 0 11
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: LIST
28966: PPUSH
28967: CALL_OW 69
28971: ST_TO_ADDR
// if ( not cargo_bay ) and ( nation_cargo in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
28972: LD_VAR 0 9
28976: NOT
28977: PUSH
28978: LD_VAR 0 11
28982: PUSH
28983: LD_VAR 0 7
28987: IN
28988: AND
28989: PUSH
28990: LD_VAR 0 3
28994: PPUSH
28995: CALL 29403 0 1
28999: AND
29000: PUSH
29001: LD_VAR 0 3
29005: PPUSH
29006: CALL 29466 0 1
29010: AND
29011: IFFALSE 29045
// vysledek := Define_NonCombat ( side , nation , factory , nation_cargo ) else
29013: LD_ADDR_VAR 0 15
29017: PUSH
29018: LD_VAR 0 1
29022: PPUSH
29023: LD_VAR 0 2
29027: PPUSH
29028: LD_VAR 0 3
29032: PPUSH
29033: LD_VAR 0 11
29037: PPUSH
29038: CALL 29492 0 4
29042: ST_TO_ADDR
29043: GO 29061
// possible := possible diff nation_cargo ;
29045: LD_ADDR_VAR 0 4
29049: PUSH
29050: LD_VAR 0 4
29054: PUSH
29055: LD_VAR 0 11
29059: DIFF
29060: ST_TO_ADDR
// if not vysledek then
29061: LD_VAR 0 15
29065: NOT
29066: IFFALSE 29206
// begin crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
29068: LD_ADDR_VAR 0 10
29072: PUSH
29073: LD_INT 22
29075: PUSH
29076: LD_VAR 0 1
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 21
29087: PUSH
29088: LD_INT 2
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 34
29097: PUSH
29098: LD_VAR 0 12
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: LIST
29111: PPUSH
29112: CALL_OW 69
29116: ST_TO_ADDR
// if ( not crane ) and ( nation_crane in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29117: LD_VAR 0 10
29121: NOT
29122: PUSH
29123: LD_VAR 0 12
29127: PUSH
29128: LD_VAR 0 7
29132: IN
29133: AND
29134: PUSH
29135: LD_VAR 0 3
29139: PPUSH
29140: CALL 29403 0 1
29144: AND
29145: PUSH
29146: LD_VAR 0 3
29150: PPUSH
29151: CALL 29466 0 1
29155: AND
29156: IFFALSE 29190
// vysledek := Define_NonCombat ( side , nation , factory , nation_crane ) else
29158: LD_ADDR_VAR 0 15
29162: PUSH
29163: LD_VAR 0 1
29167: PPUSH
29168: LD_VAR 0 2
29172: PPUSH
29173: LD_VAR 0 3
29177: PPUSH
29178: LD_VAR 0 12
29182: PPUSH
29183: CALL 29492 0 4
29187: ST_TO_ADDR
29188: GO 29206
// possible := possible diff nation_crane ;
29190: LD_ADDR_VAR 0 4
29194: PUSH
29195: LD_VAR 0 4
29199: PUSH
29200: LD_VAR 0 12
29204: DIFF
29205: ST_TO_ADDR
// end ; if not vysledek then
29206: LD_VAR 0 15
29210: NOT
29211: IFFALSE 29388
// begin weapon_prefered := [ ] ;
29213: LD_ADDR_VAR 0 13
29217: PUSH
29218: EMPTY
29219: ST_TO_ADDR
// weapon_else := 0 ;
29220: LD_ADDR_VAR 0 14
29224: PUSH
29225: LD_INT 0
29227: ST_TO_ADDR
// for un in prefered do
29228: LD_ADDR_VAR 0 6
29232: PUSH
29233: LD_LOC 57
29237: PUSH
29238: FOR_IN
29239: IFFALSE 29278
// if ( un [ 4 ] in possible ) then
29241: LD_VAR 0 6
29245: PUSH
29246: LD_INT 4
29248: ARRAY
29249: PUSH
29250: LD_VAR 0 4
29254: IN
29255: IFFALSE 29276
// weapon_prefered := weapon_prefered ^ [ un ] ;
29257: LD_ADDR_VAR 0 13
29261: PUSH
29262: LD_VAR 0 13
29266: PUSH
29267: LD_VAR 0 6
29271: PUSH
29272: EMPTY
29273: LIST
29274: ADD
29275: ST_TO_ADDR
29276: GO 29238
29278: POP
29279: POP
// if not weapon_prefered then
29280: LD_VAR 0 13
29284: NOT
29285: IFFALSE 29358
// begin for un in possible do
29287: LD_ADDR_VAR 0 6
29291: PUSH
29292: LD_VAR 0 4
29296: PUSH
29297: FOR_IN
29298: IFFALSE 29324
// if un > weapon_else then
29300: LD_VAR 0 6
29304: PUSH
29305: LD_VAR 0 14
29309: GREATER
29310: IFFALSE 29322
// weapon_else := un ;
29312: LD_ADDR_VAR 0 14
29316: PUSH
29317: LD_VAR 0 6
29321: ST_TO_ADDR
29322: GO 29297
29324: POP
29325: POP
// vysledek := Define_Vehicle ( side , nation , factory , weapon_else ) ;
29326: LD_ADDR_VAR 0 15
29330: PUSH
29331: LD_VAR 0 1
29335: PPUSH
29336: LD_VAR 0 2
29340: PPUSH
29341: LD_VAR 0 3
29345: PPUSH
29346: LD_VAR 0 14
29350: PPUSH
29351: CALL 30292 0 4
29355: ST_TO_ADDR
// end else
29356: GO 29388
// vysledek := Select_from_Prefered ( side , nation , factory , weapon_prefered ) ;
29358: LD_ADDR_VAR 0 15
29362: PUSH
29363: LD_VAR 0 1
29367: PPUSH
29368: LD_VAR 0 2
29372: PPUSH
29373: LD_VAR 0 3
29377: PPUSH
29378: LD_VAR 0 13
29382: PPUSH
29383: CALL 29764 0 4
29387: ST_TO_ADDR
// end ; result := vysledek ;
29388: LD_ADDR_VAR 0 5
29392: PUSH
29393: LD_VAR 0 15
29397: ST_TO_ADDR
// end ;
29398: LD_VAR 0 5
29402: RET
// function Remote_or_Computer ( factory ) ; var vysledek ; begin
29403: LD_INT 0
29405: PPUSH
29406: PPUSH
// vysledek := false ;
29407: LD_ADDR_VAR 0 3
29411: PUSH
29412: LD_INT 0
29414: ST_TO_ADDR
// if ExtensionBuild ( factory , b_ext_computer ) or ExtensionBuild ( factory , b_ext_radar ) then
29415: LD_VAR 0 1
29419: PPUSH
29420: LD_INT 24
29422: PPUSH
29423: CALL 28645 0 2
29427: PUSH
29428: LD_VAR 0 1
29432: PPUSH
29433: LD_INT 20
29435: PPUSH
29436: CALL 28645 0 2
29440: OR
29441: IFFALSE 29451
// vysledek := true ;
29443: LD_ADDR_VAR 0 3
29447: PUSH
29448: LD_INT 1
29450: ST_TO_ADDR
// result := vysledek ;
29451: LD_ADDR_VAR 0 2
29455: PUSH
29456: LD_VAR 0 3
29460: ST_TO_ADDR
// end ;
29461: LD_VAR 0 2
29465: RET
// function TrackExtension ( factory ) ; begin
29466: LD_INT 0
29468: PPUSH
// result := ExtensionBuild ( factory , b_ext_track ) ;
29469: LD_ADDR_VAR 0 2
29473: PUSH
29474: LD_VAR 0 1
29478: PPUSH
29479: LD_INT 16
29481: PPUSH
29482: CALL 28645 0 2
29486: ST_TO_ADDR
// end ;
29487: LD_VAR 0 2
29491: RET
// function Define_NonCombat ( side , nation , factory , weapon ) ; var components ; begin
29492: LD_INT 0
29494: PPUSH
29495: PPUSH
// components := [ ] ;
29496: LD_ADDR_VAR 0 6
29500: PUSH
29501: EMPTY
29502: ST_TO_ADDR
// case nation of 1 :
29503: LD_VAR 0 2
29507: PUSH
29508: LD_INT 1
29510: DOUBLE
29511: EQUAL
29512: IFTRUE 29516
29514: GO 29533
29516: POP
// components := components ^ us_medium_tracked ; 2 :
29517: LD_ADDR_VAR 0 6
29521: PUSH
29522: LD_VAR 0 6
29526: PUSH
29527: LD_INT 3
29529: ADD
29530: ST_TO_ADDR
29531: GO 29584
29533: LD_INT 2
29535: DOUBLE
29536: EQUAL
29537: IFTRUE 29541
29539: GO 29558
29541: POP
// components := components ^ ar_half_tracked ; 3 :
29542: LD_ADDR_VAR 0 6
29546: PUSH
29547: LD_VAR 0 6
29551: PUSH
29552: LD_INT 14
29554: ADD
29555: ST_TO_ADDR
29556: GO 29584
29558: LD_INT 3
29560: DOUBLE
29561: EQUAL
29562: IFTRUE 29566
29564: GO 29583
29566: POP
// components := components ^ ru_medium_tracked ; end ;
29567: LD_ADDR_VAR 0 6
29571: PUSH
29572: LD_VAR 0 6
29576: PUSH
29577: LD_INT 22
29579: ADD
29580: ST_TO_ADDR
29581: GO 29584
29583: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
29584: LD_VAR 0 3
29588: PPUSH
29589: LD_INT 21
29591: PPUSH
29592: CALL 28645 0 2
29596: PUSH
29597: LD_VAR 0 1
29601: PPUSH
29602: CALL 28003 0 1
29606: PUSH
29607: LD_INT 3
29609: ARRAY
29610: PUSH
29611: LD_LOC 55
29615: GREATEREQUAL
29616: AND
29617: IFFALSE 29635
// components := components ^ engine_siberite else
29619: LD_ADDR_VAR 0 6
29623: PUSH
29624: LD_VAR 0 6
29628: PUSH
29629: LD_INT 3
29631: ADD
29632: ST_TO_ADDR
29633: GO 29649
// components := components ^ engine_combustion ;
29635: LD_ADDR_VAR 0 6
29639: PUSH
29640: LD_VAR 0 6
29644: PUSH
29645: LD_INT 1
29647: ADD
29648: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
29649: LD_VAR 0 2
29653: PUSH
29654: LD_INT 2
29656: EQUAL
29657: PUSH
29658: LD_VAR 0 1
29662: PPUSH
29663: CALL 31177 0 1
29667: AND
29668: IFFALSE 29686
// components := components ^ control_apeman else
29670: LD_ADDR_VAR 0 6
29674: PUSH
29675: LD_VAR 0 6
29679: PUSH
29680: LD_INT 5
29682: ADD
29683: ST_TO_ADDR
29684: GO 29730
// if ExtensionBuild ( factory , b_ext_computer ) then
29686: LD_VAR 0 3
29690: PPUSH
29691: LD_INT 24
29693: PPUSH
29694: CALL 28645 0 2
29698: IFFALSE 29716
// components := components ^ control_computer else
29700: LD_ADDR_VAR 0 6
29704: PUSH
29705: LD_VAR 0 6
29709: PUSH
29710: LD_INT 3
29712: ADD
29713: ST_TO_ADDR
29714: GO 29730
// components := components ^ control_remote ;
29716: LD_ADDR_VAR 0 6
29720: PUSH
29721: LD_VAR 0 6
29725: PUSH
29726: LD_INT 2
29728: ADD
29729: ST_TO_ADDR
// components := components ^ [ weapon ] ;
29730: LD_ADDR_VAR 0 6
29734: PUSH
29735: LD_VAR 0 6
29739: PUSH
29740: LD_VAR 0 4
29744: PUSH
29745: EMPTY
29746: LIST
29747: ADD
29748: ST_TO_ADDR
// result := components ;
29749: LD_ADDR_VAR 0 5
29753: PUSH
29754: LD_VAR 0 6
29758: ST_TO_ADDR
// end ;
29759: LD_VAR 0 5
29763: RET
// function Select_from_Prefered ( side , nation , factory , possible ) ; var un , i , count , components , controls , vysledek ; begin
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
29770: PPUSH
29771: PPUSH
29772: PPUSH
// count := [ - 1 , 0 ] ;
29773: LD_ADDR_VAR 0 8
29777: PUSH
29778: LD_INT 1
29780: NEG
29781: PUSH
29782: LD_INT 0
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: ST_TO_ADDR
// for un in possible do
29789: LD_ADDR_VAR 0 6
29793: PUSH
29794: LD_VAR 0 4
29798: PUSH
29799: FOR_IN
29800: IFFALSE 29899
// begin i := 0 + FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , un [ 4 ] ] ] ) ;
29802: LD_ADDR_VAR 0 7
29806: PUSH
29807: LD_INT 0
29809: PUSH
29810: LD_INT 22
29812: PUSH
29813: LD_VAR 0 1
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 34
29824: PUSH
29825: LD_VAR 0 6
29829: PUSH
29830: LD_INT 4
29832: ARRAY
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PPUSH
29842: CALL_OW 69
29846: PLUS
29847: ST_TO_ADDR
// if ( count [ 1 ] < 0 ) or ( count [ 1 ] > i ) then
29848: LD_VAR 0 8
29852: PUSH
29853: LD_INT 1
29855: ARRAY
29856: PUSH
29857: LD_INT 0
29859: LESS
29860: PUSH
29861: LD_VAR 0 8
29865: PUSH
29866: LD_INT 1
29868: ARRAY
29869: PUSH
29870: LD_VAR 0 7
29874: GREATER
29875: OR
29876: IFFALSE 29897
// count := [ i , un ] ;
29878: LD_ADDR_VAR 0 8
29882: PUSH
29883: LD_VAR 0 7
29887: PUSH
29888: LD_VAR 0 6
29892: PUSH
29893: EMPTY
29894: LIST
29895: LIST
29896: ST_TO_ADDR
// end ;
29897: GO 29799
29899: POP
29900: POP
// un := count [ 2 ] ;
29901: LD_ADDR_VAR 0 6
29905: PUSH
29906: LD_VAR 0 8
29910: PUSH
29911: LD_INT 2
29913: ARRAY
29914: ST_TO_ADDR
// components := [ ] ;
29915: LD_ADDR_VAR 0 9
29919: PUSH
29920: EMPTY
29921: ST_TO_ADDR
// controls := AvailableControlList ( factory ) ;
29922: LD_ADDR_VAR 0 10
29926: PUSH
29927: LD_VAR 0 3
29931: PPUSH
29932: CALL_OW 477
29936: ST_TO_ADDR
// if un [ 1 ] in AvailableChassisList ( factory ) then
29937: LD_VAR 0 6
29941: PUSH
29942: LD_INT 1
29944: ARRAY
29945: PUSH
29946: LD_VAR 0 3
29950: PPUSH
29951: CALL_OW 475
29955: IN
29956: IFFALSE 29980
// components := components ^ un [ 1 ] else
29958: LD_ADDR_VAR 0 9
29962: PUSH
29963: LD_VAR 0 9
29967: PUSH
29968: LD_VAR 0 6
29972: PUSH
29973: LD_INT 1
29975: ARRAY
29976: ADD
29977: ST_TO_ADDR
29978: GO 30030
// components := components ^ SelectChassis ( side , nation , factory , ChassisWeight ( nation , un [ 4 ] ) ) ;
29980: LD_ADDR_VAR 0 9
29984: PUSH
29985: LD_VAR 0 9
29989: PUSH
29990: LD_VAR 0 1
29994: PPUSH
29995: LD_VAR 0 2
29999: PPUSH
30000: LD_VAR 0 3
30004: PPUSH
30005: LD_VAR 0 2
30009: PPUSH
30010: LD_VAR 0 6
30014: PUSH
30015: LD_INT 4
30017: ARRAY
30018: PPUSH
30019: CALL 31000 0 2
30023: PPUSH
30024: CALL 30634 0 4
30028: ADD
30029: ST_TO_ADDR
// if un [ 2 ] in AvailableEngineList ( factory ) then
30030: LD_VAR 0 6
30034: PUSH
30035: LD_INT 2
30037: ARRAY
30038: PUSH
30039: LD_VAR 0 3
30043: PPUSH
30044: CALL_OW 476
30048: IN
30049: IFFALSE 30073
// components := components ^ un [ 2 ] else
30051: LD_ADDR_VAR 0 9
30055: PUSH
30056: LD_VAR 0 9
30060: PUSH
30061: LD_VAR 0 6
30065: PUSH
30066: LD_INT 2
30068: ARRAY
30069: ADD
30070: ST_TO_ADDR
30071: GO 30148
// if ( not components [ 1 ] in [ us_light_wheeled , ar_hovercraft , ar_light_trike ] ) and ( Get_Resources ( side ) [ 3 ] > 9 ) then
30073: LD_VAR 0 9
30077: PUSH
30078: LD_INT 1
30080: ARRAY
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: LD_INT 11
30087: PUSH
30088: LD_INT 12
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: LIST
30095: IN
30096: NOT
30097: PUSH
30098: LD_VAR 0 1
30102: PPUSH
30103: CALL 28003 0 1
30107: PUSH
30108: LD_INT 3
30110: ARRAY
30111: PUSH
30112: LD_INT 9
30114: GREATER
30115: AND
30116: IFFALSE 30134
// components := components ^ engine_siberite else
30118: LD_ADDR_VAR 0 9
30122: PUSH
30123: LD_VAR 0 9
30127: PUSH
30128: LD_INT 3
30130: ADD
30131: ST_TO_ADDR
30132: GO 30148
// components := components ^ engine_combustion ;
30134: LD_ADDR_VAR 0 9
30138: PUSH
30139: LD_VAR 0 9
30143: PUSH
30144: LD_INT 1
30146: ADD
30147: ST_TO_ADDR
// if un [ 3 ] in AvailableControlList ( factory ) then
30148: LD_VAR 0 6
30152: PUSH
30153: LD_INT 3
30155: ARRAY
30156: PUSH
30157: LD_VAR 0 3
30161: PPUSH
30162: CALL_OW 477
30166: IN
30167: IFFALSE 30191
// components := components ^ un [ 3 ] else
30169: LD_ADDR_VAR 0 9
30173: PUSH
30174: LD_VAR 0 9
30178: PUSH
30179: LD_VAR 0 6
30183: PUSH
30184: LD_INT 3
30186: ARRAY
30187: ADD
30188: ST_TO_ADDR
30189: GO 30257
// begin if control_remote in controls then
30191: LD_INT 2
30193: PUSH
30194: LD_VAR 0 10
30198: IN
30199: IFFALSE 30217
// components := components ^ control_remote else
30201: LD_ADDR_VAR 0 9
30205: PUSH
30206: LD_VAR 0 9
30210: PUSH
30211: LD_INT 2
30213: ADD
30214: ST_TO_ADDR
30215: GO 30257
// if control_computer in controls then
30217: LD_INT 3
30219: PUSH
30220: LD_VAR 0 10
30224: IN
30225: IFFALSE 30243
// components := components ^ control_computer else
30227: LD_ADDR_VAR 0 9
30231: PUSH
30232: LD_VAR 0 9
30236: PUSH
30237: LD_INT 3
30239: ADD
30240: ST_TO_ADDR
30241: GO 30257
// components := components ^ control_manual ;
30243: LD_ADDR_VAR 0 9
30247: PUSH
30248: LD_VAR 0 9
30252: PUSH
30253: LD_INT 1
30255: ADD
30256: ST_TO_ADDR
// end ; components := components ^ un [ 4 ] ;
30257: LD_ADDR_VAR 0 9
30261: PUSH
30262: LD_VAR 0 9
30266: PUSH
30267: LD_VAR 0 6
30271: PUSH
30272: LD_INT 4
30274: ARRAY
30275: ADD
30276: ST_TO_ADDR
// result := components ;
30277: LD_ADDR_VAR 0 5
30281: PUSH
30282: LD_VAR 0 9
30286: ST_TO_ADDR
// end ;
30287: LD_VAR 0 5
30291: RET
// function Define_Vehicle ( side , nation , factory , weapon ) ; var components ; begin
30292: LD_INT 0
30294: PPUSH
30295: PPUSH
// components := [ ] ;
30296: LD_ADDR_VAR 0 6
30300: PUSH
30301: EMPTY
30302: ST_TO_ADDR
// case ChassisWeight ( nation , weapon ) of 1 :
30303: LD_VAR 0 2
30307: PPUSH
30308: LD_VAR 0 4
30312: PPUSH
30313: CALL 31000 0 2
30317: PUSH
30318: LD_INT 1
30320: DOUBLE
30321: EQUAL
30322: IFTRUE 30326
30324: GO 30363
30326: POP
// components := components ^ SelectChassis ( side , nation , factory , 1 ) ; 2 :
30327: LD_ADDR_VAR 0 6
30331: PUSH
30332: LD_VAR 0 6
30336: PUSH
30337: LD_VAR 0 1
30341: PPUSH
30342: LD_VAR 0 2
30346: PPUSH
30347: LD_VAR 0 3
30351: PPUSH
30352: LD_INT 1
30354: PPUSH
30355: CALL 30634 0 4
30359: ADD
30360: ST_TO_ADDR
30361: GO 30454
30363: LD_INT 2
30365: DOUBLE
30366: EQUAL
30367: IFTRUE 30371
30369: GO 30408
30371: POP
// components := components ^ SelectChassis ( side , nation , factory , 2 ) ; 3 :
30372: LD_ADDR_VAR 0 6
30376: PUSH
30377: LD_VAR 0 6
30381: PUSH
30382: LD_VAR 0 1
30386: PPUSH
30387: LD_VAR 0 2
30391: PPUSH
30392: LD_VAR 0 3
30396: PPUSH
30397: LD_INT 2
30399: PPUSH
30400: CALL 30634 0 4
30404: ADD
30405: ST_TO_ADDR
30406: GO 30454
30408: LD_INT 3
30410: DOUBLE
30411: EQUAL
30412: IFTRUE 30416
30414: GO 30453
30416: POP
// components := components ^ SelectChassis ( side , nation , factory , 3 ) ; end ;
30417: LD_ADDR_VAR 0 6
30421: PUSH
30422: LD_VAR 0 6
30426: PUSH
30427: LD_VAR 0 1
30431: PPUSH
30432: LD_VAR 0 2
30436: PPUSH
30437: LD_VAR 0 3
30441: PPUSH
30442: LD_INT 3
30444: PPUSH
30445: CALL 30634 0 4
30449: ADD
30450: ST_TO_ADDR
30451: GO 30454
30453: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30454: LD_VAR 0 3
30458: PPUSH
30459: LD_INT 21
30461: PPUSH
30462: CALL 28645 0 2
30466: PUSH
30467: LD_VAR 0 1
30471: PPUSH
30472: CALL 28003 0 1
30476: PUSH
30477: LD_INT 3
30479: ARRAY
30480: PUSH
30481: LD_LOC 55
30485: GREATEREQUAL
30486: AND
30487: IFFALSE 30505
// components := components ^ engine_siberite else
30489: LD_ADDR_VAR 0 6
30493: PUSH
30494: LD_VAR 0 6
30498: PUSH
30499: LD_INT 3
30501: ADD
30502: ST_TO_ADDR
30503: GO 30519
// components := components ^ engine_combustion ;
30505: LD_ADDR_VAR 0 6
30509: PUSH
30510: LD_VAR 0 6
30514: PUSH
30515: LD_INT 1
30517: ADD
30518: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30519: LD_VAR 0 2
30523: PUSH
30524: LD_INT 2
30526: EQUAL
30527: PUSH
30528: LD_VAR 0 1
30532: PPUSH
30533: CALL 31177 0 1
30537: AND
30538: IFFALSE 30556
// components := components ^ control_apeman else
30540: LD_ADDR_VAR 0 6
30544: PUSH
30545: LD_VAR 0 6
30549: PUSH
30550: LD_INT 5
30552: ADD
30553: ST_TO_ADDR
30554: GO 30600
// if ExtensionBuild ( factory , b_ext_computer ) then
30556: LD_VAR 0 3
30560: PPUSH
30561: LD_INT 24
30563: PPUSH
30564: CALL 28645 0 2
30568: IFFALSE 30586
// components := components ^ control_computer else
30570: LD_ADDR_VAR 0 6
30574: PUSH
30575: LD_VAR 0 6
30579: PUSH
30580: LD_INT 3
30582: ADD
30583: ST_TO_ADDR
30584: GO 30600
// components := components ^ control_remote ;
30586: LD_ADDR_VAR 0 6
30590: PUSH
30591: LD_VAR 0 6
30595: PUSH
30596: LD_INT 2
30598: ADD
30599: ST_TO_ADDR
// components := components ^ [ weapon ] ;
30600: LD_ADDR_VAR 0 6
30604: PUSH
30605: LD_VAR 0 6
30609: PUSH
30610: LD_VAR 0 4
30614: PUSH
30615: EMPTY
30616: LIST
30617: ADD
30618: ST_TO_ADDR
// result := components ;
30619: LD_ADDR_VAR 0 5
30623: PUSH
30624: LD_VAR 0 6
30628: ST_TO_ADDR
// end ;
30629: LD_VAR 0 5
30633: RET
// function SelectChassis ( side , nation , factory , weight ) ; var un , vysledek ; begin
30634: LD_INT 0
30636: PPUSH
30637: PPUSH
30638: PPUSH
// vysledek := 0 ;
30639: LD_ADDR_VAR 0 7
30643: PUSH
30644: LD_INT 0
30646: ST_TO_ADDR
// case weight of 1 :
30647: LD_VAR 0 4
30651: PUSH
30652: LD_INT 1
30654: DOUBLE
30655: EQUAL
30656: IFTRUE 30660
30658: GO 30723
30660: POP
// begin case nation of 1 :
30661: LD_VAR 0 2
30665: PUSH
30666: LD_INT 1
30668: DOUBLE
30669: EQUAL
30670: IFTRUE 30674
30672: GO 30685
30674: POP
// vysledek := us_light_wheeled ; 2 :
30675: LD_ADDR_VAR 0 7
30679: PUSH
30680: LD_INT 1
30682: ST_TO_ADDR
30683: GO 30721
30685: LD_INT 2
30687: DOUBLE
30688: EQUAL
30689: IFTRUE 30693
30691: GO 30720
30693: POP
// if hovers_recomended then
30694: LD_LOC 59
30698: IFFALSE 30710
// vysledek := ar_hovercraft else
30700: LD_ADDR_VAR 0 7
30704: PUSH
30705: LD_INT 11
30707: ST_TO_ADDR
30708: GO 30718
// vysledek := ar_light_trike ; end ;
30710: LD_ADDR_VAR 0 7
30714: PUSH
30715: LD_INT 12
30717: ST_TO_ADDR
30718: GO 30721
30720: POP
// end ; 2 :
30721: GO 30985
30723: LD_INT 2
30725: DOUBLE
30726: EQUAL
30727: IFTRUE 30731
30729: GO 30880
30731: POP
// begin if ( not flat_land ) and TrackExtension ( factory ) then
30732: LD_LOC 60
30736: NOT
30737: PUSH
30738: LD_VAR 0 3
30742: PPUSH
30743: CALL 29466 0 1
30747: AND
30748: IFFALSE 30815
// case nation of 1 :
30750: LD_VAR 0 2
30754: PUSH
30755: LD_INT 1
30757: DOUBLE
30758: EQUAL
30759: IFTRUE 30763
30761: GO 30774
30763: POP
// vysledek := us_medium_tracked ; 2 :
30764: LD_ADDR_VAR 0 7
30768: PUSH
30769: LD_INT 3
30771: ST_TO_ADDR
30772: GO 30813
30774: LD_INT 2
30776: DOUBLE
30777: EQUAL
30778: IFTRUE 30782
30780: GO 30793
30782: POP
// vysledek := ar_half_tracked ; 3 :
30783: LD_ADDR_VAR 0 7
30787: PUSH
30788: LD_INT 14
30790: ST_TO_ADDR
30791: GO 30813
30793: LD_INT 3
30795: DOUBLE
30796: EQUAL
30797: IFTRUE 30801
30799: GO 30812
30801: POP
// vysledek := ru_medium_tracked ; end else
30802: LD_ADDR_VAR 0 7
30806: PUSH
30807: LD_INT 22
30809: ST_TO_ADDR
30810: GO 30813
30812: POP
30813: GO 30878
// case nation of 1 :
30815: LD_VAR 0 2
30819: PUSH
30820: LD_INT 1
30822: DOUBLE
30823: EQUAL
30824: IFTRUE 30828
30826: GO 30839
30828: POP
// vysledek := us_medium_wheeled ; 2 :
30829: LD_ADDR_VAR 0 7
30833: PUSH
30834: LD_INT 2
30836: ST_TO_ADDR
30837: GO 30878
30839: LD_INT 2
30841: DOUBLE
30842: EQUAL
30843: IFTRUE 30847
30845: GO 30858
30847: POP
// vysledek := ar_medium_trike ; 3 :
30848: LD_ADDR_VAR 0 7
30852: PUSH
30853: LD_INT 13
30855: ST_TO_ADDR
30856: GO 30878
30858: LD_INT 3
30860: DOUBLE
30861: EQUAL
30862: IFTRUE 30866
30864: GO 30877
30866: POP
// vysledek := ru_medium_wheeled ; end end ; 3 :
30867: LD_ADDR_VAR 0 7
30871: PUSH
30872: LD_INT 21
30874: ST_TO_ADDR
30875: GO 30878
30877: POP
30878: GO 30985
30880: LD_INT 3
30882: DOUBLE
30883: EQUAL
30884: IFTRUE 30888
30886: GO 30984
30888: POP
// begin case nation of 1 :
30889: LD_VAR 0 2
30893: PUSH
30894: LD_INT 1
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30902
30900: GO 30941
30902: POP
// if GetTech ( side , tech_AdvChassis ) = state_researched then
30903: LD_VAR 0 1
30907: PPUSH
30908: LD_INT 36
30910: PPUSH
30911: CALL_OW 321
30915: PUSH
30916: LD_INT 2
30918: EQUAL
30919: IFFALSE 30931
// vysledek := us_morphling else
30921: LD_ADDR_VAR 0 7
30925: PUSH
30926: LD_INT 5
30928: ST_TO_ADDR
30929: GO 30939
// vysledek := us_heavy_tracked ; 3 :
30931: LD_ADDR_VAR 0 7
30935: PUSH
30936: LD_INT 4
30938: ST_TO_ADDR
30939: GO 30982
30941: LD_INT 3
30943: DOUBLE
30944: EQUAL
30945: IFTRUE 30949
30947: GO 30981
30949: POP
// if TrackExtension ( factory ) then
30950: LD_VAR 0 3
30954: PPUSH
30955: CALL 29466 0 1
30959: IFFALSE 30971
// vysledek := ru_heavy_tracked else
30961: LD_ADDR_VAR 0 7
30965: PUSH
30966: LD_INT 24
30968: ST_TO_ADDR
30969: GO 30979
// vysledek := ru_heavy_wheeled ; end end ; end ;
30971: LD_ADDR_VAR 0 7
30975: PUSH
30976: LD_INT 23
30978: ST_TO_ADDR
30979: GO 30982
30981: POP
30982: GO 30985
30984: POP
// result := vysledek ;
30985: LD_ADDR_VAR 0 5
30989: PUSH
30990: LD_VAR 0 7
30994: ST_TO_ADDR
// end ;
30995: LD_VAR 0 5
30999: RET
// function ChassisWeight ( nation , weapon ) ; var chassis , un , vysledek , weapon_list ; begin
31000: LD_INT 0
31002: PPUSH
31003: PPUSH
31004: PPUSH
31005: PPUSH
31006: PPUSH
// case nation of 1 :
31007: LD_VAR 0 1
31011: PUSH
31012: LD_INT 1
31014: DOUBLE
31015: EQUAL
31016: IFTRUE 31020
31018: GO 31033
31020: POP
// weapon_list := us_weapons ; 2 :
31021: LD_ADDR_VAR 0 7
31025: PUSH
31026: LD_LOC 52
31030: ST_TO_ADDR
31031: GO 31076
31033: LD_INT 2
31035: DOUBLE
31036: EQUAL
31037: IFTRUE 31041
31039: GO 31054
31041: POP
// weapon_list := ar_weapons ; 3 :
31042: LD_ADDR_VAR 0 7
31046: PUSH
31047: LD_LOC 53
31051: ST_TO_ADDR
31052: GO 31076
31054: LD_INT 3
31056: DOUBLE
31057: EQUAL
31058: IFTRUE 31062
31060: GO 31075
31062: POP
// weapon_list := ru_weapons ; end ;
31063: LD_ADDR_VAR 0 7
31067: PUSH
31068: LD_LOC 54
31072: ST_TO_ADDR
31073: GO 31076
31075: POP
// vysledek := false ;
31076: LD_ADDR_VAR 0 6
31080: PUSH
31081: LD_INT 0
31083: ST_TO_ADDR
// for chassis = 1 to 3 do
31084: LD_ADDR_VAR 0 4
31088: PUSH
31089: DOUBLE
31090: LD_INT 1
31092: DEC
31093: ST_TO_ADDR
31094: LD_INT 3
31096: PUSH
31097: FOR_TO
31098: IFFALSE 31160
// if not vysledek then
31100: LD_VAR 0 6
31104: NOT
31105: IFFALSE 31158
// for un in weapon_list [ chassis ] do
31107: LD_ADDR_VAR 0 5
31111: PUSH
31112: LD_VAR 0 7
31116: PUSH
31117: LD_VAR 0 4
31121: ARRAY
31122: PUSH
31123: FOR_IN
31124: IFFALSE 31156
// if weapon = un [ 1 ] then
31126: LD_VAR 0 2
31130: PUSH
31131: LD_VAR 0 5
31135: PUSH
31136: LD_INT 1
31138: ARRAY
31139: EQUAL
31140: IFFALSE 31154
// begin vysledek := chassis ;
31142: LD_ADDR_VAR 0 6
31146: PUSH
31147: LD_VAR 0 4
31151: ST_TO_ADDR
// break ;
31152: GO 31156
// end ;
31154: GO 31123
31156: POP
31157: POP
31158: GO 31097
31160: POP
31161: POP
// result := vysledek ;
31162: LD_ADDR_VAR 0 3
31166: PUSH
31167: LD_VAR 0 6
31171: ST_TO_ADDR
// end ;
31172: LD_VAR 0 3
31176: RET
// function ApemanCanDrive ( side ) ; var un ; begin
31177: LD_INT 0
31179: PPUSH
31180: PPUSH
// result := ( GetTech ( side , tech_ApeNeural ) = state_researched ) and FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31181: LD_ADDR_VAR 0 2
31185: PUSH
31186: LD_VAR 0 1
31190: PPUSH
31191: LD_INT 3
31193: PPUSH
31194: CALL_OW 321
31198: PUSH
31199: LD_INT 2
31201: EQUAL
31202: PUSH
31203: LD_INT 22
31205: PUSH
31206: LD_VAR 0 1
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 25
31217: PUSH
31218: LD_INT 12
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PPUSH
31229: CALL_OW 69
31233: AND
31234: ST_TO_ADDR
// end ;
31235: LD_VAR 0 2
31239: RET
// function transfer_mechanics ( side , mechanics , factory , components ) ; var un , isin ; begin
31240: LD_INT 0
31242: PPUSH
31243: PPUSH
31244: PPUSH
// isin := UnitsInside ( factory ) ;
31245: LD_ADDR_VAR 0 7
31249: PUSH
31250: LD_VAR 0 3
31254: PPUSH
31255: CALL_OW 313
31259: ST_TO_ADDR
// if ( 0 + isin ) > 5 then
31260: LD_INT 0
31262: PUSH
31263: LD_VAR 0 7
31267: PLUS
31268: PUSH
31269: LD_INT 5
31271: GREATER
31272: IFFALSE 31284
// begin result := true ;
31274: LD_ADDR_VAR 0 5
31278: PUSH
31279: LD_INT 1
31281: ST_TO_ADDR
// exit ;
31282: GO 31506
// end ; un := true ;
31284: LD_ADDR_VAR 0 6
31288: PUSH
31289: LD_INT 1
31291: ST_TO_ADDR
// if side = ar then
31292: LD_VAR 0 1
31296: PUSH
31297: LD_EXP 4
31301: EQUAL
31302: IFFALSE 31332
// mechanics := UnitFilter ( mechanics , [ f_not , [ f_driving ] ] ) ;
31304: LD_ADDR_VAR 0 2
31308: PUSH
31309: LD_VAR 0 2
31313: PPUSH
31314: LD_INT 3
31316: PUSH
31317: LD_INT 55
31319: PUSH
31320: EMPTY
31321: LIST
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PPUSH
31327: CALL_OW 72
31331: ST_TO_ADDR
// DoEnterUnit ( mechanics , factory ) ;
31332: LD_VAR 0 2
31336: PPUSH
31337: LD_VAR 0 3
31341: PPUSH
31342: CALL 31511 0 2
// if components [ 3 ] = control_apeman then
31346: LD_VAR 0 4
31350: PUSH
31351: LD_INT 3
31353: ARRAY
31354: PUSH
31355: LD_INT 5
31357: EQUAL
31358: IFFALSE 31496
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] , [ f_not , [ f_hastask ] ] ] ) ;
31360: LD_ADDR_VAR 0 6
31364: PUSH
31365: LD_INT 22
31367: PUSH
31368: LD_VAR 0 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 25
31379: PUSH
31380: LD_INT 12
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 3
31389: PUSH
31390: LD_INT 60
31392: PUSH
31393: EMPTY
31394: LIST
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: LIST
31404: PPUSH
31405: CALL_OW 69
31409: ST_TO_ADDR
// if un then
31410: LD_VAR 0 6
31414: IFFALSE 31436
// DoEnterUnit ( un [ 1 ] , factory ) else
31416: LD_VAR 0 6
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: LD_VAR 0 3
31429: PPUSH
31430: CALL 31511 0 2
31434: GO 31496
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31436: LD_ADDR_VAR 0 6
31440: PUSH
31441: LD_INT 22
31443: PUSH
31444: LD_VAR 0 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 25
31455: PUSH
31456: LD_INT 12
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PPUSH
31467: CALL_OW 69
31471: ST_TO_ADDR
// if un then
31472: LD_VAR 0 6
31476: IFFALSE 31496
// DoEnterUnit ( un [ 1 ] , factory ) ;
31478: LD_VAR 0 6
31482: PUSH
31483: LD_INT 1
31485: ARRAY
31486: PPUSH
31487: LD_VAR 0 3
31491: PPUSH
31492: CALL 31511 0 2
// end ; end ; result := un ;
31496: LD_ADDR_VAR 0 5
31500: PUSH
31501: LD_VAR 0 6
31505: ST_TO_ADDR
// end ;
31506: LD_VAR 0 5
31510: RET
// function DoEnterUnit ( moving_un_list , into_un ) ; var inside_un , t , moving_un ; begin
31511: LD_INT 0
31513: PPUSH
31514: PPUSH
31515: PPUSH
31516: PPUSH
// for moving_un in moving_un_list do
31517: LD_ADDR_VAR 0 6
31521: PUSH
31522: LD_VAR 0 1
31526: PUSH
31527: FOR_IN
31528: IFFALSE 31665
// begin inside_un = IsInUnit ( moving_un ) ;
31530: LD_ADDR_VAR 0 4
31534: PUSH
31535: LD_VAR 0 6
31539: PPUSH
31540: CALL_OW 310
31544: ST_TO_ADDR
// if inside_un <> into_un then
31545: LD_VAR 0 4
31549: PUSH
31550: LD_VAR 0 2
31554: NONEQUAL
31555: IFFALSE 31663
// begin if inside_un > 0 then
31557: LD_VAR 0 4
31561: PUSH
31562: LD_INT 0
31564: GREATER
31565: IFFALSE 31584
// t = GetType ( inside_un ) else
31567: LD_ADDR_VAR 0 5
31571: PUSH
31572: LD_VAR 0 4
31576: PPUSH
31577: CALL_OW 247
31581: ST_TO_ADDR
31582: GO 31592
// t = 0 ;
31584: LD_ADDR_VAR 0 5
31588: PUSH
31589: LD_INT 0
31591: ST_TO_ADDR
// case t of unit_vehicle :
31592: LD_VAR 0 5
31596: PUSH
31597: LD_INT 2
31599: DOUBLE
31600: EQUAL
31601: IFTRUE 31605
31603: GO 31617
31605: POP
// ComExitVehicle ( moving_un ) ; unit_building :
31606: LD_VAR 0 6
31610: PPUSH
31611: CALL_OW 121
31615: GO 31663
31617: LD_INT 3
31619: DOUBLE
31620: EQUAL
31621: IFTRUE 31625
31623: GO 31637
31625: POP
// ComExitBuilding ( moving_un ) ; 0 :
31626: LD_VAR 0 6
31630: PPUSH
31631: CALL_OW 122
31635: GO 31663
31637: LD_INT 0
31639: DOUBLE
31640: EQUAL
31641: IFTRUE 31645
31643: GO 31662
31645: POP
// ComEnterUnit ( moving_un , into_un ) ; end ;
31646: LD_VAR 0 6
31650: PPUSH
31651: LD_VAR 0 2
31655: PPUSH
31656: CALL_OW 120
31660: GO 31663
31662: POP
// end ; end ;
31663: GO 31527
31665: POP
31666: POP
// end ;
31667: LD_VAR 0 3
31671: RET
// function start_building_vehicle ( nation , factory , vehicle ) ; begin
31672: LD_INT 0
31674: PPUSH
// if ( not UnitsInside ( factory ) ) and ( nation <> ar ) then
31675: LD_VAR 0 2
31679: PPUSH
31680: CALL_OW 313
31684: NOT
31685: PUSH
31686: LD_VAR 0 1
31690: PUSH
31691: LD_EXP 4
31695: NONEQUAL
31696: AND
31697: IFFALSE 31709
// begin result = false ;
31699: LD_ADDR_VAR 0 4
31703: PUSH
31704: LD_INT 0
31706: ST_TO_ADDR
// exit ;
31707: GO 31815
// end ; if vehicle [ 3 ] = control_apeman and not ApemanInFactory ( factory ) then
31709: LD_VAR 0 3
31713: PUSH
31714: LD_INT 3
31716: ARRAY
31717: PUSH
31718: LD_INT 5
31720: EQUAL
31721: PUSH
31722: LD_VAR 0 2
31726: PPUSH
31727: CALL 31820 0 1
31731: NOT
31732: AND
31733: IFFALSE 31745
// begin result = false ;
31735: LD_ADDR_VAR 0 4
31739: PUSH
31740: LD_INT 0
31742: ST_TO_ADDR
// exit ;
31743: GO 31815
// end ; ComChangeProfession ( UnitsInside ( factory ) , class_mechanic ) ;
31745: LD_VAR 0 2
31749: PPUSH
31750: CALL_OW 313
31754: PPUSH
31755: LD_INT 3
31757: PPUSH
31758: CALL_OW 123
// ComConstruct ( factory , vehicle [ 1 ] , vehicle [ 2 ] , vehicle [ 3 ] , vehicle [ 4 ] ) ;
31762: LD_VAR 0 2
31766: PPUSH
31767: LD_VAR 0 3
31771: PUSH
31772: LD_INT 1
31774: ARRAY
31775: PPUSH
31776: LD_VAR 0 3
31780: PUSH
31781: LD_INT 2
31783: ARRAY
31784: PPUSH
31785: LD_VAR 0 3
31789: PUSH
31790: LD_INT 3
31792: ARRAY
31793: PPUSH
31794: LD_VAR 0 3
31798: PUSH
31799: LD_INT 4
31801: ARRAY
31802: PPUSH
31803: CALL_OW 125
// result = true ;
31807: LD_ADDR_VAR 0 4
31811: PUSH
31812: LD_INT 1
31814: ST_TO_ADDR
// end ;
31815: LD_VAR 0 4
31819: RET
// function ApemanInFactory ( factory ) ; var un , list , vysledek ; begin
31820: LD_INT 0
31822: PPUSH
31823: PPUSH
31824: PPUSH
31825: PPUSH
// vysledek := false ;
31826: LD_ADDR_VAR 0 5
31830: PUSH
31831: LD_INT 0
31833: ST_TO_ADDR
// list := UnitsInside ( factory ) ;
31834: LD_ADDR_VAR 0 4
31838: PUSH
31839: LD_VAR 0 1
31843: PPUSH
31844: CALL_OW 313
31848: ST_TO_ADDR
// for un in list do
31849: LD_ADDR_VAR 0 3
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: FOR_IN
31860: IFFALSE 31889
// if GetClass ( un ) = class_apeman then
31862: LD_VAR 0 3
31866: PPUSH
31867: CALL_OW 257
31871: PUSH
31872: LD_INT 12
31874: EQUAL
31875: IFFALSE 31887
// begin vysledek := true ;
31877: LD_ADDR_VAR 0 5
31881: PUSH
31882: LD_INT 1
31884: ST_TO_ADDR
// break ;
31885: GO 31889
// end ;
31887: GO 31859
31889: POP
31890: POP
// result := vysledek ;
31891: LD_ADDR_VAR 0 2
31895: PUSH
31896: LD_VAR 0 5
31900: ST_TO_ADDR
// end ;
31901: LD_VAR 0 2
31905: RET
// function cleanup_extensions ( side , nation , factory ) ; var un , list , crane , cargo_bay , nation_crane , nation_cargo ; begin
31906: LD_INT 0
31908: PPUSH
31909: PPUSH
31910: PPUSH
31911: PPUSH
31912: PPUSH
31913: PPUSH
31914: PPUSH
// case nation of 1 :
31915: LD_VAR 0 2
31919: PUSH
31920: LD_INT 1
31922: DOUBLE
31923: EQUAL
31924: IFTRUE 31928
31926: GO 31947
31928: POP
// begin nation_cargo := us_cargo_bay ;
31929: LD_ADDR_VAR 0 10
31933: PUSH
31934: LD_INT 12
31936: ST_TO_ADDR
// nation_crane := us_crane ;
31937: LD_ADDR_VAR 0 9
31941: PUSH
31942: LD_INT 13
31944: ST_TO_ADDR
// end ; 2 :
31945: GO 32002
31947: LD_INT 2
31949: DOUBLE
31950: EQUAL
31951: IFTRUE 31955
31953: GO 31974
31955: POP
// begin nation_cargo := ar_cargo_bay ;
31956: LD_ADDR_VAR 0 10
31960: PUSH
31961: LD_INT 32
31963: ST_TO_ADDR
// nation_crane := 0 ;
31964: LD_ADDR_VAR 0 9
31968: PUSH
31969: LD_INT 0
31971: ST_TO_ADDR
// end ; 3 :
31972: GO 32002
31974: LD_INT 3
31976: DOUBLE
31977: EQUAL
31978: IFTRUE 31982
31980: GO 32001
31982: POP
// begin nation_cargo := ru_cargo_bay ;
31983: LD_ADDR_VAR 0 10
31987: PUSH
31988: LD_INT 51
31990: ST_TO_ADDR
// nation_crane := ru_crane ;
31991: LD_ADDR_VAR 0 9
31995: PUSH
31996: LD_INT 52
31998: ST_TO_ADDR
// end ; end ;
31999: GO 32002
32001: POP
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
32002: LD_ADDR_VAR 0 8
32006: PUSH
32007: LD_INT 22
32009: PUSH
32010: LD_VAR 0 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 21
32021: PUSH
32022: LD_INT 2
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 34
32031: PUSH
32032: LD_VAR 0 10
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 69
32050: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
32051: LD_ADDR_VAR 0 7
32055: PUSH
32056: LD_INT 22
32058: PUSH
32059: LD_VAR 0 1
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 21
32070: PUSH
32071: LD_INT 2
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: LD_INT 34
32080: PUSH
32081: LD_VAR 0 9
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: LIST
32094: PPUSH
32095: CALL_OW 69
32099: ST_TO_ADDR
// if ( nation_crane in extension_wanted ) and crane then
32100: LD_VAR 0 9
32104: PUSH
32105: LD_EXP 73
32109: IN
32110: PUSH
32111: LD_VAR 0 7
32115: AND
32116: IFFALSE 32134
// extension_wanted := extension_wanted diff nation_crane ;
32118: LD_ADDR_EXP 73
32122: PUSH
32123: LD_EXP 73
32127: PUSH
32128: LD_VAR 0 9
32132: DIFF
32133: ST_TO_ADDR
// if ( nation_cargo in extension_wanted ) and cargo_bay then
32134: LD_VAR 0 10
32138: PUSH
32139: LD_EXP 73
32143: IN
32144: PUSH
32145: LD_VAR 0 8
32149: AND
32150: IFFALSE 32168
// extension_wanted := extension_wanted diff nation_cargo ;
32152: LD_ADDR_EXP 73
32156: PUSH
32157: LD_EXP 73
32161: PUSH
32162: LD_VAR 0 10
32166: DIFF
32167: ST_TO_ADDR
// list := extension_wanted ;
32168: LD_ADDR_VAR 0 6
32172: PUSH
32173: LD_EXP 73
32177: ST_TO_ADDR
// for un in list do
32178: LD_ADDR_VAR 0 5
32182: PUSH
32183: LD_VAR 0 6
32187: PUSH
32188: FOR_IN
32189: IFFALSE 32222
// begin if not un in main_extensions then
32191: LD_VAR 0 5
32195: PUSH
32196: LD_LOC 58
32200: IN
32201: NOT
32202: IFFALSE 32220
// extension_wanted := extension_wanted diff un ;
32204: LD_ADDR_EXP 73
32208: PUSH
32209: LD_EXP 73
32213: PUSH
32214: LD_VAR 0 5
32218: DIFF
32219: ST_TO_ADDR
// end ;
32220: GO 32188
32222: POP
32223: POP
// end ; end_of_file
32224: LD_VAR 0 4
32228: RET
// var mc_list ; var b_list ; export function init_keep_base ; var un , build , side ; begin
32229: LD_INT 0
32231: PPUSH
32232: PPUSH
32233: PPUSH
32234: PPUSH
// b_list := [ ] ;
32235: LD_ADDR_LOC 62
32239: PUSH
32240: EMPTY
32241: ST_TO_ADDR
// mc_list := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
32242: LD_ADDR_LOC 61
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 0
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: LD_INT 0
32264: PUSH
32265: LD_INT 0
32267: PUSH
32268: LD_INT 0
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: ST_TO_ADDR
// for side = 1 to 8 do
32281: LD_ADDR_VAR 0 4
32285: PUSH
32286: DOUBLE
32287: LD_INT 1
32289: DEC
32290: ST_TO_ADDR
32291: LD_INT 8
32293: PUSH
32294: FOR_TO
32295: IFFALSE 32410
// if side in cpu_list then
32297: LD_VAR 0 4
32301: PUSH
32302: LD_EXP 8
32306: IN
32307: IFFALSE 32392
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
32309: LD_ADDR_VAR 0 2
32313: PUSH
32314: LD_INT 22
32316: PUSH
32317: LD_VAR 0 4
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 21
32328: PUSH
32329: LD_INT 3
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 69
32344: ST_TO_ADDR
// if un then
32345: LD_VAR 0 2
32349: IFFALSE 32390
// b_list := Insert ( b_list , side , GetBuildList ( GetBase ( un [ 1 ] ) ) ) ;
32351: LD_ADDR_LOC 62
32355: PUSH
32356: LD_LOC 62
32360: PPUSH
32361: LD_VAR 0 4
32365: PPUSH
32366: LD_VAR 0 2
32370: PUSH
32371: LD_INT 1
32373: ARRAY
32374: PPUSH
32375: CALL_OW 274
32379: PPUSH
32380: CALL_OW 417
32384: PPUSH
32385: CALL_OW 2
32389: ST_TO_ADDR
// end else
32390: GO 32408
// b_list := b_list ^ [ [ ] ] ;
32392: LD_ADDR_LOC 62
32396: PUSH
32397: LD_LOC 62
32401: PUSH
32402: EMPTY
32403: PUSH
32404: EMPTY
32405: LIST
32406: ADD
32407: ST_TO_ADDR
32408: GO 32294
32410: POP
32411: POP
// end ;
32412: LD_VAR 0 1
32416: RET
// every 0 0$5.2 trigger us in cpu_list do var side , list , engineers ;
32417: LD_EXP 3
32421: PUSH
32422: LD_EXP 8
32426: IN
32427: IFFALSE 32632
32429: GO 32431
32431: DISABLE
32432: LD_INT 0
32434: PPUSH
32435: PPUSH
32436: PPUSH
// begin list := [ ] ;
32437: LD_ADDR_VAR 0 2
32441: PUSH
32442: EMPTY
32443: ST_TO_ADDR
// for side = 1 to 8 do
32444: LD_ADDR_VAR 0 1
32448: PUSH
32449: DOUBLE
32450: LD_INT 1
32452: DEC
32453: ST_TO_ADDR
32454: LD_INT 8
32456: PUSH
32457: FOR_TO
32458: IFFALSE 32619
// if ( side in cpu_list ) then
32460: LD_VAR 0 1
32464: PUSH
32465: LD_EXP 8
32469: IN
32470: IFFALSE 32603
// begin if not ExistMc ( mc_list [ side ] ) then
32472: LD_LOC 61
32476: PUSH
32477: LD_VAR 0 1
32481: ARRAY
32482: PPUSH
32483: CALL_OW 386
32487: NOT
32488: IFFALSE 32579
// begin engineers := request_people ( side , class_engineer , 5 ) ;
32490: LD_ADDR_VAR 0 3
32494: PUSH
32495: LD_VAR 0 1
32499: PPUSH
32500: LD_INT 2
32502: PPUSH
32503: LD_INT 5
32505: PPUSH
32506: CALL 26408 0 3
32510: ST_TO_ADDR
// if engineers then
32511: LD_VAR 0 3
32515: IFFALSE 32563
// list := list ^ McBase ( 3 , engineers , b_list [ side ] , 0 , 0 , 0 ) else
32517: LD_ADDR_VAR 0 2
32521: PUSH
32522: LD_VAR 0 2
32526: PUSH
32527: LD_INT 3
32529: PPUSH
32530: LD_VAR 0 3
32534: PPUSH
32535: LD_LOC 62
32539: PUSH
32540: LD_VAR 0 1
32544: ARRAY
32545: PPUSH
32546: LD_INT 0
32548: PPUSH
32549: LD_INT 0
32551: PPUSH
32552: LD_INT 0
32554: PPUSH
32555: CALL_OW 397
32559: ADD
32560: ST_TO_ADDR
32561: GO 32577
// list := list ^ 0 end else
32563: LD_ADDR_VAR 0 2
32567: PUSH
32568: LD_VAR 0 2
32572: PUSH
32573: LD_INT 0
32575: ADD
32576: ST_TO_ADDR
32577: GO 32601
// list := list ^ mc_list [ side ] ;
32579: LD_ADDR_VAR 0 2
32583: PUSH
32584: LD_VAR 0 2
32588: PUSH
32589: LD_LOC 61
32593: PUSH
32594: LD_VAR 0 1
32598: ARRAY
32599: ADD
32600: ST_TO_ADDR
// end else
32601: GO 32617
// list := list ^ 0 ;
32603: LD_ADDR_VAR 0 2
32607: PUSH
32608: LD_VAR 0 2
32612: PUSH
32613: LD_INT 0
32615: ADD
32616: ST_TO_ADDR
32617: GO 32457
32619: POP
32620: POP
// mc_list := list ;
32621: LD_ADDR_LOC 61
32625: PUSH
32626: LD_VAR 0 2
32630: ST_TO_ADDR
// enable ;
32631: ENABLE
// end ; end_of_file
32632: PPOPN 3
32634: END
// var load_global , load_local_cpu , load_local_you ; var global_delay , cpu_delay , you_delay ; var crates_loading_area ; export function init_crates_loading ; begin
32635: LD_INT 0
32637: PPUSH
// global_delay := 10 10$0 ;
32638: LD_ADDR_LOC 66
32642: PUSH
32643: LD_INT 21000
32645: ST_TO_ADDR
// cpu_delay := 0 0$90 ;
32646: LD_ADDR_LOC 67
32650: PUSH
32651: LD_INT 3150
32653: ST_TO_ADDR
// you_delay := 3 3$30 ;
32654: LD_ADDR_LOC 68
32658: PUSH
32659: LD_INT 7350
32661: ST_TO_ADDR
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32662: LD_ADDR_LOC 63
32666: PUSH
32667: LD_OWVAR 1
32671: PUSH
32672: LD_LOC 66
32676: PUSH
32677: LD_INT 1400
32679: MINUS
32680: PPUSH
32681: LD_LOC 66
32685: PUSH
32686: LD_INT 2100
32688: PLUS
32689: PPUSH
32690: CALL_OW 12
32694: PLUS
32695: ST_TO_ADDR
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
32696: LD_ADDR_LOC 64
32700: PUSH
32701: LD_OWVAR 1
32705: PUSH
32706: LD_LOC 67
32710: PUSH
32711: LD_INT 700
32713: MINUS
32714: PPUSH
32715: LD_LOC 67
32719: PUSH
32720: LD_INT 700
32722: PLUS
32723: PPUSH
32724: CALL_OW 12
32728: PLUS
32729: ST_TO_ADDR
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
32730: LD_ADDR_LOC 65
32734: PUSH
32735: LD_OWVAR 1
32739: PUSH
32740: LD_LOC 68
32744: PUSH
32745: LD_INT 700
32747: MINUS
32748: PPUSH
32749: LD_LOC 68
32753: PUSH
32754: LD_INT 700
32756: PLUS
32757: PPUSH
32758: CALL_OW 12
32762: PLUS
32763: ST_TO_ADDR
// crates_loading_area := [ us_crates , ar_crates , ru_crates ] ;
32764: LD_ADDR_LOC 69
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: LD_INT 3
32774: PUSH
32775: LD_INT 2
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: LIST
32782: ST_TO_ADDR
// end ;
32783: LD_VAR 0 1
32787: RET
// every 0 0$5.1 trigger TICK > load_global do var c , sur , i ;
32788: LD_OWVAR 1
32792: PUSH
32793: LD_LOC 63
32797: GREATER
32798: IFFALSE 32971
32800: GO 32802
32802: DISABLE
32803: LD_INT 0
32805: PPUSH
32806: PPUSH
32807: PPUSH
// begin c := RandHex ( false ) ;
32808: LD_ADDR_VAR 0 1
32812: PUSH
32813: LD_INT 0
32815: PPUSH
32816: CALL_OW 15
32820: ST_TO_ADDR
// sur := [ ] ;
32821: LD_ADDR_VAR 0 2
32825: PUSH
32826: EMPTY
32827: ST_TO_ADDR
// for i = 1 to 4 do
32828: LD_ADDR_VAR 0 3
32832: PUSH
32833: DOUBLE
32834: LD_INT 1
32836: DEC
32837: ST_TO_ADDR
32838: LD_INT 4
32840: PUSH
32841: FOR_TO
32842: IFFALSE 32889
// sur := sur ^ [ RandHexXYR ( c [ 1 ] , c [ 2 ] , 1 , false ) ] ;
32844: LD_ADDR_VAR 0 2
32848: PUSH
32849: LD_VAR 0 2
32853: PUSH
32854: LD_VAR 0 1
32858: PUSH
32859: LD_INT 1
32861: ARRAY
32862: PPUSH
32863: LD_VAR 0 1
32867: PUSH
32868: LD_INT 2
32870: ARRAY
32871: PPUSH
32872: LD_INT 1
32874: PPUSH
32875: LD_INT 0
32877: PPUSH
32878: CALL_OW 17
32882: PUSH
32883: EMPTY
32884: LIST
32885: ADD
32886: ST_TO_ADDR
32887: GO 32841
32889: POP
32890: POP
// for i in sur do
32891: LD_ADDR_VAR 0 3
32895: PUSH
32896: LD_VAR 0 2
32900: PUSH
32901: FOR_IN
32902: IFFALSE 32934
// CreateCratesXY ( 5 , i [ 1 ] , i [ 2 ] , true ) ;
32904: LD_INT 5
32906: PPUSH
32907: LD_VAR 0 3
32911: PUSH
32912: LD_INT 1
32914: ARRAY
32915: PPUSH
32916: LD_VAR 0 3
32920: PUSH
32921: LD_INT 2
32923: ARRAY
32924: PPUSH
32925: LD_INT 1
32927: PPUSH
32928: CALL_OW 54
32932: GO 32901
32934: POP
32935: POP
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32936: LD_ADDR_LOC 63
32940: PUSH
32941: LD_OWVAR 1
32945: PUSH
32946: LD_LOC 66
32950: PUSH
32951: LD_INT 1400
32953: MINUS
32954: PPUSH
32955: LD_LOC 66
32959: PUSH
32960: LD_INT 2100
32962: PLUS
32963: PPUSH
32964: CALL_OW 12
32968: PLUS
32969: ST_TO_ADDR
// enable ;
32970: ENABLE
// end ;
32971: PPOPN 3
32973: END
// every 0 0$5.4 trigger TICK > load_local_cpu do var un ;
32974: LD_OWVAR 1
32978: PUSH
32979: LD_LOC 64
32983: GREATER
32984: IFFALSE 33101
32986: GO 32988
32988: DISABLE
32989: LD_INT 0
32991: PPUSH
// begin if GetResourceArea ( us_crates , mat_cans ) < 250 then
32992: LD_INT 1
32994: PPUSH
32995: LD_INT 1
32997: PPUSH
32998: CALL_OW 287
33002: PUSH
33003: LD_INT 250
33005: LESS
33006: IFFALSE 33029
// CreateCratesArea ( Rand ( 3 , 5 ) , us_crates , true ) ;
33008: LD_INT 3
33010: PPUSH
33011: LD_INT 5
33013: PPUSH
33014: CALL_OW 12
33018: PPUSH
33019: LD_INT 1
33021: PPUSH
33022: LD_INT 1
33024: PPUSH
33025: CALL_OW 55
// if GetResourceArea ( ru_crates , mat_cans ) < 250 then
33029: LD_INT 2
33031: PPUSH
33032: LD_INT 1
33034: PPUSH
33035: CALL_OW 287
33039: PUSH
33040: LD_INT 250
33042: LESS
33043: IFFALSE 33066
// CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
33045: LD_INT 3
33047: PPUSH
33048: LD_INT 5
33050: PPUSH
33051: CALL_OW 12
33055: PPUSH
33056: LD_INT 2
33058: PPUSH
33059: LD_INT 1
33061: PPUSH
33062: CALL_OW 55
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33066: LD_ADDR_LOC 64
33070: PUSH
33071: LD_OWVAR 1
33075: PUSH
33076: LD_LOC 67
33080: PUSH
33081: LD_INT 700
33083: MINUS
33084: PPUSH
33085: LD_LOC 67
33089: PUSH
33090: LD_INT 700
33092: PLUS
33093: PPUSH
33094: CALL_OW 12
33098: PLUS
33099: ST_TO_ADDR
// enable ;
33100: ENABLE
// end ;
33101: PPOPN 1
33103: END
// every 0 0$5.3 trigger TICK > load_local_you do
33104: LD_OWVAR 1
33108: PUSH
33109: LD_LOC 65
33113: GREATER
33114: IFFALSE 33191
33116: GO 33118
33118: DISABLE
// begin if GetResourceArea ( ar_crates , mat_cans ) < 250 then
33119: LD_INT 3
33121: PPUSH
33122: LD_INT 1
33124: PPUSH
33125: CALL_OW 287
33129: PUSH
33130: LD_INT 250
33132: LESS
33133: IFFALSE 33156
// CreateCratesArea ( Rand ( 1 , 5 ) , ar_crates , true ) ;
33135: LD_INT 1
33137: PPUSH
33138: LD_INT 5
33140: PPUSH
33141: CALL_OW 12
33145: PPUSH
33146: LD_INT 3
33148: PPUSH
33149: LD_INT 1
33151: PPUSH
33152: CALL_OW 55
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33156: LD_ADDR_LOC 65
33160: PUSH
33161: LD_OWVAR 1
33165: PUSH
33166: LD_LOC 68
33170: PUSH
33171: LD_INT 700
33173: MINUS
33174: PPUSH
33175: LD_LOC 68
33179: PUSH
33180: LD_INT 700
33182: PLUS
33183: PPUSH
33184: CALL_OW 12
33188: PLUS
33189: ST_TO_ADDR
// enable ;
33190: ENABLE
// end ;
33191: END
// every 0 0$30.1 do var list , side , un , base ;
33192: GO 33194
33194: DISABLE
33195: LD_INT 0
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
// begin for side in cpu_list do
33201: LD_ADDR_VAR 0 2
33205: PUSH
33206: LD_EXP 8
33210: PUSH
33211: FOR_IN
33212: IFFALSE 33366
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
33214: LD_ADDR_VAR 0 1
33218: PUSH
33219: LD_INT 22
33221: PUSH
33222: LD_VAR 0 2
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 21
33233: PUSH
33234: LD_INT 3
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: PUSH
33244: LD_INT 30
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 30
33256: PUSH
33257: LD_INT 1
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: LIST
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: LIST
33273: PPUSH
33274: CALL_OW 69
33278: ST_TO_ADDR
// for un in list do
33279: LD_ADDR_VAR 0 3
33283: PUSH
33284: LD_VAR 0 1
33288: PUSH
33289: FOR_IN
33290: IFFALSE 33362
// begin base := GetBase ( un ) ;
33292: LD_ADDR_VAR 0 4
33296: PUSH
33297: LD_VAR 0 3
33301: PPUSH
33302: CALL_OW 274
33306: ST_TO_ADDR
// if GetResourceType ( base , mat_cans ) < 300 then
33307: LD_VAR 0 4
33311: PPUSH
33312: LD_INT 1
33314: PPUSH
33315: CALL_OW 275
33319: PUSH
33320: LD_INT 300
33322: LESS
33323: IFFALSE 33360
// SetResourceType ( base , mat_cans , GetResourceType ( base , mat_cans ) + ( difficulty * 30 ) ) ;
33325: LD_VAR 0 4
33329: PPUSH
33330: LD_INT 1
33332: PPUSH
33333: LD_VAR 0 4
33337: PPUSH
33338: LD_INT 1
33340: PPUSH
33341: CALL_OW 275
33345: PUSH
33346: LD_OWVAR 67
33350: PUSH
33351: LD_INT 30
33353: MUL
33354: PLUS
33355: PPUSH
33356: CALL_OW 277
// end ;
33360: GO 33289
33362: POP
33363: POP
// end ;
33364: GO 33211
33366: POP
33367: POP
// enable ;
33368: ENABLE
// end ; end_of_file
33369: PPOPN 4
33371: END
// var outside_list , inside_list ; var base_areas , create_areas ; var us_bay , ru_bay , ar_bay ; var us_bad , ru_bad , ar_bad ; export function init_crates_collecting ; begin
33372: LD_INT 0
33374: PPUSH
// outside_list := [ us_crates , ar_crates , ru_crates ] ;
33375: LD_ADDR_LOC 70
33379: PUSH
33380: LD_INT 1
33382: PUSH
33383: LD_INT 3
33385: PUSH
33386: LD_INT 2
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: LIST
33393: ST_TO_ADDR
// inside_list := [ us_inner_base , ar_base , ru_inner_base ] ;
33394: LD_ADDR_LOC 71
33398: PUSH
33399: LD_INT 38
33401: PUSH
33402: LD_INT 13
33404: PUSH
33405: LD_INT 39
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: LIST
33412: ST_TO_ADDR
// base_areas := [ us_base , ar_base , ru_base ] ;
33413: LD_ADDR_LOC 72
33417: PUSH
33418: LD_INT 11
33420: PUSH
33421: LD_INT 13
33423: PUSH
33424: LD_INT 12
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: LIST
33431: ST_TO_ADDR
// create_areas := [ us_create , ar_create , ru_create ] ;
33432: LD_ADDR_LOC 73
33436: PUSH
33437: LD_INT 18
33439: PUSH
33440: LD_INT 19
33442: PUSH
33443: LD_INT 17
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: LIST
33450: ST_TO_ADDR
// us_bad := [ ] ;
33451: LD_ADDR_LOC 77
33455: PUSH
33456: EMPTY
33457: ST_TO_ADDR
// ru_bad := [ ] ;
33458: LD_ADDR_LOC 78
33462: PUSH
33463: EMPTY
33464: ST_TO_ADDR
// ar_bad := [ ] ;
33465: LD_ADDR_LOC 79
33469: PUSH
33470: EMPTY
33471: ST_TO_ADDR
// end ;
33472: LD_VAR 0 1
33476: RET
// every 0 0$5.4 do var un , side , list , cargo , n_cargo , engineers ;
33477: GO 33479
33479: DISABLE
33480: LD_INT 0
33482: PPUSH
33483: PPUSH
33484: PPUSH
33485: PPUSH
33486: PPUSH
33487: PPUSH
// begin for side in cpu_list do
33488: LD_ADDR_VAR 0 2
33492: PUSH
33493: LD_EXP 8
33497: PUSH
33498: FOR_IN
33499: IFFALSE 34026
// begin list := GetListOfCratesInArea ( outside_list [ side ] ) ;
33501: LD_ADDR_VAR 0 3
33505: PUSH
33506: LD_LOC 70
33510: PUSH
33511: LD_VAR 0 2
33515: ARRAY
33516: PPUSH
33517: CALL_OW 435
33521: ST_TO_ADDR
// if list then
33522: LD_VAR 0 3
33526: IFFALSE 33894
// begin case side of 1 :
33528: LD_VAR 0 2
33532: PUSH
33533: LD_INT 1
33535: DOUBLE
33536: EQUAL
33537: IFTRUE 33541
33539: GO 33552
33541: POP
// n_cargo := us_cargo_bay ; 2 :
33542: LD_ADDR_VAR 0 5
33546: PUSH
33547: LD_INT 12
33549: ST_TO_ADDR
33550: GO 33591
33552: LD_INT 2
33554: DOUBLE
33555: EQUAL
33556: IFTRUE 33560
33558: GO 33571
33560: POP
// n_cargo := ar_cargo_bay ; 3 :
33561: LD_ADDR_VAR 0 5
33565: PUSH
33566: LD_INT 32
33568: ST_TO_ADDR
33569: GO 33591
33571: LD_INT 3
33573: DOUBLE
33574: EQUAL
33575: IFTRUE 33579
33577: GO 33590
33579: POP
// n_cargo := ru_cargo_bay ; end ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_INT 51
33587: ST_TO_ADDR
33588: GO 33591
33590: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
33591: LD_ADDR_VAR 0 4
33595: PUSH
33596: LD_INT 22
33598: PUSH
33599: LD_VAR 0 2
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 21
33610: PUSH
33611: LD_INT 2
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 34
33620: PUSH
33621: LD_VAR 0 5
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: LIST
33634: PPUSH
33635: CALL_OW 69
33639: ST_TO_ADDR
// if cargo then
33640: LD_VAR 0 4
33644: IFFALSE 33894
// begin cargo := cargo [ 1 ] ;
33646: LD_ADDR_VAR 0 4
33650: PUSH
33651: LD_VAR 0 4
33655: PUSH
33656: LD_INT 1
33658: ARRAY
33659: ST_TO_ADDR
// if ( not HasTask ( cargo ) ) and ( not ( [ list [ 1 ] , list [ 2 ] ] in ( us_bad ^ ru_bad ^ ar_bad ) ) ) then
33660: LD_VAR 0 4
33664: PPUSH
33665: CALL_OW 314
33669: NOT
33670: PUSH
33671: LD_VAR 0 3
33675: PUSH
33676: LD_INT 1
33678: ARRAY
33679: PUSH
33680: LD_VAR 0 3
33684: PUSH
33685: LD_INT 2
33687: ARRAY
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_LOC 77
33697: PUSH
33698: LD_LOC 78
33702: ADD
33703: PUSH
33704: LD_LOC 79
33708: ADD
33709: IN
33710: NOT
33711: AND
33712: IFFALSE 33894
// begin ComCollect ( cargo , list [ 1 ] , list [ 2 ] ) ;
33714: LD_VAR 0 4
33718: PPUSH
33719: LD_VAR 0 3
33723: PUSH
33724: LD_INT 1
33726: ARRAY
33727: PPUSH
33728: LD_VAR 0 3
33732: PUSH
33733: LD_INT 2
33735: ARRAY
33736: PPUSH
33737: CALL_OW 117
// case side of us :
33741: LD_VAR 0 2
33745: PUSH
33746: LD_EXP 3
33750: DOUBLE
33751: EQUAL
33752: IFTRUE 33756
33754: GO 33795
33756: POP
// us_bay := us_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ru :
33757: LD_ADDR_LOC 74
33761: PUSH
33762: LD_LOC 74
33766: PUSH
33767: LD_VAR 0 3
33771: PUSH
33772: LD_INT 1
33774: ARRAY
33775: PUSH
33776: LD_VAR 0 3
33780: PUSH
33781: LD_INT 2
33783: ARRAY
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: EMPTY
33790: LIST
33791: ADD
33792: ST_TO_ADDR
33793: GO 33894
33795: LD_EXP 2
33799: DOUBLE
33800: EQUAL
33801: IFTRUE 33805
33803: GO 33844
33805: POP
// ru_bay := ru_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ar :
33806: LD_ADDR_LOC 75
33810: PUSH
33811: LD_LOC 75
33815: PUSH
33816: LD_VAR 0 3
33820: PUSH
33821: LD_INT 1
33823: ARRAY
33824: PUSH
33825: LD_VAR 0 3
33829: PUSH
33830: LD_INT 2
33832: ARRAY
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: EMPTY
33839: LIST
33840: ADD
33841: ST_TO_ADDR
33842: GO 33894
33844: LD_EXP 4
33848: DOUBLE
33849: EQUAL
33850: IFTRUE 33854
33852: GO 33893
33854: POP
// ar_bay := ar_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; end ;
33855: LD_ADDR_LOC 76
33859: PUSH
33860: LD_LOC 76
33864: PUSH
33865: LD_VAR 0 3
33869: PUSH
33870: LD_INT 1
33872: ARRAY
33873: PUSH
33874: LD_VAR 0 3
33878: PUSH
33879: LD_INT 2
33881: ARRAY
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: EMPTY
33888: LIST
33889: ADD
33890: ST_TO_ADDR
33891: GO 33894
33893: POP
// end ; end ; end ; list := GetListOfCratesInArea ( inside_list [ side ] ) ;
33894: LD_ADDR_VAR 0 3
33898: PUSH
33899: LD_LOC 71
33903: PUSH
33904: LD_VAR 0 2
33908: ARRAY
33909: PPUSH
33910: CALL_OW 435
33914: ST_TO_ADDR
// if list then
33915: LD_VAR 0 3
33919: IFFALSE 34024
// begin engineers := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
33921: LD_ADDR_VAR 0 6
33925: PUSH
33926: LD_INT 22
33928: PUSH
33929: LD_VAR 0 2
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 21
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 25
33950: PUSH
33951: LD_INT 2
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: LIST
33962: PPUSH
33963: CALL_OW 69
33967: ST_TO_ADDR
// for un in engineers do
33968: LD_ADDR_VAR 0 1
33972: PUSH
33973: LD_VAR 0 6
33977: PUSH
33978: FOR_IN
33979: IFFALSE 34022
// if not GetUnitMc ( un ) then
33981: LD_VAR 0 1
33985: PPUSH
33986: CALL_OW 388
33990: NOT
33991: IFFALSE 34020
// ComCollect ( un , list [ 1 ] , list [ 2 ] ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 3
34002: PUSH
34003: LD_INT 1
34005: ARRAY
34006: PPUSH
34007: LD_VAR 0 3
34011: PUSH
34012: LD_INT 2
34014: ARRAY
34015: PPUSH
34016: CALL_OW 117
34020: GO 33978
34022: POP
34023: POP
// end ; end ;
34024: GO 33498
34026: POP
34027: POP
// enable ;
34028: ENABLE
// end ;
34029: PPOPN 6
34031: END
// every 1 1$0.6 do var un , n_cargo , cargo , side ;
34032: GO 34034
34034: DISABLE
34035: LD_INT 0
34037: PPUSH
34038: PPUSH
34039: PPUSH
34040: PPUSH
// begin for side in cpu_list do
34041: LD_ADDR_VAR 0 4
34045: PUSH
34046: LD_EXP 8
34050: PUSH
34051: FOR_IN
34052: IFFALSE 34491
// begin case side of 1 :
34054: LD_VAR 0 4
34058: PUSH
34059: LD_INT 1
34061: DOUBLE
34062: EQUAL
34063: IFTRUE 34067
34065: GO 34078
34067: POP
// n_cargo := us_cargo_bay ; 2 :
34068: LD_ADDR_VAR 0 2
34072: PUSH
34073: LD_INT 12
34075: ST_TO_ADDR
34076: GO 34117
34078: LD_INT 2
34080: DOUBLE
34081: EQUAL
34082: IFTRUE 34086
34084: GO 34097
34086: POP
// n_cargo := ar_cargo_bay ; 3 :
34087: LD_ADDR_VAR 0 2
34091: PUSH
34092: LD_INT 32
34094: ST_TO_ADDR
34095: GO 34117
34097: LD_INT 3
34099: DOUBLE
34100: EQUAL
34101: IFTRUE 34105
34103: GO 34116
34105: POP
// n_cargo := ru_cargo_bay ; end ;
34106: LD_ADDR_VAR 0 2
34110: PUSH
34111: LD_INT 51
34113: ST_TO_ADDR
34114: GO 34117
34116: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34117: LD_ADDR_VAR 0 3
34121: PUSH
34122: LD_INT 22
34124: PUSH
34125: LD_VAR 0 4
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 21
34136: PUSH
34137: LD_INT 2
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 34
34146: PUSH
34147: LD_VAR 0 2
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: LIST
34160: PPUSH
34161: CALL_OW 69
34165: ST_TO_ADDR
// if not ( cargo or FilterUnitsInArea ( base_areas [ side ] , [ [ f_side , you ] ] ) ) then
34166: LD_VAR 0 3
34170: PUSH
34171: LD_LOC 72
34175: PUSH
34176: LD_VAR 0 4
34180: ARRAY
34181: PPUSH
34182: LD_INT 22
34184: PUSH
34185: LD_EXP 1
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: EMPTY
34195: LIST
34196: PPUSH
34197: CALL_OW 70
34201: OR
34202: NOT
34203: IFFALSE 34489
// begin uc_side := side ;
34205: LD_ADDR_OWVAR 20
34209: PUSH
34210: LD_VAR 0 4
34214: ST_TO_ADDR
// case side of 1 :
34215: LD_VAR 0 4
34219: PUSH
34220: LD_INT 1
34222: DOUBLE
34223: EQUAL
34224: IFTRUE 34228
34226: GO 34239
34228: POP
// uc_nation := nation_american ; 2 :
34229: LD_ADDR_OWVAR 21
34233: PUSH
34234: LD_INT 1
34236: ST_TO_ADDR
34237: GO 34278
34239: LD_INT 2
34241: DOUBLE
34242: EQUAL
34243: IFTRUE 34247
34245: GO 34258
34247: POP
// uc_nation := nation_arabian ; 3 :
34248: LD_ADDR_OWVAR 21
34252: PUSH
34253: LD_INT 2
34255: ST_TO_ADDR
34256: GO 34278
34258: LD_INT 3
34260: DOUBLE
34261: EQUAL
34262: IFTRUE 34266
34264: GO 34277
34266: POP
// uc_nation := nation_russian ; end ;
34267: LD_ADDR_OWVAR 21
34271: PUSH
34272: LD_INT 3
34274: ST_TO_ADDR
34275: GO 34278
34277: POP
// uc_direction := Rand ( 0 , 5 ) ;
34278: LD_ADDR_OWVAR 24
34282: PUSH
34283: LD_INT 0
34285: PPUSH
34286: LD_INT 5
34288: PPUSH
34289: CALL_OW 12
34293: ST_TO_ADDR
// case side of 1 :
34294: LD_VAR 0 4
34298: PUSH
34299: LD_INT 1
34301: DOUBLE
34302: EQUAL
34303: IFTRUE 34307
34305: GO 34318
34307: POP
// vc_chassis := us_medium_tracked ; 2 :
34308: LD_ADDR_OWVAR 37
34312: PUSH
34313: LD_INT 3
34315: ST_TO_ADDR
34316: GO 34357
34318: LD_INT 2
34320: DOUBLE
34321: EQUAL
34322: IFTRUE 34326
34324: GO 34337
34326: POP
// vc_chassis := ar_half_tracked ; 3 :
34327: LD_ADDR_OWVAR 37
34331: PUSH
34332: LD_INT 14
34334: ST_TO_ADDR
34335: GO 34357
34337: LD_INT 3
34339: DOUBLE
34340: EQUAL
34341: IFTRUE 34345
34343: GO 34356
34345: POP
// vc_chassis := ru_medium_tracked ; end ;
34346: LD_ADDR_OWVAR 37
34350: PUSH
34351: LD_INT 22
34353: ST_TO_ADDR
34354: GO 34357
34356: POP
// vc_engine := engine_siberite ;
34357: LD_ADDR_OWVAR 39
34361: PUSH
34362: LD_INT 3
34364: ST_TO_ADDR
// case side of 1 :
34365: LD_VAR 0 4
34369: PUSH
34370: LD_INT 1
34372: DOUBLE
34373: EQUAL
34374: IFTRUE 34378
34376: GO 34389
34378: POP
// vc_control := control_computer ; 2 :
34379: LD_ADDR_OWVAR 38
34383: PUSH
34384: LD_INT 3
34386: ST_TO_ADDR
34387: GO 34428
34389: LD_INT 2
34391: DOUBLE
34392: EQUAL
34393: IFTRUE 34397
34395: GO 34408
34397: POP
// vc_control := control_apeman ; 3 :
34398: LD_ADDR_OWVAR 38
34402: PUSH
34403: LD_INT 5
34405: ST_TO_ADDR
34406: GO 34428
34408: LD_INT 3
34410: DOUBLE
34411: EQUAL
34412: IFTRUE 34416
34414: GO 34427
34416: POP
// vc_control := control_computer ; end ;
34417: LD_ADDR_OWVAR 38
34421: PUSH
34422: LD_INT 3
34424: ST_TO_ADDR
34425: GO 34428
34427: POP
// vc_weapon := n_cargo ;
34428: LD_ADDR_OWVAR 40
34432: PUSH
34433: LD_VAR 0 2
34437: ST_TO_ADDR
// un := CreateVehicle ;
34438: LD_ADDR_VAR 0 1
34442: PUSH
34443: CALL_OW 45
34447: ST_TO_ADDR
// while GetTag ( 83 ) do
34448: LD_INT 83
34450: PPUSH
34451: CALL_OW 110
34455: IFFALSE 34466
// wait ( 0 0$1 ) ;
34457: LD_INT 35
34459: PPUSH
34460: CALL_OW 67
34464: GO 34448
// PlaceUnitArea ( un , create_areas [ side ] , false ) ;
34466: LD_VAR 0 1
34470: PPUSH
34471: LD_LOC 73
34475: PUSH
34476: LD_VAR 0 4
34480: ARRAY
34481: PPUSH
34482: LD_INT 0
34484: PPUSH
34485: CALL_OW 49
// end ; end ;
34489: GO 34051
34491: POP
34492: POP
// enable ;
34493: ENABLE
// end ;
34494: PPOPN 4
34496: END
// export function remove_bad_crates ( side ) ; var list , un , x , y ; begin
34497: LD_INT 0
34499: PPUSH
34500: PPUSH
34501: PPUSH
34502: PPUSH
34503: PPUSH
// case side of us :
34504: LD_VAR 0 1
34508: PUSH
34509: LD_EXP 3
34513: DOUBLE
34514: EQUAL
34515: IFTRUE 34519
34517: GO 34590
34519: POP
// begin x := us_bay [ us_bad ] [ 1 ] ;
34520: LD_ADDR_VAR 0 5
34524: PUSH
34525: LD_LOC 74
34529: PUSH
34530: LD_LOC 77
34534: ARRAY
34535: PUSH
34536: LD_INT 1
34538: ARRAY
34539: ST_TO_ADDR
// y := us_bay [ us_bad ] [ 2 ] ;
34540: LD_ADDR_VAR 0 6
34544: PUSH
34545: LD_LOC 74
34549: PUSH
34550: LD_LOC 77
34554: ARRAY
34555: PUSH
34556: LD_INT 2
34558: ARRAY
34559: ST_TO_ADDR
// us_bad := us_bad ^ [ [ x , y ] ] ;
34560: LD_ADDR_LOC 77
34564: PUSH
34565: LD_LOC 77
34569: PUSH
34570: LD_VAR 0 5
34574: PUSH
34575: LD_VAR 0 6
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: EMPTY
34585: LIST
34586: ADD
34587: ST_TO_ADDR
// end ; ru :
34588: GO 34753
34590: LD_EXP 2
34594: DOUBLE
34595: EQUAL
34596: IFTRUE 34600
34598: GO 34671
34600: POP
// begin x := ru_bay [ us_bad ] [ 1 ] ;
34601: LD_ADDR_VAR 0 5
34605: PUSH
34606: LD_LOC 75
34610: PUSH
34611: LD_LOC 77
34615: ARRAY
34616: PUSH
34617: LD_INT 1
34619: ARRAY
34620: ST_TO_ADDR
// y := ru_bay [ us_bad ] [ 2 ] ;
34621: LD_ADDR_VAR 0 6
34625: PUSH
34626: LD_LOC 75
34630: PUSH
34631: LD_LOC 77
34635: ARRAY
34636: PUSH
34637: LD_INT 2
34639: ARRAY
34640: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34641: LD_ADDR_LOC 78
34645: PUSH
34646: LD_LOC 78
34650: PUSH
34651: LD_VAR 0 5
34655: PUSH
34656: LD_VAR 0 6
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: EMPTY
34666: LIST
34667: ADD
34668: ST_TO_ADDR
// end ; ar :
34669: GO 34753
34671: LD_EXP 4
34675: DOUBLE
34676: EQUAL
34677: IFTRUE 34681
34679: GO 34752
34681: POP
// begin x := ar_bay [ us_bad ] [ 1 ] ;
34682: LD_ADDR_VAR 0 5
34686: PUSH
34687: LD_LOC 76
34691: PUSH
34692: LD_LOC 77
34696: ARRAY
34697: PUSH
34698: LD_INT 1
34700: ARRAY
34701: ST_TO_ADDR
// y := ar_bay [ us_bad ] [ 2 ] ;
34702: LD_ADDR_VAR 0 6
34706: PUSH
34707: LD_LOC 76
34711: PUSH
34712: LD_LOC 77
34716: ARRAY
34717: PUSH
34718: LD_INT 2
34720: ARRAY
34721: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34722: LD_ADDR_LOC 78
34726: PUSH
34727: LD_LOC 78
34731: PUSH
34732: LD_VAR 0 5
34736: PUSH
34737: LD_VAR 0 6
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: EMPTY
34747: LIST
34748: ADD
34749: ST_TO_ADDR
// end ; end ;
34750: GO 34753
34752: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ;
34753: LD_ADDR_VAR 0 3
34757: PUSH
34758: LD_INT 22
34760: PUSH
34761: LD_VAR 0 1
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 21
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 25
34782: PUSH
34783: LD_INT 2
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 50
34792: PUSH
34793: EMPTY
34794: LIST
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: PPUSH
34802: CALL_OW 69
34806: ST_TO_ADDR
// for un in list do
34807: LD_ADDR_VAR 0 4
34811: PUSH
34812: LD_VAR 0 3
34816: PUSH
34817: FOR_IN
34818: IFFALSE 34871
// if not GetUnitMc ( un ) then
34820: LD_VAR 0 4
34824: PPUSH
34825: CALL_OW 388
34829: NOT
34830: IFFALSE 34869
// begin ComRemember ( un ) ;
34832: LD_VAR 0 4
34836: PPUSH
34837: CALL_OW 143
// AddComCollect ( un , x , y ) ;
34841: LD_VAR 0 4
34845: PPUSH
34846: LD_VAR 0 5
34850: PPUSH
34851: LD_VAR 0 6
34855: PPUSH
34856: CALL_OW 177
// AddComReturn ( un ) ;
34860: LD_VAR 0 4
34864: PPUSH
34865: CALL_OW 204
// end ;
34869: GO 34817
34871: POP
34872: POP
// end ;
34873: LD_VAR 0 2
34877: RET
// every 0 0$7.9 trigger us_bad do var un , list ;
34878: LD_LOC 77
34882: IFFALSE 34979
34884: GO 34886
34886: DISABLE
34887: LD_INT 0
34889: PPUSH
34890: PPUSH
// begin list := [ ] ;
34891: LD_ADDR_VAR 0 2
34895: PUSH
34896: EMPTY
34897: ST_TO_ADDR
// for un in us_bad do
34898: LD_ADDR_VAR 0 1
34902: PUSH
34903: LD_LOC 77
34907: PUSH
34908: FOR_IN
34909: IFFALSE 34966
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
34911: LD_INT 35
34913: PPUSH
34914: LD_VAR 0 1
34918: PUSH
34919: LD_INT 1
34921: ARRAY
34922: PPUSH
34923: LD_VAR 0 1
34927: PUSH
34928: LD_INT 2
34930: ARRAY
34931: PPUSH
34932: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
34936: LD_INT 35
34938: PPUSH
34939: CALL_OW 435
34943: IFFALSE 34964
// list := list ^ [ un ] ;
34945: LD_ADDR_VAR 0 2
34949: PUSH
34950: LD_VAR 0 2
34954: PUSH
34955: LD_VAR 0 1
34959: PUSH
34960: EMPTY
34961: LIST
34962: ADD
34963: ST_TO_ADDR
// end ;
34964: GO 34908
34966: POP
34967: POP
// us_bad := list ;
34968: LD_ADDR_LOC 77
34972: PUSH
34973: LD_VAR 0 2
34977: ST_TO_ADDR
// enable ;
34978: ENABLE
// end ;
34979: PPOPN 2
34981: END
// every 0 0$7.8 trigger ru_bad do var un , list ;
34982: LD_LOC 78
34986: IFFALSE 35083
34988: GO 34990
34990: DISABLE
34991: LD_INT 0
34993: PPUSH
34994: PPUSH
// begin list := [ ] ;
34995: LD_ADDR_VAR 0 2
34999: PUSH
35000: EMPTY
35001: ST_TO_ADDR
// for un in ru_bad do
35002: LD_ADDR_VAR 0 1
35006: PUSH
35007: LD_LOC 78
35011: PUSH
35012: FOR_IN
35013: IFFALSE 35070
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35015: LD_INT 35
35017: PPUSH
35018: LD_VAR 0 1
35022: PUSH
35023: LD_INT 1
35025: ARRAY
35026: PPUSH
35027: LD_VAR 0 1
35031: PUSH
35032: LD_INT 2
35034: ARRAY
35035: PPUSH
35036: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35040: LD_INT 35
35042: PPUSH
35043: CALL_OW 435
35047: IFFALSE 35068
// list := list ^ [ un ] ;
35049: LD_ADDR_VAR 0 2
35053: PUSH
35054: LD_VAR 0 2
35058: PUSH
35059: LD_VAR 0 1
35063: PUSH
35064: EMPTY
35065: LIST
35066: ADD
35067: ST_TO_ADDR
// end ;
35068: GO 35012
35070: POP
35071: POP
// ru_bad := list ;
35072: LD_ADDR_LOC 78
35076: PUSH
35077: LD_VAR 0 2
35081: ST_TO_ADDR
// enable ;
35082: ENABLE
// end ;
35083: PPOPN 2
35085: END
// every 0 0$7.7 trigger ar_bad do var un , list ;
35086: LD_LOC 79
35090: IFFALSE 35187
35092: GO 35094
35094: DISABLE
35095: LD_INT 0
35097: PPUSH
35098: PPUSH
// begin list := [ ] ;
35099: LD_ADDR_VAR 0 2
35103: PUSH
35104: EMPTY
35105: ST_TO_ADDR
// for un in ar_bad do
35106: LD_ADDR_VAR 0 1
35110: PUSH
35111: LD_LOC 79
35115: PUSH
35116: FOR_IN
35117: IFFALSE 35174
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35119: LD_INT 35
35121: PPUSH
35122: LD_VAR 0 1
35126: PUSH
35127: LD_INT 1
35129: ARRAY
35130: PPUSH
35131: LD_VAR 0 1
35135: PUSH
35136: LD_INT 2
35138: ARRAY
35139: PPUSH
35140: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35144: LD_INT 35
35146: PPUSH
35147: CALL_OW 435
35151: IFFALSE 35172
// list := list ^ [ un ] ;
35153: LD_ADDR_VAR 0 2
35157: PUSH
35158: LD_VAR 0 2
35162: PUSH
35163: LD_VAR 0 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: ADD
35171: ST_TO_ADDR
// end ;
35172: GO 35116
35174: POP
35175: POP
// ar_bad := list ;
35176: LD_ADDR_LOC 79
35180: PUSH
35181: LD_VAR 0 2
35185: ST_TO_ADDR
// enable ;
35186: ENABLE
// end ; end_of_file
35187: PPOPN 2
35189: END
// export function check_remote ( veh ) ; var un , towers , list , all_in , veh_n , veh_l , mech ; begin
35190: LD_INT 0
35192: PPUSH
35193: PPUSH
35194: PPUSH
35195: PPUSH
35196: PPUSH
35197: PPUSH
35198: PPUSH
35199: PPUSH
// list := [ ] ;
35200: LD_ADDR_VAR 0 5
35204: PUSH
35205: EMPTY
35206: ST_TO_ADDR
// veh_l := FilterAllUnits ( [ [ f_side , us ] , [ f_control , control_remote ] , [ f_ok ] ] ) union veh diff 0 ;
35207: LD_ADDR_VAR 0 8
35211: PUSH
35212: LD_INT 22
35214: PUSH
35215: LD_EXP 3
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 33
35226: PUSH
35227: LD_INT 2
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 50
35236: PUSH
35237: EMPTY
35238: LIST
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: LIST
35244: PPUSH
35245: CALL_OW 69
35249: PUSH
35250: LD_VAR 0 1
35254: UNION
35255: PUSH
35256: LD_INT 0
35258: DIFF
35259: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35260: LD_ADDR_VAR 0 4
35264: PUSH
35265: LD_INT 22
35267: PUSH
35268: LD_EXP 3
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 30
35279: PUSH
35280: LD_INT 36
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 50
35289: PUSH
35290: EMPTY
35291: LIST
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: LIST
35297: PPUSH
35298: CALL_OW 69
35302: ST_TO_ADDR
// if not towers then
35303: LD_VAR 0 4
35307: NOT
35308: IFFALSE 35312
// exit ;
35310: GO 35907
// towers := towers [ 1 ] ;
35312: LD_ADDR_VAR 0 4
35316: PUSH
35317: LD_VAR 0 4
35321: PUSH
35322: LD_INT 1
35324: ARRAY
35325: ST_TO_ADDR
// all_in := UnitsInside ( towers ) ;
35326: LD_ADDR_VAR 0 6
35330: PUSH
35331: LD_VAR 0 4
35335: PPUSH
35336: CALL_OW 313
35340: ST_TO_ADDR
// mech := all_in ^ ( FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] , [ f_ok ] ] ) diff reserved_people [ us ] ) ;
35341: LD_ADDR_VAR 0 9
35345: PUSH
35346: LD_VAR 0 6
35350: PUSH
35351: LD_INT 22
35353: PUSH
35354: LD_EXP 3
35358: PUSH
35359: EMPTY
35360: LIST
35361: LIST
35362: PUSH
35363: LD_INT 21
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 25
35375: PUSH
35376: LD_INT 3
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 50
35385: PUSH
35386: EMPTY
35387: LIST
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: PPUSH
35395: CALL_OW 69
35399: PUSH
35400: LD_EXP 71
35404: PUSH
35405: LD_EXP 3
35409: ARRAY
35410: DIFF
35411: ADD
35412: ST_TO_ADDR
// for un in mech do
35413: LD_ADDR_VAR 0 3
35417: PUSH
35418: LD_VAR 0 9
35422: PUSH
35423: FOR_IN
35424: IFFALSE 35458
// list := list ^ FindMaxSkill ( mech diff list , skill_mechanical ) ;
35426: LD_ADDR_VAR 0 5
35430: PUSH
35431: LD_VAR 0 5
35435: PUSH
35436: LD_VAR 0 9
35440: PUSH
35441: LD_VAR 0 5
35445: DIFF
35446: PPUSH
35447: LD_INT 3
35449: PPUSH
35450: CALL_OW 433
35454: ADD
35455: ST_TO_ADDR
35456: GO 35423
35458: POP
35459: POP
// mech := [ ] ;
35460: LD_ADDR_VAR 0 9
35464: PUSH
35465: EMPTY
35466: ST_TO_ADDR
// veh_n := 0 + veh_l ;
35467: LD_ADDR_VAR 0 7
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: LD_VAR 0 8
35479: PLUS
35480: ST_TO_ADDR
// for un in list do
35481: LD_ADDR_VAR 0 3
35485: PUSH
35486: LD_VAR 0 5
35490: PUSH
35491: FOR_IN
35492: IFFALSE 35562
// if ( veh_n > 0 ) or ( ( list diff mech ) > 6 ) then
35494: LD_VAR 0 7
35498: PUSH
35499: LD_INT 0
35501: GREATER
35502: PUSH
35503: LD_VAR 0 5
35507: PUSH
35508: LD_VAR 0 9
35512: DIFF
35513: PUSH
35514: LD_INT 6
35516: GREATER
35517: OR
35518: IFFALSE 35560
// begin mech := mech ^ un ;
35520: LD_ADDR_VAR 0 9
35524: PUSH
35525: LD_VAR 0 9
35529: PUSH
35530: LD_VAR 0 3
35534: ADD
35535: ST_TO_ADDR
// veh_n := veh_n - GetSkill ( un , skill_mechanical ) ;
35536: LD_ADDR_VAR 0 7
35540: PUSH
35541: LD_VAR 0 7
35545: PUSH
35546: LD_VAR 0 3
35550: PPUSH
35551: LD_INT 3
35553: PPUSH
35554: CALL_OW 259
35558: MINUS
35559: ST_TO_ADDR
// end ;
35560: GO 35491
35562: POP
35563: POP
// un := reserved_people [ us ] ^ mech ;
35564: LD_ADDR_VAR 0 3
35568: PUSH
35569: LD_EXP 71
35573: PUSH
35574: LD_EXP 3
35578: ARRAY
35579: PUSH
35580: LD_VAR 0 9
35584: ADD
35585: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35586: LD_ADDR_EXP 71
35590: PUSH
35591: LD_EXP 71
35595: PPUSH
35596: LD_EXP 3
35600: PPUSH
35601: CALL_OW 3
35605: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35606: LD_ADDR_EXP 71
35610: PUSH
35611: LD_EXP 71
35615: PPUSH
35616: LD_EXP 3
35620: PPUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 2
35630: ST_TO_ADDR
// list := UnitsInside ( towers ) diff mech ;
35631: LD_ADDR_VAR 0 5
35635: PUSH
35636: LD_VAR 0 4
35640: PPUSH
35641: CALL_OW 313
35645: PUSH
35646: LD_VAR 0 9
35650: DIFF
35651: ST_TO_ADDR
// if list then
35652: LD_VAR 0 5
35656: IFFALSE 35812
// begin un := reserved_people [ us ] diff list ;
35658: LD_ADDR_VAR 0 3
35662: PUSH
35663: LD_EXP 71
35667: PUSH
35668: LD_EXP 3
35672: ARRAY
35673: PUSH
35674: LD_VAR 0 5
35678: DIFF
35679: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35680: LD_ADDR_EXP 71
35684: PUSH
35685: LD_EXP 71
35689: PPUSH
35690: LD_EXP 3
35694: PPUSH
35695: CALL_OW 3
35699: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35700: LD_ADDR_EXP 71
35704: PUSH
35705: LD_EXP 71
35709: PPUSH
35710: LD_EXP 3
35714: PPUSH
35715: LD_VAR 0 3
35719: PPUSH
35720: CALL_OW 2
35724: ST_TO_ADDR
// ComExitBuilding ( list ) ;
35725: LD_VAR 0 5
35729: PPUSH
35730: CALL_OW 122
// un := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
35734: LD_ADDR_VAR 0 3
35738: PUSH
35739: LD_INT 22
35741: PUSH
35742: LD_EXP 3
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 2
35753: PUSH
35754: LD_INT 30
35756: PUSH
35757: LD_INT 2
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 30
35766: PUSH
35767: LD_INT 3
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: LIST
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PPUSH
35783: CALL_OW 69
35787: ST_TO_ADDR
// if un then
35788: LD_VAR 0 3
35792: IFFALSE 35812
// AddComMoveUnit ( list , un [ 1 ] ) ;
35794: LD_VAR 0 5
35798: PPUSH
35799: LD_VAR 0 3
35803: PUSH
35804: LD_INT 1
35806: ARRAY
35807: PPUSH
35808: CALL_OW 172
// end ; repeat ComMoveUnit ( mech , towers ) ;
35812: LD_VAR 0 9
35816: PPUSH
35817: LD_VAR 0 4
35821: PPUSH
35822: CALL_OW 112
// all_in := true ;
35826: LD_ADDR_VAR 0 6
35830: PUSH
35831: LD_INT 1
35833: ST_TO_ADDR
// for un in mech do
35834: LD_ADDR_VAR 0 3
35838: PUSH
35839: LD_VAR 0 9
35843: PUSH
35844: FOR_IN
35845: IFFALSE 35877
// if not ( IsInUnit ( un ) = towers ) then
35847: LD_VAR 0 3
35851: PPUSH
35852: CALL_OW 310
35856: PUSH
35857: LD_VAR 0 4
35861: EQUAL
35862: NOT
35863: IFFALSE 35875
// begin all_in := false ;
35865: LD_ADDR_VAR 0 6
35869: PUSH
35870: LD_INT 0
35872: ST_TO_ADDR
// break ;
35873: GO 35877
// end ;
35875: GO 35844
35877: POP
35878: POP
// wait ( 0 0$1 ) ;
35879: LD_INT 35
35881: PPUSH
35882: CALL_OW 67
// until all_in ;
35886: LD_VAR 0 6
35890: IFFALSE 35812
// ComLinkTo ( veh_l , towers ) ;
35892: LD_VAR 0 8
35896: PPUSH
35897: LD_VAR 0 4
35901: PPUSH
35902: CALL_OW 135
// enable ;
35906: ENABLE
// end ;
35907: LD_VAR 0 2
35911: RET
// every 0 0$10 do var list , tower ;
35912: GO 35914
35914: DISABLE
35915: LD_INT 0
35917: PPUSH
35918: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_ok ] , [ f_control , control_remote ] , f_not , [ f_linked ] ] ) ;
35919: LD_ADDR_VAR 0 1
35923: PUSH
35924: LD_INT 22
35926: PUSH
35927: LD_EXP 3
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 50
35938: PUSH
35939: EMPTY
35940: LIST
35941: PUSH
35942: LD_INT 33
35944: PUSH
35945: LD_INT 2
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 3
35954: PUSH
35955: LD_INT 61
35957: PUSH
35958: EMPTY
35959: LIST
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: PPUSH
35968: CALL_OW 69
35972: ST_TO_ADDR
// if list then
35973: LD_VAR 0 1
35977: IFFALSE 36061
// begin tower := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35979: LD_ADDR_VAR 0 2
35983: PUSH
35984: LD_INT 22
35986: PUSH
35987: LD_EXP 3
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 30
35998: PUSH
35999: LD_INT 36
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 50
36008: PUSH
36009: EMPTY
36010: LIST
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: LIST
36016: PPUSH
36017: CALL_OW 69
36021: ST_TO_ADDR
// if tower then
36022: LD_VAR 0 2
36026: IFFALSE 36044
// tower := tower [ 1 ] else
36028: LD_ADDR_VAR 0 2
36032: PUSH
36033: LD_VAR 0 2
36037: PUSH
36038: LD_INT 1
36040: ARRAY
36041: ST_TO_ADDR
36042: GO 36047
// begin enable ;
36044: ENABLE
// exit ;
36045: GO 36062
// end ; ComLinkTo ( list , tower ) ;
36047: LD_VAR 0 1
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: CALL_OW 135
// end ; enable ;
36061: ENABLE
// end ; end_of_file
36062: PPOPN 2
36064: END
// export us_sib_wait , ru_sib_wait ; var time_to_end ; export function init_sib_rocket ; begin
36065: LD_INT 0
36067: PPUSH
// us_sib_wait := false ;
36068: LD_ADDR_EXP 74
36072: PUSH
36073: LD_INT 0
36075: ST_TO_ADDR
// ru_sib_wait := false ;
36076: LD_ADDR_EXP 75
36080: PUSH
36081: LD_INT 0
36083: ST_TO_ADDR
// time_to_end := [ 85 85$0 , 65 65$0 , 45 45$0 ] [ difficulty ] ;
36084: LD_ADDR_LOC 80
36088: PUSH
36089: LD_INT 178500
36091: PUSH
36092: LD_INT 136500
36094: PUSH
36095: LD_INT 94500
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: LIST
36102: PUSH
36103: LD_OWVAR 67
36107: ARRAY
36108: ST_TO_ADDR
// end ;
36109: LD_VAR 0 1
36113: RET
// every 0 0$1.5 trigger TICK > time_to_end marked 4 do var factory , zdroje ;
36114: LD_OWVAR 1
36118: PUSH
36119: LD_LOC 80
36123: GREATER
36124: IFFALSE 36357
36126: GO 36128
36128: DISABLE
36129: LD_INT 0
36131: PPUSH
36132: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_factory ] ] ) ;
36133: LD_ADDR_VAR 0 1
36137: PUSH
36138: LD_INT 22
36140: PUSH
36141: LD_EXP 3
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 3
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PPUSH
36164: CALL_OW 69
36168: ST_TO_ADDR
// if factory then
36169: LD_VAR 0 1
36173: IFFALSE 36356
// begin factory := factory [ 1 ] ;
36175: LD_ADDR_VAR 0 1
36179: PUSH
36180: LD_VAR 0 1
36184: PUSH
36185: LD_INT 1
36187: ARRAY
36188: ST_TO_ADDR
// if us_siberium_rocket in AvailableWeaponList ( factory ) then
36189: LD_INT 8
36191: PUSH
36192: LD_VAR 0 1
36196: PPUSH
36197: CALL_OW 478
36201: IN
36202: IFFALSE 36356
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36204: LD_ADDR_VAR 0 2
36208: PUSH
36209: LD_VAR 0 1
36213: PPUSH
36214: CALL_OW 274
36218: PPUSH
36219: CALL_OW 279
36223: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36224: LD_VAR 0 2
36228: PUSH
36229: LD_INT 1
36231: ARRAY
36232: PUSH
36233: LD_INT 75
36235: GREATEREQUAL
36236: PUSH
36237: LD_VAR 0 2
36241: PUSH
36242: LD_INT 2
36244: ARRAY
36245: PUSH
36246: LD_INT 30
36248: GREATEREQUAL
36249: PUSH
36250: LD_VAR 0 2
36254: PUSH
36255: LD_INT 3
36257: ARRAY
36258: PUSH
36259: LD_INT 70
36261: GREATEREQUAL
36262: OR
36263: AND
36264: PUSH
36265: LD_VAR 0 2
36269: PUSH
36270: LD_INT 3
36272: ARRAY
36273: PUSH
36274: LD_INT 60
36276: GREATEREQUAL
36277: AND
36278: IFFALSE 36348
// begin if zdroje [ 3 ] >= 70 then
36280: LD_VAR 0 2
36284: PUSH
36285: LD_INT 3
36287: ARRAY
36288: PUSH
36289: LD_INT 70
36291: GREATEREQUAL
36292: IFFALSE 36317
// ComConstruct ( factory , us_morphling , engine_siberite , control_remote , us_siberium_rocket ) else
36294: LD_VAR 0 1
36298: PPUSH
36299: LD_INT 5
36301: PPUSH
36302: LD_INT 3
36304: PPUSH
36305: LD_INT 2
36307: PPUSH
36308: LD_INT 8
36310: PPUSH
36311: CALL_OW 125
36315: GO 36338
// ComConstruct ( factory , us_morphling , engine_combustion , control_remote , us_siberium_rocket ) ;
36317: LD_VAR 0 1
36321: PPUSH
36322: LD_INT 5
36324: PPUSH
36325: LD_INT 1
36327: PPUSH
36328: LD_INT 2
36330: PPUSH
36331: LD_INT 8
36333: PPUSH
36334: CALL_OW 125
// us_sib_wait := false ;
36338: LD_ADDR_EXP 74
36342: PUSH
36343: LD_INT 0
36345: ST_TO_ADDR
// end else
36346: GO 36356
// us_sib_wait := true ;
36348: LD_ADDR_EXP 74
36352: PUSH
36353: LD_INT 1
36355: ST_TO_ADDR
// end ; end ; enable ;
36356: ENABLE
// end ;
36357: PPOPN 2
36359: END
// every 0 0$1.5 trigger TICK > time_to_end marked 5 do var factory , zdroje ;
36360: LD_OWVAR 1
36364: PUSH
36365: LD_LOC 80
36369: GREATER
36370: IFFALSE 36603
36372: GO 36374
36374: DISABLE
36375: LD_INT 0
36377: PPUSH
36378: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , ru ] , [ f_btype , b_factory ] ] ) ;
36379: LD_ADDR_VAR 0 1
36383: PUSH
36384: LD_INT 22
36386: PUSH
36387: LD_EXP 2
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 30
36398: PUSH
36399: LD_INT 3
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PPUSH
36410: CALL_OW 69
36414: ST_TO_ADDR
// if factory then
36415: LD_VAR 0 1
36419: IFFALSE 36602
// begin factory := factory [ 1 ] ;
36421: LD_ADDR_VAR 0 1
36425: PUSH
36426: LD_VAR 0 1
36430: PUSH
36431: LD_INT 1
36433: ARRAY
36434: ST_TO_ADDR
// if ru_siberium_rocket in AvailableWeaponList ( factory ) then
36435: LD_INT 48
36437: PUSH
36438: LD_VAR 0 1
36442: PPUSH
36443: CALL_OW 478
36447: IN
36448: IFFALSE 36602
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36450: LD_ADDR_VAR 0 2
36454: PUSH
36455: LD_VAR 0 1
36459: PPUSH
36460: CALL_OW 274
36464: PPUSH
36465: CALL_OW 279
36469: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36470: LD_VAR 0 2
36474: PUSH
36475: LD_INT 1
36477: ARRAY
36478: PUSH
36479: LD_INT 75
36481: GREATEREQUAL
36482: PUSH
36483: LD_VAR 0 2
36487: PUSH
36488: LD_INT 2
36490: ARRAY
36491: PUSH
36492: LD_INT 30
36494: GREATEREQUAL
36495: PUSH
36496: LD_VAR 0 2
36500: PUSH
36501: LD_INT 3
36503: ARRAY
36504: PUSH
36505: LD_INT 70
36507: GREATEREQUAL
36508: OR
36509: AND
36510: PUSH
36511: LD_VAR 0 2
36515: PUSH
36516: LD_INT 3
36518: ARRAY
36519: PUSH
36520: LD_INT 60
36522: GREATEREQUAL
36523: AND
36524: IFFALSE 36594
// begin if zdroje [ 3 ] >= 70 then
36526: LD_VAR 0 2
36530: PUSH
36531: LD_INT 3
36533: ARRAY
36534: PUSH
36535: LD_INT 70
36537: GREATEREQUAL
36538: IFFALSE 36563
// ComConstruct ( factory , ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ) else
36540: LD_VAR 0 1
36544: PPUSH
36545: LD_INT 23
36547: PPUSH
36548: LD_INT 3
36550: PPUSH
36551: LD_INT 3
36553: PPUSH
36554: LD_INT 48
36556: PPUSH
36557: CALL_OW 125
36561: GO 36584
// ComConstruct ( factory , ru_heavy_wheeled , engine_combustion , control_computer , ru_siberium_rocket ) ;
36563: LD_VAR 0 1
36567: PPUSH
36568: LD_INT 23
36570: PPUSH
36571: LD_INT 1
36573: PPUSH
36574: LD_INT 3
36576: PPUSH
36577: LD_INT 48
36579: PPUSH
36580: CALL_OW 125
// ru_sib_wait := false ;
36584: LD_ADDR_EXP 75
36588: PUSH
36589: LD_INT 0
36591: ST_TO_ADDR
// end else
36592: GO 36602
// ru_sib_wait := true ;
36594: LD_ADDR_EXP 75
36598: PUSH
36599: LD_INT 1
36601: ST_TO_ADDR
// end ; end ; enable ;
36602: ENABLE
// end ;
36603: PPOPN 2
36605: END
// export function send_sib_to_US ( veh ) ; var n_check , s_check , send ; begin
36606: LD_INT 0
36608: PPUSH
36609: PPUSH
36610: PPUSH
36611: PPUSH
// repeat n_check := FilterUnitsInArea ( north_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36612: LD_ADDR_VAR 0 3
36616: PUSH
36617: LD_INT 25
36619: PPUSH
36620: LD_INT 21
36622: PUSH
36623: LD_INT 2
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 3
36632: PUSH
36633: LD_INT 22
36635: PUSH
36636: LD_EXP 2
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: LIST
36649: PPUSH
36650: CALL_OW 70
36654: ST_TO_ADDR
// s_check := FilterUnitsInArea ( south_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36655: LD_ADDR_VAR 0 4
36659: PUSH
36660: LD_INT 26
36662: PPUSH
36663: LD_INT 21
36665: PUSH
36666: LD_INT 2
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 3
36675: PUSH
36676: LD_INT 22
36678: PUSH
36679: LD_EXP 2
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: LIST
36692: PPUSH
36693: CALL_OW 70
36697: ST_TO_ADDR
// wait ( 0 0$2 ) ;
36698: LD_INT 70
36700: PPUSH
36701: CALL_OW 67
// until ( n_check < 3 ) and ( s_check < 3 ) ;
36705: LD_VAR 0 3
36709: PUSH
36710: LD_INT 3
36712: LESS
36713: PUSH
36714: LD_VAR 0 4
36718: PUSH
36719: LD_INT 3
36721: LESS
36722: AND
36723: IFFALSE 36612
// ComMoveXY ( veh , 144 , 65 ) ;
36725: LD_VAR 0 1
36729: PPUSH
36730: LD_INT 144
36732: PPUSH
36733: LD_INT 65
36735: PPUSH
36736: CALL_OW 111
// if n_check < s_check then
36740: LD_VAR 0 3
36744: PUSH
36745: LD_VAR 0 4
36749: LESS
36750: IFFALSE 36799
// begin AddComMoveXY ( veh , 87 , 35 ) ;
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 87
36759: PPUSH
36760: LD_INT 35
36762: PPUSH
36763: CALL_OW 171
// AddComMoveXY ( veh , 42 , 16 ) ;
36767: LD_VAR 0 1
36771: PPUSH
36772: LD_INT 42
36774: PPUSH
36775: LD_INT 16
36777: PPUSH
36778: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 56 ) ;
36782: LD_VAR 0 1
36786: PPUSH
36787: LD_INT 41
36789: PPUSH
36790: LD_INT 56
36792: PPUSH
36793: CALL_OW 176
// end else
36797: GO 36891
// begin AddComMoveXY ( veh , 141 , 116 ) ;
36799: LD_VAR 0 1
36803: PPUSH
36804: LD_INT 141
36806: PPUSH
36807: LD_INT 116
36809: PPUSH
36810: CALL_OW 171
// AddComMoveXY ( veh , 109 , 110 ) ;
36814: LD_VAR 0 1
36818: PPUSH
36819: LD_INT 109
36821: PPUSH
36822: LD_INT 110
36824: PPUSH
36825: CALL_OW 171
// if GetChassis ( veh ) = ru_heavy_tracked then
36829: LD_VAR 0 1
36833: PPUSH
36834: CALL_OW 265
36838: PUSH
36839: LD_INT 24
36841: EQUAL
36842: IFFALSE 36861
// AddComMoveXY ( veh , 86 , 106 ) else
36844: LD_VAR 0 1
36848: PPUSH
36849: LD_INT 86
36851: PPUSH
36852: LD_INT 106
36854: PPUSH
36855: CALL_OW 171
36859: GO 36876
// AddComMoveXY ( veh , 85 , 75 ) ;
36861: LD_VAR 0 1
36865: PPUSH
36866: LD_INT 85
36868: PPUSH
36869: LD_INT 75
36871: PPUSH
36872: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 66 ) ;
36876: LD_VAR 0 1
36880: PPUSH
36881: LD_INT 41
36883: PPUSH
36884: LD_INT 66
36886: PPUSH
36887: CALL_OW 176
// end ; end ; end_of_file
36891: LD_VAR 0 2
36895: RET
// export artefact_number , artefact_num , artefact_size ; export labs_in_use ; export function init_alien_research ; var art_icons , art_events , art_difficulty , art_cost , art_recharge ; begin
36896: LD_INT 0
36898: PPUSH
36899: PPUSH
36900: PPUSH
36901: PPUSH
36902: PPUSH
36903: PPUSH
// artefact_number := 3 ;
36904: LD_ADDR_EXP 76
36908: PUSH
36909: LD_INT 3
36911: ST_TO_ADDR
// artefact_num := [ 0 , 0 , 1 , 2 , 3 ] ;
36912: LD_ADDR_EXP 77
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: LD_INT 0
36922: PUSH
36923: LD_INT 1
36925: PUSH
36926: LD_INT 2
36928: PUSH
36929: LD_INT 3
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: ST_TO_ADDR
// artefact_size := [ 3 , 4 , 5 ] ;
36939: LD_ADDR_EXP 78
36943: PUSH
36944: LD_INT 3
36946: PUSH
36947: LD_INT 4
36949: PUSH
36950: LD_INT 5
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: LIST
36957: ST_TO_ADDR
// art_icons := [ [ art_exp_left , art_use_eye ] , [ art_exp_mid , art_use_sibexplosion ] , [ art_exp_right , art_use_power ] ] ;
36958: LD_ADDR_VAR 0 2
36962: PUSH
36963: LD_INT 1
36965: PUSH
36966: LD_INT 4
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: PUSH
36976: LD_INT 5
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: PUSH
36986: LD_INT 9
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: LIST
36997: ST_TO_ADDR
// art_events := [ art_place , art_unit , art_place ] ;
36998: LD_ADDR_VAR 0 3
37002: PUSH
37003: LD_INT 3
37005: PUSH
37006: LD_INT 4
37008: PUSH
37009: LD_INT 3
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: LIST
37016: ST_TO_ADDR
// art_difficulty := [ 150 , 250 , 400 ] ;
37017: LD_ADDR_VAR 0 4
37021: PUSH
37022: LD_INT 150
37024: PUSH
37025: LD_INT 250
37027: PUSH
37028: LD_INT 400
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: LIST
37035: ST_TO_ADDR
// art_cost := [ 1 + difficulty , 2 + ( 3 * difficulty ) , 30 + ( 10 * difficulty ) ] ;
37036: LD_ADDR_VAR 0 5
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: LD_OWVAR 67
37048: PLUS
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: LD_OWVAR 67
37060: MUL
37061: PLUS
37062: PUSH
37063: LD_INT 30
37065: PUSH
37066: LD_INT 10
37068: PUSH
37069: LD_OWVAR 67
37073: MUL
37074: PLUS
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: LIST
37080: ST_TO_ADDR
// art_recharge := [ 6 * difficulty , 12 * difficulty , 10000 ] ;
37081: LD_ADDR_VAR 0 6
37085: PUSH
37086: LD_INT 6
37088: PUSH
37089: LD_OWVAR 67
37093: MUL
37094: PUSH
37095: LD_INT 12
37097: PUSH
37098: LD_OWVAR 67
37102: MUL
37103: PUSH
37104: LD_INT 10000
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: LIST
37111: ST_TO_ADDR
// Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ;
37112: LD_VAR 0 2
37116: PPUSH
37117: LD_VAR 0 3
37121: PPUSH
37122: LD_VAR 0 4
37126: PPUSH
37127: LD_VAR 0 5
37131: PPUSH
37132: LD_VAR 0 6
37136: PPUSH
37137: CALL 37146 0 5
// end ;
37141: LD_VAR 0 1
37145: RET
// function Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ; var un , i , side , base ; begin
37146: LD_INT 0
37148: PPUSH
37149: PPUSH
37150: PPUSH
37151: PPUSH
37152: PPUSH
// disable ( 1 ) ;
37153: LD_INT 1
37155: DISABLE_MARKED
// disable ( 5 ) ;
37156: LD_INT 5
37158: DISABLE_MARKED
// disable ( 6 ) ;
37159: LD_INT 6
37161: DISABLE_MARKED
// disable ( 7 ) ;
37162: LD_INT 7
37164: DISABLE_MARKED
// for side = 1 to 8 do
37165: LD_ADDR_VAR 0 9
37169: PUSH
37170: DOUBLE
37171: LD_INT 1
37173: DEC
37174: ST_TO_ADDR
37175: LD_INT 8
37177: PUSH
37178: FOR_TO
37179: IFFALSE 37195
// SetArtifactRes ( side , state_enabled ) ;
37181: LD_VAR 0 9
37185: PPUSH
37186: LD_INT 1
37188: PPUSH
37189: CALL_OW 467
37193: GO 37178
37195: POP
37196: POP
// for un = 0 to ( artefact_number - 1 ) do
37197: LD_ADDR_VAR 0 7
37201: PUSH
37202: DOUBLE
37203: LD_INT 0
37205: DEC
37206: ST_TO_ADDR
37207: LD_EXP 76
37211: PUSH
37212: LD_INT 1
37214: MINUS
37215: PUSH
37216: FOR_TO
37217: IFFALSE 37615
// begin base := un * 100 ;
37219: LD_ADDR_VAR 0 10
37223: PUSH
37224: LD_VAR 0 7
37228: PUSH
37229: LD_INT 100
37231: MUL
37232: ST_TO_ADDR
// SetTag ( base + 01 , art_icons [ un + 1 ] [ 1 ] ) ;
37233: LD_VAR 0 10
37237: PUSH
37238: LD_INT 1
37240: PLUS
37241: PPUSH
37242: LD_VAR 0 1
37246: PUSH
37247: LD_VAR 0 7
37251: PUSH
37252: LD_INT 1
37254: PLUS
37255: ARRAY
37256: PUSH
37257: LD_INT 1
37259: ARRAY
37260: PPUSH
37261: CALL_OW 109
// SetTag ( base + 02 , art_icons [ un + 1 ] [ 2 ] ) ;
37265: LD_VAR 0 10
37269: PUSH
37270: LD_INT 2
37272: PLUS
37273: PPUSH
37274: LD_VAR 0 1
37278: PUSH
37279: LD_VAR 0 7
37283: PUSH
37284: LD_INT 1
37286: PLUS
37287: ARRAY
37288: PUSH
37289: LD_INT 2
37291: ARRAY
37292: PPUSH
37293: CALL_OW 109
// SetTag ( base + 03 , art_events [ un + 1 ] ) ;
37297: LD_VAR 0 10
37301: PUSH
37302: LD_INT 3
37304: PLUS
37305: PPUSH
37306: LD_VAR 0 2
37310: PUSH
37311: LD_VAR 0 7
37315: PUSH
37316: LD_INT 1
37318: PLUS
37319: ARRAY
37320: PPUSH
37321: CALL_OW 109
// SetTag ( base + 05 , art_difficulty [ un + 1 ] ) ;
37325: LD_VAR 0 10
37329: PUSH
37330: LD_INT 5
37332: PLUS
37333: PPUSH
37334: LD_VAR 0 3
37338: PUSH
37339: LD_VAR 0 7
37343: PUSH
37344: LD_INT 1
37346: PLUS
37347: ARRAY
37348: PPUSH
37349: CALL_OW 109
// SetTag ( base + 06 , art_cost [ un + 1 ] ) ;
37353: LD_VAR 0 10
37357: PUSH
37358: LD_INT 6
37360: PLUS
37361: PPUSH
37362: LD_VAR 0 4
37366: PUSH
37367: LD_VAR 0 7
37371: PUSH
37372: LD_INT 1
37374: PLUS
37375: ARRAY
37376: PPUSH
37377: CALL_OW 109
// SetTag ( base + 07 , art_recharge [ un + 1 ] ) ;
37381: LD_VAR 0 10
37385: PUSH
37386: LD_INT 7
37388: PLUS
37389: PPUSH
37390: LD_VAR 0 5
37394: PUSH
37395: LD_VAR 0 7
37399: PUSH
37400: LD_INT 1
37402: PLUS
37403: ARRAY
37404: PPUSH
37405: CALL_OW 109
// SetTag ( base + 08 , false ) ;
37409: LD_VAR 0 10
37413: PUSH
37414: LD_INT 8
37416: PLUS
37417: PPUSH
37418: LD_INT 0
37420: PPUSH
37421: CALL_OW 109
// SetTag ( base + 09 , false ) ;
37425: LD_VAR 0 10
37429: PUSH
37430: LD_INT 9
37432: PLUS
37433: PPUSH
37434: LD_INT 0
37436: PPUSH
37437: CALL_OW 109
// SetTag ( base + 11 , 0 ) ;
37441: LD_VAR 0 10
37445: PUSH
37446: LD_INT 11
37448: PLUS
37449: PPUSH
37450: LD_INT 0
37452: PPUSH
37453: CALL_OW 109
// SetTag ( base + 12 , false ) ;
37457: LD_VAR 0 10
37461: PUSH
37462: LD_INT 12
37464: PLUS
37465: PPUSH
37466: LD_INT 0
37468: PPUSH
37469: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37473: LD_VAR 0 10
37477: PUSH
37478: LD_INT 13
37480: PLUS
37481: PPUSH
37482: LD_INT 0
37484: PPUSH
37485: CALL_OW 109
// for i = 0 to 7 do
37489: LD_ADDR_VAR 0 8
37493: PUSH
37494: DOUBLE
37495: LD_INT 0
37497: DEC
37498: ST_TO_ADDR
37499: LD_INT 7
37501: PUSH
37502: FOR_TO
37503: IFFALSE 37611
// begin SetTag ( base + i * 10 + 21 , false ) ;
37505: LD_VAR 0 10
37509: PUSH
37510: LD_VAR 0 8
37514: PUSH
37515: LD_INT 10
37517: MUL
37518: PLUS
37519: PUSH
37520: LD_INT 21
37522: PLUS
37523: PPUSH
37524: LD_INT 0
37526: PPUSH
37527: CALL_OW 109
// SetTag ( base + i * 10 + 22 , 0 ) ;
37531: LD_VAR 0 10
37535: PUSH
37536: LD_VAR 0 8
37540: PUSH
37541: LD_INT 10
37543: MUL
37544: PLUS
37545: PUSH
37546: LD_INT 22
37548: PLUS
37549: PPUSH
37550: LD_INT 0
37552: PPUSH
37553: CALL_OW 109
// SetTag ( base + i * 10 + 23 , 0 ) ;
37557: LD_VAR 0 10
37561: PUSH
37562: LD_VAR 0 8
37566: PUSH
37567: LD_INT 10
37569: MUL
37570: PLUS
37571: PUSH
37572: LD_INT 23
37574: PLUS
37575: PPUSH
37576: LD_INT 0
37578: PPUSH
37579: CALL_OW 109
// SetTag ( base + i * 10 + 25 , 0 ) ;
37583: LD_VAR 0 10
37587: PUSH
37588: LD_VAR 0 8
37592: PUSH
37593: LD_INT 10
37595: MUL
37596: PLUS
37597: PUSH
37598: LD_INT 25
37600: PLUS
37601: PPUSH
37602: LD_INT 0
37604: PPUSH
37605: CALL_OW 109
// end ;
37609: GO 37502
37611: POP
37612: POP
// end ;
37613: GO 37216
37615: POP
37616: POP
// enable ( 20 ) ;
37617: LD_INT 20
37619: ENABLE_MARKED
// labs_in_use := [ ] ;
37620: LD_ADDR_EXP 79
37624: PUSH
37625: EMPTY
37626: ST_TO_ADDR
// end ;
37627: LD_VAR 0 6
37631: RET
// on ArtifactUnloaded ( un , size ) do var art , base ;
37632: LD_INT 0
37634: PPUSH
37635: PPUSH
// begin art := artefact_num [ size ] ;
37636: LD_ADDR_VAR 0 3
37640: PUSH
37641: LD_EXP 77
37645: PUSH
37646: LD_VAR 0 2
37650: ARRAY
37651: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37652: LD_ADDR_VAR 0 4
37656: PUSH
37657: LD_VAR 0 3
37661: PUSH
37662: LD_INT 1
37664: MINUS
37665: PUSH
37666: LD_INT 100
37668: MUL
37669: ST_TO_ADDR
// SetTag ( base + 09 , false ) ;
37670: LD_VAR 0 4
37674: PUSH
37675: LD_INT 9
37677: PLUS
37678: PPUSH
37679: LD_INT 0
37681: PPUSH
37682: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37686: LD_VAR 0 4
37690: PUSH
37691: LD_INT 13
37693: PLUS
37694: PPUSH
37695: LD_INT 0
37697: PPUSH
37698: CALL_OW 109
// Init_Lab ( art ) ;
37702: LD_VAR 0 3
37706: PPUSH
37707: CALL 39243 0 1
// end ;
37711: PPOPN 4
37713: END
// on ArtifactLoaded ( un , size ) do var art , base , side ;
37714: LD_INT 0
37716: PPUSH
37717: PPUSH
37718: PPUSH
// begin art := artefact_num [ size ] ;
37719: LD_ADDR_VAR 0 3
37723: PUSH
37724: LD_EXP 77
37728: PUSH
37729: LD_VAR 0 2
37733: ARRAY
37734: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37735: LD_ADDR_VAR 0 4
37739: PUSH
37740: LD_VAR 0 3
37744: PUSH
37745: LD_INT 1
37747: MINUS
37748: PUSH
37749: LD_INT 100
37751: MUL
37752: ST_TO_ADDR
// SetTag ( base + 09 , true ) ;
37753: LD_VAR 0 4
37757: PUSH
37758: LD_INT 9
37760: PLUS
37761: PPUSH
37762: LD_INT 1
37764: PPUSH
37765: CALL_OW 109
// SetTag ( base + 13 , un ) ;
37769: LD_VAR 0 4
37773: PUSH
37774: LD_INT 13
37776: PLUS
37777: PPUSH
37778: LD_VAR 0 1
37782: PPUSH
37783: CALL_OW 109
// if GetTag ( base + 11 ) then
37787: LD_VAR 0 4
37791: PUSH
37792: LD_INT 11
37794: PLUS
37795: PPUSH
37796: CALL_OW 110
37800: IFFALSE 37963
// begin side := GetSide ( GetTag ( base + 11 ) ) ;
37802: LD_ADDR_VAR 0 5
37806: PUSH
37807: LD_VAR 0 4
37811: PUSH
37812: LD_INT 11
37814: PLUS
37815: PPUSH
37816: CALL_OW 110
37820: PPUSH
37821: CALL_OW 255
37825: ST_TO_ADDR
// if GetTag ( base + 12 ) then
37826: LD_VAR 0 4
37830: PUSH
37831: LD_INT 12
37833: PLUS
37834: PPUSH
37835: CALL_OW 110
37839: IFFALSE 37907
// begin ComCancel ( GetTag ( base + 11 ) ) ;
37841: LD_VAR 0 4
37845: PUSH
37846: LD_INT 11
37848: PLUS
37849: PPUSH
37850: CALL_OW 110
37854: PPUSH
37855: CALL_OW 127
// wait ( 5 ) ;
37859: LD_INT 5
37861: PPUSH
37862: CALL_OW 67
// labs_in_use := labs_in_use diff GetTag ( base + 11 ) ;
37866: LD_ADDR_EXP 79
37870: PUSH
37871: LD_EXP 79
37875: PUSH
37876: LD_VAR 0 4
37880: PUSH
37881: LD_INT 11
37883: PLUS
37884: PPUSH
37885: CALL_OW 110
37889: DIFF
37890: ST_TO_ADDR
// SetTag ( base + 12 , false ) ;
37891: LD_VAR 0 4
37895: PUSH
37896: LD_INT 12
37898: PLUS
37899: PPUSH
37900: LD_INT 0
37902: PPUSH
37903: CALL_OW 109
// end ; if not GetTag ( base + side * 10 + 11 ) then
37907: LD_VAR 0 4
37911: PUSH
37912: LD_VAR 0 5
37916: PUSH
37917: LD_INT 10
37919: MUL
37920: PLUS
37921: PUSH
37922: LD_INT 11
37924: PLUS
37925: PPUSH
37926: CALL_OW 110
37930: NOT
37931: IFFALSE 37947
// DeInit_Lab ( side , art ) ;
37933: LD_VAR 0 5
37937: PPUSH
37938: LD_VAR 0 3
37942: PPUSH
37943: CALL 39937 0 2
// SetTag ( base + 11 , 0 ) ;
37947: LD_VAR 0 4
37951: PUSH
37952: LD_INT 11
37954: PLUS
37955: PPUSH
37956: LD_INT 0
37958: PPUSH
37959: CALL_OW 109
// end ; end ;
37963: PPOPN 5
37965: END
// on ArtifactResearchComplete ( lab ) do var un , side ;
37966: LD_INT 0
37968: PPUSH
37969: PPUSH
// begin side := GetSide ( lab ) - 1 ;
37970: LD_ADDR_VAR 0 3
37974: PUSH
37975: LD_VAR 0 1
37979: PPUSH
37980: CALL_OW 255
37984: PUSH
37985: LD_INT 1
37987: MINUS
37988: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
37989: LD_ADDR_VAR 0 2
37993: PUSH
37994: DOUBLE
37995: LD_INT 0
37997: DEC
37998: ST_TO_ADDR
37999: LD_EXP 76
38003: PUSH
38004: LD_INT 1
38006: MINUS
38007: PUSH
38008: FOR_TO
38009: IFFALSE 38051
// if lab = GetTag ( un * 100 + 11 ) then
38011: LD_VAR 0 1
38015: PUSH
38016: LD_VAR 0 2
38020: PUSH
38021: LD_INT 100
38023: MUL
38024: PUSH
38025: LD_INT 11
38027: PLUS
38028: PPUSH
38029: CALL_OW 110
38033: EQUAL
38034: IFFALSE 38049
// Init_Lab ( un + 1 ) ;
38036: LD_VAR 0 2
38040: PUSH
38041: LD_INT 1
38043: PLUS
38044: PPUSH
38045: CALL 39243 0 1
38049: GO 38008
38051: POP
38052: POP
// end ;
38053: PPOPN 3
38055: END
// on SpecResearchCancel ( lab , progress ) do var un , side ;
38056: LD_INT 0
38058: PPUSH
38059: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38060: LD_ADDR_VAR 0 4
38064: PUSH
38065: LD_VAR 0 1
38069: PPUSH
38070: CALL_OW 255
38074: PUSH
38075: LD_INT 1
38077: MINUS
38078: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38079: LD_ADDR_VAR 0 3
38083: PUSH
38084: DOUBLE
38085: LD_INT 0
38087: DEC
38088: ST_TO_ADDR
38089: LD_EXP 76
38093: PUSH
38094: LD_INT 1
38096: MINUS
38097: PUSH
38098: FOR_TO
38099: IFFALSE 38217
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38101: LD_VAR 0 3
38105: PUSH
38106: LD_INT 100
38108: MUL
38109: PUSH
38110: LD_INT 11
38112: PLUS
38113: PPUSH
38114: CALL_OW 110
38118: PUSH
38119: LD_VAR 0 1
38123: EQUAL
38124: PUSH
38125: LD_VAR 0 3
38129: PUSH
38130: LD_INT 100
38132: MUL
38133: PUSH
38134: LD_INT 12
38136: PLUS
38137: PPUSH
38138: CALL_OW 110
38142: AND
38143: IFFALSE 38215
// begin SetTag ( un * 100 + side * 10 + 22 , progress ) ;
38145: LD_VAR 0 3
38149: PUSH
38150: LD_INT 100
38152: MUL
38153: PUSH
38154: LD_VAR 0 4
38158: PUSH
38159: LD_INT 10
38161: MUL
38162: PLUS
38163: PUSH
38164: LD_INT 22
38166: PLUS
38167: PPUSH
38168: LD_VAR 0 2
38172: PPUSH
38173: CALL_OW 109
// SetTag ( un * 100 + 12 , false ) ;
38177: LD_VAR 0 3
38181: PUSH
38182: LD_INT 100
38184: MUL
38185: PUSH
38186: LD_INT 12
38188: PLUS
38189: PPUSH
38190: LD_INT 0
38192: PPUSH
38193: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38197: LD_ADDR_EXP 79
38201: PUSH
38202: LD_EXP 79
38206: PUSH
38207: LD_VAR 0 1
38211: DIFF
38212: ST_TO_ADDR
// break ;
38213: GO 38217
// end ;
38215: GO 38098
38217: POP
38218: POP
// Update_Artefact ( lab ) ;
38219: LD_VAR 0 1
38223: PPUSH
38224: CALL 40076 0 1
// end ;
38228: PPOPN 4
38230: END
// on SpecResearchComplete ( lab ) do var un , side ;
38231: LD_INT 0
38233: PPUSH
38234: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38235: LD_ADDR_VAR 0 3
38239: PUSH
38240: LD_VAR 0 1
38244: PPUSH
38245: CALL_OW 255
38249: PUSH
38250: LD_INT 1
38252: MINUS
38253: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38254: LD_ADDR_VAR 0 2
38258: PUSH
38259: DOUBLE
38260: LD_INT 0
38262: DEC
38263: ST_TO_ADDR
38264: LD_EXP 76
38268: PUSH
38269: LD_INT 1
38271: MINUS
38272: PUSH
38273: FOR_TO
38274: IFFALSE 38480
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38276: LD_VAR 0 2
38280: PUSH
38281: LD_INT 100
38283: MUL
38284: PUSH
38285: LD_INT 11
38287: PLUS
38288: PPUSH
38289: CALL_OW 110
38293: PUSH
38294: LD_VAR 0 1
38298: EQUAL
38299: PUSH
38300: LD_VAR 0 2
38304: PUSH
38305: LD_INT 100
38307: MUL
38308: PUSH
38309: LD_INT 12
38311: PLUS
38312: PPUSH
38313: CALL_OW 110
38317: AND
38318: IFFALSE 38478
// begin SetTag ( un * 100 + 12 , false ) ;
38320: LD_VAR 0 2
38324: PUSH
38325: LD_INT 100
38327: MUL
38328: PUSH
38329: LD_INT 12
38331: PLUS
38332: PPUSH
38333: LD_INT 0
38335: PPUSH
38336: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 21 , true ) ;
38340: LD_VAR 0 2
38344: PUSH
38345: LD_INT 100
38347: MUL
38348: PUSH
38349: LD_VAR 0 3
38353: PUSH
38354: LD_INT 10
38356: MUL
38357: PLUS
38358: PUSH
38359: LD_INT 21
38361: PLUS
38362: PPUSH
38363: LD_INT 1
38365: PPUSH
38366: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 25 , lab ) ;
38370: LD_VAR 0 2
38374: PUSH
38375: LD_INT 100
38377: MUL
38378: PUSH
38379: LD_VAR 0 3
38383: PUSH
38384: LD_INT 10
38386: MUL
38387: PLUS
38388: PUSH
38389: LD_INT 25
38391: PLUS
38392: PPUSH
38393: LD_VAR 0 1
38397: PPUSH
38398: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38402: LD_ADDR_EXP 79
38406: PUSH
38407: LD_EXP 79
38411: PUSH
38412: LD_VAR 0 1
38416: DIFF
38417: ST_TO_ADDR
// case un of 0 :
38418: LD_VAR 0 2
38422: PUSH
38423: LD_INT 0
38425: DOUBLE
38426: EQUAL
38427: IFTRUE 38431
38429: GO 38441
38431: POP
// Hint ( ATSpy ) ; 1 :
38432: LD_STRING ATSpy
38434: PPUSH
38435: CALL_OW 339
38439: GO 38478
38441: LD_INT 1
38443: DOUBLE
38444: EQUAL
38445: IFTRUE 38449
38447: GO 38459
38449: POP
// Hint ( ATDetonated ) ; 2 :
38450: LD_STRING ATDetonated
38452: PPUSH
38453: CALL_OW 339
38457: GO 38478
38459: LD_INT 2
38461: DOUBLE
38462: EQUAL
38463: IFTRUE 38467
38465: GO 38477
38467: POP
// Hint ( ArterfactTeleport ) ; end ;
38468: LD_STRING ArterfactTeleport
38470: PPUSH
38471: CALL_OW 339
38475: GO 38478
38477: POP
// end ;
38478: GO 38273
38480: POP
38481: POP
// Update_Artefact ( lab ) ;
38482: LD_VAR 0 1
38486: PPUSH
38487: CALL 40076 0 1
// end ;
38491: PPOPN 3
38493: END
// on ArtifactUsed ( side , number , p1 , p2 ) do var un , succes , art , base ;
38494: LD_INT 0
38496: PPUSH
38497: PPUSH
38498: PPUSH
38499: PPUSH
// begin art := ( ( number - 1 ) mod 3 ) + 1 ;
38500: LD_ADDR_VAR 0 7
38504: PUSH
38505: LD_VAR 0 2
38509: PUSH
38510: LD_INT 1
38512: MINUS
38513: PUSH
38514: LD_INT 3
38516: MOD
38517: PUSH
38518: LD_INT 1
38520: PLUS
38521: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38522: LD_ADDR_VAR 0 8
38526: PUSH
38527: LD_VAR 0 7
38531: PUSH
38532: LD_INT 1
38534: MINUS
38535: PUSH
38536: LD_INT 100
38538: MUL
38539: ST_TO_ADDR
// if number <= 3 then
38540: LD_VAR 0 2
38544: PUSH
38545: LD_INT 3
38547: LESSEQUAL
38548: IFFALSE 38780
// begin SetSpecResearch ( GetTag ( base + 11 ) , GetTag ( base + 05 ) , true ) ;
38550: LD_VAR 0 8
38554: PUSH
38555: LD_INT 11
38557: PLUS
38558: PPUSH
38559: CALL_OW 110
38563: PPUSH
38564: LD_VAR 0 8
38568: PUSH
38569: LD_INT 5
38571: PLUS
38572: PPUSH
38573: CALL_OW 110
38577: PPUSH
38578: LD_INT 1
38580: PPUSH
38581: CALL_OW 486
// SetWorkingProgress ( GetTag ( base + 11 ) , GetTag ( base + side * 10 + 12 ) ) ;
38585: LD_VAR 0 8
38589: PUSH
38590: LD_INT 11
38592: PLUS
38593: PPUSH
38594: CALL_OW 110
38598: PPUSH
38599: LD_VAR 0 8
38603: PUSH
38604: LD_VAR 0 1
38608: PUSH
38609: LD_INT 10
38611: MUL
38612: PLUS
38613: PUSH
38614: LD_INT 12
38616: PLUS
38617: PPUSH
38618: CALL_OW 110
38622: PPUSH
38623: CALL_OW 329
// SetTag ( base + 12 , true ) ;
38627: LD_VAR 0 8
38631: PUSH
38632: LD_INT 12
38634: PLUS
38635: PPUSH
38636: LD_INT 1
38638: PPUSH
38639: CALL_OW 109
// labs_in_use := labs_in_use ^ GetTag ( base + 11 ) ;
38643: LD_ADDR_EXP 79
38647: PUSH
38648: LD_EXP 79
38652: PUSH
38653: LD_VAR 0 8
38657: PUSH
38658: LD_INT 11
38660: PLUS
38661: PPUSH
38662: CALL_OW 110
38666: ADD
38667: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38668: LD_ADDR_VAR 0 5
38672: PUSH
38673: DOUBLE
38674: LD_INT 0
38676: DEC
38677: ST_TO_ADDR
38678: LD_EXP 76
38682: PUSH
38683: LD_INT 1
38685: MINUS
38686: PUSH
38687: FOR_TO
38688: IFFALSE 38776
// if GetTag ( base + 11 ) in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
38690: LD_VAR 0 8
38694: PUSH
38695: LD_INT 11
38697: PLUS
38698: PPUSH
38699: CALL_OW 110
38703: PUSH
38704: LD_VAR 0 5
38708: PUSH
38709: LD_INT 100
38711: MUL
38712: PUSH
38713: LD_INT 11
38715: PLUS
38716: PPUSH
38717: CALL_OW 110
38721: PUSH
38722: LD_VAR 0 5
38726: PUSH
38727: LD_INT 100
38729: MUL
38730: PUSH
38731: LD_VAR 0 1
38735: PUSH
38736: LD_INT 10
38738: MUL
38739: PLUS
38740: PUSH
38741: LD_INT 15
38743: PLUS
38744: PPUSH
38745: CALL_OW 110
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: IN
38754: IFFALSE 38774
// DeInit_Lab ( side , un + 1 ) ;
38756: LD_VAR 0 1
38760: PPUSH
38761: LD_VAR 0 5
38765: PUSH
38766: LD_INT 1
38768: PLUS
38769: PPUSH
38770: CALL 39937 0 2
38774: GO 38687
38776: POP
38777: POP
// end else
38778: GO 38954
// begin succes := false ;
38780: LD_ADDR_VAR 0 6
38784: PUSH
38785: LD_INT 0
38787: ST_TO_ADDR
// case art of 1 :
38788: LD_VAR 0 7
38792: PUSH
38793: LD_INT 1
38795: DOUBLE
38796: EQUAL
38797: IFTRUE 38801
38799: GO 38829
38801: POP
// succes := Show_me_map ( side , p1 , p2 ) ; 2 :
38802: LD_ADDR_VAR 0 6
38806: PUSH
38807: LD_VAR 0 1
38811: PPUSH
38812: LD_VAR 0 3
38816: PPUSH
38817: LD_VAR 0 4
38821: PPUSH
38822: CALL 40376 0 3
38826: ST_TO_ADDR
38827: GO 38897
38829: LD_INT 2
38831: DOUBLE
38832: EQUAL
38833: IFTRUE 38837
38835: GO 38860
38837: POP
// succes := Destroy_siberite ( side , p1 ) ; 3 :
38838: LD_ADDR_VAR 0 6
38842: PUSH
38843: LD_VAR 0 1
38847: PPUSH
38848: LD_VAR 0 3
38852: PPUSH
38853: CALL 40614 0 2
38857: ST_TO_ADDR
38858: GO 38897
38860: LD_INT 3
38862: DOUBLE
38863: EQUAL
38864: IFTRUE 38868
38866: GO 38896
38868: POP
// succes := Mass_Teleport ( side , p1 , p2 ) ; end ;
38869: LD_ADDR_VAR 0 6
38873: PUSH
38874: LD_VAR 0 1
38878: PPUSH
38879: LD_VAR 0 3
38883: PPUSH
38884: LD_VAR 0 4
38888: PPUSH
38889: CALL 40939 0 3
38893: ST_TO_ADDR
38894: GO 38897
38896: POP
// if succes then
38897: LD_VAR 0 6
38901: IFFALSE 38954
// begin SetTag ( base + side * 10 + 13 , GetTag ( base + 07 ) ) ;
38903: LD_VAR 0 8
38907: PUSH
38908: LD_VAR 0 1
38912: PUSH
38913: LD_INT 10
38915: MUL
38916: PLUS
38917: PUSH
38918: LD_INT 13
38920: PLUS
38921: PPUSH
38922: LD_VAR 0 8
38926: PUSH
38927: LD_INT 7
38929: PLUS
38930: PPUSH
38931: CALL_OW 110
38935: PPUSH
38936: CALL_OW 109
// Shadow_Artefact ( side , art ) ;
38940: LD_VAR 0 1
38944: PPUSH
38945: LD_VAR 0 7
38949: PPUSH
38950: CALL 38957 0 2
// end ; end ; end ;
38954: PPOPN 8
38956: END
// export function Shadow_Artefact ( side , art ) ; var base , lab ; begin
38957: LD_INT 0
38959: PPUSH
38960: PPUSH
38961: PPUSH
// base := ( art - 1 ) * 100 ;
38962: LD_ADDR_VAR 0 4
38966: PUSH
38967: LD_VAR 0 2
38971: PUSH
38972: LD_INT 1
38974: MINUS
38975: PUSH
38976: LD_INT 100
38978: MUL
38979: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
38980: LD_ADDR_VAR 0 5
38984: PUSH
38985: LD_VAR 0 4
38989: PUSH
38990: LD_VAR 0 1
38994: PUSH
38995: LD_INT 10
38997: MUL
38998: PLUS
38999: PUSH
39000: LD_INT 15
39002: PLUS
39003: PPUSH
39004: CALL_OW 110
39008: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) then
39009: LD_VAR 0 5
39013: PUSH
39014: LD_VAR 0 5
39018: PUSH
39019: LD_EXP 79
39023: IN
39024: NOT
39025: AND
39026: IFFALSE 39084
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_gray , lab ) ;
39028: LD_VAR 0 1
39032: PPUSH
39033: LD_VAR 0 4
39037: PUSH
39038: LD_INT 1
39040: PLUS
39041: PUSH
39042: LD_VAR 0 4
39046: PUSH
39047: LD_VAR 0 1
39051: PUSH
39052: LD_INT 10
39054: MUL
39055: PLUS
39056: PUSH
39057: LD_INT 11
39059: PLUS
39060: PPUSH
39061: CALL_OW 110
39065: PLUS
39066: PPUSH
39067: CALL_OW 110
39071: PPUSH
39072: LD_INT 1
39074: PPUSH
39075: LD_VAR 0 5
39079: PPUSH
39080: CALL_OW 468
// end ;
39084: LD_VAR 0 3
39088: RET
// export function Highlight_Artefact ( side , art ) ; var base , lab ; begin
39089: LD_INT 0
39091: PPUSH
39092: PPUSH
39093: PPUSH
// base := ( art - 1 ) * 100 ;
39094: LD_ADDR_VAR 0 4
39098: PUSH
39099: LD_VAR 0 2
39103: PUSH
39104: LD_INT 1
39106: MINUS
39107: PUSH
39108: LD_INT 100
39110: MUL
39111: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39112: LD_ADDR_VAR 0 5
39116: PUSH
39117: LD_VAR 0 4
39121: PUSH
39122: LD_VAR 0 1
39126: PUSH
39127: LD_INT 10
39129: MUL
39130: PLUS
39131: PUSH
39132: LD_INT 15
39134: PLUS
39135: PPUSH
39136: CALL_OW 110
39140: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) and UnitsInside ( lab ) then
39141: LD_VAR 0 5
39145: PUSH
39146: LD_VAR 0 5
39150: PUSH
39151: LD_EXP 79
39155: IN
39156: NOT
39157: AND
39158: PUSH
39159: LD_VAR 0 5
39163: PPUSH
39164: CALL_OW 313
39168: AND
39169: IFFALSE 39238
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , GetTag ( base + 03 ) , lab ) ;
39171: LD_VAR 0 1
39175: PPUSH
39176: LD_VAR 0 4
39180: PUSH
39181: LD_INT 1
39183: PLUS
39184: PUSH
39185: LD_VAR 0 4
39189: PUSH
39190: LD_VAR 0 1
39194: PUSH
39195: LD_INT 10
39197: MUL
39198: PLUS
39199: PUSH
39200: LD_INT 11
39202: PLUS
39203: PPUSH
39204: CALL_OW 110
39208: PLUS
39209: PPUSH
39210: CALL_OW 110
39214: PPUSH
39215: LD_VAR 0 4
39219: PUSH
39220: LD_INT 3
39222: PLUS
39223: PPUSH
39224: CALL_OW 110
39228: PPUSH
39229: LD_VAR 0 5
39233: PPUSH
39234: CALL_OW 468
// end ;
39238: LD_VAR 0 3
39242: RET
// export function Init_Lab ( art ) ; var list , side , base , dist , state , art_hex , nearest_lab ; begin
39243: LD_INT 0
39245: PPUSH
39246: PPUSH
39247: PPUSH
39248: PPUSH
39249: PPUSH
39250: PPUSH
39251: PPUSH
39252: PPUSH
// art_hex := FindArtifact ( artefact_size [ art ] ) ;
39253: LD_ADDR_VAR 0 8
39257: PUSH
39258: LD_EXP 78
39262: PUSH
39263: LD_VAR 0 1
39267: ARRAY
39268: PPUSH
39269: CALL_OW 469
39273: ST_TO_ADDR
// if not art_hex then
39274: LD_VAR 0 8
39278: NOT
39279: IFFALSE 39283
// exit ;
39281: GO 39932
// case art of 1 :
39283: LD_VAR 0 1
39287: PUSH
39288: LD_INT 1
39290: DOUBLE
39291: EQUAL
39292: IFTRUE 39296
39294: GO 39373
39296: POP
// list := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 2 :
39297: LD_ADDR_VAR 0 3
39301: PUSH
39302: LD_INT 23
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 21
39314: PUSH
39315: LD_INT 3
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: LD_INT 30
39327: PUSH
39328: LD_INT 6
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 30
39337: PUSH
39338: LD_INT 7
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 30
39347: PUSH
39348: LD_INT 8
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: LIST
39365: PPUSH
39366: CALL_OW 69
39370: ST_TO_ADDR
39371: GO 39493
39373: LD_INT 2
39375: DOUBLE
39376: EQUAL
39377: IFTRUE 39381
39379: GO 39458
39381: POP
// list := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 3 :
39382: LD_ADDR_VAR 0 3
39386: PUSH
39387: LD_INT 23
39389: PUSH
39390: LD_INT 3
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 21
39399: PUSH
39400: LD_INT 3
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 2
39409: PUSH
39410: LD_INT 30
39412: PUSH
39413: LD_INT 6
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 30
39422: PUSH
39423: LD_INT 7
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 30
39432: PUSH
39433: LD_INT 8
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: LIST
39450: PPUSH
39451: CALL_OW 69
39455: ST_TO_ADDR
39456: GO 39493
39458: LD_INT 3
39460: DOUBLE
39461: EQUAL
39462: IFTRUE 39466
39464: GO 39492
39466: POP
// list := FilterAllUnits ( [ [ f_btype , b_alien_tower ] ] ) ; end ;
39467: LD_ADDR_VAR 0 3
39471: PUSH
39472: LD_INT 30
39474: PUSH
39475: LD_INT 39
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: EMPTY
39483: LIST
39484: PPUSH
39485: CALL_OW 69
39489: ST_TO_ADDR
39490: GO 39493
39492: POP
// nearest_lab := NearestUnitToXY ( list , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39493: LD_ADDR_VAR 0 9
39497: PUSH
39498: LD_VAR 0 3
39502: PPUSH
39503: LD_VAR 0 8
39507: PUSH
39508: LD_INT 1
39510: ARRAY
39511: PPUSH
39512: LD_VAR 0 8
39516: PUSH
39517: LD_INT 2
39519: ARRAY
39520: PPUSH
39521: CALL_OW 73
39525: ST_TO_ADDR
// dist := GetDistUnitXY ( nearest_lab , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39526: LD_ADDR_VAR 0 6
39530: PUSH
39531: LD_VAR 0 9
39535: PPUSH
39536: LD_VAR 0 8
39540: PUSH
39541: LD_INT 1
39543: ARRAY
39544: PPUSH
39545: LD_VAR 0 8
39549: PUSH
39550: LD_INT 2
39552: ARRAY
39553: PPUSH
39554: CALL_OW 297
39558: ST_TO_ADDR
// if dist < 25 then
39559: LD_VAR 0 6
39563: PUSH
39564: LD_INT 25
39566: LESS
39567: IFFALSE 39932
// begin side := GetSide ( nearest_lab ) ;
39569: LD_ADDR_VAR 0 4
39573: PUSH
39574: LD_VAR 0 9
39578: PPUSH
39579: CALL_OW 255
39583: ST_TO_ADDR
// DeInit_Lab ( side , art ) ;
39584: LD_VAR 0 4
39588: PPUSH
39589: LD_VAR 0 1
39593: PPUSH
39594: CALL 39937 0 2
// base := ( art - 1 ) * 100 ;
39598: LD_ADDR_VAR 0 5
39602: PUSH
39603: LD_VAR 0 1
39607: PUSH
39608: LD_INT 1
39610: MINUS
39611: PUSH
39612: LD_INT 100
39614: MUL
39615: ST_TO_ADDR
// if ( GetTech ( tech_Artifact , side ) = state_researched ) then
39616: LD_INT 24
39618: PPUSH
39619: LD_VAR 0 4
39623: PPUSH
39624: CALL_OW 321
39628: PUSH
39629: LD_INT 2
39631: EQUAL
39632: IFFALSE 39835
// begin if GetTag ( base + side * 10 + 11 ) and UnitsInside ( nearest_lab ) then
39634: LD_VAR 0 5
39638: PUSH
39639: LD_VAR 0 4
39643: PUSH
39644: LD_INT 10
39646: MUL
39647: PLUS
39648: PUSH
39649: LD_INT 11
39651: PLUS
39652: PPUSH
39653: CALL_OW 110
39657: PUSH
39658: LD_VAR 0 9
39662: PPUSH
39663: CALL_OW 313
39667: AND
39668: IFFALSE 39825
// begin if not GetTag ( base + side * 10 + 13 ) then
39670: LD_VAR 0 5
39674: PUSH
39675: LD_VAR 0 4
39679: PUSH
39680: LD_INT 10
39682: MUL
39683: PLUS
39684: PUSH
39685: LD_INT 13
39687: PLUS
39688: PPUSH
39689: CALL_OW 110
39693: NOT
39694: IFFALSE 39717
// state := GetTag ( base + 03 ) else
39696: LD_ADDR_VAR 0 7
39700: PUSH
39701: LD_VAR 0 5
39705: PUSH
39706: LD_INT 3
39708: PLUS
39709: PPUSH
39710: CALL_OW 110
39714: ST_TO_ADDR
39715: GO 39725
// state := art_gray ;
39717: LD_ADDR_VAR 0 7
39721: PUSH
39722: LD_INT 1
39724: ST_TO_ADDR
// if GetTag ( base + side * 10 + 15 ) and ( GetTag ( base + side * 10 + 15 ) <> nearest_lab ) then
39725: LD_VAR 0 5
39729: PUSH
39730: LD_VAR 0 4
39734: PUSH
39735: LD_INT 10
39737: MUL
39738: PLUS
39739: PUSH
39740: LD_INT 15
39742: PLUS
39743: PPUSH
39744: CALL_OW 110
39748: PUSH
39749: LD_VAR 0 5
39753: PUSH
39754: LD_VAR 0 4
39758: PUSH
39759: LD_INT 10
39761: MUL
39762: PLUS
39763: PUSH
39764: LD_INT 15
39766: PLUS
39767: PPUSH
39768: CALL_OW 110
39772: PUSH
39773: LD_VAR 0 9
39777: NONEQUAL
39778: AND
39779: IFFALSE 39795
// DeInit_Lab ( side , art ) ;
39781: LD_VAR 0 4
39785: PPUSH
39786: LD_VAR 0 1
39790: PPUSH
39791: CALL 39937 0 2
// SetTag ( base + side * 10 + 15 , nearest_lab ) ;
39795: LD_VAR 0 5
39799: PUSH
39800: LD_VAR 0 4
39804: PUSH
39805: LD_INT 10
39807: MUL
39808: PLUS
39809: PUSH
39810: LD_INT 15
39812: PLUS
39813: PPUSH
39814: LD_VAR 0 9
39818: PPUSH
39819: CALL_OW 109
// end else
39823: GO 39833
// state := art_instant ;
39825: LD_ADDR_VAR 0 7
39829: PUSH
39830: LD_INT 2
39832: ST_TO_ADDR
// end else
39833: GO 39843
// state := art_gray ;
39835: LD_ADDR_VAR 0 7
39839: PUSH
39840: LD_INT 1
39842: ST_TO_ADDR
// SetTag ( base + 11 , nearest_lab ) ;
39843: LD_VAR 0 5
39847: PUSH
39848: LD_INT 11
39850: PLUS
39851: PPUSH
39852: LD_VAR 0 9
39856: PPUSH
39857: CALL_OW 109
// if not ( nearest_lab in labs_in_use ) then
39861: LD_VAR 0 9
39865: PUSH
39866: LD_EXP 79
39870: IN
39871: NOT
39872: IFFALSE 39932
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , state , nearest_lab ) ;
39874: LD_VAR 0 4
39878: PPUSH
39879: LD_VAR 0 5
39883: PUSH
39884: LD_INT 1
39886: PLUS
39887: PUSH
39888: LD_VAR 0 5
39892: PUSH
39893: LD_VAR 0 4
39897: PUSH
39898: LD_INT 10
39900: MUL
39901: PLUS
39902: PUSH
39903: LD_INT 11
39905: PLUS
39906: PPUSH
39907: CALL_OW 110
39911: PLUS
39912: PPUSH
39913: CALL_OW 110
39917: PPUSH
39918: LD_VAR 0 7
39922: PPUSH
39923: LD_VAR 0 9
39927: PPUSH
39928: CALL_OW 468
// end ; end ;
39932: LD_VAR 0 2
39936: RET
// export function DeInit_Lab ( side , art ) ; var base , lab ; begin
39937: LD_INT 0
39939: PPUSH
39940: PPUSH
39941: PPUSH
// base := ( art - 1 ) * 100 ;
39942: LD_ADDR_VAR 0 4
39946: PUSH
39947: LD_VAR 0 2
39951: PUSH
39952: LD_INT 1
39954: MINUS
39955: PUSH
39956: LD_INT 100
39958: MUL
39959: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39960: LD_ADDR_VAR 0 5
39964: PUSH
39965: LD_VAR 0 4
39969: PUSH
39970: LD_VAR 0 1
39974: PUSH
39975: LD_INT 10
39977: MUL
39978: PLUS
39979: PUSH
39980: LD_INT 15
39982: PLUS
39983: PPUSH
39984: CALL_OW 110
39988: ST_TO_ADDR
// if not lab then
39989: LD_VAR 0 5
39993: NOT
39994: IFFALSE 40015
// lab := GetTag ( base + 11 ) ;
39996: LD_ADDR_VAR 0 5
40000: PUSH
40001: LD_VAR 0 4
40005: PUSH
40006: LD_INT 11
40008: PLUS
40009: PPUSH
40010: CALL_OW 110
40014: ST_TO_ADDR
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_no , lab ) ;
40015: LD_VAR 0 1
40019: PPUSH
40020: LD_VAR 0 4
40024: PUSH
40025: LD_INT 1
40027: PLUS
40028: PUSH
40029: LD_VAR 0 4
40033: PUSH
40034: LD_VAR 0 1
40038: PUSH
40039: LD_INT 10
40041: MUL
40042: PLUS
40043: PUSH
40044: LD_INT 11
40046: PLUS
40047: PPUSH
40048: CALL_OW 110
40052: PLUS
40053: PPUSH
40054: CALL_OW 110
40058: PPUSH
40059: LD_INT 0
40061: PPUSH
40062: LD_VAR 0 5
40066: PPUSH
40067: CALL_OW 468
// end ;
40071: LD_VAR 0 3
40075: RET
// export function Update_Artefact ( lab ) ; var art , side , base ; begin
40076: LD_INT 0
40078: PPUSH
40079: PPUSH
40080: PPUSH
40081: PPUSH
// side := GetSide ( lab ) ;
40082: LD_ADDR_VAR 0 4
40086: PUSH
40087: LD_VAR 0 1
40091: PPUSH
40092: CALL_OW 255
40096: ST_TO_ADDR
// for art = 1 to artefact_number do
40097: LD_ADDR_VAR 0 3
40101: PUSH
40102: DOUBLE
40103: LD_INT 1
40105: DEC
40106: ST_TO_ADDR
40107: LD_EXP 76
40111: PUSH
40112: FOR_TO
40113: IFFALSE 40269
// begin base := ( art - 1 ) * 100 ;
40115: LD_ADDR_VAR 0 5
40119: PUSH
40120: LD_VAR 0 3
40124: PUSH
40125: LD_INT 1
40127: MINUS
40128: PUSH
40129: LD_INT 100
40131: MUL
40132: ST_TO_ADDR
// if GetTag ( base + 11 ) = lab then
40133: LD_VAR 0 5
40137: PUSH
40138: LD_INT 11
40140: PLUS
40141: PPUSH
40142: CALL_OW 110
40146: PUSH
40147: LD_VAR 0 1
40151: EQUAL
40152: IFFALSE 40165
// Init_Lab ( art ) else
40154: LD_VAR 0 3
40158: PPUSH
40159: CALL 39243 0 1
40163: GO 40267
// begin if lab = GetTag ( base + side * 10 + 15 ) then
40165: LD_VAR 0 1
40169: PUSH
40170: LD_VAR 0 5
40174: PUSH
40175: LD_VAR 0 4
40179: PUSH
40180: LD_INT 10
40182: MUL
40183: PLUS
40184: PUSH
40185: LD_INT 15
40187: PLUS
40188: PPUSH
40189: CALL_OW 110
40193: EQUAL
40194: IFFALSE 40267
// begin if ( GetTag ( base + side * 10 + 13 ) > 0 ) or ( not UnitsInside ( lab ) ) then
40196: LD_VAR 0 5
40200: PUSH
40201: LD_VAR 0 4
40205: PUSH
40206: LD_INT 10
40208: MUL
40209: PLUS
40210: PUSH
40211: LD_INT 13
40213: PLUS
40214: PPUSH
40215: CALL_OW 110
40219: PUSH
40220: LD_INT 0
40222: GREATER
40223: PUSH
40224: LD_VAR 0 1
40228: PPUSH
40229: CALL_OW 313
40233: NOT
40234: OR
40235: IFFALSE 40253
// Shadow_Artefact ( side , art ) else
40237: LD_VAR 0 4
40241: PPUSH
40242: LD_VAR 0 3
40246: PPUSH
40247: CALL 38957 0 2
40251: GO 40267
// Highlight_Artefact ( side , art ) ;
40253: LD_VAR 0 4
40257: PPUSH
40258: LD_VAR 0 3
40262: PPUSH
40263: CALL 39089 0 2
// end ; end ; end ;
40267: GO 40112
40269: POP
40270: POP
// end ;
40271: LD_VAR 0 2
40275: RET
// every 0 0$2 marked 20 do var list , lab ;
40276: GO 40278
40278: DISABLE
40279: LD_INT 0
40281: PPUSH
40282: PPUSH
// begin list := FilterAllUnits ( [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_alien_tower ] ] ] ) ;
40283: LD_ADDR_VAR 0 1
40287: PUSH
40288: LD_INT 2
40290: PUSH
40291: LD_INT 30
40293: PUSH
40294: LD_INT 6
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 30
40303: PUSH
40304: LD_INT 7
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 30
40313: PUSH
40314: LD_INT 8
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 39
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: PUSH
40338: EMPTY
40339: LIST
40340: PPUSH
40341: CALL_OW 69
40345: ST_TO_ADDR
// for lab in list do
40346: LD_ADDR_VAR 0 2
40350: PUSH
40351: LD_VAR 0 1
40355: PUSH
40356: FOR_IN
40357: IFFALSE 40370
// Update_Artefact ( lab ) ;
40359: LD_VAR 0 2
40363: PPUSH
40364: CALL 40076 0 1
40368: GO 40356
40370: POP
40371: POP
// enable ;
40372: ENABLE
// end ; end_of_file
40373: PPOPN 2
40375: END
// var view_data , human_changed ; export function Show_me_map ( side , x , y ) ; var vysledek , station ; begin
40376: LD_INT 0
40378: PPUSH
40379: PPUSH
40380: PPUSH
// vysledek := true ;
40381: LD_ADDR_VAR 0 5
40385: PUSH
40386: LD_INT 1
40388: ST_TO_ADDR
// station := GetBase ( GetTag ( side * 10 + 15 ) ) ;
40389: LD_ADDR_VAR 0 6
40393: PUSH
40394: LD_VAR 0 1
40398: PUSH
40399: LD_INT 10
40401: MUL
40402: PUSH
40403: LD_INT 15
40405: PLUS
40406: PPUSH
40407: CALL_OW 110
40411: PPUSH
40412: CALL_OW 274
40416: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 06 ) ) then
40417: LD_VAR 0 6
40421: PUSH
40422: LD_VAR 0 6
40426: PPUSH
40427: CALL_OW 279
40431: PUSH
40432: LD_INT 3
40434: ARRAY
40435: PUSH
40436: LD_INT 6
40438: PPUSH
40439: CALL_OW 110
40443: GREATEREQUAL
40444: AND
40445: IFFALSE 40535
// begin PlaceSeeing ( x , y , side , - 15 ) ;
40447: LD_VAR 0 2
40451: PPUSH
40452: LD_VAR 0 3
40456: PPUSH
40457: LD_VAR 0 1
40461: PPUSH
40462: LD_INT 15
40464: NEG
40465: PPUSH
40466: CALL_OW 330
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 06 ) ) ;
40470: LD_VAR 0 6
40474: PPUSH
40475: LD_INT 3
40477: PPUSH
40478: LD_VAR 0 6
40482: PPUSH
40483: CALL_OW 279
40487: PUSH
40488: LD_INT 3
40490: ARRAY
40491: PUSH
40492: LD_INT 6
40494: PPUSH
40495: CALL_OW 110
40499: MINUS
40500: PPUSH
40501: CALL_OW 277
// view_data := [ x , y , side ] ;
40505: LD_ADDR_LOC 81
40509: PUSH
40510: LD_VAR 0 2
40514: PUSH
40515: LD_VAR 0 3
40519: PUSH
40520: LD_VAR 0 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: LIST
40529: ST_TO_ADDR
// enable ( 111 ) ;
40530: LD_INT 111
40532: ENABLE_MARKED
// end else
40533: GO 40543
// vysledek := false ;
40535: LD_ADDR_VAR 0 5
40539: PUSH
40540: LD_INT 0
40542: ST_TO_ADDR
// result := vysledek ;
40543: LD_ADDR_VAR 0 4
40547: PUSH
40548: LD_VAR 0 5
40552: ST_TO_ADDR
// end ;
40553: LD_VAR 0 4
40557: RET
// every 0 0$2.8 trigger view_data marked 111 do
40558: LD_LOC 81
40562: IFFALSE 40613
40564: GO 40566
40566: DISABLE
// begin wait ( 0 0$30 ) ;
40567: LD_INT 1050
40569: PPUSH
40570: CALL_OW 67
// RemoveSeeing ( view_data [ 1 ] , view_data [ 2 ] , view_data [ 3 ] ) ;
40574: LD_LOC 81
40578: PUSH
40579: LD_INT 1
40581: ARRAY
40582: PPUSH
40583: LD_LOC 81
40587: PUSH
40588: LD_INT 2
40590: ARRAY
40591: PPUSH
40592: LD_LOC 81
40596: PUSH
40597: LD_INT 3
40599: ARRAY
40600: PPUSH
40601: CALL_OW 331
// view_data := 0 ;
40605: LD_ADDR_LOC 81
40609: PUSH
40610: LD_INT 0
40612: ST_TO_ADDR
// end ;
40613: END
// export function Destroy_siberite ( side , un ) ; var vysledek , station , v_can , b_can , it_can , building_list , vehicle_list ; begin
40614: LD_INT 0
40616: PPUSH
40617: PPUSH
40618: PPUSH
40619: PPUSH
40620: PPUSH
40621: PPUSH
40622: PPUSH
40623: PPUSH
// vysledek := true ;
40624: LD_ADDR_VAR 0 4
40628: PUSH
40629: LD_INT 1
40631: ST_TO_ADDR
// it_can := false ;
40632: LD_ADDR_VAR 0 8
40636: PUSH
40637: LD_INT 0
40639: ST_TO_ADDR
// building_list := [ b_siberite_mine , b_siberite_power ] ;
40640: LD_ADDR_VAR 0 9
40644: PUSH
40645: LD_INT 30
40647: PUSH
40648: LD_INT 28
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: ST_TO_ADDR
// vehicle_list := [ us_siberium_rocket , ru_siberium_rocket , ar_selfpropelled_bomb , ru_time_lapser , us_double_laser ] ;
40655: LD_ADDR_VAR 0 10
40659: PUSH
40660: LD_INT 8
40662: PUSH
40663: LD_INT 48
40665: PUSH
40666: LD_INT 29
40668: PUSH
40669: LD_INT 49
40671: PUSH
40672: LD_INT 10
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: ST_TO_ADDR
// b_can := ( GetType ( un ) = unit_building ) and ( ( GetBType ( un ) in building_list ) or ( GetBWeapon ( un ) in vehicle_list ) ) ;
40682: LD_ADDR_VAR 0 7
40686: PUSH
40687: LD_VAR 0 2
40691: PPUSH
40692: CALL_OW 247
40696: PUSH
40697: LD_INT 3
40699: EQUAL
40700: PUSH
40701: LD_VAR 0 2
40705: PPUSH
40706: CALL_OW 266
40710: PUSH
40711: LD_VAR 0 9
40715: IN
40716: PUSH
40717: LD_VAR 0 2
40721: PPUSH
40722: CALL_OW 269
40726: PUSH
40727: LD_VAR 0 10
40731: IN
40732: OR
40733: AND
40734: ST_TO_ADDR
// v_can := ( GetType ( un ) = unit_vehicle ) and ( ( GetWeapon ( un ) in vehicle_list ) or ( GetEngine ( un ) = engine_siberite ) ) ;
40735: LD_ADDR_VAR 0 6
40739: PUSH
40740: LD_VAR 0 2
40744: PPUSH
40745: CALL_OW 247
40749: PUSH
40750: LD_INT 2
40752: EQUAL
40753: PUSH
40754: LD_VAR 0 2
40758: PPUSH
40759: CALL_OW 264
40763: PUSH
40764: LD_VAR 0 10
40768: IN
40769: PUSH
40770: LD_VAR 0 2
40774: PPUSH
40775: CALL_OW 262
40779: PUSH
40780: LD_INT 3
40782: EQUAL
40783: OR
40784: AND
40785: ST_TO_ADDR
// it_can := b_can or v_can ;
40786: LD_ADDR_VAR 0 8
40790: PUSH
40791: LD_VAR 0 7
40795: PUSH
40796: LD_VAR 0 6
40800: OR
40801: ST_TO_ADDR
// station := GetBase ( GetTag ( 100 + side * 10 + 15 ) ) ;
40802: LD_ADDR_VAR 0 5
40806: PUSH
40807: LD_INT 100
40809: PUSH
40810: LD_VAR 0 1
40814: PUSH
40815: LD_INT 10
40817: MUL
40818: PLUS
40819: PUSH
40820: LD_INT 15
40822: PLUS
40823: PPUSH
40824: CALL_OW 110
40828: PPUSH
40829: CALL_OW 274
40833: ST_TO_ADDR
// if station and it_can and ( GetResources ( station ) [ 3 ] >= GetTag ( 106 ) ) then
40834: LD_VAR 0 5
40838: PUSH
40839: LD_VAR 0 8
40843: AND
40844: PUSH
40845: LD_VAR 0 5
40849: PPUSH
40850: CALL_OW 279
40854: PUSH
40855: LD_INT 3
40857: ARRAY
40858: PUSH
40859: LD_INT 106
40861: PPUSH
40862: CALL_OW 110
40866: GREATEREQUAL
40867: AND
40868: IFFALSE 40916
// begin KillUnit ( un ) ;
40870: LD_VAR 0 2
40874: PPUSH
40875: CALL_OW 66
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 106 ) ) ;
40879: LD_VAR 0 5
40883: PPUSH
40884: LD_INT 3
40886: PPUSH
40887: LD_VAR 0 5
40891: PPUSH
40892: CALL_OW 279
40896: PUSH
40897: LD_INT 3
40899: ARRAY
40900: PUSH
40901: LD_INT 106
40903: PPUSH
40904: CALL_OW 110
40908: MINUS
40909: PPUSH
40910: CALL_OW 277
// end else
40914: GO 40924
// vysledek := false ;
40916: LD_ADDR_VAR 0 4
40920: PUSH
40921: LD_INT 0
40923: ST_TO_ADDR
// result := vysledek ;
40924: LD_ADDR_VAR 0 3
40928: PUSH
40929: LD_VAR 0 4
40933: ST_TO_ADDR
// end ;
40934: LD_VAR 0 3
40938: RET
// export function Mass_Teleport ( side , x , y ) ; var vysledek , station , list , un ; begin
40939: LD_INT 0
40941: PPUSH
40942: PPUSH
40943: PPUSH
40944: PPUSH
40945: PPUSH
// vysledek := true ;
40946: LD_ADDR_VAR 0 5
40950: PUSH
40951: LD_INT 1
40953: ST_TO_ADDR
// station := GetBase ( GetTag ( 200 + side * 10 + 15 ) ) ;
40954: LD_ADDR_VAR 0 6
40958: PUSH
40959: LD_INT 200
40961: PUSH
40962: LD_VAR 0 1
40966: PUSH
40967: LD_INT 10
40969: MUL
40970: PLUS
40971: PUSH
40972: LD_INT 15
40974: PLUS
40975: PPUSH
40976: CALL_OW 110
40980: PPUSH
40981: CALL_OW 274
40985: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 206 ) ) then
40986: LD_VAR 0 6
40990: PUSH
40991: LD_VAR 0 6
40995: PPUSH
40996: CALL_OW 279
41000: PUSH
41001: LD_INT 3
41003: ARRAY
41004: PUSH
41005: LD_INT 206
41007: PPUSH
41008: CALL_OW 110
41012: GREATEREQUAL
41013: AND
41014: IFFALSE 41197
// begin SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 206 ) ) ;
41016: LD_VAR 0 6
41020: PPUSH
41021: LD_INT 3
41023: PPUSH
41024: LD_VAR 0 6
41028: PPUSH
41029: CALL_OW 279
41033: PUSH
41034: LD_INT 3
41036: ARRAY
41037: PUSH
41038: LD_INT 206
41040: PPUSH
41041: CALL_OW 110
41045: MINUS
41046: PPUSH
41047: CALL_OW 277
// SetAreaMapShow ( teleport_area , 1 ) ;
41051: LD_INT 24
41053: PPUSH
41054: LD_INT 1
41056: PPUSH
41057: CALL_OW 424
// for un = 1 to 11 do
41061: LD_ADDR_VAR 0 8
41065: PUSH
41066: DOUBLE
41067: LD_INT 1
41069: DEC
41070: ST_TO_ADDR
41071: LD_INT 11
41073: PUSH
41074: FOR_TO
41075: IFFALSE 41103
// begin display_strings := [ ( 11 - un ) ] ;
41077: LD_ADDR_OWVAR 47
41081: PUSH
41082: LD_INT 11
41084: PUSH
41085: LD_VAR 0 8
41089: MINUS
41090: PUSH
41091: EMPTY
41092: LIST
41093: ST_TO_ADDR
// wait ( 0 0$1 ) ;
41094: LD_INT 35
41096: PPUSH
41097: CALL_OW 67
// end ;
41101: GO 41074
41103: POP
41104: POP
// display_strings :=  ;
41105: LD_ADDR_OWVAR 47
41109: PUSH
41110: LD_STRING 
41112: ST_TO_ADDR
// SetAreaMapShow ( teleport_area , 0 ) ;
41113: LD_INT 24
41115: PPUSH
41116: LD_INT 0
41118: PPUSH
41119: CALL_OW 424
// list := FilterUnitsInArea ( teleport_area , [ f_not , [ f_type , unit_building ] ] ) ;
41123: LD_ADDR_VAR 0 7
41127: PUSH
41128: LD_INT 24
41130: PPUSH
41131: LD_INT 3
41133: PUSH
41134: LD_INT 21
41136: PUSH
41137: LD_INT 3
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PPUSH
41148: CALL_OW 70
41152: ST_TO_ADDR
// for un in list do
41153: LD_ADDR_VAR 0 8
41157: PUSH
41158: LD_VAR 0 7
41162: PUSH
41163: FOR_IN
41164: IFFALSE 41193
// TeleportUnit ( un , x , y , 12 , true ) ;
41166: LD_VAR 0 8
41170: PPUSH
41171: LD_VAR 0 2
41175: PPUSH
41176: LD_VAR 0 3
41180: PPUSH
41181: LD_INT 12
41183: PPUSH
41184: LD_INT 1
41186: PPUSH
41187: CALL_OW 483
41191: GO 41163
41193: POP
41194: POP
// end else
41195: GO 41205
// vysledek := false ;
41197: LD_ADDR_VAR 0 5
41201: PUSH
41202: LD_INT 0
41204: ST_TO_ADDR
// result := vysledek ;
41205: LD_ADDR_VAR 0 4
41209: PUSH
41210: LD_VAR 0 5
41214: ST_TO_ADDR
// end ;
41215: LD_VAR 0 4
41219: RET
// every 0 0$5 marked 20 do var art , side , recharge ;
41220: GO 41222
41222: DISABLE
41223: LD_INT 0
41225: PPUSH
41226: PPUSH
41227: PPUSH
// begin side := you ;
41228: LD_ADDR_VAR 0 2
41232: PUSH
41233: LD_EXP 1
41237: ST_TO_ADDR
// for art = 0 to artefact_number do
41238: LD_ADDR_VAR 0 1
41242: PUSH
41243: DOUBLE
41244: LD_INT 0
41246: DEC
41247: ST_TO_ADDR
41248: LD_EXP 76
41252: PUSH
41253: FOR_TO
41254: IFFALSE 41354
// begin recharge := art * 100 + side * 10 + 13 ;
41256: LD_ADDR_VAR 0 3
41260: PUSH
41261: LD_VAR 0 1
41265: PUSH
41266: LD_INT 100
41268: MUL
41269: PUSH
41270: LD_VAR 0 2
41274: PUSH
41275: LD_INT 10
41277: MUL
41278: PLUS
41279: PUSH
41280: LD_INT 13
41282: PLUS
41283: ST_TO_ADDR
// if GetTag ( recharge ) > 0 then
41284: LD_VAR 0 3
41288: PPUSH
41289: CALL_OW 110
41293: PUSH
41294: LD_INT 0
41296: GREATER
41297: IFFALSE 41352
// begin SetTag ( recharge , GetTag ( recharge ) - 1 ) ;
41299: LD_VAR 0 3
41303: PPUSH
41304: LD_VAR 0 3
41308: PPUSH
41309: CALL_OW 110
41313: PUSH
41314: LD_INT 1
41316: MINUS
41317: PPUSH
41318: CALL_OW 109
// if not GetTag ( recharge ) then
41322: LD_VAR 0 3
41326: PPUSH
41327: CALL_OW 110
41331: NOT
41332: IFFALSE 41352
// Highlight_Artefact ( side , art + 1 ) ;
41334: LD_VAR 0 2
41338: PPUSH
41339: LD_VAR 0 1
41343: PUSH
41344: LD_INT 1
41346: PLUS
41347: PPUSH
41348: CALL 39089 0 2
// end ; end ;
41352: GO 41253
41354: POP
41355: POP
// enable ;
41356: ENABLE
// end ; end_of_file
41357: PPOPN 3
41359: END
// var us_fort , ru_fort ; var us_place , ru_place ; every 0 0$11 do var side , un , list ;
41360: GO 41362
41362: DISABLE
41363: LD_INT 0
41365: PPUSH
41366: PPUSH
41367: PPUSH
// begin us_fort := [ ] ;
41368: LD_ADDR_LOC 83
41372: PUSH
41373: EMPTY
41374: ST_TO_ADDR
// ru_fort := [ ] ;
41375: LD_ADDR_LOC 84
41379: PUSH
41380: EMPTY
41381: ST_TO_ADDR
// for side in ( cpu_list diff ar ) do
41382: LD_ADDR_VAR 0 1
41386: PUSH
41387: LD_EXP 8
41391: PUSH
41392: LD_EXP 4
41396: DIFF
41397: PUSH
41398: FOR_IN
41399: IFFALSE 41604
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
41401: LD_ADDR_VAR 0 3
41405: PUSH
41406: LD_INT 22
41408: PUSH
41409: LD_VAR 0 1
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 2
41420: PUSH
41421: LD_INT 30
41423: PUSH
41424: LD_INT 32
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 30
41433: PUSH
41434: LD_INT 33
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: LIST
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PPUSH
41450: CALL_OW 69
41454: ST_TO_ADDR
// for un in list do
41455: LD_ADDR_VAR 0 2
41459: PUSH
41460: LD_VAR 0 3
41464: PUSH
41465: FOR_IN
41466: IFFALSE 41600
// case side of us :
41468: LD_VAR 0 1
41472: PUSH
41473: LD_EXP 3
41477: DOUBLE
41478: EQUAL
41479: IFTRUE 41483
41481: GO 41535
41483: POP
// us_fort := us_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; ru :
41484: LD_ADDR_LOC 83
41488: PUSH
41489: LD_LOC 83
41493: PUSH
41494: LD_VAR 0 2
41498: PPUSH
41499: CALL_OW 250
41503: PUSH
41504: LD_VAR 0 2
41508: PPUSH
41509: CALL_OW 251
41513: PUSH
41514: LD_VAR 0 2
41518: PPUSH
41519: CALL_OW 269
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: LIST
41528: PUSH
41529: EMPTY
41530: LIST
41531: ADD
41532: ST_TO_ADDR
41533: GO 41598
41535: LD_EXP 2
41539: DOUBLE
41540: EQUAL
41541: IFTRUE 41545
41543: GO 41597
41545: POP
// ru_fort := ru_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; end ;
41546: LD_ADDR_LOC 84
41550: PUSH
41551: LD_LOC 84
41555: PUSH
41556: LD_VAR 0 2
41560: PPUSH
41561: CALL_OW 250
41565: PUSH
41566: LD_VAR 0 2
41570: PPUSH
41571: CALL_OW 251
41575: PUSH
41576: LD_VAR 0 2
41580: PPUSH
41581: CALL_OW 269
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: LIST
41590: PUSH
41591: EMPTY
41592: LIST
41593: ADD
41594: ST_TO_ADDR
41595: GO 41598
41597: POP
41598: GO 41465
41600: POP
41601: POP
// end ;
41602: GO 41398
41604: POP
41605: POP
// end ;
41606: PPOPN 3
41608: END
// every 0 0$10.5 do var un , w , x , y , list ;
41609: GO 41611
41611: DISABLE
41612: LD_INT 0
41614: PPUSH
41615: PPUSH
41616: PPUSH
41617: PPUSH
41618: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_heavy_gun ] , [ f_bweapon , us_radar ] , [ f_bweapon , us_double_laser ] ] ] ) ;
41619: LD_ADDR_VAR 0 5
41623: PUSH
41624: LD_INT 22
41626: PUSH
41627: LD_EXP 3
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 2
41638: PUSH
41639: LD_INT 30
41641: PUSH
41642: LD_INT 32
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 30
41651: PUSH
41652: LD_INT 33
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 57
41666: PUSH
41667: EMPTY
41668: LIST
41669: PUSH
41670: LD_INT 3
41672: PUSH
41673: LD_INT 2
41675: PUSH
41676: LD_INT 35
41678: PUSH
41679: LD_INT 7
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 35
41688: PUSH
41689: LD_INT 6
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 35
41698: PUSH
41699: LD_INT 11
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 35
41708: PUSH
41709: LD_INT 10
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: PPUSH
41730: CALL_OW 69
41734: ST_TO_ADDR
// for un in list do
41735: LD_ADDR_VAR 0 1
41739: PUSH
41740: LD_VAR 0 5
41744: PUSH
41745: FOR_IN
41746: IFFALSE 41861
// begin x := GetX ( un ) ;
41748: LD_ADDR_VAR 0 3
41752: PUSH
41753: LD_VAR 0 1
41757: PPUSH
41758: CALL_OW 250
41762: ST_TO_ADDR
// y := GetY ( un ) ;
41763: LD_ADDR_VAR 0 4
41767: PUSH
41768: LD_VAR 0 1
41772: PPUSH
41773: CALL_OW 251
41777: ST_TO_ADDR
// for w in us_fort do
41778: LD_ADDR_VAR 0 2
41782: PUSH
41783: LD_LOC 83
41787: PUSH
41788: FOR_IN
41789: IFFALSE 41850
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
41791: LD_VAR 0 3
41795: PUSH
41796: LD_VAR 0 2
41800: PUSH
41801: LD_INT 1
41803: ARRAY
41804: EQUAL
41805: PUSH
41806: LD_VAR 0 4
41810: PUSH
41811: LD_VAR 0 2
41815: PUSH
41816: LD_INT 2
41818: ARRAY
41819: EQUAL
41820: AND
41821: IFFALSE 41841
// ComPlaceWeapon ( un , w [ 3 ] ) ;
41823: LD_VAR 0 1
41827: PPUSH
41828: LD_VAR 0 2
41832: PUSH
41833: LD_INT 3
41835: ARRAY
41836: PPUSH
41837: CALL_OW 148
// wait ( 8 ) ;
41841: LD_INT 8
41843: PPUSH
41844: CALL_OW 67
// end ;
41848: GO 41788
41850: POP
41851: POP
// wait ( 27 ) ;
41852: LD_INT 27
41854: PPUSH
41855: CALL_OW 67
// end ;
41859: GO 41745
41861: POP
41862: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
41863: LD_INT 175
41865: PPUSH
41866: LD_INT 350
41868: PPUSH
41869: CALL_OW 12
41873: PPUSH
41874: CALL_OW 67
// enable ;
41878: ENABLE
// end ;
41879: PPOPN 5
41881: END
// every 0 0$10.7 do var un , w , x , y , list ;
41882: GO 41884
41884: DISABLE
41885: LD_INT 0
41887: PPUSH
41888: PPUSH
41889: PPUSH
41890: PPUSH
41891: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , ru_rocket ] , [ f_bweapon , ru_heavy_gun ] , [ f_bweapon , ru_time_lapser ] , [ f_bweapon , ru_gatling_gun ] ] ] ) ;
41892: LD_ADDR_VAR 0 5
41896: PUSH
41897: LD_INT 22
41899: PUSH
41900: LD_EXP 2
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: LD_INT 30
41914: PUSH
41915: LD_INT 32
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PUSH
41922: LD_INT 30
41924: PUSH
41925: LD_INT 33
41927: PUSH
41928: EMPTY
41929: LIST
41930: LIST
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 57
41939: PUSH
41940: EMPTY
41941: LIST
41942: PUSH
41943: LD_INT 3
41945: PUSH
41946: LD_INT 2
41948: PUSH
41949: LD_INT 35
41951: PUSH
41952: LD_INT 47
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 35
41961: PUSH
41962: LD_INT 46
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 35
41971: PUSH
41972: LD_INT 49
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 35
41981: PUSH
41982: LD_INT 43
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: PPUSH
42003: CALL_OW 69
42007: ST_TO_ADDR
// for un in list do
42008: LD_ADDR_VAR 0 1
42012: PUSH
42013: LD_VAR 0 5
42017: PUSH
42018: FOR_IN
42019: IFFALSE 42134
// begin x := GetX ( un ) ;
42021: LD_ADDR_VAR 0 3
42025: PUSH
42026: LD_VAR 0 1
42030: PPUSH
42031: CALL_OW 250
42035: ST_TO_ADDR
// y := GetY ( un ) ;
42036: LD_ADDR_VAR 0 4
42040: PUSH
42041: LD_VAR 0 1
42045: PPUSH
42046: CALL_OW 251
42050: ST_TO_ADDR
// for w in ru_fort do
42051: LD_ADDR_VAR 0 2
42055: PUSH
42056: LD_LOC 84
42060: PUSH
42061: FOR_IN
42062: IFFALSE 42123
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42064: LD_VAR 0 3
42068: PUSH
42069: LD_VAR 0 2
42073: PUSH
42074: LD_INT 1
42076: ARRAY
42077: EQUAL
42078: PUSH
42079: LD_VAR 0 4
42083: PUSH
42084: LD_VAR 0 2
42088: PUSH
42089: LD_INT 2
42091: ARRAY
42092: EQUAL
42093: AND
42094: IFFALSE 42114
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42096: LD_VAR 0 1
42100: PPUSH
42101: LD_VAR 0 2
42105: PUSH
42106: LD_INT 3
42108: ARRAY
42109: PPUSH
42110: CALL_OW 148
// wait ( 8 ) ;
42114: LD_INT 8
42116: PPUSH
42117: CALL_OW 67
// end ;
42121: GO 42061
42123: POP
42124: POP
// wait ( 27 ) ;
42125: LD_INT 27
42127: PPUSH
42128: CALL_OW 67
// end ;
42132: GO 42018
42134: POP
42135: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42136: LD_INT 175
42138: PPUSH
42139: LD_INT 350
42141: PPUSH
42142: CALL_OW 12
42146: PPUSH
42147: CALL_OW 67
// enable ;
42151: ENABLE
// end ; end_of_file
42152: PPOPN 5
42154: END
// every 0 0$2 + 0 0$0.1 do
42155: GO 42157
42157: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
42158: LD_INT 22
42160: PUSH
42161: LD_INT 7
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 2
42170: PUSH
42171: LD_INT 25
42173: PUSH
42174: LD_INT 12
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 25
42183: PUSH
42184: LD_INT 16
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 25
42193: PUSH
42194: LD_INT 15
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 25
42203: PUSH
42204: LD_INT 17
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PPUSH
42222: CALL_OW 69
42226: PUSH
42227: LD_INT 22
42229: PUSH
42230: LD_INT 7
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 21
42239: PUSH
42240: LD_INT 1
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 3
42249: PUSH
42250: LD_INT 2
42252: PUSH
42253: LD_INT 25
42255: PUSH
42256: LD_INT 12
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 25
42265: PUSH
42266: LD_INT 16
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 25
42275: PUSH
42276: LD_INT 15
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 25
42285: PUSH
42286: LD_INT 17
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: LIST
42308: PPUSH
42309: CALL_OW 69
42313: GREATER
42314: IFFALSE 42325
// begin SetAchievement ( ACH_POTA ) ;
42316: LD_STRING ACH_POTA
42318: PPUSH
42319: CALL_OW 543
// exit ;
42323: GO 42326
// end ; enable ;
42325: ENABLE
// end ;
42326: END
// export function SA_OnMissionComplete ; begin
42327: LD_INT 0
42329: PPUSH
// SetAchievement ( ACH_GBA ) ;
42330: LD_STRING ACH_GBA
42332: PPUSH
42333: CALL_OW 543
// end ;
42337: LD_VAR 0 1
42341: RET

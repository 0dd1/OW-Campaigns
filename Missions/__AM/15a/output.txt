// export you , ru , us , ar , ar_al , neutral , camp ; export cpu_list ; export ru_nation , us_nation , ar_nation ; export Burlak , MacMillan , Roth , Gossudarov ; export Petrosyan , Belkov , Kirilenkova , Gnyevko , Gladkov , Dolgov , Gleb , Kapitsova , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Bystrov , Lipshchin , Fadeev ; export Bobby , Brown , Cornell , Connie , Cyrus , Denis , Donaldson , Frank , Gary , Gladstone , Joan , Lisa , Peterson , Simms , VanHouten , Yamoko ; export Omar , OmarKilled , NegotiationOffered , OmarWillTryContaminateMotherlode ; export Powell , Platonov ; export aliance_forces ; export finalize ; export prefered_control ; export siberite_rocket_send ; function prepare_us_units ; begin
   0: LD_INT 0
   2: PPUSH
// Powell := NewCharacter ( Powell ) ;
   3: LD_ADDR_EXP 55
   7: PUSH
   8: LD_STRING Powell
  10: PPUSH
  11: CALL_OW 25
  15: ST_TO_ADDR
// SetSide ( Powell , us ) ;
  16: LD_EXP 55
  20: PPUSH
  21: LD_EXP 3
  25: PPUSH
  26: CALL_OW 235
// end ;
  30: LD_VAR 0 1
  34: RET
// function prepare_ru_units ; begin
  35: LD_INT 0
  37: PPUSH
// Platonov := NewCharacter ( Platonov ) ;
  38: LD_ADDR_EXP 56
  42: PUSH
  43: LD_STRING Platonov
  45: PPUSH
  46: CALL_OW 25
  50: ST_TO_ADDR
// SetSide ( Platonov , ru ) ;
  51: LD_EXP 56
  55: PPUSH
  56: LD_EXP 2
  60: PPUSH
  61: CALL_OW 235
// end ;
  65: LD_VAR 0 1
  69: RET
// function prepare_ar_units ; begin
  70: LD_INT 0
  72: PPUSH
// OmarWillTryContaminateMotherlode = false ;
  73: LD_ADDR_EXP 54
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// if difficulty >= 2 then
  81: LD_OWVAR 67
  85: PUSH
  86: LD_INT 2
  88: GREATEREQUAL
  89: IFFALSE 106
// SetTech ( tech_stimdrugs , ar_al , state_researched ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_EXP 5
  98: PPUSH
  99: LD_INT 2
 101: PPUSH
 102: CALL_OW 322
// if camp = 6 then
 106: LD_EXP 7
 110: PUSH
 111: LD_INT 6
 113: EQUAL
 114: IFFALSE 134
// OmarKilled := LoadVariable ( OmarKilled , true ) else
 116: LD_ADDR_EXP 52
 120: PUSH
 121: LD_STRING OmarKilled
 123: PPUSH
 124: LD_INT 1
 126: PPUSH
 127: CALL_OW 30
 131: ST_TO_ADDR
 132: GO 142
// OmarKilled = false ;
 134: LD_ADDR_EXP 52
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// if OmarKilled then
 142: LD_EXP 52
 146: IFFALSE 158
// begin Omar = 0 ;
 148: LD_ADDR_EXP 51
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// exit ;
 156: GO 244
// end ; if TestCharacters ( Omar ) then
 158: LD_STRING Omar
 160: PPUSH
 161: CALL_OW 28
 165: IFFALSE 182
// Omar := CreateCharacter ( Omar ) else
 167: LD_ADDR_EXP 51
 171: PUSH
 172: LD_STRING Omar
 174: PPUSH
 175: CALL_OW 34
 179: ST_TO_ADDR
 180: GO 195
// Omar = NewCharacter ( Omar ) ;
 182: LD_ADDR_EXP 51
 186: PUSH
 187: LD_STRING Omar
 189: PPUSH
 190: CALL_OW 25
 194: ST_TO_ADDR
// SetSide ( Omar , ar_al ) ;
 195: LD_EXP 51
 199: PPUSH
 200: LD_EXP 5
 204: PPUSH
 205: CALL_OW 235
// NegotiationOffered := LoadVariable ( NegotiationsOffered , false ) ;
 209: LD_ADDR_EXP 53
 213: PUSH
 214: LD_STRING NegotiationsOffered
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// if NegotiationOffered then
 225: LD_EXP 53
 229: IFFALSE 236
// enable ( 2 ) else
 231: LD_INT 2
 233: ENABLE_MARKED
 234: GO 244
// OmarWillTryContaminateMotherlode = true ;
 236: LD_ADDR_EXP 54
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// end ;
 244: LD_VAR 0 1
 248: RET
// function prepare_al_units ; var un , count , i , nations , art_loaded , selected , aliance , pom_list , veh_cargo , veh_basic , veh_battle , vehicles , veh_list , JMM_car , Bur_car ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
// nations := [ nation_american , nation_russian ] ;
 267: LD_ADDR_VAR 0 5
 271: PUSH
 272: LD_INT 1
 274: PUSH
 275: LD_INT 3
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: ST_TO_ADDR
// uc_side := you ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_EXP 1
 291: ST_TO_ADDR
// aliance_forces := [ ] ;
 292: LD_ADDR_EXP 57
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// load_all_aliance ;
 299: CALL 2772 0 0
// aliance := [ ] ;
 303: LD_ADDR_VAR 0 8
 307: PUSH
 308: EMPTY
 309: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 310: LD_ADDR_EXP 12
 314: PUSH
 315: LD_STRING Burlak
 317: PPUSH
 318: CALL_OW 34
 322: ST_TO_ADDR
// aliance := aliance ^ Burlak ;
 323: LD_ADDR_VAR 0 8
 327: PUSH
 328: LD_VAR 0 8
 332: PUSH
 333: LD_EXP 12
 337: ADD
 338: ST_TO_ADDR
// if TestCharacters ( JMM ) and CheckCharacterSet ( JMM ) then
 339: LD_STRING JMM
 341: PPUSH
 342: CALL_OW 28
 346: PUSH
 347: LD_STRING JMM
 349: PPUSH
 350: CALL_OW 29
 354: AND
 355: IFFALSE 398
// begin MacMillan := CreateCharacter ( JMM ) ;
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING JMM
 364: PPUSH
 365: CALL_OW 34
 369: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
 370: LD_EXP 13
 374: PPUSH
 375: LD_INT 2
 377: PPUSH
 378: CALL_OW 336
// aliance := aliance ^ MacMillan ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_VAR 0 8
 391: PUSH
 392: LD_EXP 13
 396: ADD
 397: ST_TO_ADDR
// end ; if TestCharacters ( Roth ) and CheckCharacterSet ( Roth ) then
 398: LD_STRING Roth
 400: PPUSH
 401: CALL_OW 28
 405: PUSH
 406: LD_STRING Roth
 408: PPUSH
 409: CALL_OW 29
 413: AND
 414: IFFALSE 457
// begin Roth := CreateCharacter ( Roth ) ;
 416: LD_ADDR_EXP 14
 420: PUSH
 421: LD_STRING Roth
 423: PPUSH
 424: CALL_OW 34
 428: ST_TO_ADDR
// SetClass ( Roth , class_scientistic ) ;
 429: LD_EXP 14
 433: PPUSH
 434: LD_INT 4
 436: PPUSH
 437: CALL_OW 336
// aliance := aliance ^ Roth ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_VAR 0 8
 450: PUSH
 451: LD_EXP 14
 455: ADD
 456: ST_TO_ADDR
// end ; if TestCharacters ( Gossudarov ) and CheckCharacterSet ( Gossudarov ) then
 457: LD_STRING Gossudarov
 459: PPUSH
 460: CALL_OW 28
 464: PUSH
 465: LD_STRING Gossudarov
 467: PPUSH
 468: CALL_OW 29
 472: AND
 473: IFFALSE 516
// begin Gossudarov := CreateCharacter ( Gossudarov ) ;
 475: LD_ADDR_EXP 15
 479: PUSH
 480: LD_STRING Gossudarov
 482: PPUSH
 483: CALL_OW 34
 487: ST_TO_ADDR
// SetClass ( Gossudarov , class_scientistic ) ;
 488: LD_EXP 15
 492: PPUSH
 493: LD_INT 4
 495: PPUSH
 496: CALL_OW 336
// aliance := aliance ^ Gossudarov ;
 500: LD_ADDR_VAR 0 8
 504: PUSH
 505: LD_VAR 0 8
 509: PUSH
 510: LD_EXP 15
 514: ADD
 515: ST_TO_ADDR
// end ; if aliance < 20 then
 516: LD_VAR 0 8
 520: PUSH
 521: LD_INT 20
 523: LESS
 524: IFFALSE 585
// for i = aliance to 20 do
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: DOUBLE
 532: LD_VAR 0 8
 536: DEC
 537: ST_TO_ADDR
 538: LD_INT 20
 540: PUSH
 541: FOR_TO
 542: IFFALSE 583
// begin PrepareHuman ( 0 , 0 , 6 ) ;
 544: LD_INT 0
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: CALL_OW 380
// hc_last_mission := 15 ;
 557: LD_ADDR_OWVAR 36
 561: PUSH
 562: LD_INT 15
 564: ST_TO_ADDR
// aliance_forces := aliance_forces ^ CreateHuman ;
 565: LD_ADDR_EXP 57
 569: PUSH
 570: LD_EXP 57
 574: PUSH
 575: CALL_OW 44
 579: ADD
 580: ST_TO_ADDR
// end ;
 581: GO 541
 583: POP
 584: POP
// selected := CharacterSelection (  , 12 - aliance , 12 - aliance , aliance ^ [ sel_not_hired , sel_changeable , sel_change_class ] ^ aliance_forces , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
 585: LD_ADDR_VAR 0 7
 589: PUSH
 590: LD_STRING 
 592: PPUSH
 593: LD_INT 12
 595: PUSH
 596: LD_VAR 0 8
 600: MINUS
 601: PPUSH
 602: LD_INT 12
 604: PUSH
 605: LD_VAR 0 8
 609: MINUS
 610: PPUSH
 611: LD_VAR 0 8
 615: PUSH
 616: LD_INT -2
 618: PUSH
 619: LD_INT -3
 621: PUSH
 622: LD_INT -5
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: ADD
 630: PUSH
 631: LD_EXP 57
 635: ADD
 636: PPUSH
 637: LD_INT 1
 639: PUSH
 640: LD_INT 2
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL_OW 42
 659: ST_TO_ADDR
// aliance_forces := aliance ^ selected ;
 660: LD_ADDR_EXP 57
 664: PUSH
 665: LD_VAR 0 8
 669: PUSH
 670: LD_VAR 0 7
 674: ADD
 675: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 676: LD_ADDR_VAR 0 15
 680: PUSH
 681: LD_STRING JMM_car
 683: PPUSH
 684: LD_INT 3
 686: PUSH
 687: LD_INT 1
 689: PUSH
 690: LD_INT 1
 692: PUSH
 693: LD_INT 12
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PPUSH
 702: CALL_OW 30
 706: ST_TO_ADDR
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 707: LD_ADDR_VAR 0 16
 711: PUSH
 712: LD_STRING Bur_car
 714: PPUSH
 715: LD_INT 22
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 1
 723: PUSH
 724: LD_INT 45
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PPUSH
 733: CALL_OW 30
 737: ST_TO_ADDR
// if ( JMM_car [ 1 ] = 0 ) then
 738: LD_VAR 0 15
 742: PUSH
 743: LD_INT 1
 745: ARRAY
 746: PUSH
 747: LD_INT 0
 749: EQUAL
 750: IFFALSE 775
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 752: LD_ADDR_VAR 0 15
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 1
 762: PUSH
 763: LD_INT 1
 765: PUSH
 766: LD_INT 12
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: ST_TO_ADDR
// if ( Bur_car [ 1 ] = 0 ) then
 775: LD_VAR 0 16
 779: PUSH
 780: LD_INT 1
 782: ARRAY
 783: PUSH
 784: LD_INT 0
 786: EQUAL
 787: IFFALSE 812
// Bur_car := [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ;
 789: LD_ADDR_VAR 0 16
 793: PUSH
 794: LD_INT 22
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: LD_INT 1
 802: PUSH
 803: LD_INT 45
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: ST_TO_ADDR
// if not ( ( JMM_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) or ( Bur_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) ) then
 812: LD_VAR 0 15
 816: PUSH
 817: LD_INT 4
 819: ARRAY
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 51
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: IN
 831: PUSH
 832: LD_VAR 0 16
 836: PUSH
 837: LD_INT 4
 839: ARRAY
 840: PUSH
 841: LD_INT 12
 843: PUSH
 844: LD_INT 51
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: IN
 851: OR
 852: NOT
 853: IFFALSE 878
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 855: LD_ADDR_VAR 0 15
 859: PUSH
 860: LD_INT 3
 862: PUSH
 863: LD_INT 1
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 12
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: LIST
 877: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 878: LD_VAR 0 15
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PUSH
 887: LD_INT 1
 889: PUSH
 890: LD_INT 2
 892: PUSH
 893: LD_INT 3
 895: PUSH
 896: LD_INT 4
 898: PUSH
 899: LD_INT 5
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: IN
 909: IFFALSE 921
// uc_nation := nation_american else
 911: LD_ADDR_OWVAR 21
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
 919: GO 929
// uc_nation := nation_russian ;
 921: LD_ADDR_OWVAR 21
 925: PUSH
 926: LD_INT 3
 928: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
 929: LD_ADDR_OWVAR 24
 933: PUSH
 934: LD_INT 2
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: CALL_OW 12
 944: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 945: LD_ADDR_OWVAR 37
 949: PUSH
 950: LD_VAR 0 15
 954: PUSH
 955: LD_INT 1
 957: ARRAY
 958: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 959: LD_ADDR_OWVAR 39
 963: PUSH
 964: LD_VAR 0 15
 968: PUSH
 969: LD_INT 2
 971: ARRAY
 972: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 973: LD_ADDR_OWVAR 38
 977: PUSH
 978: LD_VAR 0 15
 982: PUSH
 983: LD_INT 3
 985: ARRAY
 986: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 987: LD_ADDR_OWVAR 40
 991: PUSH
 992: LD_VAR 0 15
 996: PUSH
 997: LD_INT 4
 999: ARRAY
1000: ST_TO_ADDR
// un := CreateVehicle ;
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: CALL_OW 45
1010: ST_TO_ADDR
// art_loaded := false ;
1011: LD_ADDR_VAR 0 6
1015: PUSH
1016: LD_INT 0
1018: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , un ) ;
1019: LD_EXP 13
1023: PPUSH
1024: LD_VAR 0 2
1028: PPUSH
1029: CALL_OW 52
// PlaceUnitArea ( un , jmm_starting , false ) ;
1033: LD_VAR 0 2
1037: PPUSH
1038: LD_INT 27
1040: PPUSH
1041: LD_INT 0
1043: PPUSH
1044: CALL_OW 49
// if GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] then
1048: LD_VAR 0 2
1052: PPUSH
1053: CALL_OW 264
1057: PUSH
1058: LD_INT 12
1060: PUSH
1061: LD_INT 51
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: IN
1068: IFFALSE 1093
// begin SetCargo ( un , mat_artefact , 50 ) ;
1070: LD_VAR 0 2
1074: PPUSH
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 50
1080: PPUSH
1081: CALL_OW 290
// art_loaded := true ;
1085: LD_ADDR_VAR 0 6
1089: PUSH
1090: LD_INT 1
1092: ST_TO_ADDR
// end ; if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
1093: LD_VAR 0 16
1097: PUSH
1098: LD_INT 1
1100: ARRAY
1101: PUSH
1102: LD_INT 21
1104: PUSH
1105: LD_INT 22
1107: PUSH
1108: LD_INT 23
1110: PUSH
1111: LD_INT 24
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: IN
1120: IFFALSE 1132
// uc_nation := nation_russian else
1122: LD_ADDR_OWVAR 21
1126: PUSH
1127: LD_INT 3
1129: ST_TO_ADDR
1130: GO 1140
// uc_nation := nation_american ;
1132: LD_ADDR_OWVAR 21
1136: PUSH
1137: LD_INT 1
1139: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
1140: LD_ADDR_OWVAR 24
1144: PUSH
1145: LD_INT 2
1147: PPUSH
1148: LD_INT 3
1150: PPUSH
1151: CALL_OW 12
1155: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
1156: LD_ADDR_OWVAR 37
1160: PUSH
1161: LD_VAR 0 16
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
1170: LD_ADDR_OWVAR 39
1174: PUSH
1175: LD_VAR 0 16
1179: PUSH
1180: LD_INT 2
1182: ARRAY
1183: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
1184: LD_ADDR_OWVAR 38
1188: PUSH
1189: LD_VAR 0 16
1193: PUSH
1194: LD_INT 3
1196: ARRAY
1197: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
1198: LD_ADDR_OWVAR 40
1202: PUSH
1203: LD_VAR 0 16
1207: PUSH
1208: LD_INT 4
1210: ARRAY
1211: ST_TO_ADDR
// un := CreateVehicle ;
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: CALL_OW 45
1221: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , un ) ;
1222: LD_EXP 12
1226: PPUSH
1227: LD_VAR 0 2
1231: PPUSH
1232: CALL_OW 52
// PlaceUnitArea ( un , burlak_starting , false ) ;
1236: LD_VAR 0 2
1240: PPUSH
1241: LD_INT 10
1243: PPUSH
1244: LD_INT 0
1246: PPUSH
1247: CALL_OW 49
// if ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) and not art_loaded then
1251: LD_VAR 0 2
1255: PPUSH
1256: CALL_OW 264
1260: PUSH
1261: LD_INT 12
1263: PUSH
1264: LD_INT 51
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: IN
1271: PUSH
1272: LD_VAR 0 6
1276: NOT
1277: AND
1278: IFFALSE 1295
// SetCargo ( un , mat_artefact , 50 ) ;
1280: LD_VAR 0 2
1284: PPUSH
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 50
1290: PPUSH
1291: CALL_OW 290
// veh_cargo := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_cargo_bay ] , [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay ] ] ;
1295: LD_ADDR_VAR 0 10
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: LD_INT 3
1311: PUSH
1312: LD_INT 12
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: PUSH
1322: LD_INT 1
1324: PUSH
1325: LD_INT 3
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: LD_INT 1
1333: PUSH
1334: LD_INT 12
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 3
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 3
1352: PUSH
1353: LD_INT 3
1355: PUSH
1356: LD_INT 51
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 22
1371: PUSH
1372: LD_INT 3
1374: PUSH
1375: LD_INT 1
1377: PUSH
1378: LD_INT 51
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: ST_TO_ADDR
// veh_basic := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_crane ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_bulldozer ] , ] ;
1394: LD_ADDR_VAR 0 11
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 3
1410: PUSH
1411: LD_INT 13
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: PUSH
1421: LD_INT 3
1423: PUSH
1424: LD_INT 24
1426: PUSH
1427: LD_INT 3
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 53
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: ST_TO_ADDR
// veh_battle := [ [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_american , us_medium_tracked , engine_siberite , control_manual , us_laser ] , [ nation_american , us_heavy_tracked , engine_siberite , control_manual , us_heavy_gun ] , [ nation_american , us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_russian , ru_medium_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_gun ] , [ nation_russian , ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun ] , ] ;
1447: LD_ADDR_VAR 0 12
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 3
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 1
1463: PUSH
1464: LD_INT 7
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PUSH
1474: LD_INT 1
1476: PUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 3
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 9
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 3
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: LIST
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 5
1523: PUSH
1524: LD_INT 1
1526: PUSH
1527: LD_INT 1
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 21
1545: PUSH
1546: LD_INT 1
1548: PUSH
1549: LD_INT 1
1551: PUSH
1552: LD_INT 45
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 3
1564: PUSH
1565: LD_INT 22
1567: PUSH
1568: LD_INT 3
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: LD_INT 44
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: PUSH
1584: LD_INT 3
1586: PUSH
1587: LD_INT 23
1589: PUSH
1590: LD_INT 1
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: LD_INT 46
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: PUSH
1606: LD_INT 3
1608: PUSH
1609: LD_INT 24
1611: PUSH
1612: LD_INT 3
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: LD_INT 46
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: ST_TO_ADDR
// veh_list := [ ] ;
1638: LD_ADDR_VAR 0 14
1642: PUSH
1643: EMPTY
1644: ST_TO_ADDR
// count := 0 ;
1645: LD_ADDR_VAR 0 3
1649: PUSH
1650: LD_INT 0
1652: ST_TO_ADDR
// for i = 3 to 4 do
1653: LD_ADDR_VAR 0 4
1657: PUSH
1658: DOUBLE
1659: LD_INT 3
1661: DEC
1662: ST_TO_ADDR
1663: LD_INT 4
1665: PUSH
1666: FOR_TO
1667: IFFALSE 1852
// begin uc_direction := Rand ( 2 , 3 ) ;
1669: LD_ADDR_OWVAR 24
1673: PUSH
1674: LD_INT 2
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// un := veh_cargo [ Rand ( 1 , veh_cargo ) ] ;
1685: LD_ADDR_VAR 0 2
1689: PUSH
1690: LD_VAR 0 10
1694: PUSH
1695: LD_INT 1
1697: PPUSH
1698: LD_VAR 0 10
1702: PPUSH
1703: CALL_OW 12
1707: ARRAY
1708: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1709: LD_ADDR_OWVAR 21
1713: PUSH
1714: LD_VAR 0 2
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1723: LD_ADDR_OWVAR 37
1727: PUSH
1728: LD_VAR 0 2
1732: PUSH
1733: LD_INT 2
1735: ARRAY
1736: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1737: LD_ADDR_OWVAR 39
1741: PUSH
1742: LD_VAR 0 2
1746: PUSH
1747: LD_INT 3
1749: ARRAY
1750: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1751: LD_ADDR_OWVAR 38
1755: PUSH
1756: LD_VAR 0 2
1760: PUSH
1761: LD_INT 4
1763: ARRAY
1764: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1765: LD_ADDR_OWVAR 40
1769: PUSH
1770: LD_VAR 0 2
1774: PUSH
1775: LD_INT 5
1777: ARRAY
1778: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1779: LD_ADDR_VAR 0 14
1783: PUSH
1784: LD_VAR 0 14
1788: PUSH
1789: CALL_OW 45
1793: ADD
1794: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1795: LD_VAR 0 2
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: PUSH
1804: LD_INT 1
1806: EQUAL
1807: IFFALSE 1823
// count := count + 1 ;
1809: LD_ADDR_VAR 0 3
1813: PUSH
1814: LD_VAR 0 3
1818: PUSH
1819: LD_INT 1
1821: PLUS
1822: ST_TO_ADDR
// SetCargo ( veh_list [ veh_list ] , mat_artefact , i * 10 ) ;
1823: LD_VAR 0 14
1827: PUSH
1828: LD_VAR 0 14
1832: ARRAY
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_VAR 0 4
1841: PUSH
1842: LD_INT 10
1844: MUL
1845: PPUSH
1846: CALL_OW 290
// end ;
1850: GO 1666
1852: POP
1853: POP
// for un in veh_basic do
1854: LD_ADDR_VAR 0 2
1858: PUSH
1859: LD_VAR 0 11
1863: PUSH
1864: FOR_IN
1865: IFFALSE 1999
// begin uc_direction := Rand ( 2 , 3 ) ;
1867: LD_ADDR_OWVAR 24
1871: PUSH
1872: LD_INT 2
1874: PPUSH
1875: LD_INT 3
1877: PPUSH
1878: CALL_OW 12
1882: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1883: LD_ADDR_OWVAR 21
1887: PUSH
1888: LD_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: ARRAY
1896: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1897: LD_ADDR_OWVAR 37
1901: PUSH
1902: LD_VAR 0 2
1906: PUSH
1907: LD_INT 2
1909: ARRAY
1910: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1911: LD_ADDR_OWVAR 39
1915: PUSH
1916: LD_VAR 0 2
1920: PUSH
1921: LD_INT 3
1923: ARRAY
1924: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1925: LD_ADDR_OWVAR 38
1929: PUSH
1930: LD_VAR 0 2
1934: PUSH
1935: LD_INT 4
1937: ARRAY
1938: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1939: LD_ADDR_OWVAR 40
1943: PUSH
1944: LD_VAR 0 2
1948: PUSH
1949: LD_INT 5
1951: ARRAY
1952: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1953: LD_ADDR_VAR 0 14
1957: PUSH
1958: LD_VAR 0 14
1962: PUSH
1963: CALL_OW 45
1967: ADD
1968: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1969: LD_VAR 0 2
1973: PUSH
1974: LD_INT 4
1976: ARRAY
1977: PUSH
1978: LD_INT 1
1980: EQUAL
1981: IFFALSE 1997
// count := count + 1 ;
1983: LD_ADDR_VAR 0 3
1987: PUSH
1988: LD_VAR 0 3
1992: PUSH
1993: LD_INT 1
1995: PLUS
1996: ST_TO_ADDR
// end ;
1997: GO 1864
1999: POP
2000: POP
// count := aliance_forces - 2 - count ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: LD_EXP 57
2010: PUSH
2011: LD_INT 2
2013: MINUS
2014: PUSH
2015: LD_VAR 0 3
2019: MINUS
2020: ST_TO_ADDR
// for i = 1 to count do
2021: LD_ADDR_VAR 0 4
2025: PUSH
2026: DOUBLE
2027: LD_INT 1
2029: DEC
2030: ST_TO_ADDR
2031: LD_VAR 0 3
2035: PUSH
2036: FOR_TO
2037: IFFALSE 2167
// begin uc_direction := Rand ( 2 , 3 ) ;
2039: LD_ADDR_OWVAR 24
2043: PUSH
2044: LD_INT 2
2046: PPUSH
2047: LD_INT 3
2049: PPUSH
2050: CALL_OW 12
2054: ST_TO_ADDR
// un := veh_battle [ Rand ( 1 , veh_battle ) ] ;
2055: LD_ADDR_VAR 0 2
2059: PUSH
2060: LD_VAR 0 12
2064: PUSH
2065: LD_INT 1
2067: PPUSH
2068: LD_VAR 0 12
2072: PPUSH
2073: CALL_OW 12
2077: ARRAY
2078: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
2079: LD_ADDR_OWVAR 21
2083: PUSH
2084: LD_VAR 0 2
2088: PUSH
2089: LD_INT 1
2091: ARRAY
2092: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
2093: LD_ADDR_OWVAR 37
2097: PUSH
2098: LD_VAR 0 2
2102: PUSH
2103: LD_INT 2
2105: ARRAY
2106: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
2107: LD_ADDR_OWVAR 39
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: LD_INT 3
2119: ARRAY
2120: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2121: LD_ADDR_OWVAR 38
2125: PUSH
2126: LD_VAR 0 2
2130: PUSH
2131: LD_INT 4
2133: ARRAY
2134: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2135: LD_ADDR_OWVAR 40
2139: PUSH
2140: LD_VAR 0 2
2144: PUSH
2145: LD_INT 5
2147: ARRAY
2148: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2149: LD_ADDR_VAR 0 14
2153: PUSH
2154: LD_VAR 0 14
2158: PUSH
2159: CALL_OW 45
2163: ADD
2164: ST_TO_ADDR
// end ;
2165: GO 2036
2167: POP
2168: POP
// pom_list := aliance_forces diff [ MacMillan , Burlak ] ;
2169: LD_ADDR_VAR 0 9
2173: PUSH
2174: LD_EXP 57
2178: PUSH
2179: LD_EXP 13
2183: PUSH
2184: LD_EXP 12
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: DIFF
2193: ST_TO_ADDR
// i := 1 ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// for un in veh_list do
2202: LD_ADDR_VAR 0 2
2206: PUSH
2207: LD_VAR 0 14
2211: PUSH
2212: FOR_IN
2213: IFFALSE 2314
// begin uc_direction := Rand ( 2 , 3 ) ;
2215: LD_ADDR_OWVAR 24
2219: PUSH
2220: LD_INT 2
2222: PPUSH
2223: LD_INT 3
2225: PPUSH
2226: CALL_OW 12
2230: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
2231: LD_VAR 0 2
2235: PPUSH
2236: CALL_OW 263
2240: PUSH
2241: LD_INT 1
2243: EQUAL
2244: IFFALSE 2297
// begin PlaceHumanInUnit ( pom_list [ i ] , un ) ;
2246: LD_VAR 0 9
2250: PUSH
2251: LD_VAR 0 4
2255: ARRAY
2256: PPUSH
2257: LD_VAR 0 2
2261: PPUSH
2262: CALL_OW 52
// PlaceUnitArea ( un , starting_area , false ) ;
2266: LD_VAR 0 2
2270: PPUSH
2271: LD_INT 7
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 49
// i := i + 1 ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: LD_INT 1
2293: PLUS
2294: ST_TO_ADDR
// end else
2295: GO 2312
// PlaceUnitArea ( un , starting_area , false ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_INT 7
2304: PPUSH
2305: LD_INT 0
2307: PPUSH
2308: CALL_OW 49
// end ;
2312: GO 2212
2314: POP
2315: POP
// ComEnterUnit ( uss_ape , uss ) ;
2316: LD_INT 146
2318: PPUSH
2319: LD_INT 38
2321: PPUSH
2322: CALL_OW 120
// end ;
2326: LD_VAR 0 1
2330: RET
// function prepare_sides ; begin
2331: LD_INT 0
2333: PPUSH
// neutral := 0 ;
2334: LD_ADDR_EXP 6
2338: PUSH
2339: LD_INT 0
2341: ST_TO_ADDR
// you := 7 ;
2342: LD_ADDR_EXP 1
2346: PUSH
2347: LD_INT 7
2349: ST_TO_ADDR
// camp := 4 ;
2350: LD_ADDR_EXP 7
2354: PUSH
2355: LD_INT 4
2357: ST_TO_ADDR
// ru := 3 ;
2358: LD_ADDR_EXP 2
2362: PUSH
2363: LD_INT 3
2365: ST_TO_ADDR
// us := 1 ;
2366: LD_ADDR_EXP 3
2370: PUSH
2371: LD_INT 1
2373: ST_TO_ADDR
// ar := 2 ;
2374: LD_ADDR_EXP 4
2378: PUSH
2379: LD_INT 2
2381: ST_TO_ADDR
// ar_al := 5 ;
2382: LD_ADDR_EXP 5
2386: PUSH
2387: LD_INT 5
2389: ST_TO_ADDR
// cpu_list := [ us , ar , ru ] ;
2390: LD_ADDR_EXP 8
2394: PUSH
2395: LD_EXP 3
2399: PUSH
2400: LD_EXP 4
2404: PUSH
2405: LD_EXP 2
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: ST_TO_ADDR
// ru_nation := nation_russian ;
2415: LD_ADDR_EXP 9
2419: PUSH
2420: LD_INT 3
2422: ST_TO_ADDR
// us_nation := nation_american ;
2423: LD_ADDR_EXP 10
2427: PUSH
2428: LD_INT 1
2430: ST_TO_ADDR
// ar_nation := nation_arabian ;
2431: LD_ADDR_EXP 11
2435: PUSH
2436: LD_INT 2
2438: ST_TO_ADDR
// finalize := 0 ;
2439: LD_ADDR_EXP 58
2443: PUSH
2444: LD_INT 0
2446: ST_TO_ADDR
// siberite_rocket_send := false ;
2447: LD_ADDR_EXP 60
2451: PUSH
2452: LD_INT 0
2454: ST_TO_ADDR
// disable ( 1 ) ;
2455: LD_INT 1
2457: DISABLE_MARKED
// disable ( 2 ) ;
2458: LD_INT 2
2460: DISABLE_MARKED
// disable ( 4 ) ;
2461: LD_INT 4
2463: DISABLE_MARKED
// disable ( 5 ) ;
2464: LD_INT 5
2466: DISABLE_MARKED
// disable ( 24 ) ;
2467: LD_INT 24
2469: DISABLE_MARKED
// disable ( 25 ) ;
2470: LD_INT 25
2472: DISABLE_MARKED
// disable ( 26 ) ;
2473: LD_INT 26
2475: DISABLE_MARKED
// disable ( 222 ) ;
2476: LD_INT 222
2478: DISABLE_MARKED
// disable ( 223 ) ;
2479: LD_INT 223
2481: DISABLE_MARKED
// SetAttitude ( you , ru , att_enemy , true ) ;
2482: LD_EXP 1
2486: PPUSH
2487: LD_EXP 2
2491: PPUSH
2492: LD_INT 2
2494: PPUSH
2495: LD_INT 1
2497: PPUSH
2498: CALL_OW 80
// SetAttitude ( you , us , att_enemy , true ) ;
2502: LD_EXP 1
2506: PPUSH
2507: LD_EXP 3
2511: PPUSH
2512: LD_INT 2
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 80
// SetAttitude ( you , ar , att_enemy , true ) ;
2522: LD_EXP 1
2526: PPUSH
2527: LD_EXP 4
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: CALL_OW 80
// SetAttitude ( you , neutral , att_neutral , true ) ;
2542: LD_EXP 1
2546: PPUSH
2547: LD_EXP 6
2551: PPUSH
2552: LD_INT 0
2554: PPUSH
2555: LD_INT 1
2557: PPUSH
2558: CALL_OW 80
// SetAttitude ( you , ar_al , att_enemy , true ) ;
2562: LD_EXP 1
2566: PPUSH
2567: LD_EXP 5
2571: PPUSH
2572: LD_INT 2
2574: PPUSH
2575: LD_INT 1
2577: PPUSH
2578: CALL_OW 80
// SetAttitude ( ru , us , att_enemy , true ) ;
2582: LD_EXP 2
2586: PPUSH
2587: LD_EXP 3
2591: PPUSH
2592: LD_INT 2
2594: PPUSH
2595: LD_INT 1
2597: PPUSH
2598: CALL_OW 80
// SetAttitude ( ru , ar , att_enemy , true ) ;
2602: LD_EXP 2
2606: PPUSH
2607: LD_EXP 4
2611: PPUSH
2612: LD_INT 2
2614: PPUSH
2615: LD_INT 1
2617: PPUSH
2618: CALL_OW 80
// SetAttitude ( us , ar , att_enemy , true ) ;
2622: LD_EXP 3
2626: PPUSH
2627: LD_EXP 4
2631: PPUSH
2632: LD_INT 2
2634: PPUSH
2635: LD_INT 1
2637: PPUSH
2638: CALL_OW 80
// SetAttitude ( ru , ar_al , att_enemy , true ) ;
2642: LD_EXP 2
2646: PPUSH
2647: LD_EXP 5
2651: PPUSH
2652: LD_INT 2
2654: PPUSH
2655: LD_INT 1
2657: PPUSH
2658: CALL_OW 80
// SetAttitude ( us , ar_al , att_enemy , true ) ;
2662: LD_EXP 3
2666: PPUSH
2667: LD_EXP 5
2671: PPUSH
2672: LD_INT 2
2674: PPUSH
2675: LD_INT 1
2677: PPUSH
2678: CALL_OW 80
// end ;
2682: LD_VAR 0 1
2686: RET
// starting begin RandomizeAll ;
2687: CALL_OW 11
// prepare_sides ;
2691: CALL 2331 0 0
// prepare_us_units ;
2695: CALL 0 0 0
// prepare_ru_units ;
2699: CALL 35 0 0
// prepare_ar_units ;
2703: CALL 70 0 0
// prepare_al_units ;
2707: CALL 249 0 0
// prepare_apemans ;
2711: CALL 7100 0 0
// create_russians ;
2715: CALL 4649 0 0
// create_americans ;
2719: CALL 5349 0 0
// create_arabians ;
2723: CALL 6074 0 0
// init_distribution ;
2727: CALL 26330 0 0
// init_defend ;
2731: CALL 18135 0 0
// init_attack ;
2735: CALL 20748 0 0
// init_keep_base ;
2739: CALL 32203 0 0
// init_research ;
2743: CALL 23927 0 0
// init_manufacture ;
2747: CALL 26677 0 0
// init_crates_loading ;
2751: CALL 32609 0 0
// init_crates_collecting ;
2755: CALL 33346 0 0
// init_alien_research ;
2759: CALL 36870 0 0
// init_sib_rocket ;
2763: CALL 36039 0 0
// starting_scene ;
2767: CALL 7332 0 0
// end ; end_of_file
2771: END
// export function load_all_aliance ; begin
2772: LD_INT 0
2774: PPUSH
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) then
2775: LD_STRING Belkov
2777: PPUSH
2778: CALL_OW 28
2782: PUSH
2783: LD_STRING Belkov
2785: PPUSH
2786: CALL_OW 29
2790: AND
2791: IFFALSE 2822
// begin Belkov := CreateCharacter ( Belkov ) ;
2793: LD_ADDR_EXP 17
2797: PUSH
2798: LD_STRING Belkov
2800: PPUSH
2801: CALL_OW 34
2805: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Belkov ;
2806: LD_ADDR_EXP 57
2810: PUSH
2811: LD_EXP 57
2815: PUSH
2816: LD_EXP 17
2820: ADD
2821: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) then
2822: LD_STRING Petrosyan
2824: PPUSH
2825: CALL_OW 28
2829: PUSH
2830: LD_STRING Petrosyan
2832: PPUSH
2833: CALL_OW 29
2837: AND
2838: IFFALSE 2869
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
2840: LD_ADDR_EXP 16
2844: PUSH
2845: LD_STRING Petrosyan
2847: PPUSH
2848: CALL_OW 34
2852: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrosyan ;
2853: LD_ADDR_EXP 57
2857: PUSH
2858: LD_EXP 57
2862: PUSH
2863: LD_EXP 16
2867: ADD
2868: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) then
2869: LD_STRING Kirilenkova
2871: PPUSH
2872: CALL_OW 28
2876: PUSH
2877: LD_STRING Kirilenkova
2879: PPUSH
2880: CALL_OW 29
2884: AND
2885: IFFALSE 2916
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
2887: LD_ADDR_EXP 18
2891: PUSH
2892: LD_STRING Kirilenkova
2894: PPUSH
2895: CALL_OW 34
2899: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kirilenkova ;
2900: LD_ADDR_EXP 57
2904: PUSH
2905: LD_EXP 57
2909: PUSH
2910: LD_EXP 18
2914: ADD
2915: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) then
2916: LD_STRING Gnyevko
2918: PPUSH
2919: CALL_OW 28
2923: PUSH
2924: LD_STRING Gnyevko
2926: PPUSH
2927: CALL_OW 29
2931: AND
2932: IFFALSE 2963
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
2934: LD_ADDR_EXP 19
2938: PUSH
2939: LD_STRING Gnyevko
2941: PPUSH
2942: CALL_OW 34
2946: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gnyevko ;
2947: LD_ADDR_EXP 57
2951: PUSH
2952: LD_EXP 57
2956: PUSH
2957: LD_EXP 19
2961: ADD
2962: ST_TO_ADDR
// end ; if TestCharacters ( Gladkov ) and CheckCharacterSet ( Gladkov ) then
2963: LD_STRING Gladkov
2965: PPUSH
2966: CALL_OW 28
2970: PUSH
2971: LD_STRING Gladkov
2973: PPUSH
2974: CALL_OW 29
2978: AND
2979: IFFALSE 3010
// begin Gladkov := CreateCharacter ( Gladkov ) ;
2981: LD_ADDR_EXP 20
2985: PUSH
2986: LD_STRING Gladkov
2988: PPUSH
2989: CALL_OW 34
2993: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladkov ;
2994: LD_ADDR_EXP 57
2998: PUSH
2999: LD_EXP 57
3003: PUSH
3004: LD_EXP 20
3008: ADD
3009: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) then
3010: LD_STRING Dolgov
3012: PPUSH
3013: CALL_OW 28
3017: PUSH
3018: LD_STRING Dolgov
3020: PPUSH
3021: CALL_OW 29
3025: AND
3026: IFFALSE 3057
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3028: LD_ADDR_EXP 21
3032: PUSH
3033: LD_STRING Dolgov
3035: PPUSH
3036: CALL_OW 34
3040: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Dolgov ;
3041: LD_ADDR_EXP 57
3045: PUSH
3046: LD_EXP 57
3050: PUSH
3051: LD_EXP 21
3055: ADD
3056: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) then
3057: LD_STRING Gleb
3059: PPUSH
3060: CALL_OW 28
3064: PUSH
3065: LD_STRING Gleb
3067: PPUSH
3068: CALL_OW 29
3072: AND
3073: IFFALSE 3104
// begin Gleb := CreateCharacter ( Gleb ) ;
3075: LD_ADDR_EXP 22
3079: PUSH
3080: LD_STRING Gleb
3082: PPUSH
3083: CALL_OW 34
3087: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gleb ;
3088: LD_ADDR_EXP 57
3092: PUSH
3093: LD_EXP 57
3097: PUSH
3098: LD_EXP 22
3102: ADD
3103: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) then
3104: LD_STRING Kapitsova
3106: PPUSH
3107: CALL_OW 28
3111: PUSH
3112: LD_STRING Kapitsova
3114: PPUSH
3115: CALL_OW 29
3119: AND
3120: IFFALSE 3151
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3122: LD_ADDR_EXP 23
3126: PUSH
3127: LD_STRING Kapitsova
3129: PPUSH
3130: CALL_OW 34
3134: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kapitsova ;
3135: LD_ADDR_EXP 57
3139: PUSH
3140: LD_EXP 57
3144: PUSH
3145: LD_EXP 23
3149: ADD
3150: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) then
3151: LD_STRING Kuzmov
3153: PPUSH
3154: CALL_OW 28
3158: PUSH
3159: LD_STRING Kuzmov
3161: PPUSH
3162: CALL_OW 29
3166: AND
3167: IFFALSE 3198
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3169: LD_ADDR_EXP 24
3173: PUSH
3174: LD_STRING Kuzmov
3176: PPUSH
3177: CALL_OW 34
3181: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kuzmov ;
3182: LD_ADDR_EXP 57
3186: PUSH
3187: LD_EXP 57
3191: PUSH
3192: LD_EXP 24
3196: ADD
3197: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) then
3198: LD_STRING Kovalyuk
3200: PPUSH
3201: CALL_OW 28
3205: PUSH
3206: LD_STRING Kovalyuk
3208: PPUSH
3209: CALL_OW 29
3213: AND
3214: IFFALSE 3245
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
3216: LD_ADDR_EXP 25
3220: PUSH
3221: LD_STRING Kovalyuk
3223: PPUSH
3224: CALL_OW 34
3228: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kovalyuk ;
3229: LD_ADDR_EXP 57
3233: PUSH
3234: LD_EXP 57
3238: PUSH
3239: LD_EXP 25
3243: ADD
3244: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) then
3245: LD_STRING Scholtze
3247: PPUSH
3248: CALL_OW 28
3252: PUSH
3253: LD_STRING Scholtze
3255: PPUSH
3256: CALL_OW 29
3260: AND
3261: IFFALSE 3292
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3263: LD_ADDR_EXP 26
3267: PUSH
3268: LD_STRING Scholtze
3270: PPUSH
3271: CALL_OW 34
3275: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Scholtze ;
3276: LD_ADDR_EXP 57
3280: PUSH
3281: LD_EXP 57
3285: PUSH
3286: LD_EXP 26
3290: ADD
3291: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) then
3292: LD_STRING Karamazov
3294: PPUSH
3295: CALL_OW 28
3299: PUSH
3300: LD_STRING Karamazov
3302: PPUSH
3303: CALL_OW 29
3307: AND
3308: IFFALSE 3339
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3310: LD_ADDR_EXP 27
3314: PUSH
3315: LD_STRING Karamazov
3317: PPUSH
3318: CALL_OW 34
3322: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Karamazov ;
3323: LD_ADDR_EXP 57
3327: PUSH
3328: LD_EXP 57
3332: PUSH
3333: LD_EXP 27
3337: ADD
3338: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) then
3339: LD_STRING Titov
3341: PPUSH
3342: CALL_OW 28
3346: PUSH
3347: LD_STRING Titov
3349: PPUSH
3350: CALL_OW 29
3354: AND
3355: IFFALSE 3386
// begin Titov := CreateCharacter ( Titov ) ;
3357: LD_ADDR_EXP 28
3361: PUSH
3362: LD_STRING Titov
3364: PPUSH
3365: CALL_OW 34
3369: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Titov ;
3370: LD_ADDR_EXP 57
3374: PUSH
3375: LD_EXP 57
3379: PUSH
3380: LD_EXP 28
3384: ADD
3385: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) then
3386: LD_STRING Oblukov
3388: PPUSH
3389: CALL_OW 28
3393: PUSH
3394: LD_STRING Oblukov
3396: PPUSH
3397: CALL_OW 29
3401: AND
3402: IFFALSE 3433
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3404: LD_ADDR_EXP 29
3408: PUSH
3409: LD_STRING Oblukov
3411: PPUSH
3412: CALL_OW 34
3416: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Oblukov ;
3417: LD_ADDR_EXP 57
3421: PUSH
3422: LD_EXP 57
3426: PUSH
3427: LD_EXP 29
3431: ADD
3432: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) then
3433: LD_STRING Kozlov
3435: PPUSH
3436: CALL_OW 28
3440: PUSH
3441: LD_STRING Kozlov
3443: PPUSH
3444: CALL_OW 29
3448: AND
3449: IFFALSE 3480
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3451: LD_ADDR_EXP 30
3455: PUSH
3456: LD_STRING Kozlov
3458: PPUSH
3459: CALL_OW 34
3463: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kozlov ;
3464: LD_ADDR_EXP 57
3468: PUSH
3469: LD_EXP 57
3473: PUSH
3474: LD_EXP 30
3478: ADD
3479: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) then
3480: LD_STRING Petrovova
3482: PPUSH
3483: CALL_OW 28
3487: PUSH
3488: LD_STRING Petrovova
3490: PPUSH
3491: CALL_OW 29
3495: AND
3496: IFFALSE 3527
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3498: LD_ADDR_EXP 31
3502: PUSH
3503: LD_STRING Petrovova
3505: PPUSH
3506: CALL_OW 34
3510: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrovova ;
3511: LD_ADDR_EXP 57
3515: PUSH
3516: LD_EXP 57
3520: PUSH
3521: LD_EXP 31
3525: ADD
3526: ST_TO_ADDR
// end ; if TestCharacters ( Bystrov ) and CheckCharacterSet ( Bystrov ) then
3527: LD_STRING Bystrov
3529: PPUSH
3530: CALL_OW 28
3534: PUSH
3535: LD_STRING Bystrov
3537: PPUSH
3538: CALL_OW 29
3542: AND
3543: IFFALSE 3574
// begin Bystrov := CreateCharacter ( Bystrov ) ;
3545: LD_ADDR_EXP 32
3549: PUSH
3550: LD_STRING Bystrov
3552: PPUSH
3553: CALL_OW 34
3557: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bystrov ;
3558: LD_ADDR_EXP 57
3562: PUSH
3563: LD_EXP 57
3567: PUSH
3568: LD_EXP 32
3572: ADD
3573: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) then
3574: LD_STRING Lipshchin
3576: PPUSH
3577: CALL_OW 28
3581: PUSH
3582: LD_STRING Lipshchin
3584: PPUSH
3585: CALL_OW 29
3589: AND
3590: IFFALSE 3621
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3592: LD_ADDR_EXP 33
3596: PUSH
3597: LD_STRING Lipshchin
3599: PPUSH
3600: CALL_OW 34
3604: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lipshchin ;
3605: LD_ADDR_EXP 57
3609: PUSH
3610: LD_EXP 57
3614: PUSH
3615: LD_EXP 33
3619: ADD
3620: ST_TO_ADDR
// end ; if TestCharacters ( Fadeev ) and CheckCharacterSet ( Fadeev ) then
3621: LD_STRING Fadeev
3623: PPUSH
3624: CALL_OW 28
3628: PUSH
3629: LD_STRING Fadeev
3631: PPUSH
3632: CALL_OW 29
3636: AND
3637: IFFALSE 3668
// begin Fadeev := CreateCharacter ( Fadeev ) ;
3639: LD_ADDR_EXP 34
3643: PUSH
3644: LD_STRING Fadeev
3646: PPUSH
3647: CALL_OW 34
3651: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Fadeev ;
3652: LD_ADDR_EXP 57
3656: PUSH
3657: LD_EXP 57
3661: PUSH
3662: LD_EXP 34
3666: ADD
3667: ST_TO_ADDR
// end ; if TestCharacters ( Bobby ) and CheckCharacterSet ( Bobby ) then
3668: LD_STRING Bobby
3670: PPUSH
3671: CALL_OW 28
3675: PUSH
3676: LD_STRING Bobby
3678: PPUSH
3679: CALL_OW 29
3683: AND
3684: IFFALSE 3715
// begin Bobby := CreateCharacter ( Bobby ) ;
3686: LD_ADDR_EXP 35
3690: PUSH
3691: LD_STRING Bobby
3693: PPUSH
3694: CALL_OW 34
3698: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bobby ;
3699: LD_ADDR_EXP 57
3703: PUSH
3704: LD_EXP 57
3708: PUSH
3709: LD_EXP 35
3713: ADD
3714: ST_TO_ADDR
// end ; if TestCharacters ( Brown ) and CheckCharacterSet ( Brown ) then
3715: LD_STRING Brown
3717: PPUSH
3718: CALL_OW 28
3722: PUSH
3723: LD_STRING Brown
3725: PPUSH
3726: CALL_OW 29
3730: AND
3731: IFFALSE 3762
// begin Brown := CreateCharacter ( Brown ) ;
3733: LD_ADDR_EXP 36
3737: PUSH
3738: LD_STRING Brown
3740: PPUSH
3741: CALL_OW 34
3745: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Brown ;
3746: LD_ADDR_EXP 57
3750: PUSH
3751: LD_EXP 57
3755: PUSH
3756: LD_EXP 36
3760: ADD
3761: ST_TO_ADDR
// end ; if TestCharacters ( Cornell ) and CheckCharacterSet ( Cornell ) then
3762: LD_STRING Cornell
3764: PPUSH
3765: CALL_OW 28
3769: PUSH
3770: LD_STRING Cornell
3772: PPUSH
3773: CALL_OW 29
3777: AND
3778: IFFALSE 3809
// begin Cornell := CreateCharacter ( Cornell ) ;
3780: LD_ADDR_EXP 37
3784: PUSH
3785: LD_STRING Cornell
3787: PPUSH
3788: CALL_OW 34
3792: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cornell ;
3793: LD_ADDR_EXP 57
3797: PUSH
3798: LD_EXP 57
3802: PUSH
3803: LD_EXP 37
3807: ADD
3808: ST_TO_ADDR
// end ; if TestCharacters ( Coonie ) and CheckCharacterSet ( Coonie ) then
3809: LD_STRING Coonie
3811: PPUSH
3812: CALL_OW 28
3816: PUSH
3817: LD_STRING Coonie
3819: PPUSH
3820: CALL_OW 29
3824: AND
3825: IFFALSE 3856
// begin Connie := CreateCharacter ( Coonie ) ;
3827: LD_ADDR_EXP 38
3831: PUSH
3832: LD_STRING Coonie
3834: PPUSH
3835: CALL_OW 34
3839: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Connie ;
3840: LD_ADDR_EXP 57
3844: PUSH
3845: LD_EXP 57
3849: PUSH
3850: LD_EXP 38
3854: ADD
3855: ST_TO_ADDR
// end ; if TestCharacters ( Cyrus ) and CheckCharacterSet ( Cyrus ) then
3856: LD_STRING Cyrus
3858: PPUSH
3859: CALL_OW 28
3863: PUSH
3864: LD_STRING Cyrus
3866: PPUSH
3867: CALL_OW 29
3871: AND
3872: IFFALSE 3903
// begin Cyrus := CreateCharacter ( Cyrus ) ;
3874: LD_ADDR_EXP 39
3878: PUSH
3879: LD_STRING Cyrus
3881: PPUSH
3882: CALL_OW 34
3886: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cyrus ;
3887: LD_ADDR_EXP 57
3891: PUSH
3892: LD_EXP 57
3896: PUSH
3897: LD_EXP 39
3901: ADD
3902: ST_TO_ADDR
// end ; if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
3903: LD_STRING Denis
3905: PPUSH
3906: CALL_OW 28
3910: PUSH
3911: LD_STRING Denis
3913: PPUSH
3914: CALL_OW 29
3918: AND
3919: IFFALSE 3950
// begin Denis := CreateCharacter ( Denis ) ;
3921: LD_ADDR_EXP 40
3925: PUSH
3926: LD_STRING Denis
3928: PPUSH
3929: CALL_OW 34
3933: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Denis ;
3934: LD_ADDR_EXP 57
3938: PUSH
3939: LD_EXP 57
3943: PUSH
3944: LD_EXP 40
3948: ADD
3949: ST_TO_ADDR
// end ; if TestCharacters ( Donaldson ) and CheckCharacterSet ( Donaldson ) then
3950: LD_STRING Donaldson
3952: PPUSH
3953: CALL_OW 28
3957: PUSH
3958: LD_STRING Donaldson
3960: PPUSH
3961: CALL_OW 29
3965: AND
3966: IFFALSE 3997
// begin Donaldson := CreateCharacter ( Donaldson ) ;
3968: LD_ADDR_EXP 41
3972: PUSH
3973: LD_STRING Donaldson
3975: PPUSH
3976: CALL_OW 34
3980: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Donaldson ;
3981: LD_ADDR_EXP 57
3985: PUSH
3986: LD_EXP 57
3990: PUSH
3991: LD_EXP 41
3995: ADD
3996: ST_TO_ADDR
// end ; if TestCharacters ( Frank ) and CheckCharacterSet ( Frank ) then
3997: LD_STRING Frank
3999: PPUSH
4000: CALL_OW 28
4004: PUSH
4005: LD_STRING Frank
4007: PPUSH
4008: CALL_OW 29
4012: AND
4013: IFFALSE 4044
// begin Frank := CreateCharacter ( Frank ) ;
4015: LD_ADDR_EXP 42
4019: PUSH
4020: LD_STRING Frank
4022: PPUSH
4023: CALL_OW 34
4027: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Frank ;
4028: LD_ADDR_EXP 57
4032: PUSH
4033: LD_EXP 57
4037: PUSH
4038: LD_EXP 42
4042: ADD
4043: ST_TO_ADDR
// end ; if TestCharacters ( Gary ) and CheckCharacterSet ( Gary ) then
4044: LD_STRING Gary
4046: PPUSH
4047: CALL_OW 28
4051: PUSH
4052: LD_STRING Gary
4054: PPUSH
4055: CALL_OW 29
4059: AND
4060: IFFALSE 4091
// begin Gary := CreateCharacter ( Gary ) ;
4062: LD_ADDR_EXP 43
4066: PUSH
4067: LD_STRING Gary
4069: PPUSH
4070: CALL_OW 34
4074: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gary ;
4075: LD_ADDR_EXP 57
4079: PUSH
4080: LD_EXP 57
4084: PUSH
4085: LD_EXP 43
4089: ADD
4090: ST_TO_ADDR
// end ; if TestCharacters ( Gladstone ) and CheckCharacterSet ( Gladstone ) then
4091: LD_STRING Gladstone
4093: PPUSH
4094: CALL_OW 28
4098: PUSH
4099: LD_STRING Gladstone
4101: PPUSH
4102: CALL_OW 29
4106: AND
4107: IFFALSE 4138
// begin Gladstone := CreateCharacter ( Gladstone ) ;
4109: LD_ADDR_EXP 44
4113: PUSH
4114: LD_STRING Gladstone
4116: PPUSH
4117: CALL_OW 34
4121: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladstone ;
4122: LD_ADDR_EXP 57
4126: PUSH
4127: LD_EXP 57
4131: PUSH
4132: LD_EXP 44
4136: ADD
4137: ST_TO_ADDR
// end ; if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) and camp = 4 then
4138: LD_STRING Joan
4140: PPUSH
4141: CALL_OW 28
4145: PUSH
4146: LD_STRING Joan
4148: PPUSH
4149: CALL_OW 29
4153: AND
4154: PUSH
4155: LD_EXP 7
4159: PUSH
4160: LD_INT 4
4162: EQUAL
4163: AND
4164: IFFALSE 4195
// begin Joan := CreateCharacter ( Joan ) ;
4166: LD_ADDR_EXP 45
4170: PUSH
4171: LD_STRING Joan
4173: PPUSH
4174: CALL_OW 34
4178: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Joan ;
4179: LD_ADDR_EXP 57
4183: PUSH
4184: LD_EXP 57
4188: PUSH
4189: LD_EXP 45
4193: ADD
4194: ST_TO_ADDR
// end ; if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
4195: LD_STRING Lisa
4197: PPUSH
4198: CALL_OW 28
4202: PUSH
4203: LD_STRING Lisa
4205: PPUSH
4206: CALL_OW 29
4210: AND
4211: IFFALSE 4242
// begin Lisa := CreateCharacter ( Lisa ) ;
4213: LD_ADDR_EXP 46
4217: PUSH
4218: LD_STRING Lisa
4220: PPUSH
4221: CALL_OW 34
4225: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lisa ;
4226: LD_ADDR_EXP 57
4230: PUSH
4231: LD_EXP 57
4235: PUSH
4236: LD_EXP 46
4240: ADD
4241: ST_TO_ADDR
// end ; if TestCharacters ( Peterson ) and CheckCharacterSet ( Peterson ) then
4242: LD_STRING Peterson
4244: PPUSH
4245: CALL_OW 28
4249: PUSH
4250: LD_STRING Peterson
4252: PPUSH
4253: CALL_OW 29
4257: AND
4258: IFFALSE 4289
// begin Peterson := CreateCharacter ( Peterson ) ;
4260: LD_ADDR_EXP 47
4264: PUSH
4265: LD_STRING Peterson
4267: PPUSH
4268: CALL_OW 34
4272: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Peterson ;
4273: LD_ADDR_EXP 57
4277: PUSH
4278: LD_EXP 57
4282: PUSH
4283: LD_EXP 47
4287: ADD
4288: ST_TO_ADDR
// end ; if TestCharacters ( Simms ) and CheckCharacterSet ( Simms ) then
4289: LD_STRING Simms
4291: PPUSH
4292: CALL_OW 28
4296: PUSH
4297: LD_STRING Simms
4299: PPUSH
4300: CALL_OW 29
4304: AND
4305: IFFALSE 4336
// begin Simms := CreateCharacter ( Simms ) ;
4307: LD_ADDR_EXP 48
4311: PUSH
4312: LD_STRING Simms
4314: PPUSH
4315: CALL_OW 34
4319: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Simms ;
4320: LD_ADDR_EXP 57
4324: PUSH
4325: LD_EXP 57
4329: PUSH
4330: LD_EXP 48
4334: ADD
4335: ST_TO_ADDR
// end ; if TestCharacters ( VanHouten ) and CheckCharacterSet ( VanHouten ) then
4336: LD_STRING VanHouten
4338: PPUSH
4339: CALL_OW 28
4343: PUSH
4344: LD_STRING VanHouten
4346: PPUSH
4347: CALL_OW 29
4351: AND
4352: IFFALSE 4383
// begin VanHouten := CreateCharacter ( VanHouten ) ;
4354: LD_ADDR_EXP 49
4358: PUSH
4359: LD_STRING VanHouten
4361: PPUSH
4362: CALL_OW 34
4366: ST_TO_ADDR
// aliance_forces := aliance_forces ^ VanHouten ;
4367: LD_ADDR_EXP 57
4371: PUSH
4372: LD_EXP 57
4376: PUSH
4377: LD_EXP 49
4381: ADD
4382: ST_TO_ADDR
// end ; if TestCharacters ( Yamoko ) and CheckCharacterSet ( Yamoko ) then
4383: LD_STRING Yamoko
4385: PPUSH
4386: CALL_OW 28
4390: PUSH
4391: LD_STRING Yamoko
4393: PPUSH
4394: CALL_OW 29
4398: AND
4399: IFFALSE 4430
// begin Yamoko := CreateCharacter ( Yamoko ) ;
4401: LD_ADDR_EXP 50
4405: PUSH
4406: LD_STRING Yamoko
4408: PPUSH
4409: CALL_OW 34
4413: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Yamoko ;
4414: LD_ADDR_EXP 57
4418: PUSH
4419: LD_EXP 57
4423: PUSH
4424: LD_EXP 50
4428: ADD
4429: ST_TO_ADDR
// end ; DisableAllBazookers ;
4430: CALL 4562 0 0
// if camp = 4 then
4434: LD_EXP 7
4438: PUSH
4439: LD_INT 4
4441: EQUAL
4442: IFFALSE 4448
// sort_aliance_by_the_nation ;
4444: CALL 4453 0 0
// end ;
4448: LD_VAR 0 1
4452: RET
// function sort_aliance_by_the_nation ; var un , us_list , ru_list ; begin
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
// us_list := [ ] ;
4459: LD_ADDR_VAR 0 3
4463: PUSH
4464: EMPTY
4465: ST_TO_ADDR
// ru_list := [ ] ;
4466: LD_ADDR_VAR 0 4
4470: PUSH
4471: EMPTY
4472: ST_TO_ADDR
// for un in aliance_forces do
4473: LD_ADDR_VAR 0 2
4477: PUSH
4478: LD_EXP 57
4482: PUSH
4483: FOR_IN
4484: IFFALSE 4539
// if GetNation ( un ) = us then
4486: LD_VAR 0 2
4490: PPUSH
4491: CALL_OW 248
4495: PUSH
4496: LD_EXP 3
4500: EQUAL
4501: IFFALSE 4521
// us_list := us_list ^ un else
4503: LD_ADDR_VAR 0 3
4507: PUSH
4508: LD_VAR 0 3
4512: PUSH
4513: LD_VAR 0 2
4517: ADD
4518: ST_TO_ADDR
4519: GO 4537
// ru_list := ru_list ^ un ;
4521: LD_ADDR_VAR 0 4
4525: PUSH
4526: LD_VAR 0 4
4530: PUSH
4531: LD_VAR 0 2
4535: ADD
4536: ST_TO_ADDR
4537: GO 4483
4539: POP
4540: POP
// aliance_forces := us_list ^ ru_list ;
4541: LD_ADDR_EXP 57
4545: PUSH
4546: LD_VAR 0 3
4550: PUSH
4551: LD_VAR 0 4
4555: ADD
4556: ST_TO_ADDR
// end ;
4557: LD_VAR 0 1
4561: RET
// function DisableAllBazookers ; var list , un ; begin
4562: LD_INT 0
4564: PPUSH
4565: PPUSH
4566: PPUSH
// list := [ ] ;
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: EMPTY
4573: ST_TO_ADDR
// for un in aliance_forces do
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: LD_EXP 57
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4632
// begin if GetClass ( un ) = class_bazooker then
4587: LD_VAR 0 3
4591: PPUSH
4592: CALL_OW 257
4596: PUSH
4597: LD_INT 9
4599: EQUAL
4600: IFFALSE 4614
// SetClass ( un , class_soldier ) ;
4602: LD_VAR 0 3
4606: PPUSH
4607: LD_INT 1
4609: PPUSH
4610: CALL_OW 336
// list := list ^ un ;
4614: LD_ADDR_VAR 0 2
4618: PUSH
4619: LD_VAR 0 2
4623: PUSH
4624: LD_VAR 0 3
4628: ADD
4629: ST_TO_ADDR
// end ;
4630: GO 4584
4632: POP
4633: POP
// aliance_forces := list ;
4634: LD_ADDR_EXP 57
4638: PUSH
4639: LD_VAR 0 2
4643: ST_TO_ADDR
// end ; end_of_file
4644: LD_VAR 0 1
4648: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_russians ; var un , class_list , members ; begin
4649: LD_INT 0
4651: PPUSH
4652: PPUSH
4653: PPUSH
4654: PPUSH
// cpu_side := ru ;
4655: LD_ADDR_LOC 1
4659: PUSH
4660: LD_EXP 2
4664: ST_TO_ADDR
// cpu_nation := nation_russian ;
4665: LD_ADDR_LOC 2
4669: PUSH
4670: LD_INT 3
4672: ST_TO_ADDR
// cpu_base := ru_create ;
4673: LD_ADDR_LOC 3
4677: PUSH
4678: LD_INT 17
4680: ST_TO_ADDR
// members := difficulty * 2 ;
4681: LD_ADDR_VAR 0 4
4685: PUSH
4686: LD_OWVAR 67
4690: PUSH
4691: LD_INT 2
4693: MUL
4694: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: LD_INT 3
4705: PUSH
4706: LD_INT 4
4708: PUSH
4709: LD_INT 2
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: LIST
4717: ST_TO_ADDR
// for un in class_list do
4718: LD_ADDR_VAR 0 2
4722: PUSH
4723: LD_VAR 0 3
4727: PUSH
4728: FOR_IN
4729: IFFALSE 4762
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
4731: LD_LOC 1
4735: PPUSH
4736: LD_LOC 2
4740: PPUSH
4741: LD_VAR 0 2
4745: PPUSH
4746: LD_VAR 0 4
4750: PPUSH
4751: LD_LOC 3
4755: PPUSH
4756: CALL 6774 0 5
4760: GO 4728
4762: POP
4763: POP
// place_all_soldiers ;
4764: CALL 4781 0 0
// place_all_scientistics ;
4768: CALL 4989 0 0
// place_all_mechanics ;
4772: CALL 5178 0 0
// end ;
4776: LD_VAR 0 1
4780: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
4781: LD_INT 0
4783: PPUSH
4784: PPUSH
4785: PPUSH
4786: PPUSH
4787: PPUSH
4788: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
4789: LD_ADDR_VAR 0 6
4793: PUSH
4794: LD_INT 22
4796: PUSH
4797: LD_LOC 1
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PUSH
4806: LD_INT 30
4808: PUSH
4809: LD_INT 32
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_INT 22
4832: PUSH
4833: LD_LOC 1
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 25
4844: PUSH
4845: LD_INT 1
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// if buildings >= units then
4861: LD_VAR 0 6
4865: PUSH
4866: LD_VAR 0 5
4870: GREATEREQUAL
4871: IFFALSE 4889
// max := 0 + units else
4873: LD_ADDR_VAR 0 4
4877: PUSH
4878: LD_INT 0
4880: PUSH
4881: LD_VAR 0 5
4885: PLUS
4886: ST_TO_ADDR
4887: GO 4903
// max := 0 + buildings ;
4889: LD_ADDR_VAR 0 4
4893: PUSH
4894: LD_INT 0
4896: PUSH
4897: LD_VAR 0 6
4901: PLUS
4902: ST_TO_ADDR
// i = 1 ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 1
4910: ST_TO_ADDR
// for un in units do
4911: LD_ADDR_VAR 0 2
4915: PUSH
4916: LD_VAR 0 5
4920: PUSH
4921: FOR_IN
4922: IFFALSE 4982
// begin if i <= max then
4924: LD_VAR 0 3
4928: PUSH
4929: LD_VAR 0 4
4933: LESSEQUAL
4934: IFFALSE 4966
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_VAR 0 6
4945: PUSH
4946: LD_VAR 0 3
4950: PUSH
4951: LD_VAR 0 6
4955: MOD
4956: PUSH
4957: LD_INT 1
4959: PLUS
4960: ARRAY
4961: PPUSH
4962: CALL_OW 120
// i := i + 1 ;
4966: LD_ADDR_VAR 0 3
4970: PUSH
4971: LD_VAR 0 3
4975: PUSH
4976: LD_INT 1
4978: PLUS
4979: ST_TO_ADDR
// end ;
4980: GO 4921
4982: POP
4983: POP
// end ;
4984: LD_VAR 0 1
4988: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
4989: LD_INT 0
4991: PPUSH
4992: PPUSH
4993: PPUSH
4994: PPUSH
4995: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
4996: LD_ADDR_VAR 0 5
5000: PUSH
5001: LD_INT 22
5003: PUSH
5004: LD_LOC 1
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 30
5018: PUSH
5019: LD_INT 8
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 30
5028: PUSH
5029: LD_INT 6
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: LIST
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PPUSH
5045: CALL_OW 69
5049: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5050: LD_ADDR_VAR 0 4
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_LOC 1
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PUSH
5067: LD_INT 25
5069: PUSH
5070: LD_INT 4
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PPUSH
5081: CALL_OW 69
5085: ST_TO_ADDR
// i = 1 ;
5086: LD_ADDR_VAR 0 3
5090: PUSH
5091: LD_INT 1
5093: ST_TO_ADDR
// for un in units do
5094: LD_ADDR_VAR 0 2
5098: PUSH
5099: LD_VAR 0 4
5103: PUSH
5104: FOR_IN
5105: IFFALSE 5171
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5107: LD_VAR 0 2
5111: PPUSH
5112: LD_VAR 0 5
5116: PUSH
5117: LD_VAR 0 3
5121: PUSH
5122: LD_VAR 0 5
5126: MOD
5127: PUSH
5128: LD_INT 1
5130: PLUS
5131: ARRAY
5132: PPUSH
5133: CALL_OW 120
// i := i + 1 ;
5137: LD_ADDR_VAR 0 3
5141: PUSH
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ST_TO_ADDR
// if i > ( units div 2 ) then
5151: LD_VAR 0 3
5155: PUSH
5156: LD_VAR 0 4
5160: PUSH
5161: LD_INT 2
5163: DIV
5164: GREATER
5165: IFFALSE 5169
// break ;
5167: GO 5171
// end ;
5169: GO 5104
5171: POP
5172: POP
// end ;
5173: LD_VAR 0 1
5177: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5178: LD_INT 0
5180: PPUSH
5181: PPUSH
5182: PPUSH
5183: PPUSH
5184: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5185: LD_ADDR_VAR 0 5
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_LOC 1
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: PUSH
5202: LD_INT 2
5204: PUSH
5205: LD_INT 30
5207: PUSH
5208: LD_INT 2
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 3
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: PPUSH
5234: CALL_OW 69
5238: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5239: LD_ADDR_VAR 0 4
5243: PUSH
5244: LD_INT 22
5246: PUSH
5247: LD_LOC 1
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: PUSH
5256: LD_INT 25
5258: PUSH
5259: LD_INT 3
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PPUSH
5270: CALL_OW 69
5274: ST_TO_ADDR
// i = 1 ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// for un in units do
5283: LD_ADDR_VAR 0 2
5287: PUSH
5288: LD_VAR 0 4
5292: PUSH
5293: FOR_IN
5294: IFFALSE 5342
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5296: LD_VAR 0 2
5300: PPUSH
5301: LD_VAR 0 5
5305: PUSH
5306: LD_VAR 0 3
5310: PUSH
5311: LD_VAR 0 5
5315: MOD
5316: PUSH
5317: LD_INT 1
5319: PLUS
5320: ARRAY
5321: PPUSH
5322: CALL_OW 120
// i := i + 1 ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_VAR 0 3
5335: PUSH
5336: LD_INT 1
5338: PLUS
5339: ST_TO_ADDR
// end ;
5340: GO 5293
5342: POP
5343: POP
// end ; end_of_file
5344: LD_VAR 0 1
5348: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_americans ; var un , class_list , members ; begin
5349: LD_INT 0
5351: PPUSH
5352: PPUSH
5353: PPUSH
5354: PPUSH
// cpu_side := us ;
5355: LD_ADDR_LOC 4
5359: PUSH
5360: LD_EXP 3
5364: ST_TO_ADDR
// cpu_nation := nation_american ;
5365: LD_ADDR_LOC 5
5369: PUSH
5370: LD_INT 1
5372: ST_TO_ADDR
// cpu_base := us_create ;
5373: LD_ADDR_LOC 6
5377: PUSH
5378: LD_INT 18
5380: ST_TO_ADDR
// members := difficulty * 2 ;
5381: LD_ADDR_VAR 0 4
5385: PUSH
5386: LD_OWVAR 67
5390: PUSH
5391: LD_INT 2
5393: MUL
5394: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
5395: LD_ADDR_VAR 0 3
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 3
5405: PUSH
5406: LD_INT 4
5408: PUSH
5409: LD_INT 2
5411: PUSH
5412: EMPTY
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: ST_TO_ADDR
// for un in class_list do
5418: LD_ADDR_VAR 0 2
5422: PUSH
5423: LD_VAR 0 3
5427: PUSH
5428: FOR_IN
5429: IFFALSE 5462
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5431: LD_LOC 4
5435: PPUSH
5436: LD_LOC 5
5440: PPUSH
5441: LD_VAR 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: LD_LOC 6
5455: PPUSH
5456: CALL 6774 0 5
5460: GO 5428
5462: POP
5463: POP
// create_units ( cpu_side , cpu_nation , class_mechanic , 2 , cpu_base ) ;
5464: LD_LOC 4
5468: PPUSH
5469: LD_LOC 5
5473: PPUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 2
5479: PPUSH
5480: LD_LOC 6
5484: PPUSH
5485: CALL 6774 0 5
// place_all_soldiers ;
5489: CALL 5506 0 0
// place_all_scientistics ;
5493: CALL 5714 0 0
// place_all_mechanics ;
5497: CALL 5903 0 0
// end ;
5501: LD_VAR 0 1
5505: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
5511: PPUSH
5512: PPUSH
5513: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5514: LD_ADDR_VAR 0 6
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_LOC 4
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 30
5533: PUSH
5534: LD_INT 32
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: CALL_OW 69
5549: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5550: LD_ADDR_VAR 0 5
5554: PUSH
5555: LD_INT 22
5557: PUSH
5558: LD_LOC 4
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 25
5569: PUSH
5570: LD_INT 1
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: PPUSH
5581: CALL_OW 69
5585: ST_TO_ADDR
// if buildings >= units then
5586: LD_VAR 0 6
5590: PUSH
5591: LD_VAR 0 5
5595: GREATEREQUAL
5596: IFFALSE 5614
// max := 0 + units else
5598: LD_ADDR_VAR 0 4
5602: PUSH
5603: LD_INT 0
5605: PUSH
5606: LD_VAR 0 5
5610: PLUS
5611: ST_TO_ADDR
5612: GO 5628
// max := 0 + buildings ;
5614: LD_ADDR_VAR 0 4
5618: PUSH
5619: LD_INT 0
5621: PUSH
5622: LD_VAR 0 6
5626: PLUS
5627: ST_TO_ADDR
// i = 1 ;
5628: LD_ADDR_VAR 0 3
5632: PUSH
5633: LD_INT 1
5635: ST_TO_ADDR
// for un in units do
5636: LD_ADDR_VAR 0 2
5640: PUSH
5641: LD_VAR 0 5
5645: PUSH
5646: FOR_IN
5647: IFFALSE 5707
// begin if i <= max then
5649: LD_VAR 0 3
5653: PUSH
5654: LD_VAR 0 4
5658: LESSEQUAL
5659: IFFALSE 5691
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5661: LD_VAR 0 2
5665: PPUSH
5666: LD_VAR 0 6
5670: PUSH
5671: LD_VAR 0 3
5675: PUSH
5676: LD_VAR 0 6
5680: MOD
5681: PUSH
5682: LD_INT 1
5684: PLUS
5685: ARRAY
5686: PPUSH
5687: CALL_OW 120
// i := i + 1 ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: LD_VAR 0 3
5700: PUSH
5701: LD_INT 1
5703: PLUS
5704: ST_TO_ADDR
// end ;
5705: GO 5646
5707: POP
5708: POP
// end ;
5709: LD_VAR 0 1
5713: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5714: LD_INT 0
5716: PPUSH
5717: PPUSH
5718: PPUSH
5719: PPUSH
5720: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5721: LD_ADDR_VAR 0 5
5725: PUSH
5726: LD_INT 22
5728: PUSH
5729: LD_LOC 4
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 30
5743: PUSH
5744: LD_INT 8
5746: PUSH
5747: EMPTY
5748: LIST
5749: LIST
5750: PUSH
5751: LD_INT 30
5753: PUSH
5754: LD_INT 6
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: LIST
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PPUSH
5770: CALL_OW 69
5774: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5775: LD_ADDR_VAR 0 4
5779: PUSH
5780: LD_INT 22
5782: PUSH
5783: LD_LOC 4
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PUSH
5792: LD_INT 25
5794: PUSH
5795: LD_INT 4
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: PPUSH
5806: CALL_OW 69
5810: ST_TO_ADDR
// i = 1 ;
5811: LD_ADDR_VAR 0 3
5815: PUSH
5816: LD_INT 1
5818: ST_TO_ADDR
// for un in units do
5819: LD_ADDR_VAR 0 2
5823: PUSH
5824: LD_VAR 0 4
5828: PUSH
5829: FOR_IN
5830: IFFALSE 5896
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5832: LD_VAR 0 2
5836: PPUSH
5837: LD_VAR 0 5
5841: PUSH
5842: LD_VAR 0 3
5846: PUSH
5847: LD_VAR 0 5
5851: MOD
5852: PUSH
5853: LD_INT 1
5855: PLUS
5856: ARRAY
5857: PPUSH
5858: CALL_OW 120
// i := i + 1 ;
5862: LD_ADDR_VAR 0 3
5866: PUSH
5867: LD_VAR 0 3
5871: PUSH
5872: LD_INT 1
5874: PLUS
5875: ST_TO_ADDR
// if i > ( units div 2 ) then
5876: LD_VAR 0 3
5880: PUSH
5881: LD_VAR 0 4
5885: PUSH
5886: LD_INT 2
5888: DIV
5889: GREATER
5890: IFFALSE 5894
// break ;
5892: GO 5896
// end ;
5894: GO 5829
5896: POP
5897: POP
// end ;
5898: LD_VAR 0 1
5902: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5903: LD_INT 0
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
5909: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5910: LD_ADDR_VAR 0 5
5914: PUSH
5915: LD_INT 22
5917: PUSH
5918: LD_LOC 4
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: PUSH
5927: LD_INT 2
5929: PUSH
5930: LD_INT 30
5932: PUSH
5933: LD_INT 2
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: PUSH
5940: LD_INT 30
5942: PUSH
5943: LD_INT 3
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PPUSH
5959: CALL_OW 69
5963: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5964: LD_ADDR_VAR 0 4
5968: PUSH
5969: LD_INT 22
5971: PUSH
5972: LD_LOC 4
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 25
5983: PUSH
5984: LD_INT 3
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PPUSH
5995: CALL_OW 69
5999: ST_TO_ADDR
// i = 1 ;
6000: LD_ADDR_VAR 0 3
6004: PUSH
6005: LD_INT 1
6007: ST_TO_ADDR
// for un in units do
6008: LD_ADDR_VAR 0 2
6012: PUSH
6013: LD_VAR 0 4
6017: PUSH
6018: FOR_IN
6019: IFFALSE 6067
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6021: LD_VAR 0 2
6025: PPUSH
6026: LD_VAR 0 5
6030: PUSH
6031: LD_VAR 0 3
6035: PUSH
6036: LD_VAR 0 5
6040: MOD
6041: PUSH
6042: LD_INT 1
6044: PLUS
6045: ARRAY
6046: PPUSH
6047: CALL_OW 120
// i := i + 1 ;
6051: LD_ADDR_VAR 0 3
6055: PUSH
6056: LD_VAR 0 3
6060: PUSH
6061: LD_INT 1
6063: PLUS
6064: ST_TO_ADDR
// end ;
6065: GO 6018
6067: POP
6068: POP
// end ; end_of_file
6069: LD_VAR 0 1
6073: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_arabians ; var un , class_list , members ; begin
6074: LD_INT 0
6076: PPUSH
6077: PPUSH
6078: PPUSH
6079: PPUSH
// cpu_side := ar ;
6080: LD_ADDR_LOC 7
6084: PUSH
6085: LD_EXP 4
6089: ST_TO_ADDR
// cpu_nation := nation_arabian ;
6090: LD_ADDR_LOC 8
6094: PUSH
6095: LD_INT 2
6097: ST_TO_ADDR
// cpu_base := ar_create ;
6098: LD_ADDR_LOC 9
6102: PUSH
6103: LD_INT 19
6105: ST_TO_ADDR
// members := difficulty + 1 ;
6106: LD_ADDR_VAR 0 4
6110: PUSH
6111: LD_OWVAR 67
6115: PUSH
6116: LD_INT 1
6118: PLUS
6119: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
6120: LD_ADDR_VAR 0 3
6124: PUSH
6125: LD_INT 1
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: LD_INT 4
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: ST_TO_ADDR
// for un in class_list do
6143: LD_ADDR_VAR 0 2
6147: PUSH
6148: LD_VAR 0 3
6152: PUSH
6153: FOR_IN
6154: IFFALSE 6187
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
6156: LD_LOC 7
6160: PPUSH
6161: LD_LOC 8
6165: PPUSH
6166: LD_VAR 0 2
6170: PPUSH
6171: LD_VAR 0 4
6175: PPUSH
6176: LD_LOC 9
6180: PPUSH
6181: CALL 6774 0 5
6185: GO 6153
6187: POP
6188: POP
// place_all_soldiers ;
6189: CALL 6206 0 0
// place_all_scientistics ;
6193: CALL 6414 0 0
// place_all_mechanics ;
6197: CALL 6603 0 0
// end ;
6201: LD_VAR 0 1
6205: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
6206: LD_INT 0
6208: PPUSH
6209: PPUSH
6210: PPUSH
6211: PPUSH
6212: PPUSH
6213: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
6214: LD_ADDR_VAR 0 6
6218: PUSH
6219: LD_INT 22
6221: PUSH
6222: LD_LOC 7
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: PUSH
6231: LD_INT 30
6233: PUSH
6234: LD_INT 32
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PPUSH
6245: CALL_OW 69
6249: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
6250: LD_ADDR_VAR 0 5
6254: PUSH
6255: LD_INT 22
6257: PUSH
6258: LD_LOC 7
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: LD_INT 25
6269: PUSH
6270: LD_INT 1
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: CALL_OW 69
6285: ST_TO_ADDR
// if buildings >= units then
6286: LD_VAR 0 6
6290: PUSH
6291: LD_VAR 0 5
6295: GREATEREQUAL
6296: IFFALSE 6314
// max := 0 + units else
6298: LD_ADDR_VAR 0 4
6302: PUSH
6303: LD_INT 0
6305: PUSH
6306: LD_VAR 0 5
6310: PLUS
6311: ST_TO_ADDR
6312: GO 6328
// max := 0 + buildings ;
6314: LD_ADDR_VAR 0 4
6318: PUSH
6319: LD_INT 0
6321: PUSH
6322: LD_VAR 0 6
6326: PLUS
6327: ST_TO_ADDR
// i = 1 ;
6328: LD_ADDR_VAR 0 3
6332: PUSH
6333: LD_INT 1
6335: ST_TO_ADDR
// for un in units do
6336: LD_ADDR_VAR 0 2
6340: PUSH
6341: LD_VAR 0 5
6345: PUSH
6346: FOR_IN
6347: IFFALSE 6407
// begin if i <= max then
6349: LD_VAR 0 3
6353: PUSH
6354: LD_VAR 0 4
6358: LESSEQUAL
6359: IFFALSE 6391
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6361: LD_VAR 0 2
6365: PPUSH
6366: LD_VAR 0 6
6370: PUSH
6371: LD_VAR 0 3
6375: PUSH
6376: LD_VAR 0 6
6380: MOD
6381: PUSH
6382: LD_INT 1
6384: PLUS
6385: ARRAY
6386: PPUSH
6387: CALL_OW 120
// i := i + 1 ;
6391: LD_ADDR_VAR 0 3
6395: PUSH
6396: LD_VAR 0 3
6400: PUSH
6401: LD_INT 1
6403: PLUS
6404: ST_TO_ADDR
// end ;
6405: GO 6346
6407: POP
6408: POP
// end ;
6409: LD_VAR 0 1
6413: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6414: LD_INT 0
6416: PPUSH
6417: PPUSH
6418: PPUSH
6419: PPUSH
6420: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6421: LD_ADDR_VAR 0 5
6425: PUSH
6426: LD_INT 22
6428: PUSH
6429: LD_LOC 7
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: LD_INT 30
6443: PUSH
6444: LD_INT 8
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PUSH
6451: LD_INT 30
6453: PUSH
6454: LD_INT 6
6456: PUSH
6457: EMPTY
6458: LIST
6459: LIST
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6475: LD_ADDR_VAR 0 4
6479: PUSH
6480: LD_INT 22
6482: PUSH
6483: LD_LOC 7
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: PUSH
6492: LD_INT 25
6494: PUSH
6495: LD_INT 4
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: PPUSH
6506: CALL_OW 69
6510: ST_TO_ADDR
// i = 1 ;
6511: LD_ADDR_VAR 0 3
6515: PUSH
6516: LD_INT 1
6518: ST_TO_ADDR
// for un in units do
6519: LD_ADDR_VAR 0 2
6523: PUSH
6524: LD_VAR 0 4
6528: PUSH
6529: FOR_IN
6530: IFFALSE 6596
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6532: LD_VAR 0 2
6536: PPUSH
6537: LD_VAR 0 5
6541: PUSH
6542: LD_VAR 0 3
6546: PUSH
6547: LD_VAR 0 5
6551: MOD
6552: PUSH
6553: LD_INT 1
6555: PLUS
6556: ARRAY
6557: PPUSH
6558: CALL_OW 120
// i := i + 1 ;
6562: LD_ADDR_VAR 0 3
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 1
6574: PLUS
6575: ST_TO_ADDR
// if i > ( units div 2 ) then
6576: LD_VAR 0 3
6580: PUSH
6581: LD_VAR 0 4
6585: PUSH
6586: LD_INT 2
6588: DIV
6589: GREATER
6590: IFFALSE 6594
// break ;
6592: GO 6596
// end ;
6594: GO 6529
6596: POP
6597: POP
// end ;
6598: LD_VAR 0 1
6602: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6603: LD_INT 0
6605: PPUSH
6606: PPUSH
6607: PPUSH
6608: PPUSH
6609: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6610: LD_ADDR_VAR 0 5
6614: PUSH
6615: LD_INT 22
6617: PUSH
6618: LD_LOC 7
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 2
6629: PUSH
6630: LD_INT 30
6632: PUSH
6633: LD_INT 2
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: LD_INT 30
6642: PUSH
6643: LD_INT 3
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: LIST
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: PPUSH
6659: CALL_OW 69
6663: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6664: LD_ADDR_VAR 0 4
6668: PUSH
6669: LD_INT 22
6671: PUSH
6672: LD_LOC 7
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: LD_INT 25
6683: PUSH
6684: LD_INT 3
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: PPUSH
6695: CALL_OW 69
6699: ST_TO_ADDR
// i = 1 ;
6700: LD_ADDR_VAR 0 3
6704: PUSH
6705: LD_INT 1
6707: ST_TO_ADDR
// for un in units do
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_VAR 0 4
6717: PUSH
6718: FOR_IN
6719: IFFALSE 6767
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6721: LD_VAR 0 2
6725: PPUSH
6726: LD_VAR 0 5
6730: PUSH
6731: LD_VAR 0 3
6735: PUSH
6736: LD_VAR 0 5
6740: MOD
6741: PUSH
6742: LD_INT 1
6744: PLUS
6745: ARRAY
6746: PPUSH
6747: CALL_OW 120
// i := i + 1 ;
6751: LD_ADDR_VAR 0 3
6755: PUSH
6756: LD_VAR 0 3
6760: PUSH
6761: LD_INT 1
6763: PLUS
6764: ST_TO_ADDR
// end ;
6765: GO 6718
6767: POP
6768: POP
// end ; end_of_file
6769: LD_VAR 0 1
6773: RET
// export function create_units ( side , nation , class_n , num , area ) ; var i , un , lev ; begin
6774: LD_INT 0
6776: PPUSH
6777: PPUSH
6778: PPUSH
6779: PPUSH
// if class_n = class_scientistic then
6780: LD_VAR 0 3
6784: PUSH
6785: LD_INT 4
6787: EQUAL
6788: IFFALSE 6842
// begin lev := [ 3 , 6 , 10 ] [ difficulty ] ;
6790: LD_ADDR_VAR 0 9
6794: PUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 6
6800: PUSH
6801: LD_INT 10
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: PUSH
6809: LD_OWVAR 67
6813: ARRAY
6814: ST_TO_ADDR
// num := [ 2 , 4 , 6 ] [ difficulty ] ;
6815: LD_ADDR_VAR 0 4
6819: PUSH
6820: LD_INT 2
6822: PUSH
6823: LD_INT 4
6825: PUSH
6826: LD_INT 6
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: LIST
6833: PUSH
6834: LD_OWVAR 67
6838: ARRAY
6839: ST_TO_ADDR
// end else
6840: GO 6912
// if class_n = class_soldier then
6842: LD_VAR 0 3
6846: PUSH
6847: LD_INT 1
6849: EQUAL
6850: IFFALSE 6887
// begin lev := [ 5 , 7 , 10 ] [ difficulty ] ;
6852: LD_ADDR_VAR 0 9
6856: PUSH
6857: LD_INT 5
6859: PUSH
6860: LD_INT 7
6862: PUSH
6863: LD_INT 10
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PUSH
6871: LD_OWVAR 67
6875: ARRAY
6876: ST_TO_ADDR
// num := 6 ;
6877: LD_ADDR_VAR 0 4
6881: PUSH
6882: LD_INT 6
6884: ST_TO_ADDR
// end else
6885: GO 6912
// lev := [ 4 , 6 , 10 ] [ difficulty ] ;
6887: LD_ADDR_VAR 0 9
6891: PUSH
6892: LD_INT 4
6894: PUSH
6895: LD_INT 6
6897: PUSH
6898: LD_INT 10
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: LIST
6905: PUSH
6906: LD_OWVAR 67
6910: ARRAY
6911: ST_TO_ADDR
// uc_side := side ;
6912: LD_ADDR_OWVAR 20
6916: PUSH
6917: LD_VAR 0 1
6921: ST_TO_ADDR
// uc_nation := nation ;
6922: LD_ADDR_OWVAR 21
6926: PUSH
6927: LD_VAR 0 2
6931: ST_TO_ADDR
// for i = 1 to num do
6932: LD_ADDR_VAR 0 7
6936: PUSH
6937: DOUBLE
6938: LD_INT 1
6940: DEC
6941: ST_TO_ADDR
6942: LD_VAR 0 4
6946: PUSH
6947: FOR_TO
6948: IFFALSE 7093
// begin uc_direction := Rand ( 0 , 5 ) ;
6950: LD_ADDR_OWVAR 24
6954: PUSH
6955: LD_INT 0
6957: PPUSH
6958: LD_INT 5
6960: PPUSH
6961: CALL_OW 12
6965: ST_TO_ADDR
// case class_n of 1 :
6966: LD_VAR 0 3
6970: PUSH
6971: LD_INT 1
6973: DOUBLE
6974: EQUAL
6975: IFTRUE 6979
6977: GO 6994
6979: POP
// PrepareSoldier ( 0 , lev ) ; 2 :
6980: LD_INT 0
6982: PPUSH
6983: LD_VAR 0 9
6987: PPUSH
6988: CALL_OW 381
6992: GO 7064
6994: LD_INT 2
6996: DOUBLE
6997: EQUAL
6998: IFTRUE 7002
7000: GO 7017
7002: POP
// PrepareEngineer ( 0 , lev ) ; 3 :
7003: LD_INT 0
7005: PPUSH
7006: LD_VAR 0 9
7010: PPUSH
7011: CALL_OW 382
7015: GO 7064
7017: LD_INT 3
7019: DOUBLE
7020: EQUAL
7021: IFTRUE 7025
7023: GO 7040
7025: POP
// PrepareMechanic ( 0 , lev ) ; 4 :
7026: LD_INT 0
7028: PPUSH
7029: LD_VAR 0 9
7033: PPUSH
7034: CALL_OW 383
7038: GO 7064
7040: LD_INT 4
7042: DOUBLE
7043: EQUAL
7044: IFTRUE 7048
7046: GO 7063
7048: POP
// PrepareScientist ( 0 , lev ) ; end ;
7049: LD_INT 0
7051: PPUSH
7052: LD_VAR 0 9
7056: PPUSH
7057: CALL_OW 384
7061: GO 7064
7063: POP
// un := CreateHuman ;
7064: LD_ADDR_VAR 0 8
7068: PUSH
7069: CALL_OW 44
7073: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7074: LD_VAR 0 8
7078: PPUSH
7079: LD_VAR 0 5
7083: PPUSH
7084: LD_INT 0
7086: PPUSH
7087: CALL_OW 49
// end ;
7091: GO 6947
7093: POP
7094: POP
// end ;
7095: LD_VAR 0 6
7099: RET
// export function prepare_apemans ; var ape , i ; begin
7100: LD_INT 0
7102: PPUSH
7103: PPUSH
7104: PPUSH
// for i = 1 to ( 6 - difficulty ) do
7105: LD_ADDR_VAR 0 3
7109: PUSH
7110: DOUBLE
7111: LD_INT 1
7113: DEC
7114: ST_TO_ADDR
7115: LD_INT 6
7117: PUSH
7118: LD_OWVAR 67
7122: MINUS
7123: PUSH
7124: FOR_TO
7125: IFFALSE 7325
// begin uc_side := neutral ;
7127: LD_ADDR_OWVAR 20
7131: PUSH
7132: LD_EXP 6
7136: ST_TO_ADDR
// uc_nation := nation_nature ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 0
7144: ST_TO_ADDR
// hc_class := class_apeman ;
7145: LD_ADDR_OWVAR 28
7149: PUSH
7150: LD_INT 12
7152: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) ] ;
7153: LD_ADDR_OWVAR 30
7157: PUSH
7158: LD_INT 1
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 12
7168: PUSH
7169: LD_INT 1
7171: PPUSH
7172: LD_INT 2
7174: PPUSH
7175: CALL_OW 12
7179: PUSH
7180: LD_INT 1
7182: PPUSH
7183: LD_INT 2
7185: PPUSH
7186: CALL_OW 12
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 2
7196: PPUSH
7197: CALL_OW 12
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: ST_TO_ADDR
// hc_skills := [ 3 , 3 , 3 , 3 ] ;
7208: LD_ADDR_OWVAR 31
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 3
7218: PUSH
7219: LD_INT 3
7221: PUSH
7222: LD_INT 3
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
7231: LD_ADDR_OWVAR 29
7235: PUSH
7236: LD_INT 10
7238: PUSH
7239: LD_INT 12
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: ST_TO_ADDR
// hc_sex := [ sex_female , sex_male ] [ Rand ( 1 , 2 ) ] ;
7246: LD_ADDR_OWVAR 27
7250: PUSH
7251: LD_INT 2
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 1
7263: PPUSH
7264: LD_INT 2
7266: PPUSH
7267: CALL_OW 12
7271: ARRAY
7272: ST_TO_ADDR
// hc_importance := 0 ;
7273: LD_ADDR_OWVAR 32
7277: PUSH
7278: LD_INT 0
7280: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
7281: LD_ADDR_OWVAR 35
7285: PUSH
7286: LD_INT 20
7288: NEG
7289: PPUSH
7290: LD_INT 20
7292: PPUSH
7293: CALL_OW 12
7297: ST_TO_ADDR
// ape := CreateHuman ;
7298: LD_ADDR_VAR 0 2
7302: PUSH
7303: CALL_OW 44
7307: ST_TO_ADDR
// PlaceUnitArea ( ape , apeman_forest , false ) ;
7308: LD_VAR 0 2
7312: PPUSH
7313: LD_INT 32
7315: PPUSH
7316: LD_INT 0
7318: PPUSH
7319: CALL_OW 49
// end ;
7323: GO 7124
7325: POP
7326: POP
// end ; end_of_file
7327: LD_VAR 0 1
7331: RET
// var alien_tower_spoted ; export function starting_scene ; var check_time ; begin
7332: LD_INT 0
7334: PPUSH
7335: PPUSH
// CenterNowOnXY ( 75 , 27 ) ;
7336: LD_INT 75
7338: PPUSH
7339: LD_INT 27
7341: PPUSH
7342: CALL_OW 86
// wait ( 0 0$1 ) ;
7346: LD_INT 35
7348: PPUSH
7349: CALL_OW 67
// InGameOn ;
7353: CALL_OW 8
// ComMoveToArea ( IsInUnit ( Burlak ) , burlak_panorama_area ) ;
7357: LD_EXP 12
7361: PPUSH
7362: CALL_OW 310
7366: PPUSH
7367: LD_INT 8
7369: PPUSH
7370: CALL_OW 113
// ComMoveToArea ( IsInUnit ( MacMillan ) , jmm_panorama_area ) ;
7374: LD_EXP 13
7378: PPUSH
7379: CALL_OW 310
7383: PPUSH
7384: LD_INT 28
7386: PPUSH
7387: CALL_OW 113
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
7391: LD_EXP 13
7395: PUSH
7396: LD_EXP 12
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PPUSH
7405: CALL_OW 85
// repeat wait ( 20 ) ;
7409: LD_INT 20
7411: PPUSH
7412: CALL_OW 67
// until IsInArea ( Burlak , burlak_panorama_area ) and IsInArea ( MacMillan , jmm_panorama_area ) ;
7416: LD_EXP 12
7420: PPUSH
7421: LD_INT 8
7423: PPUSH
7424: CALL_OW 308
7428: PUSH
7429: LD_EXP 13
7433: PPUSH
7434: LD_INT 28
7436: PPUSH
7437: CALL_OW 308
7441: AND
7442: IFFALSE 7409
// ComExitVehicle ( [ Burlak , MacMillan ] ) ;
7444: LD_EXP 12
7448: PUSH
7449: LD_EXP 13
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PPUSH
7458: CALL_OW 121
// while IsInUnit ( Burlak ) or IsInUnit ( MacMillan ) do
7462: LD_EXP 12
7466: PPUSH
7467: CALL_OW 310
7471: PUSH
7472: LD_EXP 13
7476: PPUSH
7477: CALL_OW 310
7481: OR
7482: IFFALSE 7493
// wait ( 5 ) ;
7484: LD_INT 5
7486: PPUSH
7487: CALL_OW 67
7491: GO 7462
// wait ( 10 ) ;
7493: LD_INT 10
7495: PPUSH
7496: CALL_OW 67
// ComMoveToArea ( Burlak , burlak_talking_panorama ) ;
7500: LD_EXP 12
7504: PPUSH
7505: LD_INT 9
7507: PPUSH
7508: CALL_OW 113
// ComMoveToArea ( MacMillan , jmm_talking_panorama ) ;
7512: LD_EXP 13
7516: PPUSH
7517: LD_INT 29
7519: PPUSH
7520: CALL_OW 113
// check_time := TICK ;
7524: LD_ADDR_VAR 0 2
7528: PUSH
7529: LD_OWVAR 1
7533: ST_TO_ADDR
// repeat ComHold ( FilterUnitsInArea ( burlak_talking_panorama , [ [ f_side , you ] ] ) ) ;
7534: LD_INT 9
7536: PPUSH
7537: LD_INT 22
7539: PUSH
7540: LD_EXP 1
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: EMPTY
7550: LIST
7551: PPUSH
7552: CALL_OW 70
7556: PPUSH
7557: CALL_OW 140
// ComHold ( FilterUnitsInArea ( jmm_talking_panorama , [ [ f_side , you ] ] ) ) ;
7561: LD_INT 29
7563: PPUSH
7564: LD_INT 22
7566: PUSH
7567: LD_EXP 1
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: PPUSH
7579: CALL_OW 70
7583: PPUSH
7584: CALL_OW 140
// wait ( 0 0$1 ) ;
7588: LD_INT 35
7590: PPUSH
7591: CALL_OW 67
// until ( IsInArea ( Burlak , burlak_talking_panorama ) and IsInArea ( MacMillan , jmm_talking_panorama ) ) or ( check_time < ( TICK - 0 0$4 ) ) ;
7595: LD_EXP 12
7599: PPUSH
7600: LD_INT 9
7602: PPUSH
7603: CALL_OW 308
7607: PUSH
7608: LD_EXP 13
7612: PPUSH
7613: LD_INT 29
7615: PPUSH
7616: CALL_OW 308
7620: AND
7621: PUSH
7622: LD_VAR 0 2
7626: PUSH
7627: LD_OWVAR 1
7631: PUSH
7632: LD_INT 140
7634: MINUS
7635: LESS
7636: OR
7637: IFFALSE 7534
// ComTurnUnit ( MacMillan , Burlak ) ;
7639: LD_EXP 13
7643: PPUSH
7644: LD_EXP 12
7648: PPUSH
7649: CALL_OW 119
// ComTurnUnit ( Burlak , MacMillan ) ;
7653: LD_EXP 12
7657: PPUSH
7658: LD_EXP 13
7662: PPUSH
7663: CALL_OW 119
// CenterOnXY ( 77 , 31 ) ;
7667: LD_INT 77
7669: PPUSH
7670: LD_INT 31
7672: PPUSH
7673: CALL_OW 84
// wait ( 10 ) ;
7677: LD_INT 10
7679: PPUSH
7680: CALL_OW 67
// InGameOff ;
7684: CALL_OW 9
// DialogueOn ;
7688: CALL_OW 6
// interface_hidden := true ;
7692: LD_ADDR_OWVAR 54
7696: PUSH
7697: LD_INT 1
7699: ST_TO_ADDR
// case camp of 4 :
7700: LD_EXP 7
7704: PUSH
7705: LD_INT 4
7707: DOUBLE
7708: EQUAL
7709: IFTRUE 7713
7711: GO 7764
7713: POP
// begin Say ( MacMillan , DStart-JMM-JMM-1 ) ;
7714: LD_EXP 13
7718: PPUSH
7719: LD_STRING DStart-JMM-JMM-1
7721: PPUSH
7722: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
7726: LD_EXP 12
7730: PPUSH
7731: LD_STRING DStart-JMM-Bur-1
7733: PPUSH
7734: CALL_OW 88
// Say ( MacMillan , DStart-JMM-JMM-2 ) ;
7738: LD_EXP 13
7742: PPUSH
7743: LD_STRING DStart-JMM-JMM-2
7745: PPUSH
7746: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
7750: LD_EXP 12
7754: PPUSH
7755: LD_STRING DStart-JMM-Bur-2
7757: PPUSH
7758: CALL_OW 88
// end ; 6 :
7762: GO 7812
7764: LD_INT 6
7766: DOUBLE
7767: EQUAL
7768: IFTRUE 7772
7770: GO 7811
7772: POP
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
7773: LD_EXP 12
7777: PPUSH
7778: LD_STRING DStart-Burlak-Bur-1
7780: PPUSH
7781: CALL_OW 88
// Say ( Macmillan , DStart-Burlak-JMM-1 ) ;
7785: LD_EXP 13
7789: PPUSH
7790: LD_STRING DStart-Burlak-JMM-1
7792: PPUSH
7793: CALL_OW 88
// Say ( Burlak , DStart-Burlak-Bur-2 ) ;
7797: LD_EXP 12
7801: PPUSH
7802: LD_STRING DStart-Burlak-Bur-2
7804: PPUSH
7805: CALL_OW 88
// end ; end ;
7809: GO 7812
7811: POP
// SaveForQuickRestart ;
7812: CALL_OW 22
// wait ( 20 ) ;
7816: LD_INT 20
7818: PPUSH
7819: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
7823: LD_STRING MStart
7825: PPUSH
7826: CALL_OW 337
// interface_hidden := false ;
7830: LD_ADDR_OWVAR 54
7834: PUSH
7835: LD_INT 0
7837: ST_TO_ADDR
// DialogueOff ;
7838: CALL_OW 7
// us_researched := false ;
7842: LD_ADDR_EXP 61
7846: PUSH
7847: LD_INT 0
7849: ST_TO_ADDR
// us_researched := true ;
7850: LD_ADDR_EXP 61
7854: PUSH
7855: LD_INT 1
7857: ST_TO_ADDR
// omar_in_contact := false ;
7858: LD_ADDR_EXP 64
7862: PUSH
7863: LD_INT 0
7865: ST_TO_ADDR
// alien_tower_spoted := false ;
7866: LD_ADDR_LOC 10
7870: PUSH
7871: LD_INT 0
7873: ST_TO_ADDR
// one_enabled := false ;
7874: LD_ADDR_EXP 63
7878: PUSH
7879: LD_INT 0
7881: ST_TO_ADDR
// end ;
7882: LD_VAR 0 1
7886: RET
// every 0 0$2.3 trigger See ( you , al_tower ) do var un , sol , sci ;
7887: LD_EXP 1
7891: PPUSH
7892: LD_INT 108
7894: PPUSH
7895: CALL_OW 292
7899: IFFALSE 8405
7901: GO 7903
7903: DISABLE
7904: LD_INT 0
7906: PPUSH
7907: PPUSH
7908: PPUSH
// begin repeat wait ( 0 0$1 ) ;
7909: LD_INT 35
7911: PPUSH
7912: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] , f_not , [ f_inside ] ] ) ;
7916: LD_INT 22
7918: PUSH
7919: LD_EXP 4
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: LD_INT 21
7930: PUSH
7931: LD_INT 1
7933: PUSH
7934: EMPTY
7935: LIST
7936: LIST
7937: PUSH
7938: LD_INT 50
7940: PUSH
7941: EMPTY
7942: LIST
7943: PUSH
7944: LD_INT 3
7946: PUSH
7947: LD_INT 54
7949: PUSH
7950: EMPTY
7951: LIST
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 69
7964: NOT
7965: IFFALSE 7909
// wait ( 0 0$1 ) ;
7967: LD_INT 35
7969: PPUSH
7970: CALL_OW 67
// cpu_list := cpu_list diff ar ;
7974: LD_ADDR_EXP 8
7978: PUSH
7979: LD_EXP 8
7983: PUSH
7984: LD_EXP 4
7988: DIFF
7989: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
7990: LD_ADDR_VAR 0 1
7994: PUSH
7995: LD_INT 22
7997: PUSH
7998: LD_EXP 1
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 26
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: PUSH
8026: LD_EXP 13
8030: PUSH
8031: LD_EXP 12
8035: PUSH
8036: LD_EXP 14
8040: PUSH
8041: LD_EXP 15
8045: PUSH
8046: LD_INT 0
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: LIST
8053: LIST
8054: LIST
8055: DIFF
8056: ST_TO_ADDR
// if un then
8057: LD_VAR 0 1
8061: IFFALSE 8081
// sol := FindMaxSkill ( un , skill_combat ) ;
8063: LD_ADDR_VAR 0 2
8067: PUSH
8068: LD_VAR 0 1
8072: PPUSH
8073: LD_INT 1
8075: PPUSH
8076: CALL_OW 433
8080: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , sol , 0 ] ;
8081: LD_ADDR_VAR 0 1
8085: PUSH
8086: LD_INT 22
8088: PUSH
8089: LD_EXP 1
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 26
8100: PUSH
8101: LD_INT 1
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PPUSH
8112: CALL_OW 69
8116: PUSH
8117: LD_EXP 13
8121: PUSH
8122: LD_EXP 12
8126: PUSH
8127: LD_EXP 14
8131: PUSH
8132: LD_EXP 15
8136: PUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 0
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: DIFF
8153: ST_TO_ADDR
// if un then
8154: LD_VAR 0 1
8158: IFFALSE 8178
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: LD_VAR 0 1
8169: PPUSH
8170: LD_INT 4
8172: PPUSH
8173: CALL_OW 433
8177: ST_TO_ADDR
// PlaceSeeing ( 248 , 183 , you , 10 ) ;
8178: LD_INT 248
8180: PPUSH
8181: LD_INT 183
8183: PPUSH
8184: LD_EXP 1
8188: PPUSH
8189: LD_INT 10
8191: PPUSH
8192: CALL_OW 330
// CenterOnUnits ( al_tower ) ;
8196: LD_INT 108
8198: PPUSH
8199: CALL_OW 85
// DialogueOn ;
8203: CALL_OW 6
// interface_hidden := true ;
8207: LD_ADDR_OWVAR 54
8211: PUSH
8212: LD_INT 1
8214: ST_TO_ADDR
// Say ( sol , DAlienBase-Rsol1-1 ) ;
8215: LD_VAR 0 2
8219: PPUSH
8220: LD_STRING DAlienBase-Rsol1-1
8222: PPUSH
8223: CALL_OW 88
// case camp of 4 :
8227: LD_EXP 7
8231: PUSH
8232: LD_INT 4
8234: DOUBLE
8235: EQUAL
8236: IFTRUE 8240
8238: GO 8291
8240: POP
// begin Say ( MacMillan , DAlienBase-JMM-1 ) ;
8241: LD_EXP 13
8245: PPUSH
8246: LD_STRING DAlienBase-JMM-1
8248: PPUSH
8249: CALL_OW 88
// Say ( Roth , DAlienBase-Roth-1 ) ;
8253: LD_EXP 14
8257: PPUSH
8258: LD_STRING DAlienBase-Roth-1
8260: PPUSH
8261: CALL_OW 88
// if not IsOK ( Roth ) then
8265: LD_EXP 14
8269: PPUSH
8270: CALL_OW 302
8274: NOT
8275: IFFALSE 8289
// Say ( sci , DAlienBase-Sci1-1 ) ;
8277: LD_VAR 0 3
8281: PPUSH
8282: LD_STRING DAlienBase-Sci1-1
8284: PPUSH
8285: CALL_OW 88
// end ; 6 :
8289: GO 8351
8291: LD_INT 6
8293: DOUBLE
8294: EQUAL
8295: IFTRUE 8299
8297: GO 8350
8299: POP
// begin Say ( Burlak , DAlienBase-Bur-1 ) ;
8300: LD_EXP 12
8304: PPUSH
8305: LD_STRING DAlienBase-Bur-1
8307: PPUSH
8308: CALL_OW 88
// Say ( Gossudarov , DAlienBase-Gos-1 ) ;
8312: LD_EXP 15
8316: PPUSH
8317: LD_STRING DAlienBase-Gos-1
8319: PPUSH
8320: CALL_OW 88
// if not IsOK ( Gossudarov ) then
8324: LD_EXP 15
8328: PPUSH
8329: CALL_OW 302
8333: NOT
8334: IFFALSE 8348
// Say ( sci , DAlienBase-Sci1-1 ) ;
8336: LD_VAR 0 3
8340: PPUSH
8341: LD_STRING DAlienBase-Sci1-1
8343: PPUSH
8344: CALL_OW 88
// end ; end ;
8348: GO 8351
8350: POP
// SetSide ( al_tower , you ) ;
8351: LD_INT 108
8353: PPUSH
8354: LD_EXP 1
8358: PPUSH
8359: CALL_OW 235
// RemoveSeeing ( 248 , 183 , you ) ;
8363: LD_INT 248
8365: PPUSH
8366: LD_INT 183
8368: PPUSH
8369: LD_EXP 1
8373: PPUSH
8374: CALL_OW 331
// interface_hidden := false ;
8378: LD_ADDR_OWVAR 54
8382: PUSH
8383: LD_INT 0
8385: ST_TO_ADDR
// DialogueOff ;
8386: CALL_OW 7
// Hint ( ArtefactBuilding ) ;
8390: LD_STRING ArtefactBuilding
8392: PPUSH
8393: CALL_OW 339
// alien_tower_spoted := true ;
8397: LD_ADDR_LOC 10
8401: PUSH
8402: LD_INT 1
8404: ST_TO_ADDR
// end ;
8405: PPOPN 3
8407: END
// every 0 0$4.6 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] , [ f_lives , 1000 ] ] ) and alien_tower_spoted do var un , sci ;
8408: LD_INT 22
8410: PUSH
8411: LD_EXP 1
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 30
8425: PUSH
8426: LD_INT 6
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: PUSH
8433: LD_INT 30
8435: PUSH
8436: LD_INT 7
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PUSH
8443: EMPTY
8444: LIST
8445: LIST
8446: LIST
8447: PUSH
8448: LD_INT 24
8450: PUSH
8451: LD_INT 1000
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PPUSH
8463: CALL_OW 69
8467: PUSH
8468: LD_LOC 10
8472: AND
8473: IFFALSE 8741
8475: GO 8477
8477: DISABLE
8478: LD_INT 0
8480: PPUSH
8481: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8482: LD_ADDR_VAR 0 1
8486: PUSH
8487: LD_INT 22
8489: PUSH
8490: LD_EXP 1
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: PUSH
8499: LD_INT 26
8501: PUSH
8502: LD_INT 1
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: EMPTY
8510: LIST
8511: LIST
8512: PPUSH
8513: CALL_OW 69
8517: PUSH
8518: LD_EXP 13
8522: PUSH
8523: LD_EXP 12
8527: PUSH
8528: LD_EXP 14
8532: PUSH
8533: LD_EXP 15
8537: PUSH
8538: LD_INT 0
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: DIFF
8548: ST_TO_ADDR
// if un then
8549: LD_VAR 0 1
8553: IFFALSE 8573
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8555: LD_ADDR_VAR 0 2
8559: PUSH
8560: LD_VAR 0 1
8564: PPUSH
8565: LD_INT 4
8567: PPUSH
8568: CALL_OW 433
8572: ST_TO_ADDR
// CenterOnUnits ( al_tower ) ;
8573: LD_INT 108
8575: PPUSH
8576: CALL_OW 85
// DialogueOn ;
8580: CALL_OW 6
// interface_hidden := true ;
8584: LD_ADDR_OWVAR 54
8588: PUSH
8589: LD_INT 1
8591: ST_TO_ADDR
// case camp of 4 :
8592: LD_EXP 7
8596: PUSH
8597: LD_INT 4
8599: DOUBLE
8600: EQUAL
8601: IFTRUE 8605
8603: GO 8645
8605: POP
// if IsOK ( Gossudarov ) then
8606: LD_EXP 15
8610: PPUSH
8611: CALL_OW 302
8615: IFFALSE 8631
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
8617: LD_EXP 15
8621: PPUSH
8622: LD_STRING DAlieBaseNotReady-Gos-1
8624: PPUSH
8625: CALL_OW 88
8629: GO 8643
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) ; 6 :
8631: LD_EXP 14
8635: PPUSH
8636: LD_STRING DAlieBaseNotReady-Roth-1
8638: PPUSH
8639: CALL_OW 88
8643: GO 8694
8645: LD_INT 6
8647: DOUBLE
8648: EQUAL
8649: IFTRUE 8653
8651: GO 8693
8653: POP
// if IsOK ( Roth ) then
8654: LD_EXP 14
8658: PPUSH
8659: CALL_OW 302
8663: IFFALSE 8679
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
8665: LD_EXP 14
8669: PPUSH
8670: LD_STRING DAlieBaseNotReady-Roth-1
8672: PPUSH
8673: CALL_OW 88
8677: GO 8691
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) ; end ;
8679: LD_EXP 15
8683: PPUSH
8684: LD_STRING DAlieBaseNotReady-Gos-1
8686: PPUSH
8687: CALL_OW 88
8691: GO 8694
8693: POP
// if not ( IsOK ( Gossudarov ) or IsOK ( Roth ) ) then
8694: LD_EXP 15
8698: PPUSH
8699: CALL_OW 302
8703: PUSH
8704: LD_EXP 14
8708: PPUSH
8709: CALL_OW 302
8713: OR
8714: NOT
8715: IFFALSE 8729
// Say ( sci , DAlieBaseNotReady-RSci1-1 ) ;
8717: LD_VAR 0 2
8721: PPUSH
8722: LD_STRING DAlieBaseNotReady-RSci1-1
8724: PPUSH
8725: CALL_OW 88
// interface_hidden := false ;
8729: LD_ADDR_OWVAR 54
8733: PUSH
8734: LD_INT 0
8736: ST_TO_ADDR
// DialogueOff ;
8737: CALL_OW 7
// end ;
8741: PPOPN 2
8743: END
// every 0 0$8.7 trigger GetTech ( tech_Artifact , you ) = state_researched do var un , lab , list ;
8744: LD_INT 24
8746: PPUSH
8747: LD_EXP 1
8751: PPUSH
8752: CALL_OW 321
8756: PUSH
8757: LD_INT 2
8759: EQUAL
8760: IFFALSE 8898
8762: GO 8764
8764: DISABLE
8765: LD_INT 0
8767: PPUSH
8768: PPUSH
8769: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
8770: LD_ADDR_VAR 0 3
8774: PUSH
8775: LD_INT 22
8777: PUSH
8778: LD_EXP 1
8782: PUSH
8783: EMPTY
8784: LIST
8785: LIST
8786: PUSH
8787: LD_INT 2
8789: PUSH
8790: LD_INT 30
8792: PUSH
8793: LD_INT 6
8795: PUSH
8796: EMPTY
8797: LIST
8798: LIST
8799: PUSH
8800: LD_INT 30
8802: PUSH
8803: LD_INT 7
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: PUSH
8810: LD_INT 30
8812: PUSH
8813: LD_INT 8
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 69
8834: ST_TO_ADDR
// lab := false ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_INT 0
8842: ST_TO_ADDR
// for un in list do
8843: LD_ADDR_VAR 0 1
8847: PUSH
8848: LD_VAR 0 3
8852: PUSH
8853: FOR_IN
8854: IFFALSE 8883
// if GetLives ( un ) = 1000 then
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 256
8865: PUSH
8866: LD_INT 1000
8868: EQUAL
8869: IFFALSE 8881
// lab := un ;
8871: LD_ADDR_VAR 0 2
8875: PUSH
8876: LD_VAR 0 1
8880: ST_TO_ADDR
8881: GO 8853
8883: POP
8884: POP
// if lab then
8885: LD_VAR 0 2
8889: IFFALSE 8897
// begin Talking_About_Artefact ;
8891: CALL 8901 0 0
// exit ;
8895: GO 8898
// end ; enable ;
8897: ENABLE
// end ;
8898: PPOPN 3
8900: END
// export function Talking_About_Artefact ; var un , ru_sci , us_sci , your_depot ; begin
8901: LD_INT 0
8903: PPUSH
8904: PPUSH
8905: PPUSH
8906: PPUSH
8907: PPUSH
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
8908: LD_ADDR_VAR 0 2
8912: PUSH
8913: LD_INT 22
8915: PUSH
8916: LD_EXP 1
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 23
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 26
8937: PUSH
8938: LD_INT 1
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: PPUSH
8950: CALL_OW 69
8954: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8955: LD_ADDR_VAR 0 2
8959: PUSH
8960: LD_VAR 0 2
8964: PUSH
8965: LD_EXP 13
8969: PUSH
8970: LD_EXP 12
8974: PUSH
8975: LD_EXP 14
8979: PUSH
8980: LD_EXP 15
8984: PUSH
8985: LD_INT 0
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: LIST
8992: LIST
8993: LIST
8994: DIFF
8995: ST_TO_ADDR
// if un then
8996: LD_VAR 0 2
9000: IFFALSE 9020
// ru_sci := FindMaxSkill ( un , skill_scientistic ) ;
9002: LD_ADDR_VAR 0 3
9006: PUSH
9007: LD_VAR 0 2
9011: PPUSH
9012: LD_INT 4
9014: PPUSH
9015: CALL_OW 433
9019: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9020: LD_ADDR_VAR 0 2
9024: PUSH
9025: LD_INT 22
9027: PUSH
9028: LD_EXP 1
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 23
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: LD_INT 26
9049: PUSH
9050: LD_INT 1
9052: PUSH
9053: EMPTY
9054: LIST
9055: LIST
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PPUSH
9062: CALL_OW 69
9066: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9067: LD_ADDR_VAR 0 2
9071: PUSH
9072: LD_VAR 0 2
9076: PUSH
9077: LD_EXP 13
9081: PUSH
9082: LD_EXP 12
9086: PUSH
9087: LD_EXP 14
9091: PUSH
9092: LD_EXP 15
9096: PUSH
9097: LD_INT 0
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: LIST
9104: LIST
9105: LIST
9106: DIFF
9107: ST_TO_ADDR
// if un then
9108: LD_VAR 0 2
9112: IFFALSE 9132
// us_sci := FindMaxSkill ( un , skill_scientistic ) ;
9114: LD_ADDR_VAR 0 4
9118: PUSH
9119: LD_VAR 0 2
9123: PPUSH
9124: LD_INT 4
9126: PPUSH
9127: CALL_OW 433
9131: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9132: LD_ADDR_VAR 0 2
9136: PUSH
9137: LD_INT 22
9139: PUSH
9140: LD_EXP 1
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PUSH
9149: LD_INT 2
9151: PUSH
9152: LD_INT 30
9154: PUSH
9155: LD_INT 0
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: PUSH
9162: LD_INT 30
9164: PUSH
9165: LD_INT 1
9167: PUSH
9168: EMPTY
9169: LIST
9170: LIST
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: LIST
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PPUSH
9181: CALL_OW 69
9185: ST_TO_ADDR
// if un then
9186: LD_VAR 0 2
9190: IFFALSE 9206
// your_depot := un [ 1 ] ;
9192: LD_ADDR_VAR 0 5
9196: PUSH
9197: LD_VAR 0 2
9201: PUSH
9202: LD_INT 1
9204: ARRAY
9205: ST_TO_ADDR
// CenterOnUnits ( Burlak ) ;
9206: LD_EXP 12
9210: PPUSH
9211: CALL_OW 85
// DialogueOn ;
9215: CALL_OW 6
// interface_hidden := true ;
9219: LD_ADDR_OWVAR 54
9223: PUSH
9224: LD_INT 1
9226: ST_TO_ADDR
// Say ( ru_sci , DArtefTechnology-RSci1-1 ) ;
9227: LD_VAR 0 3
9231: PPUSH
9232: LD_STRING DArtefTechnology-RSci1-1
9234: PPUSH
9235: CALL_OW 88
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
9239: LD_EXP 12
9243: PPUSH
9244: LD_STRING DArtefTechnology-Bur-1
9246: PPUSH
9247: CALL_OW 88
// Say ( ru_sci , DArtefTechnology-RSci1-2 ) ;
9251: LD_VAR 0 3
9255: PPUSH
9256: LD_STRING DArtefTechnology-RSci1-2
9258: PPUSH
9259: CALL_OW 88
// Say ( us_sci , DArtefTechnology-Sci1-2 ) ;
9263: LD_VAR 0 4
9267: PPUSH
9268: LD_STRING DArtefTechnology-Sci1-2
9270: PPUSH
9271: CALL_OW 88
// case camp of 4 :
9275: LD_EXP 7
9279: PUSH
9280: LD_INT 4
9282: DOUBLE
9283: EQUAL
9284: IFTRUE 9288
9286: GO 9303
9288: POP
// Say ( MacMillan , DArtefTechnology-JMM-2 ) ; 6 :
9289: LD_EXP 13
9293: PPUSH
9294: LD_STRING DArtefTechnology-JMM-2
9296: PPUSH
9297: CALL_OW 88
9301: GO 9327
9303: LD_INT 6
9305: DOUBLE
9306: EQUAL
9307: IFTRUE 9311
9309: GO 9326
9311: POP
// Say ( Burlak , DArtefTechnology-Bur-2 ) ; end ;
9312: LD_EXP 12
9316: PPUSH
9317: LD_STRING DArtefTechnology-Bur-2
9319: PPUSH
9320: CALL_OW 88
9324: GO 9327
9326: POP
// Say ( ru_sci , DArtefTechnology-RSci1-3 ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: LD_STRING DArtefTechnology-RSci1-3
9334: PPUSH
9335: CALL_OW 88
// if GetDistUnits ( your_depot , al_tower ) < 30 then
9339: LD_VAR 0 5
9343: PPUSH
9344: LD_INT 108
9346: PPUSH
9347: CALL_OW 296
9351: PUSH
9352: LD_INT 30
9354: LESS
9355: IFFALSE 9371
// Say ( us_sci , DArtefTechnology-Sci1-3 ) else
9357: LD_VAR 0 4
9361: PPUSH
9362: LD_STRING DArtefTechnology-Sci1-3
9364: PPUSH
9365: CALL_OW 88
9369: GO 9383
// Say ( us_sci , DArtefTechnology-Sci1-3a ) ;
9371: LD_VAR 0 4
9375: PPUSH
9376: LD_STRING DArtefTechnology-Sci1-3a
9378: PPUSH
9379: CALL_OW 88
// interface_hidden := false ;
9383: LD_ADDR_OWVAR 54
9387: PUSH
9388: LD_INT 0
9390: ST_TO_ADDR
// DialogueOff ;
9391: CALL_OW 7
// end ; end_of_file
9395: LD_VAR 0 1
9399: RET
// export us_researched , ru_researched ; export one_enabled ; every 0 0$1.1 do var un , sci ;
9400: GO 9402
9402: DISABLE
9403: LD_INT 0
9405: PPUSH
9406: PPUSH
// begin exit ;
9407: GO 9653
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9409: LD_ADDR_VAR 0 1
9413: PUSH
9414: LD_INT 22
9416: PUSH
9417: LD_EXP 1
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 23
9428: PUSH
9429: LD_INT 1
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: LD_INT 26
9438: PUSH
9439: LD_INT 1
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9456: LD_ADDR_VAR 0 1
9460: PUSH
9461: LD_VAR 0 1
9465: PUSH
9466: LD_EXP 13
9470: PUSH
9471: LD_EXP 12
9475: PUSH
9476: LD_EXP 14
9480: PUSH
9481: LD_EXP 15
9485: PUSH
9486: LD_INT 0
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: LIST
9493: LIST
9494: LIST
9495: DIFF
9496: ST_TO_ADDR
// if un then
9497: LD_VAR 0 1
9501: IFFALSE 9521
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9503: LD_ADDR_VAR 0 2
9507: PUSH
9508: LD_VAR 0 1
9512: PPUSH
9513: LD_INT 4
9515: PPUSH
9516: CALL_OW 433
9520: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
9521: LD_EXP 13
9525: PUSH
9526: LD_EXP 12
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PPUSH
9535: CALL_OW 85
// DialogueOn ;
9539: CALL_OW 6
// interface_hidden := true ;
9543: LD_ADDR_OWVAR 54
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAm-Sci1-1 ) ;
9551: LD_VAR 0 2
9555: PPUSH
9556: LD_STRING DArtefTechnologyAm-Sci1-1
9558: PPUSH
9559: CALL_OW 88
// case camp of 4 :
9563: LD_EXP 7
9567: PUSH
9568: LD_INT 4
9570: DOUBLE
9571: EQUAL
9572: IFTRUE 9576
9574: GO 9591
9576: POP
// Say ( MacMillan , DArtefTechnologyAm-JMM-1 ) ; 6 :
9577: LD_EXP 13
9581: PPUSH
9582: LD_STRING DArtefTechnologyAm-JMM-1
9584: PPUSH
9585: CALL_OW 88
9589: GO 9615
9591: LD_INT 6
9593: DOUBLE
9594: EQUAL
9595: IFTRUE 9599
9597: GO 9614
9599: POP
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ; end ;
9600: LD_EXP 12
9604: PPUSH
9605: LD_STRING DArtefTechnologyAm-Bur-1
9607: PPUSH
9608: CALL_OW 88
9612: GO 9615
9614: POP
// interface_hidden := false ;
9615: LD_ADDR_OWVAR 54
9619: PUSH
9620: LD_INT 0
9622: ST_TO_ADDR
// DialogueOff ;
9623: CALL_OW 7
// if not one_enabled then
9627: LD_EXP 63
9631: NOT
9632: IFFALSE 9645
// begin enable ( 1 ) ;
9634: LD_INT 1
9636: ENABLE_MARKED
// one_enabled := true ;
9637: LD_ADDR_EXP 63
9641: PUSH
9642: LD_INT 1
9644: ST_TO_ADDR
// end ; us_researched := true ;
9645: LD_ADDR_EXP 61
9649: PUSH
9650: LD_INT 1
9652: ST_TO_ADDR
// end ;
9653: PPOPN 2
9655: END
// every 0 0$1.3 do var un , sci ;
9656: GO 9658
9658: DISABLE
9659: LD_INT 0
9661: PPUSH
9662: PPUSH
// begin exit ;
9663: GO 9921
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9665: LD_ADDR_VAR 0 1
9669: PUSH
9670: LD_INT 22
9672: PUSH
9673: LD_EXP 1
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: PUSH
9682: LD_INT 23
9684: PUSH
9685: LD_INT 3
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PUSH
9692: LD_INT 26
9694: PUSH
9695: LD_INT 1
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PPUSH
9707: CALL_OW 69
9711: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9712: LD_ADDR_VAR 0 1
9716: PUSH
9717: LD_VAR 0 1
9721: PUSH
9722: LD_EXP 13
9726: PUSH
9727: LD_EXP 12
9731: PUSH
9732: LD_EXP 14
9736: PUSH
9737: LD_EXP 15
9741: PUSH
9742: LD_INT 0
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: LIST
9750: LIST
9751: DIFF
9752: ST_TO_ADDR
// if un then
9753: LD_VAR 0 1
9757: IFFALSE 9777
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9759: LD_ADDR_VAR 0 2
9763: PUSH
9764: LD_VAR 0 1
9768: PPUSH
9769: LD_INT 4
9771: PPUSH
9772: CALL_OW 433
9776: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , sci ] ) ;
9777: LD_EXP 13
9781: PUSH
9782: LD_VAR 0 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: PPUSH
9791: CALL_OW 85
// DialogueOn ;
9795: CALL_OW 6
// interface_hidden := true ;
9799: LD_ADDR_OWVAR 54
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// Say ( sci , DArtefTechnologyRu-RSci1-1 ) ;
9807: LD_VAR 0 2
9811: PPUSH
9812: LD_STRING DArtefTechnologyRu-RSci1-1
9814: PPUSH
9815: CALL_OW 88
// case camp of 4 :
9819: LD_EXP 7
9823: PUSH
9824: LD_INT 4
9826: DOUBLE
9827: EQUAL
9828: IFTRUE 9832
9830: GO 9847
9832: POP
// Say ( MacMillan , DArtefTechnologyRu-JMM-1 ) ; 6 :
9833: LD_EXP 13
9837: PPUSH
9838: LD_STRING DArtefTechnologyRu-JMM-1
9840: PPUSH
9841: CALL_OW 88
9845: GO 9871
9847: LD_INT 6
9849: DOUBLE
9850: EQUAL
9851: IFTRUE 9855
9853: GO 9870
9855: POP
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ; end ;
9856: LD_EXP 12
9860: PPUSH
9861: LD_STRING DArtefTechnologyRu-Bur-1
9863: PPUSH
9864: CALL_OW 88
9868: GO 9871
9870: POP
// Say ( sci , DArtefTechnologyRu-RSci1-2 ) ;
9871: LD_VAR 0 2
9875: PPUSH
9876: LD_STRING DArtefTechnologyRu-RSci1-2
9878: PPUSH
9879: CALL_OW 88
// interface_hidden := false ;
9883: LD_ADDR_OWVAR 54
9887: PUSH
9888: LD_INT 0
9890: ST_TO_ADDR
// DialogueOff ;
9891: CALL_OW 7
// if not one_enabled then
9895: LD_EXP 63
9899: NOT
9900: IFFALSE 9913
// begin enable ( 1 ) ;
9902: LD_INT 1
9904: ENABLE_MARKED
// one_enabled := true ;
9905: LD_ADDR_EXP 63
9909: PUSH
9910: LD_INT 1
9912: ST_TO_ADDR
// end ; ru_researched := true ;
9913: LD_ADDR_EXP 62
9917: PUSH
9918: LD_INT 1
9920: ST_TO_ADDR
// end ;
9921: PPOPN 2
9923: END
// every 0 0$5.3 trigger ( GetSide ( al_tower ) = you ) and ( GetTag ( 81 ) or GetTag ( 181 ) ) marked 1 do var un , sci ;
9924: LD_INT 108
9926: PPUSH
9927: CALL_OW 255
9931: PUSH
9932: LD_EXP 1
9936: EQUAL
9937: PUSH
9938: LD_INT 81
9940: PPUSH
9941: CALL_OW 110
9945: PUSH
9946: LD_INT 181
9948: PPUSH
9949: CALL_OW 110
9953: OR
9954: AND
9955: IFFALSE 10199
9957: GO 9959
9959: DISABLE
9960: LD_INT 0
9962: PPUSH
9963: PPUSH
// begin un := [ ] ;
9964: LD_ADDR_VAR 0 1
9968: PUSH
9969: EMPTY
9970: ST_TO_ADDR
// if us_researched then
9971: LD_EXP 61
9975: IFFALSE 10030
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9977: LD_ADDR_VAR 0 1
9981: PUSH
9982: LD_VAR 0 1
9986: PUSH
9987: LD_INT 22
9989: PUSH
9990: LD_EXP 1
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PUSH
9999: LD_INT 23
10001: PUSH
10002: LD_INT 1
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 26
10011: PUSH
10012: LD_INT 1
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: LIST
10023: PPUSH
10024: CALL_OW 69
10028: ADD
10029: ST_TO_ADDR
// if ru_researched then
10030: LD_EXP 62
10034: IFFALSE 10089
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10036: LD_ADDR_VAR 0 1
10040: PUSH
10041: LD_VAR 0 1
10045: PUSH
10046: LD_INT 22
10048: PUSH
10049: LD_EXP 1
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 23
10060: PUSH
10061: LD_INT 3
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: LD_INT 26
10070: PUSH
10071: LD_INT 1
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: LIST
10082: PPUSH
10083: CALL_OW 69
10087: ADD
10088: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10089: LD_ADDR_VAR 0 1
10093: PUSH
10094: LD_VAR 0 1
10098: PUSH
10099: LD_EXP 13
10103: PUSH
10104: LD_EXP 12
10108: PUSH
10109: LD_EXP 14
10113: PUSH
10114: LD_EXP 15
10118: PUSH
10119: LD_INT 0
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: DIFF
10129: ST_TO_ADDR
// if un then
10130: LD_VAR 0 1
10134: IFFALSE 10154
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10136: LD_ADDR_VAR 0 2
10140: PUSH
10141: LD_VAR 0 1
10145: PPUSH
10146: LD_INT 4
10148: PPUSH
10149: CALL_OW 433
10153: ST_TO_ADDR
// CenterOnUnits ( sci ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: CALL_OW 85
// DialogueOn ;
10163: CALL_OW 6
// interface_hidden := true ;
10167: LD_ADDR_OWVAR 54
10171: PUSH
10172: LD_INT 1
10174: ST_TO_ADDR
// Say ( sci , DArtefTechnologyArStart-Sci1-1 ) ;
10175: LD_VAR 0 2
10179: PPUSH
10180: LD_STRING DArtefTechnologyArStart-Sci1-1
10182: PPUSH
10183: CALL_OW 88
// interface_hidden := false ;
10187: LD_ADDR_OWVAR 54
10191: PUSH
10192: LD_INT 0
10194: ST_TO_ADDR
// DialogueOff ;
10195: CALL_OW 7
// end ;
10199: PPOPN 2
10201: END
// every 0 0$3.9 trigger GetTag ( 281 ) do var un , sci ;
10202: LD_INT 281
10204: PPUSH
10205: CALL_OW 110
10209: IFFALSE 10570
10211: GO 10213
10213: DISABLE
10214: LD_INT 0
10216: PPUSH
10217: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10218: LD_ADDR_VAR 0 1
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_EXP 1
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 23
10237: PUSH
10238: LD_INT 3
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 26
10247: PUSH
10248: LD_INT 1
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: PPUSH
10260: CALL_OW 69
10264: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10265: LD_ADDR_VAR 0 1
10269: PUSH
10270: LD_VAR 0 1
10274: PUSH
10275: LD_EXP 13
10279: PUSH
10280: LD_EXP 12
10284: PUSH
10285: LD_EXP 14
10289: PUSH
10290: LD_EXP 15
10294: PUSH
10295: LD_INT 0
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: DIFF
10305: ST_TO_ADDR
// if un then
10306: LD_VAR 0 1
10310: IFFALSE 10332
// sci := FindMaxSkill ( un , skill_scientistic ) else
10312: LD_ADDR_VAR 0 2
10316: PUSH
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_INT 4
10324: PPUSH
10325: CALL_OW 433
10329: ST_TO_ADDR
10330: GO 10334
// exit ;
10332: GO 10570
// CenterOnUnits ( [ MacMillan , Burlak , sci ] ) ;
10334: LD_EXP 13
10338: PUSH
10339: LD_EXP 12
10343: PUSH
10344: LD_VAR 0 2
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: LIST
10353: PPUSH
10354: CALL_OW 85
// DialogueOn ;
10358: CALL_OW 6
// interface_hidden := true ;
10362: LD_ADDR_OWVAR 54
10366: PUSH
10367: LD_INT 1
10369: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAr-RSci1-1 ) ;
10370: LD_VAR 0 2
10374: PPUSH
10375: LD_STRING DArtefTechnologyAr-RSci1-1
10377: PPUSH
10378: CALL_OW 88
// case camp of 4 :
10382: LD_EXP 7
10386: PUSH
10387: LD_INT 4
10389: DOUBLE
10390: EQUAL
10391: IFTRUE 10395
10393: GO 10410
10395: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-1 ) ; 6 :
10396: LD_EXP 13
10400: PPUSH
10401: LD_STRING DArtefTechnologyAr-JMM-1
10403: PPUSH
10404: CALL_OW 88
10408: GO 10434
10410: LD_INT 6
10412: DOUBLE
10413: EQUAL
10414: IFTRUE 10418
10416: GO 10433
10418: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-1 ) ; end ;
10419: LD_EXP 12
10423: PPUSH
10424: LD_STRING DArtefTechnologyAr-Bur-1
10426: PPUSH
10427: CALL_OW 88
10431: GO 10434
10433: POP
// Say ( sci , DArtefTechnologyAr-RSci1-2 ) ;
10434: LD_VAR 0 2
10438: PPUSH
10439: LD_STRING DArtefTechnologyAr-RSci1-2
10441: PPUSH
10442: CALL_OW 88
// case camp of 4 :
10446: LD_EXP 7
10450: PUSH
10451: LD_INT 4
10453: DOUBLE
10454: EQUAL
10455: IFTRUE 10459
10457: GO 10474
10459: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-2 ) ; 6 :
10460: LD_EXP 13
10464: PPUSH
10465: LD_STRING DArtefTechnologyAr-JMM-2
10467: PPUSH
10468: CALL_OW 88
10472: GO 10498
10474: LD_INT 6
10476: DOUBLE
10477: EQUAL
10478: IFTRUE 10482
10480: GO 10497
10482: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-2 ) ; end ;
10483: LD_EXP 12
10487: PPUSH
10488: LD_STRING DArtefTechnologyAr-Bur-2
10490: PPUSH
10491: CALL_OW 88
10495: GO 10498
10497: POP
// Say ( sci , DArtefTechnologyAr-RSci1-3 ) ;
10498: LD_VAR 0 2
10502: PPUSH
10503: LD_STRING DArtefTechnologyAr-RSci1-3
10505: PPUSH
10506: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-3 ) ;
10510: LD_EXP 13
10514: PPUSH
10515: LD_STRING DArtefTechnologyAr-JMM-3
10517: PPUSH
10518: CALL_OW 88
// Say ( sci , DArtefTechnologyAr-RSci1-4 ) ;
10522: LD_VAR 0 2
10526: PPUSH
10527: LD_STRING DArtefTechnologyAr-RSci1-4
10529: PPUSH
10530: CALL_OW 88
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
10534: LD_EXP 12
10538: PPUSH
10539: LD_STRING DArtefTechnologyAr-Bur-4
10541: PPUSH
10542: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-4 ) ;
10546: LD_EXP 13
10550: PPUSH
10551: LD_STRING DArtefTechnologyAr-JMM-4
10553: PPUSH
10554: CALL_OW 88
// interface_hidden := false ;
10558: LD_ADDR_OWVAR 54
10562: PUSH
10563: LD_INT 0
10565: ST_TO_ADDR
// DialogueOff ;
10566: CALL_OW 7
// end ; end_of_file
10570: PPOPN 2
10572: END
// export omar_in_contact ; var sib_list ; every 0 0$2 + 0 0$0.4 trigger FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] ] ) = 0 marked 2 do var answer ;
10573: LD_INT 22
10575: PUSH
10576: LD_EXP 4
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: LD_INT 21
10587: PUSH
10588: LD_INT 1
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: PUSH
10595: LD_INT 50
10597: PUSH
10598: EMPTY
10599: LIST
10600: PUSH
10601: EMPTY
10602: LIST
10603: LIST
10604: LIST
10605: PPUSH
10606: CALL_OW 69
10610: PUSH
10611: LD_INT 0
10613: EQUAL
10614: IFFALSE 11045
10616: GO 10618
10618: DISABLE
10619: LD_INT 0
10621: PPUSH
// begin Omar_Arrive ;
10622: CALL 11048 0 0
// CenterOnUnits ( Omar ) ;
10626: LD_EXP 51
10630: PPUSH
10631: CALL_OW 85
// DialogueOn ;
10635: CALL_OW 6
// interface_hidden := true ;
10639: LD_ADDR_OWVAR 54
10643: PUSH
10644: LD_INT 1
10646: ST_TO_ADDR
// Say ( Omar , DOmar-Omar-1 ) ;
10647: LD_EXP 51
10651: PPUSH
10652: LD_STRING DOmar-Omar-1
10654: PPUSH
10655: CALL_OW 88
// case camp of 4 :
10659: LD_EXP 7
10663: PUSH
10664: LD_INT 4
10666: DOUBLE
10667: EQUAL
10668: IFTRUE 10672
10670: GO 10687
10672: POP
// Say ( MacMillan , DOmar-JMM-1 ) ; 6 :
10673: LD_EXP 13
10677: PPUSH
10678: LD_STRING DOmar-JMM-1
10680: PPUSH
10681: CALL_OW 88
10685: GO 10711
10687: LD_INT 6
10689: DOUBLE
10690: EQUAL
10691: IFTRUE 10695
10693: GO 10710
10695: POP
// Say ( Burlak , DOmar-Bur-1 ) ; end ;
10696: LD_EXP 12
10700: PPUSH
10701: LD_STRING DOmar-Bur-1
10703: PPUSH
10704: CALL_OW 88
10708: GO 10711
10710: POP
// Say ( Omar , DOmar-Omar-2 ) ;
10711: LD_EXP 51
10715: PPUSH
10716: LD_STRING DOmar-Omar-2
10718: PPUSH
10719: CALL_OW 88
// case camp of 4 :
10723: LD_EXP 7
10727: PUSH
10728: LD_INT 4
10730: DOUBLE
10731: EQUAL
10732: IFTRUE 10736
10734: GO 10751
10736: POP
// Say ( MacMillan , DOmar-JMM-2 ) ; 6 :
10737: LD_EXP 13
10741: PPUSH
10742: LD_STRING DOmar-JMM-2
10744: PPUSH
10745: CALL_OW 88
10749: GO 10775
10751: LD_INT 6
10753: DOUBLE
10754: EQUAL
10755: IFTRUE 10759
10757: GO 10774
10759: POP
// Say ( Burlak , DOmar-Bur-2 ) ; end ;
10760: LD_EXP 12
10764: PPUSH
10765: LD_STRING DOmar-Bur-2
10767: PPUSH
10768: CALL_OW 88
10772: GO 10775
10774: POP
// Say ( Omar , DOmar-Omar-3 ) ;
10775: LD_EXP 51
10779: PPUSH
10780: LD_STRING DOmar-Omar-3
10782: PPUSH
10783: CALL_OW 88
// case camp of 4 :
10787: LD_EXP 7
10791: PUSH
10792: LD_INT 4
10794: DOUBLE
10795: EQUAL
10796: IFTRUE 10800
10798: GO 10815
10800: POP
// Say ( MacMillan , DOmar-JMM-3 ) ; 6 :
10801: LD_EXP 13
10805: PPUSH
10806: LD_STRING DOmar-JMM-3
10808: PPUSH
10809: CALL_OW 88
10813: GO 10839
10815: LD_INT 6
10817: DOUBLE
10818: EQUAL
10819: IFTRUE 10823
10821: GO 10838
10823: POP
// Say ( Burlak , DOmar-Bur-3 ) ; end ;
10824: LD_EXP 12
10828: PPUSH
10829: LD_STRING DOmar-Bur-3
10831: PPUSH
10832: CALL_OW 88
10836: GO 10839
10838: POP
// Say ( Omar , DOmar-Omar-4 ) ;
10839: LD_EXP 51
10843: PPUSH
10844: LD_STRING DOmar-Omar-4
10846: PPUSH
10847: CALL_OW 88
// answer = Query ( QAccept ) ;
10851: LD_ADDR_VAR 0 1
10855: PUSH
10856: LD_STRING QAccept
10858: PPUSH
10859: CALL_OW 97
10863: ST_TO_ADDR
// case answer of 1 :
10864: LD_VAR 0 1
10868: PUSH
10869: LD_INT 1
10871: DOUBLE
10872: EQUAL
10873: IFTRUE 10877
10875: GO 10955
10877: POP
// begin case camp of 4 :
10878: LD_EXP 7
10882: PUSH
10883: LD_INT 4
10885: DOUBLE
10886: EQUAL
10887: IFTRUE 10891
10889: GO 10906
10891: POP
// Say ( MacMillan , DQrAccept#1-JMM-1 ) ; 6 :
10892: LD_EXP 13
10896: PPUSH
10897: LD_STRING DQrAccept#1-JMM-1
10899: PPUSH
10900: CALL_OW 88
10904: GO 10930
10906: LD_INT 6
10908: DOUBLE
10909: EQUAL
10910: IFTRUE 10914
10912: GO 10929
10914: POP
// Say ( Burlak , DQrAccept#1-Bur-1 ) ; end ;
10915: LD_EXP 12
10919: PPUSH
10920: LD_STRING DQrAccept#1-Bur-1
10922: PPUSH
10923: CALL_OW 88
10927: GO 10930
10929: POP
// SetSide ( Omar , you ) ;
10930: LD_EXP 51
10934: PPUSH
10935: LD_EXP 1
10939: PPUSH
10940: CALL_OW 235
// ComStop ( Omar ) ;
10944: LD_EXP 51
10948: PPUSH
10949: CALL_OW 141
// end ; 2 :
10953: GO 11019
10955: LD_INT 2
10957: DOUBLE
10958: EQUAL
10959: IFTRUE 10963
10961: GO 11018
10963: POP
// begin case camp of 4 :
10964: LD_EXP 7
10968: PUSH
10969: LD_INT 4
10971: DOUBLE
10972: EQUAL
10973: IFTRUE 10977
10975: GO 10992
10977: POP
// Say ( MacMillan , DQrAccept#2-JMM-1 ) ; 6 :
10978: LD_EXP 13
10982: PPUSH
10983: LD_STRING DQrAccept#2-JMM-1
10985: PPUSH
10986: CALL_OW 88
10990: GO 11016
10992: LD_INT 6
10994: DOUBLE
10995: EQUAL
10996: IFTRUE 11000
10998: GO 11015
11000: POP
// Say ( Burlak , DQrAccept#2-Bur-1 ) ; end ;
11001: LD_EXP 12
11005: PPUSH
11006: LD_STRING DQrAccept#2-Bur-1
11008: PPUSH
11009: CALL_OW 88
11013: GO 11016
11015: POP
// end ; end ;
11016: GO 11019
11018: POP
// interface_hidden := false ;
11019: LD_ADDR_OWVAR 54
11023: PUSH
11024: LD_INT 0
11026: ST_TO_ADDR
// DialogueOff ;
11027: CALL_OW 7
// if answer = 2 then
11031: LD_VAR 0 1
11035: PUSH
11036: LD_INT 2
11038: EQUAL
11039: IFFALSE 11045
// Omar_Leave ;
11041: CALL 11097 0 0
// end ;
11045: PPOPN 1
11047: END
// function Omar_Arrive ; var un ; begin
11048: LD_INT 0
11050: PPUSH
11051: PPUSH
// PlaceUnitArea ( Omar , omar_place , false ) ;
11052: LD_EXP 51
11056: PPUSH
11057: LD_INT 4
11059: PPUSH
11060: LD_INT 0
11062: PPUSH
11063: CALL_OW 49
// repeat ComMoveToArea ( Omar , teleport_area ) ;
11067: LD_EXP 51
11071: PPUSH
11072: LD_INT 24
11074: PPUSH
11075: CALL_OW 113
// wait ( 0 0$1 ) ;
11079: LD_INT 35
11081: PPUSH
11082: CALL_OW 67
// until omar_in_contact ;
11086: LD_EXP 64
11090: IFFALSE 11067
// end ;
11092: LD_VAR 0 1
11096: RET
// function Omar_Leave ; begin
11097: LD_INT 0
11099: PPUSH
// repeat ComMoveToArea ( Omar , omar_place ) ;
11100: LD_EXP 51
11104: PPUSH
11105: LD_INT 4
11107: PPUSH
11108: CALL_OW 113
// wait ( 0 0$1 ) ;
11112: LD_INT 35
11114: PPUSH
11115: CALL_OW 67
// until IsInArea ( Omar , omar_place ) ;
11119: LD_EXP 51
11123: PPUSH
11124: LD_INT 4
11126: PPUSH
11127: CALL_OW 308
11131: IFFALSE 11100
// RemoveUnit ( Omar ) ;
11133: LD_EXP 51
11137: PPUSH
11138: CALL_OW 64
// end ;
11142: LD_VAR 0 1
11146: RET
// every 0 0$3.7 trigger OmarWillTryContaminateMotherlode and ( FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 or finalize = 2 ) do var best_sib , see_him ;
11147: LD_EXP 54
11151: PUSH
11152: LD_INT 22
11154: PUSH
11155: LD_EXP 2
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: LD_INT 2
11166: PUSH
11167: LD_INT 30
11169: PUSH
11170: LD_INT 0
11172: PUSH
11173: EMPTY
11174: LIST
11175: LIST
11176: PUSH
11177: LD_INT 30
11179: PUSH
11180: LD_INT 1
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: LIST
11191: PUSH
11192: EMPTY
11193: LIST
11194: LIST
11195: PPUSH
11196: CALL_OW 69
11200: PUSH
11201: LD_INT 0
11203: EQUAL
11204: PUSH
11205: LD_EXP 58
11209: PUSH
11210: LD_INT 2
11212: EQUAL
11213: OR
11214: AND
11215: IFFALSE 11365
11217: GO 11219
11219: DISABLE
11220: LD_INT 0
11222: PPUSH
11223: PPUSH
// begin sib_list := get_sib_list ;
11224: LD_ADDR_LOC 11
11228: PUSH
11229: CALL 11610 0 0
11233: ST_TO_ADDR
// SetClass ( Omar , class_scientistic ) ;
11234: LD_EXP 51
11238: PPUSH
11239: LD_INT 4
11241: PPUSH
11242: CALL_OW 336
// PlaceUnitArea ( Omar , omar_infested , false ) ;
11246: LD_EXP 51
11250: PPUSH
11251: LD_INT 5
11253: PPUSH
11254: LD_INT 0
11256: PPUSH
11257: CALL_OW 49
// see_him := false ;
11261: LD_ADDR_VAR 0 2
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// repeat best_sib := get_best_sib ( sib_list ) ;
11269: LD_ADDR_VAR 0 1
11273: PUSH
11274: LD_LOC 11
11278: PPUSH
11279: CALL 11750 0 1
11283: ST_TO_ADDR
// ComContaminate ( Omar , best_sib [ 1 ] , best_sib [ 2 ] ) ;
11284: LD_EXP 51
11288: PPUSH
11289: LD_VAR 0 1
11293: PUSH
11294: LD_INT 1
11296: ARRAY
11297: PPUSH
11298: LD_VAR 0 1
11302: PUSH
11303: LD_INT 2
11305: ARRAY
11306: PPUSH
11307: CALL_OW 158
// if ( not see_him ) and See ( you , Omar ) then
11311: LD_VAR 0 2
11315: NOT
11316: PUSH
11317: LD_EXP 1
11321: PPUSH
11322: LD_EXP 51
11326: PPUSH
11327: CALL_OW 292
11331: AND
11332: IFFALSE 11346
// begin talking_to_omar ;
11334: CALL 11368 0 0
// see_him := true ;
11338: LD_ADDR_VAR 0 2
11342: PUSH
11343: LD_INT 1
11345: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
11346: LD_INT 35
11348: PPUSH
11349: CALL_OW 67
// until not IsLive ( Omar ) ;
11353: LD_EXP 51
11357: PPUSH
11358: CALL_OW 300
11362: NOT
11363: IFFALSE 11269
// end ;
11365: PPOPN 2
11367: END
// function talking_to_omar ; begin
11368: LD_INT 0
11370: PPUSH
// CenterOnUnits ( Omar ) ;
11371: LD_EXP 51
11375: PPUSH
11376: CALL_OW 85
// DialogueOn ;
11380: CALL_OW 6
// interface_hidden := true ;
11384: LD_ADDR_OWVAR 54
11388: PUSH
11389: LD_INT 1
11391: ST_TO_ADDR
// case camp of 4 :
11392: LD_EXP 7
11396: PUSH
11397: LD_INT 4
11399: DOUBLE
11400: EQUAL
11401: IFTRUE 11405
11403: GO 11420
11405: POP
// Say ( MacMillan , DOmarContam-JMM-1 ) ; 6 :
11406: LD_EXP 13
11410: PPUSH
11411: LD_STRING DOmarContam-JMM-1
11413: PPUSH
11414: CALL_OW 88
11418: GO 11444
11420: LD_INT 6
11422: DOUBLE
11423: EQUAL
11424: IFTRUE 11428
11426: GO 11443
11428: POP
// Say ( Burlak , DOmarContam-Bur-1 ) ; end ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DOmarContam-Bur-1
11436: PPUSH
11437: CALL_OW 88
11441: GO 11444
11443: POP
// Say ( Omar , DOmarContam-Omar-1 ) ;
11444: LD_EXP 51
11448: PPUSH
11449: LD_STRING DOmarContam-Omar-1
11451: PPUSH
11452: CALL_OW 88
// case camp of 4 :
11456: LD_EXP 7
11460: PUSH
11461: LD_INT 4
11463: DOUBLE
11464: EQUAL
11465: IFTRUE 11469
11467: GO 11484
11469: POP
// Say ( MacMillan , DOmarContam-JMM-2 ) ; 6 :
11470: LD_EXP 13
11474: PPUSH
11475: LD_STRING DOmarContam-JMM-2
11477: PPUSH
11478: CALL_OW 88
11482: GO 11508
11484: LD_INT 6
11486: DOUBLE
11487: EQUAL
11488: IFTRUE 11492
11490: GO 11507
11492: POP
// Say ( Burlak , DOmarContam-Bur-2 ) ; end ;
11493: LD_EXP 12
11497: PPUSH
11498: LD_STRING DOmarContam-Bur-2
11500: PPUSH
11501: CALL_OW 88
11505: GO 11508
11507: POP
// interface_hidden := false ;
11508: LD_ADDR_OWVAR 54
11512: PUSH
11513: LD_INT 0
11515: ST_TO_ADDR
// DialogueOff ;
11516: CALL_OW 7
// end ;
11520: LD_VAR 0 1
11524: RET
// on SibDepositContaminated ( sib , x , y ) do var list , un ;
11525: LD_INT 0
11527: PPUSH
11528: PPUSH
// begin InGameOn ;
11529: CALL_OW 8
// CenterOnXY ( x , y ) ;
11533: LD_VAR 0 2
11537: PPUSH
11538: LD_VAR 0 3
11542: PPUSH
11543: CALL_OW 84
// PlaceSeeing ( x , y , you , - 10 ) ;
11547: LD_VAR 0 2
11551: PPUSH
11552: LD_VAR 0 3
11556: PPUSH
11557: LD_EXP 1
11561: PPUSH
11562: LD_INT 10
11564: NEG
11565: PPUSH
11566: CALL_OW 330
// wait ( 0 0$7 ) ;
11570: LD_INT 245
11572: PPUSH
11573: CALL_OW 67
// Mission_Failed ( 5 ) ;
11577: LD_INT 5
11579: PPUSH
11580: CALL 13721 0 1
// RemoveSeeing ( x , y , you ) ;
11584: LD_VAR 0 2
11588: PPUSH
11589: LD_VAR 0 3
11593: PPUSH
11594: LD_EXP 1
11598: PPUSH
11599: CALL_OW 331
// InGameOff ;
11603: CALL_OW 9
// end ;
11607: PPOPN 5
11609: END
// function get_sib_list ; var list , un , vysledek ; begin
11610: LD_INT 0
11612: PPUSH
11613: PPUSH
11614: PPUSH
11615: PPUSH
// vysledek := [ ] ;
11616: LD_ADDR_VAR 0 4
11620: PUSH
11621: EMPTY
11622: ST_TO_ADDR
// list := GetListOfResourcesInArea ( ru_base ) ;
11623: LD_ADDR_VAR 0 2
11627: PUSH
11628: LD_INT 12
11630: PPUSH
11631: CALL_OW 442
11635: ST_TO_ADDR
// for un = 1 to ( list div 3 ) do
11636: LD_ADDR_VAR 0 3
11640: PUSH
11641: DOUBLE
11642: LD_INT 1
11644: DEC
11645: ST_TO_ADDR
11646: LD_VAR 0 2
11650: PUSH
11651: LD_INT 3
11653: DIV
11654: PUSH
11655: FOR_TO
11656: IFFALSE 11733
// if list [ ( un * 3 ) ] = source_siberium then
11658: LD_VAR 0 2
11662: PUSH
11663: LD_VAR 0 3
11667: PUSH
11668: LD_INT 3
11670: MUL
11671: ARRAY
11672: PUSH
11673: LD_INT 2
11675: EQUAL
11676: IFFALSE 11731
// vysledek := vysledek ^ [ list [ ( un * 3 ) - 2 ] , list [ ( un * 3 ) - 1 ] ] ;
11678: LD_ADDR_VAR 0 4
11682: PUSH
11683: LD_VAR 0 4
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: LD_VAR 0 3
11697: PUSH
11698: LD_INT 3
11700: MUL
11701: PUSH
11702: LD_INT 2
11704: MINUS
11705: ARRAY
11706: PUSH
11707: LD_VAR 0 2
11711: PUSH
11712: LD_VAR 0 3
11716: PUSH
11717: LD_INT 3
11719: MUL
11720: PUSH
11721: LD_INT 1
11723: MINUS
11724: ARRAY
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: ADD
11730: ST_TO_ADDR
11731: GO 11655
11733: POP
11734: POP
// result := vysledek ;
11735: LD_ADDR_VAR 0 1
11739: PUSH
11740: LD_VAR 0 4
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 1
11749: RET
// function get_best_sib ( sib_list ) ; var un , min , x , y , dist , vysledek , b ; begin
11750: LD_INT 0
11752: PPUSH
11753: PPUSH
11754: PPUSH
11755: PPUSH
11756: PPUSH
11757: PPUSH
11758: PPUSH
11759: PPUSH
// min := [ - 1 , - 1 , - 1 ] ;
11760: LD_ADDR_VAR 0 4
11764: PUSH
11765: LD_INT 1
11767: NEG
11768: PUSH
11769: LD_INT 1
11771: NEG
11772: PUSH
11773: LD_INT 1
11775: NEG
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: LIST
11781: ST_TO_ADDR
// for un = 1 to ( sib_list div 2 ) do
11782: LD_ADDR_VAR 0 3
11786: PUSH
11787: DOUBLE
11788: LD_INT 1
11790: DEC
11791: ST_TO_ADDR
11792: LD_VAR 0 1
11796: PUSH
11797: LD_INT 2
11799: DIV
11800: PUSH
11801: FOR_TO
11802: IFFALSE 11975
// begin x := sib_list [ ( un * 2 ) - 1 ] ;
11804: LD_ADDR_VAR 0 5
11808: PUSH
11809: LD_VAR 0 1
11813: PUSH
11814: LD_VAR 0 3
11818: PUSH
11819: LD_INT 2
11821: MUL
11822: PUSH
11823: LD_INT 1
11825: MINUS
11826: ARRAY
11827: ST_TO_ADDR
// y := sib_list [ ( un * 2 ) ] ;
11828: LD_ADDR_VAR 0 6
11832: PUSH
11833: LD_VAR 0 1
11837: PUSH
11838: LD_VAR 0 3
11842: PUSH
11843: LD_INT 2
11845: MUL
11846: ARRAY
11847: ST_TO_ADDR
// dist := GetDistUnitXY ( Omar , x , y ) ;
11848: LD_ADDR_VAR 0 7
11852: PUSH
11853: LD_EXP 51
11857: PPUSH
11858: LD_VAR 0 5
11862: PPUSH
11863: LD_VAR 0 6
11867: PPUSH
11868: CALL_OW 297
11872: ST_TO_ADDR
// b = HexInfo ( x , y ) ;
11873: LD_ADDR_VAR 0 9
11877: PUSH
11878: LD_VAR 0 5
11882: PPUSH
11883: LD_VAR 0 6
11887: PPUSH
11888: CALL_OW 428
11892: ST_TO_ADDR
// if ( ( min [ 3 ] < 0 ) or ( dist < min [ 3 ] ) ) and ( b = 0 or GetBType ( b ) = b_siberite_mine ) then
11893: LD_VAR 0 4
11897: PUSH
11898: LD_INT 3
11900: ARRAY
11901: PUSH
11902: LD_INT 0
11904: LESS
11905: PUSH
11906: LD_VAR 0 7
11910: PUSH
11911: LD_VAR 0 4
11915: PUSH
11916: LD_INT 3
11918: ARRAY
11919: LESS
11920: OR
11921: PUSH
11922: LD_VAR 0 9
11926: PUSH
11927: LD_INT 0
11929: EQUAL
11930: PUSH
11931: LD_VAR 0 9
11935: PPUSH
11936: CALL_OW 266
11940: PUSH
11941: LD_INT 30
11943: EQUAL
11944: OR
11945: AND
11946: IFFALSE 11973
// min := [ x , y , dist ] ;
11948: LD_ADDR_VAR 0 4
11952: PUSH
11953: LD_VAR 0 5
11957: PUSH
11958: LD_VAR 0 6
11962: PUSH
11963: LD_VAR 0 7
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: LIST
11972: ST_TO_ADDR
// end ;
11973: GO 11801
11975: POP
11976: POP
// vysledek := [ min [ 1 ] , min [ 2 ] ] ;
11977: LD_ADDR_VAR 0 8
11981: PUSH
11982: LD_VAR 0 4
11986: PUSH
11987: LD_INT 1
11989: ARRAY
11990: PUSH
11991: LD_VAR 0 4
11995: PUSH
11996: LD_INT 2
11998: ARRAY
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: ST_TO_ADDR
// result := vysledek ;
12004: LD_ADDR_VAR 0 2
12008: PUSH
12009: LD_VAR 0 8
12013: ST_TO_ADDR
// end ; end_of_file
12014: LD_VAR 0 2
12018: RET
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibFiss then
12019: LD_VAR 0 1
12023: PUSH
12024: LD_INT 25
12026: EQUAL
12027: IFFALSE 12068
// case GetSide ( lab ) of 1 :
12029: LD_VAR 0 2
12033: PPUSH
12034: CALL_OW 255
12038: PUSH
12039: LD_INT 1
12041: DOUBLE
12042: EQUAL
12043: IFTRUE 12047
12045: GO 12053
12047: POP
// enable ( 4 ) ; 3 :
12048: LD_INT 4
12050: ENABLE_MARKED
12051: GO 12068
12053: LD_INT 3
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12067
12061: POP
// enable ( 5 ) ; end ;
12062: LD_INT 5
12064: ENABLE_MARKED
12065: GO 12068
12067: POP
// wait ( 10 ) ;
12068: LD_INT 10
12070: PPUSH
12071: CALL_OW 67
// if not IsBusy ( lab ) then
12075: LD_VAR 0 2
12079: PPUSH
12080: CALL_OW 315
12084: NOT
12085: IFFALSE 12112
// begin labs_in_use := labs_in_use diff lab ;
12087: LD_ADDR_EXP 79
12091: PUSH
12092: LD_EXP 79
12096: PUSH
12097: LD_VAR 0 2
12101: DIFF
12102: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12103: LD_VAR 0 2
12107: PPUSH
12108: CALL 40050 0 1
// end ; end ;
12112: PPOPN 2
12114: END
// on ResearchStarted ( tech , lab ) do var un , side ;
12115: LD_INT 0
12117: PPUSH
12118: PPUSH
// begin labs_in_use := labs_in_use ^ lab ;
12119: LD_ADDR_EXP 79
12123: PUSH
12124: LD_EXP 79
12128: PUSH
12129: LD_VAR 0 2
12133: ADD
12134: ST_TO_ADDR
// side := GetSide ( lab ) ;
12135: LD_ADDR_VAR 0 4
12139: PUSH
12140: LD_VAR 0 2
12144: PPUSH
12145: CALL_OW 255
12149: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
12150: LD_ADDR_VAR 0 3
12154: PUSH
12155: DOUBLE
12156: LD_INT 0
12158: DEC
12159: ST_TO_ADDR
12160: LD_EXP 76
12164: PUSH
12165: LD_INT 1
12167: MINUS
12168: PUSH
12169: FOR_TO
12170: IFFALSE 12249
// if lab in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
12172: LD_VAR 0 2
12176: PUSH
12177: LD_VAR 0 3
12181: PUSH
12182: LD_INT 100
12184: MUL
12185: PUSH
12186: LD_INT 11
12188: PLUS
12189: PPUSH
12190: CALL_OW 110
12194: PUSH
12195: LD_VAR 0 3
12199: PUSH
12200: LD_INT 100
12202: MUL
12203: PUSH
12204: LD_VAR 0 4
12208: PUSH
12209: LD_INT 10
12211: MUL
12212: PLUS
12213: PUSH
12214: LD_INT 15
12216: PLUS
12217: PPUSH
12218: CALL_OW 110
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: IN
12227: IFFALSE 12247
// DeInit_Lab ( side , un + 1 ) ;
12229: LD_VAR 0 4
12233: PPUSH
12234: LD_VAR 0 3
12238: PUSH
12239: LD_INT 1
12241: PLUS
12242: PPUSH
12243: CALL 39911 0 2
12247: GO 12169
12249: POP
12250: POP
// end ;
12251: PPOPN 4
12253: END
// on ResearchCancel ( tech , lab ) do begin wait ( 10 ) ;
12254: LD_INT 10
12256: PPUSH
12257: CALL_OW 67
// if not IsBusy ( lab ) then
12261: LD_VAR 0 2
12265: PPUSH
12266: CALL_OW 315
12270: NOT
12271: IFFALSE 12298
// begin labs_in_use := labs_in_use diff lab ;
12273: LD_ADDR_EXP 79
12277: PUSH
12278: LD_EXP 79
12282: PUSH
12283: LD_VAR 0 2
12287: DIFF
12288: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12289: LD_VAR 0 2
12293: PPUSH
12294: CALL 40050 0 1
// end ; end ;
12298: PPOPN 2
12300: END
// on UnitDestroyed ( un ) do begin if un = MacMillan then
12301: LD_VAR 0 1
12305: PUSH
12306: LD_EXP 13
12310: EQUAL
12311: IFFALSE 12320
// Mission_failed ( 1 ) ;
12313: LD_INT 1
12315: PPUSH
12316: CALL 13721 0 1
// if un = Burlak then
12320: LD_VAR 0 1
12324: PUSH
12325: LD_EXP 12
12329: EQUAL
12330: IFFALSE 12339
// Mission_failed ( 2 ) ;
12332: LD_INT 2
12334: PPUSH
12335: CALL 13721 0 1
// Update_defend ( un ) ;
12339: LD_VAR 0 1
12343: PPUSH
12344: CALL 20645 0 1
// end ;
12348: PPOPN 1
12350: END
// on UnitGoesToRed ( un ) do begin if ( un = MacMillan ) and not Doctors_available ( MacMillan ) then
12351: LD_VAR 0 1
12355: PUSH
12356: LD_EXP 13
12360: EQUAL
12361: PUSH
12362: LD_EXP 13
12366: PPUSH
12367: CALL 12503 0 1
12371: NOT
12372: AND
12373: IFFALSE 12382
// Mission_failed ( 1 ) ;
12375: LD_INT 1
12377: PPUSH
12378: CALL 13721 0 1
// if ( un = Burlak ) and not Doctors_available ( Burlak ) then
12382: LD_VAR 0 1
12386: PUSH
12387: LD_EXP 12
12391: EQUAL
12392: PUSH
12393: LD_EXP 12
12397: PPUSH
12398: CALL 12503 0 1
12402: NOT
12403: AND
12404: IFFALSE 12413
// Mission_failed ( 2 ) ;
12406: LD_INT 2
12408: PPUSH
12409: CALL 13721 0 1
// if ( GetSide ( un ) = us ) and ( GetControl ( un ) = control_remote ) then
12413: LD_VAR 0 1
12417: PPUSH
12418: CALL_OW 255
12422: PUSH
12423: LD_EXP 3
12427: EQUAL
12428: PUSH
12429: LD_VAR 0 1
12433: PPUSH
12434: CALL_OW 263
12438: PUSH
12439: LD_INT 2
12441: EQUAL
12442: AND
12443: IFFALSE 12461
// begin ComUnlink ( un ) ;
12445: LD_VAR 0 1
12449: PPUSH
12450: CALL_OW 136
// check_remote ( 0 ) ;
12454: LD_INT 0
12456: PPUSH
12457: CALL 35164 0 1
// end ; if GetUnitMc ( un ) then
12461: LD_VAR 0 1
12465: PPUSH
12466: CALL_OW 388
12470: IFFALSE 12491
// RemoveMcUnits ( GetUnitMc ( un ) , un ) ;
12472: LD_VAR 0 1
12476: PPUSH
12477: CALL_OW 388
12481: PPUSH
12482: LD_VAR 0 1
12486: PPUSH
12487: CALL_OW 391
// Update_defend ( un ) ;
12491: LD_VAR 0 1
12495: PPUSH
12496: CALL 20645 0 1
// end ;
12500: PPOPN 1
12502: END
// function Doctors_available ( geroj ) ; var list , un , vysledek ; begin
12503: LD_INT 0
12505: PPUSH
12506: PPUSH
12507: PPUSH
12508: PPUSH
// vysledek := false ;
12509: LD_ADDR_VAR 0 5
12513: PUSH
12514: LD_INT 0
12516: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12517: LD_ADDR_VAR 0 3
12521: PUSH
12522: LD_INT 22
12524: PUSH
12525: LD_EXP 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 4
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PUSH
12544: EMPTY
12545: LIST
12546: LIST
12547: PPUSH
12548: CALL_OW 69
12552: ST_TO_ADDR
// if list then
12553: LD_VAR 0 3
12557: IFFALSE 12567
// vysledek := true ;
12559: LD_ADDR_VAR 0 5
12563: PUSH
12564: LD_INT 1
12566: ST_TO_ADDR
// if ( not vysledek ) and ( IsInArea ( geroj , ar_crates ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_lab ] ] ) ) then
12567: LD_VAR 0 5
12571: NOT
12572: PUSH
12573: LD_VAR 0 1
12577: PPUSH
12578: LD_INT 3
12580: PPUSH
12581: CALL_OW 308
12585: AND
12586: PUSH
12587: LD_INT 22
12589: PUSH
12590: LD_EXP 1
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 21
12601: PUSH
12602: LD_INT 1
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PPUSH
12613: CALL_OW 69
12617: AND
12618: PUSH
12619: LD_INT 22
12621: PUSH
12622: LD_EXP 1
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: LD_INT 30
12633: PUSH
12634: LD_INT 6
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: AND
12650: IFFALSE 12660
// vysledek := true ;
12652: LD_ADDR_VAR 0 5
12656: PUSH
12657: LD_INT 1
12659: ST_TO_ADDR
// result := vysledek ;
12660: LD_ADDR_VAR 0 2
12664: PUSH
12665: LD_VAR 0 5
12669: ST_TO_ADDR
// end ;
12670: LD_VAR 0 2
12674: RET
// on Contact ( side1 , side2 ) do begin if ( side1 in [ ar_al , you ] ) and ( side2 in [ ar_al , you ] ) then
12675: LD_VAR 0 1
12679: PUSH
12680: LD_EXP 5
12684: PUSH
12685: LD_EXP 1
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: IN
12694: PUSH
12695: LD_VAR 0 2
12699: PUSH
12700: LD_EXP 5
12704: PUSH
12705: LD_EXP 1
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: IN
12714: AND
12715: IFFALSE 12725
// omar_in_contact := true ;
12717: LD_ADDR_EXP 64
12721: PUSH
12722: LD_INT 1
12724: ST_TO_ADDR
// end ;
12725: PPOPN 2
12727: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
12728: LD_VAR 0 1
12732: PPUSH
12733: CALL_OW 141
// if ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay ] ) then
12737: LD_VAR 0 1
12741: PPUSH
12742: CALL_OW 247
12746: PUSH
12747: LD_INT 2
12749: EQUAL
12750: PUSH
12751: LD_VAR 0 1
12755: PPUSH
12756: CALL_OW 264
12760: PUSH
12761: LD_INT 12
12763: PUSH
12764: LD_INT 51
12766: PUSH
12767: LD_INT 32
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: LIST
12774: IN
12775: AND
12776: IFFALSE 12792
// remove_bad_crates ( GetSide ( un ) ) ;
12778: LD_VAR 0 1
12782: PPUSH
12783: CALL_OW 255
12787: PPUSH
12788: CALL 34471 0 1
// end ;
12792: PPOPN 1
12794: END
// on VehicleConstructed ( veh , fac ) do var side , list , tower ;
12795: LD_INT 0
12797: PPUSH
12798: PPUSH
12799: PPUSH
// begin side := GetSide ( fac ) ;
12800: LD_ADDR_VAR 0 3
12804: PUSH
12805: LD_VAR 0 2
12809: PPUSH
12810: CALL_OW 255
12814: ST_TO_ADDR
// case side of 1 :
12815: LD_VAR 0 3
12819: PUSH
12820: LD_INT 1
12822: DOUBLE
12823: EQUAL
12824: IFTRUE 12828
12826: GO 12954
12828: POP
// begin check_remote ( veh ) ;
12829: LD_VAR 0 1
12833: PPUSH
12834: CALL 35164 0 1
// list := ready_forces [ side ] ^ veh ;
12838: LD_ADDR_VAR 0 4
12842: PUSH
12843: LD_EXP 65
12847: PUSH
12848: LD_VAR 0 3
12852: ARRAY
12853: PUSH
12854: LD_VAR 0 1
12858: ADD
12859: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , list ) ;
12860: LD_ADDR_EXP 65
12864: PUSH
12865: LD_EXP 65
12869: PPUSH
12870: LD_VAR 0 3
12874: PPUSH
12875: LD_VAR 0 4
12879: PPUSH
12880: CALL_OW 1
12884: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_control_tower ] ] ) ;
12885: LD_ADDR_VAR 0 5
12889: PUSH
12890: LD_INT 22
12892: PUSH
12893: LD_VAR 0 3
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 30
12904: PUSH
12905: LD_INT 36
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PPUSH
12916: CALL_OW 69
12920: ST_TO_ADDR
// AddComMoveToArea ( veh , us_parking ) ;
12921: LD_VAR 0 1
12925: PPUSH
12926: LD_INT 22
12928: PPUSH
12929: CALL_OW 173
// if GetWeapon ( veh ) = us_siberium_rocket then
12933: LD_VAR 0 1
12937: PPUSH
12938: CALL_OW 264
12942: PUSH
12943: LD_INT 8
12945: EQUAL
12946: IFFALSE 12952
// US_Wins ;
12948: CALL 13115 0 0
// end ; 2 :
12952: GO 13112
12954: LD_INT 2
12956: DOUBLE
12957: EQUAL
12958: IFTRUE 12962
12960: GO 12977
12962: POP
// ComMoveToArea ( veh , ar_parking ) ; 3 :
12963: LD_VAR 0 1
12967: PPUSH
12968: LD_INT 23
12970: PPUSH
12971: CALL_OW 113
12975: GO 13112
12977: LD_INT 3
12979: DOUBLE
12980: EQUAL
12981: IFTRUE 12985
12983: GO 13111
12985: POP
// begin if GetWeapon ( veh ) = ru_siberium_rocket then
12986: LD_VAR 0 1
12990: PPUSH
12991: CALL_OW 264
12995: PUSH
12996: LD_INT 48
12998: EQUAL
12999: IFFALSE 13030
// begin if us in cpu_list then
13001: LD_EXP 3
13005: PUSH
13006: LD_EXP 8
13010: IN
13011: IFFALSE 13024
// send_sib_to_US ( veh ) else
13013: LD_VAR 0 1
13017: PPUSH
13018: CALL 36580 0 1
13022: GO 13028
// RU_Wins ;
13024: CALL 13305 0 0
// end else
13028: GO 13109
// begin list := ready_forces [ side ] ^ veh ;
13030: LD_ADDR_VAR 0 4
13034: PUSH
13035: LD_EXP 65
13039: PUSH
13040: LD_VAR 0 3
13044: ARRAY
13045: PUSH
13046: LD_VAR 0 1
13050: ADD
13051: ST_TO_ADDR
// ready_forces := Delete ( ready_forces , side ) ;
13052: LD_ADDR_EXP 65
13056: PUSH
13057: LD_EXP 65
13061: PPUSH
13062: LD_VAR 0 3
13066: PPUSH
13067: CALL_OW 3
13071: ST_TO_ADDR
// ready_forces := Insert ( ready_forces , side , list ) ;
13072: LD_ADDR_EXP 65
13076: PUSH
13077: LD_EXP 65
13081: PPUSH
13082: LD_VAR 0 3
13086: PPUSH
13087: LD_VAR 0 4
13091: PPUSH
13092: CALL_OW 2
13096: ST_TO_ADDR
// ComMoveToArea ( veh , ru_parking ) ;
13097: LD_VAR 0 1
13101: PPUSH
13102: LD_INT 21
13104: PPUSH
13105: CALL_OW 113
// end ; end ; end ;
13109: GO 13112
13111: POP
// end ; end_of_file
13112: PPOPN 5
13114: END
// export function US_Wins ; begin
13115: LD_INT 0
13117: PPUSH
// DialogueOn ;
13118: CALL_OW 6
// if camp = 6 then
13122: LD_EXP 7
13126: PUSH
13127: LD_INT 6
13129: EQUAL
13130: IFFALSE 13143
// CenterOnUnits ( Burlak ) else
13132: LD_EXP 12
13136: PPUSH
13137: CALL_OW 85
13141: GO 13152
// CenterOnUnits ( MacMillan ) ;
13143: LD_EXP 13
13147: PPUSH
13148: CALL_OW 85
// wait ( 0 0$1 ) ;
13152: LD_INT 35
13154: PPUSH
13155: CALL_OW 67
// interface_hidden := true ;
13159: LD_ADDR_OWVAR 54
13163: PUSH
13164: LD_INT 1
13166: ST_TO_ADDR
// Say ( Powell , DWinAmericans-Pow-1 ) ;
13167: LD_EXP 55
13171: PPUSH
13172: LD_STRING DWinAmericans-Pow-1
13174: PPUSH
13175: CALL_OW 88
// case camp of 4 :
13179: LD_EXP 7
13183: PUSH
13184: LD_INT 4
13186: DOUBLE
13187: EQUAL
13188: IFTRUE 13192
13190: GO 13232
13192: POP
// if IsOK ( MacMillan ) then
13193: LD_EXP 13
13197: PPUSH
13198: CALL_OW 302
13202: IFFALSE 13218
// Say ( MacMillan , DWinAmericans-JMM-1 ) else
13204: LD_EXP 13
13208: PPUSH
13209: LD_STRING DWinAmericans-JMM-1
13211: PPUSH
13212: CALL_OW 88
13216: GO 13230
// Say ( Burlak , DWinAmericans-Bur-1 ) ; 6 :
13218: LD_EXP 12
13222: PPUSH
13223: LD_STRING DWinAmericans-Bur-1
13225: PPUSH
13226: CALL_OW 88
13230: GO 13281
13232: LD_INT 6
13234: DOUBLE
13235: EQUAL
13236: IFTRUE 13240
13238: GO 13280
13240: POP
// if IsOK ( Burlak ) then
13241: LD_EXP 12
13245: PPUSH
13246: CALL_OW 302
13250: IFFALSE 13266
// Say ( Burlak , DWinAmericans-Bur-1 ) else
13252: LD_EXP 12
13256: PPUSH
13257: LD_STRING DWinAmericans-Bur-1
13259: PPUSH
13260: CALL_OW 88
13264: GO 13278
// Say ( MacMillan , DWinAmericans-JMM-1 ) ; end ;
13266: LD_EXP 13
13270: PPUSH
13271: LD_STRING DWinAmericans-JMM-1
13273: PPUSH
13274: CALL_OW 88
13278: GO 13281
13280: POP
// interface_hidden := false ;
13281: LD_ADDR_OWVAR 54
13285: PUSH
13286: LD_INT 0
13288: ST_TO_ADDR
// DialogueOff ;
13289: CALL_OW 7
// Mission_failed ( 3 ) ;
13293: LD_INT 3
13295: PPUSH
13296: CALL 13721 0 1
// end ;
13300: LD_VAR 0 1
13304: RET
// export function RU_Wins ; begin
13305: LD_INT 0
13307: PPUSH
// if camp = 6 then
13308: LD_EXP 7
13312: PUSH
13313: LD_INT 6
13315: EQUAL
13316: IFFALSE 13329
// CenterOnUnits ( Burlak ) else
13318: LD_EXP 12
13322: PPUSH
13323: CALL_OW 85
13327: GO 13338
// CenterOnUnits ( MacMillan ) ;
13329: LD_EXP 13
13333: PPUSH
13334: CALL_OW 85
// DialogueOn ;
13338: CALL_OW 6
// InGameOn ;
13342: CALL_OW 8
// wait ( 0 0$1 ) ;
13346: LD_INT 35
13348: PPUSH
13349: CALL_OW 67
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13353: LD_EXP 56
13357: PPUSH
13358: LD_STRING DWinRussians-Pla-1
13360: PPUSH
13361: CALL_OW 94
// case camp of 4 :
13365: LD_EXP 7
13369: PUSH
13370: LD_INT 4
13372: DOUBLE
13373: EQUAL
13374: IFTRUE 13378
13376: GO 13418
13378: POP
// if IsOK ( MacMillan ) then
13379: LD_EXP 13
13383: PPUSH
13384: CALL_OW 302
13388: IFFALSE 13404
// Say ( MacMillan , DWinRussians-JMM-1 ) else
13390: LD_EXP 13
13394: PPUSH
13395: LD_STRING DWinRussians-JMM-1
13397: PPUSH
13398: CALL_OW 88
13402: GO 13416
// Say ( Burlak , DWinRussians-Bur-1 ) ; 6 :
13404: LD_EXP 12
13408: PPUSH
13409: LD_STRING DWinRussians-Bur-1
13411: PPUSH
13412: CALL_OW 88
13416: GO 13467
13418: LD_INT 6
13420: DOUBLE
13421: EQUAL
13422: IFTRUE 13426
13424: GO 13466
13426: POP
// if IsOK ( Burlak ) then
13427: LD_EXP 12
13431: PPUSH
13432: CALL_OW 302
13436: IFFALSE 13452
// Say ( Burlak , DWinRussians-Bur-1 ) else
13438: LD_EXP 12
13442: PPUSH
13443: LD_STRING DWinRussians-Bur-1
13445: PPUSH
13446: CALL_OW 88
13450: GO 13464
// Say ( MacMillan , DWinRussians-JMM-1 ) ; end ;
13452: LD_EXP 13
13456: PPUSH
13457: LD_STRING DWinRussians-JMM-1
13459: PPUSH
13460: CALL_OW 88
13464: GO 13467
13466: POP
// DialogueOff ;
13467: CALL_OW 7
// InGameOff ;
13471: CALL_OW 9
// Mission_failed ( 4 ) ;
13475: LD_INT 4
13477: PPUSH
13478: CALL 13721 0 1
// end ;
13482: LD_VAR 0 1
13486: RET
// on SiberiteRocketExploded ( un , x , y ) do begin InGameOn ;
13487: CALL_OW 8
// siberite_rocket_send := true ;
13491: LD_ADDR_EXP 60
13495: PUSH
13496: LD_INT 1
13498: ST_TO_ADDR
// wait ( 0 0$7 ) ;
13499: LD_INT 245
13501: PPUSH
13502: CALL_OW 67
// RU_Wins ;
13506: CALL 13305 0 0
// end ; end_of_file
13510: PPOPN 3
13512: END
// every 0 0$1 trigger finalize = 2 and ( not OmarWillTryContaminateMotherlode or GetLives ( Omar ) = 0 ) do
13513: LD_EXP 58
13517: PUSH
13518: LD_INT 2
13520: EQUAL
13521: PUSH
13522: LD_EXP 54
13526: NOT
13527: PUSH
13528: LD_EXP 51
13532: PPUSH
13533: CALL_OW 256
13537: PUSH
13538: LD_INT 0
13540: EQUAL
13541: OR
13542: AND
13543: IFFALSE 13559
13545: GO 13547
13547: DISABLE
// begin wait ( 0 0$1 ) ;
13548: LD_INT 35
13550: PPUSH
13551: CALL_OW 67
// Konec_Mise ;
13555: CALL 13560 0 0
// end ;
13559: END
// function Konec_Mise ; var campaign_loading , campaign_lost , another_campaign ; begin
13560: LD_INT 0
13562: PPUSH
13563: PPUSH
13564: PPUSH
13565: PPUSH
// lets_talking ;
13566: CALL 16099 0 0
// another_campaign := true ;
13570: LD_ADDR_VAR 0 4
13574: PUSH
13575: LD_INT 1
13577: ST_TO_ADDR
// gained_medals := [ ] ;
13578: LD_ADDR_OWVAR 61
13582: PUSH
13583: EMPTY
13584: ST_TO_ADDR
// missing_medals := [ ] ;
13585: LD_ADDR_OWVAR 62
13589: PUSH
13590: EMPTY
13591: ST_TO_ADDR
// AddMedal ( Hero , another_campaign ) ;
13592: LD_STRING Hero
13594: PPUSH
13595: LD_VAR 0 4
13599: PPUSH
13600: CALL_OW 101
// AddMedal ( Artefact , GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ) ;
13604: LD_STRING Artefact
13606: PPUSH
13607: LD_INT 81
13609: PPUSH
13610: CALL_OW 110
13614: PUSH
13615: LD_INT 181
13617: PPUSH
13618: CALL_OW 110
13622: AND
13623: PUSH
13624: LD_INT 281
13626: PPUSH
13627: CALL_OW 110
13631: AND
13632: PPUSH
13633: CALL_OW 101
// case camp of 4 :
13637: LD_EXP 7
13641: PUSH
13642: LD_INT 4
13644: DOUBLE
13645: EQUAL
13646: IFTRUE 13650
13648: GO 13670
13650: POP
// AddMedal ( ReconcileBurlak , IsOK ( Burlak ) ) ; 6 :
13651: LD_STRING ReconcileBurlak
13653: PPUSH
13654: LD_EXP 12
13658: PPUSH
13659: CALL_OW 302
13663: PPUSH
13664: CALL_OW 101
13668: GO 13699
13670: LD_INT 6
13672: DOUBLE
13673: EQUAL
13674: IFTRUE 13678
13676: GO 13698
13678: POP
// AddMedal ( ReconcileJMM , IsOK ( MacMillan ) ) ; end ;
13679: LD_STRING ReconcileJMM
13681: PPUSH
13682: LD_EXP 13
13686: PPUSH
13687: CALL_OW 302
13691: PPUSH
13692: CALL_OW 101
13696: GO 13699
13698: POP
// SA_OnMissionComplete ;
13699: CALL 42301 0 0
// GiveMedals ( Main ) ;
13703: LD_STRING Main
13705: PPUSH
13706: CALL_OW 102
// YouWin ;
13710: CALL_OW 103
// exit ;
13714: GO 13716
// end ;
13716: LD_VAR 0 1
13720: RET
// export function Mission_Failed ( how ) ; begin
13721: LD_INT 0
13723: PPUSH
// case how of 1 :
13724: LD_VAR 0 1
13728: PUSH
13729: LD_INT 1
13731: DOUBLE
13732: EQUAL
13733: IFTRUE 13737
13735: GO 13747
13737: POP
// YouLost ( JMM ) ; 2 :
13738: LD_STRING JMM
13740: PPUSH
13741: CALL_OW 104
13745: GO 13820
13747: LD_INT 2
13749: DOUBLE
13750: EQUAL
13751: IFTRUE 13755
13753: GO 13765
13755: POP
// YouLost ( Burlak ) ; 3 :
13756: LD_STRING Burlak
13758: PPUSH
13759: CALL_OW 104
13763: GO 13820
13765: LD_INT 3
13767: DOUBLE
13768: EQUAL
13769: IFTRUE 13773
13771: GO 13783
13773: POP
// YouLost ( AmBomb ) ; 4 :
13774: LD_STRING AmBomb
13776: PPUSH
13777: CALL_OW 104
13781: GO 13820
13783: LD_INT 4
13785: DOUBLE
13786: EQUAL
13787: IFTRUE 13791
13789: GO 13801
13791: POP
// YouLost ( RuBomb ) ; 5 :
13792: LD_STRING RuBomb
13794: PPUSH
13795: CALL_OW 104
13799: GO 13820
13801: LD_INT 5
13803: DOUBLE
13804: EQUAL
13805: IFTRUE 13809
13807: GO 13819
13809: POP
// YouLost ( MothContaminate ) ; end ;
13810: LD_STRING MothContaminate
13812: PPUSH
13813: CALL_OW 104
13817: GO 13820
13819: POP
// end ; end_of_file
13820: LD_VAR 0 2
13824: RET
// function Base_Destroyed ( side ) ; var un , list , vysledek ; begin
13825: LD_INT 0
13827: PPUSH
13828: PPUSH
13829: PPUSH
13830: PPUSH
// vysledek := false ;
13831: LD_ADDR_VAR 0 5
13835: PUSH
13836: LD_INT 0
13838: ST_TO_ADDR
// if not ( FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] ] ) or FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ) then
13839: LD_INT 22
13841: PUSH
13842: LD_VAR 0 1
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: LD_INT 2
13853: PUSH
13854: LD_INT 30
13856: PUSH
13857: LD_INT 0
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: PUSH
13864: LD_INT 30
13866: PUSH
13867: LD_INT 1
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: LIST
13878: PUSH
13879: LD_INT 50
13881: PUSH
13882: EMPTY
13883: LIST
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: LIST
13889: PPUSH
13890: CALL_OW 69
13894: PUSH
13895: LD_INT 22
13897: PUSH
13898: LD_VAR 0 1
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 25
13909: PUSH
13910: LD_INT 2
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PUSH
13917: LD_INT 50
13919: PUSH
13920: EMPTY
13921: LIST
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: LIST
13927: PPUSH
13928: CALL_OW 69
13932: OR
13933: NOT
13934: IFFALSE 13944
// vysledek := true ;
13936: LD_ADDR_VAR 0 5
13940: PUSH
13941: LD_INT 1
13943: ST_TO_ADDR
// if not vysledek then
13944: LD_VAR 0 5
13948: NOT
13949: IFFALSE 14012
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
13951: LD_ADDR_VAR 0 4
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_VAR 0 1
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PUSH
13968: LD_INT 21
13970: PUSH
13971: LD_INT 1
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PUSH
13978: LD_INT 50
13980: PUSH
13981: EMPTY
13982: LIST
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: LIST
13988: PPUSH
13989: CALL_OW 69
13993: ST_TO_ADDR
// if list < 3 then
13994: LD_VAR 0 4
13998: PUSH
13999: LD_INT 3
14001: LESS
14002: IFFALSE 14012
// vysledek := true ;
14004: LD_ADDR_VAR 0 5
14008: PUSH
14009: LD_INT 1
14011: ST_TO_ADDR
// end ; if not vysledek then
14012: LD_VAR 0 5
14016: NOT
14017: IFFALSE 14147
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_ok ] ] ) ;
14019: LD_ADDR_VAR 0 4
14023: PUSH
14024: LD_INT 22
14026: PUSH
14027: LD_VAR 0 1
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 2
14038: PUSH
14039: LD_INT 30
14041: PUSH
14042: LD_INT 32
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: LD_INT 30
14051: PUSH
14052: LD_INT 33
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: LIST
14063: PUSH
14064: LD_INT 50
14066: PUSH
14067: EMPTY
14068: LIST
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: LIST
14074: PPUSH
14075: CALL_OW 69
14079: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
14080: LD_ADDR_VAR 0 3
14084: PUSH
14085: LD_INT 22
14087: PUSH
14088: LD_VAR 0 1
14092: PUSH
14093: EMPTY
14094: LIST
14095: LIST
14096: PUSH
14097: LD_INT 21
14099: PUSH
14100: LD_INT 2
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 50
14109: PUSH
14110: EMPTY
14111: LIST
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: PPUSH
14118: CALL_OW 69
14122: ST_TO_ADDR
// if ( un + list ) < 5 then
14123: LD_VAR 0 3
14127: PUSH
14128: LD_VAR 0 4
14132: PLUS
14133: PUSH
14134: LD_INT 5
14136: LESS
14137: IFFALSE 14147
// vysledek := true ;
14139: LD_ADDR_VAR 0 5
14143: PUSH
14144: LD_INT 1
14146: ST_TO_ADDR
// end ; if not vysledek then
14147: LD_VAR 0 5
14151: NOT
14152: IFFALSE 14241
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] , [ f_ok ] ] ) ;
14154: LD_ADDR_VAR 0 4
14158: PUSH
14159: LD_INT 22
14161: PUSH
14162: LD_VAR 0 1
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: PUSH
14171: LD_INT 2
14173: PUSH
14174: LD_INT 30
14176: PUSH
14177: LD_INT 27
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: PUSH
14184: LD_INT 30
14186: PUSH
14187: LD_INT 26
14189: PUSH
14190: EMPTY
14191: LIST
14192: LIST
14193: PUSH
14194: LD_INT 30
14196: PUSH
14197: LD_INT 28
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: PUSH
14210: LD_INT 50
14212: PUSH
14213: EMPTY
14214: LIST
14215: PUSH
14216: EMPTY
14217: LIST
14218: LIST
14219: LIST
14220: PPUSH
14221: CALL_OW 69
14225: ST_TO_ADDR
// if not list then
14226: LD_VAR 0 4
14230: NOT
14231: IFFALSE 14241
// vysledek := 0 ;
14233: LD_ADDR_VAR 0 5
14237: PUSH
14238: LD_INT 0
14240: ST_TO_ADDR
// end ; result := vysledek ;
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: LD_VAR 0 5
14250: ST_TO_ADDR
// end ;
14251: LD_VAR 0 2
14255: RET
// every 0 0$2.1 trigger Base_Destroyed ( us ) and not siberite_rocket_send do var sol , un , list ;
14256: LD_EXP 3
14260: PPUSH
14261: CALL 13825 0 1
14265: PUSH
14266: LD_EXP 60
14270: NOT
14271: AND
14272: IFFALSE 14839
14274: GO 14276
14276: DISABLE
14277: LD_INT 0
14279: PPUSH
14280: PPUSH
14281: PPUSH
// begin if IsOK ( Powell ) then
14282: LD_EXP 55
14286: PPUSH
14287: CALL_OW 302
14291: IFFALSE 14369
// begin CenterOnUnits ( Powell ) ;
14293: LD_EXP 55
14297: PPUSH
14298: CALL_OW 85
// DialogueOn ;
14302: CALL_OW 6
// interface_hidden := true ;
14306: LD_ADDR_OWVAR 54
14310: PUSH
14311: LD_INT 1
14313: ST_TO_ADDR
// Say ( Powell , DSurrenderAmericans-Pow-1 ) ;
14314: LD_EXP 55
14318: PPUSH
14319: LD_STRING DSurrenderAmericans-Pow-1
14321: PPUSH
14322: CALL_OW 88
// Say ( MacMillan , DSurrenderAmericans-JMM-1 ) ;
14326: LD_EXP 13
14330: PPUSH
14331: LD_STRING DSurrenderAmericans-JMM-1
14333: PPUSH
14334: CALL_OW 88
// interface_hidden := false ;
14338: LD_ADDR_OWVAR 54
14342: PUSH
14343: LD_INT 0
14345: ST_TO_ADDR
// DialogueOff ;
14346: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
14350: LD_INT 35
14352: PPUSH
14353: CALL_OW 67
// until not IsOK ( Powell ) ;
14357: LD_EXP 55
14361: PPUSH
14362: CALL_OW 302
14366: NOT
14367: IFFALSE 14350
// end ; cpu_list := cpu_list diff us ;
14369: LD_ADDR_EXP 8
14373: PUSH
14374: LD_EXP 8
14378: PUSH
14379: LD_EXP 3
14383: DIFF
14384: ST_TO_ADDR
// SetAttitude ( you , us , att_friend , true ) ;
14385: LD_EXP 1
14389: PPUSH
14390: LD_EXP 3
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: LD_INT 1
14400: PPUSH
14401: CALL_OW 80
// sol := FindLastMohycane ( us ) ;
14405: LD_ADDR_VAR 0 1
14409: PUSH
14410: LD_EXP 3
14414: PPUSH
14415: CALL 15715 0 1
14419: ST_TO_ADDR
// if IsOK ( sol ) then
14420: LD_VAR 0 1
14424: PPUSH
14425: CALL_OW 302
14429: IFFALSE 14440
// ComExitBuilding ( sol ) ;
14431: LD_VAR 0 1
14435: PPUSH
14436: CALL_OW 122
// while not See ( you , sol ) do
14440: LD_EXP 1
14444: PPUSH
14445: LD_VAR 0 1
14449: PPUSH
14450: CALL_OW 292
14454: NOT
14455: IFFALSE 14522
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
14457: LD_ADDR_VAR 0 2
14461: PUSH
14462: LD_INT 22
14464: PUSH
14465: LD_EXP 1
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PUSH
14474: LD_INT 50
14476: PUSH
14477: EMPTY
14478: LIST
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PPUSH
14484: CALL_OW 69
14488: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
14489: LD_VAR 0 1
14493: PPUSH
14494: LD_VAR 0 2
14498: PPUSH
14499: LD_VAR 0 1
14503: PPUSH
14504: CALL_OW 74
14508: PPUSH
14509: CALL_OW 112
// wait ( 0 0$1 ) ;
14513: LD_INT 35
14515: PPUSH
14516: CALL_OW 67
// end ;
14520: GO 14440
// CenterOnUnits ( sol ) ;
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 85
// DialogueOn ;
14531: CALL_OW 6
// interface_hidden := true ;
14535: LD_ADDR_OWVAR 54
14539: PUSH
14540: LD_INT 1
14542: ST_TO_ADDR
// case camp of 4 :
14543: LD_EXP 7
14547: PUSH
14548: LD_INT 4
14550: DOUBLE
14551: EQUAL
14552: IFTRUE 14556
14554: GO 14571
14556: POP
// Say ( sol , DSurrenderAmericans-Sol1-1a ) ; 6 :
14557: LD_VAR 0 1
14561: PPUSH
14562: LD_STRING DSurrenderAmericans-Sol1-1a
14564: PPUSH
14565: CALL_OW 88
14569: GO 14595
14571: LD_INT 6
14573: DOUBLE
14574: EQUAL
14575: IFTRUE 14579
14577: GO 14594
14579: POP
// Say ( sol , DSurrenderAmericans-Sol1-1 ) ; end ;
14580: LD_VAR 0 1
14584: PPUSH
14585: LD_STRING DSurrenderAmericans-Sol1-1
14587: PPUSH
14588: CALL_OW 88
14592: GO 14595
14594: POP
// interface_hidden := false ;
14595: LD_ADDR_OWVAR 54
14599: PUSH
14600: LD_INT 0
14602: ST_TO_ADDR
// DialogueOff ;
14603: CALL_OW 7
// finalize := finalize + 1 ;
14607: LD_ADDR_EXP 58
14611: PUSH
14612: LD_EXP 58
14616: PUSH
14617: LD_INT 1
14619: PLUS
14620: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , us ] , f_not , [ f_type , unit_human ] ] ) ;
14621: LD_ADDR_VAR 0 3
14625: PUSH
14626: LD_INT 22
14628: PUSH
14629: LD_EXP 3
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: PUSH
14638: LD_INT 3
14640: PUSH
14641: LD_INT 21
14643: PUSH
14644: LD_INT 1
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: LIST
14655: PPUSH
14656: CALL_OW 69
14660: ST_TO_ADDR
// SetSide ( list , you ) ;
14661: LD_VAR 0 3
14665: PPUSH
14666: LD_EXP 1
14670: PPUSH
14671: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
14675: LD_VAR 0 3
14679: PPUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 2
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PPUSH
14690: CALL_OW 72
14694: PPUSH
14695: CALL 14842 0 1
// repeat list := FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14699: LD_ADDR_VAR 0 3
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_EXP 3
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: PUSH
14716: LD_INT 21
14718: PUSH
14719: LD_INT 1
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: PUSH
14726: LD_INT 50
14728: PUSH
14729: EMPTY
14730: LIST
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: LIST
14736: PPUSH
14737: CALL_OW 69
14741: ST_TO_ADDR
// ComMoveToArea ( list , am_leaving_area ) ;
14742: LD_VAR 0 3
14746: PPUSH
14747: LD_INT 30
14749: PPUSH
14750: CALL_OW 113
// if list then
14754: LD_VAR 0 3
14758: IFFALSE 14767
// wait ( 0 0$2 ) ;
14760: LD_INT 70
14762: PPUSH
14763: CALL_OW 67
// sol := FilterUnitsInArea ( am_leaving_area , [ [ f_side , us ] , [ f_type , unit_human ] ] ) ;
14767: LD_ADDR_VAR 0 1
14771: PUSH
14772: LD_INT 30
14774: PPUSH
14775: LD_INT 22
14777: PUSH
14778: LD_EXP 3
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: LD_INT 21
14789: PUSH
14790: LD_INT 1
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: PUSH
14797: EMPTY
14798: LIST
14799: LIST
14800: PPUSH
14801: CALL_OW 70
14805: ST_TO_ADDR
// for un in sol do
14806: LD_ADDR_VAR 0 2
14810: PUSH
14811: LD_VAR 0 1
14815: PUSH
14816: FOR_IN
14817: IFFALSE 14830
// RemoveUnit ( un ) ;
14819: LD_VAR 0 2
14823: PPUSH
14824: CALL_OW 64
14828: GO 14816
14830: POP
14831: POP
// until not list ;
14832: LD_VAR 0 3
14836: NOT
14837: IFFALSE 14699
// end ;
14839: PPOPN 3
14841: END
// function DestroyAndReplaceVehicles ( list ) ; var i , x , y , driver , veh ; begin
14842: LD_INT 0
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
// for i in list do
14850: LD_ADDR_VAR 0 3
14854: PUSH
14855: LD_VAR 0 1
14859: PUSH
14860: FOR_IN
14861: IFFALSE 15122
// begin InitUc ;
14863: CALL_OW 18
// InitVc ;
14867: CALL_OW 20
// uc_nation = GetNation ( i ) ;
14871: LD_ADDR_OWVAR 21
14875: PUSH
14876: LD_VAR 0 3
14880: PPUSH
14881: CALL_OW 248
14885: ST_TO_ADDR
// uc_side = GetSide ( i ) ;
14886: LD_ADDR_OWVAR 20
14890: PUSH
14891: LD_VAR 0 3
14895: PPUSH
14896: CALL_OW 255
14900: ST_TO_ADDR
// uc_direction = GetDir ( i ) ;
14901: LD_ADDR_OWVAR 24
14905: PUSH
14906: LD_VAR 0 3
14910: PPUSH
14911: CALL_OW 254
14915: ST_TO_ADDR
// vc_chassis = GetChassis ( i ) ;
14916: LD_ADDR_OWVAR 37
14920: PUSH
14921: LD_VAR 0 3
14925: PPUSH
14926: CALL_OW 265
14930: ST_TO_ADDR
// vc_engine = GetEngine ( i ) ;
14931: LD_ADDR_OWVAR 39
14935: PUSH
14936: LD_VAR 0 3
14940: PPUSH
14941: CALL_OW 262
14945: ST_TO_ADDR
// vc_weapon = GetWeapon ( i ) ;
14946: LD_ADDR_OWVAR 40
14950: PUSH
14951: LD_VAR 0 3
14955: PPUSH
14956: CALL_OW 264
14960: ST_TO_ADDR
// vc_control = GetControl ( i ) ;
14961: LD_ADDR_OWVAR 38
14965: PUSH
14966: LD_VAR 0 3
14970: PPUSH
14971: CALL_OW 263
14975: ST_TO_ADDR
// vc_fuel_battery = GetFuel ( i ) ;
14976: LD_ADDR_OWVAR 41
14980: PUSH
14981: LD_VAR 0 3
14985: PPUSH
14986: CALL_OW 261
14990: ST_TO_ADDR
// x = GetX ( i ) ;
14991: LD_ADDR_VAR 0 4
14995: PUSH
14996: LD_VAR 0 3
15000: PPUSH
15001: CALL_OW 250
15005: ST_TO_ADDR
// y = GetY ( i ) ;
15006: LD_ADDR_VAR 0 5
15010: PUSH
15011: LD_VAR 0 3
15015: PPUSH
15016: CALL_OW 251
15020: ST_TO_ADDR
// driver = IsDrivenBy ( i ) ;
15021: LD_ADDR_VAR 0 6
15025: PUSH
15026: LD_VAR 0 3
15030: PPUSH
15031: CALL_OW 311
15035: ST_TO_ADDR
// if driver > 0 then
15036: LD_VAR 0 6
15040: PUSH
15041: LD_INT 0
15043: GREATER
15044: IFFALSE 15055
// RemoveUnit ( driver ) ;
15046: LD_VAR 0 6
15050: PPUSH
15051: CALL_OW 64
// DestroyUnit ( i ) ;
15055: LD_VAR 0 3
15059: PPUSH
15060: CALL_OW 65
// veh = CreateVehicle ;
15064: LD_ADDR_VAR 0 7
15068: PUSH
15069: CALL_OW 45
15073: ST_TO_ADDR
// PlaceUnitXY ( veh , x , y , false ) ;
15074: LD_VAR 0 7
15078: PPUSH
15079: LD_VAR 0 4
15083: PPUSH
15084: LD_VAR 0 5
15088: PPUSH
15089: LD_INT 0
15091: PPUSH
15092: CALL_OW 48
// if driver > 0 then
15096: LD_VAR 0 6
15100: PUSH
15101: LD_INT 0
15103: GREATER
15104: IFFALSE 15120
// PlaceHumanInUnit ( driver , veh ) ;
15106: LD_VAR 0 6
15110: PPUSH
15111: LD_VAR 0 7
15115: PPUSH
15116: CALL_OW 52
// end ;
15120: GO 14860
15122: POP
15123: POP
// end ;
15124: LD_VAR 0 2
15128: RET
// every 0 0$2.3 trigger Base_Destroyed ( ru ) and not siberite_rocket_send do var list , sol , un ;
15129: LD_EXP 2
15133: PPUSH
15134: CALL 13825 0 1
15138: PUSH
15139: LD_EXP 60
15143: NOT
15144: AND
15145: IFFALSE 15712
15147: GO 15149
15149: DISABLE
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
// begin if IsOK ( Platonov ) then
15155: LD_EXP 56
15159: PPUSH
15160: CALL_OW 302
15164: IFFALSE 15242
// begin CenterOnUnits ( Platonov ) ;
15166: LD_EXP 56
15170: PPUSH
15171: CALL_OW 85
// DialogueOn ;
15175: CALL_OW 6
// interface_hidden := true ;
15179: LD_ADDR_OWVAR 54
15183: PUSH
15184: LD_INT 1
15186: ST_TO_ADDR
// Say ( Platonov , DSurrenderRussians-Pla-1 ) ;
15187: LD_EXP 56
15191: PPUSH
15192: LD_STRING DSurrenderRussians-Pla-1
15194: PPUSH
15195: CALL_OW 88
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15199: LD_EXP 12
15203: PPUSH
15204: LD_STRING DSurrenderRussians-Bur-1
15206: PPUSH
15207: CALL_OW 88
// interface_hidden := false ;
15211: LD_ADDR_OWVAR 54
15215: PUSH
15216: LD_INT 0
15218: ST_TO_ADDR
// DialogueOff ;
15219: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
15223: LD_INT 35
15225: PPUSH
15226: CALL_OW 67
// until not IsOK ( Platonov ) ;
15230: LD_EXP 56
15234: PPUSH
15235: CALL_OW 302
15239: NOT
15240: IFFALSE 15223
// end ; cpu_list := cpu_list diff ru ;
15242: LD_ADDR_EXP 8
15246: PUSH
15247: LD_EXP 8
15251: PUSH
15252: LD_EXP 2
15256: DIFF
15257: ST_TO_ADDR
// SetAttitude ( you , ru , att_friend , true ) ;
15258: LD_EXP 1
15262: PPUSH
15263: LD_EXP 2
15267: PPUSH
15268: LD_INT 1
15270: PPUSH
15271: LD_INT 1
15273: PPUSH
15274: CALL_OW 80
// sol := FindLastMohycane ( ru ) ;
15278: LD_ADDR_VAR 0 2
15282: PUSH
15283: LD_EXP 2
15287: PPUSH
15288: CALL 15715 0 1
15292: ST_TO_ADDR
// if IsOK ( sol ) then
15293: LD_VAR 0 2
15297: PPUSH
15298: CALL_OW 302
15302: IFFALSE 15313
// ComExitBuilding ( sol ) ;
15304: LD_VAR 0 2
15308: PPUSH
15309: CALL_OW 122
// while not See ( you , sol ) do
15313: LD_EXP 1
15317: PPUSH
15318: LD_VAR 0 2
15322: PPUSH
15323: CALL_OW 292
15327: NOT
15328: IFFALSE 15395
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
15330: LD_ADDR_VAR 0 3
15334: PUSH
15335: LD_INT 22
15337: PUSH
15338: LD_EXP 1
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 50
15349: PUSH
15350: EMPTY
15351: LIST
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PPUSH
15357: CALL_OW 69
15361: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
15362: LD_VAR 0 2
15366: PPUSH
15367: LD_VAR 0 3
15371: PPUSH
15372: LD_VAR 0 2
15376: PPUSH
15377: CALL_OW 74
15381: PPUSH
15382: CALL_OW 112
// wait ( 0 0$1 ) ;
15386: LD_INT 35
15388: PPUSH
15389: CALL_OW 67
// end ;
15393: GO 15313
// CenterOnUnits ( sol ) ;
15395: LD_VAR 0 2
15399: PPUSH
15400: CALL_OW 85
// DialogueOn ;
15404: CALL_OW 6
// interface_hidden := true ;
15408: LD_ADDR_OWVAR 54
15412: PUSH
15413: LD_INT 1
15415: ST_TO_ADDR
// case camp of 4 :
15416: LD_EXP 7
15420: PUSH
15421: LD_INT 4
15423: DOUBLE
15424: EQUAL
15425: IFTRUE 15429
15427: GO 15444
15429: POP
// Say ( sol , DSurrenderRussians-Rsol1-1a ) ; 6 :
15430: LD_VAR 0 2
15434: PPUSH
15435: LD_STRING DSurrenderRussians-Rsol1-1a
15437: PPUSH
15438: CALL_OW 88
15442: GO 15468
15444: LD_INT 6
15446: DOUBLE
15447: EQUAL
15448: IFTRUE 15452
15450: GO 15467
15452: POP
// Say ( sol , DSurrenderRussians-Rsol1-1 ) ; end ;
15453: LD_VAR 0 2
15457: PPUSH
15458: LD_STRING DSurrenderRussians-Rsol1-1
15460: PPUSH
15461: CALL_OW 88
15465: GO 15468
15467: POP
// interface_hidden := false ;
15468: LD_ADDR_OWVAR 54
15472: PUSH
15473: LD_INT 0
15475: ST_TO_ADDR
// DialogueOff ;
15476: CALL_OW 7
// finalize := finalize + 1 ;
15480: LD_ADDR_EXP 58
15484: PUSH
15485: LD_EXP 58
15489: PUSH
15490: LD_INT 1
15492: PLUS
15493: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , ru ] , f_not , [ f_type , unit_human ] ] ) ;
15494: LD_ADDR_VAR 0 1
15498: PUSH
15499: LD_INT 22
15501: PUSH
15502: LD_EXP 2
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: LD_INT 3
15513: PUSH
15514: LD_INT 21
15516: PUSH
15517: LD_INT 1
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: PPUSH
15529: CALL_OW 69
15533: ST_TO_ADDR
// SetSide ( list , you ) ;
15534: LD_VAR 0 1
15538: PPUSH
15539: LD_EXP 1
15543: PPUSH
15544: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15548: LD_VAR 0 1
15552: PPUSH
15553: LD_INT 21
15555: PUSH
15556: LD_INT 2
15558: PUSH
15559: EMPTY
15560: LIST
15561: LIST
15562: PPUSH
15563: CALL_OW 72
15567: PPUSH
15568: CALL 14842 0 1
// repeat list := FilterAllUnits ( [ [ f_side , ru ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
15572: LD_ADDR_VAR 0 1
15576: PUSH
15577: LD_INT 22
15579: PUSH
15580: LD_EXP 2
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 21
15591: PUSH
15592: LD_INT 1
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: LD_INT 50
15601: PUSH
15602: EMPTY
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: LIST
15609: PPUSH
15610: CALL_OW 69
15614: ST_TO_ADDR
// ComMoveToArea ( list , ru_leaving_area ) ;
15615: LD_VAR 0 1
15619: PPUSH
15620: LD_INT 31
15622: PPUSH
15623: CALL_OW 113
// if list then
15627: LD_VAR 0 1
15631: IFFALSE 15640
// wait ( 0 0$2 ) ;
15633: LD_INT 70
15635: PPUSH
15636: CALL_OW 67
// sol := FilterUnitsInArea ( ru_leaving_area , [ [ f_side , ru ] , [ f_type , unit_human ] ] ) ;
15640: LD_ADDR_VAR 0 2
15644: PUSH
15645: LD_INT 31
15647: PPUSH
15648: LD_INT 22
15650: PUSH
15651: LD_EXP 2
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: PUSH
15660: LD_INT 21
15662: PUSH
15663: LD_INT 1
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 70
15678: ST_TO_ADDR
// for un in sol do
15679: LD_ADDR_VAR 0 3
15683: PUSH
15684: LD_VAR 0 2
15688: PUSH
15689: FOR_IN
15690: IFFALSE 15703
// RemoveUnit ( un ) ;
15692: LD_VAR 0 3
15696: PPUSH
15697: CALL_OW 64
15701: GO 15689
15703: POP
15704: POP
// until not list ;
15705: LD_VAR 0 1
15709: NOT
15710: IFFALSE 15572
// end ;
15712: PPOPN 3
15714: END
// function FindLastMohycane ( side ) ; var area , un , list , build , unseen , vysledek ; begin
15715: LD_INT 0
15717: PPUSH
15718: PPUSH
15719: PPUSH
15720: PPUSH
15721: PPUSH
15722: PPUSH
15723: PPUSH
// case side of us :
15724: LD_VAR 0 1
15728: PUSH
15729: LD_EXP 3
15733: DOUBLE
15734: EQUAL
15735: IFTRUE 15739
15737: GO 15750
15739: POP
// area := us_base ; ru :
15740: LD_ADDR_VAR 0 3
15744: PUSH
15745: LD_INT 11
15747: ST_TO_ADDR
15748: GO 15772
15750: LD_EXP 2
15754: DOUBLE
15755: EQUAL
15756: IFTRUE 15760
15758: GO 15771
15760: POP
// area := ru_base ; end ;
15761: LD_ADDR_VAR 0 3
15765: PUSH
15766: LD_INT 12
15768: ST_TO_ADDR
15769: GO 15772
15771: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
15772: LD_ADDR_VAR 0 5
15776: PUSH
15777: LD_INT 22
15779: PUSH
15780: LD_VAR 0 1
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: PUSH
15789: LD_INT 21
15791: PUSH
15792: LD_INT 1
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: PUSH
15799: LD_INT 26
15801: PUSH
15802: LD_INT 1
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PUSH
15809: LD_INT 50
15811: PUSH
15812: EMPTY
15813: LIST
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: LIST
15819: LIST
15820: PPUSH
15821: CALL_OW 69
15825: PUSH
15826: LD_INT 22
15828: PUSH
15829: LD_VAR 0 1
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 2
15840: PUSH
15841: LD_INT 25
15843: PUSH
15844: LD_INT 12
15846: PUSH
15847: EMPTY
15848: LIST
15849: LIST
15850: PUSH
15851: LD_INT 25
15853: PUSH
15854: LD_INT 15
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: PUSH
15861: LD_INT 25
15863: PUSH
15864: LD_INT 16
15866: PUSH
15867: EMPTY
15868: LIST
15869: LIST
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 17
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: LIST
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: PPUSH
15892: CALL_OW 69
15896: DIFF
15897: ST_TO_ADDR
// if list then
15898: LD_VAR 0 5
15902: IFFALSE 15924
// vysledek := FindMaxSkill ( list , skill_combat ) else
15904: LD_ADDR_VAR 0 8
15908: PUSH
15909: LD_VAR 0 5
15913: PPUSH
15914: LD_INT 1
15916: PPUSH
15917: CALL_OW 433
15921: ST_TO_ADDR
15922: GO 16084
// begin unseen := 0 ;
15924: LD_ADDR_VAR 0 7
15928: PUSH
15929: LD_INT 0
15931: ST_TO_ADDR
// build := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_ok ] ] ) ;
15932: LD_ADDR_VAR 0 6
15936: PUSH
15937: LD_INT 22
15939: PUSH
15940: LD_VAR 0 1
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: LD_INT 58
15951: PUSH
15952: EMPTY
15953: LIST
15954: PUSH
15955: LD_INT 50
15957: PUSH
15958: EMPTY
15959: LIST
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: LIST
15965: PPUSH
15966: CALL_OW 69
15970: ST_TO_ADDR
// for un in build do
15971: LD_ADDR_VAR 0 4
15975: PUSH
15976: LD_VAR 0 6
15980: PUSH
15981: FOR_IN
15982: IFFALSE 16015
// if not See ( you , un ) then
15984: LD_EXP 1
15988: PPUSH
15989: LD_VAR 0 4
15993: PPUSH
15994: CALL_OW 292
15998: NOT
15999: IFFALSE 16013
// begin unseen := un ;
16001: LD_ADDR_VAR 0 7
16005: PUSH
16006: LD_VAR 0 4
16010: ST_TO_ADDR
// break ;
16011: GO 16015
// end ;
16013: GO 15981
16015: POP
16016: POP
// if ( not unseen ) and build then
16017: LD_VAR 0 7
16021: NOT
16022: PUSH
16023: LD_VAR 0 6
16027: AND
16028: IFFALSE 16044
// unseen := build [ 1 ] ;
16030: LD_ADDR_VAR 0 7
16034: PUSH
16035: LD_VAR 0 6
16039: PUSH
16040: LD_INT 1
16042: ARRAY
16043: ST_TO_ADDR
// if unseen then
16044: LD_VAR 0 7
16048: IFFALSE 16084
// begin PrepareSoldier ( sex_male , 5 ) ;
16050: LD_INT 1
16052: PPUSH
16053: LD_INT 5
16055: PPUSH
16056: CALL_OW 381
// vysledek := CreateHuman ;
16060: LD_ADDR_VAR 0 8
16064: PUSH
16065: CALL_OW 44
16069: ST_TO_ADDR
// PlaceHumanInUnit ( vysledek , unseen ) ;
16070: LD_VAR 0 8
16074: PPUSH
16075: LD_VAR 0 7
16079: PPUSH
16080: CALL_OW 52
// end ; end ; result := vysledek ;
16084: LD_ADDR_VAR 0 2
16088: PUSH
16089: LD_VAR 0 8
16093: ST_TO_ADDR
// end ; end_of_file
16094: LD_VAR 0 2
16098: RET
// export function lets_talking ; begin
16099: LD_INT 0
16101: PPUSH
// DialogueOn ;
16102: CALL_OW 6
// interface_hidden := true ;
16106: LD_ADDR_OWVAR 54
16110: PUSH
16111: LD_INT 1
16113: ST_TO_ADDR
// case camp of 4 :
16114: LD_EXP 7
16118: PUSH
16119: LD_INT 4
16121: DOUBLE
16122: EQUAL
16123: IFTRUE 16127
16125: GO 16134
16127: POP
// us_talking ; 6 :
16128: CALL 17199 0 0
16132: GO 16150
16134: LD_INT 6
16136: DOUBLE
16137: EQUAL
16138: IFTRUE 16142
16140: GO 16149
16142: POP
// ru_talking ; end ;
16143: CALL 16167 0 0
16147: GO 16150
16149: POP
// interface_hidden := false ;
16150: LD_ADDR_OWVAR 54
16154: PUSH
16155: LD_INT 0
16157: ST_TO_ADDR
// DialogueOff ;
16158: CALL_OW 7
// end ;
16162: LD_VAR 0 1
16166: RET
// function ru_talking ; begin
16167: LD_INT 0
16169: PPUSH
// if IsOK ( Burlak ) then
16170: LD_EXP 12
16174: PPUSH
16175: CALL_OW 302
16179: IFFALSE 16202
// begin CenterOnUnits ( Burlak ) ;
16181: LD_EXP 12
16185: PPUSH
16186: CALL_OW 85
// Say ( Burlak , DEnd-Burlak-Bur-1 ) ;
16190: LD_EXP 12
16194: PPUSH
16195: LD_STRING DEnd-Burlak-Bur-1
16197: PPUSH
16198: CALL_OW 88
// end ; if IsOK ( Petrosyan ) then
16202: LD_EXP 16
16206: PPUSH
16207: CALL_OW 302
16211: IFFALSE 16234
// begin CenterOnUnits ( Petrosyan ) ;
16213: LD_EXP 16
16217: PPUSH
16218: CALL_OW 85
// Say ( Petrosyan , DEnd-Burlak-Pty-1 ) ;
16222: LD_EXP 16
16226: PPUSH
16227: LD_STRING DEnd-Burlak-Pty-1
16229: PPUSH
16230: CALL_OW 88
// end ; if IsOK ( Belkov ) then
16234: LD_EXP 17
16238: PPUSH
16239: CALL_OW 302
16243: IFFALSE 16266
// begin CenterOnUnits ( Belkov ) ;
16245: LD_EXP 17
16249: PPUSH
16250: CALL_OW 85
// Say ( Belkov , DEnd-Burlak-Bel-1 ) ;
16254: LD_EXP 17
16258: PPUSH
16259: LD_STRING DEnd-Burlak-Bel-1
16261: PPUSH
16262: CALL_OW 88
// end ; if IsOK ( Kirilenkova ) then
16266: LD_EXP 18
16270: PPUSH
16271: CALL_OW 302
16275: IFFALSE 16298
// begin CenterOnUnits ( Kirilenkova ) ;
16277: LD_EXP 18
16281: PPUSH
16282: CALL_OW 85
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16286: LD_EXP 18
16290: PPUSH
16291: LD_STRING DEnd-Burlak-Kir-1
16293: PPUSH
16294: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
16298: LD_EXP 19
16302: PPUSH
16303: CALL_OW 302
16307: IFFALSE 16330
// begin CenterOnUnits ( Gnyevko ) ;
16309: LD_EXP 19
16313: PPUSH
16314: CALL_OW 85
// Say ( Gnyevko , DEnd-Burlak-Gny-1 ) ;
16318: LD_EXP 19
16322: PPUSH
16323: LD_STRING DEnd-Burlak-Gny-1
16325: PPUSH
16326: CALL_OW 88
// end ; if IsOK ( Gladkov ) then
16330: LD_EXP 20
16334: PPUSH
16335: CALL_OW 302
16339: IFFALSE 16362
// begin CenterOnUnits ( Gladkov ) ;
16341: LD_EXP 20
16345: PPUSH
16346: CALL_OW 85
// Say ( Gladkov , DEnd-Burlak-Gla-1 ) ;
16350: LD_EXP 20
16354: PPUSH
16355: LD_STRING DEnd-Burlak-Gla-1
16357: PPUSH
16358: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
16362: LD_EXP 21
16366: PPUSH
16367: CALL_OW 302
16371: IFFALSE 16394
// begin CenterOnUnits ( Dolgov ) ;
16373: LD_EXP 21
16377: PPUSH
16378: CALL_OW 85
// Say ( Dolgov , DEnd-Burlak-Dol-1 ) ;
16382: LD_EXP 21
16386: PPUSH
16387: LD_STRING DEnd-Burlak-Dol-1
16389: PPUSH
16390: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
16394: LD_EXP 23
16398: PPUSH
16399: CALL_OW 302
16403: IFFALSE 16426
// begin CenterOnUnits ( Kapitsova ) ;
16405: LD_EXP 23
16409: PPUSH
16410: CALL_OW 85
// Say ( Kapitsova , DEnd-Burlak-Kap-1 ) ;
16414: LD_EXP 23
16418: PPUSH
16419: LD_STRING DEnd-Burlak-Kap-1
16421: PPUSH
16422: CALL_OW 88
// end ; if IsOK ( Gleb ) then
16426: LD_EXP 22
16430: PPUSH
16431: CALL_OW 302
16435: IFFALSE 16458
// begin CenterOnUnits ( Gleb ) ;
16437: LD_EXP 22
16441: PPUSH
16442: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
16446: LD_EXP 22
16450: PPUSH
16451: LD_STRING DEnd-JMM-Glb-1
16453: PPUSH
16454: CALL_OW 88
// end ; if IsOK ( Kuzmov ) then
16458: LD_EXP 24
16462: PPUSH
16463: CALL_OW 302
16467: IFFALSE 16490
// begin CenterOnUnits ( Kuzmov ) ;
16469: LD_EXP 24
16473: PPUSH
16474: CALL_OW 85
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16478: LD_EXP 24
16482: PPUSH
16483: LD_STRING DEnd-Burlak-Kuz-1
16485: PPUSH
16486: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
16490: LD_EXP 25
16494: PPUSH
16495: CALL_OW 302
16499: IFFALSE 16522
// begin CenterOnUnits ( Kovalyuk ) ;
16501: LD_EXP 25
16505: PPUSH
16506: CALL_OW 85
// Say ( Kovalyuk , DEnd-Burlak-Kov-1 ) ;
16510: LD_EXP 25
16514: PPUSH
16515: LD_STRING DEnd-Burlak-Kov-1
16517: PPUSH
16518: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
16522: LD_EXP 26
16526: PPUSH
16527: CALL_OW 302
16531: IFFALSE 16554
// begin CenterOnUnits ( Scholtze ) ;
16533: LD_EXP 26
16537: PPUSH
16538: CALL_OW 85
// Say ( Scholtze , DEnd-Burlak-Sch-1 ) ;
16542: LD_EXP 26
16546: PPUSH
16547: LD_STRING DEnd-Burlak-Sch-1
16549: PPUSH
16550: CALL_OW 88
// end ; if IsOK ( Karamazov ) then
16554: LD_EXP 27
16558: PPUSH
16559: CALL_OW 302
16563: IFFALSE 16586
// begin CenterOnUnits ( Karamazov ) ;
16565: LD_EXP 27
16569: PPUSH
16570: CALL_OW 85
// Say ( Karamazov , DEnd-Burlak-Kar-1 ) ;
16574: LD_EXP 27
16578: PPUSH
16579: LD_STRING DEnd-Burlak-Kar-1
16581: PPUSH
16582: CALL_OW 88
// end ; if IsOK ( Titov ) then
16586: LD_EXP 28
16590: PPUSH
16591: CALL_OW 302
16595: IFFALSE 16618
// begin CenterOnUnits ( Titov ) ;
16597: LD_EXP 28
16601: PPUSH
16602: CALL_OW 85
// Say ( Titov , DEnd-Burlak-Tit-1 ) ;
16606: LD_EXP 28
16610: PPUSH
16611: LD_STRING DEnd-Burlak-Tit-1
16613: PPUSH
16614: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
16618: LD_EXP 29
16622: PPUSH
16623: CALL_OW 302
16627: IFFALSE 16650
// begin CenterOnUnits ( Oblukov ) ;
16629: LD_EXP 29
16633: PPUSH
16634: CALL_OW 85
// Say ( Oblukov , DEnd-Burlak-Obl-1 ) ;
16638: LD_EXP 29
16642: PPUSH
16643: LD_STRING DEnd-Burlak-Obl-1
16645: PPUSH
16646: CALL_OW 88
// end ; if IsOK ( Kozlov ) then
16650: LD_EXP 30
16654: PPUSH
16655: CALL_OW 302
16659: IFFALSE 16682
// begin CenterOnUnits ( Kozlov ) ;
16661: LD_EXP 30
16665: PPUSH
16666: CALL_OW 85
// Say ( Kozlov , DEnd-Burlak-Koz-1 ) ;
16670: LD_EXP 30
16674: PPUSH
16675: LD_STRING DEnd-Burlak-Koz-1
16677: PPUSH
16678: CALL_OW 88
// end ; if IsOK ( Petrovova ) then
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 302
16691: IFFALSE 16714
// begin CenterOnUnits ( Petrovova ) ;
16693: LD_EXP 31
16697: PPUSH
16698: CALL_OW 85
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16702: LD_EXP 31
16706: PPUSH
16707: LD_STRING DEnd-Burlak-Ptr-1
16709: PPUSH
16710: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
16714: LD_EXP 32
16718: PPUSH
16719: CALL_OW 302
16723: IFFALSE 16746
// begin CenterOnUnits ( Bystrov ) ;
16725: LD_EXP 32
16729: PPUSH
16730: CALL_OW 85
// Say ( Bystrov , DEnd-Burlak-Bys-1 ) ;
16734: LD_EXP 32
16738: PPUSH
16739: LD_STRING DEnd-Burlak-Bys-1
16741: PPUSH
16742: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
16746: LD_EXP 33
16750: PPUSH
16751: CALL_OW 302
16755: IFFALSE 16778
// begin CenterOnUnits ( Lipshchin ) ;
16757: LD_EXP 33
16761: PPUSH
16762: CALL_OW 85
// Say ( Lipshchin , DEnd-Burlak-Lip-1 ) ;
16766: LD_EXP 33
16770: PPUSH
16771: LD_STRING DEnd-Burlak-Lip-1
16773: PPUSH
16774: CALL_OW 88
// end ; if IsOK ( Fadeev ) then
16778: LD_EXP 34
16782: PPUSH
16783: CALL_OW 302
16787: IFFALSE 16810
// begin CenterOnUnits ( Fadeev ) ;
16789: LD_EXP 34
16793: PPUSH
16794: CALL_OW 85
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16798: LD_EXP 34
16802: PPUSH
16803: LD_STRING DEnd-Burlak-Fad-1
16805: PPUSH
16806: CALL_OW 88
// end ; if IsOK ( MacMillan ) then
16810: LD_EXP 13
16814: PPUSH
16815: CALL_OW 302
16819: IFFALSE 16842
// begin CenterOnUnits ( MacMillan ) ;
16821: LD_EXP 13
16825: PPUSH
16826: CALL_OW 85
// Say ( MacMillan , DEnd-Burlak-JMM-1 ) ;
16830: LD_EXP 13
16834: PPUSH
16835: LD_STRING DEnd-Burlak-JMM-1
16837: PPUSH
16838: CALL_OW 88
// end ; if IsOK ( Lisa ) then
16842: LD_EXP 46
16846: PPUSH
16847: CALL_OW 302
16851: IFFALSE 16874
// begin CenterOnUnits ( Lisa ) ;
16853: LD_EXP 46
16857: PPUSH
16858: CALL_OW 85
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16862: LD_EXP 46
16866: PPUSH
16867: LD_STRING DEnd-Burlak-Lisa-1
16869: PPUSH
16870: CALL_OW 88
// end ; if IsOK ( Joan ) then
16874: LD_EXP 45
16878: PPUSH
16879: CALL_OW 302
16883: IFFALSE 16906
// begin CenterOnUnits ( Joan ) ;
16885: LD_EXP 45
16889: PPUSH
16890: CALL_OW 85
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
16894: LD_EXP 45
16898: PPUSH
16899: LD_STRING DEnd-Burlak-Joan-1
16901: PPUSH
16902: CALL_OW 88
// end ; if IsOK ( Frank ) then
16906: LD_EXP 42
16910: PPUSH
16911: CALL_OW 302
16915: IFFALSE 16938
// begin CenterOnUnits ( Frank ) ;
16917: LD_EXP 42
16921: PPUSH
16922: CALL_OW 85
// Say ( Frank , DEnd-Burlak-Frank-1 ) ;
16926: LD_EXP 42
16930: PPUSH
16931: LD_STRING DEnd-Burlak-Frank-1
16933: PPUSH
16934: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
16938: LD_EXP 39
16942: PPUSH
16943: CALL_OW 302
16947: IFFALSE 16970
// begin CenterOnUnits ( Cyrus ) ;
16949: LD_EXP 39
16953: PPUSH
16954: CALL_OW 85
// Say ( Cyrus , DEnd-Burlak-Cyrus-1 ) ;
16958: LD_EXP 39
16962: PPUSH
16963: LD_STRING DEnd-Burlak-Cyrus-1
16965: PPUSH
16966: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
16970: LD_EXP 41
16974: PPUSH
16975: CALL_OW 302
16979: IFFALSE 17002
// begin CenterOnUnits ( Donaldson ) ;
16981: LD_EXP 41
16985: PPUSH
16986: CALL_OW 85
// Say ( Donaldson , DEnd-Burlak-Don-1 ) ;
16990: LD_EXP 41
16994: PPUSH
16995: LD_STRING DEnd-Burlak-Don-1
16997: PPUSH
16998: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17002: LD_EXP 35
17006: PPUSH
17007: CALL_OW 302
17011: IFFALSE 17034
// begin CenterOnUnits ( Bobby ) ;
17013: LD_EXP 35
17017: PPUSH
17018: CALL_OW 85
// Say ( Bobby , DEnd-Burlak-Bobby-1 ) ;
17022: LD_EXP 35
17026: PPUSH
17027: LD_STRING DEnd-Burlak-Bobby-1
17029: PPUSH
17030: CALL_OW 88
// end ; if IsOK ( Denis ) then
17034: LD_EXP 40
17038: PPUSH
17039: CALL_OW 302
17043: IFFALSE 17066
// begin CenterOnUnits ( Denis ) ;
17045: LD_EXP 40
17049: PPUSH
17050: CALL_OW 85
// Say ( Denis , DEnd-Burlak-Den-1 ) ;
17054: LD_EXP 40
17058: PPUSH
17059: LD_STRING DEnd-Burlak-Den-1
17061: PPUSH
17062: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17066: LD_EXP 44
17070: PPUSH
17071: CALL_OW 302
17075: IFFALSE 17098
// begin CenterOnUnits ( Gladstone ) ;
17077: LD_EXP 44
17081: PPUSH
17082: CALL_OW 85
// Say ( Gladstone , DEnd-Burlak-Glad-1 ) ;
17086: LD_EXP 44
17090: PPUSH
17091: LD_STRING DEnd-Burlak-Glad-1
17093: PPUSH
17094: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17098: LD_EXP 50
17102: PPUSH
17103: CALL_OW 302
17107: IFFALSE 17130
// begin CenterOnUnits ( Yamoko ) ;
17109: LD_EXP 50
17113: PPUSH
17114: CALL_OW 85
// Say ( Yamoko , DEnd-Burlak-Yam-1 ) ;
17118: LD_EXP 50
17122: PPUSH
17123: LD_STRING DEnd-Burlak-Yam-1
17125: PPUSH
17126: CALL_OW 88
// end ; if IsOK ( Brown ) then
17130: LD_EXP 36
17134: PPUSH
17135: CALL_OW 302
17139: IFFALSE 17162
// begin CenterOnUnits ( Brown ) ;
17141: LD_EXP 36
17145: PPUSH
17146: CALL_OW 85
// Say ( Brown , DEnd-Burlak-Brown-1 ) ;
17150: LD_EXP 36
17154: PPUSH
17155: LD_STRING DEnd-Burlak-Brown-1
17157: PPUSH
17158: CALL_OW 88
// end ; if IsOK ( Roth ) then
17162: LD_EXP 14
17166: PPUSH
17167: CALL_OW 302
17171: IFFALSE 17194
// begin CenterOnUnits ( Roth ) ;
17173: LD_EXP 14
17177: PPUSH
17178: CALL_OW 85
// Say ( Roth , DEnd-Burlak-Roth-1 ) ;
17182: LD_EXP 14
17186: PPUSH
17187: LD_STRING DEnd-Burlak-Roth-1
17189: PPUSH
17190: CALL_OW 88
// end ; end ;
17194: LD_VAR 0 1
17198: RET
// function us_talking ; begin
17199: LD_INT 0
17201: PPUSH
// if IsOK ( MacMillan ) then
17202: LD_EXP 13
17206: PPUSH
17207: CALL_OW 302
17211: IFFALSE 17234
// begin CenterOnUnits ( MacMillan ) ;
17213: LD_EXP 13
17217: PPUSH
17218: CALL_OW 85
// Say ( MacMillan , DEnd-JMM-JMM-1 ) ;
17222: LD_EXP 13
17226: PPUSH
17227: LD_STRING DEnd-JMM-JMM-1
17229: PPUSH
17230: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17234: LD_EXP 46
17238: PPUSH
17239: CALL_OW 302
17243: IFFALSE 17266
// begin CenterOnUnits ( Lisa ) ;
17245: LD_EXP 46
17249: PPUSH
17250: CALL_OW 85
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17254: LD_EXP 46
17258: PPUSH
17259: LD_STRING DEnd-JMM-Lisa-1
17261: PPUSH
17262: CALL_OW 88
// end ; if IsOK ( Joan ) then
17266: LD_EXP 45
17270: PPUSH
17271: CALL_OW 302
17275: IFFALSE 17298
// begin CenterOnUnits ( Joan ) ;
17277: LD_EXP 45
17281: PPUSH
17282: CALL_OW 85
// Say ( Joan , DEnd-JMM-Joan-1 ) ;
17286: LD_EXP 45
17290: PPUSH
17291: LD_STRING DEnd-JMM-Joan-1
17293: PPUSH
17294: CALL_OW 88
// end ; if IsOK ( Frank ) then
17298: LD_EXP 42
17302: PPUSH
17303: CALL_OW 302
17307: IFFALSE 17330
// begin CenterOnUnits ( Frank ) ;
17309: LD_EXP 42
17313: PPUSH
17314: CALL_OW 85
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17318: LD_EXP 42
17322: PPUSH
17323: LD_STRING DEnd-JMM-Frank-1
17325: PPUSH
17326: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17330: LD_EXP 39
17334: PPUSH
17335: CALL_OW 302
17339: IFFALSE 17362
// begin CenterOnUnits ( Cyrus ) ;
17341: LD_EXP 39
17345: PPUSH
17346: CALL_OW 85
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING DEnd-JMM-Cyrus-1
17357: PPUSH
17358: CALL_OW 88
// end ; if IsOK ( Cornell ) then
17362: LD_EXP 37
17366: PPUSH
17367: CALL_OW 302
17371: IFFALSE 17394
// begin CenterOnUnits ( Cornell ) ;
17373: LD_EXP 37
17377: PPUSH
17378: CALL_OW 85
// Say ( Cornell , DEnd-JMM-Corn-1 ) ;
17382: LD_EXP 37
17386: PPUSH
17387: LD_STRING DEnd-JMM-Corn-1
17389: PPUSH
17390: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17394: LD_EXP 41
17398: PPUSH
17399: CALL_OW 302
17403: IFFALSE 17426
// begin CenterOnUnits ( Donaldson ) ;
17405: LD_EXP 41
17409: PPUSH
17410: CALL_OW 85
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17414: LD_EXP 41
17418: PPUSH
17419: LD_STRING DEnd-JMM-Don-1
17421: PPUSH
17422: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17426: LD_EXP 35
17430: PPUSH
17431: CALL_OW 302
17435: IFFALSE 17458
// begin CenterOnUnits ( Bobby ) ;
17437: LD_EXP 35
17441: PPUSH
17442: CALL_OW 85
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17446: LD_EXP 35
17450: PPUSH
17451: LD_STRING DEnd-JMM-Bobby-1
17453: PPUSH
17454: CALL_OW 88
// end ; if IsOK ( Denis ) then
17458: LD_EXP 40
17462: PPUSH
17463: CALL_OW 302
17467: IFFALSE 17490
// begin CenterOnUnits ( Denis ) ;
17469: LD_EXP 40
17473: PPUSH
17474: CALL_OW 85
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17478: LD_EXP 40
17482: PPUSH
17483: LD_STRING DEnd-JMM-Den-1
17485: PPUSH
17486: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17490: LD_EXP 44
17494: PPUSH
17495: CALL_OW 302
17499: IFFALSE 17522
// begin CenterOnUnits ( Gladstone ) ;
17501: LD_EXP 44
17505: PPUSH
17506: CALL_OW 85
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17510: LD_EXP 44
17514: PPUSH
17515: LD_STRING DEnd-JMM-Glad-1
17517: PPUSH
17518: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17522: LD_EXP 50
17526: PPUSH
17527: CALL_OW 302
17531: IFFALSE 17554
// begin CenterOnUnits ( Yamoko ) ;
17533: LD_EXP 50
17537: PPUSH
17538: CALL_OW 85
// Say ( Yamoko , DEnd-JMM-Yam-1 ) ;
17542: LD_EXP 50
17546: PPUSH
17547: LD_STRING DEnd-JMM-Yam-1
17549: PPUSH
17550: CALL_OW 88
// end ; if IsOK ( Brown ) then
17554: LD_EXP 36
17558: PPUSH
17559: CALL_OW 302
17563: IFFALSE 17586
// begin CenterOnUnits ( Brown ) ;
17565: LD_EXP 36
17569: PPUSH
17570: CALL_OW 85
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17574: LD_EXP 36
17578: PPUSH
17579: LD_STRING DEnd-JMM-Brown-1
17581: PPUSH
17582: CALL_OW 88
// end ; if IsOK ( Roth ) then
17586: LD_EXP 14
17590: PPUSH
17591: CALL_OW 302
17595: IFFALSE 17618
// begin CenterOnUnits ( Roth ) ;
17597: LD_EXP 14
17601: PPUSH
17602: CALL_OW 85
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
17606: LD_EXP 14
17610: PPUSH
17611: LD_STRING DEnd-JMM-Roth-1
17613: PPUSH
17614: CALL_OW 88
// end ; if IsOK ( Connie ) then
17618: LD_EXP 38
17622: PPUSH
17623: CALL_OW 302
17627: IFFALSE 17650
// begin CenterOnUnits ( Connie ) ;
17629: LD_EXP 38
17633: PPUSH
17634: CALL_OW 85
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17638: LD_EXP 38
17642: PPUSH
17643: LD_STRING DEnd-JMM-Con-1
17645: PPUSH
17646: CALL_OW 88
// end ; if IsOK ( Gary ) then
17650: LD_EXP 43
17654: PPUSH
17655: CALL_OW 302
17659: IFFALSE 17682
// begin CenterOnUnits ( Gary ) ;
17661: LD_EXP 43
17665: PPUSH
17666: CALL_OW 85
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17670: LD_EXP 43
17674: PPUSH
17675: LD_STRING DEnd-JMM-Gary-1
17677: PPUSH
17678: CALL_OW 88
// end ; if IsOK ( Simms ) then
17682: LD_EXP 48
17686: PPUSH
17687: CALL_OW 302
17691: IFFALSE 17714
// begin CenterOnUnits ( Simms ) ;
17693: LD_EXP 48
17697: PPUSH
17698: CALL_OW 85
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17702: LD_EXP 48
17706: PPUSH
17707: LD_STRING DEnd-JMM-Sim-1
17709: PPUSH
17710: CALL_OW 88
// end ; if IsOK ( VanHouten ) then
17714: LD_EXP 49
17718: PPUSH
17719: CALL_OW 302
17723: IFFALSE 17746
// begin CenterOnUnits ( VanHouten ) ;
17725: LD_EXP 49
17729: PPUSH
17730: CALL_OW 85
// Say ( VanHouten , DEnd-JMM-VanH-1 ) ;
17734: LD_EXP 49
17738: PPUSH
17739: LD_STRING DEnd-JMM-VanH-1
17741: PPUSH
17742: CALL_OW 88
// end ; if IsOK ( Burlak ) then
17746: LD_EXP 12
17750: PPUSH
17751: CALL_OW 302
17755: IFFALSE 17778
// begin CenterOnUnits ( Burlak ) ;
17757: LD_EXP 12
17761: PPUSH
17762: CALL_OW 85
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17766: LD_EXP 12
17770: PPUSH
17771: LD_STRING DEnd-JMM-Bur-1
17773: PPUSH
17774: CALL_OW 88
// end ; if IsOK ( Belkov ) then
17778: LD_EXP 17
17782: PPUSH
17783: CALL_OW 302
17787: IFFALSE 17810
// begin CenterOnUnits ( Belkov ) ;
17789: LD_EXP 17
17793: PPUSH
17794: CALL_OW 85
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17798: LD_EXP 17
17802: PPUSH
17803: LD_STRING DEnd-JMM-Bel-1
17805: PPUSH
17806: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
17810: LD_EXP 19
17814: PPUSH
17815: CALL_OW 302
17819: IFFALSE 17842
// begin CenterOnUnits ( Gnyevko ) ;
17821: LD_EXP 19
17825: PPUSH
17826: CALL_OW 85
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17830: LD_EXP 19
17834: PPUSH
17835: LD_STRING DEnd-JMM-Gny-1
17837: PPUSH
17838: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
17842: LD_EXP 21
17846: PPUSH
17847: CALL_OW 302
17851: IFFALSE 17874
// begin CenterOnUnits ( Dolgov ) ;
17853: LD_EXP 21
17857: PPUSH
17858: CALL_OW 85
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17862: LD_EXP 21
17866: PPUSH
17867: LD_STRING DEnd-JMM-Dol-1
17869: PPUSH
17870: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
17874: LD_EXP 23
17878: PPUSH
17879: CALL_OW 302
17883: IFFALSE 17906
// begin CenterOnUnits ( Kapitsova ) ;
17885: LD_EXP 23
17889: PPUSH
17890: CALL_OW 85
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17894: LD_EXP 23
17898: PPUSH
17899: LD_STRING DEnd-JMM-Kap-1
17901: PPUSH
17902: CALL_OW 88
// end ; if IsOK ( Gleb ) then
17906: LD_EXP 22
17910: PPUSH
17911: CALL_OW 302
17915: IFFALSE 17938
// begin CenterOnUnits ( Gleb ) ;
17917: LD_EXP 22
17921: PPUSH
17922: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
17926: LD_EXP 22
17930: PPUSH
17931: LD_STRING DEnd-JMM-Glb-1
17933: PPUSH
17934: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
17938: LD_EXP 25
17942: PPUSH
17943: CALL_OW 302
17947: IFFALSE 17970
// begin CenterOnUnits ( Kovalyuk ) ;
17949: LD_EXP 25
17953: PPUSH
17954: CALL_OW 85
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17958: LD_EXP 25
17962: PPUSH
17963: LD_STRING DEnd-JMM-Kov-1
17965: PPUSH
17966: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
17970: LD_EXP 26
17974: PPUSH
17975: CALL_OW 302
17979: IFFALSE 18002
// begin CenterOnUnits ( Scholtze ) ;
17981: LD_EXP 26
17985: PPUSH
17986: CALL_OW 85
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17990: LD_EXP 26
17994: PPUSH
17995: LD_STRING DEnd-JMM-Sch-1
17997: PPUSH
17998: CALL_OW 88
// end ; if IsOK ( Titov ) then
18002: LD_EXP 28
18006: PPUSH
18007: CALL_OW 302
18011: IFFALSE 18034
// begin CenterOnUnits ( Titov ) ;
18013: LD_EXP 28
18017: PPUSH
18018: CALL_OW 85
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18022: LD_EXP 28
18026: PPUSH
18027: LD_STRING DEnd-JMM-Tit-1
18029: PPUSH
18030: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
18034: LD_EXP 29
18038: PPUSH
18039: CALL_OW 302
18043: IFFALSE 18066
// begin CenterOnUnits ( Oblukov ) ;
18045: LD_EXP 29
18049: PPUSH
18050: CALL_OW 85
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18054: LD_EXP 29
18058: PPUSH
18059: LD_STRING DEnd-JMM-Obl-1
18061: PPUSH
18062: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
18066: LD_EXP 32
18070: PPUSH
18071: CALL_OW 302
18075: IFFALSE 18098
// begin CenterOnUnits ( Bystrov ) ;
18077: LD_EXP 32
18081: PPUSH
18082: CALL_OW 85
// Say ( Bystrov , DEnd-JMM-Bys-1 ) ;
18086: LD_EXP 32
18090: PPUSH
18091: LD_STRING DEnd-JMM-Bys-1
18093: PPUSH
18094: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
18098: LD_EXP 33
18102: PPUSH
18103: CALL_OW 302
18107: IFFALSE 18130
// begin CenterOnUnits ( Lipshchin ) ;
18109: LD_EXP 33
18113: PPUSH
18114: CALL_OW 85
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18118: LD_EXP 33
18122: PPUSH
18123: LD_STRING DEnd-JMM-Lip-1
18125: PPUSH
18126: CALL_OW 88
// end ; end ; end_of_file
18130: LD_VAR 0 1
18134: RET
// var id_reg , id_def ; var BaseArea , DefendArea , Heal ; var docs ; var healing_un , wounded_un ; var central_base , mc_id_defend ; export function init_defend ; var side ; begin
18135: LD_INT 0
18137: PPUSH
18138: PPUSH
// BaseArea := [ us_base , ar_base , ru_base ] ;
18139: LD_ADDR_LOC 14
18143: PUSH
18144: LD_INT 11
18146: PUSH
18147: LD_INT 13
18149: PUSH
18150: LD_INT 12
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: LIST
18157: ST_TO_ADDR
// DefendArea := [ us_defend_base , ar_defend_base , ru_base ] ;
18158: LD_ADDR_LOC 15
18162: PUSH
18163: LD_INT 36
18165: PUSH
18166: LD_INT 37
18168: PUSH
18169: LD_INT 12
18171: PUSH
18172: EMPTY
18173: LIST
18174: LIST
18175: LIST
18176: ST_TO_ADDR
// Heal := [ us_heal , ar_heal , ru_heal ] ;
18177: LD_ADDR_LOC 16
18181: PUSH
18182: LD_INT 16
18184: PUSH
18185: LD_INT 14
18187: PUSH
18188: LD_INT 15
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: LIST
18195: ST_TO_ADDR
// docs := [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
18196: LD_ADDR_LOC 17
18200: PUSH
18201: EMPTY
18202: PUSH
18203: EMPTY
18204: PUSH
18205: EMPTY
18206: PUSH
18207: EMPTY
18208: PUSH
18209: EMPTY
18210: PUSH
18211: EMPTY
18212: PUSH
18213: EMPTY
18214: PUSH
18215: EMPTY
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: ST_TO_ADDR
// central_base := [ [ 44 , 62 ] , [ 251 , 193 ] , [ 177 , 72 ] ] ;
18227: LD_ADDR_LOC 20
18231: PUSH
18232: LD_INT 44
18234: PUSH
18235: LD_INT 62
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: PUSH
18242: LD_INT 251
18244: PUSH
18245: LD_INT 193
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: PUSH
18252: LD_INT 177
18254: PUSH
18255: LD_INT 72
18257: PUSH
18258: EMPTY
18259: LIST
18260: LIST
18261: PUSH
18262: EMPTY
18263: LIST
18264: LIST
18265: LIST
18266: ST_TO_ADDR
// healing_un := [ ] ;
18267: LD_ADDR_LOC 18
18271: PUSH
18272: EMPTY
18273: ST_TO_ADDR
// wounded_un := [ ] ;
18274: LD_ADDR_LOC 19
18278: PUSH
18279: EMPTY
18280: ST_TO_ADDR
// mc_id_defend := false ;
18281: LD_ADDR_LOC 21
18285: PUSH
18286: LD_INT 0
18288: ST_TO_ADDR
// start_defend ;
18289: CALL 18549 0 0
// end ;
18293: LD_VAR 0 1
18297: RET
// function prepare_defend ( side ) ; var seznam , def_buildings , def_vehicles , def_peoples ; begin
18298: LD_INT 0
18300: PPUSH
18301: PPUSH
18302: PPUSH
18303: PPUSH
18304: PPUSH
// def_buildings := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
18305: LD_ADDR_VAR 0 4
18309: PUSH
18310: LD_INT 22
18312: PUSH
18313: LD_VAR 0 1
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: PUSH
18322: LD_INT 2
18324: PUSH
18325: LD_INT 30
18327: PUSH
18328: LD_INT 32
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: PUSH
18335: LD_INT 30
18337: PUSH
18338: LD_INT 31
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: LIST
18349: PUSH
18350: EMPTY
18351: LIST
18352: LIST
18353: PPUSH
18354: CALL_OW 69
18358: ST_TO_ADDR
// def_peoples := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_class , class_scientistic ] ] ) ;
18359: LD_ADDR_VAR 0 6
18363: PUSH
18364: LD_INT 22
18366: PUSH
18367: LD_VAR 0 1
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: PUSH
18376: LD_INT 21
18378: PUSH
18379: LD_INT 1
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: PUSH
18386: LD_INT 3
18388: PUSH
18389: LD_INT 25
18391: PUSH
18392: LD_INT 4
18394: PUSH
18395: EMPTY
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: PPUSH
18405: CALL_OW 69
18409: ST_TO_ADDR
// def_vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , f_not , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) ;
18410: LD_ADDR_VAR 0 5
18414: PUSH
18415: LD_INT 22
18417: PUSH
18418: LD_VAR 0 1
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 21
18429: PUSH
18430: LD_INT 2
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 3
18439: PUSH
18440: LD_INT 2
18442: PUSH
18443: LD_INT 34
18445: PUSH
18446: LD_INT 12
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 34
18455: PUSH
18456: LD_INT 13
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: LD_INT 34
18465: PUSH
18466: LD_INT 32
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: PUSH
18473: LD_INT 34
18475: PUSH
18476: LD_INT 51
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: PUSH
18483: LD_INT 34
18485: PUSH
18486: LD_INT 52
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: PPUSH
18507: CALL_OW 69
18511: ST_TO_ADDR
// seznam := def_buildings ^ def_peoples ^ def_vehicles ;
18512: LD_ADDR_VAR 0 3
18516: PUSH
18517: LD_VAR 0 4
18521: PUSH
18522: LD_VAR 0 6
18526: ADD
18527: PUSH
18528: LD_VAR 0 5
18532: ADD
18533: ST_TO_ADDR
// result := seznam ;
18534: LD_ADDR_VAR 0 2
18538: PUSH
18539: LD_VAR 0 3
18543: ST_TO_ADDR
// end ;
18544: LD_VAR 0 2
18548: RET
// function start_defend ; var side ; begin
18549: LD_INT 0
18551: PPUSH
18552: PPUSH
// id_reg := [ ] ;
18553: LD_ADDR_LOC 12
18557: PUSH
18558: EMPTY
18559: ST_TO_ADDR
// id_def := [ ] ;
18560: LD_ADDR_LOC 13
18564: PUSH
18565: EMPTY
18566: ST_TO_ADDR
// for side = 1 to 8 do
18567: LD_ADDR_VAR 0 2
18571: PUSH
18572: DOUBLE
18573: LD_INT 1
18575: DEC
18576: ST_TO_ADDR
18577: LD_INT 8
18579: PUSH
18580: FOR_TO
18581: IFFALSE 18837
// if side in cpu_list then
18583: LD_VAR 0 2
18587: PUSH
18588: LD_EXP 8
18592: IN
18593: IFFALSE 18801
// begin id_reg := id_reg ^ McRegistry ( 1 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , BaseArea [ side ] ] , [ mc_reg_area_to_protect , BaseArea [ side ] ] , [ mc_reg_units_to_protect , prepare_defend ( side ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
18595: LD_ADDR_LOC 12
18599: PUSH
18600: LD_LOC 12
18604: PUSH
18605: LD_INT 1
18607: PPUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 35
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PUSH
18618: LD_INT 5
18620: PUSH
18621: LD_INT 140
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_LOC 14
18635: PUSH
18636: LD_VAR 0 2
18640: ARRAY
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 3
18648: PUSH
18649: LD_LOC 14
18653: PUSH
18654: LD_VAR 0 2
18658: ARRAY
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PUSH
18664: LD_INT 4
18666: PUSH
18667: LD_VAR 0 2
18671: PPUSH
18672: CALL 18298 0 1
18676: PUSH
18677: EMPTY
18678: LIST
18679: LIST
18680: PUSH
18681: LD_INT 8
18683: PUSH
18684: LD_INT 7
18686: NEG
18687: PUSH
18688: EMPTY
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: PPUSH
18697: CALL_OW 399
18701: ADD
18702: ST_TO_ADDR
// id_def := id_def ^ McDefend ( 200 , id_reg , prepare_defend ( side ) , [ [ mc_def_advantage , 5000 ] , [ mc_area_dont_leave , BaseArea [ side ] ] , [ mc_retreat_area_people , Heal [ side ] ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
18703: LD_ADDR_LOC 13
18707: PUSH
18708: LD_LOC 13
18712: PUSH
18713: LD_INT 200
18715: PPUSH
18716: LD_LOC 12
18720: PPUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: CALL 18298 0 1
18730: PPUSH
18731: LD_INT 1
18733: PUSH
18734: LD_INT 5000
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PUSH
18741: LD_INT 2
18743: PUSH
18744: LD_LOC 14
18748: PUSH
18749: LD_VAR 0 2
18753: ARRAY
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 7
18761: PUSH
18762: LD_LOC 16
18766: PUSH
18767: LD_VAR 0 2
18771: ARRAY
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 5
18779: PUSH
18780: LD_INT 600
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: PPUSH
18793: CALL_OW 401
18797: ADD
18798: ST_TO_ADDR
// end else
18799: GO 18835
// begin id_reg := id_reg ^ [ 0 ] ;
18801: LD_ADDR_LOC 12
18805: PUSH
18806: LD_LOC 12
18810: PUSH
18811: LD_INT 0
18813: PUSH
18814: EMPTY
18815: LIST
18816: ADD
18817: ST_TO_ADDR
// id_def := id_reg ^ [ 0 ] ;
18818: LD_ADDR_LOC 13
18822: PUSH
18823: LD_LOC 12
18827: PUSH
18828: LD_INT 0
18830: PUSH
18831: EMPTY
18832: LIST
18833: ADD
18834: ST_TO_ADDR
// end ;
18835: GO 18580
18837: POP
18838: POP
// end ;
18839: LD_VAR 0 1
18843: RET
// on McRegistryResultChanges ( mcid , n , s ) do var side ;
18844: LD_INT 0
18846: PPUSH
// begin for side = 1 to id_reg do
18847: LD_ADDR_VAR 0 4
18851: PUSH
18852: DOUBLE
18853: LD_INT 1
18855: DEC
18856: ST_TO_ADDR
18857: LD_LOC 12
18861: PUSH
18862: FOR_TO
18863: IFFALSE 18915
// if id_reg [ side ] = mcid then
18865: LD_LOC 12
18869: PUSH
18870: LD_VAR 0 4
18874: ARRAY
18875: PUSH
18876: LD_VAR 0 1
18880: EQUAL
18881: IFFALSE 18913
// begin AddMcUnits ( mcid , prepare_defend ( side ) ) ;
18883: LD_VAR 0 1
18887: PPUSH
18888: LD_VAR 0 4
18892: PPUSH
18893: CALL 18298 0 1
18897: PPUSH
18898: CALL_OW 390
// SendForces ( side ) ;
18902: LD_VAR 0 4
18906: PPUSH
18907: CALL 20060 0 1
// break ;
18911: GO 18915
// end ;
18913: GO 18862
18915: POP
18916: POP
// end ;
18917: PPOPN 4
18919: END
// every 0 0$7.7 do var side , list ;
18920: GO 18922
18922: DISABLE
18923: LD_INT 0
18925: PPUSH
18926: PPUSH
// begin list := [ ] ;
18927: LD_ADDR_VAR 0 2
18931: PUSH
18932: EMPTY
18933: ST_TO_ADDR
// for side = 1 to 8 do
18934: LD_ADDR_VAR 0 1
18938: PUSH
18939: DOUBLE
18940: LD_INT 1
18942: DEC
18943: ST_TO_ADDR
18944: LD_INT 8
18946: PUSH
18947: FOR_TO
18948: IFFALSE 19093
// if ( not side in cpu_list ) and id_reg [ side ] then
18950: LD_VAR 0 1
18954: PUSH
18955: LD_EXP 8
18959: IN
18960: NOT
18961: PUSH
18962: LD_LOC 12
18966: PUSH
18967: LD_VAR 0 1
18971: ARRAY
18972: AND
18973: IFFALSE 19091
// begin KillMc ( id_reg [ side ] ) ;
18975: LD_LOC 12
18979: PUSH
18980: LD_VAR 0 1
18984: ARRAY
18985: PPUSH
18986: CALL_OW 387
// id_reg := Delete ( id_reg , side ) ;
18990: LD_ADDR_LOC 12
18994: PUSH
18995: LD_LOC 12
18999: PPUSH
19000: LD_VAR 0 1
19004: PPUSH
19005: CALL_OW 3
19009: ST_TO_ADDR
// id_reg := Insert ( id_reg , side , 0 ) ;
19010: LD_ADDR_LOC 12
19014: PUSH
19015: LD_LOC 12
19019: PPUSH
19020: LD_VAR 0 1
19024: PPUSH
19025: LD_INT 0
19027: PPUSH
19028: CALL_OW 2
19032: ST_TO_ADDR
// KillMc ( id_def [ side ] ) ;
19033: LD_LOC 13
19037: PUSH
19038: LD_VAR 0 1
19042: ARRAY
19043: PPUSH
19044: CALL_OW 387
// id_def := Delete ( id_def , side ) ;
19048: LD_ADDR_LOC 13
19052: PUSH
19053: LD_LOC 13
19057: PPUSH
19058: LD_VAR 0 1
19062: PPUSH
19063: CALL_OW 3
19067: ST_TO_ADDR
// id_def := Insert ( id_def , side , 0 ) ;
19068: LD_ADDR_LOC 13
19072: PUSH
19073: LD_LOC 13
19077: PPUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: LD_INT 0
19085: PPUSH
19086: CALL_OW 2
19090: ST_TO_ADDR
// end ;
19091: GO 18947
19093: POP
19094: POP
// enable ;
19095: ENABLE
// end ;
19096: PPOPN 2
19098: END
// every 0 0$5.3 do var side , sci , list , wounded , un ;
19099: GO 19101
19101: DISABLE
19102: LD_INT 0
19104: PPUSH
19105: PPUSH
19106: PPUSH
19107: PPUSH
19108: PPUSH
// begin for side = 1 to 8 do
19109: LD_ADDR_VAR 0 1
19113: PUSH
19114: DOUBLE
19115: LD_INT 1
19117: DEC
19118: ST_TO_ADDR
19119: LD_INT 8
19121: PUSH
19122: FOR_TO
19123: IFFALSE 19557
// if side in cpu_list then
19125: LD_VAR 0 1
19129: PUSH
19130: LD_EXP 8
19134: IN
19135: IFFALSE 19555
// begin wounded := FilterUnitsInArea ( Heal [ side ] , [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 1000 ] ] ) ;
19137: LD_ADDR_VAR 0 4
19141: PUSH
19142: LD_LOC 16
19146: PUSH
19147: LD_VAR 0 1
19151: ARRAY
19152: PPUSH
19153: LD_INT 22
19155: PUSH
19156: LD_VAR 0 1
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PUSH
19165: LD_INT 21
19167: PUSH
19168: LD_INT 1
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 3
19177: PUSH
19178: LD_INT 24
19180: PUSH
19181: LD_INT 1000
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: PUSH
19188: EMPTY
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: PPUSH
19194: CALL_OW 70
19198: ST_TO_ADDR
// if wounded then
19199: LD_VAR 0 4
19203: IFFALSE 19413
// begin if not docs [ side ] then
19205: LD_LOC 17
19209: PUSH
19210: LD_VAR 0 1
19214: ARRAY
19215: NOT
19216: IFFALSE 19380
// begin sci := request_people ( side , class_scientistic , 5 ) ;
19218: LD_ADDR_VAR 0 2
19222: PUSH
19223: LD_VAR 0 1
19227: PPUSH
19228: LD_INT 4
19230: PPUSH
19231: LD_INT 5
19233: PPUSH
19234: CALL 26382 0 3
19238: ST_TO_ADDR
// docs := Delete ( docs , side ) ;
19239: LD_ADDR_LOC 17
19243: PUSH
19244: LD_LOC 17
19248: PPUSH
19249: LD_VAR 0 1
19253: PPUSH
19254: CALL_OW 3
19258: ST_TO_ADDR
// docs := Insert ( docs , side , sci ) ;
19259: LD_ADDR_LOC 17
19263: PUSH
19264: LD_LOC 17
19268: PPUSH
19269: LD_VAR 0 1
19273: PPUSH
19274: LD_VAR 0 2
19278: PPUSH
19279: CALL_OW 2
19283: ST_TO_ADDR
// list := reserved_people [ side ] ^ sci ;
19284: LD_ADDR_VAR 0 3
19288: PUSH
19289: LD_EXP 71
19293: PUSH
19294: LD_VAR 0 1
19298: ARRAY
19299: PUSH
19300: LD_VAR 0 2
19304: ADD
19305: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19306: LD_ADDR_EXP 71
19310: PUSH
19311: LD_EXP 71
19315: PPUSH
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 3
19325: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19326: LD_ADDR_EXP 71
19330: PUSH
19331: LD_EXP 71
19335: PPUSH
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 3
19345: PPUSH
19346: CALL_OW 2
19350: ST_TO_ADDR
// ComRemember ( sci ) ;
19351: LD_VAR 0 2
19355: PPUSH
19356: CALL_OW 143
// ComMoveToArea ( sci , Heal [ side ] ) ;
19360: LD_VAR 0 2
19364: PPUSH
19365: LD_LOC 16
19369: PUSH
19370: LD_VAR 0 1
19374: ARRAY
19375: PPUSH
19376: CALL_OW 113
// end ; for un in wounded do
19380: LD_ADDR_VAR 0 5
19384: PUSH
19385: LD_VAR 0 4
19389: PUSH
19390: FOR_IN
19391: IFFALSE 19409
// AddComHeal ( sci , un ) ;
19393: LD_VAR 0 2
19397: PPUSH
19398: LD_VAR 0 5
19402: PPUSH
19403: CALL_OW 188
19407: GO 19390
19409: POP
19410: POP
// end else
19411: GO 19555
// if docs [ side ] then
19413: LD_LOC 17
19417: PUSH
19418: LD_VAR 0 1
19422: ARRAY
19423: IFFALSE 19555
// begin list := reserved_people [ side ] diff docs [ side ] ;
19425: LD_ADDR_VAR 0 3
19429: PUSH
19430: LD_EXP 71
19434: PUSH
19435: LD_VAR 0 1
19439: ARRAY
19440: PUSH
19441: LD_LOC 17
19445: PUSH
19446: LD_VAR 0 1
19450: ARRAY
19451: DIFF
19452: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19453: LD_ADDR_EXP 71
19457: PUSH
19458: LD_EXP 71
19462: PPUSH
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL_OW 3
19472: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19473: LD_ADDR_EXP 71
19477: PUSH
19478: LD_EXP 71
19482: PPUSH
19483: LD_VAR 0 1
19487: PPUSH
19488: LD_VAR 0 3
19492: PPUSH
19493: CALL_OW 2
19497: ST_TO_ADDR
// ComReturn ( docs [ side ] ) ;
19498: LD_LOC 17
19502: PUSH
19503: LD_VAR 0 1
19507: ARRAY
19508: PPUSH
19509: CALL_OW 144
// docs := Delete ( docs , side ) ;
19513: LD_ADDR_LOC 17
19517: PUSH
19518: LD_LOC 17
19522: PPUSH
19523: LD_VAR 0 1
19527: PPUSH
19528: CALL_OW 3
19532: ST_TO_ADDR
// docs := Insert ( docs , side , [ ] ) ;
19533: LD_ADDR_LOC 17
19537: PUSH
19538: LD_LOC 17
19542: PPUSH
19543: LD_VAR 0 1
19547: PPUSH
19548: EMPTY
19549: PPUSH
19550: CALL_OW 2
19554: ST_TO_ADDR
// end ; end ;
19555: GO 19122
19557: POP
19558: POP
// enable ;
19559: ENABLE
// end ;
19560: PPOPN 5
19562: END
// every 0 0$3.1 do var list , self ;
19563: GO 19565
19565: DISABLE
19566: LD_INT 0
19568: PPUSH
19569: PPUSH
// begin list := FilterUnitsInArea ( ar_base , [ [ f_side , you ] , [ f_ok ] ] ) ;
19570: LD_ADDR_VAR 0 1
19574: PUSH
19575: LD_INT 13
19577: PPUSH
19578: LD_INT 22
19580: PUSH
19581: LD_EXP 1
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: PUSH
19590: LD_INT 50
19592: PUSH
19593: EMPTY
19594: LIST
19595: PUSH
19596: EMPTY
19597: LIST
19598: LIST
19599: PPUSH
19600: CALL_OW 70
19604: ST_TO_ADDR
// if list then
19605: LD_VAR 0 1
19609: IFFALSE 19706
// begin self := FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_vehicle ] , [ f_weapon , ar_selfpropelled_bomb ] ] ) ;
19611: LD_ADDR_VAR 0 2
19615: PUSH
19616: LD_INT 22
19618: PUSH
19619: LD_EXP 4
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 21
19630: PUSH
19631: LD_INT 2
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 34
19640: PUSH
19641: LD_INT 29
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PPUSH
19653: CALL_OW 69
19657: ST_TO_ADDR
// if self then
19658: LD_VAR 0 2
19662: IFFALSE 19680
// self := self [ 1 ] else
19664: LD_ADDR_VAR 0 2
19668: PUSH
19669: LD_VAR 0 2
19673: PUSH
19674: LD_INT 1
19676: ARRAY
19677: ST_TO_ADDR
19678: GO 19682
// exit ;
19680: GO 19707
// ComAttackUnit ( self , NearestUnitToUnit ( list , self ) ) ;
19682: LD_VAR 0 2
19686: PPUSH
19687: LD_VAR 0 1
19691: PPUSH
19692: LD_VAR 0 2
19696: PPUSH
19697: CALL_OW 74
19701: PPUSH
19702: CALL_OW 115
// ; end ; enable ;
19706: ENABLE
// end ;
19707: PPOPN 2
19709: END
// every 0 0$3 do var side , list ;
19710: GO 19712
19712: DISABLE
19713: LD_INT 0
19715: PPUSH
19716: PPUSH
// begin for side in cpu_list do
19717: LD_ADDR_VAR 0 1
19721: PUSH
19722: LD_EXP 8
19726: PUSH
19727: FOR_IN
19728: IFFALSE 19817
// if side then
19730: LD_VAR 0 1
19734: IFFALSE 19815
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 800 ] ] ) diff healing_un ;
19736: LD_ADDR_VAR 0 2
19740: PUSH
19741: LD_INT 22
19743: PUSH
19744: LD_VAR 0 1
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 21
19755: PUSH
19756: LD_INT 1
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: LD_INT 24
19768: PUSH
19769: LD_INT 800
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: PPUSH
19782: CALL_OW 69
19786: PUSH
19787: LD_LOC 18
19791: DIFF
19792: ST_TO_ADDR
// if list then
19793: LD_VAR 0 2
19797: IFFALSE 19815
// wounded_un := wounded_un ^ list ;
19799: LD_ADDR_LOC 19
19803: PUSH
19804: LD_LOC 19
19808: PUSH
19809: LD_VAR 0 2
19813: ADD
19814: ST_TO_ADDR
// end ;
19815: GO 19727
19817: POP
19818: POP
// enable ;
19819: ENABLE
// end ;
19820: PPOPN 2
19822: END
// every 0 0$2 do var list , un ;
19823: GO 19825
19825: DISABLE
19826: LD_INT 0
19828: PPUSH
19829: PPUSH
// begin for un in wounded_un do
19830: LD_ADDR_VAR 0 2
19834: PUSH
19835: LD_LOC 19
19839: PUSH
19840: FOR_IN
19841: IFFALSE 19927
// if not ( un in healing_un ) then
19843: LD_VAR 0 2
19847: PUSH
19848: LD_LOC 18
19852: IN
19853: NOT
19854: IFFALSE 19925
// begin healing_un := healing_un ^ un ;
19856: LD_ADDR_LOC 18
19860: PUSH
19861: LD_LOC 18
19865: PUSH
19866: LD_VAR 0 2
19870: ADD
19871: ST_TO_ADDR
// McCustom ( 100 , un ) ;
19872: LD_INT 100
19874: PPUSH
19875: LD_VAR 0 2
19879: PPUSH
19880: CALL_OW 416
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
19884: LD_VAR 0 2
19888: PPUSH
19889: LD_LOC 16
19893: PUSH
19894: LD_VAR 0 2
19898: PPUSH
19899: CALL_OW 255
19903: ARRAY
19904: PPUSH
19905: CALL_OW 113
// wounded_un := wounded_un diff un ;
19909: LD_ADDR_LOC 19
19913: PUSH
19914: LD_LOC 19
19918: PUSH
19919: LD_VAR 0 2
19923: DIFF
19924: ST_TO_ADDR
// end ;
19925: GO 19840
19927: POP
19928: POP
// enable ;
19929: ENABLE
// end ;
19930: PPOPN 2
19932: END
// every 0 0$2 + 0 0$1 do var un ;
19933: GO 19935
19935: DISABLE
19936: LD_INT 0
19938: PPUSH
// begin for un in healing_un do
19939: LD_ADDR_VAR 0 1
19943: PUSH
19944: LD_LOC 18
19948: PUSH
19949: FOR_IN
19950: IFFALSE 20054
// if GetLives ( un ) = 1000 then
19952: LD_VAR 0 1
19956: PPUSH
19957: CALL_OW 256
19961: PUSH
19962: LD_INT 1000
19964: EQUAL
19965: IFFALSE 19999
// begin KillMc ( GetUnitMc ( un ) ) ;
19967: LD_VAR 0 1
19971: PPUSH
19972: CALL_OW 388
19976: PPUSH
19977: CALL_OW 387
// healing_un := healing_un diff un ;
19981: LD_ADDR_LOC 18
19985: PUSH
19986: LD_LOC 18
19990: PUSH
19991: LD_VAR 0 1
19995: DIFF
19996: ST_TO_ADDR
// end else
19997: GO 20052
// if not IsInArea ( un , Heal [ GetSide ( un ) ] ) then
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_LOC 16
20008: PUSH
20009: LD_VAR 0 1
20013: PPUSH
20014: CALL_OW 255
20018: ARRAY
20019: PPUSH
20020: CALL_OW 308
20024: NOT
20025: IFFALSE 20052
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20027: LD_VAR 0 1
20031: PPUSH
20032: LD_LOC 16
20036: PUSH
20037: LD_VAR 0 1
20041: PPUSH
20042: CALL_OW 255
20046: ARRAY
20047: PPUSH
20048: CALL_OW 113
20052: GO 19949
20054: POP
20055: POP
// enable ;
20056: ENABLE
// end ;
20057: PPOPN 1
20059: END
// function SendForces ( side ) ; var un , list , target , defenders ; begin
20060: LD_INT 0
20062: PPUSH
20063: PPUSH
20064: PPUSH
20065: PPUSH
20066: PPUSH
// ComRemember ( defend_forces [ side ] ) ;
20067: LD_EXP 68
20071: PUSH
20072: LD_VAR 0 1
20076: ARRAY
20077: PPUSH
20078: CALL_OW 143
// if ExistMc ( mc_id_defend ) then
20082: LD_LOC 21
20086: PPUSH
20087: CALL_OW 386
20091: IFFALSE 20102
// KillMc ( mc_id_defend ) ;
20093: LD_LOC 21
20097: PPUSH
20098: CALL_OW 387
// mc_id_defend := McCustom ( 500 , defend_forces [ side ] ) ;
20102: LD_ADDR_LOC 21
20106: PUSH
20107: LD_INT 500
20109: PPUSH
20110: LD_EXP 68
20114: PUSH
20115: LD_VAR 0 1
20119: ARRAY
20120: PPUSH
20121: CALL_OW 416
20125: ST_TO_ADDR
// wait ( 1 ) ;
20126: LD_INT 1
20128: PPUSH
20129: CALL_OW 67
// repeat list := FilterUnitsInArea ( DefendArea [ side ] , [ [ f_side , you ] , [ f_ok ] ] ) ;
20133: LD_ADDR_VAR 0 4
20137: PUSH
20138: LD_LOC 15
20142: PUSH
20143: LD_VAR 0 1
20147: ARRAY
20148: PPUSH
20149: LD_INT 22
20151: PUSH
20152: LD_EXP 1
20156: PUSH
20157: EMPTY
20158: LIST
20159: LIST
20160: PUSH
20161: LD_INT 50
20163: PUSH
20164: EMPTY
20165: LIST
20166: PUSH
20167: EMPTY
20168: LIST
20169: LIST
20170: PPUSH
20171: CALL_OW 70
20175: ST_TO_ADDR
// target := NearestUnitToXY ( list , central_base [ side ] [ 1 ] , central_base [ side ] [ 2 ] ) ;
20176: LD_ADDR_VAR 0 5
20180: PUSH
20181: LD_VAR 0 4
20185: PPUSH
20186: LD_LOC 20
20190: PUSH
20191: LD_VAR 0 1
20195: ARRAY
20196: PUSH
20197: LD_INT 1
20199: ARRAY
20200: PPUSH
20201: LD_LOC 20
20205: PUSH
20206: LD_VAR 0 1
20210: ARRAY
20211: PUSH
20212: LD_INT 2
20214: ARRAY
20215: PPUSH
20216: CALL_OW 73
20220: ST_TO_ADDR
// defenders := prepare_defend ( side ) ;
20221: LD_ADDR_VAR 0 6
20225: PUSH
20226: LD_VAR 0 1
20230: PPUSH
20231: CALL 18298 0 1
20235: ST_TO_ADDR
// if list = 0 or defenders = 0 then
20236: LD_VAR 0 4
20240: PUSH
20241: LD_INT 0
20243: EQUAL
20244: PUSH
20245: LD_VAR 0 6
20249: PUSH
20250: LD_INT 0
20252: EQUAL
20253: OR
20254: IFFALSE 20258
// break ;
20256: GO 20373
// for un in defenders do
20258: LD_ADDR_VAR 0 3
20262: PUSH
20263: LD_VAR 0 6
20267: PUSH
20268: FOR_IN
20269: IFFALSE 20360
// if GetWeapon ( un ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ru_rocket ] then
20271: LD_VAR 0 3
20275: PPUSH
20276: CALL_OW 264
20280: PUSH
20281: LD_INT 7
20283: PUSH
20284: LD_INT 28
20286: PUSH
20287: LD_INT 45
20289: PUSH
20290: LD_INT 47
20292: PUSH
20293: EMPTY
20294: LIST
20295: LIST
20296: LIST
20297: LIST
20298: IN
20299: IFFALSE 20338
// ComAttackPlace ( defend_forces [ side ] , GetX ( target ) , GetY ( target ) ) else
20301: LD_EXP 68
20305: PUSH
20306: LD_VAR 0 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 5
20316: PPUSH
20317: CALL_OW 250
20321: PPUSH
20322: LD_VAR 0 5
20326: PPUSH
20327: CALL_OW 251
20331: PPUSH
20332: CALL_OW 116
20336: GO 20358
// ComAttackUnit ( defend_forces [ side ] , target ) ;
20338: LD_EXP 68
20342: PUSH
20343: LD_VAR 0 1
20347: ARRAY
20348: PPUSH
20349: LD_VAR 0 5
20353: PPUSH
20354: CALL_OW 115
20358: GO 20268
20360: POP
20361: POP
// wait ( 50 ) ;
20362: LD_INT 50
20364: PPUSH
20365: CALL_OW 67
// until false ;
20369: LD_INT 0
20371: IFFALSE 20133
// KillMc ( mc_id_defend ) ;
20373: LD_LOC 21
20377: PPUSH
20378: CALL_OW 387
// mc_id_defend := false ;
20382: LD_ADDR_LOC 21
20386: PUSH
20387: LD_INT 0
20389: ST_TO_ADDR
// wait ( 2 ) ;
20390: LD_INT 2
20392: PPUSH
20393: CALL_OW 67
// ComReturn ( defend_forces [ side ] ) ;
20397: LD_EXP 68
20401: PUSH
20402: LD_VAR 0 1
20406: ARRAY
20407: PPUSH
20408: CALL_OW 144
// end ;
20412: LD_VAR 0 2
20416: RET
// every 0 0$5.1 do var side ;
20417: GO 20419
20419: DISABLE
20420: LD_INT 0
20422: PPUSH
// begin for side = 1 to 3 do
20423: LD_ADDR_VAR 0 1
20427: PUSH
20428: DOUBLE
20429: LD_INT 1
20431: DEC
20432: ST_TO_ADDR
20433: LD_INT 3
20435: PUSH
20436: FOR_TO
20437: IFFALSE 20639
// if ( not defend_forces [ side ] ) and ready_forces [ side ] then
20439: LD_EXP 68
20443: PUSH
20444: LD_VAR 0 1
20448: ARRAY
20449: NOT
20450: PUSH
20451: LD_EXP 65
20455: PUSH
20456: LD_VAR 0 1
20460: ARRAY
20461: AND
20462: IFFALSE 20637
// begin defend_forces := Replace ( defend_forces , side , ready_forces [ side ] ) ;
20464: LD_ADDR_EXP 68
20468: PUSH
20469: LD_EXP 68
20473: PPUSH
20474: LD_VAR 0 1
20478: PPUSH
20479: LD_EXP 65
20483: PUSH
20484: LD_VAR 0 1
20488: ARRAY
20489: PPUSH
20490: CALL_OW 1
20494: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
20495: LD_ADDR_EXP 65
20499: PUSH
20500: LD_EXP 65
20504: PPUSH
20505: LD_VAR 0 1
20509: PPUSH
20510: EMPTY
20511: PPUSH
20512: CALL_OW 1
20516: ST_TO_ADDR
// jammed_forces := Replace ( jammed_forces , side , jammed_forces [ side ] diff defend_forces [ side ] ) ;
20517: LD_ADDR_EXP 69
20521: PUSH
20522: LD_EXP 69
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_EXP 69
20536: PUSH
20537: LD_VAR 0 1
20541: ARRAY
20542: PUSH
20543: LD_EXP 68
20547: PUSH
20548: LD_VAR 0 1
20552: ARRAY
20553: DIFF
20554: PPUSH
20555: CALL_OW 1
20559: ST_TO_ADDR
// case side of 1 :
20560: LD_VAR 0 1
20564: PUSH
20565: LD_INT 1
20567: DOUBLE
20568: EQUAL
20569: IFTRUE 20573
20571: GO 20597
20573: POP
// ComMoveXY ( defend_forces [ side ] , 40 , 46 ) ; 3 :
20574: LD_EXP 68
20578: PUSH
20579: LD_VAR 0 1
20583: ARRAY
20584: PPUSH
20585: LD_INT 40
20587: PPUSH
20588: LD_INT 46
20590: PPUSH
20591: CALL_OW 111
20595: GO 20630
20597: LD_INT 3
20599: DOUBLE
20600: EQUAL
20601: IFTRUE 20605
20603: GO 20629
20605: POP
// ComMoveXY ( defend_forces [ side ] , 175 , 50 ) ; end ;
20606: LD_EXP 68
20610: PUSH
20611: LD_VAR 0 1
20615: ARRAY
20616: PPUSH
20617: LD_INT 175
20619: PPUSH
20620: LD_INT 50
20622: PPUSH
20623: CALL_OW 111
20627: GO 20630
20629: POP
// wait ( 2 ) ;
20630: LD_INT 2
20632: PPUSH
20633: CALL_OW 67
// end ;
20637: GO 20436
20639: POP
20640: POP
// enable ;
20641: ENABLE
// end ;
20642: PPOPN 1
20644: END
// export function Update_defend ( un ) ; var side ; begin
20645: LD_INT 0
20647: PPUSH
20648: PPUSH
// if GetSide ( un ) = you then
20649: LD_VAR 0 1
20653: PPUSH
20654: CALL_OW 255
20658: PUSH
20659: LD_EXP 1
20663: EQUAL
20664: IFFALSE 20668
// exit ;
20666: GO 20743
// for side = 1 to 3 do
20668: LD_ADDR_VAR 0 3
20672: PUSH
20673: DOUBLE
20674: LD_INT 1
20676: DEC
20677: ST_TO_ADDR
20678: LD_INT 3
20680: PUSH
20681: FOR_TO
20682: IFFALSE 20741
// if un in defend_forces [ side ] then
20684: LD_VAR 0 1
20688: PUSH
20689: LD_EXP 68
20693: PUSH
20694: LD_VAR 0 3
20698: ARRAY
20699: IN
20700: IFFALSE 20739
// defend_forces := Replace ( defend_forces , side , defend_forces [ side ] diff un ) ;
20702: LD_ADDR_EXP 68
20706: PUSH
20707: LD_EXP 68
20711: PPUSH
20712: LD_VAR 0 3
20716: PPUSH
20717: LD_EXP 68
20721: PUSH
20722: LD_VAR 0 3
20726: ARRAY
20727: PUSH
20728: LD_VAR 0 1
20732: DIFF
20733: PPUSH
20734: CALL_OW 1
20738: ST_TO_ADDR
20739: GO 20681
20741: POP
20742: POP
// end ; end_of_file
20743: LD_VAR 0 2
20747: RET
// export ready_forces , attack_forces , retreat_forces , defend_forces , jammed_forces ; var us_ru , us_ar , ru_us , ru_ar ; var last_ar_attack , attack_timing , attack_limit ; var al_eliminate ; var pocet_odebrani ; export function init_attack ; var side ; begin
20748: LD_INT 0
20750: PPUSH
20751: PPUSH
// ready_forces = [ ] ;
20752: LD_ADDR_EXP 65
20756: PUSH
20757: EMPTY
20758: ST_TO_ADDR
// attack_forces = [ ] ;
20759: LD_ADDR_EXP 66
20763: PUSH
20764: EMPTY
20765: ST_TO_ADDR
// retreat_forces = [ ] ;
20766: LD_ADDR_EXP 67
20770: PUSH
20771: EMPTY
20772: ST_TO_ADDR
// defend_forces = [ ] ;
20773: LD_ADDR_EXP 68
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// for side = 1 to 8 do
20780: LD_ADDR_VAR 0 2
20784: PUSH
20785: DOUBLE
20786: LD_INT 1
20788: DEC
20789: ST_TO_ADDR
20790: LD_INT 8
20792: PUSH
20793: FOR_TO
20794: IFFALSE 20878
// begin ready_forces = ready_forces ^ [ [ ] ] ;
20796: LD_ADDR_EXP 65
20800: PUSH
20801: LD_EXP 65
20805: PUSH
20806: EMPTY
20807: PUSH
20808: EMPTY
20809: LIST
20810: ADD
20811: ST_TO_ADDR
// attack_forces = attack_forces ^ [ [ ] ] ;
20812: LD_ADDR_EXP 66
20816: PUSH
20817: LD_EXP 66
20821: PUSH
20822: EMPTY
20823: PUSH
20824: EMPTY
20825: LIST
20826: ADD
20827: ST_TO_ADDR
// retreat_forces = retreat_forces ^ [ [ ] ] ;
20828: LD_ADDR_EXP 67
20832: PUSH
20833: LD_EXP 67
20837: PUSH
20838: EMPTY
20839: PUSH
20840: EMPTY
20841: LIST
20842: ADD
20843: ST_TO_ADDR
// defend_forces = defend_forces ^ [ [ ] ] ;
20844: LD_ADDR_EXP 68
20848: PUSH
20849: LD_EXP 68
20853: PUSH
20854: EMPTY
20855: PUSH
20856: EMPTY
20857: LIST
20858: ADD
20859: ST_TO_ADDR
// jammed_forces = jammed_forces ^ [ [ ] ] ;
20860: LD_ADDR_EXP 69
20864: PUSH
20865: LD_EXP 69
20869: PUSH
20870: EMPTY
20871: PUSH
20872: EMPTY
20873: LIST
20874: ADD
20875: ST_TO_ADDR
// end ;
20876: GO 20793
20878: POP
20879: POP
// us_ru := [ [ 76 , 61 ] , [ 121 , 55 ] , [ 171 , 59 ] , [ 190 , 90 ] ] ;
20880: LD_ADDR_LOC 22
20884: PUSH
20885: LD_INT 76
20887: PUSH
20888: LD_INT 61
20890: PUSH
20891: EMPTY
20892: LIST
20893: LIST
20894: PUSH
20895: LD_INT 121
20897: PUSH
20898: LD_INT 55
20900: PUSH
20901: EMPTY
20902: LIST
20903: LIST
20904: PUSH
20905: LD_INT 171
20907: PUSH
20908: LD_INT 59
20910: PUSH
20911: EMPTY
20912: LIST
20913: LIST
20914: PUSH
20915: LD_INT 190
20917: PUSH
20918: LD_INT 90
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: LIST
20929: LIST
20930: ST_TO_ADDR
// us_ar := [ [ [ 78 , 69 ] , [ 121 , 116 ] , [ 155 , 137 ] , [ 190 , 170 ] , [ 242 , 187 ] ] , [ [ 72 , 106 ] , [ 111 , 176 ] , [ 163 , 184 ] , [ 215 , 191 ] , [ 242 , 187 ] ] ] ;
20931: LD_ADDR_LOC 23
20935: PUSH
20936: LD_INT 78
20938: PUSH
20939: LD_INT 69
20941: PUSH
20942: EMPTY
20943: LIST
20944: LIST
20945: PUSH
20946: LD_INT 121
20948: PUSH
20949: LD_INT 116
20951: PUSH
20952: EMPTY
20953: LIST
20954: LIST
20955: PUSH
20956: LD_INT 155
20958: PUSH
20959: LD_INT 137
20961: PUSH
20962: EMPTY
20963: LIST
20964: LIST
20965: PUSH
20966: LD_INT 190
20968: PUSH
20969: LD_INT 170
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 242
20978: PUSH
20979: LD_INT 187
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: PUSH
20993: LD_INT 72
20995: PUSH
20996: LD_INT 106
20998: PUSH
20999: EMPTY
21000: LIST
21001: LIST
21002: PUSH
21003: LD_INT 111
21005: PUSH
21006: LD_INT 176
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: PUSH
21013: LD_INT 163
21015: PUSH
21016: LD_INT 184
21018: PUSH
21019: EMPTY
21020: LIST
21021: LIST
21022: PUSH
21023: LD_INT 215
21025: PUSH
21026: LD_INT 191
21028: PUSH
21029: EMPTY
21030: LIST
21031: LIST
21032: PUSH
21033: LD_INT 242
21035: PUSH
21036: LD_INT 187
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: LIST
21048: LIST
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: ST_TO_ADDR
// ru_us := [ [ 118 , 63 ] , [ 78 , 57 ] , [ 30 , 44 ] , [ 56 , 83 ] ] ;
21054: LD_ADDR_LOC 24
21058: PUSH
21059: LD_INT 118
21061: PUSH
21062: LD_INT 63
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: LD_INT 78
21071: PUSH
21072: LD_INT 57
21074: PUSH
21075: EMPTY
21076: LIST
21077: LIST
21078: PUSH
21079: LD_INT 30
21081: PUSH
21082: LD_INT 44
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: PUSH
21089: LD_INT 56
21091: PUSH
21092: LD_INT 83
21094: PUSH
21095: EMPTY
21096: LIST
21097: LIST
21098: PUSH
21099: EMPTY
21100: LIST
21101: LIST
21102: LIST
21103: LIST
21104: ST_TO_ADDR
// ru_ar := [ [ [ 142 , 65 ] , [ 160 , 140 ] , [ 255 , 196 ] ] , [ [ 125 , 58 ] , [ 106 , 93 ] , [ 126 , 154 ] , [ 121 , 182 ] , [ 167 , 180 ] , [ 251 , 187 ] ] ] ;
21105: LD_ADDR_LOC 25
21109: PUSH
21110: LD_INT 142
21112: PUSH
21113: LD_INT 65
21115: PUSH
21116: EMPTY
21117: LIST
21118: LIST
21119: PUSH
21120: LD_INT 160
21122: PUSH
21123: LD_INT 140
21125: PUSH
21126: EMPTY
21127: LIST
21128: LIST
21129: PUSH
21130: LD_INT 255
21132: PUSH
21133: LD_INT 196
21135: PUSH
21136: EMPTY
21137: LIST
21138: LIST
21139: PUSH
21140: EMPTY
21141: LIST
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 125
21147: PUSH
21148: LD_INT 58
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: PUSH
21155: LD_INT 106
21157: PUSH
21158: LD_INT 93
21160: PUSH
21161: EMPTY
21162: LIST
21163: LIST
21164: PUSH
21165: LD_INT 126
21167: PUSH
21168: LD_INT 154
21170: PUSH
21171: EMPTY
21172: LIST
21173: LIST
21174: PUSH
21175: LD_INT 121
21177: PUSH
21178: LD_INT 182
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: PUSH
21185: LD_INT 167
21187: PUSH
21188: LD_INT 180
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PUSH
21195: LD_INT 251
21197: PUSH
21198: LD_INT 187
21200: PUSH
21201: EMPTY
21202: LIST
21203: LIST
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: LIST
21209: LIST
21210: LIST
21211: LIST
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: ST_TO_ADDR
// al_eliminate = [ [ 88 , 53 ] , [ 49 , 10 ] , [ 83 , 13 ] ] ;
21217: LD_ADDR_LOC 29
21221: PUSH
21222: LD_INT 88
21224: PUSH
21225: LD_INT 53
21227: PUSH
21228: EMPTY
21229: LIST
21230: LIST
21231: PUSH
21232: LD_INT 49
21234: PUSH
21235: LD_INT 10
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PUSH
21242: LD_INT 83
21244: PUSH
21245: LD_INT 13
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: LIST
21256: ST_TO_ADDR
// attack_timing = [ 50 , 40 , 30 ] [ difficulty ] ;
21257: LD_ADDR_LOC 27
21261: PUSH
21262: LD_INT 50
21264: PUSH
21265: LD_INT 40
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: LIST
21275: PUSH
21276: LD_OWVAR 67
21280: ARRAY
21281: ST_TO_ADDR
// attack_limit = 0 ;
21282: LD_ADDR_LOC 28
21286: PUSH
21287: LD_INT 0
21289: ST_TO_ADDR
// last_ar_attack = TICK ;
21290: LD_ADDR_LOC 26
21294: PUSH
21295: LD_OWVAR 1
21299: ST_TO_ADDR
// pocet_odebrani = 0 ;
21300: LD_ADDR_LOC 30
21304: PUSH
21305: LD_INT 0
21307: ST_TO_ADDR
// end ;
21308: LD_VAR 0 1
21312: RET
// every 0 0$15.4 do var active_side , num_forces ;
21313: GO 21315
21315: DISABLE
21316: LD_INT 0
21318: PPUSH
21319: PPUSH
// begin num_forces := define_forces_strenght ;
21320: LD_ADDR_VAR 0 2
21324: PUSH
21325: CALL 21385 0 0
21329: ST_TO_ADDR
// for active_side in cpu_list do
21330: LD_ADDR_VAR 0 1
21334: PUSH
21335: LD_EXP 8
21339: PUSH
21340: FOR_IN
21341: IFFALSE 21379
// if ready_forces [ active_side ] >= num_forces then
21343: LD_EXP 65
21347: PUSH
21348: LD_VAR 0 1
21352: ARRAY
21353: PUSH
21354: LD_VAR 0 2
21358: GREATEREQUAL
21359: IFFALSE 21377
// begin let_the_war_begin ( active_side ) ;
21361: LD_VAR 0 1
21365: PPUSH
21366: CALL 22848 0 1
// wait ( 1 ) ;
21370: LD_INT 1
21372: PPUSH
21373: CALL_OW 67
// end ;
21377: GO 21340
21379: POP
21380: POP
// enable ;
21381: ENABLE
// end ;
21382: PPOPN 2
21384: END
// function define_forces_strenght ; var num ; begin
21385: LD_INT 0
21387: PPUSH
21388: PPUSH
// num := 3 ;
21389: LD_ADDR_VAR 0 2
21393: PUSH
21394: LD_INT 3
21396: ST_TO_ADDR
// if TICK > 7 7$0 then
21397: LD_OWVAR 1
21401: PUSH
21402: LD_INT 14700
21404: GREATER
21405: IFFALSE 21415
// num := 4 ;
21407: LD_ADDR_VAR 0 2
21411: PUSH
21412: LD_INT 4
21414: ST_TO_ADDR
// if TICK > 14 14$0 then
21415: LD_OWVAR 1
21419: PUSH
21420: LD_INT 29400
21422: GREATER
21423: IFFALSE 21433
// num := 6 ;
21425: LD_ADDR_VAR 0 2
21429: PUSH
21430: LD_INT 6
21432: ST_TO_ADDR
// result := num ;
21433: LD_ADDR_VAR 0 1
21437: PUSH
21438: LD_VAR 0 2
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 1
21447: RET
// function define_target_priority ; var target ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
// target := Rand ( 0 , attack_timing ) ;
21452: LD_ADDR_VAR 0 2
21456: PUSH
21457: LD_INT 0
21459: PPUSH
21460: LD_LOC 27
21464: PPUSH
21465: CALL_OW 12
21469: ST_TO_ADDR
// if target > attack_limit then
21470: LD_VAR 0 2
21474: PUSH
21475: LD_LOC 28
21479: GREATER
21480: IFFALSE 21492
// target := false else
21482: LD_ADDR_VAR 0 2
21486: PUSH
21487: LD_INT 0
21489: ST_TO_ADDR
21490: GO 21500
// target := true ;
21492: LD_ADDR_VAR 0 2
21496: PUSH
21497: LD_INT 1
21499: ST_TO_ADDR
// result := target ;
21500: LD_ADDR_VAR 0 1
21504: PUSH
21505: LD_VAR 0 2
21509: ST_TO_ADDR
// end ;
21510: LD_VAR 0 1
21514: RET
// every 1 1$0 trigger attack_timing > attack_limit do
21515: LD_LOC 27
21519: PUSH
21520: LD_LOC 28
21524: GREATER
21525: IFFALSE 21559
21527: GO 21529
21529: DISABLE
// begin attack_timing := attack_timing - 1 ;
21530: LD_ADDR_LOC 27
21534: PUSH
21535: LD_LOC 27
21539: PUSH
21540: LD_INT 1
21542: MINUS
21543: ST_TO_ADDR
// attack_limit := attack_limit + 1 ;
21544: LD_ADDR_LOC 28
21548: PUSH
21549: LD_LOC 28
21553: PUSH
21554: LD_INT 1
21556: PLUS
21557: ST_TO_ADDR
// enable ;
21558: ENABLE
// end ;
21559: END
// function Select_Weakest_Base ( areas ) ; var selected , un , list ; begin
21560: LD_INT 0
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
// selected := false ;
21566: LD_ADDR_VAR 0 3
21570: PUSH
21571: LD_INT 0
21573: ST_TO_ADDR
// for un in areas do
21574: LD_ADDR_VAR 0 4
21578: PUSH
21579: LD_VAR 0 1
21583: PUSH
21584: FOR_IN
21585: IFFALSE 21712
// begin list := FilterUnitsInArea ( un , [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
21587: LD_ADDR_VAR 0 5
21591: PUSH
21592: LD_VAR 0 4
21596: PPUSH
21597: LD_INT 22
21599: PUSH
21600: LD_EXP 1
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: PUSH
21609: LD_INT 21
21611: PUSH
21612: LD_INT 3
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 2
21621: PUSH
21622: LD_INT 30
21624: PUSH
21625: LD_INT 33
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 30
21634: PUSH
21635: LD_INT 32
21637: PUSH
21638: EMPTY
21639: LIST
21640: LIST
21641: PUSH
21642: EMPTY
21643: LIST
21644: LIST
21645: LIST
21646: PUSH
21647: EMPTY
21648: LIST
21649: LIST
21650: LIST
21651: PPUSH
21652: CALL_OW 70
21656: ST_TO_ADDR
// if ( not selected ) or ( selected [ 1 ] < list ) then
21657: LD_VAR 0 3
21661: NOT
21662: PUSH
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 1
21670: ARRAY
21671: PUSH
21672: LD_VAR 0 5
21676: LESS
21677: OR
21678: IFFALSE 21703
// selected := [ list + 0 , un ] ;
21680: LD_ADDR_VAR 0 3
21684: PUSH
21685: LD_VAR 0 5
21689: PUSH
21690: LD_INT 0
21692: PLUS
21693: PUSH
21694: LD_VAR 0 4
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: ST_TO_ADDR
// wait ( 1 ) ;
21703: LD_INT 1
21705: PPUSH
21706: CALL_OW 67
// end ;
21710: GO 21584
21712: POP
21713: POP
// if selected then
21714: LD_VAR 0 3
21718: IFFALSE 21734
// selected := selected [ 2 ] ;
21720: LD_ADDR_VAR 0 3
21724: PUSH
21725: LD_VAR 0 3
21729: PUSH
21730: LD_INT 2
21732: ARRAY
21733: ST_TO_ADDR
// result := selected ;
21734: LD_ADDR_VAR 0 2
21738: PUSH
21739: LD_VAR 0 3
21743: ST_TO_ADDR
// end ;
21744: LD_VAR 0 2
21748: RET
// function Find_Player_Base ; var list , un , goal , areas , defend_tought ; begin
21749: LD_INT 0
21751: PPUSH
21752: PPUSH
21753: PPUSH
21754: PPUSH
21755: PPUSH
21756: PPUSH
// goal := false ;
21757: LD_ADDR_VAR 0 4
21761: PUSH
21762: LD_INT 0
21764: ST_TO_ADDR
// areas := [ ] ;
21765: LD_ADDR_VAR 0 5
21769: PUSH
21770: EMPTY
21771: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21772: LD_ADDR_VAR 0 2
21776: PUSH
21777: LD_INT 22
21779: PUSH
21780: LD_EXP 1
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: PUSH
21789: LD_INT 21
21791: PUSH
21792: LD_INT 3
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 2
21801: PUSH
21802: LD_INT 30
21804: PUSH
21805: LD_INT 0
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: PUSH
21812: LD_INT 30
21814: PUSH
21815: LD_INT 1
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: PUSH
21822: EMPTY
21823: LIST
21824: LIST
21825: LIST
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: LIST
21831: PPUSH
21832: CALL_OW 69
21836: ST_TO_ADDR
// for un in list do
21837: LD_ADDR_VAR 0 3
21841: PUSH
21842: LD_VAR 0 2
21846: PUSH
21847: FOR_IN
21848: IFFALSE 21947
// begin if IsInArea ( un , ar_base ) then
21850: LD_VAR 0 3
21854: PPUSH
21855: LD_INT 13
21857: PPUSH
21858: CALL_OW 308
21862: IFFALSE 21880
// areas := areas ^ ar_base else
21864: LD_ADDR_VAR 0 5
21868: PUSH
21869: LD_VAR 0 5
21873: PUSH
21874: LD_INT 13
21876: ADD
21877: ST_TO_ADDR
21878: GO 21938
// if IsInArea ( un , us_base ) then
21880: LD_VAR 0 3
21884: PPUSH
21885: LD_INT 11
21887: PPUSH
21888: CALL_OW 308
21892: IFFALSE 21910
// areas := areas ^ us_base else
21894: LD_ADDR_VAR 0 5
21898: PUSH
21899: LD_VAR 0 5
21903: PUSH
21904: LD_INT 11
21906: ADD
21907: ST_TO_ADDR
21908: GO 21938
// if IsInArea ( un , ru_base ) then
21910: LD_VAR 0 3
21914: PPUSH
21915: LD_INT 12
21917: PPUSH
21918: CALL_OW 308
21922: IFFALSE 21938
// areas := areas ^ ru_base ;
21924: LD_ADDR_VAR 0 5
21928: PUSH
21929: LD_VAR 0 5
21933: PUSH
21934: LD_INT 12
21936: ADD
21937: ST_TO_ADDR
// wait ( 1 ) ;
21938: LD_INT 1
21940: PPUSH
21941: CALL_OW 67
// end ;
21945: GO 21847
21947: POP
21948: POP
// if ( not areas ) or ( areas > 1 ) then
21949: LD_VAR 0 5
21953: NOT
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 1
21962: GREATER
21963: OR
21964: IFFALSE 21983
// goal := Select_Weakest_Base ( areas ) else
21966: LD_ADDR_VAR 0 4
21970: PUSH
21971: LD_VAR 0 5
21975: PPUSH
21976: CALL 21560 0 1
21980: ST_TO_ADDR
21981: GO 21997
// goal := areas [ 1 ] ;
21983: LD_ADDR_VAR 0 4
21987: PUSH
21988: LD_VAR 0 5
21992: PUSH
21993: LD_INT 1
21995: ARRAY
21996: ST_TO_ADDR
// result := goal ;
21997: LD_ADDR_VAR 0 1
22001: PUSH
22002: LD_VAR 0 4
22006: ST_TO_ADDR
// end ;
22007: LD_VAR 0 1
22011: RET
// function GetUnitArea ( un ) ; var area ; begin
22012: LD_INT 0
22014: PPUSH
22015: PPUSH
// case un of 1 :
22016: LD_VAR 0 1
22020: PUSH
22021: LD_INT 1
22023: DOUBLE
22024: EQUAL
22025: IFTRUE 22029
22027: GO 22040
22029: POP
// area := us_base ; 2 :
22030: LD_ADDR_VAR 0 3
22034: PUSH
22035: LD_INT 11
22037: ST_TO_ADDR
22038: GO 22079
22040: LD_INT 2
22042: DOUBLE
22043: EQUAL
22044: IFTRUE 22048
22046: GO 22059
22048: POP
// area := ar_base ; 3 :
22049: LD_ADDR_VAR 0 3
22053: PUSH
22054: LD_INT 13
22056: ST_TO_ADDR
22057: GO 22079
22059: LD_INT 3
22061: DOUBLE
22062: EQUAL
22063: IFTRUE 22067
22065: GO 22078
22067: POP
// area := ru_base ; end ;
22068: LD_ADDR_VAR 0 3
22072: PUSH
22073: LD_INT 12
22075: ST_TO_ADDR
22076: GO 22079
22078: POP
// result := area ;
22079: LD_ADDR_VAR 0 2
22083: PUSH
22084: LD_VAR 0 3
22088: ST_TO_ADDR
// end ;
22089: LD_VAR 0 2
22093: RET
// function Find_CPU_Target ( side ) ; var un , goal , bases , list ; begin
22094: LD_INT 0
22096: PPUSH
22097: PPUSH
22098: PPUSH
22099: PPUSH
22100: PPUSH
// bases := [ ] ;
22101: LD_ADDR_VAR 0 5
22105: PUSH
22106: EMPTY
22107: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22108: LD_ADDR_VAR 0 6
22112: PUSH
22113: LD_INT 21
22115: PUSH
22116: LD_INT 3
22118: PUSH
22119: EMPTY
22120: LIST
22121: LIST
22122: PUSH
22123: LD_INT 2
22125: PUSH
22126: LD_INT 30
22128: PUSH
22129: LD_INT 0
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: LD_INT 30
22138: PUSH
22139: LD_INT 1
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PUSH
22146: EMPTY
22147: LIST
22148: LIST
22149: LIST
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PPUSH
22155: CALL_OW 69
22159: ST_TO_ADDR
// for un in list do
22160: LD_ADDR_VAR 0 3
22164: PUSH
22165: LD_VAR 0 6
22169: PUSH
22170: FOR_IN
22171: IFFALSE 22213
// if GetSide ( un ) <> side then
22173: LD_VAR 0 3
22177: PPUSH
22178: CALL_OW 255
22182: PUSH
22183: LD_VAR 0 1
22187: NONEQUAL
22188: IFFALSE 22211
// bases := bases ^ GetSide ( un ) ;
22190: LD_ADDR_VAR 0 5
22194: PUSH
22195: LD_VAR 0 5
22199: PUSH
22200: LD_VAR 0 3
22204: PPUSH
22205: CALL_OW 255
22209: ADD
22210: ST_TO_ADDR
22211: GO 22170
22213: POP
22214: POP
// bases := bases diff you ;
22215: LD_ADDR_VAR 0 5
22219: PUSH
22220: LD_VAR 0 5
22224: PUSH
22225: LD_EXP 1
22229: DIFF
22230: ST_TO_ADDR
// if bases then
22231: LD_VAR 0 5
22235: IFFALSE 22319
// begin if ( bases diff ar ) and Rand ( 0 , 2 ) then
22237: LD_VAR 0 5
22241: PUSH
22242: LD_EXP 4
22246: DIFF
22247: PUSH
22248: LD_INT 0
22250: PPUSH
22251: LD_INT 2
22253: PPUSH
22254: CALL_OW 12
22258: AND
22259: IFFALSE 22288
// goal := GetUnitArea ( ( bases diff ar ) [ 1 ] ) else
22261: LD_ADDR_VAR 0 4
22265: PUSH
22266: LD_VAR 0 5
22270: PUSH
22271: LD_EXP 4
22275: DIFF
22276: PUSH
22277: LD_INT 1
22279: ARRAY
22280: PPUSH
22281: CALL 22012 0 1
22285: ST_TO_ADDR
22286: GO 22317
// goal := GetUnitArea ( bases [ Rand ( 1 , bases ) ] ) ;
22288: LD_ADDR_VAR 0 4
22292: PUSH
22293: LD_VAR 0 5
22297: PUSH
22298: LD_INT 1
22300: PPUSH
22301: LD_VAR 0 5
22305: PPUSH
22306: CALL_OW 12
22310: ARRAY
22311: PPUSH
22312: CALL 22012 0 1
22316: ST_TO_ADDR
// end else
22317: GO 22329
// goal := Find_Player_Base ;
22319: LD_ADDR_VAR 0 4
22323: PUSH
22324: CALL 21749 0 0
22328: ST_TO_ADDR
// result := goal ;
22329: LD_ADDR_VAR 0 2
22333: PUSH
22334: LD_VAR 0 4
22338: ST_TO_ADDR
// end ;
22339: LD_VAR 0 2
22343: RET
// function Wrong_Base ; var un , vysledek ; begin
22344: LD_INT 0
22346: PPUSH
22347: PPUSH
22348: PPUSH
// un := FilterUnitsInArea ( top_area , [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
22349: LD_ADDR_VAR 0 2
22353: PUSH
22354: LD_INT 20
22356: PPUSH
22357: LD_INT 22
22359: PUSH
22360: LD_EXP 1
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: PUSH
22369: LD_INT 21
22371: PUSH
22372: LD_INT 3
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PPUSH
22383: CALL_OW 70
22387: ST_TO_ADDR
// if un then
22388: LD_VAR 0 2
22392: IFFALSE 22404
// vysledek := true else
22394: LD_ADDR_VAR 0 3
22398: PUSH
22399: LD_INT 1
22401: ST_TO_ADDR
22402: GO 22412
// vysledek := false ;
22404: LD_ADDR_VAR 0 3
22408: PUSH
22409: LD_INT 0
22411: ST_TO_ADDR
// result := vysledek ;
22412: LD_ADDR_VAR 0 1
22416: PUSH
22417: LD_VAR 0 3
22421: ST_TO_ADDR
// end ;
22422: LD_VAR 0 1
22426: RET
// function All_Tracked ( list ) ; var un , vysledek ; begin
22427: LD_INT 0
22429: PPUSH
22430: PPUSH
22431: PPUSH
// vysledek := true ;
22432: LD_ADDR_VAR 0 4
22436: PUSH
22437: LD_INT 1
22439: ST_TO_ADDR
// for un in list do
22440: LD_ADDR_VAR 0 3
22444: PUSH
22445: LD_VAR 0 1
22449: PUSH
22450: FOR_IN
22451: IFFALSE 22491
// if GetChassis ( un ) in [ us_light_wheeled , us_medium_wheeled , ru_medium_wheeled ] then
22453: LD_VAR 0 3
22457: PPUSH
22458: CALL_OW 265
22462: PUSH
22463: LD_INT 1
22465: PUSH
22466: LD_INT 2
22468: PUSH
22469: LD_INT 21
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: IN
22477: IFFALSE 22489
// begin vysledek := false ;
22479: LD_ADDR_VAR 0 4
22483: PUSH
22484: LD_INT 0
22486: ST_TO_ADDR
// break ;
22487: GO 22491
// end ;
22489: GO 22450
22491: POP
22492: POP
// result := vysledek ;
22493: LD_ADDR_VAR 0 2
22497: PUSH
22498: LD_VAR 0 4
22502: ST_TO_ADDR
// end ;
22503: LD_VAR 0 2
22507: RET
// function Send_US_Forces ( target , side ) ; begin
22508: LD_INT 0
22510: PPUSH
// if target = ar_base then
22511: LD_VAR 0 1
22515: PUSH
22516: LD_INT 13
22518: EQUAL
22519: IFFALSE 22632
// begin if All_tracked ( attack_forces [ side ] ) then
22521: LD_EXP 66
22525: PUSH
22526: LD_VAR 0 2
22530: ARRAY
22531: PPUSH
22532: CALL 22427 0 1
22536: IFFALSE 22585
// McMove ( 15 , attack_forces [ side ] , us_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22538: LD_INT 15
22540: PPUSH
22541: LD_EXP 66
22545: PUSH
22546: LD_VAR 0 2
22550: ARRAY
22551: PPUSH
22552: LD_LOC 23
22556: PUSH
22557: LD_INT 1
22559: ARRAY
22560: PPUSH
22561: LD_INT 3
22563: PUSH
22564: LD_INT 5
22566: PUSH
22567: LD_INT 6
22569: PUSH
22570: LD_INT 7
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: LIST
22577: LIST
22578: PPUSH
22579: CALL_OW 398
22583: GO 22630
// McMove ( 15 , attack_forces [ side ] , us_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22585: LD_INT 15
22587: PPUSH
22588: LD_EXP 66
22592: PUSH
22593: LD_VAR 0 2
22597: ARRAY
22598: PPUSH
22599: LD_LOC 23
22603: PUSH
22604: LD_INT 2
22606: ARRAY
22607: PPUSH
22608: LD_INT 3
22610: PUSH
22611: LD_INT 5
22613: PUSH
22614: LD_INT 6
22616: PUSH
22617: LD_INT 7
22619: PUSH
22620: EMPTY
22621: LIST
22622: LIST
22623: LIST
22624: LIST
22625: PPUSH
22626: CALL_OW 398
// end else
22630: GO 22673
// McMove ( 15 , attack_forces [ side ] , us_ru , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22632: LD_INT 15
22634: PPUSH
22635: LD_EXP 66
22639: PUSH
22640: LD_VAR 0 2
22644: ARRAY
22645: PPUSH
22646: LD_LOC 22
22650: PPUSH
22651: LD_INT 3
22653: PUSH
22654: LD_INT 5
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: LD_INT 7
22662: PUSH
22663: EMPTY
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: PPUSH
22669: CALL_OW 398
// end ;
22673: LD_VAR 0 3
22677: RET
// function Send_RU_Forces ( target , side ) ; begin
22678: LD_INT 0
22680: PPUSH
// if target = ar_base then
22681: LD_VAR 0 1
22685: PUSH
22686: LD_INT 13
22688: EQUAL
22689: IFFALSE 22802
// begin if All_tracked ( attack_forces [ side ] ) then
22691: LD_EXP 66
22695: PUSH
22696: LD_VAR 0 2
22700: ARRAY
22701: PPUSH
22702: CALL 22427 0 1
22706: IFFALSE 22755
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22708: LD_INT 15
22710: PPUSH
22711: LD_EXP 66
22715: PUSH
22716: LD_VAR 0 2
22720: ARRAY
22721: PPUSH
22722: LD_LOC 25
22726: PUSH
22727: LD_INT 1
22729: ARRAY
22730: PPUSH
22731: LD_INT 3
22733: PUSH
22734: LD_INT 5
22736: PUSH
22737: LD_INT 6
22739: PUSH
22740: LD_INT 7
22742: PUSH
22743: EMPTY
22744: LIST
22745: LIST
22746: LIST
22747: LIST
22748: PPUSH
22749: CALL_OW 398
22753: GO 22800
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22755: LD_INT 15
22757: PPUSH
22758: LD_EXP 66
22762: PUSH
22763: LD_VAR 0 2
22767: ARRAY
22768: PPUSH
22769: LD_LOC 25
22773: PUSH
22774: LD_INT 2
22776: ARRAY
22777: PPUSH
22778: LD_INT 3
22780: PUSH
22781: LD_INT 5
22783: PUSH
22784: LD_INT 6
22786: PUSH
22787: LD_INT 7
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: LIST
22795: PPUSH
22796: CALL_OW 398
// end else
22800: GO 22843
// McMove ( 15 , attack_forces [ side ] , ru_us , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22802: LD_INT 15
22804: PPUSH
22805: LD_EXP 66
22809: PUSH
22810: LD_VAR 0 2
22814: ARRAY
22815: PPUSH
22816: LD_LOC 24
22820: PPUSH
22821: LD_INT 3
22823: PUSH
22824: LD_INT 5
22826: PUSH
22827: LD_INT 6
22829: PUSH
22830: LD_INT 7
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: PPUSH
22839: CALL_OW 398
// end ;
22843: LD_VAR 0 3
22847: RET
// function let_the_war_begin ( side ) ; var target ; begin
22848: LD_INT 0
22850: PPUSH
22851: PPUSH
// target := false ;
22852: LD_ADDR_VAR 0 3
22856: PUSH
22857: LD_INT 0
22859: ST_TO_ADDR
// if define_target_priority then
22860: CALL 21448 0 0
22864: IFFALSE 22876
// target := Find_Player_Base ;
22866: LD_ADDR_VAR 0 3
22870: PUSH
22871: CALL 21749 0 0
22875: ST_TO_ADDR
// if not target then
22876: LD_VAR 0 3
22880: NOT
22881: IFFALSE 22898
// target := Find_CPU_Target ( side ) ;
22883: LD_ADDR_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL 22094 0 1
22897: ST_TO_ADDR
// if not target then
22898: LD_VAR 0 3
22902: NOT
22903: IFFALSE 22907
// exit ;
22905: GO 23130
// attack_forces := Replace ( attack_forces , side , ready_forces [ side ] ) ;
22907: LD_ADDR_EXP 66
22911: PUSH
22912: LD_EXP 66
22916: PPUSH
22917: LD_VAR 0 1
22921: PPUSH
22922: LD_EXP 65
22926: PUSH
22927: LD_VAR 0 1
22931: ARRAY
22932: PPUSH
22933: CALL_OW 1
22937: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
22938: LD_ADDR_EXP 65
22942: PUSH
22943: LD_EXP 65
22947: PPUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: EMPTY
22954: PPUSH
22955: CALL_OW 1
22959: ST_TO_ADDR
// jammed_forces := Insert ( jammed_forces , side , jammed_forces [ side ] ^ attack_forces [ side ] ) ;
22960: LD_ADDR_EXP 69
22964: PUSH
22965: LD_EXP 69
22969: PPUSH
22970: LD_VAR 0 1
22974: PPUSH
22975: LD_EXP 69
22979: PUSH
22980: LD_VAR 0 1
22984: ARRAY
22985: PUSH
22986: LD_EXP 66
22990: PUSH
22991: LD_VAR 0 1
22995: ARRAY
22996: ADD
22997: PPUSH
22998: CALL_OW 2
23002: ST_TO_ADDR
// case side of 1 :
23003: LD_VAR 0 1
23007: PUSH
23008: LD_INT 1
23010: DOUBLE
23011: EQUAL
23012: IFTRUE 23016
23014: GO 23022
23016: POP
// enable ( 222 ) ; 3 :
23017: LD_INT 222
23019: ENABLE_MARKED
23020: GO 23037
23022: LD_INT 3
23024: DOUBLE
23025: EQUAL
23026: IFTRUE 23030
23028: GO 23036
23030: POP
// enable ( 223 ) ; end ;
23031: LD_INT 223
23033: ENABLE_MARKED
23034: GO 23037
23036: POP
// if Wrong_Base then
23037: CALL 22344 0 0
23041: IFFALSE 23074
// McMove ( 15 , attack_forces [ side ] , al_eliminate , [ mc_move_dontcapture ] ) else
23043: LD_INT 15
23045: PPUSH
23046: LD_EXP 66
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_LOC 29
23061: PPUSH
23062: LD_INT 5
23064: PUSH
23065: EMPTY
23066: LIST
23067: PPUSH
23068: CALL_OW 398
23072: GO 23130
// case side of 1 :
23074: LD_VAR 0 1
23078: PUSH
23079: LD_INT 1
23081: DOUBLE
23082: EQUAL
23083: IFTRUE 23087
23085: GO 23104
23087: POP
// Send_US_Forces ( target , side ) ; 3 :
23088: LD_VAR 0 3
23092: PPUSH
23093: LD_VAR 0 1
23097: PPUSH
23098: CALL 22508 0 2
23102: GO 23130
23104: LD_INT 3
23106: DOUBLE
23107: EQUAL
23108: IFTRUE 23112
23110: GO 23129
23112: POP
// Send_RU_Forces ( target , side ) ; end ;
23113: LD_VAR 0 3
23117: PPUSH
23118: LD_VAR 0 1
23122: PPUSH
23123: CALL 22678 0 2
23127: GO 23130
23129: POP
// end ;
23130: LD_VAR 0 2
23134: RET
// every 88 marked 222 do var list , late , un , i ;
23135: GO 23137
23137: DISABLE
23138: LD_INT 0
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
// begin wait ( 1 1$20 ) ;
23144: LD_INT 2800
23146: PPUSH
23147: CALL_OW 67
// list := FilterUnitsInArea ( us_tinny , [ [ f_side , us ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23151: LD_ADDR_VAR 0 1
23155: PUSH
23156: LD_INT 41
23158: PPUSH
23159: LD_INT 22
23161: PUSH
23162: LD_EXP 3
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: PUSH
23171: LD_INT 21
23173: PUSH
23174: LD_INT 2
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: PUSH
23181: LD_INT 50
23183: PUSH
23184: EMPTY
23185: LIST
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: LIST
23191: PPUSH
23192: CALL_OW 70
23196: ST_TO_ADDR
// late := jammed_forces [ us ] isect list ;
23197: LD_ADDR_VAR 0 2
23201: PUSH
23202: LD_EXP 69
23206: PUSH
23207: LD_EXP 3
23211: ARRAY
23212: PUSH
23213: LD_VAR 0 1
23217: ISECT
23218: ST_TO_ADDR
// if not late then
23219: LD_VAR 0 2
23223: NOT
23224: IFFALSE 23250
// begin jammed_forces := Replace ( jammed_forces , us , [ ] ) ;
23226: LD_ADDR_EXP 69
23230: PUSH
23231: LD_EXP 69
23235: PPUSH
23236: LD_EXP 3
23240: PPUSH
23241: EMPTY
23242: PPUSH
23243: CALL_OW 1
23247: ST_TO_ADDR
// exit ;
23248: GO 23528
// end ; if FilterUnitsInArea ( us_base , [ [ f_side , you ] ] ) then
23250: LD_INT 11
23252: PPUSH
23253: LD_INT 22
23255: PUSH
23256: LD_EXP 1
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: EMPTY
23266: LIST
23267: PPUSH
23268: CALL_OW 70
23272: IFFALSE 23277
// begin enable ;
23274: ENABLE
// exit ;
23275: GO 23528
// end ; for un in late do
23277: LD_ADDR_VAR 0 3
23281: PUSH
23282: LD_VAR 0 2
23286: PUSH
23287: FOR_IN
23288: IFFALSE 23317
// if GetUnitMc ( un ) then
23290: LD_VAR 0 3
23294: PPUSH
23295: CALL_OW 388
23299: IFFALSE 23315
// KillMc ( GetUnitMc ( un ) ) ;
23301: LD_VAR 0 3
23305: PPUSH
23306: CALL_OW 388
23310: PPUSH
23311: CALL_OW 387
23315: GO 23287
23317: POP
23318: POP
// while GetTag ( 83 ) do
23319: LD_INT 83
23321: PPUSH
23322: CALL_OW 110
23326: IFFALSE 23337
// wait ( 0 0$1 ) ;
23328: LD_INT 35
23330: PPUSH
23331: CALL_OW 67
23335: GO 23319
// i := 1 ;
23337: LD_ADDR_VAR 0 4
23341: PUSH
23342: LD_INT 1
23344: ST_TO_ADDR
// for un in jammed_forces [ us ] do
23345: LD_ADDR_VAR 0 3
23349: PUSH
23350: LD_EXP 69
23354: PUSH
23355: LD_EXP 3
23359: ARRAY
23360: PUSH
23361: FOR_IN
23362: IFFALSE 23467
// begin if ( i mod 2 ) and not See ( you , un ) then
23364: LD_VAR 0 4
23368: PUSH
23369: LD_INT 2
23371: MOD
23372: PUSH
23373: LD_EXP 1
23377: PPUSH
23378: LD_VAR 0 3
23382: PPUSH
23383: CALL_OW 292
23387: NOT
23388: AND
23389: IFFALSE 23451
// begin jammed_forces := Replace ( jammed_forces , us , jammed_forces [ us ] diff un ) ;
23391: LD_ADDR_EXP 69
23395: PUSH
23396: LD_EXP 69
23400: PPUSH
23401: LD_EXP 3
23405: PPUSH
23406: LD_EXP 69
23410: PUSH
23411: LD_EXP 3
23415: ARRAY
23416: PUSH
23417: LD_VAR 0 3
23421: DIFF
23422: PPUSH
23423: CALL_OW 1
23427: ST_TO_ADDR
// KillUnit ( un ) ;
23428: LD_VAR 0 3
23432: PPUSH
23433: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23437: LD_ADDR_LOC 30
23441: PUSH
23442: LD_LOC 30
23446: PUSH
23447: LD_INT 1
23449: PLUS
23450: ST_TO_ADDR
// end ; i := i + 1 ;
23451: LD_ADDR_VAR 0 4
23455: PUSH
23456: LD_VAR 0 4
23460: PUSH
23461: LD_INT 1
23463: PLUS
23464: ST_TO_ADDR
// end ;
23465: GO 23361
23467: POP
23468: POP
// wait ( 0 0$10 ) ;
23469: LD_INT 350
23471: PPUSH
23472: CALL_OW 67
// ready_forces := Replace ( ready_forces , us , ready_forces [ us ] union jammed_forces [ us ] ) ;
23476: LD_ADDR_EXP 65
23480: PUSH
23481: LD_EXP 65
23485: PPUSH
23486: LD_EXP 3
23490: PPUSH
23491: LD_EXP 65
23495: PUSH
23496: LD_EXP 3
23500: ARRAY
23501: PUSH
23502: LD_EXP 69
23506: PUSH
23507: LD_EXP 3
23511: ARRAY
23512: UNION
23513: PPUSH
23514: CALL_OW 1
23518: ST_TO_ADDR
// let_the_war_begin ( us ) ;
23519: LD_EXP 3
23523: PPUSH
23524: CALL 22848 0 1
// end ;
23528: PPOPN 4
23530: END
// every 91 marked 223 do var list , late , un , i ;
23531: GO 23533
23533: DISABLE
23534: LD_INT 0
23536: PPUSH
23537: PPUSH
23538: PPUSH
23539: PPUSH
// begin wait ( 1 1$20 ) ;
23540: LD_INT 2800
23542: PPUSH
23543: CALL_OW 67
// list := FilterUnitsInArea ( ru_tinny , [ [ f_side , ru ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23547: LD_ADDR_VAR 0 1
23551: PUSH
23552: LD_INT 40
23554: PPUSH
23555: LD_INT 22
23557: PUSH
23558: LD_EXP 2
23562: PUSH
23563: EMPTY
23564: LIST
23565: LIST
23566: PUSH
23567: LD_INT 21
23569: PUSH
23570: LD_INT 2
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: PUSH
23577: LD_INT 50
23579: PUSH
23580: EMPTY
23581: LIST
23582: PUSH
23583: EMPTY
23584: LIST
23585: LIST
23586: LIST
23587: PPUSH
23588: CALL_OW 70
23592: ST_TO_ADDR
// late := jammed_forces [ ru ] isect list ;
23593: LD_ADDR_VAR 0 2
23597: PUSH
23598: LD_EXP 69
23602: PUSH
23603: LD_EXP 2
23607: ARRAY
23608: PUSH
23609: LD_VAR 0 1
23613: ISECT
23614: ST_TO_ADDR
// if not late then
23615: LD_VAR 0 2
23619: NOT
23620: IFFALSE 23646
// begin jammed_forces := Replace ( jammed_forces , ru , [ ] ) ;
23622: LD_ADDR_EXP 69
23626: PUSH
23627: LD_EXP 69
23631: PPUSH
23632: LD_EXP 2
23636: PPUSH
23637: EMPTY
23638: PPUSH
23639: CALL_OW 1
23643: ST_TO_ADDR
// exit ;
23644: GO 23924
// end ; if FilterUnitsInArea ( ru_base , [ [ f_side , you ] ] ) then
23646: LD_INT 12
23648: PPUSH
23649: LD_INT 22
23651: PUSH
23652: LD_EXP 1
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: EMPTY
23662: LIST
23663: PPUSH
23664: CALL_OW 70
23668: IFFALSE 23673
// begin enable ;
23670: ENABLE
// exit ;
23671: GO 23924
// end ; for un in late do
23673: LD_ADDR_VAR 0 3
23677: PUSH
23678: LD_VAR 0 2
23682: PUSH
23683: FOR_IN
23684: IFFALSE 23713
// if GetUnitMc ( un ) then
23686: LD_VAR 0 3
23690: PPUSH
23691: CALL_OW 388
23695: IFFALSE 23711
// KillMc ( GetUnitMc ( un ) ) ;
23697: LD_VAR 0 3
23701: PPUSH
23702: CALL_OW 388
23706: PPUSH
23707: CALL_OW 387
23711: GO 23683
23713: POP
23714: POP
// while GetTag ( 83 ) do
23715: LD_INT 83
23717: PPUSH
23718: CALL_OW 110
23722: IFFALSE 23733
// wait ( 0 0$1 ) ;
23724: LD_INT 35
23726: PPUSH
23727: CALL_OW 67
23731: GO 23715
// i := 1 ;
23733: LD_ADDR_VAR 0 4
23737: PUSH
23738: LD_INT 1
23740: ST_TO_ADDR
// for un in jammed_forces [ ru ] do
23741: LD_ADDR_VAR 0 3
23745: PUSH
23746: LD_EXP 69
23750: PUSH
23751: LD_EXP 2
23755: ARRAY
23756: PUSH
23757: FOR_IN
23758: IFFALSE 23863
// begin if ( i mod 2 ) and not See ( you , un ) then
23760: LD_VAR 0 4
23764: PUSH
23765: LD_INT 2
23767: MOD
23768: PUSH
23769: LD_EXP 1
23773: PPUSH
23774: LD_VAR 0 3
23778: PPUSH
23779: CALL_OW 292
23783: NOT
23784: AND
23785: IFFALSE 23847
// begin jammed_forces := Replace ( jammed_forces , ru , jammed_forces [ ru ] diff un ) ;
23787: LD_ADDR_EXP 69
23791: PUSH
23792: LD_EXP 69
23796: PPUSH
23797: LD_EXP 2
23801: PPUSH
23802: LD_EXP 69
23806: PUSH
23807: LD_EXP 2
23811: ARRAY
23812: PUSH
23813: LD_VAR 0 3
23817: DIFF
23818: PPUSH
23819: CALL_OW 1
23823: ST_TO_ADDR
// KillUnit ( un ) ;
23824: LD_VAR 0 3
23828: PPUSH
23829: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23833: LD_ADDR_LOC 30
23837: PUSH
23838: LD_LOC 30
23842: PUSH
23843: LD_INT 1
23845: PLUS
23846: ST_TO_ADDR
// end ; i := i + 1 ;
23847: LD_ADDR_VAR 0 4
23851: PUSH
23852: LD_VAR 0 4
23856: PUSH
23857: LD_INT 1
23859: PLUS
23860: ST_TO_ADDR
// end ;
23861: GO 23757
23863: POP
23864: POP
// wait ( 0 0$10 ) ;
23865: LD_INT 350
23867: PPUSH
23868: CALL_OW 67
// ready_forces := Replace ( ready_forces , ru , ready_forces [ ru ] union jammed_forces [ ru ] ) ;
23872: LD_ADDR_EXP 65
23876: PUSH
23877: LD_EXP 65
23881: PPUSH
23882: LD_EXP 2
23886: PPUSH
23887: LD_EXP 65
23891: PUSH
23892: LD_EXP 2
23896: ARRAY
23897: PUSH
23898: LD_EXP 69
23902: PUSH
23903: LD_EXP 2
23907: ARRAY
23908: UNION
23909: PPUSH
23910: CALL_OW 1
23914: ST_TO_ADDR
// let_the_war_begin ( ru ) ;
23915: LD_EXP 2
23919: PPUSH
23920: CALL 22848 0 1
// end ; end_of_file
23924: PPOPN 4
23926: END
// var tech_list , weap_list , sib_list , comp_list , opto_list , bio_list , space_list ; var utech_basic , utech_weap , utech_sib , utech_comp , utech_bio , utech_space , utech_opto ; var basic_tech , upgrade_tech ; var first_technology , last_technology , recomended_technology ; export scientistic_wanted ; var all_invented ; export function init_research ; begin
23927: LD_INT 0
23929: PPUSH
// all_invented := [ false , false , false , false , false , false , false , false ] ;
23930: LD_ADDR_LOC 50
23934: PUSH
23935: LD_INT 0
23937: PUSH
23938: LD_INT 0
23940: PUSH
23941: LD_INT 0
23943: PUSH
23944: LD_INT 0
23946: PUSH
23947: LD_INT 0
23949: PUSH
23950: LD_INT 0
23952: PUSH
23953: LD_INT 0
23955: PUSH
23956: LD_INT 0
23958: PUSH
23959: EMPTY
23960: LIST
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: ST_TO_ADDR
// tech_list := [ tech_SolPow , tech_SolEng , tech_OilPow , tech_OilEng , tech_SibDet , tech_ApeLang , tech_ApePsych , tech_ApeAgres ] ;
23969: LD_ADDR_LOC 31
23973: PUSH
23974: LD_INT 35
23976: PUSH
23977: LD_INT 45
23979: PUSH
23980: LD_INT 46
23982: PUSH
23983: LD_INT 47
23985: PUSH
23986: LD_INT 20
23988: PUSH
23989: LD_INT 1
23991: PUSH
23992: LD_INT 2
23994: PUSH
23995: LD_INT 11
23997: PUSH
23998: EMPTY
23999: LIST
24000: LIST
24001: LIST
24002: LIST
24003: LIST
24004: LIST
24005: LIST
24006: LIST
24007: ST_TO_ADDR
// weap_list := [ tech_Gatling , tech_Gun , tech_Explos , tech_AdvMet , tech_Rocket , tech_AdvRocket , tech_Bazooka , tech_Mortar , tech_AdvChassis , tech_Soporific , tech_Flame , tech_Behemoth , tech_SelfDest ] ;
24008: LD_ADDR_LOC 32
24012: PUSH
24013: LD_INT 69
24015: PUSH
24016: LD_INT 39
24018: PUSH
24019: LD_INT 42
24021: PUSH
24022: LD_INT 34
24024: PUSH
24025: LD_INT 40
24027: PUSH
24028: LD_INT 71
24030: PUSH
24031: LD_INT 44
24033: PUSH
24034: LD_INT 41
24036: PUSH
24037: LD_INT 36
24039: PUSH
24040: LD_INT 13
24042: PUSH
24043: LD_INT 70
24045: PUSH
24046: LD_INT 23
24048: PUSH
24049: LD_INT 43
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: LIST
24066: ST_TO_ADDR
// sib_list := [ tech_SibPow , tech_SibEng , tech_SibFiss ] ;
24067: LD_ADDR_LOC 33
24071: PUSH
24072: LD_INT 21
24074: PUSH
24075: LD_INT 22
24077: PUSH
24078: LD_INT 25
24080: PUSH
24081: EMPTY
24082: LIST
24083: LIST
24084: LIST
24085: ST_TO_ADDR
// comp_list := [ tech_AI , tech_AdvAI , tech_Virus , tech_TargTeleport ] ;
24086: LD_ADDR_LOC 34
24090: PUSH
24091: LD_INT 32
24093: PUSH
24094: LD_INT 27
24096: PUSH
24097: LD_INT 33
24099: PUSH
24100: LD_INT 38
24102: PUSH
24103: EMPTY
24104: LIST
24105: LIST
24106: LIST
24107: LIST
24108: ST_TO_ADDR
// opto_list := [ tech_Radar , tech_LasSight , tech_RemCont , tech_Laser , tech_MatDet , tech_PartInvis , tech_RemCharge ] ;
24109: LD_ADDR_LOC 35
24113: PUSH
24114: LD_INT 6
24116: PUSH
24117: LD_INT 12
24119: PUSH
24120: LD_INT 15
24122: PUSH
24123: LD_INT 10
24125: PUSH
24126: LD_INT 7
24128: PUSH
24129: LD_INT 16
24131: PUSH
24132: LD_INT 18
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: ST_TO_ADDR
// bio_list := [ tech_ApeNeural , tech_ApeBrain , tech_StimDrugs , tech_BioDet ] ;
24144: LD_ADDR_LOC 36
24148: PUSH
24149: LD_INT 3
24151: PUSH
24152: LD_INT 4
24154: PUSH
24155: LD_INT 5
24157: PUSH
24158: LD_INT 8
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: ST_TO_ADDR
// space_list := [ tech_TauField , tech_Lapser , tech_LimTeleport , tech_TauRad , tech_SpacAnom ] ;
24167: LD_ADDR_LOC 37
24171: PUSH
24172: LD_INT 30
24174: PUSH
24175: LD_INT 31
24177: PUSH
24178: LD_INT 37
24180: PUSH
24181: LD_INT 28
24183: PUSH
24184: LD_INT 29
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: LIST
24191: LIST
24192: LIST
24193: ST_TO_ADDR
// basic_tech := [ tech_list , weap_list , sib_list , comp_list , bio_list , space_list , opto_list ] ;
24194: LD_ADDR_LOC 45
24198: PUSH
24199: LD_LOC 31
24203: PUSH
24204: LD_LOC 32
24208: PUSH
24209: LD_LOC 33
24213: PUSH
24214: LD_LOC 34
24218: PUSH
24219: LD_LOC 36
24223: PUSH
24224: LD_LOC 37
24228: PUSH
24229: LD_LOC 35
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: LIST
24238: LIST
24239: LIST
24240: LIST
24241: LIST
24242: ST_TO_ADDR
// utech_basic := [ tech_Tech1 , tech_Tech2 , tech_Tech3 ] ;
24243: LD_ADDR_LOC 38
24247: PUSH
24248: LD_INT 48
24250: PUSH
24251: LD_INT 49
24253: PUSH
24254: LD_INT 50
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: LIST
24261: ST_TO_ADDR
// utech_weap := [ tech_Weap1 , tech_Weap2 , tech_Weap3 ] ;
24262: LD_ADDR_LOC 39
24266: PUSH
24267: LD_INT 51
24269: PUSH
24270: LD_INT 52
24272: PUSH
24273: LD_INT 53
24275: PUSH
24276: EMPTY
24277: LIST
24278: LIST
24279: LIST
24280: ST_TO_ADDR
// utech_sib := [ tech_Sib1 , tech_Sib2 , tech_Sib3 ] ;
24281: LD_ADDR_LOC 40
24285: PUSH
24286: LD_INT 54
24288: PUSH
24289: LD_INT 55
24291: PUSH
24292: LD_INT 56
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: LIST
24299: ST_TO_ADDR
// utech_comp := [ tech_Comp1 , tech_Comp2 , tech_Comp3 ] ;
24300: LD_ADDR_LOC 41
24304: PUSH
24305: LD_INT 57
24307: PUSH
24308: LD_INT 58
24310: PUSH
24311: LD_INT 59
24313: PUSH
24314: EMPTY
24315: LIST
24316: LIST
24317: LIST
24318: ST_TO_ADDR
// utech_bio := [ tech_Bio1 , tech_Bio2 , tech_Bio3 ] ;
24319: LD_ADDR_LOC 42
24323: PUSH
24324: LD_INT 66
24326: PUSH
24327: LD_INT 67
24329: PUSH
24330: LD_INT 68
24332: PUSH
24333: EMPTY
24334: LIST
24335: LIST
24336: LIST
24337: ST_TO_ADDR
// utech_space := [ tech_ST1 , tech_ST2 , tech_ST3 ] ;
24338: LD_ADDR_LOC 43
24342: PUSH
24343: LD_INT 63
24345: PUSH
24346: LD_INT 64
24348: PUSH
24349: LD_INT 65
24351: PUSH
24352: EMPTY
24353: LIST
24354: LIST
24355: LIST
24356: ST_TO_ADDR
// utech_opto := [ tech_Opto1 , tech_Opto2 , tech_Opto3 ] ;
24357: LD_ADDR_LOC 44
24361: PUSH
24362: LD_INT 60
24364: PUSH
24365: LD_INT 61
24367: PUSH
24368: LD_INT 62
24370: PUSH
24371: EMPTY
24372: LIST
24373: LIST
24374: LIST
24375: ST_TO_ADDR
// end ;
24376: LD_VAR 0 1
24380: RET
// function init_upgrade_by_nations ( side_nation ) ; begin
24381: LD_INT 0
24383: PPUSH
// first_technology := [ tech_SolPow , tech_OilPow , tech_OilEng , tech_SibDet , tech_SibPow , tech_AI , tech_AdvAI ] ;
24384: LD_ADDR_LOC 47
24388: PUSH
24389: LD_INT 35
24391: PUSH
24392: LD_INT 46
24394: PUSH
24395: LD_INT 47
24397: PUSH
24398: LD_INT 20
24400: PUSH
24401: LD_INT 21
24403: PUSH
24404: LD_INT 32
24406: PUSH
24407: LD_INT 27
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: LIST
24414: LIST
24415: LIST
24416: LIST
24417: LIST
24418: ST_TO_ADDR
// last_technology := [ tech_ApeBrain , tech_Flame , tech_Soporific , tech_SibFiss ] ;
24419: LD_ADDR_LOC 48
24423: PUSH
24424: LD_INT 4
24426: PUSH
24427: LD_INT 70
24429: PUSH
24430: LD_INT 13
24432: PUSH
24433: LD_INT 25
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: ST_TO_ADDR
// recomended_technology := [ tech_Gun , tech_Tech1 , tech_Comp1 , tech_Tech2 , tech_Comp2 , tech_Tech3 , tech_Comp3 ] ;
24442: LD_ADDR_LOC 49
24446: PUSH
24447: LD_INT 39
24449: PUSH
24450: LD_INT 48
24452: PUSH
24453: LD_INT 57
24455: PUSH
24456: LD_INT 49
24458: PUSH
24459: LD_INT 58
24461: PUSH
24462: LD_INT 50
24464: PUSH
24465: LD_INT 59
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: LIST
24472: LIST
24473: LIST
24474: LIST
24475: LIST
24476: ST_TO_ADDR
// case side_nation of 1 :
24477: LD_VAR 0 1
24481: PUSH
24482: LD_INT 1
24484: DOUBLE
24485: EQUAL
24486: IFTRUE 24490
24488: GO 24530
24490: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_opto ] ; 2 :
24491: LD_ADDR_LOC 46
24495: PUSH
24496: LD_LOC 38
24500: PUSH
24501: LD_LOC 39
24505: PUSH
24506: LD_LOC 40
24510: PUSH
24511: LD_LOC 41
24515: PUSH
24516: LD_LOC 44
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: LIST
24525: LIST
24526: LIST
24527: ST_TO_ADDR
24528: GO 24627
24530: LD_INT 2
24532: DOUBLE
24533: EQUAL
24534: IFTRUE 24538
24536: GO 24578
24538: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_bio , utech_opto ] ; 3 :
24539: LD_ADDR_LOC 46
24543: PUSH
24544: LD_LOC 38
24548: PUSH
24549: LD_LOC 39
24553: PUSH
24554: LD_LOC 40
24558: PUSH
24559: LD_LOC 42
24563: PUSH
24564: LD_LOC 44
24568: PUSH
24569: EMPTY
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: LIST
24575: ST_TO_ADDR
24576: GO 24627
24578: LD_INT 3
24580: DOUBLE
24581: EQUAL
24582: IFTRUE 24586
24584: GO 24626
24586: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_space ] ; end ;
24587: LD_ADDR_LOC 46
24591: PUSH
24592: LD_LOC 38
24596: PUSH
24597: LD_LOC 39
24601: PUSH
24602: LD_LOC 40
24606: PUSH
24607: LD_LOC 41
24611: PUSH
24612: LD_LOC 43
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: LIST
24621: LIST
24622: LIST
24623: ST_TO_ADDR
24624: GO 24627
24626: POP
// end ;
24627: LD_VAR 0 2
24631: RET
// every 0 0$5.5 do var un , active_side , active_nation , lab_list , still_researching ;
24632: GO 24634
24634: DISABLE
24635: LD_INT 0
24637: PPUSH
24638: PPUSH
24639: PPUSH
24640: PPUSH
24641: PPUSH
// begin for active_side in cpu_list do
24642: LD_ADDR_VAR 0 2
24646: PUSH
24647: LD_EXP 8
24651: PUSH
24652: FOR_IN
24653: IFFALSE 24762
// begin still_researching := false ;
24655: LD_ADDR_VAR 0 5
24659: PUSH
24660: LD_INT 0
24662: ST_TO_ADDR
// lab_list := get_labs ( active_side ) ;
24663: LD_ADDR_VAR 0 4
24667: PUSH
24668: LD_VAR 0 2
24672: PPUSH
24673: CALL 24849 0 1
24677: ST_TO_ADDR
// for un in lab_list do
24678: LD_ADDR_VAR 0 1
24682: PUSH
24683: LD_VAR 0 4
24687: PUSH
24688: FOR_IN
24689: IFFALSE 24716
// if BuildingStatus ( un ) = bs_working then
24691: LD_VAR 0 1
24695: PPUSH
24696: CALL_OW 461
24700: PUSH
24701: LD_INT 3
24703: EQUAL
24704: IFFALSE 24714
// still_researching := true ;
24706: LD_ADDR_VAR 0 5
24710: PUSH
24711: LD_INT 1
24713: ST_TO_ADDR
24714: GO 24688
24716: POP
24717: POP
// active_nation := GetCPUNation ( active_side ) ;
24718: LD_ADDR_VAR 0 3
24722: PUSH
24723: LD_VAR 0 2
24727: PPUSH
24728: CALL 26450 0 1
24732: ST_TO_ADDR
// if ( not still_researching ) and active_nation then
24733: LD_VAR 0 5
24737: NOT
24738: PUSH
24739: LD_VAR 0 3
24743: AND
24744: IFFALSE 24760
// start_new_research ( active_side , active_nation ) ;
24746: LD_VAR 0 2
24750: PPUSH
24751: LD_VAR 0 3
24755: PPUSH
24756: CALL 24922 0 2
// end ;
24760: GO 24652
24762: POP
24763: POP
// if ( cpu_list ) and ( not all_cpu_invented ) then
24764: LD_EXP 8
24768: PUSH
24769: CALL 24781 0 0
24773: NOT
24774: AND
24775: IFFALSE 24778
// enable ;
24777: ENABLE
// end ;
24778: PPOPN 5
24780: END
// function all_cpu_invented ; var un , vysledek ; begin
24781: LD_INT 0
24783: PPUSH
24784: PPUSH
24785: PPUSH
// vysledek := true ;
24786: LD_ADDR_VAR 0 3
24790: PUSH
24791: LD_INT 1
24793: ST_TO_ADDR
// for un in cpu_list do
24794: LD_ADDR_VAR 0 2
24798: PUSH
24799: LD_EXP 8
24803: PUSH
24804: FOR_IN
24805: IFFALSE 24832
// if not all_invented [ un ] then
24807: LD_LOC 50
24811: PUSH
24812: LD_VAR 0 2
24816: ARRAY
24817: NOT
24818: IFFALSE 24830
// begin vysledek := false ;
24820: LD_ADDR_VAR 0 3
24824: PUSH
24825: LD_INT 0
24827: ST_TO_ADDR
// break ;
24828: GO 24832
// end ;
24830: GO 24804
24832: POP
24833: POP
// result := vysledek ;
24834: LD_ADDR_VAR 0 1
24838: PUSH
24839: LD_VAR 0 3
24843: ST_TO_ADDR
// end ;
24844: LD_VAR 0 1
24848: RET
// function get_labs ( side ) ; var lab_list ; begin
24849: LD_INT 0
24851: PPUSH
24852: PPUSH
// lab_list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
24853: LD_ADDR_VAR 0 3
24857: PUSH
24858: LD_INT 22
24860: PUSH
24861: LD_VAR 0 1
24865: PUSH
24866: EMPTY
24867: LIST
24868: LIST
24869: PUSH
24870: LD_INT 2
24872: PUSH
24873: LD_INT 30
24875: PUSH
24876: LD_INT 8
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: LD_INT 30
24885: PUSH
24886: LD_INT 6
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: LIST
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: PPUSH
24902: CALL_OW 69
24906: ST_TO_ADDR
// result := lab_list ;
24907: LD_ADDR_VAR 0 2
24911: PUSH
24912: LD_VAR 0 3
24916: ST_TO_ADDR
// end ;
24917: LD_VAR 0 2
24921: RET
// function start_new_research ( side , nation ) ; var lab_list , possible , to_research , lab , scientistic ; begin
24922: LD_INT 0
24924: PPUSH
24925: PPUSH
24926: PPUSH
24927: PPUSH
24928: PPUSH
24929: PPUSH
// scientistic := request_people ( side , class_scientistic , 1 ) ;
24930: LD_ADDR_VAR 0 8
24934: PUSH
24935: LD_VAR 0 1
24939: PPUSH
24940: LD_INT 4
24942: PPUSH
24943: LD_INT 1
24945: PPUSH
24946: CALL 26382 0 3
24950: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
24951: LD_ADDR_VAR 0 4
24955: PUSH
24956: LD_VAR 0 1
24960: PPUSH
24961: CALL 24849 0 1
24965: ST_TO_ADDR
// init_upgrade_by_nations ( nation ) ;
24966: LD_VAR 0 2
24970: PPUSH
24971: CALL 24381 0 1
// possible := get_possible_research ( side ) ;
24975: LD_ADDR_VAR 0 5
24979: PUSH
24980: LD_VAR 0 1
24984: PPUSH
24985: CALL 25069 0 1
24989: ST_TO_ADDR
// to_research := select_next_technology ( side , possible ) ;
24990: LD_ADDR_VAR 0 6
24994: PUSH
24995: LD_VAR 0 1
24999: PPUSH
25000: LD_VAR 0 5
25004: PPUSH
25005: CALL 25520 0 2
25009: ST_TO_ADDR
// lab := research_possible ( side , to_research ) ;
25010: LD_ADDR_VAR 0 7
25014: PUSH
25015: LD_VAR 0 1
25019: PPUSH
25020: LD_VAR 0 6
25024: PPUSH
25025: CALL 26079 0 2
25029: ST_TO_ADDR
// if lab then
25030: LD_VAR 0 7
25034: IFFALSE 25064
// begin transfer_scientistic ( scientistic , lab ) ;
25036: LD_VAR 0 8
25040: PPUSH
25041: LD_VAR 0 7
25045: PPUSH
25046: CALL 26200 0 2
// begin_of_research ( lab , to_research ) ;
25050: LD_VAR 0 7
25054: PPUSH
25055: LD_VAR 0 6
25059: PPUSH
25060: CALL 26308 0 2
// end ; end ;
25064: LD_VAR 0 3
25068: RET
// function get_possible_research ( side ) ; var un , vysledek , lab_list , upgrade ; begin
25069: LD_INT 0
25071: PPUSH
25072: PPUSH
25073: PPUSH
25074: PPUSH
25075: PPUSH
// vysledek := [ ] ;
25076: LD_ADDR_VAR 0 4
25080: PUSH
25081: EMPTY
25082: ST_TO_ADDR
// upgrade := [ ] ;
25083: LD_ADDR_VAR 0 6
25087: PUSH
25088: EMPTY
25089: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25090: LD_ADDR_VAR 0 5
25094: PUSH
25095: LD_VAR 0 1
25099: PPUSH
25100: CALL 24849 0 1
25104: ST_TO_ADDR
// for un in lab_list do
25105: LD_ADDR_VAR 0 3
25109: PUSH
25110: LD_VAR 0 5
25114: PUSH
25115: FOR_IN
25116: IFFALSE 25158
// upgrade := upgrade ^ GetLabKind ( un , 1 ) ^ GetLabKind ( un , 2 ) ;
25118: LD_ADDR_VAR 0 6
25122: PUSH
25123: LD_VAR 0 6
25127: PUSH
25128: LD_VAR 0 3
25132: PPUSH
25133: LD_INT 1
25135: PPUSH
25136: CALL_OW 268
25140: ADD
25141: PUSH
25142: LD_VAR 0 3
25146: PPUSH
25147: LD_INT 2
25149: PPUSH
25150: CALL_OW 268
25154: ADD
25155: ST_TO_ADDR
25156: GO 25115
25158: POP
25159: POP
// for un in upgrade do
25160: LD_ADDR_VAR 0 3
25164: PUSH
25165: LD_VAR 0 6
25169: PUSH
25170: FOR_IN
25171: IFFALSE 25195
// vysledek := vysledek ^ ( un - 8 ) ;
25173: LD_ADDR_VAR 0 4
25177: PUSH
25178: LD_VAR 0 4
25182: PUSH
25183: LD_VAR 0 3
25187: PUSH
25188: LD_INT 8
25190: MINUS
25191: ADD
25192: ST_TO_ADDR
25193: GO 25170
25195: POP
25196: POP
// result := vysledek ;
25197: LD_ADDR_VAR 0 2
25201: PUSH
25202: LD_VAR 0 4
25206: ST_TO_ADDR
// end ;
25207: LD_VAR 0 2
25211: RET
// function shake_it_baby ( list ) ; var vysledek , pom , i , n ; begin
25212: LD_INT 0
25214: PPUSH
25215: PPUSH
25216: PPUSH
25217: PPUSH
25218: PPUSH
// vysledek := [ ] ;
25219: LD_ADDR_VAR 0 3
25223: PUSH
25224: EMPTY
25225: ST_TO_ADDR
// for i = 1 to list do
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: DOUBLE
25232: LD_INT 1
25234: DEC
25235: ST_TO_ADDR
25236: LD_VAR 0 1
25240: PUSH
25241: FOR_TO
25242: IFFALSE 25316
// begin n := Rand ( 1 , list ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_INT 1
25251: PPUSH
25252: LD_VAR 0 1
25256: PPUSH
25257: CALL_OW 12
25261: ST_TO_ADDR
// pom := list [ n ] ;
25262: LD_ADDR_VAR 0 4
25266: PUSH
25267: LD_VAR 0 1
25271: PUSH
25272: LD_VAR 0 6
25276: ARRAY
25277: ST_TO_ADDR
// list := Delete ( list , n ) ;
25278: LD_ADDR_VAR 0 1
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: LD_VAR 0 6
25292: PPUSH
25293: CALL_OW 3
25297: ST_TO_ADDR
// vysledek := vysledek ^ pom ;
25298: LD_ADDR_VAR 0 3
25302: PUSH
25303: LD_VAR 0 3
25307: PUSH
25308: LD_VAR 0 4
25312: ADD
25313: ST_TO_ADDR
// end ;
25314: GO 25241
25316: POP
25317: POP
// result := vysledek ;
25318: LD_ADDR_VAR 0 2
25322: PUSH
25323: LD_VAR 0 3
25327: ST_TO_ADDR
// end ;
25328: LD_VAR 0 2
25332: RET
// function GetBasicTechnology ; var list , un , vysledek ; begin
25333: LD_INT 0
25335: PPUSH
25336: PPUSH
25337: PPUSH
25338: PPUSH
// list := [ ] ;
25339: LD_ADDR_VAR 0 2
25343: PUSH
25344: EMPTY
25345: ST_TO_ADDR
// for un in basic_tech do
25346: LD_ADDR_VAR 0 3
25350: PUSH
25351: LD_LOC 45
25355: PUSH
25356: FOR_IN
25357: IFFALSE 25386
// if un then
25359: LD_VAR 0 3
25363: IFFALSE 25384
// list := list ^ [ un ] ;
25365: LD_ADDR_VAR 0 2
25369: PUSH
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: EMPTY
25381: LIST
25382: ADD
25383: ST_TO_ADDR
25384: GO 25356
25386: POP
25387: POP
// if list > 1 then
25388: LD_VAR 0 2
25392: PUSH
25393: LD_INT 1
25395: GREATER
25396: IFFALSE 25413
// vysledek := shake_it_baby ( list ) ;
25398: LD_ADDR_VAR 0 4
25402: PUSH
25403: LD_VAR 0 2
25407: PPUSH
25408: CALL 25212 0 1
25412: ST_TO_ADDR
// result := vysledek ;
25413: LD_ADDR_VAR 0 1
25417: PUSH
25418: LD_VAR 0 4
25422: ST_TO_ADDR
// end ;
25423: LD_VAR 0 1
25427: RET
// function GetUpgradeTechnology ; var list , un , vysledek ; begin
25428: LD_INT 0
25430: PPUSH
25431: PPUSH
25432: PPUSH
25433: PPUSH
// vysledek := [ ] ;
25434: LD_ADDR_VAR 0 4
25438: PUSH
25439: EMPTY
25440: ST_TO_ADDR
// list := [ ] ;
25441: LD_ADDR_VAR 0 2
25445: PUSH
25446: EMPTY
25447: ST_TO_ADDR
// for un in upgrade_tech do
25448: LD_ADDR_VAR 0 3
25452: PUSH
25453: LD_LOC 46
25457: PUSH
25458: FOR_IN
25459: IFFALSE 25488
// if un then
25461: LD_VAR 0 3
25465: IFFALSE 25486
// list := list ^ [ un ] ;
25467: LD_ADDR_VAR 0 2
25471: PUSH
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 3
25481: PUSH
25482: EMPTY
25483: LIST
25484: ADD
25485: ST_TO_ADDR
25486: GO 25458
25488: POP
25489: POP
// vysledek := shake_it_baby ( list ) ;
25490: LD_ADDR_VAR 0 4
25494: PUSH
25495: LD_VAR 0 2
25499: PPUSH
25500: CALL 25212 0 1
25504: ST_TO_ADDR
// result := vysledek ;
25505: LD_ADDR_VAR 0 1
25509: PUSH
25510: LD_VAR 0 4
25514: ST_TO_ADDR
// end ;
25515: LD_VAR 0 1
25519: RET
// function select_next_technology ( side , possible ) ; var un , pom , new , vysledek , select ; begin
25520: LD_INT 0
25522: PPUSH
25523: PPUSH
25524: PPUSH
25525: PPUSH
25526: PPUSH
25527: PPUSH
// new := true ;
25528: LD_ADDR_VAR 0 6
25532: PUSH
25533: LD_INT 1
25535: ST_TO_ADDR
// vysledek := [ ] ;
25536: LD_ADDR_VAR 0 7
25540: PUSH
25541: EMPTY
25542: ST_TO_ADDR
// select := [ ] ;
25543: LD_ADDR_VAR 0 8
25547: PUSH
25548: EMPTY
25549: ST_TO_ADDR
// for un in first_technology do
25550: LD_ADDR_VAR 0 4
25554: PUSH
25555: LD_LOC 47
25559: PUSH
25560: FOR_IN
25561: IFFALSE 25603
// begin pom := research_possible ( side , un ) ;
25563: LD_ADDR_VAR 0 5
25567: PUSH
25568: LD_VAR 0 1
25572: PPUSH
25573: LD_VAR 0 4
25577: PPUSH
25578: CALL 26079 0 2
25582: ST_TO_ADDR
// if pom then
25583: LD_VAR 0 5
25587: IFFALSE 25601
// begin vysledek := un ;
25589: LD_ADDR_VAR 0 7
25593: PUSH
25594: LD_VAR 0 4
25598: ST_TO_ADDR
// break ;
25599: GO 25603
// end ; end ;
25601: GO 25560
25603: POP
25604: POP
// if not first_technology then
25605: LD_LOC 47
25609: NOT
25610: IFFALSE 25620
// new := false ;
25612: LD_ADDR_VAR 0 6
25616: PUSH
25617: LD_INT 0
25619: ST_TO_ADDR
// if not vysledek and ( Rand ( 0 , 10 ) < 3 ) then
25620: LD_VAR 0 7
25624: NOT
25625: PUSH
25626: LD_INT 0
25628: PPUSH
25629: LD_INT 10
25631: PPUSH
25632: CALL_OW 12
25636: PUSH
25637: LD_INT 3
25639: LESS
25640: AND
25641: IFFALSE 25698
// for un in recomended_technology do
25643: LD_ADDR_VAR 0 4
25647: PUSH
25648: LD_LOC 49
25652: PUSH
25653: FOR_IN
25654: IFFALSE 25696
// begin pom := research_possible ( side , un ) ;
25656: LD_ADDR_VAR 0 5
25660: PUSH
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_VAR 0 4
25670: PPUSH
25671: CALL 26079 0 2
25675: ST_TO_ADDR
// if pom then
25676: LD_VAR 0 5
25680: IFFALSE 25694
// begin vysledek := un ;
25682: LD_ADDR_VAR 0 7
25686: PUSH
25687: LD_VAR 0 4
25691: ST_TO_ADDR
// break ;
25692: GO 25696
// end ; end ;
25694: GO 25653
25696: POP
25697: POP
// if not recomended_technology then
25698: LD_LOC 49
25702: NOT
25703: IFFALSE 25713
// new := false ;
25705: LD_ADDR_VAR 0 6
25709: PUSH
25710: LD_INT 0
25712: ST_TO_ADDR
// if not vysledek then
25713: LD_VAR 0 7
25717: NOT
25718: IFFALSE 25805
// begin select := GetBasicTechnology ;
25720: LD_ADDR_VAR 0 8
25724: PUSH
25725: CALL 25333 0 0
25729: ST_TO_ADDR
// for un in select do
25730: LD_ADDR_VAR 0 4
25734: PUSH
25735: LD_VAR 0 8
25739: PUSH
25740: FOR_IN
25741: IFFALSE 25803
// begin pom := [ ] ;
25743: LD_ADDR_VAR 0 5
25747: PUSH
25748: EMPTY
25749: ST_TO_ADDR
// if not un in last_technology then
25750: LD_VAR 0 4
25754: PUSH
25755: LD_LOC 48
25759: IN
25760: NOT
25761: IFFALSE 25783
// pom := research_possible ( side , un ) ;
25763: LD_ADDR_VAR 0 5
25767: PUSH
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_VAR 0 4
25777: PPUSH
25778: CALL 26079 0 2
25782: ST_TO_ADDR
// if pom then
25783: LD_VAR 0 5
25787: IFFALSE 25801
// begin vysledek := un ;
25789: LD_ADDR_VAR 0 7
25793: PUSH
25794: LD_VAR 0 4
25798: ST_TO_ADDR
// break ;
25799: GO 25803
// end ; end ;
25801: GO 25740
25803: POP
25804: POP
// end ; if not select then
25805: LD_VAR 0 8
25809: NOT
25810: IFFALSE 25820
// new := false ;
25812: LD_ADDR_VAR 0 6
25816: PUSH
25817: LD_INT 0
25819: ST_TO_ADDR
// if not vysledek then
25820: LD_VAR 0 7
25824: NOT
25825: IFFALSE 25912
// begin select := GetUpgradeTechnology ;
25827: LD_ADDR_VAR 0 8
25831: PUSH
25832: CALL 25428 0 0
25836: ST_TO_ADDR
// for un in select do
25837: LD_ADDR_VAR 0 4
25841: PUSH
25842: LD_VAR 0 8
25846: PUSH
25847: FOR_IN
25848: IFFALSE 25910
// begin pom := [ ] ;
25850: LD_ADDR_VAR 0 5
25854: PUSH
25855: EMPTY
25856: ST_TO_ADDR
// if not un in last_technology then
25857: LD_VAR 0 4
25861: PUSH
25862: LD_LOC 48
25866: IN
25867: NOT
25868: IFFALSE 25890
// pom := research_possible ( side , un ) ;
25870: LD_ADDR_VAR 0 5
25874: PUSH
25875: LD_VAR 0 1
25879: PPUSH
25880: LD_VAR 0 4
25884: PPUSH
25885: CALL 26079 0 2
25889: ST_TO_ADDR
// if pom then
25890: LD_VAR 0 5
25894: IFFALSE 25908
// begin vysledek := un ;
25896: LD_ADDR_VAR 0 7
25900: PUSH
25901: LD_VAR 0 4
25905: ST_TO_ADDR
// break ;
25906: GO 25910
// end ; end ;
25908: GO 25847
25910: POP
25911: POP
// end ; if not select then
25912: LD_VAR 0 8
25916: NOT
25917: IFFALSE 25927
// new := false ;
25919: LD_ADDR_VAR 0 6
25923: PUSH
25924: LD_INT 0
25926: ST_TO_ADDR
// if not vysledek then
25927: LD_VAR 0 7
25931: NOT
25932: IFFALSE 25989
// for un in last_technology do
25934: LD_ADDR_VAR 0 4
25938: PUSH
25939: LD_LOC 48
25943: PUSH
25944: FOR_IN
25945: IFFALSE 25987
// begin pom := research_possible ( side , un ) ;
25947: LD_ADDR_VAR 0 5
25951: PUSH
25952: LD_VAR 0 1
25956: PPUSH
25957: LD_VAR 0 4
25961: PPUSH
25962: CALL 26079 0 2
25966: ST_TO_ADDR
// if pom then
25967: LD_VAR 0 5
25971: IFFALSE 25985
// begin vysledek := un ;
25973: LD_ADDR_VAR 0 7
25977: PUSH
25978: LD_VAR 0 4
25982: ST_TO_ADDR
// break ;
25983: GO 25987
// end ; end ;
25985: GO 25944
25987: POP
25988: POP
// if not last_technology then
25989: LD_LOC 48
25993: NOT
25994: IFFALSE 26004
// new := false ;
25996: LD_ADDR_VAR 0 6
26000: PUSH
26001: LD_INT 0
26003: ST_TO_ADDR
// if not ( vysledek or new ) then
26004: LD_VAR 0 7
26008: PUSH
26009: LD_VAR 0 6
26013: OR
26014: NOT
26015: IFFALSE 26064
// begin all_invented := Insert ( all_invented , side , true ) ;
26017: LD_ADDR_LOC 50
26021: PUSH
26022: LD_LOC 50
26026: PPUSH
26027: LD_VAR 0 1
26031: PPUSH
26032: LD_INT 1
26034: PPUSH
26035: CALL_OW 2
26039: ST_TO_ADDR
// all_invented := Delete ( all_invented , side + 1 ) ;
26040: LD_ADDR_LOC 50
26044: PUSH
26045: LD_LOC 50
26049: PPUSH
26050: LD_VAR 0 1
26054: PUSH
26055: LD_INT 1
26057: PLUS
26058: PPUSH
26059: CALL_OW 3
26063: ST_TO_ADDR
// end ; result := vysledek ;
26064: LD_ADDR_VAR 0 3
26068: PUSH
26069: LD_VAR 0 7
26073: ST_TO_ADDR
// end ;
26074: LD_VAR 0 3
26078: RET
// function research_possible ( side , tech ) ; var un , vysledek , lab_list ; begin
26079: LD_INT 0
26081: PPUSH
26082: PPUSH
26083: PPUSH
26084: PPUSH
// lab_list := get_labs ( side ) ;
26085: LD_ADDR_VAR 0 6
26089: PUSH
26090: LD_VAR 0 1
26094: PPUSH
26095: CALL 24849 0 1
26099: ST_TO_ADDR
// if GetTech ( tech , side ) in [ state_disabled , state_researched ] then
26100: LD_VAR 0 2
26104: PPUSH
26105: LD_VAR 0 1
26109: PPUSH
26110: CALL_OW 321
26114: PUSH
26115: LD_INT 0
26117: PUSH
26118: LD_INT 2
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: IN
26125: IFFALSE 26136
// vysledek := [ ] else
26127: LD_ADDR_VAR 0 5
26131: PUSH
26132: EMPTY
26133: ST_TO_ADDR
26134: GO 26185
// for un in lab_list do
26136: LD_ADDR_VAR 0 4
26140: PUSH
26141: LD_VAR 0 6
26145: PUSH
26146: FOR_IN
26147: IFFALSE 26183
// if CanBeResearched ( un , tech ) then
26149: LD_VAR 0 4
26153: PPUSH
26154: LD_VAR 0 2
26158: PPUSH
26159: CALL_OW 430
26163: IFFALSE 26181
// vysledek := vysledek ^ un ;
26165: LD_ADDR_VAR 0 5
26169: PUSH
26170: LD_VAR 0 5
26174: PUSH
26175: LD_VAR 0 4
26179: ADD
26180: ST_TO_ADDR
26181: GO 26146
26183: POP
26184: POP
// result := vysledek ;
26185: LD_ADDR_VAR 0 3
26189: PUSH
26190: LD_VAR 0 5
26194: ST_TO_ADDR
// end ;
26195: LD_VAR 0 3
26199: RET
// function transfer_scientistic ( scients , to_lab ) ; var un , i ; begin
26200: LD_INT 0
26202: PPUSH
26203: PPUSH
26204: PPUSH
// i = 1 ;
26205: LD_ADDR_VAR 0 5
26209: PUSH
26210: LD_INT 1
26212: ST_TO_ADDR
// to_lab := to_lab diff [ 0 ] ;
26213: LD_ADDR_VAR 0 2
26217: PUSH
26218: LD_VAR 0 2
26222: PUSH
26223: LD_INT 0
26225: PUSH
26226: EMPTY
26227: LIST
26228: DIFF
26229: ST_TO_ADDR
// for un in scients do
26230: LD_ADDR_VAR 0 4
26234: PUSH
26235: LD_VAR 0 1
26239: PUSH
26240: FOR_IN
26241: IFFALSE 26289
// begin ComEnterUnit ( un , to_lab [ ( i mod to_lab ) + 1 ] ) ;
26243: LD_VAR 0 4
26247: PPUSH
26248: LD_VAR 0 2
26252: PUSH
26253: LD_VAR 0 5
26257: PUSH
26258: LD_VAR 0 2
26262: MOD
26263: PUSH
26264: LD_INT 1
26266: PLUS
26267: ARRAY
26268: PPUSH
26269: CALL_OW 120
// i := i + 1 ;
26273: LD_ADDR_VAR 0 5
26277: PUSH
26278: LD_VAR 0 5
26282: PUSH
26283: LD_INT 1
26285: PLUS
26286: ST_TO_ADDR
// end ;
26287: GO 26240
26289: POP
26290: POP
// AddComChangeProfession ( scients , class_scientistic ) ;
26291: LD_VAR 0 1
26295: PPUSH
26296: LD_INT 4
26298: PPUSH
26299: CALL_OW 183
// end ;
26303: LD_VAR 0 3
26307: RET
// function begin_of_research ( lab , to_research ) ; begin
26308: LD_INT 0
26310: PPUSH
// ComResearch ( lab , to_research ) ;
26311: LD_VAR 0 1
26315: PPUSH
26316: LD_VAR 0 2
26320: PPUSH
26321: CALL_OW 124
// end ; end_of_file
26325: LD_VAR 0 3
26329: RET
// export reserved_people ; var vysledek ; export function init_distribution ; var un ; begin
26330: LD_INT 0
26332: PPUSH
26333: PPUSH
// reserved_people := [ ] ;
26334: LD_ADDR_EXP 71
26338: PUSH
26339: EMPTY
26340: ST_TO_ADDR
// for un = 1 to 8 do
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: DOUBLE
26347: LD_INT 1
26349: DEC
26350: ST_TO_ADDR
26351: LD_INT 8
26353: PUSH
26354: FOR_TO
26355: IFFALSE 26375
// reserved_people := reserved_people ^ [ [ ] ] ;
26357: LD_ADDR_EXP 71
26361: PUSH
26362: LD_EXP 71
26366: PUSH
26367: EMPTY
26368: PUSH
26369: EMPTY
26370: LIST
26371: ADD
26372: ST_TO_ADDR
26373: GO 26354
26375: POP
26376: POP
// end ;
26377: LD_VAR 0 1
26381: RET
// export function request_people ( side , man_class , priority ) ; begin
26382: LD_INT 0
26384: PPUSH
// vysledek := FilterAllUnits ( [ [ f_side , side ] , [ f_class , man_class ] ] ) diff reserved_people [ side ] ;
26385: LD_ADDR_LOC 51
26389: PUSH
26390: LD_INT 22
26392: PUSH
26393: LD_VAR 0 1
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: LD_INT 25
26404: PUSH
26405: LD_VAR 0 2
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PPUSH
26418: CALL_OW 69
26422: PUSH
26423: LD_EXP 71
26427: PUSH
26428: LD_VAR 0 1
26432: ARRAY
26433: DIFF
26434: ST_TO_ADDR
// result := vysledek ;
26435: LD_ADDR_VAR 0 4
26439: PUSH
26440: LD_LOC 51
26444: ST_TO_ADDR
// end ;
26445: LD_VAR 0 4
26449: RET
// export function GetCPUNation ( side ) ; var un , vysledek ; begin
26450: LD_INT 0
26452: PPUSH
26453: PPUSH
26454: PPUSH
// un := FilterAllUnits ( [ [ f_side , side ] ] ) ;
26455: LD_ADDR_VAR 0 3
26459: PUSH
26460: LD_INT 22
26462: PUSH
26463: LD_VAR 0 1
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: EMPTY
26473: LIST
26474: PPUSH
26475: CALL_OW 69
26479: ST_TO_ADDR
// if un then
26480: LD_VAR 0 3
26484: IFFALSE 26507
// vysledek := GetSide ( un [ 1 ] ) else
26486: LD_ADDR_VAR 0 4
26490: PUSH
26491: LD_VAR 0 3
26495: PUSH
26496: LD_INT 1
26498: ARRAY
26499: PPUSH
26500: CALL_OW 255
26504: ST_TO_ADDR
26505: GO 26515
// vysledek := false ;
26507: LD_ADDR_VAR 0 4
26511: PUSH
26512: LD_INT 0
26514: ST_TO_ADDR
// result := vysledek ;
26515: LD_ADDR_VAR 0 2
26519: PUSH
26520: LD_VAR 0 4
26524: ST_TO_ADDR
// end ; end_of_file
26525: LD_VAR 0 2
26529: RET
// var us_weapons , ar_weapons , ru_weapons ; var sib_engine , oil_engine ; var prefered ; var main_extensions ; var hovers_recomended , flat_land ; export mechanics_wanted , extension_wanted ; function init_priority ( side , side_nation ) ; var us_main_control ; begin
26530: LD_INT 0
26532: PPUSH
26533: PPUSH
// us_main_control := b_ext_computer ;
26534: LD_ADDR_VAR 0 4
26538: PUSH
26539: LD_INT 24
26541: ST_TO_ADDR
// prefered_control := control_computer ;
26542: LD_ADDR_EXP 59
26546: PUSH
26547: LD_INT 3
26549: ST_TO_ADDR
// case side_nation of 1 :
26550: LD_VAR 0 2
26554: PUSH
26555: LD_INT 1
26557: DOUBLE
26558: EQUAL
26559: IFTRUE 26563
26561: GO 26595
26563: POP
// main_extensions := [ b_ext_track , b_ext_siberium , b_ext_laser , b_ext_rocket , us_main_control ] ; 2 :
26564: LD_ADDR_LOC 58
26568: PUSH
26569: LD_INT 16
26571: PUSH
26572: LD_INT 21
26574: PUSH
26575: LD_INT 25
26577: PUSH
26578: LD_INT 18
26580: PUSH
26581: LD_VAR 0 4
26585: PUSH
26586: EMPTY
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: ST_TO_ADDR
26593: GO 26672
26595: LD_INT 2
26597: DOUBLE
26598: EQUAL
26599: IFTRUE 26603
26601: GO 26633
26603: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar , b_ext_siberium ] ; 3 :
26604: LD_ADDR_LOC 58
26608: PUSH
26609: LD_INT 16
26611: PUSH
26612: LD_INT 17
26614: PUSH
26615: LD_INT 18
26617: PUSH
26618: LD_INT 20
26620: PUSH
26621: LD_INT 21
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: ST_TO_ADDR
26631: GO 26672
26633: LD_INT 3
26635: DOUBLE
26636: EQUAL
26637: IFTRUE 26641
26639: GO 26671
26641: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ; end ;
26642: LD_ADDR_LOC 58
26646: PUSH
26647: LD_INT 16
26649: PUSH
26650: LD_INT 17
26652: PUSH
26653: LD_INT 18
26655: PUSH
26656: LD_INT 24
26658: PUSH
26659: LD_INT 21
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: ST_TO_ADDR
26669: GO 26672
26671: POP
// end ;
26672: LD_VAR 0 3
26676: RET
// export function init_manufacture ; begin
26677: LD_INT 0
26679: PPUSH
// hovers_recomended := false ;
26680: LD_ADDR_LOC 59
26684: PUSH
26685: LD_INT 0
26687: ST_TO_ADDR
// flat_land := false ;
26688: LD_ADDR_LOC 60
26692: PUSH
26693: LD_INT 0
26695: ST_TO_ADDR
// sib_engine := 10 ;
26696: LD_ADDR_LOC 55
26700: PUSH
26701: LD_INT 10
26703: ST_TO_ADDR
// oil_engine := 30 ;
26704: LD_ADDR_LOC 56
26708: PUSH
26709: LD_INT 30
26711: ST_TO_ADDR
// us_weapons := [ [ [ us_machine_gun , [ ] , 0 ] , [ us_light_gun , [ tech_Gun ] , b_ext_gun ] , [ us_radar , [ tech_Radar ] , b_ext_radar ] , [ us_crane , [ ] , b_ext_noncombat ] ] , [ [ us_gatling_gun , [ tech_Gatling ] , 0 ] , [ us_double_gun , [ tech_Gun ] , b_ext_gun ] , [ us_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ us_laser , [ tech_Laser ] , b_ext_laser ] , [ us_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ us_bulldozer , [ ] , b_ext_noncombat ] , [ us_siberium_rocket , [ tech_SibEng , tech_Rocket ] , b_ext_siberium ] , [ us_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] ] ] ;
26712: LD_ADDR_LOC 52
26716: PUSH
26717: LD_INT 2
26719: PUSH
26720: EMPTY
26721: PUSH
26722: LD_INT 0
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 3
26732: PUSH
26733: LD_INT 39
26735: PUSH
26736: EMPTY
26737: LIST
26738: PUSH
26739: LD_INT 17
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 11
26749: PUSH
26750: LD_INT 6
26752: PUSH
26753: EMPTY
26754: LIST
26755: PUSH
26756: LD_INT 20
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: LIST
26763: PUSH
26764: LD_INT 13
26766: PUSH
26767: EMPTY
26768: PUSH
26769: LD_INT 19
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: LIST
26776: PUSH
26777: EMPTY
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 4
26785: PUSH
26786: LD_INT 69
26788: PUSH
26789: EMPTY
26790: LIST
26791: PUSH
26792: LD_INT 0
26794: PUSH
26795: EMPTY
26796: LIST
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 5
26802: PUSH
26803: LD_INT 39
26805: PUSH
26806: EMPTY
26807: LIST
26808: PUSH
26809: LD_INT 17
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 7
26819: PUSH
26820: LD_INT 40
26822: PUSH
26823: EMPTY
26824: LIST
26825: PUSH
26826: LD_INT 18
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: LIST
26833: PUSH
26834: LD_INT 9
26836: PUSH
26837: LD_INT 10
26839: PUSH
26840: EMPTY
26841: LIST
26842: PUSH
26843: LD_INT 25
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: LIST
26850: PUSH
26851: LD_INT 12
26853: PUSH
26854: EMPTY
26855: PUSH
26856: LD_INT 19
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: LIST
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: LIST
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 14
26873: PUSH
26874: EMPTY
26875: PUSH
26876: LD_INT 19
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: LIST
26883: PUSH
26884: LD_INT 8
26886: PUSH
26887: LD_INT 22
26889: PUSH
26890: LD_INT 40
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 21
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 6
26907: PUSH
26908: LD_INT 34
26910: PUSH
26911: EMPTY
26912: LIST
26913: PUSH
26914: LD_INT 17
26916: PUSH
26917: EMPTY
26918: LIST
26919: LIST
26920: LIST
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: LIST
26931: ST_TO_ADDR
// ar_weapons := [ [ [ ar_multimissile_ballista , [ ] , 0 ] , [ ar_double_machine_gun , [ ] , 0 ] , [ ar_light_gun , [ tech_Gun ] , b_ext_gun ] ] , [ [ ar_gatling_gun , [ tech_Gatling ] , 0 ] , [ ar_flame_thrower , [ tech_Flame ] , b_ext_stitch ] , [ ar_gun , [ tech_Gun ] , b_ext_gun ] , [ ar_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ar_selfpropelled_bomb , [ tech_Explos ] , b_ext_siberium ] , [ ar_radar , [ tech_Radar ] , b_ext_radar ] , [ ar_control_tower , [ tech_RemCont ] , b_ext_radar ] , [ ar_cargo_bay , [ ] , b_ext_stitch ] ] , [ ] ] ;
26932: LD_ADDR_LOC 53
26936: PUSH
26937: LD_INT 22
26939: PUSH
26940: EMPTY
26941: PUSH
26942: LD_INT 0
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 24
26952: PUSH
26953: EMPTY
26954: PUSH
26955: LD_INT 0
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 23
26965: PUSH
26966: LD_INT 39
26968: PUSH
26969: EMPTY
26970: LIST
26971: PUSH
26972: LD_INT 17
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: LIST
26979: PUSH
26980: EMPTY
26981: LIST
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 25
26987: PUSH
26988: LD_INT 69
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: LD_INT 0
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 26
27004: PUSH
27005: LD_INT 70
27007: PUSH
27008: EMPTY
27009: LIST
27010: PUSH
27011: LD_INT 23
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: LIST
27018: PUSH
27019: LD_INT 27
27021: PUSH
27022: LD_INT 39
27024: PUSH
27025: EMPTY
27026: LIST
27027: PUSH
27028: LD_INT 17
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 28
27038: PUSH
27039: LD_INT 40
27041: PUSH
27042: EMPTY
27043: LIST
27044: PUSH
27045: LD_INT 18
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 29
27055: PUSH
27056: LD_INT 42
27058: PUSH
27059: EMPTY
27060: LIST
27061: PUSH
27062: LD_INT 21
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 30
27072: PUSH
27073: LD_INT 6
27075: PUSH
27076: EMPTY
27077: LIST
27078: PUSH
27079: LD_INT 20
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 31
27089: PUSH
27090: LD_INT 15
27092: PUSH
27093: EMPTY
27094: LIST
27095: PUSH
27096: LD_INT 20
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: LIST
27103: PUSH
27104: LD_INT 32
27106: PUSH
27107: EMPTY
27108: PUSH
27109: LD_INT 23
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: LIST
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: LIST
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: PUSH
27127: EMPTY
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: LIST
27133: ST_TO_ADDR
// ru_weapons := [ [ ] , [ [ ru_heavy_machine_gun , [ ] , 0 ] , [ ru_gatling_gun , [ tech_Gatling ] , 0 ] , [ ru_gun , [ tech_Gun ] , b_ext_gun ] , [ ru_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ru_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ ru_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] , [ ru_rocket , [ tech_AdvRocket ] , b_ext_rocket ] , [ ru_siberium_rocket , [ tech_SibEng , tech_SibFiss ] , b_ext_siberium ] , [ ru_time_lapser , [ tech_Lapser ] , b_ext_siberium ] , [ ru_bulldozer , [ ] , b_ext_noncombat ] ] ] ;
27134: LD_ADDR_LOC 54
27138: PUSH
27139: EMPTY
27140: PUSH
27141: LD_INT 42
27143: PUSH
27144: EMPTY
27145: PUSH
27146: LD_INT 0
27148: PUSH
27149: EMPTY
27150: LIST
27151: LIST
27152: LIST
27153: PUSH
27154: LD_INT 43
27156: PUSH
27157: LD_INT 69
27159: PUSH
27160: EMPTY
27161: LIST
27162: PUSH
27163: LD_INT 0
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 44
27173: PUSH
27174: LD_INT 39
27176: PUSH
27177: EMPTY
27178: LIST
27179: PUSH
27180: LD_INT 17
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: LIST
27187: PUSH
27188: LD_INT 45
27190: PUSH
27191: LD_INT 40
27193: PUSH
27194: EMPTY
27195: LIST
27196: PUSH
27197: LD_INT 18
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 51
27207: PUSH
27208: EMPTY
27209: PUSH
27210: LD_INT 19
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: LIST
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: LIST
27222: LIST
27223: LIST
27224: PUSH
27225: LD_INT 46
27227: PUSH
27228: LD_INT 34
27230: PUSH
27231: EMPTY
27232: LIST
27233: PUSH
27234: LD_INT 17
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 47
27244: PUSH
27245: LD_INT 71
27247: PUSH
27248: EMPTY
27249: LIST
27250: PUSH
27251: LD_INT 18
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: LIST
27258: PUSH
27259: LD_INT 48
27261: PUSH
27262: LD_INT 22
27264: PUSH
27265: LD_INT 25
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 21
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: LIST
27279: PUSH
27280: LD_INT 49
27282: PUSH
27283: LD_INT 31
27285: PUSH
27286: EMPTY
27287: LIST
27288: PUSH
27289: LD_INT 21
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 53
27299: PUSH
27300: EMPTY
27301: PUSH
27302: LD_INT 19
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: LIST
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: LIST
27321: ST_TO_ADDR
// end ;
27322: LD_VAR 0 1
27326: RET
// function init_prefered_vehicles ( side_nation ) ; begin
27327: LD_INT 0
27329: PPUSH
// case side_nation of 1 :
27330: LD_VAR 0 1
27334: PUSH
27335: LD_INT 1
27337: DOUBLE
27338: EQUAL
27339: IFTRUE 27343
27341: GO 27427
27343: POP
// prefered := [ [ [ us_medium_wheeled , us_medium_wheeled , us_morphling ] [ difficulty ] , 0 , control_remote , us_laser ] , [ us_morphling , 0 , control_remote , us_heavy_gun ] , [ us_morphling , 0 , control_remote , us_rocket_launcher ] ] ; 2 :
27344: LD_ADDR_LOC 57
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: LD_INT 2
27354: PUSH
27355: LD_INT 5
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: LIST
27362: PUSH
27363: LD_OWVAR 67
27367: ARRAY
27368: PUSH
27369: LD_INT 0
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: LD_INT 9
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 5
27386: PUSH
27387: LD_INT 0
27389: PUSH
27390: LD_INT 2
27392: PUSH
27393: LD_INT 6
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: PUSH
27402: LD_INT 5
27404: PUSH
27405: LD_INT 0
27407: PUSH
27408: LD_INT 2
27410: PUSH
27411: LD_INT 7
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: LIST
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: LIST
27424: ST_TO_ADDR
27425: GO 27540
27427: LD_INT 2
27429: DOUBLE
27430: EQUAL
27431: IFTRUE 27435
27433: GO 27483
27435: POP
// prefered := [ [ ar_medium_trike , 0 , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , 0 , control_remote , ar_gun ] ] ; 3 :
27436: LD_ADDR_LOC 57
27440: PUSH
27441: LD_INT 13
27443: PUSH
27444: LD_INT 0
27446: PUSH
27447: LD_INT 2
27449: PUSH
27450: LD_INT 28
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: LIST
27457: LIST
27458: PUSH
27459: LD_INT 13
27461: PUSH
27462: LD_INT 0
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: LD_INT 27
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: LIST
27475: LIST
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: ST_TO_ADDR
27481: GO 27540
27483: LD_INT 3
27485: DOUBLE
27486: EQUAL
27487: IFTRUE 27491
27489: GO 27539
27491: POP
// prefered := [ [ 0 , engine_siberite , control_computer , ru_heavy_gun ] , [ 0 , engine_siberite , control_computer , ru_rocket ] ] ; end ;
27492: LD_ADDR_LOC 57
27496: PUSH
27497: LD_INT 0
27499: PUSH
27500: LD_INT 3
27502: PUSH
27503: LD_INT 3
27505: PUSH
27506: LD_INT 46
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 0
27517: PUSH
27518: LD_INT 3
27520: PUSH
27521: LD_INT 3
27523: PUSH
27524: LD_INT 47
27526: PUSH
27527: EMPTY
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: ST_TO_ADDR
27537: GO 27540
27539: POP
// end ;
27540: LD_VAR 0 2
27544: RET
// every 0 0$1.9 do var un , factories , active_side , active_nation , wait_timers , construction_order_given ;
27545: GO 27547
27547: DISABLE
27548: LD_INT 0
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
// begin wait_timers = [ ] ;
27556: LD_ADDR_VAR 0 5
27560: PUSH
27561: EMPTY
27562: ST_TO_ADDR
// for un = 1 to 8 do
27563: LD_ADDR_VAR 0 1
27567: PUSH
27568: DOUBLE
27569: LD_INT 1
27571: DEC
27572: ST_TO_ADDR
27573: LD_INT 8
27575: PUSH
27576: FOR_TO
27577: IFFALSE 27595
// wait_timers = wait_timers ^ 0 0$15.9 ;
27579: LD_ADDR_VAR 0 5
27583: PUSH
27584: LD_VAR 0 5
27588: PUSH
27589: LD_INT 557
27591: ADD
27592: ST_TO_ADDR
27593: GO 27576
27595: POP
27596: POP
// repeat wait ( 0 0$1 ) ;
27597: LD_INT 35
27599: PPUSH
27600: CALL_OW 67
// for active_side in cpu_list do
27604: LD_ADDR_VAR 0 3
27608: PUSH
27609: LD_EXP 8
27613: PUSH
27614: FOR_IN
27615: IFFALSE 27968
// begin if wait_timers [ active_side ] > 0 0$0 then
27617: LD_VAR 0 5
27621: PUSH
27622: LD_VAR 0 3
27626: ARRAY
27627: PUSH
27628: LD_INT 0
27630: GREATER
27631: IFFALSE 27670
// begin wait_timers = Replace ( wait_timers , active_side , wait_timers [ active_side ] - 0 0$1 ) ;
27633: LD_ADDR_VAR 0 5
27637: PUSH
27638: LD_VAR 0 5
27642: PPUSH
27643: LD_VAR 0 3
27647: PPUSH
27648: LD_VAR 0 5
27652: PUSH
27653: LD_VAR 0 3
27657: ARRAY
27658: PUSH
27659: LD_INT 35
27661: MINUS
27662: PPUSH
27663: CALL_OW 1
27667: ST_TO_ADDR
// continue ;
27668: GO 27614
// end ; if ( Get_Resources ( active_side ) [ 2 ] > 29 ) or ( Get_resources ( active_side ) [ 3 ] > 9 ) then
27670: LD_VAR 0 3
27674: PPUSH
27675: CALL 27977 0 1
27679: PUSH
27680: LD_INT 2
27682: ARRAY
27683: PUSH
27684: LD_INT 29
27686: GREATER
27687: PUSH
27688: LD_VAR 0 3
27692: PPUSH
27693: CALL 27977 0 1
27697: PUSH
27698: LD_INT 3
27700: ARRAY
27701: PUSH
27702: LD_INT 9
27704: GREATER
27705: OR
27706: IFFALSE 27966
// begin case active_side of us :
27708: LD_VAR 0 3
27712: PUSH
27713: LD_EXP 3
27717: DOUBLE
27718: EQUAL
27719: IFTRUE 27723
27721: GO 27734
27723: POP
// if us_sib_wait then
27724: LD_EXP 74
27728: IFFALSE 27732
// continue ; ru :
27730: GO 27614
27732: GO 27756
27734: LD_EXP 2
27738: DOUBLE
27739: EQUAL
27740: IFTRUE 27744
27742: GO 27755
27744: POP
// if ru_sib_wait then
27745: LD_EXP 75
27749: IFFALSE 27753
// continue ; end ;
27751: GO 27614
27753: GO 27756
27755: POP
// factories := FilterAllUnits ( [ [ f_side , active_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
27756: LD_ADDR_VAR 0 2
27760: PUSH
27761: LD_INT 22
27763: PUSH
27764: LD_VAR 0 3
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 2
27775: PUSH
27776: LD_INT 30
27778: PUSH
27779: LD_INT 2
27781: PUSH
27782: EMPTY
27783: LIST
27784: LIST
27785: PUSH
27786: LD_INT 30
27788: PUSH
27789: LD_INT 3
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: LIST
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PPUSH
27805: CALL_OW 69
27809: ST_TO_ADDR
// if factories = 0 then
27810: LD_VAR 0 2
27814: PUSH
27815: LD_INT 0
27817: EQUAL
27818: IFFALSE 27822
// continue ;
27820: GO 27614
// un = factories [ 1 ] ;
27822: LD_ADDR_VAR 0 1
27826: PUSH
27827: LD_VAR 0 2
27831: PUSH
27832: LD_INT 1
27834: ARRAY
27835: ST_TO_ADDR
// active_nation := GetCPUNation ( active_side ) ;
27836: LD_ADDR_VAR 0 4
27840: PUSH
27841: LD_VAR 0 3
27845: PPUSH
27846: CALL 26450 0 1
27850: ST_TO_ADDR
// init_priority ( active_side , active_nation ) ;
27851: LD_VAR 0 3
27855: PPUSH
27856: LD_VAR 0 4
27860: PPUSH
27861: CALL 26530 0 2
// init_prefered_vehicles ( active_nation ) ;
27865: LD_VAR 0 4
27869: PPUSH
27870: CALL 27327 0 1
// if not BuildingStatus ( un ) = bs_working then
27874: LD_VAR 0 1
27878: PPUSH
27879: CALL_OW 461
27883: PUSH
27884: LD_INT 3
27886: EQUAL
27887: NOT
27888: IFFALSE 27966
// begin construction_order_given = build_new_vehicle ( active_side , active_nation , un ) ;
27890: LD_ADDR_VAR 0 6
27894: PUSH
27895: LD_VAR 0 3
27899: PPUSH
27900: LD_VAR 0 4
27904: PPUSH
27905: LD_VAR 0 1
27909: PPUSH
27910: CALL 28095 0 3
27914: ST_TO_ADDR
// if construction_order_given then
27915: LD_VAR 0 6
27919: IFFALSE 27966
// begin wait ( 10 ) ;
27921: LD_INT 10
27923: PPUSH
27924: CALL_OW 67
// if BuildingStatus ( un ) = bs_working then
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 461
27937: PUSH
27938: LD_INT 3
27940: EQUAL
27941: IFFALSE 27966
// wait_timers = Replace ( wait_timers , active_side , 0 0$15.9 ) ;
27943: LD_ADDR_VAR 0 5
27947: PUSH
27948: LD_VAR 0 5
27952: PPUSH
27953: LD_VAR 0 3
27957: PPUSH
27958: LD_INT 557
27960: PPUSH
27961: CALL_OW 1
27965: ST_TO_ADDR
// end ; end ; end ; end ;
27966: GO 27614
27968: POP
27969: POP
// until false ;
27970: LD_INT 0
27972: IFFALSE 27597
// end ;
27974: PPOPN 6
27976: END
// function Get_Resources ( side ) ; var depots ; begin
27977: LD_INT 0
27979: PPUSH
27980: PPUSH
// depots = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27981: LD_ADDR_VAR 0 3
27985: PUSH
27986: LD_INT 22
27988: PUSH
27989: LD_VAR 0 1
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 30
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 30
28013: PUSH
28014: LD_INT 1
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PPUSH
28030: CALL_OW 69
28034: ST_TO_ADDR
// if depots > 0 then
28035: LD_VAR 0 3
28039: PUSH
28040: LD_INT 0
28042: GREATER
28043: IFFALSE 28071
// result := GetResources ( GetBase ( depots [ 1 ] ) ) else
28045: LD_ADDR_VAR 0 2
28049: PUSH
28050: LD_VAR 0 3
28054: PUSH
28055: LD_INT 1
28057: ARRAY
28058: PPUSH
28059: CALL_OW 274
28063: PPUSH
28064: CALL_OW 279
28068: ST_TO_ADDR
28069: GO 28090
// result = [ 0 , 0 , 0 ] ;
28071: LD_ADDR_VAR 0 2
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: LD_INT 0
28081: PUSH
28082: LD_INT 0
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: ST_TO_ADDR
// end ;
28090: LD_VAR 0 2
28094: RET
// function build_new_vehicle ( side , nation , factory ) ; var can_made , mechanics , wanted ; begin
28095: LD_INT 0
28097: PPUSH
28098: PPUSH
28099: PPUSH
28100: PPUSH
// result = false ;
28101: LD_ADDR_VAR 0 4
28105: PUSH
28106: LD_INT 0
28108: ST_TO_ADDR
// mechanics := request_people ( side , class_mechanic , 1 ) ;
28109: LD_ADDR_VAR 0 6
28113: PUSH
28114: LD_VAR 0 1
28118: PPUSH
28119: LD_INT 3
28121: PPUSH
28122: LD_INT 1
28124: PPUSH
28125: CALL 26382 0 3
28129: ST_TO_ADDR
// can_made := get_progress ( side , nation , factory ) ;
28130: LD_ADDR_VAR 0 5
28134: PUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: LD_VAR 0 2
28144: PPUSH
28145: LD_VAR 0 3
28149: PPUSH
28150: CALL 28266 0 3
28154: ST_TO_ADDR
// if can_made then
28155: LD_VAR 0 5
28159: IFFALSE 28242
// begin wanted := get_next_vehicle ( side , nation , factory , can_made ) ;
28161: LD_ADDR_VAR 0 7
28165: PUSH
28166: LD_VAR 0 1
28170: PPUSH
28171: LD_VAR 0 2
28175: PPUSH
28176: LD_VAR 0 3
28180: PPUSH
28181: LD_VAR 0 5
28185: PPUSH
28186: CALL 28745 0 4
28190: ST_TO_ADDR
// if transfer_mechanics ( side , mechanics , factory , wanted ) then
28191: LD_VAR 0 1
28195: PPUSH
28196: LD_VAR 0 6
28200: PPUSH
28201: LD_VAR 0 3
28205: PPUSH
28206: LD_VAR 0 7
28210: PPUSH
28211: CALL 31214 0 4
28215: IFFALSE 28242
// result = start_building_vehicle ( nation , factory , wanted ) ;
28217: LD_ADDR_VAR 0 4
28221: PUSH
28222: LD_VAR 0 2
28226: PPUSH
28227: LD_VAR 0 3
28231: PPUSH
28232: LD_VAR 0 7
28236: PPUSH
28237: CALL 31646 0 3
28241: ST_TO_ADDR
// end ; cleanup_extensions ( side , nation , factory ) ;
28242: LD_VAR 0 1
28246: PPUSH
28247: LD_VAR 0 2
28251: PPUSH
28252: LD_VAR 0 3
28256: PPUSH
28257: CALL 31880 0 3
// end ;
28261: LD_VAR 0 4
28265: RET
// function get_progress ( side , nation , factory ) ; var vysledek , chassis , weapon , list ; begin
28266: LD_INT 0
28268: PPUSH
28269: PPUSH
28270: PPUSH
28271: PPUSH
28272: PPUSH
// vysledek := [ ] ;
28273: LD_ADDR_VAR 0 5
28277: PUSH
28278: EMPTY
28279: ST_TO_ADDR
// list := [ ] ;
28280: LD_ADDR_VAR 0 8
28284: PUSH
28285: EMPTY
28286: ST_TO_ADDR
// case nation of 1 :
28287: LD_VAR 0 2
28291: PUSH
28292: LD_INT 1
28294: DOUBLE
28295: EQUAL
28296: IFTRUE 28300
28298: GO 28313
28300: POP
// list := us_weapons ; 2 :
28301: LD_ADDR_VAR 0 8
28305: PUSH
28306: LD_LOC 52
28310: ST_TO_ADDR
28311: GO 28356
28313: LD_INT 2
28315: DOUBLE
28316: EQUAL
28317: IFTRUE 28321
28319: GO 28334
28321: POP
// list := ar_weapons ; 3 :
28322: LD_ADDR_VAR 0 8
28326: PUSH
28327: LD_LOC 53
28331: ST_TO_ADDR
28332: GO 28356
28334: LD_INT 3
28336: DOUBLE
28337: EQUAL
28338: IFTRUE 28342
28340: GO 28355
28342: POP
// list := ru_weapons ; end ;
28343: LD_ADDR_VAR 0 8
28347: PUSH
28348: LD_LOC 54
28352: ST_TO_ADDR
28353: GO 28356
28355: POP
// for chassis = 1 to 3 do
28356: LD_ADDR_VAR 0 6
28360: PUSH
28361: DOUBLE
28362: LD_INT 1
28364: DEC
28365: ST_TO_ADDR
28366: LD_INT 3
28368: PUSH
28369: FOR_TO
28370: IFFALSE 28532
// if ( chassis < 3 ) or ( nation = nation_russian ) or ( TrackExtension ( factory ) ) then
28372: LD_VAR 0 6
28376: PUSH
28377: LD_INT 3
28379: LESS
28380: PUSH
28381: LD_VAR 0 2
28385: PUSH
28386: LD_INT 3
28388: EQUAL
28389: OR
28390: PUSH
28391: LD_VAR 0 3
28395: PPUSH
28396: CALL 29440 0 1
28400: OR
28401: IFFALSE 28530
// for weapon in list [ chassis ] do
28403: LD_ADDR_VAR 0 7
28407: PUSH
28408: LD_VAR 0 8
28412: PUSH
28413: LD_VAR 0 6
28417: ARRAY
28418: PUSH
28419: FOR_IN
28420: IFFALSE 28528
// if Technology_Researched ( side , weapon [ 2 ] ) or not weapon [ 2 ] then
28422: LD_VAR 0 1
28426: PPUSH
28427: LD_VAR 0 7
28431: PUSH
28432: LD_INT 2
28434: ARRAY
28435: PPUSH
28436: CALL 28549 0 2
28440: PUSH
28441: LD_VAR 0 7
28445: PUSH
28446: LD_INT 2
28448: ARRAY
28449: NOT
28450: OR
28451: IFFALSE 28526
// begin if ExtensionBuild ( factory , weapon [ 3 ] ) or not weapon [ 3 ] then
28453: LD_VAR 0 3
28457: PPUSH
28458: LD_VAR 0 7
28462: PUSH
28463: LD_INT 3
28465: ARRAY
28466: PPUSH
28467: CALL 28619 0 2
28471: PUSH
28472: LD_VAR 0 7
28476: PUSH
28477: LD_INT 3
28479: ARRAY
28480: NOT
28481: OR
28482: IFFALSE 28506
// vysledek := vysledek ^ weapon [ 1 ] else
28484: LD_ADDR_VAR 0 5
28488: PUSH
28489: LD_VAR 0 5
28493: PUSH
28494: LD_VAR 0 7
28498: PUSH
28499: LD_INT 1
28501: ARRAY
28502: ADD
28503: ST_TO_ADDR
28504: GO 28526
// extension_wanted := extension_wanted ^ weapon [ 3 ] ;
28506: LD_ADDR_EXP 73
28510: PUSH
28511: LD_EXP 73
28515: PUSH
28516: LD_VAR 0 7
28520: PUSH
28521: LD_INT 3
28523: ARRAY
28524: ADD
28525: ST_TO_ADDR
// end ;
28526: GO 28419
28528: POP
28529: POP
28530: GO 28369
28532: POP
28533: POP
// result := vysledek ;
28534: LD_ADDR_VAR 0 4
28538: PUSH
28539: LD_VAR 0 5
28543: ST_TO_ADDR
// end ;
28544: LD_VAR 0 4
28548: RET
// function Technology_Researched ( side , list ) ; var tech , vysledek ; begin
28549: LD_INT 0
28551: PPUSH
28552: PPUSH
28553: PPUSH
// vysledek := true ;
28554: LD_ADDR_VAR 0 5
28558: PUSH
28559: LD_INT 1
28561: ST_TO_ADDR
// for tech in list do
28562: LD_ADDR_VAR 0 4
28566: PUSH
28567: LD_VAR 0 2
28571: PUSH
28572: FOR_IN
28573: IFFALSE 28602
// if not Researched ( side , tech ) then
28575: LD_VAR 0 1
28579: PPUSH
28580: LD_VAR 0 4
28584: PPUSH
28585: CALL_OW 325
28589: NOT
28590: IFFALSE 28600
// vysledek := false ;
28592: LD_ADDR_VAR 0 5
28596: PUSH
28597: LD_INT 0
28599: ST_TO_ADDR
28600: GO 28572
28602: POP
28603: POP
// result := vysledek ;
28604: LD_ADDR_VAR 0 3
28608: PUSH
28609: LD_VAR 0 5
28613: ST_TO_ADDR
// end ;
28614: LD_VAR 0 3
28618: RET
// function ExtensionBuild ( factory , extension ) ; var i , vysledek , list ; begin
28619: LD_INT 0
28621: PPUSH
28622: PPUSH
28623: PPUSH
28624: PPUSH
// vysledek := false ;
28625: LD_ADDR_VAR 0 5
28629: PUSH
28630: LD_INT 0
28632: ST_TO_ADDR
// if extension > 0 then
28633: LD_VAR 0 2
28637: PUSH
28638: LD_INT 0
28640: GREATER
28641: IFFALSE 28722
// begin list := GetExtPositions ( factory ) ;
28643: LD_ADDR_VAR 0 6
28647: PUSH
28648: LD_VAR 0 1
28652: PPUSH
28653: CALL_OW 270
28657: ST_TO_ADDR
// for i in list do
28658: LD_ADDR_VAR 0 4
28662: PUSH
28663: LD_VAR 0 6
28667: PUSH
28668: FOR_IN
28669: IFFALSE 28718
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = extension then
28671: LD_VAR 0 4
28675: PUSH
28676: LD_INT 1
28678: ARRAY
28679: PPUSH
28680: LD_VAR 0 4
28684: PUSH
28685: LD_INT 2
28687: ARRAY
28688: PPUSH
28689: CALL_OW 428
28693: PPUSH
28694: CALL_OW 266
28698: PUSH
28699: LD_VAR 0 2
28703: EQUAL
28704: IFFALSE 28716
// begin vysledek := true ;
28706: LD_ADDR_VAR 0 5
28710: PUSH
28711: LD_INT 1
28713: ST_TO_ADDR
// break ;
28714: GO 28718
// end ;
28716: GO 28668
28718: POP
28719: POP
// end else
28720: GO 28730
// vysledek := true ;
28722: LD_ADDR_VAR 0 5
28726: PUSH
28727: LD_INT 1
28729: ST_TO_ADDR
// result := vysledek ;
28730: LD_ADDR_VAR 0 3
28734: PUSH
28735: LD_VAR 0 5
28739: ST_TO_ADDR
// end ;
28740: LD_VAR 0 3
28744: RET
// function get_next_vehicle ( side , nation , factory , possible ) ; var un , pom , list , cargo_bay , crane , nation_cargo , nation_crane , weapon_prefered , weapon_else , vysledek ; begin
28745: LD_INT 0
28747: PPUSH
28748: PPUSH
28749: PPUSH
28750: PPUSH
28751: PPUSH
28752: PPUSH
28753: PPUSH
28754: PPUSH
28755: PPUSH
28756: PPUSH
28757: PPUSH
// vysledek := [ ] ;
28758: LD_ADDR_VAR 0 15
28762: PUSH
28763: EMPTY
28764: ST_TO_ADDR
// case nation of 1 :
28765: LD_VAR 0 2
28769: PUSH
28770: LD_INT 1
28772: DOUBLE
28773: EQUAL
28774: IFTRUE 28778
28776: GO 28807
28778: POP
// begin list := us_weapons ;
28779: LD_ADDR_VAR 0 8
28783: PUSH
28784: LD_LOC 52
28788: ST_TO_ADDR
// nation_cargo := us_cargo_bay ;
28789: LD_ADDR_VAR 0 11
28793: PUSH
28794: LD_INT 12
28796: ST_TO_ADDR
// nation_crane := us_crane ;
28797: LD_ADDR_VAR 0 12
28801: PUSH
28802: LD_INT 13
28804: ST_TO_ADDR
// end ; 2 :
28805: GO 28882
28807: LD_INT 2
28809: DOUBLE
28810: EQUAL
28811: IFTRUE 28815
28813: GO 28844
28815: POP
// begin list := ar_weapons ;
28816: LD_ADDR_VAR 0 8
28820: PUSH
28821: LD_LOC 53
28825: ST_TO_ADDR
// nation_cargo := ar_cargo_bay ;
28826: LD_ADDR_VAR 0 11
28830: PUSH
28831: LD_INT 32
28833: ST_TO_ADDR
// nation_crane := 0 ;
28834: LD_ADDR_VAR 0 12
28838: PUSH
28839: LD_INT 0
28841: ST_TO_ADDR
// end ; 3 :
28842: GO 28882
28844: LD_INT 3
28846: DOUBLE
28847: EQUAL
28848: IFTRUE 28852
28850: GO 28881
28852: POP
// begin list := ru_weapons ;
28853: LD_ADDR_VAR 0 8
28857: PUSH
28858: LD_LOC 54
28862: ST_TO_ADDR
// nation_cargo := ru_cargo_bay ;
28863: LD_ADDR_VAR 0 11
28867: PUSH
28868: LD_INT 51
28870: ST_TO_ADDR
// nation_crane := ru_crane ;
28871: LD_ADDR_VAR 0 12
28875: PUSH
28876: LD_INT 52
28878: ST_TO_ADDR
// end ; end ;
28879: GO 28882
28881: POP
// pom := AvailableWeaponList ( factory ) ;
28882: LD_ADDR_VAR 0 7
28886: PUSH
28887: LD_VAR 0 3
28891: PPUSH
28892: CALL_OW 478
28896: ST_TO_ADDR
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
28897: LD_ADDR_VAR 0 9
28901: PUSH
28902: LD_INT 22
28904: PUSH
28905: LD_VAR 0 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 21
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 34
28926: PUSH
28927: LD_VAR 0 11
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: LIST
28940: PPUSH
28941: CALL_OW 69
28945: ST_TO_ADDR
// if ( not cargo_bay ) and ( nation_cargo in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
28946: LD_VAR 0 9
28950: NOT
28951: PUSH
28952: LD_VAR 0 11
28956: PUSH
28957: LD_VAR 0 7
28961: IN
28962: AND
28963: PUSH
28964: LD_VAR 0 3
28968: PPUSH
28969: CALL 29377 0 1
28973: AND
28974: PUSH
28975: LD_VAR 0 3
28979: PPUSH
28980: CALL 29440 0 1
28984: AND
28985: IFFALSE 29019
// vysledek := Define_NonCombat ( side , nation , factory , nation_cargo ) else
28987: LD_ADDR_VAR 0 15
28991: PUSH
28992: LD_VAR 0 1
28996: PPUSH
28997: LD_VAR 0 2
29001: PPUSH
29002: LD_VAR 0 3
29006: PPUSH
29007: LD_VAR 0 11
29011: PPUSH
29012: CALL 29466 0 4
29016: ST_TO_ADDR
29017: GO 29035
// possible := possible diff nation_cargo ;
29019: LD_ADDR_VAR 0 4
29023: PUSH
29024: LD_VAR 0 4
29028: PUSH
29029: LD_VAR 0 11
29033: DIFF
29034: ST_TO_ADDR
// if not vysledek then
29035: LD_VAR 0 15
29039: NOT
29040: IFFALSE 29180
// begin crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
29042: LD_ADDR_VAR 0 10
29046: PUSH
29047: LD_INT 22
29049: PUSH
29050: LD_VAR 0 1
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 21
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: EMPTY
29066: LIST
29067: LIST
29068: PUSH
29069: LD_INT 34
29071: PUSH
29072: LD_VAR 0 12
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: LIST
29085: PPUSH
29086: CALL_OW 69
29090: ST_TO_ADDR
// if ( not crane ) and ( nation_crane in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29091: LD_VAR 0 10
29095: NOT
29096: PUSH
29097: LD_VAR 0 12
29101: PUSH
29102: LD_VAR 0 7
29106: IN
29107: AND
29108: PUSH
29109: LD_VAR 0 3
29113: PPUSH
29114: CALL 29377 0 1
29118: AND
29119: PUSH
29120: LD_VAR 0 3
29124: PPUSH
29125: CALL 29440 0 1
29129: AND
29130: IFFALSE 29164
// vysledek := Define_NonCombat ( side , nation , factory , nation_crane ) else
29132: LD_ADDR_VAR 0 15
29136: PUSH
29137: LD_VAR 0 1
29141: PPUSH
29142: LD_VAR 0 2
29146: PPUSH
29147: LD_VAR 0 3
29151: PPUSH
29152: LD_VAR 0 12
29156: PPUSH
29157: CALL 29466 0 4
29161: ST_TO_ADDR
29162: GO 29180
// possible := possible diff nation_crane ;
29164: LD_ADDR_VAR 0 4
29168: PUSH
29169: LD_VAR 0 4
29173: PUSH
29174: LD_VAR 0 12
29178: DIFF
29179: ST_TO_ADDR
// end ; if not vysledek then
29180: LD_VAR 0 15
29184: NOT
29185: IFFALSE 29362
// begin weapon_prefered := [ ] ;
29187: LD_ADDR_VAR 0 13
29191: PUSH
29192: EMPTY
29193: ST_TO_ADDR
// weapon_else := 0 ;
29194: LD_ADDR_VAR 0 14
29198: PUSH
29199: LD_INT 0
29201: ST_TO_ADDR
// for un in prefered do
29202: LD_ADDR_VAR 0 6
29206: PUSH
29207: LD_LOC 57
29211: PUSH
29212: FOR_IN
29213: IFFALSE 29252
// if ( un [ 4 ] in possible ) then
29215: LD_VAR 0 6
29219: PUSH
29220: LD_INT 4
29222: ARRAY
29223: PUSH
29224: LD_VAR 0 4
29228: IN
29229: IFFALSE 29250
// weapon_prefered := weapon_prefered ^ [ un ] ;
29231: LD_ADDR_VAR 0 13
29235: PUSH
29236: LD_VAR 0 13
29240: PUSH
29241: LD_VAR 0 6
29245: PUSH
29246: EMPTY
29247: LIST
29248: ADD
29249: ST_TO_ADDR
29250: GO 29212
29252: POP
29253: POP
// if not weapon_prefered then
29254: LD_VAR 0 13
29258: NOT
29259: IFFALSE 29332
// begin for un in possible do
29261: LD_ADDR_VAR 0 6
29265: PUSH
29266: LD_VAR 0 4
29270: PUSH
29271: FOR_IN
29272: IFFALSE 29298
// if un > weapon_else then
29274: LD_VAR 0 6
29278: PUSH
29279: LD_VAR 0 14
29283: GREATER
29284: IFFALSE 29296
// weapon_else := un ;
29286: LD_ADDR_VAR 0 14
29290: PUSH
29291: LD_VAR 0 6
29295: ST_TO_ADDR
29296: GO 29271
29298: POP
29299: POP
// vysledek := Define_Vehicle ( side , nation , factory , weapon_else ) ;
29300: LD_ADDR_VAR 0 15
29304: PUSH
29305: LD_VAR 0 1
29309: PPUSH
29310: LD_VAR 0 2
29314: PPUSH
29315: LD_VAR 0 3
29319: PPUSH
29320: LD_VAR 0 14
29324: PPUSH
29325: CALL 30266 0 4
29329: ST_TO_ADDR
// end else
29330: GO 29362
// vysledek := Select_from_Prefered ( side , nation , factory , weapon_prefered ) ;
29332: LD_ADDR_VAR 0 15
29336: PUSH
29337: LD_VAR 0 1
29341: PPUSH
29342: LD_VAR 0 2
29346: PPUSH
29347: LD_VAR 0 3
29351: PPUSH
29352: LD_VAR 0 13
29356: PPUSH
29357: CALL 29738 0 4
29361: ST_TO_ADDR
// end ; result := vysledek ;
29362: LD_ADDR_VAR 0 5
29366: PUSH
29367: LD_VAR 0 15
29371: ST_TO_ADDR
// end ;
29372: LD_VAR 0 5
29376: RET
// function Remote_or_Computer ( factory ) ; var vysledek ; begin
29377: LD_INT 0
29379: PPUSH
29380: PPUSH
// vysledek := false ;
29381: LD_ADDR_VAR 0 3
29385: PUSH
29386: LD_INT 0
29388: ST_TO_ADDR
// if ExtensionBuild ( factory , b_ext_computer ) or ExtensionBuild ( factory , b_ext_radar ) then
29389: LD_VAR 0 1
29393: PPUSH
29394: LD_INT 24
29396: PPUSH
29397: CALL 28619 0 2
29401: PUSH
29402: LD_VAR 0 1
29406: PPUSH
29407: LD_INT 20
29409: PPUSH
29410: CALL 28619 0 2
29414: OR
29415: IFFALSE 29425
// vysledek := true ;
29417: LD_ADDR_VAR 0 3
29421: PUSH
29422: LD_INT 1
29424: ST_TO_ADDR
// result := vysledek ;
29425: LD_ADDR_VAR 0 2
29429: PUSH
29430: LD_VAR 0 3
29434: ST_TO_ADDR
// end ;
29435: LD_VAR 0 2
29439: RET
// function TrackExtension ( factory ) ; begin
29440: LD_INT 0
29442: PPUSH
// result := ExtensionBuild ( factory , b_ext_track ) ;
29443: LD_ADDR_VAR 0 2
29447: PUSH
29448: LD_VAR 0 1
29452: PPUSH
29453: LD_INT 16
29455: PPUSH
29456: CALL 28619 0 2
29460: ST_TO_ADDR
// end ;
29461: LD_VAR 0 2
29465: RET
// function Define_NonCombat ( side , nation , factory , weapon ) ; var components ; begin
29466: LD_INT 0
29468: PPUSH
29469: PPUSH
// components := [ ] ;
29470: LD_ADDR_VAR 0 6
29474: PUSH
29475: EMPTY
29476: ST_TO_ADDR
// case nation of 1 :
29477: LD_VAR 0 2
29481: PUSH
29482: LD_INT 1
29484: DOUBLE
29485: EQUAL
29486: IFTRUE 29490
29488: GO 29507
29490: POP
// components := components ^ us_medium_tracked ; 2 :
29491: LD_ADDR_VAR 0 6
29495: PUSH
29496: LD_VAR 0 6
29500: PUSH
29501: LD_INT 3
29503: ADD
29504: ST_TO_ADDR
29505: GO 29558
29507: LD_INT 2
29509: DOUBLE
29510: EQUAL
29511: IFTRUE 29515
29513: GO 29532
29515: POP
// components := components ^ ar_half_tracked ; 3 :
29516: LD_ADDR_VAR 0 6
29520: PUSH
29521: LD_VAR 0 6
29525: PUSH
29526: LD_INT 14
29528: ADD
29529: ST_TO_ADDR
29530: GO 29558
29532: LD_INT 3
29534: DOUBLE
29535: EQUAL
29536: IFTRUE 29540
29538: GO 29557
29540: POP
// components := components ^ ru_medium_tracked ; end ;
29541: LD_ADDR_VAR 0 6
29545: PUSH
29546: LD_VAR 0 6
29550: PUSH
29551: LD_INT 22
29553: ADD
29554: ST_TO_ADDR
29555: GO 29558
29557: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
29558: LD_VAR 0 3
29562: PPUSH
29563: LD_INT 21
29565: PPUSH
29566: CALL 28619 0 2
29570: PUSH
29571: LD_VAR 0 1
29575: PPUSH
29576: CALL 27977 0 1
29580: PUSH
29581: LD_INT 3
29583: ARRAY
29584: PUSH
29585: LD_LOC 55
29589: GREATEREQUAL
29590: AND
29591: IFFALSE 29609
// components := components ^ engine_siberite else
29593: LD_ADDR_VAR 0 6
29597: PUSH
29598: LD_VAR 0 6
29602: PUSH
29603: LD_INT 3
29605: ADD
29606: ST_TO_ADDR
29607: GO 29623
// components := components ^ engine_combustion ;
29609: LD_ADDR_VAR 0 6
29613: PUSH
29614: LD_VAR 0 6
29618: PUSH
29619: LD_INT 1
29621: ADD
29622: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
29623: LD_VAR 0 2
29627: PUSH
29628: LD_INT 2
29630: EQUAL
29631: PUSH
29632: LD_VAR 0 1
29636: PPUSH
29637: CALL 31151 0 1
29641: AND
29642: IFFALSE 29660
// components := components ^ control_apeman else
29644: LD_ADDR_VAR 0 6
29648: PUSH
29649: LD_VAR 0 6
29653: PUSH
29654: LD_INT 5
29656: ADD
29657: ST_TO_ADDR
29658: GO 29704
// if ExtensionBuild ( factory , b_ext_computer ) then
29660: LD_VAR 0 3
29664: PPUSH
29665: LD_INT 24
29667: PPUSH
29668: CALL 28619 0 2
29672: IFFALSE 29690
// components := components ^ control_computer else
29674: LD_ADDR_VAR 0 6
29678: PUSH
29679: LD_VAR 0 6
29683: PUSH
29684: LD_INT 3
29686: ADD
29687: ST_TO_ADDR
29688: GO 29704
// components := components ^ control_remote ;
29690: LD_ADDR_VAR 0 6
29694: PUSH
29695: LD_VAR 0 6
29699: PUSH
29700: LD_INT 2
29702: ADD
29703: ST_TO_ADDR
// components := components ^ [ weapon ] ;
29704: LD_ADDR_VAR 0 6
29708: PUSH
29709: LD_VAR 0 6
29713: PUSH
29714: LD_VAR 0 4
29718: PUSH
29719: EMPTY
29720: LIST
29721: ADD
29722: ST_TO_ADDR
// result := components ;
29723: LD_ADDR_VAR 0 5
29727: PUSH
29728: LD_VAR 0 6
29732: ST_TO_ADDR
// end ;
29733: LD_VAR 0 5
29737: RET
// function Select_from_Prefered ( side , nation , factory , possible ) ; var un , i , count , components , controls , vysledek ; begin
29738: LD_INT 0
29740: PPUSH
29741: PPUSH
29742: PPUSH
29743: PPUSH
29744: PPUSH
29745: PPUSH
29746: PPUSH
// count := [ - 1 , 0 ] ;
29747: LD_ADDR_VAR 0 8
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: ST_TO_ADDR
// for un in possible do
29763: LD_ADDR_VAR 0 6
29767: PUSH
29768: LD_VAR 0 4
29772: PUSH
29773: FOR_IN
29774: IFFALSE 29873
// begin i := 0 + FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , un [ 4 ] ] ] ) ;
29776: LD_ADDR_VAR 0 7
29780: PUSH
29781: LD_INT 0
29783: PUSH
29784: LD_INT 22
29786: PUSH
29787: LD_VAR 0 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 34
29798: PUSH
29799: LD_VAR 0 6
29803: PUSH
29804: LD_INT 4
29806: ARRAY
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PPUSH
29816: CALL_OW 69
29820: PLUS
29821: ST_TO_ADDR
// if ( count [ 1 ] < 0 ) or ( count [ 1 ] > i ) then
29822: LD_VAR 0 8
29826: PUSH
29827: LD_INT 1
29829: ARRAY
29830: PUSH
29831: LD_INT 0
29833: LESS
29834: PUSH
29835: LD_VAR 0 8
29839: PUSH
29840: LD_INT 1
29842: ARRAY
29843: PUSH
29844: LD_VAR 0 7
29848: GREATER
29849: OR
29850: IFFALSE 29871
// count := [ i , un ] ;
29852: LD_ADDR_VAR 0 8
29856: PUSH
29857: LD_VAR 0 7
29861: PUSH
29862: LD_VAR 0 6
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: ST_TO_ADDR
// end ;
29871: GO 29773
29873: POP
29874: POP
// un := count [ 2 ] ;
29875: LD_ADDR_VAR 0 6
29879: PUSH
29880: LD_VAR 0 8
29884: PUSH
29885: LD_INT 2
29887: ARRAY
29888: ST_TO_ADDR
// components := [ ] ;
29889: LD_ADDR_VAR 0 9
29893: PUSH
29894: EMPTY
29895: ST_TO_ADDR
// controls := AvailableControlList ( factory ) ;
29896: LD_ADDR_VAR 0 10
29900: PUSH
29901: LD_VAR 0 3
29905: PPUSH
29906: CALL_OW 477
29910: ST_TO_ADDR
// if un [ 1 ] in AvailableChassisList ( factory ) then
29911: LD_VAR 0 6
29915: PUSH
29916: LD_INT 1
29918: ARRAY
29919: PUSH
29920: LD_VAR 0 3
29924: PPUSH
29925: CALL_OW 475
29929: IN
29930: IFFALSE 29954
// components := components ^ un [ 1 ] else
29932: LD_ADDR_VAR 0 9
29936: PUSH
29937: LD_VAR 0 9
29941: PUSH
29942: LD_VAR 0 6
29946: PUSH
29947: LD_INT 1
29949: ARRAY
29950: ADD
29951: ST_TO_ADDR
29952: GO 30004
// components := components ^ SelectChassis ( side , nation , factory , ChassisWeight ( nation , un [ 4 ] ) ) ;
29954: LD_ADDR_VAR 0 9
29958: PUSH
29959: LD_VAR 0 9
29963: PUSH
29964: LD_VAR 0 1
29968: PPUSH
29969: LD_VAR 0 2
29973: PPUSH
29974: LD_VAR 0 3
29978: PPUSH
29979: LD_VAR 0 2
29983: PPUSH
29984: LD_VAR 0 6
29988: PUSH
29989: LD_INT 4
29991: ARRAY
29992: PPUSH
29993: CALL 30974 0 2
29997: PPUSH
29998: CALL 30608 0 4
30002: ADD
30003: ST_TO_ADDR
// if un [ 2 ] in AvailableEngineList ( factory ) then
30004: LD_VAR 0 6
30008: PUSH
30009: LD_INT 2
30011: ARRAY
30012: PUSH
30013: LD_VAR 0 3
30017: PPUSH
30018: CALL_OW 476
30022: IN
30023: IFFALSE 30047
// components := components ^ un [ 2 ] else
30025: LD_ADDR_VAR 0 9
30029: PUSH
30030: LD_VAR 0 9
30034: PUSH
30035: LD_VAR 0 6
30039: PUSH
30040: LD_INT 2
30042: ARRAY
30043: ADD
30044: ST_TO_ADDR
30045: GO 30122
// if ( not components [ 1 ] in [ us_light_wheeled , ar_hovercraft , ar_light_trike ] ) and ( Get_Resources ( side ) [ 3 ] > 9 ) then
30047: LD_VAR 0 9
30051: PUSH
30052: LD_INT 1
30054: ARRAY
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 11
30061: PUSH
30062: LD_INT 12
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: LIST
30069: IN
30070: NOT
30071: PUSH
30072: LD_VAR 0 1
30076: PPUSH
30077: CALL 27977 0 1
30081: PUSH
30082: LD_INT 3
30084: ARRAY
30085: PUSH
30086: LD_INT 9
30088: GREATER
30089: AND
30090: IFFALSE 30108
// components := components ^ engine_siberite else
30092: LD_ADDR_VAR 0 9
30096: PUSH
30097: LD_VAR 0 9
30101: PUSH
30102: LD_INT 3
30104: ADD
30105: ST_TO_ADDR
30106: GO 30122
// components := components ^ engine_combustion ;
30108: LD_ADDR_VAR 0 9
30112: PUSH
30113: LD_VAR 0 9
30117: PUSH
30118: LD_INT 1
30120: ADD
30121: ST_TO_ADDR
// if un [ 3 ] in AvailableControlList ( factory ) then
30122: LD_VAR 0 6
30126: PUSH
30127: LD_INT 3
30129: ARRAY
30130: PUSH
30131: LD_VAR 0 3
30135: PPUSH
30136: CALL_OW 477
30140: IN
30141: IFFALSE 30165
// components := components ^ un [ 3 ] else
30143: LD_ADDR_VAR 0 9
30147: PUSH
30148: LD_VAR 0 9
30152: PUSH
30153: LD_VAR 0 6
30157: PUSH
30158: LD_INT 3
30160: ARRAY
30161: ADD
30162: ST_TO_ADDR
30163: GO 30231
// begin if control_remote in controls then
30165: LD_INT 2
30167: PUSH
30168: LD_VAR 0 10
30172: IN
30173: IFFALSE 30191
// components := components ^ control_remote else
30175: LD_ADDR_VAR 0 9
30179: PUSH
30180: LD_VAR 0 9
30184: PUSH
30185: LD_INT 2
30187: ADD
30188: ST_TO_ADDR
30189: GO 30231
// if control_computer in controls then
30191: LD_INT 3
30193: PUSH
30194: LD_VAR 0 10
30198: IN
30199: IFFALSE 30217
// components := components ^ control_computer else
30201: LD_ADDR_VAR 0 9
30205: PUSH
30206: LD_VAR 0 9
30210: PUSH
30211: LD_INT 3
30213: ADD
30214: ST_TO_ADDR
30215: GO 30231
// components := components ^ control_manual ;
30217: LD_ADDR_VAR 0 9
30221: PUSH
30222: LD_VAR 0 9
30226: PUSH
30227: LD_INT 1
30229: ADD
30230: ST_TO_ADDR
// end ; components := components ^ un [ 4 ] ;
30231: LD_ADDR_VAR 0 9
30235: PUSH
30236: LD_VAR 0 9
30240: PUSH
30241: LD_VAR 0 6
30245: PUSH
30246: LD_INT 4
30248: ARRAY
30249: ADD
30250: ST_TO_ADDR
// result := components ;
30251: LD_ADDR_VAR 0 5
30255: PUSH
30256: LD_VAR 0 9
30260: ST_TO_ADDR
// end ;
30261: LD_VAR 0 5
30265: RET
// function Define_Vehicle ( side , nation , factory , weapon ) ; var components ; begin
30266: LD_INT 0
30268: PPUSH
30269: PPUSH
// components := [ ] ;
30270: LD_ADDR_VAR 0 6
30274: PUSH
30275: EMPTY
30276: ST_TO_ADDR
// case ChassisWeight ( nation , weapon ) of 1 :
30277: LD_VAR 0 2
30281: PPUSH
30282: LD_VAR 0 4
30286: PPUSH
30287: CALL 30974 0 2
30291: PUSH
30292: LD_INT 1
30294: DOUBLE
30295: EQUAL
30296: IFTRUE 30300
30298: GO 30337
30300: POP
// components := components ^ SelectChassis ( side , nation , factory , 1 ) ; 2 :
30301: LD_ADDR_VAR 0 6
30305: PUSH
30306: LD_VAR 0 6
30310: PUSH
30311: LD_VAR 0 1
30315: PPUSH
30316: LD_VAR 0 2
30320: PPUSH
30321: LD_VAR 0 3
30325: PPUSH
30326: LD_INT 1
30328: PPUSH
30329: CALL 30608 0 4
30333: ADD
30334: ST_TO_ADDR
30335: GO 30428
30337: LD_INT 2
30339: DOUBLE
30340: EQUAL
30341: IFTRUE 30345
30343: GO 30382
30345: POP
// components := components ^ SelectChassis ( side , nation , factory , 2 ) ; 3 :
30346: LD_ADDR_VAR 0 6
30350: PUSH
30351: LD_VAR 0 6
30355: PUSH
30356: LD_VAR 0 1
30360: PPUSH
30361: LD_VAR 0 2
30365: PPUSH
30366: LD_VAR 0 3
30370: PPUSH
30371: LD_INT 2
30373: PPUSH
30374: CALL 30608 0 4
30378: ADD
30379: ST_TO_ADDR
30380: GO 30428
30382: LD_INT 3
30384: DOUBLE
30385: EQUAL
30386: IFTRUE 30390
30388: GO 30427
30390: POP
// components := components ^ SelectChassis ( side , nation , factory , 3 ) ; end ;
30391: LD_ADDR_VAR 0 6
30395: PUSH
30396: LD_VAR 0 6
30400: PUSH
30401: LD_VAR 0 1
30405: PPUSH
30406: LD_VAR 0 2
30410: PPUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: LD_INT 3
30418: PPUSH
30419: CALL 30608 0 4
30423: ADD
30424: ST_TO_ADDR
30425: GO 30428
30427: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30428: LD_VAR 0 3
30432: PPUSH
30433: LD_INT 21
30435: PPUSH
30436: CALL 28619 0 2
30440: PUSH
30441: LD_VAR 0 1
30445: PPUSH
30446: CALL 27977 0 1
30450: PUSH
30451: LD_INT 3
30453: ARRAY
30454: PUSH
30455: LD_LOC 55
30459: GREATEREQUAL
30460: AND
30461: IFFALSE 30479
// components := components ^ engine_siberite else
30463: LD_ADDR_VAR 0 6
30467: PUSH
30468: LD_VAR 0 6
30472: PUSH
30473: LD_INT 3
30475: ADD
30476: ST_TO_ADDR
30477: GO 30493
// components := components ^ engine_combustion ;
30479: LD_ADDR_VAR 0 6
30483: PUSH
30484: LD_VAR 0 6
30488: PUSH
30489: LD_INT 1
30491: ADD
30492: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30493: LD_VAR 0 2
30497: PUSH
30498: LD_INT 2
30500: EQUAL
30501: PUSH
30502: LD_VAR 0 1
30506: PPUSH
30507: CALL 31151 0 1
30511: AND
30512: IFFALSE 30530
// components := components ^ control_apeman else
30514: LD_ADDR_VAR 0 6
30518: PUSH
30519: LD_VAR 0 6
30523: PUSH
30524: LD_INT 5
30526: ADD
30527: ST_TO_ADDR
30528: GO 30574
// if ExtensionBuild ( factory , b_ext_computer ) then
30530: LD_VAR 0 3
30534: PPUSH
30535: LD_INT 24
30537: PPUSH
30538: CALL 28619 0 2
30542: IFFALSE 30560
// components := components ^ control_computer else
30544: LD_ADDR_VAR 0 6
30548: PUSH
30549: LD_VAR 0 6
30553: PUSH
30554: LD_INT 3
30556: ADD
30557: ST_TO_ADDR
30558: GO 30574
// components := components ^ control_remote ;
30560: LD_ADDR_VAR 0 6
30564: PUSH
30565: LD_VAR 0 6
30569: PUSH
30570: LD_INT 2
30572: ADD
30573: ST_TO_ADDR
// components := components ^ [ weapon ] ;
30574: LD_ADDR_VAR 0 6
30578: PUSH
30579: LD_VAR 0 6
30583: PUSH
30584: LD_VAR 0 4
30588: PUSH
30589: EMPTY
30590: LIST
30591: ADD
30592: ST_TO_ADDR
// result := components ;
30593: LD_ADDR_VAR 0 5
30597: PUSH
30598: LD_VAR 0 6
30602: ST_TO_ADDR
// end ;
30603: LD_VAR 0 5
30607: RET
// function SelectChassis ( side , nation , factory , weight ) ; var un , vysledek ; begin
30608: LD_INT 0
30610: PPUSH
30611: PPUSH
30612: PPUSH
// vysledek := 0 ;
30613: LD_ADDR_VAR 0 7
30617: PUSH
30618: LD_INT 0
30620: ST_TO_ADDR
// case weight of 1 :
30621: LD_VAR 0 4
30625: PUSH
30626: LD_INT 1
30628: DOUBLE
30629: EQUAL
30630: IFTRUE 30634
30632: GO 30697
30634: POP
// begin case nation of 1 :
30635: LD_VAR 0 2
30639: PUSH
30640: LD_INT 1
30642: DOUBLE
30643: EQUAL
30644: IFTRUE 30648
30646: GO 30659
30648: POP
// vysledek := us_light_wheeled ; 2 :
30649: LD_ADDR_VAR 0 7
30653: PUSH
30654: LD_INT 1
30656: ST_TO_ADDR
30657: GO 30695
30659: LD_INT 2
30661: DOUBLE
30662: EQUAL
30663: IFTRUE 30667
30665: GO 30694
30667: POP
// if hovers_recomended then
30668: LD_LOC 59
30672: IFFALSE 30684
// vysledek := ar_hovercraft else
30674: LD_ADDR_VAR 0 7
30678: PUSH
30679: LD_INT 11
30681: ST_TO_ADDR
30682: GO 30692
// vysledek := ar_light_trike ; end ;
30684: LD_ADDR_VAR 0 7
30688: PUSH
30689: LD_INT 12
30691: ST_TO_ADDR
30692: GO 30695
30694: POP
// end ; 2 :
30695: GO 30959
30697: LD_INT 2
30699: DOUBLE
30700: EQUAL
30701: IFTRUE 30705
30703: GO 30854
30705: POP
// begin if ( not flat_land ) and TrackExtension ( factory ) then
30706: LD_LOC 60
30710: NOT
30711: PUSH
30712: LD_VAR 0 3
30716: PPUSH
30717: CALL 29440 0 1
30721: AND
30722: IFFALSE 30789
// case nation of 1 :
30724: LD_VAR 0 2
30728: PUSH
30729: LD_INT 1
30731: DOUBLE
30732: EQUAL
30733: IFTRUE 30737
30735: GO 30748
30737: POP
// vysledek := us_medium_tracked ; 2 :
30738: LD_ADDR_VAR 0 7
30742: PUSH
30743: LD_INT 3
30745: ST_TO_ADDR
30746: GO 30787
30748: LD_INT 2
30750: DOUBLE
30751: EQUAL
30752: IFTRUE 30756
30754: GO 30767
30756: POP
// vysledek := ar_half_tracked ; 3 :
30757: LD_ADDR_VAR 0 7
30761: PUSH
30762: LD_INT 14
30764: ST_TO_ADDR
30765: GO 30787
30767: LD_INT 3
30769: DOUBLE
30770: EQUAL
30771: IFTRUE 30775
30773: GO 30786
30775: POP
// vysledek := ru_medium_tracked ; end else
30776: LD_ADDR_VAR 0 7
30780: PUSH
30781: LD_INT 22
30783: ST_TO_ADDR
30784: GO 30787
30786: POP
30787: GO 30852
// case nation of 1 :
30789: LD_VAR 0 2
30793: PUSH
30794: LD_INT 1
30796: DOUBLE
30797: EQUAL
30798: IFTRUE 30802
30800: GO 30813
30802: POP
// vysledek := us_medium_wheeled ; 2 :
30803: LD_ADDR_VAR 0 7
30807: PUSH
30808: LD_INT 2
30810: ST_TO_ADDR
30811: GO 30852
30813: LD_INT 2
30815: DOUBLE
30816: EQUAL
30817: IFTRUE 30821
30819: GO 30832
30821: POP
// vysledek := ar_medium_trike ; 3 :
30822: LD_ADDR_VAR 0 7
30826: PUSH
30827: LD_INT 13
30829: ST_TO_ADDR
30830: GO 30852
30832: LD_INT 3
30834: DOUBLE
30835: EQUAL
30836: IFTRUE 30840
30838: GO 30851
30840: POP
// vysledek := ru_medium_wheeled ; end end ; 3 :
30841: LD_ADDR_VAR 0 7
30845: PUSH
30846: LD_INT 21
30848: ST_TO_ADDR
30849: GO 30852
30851: POP
30852: GO 30959
30854: LD_INT 3
30856: DOUBLE
30857: EQUAL
30858: IFTRUE 30862
30860: GO 30958
30862: POP
// begin case nation of 1 :
30863: LD_VAR 0 2
30867: PUSH
30868: LD_INT 1
30870: DOUBLE
30871: EQUAL
30872: IFTRUE 30876
30874: GO 30915
30876: POP
// if GetTech ( side , tech_AdvChassis ) = state_researched then
30877: LD_VAR 0 1
30881: PPUSH
30882: LD_INT 36
30884: PPUSH
30885: CALL_OW 321
30889: PUSH
30890: LD_INT 2
30892: EQUAL
30893: IFFALSE 30905
// vysledek := us_morphling else
30895: LD_ADDR_VAR 0 7
30899: PUSH
30900: LD_INT 5
30902: ST_TO_ADDR
30903: GO 30913
// vysledek := us_heavy_tracked ; 3 :
30905: LD_ADDR_VAR 0 7
30909: PUSH
30910: LD_INT 4
30912: ST_TO_ADDR
30913: GO 30956
30915: LD_INT 3
30917: DOUBLE
30918: EQUAL
30919: IFTRUE 30923
30921: GO 30955
30923: POP
// if TrackExtension ( factory ) then
30924: LD_VAR 0 3
30928: PPUSH
30929: CALL 29440 0 1
30933: IFFALSE 30945
// vysledek := ru_heavy_tracked else
30935: LD_ADDR_VAR 0 7
30939: PUSH
30940: LD_INT 24
30942: ST_TO_ADDR
30943: GO 30953
// vysledek := ru_heavy_wheeled ; end end ; end ;
30945: LD_ADDR_VAR 0 7
30949: PUSH
30950: LD_INT 23
30952: ST_TO_ADDR
30953: GO 30956
30955: POP
30956: GO 30959
30958: POP
// result := vysledek ;
30959: LD_ADDR_VAR 0 5
30963: PUSH
30964: LD_VAR 0 7
30968: ST_TO_ADDR
// end ;
30969: LD_VAR 0 5
30973: RET
// function ChassisWeight ( nation , weapon ) ; var chassis , un , vysledek , weapon_list ; begin
30974: LD_INT 0
30976: PPUSH
30977: PPUSH
30978: PPUSH
30979: PPUSH
30980: PPUSH
// case nation of 1 :
30981: LD_VAR 0 1
30985: PUSH
30986: LD_INT 1
30988: DOUBLE
30989: EQUAL
30990: IFTRUE 30994
30992: GO 31007
30994: POP
// weapon_list := us_weapons ; 2 :
30995: LD_ADDR_VAR 0 7
30999: PUSH
31000: LD_LOC 52
31004: ST_TO_ADDR
31005: GO 31050
31007: LD_INT 2
31009: DOUBLE
31010: EQUAL
31011: IFTRUE 31015
31013: GO 31028
31015: POP
// weapon_list := ar_weapons ; 3 :
31016: LD_ADDR_VAR 0 7
31020: PUSH
31021: LD_LOC 53
31025: ST_TO_ADDR
31026: GO 31050
31028: LD_INT 3
31030: DOUBLE
31031: EQUAL
31032: IFTRUE 31036
31034: GO 31049
31036: POP
// weapon_list := ru_weapons ; end ;
31037: LD_ADDR_VAR 0 7
31041: PUSH
31042: LD_LOC 54
31046: ST_TO_ADDR
31047: GO 31050
31049: POP
// vysledek := false ;
31050: LD_ADDR_VAR 0 6
31054: PUSH
31055: LD_INT 0
31057: ST_TO_ADDR
// for chassis = 1 to 3 do
31058: LD_ADDR_VAR 0 4
31062: PUSH
31063: DOUBLE
31064: LD_INT 1
31066: DEC
31067: ST_TO_ADDR
31068: LD_INT 3
31070: PUSH
31071: FOR_TO
31072: IFFALSE 31134
// if not vysledek then
31074: LD_VAR 0 6
31078: NOT
31079: IFFALSE 31132
// for un in weapon_list [ chassis ] do
31081: LD_ADDR_VAR 0 5
31085: PUSH
31086: LD_VAR 0 7
31090: PUSH
31091: LD_VAR 0 4
31095: ARRAY
31096: PUSH
31097: FOR_IN
31098: IFFALSE 31130
// if weapon = un [ 1 ] then
31100: LD_VAR 0 2
31104: PUSH
31105: LD_VAR 0 5
31109: PUSH
31110: LD_INT 1
31112: ARRAY
31113: EQUAL
31114: IFFALSE 31128
// begin vysledek := chassis ;
31116: LD_ADDR_VAR 0 6
31120: PUSH
31121: LD_VAR 0 4
31125: ST_TO_ADDR
// break ;
31126: GO 31130
// end ;
31128: GO 31097
31130: POP
31131: POP
31132: GO 31071
31134: POP
31135: POP
// result := vysledek ;
31136: LD_ADDR_VAR 0 3
31140: PUSH
31141: LD_VAR 0 6
31145: ST_TO_ADDR
// end ;
31146: LD_VAR 0 3
31150: RET
// function ApemanCanDrive ( side ) ; var un ; begin
31151: LD_INT 0
31153: PPUSH
31154: PPUSH
// result := ( GetTech ( side , tech_ApeNeural ) = state_researched ) and FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31155: LD_ADDR_VAR 0 2
31159: PUSH
31160: LD_VAR 0 1
31164: PPUSH
31165: LD_INT 3
31167: PPUSH
31168: CALL_OW 321
31172: PUSH
31173: LD_INT 2
31175: EQUAL
31176: PUSH
31177: LD_INT 22
31179: PUSH
31180: LD_VAR 0 1
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 25
31191: PUSH
31192: LD_INT 12
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PPUSH
31203: CALL_OW 69
31207: AND
31208: ST_TO_ADDR
// end ;
31209: LD_VAR 0 2
31213: RET
// function transfer_mechanics ( side , mechanics , factory , components ) ; var un , isin ; begin
31214: LD_INT 0
31216: PPUSH
31217: PPUSH
31218: PPUSH
// isin := UnitsInside ( factory ) ;
31219: LD_ADDR_VAR 0 7
31223: PUSH
31224: LD_VAR 0 3
31228: PPUSH
31229: CALL_OW 313
31233: ST_TO_ADDR
// if ( 0 + isin ) > 5 then
31234: LD_INT 0
31236: PUSH
31237: LD_VAR 0 7
31241: PLUS
31242: PUSH
31243: LD_INT 5
31245: GREATER
31246: IFFALSE 31258
// begin result := true ;
31248: LD_ADDR_VAR 0 5
31252: PUSH
31253: LD_INT 1
31255: ST_TO_ADDR
// exit ;
31256: GO 31480
// end ; un := true ;
31258: LD_ADDR_VAR 0 6
31262: PUSH
31263: LD_INT 1
31265: ST_TO_ADDR
// if side = ar then
31266: LD_VAR 0 1
31270: PUSH
31271: LD_EXP 4
31275: EQUAL
31276: IFFALSE 31306
// mechanics := UnitFilter ( mechanics , [ f_not , [ f_driving ] ] ) ;
31278: LD_ADDR_VAR 0 2
31282: PUSH
31283: LD_VAR 0 2
31287: PPUSH
31288: LD_INT 3
31290: PUSH
31291: LD_INT 55
31293: PUSH
31294: EMPTY
31295: LIST
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PPUSH
31301: CALL_OW 72
31305: ST_TO_ADDR
// DoEnterUnit ( mechanics , factory ) ;
31306: LD_VAR 0 2
31310: PPUSH
31311: LD_VAR 0 3
31315: PPUSH
31316: CALL 31485 0 2
// if components [ 3 ] = control_apeman then
31320: LD_VAR 0 4
31324: PUSH
31325: LD_INT 3
31327: ARRAY
31328: PUSH
31329: LD_INT 5
31331: EQUAL
31332: IFFALSE 31470
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] , [ f_not , [ f_hastask ] ] ] ) ;
31334: LD_ADDR_VAR 0 6
31338: PUSH
31339: LD_INT 22
31341: PUSH
31342: LD_VAR 0 1
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 25
31353: PUSH
31354: LD_INT 12
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 3
31363: PUSH
31364: LD_INT 60
31366: PUSH
31367: EMPTY
31368: LIST
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: LIST
31378: PPUSH
31379: CALL_OW 69
31383: ST_TO_ADDR
// if un then
31384: LD_VAR 0 6
31388: IFFALSE 31410
// DoEnterUnit ( un [ 1 ] , factory ) else
31390: LD_VAR 0 6
31394: PUSH
31395: LD_INT 1
31397: ARRAY
31398: PPUSH
31399: LD_VAR 0 3
31403: PPUSH
31404: CALL 31485 0 2
31408: GO 31470
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31410: LD_ADDR_VAR 0 6
31414: PUSH
31415: LD_INT 22
31417: PUSH
31418: LD_VAR 0 1
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 25
31429: PUSH
31430: LD_INT 12
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PPUSH
31441: CALL_OW 69
31445: ST_TO_ADDR
// if un then
31446: LD_VAR 0 6
31450: IFFALSE 31470
// DoEnterUnit ( un [ 1 ] , factory ) ;
31452: LD_VAR 0 6
31456: PUSH
31457: LD_INT 1
31459: ARRAY
31460: PPUSH
31461: LD_VAR 0 3
31465: PPUSH
31466: CALL 31485 0 2
// end ; end ; result := un ;
31470: LD_ADDR_VAR 0 5
31474: PUSH
31475: LD_VAR 0 6
31479: ST_TO_ADDR
// end ;
31480: LD_VAR 0 5
31484: RET
// function DoEnterUnit ( moving_un_list , into_un ) ; var inside_un , t , moving_un ; begin
31485: LD_INT 0
31487: PPUSH
31488: PPUSH
31489: PPUSH
31490: PPUSH
// for moving_un in moving_un_list do
31491: LD_ADDR_VAR 0 6
31495: PUSH
31496: LD_VAR 0 1
31500: PUSH
31501: FOR_IN
31502: IFFALSE 31639
// begin inside_un = IsInUnit ( moving_un ) ;
31504: LD_ADDR_VAR 0 4
31508: PUSH
31509: LD_VAR 0 6
31513: PPUSH
31514: CALL_OW 310
31518: ST_TO_ADDR
// if inside_un <> into_un then
31519: LD_VAR 0 4
31523: PUSH
31524: LD_VAR 0 2
31528: NONEQUAL
31529: IFFALSE 31637
// begin if inside_un > 0 then
31531: LD_VAR 0 4
31535: PUSH
31536: LD_INT 0
31538: GREATER
31539: IFFALSE 31558
// t = GetType ( inside_un ) else
31541: LD_ADDR_VAR 0 5
31545: PUSH
31546: LD_VAR 0 4
31550: PPUSH
31551: CALL_OW 247
31555: ST_TO_ADDR
31556: GO 31566
// t = 0 ;
31558: LD_ADDR_VAR 0 5
31562: PUSH
31563: LD_INT 0
31565: ST_TO_ADDR
// case t of unit_vehicle :
31566: LD_VAR 0 5
31570: PUSH
31571: LD_INT 2
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31591
31579: POP
// ComExitVehicle ( moving_un ) ; unit_building :
31580: LD_VAR 0 6
31584: PPUSH
31585: CALL_OW 121
31589: GO 31637
31591: LD_INT 3
31593: DOUBLE
31594: EQUAL
31595: IFTRUE 31599
31597: GO 31611
31599: POP
// ComExitBuilding ( moving_un ) ; 0 :
31600: LD_VAR 0 6
31604: PPUSH
31605: CALL_OW 122
31609: GO 31637
31611: LD_INT 0
31613: DOUBLE
31614: EQUAL
31615: IFTRUE 31619
31617: GO 31636
31619: POP
// ComEnterUnit ( moving_un , into_un ) ; end ;
31620: LD_VAR 0 6
31624: PPUSH
31625: LD_VAR 0 2
31629: PPUSH
31630: CALL_OW 120
31634: GO 31637
31636: POP
// end ; end ;
31637: GO 31501
31639: POP
31640: POP
// end ;
31641: LD_VAR 0 3
31645: RET
// function start_building_vehicle ( nation , factory , vehicle ) ; begin
31646: LD_INT 0
31648: PPUSH
// if ( not UnitsInside ( factory ) ) and ( nation <> ar ) then
31649: LD_VAR 0 2
31653: PPUSH
31654: CALL_OW 313
31658: NOT
31659: PUSH
31660: LD_VAR 0 1
31664: PUSH
31665: LD_EXP 4
31669: NONEQUAL
31670: AND
31671: IFFALSE 31683
// begin result = false ;
31673: LD_ADDR_VAR 0 4
31677: PUSH
31678: LD_INT 0
31680: ST_TO_ADDR
// exit ;
31681: GO 31789
// end ; if vehicle [ 3 ] = control_apeman and not ApemanInFactory ( factory ) then
31683: LD_VAR 0 3
31687: PUSH
31688: LD_INT 3
31690: ARRAY
31691: PUSH
31692: LD_INT 5
31694: EQUAL
31695: PUSH
31696: LD_VAR 0 2
31700: PPUSH
31701: CALL 31794 0 1
31705: NOT
31706: AND
31707: IFFALSE 31719
// begin result = false ;
31709: LD_ADDR_VAR 0 4
31713: PUSH
31714: LD_INT 0
31716: ST_TO_ADDR
// exit ;
31717: GO 31789
// end ; ComChangeProfession ( UnitsInside ( factory ) , class_mechanic ) ;
31719: LD_VAR 0 2
31723: PPUSH
31724: CALL_OW 313
31728: PPUSH
31729: LD_INT 3
31731: PPUSH
31732: CALL_OW 123
// ComConstruct ( factory , vehicle [ 1 ] , vehicle [ 2 ] , vehicle [ 3 ] , vehicle [ 4 ] ) ;
31736: LD_VAR 0 2
31740: PPUSH
31741: LD_VAR 0 3
31745: PUSH
31746: LD_INT 1
31748: ARRAY
31749: PPUSH
31750: LD_VAR 0 3
31754: PUSH
31755: LD_INT 2
31757: ARRAY
31758: PPUSH
31759: LD_VAR 0 3
31763: PUSH
31764: LD_INT 3
31766: ARRAY
31767: PPUSH
31768: LD_VAR 0 3
31772: PUSH
31773: LD_INT 4
31775: ARRAY
31776: PPUSH
31777: CALL_OW 125
// result = true ;
31781: LD_ADDR_VAR 0 4
31785: PUSH
31786: LD_INT 1
31788: ST_TO_ADDR
// end ;
31789: LD_VAR 0 4
31793: RET
// function ApemanInFactory ( factory ) ; var un , list , vysledek ; begin
31794: LD_INT 0
31796: PPUSH
31797: PPUSH
31798: PPUSH
31799: PPUSH
// vysledek := false ;
31800: LD_ADDR_VAR 0 5
31804: PUSH
31805: LD_INT 0
31807: ST_TO_ADDR
// list := UnitsInside ( factory ) ;
31808: LD_ADDR_VAR 0 4
31812: PUSH
31813: LD_VAR 0 1
31817: PPUSH
31818: CALL_OW 313
31822: ST_TO_ADDR
// for un in list do
31823: LD_ADDR_VAR 0 3
31827: PUSH
31828: LD_VAR 0 4
31832: PUSH
31833: FOR_IN
31834: IFFALSE 31863
// if GetClass ( un ) = class_apeman then
31836: LD_VAR 0 3
31840: PPUSH
31841: CALL_OW 257
31845: PUSH
31846: LD_INT 12
31848: EQUAL
31849: IFFALSE 31861
// begin vysledek := true ;
31851: LD_ADDR_VAR 0 5
31855: PUSH
31856: LD_INT 1
31858: ST_TO_ADDR
// break ;
31859: GO 31863
// end ;
31861: GO 31833
31863: POP
31864: POP
// result := vysledek ;
31865: LD_ADDR_VAR 0 2
31869: PUSH
31870: LD_VAR 0 5
31874: ST_TO_ADDR
// end ;
31875: LD_VAR 0 2
31879: RET
// function cleanup_extensions ( side , nation , factory ) ; var un , list , crane , cargo_bay , nation_crane , nation_cargo ; begin
31880: LD_INT 0
31882: PPUSH
31883: PPUSH
31884: PPUSH
31885: PPUSH
31886: PPUSH
31887: PPUSH
31888: PPUSH
// case nation of 1 :
31889: LD_VAR 0 2
31893: PUSH
31894: LD_INT 1
31896: DOUBLE
31897: EQUAL
31898: IFTRUE 31902
31900: GO 31921
31902: POP
// begin nation_cargo := us_cargo_bay ;
31903: LD_ADDR_VAR 0 10
31907: PUSH
31908: LD_INT 12
31910: ST_TO_ADDR
// nation_crane := us_crane ;
31911: LD_ADDR_VAR 0 9
31915: PUSH
31916: LD_INT 13
31918: ST_TO_ADDR
// end ; 2 :
31919: GO 31976
31921: LD_INT 2
31923: DOUBLE
31924: EQUAL
31925: IFTRUE 31929
31927: GO 31948
31929: POP
// begin nation_cargo := ar_cargo_bay ;
31930: LD_ADDR_VAR 0 10
31934: PUSH
31935: LD_INT 32
31937: ST_TO_ADDR
// nation_crane := 0 ;
31938: LD_ADDR_VAR 0 9
31942: PUSH
31943: LD_INT 0
31945: ST_TO_ADDR
// end ; 3 :
31946: GO 31976
31948: LD_INT 3
31950: DOUBLE
31951: EQUAL
31952: IFTRUE 31956
31954: GO 31975
31956: POP
// begin nation_cargo := ru_cargo_bay ;
31957: LD_ADDR_VAR 0 10
31961: PUSH
31962: LD_INT 51
31964: ST_TO_ADDR
// nation_crane := ru_crane ;
31965: LD_ADDR_VAR 0 9
31969: PUSH
31970: LD_INT 52
31972: ST_TO_ADDR
// end ; end ;
31973: GO 31976
31975: POP
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
31976: LD_ADDR_VAR 0 8
31980: PUSH
31981: LD_INT 22
31983: PUSH
31984: LD_VAR 0 1
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 21
31995: PUSH
31996: LD_INT 2
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 34
32005: PUSH
32006: LD_VAR 0 10
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: LIST
32019: PPUSH
32020: CALL_OW 69
32024: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
32025: LD_ADDR_VAR 0 7
32029: PUSH
32030: LD_INT 22
32032: PUSH
32033: LD_VAR 0 1
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 21
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: LD_INT 34
32054: PUSH
32055: LD_VAR 0 9
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: LIST
32068: PPUSH
32069: CALL_OW 69
32073: ST_TO_ADDR
// if ( nation_crane in extension_wanted ) and crane then
32074: LD_VAR 0 9
32078: PUSH
32079: LD_EXP 73
32083: IN
32084: PUSH
32085: LD_VAR 0 7
32089: AND
32090: IFFALSE 32108
// extension_wanted := extension_wanted diff nation_crane ;
32092: LD_ADDR_EXP 73
32096: PUSH
32097: LD_EXP 73
32101: PUSH
32102: LD_VAR 0 9
32106: DIFF
32107: ST_TO_ADDR
// if ( nation_cargo in extension_wanted ) and cargo_bay then
32108: LD_VAR 0 10
32112: PUSH
32113: LD_EXP 73
32117: IN
32118: PUSH
32119: LD_VAR 0 8
32123: AND
32124: IFFALSE 32142
// extension_wanted := extension_wanted diff nation_cargo ;
32126: LD_ADDR_EXP 73
32130: PUSH
32131: LD_EXP 73
32135: PUSH
32136: LD_VAR 0 10
32140: DIFF
32141: ST_TO_ADDR
// list := extension_wanted ;
32142: LD_ADDR_VAR 0 6
32146: PUSH
32147: LD_EXP 73
32151: ST_TO_ADDR
// for un in list do
32152: LD_ADDR_VAR 0 5
32156: PUSH
32157: LD_VAR 0 6
32161: PUSH
32162: FOR_IN
32163: IFFALSE 32196
// begin if not un in main_extensions then
32165: LD_VAR 0 5
32169: PUSH
32170: LD_LOC 58
32174: IN
32175: NOT
32176: IFFALSE 32194
// extension_wanted := extension_wanted diff un ;
32178: LD_ADDR_EXP 73
32182: PUSH
32183: LD_EXP 73
32187: PUSH
32188: LD_VAR 0 5
32192: DIFF
32193: ST_TO_ADDR
// end ;
32194: GO 32162
32196: POP
32197: POP
// end ; end_of_file
32198: LD_VAR 0 4
32202: RET
// var mc_list ; var b_list ; export function init_keep_base ; var un , build , side ; begin
32203: LD_INT 0
32205: PPUSH
32206: PPUSH
32207: PPUSH
32208: PPUSH
// b_list := [ ] ;
32209: LD_ADDR_LOC 62
32213: PUSH
32214: EMPTY
32215: ST_TO_ADDR
// mc_list := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
32216: LD_ADDR_LOC 61
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: LD_INT 0
32229: PUSH
32230: LD_INT 0
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 0
32238: PUSH
32239: LD_INT 0
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: ST_TO_ADDR
// for side = 1 to 8 do
32255: LD_ADDR_VAR 0 4
32259: PUSH
32260: DOUBLE
32261: LD_INT 1
32263: DEC
32264: ST_TO_ADDR
32265: LD_INT 8
32267: PUSH
32268: FOR_TO
32269: IFFALSE 32384
// if side in cpu_list then
32271: LD_VAR 0 4
32275: PUSH
32276: LD_EXP 8
32280: IN
32281: IFFALSE 32366
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
32283: LD_ADDR_VAR 0 2
32287: PUSH
32288: LD_INT 22
32290: PUSH
32291: LD_VAR 0 4
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 21
32302: PUSH
32303: LD_INT 3
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PPUSH
32314: CALL_OW 69
32318: ST_TO_ADDR
// if un then
32319: LD_VAR 0 2
32323: IFFALSE 32364
// b_list := Insert ( b_list , side , GetBuildList ( GetBase ( un [ 1 ] ) ) ) ;
32325: LD_ADDR_LOC 62
32329: PUSH
32330: LD_LOC 62
32334: PPUSH
32335: LD_VAR 0 4
32339: PPUSH
32340: LD_VAR 0 2
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: PPUSH
32349: CALL_OW 274
32353: PPUSH
32354: CALL_OW 417
32358: PPUSH
32359: CALL_OW 2
32363: ST_TO_ADDR
// end else
32364: GO 32382
// b_list := b_list ^ [ [ ] ] ;
32366: LD_ADDR_LOC 62
32370: PUSH
32371: LD_LOC 62
32375: PUSH
32376: EMPTY
32377: PUSH
32378: EMPTY
32379: LIST
32380: ADD
32381: ST_TO_ADDR
32382: GO 32268
32384: POP
32385: POP
// end ;
32386: LD_VAR 0 1
32390: RET
// every 0 0$5.2 trigger us in cpu_list do var side , list , engineers ;
32391: LD_EXP 3
32395: PUSH
32396: LD_EXP 8
32400: IN
32401: IFFALSE 32606
32403: GO 32405
32405: DISABLE
32406: LD_INT 0
32408: PPUSH
32409: PPUSH
32410: PPUSH
// begin list := [ ] ;
32411: LD_ADDR_VAR 0 2
32415: PUSH
32416: EMPTY
32417: ST_TO_ADDR
// for side = 1 to 8 do
32418: LD_ADDR_VAR 0 1
32422: PUSH
32423: DOUBLE
32424: LD_INT 1
32426: DEC
32427: ST_TO_ADDR
32428: LD_INT 8
32430: PUSH
32431: FOR_TO
32432: IFFALSE 32593
// if ( side in cpu_list ) then
32434: LD_VAR 0 1
32438: PUSH
32439: LD_EXP 8
32443: IN
32444: IFFALSE 32577
// begin if not ExistMc ( mc_list [ side ] ) then
32446: LD_LOC 61
32450: PUSH
32451: LD_VAR 0 1
32455: ARRAY
32456: PPUSH
32457: CALL_OW 386
32461: NOT
32462: IFFALSE 32553
// begin engineers := request_people ( side , class_engineer , 5 ) ;
32464: LD_ADDR_VAR 0 3
32468: PUSH
32469: LD_VAR 0 1
32473: PPUSH
32474: LD_INT 2
32476: PPUSH
32477: LD_INT 5
32479: PPUSH
32480: CALL 26382 0 3
32484: ST_TO_ADDR
// if engineers then
32485: LD_VAR 0 3
32489: IFFALSE 32537
// list := list ^ McBase ( 3 , engineers , b_list [ side ] , 0 , 0 , 0 ) else
32491: LD_ADDR_VAR 0 2
32495: PUSH
32496: LD_VAR 0 2
32500: PUSH
32501: LD_INT 3
32503: PPUSH
32504: LD_VAR 0 3
32508: PPUSH
32509: LD_LOC 62
32513: PUSH
32514: LD_VAR 0 1
32518: ARRAY
32519: PPUSH
32520: LD_INT 0
32522: PPUSH
32523: LD_INT 0
32525: PPUSH
32526: LD_INT 0
32528: PPUSH
32529: CALL_OW 397
32533: ADD
32534: ST_TO_ADDR
32535: GO 32551
// list := list ^ 0 end else
32537: LD_ADDR_VAR 0 2
32541: PUSH
32542: LD_VAR 0 2
32546: PUSH
32547: LD_INT 0
32549: ADD
32550: ST_TO_ADDR
32551: GO 32575
// list := list ^ mc_list [ side ] ;
32553: LD_ADDR_VAR 0 2
32557: PUSH
32558: LD_VAR 0 2
32562: PUSH
32563: LD_LOC 61
32567: PUSH
32568: LD_VAR 0 1
32572: ARRAY
32573: ADD
32574: ST_TO_ADDR
// end else
32575: GO 32591
// list := list ^ 0 ;
32577: LD_ADDR_VAR 0 2
32581: PUSH
32582: LD_VAR 0 2
32586: PUSH
32587: LD_INT 0
32589: ADD
32590: ST_TO_ADDR
32591: GO 32431
32593: POP
32594: POP
// mc_list := list ;
32595: LD_ADDR_LOC 61
32599: PUSH
32600: LD_VAR 0 2
32604: ST_TO_ADDR
// enable ;
32605: ENABLE
// end ; end_of_file
32606: PPOPN 3
32608: END
// var load_global , load_local_cpu , load_local_you ; var global_delay , cpu_delay , you_delay ; var crates_loading_area ; export function init_crates_loading ; begin
32609: LD_INT 0
32611: PPUSH
// global_delay := 10 10$0 ;
32612: LD_ADDR_LOC 66
32616: PUSH
32617: LD_INT 21000
32619: ST_TO_ADDR
// cpu_delay := 0 0$90 ;
32620: LD_ADDR_LOC 67
32624: PUSH
32625: LD_INT 3150
32627: ST_TO_ADDR
// you_delay := 3 3$30 ;
32628: LD_ADDR_LOC 68
32632: PUSH
32633: LD_INT 7350
32635: ST_TO_ADDR
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32636: LD_ADDR_LOC 63
32640: PUSH
32641: LD_OWVAR 1
32645: PUSH
32646: LD_LOC 66
32650: PUSH
32651: LD_INT 1400
32653: MINUS
32654: PPUSH
32655: LD_LOC 66
32659: PUSH
32660: LD_INT 2100
32662: PLUS
32663: PPUSH
32664: CALL_OW 12
32668: PLUS
32669: ST_TO_ADDR
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
32670: LD_ADDR_LOC 64
32674: PUSH
32675: LD_OWVAR 1
32679: PUSH
32680: LD_LOC 67
32684: PUSH
32685: LD_INT 700
32687: MINUS
32688: PPUSH
32689: LD_LOC 67
32693: PUSH
32694: LD_INT 700
32696: PLUS
32697: PPUSH
32698: CALL_OW 12
32702: PLUS
32703: ST_TO_ADDR
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
32704: LD_ADDR_LOC 65
32708: PUSH
32709: LD_OWVAR 1
32713: PUSH
32714: LD_LOC 68
32718: PUSH
32719: LD_INT 700
32721: MINUS
32722: PPUSH
32723: LD_LOC 68
32727: PUSH
32728: LD_INT 700
32730: PLUS
32731: PPUSH
32732: CALL_OW 12
32736: PLUS
32737: ST_TO_ADDR
// crates_loading_area := [ us_crates , ar_crates , ru_crates ] ;
32738: LD_ADDR_LOC 69
32742: PUSH
32743: LD_INT 1
32745: PUSH
32746: LD_INT 3
32748: PUSH
32749: LD_INT 2
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: LIST
32756: ST_TO_ADDR
// end ;
32757: LD_VAR 0 1
32761: RET
// every 0 0$5.1 trigger TICK > load_global do var c , sur , i ;
32762: LD_OWVAR 1
32766: PUSH
32767: LD_LOC 63
32771: GREATER
32772: IFFALSE 32945
32774: GO 32776
32776: DISABLE
32777: LD_INT 0
32779: PPUSH
32780: PPUSH
32781: PPUSH
// begin c := RandHex ( false ) ;
32782: LD_ADDR_VAR 0 1
32786: PUSH
32787: LD_INT 0
32789: PPUSH
32790: CALL_OW 15
32794: ST_TO_ADDR
// sur := [ ] ;
32795: LD_ADDR_VAR 0 2
32799: PUSH
32800: EMPTY
32801: ST_TO_ADDR
// for i = 1 to 4 do
32802: LD_ADDR_VAR 0 3
32806: PUSH
32807: DOUBLE
32808: LD_INT 1
32810: DEC
32811: ST_TO_ADDR
32812: LD_INT 4
32814: PUSH
32815: FOR_TO
32816: IFFALSE 32863
// sur := sur ^ [ RandHexXYR ( c [ 1 ] , c [ 2 ] , 1 , false ) ] ;
32818: LD_ADDR_VAR 0 2
32822: PUSH
32823: LD_VAR 0 2
32827: PUSH
32828: LD_VAR 0 1
32832: PUSH
32833: LD_INT 1
32835: ARRAY
32836: PPUSH
32837: LD_VAR 0 1
32841: PUSH
32842: LD_INT 2
32844: ARRAY
32845: PPUSH
32846: LD_INT 1
32848: PPUSH
32849: LD_INT 0
32851: PPUSH
32852: CALL_OW 17
32856: PUSH
32857: EMPTY
32858: LIST
32859: ADD
32860: ST_TO_ADDR
32861: GO 32815
32863: POP
32864: POP
// for i in sur do
32865: LD_ADDR_VAR 0 3
32869: PUSH
32870: LD_VAR 0 2
32874: PUSH
32875: FOR_IN
32876: IFFALSE 32908
// CreateCratesXY ( 5 , i [ 1 ] , i [ 2 ] , true ) ;
32878: LD_INT 5
32880: PPUSH
32881: LD_VAR 0 3
32885: PUSH
32886: LD_INT 1
32888: ARRAY
32889: PPUSH
32890: LD_VAR 0 3
32894: PUSH
32895: LD_INT 2
32897: ARRAY
32898: PPUSH
32899: LD_INT 1
32901: PPUSH
32902: CALL_OW 54
32906: GO 32875
32908: POP
32909: POP
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32910: LD_ADDR_LOC 63
32914: PUSH
32915: LD_OWVAR 1
32919: PUSH
32920: LD_LOC 66
32924: PUSH
32925: LD_INT 1400
32927: MINUS
32928: PPUSH
32929: LD_LOC 66
32933: PUSH
32934: LD_INT 2100
32936: PLUS
32937: PPUSH
32938: CALL_OW 12
32942: PLUS
32943: ST_TO_ADDR
// enable ;
32944: ENABLE
// end ;
32945: PPOPN 3
32947: END
// every 0 0$5.4 trigger TICK > load_local_cpu do var un ;
32948: LD_OWVAR 1
32952: PUSH
32953: LD_LOC 64
32957: GREATER
32958: IFFALSE 33075
32960: GO 32962
32962: DISABLE
32963: LD_INT 0
32965: PPUSH
// begin if GetResourceArea ( us_crates , mat_cans ) < 250 then
32966: LD_INT 1
32968: PPUSH
32969: LD_INT 1
32971: PPUSH
32972: CALL_OW 287
32976: PUSH
32977: LD_INT 250
32979: LESS
32980: IFFALSE 33003
// CreateCratesArea ( Rand ( 3 , 5 ) , us_crates , true ) ;
32982: LD_INT 3
32984: PPUSH
32985: LD_INT 5
32987: PPUSH
32988: CALL_OW 12
32992: PPUSH
32993: LD_INT 1
32995: PPUSH
32996: LD_INT 1
32998: PPUSH
32999: CALL_OW 55
// if GetResourceArea ( ru_crates , mat_cans ) < 250 then
33003: LD_INT 2
33005: PPUSH
33006: LD_INT 1
33008: PPUSH
33009: CALL_OW 287
33013: PUSH
33014: LD_INT 250
33016: LESS
33017: IFFALSE 33040
// CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
33019: LD_INT 3
33021: PPUSH
33022: LD_INT 5
33024: PPUSH
33025: CALL_OW 12
33029: PPUSH
33030: LD_INT 2
33032: PPUSH
33033: LD_INT 1
33035: PPUSH
33036: CALL_OW 55
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33040: LD_ADDR_LOC 64
33044: PUSH
33045: LD_OWVAR 1
33049: PUSH
33050: LD_LOC 67
33054: PUSH
33055: LD_INT 700
33057: MINUS
33058: PPUSH
33059: LD_LOC 67
33063: PUSH
33064: LD_INT 700
33066: PLUS
33067: PPUSH
33068: CALL_OW 12
33072: PLUS
33073: ST_TO_ADDR
// enable ;
33074: ENABLE
// end ;
33075: PPOPN 1
33077: END
// every 0 0$5.3 trigger TICK > load_local_you do
33078: LD_OWVAR 1
33082: PUSH
33083: LD_LOC 65
33087: GREATER
33088: IFFALSE 33165
33090: GO 33092
33092: DISABLE
// begin if GetResourceArea ( ar_crates , mat_cans ) < 250 then
33093: LD_INT 3
33095: PPUSH
33096: LD_INT 1
33098: PPUSH
33099: CALL_OW 287
33103: PUSH
33104: LD_INT 250
33106: LESS
33107: IFFALSE 33130
// CreateCratesArea ( Rand ( 1 , 5 ) , ar_crates , true ) ;
33109: LD_INT 1
33111: PPUSH
33112: LD_INT 5
33114: PPUSH
33115: CALL_OW 12
33119: PPUSH
33120: LD_INT 3
33122: PPUSH
33123: LD_INT 1
33125: PPUSH
33126: CALL_OW 55
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33130: LD_ADDR_LOC 65
33134: PUSH
33135: LD_OWVAR 1
33139: PUSH
33140: LD_LOC 68
33144: PUSH
33145: LD_INT 700
33147: MINUS
33148: PPUSH
33149: LD_LOC 68
33153: PUSH
33154: LD_INT 700
33156: PLUS
33157: PPUSH
33158: CALL_OW 12
33162: PLUS
33163: ST_TO_ADDR
// enable ;
33164: ENABLE
// end ;
33165: END
// every 0 0$30.1 do var list , side , un , base ;
33166: GO 33168
33168: DISABLE
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
// begin for side in cpu_list do
33175: LD_ADDR_VAR 0 2
33179: PUSH
33180: LD_EXP 8
33184: PUSH
33185: FOR_IN
33186: IFFALSE 33340
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
33188: LD_ADDR_VAR 0 1
33192: PUSH
33193: LD_INT 22
33195: PUSH
33196: LD_VAR 0 2
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 21
33207: PUSH
33208: LD_INT 3
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: PUSH
33218: LD_INT 30
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 30
33230: PUSH
33231: LD_INT 1
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: LIST
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: LIST
33247: PPUSH
33248: CALL_OW 69
33252: ST_TO_ADDR
// for un in list do
33253: LD_ADDR_VAR 0 3
33257: PUSH
33258: LD_VAR 0 1
33262: PUSH
33263: FOR_IN
33264: IFFALSE 33336
// begin base := GetBase ( un ) ;
33266: LD_ADDR_VAR 0 4
33270: PUSH
33271: LD_VAR 0 3
33275: PPUSH
33276: CALL_OW 274
33280: ST_TO_ADDR
// if GetResourceType ( base , mat_cans ) < 300 then
33281: LD_VAR 0 4
33285: PPUSH
33286: LD_INT 1
33288: PPUSH
33289: CALL_OW 275
33293: PUSH
33294: LD_INT 300
33296: LESS
33297: IFFALSE 33334
// SetResourceType ( base , mat_cans , GetResourceType ( base , mat_cans ) + ( difficulty * 30 ) ) ;
33299: LD_VAR 0 4
33303: PPUSH
33304: LD_INT 1
33306: PPUSH
33307: LD_VAR 0 4
33311: PPUSH
33312: LD_INT 1
33314: PPUSH
33315: CALL_OW 275
33319: PUSH
33320: LD_OWVAR 67
33324: PUSH
33325: LD_INT 30
33327: MUL
33328: PLUS
33329: PPUSH
33330: CALL_OW 277
// end ;
33334: GO 33263
33336: POP
33337: POP
// end ;
33338: GO 33185
33340: POP
33341: POP
// enable ;
33342: ENABLE
// end ; end_of_file
33343: PPOPN 4
33345: END
// var outside_list , inside_list ; var base_areas , create_areas ; var us_bay , ru_bay , ar_bay ; var us_bad , ru_bad , ar_bad ; export function init_crates_collecting ; begin
33346: LD_INT 0
33348: PPUSH
// outside_list := [ us_crates , ar_crates , ru_crates ] ;
33349: LD_ADDR_LOC 70
33353: PUSH
33354: LD_INT 1
33356: PUSH
33357: LD_INT 3
33359: PUSH
33360: LD_INT 2
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: LIST
33367: ST_TO_ADDR
// inside_list := [ us_inner_base , ar_base , ru_inner_base ] ;
33368: LD_ADDR_LOC 71
33372: PUSH
33373: LD_INT 38
33375: PUSH
33376: LD_INT 13
33378: PUSH
33379: LD_INT 39
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: LIST
33386: ST_TO_ADDR
// base_areas := [ us_base , ar_base , ru_base ] ;
33387: LD_ADDR_LOC 72
33391: PUSH
33392: LD_INT 11
33394: PUSH
33395: LD_INT 13
33397: PUSH
33398: LD_INT 12
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: LIST
33405: ST_TO_ADDR
// create_areas := [ us_create , ar_create , ru_create ] ;
33406: LD_ADDR_LOC 73
33410: PUSH
33411: LD_INT 18
33413: PUSH
33414: LD_INT 19
33416: PUSH
33417: LD_INT 17
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: LIST
33424: ST_TO_ADDR
// us_bad := [ ] ;
33425: LD_ADDR_LOC 77
33429: PUSH
33430: EMPTY
33431: ST_TO_ADDR
// ru_bad := [ ] ;
33432: LD_ADDR_LOC 78
33436: PUSH
33437: EMPTY
33438: ST_TO_ADDR
// ar_bad := [ ] ;
33439: LD_ADDR_LOC 79
33443: PUSH
33444: EMPTY
33445: ST_TO_ADDR
// end ;
33446: LD_VAR 0 1
33450: RET
// every 0 0$5.4 do var un , side , list , cargo , n_cargo , engineers ;
33451: GO 33453
33453: DISABLE
33454: LD_INT 0
33456: PPUSH
33457: PPUSH
33458: PPUSH
33459: PPUSH
33460: PPUSH
33461: PPUSH
// begin for side in cpu_list do
33462: LD_ADDR_VAR 0 2
33466: PUSH
33467: LD_EXP 8
33471: PUSH
33472: FOR_IN
33473: IFFALSE 34000
// begin list := GetListOfCratesInArea ( outside_list [ side ] ) ;
33475: LD_ADDR_VAR 0 3
33479: PUSH
33480: LD_LOC 70
33484: PUSH
33485: LD_VAR 0 2
33489: ARRAY
33490: PPUSH
33491: CALL_OW 435
33495: ST_TO_ADDR
// if list then
33496: LD_VAR 0 3
33500: IFFALSE 33868
// begin case side of 1 :
33502: LD_VAR 0 2
33506: PUSH
33507: LD_INT 1
33509: DOUBLE
33510: EQUAL
33511: IFTRUE 33515
33513: GO 33526
33515: POP
// n_cargo := us_cargo_bay ; 2 :
33516: LD_ADDR_VAR 0 5
33520: PUSH
33521: LD_INT 12
33523: ST_TO_ADDR
33524: GO 33565
33526: LD_INT 2
33528: DOUBLE
33529: EQUAL
33530: IFTRUE 33534
33532: GO 33545
33534: POP
// n_cargo := ar_cargo_bay ; 3 :
33535: LD_ADDR_VAR 0 5
33539: PUSH
33540: LD_INT 32
33542: ST_TO_ADDR
33543: GO 33565
33545: LD_INT 3
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33564
33553: POP
// n_cargo := ru_cargo_bay ; end ;
33554: LD_ADDR_VAR 0 5
33558: PUSH
33559: LD_INT 51
33561: ST_TO_ADDR
33562: GO 33565
33564: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
33565: LD_ADDR_VAR 0 4
33569: PUSH
33570: LD_INT 22
33572: PUSH
33573: LD_VAR 0 2
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 21
33584: PUSH
33585: LD_INT 2
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 34
33594: PUSH
33595: LD_VAR 0 5
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: LIST
33608: PPUSH
33609: CALL_OW 69
33613: ST_TO_ADDR
// if cargo then
33614: LD_VAR 0 4
33618: IFFALSE 33868
// begin cargo := cargo [ 1 ] ;
33620: LD_ADDR_VAR 0 4
33624: PUSH
33625: LD_VAR 0 4
33629: PUSH
33630: LD_INT 1
33632: ARRAY
33633: ST_TO_ADDR
// if ( not HasTask ( cargo ) ) and ( not ( [ list [ 1 ] , list [ 2 ] ] in ( us_bad ^ ru_bad ^ ar_bad ) ) ) then
33634: LD_VAR 0 4
33638: PPUSH
33639: CALL_OW 314
33643: NOT
33644: PUSH
33645: LD_VAR 0 3
33649: PUSH
33650: LD_INT 1
33652: ARRAY
33653: PUSH
33654: LD_VAR 0 3
33658: PUSH
33659: LD_INT 2
33661: ARRAY
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_LOC 77
33671: PUSH
33672: LD_LOC 78
33676: ADD
33677: PUSH
33678: LD_LOC 79
33682: ADD
33683: IN
33684: NOT
33685: AND
33686: IFFALSE 33868
// begin ComCollect ( cargo , list [ 1 ] , list [ 2 ] ) ;
33688: LD_VAR 0 4
33692: PPUSH
33693: LD_VAR 0 3
33697: PUSH
33698: LD_INT 1
33700: ARRAY
33701: PPUSH
33702: LD_VAR 0 3
33706: PUSH
33707: LD_INT 2
33709: ARRAY
33710: PPUSH
33711: CALL_OW 117
// case side of us :
33715: LD_VAR 0 2
33719: PUSH
33720: LD_EXP 3
33724: DOUBLE
33725: EQUAL
33726: IFTRUE 33730
33728: GO 33769
33730: POP
// us_bay := us_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ru :
33731: LD_ADDR_LOC 74
33735: PUSH
33736: LD_LOC 74
33740: PUSH
33741: LD_VAR 0 3
33745: PUSH
33746: LD_INT 1
33748: ARRAY
33749: PUSH
33750: LD_VAR 0 3
33754: PUSH
33755: LD_INT 2
33757: ARRAY
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: EMPTY
33764: LIST
33765: ADD
33766: ST_TO_ADDR
33767: GO 33868
33769: LD_EXP 2
33773: DOUBLE
33774: EQUAL
33775: IFTRUE 33779
33777: GO 33818
33779: POP
// ru_bay := ru_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ar :
33780: LD_ADDR_LOC 75
33784: PUSH
33785: LD_LOC 75
33789: PUSH
33790: LD_VAR 0 3
33794: PUSH
33795: LD_INT 1
33797: ARRAY
33798: PUSH
33799: LD_VAR 0 3
33803: PUSH
33804: LD_INT 2
33806: ARRAY
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: EMPTY
33813: LIST
33814: ADD
33815: ST_TO_ADDR
33816: GO 33868
33818: LD_EXP 4
33822: DOUBLE
33823: EQUAL
33824: IFTRUE 33828
33826: GO 33867
33828: POP
// ar_bay := ar_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; end ;
33829: LD_ADDR_LOC 76
33833: PUSH
33834: LD_LOC 76
33838: PUSH
33839: LD_VAR 0 3
33843: PUSH
33844: LD_INT 1
33846: ARRAY
33847: PUSH
33848: LD_VAR 0 3
33852: PUSH
33853: LD_INT 2
33855: ARRAY
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: EMPTY
33862: LIST
33863: ADD
33864: ST_TO_ADDR
33865: GO 33868
33867: POP
// end ; end ; end ; list := GetListOfCratesInArea ( inside_list [ side ] ) ;
33868: LD_ADDR_VAR 0 3
33872: PUSH
33873: LD_LOC 71
33877: PUSH
33878: LD_VAR 0 2
33882: ARRAY
33883: PPUSH
33884: CALL_OW 435
33888: ST_TO_ADDR
// if list then
33889: LD_VAR 0 3
33893: IFFALSE 33998
// begin engineers := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
33895: LD_ADDR_VAR 0 6
33899: PUSH
33900: LD_INT 22
33902: PUSH
33903: LD_VAR 0 2
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 21
33914: PUSH
33915: LD_INT 1
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: PUSH
33922: LD_INT 25
33924: PUSH
33925: LD_INT 2
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: LIST
33936: PPUSH
33937: CALL_OW 69
33941: ST_TO_ADDR
// for un in engineers do
33942: LD_ADDR_VAR 0 1
33946: PUSH
33947: LD_VAR 0 6
33951: PUSH
33952: FOR_IN
33953: IFFALSE 33996
// if not GetUnitMc ( un ) then
33955: LD_VAR 0 1
33959: PPUSH
33960: CALL_OW 388
33964: NOT
33965: IFFALSE 33994
// ComCollect ( un , list [ 1 ] , list [ 2 ] ) ;
33967: LD_VAR 0 1
33971: PPUSH
33972: LD_VAR 0 3
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: LD_VAR 0 3
33985: PUSH
33986: LD_INT 2
33988: ARRAY
33989: PPUSH
33990: CALL_OW 117
33994: GO 33952
33996: POP
33997: POP
// end ; end ;
33998: GO 33472
34000: POP
34001: POP
// enable ;
34002: ENABLE
// end ;
34003: PPOPN 6
34005: END
// every 1 1$0.6 do var un , n_cargo , cargo , side ;
34006: GO 34008
34008: DISABLE
34009: LD_INT 0
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
// begin for side in cpu_list do
34015: LD_ADDR_VAR 0 4
34019: PUSH
34020: LD_EXP 8
34024: PUSH
34025: FOR_IN
34026: IFFALSE 34465
// begin case side of 1 :
34028: LD_VAR 0 4
34032: PUSH
34033: LD_INT 1
34035: DOUBLE
34036: EQUAL
34037: IFTRUE 34041
34039: GO 34052
34041: POP
// n_cargo := us_cargo_bay ; 2 :
34042: LD_ADDR_VAR 0 2
34046: PUSH
34047: LD_INT 12
34049: ST_TO_ADDR
34050: GO 34091
34052: LD_INT 2
34054: DOUBLE
34055: EQUAL
34056: IFTRUE 34060
34058: GO 34071
34060: POP
// n_cargo := ar_cargo_bay ; 3 :
34061: LD_ADDR_VAR 0 2
34065: PUSH
34066: LD_INT 32
34068: ST_TO_ADDR
34069: GO 34091
34071: LD_INT 3
34073: DOUBLE
34074: EQUAL
34075: IFTRUE 34079
34077: GO 34090
34079: POP
// n_cargo := ru_cargo_bay ; end ;
34080: LD_ADDR_VAR 0 2
34084: PUSH
34085: LD_INT 51
34087: ST_TO_ADDR
34088: GO 34091
34090: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34091: LD_ADDR_VAR 0 3
34095: PUSH
34096: LD_INT 22
34098: PUSH
34099: LD_VAR 0 4
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 21
34110: PUSH
34111: LD_INT 2
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 34
34120: PUSH
34121: LD_VAR 0 2
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: LIST
34134: PPUSH
34135: CALL_OW 69
34139: ST_TO_ADDR
// if not ( cargo or FilterUnitsInArea ( base_areas [ side ] , [ [ f_side , you ] ] ) ) then
34140: LD_VAR 0 3
34144: PUSH
34145: LD_LOC 72
34149: PUSH
34150: LD_VAR 0 4
34154: ARRAY
34155: PPUSH
34156: LD_INT 22
34158: PUSH
34159: LD_EXP 1
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: EMPTY
34169: LIST
34170: PPUSH
34171: CALL_OW 70
34175: OR
34176: NOT
34177: IFFALSE 34463
// begin uc_side := side ;
34179: LD_ADDR_OWVAR 20
34183: PUSH
34184: LD_VAR 0 4
34188: ST_TO_ADDR
// case side of 1 :
34189: LD_VAR 0 4
34193: PUSH
34194: LD_INT 1
34196: DOUBLE
34197: EQUAL
34198: IFTRUE 34202
34200: GO 34213
34202: POP
// uc_nation := nation_american ; 2 :
34203: LD_ADDR_OWVAR 21
34207: PUSH
34208: LD_INT 1
34210: ST_TO_ADDR
34211: GO 34252
34213: LD_INT 2
34215: DOUBLE
34216: EQUAL
34217: IFTRUE 34221
34219: GO 34232
34221: POP
// uc_nation := nation_arabian ; 3 :
34222: LD_ADDR_OWVAR 21
34226: PUSH
34227: LD_INT 2
34229: ST_TO_ADDR
34230: GO 34252
34232: LD_INT 3
34234: DOUBLE
34235: EQUAL
34236: IFTRUE 34240
34238: GO 34251
34240: POP
// uc_nation := nation_russian ; end ;
34241: LD_ADDR_OWVAR 21
34245: PUSH
34246: LD_INT 3
34248: ST_TO_ADDR
34249: GO 34252
34251: POP
// uc_direction := Rand ( 0 , 5 ) ;
34252: LD_ADDR_OWVAR 24
34256: PUSH
34257: LD_INT 0
34259: PPUSH
34260: LD_INT 5
34262: PPUSH
34263: CALL_OW 12
34267: ST_TO_ADDR
// case side of 1 :
34268: LD_VAR 0 4
34272: PUSH
34273: LD_INT 1
34275: DOUBLE
34276: EQUAL
34277: IFTRUE 34281
34279: GO 34292
34281: POP
// vc_chassis := us_medium_tracked ; 2 :
34282: LD_ADDR_OWVAR 37
34286: PUSH
34287: LD_INT 3
34289: ST_TO_ADDR
34290: GO 34331
34292: LD_INT 2
34294: DOUBLE
34295: EQUAL
34296: IFTRUE 34300
34298: GO 34311
34300: POP
// vc_chassis := ar_half_tracked ; 3 :
34301: LD_ADDR_OWVAR 37
34305: PUSH
34306: LD_INT 14
34308: ST_TO_ADDR
34309: GO 34331
34311: LD_INT 3
34313: DOUBLE
34314: EQUAL
34315: IFTRUE 34319
34317: GO 34330
34319: POP
// vc_chassis := ru_medium_tracked ; end ;
34320: LD_ADDR_OWVAR 37
34324: PUSH
34325: LD_INT 22
34327: ST_TO_ADDR
34328: GO 34331
34330: POP
// vc_engine := engine_siberite ;
34331: LD_ADDR_OWVAR 39
34335: PUSH
34336: LD_INT 3
34338: ST_TO_ADDR
// case side of 1 :
34339: LD_VAR 0 4
34343: PUSH
34344: LD_INT 1
34346: DOUBLE
34347: EQUAL
34348: IFTRUE 34352
34350: GO 34363
34352: POP
// vc_control := control_computer ; 2 :
34353: LD_ADDR_OWVAR 38
34357: PUSH
34358: LD_INT 3
34360: ST_TO_ADDR
34361: GO 34402
34363: LD_INT 2
34365: DOUBLE
34366: EQUAL
34367: IFTRUE 34371
34369: GO 34382
34371: POP
// vc_control := control_apeman ; 3 :
34372: LD_ADDR_OWVAR 38
34376: PUSH
34377: LD_INT 5
34379: ST_TO_ADDR
34380: GO 34402
34382: LD_INT 3
34384: DOUBLE
34385: EQUAL
34386: IFTRUE 34390
34388: GO 34401
34390: POP
// vc_control := control_computer ; end ;
34391: LD_ADDR_OWVAR 38
34395: PUSH
34396: LD_INT 3
34398: ST_TO_ADDR
34399: GO 34402
34401: POP
// vc_weapon := n_cargo ;
34402: LD_ADDR_OWVAR 40
34406: PUSH
34407: LD_VAR 0 2
34411: ST_TO_ADDR
// un := CreateVehicle ;
34412: LD_ADDR_VAR 0 1
34416: PUSH
34417: CALL_OW 45
34421: ST_TO_ADDR
// while GetTag ( 83 ) do
34422: LD_INT 83
34424: PPUSH
34425: CALL_OW 110
34429: IFFALSE 34440
// wait ( 0 0$1 ) ;
34431: LD_INT 35
34433: PPUSH
34434: CALL_OW 67
34438: GO 34422
// PlaceUnitArea ( un , create_areas [ side ] , false ) ;
34440: LD_VAR 0 1
34444: PPUSH
34445: LD_LOC 73
34449: PUSH
34450: LD_VAR 0 4
34454: ARRAY
34455: PPUSH
34456: LD_INT 0
34458: PPUSH
34459: CALL_OW 49
// end ; end ;
34463: GO 34025
34465: POP
34466: POP
// enable ;
34467: ENABLE
// end ;
34468: PPOPN 4
34470: END
// export function remove_bad_crates ( side ) ; var list , un , x , y ; begin
34471: LD_INT 0
34473: PPUSH
34474: PPUSH
34475: PPUSH
34476: PPUSH
34477: PPUSH
// case side of us :
34478: LD_VAR 0 1
34482: PUSH
34483: LD_EXP 3
34487: DOUBLE
34488: EQUAL
34489: IFTRUE 34493
34491: GO 34564
34493: POP
// begin x := us_bay [ us_bad ] [ 1 ] ;
34494: LD_ADDR_VAR 0 5
34498: PUSH
34499: LD_LOC 74
34503: PUSH
34504: LD_LOC 77
34508: ARRAY
34509: PUSH
34510: LD_INT 1
34512: ARRAY
34513: ST_TO_ADDR
// y := us_bay [ us_bad ] [ 2 ] ;
34514: LD_ADDR_VAR 0 6
34518: PUSH
34519: LD_LOC 74
34523: PUSH
34524: LD_LOC 77
34528: ARRAY
34529: PUSH
34530: LD_INT 2
34532: ARRAY
34533: ST_TO_ADDR
// us_bad := us_bad ^ [ [ x , y ] ] ;
34534: LD_ADDR_LOC 77
34538: PUSH
34539: LD_LOC 77
34543: PUSH
34544: LD_VAR 0 5
34548: PUSH
34549: LD_VAR 0 6
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: EMPTY
34559: LIST
34560: ADD
34561: ST_TO_ADDR
// end ; ru :
34562: GO 34727
34564: LD_EXP 2
34568: DOUBLE
34569: EQUAL
34570: IFTRUE 34574
34572: GO 34645
34574: POP
// begin x := ru_bay [ us_bad ] [ 1 ] ;
34575: LD_ADDR_VAR 0 5
34579: PUSH
34580: LD_LOC 75
34584: PUSH
34585: LD_LOC 77
34589: ARRAY
34590: PUSH
34591: LD_INT 1
34593: ARRAY
34594: ST_TO_ADDR
// y := ru_bay [ us_bad ] [ 2 ] ;
34595: LD_ADDR_VAR 0 6
34599: PUSH
34600: LD_LOC 75
34604: PUSH
34605: LD_LOC 77
34609: ARRAY
34610: PUSH
34611: LD_INT 2
34613: ARRAY
34614: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34615: LD_ADDR_LOC 78
34619: PUSH
34620: LD_LOC 78
34624: PUSH
34625: LD_VAR 0 5
34629: PUSH
34630: LD_VAR 0 6
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: EMPTY
34640: LIST
34641: ADD
34642: ST_TO_ADDR
// end ; ar :
34643: GO 34727
34645: LD_EXP 4
34649: DOUBLE
34650: EQUAL
34651: IFTRUE 34655
34653: GO 34726
34655: POP
// begin x := ar_bay [ us_bad ] [ 1 ] ;
34656: LD_ADDR_VAR 0 5
34660: PUSH
34661: LD_LOC 76
34665: PUSH
34666: LD_LOC 77
34670: ARRAY
34671: PUSH
34672: LD_INT 1
34674: ARRAY
34675: ST_TO_ADDR
// y := ar_bay [ us_bad ] [ 2 ] ;
34676: LD_ADDR_VAR 0 6
34680: PUSH
34681: LD_LOC 76
34685: PUSH
34686: LD_LOC 77
34690: ARRAY
34691: PUSH
34692: LD_INT 2
34694: ARRAY
34695: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34696: LD_ADDR_LOC 78
34700: PUSH
34701: LD_LOC 78
34705: PUSH
34706: LD_VAR 0 5
34710: PUSH
34711: LD_VAR 0 6
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: EMPTY
34721: LIST
34722: ADD
34723: ST_TO_ADDR
// end ; end ;
34724: GO 34727
34726: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ;
34727: LD_ADDR_VAR 0 3
34731: PUSH
34732: LD_INT 22
34734: PUSH
34735: LD_VAR 0 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 21
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 25
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 50
34766: PUSH
34767: EMPTY
34768: LIST
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: PPUSH
34776: CALL_OW 69
34780: ST_TO_ADDR
// for un in list do
34781: LD_ADDR_VAR 0 4
34785: PUSH
34786: LD_VAR 0 3
34790: PUSH
34791: FOR_IN
34792: IFFALSE 34845
// if not GetUnitMc ( un ) then
34794: LD_VAR 0 4
34798: PPUSH
34799: CALL_OW 388
34803: NOT
34804: IFFALSE 34843
// begin ComRemember ( un ) ;
34806: LD_VAR 0 4
34810: PPUSH
34811: CALL_OW 143
// AddComCollect ( un , x , y ) ;
34815: LD_VAR 0 4
34819: PPUSH
34820: LD_VAR 0 5
34824: PPUSH
34825: LD_VAR 0 6
34829: PPUSH
34830: CALL_OW 177
// AddComReturn ( un ) ;
34834: LD_VAR 0 4
34838: PPUSH
34839: CALL_OW 204
// end ;
34843: GO 34791
34845: POP
34846: POP
// end ;
34847: LD_VAR 0 2
34851: RET
// every 0 0$7.9 trigger us_bad do var un , list ;
34852: LD_LOC 77
34856: IFFALSE 34953
34858: GO 34860
34860: DISABLE
34861: LD_INT 0
34863: PPUSH
34864: PPUSH
// begin list := [ ] ;
34865: LD_ADDR_VAR 0 2
34869: PUSH
34870: EMPTY
34871: ST_TO_ADDR
// for un in us_bad do
34872: LD_ADDR_VAR 0 1
34876: PUSH
34877: LD_LOC 77
34881: PUSH
34882: FOR_IN
34883: IFFALSE 34940
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
34885: LD_INT 35
34887: PPUSH
34888: LD_VAR 0 1
34892: PUSH
34893: LD_INT 1
34895: ARRAY
34896: PPUSH
34897: LD_VAR 0 1
34901: PUSH
34902: LD_INT 2
34904: ARRAY
34905: PPUSH
34906: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
34910: LD_INT 35
34912: PPUSH
34913: CALL_OW 435
34917: IFFALSE 34938
// list := list ^ [ un ] ;
34919: LD_ADDR_VAR 0 2
34923: PUSH
34924: LD_VAR 0 2
34928: PUSH
34929: LD_VAR 0 1
34933: PUSH
34934: EMPTY
34935: LIST
34936: ADD
34937: ST_TO_ADDR
// end ;
34938: GO 34882
34940: POP
34941: POP
// us_bad := list ;
34942: LD_ADDR_LOC 77
34946: PUSH
34947: LD_VAR 0 2
34951: ST_TO_ADDR
// enable ;
34952: ENABLE
// end ;
34953: PPOPN 2
34955: END
// every 0 0$7.8 trigger ru_bad do var un , list ;
34956: LD_LOC 78
34960: IFFALSE 35057
34962: GO 34964
34964: DISABLE
34965: LD_INT 0
34967: PPUSH
34968: PPUSH
// begin list := [ ] ;
34969: LD_ADDR_VAR 0 2
34973: PUSH
34974: EMPTY
34975: ST_TO_ADDR
// for un in ru_bad do
34976: LD_ADDR_VAR 0 1
34980: PUSH
34981: LD_LOC 78
34985: PUSH
34986: FOR_IN
34987: IFFALSE 35044
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
34989: LD_INT 35
34991: PPUSH
34992: LD_VAR 0 1
34996: PUSH
34997: LD_INT 1
34999: ARRAY
35000: PPUSH
35001: LD_VAR 0 1
35005: PUSH
35006: LD_INT 2
35008: ARRAY
35009: PPUSH
35010: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35014: LD_INT 35
35016: PPUSH
35017: CALL_OW 435
35021: IFFALSE 35042
// list := list ^ [ un ] ;
35023: LD_ADDR_VAR 0 2
35027: PUSH
35028: LD_VAR 0 2
35032: PUSH
35033: LD_VAR 0 1
35037: PUSH
35038: EMPTY
35039: LIST
35040: ADD
35041: ST_TO_ADDR
// end ;
35042: GO 34986
35044: POP
35045: POP
// ru_bad := list ;
35046: LD_ADDR_LOC 78
35050: PUSH
35051: LD_VAR 0 2
35055: ST_TO_ADDR
// enable ;
35056: ENABLE
// end ;
35057: PPOPN 2
35059: END
// every 0 0$7.7 trigger ar_bad do var un , list ;
35060: LD_LOC 79
35064: IFFALSE 35161
35066: GO 35068
35068: DISABLE
35069: LD_INT 0
35071: PPUSH
35072: PPUSH
// begin list := [ ] ;
35073: LD_ADDR_VAR 0 2
35077: PUSH
35078: EMPTY
35079: ST_TO_ADDR
// for un in ar_bad do
35080: LD_ADDR_VAR 0 1
35084: PUSH
35085: LD_LOC 79
35089: PUSH
35090: FOR_IN
35091: IFFALSE 35148
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35093: LD_INT 35
35095: PPUSH
35096: LD_VAR 0 1
35100: PUSH
35101: LD_INT 1
35103: ARRAY
35104: PPUSH
35105: LD_VAR 0 1
35109: PUSH
35110: LD_INT 2
35112: ARRAY
35113: PPUSH
35114: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35118: LD_INT 35
35120: PPUSH
35121: CALL_OW 435
35125: IFFALSE 35146
// list := list ^ [ un ] ;
35127: LD_ADDR_VAR 0 2
35131: PUSH
35132: LD_VAR 0 2
35136: PUSH
35137: LD_VAR 0 1
35141: PUSH
35142: EMPTY
35143: LIST
35144: ADD
35145: ST_TO_ADDR
// end ;
35146: GO 35090
35148: POP
35149: POP
// ar_bad := list ;
35150: LD_ADDR_LOC 79
35154: PUSH
35155: LD_VAR 0 2
35159: ST_TO_ADDR
// enable ;
35160: ENABLE
// end ; end_of_file
35161: PPOPN 2
35163: END
// export function check_remote ( veh ) ; var un , towers , list , all_in , veh_n , veh_l , mech ; begin
35164: LD_INT 0
35166: PPUSH
35167: PPUSH
35168: PPUSH
35169: PPUSH
35170: PPUSH
35171: PPUSH
35172: PPUSH
35173: PPUSH
// list := [ ] ;
35174: LD_ADDR_VAR 0 5
35178: PUSH
35179: EMPTY
35180: ST_TO_ADDR
// veh_l := FilterAllUnits ( [ [ f_side , us ] , [ f_control , control_remote ] , [ f_ok ] ] ) union veh diff 0 ;
35181: LD_ADDR_VAR 0 8
35185: PUSH
35186: LD_INT 22
35188: PUSH
35189: LD_EXP 3
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 33
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 50
35210: PUSH
35211: EMPTY
35212: LIST
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: LIST
35218: PPUSH
35219: CALL_OW 69
35223: PUSH
35224: LD_VAR 0 1
35228: UNION
35229: PUSH
35230: LD_INT 0
35232: DIFF
35233: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35234: LD_ADDR_VAR 0 4
35238: PUSH
35239: LD_INT 22
35241: PUSH
35242: LD_EXP 3
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 30
35253: PUSH
35254: LD_INT 36
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 50
35263: PUSH
35264: EMPTY
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: PPUSH
35272: CALL_OW 69
35276: ST_TO_ADDR
// if not towers then
35277: LD_VAR 0 4
35281: NOT
35282: IFFALSE 35286
// exit ;
35284: GO 35881
// towers := towers [ 1 ] ;
35286: LD_ADDR_VAR 0 4
35290: PUSH
35291: LD_VAR 0 4
35295: PUSH
35296: LD_INT 1
35298: ARRAY
35299: ST_TO_ADDR
// all_in := UnitsInside ( towers ) ;
35300: LD_ADDR_VAR 0 6
35304: PUSH
35305: LD_VAR 0 4
35309: PPUSH
35310: CALL_OW 313
35314: ST_TO_ADDR
// mech := all_in ^ ( FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] , [ f_ok ] ] ) diff reserved_people [ us ] ) ;
35315: LD_ADDR_VAR 0 9
35319: PUSH
35320: LD_VAR 0 6
35324: PUSH
35325: LD_INT 22
35327: PUSH
35328: LD_EXP 3
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 21
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 25
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 50
35359: PUSH
35360: EMPTY
35361: LIST
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: LIST
35367: LIST
35368: PPUSH
35369: CALL_OW 69
35373: PUSH
35374: LD_EXP 71
35378: PUSH
35379: LD_EXP 3
35383: ARRAY
35384: DIFF
35385: ADD
35386: ST_TO_ADDR
// for un in mech do
35387: LD_ADDR_VAR 0 3
35391: PUSH
35392: LD_VAR 0 9
35396: PUSH
35397: FOR_IN
35398: IFFALSE 35432
// list := list ^ FindMaxSkill ( mech diff list , skill_mechanical ) ;
35400: LD_ADDR_VAR 0 5
35404: PUSH
35405: LD_VAR 0 5
35409: PUSH
35410: LD_VAR 0 9
35414: PUSH
35415: LD_VAR 0 5
35419: DIFF
35420: PPUSH
35421: LD_INT 3
35423: PPUSH
35424: CALL_OW 433
35428: ADD
35429: ST_TO_ADDR
35430: GO 35397
35432: POP
35433: POP
// mech := [ ] ;
35434: LD_ADDR_VAR 0 9
35438: PUSH
35439: EMPTY
35440: ST_TO_ADDR
// veh_n := 0 + veh_l ;
35441: LD_ADDR_VAR 0 7
35445: PUSH
35446: LD_INT 0
35448: PUSH
35449: LD_VAR 0 8
35453: PLUS
35454: ST_TO_ADDR
// for un in list do
35455: LD_ADDR_VAR 0 3
35459: PUSH
35460: LD_VAR 0 5
35464: PUSH
35465: FOR_IN
35466: IFFALSE 35536
// if ( veh_n > 0 ) or ( ( list diff mech ) > 6 ) then
35468: LD_VAR 0 7
35472: PUSH
35473: LD_INT 0
35475: GREATER
35476: PUSH
35477: LD_VAR 0 5
35481: PUSH
35482: LD_VAR 0 9
35486: DIFF
35487: PUSH
35488: LD_INT 6
35490: GREATER
35491: OR
35492: IFFALSE 35534
// begin mech := mech ^ un ;
35494: LD_ADDR_VAR 0 9
35498: PUSH
35499: LD_VAR 0 9
35503: PUSH
35504: LD_VAR 0 3
35508: ADD
35509: ST_TO_ADDR
// veh_n := veh_n - GetSkill ( un , skill_mechanical ) ;
35510: LD_ADDR_VAR 0 7
35514: PUSH
35515: LD_VAR 0 7
35519: PUSH
35520: LD_VAR 0 3
35524: PPUSH
35525: LD_INT 3
35527: PPUSH
35528: CALL_OW 259
35532: MINUS
35533: ST_TO_ADDR
// end ;
35534: GO 35465
35536: POP
35537: POP
// un := reserved_people [ us ] ^ mech ;
35538: LD_ADDR_VAR 0 3
35542: PUSH
35543: LD_EXP 71
35547: PUSH
35548: LD_EXP 3
35552: ARRAY
35553: PUSH
35554: LD_VAR 0 9
35558: ADD
35559: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35560: LD_ADDR_EXP 71
35564: PUSH
35565: LD_EXP 71
35569: PPUSH
35570: LD_EXP 3
35574: PPUSH
35575: CALL_OW 3
35579: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35580: LD_ADDR_EXP 71
35584: PUSH
35585: LD_EXP 71
35589: PPUSH
35590: LD_EXP 3
35594: PPUSH
35595: LD_VAR 0 3
35599: PPUSH
35600: CALL_OW 2
35604: ST_TO_ADDR
// list := UnitsInside ( towers ) diff mech ;
35605: LD_ADDR_VAR 0 5
35609: PUSH
35610: LD_VAR 0 4
35614: PPUSH
35615: CALL_OW 313
35619: PUSH
35620: LD_VAR 0 9
35624: DIFF
35625: ST_TO_ADDR
// if list then
35626: LD_VAR 0 5
35630: IFFALSE 35786
// begin un := reserved_people [ us ] diff list ;
35632: LD_ADDR_VAR 0 3
35636: PUSH
35637: LD_EXP 71
35641: PUSH
35642: LD_EXP 3
35646: ARRAY
35647: PUSH
35648: LD_VAR 0 5
35652: DIFF
35653: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35654: LD_ADDR_EXP 71
35658: PUSH
35659: LD_EXP 71
35663: PPUSH
35664: LD_EXP 3
35668: PPUSH
35669: CALL_OW 3
35673: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35674: LD_ADDR_EXP 71
35678: PUSH
35679: LD_EXP 71
35683: PPUSH
35684: LD_EXP 3
35688: PPUSH
35689: LD_VAR 0 3
35693: PPUSH
35694: CALL_OW 2
35698: ST_TO_ADDR
// ComExitBuilding ( list ) ;
35699: LD_VAR 0 5
35703: PPUSH
35704: CALL_OW 122
// un := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
35708: LD_ADDR_VAR 0 3
35712: PUSH
35713: LD_INT 22
35715: PUSH
35716: LD_EXP 3
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 2
35727: PUSH
35728: LD_INT 30
35730: PUSH
35731: LD_INT 2
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 30
35740: PUSH
35741: LD_INT 3
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: LIST
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PPUSH
35757: CALL_OW 69
35761: ST_TO_ADDR
// if un then
35762: LD_VAR 0 3
35766: IFFALSE 35786
// AddComMoveUnit ( list , un [ 1 ] ) ;
35768: LD_VAR 0 5
35772: PPUSH
35773: LD_VAR 0 3
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: CALL_OW 172
// end ; repeat ComMoveUnit ( mech , towers ) ;
35786: LD_VAR 0 9
35790: PPUSH
35791: LD_VAR 0 4
35795: PPUSH
35796: CALL_OW 112
// all_in := true ;
35800: LD_ADDR_VAR 0 6
35804: PUSH
35805: LD_INT 1
35807: ST_TO_ADDR
// for un in mech do
35808: LD_ADDR_VAR 0 3
35812: PUSH
35813: LD_VAR 0 9
35817: PUSH
35818: FOR_IN
35819: IFFALSE 35851
// if not ( IsInUnit ( un ) = towers ) then
35821: LD_VAR 0 3
35825: PPUSH
35826: CALL_OW 310
35830: PUSH
35831: LD_VAR 0 4
35835: EQUAL
35836: NOT
35837: IFFALSE 35849
// begin all_in := false ;
35839: LD_ADDR_VAR 0 6
35843: PUSH
35844: LD_INT 0
35846: ST_TO_ADDR
// break ;
35847: GO 35851
// end ;
35849: GO 35818
35851: POP
35852: POP
// wait ( 0 0$1 ) ;
35853: LD_INT 35
35855: PPUSH
35856: CALL_OW 67
// until all_in ;
35860: LD_VAR 0 6
35864: IFFALSE 35786
// ComLinkTo ( veh_l , towers ) ;
35866: LD_VAR 0 8
35870: PPUSH
35871: LD_VAR 0 4
35875: PPUSH
35876: CALL_OW 135
// enable ;
35880: ENABLE
// end ;
35881: LD_VAR 0 2
35885: RET
// every 0 0$10 do var list , tower ;
35886: GO 35888
35888: DISABLE
35889: LD_INT 0
35891: PPUSH
35892: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_ok ] , [ f_control , control_remote ] , f_not , [ f_linked ] ] ) ;
35893: LD_ADDR_VAR 0 1
35897: PUSH
35898: LD_INT 22
35900: PUSH
35901: LD_EXP 3
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 50
35912: PUSH
35913: EMPTY
35914: LIST
35915: PUSH
35916: LD_INT 33
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 3
35928: PUSH
35929: LD_INT 61
35931: PUSH
35932: EMPTY
35933: LIST
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: PPUSH
35942: CALL_OW 69
35946: ST_TO_ADDR
// if list then
35947: LD_VAR 0 1
35951: IFFALSE 36035
// begin tower := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35953: LD_ADDR_VAR 0 2
35957: PUSH
35958: LD_INT 22
35960: PUSH
35961: LD_EXP 3
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 30
35972: PUSH
35973: LD_INT 36
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 50
35982: PUSH
35983: EMPTY
35984: LIST
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: LIST
35990: PPUSH
35991: CALL_OW 69
35995: ST_TO_ADDR
// if tower then
35996: LD_VAR 0 2
36000: IFFALSE 36018
// tower := tower [ 1 ] else
36002: LD_ADDR_VAR 0 2
36006: PUSH
36007: LD_VAR 0 2
36011: PUSH
36012: LD_INT 1
36014: ARRAY
36015: ST_TO_ADDR
36016: GO 36021
// begin enable ;
36018: ENABLE
// exit ;
36019: GO 36036
// end ; ComLinkTo ( list , tower ) ;
36021: LD_VAR 0 1
36025: PPUSH
36026: LD_VAR 0 2
36030: PPUSH
36031: CALL_OW 135
// end ; enable ;
36035: ENABLE
// end ; end_of_file
36036: PPOPN 2
36038: END
// export us_sib_wait , ru_sib_wait ; var time_to_end ; export function init_sib_rocket ; begin
36039: LD_INT 0
36041: PPUSH
// us_sib_wait := false ;
36042: LD_ADDR_EXP 74
36046: PUSH
36047: LD_INT 0
36049: ST_TO_ADDR
// ru_sib_wait := false ;
36050: LD_ADDR_EXP 75
36054: PUSH
36055: LD_INT 0
36057: ST_TO_ADDR
// time_to_end := [ 85 85$0 , 65 65$0 , 45 45$0 ] [ difficulty ] ;
36058: LD_ADDR_LOC 80
36062: PUSH
36063: LD_INT 178500
36065: PUSH
36066: LD_INT 136500
36068: PUSH
36069: LD_INT 94500
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: LIST
36076: PUSH
36077: LD_OWVAR 67
36081: ARRAY
36082: ST_TO_ADDR
// end ;
36083: LD_VAR 0 1
36087: RET
// every 0 0$1.5 trigger TICK > time_to_end marked 4 do var factory , zdroje ;
36088: LD_OWVAR 1
36092: PUSH
36093: LD_LOC 80
36097: GREATER
36098: IFFALSE 36331
36100: GO 36102
36102: DISABLE
36103: LD_INT 0
36105: PPUSH
36106: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_factory ] ] ) ;
36107: LD_ADDR_VAR 0 1
36111: PUSH
36112: LD_INT 22
36114: PUSH
36115: LD_EXP 3
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 30
36126: PUSH
36127: LD_INT 3
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PPUSH
36138: CALL_OW 69
36142: ST_TO_ADDR
// if factory then
36143: LD_VAR 0 1
36147: IFFALSE 36330
// begin factory := factory [ 1 ] ;
36149: LD_ADDR_VAR 0 1
36153: PUSH
36154: LD_VAR 0 1
36158: PUSH
36159: LD_INT 1
36161: ARRAY
36162: ST_TO_ADDR
// if us_siberium_rocket in AvailableWeaponList ( factory ) then
36163: LD_INT 8
36165: PUSH
36166: LD_VAR 0 1
36170: PPUSH
36171: CALL_OW 478
36175: IN
36176: IFFALSE 36330
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36178: LD_ADDR_VAR 0 2
36182: PUSH
36183: LD_VAR 0 1
36187: PPUSH
36188: CALL_OW 274
36192: PPUSH
36193: CALL_OW 279
36197: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36198: LD_VAR 0 2
36202: PUSH
36203: LD_INT 1
36205: ARRAY
36206: PUSH
36207: LD_INT 75
36209: GREATEREQUAL
36210: PUSH
36211: LD_VAR 0 2
36215: PUSH
36216: LD_INT 2
36218: ARRAY
36219: PUSH
36220: LD_INT 30
36222: GREATEREQUAL
36223: PUSH
36224: LD_VAR 0 2
36228: PUSH
36229: LD_INT 3
36231: ARRAY
36232: PUSH
36233: LD_INT 70
36235: GREATEREQUAL
36236: OR
36237: AND
36238: PUSH
36239: LD_VAR 0 2
36243: PUSH
36244: LD_INT 3
36246: ARRAY
36247: PUSH
36248: LD_INT 60
36250: GREATEREQUAL
36251: AND
36252: IFFALSE 36322
// begin if zdroje [ 3 ] >= 70 then
36254: LD_VAR 0 2
36258: PUSH
36259: LD_INT 3
36261: ARRAY
36262: PUSH
36263: LD_INT 70
36265: GREATEREQUAL
36266: IFFALSE 36291
// ComConstruct ( factory , us_morphling , engine_siberite , control_remote , us_siberium_rocket ) else
36268: LD_VAR 0 1
36272: PPUSH
36273: LD_INT 5
36275: PPUSH
36276: LD_INT 3
36278: PPUSH
36279: LD_INT 2
36281: PPUSH
36282: LD_INT 8
36284: PPUSH
36285: CALL_OW 125
36289: GO 36312
// ComConstruct ( factory , us_morphling , engine_combustion , control_remote , us_siberium_rocket ) ;
36291: LD_VAR 0 1
36295: PPUSH
36296: LD_INT 5
36298: PPUSH
36299: LD_INT 1
36301: PPUSH
36302: LD_INT 2
36304: PPUSH
36305: LD_INT 8
36307: PPUSH
36308: CALL_OW 125
// us_sib_wait := false ;
36312: LD_ADDR_EXP 74
36316: PUSH
36317: LD_INT 0
36319: ST_TO_ADDR
// end else
36320: GO 36330
// us_sib_wait := true ;
36322: LD_ADDR_EXP 74
36326: PUSH
36327: LD_INT 1
36329: ST_TO_ADDR
// end ; end ; enable ;
36330: ENABLE
// end ;
36331: PPOPN 2
36333: END
// every 0 0$1.5 trigger TICK > time_to_end marked 5 do var factory , zdroje ;
36334: LD_OWVAR 1
36338: PUSH
36339: LD_LOC 80
36343: GREATER
36344: IFFALSE 36577
36346: GO 36348
36348: DISABLE
36349: LD_INT 0
36351: PPUSH
36352: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , ru ] , [ f_btype , b_factory ] ] ) ;
36353: LD_ADDR_VAR 0 1
36357: PUSH
36358: LD_INT 22
36360: PUSH
36361: LD_EXP 2
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 30
36372: PUSH
36373: LD_INT 3
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PPUSH
36384: CALL_OW 69
36388: ST_TO_ADDR
// if factory then
36389: LD_VAR 0 1
36393: IFFALSE 36576
// begin factory := factory [ 1 ] ;
36395: LD_ADDR_VAR 0 1
36399: PUSH
36400: LD_VAR 0 1
36404: PUSH
36405: LD_INT 1
36407: ARRAY
36408: ST_TO_ADDR
// if ru_siberium_rocket in AvailableWeaponList ( factory ) then
36409: LD_INT 48
36411: PUSH
36412: LD_VAR 0 1
36416: PPUSH
36417: CALL_OW 478
36421: IN
36422: IFFALSE 36576
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36424: LD_ADDR_VAR 0 2
36428: PUSH
36429: LD_VAR 0 1
36433: PPUSH
36434: CALL_OW 274
36438: PPUSH
36439: CALL_OW 279
36443: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36444: LD_VAR 0 2
36448: PUSH
36449: LD_INT 1
36451: ARRAY
36452: PUSH
36453: LD_INT 75
36455: GREATEREQUAL
36456: PUSH
36457: LD_VAR 0 2
36461: PUSH
36462: LD_INT 2
36464: ARRAY
36465: PUSH
36466: LD_INT 30
36468: GREATEREQUAL
36469: PUSH
36470: LD_VAR 0 2
36474: PUSH
36475: LD_INT 3
36477: ARRAY
36478: PUSH
36479: LD_INT 70
36481: GREATEREQUAL
36482: OR
36483: AND
36484: PUSH
36485: LD_VAR 0 2
36489: PUSH
36490: LD_INT 3
36492: ARRAY
36493: PUSH
36494: LD_INT 60
36496: GREATEREQUAL
36497: AND
36498: IFFALSE 36568
// begin if zdroje [ 3 ] >= 70 then
36500: LD_VAR 0 2
36504: PUSH
36505: LD_INT 3
36507: ARRAY
36508: PUSH
36509: LD_INT 70
36511: GREATEREQUAL
36512: IFFALSE 36537
// ComConstruct ( factory , ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ) else
36514: LD_VAR 0 1
36518: PPUSH
36519: LD_INT 23
36521: PPUSH
36522: LD_INT 3
36524: PPUSH
36525: LD_INT 3
36527: PPUSH
36528: LD_INT 48
36530: PPUSH
36531: CALL_OW 125
36535: GO 36558
// ComConstruct ( factory , ru_heavy_wheeled , engine_combustion , control_computer , ru_siberium_rocket ) ;
36537: LD_VAR 0 1
36541: PPUSH
36542: LD_INT 23
36544: PPUSH
36545: LD_INT 1
36547: PPUSH
36548: LD_INT 3
36550: PPUSH
36551: LD_INT 48
36553: PPUSH
36554: CALL_OW 125
// ru_sib_wait := false ;
36558: LD_ADDR_EXP 75
36562: PUSH
36563: LD_INT 0
36565: ST_TO_ADDR
// end else
36566: GO 36576
// ru_sib_wait := true ;
36568: LD_ADDR_EXP 75
36572: PUSH
36573: LD_INT 1
36575: ST_TO_ADDR
// end ; end ; enable ;
36576: ENABLE
// end ;
36577: PPOPN 2
36579: END
// export function send_sib_to_US ( veh ) ; var n_check , s_check , send ; begin
36580: LD_INT 0
36582: PPUSH
36583: PPUSH
36584: PPUSH
36585: PPUSH
// repeat n_check := FilterUnitsInArea ( north_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36586: LD_ADDR_VAR 0 3
36590: PUSH
36591: LD_INT 25
36593: PPUSH
36594: LD_INT 21
36596: PUSH
36597: LD_INT 2
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 3
36606: PUSH
36607: LD_INT 22
36609: PUSH
36610: LD_EXP 2
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: LIST
36623: PPUSH
36624: CALL_OW 70
36628: ST_TO_ADDR
// s_check := FilterUnitsInArea ( south_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36629: LD_ADDR_VAR 0 4
36633: PUSH
36634: LD_INT 26
36636: PPUSH
36637: LD_INT 21
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 3
36649: PUSH
36650: LD_INT 22
36652: PUSH
36653: LD_EXP 2
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: PPUSH
36667: CALL_OW 70
36671: ST_TO_ADDR
// wait ( 0 0$2 ) ;
36672: LD_INT 70
36674: PPUSH
36675: CALL_OW 67
// until ( n_check < 3 ) and ( s_check < 3 ) ;
36679: LD_VAR 0 3
36683: PUSH
36684: LD_INT 3
36686: LESS
36687: PUSH
36688: LD_VAR 0 4
36692: PUSH
36693: LD_INT 3
36695: LESS
36696: AND
36697: IFFALSE 36586
// ComMoveXY ( veh , 144 , 65 ) ;
36699: LD_VAR 0 1
36703: PPUSH
36704: LD_INT 144
36706: PPUSH
36707: LD_INT 65
36709: PPUSH
36710: CALL_OW 111
// if n_check < s_check then
36714: LD_VAR 0 3
36718: PUSH
36719: LD_VAR 0 4
36723: LESS
36724: IFFALSE 36773
// begin AddComMoveXY ( veh , 87 , 35 ) ;
36726: LD_VAR 0 1
36730: PPUSH
36731: LD_INT 87
36733: PPUSH
36734: LD_INT 35
36736: PPUSH
36737: CALL_OW 171
// AddComMoveXY ( veh , 42 , 16 ) ;
36741: LD_VAR 0 1
36745: PPUSH
36746: LD_INT 42
36748: PPUSH
36749: LD_INT 16
36751: PPUSH
36752: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 56 ) ;
36756: LD_VAR 0 1
36760: PPUSH
36761: LD_INT 41
36763: PPUSH
36764: LD_INT 56
36766: PPUSH
36767: CALL_OW 176
// end else
36771: GO 36865
// begin AddComMoveXY ( veh , 141 , 116 ) ;
36773: LD_VAR 0 1
36777: PPUSH
36778: LD_INT 141
36780: PPUSH
36781: LD_INT 116
36783: PPUSH
36784: CALL_OW 171
// AddComMoveXY ( veh , 109 , 110 ) ;
36788: LD_VAR 0 1
36792: PPUSH
36793: LD_INT 109
36795: PPUSH
36796: LD_INT 110
36798: PPUSH
36799: CALL_OW 171
// if GetChassis ( veh ) = ru_heavy_tracked then
36803: LD_VAR 0 1
36807: PPUSH
36808: CALL_OW 265
36812: PUSH
36813: LD_INT 24
36815: EQUAL
36816: IFFALSE 36835
// AddComMoveXY ( veh , 86 , 106 ) else
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_INT 86
36825: PPUSH
36826: LD_INT 106
36828: PPUSH
36829: CALL_OW 171
36833: GO 36850
// AddComMoveXY ( veh , 85 , 75 ) ;
36835: LD_VAR 0 1
36839: PPUSH
36840: LD_INT 85
36842: PPUSH
36843: LD_INT 75
36845: PPUSH
36846: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 66 ) ;
36850: LD_VAR 0 1
36854: PPUSH
36855: LD_INT 41
36857: PPUSH
36858: LD_INT 66
36860: PPUSH
36861: CALL_OW 176
// end ; end ; end_of_file
36865: LD_VAR 0 2
36869: RET
// export artefact_number , artefact_num , artefact_size ; export labs_in_use ; export function init_alien_research ; var art_icons , art_events , art_difficulty , art_cost , art_recharge ; begin
36870: LD_INT 0
36872: PPUSH
36873: PPUSH
36874: PPUSH
36875: PPUSH
36876: PPUSH
36877: PPUSH
// artefact_number := 3 ;
36878: LD_ADDR_EXP 76
36882: PUSH
36883: LD_INT 3
36885: ST_TO_ADDR
// artefact_num := [ 0 , 0 , 1 , 2 , 3 ] ;
36886: LD_ADDR_EXP 77
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: LD_INT 0
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: LD_INT 3
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: LIST
36910: LIST
36911: LIST
36912: ST_TO_ADDR
// artefact_size := [ 3 , 4 , 5 ] ;
36913: LD_ADDR_EXP 78
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: LD_INT 4
36923: PUSH
36924: LD_INT 5
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: LIST
36931: ST_TO_ADDR
// art_icons := [ [ art_exp_left , art_use_eye ] , [ art_exp_mid , art_use_sibexplosion ] , [ art_exp_right , art_use_power ] ] ;
36932: LD_ADDR_VAR 0 2
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: LD_INT 4
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: PUSH
36950: LD_INT 5
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 3
36959: PUSH
36960: LD_INT 9
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: ST_TO_ADDR
// art_events := [ art_place , art_unit , art_place ] ;
36972: LD_ADDR_VAR 0 3
36976: PUSH
36977: LD_INT 3
36979: PUSH
36980: LD_INT 4
36982: PUSH
36983: LD_INT 3
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: LIST
36990: ST_TO_ADDR
// art_difficulty := [ 150 , 250 , 400 ] ;
36991: LD_ADDR_VAR 0 4
36995: PUSH
36996: LD_INT 150
36998: PUSH
36999: LD_INT 250
37001: PUSH
37002: LD_INT 400
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: LIST
37009: ST_TO_ADDR
// art_cost := [ 1 + difficulty , 2 + ( 3 * difficulty ) , 30 + ( 10 * difficulty ) ] ;
37010: LD_ADDR_VAR 0 5
37014: PUSH
37015: LD_INT 1
37017: PUSH
37018: LD_OWVAR 67
37022: PLUS
37023: PUSH
37024: LD_INT 2
37026: PUSH
37027: LD_INT 3
37029: PUSH
37030: LD_OWVAR 67
37034: MUL
37035: PLUS
37036: PUSH
37037: LD_INT 30
37039: PUSH
37040: LD_INT 10
37042: PUSH
37043: LD_OWVAR 67
37047: MUL
37048: PLUS
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: LIST
37054: ST_TO_ADDR
// art_recharge := [ 6 * difficulty , 12 * difficulty , 10000 ] ;
37055: LD_ADDR_VAR 0 6
37059: PUSH
37060: LD_INT 6
37062: PUSH
37063: LD_OWVAR 67
37067: MUL
37068: PUSH
37069: LD_INT 12
37071: PUSH
37072: LD_OWVAR 67
37076: MUL
37077: PUSH
37078: LD_INT 10000
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: LIST
37085: ST_TO_ADDR
// Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ;
37086: LD_VAR 0 2
37090: PPUSH
37091: LD_VAR 0 3
37095: PPUSH
37096: LD_VAR 0 4
37100: PPUSH
37101: LD_VAR 0 5
37105: PPUSH
37106: LD_VAR 0 6
37110: PPUSH
37111: CALL 37120 0 5
// end ;
37115: LD_VAR 0 1
37119: RET
// function Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ; var un , i , side , base ; begin
37120: LD_INT 0
37122: PPUSH
37123: PPUSH
37124: PPUSH
37125: PPUSH
37126: PPUSH
// disable ( 1 ) ;
37127: LD_INT 1
37129: DISABLE_MARKED
// disable ( 5 ) ;
37130: LD_INT 5
37132: DISABLE_MARKED
// disable ( 6 ) ;
37133: LD_INT 6
37135: DISABLE_MARKED
// disable ( 7 ) ;
37136: LD_INT 7
37138: DISABLE_MARKED
// for side = 1 to 8 do
37139: LD_ADDR_VAR 0 9
37143: PUSH
37144: DOUBLE
37145: LD_INT 1
37147: DEC
37148: ST_TO_ADDR
37149: LD_INT 8
37151: PUSH
37152: FOR_TO
37153: IFFALSE 37169
// SetArtifactRes ( side , state_enabled ) ;
37155: LD_VAR 0 9
37159: PPUSH
37160: LD_INT 1
37162: PPUSH
37163: CALL_OW 467
37167: GO 37152
37169: POP
37170: POP
// for un = 0 to ( artefact_number - 1 ) do
37171: LD_ADDR_VAR 0 7
37175: PUSH
37176: DOUBLE
37177: LD_INT 0
37179: DEC
37180: ST_TO_ADDR
37181: LD_EXP 76
37185: PUSH
37186: LD_INT 1
37188: MINUS
37189: PUSH
37190: FOR_TO
37191: IFFALSE 37589
// begin base := un * 100 ;
37193: LD_ADDR_VAR 0 10
37197: PUSH
37198: LD_VAR 0 7
37202: PUSH
37203: LD_INT 100
37205: MUL
37206: ST_TO_ADDR
// SetTag ( base + 01 , art_icons [ un + 1 ] [ 1 ] ) ;
37207: LD_VAR 0 10
37211: PUSH
37212: LD_INT 1
37214: PLUS
37215: PPUSH
37216: LD_VAR 0 1
37220: PUSH
37221: LD_VAR 0 7
37225: PUSH
37226: LD_INT 1
37228: PLUS
37229: ARRAY
37230: PUSH
37231: LD_INT 1
37233: ARRAY
37234: PPUSH
37235: CALL_OW 109
// SetTag ( base + 02 , art_icons [ un + 1 ] [ 2 ] ) ;
37239: LD_VAR 0 10
37243: PUSH
37244: LD_INT 2
37246: PLUS
37247: PPUSH
37248: LD_VAR 0 1
37252: PUSH
37253: LD_VAR 0 7
37257: PUSH
37258: LD_INT 1
37260: PLUS
37261: ARRAY
37262: PUSH
37263: LD_INT 2
37265: ARRAY
37266: PPUSH
37267: CALL_OW 109
// SetTag ( base + 03 , art_events [ un + 1 ] ) ;
37271: LD_VAR 0 10
37275: PUSH
37276: LD_INT 3
37278: PLUS
37279: PPUSH
37280: LD_VAR 0 2
37284: PUSH
37285: LD_VAR 0 7
37289: PUSH
37290: LD_INT 1
37292: PLUS
37293: ARRAY
37294: PPUSH
37295: CALL_OW 109
// SetTag ( base + 05 , art_difficulty [ un + 1 ] ) ;
37299: LD_VAR 0 10
37303: PUSH
37304: LD_INT 5
37306: PLUS
37307: PPUSH
37308: LD_VAR 0 3
37312: PUSH
37313: LD_VAR 0 7
37317: PUSH
37318: LD_INT 1
37320: PLUS
37321: ARRAY
37322: PPUSH
37323: CALL_OW 109
// SetTag ( base + 06 , art_cost [ un + 1 ] ) ;
37327: LD_VAR 0 10
37331: PUSH
37332: LD_INT 6
37334: PLUS
37335: PPUSH
37336: LD_VAR 0 4
37340: PUSH
37341: LD_VAR 0 7
37345: PUSH
37346: LD_INT 1
37348: PLUS
37349: ARRAY
37350: PPUSH
37351: CALL_OW 109
// SetTag ( base + 07 , art_recharge [ un + 1 ] ) ;
37355: LD_VAR 0 10
37359: PUSH
37360: LD_INT 7
37362: PLUS
37363: PPUSH
37364: LD_VAR 0 5
37368: PUSH
37369: LD_VAR 0 7
37373: PUSH
37374: LD_INT 1
37376: PLUS
37377: ARRAY
37378: PPUSH
37379: CALL_OW 109
// SetTag ( base + 08 , false ) ;
37383: LD_VAR 0 10
37387: PUSH
37388: LD_INT 8
37390: PLUS
37391: PPUSH
37392: LD_INT 0
37394: PPUSH
37395: CALL_OW 109
// SetTag ( base + 09 , false ) ;
37399: LD_VAR 0 10
37403: PUSH
37404: LD_INT 9
37406: PLUS
37407: PPUSH
37408: LD_INT 0
37410: PPUSH
37411: CALL_OW 109
// SetTag ( base + 11 , 0 ) ;
37415: LD_VAR 0 10
37419: PUSH
37420: LD_INT 11
37422: PLUS
37423: PPUSH
37424: LD_INT 0
37426: PPUSH
37427: CALL_OW 109
// SetTag ( base + 12 , false ) ;
37431: LD_VAR 0 10
37435: PUSH
37436: LD_INT 12
37438: PLUS
37439: PPUSH
37440: LD_INT 0
37442: PPUSH
37443: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37447: LD_VAR 0 10
37451: PUSH
37452: LD_INT 13
37454: PLUS
37455: PPUSH
37456: LD_INT 0
37458: PPUSH
37459: CALL_OW 109
// for i = 0 to 7 do
37463: LD_ADDR_VAR 0 8
37467: PUSH
37468: DOUBLE
37469: LD_INT 0
37471: DEC
37472: ST_TO_ADDR
37473: LD_INT 7
37475: PUSH
37476: FOR_TO
37477: IFFALSE 37585
// begin SetTag ( base + i * 10 + 21 , false ) ;
37479: LD_VAR 0 10
37483: PUSH
37484: LD_VAR 0 8
37488: PUSH
37489: LD_INT 10
37491: MUL
37492: PLUS
37493: PUSH
37494: LD_INT 21
37496: PLUS
37497: PPUSH
37498: LD_INT 0
37500: PPUSH
37501: CALL_OW 109
// SetTag ( base + i * 10 + 22 , 0 ) ;
37505: LD_VAR 0 10
37509: PUSH
37510: LD_VAR 0 8
37514: PUSH
37515: LD_INT 10
37517: MUL
37518: PLUS
37519: PUSH
37520: LD_INT 22
37522: PLUS
37523: PPUSH
37524: LD_INT 0
37526: PPUSH
37527: CALL_OW 109
// SetTag ( base + i * 10 + 23 , 0 ) ;
37531: LD_VAR 0 10
37535: PUSH
37536: LD_VAR 0 8
37540: PUSH
37541: LD_INT 10
37543: MUL
37544: PLUS
37545: PUSH
37546: LD_INT 23
37548: PLUS
37549: PPUSH
37550: LD_INT 0
37552: PPUSH
37553: CALL_OW 109
// SetTag ( base + i * 10 + 25 , 0 ) ;
37557: LD_VAR 0 10
37561: PUSH
37562: LD_VAR 0 8
37566: PUSH
37567: LD_INT 10
37569: MUL
37570: PLUS
37571: PUSH
37572: LD_INT 25
37574: PLUS
37575: PPUSH
37576: LD_INT 0
37578: PPUSH
37579: CALL_OW 109
// end ;
37583: GO 37476
37585: POP
37586: POP
// end ;
37587: GO 37190
37589: POP
37590: POP
// enable ( 20 ) ;
37591: LD_INT 20
37593: ENABLE_MARKED
// labs_in_use := [ ] ;
37594: LD_ADDR_EXP 79
37598: PUSH
37599: EMPTY
37600: ST_TO_ADDR
// end ;
37601: LD_VAR 0 6
37605: RET
// on ArtifactUnloaded ( un , size ) do var art , base ;
37606: LD_INT 0
37608: PPUSH
37609: PPUSH
// begin art := artefact_num [ size ] ;
37610: LD_ADDR_VAR 0 3
37614: PUSH
37615: LD_EXP 77
37619: PUSH
37620: LD_VAR 0 2
37624: ARRAY
37625: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37626: LD_ADDR_VAR 0 4
37630: PUSH
37631: LD_VAR 0 3
37635: PUSH
37636: LD_INT 1
37638: MINUS
37639: PUSH
37640: LD_INT 100
37642: MUL
37643: ST_TO_ADDR
// SetTag ( base + 09 , false ) ;
37644: LD_VAR 0 4
37648: PUSH
37649: LD_INT 9
37651: PLUS
37652: PPUSH
37653: LD_INT 0
37655: PPUSH
37656: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37660: LD_VAR 0 4
37664: PUSH
37665: LD_INT 13
37667: PLUS
37668: PPUSH
37669: LD_INT 0
37671: PPUSH
37672: CALL_OW 109
// Init_Lab ( art ) ;
37676: LD_VAR 0 3
37680: PPUSH
37681: CALL 39217 0 1
// end ;
37685: PPOPN 4
37687: END
// on ArtifactLoaded ( un , size ) do var art , base , side ;
37688: LD_INT 0
37690: PPUSH
37691: PPUSH
37692: PPUSH
// begin art := artefact_num [ size ] ;
37693: LD_ADDR_VAR 0 3
37697: PUSH
37698: LD_EXP 77
37702: PUSH
37703: LD_VAR 0 2
37707: ARRAY
37708: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37709: LD_ADDR_VAR 0 4
37713: PUSH
37714: LD_VAR 0 3
37718: PUSH
37719: LD_INT 1
37721: MINUS
37722: PUSH
37723: LD_INT 100
37725: MUL
37726: ST_TO_ADDR
// SetTag ( base + 09 , true ) ;
37727: LD_VAR 0 4
37731: PUSH
37732: LD_INT 9
37734: PLUS
37735: PPUSH
37736: LD_INT 1
37738: PPUSH
37739: CALL_OW 109
// SetTag ( base + 13 , un ) ;
37743: LD_VAR 0 4
37747: PUSH
37748: LD_INT 13
37750: PLUS
37751: PPUSH
37752: LD_VAR 0 1
37756: PPUSH
37757: CALL_OW 109
// if GetTag ( base + 11 ) then
37761: LD_VAR 0 4
37765: PUSH
37766: LD_INT 11
37768: PLUS
37769: PPUSH
37770: CALL_OW 110
37774: IFFALSE 37937
// begin side := GetSide ( GetTag ( base + 11 ) ) ;
37776: LD_ADDR_VAR 0 5
37780: PUSH
37781: LD_VAR 0 4
37785: PUSH
37786: LD_INT 11
37788: PLUS
37789: PPUSH
37790: CALL_OW 110
37794: PPUSH
37795: CALL_OW 255
37799: ST_TO_ADDR
// if GetTag ( base + 12 ) then
37800: LD_VAR 0 4
37804: PUSH
37805: LD_INT 12
37807: PLUS
37808: PPUSH
37809: CALL_OW 110
37813: IFFALSE 37881
// begin ComCancel ( GetTag ( base + 11 ) ) ;
37815: LD_VAR 0 4
37819: PUSH
37820: LD_INT 11
37822: PLUS
37823: PPUSH
37824: CALL_OW 110
37828: PPUSH
37829: CALL_OW 127
// wait ( 5 ) ;
37833: LD_INT 5
37835: PPUSH
37836: CALL_OW 67
// labs_in_use := labs_in_use diff GetTag ( base + 11 ) ;
37840: LD_ADDR_EXP 79
37844: PUSH
37845: LD_EXP 79
37849: PUSH
37850: LD_VAR 0 4
37854: PUSH
37855: LD_INT 11
37857: PLUS
37858: PPUSH
37859: CALL_OW 110
37863: DIFF
37864: ST_TO_ADDR
// SetTag ( base + 12 , false ) ;
37865: LD_VAR 0 4
37869: PUSH
37870: LD_INT 12
37872: PLUS
37873: PPUSH
37874: LD_INT 0
37876: PPUSH
37877: CALL_OW 109
// end ; if not GetTag ( base + side * 10 + 11 ) then
37881: LD_VAR 0 4
37885: PUSH
37886: LD_VAR 0 5
37890: PUSH
37891: LD_INT 10
37893: MUL
37894: PLUS
37895: PUSH
37896: LD_INT 11
37898: PLUS
37899: PPUSH
37900: CALL_OW 110
37904: NOT
37905: IFFALSE 37921
// DeInit_Lab ( side , art ) ;
37907: LD_VAR 0 5
37911: PPUSH
37912: LD_VAR 0 3
37916: PPUSH
37917: CALL 39911 0 2
// SetTag ( base + 11 , 0 ) ;
37921: LD_VAR 0 4
37925: PUSH
37926: LD_INT 11
37928: PLUS
37929: PPUSH
37930: LD_INT 0
37932: PPUSH
37933: CALL_OW 109
// end ; end ;
37937: PPOPN 5
37939: END
// on ArtifactResearchComplete ( lab ) do var un , side ;
37940: LD_INT 0
37942: PPUSH
37943: PPUSH
// begin side := GetSide ( lab ) - 1 ;
37944: LD_ADDR_VAR 0 3
37948: PUSH
37949: LD_VAR 0 1
37953: PPUSH
37954: CALL_OW 255
37958: PUSH
37959: LD_INT 1
37961: MINUS
37962: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
37963: LD_ADDR_VAR 0 2
37967: PUSH
37968: DOUBLE
37969: LD_INT 0
37971: DEC
37972: ST_TO_ADDR
37973: LD_EXP 76
37977: PUSH
37978: LD_INT 1
37980: MINUS
37981: PUSH
37982: FOR_TO
37983: IFFALSE 38025
// if lab = GetTag ( un * 100 + 11 ) then
37985: LD_VAR 0 1
37989: PUSH
37990: LD_VAR 0 2
37994: PUSH
37995: LD_INT 100
37997: MUL
37998: PUSH
37999: LD_INT 11
38001: PLUS
38002: PPUSH
38003: CALL_OW 110
38007: EQUAL
38008: IFFALSE 38023
// Init_Lab ( un + 1 ) ;
38010: LD_VAR 0 2
38014: PUSH
38015: LD_INT 1
38017: PLUS
38018: PPUSH
38019: CALL 39217 0 1
38023: GO 37982
38025: POP
38026: POP
// end ;
38027: PPOPN 3
38029: END
// on SpecResearchCancel ( lab , progress ) do var un , side ;
38030: LD_INT 0
38032: PPUSH
38033: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38034: LD_ADDR_VAR 0 4
38038: PUSH
38039: LD_VAR 0 1
38043: PPUSH
38044: CALL_OW 255
38048: PUSH
38049: LD_INT 1
38051: MINUS
38052: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38053: LD_ADDR_VAR 0 3
38057: PUSH
38058: DOUBLE
38059: LD_INT 0
38061: DEC
38062: ST_TO_ADDR
38063: LD_EXP 76
38067: PUSH
38068: LD_INT 1
38070: MINUS
38071: PUSH
38072: FOR_TO
38073: IFFALSE 38191
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38075: LD_VAR 0 3
38079: PUSH
38080: LD_INT 100
38082: MUL
38083: PUSH
38084: LD_INT 11
38086: PLUS
38087: PPUSH
38088: CALL_OW 110
38092: PUSH
38093: LD_VAR 0 1
38097: EQUAL
38098: PUSH
38099: LD_VAR 0 3
38103: PUSH
38104: LD_INT 100
38106: MUL
38107: PUSH
38108: LD_INT 12
38110: PLUS
38111: PPUSH
38112: CALL_OW 110
38116: AND
38117: IFFALSE 38189
// begin SetTag ( un * 100 + side * 10 + 22 , progress ) ;
38119: LD_VAR 0 3
38123: PUSH
38124: LD_INT 100
38126: MUL
38127: PUSH
38128: LD_VAR 0 4
38132: PUSH
38133: LD_INT 10
38135: MUL
38136: PLUS
38137: PUSH
38138: LD_INT 22
38140: PLUS
38141: PPUSH
38142: LD_VAR 0 2
38146: PPUSH
38147: CALL_OW 109
// SetTag ( un * 100 + 12 , false ) ;
38151: LD_VAR 0 3
38155: PUSH
38156: LD_INT 100
38158: MUL
38159: PUSH
38160: LD_INT 12
38162: PLUS
38163: PPUSH
38164: LD_INT 0
38166: PPUSH
38167: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38171: LD_ADDR_EXP 79
38175: PUSH
38176: LD_EXP 79
38180: PUSH
38181: LD_VAR 0 1
38185: DIFF
38186: ST_TO_ADDR
// break ;
38187: GO 38191
// end ;
38189: GO 38072
38191: POP
38192: POP
// Update_Artefact ( lab ) ;
38193: LD_VAR 0 1
38197: PPUSH
38198: CALL 40050 0 1
// end ;
38202: PPOPN 4
38204: END
// on SpecResearchComplete ( lab ) do var un , side ;
38205: LD_INT 0
38207: PPUSH
38208: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38209: LD_ADDR_VAR 0 3
38213: PUSH
38214: LD_VAR 0 1
38218: PPUSH
38219: CALL_OW 255
38223: PUSH
38224: LD_INT 1
38226: MINUS
38227: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38228: LD_ADDR_VAR 0 2
38232: PUSH
38233: DOUBLE
38234: LD_INT 0
38236: DEC
38237: ST_TO_ADDR
38238: LD_EXP 76
38242: PUSH
38243: LD_INT 1
38245: MINUS
38246: PUSH
38247: FOR_TO
38248: IFFALSE 38454
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38250: LD_VAR 0 2
38254: PUSH
38255: LD_INT 100
38257: MUL
38258: PUSH
38259: LD_INT 11
38261: PLUS
38262: PPUSH
38263: CALL_OW 110
38267: PUSH
38268: LD_VAR 0 1
38272: EQUAL
38273: PUSH
38274: LD_VAR 0 2
38278: PUSH
38279: LD_INT 100
38281: MUL
38282: PUSH
38283: LD_INT 12
38285: PLUS
38286: PPUSH
38287: CALL_OW 110
38291: AND
38292: IFFALSE 38452
// begin SetTag ( un * 100 + 12 , false ) ;
38294: LD_VAR 0 2
38298: PUSH
38299: LD_INT 100
38301: MUL
38302: PUSH
38303: LD_INT 12
38305: PLUS
38306: PPUSH
38307: LD_INT 0
38309: PPUSH
38310: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 21 , true ) ;
38314: LD_VAR 0 2
38318: PUSH
38319: LD_INT 100
38321: MUL
38322: PUSH
38323: LD_VAR 0 3
38327: PUSH
38328: LD_INT 10
38330: MUL
38331: PLUS
38332: PUSH
38333: LD_INT 21
38335: PLUS
38336: PPUSH
38337: LD_INT 1
38339: PPUSH
38340: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 25 , lab ) ;
38344: LD_VAR 0 2
38348: PUSH
38349: LD_INT 100
38351: MUL
38352: PUSH
38353: LD_VAR 0 3
38357: PUSH
38358: LD_INT 10
38360: MUL
38361: PLUS
38362: PUSH
38363: LD_INT 25
38365: PLUS
38366: PPUSH
38367: LD_VAR 0 1
38371: PPUSH
38372: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38376: LD_ADDR_EXP 79
38380: PUSH
38381: LD_EXP 79
38385: PUSH
38386: LD_VAR 0 1
38390: DIFF
38391: ST_TO_ADDR
// case un of 0 :
38392: LD_VAR 0 2
38396: PUSH
38397: LD_INT 0
38399: DOUBLE
38400: EQUAL
38401: IFTRUE 38405
38403: GO 38415
38405: POP
// Hint ( ATSpy ) ; 1 :
38406: LD_STRING ATSpy
38408: PPUSH
38409: CALL_OW 339
38413: GO 38452
38415: LD_INT 1
38417: DOUBLE
38418: EQUAL
38419: IFTRUE 38423
38421: GO 38433
38423: POP
// Hint ( ATDetonated ) ; 2 :
38424: LD_STRING ATDetonated
38426: PPUSH
38427: CALL_OW 339
38431: GO 38452
38433: LD_INT 2
38435: DOUBLE
38436: EQUAL
38437: IFTRUE 38441
38439: GO 38451
38441: POP
// Hint ( ArterfactTeleport ) ; end ;
38442: LD_STRING ArterfactTeleport
38444: PPUSH
38445: CALL_OW 339
38449: GO 38452
38451: POP
// end ;
38452: GO 38247
38454: POP
38455: POP
// Update_Artefact ( lab ) ;
38456: LD_VAR 0 1
38460: PPUSH
38461: CALL 40050 0 1
// end ;
38465: PPOPN 3
38467: END
// on ArtifactUsed ( side , number , p1 , p2 ) do var un , succes , art , base ;
38468: LD_INT 0
38470: PPUSH
38471: PPUSH
38472: PPUSH
38473: PPUSH
// begin art := ( ( number - 1 ) mod 3 ) + 1 ;
38474: LD_ADDR_VAR 0 7
38478: PUSH
38479: LD_VAR 0 2
38483: PUSH
38484: LD_INT 1
38486: MINUS
38487: PUSH
38488: LD_INT 3
38490: MOD
38491: PUSH
38492: LD_INT 1
38494: PLUS
38495: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38496: LD_ADDR_VAR 0 8
38500: PUSH
38501: LD_VAR 0 7
38505: PUSH
38506: LD_INT 1
38508: MINUS
38509: PUSH
38510: LD_INT 100
38512: MUL
38513: ST_TO_ADDR
// if number <= 3 then
38514: LD_VAR 0 2
38518: PUSH
38519: LD_INT 3
38521: LESSEQUAL
38522: IFFALSE 38754
// begin SetSpecResearch ( GetTag ( base + 11 ) , GetTag ( base + 05 ) , true ) ;
38524: LD_VAR 0 8
38528: PUSH
38529: LD_INT 11
38531: PLUS
38532: PPUSH
38533: CALL_OW 110
38537: PPUSH
38538: LD_VAR 0 8
38542: PUSH
38543: LD_INT 5
38545: PLUS
38546: PPUSH
38547: CALL_OW 110
38551: PPUSH
38552: LD_INT 1
38554: PPUSH
38555: CALL_OW 486
// SetWorkingProgress ( GetTag ( base + 11 ) , GetTag ( base + side * 10 + 12 ) ) ;
38559: LD_VAR 0 8
38563: PUSH
38564: LD_INT 11
38566: PLUS
38567: PPUSH
38568: CALL_OW 110
38572: PPUSH
38573: LD_VAR 0 8
38577: PUSH
38578: LD_VAR 0 1
38582: PUSH
38583: LD_INT 10
38585: MUL
38586: PLUS
38587: PUSH
38588: LD_INT 12
38590: PLUS
38591: PPUSH
38592: CALL_OW 110
38596: PPUSH
38597: CALL_OW 329
// SetTag ( base + 12 , true ) ;
38601: LD_VAR 0 8
38605: PUSH
38606: LD_INT 12
38608: PLUS
38609: PPUSH
38610: LD_INT 1
38612: PPUSH
38613: CALL_OW 109
// labs_in_use := labs_in_use ^ GetTag ( base + 11 ) ;
38617: LD_ADDR_EXP 79
38621: PUSH
38622: LD_EXP 79
38626: PUSH
38627: LD_VAR 0 8
38631: PUSH
38632: LD_INT 11
38634: PLUS
38635: PPUSH
38636: CALL_OW 110
38640: ADD
38641: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38642: LD_ADDR_VAR 0 5
38646: PUSH
38647: DOUBLE
38648: LD_INT 0
38650: DEC
38651: ST_TO_ADDR
38652: LD_EXP 76
38656: PUSH
38657: LD_INT 1
38659: MINUS
38660: PUSH
38661: FOR_TO
38662: IFFALSE 38750
// if GetTag ( base + 11 ) in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
38664: LD_VAR 0 8
38668: PUSH
38669: LD_INT 11
38671: PLUS
38672: PPUSH
38673: CALL_OW 110
38677: PUSH
38678: LD_VAR 0 5
38682: PUSH
38683: LD_INT 100
38685: MUL
38686: PUSH
38687: LD_INT 11
38689: PLUS
38690: PPUSH
38691: CALL_OW 110
38695: PUSH
38696: LD_VAR 0 5
38700: PUSH
38701: LD_INT 100
38703: MUL
38704: PUSH
38705: LD_VAR 0 1
38709: PUSH
38710: LD_INT 10
38712: MUL
38713: PLUS
38714: PUSH
38715: LD_INT 15
38717: PLUS
38718: PPUSH
38719: CALL_OW 110
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: IN
38728: IFFALSE 38748
// DeInit_Lab ( side , un + 1 ) ;
38730: LD_VAR 0 1
38734: PPUSH
38735: LD_VAR 0 5
38739: PUSH
38740: LD_INT 1
38742: PLUS
38743: PPUSH
38744: CALL 39911 0 2
38748: GO 38661
38750: POP
38751: POP
// end else
38752: GO 38928
// begin succes := false ;
38754: LD_ADDR_VAR 0 6
38758: PUSH
38759: LD_INT 0
38761: ST_TO_ADDR
// case art of 1 :
38762: LD_VAR 0 7
38766: PUSH
38767: LD_INT 1
38769: DOUBLE
38770: EQUAL
38771: IFTRUE 38775
38773: GO 38803
38775: POP
// succes := Show_me_map ( side , p1 , p2 ) ; 2 :
38776: LD_ADDR_VAR 0 6
38780: PUSH
38781: LD_VAR 0 1
38785: PPUSH
38786: LD_VAR 0 3
38790: PPUSH
38791: LD_VAR 0 4
38795: PPUSH
38796: CALL 40350 0 3
38800: ST_TO_ADDR
38801: GO 38871
38803: LD_INT 2
38805: DOUBLE
38806: EQUAL
38807: IFTRUE 38811
38809: GO 38834
38811: POP
// succes := Destroy_siberite ( side , p1 ) ; 3 :
38812: LD_ADDR_VAR 0 6
38816: PUSH
38817: LD_VAR 0 1
38821: PPUSH
38822: LD_VAR 0 3
38826: PPUSH
38827: CALL 40588 0 2
38831: ST_TO_ADDR
38832: GO 38871
38834: LD_INT 3
38836: DOUBLE
38837: EQUAL
38838: IFTRUE 38842
38840: GO 38870
38842: POP
// succes := Mass_Teleport ( side , p1 , p2 ) ; end ;
38843: LD_ADDR_VAR 0 6
38847: PUSH
38848: LD_VAR 0 1
38852: PPUSH
38853: LD_VAR 0 3
38857: PPUSH
38858: LD_VAR 0 4
38862: PPUSH
38863: CALL 40913 0 3
38867: ST_TO_ADDR
38868: GO 38871
38870: POP
// if succes then
38871: LD_VAR 0 6
38875: IFFALSE 38928
// begin SetTag ( base + side * 10 + 13 , GetTag ( base + 07 ) ) ;
38877: LD_VAR 0 8
38881: PUSH
38882: LD_VAR 0 1
38886: PUSH
38887: LD_INT 10
38889: MUL
38890: PLUS
38891: PUSH
38892: LD_INT 13
38894: PLUS
38895: PPUSH
38896: LD_VAR 0 8
38900: PUSH
38901: LD_INT 7
38903: PLUS
38904: PPUSH
38905: CALL_OW 110
38909: PPUSH
38910: CALL_OW 109
// Shadow_Artefact ( side , art ) ;
38914: LD_VAR 0 1
38918: PPUSH
38919: LD_VAR 0 7
38923: PPUSH
38924: CALL 38931 0 2
// end ; end ; end ;
38928: PPOPN 8
38930: END
// export function Shadow_Artefact ( side , art ) ; var base , lab ; begin
38931: LD_INT 0
38933: PPUSH
38934: PPUSH
38935: PPUSH
// base := ( art - 1 ) * 100 ;
38936: LD_ADDR_VAR 0 4
38940: PUSH
38941: LD_VAR 0 2
38945: PUSH
38946: LD_INT 1
38948: MINUS
38949: PUSH
38950: LD_INT 100
38952: MUL
38953: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
38954: LD_ADDR_VAR 0 5
38958: PUSH
38959: LD_VAR 0 4
38963: PUSH
38964: LD_VAR 0 1
38968: PUSH
38969: LD_INT 10
38971: MUL
38972: PLUS
38973: PUSH
38974: LD_INT 15
38976: PLUS
38977: PPUSH
38978: CALL_OW 110
38982: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) then
38983: LD_VAR 0 5
38987: PUSH
38988: LD_VAR 0 5
38992: PUSH
38993: LD_EXP 79
38997: IN
38998: NOT
38999: AND
39000: IFFALSE 39058
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_gray , lab ) ;
39002: LD_VAR 0 1
39006: PPUSH
39007: LD_VAR 0 4
39011: PUSH
39012: LD_INT 1
39014: PLUS
39015: PUSH
39016: LD_VAR 0 4
39020: PUSH
39021: LD_VAR 0 1
39025: PUSH
39026: LD_INT 10
39028: MUL
39029: PLUS
39030: PUSH
39031: LD_INT 11
39033: PLUS
39034: PPUSH
39035: CALL_OW 110
39039: PLUS
39040: PPUSH
39041: CALL_OW 110
39045: PPUSH
39046: LD_INT 1
39048: PPUSH
39049: LD_VAR 0 5
39053: PPUSH
39054: CALL_OW 468
// end ;
39058: LD_VAR 0 3
39062: RET
// export function Highlight_Artefact ( side , art ) ; var base , lab ; begin
39063: LD_INT 0
39065: PPUSH
39066: PPUSH
39067: PPUSH
// base := ( art - 1 ) * 100 ;
39068: LD_ADDR_VAR 0 4
39072: PUSH
39073: LD_VAR 0 2
39077: PUSH
39078: LD_INT 1
39080: MINUS
39081: PUSH
39082: LD_INT 100
39084: MUL
39085: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39086: LD_ADDR_VAR 0 5
39090: PUSH
39091: LD_VAR 0 4
39095: PUSH
39096: LD_VAR 0 1
39100: PUSH
39101: LD_INT 10
39103: MUL
39104: PLUS
39105: PUSH
39106: LD_INT 15
39108: PLUS
39109: PPUSH
39110: CALL_OW 110
39114: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) and UnitsInside ( lab ) then
39115: LD_VAR 0 5
39119: PUSH
39120: LD_VAR 0 5
39124: PUSH
39125: LD_EXP 79
39129: IN
39130: NOT
39131: AND
39132: PUSH
39133: LD_VAR 0 5
39137: PPUSH
39138: CALL_OW 313
39142: AND
39143: IFFALSE 39212
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , GetTag ( base + 03 ) , lab ) ;
39145: LD_VAR 0 1
39149: PPUSH
39150: LD_VAR 0 4
39154: PUSH
39155: LD_INT 1
39157: PLUS
39158: PUSH
39159: LD_VAR 0 4
39163: PUSH
39164: LD_VAR 0 1
39168: PUSH
39169: LD_INT 10
39171: MUL
39172: PLUS
39173: PUSH
39174: LD_INT 11
39176: PLUS
39177: PPUSH
39178: CALL_OW 110
39182: PLUS
39183: PPUSH
39184: CALL_OW 110
39188: PPUSH
39189: LD_VAR 0 4
39193: PUSH
39194: LD_INT 3
39196: PLUS
39197: PPUSH
39198: CALL_OW 110
39202: PPUSH
39203: LD_VAR 0 5
39207: PPUSH
39208: CALL_OW 468
// end ;
39212: LD_VAR 0 3
39216: RET
// export function Init_Lab ( art ) ; var list , side , base , dist , state , art_hex , nearest_lab ; begin
39217: LD_INT 0
39219: PPUSH
39220: PPUSH
39221: PPUSH
39222: PPUSH
39223: PPUSH
39224: PPUSH
39225: PPUSH
39226: PPUSH
// art_hex := FindArtifact ( artefact_size [ art ] ) ;
39227: LD_ADDR_VAR 0 8
39231: PUSH
39232: LD_EXP 78
39236: PUSH
39237: LD_VAR 0 1
39241: ARRAY
39242: PPUSH
39243: CALL_OW 469
39247: ST_TO_ADDR
// if not art_hex then
39248: LD_VAR 0 8
39252: NOT
39253: IFFALSE 39257
// exit ;
39255: GO 39906
// case art of 1 :
39257: LD_VAR 0 1
39261: PUSH
39262: LD_INT 1
39264: DOUBLE
39265: EQUAL
39266: IFTRUE 39270
39268: GO 39347
39270: POP
// list := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 2 :
39271: LD_ADDR_VAR 0 3
39275: PUSH
39276: LD_INT 23
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 21
39288: PUSH
39289: LD_INT 3
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 2
39298: PUSH
39299: LD_INT 30
39301: PUSH
39302: LD_INT 6
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 30
39311: PUSH
39312: LD_INT 7
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 30
39321: PUSH
39322: LD_INT 8
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: LIST
39333: LIST
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: LIST
39339: PPUSH
39340: CALL_OW 69
39344: ST_TO_ADDR
39345: GO 39467
39347: LD_INT 2
39349: DOUBLE
39350: EQUAL
39351: IFTRUE 39355
39353: GO 39432
39355: POP
// list := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 3 :
39356: LD_ADDR_VAR 0 3
39360: PUSH
39361: LD_INT 23
39363: PUSH
39364: LD_INT 3
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 21
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 2
39383: PUSH
39384: LD_INT 30
39386: PUSH
39387: LD_INT 6
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 30
39396: PUSH
39397: LD_INT 7
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 30
39406: PUSH
39407: LD_INT 8
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: LIST
39424: PPUSH
39425: CALL_OW 69
39429: ST_TO_ADDR
39430: GO 39467
39432: LD_INT 3
39434: DOUBLE
39435: EQUAL
39436: IFTRUE 39440
39438: GO 39466
39440: POP
// list := FilterAllUnits ( [ [ f_btype , b_alien_tower ] ] ) ; end ;
39441: LD_ADDR_VAR 0 3
39445: PUSH
39446: LD_INT 30
39448: PUSH
39449: LD_INT 39
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: EMPTY
39457: LIST
39458: PPUSH
39459: CALL_OW 69
39463: ST_TO_ADDR
39464: GO 39467
39466: POP
// nearest_lab := NearestUnitToXY ( list , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39467: LD_ADDR_VAR 0 9
39471: PUSH
39472: LD_VAR 0 3
39476: PPUSH
39477: LD_VAR 0 8
39481: PUSH
39482: LD_INT 1
39484: ARRAY
39485: PPUSH
39486: LD_VAR 0 8
39490: PUSH
39491: LD_INT 2
39493: ARRAY
39494: PPUSH
39495: CALL_OW 73
39499: ST_TO_ADDR
// dist := GetDistUnitXY ( nearest_lab , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39500: LD_ADDR_VAR 0 6
39504: PUSH
39505: LD_VAR 0 9
39509: PPUSH
39510: LD_VAR 0 8
39514: PUSH
39515: LD_INT 1
39517: ARRAY
39518: PPUSH
39519: LD_VAR 0 8
39523: PUSH
39524: LD_INT 2
39526: ARRAY
39527: PPUSH
39528: CALL_OW 297
39532: ST_TO_ADDR
// if dist < 25 then
39533: LD_VAR 0 6
39537: PUSH
39538: LD_INT 25
39540: LESS
39541: IFFALSE 39906
// begin side := GetSide ( nearest_lab ) ;
39543: LD_ADDR_VAR 0 4
39547: PUSH
39548: LD_VAR 0 9
39552: PPUSH
39553: CALL_OW 255
39557: ST_TO_ADDR
// DeInit_Lab ( side , art ) ;
39558: LD_VAR 0 4
39562: PPUSH
39563: LD_VAR 0 1
39567: PPUSH
39568: CALL 39911 0 2
// base := ( art - 1 ) * 100 ;
39572: LD_ADDR_VAR 0 5
39576: PUSH
39577: LD_VAR 0 1
39581: PUSH
39582: LD_INT 1
39584: MINUS
39585: PUSH
39586: LD_INT 100
39588: MUL
39589: ST_TO_ADDR
// if ( GetTech ( tech_Artifact , side ) = state_researched ) then
39590: LD_INT 24
39592: PPUSH
39593: LD_VAR 0 4
39597: PPUSH
39598: CALL_OW 321
39602: PUSH
39603: LD_INT 2
39605: EQUAL
39606: IFFALSE 39809
// begin if GetTag ( base + side * 10 + 11 ) and UnitsInside ( nearest_lab ) then
39608: LD_VAR 0 5
39612: PUSH
39613: LD_VAR 0 4
39617: PUSH
39618: LD_INT 10
39620: MUL
39621: PLUS
39622: PUSH
39623: LD_INT 11
39625: PLUS
39626: PPUSH
39627: CALL_OW 110
39631: PUSH
39632: LD_VAR 0 9
39636: PPUSH
39637: CALL_OW 313
39641: AND
39642: IFFALSE 39799
// begin if not GetTag ( base + side * 10 + 13 ) then
39644: LD_VAR 0 5
39648: PUSH
39649: LD_VAR 0 4
39653: PUSH
39654: LD_INT 10
39656: MUL
39657: PLUS
39658: PUSH
39659: LD_INT 13
39661: PLUS
39662: PPUSH
39663: CALL_OW 110
39667: NOT
39668: IFFALSE 39691
// state := GetTag ( base + 03 ) else
39670: LD_ADDR_VAR 0 7
39674: PUSH
39675: LD_VAR 0 5
39679: PUSH
39680: LD_INT 3
39682: PLUS
39683: PPUSH
39684: CALL_OW 110
39688: ST_TO_ADDR
39689: GO 39699
// state := art_gray ;
39691: LD_ADDR_VAR 0 7
39695: PUSH
39696: LD_INT 1
39698: ST_TO_ADDR
// if GetTag ( base + side * 10 + 15 ) and ( GetTag ( base + side * 10 + 15 ) <> nearest_lab ) then
39699: LD_VAR 0 5
39703: PUSH
39704: LD_VAR 0 4
39708: PUSH
39709: LD_INT 10
39711: MUL
39712: PLUS
39713: PUSH
39714: LD_INT 15
39716: PLUS
39717: PPUSH
39718: CALL_OW 110
39722: PUSH
39723: LD_VAR 0 5
39727: PUSH
39728: LD_VAR 0 4
39732: PUSH
39733: LD_INT 10
39735: MUL
39736: PLUS
39737: PUSH
39738: LD_INT 15
39740: PLUS
39741: PPUSH
39742: CALL_OW 110
39746: PUSH
39747: LD_VAR 0 9
39751: NONEQUAL
39752: AND
39753: IFFALSE 39769
// DeInit_Lab ( side , art ) ;
39755: LD_VAR 0 4
39759: PPUSH
39760: LD_VAR 0 1
39764: PPUSH
39765: CALL 39911 0 2
// SetTag ( base + side * 10 + 15 , nearest_lab ) ;
39769: LD_VAR 0 5
39773: PUSH
39774: LD_VAR 0 4
39778: PUSH
39779: LD_INT 10
39781: MUL
39782: PLUS
39783: PUSH
39784: LD_INT 15
39786: PLUS
39787: PPUSH
39788: LD_VAR 0 9
39792: PPUSH
39793: CALL_OW 109
// end else
39797: GO 39807
// state := art_instant ;
39799: LD_ADDR_VAR 0 7
39803: PUSH
39804: LD_INT 2
39806: ST_TO_ADDR
// end else
39807: GO 39817
// state := art_gray ;
39809: LD_ADDR_VAR 0 7
39813: PUSH
39814: LD_INT 1
39816: ST_TO_ADDR
// SetTag ( base + 11 , nearest_lab ) ;
39817: LD_VAR 0 5
39821: PUSH
39822: LD_INT 11
39824: PLUS
39825: PPUSH
39826: LD_VAR 0 9
39830: PPUSH
39831: CALL_OW 109
// if not ( nearest_lab in labs_in_use ) then
39835: LD_VAR 0 9
39839: PUSH
39840: LD_EXP 79
39844: IN
39845: NOT
39846: IFFALSE 39906
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , state , nearest_lab ) ;
39848: LD_VAR 0 4
39852: PPUSH
39853: LD_VAR 0 5
39857: PUSH
39858: LD_INT 1
39860: PLUS
39861: PUSH
39862: LD_VAR 0 5
39866: PUSH
39867: LD_VAR 0 4
39871: PUSH
39872: LD_INT 10
39874: MUL
39875: PLUS
39876: PUSH
39877: LD_INT 11
39879: PLUS
39880: PPUSH
39881: CALL_OW 110
39885: PLUS
39886: PPUSH
39887: CALL_OW 110
39891: PPUSH
39892: LD_VAR 0 7
39896: PPUSH
39897: LD_VAR 0 9
39901: PPUSH
39902: CALL_OW 468
// end ; end ;
39906: LD_VAR 0 2
39910: RET
// export function DeInit_Lab ( side , art ) ; var base , lab ; begin
39911: LD_INT 0
39913: PPUSH
39914: PPUSH
39915: PPUSH
// base := ( art - 1 ) * 100 ;
39916: LD_ADDR_VAR 0 4
39920: PUSH
39921: LD_VAR 0 2
39925: PUSH
39926: LD_INT 1
39928: MINUS
39929: PUSH
39930: LD_INT 100
39932: MUL
39933: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39934: LD_ADDR_VAR 0 5
39938: PUSH
39939: LD_VAR 0 4
39943: PUSH
39944: LD_VAR 0 1
39948: PUSH
39949: LD_INT 10
39951: MUL
39952: PLUS
39953: PUSH
39954: LD_INT 15
39956: PLUS
39957: PPUSH
39958: CALL_OW 110
39962: ST_TO_ADDR
// if not lab then
39963: LD_VAR 0 5
39967: NOT
39968: IFFALSE 39989
// lab := GetTag ( base + 11 ) ;
39970: LD_ADDR_VAR 0 5
39974: PUSH
39975: LD_VAR 0 4
39979: PUSH
39980: LD_INT 11
39982: PLUS
39983: PPUSH
39984: CALL_OW 110
39988: ST_TO_ADDR
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_no , lab ) ;
39989: LD_VAR 0 1
39993: PPUSH
39994: LD_VAR 0 4
39998: PUSH
39999: LD_INT 1
40001: PLUS
40002: PUSH
40003: LD_VAR 0 4
40007: PUSH
40008: LD_VAR 0 1
40012: PUSH
40013: LD_INT 10
40015: MUL
40016: PLUS
40017: PUSH
40018: LD_INT 11
40020: PLUS
40021: PPUSH
40022: CALL_OW 110
40026: PLUS
40027: PPUSH
40028: CALL_OW 110
40032: PPUSH
40033: LD_INT 0
40035: PPUSH
40036: LD_VAR 0 5
40040: PPUSH
40041: CALL_OW 468
// end ;
40045: LD_VAR 0 3
40049: RET
// export function Update_Artefact ( lab ) ; var art , side , base ; begin
40050: LD_INT 0
40052: PPUSH
40053: PPUSH
40054: PPUSH
40055: PPUSH
// side := GetSide ( lab ) ;
40056: LD_ADDR_VAR 0 4
40060: PUSH
40061: LD_VAR 0 1
40065: PPUSH
40066: CALL_OW 255
40070: ST_TO_ADDR
// for art = 1 to artefact_number do
40071: LD_ADDR_VAR 0 3
40075: PUSH
40076: DOUBLE
40077: LD_INT 1
40079: DEC
40080: ST_TO_ADDR
40081: LD_EXP 76
40085: PUSH
40086: FOR_TO
40087: IFFALSE 40243
// begin base := ( art - 1 ) * 100 ;
40089: LD_ADDR_VAR 0 5
40093: PUSH
40094: LD_VAR 0 3
40098: PUSH
40099: LD_INT 1
40101: MINUS
40102: PUSH
40103: LD_INT 100
40105: MUL
40106: ST_TO_ADDR
// if GetTag ( base + 11 ) = lab then
40107: LD_VAR 0 5
40111: PUSH
40112: LD_INT 11
40114: PLUS
40115: PPUSH
40116: CALL_OW 110
40120: PUSH
40121: LD_VAR 0 1
40125: EQUAL
40126: IFFALSE 40139
// Init_Lab ( art ) else
40128: LD_VAR 0 3
40132: PPUSH
40133: CALL 39217 0 1
40137: GO 40241
// begin if lab = GetTag ( base + side * 10 + 15 ) then
40139: LD_VAR 0 1
40143: PUSH
40144: LD_VAR 0 5
40148: PUSH
40149: LD_VAR 0 4
40153: PUSH
40154: LD_INT 10
40156: MUL
40157: PLUS
40158: PUSH
40159: LD_INT 15
40161: PLUS
40162: PPUSH
40163: CALL_OW 110
40167: EQUAL
40168: IFFALSE 40241
// begin if ( GetTag ( base + side * 10 + 13 ) > 0 ) or ( not UnitsInside ( lab ) ) then
40170: LD_VAR 0 5
40174: PUSH
40175: LD_VAR 0 4
40179: PUSH
40180: LD_INT 10
40182: MUL
40183: PLUS
40184: PUSH
40185: LD_INT 13
40187: PLUS
40188: PPUSH
40189: CALL_OW 110
40193: PUSH
40194: LD_INT 0
40196: GREATER
40197: PUSH
40198: LD_VAR 0 1
40202: PPUSH
40203: CALL_OW 313
40207: NOT
40208: OR
40209: IFFALSE 40227
// Shadow_Artefact ( side , art ) else
40211: LD_VAR 0 4
40215: PPUSH
40216: LD_VAR 0 3
40220: PPUSH
40221: CALL 38931 0 2
40225: GO 40241
// Highlight_Artefact ( side , art ) ;
40227: LD_VAR 0 4
40231: PPUSH
40232: LD_VAR 0 3
40236: PPUSH
40237: CALL 39063 0 2
// end ; end ; end ;
40241: GO 40086
40243: POP
40244: POP
// end ;
40245: LD_VAR 0 2
40249: RET
// every 0 0$2 marked 20 do var list , lab ;
40250: GO 40252
40252: DISABLE
40253: LD_INT 0
40255: PPUSH
40256: PPUSH
// begin list := FilterAllUnits ( [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_alien_tower ] ] ] ) ;
40257: LD_ADDR_VAR 0 1
40261: PUSH
40262: LD_INT 2
40264: PUSH
40265: LD_INT 30
40267: PUSH
40268: LD_INT 6
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 30
40277: PUSH
40278: LD_INT 7
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 30
40287: PUSH
40288: LD_INT 8
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 30
40297: PUSH
40298: LD_INT 39
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: LIST
40309: LIST
40310: LIST
40311: PUSH
40312: EMPTY
40313: LIST
40314: PPUSH
40315: CALL_OW 69
40319: ST_TO_ADDR
// for lab in list do
40320: LD_ADDR_VAR 0 2
40324: PUSH
40325: LD_VAR 0 1
40329: PUSH
40330: FOR_IN
40331: IFFALSE 40344
// Update_Artefact ( lab ) ;
40333: LD_VAR 0 2
40337: PPUSH
40338: CALL 40050 0 1
40342: GO 40330
40344: POP
40345: POP
// enable ;
40346: ENABLE
// end ; end_of_file
40347: PPOPN 2
40349: END
// var view_data , human_changed ; export function Show_me_map ( side , x , y ) ; var vysledek , station ; begin
40350: LD_INT 0
40352: PPUSH
40353: PPUSH
40354: PPUSH
// vysledek := true ;
40355: LD_ADDR_VAR 0 5
40359: PUSH
40360: LD_INT 1
40362: ST_TO_ADDR
// station := GetBase ( GetTag ( side * 10 + 15 ) ) ;
40363: LD_ADDR_VAR 0 6
40367: PUSH
40368: LD_VAR 0 1
40372: PUSH
40373: LD_INT 10
40375: MUL
40376: PUSH
40377: LD_INT 15
40379: PLUS
40380: PPUSH
40381: CALL_OW 110
40385: PPUSH
40386: CALL_OW 274
40390: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 06 ) ) then
40391: LD_VAR 0 6
40395: PUSH
40396: LD_VAR 0 6
40400: PPUSH
40401: CALL_OW 279
40405: PUSH
40406: LD_INT 3
40408: ARRAY
40409: PUSH
40410: LD_INT 6
40412: PPUSH
40413: CALL_OW 110
40417: GREATEREQUAL
40418: AND
40419: IFFALSE 40509
// begin PlaceSeeing ( x , y , side , - 15 ) ;
40421: LD_VAR 0 2
40425: PPUSH
40426: LD_VAR 0 3
40430: PPUSH
40431: LD_VAR 0 1
40435: PPUSH
40436: LD_INT 15
40438: NEG
40439: PPUSH
40440: CALL_OW 330
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 06 ) ) ;
40444: LD_VAR 0 6
40448: PPUSH
40449: LD_INT 3
40451: PPUSH
40452: LD_VAR 0 6
40456: PPUSH
40457: CALL_OW 279
40461: PUSH
40462: LD_INT 3
40464: ARRAY
40465: PUSH
40466: LD_INT 6
40468: PPUSH
40469: CALL_OW 110
40473: MINUS
40474: PPUSH
40475: CALL_OW 277
// view_data := [ x , y , side ] ;
40479: LD_ADDR_LOC 81
40483: PUSH
40484: LD_VAR 0 2
40488: PUSH
40489: LD_VAR 0 3
40493: PUSH
40494: LD_VAR 0 1
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: ST_TO_ADDR
// enable ( 111 ) ;
40504: LD_INT 111
40506: ENABLE_MARKED
// end else
40507: GO 40517
// vysledek := false ;
40509: LD_ADDR_VAR 0 5
40513: PUSH
40514: LD_INT 0
40516: ST_TO_ADDR
// result := vysledek ;
40517: LD_ADDR_VAR 0 4
40521: PUSH
40522: LD_VAR 0 5
40526: ST_TO_ADDR
// end ;
40527: LD_VAR 0 4
40531: RET
// every 0 0$2.8 trigger view_data marked 111 do
40532: LD_LOC 81
40536: IFFALSE 40587
40538: GO 40540
40540: DISABLE
// begin wait ( 0 0$30 ) ;
40541: LD_INT 1050
40543: PPUSH
40544: CALL_OW 67
// RemoveSeeing ( view_data [ 1 ] , view_data [ 2 ] , view_data [ 3 ] ) ;
40548: LD_LOC 81
40552: PUSH
40553: LD_INT 1
40555: ARRAY
40556: PPUSH
40557: LD_LOC 81
40561: PUSH
40562: LD_INT 2
40564: ARRAY
40565: PPUSH
40566: LD_LOC 81
40570: PUSH
40571: LD_INT 3
40573: ARRAY
40574: PPUSH
40575: CALL_OW 331
// view_data := 0 ;
40579: LD_ADDR_LOC 81
40583: PUSH
40584: LD_INT 0
40586: ST_TO_ADDR
// end ;
40587: END
// export function Destroy_siberite ( side , un ) ; var vysledek , station , v_can , b_can , it_can , building_list , vehicle_list ; begin
40588: LD_INT 0
40590: PPUSH
40591: PPUSH
40592: PPUSH
40593: PPUSH
40594: PPUSH
40595: PPUSH
40596: PPUSH
40597: PPUSH
// vysledek := true ;
40598: LD_ADDR_VAR 0 4
40602: PUSH
40603: LD_INT 1
40605: ST_TO_ADDR
// it_can := false ;
40606: LD_ADDR_VAR 0 8
40610: PUSH
40611: LD_INT 0
40613: ST_TO_ADDR
// building_list := [ b_siberite_mine , b_siberite_power ] ;
40614: LD_ADDR_VAR 0 9
40618: PUSH
40619: LD_INT 30
40621: PUSH
40622: LD_INT 28
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: ST_TO_ADDR
// vehicle_list := [ us_siberium_rocket , ru_siberium_rocket , ar_selfpropelled_bomb , ru_time_lapser , us_double_laser ] ;
40629: LD_ADDR_VAR 0 10
40633: PUSH
40634: LD_INT 8
40636: PUSH
40637: LD_INT 48
40639: PUSH
40640: LD_INT 29
40642: PUSH
40643: LD_INT 49
40645: PUSH
40646: LD_INT 10
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: ST_TO_ADDR
// b_can := ( GetType ( un ) = unit_building ) and ( ( GetBType ( un ) in building_list ) or ( GetBWeapon ( un ) in vehicle_list ) ) ;
40656: LD_ADDR_VAR 0 7
40660: PUSH
40661: LD_VAR 0 2
40665: PPUSH
40666: CALL_OW 247
40670: PUSH
40671: LD_INT 3
40673: EQUAL
40674: PUSH
40675: LD_VAR 0 2
40679: PPUSH
40680: CALL_OW 266
40684: PUSH
40685: LD_VAR 0 9
40689: IN
40690: PUSH
40691: LD_VAR 0 2
40695: PPUSH
40696: CALL_OW 269
40700: PUSH
40701: LD_VAR 0 10
40705: IN
40706: OR
40707: AND
40708: ST_TO_ADDR
// v_can := ( GetType ( un ) = unit_vehicle ) and ( ( GetWeapon ( un ) in vehicle_list ) or ( GetEngine ( un ) = engine_siberite ) ) ;
40709: LD_ADDR_VAR 0 6
40713: PUSH
40714: LD_VAR 0 2
40718: PPUSH
40719: CALL_OW 247
40723: PUSH
40724: LD_INT 2
40726: EQUAL
40727: PUSH
40728: LD_VAR 0 2
40732: PPUSH
40733: CALL_OW 264
40737: PUSH
40738: LD_VAR 0 10
40742: IN
40743: PUSH
40744: LD_VAR 0 2
40748: PPUSH
40749: CALL_OW 262
40753: PUSH
40754: LD_INT 3
40756: EQUAL
40757: OR
40758: AND
40759: ST_TO_ADDR
// it_can := b_can or v_can ;
40760: LD_ADDR_VAR 0 8
40764: PUSH
40765: LD_VAR 0 7
40769: PUSH
40770: LD_VAR 0 6
40774: OR
40775: ST_TO_ADDR
// station := GetBase ( GetTag ( 100 + side * 10 + 15 ) ) ;
40776: LD_ADDR_VAR 0 5
40780: PUSH
40781: LD_INT 100
40783: PUSH
40784: LD_VAR 0 1
40788: PUSH
40789: LD_INT 10
40791: MUL
40792: PLUS
40793: PUSH
40794: LD_INT 15
40796: PLUS
40797: PPUSH
40798: CALL_OW 110
40802: PPUSH
40803: CALL_OW 274
40807: ST_TO_ADDR
// if station and it_can and ( GetResources ( station ) [ 3 ] >= GetTag ( 106 ) ) then
40808: LD_VAR 0 5
40812: PUSH
40813: LD_VAR 0 8
40817: AND
40818: PUSH
40819: LD_VAR 0 5
40823: PPUSH
40824: CALL_OW 279
40828: PUSH
40829: LD_INT 3
40831: ARRAY
40832: PUSH
40833: LD_INT 106
40835: PPUSH
40836: CALL_OW 110
40840: GREATEREQUAL
40841: AND
40842: IFFALSE 40890
// begin KillUnit ( un ) ;
40844: LD_VAR 0 2
40848: PPUSH
40849: CALL_OW 66
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 106 ) ) ;
40853: LD_VAR 0 5
40857: PPUSH
40858: LD_INT 3
40860: PPUSH
40861: LD_VAR 0 5
40865: PPUSH
40866: CALL_OW 279
40870: PUSH
40871: LD_INT 3
40873: ARRAY
40874: PUSH
40875: LD_INT 106
40877: PPUSH
40878: CALL_OW 110
40882: MINUS
40883: PPUSH
40884: CALL_OW 277
// end else
40888: GO 40898
// vysledek := false ;
40890: LD_ADDR_VAR 0 4
40894: PUSH
40895: LD_INT 0
40897: ST_TO_ADDR
// result := vysledek ;
40898: LD_ADDR_VAR 0 3
40902: PUSH
40903: LD_VAR 0 4
40907: ST_TO_ADDR
// end ;
40908: LD_VAR 0 3
40912: RET
// export function Mass_Teleport ( side , x , y ) ; var vysledek , station , list , un ; begin
40913: LD_INT 0
40915: PPUSH
40916: PPUSH
40917: PPUSH
40918: PPUSH
40919: PPUSH
// vysledek := true ;
40920: LD_ADDR_VAR 0 5
40924: PUSH
40925: LD_INT 1
40927: ST_TO_ADDR
// station := GetBase ( GetTag ( 200 + side * 10 + 15 ) ) ;
40928: LD_ADDR_VAR 0 6
40932: PUSH
40933: LD_INT 200
40935: PUSH
40936: LD_VAR 0 1
40940: PUSH
40941: LD_INT 10
40943: MUL
40944: PLUS
40945: PUSH
40946: LD_INT 15
40948: PLUS
40949: PPUSH
40950: CALL_OW 110
40954: PPUSH
40955: CALL_OW 274
40959: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 206 ) ) then
40960: LD_VAR 0 6
40964: PUSH
40965: LD_VAR 0 6
40969: PPUSH
40970: CALL_OW 279
40974: PUSH
40975: LD_INT 3
40977: ARRAY
40978: PUSH
40979: LD_INT 206
40981: PPUSH
40982: CALL_OW 110
40986: GREATEREQUAL
40987: AND
40988: IFFALSE 41171
// begin SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 206 ) ) ;
40990: LD_VAR 0 6
40994: PPUSH
40995: LD_INT 3
40997: PPUSH
40998: LD_VAR 0 6
41002: PPUSH
41003: CALL_OW 279
41007: PUSH
41008: LD_INT 3
41010: ARRAY
41011: PUSH
41012: LD_INT 206
41014: PPUSH
41015: CALL_OW 110
41019: MINUS
41020: PPUSH
41021: CALL_OW 277
// SetAreaMapShow ( teleport_area , 1 ) ;
41025: LD_INT 24
41027: PPUSH
41028: LD_INT 1
41030: PPUSH
41031: CALL_OW 424
// for un = 1 to 11 do
41035: LD_ADDR_VAR 0 8
41039: PUSH
41040: DOUBLE
41041: LD_INT 1
41043: DEC
41044: ST_TO_ADDR
41045: LD_INT 11
41047: PUSH
41048: FOR_TO
41049: IFFALSE 41077
// begin display_strings := [ ( 11 - un ) ] ;
41051: LD_ADDR_OWVAR 47
41055: PUSH
41056: LD_INT 11
41058: PUSH
41059: LD_VAR 0 8
41063: MINUS
41064: PUSH
41065: EMPTY
41066: LIST
41067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
41068: LD_INT 35
41070: PPUSH
41071: CALL_OW 67
// end ;
41075: GO 41048
41077: POP
41078: POP
// display_strings :=  ;
41079: LD_ADDR_OWVAR 47
41083: PUSH
41084: LD_STRING 
41086: ST_TO_ADDR
// SetAreaMapShow ( teleport_area , 0 ) ;
41087: LD_INT 24
41089: PPUSH
41090: LD_INT 0
41092: PPUSH
41093: CALL_OW 424
// list := FilterUnitsInArea ( teleport_area , [ f_not , [ f_type , unit_building ] ] ) ;
41097: LD_ADDR_VAR 0 7
41101: PUSH
41102: LD_INT 24
41104: PPUSH
41105: LD_INT 3
41107: PUSH
41108: LD_INT 21
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PPUSH
41122: CALL_OW 70
41126: ST_TO_ADDR
// for un in list do
41127: LD_ADDR_VAR 0 8
41131: PUSH
41132: LD_VAR 0 7
41136: PUSH
41137: FOR_IN
41138: IFFALSE 41167
// TeleportUnit ( un , x , y , 12 , true ) ;
41140: LD_VAR 0 8
41144: PPUSH
41145: LD_VAR 0 2
41149: PPUSH
41150: LD_VAR 0 3
41154: PPUSH
41155: LD_INT 12
41157: PPUSH
41158: LD_INT 1
41160: PPUSH
41161: CALL_OW 483
41165: GO 41137
41167: POP
41168: POP
// end else
41169: GO 41179
// vysledek := false ;
41171: LD_ADDR_VAR 0 5
41175: PUSH
41176: LD_INT 0
41178: ST_TO_ADDR
// result := vysledek ;
41179: LD_ADDR_VAR 0 4
41183: PUSH
41184: LD_VAR 0 5
41188: ST_TO_ADDR
// end ;
41189: LD_VAR 0 4
41193: RET
// every 0 0$5 marked 20 do var art , side , recharge ;
41194: GO 41196
41196: DISABLE
41197: LD_INT 0
41199: PPUSH
41200: PPUSH
41201: PPUSH
// begin side := you ;
41202: LD_ADDR_VAR 0 2
41206: PUSH
41207: LD_EXP 1
41211: ST_TO_ADDR
// for art = 0 to artefact_number do
41212: LD_ADDR_VAR 0 1
41216: PUSH
41217: DOUBLE
41218: LD_INT 0
41220: DEC
41221: ST_TO_ADDR
41222: LD_EXP 76
41226: PUSH
41227: FOR_TO
41228: IFFALSE 41328
// begin recharge := art * 100 + side * 10 + 13 ;
41230: LD_ADDR_VAR 0 3
41234: PUSH
41235: LD_VAR 0 1
41239: PUSH
41240: LD_INT 100
41242: MUL
41243: PUSH
41244: LD_VAR 0 2
41248: PUSH
41249: LD_INT 10
41251: MUL
41252: PLUS
41253: PUSH
41254: LD_INT 13
41256: PLUS
41257: ST_TO_ADDR
// if GetTag ( recharge ) > 0 then
41258: LD_VAR 0 3
41262: PPUSH
41263: CALL_OW 110
41267: PUSH
41268: LD_INT 0
41270: GREATER
41271: IFFALSE 41326
// begin SetTag ( recharge , GetTag ( recharge ) - 1 ) ;
41273: LD_VAR 0 3
41277: PPUSH
41278: LD_VAR 0 3
41282: PPUSH
41283: CALL_OW 110
41287: PUSH
41288: LD_INT 1
41290: MINUS
41291: PPUSH
41292: CALL_OW 109
// if not GetTag ( recharge ) then
41296: LD_VAR 0 3
41300: PPUSH
41301: CALL_OW 110
41305: NOT
41306: IFFALSE 41326
// Highlight_Artefact ( side , art + 1 ) ;
41308: LD_VAR 0 2
41312: PPUSH
41313: LD_VAR 0 1
41317: PUSH
41318: LD_INT 1
41320: PLUS
41321: PPUSH
41322: CALL 39063 0 2
// end ; end ;
41326: GO 41227
41328: POP
41329: POP
// enable ;
41330: ENABLE
// end ; end_of_file
41331: PPOPN 3
41333: END
// var us_fort , ru_fort ; var us_place , ru_place ; every 0 0$11 do var side , un , list ;
41334: GO 41336
41336: DISABLE
41337: LD_INT 0
41339: PPUSH
41340: PPUSH
41341: PPUSH
// begin us_fort := [ ] ;
41342: LD_ADDR_LOC 83
41346: PUSH
41347: EMPTY
41348: ST_TO_ADDR
// ru_fort := [ ] ;
41349: LD_ADDR_LOC 84
41353: PUSH
41354: EMPTY
41355: ST_TO_ADDR
// for side in ( cpu_list diff ar ) do
41356: LD_ADDR_VAR 0 1
41360: PUSH
41361: LD_EXP 8
41365: PUSH
41366: LD_EXP 4
41370: DIFF
41371: PUSH
41372: FOR_IN
41373: IFFALSE 41578
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
41375: LD_ADDR_VAR 0 3
41379: PUSH
41380: LD_INT 22
41382: PUSH
41383: LD_VAR 0 1
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 2
41394: PUSH
41395: LD_INT 30
41397: PUSH
41398: LD_INT 32
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 30
41407: PUSH
41408: LD_INT 33
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: LIST
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PPUSH
41424: CALL_OW 69
41428: ST_TO_ADDR
// for un in list do
41429: LD_ADDR_VAR 0 2
41433: PUSH
41434: LD_VAR 0 3
41438: PUSH
41439: FOR_IN
41440: IFFALSE 41574
// case side of us :
41442: LD_VAR 0 1
41446: PUSH
41447: LD_EXP 3
41451: DOUBLE
41452: EQUAL
41453: IFTRUE 41457
41455: GO 41509
41457: POP
// us_fort := us_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; ru :
41458: LD_ADDR_LOC 83
41462: PUSH
41463: LD_LOC 83
41467: PUSH
41468: LD_VAR 0 2
41472: PPUSH
41473: CALL_OW 250
41477: PUSH
41478: LD_VAR 0 2
41482: PPUSH
41483: CALL_OW 251
41487: PUSH
41488: LD_VAR 0 2
41492: PPUSH
41493: CALL_OW 269
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: LIST
41502: PUSH
41503: EMPTY
41504: LIST
41505: ADD
41506: ST_TO_ADDR
41507: GO 41572
41509: LD_EXP 2
41513: DOUBLE
41514: EQUAL
41515: IFTRUE 41519
41517: GO 41571
41519: POP
// ru_fort := ru_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; end ;
41520: LD_ADDR_LOC 84
41524: PUSH
41525: LD_LOC 84
41529: PUSH
41530: LD_VAR 0 2
41534: PPUSH
41535: CALL_OW 250
41539: PUSH
41540: LD_VAR 0 2
41544: PPUSH
41545: CALL_OW 251
41549: PUSH
41550: LD_VAR 0 2
41554: PPUSH
41555: CALL_OW 269
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: LIST
41564: PUSH
41565: EMPTY
41566: LIST
41567: ADD
41568: ST_TO_ADDR
41569: GO 41572
41571: POP
41572: GO 41439
41574: POP
41575: POP
// end ;
41576: GO 41372
41578: POP
41579: POP
// end ;
41580: PPOPN 3
41582: END
// every 0 0$10.5 do var un , w , x , y , list ;
41583: GO 41585
41585: DISABLE
41586: LD_INT 0
41588: PPUSH
41589: PPUSH
41590: PPUSH
41591: PPUSH
41592: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_heavy_gun ] , [ f_bweapon , us_radar ] , [ f_bweapon , us_double_laser ] ] ] ) ;
41593: LD_ADDR_VAR 0 5
41597: PUSH
41598: LD_INT 22
41600: PUSH
41601: LD_EXP 3
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 2
41612: PUSH
41613: LD_INT 30
41615: PUSH
41616: LD_INT 32
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 30
41625: PUSH
41626: LD_INT 33
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: LIST
41637: PUSH
41638: LD_INT 57
41640: PUSH
41641: EMPTY
41642: LIST
41643: PUSH
41644: LD_INT 3
41646: PUSH
41647: LD_INT 2
41649: PUSH
41650: LD_INT 35
41652: PUSH
41653: LD_INT 7
41655: PUSH
41656: EMPTY
41657: LIST
41658: LIST
41659: PUSH
41660: LD_INT 35
41662: PUSH
41663: LD_INT 6
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 35
41672: PUSH
41673: LD_INT 11
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 35
41682: PUSH
41683: LD_INT 10
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: PPUSH
41704: CALL_OW 69
41708: ST_TO_ADDR
// for un in list do
41709: LD_ADDR_VAR 0 1
41713: PUSH
41714: LD_VAR 0 5
41718: PUSH
41719: FOR_IN
41720: IFFALSE 41835
// begin x := GetX ( un ) ;
41722: LD_ADDR_VAR 0 3
41726: PUSH
41727: LD_VAR 0 1
41731: PPUSH
41732: CALL_OW 250
41736: ST_TO_ADDR
// y := GetY ( un ) ;
41737: LD_ADDR_VAR 0 4
41741: PUSH
41742: LD_VAR 0 1
41746: PPUSH
41747: CALL_OW 251
41751: ST_TO_ADDR
// for w in us_fort do
41752: LD_ADDR_VAR 0 2
41756: PUSH
41757: LD_LOC 83
41761: PUSH
41762: FOR_IN
41763: IFFALSE 41824
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
41765: LD_VAR 0 3
41769: PUSH
41770: LD_VAR 0 2
41774: PUSH
41775: LD_INT 1
41777: ARRAY
41778: EQUAL
41779: PUSH
41780: LD_VAR 0 4
41784: PUSH
41785: LD_VAR 0 2
41789: PUSH
41790: LD_INT 2
41792: ARRAY
41793: EQUAL
41794: AND
41795: IFFALSE 41815
// ComPlaceWeapon ( un , w [ 3 ] ) ;
41797: LD_VAR 0 1
41801: PPUSH
41802: LD_VAR 0 2
41806: PUSH
41807: LD_INT 3
41809: ARRAY
41810: PPUSH
41811: CALL_OW 148
// wait ( 8 ) ;
41815: LD_INT 8
41817: PPUSH
41818: CALL_OW 67
// end ;
41822: GO 41762
41824: POP
41825: POP
// wait ( 27 ) ;
41826: LD_INT 27
41828: PPUSH
41829: CALL_OW 67
// end ;
41833: GO 41719
41835: POP
41836: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
41837: LD_INT 175
41839: PPUSH
41840: LD_INT 350
41842: PPUSH
41843: CALL_OW 12
41847: PPUSH
41848: CALL_OW 67
// enable ;
41852: ENABLE
// end ;
41853: PPOPN 5
41855: END
// every 0 0$10.7 do var un , w , x , y , list ;
41856: GO 41858
41858: DISABLE
41859: LD_INT 0
41861: PPUSH
41862: PPUSH
41863: PPUSH
41864: PPUSH
41865: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , ru_rocket ] , [ f_bweapon , ru_heavy_gun ] , [ f_bweapon , ru_time_lapser ] , [ f_bweapon , ru_gatling_gun ] ] ] ) ;
41866: LD_ADDR_VAR 0 5
41870: PUSH
41871: LD_INT 22
41873: PUSH
41874: LD_EXP 2
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 2
41885: PUSH
41886: LD_INT 30
41888: PUSH
41889: LD_INT 32
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 30
41898: PUSH
41899: LD_INT 33
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 57
41913: PUSH
41914: EMPTY
41915: LIST
41916: PUSH
41917: LD_INT 3
41919: PUSH
41920: LD_INT 2
41922: PUSH
41923: LD_INT 35
41925: PUSH
41926: LD_INT 47
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 35
41935: PUSH
41936: LD_INT 46
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 35
41945: PUSH
41946: LD_INT 49
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 35
41955: PUSH
41956: LD_INT 43
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: LIST
41967: LIST
41968: LIST
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: LIST
41974: LIST
41975: LIST
41976: PPUSH
41977: CALL_OW 69
41981: ST_TO_ADDR
// for un in list do
41982: LD_ADDR_VAR 0 1
41986: PUSH
41987: LD_VAR 0 5
41991: PUSH
41992: FOR_IN
41993: IFFALSE 42108
// begin x := GetX ( un ) ;
41995: LD_ADDR_VAR 0 3
41999: PUSH
42000: LD_VAR 0 1
42004: PPUSH
42005: CALL_OW 250
42009: ST_TO_ADDR
// y := GetY ( un ) ;
42010: LD_ADDR_VAR 0 4
42014: PUSH
42015: LD_VAR 0 1
42019: PPUSH
42020: CALL_OW 251
42024: ST_TO_ADDR
// for w in ru_fort do
42025: LD_ADDR_VAR 0 2
42029: PUSH
42030: LD_LOC 84
42034: PUSH
42035: FOR_IN
42036: IFFALSE 42097
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42038: LD_VAR 0 3
42042: PUSH
42043: LD_VAR 0 2
42047: PUSH
42048: LD_INT 1
42050: ARRAY
42051: EQUAL
42052: PUSH
42053: LD_VAR 0 4
42057: PUSH
42058: LD_VAR 0 2
42062: PUSH
42063: LD_INT 2
42065: ARRAY
42066: EQUAL
42067: AND
42068: IFFALSE 42088
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42070: LD_VAR 0 1
42074: PPUSH
42075: LD_VAR 0 2
42079: PUSH
42080: LD_INT 3
42082: ARRAY
42083: PPUSH
42084: CALL_OW 148
// wait ( 8 ) ;
42088: LD_INT 8
42090: PPUSH
42091: CALL_OW 67
// end ;
42095: GO 42035
42097: POP
42098: POP
// wait ( 27 ) ;
42099: LD_INT 27
42101: PPUSH
42102: CALL_OW 67
// end ;
42106: GO 41992
42108: POP
42109: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42110: LD_INT 175
42112: PPUSH
42113: LD_INT 350
42115: PPUSH
42116: CALL_OW 12
42120: PPUSH
42121: CALL_OW 67
// enable ;
42125: ENABLE
// end ; end_of_file
42126: PPOPN 5
42128: END
// every 0 0$2 + 0 0$0.1 do
42129: GO 42131
42131: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
42132: LD_INT 22
42134: PUSH
42135: LD_INT 7
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 2
42144: PUSH
42145: LD_INT 25
42147: PUSH
42148: LD_INT 12
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 25
42157: PUSH
42158: LD_INT 16
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 25
42167: PUSH
42168: LD_INT 15
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 25
42177: PUSH
42178: LD_INT 17
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PPUSH
42196: CALL_OW 69
42200: PUSH
42201: LD_INT 22
42203: PUSH
42204: LD_INT 7
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 21
42213: PUSH
42214: LD_INT 1
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: LD_INT 2
42226: PUSH
42227: LD_INT 25
42229: PUSH
42230: LD_INT 12
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 25
42239: PUSH
42240: LD_INT 16
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 25
42249: PUSH
42250: LD_INT 15
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 25
42259: PUSH
42260: LD_INT 17
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: LIST
42282: PPUSH
42283: CALL_OW 69
42287: GREATER
42288: IFFALSE 42299
// begin SetAchievement ( ACH_POTA ) ;
42290: LD_STRING ACH_POTA
42292: PPUSH
42293: CALL_OW 543
// exit ;
42297: GO 42300
// end ; enable ;
42299: ENABLE
// end ;
42300: END
// export function SA_OnMissionComplete ; begin
42301: LD_INT 0
42303: PPUSH
// SetAchievement ( ACH_GBA ) ;
42304: LD_STRING ACH_GBA
42306: PPUSH
42307: CALL_OW 543
// end ;
42311: LD_VAR 0 1
42315: RET

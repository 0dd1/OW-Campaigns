// export you , ru , us , ar , ar_al , neutral , camp ; export cpu_list ; export ru_nation , us_nation , ar_nation ; export Burlak , MacMillan , Roth , Gossudarov ; export Petrosyan , Belkov , Kirilenkova , Gnyevko , Gladkov , Dolgov , Gleb , Kapitsova , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Bystrov , Lipshchin , Fadeev ; export Bobby , Brown , Cornell , Connie , Cyrus , Denis , Donaldson , Frank , Gary , Gladstone , Joan , Lisa , Peterson , Simms , VanHouten , Yamoko ; export Omar , OmarKilled , NegotiationOffered , OmarWillTryContaminateMotherlode ; export Powell , Platonov ; export aliance_forces ; export finalize ; export prefered_control ; export siberite_rocket_send ; function prepare_us_units ; begin
   0: LD_INT 0
   2: PPUSH
// Powell := NewCharacter ( Powell ) ;
   3: LD_ADDR_EXP 55
   7: PUSH
   8: LD_STRING Powell
  10: PPUSH
  11: CALL_OW 25
  15: ST_TO_ADDR
// SetSide ( Powell , us ) ;
  16: LD_EXP 55
  20: PPUSH
  21: LD_EXP 3
  25: PPUSH
  26: CALL_OW 235
// end ;
  30: LD_VAR 0 1
  34: RET
// function prepare_ru_units ; begin
  35: LD_INT 0
  37: PPUSH
// Platonov := NewCharacter ( Platonov ) ;
  38: LD_ADDR_EXP 56
  42: PUSH
  43: LD_STRING Platonov
  45: PPUSH
  46: CALL_OW 25
  50: ST_TO_ADDR
// SetSide ( Platonov , ru ) ;
  51: LD_EXP 56
  55: PPUSH
  56: LD_EXP 2
  60: PPUSH
  61: CALL_OW 235
// end ;
  65: LD_VAR 0 1
  69: RET
// function prepare_ar_units ; begin
  70: LD_INT 0
  72: PPUSH
// OmarWillTryContaminateMotherlode = false ;
  73: LD_ADDR_EXP 54
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// if difficulty >= 2 then
  81: LD_OWVAR 67
  85: PUSH
  86: LD_INT 2
  88: GREATEREQUAL
  89: IFFALSE 106
// SetTech ( tech_stimdrugs , ar_al , state_researched ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_EXP 5
  98: PPUSH
  99: LD_INT 2
 101: PPUSH
 102: CALL_OW 322
// if camp = 6 then
 106: LD_EXP 7
 110: PUSH
 111: LD_INT 6
 113: EQUAL
 114: IFFALSE 134
// OmarKilled := LoadVariable ( OmarKilled , true ) else
 116: LD_ADDR_EXP 52
 120: PUSH
 121: LD_STRING OmarKilled
 123: PPUSH
 124: LD_INT 1
 126: PPUSH
 127: CALL_OW 30
 131: ST_TO_ADDR
 132: GO 142
// OmarKilled = false ;
 134: LD_ADDR_EXP 52
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// if OmarKilled then
 142: LD_EXP 52
 146: IFFALSE 158
// begin Omar = 0 ;
 148: LD_ADDR_EXP 51
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// exit ;
 156: GO 244
// end ; if TestCharacters ( Omar ) then
 158: LD_STRING Omar
 160: PPUSH
 161: CALL_OW 28
 165: IFFALSE 182
// Omar := CreateCharacter ( Omar ) else
 167: LD_ADDR_EXP 51
 171: PUSH
 172: LD_STRING Omar
 174: PPUSH
 175: CALL_OW 34
 179: ST_TO_ADDR
 180: GO 195
// Omar = NewCharacter ( Omar ) ;
 182: LD_ADDR_EXP 51
 186: PUSH
 187: LD_STRING Omar
 189: PPUSH
 190: CALL_OW 25
 194: ST_TO_ADDR
// SetSide ( Omar , ar_al ) ;
 195: LD_EXP 51
 199: PPUSH
 200: LD_EXP 5
 204: PPUSH
 205: CALL_OW 235
// NegotiationOffered := LoadVariable ( NegotiationsOffered , false ) ;
 209: LD_ADDR_EXP 53
 213: PUSH
 214: LD_STRING NegotiationsOffered
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// if NegotiationOffered then
 225: LD_EXP 53
 229: IFFALSE 236
// enable ( 2 ) else
 231: LD_INT 2
 233: ENABLE_MARKED
 234: GO 244
// OmarWillTryContaminateMotherlode = true ;
 236: LD_ADDR_EXP 54
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// end ;
 244: LD_VAR 0 1
 248: RET
// function prepare_al_units ; var un , count , i , nations , art_loaded , selected , aliance , pom_list , veh_cargo , veh_basic , veh_battle , vehicles , veh_list , JMM_car , Bur_car ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
// nations := [ nation_american , nation_russian ] ;
 267: LD_ADDR_VAR 0 5
 271: PUSH
 272: LD_INT 1
 274: PUSH
 275: LD_INT 3
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: ST_TO_ADDR
// uc_side := you ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_EXP 1
 291: ST_TO_ADDR
// aliance_forces := [ ] ;
 292: LD_ADDR_EXP 57
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// load_all_aliance ;
 299: CALL 2772 0 0
// aliance := [ ] ;
 303: LD_ADDR_VAR 0 8
 307: PUSH
 308: EMPTY
 309: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 310: LD_ADDR_EXP 12
 314: PUSH
 315: LD_STRING Burlak
 317: PPUSH
 318: CALL_OW 34
 322: ST_TO_ADDR
// aliance := aliance ^ Burlak ;
 323: LD_ADDR_VAR 0 8
 327: PUSH
 328: LD_VAR 0 8
 332: PUSH
 333: LD_EXP 12
 337: ADD
 338: ST_TO_ADDR
// if TestCharacters ( JMM ) and CheckCharacterSet ( JMM ) then
 339: LD_STRING JMM
 341: PPUSH
 342: CALL_OW 28
 346: PUSH
 347: LD_STRING JMM
 349: PPUSH
 350: CALL_OW 29
 354: AND
 355: IFFALSE 398
// begin MacMillan := CreateCharacter ( JMM ) ;
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING JMM
 364: PPUSH
 365: CALL_OW 34
 369: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
 370: LD_EXP 13
 374: PPUSH
 375: LD_INT 2
 377: PPUSH
 378: CALL_OW 336
// aliance := aliance ^ MacMillan ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_VAR 0 8
 391: PUSH
 392: LD_EXP 13
 396: ADD
 397: ST_TO_ADDR
// end ; if TestCharacters ( Roth ) and CheckCharacterSet ( Roth ) then
 398: LD_STRING Roth
 400: PPUSH
 401: CALL_OW 28
 405: PUSH
 406: LD_STRING Roth
 408: PPUSH
 409: CALL_OW 29
 413: AND
 414: IFFALSE 457
// begin Roth := CreateCharacter ( Roth ) ;
 416: LD_ADDR_EXP 14
 420: PUSH
 421: LD_STRING Roth
 423: PPUSH
 424: CALL_OW 34
 428: ST_TO_ADDR
// SetClass ( Roth , class_scientistic ) ;
 429: LD_EXP 14
 433: PPUSH
 434: LD_INT 4
 436: PPUSH
 437: CALL_OW 336
// aliance := aliance ^ Roth ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_VAR 0 8
 450: PUSH
 451: LD_EXP 14
 455: ADD
 456: ST_TO_ADDR
// end ; if TestCharacters ( Gossudarov ) and CheckCharacterSet ( Gossudarov ) then
 457: LD_STRING Gossudarov
 459: PPUSH
 460: CALL_OW 28
 464: PUSH
 465: LD_STRING Gossudarov
 467: PPUSH
 468: CALL_OW 29
 472: AND
 473: IFFALSE 516
// begin Gossudarov := CreateCharacter ( Gossudarov ) ;
 475: LD_ADDR_EXP 15
 479: PUSH
 480: LD_STRING Gossudarov
 482: PPUSH
 483: CALL_OW 34
 487: ST_TO_ADDR
// SetClass ( Gossudarov , class_scientistic ) ;
 488: LD_EXP 15
 492: PPUSH
 493: LD_INT 4
 495: PPUSH
 496: CALL_OW 336
// aliance := aliance ^ Gossudarov ;
 500: LD_ADDR_VAR 0 8
 504: PUSH
 505: LD_VAR 0 8
 509: PUSH
 510: LD_EXP 15
 514: ADD
 515: ST_TO_ADDR
// end ; if aliance < 20 then
 516: LD_VAR 0 8
 520: PUSH
 521: LD_INT 20
 523: LESS
 524: IFFALSE 585
// for i = aliance to 20 do
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: DOUBLE
 532: LD_VAR 0 8
 536: DEC
 537: ST_TO_ADDR
 538: LD_INT 20
 540: PUSH
 541: FOR_TO
 542: IFFALSE 583
// begin PrepareHuman ( 0 , 0 , 6 ) ;
 544: LD_INT 0
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: CALL_OW 380
// hc_last_mission := 15 ;
 557: LD_ADDR_OWVAR 36
 561: PUSH
 562: LD_INT 15
 564: ST_TO_ADDR
// aliance_forces := aliance_forces ^ CreateHuman ;
 565: LD_ADDR_EXP 57
 569: PUSH
 570: LD_EXP 57
 574: PUSH
 575: CALL_OW 44
 579: ADD
 580: ST_TO_ADDR
// end ;
 581: GO 541
 583: POP
 584: POP
// selected := CharacterSelection (  , 12 - aliance , 12 - aliance , aliance ^ [ sel_not_hired , sel_changeable , sel_change_class ] ^ aliance_forces , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
 585: LD_ADDR_VAR 0 7
 589: PUSH
 590: LD_STRING 
 592: PPUSH
 593: LD_INT 12
 595: PUSH
 596: LD_VAR 0 8
 600: MINUS
 601: PPUSH
 602: LD_INT 12
 604: PUSH
 605: LD_VAR 0 8
 609: MINUS
 610: PPUSH
 611: LD_VAR 0 8
 615: PUSH
 616: LD_INT -2
 618: PUSH
 619: LD_INT -3
 621: PUSH
 622: LD_INT -5
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: ADD
 630: PUSH
 631: LD_EXP 57
 635: ADD
 636: PPUSH
 637: LD_INT 1
 639: PUSH
 640: LD_INT 2
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL_OW 42
 659: ST_TO_ADDR
// aliance_forces := aliance ^ selected ;
 660: LD_ADDR_EXP 57
 664: PUSH
 665: LD_VAR 0 8
 669: PUSH
 670: LD_VAR 0 7
 674: ADD
 675: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 676: LD_ADDR_VAR 0 15
 680: PUSH
 681: LD_STRING JMM_car
 683: PPUSH
 684: LD_INT 3
 686: PUSH
 687: LD_INT 1
 689: PUSH
 690: LD_INT 1
 692: PUSH
 693: LD_INT 12
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PPUSH
 702: CALL_OW 30
 706: ST_TO_ADDR
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 707: LD_ADDR_VAR 0 16
 711: PUSH
 712: LD_STRING Bur_car
 714: PPUSH
 715: LD_INT 22
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 1
 723: PUSH
 724: LD_INT 45
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PPUSH
 733: CALL_OW 30
 737: ST_TO_ADDR
// if ( JMM_car [ 1 ] = 0 ) then
 738: LD_VAR 0 15
 742: PUSH
 743: LD_INT 1
 745: ARRAY
 746: PUSH
 747: LD_INT 0
 749: EQUAL
 750: IFFALSE 775
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 752: LD_ADDR_VAR 0 15
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 1
 762: PUSH
 763: LD_INT 1
 765: PUSH
 766: LD_INT 12
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: ST_TO_ADDR
// if ( Bur_car [ 1 ] = 0 ) then
 775: LD_VAR 0 16
 779: PUSH
 780: LD_INT 1
 782: ARRAY
 783: PUSH
 784: LD_INT 0
 786: EQUAL
 787: IFFALSE 812
// Bur_car := [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ;
 789: LD_ADDR_VAR 0 16
 793: PUSH
 794: LD_INT 22
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: LD_INT 1
 802: PUSH
 803: LD_INT 45
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: ST_TO_ADDR
// if not ( ( JMM_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) or ( Bur_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) ) then
 812: LD_VAR 0 15
 816: PUSH
 817: LD_INT 4
 819: ARRAY
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 51
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: IN
 831: PUSH
 832: LD_VAR 0 16
 836: PUSH
 837: LD_INT 4
 839: ARRAY
 840: PUSH
 841: LD_INT 12
 843: PUSH
 844: LD_INT 51
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: IN
 851: OR
 852: NOT
 853: IFFALSE 878
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 855: LD_ADDR_VAR 0 15
 859: PUSH
 860: LD_INT 3
 862: PUSH
 863: LD_INT 1
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 12
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: LIST
 877: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 878: LD_VAR 0 15
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PUSH
 887: LD_INT 1
 889: PUSH
 890: LD_INT 2
 892: PUSH
 893: LD_INT 3
 895: PUSH
 896: LD_INT 4
 898: PUSH
 899: LD_INT 5
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: IN
 909: IFFALSE 921
// uc_nation := nation_american else
 911: LD_ADDR_OWVAR 21
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
 919: GO 929
// uc_nation := nation_russian ;
 921: LD_ADDR_OWVAR 21
 925: PUSH
 926: LD_INT 3
 928: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
 929: LD_ADDR_OWVAR 24
 933: PUSH
 934: LD_INT 2
 936: PPUSH
 937: LD_INT 3
 939: PPUSH
 940: CALL_OW 12
 944: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 945: LD_ADDR_OWVAR 37
 949: PUSH
 950: LD_VAR 0 15
 954: PUSH
 955: LD_INT 1
 957: ARRAY
 958: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 959: LD_ADDR_OWVAR 39
 963: PUSH
 964: LD_VAR 0 15
 968: PUSH
 969: LD_INT 2
 971: ARRAY
 972: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 973: LD_ADDR_OWVAR 38
 977: PUSH
 978: LD_VAR 0 15
 982: PUSH
 983: LD_INT 3
 985: ARRAY
 986: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 987: LD_ADDR_OWVAR 40
 991: PUSH
 992: LD_VAR 0 15
 996: PUSH
 997: LD_INT 4
 999: ARRAY
1000: ST_TO_ADDR
// un := CreateVehicle ;
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: CALL_OW 45
1010: ST_TO_ADDR
// art_loaded := false ;
1011: LD_ADDR_VAR 0 6
1015: PUSH
1016: LD_INT 0
1018: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , un ) ;
1019: LD_EXP 13
1023: PPUSH
1024: LD_VAR 0 2
1028: PPUSH
1029: CALL_OW 52
// PlaceUnitArea ( un , jmm_starting , false ) ;
1033: LD_VAR 0 2
1037: PPUSH
1038: LD_INT 27
1040: PPUSH
1041: LD_INT 0
1043: PPUSH
1044: CALL_OW 49
// if GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] then
1048: LD_VAR 0 2
1052: PPUSH
1053: CALL_OW 264
1057: PUSH
1058: LD_INT 12
1060: PUSH
1061: LD_INT 51
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: IN
1068: IFFALSE 1093
// begin SetCargo ( un , mat_artefact , 50 ) ;
1070: LD_VAR 0 2
1074: PPUSH
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 50
1080: PPUSH
1081: CALL_OW 290
// art_loaded := true ;
1085: LD_ADDR_VAR 0 6
1089: PUSH
1090: LD_INT 1
1092: ST_TO_ADDR
// end ; if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
1093: LD_VAR 0 16
1097: PUSH
1098: LD_INT 1
1100: ARRAY
1101: PUSH
1102: LD_INT 21
1104: PUSH
1105: LD_INT 22
1107: PUSH
1108: LD_INT 23
1110: PUSH
1111: LD_INT 24
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: IN
1120: IFFALSE 1132
// uc_nation := nation_russian else
1122: LD_ADDR_OWVAR 21
1126: PUSH
1127: LD_INT 3
1129: ST_TO_ADDR
1130: GO 1140
// uc_nation := nation_american ;
1132: LD_ADDR_OWVAR 21
1136: PUSH
1137: LD_INT 1
1139: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
1140: LD_ADDR_OWVAR 24
1144: PUSH
1145: LD_INT 2
1147: PPUSH
1148: LD_INT 3
1150: PPUSH
1151: CALL_OW 12
1155: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
1156: LD_ADDR_OWVAR 37
1160: PUSH
1161: LD_VAR 0 16
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
1170: LD_ADDR_OWVAR 39
1174: PUSH
1175: LD_VAR 0 16
1179: PUSH
1180: LD_INT 2
1182: ARRAY
1183: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
1184: LD_ADDR_OWVAR 38
1188: PUSH
1189: LD_VAR 0 16
1193: PUSH
1194: LD_INT 3
1196: ARRAY
1197: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
1198: LD_ADDR_OWVAR 40
1202: PUSH
1203: LD_VAR 0 16
1207: PUSH
1208: LD_INT 4
1210: ARRAY
1211: ST_TO_ADDR
// un := CreateVehicle ;
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: CALL_OW 45
1221: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , un ) ;
1222: LD_EXP 12
1226: PPUSH
1227: LD_VAR 0 2
1231: PPUSH
1232: CALL_OW 52
// PlaceUnitArea ( un , burlak_starting , false ) ;
1236: LD_VAR 0 2
1240: PPUSH
1241: LD_INT 10
1243: PPUSH
1244: LD_INT 0
1246: PPUSH
1247: CALL_OW 49
// if ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) and not art_loaded then
1251: LD_VAR 0 2
1255: PPUSH
1256: CALL_OW 264
1260: PUSH
1261: LD_INT 12
1263: PUSH
1264: LD_INT 51
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: IN
1271: PUSH
1272: LD_VAR 0 6
1276: NOT
1277: AND
1278: IFFALSE 1295
// SetCargo ( un , mat_artefact , 50 ) ;
1280: LD_VAR 0 2
1284: PPUSH
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 50
1290: PPUSH
1291: CALL_OW 290
// veh_cargo := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_cargo_bay ] , [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay ] ] ;
1295: LD_ADDR_VAR 0 10
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: LD_INT 3
1311: PUSH
1312: LD_INT 12
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: PUSH
1322: LD_INT 1
1324: PUSH
1325: LD_INT 3
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: LD_INT 1
1333: PUSH
1334: LD_INT 12
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 3
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 3
1352: PUSH
1353: LD_INT 3
1355: PUSH
1356: LD_INT 51
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 22
1371: PUSH
1372: LD_INT 3
1374: PUSH
1375: LD_INT 1
1377: PUSH
1378: LD_INT 51
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: ST_TO_ADDR
// veh_basic := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_crane ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_bulldozer ] , ] ;
1394: LD_ADDR_VAR 0 11
1398: PUSH
1399: LD_INT 1
1401: PUSH
1402: LD_INT 3
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 3
1410: PUSH
1411: LD_INT 13
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: PUSH
1421: LD_INT 3
1423: PUSH
1424: LD_INT 24
1426: PUSH
1427: LD_INT 3
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 53
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: ST_TO_ADDR
// veh_battle := [ [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_american , us_medium_tracked , engine_siberite , control_manual , us_laser ] , [ nation_american , us_heavy_tracked , engine_siberite , control_manual , us_heavy_gun ] , [ nation_american , us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_russian , ru_medium_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_gun ] , [ nation_russian , ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun ] , ] ;
1447: LD_ADDR_VAR 0 12
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 3
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 1
1463: PUSH
1464: LD_INT 7
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PUSH
1474: LD_INT 1
1476: PUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 3
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 9
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 3
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: LIST
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 5
1523: PUSH
1524: LD_INT 1
1526: PUSH
1527: LD_INT 1
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 21
1545: PUSH
1546: LD_INT 1
1548: PUSH
1549: LD_INT 1
1551: PUSH
1552: LD_INT 45
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 3
1564: PUSH
1565: LD_INT 22
1567: PUSH
1568: LD_INT 3
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: LD_INT 44
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: PUSH
1584: LD_INT 3
1586: PUSH
1587: LD_INT 23
1589: PUSH
1590: LD_INT 1
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: LD_INT 46
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: PUSH
1606: LD_INT 3
1608: PUSH
1609: LD_INT 24
1611: PUSH
1612: LD_INT 3
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: LD_INT 46
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: PUSH
1628: EMPTY
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: ST_TO_ADDR
// veh_list := [ ] ;
1638: LD_ADDR_VAR 0 14
1642: PUSH
1643: EMPTY
1644: ST_TO_ADDR
// count := 0 ;
1645: LD_ADDR_VAR 0 3
1649: PUSH
1650: LD_INT 0
1652: ST_TO_ADDR
// for i = 3 to 4 do
1653: LD_ADDR_VAR 0 4
1657: PUSH
1658: DOUBLE
1659: LD_INT 3
1661: DEC
1662: ST_TO_ADDR
1663: LD_INT 4
1665: PUSH
1666: FOR_TO
1667: IFFALSE 1852
// begin uc_direction := Rand ( 2 , 3 ) ;
1669: LD_ADDR_OWVAR 24
1673: PUSH
1674: LD_INT 2
1676: PPUSH
1677: LD_INT 3
1679: PPUSH
1680: CALL_OW 12
1684: ST_TO_ADDR
// un := veh_cargo [ Rand ( 1 , veh_cargo ) ] ;
1685: LD_ADDR_VAR 0 2
1689: PUSH
1690: LD_VAR 0 10
1694: PUSH
1695: LD_INT 1
1697: PPUSH
1698: LD_VAR 0 10
1702: PPUSH
1703: CALL_OW 12
1707: ARRAY
1708: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1709: LD_ADDR_OWVAR 21
1713: PUSH
1714: LD_VAR 0 2
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1723: LD_ADDR_OWVAR 37
1727: PUSH
1728: LD_VAR 0 2
1732: PUSH
1733: LD_INT 2
1735: ARRAY
1736: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1737: LD_ADDR_OWVAR 39
1741: PUSH
1742: LD_VAR 0 2
1746: PUSH
1747: LD_INT 3
1749: ARRAY
1750: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1751: LD_ADDR_OWVAR 38
1755: PUSH
1756: LD_VAR 0 2
1760: PUSH
1761: LD_INT 4
1763: ARRAY
1764: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1765: LD_ADDR_OWVAR 40
1769: PUSH
1770: LD_VAR 0 2
1774: PUSH
1775: LD_INT 5
1777: ARRAY
1778: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1779: LD_ADDR_VAR 0 14
1783: PUSH
1784: LD_VAR 0 14
1788: PUSH
1789: CALL_OW 45
1793: ADD
1794: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1795: LD_VAR 0 2
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: PUSH
1804: LD_INT 1
1806: EQUAL
1807: IFFALSE 1823
// count := count + 1 ;
1809: LD_ADDR_VAR 0 3
1813: PUSH
1814: LD_VAR 0 3
1818: PUSH
1819: LD_INT 1
1821: PLUS
1822: ST_TO_ADDR
// SetCargo ( veh_list [ veh_list ] , mat_artefact , i * 10 ) ;
1823: LD_VAR 0 14
1827: PUSH
1828: LD_VAR 0 14
1832: ARRAY
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_VAR 0 4
1841: PUSH
1842: LD_INT 10
1844: MUL
1845: PPUSH
1846: CALL_OW 290
// end ;
1850: GO 1666
1852: POP
1853: POP
// for un in veh_basic do
1854: LD_ADDR_VAR 0 2
1858: PUSH
1859: LD_VAR 0 11
1863: PUSH
1864: FOR_IN
1865: IFFALSE 1999
// begin uc_direction := Rand ( 2 , 3 ) ;
1867: LD_ADDR_OWVAR 24
1871: PUSH
1872: LD_INT 2
1874: PPUSH
1875: LD_INT 3
1877: PPUSH
1878: CALL_OW 12
1882: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1883: LD_ADDR_OWVAR 21
1887: PUSH
1888: LD_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: ARRAY
1896: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1897: LD_ADDR_OWVAR 37
1901: PUSH
1902: LD_VAR 0 2
1906: PUSH
1907: LD_INT 2
1909: ARRAY
1910: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1911: LD_ADDR_OWVAR 39
1915: PUSH
1916: LD_VAR 0 2
1920: PUSH
1921: LD_INT 3
1923: ARRAY
1924: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1925: LD_ADDR_OWVAR 38
1929: PUSH
1930: LD_VAR 0 2
1934: PUSH
1935: LD_INT 4
1937: ARRAY
1938: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1939: LD_ADDR_OWVAR 40
1943: PUSH
1944: LD_VAR 0 2
1948: PUSH
1949: LD_INT 5
1951: ARRAY
1952: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1953: LD_ADDR_VAR 0 14
1957: PUSH
1958: LD_VAR 0 14
1962: PUSH
1963: CALL_OW 45
1967: ADD
1968: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1969: LD_VAR 0 2
1973: PUSH
1974: LD_INT 4
1976: ARRAY
1977: PUSH
1978: LD_INT 1
1980: EQUAL
1981: IFFALSE 1997
// count := count + 1 ;
1983: LD_ADDR_VAR 0 3
1987: PUSH
1988: LD_VAR 0 3
1992: PUSH
1993: LD_INT 1
1995: PLUS
1996: ST_TO_ADDR
// end ;
1997: GO 1864
1999: POP
2000: POP
// count := aliance_forces - 2 - count ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: LD_EXP 57
2010: PUSH
2011: LD_INT 2
2013: MINUS
2014: PUSH
2015: LD_VAR 0 3
2019: MINUS
2020: ST_TO_ADDR
// for i = 1 to count do
2021: LD_ADDR_VAR 0 4
2025: PUSH
2026: DOUBLE
2027: LD_INT 1
2029: DEC
2030: ST_TO_ADDR
2031: LD_VAR 0 3
2035: PUSH
2036: FOR_TO
2037: IFFALSE 2167
// begin uc_direction := Rand ( 2 , 3 ) ;
2039: LD_ADDR_OWVAR 24
2043: PUSH
2044: LD_INT 2
2046: PPUSH
2047: LD_INT 3
2049: PPUSH
2050: CALL_OW 12
2054: ST_TO_ADDR
// un := veh_battle [ Rand ( 1 , veh_battle ) ] ;
2055: LD_ADDR_VAR 0 2
2059: PUSH
2060: LD_VAR 0 12
2064: PUSH
2065: LD_INT 1
2067: PPUSH
2068: LD_VAR 0 12
2072: PPUSH
2073: CALL_OW 12
2077: ARRAY
2078: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
2079: LD_ADDR_OWVAR 21
2083: PUSH
2084: LD_VAR 0 2
2088: PUSH
2089: LD_INT 1
2091: ARRAY
2092: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
2093: LD_ADDR_OWVAR 37
2097: PUSH
2098: LD_VAR 0 2
2102: PUSH
2103: LD_INT 2
2105: ARRAY
2106: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
2107: LD_ADDR_OWVAR 39
2111: PUSH
2112: LD_VAR 0 2
2116: PUSH
2117: LD_INT 3
2119: ARRAY
2120: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2121: LD_ADDR_OWVAR 38
2125: PUSH
2126: LD_VAR 0 2
2130: PUSH
2131: LD_INT 4
2133: ARRAY
2134: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2135: LD_ADDR_OWVAR 40
2139: PUSH
2140: LD_VAR 0 2
2144: PUSH
2145: LD_INT 5
2147: ARRAY
2148: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2149: LD_ADDR_VAR 0 14
2153: PUSH
2154: LD_VAR 0 14
2158: PUSH
2159: CALL_OW 45
2163: ADD
2164: ST_TO_ADDR
// end ;
2165: GO 2036
2167: POP
2168: POP
// pom_list := aliance_forces diff [ MacMillan , Burlak ] ;
2169: LD_ADDR_VAR 0 9
2173: PUSH
2174: LD_EXP 57
2178: PUSH
2179: LD_EXP 13
2183: PUSH
2184: LD_EXP 12
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: DIFF
2193: ST_TO_ADDR
// i := 1 ;
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// for un in veh_list do
2202: LD_ADDR_VAR 0 2
2206: PUSH
2207: LD_VAR 0 14
2211: PUSH
2212: FOR_IN
2213: IFFALSE 2314
// begin uc_direction := Rand ( 2 , 3 ) ;
2215: LD_ADDR_OWVAR 24
2219: PUSH
2220: LD_INT 2
2222: PPUSH
2223: LD_INT 3
2225: PPUSH
2226: CALL_OW 12
2230: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
2231: LD_VAR 0 2
2235: PPUSH
2236: CALL_OW 263
2240: PUSH
2241: LD_INT 1
2243: EQUAL
2244: IFFALSE 2297
// begin PlaceHumanInUnit ( pom_list [ i ] , un ) ;
2246: LD_VAR 0 9
2250: PUSH
2251: LD_VAR 0 4
2255: ARRAY
2256: PPUSH
2257: LD_VAR 0 2
2261: PPUSH
2262: CALL_OW 52
// PlaceUnitArea ( un , starting_area , false ) ;
2266: LD_VAR 0 2
2270: PPUSH
2271: LD_INT 7
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 49
// i := i + 1 ;
2281: LD_ADDR_VAR 0 4
2285: PUSH
2286: LD_VAR 0 4
2290: PUSH
2291: LD_INT 1
2293: PLUS
2294: ST_TO_ADDR
// end else
2295: GO 2312
// PlaceUnitArea ( un , starting_area , false ) ;
2297: LD_VAR 0 2
2301: PPUSH
2302: LD_INT 7
2304: PPUSH
2305: LD_INT 0
2307: PPUSH
2308: CALL_OW 49
// end ;
2312: GO 2212
2314: POP
2315: POP
// ComEnterUnit ( uss_ape , uss ) ;
2316: LD_INT 146
2318: PPUSH
2319: LD_INT 38
2321: PPUSH
2322: CALL_OW 120
// end ;
2326: LD_VAR 0 1
2330: RET
// function prepare_sides ; begin
2331: LD_INT 0
2333: PPUSH
// neutral := 0 ;
2334: LD_ADDR_EXP 6
2338: PUSH
2339: LD_INT 0
2341: ST_TO_ADDR
// you := 7 ;
2342: LD_ADDR_EXP 1
2346: PUSH
2347: LD_INT 7
2349: ST_TO_ADDR
// camp := 4 ;
2350: LD_ADDR_EXP 7
2354: PUSH
2355: LD_INT 4
2357: ST_TO_ADDR
// ru := 3 ;
2358: LD_ADDR_EXP 2
2362: PUSH
2363: LD_INT 3
2365: ST_TO_ADDR
// us := 1 ;
2366: LD_ADDR_EXP 3
2370: PUSH
2371: LD_INT 1
2373: ST_TO_ADDR
// ar := 2 ;
2374: LD_ADDR_EXP 4
2378: PUSH
2379: LD_INT 2
2381: ST_TO_ADDR
// ar_al := 5 ;
2382: LD_ADDR_EXP 5
2386: PUSH
2387: LD_INT 5
2389: ST_TO_ADDR
// cpu_list := [ us , ar , ru ] ;
2390: LD_ADDR_EXP 8
2394: PUSH
2395: LD_EXP 3
2399: PUSH
2400: LD_EXP 4
2404: PUSH
2405: LD_EXP 2
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: ST_TO_ADDR
// ru_nation := nation_russian ;
2415: LD_ADDR_EXP 9
2419: PUSH
2420: LD_INT 3
2422: ST_TO_ADDR
// us_nation := nation_american ;
2423: LD_ADDR_EXP 10
2427: PUSH
2428: LD_INT 1
2430: ST_TO_ADDR
// ar_nation := nation_arabian ;
2431: LD_ADDR_EXP 11
2435: PUSH
2436: LD_INT 2
2438: ST_TO_ADDR
// finalize := 0 ;
2439: LD_ADDR_EXP 58
2443: PUSH
2444: LD_INT 0
2446: ST_TO_ADDR
// siberite_rocket_send := false ;
2447: LD_ADDR_EXP 60
2451: PUSH
2452: LD_INT 0
2454: ST_TO_ADDR
// disable ( 1 ) ;
2455: LD_INT 1
2457: DISABLE_MARKED
// disable ( 2 ) ;
2458: LD_INT 2
2460: DISABLE_MARKED
// disable ( 4 ) ;
2461: LD_INT 4
2463: DISABLE_MARKED
// disable ( 5 ) ;
2464: LD_INT 5
2466: DISABLE_MARKED
// disable ( 24 ) ;
2467: LD_INT 24
2469: DISABLE_MARKED
// disable ( 25 ) ;
2470: LD_INT 25
2472: DISABLE_MARKED
// disable ( 26 ) ;
2473: LD_INT 26
2475: DISABLE_MARKED
// disable ( 222 ) ;
2476: LD_INT 222
2478: DISABLE_MARKED
// disable ( 223 ) ;
2479: LD_INT 223
2481: DISABLE_MARKED
// SetAttitude ( you , ru , att_enemy , true ) ;
2482: LD_EXP 1
2486: PPUSH
2487: LD_EXP 2
2491: PPUSH
2492: LD_INT 2
2494: PPUSH
2495: LD_INT 1
2497: PPUSH
2498: CALL_OW 80
// SetAttitude ( you , us , att_enemy , true ) ;
2502: LD_EXP 1
2506: PPUSH
2507: LD_EXP 3
2511: PPUSH
2512: LD_INT 2
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 80
// SetAttitude ( you , ar , att_enemy , true ) ;
2522: LD_EXP 1
2526: PPUSH
2527: LD_EXP 4
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: CALL_OW 80
// SetAttitude ( you , neutral , att_neutral , true ) ;
2542: LD_EXP 1
2546: PPUSH
2547: LD_EXP 6
2551: PPUSH
2552: LD_INT 0
2554: PPUSH
2555: LD_INT 1
2557: PPUSH
2558: CALL_OW 80
// SetAttitude ( you , ar_al , att_enemy , true ) ;
2562: LD_EXP 1
2566: PPUSH
2567: LD_EXP 5
2571: PPUSH
2572: LD_INT 2
2574: PPUSH
2575: LD_INT 1
2577: PPUSH
2578: CALL_OW 80
// SetAttitude ( ru , us , att_enemy , true ) ;
2582: LD_EXP 2
2586: PPUSH
2587: LD_EXP 3
2591: PPUSH
2592: LD_INT 2
2594: PPUSH
2595: LD_INT 1
2597: PPUSH
2598: CALL_OW 80
// SetAttitude ( ru , ar , att_enemy , true ) ;
2602: LD_EXP 2
2606: PPUSH
2607: LD_EXP 4
2611: PPUSH
2612: LD_INT 2
2614: PPUSH
2615: LD_INT 1
2617: PPUSH
2618: CALL_OW 80
// SetAttitude ( us , ar , att_enemy , true ) ;
2622: LD_EXP 3
2626: PPUSH
2627: LD_EXP 4
2631: PPUSH
2632: LD_INT 2
2634: PPUSH
2635: LD_INT 1
2637: PPUSH
2638: CALL_OW 80
// SetAttitude ( ru , ar_al , att_enemy , true ) ;
2642: LD_EXP 2
2646: PPUSH
2647: LD_EXP 5
2651: PPUSH
2652: LD_INT 2
2654: PPUSH
2655: LD_INT 1
2657: PPUSH
2658: CALL_OW 80
// SetAttitude ( us , ar_al , att_enemy , true ) ;
2662: LD_EXP 3
2666: PPUSH
2667: LD_EXP 5
2671: PPUSH
2672: LD_INT 2
2674: PPUSH
2675: LD_INT 1
2677: PPUSH
2678: CALL_OW 80
// end ;
2682: LD_VAR 0 1
2686: RET
// starting begin RandomizeAll ;
2687: CALL_OW 11
// prepare_sides ;
2691: CALL 2331 0 0
// prepare_us_units ;
2695: CALL 0 0 0
// prepare_ru_units ;
2699: CALL 35 0 0
// prepare_ar_units ;
2703: CALL 70 0 0
// prepare_al_units ;
2707: CALL 249 0 0
// prepare_apemans ;
2711: CALL 7126 0 0
// create_russians ;
2715: CALL 4649 0 0
// create_americans ;
2719: CALL 5349 0 0
// create_arabians ;
2723: CALL 6100 0 0
// init_distribution ;
2727: CALL 26469 0 0
// init_defend ;
2731: CALL 18274 0 0
// init_attack ;
2735: CALL 20887 0 0
// init_keep_base ;
2739: CALL 32342 0 0
// init_research ;
2743: CALL 24066 0 0
// init_manufacture ;
2747: CALL 26816 0 0
// init_crates_loading ;
2751: CALL 32748 0 0
// init_crates_collecting ;
2755: CALL 33485 0 0
// init_alien_research ;
2759: CALL 37009 0 0
// init_sib_rocket ;
2763: CALL 36178 0 0
// starting_scene ;
2767: CALL 7358 0 0
// end ; end_of_file
2771: END
// export function load_all_aliance ; begin
2772: LD_INT 0
2774: PPUSH
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) then
2775: LD_STRING Belkov
2777: PPUSH
2778: CALL_OW 28
2782: PUSH
2783: LD_STRING Belkov
2785: PPUSH
2786: CALL_OW 29
2790: AND
2791: IFFALSE 2822
// begin Belkov := CreateCharacter ( Belkov ) ;
2793: LD_ADDR_EXP 17
2797: PUSH
2798: LD_STRING Belkov
2800: PPUSH
2801: CALL_OW 34
2805: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Belkov ;
2806: LD_ADDR_EXP 57
2810: PUSH
2811: LD_EXP 57
2815: PUSH
2816: LD_EXP 17
2820: ADD
2821: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) then
2822: LD_STRING Petrosyan
2824: PPUSH
2825: CALL_OW 28
2829: PUSH
2830: LD_STRING Petrosyan
2832: PPUSH
2833: CALL_OW 29
2837: AND
2838: IFFALSE 2869
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
2840: LD_ADDR_EXP 16
2844: PUSH
2845: LD_STRING Petrosyan
2847: PPUSH
2848: CALL_OW 34
2852: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrosyan ;
2853: LD_ADDR_EXP 57
2857: PUSH
2858: LD_EXP 57
2862: PUSH
2863: LD_EXP 16
2867: ADD
2868: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) then
2869: LD_STRING Kirilenkova
2871: PPUSH
2872: CALL_OW 28
2876: PUSH
2877: LD_STRING Kirilenkova
2879: PPUSH
2880: CALL_OW 29
2884: AND
2885: IFFALSE 2916
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
2887: LD_ADDR_EXP 18
2891: PUSH
2892: LD_STRING Kirilenkova
2894: PPUSH
2895: CALL_OW 34
2899: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kirilenkova ;
2900: LD_ADDR_EXP 57
2904: PUSH
2905: LD_EXP 57
2909: PUSH
2910: LD_EXP 18
2914: ADD
2915: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) then
2916: LD_STRING Gnyevko
2918: PPUSH
2919: CALL_OW 28
2923: PUSH
2924: LD_STRING Gnyevko
2926: PPUSH
2927: CALL_OW 29
2931: AND
2932: IFFALSE 2963
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
2934: LD_ADDR_EXP 19
2938: PUSH
2939: LD_STRING Gnyevko
2941: PPUSH
2942: CALL_OW 34
2946: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gnyevko ;
2947: LD_ADDR_EXP 57
2951: PUSH
2952: LD_EXP 57
2956: PUSH
2957: LD_EXP 19
2961: ADD
2962: ST_TO_ADDR
// end ; if TestCharacters ( Gladkov ) and CheckCharacterSet ( Gladkov ) then
2963: LD_STRING Gladkov
2965: PPUSH
2966: CALL_OW 28
2970: PUSH
2971: LD_STRING Gladkov
2973: PPUSH
2974: CALL_OW 29
2978: AND
2979: IFFALSE 3010
// begin Gladkov := CreateCharacter ( Gladkov ) ;
2981: LD_ADDR_EXP 20
2985: PUSH
2986: LD_STRING Gladkov
2988: PPUSH
2989: CALL_OW 34
2993: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladkov ;
2994: LD_ADDR_EXP 57
2998: PUSH
2999: LD_EXP 57
3003: PUSH
3004: LD_EXP 20
3008: ADD
3009: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) then
3010: LD_STRING Dolgov
3012: PPUSH
3013: CALL_OW 28
3017: PUSH
3018: LD_STRING Dolgov
3020: PPUSH
3021: CALL_OW 29
3025: AND
3026: IFFALSE 3057
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3028: LD_ADDR_EXP 21
3032: PUSH
3033: LD_STRING Dolgov
3035: PPUSH
3036: CALL_OW 34
3040: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Dolgov ;
3041: LD_ADDR_EXP 57
3045: PUSH
3046: LD_EXP 57
3050: PUSH
3051: LD_EXP 21
3055: ADD
3056: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) then
3057: LD_STRING Gleb
3059: PPUSH
3060: CALL_OW 28
3064: PUSH
3065: LD_STRING Gleb
3067: PPUSH
3068: CALL_OW 29
3072: AND
3073: IFFALSE 3104
// begin Gleb := CreateCharacter ( Gleb ) ;
3075: LD_ADDR_EXP 22
3079: PUSH
3080: LD_STRING Gleb
3082: PPUSH
3083: CALL_OW 34
3087: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gleb ;
3088: LD_ADDR_EXP 57
3092: PUSH
3093: LD_EXP 57
3097: PUSH
3098: LD_EXP 22
3102: ADD
3103: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) then
3104: LD_STRING Kapitsova
3106: PPUSH
3107: CALL_OW 28
3111: PUSH
3112: LD_STRING Kapitsova
3114: PPUSH
3115: CALL_OW 29
3119: AND
3120: IFFALSE 3151
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3122: LD_ADDR_EXP 23
3126: PUSH
3127: LD_STRING Kapitsova
3129: PPUSH
3130: CALL_OW 34
3134: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kapitsova ;
3135: LD_ADDR_EXP 57
3139: PUSH
3140: LD_EXP 57
3144: PUSH
3145: LD_EXP 23
3149: ADD
3150: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) then
3151: LD_STRING Kuzmov
3153: PPUSH
3154: CALL_OW 28
3158: PUSH
3159: LD_STRING Kuzmov
3161: PPUSH
3162: CALL_OW 29
3166: AND
3167: IFFALSE 3198
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3169: LD_ADDR_EXP 24
3173: PUSH
3174: LD_STRING Kuzmov
3176: PPUSH
3177: CALL_OW 34
3181: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kuzmov ;
3182: LD_ADDR_EXP 57
3186: PUSH
3187: LD_EXP 57
3191: PUSH
3192: LD_EXP 24
3196: ADD
3197: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) then
3198: LD_STRING Kovalyuk
3200: PPUSH
3201: CALL_OW 28
3205: PUSH
3206: LD_STRING Kovalyuk
3208: PPUSH
3209: CALL_OW 29
3213: AND
3214: IFFALSE 3245
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
3216: LD_ADDR_EXP 25
3220: PUSH
3221: LD_STRING Kovalyuk
3223: PPUSH
3224: CALL_OW 34
3228: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kovalyuk ;
3229: LD_ADDR_EXP 57
3233: PUSH
3234: LD_EXP 57
3238: PUSH
3239: LD_EXP 25
3243: ADD
3244: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) then
3245: LD_STRING Scholtze
3247: PPUSH
3248: CALL_OW 28
3252: PUSH
3253: LD_STRING Scholtze
3255: PPUSH
3256: CALL_OW 29
3260: AND
3261: IFFALSE 3292
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3263: LD_ADDR_EXP 26
3267: PUSH
3268: LD_STRING Scholtze
3270: PPUSH
3271: CALL_OW 34
3275: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Scholtze ;
3276: LD_ADDR_EXP 57
3280: PUSH
3281: LD_EXP 57
3285: PUSH
3286: LD_EXP 26
3290: ADD
3291: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) then
3292: LD_STRING Karamazov
3294: PPUSH
3295: CALL_OW 28
3299: PUSH
3300: LD_STRING Karamazov
3302: PPUSH
3303: CALL_OW 29
3307: AND
3308: IFFALSE 3339
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3310: LD_ADDR_EXP 27
3314: PUSH
3315: LD_STRING Karamazov
3317: PPUSH
3318: CALL_OW 34
3322: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Karamazov ;
3323: LD_ADDR_EXP 57
3327: PUSH
3328: LD_EXP 57
3332: PUSH
3333: LD_EXP 27
3337: ADD
3338: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) then
3339: LD_STRING Titov
3341: PPUSH
3342: CALL_OW 28
3346: PUSH
3347: LD_STRING Titov
3349: PPUSH
3350: CALL_OW 29
3354: AND
3355: IFFALSE 3386
// begin Titov := CreateCharacter ( Titov ) ;
3357: LD_ADDR_EXP 28
3361: PUSH
3362: LD_STRING Titov
3364: PPUSH
3365: CALL_OW 34
3369: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Titov ;
3370: LD_ADDR_EXP 57
3374: PUSH
3375: LD_EXP 57
3379: PUSH
3380: LD_EXP 28
3384: ADD
3385: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) then
3386: LD_STRING Oblukov
3388: PPUSH
3389: CALL_OW 28
3393: PUSH
3394: LD_STRING Oblukov
3396: PPUSH
3397: CALL_OW 29
3401: AND
3402: IFFALSE 3433
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3404: LD_ADDR_EXP 29
3408: PUSH
3409: LD_STRING Oblukov
3411: PPUSH
3412: CALL_OW 34
3416: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Oblukov ;
3417: LD_ADDR_EXP 57
3421: PUSH
3422: LD_EXP 57
3426: PUSH
3427: LD_EXP 29
3431: ADD
3432: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) then
3433: LD_STRING Kozlov
3435: PPUSH
3436: CALL_OW 28
3440: PUSH
3441: LD_STRING Kozlov
3443: PPUSH
3444: CALL_OW 29
3448: AND
3449: IFFALSE 3480
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3451: LD_ADDR_EXP 30
3455: PUSH
3456: LD_STRING Kozlov
3458: PPUSH
3459: CALL_OW 34
3463: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kozlov ;
3464: LD_ADDR_EXP 57
3468: PUSH
3469: LD_EXP 57
3473: PUSH
3474: LD_EXP 30
3478: ADD
3479: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) then
3480: LD_STRING Petrovova
3482: PPUSH
3483: CALL_OW 28
3487: PUSH
3488: LD_STRING Petrovova
3490: PPUSH
3491: CALL_OW 29
3495: AND
3496: IFFALSE 3527
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3498: LD_ADDR_EXP 31
3502: PUSH
3503: LD_STRING Petrovova
3505: PPUSH
3506: CALL_OW 34
3510: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrovova ;
3511: LD_ADDR_EXP 57
3515: PUSH
3516: LD_EXP 57
3520: PUSH
3521: LD_EXP 31
3525: ADD
3526: ST_TO_ADDR
// end ; if TestCharacters ( Bystrov ) and CheckCharacterSet ( Bystrov ) then
3527: LD_STRING Bystrov
3529: PPUSH
3530: CALL_OW 28
3534: PUSH
3535: LD_STRING Bystrov
3537: PPUSH
3538: CALL_OW 29
3542: AND
3543: IFFALSE 3574
// begin Bystrov := CreateCharacter ( Bystrov ) ;
3545: LD_ADDR_EXP 32
3549: PUSH
3550: LD_STRING Bystrov
3552: PPUSH
3553: CALL_OW 34
3557: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bystrov ;
3558: LD_ADDR_EXP 57
3562: PUSH
3563: LD_EXP 57
3567: PUSH
3568: LD_EXP 32
3572: ADD
3573: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) then
3574: LD_STRING Lipshchin
3576: PPUSH
3577: CALL_OW 28
3581: PUSH
3582: LD_STRING Lipshchin
3584: PPUSH
3585: CALL_OW 29
3589: AND
3590: IFFALSE 3621
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3592: LD_ADDR_EXP 33
3596: PUSH
3597: LD_STRING Lipshchin
3599: PPUSH
3600: CALL_OW 34
3604: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lipshchin ;
3605: LD_ADDR_EXP 57
3609: PUSH
3610: LD_EXP 57
3614: PUSH
3615: LD_EXP 33
3619: ADD
3620: ST_TO_ADDR
// end ; if TestCharacters ( Fadeev ) and CheckCharacterSet ( Fadeev ) then
3621: LD_STRING Fadeev
3623: PPUSH
3624: CALL_OW 28
3628: PUSH
3629: LD_STRING Fadeev
3631: PPUSH
3632: CALL_OW 29
3636: AND
3637: IFFALSE 3668
// begin Fadeev := CreateCharacter ( Fadeev ) ;
3639: LD_ADDR_EXP 34
3643: PUSH
3644: LD_STRING Fadeev
3646: PPUSH
3647: CALL_OW 34
3651: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Fadeev ;
3652: LD_ADDR_EXP 57
3656: PUSH
3657: LD_EXP 57
3661: PUSH
3662: LD_EXP 34
3666: ADD
3667: ST_TO_ADDR
// end ; if TestCharacters ( Bobby ) and CheckCharacterSet ( Bobby ) then
3668: LD_STRING Bobby
3670: PPUSH
3671: CALL_OW 28
3675: PUSH
3676: LD_STRING Bobby
3678: PPUSH
3679: CALL_OW 29
3683: AND
3684: IFFALSE 3715
// begin Bobby := CreateCharacter ( Bobby ) ;
3686: LD_ADDR_EXP 35
3690: PUSH
3691: LD_STRING Bobby
3693: PPUSH
3694: CALL_OW 34
3698: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bobby ;
3699: LD_ADDR_EXP 57
3703: PUSH
3704: LD_EXP 57
3708: PUSH
3709: LD_EXP 35
3713: ADD
3714: ST_TO_ADDR
// end ; if TestCharacters ( Brown ) and CheckCharacterSet ( Brown ) then
3715: LD_STRING Brown
3717: PPUSH
3718: CALL_OW 28
3722: PUSH
3723: LD_STRING Brown
3725: PPUSH
3726: CALL_OW 29
3730: AND
3731: IFFALSE 3762
// begin Brown := CreateCharacter ( Brown ) ;
3733: LD_ADDR_EXP 36
3737: PUSH
3738: LD_STRING Brown
3740: PPUSH
3741: CALL_OW 34
3745: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Brown ;
3746: LD_ADDR_EXP 57
3750: PUSH
3751: LD_EXP 57
3755: PUSH
3756: LD_EXP 36
3760: ADD
3761: ST_TO_ADDR
// end ; if TestCharacters ( Cornell ) and CheckCharacterSet ( Cornell ) then
3762: LD_STRING Cornell
3764: PPUSH
3765: CALL_OW 28
3769: PUSH
3770: LD_STRING Cornell
3772: PPUSH
3773: CALL_OW 29
3777: AND
3778: IFFALSE 3809
// begin Cornell := CreateCharacter ( Cornell ) ;
3780: LD_ADDR_EXP 37
3784: PUSH
3785: LD_STRING Cornell
3787: PPUSH
3788: CALL_OW 34
3792: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cornell ;
3793: LD_ADDR_EXP 57
3797: PUSH
3798: LD_EXP 57
3802: PUSH
3803: LD_EXP 37
3807: ADD
3808: ST_TO_ADDR
// end ; if TestCharacters ( Coonie ) and CheckCharacterSet ( Coonie ) then
3809: LD_STRING Coonie
3811: PPUSH
3812: CALL_OW 28
3816: PUSH
3817: LD_STRING Coonie
3819: PPUSH
3820: CALL_OW 29
3824: AND
3825: IFFALSE 3856
// begin Connie := CreateCharacter ( Coonie ) ;
3827: LD_ADDR_EXP 38
3831: PUSH
3832: LD_STRING Coonie
3834: PPUSH
3835: CALL_OW 34
3839: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Connie ;
3840: LD_ADDR_EXP 57
3844: PUSH
3845: LD_EXP 57
3849: PUSH
3850: LD_EXP 38
3854: ADD
3855: ST_TO_ADDR
// end ; if TestCharacters ( Cyrus ) and CheckCharacterSet ( Cyrus ) then
3856: LD_STRING Cyrus
3858: PPUSH
3859: CALL_OW 28
3863: PUSH
3864: LD_STRING Cyrus
3866: PPUSH
3867: CALL_OW 29
3871: AND
3872: IFFALSE 3903
// begin Cyrus := CreateCharacter ( Cyrus ) ;
3874: LD_ADDR_EXP 39
3878: PUSH
3879: LD_STRING Cyrus
3881: PPUSH
3882: CALL_OW 34
3886: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cyrus ;
3887: LD_ADDR_EXP 57
3891: PUSH
3892: LD_EXP 57
3896: PUSH
3897: LD_EXP 39
3901: ADD
3902: ST_TO_ADDR
// end ; if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
3903: LD_STRING Denis
3905: PPUSH
3906: CALL_OW 28
3910: PUSH
3911: LD_STRING Denis
3913: PPUSH
3914: CALL_OW 29
3918: AND
3919: IFFALSE 3950
// begin Denis := CreateCharacter ( Denis ) ;
3921: LD_ADDR_EXP 40
3925: PUSH
3926: LD_STRING Denis
3928: PPUSH
3929: CALL_OW 34
3933: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Denis ;
3934: LD_ADDR_EXP 57
3938: PUSH
3939: LD_EXP 57
3943: PUSH
3944: LD_EXP 40
3948: ADD
3949: ST_TO_ADDR
// end ; if TestCharacters ( Donaldson ) and CheckCharacterSet ( Donaldson ) then
3950: LD_STRING Donaldson
3952: PPUSH
3953: CALL_OW 28
3957: PUSH
3958: LD_STRING Donaldson
3960: PPUSH
3961: CALL_OW 29
3965: AND
3966: IFFALSE 3997
// begin Donaldson := CreateCharacter ( Donaldson ) ;
3968: LD_ADDR_EXP 41
3972: PUSH
3973: LD_STRING Donaldson
3975: PPUSH
3976: CALL_OW 34
3980: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Donaldson ;
3981: LD_ADDR_EXP 57
3985: PUSH
3986: LD_EXP 57
3990: PUSH
3991: LD_EXP 41
3995: ADD
3996: ST_TO_ADDR
// end ; if TestCharacters ( Frank ) and CheckCharacterSet ( Frank ) then
3997: LD_STRING Frank
3999: PPUSH
4000: CALL_OW 28
4004: PUSH
4005: LD_STRING Frank
4007: PPUSH
4008: CALL_OW 29
4012: AND
4013: IFFALSE 4044
// begin Frank := CreateCharacter ( Frank ) ;
4015: LD_ADDR_EXP 42
4019: PUSH
4020: LD_STRING Frank
4022: PPUSH
4023: CALL_OW 34
4027: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Frank ;
4028: LD_ADDR_EXP 57
4032: PUSH
4033: LD_EXP 57
4037: PUSH
4038: LD_EXP 42
4042: ADD
4043: ST_TO_ADDR
// end ; if TestCharacters ( Gary ) and CheckCharacterSet ( Gary ) then
4044: LD_STRING Gary
4046: PPUSH
4047: CALL_OW 28
4051: PUSH
4052: LD_STRING Gary
4054: PPUSH
4055: CALL_OW 29
4059: AND
4060: IFFALSE 4091
// begin Gary := CreateCharacter ( Gary ) ;
4062: LD_ADDR_EXP 43
4066: PUSH
4067: LD_STRING Gary
4069: PPUSH
4070: CALL_OW 34
4074: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gary ;
4075: LD_ADDR_EXP 57
4079: PUSH
4080: LD_EXP 57
4084: PUSH
4085: LD_EXP 43
4089: ADD
4090: ST_TO_ADDR
// end ; if TestCharacters ( Gladstone ) and CheckCharacterSet ( Gladstone ) then
4091: LD_STRING Gladstone
4093: PPUSH
4094: CALL_OW 28
4098: PUSH
4099: LD_STRING Gladstone
4101: PPUSH
4102: CALL_OW 29
4106: AND
4107: IFFALSE 4138
// begin Gladstone := CreateCharacter ( Gladstone ) ;
4109: LD_ADDR_EXP 44
4113: PUSH
4114: LD_STRING Gladstone
4116: PPUSH
4117: CALL_OW 34
4121: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladstone ;
4122: LD_ADDR_EXP 57
4126: PUSH
4127: LD_EXP 57
4131: PUSH
4132: LD_EXP 44
4136: ADD
4137: ST_TO_ADDR
// end ; if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) and camp = 4 then
4138: LD_STRING Joan
4140: PPUSH
4141: CALL_OW 28
4145: PUSH
4146: LD_STRING Joan
4148: PPUSH
4149: CALL_OW 29
4153: AND
4154: PUSH
4155: LD_EXP 7
4159: PUSH
4160: LD_INT 4
4162: EQUAL
4163: AND
4164: IFFALSE 4195
// begin Joan := CreateCharacter ( Joan ) ;
4166: LD_ADDR_EXP 45
4170: PUSH
4171: LD_STRING Joan
4173: PPUSH
4174: CALL_OW 34
4178: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Joan ;
4179: LD_ADDR_EXP 57
4183: PUSH
4184: LD_EXP 57
4188: PUSH
4189: LD_EXP 45
4193: ADD
4194: ST_TO_ADDR
// end ; if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
4195: LD_STRING Lisa
4197: PPUSH
4198: CALL_OW 28
4202: PUSH
4203: LD_STRING Lisa
4205: PPUSH
4206: CALL_OW 29
4210: AND
4211: IFFALSE 4242
// begin Lisa := CreateCharacter ( Lisa ) ;
4213: LD_ADDR_EXP 46
4217: PUSH
4218: LD_STRING Lisa
4220: PPUSH
4221: CALL_OW 34
4225: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lisa ;
4226: LD_ADDR_EXP 57
4230: PUSH
4231: LD_EXP 57
4235: PUSH
4236: LD_EXP 46
4240: ADD
4241: ST_TO_ADDR
// end ; if TestCharacters ( Peterson ) and CheckCharacterSet ( Peterson ) then
4242: LD_STRING Peterson
4244: PPUSH
4245: CALL_OW 28
4249: PUSH
4250: LD_STRING Peterson
4252: PPUSH
4253: CALL_OW 29
4257: AND
4258: IFFALSE 4289
// begin Peterson := CreateCharacter ( Peterson ) ;
4260: LD_ADDR_EXP 47
4264: PUSH
4265: LD_STRING Peterson
4267: PPUSH
4268: CALL_OW 34
4272: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Peterson ;
4273: LD_ADDR_EXP 57
4277: PUSH
4278: LD_EXP 57
4282: PUSH
4283: LD_EXP 47
4287: ADD
4288: ST_TO_ADDR
// end ; if TestCharacters ( Simms ) and CheckCharacterSet ( Simms ) then
4289: LD_STRING Simms
4291: PPUSH
4292: CALL_OW 28
4296: PUSH
4297: LD_STRING Simms
4299: PPUSH
4300: CALL_OW 29
4304: AND
4305: IFFALSE 4336
// begin Simms := CreateCharacter ( Simms ) ;
4307: LD_ADDR_EXP 48
4311: PUSH
4312: LD_STRING Simms
4314: PPUSH
4315: CALL_OW 34
4319: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Simms ;
4320: LD_ADDR_EXP 57
4324: PUSH
4325: LD_EXP 57
4329: PUSH
4330: LD_EXP 48
4334: ADD
4335: ST_TO_ADDR
// end ; if TestCharacters ( VanHouten ) and CheckCharacterSet ( VanHouten ) then
4336: LD_STRING VanHouten
4338: PPUSH
4339: CALL_OW 28
4343: PUSH
4344: LD_STRING VanHouten
4346: PPUSH
4347: CALL_OW 29
4351: AND
4352: IFFALSE 4383
// begin VanHouten := CreateCharacter ( VanHouten ) ;
4354: LD_ADDR_EXP 49
4358: PUSH
4359: LD_STRING VanHouten
4361: PPUSH
4362: CALL_OW 34
4366: ST_TO_ADDR
// aliance_forces := aliance_forces ^ VanHouten ;
4367: LD_ADDR_EXP 57
4371: PUSH
4372: LD_EXP 57
4376: PUSH
4377: LD_EXP 49
4381: ADD
4382: ST_TO_ADDR
// end ; if TestCharacters ( Yamoko ) and CheckCharacterSet ( Yamoko ) then
4383: LD_STRING Yamoko
4385: PPUSH
4386: CALL_OW 28
4390: PUSH
4391: LD_STRING Yamoko
4393: PPUSH
4394: CALL_OW 29
4398: AND
4399: IFFALSE 4430
// begin Yamoko := CreateCharacter ( Yamoko ) ;
4401: LD_ADDR_EXP 50
4405: PUSH
4406: LD_STRING Yamoko
4408: PPUSH
4409: CALL_OW 34
4413: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Yamoko ;
4414: LD_ADDR_EXP 57
4418: PUSH
4419: LD_EXP 57
4423: PUSH
4424: LD_EXP 50
4428: ADD
4429: ST_TO_ADDR
// end ; DisableAllBazookers ;
4430: CALL 4562 0 0
// if camp = 4 then
4434: LD_EXP 7
4438: PUSH
4439: LD_INT 4
4441: EQUAL
4442: IFFALSE 4448
// sort_aliance_by_the_nation ;
4444: CALL 4453 0 0
// end ;
4448: LD_VAR 0 1
4452: RET
// function sort_aliance_by_the_nation ; var un , us_list , ru_list ; begin
4453: LD_INT 0
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
// us_list := [ ] ;
4459: LD_ADDR_VAR 0 3
4463: PUSH
4464: EMPTY
4465: ST_TO_ADDR
// ru_list := [ ] ;
4466: LD_ADDR_VAR 0 4
4470: PUSH
4471: EMPTY
4472: ST_TO_ADDR
// for un in aliance_forces do
4473: LD_ADDR_VAR 0 2
4477: PUSH
4478: LD_EXP 57
4482: PUSH
4483: FOR_IN
4484: IFFALSE 4539
// if GetNation ( un ) = us then
4486: LD_VAR 0 2
4490: PPUSH
4491: CALL_OW 248
4495: PUSH
4496: LD_EXP 3
4500: EQUAL
4501: IFFALSE 4521
// us_list := us_list ^ un else
4503: LD_ADDR_VAR 0 3
4507: PUSH
4508: LD_VAR 0 3
4512: PUSH
4513: LD_VAR 0 2
4517: ADD
4518: ST_TO_ADDR
4519: GO 4537
// ru_list := ru_list ^ un ;
4521: LD_ADDR_VAR 0 4
4525: PUSH
4526: LD_VAR 0 4
4530: PUSH
4531: LD_VAR 0 2
4535: ADD
4536: ST_TO_ADDR
4537: GO 4483
4539: POP
4540: POP
// aliance_forces := us_list ^ ru_list ;
4541: LD_ADDR_EXP 57
4545: PUSH
4546: LD_VAR 0 3
4550: PUSH
4551: LD_VAR 0 4
4555: ADD
4556: ST_TO_ADDR
// end ;
4557: LD_VAR 0 1
4561: RET
// function DisableAllBazookers ; var list , un ; begin
4562: LD_INT 0
4564: PPUSH
4565: PPUSH
4566: PPUSH
// list := [ ] ;
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: EMPTY
4573: ST_TO_ADDR
// for un in aliance_forces do
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: LD_EXP 57
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4632
// begin if GetClass ( un ) = class_bazooker then
4587: LD_VAR 0 3
4591: PPUSH
4592: CALL_OW 257
4596: PUSH
4597: LD_INT 9
4599: EQUAL
4600: IFFALSE 4614
// SetClass ( un , class_soldier ) ;
4602: LD_VAR 0 3
4606: PPUSH
4607: LD_INT 1
4609: PPUSH
4610: CALL_OW 336
// list := list ^ un ;
4614: LD_ADDR_VAR 0 2
4618: PUSH
4619: LD_VAR 0 2
4623: PUSH
4624: LD_VAR 0 3
4628: ADD
4629: ST_TO_ADDR
// end ;
4630: GO 4584
4632: POP
4633: POP
// aliance_forces := list ;
4634: LD_ADDR_EXP 57
4638: PUSH
4639: LD_VAR 0 2
4643: ST_TO_ADDR
// end ; end_of_file
4644: LD_VAR 0 1
4648: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_russians ; var un , class_list , members ; begin
4649: LD_INT 0
4651: PPUSH
4652: PPUSH
4653: PPUSH
4654: PPUSH
// cpu_side := ru ;
4655: LD_ADDR_LOC 1
4659: PUSH
4660: LD_EXP 2
4664: ST_TO_ADDR
// cpu_nation := nation_russian ;
4665: LD_ADDR_LOC 2
4669: PUSH
4670: LD_INT 3
4672: ST_TO_ADDR
// cpu_base := ru_create ;
4673: LD_ADDR_LOC 3
4677: PUSH
4678: LD_INT 17
4680: ST_TO_ADDR
// members := difficulty * 2 ;
4681: LD_ADDR_VAR 0 4
4685: PUSH
4686: LD_OWVAR 67
4690: PUSH
4691: LD_INT 2
4693: MUL
4694: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: LD_INT 3
4705: PUSH
4706: LD_INT 4
4708: PUSH
4709: LD_INT 2
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: LIST
4717: ST_TO_ADDR
// for un in class_list do
4718: LD_ADDR_VAR 0 2
4722: PUSH
4723: LD_VAR 0 3
4727: PUSH
4728: FOR_IN
4729: IFFALSE 4762
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
4731: LD_LOC 1
4735: PPUSH
4736: LD_LOC 2
4740: PPUSH
4741: LD_VAR 0 2
4745: PPUSH
4746: LD_VAR 0 4
4750: PPUSH
4751: LD_LOC 3
4755: PPUSH
4756: CALL 6800 0 5
4760: GO 4728
4762: POP
4763: POP
// place_all_soldiers ;
4764: CALL 4781 0 0
// place_all_scientistics ;
4768: CALL 4989 0 0
// place_all_mechanics ;
4772: CALL 5178 0 0
// end ;
4776: LD_VAR 0 1
4780: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
4781: LD_INT 0
4783: PPUSH
4784: PPUSH
4785: PPUSH
4786: PPUSH
4787: PPUSH
4788: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
4789: LD_ADDR_VAR 0 6
4793: PUSH
4794: LD_INT 22
4796: PUSH
4797: LD_LOC 1
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PUSH
4806: LD_INT 30
4808: PUSH
4809: LD_INT 32
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_INT 22
4832: PUSH
4833: LD_LOC 1
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 25
4844: PUSH
4845: LD_INT 1
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// if buildings >= units then
4861: LD_VAR 0 6
4865: PUSH
4866: LD_VAR 0 5
4870: GREATEREQUAL
4871: IFFALSE 4889
// max := 0 + units else
4873: LD_ADDR_VAR 0 4
4877: PUSH
4878: LD_INT 0
4880: PUSH
4881: LD_VAR 0 5
4885: PLUS
4886: ST_TO_ADDR
4887: GO 4903
// max := 0 + buildings ;
4889: LD_ADDR_VAR 0 4
4893: PUSH
4894: LD_INT 0
4896: PUSH
4897: LD_VAR 0 6
4901: PLUS
4902: ST_TO_ADDR
// i = 1 ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 1
4910: ST_TO_ADDR
// for un in units do
4911: LD_ADDR_VAR 0 2
4915: PUSH
4916: LD_VAR 0 5
4920: PUSH
4921: FOR_IN
4922: IFFALSE 4982
// begin if i <= max then
4924: LD_VAR 0 3
4928: PUSH
4929: LD_VAR 0 4
4933: LESSEQUAL
4934: IFFALSE 4966
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_VAR 0 6
4945: PUSH
4946: LD_VAR 0 3
4950: PUSH
4951: LD_VAR 0 6
4955: MOD
4956: PUSH
4957: LD_INT 1
4959: PLUS
4960: ARRAY
4961: PPUSH
4962: CALL_OW 120
// i := i + 1 ;
4966: LD_ADDR_VAR 0 3
4970: PUSH
4971: LD_VAR 0 3
4975: PUSH
4976: LD_INT 1
4978: PLUS
4979: ST_TO_ADDR
// end ;
4980: GO 4921
4982: POP
4983: POP
// end ;
4984: LD_VAR 0 1
4988: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
4989: LD_INT 0
4991: PPUSH
4992: PPUSH
4993: PPUSH
4994: PPUSH
4995: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
4996: LD_ADDR_VAR 0 5
5000: PUSH
5001: LD_INT 22
5003: PUSH
5004: LD_LOC 1
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 30
5018: PUSH
5019: LD_INT 8
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 30
5028: PUSH
5029: LD_INT 6
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: LIST
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PPUSH
5045: CALL_OW 69
5049: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5050: LD_ADDR_VAR 0 4
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_LOC 1
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PUSH
5067: LD_INT 25
5069: PUSH
5070: LD_INT 4
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PPUSH
5081: CALL_OW 69
5085: ST_TO_ADDR
// i = 1 ;
5086: LD_ADDR_VAR 0 3
5090: PUSH
5091: LD_INT 1
5093: ST_TO_ADDR
// for un in units do
5094: LD_ADDR_VAR 0 2
5098: PUSH
5099: LD_VAR 0 4
5103: PUSH
5104: FOR_IN
5105: IFFALSE 5171
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5107: LD_VAR 0 2
5111: PPUSH
5112: LD_VAR 0 5
5116: PUSH
5117: LD_VAR 0 3
5121: PUSH
5122: LD_VAR 0 5
5126: MOD
5127: PUSH
5128: LD_INT 1
5130: PLUS
5131: ARRAY
5132: PPUSH
5133: CALL_OW 120
// i := i + 1 ;
5137: LD_ADDR_VAR 0 3
5141: PUSH
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ST_TO_ADDR
// if i > ( units div 2 ) then
5151: LD_VAR 0 3
5155: PUSH
5156: LD_VAR 0 4
5160: PUSH
5161: LD_INT 2
5163: DIV
5164: GREATER
5165: IFFALSE 5169
// break ;
5167: GO 5171
// end ;
5169: GO 5104
5171: POP
5172: POP
// end ;
5173: LD_VAR 0 1
5177: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5178: LD_INT 0
5180: PPUSH
5181: PPUSH
5182: PPUSH
5183: PPUSH
5184: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5185: LD_ADDR_VAR 0 5
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_LOC 1
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: PUSH
5202: LD_INT 2
5204: PUSH
5205: LD_INT 30
5207: PUSH
5208: LD_INT 2
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 3
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: PPUSH
5234: CALL_OW 69
5238: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5239: LD_ADDR_VAR 0 4
5243: PUSH
5244: LD_INT 22
5246: PUSH
5247: LD_LOC 1
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: PUSH
5256: LD_INT 25
5258: PUSH
5259: LD_INT 3
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PPUSH
5270: CALL_OW 69
5274: ST_TO_ADDR
// i = 1 ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// for un in units do
5283: LD_ADDR_VAR 0 2
5287: PUSH
5288: LD_VAR 0 4
5292: PUSH
5293: FOR_IN
5294: IFFALSE 5342
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5296: LD_VAR 0 2
5300: PPUSH
5301: LD_VAR 0 5
5305: PUSH
5306: LD_VAR 0 3
5310: PUSH
5311: LD_VAR 0 5
5315: MOD
5316: PUSH
5317: LD_INT 1
5319: PLUS
5320: ARRAY
5321: PPUSH
5322: CALL_OW 120
// i := i + 1 ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_VAR 0 3
5335: PUSH
5336: LD_INT 1
5338: PLUS
5339: ST_TO_ADDR
// end ;
5340: GO 5293
5342: POP
5343: POP
// end ; end_of_file
5344: LD_VAR 0 1
5348: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_americans ; var un , class_list , members ; begin
5349: LD_INT 0
5351: PPUSH
5352: PPUSH
5353: PPUSH
5354: PPUSH
// cpu_side := us ;
5355: LD_ADDR_LOC 4
5359: PUSH
5360: LD_EXP 3
5364: ST_TO_ADDR
// cpu_nation := nation_american ;
5365: LD_ADDR_LOC 5
5369: PUSH
5370: LD_INT 1
5372: ST_TO_ADDR
// cpu_base := us_create ;
5373: LD_ADDR_LOC 6
5377: PUSH
5378: LD_INT 18
5380: ST_TO_ADDR
// members := difficulty * 2 ;
5381: LD_ADDR_VAR 0 4
5385: PUSH
5386: LD_OWVAR 67
5390: PUSH
5391: LD_INT 2
5393: MUL
5394: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
5395: LD_ADDR_VAR 0 3
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 3
5405: PUSH
5406: LD_INT 4
5408: PUSH
5409: LD_INT 2
5411: PUSH
5412: EMPTY
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: ST_TO_ADDR
// for un in class_list do
5418: LD_ADDR_VAR 0 2
5422: PUSH
5423: LD_VAR 0 3
5427: PUSH
5428: FOR_IN
5429: IFFALSE 5462
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5431: LD_LOC 4
5435: PPUSH
5436: LD_LOC 5
5440: PPUSH
5441: LD_VAR 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: LD_LOC 6
5455: PPUSH
5456: CALL 6800 0 5
5460: GO 5428
5462: POP
5463: POP
// create_units ( cpu_side , cpu_nation , class_mechanic , 2 , cpu_base ) ;
5464: LD_LOC 4
5468: PPUSH
5469: LD_LOC 5
5473: PPUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 2
5479: PPUSH
5480: LD_LOC 6
5484: PPUSH
5485: CALL 6800 0 5
// SetResourceVisibility ( 43 , 81 , 1 ) ;
5489: LD_INT 43
5491: PPUSH
5492: LD_INT 81
5494: PPUSH
5495: LD_INT 1
5497: PPUSH
5498: CALL_OW 441
// SetResourceVisibility ( 30 , 49 , 1 ) ;
5502: LD_INT 30
5504: PPUSH
5505: LD_INT 49
5507: PPUSH
5508: LD_INT 1
5510: PPUSH
5511: CALL_OW 441
// place_all_soldiers ;
5515: CALL 5532 0 0
// place_all_scientistics ;
5519: CALL 5740 0 0
// place_all_mechanics ;
5523: CALL 5929 0 0
// end ;
5527: LD_VAR 0 1
5531: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5532: LD_INT 0
5534: PPUSH
5535: PPUSH
5536: PPUSH
5537: PPUSH
5538: PPUSH
5539: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_INT 22
5547: PUSH
5548: LD_LOC 4
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 30
5559: PUSH
5560: LD_INT 32
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PPUSH
5571: CALL_OW 69
5575: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5576: LD_ADDR_VAR 0 5
5580: PUSH
5581: LD_INT 22
5583: PUSH
5584: LD_LOC 4
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 25
5595: PUSH
5596: LD_INT 1
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// if buildings >= units then
5612: LD_VAR 0 6
5616: PUSH
5617: LD_VAR 0 5
5621: GREATEREQUAL
5622: IFFALSE 5640
// max := 0 + units else
5624: LD_ADDR_VAR 0 4
5628: PUSH
5629: LD_INT 0
5631: PUSH
5632: LD_VAR 0 5
5636: PLUS
5637: ST_TO_ADDR
5638: GO 5654
// max := 0 + buildings ;
5640: LD_ADDR_VAR 0 4
5644: PUSH
5645: LD_INT 0
5647: PUSH
5648: LD_VAR 0 6
5652: PLUS
5653: ST_TO_ADDR
// i = 1 ;
5654: LD_ADDR_VAR 0 3
5658: PUSH
5659: LD_INT 1
5661: ST_TO_ADDR
// for un in units do
5662: LD_ADDR_VAR 0 2
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: FOR_IN
5673: IFFALSE 5733
// begin if i <= max then
5675: LD_VAR 0 3
5679: PUSH
5680: LD_VAR 0 4
5684: LESSEQUAL
5685: IFFALSE 5717
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5687: LD_VAR 0 2
5691: PPUSH
5692: LD_VAR 0 6
5696: PUSH
5697: LD_VAR 0 3
5701: PUSH
5702: LD_VAR 0 6
5706: MOD
5707: PUSH
5708: LD_INT 1
5710: PLUS
5711: ARRAY
5712: PPUSH
5713: CALL_OW 120
// i := i + 1 ;
5717: LD_ADDR_VAR 0 3
5721: PUSH
5722: LD_VAR 0 3
5726: PUSH
5727: LD_INT 1
5729: PLUS
5730: ST_TO_ADDR
// end ;
5731: GO 5672
5733: POP
5734: POP
// end ;
5735: LD_VAR 0 1
5739: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5740: LD_INT 0
5742: PPUSH
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5747: LD_ADDR_VAR 0 5
5751: PUSH
5752: LD_INT 22
5754: PUSH
5755: LD_LOC 4
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: LD_INT 2
5766: PUSH
5767: LD_INT 30
5769: PUSH
5770: LD_INT 8
5772: PUSH
5773: EMPTY
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 30
5779: PUSH
5780: LD_INT 6
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PPUSH
5796: CALL_OW 69
5800: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5801: LD_ADDR_VAR 0 4
5805: PUSH
5806: LD_INT 22
5808: PUSH
5809: LD_LOC 4
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 25
5820: PUSH
5821: LD_INT 4
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL_OW 69
5836: ST_TO_ADDR
// i = 1 ;
5837: LD_ADDR_VAR 0 3
5841: PUSH
5842: LD_INT 1
5844: ST_TO_ADDR
// for un in units do
5845: LD_ADDR_VAR 0 2
5849: PUSH
5850: LD_VAR 0 4
5854: PUSH
5855: FOR_IN
5856: IFFALSE 5922
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5858: LD_VAR 0 2
5862: PPUSH
5863: LD_VAR 0 5
5867: PUSH
5868: LD_VAR 0 3
5872: PUSH
5873: LD_VAR 0 5
5877: MOD
5878: PUSH
5879: LD_INT 1
5881: PLUS
5882: ARRAY
5883: PPUSH
5884: CALL_OW 120
// i := i + 1 ;
5888: LD_ADDR_VAR 0 3
5892: PUSH
5893: LD_VAR 0 3
5897: PUSH
5898: LD_INT 1
5900: PLUS
5901: ST_TO_ADDR
// if i > ( units div 2 ) then
5902: LD_VAR 0 3
5906: PUSH
5907: LD_VAR 0 4
5911: PUSH
5912: LD_INT 2
5914: DIV
5915: GREATER
5916: IFFALSE 5920
// break ;
5918: GO 5922
// end ;
5920: GO 5855
5922: POP
5923: POP
// end ;
5924: LD_VAR 0 1
5928: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5929: LD_INT 0
5931: PPUSH
5932: PPUSH
5933: PPUSH
5934: PPUSH
5935: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5936: LD_ADDR_VAR 0 5
5940: PUSH
5941: LD_INT 22
5943: PUSH
5944: LD_LOC 4
5948: PUSH
5949: EMPTY
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 2
5955: PUSH
5956: LD_INT 30
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: LD_INT 30
5968: PUSH
5969: LD_INT 3
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PPUSH
5985: CALL_OW 69
5989: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5990: LD_ADDR_VAR 0 4
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_LOC 4
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: LD_INT 25
6009: PUSH
6010: LD_INT 3
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: PPUSH
6021: CALL_OW 69
6025: ST_TO_ADDR
// i = 1 ;
6026: LD_ADDR_VAR 0 3
6030: PUSH
6031: LD_INT 1
6033: ST_TO_ADDR
// for un in units do
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 4
6043: PUSH
6044: FOR_IN
6045: IFFALSE 6093
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6047: LD_VAR 0 2
6051: PPUSH
6052: LD_VAR 0 5
6056: PUSH
6057: LD_VAR 0 3
6061: PUSH
6062: LD_VAR 0 5
6066: MOD
6067: PUSH
6068: LD_INT 1
6070: PLUS
6071: ARRAY
6072: PPUSH
6073: CALL_OW 120
// i := i + 1 ;
6077: LD_ADDR_VAR 0 3
6081: PUSH
6082: LD_VAR 0 3
6086: PUSH
6087: LD_INT 1
6089: PLUS
6090: ST_TO_ADDR
// end ;
6091: GO 6044
6093: POP
6094: POP
// end ; end_of_file
6095: LD_VAR 0 1
6099: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_arabians ; var un , class_list , members ; begin
6100: LD_INT 0
6102: PPUSH
6103: PPUSH
6104: PPUSH
6105: PPUSH
// cpu_side := ar ;
6106: LD_ADDR_LOC 7
6110: PUSH
6111: LD_EXP 4
6115: ST_TO_ADDR
// cpu_nation := nation_arabian ;
6116: LD_ADDR_LOC 8
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// cpu_base := ar_create ;
6124: LD_ADDR_LOC 9
6128: PUSH
6129: LD_INT 19
6131: ST_TO_ADDR
// members := difficulty + 1 ;
6132: LD_ADDR_VAR 0 4
6136: PUSH
6137: LD_OWVAR 67
6141: PUSH
6142: LD_INT 1
6144: PLUS
6145: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
6146: LD_ADDR_VAR 0 3
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 3
6156: PUSH
6157: LD_INT 4
6159: PUSH
6160: LD_INT 2
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: ST_TO_ADDR
// for un in class_list do
6169: LD_ADDR_VAR 0 2
6173: PUSH
6174: LD_VAR 0 3
6178: PUSH
6179: FOR_IN
6180: IFFALSE 6213
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
6182: LD_LOC 7
6186: PPUSH
6187: LD_LOC 8
6191: PPUSH
6192: LD_VAR 0 2
6196: PPUSH
6197: LD_VAR 0 4
6201: PPUSH
6202: LD_LOC 9
6206: PPUSH
6207: CALL 6800 0 5
6211: GO 6179
6213: POP
6214: POP
// place_all_soldiers ;
6215: CALL 6232 0 0
// place_all_scientistics ;
6219: CALL 6440 0 0
// place_all_mechanics ;
6223: CALL 6629 0 0
// end ;
6227: LD_VAR 0 1
6231: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
6232: LD_INT 0
6234: PPUSH
6235: PPUSH
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
6240: LD_ADDR_VAR 0 6
6244: PUSH
6245: LD_INT 22
6247: PUSH
6248: LD_LOC 7
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: PUSH
6257: LD_INT 30
6259: PUSH
6260: LD_INT 32
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PPUSH
6271: CALL_OW 69
6275: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
6276: LD_ADDR_VAR 0 5
6280: PUSH
6281: LD_INT 22
6283: PUSH
6284: LD_LOC 7
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PUSH
6293: LD_INT 25
6295: PUSH
6296: LD_INT 1
6298: PUSH
6299: EMPTY
6300: LIST
6301: LIST
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PPUSH
6307: CALL_OW 69
6311: ST_TO_ADDR
// if buildings >= units then
6312: LD_VAR 0 6
6316: PUSH
6317: LD_VAR 0 5
6321: GREATEREQUAL
6322: IFFALSE 6340
// max := 0 + units else
6324: LD_ADDR_VAR 0 4
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_VAR 0 5
6336: PLUS
6337: ST_TO_ADDR
6338: GO 6354
// max := 0 + buildings ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_VAR 0 6
6352: PLUS
6353: ST_TO_ADDR
// i = 1 ;
6354: LD_ADDR_VAR 0 3
6358: PUSH
6359: LD_INT 1
6361: ST_TO_ADDR
// for un in units do
6362: LD_ADDR_VAR 0 2
6366: PUSH
6367: LD_VAR 0 5
6371: PUSH
6372: FOR_IN
6373: IFFALSE 6433
// begin if i <= max then
6375: LD_VAR 0 3
6379: PUSH
6380: LD_VAR 0 4
6384: LESSEQUAL
6385: IFFALSE 6417
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6387: LD_VAR 0 2
6391: PPUSH
6392: LD_VAR 0 6
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_VAR 0 6
6406: MOD
6407: PUSH
6408: LD_INT 1
6410: PLUS
6411: ARRAY
6412: PPUSH
6413: CALL_OW 120
// i := i + 1 ;
6417: LD_ADDR_VAR 0 3
6421: PUSH
6422: LD_VAR 0 3
6426: PUSH
6427: LD_INT 1
6429: PLUS
6430: ST_TO_ADDR
// end ;
6431: GO 6372
6433: POP
6434: POP
// end ;
6435: LD_VAR 0 1
6439: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6440: LD_INT 0
6442: PPUSH
6443: PPUSH
6444: PPUSH
6445: PPUSH
6446: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6447: LD_ADDR_VAR 0 5
6451: PUSH
6452: LD_INT 22
6454: PUSH
6455: LD_LOC 7
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 2
6466: PUSH
6467: LD_INT 30
6469: PUSH
6470: LD_INT 8
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 30
6479: PUSH
6480: LD_INT 6
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: PPUSH
6496: CALL_OW 69
6500: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6501: LD_ADDR_VAR 0 4
6505: PUSH
6506: LD_INT 22
6508: PUSH
6509: LD_LOC 7
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 25
6520: PUSH
6521: LD_INT 4
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PPUSH
6532: CALL_OW 69
6536: ST_TO_ADDR
// i = 1 ;
6537: LD_ADDR_VAR 0 3
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// for un in units do
6545: LD_ADDR_VAR 0 2
6549: PUSH
6550: LD_VAR 0 4
6554: PUSH
6555: FOR_IN
6556: IFFALSE 6622
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6558: LD_VAR 0 2
6562: PPUSH
6563: LD_VAR 0 5
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 5
6577: MOD
6578: PUSH
6579: LD_INT 1
6581: PLUS
6582: ARRAY
6583: PPUSH
6584: CALL_OW 120
// i := i + 1 ;
6588: LD_ADDR_VAR 0 3
6592: PUSH
6593: LD_VAR 0 3
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: ST_TO_ADDR
// if i > ( units div 2 ) then
6602: LD_VAR 0 3
6606: PUSH
6607: LD_VAR 0 4
6611: PUSH
6612: LD_INT 2
6614: DIV
6615: GREATER
6616: IFFALSE 6620
// break ;
6618: GO 6622
// end ;
6620: GO 6555
6622: POP
6623: POP
// end ;
6624: LD_VAR 0 1
6628: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6629: LD_INT 0
6631: PPUSH
6632: PPUSH
6633: PPUSH
6634: PPUSH
6635: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6636: LD_ADDR_VAR 0 5
6640: PUSH
6641: LD_INT 22
6643: PUSH
6644: LD_LOC 7
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 2
6655: PUSH
6656: LD_INT 30
6658: PUSH
6659: LD_INT 2
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: LD_INT 30
6668: PUSH
6669: LD_INT 3
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL_OW 69
6689: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6690: LD_ADDR_VAR 0 4
6694: PUSH
6695: LD_INT 22
6697: PUSH
6698: LD_LOC 7
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: LD_INT 25
6709: PUSH
6710: LD_INT 3
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PPUSH
6721: CALL_OW 69
6725: ST_TO_ADDR
// i = 1 ;
6726: LD_ADDR_VAR 0 3
6730: PUSH
6731: LD_INT 1
6733: ST_TO_ADDR
// for un in units do
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 4
6743: PUSH
6744: FOR_IN
6745: IFFALSE 6793
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6747: LD_VAR 0 2
6751: PPUSH
6752: LD_VAR 0 5
6756: PUSH
6757: LD_VAR 0 3
6761: PUSH
6762: LD_VAR 0 5
6766: MOD
6767: PUSH
6768: LD_INT 1
6770: PLUS
6771: ARRAY
6772: PPUSH
6773: CALL_OW 120
// i := i + 1 ;
6777: LD_ADDR_VAR 0 3
6781: PUSH
6782: LD_VAR 0 3
6786: PUSH
6787: LD_INT 1
6789: PLUS
6790: ST_TO_ADDR
// end ;
6791: GO 6744
6793: POP
6794: POP
// end ; end_of_file
6795: LD_VAR 0 1
6799: RET
// export function create_units ( side , nation , class_n , num , area ) ; var i , un , lev ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
6805: PPUSH
// if class_n = class_scientistic then
6806: LD_VAR 0 3
6810: PUSH
6811: LD_INT 4
6813: EQUAL
6814: IFFALSE 6868
// begin lev := [ 3 , 6 , 10 ] [ difficulty ] ;
6816: LD_ADDR_VAR 0 9
6820: PUSH
6821: LD_INT 3
6823: PUSH
6824: LD_INT 6
6826: PUSH
6827: LD_INT 10
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: PUSH
6835: LD_OWVAR 67
6839: ARRAY
6840: ST_TO_ADDR
// num := [ 2 , 4 , 6 ] [ difficulty ] ;
6841: LD_ADDR_VAR 0 4
6845: PUSH
6846: LD_INT 2
6848: PUSH
6849: LD_INT 4
6851: PUSH
6852: LD_INT 6
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: PUSH
6860: LD_OWVAR 67
6864: ARRAY
6865: ST_TO_ADDR
// end else
6866: GO 6938
// if class_n = class_soldier then
6868: LD_VAR 0 3
6872: PUSH
6873: LD_INT 1
6875: EQUAL
6876: IFFALSE 6913
// begin lev := [ 5 , 7 , 10 ] [ difficulty ] ;
6878: LD_ADDR_VAR 0 9
6882: PUSH
6883: LD_INT 5
6885: PUSH
6886: LD_INT 7
6888: PUSH
6889: LD_INT 10
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: PUSH
6897: LD_OWVAR 67
6901: ARRAY
6902: ST_TO_ADDR
// num := 6 ;
6903: LD_ADDR_VAR 0 4
6907: PUSH
6908: LD_INT 6
6910: ST_TO_ADDR
// end else
6911: GO 6938
// lev := [ 4 , 6 , 10 ] [ difficulty ] ;
6913: LD_ADDR_VAR 0 9
6917: PUSH
6918: LD_INT 4
6920: PUSH
6921: LD_INT 6
6923: PUSH
6924: LD_INT 10
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: PUSH
6932: LD_OWVAR 67
6936: ARRAY
6937: ST_TO_ADDR
// uc_side := side ;
6938: LD_ADDR_OWVAR 20
6942: PUSH
6943: LD_VAR 0 1
6947: ST_TO_ADDR
// uc_nation := nation ;
6948: LD_ADDR_OWVAR 21
6952: PUSH
6953: LD_VAR 0 2
6957: ST_TO_ADDR
// for i = 1 to num do
6958: LD_ADDR_VAR 0 7
6962: PUSH
6963: DOUBLE
6964: LD_INT 1
6966: DEC
6967: ST_TO_ADDR
6968: LD_VAR 0 4
6972: PUSH
6973: FOR_TO
6974: IFFALSE 7119
// begin uc_direction := Rand ( 0 , 5 ) ;
6976: LD_ADDR_OWVAR 24
6980: PUSH
6981: LD_INT 0
6983: PPUSH
6984: LD_INT 5
6986: PPUSH
6987: CALL_OW 12
6991: ST_TO_ADDR
// case class_n of 1 :
6992: LD_VAR 0 3
6996: PUSH
6997: LD_INT 1
6999: DOUBLE
7000: EQUAL
7001: IFTRUE 7005
7003: GO 7020
7005: POP
// PrepareSoldier ( 0 , lev ) ; 2 :
7006: LD_INT 0
7008: PPUSH
7009: LD_VAR 0 9
7013: PPUSH
7014: CALL_OW 381
7018: GO 7090
7020: LD_INT 2
7022: DOUBLE
7023: EQUAL
7024: IFTRUE 7028
7026: GO 7043
7028: POP
// PrepareEngineer ( 0 , lev ) ; 3 :
7029: LD_INT 0
7031: PPUSH
7032: LD_VAR 0 9
7036: PPUSH
7037: CALL_OW 382
7041: GO 7090
7043: LD_INT 3
7045: DOUBLE
7046: EQUAL
7047: IFTRUE 7051
7049: GO 7066
7051: POP
// PrepareMechanic ( 0 , lev ) ; 4 :
7052: LD_INT 0
7054: PPUSH
7055: LD_VAR 0 9
7059: PPUSH
7060: CALL_OW 383
7064: GO 7090
7066: LD_INT 4
7068: DOUBLE
7069: EQUAL
7070: IFTRUE 7074
7072: GO 7089
7074: POP
// PrepareScientist ( 0 , lev ) ; end ;
7075: LD_INT 0
7077: PPUSH
7078: LD_VAR 0 9
7082: PPUSH
7083: CALL_OW 384
7087: GO 7090
7089: POP
// un := CreateHuman ;
7090: LD_ADDR_VAR 0 8
7094: PUSH
7095: CALL_OW 44
7099: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7100: LD_VAR 0 8
7104: PPUSH
7105: LD_VAR 0 5
7109: PPUSH
7110: LD_INT 0
7112: PPUSH
7113: CALL_OW 49
// end ;
7117: GO 6973
7119: POP
7120: POP
// end ;
7121: LD_VAR 0 6
7125: RET
// export function prepare_apemans ; var ape , i ; begin
7126: LD_INT 0
7128: PPUSH
7129: PPUSH
7130: PPUSH
// for i = 1 to ( 6 - difficulty ) do
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: DOUBLE
7137: LD_INT 1
7139: DEC
7140: ST_TO_ADDR
7141: LD_INT 6
7143: PUSH
7144: LD_OWVAR 67
7148: MINUS
7149: PUSH
7150: FOR_TO
7151: IFFALSE 7351
// begin uc_side := neutral ;
7153: LD_ADDR_OWVAR 20
7157: PUSH
7158: LD_EXP 6
7162: ST_TO_ADDR
// uc_nation := nation_nature ;
7163: LD_ADDR_OWVAR 21
7167: PUSH
7168: LD_INT 0
7170: ST_TO_ADDR
// hc_class := class_apeman ;
7171: LD_ADDR_OWVAR 28
7175: PUSH
7176: LD_INT 12
7178: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) ] ;
7179: LD_ADDR_OWVAR 30
7183: PUSH
7184: LD_INT 1
7186: PPUSH
7187: LD_INT 2
7189: PPUSH
7190: CALL_OW 12
7194: PUSH
7195: LD_INT 1
7197: PPUSH
7198: LD_INT 2
7200: PPUSH
7201: CALL_OW 12
7205: PUSH
7206: LD_INT 1
7208: PPUSH
7209: LD_INT 2
7211: PPUSH
7212: CALL_OW 12
7216: PUSH
7217: LD_INT 1
7219: PPUSH
7220: LD_INT 2
7222: PPUSH
7223: CALL_OW 12
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: LIST
7232: LIST
7233: ST_TO_ADDR
// hc_skills := [ 3 , 3 , 3 , 3 ] ;
7234: LD_ADDR_OWVAR 31
7238: PUSH
7239: LD_INT 3
7241: PUSH
7242: LD_INT 3
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: LIST
7255: LIST
7256: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
7257: LD_ADDR_OWVAR 29
7261: PUSH
7262: LD_INT 10
7264: PUSH
7265: LD_INT 12
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: ST_TO_ADDR
// hc_sex := [ sex_female , sex_male ] [ Rand ( 1 , 2 ) ] ;
7272: LD_ADDR_OWVAR 27
7276: PUSH
7277: LD_INT 2
7279: PUSH
7280: LD_INT 1
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: PUSH
7287: LD_INT 1
7289: PPUSH
7290: LD_INT 2
7292: PPUSH
7293: CALL_OW 12
7297: ARRAY
7298: ST_TO_ADDR
// hc_importance := 0 ;
7299: LD_ADDR_OWVAR 32
7303: PUSH
7304: LD_INT 0
7306: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
7307: LD_ADDR_OWVAR 35
7311: PUSH
7312: LD_INT 20
7314: NEG
7315: PPUSH
7316: LD_INT 20
7318: PPUSH
7319: CALL_OW 12
7323: ST_TO_ADDR
// ape := CreateHuman ;
7324: LD_ADDR_VAR 0 2
7328: PUSH
7329: CALL_OW 44
7333: ST_TO_ADDR
// PlaceUnitArea ( ape , apeman_forest , false ) ;
7334: LD_VAR 0 2
7338: PPUSH
7339: LD_INT 32
7341: PPUSH
7342: LD_INT 0
7344: PPUSH
7345: CALL_OW 49
// end ;
7349: GO 7150
7351: POP
7352: POP
// end ; end_of_file
7353: LD_VAR 0 1
7357: RET
// var alien_tower_spoted ; export function starting_scene ; var check_time ; begin
7358: LD_INT 0
7360: PPUSH
7361: PPUSH
// CenterNowOnXY ( 75 , 27 ) ;
7362: LD_INT 75
7364: PPUSH
7365: LD_INT 27
7367: PPUSH
7368: CALL_OW 86
// wait ( 0 0$1 ) ;
7372: LD_INT 35
7374: PPUSH
7375: CALL_OW 67
// InGameOn ;
7379: CALL_OW 8
// ComMoveToArea ( IsInUnit ( Burlak ) , burlak_panorama_area ) ;
7383: LD_EXP 12
7387: PPUSH
7388: CALL_OW 310
7392: PPUSH
7393: LD_INT 8
7395: PPUSH
7396: CALL_OW 113
// ComMoveToArea ( IsInUnit ( MacMillan ) , jmm_panorama_area ) ;
7400: LD_EXP 13
7404: PPUSH
7405: CALL_OW 310
7409: PPUSH
7410: LD_INT 28
7412: PPUSH
7413: CALL_OW 113
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
7417: LD_EXP 13
7421: PUSH
7422: LD_EXP 12
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PPUSH
7431: CALL_OW 85
// repeat wait ( 20 ) ;
7435: LD_INT 20
7437: PPUSH
7438: CALL_OW 67
// until IsInArea ( Burlak , burlak_panorama_area ) and IsInArea ( MacMillan , jmm_panorama_area ) ;
7442: LD_EXP 12
7446: PPUSH
7447: LD_INT 8
7449: PPUSH
7450: CALL_OW 308
7454: PUSH
7455: LD_EXP 13
7459: PPUSH
7460: LD_INT 28
7462: PPUSH
7463: CALL_OW 308
7467: AND
7468: IFFALSE 7435
// ComExitVehicle ( [ Burlak , MacMillan ] ) ;
7470: LD_EXP 12
7474: PUSH
7475: LD_EXP 13
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PPUSH
7484: CALL_OW 121
// while IsInUnit ( Burlak ) or IsInUnit ( MacMillan ) do
7488: LD_EXP 12
7492: PPUSH
7493: CALL_OW 310
7497: PUSH
7498: LD_EXP 13
7502: PPUSH
7503: CALL_OW 310
7507: OR
7508: IFFALSE 7519
// wait ( 5 ) ;
7510: LD_INT 5
7512: PPUSH
7513: CALL_OW 67
7517: GO 7488
// wait ( 10 ) ;
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 67
// ComMoveToArea ( Burlak , burlak_talking_panorama ) ;
7526: LD_EXP 12
7530: PPUSH
7531: LD_INT 9
7533: PPUSH
7534: CALL_OW 113
// ComMoveToArea ( MacMillan , jmm_talking_panorama ) ;
7538: LD_EXP 13
7542: PPUSH
7543: LD_INT 29
7545: PPUSH
7546: CALL_OW 113
// check_time := TICK ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: LD_OWVAR 1
7559: ST_TO_ADDR
// repeat ComHold ( FilterUnitsInArea ( burlak_talking_panorama , [ [ f_side , you ] ] ) ) ;
7560: LD_INT 9
7562: PPUSH
7563: LD_INT 22
7565: PUSH
7566: LD_EXP 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: PPUSH
7578: CALL_OW 70
7582: PPUSH
7583: CALL_OW 140
// ComHold ( FilterUnitsInArea ( jmm_talking_panorama , [ [ f_side , you ] ] ) ) ;
7587: LD_INT 29
7589: PPUSH
7590: LD_INT 22
7592: PUSH
7593: LD_EXP 1
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: EMPTY
7603: LIST
7604: PPUSH
7605: CALL_OW 70
7609: PPUSH
7610: CALL_OW 140
// wait ( 0 0$1 ) ;
7614: LD_INT 35
7616: PPUSH
7617: CALL_OW 67
// until ( IsInArea ( Burlak , burlak_talking_panorama ) and IsInArea ( MacMillan , jmm_talking_panorama ) ) or ( check_time < ( TICK - 0 0$4 ) ) ;
7621: LD_EXP 12
7625: PPUSH
7626: LD_INT 9
7628: PPUSH
7629: CALL_OW 308
7633: PUSH
7634: LD_EXP 13
7638: PPUSH
7639: LD_INT 29
7641: PPUSH
7642: CALL_OW 308
7646: AND
7647: PUSH
7648: LD_VAR 0 2
7652: PUSH
7653: LD_OWVAR 1
7657: PUSH
7658: LD_INT 140
7660: MINUS
7661: LESS
7662: OR
7663: IFFALSE 7560
// ComTurnUnit ( MacMillan , Burlak ) ;
7665: LD_EXP 13
7669: PPUSH
7670: LD_EXP 12
7674: PPUSH
7675: CALL_OW 119
// ComTurnUnit ( Burlak , MacMillan ) ;
7679: LD_EXP 12
7683: PPUSH
7684: LD_EXP 13
7688: PPUSH
7689: CALL_OW 119
// CenterOnXY ( 77 , 31 ) ;
7693: LD_INT 77
7695: PPUSH
7696: LD_INT 31
7698: PPUSH
7699: CALL_OW 84
// wait ( 10 ) ;
7703: LD_INT 10
7705: PPUSH
7706: CALL_OW 67
// InGameOff ;
7710: CALL_OW 9
// DialogueOn ;
7714: CALL_OW 6
// interface_hidden := true ;
7718: LD_ADDR_OWVAR 54
7722: PUSH
7723: LD_INT 1
7725: ST_TO_ADDR
// case camp of 4 :
7726: LD_EXP 7
7730: PUSH
7731: LD_INT 4
7733: DOUBLE
7734: EQUAL
7735: IFTRUE 7739
7737: GO 7790
7739: POP
// begin Say ( MacMillan , DStart-JMM-JMM-1 ) ;
7740: LD_EXP 13
7744: PPUSH
7745: LD_STRING DStart-JMM-JMM-1
7747: PPUSH
7748: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
7752: LD_EXP 12
7756: PPUSH
7757: LD_STRING DStart-JMM-Bur-1
7759: PPUSH
7760: CALL_OW 88
// Say ( MacMillan , DStart-JMM-JMM-2 ) ;
7764: LD_EXP 13
7768: PPUSH
7769: LD_STRING DStart-JMM-JMM-2
7771: PPUSH
7772: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
7776: LD_EXP 12
7780: PPUSH
7781: LD_STRING DStart-JMM-Bur-2
7783: PPUSH
7784: CALL_OW 88
// end ; 6 :
7788: GO 7838
7790: LD_INT 6
7792: DOUBLE
7793: EQUAL
7794: IFTRUE 7798
7796: GO 7837
7798: POP
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
7799: LD_EXP 12
7803: PPUSH
7804: LD_STRING DStart-Burlak-Bur-1
7806: PPUSH
7807: CALL_OW 88
// Say ( Macmillan , DStart-Burlak-JMM-1 ) ;
7811: LD_EXP 13
7815: PPUSH
7816: LD_STRING DStart-Burlak-JMM-1
7818: PPUSH
7819: CALL_OW 88
// Say ( Burlak , DStart-Burlak-Bur-2 ) ;
7823: LD_EXP 12
7827: PPUSH
7828: LD_STRING DStart-Burlak-Bur-2
7830: PPUSH
7831: CALL_OW 88
// end ; end ;
7835: GO 7838
7837: POP
// SaveForQuickRestart ;
7838: CALL_OW 22
// wait ( 20 ) ;
7842: LD_INT 20
7844: PPUSH
7845: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
7849: LD_STRING MStart
7851: PPUSH
7852: CALL_OW 337
// interface_hidden := false ;
7856: LD_ADDR_OWVAR 54
7860: PUSH
7861: LD_INT 0
7863: ST_TO_ADDR
// DialogueOff ;
7864: CALL_OW 7
// us_researched := false ;
7868: LD_ADDR_EXP 61
7872: PUSH
7873: LD_INT 0
7875: ST_TO_ADDR
// us_researched := true ;
7876: LD_ADDR_EXP 61
7880: PUSH
7881: LD_INT 1
7883: ST_TO_ADDR
// omar_in_contact := false ;
7884: LD_ADDR_EXP 64
7888: PUSH
7889: LD_INT 0
7891: ST_TO_ADDR
// alien_tower_spoted := false ;
7892: LD_ADDR_LOC 10
7896: PUSH
7897: LD_INT 0
7899: ST_TO_ADDR
// one_enabled := false ;
7900: LD_ADDR_EXP 63
7904: PUSH
7905: LD_INT 0
7907: ST_TO_ADDR
// end ;
7908: LD_VAR 0 1
7912: RET
// every 0 0$2.3 trigger See ( you , al_tower ) do var un , sol , sci ;
7913: LD_EXP 1
7917: PPUSH
7918: LD_INT 108
7920: PPUSH
7921: CALL_OW 292
7925: IFFALSE 8431
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
// begin repeat wait ( 0 0$1 ) ;
7935: LD_INT 35
7937: PPUSH
7938: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] , f_not , [ f_inside ] ] ) ;
7942: LD_INT 22
7944: PUSH
7945: LD_EXP 4
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: LD_INT 21
7956: PUSH
7957: LD_INT 1
7959: PUSH
7960: EMPTY
7961: LIST
7962: LIST
7963: PUSH
7964: LD_INT 50
7966: PUSH
7967: EMPTY
7968: LIST
7969: PUSH
7970: LD_INT 3
7972: PUSH
7973: LD_INT 54
7975: PUSH
7976: EMPTY
7977: LIST
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: LIST
7983: LIST
7984: LIST
7985: PPUSH
7986: CALL_OW 69
7990: NOT
7991: IFFALSE 7935
// wait ( 0 0$1 ) ;
7993: LD_INT 35
7995: PPUSH
7996: CALL_OW 67
// cpu_list := cpu_list diff ar ;
8000: LD_ADDR_EXP 8
8004: PUSH
8005: LD_EXP 8
8009: PUSH
8010: LD_EXP 4
8014: DIFF
8015: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8016: LD_ADDR_VAR 0 1
8020: PUSH
8021: LD_INT 22
8023: PUSH
8024: LD_EXP 1
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 26
8035: PUSH
8036: LD_INT 1
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: PUSH
8052: LD_EXP 13
8056: PUSH
8057: LD_EXP 12
8061: PUSH
8062: LD_EXP 14
8066: PUSH
8067: LD_EXP 15
8071: PUSH
8072: LD_INT 0
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: LIST
8081: DIFF
8082: ST_TO_ADDR
// if un then
8083: LD_VAR 0 1
8087: IFFALSE 8107
// sol := FindMaxSkill ( un , skill_combat ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 1
8098: PPUSH
8099: LD_INT 1
8101: PPUSH
8102: CALL_OW 433
8106: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , sol , 0 ] ;
8107: LD_ADDR_VAR 0 1
8111: PUSH
8112: LD_INT 22
8114: PUSH
8115: LD_EXP 1
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 26
8126: PUSH
8127: LD_INT 1
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: PUSH
8143: LD_EXP 13
8147: PUSH
8148: LD_EXP 12
8152: PUSH
8153: LD_EXP 14
8157: PUSH
8158: LD_EXP 15
8162: PUSH
8163: LD_VAR 0 2
8167: PUSH
8168: LD_INT 0
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: LIST
8178: DIFF
8179: ST_TO_ADDR
// if un then
8180: LD_VAR 0 1
8184: IFFALSE 8204
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8186: LD_ADDR_VAR 0 3
8190: PUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: LD_INT 4
8198: PPUSH
8199: CALL_OW 433
8203: ST_TO_ADDR
// PlaceSeeing ( 248 , 183 , you , 10 ) ;
8204: LD_INT 248
8206: PPUSH
8207: LD_INT 183
8209: PPUSH
8210: LD_EXP 1
8214: PPUSH
8215: LD_INT 10
8217: PPUSH
8218: CALL_OW 330
// CenterOnUnits ( al_tower ) ;
8222: LD_INT 108
8224: PPUSH
8225: CALL_OW 85
// DialogueOn ;
8229: CALL_OW 6
// interface_hidden := true ;
8233: LD_ADDR_OWVAR 54
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// Say ( sol , DAlienBase-Rsol1-1 ) ;
8241: LD_VAR 0 2
8245: PPUSH
8246: LD_STRING DAlienBase-Rsol1-1
8248: PPUSH
8249: CALL_OW 88
// case camp of 4 :
8253: LD_EXP 7
8257: PUSH
8258: LD_INT 4
8260: DOUBLE
8261: EQUAL
8262: IFTRUE 8266
8264: GO 8317
8266: POP
// begin Say ( MacMillan , DAlienBase-JMM-1 ) ;
8267: LD_EXP 13
8271: PPUSH
8272: LD_STRING DAlienBase-JMM-1
8274: PPUSH
8275: CALL_OW 88
// Say ( Roth , DAlienBase-Roth-1 ) ;
8279: LD_EXP 14
8283: PPUSH
8284: LD_STRING DAlienBase-Roth-1
8286: PPUSH
8287: CALL_OW 88
// if not IsOK ( Roth ) then
8291: LD_EXP 14
8295: PPUSH
8296: CALL_OW 302
8300: NOT
8301: IFFALSE 8315
// Say ( sci , DAlienBase-Sci1-1 ) ;
8303: LD_VAR 0 3
8307: PPUSH
8308: LD_STRING DAlienBase-Sci1-1
8310: PPUSH
8311: CALL_OW 88
// end ; 6 :
8315: GO 8377
8317: LD_INT 6
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8376
8325: POP
// begin Say ( Burlak , DAlienBase-Bur-1 ) ;
8326: LD_EXP 12
8330: PPUSH
8331: LD_STRING DAlienBase-Bur-1
8333: PPUSH
8334: CALL_OW 88
// Say ( Gossudarov , DAlienBase-Gos-1 ) ;
8338: LD_EXP 15
8342: PPUSH
8343: LD_STRING DAlienBase-Gos-1
8345: PPUSH
8346: CALL_OW 88
// if not IsOK ( Gossudarov ) then
8350: LD_EXP 15
8354: PPUSH
8355: CALL_OW 302
8359: NOT
8360: IFFALSE 8374
// Say ( sci , DAlienBase-Sci1-1 ) ;
8362: LD_VAR 0 3
8366: PPUSH
8367: LD_STRING DAlienBase-Sci1-1
8369: PPUSH
8370: CALL_OW 88
// end ; end ;
8374: GO 8377
8376: POP
// SetSide ( al_tower , you ) ;
8377: LD_INT 108
8379: PPUSH
8380: LD_EXP 1
8384: PPUSH
8385: CALL_OW 235
// RemoveSeeing ( 248 , 183 , you ) ;
8389: LD_INT 248
8391: PPUSH
8392: LD_INT 183
8394: PPUSH
8395: LD_EXP 1
8399: PPUSH
8400: CALL_OW 331
// interface_hidden := false ;
8404: LD_ADDR_OWVAR 54
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// DialogueOff ;
8412: CALL_OW 7
// Hint ( ArtefactBuilding ) ;
8416: LD_STRING ArtefactBuilding
8418: PPUSH
8419: CALL_OW 339
// alien_tower_spoted := true ;
8423: LD_ADDR_LOC 10
8427: PUSH
8428: LD_INT 1
8430: ST_TO_ADDR
// end ;
8431: PPOPN 3
8433: END
// every 0 0$4.6 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] , [ f_lives , 1000 ] ] ) and alien_tower_spoted do var un , sci ;
8434: LD_INT 22
8436: PUSH
8437: LD_EXP 1
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: LD_INT 2
8448: PUSH
8449: LD_INT 30
8451: PUSH
8452: LD_INT 6
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PUSH
8459: LD_INT 30
8461: PUSH
8462: LD_INT 7
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: LIST
8473: PUSH
8474: LD_INT 24
8476: PUSH
8477: LD_INT 1000
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 69
8493: PUSH
8494: LD_LOC 10
8498: AND
8499: IFFALSE 8767
8501: GO 8503
8503: DISABLE
8504: LD_INT 0
8506: PPUSH
8507: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_EXP 1
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 26
8527: PUSH
8528: LD_INT 1
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PPUSH
8539: CALL_OW 69
8543: PUSH
8544: LD_EXP 13
8548: PUSH
8549: LD_EXP 12
8553: PUSH
8554: LD_EXP 14
8558: PUSH
8559: LD_EXP 15
8563: PUSH
8564: LD_INT 0
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: LIST
8573: DIFF
8574: ST_TO_ADDR
// if un then
8575: LD_VAR 0 1
8579: IFFALSE 8599
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_VAR 0 1
8590: PPUSH
8591: LD_INT 4
8593: PPUSH
8594: CALL_OW 433
8598: ST_TO_ADDR
// CenterOnUnits ( al_tower ) ;
8599: LD_INT 108
8601: PPUSH
8602: CALL_OW 85
// DialogueOn ;
8606: CALL_OW 6
// interface_hidden := true ;
8610: LD_ADDR_OWVAR 54
8614: PUSH
8615: LD_INT 1
8617: ST_TO_ADDR
// case camp of 4 :
8618: LD_EXP 7
8622: PUSH
8623: LD_INT 4
8625: DOUBLE
8626: EQUAL
8627: IFTRUE 8631
8629: GO 8671
8631: POP
// if IsOK ( Gossudarov ) then
8632: LD_EXP 15
8636: PPUSH
8637: CALL_OW 302
8641: IFFALSE 8657
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
8643: LD_EXP 15
8647: PPUSH
8648: LD_STRING DAlieBaseNotReady-Gos-1
8650: PPUSH
8651: CALL_OW 88
8655: GO 8669
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) ; 6 :
8657: LD_EXP 14
8661: PPUSH
8662: LD_STRING DAlieBaseNotReady-Roth-1
8664: PPUSH
8665: CALL_OW 88
8669: GO 8720
8671: LD_INT 6
8673: DOUBLE
8674: EQUAL
8675: IFTRUE 8679
8677: GO 8719
8679: POP
// if IsOK ( Roth ) then
8680: LD_EXP 14
8684: PPUSH
8685: CALL_OW 302
8689: IFFALSE 8705
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
8691: LD_EXP 14
8695: PPUSH
8696: LD_STRING DAlieBaseNotReady-Roth-1
8698: PPUSH
8699: CALL_OW 88
8703: GO 8717
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) ; end ;
8705: LD_EXP 15
8709: PPUSH
8710: LD_STRING DAlieBaseNotReady-Gos-1
8712: PPUSH
8713: CALL_OW 88
8717: GO 8720
8719: POP
// if not ( IsOK ( Gossudarov ) or IsOK ( Roth ) ) then
8720: LD_EXP 15
8724: PPUSH
8725: CALL_OW 302
8729: PUSH
8730: LD_EXP 14
8734: PPUSH
8735: CALL_OW 302
8739: OR
8740: NOT
8741: IFFALSE 8755
// Say ( sci , DAlieBaseNotReady-RSci1-1 ) ;
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_STRING DAlieBaseNotReady-RSci1-1
8750: PPUSH
8751: CALL_OW 88
// interface_hidden := false ;
8755: LD_ADDR_OWVAR 54
8759: PUSH
8760: LD_INT 0
8762: ST_TO_ADDR
// DialogueOff ;
8763: CALL_OW 7
// end ;
8767: PPOPN 2
8769: END
// every 0 0$8.7 trigger GetTech ( tech_Artifact , you ) = state_researched do var un , lab , list ;
8770: LD_INT 24
8772: PPUSH
8773: LD_EXP 1
8777: PPUSH
8778: CALL_OW 321
8782: PUSH
8783: LD_INT 2
8785: EQUAL
8786: IFFALSE 8924
8788: GO 8790
8790: DISABLE
8791: LD_INT 0
8793: PPUSH
8794: PPUSH
8795: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
8796: LD_ADDR_VAR 0 3
8800: PUSH
8801: LD_INT 22
8803: PUSH
8804: LD_EXP 1
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 2
8815: PUSH
8816: LD_INT 30
8818: PUSH
8819: LD_INT 6
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: LD_INT 30
8828: PUSH
8829: LD_INT 7
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 30
8838: PUSH
8839: LD_INT 8
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: PPUSH
8856: CALL_OW 69
8860: ST_TO_ADDR
// lab := false ;
8861: LD_ADDR_VAR 0 2
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// for un in list do
8869: LD_ADDR_VAR 0 1
8873: PUSH
8874: LD_VAR 0 3
8878: PUSH
8879: FOR_IN
8880: IFFALSE 8909
// if GetLives ( un ) = 1000 then
8882: LD_VAR 0 1
8886: PPUSH
8887: CALL_OW 256
8891: PUSH
8892: LD_INT 1000
8894: EQUAL
8895: IFFALSE 8907
// lab := un ;
8897: LD_ADDR_VAR 0 2
8901: PUSH
8902: LD_VAR 0 1
8906: ST_TO_ADDR
8907: GO 8879
8909: POP
8910: POP
// if lab then
8911: LD_VAR 0 2
8915: IFFALSE 8923
// begin Talking_About_Artefact ;
8917: CALL 8927 0 0
// exit ;
8921: GO 8924
// end ; enable ;
8923: ENABLE
// end ;
8924: PPOPN 3
8926: END
// export function Talking_About_Artefact ; var un , ru_sci , us_sci , your_depot ; begin
8927: LD_INT 0
8929: PPUSH
8930: PPUSH
8931: PPUSH
8932: PPUSH
8933: PPUSH
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_INT 22
8941: PUSH
8942: LD_EXP 1
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: LD_INT 23
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 26
8963: PUSH
8964: LD_INT 1
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: LIST
8975: PPUSH
8976: CALL_OW 69
8980: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8981: LD_ADDR_VAR 0 2
8985: PUSH
8986: LD_VAR 0 2
8990: PUSH
8991: LD_EXP 13
8995: PUSH
8996: LD_EXP 12
9000: PUSH
9001: LD_EXP 14
9005: PUSH
9006: LD_EXP 15
9010: PUSH
9011: LD_INT 0
9013: PUSH
9014: EMPTY
9015: LIST
9016: LIST
9017: LIST
9018: LIST
9019: LIST
9020: DIFF
9021: ST_TO_ADDR
// if un then
9022: LD_VAR 0 2
9026: IFFALSE 9046
// ru_sci := FindMaxSkill ( un , skill_scientistic ) ;
9028: LD_ADDR_VAR 0 3
9032: PUSH
9033: LD_VAR 0 2
9037: PPUSH
9038: LD_INT 4
9040: PPUSH
9041: CALL_OW 433
9045: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9046: LD_ADDR_VAR 0 2
9050: PUSH
9051: LD_INT 22
9053: PUSH
9054: LD_EXP 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: LD_INT 23
9065: PUSH
9066: LD_INT 1
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: PUSH
9073: LD_INT 26
9075: PUSH
9076: LD_INT 1
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PPUSH
9088: CALL_OW 69
9092: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9093: LD_ADDR_VAR 0 2
9097: PUSH
9098: LD_VAR 0 2
9102: PUSH
9103: LD_EXP 13
9107: PUSH
9108: LD_EXP 12
9112: PUSH
9113: LD_EXP 14
9117: PUSH
9118: LD_EXP 15
9122: PUSH
9123: LD_INT 0
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: LIST
9130: LIST
9131: LIST
9132: DIFF
9133: ST_TO_ADDR
// if un then
9134: LD_VAR 0 2
9138: IFFALSE 9158
// us_sci := FindMaxSkill ( un , skill_scientistic ) ;
9140: LD_ADDR_VAR 0 4
9144: PUSH
9145: LD_VAR 0 2
9149: PPUSH
9150: LD_INT 4
9152: PPUSH
9153: CALL_OW 433
9157: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_INT 22
9165: PUSH
9166: LD_EXP 1
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: LD_INT 30
9180: PUSH
9181: LD_INT 0
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PUSH
9188: LD_INT 30
9190: PUSH
9191: LD_INT 1
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: LIST
9202: PUSH
9203: EMPTY
9204: LIST
9205: LIST
9206: PPUSH
9207: CALL_OW 69
9211: ST_TO_ADDR
// if un then
9212: LD_VAR 0 2
9216: IFFALSE 9232
// your_depot := un [ 1 ] ;
9218: LD_ADDR_VAR 0 5
9222: PUSH
9223: LD_VAR 0 2
9227: PUSH
9228: LD_INT 1
9230: ARRAY
9231: ST_TO_ADDR
// CenterOnUnits ( Burlak ) ;
9232: LD_EXP 12
9236: PPUSH
9237: CALL_OW 85
// DialogueOn ;
9241: CALL_OW 6
// interface_hidden := true ;
9245: LD_ADDR_OWVAR 54
9249: PUSH
9250: LD_INT 1
9252: ST_TO_ADDR
// Say ( ru_sci , DArtefTechnology-RSci1-1 ) ;
9253: LD_VAR 0 3
9257: PPUSH
9258: LD_STRING DArtefTechnology-RSci1-1
9260: PPUSH
9261: CALL_OW 88
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
9265: LD_EXP 12
9269: PPUSH
9270: LD_STRING DArtefTechnology-Bur-1
9272: PPUSH
9273: CALL_OW 88
// Say ( ru_sci , DArtefTechnology-RSci1-2 ) ;
9277: LD_VAR 0 3
9281: PPUSH
9282: LD_STRING DArtefTechnology-RSci1-2
9284: PPUSH
9285: CALL_OW 88
// Say ( us_sci , DArtefTechnology-Sci1-2 ) ;
9289: LD_VAR 0 4
9293: PPUSH
9294: LD_STRING DArtefTechnology-Sci1-2
9296: PPUSH
9297: CALL_OW 88
// case camp of 4 :
9301: LD_EXP 7
9305: PUSH
9306: LD_INT 4
9308: DOUBLE
9309: EQUAL
9310: IFTRUE 9314
9312: GO 9329
9314: POP
// Say ( MacMillan , DArtefTechnology-JMM-2 ) ; 6 :
9315: LD_EXP 13
9319: PPUSH
9320: LD_STRING DArtefTechnology-JMM-2
9322: PPUSH
9323: CALL_OW 88
9327: GO 9353
9329: LD_INT 6
9331: DOUBLE
9332: EQUAL
9333: IFTRUE 9337
9335: GO 9352
9337: POP
// Say ( Burlak , DArtefTechnology-Bur-2 ) ; end ;
9338: LD_EXP 12
9342: PPUSH
9343: LD_STRING DArtefTechnology-Bur-2
9345: PPUSH
9346: CALL_OW 88
9350: GO 9353
9352: POP
// Say ( ru_sci , DArtefTechnology-RSci1-3 ) ;
9353: LD_VAR 0 3
9357: PPUSH
9358: LD_STRING DArtefTechnology-RSci1-3
9360: PPUSH
9361: CALL_OW 88
// if GetDistUnits ( your_depot , al_tower ) < 30 then
9365: LD_VAR 0 5
9369: PPUSH
9370: LD_INT 108
9372: PPUSH
9373: CALL_OW 296
9377: PUSH
9378: LD_INT 30
9380: LESS
9381: IFFALSE 9397
// Say ( us_sci , DArtefTechnology-Sci1-3 ) else
9383: LD_VAR 0 4
9387: PPUSH
9388: LD_STRING DArtefTechnology-Sci1-3
9390: PPUSH
9391: CALL_OW 88
9395: GO 9409
// Say ( us_sci , DArtefTechnology-Sci1-3a ) ;
9397: LD_VAR 0 4
9401: PPUSH
9402: LD_STRING DArtefTechnology-Sci1-3a
9404: PPUSH
9405: CALL_OW 88
// interface_hidden := false ;
9409: LD_ADDR_OWVAR 54
9413: PUSH
9414: LD_INT 0
9416: ST_TO_ADDR
// DialogueOff ;
9417: CALL_OW 7
// end ; end_of_file
9421: LD_VAR 0 1
9425: RET
// export us_researched , ru_researched ; export one_enabled ; every 0 0$1.1 do var un , sci ;
9426: GO 9428
9428: DISABLE
9429: LD_INT 0
9431: PPUSH
9432: PPUSH
// begin exit ;
9433: GO 9679
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9435: LD_ADDR_VAR 0 1
9439: PUSH
9440: LD_INT 22
9442: PUSH
9443: LD_EXP 1
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 23
9454: PUSH
9455: LD_INT 1
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PUSH
9462: LD_INT 26
9464: PUSH
9465: LD_INT 1
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PUSH
9472: EMPTY
9473: LIST
9474: LIST
9475: LIST
9476: PPUSH
9477: CALL_OW 69
9481: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9482: LD_ADDR_VAR 0 1
9486: PUSH
9487: LD_VAR 0 1
9491: PUSH
9492: LD_EXP 13
9496: PUSH
9497: LD_EXP 12
9501: PUSH
9502: LD_EXP 14
9506: PUSH
9507: LD_EXP 15
9511: PUSH
9512: LD_INT 0
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: DIFF
9522: ST_TO_ADDR
// if un then
9523: LD_VAR 0 1
9527: IFFALSE 9547
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9529: LD_ADDR_VAR 0 2
9533: PUSH
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_INT 4
9541: PPUSH
9542: CALL_OW 433
9546: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
9547: LD_EXP 13
9551: PUSH
9552: LD_EXP 12
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 85
// DialogueOn ;
9565: CALL_OW 6
// interface_hidden := true ;
9569: LD_ADDR_OWVAR 54
9573: PUSH
9574: LD_INT 1
9576: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAm-Sci1-1 ) ;
9577: LD_VAR 0 2
9581: PPUSH
9582: LD_STRING DArtefTechnologyAm-Sci1-1
9584: PPUSH
9585: CALL_OW 88
// case camp of 4 :
9589: LD_EXP 7
9593: PUSH
9594: LD_INT 4
9596: DOUBLE
9597: EQUAL
9598: IFTRUE 9602
9600: GO 9617
9602: POP
// Say ( MacMillan , DArtefTechnologyAm-JMM-1 ) ; 6 :
9603: LD_EXP 13
9607: PPUSH
9608: LD_STRING DArtefTechnologyAm-JMM-1
9610: PPUSH
9611: CALL_OW 88
9615: GO 9641
9617: LD_INT 6
9619: DOUBLE
9620: EQUAL
9621: IFTRUE 9625
9623: GO 9640
9625: POP
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ; end ;
9626: LD_EXP 12
9630: PPUSH
9631: LD_STRING DArtefTechnologyAm-Bur-1
9633: PPUSH
9634: CALL_OW 88
9638: GO 9641
9640: POP
// interface_hidden := false ;
9641: LD_ADDR_OWVAR 54
9645: PUSH
9646: LD_INT 0
9648: ST_TO_ADDR
// DialogueOff ;
9649: CALL_OW 7
// if not one_enabled then
9653: LD_EXP 63
9657: NOT
9658: IFFALSE 9671
// begin enable ( 1 ) ;
9660: LD_INT 1
9662: ENABLE_MARKED
// one_enabled := true ;
9663: LD_ADDR_EXP 63
9667: PUSH
9668: LD_INT 1
9670: ST_TO_ADDR
// end ; us_researched := true ;
9671: LD_ADDR_EXP 61
9675: PUSH
9676: LD_INT 1
9678: ST_TO_ADDR
// end ;
9679: PPOPN 2
9681: END
// every 0 0$1.3 do var un , sci ;
9682: GO 9684
9684: DISABLE
9685: LD_INT 0
9687: PPUSH
9688: PPUSH
// begin exit ;
9689: GO 9947
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9691: LD_ADDR_VAR 0 1
9695: PUSH
9696: LD_INT 22
9698: PUSH
9699: LD_EXP 1
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: PUSH
9708: LD_INT 23
9710: PUSH
9711: LD_INT 3
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 26
9720: PUSH
9721: LD_INT 1
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: LIST
9732: PPUSH
9733: CALL_OW 69
9737: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9738: LD_ADDR_VAR 0 1
9742: PUSH
9743: LD_VAR 0 1
9747: PUSH
9748: LD_EXP 13
9752: PUSH
9753: LD_EXP 12
9757: PUSH
9758: LD_EXP 14
9762: PUSH
9763: LD_EXP 15
9767: PUSH
9768: LD_INT 0
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: LIST
9777: DIFF
9778: ST_TO_ADDR
// if un then
9779: LD_VAR 0 1
9783: IFFALSE 9803
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9785: LD_ADDR_VAR 0 2
9789: PUSH
9790: LD_VAR 0 1
9794: PPUSH
9795: LD_INT 4
9797: PPUSH
9798: CALL_OW 433
9802: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , sci ] ) ;
9803: LD_EXP 13
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PPUSH
9817: CALL_OW 85
// DialogueOn ;
9821: CALL_OW 6
// interface_hidden := true ;
9825: LD_ADDR_OWVAR 54
9829: PUSH
9830: LD_INT 1
9832: ST_TO_ADDR
// Say ( sci , DArtefTechnologyRu-RSci1-1 ) ;
9833: LD_VAR 0 2
9837: PPUSH
9838: LD_STRING DArtefTechnologyRu-RSci1-1
9840: PPUSH
9841: CALL_OW 88
// case camp of 4 :
9845: LD_EXP 7
9849: PUSH
9850: LD_INT 4
9852: DOUBLE
9853: EQUAL
9854: IFTRUE 9858
9856: GO 9873
9858: POP
// Say ( MacMillan , DArtefTechnologyRu-JMM-1 ) ; 6 :
9859: LD_EXP 13
9863: PPUSH
9864: LD_STRING DArtefTechnologyRu-JMM-1
9866: PPUSH
9867: CALL_OW 88
9871: GO 9897
9873: LD_INT 6
9875: DOUBLE
9876: EQUAL
9877: IFTRUE 9881
9879: GO 9896
9881: POP
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ; end ;
9882: LD_EXP 12
9886: PPUSH
9887: LD_STRING DArtefTechnologyRu-Bur-1
9889: PPUSH
9890: CALL_OW 88
9894: GO 9897
9896: POP
// Say ( sci , DArtefTechnologyRu-RSci1-2 ) ;
9897: LD_VAR 0 2
9901: PPUSH
9902: LD_STRING DArtefTechnologyRu-RSci1-2
9904: PPUSH
9905: CALL_OW 88
// interface_hidden := false ;
9909: LD_ADDR_OWVAR 54
9913: PUSH
9914: LD_INT 0
9916: ST_TO_ADDR
// DialogueOff ;
9917: CALL_OW 7
// if not one_enabled then
9921: LD_EXP 63
9925: NOT
9926: IFFALSE 9939
// begin enable ( 1 ) ;
9928: LD_INT 1
9930: ENABLE_MARKED
// one_enabled := true ;
9931: LD_ADDR_EXP 63
9935: PUSH
9936: LD_INT 1
9938: ST_TO_ADDR
// end ; ru_researched := true ;
9939: LD_ADDR_EXP 62
9943: PUSH
9944: LD_INT 1
9946: ST_TO_ADDR
// end ;
9947: PPOPN 2
9949: END
// every 0 0$5.3 trigger ( GetSide ( al_tower ) = you ) and ( GetTag ( 81 ) or GetTag ( 181 ) ) marked 1 do var un , sci ;
9950: LD_INT 108
9952: PPUSH
9953: CALL_OW 255
9957: PUSH
9958: LD_EXP 1
9962: EQUAL
9963: PUSH
9964: LD_INT 81
9966: PPUSH
9967: CALL_OW 110
9971: PUSH
9972: LD_INT 181
9974: PPUSH
9975: CALL_OW 110
9979: OR
9980: AND
9981: IFFALSE 10225
9983: GO 9985
9985: DISABLE
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
// begin un := [ ] ;
9990: LD_ADDR_VAR 0 1
9994: PUSH
9995: EMPTY
9996: ST_TO_ADDR
// if us_researched then
9997: LD_EXP 61
10001: IFFALSE 10056
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
10003: LD_ADDR_VAR 0 1
10007: PUSH
10008: LD_VAR 0 1
10012: PUSH
10013: LD_INT 22
10015: PUSH
10016: LD_EXP 1
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PUSH
10025: LD_INT 23
10027: PUSH
10028: LD_INT 1
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 26
10037: PUSH
10038: LD_INT 1
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: LIST
10049: PPUSH
10050: CALL_OW 69
10054: ADD
10055: ST_TO_ADDR
// if ru_researched then
10056: LD_EXP 62
10060: IFFALSE 10115
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10062: LD_ADDR_VAR 0 1
10066: PUSH
10067: LD_VAR 0 1
10071: PUSH
10072: LD_INT 22
10074: PUSH
10075: LD_EXP 1
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 1
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: ADD
10114: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 1
10124: PUSH
10125: LD_EXP 13
10129: PUSH
10130: LD_EXP 12
10134: PUSH
10135: LD_EXP 14
10139: PUSH
10140: LD_EXP 15
10144: PUSH
10145: LD_INT 0
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: DIFF
10155: ST_TO_ADDR
// if un then
10156: LD_VAR 0 1
10160: IFFALSE 10180
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10162: LD_ADDR_VAR 0 2
10166: PUSH
10167: LD_VAR 0 1
10171: PPUSH
10172: LD_INT 4
10174: PPUSH
10175: CALL_OW 433
10179: ST_TO_ADDR
// CenterOnUnits ( sci ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: CALL_OW 85
// DialogueOn ;
10189: CALL_OW 6
// interface_hidden := true ;
10193: LD_ADDR_OWVAR 54
10197: PUSH
10198: LD_INT 1
10200: ST_TO_ADDR
// Say ( sci , DArtefTechnologyArStart-Sci1-1 ) ;
10201: LD_VAR 0 2
10205: PPUSH
10206: LD_STRING DArtefTechnologyArStart-Sci1-1
10208: PPUSH
10209: CALL_OW 88
// interface_hidden := false ;
10213: LD_ADDR_OWVAR 54
10217: PUSH
10218: LD_INT 0
10220: ST_TO_ADDR
// DialogueOff ;
10221: CALL_OW 7
// end ;
10225: PPOPN 2
10227: END
// every 0 0$3.9 trigger GetTag ( 281 ) do var un , sci ;
10228: LD_INT 281
10230: PPUSH
10231: CALL_OW 110
10235: IFFALSE 10596
10237: GO 10239
10239: DISABLE
10240: LD_INT 0
10242: PPUSH
10243: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10244: LD_ADDR_VAR 0 1
10248: PUSH
10249: LD_INT 22
10251: PUSH
10252: LD_EXP 1
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 23
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 26
10273: PUSH
10274: LD_INT 1
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10291: LD_ADDR_VAR 0 1
10295: PUSH
10296: LD_VAR 0 1
10300: PUSH
10301: LD_EXP 13
10305: PUSH
10306: LD_EXP 12
10310: PUSH
10311: LD_EXP 14
10315: PUSH
10316: LD_EXP 15
10320: PUSH
10321: LD_INT 0
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: DIFF
10331: ST_TO_ADDR
// if un then
10332: LD_VAR 0 1
10336: IFFALSE 10358
// sci := FindMaxSkill ( un , skill_scientistic ) else
10338: LD_ADDR_VAR 0 2
10342: PUSH
10343: LD_VAR 0 1
10347: PPUSH
10348: LD_INT 4
10350: PPUSH
10351: CALL_OW 433
10355: ST_TO_ADDR
10356: GO 10360
// exit ;
10358: GO 10596
// CenterOnUnits ( [ MacMillan , Burlak , sci ] ) ;
10360: LD_EXP 13
10364: PUSH
10365: LD_EXP 12
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 85
// DialogueOn ;
10384: CALL_OW 6
// interface_hidden := true ;
10388: LD_ADDR_OWVAR 54
10392: PUSH
10393: LD_INT 1
10395: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAr-RSci1-1 ) ;
10396: LD_VAR 0 2
10400: PPUSH
10401: LD_STRING DArtefTechnologyAr-RSci1-1
10403: PPUSH
10404: CALL_OW 88
// case camp of 4 :
10408: LD_EXP 7
10412: PUSH
10413: LD_INT 4
10415: DOUBLE
10416: EQUAL
10417: IFTRUE 10421
10419: GO 10436
10421: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-1 ) ; 6 :
10422: LD_EXP 13
10426: PPUSH
10427: LD_STRING DArtefTechnologyAr-JMM-1
10429: PPUSH
10430: CALL_OW 88
10434: GO 10460
10436: LD_INT 6
10438: DOUBLE
10439: EQUAL
10440: IFTRUE 10444
10442: GO 10459
10444: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-1 ) ; end ;
10445: LD_EXP 12
10449: PPUSH
10450: LD_STRING DArtefTechnologyAr-Bur-1
10452: PPUSH
10453: CALL_OW 88
10457: GO 10460
10459: POP
// Say ( sci , DArtefTechnologyAr-RSci1-2 ) ;
10460: LD_VAR 0 2
10464: PPUSH
10465: LD_STRING DArtefTechnologyAr-RSci1-2
10467: PPUSH
10468: CALL_OW 88
// case camp of 4 :
10472: LD_EXP 7
10476: PUSH
10477: LD_INT 4
10479: DOUBLE
10480: EQUAL
10481: IFTRUE 10485
10483: GO 10500
10485: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-2 ) ; 6 :
10486: LD_EXP 13
10490: PPUSH
10491: LD_STRING DArtefTechnologyAr-JMM-2
10493: PPUSH
10494: CALL_OW 88
10498: GO 10524
10500: LD_INT 6
10502: DOUBLE
10503: EQUAL
10504: IFTRUE 10508
10506: GO 10523
10508: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-2 ) ; end ;
10509: LD_EXP 12
10513: PPUSH
10514: LD_STRING DArtefTechnologyAr-Bur-2
10516: PPUSH
10517: CALL_OW 88
10521: GO 10524
10523: POP
// Say ( sci , DArtefTechnologyAr-RSci1-3 ) ;
10524: LD_VAR 0 2
10528: PPUSH
10529: LD_STRING DArtefTechnologyAr-RSci1-3
10531: PPUSH
10532: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-3 ) ;
10536: LD_EXP 13
10540: PPUSH
10541: LD_STRING DArtefTechnologyAr-JMM-3
10543: PPUSH
10544: CALL_OW 88
// Say ( sci , DArtefTechnologyAr-RSci1-4 ) ;
10548: LD_VAR 0 2
10552: PPUSH
10553: LD_STRING DArtefTechnologyAr-RSci1-4
10555: PPUSH
10556: CALL_OW 88
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
10560: LD_EXP 12
10564: PPUSH
10565: LD_STRING DArtefTechnologyAr-Bur-4
10567: PPUSH
10568: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-4 ) ;
10572: LD_EXP 13
10576: PPUSH
10577: LD_STRING DArtefTechnologyAr-JMM-4
10579: PPUSH
10580: CALL_OW 88
// interface_hidden := false ;
10584: LD_ADDR_OWVAR 54
10588: PUSH
10589: LD_INT 0
10591: ST_TO_ADDR
// DialogueOff ;
10592: CALL_OW 7
// end ; end_of_file
10596: PPOPN 2
10598: END
// export omar_in_contact ; var sib_list ; every 0 0$2 + 0 0$0.4 trigger FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] ] ) = 0 marked 2 do var answer ;
10599: LD_INT 22
10601: PUSH
10602: LD_EXP 4
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 21
10613: PUSH
10614: LD_INT 1
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 50
10623: PUSH
10624: EMPTY
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: PUSH
10637: LD_INT 0
10639: EQUAL
10640: IFFALSE 11071
10642: GO 10644
10644: DISABLE
10645: LD_INT 0
10647: PPUSH
// begin Omar_Arrive ;
10648: CALL 11074 0 0
// CenterOnUnits ( Omar ) ;
10652: LD_EXP 51
10656: PPUSH
10657: CALL_OW 85
// DialogueOn ;
10661: CALL_OW 6
// interface_hidden := true ;
10665: LD_ADDR_OWVAR 54
10669: PUSH
10670: LD_INT 1
10672: ST_TO_ADDR
// Say ( Omar , DOmar-Omar-1 ) ;
10673: LD_EXP 51
10677: PPUSH
10678: LD_STRING DOmar-Omar-1
10680: PPUSH
10681: CALL_OW 88
// case camp of 4 :
10685: LD_EXP 7
10689: PUSH
10690: LD_INT 4
10692: DOUBLE
10693: EQUAL
10694: IFTRUE 10698
10696: GO 10713
10698: POP
// Say ( MacMillan , DOmar-JMM-1 ) ; 6 :
10699: LD_EXP 13
10703: PPUSH
10704: LD_STRING DOmar-JMM-1
10706: PPUSH
10707: CALL_OW 88
10711: GO 10737
10713: LD_INT 6
10715: DOUBLE
10716: EQUAL
10717: IFTRUE 10721
10719: GO 10736
10721: POP
// Say ( Burlak , DOmar-Bur-1 ) ; end ;
10722: LD_EXP 12
10726: PPUSH
10727: LD_STRING DOmar-Bur-1
10729: PPUSH
10730: CALL_OW 88
10734: GO 10737
10736: POP
// Say ( Omar , DOmar-Omar-2 ) ;
10737: LD_EXP 51
10741: PPUSH
10742: LD_STRING DOmar-Omar-2
10744: PPUSH
10745: CALL_OW 88
// case camp of 4 :
10749: LD_EXP 7
10753: PUSH
10754: LD_INT 4
10756: DOUBLE
10757: EQUAL
10758: IFTRUE 10762
10760: GO 10777
10762: POP
// Say ( MacMillan , DOmar-JMM-2 ) ; 6 :
10763: LD_EXP 13
10767: PPUSH
10768: LD_STRING DOmar-JMM-2
10770: PPUSH
10771: CALL_OW 88
10775: GO 10801
10777: LD_INT 6
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10800
10785: POP
// Say ( Burlak , DOmar-Bur-2 ) ; end ;
10786: LD_EXP 12
10790: PPUSH
10791: LD_STRING DOmar-Bur-2
10793: PPUSH
10794: CALL_OW 88
10798: GO 10801
10800: POP
// Say ( Omar , DOmar-Omar-3 ) ;
10801: LD_EXP 51
10805: PPUSH
10806: LD_STRING DOmar-Omar-3
10808: PPUSH
10809: CALL_OW 88
// case camp of 4 :
10813: LD_EXP 7
10817: PUSH
10818: LD_INT 4
10820: DOUBLE
10821: EQUAL
10822: IFTRUE 10826
10824: GO 10841
10826: POP
// Say ( MacMillan , DOmar-JMM-3 ) ; 6 :
10827: LD_EXP 13
10831: PPUSH
10832: LD_STRING DOmar-JMM-3
10834: PPUSH
10835: CALL_OW 88
10839: GO 10865
10841: LD_INT 6
10843: DOUBLE
10844: EQUAL
10845: IFTRUE 10849
10847: GO 10864
10849: POP
// Say ( Burlak , DOmar-Bur-3 ) ; end ;
10850: LD_EXP 12
10854: PPUSH
10855: LD_STRING DOmar-Bur-3
10857: PPUSH
10858: CALL_OW 88
10862: GO 10865
10864: POP
// Say ( Omar , DOmar-Omar-4 ) ;
10865: LD_EXP 51
10869: PPUSH
10870: LD_STRING DOmar-Omar-4
10872: PPUSH
10873: CALL_OW 88
// answer = Query ( QAccept ) ;
10877: LD_ADDR_VAR 0 1
10881: PUSH
10882: LD_STRING QAccept
10884: PPUSH
10885: CALL_OW 97
10889: ST_TO_ADDR
// case answer of 1 :
10890: LD_VAR 0 1
10894: PUSH
10895: LD_INT 1
10897: DOUBLE
10898: EQUAL
10899: IFTRUE 10903
10901: GO 10981
10903: POP
// begin case camp of 4 :
10904: LD_EXP 7
10908: PUSH
10909: LD_INT 4
10911: DOUBLE
10912: EQUAL
10913: IFTRUE 10917
10915: GO 10932
10917: POP
// Say ( MacMillan , DQrAccept#1-JMM-1 ) ; 6 :
10918: LD_EXP 13
10922: PPUSH
10923: LD_STRING DQrAccept#1-JMM-1
10925: PPUSH
10926: CALL_OW 88
10930: GO 10956
10932: LD_INT 6
10934: DOUBLE
10935: EQUAL
10936: IFTRUE 10940
10938: GO 10955
10940: POP
// Say ( Burlak , DQrAccept#1-Bur-1 ) ; end ;
10941: LD_EXP 12
10945: PPUSH
10946: LD_STRING DQrAccept#1-Bur-1
10948: PPUSH
10949: CALL_OW 88
10953: GO 10956
10955: POP
// SetSide ( Omar , you ) ;
10956: LD_EXP 51
10960: PPUSH
10961: LD_EXP 1
10965: PPUSH
10966: CALL_OW 235
// ComStop ( Omar ) ;
10970: LD_EXP 51
10974: PPUSH
10975: CALL_OW 141
// end ; 2 :
10979: GO 11045
10981: LD_INT 2
10983: DOUBLE
10984: EQUAL
10985: IFTRUE 10989
10987: GO 11044
10989: POP
// begin case camp of 4 :
10990: LD_EXP 7
10994: PUSH
10995: LD_INT 4
10997: DOUBLE
10998: EQUAL
10999: IFTRUE 11003
11001: GO 11018
11003: POP
// Say ( MacMillan , DQrAccept#2-JMM-1 ) ; 6 :
11004: LD_EXP 13
11008: PPUSH
11009: LD_STRING DQrAccept#2-JMM-1
11011: PPUSH
11012: CALL_OW 88
11016: GO 11042
11018: LD_INT 6
11020: DOUBLE
11021: EQUAL
11022: IFTRUE 11026
11024: GO 11041
11026: POP
// Say ( Burlak , DQrAccept#2-Bur-1 ) ; end ;
11027: LD_EXP 12
11031: PPUSH
11032: LD_STRING DQrAccept#2-Bur-1
11034: PPUSH
11035: CALL_OW 88
11039: GO 11042
11041: POP
// end ; end ;
11042: GO 11045
11044: POP
// interface_hidden := false ;
11045: LD_ADDR_OWVAR 54
11049: PUSH
11050: LD_INT 0
11052: ST_TO_ADDR
// DialogueOff ;
11053: CALL_OW 7
// if answer = 2 then
11057: LD_VAR 0 1
11061: PUSH
11062: LD_INT 2
11064: EQUAL
11065: IFFALSE 11071
// Omar_Leave ;
11067: CALL 11123 0 0
// end ;
11071: PPOPN 1
11073: END
// function Omar_Arrive ; var un ; begin
11074: LD_INT 0
11076: PPUSH
11077: PPUSH
// PlaceUnitArea ( Omar , omar_place , false ) ;
11078: LD_EXP 51
11082: PPUSH
11083: LD_INT 4
11085: PPUSH
11086: LD_INT 0
11088: PPUSH
11089: CALL_OW 49
// repeat ComMoveToArea ( Omar , teleport_area ) ;
11093: LD_EXP 51
11097: PPUSH
11098: LD_INT 24
11100: PPUSH
11101: CALL_OW 113
// wait ( 0 0$1 ) ;
11105: LD_INT 35
11107: PPUSH
11108: CALL_OW 67
// until omar_in_contact ;
11112: LD_EXP 64
11116: IFFALSE 11093
// end ;
11118: LD_VAR 0 1
11122: RET
// function Omar_Leave ; begin
11123: LD_INT 0
11125: PPUSH
// repeat ComMoveToArea ( Omar , omar_place ) ;
11126: LD_EXP 51
11130: PPUSH
11131: LD_INT 4
11133: PPUSH
11134: CALL_OW 113
// wait ( 0 0$1 ) ;
11138: LD_INT 35
11140: PPUSH
11141: CALL_OW 67
// until IsInArea ( Omar , omar_place ) ;
11145: LD_EXP 51
11149: PPUSH
11150: LD_INT 4
11152: PPUSH
11153: CALL_OW 308
11157: IFFALSE 11126
// RemoveUnit ( Omar ) ;
11159: LD_EXP 51
11163: PPUSH
11164: CALL_OW 64
// end ;
11168: LD_VAR 0 1
11172: RET
// every 0 0$3.7 trigger OmarWillTryContaminateMotherlode and ( FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 or finalize = 2 ) do var best_sib , see_him ;
11173: LD_EXP 54
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_EXP 2
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PUSH
11190: LD_INT 2
11192: PUSH
11193: LD_INT 30
11195: PUSH
11196: LD_INT 0
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 30
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: PUSH
11227: LD_INT 0
11229: EQUAL
11230: PUSH
11231: LD_EXP 58
11235: PUSH
11236: LD_INT 2
11238: EQUAL
11239: OR
11240: AND
11241: IFFALSE 11391
11243: GO 11245
11245: DISABLE
11246: LD_INT 0
11248: PPUSH
11249: PPUSH
// begin sib_list := get_sib_list ;
11250: LD_ADDR_LOC 11
11254: PUSH
11255: CALL 11636 0 0
11259: ST_TO_ADDR
// SetClass ( Omar , class_scientistic ) ;
11260: LD_EXP 51
11264: PPUSH
11265: LD_INT 4
11267: PPUSH
11268: CALL_OW 336
// PlaceUnitArea ( Omar , omar_infested , false ) ;
11272: LD_EXP 51
11276: PPUSH
11277: LD_INT 5
11279: PPUSH
11280: LD_INT 0
11282: PPUSH
11283: CALL_OW 49
// see_him := false ;
11287: LD_ADDR_VAR 0 2
11291: PUSH
11292: LD_INT 0
11294: ST_TO_ADDR
// repeat best_sib := get_best_sib ( sib_list ) ;
11295: LD_ADDR_VAR 0 1
11299: PUSH
11300: LD_LOC 11
11304: PPUSH
11305: CALL 11776 0 1
11309: ST_TO_ADDR
// ComContaminate ( Omar , best_sib [ 1 ] , best_sib [ 2 ] ) ;
11310: LD_EXP 51
11314: PPUSH
11315: LD_VAR 0 1
11319: PUSH
11320: LD_INT 1
11322: ARRAY
11323: PPUSH
11324: LD_VAR 0 1
11328: PUSH
11329: LD_INT 2
11331: ARRAY
11332: PPUSH
11333: CALL_OW 158
// if ( not see_him ) and See ( you , Omar ) then
11337: LD_VAR 0 2
11341: NOT
11342: PUSH
11343: LD_EXP 1
11347: PPUSH
11348: LD_EXP 51
11352: PPUSH
11353: CALL_OW 292
11357: AND
11358: IFFALSE 11372
// begin talking_to_omar ;
11360: CALL 11394 0 0
// see_him := true ;
11364: LD_ADDR_VAR 0 2
11368: PUSH
11369: LD_INT 1
11371: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
11372: LD_INT 35
11374: PPUSH
11375: CALL_OW 67
// until not IsLive ( Omar ) ;
11379: LD_EXP 51
11383: PPUSH
11384: CALL_OW 300
11388: NOT
11389: IFFALSE 11295
// end ;
11391: PPOPN 2
11393: END
// function talking_to_omar ; begin
11394: LD_INT 0
11396: PPUSH
// CenterOnUnits ( Omar ) ;
11397: LD_EXP 51
11401: PPUSH
11402: CALL_OW 85
// DialogueOn ;
11406: CALL_OW 6
// interface_hidden := true ;
11410: LD_ADDR_OWVAR 54
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// case camp of 4 :
11418: LD_EXP 7
11422: PUSH
11423: LD_INT 4
11425: DOUBLE
11426: EQUAL
11427: IFTRUE 11431
11429: GO 11446
11431: POP
// Say ( MacMillan , DOmarContam-JMM-1 ) ; 6 :
11432: LD_EXP 13
11436: PPUSH
11437: LD_STRING DOmarContam-JMM-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11470
11446: LD_INT 6
11448: DOUBLE
11449: EQUAL
11450: IFTRUE 11454
11452: GO 11469
11454: POP
// Say ( Burlak , DOmarContam-Bur-1 ) ; end ;
11455: LD_EXP 12
11459: PPUSH
11460: LD_STRING DOmarContam-Bur-1
11462: PPUSH
11463: CALL_OW 88
11467: GO 11470
11469: POP
// Say ( Omar , DOmarContam-Omar-1 ) ;
11470: LD_EXP 51
11474: PPUSH
11475: LD_STRING DOmarContam-Omar-1
11477: PPUSH
11478: CALL_OW 88
// case camp of 4 :
11482: LD_EXP 7
11486: PUSH
11487: LD_INT 4
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11510
11495: POP
// Say ( MacMillan , DOmarContam-JMM-2 ) ; 6 :
11496: LD_EXP 13
11500: PPUSH
11501: LD_STRING DOmarContam-JMM-2
11503: PPUSH
11504: CALL_OW 88
11508: GO 11534
11510: LD_INT 6
11512: DOUBLE
11513: EQUAL
11514: IFTRUE 11518
11516: GO 11533
11518: POP
// Say ( Burlak , DOmarContam-Bur-2 ) ; end ;
11519: LD_EXP 12
11523: PPUSH
11524: LD_STRING DOmarContam-Bur-2
11526: PPUSH
11527: CALL_OW 88
11531: GO 11534
11533: POP
// interface_hidden := false ;
11534: LD_ADDR_OWVAR 54
11538: PUSH
11539: LD_INT 0
11541: ST_TO_ADDR
// DialogueOff ;
11542: CALL_OW 7
// end ;
11546: LD_VAR 0 1
11550: RET
// on SibDepositContaminated ( sib , x , y ) do var list , un ;
11551: LD_INT 0
11553: PPUSH
11554: PPUSH
// begin InGameOn ;
11555: CALL_OW 8
// CenterOnXY ( x , y ) ;
11559: LD_VAR 0 2
11563: PPUSH
11564: LD_VAR 0 3
11568: PPUSH
11569: CALL_OW 84
// PlaceSeeing ( x , y , you , - 10 ) ;
11573: LD_VAR 0 2
11577: PPUSH
11578: LD_VAR 0 3
11582: PPUSH
11583: LD_EXP 1
11587: PPUSH
11588: LD_INT 10
11590: NEG
11591: PPUSH
11592: CALL_OW 330
// wait ( 0 0$7 ) ;
11596: LD_INT 245
11598: PPUSH
11599: CALL_OW 67
// Mission_Failed ( 5 ) ;
11603: LD_INT 5
11605: PPUSH
11606: CALL 13860 0 1
// RemoveSeeing ( x , y , you ) ;
11610: LD_VAR 0 2
11614: PPUSH
11615: LD_VAR 0 3
11619: PPUSH
11620: LD_EXP 1
11624: PPUSH
11625: CALL_OW 331
// InGameOff ;
11629: CALL_OW 9
// end ;
11633: PPOPN 5
11635: END
// function get_sib_list ; var list , un , vysledek ; begin
11636: LD_INT 0
11638: PPUSH
11639: PPUSH
11640: PPUSH
11641: PPUSH
// vysledek := [ ] ;
11642: LD_ADDR_VAR 0 4
11646: PUSH
11647: EMPTY
11648: ST_TO_ADDR
// list := GetListOfResourcesInArea ( ru_base ) ;
11649: LD_ADDR_VAR 0 2
11653: PUSH
11654: LD_INT 12
11656: PPUSH
11657: CALL_OW 442
11661: ST_TO_ADDR
// for un = 1 to ( list div 3 ) do
11662: LD_ADDR_VAR 0 3
11666: PUSH
11667: DOUBLE
11668: LD_INT 1
11670: DEC
11671: ST_TO_ADDR
11672: LD_VAR 0 2
11676: PUSH
11677: LD_INT 3
11679: DIV
11680: PUSH
11681: FOR_TO
11682: IFFALSE 11759
// if list [ ( un * 3 ) ] = source_siberium then
11684: LD_VAR 0 2
11688: PUSH
11689: LD_VAR 0 3
11693: PUSH
11694: LD_INT 3
11696: MUL
11697: ARRAY
11698: PUSH
11699: LD_INT 2
11701: EQUAL
11702: IFFALSE 11757
// vysledek := vysledek ^ [ list [ ( un * 3 ) - 2 ] , list [ ( un * 3 ) - 1 ] ] ;
11704: LD_ADDR_VAR 0 4
11708: PUSH
11709: LD_VAR 0 4
11713: PUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_VAR 0 3
11723: PUSH
11724: LD_INT 3
11726: MUL
11727: PUSH
11728: LD_INT 2
11730: MINUS
11731: ARRAY
11732: PUSH
11733: LD_VAR 0 2
11737: PUSH
11738: LD_VAR 0 3
11742: PUSH
11743: LD_INT 3
11745: MUL
11746: PUSH
11747: LD_INT 1
11749: MINUS
11750: ARRAY
11751: PUSH
11752: EMPTY
11753: LIST
11754: LIST
11755: ADD
11756: ST_TO_ADDR
11757: GO 11681
11759: POP
11760: POP
// result := vysledek ;
11761: LD_ADDR_VAR 0 1
11765: PUSH
11766: LD_VAR 0 4
11770: ST_TO_ADDR
// end ;
11771: LD_VAR 0 1
11775: RET
// function get_best_sib ( sib_list ) ; var un , min , x , y , dist , vysledek , b ; begin
11776: LD_INT 0
11778: PPUSH
11779: PPUSH
11780: PPUSH
11781: PPUSH
11782: PPUSH
11783: PPUSH
11784: PPUSH
11785: PPUSH
// min := [ - 1 , - 1 , - 1 ] ;
11786: LD_ADDR_VAR 0 4
11790: PUSH
11791: LD_INT 1
11793: NEG
11794: PUSH
11795: LD_INT 1
11797: NEG
11798: PUSH
11799: LD_INT 1
11801: NEG
11802: PUSH
11803: EMPTY
11804: LIST
11805: LIST
11806: LIST
11807: ST_TO_ADDR
// for un = 1 to ( sib_list div 2 ) do
11808: LD_ADDR_VAR 0 3
11812: PUSH
11813: DOUBLE
11814: LD_INT 1
11816: DEC
11817: ST_TO_ADDR
11818: LD_VAR 0 1
11822: PUSH
11823: LD_INT 2
11825: DIV
11826: PUSH
11827: FOR_TO
11828: IFFALSE 12001
// begin x := sib_list [ ( un * 2 ) - 1 ] ;
11830: LD_ADDR_VAR 0 5
11834: PUSH
11835: LD_VAR 0 1
11839: PUSH
11840: LD_VAR 0 3
11844: PUSH
11845: LD_INT 2
11847: MUL
11848: PUSH
11849: LD_INT 1
11851: MINUS
11852: ARRAY
11853: ST_TO_ADDR
// y := sib_list [ ( un * 2 ) ] ;
11854: LD_ADDR_VAR 0 6
11858: PUSH
11859: LD_VAR 0 1
11863: PUSH
11864: LD_VAR 0 3
11868: PUSH
11869: LD_INT 2
11871: MUL
11872: ARRAY
11873: ST_TO_ADDR
// dist := GetDistUnitXY ( Omar , x , y ) ;
11874: LD_ADDR_VAR 0 7
11878: PUSH
11879: LD_EXP 51
11883: PPUSH
11884: LD_VAR 0 5
11888: PPUSH
11889: LD_VAR 0 6
11893: PPUSH
11894: CALL_OW 297
11898: ST_TO_ADDR
// b = HexInfo ( x , y ) ;
11899: LD_ADDR_VAR 0 9
11903: PUSH
11904: LD_VAR 0 5
11908: PPUSH
11909: LD_VAR 0 6
11913: PPUSH
11914: CALL_OW 428
11918: ST_TO_ADDR
// if ( ( min [ 3 ] < 0 ) or ( dist < min [ 3 ] ) ) and ( b = 0 or GetBType ( b ) = b_siberite_mine ) then
11919: LD_VAR 0 4
11923: PUSH
11924: LD_INT 3
11926: ARRAY
11927: PUSH
11928: LD_INT 0
11930: LESS
11931: PUSH
11932: LD_VAR 0 7
11936: PUSH
11937: LD_VAR 0 4
11941: PUSH
11942: LD_INT 3
11944: ARRAY
11945: LESS
11946: OR
11947: PUSH
11948: LD_VAR 0 9
11952: PUSH
11953: LD_INT 0
11955: EQUAL
11956: PUSH
11957: LD_VAR 0 9
11961: PPUSH
11962: CALL_OW 266
11966: PUSH
11967: LD_INT 30
11969: EQUAL
11970: OR
11971: AND
11972: IFFALSE 11999
// min := [ x , y , dist ] ;
11974: LD_ADDR_VAR 0 4
11978: PUSH
11979: LD_VAR 0 5
11983: PUSH
11984: LD_VAR 0 6
11988: PUSH
11989: LD_VAR 0 7
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: ST_TO_ADDR
// end ;
11999: GO 11827
12001: POP
12002: POP
// vysledek := [ min [ 1 ] , min [ 2 ] ] ;
12003: LD_ADDR_VAR 0 8
12007: PUSH
12008: LD_VAR 0 4
12012: PUSH
12013: LD_INT 1
12015: ARRAY
12016: PUSH
12017: LD_VAR 0 4
12021: PUSH
12022: LD_INT 2
12024: ARRAY
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: ST_TO_ADDR
// result := vysledek ;
12030: LD_ADDR_VAR 0 2
12034: PUSH
12035: LD_VAR 0 8
12039: ST_TO_ADDR
// end ; end_of_file
12040: LD_VAR 0 2
12044: RET
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibFiss then
12045: LD_VAR 0 1
12049: PUSH
12050: LD_INT 25
12052: EQUAL
12053: IFFALSE 12094
// case GetSide ( lab ) of 1 :
12055: LD_VAR 0 2
12059: PPUSH
12060: CALL_OW 255
12064: PUSH
12065: LD_INT 1
12067: DOUBLE
12068: EQUAL
12069: IFTRUE 12073
12071: GO 12079
12073: POP
// enable ( 4 ) ; 3 :
12074: LD_INT 4
12076: ENABLE_MARKED
12077: GO 12094
12079: LD_INT 3
12081: DOUBLE
12082: EQUAL
12083: IFTRUE 12087
12085: GO 12093
12087: POP
// enable ( 5 ) ; end ;
12088: LD_INT 5
12090: ENABLE_MARKED
12091: GO 12094
12093: POP
// wait ( 10 ) ;
12094: LD_INT 10
12096: PPUSH
12097: CALL_OW 67
// if not IsBusy ( lab ) then
12101: LD_VAR 0 2
12105: PPUSH
12106: CALL_OW 315
12110: NOT
12111: IFFALSE 12138
// begin labs_in_use := labs_in_use diff lab ;
12113: LD_ADDR_EXP 79
12117: PUSH
12118: LD_EXP 79
12122: PUSH
12123: LD_VAR 0 2
12127: DIFF
12128: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 40189 0 1
// end ; end ;
12138: PPOPN 2
12140: END
// on ResearchStarted ( tech , lab ) do var un , side ;
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin labs_in_use := labs_in_use ^ lab ;
12145: LD_ADDR_EXP 79
12149: PUSH
12150: LD_EXP 79
12154: PUSH
12155: LD_VAR 0 2
12159: ADD
12160: ST_TO_ADDR
// side := GetSide ( lab ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 2
12170: PPUSH
12171: CALL_OW 255
12175: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
12176: LD_ADDR_VAR 0 3
12180: PUSH
12181: DOUBLE
12182: LD_INT 0
12184: DEC
12185: ST_TO_ADDR
12186: LD_EXP 76
12190: PUSH
12191: LD_INT 1
12193: MINUS
12194: PUSH
12195: FOR_TO
12196: IFFALSE 12275
// if lab in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
12198: LD_VAR 0 2
12202: PUSH
12203: LD_VAR 0 3
12207: PUSH
12208: LD_INT 100
12210: MUL
12211: PUSH
12212: LD_INT 11
12214: PLUS
12215: PPUSH
12216: CALL_OW 110
12220: PUSH
12221: LD_VAR 0 3
12225: PUSH
12226: LD_INT 100
12228: MUL
12229: PUSH
12230: LD_VAR 0 4
12234: PUSH
12235: LD_INT 10
12237: MUL
12238: PLUS
12239: PUSH
12240: LD_INT 15
12242: PLUS
12243: PPUSH
12244: CALL_OW 110
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: IN
12253: IFFALSE 12273
// DeInit_Lab ( side , un + 1 ) ;
12255: LD_VAR 0 4
12259: PPUSH
12260: LD_VAR 0 3
12264: PUSH
12265: LD_INT 1
12267: PLUS
12268: PPUSH
12269: CALL 40050 0 2
12273: GO 12195
12275: POP
12276: POP
// end ;
12277: PPOPN 4
12279: END
// on ResearchCancel ( tech , lab ) do begin wait ( 10 ) ;
12280: LD_INT 10
12282: PPUSH
12283: CALL_OW 67
// if not IsBusy ( lab ) then
12287: LD_VAR 0 2
12291: PPUSH
12292: CALL_OW 315
12296: NOT
12297: IFFALSE 12324
// begin labs_in_use := labs_in_use diff lab ;
12299: LD_ADDR_EXP 79
12303: PUSH
12304: LD_EXP 79
12308: PUSH
12309: LD_VAR 0 2
12313: DIFF
12314: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12315: LD_VAR 0 2
12319: PPUSH
12320: CALL 40189 0 1
// end ; end ;
12324: PPOPN 2
12326: END
// on UnitDestroyed ( un ) do begin if un = MacMillan then
12327: LD_VAR 0 1
12331: PUSH
12332: LD_EXP 13
12336: EQUAL
12337: IFFALSE 12346
// Mission_failed ( 1 ) ;
12339: LD_INT 1
12341: PPUSH
12342: CALL 13860 0 1
// if un = Burlak then
12346: LD_VAR 0 1
12350: PUSH
12351: LD_EXP 12
12355: EQUAL
12356: IFFALSE 12365
// Mission_failed ( 2 ) ;
12358: LD_INT 2
12360: PPUSH
12361: CALL 13860 0 1
// Update_defend ( un ) ;
12365: LD_VAR 0 1
12369: PPUSH
12370: CALL 20784 0 1
// end ;
12374: PPOPN 1
12376: END
// on UnitGoesToRed ( un ) do begin if ( un = MacMillan ) and not Doctors_available ( MacMillan ) then
12377: LD_VAR 0 1
12381: PUSH
12382: LD_EXP 13
12386: EQUAL
12387: PUSH
12388: LD_EXP 13
12392: PPUSH
12393: CALL 12529 0 1
12397: NOT
12398: AND
12399: IFFALSE 12408
// Mission_failed ( 1 ) ;
12401: LD_INT 1
12403: PPUSH
12404: CALL 13860 0 1
// if ( un = Burlak ) and not Doctors_available ( Burlak ) then
12408: LD_VAR 0 1
12412: PUSH
12413: LD_EXP 12
12417: EQUAL
12418: PUSH
12419: LD_EXP 12
12423: PPUSH
12424: CALL 12529 0 1
12428: NOT
12429: AND
12430: IFFALSE 12439
// Mission_failed ( 2 ) ;
12432: LD_INT 2
12434: PPUSH
12435: CALL 13860 0 1
// if ( GetSide ( un ) = us ) and ( GetControl ( un ) = control_remote ) then
12439: LD_VAR 0 1
12443: PPUSH
12444: CALL_OW 255
12448: PUSH
12449: LD_EXP 3
12453: EQUAL
12454: PUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 263
12464: PUSH
12465: LD_INT 2
12467: EQUAL
12468: AND
12469: IFFALSE 12487
// begin ComUnlink ( un ) ;
12471: LD_VAR 0 1
12475: PPUSH
12476: CALL_OW 136
// check_remote ( 0 ) ;
12480: LD_INT 0
12482: PPUSH
12483: CALL 35303 0 1
// end ; if GetUnitMc ( un ) then
12487: LD_VAR 0 1
12491: PPUSH
12492: CALL_OW 388
12496: IFFALSE 12517
// RemoveMcUnits ( GetUnitMc ( un ) , un ) ;
12498: LD_VAR 0 1
12502: PPUSH
12503: CALL_OW 388
12507: PPUSH
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 391
// Update_defend ( un ) ;
12517: LD_VAR 0 1
12521: PPUSH
12522: CALL 20784 0 1
// end ;
12526: PPOPN 1
12528: END
// function Doctors_available ( geroj ) ; var list , un , vysledek ; begin
12529: LD_INT 0
12531: PPUSH
12532: PPUSH
12533: PPUSH
12534: PPUSH
// vysledek := false ;
12535: LD_ADDR_VAR 0 5
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12543: LD_ADDR_VAR 0 3
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_EXP 1
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 25
12562: PUSH
12563: LD_INT 4
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PPUSH
12574: CALL_OW 69
12578: ST_TO_ADDR
// if list then
12579: LD_VAR 0 3
12583: IFFALSE 12593
// vysledek := true ;
12585: LD_ADDR_VAR 0 5
12589: PUSH
12590: LD_INT 1
12592: ST_TO_ADDR
// if ( not vysledek ) and ( IsInArea ( geroj , ar_crates ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_lab ] ] ) ) then
12593: LD_VAR 0 5
12597: NOT
12598: PUSH
12599: LD_VAR 0 1
12603: PPUSH
12604: LD_INT 3
12606: PPUSH
12607: CALL_OW 308
12611: AND
12612: PUSH
12613: LD_INT 22
12615: PUSH
12616: LD_EXP 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 21
12627: PUSH
12628: LD_INT 1
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PPUSH
12639: CALL_OW 69
12643: AND
12644: PUSH
12645: LD_INT 22
12647: PUSH
12648: LD_EXP 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 30
12659: PUSH
12660: LD_INT 6
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PPUSH
12671: CALL_OW 69
12675: AND
12676: IFFALSE 12686
// vysledek := true ;
12678: LD_ADDR_VAR 0 5
12682: PUSH
12683: LD_INT 1
12685: ST_TO_ADDR
// result := vysledek ;
12686: LD_ADDR_VAR 0 2
12690: PUSH
12691: LD_VAR 0 5
12695: ST_TO_ADDR
// end ;
12696: LD_VAR 0 2
12700: RET
// on Contact ( side1 , side2 ) do begin if ( side1 in [ ar_al , you ] ) and ( side2 in [ ar_al , you ] ) then
12701: LD_VAR 0 1
12705: PUSH
12706: LD_EXP 5
12710: PUSH
12711: LD_EXP 1
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: IN
12720: PUSH
12721: LD_VAR 0 2
12725: PUSH
12726: LD_EXP 5
12730: PUSH
12731: LD_EXP 1
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: IN
12740: AND
12741: IFFALSE 12751
// omar_in_contact := true ;
12743: LD_ADDR_EXP 64
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// end ;
12751: PPOPN 2
12753: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
12754: LD_VAR 0 1
12758: PPUSH
12759: CALL_OW 141
// if ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay ] ) then
12763: LD_VAR 0 1
12767: PPUSH
12768: CALL_OW 247
12772: PUSH
12773: LD_INT 2
12775: EQUAL
12776: PUSH
12777: LD_VAR 0 1
12781: PPUSH
12782: CALL_OW 264
12786: PUSH
12787: LD_INT 12
12789: PUSH
12790: LD_INT 51
12792: PUSH
12793: LD_INT 32
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: LIST
12800: IN
12801: AND
12802: IFFALSE 12818
// remove_bad_crates ( GetSide ( un ) ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: CALL_OW 255
12813: PPUSH
12814: CALL 34610 0 1
// end ;
12818: PPOPN 1
12820: END
// on VehicleConstructed ( veh , fac ) do var side , list , tower ;
12821: LD_INT 0
12823: PPUSH
12824: PPUSH
12825: PPUSH
// begin side := GetSide ( fac ) ;
12826: LD_ADDR_VAR 0 3
12830: PUSH
12831: LD_VAR 0 2
12835: PPUSH
12836: CALL_OW 255
12840: ST_TO_ADDR
// case side of 1 :
12841: LD_VAR 0 3
12845: PUSH
12846: LD_INT 1
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12980
12854: POP
// begin check_remote ( veh ) ;
12855: LD_VAR 0 1
12859: PPUSH
12860: CALL 35303 0 1
// list := ready_forces [ side ] ^ veh ;
12864: LD_ADDR_VAR 0 4
12868: PUSH
12869: LD_EXP 65
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: PUSH
12880: LD_VAR 0 1
12884: ADD
12885: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , list ) ;
12886: LD_ADDR_EXP 65
12890: PUSH
12891: LD_EXP 65
12895: PPUSH
12896: LD_VAR 0 3
12900: PPUSH
12901: LD_VAR 0 4
12905: PPUSH
12906: CALL_OW 1
12910: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_control_tower ] ] ) ;
12911: LD_ADDR_VAR 0 5
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_VAR 0 3
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 30
12930: PUSH
12931: LD_INT 36
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PPUSH
12942: CALL_OW 69
12946: ST_TO_ADDR
// AddComMoveToArea ( veh , us_parking ) ;
12947: LD_VAR 0 1
12951: PPUSH
12952: LD_INT 22
12954: PPUSH
12955: CALL_OW 173
// if GetWeapon ( veh ) = us_siberium_rocket then
12959: LD_VAR 0 1
12963: PPUSH
12964: CALL_OW 264
12968: PUSH
12969: LD_INT 8
12971: EQUAL
12972: IFFALSE 12978
// US_Wins ;
12974: CALL 13141 0 0
// end ; 2 :
12978: GO 13138
12980: LD_INT 2
12982: DOUBLE
12983: EQUAL
12984: IFTRUE 12988
12986: GO 13003
12988: POP
// ComMoveToArea ( veh , ar_parking ) ; 3 :
12989: LD_VAR 0 1
12993: PPUSH
12994: LD_INT 23
12996: PPUSH
12997: CALL_OW 113
13001: GO 13138
13003: LD_INT 3
13005: DOUBLE
13006: EQUAL
13007: IFTRUE 13011
13009: GO 13137
13011: POP
// begin if GetWeapon ( veh ) = ru_siberium_rocket then
13012: LD_VAR 0 1
13016: PPUSH
13017: CALL_OW 264
13021: PUSH
13022: LD_INT 48
13024: EQUAL
13025: IFFALSE 13056
// begin if us in cpu_list then
13027: LD_EXP 3
13031: PUSH
13032: LD_EXP 8
13036: IN
13037: IFFALSE 13050
// send_sib_to_US ( veh ) else
13039: LD_VAR 0 1
13043: PPUSH
13044: CALL 36719 0 1
13048: GO 13054
// RU_Wins ;
13050: CALL 13331 0 0
// end else
13054: GO 13135
// begin list := ready_forces [ side ] ^ veh ;
13056: LD_ADDR_VAR 0 4
13060: PUSH
13061: LD_EXP 65
13065: PUSH
13066: LD_VAR 0 3
13070: ARRAY
13071: PUSH
13072: LD_VAR 0 1
13076: ADD
13077: ST_TO_ADDR
// ready_forces := Delete ( ready_forces , side ) ;
13078: LD_ADDR_EXP 65
13082: PUSH
13083: LD_EXP 65
13087: PPUSH
13088: LD_VAR 0 3
13092: PPUSH
13093: CALL_OW 3
13097: ST_TO_ADDR
// ready_forces := Insert ( ready_forces , side , list ) ;
13098: LD_ADDR_EXP 65
13102: PUSH
13103: LD_EXP 65
13107: PPUSH
13108: LD_VAR 0 3
13112: PPUSH
13113: LD_VAR 0 4
13117: PPUSH
13118: CALL_OW 2
13122: ST_TO_ADDR
// ComMoveToArea ( veh , ru_parking ) ;
13123: LD_VAR 0 1
13127: PPUSH
13128: LD_INT 21
13130: PPUSH
13131: CALL_OW 113
// end ; end ; end ;
13135: GO 13138
13137: POP
// end ; end_of_file
13138: PPOPN 5
13140: END
// export function US_Wins ; begin
13141: LD_INT 0
13143: PPUSH
// DialogueOn ;
13144: CALL_OW 6
// if camp = 6 then
13148: LD_EXP 7
13152: PUSH
13153: LD_INT 6
13155: EQUAL
13156: IFFALSE 13169
// CenterOnUnits ( Burlak ) else
13158: LD_EXP 12
13162: PPUSH
13163: CALL_OW 85
13167: GO 13178
// CenterOnUnits ( MacMillan ) ;
13169: LD_EXP 13
13173: PPUSH
13174: CALL_OW 85
// wait ( 0 0$1 ) ;
13178: LD_INT 35
13180: PPUSH
13181: CALL_OW 67
// interface_hidden := true ;
13185: LD_ADDR_OWVAR 54
13189: PUSH
13190: LD_INT 1
13192: ST_TO_ADDR
// Say ( Powell , DWinAmericans-Pow-1 ) ;
13193: LD_EXP 55
13197: PPUSH
13198: LD_STRING DWinAmericans-Pow-1
13200: PPUSH
13201: CALL_OW 88
// case camp of 4 :
13205: LD_EXP 7
13209: PUSH
13210: LD_INT 4
13212: DOUBLE
13213: EQUAL
13214: IFTRUE 13218
13216: GO 13258
13218: POP
// if IsOK ( MacMillan ) then
13219: LD_EXP 13
13223: PPUSH
13224: CALL_OW 302
13228: IFFALSE 13244
// Say ( MacMillan , DWinAmericans-JMM-1 ) else
13230: LD_EXP 13
13234: PPUSH
13235: LD_STRING DWinAmericans-JMM-1
13237: PPUSH
13238: CALL_OW 88
13242: GO 13256
// Say ( Burlak , DWinAmericans-Bur-1 ) ; 6 :
13244: LD_EXP 12
13248: PPUSH
13249: LD_STRING DWinAmericans-Bur-1
13251: PPUSH
13252: CALL_OW 88
13256: GO 13307
13258: LD_INT 6
13260: DOUBLE
13261: EQUAL
13262: IFTRUE 13266
13264: GO 13306
13266: POP
// if IsOK ( Burlak ) then
13267: LD_EXP 12
13271: PPUSH
13272: CALL_OW 302
13276: IFFALSE 13292
// Say ( Burlak , DWinAmericans-Bur-1 ) else
13278: LD_EXP 12
13282: PPUSH
13283: LD_STRING DWinAmericans-Bur-1
13285: PPUSH
13286: CALL_OW 88
13290: GO 13304
// Say ( MacMillan , DWinAmericans-JMM-1 ) ; end ;
13292: LD_EXP 13
13296: PPUSH
13297: LD_STRING DWinAmericans-JMM-1
13299: PPUSH
13300: CALL_OW 88
13304: GO 13307
13306: POP
// interface_hidden := false ;
13307: LD_ADDR_OWVAR 54
13311: PUSH
13312: LD_INT 0
13314: ST_TO_ADDR
// DialogueOff ;
13315: CALL_OW 7
// Mission_failed ( 3 ) ;
13319: LD_INT 3
13321: PPUSH
13322: CALL 13860 0 1
// end ;
13326: LD_VAR 0 1
13330: RET
// export function RU_Wins ; begin
13331: LD_INT 0
13333: PPUSH
// if camp = 6 then
13334: LD_EXP 7
13338: PUSH
13339: LD_INT 6
13341: EQUAL
13342: IFFALSE 13355
// CenterOnUnits ( Burlak ) else
13344: LD_EXP 12
13348: PPUSH
13349: CALL_OW 85
13353: GO 13364
// CenterOnUnits ( MacMillan ) ;
13355: LD_EXP 13
13359: PPUSH
13360: CALL_OW 85
// DialogueOn ;
13364: CALL_OW 6
// InGameOn ;
13368: CALL_OW 8
// wait ( 0 0$1 ) ;
13372: LD_INT 35
13374: PPUSH
13375: CALL_OW 67
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13379: LD_EXP 56
13383: PPUSH
13384: LD_STRING DWinRussians-Pla-1
13386: PPUSH
13387: CALL_OW 94
// case camp of 4 :
13391: LD_EXP 7
13395: PUSH
13396: LD_INT 4
13398: DOUBLE
13399: EQUAL
13400: IFTRUE 13404
13402: GO 13444
13404: POP
// if IsOK ( MacMillan ) then
13405: LD_EXP 13
13409: PPUSH
13410: CALL_OW 302
13414: IFFALSE 13430
// Say ( MacMillan , DWinRussians-JMM-1 ) else
13416: LD_EXP 13
13420: PPUSH
13421: LD_STRING DWinRussians-JMM-1
13423: PPUSH
13424: CALL_OW 88
13428: GO 13442
// Say ( Burlak , DWinRussians-Bur-1 ) ; 6 :
13430: LD_EXP 12
13434: PPUSH
13435: LD_STRING DWinRussians-Bur-1
13437: PPUSH
13438: CALL_OW 88
13442: GO 13493
13444: LD_INT 6
13446: DOUBLE
13447: EQUAL
13448: IFTRUE 13452
13450: GO 13492
13452: POP
// if IsOK ( Burlak ) then
13453: LD_EXP 12
13457: PPUSH
13458: CALL_OW 302
13462: IFFALSE 13478
// Say ( Burlak , DWinRussians-Bur-1 ) else
13464: LD_EXP 12
13468: PPUSH
13469: LD_STRING DWinRussians-Bur-1
13471: PPUSH
13472: CALL_OW 88
13476: GO 13490
// Say ( MacMillan , DWinRussians-JMM-1 ) ; end ;
13478: LD_EXP 13
13482: PPUSH
13483: LD_STRING DWinRussians-JMM-1
13485: PPUSH
13486: CALL_OW 88
13490: GO 13493
13492: POP
// DialogueOff ;
13493: CALL_OW 7
// InGameOff ;
13497: CALL_OW 9
// Mission_failed ( 4 ) ;
13501: LD_INT 4
13503: PPUSH
13504: CALL 13860 0 1
// end ;
13508: LD_VAR 0 1
13512: RET
// on SiberiteRocketExploded ( un , x , y ) do begin InGameOn ;
13513: CALL_OW 8
// siberite_rocket_send := true ;
13517: LD_ADDR_EXP 60
13521: PUSH
13522: LD_INT 1
13524: ST_TO_ADDR
// wait ( 0 0$7 ) ;
13525: LD_INT 245
13527: PPUSH
13528: CALL_OW 67
// RU_Wins ;
13532: CALL 13331 0 0
// end ; end_of_file
13536: PPOPN 3
13538: END
// every 0 0$1 trigger finalize = 2 and ( not OmarWillTryContaminateMotherlode or GetLives ( Omar ) = 0 ) do
13539: LD_EXP 58
13543: PUSH
13544: LD_INT 2
13546: EQUAL
13547: PUSH
13548: LD_EXP 54
13552: NOT
13553: PUSH
13554: LD_EXP 51
13558: PPUSH
13559: CALL_OW 256
13563: PUSH
13564: LD_INT 0
13566: EQUAL
13567: OR
13568: AND
13569: IFFALSE 13585
13571: GO 13573
13573: DISABLE
// begin wait ( 0 0$1 ) ;
13574: LD_INT 35
13576: PPUSH
13577: CALL_OW 67
// Konec_Mise ;
13581: CALL 13586 0 0
// end ;
13585: END
// function Konec_Mise ; var campaign_loading , campaign_lost , another_campaign , medal1 , medal2 , medal3 ; begin
13586: LD_INT 0
13588: PPUSH
13589: PPUSH
13590: PPUSH
13591: PPUSH
13592: PPUSH
13593: PPUSH
13594: PPUSH
// lets_talking ;
13595: CALL 16238 0 0
// another_campaign := true ;
13599: LD_ADDR_VAR 0 4
13603: PUSH
13604: LD_INT 1
13606: ST_TO_ADDR
// gained_medals := [ ] ;
13607: LD_ADDR_OWVAR 61
13611: PUSH
13612: EMPTY
13613: ST_TO_ADDR
// missing_medals := [ ] ;
13614: LD_ADDR_OWVAR 62
13618: PUSH
13619: EMPTY
13620: ST_TO_ADDR
// medal1 := true ;
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_INT 1
13628: ST_TO_ADDR
// medal2 := ( camp = 4 and IsOK ( Burlak ) ) or ( camp = 6 and IsOK ( MacMillan ) ) ;
13629: LD_ADDR_VAR 0 6
13633: PUSH
13634: LD_EXP 7
13638: PUSH
13639: LD_INT 4
13641: EQUAL
13642: PUSH
13643: LD_EXP 12
13647: PPUSH
13648: CALL_OW 302
13652: AND
13653: PUSH
13654: LD_EXP 7
13658: PUSH
13659: LD_INT 6
13661: EQUAL
13662: PUSH
13663: LD_EXP 13
13667: PPUSH
13668: CALL_OW 302
13672: AND
13673: OR
13674: ST_TO_ADDR
// medal3 := GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ;
13675: LD_ADDR_VAR 0 7
13679: PUSH
13680: LD_INT 81
13682: PPUSH
13683: CALL_OW 110
13687: PUSH
13688: LD_INT 181
13690: PPUSH
13691: CALL_OW 110
13695: AND
13696: PUSH
13697: LD_INT 281
13699: PPUSH
13700: CALL_OW 110
13704: AND
13705: ST_TO_ADDR
// AddMedal ( Hero , another_campaign ) ;
13706: LD_STRING Hero
13708: PPUSH
13709: LD_VAR 0 4
13713: PPUSH
13714: CALL_OW 101
// AddMedal ( Artefact , GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ) ;
13718: LD_STRING Artefact
13720: PPUSH
13721: LD_INT 81
13723: PPUSH
13724: CALL_OW 110
13728: PUSH
13729: LD_INT 181
13731: PPUSH
13732: CALL_OW 110
13736: AND
13737: PUSH
13738: LD_INT 281
13740: PPUSH
13741: CALL_OW 110
13745: AND
13746: PPUSH
13747: CALL_OW 101
// case camp of 4 :
13751: LD_EXP 7
13755: PUSH
13756: LD_INT 4
13758: DOUBLE
13759: EQUAL
13760: IFTRUE 13764
13762: GO 13784
13764: POP
// AddMedal ( ReconcileBurlak , IsOK ( Burlak ) ) ; 6 :
13765: LD_STRING ReconcileBurlak
13767: PPUSH
13768: LD_EXP 12
13772: PPUSH
13773: CALL_OW 302
13777: PPUSH
13778: CALL_OW 101
13782: GO 13813
13784: LD_INT 6
13786: DOUBLE
13787: EQUAL
13788: IFTRUE 13792
13790: GO 13812
13792: POP
// AddMedal ( ReconcileJMM , IsOK ( MacMillan ) ) ; end ;
13793: LD_STRING ReconcileJMM
13795: PPUSH
13796: LD_EXP 13
13800: PPUSH
13801: CALL_OW 302
13805: PPUSH
13806: CALL_OW 101
13810: GO 13813
13812: POP
// SA_OnMissionComplete ;
13813: CALL 42440 0 0
// SA_EndMission ( 4 , 4 , medal1 , medal2 , medal3 ) ;
13817: LD_INT 4
13819: PPUSH
13820: LD_INT 4
13822: PPUSH
13823: LD_VAR 0 5
13827: PPUSH
13828: LD_VAR 0 6
13832: PPUSH
13833: LD_VAR 0 7
13837: PPUSH
13838: CALL 42455 0 5
// GiveMedals ( Main ) ;
13842: LD_STRING Main
13844: PPUSH
13845: CALL_OW 102
// YouWin ;
13849: CALL_OW 103
// exit ;
13853: GO 13855
// end ;
13855: LD_VAR 0 1
13859: RET
// export function Mission_Failed ( how ) ; begin
13860: LD_INT 0
13862: PPUSH
// case how of 1 :
13863: LD_VAR 0 1
13867: PUSH
13868: LD_INT 1
13870: DOUBLE
13871: EQUAL
13872: IFTRUE 13876
13874: GO 13886
13876: POP
// YouLost ( JMM ) ; 2 :
13877: LD_STRING JMM
13879: PPUSH
13880: CALL_OW 104
13884: GO 13959
13886: LD_INT 2
13888: DOUBLE
13889: EQUAL
13890: IFTRUE 13894
13892: GO 13904
13894: POP
// YouLost ( Burlak ) ; 3 :
13895: LD_STRING Burlak
13897: PPUSH
13898: CALL_OW 104
13902: GO 13959
13904: LD_INT 3
13906: DOUBLE
13907: EQUAL
13908: IFTRUE 13912
13910: GO 13922
13912: POP
// YouLost ( AmBomb ) ; 4 :
13913: LD_STRING AmBomb
13915: PPUSH
13916: CALL_OW 104
13920: GO 13959
13922: LD_INT 4
13924: DOUBLE
13925: EQUAL
13926: IFTRUE 13930
13928: GO 13940
13930: POP
// YouLost ( RuBomb ) ; 5 :
13931: LD_STRING RuBomb
13933: PPUSH
13934: CALL_OW 104
13938: GO 13959
13940: LD_INT 5
13942: DOUBLE
13943: EQUAL
13944: IFTRUE 13948
13946: GO 13958
13948: POP
// YouLost ( MothContaminate ) ; end ;
13949: LD_STRING MothContaminate
13951: PPUSH
13952: CALL_OW 104
13956: GO 13959
13958: POP
// end ; end_of_file
13959: LD_VAR 0 2
13963: RET
// function Base_Destroyed ( side ) ; var un , list , vysledek ; begin
13964: LD_INT 0
13966: PPUSH
13967: PPUSH
13968: PPUSH
13969: PPUSH
// vysledek := false ;
13970: LD_ADDR_VAR 0 5
13974: PUSH
13975: LD_INT 0
13977: ST_TO_ADDR
// if not ( FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] ] ) or FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ) then
13978: LD_INT 22
13980: PUSH
13981: LD_VAR 0 1
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PUSH
13990: LD_INT 2
13992: PUSH
13993: LD_INT 30
13995: PUSH
13996: LD_INT 0
13998: PUSH
13999: EMPTY
14000: LIST
14001: LIST
14002: PUSH
14003: LD_INT 30
14005: PUSH
14006: LD_INT 1
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 50
14020: PUSH
14021: EMPTY
14022: LIST
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: LIST
14028: PPUSH
14029: CALL_OW 69
14033: PUSH
14034: LD_INT 22
14036: PUSH
14037: LD_VAR 0 1
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: LD_INT 25
14048: PUSH
14049: LD_INT 2
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: PUSH
14056: LD_INT 50
14058: PUSH
14059: EMPTY
14060: LIST
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: PPUSH
14067: CALL_OW 69
14071: OR
14072: NOT
14073: IFFALSE 14083
// vysledek := true ;
14075: LD_ADDR_VAR 0 5
14079: PUSH
14080: LD_INT 1
14082: ST_TO_ADDR
// if not vysledek then
14083: LD_VAR 0 5
14087: NOT
14088: IFFALSE 14151
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14090: LD_ADDR_VAR 0 4
14094: PUSH
14095: LD_INT 22
14097: PUSH
14098: LD_VAR 0 1
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 21
14109: PUSH
14110: LD_INT 1
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 50
14119: PUSH
14120: EMPTY
14121: LIST
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: LIST
14127: PPUSH
14128: CALL_OW 69
14132: ST_TO_ADDR
// if list < 3 then
14133: LD_VAR 0 4
14137: PUSH
14138: LD_INT 3
14140: LESS
14141: IFFALSE 14151
// vysledek := true ;
14143: LD_ADDR_VAR 0 5
14147: PUSH
14148: LD_INT 1
14150: ST_TO_ADDR
// end ; if not vysledek then
14151: LD_VAR 0 5
14155: NOT
14156: IFFALSE 14286
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_ok ] ] ) ;
14158: LD_ADDR_VAR 0 4
14162: PUSH
14163: LD_INT 22
14165: PUSH
14166: LD_VAR 0 1
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PUSH
14175: LD_INT 2
14177: PUSH
14178: LD_INT 30
14180: PUSH
14181: LD_INT 32
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_INT 30
14190: PUSH
14191: LD_INT 33
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: LIST
14202: PUSH
14203: LD_INT 50
14205: PUSH
14206: EMPTY
14207: LIST
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: LIST
14213: PPUSH
14214: CALL_OW 69
14218: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
14219: LD_ADDR_VAR 0 3
14223: PUSH
14224: LD_INT 22
14226: PUSH
14227: LD_VAR 0 1
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 21
14238: PUSH
14239: LD_INT 2
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: PUSH
14246: LD_INT 50
14248: PUSH
14249: EMPTY
14250: LIST
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL_OW 69
14261: ST_TO_ADDR
// if ( un + list ) < 5 then
14262: LD_VAR 0 3
14266: PUSH
14267: LD_VAR 0 4
14271: PLUS
14272: PUSH
14273: LD_INT 5
14275: LESS
14276: IFFALSE 14286
// vysledek := true ;
14278: LD_ADDR_VAR 0 5
14282: PUSH
14283: LD_INT 1
14285: ST_TO_ADDR
// end ; if not vysledek then
14286: LD_VAR 0 5
14290: NOT
14291: IFFALSE 14380
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] , [ f_ok ] ] ) ;
14293: LD_ADDR_VAR 0 4
14297: PUSH
14298: LD_INT 22
14300: PUSH
14301: LD_VAR 0 1
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: PUSH
14310: LD_INT 2
14312: PUSH
14313: LD_INT 30
14315: PUSH
14316: LD_INT 27
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: PUSH
14323: LD_INT 30
14325: PUSH
14326: LD_INT 26
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 30
14335: PUSH
14336: LD_INT 28
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: EMPTY
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: PUSH
14349: LD_INT 50
14351: PUSH
14352: EMPTY
14353: LIST
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: LIST
14359: PPUSH
14360: CALL_OW 69
14364: ST_TO_ADDR
// if not list then
14365: LD_VAR 0 4
14369: NOT
14370: IFFALSE 14380
// vysledek := 0 ;
14372: LD_ADDR_VAR 0 5
14376: PUSH
14377: LD_INT 0
14379: ST_TO_ADDR
// end ; result := vysledek ;
14380: LD_ADDR_VAR 0 2
14384: PUSH
14385: LD_VAR 0 5
14389: ST_TO_ADDR
// end ;
14390: LD_VAR 0 2
14394: RET
// every 0 0$2.1 trigger Base_Destroyed ( us ) and not siberite_rocket_send do var sol , un , list ;
14395: LD_EXP 3
14399: PPUSH
14400: CALL 13964 0 1
14404: PUSH
14405: LD_EXP 60
14409: NOT
14410: AND
14411: IFFALSE 14978
14413: GO 14415
14415: DISABLE
14416: LD_INT 0
14418: PPUSH
14419: PPUSH
14420: PPUSH
// begin if IsOK ( Powell ) then
14421: LD_EXP 55
14425: PPUSH
14426: CALL_OW 302
14430: IFFALSE 14508
// begin CenterOnUnits ( Powell ) ;
14432: LD_EXP 55
14436: PPUSH
14437: CALL_OW 85
// DialogueOn ;
14441: CALL_OW 6
// interface_hidden := true ;
14445: LD_ADDR_OWVAR 54
14449: PUSH
14450: LD_INT 1
14452: ST_TO_ADDR
// Say ( Powell , DSurrenderAmericans-Pow-1 ) ;
14453: LD_EXP 55
14457: PPUSH
14458: LD_STRING DSurrenderAmericans-Pow-1
14460: PPUSH
14461: CALL_OW 88
// Say ( MacMillan , DSurrenderAmericans-JMM-1 ) ;
14465: LD_EXP 13
14469: PPUSH
14470: LD_STRING DSurrenderAmericans-JMM-1
14472: PPUSH
14473: CALL_OW 88
// interface_hidden := false ;
14477: LD_ADDR_OWVAR 54
14481: PUSH
14482: LD_INT 0
14484: ST_TO_ADDR
// DialogueOff ;
14485: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
14489: LD_INT 35
14491: PPUSH
14492: CALL_OW 67
// until not IsOK ( Powell ) ;
14496: LD_EXP 55
14500: PPUSH
14501: CALL_OW 302
14505: NOT
14506: IFFALSE 14489
// end ; cpu_list := cpu_list diff us ;
14508: LD_ADDR_EXP 8
14512: PUSH
14513: LD_EXP 8
14517: PUSH
14518: LD_EXP 3
14522: DIFF
14523: ST_TO_ADDR
// SetAttitude ( you , us , att_friend , true ) ;
14524: LD_EXP 1
14528: PPUSH
14529: LD_EXP 3
14533: PPUSH
14534: LD_INT 1
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 80
// sol := FindLastMohycane ( us ) ;
14544: LD_ADDR_VAR 0 1
14548: PUSH
14549: LD_EXP 3
14553: PPUSH
14554: CALL 15854 0 1
14558: ST_TO_ADDR
// if IsOK ( sol ) then
14559: LD_VAR 0 1
14563: PPUSH
14564: CALL_OW 302
14568: IFFALSE 14579
// ComExitBuilding ( sol ) ;
14570: LD_VAR 0 1
14574: PPUSH
14575: CALL_OW 122
// while not See ( you , sol ) do
14579: LD_EXP 1
14583: PPUSH
14584: LD_VAR 0 1
14588: PPUSH
14589: CALL_OW 292
14593: NOT
14594: IFFALSE 14661
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
14596: LD_ADDR_VAR 0 2
14600: PUSH
14601: LD_INT 22
14603: PUSH
14604: LD_EXP 1
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: LD_INT 50
14615: PUSH
14616: EMPTY
14617: LIST
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PPUSH
14623: CALL_OW 69
14627: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
14628: LD_VAR 0 1
14632: PPUSH
14633: LD_VAR 0 2
14637: PPUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 74
14647: PPUSH
14648: CALL_OW 112
// wait ( 0 0$1 ) ;
14652: LD_INT 35
14654: PPUSH
14655: CALL_OW 67
// end ;
14659: GO 14579
// CenterOnUnits ( sol ) ;
14661: LD_VAR 0 1
14665: PPUSH
14666: CALL_OW 85
// DialogueOn ;
14670: CALL_OW 6
// interface_hidden := true ;
14674: LD_ADDR_OWVAR 54
14678: PUSH
14679: LD_INT 1
14681: ST_TO_ADDR
// case camp of 4 :
14682: LD_EXP 7
14686: PUSH
14687: LD_INT 4
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14710
14695: POP
// Say ( sol , DSurrenderAmericans-Sol1-1a ) ; 6 :
14696: LD_VAR 0 1
14700: PPUSH
14701: LD_STRING DSurrenderAmericans-Sol1-1a
14703: PPUSH
14704: CALL_OW 88
14708: GO 14734
14710: LD_INT 6
14712: DOUBLE
14713: EQUAL
14714: IFTRUE 14718
14716: GO 14733
14718: POP
// Say ( sol , DSurrenderAmericans-Sol1-1 ) ; end ;
14719: LD_VAR 0 1
14723: PPUSH
14724: LD_STRING DSurrenderAmericans-Sol1-1
14726: PPUSH
14727: CALL_OW 88
14731: GO 14734
14733: POP
// interface_hidden := false ;
14734: LD_ADDR_OWVAR 54
14738: PUSH
14739: LD_INT 0
14741: ST_TO_ADDR
// DialogueOff ;
14742: CALL_OW 7
// finalize := finalize + 1 ;
14746: LD_ADDR_EXP 58
14750: PUSH
14751: LD_EXP 58
14755: PUSH
14756: LD_INT 1
14758: PLUS
14759: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , us ] , f_not , [ f_type , unit_human ] ] ) ;
14760: LD_ADDR_VAR 0 3
14764: PUSH
14765: LD_INT 22
14767: PUSH
14768: LD_EXP 3
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 3
14779: PUSH
14780: LD_INT 21
14782: PUSH
14783: LD_INT 1
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: PUSH
14790: EMPTY
14791: LIST
14792: LIST
14793: LIST
14794: PPUSH
14795: CALL_OW 69
14799: ST_TO_ADDR
// SetSide ( list , you ) ;
14800: LD_VAR 0 3
14804: PPUSH
14805: LD_EXP 1
14809: PPUSH
14810: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
14814: LD_VAR 0 3
14818: PPUSH
14819: LD_INT 21
14821: PUSH
14822: LD_INT 2
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 72
14833: PPUSH
14834: CALL 14981 0 1
// repeat list := FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14838: LD_ADDR_VAR 0 3
14842: PUSH
14843: LD_INT 22
14845: PUSH
14846: LD_EXP 3
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PUSH
14855: LD_INT 21
14857: PUSH
14858: LD_INT 1
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PUSH
14865: LD_INT 50
14867: PUSH
14868: EMPTY
14869: LIST
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 69
14880: ST_TO_ADDR
// ComMoveToArea ( list , am_leaving_area ) ;
14881: LD_VAR 0 3
14885: PPUSH
14886: LD_INT 30
14888: PPUSH
14889: CALL_OW 113
// if list then
14893: LD_VAR 0 3
14897: IFFALSE 14906
// wait ( 0 0$2 ) ;
14899: LD_INT 70
14901: PPUSH
14902: CALL_OW 67
// sol := FilterUnitsInArea ( am_leaving_area , [ [ f_side , us ] , [ f_type , unit_human ] ] ) ;
14906: LD_ADDR_VAR 0 1
14910: PUSH
14911: LD_INT 30
14913: PPUSH
14914: LD_INT 22
14916: PUSH
14917: LD_EXP 3
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: PUSH
14926: LD_INT 21
14928: PUSH
14929: LD_INT 1
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: PPUSH
14940: CALL_OW 70
14944: ST_TO_ADDR
// for un in sol do
14945: LD_ADDR_VAR 0 2
14949: PUSH
14950: LD_VAR 0 1
14954: PUSH
14955: FOR_IN
14956: IFFALSE 14969
// RemoveUnit ( un ) ;
14958: LD_VAR 0 2
14962: PPUSH
14963: CALL_OW 64
14967: GO 14955
14969: POP
14970: POP
// until not list ;
14971: LD_VAR 0 3
14975: NOT
14976: IFFALSE 14838
// end ;
14978: PPOPN 3
14980: END
// function DestroyAndReplaceVehicles ( list ) ; var i , x , y , driver , veh ; begin
14981: LD_INT 0
14983: PPUSH
14984: PPUSH
14985: PPUSH
14986: PPUSH
14987: PPUSH
14988: PPUSH
// for i in list do
14989: LD_ADDR_VAR 0 3
14993: PUSH
14994: LD_VAR 0 1
14998: PUSH
14999: FOR_IN
15000: IFFALSE 15261
// begin InitUc ;
15002: CALL_OW 18
// InitVc ;
15006: CALL_OW 20
// uc_nation = GetNation ( i ) ;
15010: LD_ADDR_OWVAR 21
15014: PUSH
15015: LD_VAR 0 3
15019: PPUSH
15020: CALL_OW 248
15024: ST_TO_ADDR
// uc_side = GetSide ( i ) ;
15025: LD_ADDR_OWVAR 20
15029: PUSH
15030: LD_VAR 0 3
15034: PPUSH
15035: CALL_OW 255
15039: ST_TO_ADDR
// uc_direction = GetDir ( i ) ;
15040: LD_ADDR_OWVAR 24
15044: PUSH
15045: LD_VAR 0 3
15049: PPUSH
15050: CALL_OW 254
15054: ST_TO_ADDR
// vc_chassis = GetChassis ( i ) ;
15055: LD_ADDR_OWVAR 37
15059: PUSH
15060: LD_VAR 0 3
15064: PPUSH
15065: CALL_OW 265
15069: ST_TO_ADDR
// vc_engine = GetEngine ( i ) ;
15070: LD_ADDR_OWVAR 39
15074: PUSH
15075: LD_VAR 0 3
15079: PPUSH
15080: CALL_OW 262
15084: ST_TO_ADDR
// vc_weapon = GetWeapon ( i ) ;
15085: LD_ADDR_OWVAR 40
15089: PUSH
15090: LD_VAR 0 3
15094: PPUSH
15095: CALL_OW 264
15099: ST_TO_ADDR
// vc_control = GetControl ( i ) ;
15100: LD_ADDR_OWVAR 38
15104: PUSH
15105: LD_VAR 0 3
15109: PPUSH
15110: CALL_OW 263
15114: ST_TO_ADDR
// vc_fuel_battery = GetFuel ( i ) ;
15115: LD_ADDR_OWVAR 41
15119: PUSH
15120: LD_VAR 0 3
15124: PPUSH
15125: CALL_OW 261
15129: ST_TO_ADDR
// x = GetX ( i ) ;
15130: LD_ADDR_VAR 0 4
15134: PUSH
15135: LD_VAR 0 3
15139: PPUSH
15140: CALL_OW 250
15144: ST_TO_ADDR
// y = GetY ( i ) ;
15145: LD_ADDR_VAR 0 5
15149: PUSH
15150: LD_VAR 0 3
15154: PPUSH
15155: CALL_OW 251
15159: ST_TO_ADDR
// driver = IsDrivenBy ( i ) ;
15160: LD_ADDR_VAR 0 6
15164: PUSH
15165: LD_VAR 0 3
15169: PPUSH
15170: CALL_OW 311
15174: ST_TO_ADDR
// if driver > 0 then
15175: LD_VAR 0 6
15179: PUSH
15180: LD_INT 0
15182: GREATER
15183: IFFALSE 15194
// RemoveUnit ( driver ) ;
15185: LD_VAR 0 6
15189: PPUSH
15190: CALL_OW 64
// DestroyUnit ( i ) ;
15194: LD_VAR 0 3
15198: PPUSH
15199: CALL_OW 65
// veh = CreateVehicle ;
15203: LD_ADDR_VAR 0 7
15207: PUSH
15208: CALL_OW 45
15212: ST_TO_ADDR
// PlaceUnitXY ( veh , x , y , false ) ;
15213: LD_VAR 0 7
15217: PPUSH
15218: LD_VAR 0 4
15222: PPUSH
15223: LD_VAR 0 5
15227: PPUSH
15228: LD_INT 0
15230: PPUSH
15231: CALL_OW 48
// if driver > 0 then
15235: LD_VAR 0 6
15239: PUSH
15240: LD_INT 0
15242: GREATER
15243: IFFALSE 15259
// PlaceHumanInUnit ( driver , veh ) ;
15245: LD_VAR 0 6
15249: PPUSH
15250: LD_VAR 0 7
15254: PPUSH
15255: CALL_OW 52
// end ;
15259: GO 14999
15261: POP
15262: POP
// end ;
15263: LD_VAR 0 2
15267: RET
// every 0 0$2.3 trigger Base_Destroyed ( ru ) and not siberite_rocket_send do var list , sol , un ;
15268: LD_EXP 2
15272: PPUSH
15273: CALL 13964 0 1
15277: PUSH
15278: LD_EXP 60
15282: NOT
15283: AND
15284: IFFALSE 15851
15286: GO 15288
15288: DISABLE
15289: LD_INT 0
15291: PPUSH
15292: PPUSH
15293: PPUSH
// begin if IsOK ( Platonov ) then
15294: LD_EXP 56
15298: PPUSH
15299: CALL_OW 302
15303: IFFALSE 15381
// begin CenterOnUnits ( Platonov ) ;
15305: LD_EXP 56
15309: PPUSH
15310: CALL_OW 85
// DialogueOn ;
15314: CALL_OW 6
// interface_hidden := true ;
15318: LD_ADDR_OWVAR 54
15322: PUSH
15323: LD_INT 1
15325: ST_TO_ADDR
// Say ( Platonov , DSurrenderRussians-Pla-1 ) ;
15326: LD_EXP 56
15330: PPUSH
15331: LD_STRING DSurrenderRussians-Pla-1
15333: PPUSH
15334: CALL_OW 88
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15338: LD_EXP 12
15342: PPUSH
15343: LD_STRING DSurrenderRussians-Bur-1
15345: PPUSH
15346: CALL_OW 88
// interface_hidden := false ;
15350: LD_ADDR_OWVAR 54
15354: PUSH
15355: LD_INT 0
15357: ST_TO_ADDR
// DialogueOff ;
15358: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 67
// until not IsOK ( Platonov ) ;
15369: LD_EXP 56
15373: PPUSH
15374: CALL_OW 302
15378: NOT
15379: IFFALSE 15362
// end ; cpu_list := cpu_list diff ru ;
15381: LD_ADDR_EXP 8
15385: PUSH
15386: LD_EXP 8
15390: PUSH
15391: LD_EXP 2
15395: DIFF
15396: ST_TO_ADDR
// SetAttitude ( you , ru , att_friend , true ) ;
15397: LD_EXP 1
15401: PPUSH
15402: LD_EXP 2
15406: PPUSH
15407: LD_INT 1
15409: PPUSH
15410: LD_INT 1
15412: PPUSH
15413: CALL_OW 80
// sol := FindLastMohycane ( ru ) ;
15417: LD_ADDR_VAR 0 2
15421: PUSH
15422: LD_EXP 2
15426: PPUSH
15427: CALL 15854 0 1
15431: ST_TO_ADDR
// if IsOK ( sol ) then
15432: LD_VAR 0 2
15436: PPUSH
15437: CALL_OW 302
15441: IFFALSE 15452
// ComExitBuilding ( sol ) ;
15443: LD_VAR 0 2
15447: PPUSH
15448: CALL_OW 122
// while not See ( you , sol ) do
15452: LD_EXP 1
15456: PPUSH
15457: LD_VAR 0 2
15461: PPUSH
15462: CALL_OW 292
15466: NOT
15467: IFFALSE 15534
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
15469: LD_ADDR_VAR 0 3
15473: PUSH
15474: LD_INT 22
15476: PUSH
15477: LD_EXP 1
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 50
15488: PUSH
15489: EMPTY
15490: LIST
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PPUSH
15496: CALL_OW 69
15500: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
15501: LD_VAR 0 2
15505: PPUSH
15506: LD_VAR 0 3
15510: PPUSH
15511: LD_VAR 0 2
15515: PPUSH
15516: CALL_OW 74
15520: PPUSH
15521: CALL_OW 112
// wait ( 0 0$1 ) ;
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 67
// end ;
15532: GO 15452
// CenterOnUnits ( sol ) ;
15534: LD_VAR 0 2
15538: PPUSH
15539: CALL_OW 85
// DialogueOn ;
15543: CALL_OW 6
// interface_hidden := true ;
15547: LD_ADDR_OWVAR 54
15551: PUSH
15552: LD_INT 1
15554: ST_TO_ADDR
// case camp of 4 :
15555: LD_EXP 7
15559: PUSH
15560: LD_INT 4
15562: DOUBLE
15563: EQUAL
15564: IFTRUE 15568
15566: GO 15583
15568: POP
// Say ( sol , DSurrenderRussians-Rsol1-1a ) ; 6 :
15569: LD_VAR 0 2
15573: PPUSH
15574: LD_STRING DSurrenderRussians-Rsol1-1a
15576: PPUSH
15577: CALL_OW 88
15581: GO 15607
15583: LD_INT 6
15585: DOUBLE
15586: EQUAL
15587: IFTRUE 15591
15589: GO 15606
15591: POP
// Say ( sol , DSurrenderRussians-Rsol1-1 ) ; end ;
15592: LD_VAR 0 2
15596: PPUSH
15597: LD_STRING DSurrenderRussians-Rsol1-1
15599: PPUSH
15600: CALL_OW 88
15604: GO 15607
15606: POP
// interface_hidden := false ;
15607: LD_ADDR_OWVAR 54
15611: PUSH
15612: LD_INT 0
15614: ST_TO_ADDR
// DialogueOff ;
15615: CALL_OW 7
// finalize := finalize + 1 ;
15619: LD_ADDR_EXP 58
15623: PUSH
15624: LD_EXP 58
15628: PUSH
15629: LD_INT 1
15631: PLUS
15632: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , ru ] , f_not , [ f_type , unit_human ] ] ) ;
15633: LD_ADDR_VAR 0 1
15637: PUSH
15638: LD_INT 22
15640: PUSH
15641: LD_EXP 2
15645: PUSH
15646: EMPTY
15647: LIST
15648: LIST
15649: PUSH
15650: LD_INT 3
15652: PUSH
15653: LD_INT 21
15655: PUSH
15656: LD_INT 1
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: LIST
15667: PPUSH
15668: CALL_OW 69
15672: ST_TO_ADDR
// SetSide ( list , you ) ;
15673: LD_VAR 0 1
15677: PPUSH
15678: LD_EXP 1
15682: PPUSH
15683: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15687: LD_VAR 0 1
15691: PPUSH
15692: LD_INT 21
15694: PUSH
15695: LD_INT 2
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PPUSH
15702: CALL_OW 72
15706: PPUSH
15707: CALL 14981 0 1
// repeat list := FilterAllUnits ( [ [ f_side , ru ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
15711: LD_ADDR_VAR 0 1
15715: PUSH
15716: LD_INT 22
15718: PUSH
15719: LD_EXP 2
15723: PUSH
15724: EMPTY
15725: LIST
15726: LIST
15727: PUSH
15728: LD_INT 21
15730: PUSH
15731: LD_INT 1
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: PUSH
15738: LD_INT 50
15740: PUSH
15741: EMPTY
15742: LIST
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: PPUSH
15749: CALL_OW 69
15753: ST_TO_ADDR
// ComMoveToArea ( list , ru_leaving_area ) ;
15754: LD_VAR 0 1
15758: PPUSH
15759: LD_INT 31
15761: PPUSH
15762: CALL_OW 113
// if list then
15766: LD_VAR 0 1
15770: IFFALSE 15779
// wait ( 0 0$2 ) ;
15772: LD_INT 70
15774: PPUSH
15775: CALL_OW 67
// sol := FilterUnitsInArea ( ru_leaving_area , [ [ f_side , ru ] , [ f_type , unit_human ] ] ) ;
15779: LD_ADDR_VAR 0 2
15783: PUSH
15784: LD_INT 31
15786: PPUSH
15787: LD_INT 22
15789: PUSH
15790: LD_EXP 2
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: PUSH
15799: LD_INT 21
15801: PUSH
15802: LD_INT 1
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PPUSH
15813: CALL_OW 70
15817: ST_TO_ADDR
// for un in sol do
15818: LD_ADDR_VAR 0 3
15822: PUSH
15823: LD_VAR 0 2
15827: PUSH
15828: FOR_IN
15829: IFFALSE 15842
// RemoveUnit ( un ) ;
15831: LD_VAR 0 3
15835: PPUSH
15836: CALL_OW 64
15840: GO 15828
15842: POP
15843: POP
// until not list ;
15844: LD_VAR 0 1
15848: NOT
15849: IFFALSE 15711
// end ;
15851: PPOPN 3
15853: END
// function FindLastMohycane ( side ) ; var area , un , list , build , unseen , vysledek ; begin
15854: LD_INT 0
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
15860: PPUSH
15861: PPUSH
15862: PPUSH
// case side of us :
15863: LD_VAR 0 1
15867: PUSH
15868: LD_EXP 3
15872: DOUBLE
15873: EQUAL
15874: IFTRUE 15878
15876: GO 15889
15878: POP
// area := us_base ; ru :
15879: LD_ADDR_VAR 0 3
15883: PUSH
15884: LD_INT 11
15886: ST_TO_ADDR
15887: GO 15911
15889: LD_EXP 2
15893: DOUBLE
15894: EQUAL
15895: IFTRUE 15899
15897: GO 15910
15899: POP
// area := ru_base ; end ;
15900: LD_ADDR_VAR 0 3
15904: PUSH
15905: LD_INT 12
15907: ST_TO_ADDR
15908: GO 15911
15910: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_INT 22
15918: PUSH
15919: LD_VAR 0 1
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PUSH
15928: LD_INT 21
15930: PUSH
15931: LD_INT 1
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PUSH
15938: LD_INT 26
15940: PUSH
15941: LD_INT 1
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: LD_INT 50
15950: PUSH
15951: EMPTY
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: LIST
15958: LIST
15959: PPUSH
15960: CALL_OW 69
15964: PUSH
15965: LD_INT 22
15967: PUSH
15968: LD_VAR 0 1
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PUSH
15977: LD_INT 2
15979: PUSH
15980: LD_INT 25
15982: PUSH
15983: LD_INT 12
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: LD_INT 25
15992: PUSH
15993: LD_INT 15
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: PUSH
16000: LD_INT 25
16002: PUSH
16003: LD_INT 16
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PUSH
16010: LD_INT 25
16012: PUSH
16013: LD_INT 17
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PPUSH
16031: CALL_OW 69
16035: DIFF
16036: ST_TO_ADDR
// if list then
16037: LD_VAR 0 5
16041: IFFALSE 16063
// vysledek := FindMaxSkill ( list , skill_combat ) else
16043: LD_ADDR_VAR 0 8
16047: PUSH
16048: LD_VAR 0 5
16052: PPUSH
16053: LD_INT 1
16055: PPUSH
16056: CALL_OW 433
16060: ST_TO_ADDR
16061: GO 16223
// begin unseen := 0 ;
16063: LD_ADDR_VAR 0 7
16067: PUSH
16068: LD_INT 0
16070: ST_TO_ADDR
// build := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_ok ] ] ) ;
16071: LD_ADDR_VAR 0 6
16075: PUSH
16076: LD_INT 22
16078: PUSH
16079: LD_VAR 0 1
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: PUSH
16088: LD_INT 58
16090: PUSH
16091: EMPTY
16092: LIST
16093: PUSH
16094: LD_INT 50
16096: PUSH
16097: EMPTY
16098: LIST
16099: PUSH
16100: EMPTY
16101: LIST
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: ST_TO_ADDR
// for un in build do
16110: LD_ADDR_VAR 0 4
16114: PUSH
16115: LD_VAR 0 6
16119: PUSH
16120: FOR_IN
16121: IFFALSE 16154
// if not See ( you , un ) then
16123: LD_EXP 1
16127: PPUSH
16128: LD_VAR 0 4
16132: PPUSH
16133: CALL_OW 292
16137: NOT
16138: IFFALSE 16152
// begin unseen := un ;
16140: LD_ADDR_VAR 0 7
16144: PUSH
16145: LD_VAR 0 4
16149: ST_TO_ADDR
// break ;
16150: GO 16154
// end ;
16152: GO 16120
16154: POP
16155: POP
// if ( not unseen ) and build then
16156: LD_VAR 0 7
16160: NOT
16161: PUSH
16162: LD_VAR 0 6
16166: AND
16167: IFFALSE 16183
// unseen := build [ 1 ] ;
16169: LD_ADDR_VAR 0 7
16173: PUSH
16174: LD_VAR 0 6
16178: PUSH
16179: LD_INT 1
16181: ARRAY
16182: ST_TO_ADDR
// if unseen then
16183: LD_VAR 0 7
16187: IFFALSE 16223
// begin PrepareSoldier ( sex_male , 5 ) ;
16189: LD_INT 1
16191: PPUSH
16192: LD_INT 5
16194: PPUSH
16195: CALL_OW 381
// vysledek := CreateHuman ;
16199: LD_ADDR_VAR 0 8
16203: PUSH
16204: CALL_OW 44
16208: ST_TO_ADDR
// PlaceHumanInUnit ( vysledek , unseen ) ;
16209: LD_VAR 0 8
16213: PPUSH
16214: LD_VAR 0 7
16218: PPUSH
16219: CALL_OW 52
// end ; end ; result := vysledek ;
16223: LD_ADDR_VAR 0 2
16227: PUSH
16228: LD_VAR 0 8
16232: ST_TO_ADDR
// end ; end_of_file
16233: LD_VAR 0 2
16237: RET
// export function lets_talking ; begin
16238: LD_INT 0
16240: PPUSH
// DialogueOn ;
16241: CALL_OW 6
// interface_hidden := true ;
16245: LD_ADDR_OWVAR 54
16249: PUSH
16250: LD_INT 1
16252: ST_TO_ADDR
// case camp of 4 :
16253: LD_EXP 7
16257: PUSH
16258: LD_INT 4
16260: DOUBLE
16261: EQUAL
16262: IFTRUE 16266
16264: GO 16273
16266: POP
// us_talking ; 6 :
16267: CALL 17338 0 0
16271: GO 16289
16273: LD_INT 6
16275: DOUBLE
16276: EQUAL
16277: IFTRUE 16281
16279: GO 16288
16281: POP
// ru_talking ; end ;
16282: CALL 16306 0 0
16286: GO 16289
16288: POP
// interface_hidden := false ;
16289: LD_ADDR_OWVAR 54
16293: PUSH
16294: LD_INT 0
16296: ST_TO_ADDR
// DialogueOff ;
16297: CALL_OW 7
// end ;
16301: LD_VAR 0 1
16305: RET
// function ru_talking ; begin
16306: LD_INT 0
16308: PPUSH
// if IsOK ( Burlak ) then
16309: LD_EXP 12
16313: PPUSH
16314: CALL_OW 302
16318: IFFALSE 16341
// begin CenterOnUnits ( Burlak ) ;
16320: LD_EXP 12
16324: PPUSH
16325: CALL_OW 85
// Say ( Burlak , DEnd-Burlak-Bur-1 ) ;
16329: LD_EXP 12
16333: PPUSH
16334: LD_STRING DEnd-Burlak-Bur-1
16336: PPUSH
16337: CALL_OW 88
// end ; if IsOK ( Petrosyan ) then
16341: LD_EXP 16
16345: PPUSH
16346: CALL_OW 302
16350: IFFALSE 16373
// begin CenterOnUnits ( Petrosyan ) ;
16352: LD_EXP 16
16356: PPUSH
16357: CALL_OW 85
// Say ( Petrosyan , DEnd-Burlak-Pty-1 ) ;
16361: LD_EXP 16
16365: PPUSH
16366: LD_STRING DEnd-Burlak-Pty-1
16368: PPUSH
16369: CALL_OW 88
// end ; if IsOK ( Belkov ) then
16373: LD_EXP 17
16377: PPUSH
16378: CALL_OW 302
16382: IFFALSE 16405
// begin CenterOnUnits ( Belkov ) ;
16384: LD_EXP 17
16388: PPUSH
16389: CALL_OW 85
// Say ( Belkov , DEnd-Burlak-Bel-1 ) ;
16393: LD_EXP 17
16397: PPUSH
16398: LD_STRING DEnd-Burlak-Bel-1
16400: PPUSH
16401: CALL_OW 88
// end ; if IsOK ( Kirilenkova ) then
16405: LD_EXP 18
16409: PPUSH
16410: CALL_OW 302
16414: IFFALSE 16437
// begin CenterOnUnits ( Kirilenkova ) ;
16416: LD_EXP 18
16420: PPUSH
16421: CALL_OW 85
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16425: LD_EXP 18
16429: PPUSH
16430: LD_STRING DEnd-Burlak-Kir-1
16432: PPUSH
16433: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
16437: LD_EXP 19
16441: PPUSH
16442: CALL_OW 302
16446: IFFALSE 16469
// begin CenterOnUnits ( Gnyevko ) ;
16448: LD_EXP 19
16452: PPUSH
16453: CALL_OW 85
// Say ( Gnyevko , DEnd-Burlak-Gny-1 ) ;
16457: LD_EXP 19
16461: PPUSH
16462: LD_STRING DEnd-Burlak-Gny-1
16464: PPUSH
16465: CALL_OW 88
// end ; if IsOK ( Gladkov ) then
16469: LD_EXP 20
16473: PPUSH
16474: CALL_OW 302
16478: IFFALSE 16501
// begin CenterOnUnits ( Gladkov ) ;
16480: LD_EXP 20
16484: PPUSH
16485: CALL_OW 85
// Say ( Gladkov , DEnd-Burlak-Gla-1 ) ;
16489: LD_EXP 20
16493: PPUSH
16494: LD_STRING DEnd-Burlak-Gla-1
16496: PPUSH
16497: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
16501: LD_EXP 21
16505: PPUSH
16506: CALL_OW 302
16510: IFFALSE 16533
// begin CenterOnUnits ( Dolgov ) ;
16512: LD_EXP 21
16516: PPUSH
16517: CALL_OW 85
// Say ( Dolgov , DEnd-Burlak-Dol-1 ) ;
16521: LD_EXP 21
16525: PPUSH
16526: LD_STRING DEnd-Burlak-Dol-1
16528: PPUSH
16529: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
16533: LD_EXP 23
16537: PPUSH
16538: CALL_OW 302
16542: IFFALSE 16565
// begin CenterOnUnits ( Kapitsova ) ;
16544: LD_EXP 23
16548: PPUSH
16549: CALL_OW 85
// Say ( Kapitsova , DEnd-Burlak-Kap-1 ) ;
16553: LD_EXP 23
16557: PPUSH
16558: LD_STRING DEnd-Burlak-Kap-1
16560: PPUSH
16561: CALL_OW 88
// end ; if IsOK ( Gleb ) then
16565: LD_EXP 22
16569: PPUSH
16570: CALL_OW 302
16574: IFFALSE 16597
// begin CenterOnUnits ( Gleb ) ;
16576: LD_EXP 22
16580: PPUSH
16581: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
16585: LD_EXP 22
16589: PPUSH
16590: LD_STRING DEnd-JMM-Glb-1
16592: PPUSH
16593: CALL_OW 88
// end ; if IsOK ( Kuzmov ) then
16597: LD_EXP 24
16601: PPUSH
16602: CALL_OW 302
16606: IFFALSE 16629
// begin CenterOnUnits ( Kuzmov ) ;
16608: LD_EXP 24
16612: PPUSH
16613: CALL_OW 85
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16617: LD_EXP 24
16621: PPUSH
16622: LD_STRING DEnd-Burlak-Kuz-1
16624: PPUSH
16625: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
16629: LD_EXP 25
16633: PPUSH
16634: CALL_OW 302
16638: IFFALSE 16661
// begin CenterOnUnits ( Kovalyuk ) ;
16640: LD_EXP 25
16644: PPUSH
16645: CALL_OW 85
// Say ( Kovalyuk , DEnd-Burlak-Kov-1 ) ;
16649: LD_EXP 25
16653: PPUSH
16654: LD_STRING DEnd-Burlak-Kov-1
16656: PPUSH
16657: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
16661: LD_EXP 26
16665: PPUSH
16666: CALL_OW 302
16670: IFFALSE 16693
// begin CenterOnUnits ( Scholtze ) ;
16672: LD_EXP 26
16676: PPUSH
16677: CALL_OW 85
// Say ( Scholtze , DEnd-Burlak-Sch-1 ) ;
16681: LD_EXP 26
16685: PPUSH
16686: LD_STRING DEnd-Burlak-Sch-1
16688: PPUSH
16689: CALL_OW 88
// end ; if IsOK ( Karamazov ) then
16693: LD_EXP 27
16697: PPUSH
16698: CALL_OW 302
16702: IFFALSE 16725
// begin CenterOnUnits ( Karamazov ) ;
16704: LD_EXP 27
16708: PPUSH
16709: CALL_OW 85
// Say ( Karamazov , DEnd-Burlak-Kar-1 ) ;
16713: LD_EXP 27
16717: PPUSH
16718: LD_STRING DEnd-Burlak-Kar-1
16720: PPUSH
16721: CALL_OW 88
// end ; if IsOK ( Titov ) then
16725: LD_EXP 28
16729: PPUSH
16730: CALL_OW 302
16734: IFFALSE 16757
// begin CenterOnUnits ( Titov ) ;
16736: LD_EXP 28
16740: PPUSH
16741: CALL_OW 85
// Say ( Titov , DEnd-Burlak-Tit-1 ) ;
16745: LD_EXP 28
16749: PPUSH
16750: LD_STRING DEnd-Burlak-Tit-1
16752: PPUSH
16753: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
16757: LD_EXP 29
16761: PPUSH
16762: CALL_OW 302
16766: IFFALSE 16789
// begin CenterOnUnits ( Oblukov ) ;
16768: LD_EXP 29
16772: PPUSH
16773: CALL_OW 85
// Say ( Oblukov , DEnd-Burlak-Obl-1 ) ;
16777: LD_EXP 29
16781: PPUSH
16782: LD_STRING DEnd-Burlak-Obl-1
16784: PPUSH
16785: CALL_OW 88
// end ; if IsOK ( Kozlov ) then
16789: LD_EXP 30
16793: PPUSH
16794: CALL_OW 302
16798: IFFALSE 16821
// begin CenterOnUnits ( Kozlov ) ;
16800: LD_EXP 30
16804: PPUSH
16805: CALL_OW 85
// Say ( Kozlov , DEnd-Burlak-Koz-1 ) ;
16809: LD_EXP 30
16813: PPUSH
16814: LD_STRING DEnd-Burlak-Koz-1
16816: PPUSH
16817: CALL_OW 88
// end ; if IsOK ( Petrovova ) then
16821: LD_EXP 31
16825: PPUSH
16826: CALL_OW 302
16830: IFFALSE 16853
// begin CenterOnUnits ( Petrovova ) ;
16832: LD_EXP 31
16836: PPUSH
16837: CALL_OW 85
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16841: LD_EXP 31
16845: PPUSH
16846: LD_STRING DEnd-Burlak-Ptr-1
16848: PPUSH
16849: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
16853: LD_EXP 32
16857: PPUSH
16858: CALL_OW 302
16862: IFFALSE 16885
// begin CenterOnUnits ( Bystrov ) ;
16864: LD_EXP 32
16868: PPUSH
16869: CALL_OW 85
// Say ( Bystrov , DEnd-Burlak-Bys-1 ) ;
16873: LD_EXP 32
16877: PPUSH
16878: LD_STRING DEnd-Burlak-Bys-1
16880: PPUSH
16881: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
16885: LD_EXP 33
16889: PPUSH
16890: CALL_OW 302
16894: IFFALSE 16917
// begin CenterOnUnits ( Lipshchin ) ;
16896: LD_EXP 33
16900: PPUSH
16901: CALL_OW 85
// Say ( Lipshchin , DEnd-Burlak-Lip-1 ) ;
16905: LD_EXP 33
16909: PPUSH
16910: LD_STRING DEnd-Burlak-Lip-1
16912: PPUSH
16913: CALL_OW 88
// end ; if IsOK ( Fadeev ) then
16917: LD_EXP 34
16921: PPUSH
16922: CALL_OW 302
16926: IFFALSE 16949
// begin CenterOnUnits ( Fadeev ) ;
16928: LD_EXP 34
16932: PPUSH
16933: CALL_OW 85
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16937: LD_EXP 34
16941: PPUSH
16942: LD_STRING DEnd-Burlak-Fad-1
16944: PPUSH
16945: CALL_OW 88
// end ; if IsOK ( MacMillan ) then
16949: LD_EXP 13
16953: PPUSH
16954: CALL_OW 302
16958: IFFALSE 16981
// begin CenterOnUnits ( MacMillan ) ;
16960: LD_EXP 13
16964: PPUSH
16965: CALL_OW 85
// Say ( MacMillan , DEnd-Burlak-JMM-1 ) ;
16969: LD_EXP 13
16973: PPUSH
16974: LD_STRING DEnd-Burlak-JMM-1
16976: PPUSH
16977: CALL_OW 88
// end ; if IsOK ( Lisa ) then
16981: LD_EXP 46
16985: PPUSH
16986: CALL_OW 302
16990: IFFALSE 17013
// begin CenterOnUnits ( Lisa ) ;
16992: LD_EXP 46
16996: PPUSH
16997: CALL_OW 85
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17001: LD_EXP 46
17005: PPUSH
17006: LD_STRING DEnd-Burlak-Lisa-1
17008: PPUSH
17009: CALL_OW 88
// end ; if IsOK ( Joan ) then
17013: LD_EXP 45
17017: PPUSH
17018: CALL_OW 302
17022: IFFALSE 17045
// begin CenterOnUnits ( Joan ) ;
17024: LD_EXP 45
17028: PPUSH
17029: CALL_OW 85
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
17033: LD_EXP 45
17037: PPUSH
17038: LD_STRING DEnd-Burlak-Joan-1
17040: PPUSH
17041: CALL_OW 88
// end ; if IsOK ( Frank ) then
17045: LD_EXP 42
17049: PPUSH
17050: CALL_OW 302
17054: IFFALSE 17077
// begin CenterOnUnits ( Frank ) ;
17056: LD_EXP 42
17060: PPUSH
17061: CALL_OW 85
// Say ( Frank , DEnd-Burlak-Frank-1 ) ;
17065: LD_EXP 42
17069: PPUSH
17070: LD_STRING DEnd-Burlak-Frank-1
17072: PPUSH
17073: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17077: LD_EXP 39
17081: PPUSH
17082: CALL_OW 302
17086: IFFALSE 17109
// begin CenterOnUnits ( Cyrus ) ;
17088: LD_EXP 39
17092: PPUSH
17093: CALL_OW 85
// Say ( Cyrus , DEnd-Burlak-Cyrus-1 ) ;
17097: LD_EXP 39
17101: PPUSH
17102: LD_STRING DEnd-Burlak-Cyrus-1
17104: PPUSH
17105: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17109: LD_EXP 41
17113: PPUSH
17114: CALL_OW 302
17118: IFFALSE 17141
// begin CenterOnUnits ( Donaldson ) ;
17120: LD_EXP 41
17124: PPUSH
17125: CALL_OW 85
// Say ( Donaldson , DEnd-Burlak-Don-1 ) ;
17129: LD_EXP 41
17133: PPUSH
17134: LD_STRING DEnd-Burlak-Don-1
17136: PPUSH
17137: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17141: LD_EXP 35
17145: PPUSH
17146: CALL_OW 302
17150: IFFALSE 17173
// begin CenterOnUnits ( Bobby ) ;
17152: LD_EXP 35
17156: PPUSH
17157: CALL_OW 85
// Say ( Bobby , DEnd-Burlak-Bobby-1 ) ;
17161: LD_EXP 35
17165: PPUSH
17166: LD_STRING DEnd-Burlak-Bobby-1
17168: PPUSH
17169: CALL_OW 88
// end ; if IsOK ( Denis ) then
17173: LD_EXP 40
17177: PPUSH
17178: CALL_OW 302
17182: IFFALSE 17205
// begin CenterOnUnits ( Denis ) ;
17184: LD_EXP 40
17188: PPUSH
17189: CALL_OW 85
// Say ( Denis , DEnd-Burlak-Den-1 ) ;
17193: LD_EXP 40
17197: PPUSH
17198: LD_STRING DEnd-Burlak-Den-1
17200: PPUSH
17201: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17205: LD_EXP 44
17209: PPUSH
17210: CALL_OW 302
17214: IFFALSE 17237
// begin CenterOnUnits ( Gladstone ) ;
17216: LD_EXP 44
17220: PPUSH
17221: CALL_OW 85
// Say ( Gladstone , DEnd-Burlak-Glad-1 ) ;
17225: LD_EXP 44
17229: PPUSH
17230: LD_STRING DEnd-Burlak-Glad-1
17232: PPUSH
17233: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17237: LD_EXP 50
17241: PPUSH
17242: CALL_OW 302
17246: IFFALSE 17269
// begin CenterOnUnits ( Yamoko ) ;
17248: LD_EXP 50
17252: PPUSH
17253: CALL_OW 85
// Say ( Yamoko , DEnd-Burlak-Yam-1 ) ;
17257: LD_EXP 50
17261: PPUSH
17262: LD_STRING DEnd-Burlak-Yam-1
17264: PPUSH
17265: CALL_OW 88
// end ; if IsOK ( Brown ) then
17269: LD_EXP 36
17273: PPUSH
17274: CALL_OW 302
17278: IFFALSE 17301
// begin CenterOnUnits ( Brown ) ;
17280: LD_EXP 36
17284: PPUSH
17285: CALL_OW 85
// Say ( Brown , DEnd-Burlak-Brown-1 ) ;
17289: LD_EXP 36
17293: PPUSH
17294: LD_STRING DEnd-Burlak-Brown-1
17296: PPUSH
17297: CALL_OW 88
// end ; if IsOK ( Roth ) then
17301: LD_EXP 14
17305: PPUSH
17306: CALL_OW 302
17310: IFFALSE 17333
// begin CenterOnUnits ( Roth ) ;
17312: LD_EXP 14
17316: PPUSH
17317: CALL_OW 85
// Say ( Roth , DEnd-Burlak-Roth-1 ) ;
17321: LD_EXP 14
17325: PPUSH
17326: LD_STRING DEnd-Burlak-Roth-1
17328: PPUSH
17329: CALL_OW 88
// end ; end ;
17333: LD_VAR 0 1
17337: RET
// function us_talking ; begin
17338: LD_INT 0
17340: PPUSH
// if IsOK ( MacMillan ) then
17341: LD_EXP 13
17345: PPUSH
17346: CALL_OW 302
17350: IFFALSE 17373
// begin CenterOnUnits ( MacMillan ) ;
17352: LD_EXP 13
17356: PPUSH
17357: CALL_OW 85
// Say ( MacMillan , DEnd-JMM-JMM-1 ) ;
17361: LD_EXP 13
17365: PPUSH
17366: LD_STRING DEnd-JMM-JMM-1
17368: PPUSH
17369: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17373: LD_EXP 46
17377: PPUSH
17378: CALL_OW 302
17382: IFFALSE 17405
// begin CenterOnUnits ( Lisa ) ;
17384: LD_EXP 46
17388: PPUSH
17389: CALL_OW 85
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17393: LD_EXP 46
17397: PPUSH
17398: LD_STRING DEnd-JMM-Lisa-1
17400: PPUSH
17401: CALL_OW 88
// end ; if IsOK ( Joan ) then
17405: LD_EXP 45
17409: PPUSH
17410: CALL_OW 302
17414: IFFALSE 17437
// begin CenterOnUnits ( Joan ) ;
17416: LD_EXP 45
17420: PPUSH
17421: CALL_OW 85
// Say ( Joan , DEnd-JMM-Joan-1 ) ;
17425: LD_EXP 45
17429: PPUSH
17430: LD_STRING DEnd-JMM-Joan-1
17432: PPUSH
17433: CALL_OW 88
// end ; if IsOK ( Frank ) then
17437: LD_EXP 42
17441: PPUSH
17442: CALL_OW 302
17446: IFFALSE 17469
// begin CenterOnUnits ( Frank ) ;
17448: LD_EXP 42
17452: PPUSH
17453: CALL_OW 85
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17457: LD_EXP 42
17461: PPUSH
17462: LD_STRING DEnd-JMM-Frank-1
17464: PPUSH
17465: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17469: LD_EXP 39
17473: PPUSH
17474: CALL_OW 302
17478: IFFALSE 17501
// begin CenterOnUnits ( Cyrus ) ;
17480: LD_EXP 39
17484: PPUSH
17485: CALL_OW 85
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17489: LD_EXP 39
17493: PPUSH
17494: LD_STRING DEnd-JMM-Cyrus-1
17496: PPUSH
17497: CALL_OW 88
// end ; if IsOK ( Cornell ) then
17501: LD_EXP 37
17505: PPUSH
17506: CALL_OW 302
17510: IFFALSE 17533
// begin CenterOnUnits ( Cornell ) ;
17512: LD_EXP 37
17516: PPUSH
17517: CALL_OW 85
// Say ( Cornell , DEnd-JMM-Corn-1 ) ;
17521: LD_EXP 37
17525: PPUSH
17526: LD_STRING DEnd-JMM-Corn-1
17528: PPUSH
17529: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17533: LD_EXP 41
17537: PPUSH
17538: CALL_OW 302
17542: IFFALSE 17565
// begin CenterOnUnits ( Donaldson ) ;
17544: LD_EXP 41
17548: PPUSH
17549: CALL_OW 85
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17553: LD_EXP 41
17557: PPUSH
17558: LD_STRING DEnd-JMM-Don-1
17560: PPUSH
17561: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17565: LD_EXP 35
17569: PPUSH
17570: CALL_OW 302
17574: IFFALSE 17597
// begin CenterOnUnits ( Bobby ) ;
17576: LD_EXP 35
17580: PPUSH
17581: CALL_OW 85
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17585: LD_EXP 35
17589: PPUSH
17590: LD_STRING DEnd-JMM-Bobby-1
17592: PPUSH
17593: CALL_OW 88
// end ; if IsOK ( Denis ) then
17597: LD_EXP 40
17601: PPUSH
17602: CALL_OW 302
17606: IFFALSE 17629
// begin CenterOnUnits ( Denis ) ;
17608: LD_EXP 40
17612: PPUSH
17613: CALL_OW 85
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17617: LD_EXP 40
17621: PPUSH
17622: LD_STRING DEnd-JMM-Den-1
17624: PPUSH
17625: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17629: LD_EXP 44
17633: PPUSH
17634: CALL_OW 302
17638: IFFALSE 17661
// begin CenterOnUnits ( Gladstone ) ;
17640: LD_EXP 44
17644: PPUSH
17645: CALL_OW 85
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17649: LD_EXP 44
17653: PPUSH
17654: LD_STRING DEnd-JMM-Glad-1
17656: PPUSH
17657: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17661: LD_EXP 50
17665: PPUSH
17666: CALL_OW 302
17670: IFFALSE 17693
// begin CenterOnUnits ( Yamoko ) ;
17672: LD_EXP 50
17676: PPUSH
17677: CALL_OW 85
// Say ( Yamoko , DEnd-JMM-Yam-1 ) ;
17681: LD_EXP 50
17685: PPUSH
17686: LD_STRING DEnd-JMM-Yam-1
17688: PPUSH
17689: CALL_OW 88
// end ; if IsOK ( Brown ) then
17693: LD_EXP 36
17697: PPUSH
17698: CALL_OW 302
17702: IFFALSE 17725
// begin CenterOnUnits ( Brown ) ;
17704: LD_EXP 36
17708: PPUSH
17709: CALL_OW 85
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17713: LD_EXP 36
17717: PPUSH
17718: LD_STRING DEnd-JMM-Brown-1
17720: PPUSH
17721: CALL_OW 88
// end ; if IsOK ( Roth ) then
17725: LD_EXP 14
17729: PPUSH
17730: CALL_OW 302
17734: IFFALSE 17757
// begin CenterOnUnits ( Roth ) ;
17736: LD_EXP 14
17740: PPUSH
17741: CALL_OW 85
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
17745: LD_EXP 14
17749: PPUSH
17750: LD_STRING DEnd-JMM-Roth-1
17752: PPUSH
17753: CALL_OW 88
// end ; if IsOK ( Connie ) then
17757: LD_EXP 38
17761: PPUSH
17762: CALL_OW 302
17766: IFFALSE 17789
// begin CenterOnUnits ( Connie ) ;
17768: LD_EXP 38
17772: PPUSH
17773: CALL_OW 85
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17777: LD_EXP 38
17781: PPUSH
17782: LD_STRING DEnd-JMM-Con-1
17784: PPUSH
17785: CALL_OW 88
// end ; if IsOK ( Gary ) then
17789: LD_EXP 43
17793: PPUSH
17794: CALL_OW 302
17798: IFFALSE 17821
// begin CenterOnUnits ( Gary ) ;
17800: LD_EXP 43
17804: PPUSH
17805: CALL_OW 85
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17809: LD_EXP 43
17813: PPUSH
17814: LD_STRING DEnd-JMM-Gary-1
17816: PPUSH
17817: CALL_OW 88
// end ; if IsOK ( Simms ) then
17821: LD_EXP 48
17825: PPUSH
17826: CALL_OW 302
17830: IFFALSE 17853
// begin CenterOnUnits ( Simms ) ;
17832: LD_EXP 48
17836: PPUSH
17837: CALL_OW 85
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17841: LD_EXP 48
17845: PPUSH
17846: LD_STRING DEnd-JMM-Sim-1
17848: PPUSH
17849: CALL_OW 88
// end ; if IsOK ( VanHouten ) then
17853: LD_EXP 49
17857: PPUSH
17858: CALL_OW 302
17862: IFFALSE 17885
// begin CenterOnUnits ( VanHouten ) ;
17864: LD_EXP 49
17868: PPUSH
17869: CALL_OW 85
// Say ( VanHouten , DEnd-JMM-VanH-1 ) ;
17873: LD_EXP 49
17877: PPUSH
17878: LD_STRING DEnd-JMM-VanH-1
17880: PPUSH
17881: CALL_OW 88
// end ; if IsOK ( Burlak ) then
17885: LD_EXP 12
17889: PPUSH
17890: CALL_OW 302
17894: IFFALSE 17917
// begin CenterOnUnits ( Burlak ) ;
17896: LD_EXP 12
17900: PPUSH
17901: CALL_OW 85
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17905: LD_EXP 12
17909: PPUSH
17910: LD_STRING DEnd-JMM-Bur-1
17912: PPUSH
17913: CALL_OW 88
// end ; if IsOK ( Belkov ) then
17917: LD_EXP 17
17921: PPUSH
17922: CALL_OW 302
17926: IFFALSE 17949
// begin CenterOnUnits ( Belkov ) ;
17928: LD_EXP 17
17932: PPUSH
17933: CALL_OW 85
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17937: LD_EXP 17
17941: PPUSH
17942: LD_STRING DEnd-JMM-Bel-1
17944: PPUSH
17945: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
17949: LD_EXP 19
17953: PPUSH
17954: CALL_OW 302
17958: IFFALSE 17981
// begin CenterOnUnits ( Gnyevko ) ;
17960: LD_EXP 19
17964: PPUSH
17965: CALL_OW 85
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17969: LD_EXP 19
17973: PPUSH
17974: LD_STRING DEnd-JMM-Gny-1
17976: PPUSH
17977: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
17981: LD_EXP 21
17985: PPUSH
17986: CALL_OW 302
17990: IFFALSE 18013
// begin CenterOnUnits ( Dolgov ) ;
17992: LD_EXP 21
17996: PPUSH
17997: CALL_OW 85
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18001: LD_EXP 21
18005: PPUSH
18006: LD_STRING DEnd-JMM-Dol-1
18008: PPUSH
18009: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
18013: LD_EXP 23
18017: PPUSH
18018: CALL_OW 302
18022: IFFALSE 18045
// begin CenterOnUnits ( Kapitsova ) ;
18024: LD_EXP 23
18028: PPUSH
18029: CALL_OW 85
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18033: LD_EXP 23
18037: PPUSH
18038: LD_STRING DEnd-JMM-Kap-1
18040: PPUSH
18041: CALL_OW 88
// end ; if IsOK ( Gleb ) then
18045: LD_EXP 22
18049: PPUSH
18050: CALL_OW 302
18054: IFFALSE 18077
// begin CenterOnUnits ( Gleb ) ;
18056: LD_EXP 22
18060: PPUSH
18061: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
18065: LD_EXP 22
18069: PPUSH
18070: LD_STRING DEnd-JMM-Glb-1
18072: PPUSH
18073: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
18077: LD_EXP 25
18081: PPUSH
18082: CALL_OW 302
18086: IFFALSE 18109
// begin CenterOnUnits ( Kovalyuk ) ;
18088: LD_EXP 25
18092: PPUSH
18093: CALL_OW 85
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18097: LD_EXP 25
18101: PPUSH
18102: LD_STRING DEnd-JMM-Kov-1
18104: PPUSH
18105: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
18109: LD_EXP 26
18113: PPUSH
18114: CALL_OW 302
18118: IFFALSE 18141
// begin CenterOnUnits ( Scholtze ) ;
18120: LD_EXP 26
18124: PPUSH
18125: CALL_OW 85
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18129: LD_EXP 26
18133: PPUSH
18134: LD_STRING DEnd-JMM-Sch-1
18136: PPUSH
18137: CALL_OW 88
// end ; if IsOK ( Titov ) then
18141: LD_EXP 28
18145: PPUSH
18146: CALL_OW 302
18150: IFFALSE 18173
// begin CenterOnUnits ( Titov ) ;
18152: LD_EXP 28
18156: PPUSH
18157: CALL_OW 85
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18161: LD_EXP 28
18165: PPUSH
18166: LD_STRING DEnd-JMM-Tit-1
18168: PPUSH
18169: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
18173: LD_EXP 29
18177: PPUSH
18178: CALL_OW 302
18182: IFFALSE 18205
// begin CenterOnUnits ( Oblukov ) ;
18184: LD_EXP 29
18188: PPUSH
18189: CALL_OW 85
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18193: LD_EXP 29
18197: PPUSH
18198: LD_STRING DEnd-JMM-Obl-1
18200: PPUSH
18201: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
18205: LD_EXP 32
18209: PPUSH
18210: CALL_OW 302
18214: IFFALSE 18237
// begin CenterOnUnits ( Bystrov ) ;
18216: LD_EXP 32
18220: PPUSH
18221: CALL_OW 85
// Say ( Bystrov , DEnd-JMM-Bys-1 ) ;
18225: LD_EXP 32
18229: PPUSH
18230: LD_STRING DEnd-JMM-Bys-1
18232: PPUSH
18233: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
18237: LD_EXP 33
18241: PPUSH
18242: CALL_OW 302
18246: IFFALSE 18269
// begin CenterOnUnits ( Lipshchin ) ;
18248: LD_EXP 33
18252: PPUSH
18253: CALL_OW 85
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18257: LD_EXP 33
18261: PPUSH
18262: LD_STRING DEnd-JMM-Lip-1
18264: PPUSH
18265: CALL_OW 88
// end ; end ; end_of_file
18269: LD_VAR 0 1
18273: RET
// var id_reg , id_def ; var BaseArea , DefendArea , Heal ; var docs ; var healing_un , wounded_un ; var central_base , mc_id_defend ; export function init_defend ; var side ; begin
18274: LD_INT 0
18276: PPUSH
18277: PPUSH
// BaseArea := [ us_base , ar_base , ru_base ] ;
18278: LD_ADDR_LOC 14
18282: PUSH
18283: LD_INT 11
18285: PUSH
18286: LD_INT 13
18288: PUSH
18289: LD_INT 12
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: LIST
18296: ST_TO_ADDR
// DefendArea := [ us_defend_base , ar_defend_base , ru_base ] ;
18297: LD_ADDR_LOC 15
18301: PUSH
18302: LD_INT 36
18304: PUSH
18305: LD_INT 37
18307: PUSH
18308: LD_INT 12
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: LIST
18315: ST_TO_ADDR
// Heal := [ us_heal , ar_heal , ru_heal ] ;
18316: LD_ADDR_LOC 16
18320: PUSH
18321: LD_INT 16
18323: PUSH
18324: LD_INT 14
18326: PUSH
18327: LD_INT 15
18329: PUSH
18330: EMPTY
18331: LIST
18332: LIST
18333: LIST
18334: ST_TO_ADDR
// docs := [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
18335: LD_ADDR_LOC 17
18339: PUSH
18340: EMPTY
18341: PUSH
18342: EMPTY
18343: PUSH
18344: EMPTY
18345: PUSH
18346: EMPTY
18347: PUSH
18348: EMPTY
18349: PUSH
18350: EMPTY
18351: PUSH
18352: EMPTY
18353: PUSH
18354: EMPTY
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: LIST
18364: LIST
18365: ST_TO_ADDR
// central_base := [ [ 44 , 62 ] , [ 251 , 193 ] , [ 177 , 72 ] ] ;
18366: LD_ADDR_LOC 20
18370: PUSH
18371: LD_INT 44
18373: PUSH
18374: LD_INT 62
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: PUSH
18381: LD_INT 251
18383: PUSH
18384: LD_INT 193
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: PUSH
18391: LD_INT 177
18393: PUSH
18394: LD_INT 72
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: LIST
18405: ST_TO_ADDR
// healing_un := [ ] ;
18406: LD_ADDR_LOC 18
18410: PUSH
18411: EMPTY
18412: ST_TO_ADDR
// wounded_un := [ ] ;
18413: LD_ADDR_LOC 19
18417: PUSH
18418: EMPTY
18419: ST_TO_ADDR
// mc_id_defend := false ;
18420: LD_ADDR_LOC 21
18424: PUSH
18425: LD_INT 0
18427: ST_TO_ADDR
// start_defend ;
18428: CALL 18688 0 0
// end ;
18432: LD_VAR 0 1
18436: RET
// function prepare_defend ( side ) ; var seznam , def_buildings , def_vehicles , def_peoples ; begin
18437: LD_INT 0
18439: PPUSH
18440: PPUSH
18441: PPUSH
18442: PPUSH
18443: PPUSH
// def_buildings := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
18444: LD_ADDR_VAR 0 4
18448: PUSH
18449: LD_INT 22
18451: PUSH
18452: LD_VAR 0 1
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: PUSH
18461: LD_INT 2
18463: PUSH
18464: LD_INT 30
18466: PUSH
18467: LD_INT 32
18469: PUSH
18470: EMPTY
18471: LIST
18472: LIST
18473: PUSH
18474: LD_INT 30
18476: PUSH
18477: LD_INT 31
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: LIST
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PPUSH
18493: CALL_OW 69
18497: ST_TO_ADDR
// def_peoples := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_class , class_scientistic ] ] ) ;
18498: LD_ADDR_VAR 0 6
18502: PUSH
18503: LD_INT 22
18505: PUSH
18506: LD_VAR 0 1
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: PUSH
18515: LD_INT 21
18517: PUSH
18518: LD_INT 1
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: PUSH
18525: LD_INT 3
18527: PUSH
18528: LD_INT 25
18530: PUSH
18531: LD_INT 4
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: LIST
18542: LIST
18543: PPUSH
18544: CALL_OW 69
18548: ST_TO_ADDR
// def_vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , f_not , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) ;
18549: LD_ADDR_VAR 0 5
18553: PUSH
18554: LD_INT 22
18556: PUSH
18557: LD_VAR 0 1
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: PUSH
18566: LD_INT 21
18568: PUSH
18569: LD_INT 2
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PUSH
18576: LD_INT 3
18578: PUSH
18579: LD_INT 2
18581: PUSH
18582: LD_INT 34
18584: PUSH
18585: LD_INT 12
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PUSH
18592: LD_INT 34
18594: PUSH
18595: LD_INT 13
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: PUSH
18602: LD_INT 34
18604: PUSH
18605: LD_INT 32
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 34
18614: PUSH
18615: LD_INT 51
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: LD_INT 34
18624: PUSH
18625: LD_INT 52
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: LIST
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: LIST
18644: LIST
18645: PPUSH
18646: CALL_OW 69
18650: ST_TO_ADDR
// seznam := def_buildings ^ def_peoples ^ def_vehicles ;
18651: LD_ADDR_VAR 0 3
18655: PUSH
18656: LD_VAR 0 4
18660: PUSH
18661: LD_VAR 0 6
18665: ADD
18666: PUSH
18667: LD_VAR 0 5
18671: ADD
18672: ST_TO_ADDR
// result := seznam ;
18673: LD_ADDR_VAR 0 2
18677: PUSH
18678: LD_VAR 0 3
18682: ST_TO_ADDR
// end ;
18683: LD_VAR 0 2
18687: RET
// function start_defend ; var side ; begin
18688: LD_INT 0
18690: PPUSH
18691: PPUSH
// id_reg := [ ] ;
18692: LD_ADDR_LOC 12
18696: PUSH
18697: EMPTY
18698: ST_TO_ADDR
// id_def := [ ] ;
18699: LD_ADDR_LOC 13
18703: PUSH
18704: EMPTY
18705: ST_TO_ADDR
// for side = 1 to 8 do
18706: LD_ADDR_VAR 0 2
18710: PUSH
18711: DOUBLE
18712: LD_INT 1
18714: DEC
18715: ST_TO_ADDR
18716: LD_INT 8
18718: PUSH
18719: FOR_TO
18720: IFFALSE 18976
// if side in cpu_list then
18722: LD_VAR 0 2
18726: PUSH
18727: LD_EXP 8
18731: IN
18732: IFFALSE 18940
// begin id_reg := id_reg ^ McRegistry ( 1 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , BaseArea [ side ] ] , [ mc_reg_area_to_protect , BaseArea [ side ] ] , [ mc_reg_units_to_protect , prepare_defend ( side ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
18734: LD_ADDR_LOC 12
18738: PUSH
18739: LD_LOC 12
18743: PUSH
18744: LD_INT 1
18746: PPUSH
18747: LD_INT 1
18749: PUSH
18750: LD_INT 35
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 5
18759: PUSH
18760: LD_INT 140
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 2
18769: PUSH
18770: LD_LOC 14
18774: PUSH
18775: LD_VAR 0 2
18779: ARRAY
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: LD_LOC 14
18792: PUSH
18793: LD_VAR 0 2
18797: ARRAY
18798: PUSH
18799: EMPTY
18800: LIST
18801: LIST
18802: PUSH
18803: LD_INT 4
18805: PUSH
18806: LD_VAR 0 2
18810: PPUSH
18811: CALL 18437 0 1
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: PUSH
18820: LD_INT 8
18822: PUSH
18823: LD_INT 7
18825: NEG
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: LIST
18835: PPUSH
18836: CALL_OW 399
18840: ADD
18841: ST_TO_ADDR
// id_def := id_def ^ McDefend ( 200 , id_reg , prepare_defend ( side ) , [ [ mc_def_advantage , 5000 ] , [ mc_area_dont_leave , BaseArea [ side ] ] , [ mc_retreat_area_people , Heal [ side ] ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
18842: LD_ADDR_LOC 13
18846: PUSH
18847: LD_LOC 13
18851: PUSH
18852: LD_INT 200
18854: PPUSH
18855: LD_LOC 12
18859: PPUSH
18860: LD_VAR 0 2
18864: PPUSH
18865: CALL 18437 0 1
18869: PPUSH
18870: LD_INT 1
18872: PUSH
18873: LD_INT 5000
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: PUSH
18880: LD_INT 2
18882: PUSH
18883: LD_LOC 14
18887: PUSH
18888: LD_VAR 0 2
18892: ARRAY
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: PUSH
18898: LD_INT 7
18900: PUSH
18901: LD_LOC 16
18905: PUSH
18906: LD_VAR 0 2
18910: ARRAY
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PUSH
18916: LD_INT 5
18918: PUSH
18919: LD_INT 600
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: PPUSH
18932: CALL_OW 401
18936: ADD
18937: ST_TO_ADDR
// end else
18938: GO 18974
// begin id_reg := id_reg ^ [ 0 ] ;
18940: LD_ADDR_LOC 12
18944: PUSH
18945: LD_LOC 12
18949: PUSH
18950: LD_INT 0
18952: PUSH
18953: EMPTY
18954: LIST
18955: ADD
18956: ST_TO_ADDR
// id_def := id_reg ^ [ 0 ] ;
18957: LD_ADDR_LOC 13
18961: PUSH
18962: LD_LOC 12
18966: PUSH
18967: LD_INT 0
18969: PUSH
18970: EMPTY
18971: LIST
18972: ADD
18973: ST_TO_ADDR
// end ;
18974: GO 18719
18976: POP
18977: POP
// end ;
18978: LD_VAR 0 1
18982: RET
// on McRegistryResultChanges ( mcid , n , s ) do var side ;
18983: LD_INT 0
18985: PPUSH
// begin for side = 1 to id_reg do
18986: LD_ADDR_VAR 0 4
18990: PUSH
18991: DOUBLE
18992: LD_INT 1
18994: DEC
18995: ST_TO_ADDR
18996: LD_LOC 12
19000: PUSH
19001: FOR_TO
19002: IFFALSE 19054
// if id_reg [ side ] = mcid then
19004: LD_LOC 12
19008: PUSH
19009: LD_VAR 0 4
19013: ARRAY
19014: PUSH
19015: LD_VAR 0 1
19019: EQUAL
19020: IFFALSE 19052
// begin AddMcUnits ( mcid , prepare_defend ( side ) ) ;
19022: LD_VAR 0 1
19026: PPUSH
19027: LD_VAR 0 4
19031: PPUSH
19032: CALL 18437 0 1
19036: PPUSH
19037: CALL_OW 390
// SendForces ( side ) ;
19041: LD_VAR 0 4
19045: PPUSH
19046: CALL 20199 0 1
// break ;
19050: GO 19054
// end ;
19052: GO 19001
19054: POP
19055: POP
// end ;
19056: PPOPN 4
19058: END
// every 0 0$7.7 do var side , list ;
19059: GO 19061
19061: DISABLE
19062: LD_INT 0
19064: PPUSH
19065: PPUSH
// begin list := [ ] ;
19066: LD_ADDR_VAR 0 2
19070: PUSH
19071: EMPTY
19072: ST_TO_ADDR
// for side = 1 to 8 do
19073: LD_ADDR_VAR 0 1
19077: PUSH
19078: DOUBLE
19079: LD_INT 1
19081: DEC
19082: ST_TO_ADDR
19083: LD_INT 8
19085: PUSH
19086: FOR_TO
19087: IFFALSE 19232
// if ( not side in cpu_list ) and id_reg [ side ] then
19089: LD_VAR 0 1
19093: PUSH
19094: LD_EXP 8
19098: IN
19099: NOT
19100: PUSH
19101: LD_LOC 12
19105: PUSH
19106: LD_VAR 0 1
19110: ARRAY
19111: AND
19112: IFFALSE 19230
// begin KillMc ( id_reg [ side ] ) ;
19114: LD_LOC 12
19118: PUSH
19119: LD_VAR 0 1
19123: ARRAY
19124: PPUSH
19125: CALL_OW 387
// id_reg := Delete ( id_reg , side ) ;
19129: LD_ADDR_LOC 12
19133: PUSH
19134: LD_LOC 12
19138: PPUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 3
19148: ST_TO_ADDR
// id_reg := Insert ( id_reg , side , 0 ) ;
19149: LD_ADDR_LOC 12
19153: PUSH
19154: LD_LOC 12
19158: PPUSH
19159: LD_VAR 0 1
19163: PPUSH
19164: LD_INT 0
19166: PPUSH
19167: CALL_OW 2
19171: ST_TO_ADDR
// KillMc ( id_def [ side ] ) ;
19172: LD_LOC 13
19176: PUSH
19177: LD_VAR 0 1
19181: ARRAY
19182: PPUSH
19183: CALL_OW 387
// id_def := Delete ( id_def , side ) ;
19187: LD_ADDR_LOC 13
19191: PUSH
19192: LD_LOC 13
19196: PPUSH
19197: LD_VAR 0 1
19201: PPUSH
19202: CALL_OW 3
19206: ST_TO_ADDR
// id_def := Insert ( id_def , side , 0 ) ;
19207: LD_ADDR_LOC 13
19211: PUSH
19212: LD_LOC 13
19216: PPUSH
19217: LD_VAR 0 1
19221: PPUSH
19222: LD_INT 0
19224: PPUSH
19225: CALL_OW 2
19229: ST_TO_ADDR
// end ;
19230: GO 19086
19232: POP
19233: POP
// enable ;
19234: ENABLE
// end ;
19235: PPOPN 2
19237: END
// every 0 0$5.3 do var side , sci , list , wounded , un ;
19238: GO 19240
19240: DISABLE
19241: LD_INT 0
19243: PPUSH
19244: PPUSH
19245: PPUSH
19246: PPUSH
19247: PPUSH
// begin for side = 1 to 8 do
19248: LD_ADDR_VAR 0 1
19252: PUSH
19253: DOUBLE
19254: LD_INT 1
19256: DEC
19257: ST_TO_ADDR
19258: LD_INT 8
19260: PUSH
19261: FOR_TO
19262: IFFALSE 19696
// if side in cpu_list then
19264: LD_VAR 0 1
19268: PUSH
19269: LD_EXP 8
19273: IN
19274: IFFALSE 19694
// begin wounded := FilterUnitsInArea ( Heal [ side ] , [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 1000 ] ] ) ;
19276: LD_ADDR_VAR 0 4
19280: PUSH
19281: LD_LOC 16
19285: PUSH
19286: LD_VAR 0 1
19290: ARRAY
19291: PPUSH
19292: LD_INT 22
19294: PUSH
19295: LD_VAR 0 1
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: PUSH
19304: LD_INT 21
19306: PUSH
19307: LD_INT 1
19309: PUSH
19310: EMPTY
19311: LIST
19312: LIST
19313: PUSH
19314: LD_INT 3
19316: PUSH
19317: LD_INT 24
19319: PUSH
19320: LD_INT 1000
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: LIST
19331: LIST
19332: PPUSH
19333: CALL_OW 70
19337: ST_TO_ADDR
// if wounded then
19338: LD_VAR 0 4
19342: IFFALSE 19552
// begin if not docs [ side ] then
19344: LD_LOC 17
19348: PUSH
19349: LD_VAR 0 1
19353: ARRAY
19354: NOT
19355: IFFALSE 19519
// begin sci := request_people ( side , class_scientistic , 5 ) ;
19357: LD_ADDR_VAR 0 2
19361: PUSH
19362: LD_VAR 0 1
19366: PPUSH
19367: LD_INT 4
19369: PPUSH
19370: LD_INT 5
19372: PPUSH
19373: CALL 26521 0 3
19377: ST_TO_ADDR
// docs := Delete ( docs , side ) ;
19378: LD_ADDR_LOC 17
19382: PUSH
19383: LD_LOC 17
19387: PPUSH
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL_OW 3
19397: ST_TO_ADDR
// docs := Insert ( docs , side , sci ) ;
19398: LD_ADDR_LOC 17
19402: PUSH
19403: LD_LOC 17
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: LD_VAR 0 2
19417: PPUSH
19418: CALL_OW 2
19422: ST_TO_ADDR
// list := reserved_people [ side ] ^ sci ;
19423: LD_ADDR_VAR 0 3
19427: PUSH
19428: LD_EXP 71
19432: PUSH
19433: LD_VAR 0 1
19437: ARRAY
19438: PUSH
19439: LD_VAR 0 2
19443: ADD
19444: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19445: LD_ADDR_EXP 71
19449: PUSH
19450: LD_EXP 71
19454: PPUSH
19455: LD_VAR 0 1
19459: PPUSH
19460: CALL_OW 3
19464: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19465: LD_ADDR_EXP 71
19469: PUSH
19470: LD_EXP 71
19474: PPUSH
19475: LD_VAR 0 1
19479: PPUSH
19480: LD_VAR 0 3
19484: PPUSH
19485: CALL_OW 2
19489: ST_TO_ADDR
// ComRemember ( sci ) ;
19490: LD_VAR 0 2
19494: PPUSH
19495: CALL_OW 143
// ComMoveToArea ( sci , Heal [ side ] ) ;
19499: LD_VAR 0 2
19503: PPUSH
19504: LD_LOC 16
19508: PUSH
19509: LD_VAR 0 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 113
// end ; for un in wounded do
19519: LD_ADDR_VAR 0 5
19523: PUSH
19524: LD_VAR 0 4
19528: PUSH
19529: FOR_IN
19530: IFFALSE 19548
// AddComHeal ( sci , un ) ;
19532: LD_VAR 0 2
19536: PPUSH
19537: LD_VAR 0 5
19541: PPUSH
19542: CALL_OW 188
19546: GO 19529
19548: POP
19549: POP
// end else
19550: GO 19694
// if docs [ side ] then
19552: LD_LOC 17
19556: PUSH
19557: LD_VAR 0 1
19561: ARRAY
19562: IFFALSE 19694
// begin list := reserved_people [ side ] diff docs [ side ] ;
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_EXP 71
19573: PUSH
19574: LD_VAR 0 1
19578: ARRAY
19579: PUSH
19580: LD_LOC 17
19584: PUSH
19585: LD_VAR 0 1
19589: ARRAY
19590: DIFF
19591: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19592: LD_ADDR_EXP 71
19596: PUSH
19597: LD_EXP 71
19601: PPUSH
19602: LD_VAR 0 1
19606: PPUSH
19607: CALL_OW 3
19611: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19612: LD_ADDR_EXP 71
19616: PUSH
19617: LD_EXP 71
19621: PPUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: LD_VAR 0 3
19631: PPUSH
19632: CALL_OW 2
19636: ST_TO_ADDR
// ComReturn ( docs [ side ] ) ;
19637: LD_LOC 17
19641: PUSH
19642: LD_VAR 0 1
19646: ARRAY
19647: PPUSH
19648: CALL_OW 144
// docs := Delete ( docs , side ) ;
19652: LD_ADDR_LOC 17
19656: PUSH
19657: LD_LOC 17
19661: PPUSH
19662: LD_VAR 0 1
19666: PPUSH
19667: CALL_OW 3
19671: ST_TO_ADDR
// docs := Insert ( docs , side , [ ] ) ;
19672: LD_ADDR_LOC 17
19676: PUSH
19677: LD_LOC 17
19681: PPUSH
19682: LD_VAR 0 1
19686: PPUSH
19687: EMPTY
19688: PPUSH
19689: CALL_OW 2
19693: ST_TO_ADDR
// end ; end ;
19694: GO 19261
19696: POP
19697: POP
// enable ;
19698: ENABLE
// end ;
19699: PPOPN 5
19701: END
// every 0 0$3.1 do var list , self ;
19702: GO 19704
19704: DISABLE
19705: LD_INT 0
19707: PPUSH
19708: PPUSH
// begin list := FilterUnitsInArea ( ar_base , [ [ f_side , you ] , [ f_ok ] ] ) ;
19709: LD_ADDR_VAR 0 1
19713: PUSH
19714: LD_INT 13
19716: PPUSH
19717: LD_INT 22
19719: PUSH
19720: LD_EXP 1
19724: PUSH
19725: EMPTY
19726: LIST
19727: LIST
19728: PUSH
19729: LD_INT 50
19731: PUSH
19732: EMPTY
19733: LIST
19734: PUSH
19735: EMPTY
19736: LIST
19737: LIST
19738: PPUSH
19739: CALL_OW 70
19743: ST_TO_ADDR
// if list then
19744: LD_VAR 0 1
19748: IFFALSE 19845
// begin self := FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_vehicle ] , [ f_weapon , ar_selfpropelled_bomb ] ] ) ;
19750: LD_ADDR_VAR 0 2
19754: PUSH
19755: LD_INT 22
19757: PUSH
19758: LD_EXP 4
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PUSH
19767: LD_INT 21
19769: PUSH
19770: LD_INT 2
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: PUSH
19777: LD_INT 34
19779: PUSH
19780: LD_INT 29
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: LIST
19791: PPUSH
19792: CALL_OW 69
19796: ST_TO_ADDR
// if self then
19797: LD_VAR 0 2
19801: IFFALSE 19819
// self := self [ 1 ] else
19803: LD_ADDR_VAR 0 2
19807: PUSH
19808: LD_VAR 0 2
19812: PUSH
19813: LD_INT 1
19815: ARRAY
19816: ST_TO_ADDR
19817: GO 19821
// exit ;
19819: GO 19846
// ComAttackUnit ( self , NearestUnitToUnit ( list , self ) ) ;
19821: LD_VAR 0 2
19825: PPUSH
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_VAR 0 2
19835: PPUSH
19836: CALL_OW 74
19840: PPUSH
19841: CALL_OW 115
// ; end ; enable ;
19845: ENABLE
// end ;
19846: PPOPN 2
19848: END
// every 0 0$3 do var side , list ;
19849: GO 19851
19851: DISABLE
19852: LD_INT 0
19854: PPUSH
19855: PPUSH
// begin for side in cpu_list do
19856: LD_ADDR_VAR 0 1
19860: PUSH
19861: LD_EXP 8
19865: PUSH
19866: FOR_IN
19867: IFFALSE 19956
// if side then
19869: LD_VAR 0 1
19873: IFFALSE 19954
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 800 ] ] ) diff healing_un ;
19875: LD_ADDR_VAR 0 2
19879: PUSH
19880: LD_INT 22
19882: PUSH
19883: LD_VAR 0 1
19887: PUSH
19888: EMPTY
19889: LIST
19890: LIST
19891: PUSH
19892: LD_INT 21
19894: PUSH
19895: LD_INT 1
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: PUSH
19902: LD_INT 3
19904: PUSH
19905: LD_INT 24
19907: PUSH
19908: LD_INT 800
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: LIST
19919: LIST
19920: PPUSH
19921: CALL_OW 69
19925: PUSH
19926: LD_LOC 18
19930: DIFF
19931: ST_TO_ADDR
// if list then
19932: LD_VAR 0 2
19936: IFFALSE 19954
// wounded_un := wounded_un ^ list ;
19938: LD_ADDR_LOC 19
19942: PUSH
19943: LD_LOC 19
19947: PUSH
19948: LD_VAR 0 2
19952: ADD
19953: ST_TO_ADDR
// end ;
19954: GO 19866
19956: POP
19957: POP
// enable ;
19958: ENABLE
// end ;
19959: PPOPN 2
19961: END
// every 0 0$2 do var list , un ;
19962: GO 19964
19964: DISABLE
19965: LD_INT 0
19967: PPUSH
19968: PPUSH
// begin for un in wounded_un do
19969: LD_ADDR_VAR 0 2
19973: PUSH
19974: LD_LOC 19
19978: PUSH
19979: FOR_IN
19980: IFFALSE 20066
// if not ( un in healing_un ) then
19982: LD_VAR 0 2
19986: PUSH
19987: LD_LOC 18
19991: IN
19992: NOT
19993: IFFALSE 20064
// begin healing_un := healing_un ^ un ;
19995: LD_ADDR_LOC 18
19999: PUSH
20000: LD_LOC 18
20004: PUSH
20005: LD_VAR 0 2
20009: ADD
20010: ST_TO_ADDR
// McCustom ( 100 , un ) ;
20011: LD_INT 100
20013: PPUSH
20014: LD_VAR 0 2
20018: PPUSH
20019: CALL_OW 416
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20023: LD_VAR 0 2
20027: PPUSH
20028: LD_LOC 16
20032: PUSH
20033: LD_VAR 0 2
20037: PPUSH
20038: CALL_OW 255
20042: ARRAY
20043: PPUSH
20044: CALL_OW 113
// wounded_un := wounded_un diff un ;
20048: LD_ADDR_LOC 19
20052: PUSH
20053: LD_LOC 19
20057: PUSH
20058: LD_VAR 0 2
20062: DIFF
20063: ST_TO_ADDR
// end ;
20064: GO 19979
20066: POP
20067: POP
// enable ;
20068: ENABLE
// end ;
20069: PPOPN 2
20071: END
// every 0 0$2 + 0 0$1 do var un ;
20072: GO 20074
20074: DISABLE
20075: LD_INT 0
20077: PPUSH
// begin for un in healing_un do
20078: LD_ADDR_VAR 0 1
20082: PUSH
20083: LD_LOC 18
20087: PUSH
20088: FOR_IN
20089: IFFALSE 20193
// if GetLives ( un ) = 1000 then
20091: LD_VAR 0 1
20095: PPUSH
20096: CALL_OW 256
20100: PUSH
20101: LD_INT 1000
20103: EQUAL
20104: IFFALSE 20138
// begin KillMc ( GetUnitMc ( un ) ) ;
20106: LD_VAR 0 1
20110: PPUSH
20111: CALL_OW 388
20115: PPUSH
20116: CALL_OW 387
// healing_un := healing_un diff un ;
20120: LD_ADDR_LOC 18
20124: PUSH
20125: LD_LOC 18
20129: PUSH
20130: LD_VAR 0 1
20134: DIFF
20135: ST_TO_ADDR
// end else
20136: GO 20191
// if not IsInArea ( un , Heal [ GetSide ( un ) ] ) then
20138: LD_VAR 0 1
20142: PPUSH
20143: LD_LOC 16
20147: PUSH
20148: LD_VAR 0 1
20152: PPUSH
20153: CALL_OW 255
20157: ARRAY
20158: PPUSH
20159: CALL_OW 308
20163: NOT
20164: IFFALSE 20191
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20166: LD_VAR 0 1
20170: PPUSH
20171: LD_LOC 16
20175: PUSH
20176: LD_VAR 0 1
20180: PPUSH
20181: CALL_OW 255
20185: ARRAY
20186: PPUSH
20187: CALL_OW 113
20191: GO 20088
20193: POP
20194: POP
// enable ;
20195: ENABLE
// end ;
20196: PPOPN 1
20198: END
// function SendForces ( side ) ; var un , list , target , defenders ; begin
20199: LD_INT 0
20201: PPUSH
20202: PPUSH
20203: PPUSH
20204: PPUSH
20205: PPUSH
// ComRemember ( defend_forces [ side ] ) ;
20206: LD_EXP 68
20210: PUSH
20211: LD_VAR 0 1
20215: ARRAY
20216: PPUSH
20217: CALL_OW 143
// if ExistMc ( mc_id_defend ) then
20221: LD_LOC 21
20225: PPUSH
20226: CALL_OW 386
20230: IFFALSE 20241
// KillMc ( mc_id_defend ) ;
20232: LD_LOC 21
20236: PPUSH
20237: CALL_OW 387
// mc_id_defend := McCustom ( 500 , defend_forces [ side ] ) ;
20241: LD_ADDR_LOC 21
20245: PUSH
20246: LD_INT 500
20248: PPUSH
20249: LD_EXP 68
20253: PUSH
20254: LD_VAR 0 1
20258: ARRAY
20259: PPUSH
20260: CALL_OW 416
20264: ST_TO_ADDR
// wait ( 1 ) ;
20265: LD_INT 1
20267: PPUSH
20268: CALL_OW 67
// repeat list := FilterUnitsInArea ( DefendArea [ side ] , [ [ f_side , you ] , [ f_ok ] ] ) ;
20272: LD_ADDR_VAR 0 4
20276: PUSH
20277: LD_LOC 15
20281: PUSH
20282: LD_VAR 0 1
20286: ARRAY
20287: PPUSH
20288: LD_INT 22
20290: PUSH
20291: LD_EXP 1
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 50
20302: PUSH
20303: EMPTY
20304: LIST
20305: PUSH
20306: EMPTY
20307: LIST
20308: LIST
20309: PPUSH
20310: CALL_OW 70
20314: ST_TO_ADDR
// target := NearestUnitToXY ( list , central_base [ side ] [ 1 ] , central_base [ side ] [ 2 ] ) ;
20315: LD_ADDR_VAR 0 5
20319: PUSH
20320: LD_VAR 0 4
20324: PPUSH
20325: LD_LOC 20
20329: PUSH
20330: LD_VAR 0 1
20334: ARRAY
20335: PUSH
20336: LD_INT 1
20338: ARRAY
20339: PPUSH
20340: LD_LOC 20
20344: PUSH
20345: LD_VAR 0 1
20349: ARRAY
20350: PUSH
20351: LD_INT 2
20353: ARRAY
20354: PPUSH
20355: CALL_OW 73
20359: ST_TO_ADDR
// defenders := prepare_defend ( side ) ;
20360: LD_ADDR_VAR 0 6
20364: PUSH
20365: LD_VAR 0 1
20369: PPUSH
20370: CALL 18437 0 1
20374: ST_TO_ADDR
// if list = 0 or defenders = 0 then
20375: LD_VAR 0 4
20379: PUSH
20380: LD_INT 0
20382: EQUAL
20383: PUSH
20384: LD_VAR 0 6
20388: PUSH
20389: LD_INT 0
20391: EQUAL
20392: OR
20393: IFFALSE 20397
// break ;
20395: GO 20512
// for un in defenders do
20397: LD_ADDR_VAR 0 3
20401: PUSH
20402: LD_VAR 0 6
20406: PUSH
20407: FOR_IN
20408: IFFALSE 20499
// if GetWeapon ( un ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ru_rocket ] then
20410: LD_VAR 0 3
20414: PPUSH
20415: CALL_OW 264
20419: PUSH
20420: LD_INT 7
20422: PUSH
20423: LD_INT 28
20425: PUSH
20426: LD_INT 45
20428: PUSH
20429: LD_INT 47
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: IN
20438: IFFALSE 20477
// ComAttackPlace ( defend_forces [ side ] , GetX ( target ) , GetY ( target ) ) else
20440: LD_EXP 68
20444: PUSH
20445: LD_VAR 0 1
20449: ARRAY
20450: PPUSH
20451: LD_VAR 0 5
20455: PPUSH
20456: CALL_OW 250
20460: PPUSH
20461: LD_VAR 0 5
20465: PPUSH
20466: CALL_OW 251
20470: PPUSH
20471: CALL_OW 116
20475: GO 20497
// ComAttackUnit ( defend_forces [ side ] , target ) ;
20477: LD_EXP 68
20481: PUSH
20482: LD_VAR 0 1
20486: ARRAY
20487: PPUSH
20488: LD_VAR 0 5
20492: PPUSH
20493: CALL_OW 115
20497: GO 20407
20499: POP
20500: POP
// wait ( 50 ) ;
20501: LD_INT 50
20503: PPUSH
20504: CALL_OW 67
// until false ;
20508: LD_INT 0
20510: IFFALSE 20272
// KillMc ( mc_id_defend ) ;
20512: LD_LOC 21
20516: PPUSH
20517: CALL_OW 387
// mc_id_defend := false ;
20521: LD_ADDR_LOC 21
20525: PUSH
20526: LD_INT 0
20528: ST_TO_ADDR
// wait ( 2 ) ;
20529: LD_INT 2
20531: PPUSH
20532: CALL_OW 67
// ComReturn ( defend_forces [ side ] ) ;
20536: LD_EXP 68
20540: PUSH
20541: LD_VAR 0 1
20545: ARRAY
20546: PPUSH
20547: CALL_OW 144
// end ;
20551: LD_VAR 0 2
20555: RET
// every 0 0$5.1 do var side ;
20556: GO 20558
20558: DISABLE
20559: LD_INT 0
20561: PPUSH
// begin for side = 1 to 3 do
20562: LD_ADDR_VAR 0 1
20566: PUSH
20567: DOUBLE
20568: LD_INT 1
20570: DEC
20571: ST_TO_ADDR
20572: LD_INT 3
20574: PUSH
20575: FOR_TO
20576: IFFALSE 20778
// if ( not defend_forces [ side ] ) and ready_forces [ side ] then
20578: LD_EXP 68
20582: PUSH
20583: LD_VAR 0 1
20587: ARRAY
20588: NOT
20589: PUSH
20590: LD_EXP 65
20594: PUSH
20595: LD_VAR 0 1
20599: ARRAY
20600: AND
20601: IFFALSE 20776
// begin defend_forces := Replace ( defend_forces , side , ready_forces [ side ] ) ;
20603: LD_ADDR_EXP 68
20607: PUSH
20608: LD_EXP 68
20612: PPUSH
20613: LD_VAR 0 1
20617: PPUSH
20618: LD_EXP 65
20622: PUSH
20623: LD_VAR 0 1
20627: ARRAY
20628: PPUSH
20629: CALL_OW 1
20633: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
20634: LD_ADDR_EXP 65
20638: PUSH
20639: LD_EXP 65
20643: PPUSH
20644: LD_VAR 0 1
20648: PPUSH
20649: EMPTY
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// jammed_forces := Replace ( jammed_forces , side , jammed_forces [ side ] diff defend_forces [ side ] ) ;
20656: LD_ADDR_EXP 69
20660: PUSH
20661: LD_EXP 69
20665: PPUSH
20666: LD_VAR 0 1
20670: PPUSH
20671: LD_EXP 69
20675: PUSH
20676: LD_VAR 0 1
20680: ARRAY
20681: PUSH
20682: LD_EXP 68
20686: PUSH
20687: LD_VAR 0 1
20691: ARRAY
20692: DIFF
20693: PPUSH
20694: CALL_OW 1
20698: ST_TO_ADDR
// case side of 1 :
20699: LD_VAR 0 1
20703: PUSH
20704: LD_INT 1
20706: DOUBLE
20707: EQUAL
20708: IFTRUE 20712
20710: GO 20736
20712: POP
// ComMoveXY ( defend_forces [ side ] , 40 , 46 ) ; 3 :
20713: LD_EXP 68
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PPUSH
20724: LD_INT 40
20726: PPUSH
20727: LD_INT 46
20729: PPUSH
20730: CALL_OW 111
20734: GO 20769
20736: LD_INT 3
20738: DOUBLE
20739: EQUAL
20740: IFTRUE 20744
20742: GO 20768
20744: POP
// ComMoveXY ( defend_forces [ side ] , 175 , 50 ) ; end ;
20745: LD_EXP 68
20749: PUSH
20750: LD_VAR 0 1
20754: ARRAY
20755: PPUSH
20756: LD_INT 175
20758: PPUSH
20759: LD_INT 50
20761: PPUSH
20762: CALL_OW 111
20766: GO 20769
20768: POP
// wait ( 2 ) ;
20769: LD_INT 2
20771: PPUSH
20772: CALL_OW 67
// end ;
20776: GO 20575
20778: POP
20779: POP
// enable ;
20780: ENABLE
// end ;
20781: PPOPN 1
20783: END
// export function Update_defend ( un ) ; var side ; begin
20784: LD_INT 0
20786: PPUSH
20787: PPUSH
// if GetSide ( un ) = you then
20788: LD_VAR 0 1
20792: PPUSH
20793: CALL_OW 255
20797: PUSH
20798: LD_EXP 1
20802: EQUAL
20803: IFFALSE 20807
// exit ;
20805: GO 20882
// for side = 1 to 3 do
20807: LD_ADDR_VAR 0 3
20811: PUSH
20812: DOUBLE
20813: LD_INT 1
20815: DEC
20816: ST_TO_ADDR
20817: LD_INT 3
20819: PUSH
20820: FOR_TO
20821: IFFALSE 20880
// if un in defend_forces [ side ] then
20823: LD_VAR 0 1
20827: PUSH
20828: LD_EXP 68
20832: PUSH
20833: LD_VAR 0 3
20837: ARRAY
20838: IN
20839: IFFALSE 20878
// defend_forces := Replace ( defend_forces , side , defend_forces [ side ] diff un ) ;
20841: LD_ADDR_EXP 68
20845: PUSH
20846: LD_EXP 68
20850: PPUSH
20851: LD_VAR 0 3
20855: PPUSH
20856: LD_EXP 68
20860: PUSH
20861: LD_VAR 0 3
20865: ARRAY
20866: PUSH
20867: LD_VAR 0 1
20871: DIFF
20872: PPUSH
20873: CALL_OW 1
20877: ST_TO_ADDR
20878: GO 20820
20880: POP
20881: POP
// end ; end_of_file
20882: LD_VAR 0 2
20886: RET
// export ready_forces , attack_forces , retreat_forces , defend_forces , jammed_forces ; var us_ru , us_ar , ru_us , ru_ar ; var last_ar_attack , attack_timing , attack_limit ; var al_eliminate ; var pocet_odebrani ; export function init_attack ; var side ; begin
20887: LD_INT 0
20889: PPUSH
20890: PPUSH
// ready_forces = [ ] ;
20891: LD_ADDR_EXP 65
20895: PUSH
20896: EMPTY
20897: ST_TO_ADDR
// attack_forces = [ ] ;
20898: LD_ADDR_EXP 66
20902: PUSH
20903: EMPTY
20904: ST_TO_ADDR
// retreat_forces = [ ] ;
20905: LD_ADDR_EXP 67
20909: PUSH
20910: EMPTY
20911: ST_TO_ADDR
// defend_forces = [ ] ;
20912: LD_ADDR_EXP 68
20916: PUSH
20917: EMPTY
20918: ST_TO_ADDR
// for side = 1 to 8 do
20919: LD_ADDR_VAR 0 2
20923: PUSH
20924: DOUBLE
20925: LD_INT 1
20927: DEC
20928: ST_TO_ADDR
20929: LD_INT 8
20931: PUSH
20932: FOR_TO
20933: IFFALSE 21017
// begin ready_forces = ready_forces ^ [ [ ] ] ;
20935: LD_ADDR_EXP 65
20939: PUSH
20940: LD_EXP 65
20944: PUSH
20945: EMPTY
20946: PUSH
20947: EMPTY
20948: LIST
20949: ADD
20950: ST_TO_ADDR
// attack_forces = attack_forces ^ [ [ ] ] ;
20951: LD_ADDR_EXP 66
20955: PUSH
20956: LD_EXP 66
20960: PUSH
20961: EMPTY
20962: PUSH
20963: EMPTY
20964: LIST
20965: ADD
20966: ST_TO_ADDR
// retreat_forces = retreat_forces ^ [ [ ] ] ;
20967: LD_ADDR_EXP 67
20971: PUSH
20972: LD_EXP 67
20976: PUSH
20977: EMPTY
20978: PUSH
20979: EMPTY
20980: LIST
20981: ADD
20982: ST_TO_ADDR
// defend_forces = defend_forces ^ [ [ ] ] ;
20983: LD_ADDR_EXP 68
20987: PUSH
20988: LD_EXP 68
20992: PUSH
20993: EMPTY
20994: PUSH
20995: EMPTY
20996: LIST
20997: ADD
20998: ST_TO_ADDR
// jammed_forces = jammed_forces ^ [ [ ] ] ;
20999: LD_ADDR_EXP 69
21003: PUSH
21004: LD_EXP 69
21008: PUSH
21009: EMPTY
21010: PUSH
21011: EMPTY
21012: LIST
21013: ADD
21014: ST_TO_ADDR
// end ;
21015: GO 20932
21017: POP
21018: POP
// us_ru := [ [ 76 , 61 ] , [ 121 , 55 ] , [ 171 , 59 ] , [ 190 , 90 ] ] ;
21019: LD_ADDR_LOC 22
21023: PUSH
21024: LD_INT 76
21026: PUSH
21027: LD_INT 61
21029: PUSH
21030: EMPTY
21031: LIST
21032: LIST
21033: PUSH
21034: LD_INT 121
21036: PUSH
21037: LD_INT 55
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: PUSH
21044: LD_INT 171
21046: PUSH
21047: LD_INT 59
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: PUSH
21054: LD_INT 190
21056: PUSH
21057: LD_INT 90
21059: PUSH
21060: EMPTY
21061: LIST
21062: LIST
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: LIST
21068: LIST
21069: ST_TO_ADDR
// us_ar := [ [ [ 78 , 69 ] , [ 121 , 116 ] , [ 155 , 137 ] , [ 190 , 170 ] , [ 242 , 187 ] ] , [ [ 72 , 106 ] , [ 111 , 176 ] , [ 163 , 184 ] , [ 215 , 191 ] , [ 242 , 187 ] ] ] ;
21070: LD_ADDR_LOC 23
21074: PUSH
21075: LD_INT 78
21077: PUSH
21078: LD_INT 69
21080: PUSH
21081: EMPTY
21082: LIST
21083: LIST
21084: PUSH
21085: LD_INT 121
21087: PUSH
21088: LD_INT 116
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: PUSH
21095: LD_INT 155
21097: PUSH
21098: LD_INT 137
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: LD_INT 190
21107: PUSH
21108: LD_INT 170
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: PUSH
21115: LD_INT 242
21117: PUSH
21118: LD_INT 187
21120: PUSH
21121: EMPTY
21122: LIST
21123: LIST
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: LIST
21131: PUSH
21132: LD_INT 72
21134: PUSH
21135: LD_INT 106
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PUSH
21142: LD_INT 111
21144: PUSH
21145: LD_INT 176
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PUSH
21152: LD_INT 163
21154: PUSH
21155: LD_INT 184
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: LD_INT 215
21164: PUSH
21165: LD_INT 191
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 242
21174: PUSH
21175: LD_INT 187
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: LIST
21186: LIST
21187: LIST
21188: PUSH
21189: EMPTY
21190: LIST
21191: LIST
21192: ST_TO_ADDR
// ru_us := [ [ 118 , 63 ] , [ 78 , 57 ] , [ 30 , 44 ] , [ 56 , 83 ] ] ;
21193: LD_ADDR_LOC 24
21197: PUSH
21198: LD_INT 118
21200: PUSH
21201: LD_INT 63
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: PUSH
21208: LD_INT 78
21210: PUSH
21211: LD_INT 57
21213: PUSH
21214: EMPTY
21215: LIST
21216: LIST
21217: PUSH
21218: LD_INT 30
21220: PUSH
21221: LD_INT 44
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: PUSH
21228: LD_INT 56
21230: PUSH
21231: LD_INT 83
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: LIST
21243: ST_TO_ADDR
// ru_ar := [ [ [ 142 , 65 ] , [ 160 , 140 ] , [ 255 , 196 ] ] , [ [ 125 , 58 ] , [ 106 , 93 ] , [ 126 , 154 ] , [ 121 , 182 ] , [ 167 , 180 ] , [ 251 , 187 ] ] ] ;
21244: LD_ADDR_LOC 25
21248: PUSH
21249: LD_INT 142
21251: PUSH
21252: LD_INT 65
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: LD_INT 160
21261: PUSH
21262: LD_INT 140
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 255
21271: PUSH
21272: LD_INT 196
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: LIST
21283: PUSH
21284: LD_INT 125
21286: PUSH
21287: LD_INT 58
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: PUSH
21294: LD_INT 106
21296: PUSH
21297: LD_INT 93
21299: PUSH
21300: EMPTY
21301: LIST
21302: LIST
21303: PUSH
21304: LD_INT 126
21306: PUSH
21307: LD_INT 154
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: PUSH
21314: LD_INT 121
21316: PUSH
21317: LD_INT 182
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: PUSH
21324: LD_INT 167
21326: PUSH
21327: LD_INT 180
21329: PUSH
21330: EMPTY
21331: LIST
21332: LIST
21333: PUSH
21334: LD_INT 251
21336: PUSH
21337: LD_INT 187
21339: PUSH
21340: EMPTY
21341: LIST
21342: LIST
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: LIST
21348: LIST
21349: LIST
21350: LIST
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: ST_TO_ADDR
// al_eliminate = [ [ 88 , 53 ] , [ 49 , 10 ] , [ 83 , 13 ] ] ;
21356: LD_ADDR_LOC 29
21360: PUSH
21361: LD_INT 88
21363: PUSH
21364: LD_INT 53
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PUSH
21371: LD_INT 49
21373: PUSH
21374: LD_INT 10
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: PUSH
21381: LD_INT 83
21383: PUSH
21384: LD_INT 13
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: LIST
21395: ST_TO_ADDR
// attack_timing = [ 50 , 40 , 30 ] [ difficulty ] ;
21396: LD_ADDR_LOC 27
21400: PUSH
21401: LD_INT 50
21403: PUSH
21404: LD_INT 40
21406: PUSH
21407: LD_INT 30
21409: PUSH
21410: EMPTY
21411: LIST
21412: LIST
21413: LIST
21414: PUSH
21415: LD_OWVAR 67
21419: ARRAY
21420: ST_TO_ADDR
// attack_limit = 0 ;
21421: LD_ADDR_LOC 28
21425: PUSH
21426: LD_INT 0
21428: ST_TO_ADDR
// last_ar_attack = TICK ;
21429: LD_ADDR_LOC 26
21433: PUSH
21434: LD_OWVAR 1
21438: ST_TO_ADDR
// pocet_odebrani = 0 ;
21439: LD_ADDR_LOC 30
21443: PUSH
21444: LD_INT 0
21446: ST_TO_ADDR
// end ;
21447: LD_VAR 0 1
21451: RET
// every 0 0$15.4 do var active_side , num_forces ;
21452: GO 21454
21454: DISABLE
21455: LD_INT 0
21457: PPUSH
21458: PPUSH
// begin num_forces := define_forces_strenght ;
21459: LD_ADDR_VAR 0 2
21463: PUSH
21464: CALL 21524 0 0
21468: ST_TO_ADDR
// for active_side in cpu_list do
21469: LD_ADDR_VAR 0 1
21473: PUSH
21474: LD_EXP 8
21478: PUSH
21479: FOR_IN
21480: IFFALSE 21518
// if ready_forces [ active_side ] >= num_forces then
21482: LD_EXP 65
21486: PUSH
21487: LD_VAR 0 1
21491: ARRAY
21492: PUSH
21493: LD_VAR 0 2
21497: GREATEREQUAL
21498: IFFALSE 21516
// begin let_the_war_begin ( active_side ) ;
21500: LD_VAR 0 1
21504: PPUSH
21505: CALL 22987 0 1
// wait ( 1 ) ;
21509: LD_INT 1
21511: PPUSH
21512: CALL_OW 67
// end ;
21516: GO 21479
21518: POP
21519: POP
// enable ;
21520: ENABLE
// end ;
21521: PPOPN 2
21523: END
// function define_forces_strenght ; var num ; begin
21524: LD_INT 0
21526: PPUSH
21527: PPUSH
// num := 3 ;
21528: LD_ADDR_VAR 0 2
21532: PUSH
21533: LD_INT 3
21535: ST_TO_ADDR
// if TICK > 7 7$0 then
21536: LD_OWVAR 1
21540: PUSH
21541: LD_INT 14700
21543: GREATER
21544: IFFALSE 21554
// num := 4 ;
21546: LD_ADDR_VAR 0 2
21550: PUSH
21551: LD_INT 4
21553: ST_TO_ADDR
// if TICK > 14 14$0 then
21554: LD_OWVAR 1
21558: PUSH
21559: LD_INT 29400
21561: GREATER
21562: IFFALSE 21572
// num := 6 ;
21564: LD_ADDR_VAR 0 2
21568: PUSH
21569: LD_INT 6
21571: ST_TO_ADDR
// result := num ;
21572: LD_ADDR_VAR 0 1
21576: PUSH
21577: LD_VAR 0 2
21581: ST_TO_ADDR
// end ;
21582: LD_VAR 0 1
21586: RET
// function define_target_priority ; var target ; begin
21587: LD_INT 0
21589: PPUSH
21590: PPUSH
// target := Rand ( 0 , attack_timing ) ;
21591: LD_ADDR_VAR 0 2
21595: PUSH
21596: LD_INT 0
21598: PPUSH
21599: LD_LOC 27
21603: PPUSH
21604: CALL_OW 12
21608: ST_TO_ADDR
// if target > attack_limit then
21609: LD_VAR 0 2
21613: PUSH
21614: LD_LOC 28
21618: GREATER
21619: IFFALSE 21631
// target := false else
21621: LD_ADDR_VAR 0 2
21625: PUSH
21626: LD_INT 0
21628: ST_TO_ADDR
21629: GO 21639
// target := true ;
21631: LD_ADDR_VAR 0 2
21635: PUSH
21636: LD_INT 1
21638: ST_TO_ADDR
// result := target ;
21639: LD_ADDR_VAR 0 1
21643: PUSH
21644: LD_VAR 0 2
21648: ST_TO_ADDR
// end ;
21649: LD_VAR 0 1
21653: RET
// every 1 1$0 trigger attack_timing > attack_limit do
21654: LD_LOC 27
21658: PUSH
21659: LD_LOC 28
21663: GREATER
21664: IFFALSE 21698
21666: GO 21668
21668: DISABLE
// begin attack_timing := attack_timing - 1 ;
21669: LD_ADDR_LOC 27
21673: PUSH
21674: LD_LOC 27
21678: PUSH
21679: LD_INT 1
21681: MINUS
21682: ST_TO_ADDR
// attack_limit := attack_limit + 1 ;
21683: LD_ADDR_LOC 28
21687: PUSH
21688: LD_LOC 28
21692: PUSH
21693: LD_INT 1
21695: PLUS
21696: ST_TO_ADDR
// enable ;
21697: ENABLE
// end ;
21698: END
// function Select_Weakest_Base ( areas ) ; var selected , un , list ; begin
21699: LD_INT 0
21701: PPUSH
21702: PPUSH
21703: PPUSH
21704: PPUSH
// selected := false ;
21705: LD_ADDR_VAR 0 3
21709: PUSH
21710: LD_INT 0
21712: ST_TO_ADDR
// for un in areas do
21713: LD_ADDR_VAR 0 4
21717: PUSH
21718: LD_VAR 0 1
21722: PUSH
21723: FOR_IN
21724: IFFALSE 21851
// begin list := FilterUnitsInArea ( un , [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
21726: LD_ADDR_VAR 0 5
21730: PUSH
21731: LD_VAR 0 4
21735: PPUSH
21736: LD_INT 22
21738: PUSH
21739: LD_EXP 1
21743: PUSH
21744: EMPTY
21745: LIST
21746: LIST
21747: PUSH
21748: LD_INT 21
21750: PUSH
21751: LD_INT 3
21753: PUSH
21754: EMPTY
21755: LIST
21756: LIST
21757: PUSH
21758: LD_INT 2
21760: PUSH
21761: LD_INT 30
21763: PUSH
21764: LD_INT 33
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 30
21773: PUSH
21774: LD_INT 32
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: LIST
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: LIST
21790: PPUSH
21791: CALL_OW 70
21795: ST_TO_ADDR
// if ( not selected ) or ( selected [ 1 ] < list ) then
21796: LD_VAR 0 3
21800: NOT
21801: PUSH
21802: LD_VAR 0 3
21806: PUSH
21807: LD_INT 1
21809: ARRAY
21810: PUSH
21811: LD_VAR 0 5
21815: LESS
21816: OR
21817: IFFALSE 21842
// selected := [ list + 0 , un ] ;
21819: LD_ADDR_VAR 0 3
21823: PUSH
21824: LD_VAR 0 5
21828: PUSH
21829: LD_INT 0
21831: PLUS
21832: PUSH
21833: LD_VAR 0 4
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: ST_TO_ADDR
// wait ( 1 ) ;
21842: LD_INT 1
21844: PPUSH
21845: CALL_OW 67
// end ;
21849: GO 21723
21851: POP
21852: POP
// if selected then
21853: LD_VAR 0 3
21857: IFFALSE 21873
// selected := selected [ 2 ] ;
21859: LD_ADDR_VAR 0 3
21863: PUSH
21864: LD_VAR 0 3
21868: PUSH
21869: LD_INT 2
21871: ARRAY
21872: ST_TO_ADDR
// result := selected ;
21873: LD_ADDR_VAR 0 2
21877: PUSH
21878: LD_VAR 0 3
21882: ST_TO_ADDR
// end ;
21883: LD_VAR 0 2
21887: RET
// function Find_Player_Base ; var list , un , goal , areas , defend_tought ; begin
21888: LD_INT 0
21890: PPUSH
21891: PPUSH
21892: PPUSH
21893: PPUSH
21894: PPUSH
21895: PPUSH
// goal := false ;
21896: LD_ADDR_VAR 0 4
21900: PUSH
21901: LD_INT 0
21903: ST_TO_ADDR
// areas := [ ] ;
21904: LD_ADDR_VAR 0 5
21908: PUSH
21909: EMPTY
21910: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21911: LD_ADDR_VAR 0 2
21915: PUSH
21916: LD_INT 22
21918: PUSH
21919: LD_EXP 1
21923: PUSH
21924: EMPTY
21925: LIST
21926: LIST
21927: PUSH
21928: LD_INT 21
21930: PUSH
21931: LD_INT 3
21933: PUSH
21934: EMPTY
21935: LIST
21936: LIST
21937: PUSH
21938: LD_INT 2
21940: PUSH
21941: LD_INT 30
21943: PUSH
21944: LD_INT 0
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: PUSH
21951: LD_INT 30
21953: PUSH
21954: LD_INT 1
21956: PUSH
21957: EMPTY
21958: LIST
21959: LIST
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: LIST
21965: PUSH
21966: EMPTY
21967: LIST
21968: LIST
21969: LIST
21970: PPUSH
21971: CALL_OW 69
21975: ST_TO_ADDR
// for un in list do
21976: LD_ADDR_VAR 0 3
21980: PUSH
21981: LD_VAR 0 2
21985: PUSH
21986: FOR_IN
21987: IFFALSE 22086
// begin if IsInArea ( un , ar_base ) then
21989: LD_VAR 0 3
21993: PPUSH
21994: LD_INT 13
21996: PPUSH
21997: CALL_OW 308
22001: IFFALSE 22019
// areas := areas ^ ar_base else
22003: LD_ADDR_VAR 0 5
22007: PUSH
22008: LD_VAR 0 5
22012: PUSH
22013: LD_INT 13
22015: ADD
22016: ST_TO_ADDR
22017: GO 22077
// if IsInArea ( un , us_base ) then
22019: LD_VAR 0 3
22023: PPUSH
22024: LD_INT 11
22026: PPUSH
22027: CALL_OW 308
22031: IFFALSE 22049
// areas := areas ^ us_base else
22033: LD_ADDR_VAR 0 5
22037: PUSH
22038: LD_VAR 0 5
22042: PUSH
22043: LD_INT 11
22045: ADD
22046: ST_TO_ADDR
22047: GO 22077
// if IsInArea ( un , ru_base ) then
22049: LD_VAR 0 3
22053: PPUSH
22054: LD_INT 12
22056: PPUSH
22057: CALL_OW 308
22061: IFFALSE 22077
// areas := areas ^ ru_base ;
22063: LD_ADDR_VAR 0 5
22067: PUSH
22068: LD_VAR 0 5
22072: PUSH
22073: LD_INT 12
22075: ADD
22076: ST_TO_ADDR
// wait ( 1 ) ;
22077: LD_INT 1
22079: PPUSH
22080: CALL_OW 67
// end ;
22084: GO 21986
22086: POP
22087: POP
// if ( not areas ) or ( areas > 1 ) then
22088: LD_VAR 0 5
22092: NOT
22093: PUSH
22094: LD_VAR 0 5
22098: PUSH
22099: LD_INT 1
22101: GREATER
22102: OR
22103: IFFALSE 22122
// goal := Select_Weakest_Base ( areas ) else
22105: LD_ADDR_VAR 0 4
22109: PUSH
22110: LD_VAR 0 5
22114: PPUSH
22115: CALL 21699 0 1
22119: ST_TO_ADDR
22120: GO 22136
// goal := areas [ 1 ] ;
22122: LD_ADDR_VAR 0 4
22126: PUSH
22127: LD_VAR 0 5
22131: PUSH
22132: LD_INT 1
22134: ARRAY
22135: ST_TO_ADDR
// result := goal ;
22136: LD_ADDR_VAR 0 1
22140: PUSH
22141: LD_VAR 0 4
22145: ST_TO_ADDR
// end ;
22146: LD_VAR 0 1
22150: RET
// function GetUnitArea ( un ) ; var area ; begin
22151: LD_INT 0
22153: PPUSH
22154: PPUSH
// case un of 1 :
22155: LD_VAR 0 1
22159: PUSH
22160: LD_INT 1
22162: DOUBLE
22163: EQUAL
22164: IFTRUE 22168
22166: GO 22179
22168: POP
// area := us_base ; 2 :
22169: LD_ADDR_VAR 0 3
22173: PUSH
22174: LD_INT 11
22176: ST_TO_ADDR
22177: GO 22218
22179: LD_INT 2
22181: DOUBLE
22182: EQUAL
22183: IFTRUE 22187
22185: GO 22198
22187: POP
// area := ar_base ; 3 :
22188: LD_ADDR_VAR 0 3
22192: PUSH
22193: LD_INT 13
22195: ST_TO_ADDR
22196: GO 22218
22198: LD_INT 3
22200: DOUBLE
22201: EQUAL
22202: IFTRUE 22206
22204: GO 22217
22206: POP
// area := ru_base ; end ;
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_INT 12
22214: ST_TO_ADDR
22215: GO 22218
22217: POP
// result := area ;
22218: LD_ADDR_VAR 0 2
22222: PUSH
22223: LD_VAR 0 3
22227: ST_TO_ADDR
// end ;
22228: LD_VAR 0 2
22232: RET
// function Find_CPU_Target ( side ) ; var un , goal , bases , list ; begin
22233: LD_INT 0
22235: PPUSH
22236: PPUSH
22237: PPUSH
22238: PPUSH
22239: PPUSH
// bases := [ ] ;
22240: LD_ADDR_VAR 0 5
22244: PUSH
22245: EMPTY
22246: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22247: LD_ADDR_VAR 0 6
22251: PUSH
22252: LD_INT 21
22254: PUSH
22255: LD_INT 3
22257: PUSH
22258: EMPTY
22259: LIST
22260: LIST
22261: PUSH
22262: LD_INT 2
22264: PUSH
22265: LD_INT 30
22267: PUSH
22268: LD_INT 0
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: PUSH
22275: LD_INT 30
22277: PUSH
22278: LD_INT 1
22280: PUSH
22281: EMPTY
22282: LIST
22283: LIST
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: LIST
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PPUSH
22294: CALL_OW 69
22298: ST_TO_ADDR
// for un in list do
22299: LD_ADDR_VAR 0 3
22303: PUSH
22304: LD_VAR 0 6
22308: PUSH
22309: FOR_IN
22310: IFFALSE 22352
// if GetSide ( un ) <> side then
22312: LD_VAR 0 3
22316: PPUSH
22317: CALL_OW 255
22321: PUSH
22322: LD_VAR 0 1
22326: NONEQUAL
22327: IFFALSE 22350
// bases := bases ^ GetSide ( un ) ;
22329: LD_ADDR_VAR 0 5
22333: PUSH
22334: LD_VAR 0 5
22338: PUSH
22339: LD_VAR 0 3
22343: PPUSH
22344: CALL_OW 255
22348: ADD
22349: ST_TO_ADDR
22350: GO 22309
22352: POP
22353: POP
// bases := bases diff you ;
22354: LD_ADDR_VAR 0 5
22358: PUSH
22359: LD_VAR 0 5
22363: PUSH
22364: LD_EXP 1
22368: DIFF
22369: ST_TO_ADDR
// if bases then
22370: LD_VAR 0 5
22374: IFFALSE 22458
// begin if ( bases diff ar ) and Rand ( 0 , 2 ) then
22376: LD_VAR 0 5
22380: PUSH
22381: LD_EXP 4
22385: DIFF
22386: PUSH
22387: LD_INT 0
22389: PPUSH
22390: LD_INT 2
22392: PPUSH
22393: CALL_OW 12
22397: AND
22398: IFFALSE 22427
// goal := GetUnitArea ( ( bases diff ar ) [ 1 ] ) else
22400: LD_ADDR_VAR 0 4
22404: PUSH
22405: LD_VAR 0 5
22409: PUSH
22410: LD_EXP 4
22414: DIFF
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: CALL 22151 0 1
22424: ST_TO_ADDR
22425: GO 22456
// goal := GetUnitArea ( bases [ Rand ( 1 , bases ) ] ) ;
22427: LD_ADDR_VAR 0 4
22431: PUSH
22432: LD_VAR 0 5
22436: PUSH
22437: LD_INT 1
22439: PPUSH
22440: LD_VAR 0 5
22444: PPUSH
22445: CALL_OW 12
22449: ARRAY
22450: PPUSH
22451: CALL 22151 0 1
22455: ST_TO_ADDR
// end else
22456: GO 22468
// goal := Find_Player_Base ;
22458: LD_ADDR_VAR 0 4
22462: PUSH
22463: CALL 21888 0 0
22467: ST_TO_ADDR
// result := goal ;
22468: LD_ADDR_VAR 0 2
22472: PUSH
22473: LD_VAR 0 4
22477: ST_TO_ADDR
// end ;
22478: LD_VAR 0 2
22482: RET
// function Wrong_Base ; var un , vysledek ; begin
22483: LD_INT 0
22485: PPUSH
22486: PPUSH
22487: PPUSH
// un := FilterUnitsInArea ( top_area , [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
22488: LD_ADDR_VAR 0 2
22492: PUSH
22493: LD_INT 20
22495: PPUSH
22496: LD_INT 22
22498: PUSH
22499: LD_EXP 1
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: PUSH
22508: LD_INT 21
22510: PUSH
22511: LD_INT 3
22513: PUSH
22514: EMPTY
22515: LIST
22516: LIST
22517: PUSH
22518: EMPTY
22519: LIST
22520: LIST
22521: PPUSH
22522: CALL_OW 70
22526: ST_TO_ADDR
// if un then
22527: LD_VAR 0 2
22531: IFFALSE 22543
// vysledek := true else
22533: LD_ADDR_VAR 0 3
22537: PUSH
22538: LD_INT 1
22540: ST_TO_ADDR
22541: GO 22551
// vysledek := false ;
22543: LD_ADDR_VAR 0 3
22547: PUSH
22548: LD_INT 0
22550: ST_TO_ADDR
// result := vysledek ;
22551: LD_ADDR_VAR 0 1
22555: PUSH
22556: LD_VAR 0 3
22560: ST_TO_ADDR
// end ;
22561: LD_VAR 0 1
22565: RET
// function All_Tracked ( list ) ; var un , vysledek ; begin
22566: LD_INT 0
22568: PPUSH
22569: PPUSH
22570: PPUSH
// vysledek := true ;
22571: LD_ADDR_VAR 0 4
22575: PUSH
22576: LD_INT 1
22578: ST_TO_ADDR
// for un in list do
22579: LD_ADDR_VAR 0 3
22583: PUSH
22584: LD_VAR 0 1
22588: PUSH
22589: FOR_IN
22590: IFFALSE 22630
// if GetChassis ( un ) in [ us_light_wheeled , us_medium_wheeled , ru_medium_wheeled ] then
22592: LD_VAR 0 3
22596: PPUSH
22597: CALL_OW 265
22601: PUSH
22602: LD_INT 1
22604: PUSH
22605: LD_INT 2
22607: PUSH
22608: LD_INT 21
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: LIST
22615: IN
22616: IFFALSE 22628
// begin vysledek := false ;
22618: LD_ADDR_VAR 0 4
22622: PUSH
22623: LD_INT 0
22625: ST_TO_ADDR
// break ;
22626: GO 22630
// end ;
22628: GO 22589
22630: POP
22631: POP
// result := vysledek ;
22632: LD_ADDR_VAR 0 2
22636: PUSH
22637: LD_VAR 0 4
22641: ST_TO_ADDR
// end ;
22642: LD_VAR 0 2
22646: RET
// function Send_US_Forces ( target , side ) ; begin
22647: LD_INT 0
22649: PPUSH
// if target = ar_base then
22650: LD_VAR 0 1
22654: PUSH
22655: LD_INT 13
22657: EQUAL
22658: IFFALSE 22771
// begin if All_tracked ( attack_forces [ side ] ) then
22660: LD_EXP 66
22664: PUSH
22665: LD_VAR 0 2
22669: ARRAY
22670: PPUSH
22671: CALL 22566 0 1
22675: IFFALSE 22724
// McMove ( 15 , attack_forces [ side ] , us_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22677: LD_INT 15
22679: PPUSH
22680: LD_EXP 66
22684: PUSH
22685: LD_VAR 0 2
22689: ARRAY
22690: PPUSH
22691: LD_LOC 23
22695: PUSH
22696: LD_INT 1
22698: ARRAY
22699: PPUSH
22700: LD_INT 3
22702: PUSH
22703: LD_INT 5
22705: PUSH
22706: LD_INT 6
22708: PUSH
22709: LD_INT 7
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: PPUSH
22718: CALL_OW 398
22722: GO 22769
// McMove ( 15 , attack_forces [ side ] , us_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22724: LD_INT 15
22726: PPUSH
22727: LD_EXP 66
22731: PUSH
22732: LD_VAR 0 2
22736: ARRAY
22737: PPUSH
22738: LD_LOC 23
22742: PUSH
22743: LD_INT 2
22745: ARRAY
22746: PPUSH
22747: LD_INT 3
22749: PUSH
22750: LD_INT 5
22752: PUSH
22753: LD_INT 6
22755: PUSH
22756: LD_INT 7
22758: PUSH
22759: EMPTY
22760: LIST
22761: LIST
22762: LIST
22763: LIST
22764: PPUSH
22765: CALL_OW 398
// end else
22769: GO 22812
// McMove ( 15 , attack_forces [ side ] , us_ru , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22771: LD_INT 15
22773: PPUSH
22774: LD_EXP 66
22778: PUSH
22779: LD_VAR 0 2
22783: ARRAY
22784: PPUSH
22785: LD_LOC 22
22789: PPUSH
22790: LD_INT 3
22792: PUSH
22793: LD_INT 5
22795: PUSH
22796: LD_INT 6
22798: PUSH
22799: LD_INT 7
22801: PUSH
22802: EMPTY
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: PPUSH
22808: CALL_OW 398
// end ;
22812: LD_VAR 0 3
22816: RET
// function Send_RU_Forces ( target , side ) ; begin
22817: LD_INT 0
22819: PPUSH
// if target = ar_base then
22820: LD_VAR 0 1
22824: PUSH
22825: LD_INT 13
22827: EQUAL
22828: IFFALSE 22941
// begin if All_tracked ( attack_forces [ side ] ) then
22830: LD_EXP 66
22834: PUSH
22835: LD_VAR 0 2
22839: ARRAY
22840: PPUSH
22841: CALL 22566 0 1
22845: IFFALSE 22894
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22847: LD_INT 15
22849: PPUSH
22850: LD_EXP 66
22854: PUSH
22855: LD_VAR 0 2
22859: ARRAY
22860: PPUSH
22861: LD_LOC 25
22865: PUSH
22866: LD_INT 1
22868: ARRAY
22869: PPUSH
22870: LD_INT 3
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: LD_INT 6
22878: PUSH
22879: LD_INT 7
22881: PUSH
22882: EMPTY
22883: LIST
22884: LIST
22885: LIST
22886: LIST
22887: PPUSH
22888: CALL_OW 398
22892: GO 22939
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22894: LD_INT 15
22896: PPUSH
22897: LD_EXP 66
22901: PUSH
22902: LD_VAR 0 2
22906: ARRAY
22907: PPUSH
22908: LD_LOC 25
22912: PUSH
22913: LD_INT 2
22915: ARRAY
22916: PPUSH
22917: LD_INT 3
22919: PUSH
22920: LD_INT 5
22922: PUSH
22923: LD_INT 6
22925: PUSH
22926: LD_INT 7
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: LIST
22933: LIST
22934: PPUSH
22935: CALL_OW 398
// end else
22939: GO 22982
// McMove ( 15 , attack_forces [ side ] , ru_us , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22941: LD_INT 15
22943: PPUSH
22944: LD_EXP 66
22948: PUSH
22949: LD_VAR 0 2
22953: ARRAY
22954: PPUSH
22955: LD_LOC 24
22959: PPUSH
22960: LD_INT 3
22962: PUSH
22963: LD_INT 5
22965: PUSH
22966: LD_INT 6
22968: PUSH
22969: LD_INT 7
22971: PUSH
22972: EMPTY
22973: LIST
22974: LIST
22975: LIST
22976: LIST
22977: PPUSH
22978: CALL_OW 398
// end ;
22982: LD_VAR 0 3
22986: RET
// function let_the_war_begin ( side ) ; var target ; begin
22987: LD_INT 0
22989: PPUSH
22990: PPUSH
// target := false ;
22991: LD_ADDR_VAR 0 3
22995: PUSH
22996: LD_INT 0
22998: ST_TO_ADDR
// if define_target_priority then
22999: CALL 21587 0 0
23003: IFFALSE 23015
// target := Find_Player_Base ;
23005: LD_ADDR_VAR 0 3
23009: PUSH
23010: CALL 21888 0 0
23014: ST_TO_ADDR
// if not target then
23015: LD_VAR 0 3
23019: NOT
23020: IFFALSE 23037
// target := Find_CPU_Target ( side ) ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL 22233 0 1
23036: ST_TO_ADDR
// if not target then
23037: LD_VAR 0 3
23041: NOT
23042: IFFALSE 23046
// exit ;
23044: GO 23269
// attack_forces := Replace ( attack_forces , side , ready_forces [ side ] ) ;
23046: LD_ADDR_EXP 66
23050: PUSH
23051: LD_EXP 66
23055: PPUSH
23056: LD_VAR 0 1
23060: PPUSH
23061: LD_EXP 65
23065: PUSH
23066: LD_VAR 0 1
23070: ARRAY
23071: PPUSH
23072: CALL_OW 1
23076: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
23077: LD_ADDR_EXP 65
23081: PUSH
23082: LD_EXP 65
23086: PPUSH
23087: LD_VAR 0 1
23091: PPUSH
23092: EMPTY
23093: PPUSH
23094: CALL_OW 1
23098: ST_TO_ADDR
// jammed_forces := Insert ( jammed_forces , side , jammed_forces [ side ] ^ attack_forces [ side ] ) ;
23099: LD_ADDR_EXP 69
23103: PUSH
23104: LD_EXP 69
23108: PPUSH
23109: LD_VAR 0 1
23113: PPUSH
23114: LD_EXP 69
23118: PUSH
23119: LD_VAR 0 1
23123: ARRAY
23124: PUSH
23125: LD_EXP 66
23129: PUSH
23130: LD_VAR 0 1
23134: ARRAY
23135: ADD
23136: PPUSH
23137: CALL_OW 2
23141: ST_TO_ADDR
// case side of 1 :
23142: LD_VAR 0 1
23146: PUSH
23147: LD_INT 1
23149: DOUBLE
23150: EQUAL
23151: IFTRUE 23155
23153: GO 23161
23155: POP
// enable ( 222 ) ; 3 :
23156: LD_INT 222
23158: ENABLE_MARKED
23159: GO 23176
23161: LD_INT 3
23163: DOUBLE
23164: EQUAL
23165: IFTRUE 23169
23167: GO 23175
23169: POP
// enable ( 223 ) ; end ;
23170: LD_INT 223
23172: ENABLE_MARKED
23173: GO 23176
23175: POP
// if Wrong_Base then
23176: CALL 22483 0 0
23180: IFFALSE 23213
// McMove ( 15 , attack_forces [ side ] , al_eliminate , [ mc_move_dontcapture ] ) else
23182: LD_INT 15
23184: PPUSH
23185: LD_EXP 66
23189: PUSH
23190: LD_VAR 0 1
23194: ARRAY
23195: PPUSH
23196: LD_LOC 29
23200: PPUSH
23201: LD_INT 5
23203: PUSH
23204: EMPTY
23205: LIST
23206: PPUSH
23207: CALL_OW 398
23211: GO 23269
// case side of 1 :
23213: LD_VAR 0 1
23217: PUSH
23218: LD_INT 1
23220: DOUBLE
23221: EQUAL
23222: IFTRUE 23226
23224: GO 23243
23226: POP
// Send_US_Forces ( target , side ) ; 3 :
23227: LD_VAR 0 3
23231: PPUSH
23232: LD_VAR 0 1
23236: PPUSH
23237: CALL 22647 0 2
23241: GO 23269
23243: LD_INT 3
23245: DOUBLE
23246: EQUAL
23247: IFTRUE 23251
23249: GO 23268
23251: POP
// Send_RU_Forces ( target , side ) ; end ;
23252: LD_VAR 0 3
23256: PPUSH
23257: LD_VAR 0 1
23261: PPUSH
23262: CALL 22817 0 2
23266: GO 23269
23268: POP
// end ;
23269: LD_VAR 0 2
23273: RET
// every 88 marked 222 do var list , late , un , i ;
23274: GO 23276
23276: DISABLE
23277: LD_INT 0
23279: PPUSH
23280: PPUSH
23281: PPUSH
23282: PPUSH
// begin wait ( 1 1$20 ) ;
23283: LD_INT 2800
23285: PPUSH
23286: CALL_OW 67
// list := FilterUnitsInArea ( us_tinny , [ [ f_side , us ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23290: LD_ADDR_VAR 0 1
23294: PUSH
23295: LD_INT 41
23297: PPUSH
23298: LD_INT 22
23300: PUSH
23301: LD_EXP 3
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: PUSH
23310: LD_INT 21
23312: PUSH
23313: LD_INT 2
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: PUSH
23320: LD_INT 50
23322: PUSH
23323: EMPTY
23324: LIST
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: PPUSH
23331: CALL_OW 70
23335: ST_TO_ADDR
// late := jammed_forces [ us ] isect list ;
23336: LD_ADDR_VAR 0 2
23340: PUSH
23341: LD_EXP 69
23345: PUSH
23346: LD_EXP 3
23350: ARRAY
23351: PUSH
23352: LD_VAR 0 1
23356: ISECT
23357: ST_TO_ADDR
// if not late then
23358: LD_VAR 0 2
23362: NOT
23363: IFFALSE 23389
// begin jammed_forces := Replace ( jammed_forces , us , [ ] ) ;
23365: LD_ADDR_EXP 69
23369: PUSH
23370: LD_EXP 69
23374: PPUSH
23375: LD_EXP 3
23379: PPUSH
23380: EMPTY
23381: PPUSH
23382: CALL_OW 1
23386: ST_TO_ADDR
// exit ;
23387: GO 23667
// end ; if FilterUnitsInArea ( us_base , [ [ f_side , you ] ] ) then
23389: LD_INT 11
23391: PPUSH
23392: LD_INT 22
23394: PUSH
23395: LD_EXP 1
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: PUSH
23404: EMPTY
23405: LIST
23406: PPUSH
23407: CALL_OW 70
23411: IFFALSE 23416
// begin enable ;
23413: ENABLE
// exit ;
23414: GO 23667
// end ; for un in late do
23416: LD_ADDR_VAR 0 3
23420: PUSH
23421: LD_VAR 0 2
23425: PUSH
23426: FOR_IN
23427: IFFALSE 23456
// if GetUnitMc ( un ) then
23429: LD_VAR 0 3
23433: PPUSH
23434: CALL_OW 388
23438: IFFALSE 23454
// KillMc ( GetUnitMc ( un ) ) ;
23440: LD_VAR 0 3
23444: PPUSH
23445: CALL_OW 388
23449: PPUSH
23450: CALL_OW 387
23454: GO 23426
23456: POP
23457: POP
// while GetTag ( 83 ) do
23458: LD_INT 83
23460: PPUSH
23461: CALL_OW 110
23465: IFFALSE 23476
// wait ( 0 0$1 ) ;
23467: LD_INT 35
23469: PPUSH
23470: CALL_OW 67
23474: GO 23458
// i := 1 ;
23476: LD_ADDR_VAR 0 4
23480: PUSH
23481: LD_INT 1
23483: ST_TO_ADDR
// for un in jammed_forces [ us ] do
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: LD_EXP 69
23493: PUSH
23494: LD_EXP 3
23498: ARRAY
23499: PUSH
23500: FOR_IN
23501: IFFALSE 23606
// begin if ( i mod 2 ) and not See ( you , un ) then
23503: LD_VAR 0 4
23507: PUSH
23508: LD_INT 2
23510: MOD
23511: PUSH
23512: LD_EXP 1
23516: PPUSH
23517: LD_VAR 0 3
23521: PPUSH
23522: CALL_OW 292
23526: NOT
23527: AND
23528: IFFALSE 23590
// begin jammed_forces := Replace ( jammed_forces , us , jammed_forces [ us ] diff un ) ;
23530: LD_ADDR_EXP 69
23534: PUSH
23535: LD_EXP 69
23539: PPUSH
23540: LD_EXP 3
23544: PPUSH
23545: LD_EXP 69
23549: PUSH
23550: LD_EXP 3
23554: ARRAY
23555: PUSH
23556: LD_VAR 0 3
23560: DIFF
23561: PPUSH
23562: CALL_OW 1
23566: ST_TO_ADDR
// KillUnit ( un ) ;
23567: LD_VAR 0 3
23571: PPUSH
23572: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23576: LD_ADDR_LOC 30
23580: PUSH
23581: LD_LOC 30
23585: PUSH
23586: LD_INT 1
23588: PLUS
23589: ST_TO_ADDR
// end ; i := i + 1 ;
23590: LD_ADDR_VAR 0 4
23594: PUSH
23595: LD_VAR 0 4
23599: PUSH
23600: LD_INT 1
23602: PLUS
23603: ST_TO_ADDR
// end ;
23604: GO 23500
23606: POP
23607: POP
// wait ( 0 0$10 ) ;
23608: LD_INT 350
23610: PPUSH
23611: CALL_OW 67
// ready_forces := Replace ( ready_forces , us , ready_forces [ us ] union jammed_forces [ us ] ) ;
23615: LD_ADDR_EXP 65
23619: PUSH
23620: LD_EXP 65
23624: PPUSH
23625: LD_EXP 3
23629: PPUSH
23630: LD_EXP 65
23634: PUSH
23635: LD_EXP 3
23639: ARRAY
23640: PUSH
23641: LD_EXP 69
23645: PUSH
23646: LD_EXP 3
23650: ARRAY
23651: UNION
23652: PPUSH
23653: CALL_OW 1
23657: ST_TO_ADDR
// let_the_war_begin ( us ) ;
23658: LD_EXP 3
23662: PPUSH
23663: CALL 22987 0 1
// end ;
23667: PPOPN 4
23669: END
// every 91 marked 223 do var list , late , un , i ;
23670: GO 23672
23672: DISABLE
23673: LD_INT 0
23675: PPUSH
23676: PPUSH
23677: PPUSH
23678: PPUSH
// begin wait ( 1 1$20 ) ;
23679: LD_INT 2800
23681: PPUSH
23682: CALL_OW 67
// list := FilterUnitsInArea ( ru_tinny , [ [ f_side , ru ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23686: LD_ADDR_VAR 0 1
23690: PUSH
23691: LD_INT 40
23693: PPUSH
23694: LD_INT 22
23696: PUSH
23697: LD_EXP 2
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PUSH
23706: LD_INT 21
23708: PUSH
23709: LD_INT 2
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: PUSH
23716: LD_INT 50
23718: PUSH
23719: EMPTY
23720: LIST
23721: PUSH
23722: EMPTY
23723: LIST
23724: LIST
23725: LIST
23726: PPUSH
23727: CALL_OW 70
23731: ST_TO_ADDR
// late := jammed_forces [ ru ] isect list ;
23732: LD_ADDR_VAR 0 2
23736: PUSH
23737: LD_EXP 69
23741: PUSH
23742: LD_EXP 2
23746: ARRAY
23747: PUSH
23748: LD_VAR 0 1
23752: ISECT
23753: ST_TO_ADDR
// if not late then
23754: LD_VAR 0 2
23758: NOT
23759: IFFALSE 23785
// begin jammed_forces := Replace ( jammed_forces , ru , [ ] ) ;
23761: LD_ADDR_EXP 69
23765: PUSH
23766: LD_EXP 69
23770: PPUSH
23771: LD_EXP 2
23775: PPUSH
23776: EMPTY
23777: PPUSH
23778: CALL_OW 1
23782: ST_TO_ADDR
// exit ;
23783: GO 24063
// end ; if FilterUnitsInArea ( ru_base , [ [ f_side , you ] ] ) then
23785: LD_INT 12
23787: PPUSH
23788: LD_INT 22
23790: PUSH
23791: LD_EXP 1
23795: PUSH
23796: EMPTY
23797: LIST
23798: LIST
23799: PUSH
23800: EMPTY
23801: LIST
23802: PPUSH
23803: CALL_OW 70
23807: IFFALSE 23812
// begin enable ;
23809: ENABLE
// exit ;
23810: GO 24063
// end ; for un in late do
23812: LD_ADDR_VAR 0 3
23816: PUSH
23817: LD_VAR 0 2
23821: PUSH
23822: FOR_IN
23823: IFFALSE 23852
// if GetUnitMc ( un ) then
23825: LD_VAR 0 3
23829: PPUSH
23830: CALL_OW 388
23834: IFFALSE 23850
// KillMc ( GetUnitMc ( un ) ) ;
23836: LD_VAR 0 3
23840: PPUSH
23841: CALL_OW 388
23845: PPUSH
23846: CALL_OW 387
23850: GO 23822
23852: POP
23853: POP
// while GetTag ( 83 ) do
23854: LD_INT 83
23856: PPUSH
23857: CALL_OW 110
23861: IFFALSE 23872
// wait ( 0 0$1 ) ;
23863: LD_INT 35
23865: PPUSH
23866: CALL_OW 67
23870: GO 23854
// i := 1 ;
23872: LD_ADDR_VAR 0 4
23876: PUSH
23877: LD_INT 1
23879: ST_TO_ADDR
// for un in jammed_forces [ ru ] do
23880: LD_ADDR_VAR 0 3
23884: PUSH
23885: LD_EXP 69
23889: PUSH
23890: LD_EXP 2
23894: ARRAY
23895: PUSH
23896: FOR_IN
23897: IFFALSE 24002
// begin if ( i mod 2 ) and not See ( you , un ) then
23899: LD_VAR 0 4
23903: PUSH
23904: LD_INT 2
23906: MOD
23907: PUSH
23908: LD_EXP 1
23912: PPUSH
23913: LD_VAR 0 3
23917: PPUSH
23918: CALL_OW 292
23922: NOT
23923: AND
23924: IFFALSE 23986
// begin jammed_forces := Replace ( jammed_forces , ru , jammed_forces [ ru ] diff un ) ;
23926: LD_ADDR_EXP 69
23930: PUSH
23931: LD_EXP 69
23935: PPUSH
23936: LD_EXP 2
23940: PPUSH
23941: LD_EXP 69
23945: PUSH
23946: LD_EXP 2
23950: ARRAY
23951: PUSH
23952: LD_VAR 0 3
23956: DIFF
23957: PPUSH
23958: CALL_OW 1
23962: ST_TO_ADDR
// KillUnit ( un ) ;
23963: LD_VAR 0 3
23967: PPUSH
23968: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23972: LD_ADDR_LOC 30
23976: PUSH
23977: LD_LOC 30
23981: PUSH
23982: LD_INT 1
23984: PLUS
23985: ST_TO_ADDR
// end ; i := i + 1 ;
23986: LD_ADDR_VAR 0 4
23990: PUSH
23991: LD_VAR 0 4
23995: PUSH
23996: LD_INT 1
23998: PLUS
23999: ST_TO_ADDR
// end ;
24000: GO 23896
24002: POP
24003: POP
// wait ( 0 0$10 ) ;
24004: LD_INT 350
24006: PPUSH
24007: CALL_OW 67
// ready_forces := Replace ( ready_forces , ru , ready_forces [ ru ] union jammed_forces [ ru ] ) ;
24011: LD_ADDR_EXP 65
24015: PUSH
24016: LD_EXP 65
24020: PPUSH
24021: LD_EXP 2
24025: PPUSH
24026: LD_EXP 65
24030: PUSH
24031: LD_EXP 2
24035: ARRAY
24036: PUSH
24037: LD_EXP 69
24041: PUSH
24042: LD_EXP 2
24046: ARRAY
24047: UNION
24048: PPUSH
24049: CALL_OW 1
24053: ST_TO_ADDR
// let_the_war_begin ( ru ) ;
24054: LD_EXP 2
24058: PPUSH
24059: CALL 22987 0 1
// end ; end_of_file
24063: PPOPN 4
24065: END
// var tech_list , weap_list , sib_list , comp_list , opto_list , bio_list , space_list ; var utech_basic , utech_weap , utech_sib , utech_comp , utech_bio , utech_space , utech_opto ; var basic_tech , upgrade_tech ; var first_technology , last_technology , recomended_technology ; export scientistic_wanted ; var all_invented ; export function init_research ; begin
24066: LD_INT 0
24068: PPUSH
// all_invented := [ false , false , false , false , false , false , false , false ] ;
24069: LD_ADDR_LOC 50
24073: PUSH
24074: LD_INT 0
24076: PUSH
24077: LD_INT 0
24079: PUSH
24080: LD_INT 0
24082: PUSH
24083: LD_INT 0
24085: PUSH
24086: LD_INT 0
24088: PUSH
24089: LD_INT 0
24091: PUSH
24092: LD_INT 0
24094: PUSH
24095: LD_INT 0
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: ST_TO_ADDR
// tech_list := [ tech_SolPow , tech_SolEng , tech_OilPow , tech_OilEng , tech_SibDet , tech_ApeLang , tech_ApePsych , tech_ApeAgres ] ;
24108: LD_ADDR_LOC 31
24112: PUSH
24113: LD_INT 35
24115: PUSH
24116: LD_INT 45
24118: PUSH
24119: LD_INT 46
24121: PUSH
24122: LD_INT 47
24124: PUSH
24125: LD_INT 20
24127: PUSH
24128: LD_INT 1
24130: PUSH
24131: LD_INT 2
24133: PUSH
24134: LD_INT 11
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: LIST
24146: ST_TO_ADDR
// weap_list := [ tech_Gatling , tech_Gun , tech_Explos , tech_AdvMet , tech_Rocket , tech_AdvRocket , tech_Bazooka , tech_Mortar , tech_AdvChassis , tech_Soporific , tech_Flame , tech_Behemoth , tech_SelfDest ] ;
24147: LD_ADDR_LOC 32
24151: PUSH
24152: LD_INT 69
24154: PUSH
24155: LD_INT 39
24157: PUSH
24158: LD_INT 42
24160: PUSH
24161: LD_INT 34
24163: PUSH
24164: LD_INT 40
24166: PUSH
24167: LD_INT 71
24169: PUSH
24170: LD_INT 44
24172: PUSH
24173: LD_INT 41
24175: PUSH
24176: LD_INT 36
24178: PUSH
24179: LD_INT 13
24181: PUSH
24182: LD_INT 70
24184: PUSH
24185: LD_INT 23
24187: PUSH
24188: LD_INT 43
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: LIST
24195: LIST
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: ST_TO_ADDR
// sib_list := [ tech_SibPow , tech_SibEng , tech_SibFiss ] ;
24206: LD_ADDR_LOC 33
24210: PUSH
24211: LD_INT 21
24213: PUSH
24214: LD_INT 22
24216: PUSH
24217: LD_INT 25
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: LIST
24224: ST_TO_ADDR
// comp_list := [ tech_AI , tech_AdvAI , tech_Virus , tech_TargTeleport ] ;
24225: LD_ADDR_LOC 34
24229: PUSH
24230: LD_INT 32
24232: PUSH
24233: LD_INT 27
24235: PUSH
24236: LD_INT 33
24238: PUSH
24239: LD_INT 38
24241: PUSH
24242: EMPTY
24243: LIST
24244: LIST
24245: LIST
24246: LIST
24247: ST_TO_ADDR
// opto_list := [ tech_Radar , tech_LasSight , tech_RemCont , tech_Laser , tech_MatDet , tech_PartInvis , tech_RemCharge ] ;
24248: LD_ADDR_LOC 35
24252: PUSH
24253: LD_INT 6
24255: PUSH
24256: LD_INT 12
24258: PUSH
24259: LD_INT 15
24261: PUSH
24262: LD_INT 10
24264: PUSH
24265: LD_INT 7
24267: PUSH
24268: LD_INT 16
24270: PUSH
24271: LD_INT 18
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: LIST
24278: LIST
24279: LIST
24280: LIST
24281: LIST
24282: ST_TO_ADDR
// bio_list := [ tech_ApeNeural , tech_ApeBrain , tech_StimDrugs , tech_BioDet ] ;
24283: LD_ADDR_LOC 36
24287: PUSH
24288: LD_INT 3
24290: PUSH
24291: LD_INT 4
24293: PUSH
24294: LD_INT 5
24296: PUSH
24297: LD_INT 8
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: ST_TO_ADDR
// space_list := [ tech_TauField , tech_Lapser , tech_LimTeleport , tech_TauRad , tech_SpacAnom ] ;
24306: LD_ADDR_LOC 37
24310: PUSH
24311: LD_INT 30
24313: PUSH
24314: LD_INT 31
24316: PUSH
24317: LD_INT 37
24319: PUSH
24320: LD_INT 28
24322: PUSH
24323: LD_INT 29
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: LIST
24330: LIST
24331: LIST
24332: ST_TO_ADDR
// basic_tech := [ tech_list , weap_list , sib_list , comp_list , bio_list , space_list , opto_list ] ;
24333: LD_ADDR_LOC 45
24337: PUSH
24338: LD_LOC 31
24342: PUSH
24343: LD_LOC 32
24347: PUSH
24348: LD_LOC 33
24352: PUSH
24353: LD_LOC 34
24357: PUSH
24358: LD_LOC 36
24362: PUSH
24363: LD_LOC 37
24367: PUSH
24368: LD_LOC 35
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: LIST
24377: LIST
24378: LIST
24379: LIST
24380: LIST
24381: ST_TO_ADDR
// utech_basic := [ tech_Tech1 , tech_Tech2 , tech_Tech3 ] ;
24382: LD_ADDR_LOC 38
24386: PUSH
24387: LD_INT 48
24389: PUSH
24390: LD_INT 49
24392: PUSH
24393: LD_INT 50
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: LIST
24400: ST_TO_ADDR
// utech_weap := [ tech_Weap1 , tech_Weap2 , tech_Weap3 ] ;
24401: LD_ADDR_LOC 39
24405: PUSH
24406: LD_INT 51
24408: PUSH
24409: LD_INT 52
24411: PUSH
24412: LD_INT 53
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: LIST
24419: ST_TO_ADDR
// utech_sib := [ tech_Sib1 , tech_Sib2 , tech_Sib3 ] ;
24420: LD_ADDR_LOC 40
24424: PUSH
24425: LD_INT 54
24427: PUSH
24428: LD_INT 55
24430: PUSH
24431: LD_INT 56
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: LIST
24438: ST_TO_ADDR
// utech_comp := [ tech_Comp1 , tech_Comp2 , tech_Comp3 ] ;
24439: LD_ADDR_LOC 41
24443: PUSH
24444: LD_INT 57
24446: PUSH
24447: LD_INT 58
24449: PUSH
24450: LD_INT 59
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: LIST
24457: ST_TO_ADDR
// utech_bio := [ tech_Bio1 , tech_Bio2 , tech_Bio3 ] ;
24458: LD_ADDR_LOC 42
24462: PUSH
24463: LD_INT 66
24465: PUSH
24466: LD_INT 67
24468: PUSH
24469: LD_INT 68
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: LIST
24476: ST_TO_ADDR
// utech_space := [ tech_ST1 , tech_ST2 , tech_ST3 ] ;
24477: LD_ADDR_LOC 43
24481: PUSH
24482: LD_INT 63
24484: PUSH
24485: LD_INT 64
24487: PUSH
24488: LD_INT 65
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: LIST
24495: ST_TO_ADDR
// utech_opto := [ tech_Opto1 , tech_Opto2 , tech_Opto3 ] ;
24496: LD_ADDR_LOC 44
24500: PUSH
24501: LD_INT 60
24503: PUSH
24504: LD_INT 61
24506: PUSH
24507: LD_INT 62
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: LIST
24514: ST_TO_ADDR
// end ;
24515: LD_VAR 0 1
24519: RET
// function init_upgrade_by_nations ( side_nation ) ; begin
24520: LD_INT 0
24522: PPUSH
// first_technology := [ tech_SolPow , tech_OilPow , tech_OilEng , tech_SibDet , tech_SibPow , tech_AI , tech_AdvAI ] ;
24523: LD_ADDR_LOC 47
24527: PUSH
24528: LD_INT 35
24530: PUSH
24531: LD_INT 46
24533: PUSH
24534: LD_INT 47
24536: PUSH
24537: LD_INT 20
24539: PUSH
24540: LD_INT 21
24542: PUSH
24543: LD_INT 32
24545: PUSH
24546: LD_INT 27
24548: PUSH
24549: EMPTY
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: LIST
24557: ST_TO_ADDR
// last_technology := [ tech_ApeBrain , tech_Flame , tech_Soporific , tech_SibFiss ] ;
24558: LD_ADDR_LOC 48
24562: PUSH
24563: LD_INT 4
24565: PUSH
24566: LD_INT 70
24568: PUSH
24569: LD_INT 13
24571: PUSH
24572: LD_INT 25
24574: PUSH
24575: EMPTY
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: ST_TO_ADDR
// recomended_technology := [ tech_Gun , tech_Tech1 , tech_Comp1 , tech_Tech2 , tech_Comp2 , tech_Tech3 , tech_Comp3 ] ;
24581: LD_ADDR_LOC 49
24585: PUSH
24586: LD_INT 39
24588: PUSH
24589: LD_INT 48
24591: PUSH
24592: LD_INT 57
24594: PUSH
24595: LD_INT 49
24597: PUSH
24598: LD_INT 58
24600: PUSH
24601: LD_INT 50
24603: PUSH
24604: LD_INT 59
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: LIST
24613: LIST
24614: LIST
24615: ST_TO_ADDR
// case side_nation of 1 :
24616: LD_VAR 0 1
24620: PUSH
24621: LD_INT 1
24623: DOUBLE
24624: EQUAL
24625: IFTRUE 24629
24627: GO 24669
24629: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_opto ] ; 2 :
24630: LD_ADDR_LOC 46
24634: PUSH
24635: LD_LOC 38
24639: PUSH
24640: LD_LOC 39
24644: PUSH
24645: LD_LOC 40
24649: PUSH
24650: LD_LOC 41
24654: PUSH
24655: LD_LOC 44
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: LIST
24666: ST_TO_ADDR
24667: GO 24766
24669: LD_INT 2
24671: DOUBLE
24672: EQUAL
24673: IFTRUE 24677
24675: GO 24717
24677: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_bio , utech_opto ] ; 3 :
24678: LD_ADDR_LOC 46
24682: PUSH
24683: LD_LOC 38
24687: PUSH
24688: LD_LOC 39
24692: PUSH
24693: LD_LOC 40
24697: PUSH
24698: LD_LOC 42
24702: PUSH
24703: LD_LOC 44
24707: PUSH
24708: EMPTY
24709: LIST
24710: LIST
24711: LIST
24712: LIST
24713: LIST
24714: ST_TO_ADDR
24715: GO 24766
24717: LD_INT 3
24719: DOUBLE
24720: EQUAL
24721: IFTRUE 24725
24723: GO 24765
24725: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_space ] ; end ;
24726: LD_ADDR_LOC 46
24730: PUSH
24731: LD_LOC 38
24735: PUSH
24736: LD_LOC 39
24740: PUSH
24741: LD_LOC 40
24745: PUSH
24746: LD_LOC 41
24750: PUSH
24751: LD_LOC 43
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: LIST
24760: LIST
24761: LIST
24762: ST_TO_ADDR
24763: GO 24766
24765: POP
// end ;
24766: LD_VAR 0 2
24770: RET
// every 0 0$5.5 do var un , active_side , active_nation , lab_list , still_researching ;
24771: GO 24773
24773: DISABLE
24774: LD_INT 0
24776: PPUSH
24777: PPUSH
24778: PPUSH
24779: PPUSH
24780: PPUSH
// begin for active_side in cpu_list do
24781: LD_ADDR_VAR 0 2
24785: PUSH
24786: LD_EXP 8
24790: PUSH
24791: FOR_IN
24792: IFFALSE 24901
// begin still_researching := false ;
24794: LD_ADDR_VAR 0 5
24798: PUSH
24799: LD_INT 0
24801: ST_TO_ADDR
// lab_list := get_labs ( active_side ) ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 2
24811: PPUSH
24812: CALL 24988 0 1
24816: ST_TO_ADDR
// for un in lab_list do
24817: LD_ADDR_VAR 0 1
24821: PUSH
24822: LD_VAR 0 4
24826: PUSH
24827: FOR_IN
24828: IFFALSE 24855
// if BuildingStatus ( un ) = bs_working then
24830: LD_VAR 0 1
24834: PPUSH
24835: CALL_OW 461
24839: PUSH
24840: LD_INT 3
24842: EQUAL
24843: IFFALSE 24853
// still_researching := true ;
24845: LD_ADDR_VAR 0 5
24849: PUSH
24850: LD_INT 1
24852: ST_TO_ADDR
24853: GO 24827
24855: POP
24856: POP
// active_nation := GetCPUNation ( active_side ) ;
24857: LD_ADDR_VAR 0 3
24861: PUSH
24862: LD_VAR 0 2
24866: PPUSH
24867: CALL 26589 0 1
24871: ST_TO_ADDR
// if ( not still_researching ) and active_nation then
24872: LD_VAR 0 5
24876: NOT
24877: PUSH
24878: LD_VAR 0 3
24882: AND
24883: IFFALSE 24899
// start_new_research ( active_side , active_nation ) ;
24885: LD_VAR 0 2
24889: PPUSH
24890: LD_VAR 0 3
24894: PPUSH
24895: CALL 25061 0 2
// end ;
24899: GO 24791
24901: POP
24902: POP
// if ( cpu_list ) and ( not all_cpu_invented ) then
24903: LD_EXP 8
24907: PUSH
24908: CALL 24920 0 0
24912: NOT
24913: AND
24914: IFFALSE 24917
// enable ;
24916: ENABLE
// end ;
24917: PPOPN 5
24919: END
// function all_cpu_invented ; var un , vysledek ; begin
24920: LD_INT 0
24922: PPUSH
24923: PPUSH
24924: PPUSH
// vysledek := true ;
24925: LD_ADDR_VAR 0 3
24929: PUSH
24930: LD_INT 1
24932: ST_TO_ADDR
// for un in cpu_list do
24933: LD_ADDR_VAR 0 2
24937: PUSH
24938: LD_EXP 8
24942: PUSH
24943: FOR_IN
24944: IFFALSE 24971
// if not all_invented [ un ] then
24946: LD_LOC 50
24950: PUSH
24951: LD_VAR 0 2
24955: ARRAY
24956: NOT
24957: IFFALSE 24969
// begin vysledek := false ;
24959: LD_ADDR_VAR 0 3
24963: PUSH
24964: LD_INT 0
24966: ST_TO_ADDR
// break ;
24967: GO 24971
// end ;
24969: GO 24943
24971: POP
24972: POP
// result := vysledek ;
24973: LD_ADDR_VAR 0 1
24977: PUSH
24978: LD_VAR 0 3
24982: ST_TO_ADDR
// end ;
24983: LD_VAR 0 1
24987: RET
// function get_labs ( side ) ; var lab_list ; begin
24988: LD_INT 0
24990: PPUSH
24991: PPUSH
// lab_list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
24992: LD_ADDR_VAR 0 3
24996: PUSH
24997: LD_INT 22
24999: PUSH
25000: LD_VAR 0 1
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 2
25011: PUSH
25012: LD_INT 30
25014: PUSH
25015: LD_INT 8
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: LD_INT 30
25024: PUSH
25025: LD_INT 6
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: LIST
25036: PUSH
25037: EMPTY
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: ST_TO_ADDR
// result := lab_list ;
25046: LD_ADDR_VAR 0 2
25050: PUSH
25051: LD_VAR 0 3
25055: ST_TO_ADDR
// end ;
25056: LD_VAR 0 2
25060: RET
// function start_new_research ( side , nation ) ; var lab_list , possible , to_research , lab , scientistic ; begin
25061: LD_INT 0
25063: PPUSH
25064: PPUSH
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
// scientistic := request_people ( side , class_scientistic , 1 ) ;
25069: LD_ADDR_VAR 0 8
25073: PUSH
25074: LD_VAR 0 1
25078: PPUSH
25079: LD_INT 4
25081: PPUSH
25082: LD_INT 1
25084: PPUSH
25085: CALL 26521 0 3
25089: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25090: LD_ADDR_VAR 0 4
25094: PUSH
25095: LD_VAR 0 1
25099: PPUSH
25100: CALL 24988 0 1
25104: ST_TO_ADDR
// init_upgrade_by_nations ( nation ) ;
25105: LD_VAR 0 2
25109: PPUSH
25110: CALL 24520 0 1
// possible := get_possible_research ( side ) ;
25114: LD_ADDR_VAR 0 5
25118: PUSH
25119: LD_VAR 0 1
25123: PPUSH
25124: CALL 25208 0 1
25128: ST_TO_ADDR
// to_research := select_next_technology ( side , possible ) ;
25129: LD_ADDR_VAR 0 6
25133: PUSH
25134: LD_VAR 0 1
25138: PPUSH
25139: LD_VAR 0 5
25143: PPUSH
25144: CALL 25659 0 2
25148: ST_TO_ADDR
// lab := research_possible ( side , to_research ) ;
25149: LD_ADDR_VAR 0 7
25153: PUSH
25154: LD_VAR 0 1
25158: PPUSH
25159: LD_VAR 0 6
25163: PPUSH
25164: CALL 26218 0 2
25168: ST_TO_ADDR
// if lab then
25169: LD_VAR 0 7
25173: IFFALSE 25203
// begin transfer_scientistic ( scientistic , lab ) ;
25175: LD_VAR 0 8
25179: PPUSH
25180: LD_VAR 0 7
25184: PPUSH
25185: CALL 26339 0 2
// begin_of_research ( lab , to_research ) ;
25189: LD_VAR 0 7
25193: PPUSH
25194: LD_VAR 0 6
25198: PPUSH
25199: CALL 26447 0 2
// end ; end ;
25203: LD_VAR 0 3
25207: RET
// function get_possible_research ( side ) ; var un , vysledek , lab_list , upgrade ; begin
25208: LD_INT 0
25210: PPUSH
25211: PPUSH
25212: PPUSH
25213: PPUSH
25214: PPUSH
// vysledek := [ ] ;
25215: LD_ADDR_VAR 0 4
25219: PUSH
25220: EMPTY
25221: ST_TO_ADDR
// upgrade := [ ] ;
25222: LD_ADDR_VAR 0 6
25226: PUSH
25227: EMPTY
25228: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25229: LD_ADDR_VAR 0 5
25233: PUSH
25234: LD_VAR 0 1
25238: PPUSH
25239: CALL 24988 0 1
25243: ST_TO_ADDR
// for un in lab_list do
25244: LD_ADDR_VAR 0 3
25248: PUSH
25249: LD_VAR 0 5
25253: PUSH
25254: FOR_IN
25255: IFFALSE 25297
// upgrade := upgrade ^ GetLabKind ( un , 1 ) ^ GetLabKind ( un , 2 ) ;
25257: LD_ADDR_VAR 0 6
25261: PUSH
25262: LD_VAR 0 6
25266: PUSH
25267: LD_VAR 0 3
25271: PPUSH
25272: LD_INT 1
25274: PPUSH
25275: CALL_OW 268
25279: ADD
25280: PUSH
25281: LD_VAR 0 3
25285: PPUSH
25286: LD_INT 2
25288: PPUSH
25289: CALL_OW 268
25293: ADD
25294: ST_TO_ADDR
25295: GO 25254
25297: POP
25298: POP
// for un in upgrade do
25299: LD_ADDR_VAR 0 3
25303: PUSH
25304: LD_VAR 0 6
25308: PUSH
25309: FOR_IN
25310: IFFALSE 25334
// vysledek := vysledek ^ ( un - 8 ) ;
25312: LD_ADDR_VAR 0 4
25316: PUSH
25317: LD_VAR 0 4
25321: PUSH
25322: LD_VAR 0 3
25326: PUSH
25327: LD_INT 8
25329: MINUS
25330: ADD
25331: ST_TO_ADDR
25332: GO 25309
25334: POP
25335: POP
// result := vysledek ;
25336: LD_ADDR_VAR 0 2
25340: PUSH
25341: LD_VAR 0 4
25345: ST_TO_ADDR
// end ;
25346: LD_VAR 0 2
25350: RET
// function shake_it_baby ( list ) ; var vysledek , pom , i , n ; begin
25351: LD_INT 0
25353: PPUSH
25354: PPUSH
25355: PPUSH
25356: PPUSH
25357: PPUSH
// vysledek := [ ] ;
25358: LD_ADDR_VAR 0 3
25362: PUSH
25363: EMPTY
25364: ST_TO_ADDR
// for i = 1 to list do
25365: LD_ADDR_VAR 0 5
25369: PUSH
25370: DOUBLE
25371: LD_INT 1
25373: DEC
25374: ST_TO_ADDR
25375: LD_VAR 0 1
25379: PUSH
25380: FOR_TO
25381: IFFALSE 25455
// begin n := Rand ( 1 , list ) ;
25383: LD_ADDR_VAR 0 6
25387: PUSH
25388: LD_INT 1
25390: PPUSH
25391: LD_VAR 0 1
25395: PPUSH
25396: CALL_OW 12
25400: ST_TO_ADDR
// pom := list [ n ] ;
25401: LD_ADDR_VAR 0 4
25405: PUSH
25406: LD_VAR 0 1
25410: PUSH
25411: LD_VAR 0 6
25415: ARRAY
25416: ST_TO_ADDR
// list := Delete ( list , n ) ;
25417: LD_ADDR_VAR 0 1
25421: PUSH
25422: LD_VAR 0 1
25426: PPUSH
25427: LD_VAR 0 6
25431: PPUSH
25432: CALL_OW 3
25436: ST_TO_ADDR
// vysledek := vysledek ^ pom ;
25437: LD_ADDR_VAR 0 3
25441: PUSH
25442: LD_VAR 0 3
25446: PUSH
25447: LD_VAR 0 4
25451: ADD
25452: ST_TO_ADDR
// end ;
25453: GO 25380
25455: POP
25456: POP
// result := vysledek ;
25457: LD_ADDR_VAR 0 2
25461: PUSH
25462: LD_VAR 0 3
25466: ST_TO_ADDR
// end ;
25467: LD_VAR 0 2
25471: RET
// function GetBasicTechnology ; var list , un , vysledek ; begin
25472: LD_INT 0
25474: PPUSH
25475: PPUSH
25476: PPUSH
25477: PPUSH
// list := [ ] ;
25478: LD_ADDR_VAR 0 2
25482: PUSH
25483: EMPTY
25484: ST_TO_ADDR
// for un in basic_tech do
25485: LD_ADDR_VAR 0 3
25489: PUSH
25490: LD_LOC 45
25494: PUSH
25495: FOR_IN
25496: IFFALSE 25525
// if un then
25498: LD_VAR 0 3
25502: IFFALSE 25523
// list := list ^ [ un ] ;
25504: LD_ADDR_VAR 0 2
25508: PUSH
25509: LD_VAR 0 2
25513: PUSH
25514: LD_VAR 0 3
25518: PUSH
25519: EMPTY
25520: LIST
25521: ADD
25522: ST_TO_ADDR
25523: GO 25495
25525: POP
25526: POP
// if list > 1 then
25527: LD_VAR 0 2
25531: PUSH
25532: LD_INT 1
25534: GREATER
25535: IFFALSE 25552
// vysledek := shake_it_baby ( list ) ;
25537: LD_ADDR_VAR 0 4
25541: PUSH
25542: LD_VAR 0 2
25546: PPUSH
25547: CALL 25351 0 1
25551: ST_TO_ADDR
// result := vysledek ;
25552: LD_ADDR_VAR 0 1
25556: PUSH
25557: LD_VAR 0 4
25561: ST_TO_ADDR
// end ;
25562: LD_VAR 0 1
25566: RET
// function GetUpgradeTechnology ; var list , un , vysledek ; begin
25567: LD_INT 0
25569: PPUSH
25570: PPUSH
25571: PPUSH
25572: PPUSH
// vysledek := [ ] ;
25573: LD_ADDR_VAR 0 4
25577: PUSH
25578: EMPTY
25579: ST_TO_ADDR
// list := [ ] ;
25580: LD_ADDR_VAR 0 2
25584: PUSH
25585: EMPTY
25586: ST_TO_ADDR
// for un in upgrade_tech do
25587: LD_ADDR_VAR 0 3
25591: PUSH
25592: LD_LOC 46
25596: PUSH
25597: FOR_IN
25598: IFFALSE 25627
// if un then
25600: LD_VAR 0 3
25604: IFFALSE 25625
// list := list ^ [ un ] ;
25606: LD_ADDR_VAR 0 2
25610: PUSH
25611: LD_VAR 0 2
25615: PUSH
25616: LD_VAR 0 3
25620: PUSH
25621: EMPTY
25622: LIST
25623: ADD
25624: ST_TO_ADDR
25625: GO 25597
25627: POP
25628: POP
// vysledek := shake_it_baby ( list ) ;
25629: LD_ADDR_VAR 0 4
25633: PUSH
25634: LD_VAR 0 2
25638: PPUSH
25639: CALL 25351 0 1
25643: ST_TO_ADDR
// result := vysledek ;
25644: LD_ADDR_VAR 0 1
25648: PUSH
25649: LD_VAR 0 4
25653: ST_TO_ADDR
// end ;
25654: LD_VAR 0 1
25658: RET
// function select_next_technology ( side , possible ) ; var un , pom , new , vysledek , select ; begin
25659: LD_INT 0
25661: PPUSH
25662: PPUSH
25663: PPUSH
25664: PPUSH
25665: PPUSH
25666: PPUSH
// new := true ;
25667: LD_ADDR_VAR 0 6
25671: PUSH
25672: LD_INT 1
25674: ST_TO_ADDR
// vysledek := [ ] ;
25675: LD_ADDR_VAR 0 7
25679: PUSH
25680: EMPTY
25681: ST_TO_ADDR
// select := [ ] ;
25682: LD_ADDR_VAR 0 8
25686: PUSH
25687: EMPTY
25688: ST_TO_ADDR
// for un in first_technology do
25689: LD_ADDR_VAR 0 4
25693: PUSH
25694: LD_LOC 47
25698: PUSH
25699: FOR_IN
25700: IFFALSE 25742
// begin pom := research_possible ( side , un ) ;
25702: LD_ADDR_VAR 0 5
25706: PUSH
25707: LD_VAR 0 1
25711: PPUSH
25712: LD_VAR 0 4
25716: PPUSH
25717: CALL 26218 0 2
25721: ST_TO_ADDR
// if pom then
25722: LD_VAR 0 5
25726: IFFALSE 25740
// begin vysledek := un ;
25728: LD_ADDR_VAR 0 7
25732: PUSH
25733: LD_VAR 0 4
25737: ST_TO_ADDR
// break ;
25738: GO 25742
// end ; end ;
25740: GO 25699
25742: POP
25743: POP
// if not first_technology then
25744: LD_LOC 47
25748: NOT
25749: IFFALSE 25759
// new := false ;
25751: LD_ADDR_VAR 0 6
25755: PUSH
25756: LD_INT 0
25758: ST_TO_ADDR
// if not vysledek and ( Rand ( 0 , 10 ) < 3 ) then
25759: LD_VAR 0 7
25763: NOT
25764: PUSH
25765: LD_INT 0
25767: PPUSH
25768: LD_INT 10
25770: PPUSH
25771: CALL_OW 12
25775: PUSH
25776: LD_INT 3
25778: LESS
25779: AND
25780: IFFALSE 25837
// for un in recomended_technology do
25782: LD_ADDR_VAR 0 4
25786: PUSH
25787: LD_LOC 49
25791: PUSH
25792: FOR_IN
25793: IFFALSE 25835
// begin pom := research_possible ( side , un ) ;
25795: LD_ADDR_VAR 0 5
25799: PUSH
25800: LD_VAR 0 1
25804: PPUSH
25805: LD_VAR 0 4
25809: PPUSH
25810: CALL 26218 0 2
25814: ST_TO_ADDR
// if pom then
25815: LD_VAR 0 5
25819: IFFALSE 25833
// begin vysledek := un ;
25821: LD_ADDR_VAR 0 7
25825: PUSH
25826: LD_VAR 0 4
25830: ST_TO_ADDR
// break ;
25831: GO 25835
// end ; end ;
25833: GO 25792
25835: POP
25836: POP
// if not recomended_technology then
25837: LD_LOC 49
25841: NOT
25842: IFFALSE 25852
// new := false ;
25844: LD_ADDR_VAR 0 6
25848: PUSH
25849: LD_INT 0
25851: ST_TO_ADDR
// if not vysledek then
25852: LD_VAR 0 7
25856: NOT
25857: IFFALSE 25944
// begin select := GetBasicTechnology ;
25859: LD_ADDR_VAR 0 8
25863: PUSH
25864: CALL 25472 0 0
25868: ST_TO_ADDR
// for un in select do
25869: LD_ADDR_VAR 0 4
25873: PUSH
25874: LD_VAR 0 8
25878: PUSH
25879: FOR_IN
25880: IFFALSE 25942
// begin pom := [ ] ;
25882: LD_ADDR_VAR 0 5
25886: PUSH
25887: EMPTY
25888: ST_TO_ADDR
// if not un in last_technology then
25889: LD_VAR 0 4
25893: PUSH
25894: LD_LOC 48
25898: IN
25899: NOT
25900: IFFALSE 25922
// pom := research_possible ( side , un ) ;
25902: LD_ADDR_VAR 0 5
25906: PUSH
25907: LD_VAR 0 1
25911: PPUSH
25912: LD_VAR 0 4
25916: PPUSH
25917: CALL 26218 0 2
25921: ST_TO_ADDR
// if pom then
25922: LD_VAR 0 5
25926: IFFALSE 25940
// begin vysledek := un ;
25928: LD_ADDR_VAR 0 7
25932: PUSH
25933: LD_VAR 0 4
25937: ST_TO_ADDR
// break ;
25938: GO 25942
// end ; end ;
25940: GO 25879
25942: POP
25943: POP
// end ; if not select then
25944: LD_VAR 0 8
25948: NOT
25949: IFFALSE 25959
// new := false ;
25951: LD_ADDR_VAR 0 6
25955: PUSH
25956: LD_INT 0
25958: ST_TO_ADDR
// if not vysledek then
25959: LD_VAR 0 7
25963: NOT
25964: IFFALSE 26051
// begin select := GetUpgradeTechnology ;
25966: LD_ADDR_VAR 0 8
25970: PUSH
25971: CALL 25567 0 0
25975: ST_TO_ADDR
// for un in select do
25976: LD_ADDR_VAR 0 4
25980: PUSH
25981: LD_VAR 0 8
25985: PUSH
25986: FOR_IN
25987: IFFALSE 26049
// begin pom := [ ] ;
25989: LD_ADDR_VAR 0 5
25993: PUSH
25994: EMPTY
25995: ST_TO_ADDR
// if not un in last_technology then
25996: LD_VAR 0 4
26000: PUSH
26001: LD_LOC 48
26005: IN
26006: NOT
26007: IFFALSE 26029
// pom := research_possible ( side , un ) ;
26009: LD_ADDR_VAR 0 5
26013: PUSH
26014: LD_VAR 0 1
26018: PPUSH
26019: LD_VAR 0 4
26023: PPUSH
26024: CALL 26218 0 2
26028: ST_TO_ADDR
// if pom then
26029: LD_VAR 0 5
26033: IFFALSE 26047
// begin vysledek := un ;
26035: LD_ADDR_VAR 0 7
26039: PUSH
26040: LD_VAR 0 4
26044: ST_TO_ADDR
// break ;
26045: GO 26049
// end ; end ;
26047: GO 25986
26049: POP
26050: POP
// end ; if not select then
26051: LD_VAR 0 8
26055: NOT
26056: IFFALSE 26066
// new := false ;
26058: LD_ADDR_VAR 0 6
26062: PUSH
26063: LD_INT 0
26065: ST_TO_ADDR
// if not vysledek then
26066: LD_VAR 0 7
26070: NOT
26071: IFFALSE 26128
// for un in last_technology do
26073: LD_ADDR_VAR 0 4
26077: PUSH
26078: LD_LOC 48
26082: PUSH
26083: FOR_IN
26084: IFFALSE 26126
// begin pom := research_possible ( side , un ) ;
26086: LD_ADDR_VAR 0 5
26090: PUSH
26091: LD_VAR 0 1
26095: PPUSH
26096: LD_VAR 0 4
26100: PPUSH
26101: CALL 26218 0 2
26105: ST_TO_ADDR
// if pom then
26106: LD_VAR 0 5
26110: IFFALSE 26124
// begin vysledek := un ;
26112: LD_ADDR_VAR 0 7
26116: PUSH
26117: LD_VAR 0 4
26121: ST_TO_ADDR
// break ;
26122: GO 26126
// end ; end ;
26124: GO 26083
26126: POP
26127: POP
// if not last_technology then
26128: LD_LOC 48
26132: NOT
26133: IFFALSE 26143
// new := false ;
26135: LD_ADDR_VAR 0 6
26139: PUSH
26140: LD_INT 0
26142: ST_TO_ADDR
// if not ( vysledek or new ) then
26143: LD_VAR 0 7
26147: PUSH
26148: LD_VAR 0 6
26152: OR
26153: NOT
26154: IFFALSE 26203
// begin all_invented := Insert ( all_invented , side , true ) ;
26156: LD_ADDR_LOC 50
26160: PUSH
26161: LD_LOC 50
26165: PPUSH
26166: LD_VAR 0 1
26170: PPUSH
26171: LD_INT 1
26173: PPUSH
26174: CALL_OW 2
26178: ST_TO_ADDR
// all_invented := Delete ( all_invented , side + 1 ) ;
26179: LD_ADDR_LOC 50
26183: PUSH
26184: LD_LOC 50
26188: PPUSH
26189: LD_VAR 0 1
26193: PUSH
26194: LD_INT 1
26196: PLUS
26197: PPUSH
26198: CALL_OW 3
26202: ST_TO_ADDR
// end ; result := vysledek ;
26203: LD_ADDR_VAR 0 3
26207: PUSH
26208: LD_VAR 0 7
26212: ST_TO_ADDR
// end ;
26213: LD_VAR 0 3
26217: RET
// function research_possible ( side , tech ) ; var un , vysledek , lab_list ; begin
26218: LD_INT 0
26220: PPUSH
26221: PPUSH
26222: PPUSH
26223: PPUSH
// lab_list := get_labs ( side ) ;
26224: LD_ADDR_VAR 0 6
26228: PUSH
26229: LD_VAR 0 1
26233: PPUSH
26234: CALL 24988 0 1
26238: ST_TO_ADDR
// if GetTech ( tech , side ) in [ state_disabled , state_researched ] then
26239: LD_VAR 0 2
26243: PPUSH
26244: LD_VAR 0 1
26248: PPUSH
26249: CALL_OW 321
26253: PUSH
26254: LD_INT 0
26256: PUSH
26257: LD_INT 2
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: IN
26264: IFFALSE 26275
// vysledek := [ ] else
26266: LD_ADDR_VAR 0 5
26270: PUSH
26271: EMPTY
26272: ST_TO_ADDR
26273: GO 26324
// for un in lab_list do
26275: LD_ADDR_VAR 0 4
26279: PUSH
26280: LD_VAR 0 6
26284: PUSH
26285: FOR_IN
26286: IFFALSE 26322
// if CanBeResearched ( un , tech ) then
26288: LD_VAR 0 4
26292: PPUSH
26293: LD_VAR 0 2
26297: PPUSH
26298: CALL_OW 430
26302: IFFALSE 26320
// vysledek := vysledek ^ un ;
26304: LD_ADDR_VAR 0 5
26308: PUSH
26309: LD_VAR 0 5
26313: PUSH
26314: LD_VAR 0 4
26318: ADD
26319: ST_TO_ADDR
26320: GO 26285
26322: POP
26323: POP
// result := vysledek ;
26324: LD_ADDR_VAR 0 3
26328: PUSH
26329: LD_VAR 0 5
26333: ST_TO_ADDR
// end ;
26334: LD_VAR 0 3
26338: RET
// function transfer_scientistic ( scients , to_lab ) ; var un , i ; begin
26339: LD_INT 0
26341: PPUSH
26342: PPUSH
26343: PPUSH
// i = 1 ;
26344: LD_ADDR_VAR 0 5
26348: PUSH
26349: LD_INT 1
26351: ST_TO_ADDR
// to_lab := to_lab diff [ 0 ] ;
26352: LD_ADDR_VAR 0 2
26356: PUSH
26357: LD_VAR 0 2
26361: PUSH
26362: LD_INT 0
26364: PUSH
26365: EMPTY
26366: LIST
26367: DIFF
26368: ST_TO_ADDR
// for un in scients do
26369: LD_ADDR_VAR 0 4
26373: PUSH
26374: LD_VAR 0 1
26378: PUSH
26379: FOR_IN
26380: IFFALSE 26428
// begin ComEnterUnit ( un , to_lab [ ( i mod to_lab ) + 1 ] ) ;
26382: LD_VAR 0 4
26386: PPUSH
26387: LD_VAR 0 2
26391: PUSH
26392: LD_VAR 0 5
26396: PUSH
26397: LD_VAR 0 2
26401: MOD
26402: PUSH
26403: LD_INT 1
26405: PLUS
26406: ARRAY
26407: PPUSH
26408: CALL_OW 120
// i := i + 1 ;
26412: LD_ADDR_VAR 0 5
26416: PUSH
26417: LD_VAR 0 5
26421: PUSH
26422: LD_INT 1
26424: PLUS
26425: ST_TO_ADDR
// end ;
26426: GO 26379
26428: POP
26429: POP
// AddComChangeProfession ( scients , class_scientistic ) ;
26430: LD_VAR 0 1
26434: PPUSH
26435: LD_INT 4
26437: PPUSH
26438: CALL_OW 183
// end ;
26442: LD_VAR 0 3
26446: RET
// function begin_of_research ( lab , to_research ) ; begin
26447: LD_INT 0
26449: PPUSH
// ComResearch ( lab , to_research ) ;
26450: LD_VAR 0 1
26454: PPUSH
26455: LD_VAR 0 2
26459: PPUSH
26460: CALL_OW 124
// end ; end_of_file
26464: LD_VAR 0 3
26468: RET
// export reserved_people ; var vysledek ; export function init_distribution ; var un ; begin
26469: LD_INT 0
26471: PPUSH
26472: PPUSH
// reserved_people := [ ] ;
26473: LD_ADDR_EXP 71
26477: PUSH
26478: EMPTY
26479: ST_TO_ADDR
// for un = 1 to 8 do
26480: LD_ADDR_VAR 0 2
26484: PUSH
26485: DOUBLE
26486: LD_INT 1
26488: DEC
26489: ST_TO_ADDR
26490: LD_INT 8
26492: PUSH
26493: FOR_TO
26494: IFFALSE 26514
// reserved_people := reserved_people ^ [ [ ] ] ;
26496: LD_ADDR_EXP 71
26500: PUSH
26501: LD_EXP 71
26505: PUSH
26506: EMPTY
26507: PUSH
26508: EMPTY
26509: LIST
26510: ADD
26511: ST_TO_ADDR
26512: GO 26493
26514: POP
26515: POP
// end ;
26516: LD_VAR 0 1
26520: RET
// export function request_people ( side , man_class , priority ) ; begin
26521: LD_INT 0
26523: PPUSH
// vysledek := FilterAllUnits ( [ [ f_side , side ] , [ f_class , man_class ] ] ) diff reserved_people [ side ] ;
26524: LD_ADDR_LOC 51
26528: PUSH
26529: LD_INT 22
26531: PUSH
26532: LD_VAR 0 1
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 25
26543: PUSH
26544: LD_VAR 0 2
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: PPUSH
26557: CALL_OW 69
26561: PUSH
26562: LD_EXP 71
26566: PUSH
26567: LD_VAR 0 1
26571: ARRAY
26572: DIFF
26573: ST_TO_ADDR
// result := vysledek ;
26574: LD_ADDR_VAR 0 4
26578: PUSH
26579: LD_LOC 51
26583: ST_TO_ADDR
// end ;
26584: LD_VAR 0 4
26588: RET
// export function GetCPUNation ( side ) ; var un , vysledek ; begin
26589: LD_INT 0
26591: PPUSH
26592: PPUSH
26593: PPUSH
// un := FilterAllUnits ( [ [ f_side , side ] ] ) ;
26594: LD_ADDR_VAR 0 3
26598: PUSH
26599: LD_INT 22
26601: PUSH
26602: LD_VAR 0 1
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: EMPTY
26612: LIST
26613: PPUSH
26614: CALL_OW 69
26618: ST_TO_ADDR
// if un then
26619: LD_VAR 0 3
26623: IFFALSE 26646
// vysledek := GetSide ( un [ 1 ] ) else
26625: LD_ADDR_VAR 0 4
26629: PUSH
26630: LD_VAR 0 3
26634: PUSH
26635: LD_INT 1
26637: ARRAY
26638: PPUSH
26639: CALL_OW 255
26643: ST_TO_ADDR
26644: GO 26654
// vysledek := false ;
26646: LD_ADDR_VAR 0 4
26650: PUSH
26651: LD_INT 0
26653: ST_TO_ADDR
// result := vysledek ;
26654: LD_ADDR_VAR 0 2
26658: PUSH
26659: LD_VAR 0 4
26663: ST_TO_ADDR
// end ; end_of_file
26664: LD_VAR 0 2
26668: RET
// var us_weapons , ar_weapons , ru_weapons ; var sib_engine , oil_engine ; var prefered ; var main_extensions ; var hovers_recomended , flat_land ; export mechanics_wanted , extension_wanted ; function init_priority ( side , side_nation ) ; var us_main_control ; begin
26669: LD_INT 0
26671: PPUSH
26672: PPUSH
// us_main_control := b_ext_computer ;
26673: LD_ADDR_VAR 0 4
26677: PUSH
26678: LD_INT 24
26680: ST_TO_ADDR
// prefered_control := control_computer ;
26681: LD_ADDR_EXP 59
26685: PUSH
26686: LD_INT 3
26688: ST_TO_ADDR
// case side_nation of 1 :
26689: LD_VAR 0 2
26693: PUSH
26694: LD_INT 1
26696: DOUBLE
26697: EQUAL
26698: IFTRUE 26702
26700: GO 26734
26702: POP
// main_extensions := [ b_ext_track , b_ext_siberium , b_ext_laser , b_ext_rocket , us_main_control ] ; 2 :
26703: LD_ADDR_LOC 58
26707: PUSH
26708: LD_INT 16
26710: PUSH
26711: LD_INT 21
26713: PUSH
26714: LD_INT 25
26716: PUSH
26717: LD_INT 18
26719: PUSH
26720: LD_VAR 0 4
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: ST_TO_ADDR
26732: GO 26811
26734: LD_INT 2
26736: DOUBLE
26737: EQUAL
26738: IFTRUE 26742
26740: GO 26772
26742: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar , b_ext_siberium ] ; 3 :
26743: LD_ADDR_LOC 58
26747: PUSH
26748: LD_INT 16
26750: PUSH
26751: LD_INT 17
26753: PUSH
26754: LD_INT 18
26756: PUSH
26757: LD_INT 20
26759: PUSH
26760: LD_INT 21
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: ST_TO_ADDR
26770: GO 26811
26772: LD_INT 3
26774: DOUBLE
26775: EQUAL
26776: IFTRUE 26780
26778: GO 26810
26780: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ; end ;
26781: LD_ADDR_LOC 58
26785: PUSH
26786: LD_INT 16
26788: PUSH
26789: LD_INT 17
26791: PUSH
26792: LD_INT 18
26794: PUSH
26795: LD_INT 24
26797: PUSH
26798: LD_INT 21
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: ST_TO_ADDR
26808: GO 26811
26810: POP
// end ;
26811: LD_VAR 0 3
26815: RET
// export function init_manufacture ; begin
26816: LD_INT 0
26818: PPUSH
// hovers_recomended := false ;
26819: LD_ADDR_LOC 59
26823: PUSH
26824: LD_INT 0
26826: ST_TO_ADDR
// flat_land := false ;
26827: LD_ADDR_LOC 60
26831: PUSH
26832: LD_INT 0
26834: ST_TO_ADDR
// sib_engine := 10 ;
26835: LD_ADDR_LOC 55
26839: PUSH
26840: LD_INT 10
26842: ST_TO_ADDR
// oil_engine := 30 ;
26843: LD_ADDR_LOC 56
26847: PUSH
26848: LD_INT 30
26850: ST_TO_ADDR
// us_weapons := [ [ [ us_machine_gun , [ ] , 0 ] , [ us_light_gun , [ tech_Gun ] , b_ext_gun ] , [ us_radar , [ tech_Radar ] , b_ext_radar ] , [ us_crane , [ ] , b_ext_noncombat ] ] , [ [ us_gatling_gun , [ tech_Gatling ] , 0 ] , [ us_double_gun , [ tech_Gun ] , b_ext_gun ] , [ us_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ us_laser , [ tech_Laser ] , b_ext_laser ] , [ us_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ us_bulldozer , [ ] , b_ext_noncombat ] , [ us_siberium_rocket , [ tech_SibEng , tech_Rocket ] , b_ext_siberium ] , [ us_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] ] ] ;
26851: LD_ADDR_LOC 52
26855: PUSH
26856: LD_INT 2
26858: PUSH
26859: EMPTY
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 3
26871: PUSH
26872: LD_INT 39
26874: PUSH
26875: EMPTY
26876: LIST
26877: PUSH
26878: LD_INT 17
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: LIST
26885: PUSH
26886: LD_INT 11
26888: PUSH
26889: LD_INT 6
26891: PUSH
26892: EMPTY
26893: LIST
26894: PUSH
26895: LD_INT 20
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 13
26905: PUSH
26906: EMPTY
26907: PUSH
26908: LD_INT 19
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: PUSH
26922: LD_INT 4
26924: PUSH
26925: LD_INT 69
26927: PUSH
26928: EMPTY
26929: LIST
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 5
26941: PUSH
26942: LD_INT 39
26944: PUSH
26945: EMPTY
26946: LIST
26947: PUSH
26948: LD_INT 17
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 7
26958: PUSH
26959: LD_INT 40
26961: PUSH
26962: EMPTY
26963: LIST
26964: PUSH
26965: LD_INT 18
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: LIST
26972: PUSH
26973: LD_INT 9
26975: PUSH
26976: LD_INT 10
26978: PUSH
26979: EMPTY
26980: LIST
26981: PUSH
26982: LD_INT 25
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 12
26992: PUSH
26993: EMPTY
26994: PUSH
26995: LD_INT 19
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: LIST
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 14
27012: PUSH
27013: EMPTY
27014: PUSH
27015: LD_INT 19
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: LIST
27022: PUSH
27023: LD_INT 8
27025: PUSH
27026: LD_INT 22
27028: PUSH
27029: LD_INT 40
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 21
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 6
27046: PUSH
27047: LD_INT 34
27049: PUSH
27050: EMPTY
27051: LIST
27052: PUSH
27053: LD_INT 17
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: LIST
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: LIST
27070: ST_TO_ADDR
// ar_weapons := [ [ [ ar_multimissile_ballista , [ ] , 0 ] , [ ar_double_machine_gun , [ ] , 0 ] , [ ar_light_gun , [ tech_Gun ] , b_ext_gun ] ] , [ [ ar_gatling_gun , [ tech_Gatling ] , 0 ] , [ ar_flame_thrower , [ tech_Flame ] , b_ext_stitch ] , [ ar_gun , [ tech_Gun ] , b_ext_gun ] , [ ar_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ar_selfpropelled_bomb , [ tech_Explos ] , b_ext_siberium ] , [ ar_radar , [ tech_Radar ] , b_ext_radar ] , [ ar_control_tower , [ tech_RemCont ] , b_ext_radar ] , [ ar_cargo_bay , [ ] , b_ext_stitch ] ] , [ ] ] ;
27071: LD_ADDR_LOC 53
27075: PUSH
27076: LD_INT 22
27078: PUSH
27079: EMPTY
27080: PUSH
27081: LD_INT 0
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: LIST
27088: PUSH
27089: LD_INT 24
27091: PUSH
27092: EMPTY
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 23
27104: PUSH
27105: LD_INT 39
27107: PUSH
27108: EMPTY
27109: LIST
27110: PUSH
27111: LD_INT 17
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 25
27126: PUSH
27127: LD_INT 69
27129: PUSH
27130: EMPTY
27131: LIST
27132: PUSH
27133: LD_INT 0
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 26
27143: PUSH
27144: LD_INT 70
27146: PUSH
27147: EMPTY
27148: LIST
27149: PUSH
27150: LD_INT 23
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 27
27160: PUSH
27161: LD_INT 39
27163: PUSH
27164: EMPTY
27165: LIST
27166: PUSH
27167: LD_INT 17
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: LIST
27174: PUSH
27175: LD_INT 28
27177: PUSH
27178: LD_INT 40
27180: PUSH
27181: EMPTY
27182: LIST
27183: PUSH
27184: LD_INT 18
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 29
27194: PUSH
27195: LD_INT 42
27197: PUSH
27198: EMPTY
27199: LIST
27200: PUSH
27201: LD_INT 21
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: LIST
27208: PUSH
27209: LD_INT 30
27211: PUSH
27212: LD_INT 6
27214: PUSH
27215: EMPTY
27216: LIST
27217: PUSH
27218: LD_INT 20
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 31
27228: PUSH
27229: LD_INT 15
27231: PUSH
27232: EMPTY
27233: LIST
27234: PUSH
27235: LD_INT 20
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 32
27245: PUSH
27246: EMPTY
27247: PUSH
27248: LD_INT 23
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: LIST
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: LIST
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: PUSH
27266: EMPTY
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: LIST
27272: ST_TO_ADDR
// ru_weapons := [ [ ] , [ [ ru_heavy_machine_gun , [ ] , 0 ] , [ ru_gatling_gun , [ tech_Gatling ] , 0 ] , [ ru_gun , [ tech_Gun ] , b_ext_gun ] , [ ru_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ru_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ ru_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] , [ ru_rocket , [ tech_AdvRocket ] , b_ext_rocket ] , [ ru_siberium_rocket , [ tech_SibEng , tech_SibFiss ] , b_ext_siberium ] , [ ru_time_lapser , [ tech_Lapser ] , b_ext_siberium ] , [ ru_bulldozer , [ ] , b_ext_noncombat ] ] ] ;
27273: LD_ADDR_LOC 54
27277: PUSH
27278: EMPTY
27279: PUSH
27280: LD_INT 42
27282: PUSH
27283: EMPTY
27284: PUSH
27285: LD_INT 0
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: LIST
27292: PUSH
27293: LD_INT 43
27295: PUSH
27296: LD_INT 69
27298: PUSH
27299: EMPTY
27300: LIST
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: LIST
27309: PUSH
27310: LD_INT 44
27312: PUSH
27313: LD_INT 39
27315: PUSH
27316: EMPTY
27317: LIST
27318: PUSH
27319: LD_INT 17
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 45
27329: PUSH
27330: LD_INT 40
27332: PUSH
27333: EMPTY
27334: LIST
27335: PUSH
27336: LD_INT 18
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 51
27346: PUSH
27347: EMPTY
27348: PUSH
27349: LD_INT 19
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 46
27366: PUSH
27367: LD_INT 34
27369: PUSH
27370: EMPTY
27371: LIST
27372: PUSH
27373: LD_INT 17
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 47
27383: PUSH
27384: LD_INT 71
27386: PUSH
27387: EMPTY
27388: LIST
27389: PUSH
27390: LD_INT 18
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 48
27400: PUSH
27401: LD_INT 22
27403: PUSH
27404: LD_INT 25
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: LD_INT 21
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 49
27421: PUSH
27422: LD_INT 31
27424: PUSH
27425: EMPTY
27426: LIST
27427: PUSH
27428: LD_INT 21
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 53
27438: PUSH
27439: EMPTY
27440: PUSH
27441: LD_INT 19
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: LIST
27460: ST_TO_ADDR
// end ;
27461: LD_VAR 0 1
27465: RET
// function init_prefered_vehicles ( side_nation ) ; begin
27466: LD_INT 0
27468: PPUSH
// case side_nation of 1 :
27469: LD_VAR 0 1
27473: PUSH
27474: LD_INT 1
27476: DOUBLE
27477: EQUAL
27478: IFTRUE 27482
27480: GO 27566
27482: POP
// prefered := [ [ [ us_medium_wheeled , us_medium_wheeled , us_morphling ] [ difficulty ] , 0 , control_remote , us_laser ] , [ us_morphling , 0 , control_remote , us_heavy_gun ] , [ us_morphling , 0 , control_remote , us_rocket_launcher ] ] ; 2 :
27483: LD_ADDR_LOC 57
27487: PUSH
27488: LD_INT 2
27490: PUSH
27491: LD_INT 2
27493: PUSH
27494: LD_INT 5
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: LIST
27501: PUSH
27502: LD_OWVAR 67
27506: ARRAY
27507: PUSH
27508: LD_INT 0
27510: PUSH
27511: LD_INT 2
27513: PUSH
27514: LD_INT 9
27516: PUSH
27517: EMPTY
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 5
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: LD_INT 6
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: PUSH
27541: LD_INT 5
27543: PUSH
27544: LD_INT 0
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: LD_INT 7
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: LIST
27563: ST_TO_ADDR
27564: GO 27679
27566: LD_INT 2
27568: DOUBLE
27569: EQUAL
27570: IFTRUE 27574
27572: GO 27622
27574: POP
// prefered := [ [ ar_medium_trike , 0 , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , 0 , control_remote , ar_gun ] ] ; 3 :
27575: LD_ADDR_LOC 57
27579: PUSH
27580: LD_INT 13
27582: PUSH
27583: LD_INT 0
27585: PUSH
27586: LD_INT 2
27588: PUSH
27589: LD_INT 28
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 13
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: LD_INT 2
27606: PUSH
27607: LD_INT 27
27609: PUSH
27610: EMPTY
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: ST_TO_ADDR
27620: GO 27679
27622: LD_INT 3
27624: DOUBLE
27625: EQUAL
27626: IFTRUE 27630
27628: GO 27678
27630: POP
// prefered := [ [ 0 , engine_siberite , control_computer , ru_heavy_gun ] , [ 0 , engine_siberite , control_computer , ru_rocket ] ] ; end ;
27631: LD_ADDR_LOC 57
27635: PUSH
27636: LD_INT 0
27638: PUSH
27639: LD_INT 3
27641: PUSH
27642: LD_INT 3
27644: PUSH
27645: LD_INT 46
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: PUSH
27654: LD_INT 0
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: LD_INT 3
27662: PUSH
27663: LD_INT 47
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: PUSH
27672: EMPTY
27673: LIST
27674: LIST
27675: ST_TO_ADDR
27676: GO 27679
27678: POP
// end ;
27679: LD_VAR 0 2
27683: RET
// every 0 0$1.9 do var un , factories , active_side , active_nation , wait_timers , construction_order_given ;
27684: GO 27686
27686: DISABLE
27687: LD_INT 0
27689: PPUSH
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
// begin wait_timers = [ ] ;
27695: LD_ADDR_VAR 0 5
27699: PUSH
27700: EMPTY
27701: ST_TO_ADDR
// for un = 1 to 8 do
27702: LD_ADDR_VAR 0 1
27706: PUSH
27707: DOUBLE
27708: LD_INT 1
27710: DEC
27711: ST_TO_ADDR
27712: LD_INT 8
27714: PUSH
27715: FOR_TO
27716: IFFALSE 27734
// wait_timers = wait_timers ^ 0 0$15.9 ;
27718: LD_ADDR_VAR 0 5
27722: PUSH
27723: LD_VAR 0 5
27727: PUSH
27728: LD_INT 557
27730: ADD
27731: ST_TO_ADDR
27732: GO 27715
27734: POP
27735: POP
// repeat wait ( 0 0$1 ) ;
27736: LD_INT 35
27738: PPUSH
27739: CALL_OW 67
// for active_side in cpu_list do
27743: LD_ADDR_VAR 0 3
27747: PUSH
27748: LD_EXP 8
27752: PUSH
27753: FOR_IN
27754: IFFALSE 28107
// begin if wait_timers [ active_side ] > 0 0$0 then
27756: LD_VAR 0 5
27760: PUSH
27761: LD_VAR 0 3
27765: ARRAY
27766: PUSH
27767: LD_INT 0
27769: GREATER
27770: IFFALSE 27809
// begin wait_timers = Replace ( wait_timers , active_side , wait_timers [ active_side ] - 0 0$1 ) ;
27772: LD_ADDR_VAR 0 5
27776: PUSH
27777: LD_VAR 0 5
27781: PPUSH
27782: LD_VAR 0 3
27786: PPUSH
27787: LD_VAR 0 5
27791: PUSH
27792: LD_VAR 0 3
27796: ARRAY
27797: PUSH
27798: LD_INT 35
27800: MINUS
27801: PPUSH
27802: CALL_OW 1
27806: ST_TO_ADDR
// continue ;
27807: GO 27753
// end ; if ( Get_Resources ( active_side ) [ 2 ] > 29 ) or ( Get_resources ( active_side ) [ 3 ] > 9 ) then
27809: LD_VAR 0 3
27813: PPUSH
27814: CALL 28116 0 1
27818: PUSH
27819: LD_INT 2
27821: ARRAY
27822: PUSH
27823: LD_INT 29
27825: GREATER
27826: PUSH
27827: LD_VAR 0 3
27831: PPUSH
27832: CALL 28116 0 1
27836: PUSH
27837: LD_INT 3
27839: ARRAY
27840: PUSH
27841: LD_INT 9
27843: GREATER
27844: OR
27845: IFFALSE 28105
// begin case active_side of us :
27847: LD_VAR 0 3
27851: PUSH
27852: LD_EXP 3
27856: DOUBLE
27857: EQUAL
27858: IFTRUE 27862
27860: GO 27873
27862: POP
// if us_sib_wait then
27863: LD_EXP 74
27867: IFFALSE 27871
// continue ; ru :
27869: GO 27753
27871: GO 27895
27873: LD_EXP 2
27877: DOUBLE
27878: EQUAL
27879: IFTRUE 27883
27881: GO 27894
27883: POP
// if ru_sib_wait then
27884: LD_EXP 75
27888: IFFALSE 27892
// continue ; end ;
27890: GO 27753
27892: GO 27895
27894: POP
// factories := FilterAllUnits ( [ [ f_side , active_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
27895: LD_ADDR_VAR 0 2
27899: PUSH
27900: LD_INT 22
27902: PUSH
27903: LD_VAR 0 3
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 2
27914: PUSH
27915: LD_INT 30
27917: PUSH
27918: LD_INT 2
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 30
27927: PUSH
27928: LD_INT 3
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: LIST
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: PPUSH
27944: CALL_OW 69
27948: ST_TO_ADDR
// if factories = 0 then
27949: LD_VAR 0 2
27953: PUSH
27954: LD_INT 0
27956: EQUAL
27957: IFFALSE 27961
// continue ;
27959: GO 27753
// un = factories [ 1 ] ;
27961: LD_ADDR_VAR 0 1
27965: PUSH
27966: LD_VAR 0 2
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: ST_TO_ADDR
// active_nation := GetCPUNation ( active_side ) ;
27975: LD_ADDR_VAR 0 4
27979: PUSH
27980: LD_VAR 0 3
27984: PPUSH
27985: CALL 26589 0 1
27989: ST_TO_ADDR
// init_priority ( active_side , active_nation ) ;
27990: LD_VAR 0 3
27994: PPUSH
27995: LD_VAR 0 4
27999: PPUSH
28000: CALL 26669 0 2
// init_prefered_vehicles ( active_nation ) ;
28004: LD_VAR 0 4
28008: PPUSH
28009: CALL 27466 0 1
// if not BuildingStatus ( un ) = bs_working then
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 461
28022: PUSH
28023: LD_INT 3
28025: EQUAL
28026: NOT
28027: IFFALSE 28105
// begin construction_order_given = build_new_vehicle ( active_side , active_nation , un ) ;
28029: LD_ADDR_VAR 0 6
28033: PUSH
28034: LD_VAR 0 3
28038: PPUSH
28039: LD_VAR 0 4
28043: PPUSH
28044: LD_VAR 0 1
28048: PPUSH
28049: CALL 28234 0 3
28053: ST_TO_ADDR
// if construction_order_given then
28054: LD_VAR 0 6
28058: IFFALSE 28105
// begin wait ( 10 ) ;
28060: LD_INT 10
28062: PPUSH
28063: CALL_OW 67
// if BuildingStatus ( un ) = bs_working then
28067: LD_VAR 0 1
28071: PPUSH
28072: CALL_OW 461
28076: PUSH
28077: LD_INT 3
28079: EQUAL
28080: IFFALSE 28105
// wait_timers = Replace ( wait_timers , active_side , 0 0$15.9 ) ;
28082: LD_ADDR_VAR 0 5
28086: PUSH
28087: LD_VAR 0 5
28091: PPUSH
28092: LD_VAR 0 3
28096: PPUSH
28097: LD_INT 557
28099: PPUSH
28100: CALL_OW 1
28104: ST_TO_ADDR
// end ; end ; end ; end ;
28105: GO 27753
28107: POP
28108: POP
// until false ;
28109: LD_INT 0
28111: IFFALSE 27736
// end ;
28113: PPOPN 6
28115: END
// function Get_Resources ( side ) ; var depots ; begin
28116: LD_INT 0
28118: PPUSH
28119: PPUSH
// depots = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28120: LD_ADDR_VAR 0 3
28124: PUSH
28125: LD_INT 22
28127: PUSH
28128: LD_VAR 0 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: PUSH
28140: LD_INT 30
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: PUSH
28150: LD_INT 30
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: LIST
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PPUSH
28169: CALL_OW 69
28173: ST_TO_ADDR
// if depots > 0 then
28174: LD_VAR 0 3
28178: PUSH
28179: LD_INT 0
28181: GREATER
28182: IFFALSE 28210
// result := GetResources ( GetBase ( depots [ 1 ] ) ) else
28184: LD_ADDR_VAR 0 2
28188: PUSH
28189: LD_VAR 0 3
28193: PUSH
28194: LD_INT 1
28196: ARRAY
28197: PPUSH
28198: CALL_OW 274
28202: PPUSH
28203: CALL_OW 279
28207: ST_TO_ADDR
28208: GO 28229
// result = [ 0 , 0 , 0 ] ;
28210: LD_ADDR_VAR 0 2
28214: PUSH
28215: LD_INT 0
28217: PUSH
28218: LD_INT 0
28220: PUSH
28221: LD_INT 0
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: LIST
28228: ST_TO_ADDR
// end ;
28229: LD_VAR 0 2
28233: RET
// function build_new_vehicle ( side , nation , factory ) ; var can_made , mechanics , wanted ; begin
28234: LD_INT 0
28236: PPUSH
28237: PPUSH
28238: PPUSH
28239: PPUSH
// result = false ;
28240: LD_ADDR_VAR 0 4
28244: PUSH
28245: LD_INT 0
28247: ST_TO_ADDR
// mechanics := request_people ( side , class_mechanic , 1 ) ;
28248: LD_ADDR_VAR 0 6
28252: PUSH
28253: LD_VAR 0 1
28257: PPUSH
28258: LD_INT 3
28260: PPUSH
28261: LD_INT 1
28263: PPUSH
28264: CALL 26521 0 3
28268: ST_TO_ADDR
// can_made := get_progress ( side , nation , factory ) ;
28269: LD_ADDR_VAR 0 5
28273: PUSH
28274: LD_VAR 0 1
28278: PPUSH
28279: LD_VAR 0 2
28283: PPUSH
28284: LD_VAR 0 3
28288: PPUSH
28289: CALL 28405 0 3
28293: ST_TO_ADDR
// if can_made then
28294: LD_VAR 0 5
28298: IFFALSE 28381
// begin wanted := get_next_vehicle ( side , nation , factory , can_made ) ;
28300: LD_ADDR_VAR 0 7
28304: PUSH
28305: LD_VAR 0 1
28309: PPUSH
28310: LD_VAR 0 2
28314: PPUSH
28315: LD_VAR 0 3
28319: PPUSH
28320: LD_VAR 0 5
28324: PPUSH
28325: CALL 28884 0 4
28329: ST_TO_ADDR
// if transfer_mechanics ( side , mechanics , factory , wanted ) then
28330: LD_VAR 0 1
28334: PPUSH
28335: LD_VAR 0 6
28339: PPUSH
28340: LD_VAR 0 3
28344: PPUSH
28345: LD_VAR 0 7
28349: PPUSH
28350: CALL 31353 0 4
28354: IFFALSE 28381
// result = start_building_vehicle ( nation , factory , wanted ) ;
28356: LD_ADDR_VAR 0 4
28360: PUSH
28361: LD_VAR 0 2
28365: PPUSH
28366: LD_VAR 0 3
28370: PPUSH
28371: LD_VAR 0 7
28375: PPUSH
28376: CALL 31785 0 3
28380: ST_TO_ADDR
// end ; cleanup_extensions ( side , nation , factory ) ;
28381: LD_VAR 0 1
28385: PPUSH
28386: LD_VAR 0 2
28390: PPUSH
28391: LD_VAR 0 3
28395: PPUSH
28396: CALL 32019 0 3
// end ;
28400: LD_VAR 0 4
28404: RET
// function get_progress ( side , nation , factory ) ; var vysledek , chassis , weapon , list ; begin
28405: LD_INT 0
28407: PPUSH
28408: PPUSH
28409: PPUSH
28410: PPUSH
28411: PPUSH
// vysledek := [ ] ;
28412: LD_ADDR_VAR 0 5
28416: PUSH
28417: EMPTY
28418: ST_TO_ADDR
// list := [ ] ;
28419: LD_ADDR_VAR 0 8
28423: PUSH
28424: EMPTY
28425: ST_TO_ADDR
// case nation of 1 :
28426: LD_VAR 0 2
28430: PUSH
28431: LD_INT 1
28433: DOUBLE
28434: EQUAL
28435: IFTRUE 28439
28437: GO 28452
28439: POP
// list := us_weapons ; 2 :
28440: LD_ADDR_VAR 0 8
28444: PUSH
28445: LD_LOC 52
28449: ST_TO_ADDR
28450: GO 28495
28452: LD_INT 2
28454: DOUBLE
28455: EQUAL
28456: IFTRUE 28460
28458: GO 28473
28460: POP
// list := ar_weapons ; 3 :
28461: LD_ADDR_VAR 0 8
28465: PUSH
28466: LD_LOC 53
28470: ST_TO_ADDR
28471: GO 28495
28473: LD_INT 3
28475: DOUBLE
28476: EQUAL
28477: IFTRUE 28481
28479: GO 28494
28481: POP
// list := ru_weapons ; end ;
28482: LD_ADDR_VAR 0 8
28486: PUSH
28487: LD_LOC 54
28491: ST_TO_ADDR
28492: GO 28495
28494: POP
// for chassis = 1 to 3 do
28495: LD_ADDR_VAR 0 6
28499: PUSH
28500: DOUBLE
28501: LD_INT 1
28503: DEC
28504: ST_TO_ADDR
28505: LD_INT 3
28507: PUSH
28508: FOR_TO
28509: IFFALSE 28671
// if ( chassis < 3 ) or ( nation = nation_russian ) or ( TrackExtension ( factory ) ) then
28511: LD_VAR 0 6
28515: PUSH
28516: LD_INT 3
28518: LESS
28519: PUSH
28520: LD_VAR 0 2
28524: PUSH
28525: LD_INT 3
28527: EQUAL
28528: OR
28529: PUSH
28530: LD_VAR 0 3
28534: PPUSH
28535: CALL 29579 0 1
28539: OR
28540: IFFALSE 28669
// for weapon in list [ chassis ] do
28542: LD_ADDR_VAR 0 7
28546: PUSH
28547: LD_VAR 0 8
28551: PUSH
28552: LD_VAR 0 6
28556: ARRAY
28557: PUSH
28558: FOR_IN
28559: IFFALSE 28667
// if Technology_Researched ( side , weapon [ 2 ] ) or not weapon [ 2 ] then
28561: LD_VAR 0 1
28565: PPUSH
28566: LD_VAR 0 7
28570: PUSH
28571: LD_INT 2
28573: ARRAY
28574: PPUSH
28575: CALL 28688 0 2
28579: PUSH
28580: LD_VAR 0 7
28584: PUSH
28585: LD_INT 2
28587: ARRAY
28588: NOT
28589: OR
28590: IFFALSE 28665
// begin if ExtensionBuild ( factory , weapon [ 3 ] ) or not weapon [ 3 ] then
28592: LD_VAR 0 3
28596: PPUSH
28597: LD_VAR 0 7
28601: PUSH
28602: LD_INT 3
28604: ARRAY
28605: PPUSH
28606: CALL 28758 0 2
28610: PUSH
28611: LD_VAR 0 7
28615: PUSH
28616: LD_INT 3
28618: ARRAY
28619: NOT
28620: OR
28621: IFFALSE 28645
// vysledek := vysledek ^ weapon [ 1 ] else
28623: LD_ADDR_VAR 0 5
28627: PUSH
28628: LD_VAR 0 5
28632: PUSH
28633: LD_VAR 0 7
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: ADD
28642: ST_TO_ADDR
28643: GO 28665
// extension_wanted := extension_wanted ^ weapon [ 3 ] ;
28645: LD_ADDR_EXP 73
28649: PUSH
28650: LD_EXP 73
28654: PUSH
28655: LD_VAR 0 7
28659: PUSH
28660: LD_INT 3
28662: ARRAY
28663: ADD
28664: ST_TO_ADDR
// end ;
28665: GO 28558
28667: POP
28668: POP
28669: GO 28508
28671: POP
28672: POP
// result := vysledek ;
28673: LD_ADDR_VAR 0 4
28677: PUSH
28678: LD_VAR 0 5
28682: ST_TO_ADDR
// end ;
28683: LD_VAR 0 4
28687: RET
// function Technology_Researched ( side , list ) ; var tech , vysledek ; begin
28688: LD_INT 0
28690: PPUSH
28691: PPUSH
28692: PPUSH
// vysledek := true ;
28693: LD_ADDR_VAR 0 5
28697: PUSH
28698: LD_INT 1
28700: ST_TO_ADDR
// for tech in list do
28701: LD_ADDR_VAR 0 4
28705: PUSH
28706: LD_VAR 0 2
28710: PUSH
28711: FOR_IN
28712: IFFALSE 28741
// if not Researched ( side , tech ) then
28714: LD_VAR 0 1
28718: PPUSH
28719: LD_VAR 0 4
28723: PPUSH
28724: CALL_OW 325
28728: NOT
28729: IFFALSE 28739
// vysledek := false ;
28731: LD_ADDR_VAR 0 5
28735: PUSH
28736: LD_INT 0
28738: ST_TO_ADDR
28739: GO 28711
28741: POP
28742: POP
// result := vysledek ;
28743: LD_ADDR_VAR 0 3
28747: PUSH
28748: LD_VAR 0 5
28752: ST_TO_ADDR
// end ;
28753: LD_VAR 0 3
28757: RET
// function ExtensionBuild ( factory , extension ) ; var i , vysledek , list ; begin
28758: LD_INT 0
28760: PPUSH
28761: PPUSH
28762: PPUSH
28763: PPUSH
// vysledek := false ;
28764: LD_ADDR_VAR 0 5
28768: PUSH
28769: LD_INT 0
28771: ST_TO_ADDR
// if extension > 0 then
28772: LD_VAR 0 2
28776: PUSH
28777: LD_INT 0
28779: GREATER
28780: IFFALSE 28861
// begin list := GetExtPositions ( factory ) ;
28782: LD_ADDR_VAR 0 6
28786: PUSH
28787: LD_VAR 0 1
28791: PPUSH
28792: CALL_OW 270
28796: ST_TO_ADDR
// for i in list do
28797: LD_ADDR_VAR 0 4
28801: PUSH
28802: LD_VAR 0 6
28806: PUSH
28807: FOR_IN
28808: IFFALSE 28857
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = extension then
28810: LD_VAR 0 4
28814: PUSH
28815: LD_INT 1
28817: ARRAY
28818: PPUSH
28819: LD_VAR 0 4
28823: PUSH
28824: LD_INT 2
28826: ARRAY
28827: PPUSH
28828: CALL_OW 428
28832: PPUSH
28833: CALL_OW 266
28837: PUSH
28838: LD_VAR 0 2
28842: EQUAL
28843: IFFALSE 28855
// begin vysledek := true ;
28845: LD_ADDR_VAR 0 5
28849: PUSH
28850: LD_INT 1
28852: ST_TO_ADDR
// break ;
28853: GO 28857
// end ;
28855: GO 28807
28857: POP
28858: POP
// end else
28859: GO 28869
// vysledek := true ;
28861: LD_ADDR_VAR 0 5
28865: PUSH
28866: LD_INT 1
28868: ST_TO_ADDR
// result := vysledek ;
28869: LD_ADDR_VAR 0 3
28873: PUSH
28874: LD_VAR 0 5
28878: ST_TO_ADDR
// end ;
28879: LD_VAR 0 3
28883: RET
// function get_next_vehicle ( side , nation , factory , possible ) ; var un , pom , list , cargo_bay , crane , nation_cargo , nation_crane , weapon_prefered , weapon_else , vysledek ; begin
28884: LD_INT 0
28886: PPUSH
28887: PPUSH
28888: PPUSH
28889: PPUSH
28890: PPUSH
28891: PPUSH
28892: PPUSH
28893: PPUSH
28894: PPUSH
28895: PPUSH
28896: PPUSH
// vysledek := [ ] ;
28897: LD_ADDR_VAR 0 15
28901: PUSH
28902: EMPTY
28903: ST_TO_ADDR
// case nation of 1 :
28904: LD_VAR 0 2
28908: PUSH
28909: LD_INT 1
28911: DOUBLE
28912: EQUAL
28913: IFTRUE 28917
28915: GO 28946
28917: POP
// begin list := us_weapons ;
28918: LD_ADDR_VAR 0 8
28922: PUSH
28923: LD_LOC 52
28927: ST_TO_ADDR
// nation_cargo := us_cargo_bay ;
28928: LD_ADDR_VAR 0 11
28932: PUSH
28933: LD_INT 12
28935: ST_TO_ADDR
// nation_crane := us_crane ;
28936: LD_ADDR_VAR 0 12
28940: PUSH
28941: LD_INT 13
28943: ST_TO_ADDR
// end ; 2 :
28944: GO 29021
28946: LD_INT 2
28948: DOUBLE
28949: EQUAL
28950: IFTRUE 28954
28952: GO 28983
28954: POP
// begin list := ar_weapons ;
28955: LD_ADDR_VAR 0 8
28959: PUSH
28960: LD_LOC 53
28964: ST_TO_ADDR
// nation_cargo := ar_cargo_bay ;
28965: LD_ADDR_VAR 0 11
28969: PUSH
28970: LD_INT 32
28972: ST_TO_ADDR
// nation_crane := 0 ;
28973: LD_ADDR_VAR 0 12
28977: PUSH
28978: LD_INT 0
28980: ST_TO_ADDR
// end ; 3 :
28981: GO 29021
28983: LD_INT 3
28985: DOUBLE
28986: EQUAL
28987: IFTRUE 28991
28989: GO 29020
28991: POP
// begin list := ru_weapons ;
28992: LD_ADDR_VAR 0 8
28996: PUSH
28997: LD_LOC 54
29001: ST_TO_ADDR
// nation_cargo := ru_cargo_bay ;
29002: LD_ADDR_VAR 0 11
29006: PUSH
29007: LD_INT 51
29009: ST_TO_ADDR
// nation_crane := ru_crane ;
29010: LD_ADDR_VAR 0 12
29014: PUSH
29015: LD_INT 52
29017: ST_TO_ADDR
// end ; end ;
29018: GO 29021
29020: POP
// pom := AvailableWeaponList ( factory ) ;
29021: LD_ADDR_VAR 0 7
29025: PUSH
29026: LD_VAR 0 3
29030: PPUSH
29031: CALL_OW 478
29035: ST_TO_ADDR
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
29036: LD_ADDR_VAR 0 9
29040: PUSH
29041: LD_INT 22
29043: PUSH
29044: LD_VAR 0 1
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: LD_INT 21
29055: PUSH
29056: LD_INT 2
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 34
29065: PUSH
29066: LD_VAR 0 11
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: PPUSH
29080: CALL_OW 69
29084: ST_TO_ADDR
// if ( not cargo_bay ) and ( nation_cargo in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29085: LD_VAR 0 9
29089: NOT
29090: PUSH
29091: LD_VAR 0 11
29095: PUSH
29096: LD_VAR 0 7
29100: IN
29101: AND
29102: PUSH
29103: LD_VAR 0 3
29107: PPUSH
29108: CALL 29516 0 1
29112: AND
29113: PUSH
29114: LD_VAR 0 3
29118: PPUSH
29119: CALL 29579 0 1
29123: AND
29124: IFFALSE 29158
// vysledek := Define_NonCombat ( side , nation , factory , nation_cargo ) else
29126: LD_ADDR_VAR 0 15
29130: PUSH
29131: LD_VAR 0 1
29135: PPUSH
29136: LD_VAR 0 2
29140: PPUSH
29141: LD_VAR 0 3
29145: PPUSH
29146: LD_VAR 0 11
29150: PPUSH
29151: CALL 29605 0 4
29155: ST_TO_ADDR
29156: GO 29174
// possible := possible diff nation_cargo ;
29158: LD_ADDR_VAR 0 4
29162: PUSH
29163: LD_VAR 0 4
29167: PUSH
29168: LD_VAR 0 11
29172: DIFF
29173: ST_TO_ADDR
// if not vysledek then
29174: LD_VAR 0 15
29178: NOT
29179: IFFALSE 29319
// begin crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
29181: LD_ADDR_VAR 0 10
29185: PUSH
29186: LD_INT 22
29188: PUSH
29189: LD_VAR 0 1
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 21
29200: PUSH
29201: LD_INT 2
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 34
29210: PUSH
29211: LD_VAR 0 12
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: LIST
29224: PPUSH
29225: CALL_OW 69
29229: ST_TO_ADDR
// if ( not crane ) and ( nation_crane in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29230: LD_VAR 0 10
29234: NOT
29235: PUSH
29236: LD_VAR 0 12
29240: PUSH
29241: LD_VAR 0 7
29245: IN
29246: AND
29247: PUSH
29248: LD_VAR 0 3
29252: PPUSH
29253: CALL 29516 0 1
29257: AND
29258: PUSH
29259: LD_VAR 0 3
29263: PPUSH
29264: CALL 29579 0 1
29268: AND
29269: IFFALSE 29303
// vysledek := Define_NonCombat ( side , nation , factory , nation_crane ) else
29271: LD_ADDR_VAR 0 15
29275: PUSH
29276: LD_VAR 0 1
29280: PPUSH
29281: LD_VAR 0 2
29285: PPUSH
29286: LD_VAR 0 3
29290: PPUSH
29291: LD_VAR 0 12
29295: PPUSH
29296: CALL 29605 0 4
29300: ST_TO_ADDR
29301: GO 29319
// possible := possible diff nation_crane ;
29303: LD_ADDR_VAR 0 4
29307: PUSH
29308: LD_VAR 0 4
29312: PUSH
29313: LD_VAR 0 12
29317: DIFF
29318: ST_TO_ADDR
// end ; if not vysledek then
29319: LD_VAR 0 15
29323: NOT
29324: IFFALSE 29501
// begin weapon_prefered := [ ] ;
29326: LD_ADDR_VAR 0 13
29330: PUSH
29331: EMPTY
29332: ST_TO_ADDR
// weapon_else := 0 ;
29333: LD_ADDR_VAR 0 14
29337: PUSH
29338: LD_INT 0
29340: ST_TO_ADDR
// for un in prefered do
29341: LD_ADDR_VAR 0 6
29345: PUSH
29346: LD_LOC 57
29350: PUSH
29351: FOR_IN
29352: IFFALSE 29391
// if ( un [ 4 ] in possible ) then
29354: LD_VAR 0 6
29358: PUSH
29359: LD_INT 4
29361: ARRAY
29362: PUSH
29363: LD_VAR 0 4
29367: IN
29368: IFFALSE 29389
// weapon_prefered := weapon_prefered ^ [ un ] ;
29370: LD_ADDR_VAR 0 13
29374: PUSH
29375: LD_VAR 0 13
29379: PUSH
29380: LD_VAR 0 6
29384: PUSH
29385: EMPTY
29386: LIST
29387: ADD
29388: ST_TO_ADDR
29389: GO 29351
29391: POP
29392: POP
// if not weapon_prefered then
29393: LD_VAR 0 13
29397: NOT
29398: IFFALSE 29471
// begin for un in possible do
29400: LD_ADDR_VAR 0 6
29404: PUSH
29405: LD_VAR 0 4
29409: PUSH
29410: FOR_IN
29411: IFFALSE 29437
// if un > weapon_else then
29413: LD_VAR 0 6
29417: PUSH
29418: LD_VAR 0 14
29422: GREATER
29423: IFFALSE 29435
// weapon_else := un ;
29425: LD_ADDR_VAR 0 14
29429: PUSH
29430: LD_VAR 0 6
29434: ST_TO_ADDR
29435: GO 29410
29437: POP
29438: POP
// vysledek := Define_Vehicle ( side , nation , factory , weapon_else ) ;
29439: LD_ADDR_VAR 0 15
29443: PUSH
29444: LD_VAR 0 1
29448: PPUSH
29449: LD_VAR 0 2
29453: PPUSH
29454: LD_VAR 0 3
29458: PPUSH
29459: LD_VAR 0 14
29463: PPUSH
29464: CALL 30405 0 4
29468: ST_TO_ADDR
// end else
29469: GO 29501
// vysledek := Select_from_Prefered ( side , nation , factory , weapon_prefered ) ;
29471: LD_ADDR_VAR 0 15
29475: PUSH
29476: LD_VAR 0 1
29480: PPUSH
29481: LD_VAR 0 2
29485: PPUSH
29486: LD_VAR 0 3
29490: PPUSH
29491: LD_VAR 0 13
29495: PPUSH
29496: CALL 29877 0 4
29500: ST_TO_ADDR
// end ; result := vysledek ;
29501: LD_ADDR_VAR 0 5
29505: PUSH
29506: LD_VAR 0 15
29510: ST_TO_ADDR
// end ;
29511: LD_VAR 0 5
29515: RET
// function Remote_or_Computer ( factory ) ; var vysledek ; begin
29516: LD_INT 0
29518: PPUSH
29519: PPUSH
// vysledek := false ;
29520: LD_ADDR_VAR 0 3
29524: PUSH
29525: LD_INT 0
29527: ST_TO_ADDR
// if ExtensionBuild ( factory , b_ext_computer ) or ExtensionBuild ( factory , b_ext_radar ) then
29528: LD_VAR 0 1
29532: PPUSH
29533: LD_INT 24
29535: PPUSH
29536: CALL 28758 0 2
29540: PUSH
29541: LD_VAR 0 1
29545: PPUSH
29546: LD_INT 20
29548: PPUSH
29549: CALL 28758 0 2
29553: OR
29554: IFFALSE 29564
// vysledek := true ;
29556: LD_ADDR_VAR 0 3
29560: PUSH
29561: LD_INT 1
29563: ST_TO_ADDR
// result := vysledek ;
29564: LD_ADDR_VAR 0 2
29568: PUSH
29569: LD_VAR 0 3
29573: ST_TO_ADDR
// end ;
29574: LD_VAR 0 2
29578: RET
// function TrackExtension ( factory ) ; begin
29579: LD_INT 0
29581: PPUSH
// result := ExtensionBuild ( factory , b_ext_track ) ;
29582: LD_ADDR_VAR 0 2
29586: PUSH
29587: LD_VAR 0 1
29591: PPUSH
29592: LD_INT 16
29594: PPUSH
29595: CALL 28758 0 2
29599: ST_TO_ADDR
// end ;
29600: LD_VAR 0 2
29604: RET
// function Define_NonCombat ( side , nation , factory , weapon ) ; var components ; begin
29605: LD_INT 0
29607: PPUSH
29608: PPUSH
// components := [ ] ;
29609: LD_ADDR_VAR 0 6
29613: PUSH
29614: EMPTY
29615: ST_TO_ADDR
// case nation of 1 :
29616: LD_VAR 0 2
29620: PUSH
29621: LD_INT 1
29623: DOUBLE
29624: EQUAL
29625: IFTRUE 29629
29627: GO 29646
29629: POP
// components := components ^ us_medium_tracked ; 2 :
29630: LD_ADDR_VAR 0 6
29634: PUSH
29635: LD_VAR 0 6
29639: PUSH
29640: LD_INT 3
29642: ADD
29643: ST_TO_ADDR
29644: GO 29697
29646: LD_INT 2
29648: DOUBLE
29649: EQUAL
29650: IFTRUE 29654
29652: GO 29671
29654: POP
// components := components ^ ar_half_tracked ; 3 :
29655: LD_ADDR_VAR 0 6
29659: PUSH
29660: LD_VAR 0 6
29664: PUSH
29665: LD_INT 14
29667: ADD
29668: ST_TO_ADDR
29669: GO 29697
29671: LD_INT 3
29673: DOUBLE
29674: EQUAL
29675: IFTRUE 29679
29677: GO 29696
29679: POP
// components := components ^ ru_medium_tracked ; end ;
29680: LD_ADDR_VAR 0 6
29684: PUSH
29685: LD_VAR 0 6
29689: PUSH
29690: LD_INT 22
29692: ADD
29693: ST_TO_ADDR
29694: GO 29697
29696: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
29697: LD_VAR 0 3
29701: PPUSH
29702: LD_INT 21
29704: PPUSH
29705: CALL 28758 0 2
29709: PUSH
29710: LD_VAR 0 1
29714: PPUSH
29715: CALL 28116 0 1
29719: PUSH
29720: LD_INT 3
29722: ARRAY
29723: PUSH
29724: LD_LOC 55
29728: GREATEREQUAL
29729: AND
29730: IFFALSE 29748
// components := components ^ engine_siberite else
29732: LD_ADDR_VAR 0 6
29736: PUSH
29737: LD_VAR 0 6
29741: PUSH
29742: LD_INT 3
29744: ADD
29745: ST_TO_ADDR
29746: GO 29762
// components := components ^ engine_combustion ;
29748: LD_ADDR_VAR 0 6
29752: PUSH
29753: LD_VAR 0 6
29757: PUSH
29758: LD_INT 1
29760: ADD
29761: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
29762: LD_VAR 0 2
29766: PUSH
29767: LD_INT 2
29769: EQUAL
29770: PUSH
29771: LD_VAR 0 1
29775: PPUSH
29776: CALL 31290 0 1
29780: AND
29781: IFFALSE 29799
// components := components ^ control_apeman else
29783: LD_ADDR_VAR 0 6
29787: PUSH
29788: LD_VAR 0 6
29792: PUSH
29793: LD_INT 5
29795: ADD
29796: ST_TO_ADDR
29797: GO 29843
// if ExtensionBuild ( factory , b_ext_computer ) then
29799: LD_VAR 0 3
29803: PPUSH
29804: LD_INT 24
29806: PPUSH
29807: CALL 28758 0 2
29811: IFFALSE 29829
// components := components ^ control_computer else
29813: LD_ADDR_VAR 0 6
29817: PUSH
29818: LD_VAR 0 6
29822: PUSH
29823: LD_INT 3
29825: ADD
29826: ST_TO_ADDR
29827: GO 29843
// components := components ^ control_remote ;
29829: LD_ADDR_VAR 0 6
29833: PUSH
29834: LD_VAR 0 6
29838: PUSH
29839: LD_INT 2
29841: ADD
29842: ST_TO_ADDR
// components := components ^ [ weapon ] ;
29843: LD_ADDR_VAR 0 6
29847: PUSH
29848: LD_VAR 0 6
29852: PUSH
29853: LD_VAR 0 4
29857: PUSH
29858: EMPTY
29859: LIST
29860: ADD
29861: ST_TO_ADDR
// result := components ;
29862: LD_ADDR_VAR 0 5
29866: PUSH
29867: LD_VAR 0 6
29871: ST_TO_ADDR
// end ;
29872: LD_VAR 0 5
29876: RET
// function Select_from_Prefered ( side , nation , factory , possible ) ; var un , i , count , components , controls , vysledek ; begin
29877: LD_INT 0
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
29884: PPUSH
29885: PPUSH
// count := [ - 1 , 0 ] ;
29886: LD_ADDR_VAR 0 8
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: LD_INT 0
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: ST_TO_ADDR
// for un in possible do
29902: LD_ADDR_VAR 0 6
29906: PUSH
29907: LD_VAR 0 4
29911: PUSH
29912: FOR_IN
29913: IFFALSE 30012
// begin i := 0 + FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , un [ 4 ] ] ] ) ;
29915: LD_ADDR_VAR 0 7
29919: PUSH
29920: LD_INT 0
29922: PUSH
29923: LD_INT 22
29925: PUSH
29926: LD_VAR 0 1
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 34
29937: PUSH
29938: LD_VAR 0 6
29942: PUSH
29943: LD_INT 4
29945: ARRAY
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PPUSH
29955: CALL_OW 69
29959: PLUS
29960: ST_TO_ADDR
// if ( count [ 1 ] < 0 ) or ( count [ 1 ] > i ) then
29961: LD_VAR 0 8
29965: PUSH
29966: LD_INT 1
29968: ARRAY
29969: PUSH
29970: LD_INT 0
29972: LESS
29973: PUSH
29974: LD_VAR 0 8
29978: PUSH
29979: LD_INT 1
29981: ARRAY
29982: PUSH
29983: LD_VAR 0 7
29987: GREATER
29988: OR
29989: IFFALSE 30010
// count := [ i , un ] ;
29991: LD_ADDR_VAR 0 8
29995: PUSH
29996: LD_VAR 0 7
30000: PUSH
30001: LD_VAR 0 6
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: ST_TO_ADDR
// end ;
30010: GO 29912
30012: POP
30013: POP
// un := count [ 2 ] ;
30014: LD_ADDR_VAR 0 6
30018: PUSH
30019: LD_VAR 0 8
30023: PUSH
30024: LD_INT 2
30026: ARRAY
30027: ST_TO_ADDR
// components := [ ] ;
30028: LD_ADDR_VAR 0 9
30032: PUSH
30033: EMPTY
30034: ST_TO_ADDR
// controls := AvailableControlList ( factory ) ;
30035: LD_ADDR_VAR 0 10
30039: PUSH
30040: LD_VAR 0 3
30044: PPUSH
30045: CALL_OW 477
30049: ST_TO_ADDR
// if un [ 1 ] in AvailableChassisList ( factory ) then
30050: LD_VAR 0 6
30054: PUSH
30055: LD_INT 1
30057: ARRAY
30058: PUSH
30059: LD_VAR 0 3
30063: PPUSH
30064: CALL_OW 475
30068: IN
30069: IFFALSE 30093
// components := components ^ un [ 1 ] else
30071: LD_ADDR_VAR 0 9
30075: PUSH
30076: LD_VAR 0 9
30080: PUSH
30081: LD_VAR 0 6
30085: PUSH
30086: LD_INT 1
30088: ARRAY
30089: ADD
30090: ST_TO_ADDR
30091: GO 30143
// components := components ^ SelectChassis ( side , nation , factory , ChassisWeight ( nation , un [ 4 ] ) ) ;
30093: LD_ADDR_VAR 0 9
30097: PUSH
30098: LD_VAR 0 9
30102: PUSH
30103: LD_VAR 0 1
30107: PPUSH
30108: LD_VAR 0 2
30112: PPUSH
30113: LD_VAR 0 3
30117: PPUSH
30118: LD_VAR 0 2
30122: PPUSH
30123: LD_VAR 0 6
30127: PUSH
30128: LD_INT 4
30130: ARRAY
30131: PPUSH
30132: CALL 31113 0 2
30136: PPUSH
30137: CALL 30747 0 4
30141: ADD
30142: ST_TO_ADDR
// if un [ 2 ] in AvailableEngineList ( factory ) then
30143: LD_VAR 0 6
30147: PUSH
30148: LD_INT 2
30150: ARRAY
30151: PUSH
30152: LD_VAR 0 3
30156: PPUSH
30157: CALL_OW 476
30161: IN
30162: IFFALSE 30186
// components := components ^ un [ 2 ] else
30164: LD_ADDR_VAR 0 9
30168: PUSH
30169: LD_VAR 0 9
30173: PUSH
30174: LD_VAR 0 6
30178: PUSH
30179: LD_INT 2
30181: ARRAY
30182: ADD
30183: ST_TO_ADDR
30184: GO 30261
// if ( not components [ 1 ] in [ us_light_wheeled , ar_hovercraft , ar_light_trike ] ) and ( Get_Resources ( side ) [ 3 ] > 9 ) then
30186: LD_VAR 0 9
30190: PUSH
30191: LD_INT 1
30193: ARRAY
30194: PUSH
30195: LD_INT 1
30197: PUSH
30198: LD_INT 11
30200: PUSH
30201: LD_INT 12
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: LIST
30208: IN
30209: NOT
30210: PUSH
30211: LD_VAR 0 1
30215: PPUSH
30216: CALL 28116 0 1
30220: PUSH
30221: LD_INT 3
30223: ARRAY
30224: PUSH
30225: LD_INT 9
30227: GREATER
30228: AND
30229: IFFALSE 30247
// components := components ^ engine_siberite else
30231: LD_ADDR_VAR 0 9
30235: PUSH
30236: LD_VAR 0 9
30240: PUSH
30241: LD_INT 3
30243: ADD
30244: ST_TO_ADDR
30245: GO 30261
// components := components ^ engine_combustion ;
30247: LD_ADDR_VAR 0 9
30251: PUSH
30252: LD_VAR 0 9
30256: PUSH
30257: LD_INT 1
30259: ADD
30260: ST_TO_ADDR
// if un [ 3 ] in AvailableControlList ( factory ) then
30261: LD_VAR 0 6
30265: PUSH
30266: LD_INT 3
30268: ARRAY
30269: PUSH
30270: LD_VAR 0 3
30274: PPUSH
30275: CALL_OW 477
30279: IN
30280: IFFALSE 30304
// components := components ^ un [ 3 ] else
30282: LD_ADDR_VAR 0 9
30286: PUSH
30287: LD_VAR 0 9
30291: PUSH
30292: LD_VAR 0 6
30296: PUSH
30297: LD_INT 3
30299: ARRAY
30300: ADD
30301: ST_TO_ADDR
30302: GO 30370
// begin if control_remote in controls then
30304: LD_INT 2
30306: PUSH
30307: LD_VAR 0 10
30311: IN
30312: IFFALSE 30330
// components := components ^ control_remote else
30314: LD_ADDR_VAR 0 9
30318: PUSH
30319: LD_VAR 0 9
30323: PUSH
30324: LD_INT 2
30326: ADD
30327: ST_TO_ADDR
30328: GO 30370
// if control_computer in controls then
30330: LD_INT 3
30332: PUSH
30333: LD_VAR 0 10
30337: IN
30338: IFFALSE 30356
// components := components ^ control_computer else
30340: LD_ADDR_VAR 0 9
30344: PUSH
30345: LD_VAR 0 9
30349: PUSH
30350: LD_INT 3
30352: ADD
30353: ST_TO_ADDR
30354: GO 30370
// components := components ^ control_manual ;
30356: LD_ADDR_VAR 0 9
30360: PUSH
30361: LD_VAR 0 9
30365: PUSH
30366: LD_INT 1
30368: ADD
30369: ST_TO_ADDR
// end ; components := components ^ un [ 4 ] ;
30370: LD_ADDR_VAR 0 9
30374: PUSH
30375: LD_VAR 0 9
30379: PUSH
30380: LD_VAR 0 6
30384: PUSH
30385: LD_INT 4
30387: ARRAY
30388: ADD
30389: ST_TO_ADDR
// result := components ;
30390: LD_ADDR_VAR 0 5
30394: PUSH
30395: LD_VAR 0 9
30399: ST_TO_ADDR
// end ;
30400: LD_VAR 0 5
30404: RET
// function Define_Vehicle ( side , nation , factory , weapon ) ; var components ; begin
30405: LD_INT 0
30407: PPUSH
30408: PPUSH
// components := [ ] ;
30409: LD_ADDR_VAR 0 6
30413: PUSH
30414: EMPTY
30415: ST_TO_ADDR
// case ChassisWeight ( nation , weapon ) of 1 :
30416: LD_VAR 0 2
30420: PPUSH
30421: LD_VAR 0 4
30425: PPUSH
30426: CALL 31113 0 2
30430: PUSH
30431: LD_INT 1
30433: DOUBLE
30434: EQUAL
30435: IFTRUE 30439
30437: GO 30476
30439: POP
// components := components ^ SelectChassis ( side , nation , factory , 1 ) ; 2 :
30440: LD_ADDR_VAR 0 6
30444: PUSH
30445: LD_VAR 0 6
30449: PUSH
30450: LD_VAR 0 1
30454: PPUSH
30455: LD_VAR 0 2
30459: PPUSH
30460: LD_VAR 0 3
30464: PPUSH
30465: LD_INT 1
30467: PPUSH
30468: CALL 30747 0 4
30472: ADD
30473: ST_TO_ADDR
30474: GO 30567
30476: LD_INT 2
30478: DOUBLE
30479: EQUAL
30480: IFTRUE 30484
30482: GO 30521
30484: POP
// components := components ^ SelectChassis ( side , nation , factory , 2 ) ; 3 :
30485: LD_ADDR_VAR 0 6
30489: PUSH
30490: LD_VAR 0 6
30494: PUSH
30495: LD_VAR 0 1
30499: PPUSH
30500: LD_VAR 0 2
30504: PPUSH
30505: LD_VAR 0 3
30509: PPUSH
30510: LD_INT 2
30512: PPUSH
30513: CALL 30747 0 4
30517: ADD
30518: ST_TO_ADDR
30519: GO 30567
30521: LD_INT 3
30523: DOUBLE
30524: EQUAL
30525: IFTRUE 30529
30527: GO 30566
30529: POP
// components := components ^ SelectChassis ( side , nation , factory , 3 ) ; end ;
30530: LD_ADDR_VAR 0 6
30534: PUSH
30535: LD_VAR 0 6
30539: PUSH
30540: LD_VAR 0 1
30544: PPUSH
30545: LD_VAR 0 2
30549: PPUSH
30550: LD_VAR 0 3
30554: PPUSH
30555: LD_INT 3
30557: PPUSH
30558: CALL 30747 0 4
30562: ADD
30563: ST_TO_ADDR
30564: GO 30567
30566: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30567: LD_VAR 0 3
30571: PPUSH
30572: LD_INT 21
30574: PPUSH
30575: CALL 28758 0 2
30579: PUSH
30580: LD_VAR 0 1
30584: PPUSH
30585: CALL 28116 0 1
30589: PUSH
30590: LD_INT 3
30592: ARRAY
30593: PUSH
30594: LD_LOC 55
30598: GREATEREQUAL
30599: AND
30600: IFFALSE 30618
// components := components ^ engine_siberite else
30602: LD_ADDR_VAR 0 6
30606: PUSH
30607: LD_VAR 0 6
30611: PUSH
30612: LD_INT 3
30614: ADD
30615: ST_TO_ADDR
30616: GO 30632
// components := components ^ engine_combustion ;
30618: LD_ADDR_VAR 0 6
30622: PUSH
30623: LD_VAR 0 6
30627: PUSH
30628: LD_INT 1
30630: ADD
30631: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30632: LD_VAR 0 2
30636: PUSH
30637: LD_INT 2
30639: EQUAL
30640: PUSH
30641: LD_VAR 0 1
30645: PPUSH
30646: CALL 31290 0 1
30650: AND
30651: IFFALSE 30669
// components := components ^ control_apeman else
30653: LD_ADDR_VAR 0 6
30657: PUSH
30658: LD_VAR 0 6
30662: PUSH
30663: LD_INT 5
30665: ADD
30666: ST_TO_ADDR
30667: GO 30713
// if ExtensionBuild ( factory , b_ext_computer ) then
30669: LD_VAR 0 3
30673: PPUSH
30674: LD_INT 24
30676: PPUSH
30677: CALL 28758 0 2
30681: IFFALSE 30699
// components := components ^ control_computer else
30683: LD_ADDR_VAR 0 6
30687: PUSH
30688: LD_VAR 0 6
30692: PUSH
30693: LD_INT 3
30695: ADD
30696: ST_TO_ADDR
30697: GO 30713
// components := components ^ control_remote ;
30699: LD_ADDR_VAR 0 6
30703: PUSH
30704: LD_VAR 0 6
30708: PUSH
30709: LD_INT 2
30711: ADD
30712: ST_TO_ADDR
// components := components ^ [ weapon ] ;
30713: LD_ADDR_VAR 0 6
30717: PUSH
30718: LD_VAR 0 6
30722: PUSH
30723: LD_VAR 0 4
30727: PUSH
30728: EMPTY
30729: LIST
30730: ADD
30731: ST_TO_ADDR
// result := components ;
30732: LD_ADDR_VAR 0 5
30736: PUSH
30737: LD_VAR 0 6
30741: ST_TO_ADDR
// end ;
30742: LD_VAR 0 5
30746: RET
// function SelectChassis ( side , nation , factory , weight ) ; var un , vysledek ; begin
30747: LD_INT 0
30749: PPUSH
30750: PPUSH
30751: PPUSH
// vysledek := 0 ;
30752: LD_ADDR_VAR 0 7
30756: PUSH
30757: LD_INT 0
30759: ST_TO_ADDR
// case weight of 1 :
30760: LD_VAR 0 4
30764: PUSH
30765: LD_INT 1
30767: DOUBLE
30768: EQUAL
30769: IFTRUE 30773
30771: GO 30836
30773: POP
// begin case nation of 1 :
30774: LD_VAR 0 2
30778: PUSH
30779: LD_INT 1
30781: DOUBLE
30782: EQUAL
30783: IFTRUE 30787
30785: GO 30798
30787: POP
// vysledek := us_light_wheeled ; 2 :
30788: LD_ADDR_VAR 0 7
30792: PUSH
30793: LD_INT 1
30795: ST_TO_ADDR
30796: GO 30834
30798: LD_INT 2
30800: DOUBLE
30801: EQUAL
30802: IFTRUE 30806
30804: GO 30833
30806: POP
// if hovers_recomended then
30807: LD_LOC 59
30811: IFFALSE 30823
// vysledek := ar_hovercraft else
30813: LD_ADDR_VAR 0 7
30817: PUSH
30818: LD_INT 11
30820: ST_TO_ADDR
30821: GO 30831
// vysledek := ar_light_trike ; end ;
30823: LD_ADDR_VAR 0 7
30827: PUSH
30828: LD_INT 12
30830: ST_TO_ADDR
30831: GO 30834
30833: POP
// end ; 2 :
30834: GO 31098
30836: LD_INT 2
30838: DOUBLE
30839: EQUAL
30840: IFTRUE 30844
30842: GO 30993
30844: POP
// begin if ( not flat_land ) and TrackExtension ( factory ) then
30845: LD_LOC 60
30849: NOT
30850: PUSH
30851: LD_VAR 0 3
30855: PPUSH
30856: CALL 29579 0 1
30860: AND
30861: IFFALSE 30928
// case nation of 1 :
30863: LD_VAR 0 2
30867: PUSH
30868: LD_INT 1
30870: DOUBLE
30871: EQUAL
30872: IFTRUE 30876
30874: GO 30887
30876: POP
// vysledek := us_medium_tracked ; 2 :
30877: LD_ADDR_VAR 0 7
30881: PUSH
30882: LD_INT 3
30884: ST_TO_ADDR
30885: GO 30926
30887: LD_INT 2
30889: DOUBLE
30890: EQUAL
30891: IFTRUE 30895
30893: GO 30906
30895: POP
// vysledek := ar_half_tracked ; 3 :
30896: LD_ADDR_VAR 0 7
30900: PUSH
30901: LD_INT 14
30903: ST_TO_ADDR
30904: GO 30926
30906: LD_INT 3
30908: DOUBLE
30909: EQUAL
30910: IFTRUE 30914
30912: GO 30925
30914: POP
// vysledek := ru_medium_tracked ; end else
30915: LD_ADDR_VAR 0 7
30919: PUSH
30920: LD_INT 22
30922: ST_TO_ADDR
30923: GO 30926
30925: POP
30926: GO 30991
// case nation of 1 :
30928: LD_VAR 0 2
30932: PUSH
30933: LD_INT 1
30935: DOUBLE
30936: EQUAL
30937: IFTRUE 30941
30939: GO 30952
30941: POP
// vysledek := us_medium_wheeled ; 2 :
30942: LD_ADDR_VAR 0 7
30946: PUSH
30947: LD_INT 2
30949: ST_TO_ADDR
30950: GO 30991
30952: LD_INT 2
30954: DOUBLE
30955: EQUAL
30956: IFTRUE 30960
30958: GO 30971
30960: POP
// vysledek := ar_medium_trike ; 3 :
30961: LD_ADDR_VAR 0 7
30965: PUSH
30966: LD_INT 13
30968: ST_TO_ADDR
30969: GO 30991
30971: LD_INT 3
30973: DOUBLE
30974: EQUAL
30975: IFTRUE 30979
30977: GO 30990
30979: POP
// vysledek := ru_medium_wheeled ; end end ; 3 :
30980: LD_ADDR_VAR 0 7
30984: PUSH
30985: LD_INT 21
30987: ST_TO_ADDR
30988: GO 30991
30990: POP
30991: GO 31098
30993: LD_INT 3
30995: DOUBLE
30996: EQUAL
30997: IFTRUE 31001
30999: GO 31097
31001: POP
// begin case nation of 1 :
31002: LD_VAR 0 2
31006: PUSH
31007: LD_INT 1
31009: DOUBLE
31010: EQUAL
31011: IFTRUE 31015
31013: GO 31054
31015: POP
// if GetTech ( side , tech_AdvChassis ) = state_researched then
31016: LD_VAR 0 1
31020: PPUSH
31021: LD_INT 36
31023: PPUSH
31024: CALL_OW 321
31028: PUSH
31029: LD_INT 2
31031: EQUAL
31032: IFFALSE 31044
// vysledek := us_morphling else
31034: LD_ADDR_VAR 0 7
31038: PUSH
31039: LD_INT 5
31041: ST_TO_ADDR
31042: GO 31052
// vysledek := us_heavy_tracked ; 3 :
31044: LD_ADDR_VAR 0 7
31048: PUSH
31049: LD_INT 4
31051: ST_TO_ADDR
31052: GO 31095
31054: LD_INT 3
31056: DOUBLE
31057: EQUAL
31058: IFTRUE 31062
31060: GO 31094
31062: POP
// if TrackExtension ( factory ) then
31063: LD_VAR 0 3
31067: PPUSH
31068: CALL 29579 0 1
31072: IFFALSE 31084
// vysledek := ru_heavy_tracked else
31074: LD_ADDR_VAR 0 7
31078: PUSH
31079: LD_INT 24
31081: ST_TO_ADDR
31082: GO 31092
// vysledek := ru_heavy_wheeled ; end end ; end ;
31084: LD_ADDR_VAR 0 7
31088: PUSH
31089: LD_INT 23
31091: ST_TO_ADDR
31092: GO 31095
31094: POP
31095: GO 31098
31097: POP
// result := vysledek ;
31098: LD_ADDR_VAR 0 5
31102: PUSH
31103: LD_VAR 0 7
31107: ST_TO_ADDR
// end ;
31108: LD_VAR 0 5
31112: RET
// function ChassisWeight ( nation , weapon ) ; var chassis , un , vysledek , weapon_list ; begin
31113: LD_INT 0
31115: PPUSH
31116: PPUSH
31117: PPUSH
31118: PPUSH
31119: PPUSH
// case nation of 1 :
31120: LD_VAR 0 1
31124: PUSH
31125: LD_INT 1
31127: DOUBLE
31128: EQUAL
31129: IFTRUE 31133
31131: GO 31146
31133: POP
// weapon_list := us_weapons ; 2 :
31134: LD_ADDR_VAR 0 7
31138: PUSH
31139: LD_LOC 52
31143: ST_TO_ADDR
31144: GO 31189
31146: LD_INT 2
31148: DOUBLE
31149: EQUAL
31150: IFTRUE 31154
31152: GO 31167
31154: POP
// weapon_list := ar_weapons ; 3 :
31155: LD_ADDR_VAR 0 7
31159: PUSH
31160: LD_LOC 53
31164: ST_TO_ADDR
31165: GO 31189
31167: LD_INT 3
31169: DOUBLE
31170: EQUAL
31171: IFTRUE 31175
31173: GO 31188
31175: POP
// weapon_list := ru_weapons ; end ;
31176: LD_ADDR_VAR 0 7
31180: PUSH
31181: LD_LOC 54
31185: ST_TO_ADDR
31186: GO 31189
31188: POP
// vysledek := false ;
31189: LD_ADDR_VAR 0 6
31193: PUSH
31194: LD_INT 0
31196: ST_TO_ADDR
// for chassis = 1 to 3 do
31197: LD_ADDR_VAR 0 4
31201: PUSH
31202: DOUBLE
31203: LD_INT 1
31205: DEC
31206: ST_TO_ADDR
31207: LD_INT 3
31209: PUSH
31210: FOR_TO
31211: IFFALSE 31273
// if not vysledek then
31213: LD_VAR 0 6
31217: NOT
31218: IFFALSE 31271
// for un in weapon_list [ chassis ] do
31220: LD_ADDR_VAR 0 5
31224: PUSH
31225: LD_VAR 0 7
31229: PUSH
31230: LD_VAR 0 4
31234: ARRAY
31235: PUSH
31236: FOR_IN
31237: IFFALSE 31269
// if weapon = un [ 1 ] then
31239: LD_VAR 0 2
31243: PUSH
31244: LD_VAR 0 5
31248: PUSH
31249: LD_INT 1
31251: ARRAY
31252: EQUAL
31253: IFFALSE 31267
// begin vysledek := chassis ;
31255: LD_ADDR_VAR 0 6
31259: PUSH
31260: LD_VAR 0 4
31264: ST_TO_ADDR
// break ;
31265: GO 31269
// end ;
31267: GO 31236
31269: POP
31270: POP
31271: GO 31210
31273: POP
31274: POP
// result := vysledek ;
31275: LD_ADDR_VAR 0 3
31279: PUSH
31280: LD_VAR 0 6
31284: ST_TO_ADDR
// end ;
31285: LD_VAR 0 3
31289: RET
// function ApemanCanDrive ( side ) ; var un ; begin
31290: LD_INT 0
31292: PPUSH
31293: PPUSH
// result := ( GetTech ( side , tech_ApeNeural ) = state_researched ) and FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31294: LD_ADDR_VAR 0 2
31298: PUSH
31299: LD_VAR 0 1
31303: PPUSH
31304: LD_INT 3
31306: PPUSH
31307: CALL_OW 321
31311: PUSH
31312: LD_INT 2
31314: EQUAL
31315: PUSH
31316: LD_INT 22
31318: PUSH
31319: LD_VAR 0 1
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 25
31330: PUSH
31331: LD_INT 12
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PPUSH
31342: CALL_OW 69
31346: AND
31347: ST_TO_ADDR
// end ;
31348: LD_VAR 0 2
31352: RET
// function transfer_mechanics ( side , mechanics , factory , components ) ; var un , isin ; begin
31353: LD_INT 0
31355: PPUSH
31356: PPUSH
31357: PPUSH
// isin := UnitsInside ( factory ) ;
31358: LD_ADDR_VAR 0 7
31362: PUSH
31363: LD_VAR 0 3
31367: PPUSH
31368: CALL_OW 313
31372: ST_TO_ADDR
// if ( 0 + isin ) > 5 then
31373: LD_INT 0
31375: PUSH
31376: LD_VAR 0 7
31380: PLUS
31381: PUSH
31382: LD_INT 5
31384: GREATER
31385: IFFALSE 31397
// begin result := true ;
31387: LD_ADDR_VAR 0 5
31391: PUSH
31392: LD_INT 1
31394: ST_TO_ADDR
// exit ;
31395: GO 31619
// end ; un := true ;
31397: LD_ADDR_VAR 0 6
31401: PUSH
31402: LD_INT 1
31404: ST_TO_ADDR
// if side = ar then
31405: LD_VAR 0 1
31409: PUSH
31410: LD_EXP 4
31414: EQUAL
31415: IFFALSE 31445
// mechanics := UnitFilter ( mechanics , [ f_not , [ f_driving ] ] ) ;
31417: LD_ADDR_VAR 0 2
31421: PUSH
31422: LD_VAR 0 2
31426: PPUSH
31427: LD_INT 3
31429: PUSH
31430: LD_INT 55
31432: PUSH
31433: EMPTY
31434: LIST
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PPUSH
31440: CALL_OW 72
31444: ST_TO_ADDR
// DoEnterUnit ( mechanics , factory ) ;
31445: LD_VAR 0 2
31449: PPUSH
31450: LD_VAR 0 3
31454: PPUSH
31455: CALL 31624 0 2
// if components [ 3 ] = control_apeman then
31459: LD_VAR 0 4
31463: PUSH
31464: LD_INT 3
31466: ARRAY
31467: PUSH
31468: LD_INT 5
31470: EQUAL
31471: IFFALSE 31609
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] , [ f_not , [ f_hastask ] ] ] ) ;
31473: LD_ADDR_VAR 0 6
31477: PUSH
31478: LD_INT 22
31480: PUSH
31481: LD_VAR 0 1
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 25
31492: PUSH
31493: LD_INT 12
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 3
31502: PUSH
31503: LD_INT 60
31505: PUSH
31506: EMPTY
31507: LIST
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: LIST
31517: PPUSH
31518: CALL_OW 69
31522: ST_TO_ADDR
// if un then
31523: LD_VAR 0 6
31527: IFFALSE 31549
// DoEnterUnit ( un [ 1 ] , factory ) else
31529: LD_VAR 0 6
31533: PUSH
31534: LD_INT 1
31536: ARRAY
31537: PPUSH
31538: LD_VAR 0 3
31542: PPUSH
31543: CALL 31624 0 2
31547: GO 31609
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31549: LD_ADDR_VAR 0 6
31553: PUSH
31554: LD_INT 22
31556: PUSH
31557: LD_VAR 0 1
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 25
31568: PUSH
31569: LD_INT 12
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PPUSH
31580: CALL_OW 69
31584: ST_TO_ADDR
// if un then
31585: LD_VAR 0 6
31589: IFFALSE 31609
// DoEnterUnit ( un [ 1 ] , factory ) ;
31591: LD_VAR 0 6
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: LD_VAR 0 3
31604: PPUSH
31605: CALL 31624 0 2
// end ; end ; result := un ;
31609: LD_ADDR_VAR 0 5
31613: PUSH
31614: LD_VAR 0 6
31618: ST_TO_ADDR
// end ;
31619: LD_VAR 0 5
31623: RET
// function DoEnterUnit ( moving_un_list , into_un ) ; var inside_un , t , moving_un ; begin
31624: LD_INT 0
31626: PPUSH
31627: PPUSH
31628: PPUSH
31629: PPUSH
// for moving_un in moving_un_list do
31630: LD_ADDR_VAR 0 6
31634: PUSH
31635: LD_VAR 0 1
31639: PUSH
31640: FOR_IN
31641: IFFALSE 31778
// begin inside_un = IsInUnit ( moving_un ) ;
31643: LD_ADDR_VAR 0 4
31647: PUSH
31648: LD_VAR 0 6
31652: PPUSH
31653: CALL_OW 310
31657: ST_TO_ADDR
// if inside_un <> into_un then
31658: LD_VAR 0 4
31662: PUSH
31663: LD_VAR 0 2
31667: NONEQUAL
31668: IFFALSE 31776
// begin if inside_un > 0 then
31670: LD_VAR 0 4
31674: PUSH
31675: LD_INT 0
31677: GREATER
31678: IFFALSE 31697
// t = GetType ( inside_un ) else
31680: LD_ADDR_VAR 0 5
31684: PUSH
31685: LD_VAR 0 4
31689: PPUSH
31690: CALL_OW 247
31694: ST_TO_ADDR
31695: GO 31705
// t = 0 ;
31697: LD_ADDR_VAR 0 5
31701: PUSH
31702: LD_INT 0
31704: ST_TO_ADDR
// case t of unit_vehicle :
31705: LD_VAR 0 5
31709: PUSH
31710: LD_INT 2
31712: DOUBLE
31713: EQUAL
31714: IFTRUE 31718
31716: GO 31730
31718: POP
// ComExitVehicle ( moving_un ) ; unit_building :
31719: LD_VAR 0 6
31723: PPUSH
31724: CALL_OW 121
31728: GO 31776
31730: LD_INT 3
31732: DOUBLE
31733: EQUAL
31734: IFTRUE 31738
31736: GO 31750
31738: POP
// ComExitBuilding ( moving_un ) ; 0 :
31739: LD_VAR 0 6
31743: PPUSH
31744: CALL_OW 122
31748: GO 31776
31750: LD_INT 0
31752: DOUBLE
31753: EQUAL
31754: IFTRUE 31758
31756: GO 31775
31758: POP
// ComEnterUnit ( moving_un , into_un ) ; end ;
31759: LD_VAR 0 6
31763: PPUSH
31764: LD_VAR 0 2
31768: PPUSH
31769: CALL_OW 120
31773: GO 31776
31775: POP
// end ; end ;
31776: GO 31640
31778: POP
31779: POP
// end ;
31780: LD_VAR 0 3
31784: RET
// function start_building_vehicle ( nation , factory , vehicle ) ; begin
31785: LD_INT 0
31787: PPUSH
// if ( not UnitsInside ( factory ) ) and ( nation <> ar ) then
31788: LD_VAR 0 2
31792: PPUSH
31793: CALL_OW 313
31797: NOT
31798: PUSH
31799: LD_VAR 0 1
31803: PUSH
31804: LD_EXP 4
31808: NONEQUAL
31809: AND
31810: IFFALSE 31822
// begin result = false ;
31812: LD_ADDR_VAR 0 4
31816: PUSH
31817: LD_INT 0
31819: ST_TO_ADDR
// exit ;
31820: GO 31928
// end ; if vehicle [ 3 ] = control_apeman and not ApemanInFactory ( factory ) then
31822: LD_VAR 0 3
31826: PUSH
31827: LD_INT 3
31829: ARRAY
31830: PUSH
31831: LD_INT 5
31833: EQUAL
31834: PUSH
31835: LD_VAR 0 2
31839: PPUSH
31840: CALL 31933 0 1
31844: NOT
31845: AND
31846: IFFALSE 31858
// begin result = false ;
31848: LD_ADDR_VAR 0 4
31852: PUSH
31853: LD_INT 0
31855: ST_TO_ADDR
// exit ;
31856: GO 31928
// end ; ComChangeProfession ( UnitsInside ( factory ) , class_mechanic ) ;
31858: LD_VAR 0 2
31862: PPUSH
31863: CALL_OW 313
31867: PPUSH
31868: LD_INT 3
31870: PPUSH
31871: CALL_OW 123
// ComConstruct ( factory , vehicle [ 1 ] , vehicle [ 2 ] , vehicle [ 3 ] , vehicle [ 4 ] ) ;
31875: LD_VAR 0 2
31879: PPUSH
31880: LD_VAR 0 3
31884: PUSH
31885: LD_INT 1
31887: ARRAY
31888: PPUSH
31889: LD_VAR 0 3
31893: PUSH
31894: LD_INT 2
31896: ARRAY
31897: PPUSH
31898: LD_VAR 0 3
31902: PUSH
31903: LD_INT 3
31905: ARRAY
31906: PPUSH
31907: LD_VAR 0 3
31911: PUSH
31912: LD_INT 4
31914: ARRAY
31915: PPUSH
31916: CALL_OW 125
// result = true ;
31920: LD_ADDR_VAR 0 4
31924: PUSH
31925: LD_INT 1
31927: ST_TO_ADDR
// end ;
31928: LD_VAR 0 4
31932: RET
// function ApemanInFactory ( factory ) ; var un , list , vysledek ; begin
31933: LD_INT 0
31935: PPUSH
31936: PPUSH
31937: PPUSH
31938: PPUSH
// vysledek := false ;
31939: LD_ADDR_VAR 0 5
31943: PUSH
31944: LD_INT 0
31946: ST_TO_ADDR
// list := UnitsInside ( factory ) ;
31947: LD_ADDR_VAR 0 4
31951: PUSH
31952: LD_VAR 0 1
31956: PPUSH
31957: CALL_OW 313
31961: ST_TO_ADDR
// for un in list do
31962: LD_ADDR_VAR 0 3
31966: PUSH
31967: LD_VAR 0 4
31971: PUSH
31972: FOR_IN
31973: IFFALSE 32002
// if GetClass ( un ) = class_apeman then
31975: LD_VAR 0 3
31979: PPUSH
31980: CALL_OW 257
31984: PUSH
31985: LD_INT 12
31987: EQUAL
31988: IFFALSE 32000
// begin vysledek := true ;
31990: LD_ADDR_VAR 0 5
31994: PUSH
31995: LD_INT 1
31997: ST_TO_ADDR
// break ;
31998: GO 32002
// end ;
32000: GO 31972
32002: POP
32003: POP
// result := vysledek ;
32004: LD_ADDR_VAR 0 2
32008: PUSH
32009: LD_VAR 0 5
32013: ST_TO_ADDR
// end ;
32014: LD_VAR 0 2
32018: RET
// function cleanup_extensions ( side , nation , factory ) ; var un , list , crane , cargo_bay , nation_crane , nation_cargo ; begin
32019: LD_INT 0
32021: PPUSH
32022: PPUSH
32023: PPUSH
32024: PPUSH
32025: PPUSH
32026: PPUSH
32027: PPUSH
// case nation of 1 :
32028: LD_VAR 0 2
32032: PUSH
32033: LD_INT 1
32035: DOUBLE
32036: EQUAL
32037: IFTRUE 32041
32039: GO 32060
32041: POP
// begin nation_cargo := us_cargo_bay ;
32042: LD_ADDR_VAR 0 10
32046: PUSH
32047: LD_INT 12
32049: ST_TO_ADDR
// nation_crane := us_crane ;
32050: LD_ADDR_VAR 0 9
32054: PUSH
32055: LD_INT 13
32057: ST_TO_ADDR
// end ; 2 :
32058: GO 32115
32060: LD_INT 2
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32087
32068: POP
// begin nation_cargo := ar_cargo_bay ;
32069: LD_ADDR_VAR 0 10
32073: PUSH
32074: LD_INT 32
32076: ST_TO_ADDR
// nation_crane := 0 ;
32077: LD_ADDR_VAR 0 9
32081: PUSH
32082: LD_INT 0
32084: ST_TO_ADDR
// end ; 3 :
32085: GO 32115
32087: LD_INT 3
32089: DOUBLE
32090: EQUAL
32091: IFTRUE 32095
32093: GO 32114
32095: POP
// begin nation_cargo := ru_cargo_bay ;
32096: LD_ADDR_VAR 0 10
32100: PUSH
32101: LD_INT 51
32103: ST_TO_ADDR
// nation_crane := ru_crane ;
32104: LD_ADDR_VAR 0 9
32108: PUSH
32109: LD_INT 52
32111: ST_TO_ADDR
// end ; end ;
32112: GO 32115
32114: POP
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
32115: LD_ADDR_VAR 0 8
32119: PUSH
32120: LD_INT 22
32122: PUSH
32123: LD_VAR 0 1
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 21
32134: PUSH
32135: LD_INT 2
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 34
32144: PUSH
32145: LD_VAR 0 10
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: LIST
32158: PPUSH
32159: CALL_OW 69
32163: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
32164: LD_ADDR_VAR 0 7
32168: PUSH
32169: LD_INT 22
32171: PUSH
32172: LD_VAR 0 1
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 21
32183: PUSH
32184: LD_INT 2
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 34
32193: PUSH
32194: LD_VAR 0 9
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: LIST
32207: PPUSH
32208: CALL_OW 69
32212: ST_TO_ADDR
// if ( nation_crane in extension_wanted ) and crane then
32213: LD_VAR 0 9
32217: PUSH
32218: LD_EXP 73
32222: IN
32223: PUSH
32224: LD_VAR 0 7
32228: AND
32229: IFFALSE 32247
// extension_wanted := extension_wanted diff nation_crane ;
32231: LD_ADDR_EXP 73
32235: PUSH
32236: LD_EXP 73
32240: PUSH
32241: LD_VAR 0 9
32245: DIFF
32246: ST_TO_ADDR
// if ( nation_cargo in extension_wanted ) and cargo_bay then
32247: LD_VAR 0 10
32251: PUSH
32252: LD_EXP 73
32256: IN
32257: PUSH
32258: LD_VAR 0 8
32262: AND
32263: IFFALSE 32281
// extension_wanted := extension_wanted diff nation_cargo ;
32265: LD_ADDR_EXP 73
32269: PUSH
32270: LD_EXP 73
32274: PUSH
32275: LD_VAR 0 10
32279: DIFF
32280: ST_TO_ADDR
// list := extension_wanted ;
32281: LD_ADDR_VAR 0 6
32285: PUSH
32286: LD_EXP 73
32290: ST_TO_ADDR
// for un in list do
32291: LD_ADDR_VAR 0 5
32295: PUSH
32296: LD_VAR 0 6
32300: PUSH
32301: FOR_IN
32302: IFFALSE 32335
// begin if not un in main_extensions then
32304: LD_VAR 0 5
32308: PUSH
32309: LD_LOC 58
32313: IN
32314: NOT
32315: IFFALSE 32333
// extension_wanted := extension_wanted diff un ;
32317: LD_ADDR_EXP 73
32321: PUSH
32322: LD_EXP 73
32326: PUSH
32327: LD_VAR 0 5
32331: DIFF
32332: ST_TO_ADDR
// end ;
32333: GO 32301
32335: POP
32336: POP
// end ; end_of_file
32337: LD_VAR 0 4
32341: RET
// var mc_list ; var b_list ; export function init_keep_base ; var un , build , side ; begin
32342: LD_INT 0
32344: PPUSH
32345: PPUSH
32346: PPUSH
32347: PPUSH
// b_list := [ ] ;
32348: LD_ADDR_LOC 62
32352: PUSH
32353: EMPTY
32354: ST_TO_ADDR
// mc_list := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
32355: LD_ADDR_LOC 61
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 0
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: LD_INT 0
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: ST_TO_ADDR
// for side = 1 to 8 do
32394: LD_ADDR_VAR 0 4
32398: PUSH
32399: DOUBLE
32400: LD_INT 1
32402: DEC
32403: ST_TO_ADDR
32404: LD_INT 8
32406: PUSH
32407: FOR_TO
32408: IFFALSE 32523
// if side in cpu_list then
32410: LD_VAR 0 4
32414: PUSH
32415: LD_EXP 8
32419: IN
32420: IFFALSE 32505
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
32422: LD_ADDR_VAR 0 2
32426: PUSH
32427: LD_INT 22
32429: PUSH
32430: LD_VAR 0 4
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 21
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PPUSH
32453: CALL_OW 69
32457: ST_TO_ADDR
// if un then
32458: LD_VAR 0 2
32462: IFFALSE 32503
// b_list := Insert ( b_list , side , GetBuildList ( GetBase ( un [ 1 ] ) ) ) ;
32464: LD_ADDR_LOC 62
32468: PUSH
32469: LD_LOC 62
32473: PPUSH
32474: LD_VAR 0 4
32478: PPUSH
32479: LD_VAR 0 2
32483: PUSH
32484: LD_INT 1
32486: ARRAY
32487: PPUSH
32488: CALL_OW 274
32492: PPUSH
32493: CALL_OW 417
32497: PPUSH
32498: CALL_OW 2
32502: ST_TO_ADDR
// end else
32503: GO 32521
// b_list := b_list ^ [ [ ] ] ;
32505: LD_ADDR_LOC 62
32509: PUSH
32510: LD_LOC 62
32514: PUSH
32515: EMPTY
32516: PUSH
32517: EMPTY
32518: LIST
32519: ADD
32520: ST_TO_ADDR
32521: GO 32407
32523: POP
32524: POP
// end ;
32525: LD_VAR 0 1
32529: RET
// every 0 0$5.2 trigger us in cpu_list do var side , list , engineers ;
32530: LD_EXP 3
32534: PUSH
32535: LD_EXP 8
32539: IN
32540: IFFALSE 32745
32542: GO 32544
32544: DISABLE
32545: LD_INT 0
32547: PPUSH
32548: PPUSH
32549: PPUSH
// begin list := [ ] ;
32550: LD_ADDR_VAR 0 2
32554: PUSH
32555: EMPTY
32556: ST_TO_ADDR
// for side = 1 to 8 do
32557: LD_ADDR_VAR 0 1
32561: PUSH
32562: DOUBLE
32563: LD_INT 1
32565: DEC
32566: ST_TO_ADDR
32567: LD_INT 8
32569: PUSH
32570: FOR_TO
32571: IFFALSE 32732
// if ( side in cpu_list ) then
32573: LD_VAR 0 1
32577: PUSH
32578: LD_EXP 8
32582: IN
32583: IFFALSE 32716
// begin if not ExistMc ( mc_list [ side ] ) then
32585: LD_LOC 61
32589: PUSH
32590: LD_VAR 0 1
32594: ARRAY
32595: PPUSH
32596: CALL_OW 386
32600: NOT
32601: IFFALSE 32692
// begin engineers := request_people ( side , class_engineer , 5 ) ;
32603: LD_ADDR_VAR 0 3
32607: PUSH
32608: LD_VAR 0 1
32612: PPUSH
32613: LD_INT 2
32615: PPUSH
32616: LD_INT 5
32618: PPUSH
32619: CALL 26521 0 3
32623: ST_TO_ADDR
// if engineers then
32624: LD_VAR 0 3
32628: IFFALSE 32676
// list := list ^ McBase ( 3 , engineers , b_list [ side ] , 0 , 0 , 0 ) else
32630: LD_ADDR_VAR 0 2
32634: PUSH
32635: LD_VAR 0 2
32639: PUSH
32640: LD_INT 3
32642: PPUSH
32643: LD_VAR 0 3
32647: PPUSH
32648: LD_LOC 62
32652: PUSH
32653: LD_VAR 0 1
32657: ARRAY
32658: PPUSH
32659: LD_INT 0
32661: PPUSH
32662: LD_INT 0
32664: PPUSH
32665: LD_INT 0
32667: PPUSH
32668: CALL_OW 397
32672: ADD
32673: ST_TO_ADDR
32674: GO 32690
// list := list ^ 0 end else
32676: LD_ADDR_VAR 0 2
32680: PUSH
32681: LD_VAR 0 2
32685: PUSH
32686: LD_INT 0
32688: ADD
32689: ST_TO_ADDR
32690: GO 32714
// list := list ^ mc_list [ side ] ;
32692: LD_ADDR_VAR 0 2
32696: PUSH
32697: LD_VAR 0 2
32701: PUSH
32702: LD_LOC 61
32706: PUSH
32707: LD_VAR 0 1
32711: ARRAY
32712: ADD
32713: ST_TO_ADDR
// end else
32714: GO 32730
// list := list ^ 0 ;
32716: LD_ADDR_VAR 0 2
32720: PUSH
32721: LD_VAR 0 2
32725: PUSH
32726: LD_INT 0
32728: ADD
32729: ST_TO_ADDR
32730: GO 32570
32732: POP
32733: POP
// mc_list := list ;
32734: LD_ADDR_LOC 61
32738: PUSH
32739: LD_VAR 0 2
32743: ST_TO_ADDR
// enable ;
32744: ENABLE
// end ; end_of_file
32745: PPOPN 3
32747: END
// var load_global , load_local_cpu , load_local_you ; var global_delay , cpu_delay , you_delay ; var crates_loading_area ; export function init_crates_loading ; begin
32748: LD_INT 0
32750: PPUSH
// global_delay := 10 10$0 ;
32751: LD_ADDR_LOC 66
32755: PUSH
32756: LD_INT 21000
32758: ST_TO_ADDR
// cpu_delay := 0 0$90 ;
32759: LD_ADDR_LOC 67
32763: PUSH
32764: LD_INT 3150
32766: ST_TO_ADDR
// you_delay := 3 3$30 ;
32767: LD_ADDR_LOC 68
32771: PUSH
32772: LD_INT 7350
32774: ST_TO_ADDR
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32775: LD_ADDR_LOC 63
32779: PUSH
32780: LD_OWVAR 1
32784: PUSH
32785: LD_LOC 66
32789: PUSH
32790: LD_INT 1400
32792: MINUS
32793: PPUSH
32794: LD_LOC 66
32798: PUSH
32799: LD_INT 2100
32801: PLUS
32802: PPUSH
32803: CALL_OW 12
32807: PLUS
32808: ST_TO_ADDR
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
32809: LD_ADDR_LOC 64
32813: PUSH
32814: LD_OWVAR 1
32818: PUSH
32819: LD_LOC 67
32823: PUSH
32824: LD_INT 700
32826: MINUS
32827: PPUSH
32828: LD_LOC 67
32832: PUSH
32833: LD_INT 700
32835: PLUS
32836: PPUSH
32837: CALL_OW 12
32841: PLUS
32842: ST_TO_ADDR
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
32843: LD_ADDR_LOC 65
32847: PUSH
32848: LD_OWVAR 1
32852: PUSH
32853: LD_LOC 68
32857: PUSH
32858: LD_INT 700
32860: MINUS
32861: PPUSH
32862: LD_LOC 68
32866: PUSH
32867: LD_INT 700
32869: PLUS
32870: PPUSH
32871: CALL_OW 12
32875: PLUS
32876: ST_TO_ADDR
// crates_loading_area := [ us_crates , ar_crates , ru_crates ] ;
32877: LD_ADDR_LOC 69
32881: PUSH
32882: LD_INT 1
32884: PUSH
32885: LD_INT 3
32887: PUSH
32888: LD_INT 2
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: LIST
32895: ST_TO_ADDR
// end ;
32896: LD_VAR 0 1
32900: RET
// every 0 0$5.1 trigger TICK > load_global do var c , sur , i ;
32901: LD_OWVAR 1
32905: PUSH
32906: LD_LOC 63
32910: GREATER
32911: IFFALSE 33084
32913: GO 32915
32915: DISABLE
32916: LD_INT 0
32918: PPUSH
32919: PPUSH
32920: PPUSH
// begin c := RandHex ( false ) ;
32921: LD_ADDR_VAR 0 1
32925: PUSH
32926: LD_INT 0
32928: PPUSH
32929: CALL_OW 15
32933: ST_TO_ADDR
// sur := [ ] ;
32934: LD_ADDR_VAR 0 2
32938: PUSH
32939: EMPTY
32940: ST_TO_ADDR
// for i = 1 to 4 do
32941: LD_ADDR_VAR 0 3
32945: PUSH
32946: DOUBLE
32947: LD_INT 1
32949: DEC
32950: ST_TO_ADDR
32951: LD_INT 4
32953: PUSH
32954: FOR_TO
32955: IFFALSE 33002
// sur := sur ^ [ RandHexXYR ( c [ 1 ] , c [ 2 ] , 1 , false ) ] ;
32957: LD_ADDR_VAR 0 2
32961: PUSH
32962: LD_VAR 0 2
32966: PUSH
32967: LD_VAR 0 1
32971: PUSH
32972: LD_INT 1
32974: ARRAY
32975: PPUSH
32976: LD_VAR 0 1
32980: PUSH
32981: LD_INT 2
32983: ARRAY
32984: PPUSH
32985: LD_INT 1
32987: PPUSH
32988: LD_INT 0
32990: PPUSH
32991: CALL_OW 17
32995: PUSH
32996: EMPTY
32997: LIST
32998: ADD
32999: ST_TO_ADDR
33000: GO 32954
33002: POP
33003: POP
// for i in sur do
33004: LD_ADDR_VAR 0 3
33008: PUSH
33009: LD_VAR 0 2
33013: PUSH
33014: FOR_IN
33015: IFFALSE 33047
// CreateCratesXY ( 5 , i [ 1 ] , i [ 2 ] , true ) ;
33017: LD_INT 5
33019: PPUSH
33020: LD_VAR 0 3
33024: PUSH
33025: LD_INT 1
33027: ARRAY
33028: PPUSH
33029: LD_VAR 0 3
33033: PUSH
33034: LD_INT 2
33036: ARRAY
33037: PPUSH
33038: LD_INT 1
33040: PPUSH
33041: CALL_OW 54
33045: GO 33014
33047: POP
33048: POP
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
33049: LD_ADDR_LOC 63
33053: PUSH
33054: LD_OWVAR 1
33058: PUSH
33059: LD_LOC 66
33063: PUSH
33064: LD_INT 1400
33066: MINUS
33067: PPUSH
33068: LD_LOC 66
33072: PUSH
33073: LD_INT 2100
33075: PLUS
33076: PPUSH
33077: CALL_OW 12
33081: PLUS
33082: ST_TO_ADDR
// enable ;
33083: ENABLE
// end ;
33084: PPOPN 3
33086: END
// every 0 0$5.4 trigger TICK > load_local_cpu do var un ;
33087: LD_OWVAR 1
33091: PUSH
33092: LD_LOC 64
33096: GREATER
33097: IFFALSE 33214
33099: GO 33101
33101: DISABLE
33102: LD_INT 0
33104: PPUSH
// begin if GetResourceArea ( us_crates , mat_cans ) < 250 then
33105: LD_INT 1
33107: PPUSH
33108: LD_INT 1
33110: PPUSH
33111: CALL_OW 287
33115: PUSH
33116: LD_INT 250
33118: LESS
33119: IFFALSE 33142
// CreateCratesArea ( Rand ( 3 , 5 ) , us_crates , true ) ;
33121: LD_INT 3
33123: PPUSH
33124: LD_INT 5
33126: PPUSH
33127: CALL_OW 12
33131: PPUSH
33132: LD_INT 1
33134: PPUSH
33135: LD_INT 1
33137: PPUSH
33138: CALL_OW 55
// if GetResourceArea ( ru_crates , mat_cans ) < 250 then
33142: LD_INT 2
33144: PPUSH
33145: LD_INT 1
33147: PPUSH
33148: CALL_OW 287
33152: PUSH
33153: LD_INT 250
33155: LESS
33156: IFFALSE 33179
// CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
33158: LD_INT 3
33160: PPUSH
33161: LD_INT 5
33163: PPUSH
33164: CALL_OW 12
33168: PPUSH
33169: LD_INT 2
33171: PPUSH
33172: LD_INT 1
33174: PPUSH
33175: CALL_OW 55
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33179: LD_ADDR_LOC 64
33183: PUSH
33184: LD_OWVAR 1
33188: PUSH
33189: LD_LOC 67
33193: PUSH
33194: LD_INT 700
33196: MINUS
33197: PPUSH
33198: LD_LOC 67
33202: PUSH
33203: LD_INT 700
33205: PLUS
33206: PPUSH
33207: CALL_OW 12
33211: PLUS
33212: ST_TO_ADDR
// enable ;
33213: ENABLE
// end ;
33214: PPOPN 1
33216: END
// every 0 0$5.3 trigger TICK > load_local_you do
33217: LD_OWVAR 1
33221: PUSH
33222: LD_LOC 65
33226: GREATER
33227: IFFALSE 33304
33229: GO 33231
33231: DISABLE
// begin if GetResourceArea ( ar_crates , mat_cans ) < 250 then
33232: LD_INT 3
33234: PPUSH
33235: LD_INT 1
33237: PPUSH
33238: CALL_OW 287
33242: PUSH
33243: LD_INT 250
33245: LESS
33246: IFFALSE 33269
// CreateCratesArea ( Rand ( 1 , 5 ) , ar_crates , true ) ;
33248: LD_INT 1
33250: PPUSH
33251: LD_INT 5
33253: PPUSH
33254: CALL_OW 12
33258: PPUSH
33259: LD_INT 3
33261: PPUSH
33262: LD_INT 1
33264: PPUSH
33265: CALL_OW 55
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33269: LD_ADDR_LOC 65
33273: PUSH
33274: LD_OWVAR 1
33278: PUSH
33279: LD_LOC 68
33283: PUSH
33284: LD_INT 700
33286: MINUS
33287: PPUSH
33288: LD_LOC 68
33292: PUSH
33293: LD_INT 700
33295: PLUS
33296: PPUSH
33297: CALL_OW 12
33301: PLUS
33302: ST_TO_ADDR
// enable ;
33303: ENABLE
// end ;
33304: END
// every 0 0$30.1 do var list , side , un , base ;
33305: GO 33307
33307: DISABLE
33308: LD_INT 0
33310: PPUSH
33311: PPUSH
33312: PPUSH
33313: PPUSH
// begin for side in cpu_list do
33314: LD_ADDR_VAR 0 2
33318: PUSH
33319: LD_EXP 8
33323: PUSH
33324: FOR_IN
33325: IFFALSE 33479
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
33327: LD_ADDR_VAR 0 1
33331: PUSH
33332: LD_INT 22
33334: PUSH
33335: LD_VAR 0 2
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 21
33346: PUSH
33347: LD_INT 3
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: LD_INT 30
33359: PUSH
33360: LD_INT 0
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 30
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: LIST
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: LIST
33386: PPUSH
33387: CALL_OW 69
33391: ST_TO_ADDR
// for un in list do
33392: LD_ADDR_VAR 0 3
33396: PUSH
33397: LD_VAR 0 1
33401: PUSH
33402: FOR_IN
33403: IFFALSE 33475
// begin base := GetBase ( un ) ;
33405: LD_ADDR_VAR 0 4
33409: PUSH
33410: LD_VAR 0 3
33414: PPUSH
33415: CALL_OW 274
33419: ST_TO_ADDR
// if GetResourceType ( base , mat_cans ) < 300 then
33420: LD_VAR 0 4
33424: PPUSH
33425: LD_INT 1
33427: PPUSH
33428: CALL_OW 275
33432: PUSH
33433: LD_INT 300
33435: LESS
33436: IFFALSE 33473
// SetResourceType ( base , mat_cans , GetResourceType ( base , mat_cans ) + ( difficulty * 30 ) ) ;
33438: LD_VAR 0 4
33442: PPUSH
33443: LD_INT 1
33445: PPUSH
33446: LD_VAR 0 4
33450: PPUSH
33451: LD_INT 1
33453: PPUSH
33454: CALL_OW 275
33458: PUSH
33459: LD_OWVAR 67
33463: PUSH
33464: LD_INT 30
33466: MUL
33467: PLUS
33468: PPUSH
33469: CALL_OW 277
// end ;
33473: GO 33402
33475: POP
33476: POP
// end ;
33477: GO 33324
33479: POP
33480: POP
// enable ;
33481: ENABLE
// end ; end_of_file
33482: PPOPN 4
33484: END
// var outside_list , inside_list ; var base_areas , create_areas ; var us_bay , ru_bay , ar_bay ; var us_bad , ru_bad , ar_bad ; export function init_crates_collecting ; begin
33485: LD_INT 0
33487: PPUSH
// outside_list := [ us_crates , ar_crates , ru_crates ] ;
33488: LD_ADDR_LOC 70
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: LD_INT 3
33498: PUSH
33499: LD_INT 2
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: LIST
33506: ST_TO_ADDR
// inside_list := [ us_inner_base , ar_base , ru_inner_base ] ;
33507: LD_ADDR_LOC 71
33511: PUSH
33512: LD_INT 38
33514: PUSH
33515: LD_INT 13
33517: PUSH
33518: LD_INT 39
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: LIST
33525: ST_TO_ADDR
// base_areas := [ us_base , ar_base , ru_base ] ;
33526: LD_ADDR_LOC 72
33530: PUSH
33531: LD_INT 11
33533: PUSH
33534: LD_INT 13
33536: PUSH
33537: LD_INT 12
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: LIST
33544: ST_TO_ADDR
// create_areas := [ us_create , ar_create , ru_create ] ;
33545: LD_ADDR_LOC 73
33549: PUSH
33550: LD_INT 18
33552: PUSH
33553: LD_INT 19
33555: PUSH
33556: LD_INT 17
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: LIST
33563: ST_TO_ADDR
// us_bad := [ ] ;
33564: LD_ADDR_LOC 77
33568: PUSH
33569: EMPTY
33570: ST_TO_ADDR
// ru_bad := [ ] ;
33571: LD_ADDR_LOC 78
33575: PUSH
33576: EMPTY
33577: ST_TO_ADDR
// ar_bad := [ ] ;
33578: LD_ADDR_LOC 79
33582: PUSH
33583: EMPTY
33584: ST_TO_ADDR
// end ;
33585: LD_VAR 0 1
33589: RET
// every 0 0$5.4 do var un , side , list , cargo , n_cargo , engineers ;
33590: GO 33592
33592: DISABLE
33593: LD_INT 0
33595: PPUSH
33596: PPUSH
33597: PPUSH
33598: PPUSH
33599: PPUSH
33600: PPUSH
// begin for side in cpu_list do
33601: LD_ADDR_VAR 0 2
33605: PUSH
33606: LD_EXP 8
33610: PUSH
33611: FOR_IN
33612: IFFALSE 34139
// begin list := GetListOfCratesInArea ( outside_list [ side ] ) ;
33614: LD_ADDR_VAR 0 3
33618: PUSH
33619: LD_LOC 70
33623: PUSH
33624: LD_VAR 0 2
33628: ARRAY
33629: PPUSH
33630: CALL_OW 435
33634: ST_TO_ADDR
// if list then
33635: LD_VAR 0 3
33639: IFFALSE 34007
// begin case side of 1 :
33641: LD_VAR 0 2
33645: PUSH
33646: LD_INT 1
33648: DOUBLE
33649: EQUAL
33650: IFTRUE 33654
33652: GO 33665
33654: POP
// n_cargo := us_cargo_bay ; 2 :
33655: LD_ADDR_VAR 0 5
33659: PUSH
33660: LD_INT 12
33662: ST_TO_ADDR
33663: GO 33704
33665: LD_INT 2
33667: DOUBLE
33668: EQUAL
33669: IFTRUE 33673
33671: GO 33684
33673: POP
// n_cargo := ar_cargo_bay ; 3 :
33674: LD_ADDR_VAR 0 5
33678: PUSH
33679: LD_INT 32
33681: ST_TO_ADDR
33682: GO 33704
33684: LD_INT 3
33686: DOUBLE
33687: EQUAL
33688: IFTRUE 33692
33690: GO 33703
33692: POP
// n_cargo := ru_cargo_bay ; end ;
33693: LD_ADDR_VAR 0 5
33697: PUSH
33698: LD_INT 51
33700: ST_TO_ADDR
33701: GO 33704
33703: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
33704: LD_ADDR_VAR 0 4
33708: PUSH
33709: LD_INT 22
33711: PUSH
33712: LD_VAR 0 2
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 21
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 34
33733: PUSH
33734: LD_VAR 0 5
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: LIST
33747: PPUSH
33748: CALL_OW 69
33752: ST_TO_ADDR
// if cargo then
33753: LD_VAR 0 4
33757: IFFALSE 34007
// begin cargo := cargo [ 1 ] ;
33759: LD_ADDR_VAR 0 4
33763: PUSH
33764: LD_VAR 0 4
33768: PUSH
33769: LD_INT 1
33771: ARRAY
33772: ST_TO_ADDR
// if ( not HasTask ( cargo ) ) and ( not ( [ list [ 1 ] , list [ 2 ] ] in ( us_bad ^ ru_bad ^ ar_bad ) ) ) then
33773: LD_VAR 0 4
33777: PPUSH
33778: CALL_OW 314
33782: NOT
33783: PUSH
33784: LD_VAR 0 3
33788: PUSH
33789: LD_INT 1
33791: ARRAY
33792: PUSH
33793: LD_VAR 0 3
33797: PUSH
33798: LD_INT 2
33800: ARRAY
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_LOC 77
33810: PUSH
33811: LD_LOC 78
33815: ADD
33816: PUSH
33817: LD_LOC 79
33821: ADD
33822: IN
33823: NOT
33824: AND
33825: IFFALSE 34007
// begin ComCollect ( cargo , list [ 1 ] , list [ 2 ] ) ;
33827: LD_VAR 0 4
33831: PPUSH
33832: LD_VAR 0 3
33836: PUSH
33837: LD_INT 1
33839: ARRAY
33840: PPUSH
33841: LD_VAR 0 3
33845: PUSH
33846: LD_INT 2
33848: ARRAY
33849: PPUSH
33850: CALL_OW 117
// case side of us :
33854: LD_VAR 0 2
33858: PUSH
33859: LD_EXP 3
33863: DOUBLE
33864: EQUAL
33865: IFTRUE 33869
33867: GO 33908
33869: POP
// us_bay := us_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ru :
33870: LD_ADDR_LOC 74
33874: PUSH
33875: LD_LOC 74
33879: PUSH
33880: LD_VAR 0 3
33884: PUSH
33885: LD_INT 1
33887: ARRAY
33888: PUSH
33889: LD_VAR 0 3
33893: PUSH
33894: LD_INT 2
33896: ARRAY
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: EMPTY
33903: LIST
33904: ADD
33905: ST_TO_ADDR
33906: GO 34007
33908: LD_EXP 2
33912: DOUBLE
33913: EQUAL
33914: IFTRUE 33918
33916: GO 33957
33918: POP
// ru_bay := ru_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ar :
33919: LD_ADDR_LOC 75
33923: PUSH
33924: LD_LOC 75
33928: PUSH
33929: LD_VAR 0 3
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PUSH
33938: LD_VAR 0 3
33942: PUSH
33943: LD_INT 2
33945: ARRAY
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: EMPTY
33952: LIST
33953: ADD
33954: ST_TO_ADDR
33955: GO 34007
33957: LD_EXP 4
33961: DOUBLE
33962: EQUAL
33963: IFTRUE 33967
33965: GO 34006
33967: POP
// ar_bay := ar_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; end ;
33968: LD_ADDR_LOC 76
33972: PUSH
33973: LD_LOC 76
33977: PUSH
33978: LD_VAR 0 3
33982: PUSH
33983: LD_INT 1
33985: ARRAY
33986: PUSH
33987: LD_VAR 0 3
33991: PUSH
33992: LD_INT 2
33994: ARRAY
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: EMPTY
34001: LIST
34002: ADD
34003: ST_TO_ADDR
34004: GO 34007
34006: POP
// end ; end ; end ; list := GetListOfCratesInArea ( inside_list [ side ] ) ;
34007: LD_ADDR_VAR 0 3
34011: PUSH
34012: LD_LOC 71
34016: PUSH
34017: LD_VAR 0 2
34021: ARRAY
34022: PPUSH
34023: CALL_OW 435
34027: ST_TO_ADDR
// if list then
34028: LD_VAR 0 3
34032: IFFALSE 34137
// begin engineers := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
34034: LD_ADDR_VAR 0 6
34038: PUSH
34039: LD_INT 22
34041: PUSH
34042: LD_VAR 0 2
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 21
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 25
34063: PUSH
34064: LD_INT 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: LIST
34075: PPUSH
34076: CALL_OW 69
34080: ST_TO_ADDR
// for un in engineers do
34081: LD_ADDR_VAR 0 1
34085: PUSH
34086: LD_VAR 0 6
34090: PUSH
34091: FOR_IN
34092: IFFALSE 34135
// if not GetUnitMc ( un ) then
34094: LD_VAR 0 1
34098: PPUSH
34099: CALL_OW 388
34103: NOT
34104: IFFALSE 34133
// ComCollect ( un , list [ 1 ] , list [ 2 ] ) ;
34106: LD_VAR 0 1
34110: PPUSH
34111: LD_VAR 0 3
34115: PUSH
34116: LD_INT 1
34118: ARRAY
34119: PPUSH
34120: LD_VAR 0 3
34124: PUSH
34125: LD_INT 2
34127: ARRAY
34128: PPUSH
34129: CALL_OW 117
34133: GO 34091
34135: POP
34136: POP
// end ; end ;
34137: GO 33611
34139: POP
34140: POP
// enable ;
34141: ENABLE
// end ;
34142: PPOPN 6
34144: END
// every 1 1$0.6 do var un , n_cargo , cargo , side ;
34145: GO 34147
34147: DISABLE
34148: LD_INT 0
34150: PPUSH
34151: PPUSH
34152: PPUSH
34153: PPUSH
// begin for side in cpu_list do
34154: LD_ADDR_VAR 0 4
34158: PUSH
34159: LD_EXP 8
34163: PUSH
34164: FOR_IN
34165: IFFALSE 34604
// begin case side of 1 :
34167: LD_VAR 0 4
34171: PUSH
34172: LD_INT 1
34174: DOUBLE
34175: EQUAL
34176: IFTRUE 34180
34178: GO 34191
34180: POP
// n_cargo := us_cargo_bay ; 2 :
34181: LD_ADDR_VAR 0 2
34185: PUSH
34186: LD_INT 12
34188: ST_TO_ADDR
34189: GO 34230
34191: LD_INT 2
34193: DOUBLE
34194: EQUAL
34195: IFTRUE 34199
34197: GO 34210
34199: POP
// n_cargo := ar_cargo_bay ; 3 :
34200: LD_ADDR_VAR 0 2
34204: PUSH
34205: LD_INT 32
34207: ST_TO_ADDR
34208: GO 34230
34210: LD_INT 3
34212: DOUBLE
34213: EQUAL
34214: IFTRUE 34218
34216: GO 34229
34218: POP
// n_cargo := ru_cargo_bay ; end ;
34219: LD_ADDR_VAR 0 2
34223: PUSH
34224: LD_INT 51
34226: ST_TO_ADDR
34227: GO 34230
34229: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34230: LD_ADDR_VAR 0 3
34234: PUSH
34235: LD_INT 22
34237: PUSH
34238: LD_VAR 0 4
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 21
34249: PUSH
34250: LD_INT 2
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 34
34259: PUSH
34260: LD_VAR 0 2
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: LIST
34273: PPUSH
34274: CALL_OW 69
34278: ST_TO_ADDR
// if not ( cargo or FilterUnitsInArea ( base_areas [ side ] , [ [ f_side , you ] ] ) ) then
34279: LD_VAR 0 3
34283: PUSH
34284: LD_LOC 72
34288: PUSH
34289: LD_VAR 0 4
34293: ARRAY
34294: PPUSH
34295: LD_INT 22
34297: PUSH
34298: LD_EXP 1
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: PPUSH
34310: CALL_OW 70
34314: OR
34315: NOT
34316: IFFALSE 34602
// begin uc_side := side ;
34318: LD_ADDR_OWVAR 20
34322: PUSH
34323: LD_VAR 0 4
34327: ST_TO_ADDR
// case side of 1 :
34328: LD_VAR 0 4
34332: PUSH
34333: LD_INT 1
34335: DOUBLE
34336: EQUAL
34337: IFTRUE 34341
34339: GO 34352
34341: POP
// uc_nation := nation_american ; 2 :
34342: LD_ADDR_OWVAR 21
34346: PUSH
34347: LD_INT 1
34349: ST_TO_ADDR
34350: GO 34391
34352: LD_INT 2
34354: DOUBLE
34355: EQUAL
34356: IFTRUE 34360
34358: GO 34371
34360: POP
// uc_nation := nation_arabian ; 3 :
34361: LD_ADDR_OWVAR 21
34365: PUSH
34366: LD_INT 2
34368: ST_TO_ADDR
34369: GO 34391
34371: LD_INT 3
34373: DOUBLE
34374: EQUAL
34375: IFTRUE 34379
34377: GO 34390
34379: POP
// uc_nation := nation_russian ; end ;
34380: LD_ADDR_OWVAR 21
34384: PUSH
34385: LD_INT 3
34387: ST_TO_ADDR
34388: GO 34391
34390: POP
// uc_direction := Rand ( 0 , 5 ) ;
34391: LD_ADDR_OWVAR 24
34395: PUSH
34396: LD_INT 0
34398: PPUSH
34399: LD_INT 5
34401: PPUSH
34402: CALL_OW 12
34406: ST_TO_ADDR
// case side of 1 :
34407: LD_VAR 0 4
34411: PUSH
34412: LD_INT 1
34414: DOUBLE
34415: EQUAL
34416: IFTRUE 34420
34418: GO 34431
34420: POP
// vc_chassis := us_medium_tracked ; 2 :
34421: LD_ADDR_OWVAR 37
34425: PUSH
34426: LD_INT 3
34428: ST_TO_ADDR
34429: GO 34470
34431: LD_INT 2
34433: DOUBLE
34434: EQUAL
34435: IFTRUE 34439
34437: GO 34450
34439: POP
// vc_chassis := ar_half_tracked ; 3 :
34440: LD_ADDR_OWVAR 37
34444: PUSH
34445: LD_INT 14
34447: ST_TO_ADDR
34448: GO 34470
34450: LD_INT 3
34452: DOUBLE
34453: EQUAL
34454: IFTRUE 34458
34456: GO 34469
34458: POP
// vc_chassis := ru_medium_tracked ; end ;
34459: LD_ADDR_OWVAR 37
34463: PUSH
34464: LD_INT 22
34466: ST_TO_ADDR
34467: GO 34470
34469: POP
// vc_engine := engine_siberite ;
34470: LD_ADDR_OWVAR 39
34474: PUSH
34475: LD_INT 3
34477: ST_TO_ADDR
// case side of 1 :
34478: LD_VAR 0 4
34482: PUSH
34483: LD_INT 1
34485: DOUBLE
34486: EQUAL
34487: IFTRUE 34491
34489: GO 34502
34491: POP
// vc_control := control_computer ; 2 :
34492: LD_ADDR_OWVAR 38
34496: PUSH
34497: LD_INT 3
34499: ST_TO_ADDR
34500: GO 34541
34502: LD_INT 2
34504: DOUBLE
34505: EQUAL
34506: IFTRUE 34510
34508: GO 34521
34510: POP
// vc_control := control_apeman ; 3 :
34511: LD_ADDR_OWVAR 38
34515: PUSH
34516: LD_INT 5
34518: ST_TO_ADDR
34519: GO 34541
34521: LD_INT 3
34523: DOUBLE
34524: EQUAL
34525: IFTRUE 34529
34527: GO 34540
34529: POP
// vc_control := control_computer ; end ;
34530: LD_ADDR_OWVAR 38
34534: PUSH
34535: LD_INT 3
34537: ST_TO_ADDR
34538: GO 34541
34540: POP
// vc_weapon := n_cargo ;
34541: LD_ADDR_OWVAR 40
34545: PUSH
34546: LD_VAR 0 2
34550: ST_TO_ADDR
// un := CreateVehicle ;
34551: LD_ADDR_VAR 0 1
34555: PUSH
34556: CALL_OW 45
34560: ST_TO_ADDR
// while GetTag ( 83 ) do
34561: LD_INT 83
34563: PPUSH
34564: CALL_OW 110
34568: IFFALSE 34579
// wait ( 0 0$1 ) ;
34570: LD_INT 35
34572: PPUSH
34573: CALL_OW 67
34577: GO 34561
// PlaceUnitArea ( un , create_areas [ side ] , false ) ;
34579: LD_VAR 0 1
34583: PPUSH
34584: LD_LOC 73
34588: PUSH
34589: LD_VAR 0 4
34593: ARRAY
34594: PPUSH
34595: LD_INT 0
34597: PPUSH
34598: CALL_OW 49
// end ; end ;
34602: GO 34164
34604: POP
34605: POP
// enable ;
34606: ENABLE
// end ;
34607: PPOPN 4
34609: END
// export function remove_bad_crates ( side ) ; var list , un , x , y ; begin
34610: LD_INT 0
34612: PPUSH
34613: PPUSH
34614: PPUSH
34615: PPUSH
34616: PPUSH
// case side of us :
34617: LD_VAR 0 1
34621: PUSH
34622: LD_EXP 3
34626: DOUBLE
34627: EQUAL
34628: IFTRUE 34632
34630: GO 34703
34632: POP
// begin x := us_bay [ us_bad ] [ 1 ] ;
34633: LD_ADDR_VAR 0 5
34637: PUSH
34638: LD_LOC 74
34642: PUSH
34643: LD_LOC 77
34647: ARRAY
34648: PUSH
34649: LD_INT 1
34651: ARRAY
34652: ST_TO_ADDR
// y := us_bay [ us_bad ] [ 2 ] ;
34653: LD_ADDR_VAR 0 6
34657: PUSH
34658: LD_LOC 74
34662: PUSH
34663: LD_LOC 77
34667: ARRAY
34668: PUSH
34669: LD_INT 2
34671: ARRAY
34672: ST_TO_ADDR
// us_bad := us_bad ^ [ [ x , y ] ] ;
34673: LD_ADDR_LOC 77
34677: PUSH
34678: LD_LOC 77
34682: PUSH
34683: LD_VAR 0 5
34687: PUSH
34688: LD_VAR 0 6
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: EMPTY
34698: LIST
34699: ADD
34700: ST_TO_ADDR
// end ; ru :
34701: GO 34866
34703: LD_EXP 2
34707: DOUBLE
34708: EQUAL
34709: IFTRUE 34713
34711: GO 34784
34713: POP
// begin x := ru_bay [ us_bad ] [ 1 ] ;
34714: LD_ADDR_VAR 0 5
34718: PUSH
34719: LD_LOC 75
34723: PUSH
34724: LD_LOC 77
34728: ARRAY
34729: PUSH
34730: LD_INT 1
34732: ARRAY
34733: ST_TO_ADDR
// y := ru_bay [ us_bad ] [ 2 ] ;
34734: LD_ADDR_VAR 0 6
34738: PUSH
34739: LD_LOC 75
34743: PUSH
34744: LD_LOC 77
34748: ARRAY
34749: PUSH
34750: LD_INT 2
34752: ARRAY
34753: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34754: LD_ADDR_LOC 78
34758: PUSH
34759: LD_LOC 78
34763: PUSH
34764: LD_VAR 0 5
34768: PUSH
34769: LD_VAR 0 6
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: EMPTY
34779: LIST
34780: ADD
34781: ST_TO_ADDR
// end ; ar :
34782: GO 34866
34784: LD_EXP 4
34788: DOUBLE
34789: EQUAL
34790: IFTRUE 34794
34792: GO 34865
34794: POP
// begin x := ar_bay [ us_bad ] [ 1 ] ;
34795: LD_ADDR_VAR 0 5
34799: PUSH
34800: LD_LOC 76
34804: PUSH
34805: LD_LOC 77
34809: ARRAY
34810: PUSH
34811: LD_INT 1
34813: ARRAY
34814: ST_TO_ADDR
// y := ar_bay [ us_bad ] [ 2 ] ;
34815: LD_ADDR_VAR 0 6
34819: PUSH
34820: LD_LOC 76
34824: PUSH
34825: LD_LOC 77
34829: ARRAY
34830: PUSH
34831: LD_INT 2
34833: ARRAY
34834: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34835: LD_ADDR_LOC 78
34839: PUSH
34840: LD_LOC 78
34844: PUSH
34845: LD_VAR 0 5
34849: PUSH
34850: LD_VAR 0 6
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: EMPTY
34860: LIST
34861: ADD
34862: ST_TO_ADDR
// end ; end ;
34863: GO 34866
34865: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ;
34866: LD_ADDR_VAR 0 3
34870: PUSH
34871: LD_INT 22
34873: PUSH
34874: LD_VAR 0 1
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 21
34885: PUSH
34886: LD_INT 1
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 25
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 50
34905: PUSH
34906: EMPTY
34907: LIST
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: PPUSH
34915: CALL_OW 69
34919: ST_TO_ADDR
// for un in list do
34920: LD_ADDR_VAR 0 4
34924: PUSH
34925: LD_VAR 0 3
34929: PUSH
34930: FOR_IN
34931: IFFALSE 34984
// if not GetUnitMc ( un ) then
34933: LD_VAR 0 4
34937: PPUSH
34938: CALL_OW 388
34942: NOT
34943: IFFALSE 34982
// begin ComRemember ( un ) ;
34945: LD_VAR 0 4
34949: PPUSH
34950: CALL_OW 143
// AddComCollect ( un , x , y ) ;
34954: LD_VAR 0 4
34958: PPUSH
34959: LD_VAR 0 5
34963: PPUSH
34964: LD_VAR 0 6
34968: PPUSH
34969: CALL_OW 177
// AddComReturn ( un ) ;
34973: LD_VAR 0 4
34977: PPUSH
34978: CALL_OW 204
// end ;
34982: GO 34930
34984: POP
34985: POP
// end ;
34986: LD_VAR 0 2
34990: RET
// every 0 0$7.9 trigger us_bad do var un , list ;
34991: LD_LOC 77
34995: IFFALSE 35092
34997: GO 34999
34999: DISABLE
35000: LD_INT 0
35002: PPUSH
35003: PPUSH
// begin list := [ ] ;
35004: LD_ADDR_VAR 0 2
35008: PUSH
35009: EMPTY
35010: ST_TO_ADDR
// for un in us_bad do
35011: LD_ADDR_VAR 0 1
35015: PUSH
35016: LD_LOC 77
35020: PUSH
35021: FOR_IN
35022: IFFALSE 35079
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35024: LD_INT 35
35026: PPUSH
35027: LD_VAR 0 1
35031: PUSH
35032: LD_INT 1
35034: ARRAY
35035: PPUSH
35036: LD_VAR 0 1
35040: PUSH
35041: LD_INT 2
35043: ARRAY
35044: PPUSH
35045: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35049: LD_INT 35
35051: PPUSH
35052: CALL_OW 435
35056: IFFALSE 35077
// list := list ^ [ un ] ;
35058: LD_ADDR_VAR 0 2
35062: PUSH
35063: LD_VAR 0 2
35067: PUSH
35068: LD_VAR 0 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: ADD
35076: ST_TO_ADDR
// end ;
35077: GO 35021
35079: POP
35080: POP
// us_bad := list ;
35081: LD_ADDR_LOC 77
35085: PUSH
35086: LD_VAR 0 2
35090: ST_TO_ADDR
// enable ;
35091: ENABLE
// end ;
35092: PPOPN 2
35094: END
// every 0 0$7.8 trigger ru_bad do var un , list ;
35095: LD_LOC 78
35099: IFFALSE 35196
35101: GO 35103
35103: DISABLE
35104: LD_INT 0
35106: PPUSH
35107: PPUSH
// begin list := [ ] ;
35108: LD_ADDR_VAR 0 2
35112: PUSH
35113: EMPTY
35114: ST_TO_ADDR
// for un in ru_bad do
35115: LD_ADDR_VAR 0 1
35119: PUSH
35120: LD_LOC 78
35124: PUSH
35125: FOR_IN
35126: IFFALSE 35183
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35128: LD_INT 35
35130: PPUSH
35131: LD_VAR 0 1
35135: PUSH
35136: LD_INT 1
35138: ARRAY
35139: PPUSH
35140: LD_VAR 0 1
35144: PUSH
35145: LD_INT 2
35147: ARRAY
35148: PPUSH
35149: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35153: LD_INT 35
35155: PPUSH
35156: CALL_OW 435
35160: IFFALSE 35181
// list := list ^ [ un ] ;
35162: LD_ADDR_VAR 0 2
35166: PUSH
35167: LD_VAR 0 2
35171: PUSH
35172: LD_VAR 0 1
35176: PUSH
35177: EMPTY
35178: LIST
35179: ADD
35180: ST_TO_ADDR
// end ;
35181: GO 35125
35183: POP
35184: POP
// ru_bad := list ;
35185: LD_ADDR_LOC 78
35189: PUSH
35190: LD_VAR 0 2
35194: ST_TO_ADDR
// enable ;
35195: ENABLE
// end ;
35196: PPOPN 2
35198: END
// every 0 0$7.7 trigger ar_bad do var un , list ;
35199: LD_LOC 79
35203: IFFALSE 35300
35205: GO 35207
35207: DISABLE
35208: LD_INT 0
35210: PPUSH
35211: PPUSH
// begin list := [ ] ;
35212: LD_ADDR_VAR 0 2
35216: PUSH
35217: EMPTY
35218: ST_TO_ADDR
// for un in ar_bad do
35219: LD_ADDR_VAR 0 1
35223: PUSH
35224: LD_LOC 79
35228: PUSH
35229: FOR_IN
35230: IFFALSE 35287
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35232: LD_INT 35
35234: PPUSH
35235: LD_VAR 0 1
35239: PUSH
35240: LD_INT 1
35242: ARRAY
35243: PPUSH
35244: LD_VAR 0 1
35248: PUSH
35249: LD_INT 2
35251: ARRAY
35252: PPUSH
35253: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35257: LD_INT 35
35259: PPUSH
35260: CALL_OW 435
35264: IFFALSE 35285
// list := list ^ [ un ] ;
35266: LD_ADDR_VAR 0 2
35270: PUSH
35271: LD_VAR 0 2
35275: PUSH
35276: LD_VAR 0 1
35280: PUSH
35281: EMPTY
35282: LIST
35283: ADD
35284: ST_TO_ADDR
// end ;
35285: GO 35229
35287: POP
35288: POP
// ar_bad := list ;
35289: LD_ADDR_LOC 79
35293: PUSH
35294: LD_VAR 0 2
35298: ST_TO_ADDR
// enable ;
35299: ENABLE
// end ; end_of_file
35300: PPOPN 2
35302: END
// export function check_remote ( veh ) ; var un , towers , list , all_in , veh_n , veh_l , mech ; begin
35303: LD_INT 0
35305: PPUSH
35306: PPUSH
35307: PPUSH
35308: PPUSH
35309: PPUSH
35310: PPUSH
35311: PPUSH
35312: PPUSH
// list := [ ] ;
35313: LD_ADDR_VAR 0 5
35317: PUSH
35318: EMPTY
35319: ST_TO_ADDR
// veh_l := FilterAllUnits ( [ [ f_side , us ] , [ f_control , control_remote ] , [ f_ok ] ] ) union veh diff 0 ;
35320: LD_ADDR_VAR 0 8
35324: PUSH
35325: LD_INT 22
35327: PUSH
35328: LD_EXP 3
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 33
35339: PUSH
35340: LD_INT 2
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 50
35349: PUSH
35350: EMPTY
35351: LIST
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: LIST
35357: PPUSH
35358: CALL_OW 69
35362: PUSH
35363: LD_VAR 0 1
35367: UNION
35368: PUSH
35369: LD_INT 0
35371: DIFF
35372: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35373: LD_ADDR_VAR 0 4
35377: PUSH
35378: LD_INT 22
35380: PUSH
35381: LD_EXP 3
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 30
35392: PUSH
35393: LD_INT 36
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 50
35402: PUSH
35403: EMPTY
35404: LIST
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: LIST
35410: PPUSH
35411: CALL_OW 69
35415: ST_TO_ADDR
// if not towers then
35416: LD_VAR 0 4
35420: NOT
35421: IFFALSE 35425
// exit ;
35423: GO 36020
// towers := towers [ 1 ] ;
35425: LD_ADDR_VAR 0 4
35429: PUSH
35430: LD_VAR 0 4
35434: PUSH
35435: LD_INT 1
35437: ARRAY
35438: ST_TO_ADDR
// all_in := UnitsInside ( towers ) ;
35439: LD_ADDR_VAR 0 6
35443: PUSH
35444: LD_VAR 0 4
35448: PPUSH
35449: CALL_OW 313
35453: ST_TO_ADDR
// mech := all_in ^ ( FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] , [ f_ok ] ] ) diff reserved_people [ us ] ) ;
35454: LD_ADDR_VAR 0 9
35458: PUSH
35459: LD_VAR 0 6
35463: PUSH
35464: LD_INT 22
35466: PUSH
35467: LD_EXP 3
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 21
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 25
35488: PUSH
35489: LD_INT 3
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 50
35498: PUSH
35499: EMPTY
35500: LIST
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: PPUSH
35508: CALL_OW 69
35512: PUSH
35513: LD_EXP 71
35517: PUSH
35518: LD_EXP 3
35522: ARRAY
35523: DIFF
35524: ADD
35525: ST_TO_ADDR
// for un in mech do
35526: LD_ADDR_VAR 0 3
35530: PUSH
35531: LD_VAR 0 9
35535: PUSH
35536: FOR_IN
35537: IFFALSE 35571
// list := list ^ FindMaxSkill ( mech diff list , skill_mechanical ) ;
35539: LD_ADDR_VAR 0 5
35543: PUSH
35544: LD_VAR 0 5
35548: PUSH
35549: LD_VAR 0 9
35553: PUSH
35554: LD_VAR 0 5
35558: DIFF
35559: PPUSH
35560: LD_INT 3
35562: PPUSH
35563: CALL_OW 433
35567: ADD
35568: ST_TO_ADDR
35569: GO 35536
35571: POP
35572: POP
// mech := [ ] ;
35573: LD_ADDR_VAR 0 9
35577: PUSH
35578: EMPTY
35579: ST_TO_ADDR
// veh_n := 0 + veh_l ;
35580: LD_ADDR_VAR 0 7
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_VAR 0 8
35592: PLUS
35593: ST_TO_ADDR
// for un in list do
35594: LD_ADDR_VAR 0 3
35598: PUSH
35599: LD_VAR 0 5
35603: PUSH
35604: FOR_IN
35605: IFFALSE 35675
// if ( veh_n > 0 ) or ( ( list diff mech ) > 6 ) then
35607: LD_VAR 0 7
35611: PUSH
35612: LD_INT 0
35614: GREATER
35615: PUSH
35616: LD_VAR 0 5
35620: PUSH
35621: LD_VAR 0 9
35625: DIFF
35626: PUSH
35627: LD_INT 6
35629: GREATER
35630: OR
35631: IFFALSE 35673
// begin mech := mech ^ un ;
35633: LD_ADDR_VAR 0 9
35637: PUSH
35638: LD_VAR 0 9
35642: PUSH
35643: LD_VAR 0 3
35647: ADD
35648: ST_TO_ADDR
// veh_n := veh_n - GetSkill ( un , skill_mechanical ) ;
35649: LD_ADDR_VAR 0 7
35653: PUSH
35654: LD_VAR 0 7
35658: PUSH
35659: LD_VAR 0 3
35663: PPUSH
35664: LD_INT 3
35666: PPUSH
35667: CALL_OW 259
35671: MINUS
35672: ST_TO_ADDR
// end ;
35673: GO 35604
35675: POP
35676: POP
// un := reserved_people [ us ] ^ mech ;
35677: LD_ADDR_VAR 0 3
35681: PUSH
35682: LD_EXP 71
35686: PUSH
35687: LD_EXP 3
35691: ARRAY
35692: PUSH
35693: LD_VAR 0 9
35697: ADD
35698: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35699: LD_ADDR_EXP 71
35703: PUSH
35704: LD_EXP 71
35708: PPUSH
35709: LD_EXP 3
35713: PPUSH
35714: CALL_OW 3
35718: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35719: LD_ADDR_EXP 71
35723: PUSH
35724: LD_EXP 71
35728: PPUSH
35729: LD_EXP 3
35733: PPUSH
35734: LD_VAR 0 3
35738: PPUSH
35739: CALL_OW 2
35743: ST_TO_ADDR
// list := UnitsInside ( towers ) diff mech ;
35744: LD_ADDR_VAR 0 5
35748: PUSH
35749: LD_VAR 0 4
35753: PPUSH
35754: CALL_OW 313
35758: PUSH
35759: LD_VAR 0 9
35763: DIFF
35764: ST_TO_ADDR
// if list then
35765: LD_VAR 0 5
35769: IFFALSE 35925
// begin un := reserved_people [ us ] diff list ;
35771: LD_ADDR_VAR 0 3
35775: PUSH
35776: LD_EXP 71
35780: PUSH
35781: LD_EXP 3
35785: ARRAY
35786: PUSH
35787: LD_VAR 0 5
35791: DIFF
35792: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35793: LD_ADDR_EXP 71
35797: PUSH
35798: LD_EXP 71
35802: PPUSH
35803: LD_EXP 3
35807: PPUSH
35808: CALL_OW 3
35812: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35813: LD_ADDR_EXP 71
35817: PUSH
35818: LD_EXP 71
35822: PPUSH
35823: LD_EXP 3
35827: PPUSH
35828: LD_VAR 0 3
35832: PPUSH
35833: CALL_OW 2
35837: ST_TO_ADDR
// ComExitBuilding ( list ) ;
35838: LD_VAR 0 5
35842: PPUSH
35843: CALL_OW 122
// un := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
35847: LD_ADDR_VAR 0 3
35851: PUSH
35852: LD_INT 22
35854: PUSH
35855: LD_EXP 3
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: LD_INT 30
35869: PUSH
35870: LD_INT 2
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 30
35879: PUSH
35880: LD_INT 3
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: LIST
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PPUSH
35896: CALL_OW 69
35900: ST_TO_ADDR
// if un then
35901: LD_VAR 0 3
35905: IFFALSE 35925
// AddComMoveUnit ( list , un [ 1 ] ) ;
35907: LD_VAR 0 5
35911: PPUSH
35912: LD_VAR 0 3
35916: PUSH
35917: LD_INT 1
35919: ARRAY
35920: PPUSH
35921: CALL_OW 172
// end ; repeat ComMoveUnit ( mech , towers ) ;
35925: LD_VAR 0 9
35929: PPUSH
35930: LD_VAR 0 4
35934: PPUSH
35935: CALL_OW 112
// all_in := true ;
35939: LD_ADDR_VAR 0 6
35943: PUSH
35944: LD_INT 1
35946: ST_TO_ADDR
// for un in mech do
35947: LD_ADDR_VAR 0 3
35951: PUSH
35952: LD_VAR 0 9
35956: PUSH
35957: FOR_IN
35958: IFFALSE 35990
// if not ( IsInUnit ( un ) = towers ) then
35960: LD_VAR 0 3
35964: PPUSH
35965: CALL_OW 310
35969: PUSH
35970: LD_VAR 0 4
35974: EQUAL
35975: NOT
35976: IFFALSE 35988
// begin all_in := false ;
35978: LD_ADDR_VAR 0 6
35982: PUSH
35983: LD_INT 0
35985: ST_TO_ADDR
// break ;
35986: GO 35990
// end ;
35988: GO 35957
35990: POP
35991: POP
// wait ( 0 0$1 ) ;
35992: LD_INT 35
35994: PPUSH
35995: CALL_OW 67
// until all_in ;
35999: LD_VAR 0 6
36003: IFFALSE 35925
// ComLinkTo ( veh_l , towers ) ;
36005: LD_VAR 0 8
36009: PPUSH
36010: LD_VAR 0 4
36014: PPUSH
36015: CALL_OW 135
// enable ;
36019: ENABLE
// end ;
36020: LD_VAR 0 2
36024: RET
// every 0 0$10 do var list , tower ;
36025: GO 36027
36027: DISABLE
36028: LD_INT 0
36030: PPUSH
36031: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_ok ] , [ f_control , control_remote ] , f_not , [ f_linked ] ] ) ;
36032: LD_ADDR_VAR 0 1
36036: PUSH
36037: LD_INT 22
36039: PUSH
36040: LD_EXP 3
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 50
36051: PUSH
36052: EMPTY
36053: LIST
36054: PUSH
36055: LD_INT 33
36057: PUSH
36058: LD_INT 2
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 3
36067: PUSH
36068: LD_INT 61
36070: PUSH
36071: EMPTY
36072: LIST
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: PPUSH
36081: CALL_OW 69
36085: ST_TO_ADDR
// if list then
36086: LD_VAR 0 1
36090: IFFALSE 36174
// begin tower := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
36092: LD_ADDR_VAR 0 2
36096: PUSH
36097: LD_INT 22
36099: PUSH
36100: LD_EXP 3
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 30
36111: PUSH
36112: LD_INT 36
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 50
36121: PUSH
36122: EMPTY
36123: LIST
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: LIST
36129: PPUSH
36130: CALL_OW 69
36134: ST_TO_ADDR
// if tower then
36135: LD_VAR 0 2
36139: IFFALSE 36157
// tower := tower [ 1 ] else
36141: LD_ADDR_VAR 0 2
36145: PUSH
36146: LD_VAR 0 2
36150: PUSH
36151: LD_INT 1
36153: ARRAY
36154: ST_TO_ADDR
36155: GO 36160
// begin enable ;
36157: ENABLE
// exit ;
36158: GO 36175
// end ; ComLinkTo ( list , tower ) ;
36160: LD_VAR 0 1
36164: PPUSH
36165: LD_VAR 0 2
36169: PPUSH
36170: CALL_OW 135
// end ; enable ;
36174: ENABLE
// end ; end_of_file
36175: PPOPN 2
36177: END
// export us_sib_wait , ru_sib_wait ; var time_to_end ; export function init_sib_rocket ; begin
36178: LD_INT 0
36180: PPUSH
// us_sib_wait := false ;
36181: LD_ADDR_EXP 74
36185: PUSH
36186: LD_INT 0
36188: ST_TO_ADDR
// ru_sib_wait := false ;
36189: LD_ADDR_EXP 75
36193: PUSH
36194: LD_INT 0
36196: ST_TO_ADDR
// time_to_end := [ 85 85$0 , 65 65$0 , 45 45$0 ] [ difficulty ] ;
36197: LD_ADDR_LOC 80
36201: PUSH
36202: LD_INT 178500
36204: PUSH
36205: LD_INT 136500
36207: PUSH
36208: LD_INT 94500
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: LIST
36215: PUSH
36216: LD_OWVAR 67
36220: ARRAY
36221: ST_TO_ADDR
// end ;
36222: LD_VAR 0 1
36226: RET
// every 0 0$1.5 trigger TICK > time_to_end marked 4 do var factory , zdroje ;
36227: LD_OWVAR 1
36231: PUSH
36232: LD_LOC 80
36236: GREATER
36237: IFFALSE 36470
36239: GO 36241
36241: DISABLE
36242: LD_INT 0
36244: PPUSH
36245: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_factory ] ] ) ;
36246: LD_ADDR_VAR 0 1
36250: PUSH
36251: LD_INT 22
36253: PUSH
36254: LD_EXP 3
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 30
36265: PUSH
36266: LD_INT 3
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PPUSH
36277: CALL_OW 69
36281: ST_TO_ADDR
// if factory then
36282: LD_VAR 0 1
36286: IFFALSE 36469
// begin factory := factory [ 1 ] ;
36288: LD_ADDR_VAR 0 1
36292: PUSH
36293: LD_VAR 0 1
36297: PUSH
36298: LD_INT 1
36300: ARRAY
36301: ST_TO_ADDR
// if us_siberium_rocket in AvailableWeaponList ( factory ) then
36302: LD_INT 8
36304: PUSH
36305: LD_VAR 0 1
36309: PPUSH
36310: CALL_OW 478
36314: IN
36315: IFFALSE 36469
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36317: LD_ADDR_VAR 0 2
36321: PUSH
36322: LD_VAR 0 1
36326: PPUSH
36327: CALL_OW 274
36331: PPUSH
36332: CALL_OW 279
36336: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36337: LD_VAR 0 2
36341: PUSH
36342: LD_INT 1
36344: ARRAY
36345: PUSH
36346: LD_INT 75
36348: GREATEREQUAL
36349: PUSH
36350: LD_VAR 0 2
36354: PUSH
36355: LD_INT 2
36357: ARRAY
36358: PUSH
36359: LD_INT 30
36361: GREATEREQUAL
36362: PUSH
36363: LD_VAR 0 2
36367: PUSH
36368: LD_INT 3
36370: ARRAY
36371: PUSH
36372: LD_INT 70
36374: GREATEREQUAL
36375: OR
36376: AND
36377: PUSH
36378: LD_VAR 0 2
36382: PUSH
36383: LD_INT 3
36385: ARRAY
36386: PUSH
36387: LD_INT 60
36389: GREATEREQUAL
36390: AND
36391: IFFALSE 36461
// begin if zdroje [ 3 ] >= 70 then
36393: LD_VAR 0 2
36397: PUSH
36398: LD_INT 3
36400: ARRAY
36401: PUSH
36402: LD_INT 70
36404: GREATEREQUAL
36405: IFFALSE 36430
// ComConstruct ( factory , us_morphling , engine_siberite , control_remote , us_siberium_rocket ) else
36407: LD_VAR 0 1
36411: PPUSH
36412: LD_INT 5
36414: PPUSH
36415: LD_INT 3
36417: PPUSH
36418: LD_INT 2
36420: PPUSH
36421: LD_INT 8
36423: PPUSH
36424: CALL_OW 125
36428: GO 36451
// ComConstruct ( factory , us_morphling , engine_combustion , control_remote , us_siberium_rocket ) ;
36430: LD_VAR 0 1
36434: PPUSH
36435: LD_INT 5
36437: PPUSH
36438: LD_INT 1
36440: PPUSH
36441: LD_INT 2
36443: PPUSH
36444: LD_INT 8
36446: PPUSH
36447: CALL_OW 125
// us_sib_wait := false ;
36451: LD_ADDR_EXP 74
36455: PUSH
36456: LD_INT 0
36458: ST_TO_ADDR
// end else
36459: GO 36469
// us_sib_wait := true ;
36461: LD_ADDR_EXP 74
36465: PUSH
36466: LD_INT 1
36468: ST_TO_ADDR
// end ; end ; enable ;
36469: ENABLE
// end ;
36470: PPOPN 2
36472: END
// every 0 0$1.5 trigger TICK > time_to_end marked 5 do var factory , zdroje ;
36473: LD_OWVAR 1
36477: PUSH
36478: LD_LOC 80
36482: GREATER
36483: IFFALSE 36716
36485: GO 36487
36487: DISABLE
36488: LD_INT 0
36490: PPUSH
36491: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , ru ] , [ f_btype , b_factory ] ] ) ;
36492: LD_ADDR_VAR 0 1
36496: PUSH
36497: LD_INT 22
36499: PUSH
36500: LD_EXP 2
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 30
36511: PUSH
36512: LD_INT 3
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PPUSH
36523: CALL_OW 69
36527: ST_TO_ADDR
// if factory then
36528: LD_VAR 0 1
36532: IFFALSE 36715
// begin factory := factory [ 1 ] ;
36534: LD_ADDR_VAR 0 1
36538: PUSH
36539: LD_VAR 0 1
36543: PUSH
36544: LD_INT 1
36546: ARRAY
36547: ST_TO_ADDR
// if ru_siberium_rocket in AvailableWeaponList ( factory ) then
36548: LD_INT 48
36550: PUSH
36551: LD_VAR 0 1
36555: PPUSH
36556: CALL_OW 478
36560: IN
36561: IFFALSE 36715
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36563: LD_ADDR_VAR 0 2
36567: PUSH
36568: LD_VAR 0 1
36572: PPUSH
36573: CALL_OW 274
36577: PPUSH
36578: CALL_OW 279
36582: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36583: LD_VAR 0 2
36587: PUSH
36588: LD_INT 1
36590: ARRAY
36591: PUSH
36592: LD_INT 75
36594: GREATEREQUAL
36595: PUSH
36596: LD_VAR 0 2
36600: PUSH
36601: LD_INT 2
36603: ARRAY
36604: PUSH
36605: LD_INT 30
36607: GREATEREQUAL
36608: PUSH
36609: LD_VAR 0 2
36613: PUSH
36614: LD_INT 3
36616: ARRAY
36617: PUSH
36618: LD_INT 70
36620: GREATEREQUAL
36621: OR
36622: AND
36623: PUSH
36624: LD_VAR 0 2
36628: PUSH
36629: LD_INT 3
36631: ARRAY
36632: PUSH
36633: LD_INT 60
36635: GREATEREQUAL
36636: AND
36637: IFFALSE 36707
// begin if zdroje [ 3 ] >= 70 then
36639: LD_VAR 0 2
36643: PUSH
36644: LD_INT 3
36646: ARRAY
36647: PUSH
36648: LD_INT 70
36650: GREATEREQUAL
36651: IFFALSE 36676
// ComConstruct ( factory , ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ) else
36653: LD_VAR 0 1
36657: PPUSH
36658: LD_INT 23
36660: PPUSH
36661: LD_INT 3
36663: PPUSH
36664: LD_INT 3
36666: PPUSH
36667: LD_INT 48
36669: PPUSH
36670: CALL_OW 125
36674: GO 36697
// ComConstruct ( factory , ru_heavy_wheeled , engine_combustion , control_computer , ru_siberium_rocket ) ;
36676: LD_VAR 0 1
36680: PPUSH
36681: LD_INT 23
36683: PPUSH
36684: LD_INT 1
36686: PPUSH
36687: LD_INT 3
36689: PPUSH
36690: LD_INT 48
36692: PPUSH
36693: CALL_OW 125
// ru_sib_wait := false ;
36697: LD_ADDR_EXP 75
36701: PUSH
36702: LD_INT 0
36704: ST_TO_ADDR
// end else
36705: GO 36715
// ru_sib_wait := true ;
36707: LD_ADDR_EXP 75
36711: PUSH
36712: LD_INT 1
36714: ST_TO_ADDR
// end ; end ; enable ;
36715: ENABLE
// end ;
36716: PPOPN 2
36718: END
// export function send_sib_to_US ( veh ) ; var n_check , s_check , send ; begin
36719: LD_INT 0
36721: PPUSH
36722: PPUSH
36723: PPUSH
36724: PPUSH
// repeat n_check := FilterUnitsInArea ( north_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36725: LD_ADDR_VAR 0 3
36729: PUSH
36730: LD_INT 25
36732: PPUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 22
36748: PUSH
36749: LD_EXP 2
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: LIST
36762: PPUSH
36763: CALL_OW 70
36767: ST_TO_ADDR
// s_check := FilterUnitsInArea ( south_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36768: LD_ADDR_VAR 0 4
36772: PUSH
36773: LD_INT 26
36775: PPUSH
36776: LD_INT 21
36778: PUSH
36779: LD_INT 2
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 3
36788: PUSH
36789: LD_INT 22
36791: PUSH
36792: LD_EXP 2
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: LIST
36805: PPUSH
36806: CALL_OW 70
36810: ST_TO_ADDR
// wait ( 0 0$2 ) ;
36811: LD_INT 70
36813: PPUSH
36814: CALL_OW 67
// until ( n_check < 3 ) and ( s_check < 3 ) ;
36818: LD_VAR 0 3
36822: PUSH
36823: LD_INT 3
36825: LESS
36826: PUSH
36827: LD_VAR 0 4
36831: PUSH
36832: LD_INT 3
36834: LESS
36835: AND
36836: IFFALSE 36725
// ComMoveXY ( veh , 144 , 65 ) ;
36838: LD_VAR 0 1
36842: PPUSH
36843: LD_INT 144
36845: PPUSH
36846: LD_INT 65
36848: PPUSH
36849: CALL_OW 111
// if n_check < s_check then
36853: LD_VAR 0 3
36857: PUSH
36858: LD_VAR 0 4
36862: LESS
36863: IFFALSE 36912
// begin AddComMoveXY ( veh , 87 , 35 ) ;
36865: LD_VAR 0 1
36869: PPUSH
36870: LD_INT 87
36872: PPUSH
36873: LD_INT 35
36875: PPUSH
36876: CALL_OW 171
// AddComMoveXY ( veh , 42 , 16 ) ;
36880: LD_VAR 0 1
36884: PPUSH
36885: LD_INT 42
36887: PPUSH
36888: LD_INT 16
36890: PPUSH
36891: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 56 ) ;
36895: LD_VAR 0 1
36899: PPUSH
36900: LD_INT 41
36902: PPUSH
36903: LD_INT 56
36905: PPUSH
36906: CALL_OW 176
// end else
36910: GO 37004
// begin AddComMoveXY ( veh , 141 , 116 ) ;
36912: LD_VAR 0 1
36916: PPUSH
36917: LD_INT 141
36919: PPUSH
36920: LD_INT 116
36922: PPUSH
36923: CALL_OW 171
// AddComMoveXY ( veh , 109 , 110 ) ;
36927: LD_VAR 0 1
36931: PPUSH
36932: LD_INT 109
36934: PPUSH
36935: LD_INT 110
36937: PPUSH
36938: CALL_OW 171
// if GetChassis ( veh ) = ru_heavy_tracked then
36942: LD_VAR 0 1
36946: PPUSH
36947: CALL_OW 265
36951: PUSH
36952: LD_INT 24
36954: EQUAL
36955: IFFALSE 36974
// AddComMoveXY ( veh , 86 , 106 ) else
36957: LD_VAR 0 1
36961: PPUSH
36962: LD_INT 86
36964: PPUSH
36965: LD_INT 106
36967: PPUSH
36968: CALL_OW 171
36972: GO 36989
// AddComMoveXY ( veh , 85 , 75 ) ;
36974: LD_VAR 0 1
36978: PPUSH
36979: LD_INT 85
36981: PPUSH
36982: LD_INT 75
36984: PPUSH
36985: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 66 ) ;
36989: LD_VAR 0 1
36993: PPUSH
36994: LD_INT 41
36996: PPUSH
36997: LD_INT 66
36999: PPUSH
37000: CALL_OW 176
// end ; end ; end_of_file
37004: LD_VAR 0 2
37008: RET
// export artefact_number , artefact_num , artefact_size ; export labs_in_use ; export function init_alien_research ; var art_icons , art_events , art_difficulty , art_cost , art_recharge ; begin
37009: LD_INT 0
37011: PPUSH
37012: PPUSH
37013: PPUSH
37014: PPUSH
37015: PPUSH
37016: PPUSH
// artefact_number := 3 ;
37017: LD_ADDR_EXP 76
37021: PUSH
37022: LD_INT 3
37024: ST_TO_ADDR
// artefact_num := [ 0 , 0 , 1 , 2 , 3 ] ;
37025: LD_ADDR_EXP 77
37029: PUSH
37030: LD_INT 0
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: LD_INT 2
37041: PUSH
37042: LD_INT 3
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: ST_TO_ADDR
// artefact_size := [ 3 , 4 , 5 ] ;
37052: LD_ADDR_EXP 78
37056: PUSH
37057: LD_INT 3
37059: PUSH
37060: LD_INT 4
37062: PUSH
37063: LD_INT 5
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: LIST
37070: ST_TO_ADDR
// art_icons := [ [ art_exp_left , art_use_eye ] , [ art_exp_mid , art_use_sibexplosion ] , [ art_exp_right , art_use_power ] ] ;
37071: LD_ADDR_VAR 0 2
37075: PUSH
37076: LD_INT 1
37078: PUSH
37079: LD_INT 4
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 2
37088: PUSH
37089: LD_INT 5
37091: PUSH
37092: EMPTY
37093: LIST
37094: LIST
37095: PUSH
37096: LD_INT 3
37098: PUSH
37099: LD_INT 9
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: LIST
37110: ST_TO_ADDR
// art_events := [ art_place , art_unit , art_place ] ;
37111: LD_ADDR_VAR 0 3
37115: PUSH
37116: LD_INT 3
37118: PUSH
37119: LD_INT 4
37121: PUSH
37122: LD_INT 3
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: LIST
37129: ST_TO_ADDR
// art_difficulty := [ 150 , 250 , 400 ] ;
37130: LD_ADDR_VAR 0 4
37134: PUSH
37135: LD_INT 150
37137: PUSH
37138: LD_INT 250
37140: PUSH
37141: LD_INT 400
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: LIST
37148: ST_TO_ADDR
// art_cost := [ 1 + difficulty , 2 + ( 3 * difficulty ) , 30 + ( 10 * difficulty ) ] ;
37149: LD_ADDR_VAR 0 5
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: LD_OWVAR 67
37161: PLUS
37162: PUSH
37163: LD_INT 2
37165: PUSH
37166: LD_INT 3
37168: PUSH
37169: LD_OWVAR 67
37173: MUL
37174: PLUS
37175: PUSH
37176: LD_INT 30
37178: PUSH
37179: LD_INT 10
37181: PUSH
37182: LD_OWVAR 67
37186: MUL
37187: PLUS
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: LIST
37193: ST_TO_ADDR
// art_recharge := [ 6 * difficulty , 12 * difficulty , 10000 ] ;
37194: LD_ADDR_VAR 0 6
37198: PUSH
37199: LD_INT 6
37201: PUSH
37202: LD_OWVAR 67
37206: MUL
37207: PUSH
37208: LD_INT 12
37210: PUSH
37211: LD_OWVAR 67
37215: MUL
37216: PUSH
37217: LD_INT 10000
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: LIST
37224: ST_TO_ADDR
// Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ;
37225: LD_VAR 0 2
37229: PPUSH
37230: LD_VAR 0 3
37234: PPUSH
37235: LD_VAR 0 4
37239: PPUSH
37240: LD_VAR 0 5
37244: PPUSH
37245: LD_VAR 0 6
37249: PPUSH
37250: CALL 37259 0 5
// end ;
37254: LD_VAR 0 1
37258: RET
// function Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ; var un , i , side , base ; begin
37259: LD_INT 0
37261: PPUSH
37262: PPUSH
37263: PPUSH
37264: PPUSH
37265: PPUSH
// disable ( 1 ) ;
37266: LD_INT 1
37268: DISABLE_MARKED
// disable ( 5 ) ;
37269: LD_INT 5
37271: DISABLE_MARKED
// disable ( 6 ) ;
37272: LD_INT 6
37274: DISABLE_MARKED
// disable ( 7 ) ;
37275: LD_INT 7
37277: DISABLE_MARKED
// for side = 1 to 8 do
37278: LD_ADDR_VAR 0 9
37282: PUSH
37283: DOUBLE
37284: LD_INT 1
37286: DEC
37287: ST_TO_ADDR
37288: LD_INT 8
37290: PUSH
37291: FOR_TO
37292: IFFALSE 37308
// SetArtifactRes ( side , state_enabled ) ;
37294: LD_VAR 0 9
37298: PPUSH
37299: LD_INT 1
37301: PPUSH
37302: CALL_OW 467
37306: GO 37291
37308: POP
37309: POP
// for un = 0 to ( artefact_number - 1 ) do
37310: LD_ADDR_VAR 0 7
37314: PUSH
37315: DOUBLE
37316: LD_INT 0
37318: DEC
37319: ST_TO_ADDR
37320: LD_EXP 76
37324: PUSH
37325: LD_INT 1
37327: MINUS
37328: PUSH
37329: FOR_TO
37330: IFFALSE 37728
// begin base := un * 100 ;
37332: LD_ADDR_VAR 0 10
37336: PUSH
37337: LD_VAR 0 7
37341: PUSH
37342: LD_INT 100
37344: MUL
37345: ST_TO_ADDR
// SetTag ( base + 01 , art_icons [ un + 1 ] [ 1 ] ) ;
37346: LD_VAR 0 10
37350: PUSH
37351: LD_INT 1
37353: PLUS
37354: PPUSH
37355: LD_VAR 0 1
37359: PUSH
37360: LD_VAR 0 7
37364: PUSH
37365: LD_INT 1
37367: PLUS
37368: ARRAY
37369: PUSH
37370: LD_INT 1
37372: ARRAY
37373: PPUSH
37374: CALL_OW 109
// SetTag ( base + 02 , art_icons [ un + 1 ] [ 2 ] ) ;
37378: LD_VAR 0 10
37382: PUSH
37383: LD_INT 2
37385: PLUS
37386: PPUSH
37387: LD_VAR 0 1
37391: PUSH
37392: LD_VAR 0 7
37396: PUSH
37397: LD_INT 1
37399: PLUS
37400: ARRAY
37401: PUSH
37402: LD_INT 2
37404: ARRAY
37405: PPUSH
37406: CALL_OW 109
// SetTag ( base + 03 , art_events [ un + 1 ] ) ;
37410: LD_VAR 0 10
37414: PUSH
37415: LD_INT 3
37417: PLUS
37418: PPUSH
37419: LD_VAR 0 2
37423: PUSH
37424: LD_VAR 0 7
37428: PUSH
37429: LD_INT 1
37431: PLUS
37432: ARRAY
37433: PPUSH
37434: CALL_OW 109
// SetTag ( base + 05 , art_difficulty [ un + 1 ] ) ;
37438: LD_VAR 0 10
37442: PUSH
37443: LD_INT 5
37445: PLUS
37446: PPUSH
37447: LD_VAR 0 3
37451: PUSH
37452: LD_VAR 0 7
37456: PUSH
37457: LD_INT 1
37459: PLUS
37460: ARRAY
37461: PPUSH
37462: CALL_OW 109
// SetTag ( base + 06 , art_cost [ un + 1 ] ) ;
37466: LD_VAR 0 10
37470: PUSH
37471: LD_INT 6
37473: PLUS
37474: PPUSH
37475: LD_VAR 0 4
37479: PUSH
37480: LD_VAR 0 7
37484: PUSH
37485: LD_INT 1
37487: PLUS
37488: ARRAY
37489: PPUSH
37490: CALL_OW 109
// SetTag ( base + 07 , art_recharge [ un + 1 ] ) ;
37494: LD_VAR 0 10
37498: PUSH
37499: LD_INT 7
37501: PLUS
37502: PPUSH
37503: LD_VAR 0 5
37507: PUSH
37508: LD_VAR 0 7
37512: PUSH
37513: LD_INT 1
37515: PLUS
37516: ARRAY
37517: PPUSH
37518: CALL_OW 109
// SetTag ( base + 08 , false ) ;
37522: LD_VAR 0 10
37526: PUSH
37527: LD_INT 8
37529: PLUS
37530: PPUSH
37531: LD_INT 0
37533: PPUSH
37534: CALL_OW 109
// SetTag ( base + 09 , false ) ;
37538: LD_VAR 0 10
37542: PUSH
37543: LD_INT 9
37545: PLUS
37546: PPUSH
37547: LD_INT 0
37549: PPUSH
37550: CALL_OW 109
// SetTag ( base + 11 , 0 ) ;
37554: LD_VAR 0 10
37558: PUSH
37559: LD_INT 11
37561: PLUS
37562: PPUSH
37563: LD_INT 0
37565: PPUSH
37566: CALL_OW 109
// SetTag ( base + 12 , false ) ;
37570: LD_VAR 0 10
37574: PUSH
37575: LD_INT 12
37577: PLUS
37578: PPUSH
37579: LD_INT 0
37581: PPUSH
37582: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37586: LD_VAR 0 10
37590: PUSH
37591: LD_INT 13
37593: PLUS
37594: PPUSH
37595: LD_INT 0
37597: PPUSH
37598: CALL_OW 109
// for i = 0 to 7 do
37602: LD_ADDR_VAR 0 8
37606: PUSH
37607: DOUBLE
37608: LD_INT 0
37610: DEC
37611: ST_TO_ADDR
37612: LD_INT 7
37614: PUSH
37615: FOR_TO
37616: IFFALSE 37724
// begin SetTag ( base + i * 10 + 21 , false ) ;
37618: LD_VAR 0 10
37622: PUSH
37623: LD_VAR 0 8
37627: PUSH
37628: LD_INT 10
37630: MUL
37631: PLUS
37632: PUSH
37633: LD_INT 21
37635: PLUS
37636: PPUSH
37637: LD_INT 0
37639: PPUSH
37640: CALL_OW 109
// SetTag ( base + i * 10 + 22 , 0 ) ;
37644: LD_VAR 0 10
37648: PUSH
37649: LD_VAR 0 8
37653: PUSH
37654: LD_INT 10
37656: MUL
37657: PLUS
37658: PUSH
37659: LD_INT 22
37661: PLUS
37662: PPUSH
37663: LD_INT 0
37665: PPUSH
37666: CALL_OW 109
// SetTag ( base + i * 10 + 23 , 0 ) ;
37670: LD_VAR 0 10
37674: PUSH
37675: LD_VAR 0 8
37679: PUSH
37680: LD_INT 10
37682: MUL
37683: PLUS
37684: PUSH
37685: LD_INT 23
37687: PLUS
37688: PPUSH
37689: LD_INT 0
37691: PPUSH
37692: CALL_OW 109
// SetTag ( base + i * 10 + 25 , 0 ) ;
37696: LD_VAR 0 10
37700: PUSH
37701: LD_VAR 0 8
37705: PUSH
37706: LD_INT 10
37708: MUL
37709: PLUS
37710: PUSH
37711: LD_INT 25
37713: PLUS
37714: PPUSH
37715: LD_INT 0
37717: PPUSH
37718: CALL_OW 109
// end ;
37722: GO 37615
37724: POP
37725: POP
// end ;
37726: GO 37329
37728: POP
37729: POP
// enable ( 20 ) ;
37730: LD_INT 20
37732: ENABLE_MARKED
// labs_in_use := [ ] ;
37733: LD_ADDR_EXP 79
37737: PUSH
37738: EMPTY
37739: ST_TO_ADDR
// end ;
37740: LD_VAR 0 6
37744: RET
// on ArtifactUnloaded ( un , size ) do var art , base ;
37745: LD_INT 0
37747: PPUSH
37748: PPUSH
// begin art := artefact_num [ size ] ;
37749: LD_ADDR_VAR 0 3
37753: PUSH
37754: LD_EXP 77
37758: PUSH
37759: LD_VAR 0 2
37763: ARRAY
37764: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37765: LD_ADDR_VAR 0 4
37769: PUSH
37770: LD_VAR 0 3
37774: PUSH
37775: LD_INT 1
37777: MINUS
37778: PUSH
37779: LD_INT 100
37781: MUL
37782: ST_TO_ADDR
// SetTag ( base + 09 , false ) ;
37783: LD_VAR 0 4
37787: PUSH
37788: LD_INT 9
37790: PLUS
37791: PPUSH
37792: LD_INT 0
37794: PPUSH
37795: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37799: LD_VAR 0 4
37803: PUSH
37804: LD_INT 13
37806: PLUS
37807: PPUSH
37808: LD_INT 0
37810: PPUSH
37811: CALL_OW 109
// Init_Lab ( art ) ;
37815: LD_VAR 0 3
37819: PPUSH
37820: CALL 39356 0 1
// end ;
37824: PPOPN 4
37826: END
// on ArtifactLoaded ( un , size ) do var art , base , side ;
37827: LD_INT 0
37829: PPUSH
37830: PPUSH
37831: PPUSH
// begin art := artefact_num [ size ] ;
37832: LD_ADDR_VAR 0 3
37836: PUSH
37837: LD_EXP 77
37841: PUSH
37842: LD_VAR 0 2
37846: ARRAY
37847: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37848: LD_ADDR_VAR 0 4
37852: PUSH
37853: LD_VAR 0 3
37857: PUSH
37858: LD_INT 1
37860: MINUS
37861: PUSH
37862: LD_INT 100
37864: MUL
37865: ST_TO_ADDR
// SetTag ( base + 09 , true ) ;
37866: LD_VAR 0 4
37870: PUSH
37871: LD_INT 9
37873: PLUS
37874: PPUSH
37875: LD_INT 1
37877: PPUSH
37878: CALL_OW 109
// SetTag ( base + 13 , un ) ;
37882: LD_VAR 0 4
37886: PUSH
37887: LD_INT 13
37889: PLUS
37890: PPUSH
37891: LD_VAR 0 1
37895: PPUSH
37896: CALL_OW 109
// if GetTag ( base + 11 ) then
37900: LD_VAR 0 4
37904: PUSH
37905: LD_INT 11
37907: PLUS
37908: PPUSH
37909: CALL_OW 110
37913: IFFALSE 38076
// begin side := GetSide ( GetTag ( base + 11 ) ) ;
37915: LD_ADDR_VAR 0 5
37919: PUSH
37920: LD_VAR 0 4
37924: PUSH
37925: LD_INT 11
37927: PLUS
37928: PPUSH
37929: CALL_OW 110
37933: PPUSH
37934: CALL_OW 255
37938: ST_TO_ADDR
// if GetTag ( base + 12 ) then
37939: LD_VAR 0 4
37943: PUSH
37944: LD_INT 12
37946: PLUS
37947: PPUSH
37948: CALL_OW 110
37952: IFFALSE 38020
// begin ComCancel ( GetTag ( base + 11 ) ) ;
37954: LD_VAR 0 4
37958: PUSH
37959: LD_INT 11
37961: PLUS
37962: PPUSH
37963: CALL_OW 110
37967: PPUSH
37968: CALL_OW 127
// wait ( 5 ) ;
37972: LD_INT 5
37974: PPUSH
37975: CALL_OW 67
// labs_in_use := labs_in_use diff GetTag ( base + 11 ) ;
37979: LD_ADDR_EXP 79
37983: PUSH
37984: LD_EXP 79
37988: PUSH
37989: LD_VAR 0 4
37993: PUSH
37994: LD_INT 11
37996: PLUS
37997: PPUSH
37998: CALL_OW 110
38002: DIFF
38003: ST_TO_ADDR
// SetTag ( base + 12 , false ) ;
38004: LD_VAR 0 4
38008: PUSH
38009: LD_INT 12
38011: PLUS
38012: PPUSH
38013: LD_INT 0
38015: PPUSH
38016: CALL_OW 109
// end ; if not GetTag ( base + side * 10 + 11 ) then
38020: LD_VAR 0 4
38024: PUSH
38025: LD_VAR 0 5
38029: PUSH
38030: LD_INT 10
38032: MUL
38033: PLUS
38034: PUSH
38035: LD_INT 11
38037: PLUS
38038: PPUSH
38039: CALL_OW 110
38043: NOT
38044: IFFALSE 38060
// DeInit_Lab ( side , art ) ;
38046: LD_VAR 0 5
38050: PPUSH
38051: LD_VAR 0 3
38055: PPUSH
38056: CALL 40050 0 2
// SetTag ( base + 11 , 0 ) ;
38060: LD_VAR 0 4
38064: PUSH
38065: LD_INT 11
38067: PLUS
38068: PPUSH
38069: LD_INT 0
38071: PPUSH
38072: CALL_OW 109
// end ; end ;
38076: PPOPN 5
38078: END
// on ArtifactResearchComplete ( lab ) do var un , side ;
38079: LD_INT 0
38081: PPUSH
38082: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38083: LD_ADDR_VAR 0 3
38087: PUSH
38088: LD_VAR 0 1
38092: PPUSH
38093: CALL_OW 255
38097: PUSH
38098: LD_INT 1
38100: MINUS
38101: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38102: LD_ADDR_VAR 0 2
38106: PUSH
38107: DOUBLE
38108: LD_INT 0
38110: DEC
38111: ST_TO_ADDR
38112: LD_EXP 76
38116: PUSH
38117: LD_INT 1
38119: MINUS
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38164
// if lab = GetTag ( un * 100 + 11 ) then
38124: LD_VAR 0 1
38128: PUSH
38129: LD_VAR 0 2
38133: PUSH
38134: LD_INT 100
38136: MUL
38137: PUSH
38138: LD_INT 11
38140: PLUS
38141: PPUSH
38142: CALL_OW 110
38146: EQUAL
38147: IFFALSE 38162
// Init_Lab ( un + 1 ) ;
38149: LD_VAR 0 2
38153: PUSH
38154: LD_INT 1
38156: PLUS
38157: PPUSH
38158: CALL 39356 0 1
38162: GO 38121
38164: POP
38165: POP
// end ;
38166: PPOPN 3
38168: END
// on SpecResearchCancel ( lab , progress ) do var un , side ;
38169: LD_INT 0
38171: PPUSH
38172: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38173: LD_ADDR_VAR 0 4
38177: PUSH
38178: LD_VAR 0 1
38182: PPUSH
38183: CALL_OW 255
38187: PUSH
38188: LD_INT 1
38190: MINUS
38191: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38192: LD_ADDR_VAR 0 3
38196: PUSH
38197: DOUBLE
38198: LD_INT 0
38200: DEC
38201: ST_TO_ADDR
38202: LD_EXP 76
38206: PUSH
38207: LD_INT 1
38209: MINUS
38210: PUSH
38211: FOR_TO
38212: IFFALSE 38330
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38214: LD_VAR 0 3
38218: PUSH
38219: LD_INT 100
38221: MUL
38222: PUSH
38223: LD_INT 11
38225: PLUS
38226: PPUSH
38227: CALL_OW 110
38231: PUSH
38232: LD_VAR 0 1
38236: EQUAL
38237: PUSH
38238: LD_VAR 0 3
38242: PUSH
38243: LD_INT 100
38245: MUL
38246: PUSH
38247: LD_INT 12
38249: PLUS
38250: PPUSH
38251: CALL_OW 110
38255: AND
38256: IFFALSE 38328
// begin SetTag ( un * 100 + side * 10 + 22 , progress ) ;
38258: LD_VAR 0 3
38262: PUSH
38263: LD_INT 100
38265: MUL
38266: PUSH
38267: LD_VAR 0 4
38271: PUSH
38272: LD_INT 10
38274: MUL
38275: PLUS
38276: PUSH
38277: LD_INT 22
38279: PLUS
38280: PPUSH
38281: LD_VAR 0 2
38285: PPUSH
38286: CALL_OW 109
// SetTag ( un * 100 + 12 , false ) ;
38290: LD_VAR 0 3
38294: PUSH
38295: LD_INT 100
38297: MUL
38298: PUSH
38299: LD_INT 12
38301: PLUS
38302: PPUSH
38303: LD_INT 0
38305: PPUSH
38306: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38310: LD_ADDR_EXP 79
38314: PUSH
38315: LD_EXP 79
38319: PUSH
38320: LD_VAR 0 1
38324: DIFF
38325: ST_TO_ADDR
// break ;
38326: GO 38330
// end ;
38328: GO 38211
38330: POP
38331: POP
// Update_Artefact ( lab ) ;
38332: LD_VAR 0 1
38336: PPUSH
38337: CALL 40189 0 1
// end ;
38341: PPOPN 4
38343: END
// on SpecResearchComplete ( lab ) do var un , side ;
38344: LD_INT 0
38346: PPUSH
38347: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38348: LD_ADDR_VAR 0 3
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: CALL_OW 255
38362: PUSH
38363: LD_INT 1
38365: MINUS
38366: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38367: LD_ADDR_VAR 0 2
38371: PUSH
38372: DOUBLE
38373: LD_INT 0
38375: DEC
38376: ST_TO_ADDR
38377: LD_EXP 76
38381: PUSH
38382: LD_INT 1
38384: MINUS
38385: PUSH
38386: FOR_TO
38387: IFFALSE 38593
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38389: LD_VAR 0 2
38393: PUSH
38394: LD_INT 100
38396: MUL
38397: PUSH
38398: LD_INT 11
38400: PLUS
38401: PPUSH
38402: CALL_OW 110
38406: PUSH
38407: LD_VAR 0 1
38411: EQUAL
38412: PUSH
38413: LD_VAR 0 2
38417: PUSH
38418: LD_INT 100
38420: MUL
38421: PUSH
38422: LD_INT 12
38424: PLUS
38425: PPUSH
38426: CALL_OW 110
38430: AND
38431: IFFALSE 38591
// begin SetTag ( un * 100 + 12 , false ) ;
38433: LD_VAR 0 2
38437: PUSH
38438: LD_INT 100
38440: MUL
38441: PUSH
38442: LD_INT 12
38444: PLUS
38445: PPUSH
38446: LD_INT 0
38448: PPUSH
38449: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 21 , true ) ;
38453: LD_VAR 0 2
38457: PUSH
38458: LD_INT 100
38460: MUL
38461: PUSH
38462: LD_VAR 0 3
38466: PUSH
38467: LD_INT 10
38469: MUL
38470: PLUS
38471: PUSH
38472: LD_INT 21
38474: PLUS
38475: PPUSH
38476: LD_INT 1
38478: PPUSH
38479: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 25 , lab ) ;
38483: LD_VAR 0 2
38487: PUSH
38488: LD_INT 100
38490: MUL
38491: PUSH
38492: LD_VAR 0 3
38496: PUSH
38497: LD_INT 10
38499: MUL
38500: PLUS
38501: PUSH
38502: LD_INT 25
38504: PLUS
38505: PPUSH
38506: LD_VAR 0 1
38510: PPUSH
38511: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38515: LD_ADDR_EXP 79
38519: PUSH
38520: LD_EXP 79
38524: PUSH
38525: LD_VAR 0 1
38529: DIFF
38530: ST_TO_ADDR
// case un of 0 :
38531: LD_VAR 0 2
38535: PUSH
38536: LD_INT 0
38538: DOUBLE
38539: EQUAL
38540: IFTRUE 38544
38542: GO 38554
38544: POP
// Hint ( ATSpy ) ; 1 :
38545: LD_STRING ATSpy
38547: PPUSH
38548: CALL_OW 339
38552: GO 38591
38554: LD_INT 1
38556: DOUBLE
38557: EQUAL
38558: IFTRUE 38562
38560: GO 38572
38562: POP
// Hint ( ATDetonated ) ; 2 :
38563: LD_STRING ATDetonated
38565: PPUSH
38566: CALL_OW 339
38570: GO 38591
38572: LD_INT 2
38574: DOUBLE
38575: EQUAL
38576: IFTRUE 38580
38578: GO 38590
38580: POP
// Hint ( ArterfactTeleport ) ; end ;
38581: LD_STRING ArterfactTeleport
38583: PPUSH
38584: CALL_OW 339
38588: GO 38591
38590: POP
// end ;
38591: GO 38386
38593: POP
38594: POP
// Update_Artefact ( lab ) ;
38595: LD_VAR 0 1
38599: PPUSH
38600: CALL 40189 0 1
// end ;
38604: PPOPN 3
38606: END
// on ArtifactUsed ( side , number , p1 , p2 ) do var un , succes , art , base ;
38607: LD_INT 0
38609: PPUSH
38610: PPUSH
38611: PPUSH
38612: PPUSH
// begin art := ( ( number - 1 ) mod 3 ) + 1 ;
38613: LD_ADDR_VAR 0 7
38617: PUSH
38618: LD_VAR 0 2
38622: PUSH
38623: LD_INT 1
38625: MINUS
38626: PUSH
38627: LD_INT 3
38629: MOD
38630: PUSH
38631: LD_INT 1
38633: PLUS
38634: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38635: LD_ADDR_VAR 0 8
38639: PUSH
38640: LD_VAR 0 7
38644: PUSH
38645: LD_INT 1
38647: MINUS
38648: PUSH
38649: LD_INT 100
38651: MUL
38652: ST_TO_ADDR
// if number <= 3 then
38653: LD_VAR 0 2
38657: PUSH
38658: LD_INT 3
38660: LESSEQUAL
38661: IFFALSE 38893
// begin SetSpecResearch ( GetTag ( base + 11 ) , GetTag ( base + 05 ) , true ) ;
38663: LD_VAR 0 8
38667: PUSH
38668: LD_INT 11
38670: PLUS
38671: PPUSH
38672: CALL_OW 110
38676: PPUSH
38677: LD_VAR 0 8
38681: PUSH
38682: LD_INT 5
38684: PLUS
38685: PPUSH
38686: CALL_OW 110
38690: PPUSH
38691: LD_INT 1
38693: PPUSH
38694: CALL_OW 486
// SetWorkingProgress ( GetTag ( base + 11 ) , GetTag ( base + side * 10 + 12 ) ) ;
38698: LD_VAR 0 8
38702: PUSH
38703: LD_INT 11
38705: PLUS
38706: PPUSH
38707: CALL_OW 110
38711: PPUSH
38712: LD_VAR 0 8
38716: PUSH
38717: LD_VAR 0 1
38721: PUSH
38722: LD_INT 10
38724: MUL
38725: PLUS
38726: PUSH
38727: LD_INT 12
38729: PLUS
38730: PPUSH
38731: CALL_OW 110
38735: PPUSH
38736: CALL_OW 329
// SetTag ( base + 12 , true ) ;
38740: LD_VAR 0 8
38744: PUSH
38745: LD_INT 12
38747: PLUS
38748: PPUSH
38749: LD_INT 1
38751: PPUSH
38752: CALL_OW 109
// labs_in_use := labs_in_use ^ GetTag ( base + 11 ) ;
38756: LD_ADDR_EXP 79
38760: PUSH
38761: LD_EXP 79
38765: PUSH
38766: LD_VAR 0 8
38770: PUSH
38771: LD_INT 11
38773: PLUS
38774: PPUSH
38775: CALL_OW 110
38779: ADD
38780: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38781: LD_ADDR_VAR 0 5
38785: PUSH
38786: DOUBLE
38787: LD_INT 0
38789: DEC
38790: ST_TO_ADDR
38791: LD_EXP 76
38795: PUSH
38796: LD_INT 1
38798: MINUS
38799: PUSH
38800: FOR_TO
38801: IFFALSE 38889
// if GetTag ( base + 11 ) in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
38803: LD_VAR 0 8
38807: PUSH
38808: LD_INT 11
38810: PLUS
38811: PPUSH
38812: CALL_OW 110
38816: PUSH
38817: LD_VAR 0 5
38821: PUSH
38822: LD_INT 100
38824: MUL
38825: PUSH
38826: LD_INT 11
38828: PLUS
38829: PPUSH
38830: CALL_OW 110
38834: PUSH
38835: LD_VAR 0 5
38839: PUSH
38840: LD_INT 100
38842: MUL
38843: PUSH
38844: LD_VAR 0 1
38848: PUSH
38849: LD_INT 10
38851: MUL
38852: PLUS
38853: PUSH
38854: LD_INT 15
38856: PLUS
38857: PPUSH
38858: CALL_OW 110
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: IN
38867: IFFALSE 38887
// DeInit_Lab ( side , un + 1 ) ;
38869: LD_VAR 0 1
38873: PPUSH
38874: LD_VAR 0 5
38878: PUSH
38879: LD_INT 1
38881: PLUS
38882: PPUSH
38883: CALL 40050 0 2
38887: GO 38800
38889: POP
38890: POP
// end else
38891: GO 39067
// begin succes := false ;
38893: LD_ADDR_VAR 0 6
38897: PUSH
38898: LD_INT 0
38900: ST_TO_ADDR
// case art of 1 :
38901: LD_VAR 0 7
38905: PUSH
38906: LD_INT 1
38908: DOUBLE
38909: EQUAL
38910: IFTRUE 38914
38912: GO 38942
38914: POP
// succes := Show_me_map ( side , p1 , p2 ) ; 2 :
38915: LD_ADDR_VAR 0 6
38919: PUSH
38920: LD_VAR 0 1
38924: PPUSH
38925: LD_VAR 0 3
38929: PPUSH
38930: LD_VAR 0 4
38934: PPUSH
38935: CALL 40489 0 3
38939: ST_TO_ADDR
38940: GO 39010
38942: LD_INT 2
38944: DOUBLE
38945: EQUAL
38946: IFTRUE 38950
38948: GO 38973
38950: POP
// succes := Destroy_siberite ( side , p1 ) ; 3 :
38951: LD_ADDR_VAR 0 6
38955: PUSH
38956: LD_VAR 0 1
38960: PPUSH
38961: LD_VAR 0 3
38965: PPUSH
38966: CALL 40727 0 2
38970: ST_TO_ADDR
38971: GO 39010
38973: LD_INT 3
38975: DOUBLE
38976: EQUAL
38977: IFTRUE 38981
38979: GO 39009
38981: POP
// succes := Mass_Teleport ( side , p1 , p2 ) ; end ;
38982: LD_ADDR_VAR 0 6
38986: PUSH
38987: LD_VAR 0 1
38991: PPUSH
38992: LD_VAR 0 3
38996: PPUSH
38997: LD_VAR 0 4
39001: PPUSH
39002: CALL 41052 0 3
39006: ST_TO_ADDR
39007: GO 39010
39009: POP
// if succes then
39010: LD_VAR 0 6
39014: IFFALSE 39067
// begin SetTag ( base + side * 10 + 13 , GetTag ( base + 07 ) ) ;
39016: LD_VAR 0 8
39020: PUSH
39021: LD_VAR 0 1
39025: PUSH
39026: LD_INT 10
39028: MUL
39029: PLUS
39030: PUSH
39031: LD_INT 13
39033: PLUS
39034: PPUSH
39035: LD_VAR 0 8
39039: PUSH
39040: LD_INT 7
39042: PLUS
39043: PPUSH
39044: CALL_OW 110
39048: PPUSH
39049: CALL_OW 109
// Shadow_Artefact ( side , art ) ;
39053: LD_VAR 0 1
39057: PPUSH
39058: LD_VAR 0 7
39062: PPUSH
39063: CALL 39070 0 2
// end ; end ; end ;
39067: PPOPN 8
39069: END
// export function Shadow_Artefact ( side , art ) ; var base , lab ; begin
39070: LD_INT 0
39072: PPUSH
39073: PPUSH
39074: PPUSH
// base := ( art - 1 ) * 100 ;
39075: LD_ADDR_VAR 0 4
39079: PUSH
39080: LD_VAR 0 2
39084: PUSH
39085: LD_INT 1
39087: MINUS
39088: PUSH
39089: LD_INT 100
39091: MUL
39092: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39093: LD_ADDR_VAR 0 5
39097: PUSH
39098: LD_VAR 0 4
39102: PUSH
39103: LD_VAR 0 1
39107: PUSH
39108: LD_INT 10
39110: MUL
39111: PLUS
39112: PUSH
39113: LD_INT 15
39115: PLUS
39116: PPUSH
39117: CALL_OW 110
39121: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) then
39122: LD_VAR 0 5
39126: PUSH
39127: LD_VAR 0 5
39131: PUSH
39132: LD_EXP 79
39136: IN
39137: NOT
39138: AND
39139: IFFALSE 39197
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_gray , lab ) ;
39141: LD_VAR 0 1
39145: PPUSH
39146: LD_VAR 0 4
39150: PUSH
39151: LD_INT 1
39153: PLUS
39154: PUSH
39155: LD_VAR 0 4
39159: PUSH
39160: LD_VAR 0 1
39164: PUSH
39165: LD_INT 10
39167: MUL
39168: PLUS
39169: PUSH
39170: LD_INT 11
39172: PLUS
39173: PPUSH
39174: CALL_OW 110
39178: PLUS
39179: PPUSH
39180: CALL_OW 110
39184: PPUSH
39185: LD_INT 1
39187: PPUSH
39188: LD_VAR 0 5
39192: PPUSH
39193: CALL_OW 468
// end ;
39197: LD_VAR 0 3
39201: RET
// export function Highlight_Artefact ( side , art ) ; var base , lab ; begin
39202: LD_INT 0
39204: PPUSH
39205: PPUSH
39206: PPUSH
// base := ( art - 1 ) * 100 ;
39207: LD_ADDR_VAR 0 4
39211: PUSH
39212: LD_VAR 0 2
39216: PUSH
39217: LD_INT 1
39219: MINUS
39220: PUSH
39221: LD_INT 100
39223: MUL
39224: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39225: LD_ADDR_VAR 0 5
39229: PUSH
39230: LD_VAR 0 4
39234: PUSH
39235: LD_VAR 0 1
39239: PUSH
39240: LD_INT 10
39242: MUL
39243: PLUS
39244: PUSH
39245: LD_INT 15
39247: PLUS
39248: PPUSH
39249: CALL_OW 110
39253: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) and UnitsInside ( lab ) then
39254: LD_VAR 0 5
39258: PUSH
39259: LD_VAR 0 5
39263: PUSH
39264: LD_EXP 79
39268: IN
39269: NOT
39270: AND
39271: PUSH
39272: LD_VAR 0 5
39276: PPUSH
39277: CALL_OW 313
39281: AND
39282: IFFALSE 39351
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , GetTag ( base + 03 ) , lab ) ;
39284: LD_VAR 0 1
39288: PPUSH
39289: LD_VAR 0 4
39293: PUSH
39294: LD_INT 1
39296: PLUS
39297: PUSH
39298: LD_VAR 0 4
39302: PUSH
39303: LD_VAR 0 1
39307: PUSH
39308: LD_INT 10
39310: MUL
39311: PLUS
39312: PUSH
39313: LD_INT 11
39315: PLUS
39316: PPUSH
39317: CALL_OW 110
39321: PLUS
39322: PPUSH
39323: CALL_OW 110
39327: PPUSH
39328: LD_VAR 0 4
39332: PUSH
39333: LD_INT 3
39335: PLUS
39336: PPUSH
39337: CALL_OW 110
39341: PPUSH
39342: LD_VAR 0 5
39346: PPUSH
39347: CALL_OW 468
// end ;
39351: LD_VAR 0 3
39355: RET
// export function Init_Lab ( art ) ; var list , side , base , dist , state , art_hex , nearest_lab ; begin
39356: LD_INT 0
39358: PPUSH
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
39363: PPUSH
39364: PPUSH
39365: PPUSH
// art_hex := FindArtifact ( artefact_size [ art ] ) ;
39366: LD_ADDR_VAR 0 8
39370: PUSH
39371: LD_EXP 78
39375: PUSH
39376: LD_VAR 0 1
39380: ARRAY
39381: PPUSH
39382: CALL_OW 469
39386: ST_TO_ADDR
// if not art_hex then
39387: LD_VAR 0 8
39391: NOT
39392: IFFALSE 39396
// exit ;
39394: GO 40045
// case art of 1 :
39396: LD_VAR 0 1
39400: PUSH
39401: LD_INT 1
39403: DOUBLE
39404: EQUAL
39405: IFTRUE 39409
39407: GO 39486
39409: POP
// list := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 2 :
39410: LD_ADDR_VAR 0 3
39414: PUSH
39415: LD_INT 23
39417: PUSH
39418: LD_INT 1
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 21
39427: PUSH
39428: LD_INT 3
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: LD_INT 30
39440: PUSH
39441: LD_INT 6
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 30
39450: PUSH
39451: LD_INT 7
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 30
39460: PUSH
39461: LD_INT 8
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: LIST
39478: PPUSH
39479: CALL_OW 69
39483: ST_TO_ADDR
39484: GO 39606
39486: LD_INT 2
39488: DOUBLE
39489: EQUAL
39490: IFTRUE 39494
39492: GO 39571
39494: POP
// list := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 3 :
39495: LD_ADDR_VAR 0 3
39499: PUSH
39500: LD_INT 23
39502: PUSH
39503: LD_INT 3
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 21
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 2
39522: PUSH
39523: LD_INT 30
39525: PUSH
39526: LD_INT 6
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 30
39535: PUSH
39536: LD_INT 7
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 30
39545: PUSH
39546: LD_INT 8
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: LIST
39557: LIST
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: LIST
39563: PPUSH
39564: CALL_OW 69
39568: ST_TO_ADDR
39569: GO 39606
39571: LD_INT 3
39573: DOUBLE
39574: EQUAL
39575: IFTRUE 39579
39577: GO 39605
39579: POP
// list := FilterAllUnits ( [ [ f_btype , b_alien_tower ] ] ) ; end ;
39580: LD_ADDR_VAR 0 3
39584: PUSH
39585: LD_INT 30
39587: PUSH
39588: LD_INT 39
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: EMPTY
39596: LIST
39597: PPUSH
39598: CALL_OW 69
39602: ST_TO_ADDR
39603: GO 39606
39605: POP
// nearest_lab := NearestUnitToXY ( list , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39606: LD_ADDR_VAR 0 9
39610: PUSH
39611: LD_VAR 0 3
39615: PPUSH
39616: LD_VAR 0 8
39620: PUSH
39621: LD_INT 1
39623: ARRAY
39624: PPUSH
39625: LD_VAR 0 8
39629: PUSH
39630: LD_INT 2
39632: ARRAY
39633: PPUSH
39634: CALL_OW 73
39638: ST_TO_ADDR
// dist := GetDistUnitXY ( nearest_lab , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39639: LD_ADDR_VAR 0 6
39643: PUSH
39644: LD_VAR 0 9
39648: PPUSH
39649: LD_VAR 0 8
39653: PUSH
39654: LD_INT 1
39656: ARRAY
39657: PPUSH
39658: LD_VAR 0 8
39662: PUSH
39663: LD_INT 2
39665: ARRAY
39666: PPUSH
39667: CALL_OW 297
39671: ST_TO_ADDR
// if dist < 25 then
39672: LD_VAR 0 6
39676: PUSH
39677: LD_INT 25
39679: LESS
39680: IFFALSE 40045
// begin side := GetSide ( nearest_lab ) ;
39682: LD_ADDR_VAR 0 4
39686: PUSH
39687: LD_VAR 0 9
39691: PPUSH
39692: CALL_OW 255
39696: ST_TO_ADDR
// DeInit_Lab ( side , art ) ;
39697: LD_VAR 0 4
39701: PPUSH
39702: LD_VAR 0 1
39706: PPUSH
39707: CALL 40050 0 2
// base := ( art - 1 ) * 100 ;
39711: LD_ADDR_VAR 0 5
39715: PUSH
39716: LD_VAR 0 1
39720: PUSH
39721: LD_INT 1
39723: MINUS
39724: PUSH
39725: LD_INT 100
39727: MUL
39728: ST_TO_ADDR
// if ( GetTech ( tech_Artifact , side ) = state_researched ) then
39729: LD_INT 24
39731: PPUSH
39732: LD_VAR 0 4
39736: PPUSH
39737: CALL_OW 321
39741: PUSH
39742: LD_INT 2
39744: EQUAL
39745: IFFALSE 39948
// begin if GetTag ( base + side * 10 + 11 ) and UnitsInside ( nearest_lab ) then
39747: LD_VAR 0 5
39751: PUSH
39752: LD_VAR 0 4
39756: PUSH
39757: LD_INT 10
39759: MUL
39760: PLUS
39761: PUSH
39762: LD_INT 11
39764: PLUS
39765: PPUSH
39766: CALL_OW 110
39770: PUSH
39771: LD_VAR 0 9
39775: PPUSH
39776: CALL_OW 313
39780: AND
39781: IFFALSE 39938
// begin if not GetTag ( base + side * 10 + 13 ) then
39783: LD_VAR 0 5
39787: PUSH
39788: LD_VAR 0 4
39792: PUSH
39793: LD_INT 10
39795: MUL
39796: PLUS
39797: PUSH
39798: LD_INT 13
39800: PLUS
39801: PPUSH
39802: CALL_OW 110
39806: NOT
39807: IFFALSE 39830
// state := GetTag ( base + 03 ) else
39809: LD_ADDR_VAR 0 7
39813: PUSH
39814: LD_VAR 0 5
39818: PUSH
39819: LD_INT 3
39821: PLUS
39822: PPUSH
39823: CALL_OW 110
39827: ST_TO_ADDR
39828: GO 39838
// state := art_gray ;
39830: LD_ADDR_VAR 0 7
39834: PUSH
39835: LD_INT 1
39837: ST_TO_ADDR
// if GetTag ( base + side * 10 + 15 ) and ( GetTag ( base + side * 10 + 15 ) <> nearest_lab ) then
39838: LD_VAR 0 5
39842: PUSH
39843: LD_VAR 0 4
39847: PUSH
39848: LD_INT 10
39850: MUL
39851: PLUS
39852: PUSH
39853: LD_INT 15
39855: PLUS
39856: PPUSH
39857: CALL_OW 110
39861: PUSH
39862: LD_VAR 0 5
39866: PUSH
39867: LD_VAR 0 4
39871: PUSH
39872: LD_INT 10
39874: MUL
39875: PLUS
39876: PUSH
39877: LD_INT 15
39879: PLUS
39880: PPUSH
39881: CALL_OW 110
39885: PUSH
39886: LD_VAR 0 9
39890: NONEQUAL
39891: AND
39892: IFFALSE 39908
// DeInit_Lab ( side , art ) ;
39894: LD_VAR 0 4
39898: PPUSH
39899: LD_VAR 0 1
39903: PPUSH
39904: CALL 40050 0 2
// SetTag ( base + side * 10 + 15 , nearest_lab ) ;
39908: LD_VAR 0 5
39912: PUSH
39913: LD_VAR 0 4
39917: PUSH
39918: LD_INT 10
39920: MUL
39921: PLUS
39922: PUSH
39923: LD_INT 15
39925: PLUS
39926: PPUSH
39927: LD_VAR 0 9
39931: PPUSH
39932: CALL_OW 109
// end else
39936: GO 39946
// state := art_instant ;
39938: LD_ADDR_VAR 0 7
39942: PUSH
39943: LD_INT 2
39945: ST_TO_ADDR
// end else
39946: GO 39956
// state := art_gray ;
39948: LD_ADDR_VAR 0 7
39952: PUSH
39953: LD_INT 1
39955: ST_TO_ADDR
// SetTag ( base + 11 , nearest_lab ) ;
39956: LD_VAR 0 5
39960: PUSH
39961: LD_INT 11
39963: PLUS
39964: PPUSH
39965: LD_VAR 0 9
39969: PPUSH
39970: CALL_OW 109
// if not ( nearest_lab in labs_in_use ) then
39974: LD_VAR 0 9
39978: PUSH
39979: LD_EXP 79
39983: IN
39984: NOT
39985: IFFALSE 40045
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , state , nearest_lab ) ;
39987: LD_VAR 0 4
39991: PPUSH
39992: LD_VAR 0 5
39996: PUSH
39997: LD_INT 1
39999: PLUS
40000: PUSH
40001: LD_VAR 0 5
40005: PUSH
40006: LD_VAR 0 4
40010: PUSH
40011: LD_INT 10
40013: MUL
40014: PLUS
40015: PUSH
40016: LD_INT 11
40018: PLUS
40019: PPUSH
40020: CALL_OW 110
40024: PLUS
40025: PPUSH
40026: CALL_OW 110
40030: PPUSH
40031: LD_VAR 0 7
40035: PPUSH
40036: LD_VAR 0 9
40040: PPUSH
40041: CALL_OW 468
// end ; end ;
40045: LD_VAR 0 2
40049: RET
// export function DeInit_Lab ( side , art ) ; var base , lab ; begin
40050: LD_INT 0
40052: PPUSH
40053: PPUSH
40054: PPUSH
// base := ( art - 1 ) * 100 ;
40055: LD_ADDR_VAR 0 4
40059: PUSH
40060: LD_VAR 0 2
40064: PUSH
40065: LD_INT 1
40067: MINUS
40068: PUSH
40069: LD_INT 100
40071: MUL
40072: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
40073: LD_ADDR_VAR 0 5
40077: PUSH
40078: LD_VAR 0 4
40082: PUSH
40083: LD_VAR 0 1
40087: PUSH
40088: LD_INT 10
40090: MUL
40091: PLUS
40092: PUSH
40093: LD_INT 15
40095: PLUS
40096: PPUSH
40097: CALL_OW 110
40101: ST_TO_ADDR
// if not lab then
40102: LD_VAR 0 5
40106: NOT
40107: IFFALSE 40128
// lab := GetTag ( base + 11 ) ;
40109: LD_ADDR_VAR 0 5
40113: PUSH
40114: LD_VAR 0 4
40118: PUSH
40119: LD_INT 11
40121: PLUS
40122: PPUSH
40123: CALL_OW 110
40127: ST_TO_ADDR
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_no , lab ) ;
40128: LD_VAR 0 1
40132: PPUSH
40133: LD_VAR 0 4
40137: PUSH
40138: LD_INT 1
40140: PLUS
40141: PUSH
40142: LD_VAR 0 4
40146: PUSH
40147: LD_VAR 0 1
40151: PUSH
40152: LD_INT 10
40154: MUL
40155: PLUS
40156: PUSH
40157: LD_INT 11
40159: PLUS
40160: PPUSH
40161: CALL_OW 110
40165: PLUS
40166: PPUSH
40167: CALL_OW 110
40171: PPUSH
40172: LD_INT 0
40174: PPUSH
40175: LD_VAR 0 5
40179: PPUSH
40180: CALL_OW 468
// end ;
40184: LD_VAR 0 3
40188: RET
// export function Update_Artefact ( lab ) ; var art , side , base ; begin
40189: LD_INT 0
40191: PPUSH
40192: PPUSH
40193: PPUSH
40194: PPUSH
// side := GetSide ( lab ) ;
40195: LD_ADDR_VAR 0 4
40199: PUSH
40200: LD_VAR 0 1
40204: PPUSH
40205: CALL_OW 255
40209: ST_TO_ADDR
// for art = 1 to artefact_number do
40210: LD_ADDR_VAR 0 3
40214: PUSH
40215: DOUBLE
40216: LD_INT 1
40218: DEC
40219: ST_TO_ADDR
40220: LD_EXP 76
40224: PUSH
40225: FOR_TO
40226: IFFALSE 40382
// begin base := ( art - 1 ) * 100 ;
40228: LD_ADDR_VAR 0 5
40232: PUSH
40233: LD_VAR 0 3
40237: PUSH
40238: LD_INT 1
40240: MINUS
40241: PUSH
40242: LD_INT 100
40244: MUL
40245: ST_TO_ADDR
// if GetTag ( base + 11 ) = lab then
40246: LD_VAR 0 5
40250: PUSH
40251: LD_INT 11
40253: PLUS
40254: PPUSH
40255: CALL_OW 110
40259: PUSH
40260: LD_VAR 0 1
40264: EQUAL
40265: IFFALSE 40278
// Init_Lab ( art ) else
40267: LD_VAR 0 3
40271: PPUSH
40272: CALL 39356 0 1
40276: GO 40380
// begin if lab = GetTag ( base + side * 10 + 15 ) then
40278: LD_VAR 0 1
40282: PUSH
40283: LD_VAR 0 5
40287: PUSH
40288: LD_VAR 0 4
40292: PUSH
40293: LD_INT 10
40295: MUL
40296: PLUS
40297: PUSH
40298: LD_INT 15
40300: PLUS
40301: PPUSH
40302: CALL_OW 110
40306: EQUAL
40307: IFFALSE 40380
// begin if ( GetTag ( base + side * 10 + 13 ) > 0 ) or ( not UnitsInside ( lab ) ) then
40309: LD_VAR 0 5
40313: PUSH
40314: LD_VAR 0 4
40318: PUSH
40319: LD_INT 10
40321: MUL
40322: PLUS
40323: PUSH
40324: LD_INT 13
40326: PLUS
40327: PPUSH
40328: CALL_OW 110
40332: PUSH
40333: LD_INT 0
40335: GREATER
40336: PUSH
40337: LD_VAR 0 1
40341: PPUSH
40342: CALL_OW 313
40346: NOT
40347: OR
40348: IFFALSE 40366
// Shadow_Artefact ( side , art ) else
40350: LD_VAR 0 4
40354: PPUSH
40355: LD_VAR 0 3
40359: PPUSH
40360: CALL 39070 0 2
40364: GO 40380
// Highlight_Artefact ( side , art ) ;
40366: LD_VAR 0 4
40370: PPUSH
40371: LD_VAR 0 3
40375: PPUSH
40376: CALL 39202 0 2
// end ; end ; end ;
40380: GO 40225
40382: POP
40383: POP
// end ;
40384: LD_VAR 0 2
40388: RET
// every 0 0$2 marked 20 do var list , lab ;
40389: GO 40391
40391: DISABLE
40392: LD_INT 0
40394: PPUSH
40395: PPUSH
// begin list := FilterAllUnits ( [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_alien_tower ] ] ] ) ;
40396: LD_ADDR_VAR 0 1
40400: PUSH
40401: LD_INT 2
40403: PUSH
40404: LD_INT 30
40406: PUSH
40407: LD_INT 6
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 30
40416: PUSH
40417: LD_INT 7
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 30
40426: PUSH
40427: LD_INT 8
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 30
40436: PUSH
40437: LD_INT 39
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: PUSH
40451: EMPTY
40452: LIST
40453: PPUSH
40454: CALL_OW 69
40458: ST_TO_ADDR
// for lab in list do
40459: LD_ADDR_VAR 0 2
40463: PUSH
40464: LD_VAR 0 1
40468: PUSH
40469: FOR_IN
40470: IFFALSE 40483
// Update_Artefact ( lab ) ;
40472: LD_VAR 0 2
40476: PPUSH
40477: CALL 40189 0 1
40481: GO 40469
40483: POP
40484: POP
// enable ;
40485: ENABLE
// end ; end_of_file
40486: PPOPN 2
40488: END
// var view_data , human_changed ; export function Show_me_map ( side , x , y ) ; var vysledek , station ; begin
40489: LD_INT 0
40491: PPUSH
40492: PPUSH
40493: PPUSH
// vysledek := true ;
40494: LD_ADDR_VAR 0 5
40498: PUSH
40499: LD_INT 1
40501: ST_TO_ADDR
// station := GetBase ( GetTag ( side * 10 + 15 ) ) ;
40502: LD_ADDR_VAR 0 6
40506: PUSH
40507: LD_VAR 0 1
40511: PUSH
40512: LD_INT 10
40514: MUL
40515: PUSH
40516: LD_INT 15
40518: PLUS
40519: PPUSH
40520: CALL_OW 110
40524: PPUSH
40525: CALL_OW 274
40529: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 06 ) ) then
40530: LD_VAR 0 6
40534: PUSH
40535: LD_VAR 0 6
40539: PPUSH
40540: CALL_OW 279
40544: PUSH
40545: LD_INT 3
40547: ARRAY
40548: PUSH
40549: LD_INT 6
40551: PPUSH
40552: CALL_OW 110
40556: GREATEREQUAL
40557: AND
40558: IFFALSE 40648
// begin PlaceSeeing ( x , y , side , - 15 ) ;
40560: LD_VAR 0 2
40564: PPUSH
40565: LD_VAR 0 3
40569: PPUSH
40570: LD_VAR 0 1
40574: PPUSH
40575: LD_INT 15
40577: NEG
40578: PPUSH
40579: CALL_OW 330
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 06 ) ) ;
40583: LD_VAR 0 6
40587: PPUSH
40588: LD_INT 3
40590: PPUSH
40591: LD_VAR 0 6
40595: PPUSH
40596: CALL_OW 279
40600: PUSH
40601: LD_INT 3
40603: ARRAY
40604: PUSH
40605: LD_INT 6
40607: PPUSH
40608: CALL_OW 110
40612: MINUS
40613: PPUSH
40614: CALL_OW 277
// view_data := [ x , y , side ] ;
40618: LD_ADDR_LOC 81
40622: PUSH
40623: LD_VAR 0 2
40627: PUSH
40628: LD_VAR 0 3
40632: PUSH
40633: LD_VAR 0 1
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: LIST
40642: ST_TO_ADDR
// enable ( 111 ) ;
40643: LD_INT 111
40645: ENABLE_MARKED
// end else
40646: GO 40656
// vysledek := false ;
40648: LD_ADDR_VAR 0 5
40652: PUSH
40653: LD_INT 0
40655: ST_TO_ADDR
// result := vysledek ;
40656: LD_ADDR_VAR 0 4
40660: PUSH
40661: LD_VAR 0 5
40665: ST_TO_ADDR
// end ;
40666: LD_VAR 0 4
40670: RET
// every 0 0$2.8 trigger view_data marked 111 do
40671: LD_LOC 81
40675: IFFALSE 40726
40677: GO 40679
40679: DISABLE
// begin wait ( 0 0$30 ) ;
40680: LD_INT 1050
40682: PPUSH
40683: CALL_OW 67
// RemoveSeeing ( view_data [ 1 ] , view_data [ 2 ] , view_data [ 3 ] ) ;
40687: LD_LOC 81
40691: PUSH
40692: LD_INT 1
40694: ARRAY
40695: PPUSH
40696: LD_LOC 81
40700: PUSH
40701: LD_INT 2
40703: ARRAY
40704: PPUSH
40705: LD_LOC 81
40709: PUSH
40710: LD_INT 3
40712: ARRAY
40713: PPUSH
40714: CALL_OW 331
// view_data := 0 ;
40718: LD_ADDR_LOC 81
40722: PUSH
40723: LD_INT 0
40725: ST_TO_ADDR
// end ;
40726: END
// export function Destroy_siberite ( side , un ) ; var vysledek , station , v_can , b_can , it_can , building_list , vehicle_list ; begin
40727: LD_INT 0
40729: PPUSH
40730: PPUSH
40731: PPUSH
40732: PPUSH
40733: PPUSH
40734: PPUSH
40735: PPUSH
40736: PPUSH
// vysledek := true ;
40737: LD_ADDR_VAR 0 4
40741: PUSH
40742: LD_INT 1
40744: ST_TO_ADDR
// it_can := false ;
40745: LD_ADDR_VAR 0 8
40749: PUSH
40750: LD_INT 0
40752: ST_TO_ADDR
// building_list := [ b_siberite_mine , b_siberite_power ] ;
40753: LD_ADDR_VAR 0 9
40757: PUSH
40758: LD_INT 30
40760: PUSH
40761: LD_INT 28
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: ST_TO_ADDR
// vehicle_list := [ us_siberium_rocket , ru_siberium_rocket , ar_selfpropelled_bomb , ru_time_lapser , us_double_laser ] ;
40768: LD_ADDR_VAR 0 10
40772: PUSH
40773: LD_INT 8
40775: PUSH
40776: LD_INT 48
40778: PUSH
40779: LD_INT 29
40781: PUSH
40782: LD_INT 49
40784: PUSH
40785: LD_INT 10
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: ST_TO_ADDR
// b_can := ( GetType ( un ) = unit_building ) and ( ( GetBType ( un ) in building_list ) or ( GetBWeapon ( un ) in vehicle_list ) ) ;
40795: LD_ADDR_VAR 0 7
40799: PUSH
40800: LD_VAR 0 2
40804: PPUSH
40805: CALL_OW 247
40809: PUSH
40810: LD_INT 3
40812: EQUAL
40813: PUSH
40814: LD_VAR 0 2
40818: PPUSH
40819: CALL_OW 266
40823: PUSH
40824: LD_VAR 0 9
40828: IN
40829: PUSH
40830: LD_VAR 0 2
40834: PPUSH
40835: CALL_OW 269
40839: PUSH
40840: LD_VAR 0 10
40844: IN
40845: OR
40846: AND
40847: ST_TO_ADDR
// v_can := ( GetType ( un ) = unit_vehicle ) and ( ( GetWeapon ( un ) in vehicle_list ) or ( GetEngine ( un ) = engine_siberite ) ) ;
40848: LD_ADDR_VAR 0 6
40852: PUSH
40853: LD_VAR 0 2
40857: PPUSH
40858: CALL_OW 247
40862: PUSH
40863: LD_INT 2
40865: EQUAL
40866: PUSH
40867: LD_VAR 0 2
40871: PPUSH
40872: CALL_OW 264
40876: PUSH
40877: LD_VAR 0 10
40881: IN
40882: PUSH
40883: LD_VAR 0 2
40887: PPUSH
40888: CALL_OW 262
40892: PUSH
40893: LD_INT 3
40895: EQUAL
40896: OR
40897: AND
40898: ST_TO_ADDR
// it_can := b_can or v_can ;
40899: LD_ADDR_VAR 0 8
40903: PUSH
40904: LD_VAR 0 7
40908: PUSH
40909: LD_VAR 0 6
40913: OR
40914: ST_TO_ADDR
// station := GetBase ( GetTag ( 100 + side * 10 + 15 ) ) ;
40915: LD_ADDR_VAR 0 5
40919: PUSH
40920: LD_INT 100
40922: PUSH
40923: LD_VAR 0 1
40927: PUSH
40928: LD_INT 10
40930: MUL
40931: PLUS
40932: PUSH
40933: LD_INT 15
40935: PLUS
40936: PPUSH
40937: CALL_OW 110
40941: PPUSH
40942: CALL_OW 274
40946: ST_TO_ADDR
// if station and it_can and ( GetResources ( station ) [ 3 ] >= GetTag ( 106 ) ) then
40947: LD_VAR 0 5
40951: PUSH
40952: LD_VAR 0 8
40956: AND
40957: PUSH
40958: LD_VAR 0 5
40962: PPUSH
40963: CALL_OW 279
40967: PUSH
40968: LD_INT 3
40970: ARRAY
40971: PUSH
40972: LD_INT 106
40974: PPUSH
40975: CALL_OW 110
40979: GREATEREQUAL
40980: AND
40981: IFFALSE 41029
// begin KillUnit ( un ) ;
40983: LD_VAR 0 2
40987: PPUSH
40988: CALL_OW 66
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 106 ) ) ;
40992: LD_VAR 0 5
40996: PPUSH
40997: LD_INT 3
40999: PPUSH
41000: LD_VAR 0 5
41004: PPUSH
41005: CALL_OW 279
41009: PUSH
41010: LD_INT 3
41012: ARRAY
41013: PUSH
41014: LD_INT 106
41016: PPUSH
41017: CALL_OW 110
41021: MINUS
41022: PPUSH
41023: CALL_OW 277
// end else
41027: GO 41037
// vysledek := false ;
41029: LD_ADDR_VAR 0 4
41033: PUSH
41034: LD_INT 0
41036: ST_TO_ADDR
// result := vysledek ;
41037: LD_ADDR_VAR 0 3
41041: PUSH
41042: LD_VAR 0 4
41046: ST_TO_ADDR
// end ;
41047: LD_VAR 0 3
41051: RET
// export function Mass_Teleport ( side , x , y ) ; var vysledek , station , list , un ; begin
41052: LD_INT 0
41054: PPUSH
41055: PPUSH
41056: PPUSH
41057: PPUSH
41058: PPUSH
// vysledek := true ;
41059: LD_ADDR_VAR 0 5
41063: PUSH
41064: LD_INT 1
41066: ST_TO_ADDR
// station := GetBase ( GetTag ( 200 + side * 10 + 15 ) ) ;
41067: LD_ADDR_VAR 0 6
41071: PUSH
41072: LD_INT 200
41074: PUSH
41075: LD_VAR 0 1
41079: PUSH
41080: LD_INT 10
41082: MUL
41083: PLUS
41084: PUSH
41085: LD_INT 15
41087: PLUS
41088: PPUSH
41089: CALL_OW 110
41093: PPUSH
41094: CALL_OW 274
41098: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 206 ) ) then
41099: LD_VAR 0 6
41103: PUSH
41104: LD_VAR 0 6
41108: PPUSH
41109: CALL_OW 279
41113: PUSH
41114: LD_INT 3
41116: ARRAY
41117: PUSH
41118: LD_INT 206
41120: PPUSH
41121: CALL_OW 110
41125: GREATEREQUAL
41126: AND
41127: IFFALSE 41310
// begin SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 206 ) ) ;
41129: LD_VAR 0 6
41133: PPUSH
41134: LD_INT 3
41136: PPUSH
41137: LD_VAR 0 6
41141: PPUSH
41142: CALL_OW 279
41146: PUSH
41147: LD_INT 3
41149: ARRAY
41150: PUSH
41151: LD_INT 206
41153: PPUSH
41154: CALL_OW 110
41158: MINUS
41159: PPUSH
41160: CALL_OW 277
// SetAreaMapShow ( teleport_area , 1 ) ;
41164: LD_INT 24
41166: PPUSH
41167: LD_INT 1
41169: PPUSH
41170: CALL_OW 424
// for un = 1 to 11 do
41174: LD_ADDR_VAR 0 8
41178: PUSH
41179: DOUBLE
41180: LD_INT 1
41182: DEC
41183: ST_TO_ADDR
41184: LD_INT 11
41186: PUSH
41187: FOR_TO
41188: IFFALSE 41216
// begin display_strings := [ ( 11 - un ) ] ;
41190: LD_ADDR_OWVAR 47
41194: PUSH
41195: LD_INT 11
41197: PUSH
41198: LD_VAR 0 8
41202: MINUS
41203: PUSH
41204: EMPTY
41205: LIST
41206: ST_TO_ADDR
// wait ( 0 0$1 ) ;
41207: LD_INT 35
41209: PPUSH
41210: CALL_OW 67
// end ;
41214: GO 41187
41216: POP
41217: POP
// display_strings :=  ;
41218: LD_ADDR_OWVAR 47
41222: PUSH
41223: LD_STRING 
41225: ST_TO_ADDR
// SetAreaMapShow ( teleport_area , 0 ) ;
41226: LD_INT 24
41228: PPUSH
41229: LD_INT 0
41231: PPUSH
41232: CALL_OW 424
// list := FilterUnitsInArea ( teleport_area , [ f_not , [ f_type , unit_building ] ] ) ;
41236: LD_ADDR_VAR 0 7
41240: PUSH
41241: LD_INT 24
41243: PPUSH
41244: LD_INT 3
41246: PUSH
41247: LD_INT 21
41249: PUSH
41250: LD_INT 3
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PPUSH
41261: CALL_OW 70
41265: ST_TO_ADDR
// for un in list do
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_VAR 0 7
41275: PUSH
41276: FOR_IN
41277: IFFALSE 41306
// TeleportUnit ( un , x , y , 12 , true ) ;
41279: LD_VAR 0 8
41283: PPUSH
41284: LD_VAR 0 2
41288: PPUSH
41289: LD_VAR 0 3
41293: PPUSH
41294: LD_INT 12
41296: PPUSH
41297: LD_INT 1
41299: PPUSH
41300: CALL_OW 483
41304: GO 41276
41306: POP
41307: POP
// end else
41308: GO 41318
// vysledek := false ;
41310: LD_ADDR_VAR 0 5
41314: PUSH
41315: LD_INT 0
41317: ST_TO_ADDR
// result := vysledek ;
41318: LD_ADDR_VAR 0 4
41322: PUSH
41323: LD_VAR 0 5
41327: ST_TO_ADDR
// end ;
41328: LD_VAR 0 4
41332: RET
// every 0 0$5 marked 20 do var art , side , recharge ;
41333: GO 41335
41335: DISABLE
41336: LD_INT 0
41338: PPUSH
41339: PPUSH
41340: PPUSH
// begin side := you ;
41341: LD_ADDR_VAR 0 2
41345: PUSH
41346: LD_EXP 1
41350: ST_TO_ADDR
// for art = 0 to artefact_number do
41351: LD_ADDR_VAR 0 1
41355: PUSH
41356: DOUBLE
41357: LD_INT 0
41359: DEC
41360: ST_TO_ADDR
41361: LD_EXP 76
41365: PUSH
41366: FOR_TO
41367: IFFALSE 41467
// begin recharge := art * 100 + side * 10 + 13 ;
41369: LD_ADDR_VAR 0 3
41373: PUSH
41374: LD_VAR 0 1
41378: PUSH
41379: LD_INT 100
41381: MUL
41382: PUSH
41383: LD_VAR 0 2
41387: PUSH
41388: LD_INT 10
41390: MUL
41391: PLUS
41392: PUSH
41393: LD_INT 13
41395: PLUS
41396: ST_TO_ADDR
// if GetTag ( recharge ) > 0 then
41397: LD_VAR 0 3
41401: PPUSH
41402: CALL_OW 110
41406: PUSH
41407: LD_INT 0
41409: GREATER
41410: IFFALSE 41465
// begin SetTag ( recharge , GetTag ( recharge ) - 1 ) ;
41412: LD_VAR 0 3
41416: PPUSH
41417: LD_VAR 0 3
41421: PPUSH
41422: CALL_OW 110
41426: PUSH
41427: LD_INT 1
41429: MINUS
41430: PPUSH
41431: CALL_OW 109
// if not GetTag ( recharge ) then
41435: LD_VAR 0 3
41439: PPUSH
41440: CALL_OW 110
41444: NOT
41445: IFFALSE 41465
// Highlight_Artefact ( side , art + 1 ) ;
41447: LD_VAR 0 2
41451: PPUSH
41452: LD_VAR 0 1
41456: PUSH
41457: LD_INT 1
41459: PLUS
41460: PPUSH
41461: CALL 39202 0 2
// end ; end ;
41465: GO 41366
41467: POP
41468: POP
// enable ;
41469: ENABLE
// end ; end_of_file
41470: PPOPN 3
41472: END
// var us_fort , ru_fort ; var us_place , ru_place ; every 0 0$11 do var side , un , list ;
41473: GO 41475
41475: DISABLE
41476: LD_INT 0
41478: PPUSH
41479: PPUSH
41480: PPUSH
// begin us_fort := [ ] ;
41481: LD_ADDR_LOC 83
41485: PUSH
41486: EMPTY
41487: ST_TO_ADDR
// ru_fort := [ ] ;
41488: LD_ADDR_LOC 84
41492: PUSH
41493: EMPTY
41494: ST_TO_ADDR
// for side in ( cpu_list diff ar ) do
41495: LD_ADDR_VAR 0 1
41499: PUSH
41500: LD_EXP 8
41504: PUSH
41505: LD_EXP 4
41509: DIFF
41510: PUSH
41511: FOR_IN
41512: IFFALSE 41717
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
41514: LD_ADDR_VAR 0 3
41518: PUSH
41519: LD_INT 22
41521: PUSH
41522: LD_VAR 0 1
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 2
41533: PUSH
41534: LD_INT 30
41536: PUSH
41537: LD_INT 32
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 30
41546: PUSH
41547: LD_INT 33
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: LIST
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PPUSH
41563: CALL_OW 69
41567: ST_TO_ADDR
// for un in list do
41568: LD_ADDR_VAR 0 2
41572: PUSH
41573: LD_VAR 0 3
41577: PUSH
41578: FOR_IN
41579: IFFALSE 41713
// case side of us :
41581: LD_VAR 0 1
41585: PUSH
41586: LD_EXP 3
41590: DOUBLE
41591: EQUAL
41592: IFTRUE 41596
41594: GO 41648
41596: POP
// us_fort := us_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; ru :
41597: LD_ADDR_LOC 83
41601: PUSH
41602: LD_LOC 83
41606: PUSH
41607: LD_VAR 0 2
41611: PPUSH
41612: CALL_OW 250
41616: PUSH
41617: LD_VAR 0 2
41621: PPUSH
41622: CALL_OW 251
41626: PUSH
41627: LD_VAR 0 2
41631: PPUSH
41632: CALL_OW 269
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: LIST
41641: PUSH
41642: EMPTY
41643: LIST
41644: ADD
41645: ST_TO_ADDR
41646: GO 41711
41648: LD_EXP 2
41652: DOUBLE
41653: EQUAL
41654: IFTRUE 41658
41656: GO 41710
41658: POP
// ru_fort := ru_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; end ;
41659: LD_ADDR_LOC 84
41663: PUSH
41664: LD_LOC 84
41668: PUSH
41669: LD_VAR 0 2
41673: PPUSH
41674: CALL_OW 250
41678: PUSH
41679: LD_VAR 0 2
41683: PPUSH
41684: CALL_OW 251
41688: PUSH
41689: LD_VAR 0 2
41693: PPUSH
41694: CALL_OW 269
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: LIST
41703: PUSH
41704: EMPTY
41705: LIST
41706: ADD
41707: ST_TO_ADDR
41708: GO 41711
41710: POP
41711: GO 41578
41713: POP
41714: POP
// end ;
41715: GO 41511
41717: POP
41718: POP
// end ;
41719: PPOPN 3
41721: END
// every 0 0$10.5 do var un , w , x , y , list ;
41722: GO 41724
41724: DISABLE
41725: LD_INT 0
41727: PPUSH
41728: PPUSH
41729: PPUSH
41730: PPUSH
41731: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_heavy_gun ] , [ f_bweapon , us_radar ] , [ f_bweapon , us_double_laser ] ] ] ) ;
41732: LD_ADDR_VAR 0 5
41736: PUSH
41737: LD_INT 22
41739: PUSH
41740: LD_EXP 3
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 2
41751: PUSH
41752: LD_INT 30
41754: PUSH
41755: LD_INT 32
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 30
41764: PUSH
41765: LD_INT 33
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: LIST
41776: PUSH
41777: LD_INT 57
41779: PUSH
41780: EMPTY
41781: LIST
41782: PUSH
41783: LD_INT 3
41785: PUSH
41786: LD_INT 2
41788: PUSH
41789: LD_INT 35
41791: PUSH
41792: LD_INT 7
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 35
41801: PUSH
41802: LD_INT 6
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 35
41811: PUSH
41812: LD_INT 11
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 35
41821: PUSH
41822: LD_INT 10
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: LIST
41833: LIST
41834: LIST
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: LIST
41840: LIST
41841: LIST
41842: PPUSH
41843: CALL_OW 69
41847: ST_TO_ADDR
// for un in list do
41848: LD_ADDR_VAR 0 1
41852: PUSH
41853: LD_VAR 0 5
41857: PUSH
41858: FOR_IN
41859: IFFALSE 41974
// begin x := GetX ( un ) ;
41861: LD_ADDR_VAR 0 3
41865: PUSH
41866: LD_VAR 0 1
41870: PPUSH
41871: CALL_OW 250
41875: ST_TO_ADDR
// y := GetY ( un ) ;
41876: LD_ADDR_VAR 0 4
41880: PUSH
41881: LD_VAR 0 1
41885: PPUSH
41886: CALL_OW 251
41890: ST_TO_ADDR
// for w in us_fort do
41891: LD_ADDR_VAR 0 2
41895: PUSH
41896: LD_LOC 83
41900: PUSH
41901: FOR_IN
41902: IFFALSE 41963
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
41904: LD_VAR 0 3
41908: PUSH
41909: LD_VAR 0 2
41913: PUSH
41914: LD_INT 1
41916: ARRAY
41917: EQUAL
41918: PUSH
41919: LD_VAR 0 4
41923: PUSH
41924: LD_VAR 0 2
41928: PUSH
41929: LD_INT 2
41931: ARRAY
41932: EQUAL
41933: AND
41934: IFFALSE 41954
// ComPlaceWeapon ( un , w [ 3 ] ) ;
41936: LD_VAR 0 1
41940: PPUSH
41941: LD_VAR 0 2
41945: PUSH
41946: LD_INT 3
41948: ARRAY
41949: PPUSH
41950: CALL_OW 148
// wait ( 8 ) ;
41954: LD_INT 8
41956: PPUSH
41957: CALL_OW 67
// end ;
41961: GO 41901
41963: POP
41964: POP
// wait ( 27 ) ;
41965: LD_INT 27
41967: PPUSH
41968: CALL_OW 67
// end ;
41972: GO 41858
41974: POP
41975: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
41976: LD_INT 175
41978: PPUSH
41979: LD_INT 350
41981: PPUSH
41982: CALL_OW 12
41986: PPUSH
41987: CALL_OW 67
// enable ;
41991: ENABLE
// end ;
41992: PPOPN 5
41994: END
// every 0 0$10.7 do var un , w , x , y , list ;
41995: GO 41997
41997: DISABLE
41998: LD_INT 0
42000: PPUSH
42001: PPUSH
42002: PPUSH
42003: PPUSH
42004: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , ru_rocket ] , [ f_bweapon , ru_heavy_gun ] , [ f_bweapon , ru_time_lapser ] , [ f_bweapon , ru_gatling_gun ] ] ] ) ;
42005: LD_ADDR_VAR 0 5
42009: PUSH
42010: LD_INT 22
42012: PUSH
42013: LD_EXP 2
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 2
42024: PUSH
42025: LD_INT 30
42027: PUSH
42028: LD_INT 32
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 30
42037: PUSH
42038: LD_INT 33
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 57
42052: PUSH
42053: EMPTY
42054: LIST
42055: PUSH
42056: LD_INT 3
42058: PUSH
42059: LD_INT 2
42061: PUSH
42062: LD_INT 35
42064: PUSH
42065: LD_INT 47
42067: PUSH
42068: EMPTY
42069: LIST
42070: LIST
42071: PUSH
42072: LD_INT 35
42074: PUSH
42075: LD_INT 46
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 35
42084: PUSH
42085: LD_INT 49
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: LD_INT 35
42094: PUSH
42095: LD_INT 43
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: PPUSH
42116: CALL_OW 69
42120: ST_TO_ADDR
// for un in list do
42121: LD_ADDR_VAR 0 1
42125: PUSH
42126: LD_VAR 0 5
42130: PUSH
42131: FOR_IN
42132: IFFALSE 42247
// begin x := GetX ( un ) ;
42134: LD_ADDR_VAR 0 3
42138: PUSH
42139: LD_VAR 0 1
42143: PPUSH
42144: CALL_OW 250
42148: ST_TO_ADDR
// y := GetY ( un ) ;
42149: LD_ADDR_VAR 0 4
42153: PUSH
42154: LD_VAR 0 1
42158: PPUSH
42159: CALL_OW 251
42163: ST_TO_ADDR
// for w in ru_fort do
42164: LD_ADDR_VAR 0 2
42168: PUSH
42169: LD_LOC 84
42173: PUSH
42174: FOR_IN
42175: IFFALSE 42236
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42177: LD_VAR 0 3
42181: PUSH
42182: LD_VAR 0 2
42186: PUSH
42187: LD_INT 1
42189: ARRAY
42190: EQUAL
42191: PUSH
42192: LD_VAR 0 4
42196: PUSH
42197: LD_VAR 0 2
42201: PUSH
42202: LD_INT 2
42204: ARRAY
42205: EQUAL
42206: AND
42207: IFFALSE 42227
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42209: LD_VAR 0 1
42213: PPUSH
42214: LD_VAR 0 2
42218: PUSH
42219: LD_INT 3
42221: ARRAY
42222: PPUSH
42223: CALL_OW 148
// wait ( 8 ) ;
42227: LD_INT 8
42229: PPUSH
42230: CALL_OW 67
// end ;
42234: GO 42174
42236: POP
42237: POP
// wait ( 27 ) ;
42238: LD_INT 27
42240: PPUSH
42241: CALL_OW 67
// end ;
42245: GO 42131
42247: POP
42248: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42249: LD_INT 175
42251: PPUSH
42252: LD_INT 350
42254: PPUSH
42255: CALL_OW 12
42259: PPUSH
42260: CALL_OW 67
// enable ;
42264: ENABLE
// end ; end_of_file
42265: PPOPN 5
42267: END
// every 0 0$2 + 0 0$0.1 do
42268: GO 42270
42270: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
42271: LD_INT 22
42273: PUSH
42274: LD_INT 7
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 2
42283: PUSH
42284: LD_INT 25
42286: PUSH
42287: LD_INT 12
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 25
42296: PUSH
42297: LD_INT 16
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 25
42306: PUSH
42307: LD_INT 15
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 25
42316: PUSH
42317: LD_INT 17
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PPUSH
42335: CALL_OW 69
42339: PUSH
42340: LD_INT 22
42342: PUSH
42343: LD_INT 7
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 21
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 3
42362: PUSH
42363: LD_INT 2
42365: PUSH
42366: LD_INT 25
42368: PUSH
42369: LD_INT 12
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 25
42378: PUSH
42379: LD_INT 16
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 25
42388: PUSH
42389: LD_INT 15
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 25
42398: PUSH
42399: LD_INT 17
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: LIST
42421: PPUSH
42422: CALL_OW 69
42426: GREATER
42427: IFFALSE 42438
// begin SetAchievement ( ACH_POTA ) ;
42429: LD_STRING ACH_POTA
42431: PPUSH
42432: CALL_OW 543
// exit ;
42436: GO 42439
// end ; enable ;
42438: ENABLE
// end ;
42439: END
// export function SA_OnMissionComplete ; begin
42440: LD_INT 0
42442: PPUSH
// SetAchievement ( ACH_FBF ) ;
42443: LD_STRING ACH_FBF
42445: PPUSH
42446: CALL_OW 543
// end ; end_of_file
42450: LD_VAR 0 1
42454: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
42455: LD_INT 0
42457: PPUSH
42458: PPUSH
// if not missionNumber then
42459: LD_VAR 0 2
42463: NOT
42464: IFFALSE 42468
// exit ;
42466: GO 42588
// achiv := false ;
42468: LD_ADDR_VAR 0 7
42472: PUSH
42473: LD_INT 0
42475: ST_TO_ADDR
// case campaignNumber of 1 :
42476: LD_VAR 0 1
42480: PUSH
42481: LD_INT 1
42483: DOUBLE
42484: EQUAL
42485: IFTRUE 42489
42487: GO 42500
42489: POP
// achiv := ACH_GOTA ; 2 :
42490: LD_ADDR_VAR 0 7
42494: PUSH
42495: LD_STRING ACH_GOTA
42497: ST_TO_ADDR
42498: GO 42550
42500: LD_INT 2
42502: DOUBLE
42503: EQUAL
42504: IFTRUE 42508
42506: GO 42511
42508: POP
// ; 3 :
42509: GO 42550
42511: LD_INT 3
42513: DOUBLE
42514: EQUAL
42515: IFTRUE 42519
42517: GO 42530
42519: POP
// achiv := ACH_MOTSU ; 4 :
42520: LD_ADDR_VAR 0 7
42524: PUSH
42525: LD_STRING ACH_MOTSU
42527: ST_TO_ADDR
42528: GO 42550
42530: LD_INT 4
42532: DOUBLE
42533: EQUAL
42534: IFTRUE 42538
42536: GO 42549
42538: POP
// achiv := ACH_LOP ; end ;
42539: LD_ADDR_VAR 0 7
42543: PUSH
42544: LD_STRING ACH_LOP
42546: ST_TO_ADDR
42547: GO 42550
42549: POP
// if achiv and medal1 and medal2 and medal3 then
42550: LD_VAR 0 7
42554: PUSH
42555: LD_VAR 0 3
42559: AND
42560: PUSH
42561: LD_VAR 0 4
42565: AND
42566: PUSH
42567: LD_VAR 0 5
42571: AND
42572: IFFALSE 42588
// SetAchievementEX ( achiv , missionNumber ) ;
42574: LD_VAR 0 7
42578: PPUSH
42579: LD_VAR 0 2
42583: PPUSH
42584: CALL_OW 564
// end ;
42588: LD_VAR 0 6
42592: RET

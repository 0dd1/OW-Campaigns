// export you , ru , us , ar , ar_al , neutral , camp ; export cpu_list ; export ru_nation , us_nation , ar_nation ; export Burlak , MacMillan , Roth , Gossudarov ; export Petrosyan , Belkov , Kirilenkova , Gnyevko , Gladkov , Dolgov , Gleb , Kapitsova , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Bystrov , Lipshchin , Fadeev ; export Bobby , Brown , Cornell , Connie , Cyrus , Denis , Donaldson , Frank , Gary , Gladstone , Joan , Lisa , Peterson , Simms , VanHouten , Yamoko , others ; export Omar , OmarKilled , NegotiationOffered , OmarWillTryContaminateMotherlode ; export Powell , Platonov ; export aliance_forces ; export finalize ; export prefered_control ; export siberite_rocket_send ; function prepare_us_units ; begin
   0: LD_INT 0
   2: PPUSH
// Powell := NewCharacter ( Powell ) ;
   3: LD_ADDR_EXP 56
   7: PUSH
   8: LD_STRING Powell
  10: PPUSH
  11: CALL_OW 25
  15: ST_TO_ADDR
// SetSide ( Powell , us ) ;
  16: LD_EXP 56
  20: PPUSH
  21: LD_EXP 3
  25: PPUSH
  26: CALL_OW 235
// end ;
  30: LD_VAR 0 1
  34: RET
// function prepare_ru_units ; begin
  35: LD_INT 0
  37: PPUSH
// Platonov := NewCharacter ( Platonov ) ;
  38: LD_ADDR_EXP 57
  42: PUSH
  43: LD_STRING Platonov
  45: PPUSH
  46: CALL_OW 25
  50: ST_TO_ADDR
// SetSide ( Platonov , ru ) ;
  51: LD_EXP 57
  55: PPUSH
  56: LD_EXP 2
  60: PPUSH
  61: CALL_OW 235
// end ;
  65: LD_VAR 0 1
  69: RET
// function prepare_ar_units ; begin
  70: LD_INT 0
  72: PPUSH
// OmarWillTryContaminateMotherlode = false ;
  73: LD_ADDR_EXP 55
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// if difficulty >= 2 then
  81: LD_OWVAR 67
  85: PUSH
  86: LD_INT 2
  88: GREATEREQUAL
  89: IFFALSE 106
// SetTech ( tech_stimdrugs , ar_al , state_researched ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_EXP 5
  98: PPUSH
  99: LD_INT 2
 101: PPUSH
 102: CALL_OW 322
// if camp = 6 then
 106: LD_EXP 7
 110: PUSH
 111: LD_INT 6
 113: EQUAL
 114: IFFALSE 134
// OmarKilled := LoadVariable ( OmarKilled , true ) else
 116: LD_ADDR_EXP 53
 120: PUSH
 121: LD_STRING OmarKilled
 123: PPUSH
 124: LD_INT 1
 126: PPUSH
 127: CALL_OW 30
 131: ST_TO_ADDR
 132: GO 142
// OmarKilled = false ;
 134: LD_ADDR_EXP 53
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// if OmarKilled then
 142: LD_EXP 53
 146: IFFALSE 158
// begin Omar = 0 ;
 148: LD_ADDR_EXP 52
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// exit ;
 156: GO 244
// end ; if TestCharacters ( Omar ) then
 158: LD_STRING Omar
 160: PPUSH
 161: CALL_OW 28
 165: IFFALSE 182
// Omar := CreateCharacter ( Omar ) else
 167: LD_ADDR_EXP 52
 171: PUSH
 172: LD_STRING Omar
 174: PPUSH
 175: CALL_OW 34
 179: ST_TO_ADDR
 180: GO 195
// Omar = NewCharacter ( Omar ) ;
 182: LD_ADDR_EXP 52
 186: PUSH
 187: LD_STRING Omar
 189: PPUSH
 190: CALL_OW 25
 194: ST_TO_ADDR
// SetSide ( Omar , ar_al ) ;
 195: LD_EXP 52
 199: PPUSH
 200: LD_EXP 5
 204: PPUSH
 205: CALL_OW 235
// NegotiationOffered := LoadVariable ( NegotiationsOffered , false ) ;
 209: LD_ADDR_EXP 54
 213: PUSH
 214: LD_STRING NegotiationsOffered
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// if NegotiationOffered then
 225: LD_EXP 54
 229: IFFALSE 236
// enable ( 2 ) else
 231: LD_INT 2
 233: ENABLE_MARKED
 234: GO 244
// OmarWillTryContaminateMotherlode = true ;
 236: LD_ADDR_EXP 55
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// end ;
 244: LD_VAR 0 1
 248: RET
// function prepare_al_units ; var un , count , i , nations , art_loaded , selected , aliance , pom_list , veh_cargo , veh_basic , veh_battle , vehicles , veh_list , JMM_car , Bur_car ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
// nations := [ nation_american , nation_russian ] ;
 267: LD_ADDR_VAR 0 5
 271: PUSH
 272: LD_INT 1
 274: PUSH
 275: LD_INT 3
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: ST_TO_ADDR
// uc_side := you ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_EXP 1
 291: ST_TO_ADDR
// aliance_forces := [ ] ;
 292: LD_ADDR_EXP 58
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// load_all_aliance ;
 299: CALL 2799 0 0
// aliance := [ ] ;
 303: LD_ADDR_VAR 0 8
 307: PUSH
 308: EMPTY
 309: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 310: LD_ADDR_EXP 12
 314: PUSH
 315: LD_STRING Burlak
 317: PPUSH
 318: CALL_OW 34
 322: ST_TO_ADDR
// aliance := aliance ^ Burlak ;
 323: LD_ADDR_VAR 0 8
 327: PUSH
 328: LD_VAR 0 8
 332: PUSH
 333: LD_EXP 12
 337: ADD
 338: ST_TO_ADDR
// if TestCharacters ( JMM ) and CheckCharacterSet ( JMM ) then
 339: LD_STRING JMM
 341: PPUSH
 342: CALL_OW 28
 346: PUSH
 347: LD_STRING JMM
 349: PPUSH
 350: CALL_OW 29
 354: AND
 355: IFFALSE 398
// begin MacMillan := CreateCharacter ( JMM ) ;
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING JMM
 364: PPUSH
 365: CALL_OW 34
 369: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
 370: LD_EXP 13
 374: PPUSH
 375: LD_INT 2
 377: PPUSH
 378: CALL_OW 336
// aliance := aliance ^ MacMillan ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_VAR 0 8
 391: PUSH
 392: LD_EXP 13
 396: ADD
 397: ST_TO_ADDR
// end ; if TestCharacters ( Roth ) and CheckCharacterSet ( Roth ) then
 398: LD_STRING Roth
 400: PPUSH
 401: CALL_OW 28
 405: PUSH
 406: LD_STRING Roth
 408: PPUSH
 409: CALL_OW 29
 413: AND
 414: IFFALSE 457
// begin Roth := CreateCharacter ( Roth ) ;
 416: LD_ADDR_EXP 14
 420: PUSH
 421: LD_STRING Roth
 423: PPUSH
 424: CALL_OW 34
 428: ST_TO_ADDR
// SetClass ( Roth , class_scientistic ) ;
 429: LD_EXP 14
 433: PPUSH
 434: LD_INT 4
 436: PPUSH
 437: CALL_OW 336
// aliance := aliance ^ Roth ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_VAR 0 8
 450: PUSH
 451: LD_EXP 14
 455: ADD
 456: ST_TO_ADDR
// end ; if TestCharacters ( Gossudarov ) and CheckCharacterSet ( Gossudarov ) then
 457: LD_STRING Gossudarov
 459: PPUSH
 460: CALL_OW 28
 464: PUSH
 465: LD_STRING Gossudarov
 467: PPUSH
 468: CALL_OW 29
 472: AND
 473: IFFALSE 516
// begin Gossudarov := CreateCharacter ( Gossudarov ) ;
 475: LD_ADDR_EXP 15
 479: PUSH
 480: LD_STRING Gossudarov
 482: PPUSH
 483: CALL_OW 34
 487: ST_TO_ADDR
// SetClass ( Gossudarov , class_scientistic ) ;
 488: LD_EXP 15
 492: PPUSH
 493: LD_INT 4
 495: PPUSH
 496: CALL_OW 336
// aliance := aliance ^ Gossudarov ;
 500: LD_ADDR_VAR 0 8
 504: PUSH
 505: LD_VAR 0 8
 509: PUSH
 510: LD_EXP 15
 514: ADD
 515: ST_TO_ADDR
// end ; if aliance_forces < 20 then
 516: LD_EXP 58
 520: PUSH
 521: LD_INT 20
 523: LESS
 524: IFFALSE 612
// for i = aliance_forces to 20 do
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: DOUBLE
 532: LD_EXP 58
 536: DEC
 537: ST_TO_ADDR
 538: LD_INT 20
 540: PUSH
 541: FOR_TO
 542: IFFALSE 610
// begin PrepareHuman ( 0 , 0 , 6 ) ;
 544: LD_INT 0
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: CALL_OW 380
// uc_nation = [ nation_american , nation_russian ] [ Rand ( 1 , 2 ) ] ;
 557: LD_ADDR_OWVAR 21
 561: PUSH
 562: LD_INT 1
 564: PUSH
 565: LD_INT 3
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: PUSH
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 2
 577: PPUSH
 578: CALL_OW 12
 582: ARRAY
 583: ST_TO_ADDR
// hc_last_mission := 15 ;
 584: LD_ADDR_OWVAR 36
 588: PUSH
 589: LD_INT 15
 591: ST_TO_ADDR
// aliance_forces := aliance_forces ^ CreateHuman ;
 592: LD_ADDR_EXP 58
 596: PUSH
 597: LD_EXP 58
 601: PUSH
 602: CALL_OW 44
 606: ADD
 607: ST_TO_ADDR
// end ;
 608: GO 541
 610: POP
 611: POP
// selected := CharacterSelection (  , 12 - aliance , 12 - aliance , aliance ^ [ sel_not_hired , sel_changeable , sel_change_class ] ^ aliance_forces , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
 612: LD_ADDR_VAR 0 7
 616: PUSH
 617: LD_STRING 
 619: PPUSH
 620: LD_INT 12
 622: PUSH
 623: LD_VAR 0 8
 627: MINUS
 628: PPUSH
 629: LD_INT 12
 631: PUSH
 632: LD_VAR 0 8
 636: MINUS
 637: PPUSH
 638: LD_VAR 0 8
 642: PUSH
 643: LD_INT -2
 645: PUSH
 646: LD_INT -3
 648: PUSH
 649: LD_INT -5
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: ADD
 657: PUSH
 658: LD_EXP 58
 662: ADD
 663: PPUSH
 664: LD_INT 1
 666: PUSH
 667: LD_INT 2
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 4
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: PPUSH
 682: CALL_OW 42
 686: ST_TO_ADDR
// aliance_forces := aliance ^ selected ;
 687: LD_ADDR_EXP 58
 691: PUSH
 692: LD_VAR 0 8
 696: PUSH
 697: LD_VAR 0 7
 701: ADD
 702: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 703: LD_ADDR_VAR 0 15
 707: PUSH
 708: LD_STRING JMM_car
 710: PPUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 1
 716: PUSH
 717: LD_INT 1
 719: PUSH
 720: LD_INT 12
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: PPUSH
 729: CALL_OW 30
 733: ST_TO_ADDR
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 734: LD_ADDR_VAR 0 16
 738: PUSH
 739: LD_STRING Bur_car
 741: PPUSH
 742: LD_INT 22
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 1
 750: PUSH
 751: LD_INT 45
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: PPUSH
 760: CALL_OW 30
 764: ST_TO_ADDR
// if ( JMM_car [ 1 ] = 0 ) then
 765: LD_VAR 0 15
 769: PUSH
 770: LD_INT 1
 772: ARRAY
 773: PUSH
 774: LD_INT 0
 776: EQUAL
 777: IFFALSE 802
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 779: LD_ADDR_VAR 0 15
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 1
 789: PUSH
 790: LD_INT 1
 792: PUSH
 793: LD_INT 12
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: ST_TO_ADDR
// if ( Bur_car [ 1 ] = 0 ) then
 802: LD_VAR 0 16
 806: PUSH
 807: LD_INT 1
 809: ARRAY
 810: PUSH
 811: LD_INT 0
 813: EQUAL
 814: IFFALSE 839
// Bur_car := [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ;
 816: LD_ADDR_VAR 0 16
 820: PUSH
 821: LD_INT 22
 823: PUSH
 824: LD_INT 3
 826: PUSH
 827: LD_INT 1
 829: PUSH
 830: LD_INT 45
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: LIST
 837: LIST
 838: ST_TO_ADDR
// if not ( ( JMM_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) or ( Bur_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) ) then
 839: LD_VAR 0 15
 843: PUSH
 844: LD_INT 4
 846: ARRAY
 847: PUSH
 848: LD_INT 12
 850: PUSH
 851: LD_INT 51
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: IN
 858: PUSH
 859: LD_VAR 0 16
 863: PUSH
 864: LD_INT 4
 866: ARRAY
 867: PUSH
 868: LD_INT 12
 870: PUSH
 871: LD_INT 51
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: IN
 878: OR
 879: NOT
 880: IFFALSE 905
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 882: LD_ADDR_VAR 0 15
 886: PUSH
 887: LD_INT 3
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 12
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 905: LD_VAR 0 15
 909: PUSH
 910: LD_INT 1
 912: ARRAY
 913: PUSH
 914: LD_INT 1
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 3
 922: PUSH
 923: LD_INT 4
 925: PUSH
 926: LD_INT 5
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: IN
 936: IFFALSE 948
// uc_nation := nation_american else
 938: LD_ADDR_OWVAR 21
 942: PUSH
 943: LD_INT 1
 945: ST_TO_ADDR
 946: GO 956
// uc_nation := nation_russian ;
 948: LD_ADDR_OWVAR 21
 952: PUSH
 953: LD_INT 3
 955: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
 956: LD_ADDR_OWVAR 24
 960: PUSH
 961: LD_INT 2
 963: PPUSH
 964: LD_INT 3
 966: PPUSH
 967: CALL_OW 12
 971: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 972: LD_ADDR_OWVAR 37
 976: PUSH
 977: LD_VAR 0 15
 981: PUSH
 982: LD_INT 1
 984: ARRAY
 985: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 986: LD_ADDR_OWVAR 39
 990: PUSH
 991: LD_VAR 0 15
 995: PUSH
 996: LD_INT 2
 998: ARRAY
 999: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
1000: LD_ADDR_OWVAR 38
1004: PUSH
1005: LD_VAR 0 15
1009: PUSH
1010: LD_INT 3
1012: ARRAY
1013: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
1014: LD_ADDR_OWVAR 40
1018: PUSH
1019: LD_VAR 0 15
1023: PUSH
1024: LD_INT 4
1026: ARRAY
1027: ST_TO_ADDR
// un := CreateVehicle ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: CALL_OW 45
1037: ST_TO_ADDR
// art_loaded := false ;
1038: LD_ADDR_VAR 0 6
1042: PUSH
1043: LD_INT 0
1045: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , un ) ;
1046: LD_EXP 13
1050: PPUSH
1051: LD_VAR 0 2
1055: PPUSH
1056: CALL_OW 52
// PlaceUnitArea ( un , jmm_starting , false ) ;
1060: LD_VAR 0 2
1064: PPUSH
1065: LD_INT 27
1067: PPUSH
1068: LD_INT 0
1070: PPUSH
1071: CALL_OW 49
// if GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] then
1075: LD_VAR 0 2
1079: PPUSH
1080: CALL_OW 264
1084: PUSH
1085: LD_INT 12
1087: PUSH
1088: LD_INT 51
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: IN
1095: IFFALSE 1120
// begin SetCargo ( un , mat_artefact , 50 ) ;
1097: LD_VAR 0 2
1101: PPUSH
1102: LD_INT 4
1104: PPUSH
1105: LD_INT 50
1107: PPUSH
1108: CALL_OW 290
// art_loaded := true ;
1112: LD_ADDR_VAR 0 6
1116: PUSH
1117: LD_INT 1
1119: ST_TO_ADDR
// end ; if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
1120: LD_VAR 0 16
1124: PUSH
1125: LD_INT 1
1127: ARRAY
1128: PUSH
1129: LD_INT 21
1131: PUSH
1132: LD_INT 22
1134: PUSH
1135: LD_INT 23
1137: PUSH
1138: LD_INT 24
1140: PUSH
1141: EMPTY
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: IN
1147: IFFALSE 1159
// uc_nation := nation_russian else
1149: LD_ADDR_OWVAR 21
1153: PUSH
1154: LD_INT 3
1156: ST_TO_ADDR
1157: GO 1167
// uc_nation := nation_american ;
1159: LD_ADDR_OWVAR 21
1163: PUSH
1164: LD_INT 1
1166: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
1167: LD_ADDR_OWVAR 24
1171: PUSH
1172: LD_INT 2
1174: PPUSH
1175: LD_INT 3
1177: PPUSH
1178: CALL_OW 12
1182: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
1183: LD_ADDR_OWVAR 37
1187: PUSH
1188: LD_VAR 0 16
1192: PUSH
1193: LD_INT 1
1195: ARRAY
1196: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
1197: LD_ADDR_OWVAR 39
1201: PUSH
1202: LD_VAR 0 16
1206: PUSH
1207: LD_INT 2
1209: ARRAY
1210: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
1211: LD_ADDR_OWVAR 38
1215: PUSH
1216: LD_VAR 0 16
1220: PUSH
1221: LD_INT 3
1223: ARRAY
1224: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
1225: LD_ADDR_OWVAR 40
1229: PUSH
1230: LD_VAR 0 16
1234: PUSH
1235: LD_INT 4
1237: ARRAY
1238: ST_TO_ADDR
// un := CreateVehicle ;
1239: LD_ADDR_VAR 0 2
1243: PUSH
1244: CALL_OW 45
1248: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , un ) ;
1249: LD_EXP 12
1253: PPUSH
1254: LD_VAR 0 2
1258: PPUSH
1259: CALL_OW 52
// PlaceUnitArea ( un , burlak_starting , false ) ;
1263: LD_VAR 0 2
1267: PPUSH
1268: LD_INT 10
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// if ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) and not art_loaded then
1278: LD_VAR 0 2
1282: PPUSH
1283: CALL_OW 264
1287: PUSH
1288: LD_INT 12
1290: PUSH
1291: LD_INT 51
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: IN
1298: PUSH
1299: LD_VAR 0 6
1303: NOT
1304: AND
1305: IFFALSE 1322
// SetCargo ( un , mat_artefact , 50 ) ;
1307: LD_VAR 0 2
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: LD_INT 50
1317: PPUSH
1318: CALL_OW 290
// veh_cargo := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_cargo_bay ] , [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay ] ] ;
1322: LD_ADDR_VAR 0 10
1326: PUSH
1327: LD_INT 1
1329: PUSH
1330: LD_INT 3
1332: PUSH
1333: LD_INT 1
1335: PUSH
1336: LD_INT 3
1338: PUSH
1339: LD_INT 12
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: LD_INT 1
1351: PUSH
1352: LD_INT 3
1354: PUSH
1355: LD_INT 1
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: LD_INT 12
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: LIST
1370: PUSH
1371: LD_INT 3
1373: PUSH
1374: LD_INT 22
1376: PUSH
1377: LD_INT 3
1379: PUSH
1380: LD_INT 3
1382: PUSH
1383: LD_INT 51
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: LD_INT 3
1395: PUSH
1396: LD_INT 22
1398: PUSH
1399: LD_INT 3
1401: PUSH
1402: LD_INT 1
1404: PUSH
1405: LD_INT 51
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: ST_TO_ADDR
// veh_basic := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_crane ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_bulldozer ] , ] ;
1421: LD_ADDR_VAR 0 11
1425: PUSH
1426: LD_INT 1
1428: PUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 3
1437: PUSH
1438: LD_INT 13
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 3
1450: PUSH
1451: LD_INT 24
1453: PUSH
1454: LD_INT 3
1456: PUSH
1457: LD_INT 1
1459: PUSH
1460: LD_INT 53
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: ST_TO_ADDR
// veh_battle := [ [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_american , us_medium_tracked , engine_siberite , control_manual , us_laser ] , [ nation_american , us_heavy_tracked , engine_siberite , control_manual , us_heavy_gun ] , [ nation_american , us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_russian , ru_medium_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_gun ] , [ nation_russian , ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun ] , ] ;
1474: LD_ADDR_VAR 0 12
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 3
1484: PUSH
1485: LD_INT 1
1487: PUSH
1488: LD_INT 1
1490: PUSH
1491: LD_INT 7
1493: PUSH
1494: EMPTY
1495: LIST
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 3
1506: PUSH
1507: LD_INT 3
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: LD_INT 9
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 4
1528: PUSH
1529: LD_INT 3
1531: PUSH
1532: LD_INT 1
1534: PUSH
1535: LD_INT 6
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: LIST
1542: LIST
1543: LIST
1544: PUSH
1545: LD_INT 1
1547: PUSH
1548: LD_INT 5
1550: PUSH
1551: LD_INT 1
1553: PUSH
1554: LD_INT 1
1556: PUSH
1557: LD_INT 7
1559: PUSH
1560: EMPTY
1561: LIST
1562: LIST
1563: LIST
1564: LIST
1565: LIST
1566: PUSH
1567: LD_INT 3
1569: PUSH
1570: LD_INT 21
1572: PUSH
1573: LD_INT 1
1575: PUSH
1576: LD_INT 1
1578: PUSH
1579: LD_INT 45
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: PUSH
1589: LD_INT 3
1591: PUSH
1592: LD_INT 22
1594: PUSH
1595: LD_INT 3
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: LD_INT 44
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: LD_INT 23
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: LD_INT 1
1622: PUSH
1623: LD_INT 46
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: PUSH
1633: LD_INT 3
1635: PUSH
1636: LD_INT 24
1638: PUSH
1639: LD_INT 3
1641: PUSH
1642: LD_INT 1
1644: PUSH
1645: LD_INT 46
1647: PUSH
1648: EMPTY
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: EMPTY
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: ST_TO_ADDR
// veh_list := [ ] ;
1665: LD_ADDR_VAR 0 14
1669: PUSH
1670: EMPTY
1671: ST_TO_ADDR
// count := 0 ;
1672: LD_ADDR_VAR 0 3
1676: PUSH
1677: LD_INT 0
1679: ST_TO_ADDR
// for i = 3 to 4 do
1680: LD_ADDR_VAR 0 4
1684: PUSH
1685: DOUBLE
1686: LD_INT 3
1688: DEC
1689: ST_TO_ADDR
1690: LD_INT 4
1692: PUSH
1693: FOR_TO
1694: IFFALSE 1879
// begin uc_direction := Rand ( 2 , 3 ) ;
1696: LD_ADDR_OWVAR 24
1700: PUSH
1701: LD_INT 2
1703: PPUSH
1704: LD_INT 3
1706: PPUSH
1707: CALL_OW 12
1711: ST_TO_ADDR
// un := veh_cargo [ Rand ( 1 , veh_cargo ) ] ;
1712: LD_ADDR_VAR 0 2
1716: PUSH
1717: LD_VAR 0 10
1721: PUSH
1722: LD_INT 1
1724: PPUSH
1725: LD_VAR 0 10
1729: PPUSH
1730: CALL_OW 12
1734: ARRAY
1735: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1736: LD_ADDR_OWVAR 21
1740: PUSH
1741: LD_VAR 0 2
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1750: LD_ADDR_OWVAR 37
1754: PUSH
1755: LD_VAR 0 2
1759: PUSH
1760: LD_INT 2
1762: ARRAY
1763: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1764: LD_ADDR_OWVAR 39
1768: PUSH
1769: LD_VAR 0 2
1773: PUSH
1774: LD_INT 3
1776: ARRAY
1777: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1778: LD_ADDR_OWVAR 38
1782: PUSH
1783: LD_VAR 0 2
1787: PUSH
1788: LD_INT 4
1790: ARRAY
1791: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1792: LD_ADDR_OWVAR 40
1796: PUSH
1797: LD_VAR 0 2
1801: PUSH
1802: LD_INT 5
1804: ARRAY
1805: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1806: LD_ADDR_VAR 0 14
1810: PUSH
1811: LD_VAR 0 14
1815: PUSH
1816: CALL_OW 45
1820: ADD
1821: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1822: LD_VAR 0 2
1826: PUSH
1827: LD_INT 4
1829: ARRAY
1830: PUSH
1831: LD_INT 1
1833: EQUAL
1834: IFFALSE 1850
// count := count + 1 ;
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: LD_VAR 0 3
1845: PUSH
1846: LD_INT 1
1848: PLUS
1849: ST_TO_ADDR
// SetCargo ( veh_list [ veh_list ] , mat_artefact , i * 10 ) ;
1850: LD_VAR 0 14
1854: PUSH
1855: LD_VAR 0 14
1859: ARRAY
1860: PPUSH
1861: LD_INT 4
1863: PPUSH
1864: LD_VAR 0 4
1868: PUSH
1869: LD_INT 10
1871: MUL
1872: PPUSH
1873: CALL_OW 290
// end ;
1877: GO 1693
1879: POP
1880: POP
// for un in veh_basic do
1881: LD_ADDR_VAR 0 2
1885: PUSH
1886: LD_VAR 0 11
1890: PUSH
1891: FOR_IN
1892: IFFALSE 2026
// begin uc_direction := Rand ( 2 , 3 ) ;
1894: LD_ADDR_OWVAR 24
1898: PUSH
1899: LD_INT 2
1901: PPUSH
1902: LD_INT 3
1904: PPUSH
1905: CALL_OW 12
1909: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1910: LD_ADDR_OWVAR 21
1914: PUSH
1915: LD_VAR 0 2
1919: PUSH
1920: LD_INT 1
1922: ARRAY
1923: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1924: LD_ADDR_OWVAR 37
1928: PUSH
1929: LD_VAR 0 2
1933: PUSH
1934: LD_INT 2
1936: ARRAY
1937: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1938: LD_ADDR_OWVAR 39
1942: PUSH
1943: LD_VAR 0 2
1947: PUSH
1948: LD_INT 3
1950: ARRAY
1951: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1952: LD_ADDR_OWVAR 38
1956: PUSH
1957: LD_VAR 0 2
1961: PUSH
1962: LD_INT 4
1964: ARRAY
1965: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1966: LD_ADDR_OWVAR 40
1970: PUSH
1971: LD_VAR 0 2
1975: PUSH
1976: LD_INT 5
1978: ARRAY
1979: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1980: LD_ADDR_VAR 0 14
1984: PUSH
1985: LD_VAR 0 14
1989: PUSH
1990: CALL_OW 45
1994: ADD
1995: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1996: LD_VAR 0 2
2000: PUSH
2001: LD_INT 4
2003: ARRAY
2004: PUSH
2005: LD_INT 1
2007: EQUAL
2008: IFFALSE 2024
// count := count + 1 ;
2010: LD_ADDR_VAR 0 3
2014: PUSH
2015: LD_VAR 0 3
2019: PUSH
2020: LD_INT 1
2022: PLUS
2023: ST_TO_ADDR
// end ;
2024: GO 1891
2026: POP
2027: POP
// count := aliance_forces - 2 - count ;
2028: LD_ADDR_VAR 0 3
2032: PUSH
2033: LD_EXP 58
2037: PUSH
2038: LD_INT 2
2040: MINUS
2041: PUSH
2042: LD_VAR 0 3
2046: MINUS
2047: ST_TO_ADDR
// for i = 1 to count do
2048: LD_ADDR_VAR 0 4
2052: PUSH
2053: DOUBLE
2054: LD_INT 1
2056: DEC
2057: ST_TO_ADDR
2058: LD_VAR 0 3
2062: PUSH
2063: FOR_TO
2064: IFFALSE 2194
// begin uc_direction := Rand ( 2 , 3 ) ;
2066: LD_ADDR_OWVAR 24
2070: PUSH
2071: LD_INT 2
2073: PPUSH
2074: LD_INT 3
2076: PPUSH
2077: CALL_OW 12
2081: ST_TO_ADDR
// un := veh_battle [ Rand ( 1 , veh_battle ) ] ;
2082: LD_ADDR_VAR 0 2
2086: PUSH
2087: LD_VAR 0 12
2091: PUSH
2092: LD_INT 1
2094: PPUSH
2095: LD_VAR 0 12
2099: PPUSH
2100: CALL_OW 12
2104: ARRAY
2105: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
2106: LD_ADDR_OWVAR 21
2110: PUSH
2111: LD_VAR 0 2
2115: PUSH
2116: LD_INT 1
2118: ARRAY
2119: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
2120: LD_ADDR_OWVAR 37
2124: PUSH
2125: LD_VAR 0 2
2129: PUSH
2130: LD_INT 2
2132: ARRAY
2133: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
2134: LD_ADDR_OWVAR 39
2138: PUSH
2139: LD_VAR 0 2
2143: PUSH
2144: LD_INT 3
2146: ARRAY
2147: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2148: LD_ADDR_OWVAR 38
2152: PUSH
2153: LD_VAR 0 2
2157: PUSH
2158: LD_INT 4
2160: ARRAY
2161: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2162: LD_ADDR_OWVAR 40
2166: PUSH
2167: LD_VAR 0 2
2171: PUSH
2172: LD_INT 5
2174: ARRAY
2175: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2176: LD_ADDR_VAR 0 14
2180: PUSH
2181: LD_VAR 0 14
2185: PUSH
2186: CALL_OW 45
2190: ADD
2191: ST_TO_ADDR
// end ;
2192: GO 2063
2194: POP
2195: POP
// pom_list := aliance_forces diff [ MacMillan , Burlak ] ;
2196: LD_ADDR_VAR 0 9
2200: PUSH
2201: LD_EXP 58
2205: PUSH
2206: LD_EXP 13
2210: PUSH
2211: LD_EXP 12
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: DIFF
2220: ST_TO_ADDR
// i := 1 ;
2221: LD_ADDR_VAR 0 4
2225: PUSH
2226: LD_INT 1
2228: ST_TO_ADDR
// for un in veh_list do
2229: LD_ADDR_VAR 0 2
2233: PUSH
2234: LD_VAR 0 14
2238: PUSH
2239: FOR_IN
2240: IFFALSE 2341
// begin uc_direction := Rand ( 2 , 3 ) ;
2242: LD_ADDR_OWVAR 24
2246: PUSH
2247: LD_INT 2
2249: PPUSH
2250: LD_INT 3
2252: PPUSH
2253: CALL_OW 12
2257: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
2258: LD_VAR 0 2
2262: PPUSH
2263: CALL_OW 263
2267: PUSH
2268: LD_INT 1
2270: EQUAL
2271: IFFALSE 2324
// begin PlaceHumanInUnit ( pom_list [ i ] , un ) ;
2273: LD_VAR 0 9
2277: PUSH
2278: LD_VAR 0 4
2282: ARRAY
2283: PPUSH
2284: LD_VAR 0 2
2288: PPUSH
2289: CALL_OW 52
// PlaceUnitArea ( un , starting_area , false ) ;
2293: LD_VAR 0 2
2297: PPUSH
2298: LD_INT 7
2300: PPUSH
2301: LD_INT 0
2303: PPUSH
2304: CALL_OW 49
// i := i + 1 ;
2308: LD_ADDR_VAR 0 4
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_INT 1
2320: PLUS
2321: ST_TO_ADDR
// end else
2322: GO 2339
// PlaceUnitArea ( un , starting_area , false ) ;
2324: LD_VAR 0 2
2328: PPUSH
2329: LD_INT 7
2331: PPUSH
2332: LD_INT 0
2334: PPUSH
2335: CALL_OW 49
// end ;
2339: GO 2239
2341: POP
2342: POP
// ComEnterUnit ( uss_ape , uss ) ;
2343: LD_INT 146
2345: PPUSH
2346: LD_INT 38
2348: PPUSH
2349: CALL_OW 120
// end ;
2353: LD_VAR 0 1
2357: RET
// function prepare_sides ; begin
2358: LD_INT 0
2360: PPUSH
// neutral := 0 ;
2361: LD_ADDR_EXP 6
2365: PUSH
2366: LD_INT 0
2368: ST_TO_ADDR
// you := 7 ;
2369: LD_ADDR_EXP 1
2373: PUSH
2374: LD_INT 7
2376: ST_TO_ADDR
// camp := 4 ;
2377: LD_ADDR_EXP 7
2381: PUSH
2382: LD_INT 4
2384: ST_TO_ADDR
// ru := 3 ;
2385: LD_ADDR_EXP 2
2389: PUSH
2390: LD_INT 3
2392: ST_TO_ADDR
// us := 1 ;
2393: LD_ADDR_EXP 3
2397: PUSH
2398: LD_INT 1
2400: ST_TO_ADDR
// ar := 2 ;
2401: LD_ADDR_EXP 4
2405: PUSH
2406: LD_INT 2
2408: ST_TO_ADDR
// ar_al := 5 ;
2409: LD_ADDR_EXP 5
2413: PUSH
2414: LD_INT 5
2416: ST_TO_ADDR
// cpu_list := [ us , ar , ru ] ;
2417: LD_ADDR_EXP 8
2421: PUSH
2422: LD_EXP 3
2426: PUSH
2427: LD_EXP 4
2431: PUSH
2432: LD_EXP 2
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: ST_TO_ADDR
// ru_nation := nation_russian ;
2442: LD_ADDR_EXP 9
2446: PUSH
2447: LD_INT 3
2449: ST_TO_ADDR
// us_nation := nation_american ;
2450: LD_ADDR_EXP 10
2454: PUSH
2455: LD_INT 1
2457: ST_TO_ADDR
// ar_nation := nation_arabian ;
2458: LD_ADDR_EXP 11
2462: PUSH
2463: LD_INT 2
2465: ST_TO_ADDR
// finalize := 0 ;
2466: LD_ADDR_EXP 59
2470: PUSH
2471: LD_INT 0
2473: ST_TO_ADDR
// siberite_rocket_send := false ;
2474: LD_ADDR_EXP 61
2478: PUSH
2479: LD_INT 0
2481: ST_TO_ADDR
// disable ( 1 ) ;
2482: LD_INT 1
2484: DISABLE_MARKED
// disable ( 2 ) ;
2485: LD_INT 2
2487: DISABLE_MARKED
// disable ( 4 ) ;
2488: LD_INT 4
2490: DISABLE_MARKED
// disable ( 5 ) ;
2491: LD_INT 5
2493: DISABLE_MARKED
// disable ( 24 ) ;
2494: LD_INT 24
2496: DISABLE_MARKED
// disable ( 25 ) ;
2497: LD_INT 25
2499: DISABLE_MARKED
// disable ( 26 ) ;
2500: LD_INT 26
2502: DISABLE_MARKED
// disable ( 222 ) ;
2503: LD_INT 222
2505: DISABLE_MARKED
// disable ( 223 ) ;
2506: LD_INT 223
2508: DISABLE_MARKED
// SetAttitude ( you , ru , att_enemy , true ) ;
2509: LD_EXP 1
2513: PPUSH
2514: LD_EXP 2
2518: PPUSH
2519: LD_INT 2
2521: PPUSH
2522: LD_INT 1
2524: PPUSH
2525: CALL_OW 80
// SetAttitude ( you , us , att_enemy , true ) ;
2529: LD_EXP 1
2533: PPUSH
2534: LD_EXP 3
2538: PPUSH
2539: LD_INT 2
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: CALL_OW 80
// SetAttitude ( you , ar , att_enemy , true ) ;
2549: LD_EXP 1
2553: PPUSH
2554: LD_EXP 4
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: LD_INT 1
2564: PPUSH
2565: CALL_OW 80
// SetAttitude ( you , neutral , att_neutral , true ) ;
2569: LD_EXP 1
2573: PPUSH
2574: LD_EXP 6
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: LD_INT 1
2584: PPUSH
2585: CALL_OW 80
// SetAttitude ( you , ar_al , att_enemy , true ) ;
2589: LD_EXP 1
2593: PPUSH
2594: LD_EXP 5
2598: PPUSH
2599: LD_INT 2
2601: PPUSH
2602: LD_INT 1
2604: PPUSH
2605: CALL_OW 80
// SetAttitude ( ru , us , att_enemy , true ) ;
2609: LD_EXP 2
2613: PPUSH
2614: LD_EXP 3
2618: PPUSH
2619: LD_INT 2
2621: PPUSH
2622: LD_INT 1
2624: PPUSH
2625: CALL_OW 80
// SetAttitude ( ru , ar , att_enemy , true ) ;
2629: LD_EXP 2
2633: PPUSH
2634: LD_EXP 4
2638: PPUSH
2639: LD_INT 2
2641: PPUSH
2642: LD_INT 1
2644: PPUSH
2645: CALL_OW 80
// SetAttitude ( us , ar , att_enemy , true ) ;
2649: LD_EXP 3
2653: PPUSH
2654: LD_EXP 4
2658: PPUSH
2659: LD_INT 2
2661: PPUSH
2662: LD_INT 1
2664: PPUSH
2665: CALL_OW 80
// SetAttitude ( ru , ar_al , att_enemy , true ) ;
2669: LD_EXP 2
2673: PPUSH
2674: LD_EXP 5
2678: PPUSH
2679: LD_INT 2
2681: PPUSH
2682: LD_INT 1
2684: PPUSH
2685: CALL_OW 80
// SetAttitude ( us , ar_al , att_enemy , true ) ;
2689: LD_EXP 3
2693: PPUSH
2694: LD_EXP 5
2698: PPUSH
2699: LD_INT 2
2701: PPUSH
2702: LD_INT 1
2704: PPUSH
2705: CALL_OW 80
// end ;
2709: LD_VAR 0 1
2713: RET
// starting begin RandomizeAll ;
2714: CALL_OW 11
// prepare_sides ;
2718: CALL 2358 0 0
// prepare_us_units ;
2722: CALL 0 0 0
// prepare_ru_units ;
2726: CALL 35 0 0
// prepare_ar_units ;
2730: CALL 70 0 0
// prepare_al_units ;
2734: CALL 249 0 0
// prepare_apemans ;
2738: CALL 7164 0 0
// create_russians ;
2742: CALL 4687 0 0
// create_americans ;
2746: CALL 5387 0 0
// create_arabians ;
2750: CALL 6138 0 0
// init_distribution ;
2754: CALL 26507 0 0
// init_defend ;
2758: CALL 18312 0 0
// init_attack ;
2762: CALL 20925 0 0
// init_keep_base ;
2766: CALL 32380 0 0
// init_research ;
2770: CALL 24104 0 0
// init_manufacture ;
2774: CALL 26854 0 0
// init_crates_loading ;
2778: CALL 32786 0 0
// init_crates_collecting ;
2782: CALL 33523 0 0
// init_alien_research ;
2786: CALL 37047 0 0
// init_sib_rocket ;
2790: CALL 36216 0 0
// starting_scene ;
2794: CALL 7396 0 0
// end ; end_of_file
2798: END
// export function load_all_aliance ; begin
2799: LD_INT 0
2801: PPUSH
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) then
2802: LD_STRING Belkov
2804: PPUSH
2805: CALL_OW 28
2809: PUSH
2810: LD_STRING Belkov
2812: PPUSH
2813: CALL_OW 29
2817: AND
2818: IFFALSE 2849
// begin Belkov := CreateCharacter ( Belkov ) ;
2820: LD_ADDR_EXP 17
2824: PUSH
2825: LD_STRING Belkov
2827: PPUSH
2828: CALL_OW 34
2832: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Belkov ;
2833: LD_ADDR_EXP 58
2837: PUSH
2838: LD_EXP 58
2842: PUSH
2843: LD_EXP 17
2847: ADD
2848: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) then
2849: LD_STRING Petrosyan
2851: PPUSH
2852: CALL_OW 28
2856: PUSH
2857: LD_STRING Petrosyan
2859: PPUSH
2860: CALL_OW 29
2864: AND
2865: IFFALSE 2896
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
2867: LD_ADDR_EXP 16
2871: PUSH
2872: LD_STRING Petrosyan
2874: PPUSH
2875: CALL_OW 34
2879: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrosyan ;
2880: LD_ADDR_EXP 58
2884: PUSH
2885: LD_EXP 58
2889: PUSH
2890: LD_EXP 16
2894: ADD
2895: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) then
2896: LD_STRING Kirilenkova
2898: PPUSH
2899: CALL_OW 28
2903: PUSH
2904: LD_STRING Kirilenkova
2906: PPUSH
2907: CALL_OW 29
2911: AND
2912: IFFALSE 2943
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
2914: LD_ADDR_EXP 18
2918: PUSH
2919: LD_STRING Kirilenkova
2921: PPUSH
2922: CALL_OW 34
2926: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kirilenkova ;
2927: LD_ADDR_EXP 58
2931: PUSH
2932: LD_EXP 58
2936: PUSH
2937: LD_EXP 18
2941: ADD
2942: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) then
2943: LD_STRING Gnyevko
2945: PPUSH
2946: CALL_OW 28
2950: PUSH
2951: LD_STRING Gnyevko
2953: PPUSH
2954: CALL_OW 29
2958: AND
2959: IFFALSE 2990
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
2961: LD_ADDR_EXP 19
2965: PUSH
2966: LD_STRING Gnyevko
2968: PPUSH
2969: CALL_OW 34
2973: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gnyevko ;
2974: LD_ADDR_EXP 58
2978: PUSH
2979: LD_EXP 58
2983: PUSH
2984: LD_EXP 19
2988: ADD
2989: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) then
2990: LD_STRING Dolgov
2992: PPUSH
2993: CALL_OW 28
2997: PUSH
2998: LD_STRING Dolgov
3000: PPUSH
3001: CALL_OW 29
3005: AND
3006: IFFALSE 3037
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3008: LD_ADDR_EXP 21
3012: PUSH
3013: LD_STRING Dolgov
3015: PPUSH
3016: CALL_OW 34
3020: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Dolgov ;
3021: LD_ADDR_EXP 58
3025: PUSH
3026: LD_EXP 58
3030: PUSH
3031: LD_EXP 21
3035: ADD
3036: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) then
3037: LD_STRING Gleb
3039: PPUSH
3040: CALL_OW 28
3044: PUSH
3045: LD_STRING Gleb
3047: PPUSH
3048: CALL_OW 29
3052: AND
3053: IFFALSE 3084
// begin Gleb := CreateCharacter ( Gleb ) ;
3055: LD_ADDR_EXP 22
3059: PUSH
3060: LD_STRING Gleb
3062: PPUSH
3063: CALL_OW 34
3067: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gleb ;
3068: LD_ADDR_EXP 58
3072: PUSH
3073: LD_EXP 58
3077: PUSH
3078: LD_EXP 22
3082: ADD
3083: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) then
3084: LD_STRING Kapitsova
3086: PPUSH
3087: CALL_OW 28
3091: PUSH
3092: LD_STRING Kapitsova
3094: PPUSH
3095: CALL_OW 29
3099: AND
3100: IFFALSE 3131
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3102: LD_ADDR_EXP 23
3106: PUSH
3107: LD_STRING Kapitsova
3109: PPUSH
3110: CALL_OW 34
3114: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kapitsova ;
3115: LD_ADDR_EXP 58
3119: PUSH
3120: LD_EXP 58
3124: PUSH
3125: LD_EXP 23
3129: ADD
3130: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) then
3131: LD_STRING Kuzmov
3133: PPUSH
3134: CALL_OW 28
3138: PUSH
3139: LD_STRING Kuzmov
3141: PPUSH
3142: CALL_OW 29
3146: AND
3147: IFFALSE 3178
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3149: LD_ADDR_EXP 24
3153: PUSH
3154: LD_STRING Kuzmov
3156: PPUSH
3157: CALL_OW 34
3161: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kuzmov ;
3162: LD_ADDR_EXP 58
3166: PUSH
3167: LD_EXP 58
3171: PUSH
3172: LD_EXP 24
3176: ADD
3177: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) then
3178: LD_STRING Kovalyuk
3180: PPUSH
3181: CALL_OW 28
3185: PUSH
3186: LD_STRING Kovalyuk
3188: PPUSH
3189: CALL_OW 29
3193: AND
3194: IFFALSE 3225
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
3196: LD_ADDR_EXP 25
3200: PUSH
3201: LD_STRING Kovalyuk
3203: PPUSH
3204: CALL_OW 34
3208: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kovalyuk ;
3209: LD_ADDR_EXP 58
3213: PUSH
3214: LD_EXP 58
3218: PUSH
3219: LD_EXP 25
3223: ADD
3224: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) then
3225: LD_STRING Scholtze
3227: PPUSH
3228: CALL_OW 28
3232: PUSH
3233: LD_STRING Scholtze
3235: PPUSH
3236: CALL_OW 29
3240: AND
3241: IFFALSE 3272
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3243: LD_ADDR_EXP 26
3247: PUSH
3248: LD_STRING Scholtze
3250: PPUSH
3251: CALL_OW 34
3255: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Scholtze ;
3256: LD_ADDR_EXP 58
3260: PUSH
3261: LD_EXP 58
3265: PUSH
3266: LD_EXP 26
3270: ADD
3271: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) then
3272: LD_STRING Karamazov
3274: PPUSH
3275: CALL_OW 28
3279: PUSH
3280: LD_STRING Karamazov
3282: PPUSH
3283: CALL_OW 29
3287: AND
3288: IFFALSE 3319
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3290: LD_ADDR_EXP 27
3294: PUSH
3295: LD_STRING Karamazov
3297: PPUSH
3298: CALL_OW 34
3302: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Karamazov ;
3303: LD_ADDR_EXP 58
3307: PUSH
3308: LD_EXP 58
3312: PUSH
3313: LD_EXP 27
3317: ADD
3318: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) then
3319: LD_STRING Titov
3321: PPUSH
3322: CALL_OW 28
3326: PUSH
3327: LD_STRING Titov
3329: PPUSH
3330: CALL_OW 29
3334: AND
3335: IFFALSE 3366
// begin Titov := CreateCharacter ( Titov ) ;
3337: LD_ADDR_EXP 28
3341: PUSH
3342: LD_STRING Titov
3344: PPUSH
3345: CALL_OW 34
3349: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Titov ;
3350: LD_ADDR_EXP 58
3354: PUSH
3355: LD_EXP 58
3359: PUSH
3360: LD_EXP 28
3364: ADD
3365: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) then
3366: LD_STRING Oblukov
3368: PPUSH
3369: CALL_OW 28
3373: PUSH
3374: LD_STRING Oblukov
3376: PPUSH
3377: CALL_OW 29
3381: AND
3382: IFFALSE 3413
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3384: LD_ADDR_EXP 29
3388: PUSH
3389: LD_STRING Oblukov
3391: PPUSH
3392: CALL_OW 34
3396: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Oblukov ;
3397: LD_ADDR_EXP 58
3401: PUSH
3402: LD_EXP 58
3406: PUSH
3407: LD_EXP 29
3411: ADD
3412: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) then
3413: LD_STRING Kozlov
3415: PPUSH
3416: CALL_OW 28
3420: PUSH
3421: LD_STRING Kozlov
3423: PPUSH
3424: CALL_OW 29
3428: AND
3429: IFFALSE 3460
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3431: LD_ADDR_EXP 30
3435: PUSH
3436: LD_STRING Kozlov
3438: PPUSH
3439: CALL_OW 34
3443: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kozlov ;
3444: LD_ADDR_EXP 58
3448: PUSH
3449: LD_EXP 58
3453: PUSH
3454: LD_EXP 30
3458: ADD
3459: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) then
3460: LD_STRING Petrovova
3462: PPUSH
3463: CALL_OW 28
3467: PUSH
3468: LD_STRING Petrovova
3470: PPUSH
3471: CALL_OW 29
3475: AND
3476: IFFALSE 3507
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3478: LD_ADDR_EXP 31
3482: PUSH
3483: LD_STRING Petrovova
3485: PPUSH
3486: CALL_OW 34
3490: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrovova ;
3491: LD_ADDR_EXP 58
3495: PUSH
3496: LD_EXP 58
3500: PUSH
3501: LD_EXP 31
3505: ADD
3506: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) then
3507: LD_STRING Lipshchin
3509: PPUSH
3510: CALL_OW 28
3514: PUSH
3515: LD_STRING Lipshchin
3517: PPUSH
3518: CALL_OW 29
3522: AND
3523: IFFALSE 3554
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3525: LD_ADDR_EXP 33
3529: PUSH
3530: LD_STRING Lipshchin
3532: PPUSH
3533: CALL_OW 34
3537: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lipshchin ;
3538: LD_ADDR_EXP 58
3542: PUSH
3543: LD_EXP 58
3547: PUSH
3548: LD_EXP 33
3552: ADD
3553: ST_TO_ADDR
// end ; if TestCharacters ( Bobby ) and CheckCharacterSet ( Bobby ) and LoadVariable ( bobby_side , 0 ) = 7 then
3554: LD_STRING Bobby
3556: PPUSH
3557: CALL_OW 28
3561: PUSH
3562: LD_STRING Bobby
3564: PPUSH
3565: CALL_OW 29
3569: AND
3570: PUSH
3571: LD_STRING bobby_side
3573: PPUSH
3574: LD_INT 0
3576: PPUSH
3577: CALL_OW 30
3581: PUSH
3582: LD_INT 7
3584: EQUAL
3585: AND
3586: IFFALSE 3617
// begin Bobby := CreateCharacter ( Bobby ) ;
3588: LD_ADDR_EXP 35
3592: PUSH
3593: LD_STRING Bobby
3595: PPUSH
3596: CALL_OW 34
3600: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bobby ;
3601: LD_ADDR_EXP 58
3605: PUSH
3606: LD_EXP 58
3610: PUSH
3611: LD_EXP 35
3615: ADD
3616: ST_TO_ADDR
// end ; if TestCharacters ( Brown ) and CheckCharacterSet ( Brown ) and LoadVariable ( brown_side , 0 ) = 7 then
3617: LD_STRING Brown
3619: PPUSH
3620: CALL_OW 28
3624: PUSH
3625: LD_STRING Brown
3627: PPUSH
3628: CALL_OW 29
3632: AND
3633: PUSH
3634: LD_STRING brown_side
3636: PPUSH
3637: LD_INT 0
3639: PPUSH
3640: CALL_OW 30
3644: PUSH
3645: LD_INT 7
3647: EQUAL
3648: AND
3649: IFFALSE 3680
// begin Brown := CreateCharacter ( Brown ) ;
3651: LD_ADDR_EXP 36
3655: PUSH
3656: LD_STRING Brown
3658: PPUSH
3659: CALL_OW 34
3663: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Brown ;
3664: LD_ADDR_EXP 58
3668: PUSH
3669: LD_EXP 58
3673: PUSH
3674: LD_EXP 36
3678: ADD
3679: ST_TO_ADDR
// end ; if TestCharacters ( Cornell ) and CheckCharacterSet ( Cornell ) and LoadVariable ( markc_side , 0 ) = 7 then
3680: LD_STRING Cornell
3682: PPUSH
3683: CALL_OW 28
3687: PUSH
3688: LD_STRING Cornell
3690: PPUSH
3691: CALL_OW 29
3695: AND
3696: PUSH
3697: LD_STRING markc_side
3699: PPUSH
3700: LD_INT 0
3702: PPUSH
3703: CALL_OW 30
3707: PUSH
3708: LD_INT 7
3710: EQUAL
3711: AND
3712: IFFALSE 3743
// begin Cornell := CreateCharacter ( Cornell ) ;
3714: LD_ADDR_EXP 37
3718: PUSH
3719: LD_STRING Cornell
3721: PPUSH
3722: CALL_OW 34
3726: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cornell ;
3727: LD_ADDR_EXP 58
3731: PUSH
3732: LD_EXP 58
3736: PUSH
3737: LD_EXP 37
3741: ADD
3742: ST_TO_ADDR
// end ; if TestCharacters ( Cyrus ) and CheckCharacterSet ( Cyrus ) and LoadVariable ( cyrus_side , 0 ) = 7 then
3743: LD_STRING Cyrus
3745: PPUSH
3746: CALL_OW 28
3750: PUSH
3751: LD_STRING Cyrus
3753: PPUSH
3754: CALL_OW 29
3758: AND
3759: PUSH
3760: LD_STRING cyrus_side
3762: PPUSH
3763: LD_INT 0
3765: PPUSH
3766: CALL_OW 30
3770: PUSH
3771: LD_INT 7
3773: EQUAL
3774: AND
3775: IFFALSE 3806
// begin Cyrus := CreateCharacter ( Cyrus ) ;
3777: LD_ADDR_EXP 39
3781: PUSH
3782: LD_STRING Cyrus
3784: PPUSH
3785: CALL_OW 34
3789: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cyrus ;
3790: LD_ADDR_EXP 58
3794: PUSH
3795: LD_EXP 58
3799: PUSH
3800: LD_EXP 39
3804: ADD
3805: ST_TO_ADDR
// end ; if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) and LoadVariable ( denis_side , 0 ) = 7 then
3806: LD_STRING Denis
3808: PPUSH
3809: CALL_OW 28
3813: PUSH
3814: LD_STRING Denis
3816: PPUSH
3817: CALL_OW 29
3821: AND
3822: PUSH
3823: LD_STRING denis_side
3825: PPUSH
3826: LD_INT 0
3828: PPUSH
3829: CALL_OW 30
3833: PUSH
3834: LD_INT 7
3836: EQUAL
3837: AND
3838: IFFALSE 3869
// begin Denis := CreateCharacter ( Denis ) ;
3840: LD_ADDR_EXP 40
3844: PUSH
3845: LD_STRING Denis
3847: PPUSH
3848: CALL_OW 34
3852: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Denis ;
3853: LD_ADDR_EXP 58
3857: PUSH
3858: LD_EXP 58
3862: PUSH
3863: LD_EXP 40
3867: ADD
3868: ST_TO_ADDR
// end ; if TestCharacters ( Donaldson ) and CheckCharacterSet ( Donaldson ) and LoadVariable ( lucy_side , 0 ) = 7 then
3869: LD_STRING Donaldson
3871: PPUSH
3872: CALL_OW 28
3876: PUSH
3877: LD_STRING Donaldson
3879: PPUSH
3880: CALL_OW 29
3884: AND
3885: PUSH
3886: LD_STRING lucy_side
3888: PPUSH
3889: LD_INT 0
3891: PPUSH
3892: CALL_OW 30
3896: PUSH
3897: LD_INT 7
3899: EQUAL
3900: AND
3901: IFFALSE 3932
// begin Donaldson := CreateCharacter ( Donaldson ) ;
3903: LD_ADDR_EXP 41
3907: PUSH
3908: LD_STRING Donaldson
3910: PPUSH
3911: CALL_OW 34
3915: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Donaldson ;
3916: LD_ADDR_EXP 58
3920: PUSH
3921: LD_EXP 58
3925: PUSH
3926: LD_EXP 41
3930: ADD
3931: ST_TO_ADDR
// end ; if TestCharacters ( Frank ) and CheckCharacterSet ( Frank ) and LoadVariable ( frank_side , 0 ) = 7 then
3932: LD_STRING Frank
3934: PPUSH
3935: CALL_OW 28
3939: PUSH
3940: LD_STRING Frank
3942: PPUSH
3943: CALL_OW 29
3947: AND
3948: PUSH
3949: LD_STRING frank_side
3951: PPUSH
3952: LD_INT 0
3954: PPUSH
3955: CALL_OW 30
3959: PUSH
3960: LD_INT 7
3962: EQUAL
3963: AND
3964: IFFALSE 3995
// begin Frank := CreateCharacter ( Frank ) ;
3966: LD_ADDR_EXP 42
3970: PUSH
3971: LD_STRING Frank
3973: PPUSH
3974: CALL_OW 34
3978: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Frank ;
3979: LD_ADDR_EXP 58
3983: PUSH
3984: LD_EXP 58
3988: PUSH
3989: LD_EXP 42
3993: ADD
3994: ST_TO_ADDR
// end ; if TestCharacters ( Gary ) and CheckCharacterSet ( Gary ) and LoadVariable ( gary_side , 0 ) = 7 then
3995: LD_STRING Gary
3997: PPUSH
3998: CALL_OW 28
4002: PUSH
4003: LD_STRING Gary
4005: PPUSH
4006: CALL_OW 29
4010: AND
4011: PUSH
4012: LD_STRING gary_side
4014: PPUSH
4015: LD_INT 0
4017: PPUSH
4018: CALL_OW 30
4022: PUSH
4023: LD_INT 7
4025: EQUAL
4026: AND
4027: IFFALSE 4058
// begin Gary := CreateCharacter ( Gary ) ;
4029: LD_ADDR_EXP 43
4033: PUSH
4034: LD_STRING Gary
4036: PPUSH
4037: CALL_OW 34
4041: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gary ;
4042: LD_ADDR_EXP 58
4046: PUSH
4047: LD_EXP 58
4051: PUSH
4052: LD_EXP 43
4056: ADD
4057: ST_TO_ADDR
// end ; if TestCharacters ( Gladstone ) and CheckCharacterSet ( Gladstone ) and LoadVariable ( tim_side , 0 ) = 7 then
4058: LD_STRING Gladstone
4060: PPUSH
4061: CALL_OW 28
4065: PUSH
4066: LD_STRING Gladstone
4068: PPUSH
4069: CALL_OW 29
4073: AND
4074: PUSH
4075: LD_STRING tim_side
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 30
4085: PUSH
4086: LD_INT 7
4088: EQUAL
4089: AND
4090: IFFALSE 4121
// begin Gladstone := CreateCharacter ( Gladstone ) ;
4092: LD_ADDR_EXP 44
4096: PUSH
4097: LD_STRING Gladstone
4099: PPUSH
4100: CALL_OW 34
4104: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladstone ;
4105: LD_ADDR_EXP 58
4109: PUSH
4110: LD_EXP 58
4114: PUSH
4115: LD_EXP 44
4119: ADD
4120: ST_TO_ADDR
// end ; if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) and LoadVariable ( joan_side , 0 ) = 7 and camp = 4 then
4121: LD_STRING Joan
4123: PPUSH
4124: CALL_OW 28
4128: PUSH
4129: LD_STRING Joan
4131: PPUSH
4132: CALL_OW 29
4136: AND
4137: PUSH
4138: LD_STRING joan_side
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 30
4148: PUSH
4149: LD_INT 7
4151: EQUAL
4152: AND
4153: PUSH
4154: LD_EXP 7
4158: PUSH
4159: LD_INT 4
4161: EQUAL
4162: AND
4163: IFFALSE 4194
// begin Joan := CreateCharacter ( Joan ) ;
4165: LD_ADDR_EXP 45
4169: PUSH
4170: LD_STRING Joan
4172: PPUSH
4173: CALL_OW 34
4177: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Joan ;
4178: LD_ADDR_EXP 58
4182: PUSH
4183: LD_EXP 58
4187: PUSH
4188: LD_EXP 45
4192: ADD
4193: ST_TO_ADDR
// end ; if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) and LoadVariable ( lisa_side , 0 ) = 7 then
4194: LD_STRING Lisa
4196: PPUSH
4197: CALL_OW 28
4201: PUSH
4202: LD_STRING Lisa
4204: PPUSH
4205: CALL_OW 29
4209: AND
4210: PUSH
4211: LD_STRING lisa_side
4213: PPUSH
4214: LD_INT 0
4216: PPUSH
4217: CALL_OW 30
4221: PUSH
4222: LD_INT 7
4224: EQUAL
4225: AND
4226: IFFALSE 4257
// begin Lisa := CreateCharacter ( Lisa ) ;
4228: LD_ADDR_EXP 46
4232: PUSH
4233: LD_STRING Lisa
4235: PPUSH
4236: CALL_OW 34
4240: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lisa ;
4241: LD_ADDR_EXP 58
4245: PUSH
4246: LD_EXP 58
4250: PUSH
4251: LD_EXP 46
4255: ADD
4256: ST_TO_ADDR
// end ; if TestCharacters ( Peterson ) and CheckCharacterSet ( Peterson ) then
4257: LD_STRING Peterson
4259: PPUSH
4260: CALL_OW 28
4264: PUSH
4265: LD_STRING Peterson
4267: PPUSH
4268: CALL_OW 29
4272: AND
4273: IFFALSE 4304
// begin Peterson := CreateCharacter ( Peterson ) ;
4275: LD_ADDR_EXP 47
4279: PUSH
4280: LD_STRING Peterson
4282: PPUSH
4283: CALL_OW 34
4287: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Peterson ;
4288: LD_ADDR_EXP 58
4292: PUSH
4293: LD_EXP 58
4297: PUSH
4298: LD_EXP 47
4302: ADD
4303: ST_TO_ADDR
// end ; if TestCharacters ( Simms ) and CheckCharacterSet ( Simms ) and LoadVariable ( simms_side , 0 ) = 7 then
4304: LD_STRING Simms
4306: PPUSH
4307: CALL_OW 28
4311: PUSH
4312: LD_STRING Simms
4314: PPUSH
4315: CALL_OW 29
4319: AND
4320: PUSH
4321: LD_STRING simms_side
4323: PPUSH
4324: LD_INT 0
4326: PPUSH
4327: CALL_OW 30
4331: PUSH
4332: LD_INT 7
4334: EQUAL
4335: AND
4336: IFFALSE 4367
// begin Simms := CreateCharacter ( Simms ) ;
4338: LD_ADDR_EXP 48
4342: PUSH
4343: LD_STRING Simms
4345: PPUSH
4346: CALL_OW 34
4350: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Simms ;
4351: LD_ADDR_EXP 58
4355: PUSH
4356: LD_EXP 58
4360: PUSH
4361: LD_EXP 48
4365: ADD
4366: ST_TO_ADDR
// end ; if TestCharacters ( Yamoko ) and CheckCharacterSet ( Yamoko ) and LoadVariable ( yamoko_side , 0 ) = 7 then
4367: LD_STRING Yamoko
4369: PPUSH
4370: CALL_OW 28
4374: PUSH
4375: LD_STRING Yamoko
4377: PPUSH
4378: CALL_OW 29
4382: AND
4383: PUSH
4384: LD_STRING yamoko_side
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 30
4394: PUSH
4395: LD_INT 7
4397: EQUAL
4398: AND
4399: IFFALSE 4430
// begin Yamoko := CreateCharacter ( Yamoko ) ;
4401: LD_ADDR_EXP 50
4405: PUSH
4406: LD_STRING Yamoko
4408: PPUSH
4409: CALL_OW 34
4413: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Yamoko ;
4414: LD_ADDR_EXP 58
4418: PUSH
4419: LD_EXP 58
4423: PUSH
4424: LD_EXP 50
4428: ADD
4429: ST_TO_ADDR
// end ; if CheckCharacterSet ( otherWithJMM ) then
4430: LD_STRING otherWithJMM
4432: PPUSH
4433: CALL_OW 29
4437: IFFALSE 4468
// begin others = CreateCharacterSet ( otherWithJMM ) ;
4439: LD_ADDR_EXP 51
4443: PUSH
4444: LD_STRING otherWithJMM
4446: PPUSH
4447: CALL_OW 31
4451: ST_TO_ADDR
// aliance_forces := aliance_forces ^ others ;
4452: LD_ADDR_EXP 58
4456: PUSH
4457: LD_EXP 58
4461: PUSH
4462: LD_EXP 51
4466: ADD
4467: ST_TO_ADDR
// end ; DisableAllBazookers ;
4468: CALL 4600 0 0
// if camp = 4 then
4472: LD_EXP 7
4476: PUSH
4477: LD_INT 4
4479: EQUAL
4480: IFFALSE 4486
// sort_aliance_by_the_nation ;
4482: CALL 4491 0 0
// end ;
4486: LD_VAR 0 1
4490: RET
// function sort_aliance_by_the_nation ; var un , us_list , ru_list ; begin
4491: LD_INT 0
4493: PPUSH
4494: PPUSH
4495: PPUSH
4496: PPUSH
// us_list := [ ] ;
4497: LD_ADDR_VAR 0 3
4501: PUSH
4502: EMPTY
4503: ST_TO_ADDR
// ru_list := [ ] ;
4504: LD_ADDR_VAR 0 4
4508: PUSH
4509: EMPTY
4510: ST_TO_ADDR
// for un in aliance_forces do
4511: LD_ADDR_VAR 0 2
4515: PUSH
4516: LD_EXP 58
4520: PUSH
4521: FOR_IN
4522: IFFALSE 4577
// if GetNation ( un ) = us then
4524: LD_VAR 0 2
4528: PPUSH
4529: CALL_OW 248
4533: PUSH
4534: LD_EXP 3
4538: EQUAL
4539: IFFALSE 4559
// us_list := us_list ^ un else
4541: LD_ADDR_VAR 0 3
4545: PUSH
4546: LD_VAR 0 3
4550: PUSH
4551: LD_VAR 0 2
4555: ADD
4556: ST_TO_ADDR
4557: GO 4575
// ru_list := ru_list ^ un ;
4559: LD_ADDR_VAR 0 4
4563: PUSH
4564: LD_VAR 0 4
4568: PUSH
4569: LD_VAR 0 2
4573: ADD
4574: ST_TO_ADDR
4575: GO 4521
4577: POP
4578: POP
// aliance_forces := us_list ^ ru_list ;
4579: LD_ADDR_EXP 58
4583: PUSH
4584: LD_VAR 0 3
4588: PUSH
4589: LD_VAR 0 4
4593: ADD
4594: ST_TO_ADDR
// end ;
4595: LD_VAR 0 1
4599: RET
// function DisableAllBazookers ; var list , un ; begin
4600: LD_INT 0
4602: PPUSH
4603: PPUSH
4604: PPUSH
// list := [ ] ;
4605: LD_ADDR_VAR 0 2
4609: PUSH
4610: EMPTY
4611: ST_TO_ADDR
// for un in aliance_forces do
4612: LD_ADDR_VAR 0 3
4616: PUSH
4617: LD_EXP 58
4621: PUSH
4622: FOR_IN
4623: IFFALSE 4670
// begin if GetClass ( un ) = class_bazooker then
4625: LD_VAR 0 3
4629: PPUSH
4630: CALL_OW 257
4634: PUSH
4635: LD_INT 9
4637: EQUAL
4638: IFFALSE 4652
// SetClass ( un , class_soldier ) ;
4640: LD_VAR 0 3
4644: PPUSH
4645: LD_INT 1
4647: PPUSH
4648: CALL_OW 336
// list := list ^ un ;
4652: LD_ADDR_VAR 0 2
4656: PUSH
4657: LD_VAR 0 2
4661: PUSH
4662: LD_VAR 0 3
4666: ADD
4667: ST_TO_ADDR
// end ;
4668: GO 4622
4670: POP
4671: POP
// aliance_forces := list ;
4672: LD_ADDR_EXP 58
4676: PUSH
4677: LD_VAR 0 2
4681: ST_TO_ADDR
// end ; end_of_file
4682: LD_VAR 0 1
4686: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_russians ; var un , class_list , members ; begin
4687: LD_INT 0
4689: PPUSH
4690: PPUSH
4691: PPUSH
4692: PPUSH
// cpu_side := ru ;
4693: LD_ADDR_LOC 1
4697: PUSH
4698: LD_EXP 2
4702: ST_TO_ADDR
// cpu_nation := nation_russian ;
4703: LD_ADDR_LOC 2
4707: PUSH
4708: LD_INT 3
4710: ST_TO_ADDR
// cpu_base := ru_create ;
4711: LD_ADDR_LOC 3
4715: PUSH
4716: LD_INT 17
4718: ST_TO_ADDR
// members := difficulty * 2 ;
4719: LD_ADDR_VAR 0 4
4723: PUSH
4724: LD_OWVAR 67
4728: PUSH
4729: LD_INT 2
4731: MUL
4732: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
4733: LD_ADDR_VAR 0 3
4737: PUSH
4738: LD_INT 1
4740: PUSH
4741: LD_INT 3
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 2
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: ST_TO_ADDR
// for un in class_list do
4756: LD_ADDR_VAR 0 2
4760: PUSH
4761: LD_VAR 0 3
4765: PUSH
4766: FOR_IN
4767: IFFALSE 4800
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
4769: LD_LOC 1
4773: PPUSH
4774: LD_LOC 2
4778: PPUSH
4779: LD_VAR 0 2
4783: PPUSH
4784: LD_VAR 0 4
4788: PPUSH
4789: LD_LOC 3
4793: PPUSH
4794: CALL 6838 0 5
4798: GO 4766
4800: POP
4801: POP
// place_all_soldiers ;
4802: CALL 4819 0 0
// place_all_scientistics ;
4806: CALL 5027 0 0
// place_all_mechanics ;
4810: CALL 5216 0 0
// end ;
4814: LD_VAR 0 1
4818: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
4826: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
4827: LD_ADDR_VAR 0 6
4831: PUSH
4832: LD_INT 22
4834: PUSH
4835: LD_LOC 1
4839: PUSH
4840: EMPTY
4841: LIST
4842: LIST
4843: PUSH
4844: LD_INT 30
4846: PUSH
4847: LD_INT 32
4849: PUSH
4850: EMPTY
4851: LIST
4852: LIST
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PPUSH
4858: CALL_OW 69
4862: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
4863: LD_ADDR_VAR 0 5
4867: PUSH
4868: LD_INT 22
4870: PUSH
4871: LD_LOC 1
4875: PUSH
4876: EMPTY
4877: LIST
4878: LIST
4879: PUSH
4880: LD_INT 25
4882: PUSH
4883: LD_INT 1
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PPUSH
4894: CALL_OW 69
4898: ST_TO_ADDR
// if buildings >= units then
4899: LD_VAR 0 6
4903: PUSH
4904: LD_VAR 0 5
4908: GREATEREQUAL
4909: IFFALSE 4927
// max := 0 + units else
4911: LD_ADDR_VAR 0 4
4915: PUSH
4916: LD_INT 0
4918: PUSH
4919: LD_VAR 0 5
4923: PLUS
4924: ST_TO_ADDR
4925: GO 4941
// max := 0 + buildings ;
4927: LD_ADDR_VAR 0 4
4931: PUSH
4932: LD_INT 0
4934: PUSH
4935: LD_VAR 0 6
4939: PLUS
4940: ST_TO_ADDR
// i = 1 ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 1
4948: ST_TO_ADDR
// for un in units do
4949: LD_ADDR_VAR 0 2
4953: PUSH
4954: LD_VAR 0 5
4958: PUSH
4959: FOR_IN
4960: IFFALSE 5020
// begin if i <= max then
4962: LD_VAR 0 3
4966: PUSH
4967: LD_VAR 0 4
4971: LESSEQUAL
4972: IFFALSE 5004
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
4974: LD_VAR 0 2
4978: PPUSH
4979: LD_VAR 0 6
4983: PUSH
4984: LD_VAR 0 3
4988: PUSH
4989: LD_VAR 0 6
4993: MOD
4994: PUSH
4995: LD_INT 1
4997: PLUS
4998: ARRAY
4999: PPUSH
5000: CALL_OW 120
// i := i + 1 ;
5004: LD_ADDR_VAR 0 3
5008: PUSH
5009: LD_VAR 0 3
5013: PUSH
5014: LD_INT 1
5016: PLUS
5017: ST_TO_ADDR
// end ;
5018: GO 4959
5020: POP
5021: POP
// end ;
5022: LD_VAR 0 1
5026: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5027: LD_INT 0
5029: PPUSH
5030: PPUSH
5031: PPUSH
5032: PPUSH
5033: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5034: LD_ADDR_VAR 0 5
5038: PUSH
5039: LD_INT 22
5041: PUSH
5042: LD_LOC 1
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 2
5053: PUSH
5054: LD_INT 30
5056: PUSH
5057: LD_INT 8
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 30
5066: PUSH
5067: LD_INT 6
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5088: LD_ADDR_VAR 0 4
5092: PUSH
5093: LD_INT 22
5095: PUSH
5096: LD_LOC 1
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 25
5107: PUSH
5108: LD_INT 4
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 69
5123: ST_TO_ADDR
// i = 1 ;
5124: LD_ADDR_VAR 0 3
5128: PUSH
5129: LD_INT 1
5131: ST_TO_ADDR
// for un in units do
5132: LD_ADDR_VAR 0 2
5136: PUSH
5137: LD_VAR 0 4
5141: PUSH
5142: FOR_IN
5143: IFFALSE 5209
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5145: LD_VAR 0 2
5149: PPUSH
5150: LD_VAR 0 5
5154: PUSH
5155: LD_VAR 0 3
5159: PUSH
5160: LD_VAR 0 5
5164: MOD
5165: PUSH
5166: LD_INT 1
5168: PLUS
5169: ARRAY
5170: PPUSH
5171: CALL_OW 120
// i := i + 1 ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: LD_VAR 0 3
5184: PUSH
5185: LD_INT 1
5187: PLUS
5188: ST_TO_ADDR
// if i > ( units div 2 ) then
5189: LD_VAR 0 3
5193: PUSH
5194: LD_VAR 0 4
5198: PUSH
5199: LD_INT 2
5201: DIV
5202: GREATER
5203: IFFALSE 5207
// break ;
5205: GO 5209
// end ;
5207: GO 5142
5209: POP
5210: POP
// end ;
5211: LD_VAR 0 1
5215: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5216: LD_INT 0
5218: PPUSH
5219: PPUSH
5220: PPUSH
5221: PPUSH
5222: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5223: LD_ADDR_VAR 0 5
5227: PUSH
5228: LD_INT 22
5230: PUSH
5231: LD_LOC 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 2
5242: PUSH
5243: LD_INT 30
5245: PUSH
5246: LD_INT 2
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PUSH
5268: EMPTY
5269: LIST
5270: LIST
5271: PPUSH
5272: CALL_OW 69
5276: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5277: LD_ADDR_VAR 0 4
5281: PUSH
5282: LD_INT 22
5284: PUSH
5285: LD_LOC 1
5289: PUSH
5290: EMPTY
5291: LIST
5292: LIST
5293: PUSH
5294: LD_INT 25
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: PPUSH
5308: CALL_OW 69
5312: ST_TO_ADDR
// i = 1 ;
5313: LD_ADDR_VAR 0 3
5317: PUSH
5318: LD_INT 1
5320: ST_TO_ADDR
// for un in units do
5321: LD_ADDR_VAR 0 2
5325: PUSH
5326: LD_VAR 0 4
5330: PUSH
5331: FOR_IN
5332: IFFALSE 5380
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5334: LD_VAR 0 2
5338: PPUSH
5339: LD_VAR 0 5
5343: PUSH
5344: LD_VAR 0 3
5348: PUSH
5349: LD_VAR 0 5
5353: MOD
5354: PUSH
5355: LD_INT 1
5357: PLUS
5358: ARRAY
5359: PPUSH
5360: CALL_OW 120
// i := i + 1 ;
5364: LD_ADDR_VAR 0 3
5368: PUSH
5369: LD_VAR 0 3
5373: PUSH
5374: LD_INT 1
5376: PLUS
5377: ST_TO_ADDR
// end ;
5378: GO 5331
5380: POP
5381: POP
// end ; end_of_file
5382: LD_VAR 0 1
5386: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_americans ; var un , class_list , members ; begin
5387: LD_INT 0
5389: PPUSH
5390: PPUSH
5391: PPUSH
5392: PPUSH
// cpu_side := us ;
5393: LD_ADDR_LOC 4
5397: PUSH
5398: LD_EXP 3
5402: ST_TO_ADDR
// cpu_nation := nation_american ;
5403: LD_ADDR_LOC 5
5407: PUSH
5408: LD_INT 1
5410: ST_TO_ADDR
// cpu_base := us_create ;
5411: LD_ADDR_LOC 6
5415: PUSH
5416: LD_INT 18
5418: ST_TO_ADDR
// members := difficulty * 2 ;
5419: LD_ADDR_VAR 0 4
5423: PUSH
5424: LD_OWVAR 67
5428: PUSH
5429: LD_INT 2
5431: MUL
5432: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
5433: LD_ADDR_VAR 0 3
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: LD_INT 3
5443: PUSH
5444: LD_INT 4
5446: PUSH
5447: LD_INT 2
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: LIST
5454: LIST
5455: ST_TO_ADDR
// for un in class_list do
5456: LD_ADDR_VAR 0 2
5460: PUSH
5461: LD_VAR 0 3
5465: PUSH
5466: FOR_IN
5467: IFFALSE 5500
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5469: LD_LOC 4
5473: PPUSH
5474: LD_LOC 5
5478: PPUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: LD_VAR 0 4
5488: PPUSH
5489: LD_LOC 6
5493: PPUSH
5494: CALL 6838 0 5
5498: GO 5466
5500: POP
5501: POP
// create_units ( cpu_side , cpu_nation , class_mechanic , 2 , cpu_base ) ;
5502: LD_LOC 4
5506: PPUSH
5507: LD_LOC 5
5511: PPUSH
5512: LD_INT 3
5514: PPUSH
5515: LD_INT 2
5517: PPUSH
5518: LD_LOC 6
5522: PPUSH
5523: CALL 6838 0 5
// SetResourceVisibility ( 43 , 81 , 1 ) ;
5527: LD_INT 43
5529: PPUSH
5530: LD_INT 81
5532: PPUSH
5533: LD_INT 1
5535: PPUSH
5536: CALL_OW 441
// SetResourceVisibility ( 30 , 49 , 1 ) ;
5540: LD_INT 30
5542: PPUSH
5543: LD_INT 49
5545: PPUSH
5546: LD_INT 1
5548: PPUSH
5549: CALL_OW 441
// place_all_soldiers ;
5553: CALL 5570 0 0
// place_all_scientistics ;
5557: CALL 5778 0 0
// place_all_mechanics ;
5561: CALL 5967 0 0
// end ;
5565: LD_VAR 0 1
5569: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5570: LD_INT 0
5572: PPUSH
5573: PPUSH
5574: PPUSH
5575: PPUSH
5576: PPUSH
5577: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5578: LD_ADDR_VAR 0 6
5582: PUSH
5583: LD_INT 22
5585: PUSH
5586: LD_LOC 4
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 30
5597: PUSH
5598: LD_INT 32
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 69
5613: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5614: LD_ADDR_VAR 0 5
5618: PUSH
5619: LD_INT 22
5621: PUSH
5622: LD_LOC 4
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: PUSH
5631: LD_INT 25
5633: PUSH
5634: LD_INT 1
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PPUSH
5645: CALL_OW 69
5649: ST_TO_ADDR
// if buildings >= units then
5650: LD_VAR 0 6
5654: PUSH
5655: LD_VAR 0 5
5659: GREATEREQUAL
5660: IFFALSE 5678
// max := 0 + units else
5662: LD_ADDR_VAR 0 4
5666: PUSH
5667: LD_INT 0
5669: PUSH
5670: LD_VAR 0 5
5674: PLUS
5675: ST_TO_ADDR
5676: GO 5692
// max := 0 + buildings ;
5678: LD_ADDR_VAR 0 4
5682: PUSH
5683: LD_INT 0
5685: PUSH
5686: LD_VAR 0 6
5690: PLUS
5691: ST_TO_ADDR
// i = 1 ;
5692: LD_ADDR_VAR 0 3
5696: PUSH
5697: LD_INT 1
5699: ST_TO_ADDR
// for un in units do
5700: LD_ADDR_VAR 0 2
5704: PUSH
5705: LD_VAR 0 5
5709: PUSH
5710: FOR_IN
5711: IFFALSE 5771
// begin if i <= max then
5713: LD_VAR 0 3
5717: PUSH
5718: LD_VAR 0 4
5722: LESSEQUAL
5723: IFFALSE 5755
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5725: LD_VAR 0 2
5729: PPUSH
5730: LD_VAR 0 6
5734: PUSH
5735: LD_VAR 0 3
5739: PUSH
5740: LD_VAR 0 6
5744: MOD
5745: PUSH
5746: LD_INT 1
5748: PLUS
5749: ARRAY
5750: PPUSH
5751: CALL_OW 120
// i := i + 1 ;
5755: LD_ADDR_VAR 0 3
5759: PUSH
5760: LD_VAR 0 3
5764: PUSH
5765: LD_INT 1
5767: PLUS
5768: ST_TO_ADDR
// end ;
5769: GO 5710
5771: POP
5772: POP
// end ;
5773: LD_VAR 0 1
5777: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5778: LD_INT 0
5780: PPUSH
5781: PPUSH
5782: PPUSH
5783: PPUSH
5784: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5785: LD_ADDR_VAR 0 5
5789: PUSH
5790: LD_INT 22
5792: PUSH
5793: LD_LOC 4
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 2
5804: PUSH
5805: LD_INT 30
5807: PUSH
5808: LD_INT 8
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 30
5817: PUSH
5818: LD_INT 6
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: PPUSH
5834: CALL_OW 69
5838: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5839: LD_ADDR_VAR 0 4
5843: PUSH
5844: LD_INT 22
5846: PUSH
5847: LD_LOC 4
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: PUSH
5856: LD_INT 25
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: CALL_OW 69
5874: ST_TO_ADDR
// i = 1 ;
5875: LD_ADDR_VAR 0 3
5879: PUSH
5880: LD_INT 1
5882: ST_TO_ADDR
// for un in units do
5883: LD_ADDR_VAR 0 2
5887: PUSH
5888: LD_VAR 0 4
5892: PUSH
5893: FOR_IN
5894: IFFALSE 5960
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5896: LD_VAR 0 2
5900: PPUSH
5901: LD_VAR 0 5
5905: PUSH
5906: LD_VAR 0 3
5910: PUSH
5911: LD_VAR 0 5
5915: MOD
5916: PUSH
5917: LD_INT 1
5919: PLUS
5920: ARRAY
5921: PPUSH
5922: CALL_OW 120
// i := i + 1 ;
5926: LD_ADDR_VAR 0 3
5930: PUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 1
5938: PLUS
5939: ST_TO_ADDR
// if i > ( units div 2 ) then
5940: LD_VAR 0 3
5944: PUSH
5945: LD_VAR 0 4
5949: PUSH
5950: LD_INT 2
5952: DIV
5953: GREATER
5954: IFFALSE 5958
// break ;
5956: GO 5960
// end ;
5958: GO 5893
5960: POP
5961: POP
// end ;
5962: LD_VAR 0 1
5966: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5967: LD_INT 0
5969: PPUSH
5970: PPUSH
5971: PPUSH
5972: PPUSH
5973: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5974: LD_ADDR_VAR 0 5
5978: PUSH
5979: LD_INT 22
5981: PUSH
5982: LD_LOC 4
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: PUSH
5991: LD_INT 2
5993: PUSH
5994: LD_INT 30
5996: PUSH
5997: LD_INT 2
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: PUSH
6004: LD_INT 30
6006: PUSH
6007: LD_INT 3
6009: PUSH
6010: EMPTY
6011: LIST
6012: LIST
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL_OW 69
6027: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6028: LD_ADDR_VAR 0 4
6032: PUSH
6033: LD_INT 22
6035: PUSH
6036: LD_LOC 4
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 25
6047: PUSH
6048: LD_INT 3
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PPUSH
6059: CALL_OW 69
6063: ST_TO_ADDR
// i = 1 ;
6064: LD_ADDR_VAR 0 3
6068: PUSH
6069: LD_INT 1
6071: ST_TO_ADDR
// for un in units do
6072: LD_ADDR_VAR 0 2
6076: PUSH
6077: LD_VAR 0 4
6081: PUSH
6082: FOR_IN
6083: IFFALSE 6131
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6085: LD_VAR 0 2
6089: PPUSH
6090: LD_VAR 0 5
6094: PUSH
6095: LD_VAR 0 3
6099: PUSH
6100: LD_VAR 0 5
6104: MOD
6105: PUSH
6106: LD_INT 1
6108: PLUS
6109: ARRAY
6110: PPUSH
6111: CALL_OW 120
// i := i + 1 ;
6115: LD_ADDR_VAR 0 3
6119: PUSH
6120: LD_VAR 0 3
6124: PUSH
6125: LD_INT 1
6127: PLUS
6128: ST_TO_ADDR
// end ;
6129: GO 6082
6131: POP
6132: POP
// end ; end_of_file
6133: LD_VAR 0 1
6137: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_arabians ; var un , class_list , members ; begin
6138: LD_INT 0
6140: PPUSH
6141: PPUSH
6142: PPUSH
6143: PPUSH
// cpu_side := ar ;
6144: LD_ADDR_LOC 7
6148: PUSH
6149: LD_EXP 4
6153: ST_TO_ADDR
// cpu_nation := nation_arabian ;
6154: LD_ADDR_LOC 8
6158: PUSH
6159: LD_INT 2
6161: ST_TO_ADDR
// cpu_base := ar_create ;
6162: LD_ADDR_LOC 9
6166: PUSH
6167: LD_INT 19
6169: ST_TO_ADDR
// members := difficulty + 1 ;
6170: LD_ADDR_VAR 0 4
6174: PUSH
6175: LD_OWVAR 67
6179: PUSH
6180: LD_INT 1
6182: PLUS
6183: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
6184: LD_ADDR_VAR 0 3
6188: PUSH
6189: LD_INT 1
6191: PUSH
6192: LD_INT 3
6194: PUSH
6195: LD_INT 4
6197: PUSH
6198: LD_INT 2
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: ST_TO_ADDR
// for un in class_list do
6207: LD_ADDR_VAR 0 2
6211: PUSH
6212: LD_VAR 0 3
6216: PUSH
6217: FOR_IN
6218: IFFALSE 6251
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
6220: LD_LOC 7
6224: PPUSH
6225: LD_LOC 8
6229: PPUSH
6230: LD_VAR 0 2
6234: PPUSH
6235: LD_VAR 0 4
6239: PPUSH
6240: LD_LOC 9
6244: PPUSH
6245: CALL 6838 0 5
6249: GO 6217
6251: POP
6252: POP
// place_all_soldiers ;
6253: CALL 6270 0 0
// place_all_scientistics ;
6257: CALL 6478 0 0
// place_all_mechanics ;
6261: CALL 6667 0 0
// end ;
6265: LD_VAR 0 1
6269: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
6274: PPUSH
6275: PPUSH
6276: PPUSH
6277: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
6278: LD_ADDR_VAR 0 6
6282: PUSH
6283: LD_INT 22
6285: PUSH
6286: LD_LOC 7
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: PUSH
6295: LD_INT 30
6297: PUSH
6298: LD_INT 32
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PPUSH
6309: CALL_OW 69
6313: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
6314: LD_ADDR_VAR 0 5
6318: PUSH
6319: LD_INT 22
6321: PUSH
6322: LD_LOC 7
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 25
6333: PUSH
6334: LD_INT 1
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PPUSH
6345: CALL_OW 69
6349: ST_TO_ADDR
// if buildings >= units then
6350: LD_VAR 0 6
6354: PUSH
6355: LD_VAR 0 5
6359: GREATEREQUAL
6360: IFFALSE 6378
// max := 0 + units else
6362: LD_ADDR_VAR 0 4
6366: PUSH
6367: LD_INT 0
6369: PUSH
6370: LD_VAR 0 5
6374: PLUS
6375: ST_TO_ADDR
6376: GO 6392
// max := 0 + buildings ;
6378: LD_ADDR_VAR 0 4
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: LD_VAR 0 6
6390: PLUS
6391: ST_TO_ADDR
// i = 1 ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: LD_INT 1
6399: ST_TO_ADDR
// for un in units do
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: LD_VAR 0 5
6409: PUSH
6410: FOR_IN
6411: IFFALSE 6471
// begin if i <= max then
6413: LD_VAR 0 3
6417: PUSH
6418: LD_VAR 0 4
6422: LESSEQUAL
6423: IFFALSE 6455
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6425: LD_VAR 0 2
6429: PPUSH
6430: LD_VAR 0 6
6434: PUSH
6435: LD_VAR 0 3
6439: PUSH
6440: LD_VAR 0 6
6444: MOD
6445: PUSH
6446: LD_INT 1
6448: PLUS
6449: ARRAY
6450: PPUSH
6451: CALL_OW 120
// i := i + 1 ;
6455: LD_ADDR_VAR 0 3
6459: PUSH
6460: LD_VAR 0 3
6464: PUSH
6465: LD_INT 1
6467: PLUS
6468: ST_TO_ADDR
// end ;
6469: GO 6410
6471: POP
6472: POP
// end ;
6473: LD_VAR 0 1
6477: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6478: LD_INT 0
6480: PPUSH
6481: PPUSH
6482: PPUSH
6483: PPUSH
6484: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6485: LD_ADDR_VAR 0 5
6489: PUSH
6490: LD_INT 22
6492: PUSH
6493: LD_LOC 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: LD_INT 30
6507: PUSH
6508: LD_INT 8
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 30
6517: PUSH
6518: LD_INT 6
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PPUSH
6534: CALL_OW 69
6538: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6539: LD_ADDR_VAR 0 4
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_LOC 7
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 25
6558: PUSH
6559: LD_INT 4
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PPUSH
6570: CALL_OW 69
6574: ST_TO_ADDR
// i = 1 ;
6575: LD_ADDR_VAR 0 3
6579: PUSH
6580: LD_INT 1
6582: ST_TO_ADDR
// for un in units do
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_VAR 0 4
6592: PUSH
6593: FOR_IN
6594: IFFALSE 6660
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6596: LD_VAR 0 2
6600: PPUSH
6601: LD_VAR 0 5
6605: PUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_VAR 0 5
6615: MOD
6616: PUSH
6617: LD_INT 1
6619: PLUS
6620: ARRAY
6621: PPUSH
6622: CALL_OW 120
// i := i + 1 ;
6626: LD_ADDR_VAR 0 3
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 1
6638: PLUS
6639: ST_TO_ADDR
// if i > ( units div 2 ) then
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 4
6649: PUSH
6650: LD_INT 2
6652: DIV
6653: GREATER
6654: IFFALSE 6658
// break ;
6656: GO 6660
// end ;
6658: GO 6593
6660: POP
6661: POP
// end ;
6662: LD_VAR 0 1
6666: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6667: LD_INT 0
6669: PPUSH
6670: PPUSH
6671: PPUSH
6672: PPUSH
6673: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6674: LD_ADDR_VAR 0 5
6678: PUSH
6679: LD_INT 22
6681: PUSH
6682: LD_LOC 7
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: PUSH
6691: LD_INT 2
6693: PUSH
6694: LD_INT 30
6696: PUSH
6697: LD_INT 2
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 30
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: LIST
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6728: LD_ADDR_VAR 0 4
6732: PUSH
6733: LD_INT 22
6735: PUSH
6736: LD_LOC 7
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: PUSH
6745: LD_INT 25
6747: PUSH
6748: LD_INT 3
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PPUSH
6759: CALL_OW 69
6763: ST_TO_ADDR
// i = 1 ;
6764: LD_ADDR_VAR 0 3
6768: PUSH
6769: LD_INT 1
6771: ST_TO_ADDR
// for un in units do
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: LD_VAR 0 4
6781: PUSH
6782: FOR_IN
6783: IFFALSE 6831
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_VAR 0 5
6794: PUSH
6795: LD_VAR 0 3
6799: PUSH
6800: LD_VAR 0 5
6804: MOD
6805: PUSH
6806: LD_INT 1
6808: PLUS
6809: ARRAY
6810: PPUSH
6811: CALL_OW 120
// i := i + 1 ;
6815: LD_ADDR_VAR 0 3
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: LD_INT 1
6827: PLUS
6828: ST_TO_ADDR
// end ;
6829: GO 6782
6831: POP
6832: POP
// end ; end_of_file
6833: LD_VAR 0 1
6837: RET
// export function create_units ( side , nation , class_n , num , area ) ; var i , un , lev ; begin
6838: LD_INT 0
6840: PPUSH
6841: PPUSH
6842: PPUSH
6843: PPUSH
// if class_n = class_scientistic then
6844: LD_VAR 0 3
6848: PUSH
6849: LD_INT 4
6851: EQUAL
6852: IFFALSE 6906
// begin lev := [ 3 , 6 , 10 ] [ difficulty ] ;
6854: LD_ADDR_VAR 0 9
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: LD_INT 6
6864: PUSH
6865: LD_INT 10
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: PUSH
6873: LD_OWVAR 67
6877: ARRAY
6878: ST_TO_ADDR
// num := [ 2 , 4 , 6 ] [ difficulty ] ;
6879: LD_ADDR_VAR 0 4
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: LD_INT 4
6889: PUSH
6890: LD_INT 6
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_OWVAR 67
6902: ARRAY
6903: ST_TO_ADDR
// end else
6904: GO 6976
// if class_n = class_soldier then
6906: LD_VAR 0 3
6910: PUSH
6911: LD_INT 1
6913: EQUAL
6914: IFFALSE 6951
// begin lev := [ 5 , 7 , 10 ] [ difficulty ] ;
6916: LD_ADDR_VAR 0 9
6920: PUSH
6921: LD_INT 5
6923: PUSH
6924: LD_INT 7
6926: PUSH
6927: LD_INT 10
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: ST_TO_ADDR
// num := 6 ;
6941: LD_ADDR_VAR 0 4
6945: PUSH
6946: LD_INT 6
6948: ST_TO_ADDR
// end else
6949: GO 6976
// lev := [ 4 , 6 , 10 ] [ difficulty ] ;
6951: LD_ADDR_VAR 0 9
6955: PUSH
6956: LD_INT 4
6958: PUSH
6959: LD_INT 6
6961: PUSH
6962: LD_INT 10
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: LIST
6969: PUSH
6970: LD_OWVAR 67
6974: ARRAY
6975: ST_TO_ADDR
// uc_side := side ;
6976: LD_ADDR_OWVAR 20
6980: PUSH
6981: LD_VAR 0 1
6985: ST_TO_ADDR
// uc_nation := nation ;
6986: LD_ADDR_OWVAR 21
6990: PUSH
6991: LD_VAR 0 2
6995: ST_TO_ADDR
// for i = 1 to num do
6996: LD_ADDR_VAR 0 7
7000: PUSH
7001: DOUBLE
7002: LD_INT 1
7004: DEC
7005: ST_TO_ADDR
7006: LD_VAR 0 4
7010: PUSH
7011: FOR_TO
7012: IFFALSE 7157
// begin uc_direction := Rand ( 0 , 5 ) ;
7014: LD_ADDR_OWVAR 24
7018: PUSH
7019: LD_INT 0
7021: PPUSH
7022: LD_INT 5
7024: PPUSH
7025: CALL_OW 12
7029: ST_TO_ADDR
// case class_n of 1 :
7030: LD_VAR 0 3
7034: PUSH
7035: LD_INT 1
7037: DOUBLE
7038: EQUAL
7039: IFTRUE 7043
7041: GO 7058
7043: POP
// PrepareSoldier ( 0 , lev ) ; 2 :
7044: LD_INT 0
7046: PPUSH
7047: LD_VAR 0 9
7051: PPUSH
7052: CALL_OW 381
7056: GO 7128
7058: LD_INT 2
7060: DOUBLE
7061: EQUAL
7062: IFTRUE 7066
7064: GO 7081
7066: POP
// PrepareEngineer ( 0 , lev ) ; 3 :
7067: LD_INT 0
7069: PPUSH
7070: LD_VAR 0 9
7074: PPUSH
7075: CALL_OW 382
7079: GO 7128
7081: LD_INT 3
7083: DOUBLE
7084: EQUAL
7085: IFTRUE 7089
7087: GO 7104
7089: POP
// PrepareMechanic ( 0 , lev ) ; 4 :
7090: LD_INT 0
7092: PPUSH
7093: LD_VAR 0 9
7097: PPUSH
7098: CALL_OW 383
7102: GO 7128
7104: LD_INT 4
7106: DOUBLE
7107: EQUAL
7108: IFTRUE 7112
7110: GO 7127
7112: POP
// PrepareScientist ( 0 , lev ) ; end ;
7113: LD_INT 0
7115: PPUSH
7116: LD_VAR 0 9
7120: PPUSH
7121: CALL_OW 384
7125: GO 7128
7127: POP
// un := CreateHuman ;
7128: LD_ADDR_VAR 0 8
7132: PUSH
7133: CALL_OW 44
7137: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7138: LD_VAR 0 8
7142: PPUSH
7143: LD_VAR 0 5
7147: PPUSH
7148: LD_INT 0
7150: PPUSH
7151: CALL_OW 49
// end ;
7155: GO 7011
7157: POP
7158: POP
// end ;
7159: LD_VAR 0 6
7163: RET
// export function prepare_apemans ; var ape , i ; begin
7164: LD_INT 0
7166: PPUSH
7167: PPUSH
7168: PPUSH
// for i = 1 to ( 6 - difficulty ) do
7169: LD_ADDR_VAR 0 3
7173: PUSH
7174: DOUBLE
7175: LD_INT 1
7177: DEC
7178: ST_TO_ADDR
7179: LD_INT 6
7181: PUSH
7182: LD_OWVAR 67
7186: MINUS
7187: PUSH
7188: FOR_TO
7189: IFFALSE 7389
// begin uc_side := neutral ;
7191: LD_ADDR_OWVAR 20
7195: PUSH
7196: LD_EXP 6
7200: ST_TO_ADDR
// uc_nation := nation_nature ;
7201: LD_ADDR_OWVAR 21
7205: PUSH
7206: LD_INT 0
7208: ST_TO_ADDR
// hc_class := class_apeman ;
7209: LD_ADDR_OWVAR 28
7213: PUSH
7214: LD_INT 12
7216: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) ] ;
7217: LD_ADDR_OWVAR 30
7221: PUSH
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 2
7227: PPUSH
7228: CALL_OW 12
7232: PUSH
7233: LD_INT 1
7235: PPUSH
7236: LD_INT 2
7238: PPUSH
7239: CALL_OW 12
7243: PUSH
7244: LD_INT 1
7246: PPUSH
7247: LD_INT 2
7249: PPUSH
7250: CALL_OW 12
7254: PUSH
7255: LD_INT 1
7257: PPUSH
7258: LD_INT 2
7260: PPUSH
7261: CALL_OW 12
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: ST_TO_ADDR
// hc_skills := [ 3 , 3 , 3 , 3 ] ;
7272: LD_ADDR_OWVAR 31
7276: PUSH
7277: LD_INT 3
7279: PUSH
7280: LD_INT 3
7282: PUSH
7283: LD_INT 3
7285: PUSH
7286: LD_INT 3
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
7295: LD_ADDR_OWVAR 29
7299: PUSH
7300: LD_INT 10
7302: PUSH
7303: LD_INT 12
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: ST_TO_ADDR
// hc_sex := [ sex_female , sex_male ] [ Rand ( 1 , 2 ) ] ;
7310: LD_ADDR_OWVAR 27
7314: PUSH
7315: LD_INT 2
7317: PUSH
7318: LD_INT 1
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 1
7327: PPUSH
7328: LD_INT 2
7330: PPUSH
7331: CALL_OW 12
7335: ARRAY
7336: ST_TO_ADDR
// hc_importance := 0 ;
7337: LD_ADDR_OWVAR 32
7341: PUSH
7342: LD_INT 0
7344: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
7345: LD_ADDR_OWVAR 35
7349: PUSH
7350: LD_INT 20
7352: NEG
7353: PPUSH
7354: LD_INT 20
7356: PPUSH
7357: CALL_OW 12
7361: ST_TO_ADDR
// ape := CreateHuman ;
7362: LD_ADDR_VAR 0 2
7366: PUSH
7367: CALL_OW 44
7371: ST_TO_ADDR
// PlaceUnitArea ( ape , apeman_forest , false ) ;
7372: LD_VAR 0 2
7376: PPUSH
7377: LD_INT 32
7379: PPUSH
7380: LD_INT 0
7382: PPUSH
7383: CALL_OW 49
// end ;
7387: GO 7188
7389: POP
7390: POP
// end ; end_of_file
7391: LD_VAR 0 1
7395: RET
// var alien_tower_spoted ; export function starting_scene ; var check_time ; begin
7396: LD_INT 0
7398: PPUSH
7399: PPUSH
// CenterNowOnXY ( 75 , 27 ) ;
7400: LD_INT 75
7402: PPUSH
7403: LD_INT 27
7405: PPUSH
7406: CALL_OW 86
// wait ( 0 0$1 ) ;
7410: LD_INT 35
7412: PPUSH
7413: CALL_OW 67
// InGameOn ;
7417: CALL_OW 8
// ComMoveToArea ( IsInUnit ( Burlak ) , burlak_panorama_area ) ;
7421: LD_EXP 12
7425: PPUSH
7426: CALL_OW 310
7430: PPUSH
7431: LD_INT 8
7433: PPUSH
7434: CALL_OW 113
// ComMoveToArea ( IsInUnit ( MacMillan ) , jmm_panorama_area ) ;
7438: LD_EXP 13
7442: PPUSH
7443: CALL_OW 310
7447: PPUSH
7448: LD_INT 28
7450: PPUSH
7451: CALL_OW 113
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
7455: LD_EXP 13
7459: PUSH
7460: LD_EXP 12
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PPUSH
7469: CALL_OW 85
// repeat wait ( 20 ) ;
7473: LD_INT 20
7475: PPUSH
7476: CALL_OW 67
// until IsInArea ( Burlak , burlak_panorama_area ) and IsInArea ( MacMillan , jmm_panorama_area ) ;
7480: LD_EXP 12
7484: PPUSH
7485: LD_INT 8
7487: PPUSH
7488: CALL_OW 308
7492: PUSH
7493: LD_EXP 13
7497: PPUSH
7498: LD_INT 28
7500: PPUSH
7501: CALL_OW 308
7505: AND
7506: IFFALSE 7473
// ComExitVehicle ( [ Burlak , MacMillan ] ) ;
7508: LD_EXP 12
7512: PUSH
7513: LD_EXP 13
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PPUSH
7522: CALL_OW 121
// while IsInUnit ( Burlak ) or IsInUnit ( MacMillan ) do
7526: LD_EXP 12
7530: PPUSH
7531: CALL_OW 310
7535: PUSH
7536: LD_EXP 13
7540: PPUSH
7541: CALL_OW 310
7545: OR
7546: IFFALSE 7557
// wait ( 5 ) ;
7548: LD_INT 5
7550: PPUSH
7551: CALL_OW 67
7555: GO 7526
// wait ( 10 ) ;
7557: LD_INT 10
7559: PPUSH
7560: CALL_OW 67
// ComMoveToArea ( Burlak , burlak_talking_panorama ) ;
7564: LD_EXP 12
7568: PPUSH
7569: LD_INT 9
7571: PPUSH
7572: CALL_OW 113
// ComMoveToArea ( MacMillan , jmm_talking_panorama ) ;
7576: LD_EXP 13
7580: PPUSH
7581: LD_INT 29
7583: PPUSH
7584: CALL_OW 113
// check_time := TICK ;
7588: LD_ADDR_VAR 0 2
7592: PUSH
7593: LD_OWVAR 1
7597: ST_TO_ADDR
// repeat ComHold ( FilterUnitsInArea ( burlak_talking_panorama , [ [ f_side , you ] ] ) ) ;
7598: LD_INT 9
7600: PPUSH
7601: LD_INT 22
7603: PUSH
7604: LD_EXP 1
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: EMPTY
7614: LIST
7615: PPUSH
7616: CALL_OW 70
7620: PPUSH
7621: CALL_OW 140
// ComHold ( FilterUnitsInArea ( jmm_talking_panorama , [ [ f_side , you ] ] ) ) ;
7625: LD_INT 29
7627: PPUSH
7628: LD_INT 22
7630: PUSH
7631: LD_EXP 1
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PUSH
7640: EMPTY
7641: LIST
7642: PPUSH
7643: CALL_OW 70
7647: PPUSH
7648: CALL_OW 140
// wait ( 0 0$1 ) ;
7652: LD_INT 35
7654: PPUSH
7655: CALL_OW 67
// until ( IsInArea ( Burlak , burlak_talking_panorama ) and IsInArea ( MacMillan , jmm_talking_panorama ) ) or ( check_time < ( TICK - 0 0$4 ) ) ;
7659: LD_EXP 12
7663: PPUSH
7664: LD_INT 9
7666: PPUSH
7667: CALL_OW 308
7671: PUSH
7672: LD_EXP 13
7676: PPUSH
7677: LD_INT 29
7679: PPUSH
7680: CALL_OW 308
7684: AND
7685: PUSH
7686: LD_VAR 0 2
7690: PUSH
7691: LD_OWVAR 1
7695: PUSH
7696: LD_INT 140
7698: MINUS
7699: LESS
7700: OR
7701: IFFALSE 7598
// ComTurnUnit ( MacMillan , Burlak ) ;
7703: LD_EXP 13
7707: PPUSH
7708: LD_EXP 12
7712: PPUSH
7713: CALL_OW 119
// ComTurnUnit ( Burlak , MacMillan ) ;
7717: LD_EXP 12
7721: PPUSH
7722: LD_EXP 13
7726: PPUSH
7727: CALL_OW 119
// CenterOnXY ( 77 , 31 ) ;
7731: LD_INT 77
7733: PPUSH
7734: LD_INT 31
7736: PPUSH
7737: CALL_OW 84
// wait ( 10 ) ;
7741: LD_INT 10
7743: PPUSH
7744: CALL_OW 67
// InGameOff ;
7748: CALL_OW 9
// DialogueOn ;
7752: CALL_OW 6
// interface_hidden := true ;
7756: LD_ADDR_OWVAR 54
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// case camp of 4 :
7764: LD_EXP 7
7768: PUSH
7769: LD_INT 4
7771: DOUBLE
7772: EQUAL
7773: IFTRUE 7777
7775: GO 7828
7777: POP
// begin Say ( MacMillan , DStart-JMM-JMM-1 ) ;
7778: LD_EXP 13
7782: PPUSH
7783: LD_STRING DStart-JMM-JMM-1
7785: PPUSH
7786: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
7790: LD_EXP 12
7794: PPUSH
7795: LD_STRING DStart-JMM-Bur-1
7797: PPUSH
7798: CALL_OW 88
// Say ( MacMillan , DStart-JMM-JMM-2 ) ;
7802: LD_EXP 13
7806: PPUSH
7807: LD_STRING DStart-JMM-JMM-2
7809: PPUSH
7810: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
7814: LD_EXP 12
7818: PPUSH
7819: LD_STRING DStart-JMM-Bur-2
7821: PPUSH
7822: CALL_OW 88
// end ; 6 :
7826: GO 7876
7828: LD_INT 6
7830: DOUBLE
7831: EQUAL
7832: IFTRUE 7836
7834: GO 7875
7836: POP
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
7837: LD_EXP 12
7841: PPUSH
7842: LD_STRING DStart-Burlak-Bur-1
7844: PPUSH
7845: CALL_OW 88
// Say ( Macmillan , DStart-Burlak-JMM-1 ) ;
7849: LD_EXP 13
7853: PPUSH
7854: LD_STRING DStart-Burlak-JMM-1
7856: PPUSH
7857: CALL_OW 88
// Say ( Burlak , DStart-Burlak-Bur-2 ) ;
7861: LD_EXP 12
7865: PPUSH
7866: LD_STRING DStart-Burlak-Bur-2
7868: PPUSH
7869: CALL_OW 88
// end ; end ;
7873: GO 7876
7875: POP
// SaveForQuickRestart ;
7876: CALL_OW 22
// wait ( 20 ) ;
7880: LD_INT 20
7882: PPUSH
7883: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
7887: LD_STRING MStart
7889: PPUSH
7890: CALL_OW 337
// interface_hidden := false ;
7894: LD_ADDR_OWVAR 54
7898: PUSH
7899: LD_INT 0
7901: ST_TO_ADDR
// DialogueOff ;
7902: CALL_OW 7
// us_researched := false ;
7906: LD_ADDR_EXP 62
7910: PUSH
7911: LD_INT 0
7913: ST_TO_ADDR
// us_researched := true ;
7914: LD_ADDR_EXP 62
7918: PUSH
7919: LD_INT 1
7921: ST_TO_ADDR
// omar_in_contact := false ;
7922: LD_ADDR_EXP 65
7926: PUSH
7927: LD_INT 0
7929: ST_TO_ADDR
// alien_tower_spoted := false ;
7930: LD_ADDR_LOC 10
7934: PUSH
7935: LD_INT 0
7937: ST_TO_ADDR
// one_enabled := false ;
7938: LD_ADDR_EXP 64
7942: PUSH
7943: LD_INT 0
7945: ST_TO_ADDR
// end ;
7946: LD_VAR 0 1
7950: RET
// every 0 0$2.3 trigger See ( you , al_tower ) do var un , sol , sci ;
7951: LD_EXP 1
7955: PPUSH
7956: LD_INT 108
7958: PPUSH
7959: CALL_OW 292
7963: IFFALSE 8469
7965: GO 7967
7967: DISABLE
7968: LD_INT 0
7970: PPUSH
7971: PPUSH
7972: PPUSH
// begin repeat wait ( 0 0$1 ) ;
7973: LD_INT 35
7975: PPUSH
7976: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] , f_not , [ f_inside ] ] ) ;
7980: LD_INT 22
7982: PUSH
7983: LD_EXP 4
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: PUSH
7992: LD_INT 21
7994: PUSH
7995: LD_INT 1
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: LD_INT 50
8004: PUSH
8005: EMPTY
8006: LIST
8007: PUSH
8008: LD_INT 3
8010: PUSH
8011: LD_INT 54
8013: PUSH
8014: EMPTY
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: NOT
8029: IFFALSE 7973
// wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// cpu_list := cpu_list diff ar ;
8038: LD_ADDR_EXP 8
8042: PUSH
8043: LD_EXP 8
8047: PUSH
8048: LD_EXP 4
8052: DIFF
8053: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8054: LD_ADDR_VAR 0 1
8058: PUSH
8059: LD_INT 22
8061: PUSH
8062: LD_EXP 1
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PUSH
8071: LD_INT 26
8073: PUSH
8074: LD_INT 1
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PPUSH
8085: CALL_OW 69
8089: PUSH
8090: LD_EXP 13
8094: PUSH
8095: LD_EXP 12
8099: PUSH
8100: LD_EXP 14
8104: PUSH
8105: LD_EXP 15
8109: PUSH
8110: LD_INT 0
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: LIST
8117: LIST
8118: LIST
8119: DIFF
8120: ST_TO_ADDR
// if un then
8121: LD_VAR 0 1
8125: IFFALSE 8145
// sol := FindMaxSkill ( un , skill_combat ) ;
8127: LD_ADDR_VAR 0 2
8131: PUSH
8132: LD_VAR 0 1
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: CALL_OW 433
8144: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , sol , 0 ] ;
8145: LD_ADDR_VAR 0 1
8149: PUSH
8150: LD_INT 22
8152: PUSH
8153: LD_EXP 1
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: LD_INT 26
8164: PUSH
8165: LD_INT 1
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: PPUSH
8176: CALL_OW 69
8180: PUSH
8181: LD_EXP 13
8185: PUSH
8186: LD_EXP 12
8190: PUSH
8191: LD_EXP 14
8195: PUSH
8196: LD_EXP 15
8200: PUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 0
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: DIFF
8217: ST_TO_ADDR
// if un then
8218: LD_VAR 0 1
8222: IFFALSE 8242
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8224: LD_ADDR_VAR 0 3
8228: PUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 433
8241: ST_TO_ADDR
// PlaceSeeing ( 248 , 183 , you , 10 ) ;
8242: LD_INT 248
8244: PPUSH
8245: LD_INT 183
8247: PPUSH
8248: LD_EXP 1
8252: PPUSH
8253: LD_INT 10
8255: PPUSH
8256: CALL_OW 330
// CenterOnUnits ( al_tower ) ;
8260: LD_INT 108
8262: PPUSH
8263: CALL_OW 85
// DialogueOn ;
8267: CALL_OW 6
// interface_hidden := true ;
8271: LD_ADDR_OWVAR 54
8275: PUSH
8276: LD_INT 1
8278: ST_TO_ADDR
// Say ( sol , DAlienBase-Rsol1-1 ) ;
8279: LD_VAR 0 2
8283: PPUSH
8284: LD_STRING DAlienBase-Rsol1-1
8286: PPUSH
8287: CALL_OW 88
// case camp of 4 :
8291: LD_EXP 7
8295: PUSH
8296: LD_INT 4
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8355
8304: POP
// begin Say ( MacMillan , DAlienBase-JMM-1 ) ;
8305: LD_EXP 13
8309: PPUSH
8310: LD_STRING DAlienBase-JMM-1
8312: PPUSH
8313: CALL_OW 88
// Say ( Roth , DAlienBase-Roth-1 ) ;
8317: LD_EXP 14
8321: PPUSH
8322: LD_STRING DAlienBase-Roth-1
8324: PPUSH
8325: CALL_OW 88
// if not IsOK ( Roth ) then
8329: LD_EXP 14
8333: PPUSH
8334: CALL_OW 302
8338: NOT
8339: IFFALSE 8353
// Say ( sci , DAlienBase-Sci1-1 ) ;
8341: LD_VAR 0 3
8345: PPUSH
8346: LD_STRING DAlienBase-Sci1-1
8348: PPUSH
8349: CALL_OW 88
// end ; 6 :
8353: GO 8415
8355: LD_INT 6
8357: DOUBLE
8358: EQUAL
8359: IFTRUE 8363
8361: GO 8414
8363: POP
// begin Say ( Burlak , DAlienBase-Bur-1 ) ;
8364: LD_EXP 12
8368: PPUSH
8369: LD_STRING DAlienBase-Bur-1
8371: PPUSH
8372: CALL_OW 88
// Say ( Gossudarov , DAlienBase-Gos-1 ) ;
8376: LD_EXP 15
8380: PPUSH
8381: LD_STRING DAlienBase-Gos-1
8383: PPUSH
8384: CALL_OW 88
// if not IsOK ( Gossudarov ) then
8388: LD_EXP 15
8392: PPUSH
8393: CALL_OW 302
8397: NOT
8398: IFFALSE 8412
// Say ( sci , DAlienBase-Sci1-1 ) ;
8400: LD_VAR 0 3
8404: PPUSH
8405: LD_STRING DAlienBase-Sci1-1
8407: PPUSH
8408: CALL_OW 88
// end ; end ;
8412: GO 8415
8414: POP
// SetSide ( al_tower , you ) ;
8415: LD_INT 108
8417: PPUSH
8418: LD_EXP 1
8422: PPUSH
8423: CALL_OW 235
// RemoveSeeing ( 248 , 183 , you ) ;
8427: LD_INT 248
8429: PPUSH
8430: LD_INT 183
8432: PPUSH
8433: LD_EXP 1
8437: PPUSH
8438: CALL_OW 331
// interface_hidden := false ;
8442: LD_ADDR_OWVAR 54
8446: PUSH
8447: LD_INT 0
8449: ST_TO_ADDR
// DialogueOff ;
8450: CALL_OW 7
// Hint ( ArtefactBuilding ) ;
8454: LD_STRING ArtefactBuilding
8456: PPUSH
8457: CALL_OW 339
// alien_tower_spoted := true ;
8461: LD_ADDR_LOC 10
8465: PUSH
8466: LD_INT 1
8468: ST_TO_ADDR
// end ;
8469: PPOPN 3
8471: END
// every 0 0$4.6 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] , [ f_lives , 1000 ] ] ) and alien_tower_spoted do var un , sci ;
8472: LD_INT 22
8474: PUSH
8475: LD_EXP 1
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: LD_INT 2
8486: PUSH
8487: LD_INT 30
8489: PUSH
8490: LD_INT 6
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: LD_INT 30
8499: PUSH
8500: LD_INT 7
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 24
8514: PUSH
8515: LD_INT 1000
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: LIST
8526: PPUSH
8527: CALL_OW 69
8531: PUSH
8532: LD_LOC 10
8536: AND
8537: IFFALSE 8805
8539: GO 8541
8541: DISABLE
8542: LD_INT 0
8544: PPUSH
8545: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8546: LD_ADDR_VAR 0 1
8550: PUSH
8551: LD_INT 22
8553: PUSH
8554: LD_EXP 1
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 26
8565: PUSH
8566: LD_INT 1
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: PUSH
8582: LD_EXP 13
8586: PUSH
8587: LD_EXP 12
8591: PUSH
8592: LD_EXP 14
8596: PUSH
8597: LD_EXP 15
8601: PUSH
8602: LD_INT 0
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: DIFF
8612: ST_TO_ADDR
// if un then
8613: LD_VAR 0 1
8617: IFFALSE 8637
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8619: LD_ADDR_VAR 0 2
8623: PUSH
8624: LD_VAR 0 1
8628: PPUSH
8629: LD_INT 4
8631: PPUSH
8632: CALL_OW 433
8636: ST_TO_ADDR
// CenterOnUnits ( al_tower ) ;
8637: LD_INT 108
8639: PPUSH
8640: CALL_OW 85
// DialogueOn ;
8644: CALL_OW 6
// interface_hidden := true ;
8648: LD_ADDR_OWVAR 54
8652: PUSH
8653: LD_INT 1
8655: ST_TO_ADDR
// case camp of 4 :
8656: LD_EXP 7
8660: PUSH
8661: LD_INT 4
8663: DOUBLE
8664: EQUAL
8665: IFTRUE 8669
8667: GO 8709
8669: POP
// if IsOK ( Gossudarov ) then
8670: LD_EXP 15
8674: PPUSH
8675: CALL_OW 302
8679: IFFALSE 8695
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
8681: LD_EXP 15
8685: PPUSH
8686: LD_STRING DAlieBaseNotReady-Gos-1
8688: PPUSH
8689: CALL_OW 88
8693: GO 8707
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) ; 6 :
8695: LD_EXP 14
8699: PPUSH
8700: LD_STRING DAlieBaseNotReady-Roth-1
8702: PPUSH
8703: CALL_OW 88
8707: GO 8758
8709: LD_INT 6
8711: DOUBLE
8712: EQUAL
8713: IFTRUE 8717
8715: GO 8757
8717: POP
// if IsOK ( Roth ) then
8718: LD_EXP 14
8722: PPUSH
8723: CALL_OW 302
8727: IFFALSE 8743
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
8729: LD_EXP 14
8733: PPUSH
8734: LD_STRING DAlieBaseNotReady-Roth-1
8736: PPUSH
8737: CALL_OW 88
8741: GO 8755
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) ; end ;
8743: LD_EXP 15
8747: PPUSH
8748: LD_STRING DAlieBaseNotReady-Gos-1
8750: PPUSH
8751: CALL_OW 88
8755: GO 8758
8757: POP
// if not ( IsOK ( Gossudarov ) or IsOK ( Roth ) ) then
8758: LD_EXP 15
8762: PPUSH
8763: CALL_OW 302
8767: PUSH
8768: LD_EXP 14
8772: PPUSH
8773: CALL_OW 302
8777: OR
8778: NOT
8779: IFFALSE 8793
// Say ( sci , DAlieBaseNotReady-RSci1-1 ) ;
8781: LD_VAR 0 2
8785: PPUSH
8786: LD_STRING DAlieBaseNotReady-RSci1-1
8788: PPUSH
8789: CALL_OW 88
// interface_hidden := false ;
8793: LD_ADDR_OWVAR 54
8797: PUSH
8798: LD_INT 0
8800: ST_TO_ADDR
// DialogueOff ;
8801: CALL_OW 7
// end ;
8805: PPOPN 2
8807: END
// every 0 0$8.7 trigger GetTech ( tech_Artifact , you ) = state_researched do var un , lab , list ;
8808: LD_INT 24
8810: PPUSH
8811: LD_EXP 1
8815: PPUSH
8816: CALL_OW 321
8820: PUSH
8821: LD_INT 2
8823: EQUAL
8824: IFFALSE 8962
8826: GO 8828
8828: DISABLE
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
8834: LD_ADDR_VAR 0 3
8838: PUSH
8839: LD_INT 22
8841: PUSH
8842: LD_EXP 1
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: LD_INT 30
8856: PUSH
8857: LD_INT 6
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: LD_INT 30
8866: PUSH
8867: LD_INT 7
8869: PUSH
8870: EMPTY
8871: LIST
8872: LIST
8873: PUSH
8874: LD_INT 30
8876: PUSH
8877: LD_INT 8
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: LIST
8888: LIST
8889: PUSH
8890: EMPTY
8891: LIST
8892: LIST
8893: PPUSH
8894: CALL_OW 69
8898: ST_TO_ADDR
// lab := false ;
8899: LD_ADDR_VAR 0 2
8903: PUSH
8904: LD_INT 0
8906: ST_TO_ADDR
// for un in list do
8907: LD_ADDR_VAR 0 1
8911: PUSH
8912: LD_VAR 0 3
8916: PUSH
8917: FOR_IN
8918: IFFALSE 8947
// if GetLives ( un ) = 1000 then
8920: LD_VAR 0 1
8924: PPUSH
8925: CALL_OW 256
8929: PUSH
8930: LD_INT 1000
8932: EQUAL
8933: IFFALSE 8945
// lab := un ;
8935: LD_ADDR_VAR 0 2
8939: PUSH
8940: LD_VAR 0 1
8944: ST_TO_ADDR
8945: GO 8917
8947: POP
8948: POP
// if lab then
8949: LD_VAR 0 2
8953: IFFALSE 8961
// begin Talking_About_Artefact ;
8955: CALL 8965 0 0
// exit ;
8959: GO 8962
// end ; enable ;
8961: ENABLE
// end ;
8962: PPOPN 3
8964: END
// export function Talking_About_Artefact ; var un , ru_sci , us_sci , your_depot ; begin
8965: LD_INT 0
8967: PPUSH
8968: PPUSH
8969: PPUSH
8970: PPUSH
8971: PPUSH
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
8972: LD_ADDR_VAR 0 2
8976: PUSH
8977: LD_INT 22
8979: PUSH
8980: LD_EXP 1
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PUSH
8989: LD_INT 23
8991: PUSH
8992: LD_INT 3
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PUSH
8999: LD_INT 26
9001: PUSH
9002: LD_INT 1
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9019: LD_ADDR_VAR 0 2
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: LD_EXP 13
9033: PUSH
9034: LD_EXP 12
9038: PUSH
9039: LD_EXP 14
9043: PUSH
9044: LD_EXP 15
9048: PUSH
9049: LD_INT 0
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: LIST
9058: DIFF
9059: ST_TO_ADDR
// if un then
9060: LD_VAR 0 2
9064: IFFALSE 9084
// ru_sci := FindMaxSkill ( un , skill_scientistic ) ;
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: LD_INT 4
9078: PPUSH
9079: CALL_OW 433
9083: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_INT 22
9091: PUSH
9092: LD_EXP 1
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 23
9103: PUSH
9104: LD_INT 1
9106: PUSH
9107: EMPTY
9108: LIST
9109: LIST
9110: PUSH
9111: LD_INT 26
9113: PUSH
9114: LD_INT 1
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: LIST
9125: PPUSH
9126: CALL_OW 69
9130: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9131: LD_ADDR_VAR 0 2
9135: PUSH
9136: LD_VAR 0 2
9140: PUSH
9141: LD_EXP 13
9145: PUSH
9146: LD_EXP 12
9150: PUSH
9151: LD_EXP 14
9155: PUSH
9156: LD_EXP 15
9160: PUSH
9161: LD_INT 0
9163: PUSH
9164: EMPTY
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: DIFF
9171: ST_TO_ADDR
// if un then
9172: LD_VAR 0 2
9176: IFFALSE 9196
// us_sci := FindMaxSkill ( un , skill_scientistic ) ;
9178: LD_ADDR_VAR 0 4
9182: PUSH
9183: LD_VAR 0 2
9187: PPUSH
9188: LD_INT 4
9190: PPUSH
9191: CALL_OW 433
9195: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9196: LD_ADDR_VAR 0 2
9200: PUSH
9201: LD_INT 22
9203: PUSH
9204: LD_EXP 1
9208: PUSH
9209: EMPTY
9210: LIST
9211: LIST
9212: PUSH
9213: LD_INT 2
9215: PUSH
9216: LD_INT 30
9218: PUSH
9219: LD_INT 0
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: LD_INT 30
9228: PUSH
9229: LD_INT 1
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: LIST
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 69
9249: ST_TO_ADDR
// if un then
9250: LD_VAR 0 2
9254: IFFALSE 9270
// your_depot := un [ 1 ] ;
9256: LD_ADDR_VAR 0 5
9260: PUSH
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: ST_TO_ADDR
// CenterOnUnits ( Burlak ) ;
9270: LD_EXP 12
9274: PPUSH
9275: CALL_OW 85
// DialogueOn ;
9279: CALL_OW 6
// interface_hidden := true ;
9283: LD_ADDR_OWVAR 54
9287: PUSH
9288: LD_INT 1
9290: ST_TO_ADDR
// Say ( ru_sci , DArtefTechnology-RSci1-1 ) ;
9291: LD_VAR 0 3
9295: PPUSH
9296: LD_STRING DArtefTechnology-RSci1-1
9298: PPUSH
9299: CALL_OW 88
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
9303: LD_EXP 12
9307: PPUSH
9308: LD_STRING DArtefTechnology-Bur-1
9310: PPUSH
9311: CALL_OW 88
// Say ( ru_sci , DArtefTechnology-RSci1-2 ) ;
9315: LD_VAR 0 3
9319: PPUSH
9320: LD_STRING DArtefTechnology-RSci1-2
9322: PPUSH
9323: CALL_OW 88
// Say ( us_sci , DArtefTechnology-Sci1-2 ) ;
9327: LD_VAR 0 4
9331: PPUSH
9332: LD_STRING DArtefTechnology-Sci1-2
9334: PPUSH
9335: CALL_OW 88
// case camp of 4 :
9339: LD_EXP 7
9343: PUSH
9344: LD_INT 4
9346: DOUBLE
9347: EQUAL
9348: IFTRUE 9352
9350: GO 9367
9352: POP
// Say ( MacMillan , DArtefTechnology-JMM-2 ) ; 6 :
9353: LD_EXP 13
9357: PPUSH
9358: LD_STRING DArtefTechnology-JMM-2
9360: PPUSH
9361: CALL_OW 88
9365: GO 9391
9367: LD_INT 6
9369: DOUBLE
9370: EQUAL
9371: IFTRUE 9375
9373: GO 9390
9375: POP
// Say ( Burlak , DArtefTechnology-Bur-2 ) ; end ;
9376: LD_EXP 12
9380: PPUSH
9381: LD_STRING DArtefTechnology-Bur-2
9383: PPUSH
9384: CALL_OW 88
9388: GO 9391
9390: POP
// Say ( ru_sci , DArtefTechnology-RSci1-3 ) ;
9391: LD_VAR 0 3
9395: PPUSH
9396: LD_STRING DArtefTechnology-RSci1-3
9398: PPUSH
9399: CALL_OW 88
// if GetDistUnits ( your_depot , al_tower ) < 30 then
9403: LD_VAR 0 5
9407: PPUSH
9408: LD_INT 108
9410: PPUSH
9411: CALL_OW 296
9415: PUSH
9416: LD_INT 30
9418: LESS
9419: IFFALSE 9435
// Say ( us_sci , DArtefTechnology-Sci1-3 ) else
9421: LD_VAR 0 4
9425: PPUSH
9426: LD_STRING DArtefTechnology-Sci1-3
9428: PPUSH
9429: CALL_OW 88
9433: GO 9447
// Say ( us_sci , DArtefTechnology-Sci1-3a ) ;
9435: LD_VAR 0 4
9439: PPUSH
9440: LD_STRING DArtefTechnology-Sci1-3a
9442: PPUSH
9443: CALL_OW 88
// interface_hidden := false ;
9447: LD_ADDR_OWVAR 54
9451: PUSH
9452: LD_INT 0
9454: ST_TO_ADDR
// DialogueOff ;
9455: CALL_OW 7
// end ; end_of_file
9459: LD_VAR 0 1
9463: RET
// export us_researched , ru_researched ; export one_enabled ; every 0 0$1.1 do var un , sci ;
9464: GO 9466
9466: DISABLE
9467: LD_INT 0
9469: PPUSH
9470: PPUSH
// begin exit ;
9471: GO 9717
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9473: LD_ADDR_VAR 0 1
9477: PUSH
9478: LD_INT 22
9480: PUSH
9481: LD_EXP 1
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: PUSH
9490: LD_INT 23
9492: PUSH
9493: LD_INT 1
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: PUSH
9500: LD_INT 26
9502: PUSH
9503: LD_INT 1
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: PPUSH
9515: CALL_OW 69
9519: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9520: LD_ADDR_VAR 0 1
9524: PUSH
9525: LD_VAR 0 1
9529: PUSH
9530: LD_EXP 13
9534: PUSH
9535: LD_EXP 12
9539: PUSH
9540: LD_EXP 14
9544: PUSH
9545: LD_EXP 15
9549: PUSH
9550: LD_INT 0
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: DIFF
9560: ST_TO_ADDR
// if un then
9561: LD_VAR 0 1
9565: IFFALSE 9585
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9567: LD_ADDR_VAR 0 2
9571: PUSH
9572: LD_VAR 0 1
9576: PPUSH
9577: LD_INT 4
9579: PPUSH
9580: CALL_OW 433
9584: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
9585: LD_EXP 13
9589: PUSH
9590: LD_EXP 12
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 85
// DialogueOn ;
9603: CALL_OW 6
// interface_hidden := true ;
9607: LD_ADDR_OWVAR 54
9611: PUSH
9612: LD_INT 1
9614: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAm-Sci1-1 ) ;
9615: LD_VAR 0 2
9619: PPUSH
9620: LD_STRING DArtefTechnologyAm-Sci1-1
9622: PPUSH
9623: CALL_OW 88
// case camp of 4 :
9627: LD_EXP 7
9631: PUSH
9632: LD_INT 4
9634: DOUBLE
9635: EQUAL
9636: IFTRUE 9640
9638: GO 9655
9640: POP
// Say ( MacMillan , DArtefTechnologyAm-JMM-1 ) ; 6 :
9641: LD_EXP 13
9645: PPUSH
9646: LD_STRING DArtefTechnologyAm-JMM-1
9648: PPUSH
9649: CALL_OW 88
9653: GO 9679
9655: LD_INT 6
9657: DOUBLE
9658: EQUAL
9659: IFTRUE 9663
9661: GO 9678
9663: POP
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ; end ;
9664: LD_EXP 12
9668: PPUSH
9669: LD_STRING DArtefTechnologyAm-Bur-1
9671: PPUSH
9672: CALL_OW 88
9676: GO 9679
9678: POP
// interface_hidden := false ;
9679: LD_ADDR_OWVAR 54
9683: PUSH
9684: LD_INT 0
9686: ST_TO_ADDR
// DialogueOff ;
9687: CALL_OW 7
// if not one_enabled then
9691: LD_EXP 64
9695: NOT
9696: IFFALSE 9709
// begin enable ( 1 ) ;
9698: LD_INT 1
9700: ENABLE_MARKED
// one_enabled := true ;
9701: LD_ADDR_EXP 64
9705: PUSH
9706: LD_INT 1
9708: ST_TO_ADDR
// end ; us_researched := true ;
9709: LD_ADDR_EXP 62
9713: PUSH
9714: LD_INT 1
9716: ST_TO_ADDR
// end ;
9717: PPOPN 2
9719: END
// every 0 0$1.3 do var un , sci ;
9720: GO 9722
9722: DISABLE
9723: LD_INT 0
9725: PPUSH
9726: PPUSH
// begin exit ;
9727: GO 9985
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9729: LD_ADDR_VAR 0 1
9733: PUSH
9734: LD_INT 22
9736: PUSH
9737: LD_EXP 1
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PUSH
9746: LD_INT 23
9748: PUSH
9749: LD_INT 3
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PUSH
9756: LD_INT 26
9758: PUSH
9759: LD_INT 1
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 69
9775: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9776: LD_ADDR_VAR 0 1
9780: PUSH
9781: LD_VAR 0 1
9785: PUSH
9786: LD_EXP 13
9790: PUSH
9791: LD_EXP 12
9795: PUSH
9796: LD_EXP 14
9800: PUSH
9801: LD_EXP 15
9805: PUSH
9806: LD_INT 0
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: DIFF
9816: ST_TO_ADDR
// if un then
9817: LD_VAR 0 1
9821: IFFALSE 9841
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9823: LD_ADDR_VAR 0 2
9827: PUSH
9828: LD_VAR 0 1
9832: PPUSH
9833: LD_INT 4
9835: PPUSH
9836: CALL_OW 433
9840: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , sci ] ) ;
9841: LD_EXP 13
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PPUSH
9855: CALL_OW 85
// DialogueOn ;
9859: CALL_OW 6
// interface_hidden := true ;
9863: LD_ADDR_OWVAR 54
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// Say ( sci , DArtefTechnologyRu-RSci1-1 ) ;
9871: LD_VAR 0 2
9875: PPUSH
9876: LD_STRING DArtefTechnologyRu-RSci1-1
9878: PPUSH
9879: CALL_OW 88
// case camp of 4 :
9883: LD_EXP 7
9887: PUSH
9888: LD_INT 4
9890: DOUBLE
9891: EQUAL
9892: IFTRUE 9896
9894: GO 9911
9896: POP
// Say ( MacMillan , DArtefTechnologyRu-JMM-1 ) ; 6 :
9897: LD_EXP 13
9901: PPUSH
9902: LD_STRING DArtefTechnologyRu-JMM-1
9904: PPUSH
9905: CALL_OW 88
9909: GO 9935
9911: LD_INT 6
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9934
9919: POP
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ; end ;
9920: LD_EXP 12
9924: PPUSH
9925: LD_STRING DArtefTechnologyRu-Bur-1
9927: PPUSH
9928: CALL_OW 88
9932: GO 9935
9934: POP
// Say ( sci , DArtefTechnologyRu-RSci1-2 ) ;
9935: LD_VAR 0 2
9939: PPUSH
9940: LD_STRING DArtefTechnologyRu-RSci1-2
9942: PPUSH
9943: CALL_OW 88
// interface_hidden := false ;
9947: LD_ADDR_OWVAR 54
9951: PUSH
9952: LD_INT 0
9954: ST_TO_ADDR
// DialogueOff ;
9955: CALL_OW 7
// if not one_enabled then
9959: LD_EXP 64
9963: NOT
9964: IFFALSE 9977
// begin enable ( 1 ) ;
9966: LD_INT 1
9968: ENABLE_MARKED
// one_enabled := true ;
9969: LD_ADDR_EXP 64
9973: PUSH
9974: LD_INT 1
9976: ST_TO_ADDR
// end ; ru_researched := true ;
9977: LD_ADDR_EXP 63
9981: PUSH
9982: LD_INT 1
9984: ST_TO_ADDR
// end ;
9985: PPOPN 2
9987: END
// every 0 0$5.3 trigger ( GetSide ( al_tower ) = you ) and ( GetTag ( 81 ) or GetTag ( 181 ) ) marked 1 do var un , sci ;
9988: LD_INT 108
9990: PPUSH
9991: CALL_OW 255
9995: PUSH
9996: LD_EXP 1
10000: EQUAL
10001: PUSH
10002: LD_INT 81
10004: PPUSH
10005: CALL_OW 110
10009: PUSH
10010: LD_INT 181
10012: PPUSH
10013: CALL_OW 110
10017: OR
10018: AND
10019: IFFALSE 10263
10021: GO 10023
10023: DISABLE
10024: LD_INT 0
10026: PPUSH
10027: PPUSH
// begin un := [ ] ;
10028: LD_ADDR_VAR 0 1
10032: PUSH
10033: EMPTY
10034: ST_TO_ADDR
// if us_researched then
10035: LD_EXP 62
10039: IFFALSE 10094
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
10041: LD_ADDR_VAR 0 1
10045: PUSH
10046: LD_VAR 0 1
10050: PUSH
10051: LD_INT 22
10053: PUSH
10054: LD_EXP 1
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: PUSH
10063: LD_INT 23
10065: PUSH
10066: LD_INT 1
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 26
10075: PUSH
10076: LD_INT 1
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: LIST
10087: PPUSH
10088: CALL_OW 69
10092: ADD
10093: ST_TO_ADDR
// if ru_researched then
10094: LD_EXP 63
10098: IFFALSE 10153
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10100: LD_ADDR_VAR 0 1
10104: PUSH
10105: LD_VAR 0 1
10109: PUSH
10110: LD_INT 22
10112: PUSH
10113: LD_EXP 1
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PUSH
10122: LD_INT 23
10124: PUSH
10125: LD_INT 3
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 26
10134: PUSH
10135: LD_INT 1
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: LIST
10146: PPUSH
10147: CALL_OW 69
10151: ADD
10152: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10153: LD_ADDR_VAR 0 1
10157: PUSH
10158: LD_VAR 0 1
10162: PUSH
10163: LD_EXP 13
10167: PUSH
10168: LD_EXP 12
10172: PUSH
10173: LD_EXP 14
10177: PUSH
10178: LD_EXP 15
10182: PUSH
10183: LD_INT 0
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: DIFF
10193: ST_TO_ADDR
// if un then
10194: LD_VAR 0 1
10198: IFFALSE 10218
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10200: LD_ADDR_VAR 0 2
10204: PUSH
10205: LD_VAR 0 1
10209: PPUSH
10210: LD_INT 4
10212: PPUSH
10213: CALL_OW 433
10217: ST_TO_ADDR
// CenterOnUnits ( sci ) ;
10218: LD_VAR 0 2
10222: PPUSH
10223: CALL_OW 85
// DialogueOn ;
10227: CALL_OW 6
// interface_hidden := true ;
10231: LD_ADDR_OWVAR 54
10235: PUSH
10236: LD_INT 1
10238: ST_TO_ADDR
// Say ( sci , DArtefTechnologyArStart-Sci1-1 ) ;
10239: LD_VAR 0 2
10243: PPUSH
10244: LD_STRING DArtefTechnologyArStart-Sci1-1
10246: PPUSH
10247: CALL_OW 88
// interface_hidden := false ;
10251: LD_ADDR_OWVAR 54
10255: PUSH
10256: LD_INT 0
10258: ST_TO_ADDR
// DialogueOff ;
10259: CALL_OW 7
// end ;
10263: PPOPN 2
10265: END
// every 0 0$3.9 trigger GetTag ( 281 ) do var un , sci ;
10266: LD_INT 281
10268: PPUSH
10269: CALL_OW 110
10273: IFFALSE 10634
10275: GO 10277
10277: DISABLE
10278: LD_INT 0
10280: PPUSH
10281: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10282: LD_ADDR_VAR 0 1
10286: PUSH
10287: LD_INT 22
10289: PUSH
10290: LD_EXP 1
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: PUSH
10299: LD_INT 23
10301: PUSH
10302: LD_INT 3
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: PUSH
10309: LD_INT 26
10311: PUSH
10312: LD_INT 1
10314: PUSH
10315: EMPTY
10316: LIST
10317: LIST
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10329: LD_ADDR_VAR 0 1
10333: PUSH
10334: LD_VAR 0 1
10338: PUSH
10339: LD_EXP 13
10343: PUSH
10344: LD_EXP 12
10348: PUSH
10349: LD_EXP 14
10353: PUSH
10354: LD_EXP 15
10358: PUSH
10359: LD_INT 0
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: DIFF
10369: ST_TO_ADDR
// if un then
10370: LD_VAR 0 1
10374: IFFALSE 10396
// sci := FindMaxSkill ( un , skill_scientistic ) else
10376: LD_ADDR_VAR 0 2
10380: PUSH
10381: LD_VAR 0 1
10385: PPUSH
10386: LD_INT 4
10388: PPUSH
10389: CALL_OW 433
10393: ST_TO_ADDR
10394: GO 10398
// exit ;
10396: GO 10634
// CenterOnUnits ( [ MacMillan , Burlak , sci ] ) ;
10398: LD_EXP 13
10402: PUSH
10403: LD_EXP 12
10407: PUSH
10408: LD_VAR 0 2
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: PPUSH
10418: CALL_OW 85
// DialogueOn ;
10422: CALL_OW 6
// interface_hidden := true ;
10426: LD_ADDR_OWVAR 54
10430: PUSH
10431: LD_INT 1
10433: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAr-RSci1-1 ) ;
10434: LD_VAR 0 2
10438: PPUSH
10439: LD_STRING DArtefTechnologyAr-RSci1-1
10441: PPUSH
10442: CALL_OW 88
// case camp of 4 :
10446: LD_EXP 7
10450: PUSH
10451: LD_INT 4
10453: DOUBLE
10454: EQUAL
10455: IFTRUE 10459
10457: GO 10474
10459: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-1 ) ; 6 :
10460: LD_EXP 13
10464: PPUSH
10465: LD_STRING DArtefTechnologyAr-JMM-1
10467: PPUSH
10468: CALL_OW 88
10472: GO 10498
10474: LD_INT 6
10476: DOUBLE
10477: EQUAL
10478: IFTRUE 10482
10480: GO 10497
10482: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-1 ) ; end ;
10483: LD_EXP 12
10487: PPUSH
10488: LD_STRING DArtefTechnologyAr-Bur-1
10490: PPUSH
10491: CALL_OW 88
10495: GO 10498
10497: POP
// Say ( sci , DArtefTechnologyAr-RSci1-2 ) ;
10498: LD_VAR 0 2
10502: PPUSH
10503: LD_STRING DArtefTechnologyAr-RSci1-2
10505: PPUSH
10506: CALL_OW 88
// case camp of 4 :
10510: LD_EXP 7
10514: PUSH
10515: LD_INT 4
10517: DOUBLE
10518: EQUAL
10519: IFTRUE 10523
10521: GO 10538
10523: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-2 ) ; 6 :
10524: LD_EXP 13
10528: PPUSH
10529: LD_STRING DArtefTechnologyAr-JMM-2
10531: PPUSH
10532: CALL_OW 88
10536: GO 10562
10538: LD_INT 6
10540: DOUBLE
10541: EQUAL
10542: IFTRUE 10546
10544: GO 10561
10546: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-2 ) ; end ;
10547: LD_EXP 12
10551: PPUSH
10552: LD_STRING DArtefTechnologyAr-Bur-2
10554: PPUSH
10555: CALL_OW 88
10559: GO 10562
10561: POP
// Say ( sci , DArtefTechnologyAr-RSci1-3 ) ;
10562: LD_VAR 0 2
10566: PPUSH
10567: LD_STRING DArtefTechnologyAr-RSci1-3
10569: PPUSH
10570: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-3 ) ;
10574: LD_EXP 13
10578: PPUSH
10579: LD_STRING DArtefTechnologyAr-JMM-3
10581: PPUSH
10582: CALL_OW 88
// Say ( sci , DArtefTechnologyAr-RSci1-4 ) ;
10586: LD_VAR 0 2
10590: PPUSH
10591: LD_STRING DArtefTechnologyAr-RSci1-4
10593: PPUSH
10594: CALL_OW 88
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
10598: LD_EXP 12
10602: PPUSH
10603: LD_STRING DArtefTechnologyAr-Bur-4
10605: PPUSH
10606: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-4 ) ;
10610: LD_EXP 13
10614: PPUSH
10615: LD_STRING DArtefTechnologyAr-JMM-4
10617: PPUSH
10618: CALL_OW 88
// interface_hidden := false ;
10622: LD_ADDR_OWVAR 54
10626: PUSH
10627: LD_INT 0
10629: ST_TO_ADDR
// DialogueOff ;
10630: CALL_OW 7
// end ; end_of_file
10634: PPOPN 2
10636: END
// export omar_in_contact ; var sib_list ; every 0 0$2 + 0 0$0.4 trigger FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] ] ) = 0 marked 2 do var answer ;
10637: LD_INT 22
10639: PUSH
10640: LD_EXP 4
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PUSH
10649: LD_INT 21
10651: PUSH
10652: LD_INT 1
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: LD_INT 50
10661: PUSH
10662: EMPTY
10663: LIST
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: LIST
10669: PPUSH
10670: CALL_OW 69
10674: PUSH
10675: LD_INT 0
10677: EQUAL
10678: IFFALSE 11109
10680: GO 10682
10682: DISABLE
10683: LD_INT 0
10685: PPUSH
// begin Omar_Arrive ;
10686: CALL 11112 0 0
// CenterOnUnits ( Omar ) ;
10690: LD_EXP 52
10694: PPUSH
10695: CALL_OW 85
// DialogueOn ;
10699: CALL_OW 6
// interface_hidden := true ;
10703: LD_ADDR_OWVAR 54
10707: PUSH
10708: LD_INT 1
10710: ST_TO_ADDR
// Say ( Omar , DOmar-Omar-1 ) ;
10711: LD_EXP 52
10715: PPUSH
10716: LD_STRING DOmar-Omar-1
10718: PPUSH
10719: CALL_OW 88
// case camp of 4 :
10723: LD_EXP 7
10727: PUSH
10728: LD_INT 4
10730: DOUBLE
10731: EQUAL
10732: IFTRUE 10736
10734: GO 10751
10736: POP
// Say ( MacMillan , DOmar-JMM-1 ) ; 6 :
10737: LD_EXP 13
10741: PPUSH
10742: LD_STRING DOmar-JMM-1
10744: PPUSH
10745: CALL_OW 88
10749: GO 10775
10751: LD_INT 6
10753: DOUBLE
10754: EQUAL
10755: IFTRUE 10759
10757: GO 10774
10759: POP
// Say ( Burlak , DOmar-Bur-1 ) ; end ;
10760: LD_EXP 12
10764: PPUSH
10765: LD_STRING DOmar-Bur-1
10767: PPUSH
10768: CALL_OW 88
10772: GO 10775
10774: POP
// Say ( Omar , DOmar-Omar-2 ) ;
10775: LD_EXP 52
10779: PPUSH
10780: LD_STRING DOmar-Omar-2
10782: PPUSH
10783: CALL_OW 88
// case camp of 4 :
10787: LD_EXP 7
10791: PUSH
10792: LD_INT 4
10794: DOUBLE
10795: EQUAL
10796: IFTRUE 10800
10798: GO 10815
10800: POP
// Say ( MacMillan , DOmar-JMM-2 ) ; 6 :
10801: LD_EXP 13
10805: PPUSH
10806: LD_STRING DOmar-JMM-2
10808: PPUSH
10809: CALL_OW 88
10813: GO 10839
10815: LD_INT 6
10817: DOUBLE
10818: EQUAL
10819: IFTRUE 10823
10821: GO 10838
10823: POP
// Say ( Burlak , DOmar-Bur-2 ) ; end ;
10824: LD_EXP 12
10828: PPUSH
10829: LD_STRING DOmar-Bur-2
10831: PPUSH
10832: CALL_OW 88
10836: GO 10839
10838: POP
// Say ( Omar , DOmar-Omar-3 ) ;
10839: LD_EXP 52
10843: PPUSH
10844: LD_STRING DOmar-Omar-3
10846: PPUSH
10847: CALL_OW 88
// case camp of 4 :
10851: LD_EXP 7
10855: PUSH
10856: LD_INT 4
10858: DOUBLE
10859: EQUAL
10860: IFTRUE 10864
10862: GO 10879
10864: POP
// Say ( MacMillan , DOmar-JMM-3 ) ; 6 :
10865: LD_EXP 13
10869: PPUSH
10870: LD_STRING DOmar-JMM-3
10872: PPUSH
10873: CALL_OW 88
10877: GO 10903
10879: LD_INT 6
10881: DOUBLE
10882: EQUAL
10883: IFTRUE 10887
10885: GO 10902
10887: POP
// Say ( Burlak , DOmar-Bur-3 ) ; end ;
10888: LD_EXP 12
10892: PPUSH
10893: LD_STRING DOmar-Bur-3
10895: PPUSH
10896: CALL_OW 88
10900: GO 10903
10902: POP
// Say ( Omar , DOmar-Omar-4 ) ;
10903: LD_EXP 52
10907: PPUSH
10908: LD_STRING DOmar-Omar-4
10910: PPUSH
10911: CALL_OW 88
// answer = Query ( QAccept ) ;
10915: LD_ADDR_VAR 0 1
10919: PUSH
10920: LD_STRING QAccept
10922: PPUSH
10923: CALL_OW 97
10927: ST_TO_ADDR
// case answer of 1 :
10928: LD_VAR 0 1
10932: PUSH
10933: LD_INT 1
10935: DOUBLE
10936: EQUAL
10937: IFTRUE 10941
10939: GO 11019
10941: POP
// begin case camp of 4 :
10942: LD_EXP 7
10946: PUSH
10947: LD_INT 4
10949: DOUBLE
10950: EQUAL
10951: IFTRUE 10955
10953: GO 10970
10955: POP
// Say ( MacMillan , DQrAccept#1-JMM-1 ) ; 6 :
10956: LD_EXP 13
10960: PPUSH
10961: LD_STRING DQrAccept#1-JMM-1
10963: PPUSH
10964: CALL_OW 88
10968: GO 10994
10970: LD_INT 6
10972: DOUBLE
10973: EQUAL
10974: IFTRUE 10978
10976: GO 10993
10978: POP
// Say ( Burlak , DQrAccept#1-Bur-1 ) ; end ;
10979: LD_EXP 12
10983: PPUSH
10984: LD_STRING DQrAccept#1-Bur-1
10986: PPUSH
10987: CALL_OW 88
10991: GO 10994
10993: POP
// SetSide ( Omar , you ) ;
10994: LD_EXP 52
10998: PPUSH
10999: LD_EXP 1
11003: PPUSH
11004: CALL_OW 235
// ComStop ( Omar ) ;
11008: LD_EXP 52
11012: PPUSH
11013: CALL_OW 141
// end ; 2 :
11017: GO 11083
11019: LD_INT 2
11021: DOUBLE
11022: EQUAL
11023: IFTRUE 11027
11025: GO 11082
11027: POP
// begin case camp of 4 :
11028: LD_EXP 7
11032: PUSH
11033: LD_INT 4
11035: DOUBLE
11036: EQUAL
11037: IFTRUE 11041
11039: GO 11056
11041: POP
// Say ( MacMillan , DQrAccept#2-JMM-1 ) ; 6 :
11042: LD_EXP 13
11046: PPUSH
11047: LD_STRING DQrAccept#2-JMM-1
11049: PPUSH
11050: CALL_OW 88
11054: GO 11080
11056: LD_INT 6
11058: DOUBLE
11059: EQUAL
11060: IFTRUE 11064
11062: GO 11079
11064: POP
// Say ( Burlak , DQrAccept#2-Bur-1 ) ; end ;
11065: LD_EXP 12
11069: PPUSH
11070: LD_STRING DQrAccept#2-Bur-1
11072: PPUSH
11073: CALL_OW 88
11077: GO 11080
11079: POP
// end ; end ;
11080: GO 11083
11082: POP
// interface_hidden := false ;
11083: LD_ADDR_OWVAR 54
11087: PUSH
11088: LD_INT 0
11090: ST_TO_ADDR
// DialogueOff ;
11091: CALL_OW 7
// if answer = 2 then
11095: LD_VAR 0 1
11099: PUSH
11100: LD_INT 2
11102: EQUAL
11103: IFFALSE 11109
// Omar_Leave ;
11105: CALL 11161 0 0
// end ;
11109: PPOPN 1
11111: END
// function Omar_Arrive ; var un ; begin
11112: LD_INT 0
11114: PPUSH
11115: PPUSH
// PlaceUnitArea ( Omar , omar_place , false ) ;
11116: LD_EXP 52
11120: PPUSH
11121: LD_INT 4
11123: PPUSH
11124: LD_INT 0
11126: PPUSH
11127: CALL_OW 49
// repeat ComMoveToArea ( Omar , teleport_area ) ;
11131: LD_EXP 52
11135: PPUSH
11136: LD_INT 24
11138: PPUSH
11139: CALL_OW 113
// wait ( 0 0$1 ) ;
11143: LD_INT 35
11145: PPUSH
11146: CALL_OW 67
// until omar_in_contact ;
11150: LD_EXP 65
11154: IFFALSE 11131
// end ;
11156: LD_VAR 0 1
11160: RET
// function Omar_Leave ; begin
11161: LD_INT 0
11163: PPUSH
// repeat ComMoveToArea ( Omar , omar_place ) ;
11164: LD_EXP 52
11168: PPUSH
11169: LD_INT 4
11171: PPUSH
11172: CALL_OW 113
// wait ( 0 0$1 ) ;
11176: LD_INT 35
11178: PPUSH
11179: CALL_OW 67
// until IsInArea ( Omar , omar_place ) ;
11183: LD_EXP 52
11187: PPUSH
11188: LD_INT 4
11190: PPUSH
11191: CALL_OW 308
11195: IFFALSE 11164
// RemoveUnit ( Omar ) ;
11197: LD_EXP 52
11201: PPUSH
11202: CALL_OW 64
// end ;
11206: LD_VAR 0 1
11210: RET
// every 0 0$3.7 trigger OmarWillTryContaminateMotherlode and ( FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 or finalize = 2 ) do var best_sib , see_him ;
11211: LD_EXP 55
11215: PUSH
11216: LD_INT 22
11218: PUSH
11219: LD_EXP 2
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 2
11230: PUSH
11231: LD_INT 30
11233: PUSH
11234: LD_INT 0
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 30
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: LIST
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: PPUSH
11260: CALL_OW 69
11264: PUSH
11265: LD_INT 0
11267: EQUAL
11268: PUSH
11269: LD_EXP 59
11273: PUSH
11274: LD_INT 2
11276: EQUAL
11277: OR
11278: AND
11279: IFFALSE 11429
11281: GO 11283
11283: DISABLE
11284: LD_INT 0
11286: PPUSH
11287: PPUSH
// begin sib_list := get_sib_list ;
11288: LD_ADDR_LOC 11
11292: PUSH
11293: CALL 11674 0 0
11297: ST_TO_ADDR
// SetClass ( Omar , class_scientistic ) ;
11298: LD_EXP 52
11302: PPUSH
11303: LD_INT 4
11305: PPUSH
11306: CALL_OW 336
// PlaceUnitArea ( Omar , omar_infested , false ) ;
11310: LD_EXP 52
11314: PPUSH
11315: LD_INT 5
11317: PPUSH
11318: LD_INT 0
11320: PPUSH
11321: CALL_OW 49
// see_him := false ;
11325: LD_ADDR_VAR 0 2
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// repeat best_sib := get_best_sib ( sib_list ) ;
11333: LD_ADDR_VAR 0 1
11337: PUSH
11338: LD_LOC 11
11342: PPUSH
11343: CALL 11814 0 1
11347: ST_TO_ADDR
// ComContaminate ( Omar , best_sib [ 1 ] , best_sib [ 2 ] ) ;
11348: LD_EXP 52
11352: PPUSH
11353: LD_VAR 0 1
11357: PUSH
11358: LD_INT 1
11360: ARRAY
11361: PPUSH
11362: LD_VAR 0 1
11366: PUSH
11367: LD_INT 2
11369: ARRAY
11370: PPUSH
11371: CALL_OW 158
// if ( not see_him ) and See ( you , Omar ) then
11375: LD_VAR 0 2
11379: NOT
11380: PUSH
11381: LD_EXP 1
11385: PPUSH
11386: LD_EXP 52
11390: PPUSH
11391: CALL_OW 292
11395: AND
11396: IFFALSE 11410
// begin talking_to_omar ;
11398: CALL 11432 0 0
// see_him := true ;
11402: LD_ADDR_VAR 0 2
11406: PUSH
11407: LD_INT 1
11409: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
11410: LD_INT 35
11412: PPUSH
11413: CALL_OW 67
// until not IsLive ( Omar ) ;
11417: LD_EXP 52
11421: PPUSH
11422: CALL_OW 300
11426: NOT
11427: IFFALSE 11333
// end ;
11429: PPOPN 2
11431: END
// function talking_to_omar ; begin
11432: LD_INT 0
11434: PPUSH
// CenterOnUnits ( Omar ) ;
11435: LD_EXP 52
11439: PPUSH
11440: CALL_OW 85
// DialogueOn ;
11444: CALL_OW 6
// interface_hidden := true ;
11448: LD_ADDR_OWVAR 54
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// case camp of 4 :
11456: LD_EXP 7
11460: PUSH
11461: LD_INT 4
11463: DOUBLE
11464: EQUAL
11465: IFTRUE 11469
11467: GO 11484
11469: POP
// Say ( MacMillan , DOmarContam-JMM-1 ) ; 6 :
11470: LD_EXP 13
11474: PPUSH
11475: LD_STRING DOmarContam-JMM-1
11477: PPUSH
11478: CALL_OW 88
11482: GO 11508
11484: LD_INT 6
11486: DOUBLE
11487: EQUAL
11488: IFTRUE 11492
11490: GO 11507
11492: POP
// Say ( Burlak , DOmarContam-Bur-1 ) ; end ;
11493: LD_EXP 12
11497: PPUSH
11498: LD_STRING DOmarContam-Bur-1
11500: PPUSH
11501: CALL_OW 88
11505: GO 11508
11507: POP
// Say ( Omar , DOmarContam-Omar-1 ) ;
11508: LD_EXP 52
11512: PPUSH
11513: LD_STRING DOmarContam-Omar-1
11515: PPUSH
11516: CALL_OW 88
// case camp of 4 :
11520: LD_EXP 7
11524: PUSH
11525: LD_INT 4
11527: DOUBLE
11528: EQUAL
11529: IFTRUE 11533
11531: GO 11548
11533: POP
// Say ( MacMillan , DOmarContam-JMM-2 ) ; 6 :
11534: LD_EXP 13
11538: PPUSH
11539: LD_STRING DOmarContam-JMM-2
11541: PPUSH
11542: CALL_OW 88
11546: GO 11572
11548: LD_INT 6
11550: DOUBLE
11551: EQUAL
11552: IFTRUE 11556
11554: GO 11571
11556: POP
// Say ( Burlak , DOmarContam-Bur-2 ) ; end ;
11557: LD_EXP 12
11561: PPUSH
11562: LD_STRING DOmarContam-Bur-2
11564: PPUSH
11565: CALL_OW 88
11569: GO 11572
11571: POP
// interface_hidden := false ;
11572: LD_ADDR_OWVAR 54
11576: PUSH
11577: LD_INT 0
11579: ST_TO_ADDR
// DialogueOff ;
11580: CALL_OW 7
// end ;
11584: LD_VAR 0 1
11588: RET
// on SibDepositContaminated ( sib , x , y ) do var list , un ;
11589: LD_INT 0
11591: PPUSH
11592: PPUSH
// begin InGameOn ;
11593: CALL_OW 8
// CenterOnXY ( x , y ) ;
11597: LD_VAR 0 2
11601: PPUSH
11602: LD_VAR 0 3
11606: PPUSH
11607: CALL_OW 84
// PlaceSeeing ( x , y , you , - 10 ) ;
11611: LD_VAR 0 2
11615: PPUSH
11616: LD_VAR 0 3
11620: PPUSH
11621: LD_EXP 1
11625: PPUSH
11626: LD_INT 10
11628: NEG
11629: PPUSH
11630: CALL_OW 330
// wait ( 0 0$7 ) ;
11634: LD_INT 245
11636: PPUSH
11637: CALL_OW 67
// Mission_Failed ( 5 ) ;
11641: LD_INT 5
11643: PPUSH
11644: CALL 13898 0 1
// RemoveSeeing ( x , y , you ) ;
11648: LD_VAR 0 2
11652: PPUSH
11653: LD_VAR 0 3
11657: PPUSH
11658: LD_EXP 1
11662: PPUSH
11663: CALL_OW 331
// InGameOff ;
11667: CALL_OW 9
// end ;
11671: PPOPN 5
11673: END
// function get_sib_list ; var list , un , vysledek ; begin
11674: LD_INT 0
11676: PPUSH
11677: PPUSH
11678: PPUSH
11679: PPUSH
// vysledek := [ ] ;
11680: LD_ADDR_VAR 0 4
11684: PUSH
11685: EMPTY
11686: ST_TO_ADDR
// list := GetListOfResourcesInArea ( ru_base ) ;
11687: LD_ADDR_VAR 0 2
11691: PUSH
11692: LD_INT 12
11694: PPUSH
11695: CALL_OW 442
11699: ST_TO_ADDR
// for un = 1 to ( list div 3 ) do
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: DOUBLE
11706: LD_INT 1
11708: DEC
11709: ST_TO_ADDR
11710: LD_VAR 0 2
11714: PUSH
11715: LD_INT 3
11717: DIV
11718: PUSH
11719: FOR_TO
11720: IFFALSE 11797
// if list [ ( un * 3 ) ] = source_siberium then
11722: LD_VAR 0 2
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_INT 3
11734: MUL
11735: ARRAY
11736: PUSH
11737: LD_INT 2
11739: EQUAL
11740: IFFALSE 11795
// vysledek := vysledek ^ [ list [ ( un * 3 ) - 2 ] , list [ ( un * 3 ) - 1 ] ] ;
11742: LD_ADDR_VAR 0 4
11746: PUSH
11747: LD_VAR 0 4
11751: PUSH
11752: LD_VAR 0 2
11756: PUSH
11757: LD_VAR 0 3
11761: PUSH
11762: LD_INT 3
11764: MUL
11765: PUSH
11766: LD_INT 2
11768: MINUS
11769: ARRAY
11770: PUSH
11771: LD_VAR 0 2
11775: PUSH
11776: LD_VAR 0 3
11780: PUSH
11781: LD_INT 3
11783: MUL
11784: PUSH
11785: LD_INT 1
11787: MINUS
11788: ARRAY
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: ADD
11794: ST_TO_ADDR
11795: GO 11719
11797: POP
11798: POP
// result := vysledek ;
11799: LD_ADDR_VAR 0 1
11803: PUSH
11804: LD_VAR 0 4
11808: ST_TO_ADDR
// end ;
11809: LD_VAR 0 1
11813: RET
// function get_best_sib ( sib_list ) ; var un , min , x , y , dist , vysledek , b ; begin
11814: LD_INT 0
11816: PPUSH
11817: PPUSH
11818: PPUSH
11819: PPUSH
11820: PPUSH
11821: PPUSH
11822: PPUSH
11823: PPUSH
// min := [ - 1 , - 1 , - 1 ] ;
11824: LD_ADDR_VAR 0 4
11828: PUSH
11829: LD_INT 1
11831: NEG
11832: PUSH
11833: LD_INT 1
11835: NEG
11836: PUSH
11837: LD_INT 1
11839: NEG
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: LIST
11845: ST_TO_ADDR
// for un = 1 to ( sib_list div 2 ) do
11846: LD_ADDR_VAR 0 3
11850: PUSH
11851: DOUBLE
11852: LD_INT 1
11854: DEC
11855: ST_TO_ADDR
11856: LD_VAR 0 1
11860: PUSH
11861: LD_INT 2
11863: DIV
11864: PUSH
11865: FOR_TO
11866: IFFALSE 12039
// begin x := sib_list [ ( un * 2 ) - 1 ] ;
11868: LD_ADDR_VAR 0 5
11872: PUSH
11873: LD_VAR 0 1
11877: PUSH
11878: LD_VAR 0 3
11882: PUSH
11883: LD_INT 2
11885: MUL
11886: PUSH
11887: LD_INT 1
11889: MINUS
11890: ARRAY
11891: ST_TO_ADDR
// y := sib_list [ ( un * 2 ) ] ;
11892: LD_ADDR_VAR 0 6
11896: PUSH
11897: LD_VAR 0 1
11901: PUSH
11902: LD_VAR 0 3
11906: PUSH
11907: LD_INT 2
11909: MUL
11910: ARRAY
11911: ST_TO_ADDR
// dist := GetDistUnitXY ( Omar , x , y ) ;
11912: LD_ADDR_VAR 0 7
11916: PUSH
11917: LD_EXP 52
11921: PPUSH
11922: LD_VAR 0 5
11926: PPUSH
11927: LD_VAR 0 6
11931: PPUSH
11932: CALL_OW 297
11936: ST_TO_ADDR
// b = HexInfo ( x , y ) ;
11937: LD_ADDR_VAR 0 9
11941: PUSH
11942: LD_VAR 0 5
11946: PPUSH
11947: LD_VAR 0 6
11951: PPUSH
11952: CALL_OW 428
11956: ST_TO_ADDR
// if ( ( min [ 3 ] < 0 ) or ( dist < min [ 3 ] ) ) and ( b = 0 or GetBType ( b ) = b_siberite_mine ) then
11957: LD_VAR 0 4
11961: PUSH
11962: LD_INT 3
11964: ARRAY
11965: PUSH
11966: LD_INT 0
11968: LESS
11969: PUSH
11970: LD_VAR 0 7
11974: PUSH
11975: LD_VAR 0 4
11979: PUSH
11980: LD_INT 3
11982: ARRAY
11983: LESS
11984: OR
11985: PUSH
11986: LD_VAR 0 9
11990: PUSH
11991: LD_INT 0
11993: EQUAL
11994: PUSH
11995: LD_VAR 0 9
11999: PPUSH
12000: CALL_OW 266
12004: PUSH
12005: LD_INT 30
12007: EQUAL
12008: OR
12009: AND
12010: IFFALSE 12037
// min := [ x , y , dist ] ;
12012: LD_ADDR_VAR 0 4
12016: PUSH
12017: LD_VAR 0 5
12021: PUSH
12022: LD_VAR 0 6
12026: PUSH
12027: LD_VAR 0 7
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: LIST
12036: ST_TO_ADDR
// end ;
12037: GO 11865
12039: POP
12040: POP
// vysledek := [ min [ 1 ] , min [ 2 ] ] ;
12041: LD_ADDR_VAR 0 8
12045: PUSH
12046: LD_VAR 0 4
12050: PUSH
12051: LD_INT 1
12053: ARRAY
12054: PUSH
12055: LD_VAR 0 4
12059: PUSH
12060: LD_INT 2
12062: ARRAY
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: ST_TO_ADDR
// result := vysledek ;
12068: LD_ADDR_VAR 0 2
12072: PUSH
12073: LD_VAR 0 8
12077: ST_TO_ADDR
// end ; end_of_file
12078: LD_VAR 0 2
12082: RET
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibFiss then
12083: LD_VAR 0 1
12087: PUSH
12088: LD_INT 25
12090: EQUAL
12091: IFFALSE 12132
// case GetSide ( lab ) of 1 :
12093: LD_VAR 0 2
12097: PPUSH
12098: CALL_OW 255
12102: PUSH
12103: LD_INT 1
12105: DOUBLE
12106: EQUAL
12107: IFTRUE 12111
12109: GO 12117
12111: POP
// enable ( 4 ) ; 3 :
12112: LD_INT 4
12114: ENABLE_MARKED
12115: GO 12132
12117: LD_INT 3
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12125
12123: GO 12131
12125: POP
// enable ( 5 ) ; end ;
12126: LD_INT 5
12128: ENABLE_MARKED
12129: GO 12132
12131: POP
// wait ( 10 ) ;
12132: LD_INT 10
12134: PPUSH
12135: CALL_OW 67
// if not IsBusy ( lab ) then
12139: LD_VAR 0 2
12143: PPUSH
12144: CALL_OW 315
12148: NOT
12149: IFFALSE 12176
// begin labs_in_use := labs_in_use diff lab ;
12151: LD_ADDR_EXP 80
12155: PUSH
12156: LD_EXP 80
12160: PUSH
12161: LD_VAR 0 2
12165: DIFF
12166: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12167: LD_VAR 0 2
12171: PPUSH
12172: CALL 40227 0 1
// end ; end ;
12176: PPOPN 2
12178: END
// on ResearchStarted ( tech , lab ) do var un , side ;
12179: LD_INT 0
12181: PPUSH
12182: PPUSH
// begin labs_in_use := labs_in_use ^ lab ;
12183: LD_ADDR_EXP 80
12187: PUSH
12188: LD_EXP 80
12192: PUSH
12193: LD_VAR 0 2
12197: ADD
12198: ST_TO_ADDR
// side := GetSide ( lab ) ;
12199: LD_ADDR_VAR 0 4
12203: PUSH
12204: LD_VAR 0 2
12208: PPUSH
12209: CALL_OW 255
12213: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
12214: LD_ADDR_VAR 0 3
12218: PUSH
12219: DOUBLE
12220: LD_INT 0
12222: DEC
12223: ST_TO_ADDR
12224: LD_EXP 77
12228: PUSH
12229: LD_INT 1
12231: MINUS
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12313
// if lab in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
12236: LD_VAR 0 2
12240: PUSH
12241: LD_VAR 0 3
12245: PUSH
12246: LD_INT 100
12248: MUL
12249: PUSH
12250: LD_INT 11
12252: PLUS
12253: PPUSH
12254: CALL_OW 110
12258: PUSH
12259: LD_VAR 0 3
12263: PUSH
12264: LD_INT 100
12266: MUL
12267: PUSH
12268: LD_VAR 0 4
12272: PUSH
12273: LD_INT 10
12275: MUL
12276: PLUS
12277: PUSH
12278: LD_INT 15
12280: PLUS
12281: PPUSH
12282: CALL_OW 110
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: IN
12291: IFFALSE 12311
// DeInit_Lab ( side , un + 1 ) ;
12293: LD_VAR 0 4
12297: PPUSH
12298: LD_VAR 0 3
12302: PUSH
12303: LD_INT 1
12305: PLUS
12306: PPUSH
12307: CALL 40088 0 2
12311: GO 12233
12313: POP
12314: POP
// end ;
12315: PPOPN 4
12317: END
// on ResearchCancel ( tech , lab ) do begin wait ( 10 ) ;
12318: LD_INT 10
12320: PPUSH
12321: CALL_OW 67
// if not IsBusy ( lab ) then
12325: LD_VAR 0 2
12329: PPUSH
12330: CALL_OW 315
12334: NOT
12335: IFFALSE 12362
// begin labs_in_use := labs_in_use diff lab ;
12337: LD_ADDR_EXP 80
12341: PUSH
12342: LD_EXP 80
12346: PUSH
12347: LD_VAR 0 2
12351: DIFF
12352: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12353: LD_VAR 0 2
12357: PPUSH
12358: CALL 40227 0 1
// end ; end ;
12362: PPOPN 2
12364: END
// on UnitDestroyed ( un ) do begin if un = MacMillan then
12365: LD_VAR 0 1
12369: PUSH
12370: LD_EXP 13
12374: EQUAL
12375: IFFALSE 12384
// Mission_failed ( 1 ) ;
12377: LD_INT 1
12379: PPUSH
12380: CALL 13898 0 1
// if un = Burlak then
12384: LD_VAR 0 1
12388: PUSH
12389: LD_EXP 12
12393: EQUAL
12394: IFFALSE 12403
// Mission_failed ( 2 ) ;
12396: LD_INT 2
12398: PPUSH
12399: CALL 13898 0 1
// Update_defend ( un ) ;
12403: LD_VAR 0 1
12407: PPUSH
12408: CALL 20822 0 1
// end ;
12412: PPOPN 1
12414: END
// on UnitGoesToRed ( un ) do begin if ( un = MacMillan ) and not Doctors_available ( MacMillan ) then
12415: LD_VAR 0 1
12419: PUSH
12420: LD_EXP 13
12424: EQUAL
12425: PUSH
12426: LD_EXP 13
12430: PPUSH
12431: CALL 12567 0 1
12435: NOT
12436: AND
12437: IFFALSE 12446
// Mission_failed ( 1 ) ;
12439: LD_INT 1
12441: PPUSH
12442: CALL 13898 0 1
// if ( un = Burlak ) and not Doctors_available ( Burlak ) then
12446: LD_VAR 0 1
12450: PUSH
12451: LD_EXP 12
12455: EQUAL
12456: PUSH
12457: LD_EXP 12
12461: PPUSH
12462: CALL 12567 0 1
12466: NOT
12467: AND
12468: IFFALSE 12477
// Mission_failed ( 2 ) ;
12470: LD_INT 2
12472: PPUSH
12473: CALL 13898 0 1
// if ( GetSide ( un ) = us ) and ( GetControl ( un ) = control_remote ) then
12477: LD_VAR 0 1
12481: PPUSH
12482: CALL_OW 255
12486: PUSH
12487: LD_EXP 3
12491: EQUAL
12492: PUSH
12493: LD_VAR 0 1
12497: PPUSH
12498: CALL_OW 263
12502: PUSH
12503: LD_INT 2
12505: EQUAL
12506: AND
12507: IFFALSE 12525
// begin ComUnlink ( un ) ;
12509: LD_VAR 0 1
12513: PPUSH
12514: CALL_OW 136
// check_remote ( 0 ) ;
12518: LD_INT 0
12520: PPUSH
12521: CALL 35341 0 1
// end ; if GetUnitMc ( un ) then
12525: LD_VAR 0 1
12529: PPUSH
12530: CALL_OW 388
12534: IFFALSE 12555
// RemoveMcUnits ( GetUnitMc ( un ) , un ) ;
12536: LD_VAR 0 1
12540: PPUSH
12541: CALL_OW 388
12545: PPUSH
12546: LD_VAR 0 1
12550: PPUSH
12551: CALL_OW 391
// Update_defend ( un ) ;
12555: LD_VAR 0 1
12559: PPUSH
12560: CALL 20822 0 1
// end ;
12564: PPOPN 1
12566: END
// function Doctors_available ( geroj ) ; var list , un , vysledek ; begin
12567: LD_INT 0
12569: PPUSH
12570: PPUSH
12571: PPUSH
12572: PPUSH
// vysledek := false ;
12573: LD_ADDR_VAR 0 5
12577: PUSH
12578: LD_INT 0
12580: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12581: LD_ADDR_VAR 0 3
12585: PUSH
12586: LD_INT 22
12588: PUSH
12589: LD_EXP 1
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: LD_INT 25
12600: PUSH
12601: LD_INT 4
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PPUSH
12612: CALL_OW 69
12616: ST_TO_ADDR
// if list then
12617: LD_VAR 0 3
12621: IFFALSE 12631
// vysledek := true ;
12623: LD_ADDR_VAR 0 5
12627: PUSH
12628: LD_INT 1
12630: ST_TO_ADDR
// if ( not vysledek ) and ( IsInArea ( geroj , ar_crates ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_lab ] ] ) ) then
12631: LD_VAR 0 5
12635: NOT
12636: PUSH
12637: LD_VAR 0 1
12641: PPUSH
12642: LD_INT 3
12644: PPUSH
12645: CALL_OW 308
12649: AND
12650: PUSH
12651: LD_INT 22
12653: PUSH
12654: LD_EXP 1
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: PUSH
12663: LD_INT 21
12665: PUSH
12666: LD_INT 1
12668: PUSH
12669: EMPTY
12670: LIST
12671: LIST
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PPUSH
12677: CALL_OW 69
12681: AND
12682: PUSH
12683: LD_INT 22
12685: PUSH
12686: LD_EXP 1
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 6
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: PPUSH
12709: CALL_OW 69
12713: AND
12714: IFFALSE 12724
// vysledek := true ;
12716: LD_ADDR_VAR 0 5
12720: PUSH
12721: LD_INT 1
12723: ST_TO_ADDR
// result := vysledek ;
12724: LD_ADDR_VAR 0 2
12728: PUSH
12729: LD_VAR 0 5
12733: ST_TO_ADDR
// end ;
12734: LD_VAR 0 2
12738: RET
// on Contact ( side1 , side2 ) do begin if ( side1 in [ ar_al , you ] ) and ( side2 in [ ar_al , you ] ) then
12739: LD_VAR 0 1
12743: PUSH
12744: LD_EXP 5
12748: PUSH
12749: LD_EXP 1
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: IN
12758: PUSH
12759: LD_VAR 0 2
12763: PUSH
12764: LD_EXP 5
12768: PUSH
12769: LD_EXP 1
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: IN
12778: AND
12779: IFFALSE 12789
// omar_in_contact := true ;
12781: LD_ADDR_EXP 65
12785: PUSH
12786: LD_INT 1
12788: ST_TO_ADDR
// end ;
12789: PPOPN 2
12791: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
12792: LD_VAR 0 1
12796: PPUSH
12797: CALL_OW 141
// if ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay ] ) then
12801: LD_VAR 0 1
12805: PPUSH
12806: CALL_OW 247
12810: PUSH
12811: LD_INT 2
12813: EQUAL
12814: PUSH
12815: LD_VAR 0 1
12819: PPUSH
12820: CALL_OW 264
12824: PUSH
12825: LD_INT 12
12827: PUSH
12828: LD_INT 51
12830: PUSH
12831: LD_INT 32
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: LIST
12838: IN
12839: AND
12840: IFFALSE 12856
// remove_bad_crates ( GetSide ( un ) ) ;
12842: LD_VAR 0 1
12846: PPUSH
12847: CALL_OW 255
12851: PPUSH
12852: CALL 34648 0 1
// end ;
12856: PPOPN 1
12858: END
// on VehicleConstructed ( veh , fac ) do var side , list , tower ;
12859: LD_INT 0
12861: PPUSH
12862: PPUSH
12863: PPUSH
// begin side := GetSide ( fac ) ;
12864: LD_ADDR_VAR 0 3
12868: PUSH
12869: LD_VAR 0 2
12873: PPUSH
12874: CALL_OW 255
12878: ST_TO_ADDR
// case side of 1 :
12879: LD_VAR 0 3
12883: PUSH
12884: LD_INT 1
12886: DOUBLE
12887: EQUAL
12888: IFTRUE 12892
12890: GO 13018
12892: POP
// begin check_remote ( veh ) ;
12893: LD_VAR 0 1
12897: PPUSH
12898: CALL 35341 0 1
// list := ready_forces [ side ] ^ veh ;
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: LD_EXP 66
12911: PUSH
12912: LD_VAR 0 3
12916: ARRAY
12917: PUSH
12918: LD_VAR 0 1
12922: ADD
12923: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , list ) ;
12924: LD_ADDR_EXP 66
12928: PUSH
12929: LD_EXP 66
12933: PPUSH
12934: LD_VAR 0 3
12938: PPUSH
12939: LD_VAR 0 4
12943: PPUSH
12944: CALL_OW 1
12948: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_control_tower ] ] ) ;
12949: LD_ADDR_VAR 0 5
12953: PUSH
12954: LD_INT 22
12956: PUSH
12957: LD_VAR 0 3
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 30
12968: PUSH
12969: LD_INT 36
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PPUSH
12980: CALL_OW 69
12984: ST_TO_ADDR
// AddComMoveToArea ( veh , us_parking ) ;
12985: LD_VAR 0 1
12989: PPUSH
12990: LD_INT 22
12992: PPUSH
12993: CALL_OW 173
// if GetWeapon ( veh ) = us_siberium_rocket then
12997: LD_VAR 0 1
13001: PPUSH
13002: CALL_OW 264
13006: PUSH
13007: LD_INT 8
13009: EQUAL
13010: IFFALSE 13016
// US_Wins ;
13012: CALL 13179 0 0
// end ; 2 :
13016: GO 13176
13018: LD_INT 2
13020: DOUBLE
13021: EQUAL
13022: IFTRUE 13026
13024: GO 13041
13026: POP
// ComMoveToArea ( veh , ar_parking ) ; 3 :
13027: LD_VAR 0 1
13031: PPUSH
13032: LD_INT 23
13034: PPUSH
13035: CALL_OW 113
13039: GO 13176
13041: LD_INT 3
13043: DOUBLE
13044: EQUAL
13045: IFTRUE 13049
13047: GO 13175
13049: POP
// begin if GetWeapon ( veh ) = ru_siberium_rocket then
13050: LD_VAR 0 1
13054: PPUSH
13055: CALL_OW 264
13059: PUSH
13060: LD_INT 48
13062: EQUAL
13063: IFFALSE 13094
// begin if us in cpu_list then
13065: LD_EXP 3
13069: PUSH
13070: LD_EXP 8
13074: IN
13075: IFFALSE 13088
// send_sib_to_US ( veh ) else
13077: LD_VAR 0 1
13081: PPUSH
13082: CALL 36757 0 1
13086: GO 13092
// RU_Wins ;
13088: CALL 13369 0 0
// end else
13092: GO 13173
// begin list := ready_forces [ side ] ^ veh ;
13094: LD_ADDR_VAR 0 4
13098: PUSH
13099: LD_EXP 66
13103: PUSH
13104: LD_VAR 0 3
13108: ARRAY
13109: PUSH
13110: LD_VAR 0 1
13114: ADD
13115: ST_TO_ADDR
// ready_forces := Delete ( ready_forces , side ) ;
13116: LD_ADDR_EXP 66
13120: PUSH
13121: LD_EXP 66
13125: PPUSH
13126: LD_VAR 0 3
13130: PPUSH
13131: CALL_OW 3
13135: ST_TO_ADDR
// ready_forces := Insert ( ready_forces , side , list ) ;
13136: LD_ADDR_EXP 66
13140: PUSH
13141: LD_EXP 66
13145: PPUSH
13146: LD_VAR 0 3
13150: PPUSH
13151: LD_VAR 0 4
13155: PPUSH
13156: CALL_OW 2
13160: ST_TO_ADDR
// ComMoveToArea ( veh , ru_parking ) ;
13161: LD_VAR 0 1
13165: PPUSH
13166: LD_INT 21
13168: PPUSH
13169: CALL_OW 113
// end ; end ; end ;
13173: GO 13176
13175: POP
// end ; end_of_file
13176: PPOPN 5
13178: END
// export function US_Wins ; begin
13179: LD_INT 0
13181: PPUSH
// DialogueOn ;
13182: CALL_OW 6
// if camp = 6 then
13186: LD_EXP 7
13190: PUSH
13191: LD_INT 6
13193: EQUAL
13194: IFFALSE 13207
// CenterOnUnits ( Burlak ) else
13196: LD_EXP 12
13200: PPUSH
13201: CALL_OW 85
13205: GO 13216
// CenterOnUnits ( MacMillan ) ;
13207: LD_EXP 13
13211: PPUSH
13212: CALL_OW 85
// wait ( 0 0$1 ) ;
13216: LD_INT 35
13218: PPUSH
13219: CALL_OW 67
// interface_hidden := true ;
13223: LD_ADDR_OWVAR 54
13227: PUSH
13228: LD_INT 1
13230: ST_TO_ADDR
// Say ( Powell , DWinAmericans-Pow-1 ) ;
13231: LD_EXP 56
13235: PPUSH
13236: LD_STRING DWinAmericans-Pow-1
13238: PPUSH
13239: CALL_OW 88
// case camp of 4 :
13243: LD_EXP 7
13247: PUSH
13248: LD_INT 4
13250: DOUBLE
13251: EQUAL
13252: IFTRUE 13256
13254: GO 13296
13256: POP
// if IsOK ( MacMillan ) then
13257: LD_EXP 13
13261: PPUSH
13262: CALL_OW 302
13266: IFFALSE 13282
// Say ( MacMillan , DWinAmericans-JMM-1 ) else
13268: LD_EXP 13
13272: PPUSH
13273: LD_STRING DWinAmericans-JMM-1
13275: PPUSH
13276: CALL_OW 88
13280: GO 13294
// Say ( Burlak , DWinAmericans-Bur-1 ) ; 6 :
13282: LD_EXP 12
13286: PPUSH
13287: LD_STRING DWinAmericans-Bur-1
13289: PPUSH
13290: CALL_OW 88
13294: GO 13345
13296: LD_INT 6
13298: DOUBLE
13299: EQUAL
13300: IFTRUE 13304
13302: GO 13344
13304: POP
// if IsOK ( Burlak ) then
13305: LD_EXP 12
13309: PPUSH
13310: CALL_OW 302
13314: IFFALSE 13330
// Say ( Burlak , DWinAmericans-Bur-1 ) else
13316: LD_EXP 12
13320: PPUSH
13321: LD_STRING DWinAmericans-Bur-1
13323: PPUSH
13324: CALL_OW 88
13328: GO 13342
// Say ( MacMillan , DWinAmericans-JMM-1 ) ; end ;
13330: LD_EXP 13
13334: PPUSH
13335: LD_STRING DWinAmericans-JMM-1
13337: PPUSH
13338: CALL_OW 88
13342: GO 13345
13344: POP
// interface_hidden := false ;
13345: LD_ADDR_OWVAR 54
13349: PUSH
13350: LD_INT 0
13352: ST_TO_ADDR
// DialogueOff ;
13353: CALL_OW 7
// Mission_failed ( 3 ) ;
13357: LD_INT 3
13359: PPUSH
13360: CALL 13898 0 1
// end ;
13364: LD_VAR 0 1
13368: RET
// export function RU_Wins ; begin
13369: LD_INT 0
13371: PPUSH
// if camp = 6 then
13372: LD_EXP 7
13376: PUSH
13377: LD_INT 6
13379: EQUAL
13380: IFFALSE 13393
// CenterOnUnits ( Burlak ) else
13382: LD_EXP 12
13386: PPUSH
13387: CALL_OW 85
13391: GO 13402
// CenterOnUnits ( MacMillan ) ;
13393: LD_EXP 13
13397: PPUSH
13398: CALL_OW 85
// DialogueOn ;
13402: CALL_OW 6
// InGameOn ;
13406: CALL_OW 8
// wait ( 0 0$1 ) ;
13410: LD_INT 35
13412: PPUSH
13413: CALL_OW 67
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13417: LD_EXP 57
13421: PPUSH
13422: LD_STRING DWinRussians-Pla-1
13424: PPUSH
13425: CALL_OW 94
// case camp of 4 :
13429: LD_EXP 7
13433: PUSH
13434: LD_INT 4
13436: DOUBLE
13437: EQUAL
13438: IFTRUE 13442
13440: GO 13482
13442: POP
// if IsOK ( MacMillan ) then
13443: LD_EXP 13
13447: PPUSH
13448: CALL_OW 302
13452: IFFALSE 13468
// Say ( MacMillan , DWinRussians-JMM-1 ) else
13454: LD_EXP 13
13458: PPUSH
13459: LD_STRING DWinRussians-JMM-1
13461: PPUSH
13462: CALL_OW 88
13466: GO 13480
// Say ( Burlak , DWinRussians-Bur-1 ) ; 6 :
13468: LD_EXP 12
13472: PPUSH
13473: LD_STRING DWinRussians-Bur-1
13475: PPUSH
13476: CALL_OW 88
13480: GO 13531
13482: LD_INT 6
13484: DOUBLE
13485: EQUAL
13486: IFTRUE 13490
13488: GO 13530
13490: POP
// if IsOK ( Burlak ) then
13491: LD_EXP 12
13495: PPUSH
13496: CALL_OW 302
13500: IFFALSE 13516
// Say ( Burlak , DWinRussians-Bur-1 ) else
13502: LD_EXP 12
13506: PPUSH
13507: LD_STRING DWinRussians-Bur-1
13509: PPUSH
13510: CALL_OW 88
13514: GO 13528
// Say ( MacMillan , DWinRussians-JMM-1 ) ; end ;
13516: LD_EXP 13
13520: PPUSH
13521: LD_STRING DWinRussians-JMM-1
13523: PPUSH
13524: CALL_OW 88
13528: GO 13531
13530: POP
// DialogueOff ;
13531: CALL_OW 7
// InGameOff ;
13535: CALL_OW 9
// Mission_failed ( 4 ) ;
13539: LD_INT 4
13541: PPUSH
13542: CALL 13898 0 1
// end ;
13546: LD_VAR 0 1
13550: RET
// on SiberiteRocketExploded ( un , x , y ) do begin InGameOn ;
13551: CALL_OW 8
// siberite_rocket_send := true ;
13555: LD_ADDR_EXP 61
13559: PUSH
13560: LD_INT 1
13562: ST_TO_ADDR
// wait ( 0 0$7 ) ;
13563: LD_INT 245
13565: PPUSH
13566: CALL_OW 67
// RU_Wins ;
13570: CALL 13369 0 0
// end ; end_of_file
13574: PPOPN 3
13576: END
// every 0 0$1 trigger finalize = 2 and ( not OmarWillTryContaminateMotherlode or GetLives ( Omar ) = 0 ) do
13577: LD_EXP 59
13581: PUSH
13582: LD_INT 2
13584: EQUAL
13585: PUSH
13586: LD_EXP 55
13590: NOT
13591: PUSH
13592: LD_EXP 52
13596: PPUSH
13597: CALL_OW 256
13601: PUSH
13602: LD_INT 0
13604: EQUAL
13605: OR
13606: AND
13607: IFFALSE 13623
13609: GO 13611
13611: DISABLE
// begin wait ( 0 0$1 ) ;
13612: LD_INT 35
13614: PPUSH
13615: CALL_OW 67
// Konec_Mise ;
13619: CALL 13624 0 0
// end ;
13623: END
// function Konec_Mise ; var campaign_loading , campaign_lost , another_campaign , medal1 , medal2 , medal3 ; begin
13624: LD_INT 0
13626: PPUSH
13627: PPUSH
13628: PPUSH
13629: PPUSH
13630: PPUSH
13631: PPUSH
13632: PPUSH
// lets_talking ;
13633: CALL 16276 0 0
// another_campaign := true ;
13637: LD_ADDR_VAR 0 4
13641: PUSH
13642: LD_INT 1
13644: ST_TO_ADDR
// gained_medals := [ ] ;
13645: LD_ADDR_OWVAR 61
13649: PUSH
13650: EMPTY
13651: ST_TO_ADDR
// missing_medals := [ ] ;
13652: LD_ADDR_OWVAR 62
13656: PUSH
13657: EMPTY
13658: ST_TO_ADDR
// medal1 := true ;
13659: LD_ADDR_VAR 0 5
13663: PUSH
13664: LD_INT 1
13666: ST_TO_ADDR
// medal2 := ( camp = 4 and IsOK ( Burlak ) ) or ( camp = 6 and IsOK ( MacMillan ) ) ;
13667: LD_ADDR_VAR 0 6
13671: PUSH
13672: LD_EXP 7
13676: PUSH
13677: LD_INT 4
13679: EQUAL
13680: PUSH
13681: LD_EXP 12
13685: PPUSH
13686: CALL_OW 302
13690: AND
13691: PUSH
13692: LD_EXP 7
13696: PUSH
13697: LD_INT 6
13699: EQUAL
13700: PUSH
13701: LD_EXP 13
13705: PPUSH
13706: CALL_OW 302
13710: AND
13711: OR
13712: ST_TO_ADDR
// medal3 := GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ;
13713: LD_ADDR_VAR 0 7
13717: PUSH
13718: LD_INT 81
13720: PPUSH
13721: CALL_OW 110
13725: PUSH
13726: LD_INT 181
13728: PPUSH
13729: CALL_OW 110
13733: AND
13734: PUSH
13735: LD_INT 281
13737: PPUSH
13738: CALL_OW 110
13742: AND
13743: ST_TO_ADDR
// AddMedal ( Hero , another_campaign ) ;
13744: LD_STRING Hero
13746: PPUSH
13747: LD_VAR 0 4
13751: PPUSH
13752: CALL_OW 101
// AddMedal ( Artefact , GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ) ;
13756: LD_STRING Artefact
13758: PPUSH
13759: LD_INT 81
13761: PPUSH
13762: CALL_OW 110
13766: PUSH
13767: LD_INT 181
13769: PPUSH
13770: CALL_OW 110
13774: AND
13775: PUSH
13776: LD_INT 281
13778: PPUSH
13779: CALL_OW 110
13783: AND
13784: PPUSH
13785: CALL_OW 101
// case camp of 4 :
13789: LD_EXP 7
13793: PUSH
13794: LD_INT 4
13796: DOUBLE
13797: EQUAL
13798: IFTRUE 13802
13800: GO 13822
13802: POP
// AddMedal ( ReconcileBurlak , IsOK ( Burlak ) ) ; 6 :
13803: LD_STRING ReconcileBurlak
13805: PPUSH
13806: LD_EXP 12
13810: PPUSH
13811: CALL_OW 302
13815: PPUSH
13816: CALL_OW 101
13820: GO 13851
13822: LD_INT 6
13824: DOUBLE
13825: EQUAL
13826: IFTRUE 13830
13828: GO 13850
13830: POP
// AddMedal ( ReconcileJMM , IsOK ( MacMillan ) ) ; end ;
13831: LD_STRING ReconcileJMM
13833: PPUSH
13834: LD_EXP 13
13838: PPUSH
13839: CALL_OW 302
13843: PPUSH
13844: CALL_OW 101
13848: GO 13851
13850: POP
// SA_OnMissionComplete ;
13851: CALL 42478 0 0
// SA_EndMission ( 4 , 4 , medal1 , medal2 , medal3 ) ;
13855: LD_INT 4
13857: PPUSH
13858: LD_INT 4
13860: PPUSH
13861: LD_VAR 0 5
13865: PPUSH
13866: LD_VAR 0 6
13870: PPUSH
13871: LD_VAR 0 7
13875: PPUSH
13876: CALL 42493 0 5
// GiveMedals ( Main ) ;
13880: LD_STRING Main
13882: PPUSH
13883: CALL_OW 102
// YouWin ;
13887: CALL_OW 103
// exit ;
13891: GO 13893
// end ;
13893: LD_VAR 0 1
13897: RET
// export function Mission_Failed ( how ) ; begin
13898: LD_INT 0
13900: PPUSH
// case how of 1 :
13901: LD_VAR 0 1
13905: PUSH
13906: LD_INT 1
13908: DOUBLE
13909: EQUAL
13910: IFTRUE 13914
13912: GO 13924
13914: POP
// YouLost ( JMM ) ; 2 :
13915: LD_STRING JMM
13917: PPUSH
13918: CALL_OW 104
13922: GO 13997
13924: LD_INT 2
13926: DOUBLE
13927: EQUAL
13928: IFTRUE 13932
13930: GO 13942
13932: POP
// YouLost ( Burlak ) ; 3 :
13933: LD_STRING Burlak
13935: PPUSH
13936: CALL_OW 104
13940: GO 13997
13942: LD_INT 3
13944: DOUBLE
13945: EQUAL
13946: IFTRUE 13950
13948: GO 13960
13950: POP
// YouLost ( AmBomb ) ; 4 :
13951: LD_STRING AmBomb
13953: PPUSH
13954: CALL_OW 104
13958: GO 13997
13960: LD_INT 4
13962: DOUBLE
13963: EQUAL
13964: IFTRUE 13968
13966: GO 13978
13968: POP
// YouLost ( RuBomb ) ; 5 :
13969: LD_STRING RuBomb
13971: PPUSH
13972: CALL_OW 104
13976: GO 13997
13978: LD_INT 5
13980: DOUBLE
13981: EQUAL
13982: IFTRUE 13986
13984: GO 13996
13986: POP
// YouLost ( MothContaminate ) ; end ;
13987: LD_STRING MothContaminate
13989: PPUSH
13990: CALL_OW 104
13994: GO 13997
13996: POP
// end ; end_of_file
13997: LD_VAR 0 2
14001: RET
// function Base_Destroyed ( side ) ; var un , list , vysledek ; begin
14002: LD_INT 0
14004: PPUSH
14005: PPUSH
14006: PPUSH
14007: PPUSH
// vysledek := false ;
14008: LD_ADDR_VAR 0 5
14012: PUSH
14013: LD_INT 0
14015: ST_TO_ADDR
// if not ( FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] ] ) or FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ) then
14016: LD_INT 22
14018: PUSH
14019: LD_VAR 0 1
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PUSH
14028: LD_INT 2
14030: PUSH
14031: LD_INT 30
14033: PUSH
14034: LD_INT 0
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 30
14043: PUSH
14044: LD_INT 1
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: EMPTY
14052: LIST
14053: LIST
14054: LIST
14055: PUSH
14056: LD_INT 50
14058: PUSH
14059: EMPTY
14060: LIST
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: PPUSH
14067: CALL_OW 69
14071: PUSH
14072: LD_INT 22
14074: PUSH
14075: LD_VAR 0 1
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: PUSH
14084: LD_INT 25
14086: PUSH
14087: LD_INT 2
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: PUSH
14094: LD_INT 50
14096: PUSH
14097: EMPTY
14098: LIST
14099: PUSH
14100: EMPTY
14101: LIST
14102: LIST
14103: LIST
14104: PPUSH
14105: CALL_OW 69
14109: OR
14110: NOT
14111: IFFALSE 14121
// vysledek := true ;
14113: LD_ADDR_VAR 0 5
14117: PUSH
14118: LD_INT 1
14120: ST_TO_ADDR
// if not vysledek then
14121: LD_VAR 0 5
14125: NOT
14126: IFFALSE 14189
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14128: LD_ADDR_VAR 0 4
14132: PUSH
14133: LD_INT 22
14135: PUSH
14136: LD_VAR 0 1
14140: PUSH
14141: EMPTY
14142: LIST
14143: LIST
14144: PUSH
14145: LD_INT 21
14147: PUSH
14148: LD_INT 1
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PUSH
14155: LD_INT 50
14157: PUSH
14158: EMPTY
14159: LIST
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: PPUSH
14166: CALL_OW 69
14170: ST_TO_ADDR
// if list < 3 then
14171: LD_VAR 0 4
14175: PUSH
14176: LD_INT 3
14178: LESS
14179: IFFALSE 14189
// vysledek := true ;
14181: LD_ADDR_VAR 0 5
14185: PUSH
14186: LD_INT 1
14188: ST_TO_ADDR
// end ; if not vysledek then
14189: LD_VAR 0 5
14193: NOT
14194: IFFALSE 14324
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_ok ] ] ) ;
14196: LD_ADDR_VAR 0 4
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_VAR 0 1
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 2
14215: PUSH
14216: LD_INT 30
14218: PUSH
14219: LD_INT 32
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 33
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 50
14243: PUSH
14244: EMPTY
14245: LIST
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: LIST
14251: PPUSH
14252: CALL_OW 69
14256: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
14257: LD_ADDR_VAR 0 3
14261: PUSH
14262: LD_INT 22
14264: PUSH
14265: LD_VAR 0 1
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 2
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PUSH
14284: LD_INT 50
14286: PUSH
14287: EMPTY
14288: LIST
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 69
14299: ST_TO_ADDR
// if ( un + list ) < 5 then
14300: LD_VAR 0 3
14304: PUSH
14305: LD_VAR 0 4
14309: PLUS
14310: PUSH
14311: LD_INT 5
14313: LESS
14314: IFFALSE 14324
// vysledek := true ;
14316: LD_ADDR_VAR 0 5
14320: PUSH
14321: LD_INT 1
14323: ST_TO_ADDR
// end ; if not vysledek then
14324: LD_VAR 0 5
14328: NOT
14329: IFFALSE 14418
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] , [ f_ok ] ] ) ;
14331: LD_ADDR_VAR 0 4
14335: PUSH
14336: LD_INT 22
14338: PUSH
14339: LD_VAR 0 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 2
14350: PUSH
14351: LD_INT 30
14353: PUSH
14354: LD_INT 27
14356: PUSH
14357: EMPTY
14358: LIST
14359: LIST
14360: PUSH
14361: LD_INT 30
14363: PUSH
14364: LD_INT 26
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PUSH
14371: LD_INT 30
14373: PUSH
14374: LD_INT 28
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: PUSH
14387: LD_INT 50
14389: PUSH
14390: EMPTY
14391: LIST
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: LIST
14397: PPUSH
14398: CALL_OW 69
14402: ST_TO_ADDR
// if not list then
14403: LD_VAR 0 4
14407: NOT
14408: IFFALSE 14418
// vysledek := 0 ;
14410: LD_ADDR_VAR 0 5
14414: PUSH
14415: LD_INT 0
14417: ST_TO_ADDR
// end ; result := vysledek ;
14418: LD_ADDR_VAR 0 2
14422: PUSH
14423: LD_VAR 0 5
14427: ST_TO_ADDR
// end ;
14428: LD_VAR 0 2
14432: RET
// every 0 0$2.1 trigger Base_Destroyed ( us ) and not siberite_rocket_send do var sol , un , list ;
14433: LD_EXP 3
14437: PPUSH
14438: CALL 14002 0 1
14442: PUSH
14443: LD_EXP 61
14447: NOT
14448: AND
14449: IFFALSE 15016
14451: GO 14453
14453: DISABLE
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
// begin if IsOK ( Powell ) then
14459: LD_EXP 56
14463: PPUSH
14464: CALL_OW 302
14468: IFFALSE 14546
// begin CenterOnUnits ( Powell ) ;
14470: LD_EXP 56
14474: PPUSH
14475: CALL_OW 85
// DialogueOn ;
14479: CALL_OW 6
// interface_hidden := true ;
14483: LD_ADDR_OWVAR 54
14487: PUSH
14488: LD_INT 1
14490: ST_TO_ADDR
// Say ( Powell , DSurrenderAmericans-Pow-1 ) ;
14491: LD_EXP 56
14495: PPUSH
14496: LD_STRING DSurrenderAmericans-Pow-1
14498: PPUSH
14499: CALL_OW 88
// Say ( MacMillan , DSurrenderAmericans-JMM-1 ) ;
14503: LD_EXP 13
14507: PPUSH
14508: LD_STRING DSurrenderAmericans-JMM-1
14510: PPUSH
14511: CALL_OW 88
// interface_hidden := false ;
14515: LD_ADDR_OWVAR 54
14519: PUSH
14520: LD_INT 0
14522: ST_TO_ADDR
// DialogueOff ;
14523: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
14527: LD_INT 35
14529: PPUSH
14530: CALL_OW 67
// until not IsOK ( Powell ) ;
14534: LD_EXP 56
14538: PPUSH
14539: CALL_OW 302
14543: NOT
14544: IFFALSE 14527
// end ; cpu_list := cpu_list diff us ;
14546: LD_ADDR_EXP 8
14550: PUSH
14551: LD_EXP 8
14555: PUSH
14556: LD_EXP 3
14560: DIFF
14561: ST_TO_ADDR
// SetAttitude ( you , us , att_friend , true ) ;
14562: LD_EXP 1
14566: PPUSH
14567: LD_EXP 3
14571: PPUSH
14572: LD_INT 1
14574: PPUSH
14575: LD_INT 1
14577: PPUSH
14578: CALL_OW 80
// sol := FindLastMohycane ( us ) ;
14582: LD_ADDR_VAR 0 1
14586: PUSH
14587: LD_EXP 3
14591: PPUSH
14592: CALL 15892 0 1
14596: ST_TO_ADDR
// if IsOK ( sol ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: CALL_OW 302
14606: IFFALSE 14617
// ComExitBuilding ( sol ) ;
14608: LD_VAR 0 1
14612: PPUSH
14613: CALL_OW 122
// while not See ( you , sol ) do
14617: LD_EXP 1
14621: PPUSH
14622: LD_VAR 0 1
14626: PPUSH
14627: CALL_OW 292
14631: NOT
14632: IFFALSE 14699
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
14634: LD_ADDR_VAR 0 2
14638: PUSH
14639: LD_INT 22
14641: PUSH
14642: LD_EXP 1
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: LD_INT 50
14653: PUSH
14654: EMPTY
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PPUSH
14661: CALL_OW 69
14665: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
14666: LD_VAR 0 1
14670: PPUSH
14671: LD_VAR 0 2
14675: PPUSH
14676: LD_VAR 0 1
14680: PPUSH
14681: CALL_OW 74
14685: PPUSH
14686: CALL_OW 112
// wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// end ;
14697: GO 14617
// CenterOnUnits ( sol ) ;
14699: LD_VAR 0 1
14703: PPUSH
14704: CALL_OW 85
// DialogueOn ;
14708: CALL_OW 6
// interface_hidden := true ;
14712: LD_ADDR_OWVAR 54
14716: PUSH
14717: LD_INT 1
14719: ST_TO_ADDR
// case camp of 4 :
14720: LD_EXP 7
14724: PUSH
14725: LD_INT 4
14727: DOUBLE
14728: EQUAL
14729: IFTRUE 14733
14731: GO 14748
14733: POP
// Say ( sol , DSurrenderAmericans-Sol1-1a ) ; 6 :
14734: LD_VAR 0 1
14738: PPUSH
14739: LD_STRING DSurrenderAmericans-Sol1-1a
14741: PPUSH
14742: CALL_OW 88
14746: GO 14772
14748: LD_INT 6
14750: DOUBLE
14751: EQUAL
14752: IFTRUE 14756
14754: GO 14771
14756: POP
// Say ( sol , DSurrenderAmericans-Sol1-1 ) ; end ;
14757: LD_VAR 0 1
14761: PPUSH
14762: LD_STRING DSurrenderAmericans-Sol1-1
14764: PPUSH
14765: CALL_OW 88
14769: GO 14772
14771: POP
// interface_hidden := false ;
14772: LD_ADDR_OWVAR 54
14776: PUSH
14777: LD_INT 0
14779: ST_TO_ADDR
// DialogueOff ;
14780: CALL_OW 7
// finalize := finalize + 1 ;
14784: LD_ADDR_EXP 59
14788: PUSH
14789: LD_EXP 59
14793: PUSH
14794: LD_INT 1
14796: PLUS
14797: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , us ] , f_not , [ f_type , unit_human ] ] ) ;
14798: LD_ADDR_VAR 0 3
14802: PUSH
14803: LD_INT 22
14805: PUSH
14806: LD_EXP 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: LD_INT 21
14820: PUSH
14821: LD_INT 1
14823: PUSH
14824: EMPTY
14825: LIST
14826: LIST
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: LIST
14832: PPUSH
14833: CALL_OW 69
14837: ST_TO_ADDR
// SetSide ( list , you ) ;
14838: LD_VAR 0 3
14842: PPUSH
14843: LD_EXP 1
14847: PPUSH
14848: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
14852: LD_VAR 0 3
14856: PPUSH
14857: LD_INT 21
14859: PUSH
14860: LD_INT 2
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: PPUSH
14867: CALL_OW 72
14871: PPUSH
14872: CALL 15019 0 1
// repeat list := FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14876: LD_ADDR_VAR 0 3
14880: PUSH
14881: LD_INT 22
14883: PUSH
14884: LD_EXP 3
14888: PUSH
14889: EMPTY
14890: LIST
14891: LIST
14892: PUSH
14893: LD_INT 21
14895: PUSH
14896: LD_INT 1
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 50
14905: PUSH
14906: EMPTY
14907: LIST
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: LIST
14913: PPUSH
14914: CALL_OW 69
14918: ST_TO_ADDR
// ComMoveToArea ( list , am_leaving_area ) ;
14919: LD_VAR 0 3
14923: PPUSH
14924: LD_INT 30
14926: PPUSH
14927: CALL_OW 113
// if list then
14931: LD_VAR 0 3
14935: IFFALSE 14944
// wait ( 0 0$2 ) ;
14937: LD_INT 70
14939: PPUSH
14940: CALL_OW 67
// sol := FilterUnitsInArea ( am_leaving_area , [ [ f_side , us ] , [ f_type , unit_human ] ] ) ;
14944: LD_ADDR_VAR 0 1
14948: PUSH
14949: LD_INT 30
14951: PPUSH
14952: LD_INT 22
14954: PUSH
14955: LD_EXP 3
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: LD_INT 21
14966: PUSH
14967: LD_INT 1
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PPUSH
14978: CALL_OW 70
14982: ST_TO_ADDR
// for un in sol do
14983: LD_ADDR_VAR 0 2
14987: PUSH
14988: LD_VAR 0 1
14992: PUSH
14993: FOR_IN
14994: IFFALSE 15007
// RemoveUnit ( un ) ;
14996: LD_VAR 0 2
15000: PPUSH
15001: CALL_OW 64
15005: GO 14993
15007: POP
15008: POP
// until not list ;
15009: LD_VAR 0 3
15013: NOT
15014: IFFALSE 14876
// end ;
15016: PPOPN 3
15018: END
// function DestroyAndReplaceVehicles ( list ) ; var i , x , y , driver , veh ; begin
15019: LD_INT 0
15021: PPUSH
15022: PPUSH
15023: PPUSH
15024: PPUSH
15025: PPUSH
15026: PPUSH
// for i in list do
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: LD_VAR 0 1
15036: PUSH
15037: FOR_IN
15038: IFFALSE 15299
// begin InitUc ;
15040: CALL_OW 18
// InitVc ;
15044: CALL_OW 20
// uc_nation = GetNation ( i ) ;
15048: LD_ADDR_OWVAR 21
15052: PUSH
15053: LD_VAR 0 3
15057: PPUSH
15058: CALL_OW 248
15062: ST_TO_ADDR
// uc_side = GetSide ( i ) ;
15063: LD_ADDR_OWVAR 20
15067: PUSH
15068: LD_VAR 0 3
15072: PPUSH
15073: CALL_OW 255
15077: ST_TO_ADDR
// uc_direction = GetDir ( i ) ;
15078: LD_ADDR_OWVAR 24
15082: PUSH
15083: LD_VAR 0 3
15087: PPUSH
15088: CALL_OW 254
15092: ST_TO_ADDR
// vc_chassis = GetChassis ( i ) ;
15093: LD_ADDR_OWVAR 37
15097: PUSH
15098: LD_VAR 0 3
15102: PPUSH
15103: CALL_OW 265
15107: ST_TO_ADDR
// vc_engine = GetEngine ( i ) ;
15108: LD_ADDR_OWVAR 39
15112: PUSH
15113: LD_VAR 0 3
15117: PPUSH
15118: CALL_OW 262
15122: ST_TO_ADDR
// vc_weapon = GetWeapon ( i ) ;
15123: LD_ADDR_OWVAR 40
15127: PUSH
15128: LD_VAR 0 3
15132: PPUSH
15133: CALL_OW 264
15137: ST_TO_ADDR
// vc_control = GetControl ( i ) ;
15138: LD_ADDR_OWVAR 38
15142: PUSH
15143: LD_VAR 0 3
15147: PPUSH
15148: CALL_OW 263
15152: ST_TO_ADDR
// vc_fuel_battery = GetFuel ( i ) ;
15153: LD_ADDR_OWVAR 41
15157: PUSH
15158: LD_VAR 0 3
15162: PPUSH
15163: CALL_OW 261
15167: ST_TO_ADDR
// x = GetX ( i ) ;
15168: LD_ADDR_VAR 0 4
15172: PUSH
15173: LD_VAR 0 3
15177: PPUSH
15178: CALL_OW 250
15182: ST_TO_ADDR
// y = GetY ( i ) ;
15183: LD_ADDR_VAR 0 5
15187: PUSH
15188: LD_VAR 0 3
15192: PPUSH
15193: CALL_OW 251
15197: ST_TO_ADDR
// driver = IsDrivenBy ( i ) ;
15198: LD_ADDR_VAR 0 6
15202: PUSH
15203: LD_VAR 0 3
15207: PPUSH
15208: CALL_OW 311
15212: ST_TO_ADDR
// if driver > 0 then
15213: LD_VAR 0 6
15217: PUSH
15218: LD_INT 0
15220: GREATER
15221: IFFALSE 15232
// RemoveUnit ( driver ) ;
15223: LD_VAR 0 6
15227: PPUSH
15228: CALL_OW 64
// DestroyUnit ( i ) ;
15232: LD_VAR 0 3
15236: PPUSH
15237: CALL_OW 65
// veh = CreateVehicle ;
15241: LD_ADDR_VAR 0 7
15245: PUSH
15246: CALL_OW 45
15250: ST_TO_ADDR
// PlaceUnitXY ( veh , x , y , false ) ;
15251: LD_VAR 0 7
15255: PPUSH
15256: LD_VAR 0 4
15260: PPUSH
15261: LD_VAR 0 5
15265: PPUSH
15266: LD_INT 0
15268: PPUSH
15269: CALL_OW 48
// if driver > 0 then
15273: LD_VAR 0 6
15277: PUSH
15278: LD_INT 0
15280: GREATER
15281: IFFALSE 15297
// PlaceHumanInUnit ( driver , veh ) ;
15283: LD_VAR 0 6
15287: PPUSH
15288: LD_VAR 0 7
15292: PPUSH
15293: CALL_OW 52
// end ;
15297: GO 15037
15299: POP
15300: POP
// end ;
15301: LD_VAR 0 2
15305: RET
// every 0 0$2.3 trigger Base_Destroyed ( ru ) and not siberite_rocket_send do var list , sol , un ;
15306: LD_EXP 2
15310: PPUSH
15311: CALL 14002 0 1
15315: PUSH
15316: LD_EXP 61
15320: NOT
15321: AND
15322: IFFALSE 15889
15324: GO 15326
15326: DISABLE
15327: LD_INT 0
15329: PPUSH
15330: PPUSH
15331: PPUSH
// begin if IsOK ( Platonov ) then
15332: LD_EXP 57
15336: PPUSH
15337: CALL_OW 302
15341: IFFALSE 15419
// begin CenterOnUnits ( Platonov ) ;
15343: LD_EXP 57
15347: PPUSH
15348: CALL_OW 85
// DialogueOn ;
15352: CALL_OW 6
// interface_hidden := true ;
15356: LD_ADDR_OWVAR 54
15360: PUSH
15361: LD_INT 1
15363: ST_TO_ADDR
// Say ( Platonov , DSurrenderRussians-Pla-1 ) ;
15364: LD_EXP 57
15368: PPUSH
15369: LD_STRING DSurrenderRussians-Pla-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15376: LD_EXP 12
15380: PPUSH
15381: LD_STRING DSurrenderRussians-Bur-1
15383: PPUSH
15384: CALL_OW 88
// interface_hidden := false ;
15388: LD_ADDR_OWVAR 54
15392: PUSH
15393: LD_INT 0
15395: ST_TO_ADDR
// DialogueOff ;
15396: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
15400: LD_INT 35
15402: PPUSH
15403: CALL_OW 67
// until not IsOK ( Platonov ) ;
15407: LD_EXP 57
15411: PPUSH
15412: CALL_OW 302
15416: NOT
15417: IFFALSE 15400
// end ; cpu_list := cpu_list diff ru ;
15419: LD_ADDR_EXP 8
15423: PUSH
15424: LD_EXP 8
15428: PUSH
15429: LD_EXP 2
15433: DIFF
15434: ST_TO_ADDR
// SetAttitude ( you , ru , att_friend , true ) ;
15435: LD_EXP 1
15439: PPUSH
15440: LD_EXP 2
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: LD_INT 1
15450: PPUSH
15451: CALL_OW 80
// sol := FindLastMohycane ( ru ) ;
15455: LD_ADDR_VAR 0 2
15459: PUSH
15460: LD_EXP 2
15464: PPUSH
15465: CALL 15892 0 1
15469: ST_TO_ADDR
// if IsOK ( sol ) then
15470: LD_VAR 0 2
15474: PPUSH
15475: CALL_OW 302
15479: IFFALSE 15490
// ComExitBuilding ( sol ) ;
15481: LD_VAR 0 2
15485: PPUSH
15486: CALL_OW 122
// while not See ( you , sol ) do
15490: LD_EXP 1
15494: PPUSH
15495: LD_VAR 0 2
15499: PPUSH
15500: CALL_OW 292
15504: NOT
15505: IFFALSE 15572
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
15507: LD_ADDR_VAR 0 3
15511: PUSH
15512: LD_INT 22
15514: PUSH
15515: LD_EXP 1
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PUSH
15524: LD_INT 50
15526: PUSH
15527: EMPTY
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PPUSH
15534: CALL_OW 69
15538: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
15539: LD_VAR 0 2
15543: PPUSH
15544: LD_VAR 0 3
15548: PPUSH
15549: LD_VAR 0 2
15553: PPUSH
15554: CALL_OW 74
15558: PPUSH
15559: CALL_OW 112
// wait ( 0 0$1 ) ;
15563: LD_INT 35
15565: PPUSH
15566: CALL_OW 67
// end ;
15570: GO 15490
// CenterOnUnits ( sol ) ;
15572: LD_VAR 0 2
15576: PPUSH
15577: CALL_OW 85
// DialogueOn ;
15581: CALL_OW 6
// interface_hidden := true ;
15585: LD_ADDR_OWVAR 54
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// case camp of 4 :
15593: LD_EXP 7
15597: PUSH
15598: LD_INT 4
15600: DOUBLE
15601: EQUAL
15602: IFTRUE 15606
15604: GO 15621
15606: POP
// Say ( sol , DSurrenderRussians-Rsol1-1a ) ; 6 :
15607: LD_VAR 0 2
15611: PPUSH
15612: LD_STRING DSurrenderRussians-Rsol1-1a
15614: PPUSH
15615: CALL_OW 88
15619: GO 15645
15621: LD_INT 6
15623: DOUBLE
15624: EQUAL
15625: IFTRUE 15629
15627: GO 15644
15629: POP
// Say ( sol , DSurrenderRussians-Rsol1-1 ) ; end ;
15630: LD_VAR 0 2
15634: PPUSH
15635: LD_STRING DSurrenderRussians-Rsol1-1
15637: PPUSH
15638: CALL_OW 88
15642: GO 15645
15644: POP
// interface_hidden := false ;
15645: LD_ADDR_OWVAR 54
15649: PUSH
15650: LD_INT 0
15652: ST_TO_ADDR
// DialogueOff ;
15653: CALL_OW 7
// finalize := finalize + 1 ;
15657: LD_ADDR_EXP 59
15661: PUSH
15662: LD_EXP 59
15666: PUSH
15667: LD_INT 1
15669: PLUS
15670: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , ru ] , f_not , [ f_type , unit_human ] ] ) ;
15671: LD_ADDR_VAR 0 1
15675: PUSH
15676: LD_INT 22
15678: PUSH
15679: LD_EXP 2
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: LD_INT 3
15690: PUSH
15691: LD_INT 21
15693: PUSH
15694: LD_INT 1
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: LIST
15705: PPUSH
15706: CALL_OW 69
15710: ST_TO_ADDR
// SetSide ( list , you ) ;
15711: LD_VAR 0 1
15715: PPUSH
15716: LD_EXP 1
15720: PPUSH
15721: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15725: LD_VAR 0 1
15729: PPUSH
15730: LD_INT 21
15732: PUSH
15733: LD_INT 2
15735: PUSH
15736: EMPTY
15737: LIST
15738: LIST
15739: PPUSH
15740: CALL_OW 72
15744: PPUSH
15745: CALL 15019 0 1
// repeat list := FilterAllUnits ( [ [ f_side , ru ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
15749: LD_ADDR_VAR 0 1
15753: PUSH
15754: LD_INT 22
15756: PUSH
15757: LD_EXP 2
15761: PUSH
15762: EMPTY
15763: LIST
15764: LIST
15765: PUSH
15766: LD_INT 21
15768: PUSH
15769: LD_INT 1
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PUSH
15776: LD_INT 50
15778: PUSH
15779: EMPTY
15780: LIST
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: LIST
15786: PPUSH
15787: CALL_OW 69
15791: ST_TO_ADDR
// ComMoveToArea ( list , ru_leaving_area ) ;
15792: LD_VAR 0 1
15796: PPUSH
15797: LD_INT 31
15799: PPUSH
15800: CALL_OW 113
// if list then
15804: LD_VAR 0 1
15808: IFFALSE 15817
// wait ( 0 0$2 ) ;
15810: LD_INT 70
15812: PPUSH
15813: CALL_OW 67
// sol := FilterUnitsInArea ( ru_leaving_area , [ [ f_side , ru ] , [ f_type , unit_human ] ] ) ;
15817: LD_ADDR_VAR 0 2
15821: PUSH
15822: LD_INT 31
15824: PPUSH
15825: LD_INT 22
15827: PUSH
15828: LD_EXP 2
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 21
15839: PUSH
15840: LD_INT 1
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: PUSH
15847: EMPTY
15848: LIST
15849: LIST
15850: PPUSH
15851: CALL_OW 70
15855: ST_TO_ADDR
// for un in sol do
15856: LD_ADDR_VAR 0 3
15860: PUSH
15861: LD_VAR 0 2
15865: PUSH
15866: FOR_IN
15867: IFFALSE 15880
// RemoveUnit ( un ) ;
15869: LD_VAR 0 3
15873: PPUSH
15874: CALL_OW 64
15878: GO 15866
15880: POP
15881: POP
// until not list ;
15882: LD_VAR 0 1
15886: NOT
15887: IFFALSE 15749
// end ;
15889: PPOPN 3
15891: END
// function FindLastMohycane ( side ) ; var area , un , list , build , unseen , vysledek ; begin
15892: LD_INT 0
15894: PPUSH
15895: PPUSH
15896: PPUSH
15897: PPUSH
15898: PPUSH
15899: PPUSH
15900: PPUSH
// case side of us :
15901: LD_VAR 0 1
15905: PUSH
15906: LD_EXP 3
15910: DOUBLE
15911: EQUAL
15912: IFTRUE 15916
15914: GO 15927
15916: POP
// area := us_base ; ru :
15917: LD_ADDR_VAR 0 3
15921: PUSH
15922: LD_INT 11
15924: ST_TO_ADDR
15925: GO 15949
15927: LD_EXP 2
15931: DOUBLE
15932: EQUAL
15933: IFTRUE 15937
15935: GO 15948
15937: POP
// area := ru_base ; end ;
15938: LD_ADDR_VAR 0 3
15942: PUSH
15943: LD_INT 12
15945: ST_TO_ADDR
15946: GO 15949
15948: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
15949: LD_ADDR_VAR 0 5
15953: PUSH
15954: LD_INT 22
15956: PUSH
15957: LD_VAR 0 1
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 21
15968: PUSH
15969: LD_INT 1
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: LD_INT 26
15978: PUSH
15979: LD_INT 1
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 50
15988: PUSH
15989: EMPTY
15990: LIST
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: PPUSH
15998: CALL_OW 69
16002: PUSH
16003: LD_INT 22
16005: PUSH
16006: LD_VAR 0 1
16010: PUSH
16011: EMPTY
16012: LIST
16013: LIST
16014: PUSH
16015: LD_INT 2
16017: PUSH
16018: LD_INT 25
16020: PUSH
16021: LD_INT 12
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: PUSH
16028: LD_INT 25
16030: PUSH
16031: LD_INT 15
16033: PUSH
16034: EMPTY
16035: LIST
16036: LIST
16037: PUSH
16038: LD_INT 25
16040: PUSH
16041: LD_INT 16
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: PUSH
16048: LD_INT 25
16050: PUSH
16051: LD_INT 17
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: LIST
16062: LIST
16063: LIST
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PPUSH
16069: CALL_OW 69
16073: DIFF
16074: ST_TO_ADDR
// if list then
16075: LD_VAR 0 5
16079: IFFALSE 16101
// vysledek := FindMaxSkill ( list , skill_combat ) else
16081: LD_ADDR_VAR 0 8
16085: PUSH
16086: LD_VAR 0 5
16090: PPUSH
16091: LD_INT 1
16093: PPUSH
16094: CALL_OW 433
16098: ST_TO_ADDR
16099: GO 16261
// begin unseen := 0 ;
16101: LD_ADDR_VAR 0 7
16105: PUSH
16106: LD_INT 0
16108: ST_TO_ADDR
// build := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_ok ] ] ) ;
16109: LD_ADDR_VAR 0 6
16113: PUSH
16114: LD_INT 22
16116: PUSH
16117: LD_VAR 0 1
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PUSH
16126: LD_INT 58
16128: PUSH
16129: EMPTY
16130: LIST
16131: PUSH
16132: LD_INT 50
16134: PUSH
16135: EMPTY
16136: LIST
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: LIST
16142: PPUSH
16143: CALL_OW 69
16147: ST_TO_ADDR
// for un in build do
16148: LD_ADDR_VAR 0 4
16152: PUSH
16153: LD_VAR 0 6
16157: PUSH
16158: FOR_IN
16159: IFFALSE 16192
// if not See ( you , un ) then
16161: LD_EXP 1
16165: PPUSH
16166: LD_VAR 0 4
16170: PPUSH
16171: CALL_OW 292
16175: NOT
16176: IFFALSE 16190
// begin unseen := un ;
16178: LD_ADDR_VAR 0 7
16182: PUSH
16183: LD_VAR 0 4
16187: ST_TO_ADDR
// break ;
16188: GO 16192
// end ;
16190: GO 16158
16192: POP
16193: POP
// if ( not unseen ) and build then
16194: LD_VAR 0 7
16198: NOT
16199: PUSH
16200: LD_VAR 0 6
16204: AND
16205: IFFALSE 16221
// unseen := build [ 1 ] ;
16207: LD_ADDR_VAR 0 7
16211: PUSH
16212: LD_VAR 0 6
16216: PUSH
16217: LD_INT 1
16219: ARRAY
16220: ST_TO_ADDR
// if unseen then
16221: LD_VAR 0 7
16225: IFFALSE 16261
// begin PrepareSoldier ( sex_male , 5 ) ;
16227: LD_INT 1
16229: PPUSH
16230: LD_INT 5
16232: PPUSH
16233: CALL_OW 381
// vysledek := CreateHuman ;
16237: LD_ADDR_VAR 0 8
16241: PUSH
16242: CALL_OW 44
16246: ST_TO_ADDR
// PlaceHumanInUnit ( vysledek , unseen ) ;
16247: LD_VAR 0 8
16251: PPUSH
16252: LD_VAR 0 7
16256: PPUSH
16257: CALL_OW 52
// end ; end ; result := vysledek ;
16261: LD_ADDR_VAR 0 2
16265: PUSH
16266: LD_VAR 0 8
16270: ST_TO_ADDR
// end ; end_of_file
16271: LD_VAR 0 2
16275: RET
// export function lets_talking ; begin
16276: LD_INT 0
16278: PPUSH
// DialogueOn ;
16279: CALL_OW 6
// interface_hidden := true ;
16283: LD_ADDR_OWVAR 54
16287: PUSH
16288: LD_INT 1
16290: ST_TO_ADDR
// case camp of 4 :
16291: LD_EXP 7
16295: PUSH
16296: LD_INT 4
16298: DOUBLE
16299: EQUAL
16300: IFTRUE 16304
16302: GO 16311
16304: POP
// us_talking ; 6 :
16305: CALL 17376 0 0
16309: GO 16327
16311: LD_INT 6
16313: DOUBLE
16314: EQUAL
16315: IFTRUE 16319
16317: GO 16326
16319: POP
// ru_talking ; end ;
16320: CALL 16344 0 0
16324: GO 16327
16326: POP
// interface_hidden := false ;
16327: LD_ADDR_OWVAR 54
16331: PUSH
16332: LD_INT 0
16334: ST_TO_ADDR
// DialogueOff ;
16335: CALL_OW 7
// end ;
16339: LD_VAR 0 1
16343: RET
// function ru_talking ; begin
16344: LD_INT 0
16346: PPUSH
// if IsOK ( Burlak ) then
16347: LD_EXP 12
16351: PPUSH
16352: CALL_OW 302
16356: IFFALSE 16379
// begin CenterOnUnits ( Burlak ) ;
16358: LD_EXP 12
16362: PPUSH
16363: CALL_OW 85
// Say ( Burlak , DEnd-Burlak-Bur-1 ) ;
16367: LD_EXP 12
16371: PPUSH
16372: LD_STRING DEnd-Burlak-Bur-1
16374: PPUSH
16375: CALL_OW 88
// end ; if IsOK ( Petrosyan ) then
16379: LD_EXP 16
16383: PPUSH
16384: CALL_OW 302
16388: IFFALSE 16411
// begin CenterOnUnits ( Petrosyan ) ;
16390: LD_EXP 16
16394: PPUSH
16395: CALL_OW 85
// Say ( Petrosyan , DEnd-Burlak-Pty-1 ) ;
16399: LD_EXP 16
16403: PPUSH
16404: LD_STRING DEnd-Burlak-Pty-1
16406: PPUSH
16407: CALL_OW 88
// end ; if IsOK ( Belkov ) then
16411: LD_EXP 17
16415: PPUSH
16416: CALL_OW 302
16420: IFFALSE 16443
// begin CenterOnUnits ( Belkov ) ;
16422: LD_EXP 17
16426: PPUSH
16427: CALL_OW 85
// Say ( Belkov , DEnd-Burlak-Bel-1 ) ;
16431: LD_EXP 17
16435: PPUSH
16436: LD_STRING DEnd-Burlak-Bel-1
16438: PPUSH
16439: CALL_OW 88
// end ; if IsOK ( Kirilenkova ) then
16443: LD_EXP 18
16447: PPUSH
16448: CALL_OW 302
16452: IFFALSE 16475
// begin CenterOnUnits ( Kirilenkova ) ;
16454: LD_EXP 18
16458: PPUSH
16459: CALL_OW 85
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16463: LD_EXP 18
16467: PPUSH
16468: LD_STRING DEnd-Burlak-Kir-1
16470: PPUSH
16471: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
16475: LD_EXP 19
16479: PPUSH
16480: CALL_OW 302
16484: IFFALSE 16507
// begin CenterOnUnits ( Gnyevko ) ;
16486: LD_EXP 19
16490: PPUSH
16491: CALL_OW 85
// Say ( Gnyevko , DEnd-Burlak-Gny-1 ) ;
16495: LD_EXP 19
16499: PPUSH
16500: LD_STRING DEnd-Burlak-Gny-1
16502: PPUSH
16503: CALL_OW 88
// end ; if IsOK ( Gladkov ) then
16507: LD_EXP 20
16511: PPUSH
16512: CALL_OW 302
16516: IFFALSE 16539
// begin CenterOnUnits ( Gladkov ) ;
16518: LD_EXP 20
16522: PPUSH
16523: CALL_OW 85
// Say ( Gladkov , DEnd-Burlak-Gla-1 ) ;
16527: LD_EXP 20
16531: PPUSH
16532: LD_STRING DEnd-Burlak-Gla-1
16534: PPUSH
16535: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
16539: LD_EXP 21
16543: PPUSH
16544: CALL_OW 302
16548: IFFALSE 16571
// begin CenterOnUnits ( Dolgov ) ;
16550: LD_EXP 21
16554: PPUSH
16555: CALL_OW 85
// Say ( Dolgov , DEnd-Burlak-Dol-1 ) ;
16559: LD_EXP 21
16563: PPUSH
16564: LD_STRING DEnd-Burlak-Dol-1
16566: PPUSH
16567: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
16571: LD_EXP 23
16575: PPUSH
16576: CALL_OW 302
16580: IFFALSE 16603
// begin CenterOnUnits ( Kapitsova ) ;
16582: LD_EXP 23
16586: PPUSH
16587: CALL_OW 85
// Say ( Kapitsova , DEnd-Burlak-Kap-1 ) ;
16591: LD_EXP 23
16595: PPUSH
16596: LD_STRING DEnd-Burlak-Kap-1
16598: PPUSH
16599: CALL_OW 88
// end ; if IsOK ( Gleb ) then
16603: LD_EXP 22
16607: PPUSH
16608: CALL_OW 302
16612: IFFALSE 16635
// begin CenterOnUnits ( Gleb ) ;
16614: LD_EXP 22
16618: PPUSH
16619: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
16623: LD_EXP 22
16627: PPUSH
16628: LD_STRING DEnd-JMM-Glb-1
16630: PPUSH
16631: CALL_OW 88
// end ; if IsOK ( Kuzmov ) then
16635: LD_EXP 24
16639: PPUSH
16640: CALL_OW 302
16644: IFFALSE 16667
// begin CenterOnUnits ( Kuzmov ) ;
16646: LD_EXP 24
16650: PPUSH
16651: CALL_OW 85
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16655: LD_EXP 24
16659: PPUSH
16660: LD_STRING DEnd-Burlak-Kuz-1
16662: PPUSH
16663: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
16667: LD_EXP 25
16671: PPUSH
16672: CALL_OW 302
16676: IFFALSE 16699
// begin CenterOnUnits ( Kovalyuk ) ;
16678: LD_EXP 25
16682: PPUSH
16683: CALL_OW 85
// Say ( Kovalyuk , DEnd-Burlak-Kov-1 ) ;
16687: LD_EXP 25
16691: PPUSH
16692: LD_STRING DEnd-Burlak-Kov-1
16694: PPUSH
16695: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
16699: LD_EXP 26
16703: PPUSH
16704: CALL_OW 302
16708: IFFALSE 16731
// begin CenterOnUnits ( Scholtze ) ;
16710: LD_EXP 26
16714: PPUSH
16715: CALL_OW 85
// Say ( Scholtze , DEnd-Burlak-Sch-1 ) ;
16719: LD_EXP 26
16723: PPUSH
16724: LD_STRING DEnd-Burlak-Sch-1
16726: PPUSH
16727: CALL_OW 88
// end ; if IsOK ( Karamazov ) then
16731: LD_EXP 27
16735: PPUSH
16736: CALL_OW 302
16740: IFFALSE 16763
// begin CenterOnUnits ( Karamazov ) ;
16742: LD_EXP 27
16746: PPUSH
16747: CALL_OW 85
// Say ( Karamazov , DEnd-Burlak-Kar-1 ) ;
16751: LD_EXP 27
16755: PPUSH
16756: LD_STRING DEnd-Burlak-Kar-1
16758: PPUSH
16759: CALL_OW 88
// end ; if IsOK ( Titov ) then
16763: LD_EXP 28
16767: PPUSH
16768: CALL_OW 302
16772: IFFALSE 16795
// begin CenterOnUnits ( Titov ) ;
16774: LD_EXP 28
16778: PPUSH
16779: CALL_OW 85
// Say ( Titov , DEnd-Burlak-Tit-1 ) ;
16783: LD_EXP 28
16787: PPUSH
16788: LD_STRING DEnd-Burlak-Tit-1
16790: PPUSH
16791: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
16795: LD_EXP 29
16799: PPUSH
16800: CALL_OW 302
16804: IFFALSE 16827
// begin CenterOnUnits ( Oblukov ) ;
16806: LD_EXP 29
16810: PPUSH
16811: CALL_OW 85
// Say ( Oblukov , DEnd-Burlak-Obl-1 ) ;
16815: LD_EXP 29
16819: PPUSH
16820: LD_STRING DEnd-Burlak-Obl-1
16822: PPUSH
16823: CALL_OW 88
// end ; if IsOK ( Kozlov ) then
16827: LD_EXP 30
16831: PPUSH
16832: CALL_OW 302
16836: IFFALSE 16859
// begin CenterOnUnits ( Kozlov ) ;
16838: LD_EXP 30
16842: PPUSH
16843: CALL_OW 85
// Say ( Kozlov , DEnd-Burlak-Koz-1 ) ;
16847: LD_EXP 30
16851: PPUSH
16852: LD_STRING DEnd-Burlak-Koz-1
16854: PPUSH
16855: CALL_OW 88
// end ; if IsOK ( Petrovova ) then
16859: LD_EXP 31
16863: PPUSH
16864: CALL_OW 302
16868: IFFALSE 16891
// begin CenterOnUnits ( Petrovova ) ;
16870: LD_EXP 31
16874: PPUSH
16875: CALL_OW 85
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16879: LD_EXP 31
16883: PPUSH
16884: LD_STRING DEnd-Burlak-Ptr-1
16886: PPUSH
16887: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
16891: LD_EXP 32
16895: PPUSH
16896: CALL_OW 302
16900: IFFALSE 16923
// begin CenterOnUnits ( Bystrov ) ;
16902: LD_EXP 32
16906: PPUSH
16907: CALL_OW 85
// Say ( Bystrov , DEnd-Burlak-Bys-1 ) ;
16911: LD_EXP 32
16915: PPUSH
16916: LD_STRING DEnd-Burlak-Bys-1
16918: PPUSH
16919: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
16923: LD_EXP 33
16927: PPUSH
16928: CALL_OW 302
16932: IFFALSE 16955
// begin CenterOnUnits ( Lipshchin ) ;
16934: LD_EXP 33
16938: PPUSH
16939: CALL_OW 85
// Say ( Lipshchin , DEnd-Burlak-Lip-1 ) ;
16943: LD_EXP 33
16947: PPUSH
16948: LD_STRING DEnd-Burlak-Lip-1
16950: PPUSH
16951: CALL_OW 88
// end ; if IsOK ( Fadeev ) then
16955: LD_EXP 34
16959: PPUSH
16960: CALL_OW 302
16964: IFFALSE 16987
// begin CenterOnUnits ( Fadeev ) ;
16966: LD_EXP 34
16970: PPUSH
16971: CALL_OW 85
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16975: LD_EXP 34
16979: PPUSH
16980: LD_STRING DEnd-Burlak-Fad-1
16982: PPUSH
16983: CALL_OW 88
// end ; if IsOK ( MacMillan ) then
16987: LD_EXP 13
16991: PPUSH
16992: CALL_OW 302
16996: IFFALSE 17019
// begin CenterOnUnits ( MacMillan ) ;
16998: LD_EXP 13
17002: PPUSH
17003: CALL_OW 85
// Say ( MacMillan , DEnd-Burlak-JMM-1 ) ;
17007: LD_EXP 13
17011: PPUSH
17012: LD_STRING DEnd-Burlak-JMM-1
17014: PPUSH
17015: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17019: LD_EXP 46
17023: PPUSH
17024: CALL_OW 302
17028: IFFALSE 17051
// begin CenterOnUnits ( Lisa ) ;
17030: LD_EXP 46
17034: PPUSH
17035: CALL_OW 85
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17039: LD_EXP 46
17043: PPUSH
17044: LD_STRING DEnd-Burlak-Lisa-1
17046: PPUSH
17047: CALL_OW 88
// end ; if IsOK ( Joan ) then
17051: LD_EXP 45
17055: PPUSH
17056: CALL_OW 302
17060: IFFALSE 17083
// begin CenterOnUnits ( Joan ) ;
17062: LD_EXP 45
17066: PPUSH
17067: CALL_OW 85
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
17071: LD_EXP 45
17075: PPUSH
17076: LD_STRING DEnd-Burlak-Joan-1
17078: PPUSH
17079: CALL_OW 88
// end ; if IsOK ( Frank ) then
17083: LD_EXP 42
17087: PPUSH
17088: CALL_OW 302
17092: IFFALSE 17115
// begin CenterOnUnits ( Frank ) ;
17094: LD_EXP 42
17098: PPUSH
17099: CALL_OW 85
// Say ( Frank , DEnd-Burlak-Frank-1 ) ;
17103: LD_EXP 42
17107: PPUSH
17108: LD_STRING DEnd-Burlak-Frank-1
17110: PPUSH
17111: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17115: LD_EXP 39
17119: PPUSH
17120: CALL_OW 302
17124: IFFALSE 17147
// begin CenterOnUnits ( Cyrus ) ;
17126: LD_EXP 39
17130: PPUSH
17131: CALL_OW 85
// Say ( Cyrus , DEnd-Burlak-Cyrus-1 ) ;
17135: LD_EXP 39
17139: PPUSH
17140: LD_STRING DEnd-Burlak-Cyrus-1
17142: PPUSH
17143: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17147: LD_EXP 41
17151: PPUSH
17152: CALL_OW 302
17156: IFFALSE 17179
// begin CenterOnUnits ( Donaldson ) ;
17158: LD_EXP 41
17162: PPUSH
17163: CALL_OW 85
// Say ( Donaldson , DEnd-Burlak-Don-1 ) ;
17167: LD_EXP 41
17171: PPUSH
17172: LD_STRING DEnd-Burlak-Don-1
17174: PPUSH
17175: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17179: LD_EXP 35
17183: PPUSH
17184: CALL_OW 302
17188: IFFALSE 17211
// begin CenterOnUnits ( Bobby ) ;
17190: LD_EXP 35
17194: PPUSH
17195: CALL_OW 85
// Say ( Bobby , DEnd-Burlak-Bobby-1 ) ;
17199: LD_EXP 35
17203: PPUSH
17204: LD_STRING DEnd-Burlak-Bobby-1
17206: PPUSH
17207: CALL_OW 88
// end ; if IsOK ( Denis ) then
17211: LD_EXP 40
17215: PPUSH
17216: CALL_OW 302
17220: IFFALSE 17243
// begin CenterOnUnits ( Denis ) ;
17222: LD_EXP 40
17226: PPUSH
17227: CALL_OW 85
// Say ( Denis , DEnd-Burlak-Den-1 ) ;
17231: LD_EXP 40
17235: PPUSH
17236: LD_STRING DEnd-Burlak-Den-1
17238: PPUSH
17239: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17243: LD_EXP 44
17247: PPUSH
17248: CALL_OW 302
17252: IFFALSE 17275
// begin CenterOnUnits ( Gladstone ) ;
17254: LD_EXP 44
17258: PPUSH
17259: CALL_OW 85
// Say ( Gladstone , DEnd-Burlak-Glad-1 ) ;
17263: LD_EXP 44
17267: PPUSH
17268: LD_STRING DEnd-Burlak-Glad-1
17270: PPUSH
17271: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17275: LD_EXP 50
17279: PPUSH
17280: CALL_OW 302
17284: IFFALSE 17307
// begin CenterOnUnits ( Yamoko ) ;
17286: LD_EXP 50
17290: PPUSH
17291: CALL_OW 85
// Say ( Yamoko , DEnd-Burlak-Yam-1 ) ;
17295: LD_EXP 50
17299: PPUSH
17300: LD_STRING DEnd-Burlak-Yam-1
17302: PPUSH
17303: CALL_OW 88
// end ; if IsOK ( Brown ) then
17307: LD_EXP 36
17311: PPUSH
17312: CALL_OW 302
17316: IFFALSE 17339
// begin CenterOnUnits ( Brown ) ;
17318: LD_EXP 36
17322: PPUSH
17323: CALL_OW 85
// Say ( Brown , DEnd-Burlak-Brown-1 ) ;
17327: LD_EXP 36
17331: PPUSH
17332: LD_STRING DEnd-Burlak-Brown-1
17334: PPUSH
17335: CALL_OW 88
// end ; if IsOK ( Roth ) then
17339: LD_EXP 14
17343: PPUSH
17344: CALL_OW 302
17348: IFFALSE 17371
// begin CenterOnUnits ( Roth ) ;
17350: LD_EXP 14
17354: PPUSH
17355: CALL_OW 85
// Say ( Roth , DEnd-Burlak-Roth-1 ) ;
17359: LD_EXP 14
17363: PPUSH
17364: LD_STRING DEnd-Burlak-Roth-1
17366: PPUSH
17367: CALL_OW 88
// end ; end ;
17371: LD_VAR 0 1
17375: RET
// function us_talking ; begin
17376: LD_INT 0
17378: PPUSH
// if IsOK ( MacMillan ) then
17379: LD_EXP 13
17383: PPUSH
17384: CALL_OW 302
17388: IFFALSE 17411
// begin CenterOnUnits ( MacMillan ) ;
17390: LD_EXP 13
17394: PPUSH
17395: CALL_OW 85
// Say ( MacMillan , DEnd-JMM-JMM-1 ) ;
17399: LD_EXP 13
17403: PPUSH
17404: LD_STRING DEnd-JMM-JMM-1
17406: PPUSH
17407: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17411: LD_EXP 46
17415: PPUSH
17416: CALL_OW 302
17420: IFFALSE 17443
// begin CenterOnUnits ( Lisa ) ;
17422: LD_EXP 46
17426: PPUSH
17427: CALL_OW 85
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17431: LD_EXP 46
17435: PPUSH
17436: LD_STRING DEnd-JMM-Lisa-1
17438: PPUSH
17439: CALL_OW 88
// end ; if IsOK ( Joan ) then
17443: LD_EXP 45
17447: PPUSH
17448: CALL_OW 302
17452: IFFALSE 17475
// begin CenterOnUnits ( Joan ) ;
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 85
// Say ( Joan , DEnd-JMM-Joan-1 ) ;
17463: LD_EXP 45
17467: PPUSH
17468: LD_STRING DEnd-JMM-Joan-1
17470: PPUSH
17471: CALL_OW 88
// end ; if IsOK ( Frank ) then
17475: LD_EXP 42
17479: PPUSH
17480: CALL_OW 302
17484: IFFALSE 17507
// begin CenterOnUnits ( Frank ) ;
17486: LD_EXP 42
17490: PPUSH
17491: CALL_OW 85
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17495: LD_EXP 42
17499: PPUSH
17500: LD_STRING DEnd-JMM-Frank-1
17502: PPUSH
17503: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17507: LD_EXP 39
17511: PPUSH
17512: CALL_OW 302
17516: IFFALSE 17539
// begin CenterOnUnits ( Cyrus ) ;
17518: LD_EXP 39
17522: PPUSH
17523: CALL_OW 85
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17527: LD_EXP 39
17531: PPUSH
17532: LD_STRING DEnd-JMM-Cyrus-1
17534: PPUSH
17535: CALL_OW 88
// end ; if IsOK ( Cornell ) then
17539: LD_EXP 37
17543: PPUSH
17544: CALL_OW 302
17548: IFFALSE 17571
// begin CenterOnUnits ( Cornell ) ;
17550: LD_EXP 37
17554: PPUSH
17555: CALL_OW 85
// Say ( Cornell , DEnd-JMM-Corn-1 ) ;
17559: LD_EXP 37
17563: PPUSH
17564: LD_STRING DEnd-JMM-Corn-1
17566: PPUSH
17567: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17571: LD_EXP 41
17575: PPUSH
17576: CALL_OW 302
17580: IFFALSE 17603
// begin CenterOnUnits ( Donaldson ) ;
17582: LD_EXP 41
17586: PPUSH
17587: CALL_OW 85
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17591: LD_EXP 41
17595: PPUSH
17596: LD_STRING DEnd-JMM-Don-1
17598: PPUSH
17599: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17603: LD_EXP 35
17607: PPUSH
17608: CALL_OW 302
17612: IFFALSE 17635
// begin CenterOnUnits ( Bobby ) ;
17614: LD_EXP 35
17618: PPUSH
17619: CALL_OW 85
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17623: LD_EXP 35
17627: PPUSH
17628: LD_STRING DEnd-JMM-Bobby-1
17630: PPUSH
17631: CALL_OW 88
// end ; if IsOK ( Denis ) then
17635: LD_EXP 40
17639: PPUSH
17640: CALL_OW 302
17644: IFFALSE 17667
// begin CenterOnUnits ( Denis ) ;
17646: LD_EXP 40
17650: PPUSH
17651: CALL_OW 85
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17655: LD_EXP 40
17659: PPUSH
17660: LD_STRING DEnd-JMM-Den-1
17662: PPUSH
17663: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17667: LD_EXP 44
17671: PPUSH
17672: CALL_OW 302
17676: IFFALSE 17699
// begin CenterOnUnits ( Gladstone ) ;
17678: LD_EXP 44
17682: PPUSH
17683: CALL_OW 85
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17687: LD_EXP 44
17691: PPUSH
17692: LD_STRING DEnd-JMM-Glad-1
17694: PPUSH
17695: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17699: LD_EXP 50
17703: PPUSH
17704: CALL_OW 302
17708: IFFALSE 17731
// begin CenterOnUnits ( Yamoko ) ;
17710: LD_EXP 50
17714: PPUSH
17715: CALL_OW 85
// Say ( Yamoko , DEnd-JMM-Yam-1 ) ;
17719: LD_EXP 50
17723: PPUSH
17724: LD_STRING DEnd-JMM-Yam-1
17726: PPUSH
17727: CALL_OW 88
// end ; if IsOK ( Brown ) then
17731: LD_EXP 36
17735: PPUSH
17736: CALL_OW 302
17740: IFFALSE 17763
// begin CenterOnUnits ( Brown ) ;
17742: LD_EXP 36
17746: PPUSH
17747: CALL_OW 85
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17751: LD_EXP 36
17755: PPUSH
17756: LD_STRING DEnd-JMM-Brown-1
17758: PPUSH
17759: CALL_OW 88
// end ; if IsOK ( Roth ) then
17763: LD_EXP 14
17767: PPUSH
17768: CALL_OW 302
17772: IFFALSE 17795
// begin CenterOnUnits ( Roth ) ;
17774: LD_EXP 14
17778: PPUSH
17779: CALL_OW 85
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
17783: LD_EXP 14
17787: PPUSH
17788: LD_STRING DEnd-JMM-Roth-1
17790: PPUSH
17791: CALL_OW 88
// end ; if IsOK ( Connie ) then
17795: LD_EXP 38
17799: PPUSH
17800: CALL_OW 302
17804: IFFALSE 17827
// begin CenterOnUnits ( Connie ) ;
17806: LD_EXP 38
17810: PPUSH
17811: CALL_OW 85
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17815: LD_EXP 38
17819: PPUSH
17820: LD_STRING DEnd-JMM-Con-1
17822: PPUSH
17823: CALL_OW 88
// end ; if IsOK ( Gary ) then
17827: LD_EXP 43
17831: PPUSH
17832: CALL_OW 302
17836: IFFALSE 17859
// begin CenterOnUnits ( Gary ) ;
17838: LD_EXP 43
17842: PPUSH
17843: CALL_OW 85
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17847: LD_EXP 43
17851: PPUSH
17852: LD_STRING DEnd-JMM-Gary-1
17854: PPUSH
17855: CALL_OW 88
// end ; if IsOK ( Simms ) then
17859: LD_EXP 48
17863: PPUSH
17864: CALL_OW 302
17868: IFFALSE 17891
// begin CenterOnUnits ( Simms ) ;
17870: LD_EXP 48
17874: PPUSH
17875: CALL_OW 85
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17879: LD_EXP 48
17883: PPUSH
17884: LD_STRING DEnd-JMM-Sim-1
17886: PPUSH
17887: CALL_OW 88
// end ; if IsOK ( VanHouten ) then
17891: LD_EXP 49
17895: PPUSH
17896: CALL_OW 302
17900: IFFALSE 17923
// begin CenterOnUnits ( VanHouten ) ;
17902: LD_EXP 49
17906: PPUSH
17907: CALL_OW 85
// Say ( VanHouten , DEnd-JMM-VanH-1 ) ;
17911: LD_EXP 49
17915: PPUSH
17916: LD_STRING DEnd-JMM-VanH-1
17918: PPUSH
17919: CALL_OW 88
// end ; if IsOK ( Burlak ) then
17923: LD_EXP 12
17927: PPUSH
17928: CALL_OW 302
17932: IFFALSE 17955
// begin CenterOnUnits ( Burlak ) ;
17934: LD_EXP 12
17938: PPUSH
17939: CALL_OW 85
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17943: LD_EXP 12
17947: PPUSH
17948: LD_STRING DEnd-JMM-Bur-1
17950: PPUSH
17951: CALL_OW 88
// end ; if IsOK ( Belkov ) then
17955: LD_EXP 17
17959: PPUSH
17960: CALL_OW 302
17964: IFFALSE 17987
// begin CenterOnUnits ( Belkov ) ;
17966: LD_EXP 17
17970: PPUSH
17971: CALL_OW 85
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17975: LD_EXP 17
17979: PPUSH
17980: LD_STRING DEnd-JMM-Bel-1
17982: PPUSH
17983: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
17987: LD_EXP 19
17991: PPUSH
17992: CALL_OW 302
17996: IFFALSE 18019
// begin CenterOnUnits ( Gnyevko ) ;
17998: LD_EXP 19
18002: PPUSH
18003: CALL_OW 85
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18007: LD_EXP 19
18011: PPUSH
18012: LD_STRING DEnd-JMM-Gny-1
18014: PPUSH
18015: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
18019: LD_EXP 21
18023: PPUSH
18024: CALL_OW 302
18028: IFFALSE 18051
// begin CenterOnUnits ( Dolgov ) ;
18030: LD_EXP 21
18034: PPUSH
18035: CALL_OW 85
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18039: LD_EXP 21
18043: PPUSH
18044: LD_STRING DEnd-JMM-Dol-1
18046: PPUSH
18047: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
18051: LD_EXP 23
18055: PPUSH
18056: CALL_OW 302
18060: IFFALSE 18083
// begin CenterOnUnits ( Kapitsova ) ;
18062: LD_EXP 23
18066: PPUSH
18067: CALL_OW 85
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18071: LD_EXP 23
18075: PPUSH
18076: LD_STRING DEnd-JMM-Kap-1
18078: PPUSH
18079: CALL_OW 88
// end ; if IsOK ( Gleb ) then
18083: LD_EXP 22
18087: PPUSH
18088: CALL_OW 302
18092: IFFALSE 18115
// begin CenterOnUnits ( Gleb ) ;
18094: LD_EXP 22
18098: PPUSH
18099: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
18103: LD_EXP 22
18107: PPUSH
18108: LD_STRING DEnd-JMM-Glb-1
18110: PPUSH
18111: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
18115: LD_EXP 25
18119: PPUSH
18120: CALL_OW 302
18124: IFFALSE 18147
// begin CenterOnUnits ( Kovalyuk ) ;
18126: LD_EXP 25
18130: PPUSH
18131: CALL_OW 85
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18135: LD_EXP 25
18139: PPUSH
18140: LD_STRING DEnd-JMM-Kov-1
18142: PPUSH
18143: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
18147: LD_EXP 26
18151: PPUSH
18152: CALL_OW 302
18156: IFFALSE 18179
// begin CenterOnUnits ( Scholtze ) ;
18158: LD_EXP 26
18162: PPUSH
18163: CALL_OW 85
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18167: LD_EXP 26
18171: PPUSH
18172: LD_STRING DEnd-JMM-Sch-1
18174: PPUSH
18175: CALL_OW 88
// end ; if IsOK ( Titov ) then
18179: LD_EXP 28
18183: PPUSH
18184: CALL_OW 302
18188: IFFALSE 18211
// begin CenterOnUnits ( Titov ) ;
18190: LD_EXP 28
18194: PPUSH
18195: CALL_OW 85
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18199: LD_EXP 28
18203: PPUSH
18204: LD_STRING DEnd-JMM-Tit-1
18206: PPUSH
18207: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
18211: LD_EXP 29
18215: PPUSH
18216: CALL_OW 302
18220: IFFALSE 18243
// begin CenterOnUnits ( Oblukov ) ;
18222: LD_EXP 29
18226: PPUSH
18227: CALL_OW 85
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18231: LD_EXP 29
18235: PPUSH
18236: LD_STRING DEnd-JMM-Obl-1
18238: PPUSH
18239: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
18243: LD_EXP 32
18247: PPUSH
18248: CALL_OW 302
18252: IFFALSE 18275
// begin CenterOnUnits ( Bystrov ) ;
18254: LD_EXP 32
18258: PPUSH
18259: CALL_OW 85
// Say ( Bystrov , DEnd-JMM-Bys-1 ) ;
18263: LD_EXP 32
18267: PPUSH
18268: LD_STRING DEnd-JMM-Bys-1
18270: PPUSH
18271: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
18275: LD_EXP 33
18279: PPUSH
18280: CALL_OW 302
18284: IFFALSE 18307
// begin CenterOnUnits ( Lipshchin ) ;
18286: LD_EXP 33
18290: PPUSH
18291: CALL_OW 85
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18295: LD_EXP 33
18299: PPUSH
18300: LD_STRING DEnd-JMM-Lip-1
18302: PPUSH
18303: CALL_OW 88
// end ; end ; end_of_file
18307: LD_VAR 0 1
18311: RET
// var id_reg , id_def ; var BaseArea , DefendArea , Heal ; var docs ; var healing_un , wounded_un ; var central_base , mc_id_defend ; export function init_defend ; var side ; begin
18312: LD_INT 0
18314: PPUSH
18315: PPUSH
// BaseArea := [ us_base , ar_base , ru_base ] ;
18316: LD_ADDR_LOC 14
18320: PUSH
18321: LD_INT 11
18323: PUSH
18324: LD_INT 13
18326: PUSH
18327: LD_INT 12
18329: PUSH
18330: EMPTY
18331: LIST
18332: LIST
18333: LIST
18334: ST_TO_ADDR
// DefendArea := [ us_defend_base , ar_defend_base , ru_base ] ;
18335: LD_ADDR_LOC 15
18339: PUSH
18340: LD_INT 36
18342: PUSH
18343: LD_INT 37
18345: PUSH
18346: LD_INT 12
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: LIST
18353: ST_TO_ADDR
// Heal := [ us_heal , ar_heal , ru_heal ] ;
18354: LD_ADDR_LOC 16
18358: PUSH
18359: LD_INT 16
18361: PUSH
18362: LD_INT 14
18364: PUSH
18365: LD_INT 15
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: LIST
18372: ST_TO_ADDR
// docs := [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
18373: LD_ADDR_LOC 17
18377: PUSH
18378: EMPTY
18379: PUSH
18380: EMPTY
18381: PUSH
18382: EMPTY
18383: PUSH
18384: EMPTY
18385: PUSH
18386: EMPTY
18387: PUSH
18388: EMPTY
18389: PUSH
18390: EMPTY
18391: PUSH
18392: EMPTY
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: LIST
18401: LIST
18402: LIST
18403: ST_TO_ADDR
// central_base := [ [ 44 , 62 ] , [ 251 , 193 ] , [ 177 , 72 ] ] ;
18404: LD_ADDR_LOC 20
18408: PUSH
18409: LD_INT 44
18411: PUSH
18412: LD_INT 62
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PUSH
18419: LD_INT 251
18421: PUSH
18422: LD_INT 193
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: PUSH
18429: LD_INT 177
18431: PUSH
18432: LD_INT 72
18434: PUSH
18435: EMPTY
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: ST_TO_ADDR
// healing_un := [ ] ;
18444: LD_ADDR_LOC 18
18448: PUSH
18449: EMPTY
18450: ST_TO_ADDR
// wounded_un := [ ] ;
18451: LD_ADDR_LOC 19
18455: PUSH
18456: EMPTY
18457: ST_TO_ADDR
// mc_id_defend := false ;
18458: LD_ADDR_LOC 21
18462: PUSH
18463: LD_INT 0
18465: ST_TO_ADDR
// start_defend ;
18466: CALL 18726 0 0
// end ;
18470: LD_VAR 0 1
18474: RET
// function prepare_defend ( side ) ; var seznam , def_buildings , def_vehicles , def_peoples ; begin
18475: LD_INT 0
18477: PPUSH
18478: PPUSH
18479: PPUSH
18480: PPUSH
18481: PPUSH
// def_buildings := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
18482: LD_ADDR_VAR 0 4
18486: PUSH
18487: LD_INT 22
18489: PUSH
18490: LD_VAR 0 1
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 2
18501: PUSH
18502: LD_INT 30
18504: PUSH
18505: LD_INT 32
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PUSH
18512: LD_INT 30
18514: PUSH
18515: LD_INT 31
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: LIST
18526: PUSH
18527: EMPTY
18528: LIST
18529: LIST
18530: PPUSH
18531: CALL_OW 69
18535: ST_TO_ADDR
// def_peoples := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_class , class_scientistic ] ] ) ;
18536: LD_ADDR_VAR 0 6
18540: PUSH
18541: LD_INT 22
18543: PUSH
18544: LD_VAR 0 1
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: LD_INT 21
18555: PUSH
18556: LD_INT 1
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 3
18565: PUSH
18566: LD_INT 25
18568: PUSH
18569: LD_INT 4
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: PPUSH
18582: CALL_OW 69
18586: ST_TO_ADDR
// def_vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , f_not , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) ;
18587: LD_ADDR_VAR 0 5
18591: PUSH
18592: LD_INT 22
18594: PUSH
18595: LD_VAR 0 1
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 21
18606: PUSH
18607: LD_INT 2
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: LD_INT 3
18616: PUSH
18617: LD_INT 2
18619: PUSH
18620: LD_INT 34
18622: PUSH
18623: LD_INT 12
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: PUSH
18630: LD_INT 34
18632: PUSH
18633: LD_INT 13
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 34
18642: PUSH
18643: LD_INT 32
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: LD_INT 34
18652: PUSH
18653: LD_INT 51
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PUSH
18660: LD_INT 34
18662: PUSH
18663: LD_INT 52
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: LIST
18683: PPUSH
18684: CALL_OW 69
18688: ST_TO_ADDR
// seznam := def_buildings ^ def_peoples ^ def_vehicles ;
18689: LD_ADDR_VAR 0 3
18693: PUSH
18694: LD_VAR 0 4
18698: PUSH
18699: LD_VAR 0 6
18703: ADD
18704: PUSH
18705: LD_VAR 0 5
18709: ADD
18710: ST_TO_ADDR
// result := seznam ;
18711: LD_ADDR_VAR 0 2
18715: PUSH
18716: LD_VAR 0 3
18720: ST_TO_ADDR
// end ;
18721: LD_VAR 0 2
18725: RET
// function start_defend ; var side ; begin
18726: LD_INT 0
18728: PPUSH
18729: PPUSH
// id_reg := [ ] ;
18730: LD_ADDR_LOC 12
18734: PUSH
18735: EMPTY
18736: ST_TO_ADDR
// id_def := [ ] ;
18737: LD_ADDR_LOC 13
18741: PUSH
18742: EMPTY
18743: ST_TO_ADDR
// for side = 1 to 8 do
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: DOUBLE
18750: LD_INT 1
18752: DEC
18753: ST_TO_ADDR
18754: LD_INT 8
18756: PUSH
18757: FOR_TO
18758: IFFALSE 19014
// if side in cpu_list then
18760: LD_VAR 0 2
18764: PUSH
18765: LD_EXP 8
18769: IN
18770: IFFALSE 18978
// begin id_reg := id_reg ^ McRegistry ( 1 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , BaseArea [ side ] ] , [ mc_reg_area_to_protect , BaseArea [ side ] ] , [ mc_reg_units_to_protect , prepare_defend ( side ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
18772: LD_ADDR_LOC 12
18776: PUSH
18777: LD_LOC 12
18781: PUSH
18782: LD_INT 1
18784: PPUSH
18785: LD_INT 1
18787: PUSH
18788: LD_INT 35
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PUSH
18795: LD_INT 5
18797: PUSH
18798: LD_INT 140
18800: PUSH
18801: EMPTY
18802: LIST
18803: LIST
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: LD_LOC 14
18812: PUSH
18813: LD_VAR 0 2
18817: ARRAY
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: PUSH
18823: LD_INT 3
18825: PUSH
18826: LD_LOC 14
18830: PUSH
18831: LD_VAR 0 2
18835: ARRAY
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: PUSH
18841: LD_INT 4
18843: PUSH
18844: LD_VAR 0 2
18848: PPUSH
18849: CALL 18475 0 1
18853: PUSH
18854: EMPTY
18855: LIST
18856: LIST
18857: PUSH
18858: LD_INT 8
18860: PUSH
18861: LD_INT 7
18863: NEG
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 399
18878: ADD
18879: ST_TO_ADDR
// id_def := id_def ^ McDefend ( 200 , id_reg , prepare_defend ( side ) , [ [ mc_def_advantage , 5000 ] , [ mc_area_dont_leave , BaseArea [ side ] ] , [ mc_retreat_area_people , Heal [ side ] ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
18880: LD_ADDR_LOC 13
18884: PUSH
18885: LD_LOC 13
18889: PUSH
18890: LD_INT 200
18892: PPUSH
18893: LD_LOC 12
18897: PPUSH
18898: LD_VAR 0 2
18902: PPUSH
18903: CALL 18475 0 1
18907: PPUSH
18908: LD_INT 1
18910: PUSH
18911: LD_INT 5000
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_LOC 14
18925: PUSH
18926: LD_VAR 0 2
18930: ARRAY
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PUSH
18936: LD_INT 7
18938: PUSH
18939: LD_LOC 16
18943: PUSH
18944: LD_VAR 0 2
18948: ARRAY
18949: PUSH
18950: EMPTY
18951: LIST
18952: LIST
18953: PUSH
18954: LD_INT 5
18956: PUSH
18957: LD_INT 600
18959: PUSH
18960: EMPTY
18961: LIST
18962: LIST
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: PPUSH
18970: CALL_OW 401
18974: ADD
18975: ST_TO_ADDR
// end else
18976: GO 19012
// begin id_reg := id_reg ^ [ 0 ] ;
18978: LD_ADDR_LOC 12
18982: PUSH
18983: LD_LOC 12
18987: PUSH
18988: LD_INT 0
18990: PUSH
18991: EMPTY
18992: LIST
18993: ADD
18994: ST_TO_ADDR
// id_def := id_reg ^ [ 0 ] ;
18995: LD_ADDR_LOC 13
18999: PUSH
19000: LD_LOC 12
19004: PUSH
19005: LD_INT 0
19007: PUSH
19008: EMPTY
19009: LIST
19010: ADD
19011: ST_TO_ADDR
// end ;
19012: GO 18757
19014: POP
19015: POP
// end ;
19016: LD_VAR 0 1
19020: RET
// on McRegistryResultChanges ( mcid , n , s ) do var side ;
19021: LD_INT 0
19023: PPUSH
// begin for side = 1 to id_reg do
19024: LD_ADDR_VAR 0 4
19028: PUSH
19029: DOUBLE
19030: LD_INT 1
19032: DEC
19033: ST_TO_ADDR
19034: LD_LOC 12
19038: PUSH
19039: FOR_TO
19040: IFFALSE 19092
// if id_reg [ side ] = mcid then
19042: LD_LOC 12
19046: PUSH
19047: LD_VAR 0 4
19051: ARRAY
19052: PUSH
19053: LD_VAR 0 1
19057: EQUAL
19058: IFFALSE 19090
// begin AddMcUnits ( mcid , prepare_defend ( side ) ) ;
19060: LD_VAR 0 1
19064: PPUSH
19065: LD_VAR 0 4
19069: PPUSH
19070: CALL 18475 0 1
19074: PPUSH
19075: CALL_OW 390
// SendForces ( side ) ;
19079: LD_VAR 0 4
19083: PPUSH
19084: CALL 20237 0 1
// break ;
19088: GO 19092
// end ;
19090: GO 19039
19092: POP
19093: POP
// end ;
19094: PPOPN 4
19096: END
// every 0 0$7.7 do var side , list ;
19097: GO 19099
19099: DISABLE
19100: LD_INT 0
19102: PPUSH
19103: PPUSH
// begin list := [ ] ;
19104: LD_ADDR_VAR 0 2
19108: PUSH
19109: EMPTY
19110: ST_TO_ADDR
// for side = 1 to 8 do
19111: LD_ADDR_VAR 0 1
19115: PUSH
19116: DOUBLE
19117: LD_INT 1
19119: DEC
19120: ST_TO_ADDR
19121: LD_INT 8
19123: PUSH
19124: FOR_TO
19125: IFFALSE 19270
// if ( not side in cpu_list ) and id_reg [ side ] then
19127: LD_VAR 0 1
19131: PUSH
19132: LD_EXP 8
19136: IN
19137: NOT
19138: PUSH
19139: LD_LOC 12
19143: PUSH
19144: LD_VAR 0 1
19148: ARRAY
19149: AND
19150: IFFALSE 19268
// begin KillMc ( id_reg [ side ] ) ;
19152: LD_LOC 12
19156: PUSH
19157: LD_VAR 0 1
19161: ARRAY
19162: PPUSH
19163: CALL_OW 387
// id_reg := Delete ( id_reg , side ) ;
19167: LD_ADDR_LOC 12
19171: PUSH
19172: LD_LOC 12
19176: PPUSH
19177: LD_VAR 0 1
19181: PPUSH
19182: CALL_OW 3
19186: ST_TO_ADDR
// id_reg := Insert ( id_reg , side , 0 ) ;
19187: LD_ADDR_LOC 12
19191: PUSH
19192: LD_LOC 12
19196: PPUSH
19197: LD_VAR 0 1
19201: PPUSH
19202: LD_INT 0
19204: PPUSH
19205: CALL_OW 2
19209: ST_TO_ADDR
// KillMc ( id_def [ side ] ) ;
19210: LD_LOC 13
19214: PUSH
19215: LD_VAR 0 1
19219: ARRAY
19220: PPUSH
19221: CALL_OW 387
// id_def := Delete ( id_def , side ) ;
19225: LD_ADDR_LOC 13
19229: PUSH
19230: LD_LOC 13
19234: PPUSH
19235: LD_VAR 0 1
19239: PPUSH
19240: CALL_OW 3
19244: ST_TO_ADDR
// id_def := Insert ( id_def , side , 0 ) ;
19245: LD_ADDR_LOC 13
19249: PUSH
19250: LD_LOC 13
19254: PPUSH
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_INT 0
19262: PPUSH
19263: CALL_OW 2
19267: ST_TO_ADDR
// end ;
19268: GO 19124
19270: POP
19271: POP
// enable ;
19272: ENABLE
// end ;
19273: PPOPN 2
19275: END
// every 0 0$5.3 do var side , sci , list , wounded , un ;
19276: GO 19278
19278: DISABLE
19279: LD_INT 0
19281: PPUSH
19282: PPUSH
19283: PPUSH
19284: PPUSH
19285: PPUSH
// begin for side = 1 to 8 do
19286: LD_ADDR_VAR 0 1
19290: PUSH
19291: DOUBLE
19292: LD_INT 1
19294: DEC
19295: ST_TO_ADDR
19296: LD_INT 8
19298: PUSH
19299: FOR_TO
19300: IFFALSE 19734
// if side in cpu_list then
19302: LD_VAR 0 1
19306: PUSH
19307: LD_EXP 8
19311: IN
19312: IFFALSE 19732
// begin wounded := FilterUnitsInArea ( Heal [ side ] , [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 1000 ] ] ) ;
19314: LD_ADDR_VAR 0 4
19318: PUSH
19319: LD_LOC 16
19323: PUSH
19324: LD_VAR 0 1
19328: ARRAY
19329: PPUSH
19330: LD_INT 22
19332: PUSH
19333: LD_VAR 0 1
19337: PUSH
19338: EMPTY
19339: LIST
19340: LIST
19341: PUSH
19342: LD_INT 21
19344: PUSH
19345: LD_INT 1
19347: PUSH
19348: EMPTY
19349: LIST
19350: LIST
19351: PUSH
19352: LD_INT 3
19354: PUSH
19355: LD_INT 24
19357: PUSH
19358: LD_INT 1000
19360: PUSH
19361: EMPTY
19362: LIST
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: PPUSH
19371: CALL_OW 70
19375: ST_TO_ADDR
// if wounded then
19376: LD_VAR 0 4
19380: IFFALSE 19590
// begin if not docs [ side ] then
19382: LD_LOC 17
19386: PUSH
19387: LD_VAR 0 1
19391: ARRAY
19392: NOT
19393: IFFALSE 19557
// begin sci := request_people ( side , class_scientistic , 5 ) ;
19395: LD_ADDR_VAR 0 2
19399: PUSH
19400: LD_VAR 0 1
19404: PPUSH
19405: LD_INT 4
19407: PPUSH
19408: LD_INT 5
19410: PPUSH
19411: CALL 26559 0 3
19415: ST_TO_ADDR
// docs := Delete ( docs , side ) ;
19416: LD_ADDR_LOC 17
19420: PUSH
19421: LD_LOC 17
19425: PPUSH
19426: LD_VAR 0 1
19430: PPUSH
19431: CALL_OW 3
19435: ST_TO_ADDR
// docs := Insert ( docs , side , sci ) ;
19436: LD_ADDR_LOC 17
19440: PUSH
19441: LD_LOC 17
19445: PPUSH
19446: LD_VAR 0 1
19450: PPUSH
19451: LD_VAR 0 2
19455: PPUSH
19456: CALL_OW 2
19460: ST_TO_ADDR
// list := reserved_people [ side ] ^ sci ;
19461: LD_ADDR_VAR 0 3
19465: PUSH
19466: LD_EXP 72
19470: PUSH
19471: LD_VAR 0 1
19475: ARRAY
19476: PUSH
19477: LD_VAR 0 2
19481: ADD
19482: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19483: LD_ADDR_EXP 72
19487: PUSH
19488: LD_EXP 72
19492: PPUSH
19493: LD_VAR 0 1
19497: PPUSH
19498: CALL_OW 3
19502: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19503: LD_ADDR_EXP 72
19507: PUSH
19508: LD_EXP 72
19512: PPUSH
19513: LD_VAR 0 1
19517: PPUSH
19518: LD_VAR 0 3
19522: PPUSH
19523: CALL_OW 2
19527: ST_TO_ADDR
// ComRemember ( sci ) ;
19528: LD_VAR 0 2
19532: PPUSH
19533: CALL_OW 143
// ComMoveToArea ( sci , Heal [ side ] ) ;
19537: LD_VAR 0 2
19541: PPUSH
19542: LD_LOC 16
19546: PUSH
19547: LD_VAR 0 1
19551: ARRAY
19552: PPUSH
19553: CALL_OW 113
// end ; for un in wounded do
19557: LD_ADDR_VAR 0 5
19561: PUSH
19562: LD_VAR 0 4
19566: PUSH
19567: FOR_IN
19568: IFFALSE 19586
// AddComHeal ( sci , un ) ;
19570: LD_VAR 0 2
19574: PPUSH
19575: LD_VAR 0 5
19579: PPUSH
19580: CALL_OW 188
19584: GO 19567
19586: POP
19587: POP
// end else
19588: GO 19732
// if docs [ side ] then
19590: LD_LOC 17
19594: PUSH
19595: LD_VAR 0 1
19599: ARRAY
19600: IFFALSE 19732
// begin list := reserved_people [ side ] diff docs [ side ] ;
19602: LD_ADDR_VAR 0 3
19606: PUSH
19607: LD_EXP 72
19611: PUSH
19612: LD_VAR 0 1
19616: ARRAY
19617: PUSH
19618: LD_LOC 17
19622: PUSH
19623: LD_VAR 0 1
19627: ARRAY
19628: DIFF
19629: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19630: LD_ADDR_EXP 72
19634: PUSH
19635: LD_EXP 72
19639: PPUSH
19640: LD_VAR 0 1
19644: PPUSH
19645: CALL_OW 3
19649: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19650: LD_ADDR_EXP 72
19654: PUSH
19655: LD_EXP 72
19659: PPUSH
19660: LD_VAR 0 1
19664: PPUSH
19665: LD_VAR 0 3
19669: PPUSH
19670: CALL_OW 2
19674: ST_TO_ADDR
// ComReturn ( docs [ side ] ) ;
19675: LD_LOC 17
19679: PUSH
19680: LD_VAR 0 1
19684: ARRAY
19685: PPUSH
19686: CALL_OW 144
// docs := Delete ( docs , side ) ;
19690: LD_ADDR_LOC 17
19694: PUSH
19695: LD_LOC 17
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 3
19709: ST_TO_ADDR
// docs := Insert ( docs , side , [ ] ) ;
19710: LD_ADDR_LOC 17
19714: PUSH
19715: LD_LOC 17
19719: PPUSH
19720: LD_VAR 0 1
19724: PPUSH
19725: EMPTY
19726: PPUSH
19727: CALL_OW 2
19731: ST_TO_ADDR
// end ; end ;
19732: GO 19299
19734: POP
19735: POP
// enable ;
19736: ENABLE
// end ;
19737: PPOPN 5
19739: END
// every 0 0$3.1 do var list , self ;
19740: GO 19742
19742: DISABLE
19743: LD_INT 0
19745: PPUSH
19746: PPUSH
// begin list := FilterUnitsInArea ( ar_base , [ [ f_side , you ] , [ f_ok ] ] ) ;
19747: LD_ADDR_VAR 0 1
19751: PUSH
19752: LD_INT 13
19754: PPUSH
19755: LD_INT 22
19757: PUSH
19758: LD_EXP 1
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PUSH
19767: LD_INT 50
19769: PUSH
19770: EMPTY
19771: LIST
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: PPUSH
19777: CALL_OW 70
19781: ST_TO_ADDR
// if list then
19782: LD_VAR 0 1
19786: IFFALSE 19883
// begin self := FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_vehicle ] , [ f_weapon , ar_selfpropelled_bomb ] ] ) ;
19788: LD_ADDR_VAR 0 2
19792: PUSH
19793: LD_INT 22
19795: PUSH
19796: LD_EXP 4
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: PUSH
19805: LD_INT 21
19807: PUSH
19808: LD_INT 2
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: PUSH
19815: LD_INT 34
19817: PUSH
19818: LD_INT 29
19820: PUSH
19821: EMPTY
19822: LIST
19823: LIST
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: LIST
19829: PPUSH
19830: CALL_OW 69
19834: ST_TO_ADDR
// if self then
19835: LD_VAR 0 2
19839: IFFALSE 19857
// self := self [ 1 ] else
19841: LD_ADDR_VAR 0 2
19845: PUSH
19846: LD_VAR 0 2
19850: PUSH
19851: LD_INT 1
19853: ARRAY
19854: ST_TO_ADDR
19855: GO 19859
// exit ;
19857: GO 19884
// ComAttackUnit ( self , NearestUnitToUnit ( list , self ) ) ;
19859: LD_VAR 0 2
19863: PPUSH
19864: LD_VAR 0 1
19868: PPUSH
19869: LD_VAR 0 2
19873: PPUSH
19874: CALL_OW 74
19878: PPUSH
19879: CALL_OW 115
// ; end ; enable ;
19883: ENABLE
// end ;
19884: PPOPN 2
19886: END
// every 0 0$3 do var side , list ;
19887: GO 19889
19889: DISABLE
19890: LD_INT 0
19892: PPUSH
19893: PPUSH
// begin for side in cpu_list do
19894: LD_ADDR_VAR 0 1
19898: PUSH
19899: LD_EXP 8
19903: PUSH
19904: FOR_IN
19905: IFFALSE 19994
// if side then
19907: LD_VAR 0 1
19911: IFFALSE 19992
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 800 ] ] ) diff healing_un ;
19913: LD_ADDR_VAR 0 2
19917: PUSH
19918: LD_INT 22
19920: PUSH
19921: LD_VAR 0 1
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PUSH
19930: LD_INT 21
19932: PUSH
19933: LD_INT 1
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PUSH
19940: LD_INT 3
19942: PUSH
19943: LD_INT 24
19945: PUSH
19946: LD_INT 800
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: PPUSH
19959: CALL_OW 69
19963: PUSH
19964: LD_LOC 18
19968: DIFF
19969: ST_TO_ADDR
// if list then
19970: LD_VAR 0 2
19974: IFFALSE 19992
// wounded_un := wounded_un ^ list ;
19976: LD_ADDR_LOC 19
19980: PUSH
19981: LD_LOC 19
19985: PUSH
19986: LD_VAR 0 2
19990: ADD
19991: ST_TO_ADDR
// end ;
19992: GO 19904
19994: POP
19995: POP
// enable ;
19996: ENABLE
// end ;
19997: PPOPN 2
19999: END
// every 0 0$2 do var list , un ;
20000: GO 20002
20002: DISABLE
20003: LD_INT 0
20005: PPUSH
20006: PPUSH
// begin for un in wounded_un do
20007: LD_ADDR_VAR 0 2
20011: PUSH
20012: LD_LOC 19
20016: PUSH
20017: FOR_IN
20018: IFFALSE 20104
// if not ( un in healing_un ) then
20020: LD_VAR 0 2
20024: PUSH
20025: LD_LOC 18
20029: IN
20030: NOT
20031: IFFALSE 20102
// begin healing_un := healing_un ^ un ;
20033: LD_ADDR_LOC 18
20037: PUSH
20038: LD_LOC 18
20042: PUSH
20043: LD_VAR 0 2
20047: ADD
20048: ST_TO_ADDR
// McCustom ( 100 , un ) ;
20049: LD_INT 100
20051: PPUSH
20052: LD_VAR 0 2
20056: PPUSH
20057: CALL_OW 416
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20061: LD_VAR 0 2
20065: PPUSH
20066: LD_LOC 16
20070: PUSH
20071: LD_VAR 0 2
20075: PPUSH
20076: CALL_OW 255
20080: ARRAY
20081: PPUSH
20082: CALL_OW 113
// wounded_un := wounded_un diff un ;
20086: LD_ADDR_LOC 19
20090: PUSH
20091: LD_LOC 19
20095: PUSH
20096: LD_VAR 0 2
20100: DIFF
20101: ST_TO_ADDR
// end ;
20102: GO 20017
20104: POP
20105: POP
// enable ;
20106: ENABLE
// end ;
20107: PPOPN 2
20109: END
// every 0 0$2 + 0 0$1 do var un ;
20110: GO 20112
20112: DISABLE
20113: LD_INT 0
20115: PPUSH
// begin for un in healing_un do
20116: LD_ADDR_VAR 0 1
20120: PUSH
20121: LD_LOC 18
20125: PUSH
20126: FOR_IN
20127: IFFALSE 20231
// if GetLives ( un ) = 1000 then
20129: LD_VAR 0 1
20133: PPUSH
20134: CALL_OW 256
20138: PUSH
20139: LD_INT 1000
20141: EQUAL
20142: IFFALSE 20176
// begin KillMc ( GetUnitMc ( un ) ) ;
20144: LD_VAR 0 1
20148: PPUSH
20149: CALL_OW 388
20153: PPUSH
20154: CALL_OW 387
// healing_un := healing_un diff un ;
20158: LD_ADDR_LOC 18
20162: PUSH
20163: LD_LOC 18
20167: PUSH
20168: LD_VAR 0 1
20172: DIFF
20173: ST_TO_ADDR
// end else
20174: GO 20229
// if not IsInArea ( un , Heal [ GetSide ( un ) ] ) then
20176: LD_VAR 0 1
20180: PPUSH
20181: LD_LOC 16
20185: PUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: CALL_OW 255
20195: ARRAY
20196: PPUSH
20197: CALL_OW 308
20201: NOT
20202: IFFALSE 20229
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20204: LD_VAR 0 1
20208: PPUSH
20209: LD_LOC 16
20213: PUSH
20214: LD_VAR 0 1
20218: PPUSH
20219: CALL_OW 255
20223: ARRAY
20224: PPUSH
20225: CALL_OW 113
20229: GO 20126
20231: POP
20232: POP
// enable ;
20233: ENABLE
// end ;
20234: PPOPN 1
20236: END
// function SendForces ( side ) ; var un , list , target , defenders ; begin
20237: LD_INT 0
20239: PPUSH
20240: PPUSH
20241: PPUSH
20242: PPUSH
20243: PPUSH
// ComRemember ( defend_forces [ side ] ) ;
20244: LD_EXP 69
20248: PUSH
20249: LD_VAR 0 1
20253: ARRAY
20254: PPUSH
20255: CALL_OW 143
// if ExistMc ( mc_id_defend ) then
20259: LD_LOC 21
20263: PPUSH
20264: CALL_OW 386
20268: IFFALSE 20279
// KillMc ( mc_id_defend ) ;
20270: LD_LOC 21
20274: PPUSH
20275: CALL_OW 387
// mc_id_defend := McCustom ( 500 , defend_forces [ side ] ) ;
20279: LD_ADDR_LOC 21
20283: PUSH
20284: LD_INT 500
20286: PPUSH
20287: LD_EXP 69
20291: PUSH
20292: LD_VAR 0 1
20296: ARRAY
20297: PPUSH
20298: CALL_OW 416
20302: ST_TO_ADDR
// wait ( 1 ) ;
20303: LD_INT 1
20305: PPUSH
20306: CALL_OW 67
// repeat list := FilterUnitsInArea ( DefendArea [ side ] , [ [ f_side , you ] , [ f_ok ] ] ) ;
20310: LD_ADDR_VAR 0 4
20314: PUSH
20315: LD_LOC 15
20319: PUSH
20320: LD_VAR 0 1
20324: ARRAY
20325: PPUSH
20326: LD_INT 22
20328: PUSH
20329: LD_EXP 1
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: PUSH
20338: LD_INT 50
20340: PUSH
20341: EMPTY
20342: LIST
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: PPUSH
20348: CALL_OW 70
20352: ST_TO_ADDR
// target := NearestUnitToXY ( list , central_base [ side ] [ 1 ] , central_base [ side ] [ 2 ] ) ;
20353: LD_ADDR_VAR 0 5
20357: PUSH
20358: LD_VAR 0 4
20362: PPUSH
20363: LD_LOC 20
20367: PUSH
20368: LD_VAR 0 1
20372: ARRAY
20373: PUSH
20374: LD_INT 1
20376: ARRAY
20377: PPUSH
20378: LD_LOC 20
20382: PUSH
20383: LD_VAR 0 1
20387: ARRAY
20388: PUSH
20389: LD_INT 2
20391: ARRAY
20392: PPUSH
20393: CALL_OW 73
20397: ST_TO_ADDR
// defenders := prepare_defend ( side ) ;
20398: LD_ADDR_VAR 0 6
20402: PUSH
20403: LD_VAR 0 1
20407: PPUSH
20408: CALL 18475 0 1
20412: ST_TO_ADDR
// if list = 0 or defenders = 0 then
20413: LD_VAR 0 4
20417: PUSH
20418: LD_INT 0
20420: EQUAL
20421: PUSH
20422: LD_VAR 0 6
20426: PUSH
20427: LD_INT 0
20429: EQUAL
20430: OR
20431: IFFALSE 20435
// break ;
20433: GO 20550
// for un in defenders do
20435: LD_ADDR_VAR 0 3
20439: PUSH
20440: LD_VAR 0 6
20444: PUSH
20445: FOR_IN
20446: IFFALSE 20537
// if GetWeapon ( un ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ru_rocket ] then
20448: LD_VAR 0 3
20452: PPUSH
20453: CALL_OW 264
20457: PUSH
20458: LD_INT 7
20460: PUSH
20461: LD_INT 28
20463: PUSH
20464: LD_INT 45
20466: PUSH
20467: LD_INT 47
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: LIST
20474: LIST
20475: IN
20476: IFFALSE 20515
// ComAttackPlace ( defend_forces [ side ] , GetX ( target ) , GetY ( target ) ) else
20478: LD_EXP 69
20482: PUSH
20483: LD_VAR 0 1
20487: ARRAY
20488: PPUSH
20489: LD_VAR 0 5
20493: PPUSH
20494: CALL_OW 250
20498: PPUSH
20499: LD_VAR 0 5
20503: PPUSH
20504: CALL_OW 251
20508: PPUSH
20509: CALL_OW 116
20513: GO 20535
// ComAttackUnit ( defend_forces [ side ] , target ) ;
20515: LD_EXP 69
20519: PUSH
20520: LD_VAR 0 1
20524: ARRAY
20525: PPUSH
20526: LD_VAR 0 5
20530: PPUSH
20531: CALL_OW 115
20535: GO 20445
20537: POP
20538: POP
// wait ( 50 ) ;
20539: LD_INT 50
20541: PPUSH
20542: CALL_OW 67
// until false ;
20546: LD_INT 0
20548: IFFALSE 20310
// KillMc ( mc_id_defend ) ;
20550: LD_LOC 21
20554: PPUSH
20555: CALL_OW 387
// mc_id_defend := false ;
20559: LD_ADDR_LOC 21
20563: PUSH
20564: LD_INT 0
20566: ST_TO_ADDR
// wait ( 2 ) ;
20567: LD_INT 2
20569: PPUSH
20570: CALL_OW 67
// ComReturn ( defend_forces [ side ] ) ;
20574: LD_EXP 69
20578: PUSH
20579: LD_VAR 0 1
20583: ARRAY
20584: PPUSH
20585: CALL_OW 144
// end ;
20589: LD_VAR 0 2
20593: RET
// every 0 0$5.1 do var side ;
20594: GO 20596
20596: DISABLE
20597: LD_INT 0
20599: PPUSH
// begin for side = 1 to 3 do
20600: LD_ADDR_VAR 0 1
20604: PUSH
20605: DOUBLE
20606: LD_INT 1
20608: DEC
20609: ST_TO_ADDR
20610: LD_INT 3
20612: PUSH
20613: FOR_TO
20614: IFFALSE 20816
// if ( not defend_forces [ side ] ) and ready_forces [ side ] then
20616: LD_EXP 69
20620: PUSH
20621: LD_VAR 0 1
20625: ARRAY
20626: NOT
20627: PUSH
20628: LD_EXP 66
20632: PUSH
20633: LD_VAR 0 1
20637: ARRAY
20638: AND
20639: IFFALSE 20814
// begin defend_forces := Replace ( defend_forces , side , ready_forces [ side ] ) ;
20641: LD_ADDR_EXP 69
20645: PUSH
20646: LD_EXP 69
20650: PPUSH
20651: LD_VAR 0 1
20655: PPUSH
20656: LD_EXP 66
20660: PUSH
20661: LD_VAR 0 1
20665: ARRAY
20666: PPUSH
20667: CALL_OW 1
20671: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
20672: LD_ADDR_EXP 66
20676: PUSH
20677: LD_EXP 66
20681: PPUSH
20682: LD_VAR 0 1
20686: PPUSH
20687: EMPTY
20688: PPUSH
20689: CALL_OW 1
20693: ST_TO_ADDR
// jammed_forces := Replace ( jammed_forces , side , jammed_forces [ side ] diff defend_forces [ side ] ) ;
20694: LD_ADDR_EXP 70
20698: PUSH
20699: LD_EXP 70
20703: PPUSH
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_EXP 70
20713: PUSH
20714: LD_VAR 0 1
20718: ARRAY
20719: PUSH
20720: LD_EXP 69
20724: PUSH
20725: LD_VAR 0 1
20729: ARRAY
20730: DIFF
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// case side of 1 :
20737: LD_VAR 0 1
20741: PUSH
20742: LD_INT 1
20744: DOUBLE
20745: EQUAL
20746: IFTRUE 20750
20748: GO 20774
20750: POP
// ComMoveXY ( defend_forces [ side ] , 40 , 46 ) ; 3 :
20751: LD_EXP 69
20755: PUSH
20756: LD_VAR 0 1
20760: ARRAY
20761: PPUSH
20762: LD_INT 40
20764: PPUSH
20765: LD_INT 46
20767: PPUSH
20768: CALL_OW 111
20772: GO 20807
20774: LD_INT 3
20776: DOUBLE
20777: EQUAL
20778: IFTRUE 20782
20780: GO 20806
20782: POP
// ComMoveXY ( defend_forces [ side ] , 175 , 50 ) ; end ;
20783: LD_EXP 69
20787: PUSH
20788: LD_VAR 0 1
20792: ARRAY
20793: PPUSH
20794: LD_INT 175
20796: PPUSH
20797: LD_INT 50
20799: PPUSH
20800: CALL_OW 111
20804: GO 20807
20806: POP
// wait ( 2 ) ;
20807: LD_INT 2
20809: PPUSH
20810: CALL_OW 67
// end ;
20814: GO 20613
20816: POP
20817: POP
// enable ;
20818: ENABLE
// end ;
20819: PPOPN 1
20821: END
// export function Update_defend ( un ) ; var side ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
// if GetSide ( un ) = you then
20826: LD_VAR 0 1
20830: PPUSH
20831: CALL_OW 255
20835: PUSH
20836: LD_EXP 1
20840: EQUAL
20841: IFFALSE 20845
// exit ;
20843: GO 20920
// for side = 1 to 3 do
20845: LD_ADDR_VAR 0 3
20849: PUSH
20850: DOUBLE
20851: LD_INT 1
20853: DEC
20854: ST_TO_ADDR
20855: LD_INT 3
20857: PUSH
20858: FOR_TO
20859: IFFALSE 20918
// if un in defend_forces [ side ] then
20861: LD_VAR 0 1
20865: PUSH
20866: LD_EXP 69
20870: PUSH
20871: LD_VAR 0 3
20875: ARRAY
20876: IN
20877: IFFALSE 20916
// defend_forces := Replace ( defend_forces , side , defend_forces [ side ] diff un ) ;
20879: LD_ADDR_EXP 69
20883: PUSH
20884: LD_EXP 69
20888: PPUSH
20889: LD_VAR 0 3
20893: PPUSH
20894: LD_EXP 69
20898: PUSH
20899: LD_VAR 0 3
20903: ARRAY
20904: PUSH
20905: LD_VAR 0 1
20909: DIFF
20910: PPUSH
20911: CALL_OW 1
20915: ST_TO_ADDR
20916: GO 20858
20918: POP
20919: POP
// end ; end_of_file
20920: LD_VAR 0 2
20924: RET
// export ready_forces , attack_forces , retreat_forces , defend_forces , jammed_forces ; var us_ru , us_ar , ru_us , ru_ar ; var last_ar_attack , attack_timing , attack_limit ; var al_eliminate ; var pocet_odebrani ; export function init_attack ; var side ; begin
20925: LD_INT 0
20927: PPUSH
20928: PPUSH
// ready_forces = [ ] ;
20929: LD_ADDR_EXP 66
20933: PUSH
20934: EMPTY
20935: ST_TO_ADDR
// attack_forces = [ ] ;
20936: LD_ADDR_EXP 67
20940: PUSH
20941: EMPTY
20942: ST_TO_ADDR
// retreat_forces = [ ] ;
20943: LD_ADDR_EXP 68
20947: PUSH
20948: EMPTY
20949: ST_TO_ADDR
// defend_forces = [ ] ;
20950: LD_ADDR_EXP 69
20954: PUSH
20955: EMPTY
20956: ST_TO_ADDR
// for side = 1 to 8 do
20957: LD_ADDR_VAR 0 2
20961: PUSH
20962: DOUBLE
20963: LD_INT 1
20965: DEC
20966: ST_TO_ADDR
20967: LD_INT 8
20969: PUSH
20970: FOR_TO
20971: IFFALSE 21055
// begin ready_forces = ready_forces ^ [ [ ] ] ;
20973: LD_ADDR_EXP 66
20977: PUSH
20978: LD_EXP 66
20982: PUSH
20983: EMPTY
20984: PUSH
20985: EMPTY
20986: LIST
20987: ADD
20988: ST_TO_ADDR
// attack_forces = attack_forces ^ [ [ ] ] ;
20989: LD_ADDR_EXP 67
20993: PUSH
20994: LD_EXP 67
20998: PUSH
20999: EMPTY
21000: PUSH
21001: EMPTY
21002: LIST
21003: ADD
21004: ST_TO_ADDR
// retreat_forces = retreat_forces ^ [ [ ] ] ;
21005: LD_ADDR_EXP 68
21009: PUSH
21010: LD_EXP 68
21014: PUSH
21015: EMPTY
21016: PUSH
21017: EMPTY
21018: LIST
21019: ADD
21020: ST_TO_ADDR
// defend_forces = defend_forces ^ [ [ ] ] ;
21021: LD_ADDR_EXP 69
21025: PUSH
21026: LD_EXP 69
21030: PUSH
21031: EMPTY
21032: PUSH
21033: EMPTY
21034: LIST
21035: ADD
21036: ST_TO_ADDR
// jammed_forces = jammed_forces ^ [ [ ] ] ;
21037: LD_ADDR_EXP 70
21041: PUSH
21042: LD_EXP 70
21046: PUSH
21047: EMPTY
21048: PUSH
21049: EMPTY
21050: LIST
21051: ADD
21052: ST_TO_ADDR
// end ;
21053: GO 20970
21055: POP
21056: POP
// us_ru := [ [ 76 , 61 ] , [ 121 , 55 ] , [ 171 , 59 ] , [ 190 , 90 ] ] ;
21057: LD_ADDR_LOC 22
21061: PUSH
21062: LD_INT 76
21064: PUSH
21065: LD_INT 61
21067: PUSH
21068: EMPTY
21069: LIST
21070: LIST
21071: PUSH
21072: LD_INT 121
21074: PUSH
21075: LD_INT 55
21077: PUSH
21078: EMPTY
21079: LIST
21080: LIST
21081: PUSH
21082: LD_INT 171
21084: PUSH
21085: LD_INT 59
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: PUSH
21092: LD_INT 190
21094: PUSH
21095: LD_INT 90
21097: PUSH
21098: EMPTY
21099: LIST
21100: LIST
21101: PUSH
21102: EMPTY
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: ST_TO_ADDR
// us_ar := [ [ [ 78 , 69 ] , [ 121 , 116 ] , [ 155 , 137 ] , [ 190 , 170 ] , [ 242 , 187 ] ] , [ [ 72 , 106 ] , [ 111 , 176 ] , [ 163 , 184 ] , [ 215 , 191 ] , [ 242 , 187 ] ] ] ;
21108: LD_ADDR_LOC 23
21112: PUSH
21113: LD_INT 78
21115: PUSH
21116: LD_INT 69
21118: PUSH
21119: EMPTY
21120: LIST
21121: LIST
21122: PUSH
21123: LD_INT 121
21125: PUSH
21126: LD_INT 116
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: LD_INT 155
21135: PUSH
21136: LD_INT 137
21138: PUSH
21139: EMPTY
21140: LIST
21141: LIST
21142: PUSH
21143: LD_INT 190
21145: PUSH
21146: LD_INT 170
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: PUSH
21153: LD_INT 242
21155: PUSH
21156: LD_INT 187
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: PUSH
21163: EMPTY
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: PUSH
21170: LD_INT 72
21172: PUSH
21173: LD_INT 106
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PUSH
21180: LD_INT 111
21182: PUSH
21183: LD_INT 176
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PUSH
21190: LD_INT 163
21192: PUSH
21193: LD_INT 184
21195: PUSH
21196: EMPTY
21197: LIST
21198: LIST
21199: PUSH
21200: LD_INT 215
21202: PUSH
21203: LD_INT 191
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PUSH
21210: LD_INT 242
21212: PUSH
21213: LD_INT 187
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: EMPTY
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: ST_TO_ADDR
// ru_us := [ [ 118 , 63 ] , [ 78 , 57 ] , [ 30 , 44 ] , [ 56 , 83 ] ] ;
21231: LD_ADDR_LOC 24
21235: PUSH
21236: LD_INT 118
21238: PUSH
21239: LD_INT 63
21241: PUSH
21242: EMPTY
21243: LIST
21244: LIST
21245: PUSH
21246: LD_INT 78
21248: PUSH
21249: LD_INT 57
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: PUSH
21256: LD_INT 30
21258: PUSH
21259: LD_INT 44
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: LD_INT 56
21268: PUSH
21269: LD_INT 83
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: PUSH
21276: EMPTY
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: ST_TO_ADDR
// ru_ar := [ [ [ 142 , 65 ] , [ 160 , 140 ] , [ 255 , 196 ] ] , [ [ 125 , 58 ] , [ 106 , 93 ] , [ 126 , 154 ] , [ 121 , 182 ] , [ 167 , 180 ] , [ 251 , 187 ] ] ] ;
21282: LD_ADDR_LOC 25
21286: PUSH
21287: LD_INT 142
21289: PUSH
21290: LD_INT 65
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: PUSH
21297: LD_INT 160
21299: PUSH
21300: LD_INT 140
21302: PUSH
21303: EMPTY
21304: LIST
21305: LIST
21306: PUSH
21307: LD_INT 255
21309: PUSH
21310: LD_INT 196
21312: PUSH
21313: EMPTY
21314: LIST
21315: LIST
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: LIST
21321: PUSH
21322: LD_INT 125
21324: PUSH
21325: LD_INT 58
21327: PUSH
21328: EMPTY
21329: LIST
21330: LIST
21331: PUSH
21332: LD_INT 106
21334: PUSH
21335: LD_INT 93
21337: PUSH
21338: EMPTY
21339: LIST
21340: LIST
21341: PUSH
21342: LD_INT 126
21344: PUSH
21345: LD_INT 154
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: PUSH
21352: LD_INT 121
21354: PUSH
21355: LD_INT 182
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PUSH
21362: LD_INT 167
21364: PUSH
21365: LD_INT 180
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: PUSH
21372: LD_INT 251
21374: PUSH
21375: LD_INT 187
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: PUSH
21390: EMPTY
21391: LIST
21392: LIST
21393: ST_TO_ADDR
// al_eliminate = [ [ 88 , 53 ] , [ 49 , 10 ] , [ 83 , 13 ] ] ;
21394: LD_ADDR_LOC 29
21398: PUSH
21399: LD_INT 88
21401: PUSH
21402: LD_INT 53
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: PUSH
21409: LD_INT 49
21411: PUSH
21412: LD_INT 10
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 83
21421: PUSH
21422: LD_INT 13
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: LIST
21433: ST_TO_ADDR
// attack_timing = [ 50 , 40 , 30 ] [ difficulty ] ;
21434: LD_ADDR_LOC 27
21438: PUSH
21439: LD_INT 50
21441: PUSH
21442: LD_INT 40
21444: PUSH
21445: LD_INT 30
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: LIST
21452: PUSH
21453: LD_OWVAR 67
21457: ARRAY
21458: ST_TO_ADDR
// attack_limit = 0 ;
21459: LD_ADDR_LOC 28
21463: PUSH
21464: LD_INT 0
21466: ST_TO_ADDR
// last_ar_attack = TICK ;
21467: LD_ADDR_LOC 26
21471: PUSH
21472: LD_OWVAR 1
21476: ST_TO_ADDR
// pocet_odebrani = 0 ;
21477: LD_ADDR_LOC 30
21481: PUSH
21482: LD_INT 0
21484: ST_TO_ADDR
// end ;
21485: LD_VAR 0 1
21489: RET
// every 0 0$15.4 do var active_side , num_forces ;
21490: GO 21492
21492: DISABLE
21493: LD_INT 0
21495: PPUSH
21496: PPUSH
// begin num_forces := define_forces_strenght ;
21497: LD_ADDR_VAR 0 2
21501: PUSH
21502: CALL 21562 0 0
21506: ST_TO_ADDR
// for active_side in cpu_list do
21507: LD_ADDR_VAR 0 1
21511: PUSH
21512: LD_EXP 8
21516: PUSH
21517: FOR_IN
21518: IFFALSE 21556
// if ready_forces [ active_side ] >= num_forces then
21520: LD_EXP 66
21524: PUSH
21525: LD_VAR 0 1
21529: ARRAY
21530: PUSH
21531: LD_VAR 0 2
21535: GREATEREQUAL
21536: IFFALSE 21554
// begin let_the_war_begin ( active_side ) ;
21538: LD_VAR 0 1
21542: PPUSH
21543: CALL 23025 0 1
// wait ( 1 ) ;
21547: LD_INT 1
21549: PPUSH
21550: CALL_OW 67
// end ;
21554: GO 21517
21556: POP
21557: POP
// enable ;
21558: ENABLE
// end ;
21559: PPOPN 2
21561: END
// function define_forces_strenght ; var num ; begin
21562: LD_INT 0
21564: PPUSH
21565: PPUSH
// num := 3 ;
21566: LD_ADDR_VAR 0 2
21570: PUSH
21571: LD_INT 3
21573: ST_TO_ADDR
// if TICK > 7 7$0 then
21574: LD_OWVAR 1
21578: PUSH
21579: LD_INT 14700
21581: GREATER
21582: IFFALSE 21592
// num := 4 ;
21584: LD_ADDR_VAR 0 2
21588: PUSH
21589: LD_INT 4
21591: ST_TO_ADDR
// if TICK > 14 14$0 then
21592: LD_OWVAR 1
21596: PUSH
21597: LD_INT 29400
21599: GREATER
21600: IFFALSE 21610
// num := 6 ;
21602: LD_ADDR_VAR 0 2
21606: PUSH
21607: LD_INT 6
21609: ST_TO_ADDR
// result := num ;
21610: LD_ADDR_VAR 0 1
21614: PUSH
21615: LD_VAR 0 2
21619: ST_TO_ADDR
// end ;
21620: LD_VAR 0 1
21624: RET
// function define_target_priority ; var target ; begin
21625: LD_INT 0
21627: PPUSH
21628: PPUSH
// target := Rand ( 0 , attack_timing ) ;
21629: LD_ADDR_VAR 0 2
21633: PUSH
21634: LD_INT 0
21636: PPUSH
21637: LD_LOC 27
21641: PPUSH
21642: CALL_OW 12
21646: ST_TO_ADDR
// if target > attack_limit then
21647: LD_VAR 0 2
21651: PUSH
21652: LD_LOC 28
21656: GREATER
21657: IFFALSE 21669
// target := false else
21659: LD_ADDR_VAR 0 2
21663: PUSH
21664: LD_INT 0
21666: ST_TO_ADDR
21667: GO 21677
// target := true ;
21669: LD_ADDR_VAR 0 2
21673: PUSH
21674: LD_INT 1
21676: ST_TO_ADDR
// result := target ;
21677: LD_ADDR_VAR 0 1
21681: PUSH
21682: LD_VAR 0 2
21686: ST_TO_ADDR
// end ;
21687: LD_VAR 0 1
21691: RET
// every 1 1$0 trigger attack_timing > attack_limit do
21692: LD_LOC 27
21696: PUSH
21697: LD_LOC 28
21701: GREATER
21702: IFFALSE 21736
21704: GO 21706
21706: DISABLE
// begin attack_timing := attack_timing - 1 ;
21707: LD_ADDR_LOC 27
21711: PUSH
21712: LD_LOC 27
21716: PUSH
21717: LD_INT 1
21719: MINUS
21720: ST_TO_ADDR
// attack_limit := attack_limit + 1 ;
21721: LD_ADDR_LOC 28
21725: PUSH
21726: LD_LOC 28
21730: PUSH
21731: LD_INT 1
21733: PLUS
21734: ST_TO_ADDR
// enable ;
21735: ENABLE
// end ;
21736: END
// function Select_Weakest_Base ( areas ) ; var selected , un , list ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
21741: PPUSH
21742: PPUSH
// selected := false ;
21743: LD_ADDR_VAR 0 3
21747: PUSH
21748: LD_INT 0
21750: ST_TO_ADDR
// for un in areas do
21751: LD_ADDR_VAR 0 4
21755: PUSH
21756: LD_VAR 0 1
21760: PUSH
21761: FOR_IN
21762: IFFALSE 21889
// begin list := FilterUnitsInArea ( un , [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
21764: LD_ADDR_VAR 0 5
21768: PUSH
21769: LD_VAR 0 4
21773: PPUSH
21774: LD_INT 22
21776: PUSH
21777: LD_EXP 1
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 21
21788: PUSH
21789: LD_INT 3
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: LD_INT 2
21798: PUSH
21799: LD_INT 30
21801: PUSH
21802: LD_INT 33
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 30
21811: PUSH
21812: LD_INT 32
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: LIST
21823: PUSH
21824: EMPTY
21825: LIST
21826: LIST
21827: LIST
21828: PPUSH
21829: CALL_OW 70
21833: ST_TO_ADDR
// if ( not selected ) or ( selected [ 1 ] < list ) then
21834: LD_VAR 0 3
21838: NOT
21839: PUSH
21840: LD_VAR 0 3
21844: PUSH
21845: LD_INT 1
21847: ARRAY
21848: PUSH
21849: LD_VAR 0 5
21853: LESS
21854: OR
21855: IFFALSE 21880
// selected := [ list + 0 , un ] ;
21857: LD_ADDR_VAR 0 3
21861: PUSH
21862: LD_VAR 0 5
21866: PUSH
21867: LD_INT 0
21869: PLUS
21870: PUSH
21871: LD_VAR 0 4
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// wait ( 1 ) ;
21880: LD_INT 1
21882: PPUSH
21883: CALL_OW 67
// end ;
21887: GO 21761
21889: POP
21890: POP
// if selected then
21891: LD_VAR 0 3
21895: IFFALSE 21911
// selected := selected [ 2 ] ;
21897: LD_ADDR_VAR 0 3
21901: PUSH
21902: LD_VAR 0 3
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: ST_TO_ADDR
// result := selected ;
21911: LD_ADDR_VAR 0 2
21915: PUSH
21916: LD_VAR 0 3
21920: ST_TO_ADDR
// end ;
21921: LD_VAR 0 2
21925: RET
// function Find_Player_Base ; var list , un , goal , areas , defend_tought ; begin
21926: LD_INT 0
21928: PPUSH
21929: PPUSH
21930: PPUSH
21931: PPUSH
21932: PPUSH
21933: PPUSH
// goal := false ;
21934: LD_ADDR_VAR 0 4
21938: PUSH
21939: LD_INT 0
21941: ST_TO_ADDR
// areas := [ ] ;
21942: LD_ADDR_VAR 0 5
21946: PUSH
21947: EMPTY
21948: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21949: LD_ADDR_VAR 0 2
21953: PUSH
21954: LD_INT 22
21956: PUSH
21957: LD_EXP 1
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: PUSH
21966: LD_INT 21
21968: PUSH
21969: LD_INT 3
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PUSH
21976: LD_INT 2
21978: PUSH
21979: LD_INT 30
21981: PUSH
21982: LD_INT 0
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: PUSH
21989: LD_INT 30
21991: PUSH
21992: LD_INT 1
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: EMPTY
22000: LIST
22001: LIST
22002: LIST
22003: PUSH
22004: EMPTY
22005: LIST
22006: LIST
22007: LIST
22008: PPUSH
22009: CALL_OW 69
22013: ST_TO_ADDR
// for un in list do
22014: LD_ADDR_VAR 0 3
22018: PUSH
22019: LD_VAR 0 2
22023: PUSH
22024: FOR_IN
22025: IFFALSE 22124
// begin if IsInArea ( un , ar_base ) then
22027: LD_VAR 0 3
22031: PPUSH
22032: LD_INT 13
22034: PPUSH
22035: CALL_OW 308
22039: IFFALSE 22057
// areas := areas ^ ar_base else
22041: LD_ADDR_VAR 0 5
22045: PUSH
22046: LD_VAR 0 5
22050: PUSH
22051: LD_INT 13
22053: ADD
22054: ST_TO_ADDR
22055: GO 22115
// if IsInArea ( un , us_base ) then
22057: LD_VAR 0 3
22061: PPUSH
22062: LD_INT 11
22064: PPUSH
22065: CALL_OW 308
22069: IFFALSE 22087
// areas := areas ^ us_base else
22071: LD_ADDR_VAR 0 5
22075: PUSH
22076: LD_VAR 0 5
22080: PUSH
22081: LD_INT 11
22083: ADD
22084: ST_TO_ADDR
22085: GO 22115
// if IsInArea ( un , ru_base ) then
22087: LD_VAR 0 3
22091: PPUSH
22092: LD_INT 12
22094: PPUSH
22095: CALL_OW 308
22099: IFFALSE 22115
// areas := areas ^ ru_base ;
22101: LD_ADDR_VAR 0 5
22105: PUSH
22106: LD_VAR 0 5
22110: PUSH
22111: LD_INT 12
22113: ADD
22114: ST_TO_ADDR
// wait ( 1 ) ;
22115: LD_INT 1
22117: PPUSH
22118: CALL_OW 67
// end ;
22122: GO 22024
22124: POP
22125: POP
// if ( not areas ) or ( areas > 1 ) then
22126: LD_VAR 0 5
22130: NOT
22131: PUSH
22132: LD_VAR 0 5
22136: PUSH
22137: LD_INT 1
22139: GREATER
22140: OR
22141: IFFALSE 22160
// goal := Select_Weakest_Base ( areas ) else
22143: LD_ADDR_VAR 0 4
22147: PUSH
22148: LD_VAR 0 5
22152: PPUSH
22153: CALL 21737 0 1
22157: ST_TO_ADDR
22158: GO 22174
// goal := areas [ 1 ] ;
22160: LD_ADDR_VAR 0 4
22164: PUSH
22165: LD_VAR 0 5
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: ST_TO_ADDR
// result := goal ;
22174: LD_ADDR_VAR 0 1
22178: PUSH
22179: LD_VAR 0 4
22183: ST_TO_ADDR
// end ;
22184: LD_VAR 0 1
22188: RET
// function GetUnitArea ( un ) ; var area ; begin
22189: LD_INT 0
22191: PPUSH
22192: PPUSH
// case un of 1 :
22193: LD_VAR 0 1
22197: PUSH
22198: LD_INT 1
22200: DOUBLE
22201: EQUAL
22202: IFTRUE 22206
22204: GO 22217
22206: POP
// area := us_base ; 2 :
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_INT 11
22214: ST_TO_ADDR
22215: GO 22256
22217: LD_INT 2
22219: DOUBLE
22220: EQUAL
22221: IFTRUE 22225
22223: GO 22236
22225: POP
// area := ar_base ; 3 :
22226: LD_ADDR_VAR 0 3
22230: PUSH
22231: LD_INT 13
22233: ST_TO_ADDR
22234: GO 22256
22236: LD_INT 3
22238: DOUBLE
22239: EQUAL
22240: IFTRUE 22244
22242: GO 22255
22244: POP
// area := ru_base ; end ;
22245: LD_ADDR_VAR 0 3
22249: PUSH
22250: LD_INT 12
22252: ST_TO_ADDR
22253: GO 22256
22255: POP
// result := area ;
22256: LD_ADDR_VAR 0 2
22260: PUSH
22261: LD_VAR 0 3
22265: ST_TO_ADDR
// end ;
22266: LD_VAR 0 2
22270: RET
// function Find_CPU_Target ( side ) ; var un , goal , bases , list ; begin
22271: LD_INT 0
22273: PPUSH
22274: PPUSH
22275: PPUSH
22276: PPUSH
22277: PPUSH
// bases := [ ] ;
22278: LD_ADDR_VAR 0 5
22282: PUSH
22283: EMPTY
22284: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22285: LD_ADDR_VAR 0 6
22289: PUSH
22290: LD_INT 21
22292: PUSH
22293: LD_INT 3
22295: PUSH
22296: EMPTY
22297: LIST
22298: LIST
22299: PUSH
22300: LD_INT 2
22302: PUSH
22303: LD_INT 30
22305: PUSH
22306: LD_INT 0
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 1
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: LIST
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PPUSH
22332: CALL_OW 69
22336: ST_TO_ADDR
// for un in list do
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_VAR 0 6
22346: PUSH
22347: FOR_IN
22348: IFFALSE 22390
// if GetSide ( un ) <> side then
22350: LD_VAR 0 3
22354: PPUSH
22355: CALL_OW 255
22359: PUSH
22360: LD_VAR 0 1
22364: NONEQUAL
22365: IFFALSE 22388
// bases := bases ^ GetSide ( un ) ;
22367: LD_ADDR_VAR 0 5
22371: PUSH
22372: LD_VAR 0 5
22376: PUSH
22377: LD_VAR 0 3
22381: PPUSH
22382: CALL_OW 255
22386: ADD
22387: ST_TO_ADDR
22388: GO 22347
22390: POP
22391: POP
// bases := bases diff you ;
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_VAR 0 5
22401: PUSH
22402: LD_EXP 1
22406: DIFF
22407: ST_TO_ADDR
// if bases then
22408: LD_VAR 0 5
22412: IFFALSE 22496
// begin if ( bases diff ar ) and Rand ( 0 , 2 ) then
22414: LD_VAR 0 5
22418: PUSH
22419: LD_EXP 4
22423: DIFF
22424: PUSH
22425: LD_INT 0
22427: PPUSH
22428: LD_INT 2
22430: PPUSH
22431: CALL_OW 12
22435: AND
22436: IFFALSE 22465
// goal := GetUnitArea ( ( bases diff ar ) [ 1 ] ) else
22438: LD_ADDR_VAR 0 4
22442: PUSH
22443: LD_VAR 0 5
22447: PUSH
22448: LD_EXP 4
22452: DIFF
22453: PUSH
22454: LD_INT 1
22456: ARRAY
22457: PPUSH
22458: CALL 22189 0 1
22462: ST_TO_ADDR
22463: GO 22494
// goal := GetUnitArea ( bases [ Rand ( 1 , bases ) ] ) ;
22465: LD_ADDR_VAR 0 4
22469: PUSH
22470: LD_VAR 0 5
22474: PUSH
22475: LD_INT 1
22477: PPUSH
22478: LD_VAR 0 5
22482: PPUSH
22483: CALL_OW 12
22487: ARRAY
22488: PPUSH
22489: CALL 22189 0 1
22493: ST_TO_ADDR
// end else
22494: GO 22506
// goal := Find_Player_Base ;
22496: LD_ADDR_VAR 0 4
22500: PUSH
22501: CALL 21926 0 0
22505: ST_TO_ADDR
// result := goal ;
22506: LD_ADDR_VAR 0 2
22510: PUSH
22511: LD_VAR 0 4
22515: ST_TO_ADDR
// end ;
22516: LD_VAR 0 2
22520: RET
// function Wrong_Base ; var un , vysledek ; begin
22521: LD_INT 0
22523: PPUSH
22524: PPUSH
22525: PPUSH
// un := FilterUnitsInArea ( top_area , [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
22526: LD_ADDR_VAR 0 2
22530: PUSH
22531: LD_INT 20
22533: PPUSH
22534: LD_INT 22
22536: PUSH
22537: LD_EXP 1
22541: PUSH
22542: EMPTY
22543: LIST
22544: LIST
22545: PUSH
22546: LD_INT 21
22548: PUSH
22549: LD_INT 3
22551: PUSH
22552: EMPTY
22553: LIST
22554: LIST
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 70
22564: ST_TO_ADDR
// if un then
22565: LD_VAR 0 2
22569: IFFALSE 22581
// vysledek := true else
22571: LD_ADDR_VAR 0 3
22575: PUSH
22576: LD_INT 1
22578: ST_TO_ADDR
22579: GO 22589
// vysledek := false ;
22581: LD_ADDR_VAR 0 3
22585: PUSH
22586: LD_INT 0
22588: ST_TO_ADDR
// result := vysledek ;
22589: LD_ADDR_VAR 0 1
22593: PUSH
22594: LD_VAR 0 3
22598: ST_TO_ADDR
// end ;
22599: LD_VAR 0 1
22603: RET
// function All_Tracked ( list ) ; var un , vysledek ; begin
22604: LD_INT 0
22606: PPUSH
22607: PPUSH
22608: PPUSH
// vysledek := true ;
22609: LD_ADDR_VAR 0 4
22613: PUSH
22614: LD_INT 1
22616: ST_TO_ADDR
// for un in list do
22617: LD_ADDR_VAR 0 3
22621: PUSH
22622: LD_VAR 0 1
22626: PUSH
22627: FOR_IN
22628: IFFALSE 22668
// if GetChassis ( un ) in [ us_light_wheeled , us_medium_wheeled , ru_medium_wheeled ] then
22630: LD_VAR 0 3
22634: PPUSH
22635: CALL_OW 265
22639: PUSH
22640: LD_INT 1
22642: PUSH
22643: LD_INT 2
22645: PUSH
22646: LD_INT 21
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: LIST
22653: IN
22654: IFFALSE 22666
// begin vysledek := false ;
22656: LD_ADDR_VAR 0 4
22660: PUSH
22661: LD_INT 0
22663: ST_TO_ADDR
// break ;
22664: GO 22668
// end ;
22666: GO 22627
22668: POP
22669: POP
// result := vysledek ;
22670: LD_ADDR_VAR 0 2
22674: PUSH
22675: LD_VAR 0 4
22679: ST_TO_ADDR
// end ;
22680: LD_VAR 0 2
22684: RET
// function Send_US_Forces ( target , side ) ; begin
22685: LD_INT 0
22687: PPUSH
// if target = ar_base then
22688: LD_VAR 0 1
22692: PUSH
22693: LD_INT 13
22695: EQUAL
22696: IFFALSE 22809
// begin if All_tracked ( attack_forces [ side ] ) then
22698: LD_EXP 67
22702: PUSH
22703: LD_VAR 0 2
22707: ARRAY
22708: PPUSH
22709: CALL 22604 0 1
22713: IFFALSE 22762
// McMove ( 15 , attack_forces [ side ] , us_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22715: LD_INT 15
22717: PPUSH
22718: LD_EXP 67
22722: PUSH
22723: LD_VAR 0 2
22727: ARRAY
22728: PPUSH
22729: LD_LOC 23
22733: PUSH
22734: LD_INT 1
22736: ARRAY
22737: PPUSH
22738: LD_INT 3
22740: PUSH
22741: LD_INT 5
22743: PUSH
22744: LD_INT 6
22746: PUSH
22747: LD_INT 7
22749: PUSH
22750: EMPTY
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: PPUSH
22756: CALL_OW 398
22760: GO 22807
// McMove ( 15 , attack_forces [ side ] , us_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22762: LD_INT 15
22764: PPUSH
22765: LD_EXP 67
22769: PUSH
22770: LD_VAR 0 2
22774: ARRAY
22775: PPUSH
22776: LD_LOC 23
22780: PUSH
22781: LD_INT 2
22783: ARRAY
22784: PPUSH
22785: LD_INT 3
22787: PUSH
22788: LD_INT 5
22790: PUSH
22791: LD_INT 6
22793: PUSH
22794: LD_INT 7
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: LIST
22801: LIST
22802: PPUSH
22803: CALL_OW 398
// end else
22807: GO 22850
// McMove ( 15 , attack_forces [ side ] , us_ru , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22809: LD_INT 15
22811: PPUSH
22812: LD_EXP 67
22816: PUSH
22817: LD_VAR 0 2
22821: ARRAY
22822: PPUSH
22823: LD_LOC 22
22827: PPUSH
22828: LD_INT 3
22830: PUSH
22831: LD_INT 5
22833: PUSH
22834: LD_INT 6
22836: PUSH
22837: LD_INT 7
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: PPUSH
22846: CALL_OW 398
// end ;
22850: LD_VAR 0 3
22854: RET
// function Send_RU_Forces ( target , side ) ; begin
22855: LD_INT 0
22857: PPUSH
// if target = ar_base then
22858: LD_VAR 0 1
22862: PUSH
22863: LD_INT 13
22865: EQUAL
22866: IFFALSE 22979
// begin if All_tracked ( attack_forces [ side ] ) then
22868: LD_EXP 67
22872: PUSH
22873: LD_VAR 0 2
22877: ARRAY
22878: PPUSH
22879: CALL 22604 0 1
22883: IFFALSE 22932
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22885: LD_INT 15
22887: PPUSH
22888: LD_EXP 67
22892: PUSH
22893: LD_VAR 0 2
22897: ARRAY
22898: PPUSH
22899: LD_LOC 25
22903: PUSH
22904: LD_INT 1
22906: ARRAY
22907: PPUSH
22908: LD_INT 3
22910: PUSH
22911: LD_INT 5
22913: PUSH
22914: LD_INT 6
22916: PUSH
22917: LD_INT 7
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: LIST
22924: LIST
22925: PPUSH
22926: CALL_OW 398
22930: GO 22977
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22932: LD_INT 15
22934: PPUSH
22935: LD_EXP 67
22939: PUSH
22940: LD_VAR 0 2
22944: ARRAY
22945: PPUSH
22946: LD_LOC 25
22950: PUSH
22951: LD_INT 2
22953: ARRAY
22954: PPUSH
22955: LD_INT 3
22957: PUSH
22958: LD_INT 5
22960: PUSH
22961: LD_INT 6
22963: PUSH
22964: LD_INT 7
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: PPUSH
22973: CALL_OW 398
// end else
22977: GO 23020
// McMove ( 15 , attack_forces [ side ] , ru_us , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
22979: LD_INT 15
22981: PPUSH
22982: LD_EXP 67
22986: PUSH
22987: LD_VAR 0 2
22991: ARRAY
22992: PPUSH
22993: LD_LOC 24
22997: PPUSH
22998: LD_INT 3
23000: PUSH
23001: LD_INT 5
23003: PUSH
23004: LD_INT 6
23006: PUSH
23007: LD_INT 7
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: LIST
23014: LIST
23015: PPUSH
23016: CALL_OW 398
// end ;
23020: LD_VAR 0 3
23024: RET
// function let_the_war_begin ( side ) ; var target ; begin
23025: LD_INT 0
23027: PPUSH
23028: PPUSH
// target := false ;
23029: LD_ADDR_VAR 0 3
23033: PUSH
23034: LD_INT 0
23036: ST_TO_ADDR
// if define_target_priority then
23037: CALL 21625 0 0
23041: IFFALSE 23053
// target := Find_Player_Base ;
23043: LD_ADDR_VAR 0 3
23047: PUSH
23048: CALL 21926 0 0
23052: ST_TO_ADDR
// if not target then
23053: LD_VAR 0 3
23057: NOT
23058: IFFALSE 23075
// target := Find_CPU_Target ( side ) ;
23060: LD_ADDR_VAR 0 3
23064: PUSH
23065: LD_VAR 0 1
23069: PPUSH
23070: CALL 22271 0 1
23074: ST_TO_ADDR
// if not target then
23075: LD_VAR 0 3
23079: NOT
23080: IFFALSE 23084
// exit ;
23082: GO 23307
// attack_forces := Replace ( attack_forces , side , ready_forces [ side ] ) ;
23084: LD_ADDR_EXP 67
23088: PUSH
23089: LD_EXP 67
23093: PPUSH
23094: LD_VAR 0 1
23098: PPUSH
23099: LD_EXP 66
23103: PUSH
23104: LD_VAR 0 1
23108: ARRAY
23109: PPUSH
23110: CALL_OW 1
23114: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
23115: LD_ADDR_EXP 66
23119: PUSH
23120: LD_EXP 66
23124: PPUSH
23125: LD_VAR 0 1
23129: PPUSH
23130: EMPTY
23131: PPUSH
23132: CALL_OW 1
23136: ST_TO_ADDR
// jammed_forces := Insert ( jammed_forces , side , jammed_forces [ side ] ^ attack_forces [ side ] ) ;
23137: LD_ADDR_EXP 70
23141: PUSH
23142: LD_EXP 70
23146: PPUSH
23147: LD_VAR 0 1
23151: PPUSH
23152: LD_EXP 70
23156: PUSH
23157: LD_VAR 0 1
23161: ARRAY
23162: PUSH
23163: LD_EXP 67
23167: PUSH
23168: LD_VAR 0 1
23172: ARRAY
23173: ADD
23174: PPUSH
23175: CALL_OW 2
23179: ST_TO_ADDR
// case side of 1 :
23180: LD_VAR 0 1
23184: PUSH
23185: LD_INT 1
23187: DOUBLE
23188: EQUAL
23189: IFTRUE 23193
23191: GO 23199
23193: POP
// enable ( 222 ) ; 3 :
23194: LD_INT 222
23196: ENABLE_MARKED
23197: GO 23214
23199: LD_INT 3
23201: DOUBLE
23202: EQUAL
23203: IFTRUE 23207
23205: GO 23213
23207: POP
// enable ( 223 ) ; end ;
23208: LD_INT 223
23210: ENABLE_MARKED
23211: GO 23214
23213: POP
// if Wrong_Base then
23214: CALL 22521 0 0
23218: IFFALSE 23251
// McMove ( 15 , attack_forces [ side ] , al_eliminate , [ mc_move_dontcapture ] ) else
23220: LD_INT 15
23222: PPUSH
23223: LD_EXP 67
23227: PUSH
23228: LD_VAR 0 1
23232: ARRAY
23233: PPUSH
23234: LD_LOC 29
23238: PPUSH
23239: LD_INT 5
23241: PUSH
23242: EMPTY
23243: LIST
23244: PPUSH
23245: CALL_OW 398
23249: GO 23307
// case side of 1 :
23251: LD_VAR 0 1
23255: PUSH
23256: LD_INT 1
23258: DOUBLE
23259: EQUAL
23260: IFTRUE 23264
23262: GO 23281
23264: POP
// Send_US_Forces ( target , side ) ; 3 :
23265: LD_VAR 0 3
23269: PPUSH
23270: LD_VAR 0 1
23274: PPUSH
23275: CALL 22685 0 2
23279: GO 23307
23281: LD_INT 3
23283: DOUBLE
23284: EQUAL
23285: IFTRUE 23289
23287: GO 23306
23289: POP
// Send_RU_Forces ( target , side ) ; end ;
23290: LD_VAR 0 3
23294: PPUSH
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL 22855 0 2
23304: GO 23307
23306: POP
// end ;
23307: LD_VAR 0 2
23311: RET
// every 88 marked 222 do var list , late , un , i ;
23312: GO 23314
23314: DISABLE
23315: LD_INT 0
23317: PPUSH
23318: PPUSH
23319: PPUSH
23320: PPUSH
// begin wait ( 1 1$20 ) ;
23321: LD_INT 2800
23323: PPUSH
23324: CALL_OW 67
// list := FilterUnitsInArea ( us_tinny , [ [ f_side , us ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23328: LD_ADDR_VAR 0 1
23332: PUSH
23333: LD_INT 41
23335: PPUSH
23336: LD_INT 22
23338: PUSH
23339: LD_EXP 3
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 21
23350: PUSH
23351: LD_INT 2
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 50
23360: PUSH
23361: EMPTY
23362: LIST
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: LIST
23368: PPUSH
23369: CALL_OW 70
23373: ST_TO_ADDR
// late := jammed_forces [ us ] isect list ;
23374: LD_ADDR_VAR 0 2
23378: PUSH
23379: LD_EXP 70
23383: PUSH
23384: LD_EXP 3
23388: ARRAY
23389: PUSH
23390: LD_VAR 0 1
23394: ISECT
23395: ST_TO_ADDR
// if not late then
23396: LD_VAR 0 2
23400: NOT
23401: IFFALSE 23427
// begin jammed_forces := Replace ( jammed_forces , us , [ ] ) ;
23403: LD_ADDR_EXP 70
23407: PUSH
23408: LD_EXP 70
23412: PPUSH
23413: LD_EXP 3
23417: PPUSH
23418: EMPTY
23419: PPUSH
23420: CALL_OW 1
23424: ST_TO_ADDR
// exit ;
23425: GO 23705
// end ; if FilterUnitsInArea ( us_base , [ [ f_side , you ] ] ) then
23427: LD_INT 11
23429: PPUSH
23430: LD_INT 22
23432: PUSH
23433: LD_EXP 1
23437: PUSH
23438: EMPTY
23439: LIST
23440: LIST
23441: PUSH
23442: EMPTY
23443: LIST
23444: PPUSH
23445: CALL_OW 70
23449: IFFALSE 23454
// begin enable ;
23451: ENABLE
// exit ;
23452: GO 23705
// end ; for un in late do
23454: LD_ADDR_VAR 0 3
23458: PUSH
23459: LD_VAR 0 2
23463: PUSH
23464: FOR_IN
23465: IFFALSE 23494
// if GetUnitMc ( un ) then
23467: LD_VAR 0 3
23471: PPUSH
23472: CALL_OW 388
23476: IFFALSE 23492
// KillMc ( GetUnitMc ( un ) ) ;
23478: LD_VAR 0 3
23482: PPUSH
23483: CALL_OW 388
23487: PPUSH
23488: CALL_OW 387
23492: GO 23464
23494: POP
23495: POP
// while GetTag ( 83 ) do
23496: LD_INT 83
23498: PPUSH
23499: CALL_OW 110
23503: IFFALSE 23514
// wait ( 0 0$1 ) ;
23505: LD_INT 35
23507: PPUSH
23508: CALL_OW 67
23512: GO 23496
// i := 1 ;
23514: LD_ADDR_VAR 0 4
23518: PUSH
23519: LD_INT 1
23521: ST_TO_ADDR
// for un in jammed_forces [ us ] do
23522: LD_ADDR_VAR 0 3
23526: PUSH
23527: LD_EXP 70
23531: PUSH
23532: LD_EXP 3
23536: ARRAY
23537: PUSH
23538: FOR_IN
23539: IFFALSE 23644
// begin if ( i mod 2 ) and not See ( you , un ) then
23541: LD_VAR 0 4
23545: PUSH
23546: LD_INT 2
23548: MOD
23549: PUSH
23550: LD_EXP 1
23554: PPUSH
23555: LD_VAR 0 3
23559: PPUSH
23560: CALL_OW 292
23564: NOT
23565: AND
23566: IFFALSE 23628
// begin jammed_forces := Replace ( jammed_forces , us , jammed_forces [ us ] diff un ) ;
23568: LD_ADDR_EXP 70
23572: PUSH
23573: LD_EXP 70
23577: PPUSH
23578: LD_EXP 3
23582: PPUSH
23583: LD_EXP 70
23587: PUSH
23588: LD_EXP 3
23592: ARRAY
23593: PUSH
23594: LD_VAR 0 3
23598: DIFF
23599: PPUSH
23600: CALL_OW 1
23604: ST_TO_ADDR
// KillUnit ( un ) ;
23605: LD_VAR 0 3
23609: PPUSH
23610: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23614: LD_ADDR_LOC 30
23618: PUSH
23619: LD_LOC 30
23623: PUSH
23624: LD_INT 1
23626: PLUS
23627: ST_TO_ADDR
// end ; i := i + 1 ;
23628: LD_ADDR_VAR 0 4
23632: PUSH
23633: LD_VAR 0 4
23637: PUSH
23638: LD_INT 1
23640: PLUS
23641: ST_TO_ADDR
// end ;
23642: GO 23538
23644: POP
23645: POP
// wait ( 0 0$10 ) ;
23646: LD_INT 350
23648: PPUSH
23649: CALL_OW 67
// ready_forces := Replace ( ready_forces , us , ready_forces [ us ] union jammed_forces [ us ] ) ;
23653: LD_ADDR_EXP 66
23657: PUSH
23658: LD_EXP 66
23662: PPUSH
23663: LD_EXP 3
23667: PPUSH
23668: LD_EXP 66
23672: PUSH
23673: LD_EXP 3
23677: ARRAY
23678: PUSH
23679: LD_EXP 70
23683: PUSH
23684: LD_EXP 3
23688: ARRAY
23689: UNION
23690: PPUSH
23691: CALL_OW 1
23695: ST_TO_ADDR
// let_the_war_begin ( us ) ;
23696: LD_EXP 3
23700: PPUSH
23701: CALL 23025 0 1
// end ;
23705: PPOPN 4
23707: END
// every 91 marked 223 do var list , late , un , i ;
23708: GO 23710
23710: DISABLE
23711: LD_INT 0
23713: PPUSH
23714: PPUSH
23715: PPUSH
23716: PPUSH
// begin wait ( 1 1$20 ) ;
23717: LD_INT 2800
23719: PPUSH
23720: CALL_OW 67
// list := FilterUnitsInArea ( ru_tinny , [ [ f_side , ru ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23724: LD_ADDR_VAR 0 1
23728: PUSH
23729: LD_INT 40
23731: PPUSH
23732: LD_INT 22
23734: PUSH
23735: LD_EXP 2
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: PUSH
23744: LD_INT 21
23746: PUSH
23747: LD_INT 2
23749: PUSH
23750: EMPTY
23751: LIST
23752: LIST
23753: PUSH
23754: LD_INT 50
23756: PUSH
23757: EMPTY
23758: LIST
23759: PUSH
23760: EMPTY
23761: LIST
23762: LIST
23763: LIST
23764: PPUSH
23765: CALL_OW 70
23769: ST_TO_ADDR
// late := jammed_forces [ ru ] isect list ;
23770: LD_ADDR_VAR 0 2
23774: PUSH
23775: LD_EXP 70
23779: PUSH
23780: LD_EXP 2
23784: ARRAY
23785: PUSH
23786: LD_VAR 0 1
23790: ISECT
23791: ST_TO_ADDR
// if not late then
23792: LD_VAR 0 2
23796: NOT
23797: IFFALSE 23823
// begin jammed_forces := Replace ( jammed_forces , ru , [ ] ) ;
23799: LD_ADDR_EXP 70
23803: PUSH
23804: LD_EXP 70
23808: PPUSH
23809: LD_EXP 2
23813: PPUSH
23814: EMPTY
23815: PPUSH
23816: CALL_OW 1
23820: ST_TO_ADDR
// exit ;
23821: GO 24101
// end ; if FilterUnitsInArea ( ru_base , [ [ f_side , you ] ] ) then
23823: LD_INT 12
23825: PPUSH
23826: LD_INT 22
23828: PUSH
23829: LD_EXP 1
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PUSH
23838: EMPTY
23839: LIST
23840: PPUSH
23841: CALL_OW 70
23845: IFFALSE 23850
// begin enable ;
23847: ENABLE
// exit ;
23848: GO 24101
// end ; for un in late do
23850: LD_ADDR_VAR 0 3
23854: PUSH
23855: LD_VAR 0 2
23859: PUSH
23860: FOR_IN
23861: IFFALSE 23890
// if GetUnitMc ( un ) then
23863: LD_VAR 0 3
23867: PPUSH
23868: CALL_OW 388
23872: IFFALSE 23888
// KillMc ( GetUnitMc ( un ) ) ;
23874: LD_VAR 0 3
23878: PPUSH
23879: CALL_OW 388
23883: PPUSH
23884: CALL_OW 387
23888: GO 23860
23890: POP
23891: POP
// while GetTag ( 83 ) do
23892: LD_INT 83
23894: PPUSH
23895: CALL_OW 110
23899: IFFALSE 23910
// wait ( 0 0$1 ) ;
23901: LD_INT 35
23903: PPUSH
23904: CALL_OW 67
23908: GO 23892
// i := 1 ;
23910: LD_ADDR_VAR 0 4
23914: PUSH
23915: LD_INT 1
23917: ST_TO_ADDR
// for un in jammed_forces [ ru ] do
23918: LD_ADDR_VAR 0 3
23922: PUSH
23923: LD_EXP 70
23927: PUSH
23928: LD_EXP 2
23932: ARRAY
23933: PUSH
23934: FOR_IN
23935: IFFALSE 24040
// begin if ( i mod 2 ) and not See ( you , un ) then
23937: LD_VAR 0 4
23941: PUSH
23942: LD_INT 2
23944: MOD
23945: PUSH
23946: LD_EXP 1
23950: PPUSH
23951: LD_VAR 0 3
23955: PPUSH
23956: CALL_OW 292
23960: NOT
23961: AND
23962: IFFALSE 24024
// begin jammed_forces := Replace ( jammed_forces , ru , jammed_forces [ ru ] diff un ) ;
23964: LD_ADDR_EXP 70
23968: PUSH
23969: LD_EXP 70
23973: PPUSH
23974: LD_EXP 2
23978: PPUSH
23979: LD_EXP 70
23983: PUSH
23984: LD_EXP 2
23988: ARRAY
23989: PUSH
23990: LD_VAR 0 3
23994: DIFF
23995: PPUSH
23996: CALL_OW 1
24000: ST_TO_ADDR
// KillUnit ( un ) ;
24001: LD_VAR 0 3
24005: PPUSH
24006: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
24010: LD_ADDR_LOC 30
24014: PUSH
24015: LD_LOC 30
24019: PUSH
24020: LD_INT 1
24022: PLUS
24023: ST_TO_ADDR
// end ; i := i + 1 ;
24024: LD_ADDR_VAR 0 4
24028: PUSH
24029: LD_VAR 0 4
24033: PUSH
24034: LD_INT 1
24036: PLUS
24037: ST_TO_ADDR
// end ;
24038: GO 23934
24040: POP
24041: POP
// wait ( 0 0$10 ) ;
24042: LD_INT 350
24044: PPUSH
24045: CALL_OW 67
// ready_forces := Replace ( ready_forces , ru , ready_forces [ ru ] union jammed_forces [ ru ] ) ;
24049: LD_ADDR_EXP 66
24053: PUSH
24054: LD_EXP 66
24058: PPUSH
24059: LD_EXP 2
24063: PPUSH
24064: LD_EXP 66
24068: PUSH
24069: LD_EXP 2
24073: ARRAY
24074: PUSH
24075: LD_EXP 70
24079: PUSH
24080: LD_EXP 2
24084: ARRAY
24085: UNION
24086: PPUSH
24087: CALL_OW 1
24091: ST_TO_ADDR
// let_the_war_begin ( ru ) ;
24092: LD_EXP 2
24096: PPUSH
24097: CALL 23025 0 1
// end ; end_of_file
24101: PPOPN 4
24103: END
// var tech_list , weap_list , sib_list , comp_list , opto_list , bio_list , space_list ; var utech_basic , utech_weap , utech_sib , utech_comp , utech_bio , utech_space , utech_opto ; var basic_tech , upgrade_tech ; var first_technology , last_technology , recomended_technology ; export scientistic_wanted ; var all_invented ; export function init_research ; begin
24104: LD_INT 0
24106: PPUSH
// all_invented := [ false , false , false , false , false , false , false , false ] ;
24107: LD_ADDR_LOC 50
24111: PUSH
24112: LD_INT 0
24114: PUSH
24115: LD_INT 0
24117: PUSH
24118: LD_INT 0
24120: PUSH
24121: LD_INT 0
24123: PUSH
24124: LD_INT 0
24126: PUSH
24127: LD_INT 0
24129: PUSH
24130: LD_INT 0
24132: PUSH
24133: LD_INT 0
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: ST_TO_ADDR
// tech_list := [ tech_SolPow , tech_SolEng , tech_OilPow , tech_OilEng , tech_SibDet , tech_ApeLang , tech_ApePsych , tech_ApeAgres ] ;
24146: LD_ADDR_LOC 31
24150: PUSH
24151: LD_INT 35
24153: PUSH
24154: LD_INT 45
24156: PUSH
24157: LD_INT 46
24159: PUSH
24160: LD_INT 47
24162: PUSH
24163: LD_INT 20
24165: PUSH
24166: LD_INT 1
24168: PUSH
24169: LD_INT 2
24171: PUSH
24172: LD_INT 11
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: LIST
24181: LIST
24182: LIST
24183: LIST
24184: ST_TO_ADDR
// weap_list := [ tech_Gatling , tech_Gun , tech_Explos , tech_AdvMet , tech_Rocket , tech_AdvRocket , tech_Bazooka , tech_Mortar , tech_AdvChassis , tech_Soporific , tech_Flame , tech_Behemoth , tech_SelfDest ] ;
24185: LD_ADDR_LOC 32
24189: PUSH
24190: LD_INT 69
24192: PUSH
24193: LD_INT 39
24195: PUSH
24196: LD_INT 42
24198: PUSH
24199: LD_INT 34
24201: PUSH
24202: LD_INT 40
24204: PUSH
24205: LD_INT 71
24207: PUSH
24208: LD_INT 44
24210: PUSH
24211: LD_INT 41
24213: PUSH
24214: LD_INT 36
24216: PUSH
24217: LD_INT 13
24219: PUSH
24220: LD_INT 70
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 43
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: LIST
24237: LIST
24238: LIST
24239: LIST
24240: LIST
24241: LIST
24242: LIST
24243: ST_TO_ADDR
// sib_list := [ tech_SibPow , tech_SibEng , tech_SibFiss ] ;
24244: LD_ADDR_LOC 33
24248: PUSH
24249: LD_INT 21
24251: PUSH
24252: LD_INT 22
24254: PUSH
24255: LD_INT 25
24257: PUSH
24258: EMPTY
24259: LIST
24260: LIST
24261: LIST
24262: ST_TO_ADDR
// comp_list := [ tech_AI , tech_AdvAI , tech_Virus , tech_TargTeleport ] ;
24263: LD_ADDR_LOC 34
24267: PUSH
24268: LD_INT 32
24270: PUSH
24271: LD_INT 27
24273: PUSH
24274: LD_INT 33
24276: PUSH
24277: LD_INT 38
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: LIST
24284: LIST
24285: ST_TO_ADDR
// opto_list := [ tech_Radar , tech_LasSight , tech_RemCont , tech_Laser , tech_MatDet , tech_PartInvis , tech_RemCharge ] ;
24286: LD_ADDR_LOC 35
24290: PUSH
24291: LD_INT 6
24293: PUSH
24294: LD_INT 12
24296: PUSH
24297: LD_INT 15
24299: PUSH
24300: LD_INT 10
24302: PUSH
24303: LD_INT 7
24305: PUSH
24306: LD_INT 16
24308: PUSH
24309: LD_INT 18
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: ST_TO_ADDR
// bio_list := [ tech_ApeNeural , tech_ApeBrain , tech_StimDrugs , tech_BioDet ] ;
24321: LD_ADDR_LOC 36
24325: PUSH
24326: LD_INT 3
24328: PUSH
24329: LD_INT 4
24331: PUSH
24332: LD_INT 5
24334: PUSH
24335: LD_INT 8
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: ST_TO_ADDR
// space_list := [ tech_TauField , tech_Lapser , tech_LimTeleport , tech_TauRad , tech_SpacAnom ] ;
24344: LD_ADDR_LOC 37
24348: PUSH
24349: LD_INT 30
24351: PUSH
24352: LD_INT 31
24354: PUSH
24355: LD_INT 37
24357: PUSH
24358: LD_INT 28
24360: PUSH
24361: LD_INT 29
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: ST_TO_ADDR
// basic_tech := [ tech_list , weap_list , sib_list , comp_list , bio_list , space_list , opto_list ] ;
24371: LD_ADDR_LOC 45
24375: PUSH
24376: LD_LOC 31
24380: PUSH
24381: LD_LOC 32
24385: PUSH
24386: LD_LOC 33
24390: PUSH
24391: LD_LOC 34
24395: PUSH
24396: LD_LOC 36
24400: PUSH
24401: LD_LOC 37
24405: PUSH
24406: LD_LOC 35
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: LIST
24415: LIST
24416: LIST
24417: LIST
24418: LIST
24419: ST_TO_ADDR
// utech_basic := [ tech_Tech1 , tech_Tech2 , tech_Tech3 ] ;
24420: LD_ADDR_LOC 38
24424: PUSH
24425: LD_INT 48
24427: PUSH
24428: LD_INT 49
24430: PUSH
24431: LD_INT 50
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: LIST
24438: ST_TO_ADDR
// utech_weap := [ tech_Weap1 , tech_Weap2 , tech_Weap3 ] ;
24439: LD_ADDR_LOC 39
24443: PUSH
24444: LD_INT 51
24446: PUSH
24447: LD_INT 52
24449: PUSH
24450: LD_INT 53
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: LIST
24457: ST_TO_ADDR
// utech_sib := [ tech_Sib1 , tech_Sib2 , tech_Sib3 ] ;
24458: LD_ADDR_LOC 40
24462: PUSH
24463: LD_INT 54
24465: PUSH
24466: LD_INT 55
24468: PUSH
24469: LD_INT 56
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: LIST
24476: ST_TO_ADDR
// utech_comp := [ tech_Comp1 , tech_Comp2 , tech_Comp3 ] ;
24477: LD_ADDR_LOC 41
24481: PUSH
24482: LD_INT 57
24484: PUSH
24485: LD_INT 58
24487: PUSH
24488: LD_INT 59
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: LIST
24495: ST_TO_ADDR
// utech_bio := [ tech_Bio1 , tech_Bio2 , tech_Bio3 ] ;
24496: LD_ADDR_LOC 42
24500: PUSH
24501: LD_INT 66
24503: PUSH
24504: LD_INT 67
24506: PUSH
24507: LD_INT 68
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: LIST
24514: ST_TO_ADDR
// utech_space := [ tech_ST1 , tech_ST2 , tech_ST3 ] ;
24515: LD_ADDR_LOC 43
24519: PUSH
24520: LD_INT 63
24522: PUSH
24523: LD_INT 64
24525: PUSH
24526: LD_INT 65
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: LIST
24533: ST_TO_ADDR
// utech_opto := [ tech_Opto1 , tech_Opto2 , tech_Opto3 ] ;
24534: LD_ADDR_LOC 44
24538: PUSH
24539: LD_INT 60
24541: PUSH
24542: LD_INT 61
24544: PUSH
24545: LD_INT 62
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: LIST
24552: ST_TO_ADDR
// end ;
24553: LD_VAR 0 1
24557: RET
// function init_upgrade_by_nations ( side_nation ) ; begin
24558: LD_INT 0
24560: PPUSH
// first_technology := [ tech_SolPow , tech_OilPow , tech_OilEng , tech_SibDet , tech_SibPow , tech_AI , tech_AdvAI ] ;
24561: LD_ADDR_LOC 47
24565: PUSH
24566: LD_INT 35
24568: PUSH
24569: LD_INT 46
24571: PUSH
24572: LD_INT 47
24574: PUSH
24575: LD_INT 20
24577: PUSH
24578: LD_INT 21
24580: PUSH
24581: LD_INT 32
24583: PUSH
24584: LD_INT 27
24586: PUSH
24587: EMPTY
24588: LIST
24589: LIST
24590: LIST
24591: LIST
24592: LIST
24593: LIST
24594: LIST
24595: ST_TO_ADDR
// last_technology := [ tech_ApeBrain , tech_Flame , tech_Soporific , tech_SibFiss ] ;
24596: LD_ADDR_LOC 48
24600: PUSH
24601: LD_INT 4
24603: PUSH
24604: LD_INT 70
24606: PUSH
24607: LD_INT 13
24609: PUSH
24610: LD_INT 25
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: LIST
24617: LIST
24618: ST_TO_ADDR
// recomended_technology := [ tech_Gun , tech_Tech1 , tech_Comp1 , tech_Tech2 , tech_Comp2 , tech_Tech3 , tech_Comp3 ] ;
24619: LD_ADDR_LOC 49
24623: PUSH
24624: LD_INT 39
24626: PUSH
24627: LD_INT 48
24629: PUSH
24630: LD_INT 57
24632: PUSH
24633: LD_INT 49
24635: PUSH
24636: LD_INT 58
24638: PUSH
24639: LD_INT 50
24641: PUSH
24642: LD_INT 59
24644: PUSH
24645: EMPTY
24646: LIST
24647: LIST
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: ST_TO_ADDR
// case side_nation of 1 :
24654: LD_VAR 0 1
24658: PUSH
24659: LD_INT 1
24661: DOUBLE
24662: EQUAL
24663: IFTRUE 24667
24665: GO 24707
24667: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_opto ] ; 2 :
24668: LD_ADDR_LOC 46
24672: PUSH
24673: LD_LOC 38
24677: PUSH
24678: LD_LOC 39
24682: PUSH
24683: LD_LOC 40
24687: PUSH
24688: LD_LOC 41
24692: PUSH
24693: LD_LOC 44
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: LIST
24702: LIST
24703: LIST
24704: ST_TO_ADDR
24705: GO 24804
24707: LD_INT 2
24709: DOUBLE
24710: EQUAL
24711: IFTRUE 24715
24713: GO 24755
24715: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_bio , utech_opto ] ; 3 :
24716: LD_ADDR_LOC 46
24720: PUSH
24721: LD_LOC 38
24725: PUSH
24726: LD_LOC 39
24730: PUSH
24731: LD_LOC 40
24735: PUSH
24736: LD_LOC 42
24740: PUSH
24741: LD_LOC 44
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: LIST
24750: LIST
24751: LIST
24752: ST_TO_ADDR
24753: GO 24804
24755: LD_INT 3
24757: DOUBLE
24758: EQUAL
24759: IFTRUE 24763
24761: GO 24803
24763: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_space ] ; end ;
24764: LD_ADDR_LOC 46
24768: PUSH
24769: LD_LOC 38
24773: PUSH
24774: LD_LOC 39
24778: PUSH
24779: LD_LOC 40
24783: PUSH
24784: LD_LOC 41
24788: PUSH
24789: LD_LOC 43
24793: PUSH
24794: EMPTY
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: LIST
24800: ST_TO_ADDR
24801: GO 24804
24803: POP
// end ;
24804: LD_VAR 0 2
24808: RET
// every 0 0$5.5 do var un , active_side , active_nation , lab_list , still_researching ;
24809: GO 24811
24811: DISABLE
24812: LD_INT 0
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
// begin for active_side in cpu_list do
24819: LD_ADDR_VAR 0 2
24823: PUSH
24824: LD_EXP 8
24828: PUSH
24829: FOR_IN
24830: IFFALSE 24939
// begin still_researching := false ;
24832: LD_ADDR_VAR 0 5
24836: PUSH
24837: LD_INT 0
24839: ST_TO_ADDR
// lab_list := get_labs ( active_side ) ;
24840: LD_ADDR_VAR 0 4
24844: PUSH
24845: LD_VAR 0 2
24849: PPUSH
24850: CALL 25026 0 1
24854: ST_TO_ADDR
// for un in lab_list do
24855: LD_ADDR_VAR 0 1
24859: PUSH
24860: LD_VAR 0 4
24864: PUSH
24865: FOR_IN
24866: IFFALSE 24893
// if BuildingStatus ( un ) = bs_working then
24868: LD_VAR 0 1
24872: PPUSH
24873: CALL_OW 461
24877: PUSH
24878: LD_INT 3
24880: EQUAL
24881: IFFALSE 24891
// still_researching := true ;
24883: LD_ADDR_VAR 0 5
24887: PUSH
24888: LD_INT 1
24890: ST_TO_ADDR
24891: GO 24865
24893: POP
24894: POP
// active_nation := GetCPUNation ( active_side ) ;
24895: LD_ADDR_VAR 0 3
24899: PUSH
24900: LD_VAR 0 2
24904: PPUSH
24905: CALL 26627 0 1
24909: ST_TO_ADDR
// if ( not still_researching ) and active_nation then
24910: LD_VAR 0 5
24914: NOT
24915: PUSH
24916: LD_VAR 0 3
24920: AND
24921: IFFALSE 24937
// start_new_research ( active_side , active_nation ) ;
24923: LD_VAR 0 2
24927: PPUSH
24928: LD_VAR 0 3
24932: PPUSH
24933: CALL 25099 0 2
// end ;
24937: GO 24829
24939: POP
24940: POP
// if ( cpu_list ) and ( not all_cpu_invented ) then
24941: LD_EXP 8
24945: PUSH
24946: CALL 24958 0 0
24950: NOT
24951: AND
24952: IFFALSE 24955
// enable ;
24954: ENABLE
// end ;
24955: PPOPN 5
24957: END
// function all_cpu_invented ; var un , vysledek ; begin
24958: LD_INT 0
24960: PPUSH
24961: PPUSH
24962: PPUSH
// vysledek := true ;
24963: LD_ADDR_VAR 0 3
24967: PUSH
24968: LD_INT 1
24970: ST_TO_ADDR
// for un in cpu_list do
24971: LD_ADDR_VAR 0 2
24975: PUSH
24976: LD_EXP 8
24980: PUSH
24981: FOR_IN
24982: IFFALSE 25009
// if not all_invented [ un ] then
24984: LD_LOC 50
24988: PUSH
24989: LD_VAR 0 2
24993: ARRAY
24994: NOT
24995: IFFALSE 25007
// begin vysledek := false ;
24997: LD_ADDR_VAR 0 3
25001: PUSH
25002: LD_INT 0
25004: ST_TO_ADDR
// break ;
25005: GO 25009
// end ;
25007: GO 24981
25009: POP
25010: POP
// result := vysledek ;
25011: LD_ADDR_VAR 0 1
25015: PUSH
25016: LD_VAR 0 3
25020: ST_TO_ADDR
// end ;
25021: LD_VAR 0 1
25025: RET
// function get_labs ( side ) ; var lab_list ; begin
25026: LD_INT 0
25028: PPUSH
25029: PPUSH
// lab_list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
25030: LD_ADDR_VAR 0 3
25034: PUSH
25035: LD_INT 22
25037: PUSH
25038: LD_VAR 0 1
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: PUSH
25047: LD_INT 2
25049: PUSH
25050: LD_INT 30
25052: PUSH
25053: LD_INT 8
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 30
25062: PUSH
25063: LD_INT 6
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: LIST
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PPUSH
25079: CALL_OW 69
25083: ST_TO_ADDR
// result := lab_list ;
25084: LD_ADDR_VAR 0 2
25088: PUSH
25089: LD_VAR 0 3
25093: ST_TO_ADDR
// end ;
25094: LD_VAR 0 2
25098: RET
// function start_new_research ( side , nation ) ; var lab_list , possible , to_research , lab , scientistic ; begin
25099: LD_INT 0
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
// scientistic := request_people ( side , class_scientistic , 1 ) ;
25107: LD_ADDR_VAR 0 8
25111: PUSH
25112: LD_VAR 0 1
25116: PPUSH
25117: LD_INT 4
25119: PPUSH
25120: LD_INT 1
25122: PPUSH
25123: CALL 26559 0 3
25127: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25128: LD_ADDR_VAR 0 4
25132: PUSH
25133: LD_VAR 0 1
25137: PPUSH
25138: CALL 25026 0 1
25142: ST_TO_ADDR
// init_upgrade_by_nations ( nation ) ;
25143: LD_VAR 0 2
25147: PPUSH
25148: CALL 24558 0 1
// possible := get_possible_research ( side ) ;
25152: LD_ADDR_VAR 0 5
25156: PUSH
25157: LD_VAR 0 1
25161: PPUSH
25162: CALL 25246 0 1
25166: ST_TO_ADDR
// to_research := select_next_technology ( side , possible ) ;
25167: LD_ADDR_VAR 0 6
25171: PUSH
25172: LD_VAR 0 1
25176: PPUSH
25177: LD_VAR 0 5
25181: PPUSH
25182: CALL 25697 0 2
25186: ST_TO_ADDR
// lab := research_possible ( side , to_research ) ;
25187: LD_ADDR_VAR 0 7
25191: PUSH
25192: LD_VAR 0 1
25196: PPUSH
25197: LD_VAR 0 6
25201: PPUSH
25202: CALL 26256 0 2
25206: ST_TO_ADDR
// if lab then
25207: LD_VAR 0 7
25211: IFFALSE 25241
// begin transfer_scientistic ( scientistic , lab ) ;
25213: LD_VAR 0 8
25217: PPUSH
25218: LD_VAR 0 7
25222: PPUSH
25223: CALL 26377 0 2
// begin_of_research ( lab , to_research ) ;
25227: LD_VAR 0 7
25231: PPUSH
25232: LD_VAR 0 6
25236: PPUSH
25237: CALL 26485 0 2
// end ; end ;
25241: LD_VAR 0 3
25245: RET
// function get_possible_research ( side ) ; var un , vysledek , lab_list , upgrade ; begin
25246: LD_INT 0
25248: PPUSH
25249: PPUSH
25250: PPUSH
25251: PPUSH
25252: PPUSH
// vysledek := [ ] ;
25253: LD_ADDR_VAR 0 4
25257: PUSH
25258: EMPTY
25259: ST_TO_ADDR
// upgrade := [ ] ;
25260: LD_ADDR_VAR 0 6
25264: PUSH
25265: EMPTY
25266: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25267: LD_ADDR_VAR 0 5
25271: PUSH
25272: LD_VAR 0 1
25276: PPUSH
25277: CALL 25026 0 1
25281: ST_TO_ADDR
// for un in lab_list do
25282: LD_ADDR_VAR 0 3
25286: PUSH
25287: LD_VAR 0 5
25291: PUSH
25292: FOR_IN
25293: IFFALSE 25335
// upgrade := upgrade ^ GetLabKind ( un , 1 ) ^ GetLabKind ( un , 2 ) ;
25295: LD_ADDR_VAR 0 6
25299: PUSH
25300: LD_VAR 0 6
25304: PUSH
25305: LD_VAR 0 3
25309: PPUSH
25310: LD_INT 1
25312: PPUSH
25313: CALL_OW 268
25317: ADD
25318: PUSH
25319: LD_VAR 0 3
25323: PPUSH
25324: LD_INT 2
25326: PPUSH
25327: CALL_OW 268
25331: ADD
25332: ST_TO_ADDR
25333: GO 25292
25335: POP
25336: POP
// for un in upgrade do
25337: LD_ADDR_VAR 0 3
25341: PUSH
25342: LD_VAR 0 6
25346: PUSH
25347: FOR_IN
25348: IFFALSE 25372
// vysledek := vysledek ^ ( un - 8 ) ;
25350: LD_ADDR_VAR 0 4
25354: PUSH
25355: LD_VAR 0 4
25359: PUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 8
25367: MINUS
25368: ADD
25369: ST_TO_ADDR
25370: GO 25347
25372: POP
25373: POP
// result := vysledek ;
25374: LD_ADDR_VAR 0 2
25378: PUSH
25379: LD_VAR 0 4
25383: ST_TO_ADDR
// end ;
25384: LD_VAR 0 2
25388: RET
// function shake_it_baby ( list ) ; var vysledek , pom , i , n ; begin
25389: LD_INT 0
25391: PPUSH
25392: PPUSH
25393: PPUSH
25394: PPUSH
25395: PPUSH
// vysledek := [ ] ;
25396: LD_ADDR_VAR 0 3
25400: PUSH
25401: EMPTY
25402: ST_TO_ADDR
// for i = 1 to list do
25403: LD_ADDR_VAR 0 5
25407: PUSH
25408: DOUBLE
25409: LD_INT 1
25411: DEC
25412: ST_TO_ADDR
25413: LD_VAR 0 1
25417: PUSH
25418: FOR_TO
25419: IFFALSE 25493
// begin n := Rand ( 1 , list ) ;
25421: LD_ADDR_VAR 0 6
25425: PUSH
25426: LD_INT 1
25428: PPUSH
25429: LD_VAR 0 1
25433: PPUSH
25434: CALL_OW 12
25438: ST_TO_ADDR
// pom := list [ n ] ;
25439: LD_ADDR_VAR 0 4
25443: PUSH
25444: LD_VAR 0 1
25448: PUSH
25449: LD_VAR 0 6
25453: ARRAY
25454: ST_TO_ADDR
// list := Delete ( list , n ) ;
25455: LD_ADDR_VAR 0 1
25459: PUSH
25460: LD_VAR 0 1
25464: PPUSH
25465: LD_VAR 0 6
25469: PPUSH
25470: CALL_OW 3
25474: ST_TO_ADDR
// vysledek := vysledek ^ pom ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_VAR 0 3
25484: PUSH
25485: LD_VAR 0 4
25489: ADD
25490: ST_TO_ADDR
// end ;
25491: GO 25418
25493: POP
25494: POP
// result := vysledek ;
25495: LD_ADDR_VAR 0 2
25499: PUSH
25500: LD_VAR 0 3
25504: ST_TO_ADDR
// end ;
25505: LD_VAR 0 2
25509: RET
// function GetBasicTechnology ; var list , un , vysledek ; begin
25510: LD_INT 0
25512: PPUSH
25513: PPUSH
25514: PPUSH
25515: PPUSH
// list := [ ] ;
25516: LD_ADDR_VAR 0 2
25520: PUSH
25521: EMPTY
25522: ST_TO_ADDR
// for un in basic_tech do
25523: LD_ADDR_VAR 0 3
25527: PUSH
25528: LD_LOC 45
25532: PUSH
25533: FOR_IN
25534: IFFALSE 25563
// if un then
25536: LD_VAR 0 3
25540: IFFALSE 25561
// list := list ^ [ un ] ;
25542: LD_ADDR_VAR 0 2
25546: PUSH
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 3
25556: PUSH
25557: EMPTY
25558: LIST
25559: ADD
25560: ST_TO_ADDR
25561: GO 25533
25563: POP
25564: POP
// if list > 1 then
25565: LD_VAR 0 2
25569: PUSH
25570: LD_INT 1
25572: GREATER
25573: IFFALSE 25590
// vysledek := shake_it_baby ( list ) ;
25575: LD_ADDR_VAR 0 4
25579: PUSH
25580: LD_VAR 0 2
25584: PPUSH
25585: CALL 25389 0 1
25589: ST_TO_ADDR
// result := vysledek ;
25590: LD_ADDR_VAR 0 1
25594: PUSH
25595: LD_VAR 0 4
25599: ST_TO_ADDR
// end ;
25600: LD_VAR 0 1
25604: RET
// function GetUpgradeTechnology ; var list , un , vysledek ; begin
25605: LD_INT 0
25607: PPUSH
25608: PPUSH
25609: PPUSH
25610: PPUSH
// vysledek := [ ] ;
25611: LD_ADDR_VAR 0 4
25615: PUSH
25616: EMPTY
25617: ST_TO_ADDR
// list := [ ] ;
25618: LD_ADDR_VAR 0 2
25622: PUSH
25623: EMPTY
25624: ST_TO_ADDR
// for un in upgrade_tech do
25625: LD_ADDR_VAR 0 3
25629: PUSH
25630: LD_LOC 46
25634: PUSH
25635: FOR_IN
25636: IFFALSE 25665
// if un then
25638: LD_VAR 0 3
25642: IFFALSE 25663
// list := list ^ [ un ] ;
25644: LD_ADDR_VAR 0 2
25648: PUSH
25649: LD_VAR 0 2
25653: PUSH
25654: LD_VAR 0 3
25658: PUSH
25659: EMPTY
25660: LIST
25661: ADD
25662: ST_TO_ADDR
25663: GO 25635
25665: POP
25666: POP
// vysledek := shake_it_baby ( list ) ;
25667: LD_ADDR_VAR 0 4
25671: PUSH
25672: LD_VAR 0 2
25676: PPUSH
25677: CALL 25389 0 1
25681: ST_TO_ADDR
// result := vysledek ;
25682: LD_ADDR_VAR 0 1
25686: PUSH
25687: LD_VAR 0 4
25691: ST_TO_ADDR
// end ;
25692: LD_VAR 0 1
25696: RET
// function select_next_technology ( side , possible ) ; var un , pom , new , vysledek , select ; begin
25697: LD_INT 0
25699: PPUSH
25700: PPUSH
25701: PPUSH
25702: PPUSH
25703: PPUSH
25704: PPUSH
// new := true ;
25705: LD_ADDR_VAR 0 6
25709: PUSH
25710: LD_INT 1
25712: ST_TO_ADDR
// vysledek := [ ] ;
25713: LD_ADDR_VAR 0 7
25717: PUSH
25718: EMPTY
25719: ST_TO_ADDR
// select := [ ] ;
25720: LD_ADDR_VAR 0 8
25724: PUSH
25725: EMPTY
25726: ST_TO_ADDR
// for un in first_technology do
25727: LD_ADDR_VAR 0 4
25731: PUSH
25732: LD_LOC 47
25736: PUSH
25737: FOR_IN
25738: IFFALSE 25780
// begin pom := research_possible ( side , un ) ;
25740: LD_ADDR_VAR 0 5
25744: PUSH
25745: LD_VAR 0 1
25749: PPUSH
25750: LD_VAR 0 4
25754: PPUSH
25755: CALL 26256 0 2
25759: ST_TO_ADDR
// if pom then
25760: LD_VAR 0 5
25764: IFFALSE 25778
// begin vysledek := un ;
25766: LD_ADDR_VAR 0 7
25770: PUSH
25771: LD_VAR 0 4
25775: ST_TO_ADDR
// break ;
25776: GO 25780
// end ; end ;
25778: GO 25737
25780: POP
25781: POP
// if not first_technology then
25782: LD_LOC 47
25786: NOT
25787: IFFALSE 25797
// new := false ;
25789: LD_ADDR_VAR 0 6
25793: PUSH
25794: LD_INT 0
25796: ST_TO_ADDR
// if not vysledek and ( Rand ( 0 , 10 ) < 3 ) then
25797: LD_VAR 0 7
25801: NOT
25802: PUSH
25803: LD_INT 0
25805: PPUSH
25806: LD_INT 10
25808: PPUSH
25809: CALL_OW 12
25813: PUSH
25814: LD_INT 3
25816: LESS
25817: AND
25818: IFFALSE 25875
// for un in recomended_technology do
25820: LD_ADDR_VAR 0 4
25824: PUSH
25825: LD_LOC 49
25829: PUSH
25830: FOR_IN
25831: IFFALSE 25873
// begin pom := research_possible ( side , un ) ;
25833: LD_ADDR_VAR 0 5
25837: PUSH
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_VAR 0 4
25847: PPUSH
25848: CALL 26256 0 2
25852: ST_TO_ADDR
// if pom then
25853: LD_VAR 0 5
25857: IFFALSE 25871
// begin vysledek := un ;
25859: LD_ADDR_VAR 0 7
25863: PUSH
25864: LD_VAR 0 4
25868: ST_TO_ADDR
// break ;
25869: GO 25873
// end ; end ;
25871: GO 25830
25873: POP
25874: POP
// if not recomended_technology then
25875: LD_LOC 49
25879: NOT
25880: IFFALSE 25890
// new := false ;
25882: LD_ADDR_VAR 0 6
25886: PUSH
25887: LD_INT 0
25889: ST_TO_ADDR
// if not vysledek then
25890: LD_VAR 0 7
25894: NOT
25895: IFFALSE 25982
// begin select := GetBasicTechnology ;
25897: LD_ADDR_VAR 0 8
25901: PUSH
25902: CALL 25510 0 0
25906: ST_TO_ADDR
// for un in select do
25907: LD_ADDR_VAR 0 4
25911: PUSH
25912: LD_VAR 0 8
25916: PUSH
25917: FOR_IN
25918: IFFALSE 25980
// begin pom := [ ] ;
25920: LD_ADDR_VAR 0 5
25924: PUSH
25925: EMPTY
25926: ST_TO_ADDR
// if not un in last_technology then
25927: LD_VAR 0 4
25931: PUSH
25932: LD_LOC 48
25936: IN
25937: NOT
25938: IFFALSE 25960
// pom := research_possible ( side , un ) ;
25940: LD_ADDR_VAR 0 5
25944: PUSH
25945: LD_VAR 0 1
25949: PPUSH
25950: LD_VAR 0 4
25954: PPUSH
25955: CALL 26256 0 2
25959: ST_TO_ADDR
// if pom then
25960: LD_VAR 0 5
25964: IFFALSE 25978
// begin vysledek := un ;
25966: LD_ADDR_VAR 0 7
25970: PUSH
25971: LD_VAR 0 4
25975: ST_TO_ADDR
// break ;
25976: GO 25980
// end ; end ;
25978: GO 25917
25980: POP
25981: POP
// end ; if not select then
25982: LD_VAR 0 8
25986: NOT
25987: IFFALSE 25997
// new := false ;
25989: LD_ADDR_VAR 0 6
25993: PUSH
25994: LD_INT 0
25996: ST_TO_ADDR
// if not vysledek then
25997: LD_VAR 0 7
26001: NOT
26002: IFFALSE 26089
// begin select := GetUpgradeTechnology ;
26004: LD_ADDR_VAR 0 8
26008: PUSH
26009: CALL 25605 0 0
26013: ST_TO_ADDR
// for un in select do
26014: LD_ADDR_VAR 0 4
26018: PUSH
26019: LD_VAR 0 8
26023: PUSH
26024: FOR_IN
26025: IFFALSE 26087
// begin pom := [ ] ;
26027: LD_ADDR_VAR 0 5
26031: PUSH
26032: EMPTY
26033: ST_TO_ADDR
// if not un in last_technology then
26034: LD_VAR 0 4
26038: PUSH
26039: LD_LOC 48
26043: IN
26044: NOT
26045: IFFALSE 26067
// pom := research_possible ( side , un ) ;
26047: LD_ADDR_VAR 0 5
26051: PUSH
26052: LD_VAR 0 1
26056: PPUSH
26057: LD_VAR 0 4
26061: PPUSH
26062: CALL 26256 0 2
26066: ST_TO_ADDR
// if pom then
26067: LD_VAR 0 5
26071: IFFALSE 26085
// begin vysledek := un ;
26073: LD_ADDR_VAR 0 7
26077: PUSH
26078: LD_VAR 0 4
26082: ST_TO_ADDR
// break ;
26083: GO 26087
// end ; end ;
26085: GO 26024
26087: POP
26088: POP
// end ; if not select then
26089: LD_VAR 0 8
26093: NOT
26094: IFFALSE 26104
// new := false ;
26096: LD_ADDR_VAR 0 6
26100: PUSH
26101: LD_INT 0
26103: ST_TO_ADDR
// if not vysledek then
26104: LD_VAR 0 7
26108: NOT
26109: IFFALSE 26166
// for un in last_technology do
26111: LD_ADDR_VAR 0 4
26115: PUSH
26116: LD_LOC 48
26120: PUSH
26121: FOR_IN
26122: IFFALSE 26164
// begin pom := research_possible ( side , un ) ;
26124: LD_ADDR_VAR 0 5
26128: PUSH
26129: LD_VAR 0 1
26133: PPUSH
26134: LD_VAR 0 4
26138: PPUSH
26139: CALL 26256 0 2
26143: ST_TO_ADDR
// if pom then
26144: LD_VAR 0 5
26148: IFFALSE 26162
// begin vysledek := un ;
26150: LD_ADDR_VAR 0 7
26154: PUSH
26155: LD_VAR 0 4
26159: ST_TO_ADDR
// break ;
26160: GO 26164
// end ; end ;
26162: GO 26121
26164: POP
26165: POP
// if not last_technology then
26166: LD_LOC 48
26170: NOT
26171: IFFALSE 26181
// new := false ;
26173: LD_ADDR_VAR 0 6
26177: PUSH
26178: LD_INT 0
26180: ST_TO_ADDR
// if not ( vysledek or new ) then
26181: LD_VAR 0 7
26185: PUSH
26186: LD_VAR 0 6
26190: OR
26191: NOT
26192: IFFALSE 26241
// begin all_invented := Insert ( all_invented , side , true ) ;
26194: LD_ADDR_LOC 50
26198: PUSH
26199: LD_LOC 50
26203: PPUSH
26204: LD_VAR 0 1
26208: PPUSH
26209: LD_INT 1
26211: PPUSH
26212: CALL_OW 2
26216: ST_TO_ADDR
// all_invented := Delete ( all_invented , side + 1 ) ;
26217: LD_ADDR_LOC 50
26221: PUSH
26222: LD_LOC 50
26226: PPUSH
26227: LD_VAR 0 1
26231: PUSH
26232: LD_INT 1
26234: PLUS
26235: PPUSH
26236: CALL_OW 3
26240: ST_TO_ADDR
// end ; result := vysledek ;
26241: LD_ADDR_VAR 0 3
26245: PUSH
26246: LD_VAR 0 7
26250: ST_TO_ADDR
// end ;
26251: LD_VAR 0 3
26255: RET
// function research_possible ( side , tech ) ; var un , vysledek , lab_list ; begin
26256: LD_INT 0
26258: PPUSH
26259: PPUSH
26260: PPUSH
26261: PPUSH
// lab_list := get_labs ( side ) ;
26262: LD_ADDR_VAR 0 6
26266: PUSH
26267: LD_VAR 0 1
26271: PPUSH
26272: CALL 25026 0 1
26276: ST_TO_ADDR
// if GetTech ( tech , side ) in [ state_disabled , state_researched ] then
26277: LD_VAR 0 2
26281: PPUSH
26282: LD_VAR 0 1
26286: PPUSH
26287: CALL_OW 321
26291: PUSH
26292: LD_INT 0
26294: PUSH
26295: LD_INT 2
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: IN
26302: IFFALSE 26313
// vysledek := [ ] else
26304: LD_ADDR_VAR 0 5
26308: PUSH
26309: EMPTY
26310: ST_TO_ADDR
26311: GO 26362
// for un in lab_list do
26313: LD_ADDR_VAR 0 4
26317: PUSH
26318: LD_VAR 0 6
26322: PUSH
26323: FOR_IN
26324: IFFALSE 26360
// if CanBeResearched ( un , tech ) then
26326: LD_VAR 0 4
26330: PPUSH
26331: LD_VAR 0 2
26335: PPUSH
26336: CALL_OW 430
26340: IFFALSE 26358
// vysledek := vysledek ^ un ;
26342: LD_ADDR_VAR 0 5
26346: PUSH
26347: LD_VAR 0 5
26351: PUSH
26352: LD_VAR 0 4
26356: ADD
26357: ST_TO_ADDR
26358: GO 26323
26360: POP
26361: POP
// result := vysledek ;
26362: LD_ADDR_VAR 0 3
26366: PUSH
26367: LD_VAR 0 5
26371: ST_TO_ADDR
// end ;
26372: LD_VAR 0 3
26376: RET
// function transfer_scientistic ( scients , to_lab ) ; var un , i ; begin
26377: LD_INT 0
26379: PPUSH
26380: PPUSH
26381: PPUSH
// i = 1 ;
26382: LD_ADDR_VAR 0 5
26386: PUSH
26387: LD_INT 1
26389: ST_TO_ADDR
// to_lab := to_lab diff [ 0 ] ;
26390: LD_ADDR_VAR 0 2
26394: PUSH
26395: LD_VAR 0 2
26399: PUSH
26400: LD_INT 0
26402: PUSH
26403: EMPTY
26404: LIST
26405: DIFF
26406: ST_TO_ADDR
// for un in scients do
26407: LD_ADDR_VAR 0 4
26411: PUSH
26412: LD_VAR 0 1
26416: PUSH
26417: FOR_IN
26418: IFFALSE 26466
// begin ComEnterUnit ( un , to_lab [ ( i mod to_lab ) + 1 ] ) ;
26420: LD_VAR 0 4
26424: PPUSH
26425: LD_VAR 0 2
26429: PUSH
26430: LD_VAR 0 5
26434: PUSH
26435: LD_VAR 0 2
26439: MOD
26440: PUSH
26441: LD_INT 1
26443: PLUS
26444: ARRAY
26445: PPUSH
26446: CALL_OW 120
// i := i + 1 ;
26450: LD_ADDR_VAR 0 5
26454: PUSH
26455: LD_VAR 0 5
26459: PUSH
26460: LD_INT 1
26462: PLUS
26463: ST_TO_ADDR
// end ;
26464: GO 26417
26466: POP
26467: POP
// AddComChangeProfession ( scients , class_scientistic ) ;
26468: LD_VAR 0 1
26472: PPUSH
26473: LD_INT 4
26475: PPUSH
26476: CALL_OW 183
// end ;
26480: LD_VAR 0 3
26484: RET
// function begin_of_research ( lab , to_research ) ; begin
26485: LD_INT 0
26487: PPUSH
// ComResearch ( lab , to_research ) ;
26488: LD_VAR 0 1
26492: PPUSH
26493: LD_VAR 0 2
26497: PPUSH
26498: CALL_OW 124
// end ; end_of_file
26502: LD_VAR 0 3
26506: RET
// export reserved_people ; var vysledek ; export function init_distribution ; var un ; begin
26507: LD_INT 0
26509: PPUSH
26510: PPUSH
// reserved_people := [ ] ;
26511: LD_ADDR_EXP 72
26515: PUSH
26516: EMPTY
26517: ST_TO_ADDR
// for un = 1 to 8 do
26518: LD_ADDR_VAR 0 2
26522: PUSH
26523: DOUBLE
26524: LD_INT 1
26526: DEC
26527: ST_TO_ADDR
26528: LD_INT 8
26530: PUSH
26531: FOR_TO
26532: IFFALSE 26552
// reserved_people := reserved_people ^ [ [ ] ] ;
26534: LD_ADDR_EXP 72
26538: PUSH
26539: LD_EXP 72
26543: PUSH
26544: EMPTY
26545: PUSH
26546: EMPTY
26547: LIST
26548: ADD
26549: ST_TO_ADDR
26550: GO 26531
26552: POP
26553: POP
// end ;
26554: LD_VAR 0 1
26558: RET
// export function request_people ( side , man_class , priority ) ; begin
26559: LD_INT 0
26561: PPUSH
// vysledek := FilterAllUnits ( [ [ f_side , side ] , [ f_class , man_class ] ] ) diff reserved_people [ side ] ;
26562: LD_ADDR_LOC 51
26566: PUSH
26567: LD_INT 22
26569: PUSH
26570: LD_VAR 0 1
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 25
26581: PUSH
26582: LD_VAR 0 2
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PPUSH
26595: CALL_OW 69
26599: PUSH
26600: LD_EXP 72
26604: PUSH
26605: LD_VAR 0 1
26609: ARRAY
26610: DIFF
26611: ST_TO_ADDR
// result := vysledek ;
26612: LD_ADDR_VAR 0 4
26616: PUSH
26617: LD_LOC 51
26621: ST_TO_ADDR
// end ;
26622: LD_VAR 0 4
26626: RET
// export function GetCPUNation ( side ) ; var un , vysledek ; begin
26627: LD_INT 0
26629: PPUSH
26630: PPUSH
26631: PPUSH
// un := FilterAllUnits ( [ [ f_side , side ] ] ) ;
26632: LD_ADDR_VAR 0 3
26636: PUSH
26637: LD_INT 22
26639: PUSH
26640: LD_VAR 0 1
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: EMPTY
26650: LIST
26651: PPUSH
26652: CALL_OW 69
26656: ST_TO_ADDR
// if un then
26657: LD_VAR 0 3
26661: IFFALSE 26684
// vysledek := GetSide ( un [ 1 ] ) else
26663: LD_ADDR_VAR 0 4
26667: PUSH
26668: LD_VAR 0 3
26672: PUSH
26673: LD_INT 1
26675: ARRAY
26676: PPUSH
26677: CALL_OW 255
26681: ST_TO_ADDR
26682: GO 26692
// vysledek := false ;
26684: LD_ADDR_VAR 0 4
26688: PUSH
26689: LD_INT 0
26691: ST_TO_ADDR
// result := vysledek ;
26692: LD_ADDR_VAR 0 2
26696: PUSH
26697: LD_VAR 0 4
26701: ST_TO_ADDR
// end ; end_of_file
26702: LD_VAR 0 2
26706: RET
// var us_weapons , ar_weapons , ru_weapons ; var sib_engine , oil_engine ; var prefered ; var main_extensions ; var hovers_recomended , flat_land ; export mechanics_wanted , extension_wanted ; function init_priority ( side , side_nation ) ; var us_main_control ; begin
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
// us_main_control := b_ext_computer ;
26711: LD_ADDR_VAR 0 4
26715: PUSH
26716: LD_INT 24
26718: ST_TO_ADDR
// prefered_control := control_computer ;
26719: LD_ADDR_EXP 60
26723: PUSH
26724: LD_INT 3
26726: ST_TO_ADDR
// case side_nation of 1 :
26727: LD_VAR 0 2
26731: PUSH
26732: LD_INT 1
26734: DOUBLE
26735: EQUAL
26736: IFTRUE 26740
26738: GO 26772
26740: POP
// main_extensions := [ b_ext_track , b_ext_siberium , b_ext_laser , b_ext_rocket , us_main_control ] ; 2 :
26741: LD_ADDR_LOC 58
26745: PUSH
26746: LD_INT 16
26748: PUSH
26749: LD_INT 21
26751: PUSH
26752: LD_INT 25
26754: PUSH
26755: LD_INT 18
26757: PUSH
26758: LD_VAR 0 4
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: ST_TO_ADDR
26770: GO 26849
26772: LD_INT 2
26774: DOUBLE
26775: EQUAL
26776: IFTRUE 26780
26778: GO 26810
26780: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar , b_ext_siberium ] ; 3 :
26781: LD_ADDR_LOC 58
26785: PUSH
26786: LD_INT 16
26788: PUSH
26789: LD_INT 17
26791: PUSH
26792: LD_INT 18
26794: PUSH
26795: LD_INT 20
26797: PUSH
26798: LD_INT 21
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: ST_TO_ADDR
26808: GO 26849
26810: LD_INT 3
26812: DOUBLE
26813: EQUAL
26814: IFTRUE 26818
26816: GO 26848
26818: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ; end ;
26819: LD_ADDR_LOC 58
26823: PUSH
26824: LD_INT 16
26826: PUSH
26827: LD_INT 17
26829: PUSH
26830: LD_INT 18
26832: PUSH
26833: LD_INT 24
26835: PUSH
26836: LD_INT 21
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: ST_TO_ADDR
26846: GO 26849
26848: POP
// end ;
26849: LD_VAR 0 3
26853: RET
// export function init_manufacture ; begin
26854: LD_INT 0
26856: PPUSH
// hovers_recomended := false ;
26857: LD_ADDR_LOC 59
26861: PUSH
26862: LD_INT 0
26864: ST_TO_ADDR
// flat_land := false ;
26865: LD_ADDR_LOC 60
26869: PUSH
26870: LD_INT 0
26872: ST_TO_ADDR
// sib_engine := 10 ;
26873: LD_ADDR_LOC 55
26877: PUSH
26878: LD_INT 10
26880: ST_TO_ADDR
// oil_engine := 30 ;
26881: LD_ADDR_LOC 56
26885: PUSH
26886: LD_INT 30
26888: ST_TO_ADDR
// us_weapons := [ [ [ us_machine_gun , [ ] , 0 ] , [ us_light_gun , [ tech_Gun ] , b_ext_gun ] , [ us_radar , [ tech_Radar ] , b_ext_radar ] , [ us_crane , [ ] , b_ext_noncombat ] ] , [ [ us_gatling_gun , [ tech_Gatling ] , 0 ] , [ us_double_gun , [ tech_Gun ] , b_ext_gun ] , [ us_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ us_laser , [ tech_Laser ] , b_ext_laser ] , [ us_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ us_bulldozer , [ ] , b_ext_noncombat ] , [ us_siberium_rocket , [ tech_SibEng , tech_Rocket ] , b_ext_siberium ] , [ us_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] ] ] ;
26889: LD_ADDR_LOC 52
26893: PUSH
26894: LD_INT 2
26896: PUSH
26897: EMPTY
26898: PUSH
26899: LD_INT 0
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 3
26909: PUSH
26910: LD_INT 39
26912: PUSH
26913: EMPTY
26914: LIST
26915: PUSH
26916: LD_INT 17
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 11
26926: PUSH
26927: LD_INT 6
26929: PUSH
26930: EMPTY
26931: LIST
26932: PUSH
26933: LD_INT 20
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 13
26943: PUSH
26944: EMPTY
26945: PUSH
26946: LD_INT 19
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: LIST
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 4
26962: PUSH
26963: LD_INT 69
26965: PUSH
26966: EMPTY
26967: LIST
26968: PUSH
26969: LD_INT 0
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: LIST
26976: PUSH
26977: LD_INT 5
26979: PUSH
26980: LD_INT 39
26982: PUSH
26983: EMPTY
26984: LIST
26985: PUSH
26986: LD_INT 17
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: LIST
26993: PUSH
26994: LD_INT 7
26996: PUSH
26997: LD_INT 40
26999: PUSH
27000: EMPTY
27001: LIST
27002: PUSH
27003: LD_INT 18
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: LIST
27010: PUSH
27011: LD_INT 9
27013: PUSH
27014: LD_INT 10
27016: PUSH
27017: EMPTY
27018: LIST
27019: PUSH
27020: LD_INT 25
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: LIST
27027: PUSH
27028: LD_INT 12
27030: PUSH
27031: EMPTY
27032: PUSH
27033: LD_INT 19
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: LIST
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: LIST
27046: LIST
27047: PUSH
27048: LD_INT 14
27050: PUSH
27051: EMPTY
27052: PUSH
27053: LD_INT 19
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: PUSH
27061: LD_INT 8
27063: PUSH
27064: LD_INT 22
27066: PUSH
27067: LD_INT 40
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 21
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 6
27084: PUSH
27085: LD_INT 34
27087: PUSH
27088: EMPTY
27089: LIST
27090: PUSH
27091: LD_INT 17
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: LIST
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: LIST
27103: PUSH
27104: EMPTY
27105: LIST
27106: LIST
27107: LIST
27108: ST_TO_ADDR
// ar_weapons := [ [ [ ar_multimissile_ballista , [ ] , 0 ] , [ ar_double_machine_gun , [ ] , 0 ] , [ ar_light_gun , [ tech_Gun ] , b_ext_gun ] ] , [ [ ar_gatling_gun , [ tech_Gatling ] , 0 ] , [ ar_flame_thrower , [ tech_Flame ] , b_ext_stitch ] , [ ar_gun , [ tech_Gun ] , b_ext_gun ] , [ ar_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ar_selfpropelled_bomb , [ tech_Explos ] , b_ext_siberium ] , [ ar_radar , [ tech_Radar ] , b_ext_radar ] , [ ar_control_tower , [ tech_RemCont ] , b_ext_radar ] , [ ar_cargo_bay , [ ] , b_ext_stitch ] ] , [ ] ] ;
27109: LD_ADDR_LOC 53
27113: PUSH
27114: LD_INT 22
27116: PUSH
27117: EMPTY
27118: PUSH
27119: LD_INT 0
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 24
27129: PUSH
27130: EMPTY
27131: PUSH
27132: LD_INT 0
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 23
27142: PUSH
27143: LD_INT 39
27145: PUSH
27146: EMPTY
27147: LIST
27148: PUSH
27149: LD_INT 17
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: LIST
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 25
27164: PUSH
27165: LD_INT 69
27167: PUSH
27168: EMPTY
27169: LIST
27170: PUSH
27171: LD_INT 0
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 26
27181: PUSH
27182: LD_INT 70
27184: PUSH
27185: EMPTY
27186: LIST
27187: PUSH
27188: LD_INT 23
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: LIST
27195: PUSH
27196: LD_INT 27
27198: PUSH
27199: LD_INT 39
27201: PUSH
27202: EMPTY
27203: LIST
27204: PUSH
27205: LD_INT 17
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: LIST
27212: PUSH
27213: LD_INT 28
27215: PUSH
27216: LD_INT 40
27218: PUSH
27219: EMPTY
27220: LIST
27221: PUSH
27222: LD_INT 18
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 29
27232: PUSH
27233: LD_INT 42
27235: PUSH
27236: EMPTY
27237: LIST
27238: PUSH
27239: LD_INT 21
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 30
27249: PUSH
27250: LD_INT 6
27252: PUSH
27253: EMPTY
27254: LIST
27255: PUSH
27256: LD_INT 20
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: PUSH
27264: LD_INT 31
27266: PUSH
27267: LD_INT 15
27269: PUSH
27270: EMPTY
27271: LIST
27272: PUSH
27273: LD_INT 20
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 32
27283: PUSH
27284: EMPTY
27285: PUSH
27286: LD_INT 23
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: LIST
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: PUSH
27304: EMPTY
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: LIST
27310: ST_TO_ADDR
// ru_weapons := [ [ ] , [ [ ru_heavy_machine_gun , [ ] , 0 ] , [ ru_gatling_gun , [ tech_Gatling ] , 0 ] , [ ru_gun , [ tech_Gun ] , b_ext_gun ] , [ ru_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ru_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ ru_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] , [ ru_rocket , [ tech_AdvRocket ] , b_ext_rocket ] , [ ru_siberium_rocket , [ tech_SibEng , tech_SibFiss ] , b_ext_siberium ] , [ ru_time_lapser , [ tech_Lapser ] , b_ext_siberium ] , [ ru_bulldozer , [ ] , b_ext_noncombat ] ] ] ;
27311: LD_ADDR_LOC 54
27315: PUSH
27316: EMPTY
27317: PUSH
27318: LD_INT 42
27320: PUSH
27321: EMPTY
27322: PUSH
27323: LD_INT 0
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: LIST
27330: PUSH
27331: LD_INT 43
27333: PUSH
27334: LD_INT 69
27336: PUSH
27337: EMPTY
27338: LIST
27339: PUSH
27340: LD_INT 0
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: LIST
27347: PUSH
27348: LD_INT 44
27350: PUSH
27351: LD_INT 39
27353: PUSH
27354: EMPTY
27355: LIST
27356: PUSH
27357: LD_INT 17
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: LIST
27364: PUSH
27365: LD_INT 45
27367: PUSH
27368: LD_INT 40
27370: PUSH
27371: EMPTY
27372: LIST
27373: PUSH
27374: LD_INT 18
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 51
27384: PUSH
27385: EMPTY
27386: PUSH
27387: LD_INT 19
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: LIST
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: PUSH
27402: LD_INT 46
27404: PUSH
27405: LD_INT 34
27407: PUSH
27408: EMPTY
27409: LIST
27410: PUSH
27411: LD_INT 17
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 47
27421: PUSH
27422: LD_INT 71
27424: PUSH
27425: EMPTY
27426: LIST
27427: PUSH
27428: LD_INT 18
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 48
27438: PUSH
27439: LD_INT 22
27441: PUSH
27442: LD_INT 25
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 21
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 49
27459: PUSH
27460: LD_INT 31
27462: PUSH
27463: EMPTY
27464: LIST
27465: PUSH
27466: LD_INT 21
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: LIST
27473: PUSH
27474: LD_INT 53
27476: PUSH
27477: EMPTY
27478: PUSH
27479: LD_INT 19
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: LIST
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: LIST
27491: LIST
27492: LIST
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: LIST
27498: ST_TO_ADDR
// end ;
27499: LD_VAR 0 1
27503: RET
// function init_prefered_vehicles ( side_nation ) ; begin
27504: LD_INT 0
27506: PPUSH
// case side_nation of 1 :
27507: LD_VAR 0 1
27511: PUSH
27512: LD_INT 1
27514: DOUBLE
27515: EQUAL
27516: IFTRUE 27520
27518: GO 27604
27520: POP
// prefered := [ [ [ us_medium_wheeled , us_medium_wheeled , us_morphling ] [ difficulty ] , 0 , control_remote , us_laser ] , [ us_morphling , 0 , control_remote , us_heavy_gun ] , [ us_morphling , 0 , control_remote , us_rocket_launcher ] ] ; 2 :
27521: LD_ADDR_LOC 57
27525: PUSH
27526: LD_INT 2
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: LD_INT 5
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: LIST
27539: PUSH
27540: LD_OWVAR 67
27544: ARRAY
27545: PUSH
27546: LD_INT 0
27548: PUSH
27549: LD_INT 2
27551: PUSH
27552: LD_INT 9
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: LIST
27559: LIST
27560: PUSH
27561: LD_INT 5
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 2
27569: PUSH
27570: LD_INT 6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 5
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: LD_INT 2
27587: PUSH
27588: LD_INT 7
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: LIST
27601: ST_TO_ADDR
27602: GO 27717
27604: LD_INT 2
27606: DOUBLE
27607: EQUAL
27608: IFTRUE 27612
27610: GO 27660
27612: POP
// prefered := [ [ ar_medium_trike , 0 , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , 0 , control_remote , ar_gun ] ] ; 3 :
27613: LD_ADDR_LOC 57
27617: PUSH
27618: LD_INT 13
27620: PUSH
27621: LD_INT 0
27623: PUSH
27624: LD_INT 2
27626: PUSH
27627: LD_INT 28
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: PUSH
27636: LD_INT 13
27638: PUSH
27639: LD_INT 0
27641: PUSH
27642: LD_INT 2
27644: PUSH
27645: LD_INT 27
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: ST_TO_ADDR
27658: GO 27717
27660: LD_INT 3
27662: DOUBLE
27663: EQUAL
27664: IFTRUE 27668
27666: GO 27716
27668: POP
// prefered := [ [ 0 , engine_siberite , control_computer , ru_heavy_gun ] , [ 0 , engine_siberite , control_computer , ru_rocket ] ] ; end ;
27669: LD_ADDR_LOC 57
27673: PUSH
27674: LD_INT 0
27676: PUSH
27677: LD_INT 3
27679: PUSH
27680: LD_INT 3
27682: PUSH
27683: LD_INT 46
27685: PUSH
27686: EMPTY
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 3
27697: PUSH
27698: LD_INT 3
27700: PUSH
27701: LD_INT 47
27703: PUSH
27704: EMPTY
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: ST_TO_ADDR
27714: GO 27717
27716: POP
// end ;
27717: LD_VAR 0 2
27721: RET
// every 0 0$1.9 do var un , factories , active_side , active_nation , wait_timers , construction_order_given ;
27722: GO 27724
27724: DISABLE
27725: LD_INT 0
27727: PPUSH
27728: PPUSH
27729: PPUSH
27730: PPUSH
27731: PPUSH
27732: PPUSH
// begin wait_timers = [ ] ;
27733: LD_ADDR_VAR 0 5
27737: PUSH
27738: EMPTY
27739: ST_TO_ADDR
// for un = 1 to 8 do
27740: LD_ADDR_VAR 0 1
27744: PUSH
27745: DOUBLE
27746: LD_INT 1
27748: DEC
27749: ST_TO_ADDR
27750: LD_INT 8
27752: PUSH
27753: FOR_TO
27754: IFFALSE 27772
// wait_timers = wait_timers ^ 0 0$15.9 ;
27756: LD_ADDR_VAR 0 5
27760: PUSH
27761: LD_VAR 0 5
27765: PUSH
27766: LD_INT 557
27768: ADD
27769: ST_TO_ADDR
27770: GO 27753
27772: POP
27773: POP
// repeat wait ( 0 0$1 ) ;
27774: LD_INT 35
27776: PPUSH
27777: CALL_OW 67
// for active_side in cpu_list do
27781: LD_ADDR_VAR 0 3
27785: PUSH
27786: LD_EXP 8
27790: PUSH
27791: FOR_IN
27792: IFFALSE 28145
// begin if wait_timers [ active_side ] > 0 0$0 then
27794: LD_VAR 0 5
27798: PUSH
27799: LD_VAR 0 3
27803: ARRAY
27804: PUSH
27805: LD_INT 0
27807: GREATER
27808: IFFALSE 27847
// begin wait_timers = Replace ( wait_timers , active_side , wait_timers [ active_side ] - 0 0$1 ) ;
27810: LD_ADDR_VAR 0 5
27814: PUSH
27815: LD_VAR 0 5
27819: PPUSH
27820: LD_VAR 0 3
27824: PPUSH
27825: LD_VAR 0 5
27829: PUSH
27830: LD_VAR 0 3
27834: ARRAY
27835: PUSH
27836: LD_INT 35
27838: MINUS
27839: PPUSH
27840: CALL_OW 1
27844: ST_TO_ADDR
// continue ;
27845: GO 27791
// end ; if ( Get_Resources ( active_side ) [ 2 ] > 29 ) or ( Get_resources ( active_side ) [ 3 ] > 9 ) then
27847: LD_VAR 0 3
27851: PPUSH
27852: CALL 28154 0 1
27856: PUSH
27857: LD_INT 2
27859: ARRAY
27860: PUSH
27861: LD_INT 29
27863: GREATER
27864: PUSH
27865: LD_VAR 0 3
27869: PPUSH
27870: CALL 28154 0 1
27874: PUSH
27875: LD_INT 3
27877: ARRAY
27878: PUSH
27879: LD_INT 9
27881: GREATER
27882: OR
27883: IFFALSE 28143
// begin case active_side of us :
27885: LD_VAR 0 3
27889: PUSH
27890: LD_EXP 3
27894: DOUBLE
27895: EQUAL
27896: IFTRUE 27900
27898: GO 27911
27900: POP
// if us_sib_wait then
27901: LD_EXP 75
27905: IFFALSE 27909
// continue ; ru :
27907: GO 27791
27909: GO 27933
27911: LD_EXP 2
27915: DOUBLE
27916: EQUAL
27917: IFTRUE 27921
27919: GO 27932
27921: POP
// if ru_sib_wait then
27922: LD_EXP 76
27926: IFFALSE 27930
// continue ; end ;
27928: GO 27791
27930: GO 27933
27932: POP
// factories := FilterAllUnits ( [ [ f_side , active_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
27933: LD_ADDR_VAR 0 2
27937: PUSH
27938: LD_INT 22
27940: PUSH
27941: LD_VAR 0 3
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 2
27952: PUSH
27953: LD_INT 30
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: LD_INT 30
27965: PUSH
27966: LD_INT 3
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: PPUSH
27982: CALL_OW 69
27986: ST_TO_ADDR
// if factories = 0 then
27987: LD_VAR 0 2
27991: PUSH
27992: LD_INT 0
27994: EQUAL
27995: IFFALSE 27999
// continue ;
27997: GO 27791
// un = factories [ 1 ] ;
27999: LD_ADDR_VAR 0 1
28003: PUSH
28004: LD_VAR 0 2
28008: PUSH
28009: LD_INT 1
28011: ARRAY
28012: ST_TO_ADDR
// active_nation := GetCPUNation ( active_side ) ;
28013: LD_ADDR_VAR 0 4
28017: PUSH
28018: LD_VAR 0 3
28022: PPUSH
28023: CALL 26627 0 1
28027: ST_TO_ADDR
// init_priority ( active_side , active_nation ) ;
28028: LD_VAR 0 3
28032: PPUSH
28033: LD_VAR 0 4
28037: PPUSH
28038: CALL 26707 0 2
// init_prefered_vehicles ( active_nation ) ;
28042: LD_VAR 0 4
28046: PPUSH
28047: CALL 27504 0 1
// if not BuildingStatus ( un ) = bs_working then
28051: LD_VAR 0 1
28055: PPUSH
28056: CALL_OW 461
28060: PUSH
28061: LD_INT 3
28063: EQUAL
28064: NOT
28065: IFFALSE 28143
// begin construction_order_given = build_new_vehicle ( active_side , active_nation , un ) ;
28067: LD_ADDR_VAR 0 6
28071: PUSH
28072: LD_VAR 0 3
28076: PPUSH
28077: LD_VAR 0 4
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: CALL 28272 0 3
28091: ST_TO_ADDR
// if construction_order_given then
28092: LD_VAR 0 6
28096: IFFALSE 28143
// begin wait ( 10 ) ;
28098: LD_INT 10
28100: PPUSH
28101: CALL_OW 67
// if BuildingStatus ( un ) = bs_working then
28105: LD_VAR 0 1
28109: PPUSH
28110: CALL_OW 461
28114: PUSH
28115: LD_INT 3
28117: EQUAL
28118: IFFALSE 28143
// wait_timers = Replace ( wait_timers , active_side , 0 0$15.9 ) ;
28120: LD_ADDR_VAR 0 5
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: LD_VAR 0 3
28134: PPUSH
28135: LD_INT 557
28137: PPUSH
28138: CALL_OW 1
28142: ST_TO_ADDR
// end ; end ; end ; end ;
28143: GO 27791
28145: POP
28146: POP
// until false ;
28147: LD_INT 0
28149: IFFALSE 27774
// end ;
28151: PPOPN 6
28153: END
// function Get_Resources ( side ) ; var depots ; begin
28154: LD_INT 0
28156: PPUSH
28157: PPUSH
// depots = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28158: LD_ADDR_VAR 0 3
28162: PUSH
28163: LD_INT 22
28165: PUSH
28166: LD_VAR 0 1
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 2
28177: PUSH
28178: LD_INT 30
28180: PUSH
28181: LD_INT 0
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PUSH
28188: LD_INT 30
28190: PUSH
28191: LD_INT 1
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: LIST
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PPUSH
28207: CALL_OW 69
28211: ST_TO_ADDR
// if depots > 0 then
28212: LD_VAR 0 3
28216: PUSH
28217: LD_INT 0
28219: GREATER
28220: IFFALSE 28248
// result := GetResources ( GetBase ( depots [ 1 ] ) ) else
28222: LD_ADDR_VAR 0 2
28226: PUSH
28227: LD_VAR 0 3
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PPUSH
28236: CALL_OW 274
28240: PPUSH
28241: CALL_OW 279
28245: ST_TO_ADDR
28246: GO 28267
// result = [ 0 , 0 , 0 ] ;
28248: LD_ADDR_VAR 0 2
28252: PUSH
28253: LD_INT 0
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: LIST
28266: ST_TO_ADDR
// end ;
28267: LD_VAR 0 2
28271: RET
// function build_new_vehicle ( side , nation , factory ) ; var can_made , mechanics , wanted ; begin
28272: LD_INT 0
28274: PPUSH
28275: PPUSH
28276: PPUSH
28277: PPUSH
// result = false ;
28278: LD_ADDR_VAR 0 4
28282: PUSH
28283: LD_INT 0
28285: ST_TO_ADDR
// mechanics := request_people ( side , class_mechanic , 1 ) ;
28286: LD_ADDR_VAR 0 6
28290: PUSH
28291: LD_VAR 0 1
28295: PPUSH
28296: LD_INT 3
28298: PPUSH
28299: LD_INT 1
28301: PPUSH
28302: CALL 26559 0 3
28306: ST_TO_ADDR
// can_made := get_progress ( side , nation , factory ) ;
28307: LD_ADDR_VAR 0 5
28311: PUSH
28312: LD_VAR 0 1
28316: PPUSH
28317: LD_VAR 0 2
28321: PPUSH
28322: LD_VAR 0 3
28326: PPUSH
28327: CALL 28443 0 3
28331: ST_TO_ADDR
// if can_made then
28332: LD_VAR 0 5
28336: IFFALSE 28419
// begin wanted := get_next_vehicle ( side , nation , factory , can_made ) ;
28338: LD_ADDR_VAR 0 7
28342: PUSH
28343: LD_VAR 0 1
28347: PPUSH
28348: LD_VAR 0 2
28352: PPUSH
28353: LD_VAR 0 3
28357: PPUSH
28358: LD_VAR 0 5
28362: PPUSH
28363: CALL 28922 0 4
28367: ST_TO_ADDR
// if transfer_mechanics ( side , mechanics , factory , wanted ) then
28368: LD_VAR 0 1
28372: PPUSH
28373: LD_VAR 0 6
28377: PPUSH
28378: LD_VAR 0 3
28382: PPUSH
28383: LD_VAR 0 7
28387: PPUSH
28388: CALL 31391 0 4
28392: IFFALSE 28419
// result = start_building_vehicle ( nation , factory , wanted ) ;
28394: LD_ADDR_VAR 0 4
28398: PUSH
28399: LD_VAR 0 2
28403: PPUSH
28404: LD_VAR 0 3
28408: PPUSH
28409: LD_VAR 0 7
28413: PPUSH
28414: CALL 31823 0 3
28418: ST_TO_ADDR
// end ; cleanup_extensions ( side , nation , factory ) ;
28419: LD_VAR 0 1
28423: PPUSH
28424: LD_VAR 0 2
28428: PPUSH
28429: LD_VAR 0 3
28433: PPUSH
28434: CALL 32057 0 3
// end ;
28438: LD_VAR 0 4
28442: RET
// function get_progress ( side , nation , factory ) ; var vysledek , chassis , weapon , list ; begin
28443: LD_INT 0
28445: PPUSH
28446: PPUSH
28447: PPUSH
28448: PPUSH
28449: PPUSH
// vysledek := [ ] ;
28450: LD_ADDR_VAR 0 5
28454: PUSH
28455: EMPTY
28456: ST_TO_ADDR
// list := [ ] ;
28457: LD_ADDR_VAR 0 8
28461: PUSH
28462: EMPTY
28463: ST_TO_ADDR
// case nation of 1 :
28464: LD_VAR 0 2
28468: PUSH
28469: LD_INT 1
28471: DOUBLE
28472: EQUAL
28473: IFTRUE 28477
28475: GO 28490
28477: POP
// list := us_weapons ; 2 :
28478: LD_ADDR_VAR 0 8
28482: PUSH
28483: LD_LOC 52
28487: ST_TO_ADDR
28488: GO 28533
28490: LD_INT 2
28492: DOUBLE
28493: EQUAL
28494: IFTRUE 28498
28496: GO 28511
28498: POP
// list := ar_weapons ; 3 :
28499: LD_ADDR_VAR 0 8
28503: PUSH
28504: LD_LOC 53
28508: ST_TO_ADDR
28509: GO 28533
28511: LD_INT 3
28513: DOUBLE
28514: EQUAL
28515: IFTRUE 28519
28517: GO 28532
28519: POP
// list := ru_weapons ; end ;
28520: LD_ADDR_VAR 0 8
28524: PUSH
28525: LD_LOC 54
28529: ST_TO_ADDR
28530: GO 28533
28532: POP
// for chassis = 1 to 3 do
28533: LD_ADDR_VAR 0 6
28537: PUSH
28538: DOUBLE
28539: LD_INT 1
28541: DEC
28542: ST_TO_ADDR
28543: LD_INT 3
28545: PUSH
28546: FOR_TO
28547: IFFALSE 28709
// if ( chassis < 3 ) or ( nation = nation_russian ) or ( TrackExtension ( factory ) ) then
28549: LD_VAR 0 6
28553: PUSH
28554: LD_INT 3
28556: LESS
28557: PUSH
28558: LD_VAR 0 2
28562: PUSH
28563: LD_INT 3
28565: EQUAL
28566: OR
28567: PUSH
28568: LD_VAR 0 3
28572: PPUSH
28573: CALL 29617 0 1
28577: OR
28578: IFFALSE 28707
// for weapon in list [ chassis ] do
28580: LD_ADDR_VAR 0 7
28584: PUSH
28585: LD_VAR 0 8
28589: PUSH
28590: LD_VAR 0 6
28594: ARRAY
28595: PUSH
28596: FOR_IN
28597: IFFALSE 28705
// if Technology_Researched ( side , weapon [ 2 ] ) or not weapon [ 2 ] then
28599: LD_VAR 0 1
28603: PPUSH
28604: LD_VAR 0 7
28608: PUSH
28609: LD_INT 2
28611: ARRAY
28612: PPUSH
28613: CALL 28726 0 2
28617: PUSH
28618: LD_VAR 0 7
28622: PUSH
28623: LD_INT 2
28625: ARRAY
28626: NOT
28627: OR
28628: IFFALSE 28703
// begin if ExtensionBuild ( factory , weapon [ 3 ] ) or not weapon [ 3 ] then
28630: LD_VAR 0 3
28634: PPUSH
28635: LD_VAR 0 7
28639: PUSH
28640: LD_INT 3
28642: ARRAY
28643: PPUSH
28644: CALL 28796 0 2
28648: PUSH
28649: LD_VAR 0 7
28653: PUSH
28654: LD_INT 3
28656: ARRAY
28657: NOT
28658: OR
28659: IFFALSE 28683
// vysledek := vysledek ^ weapon [ 1 ] else
28661: LD_ADDR_VAR 0 5
28665: PUSH
28666: LD_VAR 0 5
28670: PUSH
28671: LD_VAR 0 7
28675: PUSH
28676: LD_INT 1
28678: ARRAY
28679: ADD
28680: ST_TO_ADDR
28681: GO 28703
// extension_wanted := extension_wanted ^ weapon [ 3 ] ;
28683: LD_ADDR_EXP 74
28687: PUSH
28688: LD_EXP 74
28692: PUSH
28693: LD_VAR 0 7
28697: PUSH
28698: LD_INT 3
28700: ARRAY
28701: ADD
28702: ST_TO_ADDR
// end ;
28703: GO 28596
28705: POP
28706: POP
28707: GO 28546
28709: POP
28710: POP
// result := vysledek ;
28711: LD_ADDR_VAR 0 4
28715: PUSH
28716: LD_VAR 0 5
28720: ST_TO_ADDR
// end ;
28721: LD_VAR 0 4
28725: RET
// function Technology_Researched ( side , list ) ; var tech , vysledek ; begin
28726: LD_INT 0
28728: PPUSH
28729: PPUSH
28730: PPUSH
// vysledek := true ;
28731: LD_ADDR_VAR 0 5
28735: PUSH
28736: LD_INT 1
28738: ST_TO_ADDR
// for tech in list do
28739: LD_ADDR_VAR 0 4
28743: PUSH
28744: LD_VAR 0 2
28748: PUSH
28749: FOR_IN
28750: IFFALSE 28779
// if not Researched ( side , tech ) then
28752: LD_VAR 0 1
28756: PPUSH
28757: LD_VAR 0 4
28761: PPUSH
28762: CALL_OW 325
28766: NOT
28767: IFFALSE 28777
// vysledek := false ;
28769: LD_ADDR_VAR 0 5
28773: PUSH
28774: LD_INT 0
28776: ST_TO_ADDR
28777: GO 28749
28779: POP
28780: POP
// result := vysledek ;
28781: LD_ADDR_VAR 0 3
28785: PUSH
28786: LD_VAR 0 5
28790: ST_TO_ADDR
// end ;
28791: LD_VAR 0 3
28795: RET
// function ExtensionBuild ( factory , extension ) ; var i , vysledek , list ; begin
28796: LD_INT 0
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
// vysledek := false ;
28802: LD_ADDR_VAR 0 5
28806: PUSH
28807: LD_INT 0
28809: ST_TO_ADDR
// if extension > 0 then
28810: LD_VAR 0 2
28814: PUSH
28815: LD_INT 0
28817: GREATER
28818: IFFALSE 28899
// begin list := GetExtPositions ( factory ) ;
28820: LD_ADDR_VAR 0 6
28824: PUSH
28825: LD_VAR 0 1
28829: PPUSH
28830: CALL_OW 270
28834: ST_TO_ADDR
// for i in list do
28835: LD_ADDR_VAR 0 4
28839: PUSH
28840: LD_VAR 0 6
28844: PUSH
28845: FOR_IN
28846: IFFALSE 28895
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = extension then
28848: LD_VAR 0 4
28852: PUSH
28853: LD_INT 1
28855: ARRAY
28856: PPUSH
28857: LD_VAR 0 4
28861: PUSH
28862: LD_INT 2
28864: ARRAY
28865: PPUSH
28866: CALL_OW 428
28870: PPUSH
28871: CALL_OW 266
28875: PUSH
28876: LD_VAR 0 2
28880: EQUAL
28881: IFFALSE 28893
// begin vysledek := true ;
28883: LD_ADDR_VAR 0 5
28887: PUSH
28888: LD_INT 1
28890: ST_TO_ADDR
// break ;
28891: GO 28895
// end ;
28893: GO 28845
28895: POP
28896: POP
// end else
28897: GO 28907
// vysledek := true ;
28899: LD_ADDR_VAR 0 5
28903: PUSH
28904: LD_INT 1
28906: ST_TO_ADDR
// result := vysledek ;
28907: LD_ADDR_VAR 0 3
28911: PUSH
28912: LD_VAR 0 5
28916: ST_TO_ADDR
// end ;
28917: LD_VAR 0 3
28921: RET
// function get_next_vehicle ( side , nation , factory , possible ) ; var un , pom , list , cargo_bay , crane , nation_cargo , nation_crane , weapon_prefered , weapon_else , vysledek ; begin
28922: LD_INT 0
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
// vysledek := [ ] ;
28935: LD_ADDR_VAR 0 15
28939: PUSH
28940: EMPTY
28941: ST_TO_ADDR
// case nation of 1 :
28942: LD_VAR 0 2
28946: PUSH
28947: LD_INT 1
28949: DOUBLE
28950: EQUAL
28951: IFTRUE 28955
28953: GO 28984
28955: POP
// begin list := us_weapons ;
28956: LD_ADDR_VAR 0 8
28960: PUSH
28961: LD_LOC 52
28965: ST_TO_ADDR
// nation_cargo := us_cargo_bay ;
28966: LD_ADDR_VAR 0 11
28970: PUSH
28971: LD_INT 12
28973: ST_TO_ADDR
// nation_crane := us_crane ;
28974: LD_ADDR_VAR 0 12
28978: PUSH
28979: LD_INT 13
28981: ST_TO_ADDR
// end ; 2 :
28982: GO 29059
28984: LD_INT 2
28986: DOUBLE
28987: EQUAL
28988: IFTRUE 28992
28990: GO 29021
28992: POP
// begin list := ar_weapons ;
28993: LD_ADDR_VAR 0 8
28997: PUSH
28998: LD_LOC 53
29002: ST_TO_ADDR
// nation_cargo := ar_cargo_bay ;
29003: LD_ADDR_VAR 0 11
29007: PUSH
29008: LD_INT 32
29010: ST_TO_ADDR
// nation_crane := 0 ;
29011: LD_ADDR_VAR 0 12
29015: PUSH
29016: LD_INT 0
29018: ST_TO_ADDR
// end ; 3 :
29019: GO 29059
29021: LD_INT 3
29023: DOUBLE
29024: EQUAL
29025: IFTRUE 29029
29027: GO 29058
29029: POP
// begin list := ru_weapons ;
29030: LD_ADDR_VAR 0 8
29034: PUSH
29035: LD_LOC 54
29039: ST_TO_ADDR
// nation_cargo := ru_cargo_bay ;
29040: LD_ADDR_VAR 0 11
29044: PUSH
29045: LD_INT 51
29047: ST_TO_ADDR
// nation_crane := ru_crane ;
29048: LD_ADDR_VAR 0 12
29052: PUSH
29053: LD_INT 52
29055: ST_TO_ADDR
// end ; end ;
29056: GO 29059
29058: POP
// pom := AvailableWeaponList ( factory ) ;
29059: LD_ADDR_VAR 0 7
29063: PUSH
29064: LD_VAR 0 3
29068: PPUSH
29069: CALL_OW 478
29073: ST_TO_ADDR
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
29074: LD_ADDR_VAR 0 9
29078: PUSH
29079: LD_INT 22
29081: PUSH
29082: LD_VAR 0 1
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 21
29093: PUSH
29094: LD_INT 2
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: LD_INT 34
29103: PUSH
29104: LD_VAR 0 11
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: LIST
29117: PPUSH
29118: CALL_OW 69
29122: ST_TO_ADDR
// if ( not cargo_bay ) and ( nation_cargo in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29123: LD_VAR 0 9
29127: NOT
29128: PUSH
29129: LD_VAR 0 11
29133: PUSH
29134: LD_VAR 0 7
29138: IN
29139: AND
29140: PUSH
29141: LD_VAR 0 3
29145: PPUSH
29146: CALL 29554 0 1
29150: AND
29151: PUSH
29152: LD_VAR 0 3
29156: PPUSH
29157: CALL 29617 0 1
29161: AND
29162: IFFALSE 29196
// vysledek := Define_NonCombat ( side , nation , factory , nation_cargo ) else
29164: LD_ADDR_VAR 0 15
29168: PUSH
29169: LD_VAR 0 1
29173: PPUSH
29174: LD_VAR 0 2
29178: PPUSH
29179: LD_VAR 0 3
29183: PPUSH
29184: LD_VAR 0 11
29188: PPUSH
29189: CALL 29643 0 4
29193: ST_TO_ADDR
29194: GO 29212
// possible := possible diff nation_cargo ;
29196: LD_ADDR_VAR 0 4
29200: PUSH
29201: LD_VAR 0 4
29205: PUSH
29206: LD_VAR 0 11
29210: DIFF
29211: ST_TO_ADDR
// if not vysledek then
29212: LD_VAR 0 15
29216: NOT
29217: IFFALSE 29357
// begin crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
29219: LD_ADDR_VAR 0 10
29223: PUSH
29224: LD_INT 22
29226: PUSH
29227: LD_VAR 0 1
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 21
29238: PUSH
29239: LD_INT 2
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 34
29248: PUSH
29249: LD_VAR 0 12
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: LIST
29262: PPUSH
29263: CALL_OW 69
29267: ST_TO_ADDR
// if ( not crane ) and ( nation_crane in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29268: LD_VAR 0 10
29272: NOT
29273: PUSH
29274: LD_VAR 0 12
29278: PUSH
29279: LD_VAR 0 7
29283: IN
29284: AND
29285: PUSH
29286: LD_VAR 0 3
29290: PPUSH
29291: CALL 29554 0 1
29295: AND
29296: PUSH
29297: LD_VAR 0 3
29301: PPUSH
29302: CALL 29617 0 1
29306: AND
29307: IFFALSE 29341
// vysledek := Define_NonCombat ( side , nation , factory , nation_crane ) else
29309: LD_ADDR_VAR 0 15
29313: PUSH
29314: LD_VAR 0 1
29318: PPUSH
29319: LD_VAR 0 2
29323: PPUSH
29324: LD_VAR 0 3
29328: PPUSH
29329: LD_VAR 0 12
29333: PPUSH
29334: CALL 29643 0 4
29338: ST_TO_ADDR
29339: GO 29357
// possible := possible diff nation_crane ;
29341: LD_ADDR_VAR 0 4
29345: PUSH
29346: LD_VAR 0 4
29350: PUSH
29351: LD_VAR 0 12
29355: DIFF
29356: ST_TO_ADDR
// end ; if not vysledek then
29357: LD_VAR 0 15
29361: NOT
29362: IFFALSE 29539
// begin weapon_prefered := [ ] ;
29364: LD_ADDR_VAR 0 13
29368: PUSH
29369: EMPTY
29370: ST_TO_ADDR
// weapon_else := 0 ;
29371: LD_ADDR_VAR 0 14
29375: PUSH
29376: LD_INT 0
29378: ST_TO_ADDR
// for un in prefered do
29379: LD_ADDR_VAR 0 6
29383: PUSH
29384: LD_LOC 57
29388: PUSH
29389: FOR_IN
29390: IFFALSE 29429
// if ( un [ 4 ] in possible ) then
29392: LD_VAR 0 6
29396: PUSH
29397: LD_INT 4
29399: ARRAY
29400: PUSH
29401: LD_VAR 0 4
29405: IN
29406: IFFALSE 29427
// weapon_prefered := weapon_prefered ^ [ un ] ;
29408: LD_ADDR_VAR 0 13
29412: PUSH
29413: LD_VAR 0 13
29417: PUSH
29418: LD_VAR 0 6
29422: PUSH
29423: EMPTY
29424: LIST
29425: ADD
29426: ST_TO_ADDR
29427: GO 29389
29429: POP
29430: POP
// if not weapon_prefered then
29431: LD_VAR 0 13
29435: NOT
29436: IFFALSE 29509
// begin for un in possible do
29438: LD_ADDR_VAR 0 6
29442: PUSH
29443: LD_VAR 0 4
29447: PUSH
29448: FOR_IN
29449: IFFALSE 29475
// if un > weapon_else then
29451: LD_VAR 0 6
29455: PUSH
29456: LD_VAR 0 14
29460: GREATER
29461: IFFALSE 29473
// weapon_else := un ;
29463: LD_ADDR_VAR 0 14
29467: PUSH
29468: LD_VAR 0 6
29472: ST_TO_ADDR
29473: GO 29448
29475: POP
29476: POP
// vysledek := Define_Vehicle ( side , nation , factory , weapon_else ) ;
29477: LD_ADDR_VAR 0 15
29481: PUSH
29482: LD_VAR 0 1
29486: PPUSH
29487: LD_VAR 0 2
29491: PPUSH
29492: LD_VAR 0 3
29496: PPUSH
29497: LD_VAR 0 14
29501: PPUSH
29502: CALL 30443 0 4
29506: ST_TO_ADDR
// end else
29507: GO 29539
// vysledek := Select_from_Prefered ( side , nation , factory , weapon_prefered ) ;
29509: LD_ADDR_VAR 0 15
29513: PUSH
29514: LD_VAR 0 1
29518: PPUSH
29519: LD_VAR 0 2
29523: PPUSH
29524: LD_VAR 0 3
29528: PPUSH
29529: LD_VAR 0 13
29533: PPUSH
29534: CALL 29915 0 4
29538: ST_TO_ADDR
// end ; result := vysledek ;
29539: LD_ADDR_VAR 0 5
29543: PUSH
29544: LD_VAR 0 15
29548: ST_TO_ADDR
// end ;
29549: LD_VAR 0 5
29553: RET
// function Remote_or_Computer ( factory ) ; var vysledek ; begin
29554: LD_INT 0
29556: PPUSH
29557: PPUSH
// vysledek := false ;
29558: LD_ADDR_VAR 0 3
29562: PUSH
29563: LD_INT 0
29565: ST_TO_ADDR
// if ExtensionBuild ( factory , b_ext_computer ) or ExtensionBuild ( factory , b_ext_radar ) then
29566: LD_VAR 0 1
29570: PPUSH
29571: LD_INT 24
29573: PPUSH
29574: CALL 28796 0 2
29578: PUSH
29579: LD_VAR 0 1
29583: PPUSH
29584: LD_INT 20
29586: PPUSH
29587: CALL 28796 0 2
29591: OR
29592: IFFALSE 29602
// vysledek := true ;
29594: LD_ADDR_VAR 0 3
29598: PUSH
29599: LD_INT 1
29601: ST_TO_ADDR
// result := vysledek ;
29602: LD_ADDR_VAR 0 2
29606: PUSH
29607: LD_VAR 0 3
29611: ST_TO_ADDR
// end ;
29612: LD_VAR 0 2
29616: RET
// function TrackExtension ( factory ) ; begin
29617: LD_INT 0
29619: PPUSH
// result := ExtensionBuild ( factory , b_ext_track ) ;
29620: LD_ADDR_VAR 0 2
29624: PUSH
29625: LD_VAR 0 1
29629: PPUSH
29630: LD_INT 16
29632: PPUSH
29633: CALL 28796 0 2
29637: ST_TO_ADDR
// end ;
29638: LD_VAR 0 2
29642: RET
// function Define_NonCombat ( side , nation , factory , weapon ) ; var components ; begin
29643: LD_INT 0
29645: PPUSH
29646: PPUSH
// components := [ ] ;
29647: LD_ADDR_VAR 0 6
29651: PUSH
29652: EMPTY
29653: ST_TO_ADDR
// case nation of 1 :
29654: LD_VAR 0 2
29658: PUSH
29659: LD_INT 1
29661: DOUBLE
29662: EQUAL
29663: IFTRUE 29667
29665: GO 29684
29667: POP
// components := components ^ us_medium_tracked ; 2 :
29668: LD_ADDR_VAR 0 6
29672: PUSH
29673: LD_VAR 0 6
29677: PUSH
29678: LD_INT 3
29680: ADD
29681: ST_TO_ADDR
29682: GO 29735
29684: LD_INT 2
29686: DOUBLE
29687: EQUAL
29688: IFTRUE 29692
29690: GO 29709
29692: POP
// components := components ^ ar_half_tracked ; 3 :
29693: LD_ADDR_VAR 0 6
29697: PUSH
29698: LD_VAR 0 6
29702: PUSH
29703: LD_INT 14
29705: ADD
29706: ST_TO_ADDR
29707: GO 29735
29709: LD_INT 3
29711: DOUBLE
29712: EQUAL
29713: IFTRUE 29717
29715: GO 29734
29717: POP
// components := components ^ ru_medium_tracked ; end ;
29718: LD_ADDR_VAR 0 6
29722: PUSH
29723: LD_VAR 0 6
29727: PUSH
29728: LD_INT 22
29730: ADD
29731: ST_TO_ADDR
29732: GO 29735
29734: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
29735: LD_VAR 0 3
29739: PPUSH
29740: LD_INT 21
29742: PPUSH
29743: CALL 28796 0 2
29747: PUSH
29748: LD_VAR 0 1
29752: PPUSH
29753: CALL 28154 0 1
29757: PUSH
29758: LD_INT 3
29760: ARRAY
29761: PUSH
29762: LD_LOC 55
29766: GREATEREQUAL
29767: AND
29768: IFFALSE 29786
// components := components ^ engine_siberite else
29770: LD_ADDR_VAR 0 6
29774: PUSH
29775: LD_VAR 0 6
29779: PUSH
29780: LD_INT 3
29782: ADD
29783: ST_TO_ADDR
29784: GO 29800
// components := components ^ engine_combustion ;
29786: LD_ADDR_VAR 0 6
29790: PUSH
29791: LD_VAR 0 6
29795: PUSH
29796: LD_INT 1
29798: ADD
29799: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
29800: LD_VAR 0 2
29804: PUSH
29805: LD_INT 2
29807: EQUAL
29808: PUSH
29809: LD_VAR 0 1
29813: PPUSH
29814: CALL 31328 0 1
29818: AND
29819: IFFALSE 29837
// components := components ^ control_apeman else
29821: LD_ADDR_VAR 0 6
29825: PUSH
29826: LD_VAR 0 6
29830: PUSH
29831: LD_INT 5
29833: ADD
29834: ST_TO_ADDR
29835: GO 29881
// if ExtensionBuild ( factory , b_ext_computer ) then
29837: LD_VAR 0 3
29841: PPUSH
29842: LD_INT 24
29844: PPUSH
29845: CALL 28796 0 2
29849: IFFALSE 29867
// components := components ^ control_computer else
29851: LD_ADDR_VAR 0 6
29855: PUSH
29856: LD_VAR 0 6
29860: PUSH
29861: LD_INT 3
29863: ADD
29864: ST_TO_ADDR
29865: GO 29881
// components := components ^ control_remote ;
29867: LD_ADDR_VAR 0 6
29871: PUSH
29872: LD_VAR 0 6
29876: PUSH
29877: LD_INT 2
29879: ADD
29880: ST_TO_ADDR
// components := components ^ [ weapon ] ;
29881: LD_ADDR_VAR 0 6
29885: PUSH
29886: LD_VAR 0 6
29890: PUSH
29891: LD_VAR 0 4
29895: PUSH
29896: EMPTY
29897: LIST
29898: ADD
29899: ST_TO_ADDR
// result := components ;
29900: LD_ADDR_VAR 0 5
29904: PUSH
29905: LD_VAR 0 6
29909: ST_TO_ADDR
// end ;
29910: LD_VAR 0 5
29914: RET
// function Select_from_Prefered ( side , nation , factory , possible ) ; var un , i , count , components , controls , vysledek ; begin
29915: LD_INT 0
29917: PPUSH
29918: PPUSH
29919: PPUSH
29920: PPUSH
29921: PPUSH
29922: PPUSH
29923: PPUSH
// count := [ - 1 , 0 ] ;
29924: LD_ADDR_VAR 0 8
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: ST_TO_ADDR
// for un in possible do
29940: LD_ADDR_VAR 0 6
29944: PUSH
29945: LD_VAR 0 4
29949: PUSH
29950: FOR_IN
29951: IFFALSE 30050
// begin i := 0 + FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , un [ 4 ] ] ] ) ;
29953: LD_ADDR_VAR 0 7
29957: PUSH
29958: LD_INT 0
29960: PUSH
29961: LD_INT 22
29963: PUSH
29964: LD_VAR 0 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: LD_INT 34
29975: PUSH
29976: LD_VAR 0 6
29980: PUSH
29981: LD_INT 4
29983: ARRAY
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: PPUSH
29993: CALL_OW 69
29997: PLUS
29998: ST_TO_ADDR
// if ( count [ 1 ] < 0 ) or ( count [ 1 ] > i ) then
29999: LD_VAR 0 8
30003: PUSH
30004: LD_INT 1
30006: ARRAY
30007: PUSH
30008: LD_INT 0
30010: LESS
30011: PUSH
30012: LD_VAR 0 8
30016: PUSH
30017: LD_INT 1
30019: ARRAY
30020: PUSH
30021: LD_VAR 0 7
30025: GREATER
30026: OR
30027: IFFALSE 30048
// count := [ i , un ] ;
30029: LD_ADDR_VAR 0 8
30033: PUSH
30034: LD_VAR 0 7
30038: PUSH
30039: LD_VAR 0 6
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: ST_TO_ADDR
// end ;
30048: GO 29950
30050: POP
30051: POP
// un := count [ 2 ] ;
30052: LD_ADDR_VAR 0 6
30056: PUSH
30057: LD_VAR 0 8
30061: PUSH
30062: LD_INT 2
30064: ARRAY
30065: ST_TO_ADDR
// components := [ ] ;
30066: LD_ADDR_VAR 0 9
30070: PUSH
30071: EMPTY
30072: ST_TO_ADDR
// controls := AvailableControlList ( factory ) ;
30073: LD_ADDR_VAR 0 10
30077: PUSH
30078: LD_VAR 0 3
30082: PPUSH
30083: CALL_OW 477
30087: ST_TO_ADDR
// if un [ 1 ] in AvailableChassisList ( factory ) then
30088: LD_VAR 0 6
30092: PUSH
30093: LD_INT 1
30095: ARRAY
30096: PUSH
30097: LD_VAR 0 3
30101: PPUSH
30102: CALL_OW 475
30106: IN
30107: IFFALSE 30131
// components := components ^ un [ 1 ] else
30109: LD_ADDR_VAR 0 9
30113: PUSH
30114: LD_VAR 0 9
30118: PUSH
30119: LD_VAR 0 6
30123: PUSH
30124: LD_INT 1
30126: ARRAY
30127: ADD
30128: ST_TO_ADDR
30129: GO 30181
// components := components ^ SelectChassis ( side , nation , factory , ChassisWeight ( nation , un [ 4 ] ) ) ;
30131: LD_ADDR_VAR 0 9
30135: PUSH
30136: LD_VAR 0 9
30140: PUSH
30141: LD_VAR 0 1
30145: PPUSH
30146: LD_VAR 0 2
30150: PPUSH
30151: LD_VAR 0 3
30155: PPUSH
30156: LD_VAR 0 2
30160: PPUSH
30161: LD_VAR 0 6
30165: PUSH
30166: LD_INT 4
30168: ARRAY
30169: PPUSH
30170: CALL 31151 0 2
30174: PPUSH
30175: CALL 30785 0 4
30179: ADD
30180: ST_TO_ADDR
// if un [ 2 ] in AvailableEngineList ( factory ) then
30181: LD_VAR 0 6
30185: PUSH
30186: LD_INT 2
30188: ARRAY
30189: PUSH
30190: LD_VAR 0 3
30194: PPUSH
30195: CALL_OW 476
30199: IN
30200: IFFALSE 30224
// components := components ^ un [ 2 ] else
30202: LD_ADDR_VAR 0 9
30206: PUSH
30207: LD_VAR 0 9
30211: PUSH
30212: LD_VAR 0 6
30216: PUSH
30217: LD_INT 2
30219: ARRAY
30220: ADD
30221: ST_TO_ADDR
30222: GO 30299
// if ( not components [ 1 ] in [ us_light_wheeled , ar_hovercraft , ar_light_trike ] ) and ( Get_Resources ( side ) [ 3 ] > 9 ) then
30224: LD_VAR 0 9
30228: PUSH
30229: LD_INT 1
30231: ARRAY
30232: PUSH
30233: LD_INT 1
30235: PUSH
30236: LD_INT 11
30238: PUSH
30239: LD_INT 12
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: LIST
30246: IN
30247: NOT
30248: PUSH
30249: LD_VAR 0 1
30253: PPUSH
30254: CALL 28154 0 1
30258: PUSH
30259: LD_INT 3
30261: ARRAY
30262: PUSH
30263: LD_INT 9
30265: GREATER
30266: AND
30267: IFFALSE 30285
// components := components ^ engine_siberite else
30269: LD_ADDR_VAR 0 9
30273: PUSH
30274: LD_VAR 0 9
30278: PUSH
30279: LD_INT 3
30281: ADD
30282: ST_TO_ADDR
30283: GO 30299
// components := components ^ engine_combustion ;
30285: LD_ADDR_VAR 0 9
30289: PUSH
30290: LD_VAR 0 9
30294: PUSH
30295: LD_INT 1
30297: ADD
30298: ST_TO_ADDR
// if un [ 3 ] in AvailableControlList ( factory ) then
30299: LD_VAR 0 6
30303: PUSH
30304: LD_INT 3
30306: ARRAY
30307: PUSH
30308: LD_VAR 0 3
30312: PPUSH
30313: CALL_OW 477
30317: IN
30318: IFFALSE 30342
// components := components ^ un [ 3 ] else
30320: LD_ADDR_VAR 0 9
30324: PUSH
30325: LD_VAR 0 9
30329: PUSH
30330: LD_VAR 0 6
30334: PUSH
30335: LD_INT 3
30337: ARRAY
30338: ADD
30339: ST_TO_ADDR
30340: GO 30408
// begin if control_remote in controls then
30342: LD_INT 2
30344: PUSH
30345: LD_VAR 0 10
30349: IN
30350: IFFALSE 30368
// components := components ^ control_remote else
30352: LD_ADDR_VAR 0 9
30356: PUSH
30357: LD_VAR 0 9
30361: PUSH
30362: LD_INT 2
30364: ADD
30365: ST_TO_ADDR
30366: GO 30408
// if control_computer in controls then
30368: LD_INT 3
30370: PUSH
30371: LD_VAR 0 10
30375: IN
30376: IFFALSE 30394
// components := components ^ control_computer else
30378: LD_ADDR_VAR 0 9
30382: PUSH
30383: LD_VAR 0 9
30387: PUSH
30388: LD_INT 3
30390: ADD
30391: ST_TO_ADDR
30392: GO 30408
// components := components ^ control_manual ;
30394: LD_ADDR_VAR 0 9
30398: PUSH
30399: LD_VAR 0 9
30403: PUSH
30404: LD_INT 1
30406: ADD
30407: ST_TO_ADDR
// end ; components := components ^ un [ 4 ] ;
30408: LD_ADDR_VAR 0 9
30412: PUSH
30413: LD_VAR 0 9
30417: PUSH
30418: LD_VAR 0 6
30422: PUSH
30423: LD_INT 4
30425: ARRAY
30426: ADD
30427: ST_TO_ADDR
// result := components ;
30428: LD_ADDR_VAR 0 5
30432: PUSH
30433: LD_VAR 0 9
30437: ST_TO_ADDR
// end ;
30438: LD_VAR 0 5
30442: RET
// function Define_Vehicle ( side , nation , factory , weapon ) ; var components ; begin
30443: LD_INT 0
30445: PPUSH
30446: PPUSH
// components := [ ] ;
30447: LD_ADDR_VAR 0 6
30451: PUSH
30452: EMPTY
30453: ST_TO_ADDR
// case ChassisWeight ( nation , weapon ) of 1 :
30454: LD_VAR 0 2
30458: PPUSH
30459: LD_VAR 0 4
30463: PPUSH
30464: CALL 31151 0 2
30468: PUSH
30469: LD_INT 1
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30514
30477: POP
// components := components ^ SelectChassis ( side , nation , factory , 1 ) ; 2 :
30478: LD_ADDR_VAR 0 6
30482: PUSH
30483: LD_VAR 0 6
30487: PUSH
30488: LD_VAR 0 1
30492: PPUSH
30493: LD_VAR 0 2
30497: PPUSH
30498: LD_VAR 0 3
30502: PPUSH
30503: LD_INT 1
30505: PPUSH
30506: CALL 30785 0 4
30510: ADD
30511: ST_TO_ADDR
30512: GO 30605
30514: LD_INT 2
30516: DOUBLE
30517: EQUAL
30518: IFTRUE 30522
30520: GO 30559
30522: POP
// components := components ^ SelectChassis ( side , nation , factory , 2 ) ; 3 :
30523: LD_ADDR_VAR 0 6
30527: PUSH
30528: LD_VAR 0 6
30532: PUSH
30533: LD_VAR 0 1
30537: PPUSH
30538: LD_VAR 0 2
30542: PPUSH
30543: LD_VAR 0 3
30547: PPUSH
30548: LD_INT 2
30550: PPUSH
30551: CALL 30785 0 4
30555: ADD
30556: ST_TO_ADDR
30557: GO 30605
30559: LD_INT 3
30561: DOUBLE
30562: EQUAL
30563: IFTRUE 30567
30565: GO 30604
30567: POP
// components := components ^ SelectChassis ( side , nation , factory , 3 ) ; end ;
30568: LD_ADDR_VAR 0 6
30572: PUSH
30573: LD_VAR 0 6
30577: PUSH
30578: LD_VAR 0 1
30582: PPUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: LD_VAR 0 3
30592: PPUSH
30593: LD_INT 3
30595: PPUSH
30596: CALL 30785 0 4
30600: ADD
30601: ST_TO_ADDR
30602: GO 30605
30604: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30605: LD_VAR 0 3
30609: PPUSH
30610: LD_INT 21
30612: PPUSH
30613: CALL 28796 0 2
30617: PUSH
30618: LD_VAR 0 1
30622: PPUSH
30623: CALL 28154 0 1
30627: PUSH
30628: LD_INT 3
30630: ARRAY
30631: PUSH
30632: LD_LOC 55
30636: GREATEREQUAL
30637: AND
30638: IFFALSE 30656
// components := components ^ engine_siberite else
30640: LD_ADDR_VAR 0 6
30644: PUSH
30645: LD_VAR 0 6
30649: PUSH
30650: LD_INT 3
30652: ADD
30653: ST_TO_ADDR
30654: GO 30670
// components := components ^ engine_combustion ;
30656: LD_ADDR_VAR 0 6
30660: PUSH
30661: LD_VAR 0 6
30665: PUSH
30666: LD_INT 1
30668: ADD
30669: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30670: LD_VAR 0 2
30674: PUSH
30675: LD_INT 2
30677: EQUAL
30678: PUSH
30679: LD_VAR 0 1
30683: PPUSH
30684: CALL 31328 0 1
30688: AND
30689: IFFALSE 30707
// components := components ^ control_apeman else
30691: LD_ADDR_VAR 0 6
30695: PUSH
30696: LD_VAR 0 6
30700: PUSH
30701: LD_INT 5
30703: ADD
30704: ST_TO_ADDR
30705: GO 30751
// if ExtensionBuild ( factory , b_ext_computer ) then
30707: LD_VAR 0 3
30711: PPUSH
30712: LD_INT 24
30714: PPUSH
30715: CALL 28796 0 2
30719: IFFALSE 30737
// components := components ^ control_computer else
30721: LD_ADDR_VAR 0 6
30725: PUSH
30726: LD_VAR 0 6
30730: PUSH
30731: LD_INT 3
30733: ADD
30734: ST_TO_ADDR
30735: GO 30751
// components := components ^ control_remote ;
30737: LD_ADDR_VAR 0 6
30741: PUSH
30742: LD_VAR 0 6
30746: PUSH
30747: LD_INT 2
30749: ADD
30750: ST_TO_ADDR
// components := components ^ [ weapon ] ;
30751: LD_ADDR_VAR 0 6
30755: PUSH
30756: LD_VAR 0 6
30760: PUSH
30761: LD_VAR 0 4
30765: PUSH
30766: EMPTY
30767: LIST
30768: ADD
30769: ST_TO_ADDR
// result := components ;
30770: LD_ADDR_VAR 0 5
30774: PUSH
30775: LD_VAR 0 6
30779: ST_TO_ADDR
// end ;
30780: LD_VAR 0 5
30784: RET
// function SelectChassis ( side , nation , factory , weight ) ; var un , vysledek ; begin
30785: LD_INT 0
30787: PPUSH
30788: PPUSH
30789: PPUSH
// vysledek := 0 ;
30790: LD_ADDR_VAR 0 7
30794: PUSH
30795: LD_INT 0
30797: ST_TO_ADDR
// case weight of 1 :
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 1
30805: DOUBLE
30806: EQUAL
30807: IFTRUE 30811
30809: GO 30874
30811: POP
// begin case nation of 1 :
30812: LD_VAR 0 2
30816: PUSH
30817: LD_INT 1
30819: DOUBLE
30820: EQUAL
30821: IFTRUE 30825
30823: GO 30836
30825: POP
// vysledek := us_light_wheeled ; 2 :
30826: LD_ADDR_VAR 0 7
30830: PUSH
30831: LD_INT 1
30833: ST_TO_ADDR
30834: GO 30872
30836: LD_INT 2
30838: DOUBLE
30839: EQUAL
30840: IFTRUE 30844
30842: GO 30871
30844: POP
// if hovers_recomended then
30845: LD_LOC 59
30849: IFFALSE 30861
// vysledek := ar_hovercraft else
30851: LD_ADDR_VAR 0 7
30855: PUSH
30856: LD_INT 11
30858: ST_TO_ADDR
30859: GO 30869
// vysledek := ar_light_trike ; end ;
30861: LD_ADDR_VAR 0 7
30865: PUSH
30866: LD_INT 12
30868: ST_TO_ADDR
30869: GO 30872
30871: POP
// end ; 2 :
30872: GO 31136
30874: LD_INT 2
30876: DOUBLE
30877: EQUAL
30878: IFTRUE 30882
30880: GO 31031
30882: POP
// begin if ( not flat_land ) and TrackExtension ( factory ) then
30883: LD_LOC 60
30887: NOT
30888: PUSH
30889: LD_VAR 0 3
30893: PPUSH
30894: CALL 29617 0 1
30898: AND
30899: IFFALSE 30966
// case nation of 1 :
30901: LD_VAR 0 2
30905: PUSH
30906: LD_INT 1
30908: DOUBLE
30909: EQUAL
30910: IFTRUE 30914
30912: GO 30925
30914: POP
// vysledek := us_medium_tracked ; 2 :
30915: LD_ADDR_VAR 0 7
30919: PUSH
30920: LD_INT 3
30922: ST_TO_ADDR
30923: GO 30964
30925: LD_INT 2
30927: DOUBLE
30928: EQUAL
30929: IFTRUE 30933
30931: GO 30944
30933: POP
// vysledek := ar_half_tracked ; 3 :
30934: LD_ADDR_VAR 0 7
30938: PUSH
30939: LD_INT 14
30941: ST_TO_ADDR
30942: GO 30964
30944: LD_INT 3
30946: DOUBLE
30947: EQUAL
30948: IFTRUE 30952
30950: GO 30963
30952: POP
// vysledek := ru_medium_tracked ; end else
30953: LD_ADDR_VAR 0 7
30957: PUSH
30958: LD_INT 22
30960: ST_TO_ADDR
30961: GO 30964
30963: POP
30964: GO 31029
// case nation of 1 :
30966: LD_VAR 0 2
30970: PUSH
30971: LD_INT 1
30973: DOUBLE
30974: EQUAL
30975: IFTRUE 30979
30977: GO 30990
30979: POP
// vysledek := us_medium_wheeled ; 2 :
30980: LD_ADDR_VAR 0 7
30984: PUSH
30985: LD_INT 2
30987: ST_TO_ADDR
30988: GO 31029
30990: LD_INT 2
30992: DOUBLE
30993: EQUAL
30994: IFTRUE 30998
30996: GO 31009
30998: POP
// vysledek := ar_medium_trike ; 3 :
30999: LD_ADDR_VAR 0 7
31003: PUSH
31004: LD_INT 13
31006: ST_TO_ADDR
31007: GO 31029
31009: LD_INT 3
31011: DOUBLE
31012: EQUAL
31013: IFTRUE 31017
31015: GO 31028
31017: POP
// vysledek := ru_medium_wheeled ; end end ; 3 :
31018: LD_ADDR_VAR 0 7
31022: PUSH
31023: LD_INT 21
31025: ST_TO_ADDR
31026: GO 31029
31028: POP
31029: GO 31136
31031: LD_INT 3
31033: DOUBLE
31034: EQUAL
31035: IFTRUE 31039
31037: GO 31135
31039: POP
// begin case nation of 1 :
31040: LD_VAR 0 2
31044: PUSH
31045: LD_INT 1
31047: DOUBLE
31048: EQUAL
31049: IFTRUE 31053
31051: GO 31092
31053: POP
// if GetTech ( side , tech_AdvChassis ) = state_researched then
31054: LD_VAR 0 1
31058: PPUSH
31059: LD_INT 36
31061: PPUSH
31062: CALL_OW 321
31066: PUSH
31067: LD_INT 2
31069: EQUAL
31070: IFFALSE 31082
// vysledek := us_morphling else
31072: LD_ADDR_VAR 0 7
31076: PUSH
31077: LD_INT 5
31079: ST_TO_ADDR
31080: GO 31090
// vysledek := us_heavy_tracked ; 3 :
31082: LD_ADDR_VAR 0 7
31086: PUSH
31087: LD_INT 4
31089: ST_TO_ADDR
31090: GO 31133
31092: LD_INT 3
31094: DOUBLE
31095: EQUAL
31096: IFTRUE 31100
31098: GO 31132
31100: POP
// if TrackExtension ( factory ) then
31101: LD_VAR 0 3
31105: PPUSH
31106: CALL 29617 0 1
31110: IFFALSE 31122
// vysledek := ru_heavy_tracked else
31112: LD_ADDR_VAR 0 7
31116: PUSH
31117: LD_INT 24
31119: ST_TO_ADDR
31120: GO 31130
// vysledek := ru_heavy_wheeled ; end end ; end ;
31122: LD_ADDR_VAR 0 7
31126: PUSH
31127: LD_INT 23
31129: ST_TO_ADDR
31130: GO 31133
31132: POP
31133: GO 31136
31135: POP
// result := vysledek ;
31136: LD_ADDR_VAR 0 5
31140: PUSH
31141: LD_VAR 0 7
31145: ST_TO_ADDR
// end ;
31146: LD_VAR 0 5
31150: RET
// function ChassisWeight ( nation , weapon ) ; var chassis , un , vysledek , weapon_list ; begin
31151: LD_INT 0
31153: PPUSH
31154: PPUSH
31155: PPUSH
31156: PPUSH
31157: PPUSH
// case nation of 1 :
31158: LD_VAR 0 1
31162: PUSH
31163: LD_INT 1
31165: DOUBLE
31166: EQUAL
31167: IFTRUE 31171
31169: GO 31184
31171: POP
// weapon_list := us_weapons ; 2 :
31172: LD_ADDR_VAR 0 7
31176: PUSH
31177: LD_LOC 52
31181: ST_TO_ADDR
31182: GO 31227
31184: LD_INT 2
31186: DOUBLE
31187: EQUAL
31188: IFTRUE 31192
31190: GO 31205
31192: POP
// weapon_list := ar_weapons ; 3 :
31193: LD_ADDR_VAR 0 7
31197: PUSH
31198: LD_LOC 53
31202: ST_TO_ADDR
31203: GO 31227
31205: LD_INT 3
31207: DOUBLE
31208: EQUAL
31209: IFTRUE 31213
31211: GO 31226
31213: POP
// weapon_list := ru_weapons ; end ;
31214: LD_ADDR_VAR 0 7
31218: PUSH
31219: LD_LOC 54
31223: ST_TO_ADDR
31224: GO 31227
31226: POP
// vysledek := false ;
31227: LD_ADDR_VAR 0 6
31231: PUSH
31232: LD_INT 0
31234: ST_TO_ADDR
// for chassis = 1 to 3 do
31235: LD_ADDR_VAR 0 4
31239: PUSH
31240: DOUBLE
31241: LD_INT 1
31243: DEC
31244: ST_TO_ADDR
31245: LD_INT 3
31247: PUSH
31248: FOR_TO
31249: IFFALSE 31311
// if not vysledek then
31251: LD_VAR 0 6
31255: NOT
31256: IFFALSE 31309
// for un in weapon_list [ chassis ] do
31258: LD_ADDR_VAR 0 5
31262: PUSH
31263: LD_VAR 0 7
31267: PUSH
31268: LD_VAR 0 4
31272: ARRAY
31273: PUSH
31274: FOR_IN
31275: IFFALSE 31307
// if weapon = un [ 1 ] then
31277: LD_VAR 0 2
31281: PUSH
31282: LD_VAR 0 5
31286: PUSH
31287: LD_INT 1
31289: ARRAY
31290: EQUAL
31291: IFFALSE 31305
// begin vysledek := chassis ;
31293: LD_ADDR_VAR 0 6
31297: PUSH
31298: LD_VAR 0 4
31302: ST_TO_ADDR
// break ;
31303: GO 31307
// end ;
31305: GO 31274
31307: POP
31308: POP
31309: GO 31248
31311: POP
31312: POP
// result := vysledek ;
31313: LD_ADDR_VAR 0 3
31317: PUSH
31318: LD_VAR 0 6
31322: ST_TO_ADDR
// end ;
31323: LD_VAR 0 3
31327: RET
// function ApemanCanDrive ( side ) ; var un ; begin
31328: LD_INT 0
31330: PPUSH
31331: PPUSH
// result := ( GetTech ( side , tech_ApeNeural ) = state_researched ) and FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31332: LD_ADDR_VAR 0 2
31336: PUSH
31337: LD_VAR 0 1
31341: PPUSH
31342: LD_INT 3
31344: PPUSH
31345: CALL_OW 321
31349: PUSH
31350: LD_INT 2
31352: EQUAL
31353: PUSH
31354: LD_INT 22
31356: PUSH
31357: LD_VAR 0 1
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 25
31368: PUSH
31369: LD_INT 12
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PPUSH
31380: CALL_OW 69
31384: AND
31385: ST_TO_ADDR
// end ;
31386: LD_VAR 0 2
31390: RET
// function transfer_mechanics ( side , mechanics , factory , components ) ; var un , isin ; begin
31391: LD_INT 0
31393: PPUSH
31394: PPUSH
31395: PPUSH
// isin := UnitsInside ( factory ) ;
31396: LD_ADDR_VAR 0 7
31400: PUSH
31401: LD_VAR 0 3
31405: PPUSH
31406: CALL_OW 313
31410: ST_TO_ADDR
// if ( 0 + isin ) > 5 then
31411: LD_INT 0
31413: PUSH
31414: LD_VAR 0 7
31418: PLUS
31419: PUSH
31420: LD_INT 5
31422: GREATER
31423: IFFALSE 31435
// begin result := true ;
31425: LD_ADDR_VAR 0 5
31429: PUSH
31430: LD_INT 1
31432: ST_TO_ADDR
// exit ;
31433: GO 31657
// end ; un := true ;
31435: LD_ADDR_VAR 0 6
31439: PUSH
31440: LD_INT 1
31442: ST_TO_ADDR
// if side = ar then
31443: LD_VAR 0 1
31447: PUSH
31448: LD_EXP 4
31452: EQUAL
31453: IFFALSE 31483
// mechanics := UnitFilter ( mechanics , [ f_not , [ f_driving ] ] ) ;
31455: LD_ADDR_VAR 0 2
31459: PUSH
31460: LD_VAR 0 2
31464: PPUSH
31465: LD_INT 3
31467: PUSH
31468: LD_INT 55
31470: PUSH
31471: EMPTY
31472: LIST
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PPUSH
31478: CALL_OW 72
31482: ST_TO_ADDR
// DoEnterUnit ( mechanics , factory ) ;
31483: LD_VAR 0 2
31487: PPUSH
31488: LD_VAR 0 3
31492: PPUSH
31493: CALL 31662 0 2
// if components [ 3 ] = control_apeman then
31497: LD_VAR 0 4
31501: PUSH
31502: LD_INT 3
31504: ARRAY
31505: PUSH
31506: LD_INT 5
31508: EQUAL
31509: IFFALSE 31647
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] , [ f_not , [ f_hastask ] ] ] ) ;
31511: LD_ADDR_VAR 0 6
31515: PUSH
31516: LD_INT 22
31518: PUSH
31519: LD_VAR 0 1
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 25
31530: PUSH
31531: LD_INT 12
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 3
31540: PUSH
31541: LD_INT 60
31543: PUSH
31544: EMPTY
31545: LIST
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: LIST
31555: PPUSH
31556: CALL_OW 69
31560: ST_TO_ADDR
// if un then
31561: LD_VAR 0 6
31565: IFFALSE 31587
// DoEnterUnit ( un [ 1 ] , factory ) else
31567: LD_VAR 0 6
31571: PUSH
31572: LD_INT 1
31574: ARRAY
31575: PPUSH
31576: LD_VAR 0 3
31580: PPUSH
31581: CALL 31662 0 2
31585: GO 31647
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31587: LD_ADDR_VAR 0 6
31591: PUSH
31592: LD_INT 22
31594: PUSH
31595: LD_VAR 0 1
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 25
31606: PUSH
31607: LD_INT 12
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PPUSH
31618: CALL_OW 69
31622: ST_TO_ADDR
// if un then
31623: LD_VAR 0 6
31627: IFFALSE 31647
// DoEnterUnit ( un [ 1 ] , factory ) ;
31629: LD_VAR 0 6
31633: PUSH
31634: LD_INT 1
31636: ARRAY
31637: PPUSH
31638: LD_VAR 0 3
31642: PPUSH
31643: CALL 31662 0 2
// end ; end ; result := un ;
31647: LD_ADDR_VAR 0 5
31651: PUSH
31652: LD_VAR 0 6
31656: ST_TO_ADDR
// end ;
31657: LD_VAR 0 5
31661: RET
// function DoEnterUnit ( moving_un_list , into_un ) ; var inside_un , t , moving_un ; begin
31662: LD_INT 0
31664: PPUSH
31665: PPUSH
31666: PPUSH
31667: PPUSH
// for moving_un in moving_un_list do
31668: LD_ADDR_VAR 0 6
31672: PUSH
31673: LD_VAR 0 1
31677: PUSH
31678: FOR_IN
31679: IFFALSE 31816
// begin inside_un = IsInUnit ( moving_un ) ;
31681: LD_ADDR_VAR 0 4
31685: PUSH
31686: LD_VAR 0 6
31690: PPUSH
31691: CALL_OW 310
31695: ST_TO_ADDR
// if inside_un <> into_un then
31696: LD_VAR 0 4
31700: PUSH
31701: LD_VAR 0 2
31705: NONEQUAL
31706: IFFALSE 31814
// begin if inside_un > 0 then
31708: LD_VAR 0 4
31712: PUSH
31713: LD_INT 0
31715: GREATER
31716: IFFALSE 31735
// t = GetType ( inside_un ) else
31718: LD_ADDR_VAR 0 5
31722: PUSH
31723: LD_VAR 0 4
31727: PPUSH
31728: CALL_OW 247
31732: ST_TO_ADDR
31733: GO 31743
// t = 0 ;
31735: LD_ADDR_VAR 0 5
31739: PUSH
31740: LD_INT 0
31742: ST_TO_ADDR
// case t of unit_vehicle :
31743: LD_VAR 0 5
31747: PUSH
31748: LD_INT 2
31750: DOUBLE
31751: EQUAL
31752: IFTRUE 31756
31754: GO 31768
31756: POP
// ComExitVehicle ( moving_un ) ; unit_building :
31757: LD_VAR 0 6
31761: PPUSH
31762: CALL_OW 121
31766: GO 31814
31768: LD_INT 3
31770: DOUBLE
31771: EQUAL
31772: IFTRUE 31776
31774: GO 31788
31776: POP
// ComExitBuilding ( moving_un ) ; 0 :
31777: LD_VAR 0 6
31781: PPUSH
31782: CALL_OW 122
31786: GO 31814
31788: LD_INT 0
31790: DOUBLE
31791: EQUAL
31792: IFTRUE 31796
31794: GO 31813
31796: POP
// ComEnterUnit ( moving_un , into_un ) ; end ;
31797: LD_VAR 0 6
31801: PPUSH
31802: LD_VAR 0 2
31806: PPUSH
31807: CALL_OW 120
31811: GO 31814
31813: POP
// end ; end ;
31814: GO 31678
31816: POP
31817: POP
// end ;
31818: LD_VAR 0 3
31822: RET
// function start_building_vehicle ( nation , factory , vehicle ) ; begin
31823: LD_INT 0
31825: PPUSH
// if ( not UnitsInside ( factory ) ) and ( nation <> ar ) then
31826: LD_VAR 0 2
31830: PPUSH
31831: CALL_OW 313
31835: NOT
31836: PUSH
31837: LD_VAR 0 1
31841: PUSH
31842: LD_EXP 4
31846: NONEQUAL
31847: AND
31848: IFFALSE 31860
// begin result = false ;
31850: LD_ADDR_VAR 0 4
31854: PUSH
31855: LD_INT 0
31857: ST_TO_ADDR
// exit ;
31858: GO 31966
// end ; if vehicle [ 3 ] = control_apeman and not ApemanInFactory ( factory ) then
31860: LD_VAR 0 3
31864: PUSH
31865: LD_INT 3
31867: ARRAY
31868: PUSH
31869: LD_INT 5
31871: EQUAL
31872: PUSH
31873: LD_VAR 0 2
31877: PPUSH
31878: CALL 31971 0 1
31882: NOT
31883: AND
31884: IFFALSE 31896
// begin result = false ;
31886: LD_ADDR_VAR 0 4
31890: PUSH
31891: LD_INT 0
31893: ST_TO_ADDR
// exit ;
31894: GO 31966
// end ; ComChangeProfession ( UnitsInside ( factory ) , class_mechanic ) ;
31896: LD_VAR 0 2
31900: PPUSH
31901: CALL_OW 313
31905: PPUSH
31906: LD_INT 3
31908: PPUSH
31909: CALL_OW 123
// ComConstruct ( factory , vehicle [ 1 ] , vehicle [ 2 ] , vehicle [ 3 ] , vehicle [ 4 ] ) ;
31913: LD_VAR 0 2
31917: PPUSH
31918: LD_VAR 0 3
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_VAR 0 3
31931: PUSH
31932: LD_INT 2
31934: ARRAY
31935: PPUSH
31936: LD_VAR 0 3
31940: PUSH
31941: LD_INT 3
31943: ARRAY
31944: PPUSH
31945: LD_VAR 0 3
31949: PUSH
31950: LD_INT 4
31952: ARRAY
31953: PPUSH
31954: CALL_OW 125
// result = true ;
31958: LD_ADDR_VAR 0 4
31962: PUSH
31963: LD_INT 1
31965: ST_TO_ADDR
// end ;
31966: LD_VAR 0 4
31970: RET
// function ApemanInFactory ( factory ) ; var un , list , vysledek ; begin
31971: LD_INT 0
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
// vysledek := false ;
31977: LD_ADDR_VAR 0 5
31981: PUSH
31982: LD_INT 0
31984: ST_TO_ADDR
// list := UnitsInside ( factory ) ;
31985: LD_ADDR_VAR 0 4
31989: PUSH
31990: LD_VAR 0 1
31994: PPUSH
31995: CALL_OW 313
31999: ST_TO_ADDR
// for un in list do
32000: LD_ADDR_VAR 0 3
32004: PUSH
32005: LD_VAR 0 4
32009: PUSH
32010: FOR_IN
32011: IFFALSE 32040
// if GetClass ( un ) = class_apeman then
32013: LD_VAR 0 3
32017: PPUSH
32018: CALL_OW 257
32022: PUSH
32023: LD_INT 12
32025: EQUAL
32026: IFFALSE 32038
// begin vysledek := true ;
32028: LD_ADDR_VAR 0 5
32032: PUSH
32033: LD_INT 1
32035: ST_TO_ADDR
// break ;
32036: GO 32040
// end ;
32038: GO 32010
32040: POP
32041: POP
// result := vysledek ;
32042: LD_ADDR_VAR 0 2
32046: PUSH
32047: LD_VAR 0 5
32051: ST_TO_ADDR
// end ;
32052: LD_VAR 0 2
32056: RET
// function cleanup_extensions ( side , nation , factory ) ; var un , list , crane , cargo_bay , nation_crane , nation_cargo ; begin
32057: LD_INT 0
32059: PPUSH
32060: PPUSH
32061: PPUSH
32062: PPUSH
32063: PPUSH
32064: PPUSH
32065: PPUSH
// case nation of 1 :
32066: LD_VAR 0 2
32070: PUSH
32071: LD_INT 1
32073: DOUBLE
32074: EQUAL
32075: IFTRUE 32079
32077: GO 32098
32079: POP
// begin nation_cargo := us_cargo_bay ;
32080: LD_ADDR_VAR 0 10
32084: PUSH
32085: LD_INT 12
32087: ST_TO_ADDR
// nation_crane := us_crane ;
32088: LD_ADDR_VAR 0 9
32092: PUSH
32093: LD_INT 13
32095: ST_TO_ADDR
// end ; 2 :
32096: GO 32153
32098: LD_INT 2
32100: DOUBLE
32101: EQUAL
32102: IFTRUE 32106
32104: GO 32125
32106: POP
// begin nation_cargo := ar_cargo_bay ;
32107: LD_ADDR_VAR 0 10
32111: PUSH
32112: LD_INT 32
32114: ST_TO_ADDR
// nation_crane := 0 ;
32115: LD_ADDR_VAR 0 9
32119: PUSH
32120: LD_INT 0
32122: ST_TO_ADDR
// end ; 3 :
32123: GO 32153
32125: LD_INT 3
32127: DOUBLE
32128: EQUAL
32129: IFTRUE 32133
32131: GO 32152
32133: POP
// begin nation_cargo := ru_cargo_bay ;
32134: LD_ADDR_VAR 0 10
32138: PUSH
32139: LD_INT 51
32141: ST_TO_ADDR
// nation_crane := ru_crane ;
32142: LD_ADDR_VAR 0 9
32146: PUSH
32147: LD_INT 52
32149: ST_TO_ADDR
// end ; end ;
32150: GO 32153
32152: POP
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
32153: LD_ADDR_VAR 0 8
32157: PUSH
32158: LD_INT 22
32160: PUSH
32161: LD_VAR 0 1
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 21
32172: PUSH
32173: LD_INT 2
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 34
32182: PUSH
32183: LD_VAR 0 10
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: LIST
32196: PPUSH
32197: CALL_OW 69
32201: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
32202: LD_ADDR_VAR 0 7
32206: PUSH
32207: LD_INT 22
32209: PUSH
32210: LD_VAR 0 1
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 21
32221: PUSH
32222: LD_INT 2
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 34
32231: PUSH
32232: LD_VAR 0 9
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: LIST
32245: PPUSH
32246: CALL_OW 69
32250: ST_TO_ADDR
// if ( nation_crane in extension_wanted ) and crane then
32251: LD_VAR 0 9
32255: PUSH
32256: LD_EXP 74
32260: IN
32261: PUSH
32262: LD_VAR 0 7
32266: AND
32267: IFFALSE 32285
// extension_wanted := extension_wanted diff nation_crane ;
32269: LD_ADDR_EXP 74
32273: PUSH
32274: LD_EXP 74
32278: PUSH
32279: LD_VAR 0 9
32283: DIFF
32284: ST_TO_ADDR
// if ( nation_cargo in extension_wanted ) and cargo_bay then
32285: LD_VAR 0 10
32289: PUSH
32290: LD_EXP 74
32294: IN
32295: PUSH
32296: LD_VAR 0 8
32300: AND
32301: IFFALSE 32319
// extension_wanted := extension_wanted diff nation_cargo ;
32303: LD_ADDR_EXP 74
32307: PUSH
32308: LD_EXP 74
32312: PUSH
32313: LD_VAR 0 10
32317: DIFF
32318: ST_TO_ADDR
// list := extension_wanted ;
32319: LD_ADDR_VAR 0 6
32323: PUSH
32324: LD_EXP 74
32328: ST_TO_ADDR
// for un in list do
32329: LD_ADDR_VAR 0 5
32333: PUSH
32334: LD_VAR 0 6
32338: PUSH
32339: FOR_IN
32340: IFFALSE 32373
// begin if not un in main_extensions then
32342: LD_VAR 0 5
32346: PUSH
32347: LD_LOC 58
32351: IN
32352: NOT
32353: IFFALSE 32371
// extension_wanted := extension_wanted diff un ;
32355: LD_ADDR_EXP 74
32359: PUSH
32360: LD_EXP 74
32364: PUSH
32365: LD_VAR 0 5
32369: DIFF
32370: ST_TO_ADDR
// end ;
32371: GO 32339
32373: POP
32374: POP
// end ; end_of_file
32375: LD_VAR 0 4
32379: RET
// var mc_list ; var b_list ; export function init_keep_base ; var un , build , side ; begin
32380: LD_INT 0
32382: PPUSH
32383: PPUSH
32384: PPUSH
32385: PPUSH
// b_list := [ ] ;
32386: LD_ADDR_LOC 62
32390: PUSH
32391: EMPTY
32392: ST_TO_ADDR
// mc_list := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
32393: LD_ADDR_LOC 61
32397: PUSH
32398: LD_INT 0
32400: PUSH
32401: LD_INT 0
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: LD_INT 0
32415: PUSH
32416: LD_INT 0
32418: PUSH
32419: LD_INT 0
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: ST_TO_ADDR
// for side = 1 to 8 do
32432: LD_ADDR_VAR 0 4
32436: PUSH
32437: DOUBLE
32438: LD_INT 1
32440: DEC
32441: ST_TO_ADDR
32442: LD_INT 8
32444: PUSH
32445: FOR_TO
32446: IFFALSE 32561
// if side in cpu_list then
32448: LD_VAR 0 4
32452: PUSH
32453: LD_EXP 8
32457: IN
32458: IFFALSE 32543
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
32460: LD_ADDR_VAR 0 2
32464: PUSH
32465: LD_INT 22
32467: PUSH
32468: LD_VAR 0 4
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 21
32479: PUSH
32480: LD_INT 3
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PPUSH
32491: CALL_OW 69
32495: ST_TO_ADDR
// if un then
32496: LD_VAR 0 2
32500: IFFALSE 32541
// b_list := Insert ( b_list , side , GetBuildList ( GetBase ( un [ 1 ] ) ) ) ;
32502: LD_ADDR_LOC 62
32506: PUSH
32507: LD_LOC 62
32511: PPUSH
32512: LD_VAR 0 4
32516: PPUSH
32517: LD_VAR 0 2
32521: PUSH
32522: LD_INT 1
32524: ARRAY
32525: PPUSH
32526: CALL_OW 274
32530: PPUSH
32531: CALL_OW 417
32535: PPUSH
32536: CALL_OW 2
32540: ST_TO_ADDR
// end else
32541: GO 32559
// b_list := b_list ^ [ [ ] ] ;
32543: LD_ADDR_LOC 62
32547: PUSH
32548: LD_LOC 62
32552: PUSH
32553: EMPTY
32554: PUSH
32555: EMPTY
32556: LIST
32557: ADD
32558: ST_TO_ADDR
32559: GO 32445
32561: POP
32562: POP
// end ;
32563: LD_VAR 0 1
32567: RET
// every 0 0$5.2 trigger us in cpu_list do var side , list , engineers ;
32568: LD_EXP 3
32572: PUSH
32573: LD_EXP 8
32577: IN
32578: IFFALSE 32783
32580: GO 32582
32582: DISABLE
32583: LD_INT 0
32585: PPUSH
32586: PPUSH
32587: PPUSH
// begin list := [ ] ;
32588: LD_ADDR_VAR 0 2
32592: PUSH
32593: EMPTY
32594: ST_TO_ADDR
// for side = 1 to 8 do
32595: LD_ADDR_VAR 0 1
32599: PUSH
32600: DOUBLE
32601: LD_INT 1
32603: DEC
32604: ST_TO_ADDR
32605: LD_INT 8
32607: PUSH
32608: FOR_TO
32609: IFFALSE 32770
// if ( side in cpu_list ) then
32611: LD_VAR 0 1
32615: PUSH
32616: LD_EXP 8
32620: IN
32621: IFFALSE 32754
// begin if not ExistMc ( mc_list [ side ] ) then
32623: LD_LOC 61
32627: PUSH
32628: LD_VAR 0 1
32632: ARRAY
32633: PPUSH
32634: CALL_OW 386
32638: NOT
32639: IFFALSE 32730
// begin engineers := request_people ( side , class_engineer , 5 ) ;
32641: LD_ADDR_VAR 0 3
32645: PUSH
32646: LD_VAR 0 1
32650: PPUSH
32651: LD_INT 2
32653: PPUSH
32654: LD_INT 5
32656: PPUSH
32657: CALL 26559 0 3
32661: ST_TO_ADDR
// if engineers then
32662: LD_VAR 0 3
32666: IFFALSE 32714
// list := list ^ McBase ( 3 , engineers , b_list [ side ] , 0 , 0 , 0 ) else
32668: LD_ADDR_VAR 0 2
32672: PUSH
32673: LD_VAR 0 2
32677: PUSH
32678: LD_INT 3
32680: PPUSH
32681: LD_VAR 0 3
32685: PPUSH
32686: LD_LOC 62
32690: PUSH
32691: LD_VAR 0 1
32695: ARRAY
32696: PPUSH
32697: LD_INT 0
32699: PPUSH
32700: LD_INT 0
32702: PPUSH
32703: LD_INT 0
32705: PPUSH
32706: CALL_OW 397
32710: ADD
32711: ST_TO_ADDR
32712: GO 32728
// list := list ^ 0 end else
32714: LD_ADDR_VAR 0 2
32718: PUSH
32719: LD_VAR 0 2
32723: PUSH
32724: LD_INT 0
32726: ADD
32727: ST_TO_ADDR
32728: GO 32752
// list := list ^ mc_list [ side ] ;
32730: LD_ADDR_VAR 0 2
32734: PUSH
32735: LD_VAR 0 2
32739: PUSH
32740: LD_LOC 61
32744: PUSH
32745: LD_VAR 0 1
32749: ARRAY
32750: ADD
32751: ST_TO_ADDR
// end else
32752: GO 32768
// list := list ^ 0 ;
32754: LD_ADDR_VAR 0 2
32758: PUSH
32759: LD_VAR 0 2
32763: PUSH
32764: LD_INT 0
32766: ADD
32767: ST_TO_ADDR
32768: GO 32608
32770: POP
32771: POP
// mc_list := list ;
32772: LD_ADDR_LOC 61
32776: PUSH
32777: LD_VAR 0 2
32781: ST_TO_ADDR
// enable ;
32782: ENABLE
// end ; end_of_file
32783: PPOPN 3
32785: END
// var load_global , load_local_cpu , load_local_you ; var global_delay , cpu_delay , you_delay ; var crates_loading_area ; export function init_crates_loading ; begin
32786: LD_INT 0
32788: PPUSH
// global_delay := 10 10$0 ;
32789: LD_ADDR_LOC 66
32793: PUSH
32794: LD_INT 21000
32796: ST_TO_ADDR
// cpu_delay := 0 0$90 ;
32797: LD_ADDR_LOC 67
32801: PUSH
32802: LD_INT 3150
32804: ST_TO_ADDR
// you_delay := 3 3$30 ;
32805: LD_ADDR_LOC 68
32809: PUSH
32810: LD_INT 7350
32812: ST_TO_ADDR
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
32813: LD_ADDR_LOC 63
32817: PUSH
32818: LD_OWVAR 1
32822: PUSH
32823: LD_LOC 66
32827: PUSH
32828: LD_INT 1400
32830: MINUS
32831: PPUSH
32832: LD_LOC 66
32836: PUSH
32837: LD_INT 2100
32839: PLUS
32840: PPUSH
32841: CALL_OW 12
32845: PLUS
32846: ST_TO_ADDR
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
32847: LD_ADDR_LOC 64
32851: PUSH
32852: LD_OWVAR 1
32856: PUSH
32857: LD_LOC 67
32861: PUSH
32862: LD_INT 700
32864: MINUS
32865: PPUSH
32866: LD_LOC 67
32870: PUSH
32871: LD_INT 700
32873: PLUS
32874: PPUSH
32875: CALL_OW 12
32879: PLUS
32880: ST_TO_ADDR
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
32881: LD_ADDR_LOC 65
32885: PUSH
32886: LD_OWVAR 1
32890: PUSH
32891: LD_LOC 68
32895: PUSH
32896: LD_INT 700
32898: MINUS
32899: PPUSH
32900: LD_LOC 68
32904: PUSH
32905: LD_INT 700
32907: PLUS
32908: PPUSH
32909: CALL_OW 12
32913: PLUS
32914: ST_TO_ADDR
// crates_loading_area := [ us_crates , ar_crates , ru_crates ] ;
32915: LD_ADDR_LOC 69
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: LD_INT 3
32925: PUSH
32926: LD_INT 2
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: LIST
32933: ST_TO_ADDR
// end ;
32934: LD_VAR 0 1
32938: RET
// every 0 0$5.1 trigger TICK > load_global do var c , sur , i ;
32939: LD_OWVAR 1
32943: PUSH
32944: LD_LOC 63
32948: GREATER
32949: IFFALSE 33122
32951: GO 32953
32953: DISABLE
32954: LD_INT 0
32956: PPUSH
32957: PPUSH
32958: PPUSH
// begin c := RandHex ( false ) ;
32959: LD_ADDR_VAR 0 1
32963: PUSH
32964: LD_INT 0
32966: PPUSH
32967: CALL_OW 15
32971: ST_TO_ADDR
// sur := [ ] ;
32972: LD_ADDR_VAR 0 2
32976: PUSH
32977: EMPTY
32978: ST_TO_ADDR
// for i = 1 to 4 do
32979: LD_ADDR_VAR 0 3
32983: PUSH
32984: DOUBLE
32985: LD_INT 1
32987: DEC
32988: ST_TO_ADDR
32989: LD_INT 4
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33040
// sur := sur ^ [ RandHexXYR ( c [ 1 ] , c [ 2 ] , 1 , false ) ] ;
32995: LD_ADDR_VAR 0 2
32999: PUSH
33000: LD_VAR 0 2
33004: PUSH
33005: LD_VAR 0 1
33009: PUSH
33010: LD_INT 1
33012: ARRAY
33013: PPUSH
33014: LD_VAR 0 1
33018: PUSH
33019: LD_INT 2
33021: ARRAY
33022: PPUSH
33023: LD_INT 1
33025: PPUSH
33026: LD_INT 0
33028: PPUSH
33029: CALL_OW 17
33033: PUSH
33034: EMPTY
33035: LIST
33036: ADD
33037: ST_TO_ADDR
33038: GO 32992
33040: POP
33041: POP
// for i in sur do
33042: LD_ADDR_VAR 0 3
33046: PUSH
33047: LD_VAR 0 2
33051: PUSH
33052: FOR_IN
33053: IFFALSE 33085
// CreateCratesXY ( 5 , i [ 1 ] , i [ 2 ] , true ) ;
33055: LD_INT 5
33057: PPUSH
33058: LD_VAR 0 3
33062: PUSH
33063: LD_INT 1
33065: ARRAY
33066: PPUSH
33067: LD_VAR 0 3
33071: PUSH
33072: LD_INT 2
33074: ARRAY
33075: PPUSH
33076: LD_INT 1
33078: PPUSH
33079: CALL_OW 54
33083: GO 33052
33085: POP
33086: POP
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
33087: LD_ADDR_LOC 63
33091: PUSH
33092: LD_OWVAR 1
33096: PUSH
33097: LD_LOC 66
33101: PUSH
33102: LD_INT 1400
33104: MINUS
33105: PPUSH
33106: LD_LOC 66
33110: PUSH
33111: LD_INT 2100
33113: PLUS
33114: PPUSH
33115: CALL_OW 12
33119: PLUS
33120: ST_TO_ADDR
// enable ;
33121: ENABLE
// end ;
33122: PPOPN 3
33124: END
// every 0 0$5.4 trigger TICK > load_local_cpu do var un ;
33125: LD_OWVAR 1
33129: PUSH
33130: LD_LOC 64
33134: GREATER
33135: IFFALSE 33252
33137: GO 33139
33139: DISABLE
33140: LD_INT 0
33142: PPUSH
// begin if GetResourceArea ( us_crates , mat_cans ) < 250 then
33143: LD_INT 1
33145: PPUSH
33146: LD_INT 1
33148: PPUSH
33149: CALL_OW 287
33153: PUSH
33154: LD_INT 250
33156: LESS
33157: IFFALSE 33180
// CreateCratesArea ( Rand ( 3 , 5 ) , us_crates , true ) ;
33159: LD_INT 3
33161: PPUSH
33162: LD_INT 5
33164: PPUSH
33165: CALL_OW 12
33169: PPUSH
33170: LD_INT 1
33172: PPUSH
33173: LD_INT 1
33175: PPUSH
33176: CALL_OW 55
// if GetResourceArea ( ru_crates , mat_cans ) < 250 then
33180: LD_INT 2
33182: PPUSH
33183: LD_INT 1
33185: PPUSH
33186: CALL_OW 287
33190: PUSH
33191: LD_INT 250
33193: LESS
33194: IFFALSE 33217
// CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
33196: LD_INT 3
33198: PPUSH
33199: LD_INT 5
33201: PPUSH
33202: CALL_OW 12
33206: PPUSH
33207: LD_INT 2
33209: PPUSH
33210: LD_INT 1
33212: PPUSH
33213: CALL_OW 55
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33217: LD_ADDR_LOC 64
33221: PUSH
33222: LD_OWVAR 1
33226: PUSH
33227: LD_LOC 67
33231: PUSH
33232: LD_INT 700
33234: MINUS
33235: PPUSH
33236: LD_LOC 67
33240: PUSH
33241: LD_INT 700
33243: PLUS
33244: PPUSH
33245: CALL_OW 12
33249: PLUS
33250: ST_TO_ADDR
// enable ;
33251: ENABLE
// end ;
33252: PPOPN 1
33254: END
// every 0 0$5.3 trigger TICK > load_local_you do
33255: LD_OWVAR 1
33259: PUSH
33260: LD_LOC 65
33264: GREATER
33265: IFFALSE 33342
33267: GO 33269
33269: DISABLE
// begin if GetResourceArea ( ar_crates , mat_cans ) < 250 then
33270: LD_INT 3
33272: PPUSH
33273: LD_INT 1
33275: PPUSH
33276: CALL_OW 287
33280: PUSH
33281: LD_INT 250
33283: LESS
33284: IFFALSE 33307
// CreateCratesArea ( Rand ( 1 , 5 ) , ar_crates , true ) ;
33286: LD_INT 1
33288: PPUSH
33289: LD_INT 5
33291: PPUSH
33292: CALL_OW 12
33296: PPUSH
33297: LD_INT 3
33299: PPUSH
33300: LD_INT 1
33302: PPUSH
33303: CALL_OW 55
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33307: LD_ADDR_LOC 65
33311: PUSH
33312: LD_OWVAR 1
33316: PUSH
33317: LD_LOC 68
33321: PUSH
33322: LD_INT 700
33324: MINUS
33325: PPUSH
33326: LD_LOC 68
33330: PUSH
33331: LD_INT 700
33333: PLUS
33334: PPUSH
33335: CALL_OW 12
33339: PLUS
33340: ST_TO_ADDR
// enable ;
33341: ENABLE
// end ;
33342: END
// every 0 0$30.1 do var list , side , un , base ;
33343: GO 33345
33345: DISABLE
33346: LD_INT 0
33348: PPUSH
33349: PPUSH
33350: PPUSH
33351: PPUSH
// begin for side in cpu_list do
33352: LD_ADDR_VAR 0 2
33356: PUSH
33357: LD_EXP 8
33361: PUSH
33362: FOR_IN
33363: IFFALSE 33517
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
33365: LD_ADDR_VAR 0 1
33369: PUSH
33370: LD_INT 22
33372: PUSH
33373: LD_VAR 0 2
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 21
33384: PUSH
33385: LD_INT 3
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 2
33394: PUSH
33395: LD_INT 30
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 30
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: LIST
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: LIST
33424: PPUSH
33425: CALL_OW 69
33429: ST_TO_ADDR
// for un in list do
33430: LD_ADDR_VAR 0 3
33434: PUSH
33435: LD_VAR 0 1
33439: PUSH
33440: FOR_IN
33441: IFFALSE 33513
// begin base := GetBase ( un ) ;
33443: LD_ADDR_VAR 0 4
33447: PUSH
33448: LD_VAR 0 3
33452: PPUSH
33453: CALL_OW 274
33457: ST_TO_ADDR
// if GetResourceType ( base , mat_cans ) < 300 then
33458: LD_VAR 0 4
33462: PPUSH
33463: LD_INT 1
33465: PPUSH
33466: CALL_OW 275
33470: PUSH
33471: LD_INT 300
33473: LESS
33474: IFFALSE 33511
// SetResourceType ( base , mat_cans , GetResourceType ( base , mat_cans ) + ( difficulty * 30 ) ) ;
33476: LD_VAR 0 4
33480: PPUSH
33481: LD_INT 1
33483: PPUSH
33484: LD_VAR 0 4
33488: PPUSH
33489: LD_INT 1
33491: PPUSH
33492: CALL_OW 275
33496: PUSH
33497: LD_OWVAR 67
33501: PUSH
33502: LD_INT 30
33504: MUL
33505: PLUS
33506: PPUSH
33507: CALL_OW 277
// end ;
33511: GO 33440
33513: POP
33514: POP
// end ;
33515: GO 33362
33517: POP
33518: POP
// enable ;
33519: ENABLE
// end ; end_of_file
33520: PPOPN 4
33522: END
// var outside_list , inside_list ; var base_areas , create_areas ; var us_bay , ru_bay , ar_bay ; var us_bad , ru_bad , ar_bad ; export function init_crates_collecting ; begin
33523: LD_INT 0
33525: PPUSH
// outside_list := [ us_crates , ar_crates , ru_crates ] ;
33526: LD_ADDR_LOC 70
33530: PUSH
33531: LD_INT 1
33533: PUSH
33534: LD_INT 3
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: LIST
33544: ST_TO_ADDR
// inside_list := [ us_inner_base , ar_base , ru_inner_base ] ;
33545: LD_ADDR_LOC 71
33549: PUSH
33550: LD_INT 38
33552: PUSH
33553: LD_INT 13
33555: PUSH
33556: LD_INT 39
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: LIST
33563: ST_TO_ADDR
// base_areas := [ us_base , ar_base , ru_base ] ;
33564: LD_ADDR_LOC 72
33568: PUSH
33569: LD_INT 11
33571: PUSH
33572: LD_INT 13
33574: PUSH
33575: LD_INT 12
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: LIST
33582: ST_TO_ADDR
// create_areas := [ us_create , ar_create , ru_create ] ;
33583: LD_ADDR_LOC 73
33587: PUSH
33588: LD_INT 18
33590: PUSH
33591: LD_INT 19
33593: PUSH
33594: LD_INT 17
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: LIST
33601: ST_TO_ADDR
// us_bad := [ ] ;
33602: LD_ADDR_LOC 77
33606: PUSH
33607: EMPTY
33608: ST_TO_ADDR
// ru_bad := [ ] ;
33609: LD_ADDR_LOC 78
33613: PUSH
33614: EMPTY
33615: ST_TO_ADDR
// ar_bad := [ ] ;
33616: LD_ADDR_LOC 79
33620: PUSH
33621: EMPTY
33622: ST_TO_ADDR
// end ;
33623: LD_VAR 0 1
33627: RET
// every 0 0$5.4 do var un , side , list , cargo , n_cargo , engineers ;
33628: GO 33630
33630: DISABLE
33631: LD_INT 0
33633: PPUSH
33634: PPUSH
33635: PPUSH
33636: PPUSH
33637: PPUSH
33638: PPUSH
// begin for side in cpu_list do
33639: LD_ADDR_VAR 0 2
33643: PUSH
33644: LD_EXP 8
33648: PUSH
33649: FOR_IN
33650: IFFALSE 34177
// begin list := GetListOfCratesInArea ( outside_list [ side ] ) ;
33652: LD_ADDR_VAR 0 3
33656: PUSH
33657: LD_LOC 70
33661: PUSH
33662: LD_VAR 0 2
33666: ARRAY
33667: PPUSH
33668: CALL_OW 435
33672: ST_TO_ADDR
// if list then
33673: LD_VAR 0 3
33677: IFFALSE 34045
// begin case side of 1 :
33679: LD_VAR 0 2
33683: PUSH
33684: LD_INT 1
33686: DOUBLE
33687: EQUAL
33688: IFTRUE 33692
33690: GO 33703
33692: POP
// n_cargo := us_cargo_bay ; 2 :
33693: LD_ADDR_VAR 0 5
33697: PUSH
33698: LD_INT 12
33700: ST_TO_ADDR
33701: GO 33742
33703: LD_INT 2
33705: DOUBLE
33706: EQUAL
33707: IFTRUE 33711
33709: GO 33722
33711: POP
// n_cargo := ar_cargo_bay ; 3 :
33712: LD_ADDR_VAR 0 5
33716: PUSH
33717: LD_INT 32
33719: ST_TO_ADDR
33720: GO 33742
33722: LD_INT 3
33724: DOUBLE
33725: EQUAL
33726: IFTRUE 33730
33728: GO 33741
33730: POP
// n_cargo := ru_cargo_bay ; end ;
33731: LD_ADDR_VAR 0 5
33735: PUSH
33736: LD_INT 51
33738: ST_TO_ADDR
33739: GO 33742
33741: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
33742: LD_ADDR_VAR 0 4
33746: PUSH
33747: LD_INT 22
33749: PUSH
33750: LD_VAR 0 2
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 21
33761: PUSH
33762: LD_INT 2
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 34
33771: PUSH
33772: LD_VAR 0 5
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: LIST
33785: PPUSH
33786: CALL_OW 69
33790: ST_TO_ADDR
// if cargo then
33791: LD_VAR 0 4
33795: IFFALSE 34045
// begin cargo := cargo [ 1 ] ;
33797: LD_ADDR_VAR 0 4
33801: PUSH
33802: LD_VAR 0 4
33806: PUSH
33807: LD_INT 1
33809: ARRAY
33810: ST_TO_ADDR
// if ( not HasTask ( cargo ) ) and ( not ( [ list [ 1 ] , list [ 2 ] ] in ( us_bad ^ ru_bad ^ ar_bad ) ) ) then
33811: LD_VAR 0 4
33815: PPUSH
33816: CALL_OW 314
33820: NOT
33821: PUSH
33822: LD_VAR 0 3
33826: PUSH
33827: LD_INT 1
33829: ARRAY
33830: PUSH
33831: LD_VAR 0 3
33835: PUSH
33836: LD_INT 2
33838: ARRAY
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_LOC 77
33848: PUSH
33849: LD_LOC 78
33853: ADD
33854: PUSH
33855: LD_LOC 79
33859: ADD
33860: IN
33861: NOT
33862: AND
33863: IFFALSE 34045
// begin ComCollect ( cargo , list [ 1 ] , list [ 2 ] ) ;
33865: LD_VAR 0 4
33869: PPUSH
33870: LD_VAR 0 3
33874: PUSH
33875: LD_INT 1
33877: ARRAY
33878: PPUSH
33879: LD_VAR 0 3
33883: PUSH
33884: LD_INT 2
33886: ARRAY
33887: PPUSH
33888: CALL_OW 117
// case side of us :
33892: LD_VAR 0 2
33896: PUSH
33897: LD_EXP 3
33901: DOUBLE
33902: EQUAL
33903: IFTRUE 33907
33905: GO 33946
33907: POP
// us_bay := us_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ru :
33908: LD_ADDR_LOC 74
33912: PUSH
33913: LD_LOC 74
33917: PUSH
33918: LD_VAR 0 3
33922: PUSH
33923: LD_INT 1
33925: ARRAY
33926: PUSH
33927: LD_VAR 0 3
33931: PUSH
33932: LD_INT 2
33934: ARRAY
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: EMPTY
33941: LIST
33942: ADD
33943: ST_TO_ADDR
33944: GO 34045
33946: LD_EXP 2
33950: DOUBLE
33951: EQUAL
33952: IFTRUE 33956
33954: GO 33995
33956: POP
// ru_bay := ru_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ar :
33957: LD_ADDR_LOC 75
33961: PUSH
33962: LD_LOC 75
33966: PUSH
33967: LD_VAR 0 3
33971: PUSH
33972: LD_INT 1
33974: ARRAY
33975: PUSH
33976: LD_VAR 0 3
33980: PUSH
33981: LD_INT 2
33983: ARRAY
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: EMPTY
33990: LIST
33991: ADD
33992: ST_TO_ADDR
33993: GO 34045
33995: LD_EXP 4
33999: DOUBLE
34000: EQUAL
34001: IFTRUE 34005
34003: GO 34044
34005: POP
// ar_bay := ar_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; end ;
34006: LD_ADDR_LOC 76
34010: PUSH
34011: LD_LOC 76
34015: PUSH
34016: LD_VAR 0 3
34020: PUSH
34021: LD_INT 1
34023: ARRAY
34024: PUSH
34025: LD_VAR 0 3
34029: PUSH
34030: LD_INT 2
34032: ARRAY
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: ADD
34041: ST_TO_ADDR
34042: GO 34045
34044: POP
// end ; end ; end ; list := GetListOfCratesInArea ( inside_list [ side ] ) ;
34045: LD_ADDR_VAR 0 3
34049: PUSH
34050: LD_LOC 71
34054: PUSH
34055: LD_VAR 0 2
34059: ARRAY
34060: PPUSH
34061: CALL_OW 435
34065: ST_TO_ADDR
// if list then
34066: LD_VAR 0 3
34070: IFFALSE 34175
// begin engineers := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
34072: LD_ADDR_VAR 0 6
34076: PUSH
34077: LD_INT 22
34079: PUSH
34080: LD_VAR 0 2
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 21
34091: PUSH
34092: LD_INT 1
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 25
34101: PUSH
34102: LD_INT 2
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: LIST
34113: PPUSH
34114: CALL_OW 69
34118: ST_TO_ADDR
// for un in engineers do
34119: LD_ADDR_VAR 0 1
34123: PUSH
34124: LD_VAR 0 6
34128: PUSH
34129: FOR_IN
34130: IFFALSE 34173
// if not GetUnitMc ( un ) then
34132: LD_VAR 0 1
34136: PPUSH
34137: CALL_OW 388
34141: NOT
34142: IFFALSE 34171
// ComCollect ( un , list [ 1 ] , list [ 2 ] ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: LD_VAR 0 3
34153: PUSH
34154: LD_INT 1
34156: ARRAY
34157: PPUSH
34158: LD_VAR 0 3
34162: PUSH
34163: LD_INT 2
34165: ARRAY
34166: PPUSH
34167: CALL_OW 117
34171: GO 34129
34173: POP
34174: POP
// end ; end ;
34175: GO 33649
34177: POP
34178: POP
// enable ;
34179: ENABLE
// end ;
34180: PPOPN 6
34182: END
// every 1 1$0.6 do var un , n_cargo , cargo , side ;
34183: GO 34185
34185: DISABLE
34186: LD_INT 0
34188: PPUSH
34189: PPUSH
34190: PPUSH
34191: PPUSH
// begin for side in cpu_list do
34192: LD_ADDR_VAR 0 4
34196: PUSH
34197: LD_EXP 8
34201: PUSH
34202: FOR_IN
34203: IFFALSE 34642
// begin case side of 1 :
34205: LD_VAR 0 4
34209: PUSH
34210: LD_INT 1
34212: DOUBLE
34213: EQUAL
34214: IFTRUE 34218
34216: GO 34229
34218: POP
// n_cargo := us_cargo_bay ; 2 :
34219: LD_ADDR_VAR 0 2
34223: PUSH
34224: LD_INT 12
34226: ST_TO_ADDR
34227: GO 34268
34229: LD_INT 2
34231: DOUBLE
34232: EQUAL
34233: IFTRUE 34237
34235: GO 34248
34237: POP
// n_cargo := ar_cargo_bay ; 3 :
34238: LD_ADDR_VAR 0 2
34242: PUSH
34243: LD_INT 32
34245: ST_TO_ADDR
34246: GO 34268
34248: LD_INT 3
34250: DOUBLE
34251: EQUAL
34252: IFTRUE 34256
34254: GO 34267
34256: POP
// n_cargo := ru_cargo_bay ; end ;
34257: LD_ADDR_VAR 0 2
34261: PUSH
34262: LD_INT 51
34264: ST_TO_ADDR
34265: GO 34268
34267: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34268: LD_ADDR_VAR 0 3
34272: PUSH
34273: LD_INT 22
34275: PUSH
34276: LD_VAR 0 4
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 21
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 34
34297: PUSH
34298: LD_VAR 0 2
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: LIST
34311: PPUSH
34312: CALL_OW 69
34316: ST_TO_ADDR
// if not ( cargo or FilterUnitsInArea ( base_areas [ side ] , [ [ f_side , you ] ] ) ) then
34317: LD_VAR 0 3
34321: PUSH
34322: LD_LOC 72
34326: PUSH
34327: LD_VAR 0 4
34331: ARRAY
34332: PPUSH
34333: LD_INT 22
34335: PUSH
34336: LD_EXP 1
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: EMPTY
34346: LIST
34347: PPUSH
34348: CALL_OW 70
34352: OR
34353: NOT
34354: IFFALSE 34640
// begin uc_side := side ;
34356: LD_ADDR_OWVAR 20
34360: PUSH
34361: LD_VAR 0 4
34365: ST_TO_ADDR
// case side of 1 :
34366: LD_VAR 0 4
34370: PUSH
34371: LD_INT 1
34373: DOUBLE
34374: EQUAL
34375: IFTRUE 34379
34377: GO 34390
34379: POP
// uc_nation := nation_american ; 2 :
34380: LD_ADDR_OWVAR 21
34384: PUSH
34385: LD_INT 1
34387: ST_TO_ADDR
34388: GO 34429
34390: LD_INT 2
34392: DOUBLE
34393: EQUAL
34394: IFTRUE 34398
34396: GO 34409
34398: POP
// uc_nation := nation_arabian ; 3 :
34399: LD_ADDR_OWVAR 21
34403: PUSH
34404: LD_INT 2
34406: ST_TO_ADDR
34407: GO 34429
34409: LD_INT 3
34411: DOUBLE
34412: EQUAL
34413: IFTRUE 34417
34415: GO 34428
34417: POP
// uc_nation := nation_russian ; end ;
34418: LD_ADDR_OWVAR 21
34422: PUSH
34423: LD_INT 3
34425: ST_TO_ADDR
34426: GO 34429
34428: POP
// uc_direction := Rand ( 0 , 5 ) ;
34429: LD_ADDR_OWVAR 24
34433: PUSH
34434: LD_INT 0
34436: PPUSH
34437: LD_INT 5
34439: PPUSH
34440: CALL_OW 12
34444: ST_TO_ADDR
// case side of 1 :
34445: LD_VAR 0 4
34449: PUSH
34450: LD_INT 1
34452: DOUBLE
34453: EQUAL
34454: IFTRUE 34458
34456: GO 34469
34458: POP
// vc_chassis := us_medium_tracked ; 2 :
34459: LD_ADDR_OWVAR 37
34463: PUSH
34464: LD_INT 3
34466: ST_TO_ADDR
34467: GO 34508
34469: LD_INT 2
34471: DOUBLE
34472: EQUAL
34473: IFTRUE 34477
34475: GO 34488
34477: POP
// vc_chassis := ar_half_tracked ; 3 :
34478: LD_ADDR_OWVAR 37
34482: PUSH
34483: LD_INT 14
34485: ST_TO_ADDR
34486: GO 34508
34488: LD_INT 3
34490: DOUBLE
34491: EQUAL
34492: IFTRUE 34496
34494: GO 34507
34496: POP
// vc_chassis := ru_medium_tracked ; end ;
34497: LD_ADDR_OWVAR 37
34501: PUSH
34502: LD_INT 22
34504: ST_TO_ADDR
34505: GO 34508
34507: POP
// vc_engine := engine_siberite ;
34508: LD_ADDR_OWVAR 39
34512: PUSH
34513: LD_INT 3
34515: ST_TO_ADDR
// case side of 1 :
34516: LD_VAR 0 4
34520: PUSH
34521: LD_INT 1
34523: DOUBLE
34524: EQUAL
34525: IFTRUE 34529
34527: GO 34540
34529: POP
// vc_control := control_computer ; 2 :
34530: LD_ADDR_OWVAR 38
34534: PUSH
34535: LD_INT 3
34537: ST_TO_ADDR
34538: GO 34579
34540: LD_INT 2
34542: DOUBLE
34543: EQUAL
34544: IFTRUE 34548
34546: GO 34559
34548: POP
// vc_control := control_apeman ; 3 :
34549: LD_ADDR_OWVAR 38
34553: PUSH
34554: LD_INT 5
34556: ST_TO_ADDR
34557: GO 34579
34559: LD_INT 3
34561: DOUBLE
34562: EQUAL
34563: IFTRUE 34567
34565: GO 34578
34567: POP
// vc_control := control_computer ; end ;
34568: LD_ADDR_OWVAR 38
34572: PUSH
34573: LD_INT 3
34575: ST_TO_ADDR
34576: GO 34579
34578: POP
// vc_weapon := n_cargo ;
34579: LD_ADDR_OWVAR 40
34583: PUSH
34584: LD_VAR 0 2
34588: ST_TO_ADDR
// un := CreateVehicle ;
34589: LD_ADDR_VAR 0 1
34593: PUSH
34594: CALL_OW 45
34598: ST_TO_ADDR
// while GetTag ( 83 ) do
34599: LD_INT 83
34601: PPUSH
34602: CALL_OW 110
34606: IFFALSE 34617
// wait ( 0 0$1 ) ;
34608: LD_INT 35
34610: PPUSH
34611: CALL_OW 67
34615: GO 34599
// PlaceUnitArea ( un , create_areas [ side ] , false ) ;
34617: LD_VAR 0 1
34621: PPUSH
34622: LD_LOC 73
34626: PUSH
34627: LD_VAR 0 4
34631: ARRAY
34632: PPUSH
34633: LD_INT 0
34635: PPUSH
34636: CALL_OW 49
// end ; end ;
34640: GO 34202
34642: POP
34643: POP
// enable ;
34644: ENABLE
// end ;
34645: PPOPN 4
34647: END
// export function remove_bad_crates ( side ) ; var list , un , x , y ; begin
34648: LD_INT 0
34650: PPUSH
34651: PPUSH
34652: PPUSH
34653: PPUSH
34654: PPUSH
// case side of us :
34655: LD_VAR 0 1
34659: PUSH
34660: LD_EXP 3
34664: DOUBLE
34665: EQUAL
34666: IFTRUE 34670
34668: GO 34741
34670: POP
// begin x := us_bay [ us_bad ] [ 1 ] ;
34671: LD_ADDR_VAR 0 5
34675: PUSH
34676: LD_LOC 74
34680: PUSH
34681: LD_LOC 77
34685: ARRAY
34686: PUSH
34687: LD_INT 1
34689: ARRAY
34690: ST_TO_ADDR
// y := us_bay [ us_bad ] [ 2 ] ;
34691: LD_ADDR_VAR 0 6
34695: PUSH
34696: LD_LOC 74
34700: PUSH
34701: LD_LOC 77
34705: ARRAY
34706: PUSH
34707: LD_INT 2
34709: ARRAY
34710: ST_TO_ADDR
// us_bad := us_bad ^ [ [ x , y ] ] ;
34711: LD_ADDR_LOC 77
34715: PUSH
34716: LD_LOC 77
34720: PUSH
34721: LD_VAR 0 5
34725: PUSH
34726: LD_VAR 0 6
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: ADD
34738: ST_TO_ADDR
// end ; ru :
34739: GO 34904
34741: LD_EXP 2
34745: DOUBLE
34746: EQUAL
34747: IFTRUE 34751
34749: GO 34822
34751: POP
// begin x := ru_bay [ us_bad ] [ 1 ] ;
34752: LD_ADDR_VAR 0 5
34756: PUSH
34757: LD_LOC 75
34761: PUSH
34762: LD_LOC 77
34766: ARRAY
34767: PUSH
34768: LD_INT 1
34770: ARRAY
34771: ST_TO_ADDR
// y := ru_bay [ us_bad ] [ 2 ] ;
34772: LD_ADDR_VAR 0 6
34776: PUSH
34777: LD_LOC 75
34781: PUSH
34782: LD_LOC 77
34786: ARRAY
34787: PUSH
34788: LD_INT 2
34790: ARRAY
34791: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34792: LD_ADDR_LOC 78
34796: PUSH
34797: LD_LOC 78
34801: PUSH
34802: LD_VAR 0 5
34806: PUSH
34807: LD_VAR 0 6
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: EMPTY
34817: LIST
34818: ADD
34819: ST_TO_ADDR
// end ; ar :
34820: GO 34904
34822: LD_EXP 4
34826: DOUBLE
34827: EQUAL
34828: IFTRUE 34832
34830: GO 34903
34832: POP
// begin x := ar_bay [ us_bad ] [ 1 ] ;
34833: LD_ADDR_VAR 0 5
34837: PUSH
34838: LD_LOC 76
34842: PUSH
34843: LD_LOC 77
34847: ARRAY
34848: PUSH
34849: LD_INT 1
34851: ARRAY
34852: ST_TO_ADDR
// y := ar_bay [ us_bad ] [ 2 ] ;
34853: LD_ADDR_VAR 0 6
34857: PUSH
34858: LD_LOC 76
34862: PUSH
34863: LD_LOC 77
34867: ARRAY
34868: PUSH
34869: LD_INT 2
34871: ARRAY
34872: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
34873: LD_ADDR_LOC 78
34877: PUSH
34878: LD_LOC 78
34882: PUSH
34883: LD_VAR 0 5
34887: PUSH
34888: LD_VAR 0 6
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: EMPTY
34898: LIST
34899: ADD
34900: ST_TO_ADDR
// end ; end ;
34901: GO 34904
34903: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ;
34904: LD_ADDR_VAR 0 3
34908: PUSH
34909: LD_INT 22
34911: PUSH
34912: LD_VAR 0 1
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 21
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 25
34933: PUSH
34934: LD_INT 2
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 50
34943: PUSH
34944: EMPTY
34945: LIST
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: PPUSH
34953: CALL_OW 69
34957: ST_TO_ADDR
// for un in list do
34958: LD_ADDR_VAR 0 4
34962: PUSH
34963: LD_VAR 0 3
34967: PUSH
34968: FOR_IN
34969: IFFALSE 35022
// if not GetUnitMc ( un ) then
34971: LD_VAR 0 4
34975: PPUSH
34976: CALL_OW 388
34980: NOT
34981: IFFALSE 35020
// begin ComRemember ( un ) ;
34983: LD_VAR 0 4
34987: PPUSH
34988: CALL_OW 143
// AddComCollect ( un , x , y ) ;
34992: LD_VAR 0 4
34996: PPUSH
34997: LD_VAR 0 5
35001: PPUSH
35002: LD_VAR 0 6
35006: PPUSH
35007: CALL_OW 177
// AddComReturn ( un ) ;
35011: LD_VAR 0 4
35015: PPUSH
35016: CALL_OW 204
// end ;
35020: GO 34968
35022: POP
35023: POP
// end ;
35024: LD_VAR 0 2
35028: RET
// every 0 0$7.9 trigger us_bad do var un , list ;
35029: LD_LOC 77
35033: IFFALSE 35130
35035: GO 35037
35037: DISABLE
35038: LD_INT 0
35040: PPUSH
35041: PPUSH
// begin list := [ ] ;
35042: LD_ADDR_VAR 0 2
35046: PUSH
35047: EMPTY
35048: ST_TO_ADDR
// for un in us_bad do
35049: LD_ADDR_VAR 0 1
35053: PUSH
35054: LD_LOC 77
35058: PUSH
35059: FOR_IN
35060: IFFALSE 35117
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35062: LD_INT 35
35064: PPUSH
35065: LD_VAR 0 1
35069: PUSH
35070: LD_INT 1
35072: ARRAY
35073: PPUSH
35074: LD_VAR 0 1
35078: PUSH
35079: LD_INT 2
35081: ARRAY
35082: PPUSH
35083: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35087: LD_INT 35
35089: PPUSH
35090: CALL_OW 435
35094: IFFALSE 35115
// list := list ^ [ un ] ;
35096: LD_ADDR_VAR 0 2
35100: PUSH
35101: LD_VAR 0 2
35105: PUSH
35106: LD_VAR 0 1
35110: PUSH
35111: EMPTY
35112: LIST
35113: ADD
35114: ST_TO_ADDR
// end ;
35115: GO 35059
35117: POP
35118: POP
// us_bad := list ;
35119: LD_ADDR_LOC 77
35123: PUSH
35124: LD_VAR 0 2
35128: ST_TO_ADDR
// enable ;
35129: ENABLE
// end ;
35130: PPOPN 2
35132: END
// every 0 0$7.8 trigger ru_bad do var un , list ;
35133: LD_LOC 78
35137: IFFALSE 35234
35139: GO 35141
35141: DISABLE
35142: LD_INT 0
35144: PPUSH
35145: PPUSH
// begin list := [ ] ;
35146: LD_ADDR_VAR 0 2
35150: PUSH
35151: EMPTY
35152: ST_TO_ADDR
// for un in ru_bad do
35153: LD_ADDR_VAR 0 1
35157: PUSH
35158: LD_LOC 78
35162: PUSH
35163: FOR_IN
35164: IFFALSE 35221
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35166: LD_INT 35
35168: PPUSH
35169: LD_VAR 0 1
35173: PUSH
35174: LD_INT 1
35176: ARRAY
35177: PPUSH
35178: LD_VAR 0 1
35182: PUSH
35183: LD_INT 2
35185: ARRAY
35186: PPUSH
35187: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35191: LD_INT 35
35193: PPUSH
35194: CALL_OW 435
35198: IFFALSE 35219
// list := list ^ [ un ] ;
35200: LD_ADDR_VAR 0 2
35204: PUSH
35205: LD_VAR 0 2
35209: PUSH
35210: LD_VAR 0 1
35214: PUSH
35215: EMPTY
35216: LIST
35217: ADD
35218: ST_TO_ADDR
// end ;
35219: GO 35163
35221: POP
35222: POP
// ru_bad := list ;
35223: LD_ADDR_LOC 78
35227: PUSH
35228: LD_VAR 0 2
35232: ST_TO_ADDR
// enable ;
35233: ENABLE
// end ;
35234: PPOPN 2
35236: END
// every 0 0$7.7 trigger ar_bad do var un , list ;
35237: LD_LOC 79
35241: IFFALSE 35338
35243: GO 35245
35245: DISABLE
35246: LD_INT 0
35248: PPUSH
35249: PPUSH
// begin list := [ ] ;
35250: LD_ADDR_VAR 0 2
35254: PUSH
35255: EMPTY
35256: ST_TO_ADDR
// for un in ar_bad do
35257: LD_ADDR_VAR 0 1
35261: PUSH
35262: LD_LOC 79
35266: PUSH
35267: FOR_IN
35268: IFFALSE 35325
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35270: LD_INT 35
35272: PPUSH
35273: LD_VAR 0 1
35277: PUSH
35278: LD_INT 1
35280: ARRAY
35281: PPUSH
35282: LD_VAR 0 1
35286: PUSH
35287: LD_INT 2
35289: ARRAY
35290: PPUSH
35291: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35295: LD_INT 35
35297: PPUSH
35298: CALL_OW 435
35302: IFFALSE 35323
// list := list ^ [ un ] ;
35304: LD_ADDR_VAR 0 2
35308: PUSH
35309: LD_VAR 0 2
35313: PUSH
35314: LD_VAR 0 1
35318: PUSH
35319: EMPTY
35320: LIST
35321: ADD
35322: ST_TO_ADDR
// end ;
35323: GO 35267
35325: POP
35326: POP
// ar_bad := list ;
35327: LD_ADDR_LOC 79
35331: PUSH
35332: LD_VAR 0 2
35336: ST_TO_ADDR
// enable ;
35337: ENABLE
// end ; end_of_file
35338: PPOPN 2
35340: END
// export function check_remote ( veh ) ; var un , towers , list , all_in , veh_n , veh_l , mech ; begin
35341: LD_INT 0
35343: PPUSH
35344: PPUSH
35345: PPUSH
35346: PPUSH
35347: PPUSH
35348: PPUSH
35349: PPUSH
35350: PPUSH
// list := [ ] ;
35351: LD_ADDR_VAR 0 5
35355: PUSH
35356: EMPTY
35357: ST_TO_ADDR
// veh_l := FilterAllUnits ( [ [ f_side , us ] , [ f_control , control_remote ] , [ f_ok ] ] ) union veh diff 0 ;
35358: LD_ADDR_VAR 0 8
35362: PUSH
35363: LD_INT 22
35365: PUSH
35366: LD_EXP 3
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 33
35377: PUSH
35378: LD_INT 2
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 50
35387: PUSH
35388: EMPTY
35389: LIST
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: LIST
35395: PPUSH
35396: CALL_OW 69
35400: PUSH
35401: LD_VAR 0 1
35405: UNION
35406: PUSH
35407: LD_INT 0
35409: DIFF
35410: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35411: LD_ADDR_VAR 0 4
35415: PUSH
35416: LD_INT 22
35418: PUSH
35419: LD_EXP 3
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 30
35430: PUSH
35431: LD_INT 36
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 50
35440: PUSH
35441: EMPTY
35442: LIST
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: LIST
35448: PPUSH
35449: CALL_OW 69
35453: ST_TO_ADDR
// if not towers then
35454: LD_VAR 0 4
35458: NOT
35459: IFFALSE 35463
// exit ;
35461: GO 36058
// towers := towers [ 1 ] ;
35463: LD_ADDR_VAR 0 4
35467: PUSH
35468: LD_VAR 0 4
35472: PUSH
35473: LD_INT 1
35475: ARRAY
35476: ST_TO_ADDR
// all_in := UnitsInside ( towers ) ;
35477: LD_ADDR_VAR 0 6
35481: PUSH
35482: LD_VAR 0 4
35486: PPUSH
35487: CALL_OW 313
35491: ST_TO_ADDR
// mech := all_in ^ ( FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] , [ f_ok ] ] ) diff reserved_people [ us ] ) ;
35492: LD_ADDR_VAR 0 9
35496: PUSH
35497: LD_VAR 0 6
35501: PUSH
35502: LD_INT 22
35504: PUSH
35505: LD_EXP 3
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 21
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 25
35526: PUSH
35527: LD_INT 3
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 50
35536: PUSH
35537: EMPTY
35538: LIST
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: PPUSH
35546: CALL_OW 69
35550: PUSH
35551: LD_EXP 72
35555: PUSH
35556: LD_EXP 3
35560: ARRAY
35561: DIFF
35562: ADD
35563: ST_TO_ADDR
// for un in mech do
35564: LD_ADDR_VAR 0 3
35568: PUSH
35569: LD_VAR 0 9
35573: PUSH
35574: FOR_IN
35575: IFFALSE 35609
// list := list ^ FindMaxSkill ( mech diff list , skill_mechanical ) ;
35577: LD_ADDR_VAR 0 5
35581: PUSH
35582: LD_VAR 0 5
35586: PUSH
35587: LD_VAR 0 9
35591: PUSH
35592: LD_VAR 0 5
35596: DIFF
35597: PPUSH
35598: LD_INT 3
35600: PPUSH
35601: CALL_OW 433
35605: ADD
35606: ST_TO_ADDR
35607: GO 35574
35609: POP
35610: POP
// mech := [ ] ;
35611: LD_ADDR_VAR 0 9
35615: PUSH
35616: EMPTY
35617: ST_TO_ADDR
// veh_n := 0 + veh_l ;
35618: LD_ADDR_VAR 0 7
35622: PUSH
35623: LD_INT 0
35625: PUSH
35626: LD_VAR 0 8
35630: PLUS
35631: ST_TO_ADDR
// for un in list do
35632: LD_ADDR_VAR 0 3
35636: PUSH
35637: LD_VAR 0 5
35641: PUSH
35642: FOR_IN
35643: IFFALSE 35713
// if ( veh_n > 0 ) or ( ( list diff mech ) > 6 ) then
35645: LD_VAR 0 7
35649: PUSH
35650: LD_INT 0
35652: GREATER
35653: PUSH
35654: LD_VAR 0 5
35658: PUSH
35659: LD_VAR 0 9
35663: DIFF
35664: PUSH
35665: LD_INT 6
35667: GREATER
35668: OR
35669: IFFALSE 35711
// begin mech := mech ^ un ;
35671: LD_ADDR_VAR 0 9
35675: PUSH
35676: LD_VAR 0 9
35680: PUSH
35681: LD_VAR 0 3
35685: ADD
35686: ST_TO_ADDR
// veh_n := veh_n - GetSkill ( un , skill_mechanical ) ;
35687: LD_ADDR_VAR 0 7
35691: PUSH
35692: LD_VAR 0 7
35696: PUSH
35697: LD_VAR 0 3
35701: PPUSH
35702: LD_INT 3
35704: PPUSH
35705: CALL_OW 259
35709: MINUS
35710: ST_TO_ADDR
// end ;
35711: GO 35642
35713: POP
35714: POP
// un := reserved_people [ us ] ^ mech ;
35715: LD_ADDR_VAR 0 3
35719: PUSH
35720: LD_EXP 72
35724: PUSH
35725: LD_EXP 3
35729: ARRAY
35730: PUSH
35731: LD_VAR 0 9
35735: ADD
35736: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35737: LD_ADDR_EXP 72
35741: PUSH
35742: LD_EXP 72
35746: PPUSH
35747: LD_EXP 3
35751: PPUSH
35752: CALL_OW 3
35756: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35757: LD_ADDR_EXP 72
35761: PUSH
35762: LD_EXP 72
35766: PPUSH
35767: LD_EXP 3
35771: PPUSH
35772: LD_VAR 0 3
35776: PPUSH
35777: CALL_OW 2
35781: ST_TO_ADDR
// list := UnitsInside ( towers ) diff mech ;
35782: LD_ADDR_VAR 0 5
35786: PUSH
35787: LD_VAR 0 4
35791: PPUSH
35792: CALL_OW 313
35796: PUSH
35797: LD_VAR 0 9
35801: DIFF
35802: ST_TO_ADDR
// if list then
35803: LD_VAR 0 5
35807: IFFALSE 35963
// begin un := reserved_people [ us ] diff list ;
35809: LD_ADDR_VAR 0 3
35813: PUSH
35814: LD_EXP 72
35818: PUSH
35819: LD_EXP 3
35823: ARRAY
35824: PUSH
35825: LD_VAR 0 5
35829: DIFF
35830: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
35831: LD_ADDR_EXP 72
35835: PUSH
35836: LD_EXP 72
35840: PPUSH
35841: LD_EXP 3
35845: PPUSH
35846: CALL_OW 3
35850: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
35851: LD_ADDR_EXP 72
35855: PUSH
35856: LD_EXP 72
35860: PPUSH
35861: LD_EXP 3
35865: PPUSH
35866: LD_VAR 0 3
35870: PPUSH
35871: CALL_OW 2
35875: ST_TO_ADDR
// ComExitBuilding ( list ) ;
35876: LD_VAR 0 5
35880: PPUSH
35881: CALL_OW 122
// un := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
35885: LD_ADDR_VAR 0 3
35889: PUSH
35890: LD_INT 22
35892: PUSH
35893: LD_EXP 3
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 2
35904: PUSH
35905: LD_INT 30
35907: PUSH
35908: LD_INT 2
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 30
35917: PUSH
35918: LD_INT 3
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: LIST
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PPUSH
35934: CALL_OW 69
35938: ST_TO_ADDR
// if un then
35939: LD_VAR 0 3
35943: IFFALSE 35963
// AddComMoveUnit ( list , un [ 1 ] ) ;
35945: LD_VAR 0 5
35949: PPUSH
35950: LD_VAR 0 3
35954: PUSH
35955: LD_INT 1
35957: ARRAY
35958: PPUSH
35959: CALL_OW 172
// end ; repeat ComMoveUnit ( mech , towers ) ;
35963: LD_VAR 0 9
35967: PPUSH
35968: LD_VAR 0 4
35972: PPUSH
35973: CALL_OW 112
// all_in := true ;
35977: LD_ADDR_VAR 0 6
35981: PUSH
35982: LD_INT 1
35984: ST_TO_ADDR
// for un in mech do
35985: LD_ADDR_VAR 0 3
35989: PUSH
35990: LD_VAR 0 9
35994: PUSH
35995: FOR_IN
35996: IFFALSE 36028
// if not ( IsInUnit ( un ) = towers ) then
35998: LD_VAR 0 3
36002: PPUSH
36003: CALL_OW 310
36007: PUSH
36008: LD_VAR 0 4
36012: EQUAL
36013: NOT
36014: IFFALSE 36026
// begin all_in := false ;
36016: LD_ADDR_VAR 0 6
36020: PUSH
36021: LD_INT 0
36023: ST_TO_ADDR
// break ;
36024: GO 36028
// end ;
36026: GO 35995
36028: POP
36029: POP
// wait ( 0 0$1 ) ;
36030: LD_INT 35
36032: PPUSH
36033: CALL_OW 67
// until all_in ;
36037: LD_VAR 0 6
36041: IFFALSE 35963
// ComLinkTo ( veh_l , towers ) ;
36043: LD_VAR 0 8
36047: PPUSH
36048: LD_VAR 0 4
36052: PPUSH
36053: CALL_OW 135
// enable ;
36057: ENABLE
// end ;
36058: LD_VAR 0 2
36062: RET
// every 0 0$10 do var list , tower ;
36063: GO 36065
36065: DISABLE
36066: LD_INT 0
36068: PPUSH
36069: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_ok ] , [ f_control , control_remote ] , f_not , [ f_linked ] ] ) ;
36070: LD_ADDR_VAR 0 1
36074: PUSH
36075: LD_INT 22
36077: PUSH
36078: LD_EXP 3
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 50
36089: PUSH
36090: EMPTY
36091: LIST
36092: PUSH
36093: LD_INT 33
36095: PUSH
36096: LD_INT 2
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 3
36105: PUSH
36106: LD_INT 61
36108: PUSH
36109: EMPTY
36110: LIST
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: PPUSH
36119: CALL_OW 69
36123: ST_TO_ADDR
// if list then
36124: LD_VAR 0 1
36128: IFFALSE 36212
// begin tower := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
36130: LD_ADDR_VAR 0 2
36134: PUSH
36135: LD_INT 22
36137: PUSH
36138: LD_EXP 3
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 30
36149: PUSH
36150: LD_INT 36
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 50
36159: PUSH
36160: EMPTY
36161: LIST
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: LIST
36167: PPUSH
36168: CALL_OW 69
36172: ST_TO_ADDR
// if tower then
36173: LD_VAR 0 2
36177: IFFALSE 36195
// tower := tower [ 1 ] else
36179: LD_ADDR_VAR 0 2
36183: PUSH
36184: LD_VAR 0 2
36188: PUSH
36189: LD_INT 1
36191: ARRAY
36192: ST_TO_ADDR
36193: GO 36198
// begin enable ;
36195: ENABLE
// exit ;
36196: GO 36213
// end ; ComLinkTo ( list , tower ) ;
36198: LD_VAR 0 1
36202: PPUSH
36203: LD_VAR 0 2
36207: PPUSH
36208: CALL_OW 135
// end ; enable ;
36212: ENABLE
// end ; end_of_file
36213: PPOPN 2
36215: END
// export us_sib_wait , ru_sib_wait ; var time_to_end ; export function init_sib_rocket ; begin
36216: LD_INT 0
36218: PPUSH
// us_sib_wait := false ;
36219: LD_ADDR_EXP 75
36223: PUSH
36224: LD_INT 0
36226: ST_TO_ADDR
// ru_sib_wait := false ;
36227: LD_ADDR_EXP 76
36231: PUSH
36232: LD_INT 0
36234: ST_TO_ADDR
// time_to_end := [ 85 85$0 , 65 65$0 , 45 45$0 ] [ difficulty ] ;
36235: LD_ADDR_LOC 80
36239: PUSH
36240: LD_INT 178500
36242: PUSH
36243: LD_INT 136500
36245: PUSH
36246: LD_INT 94500
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: LIST
36253: PUSH
36254: LD_OWVAR 67
36258: ARRAY
36259: ST_TO_ADDR
// end ;
36260: LD_VAR 0 1
36264: RET
// every 0 0$1.5 trigger TICK > time_to_end marked 4 do var factory , zdroje ;
36265: LD_OWVAR 1
36269: PUSH
36270: LD_LOC 80
36274: GREATER
36275: IFFALSE 36508
36277: GO 36279
36279: DISABLE
36280: LD_INT 0
36282: PPUSH
36283: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_factory ] ] ) ;
36284: LD_ADDR_VAR 0 1
36288: PUSH
36289: LD_INT 22
36291: PUSH
36292: LD_EXP 3
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 30
36303: PUSH
36304: LD_INT 3
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PPUSH
36315: CALL_OW 69
36319: ST_TO_ADDR
// if factory then
36320: LD_VAR 0 1
36324: IFFALSE 36507
// begin factory := factory [ 1 ] ;
36326: LD_ADDR_VAR 0 1
36330: PUSH
36331: LD_VAR 0 1
36335: PUSH
36336: LD_INT 1
36338: ARRAY
36339: ST_TO_ADDR
// if us_siberium_rocket in AvailableWeaponList ( factory ) then
36340: LD_INT 8
36342: PUSH
36343: LD_VAR 0 1
36347: PPUSH
36348: CALL_OW 478
36352: IN
36353: IFFALSE 36507
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36355: LD_ADDR_VAR 0 2
36359: PUSH
36360: LD_VAR 0 1
36364: PPUSH
36365: CALL_OW 274
36369: PPUSH
36370: CALL_OW 279
36374: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36375: LD_VAR 0 2
36379: PUSH
36380: LD_INT 1
36382: ARRAY
36383: PUSH
36384: LD_INT 75
36386: GREATEREQUAL
36387: PUSH
36388: LD_VAR 0 2
36392: PUSH
36393: LD_INT 2
36395: ARRAY
36396: PUSH
36397: LD_INT 30
36399: GREATEREQUAL
36400: PUSH
36401: LD_VAR 0 2
36405: PUSH
36406: LD_INT 3
36408: ARRAY
36409: PUSH
36410: LD_INT 70
36412: GREATEREQUAL
36413: OR
36414: AND
36415: PUSH
36416: LD_VAR 0 2
36420: PUSH
36421: LD_INT 3
36423: ARRAY
36424: PUSH
36425: LD_INT 60
36427: GREATEREQUAL
36428: AND
36429: IFFALSE 36499
// begin if zdroje [ 3 ] >= 70 then
36431: LD_VAR 0 2
36435: PUSH
36436: LD_INT 3
36438: ARRAY
36439: PUSH
36440: LD_INT 70
36442: GREATEREQUAL
36443: IFFALSE 36468
// ComConstruct ( factory , us_morphling , engine_siberite , control_remote , us_siberium_rocket ) else
36445: LD_VAR 0 1
36449: PPUSH
36450: LD_INT 5
36452: PPUSH
36453: LD_INT 3
36455: PPUSH
36456: LD_INT 2
36458: PPUSH
36459: LD_INT 8
36461: PPUSH
36462: CALL_OW 125
36466: GO 36489
// ComConstruct ( factory , us_morphling , engine_combustion , control_remote , us_siberium_rocket ) ;
36468: LD_VAR 0 1
36472: PPUSH
36473: LD_INT 5
36475: PPUSH
36476: LD_INT 1
36478: PPUSH
36479: LD_INT 2
36481: PPUSH
36482: LD_INT 8
36484: PPUSH
36485: CALL_OW 125
// us_sib_wait := false ;
36489: LD_ADDR_EXP 75
36493: PUSH
36494: LD_INT 0
36496: ST_TO_ADDR
// end else
36497: GO 36507
// us_sib_wait := true ;
36499: LD_ADDR_EXP 75
36503: PUSH
36504: LD_INT 1
36506: ST_TO_ADDR
// end ; end ; enable ;
36507: ENABLE
// end ;
36508: PPOPN 2
36510: END
// every 0 0$1.5 trigger TICK > time_to_end marked 5 do var factory , zdroje ;
36511: LD_OWVAR 1
36515: PUSH
36516: LD_LOC 80
36520: GREATER
36521: IFFALSE 36754
36523: GO 36525
36525: DISABLE
36526: LD_INT 0
36528: PPUSH
36529: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , ru ] , [ f_btype , b_factory ] ] ) ;
36530: LD_ADDR_VAR 0 1
36534: PUSH
36535: LD_INT 22
36537: PUSH
36538: LD_EXP 2
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 30
36549: PUSH
36550: LD_INT 3
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PPUSH
36561: CALL_OW 69
36565: ST_TO_ADDR
// if factory then
36566: LD_VAR 0 1
36570: IFFALSE 36753
// begin factory := factory [ 1 ] ;
36572: LD_ADDR_VAR 0 1
36576: PUSH
36577: LD_VAR 0 1
36581: PUSH
36582: LD_INT 1
36584: ARRAY
36585: ST_TO_ADDR
// if ru_siberium_rocket in AvailableWeaponList ( factory ) then
36586: LD_INT 48
36588: PUSH
36589: LD_VAR 0 1
36593: PPUSH
36594: CALL_OW 478
36598: IN
36599: IFFALSE 36753
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36601: LD_ADDR_VAR 0 2
36605: PUSH
36606: LD_VAR 0 1
36610: PPUSH
36611: CALL_OW 274
36615: PPUSH
36616: CALL_OW 279
36620: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36621: LD_VAR 0 2
36625: PUSH
36626: LD_INT 1
36628: ARRAY
36629: PUSH
36630: LD_INT 75
36632: GREATEREQUAL
36633: PUSH
36634: LD_VAR 0 2
36638: PUSH
36639: LD_INT 2
36641: ARRAY
36642: PUSH
36643: LD_INT 30
36645: GREATEREQUAL
36646: PUSH
36647: LD_VAR 0 2
36651: PUSH
36652: LD_INT 3
36654: ARRAY
36655: PUSH
36656: LD_INT 70
36658: GREATEREQUAL
36659: OR
36660: AND
36661: PUSH
36662: LD_VAR 0 2
36666: PUSH
36667: LD_INT 3
36669: ARRAY
36670: PUSH
36671: LD_INT 60
36673: GREATEREQUAL
36674: AND
36675: IFFALSE 36745
// begin if zdroje [ 3 ] >= 70 then
36677: LD_VAR 0 2
36681: PUSH
36682: LD_INT 3
36684: ARRAY
36685: PUSH
36686: LD_INT 70
36688: GREATEREQUAL
36689: IFFALSE 36714
// ComConstruct ( factory , ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ) else
36691: LD_VAR 0 1
36695: PPUSH
36696: LD_INT 23
36698: PPUSH
36699: LD_INT 3
36701: PPUSH
36702: LD_INT 3
36704: PPUSH
36705: LD_INT 48
36707: PPUSH
36708: CALL_OW 125
36712: GO 36735
// ComConstruct ( factory , ru_heavy_wheeled , engine_combustion , control_computer , ru_siberium_rocket ) ;
36714: LD_VAR 0 1
36718: PPUSH
36719: LD_INT 23
36721: PPUSH
36722: LD_INT 1
36724: PPUSH
36725: LD_INT 3
36727: PPUSH
36728: LD_INT 48
36730: PPUSH
36731: CALL_OW 125
// ru_sib_wait := false ;
36735: LD_ADDR_EXP 76
36739: PUSH
36740: LD_INT 0
36742: ST_TO_ADDR
// end else
36743: GO 36753
// ru_sib_wait := true ;
36745: LD_ADDR_EXP 76
36749: PUSH
36750: LD_INT 1
36752: ST_TO_ADDR
// end ; end ; enable ;
36753: ENABLE
// end ;
36754: PPOPN 2
36756: END
// export function send_sib_to_US ( veh ) ; var n_check , s_check , send ; begin
36757: LD_INT 0
36759: PPUSH
36760: PPUSH
36761: PPUSH
36762: PPUSH
// repeat n_check := FilterUnitsInArea ( north_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36763: LD_ADDR_VAR 0 3
36767: PUSH
36768: LD_INT 25
36770: PPUSH
36771: LD_INT 21
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 3
36783: PUSH
36784: LD_INT 22
36786: PUSH
36787: LD_EXP 2
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: PPUSH
36801: CALL_OW 70
36805: ST_TO_ADDR
// s_check := FilterUnitsInArea ( south_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
36806: LD_ADDR_VAR 0 4
36810: PUSH
36811: LD_INT 26
36813: PPUSH
36814: LD_INT 21
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 3
36826: PUSH
36827: LD_INT 22
36829: PUSH
36830: LD_EXP 2
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: LIST
36843: PPUSH
36844: CALL_OW 70
36848: ST_TO_ADDR
// wait ( 0 0$2 ) ;
36849: LD_INT 70
36851: PPUSH
36852: CALL_OW 67
// until ( n_check < 3 ) and ( s_check < 3 ) ;
36856: LD_VAR 0 3
36860: PUSH
36861: LD_INT 3
36863: LESS
36864: PUSH
36865: LD_VAR 0 4
36869: PUSH
36870: LD_INT 3
36872: LESS
36873: AND
36874: IFFALSE 36763
// ComMoveXY ( veh , 144 , 65 ) ;
36876: LD_VAR 0 1
36880: PPUSH
36881: LD_INT 144
36883: PPUSH
36884: LD_INT 65
36886: PPUSH
36887: CALL_OW 111
// if n_check < s_check then
36891: LD_VAR 0 3
36895: PUSH
36896: LD_VAR 0 4
36900: LESS
36901: IFFALSE 36950
// begin AddComMoveXY ( veh , 87 , 35 ) ;
36903: LD_VAR 0 1
36907: PPUSH
36908: LD_INT 87
36910: PPUSH
36911: LD_INT 35
36913: PPUSH
36914: CALL_OW 171
// AddComMoveXY ( veh , 42 , 16 ) ;
36918: LD_VAR 0 1
36922: PPUSH
36923: LD_INT 42
36925: PPUSH
36926: LD_INT 16
36928: PPUSH
36929: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 56 ) ;
36933: LD_VAR 0 1
36937: PPUSH
36938: LD_INT 41
36940: PPUSH
36941: LD_INT 56
36943: PPUSH
36944: CALL_OW 176
// end else
36948: GO 37042
// begin AddComMoveXY ( veh , 141 , 116 ) ;
36950: LD_VAR 0 1
36954: PPUSH
36955: LD_INT 141
36957: PPUSH
36958: LD_INT 116
36960: PPUSH
36961: CALL_OW 171
// AddComMoveXY ( veh , 109 , 110 ) ;
36965: LD_VAR 0 1
36969: PPUSH
36970: LD_INT 109
36972: PPUSH
36973: LD_INT 110
36975: PPUSH
36976: CALL_OW 171
// if GetChassis ( veh ) = ru_heavy_tracked then
36980: LD_VAR 0 1
36984: PPUSH
36985: CALL_OW 265
36989: PUSH
36990: LD_INT 24
36992: EQUAL
36993: IFFALSE 37012
// AddComMoveXY ( veh , 86 , 106 ) else
36995: LD_VAR 0 1
36999: PPUSH
37000: LD_INT 86
37002: PPUSH
37003: LD_INT 106
37005: PPUSH
37006: CALL_OW 171
37010: GO 37027
// AddComMoveXY ( veh , 85 , 75 ) ;
37012: LD_VAR 0 1
37016: PPUSH
37017: LD_INT 85
37019: PPUSH
37020: LD_INT 75
37022: PPUSH
37023: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 66 ) ;
37027: LD_VAR 0 1
37031: PPUSH
37032: LD_INT 41
37034: PPUSH
37035: LD_INT 66
37037: PPUSH
37038: CALL_OW 176
// end ; end ; end_of_file
37042: LD_VAR 0 2
37046: RET
// export artefact_number , artefact_num , artefact_size ; export labs_in_use ; export function init_alien_research ; var art_icons , art_events , art_difficulty , art_cost , art_recharge ; begin
37047: LD_INT 0
37049: PPUSH
37050: PPUSH
37051: PPUSH
37052: PPUSH
37053: PPUSH
37054: PPUSH
// artefact_number := 3 ;
37055: LD_ADDR_EXP 77
37059: PUSH
37060: LD_INT 3
37062: ST_TO_ADDR
// artefact_num := [ 0 , 0 , 1 , 2 , 3 ] ;
37063: LD_ADDR_EXP 78
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: LD_INT 1
37076: PUSH
37077: LD_INT 2
37079: PUSH
37080: LD_INT 3
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: ST_TO_ADDR
// artefact_size := [ 3 , 4 , 5 ] ;
37090: LD_ADDR_EXP 79
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: LD_INT 4
37100: PUSH
37101: LD_INT 5
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: LIST
37108: ST_TO_ADDR
// art_icons := [ [ art_exp_left , art_use_eye ] , [ art_exp_mid , art_use_sibexplosion ] , [ art_exp_right , art_use_power ] ] ;
37109: LD_ADDR_VAR 0 2
37113: PUSH
37114: LD_INT 1
37116: PUSH
37117: LD_INT 4
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: PUSH
37124: LD_INT 2
37126: PUSH
37127: LD_INT 5
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 3
37136: PUSH
37137: LD_INT 9
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: LIST
37148: ST_TO_ADDR
// art_events := [ art_place , art_unit , art_place ] ;
37149: LD_ADDR_VAR 0 3
37153: PUSH
37154: LD_INT 3
37156: PUSH
37157: LD_INT 4
37159: PUSH
37160: LD_INT 3
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: LIST
37167: ST_TO_ADDR
// art_difficulty := [ 150 , 250 , 400 ] ;
37168: LD_ADDR_VAR 0 4
37172: PUSH
37173: LD_INT 150
37175: PUSH
37176: LD_INT 250
37178: PUSH
37179: LD_INT 400
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: LIST
37186: ST_TO_ADDR
// art_cost := [ 1 + difficulty , 2 + ( 3 * difficulty ) , 30 + ( 10 * difficulty ) ] ;
37187: LD_ADDR_VAR 0 5
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: LD_OWVAR 67
37199: PLUS
37200: PUSH
37201: LD_INT 2
37203: PUSH
37204: LD_INT 3
37206: PUSH
37207: LD_OWVAR 67
37211: MUL
37212: PLUS
37213: PUSH
37214: LD_INT 30
37216: PUSH
37217: LD_INT 10
37219: PUSH
37220: LD_OWVAR 67
37224: MUL
37225: PLUS
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: LIST
37231: ST_TO_ADDR
// art_recharge := [ 6 * difficulty , 12 * difficulty , 10000 ] ;
37232: LD_ADDR_VAR 0 6
37236: PUSH
37237: LD_INT 6
37239: PUSH
37240: LD_OWVAR 67
37244: MUL
37245: PUSH
37246: LD_INT 12
37248: PUSH
37249: LD_OWVAR 67
37253: MUL
37254: PUSH
37255: LD_INT 10000
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: LIST
37262: ST_TO_ADDR
// Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ;
37263: LD_VAR 0 2
37267: PPUSH
37268: LD_VAR 0 3
37272: PPUSH
37273: LD_VAR 0 4
37277: PPUSH
37278: LD_VAR 0 5
37282: PPUSH
37283: LD_VAR 0 6
37287: PPUSH
37288: CALL 37297 0 5
// end ;
37292: LD_VAR 0 1
37296: RET
// function Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ; var un , i , side , base ; begin
37297: LD_INT 0
37299: PPUSH
37300: PPUSH
37301: PPUSH
37302: PPUSH
37303: PPUSH
// disable ( 1 ) ;
37304: LD_INT 1
37306: DISABLE_MARKED
// disable ( 5 ) ;
37307: LD_INT 5
37309: DISABLE_MARKED
// disable ( 6 ) ;
37310: LD_INT 6
37312: DISABLE_MARKED
// disable ( 7 ) ;
37313: LD_INT 7
37315: DISABLE_MARKED
// for side = 1 to 8 do
37316: LD_ADDR_VAR 0 9
37320: PUSH
37321: DOUBLE
37322: LD_INT 1
37324: DEC
37325: ST_TO_ADDR
37326: LD_INT 8
37328: PUSH
37329: FOR_TO
37330: IFFALSE 37346
// SetArtifactRes ( side , state_enabled ) ;
37332: LD_VAR 0 9
37336: PPUSH
37337: LD_INT 1
37339: PPUSH
37340: CALL_OW 467
37344: GO 37329
37346: POP
37347: POP
// for un = 0 to ( artefact_number - 1 ) do
37348: LD_ADDR_VAR 0 7
37352: PUSH
37353: DOUBLE
37354: LD_INT 0
37356: DEC
37357: ST_TO_ADDR
37358: LD_EXP 77
37362: PUSH
37363: LD_INT 1
37365: MINUS
37366: PUSH
37367: FOR_TO
37368: IFFALSE 37766
// begin base := un * 100 ;
37370: LD_ADDR_VAR 0 10
37374: PUSH
37375: LD_VAR 0 7
37379: PUSH
37380: LD_INT 100
37382: MUL
37383: ST_TO_ADDR
// SetTag ( base + 01 , art_icons [ un + 1 ] [ 1 ] ) ;
37384: LD_VAR 0 10
37388: PUSH
37389: LD_INT 1
37391: PLUS
37392: PPUSH
37393: LD_VAR 0 1
37397: PUSH
37398: LD_VAR 0 7
37402: PUSH
37403: LD_INT 1
37405: PLUS
37406: ARRAY
37407: PUSH
37408: LD_INT 1
37410: ARRAY
37411: PPUSH
37412: CALL_OW 109
// SetTag ( base + 02 , art_icons [ un + 1 ] [ 2 ] ) ;
37416: LD_VAR 0 10
37420: PUSH
37421: LD_INT 2
37423: PLUS
37424: PPUSH
37425: LD_VAR 0 1
37429: PUSH
37430: LD_VAR 0 7
37434: PUSH
37435: LD_INT 1
37437: PLUS
37438: ARRAY
37439: PUSH
37440: LD_INT 2
37442: ARRAY
37443: PPUSH
37444: CALL_OW 109
// SetTag ( base + 03 , art_events [ un + 1 ] ) ;
37448: LD_VAR 0 10
37452: PUSH
37453: LD_INT 3
37455: PLUS
37456: PPUSH
37457: LD_VAR 0 2
37461: PUSH
37462: LD_VAR 0 7
37466: PUSH
37467: LD_INT 1
37469: PLUS
37470: ARRAY
37471: PPUSH
37472: CALL_OW 109
// SetTag ( base + 05 , art_difficulty [ un + 1 ] ) ;
37476: LD_VAR 0 10
37480: PUSH
37481: LD_INT 5
37483: PLUS
37484: PPUSH
37485: LD_VAR 0 3
37489: PUSH
37490: LD_VAR 0 7
37494: PUSH
37495: LD_INT 1
37497: PLUS
37498: ARRAY
37499: PPUSH
37500: CALL_OW 109
// SetTag ( base + 06 , art_cost [ un + 1 ] ) ;
37504: LD_VAR 0 10
37508: PUSH
37509: LD_INT 6
37511: PLUS
37512: PPUSH
37513: LD_VAR 0 4
37517: PUSH
37518: LD_VAR 0 7
37522: PUSH
37523: LD_INT 1
37525: PLUS
37526: ARRAY
37527: PPUSH
37528: CALL_OW 109
// SetTag ( base + 07 , art_recharge [ un + 1 ] ) ;
37532: LD_VAR 0 10
37536: PUSH
37537: LD_INT 7
37539: PLUS
37540: PPUSH
37541: LD_VAR 0 5
37545: PUSH
37546: LD_VAR 0 7
37550: PUSH
37551: LD_INT 1
37553: PLUS
37554: ARRAY
37555: PPUSH
37556: CALL_OW 109
// SetTag ( base + 08 , false ) ;
37560: LD_VAR 0 10
37564: PUSH
37565: LD_INT 8
37567: PLUS
37568: PPUSH
37569: LD_INT 0
37571: PPUSH
37572: CALL_OW 109
// SetTag ( base + 09 , false ) ;
37576: LD_VAR 0 10
37580: PUSH
37581: LD_INT 9
37583: PLUS
37584: PPUSH
37585: LD_INT 0
37587: PPUSH
37588: CALL_OW 109
// SetTag ( base + 11 , 0 ) ;
37592: LD_VAR 0 10
37596: PUSH
37597: LD_INT 11
37599: PLUS
37600: PPUSH
37601: LD_INT 0
37603: PPUSH
37604: CALL_OW 109
// SetTag ( base + 12 , false ) ;
37608: LD_VAR 0 10
37612: PUSH
37613: LD_INT 12
37615: PLUS
37616: PPUSH
37617: LD_INT 0
37619: PPUSH
37620: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37624: LD_VAR 0 10
37628: PUSH
37629: LD_INT 13
37631: PLUS
37632: PPUSH
37633: LD_INT 0
37635: PPUSH
37636: CALL_OW 109
// for i = 0 to 7 do
37640: LD_ADDR_VAR 0 8
37644: PUSH
37645: DOUBLE
37646: LD_INT 0
37648: DEC
37649: ST_TO_ADDR
37650: LD_INT 7
37652: PUSH
37653: FOR_TO
37654: IFFALSE 37762
// begin SetTag ( base + i * 10 + 21 , false ) ;
37656: LD_VAR 0 10
37660: PUSH
37661: LD_VAR 0 8
37665: PUSH
37666: LD_INT 10
37668: MUL
37669: PLUS
37670: PUSH
37671: LD_INT 21
37673: PLUS
37674: PPUSH
37675: LD_INT 0
37677: PPUSH
37678: CALL_OW 109
// SetTag ( base + i * 10 + 22 , 0 ) ;
37682: LD_VAR 0 10
37686: PUSH
37687: LD_VAR 0 8
37691: PUSH
37692: LD_INT 10
37694: MUL
37695: PLUS
37696: PUSH
37697: LD_INT 22
37699: PLUS
37700: PPUSH
37701: LD_INT 0
37703: PPUSH
37704: CALL_OW 109
// SetTag ( base + i * 10 + 23 , 0 ) ;
37708: LD_VAR 0 10
37712: PUSH
37713: LD_VAR 0 8
37717: PUSH
37718: LD_INT 10
37720: MUL
37721: PLUS
37722: PUSH
37723: LD_INT 23
37725: PLUS
37726: PPUSH
37727: LD_INT 0
37729: PPUSH
37730: CALL_OW 109
// SetTag ( base + i * 10 + 25 , 0 ) ;
37734: LD_VAR 0 10
37738: PUSH
37739: LD_VAR 0 8
37743: PUSH
37744: LD_INT 10
37746: MUL
37747: PLUS
37748: PUSH
37749: LD_INT 25
37751: PLUS
37752: PPUSH
37753: LD_INT 0
37755: PPUSH
37756: CALL_OW 109
// end ;
37760: GO 37653
37762: POP
37763: POP
// end ;
37764: GO 37367
37766: POP
37767: POP
// enable ( 20 ) ;
37768: LD_INT 20
37770: ENABLE_MARKED
// labs_in_use := [ ] ;
37771: LD_ADDR_EXP 80
37775: PUSH
37776: EMPTY
37777: ST_TO_ADDR
// end ;
37778: LD_VAR 0 6
37782: RET
// on ArtifactUnloaded ( un , size ) do var art , base ;
37783: LD_INT 0
37785: PPUSH
37786: PPUSH
// begin art := artefact_num [ size ] ;
37787: LD_ADDR_VAR 0 3
37791: PUSH
37792: LD_EXP 78
37796: PUSH
37797: LD_VAR 0 2
37801: ARRAY
37802: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37803: LD_ADDR_VAR 0 4
37807: PUSH
37808: LD_VAR 0 3
37812: PUSH
37813: LD_INT 1
37815: MINUS
37816: PUSH
37817: LD_INT 100
37819: MUL
37820: ST_TO_ADDR
// SetTag ( base + 09 , false ) ;
37821: LD_VAR 0 4
37825: PUSH
37826: LD_INT 9
37828: PLUS
37829: PPUSH
37830: LD_INT 0
37832: PPUSH
37833: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37837: LD_VAR 0 4
37841: PUSH
37842: LD_INT 13
37844: PLUS
37845: PPUSH
37846: LD_INT 0
37848: PPUSH
37849: CALL_OW 109
// Init_Lab ( art ) ;
37853: LD_VAR 0 3
37857: PPUSH
37858: CALL 39394 0 1
// end ;
37862: PPOPN 4
37864: END
// on ArtifactLoaded ( un , size ) do var art , base , side ;
37865: LD_INT 0
37867: PPUSH
37868: PPUSH
37869: PPUSH
// begin art := artefact_num [ size ] ;
37870: LD_ADDR_VAR 0 3
37874: PUSH
37875: LD_EXP 78
37879: PUSH
37880: LD_VAR 0 2
37884: ARRAY
37885: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
37886: LD_ADDR_VAR 0 4
37890: PUSH
37891: LD_VAR 0 3
37895: PUSH
37896: LD_INT 1
37898: MINUS
37899: PUSH
37900: LD_INT 100
37902: MUL
37903: ST_TO_ADDR
// SetTag ( base + 09 , true ) ;
37904: LD_VAR 0 4
37908: PUSH
37909: LD_INT 9
37911: PLUS
37912: PPUSH
37913: LD_INT 1
37915: PPUSH
37916: CALL_OW 109
// SetTag ( base + 13 , un ) ;
37920: LD_VAR 0 4
37924: PUSH
37925: LD_INT 13
37927: PLUS
37928: PPUSH
37929: LD_VAR 0 1
37933: PPUSH
37934: CALL_OW 109
// if GetTag ( base + 11 ) then
37938: LD_VAR 0 4
37942: PUSH
37943: LD_INT 11
37945: PLUS
37946: PPUSH
37947: CALL_OW 110
37951: IFFALSE 38114
// begin side := GetSide ( GetTag ( base + 11 ) ) ;
37953: LD_ADDR_VAR 0 5
37957: PUSH
37958: LD_VAR 0 4
37962: PUSH
37963: LD_INT 11
37965: PLUS
37966: PPUSH
37967: CALL_OW 110
37971: PPUSH
37972: CALL_OW 255
37976: ST_TO_ADDR
// if GetTag ( base + 12 ) then
37977: LD_VAR 0 4
37981: PUSH
37982: LD_INT 12
37984: PLUS
37985: PPUSH
37986: CALL_OW 110
37990: IFFALSE 38058
// begin ComCancel ( GetTag ( base + 11 ) ) ;
37992: LD_VAR 0 4
37996: PUSH
37997: LD_INT 11
37999: PLUS
38000: PPUSH
38001: CALL_OW 110
38005: PPUSH
38006: CALL_OW 127
// wait ( 5 ) ;
38010: LD_INT 5
38012: PPUSH
38013: CALL_OW 67
// labs_in_use := labs_in_use diff GetTag ( base + 11 ) ;
38017: LD_ADDR_EXP 80
38021: PUSH
38022: LD_EXP 80
38026: PUSH
38027: LD_VAR 0 4
38031: PUSH
38032: LD_INT 11
38034: PLUS
38035: PPUSH
38036: CALL_OW 110
38040: DIFF
38041: ST_TO_ADDR
// SetTag ( base + 12 , false ) ;
38042: LD_VAR 0 4
38046: PUSH
38047: LD_INT 12
38049: PLUS
38050: PPUSH
38051: LD_INT 0
38053: PPUSH
38054: CALL_OW 109
// end ; if not GetTag ( base + side * 10 + 11 ) then
38058: LD_VAR 0 4
38062: PUSH
38063: LD_VAR 0 5
38067: PUSH
38068: LD_INT 10
38070: MUL
38071: PLUS
38072: PUSH
38073: LD_INT 11
38075: PLUS
38076: PPUSH
38077: CALL_OW 110
38081: NOT
38082: IFFALSE 38098
// DeInit_Lab ( side , art ) ;
38084: LD_VAR 0 5
38088: PPUSH
38089: LD_VAR 0 3
38093: PPUSH
38094: CALL 40088 0 2
// SetTag ( base + 11 , 0 ) ;
38098: LD_VAR 0 4
38102: PUSH
38103: LD_INT 11
38105: PLUS
38106: PPUSH
38107: LD_INT 0
38109: PPUSH
38110: CALL_OW 109
// end ; end ;
38114: PPOPN 5
38116: END
// on ArtifactResearchComplete ( lab ) do var un , side ;
38117: LD_INT 0
38119: PPUSH
38120: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38121: LD_ADDR_VAR 0 3
38125: PUSH
38126: LD_VAR 0 1
38130: PPUSH
38131: CALL_OW 255
38135: PUSH
38136: LD_INT 1
38138: MINUS
38139: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38140: LD_ADDR_VAR 0 2
38144: PUSH
38145: DOUBLE
38146: LD_INT 0
38148: DEC
38149: ST_TO_ADDR
38150: LD_EXP 77
38154: PUSH
38155: LD_INT 1
38157: MINUS
38158: PUSH
38159: FOR_TO
38160: IFFALSE 38202
// if lab = GetTag ( un * 100 + 11 ) then
38162: LD_VAR 0 1
38166: PUSH
38167: LD_VAR 0 2
38171: PUSH
38172: LD_INT 100
38174: MUL
38175: PUSH
38176: LD_INT 11
38178: PLUS
38179: PPUSH
38180: CALL_OW 110
38184: EQUAL
38185: IFFALSE 38200
// Init_Lab ( un + 1 ) ;
38187: LD_VAR 0 2
38191: PUSH
38192: LD_INT 1
38194: PLUS
38195: PPUSH
38196: CALL 39394 0 1
38200: GO 38159
38202: POP
38203: POP
// end ;
38204: PPOPN 3
38206: END
// on SpecResearchCancel ( lab , progress ) do var un , side ;
38207: LD_INT 0
38209: PPUSH
38210: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38211: LD_ADDR_VAR 0 4
38215: PUSH
38216: LD_VAR 0 1
38220: PPUSH
38221: CALL_OW 255
38225: PUSH
38226: LD_INT 1
38228: MINUS
38229: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38230: LD_ADDR_VAR 0 3
38234: PUSH
38235: DOUBLE
38236: LD_INT 0
38238: DEC
38239: ST_TO_ADDR
38240: LD_EXP 77
38244: PUSH
38245: LD_INT 1
38247: MINUS
38248: PUSH
38249: FOR_TO
38250: IFFALSE 38368
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38252: LD_VAR 0 3
38256: PUSH
38257: LD_INT 100
38259: MUL
38260: PUSH
38261: LD_INT 11
38263: PLUS
38264: PPUSH
38265: CALL_OW 110
38269: PUSH
38270: LD_VAR 0 1
38274: EQUAL
38275: PUSH
38276: LD_VAR 0 3
38280: PUSH
38281: LD_INT 100
38283: MUL
38284: PUSH
38285: LD_INT 12
38287: PLUS
38288: PPUSH
38289: CALL_OW 110
38293: AND
38294: IFFALSE 38366
// begin SetTag ( un * 100 + side * 10 + 22 , progress ) ;
38296: LD_VAR 0 3
38300: PUSH
38301: LD_INT 100
38303: MUL
38304: PUSH
38305: LD_VAR 0 4
38309: PUSH
38310: LD_INT 10
38312: MUL
38313: PLUS
38314: PUSH
38315: LD_INT 22
38317: PLUS
38318: PPUSH
38319: LD_VAR 0 2
38323: PPUSH
38324: CALL_OW 109
// SetTag ( un * 100 + 12 , false ) ;
38328: LD_VAR 0 3
38332: PUSH
38333: LD_INT 100
38335: MUL
38336: PUSH
38337: LD_INT 12
38339: PLUS
38340: PPUSH
38341: LD_INT 0
38343: PPUSH
38344: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38348: LD_ADDR_EXP 80
38352: PUSH
38353: LD_EXP 80
38357: PUSH
38358: LD_VAR 0 1
38362: DIFF
38363: ST_TO_ADDR
// break ;
38364: GO 38368
// end ;
38366: GO 38249
38368: POP
38369: POP
// Update_Artefact ( lab ) ;
38370: LD_VAR 0 1
38374: PPUSH
38375: CALL 40227 0 1
// end ;
38379: PPOPN 4
38381: END
// on SpecResearchComplete ( lab ) do var un , side ;
38382: LD_INT 0
38384: PPUSH
38385: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38386: LD_ADDR_VAR 0 3
38390: PUSH
38391: LD_VAR 0 1
38395: PPUSH
38396: CALL_OW 255
38400: PUSH
38401: LD_INT 1
38403: MINUS
38404: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38405: LD_ADDR_VAR 0 2
38409: PUSH
38410: DOUBLE
38411: LD_INT 0
38413: DEC
38414: ST_TO_ADDR
38415: LD_EXP 77
38419: PUSH
38420: LD_INT 1
38422: MINUS
38423: PUSH
38424: FOR_TO
38425: IFFALSE 38631
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38427: LD_VAR 0 2
38431: PUSH
38432: LD_INT 100
38434: MUL
38435: PUSH
38436: LD_INT 11
38438: PLUS
38439: PPUSH
38440: CALL_OW 110
38444: PUSH
38445: LD_VAR 0 1
38449: EQUAL
38450: PUSH
38451: LD_VAR 0 2
38455: PUSH
38456: LD_INT 100
38458: MUL
38459: PUSH
38460: LD_INT 12
38462: PLUS
38463: PPUSH
38464: CALL_OW 110
38468: AND
38469: IFFALSE 38629
// begin SetTag ( un * 100 + 12 , false ) ;
38471: LD_VAR 0 2
38475: PUSH
38476: LD_INT 100
38478: MUL
38479: PUSH
38480: LD_INT 12
38482: PLUS
38483: PPUSH
38484: LD_INT 0
38486: PPUSH
38487: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 21 , true ) ;
38491: LD_VAR 0 2
38495: PUSH
38496: LD_INT 100
38498: MUL
38499: PUSH
38500: LD_VAR 0 3
38504: PUSH
38505: LD_INT 10
38507: MUL
38508: PLUS
38509: PUSH
38510: LD_INT 21
38512: PLUS
38513: PPUSH
38514: LD_INT 1
38516: PPUSH
38517: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 25 , lab ) ;
38521: LD_VAR 0 2
38525: PUSH
38526: LD_INT 100
38528: MUL
38529: PUSH
38530: LD_VAR 0 3
38534: PUSH
38535: LD_INT 10
38537: MUL
38538: PLUS
38539: PUSH
38540: LD_INT 25
38542: PLUS
38543: PPUSH
38544: LD_VAR 0 1
38548: PPUSH
38549: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38553: LD_ADDR_EXP 80
38557: PUSH
38558: LD_EXP 80
38562: PUSH
38563: LD_VAR 0 1
38567: DIFF
38568: ST_TO_ADDR
// case un of 0 :
38569: LD_VAR 0 2
38573: PUSH
38574: LD_INT 0
38576: DOUBLE
38577: EQUAL
38578: IFTRUE 38582
38580: GO 38592
38582: POP
// Hint ( ATSpy ) ; 1 :
38583: LD_STRING ATSpy
38585: PPUSH
38586: CALL_OW 339
38590: GO 38629
38592: LD_INT 1
38594: DOUBLE
38595: EQUAL
38596: IFTRUE 38600
38598: GO 38610
38600: POP
// Hint ( ATDetonated ) ; 2 :
38601: LD_STRING ATDetonated
38603: PPUSH
38604: CALL_OW 339
38608: GO 38629
38610: LD_INT 2
38612: DOUBLE
38613: EQUAL
38614: IFTRUE 38618
38616: GO 38628
38618: POP
// Hint ( ArterfactTeleport ) ; end ;
38619: LD_STRING ArterfactTeleport
38621: PPUSH
38622: CALL_OW 339
38626: GO 38629
38628: POP
// end ;
38629: GO 38424
38631: POP
38632: POP
// Update_Artefact ( lab ) ;
38633: LD_VAR 0 1
38637: PPUSH
38638: CALL 40227 0 1
// end ;
38642: PPOPN 3
38644: END
// on ArtifactUsed ( side , number , p1 , p2 ) do var un , succes , art , base ;
38645: LD_INT 0
38647: PPUSH
38648: PPUSH
38649: PPUSH
38650: PPUSH
// begin art := ( ( number - 1 ) mod 3 ) + 1 ;
38651: LD_ADDR_VAR 0 7
38655: PUSH
38656: LD_VAR 0 2
38660: PUSH
38661: LD_INT 1
38663: MINUS
38664: PUSH
38665: LD_INT 3
38667: MOD
38668: PUSH
38669: LD_INT 1
38671: PLUS
38672: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38673: LD_ADDR_VAR 0 8
38677: PUSH
38678: LD_VAR 0 7
38682: PUSH
38683: LD_INT 1
38685: MINUS
38686: PUSH
38687: LD_INT 100
38689: MUL
38690: ST_TO_ADDR
// if number <= 3 then
38691: LD_VAR 0 2
38695: PUSH
38696: LD_INT 3
38698: LESSEQUAL
38699: IFFALSE 38931
// begin SetSpecResearch ( GetTag ( base + 11 ) , GetTag ( base + 05 ) , true ) ;
38701: LD_VAR 0 8
38705: PUSH
38706: LD_INT 11
38708: PLUS
38709: PPUSH
38710: CALL_OW 110
38714: PPUSH
38715: LD_VAR 0 8
38719: PUSH
38720: LD_INT 5
38722: PLUS
38723: PPUSH
38724: CALL_OW 110
38728: PPUSH
38729: LD_INT 1
38731: PPUSH
38732: CALL_OW 486
// SetWorkingProgress ( GetTag ( base + 11 ) , GetTag ( base + side * 10 + 12 ) ) ;
38736: LD_VAR 0 8
38740: PUSH
38741: LD_INT 11
38743: PLUS
38744: PPUSH
38745: CALL_OW 110
38749: PPUSH
38750: LD_VAR 0 8
38754: PUSH
38755: LD_VAR 0 1
38759: PUSH
38760: LD_INT 10
38762: MUL
38763: PLUS
38764: PUSH
38765: LD_INT 12
38767: PLUS
38768: PPUSH
38769: CALL_OW 110
38773: PPUSH
38774: CALL_OW 329
// SetTag ( base + 12 , true ) ;
38778: LD_VAR 0 8
38782: PUSH
38783: LD_INT 12
38785: PLUS
38786: PPUSH
38787: LD_INT 1
38789: PPUSH
38790: CALL_OW 109
// labs_in_use := labs_in_use ^ GetTag ( base + 11 ) ;
38794: LD_ADDR_EXP 80
38798: PUSH
38799: LD_EXP 80
38803: PUSH
38804: LD_VAR 0 8
38808: PUSH
38809: LD_INT 11
38811: PLUS
38812: PPUSH
38813: CALL_OW 110
38817: ADD
38818: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38819: LD_ADDR_VAR 0 5
38823: PUSH
38824: DOUBLE
38825: LD_INT 0
38827: DEC
38828: ST_TO_ADDR
38829: LD_EXP 77
38833: PUSH
38834: LD_INT 1
38836: MINUS
38837: PUSH
38838: FOR_TO
38839: IFFALSE 38927
// if GetTag ( base + 11 ) in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
38841: LD_VAR 0 8
38845: PUSH
38846: LD_INT 11
38848: PLUS
38849: PPUSH
38850: CALL_OW 110
38854: PUSH
38855: LD_VAR 0 5
38859: PUSH
38860: LD_INT 100
38862: MUL
38863: PUSH
38864: LD_INT 11
38866: PLUS
38867: PPUSH
38868: CALL_OW 110
38872: PUSH
38873: LD_VAR 0 5
38877: PUSH
38878: LD_INT 100
38880: MUL
38881: PUSH
38882: LD_VAR 0 1
38886: PUSH
38887: LD_INT 10
38889: MUL
38890: PLUS
38891: PUSH
38892: LD_INT 15
38894: PLUS
38895: PPUSH
38896: CALL_OW 110
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: IN
38905: IFFALSE 38925
// DeInit_Lab ( side , un + 1 ) ;
38907: LD_VAR 0 1
38911: PPUSH
38912: LD_VAR 0 5
38916: PUSH
38917: LD_INT 1
38919: PLUS
38920: PPUSH
38921: CALL 40088 0 2
38925: GO 38838
38927: POP
38928: POP
// end else
38929: GO 39105
// begin succes := false ;
38931: LD_ADDR_VAR 0 6
38935: PUSH
38936: LD_INT 0
38938: ST_TO_ADDR
// case art of 1 :
38939: LD_VAR 0 7
38943: PUSH
38944: LD_INT 1
38946: DOUBLE
38947: EQUAL
38948: IFTRUE 38952
38950: GO 38980
38952: POP
// succes := Show_me_map ( side , p1 , p2 ) ; 2 :
38953: LD_ADDR_VAR 0 6
38957: PUSH
38958: LD_VAR 0 1
38962: PPUSH
38963: LD_VAR 0 3
38967: PPUSH
38968: LD_VAR 0 4
38972: PPUSH
38973: CALL 40527 0 3
38977: ST_TO_ADDR
38978: GO 39048
38980: LD_INT 2
38982: DOUBLE
38983: EQUAL
38984: IFTRUE 38988
38986: GO 39011
38988: POP
// succes := Destroy_siberite ( side , p1 ) ; 3 :
38989: LD_ADDR_VAR 0 6
38993: PUSH
38994: LD_VAR 0 1
38998: PPUSH
38999: LD_VAR 0 3
39003: PPUSH
39004: CALL 40765 0 2
39008: ST_TO_ADDR
39009: GO 39048
39011: LD_INT 3
39013: DOUBLE
39014: EQUAL
39015: IFTRUE 39019
39017: GO 39047
39019: POP
// succes := Mass_Teleport ( side , p1 , p2 ) ; end ;
39020: LD_ADDR_VAR 0 6
39024: PUSH
39025: LD_VAR 0 1
39029: PPUSH
39030: LD_VAR 0 3
39034: PPUSH
39035: LD_VAR 0 4
39039: PPUSH
39040: CALL 41090 0 3
39044: ST_TO_ADDR
39045: GO 39048
39047: POP
// if succes then
39048: LD_VAR 0 6
39052: IFFALSE 39105
// begin SetTag ( base + side * 10 + 13 , GetTag ( base + 07 ) ) ;
39054: LD_VAR 0 8
39058: PUSH
39059: LD_VAR 0 1
39063: PUSH
39064: LD_INT 10
39066: MUL
39067: PLUS
39068: PUSH
39069: LD_INT 13
39071: PLUS
39072: PPUSH
39073: LD_VAR 0 8
39077: PUSH
39078: LD_INT 7
39080: PLUS
39081: PPUSH
39082: CALL_OW 110
39086: PPUSH
39087: CALL_OW 109
// Shadow_Artefact ( side , art ) ;
39091: LD_VAR 0 1
39095: PPUSH
39096: LD_VAR 0 7
39100: PPUSH
39101: CALL 39108 0 2
// end ; end ; end ;
39105: PPOPN 8
39107: END
// export function Shadow_Artefact ( side , art ) ; var base , lab ; begin
39108: LD_INT 0
39110: PPUSH
39111: PPUSH
39112: PPUSH
// base := ( art - 1 ) * 100 ;
39113: LD_ADDR_VAR 0 4
39117: PUSH
39118: LD_VAR 0 2
39122: PUSH
39123: LD_INT 1
39125: MINUS
39126: PUSH
39127: LD_INT 100
39129: MUL
39130: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39131: LD_ADDR_VAR 0 5
39135: PUSH
39136: LD_VAR 0 4
39140: PUSH
39141: LD_VAR 0 1
39145: PUSH
39146: LD_INT 10
39148: MUL
39149: PLUS
39150: PUSH
39151: LD_INT 15
39153: PLUS
39154: PPUSH
39155: CALL_OW 110
39159: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) then
39160: LD_VAR 0 5
39164: PUSH
39165: LD_VAR 0 5
39169: PUSH
39170: LD_EXP 80
39174: IN
39175: NOT
39176: AND
39177: IFFALSE 39235
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_gray , lab ) ;
39179: LD_VAR 0 1
39183: PPUSH
39184: LD_VAR 0 4
39188: PUSH
39189: LD_INT 1
39191: PLUS
39192: PUSH
39193: LD_VAR 0 4
39197: PUSH
39198: LD_VAR 0 1
39202: PUSH
39203: LD_INT 10
39205: MUL
39206: PLUS
39207: PUSH
39208: LD_INT 11
39210: PLUS
39211: PPUSH
39212: CALL_OW 110
39216: PLUS
39217: PPUSH
39218: CALL_OW 110
39222: PPUSH
39223: LD_INT 1
39225: PPUSH
39226: LD_VAR 0 5
39230: PPUSH
39231: CALL_OW 468
// end ;
39235: LD_VAR 0 3
39239: RET
// export function Highlight_Artefact ( side , art ) ; var base , lab ; begin
39240: LD_INT 0
39242: PPUSH
39243: PPUSH
39244: PPUSH
// base := ( art - 1 ) * 100 ;
39245: LD_ADDR_VAR 0 4
39249: PUSH
39250: LD_VAR 0 2
39254: PUSH
39255: LD_INT 1
39257: MINUS
39258: PUSH
39259: LD_INT 100
39261: MUL
39262: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39263: LD_ADDR_VAR 0 5
39267: PUSH
39268: LD_VAR 0 4
39272: PUSH
39273: LD_VAR 0 1
39277: PUSH
39278: LD_INT 10
39280: MUL
39281: PLUS
39282: PUSH
39283: LD_INT 15
39285: PLUS
39286: PPUSH
39287: CALL_OW 110
39291: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) and UnitsInside ( lab ) then
39292: LD_VAR 0 5
39296: PUSH
39297: LD_VAR 0 5
39301: PUSH
39302: LD_EXP 80
39306: IN
39307: NOT
39308: AND
39309: PUSH
39310: LD_VAR 0 5
39314: PPUSH
39315: CALL_OW 313
39319: AND
39320: IFFALSE 39389
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , GetTag ( base + 03 ) , lab ) ;
39322: LD_VAR 0 1
39326: PPUSH
39327: LD_VAR 0 4
39331: PUSH
39332: LD_INT 1
39334: PLUS
39335: PUSH
39336: LD_VAR 0 4
39340: PUSH
39341: LD_VAR 0 1
39345: PUSH
39346: LD_INT 10
39348: MUL
39349: PLUS
39350: PUSH
39351: LD_INT 11
39353: PLUS
39354: PPUSH
39355: CALL_OW 110
39359: PLUS
39360: PPUSH
39361: CALL_OW 110
39365: PPUSH
39366: LD_VAR 0 4
39370: PUSH
39371: LD_INT 3
39373: PLUS
39374: PPUSH
39375: CALL_OW 110
39379: PPUSH
39380: LD_VAR 0 5
39384: PPUSH
39385: CALL_OW 468
// end ;
39389: LD_VAR 0 3
39393: RET
// export function Init_Lab ( art ) ; var list , side , base , dist , state , art_hex , nearest_lab ; begin
39394: LD_INT 0
39396: PPUSH
39397: PPUSH
39398: PPUSH
39399: PPUSH
39400: PPUSH
39401: PPUSH
39402: PPUSH
39403: PPUSH
// art_hex := FindArtifact ( artefact_size [ art ] ) ;
39404: LD_ADDR_VAR 0 8
39408: PUSH
39409: LD_EXP 79
39413: PUSH
39414: LD_VAR 0 1
39418: ARRAY
39419: PPUSH
39420: CALL_OW 469
39424: ST_TO_ADDR
// if not art_hex then
39425: LD_VAR 0 8
39429: NOT
39430: IFFALSE 39434
// exit ;
39432: GO 40083
// case art of 1 :
39434: LD_VAR 0 1
39438: PUSH
39439: LD_INT 1
39441: DOUBLE
39442: EQUAL
39443: IFTRUE 39447
39445: GO 39524
39447: POP
// list := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 2 :
39448: LD_ADDR_VAR 0 3
39452: PUSH
39453: LD_INT 23
39455: PUSH
39456: LD_INT 1
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 21
39465: PUSH
39466: LD_INT 3
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 2
39475: PUSH
39476: LD_INT 30
39478: PUSH
39479: LD_INT 6
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 30
39488: PUSH
39489: LD_INT 7
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 30
39498: PUSH
39499: LD_INT 8
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: LIST
39510: LIST
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: LIST
39516: PPUSH
39517: CALL_OW 69
39521: ST_TO_ADDR
39522: GO 39644
39524: LD_INT 2
39526: DOUBLE
39527: EQUAL
39528: IFTRUE 39532
39530: GO 39609
39532: POP
// list := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 3 :
39533: LD_ADDR_VAR 0 3
39537: PUSH
39538: LD_INT 23
39540: PUSH
39541: LD_INT 3
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 21
39550: PUSH
39551: LD_INT 3
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 2
39560: PUSH
39561: LD_INT 30
39563: PUSH
39564: LD_INT 6
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 30
39573: PUSH
39574: LD_INT 7
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 30
39583: PUSH
39584: LD_INT 8
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: LIST
39601: PPUSH
39602: CALL_OW 69
39606: ST_TO_ADDR
39607: GO 39644
39609: LD_INT 3
39611: DOUBLE
39612: EQUAL
39613: IFTRUE 39617
39615: GO 39643
39617: POP
// list := FilterAllUnits ( [ [ f_btype , b_alien_tower ] ] ) ; end ;
39618: LD_ADDR_VAR 0 3
39622: PUSH
39623: LD_INT 30
39625: PUSH
39626: LD_INT 39
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: EMPTY
39634: LIST
39635: PPUSH
39636: CALL_OW 69
39640: ST_TO_ADDR
39641: GO 39644
39643: POP
// nearest_lab := NearestUnitToXY ( list , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39644: LD_ADDR_VAR 0 9
39648: PUSH
39649: LD_VAR 0 3
39653: PPUSH
39654: LD_VAR 0 8
39658: PUSH
39659: LD_INT 1
39661: ARRAY
39662: PPUSH
39663: LD_VAR 0 8
39667: PUSH
39668: LD_INT 2
39670: ARRAY
39671: PPUSH
39672: CALL_OW 73
39676: ST_TO_ADDR
// dist := GetDistUnitXY ( nearest_lab , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39677: LD_ADDR_VAR 0 6
39681: PUSH
39682: LD_VAR 0 9
39686: PPUSH
39687: LD_VAR 0 8
39691: PUSH
39692: LD_INT 1
39694: ARRAY
39695: PPUSH
39696: LD_VAR 0 8
39700: PUSH
39701: LD_INT 2
39703: ARRAY
39704: PPUSH
39705: CALL_OW 297
39709: ST_TO_ADDR
// if dist < 25 then
39710: LD_VAR 0 6
39714: PUSH
39715: LD_INT 25
39717: LESS
39718: IFFALSE 40083
// begin side := GetSide ( nearest_lab ) ;
39720: LD_ADDR_VAR 0 4
39724: PUSH
39725: LD_VAR 0 9
39729: PPUSH
39730: CALL_OW 255
39734: ST_TO_ADDR
// DeInit_Lab ( side , art ) ;
39735: LD_VAR 0 4
39739: PPUSH
39740: LD_VAR 0 1
39744: PPUSH
39745: CALL 40088 0 2
// base := ( art - 1 ) * 100 ;
39749: LD_ADDR_VAR 0 5
39753: PUSH
39754: LD_VAR 0 1
39758: PUSH
39759: LD_INT 1
39761: MINUS
39762: PUSH
39763: LD_INT 100
39765: MUL
39766: ST_TO_ADDR
// if ( GetTech ( tech_Artifact , side ) = state_researched ) then
39767: LD_INT 24
39769: PPUSH
39770: LD_VAR 0 4
39774: PPUSH
39775: CALL_OW 321
39779: PUSH
39780: LD_INT 2
39782: EQUAL
39783: IFFALSE 39986
// begin if GetTag ( base + side * 10 + 11 ) and UnitsInside ( nearest_lab ) then
39785: LD_VAR 0 5
39789: PUSH
39790: LD_VAR 0 4
39794: PUSH
39795: LD_INT 10
39797: MUL
39798: PLUS
39799: PUSH
39800: LD_INT 11
39802: PLUS
39803: PPUSH
39804: CALL_OW 110
39808: PUSH
39809: LD_VAR 0 9
39813: PPUSH
39814: CALL_OW 313
39818: AND
39819: IFFALSE 39976
// begin if not GetTag ( base + side * 10 + 13 ) then
39821: LD_VAR 0 5
39825: PUSH
39826: LD_VAR 0 4
39830: PUSH
39831: LD_INT 10
39833: MUL
39834: PLUS
39835: PUSH
39836: LD_INT 13
39838: PLUS
39839: PPUSH
39840: CALL_OW 110
39844: NOT
39845: IFFALSE 39868
// state := GetTag ( base + 03 ) else
39847: LD_ADDR_VAR 0 7
39851: PUSH
39852: LD_VAR 0 5
39856: PUSH
39857: LD_INT 3
39859: PLUS
39860: PPUSH
39861: CALL_OW 110
39865: ST_TO_ADDR
39866: GO 39876
// state := art_gray ;
39868: LD_ADDR_VAR 0 7
39872: PUSH
39873: LD_INT 1
39875: ST_TO_ADDR
// if GetTag ( base + side * 10 + 15 ) and ( GetTag ( base + side * 10 + 15 ) <> nearest_lab ) then
39876: LD_VAR 0 5
39880: PUSH
39881: LD_VAR 0 4
39885: PUSH
39886: LD_INT 10
39888: MUL
39889: PLUS
39890: PUSH
39891: LD_INT 15
39893: PLUS
39894: PPUSH
39895: CALL_OW 110
39899: PUSH
39900: LD_VAR 0 5
39904: PUSH
39905: LD_VAR 0 4
39909: PUSH
39910: LD_INT 10
39912: MUL
39913: PLUS
39914: PUSH
39915: LD_INT 15
39917: PLUS
39918: PPUSH
39919: CALL_OW 110
39923: PUSH
39924: LD_VAR 0 9
39928: NONEQUAL
39929: AND
39930: IFFALSE 39946
// DeInit_Lab ( side , art ) ;
39932: LD_VAR 0 4
39936: PPUSH
39937: LD_VAR 0 1
39941: PPUSH
39942: CALL 40088 0 2
// SetTag ( base + side * 10 + 15 , nearest_lab ) ;
39946: LD_VAR 0 5
39950: PUSH
39951: LD_VAR 0 4
39955: PUSH
39956: LD_INT 10
39958: MUL
39959: PLUS
39960: PUSH
39961: LD_INT 15
39963: PLUS
39964: PPUSH
39965: LD_VAR 0 9
39969: PPUSH
39970: CALL_OW 109
// end else
39974: GO 39984
// state := art_instant ;
39976: LD_ADDR_VAR 0 7
39980: PUSH
39981: LD_INT 2
39983: ST_TO_ADDR
// end else
39984: GO 39994
// state := art_gray ;
39986: LD_ADDR_VAR 0 7
39990: PUSH
39991: LD_INT 1
39993: ST_TO_ADDR
// SetTag ( base + 11 , nearest_lab ) ;
39994: LD_VAR 0 5
39998: PUSH
39999: LD_INT 11
40001: PLUS
40002: PPUSH
40003: LD_VAR 0 9
40007: PPUSH
40008: CALL_OW 109
// if not ( nearest_lab in labs_in_use ) then
40012: LD_VAR 0 9
40016: PUSH
40017: LD_EXP 80
40021: IN
40022: NOT
40023: IFFALSE 40083
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , state , nearest_lab ) ;
40025: LD_VAR 0 4
40029: PPUSH
40030: LD_VAR 0 5
40034: PUSH
40035: LD_INT 1
40037: PLUS
40038: PUSH
40039: LD_VAR 0 5
40043: PUSH
40044: LD_VAR 0 4
40048: PUSH
40049: LD_INT 10
40051: MUL
40052: PLUS
40053: PUSH
40054: LD_INT 11
40056: PLUS
40057: PPUSH
40058: CALL_OW 110
40062: PLUS
40063: PPUSH
40064: CALL_OW 110
40068: PPUSH
40069: LD_VAR 0 7
40073: PPUSH
40074: LD_VAR 0 9
40078: PPUSH
40079: CALL_OW 468
// end ; end ;
40083: LD_VAR 0 2
40087: RET
// export function DeInit_Lab ( side , art ) ; var base , lab ; begin
40088: LD_INT 0
40090: PPUSH
40091: PPUSH
40092: PPUSH
// base := ( art - 1 ) * 100 ;
40093: LD_ADDR_VAR 0 4
40097: PUSH
40098: LD_VAR 0 2
40102: PUSH
40103: LD_INT 1
40105: MINUS
40106: PUSH
40107: LD_INT 100
40109: MUL
40110: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
40111: LD_ADDR_VAR 0 5
40115: PUSH
40116: LD_VAR 0 4
40120: PUSH
40121: LD_VAR 0 1
40125: PUSH
40126: LD_INT 10
40128: MUL
40129: PLUS
40130: PUSH
40131: LD_INT 15
40133: PLUS
40134: PPUSH
40135: CALL_OW 110
40139: ST_TO_ADDR
// if not lab then
40140: LD_VAR 0 5
40144: NOT
40145: IFFALSE 40166
// lab := GetTag ( base + 11 ) ;
40147: LD_ADDR_VAR 0 5
40151: PUSH
40152: LD_VAR 0 4
40156: PUSH
40157: LD_INT 11
40159: PLUS
40160: PPUSH
40161: CALL_OW 110
40165: ST_TO_ADDR
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_no , lab ) ;
40166: LD_VAR 0 1
40170: PPUSH
40171: LD_VAR 0 4
40175: PUSH
40176: LD_INT 1
40178: PLUS
40179: PUSH
40180: LD_VAR 0 4
40184: PUSH
40185: LD_VAR 0 1
40189: PUSH
40190: LD_INT 10
40192: MUL
40193: PLUS
40194: PUSH
40195: LD_INT 11
40197: PLUS
40198: PPUSH
40199: CALL_OW 110
40203: PLUS
40204: PPUSH
40205: CALL_OW 110
40209: PPUSH
40210: LD_INT 0
40212: PPUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: CALL_OW 468
// end ;
40222: LD_VAR 0 3
40226: RET
// export function Update_Artefact ( lab ) ; var art , side , base ; begin
40227: LD_INT 0
40229: PPUSH
40230: PPUSH
40231: PPUSH
40232: PPUSH
// side := GetSide ( lab ) ;
40233: LD_ADDR_VAR 0 4
40237: PUSH
40238: LD_VAR 0 1
40242: PPUSH
40243: CALL_OW 255
40247: ST_TO_ADDR
// for art = 1 to artefact_number do
40248: LD_ADDR_VAR 0 3
40252: PUSH
40253: DOUBLE
40254: LD_INT 1
40256: DEC
40257: ST_TO_ADDR
40258: LD_EXP 77
40262: PUSH
40263: FOR_TO
40264: IFFALSE 40420
// begin base := ( art - 1 ) * 100 ;
40266: LD_ADDR_VAR 0 5
40270: PUSH
40271: LD_VAR 0 3
40275: PUSH
40276: LD_INT 1
40278: MINUS
40279: PUSH
40280: LD_INT 100
40282: MUL
40283: ST_TO_ADDR
// if GetTag ( base + 11 ) = lab then
40284: LD_VAR 0 5
40288: PUSH
40289: LD_INT 11
40291: PLUS
40292: PPUSH
40293: CALL_OW 110
40297: PUSH
40298: LD_VAR 0 1
40302: EQUAL
40303: IFFALSE 40316
// Init_Lab ( art ) else
40305: LD_VAR 0 3
40309: PPUSH
40310: CALL 39394 0 1
40314: GO 40418
// begin if lab = GetTag ( base + side * 10 + 15 ) then
40316: LD_VAR 0 1
40320: PUSH
40321: LD_VAR 0 5
40325: PUSH
40326: LD_VAR 0 4
40330: PUSH
40331: LD_INT 10
40333: MUL
40334: PLUS
40335: PUSH
40336: LD_INT 15
40338: PLUS
40339: PPUSH
40340: CALL_OW 110
40344: EQUAL
40345: IFFALSE 40418
// begin if ( GetTag ( base + side * 10 + 13 ) > 0 ) or ( not UnitsInside ( lab ) ) then
40347: LD_VAR 0 5
40351: PUSH
40352: LD_VAR 0 4
40356: PUSH
40357: LD_INT 10
40359: MUL
40360: PLUS
40361: PUSH
40362: LD_INT 13
40364: PLUS
40365: PPUSH
40366: CALL_OW 110
40370: PUSH
40371: LD_INT 0
40373: GREATER
40374: PUSH
40375: LD_VAR 0 1
40379: PPUSH
40380: CALL_OW 313
40384: NOT
40385: OR
40386: IFFALSE 40404
// Shadow_Artefact ( side , art ) else
40388: LD_VAR 0 4
40392: PPUSH
40393: LD_VAR 0 3
40397: PPUSH
40398: CALL 39108 0 2
40402: GO 40418
// Highlight_Artefact ( side , art ) ;
40404: LD_VAR 0 4
40408: PPUSH
40409: LD_VAR 0 3
40413: PPUSH
40414: CALL 39240 0 2
// end ; end ; end ;
40418: GO 40263
40420: POP
40421: POP
// end ;
40422: LD_VAR 0 2
40426: RET
// every 0 0$2 marked 20 do var list , lab ;
40427: GO 40429
40429: DISABLE
40430: LD_INT 0
40432: PPUSH
40433: PPUSH
// begin list := FilterAllUnits ( [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_alien_tower ] ] ] ) ;
40434: LD_ADDR_VAR 0 1
40438: PUSH
40439: LD_INT 2
40441: PUSH
40442: LD_INT 30
40444: PUSH
40445: LD_INT 6
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 30
40454: PUSH
40455: LD_INT 7
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 30
40464: PUSH
40465: LD_INT 8
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 30
40474: PUSH
40475: LD_INT 39
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: PUSH
40489: EMPTY
40490: LIST
40491: PPUSH
40492: CALL_OW 69
40496: ST_TO_ADDR
// for lab in list do
40497: LD_ADDR_VAR 0 2
40501: PUSH
40502: LD_VAR 0 1
40506: PUSH
40507: FOR_IN
40508: IFFALSE 40521
// Update_Artefact ( lab ) ;
40510: LD_VAR 0 2
40514: PPUSH
40515: CALL 40227 0 1
40519: GO 40507
40521: POP
40522: POP
// enable ;
40523: ENABLE
// end ; end_of_file
40524: PPOPN 2
40526: END
// var view_data , human_changed ; export function Show_me_map ( side , x , y ) ; var vysledek , station ; begin
40527: LD_INT 0
40529: PPUSH
40530: PPUSH
40531: PPUSH
// vysledek := true ;
40532: LD_ADDR_VAR 0 5
40536: PUSH
40537: LD_INT 1
40539: ST_TO_ADDR
// station := GetBase ( GetTag ( side * 10 + 15 ) ) ;
40540: LD_ADDR_VAR 0 6
40544: PUSH
40545: LD_VAR 0 1
40549: PUSH
40550: LD_INT 10
40552: MUL
40553: PUSH
40554: LD_INT 15
40556: PLUS
40557: PPUSH
40558: CALL_OW 110
40562: PPUSH
40563: CALL_OW 274
40567: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 06 ) ) then
40568: LD_VAR 0 6
40572: PUSH
40573: LD_VAR 0 6
40577: PPUSH
40578: CALL_OW 279
40582: PUSH
40583: LD_INT 3
40585: ARRAY
40586: PUSH
40587: LD_INT 6
40589: PPUSH
40590: CALL_OW 110
40594: GREATEREQUAL
40595: AND
40596: IFFALSE 40686
// begin PlaceSeeing ( x , y , side , - 15 ) ;
40598: LD_VAR 0 2
40602: PPUSH
40603: LD_VAR 0 3
40607: PPUSH
40608: LD_VAR 0 1
40612: PPUSH
40613: LD_INT 15
40615: NEG
40616: PPUSH
40617: CALL_OW 330
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 06 ) ) ;
40621: LD_VAR 0 6
40625: PPUSH
40626: LD_INT 3
40628: PPUSH
40629: LD_VAR 0 6
40633: PPUSH
40634: CALL_OW 279
40638: PUSH
40639: LD_INT 3
40641: ARRAY
40642: PUSH
40643: LD_INT 6
40645: PPUSH
40646: CALL_OW 110
40650: MINUS
40651: PPUSH
40652: CALL_OW 277
// view_data := [ x , y , side ] ;
40656: LD_ADDR_LOC 81
40660: PUSH
40661: LD_VAR 0 2
40665: PUSH
40666: LD_VAR 0 3
40670: PUSH
40671: LD_VAR 0 1
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: LIST
40680: ST_TO_ADDR
// enable ( 111 ) ;
40681: LD_INT 111
40683: ENABLE_MARKED
// end else
40684: GO 40694
// vysledek := false ;
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_INT 0
40693: ST_TO_ADDR
// result := vysledek ;
40694: LD_ADDR_VAR 0 4
40698: PUSH
40699: LD_VAR 0 5
40703: ST_TO_ADDR
// end ;
40704: LD_VAR 0 4
40708: RET
// every 0 0$2.8 trigger view_data marked 111 do
40709: LD_LOC 81
40713: IFFALSE 40764
40715: GO 40717
40717: DISABLE
// begin wait ( 0 0$30 ) ;
40718: LD_INT 1050
40720: PPUSH
40721: CALL_OW 67
// RemoveSeeing ( view_data [ 1 ] , view_data [ 2 ] , view_data [ 3 ] ) ;
40725: LD_LOC 81
40729: PUSH
40730: LD_INT 1
40732: ARRAY
40733: PPUSH
40734: LD_LOC 81
40738: PUSH
40739: LD_INT 2
40741: ARRAY
40742: PPUSH
40743: LD_LOC 81
40747: PUSH
40748: LD_INT 3
40750: ARRAY
40751: PPUSH
40752: CALL_OW 331
// view_data := 0 ;
40756: LD_ADDR_LOC 81
40760: PUSH
40761: LD_INT 0
40763: ST_TO_ADDR
// end ;
40764: END
// export function Destroy_siberite ( side , un ) ; var vysledek , station , v_can , b_can , it_can , building_list , vehicle_list ; begin
40765: LD_INT 0
40767: PPUSH
40768: PPUSH
40769: PPUSH
40770: PPUSH
40771: PPUSH
40772: PPUSH
40773: PPUSH
40774: PPUSH
// vysledek := true ;
40775: LD_ADDR_VAR 0 4
40779: PUSH
40780: LD_INT 1
40782: ST_TO_ADDR
// it_can := false ;
40783: LD_ADDR_VAR 0 8
40787: PUSH
40788: LD_INT 0
40790: ST_TO_ADDR
// building_list := [ b_siberite_mine , b_siberite_power ] ;
40791: LD_ADDR_VAR 0 9
40795: PUSH
40796: LD_INT 30
40798: PUSH
40799: LD_INT 28
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: ST_TO_ADDR
// vehicle_list := [ us_siberium_rocket , ru_siberium_rocket , ar_selfpropelled_bomb , ru_time_lapser , us_double_laser ] ;
40806: LD_ADDR_VAR 0 10
40810: PUSH
40811: LD_INT 8
40813: PUSH
40814: LD_INT 48
40816: PUSH
40817: LD_INT 29
40819: PUSH
40820: LD_INT 49
40822: PUSH
40823: LD_INT 10
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: LIST
40830: LIST
40831: LIST
40832: ST_TO_ADDR
// b_can := ( GetType ( un ) = unit_building ) and ( ( GetBType ( un ) in building_list ) or ( GetBWeapon ( un ) in vehicle_list ) ) ;
40833: LD_ADDR_VAR 0 7
40837: PUSH
40838: LD_VAR 0 2
40842: PPUSH
40843: CALL_OW 247
40847: PUSH
40848: LD_INT 3
40850: EQUAL
40851: PUSH
40852: LD_VAR 0 2
40856: PPUSH
40857: CALL_OW 266
40861: PUSH
40862: LD_VAR 0 9
40866: IN
40867: PUSH
40868: LD_VAR 0 2
40872: PPUSH
40873: CALL_OW 269
40877: PUSH
40878: LD_VAR 0 10
40882: IN
40883: OR
40884: AND
40885: ST_TO_ADDR
// v_can := ( GetType ( un ) = unit_vehicle ) and ( ( GetWeapon ( un ) in vehicle_list ) or ( GetEngine ( un ) = engine_siberite ) ) ;
40886: LD_ADDR_VAR 0 6
40890: PUSH
40891: LD_VAR 0 2
40895: PPUSH
40896: CALL_OW 247
40900: PUSH
40901: LD_INT 2
40903: EQUAL
40904: PUSH
40905: LD_VAR 0 2
40909: PPUSH
40910: CALL_OW 264
40914: PUSH
40915: LD_VAR 0 10
40919: IN
40920: PUSH
40921: LD_VAR 0 2
40925: PPUSH
40926: CALL_OW 262
40930: PUSH
40931: LD_INT 3
40933: EQUAL
40934: OR
40935: AND
40936: ST_TO_ADDR
// it_can := b_can or v_can ;
40937: LD_ADDR_VAR 0 8
40941: PUSH
40942: LD_VAR 0 7
40946: PUSH
40947: LD_VAR 0 6
40951: OR
40952: ST_TO_ADDR
// station := GetBase ( GetTag ( 100 + side * 10 + 15 ) ) ;
40953: LD_ADDR_VAR 0 5
40957: PUSH
40958: LD_INT 100
40960: PUSH
40961: LD_VAR 0 1
40965: PUSH
40966: LD_INT 10
40968: MUL
40969: PLUS
40970: PUSH
40971: LD_INT 15
40973: PLUS
40974: PPUSH
40975: CALL_OW 110
40979: PPUSH
40980: CALL_OW 274
40984: ST_TO_ADDR
// if station and it_can and ( GetResources ( station ) [ 3 ] >= GetTag ( 106 ) ) then
40985: LD_VAR 0 5
40989: PUSH
40990: LD_VAR 0 8
40994: AND
40995: PUSH
40996: LD_VAR 0 5
41000: PPUSH
41001: CALL_OW 279
41005: PUSH
41006: LD_INT 3
41008: ARRAY
41009: PUSH
41010: LD_INT 106
41012: PPUSH
41013: CALL_OW 110
41017: GREATEREQUAL
41018: AND
41019: IFFALSE 41067
// begin KillUnit ( un ) ;
41021: LD_VAR 0 2
41025: PPUSH
41026: CALL_OW 66
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 106 ) ) ;
41030: LD_VAR 0 5
41034: PPUSH
41035: LD_INT 3
41037: PPUSH
41038: LD_VAR 0 5
41042: PPUSH
41043: CALL_OW 279
41047: PUSH
41048: LD_INT 3
41050: ARRAY
41051: PUSH
41052: LD_INT 106
41054: PPUSH
41055: CALL_OW 110
41059: MINUS
41060: PPUSH
41061: CALL_OW 277
// end else
41065: GO 41075
// vysledek := false ;
41067: LD_ADDR_VAR 0 4
41071: PUSH
41072: LD_INT 0
41074: ST_TO_ADDR
// result := vysledek ;
41075: LD_ADDR_VAR 0 3
41079: PUSH
41080: LD_VAR 0 4
41084: ST_TO_ADDR
// end ;
41085: LD_VAR 0 3
41089: RET
// export function Mass_Teleport ( side , x , y ) ; var vysledek , station , list , un ; begin
41090: LD_INT 0
41092: PPUSH
41093: PPUSH
41094: PPUSH
41095: PPUSH
41096: PPUSH
// vysledek := true ;
41097: LD_ADDR_VAR 0 5
41101: PUSH
41102: LD_INT 1
41104: ST_TO_ADDR
// station := GetBase ( GetTag ( 200 + side * 10 + 15 ) ) ;
41105: LD_ADDR_VAR 0 6
41109: PUSH
41110: LD_INT 200
41112: PUSH
41113: LD_VAR 0 1
41117: PUSH
41118: LD_INT 10
41120: MUL
41121: PLUS
41122: PUSH
41123: LD_INT 15
41125: PLUS
41126: PPUSH
41127: CALL_OW 110
41131: PPUSH
41132: CALL_OW 274
41136: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 206 ) ) then
41137: LD_VAR 0 6
41141: PUSH
41142: LD_VAR 0 6
41146: PPUSH
41147: CALL_OW 279
41151: PUSH
41152: LD_INT 3
41154: ARRAY
41155: PUSH
41156: LD_INT 206
41158: PPUSH
41159: CALL_OW 110
41163: GREATEREQUAL
41164: AND
41165: IFFALSE 41348
// begin SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 206 ) ) ;
41167: LD_VAR 0 6
41171: PPUSH
41172: LD_INT 3
41174: PPUSH
41175: LD_VAR 0 6
41179: PPUSH
41180: CALL_OW 279
41184: PUSH
41185: LD_INT 3
41187: ARRAY
41188: PUSH
41189: LD_INT 206
41191: PPUSH
41192: CALL_OW 110
41196: MINUS
41197: PPUSH
41198: CALL_OW 277
// SetAreaMapShow ( teleport_area , 1 ) ;
41202: LD_INT 24
41204: PPUSH
41205: LD_INT 1
41207: PPUSH
41208: CALL_OW 424
// for un = 1 to 11 do
41212: LD_ADDR_VAR 0 8
41216: PUSH
41217: DOUBLE
41218: LD_INT 1
41220: DEC
41221: ST_TO_ADDR
41222: LD_INT 11
41224: PUSH
41225: FOR_TO
41226: IFFALSE 41254
// begin display_strings := [ ( 11 - un ) ] ;
41228: LD_ADDR_OWVAR 47
41232: PUSH
41233: LD_INT 11
41235: PUSH
41236: LD_VAR 0 8
41240: MINUS
41241: PUSH
41242: EMPTY
41243: LIST
41244: ST_TO_ADDR
// wait ( 0 0$1 ) ;
41245: LD_INT 35
41247: PPUSH
41248: CALL_OW 67
// end ;
41252: GO 41225
41254: POP
41255: POP
// display_strings :=  ;
41256: LD_ADDR_OWVAR 47
41260: PUSH
41261: LD_STRING 
41263: ST_TO_ADDR
// SetAreaMapShow ( teleport_area , 0 ) ;
41264: LD_INT 24
41266: PPUSH
41267: LD_INT 0
41269: PPUSH
41270: CALL_OW 424
// list := FilterUnitsInArea ( teleport_area , [ f_not , [ f_type , unit_building ] ] ) ;
41274: LD_ADDR_VAR 0 7
41278: PUSH
41279: LD_INT 24
41281: PPUSH
41282: LD_INT 3
41284: PUSH
41285: LD_INT 21
41287: PUSH
41288: LD_INT 3
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PPUSH
41299: CALL_OW 70
41303: ST_TO_ADDR
// for un in list do
41304: LD_ADDR_VAR 0 8
41308: PUSH
41309: LD_VAR 0 7
41313: PUSH
41314: FOR_IN
41315: IFFALSE 41344
// TeleportUnit ( un , x , y , 12 , true ) ;
41317: LD_VAR 0 8
41321: PPUSH
41322: LD_VAR 0 2
41326: PPUSH
41327: LD_VAR 0 3
41331: PPUSH
41332: LD_INT 12
41334: PPUSH
41335: LD_INT 1
41337: PPUSH
41338: CALL_OW 483
41342: GO 41314
41344: POP
41345: POP
// end else
41346: GO 41356
// vysledek := false ;
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_INT 0
41355: ST_TO_ADDR
// result := vysledek ;
41356: LD_ADDR_VAR 0 4
41360: PUSH
41361: LD_VAR 0 5
41365: ST_TO_ADDR
// end ;
41366: LD_VAR 0 4
41370: RET
// every 0 0$5 marked 20 do var art , side , recharge ;
41371: GO 41373
41373: DISABLE
41374: LD_INT 0
41376: PPUSH
41377: PPUSH
41378: PPUSH
// begin side := you ;
41379: LD_ADDR_VAR 0 2
41383: PUSH
41384: LD_EXP 1
41388: ST_TO_ADDR
// for art = 0 to artefact_number do
41389: LD_ADDR_VAR 0 1
41393: PUSH
41394: DOUBLE
41395: LD_INT 0
41397: DEC
41398: ST_TO_ADDR
41399: LD_EXP 77
41403: PUSH
41404: FOR_TO
41405: IFFALSE 41505
// begin recharge := art * 100 + side * 10 + 13 ;
41407: LD_ADDR_VAR 0 3
41411: PUSH
41412: LD_VAR 0 1
41416: PUSH
41417: LD_INT 100
41419: MUL
41420: PUSH
41421: LD_VAR 0 2
41425: PUSH
41426: LD_INT 10
41428: MUL
41429: PLUS
41430: PUSH
41431: LD_INT 13
41433: PLUS
41434: ST_TO_ADDR
// if GetTag ( recharge ) > 0 then
41435: LD_VAR 0 3
41439: PPUSH
41440: CALL_OW 110
41444: PUSH
41445: LD_INT 0
41447: GREATER
41448: IFFALSE 41503
// begin SetTag ( recharge , GetTag ( recharge ) - 1 ) ;
41450: LD_VAR 0 3
41454: PPUSH
41455: LD_VAR 0 3
41459: PPUSH
41460: CALL_OW 110
41464: PUSH
41465: LD_INT 1
41467: MINUS
41468: PPUSH
41469: CALL_OW 109
// if not GetTag ( recharge ) then
41473: LD_VAR 0 3
41477: PPUSH
41478: CALL_OW 110
41482: NOT
41483: IFFALSE 41503
// Highlight_Artefact ( side , art + 1 ) ;
41485: LD_VAR 0 2
41489: PPUSH
41490: LD_VAR 0 1
41494: PUSH
41495: LD_INT 1
41497: PLUS
41498: PPUSH
41499: CALL 39240 0 2
// end ; end ;
41503: GO 41404
41505: POP
41506: POP
// enable ;
41507: ENABLE
// end ; end_of_file
41508: PPOPN 3
41510: END
// var us_fort , ru_fort ; var us_place , ru_place ; every 0 0$11 do var side , un , list ;
41511: GO 41513
41513: DISABLE
41514: LD_INT 0
41516: PPUSH
41517: PPUSH
41518: PPUSH
// begin us_fort := [ ] ;
41519: LD_ADDR_LOC 83
41523: PUSH
41524: EMPTY
41525: ST_TO_ADDR
// ru_fort := [ ] ;
41526: LD_ADDR_LOC 84
41530: PUSH
41531: EMPTY
41532: ST_TO_ADDR
// for side in ( cpu_list diff ar ) do
41533: LD_ADDR_VAR 0 1
41537: PUSH
41538: LD_EXP 8
41542: PUSH
41543: LD_EXP 4
41547: DIFF
41548: PUSH
41549: FOR_IN
41550: IFFALSE 41755
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
41552: LD_ADDR_VAR 0 3
41556: PUSH
41557: LD_INT 22
41559: PUSH
41560: LD_VAR 0 1
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 2
41571: PUSH
41572: LD_INT 30
41574: PUSH
41575: LD_INT 32
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 30
41584: PUSH
41585: LD_INT 33
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PPUSH
41601: CALL_OW 69
41605: ST_TO_ADDR
// for un in list do
41606: LD_ADDR_VAR 0 2
41610: PUSH
41611: LD_VAR 0 3
41615: PUSH
41616: FOR_IN
41617: IFFALSE 41751
// case side of us :
41619: LD_VAR 0 1
41623: PUSH
41624: LD_EXP 3
41628: DOUBLE
41629: EQUAL
41630: IFTRUE 41634
41632: GO 41686
41634: POP
// us_fort := us_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; ru :
41635: LD_ADDR_LOC 83
41639: PUSH
41640: LD_LOC 83
41644: PUSH
41645: LD_VAR 0 2
41649: PPUSH
41650: CALL_OW 250
41654: PUSH
41655: LD_VAR 0 2
41659: PPUSH
41660: CALL_OW 251
41664: PUSH
41665: LD_VAR 0 2
41669: PPUSH
41670: CALL_OW 269
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: LIST
41679: PUSH
41680: EMPTY
41681: LIST
41682: ADD
41683: ST_TO_ADDR
41684: GO 41749
41686: LD_EXP 2
41690: DOUBLE
41691: EQUAL
41692: IFTRUE 41696
41694: GO 41748
41696: POP
// ru_fort := ru_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; end ;
41697: LD_ADDR_LOC 84
41701: PUSH
41702: LD_LOC 84
41706: PUSH
41707: LD_VAR 0 2
41711: PPUSH
41712: CALL_OW 250
41716: PUSH
41717: LD_VAR 0 2
41721: PPUSH
41722: CALL_OW 251
41726: PUSH
41727: LD_VAR 0 2
41731: PPUSH
41732: CALL_OW 269
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: LIST
41741: PUSH
41742: EMPTY
41743: LIST
41744: ADD
41745: ST_TO_ADDR
41746: GO 41749
41748: POP
41749: GO 41616
41751: POP
41752: POP
// end ;
41753: GO 41549
41755: POP
41756: POP
// end ;
41757: PPOPN 3
41759: END
// every 0 0$10.5 do var un , w , x , y , list ;
41760: GO 41762
41762: DISABLE
41763: LD_INT 0
41765: PPUSH
41766: PPUSH
41767: PPUSH
41768: PPUSH
41769: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_heavy_gun ] , [ f_bweapon , us_radar ] , [ f_bweapon , us_double_laser ] ] ] ) ;
41770: LD_ADDR_VAR 0 5
41774: PUSH
41775: LD_INT 22
41777: PUSH
41778: LD_EXP 3
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 2
41789: PUSH
41790: LD_INT 30
41792: PUSH
41793: LD_INT 32
41795: PUSH
41796: EMPTY
41797: LIST
41798: LIST
41799: PUSH
41800: LD_INT 30
41802: PUSH
41803: LD_INT 33
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: LIST
41814: PUSH
41815: LD_INT 57
41817: PUSH
41818: EMPTY
41819: LIST
41820: PUSH
41821: LD_INT 3
41823: PUSH
41824: LD_INT 2
41826: PUSH
41827: LD_INT 35
41829: PUSH
41830: LD_INT 7
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 35
41839: PUSH
41840: LD_INT 6
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 35
41849: PUSH
41850: LD_INT 11
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 35
41859: PUSH
41860: LD_INT 10
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: LIST
41871: LIST
41872: LIST
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: LIST
41878: LIST
41879: LIST
41880: PPUSH
41881: CALL_OW 69
41885: ST_TO_ADDR
// for un in list do
41886: LD_ADDR_VAR 0 1
41890: PUSH
41891: LD_VAR 0 5
41895: PUSH
41896: FOR_IN
41897: IFFALSE 42012
// begin x := GetX ( un ) ;
41899: LD_ADDR_VAR 0 3
41903: PUSH
41904: LD_VAR 0 1
41908: PPUSH
41909: CALL_OW 250
41913: ST_TO_ADDR
// y := GetY ( un ) ;
41914: LD_ADDR_VAR 0 4
41918: PUSH
41919: LD_VAR 0 1
41923: PPUSH
41924: CALL_OW 251
41928: ST_TO_ADDR
// for w in us_fort do
41929: LD_ADDR_VAR 0 2
41933: PUSH
41934: LD_LOC 83
41938: PUSH
41939: FOR_IN
41940: IFFALSE 42001
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
41942: LD_VAR 0 3
41946: PUSH
41947: LD_VAR 0 2
41951: PUSH
41952: LD_INT 1
41954: ARRAY
41955: EQUAL
41956: PUSH
41957: LD_VAR 0 4
41961: PUSH
41962: LD_VAR 0 2
41966: PUSH
41967: LD_INT 2
41969: ARRAY
41970: EQUAL
41971: AND
41972: IFFALSE 41992
// ComPlaceWeapon ( un , w [ 3 ] ) ;
41974: LD_VAR 0 1
41978: PPUSH
41979: LD_VAR 0 2
41983: PUSH
41984: LD_INT 3
41986: ARRAY
41987: PPUSH
41988: CALL_OW 148
// wait ( 8 ) ;
41992: LD_INT 8
41994: PPUSH
41995: CALL_OW 67
// end ;
41999: GO 41939
42001: POP
42002: POP
// wait ( 27 ) ;
42003: LD_INT 27
42005: PPUSH
42006: CALL_OW 67
// end ;
42010: GO 41896
42012: POP
42013: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42014: LD_INT 175
42016: PPUSH
42017: LD_INT 350
42019: PPUSH
42020: CALL_OW 12
42024: PPUSH
42025: CALL_OW 67
// enable ;
42029: ENABLE
// end ;
42030: PPOPN 5
42032: END
// every 0 0$10.7 do var un , w , x , y , list ;
42033: GO 42035
42035: DISABLE
42036: LD_INT 0
42038: PPUSH
42039: PPUSH
42040: PPUSH
42041: PPUSH
42042: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , ru_rocket ] , [ f_bweapon , ru_heavy_gun ] , [ f_bweapon , ru_time_lapser ] , [ f_bweapon , ru_gatling_gun ] ] ] ) ;
42043: LD_ADDR_VAR 0 5
42047: PUSH
42048: LD_INT 22
42050: PUSH
42051: LD_EXP 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 2
42062: PUSH
42063: LD_INT 30
42065: PUSH
42066: LD_INT 32
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 30
42075: PUSH
42076: LD_INT 33
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 57
42090: PUSH
42091: EMPTY
42092: LIST
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: LD_INT 2
42099: PUSH
42100: LD_INT 35
42102: PUSH
42103: LD_INT 47
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 35
42112: PUSH
42113: LD_INT 46
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 35
42122: PUSH
42123: LD_INT 49
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 35
42132: PUSH
42133: LD_INT 43
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: PPUSH
42154: CALL_OW 69
42158: ST_TO_ADDR
// for un in list do
42159: LD_ADDR_VAR 0 1
42163: PUSH
42164: LD_VAR 0 5
42168: PUSH
42169: FOR_IN
42170: IFFALSE 42285
// begin x := GetX ( un ) ;
42172: LD_ADDR_VAR 0 3
42176: PUSH
42177: LD_VAR 0 1
42181: PPUSH
42182: CALL_OW 250
42186: ST_TO_ADDR
// y := GetY ( un ) ;
42187: LD_ADDR_VAR 0 4
42191: PUSH
42192: LD_VAR 0 1
42196: PPUSH
42197: CALL_OW 251
42201: ST_TO_ADDR
// for w in ru_fort do
42202: LD_ADDR_VAR 0 2
42206: PUSH
42207: LD_LOC 84
42211: PUSH
42212: FOR_IN
42213: IFFALSE 42274
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42215: LD_VAR 0 3
42219: PUSH
42220: LD_VAR 0 2
42224: PUSH
42225: LD_INT 1
42227: ARRAY
42228: EQUAL
42229: PUSH
42230: LD_VAR 0 4
42234: PUSH
42235: LD_VAR 0 2
42239: PUSH
42240: LD_INT 2
42242: ARRAY
42243: EQUAL
42244: AND
42245: IFFALSE 42265
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42247: LD_VAR 0 1
42251: PPUSH
42252: LD_VAR 0 2
42256: PUSH
42257: LD_INT 3
42259: ARRAY
42260: PPUSH
42261: CALL_OW 148
// wait ( 8 ) ;
42265: LD_INT 8
42267: PPUSH
42268: CALL_OW 67
// end ;
42272: GO 42212
42274: POP
42275: POP
// wait ( 27 ) ;
42276: LD_INT 27
42278: PPUSH
42279: CALL_OW 67
// end ;
42283: GO 42169
42285: POP
42286: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42287: LD_INT 175
42289: PPUSH
42290: LD_INT 350
42292: PPUSH
42293: CALL_OW 12
42297: PPUSH
42298: CALL_OW 67
// enable ;
42302: ENABLE
// end ; end_of_file
42303: PPOPN 5
42305: END
// every 0 0$2 + 0 0$0.1 do
42306: GO 42308
42308: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
42309: LD_INT 22
42311: PUSH
42312: LD_INT 7
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 2
42321: PUSH
42322: LD_INT 25
42324: PUSH
42325: LD_INT 12
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 25
42334: PUSH
42335: LD_INT 16
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 25
42344: PUSH
42345: LD_INT 15
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 25
42354: PUSH
42355: LD_INT 17
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PPUSH
42373: CALL_OW 69
42377: PUSH
42378: LD_INT 22
42380: PUSH
42381: LD_INT 7
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 21
42390: PUSH
42391: LD_INT 1
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: PUSH
42401: LD_INT 2
42403: PUSH
42404: LD_INT 25
42406: PUSH
42407: LD_INT 12
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 25
42416: PUSH
42417: LD_INT 16
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 25
42426: PUSH
42427: LD_INT 15
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 25
42436: PUSH
42437: LD_INT 17
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: LIST
42459: PPUSH
42460: CALL_OW 69
42464: GREATER
42465: IFFALSE 42476
// begin SetAchievement ( ACH_POTA ) ;
42467: LD_STRING ACH_POTA
42469: PPUSH
42470: CALL_OW 543
// exit ;
42474: GO 42477
// end ; enable ;
42476: ENABLE
// end ;
42477: END
// export function SA_OnMissionComplete ; begin
42478: LD_INT 0
42480: PPUSH
// SetAchievement ( ACH_FBF ) ;
42481: LD_STRING ACH_FBF
42483: PPUSH
42484: CALL_OW 543
// end ; end_of_file
42488: LD_VAR 0 1
42492: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
42493: LD_INT 0
42495: PPUSH
42496: PPUSH
// if not missionNumber then
42497: LD_VAR 0 2
42501: NOT
42502: IFFALSE 42506
// exit ;
42504: GO 42636
// achiv := false ;
42506: LD_ADDR_VAR 0 7
42510: PUSH
42511: LD_INT 0
42513: ST_TO_ADDR
// case campaignNumber of 1 :
42514: LD_VAR 0 1
42518: PUSH
42519: LD_INT 1
42521: DOUBLE
42522: EQUAL
42523: IFTRUE 42527
42525: GO 42538
42527: POP
// achiv := ACH_GOTA ; 2 :
42528: LD_ADDR_VAR 0 7
42532: PUSH
42533: LD_STRING ACH_GOTA
42535: ST_TO_ADDR
42536: GO 42588
42538: LD_INT 2
42540: DOUBLE
42541: EQUAL
42542: IFTRUE 42546
42544: GO 42549
42546: POP
// ; 3 :
42547: GO 42588
42549: LD_INT 3
42551: DOUBLE
42552: EQUAL
42553: IFTRUE 42557
42555: GO 42568
42557: POP
// achiv := ACH_MOTSU ; 4 :
42558: LD_ADDR_VAR 0 7
42562: PUSH
42563: LD_STRING ACH_MOTSU
42565: ST_TO_ADDR
42566: GO 42588
42568: LD_INT 4
42570: DOUBLE
42571: EQUAL
42572: IFTRUE 42576
42574: GO 42587
42576: POP
// achiv := ACH_LOP ; end ;
42577: LD_ADDR_VAR 0 7
42581: PUSH
42582: LD_STRING ACH_LOP
42584: ST_TO_ADDR
42585: GO 42588
42587: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
42588: LD_OWVAR 67
42592: PUSH
42593: LD_INT 3
42595: EQUAL
42596: PUSH
42597: LD_VAR 0 7
42601: AND
42602: PUSH
42603: LD_VAR 0 3
42607: AND
42608: PUSH
42609: LD_VAR 0 4
42613: AND
42614: PUSH
42615: LD_VAR 0 5
42619: AND
42620: IFFALSE 42636
// SetAchievementEX ( achiv , missionNumber ) ;
42622: LD_VAR 0 7
42626: PPUSH
42627: LD_VAR 0 2
42631: PPUSH
42632: CALL_OW 564
// end ;
42636: LD_VAR 0 6
42640: RET
// export function SA_BehemothConstructed ; begin
42641: LD_INT 0
42643: PPUSH
// SetAchievement ( ACH_SMC ) ;
42644: LD_STRING ACH_SMC
42646: PPUSH
42647: CALL_OW 543
// end ;
42651: LD_VAR 0 1
42655: RET

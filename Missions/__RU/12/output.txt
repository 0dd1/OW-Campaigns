// export t_kill , t_intimidate , t_persuade , t_pay , t_beat , t_killbeat ; export you , americans , arabians , nature ; export mcdef1_difficulty , mcdef2_difficulty , mcdef3_difficulty , mcdef4_difficulty , mcdef5_difficulty ; export gossudarov_mech_skill ; export cap_bases ; export your_bases ; export aiH , aiN , aiZ ; export ai_nation ; export ai_s ; export ai ; export plat_i ; export apemans ; export Diplomacy , Goss ; export BehemothSeen ; export vedci_zacali_zdrhat ; export run_sci ; export utek , utek_e ; export art_cargo1 ; export your_cars ; export your_builds ; export your_humans ; export function inicializace_main ; begin
   0: LD_INT 0
   2: PPUSH
// you := 3 ;
   3: LD_ADDR_EXP 7
   7: PUSH
   8: LD_INT 3
  10: ST_TO_ADDR
// americans := 1 ;
  11: LD_ADDR_EXP 8
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabians := 2 ;
  19: LD_ADDR_EXP 9
  23: PUSH
  24: LD_INT 2
  26: ST_TO_ADDR
// nature := 0 ;
  27: LD_ADDR_EXP 10
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// utek := [ [ 55 , 21 ] , [ 83 , 36 ] , [ 103 , 70 ] , [ 142 , 88 ] ] ;
  35: LD_ADDR_EXP 32
  39: PUSH
  40: LD_INT 55
  42: PUSH
  43: LD_INT 21
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: PUSH
  50: LD_INT 83
  52: PUSH
  53: LD_INT 36
  55: PUSH
  56: EMPTY
  57: LIST
  58: LIST
  59: PUSH
  60: LD_INT 103
  62: PUSH
  63: LD_INT 70
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: PUSH
  70: LD_INT 142
  72: PUSH
  73: LD_INT 88
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: PUSH
  80: EMPTY
  81: LIST
  82: LIST
  83: LIST
  84: LIST
  85: ST_TO_ADDR
// utek_e := [ 186 , 55 ] ;
  86: LD_ADDR_EXP 33
  90: PUSH
  91: LD_INT 186
  93: PUSH
  94: LD_INT 55
  96: PUSH
  97: EMPTY
  98: LIST
  99: LIST
 100: ST_TO_ADDR
// cap_bases := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// t_kill := 1 ;
 109: LD_ADDR_EXP 1
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// t_intimidate := 2 ;
 117: LD_ADDR_EXP 2
 121: PUSH
 122: LD_INT 2
 124: ST_TO_ADDR
// t_persuade := 3 ;
 125: LD_ADDR_EXP 3
 129: PUSH
 130: LD_INT 3
 132: ST_TO_ADDR
// t_pay := 4 ;
 133: LD_ADDR_EXP 4
 137: PUSH
 138: LD_INT 4
 140: ST_TO_ADDR
// t_beat := 5 ;
 141: LD_ADDR_EXP 5
 145: PUSH
 146: LD_INT 5
 148: ST_TO_ADDR
// t_killbeat := 10 ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 10
 156: ST_TO_ADDR
// Diplomacy := true ;
 157: LD_ADDR_EXP 27
 161: PUSH
 162: LD_INT 1
 164: ST_TO_ADDR
// Goss := true ;
 165: LD_ADDR_EXP 28
 169: PUSH
 170: LD_INT 1
 172: ST_TO_ADDR
// ai_s := [ 6 , 5 , 2 , 8 , 7 ] ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 6
 180: PUSH
 181: LD_INT 5
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: LD_INT 7
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// ai := [ 6 , 5 , 2 , 8 , 7 ] ;
 200: LD_ADDR_EXP 24
 204: PUSH
 205: LD_INT 6
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 2
 213: PUSH
 214: LD_INT 8
 216: PUSH
 217: LD_INT 7
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: ST_TO_ADDR
// plat_i := 1 ;
 227: LD_ADDR_EXP 25
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// aiH := [ ] ;
 235: LD_ADDR_EXP 19
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// aiN := [ ai_s [ 2 ] , ai_s [ 3 ] , ai_s [ 4 ] , ai_s [ 5 ] ] ;
 242: LD_ADDR_EXP 20
 246: PUSH
 247: LD_EXP 23
 251: PUSH
 252: LD_INT 2
 254: ARRAY
 255: PUSH
 256: LD_EXP 23
 260: PUSH
 261: LD_INT 3
 263: ARRAY
 264: PUSH
 265: LD_EXP 23
 269: PUSH
 270: LD_INT 4
 272: ARRAY
 273: PUSH
 274: LD_EXP 23
 278: PUSH
 279: LD_INT 5
 281: ARRAY
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: ST_TO_ADDR
// aiZ := [ ai_s [ 1 ] ] ;
 289: LD_ADDR_EXP 21
 293: PUSH
 294: LD_EXP 23
 298: PUSH
 299: LD_INT 1
 301: ARRAY
 302: PUSH
 303: EMPTY
 304: LIST
 305: ST_TO_ADDR
// your_bases := [ ] ;
 306: LD_ADDR_EXP 18
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// cap_bases := 0 ;
 313: LD_ADDR_EXP 17
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// art_cargo1 := art_cargo ;
 321: LD_ADDR_EXP 34
 325: PUSH
 326: LD_INT 121
 328: ST_TO_ADDR
// ai_nation := nation_russian ;
 329: LD_ADDR_EXP 22
 333: PUSH
 334: LD_INT 3
 336: ST_TO_ADDR
// debug_strings := [ [ ] , [ ] , [ ] ] ;
 337: LD_ADDR_OWVAR 48
 341: PUSH
 342: EMPTY
 343: PUSH
 344: EMPTY
 345: PUSH
 346: EMPTY
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: ST_TO_ADDR
// end ;
 353: LD_VAR 0 1
 357: RET
// export vyhrano ; export function VyhraPlaton ; begin
 358: LD_INT 0
 360: PPUSH
// if not vyhrano then
 361: LD_EXP 38
 365: NOT
 366: IFFALSE 497
// begin vyhrano := true ;
 368: LD_ADDR_EXP 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// cap_bases := 5 ;
 376: LD_ADDR_EXP 17
 380: PUSH
 381: LD_INT 5
 383: ST_TO_ADDR
// Query ( QEndInfo ) ;
 384: LD_STRING QEndInfo
 386: PPUSH
 387: CALL_OW 97
// ExclusiveOn ;
 391: CALL_OW 4
// wait ( 1 ) ;
 395: LD_INT 1
 397: PPUSH
 398: CALL_OW 67
// DEnd ;
 402: CALL 8161 0 0
// ExclusiveOff ;
 406: CALL_OW 5
// SetMedals ;
 410: CALL 502 0 0
// GiveMedals ( Platon ) ;
 414: LD_STRING Platon
 416: PPUSH
 417: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ) ;
 421: LD_INT 22
 423: PUSH
 424: LD_EXP 7
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 21
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 3
 445: PUSH
 446: LD_INT 23
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: PPUSH
 470: CALL_OW 43
// Save ;
 474: CALL 9156 0 0
// YouWin ;
 478: CALL_OW 103
// ExclusiveOn ;
 482: CALL_OW 4
// wait ( 1 ) ;
 486: LD_INT 1
 488: PPUSH
 489: CALL_OW 67
// ExclusiveOff ;
 493: CALL_OW 5
// end ; end ;
 497: LD_VAR 0 1
 501: RET
// export function SetMedals ; begin
 502: LD_INT 0
 504: PPUSH
// AddMedal ( All , cap_bases = 5 ) ;
 505: LD_STRING All
 507: PPUSH
 508: LD_EXP 17
 512: PUSH
 513: LD_INT 5
 515: EQUAL
 516: PPUSH
 517: CALL_OW 101
// AddMedal ( Diplomacy , Diplomacy ) ;
 521: LD_STRING Diplomacy
 523: PPUSH
 524: LD_EXP 27
 528: PPUSH
 529: CALL_OW 101
// AddMedal ( Goss , Goss ) ;
 533: LD_STRING Goss
 535: PPUSH
 536: LD_EXP 28
 540: PPUSH
 541: CALL_OW 101
// SA_EndMission ( 3 , 12 , cap_bases = 5 , Diplomacy > 0 , Goss > 0 ) ;
 545: LD_INT 3
 547: PPUSH
 548: LD_INT 12
 550: PPUSH
 551: LD_EXP 17
 555: PUSH
 556: LD_INT 5
 558: EQUAL
 559: PPUSH
 560: LD_EXP 27
 564: PUSH
 565: LD_INT 0
 567: GREATER
 568: PPUSH
 569: LD_EXP 28
 573: PUSH
 574: LD_INT 0
 576: GREATER
 577: PPUSH
 578: CALL 33172 0 5
// end ;
 582: LD_VAR 0 1
 586: RET
// export function LostBurlak ; begin
 587: LD_INT 0
 589: PPUSH
// YouLost ( Burlak ) ;
 590: LD_STRING Burlak
 592: PPUSH
 593: CALL_OW 104
// end ;
 597: LD_VAR 0 1
 601: RET
// export function LostArte ; begin
 602: LD_INT 0
 604: PPUSH
// YouLost ( Arte ) ;
 605: LD_STRING Arte
 607: PPUSH
 608: CALL_OW 104
// end ;
 612: LD_VAR 0 1
 616: RET
// export function set_difficulty ; begin
 617: LD_INT 0
 619: PPUSH
// mcdef1_difficulty := [ 200 , 230 , 260 ] [ difficulty ] ;
 620: LD_ADDR_EXP 11
 624: PUSH
 625: LD_INT 200
 627: PUSH
 628: LD_INT 230
 630: PUSH
 631: LD_INT 260
 633: PUSH
 634: EMPTY
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_OWVAR 67
 643: ARRAY
 644: ST_TO_ADDR
// mcdef2_difficulty := [ 150 , 180 , 200 ] [ difficulty ] ;
 645: LD_ADDR_EXP 12
 649: PUSH
 650: LD_INT 150
 652: PUSH
 653: LD_INT 180
 655: PUSH
 656: LD_INT 200
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: PUSH
 664: LD_OWVAR 67
 668: ARRAY
 669: ST_TO_ADDR
// mcdef3_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 670: LD_ADDR_EXP 13
 674: PUSH
 675: LD_INT 170
 677: PUSH
 678: LD_INT 200
 680: PUSH
 681: LD_INT 230
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: PUSH
 689: LD_OWVAR 67
 693: ARRAY
 694: ST_TO_ADDR
// mcdef4_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 695: LD_ADDR_EXP 14
 699: PUSH
 700: LD_INT 170
 702: PUSH
 703: LD_INT 200
 705: PUSH
 706: LD_INT 230
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: PUSH
 714: LD_OWVAR 67
 718: ARRAY
 719: ST_TO_ADDR
// mcdef5_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 720: LD_ADDR_EXP 15
 724: PUSH
 725: LD_INT 170
 727: PUSH
 728: LD_INT 200
 730: PUSH
 731: LD_INT 230
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_OWVAR 67
 743: ARRAY
 744: ST_TO_ADDR
// gossudarov_mech_skill := [ 0 , 2 , 4 ] [ difficulty ] ;
 745: LD_ADDR_EXP 16
 749: PUSH
 750: LD_INT 0
 752: PUSH
 753: LD_INT 2
 755: PUSH
 756: LD_INT 4
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: LD_OWVAR 67
 768: ARRAY
 769: ST_TO_ADDR
// end ;
 770: LD_VAR 0 1
 774: RET
// export function get_your_units ; var a ; begin
 775: LD_INT 0
 777: PPUSH
 778: PPUSH
// a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
 779: LD_ADDR_VAR 0 2
 783: PUSH
 784: LD_INT 22
 786: PUSH
 787: LD_EXP 7
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: EMPTY
 797: LIST
 798: PPUSH
 799: CALL_OW 69
 803: ST_TO_ADDR
// your_humans := UnitFilter ( a , [ [ f_type , unit_human ] ] ) ;
 804: LD_ADDR_EXP 37
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: LD_INT 21
 816: PUSH
 817: LD_INT 1
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: PPUSH
 827: CALL_OW 72
 831: ST_TO_ADDR
// your_cars := UnitFilter ( a , [ [ f_type , unit_vehicle ] ] ) ;
 832: LD_ADDR_EXP 35
 836: PUSH
 837: LD_VAR 0 2
 841: PPUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: PPUSH
 855: CALL_OW 72
 859: ST_TO_ADDR
// your_builds := UnitFilter ( a , [ [ f_type , unit_building ] ] ) ;
 860: LD_ADDR_EXP 36
 864: PUSH
 865: LD_VAR 0 2
 869: PPUSH
 870: LD_INT 21
 872: PUSH
 873: LD_INT 3
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: PUSH
 880: EMPTY
 881: LIST
 882: PPUSH
 883: CALL_OW 72
 887: ST_TO_ADDR
// end ;
 888: LD_VAR 0 1
 892: RET
// every 0 0$1 do var i ;
 893: GO 895
 895: DISABLE
 896: LD_INT 0
 898: PPUSH
// begin for i in ai do
 899: LD_ADDR_VAR 0 1
 903: PUSH
 904: LD_EXP 24
 908: PUSH
 909: FOR_IN
 910: IFFALSE 1107
// case GetAttitude ( i , you ) of att_friend :
 912: LD_VAR 0 1
 916: PPUSH
 917: LD_EXP 7
 921: PPUSH
 922: CALL_OW 81
 926: PUSH
 927: LD_INT 1
 929: DOUBLE
 930: EQUAL
 931: IFTRUE 935
 933: GO 986
 935: POP
// begin aiH := aiH union i ;
 936: LD_ADDR_EXP 19
 940: PUSH
 941: LD_EXP 19
 945: PUSH
 946: LD_VAR 0 1
 950: UNION
 951: ST_TO_ADDR
// aiZ := aiZ diff i ;
 952: LD_ADDR_EXP 21
 956: PUSH
 957: LD_EXP 21
 961: PUSH
 962: LD_VAR 0 1
 966: DIFF
 967: ST_TO_ADDR
// aiN := aiN diff i ;
 968: LD_ADDR_EXP 20
 972: PUSH
 973: LD_EXP 20
 977: PUSH
 978: LD_VAR 0 1
 982: DIFF
 983: ST_TO_ADDR
// end ; att_neutral :
 984: GO 1105
 986: LD_INT 0
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1045
 994: POP
// begin aiN := aiN union i ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_EXP 20
1004: PUSH
1005: LD_VAR 0 1
1009: UNION
1010: ST_TO_ADDR
// aiZ := aiZ diff i ;
1011: LD_ADDR_EXP 21
1015: PUSH
1016: LD_EXP 21
1020: PUSH
1021: LD_VAR 0 1
1025: DIFF
1026: ST_TO_ADDR
// aiH := aiH diff i ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_EXP 19
1036: PUSH
1037: LD_VAR 0 1
1041: DIFF
1042: ST_TO_ADDR
// end ; att_enemy :
1043: GO 1105
1045: LD_INT 2
1047: DOUBLE
1048: EQUAL
1049: IFTRUE 1053
1051: GO 1104
1053: POP
// begin aiZ := aiZ union i ;
1054: LD_ADDR_EXP 21
1058: PUSH
1059: LD_EXP 21
1063: PUSH
1064: LD_VAR 0 1
1068: UNION
1069: ST_TO_ADDR
// aiH := aiH diff i ;
1070: LD_ADDR_EXP 19
1074: PUSH
1075: LD_EXP 19
1079: PUSH
1080: LD_VAR 0 1
1084: DIFF
1085: ST_TO_ADDR
// aiN := aiN diff i ;
1086: LD_ADDR_EXP 20
1090: PUSH
1091: LD_EXP 20
1095: PUSH
1096: LD_VAR 0 1
1100: DIFF
1101: ST_TO_ADDR
// end ; end ;
1102: GO 1105
1104: POP
1105: GO 909
1107: POP
1108: POP
// enable ;
1109: ENABLE
// end ;
1110: PPOPN 1
1112: END
// every 0 0$1 do
1113: GO 1115
1115: DISABLE
// begin debug_strings := [ [ ( tick div 0 0$1 ) div 60 , ( tick div 0 0$1 ) mod 60 ] , debug_strings [ 2 ] , debug_strings [ 3 ] ] ;
1116: LD_ADDR_OWVAR 48
1120: PUSH
1121: LD_OWVAR 1
1125: PUSH
1126: LD_INT 35
1128: DIV
1129: PUSH
1130: LD_INT 60
1132: DIV
1133: PUSH
1134: LD_OWVAR 1
1138: PUSH
1139: LD_INT 35
1141: DIV
1142: PUSH
1143: LD_INT 60
1145: MOD
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_OWVAR 48
1155: PUSH
1156: LD_INT 2
1158: ARRAY
1159: PUSH
1160: LD_OWVAR 48
1164: PUSH
1165: LD_INT 3
1167: ARRAY
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: ST_TO_ADDR
// enable ;
1174: ENABLE
// end ;
1175: END
// starting begin SA_OnMissionStart ;
1176: CALL 33142 0 0
// inicializace_main ;
1180: CALL 0 0 0
// inicializace_ai ;
1184: CALL 22661 0 0
// inicializace_functions ;
1188: CALL 9810 0 0
// inicializace_ai_b_repair ;
1192: CALL 22235 0 0
// inicializace_ai_b_build ;
1196: CALL 16165 0 0
// inicializace_ai_defend ;
1200: CALL 11626 0 0
// inicializace_ai_c_make ;
1204: CALL 14042 0 0
// inicializace_ai_c_repair ;
1208: CALL 12574 0 0
// disable ( 10 ) ;
1212: LD_INT 10
1214: DISABLE_MARKED
// disable ( 11 ) ;
1215: LD_INT 11
1217: DISABLE_MARKED
// disable ( 12 ) ;
1218: LD_INT 12
1220: DISABLE_MARKED
// disable ( 115 ) ;
1221: LD_INT 115
1223: DISABLE_MARKED
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_type , unit_human ] , [ f_class , class_apeman ] ] ) ;
1224: LD_ADDR_EXP 26
1228: PUSH
1229: LD_INT 23
1231: PUSH
1232: LD_INT 0
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: PUSH
1239: LD_INT 21
1241: PUSH
1242: LD_INT 1
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: PUSH
1249: LD_INT 25
1251: PUSH
1252: LD_INT 12
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: LIST
1263: PPUSH
1264: CALL_OW 69
1268: ST_TO_ADDR
// set_difficulty ;
1269: CALL 617 0 0
// SetCargo ( art_cargo1 , mat_artifact , 4 * 10 ) ;
1273: LD_EXP 34
1277: PPUSH
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PUSH
1284: LD_INT 10
1286: MUL
1287: PPUSH
1288: CALL_OW 290
// load ;
1292: CALL 8309 0 0
// inicializace_dialogues ;
1296: CALL 1321 0 0
// place_ru ;
1300: CALL 8850 0 0
// build_map ;
1304: CALL 20510 0 0
// get_groups ;
1308: CALL 22803 0 0
// get_your_units ;
1312: CALL 775 0 0
// DStart ;
1316: CALL 1496 0 0
// end ; end_of_file
1320: END
// var Gla , Bur , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ; var talking ; export function inicializace_dialogues ; begin
1321: LD_INT 0
1323: PPUSH
// Bur := Burlak ;
1324: LD_ADDR_LOC 2
1328: PUSH
1329: LD_EXP 41
1333: ST_TO_ADDR
// Gla := Gladkov ;
1334: LD_ADDR_LOC 1
1338: PUSH
1339: LD_EXP 44
1343: ST_TO_ADDR
// Glb := Gleb ;
1344: LD_ADDR_LOC 10
1348: PUSH
1349: LD_EXP 50
1353: ST_TO_ADDR
// Pla := Platonov ;
1354: LD_ADDR_LOC 3
1358: PUSH
1359: LD_EXP 42
1363: ST_TO_ADDR
// Gos := Gossudarov ;
1364: LD_ADDR_LOC 4
1368: PUSH
1369: LD_EXP 43
1373: ST_TO_ADDR
// Fad := Fadeev ;
1374: LD_ADDR_LOC 5
1378: PUSH
1379: LD_EXP 45
1383: ST_TO_ADDR
// Bor := Borodin ;
1384: LD_ADDR_LOC 6
1388: PUSH
1389: LD_EXP 46
1393: ST_TO_ADDR
// Tsr := Tsaritsyn ;
1394: LD_ADDR_LOC 7
1398: PUSH
1399: LD_EXP 47
1403: ST_TO_ADDR
// Dav := Davidov ;
1404: LD_ADDR_LOC 8
1408: PUSH
1409: LD_EXP 48
1413: ST_TO_ADDR
// Eis := Eisenstein ;
1414: LD_ADDR_LOC 9
1418: PUSH
1419: LD_EXP 49
1423: ST_TO_ADDR
// talking := [ Bur , Gla , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ] ;
1424: LD_ADDR_LOC 11
1428: PUSH
1429: LD_LOC 2
1433: PUSH
1434: LD_LOC 1
1438: PUSH
1439: LD_LOC 3
1443: PUSH
1444: LD_LOC 4
1448: PUSH
1449: LD_LOC 5
1453: PUSH
1454: LD_LOC 6
1458: PUSH
1459: LD_LOC 7
1463: PUSH
1464: LD_LOC 8
1468: PUSH
1469: LD_LOC 9
1473: PUSH
1474: LD_LOC 10
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// end ;
1491: LD_VAR 0 1
1495: RET
// export function DStart ; begin
1496: LD_INT 0
1498: PPUSH
// hide_interface_automaticaly := true ;
1499: LD_ADDR_OWVAR 53
1503: PUSH
1504: LD_INT 1
1506: ST_TO_ADDR
// InGameOn ;
1507: CALL_OW 8
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
1511: LD_LOC 2
1515: PPUSH
1516: CALL_OW 310
1520: PPUSH
1521: CALL_OW 87
// CenterNowOnUnits ( Bur ) ;
1525: LD_LOC 2
1529: PPUSH
1530: CALL_OW 87
// while IsInUnit ( bur ) do
1534: LD_LOC 2
1538: PPUSH
1539: CALL_OW 310
1543: IFFALSE 1563
// begin ComExitVehicle ( Bur ) ;
1545: LD_LOC 2
1549: PPUSH
1550: CALL_OW 121
// wait ( 0 0$0.3 ) ;
1554: LD_INT 10
1556: PPUSH
1557: CALL_OW 67
// end ;
1561: GO 1534
// Say ( Bur , DStart-Bur-1 ) ;
1563: LD_LOC 2
1567: PPUSH
1568: LD_STRING DStart-Bur-1
1570: PPUSH
1571: CALL_OW 88
// Say ( Gla , DStart-Gla-1 ) ;
1575: LD_LOC 1
1579: PPUSH
1580: LD_STRING DStart-Gla-1
1582: PPUSH
1583: CALL_OW 88
// Say ( Bur , DStart-Bur-2 ) ;
1587: LD_LOC 2
1591: PPUSH
1592: LD_STRING DStart-Bur-2
1594: PPUSH
1595: CALL_OW 88
// Say ( Gla , DStart-Gla-2 ) ;
1599: LD_LOC 1
1603: PPUSH
1604: LD_STRING DStart-Gla-2
1606: PPUSH
1607: CALL_OW 88
// Say ( Bur , DStart-Bur-3 ) ;
1611: LD_LOC 2
1615: PPUSH
1616: LD_STRING DStart-Bur-3
1618: PPUSH
1619: CALL_OW 88
// Say ( Gla , DStart-Gla-3 ) ;
1623: LD_LOC 1
1627: PPUSH
1628: LD_STRING DStart-Gla-3
1630: PPUSH
1631: CALL_OW 88
// Say ( Bur , DStart-Bur-4 ) ;
1635: LD_LOC 2
1639: PPUSH
1640: LD_STRING DStart-Bur-4
1642: PPUSH
1643: CALL_OW 88
// SetBName ( da , bluekher ) ;
1647: LD_INT 1
1649: PPUSH
1650: LD_STRING bluekher
1652: PPUSH
1653: CALL_OW 500
// SetBName ( dc , yegorov ) ;
1657: LD_INT 80
1659: PPUSH
1660: LD_STRING yegorov
1662: PPUSH
1663: CALL_OW 500
// SetBName ( dd , ryutin ) ;
1667: LD_INT 28
1669: PPUSH
1670: LD_STRING ryutin
1672: PPUSH
1673: CALL_OW 500
// SetBName ( db , budonny ) ;
1677: LD_INT 51
1679: PPUSH
1680: LD_STRING budonny
1682: PPUSH
1683: CALL_OW 500
// SetBName ( de , yakir ) ;
1687: LD_INT 37
1689: PPUSH
1690: LD_STRING yakir
1692: PPUSH
1693: CALL_OW 500
// RevealFogArea ( you , near_base ) ;
1697: LD_EXP 7
1701: PPUSH
1702: LD_INT 7
1704: PPUSH
1705: CALL_OW 332
// CenterOnUnits ( dc ) ;
1709: LD_INT 80
1711: PPUSH
1712: CALL_OW 85
// DWait ( 0 0$2 ) ;
1716: LD_INT 70
1718: PPUSH
1719: CALL_OW 68
// Say ( Gla , DStart-Gla-4 ) ;
1723: LD_LOC 1
1727: PPUSH
1728: LD_STRING DStart-Gla-4
1730: PPUSH
1731: CALL_OW 88
// CenterOnUnits ( dd ) ;
1735: LD_INT 28
1737: PPUSH
1738: CALL_OW 85
// DWait ( 0 0$2 ) ;
1742: LD_INT 70
1744: PPUSH
1745: CALL_OW 68
// Say ( Gla , DStart-Gla-4a ) ;
1749: LD_LOC 1
1753: PPUSH
1754: LD_STRING DStart-Gla-4a
1756: PPUSH
1757: CALL_OW 88
// CenterOnUnits ( de ) ;
1761: LD_INT 37
1763: PPUSH
1764: CALL_OW 85
// DWait ( 0 0$2 ) ;
1768: LD_INT 70
1770: PPUSH
1771: CALL_OW 68
// Say ( Gla , DStart-Gla-4b ) ;
1775: LD_LOC 1
1779: PPUSH
1780: LD_STRING DStart-Gla-4b
1782: PPUSH
1783: CALL_OW 88
// CenterOnUnits ( db ) ;
1787: LD_INT 51
1789: PPUSH
1790: CALL_OW 85
// DWait ( 0 0$2 ) ;
1794: LD_INT 70
1796: PPUSH
1797: CALL_OW 68
// Say ( Gla , DStart-Gla-4c ) ;
1801: LD_LOC 1
1805: PPUSH
1806: LD_STRING DStart-Gla-4c
1808: PPUSH
1809: CALL_OW 88
// CenterOnUnits ( da ) ;
1813: LD_INT 1
1815: PPUSH
1816: CALL_OW 85
// DWait ( 0 0$2 ) ;
1820: LD_INT 70
1822: PPUSH
1823: CALL_OW 68
// Say ( Gla , DStart-Gla-4d ) ;
1827: LD_LOC 1
1831: PPUSH
1832: LD_STRING DStart-Gla-4d
1834: PPUSH
1835: CALL_OW 88
// Say ( Gla , DStart-Gla-4e ) ;
1839: LD_LOC 1
1843: PPUSH
1844: LD_STRING DStart-Gla-4e
1846: PPUSH
1847: CALL_OW 88
// SaveForQuickRestart ;
1851: CALL_OW 22
// CenterNowOnUnits ( Bur ) ;
1855: LD_LOC 2
1859: PPUSH
1860: CALL_OW 87
// ChangeMissionObjectives ( MStart ) ;
1864: LD_STRING MStart
1866: PPUSH
1867: CALL_OW 337
// InGameOff ;
1871: CALL_OW 9
// end ;
1875: LD_VAR 0 1
1879: RET
// every 29 29$0 marked 111 do
1880: GO 1882
1882: DISABLE
// begin disable ( 112 ) ;
1883: LD_INT 112
1885: DISABLE_MARKED
// zdrhaji ;
1886: CALL 1915 0 0
// end ;
1890: END
// every 0 0$30 trigger kecali_o_artefaktu marked 112 do
1891: LD_EXP 40
1895: IFFALSE 1914
1897: GO 1899
1899: DISABLE
// begin disable ( 111 ) ;
1900: LD_INT 111
1902: DISABLE_MARKED
// wait ( 2 2$15 ) ;
1903: LD_INT 4725
1905: PPUSH
1906: CALL_OW 67
// zdrhaji ;
1910: CALL 1915 0 0
// end ;
1914: END
// function zdrhaji ; var ai1sci , i , mytick ; begin
1915: LD_INT 0
1917: PPUSH
1918: PPUSH
1919: PPUSH
1920: PPUSH
// vedci_zacali_zdrhat := true ;
1921: LD_ADDR_EXP 30
1925: PUSH
1926: LD_INT 1
1928: ST_TO_ADDR
// TeleportExit ( telp1 , 136 , 88 ) ;
1929: LD_INT 15
1931: PPUSH
1932: LD_INT 136
1934: PPUSH
1935: LD_INT 88
1937: PPUSH
1938: CALL_OW 243
// ai1sci := UnitFilter ( humans [ 1 ] , [ mf_sci ] ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_EXP 76
1951: PUSH
1952: LD_INT 1
1954: ARRAY
1955: PPUSH
1956: LD_EXP 54
1960: PUSH
1961: EMPTY
1962: LIST
1963: PPUSH
1964: CALL_OW 72
1968: ST_TO_ADDR
// if ai1sci then
1969: LD_VAR 0 2
1973: IFFALSE 1985
// run_sci := ai1sci ;
1975: LD_ADDR_EXP 31
1979: PUSH
1980: LD_VAR 0 2
1984: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff run_sci ) ;
1985: LD_ADDR_EXP 76
1989: PUSH
1990: LD_EXP 76
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: LD_EXP 76
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: PUSH
2007: LD_EXP 31
2011: DIFF
2012: PPUSH
2013: CALL_OW 1
2017: ST_TO_ADDR
// sci := sci diff run_sci ;
2018: LD_ADDR_EXP 88
2022: PUSH
2023: LD_EXP 88
2027: PUSH
2028: LD_EXP 31
2032: DIFF
2033: ST_TO_ADDR
// for i in utek do
2034: LD_ADDR_VAR 0 3
2038: PUSH
2039: LD_EXP 32
2043: PUSH
2044: FOR_IN
2045: IFFALSE 2076
// AddComMoveXY ( run_sci , i [ 1 ] , i [ 2 ] ) ;
2047: LD_EXP 31
2051: PPUSH
2052: LD_VAR 0 3
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: LD_VAR 0 3
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: CALL_OW 171
2074: GO 2044
2076: POP
2077: POP
// wait ( 0 0$10 ) ;
2078: LD_INT 350
2080: PPUSH
2081: CALL_OW 67
// DGossudarov ;
2085: CALL 2736 0 0
// mytick := tick + 1 1$30 ;
2089: LD_ADDR_VAR 0 4
2093: PUSH
2094: LD_OWVAR 1
2098: PUSH
2099: LD_INT 3150
2101: PLUS
2102: ST_TO_ADDR
// while mytick > tick and not UnitFilter ( run_sci , [ f_or , [ f_not , [ f_alive ] ] , [ f_distxy , 142 , 88 , 10 ] ] ) do
2103: LD_VAR 0 4
2107: PUSH
2108: LD_OWVAR 1
2112: GREATER
2113: PUSH
2114: LD_EXP 31
2118: PPUSH
2119: LD_INT 2
2121: PUSH
2122: LD_INT 3
2124: PUSH
2125: LD_INT 51
2127: PUSH
2128: EMPTY
2129: LIST
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 92
2137: PUSH
2138: LD_INT 142
2140: PUSH
2141: LD_INT 88
2143: PUSH
2144: LD_INT 10
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 72
2162: NOT
2163: AND
2164: IFFALSE 2175
// wait ( 0 0$1 ) ;
2166: LD_INT 35
2168: PPUSH
2169: CALL_OW 67
2173: GO 2103
// ComExitVehicle ( Gossudarov ) ;
2175: LD_EXP 43
2179: PPUSH
2180: CALL_OW 121
// while not UnitsInside ( art_cargo ) do
2184: LD_INT 121
2186: PPUSH
2187: CALL_OW 313
2191: NOT
2192: IFFALSE 2215
// begin ComEnterUnit ( Gossudarov , art_cargo ) ;
2194: LD_EXP 43
2198: PPUSH
2199: LD_INT 121
2201: PPUSH
2202: CALL_OW 120
// wait ( 0 0$1 ) ;
2206: LD_INT 35
2208: PPUSH
2209: CALL_OW 67
// end ;
2213: GO 2184
// if UnitFilter ( run_sci , [ [ f_distxy , 142 , 88 , 12 ] ] ) then
2215: LD_EXP 31
2219: PPUSH
2220: LD_INT 92
2222: PUSH
2223: LD_INT 142
2225: PUSH
2226: LD_INT 88
2228: PUSH
2229: LD_INT 12
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: PPUSH
2241: CALL_OW 72
2245: IFFALSE 2297
// while not UnitFilter ( art_cargo , [ [ f_distxy , 136 , 88 , 15 ] ] ) do
2247: LD_INT 121
2249: PPUSH
2250: LD_INT 92
2252: PUSH
2253: LD_INT 136
2255: PUSH
2256: LD_INT 88
2258: PUSH
2259: LD_INT 15
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: PPUSH
2271: CALL_OW 72
2275: NOT
2276: IFFALSE 2297
// begin ComMoveUnit ( art_cargo , telp1 ) ;
2278: LD_INT 121
2280: PPUSH
2281: LD_INT 15
2283: PPUSH
2284: CALL_OW 112
// wait ( 0 0$1 ) ;
2288: LD_INT 35
2290: PPUSH
2291: CALL_OW 67
// end ;
2295: GO 2247
// while UnitFilter ( run_sci ^ art_cargo , [ [ f_placed ] ] ) do
2297: LD_EXP 31
2301: PUSH
2302: LD_INT 121
2304: ADD
2305: PPUSH
2306: LD_INT 52
2308: PUSH
2309: EMPTY
2310: LIST
2311: PUSH
2312: EMPTY
2313: LIST
2314: PPUSH
2315: CALL_OW 72
2319: IFFALSE 2453
// begin ComMoveXY ( ( run_sci ) ^ art_cargo , utek_e [ 1 ] , utek_e [ 2 ] ) ;
2321: LD_EXP 31
2325: PUSH
2326: LD_INT 121
2328: ADD
2329: PPUSH
2330: LD_EXP 33
2334: PUSH
2335: LD_INT 1
2337: ARRAY
2338: PPUSH
2339: LD_EXP 33
2343: PUSH
2344: LD_INT 2
2346: ARRAY
2347: PPUSH
2348: CALL_OW 111
// for i in UnitFilter ( ( run_sci ) ^ art_cargo , [ [ f_distxy , utek_e [ 1 ] , utek_e [ 2 ] , 5 ] ] ) do
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_EXP 31
2361: PUSH
2362: LD_INT 121
2364: ADD
2365: PPUSH
2366: LD_INT 92
2368: PUSH
2369: LD_EXP 33
2373: PUSH
2374: LD_INT 1
2376: ARRAY
2377: PUSH
2378: LD_EXP 33
2382: PUSH
2383: LD_INT 2
2385: ARRAY
2386: PUSH
2387: LD_INT 5
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: PUSH
2396: EMPTY
2397: LIST
2398: PPUSH
2399: CALL_OW 72
2403: PUSH
2404: FOR_IN
2405: IFFALSE 2442
// if i = art_cargo then
2407: LD_VAR 0 3
2411: PUSH
2412: LD_INT 121
2414: EQUAL
2415: IFFALSE 2423
// LostArte else
2417: CALL 602 0 0
2421: GO 2440
// begin RemoveUnit ( i ) ;
2423: LD_VAR 0 3
2427: PPUSH
2428: CALL_OW 64
// Goss := false ;
2432: LD_ADDR_EXP 28
2436: PUSH
2437: LD_INT 0
2439: ST_TO_ADDR
// end ;
2440: GO 2404
2442: POP
2443: POP
// wait ( 0 0$1 ) ;
2444: LD_INT 35
2446: PPUSH
2447: CALL_OW 67
// end ;
2451: GO 2297
// end ;
2453: LD_VAR 0 1
2457: RET
// every 0 0$1 trigger vedci_zacali_zdrhat and UnitFilter ( run_sci ^ Gossudarov , [ [ f_alive ] , [ f_placed ] ] ) = 0 do
2458: LD_EXP 30
2462: PUSH
2463: LD_EXP 31
2467: PUSH
2468: LD_EXP 43
2472: ADD
2473: PPUSH
2474: LD_INT 51
2476: PUSH
2477: EMPTY
2478: LIST
2479: PUSH
2480: LD_INT 52
2482: PUSH
2483: EMPTY
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PPUSH
2490: CALL_OW 72
2494: PUSH
2495: LD_INT 0
2497: EQUAL
2498: AND
2499: IFFALSE 2511
2501: GO 2503
2503: DISABLE
// begin ChangeMissionObjectives ( MGossSciOut ) ;
2504: LD_STRING MGossSciOut
2506: PPUSH
2507: CALL_OW 337
// end ;
2511: END
// every 0 0$1 do var h , hinfo , i ;
2512: GO 2514
2514: DISABLE
2515: LD_INT 0
2517: PPUSH
2518: PPUSH
2519: PPUSH
// begin h := FindArtifact ( 4 ) ;
2520: LD_ADDR_VAR 0 1
2524: PUSH
2525: LD_INT 4
2527: PPUSH
2528: CALL_OW 469
2532: ST_TO_ADDR
// if h then
2533: LD_VAR 0 1
2537: IFFALSE 2732
// begin hinfo := HexInfo ( h [ 1 ] , h [ 2 ] ) ;
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_VAR 0 1
2548: PUSH
2549: LD_INT 1
2551: ARRAY
2552: PPUSH
2553: LD_VAR 0 1
2557: PUSH
2558: LD_INT 2
2560: ARRAY
2561: PPUSH
2562: CALL_OW 428
2566: ST_TO_ADDR
// if hinfo > 0 then
2567: LD_VAR 0 2
2571: PUSH
2572: LD_INT 0
2574: GREATER
2575: IFFALSE 2614
// begin if GetSide ( hinfo ) = you then
2577: LD_VAR 0 2
2581: PPUSH
2582: CALL_OW 255
2586: PUSH
2587: LD_EXP 7
2591: EQUAL
2592: IFFALSE 2604
// maji_artifact := true else
2594: LD_ADDR_EXP 39
2598: PUSH
2599: LD_INT 1
2601: ST_TO_ADDR
2602: GO 2612
// maji_artifact := false ;
2604: LD_ADDR_EXP 39
2608: PUSH
2609: LD_INT 0
2611: ST_TO_ADDR
// end else
2612: GO 2732
// begin maji_artifact := false ;
2614: LD_ADDR_EXP 39
2618: PUSH
2619: LD_INT 0
2621: ST_TO_ADDR
// for i := 1 to 5 do
2622: LD_ADDR_VAR 0 3
2626: PUSH
2627: DOUBLE
2628: LD_INT 1
2630: DEC
2631: ST_TO_ADDR
2632: LD_INT 5
2634: PUSH
2635: FOR_TO
2636: IFFALSE 2730
// if ( ai_s [ i ] in your_bases ) and ( InArea ( h [ 1 ] , h [ 2 ] , near_base_area [ i ] ) or InArea ( h [ 1 ] , h [ 2 ] , nearD ) ) then
2638: LD_EXP 23
2642: PUSH
2643: LD_VAR 0 3
2647: ARRAY
2648: PUSH
2649: LD_EXP 18
2653: IN
2654: PUSH
2655: LD_VAR 0 1
2659: PUSH
2660: LD_INT 1
2662: ARRAY
2663: PPUSH
2664: LD_VAR 0 1
2668: PUSH
2669: LD_INT 2
2671: ARRAY
2672: PPUSH
2673: LD_EXP 63
2677: PUSH
2678: LD_VAR 0 3
2682: ARRAY
2683: PPUSH
2684: CALL_OW 309
2688: PUSH
2689: LD_VAR 0 1
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: LD_VAR 0 1
2702: PUSH
2703: LD_INT 2
2705: ARRAY
2706: PPUSH
2707: LD_INT 27
2709: PPUSH
2710: CALL_OW 309
2714: OR
2715: AND
2716: IFFALSE 2728
// begin maji_artifact := true ;
2718: LD_ADDR_EXP 39
2722: PUSH
2723: LD_INT 1
2725: ST_TO_ADDR
// break ;
2726: GO 2730
// end ;
2728: GO 2635
2730: POP
2731: POP
// end ; end ; enable ;
2732: ENABLE
// end ;
2733: PPOPN 3
2735: END
// export function DGossudarov ; var x , y ; begin
2736: LD_INT 0
2738: PPUSH
2739: PPUSH
2740: PPUSH
// x := GetX ( run_sci [ 1 ] ) ;
2741: LD_ADDR_VAR 0 2
2745: PUSH
2746: LD_EXP 31
2750: PUSH
2751: LD_INT 1
2753: ARRAY
2754: PPUSH
2755: CALL_OW 250
2759: ST_TO_ADDR
// y := GetY ( run_sci [ 1 ] ) ;
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: LD_EXP 31
2769: PUSH
2770: LD_INT 1
2772: ARRAY
2773: PPUSH
2774: CALL_OW 251
2778: ST_TO_ADDR
// PlaceSeeing ( x , y , You , 10 ) ;
2779: LD_VAR 0 2
2783: PPUSH
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_EXP 7
2793: PPUSH
2794: LD_INT 10
2796: PPUSH
2797: CALL_OW 330
// CenterNowOnXY ( x , y ) ;
2801: LD_VAR 0 2
2805: PPUSH
2806: LD_VAR 0 3
2810: PPUSH
2811: CALL_OW 86
// wait ( 0 0$1 ) ;
2815: LD_INT 35
2817: PPUSH
2818: CALL_OW 67
// DialogueOn ;
2822: CALL_OW 6
// Say ( Fad , DGossudarov-Fad-1 ) ;
2826: LD_LOC 5
2830: PPUSH
2831: LD_STRING DGossudarov-Fad-1
2833: PPUSH
2834: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-1 ) ;
2838: LD_LOC 2
2842: PPUSH
2843: LD_STRING DGossudarov-Bur-1
2845: PPUSH
2846: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-1 ) ;
2850: LD_LOC 4
2854: PPUSH
2855: LD_STRING DGossudarov-Gos-1
2857: PPUSH
2858: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-2 ) ;
2862: LD_LOC 2
2866: PPUSH
2867: LD_STRING DGossudarov-Bur-2
2869: PPUSH
2870: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-2 ) ;
2874: LD_LOC 4
2878: PPUSH
2879: LD_STRING DGossudarov-Gos-2
2881: PPUSH
2882: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-3 ) ;
2886: LD_LOC 2
2890: PPUSH
2891: LD_STRING DGossudarov-Bur-3
2893: PPUSH
2894: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-3 ) ;
2898: LD_LOC 4
2902: PPUSH
2903: LD_STRING DGossudarov-Gos-3
2905: PPUSH
2906: CALL_OW 88
// ChangeMissionObjectives ( MGoss ) ;
2910: LD_STRING MGoss
2912: PPUSH
2913: CALL_OW 337
// DialogueOff ;
2917: CALL_OW 7
// wait ( 0 0$5 ) ;
2921: LD_INT 175
2923: PPUSH
2924: CALL_OW 67
// RemoveSeeing ( x , y , You ) ;
2928: LD_VAR 0 2
2932: PPUSH
2933: LD_VAR 0 3
2937: PPUSH
2938: LD_EXP 7
2942: PPUSH
2943: CALL_OW 331
// end ;
2947: LD_VAR 0 1
2951: RET
// every 0 0$2 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
2952: LD_EXP 23
2956: PUSH
2957: LD_EXP 25
2961: ARRAY
2962: PPUSH
2963: LD_EXP 37
2967: PUSH
2968: LD_EXP 35
2972: ADD
2973: PPUSH
2974: CALL 10575 0 2
2978: PUSH
2979: LD_EXP 37
2983: PUSH
2984: LD_EXP 35
2988: ADD
2989: PPUSH
2990: LD_INT 95
2992: PUSH
2993: LD_EXP 63
2997: PUSH
2998: LD_EXP 25
3002: ARRAY
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: EMPTY
3009: LIST
3010: PPUSH
3011: CALL_OW 72
3015: AND
3016: IFFALSE 3025
3018: GO 3020
3020: DISABLE
// begin DA_BaseContact ;
3021: CALL 3026 0 0
// end ;
3025: END
// export function DA_BaseContact ; begin
3026: LD_INT 0
3028: PPUSH
// DialogueOn ;
3029: CALL_OW 6
// Say ( Pla , DA-BaseContact-Pla-1 ) ;
3033: LD_LOC 3
3037: PPUSH
3038: LD_STRING DA-BaseContact-Pla-1
3040: PPUSH
3041: CALL_OW 88
// Say ( Bur , DA-BaseContact-Bur-1 ) ;
3045: LD_LOC 2
3049: PPUSH
3050: LD_STRING DA-BaseContact-Bur-1
3052: PPUSH
3053: CALL_OW 88
// DialogueOff ;
3057: CALL_OW 7
// end ;
3061: LD_VAR 0 1
3065: RET
// every 0 0$20 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
3066: LD_EXP 23
3070: PUSH
3071: LD_EXP 25
3075: ARRAY
3076: PPUSH
3077: LD_EXP 37
3081: PUSH
3082: LD_EXP 35
3086: ADD
3087: PPUSH
3088: CALL 10575 0 2
3092: PUSH
3093: LD_EXP 37
3097: PUSH
3098: LD_EXP 35
3102: ADD
3103: PPUSH
3104: LD_INT 95
3106: PUSH
3107: LD_EXP 63
3111: PUSH
3112: LD_EXP 25
3116: ARRAY
3117: PUSH
3118: EMPTY
3119: LIST
3120: LIST
3121: PUSH
3122: EMPTY
3123: LIST
3124: PPUSH
3125: CALL_OW 72
3129: AND
3130: IFFALSE 3213
3132: GO 3134
3134: DISABLE
// begin wait ( 0 0$20 ) ;
3135: LD_INT 700
3137: PPUSH
3138: CALL_OW 67
// if see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) then
3142: LD_EXP 23
3146: PUSH
3147: LD_EXP 25
3151: ARRAY
3152: PPUSH
3153: LD_EXP 37
3157: PUSH
3158: LD_EXP 35
3162: ADD
3163: PPUSH
3164: CALL 10575 0 2
3168: PUSH
3169: LD_EXP 37
3173: PUSH
3174: LD_EXP 35
3178: ADD
3179: PPUSH
3180: LD_INT 95
3182: PUSH
3183: LD_EXP 63
3187: PUSH
3188: LD_EXP 25
3192: ARRAY
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: PPUSH
3201: CALL_OW 72
3205: AND
3206: IFFALSE 3212
// DA_BaseRefuse ;
3208: CALL 3993 0 0
// enable ;
3212: ENABLE
// end ;
3213: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 12 do
3214: LD_EXP 76
3218: PUSH
3219: LD_EXP 25
3223: ARRAY
3224: PPUSH
3225: LD_INT 3
3227: PUSH
3228: LD_EXP 54
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PPUSH
3237: CALL_OW 72
3241: PUSH
3242: LD_INT 12
3244: LESS
3245: IFFALSE 3258
3247: GO 3249
3249: DISABLE
// begin DA_BaseRefuse ;
3250: CALL 3993 0 0
// ZoufalUtok ;
3254: CALL 11879 0 0
// end ;
3258: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 10 do
3259: LD_EXP 76
3263: PUSH
3264: LD_EXP 25
3268: ARRAY
3269: PPUSH
3270: LD_INT 3
3272: PUSH
3273: LD_EXP 54
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 72
3286: PUSH
3287: LD_INT 10
3289: LESS
3290: IFFALSE 3303
3292: GO 3294
3294: DISABLE
// begin DA_BaseRefuse ;
3295: CALL 3993 0 0
// BehemothUtok ;
3299: CALL 11688 0 0
// end ;
3303: END
// every 25 25$0 do
3304: GO 3306
3306: DISABLE
// begin BehemothUtok ;
3307: CALL 11688 0 0
// end ;
3311: END
// every 10 10$0 + 0 0$5 do
3312: GO 3314
3314: DISABLE
// begin NormalUtok ;
3315: CALL 12076 0 0
// end ;
3319: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) <= 7 and UnitFilter ( buildings [ plat_i ] , [ f_or , [ f_btype , b_turret ] , [ [ f_occupied ] , mf_fort ] ] ) <= 2 do var kam_zdrha , k_dispozici , mt , kam_telp , h , i , kam_zdrha_i ;
3320: LD_EXP 76
3324: PUSH
3325: LD_EXP 25
3329: ARRAY
3330: PPUSH
3331: LD_INT 3
3333: PUSH
3334: LD_EXP 54
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: CALL_OW 72
3347: PUSH
3348: LD_INT 7
3350: LESSEQUAL
3351: PUSH
3352: LD_EXP 75
3356: PUSH
3357: LD_EXP 25
3361: ARRAY
3362: PPUSH
3363: LD_INT 2
3365: PUSH
3366: LD_INT 30
3368: PUSH
3369: LD_INT 33
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 59
3378: PUSH
3379: EMPTY
3380: LIST
3381: PUSH
3382: LD_EXP 56
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 72
3400: PUSH
3401: LD_INT 2
3403: LESSEQUAL
3404: AND
3405: IFFALSE 3990
3407: GO 3409
3409: DISABLE
3410: LD_INT 0
3412: PPUSH
3413: PPUSH
3414: PPUSH
3415: PPUSH
3416: PPUSH
3417: PPUSH
3418: PPUSH
// begin k_dispozici := ( ai diff ( ai [ 1 ] ^ your_bases ) ) ;
3419: LD_ADDR_VAR 0 2
3423: PUSH
3424: LD_EXP 24
3428: PUSH
3429: LD_EXP 24
3433: PUSH
3434: LD_INT 1
3436: ARRAY
3437: PUSH
3438: LD_EXP 18
3442: ADD
3443: DIFF
3444: ST_TO_ADDR
// if k_dispozici then
3445: LD_VAR 0 2
3449: IFFALSE 3945
// begin kam_zdrha := ( k_dispozici ) [ Rand ( 1 , k_dispozici ) ] ;
3451: LD_ADDR_VAR 0 1
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 1
3463: PPUSH
3464: LD_VAR 0 2
3468: PPUSH
3469: CALL_OW 12
3473: ARRAY
3474: ST_TO_ADDR
// case kam_zdrha of ai_s [ 2 ] :
3475: LD_VAR 0 1
3479: PUSH
3480: LD_EXP 23
3484: PUSH
3485: LD_INT 2
3487: ARRAY
3488: DOUBLE
3489: EQUAL
3490: IFTRUE 3494
3492: GO 3505
3494: POP
// kam_telp := b_base ; ai_s [ 3 ] :
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: LD_INT 20
3502: ST_TO_ADDR
3503: GO 3581
3505: LD_EXP 23
3509: PUSH
3510: LD_INT 3
3512: ARRAY
3513: DOUBLE
3514: EQUAL
3515: IFTRUE 3519
3517: GO 3530
3519: POP
// kam_telp := c_base ; ai_s [ 4 ] :
3520: LD_ADDR_VAR 0 4
3524: PUSH
3525: LD_INT 23
3527: ST_TO_ADDR
3528: GO 3581
3530: LD_EXP 23
3534: PUSH
3535: LD_INT 4
3537: ARRAY
3538: DOUBLE
3539: EQUAL
3540: IFTRUE 3544
3542: GO 3555
3544: POP
// kam_telp := d_base ; ai_s [ 5 ] :
3545: LD_ADDR_VAR 0 4
3549: PUSH
3550: LD_INT 22
3552: ST_TO_ADDR
3553: GO 3581
3555: LD_EXP 23
3559: PUSH
3560: LD_INT 5
3562: ARRAY
3563: DOUBLE
3564: EQUAL
3565: IFTRUE 3569
3567: GO 3580
3569: POP
// kam_telp := e_base ; end ;
3570: LD_ADDR_VAR 0 4
3574: PUSH
3575: LD_INT 21
3577: ST_TO_ADDR
3578: GO 3581
3580: POP
// repeat h := RandHexArea ( kam_telp , false ) ;
3581: LD_ADDR_VAR 0 5
3585: PUSH
3586: LD_VAR 0 4
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 16
3598: ST_TO_ADDR
// until HexInfo ( h [ 1 ] , h [ 2 ] ) = 0 ;
3599: LD_VAR 0 5
3603: PUSH
3604: LD_INT 1
3606: ARRAY
3607: PPUSH
3608: LD_VAR 0 5
3612: PUSH
3613: LD_INT 2
3615: ARRAY
3616: PPUSH
3617: CALL_OW 428
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3581
// TeleportExit ( telp1 , h [ 1 ] , h [ 2 ] ) ;
3627: LD_INT 15
3629: PPUSH
3630: LD_VAR 0 5
3634: PUSH
3635: LD_INT 1
3637: ARRAY
3638: PPUSH
3639: LD_VAR 0 5
3643: PUSH
3644: LD_INT 2
3646: ARRAY
3647: PPUSH
3648: CALL_OW 243
// ComExitVehicle ( Platonov ) ;
3652: LD_EXP 42
3656: PPUSH
3657: CALL_OW 121
// AddComExitBuilding ( Platonov ) ;
3661: LD_EXP 42
3665: PPUSH
3666: CALL_OW 182
// AddComEnterUnit ( Platonov , telp1 ) ;
3670: LD_EXP 42
3674: PPUSH
3675: LD_INT 15
3677: PPUSH
3678: CALL_OW 180
// for i := 1 to 5 do
3682: LD_ADDR_VAR 0 6
3686: PUSH
3687: DOUBLE
3688: LD_INT 1
3690: DEC
3691: ST_TO_ADDR
3692: LD_INT 5
3694: PUSH
3695: FOR_TO
3696: IFFALSE 3728
// if ai_s [ i ] = kam_zdrha then
3698: LD_EXP 23
3702: PUSH
3703: LD_VAR 0 6
3707: ARRAY
3708: PUSH
3709: LD_VAR 0 1
3713: EQUAL
3714: IFFALSE 3726
// kam_zdrha_i := i ;
3716: LD_ADDR_VAR 0 7
3720: PUSH
3721: LD_VAR 0 6
3725: ST_TO_ADDR
3726: GO 3695
3728: POP
3729: POP
// plat_i := kam_zdrha_i ;
3730: LD_ADDR_EXP 25
3734: PUSH
3735: LD_VAR 0 7
3739: ST_TO_ADDR
// ai_s := replace ( ai_s , kam_zdrha_i , ai_s [ 1 ] ) ;
3740: LD_ADDR_EXP 23
3744: PUSH
3745: LD_EXP 23
3749: PPUSH
3750: LD_VAR 0 7
3754: PPUSH
3755: LD_EXP 23
3759: PUSH
3760: LD_INT 1
3762: ARRAY
3763: PPUSH
3764: CALL_OW 1
3768: ST_TO_ADDR
// wait ( 0 0$5 ) ;
3769: LD_INT 175
3771: PPUSH
3772: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3776: LD_EXP 42
3780: PPUSH
3781: LD_EXP 74
3785: PUSH
3786: LD_VAR 0 7
3790: ARRAY
3791: PPUSH
3792: CALL_OW 180
// DA_BaseAccept ;
3796: CALL 4043 0 0
// SurrenderBase ( t_killbeat , ai_s [ plat_i ] ) ;
3800: LD_EXP 6
3804: PPUSH
3805: LD_EXP 23
3809: PUSH
3810: LD_EXP 25
3814: ARRAY
3815: PPUSH
3816: CALL 30359 0 2
// SetAttitude ( ai_s [ plat_i ] , you , att_enemy , true ) ;
3820: LD_EXP 23
3824: PUSH
3825: LD_EXP 25
3829: ARRAY
3830: PPUSH
3831: LD_EXP 7
3835: PPUSH
3836: LD_INT 2
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: CALL_OW 80
// SetSideBase_custom ( GetBase ( depots [ plat_i ] ) , ai_s [ plat_i ] ) ;
3846: LD_EXP 74
3850: PUSH
3851: LD_EXP 25
3855: ARRAY
3856: PPUSH
3857: CALL_OW 274
3861: PPUSH
3862: LD_EXP 23
3866: PUSH
3867: LD_EXP 25
3871: ARRAY
3872: PPUSH
3873: CALL 32764 0 2
// SetSide ( FilterAllUnits ( [ [ f_side , kam_zdrha ] ] ) , ai_s [ plat_i ] ) ;
3877: LD_INT 22
3879: PUSH
3880: LD_VAR 0 1
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: PUSH
3889: EMPTY
3890: LIST
3891: PPUSH
3892: CALL_OW 69
3896: PPUSH
3897: LD_EXP 23
3901: PUSH
3902: LD_EXP 25
3906: ARRAY
3907: PPUSH
3908: CALL_OW 235
// wait ( 1 1$0 ) ;
3912: LD_INT 2100
3914: PPUSH
3915: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3919: LD_EXP 42
3923: PPUSH
3924: LD_EXP 74
3928: PUSH
3929: LD_VAR 0 7
3933: ARRAY
3934: PPUSH
3935: CALL_OW 180
// ZoufalUtok ;
3939: CALL 11879 0 0
// end else
3943: GO 3990
// begin while not IsDead ( Platonov ) do
3945: LD_EXP 42
3949: PPUSH
3950: CALL_OW 301
3954: NOT
3955: IFFALSE 3990
// begin ComAttackUnit ( Platonov , NearestUnitToUnit ( your_humans , Platonov ) ) ;
3957: LD_EXP 42
3961: PPUSH
3962: LD_EXP 37
3966: PPUSH
3967: LD_EXP 42
3971: PPUSH
3972: CALL_OW 74
3976: PPUSH
3977: CALL_OW 115
// wait ( 0 0$5 ) ;
3981: LD_INT 175
3983: PPUSH
3984: CALL_OW 67
// end ;
3988: GO 3945
// end ; end ;
3990: PPOPN 7
3992: END
// export function DA_BaseRefuse ; begin
3993: LD_INT 0
3995: PPUSH
// DialogueOn ;
3996: CALL_OW 6
// if not IsDead ( Pla ) then
4000: LD_LOC 3
4004: PPUSH
4005: CALL_OW 301
4009: NOT
4010: IFFALSE 4034
// if not Say ( Pla , DA-BaseReguse-Pla-1 ) then
4012: LD_LOC 3
4016: PPUSH
4017: LD_STRING DA-BaseReguse-Pla-1
4019: PPUSH
4020: CALL_OW 88
4024: NOT
4025: IFFALSE 4034
// msg ( bad ident: DA-BaseReguse-Pla-1 ) ;
4027: LD_STRING bad ident: DA-BaseReguse-Pla-1
4029: PPUSH
4030: CALL_OW 100
// DialogueOff ;
4034: CALL_OW 7
// end ;
4038: LD_VAR 0 1
4042: RET
// export function DA_BaseAccept ; begin
4043: LD_INT 0
4045: PPUSH
// DialogueOn ;
4046: CALL_OW 6
// Say ( Pla , DA-BaseAccept-Pla-1 ) ;
4050: LD_LOC 3
4054: PPUSH
4055: LD_STRING DA-BaseAccept-Pla-1
4057: PPUSH
4058: CALL_OW 88
// DialogueOff ;
4062: CALL_OW 7
// end ;
4066: LD_VAR 0 1
4070: RET
// every 0 0$2 trigger See ( you , behemoth ) do var who ;
4071: LD_EXP 7
4075: PPUSH
4076: LD_INT 125
4078: PPUSH
4079: CALL_OW 292
4083: IFFALSE 4202
4085: GO 4087
4087: DISABLE
4088: LD_INT 0
4090: PPUSH
// begin BehemothSeen := true ;
4091: LD_ADDR_EXP 29
4095: PUSH
4096: LD_INT 1
4098: ST_TO_ADDR
// if GetSide ( behemoth ) = you then
4099: LD_INT 125
4101: PPUSH
4102: CALL_OW 255
4106: PUSH
4107: LD_EXP 7
4111: EQUAL
4112: IFFALSE 4116
// exit ;
4114: GO 4202
// CenterNowOnUnits ( behemoth ) ;
4116: LD_INT 125
4118: PPUSH
4119: CALL_OW 87
// who := WhoSayAny ( your_humans diff talking , you , sex_male , 0 , 0 ) ;
4123: LD_ADDR_VAR 0 1
4127: PUSH
4128: LD_EXP 37
4132: PUSH
4133: LD_LOC 11
4137: DIFF
4138: PPUSH
4139: LD_EXP 7
4143: PPUSH
4144: LD_INT 1
4146: PPUSH
4147: LD_INT 0
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL 10381 0 5
4157: ST_TO_ADDR
// DialogueOn ;
4158: CALL_OW 6
// Say ( who , DBehemoth-Rsol1-1 ) ;
4162: LD_VAR 0 1
4166: PPUSH
4167: LD_STRING DBehemoth-Rsol1-1
4169: PPUSH
4170: CALL_OW 88
// Say ( Pla , DBehemoth-Pla-1 ) ;
4174: LD_LOC 3
4178: PPUSH
4179: LD_STRING DBehemoth-Pla-1
4181: PPUSH
4182: CALL_OW 88
// Say ( Bur , DBehemoth-Bur-1 ) ;
4186: LD_LOC 2
4190: PPUSH
4191: LD_STRING DBehemoth-Bur-1
4193: PPUSH
4194: CALL_OW 88
// DialogueOff ;
4198: CALL_OW 7
// end ;
4202: PPOPN 1
4204: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] do
4205: LD_LOC 2
4209: PPUSH
4210: LD_INT 20
4212: PPUSH
4213: CALL_OW 308
4217: PUSH
4218: LD_EXP 23
4222: PUSH
4223: LD_INT 1
4225: ARRAY
4226: PUSH
4227: LD_EXP 23
4231: PUSH
4232: LD_INT 2
4234: ARRAY
4235: NONEQUAL
4236: AND
4237: IFFALSE 4317
4239: GO 4241
4241: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4242: LD_EXP 37
4246: PUSH
4247: LD_INT 12
4249: LESS
4250: PUSH
4251: LD_EXP 35
4255: PUSH
4256: LD_INT 20
4258: LESS
4259: AND
4260: IFFALSE 4282
// begin DB_BaseContact ;
4262: CALL 4521 0 0
// DB_BaseRefuse1st ;
4266: CALL 4549 0 0
// wait ( 0 0$30 ) ;
4270: LD_INT 1050
4272: PPUSH
4273: CALL_OW 67
// enable ( 10 ) ;
4277: LD_INT 10
4279: ENABLE_MARKED
// end else
4280: GO 4317
// begin if not ai_s [ 2 ] in your_bases then
4282: LD_EXP 23
4286: PUSH
4287: LD_INT 2
4289: ARRAY
4290: PUSH
4291: LD_EXP 18
4295: IN
4296: NOT
4297: IFFALSE 4317
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4299: LD_EXP 2
4303: PPUSH
4304: LD_EXP 23
4308: PUSH
4309: LD_INT 2
4311: ARRAY
4312: PPUSH
4313: CALL 30359 0 2
// end ; end ; end ;
4317: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] marked 10 do
4318: LD_LOC 2
4322: PPUSH
4323: LD_INT 20
4325: PPUSH
4326: CALL_OW 308
4330: PUSH
4331: LD_EXP 23
4335: PUSH
4336: LD_INT 1
4338: ARRAY
4339: PUSH
4340: LD_EXP 23
4344: PUSH
4345: LD_INT 2
4347: ARRAY
4348: NONEQUAL
4349: AND
4350: IFFALSE 4447
4352: GO 4354
4354: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4355: LD_EXP 37
4359: PUSH
4360: LD_INT 12
4362: LESS
4363: PUSH
4364: LD_EXP 35
4368: PUSH
4369: LD_INT 20
4371: LESS
4372: AND
4373: IFFALSE 4412
// begin DB_BaseRefuse ;
4375: CALL 4577 0 0
// while IsInArea ( Bur , b_base ) do
4379: LD_LOC 2
4383: PPUSH
4384: LD_INT 20
4386: PPUSH
4387: CALL_OW 308
4391: IFFALSE 4402
// wait ( 0 0$1 ) ;
4393: LD_INT 35
4395: PPUSH
4396: CALL_OW 67
4400: GO 4379
// wait ( 0 0$20 ) ;
4402: LD_INT 700
4404: PPUSH
4405: CALL_OW 67
// enable ;
4409: ENABLE
// end else
4410: GO 4447
// begin if not ai_s [ 2 ] in your_bases then
4412: LD_EXP 23
4416: PUSH
4417: LD_INT 2
4419: ARRAY
4420: PUSH
4421: LD_EXP 18
4425: IN
4426: NOT
4427: IFFALSE 4447
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4429: LD_EXP 2
4433: PPUSH
4434: LD_EXP 23
4438: PUSH
4439: LD_INT 2
4441: ARRAY
4442: PPUSH
4443: CALL 30359 0 2
// end ; end ; end ;
4447: END
// every 0 0$2 trigger humans [ 2 ] <= 6 and ai_s [ 1 ] <> ai_s [ 2 ] do
4448: LD_EXP 76
4452: PUSH
4453: LD_INT 2
4455: ARRAY
4456: PUSH
4457: LD_INT 6
4459: LESSEQUAL
4460: PUSH
4461: LD_EXP 23
4465: PUSH
4466: LD_INT 1
4468: ARRAY
4469: PUSH
4470: LD_EXP 23
4474: PUSH
4475: LD_INT 2
4477: ARRAY
4478: NONEQUAL
4479: AND
4480: IFFALSE 4520
4482: GO 4484
4484: DISABLE
// begin if not ai_s [ 2 ] in your_bases then
4485: LD_EXP 23
4489: PUSH
4490: LD_INT 2
4492: ARRAY
4493: PUSH
4494: LD_EXP 18
4498: IN
4499: NOT
4500: IFFALSE 4520
// SurrenderBase ( t_killbeat , ai_s [ 2 ] ) ;
4502: LD_EXP 6
4506: PPUSH
4507: LD_EXP 23
4511: PUSH
4512: LD_INT 2
4514: ARRAY
4515: PPUSH
4516: CALL 30359 0 2
// end ;
4520: END
// export function DB_BaseContact ; begin
4521: LD_INT 0
4523: PPUSH
// DialogueOn ;
4524: CALL_OW 6
// Say ( Bor , DB-BaseContact-Bor-1 ) ;
4528: LD_LOC 6
4532: PPUSH
4533: LD_STRING DB-BaseContact-Bor-1
4535: PPUSH
4536: CALL_OW 88
// DialogueOff ;
4540: CALL_OW 7
// end ;
4544: LD_VAR 0 1
4548: RET
// export function DB_BaseRefuse1st ; begin
4549: LD_INT 0
4551: PPUSH
// DialogueOn ;
4552: CALL_OW 6
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4556: LD_LOC 6
4560: PPUSH
4561: LD_STRING DB-BaseRefuse-Bor-1
4563: PPUSH
4564: CALL_OW 88
// DialogueOff ;
4568: CALL_OW 7
// end ;
4572: LD_VAR 0 1
4576: RET
// export function DB_BaseRefuse ; begin
4577: LD_INT 0
4579: PPUSH
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4580: LD_LOC 6
4584: PPUSH
4585: LD_STRING DB-BaseRefuse-Bor-1
4587: PPUSH
4588: CALL_OW 88
// end ;
4592: LD_VAR 0 1
4596: RET
// export function DB_BaseAccept ( first ) ; begin
4597: LD_INT 0
4599: PPUSH
// DialogueOn ;
4600: CALL_OW 6
// Say ( Bor , DB-BaseAccept-Bor-1 ) ;
4604: LD_LOC 6
4608: PPUSH
4609: LD_STRING DB-BaseAccept-Bor-1
4611: PPUSH
4612: CALL_OW 88
// if first then
4616: LD_VAR 0 1
4620: IFFALSE 4636
// Say ( Bor , DB-BaseAccept-Bor-1a ) else
4622: LD_LOC 6
4626: PPUSH
4627: LD_STRING DB-BaseAccept-Bor-1a
4629: PPUSH
4630: CALL_OW 88
4634: GO 4648
// Say ( Bor , DB-BaseAccept-Bor-1b ) ;
4636: LD_LOC 6
4640: PPUSH
4641: LD_STRING DB-BaseAccept-Bor-1b
4643: PPUSH
4644: CALL_OW 88
// DialogueOff ;
4648: CALL_OW 7
// end ;
4652: LD_VAR 0 2
4656: RET
// var jeste_nebylo ; every 0 0$2 trigger IsInArea ( Bur , c_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
4657: LD_LOC 2
4661: PPUSH
4662: LD_INT 23
4664: PPUSH
4665: CALL_OW 308
4669: PUSH
4670: LD_EXP 23
4674: PUSH
4675: LD_INT 1
4677: ARRAY
4678: PUSH
4679: LD_EXP 23
4683: PUSH
4684: LD_INT 4
4686: ARRAY
4687: NONEQUAL
4688: AND
4689: IFFALSE 4786
4691: GO 4693
4693: DISABLE
// begin jeste_nebylo := [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
4694: LD_ADDR_LOC 12
4698: PUSH
4699: LD_INT 1
4701: PUSH
4702: LD_INT 2
4704: PUSH
4705: LD_INT 3
4707: PUSH
4708: LD_INT 4
4710: PUSH
4711: LD_INT 5
4713: PUSH
4714: LD_INT 6
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: LIST
4724: ST_TO_ADDR
// DC_BaseContact ;
4725: CALL 5481 0 0
// if otazky then
4729: CALL 4906 0 0
4733: IFFALSE 4786
// if not ai_s [ 3 ] in your_bases then
4735: LD_EXP 23
4739: PUSH
4740: LD_INT 3
4742: ARRAY
4743: PUSH
4744: LD_EXP 18
4748: IN
4749: NOT
4750: IFFALSE 4772
// SurrenderBase ( t_persuade , ai_s [ 3 ] ) else
4752: LD_EXP 3
4756: PPUSH
4757: LD_EXP 23
4761: PUSH
4762: LD_INT 3
4764: ARRAY
4765: PPUSH
4766: CALL 30359 0 2
4770: GO 4786
// begin DQrML_Wrong ;
4772: CALL 6821 0 0
// wait ( 0 0$30 ) ;
4776: LD_INT 1050
4778: PPUSH
4779: CALL_OW 67
// enable ( 11 ) ;
4783: LD_INT 11
4785: ENABLE_MARKED
// end ; end ;
4786: END
// every 0 0$2 trigger IsInArea ( Bur , c_base ) marked 11 do
4787: LD_LOC 2
4791: PPUSH
4792: LD_INT 23
4794: PPUSH
4795: CALL_OW 308
4799: IFFALSE 4832
4801: GO 4803
4803: DISABLE
// begin if not otazky then
4804: CALL 4906 0 0
4808: NOT
4809: IFFALSE 4814
// enable else
4811: ENABLE
4812: GO 4832
// SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4814: LD_EXP 2
4818: PPUSH
4819: LD_EXP 23
4823: PUSH
4824: LD_INT 2
4826: ARRAY
4827: PPUSH
4828: CALL 30359 0 2
// end ;
4832: END
// every 0 0$2 trigger humans [ 3 ] <= 2 and ai_s [ 1 ] <> ai_s [ 4 ] do
4833: LD_EXP 76
4837: PUSH
4838: LD_INT 3
4840: ARRAY
4841: PUSH
4842: LD_INT 2
4844: LESSEQUAL
4845: PUSH
4846: LD_EXP 23
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: LD_EXP 23
4859: PUSH
4860: LD_INT 4
4862: ARRAY
4863: NONEQUAL
4864: AND
4865: IFFALSE 4905
4867: GO 4869
4869: DISABLE
// begin if not ai_s [ 3 ] in your_bases then
4870: LD_EXP 23
4874: PUSH
4875: LD_INT 3
4877: ARRAY
4878: PUSH
4879: LD_EXP 18
4883: IN
4884: NOT
4885: IFFALSE 4905
// SurrenderBase ( t_killbeat , ai_s [ 3 ] ) ;
4887: LD_EXP 6
4891: PPUSH
4892: LD_EXP 23
4896: PUSH
4897: LD_INT 3
4899: ARRAY
4900: PPUSH
4901: CALL 30359 0 2
// end ;
4905: END
// function otazky ; var qb , qg , q ; begin
4906: LD_INT 0
4908: PPUSH
4909: PPUSH
4910: PPUSH
4911: PPUSH
// DC_BaseQuestion ;
4912: CALL 5509 0 0
// qb := 0 ;
4916: LD_ADDR_VAR 0 2
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// qg := 0 ;
4924: LD_ADDR_VAR 0 3
4928: PUSH
4929: LD_INT 0
4931: ST_TO_ADDR
// q := 0 ;
4932: LD_ADDR_VAR 0 4
4936: PUSH
4937: LD_INT 0
4939: ST_TO_ADDR
// while [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] and jeste_nebylo do
4940: LD_VAR 0 2
4944: PUSH
4945: LD_INT 2
4947: LESSEQUAL
4948: PUSH
4949: LD_VAR 0 2
4953: PUSH
4954: LD_INT 1
4956: LESSEQUAL
4957: PUSH
4958: LD_VAR 0 2
4962: PUSH
4963: LD_INT 0
4965: LESSEQUAL
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: LD_OWVAR 67
4976: ARRAY
4977: PUSH
4978: LD_LOC 12
4982: AND
4983: IFFALSE 5405
// begin q := q + 1 ;
4985: LD_ADDR_VAR 0 4
4989: PUSH
4990: LD_VAR 0 4
4994: PUSH
4995: LD_INT 1
4997: PLUS
4998: ST_TO_ADDR
// case jeste_nebylo [ Rand ( 1 , jeste_nebylo ) ] of 1 :
4999: LD_LOC 12
5003: PUSH
5004: LD_INT 1
5006: PPUSH
5007: LD_LOC 12
5011: PPUSH
5012: CALL_OW 12
5016: ARRAY
5017: PUSH
5018: LD_INT 1
5020: DOUBLE
5021: EQUAL
5022: IFTRUE 5026
5024: GO 5082
5026: POP
// begin if QML1 then
5027: CALL 5537 0 0
5031: IFFALSE 5049
// qg := qg + 1 else
5033: LD_ADDR_VAR 0 3
5037: PUSH
5038: LD_VAR 0 3
5042: PUSH
5043: LD_INT 1
5045: PLUS
5046: ST_TO_ADDR
5047: GO 5063
// qb := qb + 1 ;
5049: LD_ADDR_VAR 0 2
5053: PUSH
5054: LD_VAR 0 2
5058: PUSH
5059: LD_INT 1
5061: PLUS
5062: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 1 ] ;
5063: LD_ADDR_LOC 12
5067: PUSH
5068: LD_LOC 12
5072: PUSH
5073: LD_INT 1
5075: PUSH
5076: EMPTY
5077: LIST
5078: DIFF
5079: ST_TO_ADDR
// end ; 2 :
5080: GO 5403
5082: LD_INT 2
5084: DOUBLE
5085: EQUAL
5086: IFTRUE 5090
5088: GO 5146
5090: POP
// begin if QML2 then
5091: CALL 5741 0 0
5095: IFFALSE 5113
// qg := qg + 1 else
5097: LD_ADDR_VAR 0 3
5101: PUSH
5102: LD_VAR 0 3
5106: PUSH
5107: LD_INT 1
5109: PLUS
5110: ST_TO_ADDR
5111: GO 5127
// qb := qb + 1 ;
5113: LD_ADDR_VAR 0 2
5117: PUSH
5118: LD_VAR 0 2
5122: PUSH
5123: LD_INT 1
5125: PLUS
5126: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 2 ] ;
5127: LD_ADDR_LOC 12
5131: PUSH
5132: LD_LOC 12
5136: PUSH
5137: LD_INT 2
5139: PUSH
5140: EMPTY
5141: LIST
5142: DIFF
5143: ST_TO_ADDR
// end ; 3 :
5144: GO 5403
5146: LD_INT 3
5148: DOUBLE
5149: EQUAL
5150: IFTRUE 5154
5152: GO 5210
5154: POP
// begin if QML3 then
5155: CALL 5945 0 0
5159: IFFALSE 5177
// qg := qg + 1 else
5161: LD_ADDR_VAR 0 3
5165: PUSH
5166: LD_VAR 0 3
5170: PUSH
5171: LD_INT 1
5173: PLUS
5174: ST_TO_ADDR
5175: GO 5191
// qb := qb + 1 ;
5177: LD_ADDR_VAR 0 2
5181: PUSH
5182: LD_VAR 0 2
5186: PUSH
5187: LD_INT 1
5189: PLUS
5190: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 3 ] ;
5191: LD_ADDR_LOC 12
5195: PUSH
5196: LD_LOC 12
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: EMPTY
5205: LIST
5206: DIFF
5207: ST_TO_ADDR
// end ; 4 :
5208: GO 5403
5210: LD_INT 4
5212: DOUBLE
5213: EQUAL
5214: IFTRUE 5218
5216: GO 5274
5218: POP
// begin if QML4 then
5219: CALL 6149 0 0
5223: IFFALSE 5241
// qg := qg + 1 else
5225: LD_ADDR_VAR 0 3
5229: PUSH
5230: LD_VAR 0 3
5234: PUSH
5235: LD_INT 1
5237: PLUS
5238: ST_TO_ADDR
5239: GO 5255
// qb := qb + 1 ;
5241: LD_ADDR_VAR 0 2
5245: PUSH
5246: LD_VAR 0 2
5250: PUSH
5251: LD_INT 1
5253: PLUS
5254: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 4 ] ;
5255: LD_ADDR_LOC 12
5259: PUSH
5260: LD_LOC 12
5264: PUSH
5265: LD_INT 4
5267: PUSH
5268: EMPTY
5269: LIST
5270: DIFF
5271: ST_TO_ADDR
// end ; 5 :
5272: GO 5403
5274: LD_INT 5
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5282
5280: GO 5338
5282: POP
// begin if QML5 then
5283: CALL 6353 0 0
5287: IFFALSE 5305
// qg := qg + 1 else
5289: LD_ADDR_VAR 0 3
5293: PUSH
5294: LD_VAR 0 3
5298: PUSH
5299: LD_INT 1
5301: PLUS
5302: ST_TO_ADDR
5303: GO 5319
// qb := qb + 1 ;
5305: LD_ADDR_VAR 0 2
5309: PUSH
5310: LD_VAR 0 2
5314: PUSH
5315: LD_INT 1
5317: PLUS
5318: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 5 ] ;
5319: LD_ADDR_LOC 12
5323: PUSH
5324: LD_LOC 12
5328: PUSH
5329: LD_INT 5
5331: PUSH
5332: EMPTY
5333: LIST
5334: DIFF
5335: ST_TO_ADDR
// end ; 6 :
5336: GO 5403
5338: LD_INT 6
5340: DOUBLE
5341: EQUAL
5342: IFTRUE 5346
5344: GO 5402
5346: POP
// begin if QML6 then
5347: CALL 6557 0 0
5351: IFFALSE 5369
// qg := qg + 1 else
5353: LD_ADDR_VAR 0 3
5357: PUSH
5358: LD_VAR 0 3
5362: PUSH
5363: LD_INT 1
5365: PLUS
5366: ST_TO_ADDR
5367: GO 5383
// qb := qb + 1 ;
5369: LD_ADDR_VAR 0 2
5373: PUSH
5374: LD_VAR 0 2
5378: PUSH
5379: LD_INT 1
5381: PLUS
5382: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 6 ] ;
5383: LD_ADDR_LOC 12
5387: PUSH
5388: LD_LOC 12
5392: PUSH
5393: LD_INT 6
5395: PUSH
5396: EMPTY
5397: LIST
5398: DIFF
5399: ST_TO_ADDR
// end ; end ;
5400: GO 5403
5402: POP
// end ;
5403: GO 4940
// if qg = 6 then
5405: LD_VAR 0 3
5409: PUSH
5410: LD_INT 6
5412: EQUAL
5413: IFFALSE 5419
// SA_OnTsaritsynQuizPerfectCleared ;
5415: CALL 33157 0 0
// if [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] then
5419: LD_VAR 0 2
5423: PUSH
5424: LD_INT 2
5426: LESSEQUAL
5427: PUSH
5428: LD_VAR 0 2
5432: PUSH
5433: LD_INT 1
5435: LESSEQUAL
5436: PUSH
5437: LD_VAR 0 2
5441: PUSH
5442: LD_INT 0
5444: LESSEQUAL
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: LIST
5450: PUSH
5451: LD_OWVAR 67
5455: ARRAY
5456: IFFALSE 5468
// result := true else
5458: LD_ADDR_VAR 0 1
5462: PUSH
5463: LD_INT 1
5465: ST_TO_ADDR
5466: GO 5476
// result := false ;
5468: LD_ADDR_VAR 0 1
5472: PUSH
5473: LD_INT 0
5475: ST_TO_ADDR
// end ;
5476: LD_VAR 0 1
5480: RET
// export function DC_BaseContact ; begin
5481: LD_INT 0
5483: PPUSH
// DialogueOn ;
5484: CALL_OW 6
// Say ( Tsr , DC-BaseContact-Tsr-1 ) ;
5488: LD_LOC 7
5492: PPUSH
5493: LD_STRING DC-BaseContact-Tsr-1
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ;
5504: LD_VAR 0 1
5508: RET
// export function DC_BaseQuestion ; begin
5509: LD_INT 0
5511: PPUSH
// DialogueOn ;
5512: CALL_OW 6
// Say ( Tsr , DC-BaseQuestion-Tsr-1 ) ;
5516: LD_LOC 7
5520: PPUSH
5521: LD_STRING DC-BaseQuestion-Tsr-1
5523: PPUSH
5524: CALL_OW 88
// DialogueOff ;
5528: CALL_OW 7
// end ;
5532: LD_VAR 0 1
5536: RET
// function QML1 ; var mozn , qr , a , bad ; begin
5537: LD_INT 0
5539: PPUSH
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
// bad := [ 1 , 3 ] ;
5544: LD_ADDR_VAR 0 5
5548: PUSH
5549: LD_INT 1
5551: PUSH
5552: LD_INT 3
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5559: LD_ADDR_VAR 0 2
5563: PUSH
5564: LD_INT 1
5566: PUSH
5567: LD_INT 2
5569: PUSH
5570: LD_INT 3
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// if IsOk ( Gleb ) then
5578: LD_EXP 50
5582: PPUSH
5583: CALL_OW 302
5587: IFFALSE 5606
// mozn := mozn ^ [ 4 ] ;
5589: LD_ADDR_VAR 0 2
5593: PUSH
5594: LD_VAR 0 2
5598: PUSH
5599: LD_INT 4
5601: PUSH
5602: EMPTY
5603: LIST
5604: ADD
5605: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5606: LD_ADDR_VAR 0 3
5610: PUSH
5611: LD_STRING QML1
5613: PPUSH
5614: LD_VAR 0 2
5618: PPUSH
5619: CALL_OW 98
5623: ST_TO_ADDR
// if qr = 4 then
5624: LD_VAR 0 3
5628: PUSH
5629: LD_INT 4
5631: EQUAL
5632: IFFALSE 5706
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5634: LD_ADDR_VAR 0 4
5638: PUSH
5639: LD_VAR 0 5
5643: PUSH
5644: LD_INT 1
5646: PPUSH
5647: LD_INT 2
5649: PPUSH
5650: CALL_OW 12
5654: ARRAY
5655: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: LD_VAR 0 2
5674: PUSH
5675: LD_VAR 0 4
5679: PUSH
5680: LD_INT 4
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: DIFF
5687: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5688: LD_ADDR_VAR 0 3
5692: PUSH
5693: LD_STRING QML1
5695: PPUSH
5696: LD_VAR 0 2
5700: PPUSH
5701: CALL_OW 98
5705: ST_TO_ADDR
// end ; if qr in bad then
5706: LD_VAR 0 3
5710: PUSH
5711: LD_VAR 0 5
5715: IN
5716: IFFALSE 5728
// result := false else
5718: LD_ADDR_VAR 0 1
5722: PUSH
5723: LD_INT 0
5725: ST_TO_ADDR
5726: GO 5736
// result := true ;
5728: LD_ADDR_VAR 0 1
5732: PUSH
5733: LD_INT 1
5735: ST_TO_ADDR
// end ;
5736: LD_VAR 0 1
5740: RET
// function QML2 ; var mozn , qr , a , bad ; begin
5741: LD_INT 0
5743: PPUSH
5744: PPUSH
5745: PPUSH
5746: PPUSH
5747: PPUSH
// bad := [ 2 , 3 ] ;
5748: LD_ADDR_VAR 0 5
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 3
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5763: LD_ADDR_VAR 0 2
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 3
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: ST_TO_ADDR
// if IsOk ( Gleb ) then
5782: LD_EXP 50
5786: PPUSH
5787: CALL_OW 302
5791: IFFALSE 5810
// mozn := mozn ^ [ 4 ] ;
5793: LD_ADDR_VAR 0 2
5797: PUSH
5798: LD_VAR 0 2
5802: PUSH
5803: LD_INT 4
5805: PUSH
5806: EMPTY
5807: LIST
5808: ADD
5809: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5810: LD_ADDR_VAR 0 3
5814: PUSH
5815: LD_STRING QML2
5817: PPUSH
5818: LD_VAR 0 2
5822: PPUSH
5823: CALL_OW 98
5827: ST_TO_ADDR
// if qr = 4 then
5828: LD_VAR 0 3
5832: PUSH
5833: LD_INT 4
5835: EQUAL
5836: IFFALSE 5910
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5838: LD_ADDR_VAR 0 4
5842: PUSH
5843: LD_VAR 0 5
5847: PUSH
5848: LD_INT 1
5850: PPUSH
5851: LD_INT 2
5853: PPUSH
5854: CALL_OW 12
5858: ARRAY
5859: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5860: LD_VAR 0 4
5864: PPUSH
5865: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
5869: LD_ADDR_VAR 0 2
5873: PUSH
5874: LD_VAR 0 2
5878: PUSH
5879: LD_VAR 0 4
5883: PUSH
5884: LD_INT 4
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: DIFF
5891: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_STRING QML2
5899: PPUSH
5900: LD_VAR 0 2
5904: PPUSH
5905: CALL_OW 98
5909: ST_TO_ADDR
// end ; if qr in bad then
5910: LD_VAR 0 3
5914: PUSH
5915: LD_VAR 0 5
5919: IN
5920: IFFALSE 5932
// result := false else
5922: LD_ADDR_VAR 0 1
5926: PUSH
5927: LD_INT 0
5929: ST_TO_ADDR
5930: GO 5940
// result := true ;
5932: LD_ADDR_VAR 0 1
5936: PUSH
5937: LD_INT 1
5939: ST_TO_ADDR
// end ;
5940: LD_VAR 0 1
5944: RET
// function QML3 ; var mozn , qr , a , bad ; begin
5945: LD_INT 0
5947: PPUSH
5948: PPUSH
5949: PPUSH
5950: PPUSH
5951: PPUSH
// bad := [ 1 , 3 ] ;
5952: LD_ADDR_VAR 0 5
5956: PUSH
5957: LD_INT 1
5959: PUSH
5960: LD_INT 3
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 3
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: ST_TO_ADDR
// if IsOk ( Gleb ) then
5986: LD_EXP 50
5990: PPUSH
5991: CALL_OW 302
5995: IFFALSE 6014
// mozn := mozn ^ [ 4 ] ;
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: LD_VAR 0 2
6006: PUSH
6007: LD_INT 4
6009: PUSH
6010: EMPTY
6011: LIST
6012: ADD
6013: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6014: LD_ADDR_VAR 0 3
6018: PUSH
6019: LD_STRING QML3
6021: PPUSH
6022: LD_VAR 0 2
6026: PPUSH
6027: CALL_OW 98
6031: ST_TO_ADDR
// if qr = 4 then
6032: LD_VAR 0 3
6036: PUSH
6037: LD_INT 4
6039: EQUAL
6040: IFFALSE 6114
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6042: LD_ADDR_VAR 0 4
6046: PUSH
6047: LD_VAR 0 5
6051: PUSH
6052: LD_INT 1
6054: PPUSH
6055: LD_INT 2
6057: PPUSH
6058: CALL_OW 12
6062: ARRAY
6063: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6064: LD_VAR 0 4
6068: PPUSH
6069: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
6073: LD_ADDR_VAR 0 2
6077: PUSH
6078: LD_VAR 0 2
6082: PUSH
6083: LD_VAR 0 4
6087: PUSH
6088: LD_INT 4
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: DIFF
6095: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6096: LD_ADDR_VAR 0 3
6100: PUSH
6101: LD_STRING QML3
6103: PPUSH
6104: LD_VAR 0 2
6108: PPUSH
6109: CALL_OW 98
6113: ST_TO_ADDR
// end ; if qr in bad then
6114: LD_VAR 0 3
6118: PUSH
6119: LD_VAR 0 5
6123: IN
6124: IFFALSE 6136
// result := false else
6126: LD_ADDR_VAR 0 1
6130: PUSH
6131: LD_INT 0
6133: ST_TO_ADDR
6134: GO 6144
// result := true ;
6136: LD_ADDR_VAR 0 1
6140: PUSH
6141: LD_INT 1
6143: ST_TO_ADDR
// end ;
6144: LD_VAR 0 1
6148: RET
// function QML4 ; var mozn , qr , a , bad ; begin
6149: LD_INT 0
6151: PPUSH
6152: PPUSH
6153: PPUSH
6154: PPUSH
6155: PPUSH
// bad := [ 1 , 2 ] ;
6156: LD_ADDR_VAR 0 5
6160: PUSH
6161: LD_INT 1
6163: PUSH
6164: LD_INT 2
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6171: LD_ADDR_VAR 0 2
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 3
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: ST_TO_ADDR
// if IsOk ( Gleb ) then
6190: LD_EXP 50
6194: PPUSH
6195: CALL_OW 302
6199: IFFALSE 6218
// mozn := mozn ^ [ 4 ] ;
6201: LD_ADDR_VAR 0 2
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 4
6213: PUSH
6214: EMPTY
6215: LIST
6216: ADD
6217: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6218: LD_ADDR_VAR 0 3
6222: PUSH
6223: LD_STRING QML4
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: CALL_OW 98
6235: ST_TO_ADDR
// if qr = 4 then
6236: LD_VAR 0 3
6240: PUSH
6241: LD_INT 4
6243: EQUAL
6244: IFFALSE 6318
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6246: LD_ADDR_VAR 0 4
6250: PUSH
6251: LD_VAR 0 5
6255: PUSH
6256: LD_INT 1
6258: PPUSH
6259: LD_INT 2
6261: PPUSH
6262: CALL_OW 12
6266: ARRAY
6267: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6268: LD_VAR 0 4
6272: PPUSH
6273: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
6277: LD_ADDR_VAR 0 2
6281: PUSH
6282: LD_VAR 0 2
6286: PUSH
6287: LD_VAR 0 4
6291: PUSH
6292: LD_INT 4
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: DIFF
6299: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6300: LD_ADDR_VAR 0 3
6304: PUSH
6305: LD_STRING QML4
6307: PPUSH
6308: LD_VAR 0 2
6312: PPUSH
6313: CALL_OW 98
6317: ST_TO_ADDR
// end ; if qr in bad then
6318: LD_VAR 0 3
6322: PUSH
6323: LD_VAR 0 5
6327: IN
6328: IFFALSE 6340
// result := false else
6330: LD_ADDR_VAR 0 1
6334: PUSH
6335: LD_INT 0
6337: ST_TO_ADDR
6338: GO 6348
// result := true ;
6340: LD_ADDR_VAR 0 1
6344: PUSH
6345: LD_INT 1
6347: ST_TO_ADDR
// end ;
6348: LD_VAR 0 1
6352: RET
// function QML5 ; var mozn , qr , a , bad ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
6358: PPUSH
6359: PPUSH
// bad := [ 1 , 3 ] ;
6360: LD_ADDR_VAR 0 5
6364: PUSH
6365: LD_INT 1
6367: PUSH
6368: LD_INT 3
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6375: LD_ADDR_VAR 0 2
6379: PUSH
6380: LD_INT 1
6382: PUSH
6383: LD_INT 2
6385: PUSH
6386: LD_INT 3
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: LIST
6393: ST_TO_ADDR
// if IsOk ( Gleb ) then
6394: LD_EXP 50
6398: PPUSH
6399: CALL_OW 302
6403: IFFALSE 6422
// mozn := mozn ^ [ 4 ] ;
6405: LD_ADDR_VAR 0 2
6409: PUSH
6410: LD_VAR 0 2
6414: PUSH
6415: LD_INT 4
6417: PUSH
6418: EMPTY
6419: LIST
6420: ADD
6421: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6422: LD_ADDR_VAR 0 3
6426: PUSH
6427: LD_STRING QML5
6429: PPUSH
6430: LD_VAR 0 2
6434: PPUSH
6435: CALL_OW 98
6439: ST_TO_ADDR
// if qr = 4 then
6440: LD_VAR 0 3
6444: PUSH
6445: LD_INT 4
6447: EQUAL
6448: IFFALSE 6522
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6450: LD_ADDR_VAR 0 4
6454: PUSH
6455: LD_VAR 0 5
6459: PUSH
6460: LD_INT 1
6462: PPUSH
6463: LD_INT 2
6465: PPUSH
6466: CALL_OW 12
6470: ARRAY
6471: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6472: LD_VAR 0 4
6476: PPUSH
6477: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
6481: LD_ADDR_VAR 0 2
6485: PUSH
6486: LD_VAR 0 2
6490: PUSH
6491: LD_VAR 0 4
6495: PUSH
6496: LD_INT 4
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: DIFF
6503: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6504: LD_ADDR_VAR 0 3
6508: PUSH
6509: LD_STRING QML5
6511: PPUSH
6512: LD_VAR 0 2
6516: PPUSH
6517: CALL_OW 98
6521: ST_TO_ADDR
// end ; if qr in bad then
6522: LD_VAR 0 3
6526: PUSH
6527: LD_VAR 0 5
6531: IN
6532: IFFALSE 6544
// result := false else
6534: LD_ADDR_VAR 0 1
6538: PUSH
6539: LD_INT 0
6541: ST_TO_ADDR
6542: GO 6552
// result := true ;
6544: LD_ADDR_VAR 0 1
6548: PUSH
6549: LD_INT 1
6551: ST_TO_ADDR
// end ;
6552: LD_VAR 0 1
6556: RET
// function QML6 ; var mozn , qr , a , bad ; begin
6557: LD_INT 0
6559: PPUSH
6560: PPUSH
6561: PPUSH
6562: PPUSH
6563: PPUSH
// bad := [ 2 , 3 ] ;
6564: LD_ADDR_VAR 0 5
6568: PUSH
6569: LD_INT 2
6571: PUSH
6572: LD_INT 3
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6579: LD_ADDR_VAR 0 2
6583: PUSH
6584: LD_INT 1
6586: PUSH
6587: LD_INT 2
6589: PUSH
6590: LD_INT 3
6592: PUSH
6593: EMPTY
6594: LIST
6595: LIST
6596: LIST
6597: ST_TO_ADDR
// if IsOk ( Gleb ) then
6598: LD_EXP 50
6602: PPUSH
6603: CALL_OW 302
6607: IFFALSE 6626
// mozn := mozn ^ [ 4 ] ;
6609: LD_ADDR_VAR 0 2
6613: PUSH
6614: LD_VAR 0 2
6618: PUSH
6619: LD_INT 4
6621: PUSH
6622: EMPTY
6623: LIST
6624: ADD
6625: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6626: LD_ADDR_VAR 0 3
6630: PUSH
6631: LD_STRING QML6
6633: PPUSH
6634: LD_VAR 0 2
6638: PPUSH
6639: CALL_OW 98
6643: ST_TO_ADDR
// if qr = 4 then
6644: LD_VAR 0 3
6648: PUSH
6649: LD_INT 4
6651: EQUAL
6652: IFFALSE 6726
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6654: LD_ADDR_VAR 0 4
6658: PUSH
6659: LD_VAR 0 5
6663: PUSH
6664: LD_INT 1
6666: PPUSH
6667: LD_INT 2
6669: PPUSH
6670: CALL_OW 12
6674: ARRAY
6675: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6676: LD_VAR 0 4
6680: PPUSH
6681: CALL 6849 0 1
// mozn := mozn diff [ a , 4 ] ;
6685: LD_ADDR_VAR 0 2
6689: PUSH
6690: LD_VAR 0 2
6694: PUSH
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 4
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: DIFF
6707: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_STRING QML6
6715: PPUSH
6716: LD_VAR 0 2
6720: PPUSH
6721: CALL_OW 98
6725: ST_TO_ADDR
// end ; if qr in bad then
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 5
6735: IN
6736: IFFALSE 6748
// result := false else
6738: LD_ADDR_VAR 0 1
6742: PUSH
6743: LD_INT 0
6745: ST_TO_ADDR
6746: GO 6756
// result := true ;
6748: LD_ADDR_VAR 0 1
6752: PUSH
6753: LD_INT 1
6755: ST_TO_ADDR
// end ;
6756: LD_VAR 0 1
6760: RET
// export function DQrML_Right ( first ) ; begin
6761: LD_INT 0
6763: PPUSH
// DialogueOn ;
6764: CALL_OW 6
// Say ( Tsr , DQrML#Right-Tsr-1 ) ;
6768: LD_LOC 7
6772: PPUSH
6773: LD_STRING DQrML#Right-Tsr-1
6775: PPUSH
6776: CALL_OW 88
// if first then
6780: LD_VAR 0 1
6784: IFFALSE 6800
// Say ( Tsr , DQrML#Right-Tsr-1a ) else
6786: LD_LOC 7
6790: PPUSH
6791: LD_STRING DQrML#Right-Tsr-1a
6793: PPUSH
6794: CALL_OW 88
6798: GO 6812
// Say ( Tsr , DQrML#Right-Tsr-1b ) ;
6800: LD_LOC 7
6804: PPUSH
6805: LD_STRING DQrML#Right-Tsr-1b
6807: PPUSH
6808: CALL_OW 88
// DialogueOff ;
6812: CALL_OW 7
// end ;
6816: LD_VAR 0 2
6820: RET
// export function DQrML_Wrong ; begin
6821: LD_INT 0
6823: PPUSH
// DialogueOn ;
6824: CALL_OW 6
// Say ( Tsr , DQrML#Wrong-Tsr-1 ) ;
6828: LD_LOC 7
6832: PPUSH
6833: LD_STRING DQrML#Wrong-Tsr-1
6835: PPUSH
6836: CALL_OW 88
// DialogueOff ;
6840: CALL_OW 7
// end ;
6844: LD_VAR 0 1
6848: RET
// function DQrML_Gleb ( num ) ; begin
6849: LD_INT 0
6851: PPUSH
// DialogueOn ;
6852: CALL_OW 6
// case num of 1 :
6856: LD_VAR 0 1
6860: PUSH
6861: LD_INT 1
6863: DOUBLE
6864: EQUAL
6865: IFTRUE 6869
6867: GO 6884
6869: POP
// Say ( Glb , DQrML#Gleb-Glb-1 ) ; 2 :
6870: LD_LOC 10
6874: PPUSH
6875: LD_STRING DQrML#Gleb-Glb-1
6877: PPUSH
6878: CALL_OW 88
6882: GO 6931
6884: LD_INT 2
6886: DOUBLE
6887: EQUAL
6888: IFTRUE 6892
6890: GO 6907
6892: POP
// Say ( Glb , DQrML#Gleb-Glb-1a ) ; 3 :
6893: LD_LOC 10
6897: PPUSH
6898: LD_STRING DQrML#Gleb-Glb-1a
6900: PPUSH
6901: CALL_OW 88
6905: GO 6931
6907: LD_INT 3
6909: DOUBLE
6910: EQUAL
6911: IFTRUE 6915
6913: GO 6930
6915: POP
// Say ( Glb , DQrML#Gleb-Glb-1b ) ; end ;
6916: LD_LOC 10
6920: PPUSH
6921: LD_STRING DQrML#Gleb-Glb-1b
6923: PPUSH
6924: CALL_OW 88
6928: GO 6931
6930: POP
// DialogueOff ;
6931: CALL_OW 7
// end ;
6935: LD_VAR 0 2
6939: RET
// export maji_artifact ; every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
6940: LD_LOC 2
6944: PPUSH
6945: LD_INT 22
6947: PPUSH
6948: CALL_OW 308
6952: PUSH
6953: LD_EXP 23
6957: PUSH
6958: LD_INT 1
6960: ARRAY
6961: PUSH
6962: LD_EXP 23
6966: PUSH
6967: LD_INT 4
6969: ARRAY
6970: NONEQUAL
6971: AND
6972: IFFALSE 7062
6974: GO 6976
6976: DISABLE
// begin DD_BaseContact ;
6977: CALL 7229 0 0
// if maji_artifact then
6981: LD_EXP 39
6985: IFFALSE 7024
// begin if not ai_s [ 4 ] in your_bases then
6987: LD_EXP 23
6991: PUSH
6992: LD_INT 4
6994: ARRAY
6995: PUSH
6996: LD_EXP 18
7000: IN
7001: NOT
7002: IFFALSE 7022
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7004: LD_EXP 4
7008: PPUSH
7009: LD_EXP 23
7013: PUSH
7014: LD_INT 4
7016: ARRAY
7017: PPUSH
7018: CALL 30359 0 2
// end else
7022: GO 7059
// begin DD_BaseRefuse1st ;
7024: CALL 7277 0 0
// while IsInArea ( Bur , d_base ) do
7028: LD_LOC 2
7032: PPUSH
7033: LD_INT 22
7035: PPUSH
7036: CALL_OW 308
7040: IFFALSE 7051
// wait ( 0 0$1 ) ;
7042: LD_INT 35
7044: PPUSH
7045: CALL_OW 67
7049: GO 7028
// wait ( 0 0$20 ) ;
7051: LD_INT 700
7053: PPUSH
7054: CALL_OW 67
// enable ;
7058: ENABLE
// end ; enable ( 12 ) ;
7059: LD_INT 12
7061: ENABLE_MARKED
// end ;
7062: END
// every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] marked 12 do
7063: LD_LOC 2
7067: PPUSH
7068: LD_INT 22
7070: PPUSH
7071: CALL_OW 308
7075: PUSH
7076: LD_EXP 23
7080: PUSH
7081: LD_INT 1
7083: ARRAY
7084: PUSH
7085: LD_EXP 23
7089: PUSH
7090: LD_INT 4
7092: ARRAY
7093: NONEQUAL
7094: AND
7095: IFFALSE 7155
7097: GO 7099
7099: DISABLE
// begin if maji_artifact then
7100: LD_EXP 39
7104: IFFALSE 7143
// begin if not ai_s [ 4 ] in your_bases then
7106: LD_EXP 23
7110: PUSH
7111: LD_INT 4
7113: ARRAY
7114: PUSH
7115: LD_EXP 18
7119: IN
7120: NOT
7121: IFFALSE 7141
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7123: LD_EXP 4
7127: PPUSH
7128: LD_EXP 23
7132: PUSH
7133: LD_INT 4
7135: ARRAY
7136: PPUSH
7137: CALL 30359 0 2
// end else
7141: GO 7155
// begin DD_BaseRefuse ;
7143: CALL 7305 0 0
// wait ( 0 0$20 ) ;
7147: LD_INT 700
7149: PPUSH
7150: CALL_OW 67
// enable ;
7154: ENABLE
// end ; end ;
7155: END
// every 0 0$2 trigger humans [ 4 ] <= 4 and ai_s [ 1 ] <> ai_s [ 4 ] do
7156: LD_EXP 76
7160: PUSH
7161: LD_INT 4
7163: ARRAY
7164: PUSH
7165: LD_INT 4
7167: LESSEQUAL
7168: PUSH
7169: LD_EXP 23
7173: PUSH
7174: LD_INT 1
7176: ARRAY
7177: PUSH
7178: LD_EXP 23
7182: PUSH
7183: LD_INT 4
7185: ARRAY
7186: NONEQUAL
7187: AND
7188: IFFALSE 7228
7190: GO 7192
7192: DISABLE
// begin if not ai_s [ 4 ] in your_bases then
7193: LD_EXP 23
7197: PUSH
7198: LD_INT 4
7200: ARRAY
7201: PUSH
7202: LD_EXP 18
7206: IN
7207: NOT
7208: IFFALSE 7228
// SurrenderBase ( t_killbeat , ai_s [ 4 ] ) ;
7210: LD_EXP 6
7214: PPUSH
7215: LD_EXP 23
7219: PUSH
7220: LD_INT 4
7222: ARRAY
7223: PPUSH
7224: CALL 30359 0 2
// end ;
7228: END
// export kecali_o_artefaktu ; export function DD_BaseContact ; begin
7229: LD_INT 0
7231: PPUSH
// DialogueOn ;
7232: CALL_OW 6
// Say ( Dav , DD-BaseContact-Dav-1 ) ;
7236: LD_LOC 8
7240: PPUSH
7241: LD_STRING DD-BaseContact-Dav-1
7243: PPUSH
7244: CALL_OW 88
// Say ( Bur , DD-BaseContact-Bur-1 ) ;
7248: LD_LOC 2
7252: PPUSH
7253: LD_STRING DD-BaseContact-Bur-1
7255: PPUSH
7256: CALL_OW 88
// kecali_o_artefaktu := true ;
7260: LD_ADDR_EXP 40
7264: PUSH
7265: LD_INT 1
7267: ST_TO_ADDR
// DialogueOff ;
7268: CALL_OW 7
// end ;
7272: LD_VAR 0 1
7276: RET
// export function DD_BaseRefuse1st ; begin
7277: LD_INT 0
7279: PPUSH
// DialogueOn ;
7280: CALL_OW 6
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7284: LD_LOC 8
7288: PPUSH
7289: LD_STRING DD-BaseRefuse-Dav-1
7291: PPUSH
7292: CALL_OW 88
// DialogueOff ;
7296: CALL_OW 7
// end ;
7300: LD_VAR 0 1
7304: RET
// export function DD_BaseRefuse ; begin
7305: LD_INT 0
7307: PPUSH
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7308: LD_LOC 8
7312: PPUSH
7313: LD_STRING DD-BaseRefuse-Dav-1
7315: PPUSH
7316: CALL_OW 88
// end ;
7320: LD_VAR 0 1
7324: RET
// export function DD_BaseAccept ( first ) ; begin
7325: LD_INT 0
7327: PPUSH
// DialogueOn ;
7328: CALL_OW 6
// Say ( Dav , DD-BaseAccept-Dav-1 ) ;
7332: LD_LOC 8
7336: PPUSH
7337: LD_STRING DD-BaseAccept-Dav-1
7339: PPUSH
7340: CALL_OW 88
// if first then
7344: LD_VAR 0 1
7348: IFFALSE 7364
// Say ( Dav , DD-BaseAccept-Dav-1a ) else
7350: LD_LOC 8
7354: PPUSH
7355: LD_STRING DD-BaseAccept-Dav-1a
7357: PPUSH
7358: CALL_OW 88
7362: GO 7376
// Say ( Dav , DD-BaseAccept-Dav-1b ) ;
7364: LD_LOC 8
7368: PPUSH
7369: LD_STRING DD-BaseAccept-Dav-1b
7371: PPUSH
7372: CALL_OW 88
// DialogueOff ;
7376: CALL_OW 7
// end ;
7380: LD_VAR 0 2
7384: RET
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] do
7385: LD_LOC 2
7389: PPUSH
7390: LD_INT 21
7392: PPUSH
7393: CALL_OW 308
7397: PUSH
7398: LD_EXP 23
7402: PUSH
7403: LD_INT 1
7405: ARRAY
7406: PUSH
7407: LD_EXP 23
7411: PUSH
7412: LD_INT 5
7414: ARRAY
7415: NONEQUAL
7416: AND
7417: IFFALSE 7528
7419: GO 7421
7421: DISABLE
// begin DE_BaseContact ;
7422: CALL 7790 0 0
// if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7426: LD_EXP 76
7430: PUSH
7431: LD_INT 5
7433: ARRAY
7434: PPUSH
7435: LD_INT 50
7437: PUSH
7438: EMPTY
7439: LIST
7440: PUSH
7441: EMPTY
7442: LIST
7443: PPUSH
7444: CALL_OW 72
7448: PUSH
7449: LD_INT 6
7451: GREATER
7452: IFFALSE 7493
// begin DE_BaseRefuse1st ;
7454: CALL 7830 0 0
// while IsInArea ( Bur , e_base ) do
7458: LD_LOC 2
7462: PPUSH
7463: LD_INT 21
7465: PPUSH
7466: CALL_OW 308
7470: IFFALSE 7481
// wait ( 0 0$1 ) ;
7472: LD_INT 35
7474: PPUSH
7475: CALL_OW 67
7479: GO 7458
// wait ( 0 0$20 ) ;
7481: LD_INT 700
7483: PPUSH
7484: CALL_OW 67
// enable ( 115 ) ;
7488: LD_INT 115
7490: ENABLE_MARKED
// end else
7491: GO 7528
// if not ai_s [ 5 ] in your_bases then
7493: LD_EXP 23
7497: PUSH
7498: LD_INT 5
7500: ARRAY
7501: PUSH
7502: LD_EXP 18
7506: IN
7507: NOT
7508: IFFALSE 7528
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7510: LD_EXP 5
7514: PPUSH
7515: LD_EXP 23
7519: PUSH
7520: LD_INT 5
7522: ARRAY
7523: PPUSH
7524: CALL 30359 0 2
// end ;
7528: END
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] marked 115 do
7529: LD_LOC 2
7533: PPUSH
7534: LD_INT 21
7536: PPUSH
7537: CALL_OW 308
7541: PUSH
7542: LD_EXP 23
7546: PUSH
7547: LD_INT 1
7549: ARRAY
7550: PUSH
7551: LD_EXP 23
7555: PUSH
7556: LD_INT 5
7558: ARRAY
7559: NONEQUAL
7560: AND
7561: IFFALSE 7629
7563: GO 7565
7565: DISABLE
// begin if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7566: LD_EXP 76
7570: PUSH
7571: LD_INT 5
7573: ARRAY
7574: PPUSH
7575: LD_INT 50
7577: PUSH
7578: EMPTY
7579: LIST
7580: PUSH
7581: EMPTY
7582: LIST
7583: PPUSH
7584: CALL_OW 72
7588: PUSH
7589: LD_INT 6
7591: GREATER
7592: IFFALSE 7628
// begin DE_BaseRefuse ;
7594: CALL 7858 0 0
// while IsInArea ( Bur , e_base ) do
7598: LD_LOC 2
7602: PPUSH
7603: LD_INT 21
7605: PPUSH
7606: CALL_OW 308
7610: IFFALSE 7621
// wait ( 0 0$1 ) ;
7612: LD_INT 35
7614: PPUSH
7615: CALL_OW 67
7619: GO 7598
// wait ( 0 0$20 ) ;
7621: LD_INT 700
7623: PPUSH
7624: CALL_OW 67
// end ; enable ;
7628: ENABLE
// end ;
7629: END
// every 0 0$2 trigger UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) <= 6 and ai_s [ 1 ] <> ai_s [ 5 ] do
7630: LD_EXP 76
7634: PUSH
7635: LD_INT 5
7637: ARRAY
7638: PPUSH
7639: LD_INT 50
7641: PUSH
7642: EMPTY
7643: LIST
7644: PUSH
7645: EMPTY
7646: LIST
7647: PPUSH
7648: CALL_OW 72
7652: PUSH
7653: LD_INT 6
7655: LESSEQUAL
7656: PUSH
7657: LD_EXP 23
7661: PUSH
7662: LD_INT 1
7664: ARRAY
7665: PUSH
7666: LD_EXP 23
7670: PUSH
7671: LD_INT 5
7673: ARRAY
7674: NONEQUAL
7675: AND
7676: IFFALSE 7716
7678: GO 7680
7680: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7681: LD_EXP 23
7685: PUSH
7686: LD_INT 5
7688: ARRAY
7689: PUSH
7690: LD_EXP 18
7694: IN
7695: NOT
7696: IFFALSE 7716
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7698: LD_EXP 5
7702: PPUSH
7703: LD_EXP 23
7707: PUSH
7708: LD_INT 5
7710: ARRAY
7711: PPUSH
7712: CALL 30359 0 2
// end ;
7716: END
// every 0 0$2 trigger humans [ 5 ] <= 4 and ai_s [ 1 ] <> ai_s [ 5 ] do
7717: LD_EXP 76
7721: PUSH
7722: LD_INT 5
7724: ARRAY
7725: PUSH
7726: LD_INT 4
7728: LESSEQUAL
7729: PUSH
7730: LD_EXP 23
7734: PUSH
7735: LD_INT 1
7737: ARRAY
7738: PUSH
7739: LD_EXP 23
7743: PUSH
7744: LD_INT 5
7746: ARRAY
7747: NONEQUAL
7748: AND
7749: IFFALSE 7789
7751: GO 7753
7753: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7754: LD_EXP 23
7758: PUSH
7759: LD_INT 5
7761: ARRAY
7762: PUSH
7763: LD_EXP 18
7767: IN
7768: NOT
7769: IFFALSE 7789
// SurrenderBase ( t_killbeat , ai_s [ 5 ] ) ;
7771: LD_EXP 6
7775: PPUSH
7776: LD_EXP 23
7780: PUSH
7781: LD_INT 5
7783: ARRAY
7784: PPUSH
7785: CALL 30359 0 2
// end ;
7789: END
// export function DE_BaseContact ; begin
7790: LD_INT 0
7792: PPUSH
// DialogueOn ;
7793: CALL_OW 6
// Say ( Eis , DE-BaseContact-Eis-1 ) ;
7797: LD_LOC 9
7801: PPUSH
7802: LD_STRING DE-BaseContact-Eis-1
7804: PPUSH
7805: CALL_OW 88
// Say ( Bur , DE-BaseContact-Bur-1 ) ;
7809: LD_LOC 2
7813: PPUSH
7814: LD_STRING DE-BaseContact-Bur-1
7816: PPUSH
7817: CALL_OW 88
// DialogueOff ;
7821: CALL_OW 7
// end ;
7825: LD_VAR 0 1
7829: RET
// export function DE_BaseRefuse1st ; begin
7830: LD_INT 0
7832: PPUSH
// DialogueOn ;
7833: CALL_OW 6
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7837: LD_LOC 9
7841: PPUSH
7842: LD_STRING DE-BaseRefuse-Eis-1
7844: PPUSH
7845: CALL_OW 88
// DialogueOff ;
7849: CALL_OW 7
// end ;
7853: LD_VAR 0 1
7857: RET
// export function DE_BaseRefuse ; begin
7858: LD_INT 0
7860: PPUSH
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7861: LD_LOC 9
7865: PPUSH
7866: LD_STRING DE-BaseRefuse-Eis-1
7868: PPUSH
7869: CALL_OW 88
// end ;
7873: LD_VAR 0 1
7877: RET
// export function DE_BaseAccept ( first ) ; begin
7878: LD_INT 0
7880: PPUSH
// DialogueOn ;
7881: CALL_OW 6
// Say ( Eis , DE-BaseAccept-Eis-1 ) ;
7885: LD_LOC 9
7889: PPUSH
7890: LD_STRING DE-BaseAccept-Eis-1
7892: PPUSH
7893: CALL_OW 88
// if first then
7897: LD_VAR 0 1
7901: IFFALSE 7917
// Say ( Eis , DE-BaseAccept-Eis-1a ) else
7903: LD_LOC 9
7907: PPUSH
7908: LD_STRING DE-BaseAccept-Eis-1a
7910: PPUSH
7911: CALL_OW 88
7915: GO 7929
// Say ( Eis , DE-BaseAccept-Eis-1b ) ;
7917: LD_LOC 9
7921: PPUSH
7922: LD_STRING DE-BaseAccept-Eis-1b
7924: PPUSH
7925: CALL_OW 88
// DialogueOff ;
7929: CALL_OW 7
// end ;
7933: LD_VAR 0 2
7937: RET
// export function DXbaseSurrender ( side ) ; var who ; begin
7938: LD_INT 0
7940: PPUSH
7941: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , side , sex_male , 0 , 0 ) ;
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 21
7949: PUSH
7950: LD_INT 1
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 23
7959: PUSH
7960: LD_INT 3
7962: PUSH
7963: EMPTY
7964: LIST
7965: LIST
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: PPUSH
7971: CALL_OW 69
7975: PUSH
7976: LD_LOC 11
7980: DIFF
7981: PPUSH
7982: LD_VAR 0 1
7986: PPUSH
7987: LD_INT 1
7989: PPUSH
7990: LD_INT 0
7992: PPUSH
7993: LD_INT 0
7995: PPUSH
7996: CALL 10381 0 5
8000: ST_TO_ADDR
// DialogueOn ;
8001: CALL_OW 6
// Say ( who , DXbaseSurrender-Rsol1-1 ) ;
8005: LD_VAR 0 3
8009: PPUSH
8010: LD_STRING DXbaseSurrender-Rsol1-1
8012: PPUSH
8013: CALL_OW 88
// DialogueOff ;
8017: CALL_OW 7
// end ;
8021: LD_VAR 0 2
8025: RET
// export function DRocket ; var who ; begin
8026: LD_INT 0
8028: PPUSH
8029: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , class_scientistic , 0 ) ;
8030: LD_ADDR_VAR 0 2
8034: PUSH
8035: LD_INT 21
8037: PUSH
8038: LD_INT 1
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 23
8047: PUSH
8048: LD_INT 3
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 69
8063: PUSH
8064: LD_LOC 11
8068: DIFF
8069: PPUSH
8070: LD_EXP 7
8074: PPUSH
8075: LD_INT 1
8077: PPUSH
8078: LD_INT 4
8080: PPUSH
8081: LD_INT 0
8083: PPUSH
8084: CALL 10381 0 5
8088: ST_TO_ADDR
// TalkOn ;
8089: CALL 10640 0 0
// Say ( who , DRocket-RSci1-1 ) ;
8093: LD_VAR 0 2
8097: PPUSH
8098: LD_STRING DRocket-RSci1-1
8100: PPUSH
8101: CALL_OW 88
// TalkOff ;
8105: CALL 10656 0 0
// end ;
8109: LD_VAR 0 1
8113: RET
// every 0 0$1 trigger cap_bases >= 4 do
8114: LD_EXP 17
8118: PUSH
8119: LD_INT 4
8121: GREATEREQUAL
8122: IFFALSE 8138
8124: GO 8126
8126: DISABLE
// begin QEnd ;
8127: CALL 8139 0 0
// ChangeMissionObjectives ( MDestroy ) ;
8131: LD_STRING MDestroy
8133: PPUSH
8134: CALL_OW 337
// end ;
8138: END
// export function QEnd ; var qr ; begin
8139: LD_INT 0
8141: PPUSH
8142: PPUSH
// qr := Query ( QKill ) ;
8143: LD_ADDR_VAR 0 2
8147: PUSH
8148: LD_STRING QKill
8150: PPUSH
8151: CALL_OW 97
8155: ST_TO_ADDR
// end ;
8156: LD_VAR 0 1
8160: RET
// export function DEnd ; var who ; begin
8161: LD_INT 0
8163: PPUSH
8164: PPUSH
// who := Gla ;
8165: LD_ADDR_VAR 0 2
8169: PUSH
8170: LD_LOC 1
8174: ST_TO_ADDR
// if not IsOk ( Gla ) then
8175: LD_LOC 1
8179: PPUSH
8180: CALL_OW 302
8184: NOT
8185: IFFALSE 8246
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , 0 , 0 ) ;
8187: LD_ADDR_VAR 0 2
8191: PUSH
8192: LD_INT 21
8194: PUSH
8195: LD_INT 1
8197: PUSH
8198: EMPTY
8199: LIST
8200: LIST
8201: PUSH
8202: LD_INT 23
8204: PUSH
8205: LD_INT 3
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: PPUSH
8216: CALL_OW 69
8220: PUSH
8221: LD_LOC 11
8225: DIFF
8226: PPUSH
8227: LD_EXP 7
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: LD_INT 0
8237: PPUSH
8238: LD_INT 0
8240: PPUSH
8241: CALL 10381 0 5
8245: ST_TO_ADDR
// DialogueOn ;
8246: CALL_OW 6
// Say ( Bur , DEnd-Bur-1 ) ;
8250: LD_LOC 2
8254: PPUSH
8255: LD_STRING DEnd-Bur-1
8257: PPUSH
8258: CALL_OW 88
// if Say ( who , DEnd-Gla-1 ) then
8262: LD_VAR 0 2
8266: PPUSH
8267: LD_STRING DEnd-Gla-1
8269: PPUSH
8270: CALL_OW 88
8274: IFFALSE 8288
// Say ( Bur , DEnd-Bur-2 ) ;
8276: LD_LOC 2
8280: PPUSH
8281: LD_STRING DEnd-Bur-2
8283: PPUSH
8284: CALL_OW 88
// Say ( Bur , DEnd-Bur-2a ) ;
8288: LD_LOC 2
8292: PPUSH
8293: LD_STRING DEnd-Bur-2a
8295: PPUSH
8296: CALL_OW 88
// DialogueOff ;
8300: CALL_OW 7
// end ; end_of_file
8304: LD_VAR 0 1
8308: RET
// export Burlak , Platonov , Gossudarov , Gladkov , Fadeev , Borodin , Tsaritsyn , Davidov , Eisenstein , Gleb ; var masha_def , masha ; var used ; export function Load ; var i ; begin
8309: LD_INT 0
8311: PPUSH
8312: PPUSH
// Masha := LoadVariable ( Masha , [ ] ) ;
8313: LD_ADDR_LOC 14
8317: PUSH
8318: LD_STRING Masha
8320: PPUSH
8321: EMPTY
8322: PPUSH
8323: CALL_OW 30
8327: ST_TO_ADDR
// InitUc ;
8328: CALL_OW 18
// InitHc ;
8332: CALL_OW 19
// uc_nation := nation_russian ;
8336: LD_ADDR_OWVAR 21
8340: PUSH
8341: LD_INT 3
8343: ST_TO_ADDR
// uc_side := ai_s [ 1 ] ;
8344: LD_ADDR_OWVAR 20
8348: PUSH
8349: LD_EXP 23
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
8358: LD_ADDR_EXP 42
8362: PUSH
8363: LD_STRING Platonov
8365: PPUSH
8366: LD_INT 1
8368: PPUSH
8369: LD_INT 1
8371: PPUSH
8372: CALL 8973 0 3
8376: ST_TO_ADDR
// Gossudarov := MyCreateCharacter ( Gossudarov , class_scientistic , false ) ;
8377: LD_ADDR_EXP 43
8381: PUSH
8382: LD_STRING Gossudarov
8384: PPUSH
8385: LD_INT 4
8387: PPUSH
8388: LD_INT 0
8390: PPUSH
8391: CALL 8973 0 3
8395: ST_TO_ADDR
// SetSkill ( Gossudarov , skill_mechanical , gossudarov_mech_skill ) ;
8396: LD_EXP 43
8400: PPUSH
8401: LD_INT 3
8403: PPUSH
8404: LD_EXP 16
8408: PPUSH
8409: CALL_OW 237
// uc_side := ai_s [ 2 ] ;
8413: LD_ADDR_OWVAR 20
8417: PUSH
8418: LD_EXP 23
8422: PUSH
8423: LD_INT 2
8425: ARRAY
8426: ST_TO_ADDR
// Borodin := MyCreateCharacter ( Borodin , 0 , true ) ;
8427: LD_ADDR_EXP 46
8431: PUSH
8432: LD_STRING Borodin
8434: PPUSH
8435: LD_INT 0
8437: PPUSH
8438: LD_INT 1
8440: PPUSH
8441: CALL 8973 0 3
8445: ST_TO_ADDR
// uc_side := ai_s [ 3 ] ;
8446: LD_ADDR_OWVAR 20
8450: PUSH
8451: LD_EXP 23
8455: PUSH
8456: LD_INT 3
8458: ARRAY
8459: ST_TO_ADDR
// Tsaritsyn := MyCreateCharacter ( Tsaritsyn , 0 , true ) ;
8460: LD_ADDR_EXP 47
8464: PUSH
8465: LD_STRING Tsaritsyn
8467: PPUSH
8468: LD_INT 0
8470: PPUSH
8471: LD_INT 1
8473: PPUSH
8474: CALL 8973 0 3
8478: ST_TO_ADDR
// uc_side := ai_s [ 4 ] ;
8479: LD_ADDR_OWVAR 20
8483: PUSH
8484: LD_EXP 23
8488: PUSH
8489: LD_INT 4
8491: ARRAY
8492: ST_TO_ADDR
// Davidov := MyCreateCharacter ( Davidov , class_scientistic , true ) ;
8493: LD_ADDR_EXP 48
8497: PUSH
8498: LD_STRING Davidov
8500: PPUSH
8501: LD_INT 4
8503: PPUSH
8504: LD_INT 1
8506: PPUSH
8507: CALL 8973 0 3
8511: ST_TO_ADDR
// uc_side := ai_s [ 5 ] ;
8512: LD_ADDR_OWVAR 20
8516: PUSH
8517: LD_EXP 23
8521: PUSH
8522: LD_INT 5
8524: ARRAY
8525: ST_TO_ADDR
// Eisenstein := MyCreateCharacter ( Eisenstein , 0 , true ) ;
8526: LD_ADDR_EXP 49
8530: PUSH
8531: LD_STRING Eisenstein
8533: PPUSH
8534: LD_INT 0
8536: PPUSH
8537: LD_INT 1
8539: PPUSH
8540: CALL 8973 0 3
8544: ST_TO_ADDR
// uc_side := you ;
8545: LD_ADDR_OWVAR 20
8549: PUSH
8550: LD_EXP 7
8554: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
8555: LD_ADDR_EXP 41
8559: PUSH
8560: LD_STRING Burlak
8562: PPUSH
8563: LD_INT 3
8565: PPUSH
8566: LD_INT 0
8568: PPUSH
8569: CALL 8973 0 3
8573: ST_TO_ADDR
// Gladkov := MyCreateCharacter ( Gladkov , 0 , true ) ;
8574: LD_ADDR_EXP 44
8578: PUSH
8579: LD_STRING Gladkov
8581: PPUSH
8582: LD_INT 0
8584: PPUSH
8585: LD_INT 1
8587: PPUSH
8588: CALL 8973 0 3
8592: ST_TO_ADDR
// Fadeev := MyCreateCharacter ( Fadeev , 0 , true ) ;
8593: LD_ADDR_EXP 45
8597: PUSH
8598: LD_STRING Fadeev
8600: PPUSH
8601: LD_INT 0
8603: PPUSH
8604: LD_INT 1
8606: PPUSH
8607: CALL 8973 0 3
8611: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , false ) ;
8612: LD_ADDR_EXP 50
8616: PUSH
8617: LD_STRING Gleb
8619: PPUSH
8620: LD_INT 1
8622: PPUSH
8623: LD_INT 0
8625: PPUSH
8626: CALL 8973 0 3
8630: ST_TO_ADDR
// masha_def := LoadVariable ( Masha , [ ] ) ;
8631: LD_ADDR_LOC 13
8635: PUSH
8636: LD_STRING Masha
8638: PPUSH
8639: EMPTY
8640: PPUSH
8641: CALL_OW 30
8645: ST_TO_ADDR
// if masha_def then
8646: LD_LOC 13
8650: IFFALSE 8722
// begin InitVc ;
8652: CALL_OW 20
// vc_chassis := masha_def [ 1 ] ;
8656: LD_ADDR_OWVAR 37
8660: PUSH
8661: LD_LOC 13
8665: PUSH
8666: LD_INT 1
8668: ARRAY
8669: ST_TO_ADDR
// vc_engine := masha_def [ 2 ] ;
8670: LD_ADDR_OWVAR 39
8674: PUSH
8675: LD_LOC 13
8679: PUSH
8680: LD_INT 2
8682: ARRAY
8683: ST_TO_ADDR
// vc_control := masha_def [ 3 ] ;
8684: LD_ADDR_OWVAR 38
8688: PUSH
8689: LD_LOC 13
8693: PUSH
8694: LD_INT 3
8696: ARRAY
8697: ST_TO_ADDR
// vc_weapon := masha_def [ 4 ] ;
8698: LD_ADDR_OWVAR 40
8702: PUSH
8703: LD_LOC 13
8707: PUSH
8708: LD_INT 4
8710: ARRAY
8711: ST_TO_ADDR
// masha := CreateVehicle ;
8712: LD_ADDR_LOC 14
8716: PUSH
8717: CALL_OW 45
8721: ST_TO_ADDR
// end ; used := [ ] ;
8722: LD_ADDR_LOC 15
8726: PUSH
8727: EMPTY
8728: ST_TO_ADDR
// used := [ Gleb ] diff 0 ;
8729: LD_ADDR_LOC 15
8733: PUSH
8734: LD_EXP 50
8738: PUSH
8739: EMPTY
8740: LIST
8741: PUSH
8742: LD_INT 0
8744: DIFF
8745: ST_TO_ADDR
// used := used ^ [ Fadeev , Gladkov ] ;
8746: LD_ADDR_LOC 15
8750: PUSH
8751: LD_LOC 15
8755: PUSH
8756: LD_EXP 45
8760: PUSH
8761: LD_EXP 44
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: ADD
8770: ST_TO_ADDR
// for i := used + 1 to 3 do
8771: LD_ADDR_VAR 0 2
8775: PUSH
8776: DOUBLE
8777: LD_LOC 15
8781: PUSH
8782: LD_INT 1
8784: PLUS
8785: DEC
8786: ST_TO_ADDR
8787: LD_INT 3
8789: PUSH
8790: FOR_TO
8791: IFFALSE 8824
// begin PrepareSoldier ( sex_male , 6 ) ;
8793: LD_INT 1
8795: PPUSH
8796: LD_INT 6
8798: PPUSH
8799: CALL_OW 381
// used := used ^ [ CreateHuman ] ;
8803: LD_ADDR_LOC 15
8807: PUSH
8808: LD_LOC 15
8812: PUSH
8813: CALL_OW 44
8817: PUSH
8818: EMPTY
8819: LIST
8820: ADD
8821: ST_TO_ADDR
// end ;
8822: GO 8790
8824: POP
8825: POP
// used := used ^ [ Burlak ] ;
8826: LD_ADDR_LOC 15
8830: PUSH
8831: LD_LOC 15
8835: PUSH
8836: LD_EXP 41
8840: PUSH
8841: EMPTY
8842: LIST
8843: ADD
8844: ST_TO_ADDR
// end ;
8845: LD_VAR 0 1
8849: RET
// export function place_ru ; var i ; begin
8850: LD_INT 0
8852: PPUSH
8853: PPUSH
// for i in used diff burlak do
8854: LD_ADDR_VAR 0 2
8858: PUSH
8859: LD_LOC 15
8863: PUSH
8864: LD_EXP 41
8868: DIFF
8869: PUSH
8870: FOR_IN
8871: IFFALSE 8890
// PlaceUnitArea ( i , ru_place , false ) ;
8873: LD_VAR 0 2
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 0
8883: PPUSH
8884: CALL_OW 49
8888: GO 8870
8890: POP
8891: POP
// if masha then
8892: LD_LOC 14
8896: IFFALSE 8953
// begin SetMark ( masha , 1 ) ;
8898: LD_LOC 14
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// PlaceHumanInUnit ( Burlak , masha ) ;
8910: LD_EXP 41
8914: PPUSH
8915: LD_LOC 14
8919: PPUSH
8920: CALL_OW 52
// PlaceUnitArea ( masha , ru_place , false ) ;
8924: LD_LOC 14
8928: PPUSH
8929: LD_INT 6
8931: PPUSH
8932: LD_INT 0
8934: PPUSH
8935: CALL_OW 49
// SetMark ( masha , 1 ) ;
8939: LD_LOC 14
8943: PPUSH
8944: LD_INT 1
8946: PPUSH
8947: CALL_OW 242
// end else
8951: GO 8968
// PlaceUnitArea ( Burlak , ru_place , false ) ;
8953: LD_EXP 41
8957: PPUSH
8958: LD_INT 6
8960: PPUSH
8961: LD_INT 0
8963: PPUSH
8964: CALL_OW 49
// end ;
8968: LD_VAR 0 1
8972: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
8973: LD_INT 0
8975: PPUSH
// if ( new and NewCharacter ( name ) ) or TestCharacters ( name ) then
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: PPUSH
8986: CALL_OW 25
8990: AND
8991: PUSH
8992: LD_VAR 0 1
8996: PPUSH
8997: CALL_OW 28
9001: OR
9002: IFFALSE 9085
// begin if new then
9004: LD_VAR 0 3
9008: IFFALSE 9027
// result := NewCharacter ( name ) else
9010: LD_ADDR_VAR 0 4
9014: PUSH
9015: LD_VAR 0 1
9019: PPUSH
9020: CALL_OW 25
9024: ST_TO_ADDR
9025: GO 9063
// begin if CheckCharacterSet ( name ) then
9027: LD_VAR 0 1
9031: PPUSH
9032: CALL_OW 29
9036: IFFALSE 9055
// result := CreateCharacter ( name ) else
9038: LD_ADDR_VAR 0 4
9042: PUSH
9043: LD_VAR 0 1
9047: PPUSH
9048: CALL_OW 34
9052: ST_TO_ADDR
9053: GO 9063
// result := 0 ;
9055: LD_ADDR_VAR 0 4
9059: PUSH
9060: LD_INT 0
9062: ST_TO_ADDR
// end ; if unclass then
9063: LD_VAR 0 2
9067: IFFALSE 9083
// SetClass ( result , unclass ) ;
9069: LD_VAR 0 4
9073: PPUSH
9074: LD_VAR 0 2
9078: PPUSH
9079: CALL_OW 336
// end else
9083: GO 9151
// begin Msg ( Chybi  & name & ! ) ;
9085: LD_STRING Chybi 
9087: PUSH
9088: LD_VAR 0 1
9092: STR
9093: PUSH
9094: LD_STRING !
9096: STR
9097: PPUSH
9098: CALL_OW 100
// hc_name := name ;
9102: LD_ADDR_OWVAR 26
9106: PUSH
9107: LD_VAR 0 1
9111: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
9112: LD_INT 1
9114: PPUSH
9115: LD_INT 0
9117: PPUSH
9118: LD_INT 3
9120: PPUSH
9121: CALL_OW 380
// if unclass then
9125: LD_VAR 0 2
9129: IFFALSE 9141
// hc_class := unclass ;
9131: LD_ADDR_OWVAR 28
9135: PUSH
9136: LD_VAR 0 2
9140: ST_TO_ADDR
// result := CreateHuman ;
9141: LD_ADDR_VAR 0 4
9145: PUSH
9146: CALL_OW 44
9150: ST_TO_ADDR
// end ; end ;
9151: LD_VAR 0 4
9155: RET
// export function Save ; var tmp , Bluekher , t ; begin
9156: LD_INT 0
9158: PPUSH
9159: PPUSH
9160: PPUSH
9161: PPUSH
// SaveCharacters ( Burlak , Burlak ) ;
9162: LD_EXP 41
9166: PPUSH
9167: LD_STRING Burlak
9169: PPUSH
9170: CALL_OW 38
// SaveCharacters ( Gladkov , Gladkov ) ;
9174: LD_EXP 44
9178: PPUSH
9179: LD_STRING Gladkov
9181: PPUSH
9182: CALL_OW 38
// SaveCharacters ( Fadeev , Fadeev ) ;
9186: LD_EXP 45
9190: PPUSH
9191: LD_STRING Fadeev
9193: PPUSH
9194: CALL_OW 38
// DeleteCharacters ( Platonov ) ;
9198: LD_STRING Platonov
9200: PPUSH
9201: CALL_OW 40
// SaveVariable ( not IsLive ( Platonov ) , PlatonovKilled ) ;
9205: LD_EXP 42
9209: PPUSH
9210: CALL_OW 300
9214: NOT
9215: PPUSH
9216: LD_STRING PlatonovKilled
9218: PPUSH
9219: CALL_OW 39
// SaveVariable ( BehemothSeen , BehemothSeen ) ;
9223: LD_EXP 29
9227: PPUSH
9228: LD_STRING BehemothSeen
9230: PPUSH
9231: CALL_OW 39
// if IsDead ( masha ) then
9235: LD_LOC 14
9239: PPUSH
9240: CALL_OW 301
9244: IFFALSE 9253
// DeleteVariable ( Masha ) ;
9246: LD_STRING Masha
9248: PPUSH
9249: CALL_OW 41
// SaveCharacters ( Borodin , Borodin ) ;
9253: LD_EXP 46
9257: PPUSH
9258: LD_STRING Borodin
9260: PPUSH
9261: CALL_OW 38
// SaveCharacters ( Tsaritsyn , Tsaritsyn ) ;
9265: LD_EXP 47
9269: PPUSH
9270: LD_STRING Tsaritsyn
9272: PPUSH
9273: CALL_OW 38
// SaveCharacters ( Davidov , Davidov ) ;
9277: LD_EXP 48
9281: PPUSH
9282: LD_STRING Davidov
9284: PPUSH
9285: CALL_OW 38
// SaveCharacters ( Eisenstein , Eisenstein ) ;
9289: LD_EXP 49
9293: PPUSH
9294: LD_STRING Eisenstein
9296: PPUSH
9297: CALL_OW 38
// if Gleb then
9301: LD_EXP 50
9305: IFFALSE 9319
// SaveCharacters ( Gleb , Gleb ) ;
9307: LD_EXP 50
9311: PPUSH
9312: LD_STRING Gleb
9314: PPUSH
9315: CALL_OW 38
// DeleteCharacters ( Gossudarov ) ;
9319: LD_STRING Gossudarov
9321: PPUSH
9322: CALL_OW 40
// tmp := FilterUnitsInArea ( Bluekher_area , [ [ f_type , unit_building ] ] ) ;
9326: LD_ADDR_VAR 0 2
9330: PUSH
9331: LD_INT 18
9333: PPUSH
9334: LD_INT 21
9336: PUSH
9337: LD_INT 3
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: PPUSH
9347: CALL_OW 70
9351: ST_TO_ADDR
// Bluekher := [ ] ;
9352: LD_ADDR_VAR 0 3
9356: PUSH
9357: EMPTY
9358: ST_TO_ADDR
// for t in tmp do
9359: LD_ADDR_VAR 0 4
9363: PUSH
9364: LD_VAR 0 2
9368: PUSH
9369: FOR_IN
9370: IFFALSE 9757
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
9372: LD_VAR 0 4
9376: PPUSH
9377: CALL_OW 266
9381: PUSH
9382: LD_INT 9
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9426
9388: LD_INT 10
9390: DOUBLE
9391: EQUAL
9392: IFTRUE 9426
9394: LD_INT 13
9396: DOUBLE
9397: EQUAL
9398: IFTRUE 9426
9400: LD_INT 12
9402: DOUBLE
9403: EQUAL
9404: IFTRUE 9426
9406: LD_INT 15
9408: DOUBLE
9409: EQUAL
9410: IFTRUE 9426
9412: LD_INT 11
9414: DOUBLE
9415: EQUAL
9416: IFTRUE 9426
9418: LD_INT 14
9420: DOUBLE
9421: EQUAL
9422: IFTRUE 9426
9424: GO 9429
9426: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
9427: GO 9755
9429: LD_INT 6
9431: DOUBLE
9432: EQUAL
9433: IFTRUE 9449
9435: LD_INT 7
9437: DOUBLE
9438: EQUAL
9439: IFTRUE 9449
9441: LD_INT 8
9443: DOUBLE
9444: EQUAL
9445: IFTRUE 9449
9447: GO 9562
9449: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , getlabkind ( t , 1 ) , getlabkind ( t , 2 ) ] ] ; b_bunker , b_turret :
9450: LD_ADDR_VAR 0 3
9454: PUSH
9455: LD_VAR 0 3
9459: PUSH
9460: LD_VAR 0 4
9464: PPUSH
9465: CALL_OW 250
9469: PUSH
9470: LD_VAR 0 4
9474: PPUSH
9475: CALL_OW 251
9479: PUSH
9480: LD_VAR 0 4
9484: PPUSH
9485: CALL_OW 254
9489: PUSH
9490: LD_VAR 0 4
9494: PPUSH
9495: CALL_OW 266
9499: PUSH
9500: LD_VAR 0 4
9504: PPUSH
9505: CALL_OW 267
9509: PUSH
9510: LD_VAR 0 4
9514: PPUSH
9515: CALL_OW 248
9519: PUSH
9520: LD_VAR 0 4
9524: PPUSH
9525: LD_INT 1
9527: PPUSH
9528: CALL_OW 268
9532: PUSH
9533: LD_VAR 0 4
9537: PPUSH
9538: LD_INT 2
9540: PPUSH
9541: CALL_OW 268
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: LIST
9554: LIST
9555: PUSH
9556: EMPTY
9557: LIST
9558: ADD
9559: ST_TO_ADDR
9560: GO 9755
9562: LD_INT 32
9564: DOUBLE
9565: EQUAL
9566: IFTRUE 9576
9568: LD_INT 33
9570: DOUBLE
9571: EQUAL
9572: IFTRUE 9576
9574: GO 9672
9576: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , GetWeapon ( t ) ] ] ; else
9577: LD_ADDR_VAR 0 3
9581: PUSH
9582: LD_VAR 0 3
9586: PUSH
9587: LD_VAR 0 4
9591: PPUSH
9592: CALL_OW 250
9596: PUSH
9597: LD_VAR 0 4
9601: PPUSH
9602: CALL_OW 251
9606: PUSH
9607: LD_VAR 0 4
9611: PPUSH
9612: CALL_OW 254
9616: PUSH
9617: LD_VAR 0 4
9621: PPUSH
9622: CALL_OW 266
9626: PUSH
9627: LD_VAR 0 4
9631: PPUSH
9632: CALL_OW 267
9636: PUSH
9637: LD_VAR 0 4
9641: PPUSH
9642: CALL_OW 248
9646: PUSH
9647: LD_VAR 0 4
9651: PPUSH
9652: CALL_OW 264
9656: PUSH
9657: EMPTY
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: ADD
9669: ST_TO_ADDR
9670: GO 9755
9672: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) ] ] ; end ;
9673: LD_ADDR_VAR 0 3
9677: PUSH
9678: LD_VAR 0 3
9682: PUSH
9683: LD_VAR 0 4
9687: PPUSH
9688: CALL_OW 250
9692: PUSH
9693: LD_VAR 0 4
9697: PPUSH
9698: CALL_OW 251
9702: PUSH
9703: LD_VAR 0 4
9707: PPUSH
9708: CALL_OW 254
9712: PUSH
9713: LD_VAR 0 4
9717: PPUSH
9718: CALL_OW 266
9722: PUSH
9723: LD_VAR 0 4
9727: PPUSH
9728: CALL_OW 267
9732: PUSH
9733: LD_VAR 0 4
9737: PPUSH
9738: CALL_OW 248
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: LIST
9747: LIST
9748: LIST
9749: LIST
9750: PUSH
9751: EMPTY
9752: LIST
9753: ADD
9754: ST_TO_ADDR
// end ;
9755: GO 9369
9757: POP
9758: POP
// SaveVariable ( Bluekher , Bluekher ) ;
9759: LD_VAR 0 3
9763: PPUSH
9764: LD_STRING Bluekher
9766: PPUSH
9767: CALL_OW 39
// if CheckCharacterSet ( survivors3 ) then
9771: LD_STRING survivors3
9773: PPUSH
9774: CALL_OW 29
9778: IFFALSE 9805
// begin tmp = CreateCharacterSet ( survivors3 ) ;
9780: LD_ADDR_VAR 0 2
9784: PUSH
9785: LD_STRING survivors3
9787: PPUSH
9788: CALL_OW 31
9792: ST_TO_ADDR
// SaveCharacters ( tmp , survivors4 ) ;
9793: LD_VAR 0 2
9797: PPUSH
9798: LD_STRING survivors4
9800: PPUSH
9801: CALL_OW 38
// end ; end ; end_of_file
9805: LD_VAR 0 1
9809: RET
// export mf_sol ; export mf_eng ; export mf_mec ; export mf_sci ; export mf_lab ; export mf_fort ; export mf_bunk ; export mf_dep ; export mf_fact ; export mf_comp ; export mf_manu ; export function inicializace_functions ; begin
9810: LD_INT 0
9812: PPUSH
// mf_sol := [ f_class , class_soldier ] ;
9813: LD_ADDR_EXP 51
9817: PUSH
9818: LD_INT 25
9820: PUSH
9821: LD_INT 1
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: ST_TO_ADDR
// mf_eng := [ f_class , class_engineer ] ;
9828: LD_ADDR_EXP 52
9832: PUSH
9833: LD_INT 25
9835: PUSH
9836: LD_INT 2
9838: PUSH
9839: EMPTY
9840: LIST
9841: LIST
9842: ST_TO_ADDR
// mf_mec := [ f_class , class_mechanic ] ;
9843: LD_ADDR_EXP 53
9847: PUSH
9848: LD_INT 25
9850: PUSH
9851: LD_INT 3
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: ST_TO_ADDR
// mf_sci := [ f_class , class_scientistic ] ;
9858: LD_ADDR_EXP 54
9862: PUSH
9863: LD_INT 25
9865: PUSH
9866: LD_INT 4
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: ST_TO_ADDR
// mf_lab := [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ;
9873: LD_ADDR_EXP 55
9877: PUSH
9878: LD_INT 2
9880: PUSH
9881: LD_INT 30
9883: PUSH
9884: LD_INT 6
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: PUSH
9891: LD_INT 30
9893: PUSH
9894: LD_INT 7
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PUSH
9901: LD_INT 30
9903: PUSH
9904: LD_INT 8
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: LIST
9915: LIST
9916: ST_TO_ADDR
// mf_fort := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ;
9917: LD_ADDR_EXP 56
9921: PUSH
9922: LD_INT 2
9924: PUSH
9925: LD_INT 30
9927: PUSH
9928: LD_INT 32
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PUSH
9935: LD_INT 30
9937: PUSH
9938: LD_INT 31
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PUSH
9945: LD_INT 30
9947: PUSH
9948: LD_INT 4
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: PUSH
9955: LD_INT 30
9957: PUSH
9958: LD_INT 5
9960: PUSH
9961: EMPTY
9962: LIST
9963: LIST
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: ST_TO_ADDR
// mf_bunk := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ;
9972: LD_ADDR_EXP 57
9976: PUSH
9977: LD_INT 2
9979: PUSH
9980: LD_INT 30
9982: PUSH
9983: LD_INT 32
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 30
9992: PUSH
9993: LD_INT 31
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: ST_TO_ADDR
// mf_dep := [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ;
10005: LD_ADDR_EXP 58
10009: PUSH
10010: LD_INT 2
10012: PUSH
10013: LD_INT 30
10015: PUSH
10016: LD_INT 0
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PUSH
10023: LD_INT 30
10025: PUSH
10026: LD_INT 1
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: LIST
10037: ST_TO_ADDR
// mf_fact := [ f_or , [ f_btype , b_factory ] , [ f_btype , b_workshop ] ] ;
10038: LD_ADDR_EXP 59
10042: PUSH
10043: LD_INT 2
10045: PUSH
10046: LD_INT 30
10048: PUSH
10049: LD_INT 3
10051: PUSH
10052: EMPTY
10053: LIST
10054: LIST
10055: PUSH
10056: LD_INT 30
10058: PUSH
10059: LD_INT 2
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: EMPTY
10067: LIST
10068: LIST
10069: LIST
10070: ST_TO_ADDR
// mf_comp := [ f_control , control_computer ] ;
10071: LD_ADDR_EXP 60
10075: PUSH
10076: LD_INT 33
10078: PUSH
10079: LD_INT 3
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: ST_TO_ADDR
// mf_manu := [ f_control , control_manual ] ;
10086: LD_ADDR_EXP 61
10090: PUSH
10091: LD_INT 33
10093: PUSH
10094: LD_INT 1
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: ST_TO_ADDR
// end ;
10101: LD_VAR 0 1
10105: RET
// export function get_x_best ( lidi , num , skill , mclass , idle ) ; var i , skills ; begin
10106: LD_INT 0
10108: PPUSH
10109: PPUSH
10110: PPUSH
// if mclass then
10111: LD_VAR 0 4
10115: IFFALSE 10147
// lidi := UnitFilter ( lidi , [ [ f_class , mclass ] ] ) ;
10117: LD_ADDR_VAR 0 1
10121: PUSH
10122: LD_VAR 0 1
10126: PPUSH
10127: LD_INT 25
10129: PUSH
10130: LD_VAR 0 4
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: PUSH
10139: EMPTY
10140: LIST
10141: PPUSH
10142: CALL_OW 72
10146: ST_TO_ADDR
// skills := [ ] ;
10147: LD_ADDR_VAR 0 8
10151: PUSH
10152: EMPTY
10153: ST_TO_ADDR
// for i in lidi do
10154: LD_ADDR_VAR 0 7
10158: PUSH
10159: LD_VAR 0 1
10163: PUSH
10164: FOR_IN
10165: IFFALSE 10198
// skills := skills ^ [ GetSkill ( i , skill ) ] ;
10167: LD_ADDR_VAR 0 8
10171: PUSH
10172: LD_VAR 0 8
10176: PUSH
10177: LD_VAR 0 7
10181: PPUSH
10182: LD_VAR 0 3
10186: PPUSH
10187: CALL_OW 259
10191: PUSH
10192: EMPTY
10193: LIST
10194: ADD
10195: ST_TO_ADDR
10196: GO 10164
10198: POP
10199: POP
// lidi := SortListByListDesc ( lidi , skills ) ;
10200: LD_ADDR_VAR 0 1
10204: PUSH
10205: LD_VAR 0 1
10209: PPUSH
10210: LD_VAR 0 8
10214: PPUSH
10215: CALL_OW 77
10219: ST_TO_ADDR
// if num > lidi then
10220: LD_VAR 0 2
10224: PUSH
10225: LD_VAR 0 1
10229: GREATER
10230: IFFALSE 10246
// num := lidi + 0 ;
10232: LD_ADDR_VAR 0 2
10236: PUSH
10237: LD_VAR 0 1
10241: PUSH
10242: LD_INT 0
10244: PLUS
10245: ST_TO_ADDR
// i := 1 ;
10246: LD_ADDR_VAR 0 7
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// result := [ ] ;
10254: LD_ADDR_VAR 0 6
10258: PUSH
10259: EMPTY
10260: ST_TO_ADDR
// while i <= lidi and result < num do
10261: LD_VAR 0 7
10265: PUSH
10266: LD_VAR 0 1
10270: LESSEQUAL
10271: PUSH
10272: LD_VAR 0 6
10276: PUSH
10277: LD_VAR 0 2
10281: LESS
10282: AND
10283: IFFALSE 10376
// begin if idle then
10285: LD_VAR 0 5
10289: IFFALSE 10335
// begin if IsIdle ( lidi [ i ] ) then
10291: LD_VAR 0 1
10295: PUSH
10296: LD_VAR 0 7
10300: ARRAY
10301: PPUSH
10302: CALL_OW 316
10306: IFFALSE 10333
// result := result ^ [ lidi [ i ] ] ;
10308: LD_ADDR_VAR 0 6
10312: PUSH
10313: LD_VAR 0 6
10317: PUSH
10318: LD_VAR 0 1
10322: PUSH
10323: LD_VAR 0 7
10327: ARRAY
10328: PUSH
10329: EMPTY
10330: LIST
10331: ADD
10332: ST_TO_ADDR
// end else
10333: GO 10360
// result := result ^ [ lidi [ i ] ] ;
10335: LD_ADDR_VAR 0 6
10339: PUSH
10340: LD_VAR 0 6
10344: PUSH
10345: LD_VAR 0 1
10349: PUSH
10350: LD_VAR 0 7
10354: ARRAY
10355: PUSH
10356: EMPTY
10357: LIST
10358: ADD
10359: ST_TO_ADDR
// i := i + 1 ;
10360: LD_ADDR_VAR 0 7
10364: PUSH
10365: LD_VAR 0 7
10369: PUSH
10370: LD_INT 1
10372: PLUS
10373: ST_TO_ADDR
// end ;
10374: GO 10261
// end ;
10376: LD_VAR 0 6
10380: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
10381: LD_INT 0
10383: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_VAR 0 1
10393: PPUSH
10394: LD_INT 21
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 22
10406: PUSH
10407: LD_VAR 0 2
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 3
10418: PUSH
10419: LD_INT 23
10421: PUSH
10422: LD_INT 0
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: EMPTY
10430: LIST
10431: LIST
10432: LIST
10433: LIST
10434: PPUSH
10435: CALL_OW 72
10439: ST_TO_ADDR
// if sex <> 0 then
10440: LD_VAR 0 3
10444: PUSH
10445: LD_INT 0
10447: NONEQUAL
10448: IFFALSE 10477
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
10450: LD_ADDR_VAR 0 1
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: LD_INT 26
10462: PUSH
10463: LD_VAR 0 3
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PPUSH
10472: CALL_OW 72
10476: ST_TO_ADDR
// if Hclass <> 0 then
10477: LD_VAR 0 4
10481: PUSH
10482: LD_INT 0
10484: NONEQUAL
10485: IFFALSE 10514
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
10487: LD_ADDR_VAR 0 1
10491: PUSH
10492: LD_VAR 0 1
10496: PPUSH
10497: LD_INT 25
10499: PUSH
10500: LD_VAR 0 4
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PPUSH
10509: CALL_OW 72
10513: ST_TO_ADDR
// if index <= 0 then
10514: LD_VAR 0 5
10518: PUSH
10519: LD_INT 0
10521: LESSEQUAL
10522: IFFALSE 10532
// index := 1 ;
10524: LD_ADDR_VAR 0 5
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// if lidi >= index then
10532: LD_VAR 0 1
10536: PUSH
10537: LD_VAR 0 5
10541: GREATEREQUAL
10542: IFFALSE 10562
// result := lidi [ index ] else
10544: LD_ADDR_VAR 0 6
10548: PUSH
10549: LD_VAR 0 1
10553: PUSH
10554: LD_VAR 0 5
10558: ARRAY
10559: ST_TO_ADDR
10560: GO 10570
// result := 0 ;
10562: LD_ADDR_VAR 0 6
10566: PUSH
10567: LD_INT 0
10569: ST_TO_ADDR
// end ;
10570: LD_VAR 0 6
10574: RET
// export function see_any ( strana , sez ) ; var i ; begin
10575: LD_INT 0
10577: PPUSH
10578: PPUSH
// result := [ ] ;
10579: LD_ADDR_VAR 0 3
10583: PUSH
10584: EMPTY
10585: ST_TO_ADDR
// for i in sez do
10586: LD_ADDR_VAR 0 4
10590: PUSH
10591: LD_VAR 0 2
10595: PUSH
10596: FOR_IN
10597: IFFALSE 10633
// if See ( strana , i ) then
10599: LD_VAR 0 1
10603: PPUSH
10604: LD_VAR 0 4
10608: PPUSH
10609: CALL_OW 292
10613: IFFALSE 10631
// begin result := result ^ i ;
10615: LD_ADDR_VAR 0 3
10619: PUSH
10620: LD_VAR 0 3
10624: PUSH
10625: LD_VAR 0 4
10629: ADD
10630: ST_TO_ADDR
// end ;
10631: GO 10596
10633: POP
10634: POP
// ; end ;
10635: LD_VAR 0 3
10639: RET
// export function TalkOn ; begin
10640: LD_INT 0
10642: PPUSH
// stop_talking := true ;
10643: LD_ADDR_OWVAR 56
10647: PUSH
10648: LD_INT 1
10650: ST_TO_ADDR
// end ;
10651: LD_VAR 0 1
10655: RET
// export function TalkOff ; begin
10656: LD_INT 0
10658: PPUSH
// stop_talking := false ;
10659: LD_ADDR_OWVAR 56
10663: PUSH
10664: LD_INT 0
10666: ST_TO_ADDR
// end ;
10667: LD_VAR 0 1
10671: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
10672: LD_INT 0
10674: PPUSH
10675: PPUSH
10676: PPUSH
// result := [ ] ;
10677: LD_ADDR_VAR 0 3
10681: PUSH
10682: EMPTY
10683: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ f_side , you ] ) ;
10684: LD_ADDR_VAR 0 4
10688: PUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 22
10696: PUSH
10697: LD_EXP 7
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: PPUSH
10706: CALL_OW 70
10710: ST_TO_ADDR
// for i in inbase do
10711: LD_ADDR_VAR 0 5
10715: PUSH
10716: LD_VAR 0 4
10720: PUSH
10721: FOR_IN
10722: IFFALSE 10795
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
10724: LD_VAR 0 5
10728: PPUSH
10729: CALL_OW 247
10733: PUSH
10734: LD_INT 3
10736: EQUAL
10737: PUSH
10738: LD_VAR 0 5
10742: PPUSH
10743: CALL_OW 247
10747: PUSH
10748: LD_INT 2
10750: EQUAL
10751: OR
10752: IFFALSE 10777
// begin result := result ^ UnitsInside ( i ) ;
10754: LD_ADDR_VAR 0 3
10758: PUSH
10759: LD_VAR 0 3
10763: PUSH
10764: LD_VAR 0 5
10768: PPUSH
10769: CALL_OW 313
10773: ADD
10774: ST_TO_ADDR
// end else
10775: GO 10793
// begin result := result ^ i ;
10777: LD_ADDR_VAR 0 3
10781: PUSH
10782: LD_VAR 0 3
10786: PUSH
10787: LD_VAR 0 5
10791: ADD
10792: ST_TO_ADDR
// end ; end ;
10793: GO 10721
10795: POP
10796: POP
// result := UnitFilter ( result , filter ) ;
10797: LD_ADDR_VAR 0 3
10801: PUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 2
10811: PPUSH
10812: CALL_OW 72
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 3
10821: RET
// export function inside_units ( uns ) ; var i ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
// result := [ ] ;
10826: LD_ADDR_VAR 0 2
10830: PUSH
10831: EMPTY
10832: ST_TO_ADDR
// for i in uns do
10833: LD_ADDR_VAR 0 3
10837: PUSH
10838: LD_VAR 0 1
10842: PUSH
10843: FOR_IN
10844: IFFALSE 10869
// result := result ^ UnitsInside ( i ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_VAR 0 2
10855: PUSH
10856: LD_VAR 0 3
10860: PPUSH
10861: CALL_OW 313
10865: ADD
10866: ST_TO_ADDR
10867: GO 10843
10869: POP
10870: POP
// end ;
10871: LD_VAR 0 2
10875: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
10876: LD_INT 0
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
10882: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
10883: LD_ADDR_VAR 0 1
10887: PUSH
10888: LD_VAR 0 1
10892: PPUSH
10893: LD_INT 51
10895: PUSH
10896: EMPTY
10897: LIST
10898: PPUSH
10899: CALL_OW 72
10903: PUSH
10904: EMPTY
10905: UNION
10906: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
10907: LD_ADDR_VAR 0 2
10911: PUSH
10912: LD_VAR 0 2
10916: PPUSH
10917: LD_INT 51
10919: PUSH
10920: EMPTY
10921: LIST
10922: PPUSH
10923: CALL_OW 72
10927: PUSH
10928: EMPTY
10929: UNION
10930: ST_TO_ADDR
// for i in cars do
10931: LD_ADDR_VAR 0 7
10935: PUSH
10936: LD_VAR 0 1
10940: PUSH
10941: FOR_IN
10942: IFFALSE 10977
// if not IsDrivenBy ( i ) then
10944: LD_VAR 0 7
10948: PPUSH
10949: CALL_OW 311
10953: NOT
10954: IFFALSE 10975
// empty := empty ^ [ i ] ;
10956: LD_ADDR_VAR 0 5
10960: PUSH
10961: LD_VAR 0 5
10965: PUSH
10966: LD_VAR 0 7
10970: PUSH
10971: EMPTY
10972: LIST
10973: ADD
10974: ST_TO_ADDR
10975: GO 10941
10977: POP
10978: POP
// if take_out then
10979: LD_VAR 0 3
10983: IFFALSE 11041
// begin for i in drivers do
10985: LD_ADDR_VAR 0 7
10989: PUSH
10990: LD_VAR 0 2
10994: PUSH
10995: FOR_IN
10996: IFFALSE 11037
// if not ( IsInUnit ( i ) in cars ) then
10998: LD_VAR 0 7
11002: PPUSH
11003: CALL_OW 310
11007: PUSH
11008: LD_VAR 0 1
11012: IN
11013: NOT
11014: IFFALSE 11035
// free := free ^ [ i ] ;
11016: LD_ADDR_VAR 0 6
11020: PUSH
11021: LD_VAR 0 6
11025: PUSH
11026: LD_VAR 0 7
11030: PUSH
11031: EMPTY
11032: LIST
11033: ADD
11034: ST_TO_ADDR
11035: GO 10995
11037: POP
11038: POP
// end else
11039: GO 11089
// begin for i in drivers do
11041: LD_ADDR_VAR 0 7
11045: PUSH
11046: LD_VAR 0 2
11050: PUSH
11051: FOR_IN
11052: IFFALSE 11087
// if not IsInUnit ( i ) then
11054: LD_VAR 0 7
11058: PPUSH
11059: CALL_OW 310
11063: NOT
11064: IFFALSE 11085
// free := free ^ [ i ] ;
11066: LD_ADDR_VAR 0 6
11070: PUSH
11071: LD_VAR 0 6
11075: PUSH
11076: LD_VAR 0 7
11080: PUSH
11081: EMPTY
11082: LIST
11083: ADD
11084: ST_TO_ADDR
11085: GO 11051
11087: POP
11088: POP
// end ; result := cars diff empty ;
11089: LD_ADDR_VAR 0 4
11093: PUSH
11094: LD_VAR 0 1
11098: PUSH
11099: LD_VAR 0 5
11103: DIFF
11104: ST_TO_ADDR
// if empty <= free then
11105: LD_VAR 0 5
11109: PUSH
11110: LD_VAR 0 6
11114: LESSEQUAL
11115: IFFALSE 11129
// konec := empty else
11117: LD_ADDR_VAR 0 8
11121: PUSH
11122: LD_VAR 0 5
11126: ST_TO_ADDR
11127: GO 11139
// konec := free ;
11129: LD_ADDR_VAR 0 8
11133: PUSH
11134: LD_VAR 0 6
11138: ST_TO_ADDR
// for i := 1 to konec do
11139: LD_ADDR_VAR 0 7
11143: PUSH
11144: DOUBLE
11145: LD_INT 1
11147: DEC
11148: ST_TO_ADDR
11149: LD_VAR 0 8
11153: PUSH
11154: FOR_TO
11155: IFFALSE 11210
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
11157: LD_VAR 0 6
11161: PUSH
11162: LD_VAR 0 7
11166: ARRAY
11167: PPUSH
11168: LD_VAR 0 5
11172: PUSH
11173: LD_VAR 0 7
11177: ARRAY
11178: PPUSH
11179: CALL_OW 120
// result := result ^ [ empty [ i ] ] ;
11183: LD_ADDR_VAR 0 4
11187: PUSH
11188: LD_VAR 0 4
11192: PUSH
11193: LD_VAR 0 5
11197: PUSH
11198: LD_VAR 0 7
11202: ARRAY
11203: PUSH
11204: EMPTY
11205: LIST
11206: ADD
11207: ST_TO_ADDR
// end ;
11208: GO 11154
11210: POP
11211: POP
// end ;
11212: LD_VAR 0 4
11216: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
11217: LD_INT 0
11219: PPUSH
11220: PPUSH
11221: PPUSH
// while remotes > mechs do
11222: LD_VAR 0 3
11226: PUSH
11227: LD_VAR 0 2
11231: GREATER
11232: IFFALSE 11248
// delete ( remotes , 1 ) ;
11234: LD_VAR 0 3
11238: PPUSH
11239: LD_INT 1
11241: PPUSH
11242: CALL_OW 3
11246: GO 11222
// for i := 1 to remotes do
11248: LD_ADDR_VAR 0 6
11252: PUSH
11253: DOUBLE
11254: LD_INT 1
11256: DEC
11257: ST_TO_ADDR
11258: LD_VAR 0 3
11262: PUSH
11263: FOR_TO
11264: IFFALSE 11294
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
11266: LD_VAR 0 2
11270: PUSH
11271: LD_VAR 0 6
11275: ARRAY
11276: PPUSH
11277: LD_VAR 0 3
11281: PUSH
11282: LD_VAR 0 6
11286: ARRAY
11287: PPUSH
11288: CALL_OW 120
11292: GO 11263
11294: POP
11295: POP
// end ;
11296: LD_VAR 0 4
11300: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
11301: LD_INT 0
11303: PPUSH
11304: PPUSH
11305: PPUSH
11306: PPUSH
// c := tick + cas ;
11307: LD_ADDR_VAR 0 5
11311: PUSH
11312: LD_OWVAR 1
11316: PUSH
11317: LD_VAR 0 3
11321: PLUS
11322: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
11323: LD_OWVAR 1
11327: PUSH
11328: LD_VAR 0 5
11332: LESS
11333: PUSH
11334: LD_VAR 0 2
11338: PPUSH
11339: CALL 10822 0 1
11343: PUSH
11344: LD_INT 0
11346: PLUS
11347: PUSH
11348: LD_VAR 0 2
11352: EQUAL
11353: NOT
11354: AND
11355: IFFALSE 11366
// wait ( 0 0$1 ) ;
11357: LD_INT 35
11359: PPUSH
11360: CALL_OW 67
11364: GO 11323
// unlinked := cars ;
11366: LD_ADDR_VAR 0 6
11370: PUSH
11371: LD_VAR 0 1
11375: ST_TO_ADDR
// for i in remotes do
11376: LD_ADDR_VAR 0 7
11380: PUSH
11381: LD_VAR 0 2
11385: PUSH
11386: FOR_IN
11387: IFFALSE 11436
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
11389: LD_VAR 0 6
11393: PPUSH
11394: LD_VAR 0 7
11398: PPUSH
11399: CALL_OW 313
11403: PPUSH
11404: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
11408: LD_ADDR_VAR 0 6
11412: PUSH
11413: LD_VAR 0 6
11417: PUSH
11418: LD_VAR 0 7
11422: PPUSH
11423: CALL_OW 313
11427: PPUSH
11428: CALL_OW 432
11432: DIFF
11433: ST_TO_ADDR
// end ;
11434: GO 11386
11436: POP
11437: POP
// end ;
11438: LD_VAR 0 4
11442: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , k , pockat ; begin
11443: LD_INT 0
11445: PPUSH
11446: PPUSH
11447: PPUSH
11448: PPUSH
11449: PPUSH
// k := 0 ;
11450: LD_ADDR_VAR 0 6
11454: PUSH
11455: LD_INT 0
11457: ST_TO_ADDR
// pockat := tick + cas ;
11458: LD_ADDR_VAR 0 7
11462: PUSH
11463: LD_OWVAR 1
11467: PUSH
11468: LD_VAR 0 2
11472: PLUS
11473: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
11474: LD_VAR 0 5
11478: NOT
11479: PUSH
11480: LD_OWVAR 1
11484: PUSH
11485: LD_VAR 0 7
11489: LESS
11490: AND
11491: IFFALSE 11561
// begin vsichni_ready := true ;
11493: LD_ADDR_VAR 0 5
11497: PUSH
11498: LD_INT 1
11500: ST_TO_ADDR
// k := k + 1 ;
11501: LD_ADDR_VAR 0 6
11505: PUSH
11506: LD_VAR 0 6
11510: PUSH
11511: LD_INT 1
11513: PLUS
11514: ST_TO_ADDR
// for i in cars do
11515: LD_ADDR_VAR 0 4
11519: PUSH
11520: LD_VAR 0 1
11524: PUSH
11525: FOR_IN
11526: IFFALSE 11550
// if not IsDrivenBy ( i ) then
11528: LD_VAR 0 4
11532: PPUSH
11533: CALL_OW 311
11537: NOT
11538: IFFALSE 11548
// vsichni_ready := false ;
11540: LD_ADDR_VAR 0 5
11544: PUSH
11545: LD_INT 0
11547: ST_TO_ADDR
11548: GO 11525
11550: POP
11551: POP
// wait ( 0 0$1.0 ) ;
11552: LD_INT 35
11554: PPUSH
11555: CALL_OW 67
// end ;
11559: GO 11474
// end ;
11561: LD_VAR 0 3
11565: RET
// export function rev ( list ) ; var i ; begin
11566: LD_INT 0
11568: PPUSH
11569: PPUSH
// for i := list + 0 to 1 do
11570: LD_ADDR_VAR 0 3
11574: PUSH
11575: DOUBLE
11576: LD_VAR 0 1
11580: PUSH
11581: LD_INT 0
11583: PLUS
11584: DEC
11585: ST_TO_ADDR
11586: LD_INT 1
11588: PUSH
11589: FOR_TO
11590: IFFALSE 11619
// result := result ^ [ list [ i ] ] ;
11592: LD_ADDR_VAR 0 2
11596: PUSH
11597: LD_VAR 0 2
11601: PUSH
11602: LD_VAR 0 1
11606: PUSH
11607: LD_VAR 0 3
11611: ARRAY
11612: PUSH
11613: EMPTY
11614: LIST
11615: ADD
11616: ST_TO_ADDR
11617: GO 11589
11619: POP
11620: POP
// end ; end_of_file
11621: LD_VAR 0 2
11625: RET
// export under_attack ; export near_base_area ; export function inicializace_ai_defend ; begin
11626: LD_INT 0
11628: PPUSH
// under_attack := [ false , false , false , false , false ] ;
11629: LD_ADDR_EXP 62
11633: PUSH
11634: LD_INT 0
11636: PUSH
11637: LD_INT 0
11639: PUSH
11640: LD_INT 0
11642: PUSH
11643: LD_INT 0
11645: PUSH
11646: LD_INT 0
11648: PUSH
11649: EMPTY
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: ST_TO_ADDR
// near_base_area := [ nearA , nearB , nearC , nearD , nearE ] ;
11656: LD_ADDR_EXP 63
11660: PUSH
11661: LD_INT 24
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 26
11669: PUSH
11670: LD_INT 27
11672: PUSH
11673: LD_INT 28
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: ST_TO_ADDR
// end ;
11683: LD_VAR 0 1
11687: RET
// export BehMcRegId , BehMcAttId ; export function BehemothUtok ; begin
11688: LD_INT 0
11690: PPUSH
// if GetSide ( behemoth ) = you then
11691: LD_INT 125
11693: PPUSH
11694: CALL_OW 255
11698: PUSH
11699: LD_EXP 7
11703: EQUAL
11704: IFFALSE 11708
// exit ;
11706: GO 11874
// BehMcRegId := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11708: LD_ADDR_EXP 64
11712: PUSH
11713: LD_EXP 23
11717: PUSH
11718: LD_INT 1
11720: ARRAY
11721: PPUSH
11722: LD_INT 1
11724: PUSH
11725: LD_INT 140
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: PUSH
11732: LD_INT 4
11734: PUSH
11735: LD_EXP 42
11739: PUSH
11740: EMPTY
11741: LIST
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PUSH
11747: LD_INT 10
11749: PUSH
11750: LD_EXP 41
11754: PUSH
11755: EMPTY
11756: LIST
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 3
11764: PUSH
11765: LD_EXP 63
11769: PUSH
11770: LD_EXP 25
11774: ARRAY
11775: PUSH
11776: EMPTY
11777: LIST
11778: LIST
11779: PUSH
11780: LD_INT 7
11782: PUSH
11783: LD_INT 8
11785: NEG
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: PPUSH
11795: CALL_OW 399
11799: ST_TO_ADDR
// BehMcAttId := McAttack ( 12 , BehMcRegId , [ behemoth ] , [ [ mc_retreat_area_vehicles , nearA ] , [ mc_retreat_area_people , nearA ] , [ mc_retreat_lives_vehicles , 600 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11800: LD_ADDR_EXP 65
11804: PUSH
11805: LD_INT 12
11807: PPUSH
11808: LD_EXP 64
11812: PPUSH
11813: LD_INT 125
11815: PUSH
11816: EMPTY
11817: LIST
11818: PPUSH
11819: LD_INT 8
11821: PUSH
11822: LD_INT 24
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 7
11831: PUSH
11832: LD_INT 24
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 6
11841: PUSH
11842: LD_INT 600
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 5
11851: PUSH
11852: LD_INT 800
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: LD_INT 10
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 402
11873: ST_TO_ADDR
// end ;
11874: LD_VAR 0 1
11878: RET
// export ZouMcRegId , ZouMcAttId ; export function ZoufalUtok ; begin
11879: LD_INT 0
11881: PPUSH
// ZouMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11882: LD_ADDR_EXP 66
11886: PUSH
11887: LD_EXP 23
11891: PUSH
11892: LD_EXP 25
11896: ARRAY
11897: PPUSH
11898: LD_INT 1
11900: PUSH
11901: LD_INT 140
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 4
11910: PUSH
11911: LD_EXP 42
11915: PUSH
11916: EMPTY
11917: LIST
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PUSH
11923: LD_INT 10
11925: PUSH
11926: LD_EXP 41
11930: PUSH
11931: EMPTY
11932: LIST
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_INT 3
11940: PUSH
11941: LD_EXP 63
11945: PUSH
11946: LD_EXP 25
11950: ARRAY
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 7
11958: PUSH
11959: LD_INT 8
11961: NEG
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: PPUSH
11971: CALL_OW 399
11975: ST_TO_ADDR
// ZouMcAttId := McAttack ( 12 , ZouMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11976: LD_ADDR_EXP 67
11980: PUSH
11981: LD_INT 12
11983: PPUSH
11984: LD_EXP 66
11988: PPUSH
11989: LD_EXP 77
11993: PUSH
11994: LD_EXP 25
11998: ARRAY
11999: PPUSH
12000: LD_INT 8
12002: PUSH
12003: LD_EXP 63
12007: PUSH
12008: LD_EXP 25
12012: ARRAY
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 7
12020: PUSH
12021: LD_EXP 63
12025: PUSH
12026: LD_EXP 25
12030: ARRAY
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: LD_INT 6
12038: PUSH
12039: LD_INT 100
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 5
12048: PUSH
12049: LD_INT 800
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: LD_INT 10
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: LIST
12063: LIST
12064: LIST
12065: PPUSH
12066: CALL_OW 402
12070: ST_TO_ADDR
// end ;
12071: LD_VAR 0 1
12075: RET
// export NorMcRegId , NorMcAttId ; export function NormalUtok ; begin
12076: LD_INT 0
12078: PPUSH
// NorMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ your_humans ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
12079: LD_ADDR_EXP 68
12083: PUSH
12084: LD_EXP 23
12088: PUSH
12089: LD_EXP 25
12093: ARRAY
12094: PPUSH
12095: LD_INT 1
12097: PUSH
12098: LD_INT 140
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 4
12107: PUSH
12108: LD_EXP 42
12112: PUSH
12113: EMPTY
12114: LIST
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PUSH
12120: LD_INT 10
12122: PUSH
12123: LD_EXP 37
12127: PUSH
12128: EMPTY
12129: LIST
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 3
12137: PUSH
12138: LD_EXP 63
12142: PUSH
12143: LD_EXP 25
12147: ARRAY
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: PUSH
12153: LD_INT 7
12155: PUSH
12156: LD_INT 8
12158: NEG
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: PPUSH
12168: CALL_OW 399
12172: ST_TO_ADDR
// NorMcAttId := McAttack ( 12 , NorMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12173: LD_ADDR_EXP 69
12177: PUSH
12178: LD_INT 12
12180: PPUSH
12181: LD_EXP 68
12185: PPUSH
12186: LD_EXP 77
12190: PUSH
12191: LD_EXP 25
12195: ARRAY
12196: PPUSH
12197: LD_INT 8
12199: PUSH
12200: LD_EXP 63
12204: PUSH
12205: LD_EXP 25
12209: ARRAY
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: LD_INT 7
12217: PUSH
12218: LD_EXP 63
12222: PUSH
12223: LD_EXP 25
12227: ARRAY
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 6
12235: PUSH
12236: LD_INT 100
12238: PUSH
12239: EMPTY
12240: LIST
12241: LIST
12242: PUSH
12243: LD_INT 5
12245: PUSH
12246: LD_INT 800
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: PUSH
12253: LD_INT 10
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: PPUSH
12263: CALL_OW 402
12267: ST_TO_ADDR
// end ;
12268: LD_VAR 0 1
12272: RET
// function utok_na_vetrelce ( vetrelci , index_strany ) ; var nearest , units ; begin
12273: LD_INT 0
12275: PPUSH
12276: PPUSH
12277: PPUSH
// if vetrelci and ( ai_s [ index_strany ] in aiZ ) then
12278: LD_VAR 0 1
12282: PUSH
12283: LD_EXP 23
12287: PUSH
12288: LD_VAR 0 2
12292: ARRAY
12293: PUSH
12294: LD_EXP 21
12298: IN
12299: AND
12300: IFFALSE 12403
// begin nearest := NearestUnitToUnit ( vetrelci , depots [ index_strany ] ) ;
12302: LD_ADDR_VAR 0 4
12306: PUSH
12307: LD_VAR 0 1
12311: PPUSH
12312: LD_EXP 74
12316: PUSH
12317: LD_VAR 0 2
12321: ARRAY
12322: PPUSH
12323: CALL_OW 74
12327: ST_TO_ADDR
// if nearest then
12328: LD_VAR 0 4
12332: IFFALSE 12403
// begin units := attack_units isect vehicles [ index_strany ] ;
12334: LD_ADDR_VAR 0 5
12338: PUSH
12339: LD_EXP 78
12343: PUSH
12344: LD_EXP 77
12348: PUSH
12349: LD_VAR 0 2
12353: ARRAY
12354: ISECT
12355: ST_TO_ADDR
// ComRemember ( units ) ;
12356: LD_VAR 0 5
12360: PPUSH
12361: CALL_OW 143
// AddComAgressiveMove ( units , GetX ( nearest ) , GetY ( nearest ) ) ;
12365: LD_VAR 0 5
12369: PPUSH
12370: LD_VAR 0 4
12374: PPUSH
12375: CALL_OW 250
12379: PPUSH
12380: LD_VAR 0 4
12384: PPUSH
12385: CALL_OW 251
12389: PPUSH
12390: CALL_OW 174
// AddComReturn ( units ) ;
12394: LD_VAR 0 5
12398: PPUSH
12399: CALL_OW 204
// end ; end ; end ;
12403: LD_VAR 0 3
12407: RET
// every 0 0$10 do var i , a ;
12408: GO 12410
12410: DISABLE
12411: LD_INT 0
12413: PPUSH
12414: PPUSH
// begin for i := 1 to 5 do
12415: LD_ADDR_VAR 0 1
12419: PUSH
12420: DOUBLE
12421: LD_INT 1
12423: DEC
12424: ST_TO_ADDR
12425: LD_INT 5
12427: PUSH
12428: FOR_TO
12429: IFFALSE 12568
// begin a := UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ i ] ] ] ) ;
12431: LD_ADDR_VAR 0 2
12435: PUSH
12436: LD_EXP 37
12440: PUSH
12441: LD_EXP 35
12445: ADD
12446: PPUSH
12447: LD_INT 95
12449: PUSH
12450: LD_EXP 63
12454: PUSH
12455: LD_VAR 0 1
12459: ARRAY
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: PUSH
12465: EMPTY
12466: LIST
12467: PPUSH
12468: CALL_OW 72
12472: ST_TO_ADDR
// if a and ai_s [ i ] in aiZ then
12473: LD_VAR 0 2
12477: PUSH
12478: LD_EXP 23
12482: PUSH
12483: LD_VAR 0 1
12487: ARRAY
12488: PUSH
12489: LD_EXP 21
12493: IN
12494: AND
12495: IFFALSE 12536
// begin under_attack := replace ( under_attack , i , true ) ;
12497: LD_ADDR_EXP 62
12501: PUSH
12502: LD_EXP 62
12506: PPUSH
12507: LD_VAR 0 1
12511: PPUSH
12512: LD_INT 1
12514: PPUSH
12515: CALL_OW 1
12519: ST_TO_ADDR
// utok_na_vetrelce ( a , i ) ;
12520: LD_VAR 0 2
12524: PPUSH
12525: LD_VAR 0 1
12529: PPUSH
12530: CALL 12273 0 2
// end else
12534: GO 12559
// under_attack := replace ( under_attack , i , false ) ;
12536: LD_ADDR_EXP 62
12540: PUSH
12541: LD_EXP 62
12545: PPUSH
12546: LD_VAR 0 1
12550: PPUSH
12551: LD_INT 0
12553: PPUSH
12554: CALL_OW 1
12558: ST_TO_ADDR
// wait ( 0 0$2 ) ;
12559: LD_INT 70
12561: PPUSH
12562: CALL_OW 67
// end ;
12566: GO 12428
12568: POP
12569: POP
// enable ;
12570: ENABLE
// end ; end_of_file
12571: PPOPN 2
12573: END
// var repair_site ; export rc ; export bc ; export function inicializace_ai_c_repair ; begin
12574: LD_INT 0
12576: PPUSH
// repair_site := [ [ 30 , 29 ] , [ 89 , 17 ] , [ 72 , 125 ] , [ 215 , 140 ] , [ 184 , 85 ] ] ;
12577: LD_ADDR_LOC 16
12581: PUSH
12582: LD_INT 30
12584: PUSH
12585: LD_INT 29
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 89
12594: PUSH
12595: LD_INT 17
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 72
12604: PUSH
12605: LD_INT 125
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 215
12614: PUSH
12615: LD_INT 140
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 184
12624: PUSH
12625: LD_INT 85
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: ST_TO_ADDR
// bc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12639: LD_ADDR_EXP 71
12643: PUSH
12644: EMPTY
12645: PUSH
12646: EMPTY
12647: PUSH
12648: EMPTY
12649: PUSH
12650: EMPTY
12651: PUSH
12652: EMPTY
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: ST_TO_ADDR
// rc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12661: LD_ADDR_EXP 70
12665: PUSH
12666: EMPTY
12667: PUSH
12668: EMPTY
12669: PUSH
12670: EMPTY
12671: PUSH
12672: EMPTY
12673: PUSH
12674: EMPTY
12675: PUSH
12676: EMPTY
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: ST_TO_ADDR
// end ;
12683: LD_VAR 0 1
12687: RET
// every 0 0$5.0 + 0 0$0.5 do var i ;
12688: GO 12690
12690: DISABLE
12691: LD_INT 0
12693: PPUSH
// begin for i := 1 to 5 do
12694: LD_ADDR_VAR 0 1
12698: PUSH
12699: DOUBLE
12700: LD_INT 1
12702: DEC
12703: ST_TO_ADDR
12704: LD_INT 5
12706: PUSH
12707: FOR_TO
12708: IFFALSE 12763
// if ai_s [ i ] in ai then
12710: LD_EXP 23
12714: PUSH
12715: LD_VAR 0 1
12719: ARRAY
12720: PUSH
12721: LD_EXP 24
12725: IN
12726: IFFALSE 12761
// begin dop_pal ( vehicles [ i ] , depots [ i ] ) ;
12728: LD_EXP 77
12732: PUSH
12733: LD_VAR 0 1
12737: ARRAY
12738: PPUSH
12739: LD_EXP 74
12743: PUSH
12744: LD_VAR 0 1
12748: ARRAY
12749: PPUSH
12750: CALL 12769 0 2
// wait ( 0 0$1 ) ;
12754: LD_INT 35
12756: PPUSH
12757: CALL_OW 67
// end ;
12761: GO 12707
12763: POP
12764: POP
// enable ;
12765: ENABLE
// end ;
12766: PPOPN 1
12768: END
// function dop_pal ( tc , tdep ) ; var set_fuel , fuel ; begin
12769: LD_INT 0
12771: PPUSH
12772: PPUSH
12773: PPUSH
// for set_fuel in UnitFilter ( tc , [ [ f_dist , tdep , 40 ] ] ) do
12774: LD_ADDR_VAR 0 4
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 91
12786: PUSH
12787: LD_VAR 0 2
12791: PUSH
12792: LD_INT 40
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: PUSH
12800: EMPTY
12801: LIST
12802: PPUSH
12803: CALL_OW 72
12807: PUSH
12808: FOR_IN
12809: IFFALSE 12856
// begin fuel := GetFuel ( set_fuel ) ;
12811: LD_ADDR_VAR 0 5
12815: PUSH
12816: LD_VAR 0 4
12820: PPUSH
12821: CALL_OW 261
12825: ST_TO_ADDR
// if fuel <= 80 then
12826: LD_VAR 0 5
12830: PUSH
12831: LD_INT 80
12833: LESSEQUAL
12834: IFFALSE 12854
// SetFuel ( set_fuel , fuel + 20 ) ;
12836: LD_VAR 0 4
12840: PPUSH
12841: LD_VAR 0 5
12845: PUSH
12846: LD_INT 20
12848: PLUS
12849: PPUSH
12850: CALL_OW 240
// end ;
12854: GO 12808
12856: POP
12857: POP
// end ;
12858: LD_VAR 0 3
12862: RET
// every 0 0$5 + 0 0$0.3 do var zivoty , i , rem_t , add_t , k ;
12863: GO 12865
12865: DISABLE
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
12871: PPUSH
12872: PPUSH
// begin for k := 1 to 5 do
12873: LD_ADDR_VAR 0 5
12877: PUSH
12878: DOUBLE
12879: LD_INT 1
12881: DEC
12882: ST_TO_ADDR
12883: LD_INT 5
12885: PUSH
12886: FOR_TO
12887: IFFALSE 13205
// if ai_s [ k ] in ai then
12889: LD_EXP 23
12893: PUSH
12894: LD_VAR 0 5
12898: ARRAY
12899: PUSH
12900: LD_EXP 24
12904: IN
12905: IFFALSE 13181
// begin rem_t := [ ] ;
12907: LD_ADDR_VAR 0 3
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// add_t := [ ] ;
12914: LD_ADDR_VAR 0 4
12918: PUSH
12919: EMPTY
12920: ST_TO_ADDR
// for i in UnitFilter ( vehicles [ k ] , [ [ f_not , [ f_side , you ] ] ] ) do
12921: LD_ADDR_VAR 0 2
12925: PUSH
12926: LD_EXP 77
12930: PUSH
12931: LD_VAR 0 5
12935: ARRAY
12936: PPUSH
12937: LD_INT 3
12939: PUSH
12940: LD_INT 22
12942: PUSH
12943: LD_EXP 7
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: PPUSH
12959: CALL_OW 72
12963: PUSH
12964: FOR_IN
12965: IFFALSE 13033
// begin if GetLives ( i ) < 500 then
12967: LD_VAR 0 2
12971: PPUSH
12972: CALL_OW 256
12976: PUSH
12977: LD_INT 500
12979: LESS
12980: IFFALSE 13000
// begin rem_t := rem_t ^ i ;
12982: LD_ADDR_VAR 0 3
12986: PUSH
12987: LD_VAR 0 3
12991: PUSH
12992: LD_VAR 0 2
12996: ADD
12997: ST_TO_ADDR
// end else
12998: GO 13031
// if GetLives ( i ) >= 950 then
13000: LD_VAR 0 2
13004: PPUSH
13005: CALL_OW 256
13009: PUSH
13010: LD_INT 950
13012: GREATEREQUAL
13013: IFFALSE 13031
// begin add_t := add_t ^ i ;
13015: LD_ADDR_VAR 0 4
13019: PUSH
13020: LD_VAR 0 4
13024: PUSH
13025: LD_VAR 0 2
13029: ADD
13030: ST_TO_ADDR
// end ; end ;
13031: GO 12964
13033: POP
13034: POP
// bc := replace ( bc , k , bc [ k ] union rem_t ) ;
13035: LD_ADDR_EXP 71
13039: PUSH
13040: LD_EXP 71
13044: PPUSH
13045: LD_VAR 0 5
13049: PPUSH
13050: LD_EXP 71
13054: PUSH
13055: LD_VAR 0 5
13059: ARRAY
13060: PUSH
13061: LD_VAR 0 3
13065: UNION
13066: PPUSH
13067: CALL_OW 1
13071: ST_TO_ADDR
// bc := replace ( bc , k , bc [ k ] diff add_t ) ;
13072: LD_ADDR_EXP 71
13076: PUSH
13077: LD_EXP 71
13081: PPUSH
13082: LD_VAR 0 5
13086: PPUSH
13087: LD_EXP 71
13091: PUSH
13092: LD_VAR 0 5
13096: ARRAY
13097: PUSH
13098: LD_VAR 0 4
13102: DIFF
13103: PPUSH
13104: CALL_OW 1
13108: ST_TO_ADDR
// remove_from_vehicles ( rem_t ) ;
13109: LD_VAR 0 3
13113: PPUSH
13114: CALL 28265 0 1
// add_to_vehicles ( add_t ) ;
13118: LD_VAR 0 4
13122: PPUSH
13123: CALL 26934 0 1
// ComMoveXY ( bc [ k ] , repair_site [ k ] [ 1 ] , repair_site [ k ] [ 2 ] ) ;
13127: LD_EXP 71
13131: PUSH
13132: LD_VAR 0 5
13136: ARRAY
13137: PPUSH
13138: LD_LOC 16
13142: PUSH
13143: LD_VAR 0 5
13147: ARRAY
13148: PUSH
13149: LD_INT 1
13151: ARRAY
13152: PPUSH
13153: LD_LOC 16
13157: PUSH
13158: LD_VAR 0 5
13162: ARRAY
13163: PUSH
13164: LD_INT 2
13166: ARRAY
13167: PPUSH
13168: CALL_OW 111
// wait ( 0 0$0.9 ) ;
13172: LD_INT 32
13174: PPUSH
13175: CALL_OW 67
// end else
13179: GO 13203
// bc := replace ( bc , k , [ ] ) ;
13181: LD_ADDR_EXP 71
13185: PUSH
13186: LD_EXP 71
13190: PPUSH
13191: LD_VAR 0 5
13195: PPUSH
13196: EMPTY
13197: PPUSH
13198: CALL_OW 1
13202: ST_TO_ADDR
13203: GO 12886
13205: POP
13206: POP
// enable ;
13207: ENABLE
// end ;
13208: PPOPN 5
13210: END
// every 0 0$5 + 0 0$0.1 do var zivoty , i , rc_t , k ;
13211: GO 13213
13213: DISABLE
13214: LD_INT 0
13216: PPUSH
13217: PPUSH
13218: PPUSH
13219: PPUSH
// begin for k := 1 to 5 do
13220: LD_ADDR_VAR 0 4
13224: PUSH
13225: DOUBLE
13226: LD_INT 1
13228: DEC
13229: ST_TO_ADDR
13230: LD_INT 5
13232: PUSH
13233: FOR_TO
13234: IFFALSE 13401
// if ai_s [ k ] in ai then
13236: LD_EXP 23
13240: PUSH
13241: LD_VAR 0 4
13245: ARRAY
13246: PUSH
13247: LD_EXP 24
13251: IN
13252: IFFALSE 13377
// begin rc_t := [ ] ;
13254: LD_ADDR_VAR 0 3
13258: PUSH
13259: EMPTY
13260: ST_TO_ADDR
// for i in bc [ k ] do
13261: LD_ADDR_VAR 0 2
13265: PUSH
13266: LD_EXP 71
13270: PUSH
13271: LD_VAR 0 4
13275: ARRAY
13276: PUSH
13277: FOR_IN
13278: IFFALSE 13334
// begin if GetLives ( i ) < 950 then
13280: LD_VAR 0 2
13284: PPUSH
13285: CALL_OW 256
13289: PUSH
13290: LD_INT 950
13292: LESS
13293: IFFALSE 13332
// begin rc_t := rc_t ^ i ;
13295: LD_ADDR_VAR 0 3
13299: PUSH
13300: LD_VAR 0 3
13304: PUSH
13305: LD_VAR 0 2
13309: ADD
13310: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
13311: LD_ADDR_VAR 0 1
13315: PUSH
13316: LD_VAR 0 1
13320: PUSH
13321: LD_VAR 0 2
13325: PPUSH
13326: CALL_OW 256
13330: ADD
13331: ST_TO_ADDR
// end ; end ;
13332: GO 13277
13334: POP
13335: POP
// SortListByListAsc ( rc_t , zivoty ) ;
13336: LD_VAR 0 3
13340: PPUSH
13341: LD_VAR 0 1
13345: PPUSH
13346: CALL_OW 76
// rc := replace ( rc , k , rc_t ) ;
13350: LD_ADDR_EXP 70
13354: PUSH
13355: LD_EXP 70
13359: PPUSH
13360: LD_VAR 0 4
13364: PPUSH
13365: LD_VAR 0 3
13369: PPUSH
13370: CALL_OW 1
13374: ST_TO_ADDR
// end else
13375: GO 13399
// rc := replace ( rc , k , [ ] ) ;
13377: LD_ADDR_EXP 70
13381: PUSH
13382: LD_EXP 70
13386: PPUSH
13387: LD_VAR 0 4
13391: PPUSH
13392: EMPTY
13393: PPUSH
13394: CALL_OW 1
13398: ST_TO_ADDR
13399: GO 13233
13401: POP
13402: POP
// enable ;
13403: ENABLE
// end ;
13404: PPOPN 4
13406: END
// every 0 0$5 + 0 0$0.9 do var i ;
13407: GO 13409
13409: DISABLE
13410: LD_INT 0
13412: PPUSH
// begin for i := 1 to 5 do
13413: LD_ADDR_VAR 0 1
13417: PUSH
13418: DOUBLE
13419: LD_INT 1
13421: DEC
13422: ST_TO_ADDR
13423: LD_INT 5
13425: PUSH
13426: FOR_TO
13427: IFFALSE 13482
// if ai_s [ i ] in ai then
13429: LD_EXP 23
13433: PUSH
13434: LD_VAR 0 1
13438: ARRAY
13439: PUSH
13440: LD_EXP 24
13444: IN
13445: IFFALSE 13480
// begin rep ( ai_s [ i ] , rc [ i ] ) ;
13447: LD_EXP 23
13451: PUSH
13452: LD_VAR 0 1
13456: ARRAY
13457: PPUSH
13458: LD_EXP 70
13462: PUSH
13463: LD_VAR 0 1
13467: ARRAY
13468: PPUSH
13469: CALL 13488 0 2
// wait ( 0 0$0.8 ) ;
13473: LD_INT 28
13475: PPUSH
13476: CALL_OW 67
// end ;
13480: GO 13426
13482: POP
13483: POP
// enable ;
13484: ENABLE
// end ;
13485: PPOPN 1
13487: END
// function rep ( side , rep_cars ) ; var a ; begin
13488: LD_INT 0
13490: PPUSH
13491: PPUSH
// if ( side in ai ) and rep_cars then
13492: LD_VAR 0 1
13496: PUSH
13497: LD_EXP 24
13501: IN
13502: PUSH
13503: LD_VAR 0 2
13507: AND
13508: IFFALSE 14037
// begin if rep_cars [ 1 ] < 400 then
13510: LD_VAR 0 2
13514: PUSH
13515: LD_INT 1
13517: ARRAY
13518: PUSH
13519: LD_INT 400
13521: LESS
13522: IFFALSE 13621
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13524: LD_ADDR_VAR 0 4
13528: PUSH
13529: LD_EXP 86
13533: PPUSH
13534: LD_INT 22
13536: PUSH
13537: LD_VAR 0 1
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: LD_INT 91
13548: PUSH
13549: LD_VAR 0 2
13553: PUSH
13554: LD_INT 1
13556: ARRAY
13557: PUSH
13558: LD_INT 20
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: LIST
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PPUSH
13570: CALL_OW 72
13574: PPUSH
13575: LD_INT 2
13577: PPUSH
13578: LD_INT 3
13580: PPUSH
13581: LD_INT 0
13583: PPUSH
13584: LD_INT 0
13586: PPUSH
13587: CALL 10106 0 5
13591: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13592: LD_VAR 0 4
13596: PPUSH
13597: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13601: LD_VAR 0 4
13605: PPUSH
13606: LD_VAR 0 2
13610: PUSH
13611: LD_INT 1
13613: ARRAY
13614: PPUSH
13615: CALL_OW 189
// end else
13619: GO 14037
// if rep_cars [ 1 ] < 700 or rep_cars >= 2 then
13621: LD_VAR 0 2
13625: PUSH
13626: LD_INT 1
13628: ARRAY
13629: PUSH
13630: LD_INT 700
13632: LESS
13633: PUSH
13634: LD_VAR 0 2
13638: PUSH
13639: LD_INT 2
13641: GREATEREQUAL
13642: OR
13643: IFFALSE 13837
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , false ) ;
13645: LD_ADDR_VAR 0 4
13649: PUSH
13650: LD_EXP 86
13654: PPUSH
13655: LD_INT 22
13657: PUSH
13658: LD_VAR 0 1
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: PUSH
13667: LD_INT 91
13669: PUSH
13670: LD_VAR 0 2
13674: PUSH
13675: LD_INT 1
13677: ARRAY
13678: PUSH
13679: LD_INT 20
13681: PUSH
13682: EMPTY
13683: LIST
13684: LIST
13685: LIST
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PPUSH
13691: CALL_OW 72
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: LD_INT 3
13701: PPUSH
13702: LD_INT 0
13704: PPUSH
13705: LD_INT 0
13707: PPUSH
13708: CALL 10106 0 5
13712: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13713: LD_VAR 0 4
13717: PPUSH
13718: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13722: LD_VAR 0 4
13726: PPUSH
13727: LD_VAR 0 2
13731: PUSH
13732: LD_INT 1
13734: ARRAY
13735: PPUSH
13736: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , true ) ;
13740: LD_ADDR_VAR 0 4
13744: PUSH
13745: LD_EXP 86
13749: PPUSH
13750: LD_INT 22
13752: PUSH
13753: LD_VAR 0 1
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PUSH
13762: LD_INT 91
13764: PUSH
13765: LD_VAR 0 2
13769: PUSH
13770: LD_INT 2
13772: ARRAY
13773: PUSH
13774: LD_INT 20
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: LIST
13781: PUSH
13782: EMPTY
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 72
13790: PPUSH
13791: LD_INT 1
13793: PPUSH
13794: LD_INT 3
13796: PPUSH
13797: LD_INT 0
13799: PPUSH
13800: LD_INT 1
13802: PPUSH
13803: CALL 10106 0 5
13807: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13808: LD_VAR 0 4
13812: PPUSH
13813: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13817: LD_VAR 0 4
13821: PPUSH
13822: LD_VAR 0 2
13826: PUSH
13827: LD_INT 2
13829: ARRAY
13830: PPUSH
13831: CALL_OW 189
// end else
13835: GO 14037
// if rep_cars >= 3 then
13837: LD_VAR 0 2
13841: PUSH
13842: LD_INT 3
13844: GREATEREQUAL
13845: IFFALSE 14037
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13847: LD_ADDR_VAR 0 4
13851: PUSH
13852: LD_EXP 86
13856: PPUSH
13857: LD_INT 22
13859: PUSH
13860: LD_VAR 0 1
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: PUSH
13869: LD_INT 91
13871: PUSH
13872: LD_VAR 0 2
13876: PUSH
13877: LD_INT 1
13879: ARRAY
13880: PUSH
13881: LD_INT 20
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: LIST
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PPUSH
13893: CALL_OW 72
13897: PPUSH
13898: LD_INT 2
13900: PPUSH
13901: LD_INT 3
13903: PPUSH
13904: LD_INT 0
13906: PPUSH
13907: LD_INT 0
13909: PPUSH
13910: CALL 10106 0 5
13914: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13915: LD_VAR 0 4
13919: PPUSH
13920: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13924: LD_VAR 0 4
13928: PPUSH
13929: LD_VAR 0 2
13933: PUSH
13934: LD_INT 1
13936: ARRAY
13937: PPUSH
13938: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , true ) ;
13942: LD_ADDR_VAR 0 4
13946: PUSH
13947: LD_EXP 86
13951: PPUSH
13952: LD_INT 22
13954: PUSH
13955: LD_VAR 0 1
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 91
13966: PUSH
13967: LD_VAR 0 2
13971: PUSH
13972: LD_INT 2
13974: ARRAY
13975: PUSH
13976: LD_INT 20
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: LIST
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PPUSH
13988: CALL_OW 72
13992: PPUSH
13993: LD_INT 2
13995: PPUSH
13996: LD_INT 3
13998: PPUSH
13999: LD_INT 0
14001: PPUSH
14002: LD_INT 1
14004: PPUSH
14005: CALL 10106 0 5
14009: ST_TO_ADDR
// ComExitBuilding ( a ) ;
14010: LD_VAR 0 4
14014: PPUSH
14015: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
14019: LD_VAR 0 4
14023: PPUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 2
14031: ARRAY
14032: PPUSH
14033: CALL_OW 189
// end ; end ; end ; end_of_file
14037: LD_VAR 0 3
14041: RET
// var d1 , d2 , d3 , d5 , d6 , d7 ; export function inicializace_ai_c_make ; begin
14042: LD_INT 0
14044: PPUSH
// d1 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ;
14045: LD_ADDR_LOC 17
14049: PUSH
14050: LD_INT 23
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: LD_INT 1
14058: PUSH
14059: LD_INT 43
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: ST_TO_ADDR
// d2 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] ;
14068: LD_ADDR_LOC 18
14072: PUSH
14073: LD_INT 23
14075: PUSH
14076: LD_INT 1
14078: PUSH
14079: LD_INT 1
14081: PUSH
14082: LD_INT 45
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: ST_TO_ADDR
// d3 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] ;
14091: LD_ADDR_LOC 19
14095: PUSH
14096: LD_INT 23
14098: PUSH
14099: LD_INT 1
14101: PUSH
14102: LD_INT 1
14104: PUSH
14105: LD_INT 46
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: ST_TO_ADDR
// d5 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_gatling_gun ] ;
14114: LD_ADDR_LOC 20
14118: PUSH
14119: LD_INT 23
14121: PUSH
14122: LD_INT 3
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 43
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: ST_TO_ADDR
// d6 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_rocket_launcher ] ;
14137: LD_ADDR_LOC 21
14141: PUSH
14142: LD_INT 23
14144: PUSH
14145: LD_INT 3
14147: PUSH
14148: LD_INT 3
14150: PUSH
14151: LD_INT 45
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: ST_TO_ADDR
// d7 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_heavy_gun ] ;
14160: LD_ADDR_LOC 22
14164: PUSH
14165: LD_INT 23
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: LD_INT 3
14173: PUSH
14174: LD_INT 46
14176: PUSH
14177: EMPTY
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: ST_TO_ADDR
// end ;
14183: LD_VAR 0 1
14187: RET
// every 0 0$3 do var i , a ;
14188: GO 14190
14190: DISABLE
14191: LD_INT 0
14193: PPUSH
14194: PPUSH
// begin for i := 1 to 5 do
14195: LD_ADDR_VAR 0 1
14199: PUSH
14200: DOUBLE
14201: LD_INT 1
14203: DEC
14204: ST_TO_ADDR
14205: LD_INT 5
14207: PUSH
14208: FOR_TO
14209: IFFALSE 14433
// begin if ai_s [ i ] in ai then
14211: LD_EXP 23
14215: PUSH
14216: LD_VAR 0 1
14220: ARRAY
14221: PUSH
14222: LD_EXP 24
14226: IN
14227: IFFALSE 14431
// begin if depots [ i ] then
14229: LD_EXP 74
14233: PUSH
14234: LD_VAR 0 1
14238: ARRAY
14239: IFFALSE 14431
// begin if GetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans ) < 150 then
14241: LD_EXP 74
14245: PUSH
14246: LD_VAR 0 1
14250: ARRAY
14251: PUSH
14252: LD_INT 1
14254: ARRAY
14255: PPUSH
14256: CALL_OW 274
14260: PPUSH
14261: LD_INT 1
14263: PPUSH
14264: CALL_OW 275
14268: PUSH
14269: LD_INT 150
14271: LESS
14272: IFFALSE 14316
// SetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans , 150 + Rand ( 50 , 100 ) ) ;
14274: LD_EXP 74
14278: PUSH
14279: LD_VAR 0 1
14283: ARRAY
14284: PUSH
14285: LD_INT 1
14287: ARRAY
14288: PPUSH
14289: CALL_OW 274
14293: PPUSH
14294: LD_INT 1
14296: PPUSH
14297: LD_INT 150
14299: PUSH
14300: LD_INT 50
14302: PPUSH
14303: LD_INT 100
14305: PPUSH
14306: CALL_OW 12
14310: PLUS
14311: PPUSH
14312: CALL_OW 277
// a := GetListOfCratesInArea ( near_base_area [ i ] ) ;
14316: LD_ADDR_VAR 0 2
14320: PUSH
14321: LD_EXP 63
14325: PUSH
14326: LD_VAR 0 1
14330: ARRAY
14331: PPUSH
14332: CALL_OW 435
14336: ST_TO_ADDR
// if a > 6 then
14337: LD_VAR 0 2
14341: PUSH
14342: LD_INT 6
14344: GREATER
14345: IFFALSE 14431
// for i in a do
14347: LD_ADDR_VAR 0 1
14351: PUSH
14352: LD_VAR 0 2
14356: PUSH
14357: FOR_IN
14358: IFFALSE 14429
// if not SeeXY ( you , i [ 1 ] , i [ 2 ] ) then
14360: LD_EXP 7
14364: PPUSH
14365: LD_VAR 0 1
14369: PUSH
14370: LD_INT 1
14372: ARRAY
14373: PPUSH
14374: LD_VAR 0 1
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: CALL_OW 293
14387: NOT
14388: IFFALSE 14427
// begin MoveAreaXY ( hexik , i [ 1 ] , i [ 2 ] ) ;
14390: LD_INT 32
14392: PPUSH
14393: LD_VAR 0 1
14397: PUSH
14398: LD_INT 1
14400: ARRAY
14401: PPUSH
14402: LD_VAR 0 1
14406: PUSH
14407: LD_INT 2
14409: ARRAY
14410: PPUSH
14411: CALL_OW 425
// EraseResourceArea ( hexik , mat_cans ) ;
14415: LD_INT 32
14417: PPUSH
14418: LD_INT 1
14420: PPUSH
14421: CALL_OW 286
// break ;
14425: GO 14429
// end ;
14427: GO 14357
14429: POP
14430: POP
// end ; end ; end ;
14431: GO 14208
14433: POP
14434: POP
// end ;
14435: PPOPN 2
14437: END
// function MyCanBeConstructed ( tfact , d ) ; begin
14438: LD_INT 0
14440: PPUSH
// result := CanBeConstructed ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14441: LD_ADDR_VAR 0 3
14445: PUSH
14446: LD_VAR 0 1
14450: PPUSH
14451: LD_VAR 0 2
14455: PUSH
14456: LD_INT 1
14458: ARRAY
14459: PPUSH
14460: LD_VAR 0 2
14464: PUSH
14465: LD_INT 2
14467: ARRAY
14468: PPUSH
14469: LD_VAR 0 2
14473: PUSH
14474: LD_INT 3
14476: ARRAY
14477: PPUSH
14478: LD_VAR 0 2
14482: PUSH
14483: LD_INT 4
14485: ARRAY
14486: PPUSH
14487: CALL_OW 448
14491: ST_TO_ADDR
// end ;
14492: LD_VAR 0 3
14496: RET
// function MyComConstruct ( tfact , d ) ; begin
14497: LD_INT 0
14499: PPUSH
// result := ComConstruct ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14500: LD_ADDR_VAR 0 3
14504: PUSH
14505: LD_VAR 0 1
14509: PPUSH
14510: LD_VAR 0 2
14514: PUSH
14515: LD_INT 1
14517: ARRAY
14518: PPUSH
14519: LD_VAR 0 2
14523: PUSH
14524: LD_INT 2
14526: ARRAY
14527: PPUSH
14528: LD_VAR 0 2
14532: PUSH
14533: LD_INT 3
14535: ARRAY
14536: PPUSH
14537: LD_VAR 0 2
14541: PUSH
14542: LD_INT 4
14544: ARRAY
14545: PPUSH
14546: CALL_OW 125
14550: ST_TO_ADDR
// end ;
14551: LD_VAR 0 3
14555: RET
// every 0 0$10 + 0 0$1.1 trigger IsOk ( factories [ 1 ] ) and IsIdle ( factories [ 1 ] ) do var a , tfact , def , att ;
14556: LD_EXP 73
14560: PUSH
14561: LD_INT 1
14563: ARRAY
14564: PPUSH
14565: CALL_OW 302
14569: PUSH
14570: LD_EXP 73
14574: PUSH
14575: LD_INT 1
14577: ARRAY
14578: PPUSH
14579: CALL_OW 316
14583: AND
14584: IFFALSE 14903
14586: GO 14588
14588: DISABLE
14589: LD_INT 0
14591: PPUSH
14592: PPUSH
14593: PPUSH
14594: PPUSH
// begin tfact := factories [ 1 ] ;
14595: LD_ADDR_VAR 0 2
14599: PUSH
14600: LD_EXP 73
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 1 ] , [ mf_manu ] ) ;
14609: LD_ADDR_VAR 0 3
14613: PUSH
14614: LD_EXP 77
14618: PUSH
14619: LD_INT 1
14621: ARRAY
14622: PPUSH
14623: LD_EXP 61
14627: PUSH
14628: EMPTY
14629: LIST
14630: PPUSH
14631: CALL_OW 72
14635: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 1 ] , [ mf_comp ] ) ;
14636: LD_ADDR_VAR 0 4
14640: PUSH
14641: LD_EXP 77
14645: PUSH
14646: LD_INT 1
14648: ARRAY
14649: PPUSH
14650: LD_EXP 60
14654: PUSH
14655: EMPTY
14656: LIST
14657: PPUSH
14658: CALL_OW 72
14662: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14663: LD_INT 1
14665: PUSH
14666: LD_VAR 0 3
14670: PUSH
14671: LD_INT 2
14673: LESS
14674: PUSH
14675: LD_VAR 0 2
14679: PPUSH
14680: LD_LOC 18
14684: PPUSH
14685: CALL 14438 0 2
14689: AND
14690: DOUBLE
14691: EQUAL
14692: IFTRUE 14696
14694: GO 14713
14696: POP
// begin MyComConstruct ( tfact , d2 ) ;
14697: LD_VAR 0 2
14701: PPUSH
14702: LD_LOC 18
14706: PPUSH
14707: CALL 14497 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14711: GO 14902
14713: LD_VAR 0 3
14717: PUSH
14718: LD_INT 3
14720: LESS
14721: PUSH
14722: LD_VAR 0 2
14726: PPUSH
14727: LD_LOC 19
14731: PPUSH
14732: CALL 14438 0 2
14736: AND
14737: DOUBLE
14738: EQUAL
14739: IFTRUE 14743
14741: GO 14760
14743: POP
// begin MyComConstruct ( tfact , d3 ) ;
14744: LD_VAR 0 2
14748: PPUSH
14749: LD_LOC 19
14753: PPUSH
14754: CALL 14497 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
14758: GO 14902
14760: LD_VAR 0 4
14764: PUSH
14765: LD_INT 2
14767: LESS
14768: PUSH
14769: LD_VAR 0 2
14773: PPUSH
14774: LD_LOC 21
14778: PPUSH
14779: CALL 14438 0 2
14783: AND
14784: DOUBLE
14785: EQUAL
14786: IFTRUE 14790
14788: GO 14807
14790: POP
// begin MyComConstruct ( tfact , d6 ) ;
14791: LD_VAR 0 2
14795: PPUSH
14796: LD_LOC 21
14800: PPUSH
14801: CALL 14497 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
14805: GO 14902
14807: LD_VAR 0 4
14811: PUSH
14812: LD_INT 3
14814: LESS
14815: PUSH
14816: LD_VAR 0 2
14820: PPUSH
14821: LD_LOC 20
14825: PPUSH
14826: CALL 14438 0 2
14830: AND
14831: DOUBLE
14832: EQUAL
14833: IFTRUE 14837
14835: GO 14854
14837: POP
// begin MyComConstruct ( tfact , d5 ) ;
14838: LD_VAR 0 2
14842: PPUSH
14843: LD_LOC 20
14847: PPUSH
14848: CALL 14497 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
14852: GO 14902
14854: LD_VAR 0 4
14858: PUSH
14859: LD_INT 5
14861: LESS
14862: PUSH
14863: LD_VAR 0 2
14867: PPUSH
14868: LD_LOC 22
14872: PPUSH
14873: CALL 14438 0 2
14877: AND
14878: DOUBLE
14879: EQUAL
14880: IFTRUE 14884
14882: GO 14901
14884: POP
// begin MyComConstruct ( tfact , d7 ) ;
14885: LD_VAR 0 2
14889: PPUSH
14890: LD_LOC 22
14894: PPUSH
14895: CALL 14497 0 2
// end ; end ;
14899: GO 14902
14901: POP
// enable ;
14902: ENABLE
// end ;
14903: PPOPN 4
14905: END
// every 0 0$10 + 0 0$2.3 trigger IsOk ( factories [ 2 ] ) and IsIdle ( factories [ 2 ] ) do var a , tfact , def , att ;
14906: LD_EXP 73
14910: PUSH
14911: LD_INT 2
14913: ARRAY
14914: PPUSH
14915: CALL_OW 302
14919: PUSH
14920: LD_EXP 73
14924: PUSH
14925: LD_INT 2
14927: ARRAY
14928: PPUSH
14929: CALL_OW 316
14933: AND
14934: IFFALSE 15253
14936: GO 14938
14938: DISABLE
14939: LD_INT 0
14941: PPUSH
14942: PPUSH
14943: PPUSH
14944: PPUSH
// begin tfact := factories [ 2 ] ;
14945: LD_ADDR_VAR 0 2
14949: PUSH
14950: LD_EXP 73
14954: PUSH
14955: LD_INT 2
14957: ARRAY
14958: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 2 ] , [ mf_manu ] ) ;
14959: LD_ADDR_VAR 0 3
14963: PUSH
14964: LD_EXP 77
14968: PUSH
14969: LD_INT 2
14971: ARRAY
14972: PPUSH
14973: LD_EXP 61
14977: PUSH
14978: EMPTY
14979: LIST
14980: PPUSH
14981: CALL_OW 72
14985: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 2 ] , [ mf_comp ] ) ;
14986: LD_ADDR_VAR 0 4
14990: PUSH
14991: LD_EXP 77
14995: PUSH
14996: LD_INT 2
14998: ARRAY
14999: PPUSH
15000: LD_EXP 60
15004: PUSH
15005: EMPTY
15006: LIST
15007: PPUSH
15008: CALL_OW 72
15012: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15013: LD_INT 1
15015: PUSH
15016: LD_VAR 0 3
15020: PUSH
15021: LD_INT 2
15023: LESS
15024: PUSH
15025: LD_VAR 0 2
15029: PPUSH
15030: LD_LOC 18
15034: PPUSH
15035: CALL 14438 0 2
15039: AND
15040: DOUBLE
15041: EQUAL
15042: IFTRUE 15046
15044: GO 15063
15046: POP
// begin MyComConstruct ( tfact , d2 ) ;
15047: LD_VAR 0 2
15051: PPUSH
15052: LD_LOC 18
15056: PPUSH
15057: CALL 14497 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15061: GO 15252
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 3
15070: LESS
15071: PUSH
15072: LD_VAR 0 2
15076: PPUSH
15077: LD_LOC 19
15081: PPUSH
15082: CALL 14438 0 2
15086: AND
15087: DOUBLE
15088: EQUAL
15089: IFTRUE 15093
15091: GO 15110
15093: POP
// begin MyComConstruct ( tfact , d3 ) ;
15094: LD_VAR 0 2
15098: PPUSH
15099: LD_LOC 19
15103: PPUSH
15104: CALL 14497 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15108: GO 15252
15110: LD_VAR 0 4
15114: PUSH
15115: LD_INT 2
15117: LESS
15118: PUSH
15119: LD_VAR 0 2
15123: PPUSH
15124: LD_LOC 21
15128: PPUSH
15129: CALL 14438 0 2
15133: AND
15134: DOUBLE
15135: EQUAL
15136: IFTRUE 15140
15138: GO 15157
15140: POP
// begin MyComConstruct ( tfact , d6 ) ;
15141: LD_VAR 0 2
15145: PPUSH
15146: LD_LOC 21
15150: PPUSH
15151: CALL 14497 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15155: GO 15252
15157: LD_VAR 0 4
15161: PUSH
15162: LD_INT 3
15164: LESS
15165: PUSH
15166: LD_VAR 0 2
15170: PPUSH
15171: LD_LOC 20
15175: PPUSH
15176: CALL 14438 0 2
15180: AND
15181: DOUBLE
15182: EQUAL
15183: IFTRUE 15187
15185: GO 15204
15187: POP
// begin MyComConstruct ( tfact , d5 ) ;
15188: LD_VAR 0 2
15192: PPUSH
15193: LD_LOC 20
15197: PPUSH
15198: CALL 14497 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15202: GO 15252
15204: LD_VAR 0 4
15208: PUSH
15209: LD_INT 5
15211: LESS
15212: PUSH
15213: LD_VAR 0 2
15217: PPUSH
15218: LD_LOC 22
15222: PPUSH
15223: CALL 14438 0 2
15227: AND
15228: DOUBLE
15229: EQUAL
15230: IFTRUE 15234
15232: GO 15251
15234: POP
// begin MyComConstruct ( tfact , d7 ) ;
15235: LD_VAR 0 2
15239: PPUSH
15240: LD_LOC 22
15244: PPUSH
15245: CALL 14497 0 2
// end ; end ;
15249: GO 15252
15251: POP
// enable ;
15252: ENABLE
// end ;
15253: PPOPN 4
15255: END
// every 0 0$10 + 0 0$3.4 trigger IsOk ( factories [ 3 ] ) and IsIdle ( factories [ 3 ] ) do var a , tfact , def , att ;
15256: LD_EXP 73
15260: PUSH
15261: LD_INT 3
15263: ARRAY
15264: PPUSH
15265: CALL_OW 302
15269: PUSH
15270: LD_EXP 73
15274: PUSH
15275: LD_INT 3
15277: ARRAY
15278: PPUSH
15279: CALL_OW 316
15283: AND
15284: IFFALSE 15509
15286: GO 15288
15288: DISABLE
15289: LD_INT 0
15291: PPUSH
15292: PPUSH
15293: PPUSH
15294: PPUSH
// begin tfact := factories [ 3 ] ;
15295: LD_ADDR_VAR 0 2
15299: PUSH
15300: LD_EXP 73
15304: PUSH
15305: LD_INT 3
15307: ARRAY
15308: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 3 ] , [ mf_manu ] ) ;
15309: LD_ADDR_VAR 0 3
15313: PUSH
15314: LD_EXP 77
15318: PUSH
15319: LD_INT 3
15321: ARRAY
15322: PPUSH
15323: LD_EXP 61
15327: PUSH
15328: EMPTY
15329: LIST
15330: PPUSH
15331: CALL_OW 72
15335: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 3 ] , [ mf_comp ] ) ;
15336: LD_ADDR_VAR 0 4
15340: PUSH
15341: LD_EXP 77
15345: PUSH
15346: LD_INT 3
15348: ARRAY
15349: PPUSH
15350: LD_EXP 60
15354: PUSH
15355: EMPTY
15356: LIST
15357: PPUSH
15358: CALL_OW 72
15362: ST_TO_ADDR
// case true of def < 1 and MyCanBeConstructed ( tfact , d2 ) :
15363: LD_INT 1
15365: PUSH
15366: LD_VAR 0 3
15370: PUSH
15371: LD_INT 1
15373: LESS
15374: PUSH
15375: LD_VAR 0 2
15379: PPUSH
15380: LD_LOC 18
15384: PPUSH
15385: CALL 14438 0 2
15389: AND
15390: DOUBLE
15391: EQUAL
15392: IFTRUE 15396
15394: GO 15413
15396: POP
// begin MyComConstruct ( tfact , d2 ) ;
15397: LD_VAR 0 2
15401: PPUSH
15402: LD_LOC 18
15406: PPUSH
15407: CALL 14497 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15411: GO 15508
15413: LD_VAR 0 4
15417: PUSH
15418: LD_INT 2
15420: LESS
15421: PUSH
15422: LD_VAR 0 2
15426: PPUSH
15427: LD_LOC 21
15431: PPUSH
15432: CALL 14438 0 2
15436: AND
15437: DOUBLE
15438: EQUAL
15439: IFTRUE 15443
15441: GO 15460
15443: POP
// begin MyComConstruct ( tfact , d6 ) ;
15444: LD_VAR 0 2
15448: PPUSH
15449: LD_LOC 21
15453: PPUSH
15454: CALL 14497 0 2
// end ; att < 4 and MyCanBeConstructed ( tfact , d7 ) :
15458: GO 15508
15460: LD_VAR 0 4
15464: PUSH
15465: LD_INT 4
15467: LESS
15468: PUSH
15469: LD_VAR 0 2
15473: PPUSH
15474: LD_LOC 22
15478: PPUSH
15479: CALL 14438 0 2
15483: AND
15484: DOUBLE
15485: EQUAL
15486: IFTRUE 15490
15488: GO 15507
15490: POP
// begin MyComConstruct ( tfact , d7 ) ;
15491: LD_VAR 0 2
15495: PPUSH
15496: LD_LOC 22
15500: PPUSH
15501: CALL 14497 0 2
// end ; end ;
15505: GO 15508
15507: POP
// enable ;
15508: ENABLE
// end ;
15509: PPOPN 4
15511: END
// every 0 0$10 + 0 0$4.5 trigger IsOk ( factories [ 4 ] ) and IsIdle ( factories [ 4 ] ) do var a , tfact , def , att ;
15512: LD_EXP 73
15516: PUSH
15517: LD_INT 4
15519: ARRAY
15520: PPUSH
15521: CALL_OW 302
15525: PUSH
15526: LD_EXP 73
15530: PUSH
15531: LD_INT 4
15533: ARRAY
15534: PPUSH
15535: CALL_OW 316
15539: AND
15540: IFFALSE 15812
15542: GO 15544
15544: DISABLE
15545: LD_INT 0
15547: PPUSH
15548: PPUSH
15549: PPUSH
15550: PPUSH
// begin tfact := factories [ 4 ] ;
15551: LD_ADDR_VAR 0 2
15555: PUSH
15556: LD_EXP 73
15560: PUSH
15561: LD_INT 4
15563: ARRAY
15564: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 4 ] , [ mf_manu ] ) ;
15565: LD_ADDR_VAR 0 3
15569: PUSH
15570: LD_EXP 77
15574: PUSH
15575: LD_INT 4
15577: ARRAY
15578: PPUSH
15579: LD_EXP 61
15583: PUSH
15584: EMPTY
15585: LIST
15586: PPUSH
15587: CALL_OW 72
15591: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 4 ] , [ mf_comp ] ) ;
15592: LD_ADDR_VAR 0 4
15596: PUSH
15597: LD_EXP 77
15601: PUSH
15602: LD_INT 4
15604: ARRAY
15605: PPUSH
15606: LD_EXP 60
15610: PUSH
15611: EMPTY
15612: LIST
15613: PPUSH
15614: CALL_OW 72
15618: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15619: LD_INT 1
15621: PUSH
15622: LD_VAR 0 3
15626: PUSH
15627: LD_INT 2
15629: LESS
15630: PUSH
15631: LD_VAR 0 2
15635: PPUSH
15636: LD_LOC 18
15640: PPUSH
15641: CALL 14438 0 2
15645: AND
15646: DOUBLE
15647: EQUAL
15648: IFTRUE 15652
15650: GO 15669
15652: POP
// begin MyComConstruct ( tfact , d2 ) ;
15653: LD_VAR 0 2
15657: PPUSH
15658: LD_LOC 18
15662: PPUSH
15663: CALL 14497 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15667: GO 15811
15669: LD_VAR 0 3
15673: PUSH
15674: LD_INT 3
15676: LESS
15677: PUSH
15678: LD_VAR 0 2
15682: PPUSH
15683: LD_LOC 19
15687: PPUSH
15688: CALL 14438 0 2
15692: AND
15693: DOUBLE
15694: EQUAL
15695: IFTRUE 15699
15697: GO 15716
15699: POP
// begin MyComConstruct ( tfact , d3 ) ;
15700: LD_VAR 0 2
15704: PPUSH
15705: LD_LOC 19
15709: PPUSH
15710: CALL 14497 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15714: GO 15811
15716: LD_VAR 0 4
15720: PUSH
15721: LD_INT 2
15723: LESS
15724: PUSH
15725: LD_VAR 0 2
15729: PPUSH
15730: LD_LOC 21
15734: PPUSH
15735: CALL 14438 0 2
15739: AND
15740: DOUBLE
15741: EQUAL
15742: IFTRUE 15746
15744: GO 15763
15746: POP
// begin MyComConstruct ( tfact , d6 ) ;
15747: LD_VAR 0 2
15751: PPUSH
15752: LD_LOC 21
15756: PPUSH
15757: CALL 14497 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15761: GO 15811
15763: LD_VAR 0 4
15767: PUSH
15768: LD_INT 5
15770: LESS
15771: PUSH
15772: LD_VAR 0 2
15776: PPUSH
15777: LD_LOC 22
15781: PPUSH
15782: CALL 14438 0 2
15786: AND
15787: DOUBLE
15788: EQUAL
15789: IFTRUE 15793
15791: GO 15810
15793: POP
// begin MyComConstruct ( tfact , d7 ) ;
15794: LD_VAR 0 2
15798: PPUSH
15799: LD_LOC 22
15803: PPUSH
15804: CALL 14497 0 2
// end ; end ;
15808: GO 15811
15810: POP
// enable ;
15811: ENABLE
// end ;
15812: PPOPN 4
15814: END
// every 0 0$10 + 0 0$5.6 trigger IsOk ( factories [ 5 ] ) and IsIdle ( factories [ 5 ] ) do var a , tfact , def , att ;
15815: LD_EXP 73
15819: PUSH
15820: LD_INT 5
15822: ARRAY
15823: PPUSH
15824: CALL_OW 302
15828: PUSH
15829: LD_EXP 73
15833: PUSH
15834: LD_INT 5
15836: ARRAY
15837: PPUSH
15838: CALL_OW 316
15842: AND
15843: IFFALSE 16162
15845: GO 15847
15847: DISABLE
15848: LD_INT 0
15850: PPUSH
15851: PPUSH
15852: PPUSH
15853: PPUSH
// begin tfact := factories [ 5 ] ;
15854: LD_ADDR_VAR 0 2
15858: PUSH
15859: LD_EXP 73
15863: PUSH
15864: LD_INT 5
15866: ARRAY
15867: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 5 ] , [ mf_manu ] ) ;
15868: LD_ADDR_VAR 0 3
15872: PUSH
15873: LD_EXP 77
15877: PUSH
15878: LD_INT 5
15880: ARRAY
15881: PPUSH
15882: LD_EXP 61
15886: PUSH
15887: EMPTY
15888: LIST
15889: PPUSH
15890: CALL_OW 72
15894: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 5 ] , [ mf_comp ] ) ;
15895: LD_ADDR_VAR 0 4
15899: PUSH
15900: LD_EXP 77
15904: PUSH
15905: LD_INT 5
15907: ARRAY
15908: PPUSH
15909: LD_EXP 60
15913: PUSH
15914: EMPTY
15915: LIST
15916: PPUSH
15917: CALL_OW 72
15921: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15922: LD_INT 1
15924: PUSH
15925: LD_VAR 0 3
15929: PUSH
15930: LD_INT 2
15932: LESS
15933: PUSH
15934: LD_VAR 0 2
15938: PPUSH
15939: LD_LOC 18
15943: PPUSH
15944: CALL 14438 0 2
15948: AND
15949: DOUBLE
15950: EQUAL
15951: IFTRUE 15955
15953: GO 15972
15955: POP
// begin MyComConstruct ( tfact , d2 ) ;
15956: LD_VAR 0 2
15960: PPUSH
15961: LD_LOC 18
15965: PPUSH
15966: CALL 14497 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15970: GO 16161
15972: LD_VAR 0 3
15976: PUSH
15977: LD_INT 3
15979: LESS
15980: PUSH
15981: LD_VAR 0 2
15985: PPUSH
15986: LD_LOC 19
15990: PPUSH
15991: CALL 14438 0 2
15995: AND
15996: DOUBLE
15997: EQUAL
15998: IFTRUE 16002
16000: GO 16019
16002: POP
// begin MyComConstruct ( tfact , d3 ) ;
16003: LD_VAR 0 2
16007: PPUSH
16008: LD_LOC 19
16012: PPUSH
16013: CALL 14497 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
16017: GO 16161
16019: LD_VAR 0 4
16023: PUSH
16024: LD_INT 2
16026: LESS
16027: PUSH
16028: LD_VAR 0 2
16032: PPUSH
16033: LD_LOC 21
16037: PPUSH
16038: CALL 14438 0 2
16042: AND
16043: DOUBLE
16044: EQUAL
16045: IFTRUE 16049
16047: GO 16066
16049: POP
// begin MyComConstruct ( tfact , d6 ) ;
16050: LD_VAR 0 2
16054: PPUSH
16055: LD_LOC 21
16059: PPUSH
16060: CALL 14497 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
16064: GO 16161
16066: LD_VAR 0 4
16070: PUSH
16071: LD_INT 3
16073: LESS
16074: PUSH
16075: LD_VAR 0 2
16079: PPUSH
16080: LD_LOC 20
16084: PPUSH
16085: CALL 14438 0 2
16089: AND
16090: DOUBLE
16091: EQUAL
16092: IFTRUE 16096
16094: GO 16113
16096: POP
// begin MyComConstruct ( tfact , d5 ) ;
16097: LD_VAR 0 2
16101: PPUSH
16102: LD_LOC 20
16106: PPUSH
16107: CALL 14497 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
16111: GO 16161
16113: LD_VAR 0 4
16117: PUSH
16118: LD_INT 5
16120: LESS
16121: PUSH
16122: LD_VAR 0 2
16126: PPUSH
16127: LD_LOC 22
16131: PPUSH
16132: CALL 14438 0 2
16136: AND
16137: DOUBLE
16138: EQUAL
16139: IFTRUE 16143
16141: GO 16160
16143: POP
// begin MyComConstruct ( tfact , d7 ) ;
16144: LD_VAR 0 2
16148: PPUSH
16149: LD_LOC 22
16153: PPUSH
16154: CALL 14497 0 2
// end ; end ;
16158: GO 16161
16160: POP
// enable ;
16161: ENABLE
// end ; end_of_file
16162: PPOPN 4
16164: END
// var builds ; var aici ; var in_depots ; var abase ; export hlavouni ; var upgradeable ; var trough_upgrade ; export function inicializace_ai_b_build ; begin
16165: LD_INT 0
16167: PPUSH
// upgradeable := [ b_depot , b_workshop , b_armoury , b_lab , b_lab_half , b_lab ] ;
16168: LD_ADDR_LOC 27
16172: PUSH
16173: LD_INT 0
16175: PUSH
16176: LD_INT 2
16178: PUSH
16179: LD_INT 4
16181: PUSH
16182: LD_INT 6
16184: PUSH
16185: LD_INT 7
16187: PUSH
16188: LD_INT 6
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: LIST
16195: LIST
16196: LIST
16197: LIST
16198: ST_TO_ADDR
// trough_upgrade := [ b_warehouse , b_factory , b_barracks , b_lab_half , b_lab_full , b_lab_full ] ;
16199: LD_ADDR_LOC 28
16203: PUSH
16204: LD_INT 1
16206: PUSH
16207: LD_INT 3
16209: PUSH
16210: LD_INT 5
16212: PUSH
16213: LD_INT 7
16215: PUSH
16216: LD_INT 8
16218: PUSH
16219: LD_INT 8
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// abase := [ abase1 , abase2 , abase3 , abase4 , abase5 ] ;
16230: LD_ADDR_LOC 26
16234: PUSH
16235: LD_INT 5
16237: PUSH
16238: LD_INT 4
16240: PUSH
16241: LD_INT 3
16243: PUSH
16244: LD_INT 2
16246: PUSH
16247: LD_INT 1
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: ST_TO_ADDR
// aici := [ [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 6 ] , [ 3 , class_scientistic , 6 ] , [ 8 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] , [ [ 1 , class_engineer , 8 ] , [ 3 , class_scientistic , 8 ] , [ 8 , class_soldier , 8 ] , [ 3 , class_mechanic , 8 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 3 , class_scientistic , 5 ] , [ 5 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 0 , class_scientistic , 4 ] , [ 2 , class_soldier , 4 ] , [ 1 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 4 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 4 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 4 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 1 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 1 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ] ;
16257: LD_ADDR_LOC 24
16261: PUSH
16262: LD_INT 1
16264: PUSH
16265: LD_INT 2
16267: PUSH
16268: LD_INT 4
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: LIST
16275: PUSH
16276: LD_INT 3
16278: PUSH
16279: LD_INT 4
16281: PUSH
16282: LD_INT 4
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: LIST
16289: PUSH
16290: LD_INT 8
16292: PUSH
16293: LD_INT 1
16295: PUSH
16296: LD_INT 4
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: LIST
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: LD_INT 3
16309: PUSH
16310: LD_INT 4
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: PUSH
16324: LD_INT 1
16326: PUSH
16327: LD_INT 2
16329: PUSH
16330: LD_INT 6
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: LIST
16337: PUSH
16338: LD_INT 3
16340: PUSH
16341: LD_INT 4
16343: PUSH
16344: LD_INT 6
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: LIST
16351: PUSH
16352: LD_INT 8
16354: PUSH
16355: LD_INT 1
16357: PUSH
16358: LD_INT 6
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 3
16368: PUSH
16369: LD_INT 3
16371: PUSH
16372: LD_INT 6
16374: PUSH
16375: EMPTY
16376: LIST
16377: LIST
16378: LIST
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 1
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 8
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: LIST
16399: PUSH
16400: LD_INT 3
16402: PUSH
16403: LD_INT 4
16405: PUSH
16406: LD_INT 8
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: LIST
16413: PUSH
16414: LD_INT 8
16416: PUSH
16417: LD_INT 1
16419: PUSH
16420: LD_INT 8
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: LIST
16427: PUSH
16428: LD_INT 3
16430: PUSH
16431: LD_INT 3
16433: PUSH
16434: LD_INT 8
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: LIST
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: PUSH
16453: LD_OWVAR 67
16457: ARRAY
16458: PUSH
16459: LD_INT 1
16461: PUSH
16462: LD_INT 2
16464: PUSH
16465: LD_INT 4
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: LIST
16472: PUSH
16473: LD_INT 3
16475: PUSH
16476: LD_INT 4
16478: PUSH
16479: LD_INT 4
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: LIST
16486: PUSH
16487: LD_INT 5
16489: PUSH
16490: LD_INT 1
16492: PUSH
16493: LD_INT 4
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 3
16503: PUSH
16504: LD_INT 3
16506: PUSH
16507: LD_INT 4
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: LIST
16514: PUSH
16515: EMPTY
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: PUSH
16521: LD_INT 1
16523: PUSH
16524: LD_INT 2
16526: PUSH
16527: LD_INT 4
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 3
16537: PUSH
16538: LD_INT 4
16540: PUSH
16541: LD_INT 4
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 5
16551: PUSH
16552: LD_INT 1
16554: PUSH
16555: LD_INT 4
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: LIST
16562: PUSH
16563: LD_INT 3
16565: PUSH
16566: LD_INT 3
16568: PUSH
16569: LD_INT 4
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: LIST
16576: PUSH
16577: EMPTY
16578: LIST
16579: LIST
16580: LIST
16581: LIST
16582: PUSH
16583: LD_INT 1
16585: PUSH
16586: LD_INT 2
16588: PUSH
16589: LD_INT 5
16591: PUSH
16592: EMPTY
16593: LIST
16594: LIST
16595: LIST
16596: PUSH
16597: LD_INT 3
16599: PUSH
16600: LD_INT 4
16602: PUSH
16603: LD_INT 5
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: LIST
16610: PUSH
16611: LD_INT 5
16613: PUSH
16614: LD_INT 1
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: LIST
16624: PUSH
16625: LD_INT 3
16627: PUSH
16628: LD_INT 3
16630: PUSH
16631: LD_INT 5
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: LIST
16643: LIST
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: LIST
16649: PUSH
16650: LD_OWVAR 67
16654: ARRAY
16655: PUSH
16656: LD_INT 1
16658: PUSH
16659: LD_INT 2
16661: PUSH
16662: LD_INT 4
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 0
16672: PUSH
16673: LD_INT 4
16675: PUSH
16676: LD_INT 4
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: LIST
16683: PUSH
16684: LD_INT 2
16686: PUSH
16687: LD_INT 1
16689: PUSH
16690: LD_INT 4
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: LIST
16697: PUSH
16698: LD_INT 1
16700: PUSH
16701: LD_INT 3
16703: PUSH
16704: LD_INT 4
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: PUSH
16718: LD_INT 1
16720: PUSH
16721: LD_INT 2
16723: PUSH
16724: LD_INT 5
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: LIST
16731: PUSH
16732: LD_INT 0
16734: PUSH
16735: LD_INT 4
16737: PUSH
16738: LD_INT 5
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 2
16748: PUSH
16749: LD_INT 1
16751: PUSH
16752: LD_INT 5
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: PUSH
16760: LD_INT 1
16762: PUSH
16763: LD_INT 3
16765: PUSH
16766: LD_INT 5
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: LIST
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: PUSH
16780: LD_INT 1
16782: PUSH
16783: LD_INT 2
16785: PUSH
16786: LD_INT 5
16788: PUSH
16789: EMPTY
16790: LIST
16791: LIST
16792: LIST
16793: PUSH
16794: LD_INT 0
16796: PUSH
16797: LD_INT 4
16799: PUSH
16800: LD_INT 5
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 2
16810: PUSH
16811: LD_INT 1
16813: PUSH
16814: LD_INT 5
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: LIST
16821: PUSH
16822: LD_INT 1
16824: PUSH
16825: LD_INT 3
16827: PUSH
16828: LD_INT 5
16830: PUSH
16831: EMPTY
16832: LIST
16833: LIST
16834: LIST
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PUSH
16847: LD_OWVAR 67
16851: ARRAY
16852: PUSH
16853: LD_INT 1
16855: PUSH
16856: LD_INT 2
16858: PUSH
16859: LD_INT 4
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 4
16869: PUSH
16870: LD_INT 4
16872: PUSH
16873: LD_INT 4
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: LIST
16880: PUSH
16881: LD_INT 3
16883: PUSH
16884: LD_INT 1
16886: PUSH
16887: LD_INT 4
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: PUSH
16895: LD_INT 3
16897: PUSH
16898: LD_INT 3
16900: PUSH
16901: LD_INT 4
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: PUSH
16909: EMPTY
16910: LIST
16911: LIST
16912: LIST
16913: LIST
16914: PUSH
16915: LD_INT 1
16917: PUSH
16918: LD_INT 2
16920: PUSH
16921: LD_INT 5
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: LIST
16928: PUSH
16929: LD_INT 4
16931: PUSH
16932: LD_INT 4
16934: PUSH
16935: LD_INT 5
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: LIST
16942: PUSH
16943: LD_INT 3
16945: PUSH
16946: LD_INT 1
16948: PUSH
16949: LD_INT 5
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 3
16959: PUSH
16960: LD_INT 3
16962: PUSH
16963: LD_INT 5
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: LIST
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 1
16979: PUSH
16980: LD_INT 2
16982: PUSH
16983: LD_INT 6
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: PUSH
16991: LD_INT 4
16993: PUSH
16994: LD_INT 4
16996: PUSH
16997: LD_INT 6
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: LIST
17004: PUSH
17005: LD_INT 3
17007: PUSH
17008: LD_INT 1
17010: PUSH
17011: LD_INT 6
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_INT 3
17021: PUSH
17022: LD_INT 3
17024: PUSH
17025: LD_INT 6
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: LIST
17043: PUSH
17044: LD_OWVAR 67
17048: ARRAY
17049: PUSH
17050: LD_INT 1
17052: PUSH
17053: LD_INT 2
17055: PUSH
17056: LD_INT 4
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: LIST
17063: PUSH
17064: LD_INT 1
17066: PUSH
17067: LD_INT 4
17069: PUSH
17070: LD_INT 4
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: PUSH
17078: LD_INT 3
17080: PUSH
17081: LD_INT 1
17083: PUSH
17084: LD_INT 4
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: LIST
17091: PUSH
17092: LD_INT 3
17094: PUSH
17095: LD_INT 3
17097: PUSH
17098: LD_INT 4
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: PUSH
17112: LD_INT 1
17114: PUSH
17115: LD_INT 2
17117: PUSH
17118: LD_INT 5
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: LIST
17125: PUSH
17126: LD_INT 1
17128: PUSH
17129: LD_INT 4
17131: PUSH
17132: LD_INT 5
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: LIST
17139: PUSH
17140: LD_INT 3
17142: PUSH
17143: LD_INT 1
17145: PUSH
17146: LD_INT 5
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: LIST
17153: PUSH
17154: LD_INT 3
17156: PUSH
17157: LD_INT 3
17159: PUSH
17160: LD_INT 5
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: LIST
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: PUSH
17174: LD_INT 1
17176: PUSH
17177: LD_INT 2
17179: PUSH
17180: LD_INT 6
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: LIST
17187: PUSH
17188: LD_INT 1
17190: PUSH
17191: LD_INT 4
17193: PUSH
17194: LD_INT 6
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: LIST
17201: PUSH
17202: LD_INT 3
17204: PUSH
17205: LD_INT 1
17207: PUSH
17208: LD_INT 6
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: LIST
17215: PUSH
17216: LD_INT 3
17218: PUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 6
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: LIST
17234: LIST
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: LIST
17240: PUSH
17241: LD_OWVAR 67
17245: ARRAY
17246: PUSH
17247: EMPTY
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: LIST
17253: ST_TO_ADDR
// builds := [ [ [ b_warehouse , 24 , 9 , 3 , [ ] ] , [ b_barracks , 39 , 26 , 5 , [ ] ] , [ b_siberite_power , 9 , 11 , 2 , [ ] ] , [ b_turret , 45 , 20 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 44 , 25 , 2 , [ ru_heavy_gun ] ] , [ b_turret , 26 , 40 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 37 , 39 , 2 , [ ru_heavy_gun ] ] , [ b_bunker , 42 , 21 , 2 , [ ru_gatling_gun ] ] , [ b_bunker , 38 , 36 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 53 , 15 , 2 , [ ru_rocket_launcher ] ] , [ b_lab_full , 10 , 7 , 2 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_full , 34 , 10 , 3 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_factory , 20 , 21 , 2 , [ ] ] , [ b_ext_gun , 24 , 21 , 4 , [ ] ] , [ b_ext_rocket , 20 , 18 , 3 , [ ] ] , [ b_ext_siberium , 20 , 25 , 0 , [ ] ] , [ b_ext_computer , 17 , 21 , 1 , [ ] ] , [ b_ext_track , 16 , 17 , 2 , [ ] ] , [ b_siberite_mine , 20 , 34 , 0 , [ ] ] , [ b_siberite_power , 15 , 5 , 2 , [ ] ] , [ b_oil_mine , 14 , 23 , 2 , [ ] ] , [ b_teleport , 32 , 20 , 3 , [ ] ] ] , [ [ b_factory , 98 , 26 , 5 , [ ] ] , [ b_barracks , 80 , 13 , 0 , [ ] ] , [ b_siberite_power , 97 , 3 , 1 , [ ] ] , [ b_turret , 105 , 35 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 111 , 22 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 115 , 27 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 65 , 3 , 3 , [ ru_rocket_launcher ] , 20 20$0 ] , [ b_turret , 68 , 3 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 71 , 4 , 3 , [ ru_heavy_gun ] ] , [ b_siberite_power , 101 , 4 , 5 , [ ] ] , [ b_turret , 108 , 35 , 2 , [ ru_heavy_gun ] ] , [ b_ext_track , 101 , 26 , 4 , [ ] ] , [ b_ext_gun , 98 , 22 , 3 , [ ] ] , [ b_ext_siberium , 94 , 26 , 1 , [ ] ] , [ b_ext_rocket , 98 , 29 , 0 , [ ] ] , [ b_ext_noncombat , 102 , 30 , 5 , [ ] ] , [ b_warehouse , 86 , 6 , 3 , [ ] ] , [ b_siberite_mine , 102 , 9 , 4 , [ ] ] , [ b_oil_mine , 77 , 3 , 4 , [ ] ] , [ b_lab_full , 100 , 17 , 4 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_half , 94 , 6 , 3 , [ b_lab_computer , b_lab_basic ] ] ] , [ [ b_warehouse , 90 , 141 , 0 , [ ] ] , [ b_barracks , 98 , 133 , 4 , [ ] ] , [ b_siberite_power , 72 , 133 , 2 , [ ] ] , [ b_bunker , 95 , 128 , 0 , [ ru_rocket_launcher ] ] , [ b_bunker , 80 , 122 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 95 , 128 , 0 , [ ru_rocket_launcher ] , 15 15$0 ] , [ b_turret , 80 , 122 , 2 , [ ru_rocket_launcher ] , 17 17$0 ] , [ b_turret , 112 , 154 , 1 , [ ru_rocket_launcher ] , 16 16$0 ] , [ b_turret , 78 , 124 , 2 , [ ru_heavy_gun ] , 20 20$0 ] , [ b_turret , 99 , 130 , 1 , [ ru_heavy_gun ] , 22 22$0 ] , [ b_turret , 112 , 151 , 1 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_factory , 81 , 135 , 5 , [ ] ] , [ b_ext_siberium , 84 , 135 , 4 , [ ] ] , [ b_ext_gun , 85 , 139 , 5 , [ ] ] , [ b_ext_track , 77 , 135 , 1 , [ ] ] , [ b_ext_rocket , 81 , 138 , 0 , [ ] , 14 14$0 ] , [ b_siberite_mine , 71 , 137 , 0 , [ ] ] , [ b_oil_mine , 69 , 133 , 5 , [ ] ] , [ b_lab_half , 102 , 153 , 0 , [ b_lab_computer , b_lab_basic ] , 35 35$0 ] , [ b_lab_full , 97 , 145 , 2 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 74 , 137 , 2 , [ ] ] , [ b_ext_computer , 81 , 131 , 3 , [ ] ] ] , [ [ b_warehouse , 217 , 129 , 3 , [ ] ] , [ b_siberite_power , 233 , 154 , 4 , [ ] ] , [ b_turret , 205 , 123 , 0 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_turret , 200 , 142 , 4 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 135 , 4 , [ ru_heavy_gun ] , 28 28$0 ] , [ b_turret , 201 , 127 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 138 , 4 , [ ru_rocket_launcher ] ] , [ b_turret , 202 , 124 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 209 , 154 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 218 , 123 , 5 , [ ru_rocket_launcher ] ] , [ b_lab_full , 227 , 145 , 2 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_lab_full , 221 , 153 , 4 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 231 , 155 , 4 , [ ] ] , [ b_oil_mine , 224 , 134 , 4 , [ ] ] , [ b_siberite_mine , 224 , 150 , 2 , [ ] ] , [ b_factory , 207 , 141 , 1 , [ ] ] , [ b_ext_computer , 211 , 145 , 5 , [ ] ] , [ b_ext_siberium , 207 , 144 , 0 , [ ] ] , [ b_ext_rocket , 203 , 141 , 1 , [ ] ] , [ b_ext_track , 204 , 138 , 2 , [ ] ] , [ b_ext_gun , 207 , 137 , 3 , [ ] ] , [ b_armoury , 210 , 128 , 2 , [ ] , 35 35$0 ] , [ b_armoury , 210 , 128 , 2 , [ ] ] ] , [ [ b_warehouse , 184 , 73 , 3 , [ ] ] , [ b_barracks , 188 , 94 , 5 , [ ] ] , [ b_turret , 171 , 92 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 177 , 98 , 3 , [ ru_heavy_gun ] ] , [ b_turret , 169 , 69 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 170 , 66 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 184 , 62 , 5 , [ ru_gatling_gun ] ] , [ b_turret , 203 , 102 , 2 , [ ru_rocket_launcher ] , 30 30$0 ] , [ b_turret , 195 , 103 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 200 , 103 , 2 , [ ru_heavy_gun ] ] , [ b_siberite_power , 198 , 90 , 3 , [ ] ] , [ b_siberite_mine , 179 , 70 , 1 , [ ] ] , [ b_factory , 190 , 84 , 4 , [ ] ] , [ b_ext_gun , 190 , 88 , 0 , [ ] ] , [ b_ext_rocket , 193 , 87 , 5 , [ ] ] , [ b_ext_siberium , 194 , 84 , 4 , [ ] ] , [ b_ext_computer , 190 , 81 , 3 , [ ] ] , [ b_lab_full , 176 , 92 , 0 , [ b_lab_siberium , b_lab_basic ] ] , [ b_lab_full , 176 , 82 , 3 , [ b_lab_computer , b_lab_weapon ] ] , [ b_siberite_power , 196 , 92 , 5 , [ ] ] , [ b_siberite_power , 198 , 86 , 1 , [ ] ] , [ b_siberite_mine , 192 , 93 , 0 , [ ] ] ] ] ;
17254: LD_ADDR_LOC 23
17258: PUSH
17259: LD_INT 1
17261: PUSH
17262: LD_INT 24
17264: PUSH
17265: LD_INT 9
17267: PUSH
17268: LD_INT 3
17270: PUSH
17271: EMPTY
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: LIST
17277: LIST
17278: LIST
17279: PUSH
17280: LD_INT 5
17282: PUSH
17283: LD_INT 39
17285: PUSH
17286: LD_INT 26
17288: PUSH
17289: LD_INT 5
17291: PUSH
17292: EMPTY
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: LIST
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 28
17303: PUSH
17304: LD_INT 9
17306: PUSH
17307: LD_INT 11
17309: PUSH
17310: LD_INT 2
17312: PUSH
17313: EMPTY
17314: PUSH
17315: EMPTY
17316: LIST
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: PUSH
17322: LD_INT 33
17324: PUSH
17325: LD_INT 45
17327: PUSH
17328: LD_INT 20
17330: PUSH
17331: LD_INT 2
17333: PUSH
17334: LD_INT 45
17336: PUSH
17337: EMPTY
17338: LIST
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: PUSH
17347: LD_INT 33
17349: PUSH
17350: LD_INT 44
17352: PUSH
17353: LD_INT 25
17355: PUSH
17356: LD_INT 2
17358: PUSH
17359: LD_INT 46
17361: PUSH
17362: EMPTY
17363: LIST
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: LIST
17369: LIST
17370: LIST
17371: PUSH
17372: LD_INT 33
17374: PUSH
17375: LD_INT 26
17377: PUSH
17378: LD_INT 40
17380: PUSH
17381: LD_INT 3
17383: PUSH
17384: LD_INT 45
17386: PUSH
17387: EMPTY
17388: LIST
17389: PUSH
17390: EMPTY
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: PUSH
17397: LD_INT 33
17399: PUSH
17400: LD_INT 37
17402: PUSH
17403: LD_INT 39
17405: PUSH
17406: LD_INT 2
17408: PUSH
17409: LD_INT 46
17411: PUSH
17412: EMPTY
17413: LIST
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: PUSH
17422: LD_INT 32
17424: PUSH
17425: LD_INT 42
17427: PUSH
17428: LD_INT 21
17430: PUSH
17431: LD_INT 2
17433: PUSH
17434: LD_INT 43
17436: PUSH
17437: EMPTY
17438: LIST
17439: PUSH
17440: EMPTY
17441: LIST
17442: LIST
17443: LIST
17444: LIST
17445: LIST
17446: PUSH
17447: LD_INT 32
17449: PUSH
17450: LD_INT 38
17452: PUSH
17453: LD_INT 36
17455: PUSH
17456: LD_INT 2
17458: PUSH
17459: LD_INT 43
17461: PUSH
17462: EMPTY
17463: LIST
17464: PUSH
17465: EMPTY
17466: LIST
17467: LIST
17468: LIST
17469: LIST
17470: LIST
17471: PUSH
17472: LD_INT 33
17474: PUSH
17475: LD_INT 53
17477: PUSH
17478: LD_INT 15
17480: PUSH
17481: LD_INT 2
17483: PUSH
17484: LD_INT 45
17486: PUSH
17487: EMPTY
17488: LIST
17489: PUSH
17490: EMPTY
17491: LIST
17492: LIST
17493: LIST
17494: LIST
17495: LIST
17496: PUSH
17497: LD_INT 8
17499: PUSH
17500: LD_INT 10
17502: PUSH
17503: LD_INT 7
17505: PUSH
17506: LD_INT 2
17508: PUSH
17509: LD_INT 11
17511: PUSH
17512: LD_INT 10
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: PUSH
17526: LD_INT 8
17528: PUSH
17529: LD_INT 34
17531: PUSH
17532: LD_INT 10
17534: PUSH
17535: LD_INT 3
17537: PUSH
17538: LD_INT 12
17540: PUSH
17541: LD_INT 14
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: PUSH
17555: LD_INT 3
17557: PUSH
17558: LD_INT 20
17560: PUSH
17561: LD_INT 21
17563: PUSH
17564: LD_INT 2
17566: PUSH
17567: EMPTY
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: PUSH
17576: LD_INT 17
17578: PUSH
17579: LD_INT 24
17581: PUSH
17582: LD_INT 21
17584: PUSH
17585: LD_INT 4
17587: PUSH
17588: EMPTY
17589: PUSH
17590: EMPTY
17591: LIST
17592: LIST
17593: LIST
17594: LIST
17595: LIST
17596: PUSH
17597: LD_INT 18
17599: PUSH
17600: LD_INT 20
17602: PUSH
17603: LD_INT 18
17605: PUSH
17606: LD_INT 3
17608: PUSH
17609: EMPTY
17610: PUSH
17611: EMPTY
17612: LIST
17613: LIST
17614: LIST
17615: LIST
17616: LIST
17617: PUSH
17618: LD_INT 21
17620: PUSH
17621: LD_INT 20
17623: PUSH
17624: LD_INT 25
17626: PUSH
17627: LD_INT 0
17629: PUSH
17630: EMPTY
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: PUSH
17639: LD_INT 24
17641: PUSH
17642: LD_INT 17
17644: PUSH
17645: LD_INT 21
17647: PUSH
17648: LD_INT 1
17650: PUSH
17651: EMPTY
17652: PUSH
17653: EMPTY
17654: LIST
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: PUSH
17660: LD_INT 16
17662: PUSH
17663: LD_INT 16
17665: PUSH
17666: LD_INT 17
17668: PUSH
17669: LD_INT 2
17671: PUSH
17672: EMPTY
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: LIST
17678: LIST
17679: LIST
17680: PUSH
17681: LD_INT 30
17683: PUSH
17684: LD_INT 20
17686: PUSH
17687: LD_INT 34
17689: PUSH
17690: LD_INT 0
17692: PUSH
17693: EMPTY
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: LIST
17699: LIST
17700: LIST
17701: PUSH
17702: LD_INT 28
17704: PUSH
17705: LD_INT 15
17707: PUSH
17708: LD_INT 5
17710: PUSH
17711: LD_INT 2
17713: PUSH
17714: EMPTY
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: PUSH
17723: LD_INT 29
17725: PUSH
17726: LD_INT 14
17728: PUSH
17729: LD_INT 23
17731: PUSH
17732: LD_INT 2
17734: PUSH
17735: EMPTY
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: LIST
17741: LIST
17742: LIST
17743: PUSH
17744: LD_INT 34
17746: PUSH
17747: LD_INT 32
17749: PUSH
17750: LD_INT 20
17752: PUSH
17753: LD_INT 3
17755: PUSH
17756: EMPTY
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: PUSH
17765: EMPTY
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: PUSH
17789: LD_INT 3
17791: PUSH
17792: LD_INT 98
17794: PUSH
17795: LD_INT 26
17797: PUSH
17798: LD_INT 5
17800: PUSH
17801: EMPTY
17802: PUSH
17803: EMPTY
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 5
17812: PUSH
17813: LD_INT 80
17815: PUSH
17816: LD_INT 13
17818: PUSH
17819: LD_INT 0
17821: PUSH
17822: EMPTY
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: PUSH
17831: LD_INT 28
17833: PUSH
17834: LD_INT 97
17836: PUSH
17837: LD_INT 3
17839: PUSH
17840: LD_INT 1
17842: PUSH
17843: EMPTY
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: LIST
17849: LIST
17850: LIST
17851: PUSH
17852: LD_INT 33
17854: PUSH
17855: LD_INT 105
17857: PUSH
17858: LD_INT 35
17860: PUSH
17861: LD_INT 3
17863: PUSH
17864: LD_INT 45
17866: PUSH
17867: EMPTY
17868: LIST
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: PUSH
17877: LD_INT 33
17879: PUSH
17880: LD_INT 111
17882: PUSH
17883: LD_INT 22
17885: PUSH
17886: LD_INT 2
17888: PUSH
17889: LD_INT 43
17891: PUSH
17892: EMPTY
17893: LIST
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: PUSH
17902: LD_INT 33
17904: PUSH
17905: LD_INT 115
17907: PUSH
17908: LD_INT 27
17910: PUSH
17911: LD_INT 2
17913: PUSH
17914: LD_INT 45
17916: PUSH
17917: EMPTY
17918: LIST
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: LIST
17924: LIST
17925: LIST
17926: PUSH
17927: LD_INT 33
17929: PUSH
17930: LD_INT 65
17932: PUSH
17933: LD_INT 3
17935: PUSH
17936: LD_INT 3
17938: PUSH
17939: LD_INT 45
17941: PUSH
17942: EMPTY
17943: LIST
17944: PUSH
17945: LD_INT 42000
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: LIST
17954: LIST
17955: PUSH
17956: LD_INT 33
17958: PUSH
17959: LD_INT 68
17961: PUSH
17962: LD_INT 3
17964: PUSH
17965: LD_INT 3
17967: PUSH
17968: LD_INT 45
17970: PUSH
17971: EMPTY
17972: LIST
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 33
17983: PUSH
17984: LD_INT 71
17986: PUSH
17987: LD_INT 4
17989: PUSH
17990: LD_INT 3
17992: PUSH
17993: LD_INT 46
17995: PUSH
17996: EMPTY
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: PUSH
18006: LD_INT 28
18008: PUSH
18009: LD_INT 101
18011: PUSH
18012: LD_INT 4
18014: PUSH
18015: LD_INT 5
18017: PUSH
18018: EMPTY
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 33
18029: PUSH
18030: LD_INT 108
18032: PUSH
18033: LD_INT 35
18035: PUSH
18036: LD_INT 2
18038: PUSH
18039: LD_INT 46
18041: PUSH
18042: EMPTY
18043: LIST
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: PUSH
18052: LD_INT 16
18054: PUSH
18055: LD_INT 101
18057: PUSH
18058: LD_INT 26
18060: PUSH
18061: LD_INT 4
18063: PUSH
18064: EMPTY
18065: PUSH
18066: EMPTY
18067: LIST
18068: LIST
18069: LIST
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 17
18075: PUSH
18076: LD_INT 98
18078: PUSH
18079: LD_INT 22
18081: PUSH
18082: LD_INT 3
18084: PUSH
18085: EMPTY
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: LIST
18093: PUSH
18094: LD_INT 21
18096: PUSH
18097: LD_INT 94
18099: PUSH
18100: LD_INT 26
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: PUSH
18108: EMPTY
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: LD_INT 18
18117: PUSH
18118: LD_INT 98
18120: PUSH
18121: LD_INT 29
18123: PUSH
18124: LD_INT 0
18126: PUSH
18127: EMPTY
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: LIST
18133: LIST
18134: LIST
18135: PUSH
18136: LD_INT 19
18138: PUSH
18139: LD_INT 102
18141: PUSH
18142: LD_INT 30
18144: PUSH
18145: LD_INT 5
18147: PUSH
18148: EMPTY
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: LIST
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 1
18159: PUSH
18160: LD_INT 86
18162: PUSH
18163: LD_INT 6
18165: PUSH
18166: LD_INT 3
18168: PUSH
18169: EMPTY
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: LIST
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 30
18180: PUSH
18181: LD_INT 102
18183: PUSH
18184: LD_INT 9
18186: PUSH
18187: LD_INT 4
18189: PUSH
18190: EMPTY
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: LIST
18196: LIST
18197: LIST
18198: PUSH
18199: LD_INT 29
18201: PUSH
18202: LD_INT 77
18204: PUSH
18205: LD_INT 3
18207: PUSH
18208: LD_INT 4
18210: PUSH
18211: EMPTY
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: PUSH
18220: LD_INT 8
18222: PUSH
18223: LD_INT 100
18225: PUSH
18226: LD_INT 17
18228: PUSH
18229: LD_INT 4
18231: PUSH
18232: LD_INT 11
18234: PUSH
18235: LD_INT 10
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: PUSH
18249: LD_INT 7
18251: PUSH
18252: LD_INT 94
18254: PUSH
18255: LD_INT 6
18257: PUSH
18258: LD_INT 3
18260: PUSH
18261: LD_INT 12
18263: PUSH
18264: LD_INT 9
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PUSH
18271: EMPTY
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: LIST
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: LIST
18299: LIST
18300: PUSH
18301: LD_INT 1
18303: PUSH
18304: LD_INT 90
18306: PUSH
18307: LD_INT 141
18309: PUSH
18310: LD_INT 0
18312: PUSH
18313: EMPTY
18314: PUSH
18315: EMPTY
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: PUSH
18322: LD_INT 5
18324: PUSH
18325: LD_INT 98
18327: PUSH
18328: LD_INT 133
18330: PUSH
18331: LD_INT 4
18333: PUSH
18334: EMPTY
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: PUSH
18343: LD_INT 28
18345: PUSH
18346: LD_INT 72
18348: PUSH
18349: LD_INT 133
18351: PUSH
18352: LD_INT 2
18354: PUSH
18355: EMPTY
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: PUSH
18364: LD_INT 32
18366: PUSH
18367: LD_INT 95
18369: PUSH
18370: LD_INT 128
18372: PUSH
18373: LD_INT 0
18375: PUSH
18376: LD_INT 45
18378: PUSH
18379: EMPTY
18380: LIST
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: PUSH
18389: LD_INT 32
18391: PUSH
18392: LD_INT 80
18394: PUSH
18395: LD_INT 122
18397: PUSH
18398: LD_INT 2
18400: PUSH
18401: LD_INT 45
18403: PUSH
18404: EMPTY
18405: LIST
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: PUSH
18414: LD_INT 33
18416: PUSH
18417: LD_INT 95
18419: PUSH
18420: LD_INT 128
18422: PUSH
18423: LD_INT 0
18425: PUSH
18426: LD_INT 45
18428: PUSH
18429: EMPTY
18430: LIST
18431: PUSH
18432: LD_INT 31500
18434: PUSH
18435: EMPTY
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: PUSH
18443: LD_INT 33
18445: PUSH
18446: LD_INT 80
18448: PUSH
18449: LD_INT 122
18451: PUSH
18452: LD_INT 2
18454: PUSH
18455: LD_INT 45
18457: PUSH
18458: EMPTY
18459: LIST
18460: PUSH
18461: LD_INT 35700
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: LIST
18471: PUSH
18472: LD_INT 33
18474: PUSH
18475: LD_INT 112
18477: PUSH
18478: LD_INT 154
18480: PUSH
18481: LD_INT 1
18483: PUSH
18484: LD_INT 45
18486: PUSH
18487: EMPTY
18488: LIST
18489: PUSH
18490: LD_INT 33600
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: PUSH
18501: LD_INT 33
18503: PUSH
18504: LD_INT 78
18506: PUSH
18507: LD_INT 124
18509: PUSH
18510: LD_INT 2
18512: PUSH
18513: LD_INT 46
18515: PUSH
18516: EMPTY
18517: LIST
18518: PUSH
18519: LD_INT 42000
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 33
18532: PUSH
18533: LD_INT 99
18535: PUSH
18536: LD_INT 130
18538: PUSH
18539: LD_INT 1
18541: PUSH
18542: LD_INT 46
18544: PUSH
18545: EMPTY
18546: LIST
18547: PUSH
18548: LD_INT 46200
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: PUSH
18559: LD_INT 33
18561: PUSH
18562: LD_INT 112
18564: PUSH
18565: LD_INT 151
18567: PUSH
18568: LD_INT 1
18570: PUSH
18571: LD_INT 43
18573: PUSH
18574: EMPTY
18575: LIST
18576: PUSH
18577: LD_INT 52500
18579: PUSH
18580: EMPTY
18581: LIST
18582: LIST
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: PUSH
18588: LD_INT 3
18590: PUSH
18591: LD_INT 81
18593: PUSH
18594: LD_INT 135
18596: PUSH
18597: LD_INT 5
18599: PUSH
18600: EMPTY
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: PUSH
18609: LD_INT 21
18611: PUSH
18612: LD_INT 84
18614: PUSH
18615: LD_INT 135
18617: PUSH
18618: LD_INT 4
18620: PUSH
18621: EMPTY
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: PUSH
18630: LD_INT 17
18632: PUSH
18633: LD_INT 85
18635: PUSH
18636: LD_INT 139
18638: PUSH
18639: LD_INT 5
18641: PUSH
18642: EMPTY
18643: PUSH
18644: EMPTY
18645: LIST
18646: LIST
18647: LIST
18648: LIST
18649: LIST
18650: PUSH
18651: LD_INT 16
18653: PUSH
18654: LD_INT 77
18656: PUSH
18657: LD_INT 135
18659: PUSH
18660: LD_INT 1
18662: PUSH
18663: EMPTY
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: LIST
18669: LIST
18670: LIST
18671: PUSH
18672: LD_INT 18
18674: PUSH
18675: LD_INT 81
18677: PUSH
18678: LD_INT 138
18680: PUSH
18681: LD_INT 0
18683: PUSH
18684: EMPTY
18685: PUSH
18686: LD_INT 29400
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: PUSH
18697: LD_INT 30
18699: PUSH
18700: LD_INT 71
18702: PUSH
18703: LD_INT 137
18705: PUSH
18706: LD_INT 0
18708: PUSH
18709: EMPTY
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: LIST
18715: LIST
18716: LIST
18717: PUSH
18718: LD_INT 29
18720: PUSH
18721: LD_INT 69
18723: PUSH
18724: LD_INT 133
18726: PUSH
18727: LD_INT 5
18729: PUSH
18730: EMPTY
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PUSH
18739: LD_INT 7
18741: PUSH
18742: LD_INT 102
18744: PUSH
18745: LD_INT 153
18747: PUSH
18748: LD_INT 0
18750: PUSH
18751: LD_INT 12
18753: PUSH
18754: LD_INT 9
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: PUSH
18761: LD_INT 73500
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 8
18774: PUSH
18775: LD_INT 97
18777: PUSH
18778: LD_INT 145
18780: PUSH
18781: LD_INT 2
18783: PUSH
18784: LD_INT 10
18786: PUSH
18787: LD_INT 11
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: LIST
18800: PUSH
18801: LD_INT 28
18803: PUSH
18804: LD_INT 74
18806: PUSH
18807: LD_INT 137
18809: PUSH
18810: LD_INT 2
18812: PUSH
18813: EMPTY
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 24
18824: PUSH
18825: LD_INT 81
18827: PUSH
18828: LD_INT 131
18830: PUSH
18831: LD_INT 3
18833: PUSH
18834: EMPTY
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: PUSH
18843: EMPTY
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: LIST
18865: LIST
18866: PUSH
18867: LD_INT 1
18869: PUSH
18870: LD_INT 217
18872: PUSH
18873: LD_INT 129
18875: PUSH
18876: LD_INT 3
18878: PUSH
18879: EMPTY
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: PUSH
18888: LD_INT 28
18890: PUSH
18891: LD_INT 233
18893: PUSH
18894: LD_INT 154
18896: PUSH
18897: LD_INT 4
18899: PUSH
18900: EMPTY
18901: PUSH
18902: EMPTY
18903: LIST
18904: LIST
18905: LIST
18906: LIST
18907: LIST
18908: PUSH
18909: LD_INT 33
18911: PUSH
18912: LD_INT 205
18914: PUSH
18915: LD_INT 123
18917: PUSH
18918: LD_INT 0
18920: PUSH
18921: LD_INT 43
18923: PUSH
18924: EMPTY
18925: LIST
18926: PUSH
18927: LD_INT 52500
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: LIST
18937: PUSH
18938: LD_INT 33
18940: PUSH
18941: LD_INT 200
18943: PUSH
18944: LD_INT 142
18946: PUSH
18947: LD_INT 4
18949: PUSH
18950: LD_INT 46
18952: PUSH
18953: EMPTY
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: PUSH
18963: LD_INT 33
18965: PUSH
18966: LD_INT 199
18968: PUSH
18969: LD_INT 135
18971: PUSH
18972: LD_INT 4
18974: PUSH
18975: LD_INT 46
18977: PUSH
18978: EMPTY
18979: LIST
18980: PUSH
18981: LD_INT 58800
18983: PUSH
18984: EMPTY
18985: LIST
18986: LIST
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 33
18994: PUSH
18995: LD_INT 201
18997: PUSH
18998: LD_INT 127
19000: PUSH
19001: LD_INT 5
19003: PUSH
19004: LD_INT 46
19006: PUSH
19007: EMPTY
19008: LIST
19009: PUSH
19010: EMPTY
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: PUSH
19017: LD_INT 33
19019: PUSH
19020: LD_INT 199
19022: PUSH
19023: LD_INT 138
19025: PUSH
19026: LD_INT 4
19028: PUSH
19029: LD_INT 45
19031: PUSH
19032: EMPTY
19033: LIST
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: PUSH
19042: LD_INT 33
19044: PUSH
19045: LD_INT 202
19047: PUSH
19048: LD_INT 124
19050: PUSH
19051: LD_INT 5
19053: PUSH
19054: LD_INT 45
19056: PUSH
19057: EMPTY
19058: LIST
19059: PUSH
19060: EMPTY
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: LIST
19066: PUSH
19067: LD_INT 33
19069: PUSH
19070: LD_INT 209
19072: PUSH
19073: LD_INT 154
19075: PUSH
19076: LD_INT 3
19078: PUSH
19079: LD_INT 45
19081: PUSH
19082: EMPTY
19083: LIST
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: PUSH
19092: LD_INT 33
19094: PUSH
19095: LD_INT 218
19097: PUSH
19098: LD_INT 123
19100: PUSH
19101: LD_INT 5
19103: PUSH
19104: LD_INT 45
19106: PUSH
19107: EMPTY
19108: LIST
19109: PUSH
19110: EMPTY
19111: LIST
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: PUSH
19117: LD_INT 8
19119: PUSH
19120: LD_INT 227
19122: PUSH
19123: LD_INT 145
19125: PUSH
19126: LD_INT 2
19128: PUSH
19129: LD_INT 12
19131: PUSH
19132: LD_INT 14
19134: PUSH
19135: EMPTY
19136: LIST
19137: LIST
19138: PUSH
19139: EMPTY
19140: LIST
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: PUSH
19146: LD_INT 8
19148: PUSH
19149: LD_INT 221
19151: PUSH
19152: LD_INT 153
19154: PUSH
19155: LD_INT 4
19157: PUSH
19158: LD_INT 10
19160: PUSH
19161: LD_INT 11
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 28
19177: PUSH
19178: LD_INT 231
19180: PUSH
19181: LD_INT 155
19183: PUSH
19184: LD_INT 4
19186: PUSH
19187: EMPTY
19188: PUSH
19189: EMPTY
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: PUSH
19196: LD_INT 29
19198: PUSH
19199: LD_INT 224
19201: PUSH
19202: LD_INT 134
19204: PUSH
19205: LD_INT 4
19207: PUSH
19208: EMPTY
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: LIST
19214: LIST
19215: LIST
19216: PUSH
19217: LD_INT 30
19219: PUSH
19220: LD_INT 224
19222: PUSH
19223: LD_INT 150
19225: PUSH
19226: LD_INT 2
19228: PUSH
19229: EMPTY
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: LIST
19237: PUSH
19238: LD_INT 3
19240: PUSH
19241: LD_INT 207
19243: PUSH
19244: LD_INT 141
19246: PUSH
19247: LD_INT 1
19249: PUSH
19250: EMPTY
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: LIST
19256: LIST
19257: LIST
19258: PUSH
19259: LD_INT 24
19261: PUSH
19262: LD_INT 211
19264: PUSH
19265: LD_INT 145
19267: PUSH
19268: LD_INT 5
19270: PUSH
19271: EMPTY
19272: PUSH
19273: EMPTY
19274: LIST
19275: LIST
19276: LIST
19277: LIST
19278: LIST
19279: PUSH
19280: LD_INT 21
19282: PUSH
19283: LD_INT 207
19285: PUSH
19286: LD_INT 144
19288: PUSH
19289: LD_INT 0
19291: PUSH
19292: EMPTY
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: PUSH
19301: LD_INT 18
19303: PUSH
19304: LD_INT 203
19306: PUSH
19307: LD_INT 141
19309: PUSH
19310: LD_INT 1
19312: PUSH
19313: EMPTY
19314: PUSH
19315: EMPTY
19316: LIST
19317: LIST
19318: LIST
19319: LIST
19320: LIST
19321: PUSH
19322: LD_INT 16
19324: PUSH
19325: LD_INT 204
19327: PUSH
19328: LD_INT 138
19330: PUSH
19331: LD_INT 2
19333: PUSH
19334: EMPTY
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: LIST
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 17
19345: PUSH
19346: LD_INT 207
19348: PUSH
19349: LD_INT 137
19351: PUSH
19352: LD_INT 3
19354: PUSH
19355: EMPTY
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: PUSH
19364: LD_INT 4
19366: PUSH
19367: LD_INT 210
19369: PUSH
19370: LD_INT 128
19372: PUSH
19373: LD_INT 2
19375: PUSH
19376: EMPTY
19377: PUSH
19378: LD_INT 73500
19380: PUSH
19381: EMPTY
19382: LIST
19383: LIST
19384: LIST
19385: LIST
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 4
19391: PUSH
19392: LD_INT 210
19394: PUSH
19395: LD_INT 128
19397: PUSH
19398: LD_INT 2
19400: PUSH
19401: EMPTY
19402: PUSH
19403: EMPTY
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: PUSH
19435: LD_INT 1
19437: PUSH
19438: LD_INT 184
19440: PUSH
19441: LD_INT 73
19443: PUSH
19444: LD_INT 3
19446: PUSH
19447: EMPTY
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: PUSH
19456: LD_INT 5
19458: PUSH
19459: LD_INT 188
19461: PUSH
19462: LD_INT 94
19464: PUSH
19465: LD_INT 5
19467: PUSH
19468: EMPTY
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: LIST
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 33
19479: PUSH
19480: LD_INT 171
19482: PUSH
19483: LD_INT 92
19485: PUSH
19486: LD_INT 3
19488: PUSH
19489: LD_INT 45
19491: PUSH
19492: EMPTY
19493: LIST
19494: PUSH
19495: EMPTY
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: PUSH
19502: LD_INT 33
19504: PUSH
19505: LD_INT 177
19507: PUSH
19508: LD_INT 98
19510: PUSH
19511: LD_INT 3
19513: PUSH
19514: LD_INT 46
19516: PUSH
19517: EMPTY
19518: LIST
19519: PUSH
19520: EMPTY
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: PUSH
19527: LD_INT 33
19529: PUSH
19530: LD_INT 169
19532: PUSH
19533: LD_INT 69
19535: PUSH
19536: LD_INT 5
19538: PUSH
19539: LD_INT 46
19541: PUSH
19542: EMPTY
19543: LIST
19544: PUSH
19545: EMPTY
19546: LIST
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: PUSH
19552: LD_INT 33
19554: PUSH
19555: LD_INT 170
19557: PUSH
19558: LD_INT 66
19560: PUSH
19561: LD_INT 5
19563: PUSH
19564: LD_INT 45
19566: PUSH
19567: EMPTY
19568: LIST
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: PUSH
19577: LD_INT 33
19579: PUSH
19580: LD_INT 184
19582: PUSH
19583: LD_INT 62
19585: PUSH
19586: LD_INT 5
19588: PUSH
19589: LD_INT 43
19591: PUSH
19592: EMPTY
19593: LIST
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: LD_INT 33
19604: PUSH
19605: LD_INT 203
19607: PUSH
19608: LD_INT 102
19610: PUSH
19611: LD_INT 2
19613: PUSH
19614: LD_INT 45
19616: PUSH
19617: EMPTY
19618: LIST
19619: PUSH
19620: LD_INT 63000
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 33
19633: PUSH
19634: LD_INT 195
19636: PUSH
19637: LD_INT 103
19639: PUSH
19640: LD_INT 2
19642: PUSH
19643: LD_INT 45
19645: PUSH
19646: EMPTY
19647: LIST
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: PUSH
19656: LD_INT 33
19658: PUSH
19659: LD_INT 200
19661: PUSH
19662: LD_INT 103
19664: PUSH
19665: LD_INT 2
19667: PUSH
19668: LD_INT 46
19670: PUSH
19671: EMPTY
19672: LIST
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: LIST
19678: LIST
19679: LIST
19680: PUSH
19681: LD_INT 28
19683: PUSH
19684: LD_INT 198
19686: PUSH
19687: LD_INT 90
19689: PUSH
19690: LD_INT 3
19692: PUSH
19693: EMPTY
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: PUSH
19702: LD_INT 30
19704: PUSH
19705: LD_INT 179
19707: PUSH
19708: LD_INT 70
19710: PUSH
19711: LD_INT 1
19713: PUSH
19714: EMPTY
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: PUSH
19723: LD_INT 3
19725: PUSH
19726: LD_INT 190
19728: PUSH
19729: LD_INT 84
19731: PUSH
19732: LD_INT 4
19734: PUSH
19735: EMPTY
19736: PUSH
19737: EMPTY
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: PUSH
19744: LD_INT 17
19746: PUSH
19747: LD_INT 190
19749: PUSH
19750: LD_INT 88
19752: PUSH
19753: LD_INT 0
19755: PUSH
19756: EMPTY
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: PUSH
19765: LD_INT 18
19767: PUSH
19768: LD_INT 193
19770: PUSH
19771: LD_INT 87
19773: PUSH
19774: LD_INT 5
19776: PUSH
19777: EMPTY
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: PUSH
19786: LD_INT 21
19788: PUSH
19789: LD_INT 194
19791: PUSH
19792: LD_INT 84
19794: PUSH
19795: LD_INT 4
19797: PUSH
19798: EMPTY
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: PUSH
19807: LD_INT 24
19809: PUSH
19810: LD_INT 190
19812: PUSH
19813: LD_INT 81
19815: PUSH
19816: LD_INT 3
19818: PUSH
19819: EMPTY
19820: PUSH
19821: EMPTY
19822: LIST
19823: LIST
19824: LIST
19825: LIST
19826: LIST
19827: PUSH
19828: LD_INT 8
19830: PUSH
19831: LD_INT 176
19833: PUSH
19834: LD_INT 92
19836: PUSH
19837: LD_INT 0
19839: PUSH
19840: LD_INT 11
19842: PUSH
19843: LD_INT 9
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: PUSH
19857: LD_INT 8
19859: PUSH
19860: LD_INT 176
19862: PUSH
19863: LD_INT 82
19865: PUSH
19866: LD_INT 3
19868: PUSH
19869: LD_INT 12
19871: PUSH
19872: LD_INT 10
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: PUSH
19879: EMPTY
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: PUSH
19886: LD_INT 28
19888: PUSH
19889: LD_INT 196
19891: PUSH
19892: LD_INT 92
19894: PUSH
19895: LD_INT 5
19897: PUSH
19898: EMPTY
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: PUSH
19907: LD_INT 28
19909: PUSH
19910: LD_INT 198
19912: PUSH
19913: LD_INT 86
19915: PUSH
19916: LD_INT 1
19918: PUSH
19919: EMPTY
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 30
19930: PUSH
19931: LD_INT 192
19933: PUSH
19934: LD_INT 93
19936: PUSH
19937: LD_INT 0
19939: PUSH
19940: EMPTY
19941: PUSH
19942: EMPTY
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: ST_TO_ADDR
// in_depots := [ [ 820 , 720 , 421 ] , [ 770 , 620 , 320 ] , [ 680 , 900 , 310 ] , [ 730 , 920 , 240 ] , [ 510 , 810 , 300 ] ] ;
19980: LD_ADDR_LOC 25
19984: PUSH
19985: LD_INT 820
19987: PUSH
19988: LD_INT 720
19990: PUSH
19991: LD_INT 421
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: PUSH
19999: LD_INT 770
20001: PUSH
20002: LD_INT 620
20004: PUSH
20005: LD_INT 320
20007: PUSH
20008: EMPTY
20009: LIST
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 680
20015: PUSH
20016: LD_INT 900
20018: PUSH
20019: LD_INT 310
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: LIST
20026: PUSH
20027: LD_INT 730
20029: PUSH
20030: LD_INT 920
20032: PUSH
20033: LD_INT 240
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: LD_INT 510
20043: PUSH
20044: LD_INT 810
20046: PUSH
20047: LD_INT 300
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: LIST
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: LIST
20059: LIST
20060: LIST
20061: ST_TO_ADDR
// end ;
20062: LD_VAR 0 1
20066: RET
// function UpgradeableTo ( b , up ) ; var i ; begin
20067: LD_INT 0
20069: PPUSH
20070: PPUSH
// result := 0 ;
20071: LD_ADDR_VAR 0 3
20075: PUSH
20076: LD_INT 0
20078: ST_TO_ADDR
// for i := 1 to upgradeable do
20079: LD_ADDR_VAR 0 4
20083: PUSH
20084: DOUBLE
20085: LD_INT 1
20087: DEC
20088: ST_TO_ADDR
20089: LD_LOC 27
20093: PUSH
20094: FOR_TO
20095: IFFALSE 20147
// if b = upgradeable [ i ] and up = trough_upgrade [ i ] then
20097: LD_VAR 0 1
20101: PUSH
20102: LD_LOC 27
20106: PUSH
20107: LD_VAR 0 4
20111: ARRAY
20112: EQUAL
20113: PUSH
20114: LD_VAR 0 2
20118: PUSH
20119: LD_LOC 28
20123: PUSH
20124: LD_VAR 0 4
20128: ARRAY
20129: EQUAL
20130: AND
20131: IFFALSE 20145
// begin result := up ;
20133: LD_ADDR_VAR 0 3
20137: PUSH
20138: LD_VAR 0 2
20142: ST_TO_ADDR
// break ;
20143: GO 20147
// end ;
20145: GO 20094
20147: POP
20148: POP
// end ;
20149: LD_VAR 0 3
20153: RET
// function IsUpgraded ( b ) ; begin
20154: LD_INT 0
20156: PPUSH
// result := 0 ;
20157: LD_ADDR_VAR 0 2
20161: PUSH
20162: LD_INT 0
20164: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20165: LD_VAR 0 1
20169: PUSH
20170: LD_LOC 28
20174: PUSH
20175: LD_INT 1
20177: ARRAY
20178: DOUBLE
20179: EQUAL
20180: IFTRUE 20184
20182: GO 20201
20184: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20185: LD_ADDR_VAR 0 2
20189: PUSH
20190: LD_LOC 27
20194: PUSH
20195: LD_INT 1
20197: ARRAY
20198: ST_TO_ADDR
20199: GO 20326
20201: LD_LOC 28
20205: PUSH
20206: LD_INT 2
20208: ARRAY
20209: DOUBLE
20210: EQUAL
20211: IFTRUE 20215
20213: GO 20232
20215: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20216: LD_ADDR_VAR 0 2
20220: PUSH
20221: LD_LOC 27
20225: PUSH
20226: LD_INT 2
20228: ARRAY
20229: ST_TO_ADDR
20230: GO 20326
20232: LD_LOC 28
20236: PUSH
20237: LD_INT 3
20239: ARRAY
20240: DOUBLE
20241: EQUAL
20242: IFTRUE 20246
20244: GO 20263
20246: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20247: LD_ADDR_VAR 0 2
20251: PUSH
20252: LD_LOC 27
20256: PUSH
20257: LD_INT 3
20259: ARRAY
20260: ST_TO_ADDR
20261: GO 20326
20263: LD_LOC 28
20267: PUSH
20268: LD_INT 4
20270: ARRAY
20271: DOUBLE
20272: EQUAL
20273: IFTRUE 20277
20275: GO 20294
20277: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 5 ] :
20278: LD_ADDR_VAR 0 2
20282: PUSH
20283: LD_LOC 27
20287: PUSH
20288: LD_INT 4
20290: ARRAY
20291: ST_TO_ADDR
20292: GO 20326
20294: LD_LOC 28
20298: PUSH
20299: LD_INT 5
20301: ARRAY
20302: DOUBLE
20303: EQUAL
20304: IFTRUE 20308
20306: GO 20325
20308: POP
// result := upgradeable [ 5 ] ; end ;
20309: LD_ADDR_VAR 0 2
20313: PUSH
20314: LD_LOC 27
20318: PUSH
20319: LD_INT 5
20321: ARRAY
20322: ST_TO_ADDR
20323: GO 20326
20325: POP
// end ;
20326: LD_VAR 0 2
20330: RET
// function BasicFrom ( b ) ; begin
20331: LD_INT 0
20333: PPUSH
// result := b ;
20334: LD_ADDR_VAR 0 2
20338: PUSH
20339: LD_VAR 0 1
20343: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20344: LD_VAR 0 1
20348: PUSH
20349: LD_LOC 28
20353: PUSH
20354: LD_INT 1
20356: ARRAY
20357: DOUBLE
20358: EQUAL
20359: IFTRUE 20363
20361: GO 20380
20363: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20364: LD_ADDR_VAR 0 2
20368: PUSH
20369: LD_LOC 27
20373: PUSH
20374: LD_INT 1
20376: ARRAY
20377: ST_TO_ADDR
20378: GO 20505
20380: LD_LOC 28
20384: PUSH
20385: LD_INT 2
20387: ARRAY
20388: DOUBLE
20389: EQUAL
20390: IFTRUE 20394
20392: GO 20411
20394: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20395: LD_ADDR_VAR 0 2
20399: PUSH
20400: LD_LOC 27
20404: PUSH
20405: LD_INT 2
20407: ARRAY
20408: ST_TO_ADDR
20409: GO 20505
20411: LD_LOC 28
20415: PUSH
20416: LD_INT 3
20418: ARRAY
20419: DOUBLE
20420: EQUAL
20421: IFTRUE 20425
20423: GO 20442
20425: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20426: LD_ADDR_VAR 0 2
20430: PUSH
20431: LD_LOC 27
20435: PUSH
20436: LD_INT 3
20438: ARRAY
20439: ST_TO_ADDR
20440: GO 20505
20442: LD_LOC 28
20446: PUSH
20447: LD_INT 4
20449: ARRAY
20450: DOUBLE
20451: EQUAL
20452: IFTRUE 20456
20454: GO 20473
20456: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 6 ] :
20457: LD_ADDR_VAR 0 2
20461: PUSH
20462: LD_LOC 27
20466: PUSH
20467: LD_INT 4
20469: ARRAY
20470: ST_TO_ADDR
20471: GO 20505
20473: LD_LOC 28
20477: PUSH
20478: LD_INT 6
20480: ARRAY
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20504
20487: POP
// result := upgradeable [ 6 ] ; end ;
20488: LD_ADDR_VAR 0 2
20492: PUSH
20493: LD_LOC 27
20497: PUSH
20498: LD_INT 6
20500: ARRAY
20501: ST_TO_ADDR
20502: GO 20505
20504: POP
// end ;
20505: LD_VAR 0 2
20509: RET
// export function build_map ; var i , j ; begin
20510: LD_INT 0
20512: PPUSH
20513: PPUSH
20514: PPUSH
// for i := 1 to 5 do
20515: LD_ADDR_VAR 0 2
20519: PUSH
20520: DOUBLE
20521: LD_INT 1
20523: DEC
20524: ST_TO_ADDR
20525: LD_INT 5
20527: PUSH
20528: FOR_TO
20529: IFFALSE 20596
// buildings := replace ( buildings , i , place_base ( builds [ i ] , in_depots [ i ] , ai_s [ i ] , ai_nation ) ) ;
20531: LD_ADDR_EXP 75
20535: PUSH
20536: LD_EXP 75
20540: PPUSH
20541: LD_VAR 0 2
20545: PPUSH
20546: LD_LOC 23
20550: PUSH
20551: LD_VAR 0 2
20555: ARRAY
20556: PPUSH
20557: LD_LOC 25
20561: PUSH
20562: LD_VAR 0 2
20566: ARRAY
20567: PPUSH
20568: LD_EXP 23
20572: PUSH
20573: LD_VAR 0 2
20577: ARRAY
20578: PPUSH
20579: LD_EXP 22
20583: PPUSH
20584: CALL 20836 0 4
20588: PPUSH
20589: CALL_OW 1
20593: ST_TO_ADDR
20594: GO 20528
20596: POP
20597: POP
// hlavouni := [ Platonov , Gossudarov , Borodin , Tsaritsyn , Davidov , Eisenstein ] ;
20598: LD_ADDR_EXP 72
20602: PUSH
20603: LD_EXP 42
20607: PUSH
20608: LD_EXP 43
20612: PUSH
20613: LD_EXP 46
20617: PUSH
20618: LD_EXP 47
20622: PUSH
20623: LD_EXP 48
20627: PUSH
20628: LD_EXP 49
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , da ) ;
20641: LD_EXP 42
20645: PPUSH
20646: LD_INT 1
20648: PPUSH
20649: CALL_OW 52
// PlaceHumanInUnit ( Gossudarov , art_cargo ) ;
20653: LD_EXP 43
20657: PPUSH
20658: LD_INT 121
20660: PPUSH
20661: CALL_OW 52
// PlaceHumanInUnit ( Borodin , db ) ;
20665: LD_EXP 46
20669: PPUSH
20670: LD_INT 51
20672: PPUSH
20673: CALL_OW 52
// PlaceHumanInUnit ( Tsaritsyn , dc ) ;
20677: LD_EXP 47
20681: PPUSH
20682: LD_INT 80
20684: PPUSH
20685: CALL_OW 52
// PlaceHumanInUnit ( Davidov , dd ) ;
20689: LD_EXP 48
20693: PPUSH
20694: LD_INT 28
20696: PPUSH
20697: CALL_OW 52
// PlaceHumanInUnit ( Eisenstein , de ) ;
20701: LD_EXP 49
20705: PPUSH
20706: LD_INT 37
20708: PPUSH
20709: CALL_OW 52
// for i := 1 to 5 do
20713: LD_ADDR_VAR 0 2
20717: PUSH
20718: DOUBLE
20719: LD_INT 1
20721: DEC
20722: ST_TO_ADDR
20723: LD_INT 5
20725: PUSH
20726: FOR_TO
20727: IFFALSE 20829
// begin humans := replace ( humans , i , place_aici ( aici [ i ] , abase [ i ] , ai_s [ i ] , ai_nation ) ) ;
20729: LD_ADDR_EXP 76
20733: PUSH
20734: LD_EXP 76
20738: PPUSH
20739: LD_VAR 0 2
20743: PPUSH
20744: LD_LOC 24
20748: PUSH
20749: LD_VAR 0 2
20753: ARRAY
20754: PPUSH
20755: LD_LOC 26
20759: PUSH
20760: LD_VAR 0 2
20764: ARRAY
20765: PPUSH
20766: LD_EXP 23
20770: PUSH
20771: LD_VAR 0 2
20775: ARRAY
20776: PPUSH
20777: LD_EXP 22
20781: PPUSH
20782: CALL 21288 0 4
20786: PPUSH
20787: CALL_OW 1
20791: ST_TO_ADDR
// for j in humans [ i ] do
20792: LD_ADDR_VAR 0 3
20796: PUSH
20797: LD_EXP 76
20801: PUSH
20802: LD_VAR 0 2
20806: ARRAY
20807: PUSH
20808: FOR_IN
20809: IFFALSE 20825
// SetTag ( j , 1 ) ;
20811: LD_VAR 0 3
20815: PPUSH
20816: LD_INT 1
20818: PPUSH
20819: CALL_OW 109
20823: GO 20808
20825: POP
20826: POP
// end ;
20827: GO 20726
20829: POP
20830: POP
// end ;
20831: LD_VAR 0 1
20835: RET
// function place_base ( builds , in_depot , side , nat ) ; var i , base , b , tb , bb , cans , oil , sib ; begin
20836: LD_INT 0
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
20846: PPUSH
// cans := in_depot [ 1 ] ;
20847: LD_ADDR_VAR 0 11
20851: PUSH
20852: LD_VAR 0 2
20856: PUSH
20857: LD_INT 1
20859: ARRAY
20860: ST_TO_ADDR
// oil := in_depot [ 2 ] ;
20861: LD_ADDR_VAR 0 12
20865: PUSH
20866: LD_VAR 0 2
20870: PUSH
20871: LD_INT 2
20873: ARRAY
20874: ST_TO_ADDR
// sib := in_depot [ 3 ] ;
20875: LD_ADDR_VAR 0 13
20879: PUSH
20880: LD_VAR 0 2
20884: PUSH
20885: LD_INT 3
20887: ARRAY
20888: ST_TO_ADDR
// InitUc ;
20889: CALL_OW 18
// InitBc ;
20893: CALL_OW 21
// uc_side := side ;
20897: LD_ADDR_OWVAR 20
20901: PUSH
20902: LD_VAR 0 3
20906: ST_TO_ADDR
// uc_nation := nat ;
20907: LD_ADDR_OWVAR 21
20911: PUSH
20912: LD_VAR 0 4
20916: ST_TO_ADDR
// b := [ ] ;
20917: LD_ADDR_VAR 0 8
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// for i in builds do
20924: LD_ADDR_VAR 0 6
20928: PUSH
20929: LD_VAR 0 1
20933: PUSH
20934: FOR_IN
20935: IFFALSE 21165
// begin if i = 5 then
20937: LD_VAR 0 6
20941: PUSH
20942: LD_INT 5
20944: EQUAL
20945: IFFALSE 21163
// begin tb := get_build ( i [ 2 ] , i [ 3 ] , 0 ) ;
20947: LD_ADDR_VAR 0 9
20951: PUSH
20952: LD_VAR 0 6
20956: PUSH
20957: LD_INT 2
20959: ARRAY
20960: PPUSH
20961: LD_VAR 0 6
20965: PUSH
20966: LD_INT 3
20968: ARRAY
20969: PPUSH
20970: LD_INT 0
20972: PPUSH
20973: CALL 22133 0 3
20977: ST_TO_ADDR
// if not tb then
20978: LD_VAR 0 9
20982: NOT
20983: IFFALSE 21144
// begin bc_type := i [ 1 ] ;
20985: LD_ADDR_OWVAR 42
20989: PUSH
20990: LD_VAR 0 6
20994: PUSH
20995: LD_INT 1
20997: ARRAY
20998: ST_TO_ADDR
// if bc_type = b_lab or bc_type = b_lab_half or bc_type = b_lab_full then
20999: LD_OWVAR 42
21003: PUSH
21004: LD_INT 6
21006: EQUAL
21007: PUSH
21008: LD_OWVAR 42
21012: PUSH
21013: LD_INT 7
21015: EQUAL
21016: OR
21017: PUSH
21018: LD_OWVAR 42
21022: PUSH
21023: LD_INT 8
21025: EQUAL
21026: OR
21027: IFFALSE 21065
// begin bc_kind1 := i [ 5 ] [ 1 ] ;
21029: LD_ADDR_OWVAR 44
21033: PUSH
21034: LD_VAR 0 6
21038: PUSH
21039: LD_INT 5
21041: ARRAY
21042: PUSH
21043: LD_INT 1
21045: ARRAY
21046: ST_TO_ADDR
// bc_kind2 := i [ 5 ] [ 2 ] ;
21047: LD_ADDR_OWVAR 45
21051: PUSH
21052: LD_VAR 0 6
21056: PUSH
21057: LD_INT 5
21059: ARRAY
21060: PUSH
21061: LD_INT 2
21063: ARRAY
21064: ST_TO_ADDR
// end ; tb := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
21065: LD_ADDR_VAR 0 9
21069: PUSH
21070: LD_VAR 0 6
21074: PUSH
21075: LD_INT 2
21077: ARRAY
21078: PPUSH
21079: LD_VAR 0 6
21083: PUSH
21084: LD_INT 3
21086: ARRAY
21087: PPUSH
21088: LD_VAR 0 6
21092: PUSH
21093: LD_INT 4
21095: ARRAY
21096: PPUSH
21097: CALL_OW 47
21101: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
21102: LD_OWVAR 42
21106: PUSH
21107: LD_INT 32
21109: EQUAL
21110: PUSH
21111: LD_OWVAR 42
21115: PUSH
21116: LD_INT 33
21118: EQUAL
21119: OR
21120: IFFALSE 21144
// PlaceWeaponTurret ( tb , i [ 5 ] [ 1 ] ) ;
21122: LD_VAR 0 9
21126: PPUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_INT 5
21134: ARRAY
21135: PUSH
21136: LD_INT 1
21138: ARRAY
21139: PPUSH
21140: CALL_OW 431
// end ; b := b ^ [ tb ] ;
21144: LD_ADDR_VAR 0 8
21148: PUSH
21149: LD_VAR 0 8
21153: PUSH
21154: LD_VAR 0 9
21158: PUSH
21159: EMPTY
21160: LIST
21161: ADD
21162: ST_TO_ADDR
// end ; end ;
21163: GO 20934
21165: POP
21166: POP
// bb := UnitFilter ( b , [ mf_dep ] ) ;
21167: LD_ADDR_VAR 0 10
21171: PUSH
21172: LD_VAR 0 8
21176: PPUSH
21177: LD_EXP 58
21181: PUSH
21182: EMPTY
21183: LIST
21184: PPUSH
21185: CALL_OW 72
21189: ST_TO_ADDR
// for i in bb do
21190: LD_ADDR_VAR 0 6
21194: PUSH
21195: LD_VAR 0 10
21199: PUSH
21200: FOR_IN
21201: IFFALSE 21271
// begin base := GetBase ( i ) ;
21203: LD_ADDR_VAR 0 7
21207: PUSH
21208: LD_VAR 0 6
21212: PPUSH
21213: CALL_OW 274
21217: ST_TO_ADDR
// SetResourceType ( base , mat_cans , cans ) ;
21218: LD_VAR 0 7
21222: PPUSH
21223: LD_INT 1
21225: PPUSH
21226: LD_VAR 0 11
21230: PPUSH
21231: CALL_OW 277
// SetResourceType ( base , mat_oil , oil ) ;
21235: LD_VAR 0 7
21239: PPUSH
21240: LD_INT 2
21242: PPUSH
21243: LD_VAR 0 12
21247: PPUSH
21248: CALL_OW 277
// SetResourceType ( base , mat_siberit , sib ) ;
21252: LD_VAR 0 7
21256: PPUSH
21257: LD_INT 3
21259: PPUSH
21260: LD_VAR 0 13
21264: PPUSH
21265: CALL_OW 277
// end ;
21269: GO 21200
21271: POP
21272: POP
// result := b ;
21273: LD_ADDR_VAR 0 5
21277: PUSH
21278: LD_VAR 0 8
21282: ST_TO_ADDR
// end ;
21283: LD_VAR 0 5
21287: RET
// function place_aici ( aici , area , side , nat ) ; var i , j , a ; begin
21288: LD_INT 0
21290: PPUSH
21291: PPUSH
21292: PPUSH
21293: PPUSH
// InitUc ;
21294: CALL_OW 18
// InitHc ;
21298: CALL_OW 19
// uc_side := side ;
21302: LD_ADDR_OWVAR 20
21306: PUSH
21307: LD_VAR 0 3
21311: ST_TO_ADDR
// uc_nation := nat ;
21312: LD_ADDR_OWVAR 21
21316: PUSH
21317: LD_VAR 0 4
21321: ST_TO_ADDR
// a := [ ] ;
21322: LD_ADDR_VAR 0 8
21326: PUSH
21327: EMPTY
21328: ST_TO_ADDR
// for i in aici do
21329: LD_ADDR_VAR 0 6
21333: PUSH
21334: LD_VAR 0 1
21338: PUSH
21339: FOR_IN
21340: IFFALSE 21414
// begin for j := 1 to i [ 1 ] do
21342: LD_ADDR_VAR 0 7
21346: PUSH
21347: DOUBLE
21348: LD_INT 1
21350: DEC
21351: ST_TO_ADDR
21352: LD_VAR 0 6
21356: PUSH
21357: LD_INT 1
21359: ARRAY
21360: PUSH
21361: FOR_TO
21362: IFFALSE 21410
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
21364: LD_INT 0
21366: PPUSH
21367: LD_VAR 0 6
21371: PUSH
21372: LD_INT 2
21374: ARRAY
21375: PPUSH
21376: LD_VAR 0 6
21380: PUSH
21381: LD_INT 3
21383: ARRAY
21384: PPUSH
21385: CALL_OW 380
// a := a ^ [ CreateHuman ] ;
21389: LD_ADDR_VAR 0 8
21393: PUSH
21394: LD_VAR 0 8
21398: PUSH
21399: CALL_OW 44
21403: PUSH
21404: EMPTY
21405: LIST
21406: ADD
21407: ST_TO_ADDR
// end ;
21408: GO 21361
21410: POP
21411: POP
// end ;
21412: GO 21339
21414: POP
21415: POP
// for i in a do
21416: LD_ADDR_VAR 0 6
21420: PUSH
21421: LD_VAR 0 8
21425: PUSH
21426: FOR_IN
21427: IFFALSE 21448
// PlaceUnitArea ( i , area , false ) ;
21429: LD_VAR 0 6
21433: PPUSH
21434: LD_VAR 0 2
21438: PPUSH
21439: LD_INT 0
21441: PPUSH
21442: CALL_OW 49
21446: GO 21426
21448: POP
21449: POP
// result := a ;
21450: LD_ADDR_VAR 0 5
21454: PUSH
21455: LD_VAR 0 8
21459: ST_TO_ADDR
// end ;
21460: LD_VAR 0 5
21464: RET
// every 0 0$10 + 0 0$0.0 do var i , j , weap , k ;
21465: GO 21467
21467: DISABLE
21468: LD_INT 0
21470: PPUSH
21471: PPUSH
21472: PPUSH
21473: PPUSH
// begin for i in UnitFilter ( fort , [ mf_bunk ] ) do
21474: LD_ADDR_VAR 0 1
21478: PUSH
21479: LD_EXP 81
21483: PPUSH
21484: LD_EXP 57
21488: PUSH
21489: EMPTY
21490: LIST
21491: PPUSH
21492: CALL_OW 72
21496: PUSH
21497: FOR_IN
21498: IFFALSE 21668
// if not GetBWeapon ( i ) then
21500: LD_VAR 0 1
21504: PPUSH
21505: CALL_OW 269
21509: NOT
21510: IFFALSE 21666
// begin weap := 0 ;
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: LD_INT 0
21519: ST_TO_ADDR
// for k := 1 to 5 do
21520: LD_ADDR_VAR 0 4
21524: PUSH
21525: DOUBLE
21526: LD_INT 1
21528: DEC
21529: ST_TO_ADDR
21530: LD_INT 5
21532: PUSH
21533: FOR_TO
21534: IFFALSE 21644
// for j in builds [ k ] do
21536: LD_ADDR_VAR 0 2
21540: PUSH
21541: LD_LOC 23
21545: PUSH
21546: LD_VAR 0 4
21550: ARRAY
21551: PUSH
21552: FOR_IN
21553: IFFALSE 21640
// if GetX ( i ) = j [ 2 ] and GetY ( i ) = j [ 3 ] and GetBType ( i ) = j [ 1 ] then
21555: LD_VAR 0 1
21559: PPUSH
21560: CALL_OW 250
21564: PUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_INT 2
21572: ARRAY
21573: EQUAL
21574: PUSH
21575: LD_VAR 0 1
21579: PPUSH
21580: CALL_OW 251
21584: PUSH
21585: LD_VAR 0 2
21589: PUSH
21590: LD_INT 3
21592: ARRAY
21593: EQUAL
21594: AND
21595: PUSH
21596: LD_VAR 0 1
21600: PPUSH
21601: CALL_OW 266
21605: PUSH
21606: LD_VAR 0 2
21610: PUSH
21611: LD_INT 1
21613: ARRAY
21614: EQUAL
21615: AND
21616: IFFALSE 21638
// begin weap := j [ 5 ] [ 1 ] ;
21618: LD_ADDR_VAR 0 3
21622: PUSH
21623: LD_VAR 0 2
21627: PUSH
21628: LD_INT 5
21630: ARRAY
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: ST_TO_ADDR
// break ;
21636: GO 21640
// end ;
21638: GO 21552
21640: POP
21641: POP
21642: GO 21533
21644: POP
21645: POP
// if weap then
21646: LD_VAR 0 3
21650: IFFALSE 21666
// ComPlaceWeapon ( j , weap ) ;
21652: LD_VAR 0 2
21656: PPUSH
21657: LD_VAR 0 3
21661: PPUSH
21662: CALL_OW 148
// end ;
21666: GO 21497
21668: POP
21669: POP
// enable ;
21670: ENABLE
// end ;
21671: PPOPN 4
21673: END
// every 0 0$10 + 0 0$2.0 do var i , to_up , to_b , co_tam_stoji , k , je_cas_stavet ;
21674: GO 21676
21676: DISABLE
21677: LD_INT 0
21679: PPUSH
21680: PPUSH
21681: PPUSH
21682: PPUSH
21683: PPUSH
21684: PPUSH
// begin for k := 1 to 5 do
21685: LD_ADDR_VAR 0 5
21689: PUSH
21690: DOUBLE
21691: LD_INT 1
21693: DEC
21694: ST_TO_ADDR
21695: LD_INT 5
21697: PUSH
21698: FOR_TO
21699: IFFALSE 22127
// begin if not under_attack [ k ] then
21701: LD_EXP 62
21705: PUSH
21706: LD_VAR 0 5
21710: ARRAY
21711: NOT
21712: IFFALSE 22125
// begin to_b := [ ] ;
21714: LD_ADDR_VAR 0 3
21718: PUSH
21719: EMPTY
21720: ST_TO_ADDR
// to_up := [ ] ;
21721: LD_ADDR_VAR 0 2
21725: PUSH
21726: EMPTY
21727: ST_TO_ADDR
// je_cas_stavet := false ;
21728: LD_ADDR_VAR 0 6
21732: PUSH
21733: LD_INT 0
21735: ST_TO_ADDR
// for i in builds [ k ] do
21736: LD_ADDR_VAR 0 1
21740: PUSH
21741: LD_LOC 23
21745: PUSH
21746: LD_VAR 0 5
21750: ARRAY
21751: PUSH
21752: FOR_IN
21753: IFFALSE 21954
// begin je_cas_stavet := true ;
21755: LD_ADDR_VAR 0 6
21759: PUSH
21760: LD_INT 1
21762: ST_TO_ADDR
// if i = 6 then
21763: LD_VAR 0 1
21767: PUSH
21768: LD_INT 6
21770: EQUAL
21771: IFFALSE 21797
// if i [ 6 ] < tick then
21773: LD_VAR 0 1
21777: PUSH
21778: LD_INT 6
21780: ARRAY
21781: PUSH
21782: LD_OWVAR 1
21786: LESS
21787: IFFALSE 21797
// je_cas_stavet := false ;
21789: LD_ADDR_VAR 0 6
21793: PUSH
21794: LD_INT 0
21796: ST_TO_ADDR
// if je_cas_stavet then
21797: LD_VAR 0 6
21801: IFFALSE 21952
// begin co_tam_stoji := GetBType ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
21803: LD_ADDR_VAR 0 4
21807: PUSH
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 2
21815: ARRAY
21816: PPUSH
21817: LD_VAR 0 1
21821: PUSH
21822: LD_INT 3
21824: ARRAY
21825: PPUSH
21826: LD_INT 0
21828: PPUSH
21829: CALL 22133 0 3
21833: PPUSH
21834: CALL_OW 266
21838: ST_TO_ADDR
// if co_tam_stoji = - 1 then
21839: LD_VAR 0 4
21843: PUSH
21844: LD_INT 1
21846: NEG
21847: EQUAL
21848: IFFALSE 21914
// begin to_b := [ BasicFrom ( i [ 1 ] ) , i [ 2 ] , i [ 3 ] , i [ 4 ] , i [ 5 ] ] ;
21850: LD_ADDR_VAR 0 3
21854: PUSH
21855: LD_VAR 0 1
21859: PUSH
21860: LD_INT 1
21862: ARRAY
21863: PPUSH
21864: CALL 20331 0 1
21868: PUSH
21869: LD_VAR 0 1
21873: PUSH
21874: LD_INT 2
21876: ARRAY
21877: PUSH
21878: LD_VAR 0 1
21882: PUSH
21883: LD_INT 3
21885: ARRAY
21886: PUSH
21887: LD_VAR 0 1
21891: PUSH
21892: LD_INT 4
21894: ARRAY
21895: PUSH
21896: LD_VAR 0 1
21900: PUSH
21901: LD_INT 5
21903: ARRAY
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: LIST
21909: LIST
21910: LIST
21911: ST_TO_ADDR
// end else
21912: GO 21944
// if UpgradeableTo ( co_tam_stoji , i [ 1 ] ) then
21914: LD_VAR 0 4
21918: PPUSH
21919: LD_VAR 0 1
21923: PUSH
21924: LD_INT 1
21926: ARRAY
21927: PPUSH
21928: CALL 20067 0 2
21932: IFFALSE 21944
// begin to_up := i ;
21934: LD_ADDR_VAR 0 2
21938: PUSH
21939: LD_VAR 0 1
21943: ST_TO_ADDR
// end ; if to_b then
21944: LD_VAR 0 3
21948: IFFALSE 21952
// break ;
21950: GO 21954
// end ; end ;
21952: GO 21752
21954: POP
21955: POP
// if to_b then
21956: LD_VAR 0 3
21960: IFFALSE 22082
// ComBuild ( NearestUnitToXY ( UnitFilter ( eng isect humans [ k ] , [ [ f_distxy , to_b [ 2 ] , to_b [ 3 ] , 40 ] ] ) , to_b [ 2 ] , to_b [ 3 ] ) , to_b [ 1 ] , to_b [ 2 ] , to_b [ 3 ] , to_b [ 4 ] ) else
21962: LD_EXP 84
21966: PUSH
21967: LD_EXP 76
21971: PUSH
21972: LD_VAR 0 5
21976: ARRAY
21977: ISECT
21978: PPUSH
21979: LD_INT 92
21981: PUSH
21982: LD_VAR 0 3
21986: PUSH
21987: LD_INT 2
21989: ARRAY
21990: PUSH
21991: LD_VAR 0 3
21995: PUSH
21996: LD_INT 3
21998: ARRAY
21999: PUSH
22000: LD_INT 40
22002: PUSH
22003: EMPTY
22004: LIST
22005: LIST
22006: LIST
22007: LIST
22008: PUSH
22009: EMPTY
22010: LIST
22011: PPUSH
22012: CALL_OW 72
22016: PPUSH
22017: LD_VAR 0 3
22021: PUSH
22022: LD_INT 2
22024: ARRAY
22025: PPUSH
22026: LD_VAR 0 3
22030: PUSH
22031: LD_INT 3
22033: ARRAY
22034: PPUSH
22035: CALL_OW 73
22039: PPUSH
22040: LD_VAR 0 3
22044: PUSH
22045: LD_INT 1
22047: ARRAY
22048: PPUSH
22049: LD_VAR 0 3
22053: PUSH
22054: LD_INT 2
22056: ARRAY
22057: PPUSH
22058: LD_VAR 0 3
22062: PUSH
22063: LD_INT 3
22065: ARRAY
22066: PPUSH
22067: LD_VAR 0 3
22071: PUSH
22072: LD_INT 4
22074: ARRAY
22075: PPUSH
22076: CALL_OW 145
22080: GO 22118
// if to_up then
22082: LD_VAR 0 2
22086: IFFALSE 22118
// ComUpgrade ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
22088: LD_VAR 0 1
22092: PUSH
22093: LD_INT 2
22095: ARRAY
22096: PPUSH
22097: LD_VAR 0 1
22101: PUSH
22102: LD_INT 3
22104: ARRAY
22105: PPUSH
22106: LD_INT 0
22108: PPUSH
22109: CALL 22133 0 3
22113: PPUSH
22114: CALL_OW 146
// wait ( 0 0$1.1 ) ;
22118: LD_INT 39
22120: PPUSH
22121: CALL_OW 67
// end ; end ;
22125: GO 21698
22127: POP
22128: POP
// enable ;
22129: ENABLE
// end ;
22130: PPOPN 6
22132: END
// function get_build ( x , y , btype ) ; begin
22133: LD_INT 0
22135: PPUSH
// result := HexInfo ( x , y ) ;
22136: LD_ADDR_VAR 0 4
22140: PUSH
22141: LD_VAR 0 1
22145: PPUSH
22146: LD_VAR 0 2
22150: PPUSH
22151: CALL_OW 428
22155: ST_TO_ADDR
// if result < 1 then
22156: LD_VAR 0 4
22160: PUSH
22161: LD_INT 1
22163: LESS
22164: IFFALSE 22174
// result := 0 ;
22166: LD_ADDR_VAR 0 4
22170: PUSH
22171: LD_INT 0
22173: ST_TO_ADDR
// if btype then
22174: LD_VAR 0 3
22178: IFFALSE 22230
// if btype <> GetBType ( result ) then
22180: LD_VAR 0 3
22184: PUSH
22185: LD_VAR 0 4
22189: PPUSH
22190: CALL_OW 266
22194: NONEQUAL
22195: IFFALSE 22207
// result := 0 else
22197: LD_ADDR_VAR 0 4
22201: PUSH
22202: LD_INT 0
22204: ST_TO_ADDR
22205: GO 22230
// if unit_building <> GetType ( result ) then
22207: LD_INT 3
22209: PUSH
22210: LD_VAR 0 4
22214: PPUSH
22215: CALL_OW 247
22219: NONEQUAL
22220: IFFALSE 22230
// result := 0 ;
22222: LD_ADDR_VAR 0 4
22226: PUSH
22227: LD_INT 0
22229: ST_TO_ADDR
// end ; end_of_file
22230: LD_VAR 0 4
22234: RET
// var opravit ; export function inicializace_ai_b_repair ; begin
22235: LD_INT 0
22237: PPUSH
// opravit := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22238: LD_ADDR_LOC 29
22242: PUSH
22243: EMPTY
22244: PUSH
22245: EMPTY
22246: PUSH
22247: EMPTY
22248: PUSH
22249: EMPTY
22250: PUSH
22251: EMPTY
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: ST_TO_ADDR
// end ;
22260: LD_VAR 0 1
22264: RET
// function HledejBudovyNaOpravy ( opravit_index , budovy ) ; var zivoty , i , opravit_tmp ; begin
22265: LD_INT 0
22267: PPUSH
22268: PPUSH
22269: PPUSH
22270: PPUSH
// opravit_tmp := [ ] ;
22271: LD_ADDR_VAR 0 6
22275: PUSH
22276: EMPTY
22277: ST_TO_ADDR
// zivoty := [ ] ;
22278: LD_ADDR_VAR 0 4
22282: PUSH
22283: EMPTY
22284: ST_TO_ADDR
// for i in budovy do
22285: LD_ADDR_VAR 0 5
22289: PUSH
22290: LD_VAR 0 2
22294: PUSH
22295: FOR_IN
22296: IFFALSE 22358
// begin if GetLives ( i ) < 1000 then
22298: LD_VAR 0 5
22302: PPUSH
22303: CALL_OW 256
22307: PUSH
22308: LD_INT 1000
22310: LESS
22311: IFFALSE 22356
// begin opravit_tmp := opravit_tmp ^ [ i ] ;
22313: LD_ADDR_VAR 0 6
22317: PUSH
22318: LD_VAR 0 6
22322: PUSH
22323: LD_VAR 0 5
22327: PUSH
22328: EMPTY
22329: LIST
22330: ADD
22331: ST_TO_ADDR
// zivoty := zivoty ^ [ GetLives ( i ) ] ;
22332: LD_ADDR_VAR 0 4
22336: PUSH
22337: LD_VAR 0 4
22341: PUSH
22342: LD_VAR 0 5
22346: PPUSH
22347: CALL_OW 256
22351: PUSH
22352: EMPTY
22353: LIST
22354: ADD
22355: ST_TO_ADDR
// end ; end ;
22356: GO 22295
22358: POP
22359: POP
// if opravit_tmp then
22360: LD_VAR 0 6
22364: IFFALSE 22386
// opravit_tmp := SortListByListAsc ( opravit_tmp , zivoty ) ;
22366: LD_ADDR_VAR 0 6
22370: PUSH
22371: LD_VAR 0 6
22375: PPUSH
22376: LD_VAR 0 4
22380: PPUSH
22381: CALL_OW 76
22385: ST_TO_ADDR
// opravit := Replace ( opravit , opravit_index , opravit_tmp ) ;
22386: LD_ADDR_LOC 29
22390: PUSH
22391: LD_LOC 29
22395: PPUSH
22396: LD_VAR 0 1
22400: PPUSH
22401: LD_VAR 0 6
22405: PPUSH
22406: CALL_OW 1
22410: ST_TO_ADDR
// end ;
22411: LD_VAR 0 3
22415: RET
// every 0 0$5 do var i ;
22416: GO 22418
22418: DISABLE
22419: LD_INT 0
22421: PPUSH
// begin for i := 1 to 5 do
22422: LD_ADDR_VAR 0 1
22426: PUSH
22427: DOUBLE
22428: LD_INT 1
22430: DEC
22431: ST_TO_ADDR
22432: LD_INT 5
22434: PUSH
22435: FOR_TO
22436: IFFALSE 22480
// begin if not under_attack [ i ] then
22438: LD_EXP 62
22442: PUSH
22443: LD_VAR 0 1
22447: ARRAY
22448: NOT
22449: IFFALSE 22478
// begin HledejBudovyNaOpravy ( i , buildings [ i ] ) ;
22451: LD_VAR 0 1
22455: PPUSH
22456: LD_EXP 75
22460: PUSH
22461: LD_VAR 0 1
22465: ARRAY
22466: PPUSH
22467: CALL 22265 0 2
// wait ( 0 0$0.6 ) ;
22471: LD_INT 21
22473: PPUSH
22474: CALL_OW 67
// end ; end ;
22478: GO 22435
22480: POP
22481: POP
// enable ;
22482: ENABLE
// end ;
22483: PPOPN 1
22485: END
// every 0 0$5 do var i ;
22486: GO 22488
22488: DISABLE
22489: LD_INT 0
22491: PPUSH
// begin for i := 1 to 5 do
22492: LD_ADDR_VAR 0 1
22496: PUSH
22497: DOUBLE
22498: LD_INT 1
22500: DEC
22501: ST_TO_ADDR
22502: LD_INT 5
22504: PUSH
22505: FOR_TO
22506: IFFALSE 22655
// begin if opravit [ i ] then
22508: LD_LOC 29
22512: PUSH
22513: LD_VAR 0 1
22517: ARRAY
22518: IFFALSE 22653
// begin ComRepairBuilding ( UnitFilter ( eng , [ [ f_not , [ f_hastask ] ] , [ f_side , GetSide ( opravit [ i ] [ 1 ] ) ] , [ f_dist , opravit [ i ] [ 1 ] , ( ( ( 1000 div 30 ) + 5 ) - GetLives ( opravit [ i ] [ 1 ] ) div 30 ) ] ] ) , opravit [ i ] [ 1 ] ) ;
22520: LD_EXP 84
22524: PPUSH
22525: LD_INT 3
22527: PUSH
22528: LD_INT 60
22530: PUSH
22531: EMPTY
22532: LIST
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 22
22540: PUSH
22541: LD_LOC 29
22545: PUSH
22546: LD_VAR 0 1
22550: ARRAY
22551: PUSH
22552: LD_INT 1
22554: ARRAY
22555: PPUSH
22556: CALL_OW 255
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 91
22567: PUSH
22568: LD_LOC 29
22572: PUSH
22573: LD_VAR 0 1
22577: ARRAY
22578: PUSH
22579: LD_INT 1
22581: ARRAY
22582: PUSH
22583: LD_INT 1000
22585: PUSH
22586: LD_INT 30
22588: DIV
22589: PUSH
22590: LD_INT 5
22592: PLUS
22593: PUSH
22594: LD_LOC 29
22598: PUSH
22599: LD_VAR 0 1
22603: ARRAY
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: PPUSH
22609: CALL_OW 256
22613: PUSH
22614: LD_INT 30
22616: DIV
22617: MINUS
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: LIST
22623: PUSH
22624: EMPTY
22625: LIST
22626: LIST
22627: LIST
22628: PPUSH
22629: CALL_OW 72
22633: PPUSH
22634: LD_LOC 29
22638: PUSH
22639: LD_VAR 0 1
22643: ARRAY
22644: PUSH
22645: LD_INT 1
22647: ARRAY
22648: PPUSH
22649: CALL_OW 130
// end ; end ;
22653: GO 22505
22655: POP
22656: POP
// enable ;
22657: ENABLE
// end ; end_of_file
22658: PPOPN 1
22660: END
// export factories ; export depots ; export buildings ; export humans ; export vehicles ; export attack_units ; export defence_units ; export mcdef_units ; export fort , sol , dep , eng , fact , mec , lab , sci ; export function inicializace_ai ; begin
22661: LD_INT 0
22663: PPUSH
// factories := [ 0 , 0 , 0 , 0 , 0 ] ;
22664: LD_ADDR_EXP 73
22668: PUSH
22669: LD_INT 0
22671: PUSH
22672: LD_INT 0
22674: PUSH
22675: LD_INT 0
22677: PUSH
22678: LD_INT 0
22680: PUSH
22681: LD_INT 0
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: ST_TO_ADDR
// depots := [ 0 , 0 , 0 , 0 , 0 ] ;
22691: LD_ADDR_EXP 74
22695: PUSH
22696: LD_INT 0
22698: PUSH
22699: LD_INT 0
22701: PUSH
22702: LD_INT 0
22704: PUSH
22705: LD_INT 0
22707: PUSH
22708: LD_INT 0
22710: PUSH
22711: EMPTY
22712: LIST
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: ST_TO_ADDR
// buildings := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22718: LD_ADDR_EXP 75
22722: PUSH
22723: EMPTY
22724: PUSH
22725: EMPTY
22726: PUSH
22727: EMPTY
22728: PUSH
22729: EMPTY
22730: PUSH
22731: EMPTY
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: LIST
22737: LIST
22738: LIST
22739: ST_TO_ADDR
// humans := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22740: LD_ADDR_EXP 76
22744: PUSH
22745: EMPTY
22746: PUSH
22747: EMPTY
22748: PUSH
22749: EMPTY
22750: PUSH
22751: EMPTY
22752: PUSH
22753: EMPTY
22754: PUSH
22755: EMPTY
22756: LIST
22757: LIST
22758: LIST
22759: LIST
22760: LIST
22761: ST_TO_ADDR
// vehicles := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22762: LD_ADDR_EXP 77
22766: PUSH
22767: EMPTY
22768: PUSH
22769: EMPTY
22770: PUSH
22771: EMPTY
22772: PUSH
22773: EMPTY
22774: PUSH
22775: EMPTY
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: LIST
22783: ST_TO_ADDR
// attack_units := [ ] ;
22784: LD_ADDR_EXP 78
22788: PUSH
22789: EMPTY
22790: ST_TO_ADDR
// defence_units := [ ] ;
22791: LD_ADDR_EXP 79
22795: PUSH
22796: EMPTY
22797: ST_TO_ADDR
// end ;
22798: LD_VAR 0 1
22802: RET
// export function get_groups ; var i ; begin
22803: LD_INT 0
22805: PPUSH
22806: PPUSH
// fort := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fort ] ) ;
22807: LD_ADDR_EXP 81
22811: PUSH
22812: LD_INT 3
22814: PUSH
22815: LD_INT 22
22817: PUSH
22818: LD_EXP 7
22822: PUSH
22823: EMPTY
22824: LIST
22825: LIST
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: LD_EXP 56
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: PPUSH
22840: CALL_OW 69
22844: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sol ] ) diff hlavouni ;
22845: LD_ADDR_EXP 82
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: LD_INT 22
22855: PUSH
22856: LD_EXP 7
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PUSH
22869: LD_EXP 51
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: PPUSH
22878: CALL_OW 69
22882: PUSH
22883: LD_EXP 72
22887: DIFF
22888: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_dep ] ) ;
22889: LD_ADDR_EXP 83
22893: PUSH
22894: LD_INT 3
22896: PUSH
22897: LD_INT 22
22899: PUSH
22900: LD_EXP 7
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: PUSH
22913: LD_EXP 58
22917: PUSH
22918: EMPTY
22919: LIST
22920: LIST
22921: PPUSH
22922: CALL_OW 69
22926: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_eng ] ) diff hlavouni ;
22927: LD_ADDR_EXP 84
22931: PUSH
22932: LD_INT 3
22934: PUSH
22935: LD_INT 22
22937: PUSH
22938: LD_EXP 7
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: PUSH
22947: EMPTY
22948: LIST
22949: LIST
22950: PUSH
22951: LD_EXP 52
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: PPUSH
22960: CALL_OW 69
22964: PUSH
22965: LD_EXP 72
22969: DIFF
22970: ST_TO_ADDR
// fact := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fact ] ) ;
22971: LD_ADDR_EXP 85
22975: PUSH
22976: LD_INT 3
22978: PUSH
22979: LD_INT 22
22981: PUSH
22982: LD_EXP 7
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: PUSH
22995: LD_EXP 59
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PPUSH
23004: CALL_OW 69
23008: ST_TO_ADDR
// mec := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_mec ] ) diff hlavouni ;
23009: LD_ADDR_EXP 86
23013: PUSH
23014: LD_INT 3
23016: PUSH
23017: LD_INT 22
23019: PUSH
23020: LD_EXP 7
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: PUSH
23033: LD_EXP 53
23037: PUSH
23038: EMPTY
23039: LIST
23040: LIST
23041: PPUSH
23042: CALL_OW 69
23046: PUSH
23047: LD_EXP 72
23051: DIFF
23052: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_lab ] ) ;
23053: LD_ADDR_EXP 87
23057: PUSH
23058: LD_INT 3
23060: PUSH
23061: LD_INT 22
23063: PUSH
23064: LD_EXP 7
23068: PUSH
23069: EMPTY
23070: LIST
23071: LIST
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: LD_EXP 55
23081: PUSH
23082: EMPTY
23083: LIST
23084: LIST
23085: PPUSH
23086: CALL_OW 69
23090: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sci ] ) diff hlavouni ;
23091: LD_ADDR_EXP 88
23095: PUSH
23096: LD_INT 3
23098: PUSH
23099: LD_INT 22
23101: PUSH
23102: LD_EXP 7
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PUSH
23111: EMPTY
23112: LIST
23113: LIST
23114: PUSH
23115: LD_EXP 54
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: PPUSH
23124: CALL_OW 69
23128: PUSH
23129: LD_EXP 72
23133: DIFF
23134: ST_TO_ADDR
// for i := 1 to 5 do
23135: LD_ADDR_VAR 0 2
23139: PUSH
23140: DOUBLE
23141: LD_INT 1
23143: DEC
23144: ST_TO_ADDR
23145: LD_INT 5
23147: PUSH
23148: FOR_TO
23149: IFFALSE 23334
// begin humans := replace ( humans , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_human ] ] ) diff hlavouni ) ;
23151: LD_ADDR_EXP 76
23155: PUSH
23156: LD_EXP 76
23160: PPUSH
23161: LD_VAR 0 2
23165: PPUSH
23166: LD_INT 22
23168: PUSH
23169: LD_EXP 23
23173: PUSH
23174: LD_VAR 0 2
23178: ARRAY
23179: PUSH
23180: EMPTY
23181: LIST
23182: LIST
23183: PUSH
23184: LD_INT 21
23186: PUSH
23187: LD_INT 1
23189: PUSH
23190: EMPTY
23191: LIST
23192: LIST
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: PPUSH
23198: CALL_OW 69
23202: PUSH
23203: LD_EXP 72
23207: DIFF
23208: PPUSH
23209: CALL_OW 1
23213: ST_TO_ADDR
// vehicles := replace ( vehicles , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_vehicle ] ] ) diff art_cargo ) ;
23214: LD_ADDR_EXP 77
23218: PUSH
23219: LD_EXP 77
23223: PPUSH
23224: LD_VAR 0 2
23228: PPUSH
23229: LD_INT 22
23231: PUSH
23232: LD_EXP 23
23236: PUSH
23237: LD_VAR 0 2
23241: ARRAY
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 21
23249: PUSH
23250: LD_INT 2
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PPUSH
23261: CALL_OW 69
23265: PUSH
23266: LD_INT 121
23268: DIFF
23269: PPUSH
23270: CALL_OW 1
23274: ST_TO_ADDR
// buildings := replace ( buildings , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_building ] ] ) ) ;
23275: LD_ADDR_EXP 75
23279: PUSH
23280: LD_EXP 75
23284: PPUSH
23285: LD_VAR 0 2
23289: PPUSH
23290: LD_INT 22
23292: PUSH
23293: LD_EXP 23
23297: PUSH
23298: LD_VAR 0 2
23302: ARRAY
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 21
23310: PUSH
23311: LD_INT 3
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: PPUSH
23322: CALL_OW 69
23326: PPUSH
23327: CALL_OW 1
23331: ST_TO_ADDR
// end ;
23332: GO 23148
23334: POP
23335: POP
// attack_units := FilterAllUnits ( [ [ f_control , control_computer ] ] ) ;
23336: LD_ADDR_EXP 78
23340: PUSH
23341: LD_INT 33
23343: PUSH
23344: LD_INT 3
23346: PUSH
23347: EMPTY
23348: LIST
23349: LIST
23350: PUSH
23351: EMPTY
23352: LIST
23353: PPUSH
23354: CALL_OW 69
23358: ST_TO_ADDR
// defence_units := FilterAllUnits ( [ [ f_control , control_manual ] ] ) diff art_cargo ;
23359: LD_ADDR_EXP 79
23363: PUSH
23364: LD_INT 33
23366: PUSH
23367: LD_INT 1
23369: PUSH
23370: EMPTY
23371: LIST
23372: LIST
23373: PUSH
23374: EMPTY
23375: LIST
23376: PPUSH
23377: CALL_OW 69
23381: PUSH
23382: LD_INT 121
23384: DIFF
23385: ST_TO_ADDR
// write_deps ;
23386: CALL 23399 0 0
// write_facts ;
23390: CALL 23518 0 0
// end ;
23394: LD_VAR 0 1
23398: RET
// export function write_deps ; var i , a ; begin
23399: LD_INT 0
23401: PPUSH
23402: PPUSH
23403: PPUSH
// for i := 1 to 5 do
23404: LD_ADDR_VAR 0 2
23408: PUSH
23409: DOUBLE
23410: LD_INT 1
23412: DEC
23413: ST_TO_ADDR
23414: LD_INT 5
23416: PUSH
23417: FOR_TO
23418: IFFALSE 23511
// begin a := UnitFilter ( buildings [ i ] , [ mf_dep ] ) ;
23420: LD_ADDR_VAR 0 3
23424: PUSH
23425: LD_EXP 75
23429: PUSH
23430: LD_VAR 0 2
23434: ARRAY
23435: PPUSH
23436: LD_EXP 58
23440: PUSH
23441: EMPTY
23442: LIST
23443: PPUSH
23444: CALL_OW 72
23448: ST_TO_ADDR
// if a then
23449: LD_VAR 0 3
23453: IFFALSE 23486
// depots := replace ( depots , i , a [ 1 ] ) else
23455: LD_ADDR_EXP 74
23459: PUSH
23460: LD_EXP 74
23464: PPUSH
23465: LD_VAR 0 2
23469: PPUSH
23470: LD_VAR 0 3
23474: PUSH
23475: LD_INT 1
23477: ARRAY
23478: PPUSH
23479: CALL_OW 1
23483: ST_TO_ADDR
23484: GO 23509
// depots := replace ( depots , i , 0 ) ;
23486: LD_ADDR_EXP 74
23490: PUSH
23491: LD_EXP 74
23495: PPUSH
23496: LD_VAR 0 2
23500: PPUSH
23501: LD_INT 0
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// end ;
23509: GO 23417
23511: POP
23512: POP
// end ;
23513: LD_VAR 0 1
23517: RET
// export function write_facts ; var i , a ; begin
23518: LD_INT 0
23520: PPUSH
23521: PPUSH
23522: PPUSH
// for i := 1 to 5 do
23523: LD_ADDR_VAR 0 2
23527: PUSH
23528: DOUBLE
23529: LD_INT 1
23531: DEC
23532: ST_TO_ADDR
23533: LD_INT 5
23535: PUSH
23536: FOR_TO
23537: IFFALSE 23630
// begin a := UnitFilter ( buildings [ i ] , [ mf_fact ] ) ;
23539: LD_ADDR_VAR 0 3
23543: PUSH
23544: LD_EXP 75
23548: PUSH
23549: LD_VAR 0 2
23553: ARRAY
23554: PPUSH
23555: LD_EXP 59
23559: PUSH
23560: EMPTY
23561: LIST
23562: PPUSH
23563: CALL_OW 72
23567: ST_TO_ADDR
// if a then
23568: LD_VAR 0 3
23572: IFFALSE 23605
// factories := replace ( factories , i , a [ 1 ] ) else
23574: LD_ADDR_EXP 73
23578: PUSH
23579: LD_EXP 73
23583: PPUSH
23584: LD_VAR 0 2
23588: PPUSH
23589: LD_VAR 0 3
23593: PUSH
23594: LD_INT 1
23596: ARRAY
23597: PPUSH
23598: CALL_OW 1
23602: ST_TO_ADDR
23603: GO 23628
// factories := replace ( factories , i , 0 ) ;
23605: LD_ADDR_EXP 73
23609: PUSH
23610: LD_EXP 73
23614: PPUSH
23615: LD_VAR 0 2
23619: PPUSH
23620: LD_INT 0
23622: PPUSH
23623: CALL_OW 1
23627: ST_TO_ADDR
// end ;
23628: GO 23536
23630: POP
23631: POP
// end ;
23632: LD_VAR 0 1
23636: RET
// every 0 0$6 + 0 0$0.9 do var i , j , blds , hums , cars ;
23637: GO 23639
23639: DISABLE
23640: LD_INT 0
23642: PPUSH
23643: PPUSH
23644: PPUSH
23645: PPUSH
23646: PPUSH
// begin hums := [ ] ;
23647: LD_ADDR_VAR 0 4
23651: PUSH
23652: EMPTY
23653: ST_TO_ADDR
// for i in sol do
23654: LD_ADDR_VAR 0 1
23658: PUSH
23659: LD_EXP 82
23663: PUSH
23664: FOR_IN
23665: IFFALSE 23741
// if ( not HasTask ( i ) and not ( GetBType ( IsInUnit ( i ) ) = b_bunker or GetBType ( IsInUnit ( i ) ) = b_breastwork ) ) then
23667: LD_VAR 0 1
23671: PPUSH
23672: CALL_OW 314
23676: NOT
23677: PUSH
23678: LD_VAR 0 1
23682: PPUSH
23683: CALL_OW 310
23687: PPUSH
23688: CALL_OW 266
23692: PUSH
23693: LD_INT 32
23695: EQUAL
23696: PUSH
23697: LD_VAR 0 1
23701: PPUSH
23702: CALL_OW 310
23706: PPUSH
23707: CALL_OW 266
23711: PUSH
23712: LD_INT 31
23714: EQUAL
23715: OR
23716: NOT
23717: AND
23718: IFFALSE 23739
// hums := hums ^ [ i ] ;
23720: LD_ADDR_VAR 0 4
23724: PUSH
23725: LD_VAR 0 4
23729: PUSH
23730: LD_VAR 0 1
23734: PUSH
23735: EMPTY
23736: LIST
23737: ADD
23738: ST_TO_ADDR
23739: GO 23664
23741: POP
23742: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ mf_bunk ] ] ) ;
23743: LD_ADDR_VAR 0 3
23747: PUSH
23748: LD_EXP 81
23752: PPUSH
23753: LD_INT 3
23755: PUSH
23756: LD_INT 59
23758: PUSH
23759: EMPTY
23760: LIST
23761: PUSH
23762: EMPTY
23763: LIST
23764: LIST
23765: PUSH
23766: LD_EXP 57
23770: PUSH
23771: EMPTY
23772: LIST
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PPUSH
23778: CALL_OW 72
23782: ST_TO_ADDR
// for i in blds do
23783: LD_ADDR_VAR 0 1
23787: PUSH
23788: LD_VAR 0 3
23792: PUSH
23793: FOR_IN
23794: IFFALSE 23899
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 40 ] ] ) , i ) ;
23796: LD_ADDR_VAR 0 2
23800: PUSH
23801: LD_VAR 0 4
23805: PPUSH
23806: LD_INT 22
23808: PUSH
23809: LD_VAR 0 1
23813: PPUSH
23814: CALL_OW 255
23818: PUSH
23819: EMPTY
23820: LIST
23821: LIST
23822: PUSH
23823: LD_INT 91
23825: PUSH
23826: LD_VAR 0 1
23830: PUSH
23831: LD_INT 40
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: LIST
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PPUSH
23843: CALL_OW 72
23847: PPUSH
23848: LD_VAR 0 1
23852: PPUSH
23853: CALL_OW 74
23857: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23858: LD_VAR 0 2
23862: PPUSH
23863: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23867: LD_VAR 0 2
23871: PPUSH
23872: LD_VAR 0 1
23876: PPUSH
23877: CALL_OW 180
// hums := hums diff j ;
23881: LD_ADDR_VAR 0 4
23885: PUSH
23886: LD_VAR 0 4
23890: PUSH
23891: LD_VAR 0 2
23895: DIFF
23896: ST_TO_ADDR
// end ;
23897: GO 23793
23899: POP
23900: POP
// cars := UnitFilter ( defence_units , [ f_not , [ f_occupied ] ] ) ;
23901: LD_ADDR_VAR 0 5
23905: PUSH
23906: LD_EXP 79
23910: PPUSH
23911: LD_INT 3
23913: PUSH
23914: LD_INT 59
23916: PUSH
23917: EMPTY
23918: LIST
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: PPUSH
23924: CALL_OW 72
23928: ST_TO_ADDR
// for i in cars do
23929: LD_ADDR_VAR 0 1
23933: PUSH
23934: LD_VAR 0 5
23938: PUSH
23939: FOR_IN
23940: IFFALSE 24045
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
23942: LD_ADDR_VAR 0 2
23946: PUSH
23947: LD_VAR 0 4
23951: PPUSH
23952: LD_INT 22
23954: PUSH
23955: LD_VAR 0 1
23959: PPUSH
23960: CALL_OW 255
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: PUSH
23969: LD_INT 91
23971: PUSH
23972: LD_VAR 0 1
23976: PUSH
23977: LD_INT 30
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: LIST
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 72
23993: PPUSH
23994: LD_VAR 0 1
23998: PPUSH
23999: CALL_OW 74
24003: ST_TO_ADDR
// ComExitBuilding ( j ) ;
24004: LD_VAR 0 2
24008: PPUSH
24009: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
24013: LD_VAR 0 2
24017: PPUSH
24018: LD_VAR 0 1
24022: PPUSH
24023: CALL_OW 180
// hums := hums diff j ;
24027: LD_ADDR_VAR 0 4
24031: PUSH
24032: LD_VAR 0 4
24036: PUSH
24037: LD_VAR 0 2
24041: DIFF
24042: ST_TO_ADDR
// end ;
24043: GO 23939
24045: POP
24046: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
24047: LD_ADDR_VAR 0 3
24051: PUSH
24052: LD_EXP 81
24056: PPUSH
24057: LD_INT 3
24059: PUSH
24060: LD_INT 59
24062: PUSH
24063: EMPTY
24064: LIST
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: PUSH
24070: LD_INT 2
24072: PUSH
24073: LD_INT 30
24075: PUSH
24076: LD_INT 5
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: PUSH
24083: LD_INT 30
24085: PUSH
24086: LD_INT 4
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 72
24106: ST_TO_ADDR
// for i in blds do
24107: LD_ADDR_VAR 0 1
24111: PUSH
24112: LD_VAR 0 3
24116: PUSH
24117: FOR_IN
24118: IFFALSE 24178
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24120: LD_VAR 0 4
24124: PPUSH
24125: LD_INT 22
24127: PUSH
24128: LD_VAR 0 1
24132: PPUSH
24133: CALL_OW 255
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: PUSH
24142: LD_INT 91
24144: PUSH
24145: LD_VAR 0 1
24149: PUSH
24150: LD_INT 30
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: PUSH
24158: EMPTY
24159: LIST
24160: LIST
24161: PPUSH
24162: CALL_OW 72
24166: PPUSH
24167: LD_VAR 0 1
24171: PPUSH
24172: CALL_OW 120
24176: GO 24117
24178: POP
24179: POP
// enable ;
24180: ENABLE
// end ;
24181: PPOPN 5
24183: END
// every 0 0$2 + 0 0$0.5 do var i , j , blds , hums ;
24184: GO 24186
24186: DISABLE
24187: LD_INT 0
24189: PPUSH
24190: PPUSH
24191: PPUSH
24192: PPUSH
// begin blds := dep ;
24193: LD_ADDR_VAR 0 3
24197: PUSH
24198: LD_EXP 83
24202: ST_TO_ADDR
// hums := [ ] ;
24203: LD_ADDR_VAR 0 4
24207: PUSH
24208: EMPTY
24209: ST_TO_ADDR
// for i in eng do
24210: LD_ADDR_VAR 0 1
24214: PUSH
24215: LD_EXP 84
24219: PUSH
24220: FOR_IN
24221: IFFALSE 24268
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24223: LD_VAR 0 1
24227: PPUSH
24228: CALL_OW 315
24232: NOT
24233: PUSH
24234: LD_VAR 0 1
24238: PPUSH
24239: CALL_OW 310
24243: NOT
24244: AND
24245: IFFALSE 24266
// hums := hums ^ [ i ] ;
24247: LD_ADDR_VAR 0 4
24251: PUSH
24252: LD_VAR 0 4
24256: PUSH
24257: LD_VAR 0 1
24261: PUSH
24262: EMPTY
24263: LIST
24264: ADD
24265: ST_TO_ADDR
24266: GO 24220
24268: POP
24269: POP
// for i in blds do
24270: LD_ADDR_VAR 0 1
24274: PUSH
24275: LD_VAR 0 3
24279: PUSH
24280: FOR_IN
24281: IFFALSE 24341
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , GetSide ( i ) ] , [ f_dist , i , 25 ] ] ) , i ) ;
24283: LD_VAR 0 4
24287: PPUSH
24288: LD_INT 22
24290: PUSH
24291: LD_VAR 0 1
24295: PPUSH
24296: CALL_OW 255
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: LD_INT 91
24307: PUSH
24308: LD_VAR 0 1
24312: PUSH
24313: LD_INT 25
24315: PUSH
24316: EMPTY
24317: LIST
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: PPUSH
24325: CALL_OW 72
24329: PPUSH
24330: LD_VAR 0 1
24334: PPUSH
24335: CALL_OW 120
24339: GO 24280
24341: POP
24342: POP
// enable ;
24343: ENABLE
// end ;
24344: PPOPN 4
24346: END
// every 0 0$2 + 0 0$0.7 do var i , j , blds , hums ;
24347: GO 24349
24349: DISABLE
24350: LD_INT 0
24352: PPUSH
24353: PPUSH
24354: PPUSH
24355: PPUSH
// begin blds := fact ;
24356: LD_ADDR_VAR 0 3
24360: PUSH
24361: LD_EXP 85
24365: ST_TO_ADDR
// hums := [ ] ;
24366: LD_ADDR_VAR 0 4
24370: PUSH
24371: EMPTY
24372: ST_TO_ADDR
// for i in mec do
24373: LD_ADDR_VAR 0 1
24377: PUSH
24378: LD_EXP 86
24382: PUSH
24383: FOR_IN
24384: IFFALSE 24431
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24386: LD_VAR 0 1
24390: PPUSH
24391: CALL_OW 315
24395: NOT
24396: PUSH
24397: LD_VAR 0 1
24401: PPUSH
24402: CALL_OW 310
24406: NOT
24407: AND
24408: IFFALSE 24429
// hums := hums ^ [ i ] ;
24410: LD_ADDR_VAR 0 4
24414: PUSH
24415: LD_VAR 0 4
24419: PUSH
24420: LD_VAR 0 1
24424: PUSH
24425: EMPTY
24426: LIST
24427: ADD
24428: ST_TO_ADDR
24429: GO 24383
24431: POP
24432: POP
// for i in blds do
24433: LD_ADDR_VAR 0 1
24437: PUSH
24438: LD_VAR 0 3
24442: PUSH
24443: FOR_IN
24444: IFFALSE 24504
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24446: LD_VAR 0 4
24450: PPUSH
24451: LD_INT 22
24453: PUSH
24454: LD_VAR 0 1
24458: PPUSH
24459: CALL_OW 255
24463: PUSH
24464: EMPTY
24465: LIST
24466: LIST
24467: PUSH
24468: LD_INT 91
24470: PUSH
24471: LD_VAR 0 1
24475: PUSH
24476: LD_INT 30
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: LIST
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PPUSH
24488: CALL_OW 72
24492: PPUSH
24493: LD_VAR 0 1
24497: PPUSH
24498: CALL_OW 120
24502: GO 24443
24504: POP
24505: POP
// enable ;
24506: ENABLE
// end ;
24507: PPOPN 4
24509: END
// every 0 0$2 + 0 0$0.9 do var i , j , blds , hums ;
24510: GO 24512
24512: DISABLE
24513: LD_INT 0
24515: PPUSH
24516: PPUSH
24517: PPUSH
24518: PPUSH
// begin blds := lab ;
24519: LD_ADDR_VAR 0 3
24523: PUSH
24524: LD_EXP 87
24528: ST_TO_ADDR
// hums := [ ] ;
24529: LD_ADDR_VAR 0 4
24533: PUSH
24534: EMPTY
24535: ST_TO_ADDR
// for i in sci do
24536: LD_ADDR_VAR 0 1
24540: PUSH
24541: LD_EXP 88
24545: PUSH
24546: FOR_IN
24547: IFFALSE 24594
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24549: LD_VAR 0 1
24553: PPUSH
24554: CALL_OW 315
24558: NOT
24559: PUSH
24560: LD_VAR 0 1
24564: PPUSH
24565: CALL_OW 310
24569: NOT
24570: AND
24571: IFFALSE 24592
// hums := hums ^ [ i ] ;
24573: LD_ADDR_VAR 0 4
24577: PUSH
24578: LD_VAR 0 4
24582: PUSH
24583: LD_VAR 0 1
24587: PUSH
24588: EMPTY
24589: LIST
24590: ADD
24591: ST_TO_ADDR
24592: GO 24546
24594: POP
24595: POP
// for i in blds do
24596: LD_ADDR_VAR 0 1
24600: PUSH
24601: LD_VAR 0 3
24605: PUSH
24606: FOR_IN
24607: IFFALSE 24667
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24609: LD_VAR 0 4
24613: PPUSH
24614: LD_INT 22
24616: PUSH
24617: LD_VAR 0 1
24621: PPUSH
24622: CALL_OW 255
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 91
24633: PUSH
24634: LD_VAR 0 1
24638: PUSH
24639: LD_INT 30
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: LIST
24646: PUSH
24647: EMPTY
24648: LIST
24649: LIST
24650: PPUSH
24651: CALL_OW 72
24655: PPUSH
24656: LD_VAR 0 1
24660: PPUSH
24661: CALL_OW 120
24665: GO 24606
24667: POP
24668: POP
// enable ;
24669: ENABLE
// end ; end_of_file
24670: PPOPN 4
24672: END
// on UnitDestroyed ( un ) do var h , hinfo , a ;
24673: LD_INT 0
24675: PPUSH
24676: PPUSH
24677: PPUSH
// begin if un = Burlak then
24678: LD_VAR 0 1
24682: PUSH
24683: LD_EXP 41
24687: EQUAL
24688: IFFALSE 24697
// begin YouLost ( Burlak ) ;
24690: LD_STRING Burlak
24692: PPUSH
24693: CALL_OW 104
// end ; if un = Platonov then
24697: LD_VAR 0 1
24701: PUSH
24702: LD_EXP 42
24706: EQUAL
24707: IFFALSE 24732
// begin SurrenderBase ( t_kill , GetSide ( un ) ) ;
24709: LD_EXP 1
24713: PPUSH
24714: LD_VAR 0 1
24718: PPUSH
24719: CALL_OW 255
24723: PPUSH
24724: CALL 30359 0 2
// VyhraPlaton ;
24728: CALL 358 0 0
// end ; if GetSide ( un ) <> you then
24732: LD_VAR 0 1
24736: PPUSH
24737: CALL_OW 255
24741: PUSH
24742: LD_EXP 7
24746: NONEQUAL
24747: IFFALSE 24776
// begin remove_from_vehicles ( un ) ;
24749: LD_VAR 0 1
24753: PPUSH
24754: CALL 28265 0 1
// remove_from_humans ( un ) ;
24758: LD_VAR 0 1
24762: PPUSH
24763: CALL 28027 0 1
// remove_from_builds ( un ) ;
24767: LD_VAR 0 1
24771: PPUSH
24772: CALL 27781 0 1
// end ; if not GetSide ( un ) in your_bases then
24776: LD_VAR 0 1
24780: PPUSH
24781: CALL_OW 255
24785: PUSH
24786: LD_EXP 18
24790: IN
24791: NOT
24792: IFFALSE 24914
// begin if un = Borodin then
24794: LD_VAR 0 1
24798: PUSH
24799: LD_EXP 46
24803: EQUAL
24804: IFFALSE 24824
// begin SurrenderBase ( t_kill , ai_s [ 2 ] ) ;
24806: LD_EXP 1
24810: PPUSH
24811: LD_EXP 23
24815: PUSH
24816: LD_INT 2
24818: ARRAY
24819: PPUSH
24820: CALL 30359 0 2
// end ; if un = Tsaritsyn then
24824: LD_VAR 0 1
24828: PUSH
24829: LD_EXP 47
24833: EQUAL
24834: IFFALSE 24854
// begin SurrenderBase ( t_kill , ai_s [ 3 ] ) ;
24836: LD_EXP 1
24840: PPUSH
24841: LD_EXP 23
24845: PUSH
24846: LD_INT 3
24848: ARRAY
24849: PPUSH
24850: CALL 30359 0 2
// end ; if un = Davidov then
24854: LD_VAR 0 1
24858: PUSH
24859: LD_EXP 48
24863: EQUAL
24864: IFFALSE 24884
// begin SurrenderBase ( t_kill , ai_s [ 4 ] ) ;
24866: LD_EXP 1
24870: PPUSH
24871: LD_EXP 23
24875: PUSH
24876: LD_INT 4
24878: ARRAY
24879: PPUSH
24880: CALL 30359 0 2
// end ; if un = Eisenstein then
24884: LD_VAR 0 1
24888: PUSH
24889: LD_EXP 49
24893: EQUAL
24894: IFFALSE 24914
// begin SurrenderBase ( t_kill , ai_s [ 5 ] ) ;
24896: LD_EXP 1
24900: PPUSH
24901: LD_EXP 23
24905: PUSH
24906: LD_INT 5
24908: ARRAY
24909: PPUSH
24910: CALL 30359 0 2
// end ; end ; if GetSide ( un ) = you then
24914: LD_VAR 0 1
24918: PPUSH
24919: CALL_OW 255
24923: PUSH
24924: LD_EXP 7
24928: EQUAL
24929: IFFALSE 25049
// case true of GetType ( un ) = unit_building :
24931: LD_INT 1
24933: PUSH
24934: LD_VAR 0 1
24938: PPUSH
24939: CALL_OW 247
24943: PUSH
24944: LD_INT 3
24946: EQUAL
24947: DOUBLE
24948: EQUAL
24949: IFTRUE 24953
24951: GO 24972
24953: POP
// your_builds := your_builds diff un ; GetType ( un ) = unit_vehicle :
24954: LD_ADDR_EXP 36
24958: PUSH
24959: LD_EXP 36
24963: PUSH
24964: LD_VAR 0 1
24968: DIFF
24969: ST_TO_ADDR
24970: GO 25049
24972: LD_VAR 0 1
24976: PPUSH
24977: CALL_OW 247
24981: PUSH
24982: LD_INT 2
24984: EQUAL
24985: DOUBLE
24986: EQUAL
24987: IFTRUE 24991
24989: GO 25010
24991: POP
// your_cars := your_cars diff un ; GetType ( un ) = unit_human :
24992: LD_ADDR_EXP 35
24996: PUSH
24997: LD_EXP 35
25001: PUSH
25002: LD_VAR 0 1
25006: DIFF
25007: ST_TO_ADDR
25008: GO 25049
25010: LD_VAR 0 1
25014: PPUSH
25015: CALL_OW 247
25019: PUSH
25020: LD_INT 1
25022: EQUAL
25023: DOUBLE
25024: EQUAL
25025: IFTRUE 25029
25027: GO 25048
25029: POP
// your_humans := your_humans diff un ; end ;
25030: LD_ADDR_EXP 37
25034: PUSH
25035: LD_EXP 37
25039: PUSH
25040: LD_VAR 0 1
25044: DIFF
25045: ST_TO_ADDR
25046: GO 25049
25048: POP
// end ;
25049: PPOPN 4
25051: END
// on UnitGoesToRed ( un ) do var a ;
25052: LD_INT 0
25054: PPUSH
// begin if not GetSide ( un ) in your_bases ^ you then
25055: LD_VAR 0 1
25059: PPUSH
25060: CALL_OW 255
25064: PUSH
25065: LD_EXP 18
25069: PUSH
25070: LD_EXP 7
25074: ADD
25075: IN
25076: NOT
25077: IFFALSE 25310
// begin if GetBType ( un ) in [ b_depot , b_warehouse ] then
25079: LD_VAR 0 1
25083: PPUSH
25084: CALL_OW 266
25088: PUSH
25089: LD_INT 0
25091: PUSH
25092: LD_INT 1
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: IN
25099: IFFALSE 25310
// begin a := FilterAllUnits ( [ [ f_side , GetSide ( un ) ] ] ) ;
25101: LD_ADDR_VAR 0 2
25105: PUSH
25106: LD_INT 22
25108: PUSH
25109: LD_VAR 0 1
25113: PPUSH
25114: CALL_OW 255
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: PUSH
25123: EMPTY
25124: LIST
25125: PPUSH
25126: CALL_OW 69
25130: ST_TO_ADDR
// if GetSide ( un ) = ai_s [ 1 ] and IsDead ( behemoth ) and UnitFilter ( a , [ mf_sol ] ) <= 2 and UnitFilter ( a , [ [ f_type , unit_vehicle ] , [ f_or , [ [ f_control , control_manual ] , [ f_occupied ] ] , [ f_control , control_computer ] ] ] ) <= 1 then
25131: LD_VAR 0 1
25135: PPUSH
25136: CALL_OW 255
25140: PUSH
25141: LD_EXP 23
25145: PUSH
25146: LD_INT 1
25148: ARRAY
25149: EQUAL
25150: PUSH
25151: LD_INT 125
25153: PPUSH
25154: CALL_OW 301
25158: AND
25159: PUSH
25160: LD_VAR 0 2
25164: PPUSH
25165: LD_EXP 51
25169: PUSH
25170: EMPTY
25171: LIST
25172: PPUSH
25173: CALL_OW 72
25177: PUSH
25178: LD_INT 2
25180: LESSEQUAL
25181: AND
25182: PUSH
25183: LD_VAR 0 2
25187: PPUSH
25188: LD_INT 21
25190: PUSH
25191: LD_INT 2
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 2
25200: PUSH
25201: LD_INT 33
25203: PUSH
25204: LD_INT 1
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: PUSH
25211: LD_INT 59
25213: PUSH
25214: EMPTY
25215: LIST
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: LD_INT 33
25223: PUSH
25224: LD_INT 3
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: LIST
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PPUSH
25240: CALL_OW 72
25244: PUSH
25245: LD_INT 1
25247: LESSEQUAL
25248: AND
25249: IFFALSE 25270
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25251: LD_EXP 6
25255: PPUSH
25256: LD_VAR 0 1
25260: PPUSH
25261: CALL_OW 255
25265: PPUSH
25266: CALL 30359 0 2
// if GetSide ( un ) <> ai_s [ 1 ] then
25270: LD_VAR 0 1
25274: PPUSH
25275: CALL_OW 255
25279: PUSH
25280: LD_EXP 23
25284: PUSH
25285: LD_INT 1
25287: ARRAY
25288: NONEQUAL
25289: IFFALSE 25310
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25291: LD_EXP 6
25295: PPUSH
25296: LD_VAR 0 1
25300: PPUSH
25301: CALL_OW 255
25305: PPUSH
25306: CALL 30359 0 2
// end ; end ; end ;
25310: PPOPN 2
25312: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside in ai then
25313: LD_VAR 0 3
25317: PUSH
25318: LD_EXP 24
25322: IN
25323: IFFALSE 25386
// begin remove_from_vehicles ( vehold ) ;
25325: LD_VAR 0 2
25329: PPUSH
25330: CALL 28265 0 1
// if GetAttitude ( origside , you ) = att_neutral then
25334: LD_VAR 0 3
25338: PPUSH
25339: LD_EXP 7
25343: PPUSH
25344: CALL_OW 81
25348: PUSH
25349: LD_INT 0
25351: EQUAL
25352: IFFALSE 25386
// begin ComExitVehicle ( vehnew ) ;
25354: LD_VAR 0 1
25358: PPUSH
25359: CALL_OW 121
// SetSide ( vehnew , origside ) ;
25363: LD_VAR 0 1
25367: PPUSH
25368: LD_VAR 0 3
25372: PPUSH
25373: CALL_OW 235
// add_to_vehicles ( vehnew ) ;
25377: LD_VAR 0 1
25381: PPUSH
25382: CALL 26934 0 1
// end ; end ; if Getside ( vehnew ) in ai then
25386: LD_VAR 0 1
25390: PPUSH
25391: CALL_OW 255
25395: PUSH
25396: LD_EXP 24
25400: IN
25401: IFFALSE 25412
// begin add_to_vehicles ( vehnew ) ;
25403: LD_VAR 0 1
25407: PPUSH
25408: CALL 26934 0 1
// end ; if origside = you then
25412: LD_VAR 0 3
25416: PUSH
25417: LD_EXP 7
25421: EQUAL
25422: IFFALSE 25440
// your_cars := your_cars diff vehold ;
25424: LD_ADDR_EXP 35
25428: PUSH
25429: LD_EXP 35
25433: PUSH
25434: LD_VAR 0 2
25438: DIFF
25439: ST_TO_ADDR
// if GetSide ( vehnew ) = you then
25440: LD_VAR 0 1
25444: PPUSH
25445: CALL_OW 255
25449: PUSH
25450: LD_EXP 7
25454: EQUAL
25455: IFFALSE 25473
// your_cars := your_cars union vehnew ;
25457: LD_ADDR_EXP 35
25461: PUSH
25462: LD_EXP 35
25466: PUSH
25467: LD_VAR 0 1
25471: UNION
25472: ST_TO_ADDR
// if getside ( vehnew ) and GetCargo ( vehnew , mat_artefact ) > 0 then
25473: LD_VAR 0 1
25477: PPUSH
25478: CALL_OW 255
25482: PUSH
25483: LD_VAR 0 1
25487: PPUSH
25488: LD_INT 4
25490: PPUSH
25491: CALL_OW 289
25495: PUSH
25496: LD_INT 0
25498: GREATER
25499: AND
25500: IFFALSE 25510
// maji_artifact := true ;
25502: LD_ADDR_EXP 39
25506: PUSH
25507: LD_INT 1
25509: ST_TO_ADDR
// if origside = you and GetCargo ( vehnew , mat_artefact ) > 0 then
25510: LD_VAR 0 3
25514: PUSH
25515: LD_EXP 7
25519: EQUAL
25520: PUSH
25521: LD_VAR 0 1
25525: PPUSH
25526: LD_INT 4
25528: PPUSH
25529: CALL_OW 289
25533: PUSH
25534: LD_INT 0
25536: GREATER
25537: AND
25538: IFFALSE 25548
// maji_artifact := false ;
25540: LD_ADDR_EXP 39
25544: PUSH
25545: LD_INT 0
25547: ST_TO_ADDR
// end ;
25548: PPOPN 4
25550: END
// on BuildingCaptured ( build , origside , eng ) do begin if origside = you then
25551: LD_VAR 0 2
25555: PUSH
25556: LD_EXP 7
25560: EQUAL
25561: IFFALSE 25579
// begin your_builds := your_builds diff build ;
25563: LD_ADDR_EXP 36
25567: PUSH
25568: LD_EXP 36
25572: PUSH
25573: LD_VAR 0 1
25577: DIFF
25578: ST_TO_ADDR
// end ; if GetSide ( build ) = you then
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL_OW 255
25588: PUSH
25589: LD_EXP 7
25593: EQUAL
25594: IFFALSE 25612
// begin your_builds := your_builds union build ;
25596: LD_ADDR_EXP 36
25600: PUSH
25601: LD_EXP 36
25605: PUSH
25606: LD_VAR 0 1
25610: UNION
25611: ST_TO_ADDR
// end ; if origside in ai then
25612: LD_VAR 0 2
25616: PUSH
25617: LD_EXP 24
25621: IN
25622: IFFALSE 25633
// begin remove_from_builds ( build ) ;
25624: LD_VAR 0 1
25628: PPUSH
25629: CALL 27781 0 1
// end ; if GetSide ( build ) in ai then
25633: LD_VAR 0 1
25637: PPUSH
25638: CALL_OW 255
25642: PUSH
25643: LD_EXP 24
25647: IN
25648: IFFALSE 25659
// begin add_to_builds ( build ) ;
25650: LD_VAR 0 1
25654: PPUSH
25655: CALL 27279 0 1
// end ; end ;
25659: PPOPN 3
25661: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
25662: LD_VAR 0 1
25666: PPUSH
25667: CALL_OW 255
25671: PUSH
25672: LD_EXP 7
25676: EQUAL
25677: IFFALSE 25695
// begin your_builds := your_builds union build ;
25679: LD_ADDR_EXP 36
25683: PUSH
25684: LD_EXP 36
25688: PUSH
25689: LD_VAR 0 1
25693: UNION
25694: ST_TO_ADDR
// end ; if GetSide ( build ) in ai then
25695: LD_VAR 0 1
25699: PPUSH
25700: CALL_OW 255
25704: PUSH
25705: LD_EXP 24
25709: IN
25710: IFFALSE 25721
// begin add_to_builds ( build ) ;
25712: LD_VAR 0 1
25716: PPUSH
25717: CALL 27279 0 1
// end ; end ;
25721: PPOPN 1
25723: END
// on VehicleConstructed ( veh , fact ) do begin if GetSide ( veh ) = you then
25724: LD_VAR 0 1
25728: PPUSH
25729: CALL_OW 255
25733: PUSH
25734: LD_EXP 7
25738: EQUAL
25739: IFFALSE 25757
// begin your_cars := your_cars union veh ;
25741: LD_ADDR_EXP 35
25745: PUSH
25746: LD_EXP 35
25750: PUSH
25751: LD_VAR 0 1
25755: UNION
25756: ST_TO_ADDR
// end ; if GetSide ( veh ) in ai then
25757: LD_VAR 0 1
25761: PPUSH
25762: CALL_OW 255
25766: PUSH
25767: LD_EXP 24
25771: IN
25772: IFFALSE 26121
// begin if GetControl ( veh ) = control_computer then
25774: LD_VAR 0 1
25778: PPUSH
25779: CALL_OW 263
25783: PUSH
25784: LD_INT 3
25786: EQUAL
25787: IFFALSE 25947
// case GetSide ( veh ) of ai_s [ 1 ] :
25789: LD_VAR 0 1
25793: PPUSH
25794: CALL_OW 255
25798: PUSH
25799: LD_EXP 23
25803: PUSH
25804: LD_INT 1
25806: ARRAY
25807: DOUBLE
25808: EQUAL
25809: IFTRUE 25813
25811: GO 25828
25813: POP
// ComMoveToArea ( veh , pro_attA ) ; ai_s [ 2 ] :
25814: LD_VAR 0 1
25818: PPUSH
25819: LD_INT 8
25821: PPUSH
25822: CALL_OW 113
25826: GO 25945
25828: LD_EXP 23
25832: PUSH
25833: LD_INT 2
25835: ARRAY
25836: DOUBLE
25837: EQUAL
25838: IFTRUE 25842
25840: GO 25857
25842: POP
// ComMoveToArea ( veh , pro_attB ) ; ai_s [ 3 ] :
25843: LD_VAR 0 1
25847: PPUSH
25848: LD_INT 10
25850: PPUSH
25851: CALL_OW 113
25855: GO 25945
25857: LD_EXP 23
25861: PUSH
25862: LD_INT 3
25864: ARRAY
25865: DOUBLE
25866: EQUAL
25867: IFTRUE 25871
25869: GO 25886
25871: POP
// ComMoveToArea ( veh , pro_attC ) ; ai_s [ 4 ] :
25872: LD_VAR 0 1
25876: PPUSH
25877: LD_INT 17
25879: PPUSH
25880: CALL_OW 113
25884: GO 25945
25886: LD_EXP 23
25890: PUSH
25891: LD_INT 4
25893: ARRAY
25894: DOUBLE
25895: EQUAL
25896: IFTRUE 25900
25898: GO 25915
25900: POP
// ComMoveToArea ( veh , pro_attD ) ; ai_s [ 5 ] :
25901: LD_VAR 0 1
25905: PPUSH
25906: LD_INT 15
25908: PPUSH
25909: CALL_OW 113
25913: GO 25945
25915: LD_EXP 23
25919: PUSH
25920: LD_INT 5
25922: ARRAY
25923: DOUBLE
25924: EQUAL
25925: IFTRUE 25929
25927: GO 25944
25929: POP
// ComMoveToArea ( veh , pro_attE ) ; end else
25930: LD_VAR 0 1
25934: PPUSH
25935: LD_INT 12
25937: PPUSH
25938: CALL_OW 113
25942: GO 25945
25944: POP
25945: GO 26103
// case GetSide ( veh ) of ai_s [ 1 ] :
25947: LD_VAR 0 1
25951: PPUSH
25952: CALL_OW 255
25956: PUSH
25957: LD_EXP 23
25961: PUSH
25962: LD_INT 1
25964: ARRAY
25965: DOUBLE
25966: EQUAL
25967: IFTRUE 25971
25969: GO 25986
25971: POP
// ComMoveToArea ( veh , pro_defA ) ; ai_s [ 2 ] :
25972: LD_VAR 0 1
25976: PPUSH
25977: LD_INT 9
25979: PPUSH
25980: CALL_OW 113
25984: GO 26103
25986: LD_EXP 23
25990: PUSH
25991: LD_INT 2
25993: ARRAY
25994: DOUBLE
25995: EQUAL
25996: IFTRUE 26000
25998: GO 26015
26000: POP
// ComMoveToArea ( veh , pro_defB ) ; ai_s [ 3 ] :
26001: LD_VAR 0 1
26005: PPUSH
26006: LD_INT 11
26008: PPUSH
26009: CALL_OW 113
26013: GO 26103
26015: LD_EXP 23
26019: PUSH
26020: LD_INT 3
26022: ARRAY
26023: DOUBLE
26024: EQUAL
26025: IFTRUE 26029
26027: GO 26044
26029: POP
// ComMoveToArea ( veh , pro_defC ) ; ai_s [ 4 ] :
26030: LD_VAR 0 1
26034: PPUSH
26035: LD_INT 16
26037: PPUSH
26038: CALL_OW 113
26042: GO 26103
26044: LD_EXP 23
26048: PUSH
26049: LD_INT 4
26051: ARRAY
26052: DOUBLE
26053: EQUAL
26054: IFTRUE 26058
26056: GO 26073
26058: POP
// ComMoveToArea ( veh , pro_defD ) ; ai_s [ 5 ] :
26059: LD_VAR 0 1
26063: PPUSH
26064: LD_INT 14
26066: PPUSH
26067: CALL_OW 113
26071: GO 26103
26073: LD_EXP 23
26077: PUSH
26078: LD_INT 5
26080: ARRAY
26081: DOUBLE
26082: EQUAL
26083: IFTRUE 26087
26085: GO 26102
26087: POP
// ComMoveToArea ( veh , pro_defE ) ; end ;
26088: LD_VAR 0 1
26092: PPUSH
26093: LD_INT 13
26095: PPUSH
26096: CALL_OW 113
26100: GO 26103
26102: POP
// AddComExitVehicle ( veh ) ;
26103: LD_VAR 0 1
26107: PPUSH
26108: CALL_OW 181
// add_to_vehicles ( veh ) ;
26112: LD_VAR 0 1
26116: PPUSH
26117: CALL 26934 0 1
// end ; end ;
26121: PPOPN 2
26123: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) = you then
26124: LD_VAR 0 1
26128: PPUSH
26129: CALL_OW 255
26133: PUSH
26134: LD_EXP 7
26138: EQUAL
26139: IFFALSE 26149
// maji_artifact := true ;
26141: LD_ADDR_EXP 39
26145: PUSH
26146: LD_INT 1
26148: ST_TO_ADDR
// art_cargo1 := un ;
26149: LD_ADDR_EXP 34
26153: PUSH
26154: LD_VAR 0 1
26158: ST_TO_ADDR
// end ;
26159: PPOPN 2
26161: END
// on ArtifactUnloaded ( un , size ) do begin if GetSide ( un ) = you then
26162: LD_VAR 0 1
26166: PPUSH
26167: CALL_OW 255
26171: PUSH
26172: LD_EXP 7
26176: EQUAL
26177: IFFALSE 26187
// maji_artifact := false ;
26179: LD_ADDR_EXP 39
26183: PUSH
26184: LD_INT 0
26186: ST_TO_ADDR
// art_cargo1 := 0 ;
26187: LD_ADDR_EXP 34
26191: PUSH
26192: LD_INT 0
26194: ST_TO_ADDR
// end ;
26195: PPOPN 2
26197: END
// on Command ( comm ) do begin if not Getside ( Eisenstein ) = you and IsInUnit ( Eisenstein ) then
26198: LD_EXP 49
26202: PPUSH
26203: CALL_OW 255
26207: PUSH
26208: LD_EXP 7
26212: EQUAL
26213: NOT
26214: PUSH
26215: LD_EXP 49
26219: PPUSH
26220: CALL_OW 310
26224: AND
26225: IFFALSE 26236
// RemoveTasks ( Eisenstein ) ;
26227: LD_EXP 49
26231: PPUSH
26232: CALL_OW 493
// if not Getside ( Davidov ) = you and IsInUnit ( Davidov ) then
26236: LD_EXP 48
26240: PPUSH
26241: CALL_OW 255
26245: PUSH
26246: LD_EXP 7
26250: EQUAL
26251: NOT
26252: PUSH
26253: LD_EXP 48
26257: PPUSH
26258: CALL_OW 310
26262: AND
26263: IFFALSE 26274
// RemoveTasks ( Davidov ) ;
26265: LD_EXP 48
26269: PPUSH
26270: CALL_OW 493
// if not Getside ( Tsaritsyn ) = you and IsInUnit ( Tsaritsyn ) then
26274: LD_EXP 47
26278: PPUSH
26279: CALL_OW 255
26283: PUSH
26284: LD_EXP 7
26288: EQUAL
26289: NOT
26290: PUSH
26291: LD_EXP 47
26295: PPUSH
26296: CALL_OW 310
26300: AND
26301: IFFALSE 26312
// RemoveTasks ( Tsaritsyn ) ;
26303: LD_EXP 47
26307: PPUSH
26308: CALL_OW 493
// if not Getside ( Borodin ) = you and IsInUnit ( Borodin ) then
26312: LD_EXP 46
26316: PPUSH
26317: CALL_OW 255
26321: PUSH
26322: LD_EXP 7
26326: EQUAL
26327: NOT
26328: PUSH
26329: LD_EXP 46
26333: PPUSH
26334: CALL_OW 310
26338: AND
26339: IFFALSE 26350
// RemoveTasks ( Borodin ) ;
26341: LD_EXP 46
26345: PPUSH
26346: CALL_OW 493
// end ;
26350: PPOPN 1
26352: END
// on McAttackDone ( mcid , surv ) do begin msg ( [ mcid , McAttackDone , surv ] ) ;
26353: LD_VAR 0 1
26357: PUSH
26358: LD_STRING McAttackDone
26360: PUSH
26361: LD_VAR 0 2
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: LIST
26370: PPUSH
26371: CALL_OW 100
// end ;
26375: PPOPN 2
26377: END
// on McRegistryResultChanges ( mcid , count , strength ) do begin if mcid = BehMcRegId then
26378: LD_VAR 0 1
26382: PUSH
26383: LD_EXP 64
26387: EQUAL
26388: IFFALSE 26439
// debug_strings := replace ( debug_strings , 2 , [ mcid , count , strength , GetMcUnits ( BehMcAttId ) ] ) ;
26390: LD_ADDR_OWVAR 48
26394: PUSH
26395: LD_OWVAR 48
26399: PPUSH
26400: LD_INT 2
26402: PPUSH
26403: LD_VAR 0 1
26407: PUSH
26408: LD_VAR 0 2
26412: PUSH
26413: LD_VAR 0 3
26417: PUSH
26418: LD_EXP 65
26422: PPUSH
26423: CALL_OW 389
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: LIST
26432: LIST
26433: PPUSH
26434: CALL_OW 1
26438: ST_TO_ADDR
// end ;
26439: PPOPN 3
26441: END
// export function add_to ( un ) ; begin
26442: LD_INT 0
26444: PPUSH
// add_to_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
26445: LD_VAR 0 1
26449: PPUSH
26450: LD_INT 21
26452: PUSH
26453: LD_INT 1
26455: PUSH
26456: EMPTY
26457: LIST
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: PPUSH
26463: CALL_OW 72
26467: PPUSH
26468: CALL 26531 0 1
// add_to_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 21
26479: PUSH
26480: LD_INT 3
26482: PUSH
26483: EMPTY
26484: LIST
26485: LIST
26486: PUSH
26487: EMPTY
26488: LIST
26489: PPUSH
26490: CALL_OW 72
26494: PPUSH
26495: CALL 27279 0 1
// add_to_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
26499: LD_VAR 0 1
26503: PPUSH
26504: LD_INT 21
26506: PUSH
26507: LD_INT 2
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: EMPTY
26515: LIST
26516: PPUSH
26517: CALL_OW 72
26521: PPUSH
26522: CALL 26934 0 1
// end ;
26526: LD_VAR 0 2
26530: RET
// export function add_to_humans ( un ) ; var i ; begin
26531: LD_INT 0
26533: PPUSH
26534: PPUSH
// sol := sol union UnitFilter ( un , [ mf_sol ] ) ;
26535: LD_ADDR_EXP 82
26539: PUSH
26540: LD_EXP 82
26544: PUSH
26545: LD_VAR 0 1
26549: PPUSH
26550: LD_EXP 51
26554: PUSH
26555: EMPTY
26556: LIST
26557: PPUSH
26558: CALL_OW 72
26562: UNION
26563: ST_TO_ADDR
// eng := eng union UnitFilter ( un , [ mf_eng ] ) ;
26564: LD_ADDR_EXP 84
26568: PUSH
26569: LD_EXP 84
26573: PUSH
26574: LD_VAR 0 1
26578: PPUSH
26579: LD_EXP 52
26583: PUSH
26584: EMPTY
26585: LIST
26586: PPUSH
26587: CALL_OW 72
26591: UNION
26592: ST_TO_ADDR
// mec := mec union UnitFilter ( un , [ mf_mec ] ) ;
26593: LD_ADDR_EXP 86
26597: PUSH
26598: LD_EXP 86
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_EXP 53
26612: PUSH
26613: EMPTY
26614: LIST
26615: PPUSH
26616: CALL_OW 72
26620: UNION
26621: ST_TO_ADDR
// sci := sci union UnitFilter ( un , [ mf_sci ] ) ;
26622: LD_ADDR_EXP 88
26626: PUSH
26627: LD_EXP 88
26631: PUSH
26632: LD_VAR 0 1
26636: PPUSH
26637: LD_EXP 54
26641: PUSH
26642: EMPTY
26643: LIST
26644: PPUSH
26645: CALL_OW 72
26649: UNION
26650: ST_TO_ADDR
// for i in un do
26651: LD_ADDR_VAR 0 3
26655: PUSH
26656: LD_VAR 0 1
26660: PUSH
26661: FOR_IN
26662: IFFALSE 26927
// begin case GetSide ( i ) of ai_s [ 1 ] :
26664: LD_VAR 0 3
26668: PPUSH
26669: CALL_OW 255
26673: PUSH
26674: LD_EXP 23
26678: PUSH
26679: LD_INT 1
26681: ARRAY
26682: DOUBLE
26683: EQUAL
26684: IFTRUE 26688
26686: GO 26724
26688: POP
// humans := replace ( humans , 1 , humans [ 1 ] union i ) ; ai_s [ 2 ] :
26689: LD_ADDR_EXP 76
26693: PUSH
26694: LD_EXP 76
26698: PPUSH
26699: LD_INT 1
26701: PPUSH
26702: LD_EXP 76
26706: PUSH
26707: LD_INT 1
26709: ARRAY
26710: PUSH
26711: LD_VAR 0 3
26715: UNION
26716: PPUSH
26717: CALL_OW 1
26721: ST_TO_ADDR
26722: GO 26925
26724: LD_EXP 23
26728: PUSH
26729: LD_INT 2
26731: ARRAY
26732: DOUBLE
26733: EQUAL
26734: IFTRUE 26738
26736: GO 26774
26738: POP
// humans := replace ( humans , 2 , humans [ 2 ] union i ) ; ai_s [ 3 ] :
26739: LD_ADDR_EXP 76
26743: PUSH
26744: LD_EXP 76
26748: PPUSH
26749: LD_INT 2
26751: PPUSH
26752: LD_EXP 76
26756: PUSH
26757: LD_INT 2
26759: ARRAY
26760: PUSH
26761: LD_VAR 0 3
26765: UNION
26766: PPUSH
26767: CALL_OW 1
26771: ST_TO_ADDR
26772: GO 26925
26774: LD_EXP 23
26778: PUSH
26779: LD_INT 3
26781: ARRAY
26782: DOUBLE
26783: EQUAL
26784: IFTRUE 26788
26786: GO 26824
26788: POP
// humans := replace ( humans , 3 , humans [ 3 ] union i ) ; ai_s [ 4 ] :
26789: LD_ADDR_EXP 76
26793: PUSH
26794: LD_EXP 76
26798: PPUSH
26799: LD_INT 3
26801: PPUSH
26802: LD_EXP 76
26806: PUSH
26807: LD_INT 3
26809: ARRAY
26810: PUSH
26811: LD_VAR 0 3
26815: UNION
26816: PPUSH
26817: CALL_OW 1
26821: ST_TO_ADDR
26822: GO 26925
26824: LD_EXP 23
26828: PUSH
26829: LD_INT 4
26831: ARRAY
26832: DOUBLE
26833: EQUAL
26834: IFTRUE 26838
26836: GO 26874
26838: POP
// humans := replace ( humans , 4 , humans [ 4 ] union i ) ; ai_s [ 5 ] :
26839: LD_ADDR_EXP 76
26843: PUSH
26844: LD_EXP 76
26848: PPUSH
26849: LD_INT 4
26851: PPUSH
26852: LD_EXP 76
26856: PUSH
26857: LD_INT 4
26859: ARRAY
26860: PUSH
26861: LD_VAR 0 3
26865: UNION
26866: PPUSH
26867: CALL_OW 1
26871: ST_TO_ADDR
26872: GO 26925
26874: LD_EXP 23
26878: PUSH
26879: LD_INT 5
26881: ARRAY
26882: DOUBLE
26883: EQUAL
26884: IFTRUE 26888
26886: GO 26924
26888: POP
// humans := replace ( humans , 5 , humans [ 5 ] union i ) ; end ;
26889: LD_ADDR_EXP 76
26893: PUSH
26894: LD_EXP 76
26898: PPUSH
26899: LD_INT 5
26901: PPUSH
26902: LD_EXP 76
26906: PUSH
26907: LD_INT 5
26909: ARRAY
26910: PUSH
26911: LD_VAR 0 3
26915: UNION
26916: PPUSH
26917: CALL_OW 1
26921: ST_TO_ADDR
26922: GO 26925
26924: POP
// end ;
26925: GO 26661
26927: POP
26928: POP
// end ;
26929: LD_VAR 0 2
26933: RET
// export function add_to_vehicles ( un ) ; var i ; begin
26934: LD_INT 0
26936: PPUSH
26937: PPUSH
// attack_units := attack_units union UnitFilter ( un , [ mf_comp ] ) ;
26938: LD_ADDR_EXP 78
26942: PUSH
26943: LD_EXP 78
26947: PUSH
26948: LD_VAR 0 1
26952: PPUSH
26953: LD_EXP 60
26957: PUSH
26958: EMPTY
26959: LIST
26960: PPUSH
26961: CALL_OW 72
26965: UNION
26966: ST_TO_ADDR
// defence_units := defence_units union UnitFilter ( un , [ mf_manu ] ) ;
26967: LD_ADDR_EXP 79
26971: PUSH
26972: LD_EXP 79
26976: PUSH
26977: LD_VAR 0 1
26981: PPUSH
26982: LD_EXP 61
26986: PUSH
26987: EMPTY
26988: LIST
26989: PPUSH
26990: CALL_OW 72
26994: UNION
26995: ST_TO_ADDR
// for i in un do
26996: LD_ADDR_VAR 0 3
27000: PUSH
27001: LD_VAR 0 1
27005: PUSH
27006: FOR_IN
27007: IFFALSE 27272
// begin case getside ( i ) of ai_s [ 1 ] :
27009: LD_VAR 0 3
27013: PPUSH
27014: CALL_OW 255
27018: PUSH
27019: LD_EXP 23
27023: PUSH
27024: LD_INT 1
27026: ARRAY
27027: DOUBLE
27028: EQUAL
27029: IFTRUE 27033
27031: GO 27069
27033: POP
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] union i ) ; ai_s [ 2 ] :
27034: LD_ADDR_EXP 77
27038: PUSH
27039: LD_EXP 77
27043: PPUSH
27044: LD_INT 1
27046: PPUSH
27047: LD_EXP 77
27051: PUSH
27052: LD_INT 1
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 3
27060: UNION
27061: PPUSH
27062: CALL_OW 1
27066: ST_TO_ADDR
27067: GO 27270
27069: LD_EXP 23
27073: PUSH
27074: LD_INT 2
27076: ARRAY
27077: DOUBLE
27078: EQUAL
27079: IFTRUE 27083
27081: GO 27119
27083: POP
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] union i ) ; ai_s [ 3 ] :
27084: LD_ADDR_EXP 77
27088: PUSH
27089: LD_EXP 77
27093: PPUSH
27094: LD_INT 2
27096: PPUSH
27097: LD_EXP 77
27101: PUSH
27102: LD_INT 2
27104: ARRAY
27105: PUSH
27106: LD_VAR 0 3
27110: UNION
27111: PPUSH
27112: CALL_OW 1
27116: ST_TO_ADDR
27117: GO 27270
27119: LD_EXP 23
27123: PUSH
27124: LD_INT 3
27126: ARRAY
27127: DOUBLE
27128: EQUAL
27129: IFTRUE 27133
27131: GO 27169
27133: POP
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] union i ) ; ai_s [ 4 ] :
27134: LD_ADDR_EXP 77
27138: PUSH
27139: LD_EXP 77
27143: PPUSH
27144: LD_INT 3
27146: PPUSH
27147: LD_EXP 77
27151: PUSH
27152: LD_INT 3
27154: ARRAY
27155: PUSH
27156: LD_VAR 0 3
27160: UNION
27161: PPUSH
27162: CALL_OW 1
27166: ST_TO_ADDR
27167: GO 27270
27169: LD_EXP 23
27173: PUSH
27174: LD_INT 4
27176: ARRAY
27177: DOUBLE
27178: EQUAL
27179: IFTRUE 27183
27181: GO 27219
27183: POP
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] union i ) ; ai_s [ 5 ] :
27184: LD_ADDR_EXP 77
27188: PUSH
27189: LD_EXP 77
27193: PPUSH
27194: LD_INT 4
27196: PPUSH
27197: LD_EXP 77
27201: PUSH
27202: LD_INT 4
27204: ARRAY
27205: PUSH
27206: LD_VAR 0 3
27210: UNION
27211: PPUSH
27212: CALL_OW 1
27216: ST_TO_ADDR
27217: GO 27270
27219: LD_EXP 23
27223: PUSH
27224: LD_INT 5
27226: ARRAY
27227: DOUBLE
27228: EQUAL
27229: IFTRUE 27233
27231: GO 27269
27233: POP
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] union i ) ; end ;
27234: LD_ADDR_EXP 77
27238: PUSH
27239: LD_EXP 77
27243: PPUSH
27244: LD_INT 5
27246: PPUSH
27247: LD_EXP 77
27251: PUSH
27252: LD_INT 5
27254: ARRAY
27255: PUSH
27256: LD_VAR 0 3
27260: UNION
27261: PPUSH
27262: CALL_OW 1
27266: ST_TO_ADDR
27267: GO 27270
27269: POP
// end ;
27270: GO 27006
27272: POP
27273: POP
// end ;
27274: LD_VAR 0 2
27278: RET
// export function add_to_builds ( un ) ; var i , j , bt ; begin
27279: LD_INT 0
27281: PPUSH
27282: PPUSH
27283: PPUSH
27284: PPUSH
// fort := fort union UnitFilter ( un , [ mf_fort ] ) ;
27285: LD_ADDR_EXP 81
27289: PUSH
27290: LD_EXP 81
27294: PUSH
27295: LD_VAR 0 1
27299: PPUSH
27300: LD_EXP 56
27304: PUSH
27305: EMPTY
27306: LIST
27307: PPUSH
27308: CALL_OW 72
27312: UNION
27313: ST_TO_ADDR
// dep := dep union UnitFilter ( un , [ mf_dep ] ) ;
27314: LD_ADDR_EXP 83
27318: PUSH
27319: LD_EXP 83
27323: PUSH
27324: LD_VAR 0 1
27328: PPUSH
27329: LD_EXP 58
27333: PUSH
27334: EMPTY
27335: LIST
27336: PPUSH
27337: CALL_OW 72
27341: UNION
27342: ST_TO_ADDR
// fact := fact union UnitFilter ( un , [ mf_fact ] ) ;
27343: LD_ADDR_EXP 85
27347: PUSH
27348: LD_EXP 85
27352: PUSH
27353: LD_VAR 0 1
27357: PPUSH
27358: LD_EXP 59
27362: PUSH
27363: EMPTY
27364: LIST
27365: PPUSH
27366: CALL_OW 72
27370: UNION
27371: ST_TO_ADDR
// lab := lab union UnitFilter ( un , [ mf_lab ] ) ;
27372: LD_ADDR_EXP 87
27376: PUSH
27377: LD_EXP 87
27381: PUSH
27382: LD_VAR 0 1
27386: PPUSH
27387: LD_EXP 55
27391: PUSH
27392: EMPTY
27393: LIST
27394: PPUSH
27395: CALL_OW 72
27399: UNION
27400: ST_TO_ADDR
// for i in un do
27401: LD_ADDR_VAR 0 3
27405: PUSH
27406: LD_VAR 0 1
27410: PUSH
27411: FOR_IN
27412: IFFALSE 27677
// begin case GetSide ( i ) of ai_s [ 1 ] :
27414: LD_VAR 0 3
27418: PPUSH
27419: CALL_OW 255
27423: PUSH
27424: LD_EXP 23
27428: PUSH
27429: LD_INT 1
27431: ARRAY
27432: DOUBLE
27433: EQUAL
27434: IFTRUE 27438
27436: GO 27474
27438: POP
// buildings := replace ( buildings , 1 , buildings [ 1 ] union i ) ; ai_s [ 2 ] :
27439: LD_ADDR_EXP 75
27443: PUSH
27444: LD_EXP 75
27448: PPUSH
27449: LD_INT 1
27451: PPUSH
27452: LD_EXP 75
27456: PUSH
27457: LD_INT 1
27459: ARRAY
27460: PUSH
27461: LD_VAR 0 3
27465: UNION
27466: PPUSH
27467: CALL_OW 1
27471: ST_TO_ADDR
27472: GO 27675
27474: LD_EXP 23
27478: PUSH
27479: LD_INT 2
27481: ARRAY
27482: DOUBLE
27483: EQUAL
27484: IFTRUE 27488
27486: GO 27524
27488: POP
// buildings := replace ( buildings , 2 , buildings [ 2 ] union i ) ; ai_s [ 3 ] :
27489: LD_ADDR_EXP 75
27493: PUSH
27494: LD_EXP 75
27498: PPUSH
27499: LD_INT 2
27501: PPUSH
27502: LD_EXP 75
27506: PUSH
27507: LD_INT 2
27509: ARRAY
27510: PUSH
27511: LD_VAR 0 3
27515: UNION
27516: PPUSH
27517: CALL_OW 1
27521: ST_TO_ADDR
27522: GO 27675
27524: LD_EXP 23
27528: PUSH
27529: LD_INT 3
27531: ARRAY
27532: DOUBLE
27533: EQUAL
27534: IFTRUE 27538
27536: GO 27574
27538: POP
// buildings := replace ( buildings , 3 , buildings [ 3 ] union i ) ; ai_s [ 4 ] :
27539: LD_ADDR_EXP 75
27543: PUSH
27544: LD_EXP 75
27548: PPUSH
27549: LD_INT 3
27551: PPUSH
27552: LD_EXP 75
27556: PUSH
27557: LD_INT 3
27559: ARRAY
27560: PUSH
27561: LD_VAR 0 3
27565: UNION
27566: PPUSH
27567: CALL_OW 1
27571: ST_TO_ADDR
27572: GO 27675
27574: LD_EXP 23
27578: PUSH
27579: LD_INT 4
27581: ARRAY
27582: DOUBLE
27583: EQUAL
27584: IFTRUE 27588
27586: GO 27624
27588: POP
// buildings := replace ( buildings , 4 , buildings [ 4 ] union i ) ; ai_s [ 5 ] :
27589: LD_ADDR_EXP 75
27593: PUSH
27594: LD_EXP 75
27598: PPUSH
27599: LD_INT 4
27601: PPUSH
27602: LD_EXP 75
27606: PUSH
27607: LD_INT 4
27609: ARRAY
27610: PUSH
27611: LD_VAR 0 3
27615: UNION
27616: PPUSH
27617: CALL_OW 1
27621: ST_TO_ADDR
27622: GO 27675
27624: LD_EXP 23
27628: PUSH
27629: LD_INT 5
27631: ARRAY
27632: DOUBLE
27633: EQUAL
27634: IFTRUE 27638
27636: GO 27674
27638: POP
// buildings := replace ( buildings , 5 , buildings [ 5 ] union i ) ; end ;
27639: LD_ADDR_EXP 75
27643: PUSH
27644: LD_EXP 75
27648: PPUSH
27649: LD_INT 5
27651: PPUSH
27652: LD_EXP 75
27656: PUSH
27657: LD_INT 5
27659: ARRAY
27660: PUSH
27661: LD_VAR 0 3
27665: UNION
27666: PPUSH
27667: CALL_OW 1
27671: ST_TO_ADDR
27672: GO 27675
27674: POP
// end ;
27675: GO 27411
27677: POP
27678: POP
// write_deps ;
27679: CALL 23399 0 0
// write_facts ;
27683: CALL 23518 0 0
// end ;
27687: LD_VAR 0 2
27691: RET
// export function remove_from ( un ) ; begin
27692: LD_INT 0
27694: PPUSH
// remove_from_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
27695: LD_VAR 0 1
27699: PPUSH
27700: LD_INT 21
27702: PUSH
27703: LD_INT 1
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: EMPTY
27711: LIST
27712: PPUSH
27713: CALL_OW 72
27717: PPUSH
27718: CALL 28027 0 1
// remove_from_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
27722: LD_VAR 0 1
27726: PPUSH
27727: LD_INT 21
27729: PUSH
27730: LD_INT 3
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: EMPTY
27738: LIST
27739: PPUSH
27740: CALL_OW 72
27744: PPUSH
27745: CALL 27781 0 1
// remove_from_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
27749: LD_VAR 0 1
27753: PPUSH
27754: LD_INT 21
27756: PUSH
27757: LD_INT 2
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: EMPTY
27765: LIST
27766: PPUSH
27767: CALL_OW 72
27771: PPUSH
27772: CALL 28265 0 1
// end ;
27776: LD_VAR 0 2
27780: RET
// export function remove_from_builds ( un ) ; var i ; begin
27781: LD_INT 0
27783: PPUSH
27784: PPUSH
// fact := fact diff un ;
27785: LD_ADDR_EXP 85
27789: PUSH
27790: LD_EXP 85
27794: PUSH
27795: LD_VAR 0 1
27799: DIFF
27800: ST_TO_ADDR
// fort := fort diff un ;
27801: LD_ADDR_EXP 81
27805: PUSH
27806: LD_EXP 81
27810: PUSH
27811: LD_VAR 0 1
27815: DIFF
27816: ST_TO_ADDR
// lab := lab diff un ;
27817: LD_ADDR_EXP 87
27821: PUSH
27822: LD_EXP 87
27826: PUSH
27827: LD_VAR 0 1
27831: DIFF
27832: ST_TO_ADDR
// dep := dep diff un ;
27833: LD_ADDR_EXP 83
27837: PUSH
27838: LD_EXP 83
27842: PUSH
27843: LD_VAR 0 1
27847: DIFF
27848: ST_TO_ADDR
// buildings := replace ( buildings , 1 , buildings [ 1 ] diff un ) ;
27849: LD_ADDR_EXP 75
27853: PUSH
27854: LD_EXP 75
27858: PPUSH
27859: LD_INT 1
27861: PPUSH
27862: LD_EXP 75
27866: PUSH
27867: LD_INT 1
27869: ARRAY
27870: PUSH
27871: LD_VAR 0 1
27875: DIFF
27876: PPUSH
27877: CALL_OW 1
27881: ST_TO_ADDR
// buildings := replace ( buildings , 2 , buildings [ 2 ] diff un ) ;
27882: LD_ADDR_EXP 75
27886: PUSH
27887: LD_EXP 75
27891: PPUSH
27892: LD_INT 2
27894: PPUSH
27895: LD_EXP 75
27899: PUSH
27900: LD_INT 2
27902: ARRAY
27903: PUSH
27904: LD_VAR 0 1
27908: DIFF
27909: PPUSH
27910: CALL_OW 1
27914: ST_TO_ADDR
// buildings := replace ( buildings , 3 , buildings [ 3 ] diff un ) ;
27915: LD_ADDR_EXP 75
27919: PUSH
27920: LD_EXP 75
27924: PPUSH
27925: LD_INT 3
27927: PPUSH
27928: LD_EXP 75
27932: PUSH
27933: LD_INT 3
27935: ARRAY
27936: PUSH
27937: LD_VAR 0 1
27941: DIFF
27942: PPUSH
27943: CALL_OW 1
27947: ST_TO_ADDR
// buildings := replace ( buildings , 4 , buildings [ 4 ] diff un ) ;
27948: LD_ADDR_EXP 75
27952: PUSH
27953: LD_EXP 75
27957: PPUSH
27958: LD_INT 4
27960: PPUSH
27961: LD_EXP 75
27965: PUSH
27966: LD_INT 4
27968: ARRAY
27969: PUSH
27970: LD_VAR 0 1
27974: DIFF
27975: PPUSH
27976: CALL_OW 1
27980: ST_TO_ADDR
// buildings := replace ( buildings , 5 , buildings [ 5 ] diff un ) ;
27981: LD_ADDR_EXP 75
27985: PUSH
27986: LD_EXP 75
27990: PPUSH
27991: LD_INT 5
27993: PPUSH
27994: LD_EXP 75
27998: PUSH
27999: LD_INT 5
28001: ARRAY
28002: PUSH
28003: LD_VAR 0 1
28007: DIFF
28008: PPUSH
28009: CALL_OW 1
28013: ST_TO_ADDR
// write_deps ;
28014: CALL 23399 0 0
// write_facts ;
28018: CALL 23518 0 0
// end ;
28022: LD_VAR 0 2
28026: RET
// export function remove_from_humans ( un ) ; var i ; begin
28027: LD_INT 0
28029: PPUSH
28030: PPUSH
// sol := sol diff un ;
28031: LD_ADDR_EXP 82
28035: PUSH
28036: LD_EXP 82
28040: PUSH
28041: LD_VAR 0 1
28045: DIFF
28046: ST_TO_ADDR
// eng := eng diff un ;
28047: LD_ADDR_EXP 84
28051: PUSH
28052: LD_EXP 84
28056: PUSH
28057: LD_VAR 0 1
28061: DIFF
28062: ST_TO_ADDR
// mec := mec diff un ;
28063: LD_ADDR_EXP 86
28067: PUSH
28068: LD_EXP 86
28072: PUSH
28073: LD_VAR 0 1
28077: DIFF
28078: ST_TO_ADDR
// sci := sci diff un ;
28079: LD_ADDR_EXP 88
28083: PUSH
28084: LD_EXP 88
28088: PUSH
28089: LD_VAR 0 1
28093: DIFF
28094: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff un ) ;
28095: LD_ADDR_EXP 76
28099: PUSH
28100: LD_EXP 76
28104: PPUSH
28105: LD_INT 1
28107: PPUSH
28108: LD_EXP 76
28112: PUSH
28113: LD_INT 1
28115: ARRAY
28116: PUSH
28117: LD_VAR 0 1
28121: DIFF
28122: PPUSH
28123: CALL_OW 1
28127: ST_TO_ADDR
// humans := replace ( humans , 2 , humans [ 2 ] diff un ) ;
28128: LD_ADDR_EXP 76
28132: PUSH
28133: LD_EXP 76
28137: PPUSH
28138: LD_INT 2
28140: PPUSH
28141: LD_EXP 76
28145: PUSH
28146: LD_INT 2
28148: ARRAY
28149: PUSH
28150: LD_VAR 0 1
28154: DIFF
28155: PPUSH
28156: CALL_OW 1
28160: ST_TO_ADDR
// humans := replace ( humans , 3 , humans [ 3 ] diff un ) ;
28161: LD_ADDR_EXP 76
28165: PUSH
28166: LD_EXP 76
28170: PPUSH
28171: LD_INT 3
28173: PPUSH
28174: LD_EXP 76
28178: PUSH
28179: LD_INT 3
28181: ARRAY
28182: PUSH
28183: LD_VAR 0 1
28187: DIFF
28188: PPUSH
28189: CALL_OW 1
28193: ST_TO_ADDR
// humans := replace ( humans , 4 , humans [ 4 ] diff un ) ;
28194: LD_ADDR_EXP 76
28198: PUSH
28199: LD_EXP 76
28203: PPUSH
28204: LD_INT 4
28206: PPUSH
28207: LD_EXP 76
28211: PUSH
28212: LD_INT 4
28214: ARRAY
28215: PUSH
28216: LD_VAR 0 1
28220: DIFF
28221: PPUSH
28222: CALL_OW 1
28226: ST_TO_ADDR
// humans := replace ( humans , 5 , humans [ 5 ] diff un ) ;
28227: LD_ADDR_EXP 76
28231: PUSH
28232: LD_EXP 76
28236: PPUSH
28237: LD_INT 5
28239: PPUSH
28240: LD_EXP 76
28244: PUSH
28245: LD_INT 5
28247: ARRAY
28248: PUSH
28249: LD_VAR 0 1
28253: DIFF
28254: PPUSH
28255: CALL_OW 1
28259: ST_TO_ADDR
// end ;
28260: LD_VAR 0 2
28264: RET
// export function remove_from_vehicles ( un ) ; var i ; begin
28265: LD_INT 0
28267: PPUSH
28268: PPUSH
// attack_units := attack_units diff un ;
28269: LD_ADDR_EXP 78
28273: PUSH
28274: LD_EXP 78
28278: PUSH
28279: LD_VAR 0 1
28283: DIFF
28284: ST_TO_ADDR
// defence_units := defence_units diff un ;
28285: LD_ADDR_EXP 79
28289: PUSH
28290: LD_EXP 79
28294: PUSH
28295: LD_VAR 0 1
28299: DIFF
28300: ST_TO_ADDR
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] diff un ) ;
28301: LD_ADDR_EXP 77
28305: PUSH
28306: LD_EXP 77
28310: PPUSH
28311: LD_INT 1
28313: PPUSH
28314: LD_EXP 77
28318: PUSH
28319: LD_INT 1
28321: ARRAY
28322: PUSH
28323: LD_VAR 0 1
28327: DIFF
28328: PPUSH
28329: CALL_OW 1
28333: ST_TO_ADDR
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] diff un ) ;
28334: LD_ADDR_EXP 77
28338: PUSH
28339: LD_EXP 77
28343: PPUSH
28344: LD_INT 2
28346: PPUSH
28347: LD_EXP 77
28351: PUSH
28352: LD_INT 2
28354: ARRAY
28355: PUSH
28356: LD_VAR 0 1
28360: DIFF
28361: PPUSH
28362: CALL_OW 1
28366: ST_TO_ADDR
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] diff un ) ;
28367: LD_ADDR_EXP 77
28371: PUSH
28372: LD_EXP 77
28376: PPUSH
28377: LD_INT 3
28379: PPUSH
28380: LD_EXP 77
28384: PUSH
28385: LD_INT 3
28387: ARRAY
28388: PUSH
28389: LD_VAR 0 1
28393: DIFF
28394: PPUSH
28395: CALL_OW 1
28399: ST_TO_ADDR
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] diff un ) ;
28400: LD_ADDR_EXP 77
28404: PUSH
28405: LD_EXP 77
28409: PPUSH
28410: LD_INT 4
28412: PPUSH
28413: LD_EXP 77
28417: PUSH
28418: LD_INT 4
28420: ARRAY
28421: PUSH
28422: LD_VAR 0 1
28426: DIFF
28427: PPUSH
28428: CALL_OW 1
28432: ST_TO_ADDR
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] diff un ) ;
28433: LD_ADDR_EXP 77
28437: PUSH
28438: LD_EXP 77
28442: PPUSH
28443: LD_INT 5
28445: PPUSH
28446: LD_EXP 77
28450: PUSH
28451: LD_INT 5
28453: ARRAY
28454: PUSH
28455: LD_VAR 0 1
28459: DIFF
28460: PPUSH
28461: CALL_OW 1
28465: ST_TO_ADDR
// bc := replace ( bc , 1 , bc [ 1 ] diff un ) ;
28466: LD_ADDR_EXP 71
28470: PUSH
28471: LD_EXP 71
28475: PPUSH
28476: LD_INT 1
28478: PPUSH
28479: LD_EXP 71
28483: PUSH
28484: LD_INT 1
28486: ARRAY
28487: PUSH
28488: LD_VAR 0 1
28492: DIFF
28493: PPUSH
28494: CALL_OW 1
28498: ST_TO_ADDR
// bc := replace ( bc , 2 , bc [ 2 ] diff un ) ;
28499: LD_ADDR_EXP 71
28503: PUSH
28504: LD_EXP 71
28508: PPUSH
28509: LD_INT 2
28511: PPUSH
28512: LD_EXP 71
28516: PUSH
28517: LD_INT 2
28519: ARRAY
28520: PUSH
28521: LD_VAR 0 1
28525: DIFF
28526: PPUSH
28527: CALL_OW 1
28531: ST_TO_ADDR
// bc := replace ( bc , 3 , bc [ 3 ] diff un ) ;
28532: LD_ADDR_EXP 71
28536: PUSH
28537: LD_EXP 71
28541: PPUSH
28542: LD_INT 3
28544: PPUSH
28545: LD_EXP 71
28549: PUSH
28550: LD_INT 3
28552: ARRAY
28553: PUSH
28554: LD_VAR 0 1
28558: DIFF
28559: PPUSH
28560: CALL_OW 1
28564: ST_TO_ADDR
// bc := replace ( bc , 4 , bc [ 4 ] diff un ) ;
28565: LD_ADDR_EXP 71
28569: PUSH
28570: LD_EXP 71
28574: PPUSH
28575: LD_INT 4
28577: PPUSH
28578: LD_EXP 71
28582: PUSH
28583: LD_INT 4
28585: ARRAY
28586: PUSH
28587: LD_VAR 0 1
28591: DIFF
28592: PPUSH
28593: CALL_OW 1
28597: ST_TO_ADDR
// bc := replace ( bc , 5 , bc [ 5 ] diff un ) ;
28598: LD_ADDR_EXP 71
28602: PUSH
28603: LD_EXP 71
28607: PPUSH
28608: LD_INT 5
28610: PPUSH
28611: LD_EXP 71
28615: PUSH
28616: LD_INT 5
28618: ARRAY
28619: PUSH
28620: LD_VAR 0 1
28624: DIFF
28625: PPUSH
28626: CALL_OW 1
28630: ST_TO_ADDR
// rc := replace ( rc , 1 , rc [ 1 ] diff un ) ;
28631: LD_ADDR_EXP 70
28635: PUSH
28636: LD_EXP 70
28640: PPUSH
28641: LD_INT 1
28643: PPUSH
28644: LD_EXP 70
28648: PUSH
28649: LD_INT 1
28651: ARRAY
28652: PUSH
28653: LD_VAR 0 1
28657: DIFF
28658: PPUSH
28659: CALL_OW 1
28663: ST_TO_ADDR
// rc := replace ( rc , 2 , rc [ 2 ] diff un ) ;
28664: LD_ADDR_EXP 70
28668: PUSH
28669: LD_EXP 70
28673: PPUSH
28674: LD_INT 2
28676: PPUSH
28677: LD_EXP 70
28681: PUSH
28682: LD_INT 2
28684: ARRAY
28685: PUSH
28686: LD_VAR 0 1
28690: DIFF
28691: PPUSH
28692: CALL_OW 1
28696: ST_TO_ADDR
// rc := replace ( rc , 3 , rc [ 3 ] diff un ) ;
28697: LD_ADDR_EXP 70
28701: PUSH
28702: LD_EXP 70
28706: PPUSH
28707: LD_INT 3
28709: PPUSH
28710: LD_EXP 70
28714: PUSH
28715: LD_INT 3
28717: ARRAY
28718: PUSH
28719: LD_VAR 0 1
28723: DIFF
28724: PPUSH
28725: CALL_OW 1
28729: ST_TO_ADDR
// rc := replace ( rc , 4 , rc [ 4 ] diff un ) ;
28730: LD_ADDR_EXP 70
28734: PUSH
28735: LD_EXP 70
28739: PPUSH
28740: LD_INT 4
28742: PPUSH
28743: LD_EXP 70
28747: PUSH
28748: LD_INT 4
28750: ARRAY
28751: PUSH
28752: LD_VAR 0 1
28756: DIFF
28757: PPUSH
28758: CALL_OW 1
28762: ST_TO_ADDR
// rc := replace ( rc , 5 , rc [ 5 ] diff un ) ;
28763: LD_ADDR_EXP 70
28767: PUSH
28768: LD_EXP 70
28772: PPUSH
28773: LD_INT 5
28775: PPUSH
28776: LD_EXP 70
28780: PUSH
28781: LD_INT 5
28783: ARRAY
28784: PUSH
28785: LD_VAR 0 1
28789: DIFF
28790: PPUSH
28791: CALL_OW 1
28795: ST_TO_ADDR
// end ; end_of_file
28796: LD_VAR 0 2
28800: RET
// var objevovani_zasilek ; every 1 do
28801: GO 28803
28803: DISABLE
// begin objevovani_zasilek := [ 2 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 ] ;
28804: LD_ADDR_LOC 30
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: LD_INT 3
28814: PUSH
28815: LD_INT 1
28817: PUSH
28818: LD_INT 5
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: LD_INT 1
28826: PUSH
28827: LD_INT 4
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: LD_INT 0
28835: PUSH
28836: LD_INT 3
28838: PUSH
28839: LD_INT 3
28841: PUSH
28842: LD_INT 1
28844: PUSH
28845: LD_INT 5
28847: PUSH
28848: LD_INT 1
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: LD_INT 4
28856: PUSH
28857: LD_INT 1
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: LD_INT 3
28865: PUSH
28866: LD_INT 3
28868: PUSH
28869: LD_INT 1
28871: PUSH
28872: LD_INT 5
28874: PUSH
28875: LD_INT 1
28877: PUSH
28878: LD_INT 1
28880: PUSH
28881: LD_INT 4
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: LD_INT 3
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: LIST
28907: LIST
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: ST_TO_ADDR
// Randomize ;
28923: CALL_OW 10
// end ;
28927: END
// every 5 5$0 do
28928: GO 28930
28930: DISABLE
// begin Randomize ;
28931: CALL_OW 10
// enable ;
28935: ENABLE
// end ;
28936: END
// every 0 0$15 do
28937: GO 28939
28939: DISABLE
// begin padaji_bedny ;
28940: CALL 28954 0 0
// end ;
28944: END
// every 5 5$0 + 0 0$15 do
28945: GO 28947
28947: DISABLE
// begin padaji_bedny ;
28948: CALL 28954 0 0
// enable ;
28952: ENABLE
// end ;
28953: END
// function padaji_bedny ; var x , i , cek , cek2 , last , min5 ; begin
28954: LD_INT 0
28956: PPUSH
28957: PPUSH
28958: PPUSH
28959: PPUSH
28960: PPUSH
28961: PPUSH
28962: PPUSH
// min5 := ( ( tick div 5 5$0 ) + 1 ) mod objevovani_zasilek ;
28963: LD_ADDR_VAR 0 7
28967: PUSH
28968: LD_OWVAR 1
28972: PUSH
28973: LD_INT 10500
28975: DIV
28976: PUSH
28977: LD_INT 1
28979: PLUS
28980: PUSH
28981: LD_LOC 30
28985: MOD
28986: ST_TO_ADDR
// cek := [ ] ;
28987: LD_ADDR_VAR 0 4
28991: PUSH
28992: EMPTY
28993: ST_TO_ADDR
// cek2 := [ ] ;
28994: LD_ADDR_VAR 0 5
28998: PUSH
28999: EMPTY
29000: ST_TO_ADDR
// last := 0 ;
29001: LD_ADDR_VAR 0 6
29005: PUSH
29006: LD_INT 0
29008: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
29009: LD_ADDR_VAR 0 2
29013: PUSH
29014: LD_LOC 30
29018: PUSH
29019: LD_VAR 0 7
29023: ARRAY
29024: ST_TO_ADDR
// for i := 1 to x do
29025: LD_ADDR_VAR 0 3
29029: PUSH
29030: DOUBLE
29031: LD_INT 1
29033: DEC
29034: ST_TO_ADDR
29035: LD_VAR 0 2
29039: PUSH
29040: FOR_TO
29041: IFFALSE 29067
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
29043: LD_ADDR_VAR 0 4
29047: PUSH
29048: LD_VAR 0 4
29052: PUSH
29053: LD_INT 525
29055: PPUSH
29056: LD_INT 10500
29058: PPUSH
29059: CALL_OW 12
29063: ADD
29064: ST_TO_ADDR
29065: GO 29040
29067: POP
29068: POP
// cek := SortListByListAsc ( cek , cek ) ;
29069: LD_ADDR_VAR 0 4
29073: PUSH
29074: LD_VAR 0 4
29078: PPUSH
29079: LD_VAR 0 4
29083: PPUSH
29084: CALL_OW 76
29088: ST_TO_ADDR
// for i in cek do
29089: LD_ADDR_VAR 0 3
29093: PUSH
29094: LD_VAR 0 4
29098: PUSH
29099: FOR_IN
29100: IFFALSE 29136
// begin cek2 := cek2 ^ i - last ;
29102: LD_ADDR_VAR 0 5
29106: PUSH
29107: LD_VAR 0 5
29111: PUSH
29112: LD_VAR 0 3
29116: PUSH
29117: LD_VAR 0 6
29121: MINUS
29122: ADD
29123: ST_TO_ADDR
// last := i ;
29124: LD_ADDR_VAR 0 6
29128: PUSH
29129: LD_VAR 0 3
29133: ST_TO_ADDR
// end ;
29134: GO 29099
29136: POP
29137: POP
// for i := 1 to x do
29138: LD_ADDR_VAR 0 3
29142: PUSH
29143: DOUBLE
29144: LD_INT 1
29146: DEC
29147: ST_TO_ADDR
29148: LD_VAR 0 2
29152: PUSH
29153: FOR_TO
29154: IFFALSE 29183
// begin CreateCratesAnywhere ( 5 , true ) ;
29156: LD_INT 5
29158: PPUSH
29159: LD_INT 1
29161: PPUSH
29162: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
29166: LD_VAR 0 5
29170: PUSH
29171: LD_VAR 0 3
29175: ARRAY
29176: PPUSH
29177: CALL_OW 67
// end ;
29181: GO 29153
29183: POP
29184: POP
// end ; end_of_file
29185: LD_VAR 0 1
29189: RET
// var rDef1 , rDef2 , rDef3 , rDef4 , rDef5 ; var idDef1 , idDef2 , idDef3 , idDef4 , idDef5 ; export toDef1 , toDef2 , toDef3 , toDef4 , toDef5 ; every 0 0$1 do
29190: GO 29192
29192: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29193: LD_ADDR_EXP 89
29197: PUSH
29198: LD_EXP 76
29202: PUSH
29203: LD_INT 1
29205: ARRAY
29206: PPUSH
29207: LD_EXP 51
29211: PUSH
29212: EMPTY
29213: LIST
29214: PPUSH
29215: CALL_OW 72
29219: PUSH
29220: LD_EXP 77
29224: PUSH
29225: LD_INT 1
29227: ARRAY
29228: ADD
29229: PUSH
29230: LD_EXP 75
29234: PUSH
29235: LD_INT 1
29237: ARRAY
29238: PPUSH
29239: LD_EXP 56
29243: PUSH
29244: EMPTY
29245: LIST
29246: PPUSH
29247: CALL_OW 72
29251: ADD
29252: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29253: LD_ADDR_EXP 90
29257: PUSH
29258: LD_EXP 76
29262: PUSH
29263: LD_INT 2
29265: ARRAY
29266: PPUSH
29267: LD_EXP 51
29271: PUSH
29272: EMPTY
29273: LIST
29274: PPUSH
29275: CALL_OW 72
29279: PUSH
29280: LD_EXP 77
29284: PUSH
29285: LD_INT 2
29287: ARRAY
29288: ADD
29289: PUSH
29290: LD_EXP 75
29294: PUSH
29295: LD_INT 2
29297: ARRAY
29298: PPUSH
29299: LD_EXP 56
29303: PUSH
29304: EMPTY
29305: LIST
29306: PPUSH
29307: CALL_OW 72
29311: ADD
29312: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29313: LD_ADDR_EXP 91
29317: PUSH
29318: LD_EXP 76
29322: PUSH
29323: LD_INT 3
29325: ARRAY
29326: PPUSH
29327: LD_EXP 51
29331: PUSH
29332: EMPTY
29333: LIST
29334: PPUSH
29335: CALL_OW 72
29339: PUSH
29340: LD_EXP 77
29344: PUSH
29345: LD_INT 3
29347: ARRAY
29348: ADD
29349: PUSH
29350: LD_EXP 75
29354: PUSH
29355: LD_INT 3
29357: ARRAY
29358: PPUSH
29359: LD_EXP 56
29363: PUSH
29364: EMPTY
29365: LIST
29366: PPUSH
29367: CALL_OW 72
29371: ADD
29372: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
29373: LD_ADDR_EXP 92
29377: PUSH
29378: LD_EXP 76
29382: PUSH
29383: LD_INT 4
29385: ARRAY
29386: PPUSH
29387: LD_EXP 51
29391: PUSH
29392: EMPTY
29393: LIST
29394: PPUSH
29395: CALL_OW 72
29399: PUSH
29400: LD_EXP 77
29404: PUSH
29405: LD_INT 4
29407: ARRAY
29408: ADD
29409: PUSH
29410: LD_EXP 75
29414: PUSH
29415: LD_INT 4
29417: ARRAY
29418: PPUSH
29419: LD_EXP 56
29423: PUSH
29424: EMPTY
29425: LIST
29426: PPUSH
29427: CALL_OW 72
29431: ADD
29432: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
29433: LD_ADDR_EXP 93
29437: PUSH
29438: LD_EXP 76
29442: PUSH
29443: LD_INT 5
29445: ARRAY
29446: PPUSH
29447: LD_EXP 51
29451: PUSH
29452: EMPTY
29453: LIST
29454: PPUSH
29455: CALL_OW 72
29459: PUSH
29460: LD_EXP 77
29464: PUSH
29465: LD_INT 5
29467: ARRAY
29468: ADD
29469: PUSH
29470: LD_EXP 75
29474: PUSH
29475: LD_INT 5
29477: ARRAY
29478: PPUSH
29479: LD_EXP 56
29483: PUSH
29484: EMPTY
29485: LIST
29486: PPUSH
29487: CALL_OW 72
29491: ADD
29492: ST_TO_ADDR
// rDef1 := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearA ] , [ mc_reg_area_to_protect , nearA ] ] ) ;
29493: LD_ADDR_LOC 31
29497: PUSH
29498: LD_EXP 23
29502: PUSH
29503: LD_INT 1
29505: ARRAY
29506: PPUSH
29507: LD_INT 1
29509: PUSH
29510: LD_INT 70
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 2
29519: PUSH
29520: LD_INT 24
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 3
29529: PUSH
29530: LD_INT 24
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: EMPTY
29538: LIST
29539: LIST
29540: LIST
29541: PPUSH
29542: CALL_OW 399
29546: ST_TO_ADDR
// rDef2 := McRegistry ( ai_s [ 2 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearB ] , [ mc_reg_area_to_protect , nearB ] ] ) ;
29547: LD_ADDR_LOC 32
29551: PUSH
29552: LD_EXP 23
29556: PUSH
29557: LD_INT 2
29559: ARRAY
29560: PPUSH
29561: LD_INT 1
29563: PUSH
29564: LD_INT 70
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 2
29573: PUSH
29574: LD_INT 25
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 3
29583: PUSH
29584: LD_INT 25
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: LIST
29595: PPUSH
29596: CALL_OW 399
29600: ST_TO_ADDR
// rDef3 := McRegistry ( ai_s [ 3 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearC ] , [ mc_reg_area_to_protect , nearC ] ] ) ;
29601: LD_ADDR_LOC 33
29605: PUSH
29606: LD_EXP 23
29610: PUSH
29611: LD_INT 3
29613: ARRAY
29614: PPUSH
29615: LD_INT 1
29617: PUSH
29618: LD_INT 70
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 2
29627: PUSH
29628: LD_INT 26
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 3
29637: PUSH
29638: LD_INT 26
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: LIST
29649: PPUSH
29650: CALL_OW 399
29654: ST_TO_ADDR
// rDef4 := McRegistry ( ai_s [ 4 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearD ] , [ mc_reg_area_to_protect , nearD ] ] ) ;
29655: LD_ADDR_LOC 34
29659: PUSH
29660: LD_EXP 23
29664: PUSH
29665: LD_INT 4
29667: ARRAY
29668: PPUSH
29669: LD_INT 1
29671: PUSH
29672: LD_INT 70
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 27
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 3
29691: PUSH
29692: LD_INT 27
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: LIST
29703: PPUSH
29704: CALL_OW 399
29708: ST_TO_ADDR
// rDef5 := McRegistry ( ai_s [ 5 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearE ] , [ mc_reg_area_to_protect , nearE ] ] ) ;
29709: LD_ADDR_LOC 35
29713: PUSH
29714: LD_EXP 23
29718: PUSH
29719: LD_INT 5
29721: ARRAY
29722: PPUSH
29723: LD_INT 1
29725: PUSH
29726: LD_INT 70
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 2
29735: PUSH
29736: LD_INT 28
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 3
29745: PUSH
29746: LD_INT 28
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 399
29762: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef1_difficulty ] ) ;
29763: LD_ADDR_LOC 36
29767: PUSH
29768: LD_INT 10
29770: PPUSH
29771: LD_LOC 31
29775: PPUSH
29776: LD_EXP 89
29780: PPUSH
29781: LD_INT 1
29783: PUSH
29784: LD_EXP 11
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PPUSH
29793: CALL_OW 401
29797: ST_TO_ADDR
// idDef2 := McDefend ( 10 , rDef2 , toDef2 , [ mc_def_advantage , mcdef2_difficulty ] ) ;
29798: LD_ADDR_LOC 37
29802: PUSH
29803: LD_INT 10
29805: PPUSH
29806: LD_LOC 32
29810: PPUSH
29811: LD_EXP 90
29815: PPUSH
29816: LD_INT 1
29818: PUSH
29819: LD_EXP 12
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 401
29832: ST_TO_ADDR
// idDef3 := McDefend ( 10 , rDef3 , toDef3 , [ mc_def_advantage , mcdef3_difficulty ] ) ;
29833: LD_ADDR_LOC 38
29837: PUSH
29838: LD_INT 10
29840: PPUSH
29841: LD_LOC 33
29845: PPUSH
29846: LD_EXP 91
29850: PPUSH
29851: LD_INT 1
29853: PUSH
29854: LD_EXP 13
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PPUSH
29863: CALL_OW 401
29867: ST_TO_ADDR
// idDef4 := McDefend ( 10 , rDef4 , toDef4 , [ mc_def_advantage , mcdef4_difficulty ] ) ;
29868: LD_ADDR_LOC 39
29872: PUSH
29873: LD_INT 10
29875: PPUSH
29876: LD_LOC 34
29880: PPUSH
29881: LD_EXP 92
29885: PPUSH
29886: LD_INT 1
29888: PUSH
29889: LD_EXP 14
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PPUSH
29898: CALL_OW 401
29902: ST_TO_ADDR
// idDef5 := McDefend ( 10 , rDef5 , toDef5 , [ mc_def_advantage , mcdef5_difficulty ] ) ;
29903: LD_ADDR_LOC 40
29907: PUSH
29908: LD_INT 10
29910: PPUSH
29911: LD_LOC 35
29915: PPUSH
29916: LD_EXP 93
29920: PPUSH
29921: LD_INT 1
29923: PUSH
29924: LD_EXP 15
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PPUSH
29933: CALL_OW 401
29937: ST_TO_ADDR
// end ;
29938: END
// every 0 0$10 do
29939: GO 29941
29941: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29942: LD_ADDR_EXP 89
29946: PUSH
29947: LD_EXP 76
29951: PUSH
29952: LD_INT 1
29954: ARRAY
29955: PPUSH
29956: LD_EXP 51
29960: PUSH
29961: EMPTY
29962: LIST
29963: PPUSH
29964: CALL_OW 72
29968: PUSH
29969: LD_EXP 77
29973: PUSH
29974: LD_INT 1
29976: ARRAY
29977: ADD
29978: PUSH
29979: LD_EXP 75
29983: PUSH
29984: LD_INT 1
29986: ARRAY
29987: PPUSH
29988: LD_EXP 56
29992: PUSH
29993: EMPTY
29994: LIST
29995: PPUSH
29996: CALL_OW 72
30000: ADD
30001: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
30002: LD_ADDR_EXP 90
30006: PUSH
30007: LD_EXP 76
30011: PUSH
30012: LD_INT 2
30014: ARRAY
30015: PPUSH
30016: LD_EXP 51
30020: PUSH
30021: EMPTY
30022: LIST
30023: PPUSH
30024: CALL_OW 72
30028: PUSH
30029: LD_EXP 77
30033: PUSH
30034: LD_INT 2
30036: ARRAY
30037: ADD
30038: PUSH
30039: LD_EXP 75
30043: PUSH
30044: LD_INT 2
30046: ARRAY
30047: PPUSH
30048: LD_EXP 56
30052: PUSH
30053: EMPTY
30054: LIST
30055: PPUSH
30056: CALL_OW 72
30060: ADD
30061: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
30062: LD_ADDR_EXP 91
30066: PUSH
30067: LD_EXP 76
30071: PUSH
30072: LD_INT 3
30074: ARRAY
30075: PPUSH
30076: LD_EXP 51
30080: PUSH
30081: EMPTY
30082: LIST
30083: PPUSH
30084: CALL_OW 72
30088: PUSH
30089: LD_EXP 77
30093: PUSH
30094: LD_INT 3
30096: ARRAY
30097: ADD
30098: PUSH
30099: LD_EXP 75
30103: PUSH
30104: LD_INT 3
30106: ARRAY
30107: PPUSH
30108: LD_EXP 56
30112: PUSH
30113: EMPTY
30114: LIST
30115: PPUSH
30116: CALL_OW 72
30120: ADD
30121: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
30122: LD_ADDR_EXP 92
30126: PUSH
30127: LD_EXP 76
30131: PUSH
30132: LD_INT 4
30134: ARRAY
30135: PPUSH
30136: LD_EXP 51
30140: PUSH
30141: EMPTY
30142: LIST
30143: PPUSH
30144: CALL_OW 72
30148: PUSH
30149: LD_EXP 77
30153: PUSH
30154: LD_INT 4
30156: ARRAY
30157: ADD
30158: PUSH
30159: LD_EXP 75
30163: PUSH
30164: LD_INT 4
30166: ARRAY
30167: PPUSH
30168: LD_EXP 56
30172: PUSH
30173: EMPTY
30174: LIST
30175: PPUSH
30176: CALL_OW 72
30180: ADD
30181: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
30182: LD_ADDR_EXP 93
30186: PUSH
30187: LD_EXP 76
30191: PUSH
30192: LD_INT 5
30194: ARRAY
30195: PPUSH
30196: LD_EXP 51
30200: PUSH
30201: EMPTY
30202: LIST
30203: PPUSH
30204: CALL_OW 72
30208: PUSH
30209: LD_EXP 77
30213: PUSH
30214: LD_INT 5
30216: ARRAY
30217: ADD
30218: PUSH
30219: LD_EXP 75
30223: PUSH
30224: LD_INT 5
30226: ARRAY
30227: PPUSH
30228: LD_EXP 56
30232: PUSH
30233: EMPTY
30234: LIST
30235: PPUSH
30236: CALL_OW 72
30240: ADD
30241: ST_TO_ADDR
// ClearMcUnits ( idDef1 ) ;
30242: LD_LOC 36
30246: PPUSH
30247: CALL_OW 392
// AddMcUnits ( idDef1 , todef1 ) ;
30251: LD_LOC 36
30255: PPUSH
30256: LD_EXP 89
30260: PPUSH
30261: CALL_OW 390
// ClearMcUnits ( idDef2 ) ;
30265: LD_LOC 37
30269: PPUSH
30270: CALL_OW 392
// AddMcUnits ( idDef2 , todef2 ) ;
30274: LD_LOC 37
30278: PPUSH
30279: LD_EXP 90
30283: PPUSH
30284: CALL_OW 390
// ClearMcUnits ( idDef3 ) ;
30288: LD_LOC 38
30292: PPUSH
30293: CALL_OW 392
// AddMcUnits ( idDef3 , todef3 ) ;
30297: LD_LOC 38
30301: PPUSH
30302: LD_EXP 91
30306: PPUSH
30307: CALL_OW 390
// ClearMcUnits ( idDef4 ) ;
30311: LD_LOC 39
30315: PPUSH
30316: CALL_OW 392
// AddMcUnits ( idDef4 , todef4 ) ;
30320: LD_LOC 39
30324: PPUSH
30325: LD_EXP 92
30329: PPUSH
30330: CALL_OW 390
// ClearMcUnits ( idDef5 ) ;
30334: LD_LOC 40
30338: PPUSH
30339: CALL_OW 392
// AddMcUnits ( idDef5 , todef5 ) ;
30343: LD_LOC 40
30347: PPUSH
30348: LD_EXP 93
30352: PPUSH
30353: CALL_OW 390
// enable ;
30357: ENABLE
// end ; end_of_file
30358: END
// export function SurrenderBase ( type , side ) ; var a , cars ; begin
30359: LD_INT 0
30361: PPUSH
30362: PPUSH
30363: PPUSH
// if not ( side in your_bases ) then
30364: LD_VAR 0 2
30368: PUSH
30369: LD_EXP 18
30373: IN
30374: NOT
30375: IFFALSE 30989
// begin SetAttitude ( you , side , att_friend , true ) ;
30377: LD_EXP 7
30381: PPUSH
30382: LD_VAR 0 2
30386: PPUSH
30387: LD_INT 1
30389: PPUSH
30390: LD_INT 1
30392: PPUSH
30393: CALL_OW 80
// case type of t_kill :
30397: LD_VAR 0 1
30401: PUSH
30402: LD_EXP 1
30406: DOUBLE
30407: EQUAL
30408: IFTRUE 30412
30410: GO 30483
30412: POP
// begin if side = ai_s [ 1 ] then
30413: LD_VAR 0 2
30417: PUSH
30418: LD_EXP 23
30422: PUSH
30423: LD_INT 1
30425: ARRAY
30426: EQUAL
30427: IFFALSE 30452
// begin DXbaseSurrender ( side ) ;
30429: LD_VAR 0 2
30433: PPUSH
30434: CALL 7938 0 1
// SurrenderNormal ( true , side ) ;
30438: LD_INT 1
30440: PPUSH
30441: LD_VAR 0 2
30445: PPUSH
30446: CALL 30994 0 2
// end else
30450: GO 30481
// begin diplomacy := false ;
30452: LD_ADDR_EXP 27
30456: PUSH
30457: LD_INT 0
30459: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30460: LD_VAR 0 2
30464: PPUSH
30465: CALL 7938 0 1
// SurrenderNormal ( true , side ) ;
30469: LD_INT 1
30471: PPUSH
30472: LD_VAR 0 2
30476: PPUSH
30477: CALL 30994 0 2
// end ; end ; t_killbeat :
30481: GO 30821
30483: LD_EXP 6
30487: DOUBLE
30488: EQUAL
30489: IFTRUE 30493
30491: GO 30564
30493: POP
// begin if side = ai_s [ 1 ] then
30494: LD_VAR 0 2
30498: PUSH
30499: LD_EXP 23
30503: PUSH
30504: LD_INT 1
30506: ARRAY
30507: EQUAL
30508: IFFALSE 30533
// begin DXbaseSurrender ( side ) ;
30510: LD_VAR 0 2
30514: PPUSH
30515: CALL 7938 0 1
// SurrenderNormal ( true , side ) ;
30519: LD_INT 1
30521: PPUSH
30522: LD_VAR 0 2
30526: PPUSH
30527: CALL 30994 0 2
// end else
30531: GO 30562
// begin diplomacy := false ;
30533: LD_ADDR_EXP 27
30537: PUSH
30538: LD_INT 0
30540: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30541: LD_VAR 0 2
30545: PPUSH
30546: CALL 7938 0 1
// SurrenderNormal ( true , side ) ;
30550: LD_INT 1
30552: PPUSH
30553: LD_VAR 0 2
30557: PPUSH
30558: CALL 30994 0 2
// end ; end ; t_intimidate :
30562: GO 30821
30564: LD_EXP 2
30568: DOUBLE
30569: EQUAL
30570: IFTRUE 30574
30572: GO 30628
30574: POP
// begin if side = ai_s [ 2 ] then
30575: LD_VAR 0 2
30579: PUSH
30580: LD_EXP 23
30584: PUSH
30585: LD_INT 2
30587: ARRAY
30588: EQUAL
30589: IFFALSE 30626
// begin DB_BaseAccept ( cap_bases = 0 ) ;
30591: LD_EXP 17
30595: PUSH
30596: LD_INT 0
30598: EQUAL
30599: PPUSH
30600: CALL 4597 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 2 ] ) ;
30604: LD_EXP 17
30608: PUSH
30609: LD_INT 0
30611: EQUAL
30612: PPUSH
30613: LD_EXP 23
30617: PUSH
30618: LD_INT 2
30620: ARRAY
30621: PPUSH
30622: CALL 30994 0 2
// end ; end ; t_persuade :
30626: GO 30821
30628: LD_EXP 3
30632: DOUBLE
30633: EQUAL
30634: IFTRUE 30638
30636: GO 30692
30638: POP
// begin if side = ai_s [ 3 ] then
30639: LD_VAR 0 2
30643: PUSH
30644: LD_EXP 23
30648: PUSH
30649: LD_INT 3
30651: ARRAY
30652: EQUAL
30653: IFFALSE 30690
// begin DQrML_Right ( cap_bases = 0 ) ;
30655: LD_EXP 17
30659: PUSH
30660: LD_INT 0
30662: EQUAL
30663: PPUSH
30664: CALL 6761 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 3 ] ) ;
30668: LD_EXP 17
30672: PUSH
30673: LD_INT 0
30675: EQUAL
30676: PPUSH
30677: LD_EXP 23
30681: PUSH
30682: LD_INT 3
30684: ARRAY
30685: PPUSH
30686: CALL 30994 0 2
// end ; end ; t_pay :
30690: GO 30821
30692: LD_EXP 4
30696: DOUBLE
30697: EQUAL
30698: IFTRUE 30702
30700: GO 30756
30702: POP
// begin if side = ai_s [ 4 ] then
30703: LD_VAR 0 2
30707: PUSH
30708: LD_EXP 23
30712: PUSH
30713: LD_INT 4
30715: ARRAY
30716: EQUAL
30717: IFFALSE 30754
// begin DD_BaseAccept ( cap_bases = 0 ) ;
30719: LD_EXP 17
30723: PUSH
30724: LD_INT 0
30726: EQUAL
30727: PPUSH
30728: CALL 7325 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 4 ] ) ;
30732: LD_EXP 17
30736: PUSH
30737: LD_INT 0
30739: EQUAL
30740: PPUSH
30741: LD_EXP 23
30745: PUSH
30746: LD_INT 4
30748: ARRAY
30749: PPUSH
30750: CALL 30994 0 2
// end ; end ; t_beat :
30754: GO 30821
30756: LD_EXP 5
30760: DOUBLE
30761: EQUAL
30762: IFTRUE 30766
30764: GO 30820
30766: POP
// begin if side = ai_s [ 5 ] then
30767: LD_VAR 0 2
30771: PUSH
30772: LD_EXP 23
30776: PUSH
30777: LD_INT 5
30779: ARRAY
30780: EQUAL
30781: IFFALSE 30818
// begin DE_BaseAccept ( cap_bases = 0 ) ;
30783: LD_EXP 17
30787: PUSH
30788: LD_INT 0
30790: EQUAL
30791: PPUSH
30792: CALL 7878 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 5 ] ) ;
30796: LD_EXP 17
30800: PUSH
30801: LD_INT 0
30803: EQUAL
30804: PPUSH
30805: LD_EXP 23
30809: PUSH
30810: LD_INT 5
30812: ARRAY
30813: PPUSH
30814: CALL 30994 0 2
// end ; end ; end ;
30818: GO 30821
30820: POP
// your_humans := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
30821: LD_ADDR_EXP 37
30825: PUSH
30826: LD_INT 22
30828: PUSH
30829: LD_EXP 7
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 21
30840: PUSH
30841: LD_INT 1
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PPUSH
30852: CALL_OW 69
30856: ST_TO_ADDR
// your_builds := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
30857: LD_ADDR_EXP 36
30861: PUSH
30862: LD_INT 22
30864: PUSH
30865: LD_EXP 7
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 21
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PPUSH
30888: CALL_OW 69
30892: ST_TO_ADDR
// your_cars := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
30893: LD_ADDR_EXP 35
30897: PUSH
30898: LD_INT 22
30900: PUSH
30901: LD_EXP 7
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 21
30912: PUSH
30913: LD_INT 2
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PPUSH
30924: CALL_OW 69
30928: ST_TO_ADDR
// remove_from_humans ( your_humans ) ;
30929: LD_EXP 37
30933: PPUSH
30934: CALL 28027 0 1
// remove_from_builds ( your_builds ) ;
30938: LD_EXP 36
30942: PPUSH
30943: CALL 27781 0 1
// remove_from_vehicles ( your_cars ) ;
30947: LD_EXP 35
30951: PPUSH
30952: CALL 28265 0 1
// cap_bases := cap_bases + 1 ;
30956: LD_ADDR_EXP 17
30960: PUSH
30961: LD_EXP 17
30965: PUSH
30966: LD_INT 1
30968: PLUS
30969: ST_TO_ADDR
// your_bases := your_bases ^ [ side ] ;
30970: LD_ADDR_EXP 18
30974: PUSH
30975: LD_EXP 18
30979: PUSH
30980: LD_VAR 0 2
30984: PUSH
30985: EMPTY
30986: LIST
30987: ADD
30988: ST_TO_ADDR
// end ; end ;
30989: LD_VAR 0 3
30993: RET
// function SurrenderNormal ( first , side ) ; var yours , take , theirs , i , max , t_sci , t_lab ; begin
30994: LD_INT 0
30996: PPUSH
30997: PPUSH
30998: PPUSH
30999: PPUSH
31000: PPUSH
31001: PPUSH
31002: PPUSH
31003: PPUSH
// yours := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31004: LD_ADDR_VAR 0 4
31008: PUSH
31009: LD_INT 22
31011: PUSH
31012: LD_EXP 7
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 21
31023: PUSH
31024: LD_INT 1
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 23
31033: PUSH
31034: LD_INT 3
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: LIST
31045: PPUSH
31046: CALL_OW 69
31050: ST_TO_ADDR
// theirs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31051: LD_ADDR_VAR 0 6
31055: PUSH
31056: LD_INT 22
31058: PUSH
31059: LD_VAR 0 2
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 21
31070: PUSH
31071: LD_INT 1
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 23
31080: PUSH
31081: LD_INT 3
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: LIST
31092: PPUSH
31093: CALL_OW 69
31097: ST_TO_ADDR
// for i in theirs do
31098: LD_ADDR_VAR 0 7
31102: PUSH
31103: LD_VAR 0 6
31107: PUSH
31108: FOR_IN
31109: IFFALSE 31144
// if GetLives ( i ) < hranice_umirani then
31111: LD_VAR 0 7
31115: PPUSH
31116: CALL_OW 256
31120: PUSH
31121: LD_INT 250
31123: LESS
31124: IFFALSE 31142
// SetLives ( i , hranice_umirani + 50 ) ;
31126: LD_VAR 0 7
31130: PPUSH
31131: LD_INT 250
31133: PUSH
31134: LD_INT 50
31136: PLUS
31137: PPUSH
31138: CALL_OW 234
31142: GO 31108
31144: POP
31145: POP
// InGameOn ;
31146: CALL_OW 8
// while UnitFilter ( theirs , [ [ f_inside ] ] ) diff hlavouni do
31150: LD_VAR 0 6
31154: PPUSH
31155: LD_INT 54
31157: PUSH
31158: EMPTY
31159: LIST
31160: PUSH
31161: EMPTY
31162: LIST
31163: PPUSH
31164: CALL_OW 72
31168: PUSH
31169: LD_EXP 72
31173: DIFF
31174: IFFALSE 31203
// begin ComExitBuilding ( theirs ) ;
31176: LD_VAR 0 6
31180: PPUSH
31181: CALL_OW 122
// AddComExitVehicle ( theirs ) ;
31185: LD_VAR 0 6
31189: PPUSH
31190: CALL_OW 181
// wait ( 0 0$2 ) ;
31194: LD_INT 70
31196: PPUSH
31197: CALL_OW 67
// end ;
31201: GO 31150
// InGameOff ;
31203: CALL_OW 9
// if first then
31207: LD_VAR 0 1
31211: IFFALSE 31877
// begin SetTech ( tech_SibLoc , you , state_researched ) ;
31213: LD_INT 19
31215: PPUSH
31216: LD_EXP 7
31220: PPUSH
31221: LD_INT 2
31223: PPUSH
31224: CALL_OW 322
// ai := ai diff side ;
31228: LD_ADDR_EXP 24
31232: PUSH
31233: LD_EXP 24
31237: PUSH
31238: LD_VAR 0 2
31242: DIFF
31243: ST_TO_ADDR
// case side of ai_s [ 1 ] :
31244: LD_VAR 0 2
31248: PUSH
31249: LD_EXP 23
31253: PUSH
31254: LD_INT 1
31256: ARRAY
31257: DOUBLE
31258: EQUAL
31259: IFTRUE 31263
31261: GO 31325
31263: POP
// begin SetSideBase_custom ( GetBase ( depots [ 1 ] ) , you ) ;
31264: LD_EXP 74
31268: PUSH
31269: LD_INT 1
31271: ARRAY
31272: PPUSH
31273: CALL_OW 274
31277: PPUSH
31278: LD_EXP 7
31282: PPUSH
31283: CALL 32764 0 2
// SetSide ( humans [ 1 ] , you ) ;
31287: LD_EXP 76
31291: PUSH
31292: LD_INT 1
31294: ARRAY
31295: PPUSH
31296: LD_EXP 7
31300: PPUSH
31301: CALL_OW 235
// SetSide ( vehicles [ 1 ] , you ) ;
31305: LD_EXP 77
31309: PUSH
31310: LD_INT 1
31312: ARRAY
31313: PPUSH
31314: LD_EXP 7
31318: PPUSH
31319: CALL_OW 235
// end ; ai_s [ 2 ] :
31323: GO 31875
31325: LD_EXP 23
31329: PUSH
31330: LD_INT 2
31332: ARRAY
31333: DOUBLE
31334: EQUAL
31335: IFTRUE 31339
31337: GO 31415
31339: POP
// begin SetSideBase_custom ( GetBase ( depots [ 2 ] ) , you ) ;
31340: LD_EXP 74
31344: PUSH
31345: LD_INT 2
31347: ARRAY
31348: PPUSH
31349: CALL_OW 274
31353: PPUSH
31354: LD_EXP 7
31358: PPUSH
31359: CALL 32764 0 2
// SetSide ( humans [ 2 ] , you ) ;
31363: LD_EXP 76
31367: PUSH
31368: LD_INT 2
31370: ARRAY
31371: PPUSH
31372: LD_EXP 7
31376: PPUSH
31377: CALL_OW 235
// SetSide ( vehicles [ 2 ] , you ) ;
31381: LD_EXP 77
31385: PUSH
31386: LD_INT 2
31388: ARRAY
31389: PPUSH
31390: LD_EXP 7
31394: PPUSH
31395: CALL_OW 235
// SetSide ( Borodin , you ) ;
31399: LD_EXP 46
31403: PPUSH
31404: LD_EXP 7
31408: PPUSH
31409: CALL_OW 235
// end ; ai_s [ 3 ] :
31413: GO 31875
31415: LD_EXP 23
31419: PUSH
31420: LD_INT 3
31422: ARRAY
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31505
31429: POP
// begin SetSideBase_custom ( GetBase ( depots [ 3 ] ) , you ) ;
31430: LD_EXP 74
31434: PUSH
31435: LD_INT 3
31437: ARRAY
31438: PPUSH
31439: CALL_OW 274
31443: PPUSH
31444: LD_EXP 7
31448: PPUSH
31449: CALL 32764 0 2
// SetSide ( humans [ 3 ] , you ) ;
31453: LD_EXP 76
31457: PUSH
31458: LD_INT 3
31460: ARRAY
31461: PPUSH
31462: LD_EXP 7
31466: PPUSH
31467: CALL_OW 235
// SetSide ( vehicles [ 3 ] , you ) ;
31471: LD_EXP 77
31475: PUSH
31476: LD_INT 3
31478: ARRAY
31479: PPUSH
31480: LD_EXP 7
31484: PPUSH
31485: CALL_OW 235
// SetSide ( Tsaritsyn , you ) ;
31489: LD_EXP 47
31493: PPUSH
31494: LD_EXP 7
31498: PPUSH
31499: CALL_OW 235
// end ; ai_s [ 4 ] :
31503: GO 31875
31505: LD_EXP 23
31509: PUSH
31510: LD_INT 4
31512: ARRAY
31513: DOUBLE
31514: EQUAL
31515: IFTRUE 31519
31517: GO 31784
31519: POP
// begin t_sci := sci isect humans [ 4 ] ;
31520: LD_ADDR_VAR 0 9
31524: PUSH
31525: LD_EXP 88
31529: PUSH
31530: LD_EXP 76
31534: PUSH
31535: LD_INT 4
31537: ARRAY
31538: ISECT
31539: ST_TO_ADDR
// if t_sci > 3 then
31540: LD_VAR 0 9
31544: PUSH
31545: LD_INT 3
31547: GREATER
31548: IFFALSE 31584
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
31550: LD_ADDR_VAR 0 9
31554: PUSH
31555: LD_VAR 0 9
31559: PUSH
31560: LD_INT 1
31562: ARRAY
31563: PUSH
31564: LD_VAR 0 9
31568: PUSH
31569: LD_INT 2
31571: ARRAY
31572: ADD
31573: PUSH
31574: LD_VAR 0 9
31578: PUSH
31579: LD_INT 3
31581: ARRAY
31582: ADD
31583: ST_TO_ADDR
// t_lab := UnitFilter ( buildings [ 4 ] , [ mf_lab ] ) ;
31584: LD_ADDR_VAR 0 10
31588: PUSH
31589: LD_EXP 75
31593: PUSH
31594: LD_INT 4
31596: ARRAY
31597: PPUSH
31598: LD_EXP 55
31602: PUSH
31603: EMPTY
31604: LIST
31605: PPUSH
31606: CALL_OW 72
31610: ST_TO_ADDR
// for i in t_lab do
31611: LD_ADDR_VAR 0 7
31615: PUSH
31616: LD_VAR 0 10
31620: PUSH
31621: FOR_IN
31622: IFFALSE 31674
// if GetLabKind ( i , 1 ) = b_lab_spacetime or GetLabKind ( i , 2 ) = b_lab_spacetime then
31624: LD_VAR 0 7
31628: PPUSH
31629: LD_INT 1
31631: PPUSH
31632: CALL_OW 268
31636: PUSH
31637: LD_INT 14
31639: EQUAL
31640: PUSH
31641: LD_VAR 0 7
31645: PPUSH
31646: LD_INT 2
31648: PPUSH
31649: CALL_OW 268
31653: PUSH
31654: LD_INT 14
31656: EQUAL
31657: OR
31658: IFFALSE 31672
// begin t_lab := i ;
31660: LD_ADDR_VAR 0 10
31664: PUSH
31665: LD_VAR 0 7
31669: ST_TO_ADDR
// break ;
31670: GO 31674
// end ;
31672: GO 31621
31674: POP
31675: POP
// SetSideBase_custom ( GetBase ( depots [ 4 ] ) , you ) ;
31676: LD_EXP 74
31680: PUSH
31681: LD_INT 4
31683: ARRAY
31684: PPUSH
31685: CALL_OW 274
31689: PPUSH
31690: LD_EXP 7
31694: PPUSH
31695: CALL 32764 0 2
// SetSide ( humans [ 4 ] diff t_sci , you ) ;
31699: LD_EXP 76
31703: PUSH
31704: LD_INT 4
31706: ARRAY
31707: PUSH
31708: LD_VAR 0 9
31712: DIFF
31713: PPUSH
31714: LD_EXP 7
31718: PPUSH
31719: CALL_OW 235
// SetSide ( vehicles [ 4 ] , you ) ;
31723: LD_EXP 77
31727: PUSH
31728: LD_INT 4
31730: ARRAY
31731: PPUSH
31732: LD_EXP 7
31736: PPUSH
31737: CALL_OW 235
// SetSide ( t_lab , ai_s [ 4 ] ) ;
31741: LD_VAR 0 10
31745: PPUSH
31746: LD_EXP 23
31750: PUSH
31751: LD_INT 4
31753: ARRAY
31754: PPUSH
31755: CALL_OW 235
// ComEnterUnit ( t_sci ^ [ Davidov ] , t_lab ) ;
31759: LD_VAR 0 9
31763: PUSH
31764: LD_EXP 48
31768: PUSH
31769: EMPTY
31770: LIST
31771: ADD
31772: PPUSH
31773: LD_VAR 0 10
31777: PPUSH
31778: CALL_OW 120
// end ; ai_s [ 5 ] :
31782: GO 31875
31784: LD_EXP 23
31788: PUSH
31789: LD_INT 5
31791: ARRAY
31792: DOUBLE
31793: EQUAL
31794: IFTRUE 31798
31796: GO 31874
31798: POP
// begin SetSideBase_custom ( GetBase ( depots [ 5 ] ) , you ) ;
31799: LD_EXP 74
31803: PUSH
31804: LD_INT 5
31806: ARRAY
31807: PPUSH
31808: CALL_OW 274
31812: PPUSH
31813: LD_EXP 7
31817: PPUSH
31818: CALL 32764 0 2
// SetSide ( humans [ 5 ] , you ) ;
31822: LD_EXP 76
31826: PUSH
31827: LD_INT 5
31829: ARRAY
31830: PPUSH
31831: LD_EXP 7
31835: PPUSH
31836: CALL_OW 235
// SetSide ( vehicles [ 5 ] , you ) ;
31840: LD_EXP 77
31844: PUSH
31845: LD_INT 5
31847: ARRAY
31848: PPUSH
31849: LD_EXP 7
31853: PPUSH
31854: CALL_OW 235
// SetSide ( Eisenstein , you ) ;
31858: LD_EXP 49
31862: PPUSH
31863: LD_EXP 7
31867: PPUSH
31868: CALL_OW 235
// end ; end ;
31872: GO 31875
31874: POP
// end else
31875: GO 32674
// begin case side of ai_s [ 1 ] :
31877: LD_VAR 0 2
31881: PUSH
31882: LD_EXP 23
31886: PUSH
31887: LD_INT 1
31889: ARRAY
31890: DOUBLE
31891: EQUAL
31892: IFTRUE 31896
31894: GO 31933
31896: POP
// take := humans [ 1 ] ^ buildings [ 1 ] ^ vehicles [ 1 ] ; ai_s [ 2 ] :
31897: LD_ADDR_VAR 0 5
31901: PUSH
31902: LD_EXP 76
31906: PUSH
31907: LD_INT 1
31909: ARRAY
31910: PUSH
31911: LD_EXP 75
31915: PUSH
31916: LD_INT 1
31918: ARRAY
31919: ADD
31920: PUSH
31921: LD_EXP 77
31925: PUSH
31926: LD_INT 1
31928: ARRAY
31929: ADD
31930: ST_TO_ADDR
31931: GO 32674
31933: LD_EXP 23
31937: PUSH
31938: LD_INT 2
31940: ARRAY
31941: DOUBLE
31942: EQUAL
31943: IFTRUE 31947
31945: GO 32099
31947: POP
// begin if humans [ 2 ] < 3 then
31948: LD_EXP 76
31952: PUSH
31953: LD_INT 2
31955: ARRAY
31956: PUSH
31957: LD_INT 3
31959: LESS
31960: IFFALSE 31972
// max := 1 else
31962: LD_ADDR_VAR 0 8
31966: PUSH
31967: LD_INT 1
31969: ST_TO_ADDR
31970: GO 31990
// max := humans [ 2 ] - 2 ;
31972: LD_ADDR_VAR 0 8
31976: PUSH
31977: LD_EXP 76
31981: PUSH
31982: LD_INT 2
31984: ARRAY
31985: PUSH
31986: LD_INT 2
31988: MINUS
31989: ST_TO_ADDR
// if max > 5 then
31990: LD_VAR 0 8
31994: PUSH
31995: LD_INT 5
31997: GREATER
31998: IFFALSE 32008
// max := 5 ;
32000: LD_ADDR_VAR 0 8
32004: PUSH
32005: LD_INT 5
32007: ST_TO_ADDR
// take := CharacterSelection ( B-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 2 ] ^ [ sel_not_changeable ] ^ [ Borodin ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32008: LD_ADDR_VAR 0 5
32012: PUSH
32013: LD_STRING B-Base
32015: PPUSH
32016: LD_INT 1
32018: PPUSH
32019: LD_VAR 0 8
32023: PPUSH
32024: LD_VAR 0 4
32028: PUSH
32029: LD_INT -2
32031: PUSH
32032: LD_INT -3
32034: PUSH
32035: LD_INT -6
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: LIST
32042: ADD
32043: PUSH
32044: LD_EXP 76
32048: PUSH
32049: LD_INT 2
32051: ARRAY
32052: ADD
32053: PUSH
32054: LD_INT -4
32056: PUSH
32057: EMPTY
32058: LIST
32059: ADD
32060: PUSH
32061: LD_EXP 46
32065: PUSH
32066: EMPTY
32067: LIST
32068: ADD
32069: PPUSH
32070: LD_INT 1
32072: PUSH
32073: LD_INT 3
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 4
32081: PUSH
32082: LD_INT 9
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: PPUSH
32092: CALL_OW 42
32096: ST_TO_ADDR
// end ; ai_s [ 3 ] :
32097: GO 32674
32099: LD_EXP 23
32103: PUSH
32104: LD_INT 3
32106: ARRAY
32107: DOUBLE
32108: EQUAL
32109: IFTRUE 32113
32111: GO 32265
32113: POP
// begin if humans [ 3 ] < 3 then
32114: LD_EXP 76
32118: PUSH
32119: LD_INT 3
32121: ARRAY
32122: PUSH
32123: LD_INT 3
32125: LESS
32126: IFFALSE 32138
// max := 1 else
32128: LD_ADDR_VAR 0 8
32132: PUSH
32133: LD_INT 1
32135: ST_TO_ADDR
32136: GO 32156
// max := humans [ 3 ] - 2 ;
32138: LD_ADDR_VAR 0 8
32142: PUSH
32143: LD_EXP 76
32147: PUSH
32148: LD_INT 3
32150: ARRAY
32151: PUSH
32152: LD_INT 2
32154: MINUS
32155: ST_TO_ADDR
// if max > 3 then
32156: LD_VAR 0 8
32160: PUSH
32161: LD_INT 3
32163: GREATER
32164: IFFALSE 32174
// max := 3 ;
32166: LD_ADDR_VAR 0 8
32170: PUSH
32171: LD_INT 3
32173: ST_TO_ADDR
// take := CharacterSelection ( C-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 3 ] ^ [ sel_not_changeable ] ^ [ Tsaritsyn ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32174: LD_ADDR_VAR 0 5
32178: PUSH
32179: LD_STRING C-Base
32181: PPUSH
32182: LD_INT 1
32184: PPUSH
32185: LD_VAR 0 8
32189: PPUSH
32190: LD_VAR 0 4
32194: PUSH
32195: LD_INT -2
32197: PUSH
32198: LD_INT -3
32200: PUSH
32201: LD_INT -6
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: LIST
32208: ADD
32209: PUSH
32210: LD_EXP 76
32214: PUSH
32215: LD_INT 3
32217: ARRAY
32218: ADD
32219: PUSH
32220: LD_INT -4
32222: PUSH
32223: EMPTY
32224: LIST
32225: ADD
32226: PUSH
32227: LD_EXP 47
32231: PUSH
32232: EMPTY
32233: LIST
32234: ADD
32235: PPUSH
32236: LD_INT 1
32238: PUSH
32239: LD_INT 3
32241: PUSH
32242: LD_INT 2
32244: PUSH
32245: LD_INT 4
32247: PUSH
32248: LD_INT 9
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: PPUSH
32258: CALL_OW 42
32262: ST_TO_ADDR
// end ; ai_s [ 4 ] :
32263: GO 32674
32265: LD_EXP 23
32269: PUSH
32270: LD_INT 4
32272: ARRAY
32273: DOUBLE
32274: EQUAL
32275: IFTRUE 32279
32277: GO 32507
32279: POP
// begin if humans [ 4 ] < 3 then
32280: LD_EXP 76
32284: PUSH
32285: LD_INT 4
32287: ARRAY
32288: PUSH
32289: LD_INT 3
32291: LESS
32292: IFFALSE 32304
// max := 1 else
32294: LD_ADDR_VAR 0 8
32298: PUSH
32299: LD_INT 1
32301: ST_TO_ADDR
32302: GO 32322
// max := humans [ 4 ] - 2 ;
32304: LD_ADDR_VAR 0 8
32308: PUSH
32309: LD_EXP 76
32313: PUSH
32314: LD_INT 4
32316: ARRAY
32317: PUSH
32318: LD_INT 2
32320: MINUS
32321: ST_TO_ADDR
// if max > 2 then
32322: LD_VAR 0 8
32326: PUSH
32327: LD_INT 2
32329: GREATER
32330: IFFALSE 32340
// max := 2 ;
32332: LD_ADDR_VAR 0 8
32336: PUSH
32337: LD_INT 2
32339: ST_TO_ADDR
// t_sci := sci isect humans [ 4 ] ;
32340: LD_ADDR_VAR 0 9
32344: PUSH
32345: LD_EXP 88
32349: PUSH
32350: LD_EXP 76
32354: PUSH
32355: LD_INT 4
32357: ARRAY
32358: ISECT
32359: ST_TO_ADDR
// if t_sci > 3 then
32360: LD_VAR 0 9
32364: PUSH
32365: LD_INT 3
32367: GREATER
32368: IFFALSE 32404
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
32370: LD_ADDR_VAR 0 9
32374: PUSH
32375: LD_VAR 0 9
32379: PUSH
32380: LD_INT 1
32382: ARRAY
32383: PUSH
32384: LD_VAR 0 9
32388: PUSH
32389: LD_INT 2
32391: ARRAY
32392: ADD
32393: PUSH
32394: LD_VAR 0 9
32398: PUSH
32399: LD_INT 3
32401: ARRAY
32402: ADD
32403: ST_TO_ADDR
// take := CharacterSelection ( D-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ ( humans [ 4 ] diff t_sci ) ^ [ sel_not_changeable ] ^ t_sci ^ [ Davidov ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32404: LD_ADDR_VAR 0 5
32408: PUSH
32409: LD_STRING D-Base
32411: PPUSH
32412: LD_INT 1
32414: PPUSH
32415: LD_VAR 0 8
32419: PPUSH
32420: LD_VAR 0 4
32424: PUSH
32425: LD_INT -2
32427: PUSH
32428: LD_INT -3
32430: PUSH
32431: LD_INT -6
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: LIST
32438: ADD
32439: PUSH
32440: LD_EXP 76
32444: PUSH
32445: LD_INT 4
32447: ARRAY
32448: PUSH
32449: LD_VAR 0 9
32453: DIFF
32454: ADD
32455: PUSH
32456: LD_INT -4
32458: PUSH
32459: EMPTY
32460: LIST
32461: ADD
32462: PUSH
32463: LD_VAR 0 9
32467: ADD
32468: PUSH
32469: LD_EXP 48
32473: PUSH
32474: EMPTY
32475: LIST
32476: ADD
32477: PPUSH
32478: LD_INT 1
32480: PUSH
32481: LD_INT 3
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: LD_INT 4
32489: PUSH
32490: LD_INT 9
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: PPUSH
32500: CALL_OW 42
32504: ST_TO_ADDR
// end ; ai_s [ 5 ] :
32505: GO 32674
32507: LD_EXP 23
32511: PUSH
32512: LD_INT 5
32514: ARRAY
32515: DOUBLE
32516: EQUAL
32517: IFTRUE 32521
32519: GO 32673
32521: POP
// begin if humans [ 5 ] < 3 then
32522: LD_EXP 76
32526: PUSH
32527: LD_INT 5
32529: ARRAY
32530: PUSH
32531: LD_INT 3
32533: LESS
32534: IFFALSE 32546
// max := 1 else
32536: LD_ADDR_VAR 0 8
32540: PUSH
32541: LD_INT 1
32543: ST_TO_ADDR
32544: GO 32564
// max := humans [ 5 ] - 2 ;
32546: LD_ADDR_VAR 0 8
32550: PUSH
32551: LD_EXP 76
32555: PUSH
32556: LD_INT 5
32558: ARRAY
32559: PUSH
32560: LD_INT 2
32562: MINUS
32563: ST_TO_ADDR
// if max > 5 then
32564: LD_VAR 0 8
32568: PUSH
32569: LD_INT 5
32571: GREATER
32572: IFFALSE 32582
// max := 5 ;
32574: LD_ADDR_VAR 0 8
32578: PUSH
32579: LD_INT 5
32581: ST_TO_ADDR
// take := CharacterSelection ( E-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 5 ] ^ [ sel_not_changeable ] ^ [ Eisenstein ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32582: LD_ADDR_VAR 0 5
32586: PUSH
32587: LD_STRING E-Base
32589: PPUSH
32590: LD_INT 1
32592: PPUSH
32593: LD_VAR 0 8
32597: PPUSH
32598: LD_VAR 0 4
32602: PUSH
32603: LD_INT -2
32605: PUSH
32606: LD_INT -3
32608: PUSH
32609: LD_INT -6
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: LIST
32616: ADD
32617: PUSH
32618: LD_EXP 76
32622: PUSH
32623: LD_INT 5
32625: ARRAY
32626: ADD
32627: PUSH
32628: LD_INT -4
32630: PUSH
32631: EMPTY
32632: LIST
32633: ADD
32634: PUSH
32635: LD_EXP 49
32639: PUSH
32640: EMPTY
32641: LIST
32642: ADD
32643: PPUSH
32644: LD_INT 1
32646: PUSH
32647: LD_INT 3
32649: PUSH
32650: LD_INT 2
32652: PUSH
32653: LD_INT 4
32655: PUSH
32656: LD_INT 9
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: PPUSH
32666: CALL_OW 42
32670: ST_TO_ADDR
// end ; end ;
32671: GO 32674
32673: POP
// end ; ComExitVehicle ( take ) ;
32674: LD_VAR 0 5
32678: PPUSH
32679: CALL_OW 121
// AddComExitBuilding ( take ) ;
32683: LD_VAR 0 5
32687: PPUSH
32688: CALL_OW 182
// take := take union FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) ;
32692: LD_ADDR_VAR 0 5
32696: PUSH
32697: LD_VAR 0 5
32701: PUSH
32702: LD_INT 22
32704: PUSH
32705: LD_VAR 0 2
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 21
32716: PUSH
32717: LD_INT 2
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 33
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: LIST
32738: PPUSH
32739: CALL_OW 69
32743: UNION
32744: ST_TO_ADDR
// SetSide ( take , you ) ;
32745: LD_VAR 0 5
32749: PPUSH
32750: LD_EXP 7
32754: PPUSH
32755: CALL_OW 235
// end ;
32759: LD_VAR 0 3
32763: RET
// export function SetSideBase_custom ( base , side ) ; var b , depot , orig_side ; begin
32764: LD_INT 0
32766: PPUSH
32767: PPUSH
32768: PPUSH
32769: PPUSH
// depot = - 1 ;
32770: LD_ADDR_VAR 0 5
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
32779: LD_ADDR_VAR 0 4
32783: PUSH
32784: LD_INT 2
32786: PUSH
32787: LD_INT 30
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 30
32799: PUSH
32800: LD_INT 1
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: LIST
32811: PUSH
32812: EMPTY
32813: LIST
32814: PPUSH
32815: CALL_OW 69
32819: PUSH
32820: FOR_IN
32821: IFFALSE 32854
// if GetBase ( b ) = base then
32823: LD_VAR 0 4
32827: PPUSH
32828: CALL_OW 274
32832: PUSH
32833: LD_VAR 0 1
32837: EQUAL
32838: IFFALSE 32852
// begin depot = b ;
32840: LD_ADDR_VAR 0 5
32844: PUSH
32845: LD_VAR 0 4
32849: ST_TO_ADDR
// break ;
32850: GO 32854
// end ;
32852: GO 32820
32854: POP
32855: POP
// orig_side = GetSide ( depot ) ;
32856: LD_ADDR_VAR 0 6
32860: PUSH
32861: LD_VAR 0 5
32865: PPUSH
32866: CALL_OW 255
32870: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , orig_side ] , [ f_type , unit_building ] ] ) diff depot do
32871: LD_ADDR_VAR 0 4
32875: PUSH
32876: LD_INT 22
32878: PUSH
32879: LD_VAR 0 6
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 21
32890: PUSH
32891: LD_INT 3
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PPUSH
32902: CALL_OW 69
32906: PUSH
32907: LD_VAR 0 5
32911: DIFF
32912: PUSH
32913: FOR_IN
32914: IFFALSE 32949
// if GetBase ( b ) = base then
32916: LD_VAR 0 4
32920: PPUSH
32921: CALL_OW 274
32925: PUSH
32926: LD_VAR 0 1
32930: EQUAL
32931: IFFALSE 32947
// SetSide ( b , side ) ;
32933: LD_VAR 0 4
32937: PPUSH
32938: LD_VAR 0 2
32942: PPUSH
32943: CALL_OW 235
32947: GO 32913
32949: POP
32950: POP
// SetSide ( depot , side ) ;
32951: LD_VAR 0 5
32955: PPUSH
32956: LD_VAR 0 2
32960: PPUSH
32961: CALL_OW 235
// end ; end_of_file
32965: LD_VAR 0 3
32969: RET
// every 0 0$2 + 0 0$0.1 do
32970: GO 32972
32972: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
32973: LD_INT 22
32975: PUSH
32976: LD_INT 3
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 2
32985: PUSH
32986: LD_INT 25
32988: PUSH
32989: LD_INT 12
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 25
32998: PUSH
32999: LD_INT 16
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 25
33008: PUSH
33009: LD_INT 15
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 25
33018: PUSH
33019: LD_INT 17
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: LIST
33030: LIST
33031: LIST
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: PPUSH
33037: CALL_OW 69
33041: PUSH
33042: LD_INT 22
33044: PUSH
33045: LD_INT 3
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 21
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 3
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: LD_INT 25
33070: PUSH
33071: LD_INT 12
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 25
33080: PUSH
33081: LD_INT 16
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 25
33090: PUSH
33091: LD_INT 15
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 25
33100: PUSH
33101: LD_INT 17
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: LIST
33123: PPUSH
33124: CALL_OW 69
33128: GREATER
33129: IFFALSE 33140
// begin SetAchievement ( ACH_POTA ) ;
33131: LD_STRING ACH_POTA
33133: PPUSH
33134: CALL_OW 543
// exit ;
33138: GO 33141
// end ; enable ;
33140: ENABLE
// end ;
33141: END
// export function SA_OnMissionStart ; begin
33142: LD_INT 0
33144: PPUSH
// SetAchievement ( ACH_RPAT ) ;
33145: LD_STRING ACH_RPAT
33147: PPUSH
33148: CALL_OW 543
// end ;
33152: LD_VAR 0 1
33156: RET
// export function SA_OnTsaritsynQuizPerfectCleared ; begin
33157: LD_INT 0
33159: PPUSH
// SetAchievement ( ACH_CAD ) ;
33160: LD_STRING ACH_CAD
33162: PPUSH
33163: CALL_OW 543
// end ; end_of_file
33167: LD_VAR 0 1
33171: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
33172: LD_INT 0
33174: PPUSH
33175: PPUSH
// if not missionNumber then
33176: LD_VAR 0 2
33180: NOT
33181: IFFALSE 33185
// exit ;
33183: GO 33315
// achiv := false ;
33185: LD_ADDR_VAR 0 7
33189: PUSH
33190: LD_INT 0
33192: ST_TO_ADDR
// case campaignNumber of 1 :
33193: LD_VAR 0 1
33197: PUSH
33198: LD_INT 1
33200: DOUBLE
33201: EQUAL
33202: IFTRUE 33206
33204: GO 33217
33206: POP
// achiv := ACH_GOTA ; 2 :
33207: LD_ADDR_VAR 0 7
33211: PUSH
33212: LD_STRING ACH_GOTA
33214: ST_TO_ADDR
33215: GO 33267
33217: LD_INT 2
33219: DOUBLE
33220: EQUAL
33221: IFTRUE 33225
33223: GO 33228
33225: POP
// ; 3 :
33226: GO 33267
33228: LD_INT 3
33230: DOUBLE
33231: EQUAL
33232: IFTRUE 33236
33234: GO 33247
33236: POP
// achiv := ACH_MOTSU ; 4 :
33237: LD_ADDR_VAR 0 7
33241: PUSH
33242: LD_STRING ACH_MOTSU
33244: ST_TO_ADDR
33245: GO 33267
33247: LD_INT 4
33249: DOUBLE
33250: EQUAL
33251: IFTRUE 33255
33253: GO 33266
33255: POP
// achiv := ACH_LOP ; end ;
33256: LD_ADDR_VAR 0 7
33260: PUSH
33261: LD_STRING ACH_LOP
33263: ST_TO_ADDR
33264: GO 33267
33266: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
33267: LD_OWVAR 67
33271: PUSH
33272: LD_INT 3
33274: EQUAL
33275: PUSH
33276: LD_VAR 0 7
33280: AND
33281: PUSH
33282: LD_VAR 0 3
33286: AND
33287: PUSH
33288: LD_VAR 0 4
33292: AND
33293: PUSH
33294: LD_VAR 0 5
33298: AND
33299: IFFALSE 33315
// SetAchievementEX ( achiv , missionNumber ) ;
33301: LD_VAR 0 7
33305: PPUSH
33306: LD_VAR 0 2
33310: PPUSH
33311: CALL_OW 564
// end ;
33315: LD_VAR 0 6
33319: RET

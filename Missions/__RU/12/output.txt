// export t_kill , t_intimidate , t_persuade , t_pay , t_beat , t_killbeat ; export you , americans , arabians , nature ; export mcdef1_difficulty , mcdef2_difficulty , mcdef3_difficulty , mcdef4_difficulty , mcdef5_difficulty ; export gossudarov_mech_skill ; export cap_bases ; export your_bases ; export aiH , aiN , aiZ ; export ai_nation ; export ai_s ; export ai ; export plat_i ; export apemans ; export Diplomacy , Goss ; export BehemothSeen ; export vedci_zacali_zdrhat ; export run_sci ; export utek , utek_e ; export art_cargo1 ; export your_cars ; export your_builds ; export your_humans ; export function inicializace_main ; begin
   0: LD_INT 0
   2: PPUSH
// you := 3 ;
   3: LD_ADDR_EXP 7
   7: PUSH
   8: LD_INT 3
  10: ST_TO_ADDR
// americans := 1 ;
  11: LD_ADDR_EXP 8
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabians := 2 ;
  19: LD_ADDR_EXP 9
  23: PUSH
  24: LD_INT 2
  26: ST_TO_ADDR
// nature := 0 ;
  27: LD_ADDR_EXP 10
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// utek := [ [ 55 , 21 ] , [ 83 , 36 ] , [ 103 , 70 ] , [ 142 , 88 ] ] ;
  35: LD_ADDR_EXP 32
  39: PUSH
  40: LD_INT 55
  42: PUSH
  43: LD_INT 21
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: PUSH
  50: LD_INT 83
  52: PUSH
  53: LD_INT 36
  55: PUSH
  56: EMPTY
  57: LIST
  58: LIST
  59: PUSH
  60: LD_INT 103
  62: PUSH
  63: LD_INT 70
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: PUSH
  70: LD_INT 142
  72: PUSH
  73: LD_INT 88
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: PUSH
  80: EMPTY
  81: LIST
  82: LIST
  83: LIST
  84: LIST
  85: ST_TO_ADDR
// utek_e := [ 186 , 55 ] ;
  86: LD_ADDR_EXP 33
  90: PUSH
  91: LD_INT 186
  93: PUSH
  94: LD_INT 55
  96: PUSH
  97: EMPTY
  98: LIST
  99: LIST
 100: ST_TO_ADDR
// cap_bases := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// t_kill := 1 ;
 109: LD_ADDR_EXP 1
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// t_intimidate := 2 ;
 117: LD_ADDR_EXP 2
 121: PUSH
 122: LD_INT 2
 124: ST_TO_ADDR
// t_persuade := 3 ;
 125: LD_ADDR_EXP 3
 129: PUSH
 130: LD_INT 3
 132: ST_TO_ADDR
// t_pay := 4 ;
 133: LD_ADDR_EXP 4
 137: PUSH
 138: LD_INT 4
 140: ST_TO_ADDR
// t_beat := 5 ;
 141: LD_ADDR_EXP 5
 145: PUSH
 146: LD_INT 5
 148: ST_TO_ADDR
// t_killbeat := 10 ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 10
 156: ST_TO_ADDR
// Diplomacy := true ;
 157: LD_ADDR_EXP 27
 161: PUSH
 162: LD_INT 1
 164: ST_TO_ADDR
// Goss := true ;
 165: LD_ADDR_EXP 28
 169: PUSH
 170: LD_INT 1
 172: ST_TO_ADDR
// ai_s := [ 6 , 5 , 2 , 8 , 7 ] ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 6
 180: PUSH
 181: LD_INT 5
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: LD_INT 7
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// ai := [ 6 , 5 , 2 , 8 , 7 ] ;
 200: LD_ADDR_EXP 24
 204: PUSH
 205: LD_INT 6
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 2
 213: PUSH
 214: LD_INT 8
 216: PUSH
 217: LD_INT 7
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: ST_TO_ADDR
// plat_i := 1 ;
 227: LD_ADDR_EXP 25
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// aiH := [ ] ;
 235: LD_ADDR_EXP 19
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// aiN := [ ai_s [ 2 ] , ai_s [ 3 ] , ai_s [ 4 ] , ai_s [ 5 ] ] ;
 242: LD_ADDR_EXP 20
 246: PUSH
 247: LD_EXP 23
 251: PUSH
 252: LD_INT 2
 254: ARRAY
 255: PUSH
 256: LD_EXP 23
 260: PUSH
 261: LD_INT 3
 263: ARRAY
 264: PUSH
 265: LD_EXP 23
 269: PUSH
 270: LD_INT 4
 272: ARRAY
 273: PUSH
 274: LD_EXP 23
 278: PUSH
 279: LD_INT 5
 281: ARRAY
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: ST_TO_ADDR
// aiZ := [ ai_s [ 1 ] ] ;
 289: LD_ADDR_EXP 21
 293: PUSH
 294: LD_EXP 23
 298: PUSH
 299: LD_INT 1
 301: ARRAY
 302: PUSH
 303: EMPTY
 304: LIST
 305: ST_TO_ADDR
// your_bases := [ ] ;
 306: LD_ADDR_EXP 18
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// cap_bases := 0 ;
 313: LD_ADDR_EXP 17
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// art_cargo1 := art_cargo ;
 321: LD_ADDR_EXP 34
 325: PUSH
 326: LD_INT 121
 328: ST_TO_ADDR
// ai_nation := nation_russian ;
 329: LD_ADDR_EXP 22
 333: PUSH
 334: LD_INT 3
 336: ST_TO_ADDR
// debug_strings := [ [ ] , [ ] , [ ] ] ;
 337: LD_ADDR_OWVAR 48
 341: PUSH
 342: EMPTY
 343: PUSH
 344: EMPTY
 345: PUSH
 346: EMPTY
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: ST_TO_ADDR
// end ;
 353: LD_VAR 0 1
 357: RET
// export vyhrano ; export function VyhraPlaton ; begin
 358: LD_INT 0
 360: PPUSH
// if not vyhrano then
 361: LD_EXP 38
 365: NOT
 366: IFFALSE 497
// begin vyhrano := true ;
 368: LD_ADDR_EXP 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// cap_bases := 5 ;
 376: LD_ADDR_EXP 17
 380: PUSH
 381: LD_INT 5
 383: ST_TO_ADDR
// Query ( QEndInfo ) ;
 384: LD_STRING QEndInfo
 386: PPUSH
 387: CALL_OW 97
// ExclusiveOn ;
 391: CALL_OW 4
// wait ( 1 ) ;
 395: LD_INT 1
 397: PPUSH
 398: CALL_OW 67
// DEnd ;
 402: CALL 8156 0 0
// ExclusiveOff ;
 406: CALL_OW 5
// SetMedals ;
 410: CALL 502 0 0
// GiveMedals ( Platon ) ;
 414: LD_STRING Platon
 416: PPUSH
 417: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ) ;
 421: LD_INT 22
 423: PUSH
 424: LD_EXP 7
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 21
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 3
 445: PUSH
 446: LD_INT 23
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: PPUSH
 470: CALL_OW 43
// Save ;
 474: CALL 9151 0 0
// YouWin ;
 478: CALL_OW 103
// ExclusiveOn ;
 482: CALL_OW 4
// wait ( 1 ) ;
 486: LD_INT 1
 488: PPUSH
 489: CALL_OW 67
// ExclusiveOff ;
 493: CALL_OW 5
// end ; end ;
 497: LD_VAR 0 1
 501: RET
// export function SetMedals ; begin
 502: LD_INT 0
 504: PPUSH
// AddMedal ( All , cap_bases = 5 ) ;
 505: LD_STRING All
 507: PPUSH
 508: LD_EXP 17
 512: PUSH
 513: LD_INT 5
 515: EQUAL
 516: PPUSH
 517: CALL_OW 101
// AddMedal ( Diplomacy , Diplomacy ) ;
 521: LD_STRING Diplomacy
 523: PPUSH
 524: LD_EXP 27
 528: PPUSH
 529: CALL_OW 101
// AddMedal ( Goss , Goss ) ;
 533: LD_STRING Goss
 535: PPUSH
 536: LD_EXP 28
 540: PPUSH
 541: CALL_OW 101
// SA_EndMission ( 3 , 12 , cap_bases = 5 , Diplomacy > 0 , Goss > 0 ) ;
 545: LD_INT 3
 547: PPUSH
 548: LD_INT 12
 550: PPUSH
 551: LD_EXP 17
 555: PUSH
 556: LD_INT 5
 558: EQUAL
 559: PPUSH
 560: LD_EXP 27
 564: PUSH
 565: LD_INT 0
 567: GREATER
 568: PPUSH
 569: LD_EXP 28
 573: PUSH
 574: LD_INT 0
 576: GREATER
 577: PPUSH
 578: CALL 33189 0 5
// end ;
 582: LD_VAR 0 1
 586: RET
// export function LostBurlak ; begin
 587: LD_INT 0
 589: PPUSH
// YouLost ( Burlak ) ;
 590: LD_STRING Burlak
 592: PPUSH
 593: CALL_OW 104
// end ;
 597: LD_VAR 0 1
 601: RET
// export function LostArte ; begin
 602: LD_INT 0
 604: PPUSH
// YouLost ( Arte ) ;
 605: LD_STRING Arte
 607: PPUSH
 608: CALL_OW 104
// end ;
 612: LD_VAR 0 1
 616: RET
// export function set_difficulty ; begin
 617: LD_INT 0
 619: PPUSH
// mcdef1_difficulty := [ 200 , 230 , 260 ] [ difficulty ] ;
 620: LD_ADDR_EXP 11
 624: PUSH
 625: LD_INT 200
 627: PUSH
 628: LD_INT 230
 630: PUSH
 631: LD_INT 260
 633: PUSH
 634: EMPTY
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_OWVAR 67
 643: ARRAY
 644: ST_TO_ADDR
// mcdef2_difficulty := [ 150 , 180 , 200 ] [ difficulty ] ;
 645: LD_ADDR_EXP 12
 649: PUSH
 650: LD_INT 150
 652: PUSH
 653: LD_INT 180
 655: PUSH
 656: LD_INT 200
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: PUSH
 664: LD_OWVAR 67
 668: ARRAY
 669: ST_TO_ADDR
// mcdef3_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 670: LD_ADDR_EXP 13
 674: PUSH
 675: LD_INT 170
 677: PUSH
 678: LD_INT 200
 680: PUSH
 681: LD_INT 230
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: PUSH
 689: LD_OWVAR 67
 693: ARRAY
 694: ST_TO_ADDR
// mcdef4_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 695: LD_ADDR_EXP 14
 699: PUSH
 700: LD_INT 170
 702: PUSH
 703: LD_INT 200
 705: PUSH
 706: LD_INT 230
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: PUSH
 714: LD_OWVAR 67
 718: ARRAY
 719: ST_TO_ADDR
// mcdef5_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 720: LD_ADDR_EXP 15
 724: PUSH
 725: LD_INT 170
 727: PUSH
 728: LD_INT 200
 730: PUSH
 731: LD_INT 230
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_OWVAR 67
 743: ARRAY
 744: ST_TO_ADDR
// gossudarov_mech_skill := [ 0 , 2 , 4 ] [ difficulty ] ;
 745: LD_ADDR_EXP 16
 749: PUSH
 750: LD_INT 0
 752: PUSH
 753: LD_INT 2
 755: PUSH
 756: LD_INT 4
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: LD_OWVAR 67
 768: ARRAY
 769: ST_TO_ADDR
// end ;
 770: LD_VAR 0 1
 774: RET
// export function get_your_units ; var a ; begin
 775: LD_INT 0
 777: PPUSH
 778: PPUSH
// a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
 779: LD_ADDR_VAR 0 2
 783: PUSH
 784: LD_INT 22
 786: PUSH
 787: LD_EXP 7
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: EMPTY
 797: LIST
 798: PPUSH
 799: CALL_OW 69
 803: ST_TO_ADDR
// your_humans := UnitFilter ( a , [ [ f_type , unit_human ] ] ) ;
 804: LD_ADDR_EXP 37
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: LD_INT 21
 816: PUSH
 817: LD_INT 1
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: PPUSH
 827: CALL_OW 72
 831: ST_TO_ADDR
// your_cars := UnitFilter ( a , [ [ f_type , unit_vehicle ] ] ) ;
 832: LD_ADDR_EXP 35
 836: PUSH
 837: LD_VAR 0 2
 841: PPUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: PPUSH
 855: CALL_OW 72
 859: ST_TO_ADDR
// your_builds := UnitFilter ( a , [ [ f_type , unit_building ] ] ) ;
 860: LD_ADDR_EXP 36
 864: PUSH
 865: LD_VAR 0 2
 869: PPUSH
 870: LD_INT 21
 872: PUSH
 873: LD_INT 3
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: PUSH
 880: EMPTY
 881: LIST
 882: PPUSH
 883: CALL_OW 72
 887: ST_TO_ADDR
// end ;
 888: LD_VAR 0 1
 892: RET
// every 0 0$1 do var i ;
 893: GO 895
 895: DISABLE
 896: LD_INT 0
 898: PPUSH
// begin for i in ai do
 899: LD_ADDR_VAR 0 1
 903: PUSH
 904: LD_EXP 24
 908: PUSH
 909: FOR_IN
 910: IFFALSE 1107
// case GetAttitude ( i , you ) of att_friend :
 912: LD_VAR 0 1
 916: PPUSH
 917: LD_EXP 7
 921: PPUSH
 922: CALL_OW 81
 926: PUSH
 927: LD_INT 1
 929: DOUBLE
 930: EQUAL
 931: IFTRUE 935
 933: GO 986
 935: POP
// begin aiH := aiH union i ;
 936: LD_ADDR_EXP 19
 940: PUSH
 941: LD_EXP 19
 945: PUSH
 946: LD_VAR 0 1
 950: UNION
 951: ST_TO_ADDR
// aiZ := aiZ diff i ;
 952: LD_ADDR_EXP 21
 956: PUSH
 957: LD_EXP 21
 961: PUSH
 962: LD_VAR 0 1
 966: DIFF
 967: ST_TO_ADDR
// aiN := aiN diff i ;
 968: LD_ADDR_EXP 20
 972: PUSH
 973: LD_EXP 20
 977: PUSH
 978: LD_VAR 0 1
 982: DIFF
 983: ST_TO_ADDR
// end ; att_neutral :
 984: GO 1105
 986: LD_INT 0
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1045
 994: POP
// begin aiN := aiN union i ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_EXP 20
1004: PUSH
1005: LD_VAR 0 1
1009: UNION
1010: ST_TO_ADDR
// aiZ := aiZ diff i ;
1011: LD_ADDR_EXP 21
1015: PUSH
1016: LD_EXP 21
1020: PUSH
1021: LD_VAR 0 1
1025: DIFF
1026: ST_TO_ADDR
// aiH := aiH diff i ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_EXP 19
1036: PUSH
1037: LD_VAR 0 1
1041: DIFF
1042: ST_TO_ADDR
// end ; att_enemy :
1043: GO 1105
1045: LD_INT 2
1047: DOUBLE
1048: EQUAL
1049: IFTRUE 1053
1051: GO 1104
1053: POP
// begin aiZ := aiZ union i ;
1054: LD_ADDR_EXP 21
1058: PUSH
1059: LD_EXP 21
1063: PUSH
1064: LD_VAR 0 1
1068: UNION
1069: ST_TO_ADDR
// aiH := aiH diff i ;
1070: LD_ADDR_EXP 19
1074: PUSH
1075: LD_EXP 19
1079: PUSH
1080: LD_VAR 0 1
1084: DIFF
1085: ST_TO_ADDR
// aiN := aiN diff i ;
1086: LD_ADDR_EXP 20
1090: PUSH
1091: LD_EXP 20
1095: PUSH
1096: LD_VAR 0 1
1100: DIFF
1101: ST_TO_ADDR
// end ; end ;
1102: GO 1105
1104: POP
1105: GO 909
1107: POP
1108: POP
// enable ;
1109: ENABLE
// end ;
1110: PPOPN 1
1112: END
// every 0 0$1 do
1113: GO 1115
1115: DISABLE
// begin debug_strings := [ [ ( tick div 0 0$1 ) div 60 , ( tick div 0 0$1 ) mod 60 ] , debug_strings [ 2 ] , debug_strings [ 3 ] ] ;
1116: LD_ADDR_OWVAR 48
1120: PUSH
1121: LD_OWVAR 1
1125: PUSH
1126: LD_INT 35
1128: DIV
1129: PUSH
1130: LD_INT 60
1132: DIV
1133: PUSH
1134: LD_OWVAR 1
1138: PUSH
1139: LD_INT 35
1141: DIV
1142: PUSH
1143: LD_INT 60
1145: MOD
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_OWVAR 48
1155: PUSH
1156: LD_INT 2
1158: ARRAY
1159: PUSH
1160: LD_OWVAR 48
1164: PUSH
1165: LD_INT 3
1167: ARRAY
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: ST_TO_ADDR
// enable ;
1174: ENABLE
// end ;
1175: END
// starting begin SA_OnMissionStart ;
1176: CALL 33137 0 0
// inicializace_main ;
1180: CALL 0 0 0
// inicializace_ai ;
1184: CALL 22656 0 0
// inicializace_functions ;
1188: CALL 9805 0 0
// inicializace_ai_b_repair ;
1192: CALL 22230 0 0
// inicializace_ai_b_build ;
1196: CALL 16160 0 0
// inicializace_ai_defend ;
1200: CALL 11621 0 0
// inicializace_ai_c_make ;
1204: CALL 14037 0 0
// inicializace_ai_c_repair ;
1208: CALL 12569 0 0
// disable ( 10 ) ;
1212: LD_INT 10
1214: DISABLE_MARKED
// disable ( 11 ) ;
1215: LD_INT 11
1217: DISABLE_MARKED
// disable ( 12 ) ;
1218: LD_INT 12
1220: DISABLE_MARKED
// disable ( 115 ) ;
1221: LD_INT 115
1223: DISABLE_MARKED
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_type , unit_human ] , [ f_class , class_apeman ] ] ) ;
1224: LD_ADDR_EXP 26
1228: PUSH
1229: LD_INT 23
1231: PUSH
1232: LD_INT 0
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: PUSH
1239: LD_INT 21
1241: PUSH
1242: LD_INT 1
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: PUSH
1249: LD_INT 25
1251: PUSH
1252: LD_INT 12
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: LIST
1263: PPUSH
1264: CALL_OW 69
1268: ST_TO_ADDR
// set_difficulty ;
1269: CALL 617 0 0
// SetCargo ( art_cargo1 , mat_artifact , 4 * 10 ) ;
1273: LD_EXP 34
1277: PPUSH
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PUSH
1284: LD_INT 10
1286: MUL
1287: PPUSH
1288: CALL_OW 290
// load ;
1292: CALL 8304 0 0
// inicializace_dialogues ;
1296: CALL 1321 0 0
// place_ru ;
1300: CALL 8845 0 0
// build_map ;
1304: CALL 20505 0 0
// get_groups ;
1308: CALL 22798 0 0
// get_your_units ;
1312: CALL 775 0 0
// DStart ;
1316: CALL 1496 0 0
// end ; end_of_file
1320: END
// var Gla , Bur , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ; var talking ; export function inicializace_dialogues ; begin
1321: LD_INT 0
1323: PPUSH
// Bur := Burlak ;
1324: LD_ADDR_LOC 2
1328: PUSH
1329: LD_EXP 41
1333: ST_TO_ADDR
// Gla := Gladkov ;
1334: LD_ADDR_LOC 1
1338: PUSH
1339: LD_EXP 44
1343: ST_TO_ADDR
// Glb := Gleb ;
1344: LD_ADDR_LOC 10
1348: PUSH
1349: LD_EXP 50
1353: ST_TO_ADDR
// Pla := Platonov ;
1354: LD_ADDR_LOC 3
1358: PUSH
1359: LD_EXP 42
1363: ST_TO_ADDR
// Gos := Gossudarov ;
1364: LD_ADDR_LOC 4
1368: PUSH
1369: LD_EXP 43
1373: ST_TO_ADDR
// Fad := Fadeev ;
1374: LD_ADDR_LOC 5
1378: PUSH
1379: LD_EXP 45
1383: ST_TO_ADDR
// Bor := Borodin ;
1384: LD_ADDR_LOC 6
1388: PUSH
1389: LD_EXP 46
1393: ST_TO_ADDR
// Tsr := Tsaritsyn ;
1394: LD_ADDR_LOC 7
1398: PUSH
1399: LD_EXP 47
1403: ST_TO_ADDR
// Dav := Davidov ;
1404: LD_ADDR_LOC 8
1408: PUSH
1409: LD_EXP 48
1413: ST_TO_ADDR
// Eis := Eisenstein ;
1414: LD_ADDR_LOC 9
1418: PUSH
1419: LD_EXP 49
1423: ST_TO_ADDR
// talking := [ Bur , Gla , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ] ;
1424: LD_ADDR_LOC 11
1428: PUSH
1429: LD_LOC 2
1433: PUSH
1434: LD_LOC 1
1438: PUSH
1439: LD_LOC 3
1443: PUSH
1444: LD_LOC 4
1448: PUSH
1449: LD_LOC 5
1453: PUSH
1454: LD_LOC 6
1458: PUSH
1459: LD_LOC 7
1463: PUSH
1464: LD_LOC 8
1468: PUSH
1469: LD_LOC 9
1473: PUSH
1474: LD_LOC 10
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// end ;
1491: LD_VAR 0 1
1495: RET
// export function DStart ; begin
1496: LD_INT 0
1498: PPUSH
// hide_interface_automaticaly := true ;
1499: LD_ADDR_OWVAR 53
1503: PUSH
1504: LD_INT 1
1506: ST_TO_ADDR
// InGameOn ;
1507: CALL_OW 8
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
1511: LD_LOC 2
1515: PPUSH
1516: CALL_OW 310
1520: PPUSH
1521: CALL_OW 87
// CenterNowOnUnits ( Bur ) ;
1525: LD_LOC 2
1529: PPUSH
1530: CALL_OW 87
// while IsInUnit ( bur ) do
1534: LD_LOC 2
1538: PPUSH
1539: CALL_OW 310
1543: IFFALSE 1563
// begin ComExitVehicle ( Bur ) ;
1545: LD_LOC 2
1549: PPUSH
1550: CALL_OW 121
// wait ( 0 0$0.3 ) ;
1554: LD_INT 10
1556: PPUSH
1557: CALL_OW 67
// end ;
1561: GO 1534
// Say ( Bur , DStart-Bur-1 ) ;
1563: LD_LOC 2
1567: PPUSH
1568: LD_STRING DStart-Bur-1
1570: PPUSH
1571: CALL_OW 88
// Say ( Gla , DStart-Gla-1 ) ;
1575: LD_LOC 1
1579: PPUSH
1580: LD_STRING DStart-Gla-1
1582: PPUSH
1583: CALL_OW 88
// Say ( Bur , DStart-Bur-2 ) ;
1587: LD_LOC 2
1591: PPUSH
1592: LD_STRING DStart-Bur-2
1594: PPUSH
1595: CALL_OW 88
// Say ( Gla , DStart-Gla-2 ) ;
1599: LD_LOC 1
1603: PPUSH
1604: LD_STRING DStart-Gla-2
1606: PPUSH
1607: CALL_OW 88
// Say ( Bur , DStart-Bur-3 ) ;
1611: LD_LOC 2
1615: PPUSH
1616: LD_STRING DStart-Bur-3
1618: PPUSH
1619: CALL_OW 88
// Say ( Gla , DStart-Gla-3 ) ;
1623: LD_LOC 1
1627: PPUSH
1628: LD_STRING DStart-Gla-3
1630: PPUSH
1631: CALL_OW 88
// Say ( Bur , DStart-Bur-4 ) ;
1635: LD_LOC 2
1639: PPUSH
1640: LD_STRING DStart-Bur-4
1642: PPUSH
1643: CALL_OW 88
// SetBName ( da , bluekher ) ;
1647: LD_INT 1
1649: PPUSH
1650: LD_STRING bluekher
1652: PPUSH
1653: CALL_OW 500
// SetBName ( dc , yegorov ) ;
1657: LD_INT 80
1659: PPUSH
1660: LD_STRING yegorov
1662: PPUSH
1663: CALL_OW 500
// SetBName ( dd , ryutin ) ;
1667: LD_INT 28
1669: PPUSH
1670: LD_STRING ryutin
1672: PPUSH
1673: CALL_OW 500
// SetBName ( db , budonny ) ;
1677: LD_INT 51
1679: PPUSH
1680: LD_STRING budonny
1682: PPUSH
1683: CALL_OW 500
// SetBName ( de , yakir ) ;
1687: LD_INT 37
1689: PPUSH
1690: LD_STRING yakir
1692: PPUSH
1693: CALL_OW 500
// RevealFogArea ( you , near_base ) ;
1697: LD_EXP 7
1701: PPUSH
1702: LD_INT 7
1704: PPUSH
1705: CALL_OW 332
// CenterOnUnits ( dc ) ;
1709: LD_INT 80
1711: PPUSH
1712: CALL_OW 85
// DWait ( 0 0$2 ) ;
1716: LD_INT 70
1718: PPUSH
1719: CALL_OW 68
// Say ( Gla , DStart-Gla-4 ) ;
1723: LD_LOC 1
1727: PPUSH
1728: LD_STRING DStart-Gla-4
1730: PPUSH
1731: CALL_OW 88
// CenterOnUnits ( dd ) ;
1735: LD_INT 28
1737: PPUSH
1738: CALL_OW 85
// DWait ( 0 0$2 ) ;
1742: LD_INT 70
1744: PPUSH
1745: CALL_OW 68
// Say ( Gla , DStart-Gla-4a ) ;
1749: LD_LOC 1
1753: PPUSH
1754: LD_STRING DStart-Gla-4a
1756: PPUSH
1757: CALL_OW 88
// CenterOnUnits ( de ) ;
1761: LD_INT 37
1763: PPUSH
1764: CALL_OW 85
// DWait ( 0 0$2 ) ;
1768: LD_INT 70
1770: PPUSH
1771: CALL_OW 68
// Say ( Gla , DStart-Gla-4b ) ;
1775: LD_LOC 1
1779: PPUSH
1780: LD_STRING DStart-Gla-4b
1782: PPUSH
1783: CALL_OW 88
// CenterOnUnits ( db ) ;
1787: LD_INT 51
1789: PPUSH
1790: CALL_OW 85
// DWait ( 0 0$2 ) ;
1794: LD_INT 70
1796: PPUSH
1797: CALL_OW 68
// Say ( Gla , DStart-Gla-4c ) ;
1801: LD_LOC 1
1805: PPUSH
1806: LD_STRING DStart-Gla-4c
1808: PPUSH
1809: CALL_OW 88
// CenterOnUnits ( da ) ;
1813: LD_INT 1
1815: PPUSH
1816: CALL_OW 85
// DWait ( 0 0$2 ) ;
1820: LD_INT 70
1822: PPUSH
1823: CALL_OW 68
// Say ( Gla , DStart-Gla-4d ) ;
1827: LD_LOC 1
1831: PPUSH
1832: LD_STRING DStart-Gla-4d
1834: PPUSH
1835: CALL_OW 88
// Say ( Gla , DStart-Gla-4e ) ;
1839: LD_LOC 1
1843: PPUSH
1844: LD_STRING DStart-Gla-4e
1846: PPUSH
1847: CALL_OW 88
// SaveForQuickRestart ;
1851: CALL_OW 22
// CenterNowOnUnits ( Bur ) ;
1855: LD_LOC 2
1859: PPUSH
1860: CALL_OW 87
// ChangeMissionObjectives ( MStart ) ;
1864: LD_STRING MStart
1866: PPUSH
1867: CALL_OW 337
// InGameOff ;
1871: CALL_OW 9
// end ;
1875: LD_VAR 0 1
1879: RET
// every 29 29$0 marked 111 do
1880: GO 1882
1882: DISABLE
// begin disable ( 112 ) ;
1883: LD_INT 112
1885: DISABLE_MARKED
// zdrhaji ;
1886: CALL 1915 0 0
// end ;
1890: END
// every 0 0$30 trigger kecali_o_artefaktu marked 112 do
1891: LD_EXP 40
1895: IFFALSE 1914
1897: GO 1899
1899: DISABLE
// begin disable ( 111 ) ;
1900: LD_INT 111
1902: DISABLE_MARKED
// wait ( 2 2$15 ) ;
1903: LD_INT 4725
1905: PPUSH
1906: CALL_OW 67
// zdrhaji ;
1910: CALL 1915 0 0
// end ;
1914: END
// function zdrhaji ; var ai1sci , i , mytick ; begin
1915: LD_INT 0
1917: PPUSH
1918: PPUSH
1919: PPUSH
1920: PPUSH
// vedci_zacali_zdrhat := true ;
1921: LD_ADDR_EXP 30
1925: PUSH
1926: LD_INT 1
1928: ST_TO_ADDR
// TeleportExit ( telp1 , 136 , 88 ) ;
1929: LD_INT 15
1931: PPUSH
1932: LD_INT 136
1934: PPUSH
1935: LD_INT 88
1937: PPUSH
1938: CALL_OW 243
// ai1sci := UnitFilter ( humans [ 1 ] , [ mf_sci ] ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_EXP 76
1951: PUSH
1952: LD_INT 1
1954: ARRAY
1955: PPUSH
1956: LD_EXP 54
1960: PUSH
1961: EMPTY
1962: LIST
1963: PPUSH
1964: CALL_OW 72
1968: ST_TO_ADDR
// if ai1sci then
1969: LD_VAR 0 2
1973: IFFALSE 1985
// run_sci := ai1sci ;
1975: LD_ADDR_EXP 31
1979: PUSH
1980: LD_VAR 0 2
1984: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff run_sci ) ;
1985: LD_ADDR_EXP 76
1989: PUSH
1990: LD_EXP 76
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: LD_EXP 76
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: PUSH
2007: LD_EXP 31
2011: DIFF
2012: PPUSH
2013: CALL_OW 1
2017: ST_TO_ADDR
// sci := sci diff run_sci ;
2018: LD_ADDR_EXP 88
2022: PUSH
2023: LD_EXP 88
2027: PUSH
2028: LD_EXP 31
2032: DIFF
2033: ST_TO_ADDR
// for i in utek do
2034: LD_ADDR_VAR 0 3
2038: PUSH
2039: LD_EXP 32
2043: PUSH
2044: FOR_IN
2045: IFFALSE 2076
// AddComMoveXY ( run_sci , i [ 1 ] , i [ 2 ] ) ;
2047: LD_EXP 31
2051: PPUSH
2052: LD_VAR 0 3
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: LD_VAR 0 3
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: CALL_OW 171
2074: GO 2044
2076: POP
2077: POP
// wait ( 0 0$10 ) ;
2078: LD_INT 350
2080: PPUSH
2081: CALL_OW 67
// DGossudarov ;
2085: CALL 2736 0 0
// mytick := tick + 1 1$30 ;
2089: LD_ADDR_VAR 0 4
2093: PUSH
2094: LD_OWVAR 1
2098: PUSH
2099: LD_INT 3150
2101: PLUS
2102: ST_TO_ADDR
// while mytick > tick and not UnitFilter ( run_sci , [ f_or , [ f_not , [ f_alive ] ] , [ f_distxy , 142 , 88 , 10 ] ] ) do
2103: LD_VAR 0 4
2107: PUSH
2108: LD_OWVAR 1
2112: GREATER
2113: PUSH
2114: LD_EXP 31
2118: PPUSH
2119: LD_INT 2
2121: PUSH
2122: LD_INT 3
2124: PUSH
2125: LD_INT 51
2127: PUSH
2128: EMPTY
2129: LIST
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 92
2137: PUSH
2138: LD_INT 142
2140: PUSH
2141: LD_INT 88
2143: PUSH
2144: LD_INT 10
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 72
2162: NOT
2163: AND
2164: IFFALSE 2175
// wait ( 0 0$1 ) ;
2166: LD_INT 35
2168: PPUSH
2169: CALL_OW 67
2173: GO 2103
// ComExitVehicle ( Gossudarov ) ;
2175: LD_EXP 43
2179: PPUSH
2180: CALL_OW 121
// while not UnitsInside ( art_cargo ) do
2184: LD_INT 121
2186: PPUSH
2187: CALL_OW 313
2191: NOT
2192: IFFALSE 2215
// begin ComEnterUnit ( Gossudarov , art_cargo ) ;
2194: LD_EXP 43
2198: PPUSH
2199: LD_INT 121
2201: PPUSH
2202: CALL_OW 120
// wait ( 0 0$1 ) ;
2206: LD_INT 35
2208: PPUSH
2209: CALL_OW 67
// end ;
2213: GO 2184
// if UnitFilter ( run_sci , [ [ f_distxy , 142 , 88 , 12 ] ] ) then
2215: LD_EXP 31
2219: PPUSH
2220: LD_INT 92
2222: PUSH
2223: LD_INT 142
2225: PUSH
2226: LD_INT 88
2228: PUSH
2229: LD_INT 12
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: PPUSH
2241: CALL_OW 72
2245: IFFALSE 2297
// while not UnitFilter ( art_cargo , [ [ f_distxy , 136 , 88 , 15 ] ] ) do
2247: LD_INT 121
2249: PPUSH
2250: LD_INT 92
2252: PUSH
2253: LD_INT 136
2255: PUSH
2256: LD_INT 88
2258: PUSH
2259: LD_INT 15
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: PPUSH
2271: CALL_OW 72
2275: NOT
2276: IFFALSE 2297
// begin ComMoveUnit ( art_cargo , telp1 ) ;
2278: LD_INT 121
2280: PPUSH
2281: LD_INT 15
2283: PPUSH
2284: CALL_OW 112
// wait ( 0 0$1 ) ;
2288: LD_INT 35
2290: PPUSH
2291: CALL_OW 67
// end ;
2295: GO 2247
// while UnitFilter ( run_sci ^ art_cargo , [ [ f_placed ] ] ) do
2297: LD_EXP 31
2301: PUSH
2302: LD_INT 121
2304: ADD
2305: PPUSH
2306: LD_INT 52
2308: PUSH
2309: EMPTY
2310: LIST
2311: PUSH
2312: EMPTY
2313: LIST
2314: PPUSH
2315: CALL_OW 72
2319: IFFALSE 2453
// begin ComMoveXY ( ( run_sci ) ^ art_cargo , utek_e [ 1 ] , utek_e [ 2 ] ) ;
2321: LD_EXP 31
2325: PUSH
2326: LD_INT 121
2328: ADD
2329: PPUSH
2330: LD_EXP 33
2334: PUSH
2335: LD_INT 1
2337: ARRAY
2338: PPUSH
2339: LD_EXP 33
2343: PUSH
2344: LD_INT 2
2346: ARRAY
2347: PPUSH
2348: CALL_OW 111
// for i in UnitFilter ( ( run_sci ) ^ art_cargo , [ [ f_distxy , utek_e [ 1 ] , utek_e [ 2 ] , 5 ] ] ) do
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_EXP 31
2361: PUSH
2362: LD_INT 121
2364: ADD
2365: PPUSH
2366: LD_INT 92
2368: PUSH
2369: LD_EXP 33
2373: PUSH
2374: LD_INT 1
2376: ARRAY
2377: PUSH
2378: LD_EXP 33
2382: PUSH
2383: LD_INT 2
2385: ARRAY
2386: PUSH
2387: LD_INT 5
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: PUSH
2396: EMPTY
2397: LIST
2398: PPUSH
2399: CALL_OW 72
2403: PUSH
2404: FOR_IN
2405: IFFALSE 2442
// if i = art_cargo then
2407: LD_VAR 0 3
2411: PUSH
2412: LD_INT 121
2414: EQUAL
2415: IFFALSE 2423
// LostArte else
2417: CALL 602 0 0
2421: GO 2440
// begin RemoveUnit ( i ) ;
2423: LD_VAR 0 3
2427: PPUSH
2428: CALL_OW 64
// Goss := false ;
2432: LD_ADDR_EXP 28
2436: PUSH
2437: LD_INT 0
2439: ST_TO_ADDR
// end ;
2440: GO 2404
2442: POP
2443: POP
// wait ( 0 0$1 ) ;
2444: LD_INT 35
2446: PPUSH
2447: CALL_OW 67
// end ;
2451: GO 2297
// end ;
2453: LD_VAR 0 1
2457: RET
// every 0 0$1 trigger vedci_zacali_zdrhat and UnitFilter ( run_sci ^ Gossudarov , [ [ f_alive ] , [ f_placed ] ] ) = 0 do
2458: LD_EXP 30
2462: PUSH
2463: LD_EXP 31
2467: PUSH
2468: LD_EXP 43
2472: ADD
2473: PPUSH
2474: LD_INT 51
2476: PUSH
2477: EMPTY
2478: LIST
2479: PUSH
2480: LD_INT 52
2482: PUSH
2483: EMPTY
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PPUSH
2490: CALL_OW 72
2494: PUSH
2495: LD_INT 0
2497: EQUAL
2498: AND
2499: IFFALSE 2511
2501: GO 2503
2503: DISABLE
// begin ChangeMissionObjectives ( MGossSciOut ) ;
2504: LD_STRING MGossSciOut
2506: PPUSH
2507: CALL_OW 337
// end ;
2511: END
// every 0 0$1 do var h , hinfo , i ;
2512: GO 2514
2514: DISABLE
2515: LD_INT 0
2517: PPUSH
2518: PPUSH
2519: PPUSH
// begin h := FindArtifact ( 4 ) ;
2520: LD_ADDR_VAR 0 1
2524: PUSH
2525: LD_INT 4
2527: PPUSH
2528: CALL_OW 469
2532: ST_TO_ADDR
// if h then
2533: LD_VAR 0 1
2537: IFFALSE 2732
// begin hinfo := HexInfo ( h [ 1 ] , h [ 2 ] ) ;
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_VAR 0 1
2548: PUSH
2549: LD_INT 1
2551: ARRAY
2552: PPUSH
2553: LD_VAR 0 1
2557: PUSH
2558: LD_INT 2
2560: ARRAY
2561: PPUSH
2562: CALL_OW 428
2566: ST_TO_ADDR
// if hinfo > 0 then
2567: LD_VAR 0 2
2571: PUSH
2572: LD_INT 0
2574: GREATER
2575: IFFALSE 2614
// begin if GetSide ( hinfo ) = you then
2577: LD_VAR 0 2
2581: PPUSH
2582: CALL_OW 255
2586: PUSH
2587: LD_EXP 7
2591: EQUAL
2592: IFFALSE 2604
// maji_artifact := true else
2594: LD_ADDR_EXP 39
2598: PUSH
2599: LD_INT 1
2601: ST_TO_ADDR
2602: GO 2612
// maji_artifact := false ;
2604: LD_ADDR_EXP 39
2608: PUSH
2609: LD_INT 0
2611: ST_TO_ADDR
// end else
2612: GO 2732
// begin maji_artifact := false ;
2614: LD_ADDR_EXP 39
2618: PUSH
2619: LD_INT 0
2621: ST_TO_ADDR
// for i := 1 to 5 do
2622: LD_ADDR_VAR 0 3
2626: PUSH
2627: DOUBLE
2628: LD_INT 1
2630: DEC
2631: ST_TO_ADDR
2632: LD_INT 5
2634: PUSH
2635: FOR_TO
2636: IFFALSE 2730
// if ( ai_s [ i ] in your_bases ) and ( InArea ( h [ 1 ] , h [ 2 ] , near_base_area [ i ] ) or InArea ( h [ 1 ] , h [ 2 ] , nearD ) ) then
2638: LD_EXP 23
2642: PUSH
2643: LD_VAR 0 3
2647: ARRAY
2648: PUSH
2649: LD_EXP 18
2653: IN
2654: PUSH
2655: LD_VAR 0 1
2659: PUSH
2660: LD_INT 1
2662: ARRAY
2663: PPUSH
2664: LD_VAR 0 1
2668: PUSH
2669: LD_INT 2
2671: ARRAY
2672: PPUSH
2673: LD_EXP 63
2677: PUSH
2678: LD_VAR 0 3
2682: ARRAY
2683: PPUSH
2684: CALL_OW 309
2688: PUSH
2689: LD_VAR 0 1
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: LD_VAR 0 1
2702: PUSH
2703: LD_INT 2
2705: ARRAY
2706: PPUSH
2707: LD_INT 27
2709: PPUSH
2710: CALL_OW 309
2714: OR
2715: AND
2716: IFFALSE 2728
// begin maji_artifact := true ;
2718: LD_ADDR_EXP 39
2722: PUSH
2723: LD_INT 1
2725: ST_TO_ADDR
// break ;
2726: GO 2730
// end ;
2728: GO 2635
2730: POP
2731: POP
// end ; end ; enable ;
2732: ENABLE
// end ;
2733: PPOPN 3
2735: END
// export function DGossudarov ; var x , y ; begin
2736: LD_INT 0
2738: PPUSH
2739: PPUSH
2740: PPUSH
// x := GetX ( run_sci [ 1 ] ) ;
2741: LD_ADDR_VAR 0 2
2745: PUSH
2746: LD_EXP 31
2750: PUSH
2751: LD_INT 1
2753: ARRAY
2754: PPUSH
2755: CALL_OW 250
2759: ST_TO_ADDR
// y := GetY ( run_sci [ 1 ] ) ;
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: LD_EXP 31
2769: PUSH
2770: LD_INT 1
2772: ARRAY
2773: PPUSH
2774: CALL_OW 251
2778: ST_TO_ADDR
// PlaceSeeing ( x , y , You , 10 ) ;
2779: LD_VAR 0 2
2783: PPUSH
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_EXP 7
2793: PPUSH
2794: LD_INT 10
2796: PPUSH
2797: CALL_OW 330
// CenterNowOnXY ( x , y ) ;
2801: LD_VAR 0 2
2805: PPUSH
2806: LD_VAR 0 3
2810: PPUSH
2811: CALL_OW 86
// wait ( 0 0$1 ) ;
2815: LD_INT 35
2817: PPUSH
2818: CALL_OW 67
// DialogueOn ;
2822: CALL_OW 6
// Say ( Fad , DGossudarov-Fad-1 ) ;
2826: LD_LOC 5
2830: PPUSH
2831: LD_STRING DGossudarov-Fad-1
2833: PPUSH
2834: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-1 ) ;
2838: LD_LOC 2
2842: PPUSH
2843: LD_STRING DGossudarov-Bur-1
2845: PPUSH
2846: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-1 ) ;
2850: LD_LOC 4
2854: PPUSH
2855: LD_STRING DGossudarov-Gos-1
2857: PPUSH
2858: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-2 ) ;
2862: LD_LOC 2
2866: PPUSH
2867: LD_STRING DGossudarov-Bur-2
2869: PPUSH
2870: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-2 ) ;
2874: LD_LOC 4
2878: PPUSH
2879: LD_STRING DGossudarov-Gos-2
2881: PPUSH
2882: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-3 ) ;
2886: LD_LOC 2
2890: PPUSH
2891: LD_STRING DGossudarov-Bur-3
2893: PPUSH
2894: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-3 ) ;
2898: LD_LOC 4
2902: PPUSH
2903: LD_STRING DGossudarov-Gos-3
2905: PPUSH
2906: CALL_OW 88
// ChangeMissionObjectives ( MGoss ) ;
2910: LD_STRING MGoss
2912: PPUSH
2913: CALL_OW 337
// DialogueOff ;
2917: CALL_OW 7
// wait ( 0 0$5 ) ;
2921: LD_INT 175
2923: PPUSH
2924: CALL_OW 67
// RemoveSeeing ( x , y , You ) ;
2928: LD_VAR 0 2
2932: PPUSH
2933: LD_VAR 0 3
2937: PPUSH
2938: LD_EXP 7
2942: PPUSH
2943: CALL_OW 331
// end ;
2947: LD_VAR 0 1
2951: RET
// every 0 0$2 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
2952: LD_EXP 23
2956: PUSH
2957: LD_EXP 25
2961: ARRAY
2962: PPUSH
2963: LD_EXP 37
2967: PUSH
2968: LD_EXP 35
2972: ADD
2973: PPUSH
2974: CALL 10570 0 2
2978: PUSH
2979: LD_EXP 37
2983: PUSH
2984: LD_EXP 35
2988: ADD
2989: PPUSH
2990: LD_INT 95
2992: PUSH
2993: LD_EXP 63
2997: PUSH
2998: LD_EXP 25
3002: ARRAY
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: EMPTY
3009: LIST
3010: PPUSH
3011: CALL_OW 72
3015: AND
3016: IFFALSE 3025
3018: GO 3020
3020: DISABLE
// begin DA_BaseContact ;
3021: CALL 3026 0 0
// end ;
3025: END
// export function DA_BaseContact ; begin
3026: LD_INT 0
3028: PPUSH
// DialogueOn ;
3029: CALL_OW 6
// Say ( Pla , DA-BaseContact-Pla-1 ) ;
3033: LD_LOC 3
3037: PPUSH
3038: LD_STRING DA-BaseContact-Pla-1
3040: PPUSH
3041: CALL_OW 88
// Say ( Bur , DA-BaseContact-Bur-1 ) ;
3045: LD_LOC 2
3049: PPUSH
3050: LD_STRING DA-BaseContact-Bur-1
3052: PPUSH
3053: CALL_OW 88
// DialogueOff ;
3057: CALL_OW 7
// end ;
3061: LD_VAR 0 1
3065: RET
// every 0 0$20 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
3066: LD_EXP 23
3070: PUSH
3071: LD_EXP 25
3075: ARRAY
3076: PPUSH
3077: LD_EXP 37
3081: PUSH
3082: LD_EXP 35
3086: ADD
3087: PPUSH
3088: CALL 10570 0 2
3092: PUSH
3093: LD_EXP 37
3097: PUSH
3098: LD_EXP 35
3102: ADD
3103: PPUSH
3104: LD_INT 95
3106: PUSH
3107: LD_EXP 63
3111: PUSH
3112: LD_EXP 25
3116: ARRAY
3117: PUSH
3118: EMPTY
3119: LIST
3120: LIST
3121: PUSH
3122: EMPTY
3123: LIST
3124: PPUSH
3125: CALL_OW 72
3129: AND
3130: IFFALSE 3213
3132: GO 3134
3134: DISABLE
// begin wait ( 0 0$20 ) ;
3135: LD_INT 700
3137: PPUSH
3138: CALL_OW 67
// if see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) then
3142: LD_EXP 23
3146: PUSH
3147: LD_EXP 25
3151: ARRAY
3152: PPUSH
3153: LD_EXP 37
3157: PUSH
3158: LD_EXP 35
3162: ADD
3163: PPUSH
3164: CALL 10570 0 2
3168: PUSH
3169: LD_EXP 37
3173: PUSH
3174: LD_EXP 35
3178: ADD
3179: PPUSH
3180: LD_INT 95
3182: PUSH
3183: LD_EXP 63
3187: PUSH
3188: LD_EXP 25
3192: ARRAY
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: PPUSH
3201: CALL_OW 72
3205: AND
3206: IFFALSE 3212
// DA_BaseRefuse ;
3208: CALL 3993 0 0
// enable ;
3212: ENABLE
// end ;
3213: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 12 do
3214: LD_EXP 76
3218: PUSH
3219: LD_EXP 25
3223: ARRAY
3224: PPUSH
3225: LD_INT 3
3227: PUSH
3228: LD_EXP 54
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PPUSH
3237: CALL_OW 72
3241: PUSH
3242: LD_INT 12
3244: LESS
3245: IFFALSE 3258
3247: GO 3249
3249: DISABLE
// begin DA_BaseRefuse ;
3250: CALL 3993 0 0
// ZoufalUtok ;
3254: CALL 11874 0 0
// end ;
3258: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 10 do
3259: LD_EXP 76
3263: PUSH
3264: LD_EXP 25
3268: ARRAY
3269: PPUSH
3270: LD_INT 3
3272: PUSH
3273: LD_EXP 54
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 72
3286: PUSH
3287: LD_INT 10
3289: LESS
3290: IFFALSE 3303
3292: GO 3294
3294: DISABLE
// begin DA_BaseRefuse ;
3295: CALL 3993 0 0
// BehemothUtok ;
3299: CALL 11683 0 0
// end ;
3303: END
// every 25 25$0 do
3304: GO 3306
3306: DISABLE
// begin BehemothUtok ;
3307: CALL 11683 0 0
// end ;
3311: END
// every 10 10$0 + 0 0$5 do
3312: GO 3314
3314: DISABLE
// begin NormalUtok ;
3315: CALL 12071 0 0
// end ;
3319: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) <= 7 and UnitFilter ( buildings [ plat_i ] , [ f_or , [ f_btype , b_turret ] , [ [ f_occupied ] , mf_fort ] ] ) <= 2 do var kam_zdrha , k_dispozici , mt , kam_telp , h , i , kam_zdrha_i ;
3320: LD_EXP 76
3324: PUSH
3325: LD_EXP 25
3329: ARRAY
3330: PPUSH
3331: LD_INT 3
3333: PUSH
3334: LD_EXP 54
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: CALL_OW 72
3347: PUSH
3348: LD_INT 7
3350: LESSEQUAL
3351: PUSH
3352: LD_EXP 75
3356: PUSH
3357: LD_EXP 25
3361: ARRAY
3362: PPUSH
3363: LD_INT 2
3365: PUSH
3366: LD_INT 30
3368: PUSH
3369: LD_INT 33
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 59
3378: PUSH
3379: EMPTY
3380: LIST
3381: PUSH
3382: LD_EXP 56
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 72
3400: PUSH
3401: LD_INT 2
3403: LESSEQUAL
3404: AND
3405: IFFALSE 3990
3407: GO 3409
3409: DISABLE
3410: LD_INT 0
3412: PPUSH
3413: PPUSH
3414: PPUSH
3415: PPUSH
3416: PPUSH
3417: PPUSH
3418: PPUSH
// begin k_dispozici := ( ai diff ( ai [ 1 ] ^ your_bases ) ) ;
3419: LD_ADDR_VAR 0 2
3423: PUSH
3424: LD_EXP 24
3428: PUSH
3429: LD_EXP 24
3433: PUSH
3434: LD_INT 1
3436: ARRAY
3437: PUSH
3438: LD_EXP 18
3442: ADD
3443: DIFF
3444: ST_TO_ADDR
// if k_dispozici then
3445: LD_VAR 0 2
3449: IFFALSE 3945
// begin kam_zdrha := ( k_dispozici ) [ Rand ( 1 , k_dispozici ) ] ;
3451: LD_ADDR_VAR 0 1
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 1
3463: PPUSH
3464: LD_VAR 0 2
3468: PPUSH
3469: CALL_OW 12
3473: ARRAY
3474: ST_TO_ADDR
// case kam_zdrha of ai_s [ 2 ] :
3475: LD_VAR 0 1
3479: PUSH
3480: LD_EXP 23
3484: PUSH
3485: LD_INT 2
3487: ARRAY
3488: DOUBLE
3489: EQUAL
3490: IFTRUE 3494
3492: GO 3505
3494: POP
// kam_telp := b_base ; ai_s [ 3 ] :
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: LD_INT 20
3502: ST_TO_ADDR
3503: GO 3581
3505: LD_EXP 23
3509: PUSH
3510: LD_INT 3
3512: ARRAY
3513: DOUBLE
3514: EQUAL
3515: IFTRUE 3519
3517: GO 3530
3519: POP
// kam_telp := c_base ; ai_s [ 4 ] :
3520: LD_ADDR_VAR 0 4
3524: PUSH
3525: LD_INT 23
3527: ST_TO_ADDR
3528: GO 3581
3530: LD_EXP 23
3534: PUSH
3535: LD_INT 4
3537: ARRAY
3538: DOUBLE
3539: EQUAL
3540: IFTRUE 3544
3542: GO 3555
3544: POP
// kam_telp := d_base ; ai_s [ 5 ] :
3545: LD_ADDR_VAR 0 4
3549: PUSH
3550: LD_INT 22
3552: ST_TO_ADDR
3553: GO 3581
3555: LD_EXP 23
3559: PUSH
3560: LD_INT 5
3562: ARRAY
3563: DOUBLE
3564: EQUAL
3565: IFTRUE 3569
3567: GO 3580
3569: POP
// kam_telp := e_base ; end ;
3570: LD_ADDR_VAR 0 4
3574: PUSH
3575: LD_INT 21
3577: ST_TO_ADDR
3578: GO 3581
3580: POP
// repeat h := RandHexArea ( kam_telp , false ) ;
3581: LD_ADDR_VAR 0 5
3585: PUSH
3586: LD_VAR 0 4
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 16
3598: ST_TO_ADDR
// until HexInfo ( h [ 1 ] , h [ 2 ] ) = 0 ;
3599: LD_VAR 0 5
3603: PUSH
3604: LD_INT 1
3606: ARRAY
3607: PPUSH
3608: LD_VAR 0 5
3612: PUSH
3613: LD_INT 2
3615: ARRAY
3616: PPUSH
3617: CALL_OW 428
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3581
// TeleportExit ( telp1 , h [ 1 ] , h [ 2 ] ) ;
3627: LD_INT 15
3629: PPUSH
3630: LD_VAR 0 5
3634: PUSH
3635: LD_INT 1
3637: ARRAY
3638: PPUSH
3639: LD_VAR 0 5
3643: PUSH
3644: LD_INT 2
3646: ARRAY
3647: PPUSH
3648: CALL_OW 243
// ComExitVehicle ( Platonov ) ;
3652: LD_EXP 42
3656: PPUSH
3657: CALL_OW 121
// AddComExitBuilding ( Platonov ) ;
3661: LD_EXP 42
3665: PPUSH
3666: CALL_OW 182
// AddComEnterUnit ( Platonov , telp1 ) ;
3670: LD_EXP 42
3674: PPUSH
3675: LD_INT 15
3677: PPUSH
3678: CALL_OW 180
// for i := 1 to 5 do
3682: LD_ADDR_VAR 0 6
3686: PUSH
3687: DOUBLE
3688: LD_INT 1
3690: DEC
3691: ST_TO_ADDR
3692: LD_INT 5
3694: PUSH
3695: FOR_TO
3696: IFFALSE 3728
// if ai_s [ i ] = kam_zdrha then
3698: LD_EXP 23
3702: PUSH
3703: LD_VAR 0 6
3707: ARRAY
3708: PUSH
3709: LD_VAR 0 1
3713: EQUAL
3714: IFFALSE 3726
// kam_zdrha_i := i ;
3716: LD_ADDR_VAR 0 7
3720: PUSH
3721: LD_VAR 0 6
3725: ST_TO_ADDR
3726: GO 3695
3728: POP
3729: POP
// plat_i := kam_zdrha_i ;
3730: LD_ADDR_EXP 25
3734: PUSH
3735: LD_VAR 0 7
3739: ST_TO_ADDR
// ai_s := replace ( ai_s , kam_zdrha_i , ai_s [ 1 ] ) ;
3740: LD_ADDR_EXP 23
3744: PUSH
3745: LD_EXP 23
3749: PPUSH
3750: LD_VAR 0 7
3754: PPUSH
3755: LD_EXP 23
3759: PUSH
3760: LD_INT 1
3762: ARRAY
3763: PPUSH
3764: CALL_OW 1
3768: ST_TO_ADDR
// wait ( 0 0$5 ) ;
3769: LD_INT 175
3771: PPUSH
3772: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3776: LD_EXP 42
3780: PPUSH
3781: LD_EXP 74
3785: PUSH
3786: LD_VAR 0 7
3790: ARRAY
3791: PPUSH
3792: CALL_OW 180
// DA_BaseAccept ;
3796: CALL 4043 0 0
// SurrenderBase ( t_killbeat , ai_s [ plat_i ] ) ;
3800: LD_EXP 6
3804: PPUSH
3805: LD_EXP 23
3809: PUSH
3810: LD_EXP 25
3814: ARRAY
3815: PPUSH
3816: CALL 30354 0 2
// SetAttitude ( ai_s [ plat_i ] , you , att_enemy , true ) ;
3820: LD_EXP 23
3824: PUSH
3825: LD_EXP 25
3829: ARRAY
3830: PPUSH
3831: LD_EXP 7
3835: PPUSH
3836: LD_INT 2
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: CALL_OW 80
// SetSideBase_custom ( GetBase ( depots [ plat_i ] ) , ai_s [ plat_i ] ) ;
3846: LD_EXP 74
3850: PUSH
3851: LD_EXP 25
3855: ARRAY
3856: PPUSH
3857: CALL_OW 274
3861: PPUSH
3862: LD_EXP 23
3866: PUSH
3867: LD_EXP 25
3871: ARRAY
3872: PPUSH
3873: CALL 32759 0 2
// SetSide ( FilterAllUnits ( [ [ f_side , kam_zdrha ] ] ) , ai_s [ plat_i ] ) ;
3877: LD_INT 22
3879: PUSH
3880: LD_VAR 0 1
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: PUSH
3889: EMPTY
3890: LIST
3891: PPUSH
3892: CALL_OW 69
3896: PPUSH
3897: LD_EXP 23
3901: PUSH
3902: LD_EXP 25
3906: ARRAY
3907: PPUSH
3908: CALL_OW 235
// wait ( 1 1$0 ) ;
3912: LD_INT 2100
3914: PPUSH
3915: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3919: LD_EXP 42
3923: PPUSH
3924: LD_EXP 74
3928: PUSH
3929: LD_VAR 0 7
3933: ARRAY
3934: PPUSH
3935: CALL_OW 180
// ZoufalUtok ;
3939: CALL 11874 0 0
// end else
3943: GO 3990
// begin while not IsDead ( Platonov ) do
3945: LD_EXP 42
3949: PPUSH
3950: CALL_OW 301
3954: NOT
3955: IFFALSE 3990
// begin ComAttackUnit ( Platonov , NearestUnitToUnit ( your_humans , Platonov ) ) ;
3957: LD_EXP 42
3961: PPUSH
3962: LD_EXP 37
3966: PPUSH
3967: LD_EXP 42
3971: PPUSH
3972: CALL_OW 74
3976: PPUSH
3977: CALL_OW 115
// wait ( 0 0$5 ) ;
3981: LD_INT 175
3983: PPUSH
3984: CALL_OW 67
// end ;
3988: GO 3945
// end ; end ;
3990: PPOPN 7
3992: END
// export function DA_BaseRefuse ; begin
3993: LD_INT 0
3995: PPUSH
// DialogueOn ;
3996: CALL_OW 6
// if not IsDead ( Pla ) then
4000: LD_LOC 3
4004: PPUSH
4005: CALL_OW 301
4009: NOT
4010: IFFALSE 4034
// if not Say ( Pla , DA-BaseReguse-Pla-1 ) then
4012: LD_LOC 3
4016: PPUSH
4017: LD_STRING DA-BaseReguse-Pla-1
4019: PPUSH
4020: CALL_OW 88
4024: NOT
4025: IFFALSE 4034
// msg ( bad ident: DA-BaseReguse-Pla-1 ) ;
4027: LD_STRING bad ident: DA-BaseReguse-Pla-1
4029: PPUSH
4030: CALL_OW 100
// DialogueOff ;
4034: CALL_OW 7
// end ;
4038: LD_VAR 0 1
4042: RET
// export function DA_BaseAccept ; begin
4043: LD_INT 0
4045: PPUSH
// DialogueOn ;
4046: CALL_OW 6
// Say ( Pla , DA-BaseAccept-Pla-1 ) ;
4050: LD_LOC 3
4054: PPUSH
4055: LD_STRING DA-BaseAccept-Pla-1
4057: PPUSH
4058: CALL_OW 88
// DialogueOff ;
4062: CALL_OW 7
// end ;
4066: LD_VAR 0 1
4070: RET
// every 0 0$2 trigger See ( you , behemoth ) do var who ;
4071: LD_EXP 7
4075: PPUSH
4076: LD_INT 125
4078: PPUSH
4079: CALL_OW 292
4083: IFFALSE 4202
4085: GO 4087
4087: DISABLE
4088: LD_INT 0
4090: PPUSH
// begin BehemothSeen := true ;
4091: LD_ADDR_EXP 29
4095: PUSH
4096: LD_INT 1
4098: ST_TO_ADDR
// if GetSide ( behemoth ) = you then
4099: LD_INT 125
4101: PPUSH
4102: CALL_OW 255
4106: PUSH
4107: LD_EXP 7
4111: EQUAL
4112: IFFALSE 4116
// exit ;
4114: GO 4202
// CenterNowOnUnits ( behemoth ) ;
4116: LD_INT 125
4118: PPUSH
4119: CALL_OW 87
// who := WhoSayAny ( your_humans diff talking , you , sex_male , 0 , 0 ) ;
4123: LD_ADDR_VAR 0 1
4127: PUSH
4128: LD_EXP 37
4132: PUSH
4133: LD_LOC 11
4137: DIFF
4138: PPUSH
4139: LD_EXP 7
4143: PPUSH
4144: LD_INT 1
4146: PPUSH
4147: LD_INT 0
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL 10376 0 5
4157: ST_TO_ADDR
// DialogueOn ;
4158: CALL_OW 6
// Say ( who , DBehemoth-Rsol1-1 ) ;
4162: LD_VAR 0 1
4166: PPUSH
4167: LD_STRING DBehemoth-Rsol1-1
4169: PPUSH
4170: CALL_OW 88
// Say ( Pla , DBehemoth-Pla-1 ) ;
4174: LD_LOC 3
4178: PPUSH
4179: LD_STRING DBehemoth-Pla-1
4181: PPUSH
4182: CALL_OW 88
// Say ( Bur , DBehemoth-Bur-1 ) ;
4186: LD_LOC 2
4190: PPUSH
4191: LD_STRING DBehemoth-Bur-1
4193: PPUSH
4194: CALL_OW 88
// DialogueOff ;
4198: CALL_OW 7
// end ;
4202: PPOPN 1
4204: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] do
4205: LD_LOC 2
4209: PPUSH
4210: LD_INT 20
4212: PPUSH
4213: CALL_OW 308
4217: PUSH
4218: LD_EXP 23
4222: PUSH
4223: LD_INT 1
4225: ARRAY
4226: PUSH
4227: LD_EXP 23
4231: PUSH
4232: LD_INT 2
4234: ARRAY
4235: NONEQUAL
4236: AND
4237: IFFALSE 4317
4239: GO 4241
4241: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4242: LD_EXP 37
4246: PUSH
4247: LD_INT 12
4249: LESS
4250: PUSH
4251: LD_EXP 35
4255: PUSH
4256: LD_INT 20
4258: LESS
4259: AND
4260: IFFALSE 4282
// begin DB_BaseContact ;
4262: CALL 4521 0 0
// DB_BaseRefuse1st ;
4266: CALL 4549 0 0
// wait ( 0 0$30 ) ;
4270: LD_INT 1050
4272: PPUSH
4273: CALL_OW 67
// enable ( 10 ) ;
4277: LD_INT 10
4279: ENABLE_MARKED
// end else
4280: GO 4317
// begin if not ai_s [ 2 ] in your_bases then
4282: LD_EXP 23
4286: PUSH
4287: LD_INT 2
4289: ARRAY
4290: PUSH
4291: LD_EXP 18
4295: IN
4296: NOT
4297: IFFALSE 4317
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4299: LD_EXP 2
4303: PPUSH
4304: LD_EXP 23
4308: PUSH
4309: LD_INT 2
4311: ARRAY
4312: PPUSH
4313: CALL 30354 0 2
// end ; end ; end ;
4317: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] marked 10 do
4318: LD_LOC 2
4322: PPUSH
4323: LD_INT 20
4325: PPUSH
4326: CALL_OW 308
4330: PUSH
4331: LD_EXP 23
4335: PUSH
4336: LD_INT 1
4338: ARRAY
4339: PUSH
4340: LD_EXP 23
4344: PUSH
4345: LD_INT 2
4347: ARRAY
4348: NONEQUAL
4349: AND
4350: IFFALSE 4447
4352: GO 4354
4354: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4355: LD_EXP 37
4359: PUSH
4360: LD_INT 12
4362: LESS
4363: PUSH
4364: LD_EXP 35
4368: PUSH
4369: LD_INT 20
4371: LESS
4372: AND
4373: IFFALSE 4412
// begin DB_BaseRefuse ;
4375: CALL 4577 0 0
// while IsInArea ( Bur , b_base ) do
4379: LD_LOC 2
4383: PPUSH
4384: LD_INT 20
4386: PPUSH
4387: CALL_OW 308
4391: IFFALSE 4402
// wait ( 0 0$1 ) ;
4393: LD_INT 35
4395: PPUSH
4396: CALL_OW 67
4400: GO 4379
// wait ( 0 0$20 ) ;
4402: LD_INT 700
4404: PPUSH
4405: CALL_OW 67
// enable ;
4409: ENABLE
// end else
4410: GO 4447
// begin if not ai_s [ 2 ] in your_bases then
4412: LD_EXP 23
4416: PUSH
4417: LD_INT 2
4419: ARRAY
4420: PUSH
4421: LD_EXP 18
4425: IN
4426: NOT
4427: IFFALSE 4447
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4429: LD_EXP 2
4433: PPUSH
4434: LD_EXP 23
4438: PUSH
4439: LD_INT 2
4441: ARRAY
4442: PPUSH
4443: CALL 30354 0 2
// end ; end ; end ;
4447: END
// every 0 0$2 trigger humans [ 2 ] <= 6 and ai_s [ 1 ] <> ai_s [ 2 ] do
4448: LD_EXP 76
4452: PUSH
4453: LD_INT 2
4455: ARRAY
4456: PUSH
4457: LD_INT 6
4459: LESSEQUAL
4460: PUSH
4461: LD_EXP 23
4465: PUSH
4466: LD_INT 1
4468: ARRAY
4469: PUSH
4470: LD_EXP 23
4474: PUSH
4475: LD_INT 2
4477: ARRAY
4478: NONEQUAL
4479: AND
4480: IFFALSE 4520
4482: GO 4484
4484: DISABLE
// begin if not ai_s [ 2 ] in your_bases then
4485: LD_EXP 23
4489: PUSH
4490: LD_INT 2
4492: ARRAY
4493: PUSH
4494: LD_EXP 18
4498: IN
4499: NOT
4500: IFFALSE 4520
// SurrenderBase ( t_killbeat , ai_s [ 2 ] ) ;
4502: LD_EXP 6
4506: PPUSH
4507: LD_EXP 23
4511: PUSH
4512: LD_INT 2
4514: ARRAY
4515: PPUSH
4516: CALL 30354 0 2
// end ;
4520: END
// export function DB_BaseContact ; begin
4521: LD_INT 0
4523: PPUSH
// DialogueOn ;
4524: CALL_OW 6
// Say ( Bor , DB-BaseContact-Bor-1 ) ;
4528: LD_LOC 6
4532: PPUSH
4533: LD_STRING DB-BaseContact-Bor-1
4535: PPUSH
4536: CALL_OW 88
// DialogueOff ;
4540: CALL_OW 7
// end ;
4544: LD_VAR 0 1
4548: RET
// export function DB_BaseRefuse1st ; begin
4549: LD_INT 0
4551: PPUSH
// DialogueOn ;
4552: CALL_OW 6
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4556: LD_LOC 6
4560: PPUSH
4561: LD_STRING DB-BaseRefuse-Bor-1
4563: PPUSH
4564: CALL_OW 88
// DialogueOff ;
4568: CALL_OW 7
// end ;
4572: LD_VAR 0 1
4576: RET
// export function DB_BaseRefuse ; begin
4577: LD_INT 0
4579: PPUSH
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4580: LD_LOC 6
4584: PPUSH
4585: LD_STRING DB-BaseRefuse-Bor-1
4587: PPUSH
4588: CALL_OW 88
// end ;
4592: LD_VAR 0 1
4596: RET
// export function DB_BaseAccept ( first ) ; begin
4597: LD_INT 0
4599: PPUSH
// DialogueOn ;
4600: CALL_OW 6
// Say ( Bor , DB-BaseAccept-Bor-1 ) ;
4604: LD_LOC 6
4608: PPUSH
4609: LD_STRING DB-BaseAccept-Bor-1
4611: PPUSH
4612: CALL_OW 88
// if first then
4616: LD_VAR 0 1
4620: IFFALSE 4636
// Say ( Bor , DB-BaseAccept-Bor-1a ) else
4622: LD_LOC 6
4626: PPUSH
4627: LD_STRING DB-BaseAccept-Bor-1a
4629: PPUSH
4630: CALL_OW 88
4634: GO 4648
// Say ( Bor , DB-BaseAccept-Bor-1b ) ;
4636: LD_LOC 6
4640: PPUSH
4641: LD_STRING DB-BaseAccept-Bor-1b
4643: PPUSH
4644: CALL_OW 88
// DialogueOff ;
4648: CALL_OW 7
// end ;
4652: LD_VAR 0 2
4656: RET
// var jeste_nebylo ; every 0 0$2 trigger IsInArea ( Bur , c_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
4657: LD_LOC 2
4661: PPUSH
4662: LD_INT 23
4664: PPUSH
4665: CALL_OW 308
4669: PUSH
4670: LD_EXP 23
4674: PUSH
4675: LD_INT 1
4677: ARRAY
4678: PUSH
4679: LD_EXP 23
4683: PUSH
4684: LD_INT 4
4686: ARRAY
4687: NONEQUAL
4688: AND
4689: IFFALSE 4786
4691: GO 4693
4693: DISABLE
// begin jeste_nebylo := [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
4694: LD_ADDR_LOC 12
4698: PUSH
4699: LD_INT 1
4701: PUSH
4702: LD_INT 2
4704: PUSH
4705: LD_INT 3
4707: PUSH
4708: LD_INT 4
4710: PUSH
4711: LD_INT 5
4713: PUSH
4714: LD_INT 6
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: LIST
4724: ST_TO_ADDR
// DC_BaseContact ;
4725: CALL 5476 0 0
// if otazky then
4729: CALL 4906 0 0
4733: IFFALSE 4786
// if not ai_s [ 3 ] in your_bases then
4735: LD_EXP 23
4739: PUSH
4740: LD_INT 3
4742: ARRAY
4743: PUSH
4744: LD_EXP 18
4748: IN
4749: NOT
4750: IFFALSE 4772
// SurrenderBase ( t_persuade , ai_s [ 3 ] ) else
4752: LD_EXP 3
4756: PPUSH
4757: LD_EXP 23
4761: PUSH
4762: LD_INT 3
4764: ARRAY
4765: PPUSH
4766: CALL 30354 0 2
4770: GO 4786
// begin DQrML_Wrong ;
4772: CALL 6816 0 0
// wait ( 0 0$30 ) ;
4776: LD_INT 1050
4778: PPUSH
4779: CALL_OW 67
// enable ( 11 ) ;
4783: LD_INT 11
4785: ENABLE_MARKED
// end ; end ;
4786: END
// every 0 0$2 trigger IsInArea ( Bur , c_base ) marked 11 do
4787: LD_LOC 2
4791: PPUSH
4792: LD_INT 23
4794: PPUSH
4795: CALL_OW 308
4799: IFFALSE 4832
4801: GO 4803
4803: DISABLE
// begin if not otazky then
4804: CALL 4906 0 0
4808: NOT
4809: IFFALSE 4814
// enable else
4811: ENABLE
4812: GO 4832
// SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4814: LD_EXP 2
4818: PPUSH
4819: LD_EXP 23
4823: PUSH
4824: LD_INT 2
4826: ARRAY
4827: PPUSH
4828: CALL 30354 0 2
// end ;
4832: END
// every 0 0$2 trigger humans [ 3 ] <= 2 and ai_s [ 1 ] <> ai_s [ 4 ] do
4833: LD_EXP 76
4837: PUSH
4838: LD_INT 3
4840: ARRAY
4841: PUSH
4842: LD_INT 2
4844: LESSEQUAL
4845: PUSH
4846: LD_EXP 23
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: LD_EXP 23
4859: PUSH
4860: LD_INT 4
4862: ARRAY
4863: NONEQUAL
4864: AND
4865: IFFALSE 4905
4867: GO 4869
4869: DISABLE
// begin if not ai_s [ 3 ] in your_bases then
4870: LD_EXP 23
4874: PUSH
4875: LD_INT 3
4877: ARRAY
4878: PUSH
4879: LD_EXP 18
4883: IN
4884: NOT
4885: IFFALSE 4905
// SurrenderBase ( t_killbeat , ai_s [ 3 ] ) ;
4887: LD_EXP 6
4891: PPUSH
4892: LD_EXP 23
4896: PUSH
4897: LD_INT 3
4899: ARRAY
4900: PPUSH
4901: CALL 30354 0 2
// end ;
4905: END
// function otazky ; var qb , qg , q ; begin
4906: LD_INT 0
4908: PPUSH
4909: PPUSH
4910: PPUSH
4911: PPUSH
// DC_BaseQuestion ;
4912: CALL 5504 0 0
// qb := 0 ;
4916: LD_ADDR_VAR 0 2
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// qg := 0 ;
4924: LD_ADDR_VAR 0 3
4928: PUSH
4929: LD_INT 0
4931: ST_TO_ADDR
// q := 0 ;
4932: LD_ADDR_VAR 0 4
4936: PUSH
4937: LD_INT 0
4939: ST_TO_ADDR
// while [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] and jeste_nebylo do
4940: LD_VAR 0 2
4944: PUSH
4945: LD_INT 2
4947: LESSEQUAL
4948: PUSH
4949: LD_VAR 0 2
4953: PUSH
4954: LD_INT 1
4956: LESSEQUAL
4957: PUSH
4958: LD_VAR 0 2
4962: PUSH
4963: LD_INT 0
4965: LESSEQUAL
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: LD_OWVAR 67
4976: ARRAY
4977: PUSH
4978: LD_LOC 12
4982: AND
4983: IFFALSE 5405
// begin q := q + 1 ;
4985: LD_ADDR_VAR 0 4
4989: PUSH
4990: LD_VAR 0 4
4994: PUSH
4995: LD_INT 1
4997: PLUS
4998: ST_TO_ADDR
// case jeste_nebylo [ Rand ( 1 , jeste_nebylo ) ] of 1 :
4999: LD_LOC 12
5003: PUSH
5004: LD_INT 1
5006: PPUSH
5007: LD_LOC 12
5011: PPUSH
5012: CALL_OW 12
5016: ARRAY
5017: PUSH
5018: LD_INT 1
5020: DOUBLE
5021: EQUAL
5022: IFTRUE 5026
5024: GO 5082
5026: POP
// begin if QML1 then
5027: CALL 5532 0 0
5031: IFFALSE 5049
// qg := qg + 1 else
5033: LD_ADDR_VAR 0 3
5037: PUSH
5038: LD_VAR 0 3
5042: PUSH
5043: LD_INT 1
5045: PLUS
5046: ST_TO_ADDR
5047: GO 5063
// qb := qb + 1 ;
5049: LD_ADDR_VAR 0 2
5053: PUSH
5054: LD_VAR 0 2
5058: PUSH
5059: LD_INT 1
5061: PLUS
5062: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 1 ] ;
5063: LD_ADDR_LOC 12
5067: PUSH
5068: LD_LOC 12
5072: PUSH
5073: LD_INT 1
5075: PUSH
5076: EMPTY
5077: LIST
5078: DIFF
5079: ST_TO_ADDR
// end ; 2 :
5080: GO 5403
5082: LD_INT 2
5084: DOUBLE
5085: EQUAL
5086: IFTRUE 5090
5088: GO 5146
5090: POP
// begin if QML2 then
5091: CALL 5736 0 0
5095: IFFALSE 5113
// qg := qg + 1 else
5097: LD_ADDR_VAR 0 3
5101: PUSH
5102: LD_VAR 0 3
5106: PUSH
5107: LD_INT 1
5109: PLUS
5110: ST_TO_ADDR
5111: GO 5127
// qb := qb + 1 ;
5113: LD_ADDR_VAR 0 2
5117: PUSH
5118: LD_VAR 0 2
5122: PUSH
5123: LD_INT 1
5125: PLUS
5126: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 2 ] ;
5127: LD_ADDR_LOC 12
5131: PUSH
5132: LD_LOC 12
5136: PUSH
5137: LD_INT 2
5139: PUSH
5140: EMPTY
5141: LIST
5142: DIFF
5143: ST_TO_ADDR
// end ; 3 :
5144: GO 5403
5146: LD_INT 3
5148: DOUBLE
5149: EQUAL
5150: IFTRUE 5154
5152: GO 5210
5154: POP
// begin if QML3 then
5155: CALL 5940 0 0
5159: IFFALSE 5177
// qg := qg + 1 else
5161: LD_ADDR_VAR 0 3
5165: PUSH
5166: LD_VAR 0 3
5170: PUSH
5171: LD_INT 1
5173: PLUS
5174: ST_TO_ADDR
5175: GO 5191
// qb := qb + 1 ;
5177: LD_ADDR_VAR 0 2
5181: PUSH
5182: LD_VAR 0 2
5186: PUSH
5187: LD_INT 1
5189: PLUS
5190: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 3 ] ;
5191: LD_ADDR_LOC 12
5195: PUSH
5196: LD_LOC 12
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: EMPTY
5205: LIST
5206: DIFF
5207: ST_TO_ADDR
// end ; 4 :
5208: GO 5403
5210: LD_INT 4
5212: DOUBLE
5213: EQUAL
5214: IFTRUE 5218
5216: GO 5274
5218: POP
// begin if QML4 then
5219: CALL 6144 0 0
5223: IFFALSE 5241
// qg := qg + 1 else
5225: LD_ADDR_VAR 0 3
5229: PUSH
5230: LD_VAR 0 3
5234: PUSH
5235: LD_INT 1
5237: PLUS
5238: ST_TO_ADDR
5239: GO 5255
// qb := qb + 1 ;
5241: LD_ADDR_VAR 0 2
5245: PUSH
5246: LD_VAR 0 2
5250: PUSH
5251: LD_INT 1
5253: PLUS
5254: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 4 ] ;
5255: LD_ADDR_LOC 12
5259: PUSH
5260: LD_LOC 12
5264: PUSH
5265: LD_INT 4
5267: PUSH
5268: EMPTY
5269: LIST
5270: DIFF
5271: ST_TO_ADDR
// end ; 5 :
5272: GO 5403
5274: LD_INT 5
5276: DOUBLE
5277: EQUAL
5278: IFTRUE 5282
5280: GO 5338
5282: POP
// begin if QML5 then
5283: CALL 6348 0 0
5287: IFFALSE 5305
// qg := qg + 1 else
5289: LD_ADDR_VAR 0 3
5293: PUSH
5294: LD_VAR 0 3
5298: PUSH
5299: LD_INT 1
5301: PLUS
5302: ST_TO_ADDR
5303: GO 5319
// qb := qb + 1 ;
5305: LD_ADDR_VAR 0 2
5309: PUSH
5310: LD_VAR 0 2
5314: PUSH
5315: LD_INT 1
5317: PLUS
5318: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 5 ] ;
5319: LD_ADDR_LOC 12
5323: PUSH
5324: LD_LOC 12
5328: PUSH
5329: LD_INT 5
5331: PUSH
5332: EMPTY
5333: LIST
5334: DIFF
5335: ST_TO_ADDR
// end ; 6 :
5336: GO 5403
5338: LD_INT 6
5340: DOUBLE
5341: EQUAL
5342: IFTRUE 5346
5344: GO 5402
5346: POP
// begin if QML6 then
5347: CALL 6552 0 0
5351: IFFALSE 5369
// qg := qg + 1 else
5353: LD_ADDR_VAR 0 3
5357: PUSH
5358: LD_VAR 0 3
5362: PUSH
5363: LD_INT 1
5365: PLUS
5366: ST_TO_ADDR
5367: GO 5383
// qb := qb + 1 ;
5369: LD_ADDR_VAR 0 2
5373: PUSH
5374: LD_VAR 0 2
5378: PUSH
5379: LD_INT 1
5381: PLUS
5382: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 6 ] ;
5383: LD_ADDR_LOC 12
5387: PUSH
5388: LD_LOC 12
5392: PUSH
5393: LD_INT 6
5395: PUSH
5396: EMPTY
5397: LIST
5398: DIFF
5399: ST_TO_ADDR
// end ; end ;
5400: GO 5403
5402: POP
// end ;
5403: GO 4940
// SA_OnTsaritsynQuizPerfectCleared ( qg ) ;
5405: LD_VAR 0 3
5409: PPUSH
5410: CALL 33152 0 1
// if [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] then
5414: LD_VAR 0 2
5418: PUSH
5419: LD_INT 2
5421: LESSEQUAL
5422: PUSH
5423: LD_VAR 0 2
5427: PUSH
5428: LD_INT 1
5430: LESSEQUAL
5431: PUSH
5432: LD_VAR 0 2
5436: PUSH
5437: LD_INT 0
5439: LESSEQUAL
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: LIST
5445: PUSH
5446: LD_OWVAR 67
5450: ARRAY
5451: IFFALSE 5463
// result := true else
5453: LD_ADDR_VAR 0 1
5457: PUSH
5458: LD_INT 1
5460: ST_TO_ADDR
5461: GO 5471
// result := false ;
5463: LD_ADDR_VAR 0 1
5467: PUSH
5468: LD_INT 0
5470: ST_TO_ADDR
// end ;
5471: LD_VAR 0 1
5475: RET
// export function DC_BaseContact ; begin
5476: LD_INT 0
5478: PPUSH
// DialogueOn ;
5479: CALL_OW 6
// Say ( Tsr , DC-BaseContact-Tsr-1 ) ;
5483: LD_LOC 7
5487: PPUSH
5488: LD_STRING DC-BaseContact-Tsr-1
5490: PPUSH
5491: CALL_OW 88
// DialogueOff ;
5495: CALL_OW 7
// end ;
5499: LD_VAR 0 1
5503: RET
// export function DC_BaseQuestion ; begin
5504: LD_INT 0
5506: PPUSH
// DialogueOn ;
5507: CALL_OW 6
// Say ( Tsr , DC-BaseQuestion-Tsr-1 ) ;
5511: LD_LOC 7
5515: PPUSH
5516: LD_STRING DC-BaseQuestion-Tsr-1
5518: PPUSH
5519: CALL_OW 88
// DialogueOff ;
5523: CALL_OW 7
// end ;
5527: LD_VAR 0 1
5531: RET
// function QML1 ; var mozn , qr , a , bad ; begin
5532: LD_INT 0
5534: PPUSH
5535: PPUSH
5536: PPUSH
5537: PPUSH
5538: PPUSH
// bad := [ 1 , 3 ] ;
5539: LD_ADDR_VAR 0 5
5543: PUSH
5544: LD_INT 1
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5554: LD_ADDR_VAR 0 2
5558: PUSH
5559: LD_INT 1
5561: PUSH
5562: LD_INT 2
5564: PUSH
5565: LD_INT 3
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: LIST
5572: ST_TO_ADDR
// if IsOk ( Gleb ) then
5573: LD_EXP 50
5577: PPUSH
5578: CALL_OW 302
5582: IFFALSE 5601
// mozn := mozn ^ [ 4 ] ;
5584: LD_ADDR_VAR 0 2
5588: PUSH
5589: LD_VAR 0 2
5593: PUSH
5594: LD_INT 4
5596: PUSH
5597: EMPTY
5598: LIST
5599: ADD
5600: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5601: LD_ADDR_VAR 0 3
5605: PUSH
5606: LD_STRING QML1
5608: PPUSH
5609: LD_VAR 0 2
5613: PPUSH
5614: CALL_OW 98
5618: ST_TO_ADDR
// if qr = 4 then
5619: LD_VAR 0 3
5623: PUSH
5624: LD_INT 4
5626: EQUAL
5627: IFFALSE 5701
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5629: LD_ADDR_VAR 0 4
5633: PUSH
5634: LD_VAR 0 5
5638: PUSH
5639: LD_INT 1
5641: PPUSH
5642: LD_INT 2
5644: PPUSH
5645: CALL_OW 12
5649: ARRAY
5650: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5651: LD_VAR 0 4
5655: PPUSH
5656: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
5660: LD_ADDR_VAR 0 2
5664: PUSH
5665: LD_VAR 0 2
5669: PUSH
5670: LD_VAR 0 4
5674: PUSH
5675: LD_INT 4
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: DIFF
5682: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5683: LD_ADDR_VAR 0 3
5687: PUSH
5688: LD_STRING QML1
5690: PPUSH
5691: LD_VAR 0 2
5695: PPUSH
5696: CALL_OW 98
5700: ST_TO_ADDR
// end ; if qr in bad then
5701: LD_VAR 0 3
5705: PUSH
5706: LD_VAR 0 5
5710: IN
5711: IFFALSE 5723
// result := false else
5713: LD_ADDR_VAR 0 1
5717: PUSH
5718: LD_INT 0
5720: ST_TO_ADDR
5721: GO 5731
// result := true ;
5723: LD_ADDR_VAR 0 1
5727: PUSH
5728: LD_INT 1
5730: ST_TO_ADDR
// end ;
5731: LD_VAR 0 1
5735: RET
// function QML2 ; var mozn , qr , a , bad ; begin
5736: LD_INT 0
5738: PPUSH
5739: PPUSH
5740: PPUSH
5741: PPUSH
5742: PPUSH
// bad := [ 2 , 3 ] ;
5743: LD_ADDR_VAR 0 5
5747: PUSH
5748: LD_INT 2
5750: PUSH
5751: LD_INT 3
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5758: LD_ADDR_VAR 0 2
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 3
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: ST_TO_ADDR
// if IsOk ( Gleb ) then
5777: LD_EXP 50
5781: PPUSH
5782: CALL_OW 302
5786: IFFALSE 5805
// mozn := mozn ^ [ 4 ] ;
5788: LD_ADDR_VAR 0 2
5792: PUSH
5793: LD_VAR 0 2
5797: PUSH
5798: LD_INT 4
5800: PUSH
5801: EMPTY
5802: LIST
5803: ADD
5804: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5805: LD_ADDR_VAR 0 3
5809: PUSH
5810: LD_STRING QML2
5812: PPUSH
5813: LD_VAR 0 2
5817: PPUSH
5818: CALL_OW 98
5822: ST_TO_ADDR
// if qr = 4 then
5823: LD_VAR 0 3
5827: PUSH
5828: LD_INT 4
5830: EQUAL
5831: IFFALSE 5905
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5833: LD_ADDR_VAR 0 4
5837: PUSH
5838: LD_VAR 0 5
5842: PUSH
5843: LD_INT 1
5845: PPUSH
5846: LD_INT 2
5848: PPUSH
5849: CALL_OW 12
5853: ARRAY
5854: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5855: LD_VAR 0 4
5859: PPUSH
5860: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
5864: LD_ADDR_VAR 0 2
5868: PUSH
5869: LD_VAR 0 2
5873: PUSH
5874: LD_VAR 0 4
5878: PUSH
5879: LD_INT 4
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: DIFF
5886: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5887: LD_ADDR_VAR 0 3
5891: PUSH
5892: LD_STRING QML2
5894: PPUSH
5895: LD_VAR 0 2
5899: PPUSH
5900: CALL_OW 98
5904: ST_TO_ADDR
// end ; if qr in bad then
5905: LD_VAR 0 3
5909: PUSH
5910: LD_VAR 0 5
5914: IN
5915: IFFALSE 5927
// result := false else
5917: LD_ADDR_VAR 0 1
5921: PUSH
5922: LD_INT 0
5924: ST_TO_ADDR
5925: GO 5935
// result := true ;
5927: LD_ADDR_VAR 0 1
5931: PUSH
5932: LD_INT 1
5934: ST_TO_ADDR
// end ;
5935: LD_VAR 0 1
5939: RET
// function QML3 ; var mozn , qr , a , bad ; begin
5940: LD_INT 0
5942: PPUSH
5943: PPUSH
5944: PPUSH
5945: PPUSH
5946: PPUSH
// bad := [ 1 , 3 ] ;
5947: LD_ADDR_VAR 0 5
5951: PUSH
5952: LD_INT 1
5954: PUSH
5955: LD_INT 3
5957: PUSH
5958: EMPTY
5959: LIST
5960: LIST
5961: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: LD_INT 1
5969: PUSH
5970: LD_INT 2
5972: PUSH
5973: LD_INT 3
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: ST_TO_ADDR
// if IsOk ( Gleb ) then
5981: LD_EXP 50
5985: PPUSH
5986: CALL_OW 302
5990: IFFALSE 6009
// mozn := mozn ^ [ 4 ] ;
5992: LD_ADDR_VAR 0 2
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: LD_INT 4
6004: PUSH
6005: EMPTY
6006: LIST
6007: ADD
6008: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6009: LD_ADDR_VAR 0 3
6013: PUSH
6014: LD_STRING QML3
6016: PPUSH
6017: LD_VAR 0 2
6021: PPUSH
6022: CALL_OW 98
6026: ST_TO_ADDR
// if qr = 4 then
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 4
6034: EQUAL
6035: IFFALSE 6109
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6037: LD_ADDR_VAR 0 4
6041: PUSH
6042: LD_VAR 0 5
6046: PUSH
6047: LD_INT 1
6049: PPUSH
6050: LD_INT 2
6052: PPUSH
6053: CALL_OW 12
6057: ARRAY
6058: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6059: LD_VAR 0 4
6063: PPUSH
6064: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
6068: LD_ADDR_VAR 0 2
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_VAR 0 4
6082: PUSH
6083: LD_INT 4
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: DIFF
6090: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6091: LD_ADDR_VAR 0 3
6095: PUSH
6096: LD_STRING QML3
6098: PPUSH
6099: LD_VAR 0 2
6103: PPUSH
6104: CALL_OW 98
6108: ST_TO_ADDR
// end ; if qr in bad then
6109: LD_VAR 0 3
6113: PUSH
6114: LD_VAR 0 5
6118: IN
6119: IFFALSE 6131
// result := false else
6121: LD_ADDR_VAR 0 1
6125: PUSH
6126: LD_INT 0
6128: ST_TO_ADDR
6129: GO 6139
// result := true ;
6131: LD_ADDR_VAR 0 1
6135: PUSH
6136: LD_INT 1
6138: ST_TO_ADDR
// end ;
6139: LD_VAR 0 1
6143: RET
// function QML4 ; var mozn , qr , a , bad ; begin
6144: LD_INT 0
6146: PPUSH
6147: PPUSH
6148: PPUSH
6149: PPUSH
6150: PPUSH
// bad := [ 1 , 2 ] ;
6151: LD_ADDR_VAR 0 5
6155: PUSH
6156: LD_INT 1
6158: PUSH
6159: LD_INT 2
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6166: LD_ADDR_VAR 0 2
6170: PUSH
6171: LD_INT 1
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 3
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: LIST
6184: ST_TO_ADDR
// if IsOk ( Gleb ) then
6185: LD_EXP 50
6189: PPUSH
6190: CALL_OW 302
6194: IFFALSE 6213
// mozn := mozn ^ [ 4 ] ;
6196: LD_ADDR_VAR 0 2
6200: PUSH
6201: LD_VAR 0 2
6205: PUSH
6206: LD_INT 4
6208: PUSH
6209: EMPTY
6210: LIST
6211: ADD
6212: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6213: LD_ADDR_VAR 0 3
6217: PUSH
6218: LD_STRING QML4
6220: PPUSH
6221: LD_VAR 0 2
6225: PPUSH
6226: CALL_OW 98
6230: ST_TO_ADDR
// if qr = 4 then
6231: LD_VAR 0 3
6235: PUSH
6236: LD_INT 4
6238: EQUAL
6239: IFFALSE 6313
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6241: LD_ADDR_VAR 0 4
6245: PUSH
6246: LD_VAR 0 5
6250: PUSH
6251: LD_INT 1
6253: PPUSH
6254: LD_INT 2
6256: PPUSH
6257: CALL_OW 12
6261: ARRAY
6262: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6263: LD_VAR 0 4
6267: PPUSH
6268: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
6272: LD_ADDR_VAR 0 2
6276: PUSH
6277: LD_VAR 0 2
6281: PUSH
6282: LD_VAR 0 4
6286: PUSH
6287: LD_INT 4
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: DIFF
6294: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6295: LD_ADDR_VAR 0 3
6299: PUSH
6300: LD_STRING QML4
6302: PPUSH
6303: LD_VAR 0 2
6307: PPUSH
6308: CALL_OW 98
6312: ST_TO_ADDR
// end ; if qr in bad then
6313: LD_VAR 0 3
6317: PUSH
6318: LD_VAR 0 5
6322: IN
6323: IFFALSE 6335
// result := false else
6325: LD_ADDR_VAR 0 1
6329: PUSH
6330: LD_INT 0
6332: ST_TO_ADDR
6333: GO 6343
// result := true ;
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: LD_INT 1
6342: ST_TO_ADDR
// end ;
6343: LD_VAR 0 1
6347: RET
// function QML5 ; var mozn , qr , a , bad ; begin
6348: LD_INT 0
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
6354: PPUSH
// bad := [ 1 , 3 ] ;
6355: LD_ADDR_VAR 0 5
6359: PUSH
6360: LD_INT 1
6362: PUSH
6363: LD_INT 3
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6370: LD_ADDR_VAR 0 2
6374: PUSH
6375: LD_INT 1
6377: PUSH
6378: LD_INT 2
6380: PUSH
6381: LD_INT 3
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: ST_TO_ADDR
// if IsOk ( Gleb ) then
6389: LD_EXP 50
6393: PPUSH
6394: CALL_OW 302
6398: IFFALSE 6417
// mozn := mozn ^ [ 4 ] ;
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: LD_VAR 0 2
6409: PUSH
6410: LD_INT 4
6412: PUSH
6413: EMPTY
6414: LIST
6415: ADD
6416: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6417: LD_ADDR_VAR 0 3
6421: PUSH
6422: LD_STRING QML5
6424: PPUSH
6425: LD_VAR 0 2
6429: PPUSH
6430: CALL_OW 98
6434: ST_TO_ADDR
// if qr = 4 then
6435: LD_VAR 0 3
6439: PUSH
6440: LD_INT 4
6442: EQUAL
6443: IFFALSE 6517
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6445: LD_ADDR_VAR 0 4
6449: PUSH
6450: LD_VAR 0 5
6454: PUSH
6455: LD_INT 1
6457: PPUSH
6458: LD_INT 2
6460: PPUSH
6461: CALL_OW 12
6465: ARRAY
6466: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6467: LD_VAR 0 4
6471: PPUSH
6472: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
6476: LD_ADDR_VAR 0 2
6480: PUSH
6481: LD_VAR 0 2
6485: PUSH
6486: LD_VAR 0 4
6490: PUSH
6491: LD_INT 4
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: DIFF
6498: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_STRING QML5
6506: PPUSH
6507: LD_VAR 0 2
6511: PPUSH
6512: CALL_OW 98
6516: ST_TO_ADDR
// end ; if qr in bad then
6517: LD_VAR 0 3
6521: PUSH
6522: LD_VAR 0 5
6526: IN
6527: IFFALSE 6539
// result := false else
6529: LD_ADDR_VAR 0 1
6533: PUSH
6534: LD_INT 0
6536: ST_TO_ADDR
6537: GO 6547
// result := true ;
6539: LD_ADDR_VAR 0 1
6543: PUSH
6544: LD_INT 1
6546: ST_TO_ADDR
// end ;
6547: LD_VAR 0 1
6551: RET
// function QML6 ; var mozn , qr , a , bad ; begin
6552: LD_INT 0
6554: PPUSH
6555: PPUSH
6556: PPUSH
6557: PPUSH
6558: PPUSH
// bad := [ 2 , 3 ] ;
6559: LD_ADDR_VAR 0 5
6563: PUSH
6564: LD_INT 2
6566: PUSH
6567: LD_INT 3
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_INT 1
6581: PUSH
6582: LD_INT 2
6584: PUSH
6585: LD_INT 3
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: LIST
6592: ST_TO_ADDR
// if IsOk ( Gleb ) then
6593: LD_EXP 50
6597: PPUSH
6598: CALL_OW 302
6602: IFFALSE 6621
// mozn := mozn ^ [ 4 ] ;
6604: LD_ADDR_VAR 0 2
6608: PUSH
6609: LD_VAR 0 2
6613: PUSH
6614: LD_INT 4
6616: PUSH
6617: EMPTY
6618: LIST
6619: ADD
6620: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_STRING QML6
6628: PPUSH
6629: LD_VAR 0 2
6633: PPUSH
6634: CALL_OW 98
6638: ST_TO_ADDR
// if qr = 4 then
6639: LD_VAR 0 3
6643: PUSH
6644: LD_INT 4
6646: EQUAL
6647: IFFALSE 6721
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6649: LD_ADDR_VAR 0 4
6653: PUSH
6654: LD_VAR 0 5
6658: PUSH
6659: LD_INT 1
6661: PPUSH
6662: LD_INT 2
6664: PPUSH
6665: CALL_OW 12
6669: ARRAY
6670: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6671: LD_VAR 0 4
6675: PPUSH
6676: CALL 6844 0 1
// mozn := mozn diff [ a , 4 ] ;
6680: LD_ADDR_VAR 0 2
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: LD_VAR 0 4
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: DIFF
6702: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: LD_STRING QML6
6710: PPUSH
6711: LD_VAR 0 2
6715: PPUSH
6716: CALL_OW 98
6720: ST_TO_ADDR
// end ; if qr in bad then
6721: LD_VAR 0 3
6725: PUSH
6726: LD_VAR 0 5
6730: IN
6731: IFFALSE 6743
// result := false else
6733: LD_ADDR_VAR 0 1
6737: PUSH
6738: LD_INT 0
6740: ST_TO_ADDR
6741: GO 6751
// result := true ;
6743: LD_ADDR_VAR 0 1
6747: PUSH
6748: LD_INT 1
6750: ST_TO_ADDR
// end ;
6751: LD_VAR 0 1
6755: RET
// export function DQrML_Right ( first ) ; begin
6756: LD_INT 0
6758: PPUSH
// DialogueOn ;
6759: CALL_OW 6
// Say ( Tsr , DQrML#Right-Tsr-1 ) ;
6763: LD_LOC 7
6767: PPUSH
6768: LD_STRING DQrML#Right-Tsr-1
6770: PPUSH
6771: CALL_OW 88
// if first then
6775: LD_VAR 0 1
6779: IFFALSE 6795
// Say ( Tsr , DQrML#Right-Tsr-1a ) else
6781: LD_LOC 7
6785: PPUSH
6786: LD_STRING DQrML#Right-Tsr-1a
6788: PPUSH
6789: CALL_OW 88
6793: GO 6807
// Say ( Tsr , DQrML#Right-Tsr-1b ) ;
6795: LD_LOC 7
6799: PPUSH
6800: LD_STRING DQrML#Right-Tsr-1b
6802: PPUSH
6803: CALL_OW 88
// DialogueOff ;
6807: CALL_OW 7
// end ;
6811: LD_VAR 0 2
6815: RET
// export function DQrML_Wrong ; begin
6816: LD_INT 0
6818: PPUSH
// DialogueOn ;
6819: CALL_OW 6
// Say ( Tsr , DQrML#Wrong-Tsr-1 ) ;
6823: LD_LOC 7
6827: PPUSH
6828: LD_STRING DQrML#Wrong-Tsr-1
6830: PPUSH
6831: CALL_OW 88
// DialogueOff ;
6835: CALL_OW 7
// end ;
6839: LD_VAR 0 1
6843: RET
// function DQrML_Gleb ( num ) ; begin
6844: LD_INT 0
6846: PPUSH
// DialogueOn ;
6847: CALL_OW 6
// case num of 1 :
6851: LD_VAR 0 1
6855: PUSH
6856: LD_INT 1
6858: DOUBLE
6859: EQUAL
6860: IFTRUE 6864
6862: GO 6879
6864: POP
// Say ( Glb , DQrML#Gleb-Glb-1 ) ; 2 :
6865: LD_LOC 10
6869: PPUSH
6870: LD_STRING DQrML#Gleb-Glb-1
6872: PPUSH
6873: CALL_OW 88
6877: GO 6926
6879: LD_INT 2
6881: DOUBLE
6882: EQUAL
6883: IFTRUE 6887
6885: GO 6902
6887: POP
// Say ( Glb , DQrML#Gleb-Glb-1a ) ; 3 :
6888: LD_LOC 10
6892: PPUSH
6893: LD_STRING DQrML#Gleb-Glb-1a
6895: PPUSH
6896: CALL_OW 88
6900: GO 6926
6902: LD_INT 3
6904: DOUBLE
6905: EQUAL
6906: IFTRUE 6910
6908: GO 6925
6910: POP
// Say ( Glb , DQrML#Gleb-Glb-1b ) ; end ;
6911: LD_LOC 10
6915: PPUSH
6916: LD_STRING DQrML#Gleb-Glb-1b
6918: PPUSH
6919: CALL_OW 88
6923: GO 6926
6925: POP
// DialogueOff ;
6926: CALL_OW 7
// end ;
6930: LD_VAR 0 2
6934: RET
// export maji_artifact ; every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
6935: LD_LOC 2
6939: PPUSH
6940: LD_INT 22
6942: PPUSH
6943: CALL_OW 308
6947: PUSH
6948: LD_EXP 23
6952: PUSH
6953: LD_INT 1
6955: ARRAY
6956: PUSH
6957: LD_EXP 23
6961: PUSH
6962: LD_INT 4
6964: ARRAY
6965: NONEQUAL
6966: AND
6967: IFFALSE 7057
6969: GO 6971
6971: DISABLE
// begin DD_BaseContact ;
6972: CALL 7224 0 0
// if maji_artifact then
6976: LD_EXP 39
6980: IFFALSE 7019
// begin if not ai_s [ 4 ] in your_bases then
6982: LD_EXP 23
6986: PUSH
6987: LD_INT 4
6989: ARRAY
6990: PUSH
6991: LD_EXP 18
6995: IN
6996: NOT
6997: IFFALSE 7017
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
6999: LD_EXP 4
7003: PPUSH
7004: LD_EXP 23
7008: PUSH
7009: LD_INT 4
7011: ARRAY
7012: PPUSH
7013: CALL 30354 0 2
// end else
7017: GO 7054
// begin DD_BaseRefuse1st ;
7019: CALL 7272 0 0
// while IsInArea ( Bur , d_base ) do
7023: LD_LOC 2
7027: PPUSH
7028: LD_INT 22
7030: PPUSH
7031: CALL_OW 308
7035: IFFALSE 7046
// wait ( 0 0$1 ) ;
7037: LD_INT 35
7039: PPUSH
7040: CALL_OW 67
7044: GO 7023
// wait ( 0 0$20 ) ;
7046: LD_INT 700
7048: PPUSH
7049: CALL_OW 67
// enable ;
7053: ENABLE
// end ; enable ( 12 ) ;
7054: LD_INT 12
7056: ENABLE_MARKED
// end ;
7057: END
// every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] marked 12 do
7058: LD_LOC 2
7062: PPUSH
7063: LD_INT 22
7065: PPUSH
7066: CALL_OW 308
7070: PUSH
7071: LD_EXP 23
7075: PUSH
7076: LD_INT 1
7078: ARRAY
7079: PUSH
7080: LD_EXP 23
7084: PUSH
7085: LD_INT 4
7087: ARRAY
7088: NONEQUAL
7089: AND
7090: IFFALSE 7150
7092: GO 7094
7094: DISABLE
// begin if maji_artifact then
7095: LD_EXP 39
7099: IFFALSE 7138
// begin if not ai_s [ 4 ] in your_bases then
7101: LD_EXP 23
7105: PUSH
7106: LD_INT 4
7108: ARRAY
7109: PUSH
7110: LD_EXP 18
7114: IN
7115: NOT
7116: IFFALSE 7136
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7118: LD_EXP 4
7122: PPUSH
7123: LD_EXP 23
7127: PUSH
7128: LD_INT 4
7130: ARRAY
7131: PPUSH
7132: CALL 30354 0 2
// end else
7136: GO 7150
// begin DD_BaseRefuse ;
7138: CALL 7300 0 0
// wait ( 0 0$20 ) ;
7142: LD_INT 700
7144: PPUSH
7145: CALL_OW 67
// enable ;
7149: ENABLE
// end ; end ;
7150: END
// every 0 0$2 trigger humans [ 4 ] <= 4 and ai_s [ 1 ] <> ai_s [ 4 ] do
7151: LD_EXP 76
7155: PUSH
7156: LD_INT 4
7158: ARRAY
7159: PUSH
7160: LD_INT 4
7162: LESSEQUAL
7163: PUSH
7164: LD_EXP 23
7168: PUSH
7169: LD_INT 1
7171: ARRAY
7172: PUSH
7173: LD_EXP 23
7177: PUSH
7178: LD_INT 4
7180: ARRAY
7181: NONEQUAL
7182: AND
7183: IFFALSE 7223
7185: GO 7187
7187: DISABLE
// begin if not ai_s [ 4 ] in your_bases then
7188: LD_EXP 23
7192: PUSH
7193: LD_INT 4
7195: ARRAY
7196: PUSH
7197: LD_EXP 18
7201: IN
7202: NOT
7203: IFFALSE 7223
// SurrenderBase ( t_killbeat , ai_s [ 4 ] ) ;
7205: LD_EXP 6
7209: PPUSH
7210: LD_EXP 23
7214: PUSH
7215: LD_INT 4
7217: ARRAY
7218: PPUSH
7219: CALL 30354 0 2
// end ;
7223: END
// export kecali_o_artefaktu ; export function DD_BaseContact ; begin
7224: LD_INT 0
7226: PPUSH
// DialogueOn ;
7227: CALL_OW 6
// Say ( Dav , DD-BaseContact-Dav-1 ) ;
7231: LD_LOC 8
7235: PPUSH
7236: LD_STRING DD-BaseContact-Dav-1
7238: PPUSH
7239: CALL_OW 88
// Say ( Bur , DD-BaseContact-Bur-1 ) ;
7243: LD_LOC 2
7247: PPUSH
7248: LD_STRING DD-BaseContact-Bur-1
7250: PPUSH
7251: CALL_OW 88
// kecali_o_artefaktu := true ;
7255: LD_ADDR_EXP 40
7259: PUSH
7260: LD_INT 1
7262: ST_TO_ADDR
// DialogueOff ;
7263: CALL_OW 7
// end ;
7267: LD_VAR 0 1
7271: RET
// export function DD_BaseRefuse1st ; begin
7272: LD_INT 0
7274: PPUSH
// DialogueOn ;
7275: CALL_OW 6
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7279: LD_LOC 8
7283: PPUSH
7284: LD_STRING DD-BaseRefuse-Dav-1
7286: PPUSH
7287: CALL_OW 88
// DialogueOff ;
7291: CALL_OW 7
// end ;
7295: LD_VAR 0 1
7299: RET
// export function DD_BaseRefuse ; begin
7300: LD_INT 0
7302: PPUSH
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7303: LD_LOC 8
7307: PPUSH
7308: LD_STRING DD-BaseRefuse-Dav-1
7310: PPUSH
7311: CALL_OW 88
// end ;
7315: LD_VAR 0 1
7319: RET
// export function DD_BaseAccept ( first ) ; begin
7320: LD_INT 0
7322: PPUSH
// DialogueOn ;
7323: CALL_OW 6
// Say ( Dav , DD-BaseAccept-Dav-1 ) ;
7327: LD_LOC 8
7331: PPUSH
7332: LD_STRING DD-BaseAccept-Dav-1
7334: PPUSH
7335: CALL_OW 88
// if first then
7339: LD_VAR 0 1
7343: IFFALSE 7359
// Say ( Dav , DD-BaseAccept-Dav-1a ) else
7345: LD_LOC 8
7349: PPUSH
7350: LD_STRING DD-BaseAccept-Dav-1a
7352: PPUSH
7353: CALL_OW 88
7357: GO 7371
// Say ( Dav , DD-BaseAccept-Dav-1b ) ;
7359: LD_LOC 8
7363: PPUSH
7364: LD_STRING DD-BaseAccept-Dav-1b
7366: PPUSH
7367: CALL_OW 88
// DialogueOff ;
7371: CALL_OW 7
// end ;
7375: LD_VAR 0 2
7379: RET
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] do
7380: LD_LOC 2
7384: PPUSH
7385: LD_INT 21
7387: PPUSH
7388: CALL_OW 308
7392: PUSH
7393: LD_EXP 23
7397: PUSH
7398: LD_INT 1
7400: ARRAY
7401: PUSH
7402: LD_EXP 23
7406: PUSH
7407: LD_INT 5
7409: ARRAY
7410: NONEQUAL
7411: AND
7412: IFFALSE 7523
7414: GO 7416
7416: DISABLE
// begin DE_BaseContact ;
7417: CALL 7785 0 0
// if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7421: LD_EXP 76
7425: PUSH
7426: LD_INT 5
7428: ARRAY
7429: PPUSH
7430: LD_INT 50
7432: PUSH
7433: EMPTY
7434: LIST
7435: PUSH
7436: EMPTY
7437: LIST
7438: PPUSH
7439: CALL_OW 72
7443: PUSH
7444: LD_INT 6
7446: GREATER
7447: IFFALSE 7488
// begin DE_BaseRefuse1st ;
7449: CALL 7825 0 0
// while IsInArea ( Bur , e_base ) do
7453: LD_LOC 2
7457: PPUSH
7458: LD_INT 21
7460: PPUSH
7461: CALL_OW 308
7465: IFFALSE 7476
// wait ( 0 0$1 ) ;
7467: LD_INT 35
7469: PPUSH
7470: CALL_OW 67
7474: GO 7453
// wait ( 0 0$20 ) ;
7476: LD_INT 700
7478: PPUSH
7479: CALL_OW 67
// enable ( 115 ) ;
7483: LD_INT 115
7485: ENABLE_MARKED
// end else
7486: GO 7523
// if not ai_s [ 5 ] in your_bases then
7488: LD_EXP 23
7492: PUSH
7493: LD_INT 5
7495: ARRAY
7496: PUSH
7497: LD_EXP 18
7501: IN
7502: NOT
7503: IFFALSE 7523
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7505: LD_EXP 5
7509: PPUSH
7510: LD_EXP 23
7514: PUSH
7515: LD_INT 5
7517: ARRAY
7518: PPUSH
7519: CALL 30354 0 2
// end ;
7523: END
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] marked 115 do
7524: LD_LOC 2
7528: PPUSH
7529: LD_INT 21
7531: PPUSH
7532: CALL_OW 308
7536: PUSH
7537: LD_EXP 23
7541: PUSH
7542: LD_INT 1
7544: ARRAY
7545: PUSH
7546: LD_EXP 23
7550: PUSH
7551: LD_INT 5
7553: ARRAY
7554: NONEQUAL
7555: AND
7556: IFFALSE 7624
7558: GO 7560
7560: DISABLE
// begin if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7561: LD_EXP 76
7565: PUSH
7566: LD_INT 5
7568: ARRAY
7569: PPUSH
7570: LD_INT 50
7572: PUSH
7573: EMPTY
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: PPUSH
7579: CALL_OW 72
7583: PUSH
7584: LD_INT 6
7586: GREATER
7587: IFFALSE 7623
// begin DE_BaseRefuse ;
7589: CALL 7853 0 0
// while IsInArea ( Bur , e_base ) do
7593: LD_LOC 2
7597: PPUSH
7598: LD_INT 21
7600: PPUSH
7601: CALL_OW 308
7605: IFFALSE 7616
// wait ( 0 0$1 ) ;
7607: LD_INT 35
7609: PPUSH
7610: CALL_OW 67
7614: GO 7593
// wait ( 0 0$20 ) ;
7616: LD_INT 700
7618: PPUSH
7619: CALL_OW 67
// end ; enable ;
7623: ENABLE
// end ;
7624: END
// every 0 0$2 trigger UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) <= 6 and ai_s [ 1 ] <> ai_s [ 5 ] do
7625: LD_EXP 76
7629: PUSH
7630: LD_INT 5
7632: ARRAY
7633: PPUSH
7634: LD_INT 50
7636: PUSH
7637: EMPTY
7638: LIST
7639: PUSH
7640: EMPTY
7641: LIST
7642: PPUSH
7643: CALL_OW 72
7647: PUSH
7648: LD_INT 6
7650: LESSEQUAL
7651: PUSH
7652: LD_EXP 23
7656: PUSH
7657: LD_INT 1
7659: ARRAY
7660: PUSH
7661: LD_EXP 23
7665: PUSH
7666: LD_INT 5
7668: ARRAY
7669: NONEQUAL
7670: AND
7671: IFFALSE 7711
7673: GO 7675
7675: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7676: LD_EXP 23
7680: PUSH
7681: LD_INT 5
7683: ARRAY
7684: PUSH
7685: LD_EXP 18
7689: IN
7690: NOT
7691: IFFALSE 7711
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7693: LD_EXP 5
7697: PPUSH
7698: LD_EXP 23
7702: PUSH
7703: LD_INT 5
7705: ARRAY
7706: PPUSH
7707: CALL 30354 0 2
// end ;
7711: END
// every 0 0$2 trigger humans [ 5 ] <= 4 and ai_s [ 1 ] <> ai_s [ 5 ] do
7712: LD_EXP 76
7716: PUSH
7717: LD_INT 5
7719: ARRAY
7720: PUSH
7721: LD_INT 4
7723: LESSEQUAL
7724: PUSH
7725: LD_EXP 23
7729: PUSH
7730: LD_INT 1
7732: ARRAY
7733: PUSH
7734: LD_EXP 23
7738: PUSH
7739: LD_INT 5
7741: ARRAY
7742: NONEQUAL
7743: AND
7744: IFFALSE 7784
7746: GO 7748
7748: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7749: LD_EXP 23
7753: PUSH
7754: LD_INT 5
7756: ARRAY
7757: PUSH
7758: LD_EXP 18
7762: IN
7763: NOT
7764: IFFALSE 7784
// SurrenderBase ( t_killbeat , ai_s [ 5 ] ) ;
7766: LD_EXP 6
7770: PPUSH
7771: LD_EXP 23
7775: PUSH
7776: LD_INT 5
7778: ARRAY
7779: PPUSH
7780: CALL 30354 0 2
// end ;
7784: END
// export function DE_BaseContact ; begin
7785: LD_INT 0
7787: PPUSH
// DialogueOn ;
7788: CALL_OW 6
// Say ( Eis , DE-BaseContact-Eis-1 ) ;
7792: LD_LOC 9
7796: PPUSH
7797: LD_STRING DE-BaseContact-Eis-1
7799: PPUSH
7800: CALL_OW 88
// Say ( Bur , DE-BaseContact-Bur-1 ) ;
7804: LD_LOC 2
7808: PPUSH
7809: LD_STRING DE-BaseContact-Bur-1
7811: PPUSH
7812: CALL_OW 88
// DialogueOff ;
7816: CALL_OW 7
// end ;
7820: LD_VAR 0 1
7824: RET
// export function DE_BaseRefuse1st ; begin
7825: LD_INT 0
7827: PPUSH
// DialogueOn ;
7828: CALL_OW 6
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7832: LD_LOC 9
7836: PPUSH
7837: LD_STRING DE-BaseRefuse-Eis-1
7839: PPUSH
7840: CALL_OW 88
// DialogueOff ;
7844: CALL_OW 7
// end ;
7848: LD_VAR 0 1
7852: RET
// export function DE_BaseRefuse ; begin
7853: LD_INT 0
7855: PPUSH
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7856: LD_LOC 9
7860: PPUSH
7861: LD_STRING DE-BaseRefuse-Eis-1
7863: PPUSH
7864: CALL_OW 88
// end ;
7868: LD_VAR 0 1
7872: RET
// export function DE_BaseAccept ( first ) ; begin
7873: LD_INT 0
7875: PPUSH
// DialogueOn ;
7876: CALL_OW 6
// Say ( Eis , DE-BaseAccept-Eis-1 ) ;
7880: LD_LOC 9
7884: PPUSH
7885: LD_STRING DE-BaseAccept-Eis-1
7887: PPUSH
7888: CALL_OW 88
// if first then
7892: LD_VAR 0 1
7896: IFFALSE 7912
// Say ( Eis , DE-BaseAccept-Eis-1a ) else
7898: LD_LOC 9
7902: PPUSH
7903: LD_STRING DE-BaseAccept-Eis-1a
7905: PPUSH
7906: CALL_OW 88
7910: GO 7924
// Say ( Eis , DE-BaseAccept-Eis-1b ) ;
7912: LD_LOC 9
7916: PPUSH
7917: LD_STRING DE-BaseAccept-Eis-1b
7919: PPUSH
7920: CALL_OW 88
// DialogueOff ;
7924: CALL_OW 7
// end ;
7928: LD_VAR 0 2
7932: RET
// export function DXbaseSurrender ( side ) ; var who ; begin
7933: LD_INT 0
7935: PPUSH
7936: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , side , sex_male , 0 , 0 ) ;
7937: LD_ADDR_VAR 0 3
7941: PUSH
7942: LD_INT 21
7944: PUSH
7945: LD_INT 1
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 23
7954: PUSH
7955: LD_INT 3
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PPUSH
7966: CALL_OW 69
7970: PUSH
7971: LD_LOC 11
7975: DIFF
7976: PPUSH
7977: LD_VAR 0 1
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: LD_INT 0
7987: PPUSH
7988: LD_INT 0
7990: PPUSH
7991: CALL 10376 0 5
7995: ST_TO_ADDR
// DialogueOn ;
7996: CALL_OW 6
// Say ( who , DXbaseSurrender-Rsol1-1 ) ;
8000: LD_VAR 0 3
8004: PPUSH
8005: LD_STRING DXbaseSurrender-Rsol1-1
8007: PPUSH
8008: CALL_OW 88
// DialogueOff ;
8012: CALL_OW 7
// end ;
8016: LD_VAR 0 2
8020: RET
// export function DRocket ; var who ; begin
8021: LD_INT 0
8023: PPUSH
8024: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , class_scientistic , 0 ) ;
8025: LD_ADDR_VAR 0 2
8029: PUSH
8030: LD_INT 21
8032: PUSH
8033: LD_INT 1
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 23
8042: PUSH
8043: LD_INT 3
8045: PUSH
8046: EMPTY
8047: LIST
8048: LIST
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: PPUSH
8054: CALL_OW 69
8058: PUSH
8059: LD_LOC 11
8063: DIFF
8064: PPUSH
8065: LD_EXP 7
8069: PPUSH
8070: LD_INT 1
8072: PPUSH
8073: LD_INT 4
8075: PPUSH
8076: LD_INT 0
8078: PPUSH
8079: CALL 10376 0 5
8083: ST_TO_ADDR
// TalkOn ;
8084: CALL 10635 0 0
// Say ( who , DRocket-RSci1-1 ) ;
8088: LD_VAR 0 2
8092: PPUSH
8093: LD_STRING DRocket-RSci1-1
8095: PPUSH
8096: CALL_OW 88
// TalkOff ;
8100: CALL 10651 0 0
// end ;
8104: LD_VAR 0 1
8108: RET
// every 0 0$1 trigger cap_bases >= 4 do
8109: LD_EXP 17
8113: PUSH
8114: LD_INT 4
8116: GREATEREQUAL
8117: IFFALSE 8133
8119: GO 8121
8121: DISABLE
// begin QEnd ;
8122: CALL 8134 0 0
// ChangeMissionObjectives ( MDestroy ) ;
8126: LD_STRING MDestroy
8128: PPUSH
8129: CALL_OW 337
// end ;
8133: END
// export function QEnd ; var qr ; begin
8134: LD_INT 0
8136: PPUSH
8137: PPUSH
// qr := Query ( QKill ) ;
8138: LD_ADDR_VAR 0 2
8142: PUSH
8143: LD_STRING QKill
8145: PPUSH
8146: CALL_OW 97
8150: ST_TO_ADDR
// end ;
8151: LD_VAR 0 1
8155: RET
// export function DEnd ; var who ; begin
8156: LD_INT 0
8158: PPUSH
8159: PPUSH
// who := Gla ;
8160: LD_ADDR_VAR 0 2
8164: PUSH
8165: LD_LOC 1
8169: ST_TO_ADDR
// if not IsOk ( Gla ) then
8170: LD_LOC 1
8174: PPUSH
8175: CALL_OW 302
8179: NOT
8180: IFFALSE 8241
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , 0 , 0 ) ;
8182: LD_ADDR_VAR 0 2
8186: PUSH
8187: LD_INT 21
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: PUSH
8197: LD_INT 23
8199: PUSH
8200: LD_INT 3
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 69
8215: PUSH
8216: LD_LOC 11
8220: DIFF
8221: PPUSH
8222: LD_EXP 7
8226: PPUSH
8227: LD_INT 1
8229: PPUSH
8230: LD_INT 0
8232: PPUSH
8233: LD_INT 0
8235: PPUSH
8236: CALL 10376 0 5
8240: ST_TO_ADDR
// DialogueOn ;
8241: CALL_OW 6
// Say ( Bur , DEnd-Bur-1 ) ;
8245: LD_LOC 2
8249: PPUSH
8250: LD_STRING DEnd-Bur-1
8252: PPUSH
8253: CALL_OW 88
// if Say ( who , DEnd-Gla-1 ) then
8257: LD_VAR 0 2
8261: PPUSH
8262: LD_STRING DEnd-Gla-1
8264: PPUSH
8265: CALL_OW 88
8269: IFFALSE 8283
// Say ( Bur , DEnd-Bur-2 ) ;
8271: LD_LOC 2
8275: PPUSH
8276: LD_STRING DEnd-Bur-2
8278: PPUSH
8279: CALL_OW 88
// Say ( Bur , DEnd-Bur-2a ) ;
8283: LD_LOC 2
8287: PPUSH
8288: LD_STRING DEnd-Bur-2a
8290: PPUSH
8291: CALL_OW 88
// DialogueOff ;
8295: CALL_OW 7
// end ; end_of_file
8299: LD_VAR 0 1
8303: RET
// export Burlak , Platonov , Gossudarov , Gladkov , Fadeev , Borodin , Tsaritsyn , Davidov , Eisenstein , Gleb ; var masha_def , masha ; var used ; export function Load ; var i ; begin
8304: LD_INT 0
8306: PPUSH
8307: PPUSH
// Masha := LoadVariable ( Masha , [ ] ) ;
8308: LD_ADDR_LOC 14
8312: PUSH
8313: LD_STRING Masha
8315: PPUSH
8316: EMPTY
8317: PPUSH
8318: CALL_OW 30
8322: ST_TO_ADDR
// InitUc ;
8323: CALL_OW 18
// InitHc ;
8327: CALL_OW 19
// uc_nation := nation_russian ;
8331: LD_ADDR_OWVAR 21
8335: PUSH
8336: LD_INT 3
8338: ST_TO_ADDR
// uc_side := ai_s [ 1 ] ;
8339: LD_ADDR_OWVAR 20
8343: PUSH
8344: LD_EXP 23
8348: PUSH
8349: LD_INT 1
8351: ARRAY
8352: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
8353: LD_ADDR_EXP 42
8357: PUSH
8358: LD_STRING Platonov
8360: PPUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 1
8366: PPUSH
8367: CALL 8968 0 3
8371: ST_TO_ADDR
// Gossudarov := MyCreateCharacter ( Gossudarov , class_scientistic , false ) ;
8372: LD_ADDR_EXP 43
8376: PUSH
8377: LD_STRING Gossudarov
8379: PPUSH
8380: LD_INT 4
8382: PPUSH
8383: LD_INT 0
8385: PPUSH
8386: CALL 8968 0 3
8390: ST_TO_ADDR
// SetSkill ( Gossudarov , skill_mechanical , gossudarov_mech_skill ) ;
8391: LD_EXP 43
8395: PPUSH
8396: LD_INT 3
8398: PPUSH
8399: LD_EXP 16
8403: PPUSH
8404: CALL_OW 237
// uc_side := ai_s [ 2 ] ;
8408: LD_ADDR_OWVAR 20
8412: PUSH
8413: LD_EXP 23
8417: PUSH
8418: LD_INT 2
8420: ARRAY
8421: ST_TO_ADDR
// Borodin := MyCreateCharacter ( Borodin , 0 , true ) ;
8422: LD_ADDR_EXP 46
8426: PUSH
8427: LD_STRING Borodin
8429: PPUSH
8430: LD_INT 0
8432: PPUSH
8433: LD_INT 1
8435: PPUSH
8436: CALL 8968 0 3
8440: ST_TO_ADDR
// uc_side := ai_s [ 3 ] ;
8441: LD_ADDR_OWVAR 20
8445: PUSH
8446: LD_EXP 23
8450: PUSH
8451: LD_INT 3
8453: ARRAY
8454: ST_TO_ADDR
// Tsaritsyn := MyCreateCharacter ( Tsaritsyn , 0 , true ) ;
8455: LD_ADDR_EXP 47
8459: PUSH
8460: LD_STRING Tsaritsyn
8462: PPUSH
8463: LD_INT 0
8465: PPUSH
8466: LD_INT 1
8468: PPUSH
8469: CALL 8968 0 3
8473: ST_TO_ADDR
// uc_side := ai_s [ 4 ] ;
8474: LD_ADDR_OWVAR 20
8478: PUSH
8479: LD_EXP 23
8483: PUSH
8484: LD_INT 4
8486: ARRAY
8487: ST_TO_ADDR
// Davidov := MyCreateCharacter ( Davidov , class_scientistic , true ) ;
8488: LD_ADDR_EXP 48
8492: PUSH
8493: LD_STRING Davidov
8495: PPUSH
8496: LD_INT 4
8498: PPUSH
8499: LD_INT 1
8501: PPUSH
8502: CALL 8968 0 3
8506: ST_TO_ADDR
// uc_side := ai_s [ 5 ] ;
8507: LD_ADDR_OWVAR 20
8511: PUSH
8512: LD_EXP 23
8516: PUSH
8517: LD_INT 5
8519: ARRAY
8520: ST_TO_ADDR
// Eisenstein := MyCreateCharacter ( Eisenstein , 0 , true ) ;
8521: LD_ADDR_EXP 49
8525: PUSH
8526: LD_STRING Eisenstein
8528: PPUSH
8529: LD_INT 0
8531: PPUSH
8532: LD_INT 1
8534: PPUSH
8535: CALL 8968 0 3
8539: ST_TO_ADDR
// uc_side := you ;
8540: LD_ADDR_OWVAR 20
8544: PUSH
8545: LD_EXP 7
8549: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
8550: LD_ADDR_EXP 41
8554: PUSH
8555: LD_STRING Burlak
8557: PPUSH
8558: LD_INT 3
8560: PPUSH
8561: LD_INT 0
8563: PPUSH
8564: CALL 8968 0 3
8568: ST_TO_ADDR
// Gladkov := MyCreateCharacter ( Gladkov , 0 , true ) ;
8569: LD_ADDR_EXP 44
8573: PUSH
8574: LD_STRING Gladkov
8576: PPUSH
8577: LD_INT 0
8579: PPUSH
8580: LD_INT 1
8582: PPUSH
8583: CALL 8968 0 3
8587: ST_TO_ADDR
// Fadeev := MyCreateCharacter ( Fadeev , 0 , true ) ;
8588: LD_ADDR_EXP 45
8592: PUSH
8593: LD_STRING Fadeev
8595: PPUSH
8596: LD_INT 0
8598: PPUSH
8599: LD_INT 1
8601: PPUSH
8602: CALL 8968 0 3
8606: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , false ) ;
8607: LD_ADDR_EXP 50
8611: PUSH
8612: LD_STRING Gleb
8614: PPUSH
8615: LD_INT 1
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL 8968 0 3
8625: ST_TO_ADDR
// masha_def := LoadVariable ( Masha , [ ] ) ;
8626: LD_ADDR_LOC 13
8630: PUSH
8631: LD_STRING Masha
8633: PPUSH
8634: EMPTY
8635: PPUSH
8636: CALL_OW 30
8640: ST_TO_ADDR
// if masha_def then
8641: LD_LOC 13
8645: IFFALSE 8717
// begin InitVc ;
8647: CALL_OW 20
// vc_chassis := masha_def [ 1 ] ;
8651: LD_ADDR_OWVAR 37
8655: PUSH
8656: LD_LOC 13
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: ST_TO_ADDR
// vc_engine := masha_def [ 2 ] ;
8665: LD_ADDR_OWVAR 39
8669: PUSH
8670: LD_LOC 13
8674: PUSH
8675: LD_INT 2
8677: ARRAY
8678: ST_TO_ADDR
// vc_control := masha_def [ 3 ] ;
8679: LD_ADDR_OWVAR 38
8683: PUSH
8684: LD_LOC 13
8688: PUSH
8689: LD_INT 3
8691: ARRAY
8692: ST_TO_ADDR
// vc_weapon := masha_def [ 4 ] ;
8693: LD_ADDR_OWVAR 40
8697: PUSH
8698: LD_LOC 13
8702: PUSH
8703: LD_INT 4
8705: ARRAY
8706: ST_TO_ADDR
// masha := CreateVehicle ;
8707: LD_ADDR_LOC 14
8711: PUSH
8712: CALL_OW 45
8716: ST_TO_ADDR
// end ; used := [ ] ;
8717: LD_ADDR_LOC 15
8721: PUSH
8722: EMPTY
8723: ST_TO_ADDR
// used := [ Gleb ] diff 0 ;
8724: LD_ADDR_LOC 15
8728: PUSH
8729: LD_EXP 50
8733: PUSH
8734: EMPTY
8735: LIST
8736: PUSH
8737: LD_INT 0
8739: DIFF
8740: ST_TO_ADDR
// used := used ^ [ Fadeev , Gladkov ] ;
8741: LD_ADDR_LOC 15
8745: PUSH
8746: LD_LOC 15
8750: PUSH
8751: LD_EXP 45
8755: PUSH
8756: LD_EXP 44
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: ADD
8765: ST_TO_ADDR
// for i := used + 1 to 3 do
8766: LD_ADDR_VAR 0 2
8770: PUSH
8771: DOUBLE
8772: LD_LOC 15
8776: PUSH
8777: LD_INT 1
8779: PLUS
8780: DEC
8781: ST_TO_ADDR
8782: LD_INT 3
8784: PUSH
8785: FOR_TO
8786: IFFALSE 8819
// begin PrepareSoldier ( sex_male , 6 ) ;
8788: LD_INT 1
8790: PPUSH
8791: LD_INT 6
8793: PPUSH
8794: CALL_OW 381
// used := used ^ [ CreateHuman ] ;
8798: LD_ADDR_LOC 15
8802: PUSH
8803: LD_LOC 15
8807: PUSH
8808: CALL_OW 44
8812: PUSH
8813: EMPTY
8814: LIST
8815: ADD
8816: ST_TO_ADDR
// end ;
8817: GO 8785
8819: POP
8820: POP
// used := used ^ [ Burlak ] ;
8821: LD_ADDR_LOC 15
8825: PUSH
8826: LD_LOC 15
8830: PUSH
8831: LD_EXP 41
8835: PUSH
8836: EMPTY
8837: LIST
8838: ADD
8839: ST_TO_ADDR
// end ;
8840: LD_VAR 0 1
8844: RET
// export function place_ru ; var i ; begin
8845: LD_INT 0
8847: PPUSH
8848: PPUSH
// for i in used diff burlak do
8849: LD_ADDR_VAR 0 2
8853: PUSH
8854: LD_LOC 15
8858: PUSH
8859: LD_EXP 41
8863: DIFF
8864: PUSH
8865: FOR_IN
8866: IFFALSE 8885
// PlaceUnitArea ( i , ru_place , false ) ;
8868: LD_VAR 0 2
8872: PPUSH
8873: LD_INT 6
8875: PPUSH
8876: LD_INT 0
8878: PPUSH
8879: CALL_OW 49
8883: GO 8865
8885: POP
8886: POP
// if masha then
8887: LD_LOC 14
8891: IFFALSE 8948
// begin SetMark ( masha , 1 ) ;
8893: LD_LOC 14
8897: PPUSH
8898: LD_INT 1
8900: PPUSH
8901: CALL_OW 242
// PlaceHumanInUnit ( Burlak , masha ) ;
8905: LD_EXP 41
8909: PPUSH
8910: LD_LOC 14
8914: PPUSH
8915: CALL_OW 52
// PlaceUnitArea ( masha , ru_place , false ) ;
8919: LD_LOC 14
8923: PPUSH
8924: LD_INT 6
8926: PPUSH
8927: LD_INT 0
8929: PPUSH
8930: CALL_OW 49
// SetMark ( masha , 1 ) ;
8934: LD_LOC 14
8938: PPUSH
8939: LD_INT 1
8941: PPUSH
8942: CALL_OW 242
// end else
8946: GO 8963
// PlaceUnitArea ( Burlak , ru_place , false ) ;
8948: LD_EXP 41
8952: PPUSH
8953: LD_INT 6
8955: PPUSH
8956: LD_INT 0
8958: PPUSH
8959: CALL_OW 49
// end ;
8963: LD_VAR 0 1
8967: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
8968: LD_INT 0
8970: PPUSH
// if ( new and NewCharacter ( name ) ) or TestCharacters ( name ) then
8971: LD_VAR 0 3
8975: PUSH
8976: LD_VAR 0 1
8980: PPUSH
8981: CALL_OW 25
8985: AND
8986: PUSH
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 28
8996: OR
8997: IFFALSE 9080
// begin if new then
8999: LD_VAR 0 3
9003: IFFALSE 9022
// result := NewCharacter ( name ) else
9005: LD_ADDR_VAR 0 4
9009: PUSH
9010: LD_VAR 0 1
9014: PPUSH
9015: CALL_OW 25
9019: ST_TO_ADDR
9020: GO 9058
// begin if CheckCharacterSet ( name ) then
9022: LD_VAR 0 1
9026: PPUSH
9027: CALL_OW 29
9031: IFFALSE 9050
// result := CreateCharacter ( name ) else
9033: LD_ADDR_VAR 0 4
9037: PUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 34
9047: ST_TO_ADDR
9048: GO 9058
// result := 0 ;
9050: LD_ADDR_VAR 0 4
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// end ; if unclass then
9058: LD_VAR 0 2
9062: IFFALSE 9078
// SetClass ( result , unclass ) ;
9064: LD_VAR 0 4
9068: PPUSH
9069: LD_VAR 0 2
9073: PPUSH
9074: CALL_OW 336
// end else
9078: GO 9146
// begin Msg ( Chybi  & name & ! ) ;
9080: LD_STRING Chybi 
9082: PUSH
9083: LD_VAR 0 1
9087: STR
9088: PUSH
9089: LD_STRING !
9091: STR
9092: PPUSH
9093: CALL_OW 100
// hc_name := name ;
9097: LD_ADDR_OWVAR 26
9101: PUSH
9102: LD_VAR 0 1
9106: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
9107: LD_INT 1
9109: PPUSH
9110: LD_INT 0
9112: PPUSH
9113: LD_INT 3
9115: PPUSH
9116: CALL_OW 380
// if unclass then
9120: LD_VAR 0 2
9124: IFFALSE 9136
// hc_class := unclass ;
9126: LD_ADDR_OWVAR 28
9130: PUSH
9131: LD_VAR 0 2
9135: ST_TO_ADDR
// result := CreateHuman ;
9136: LD_ADDR_VAR 0 4
9140: PUSH
9141: CALL_OW 44
9145: ST_TO_ADDR
// end ; end ;
9146: LD_VAR 0 4
9150: RET
// export function Save ; var tmp , Bluekher , t ; begin
9151: LD_INT 0
9153: PPUSH
9154: PPUSH
9155: PPUSH
9156: PPUSH
// SaveCharacters ( Burlak , Burlak ) ;
9157: LD_EXP 41
9161: PPUSH
9162: LD_STRING Burlak
9164: PPUSH
9165: CALL_OW 38
// SaveCharacters ( Gladkov , Gladkov ) ;
9169: LD_EXP 44
9173: PPUSH
9174: LD_STRING Gladkov
9176: PPUSH
9177: CALL_OW 38
// SaveCharacters ( Fadeev , Fadeev ) ;
9181: LD_EXP 45
9185: PPUSH
9186: LD_STRING Fadeev
9188: PPUSH
9189: CALL_OW 38
// DeleteCharacters ( Platonov ) ;
9193: LD_STRING Platonov
9195: PPUSH
9196: CALL_OW 40
// SaveVariable ( not IsLive ( Platonov ) , PlatonovKilled ) ;
9200: LD_EXP 42
9204: PPUSH
9205: CALL_OW 300
9209: NOT
9210: PPUSH
9211: LD_STRING PlatonovKilled
9213: PPUSH
9214: CALL_OW 39
// SaveVariable ( BehemothSeen , BehemothSeen ) ;
9218: LD_EXP 29
9222: PPUSH
9223: LD_STRING BehemothSeen
9225: PPUSH
9226: CALL_OW 39
// if IsDead ( masha ) then
9230: LD_LOC 14
9234: PPUSH
9235: CALL_OW 301
9239: IFFALSE 9248
// DeleteVariable ( Masha ) ;
9241: LD_STRING Masha
9243: PPUSH
9244: CALL_OW 41
// SaveCharacters ( Borodin , Borodin ) ;
9248: LD_EXP 46
9252: PPUSH
9253: LD_STRING Borodin
9255: PPUSH
9256: CALL_OW 38
// SaveCharacters ( Tsaritsyn , Tsaritsyn ) ;
9260: LD_EXP 47
9264: PPUSH
9265: LD_STRING Tsaritsyn
9267: PPUSH
9268: CALL_OW 38
// SaveCharacters ( Davidov , Davidov ) ;
9272: LD_EXP 48
9276: PPUSH
9277: LD_STRING Davidov
9279: PPUSH
9280: CALL_OW 38
// SaveCharacters ( Eisenstein , Eisenstein ) ;
9284: LD_EXP 49
9288: PPUSH
9289: LD_STRING Eisenstein
9291: PPUSH
9292: CALL_OW 38
// if Gleb then
9296: LD_EXP 50
9300: IFFALSE 9314
// SaveCharacters ( Gleb , Gleb ) ;
9302: LD_EXP 50
9306: PPUSH
9307: LD_STRING Gleb
9309: PPUSH
9310: CALL_OW 38
// DeleteCharacters ( Gossudarov ) ;
9314: LD_STRING Gossudarov
9316: PPUSH
9317: CALL_OW 40
// tmp := FilterUnitsInArea ( Bluekher_area , [ [ f_type , unit_building ] ] ) ;
9321: LD_ADDR_VAR 0 2
9325: PUSH
9326: LD_INT 18
9328: PPUSH
9329: LD_INT 21
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: EMPTY
9336: LIST
9337: LIST
9338: PUSH
9339: EMPTY
9340: LIST
9341: PPUSH
9342: CALL_OW 70
9346: ST_TO_ADDR
// Bluekher := [ ] ;
9347: LD_ADDR_VAR 0 3
9351: PUSH
9352: EMPTY
9353: ST_TO_ADDR
// for t in tmp do
9354: LD_ADDR_VAR 0 4
9358: PUSH
9359: LD_VAR 0 2
9363: PUSH
9364: FOR_IN
9365: IFFALSE 9752
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
9367: LD_VAR 0 4
9371: PPUSH
9372: CALL_OW 266
9376: PUSH
9377: LD_INT 9
9379: DOUBLE
9380: EQUAL
9381: IFTRUE 9421
9383: LD_INT 10
9385: DOUBLE
9386: EQUAL
9387: IFTRUE 9421
9389: LD_INT 13
9391: DOUBLE
9392: EQUAL
9393: IFTRUE 9421
9395: LD_INT 12
9397: DOUBLE
9398: EQUAL
9399: IFTRUE 9421
9401: LD_INT 15
9403: DOUBLE
9404: EQUAL
9405: IFTRUE 9421
9407: LD_INT 11
9409: DOUBLE
9410: EQUAL
9411: IFTRUE 9421
9413: LD_INT 14
9415: DOUBLE
9416: EQUAL
9417: IFTRUE 9421
9419: GO 9424
9421: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
9422: GO 9750
9424: LD_INT 6
9426: DOUBLE
9427: EQUAL
9428: IFTRUE 9444
9430: LD_INT 7
9432: DOUBLE
9433: EQUAL
9434: IFTRUE 9444
9436: LD_INT 8
9438: DOUBLE
9439: EQUAL
9440: IFTRUE 9444
9442: GO 9557
9444: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , getlabkind ( t , 1 ) , getlabkind ( t , 2 ) ] ] ; b_bunker , b_turret :
9445: LD_ADDR_VAR 0 3
9449: PUSH
9450: LD_VAR 0 3
9454: PUSH
9455: LD_VAR 0 4
9459: PPUSH
9460: CALL_OW 250
9464: PUSH
9465: LD_VAR 0 4
9469: PPUSH
9470: CALL_OW 251
9474: PUSH
9475: LD_VAR 0 4
9479: PPUSH
9480: CALL_OW 254
9484: PUSH
9485: LD_VAR 0 4
9489: PPUSH
9490: CALL_OW 266
9494: PUSH
9495: LD_VAR 0 4
9499: PPUSH
9500: CALL_OW 267
9504: PUSH
9505: LD_VAR 0 4
9509: PPUSH
9510: CALL_OW 248
9514: PUSH
9515: LD_VAR 0 4
9519: PPUSH
9520: LD_INT 1
9522: PPUSH
9523: CALL_OW 268
9527: PUSH
9528: LD_VAR 0 4
9532: PPUSH
9533: LD_INT 2
9535: PPUSH
9536: CALL_OW 268
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: LIST
9550: PUSH
9551: EMPTY
9552: LIST
9553: ADD
9554: ST_TO_ADDR
9555: GO 9750
9557: LD_INT 32
9559: DOUBLE
9560: EQUAL
9561: IFTRUE 9571
9563: LD_INT 33
9565: DOUBLE
9566: EQUAL
9567: IFTRUE 9571
9569: GO 9667
9571: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , GetWeapon ( t ) ] ] ; else
9572: LD_ADDR_VAR 0 3
9576: PUSH
9577: LD_VAR 0 3
9581: PUSH
9582: LD_VAR 0 4
9586: PPUSH
9587: CALL_OW 250
9591: PUSH
9592: LD_VAR 0 4
9596: PPUSH
9597: CALL_OW 251
9601: PUSH
9602: LD_VAR 0 4
9606: PPUSH
9607: CALL_OW 254
9611: PUSH
9612: LD_VAR 0 4
9616: PPUSH
9617: CALL_OW 266
9621: PUSH
9622: LD_VAR 0 4
9626: PPUSH
9627: CALL_OW 267
9631: PUSH
9632: LD_VAR 0 4
9636: PPUSH
9637: CALL_OW 248
9641: PUSH
9642: LD_VAR 0 4
9646: PPUSH
9647: CALL_OW 264
9651: PUSH
9652: EMPTY
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: EMPTY
9662: LIST
9663: ADD
9664: ST_TO_ADDR
9665: GO 9750
9667: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) ] ] ; end ;
9668: LD_ADDR_VAR 0 3
9672: PUSH
9673: LD_VAR 0 3
9677: PUSH
9678: LD_VAR 0 4
9682: PPUSH
9683: CALL_OW 250
9687: PUSH
9688: LD_VAR 0 4
9692: PPUSH
9693: CALL_OW 251
9697: PUSH
9698: LD_VAR 0 4
9702: PPUSH
9703: CALL_OW 254
9707: PUSH
9708: LD_VAR 0 4
9712: PPUSH
9713: CALL_OW 266
9717: PUSH
9718: LD_VAR 0 4
9722: PPUSH
9723: CALL_OW 267
9727: PUSH
9728: LD_VAR 0 4
9732: PPUSH
9733: CALL_OW 248
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: LIST
9744: LIST
9745: PUSH
9746: EMPTY
9747: LIST
9748: ADD
9749: ST_TO_ADDR
// end ;
9750: GO 9364
9752: POP
9753: POP
// SaveVariable ( Bluekher , Bluekher ) ;
9754: LD_VAR 0 3
9758: PPUSH
9759: LD_STRING Bluekher
9761: PPUSH
9762: CALL_OW 39
// if CheckCharacterSet ( survivors3 ) then
9766: LD_STRING survivors3
9768: PPUSH
9769: CALL_OW 29
9773: IFFALSE 9800
// begin tmp = CreateCharacterSet ( survivors3 ) ;
9775: LD_ADDR_VAR 0 2
9779: PUSH
9780: LD_STRING survivors3
9782: PPUSH
9783: CALL_OW 31
9787: ST_TO_ADDR
// SaveCharacters ( tmp , survivors4 ) ;
9788: LD_VAR 0 2
9792: PPUSH
9793: LD_STRING survivors4
9795: PPUSH
9796: CALL_OW 38
// end ; end ; end_of_file
9800: LD_VAR 0 1
9804: RET
// export mf_sol ; export mf_eng ; export mf_mec ; export mf_sci ; export mf_lab ; export mf_fort ; export mf_bunk ; export mf_dep ; export mf_fact ; export mf_comp ; export mf_manu ; export function inicializace_functions ; begin
9805: LD_INT 0
9807: PPUSH
// mf_sol := [ f_class , class_soldier ] ;
9808: LD_ADDR_EXP 51
9812: PUSH
9813: LD_INT 25
9815: PUSH
9816: LD_INT 1
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: ST_TO_ADDR
// mf_eng := [ f_class , class_engineer ] ;
9823: LD_ADDR_EXP 52
9827: PUSH
9828: LD_INT 25
9830: PUSH
9831: LD_INT 2
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: ST_TO_ADDR
// mf_mec := [ f_class , class_mechanic ] ;
9838: LD_ADDR_EXP 53
9842: PUSH
9843: LD_INT 25
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: ST_TO_ADDR
// mf_sci := [ f_class , class_scientistic ] ;
9853: LD_ADDR_EXP 54
9857: PUSH
9858: LD_INT 25
9860: PUSH
9861: LD_INT 4
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: ST_TO_ADDR
// mf_lab := [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ;
9868: LD_ADDR_EXP 55
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: LD_INT 30
9878: PUSH
9879: LD_INT 6
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PUSH
9886: LD_INT 30
9888: PUSH
9889: LD_INT 7
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: PUSH
9896: LD_INT 30
9898: PUSH
9899: LD_INT 8
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: ST_TO_ADDR
// mf_fort := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ;
9912: LD_ADDR_EXP 56
9916: PUSH
9917: LD_INT 2
9919: PUSH
9920: LD_INT 30
9922: PUSH
9923: LD_INT 32
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: PUSH
9930: LD_INT 30
9932: PUSH
9933: LD_INT 31
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: PUSH
9940: LD_INT 30
9942: PUSH
9943: LD_INT 4
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PUSH
9950: LD_INT 30
9952: PUSH
9953: LD_INT 5
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: ST_TO_ADDR
// mf_bunk := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ;
9967: LD_ADDR_EXP 57
9971: PUSH
9972: LD_INT 2
9974: PUSH
9975: LD_INT 30
9977: PUSH
9978: LD_INT 32
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: LD_INT 30
9987: PUSH
9988: LD_INT 31
9990: PUSH
9991: EMPTY
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: LIST
9999: ST_TO_ADDR
// mf_dep := [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ;
10000: LD_ADDR_EXP 58
10004: PUSH
10005: LD_INT 2
10007: PUSH
10008: LD_INT 30
10010: PUSH
10011: LD_INT 0
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PUSH
10018: LD_INT 30
10020: PUSH
10021: LD_INT 1
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: LIST
10032: ST_TO_ADDR
// mf_fact := [ f_or , [ f_btype , b_factory ] , [ f_btype , b_workshop ] ] ;
10033: LD_ADDR_EXP 59
10037: PUSH
10038: LD_INT 2
10040: PUSH
10041: LD_INT 30
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: LD_INT 30
10053: PUSH
10054: LD_INT 2
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: ST_TO_ADDR
// mf_comp := [ f_control , control_computer ] ;
10066: LD_ADDR_EXP 60
10070: PUSH
10071: LD_INT 33
10073: PUSH
10074: LD_INT 3
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// mf_manu := [ f_control , control_manual ] ;
10081: LD_ADDR_EXP 61
10085: PUSH
10086: LD_INT 33
10088: PUSH
10089: LD_INT 1
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: ST_TO_ADDR
// end ;
10096: LD_VAR 0 1
10100: RET
// export function get_x_best ( lidi , num , skill , mclass , idle ) ; var i , skills ; begin
10101: LD_INT 0
10103: PPUSH
10104: PPUSH
10105: PPUSH
// if mclass then
10106: LD_VAR 0 4
10110: IFFALSE 10142
// lidi := UnitFilter ( lidi , [ [ f_class , mclass ] ] ) ;
10112: LD_ADDR_VAR 0 1
10116: PUSH
10117: LD_VAR 0 1
10121: PPUSH
10122: LD_INT 25
10124: PUSH
10125: LD_VAR 0 4
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PUSH
10134: EMPTY
10135: LIST
10136: PPUSH
10137: CALL_OW 72
10141: ST_TO_ADDR
// skills := [ ] ;
10142: LD_ADDR_VAR 0 8
10146: PUSH
10147: EMPTY
10148: ST_TO_ADDR
// for i in lidi do
10149: LD_ADDR_VAR 0 7
10153: PUSH
10154: LD_VAR 0 1
10158: PUSH
10159: FOR_IN
10160: IFFALSE 10193
// skills := skills ^ [ GetSkill ( i , skill ) ] ;
10162: LD_ADDR_VAR 0 8
10166: PUSH
10167: LD_VAR 0 8
10171: PUSH
10172: LD_VAR 0 7
10176: PPUSH
10177: LD_VAR 0 3
10181: PPUSH
10182: CALL_OW 259
10186: PUSH
10187: EMPTY
10188: LIST
10189: ADD
10190: ST_TO_ADDR
10191: GO 10159
10193: POP
10194: POP
// lidi := SortListByListDesc ( lidi , skills ) ;
10195: LD_ADDR_VAR 0 1
10199: PUSH
10200: LD_VAR 0 1
10204: PPUSH
10205: LD_VAR 0 8
10209: PPUSH
10210: CALL_OW 77
10214: ST_TO_ADDR
// if num > lidi then
10215: LD_VAR 0 2
10219: PUSH
10220: LD_VAR 0 1
10224: GREATER
10225: IFFALSE 10241
// num := lidi + 0 ;
10227: LD_ADDR_VAR 0 2
10231: PUSH
10232: LD_VAR 0 1
10236: PUSH
10237: LD_INT 0
10239: PLUS
10240: ST_TO_ADDR
// i := 1 ;
10241: LD_ADDR_VAR 0 7
10245: PUSH
10246: LD_INT 1
10248: ST_TO_ADDR
// result := [ ] ;
10249: LD_ADDR_VAR 0 6
10253: PUSH
10254: EMPTY
10255: ST_TO_ADDR
// while i <= lidi and result < num do
10256: LD_VAR 0 7
10260: PUSH
10261: LD_VAR 0 1
10265: LESSEQUAL
10266: PUSH
10267: LD_VAR 0 6
10271: PUSH
10272: LD_VAR 0 2
10276: LESS
10277: AND
10278: IFFALSE 10371
// begin if idle then
10280: LD_VAR 0 5
10284: IFFALSE 10330
// begin if IsIdle ( lidi [ i ] ) then
10286: LD_VAR 0 1
10290: PUSH
10291: LD_VAR 0 7
10295: ARRAY
10296: PPUSH
10297: CALL_OW 316
10301: IFFALSE 10328
// result := result ^ [ lidi [ i ] ] ;
10303: LD_ADDR_VAR 0 6
10307: PUSH
10308: LD_VAR 0 6
10312: PUSH
10313: LD_VAR 0 1
10317: PUSH
10318: LD_VAR 0 7
10322: ARRAY
10323: PUSH
10324: EMPTY
10325: LIST
10326: ADD
10327: ST_TO_ADDR
// end else
10328: GO 10355
// result := result ^ [ lidi [ i ] ] ;
10330: LD_ADDR_VAR 0 6
10334: PUSH
10335: LD_VAR 0 6
10339: PUSH
10340: LD_VAR 0 1
10344: PUSH
10345: LD_VAR 0 7
10349: ARRAY
10350: PUSH
10351: EMPTY
10352: LIST
10353: ADD
10354: ST_TO_ADDR
// i := i + 1 ;
10355: LD_ADDR_VAR 0 7
10359: PUSH
10360: LD_VAR 0 7
10364: PUSH
10365: LD_INT 1
10367: PLUS
10368: ST_TO_ADDR
// end ;
10369: GO 10256
// end ;
10371: LD_VAR 0 6
10375: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
10376: LD_INT 0
10378: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
10379: LD_ADDR_VAR 0 1
10383: PUSH
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 21
10391: PUSH
10392: LD_INT 1
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PUSH
10399: LD_INT 22
10401: PUSH
10402: LD_VAR 0 2
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 23
10416: PUSH
10417: LD_INT 0
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL_OW 72
10434: ST_TO_ADDR
// if sex <> 0 then
10435: LD_VAR 0 3
10439: PUSH
10440: LD_INT 0
10442: NONEQUAL
10443: IFFALSE 10472
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
10445: LD_ADDR_VAR 0 1
10449: PUSH
10450: LD_VAR 0 1
10454: PPUSH
10455: LD_INT 26
10457: PUSH
10458: LD_VAR 0 3
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: PPUSH
10467: CALL_OW 72
10471: ST_TO_ADDR
// if Hclass <> 0 then
10472: LD_VAR 0 4
10476: PUSH
10477: LD_INT 0
10479: NONEQUAL
10480: IFFALSE 10509
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
10482: LD_ADDR_VAR 0 1
10486: PUSH
10487: LD_VAR 0 1
10491: PPUSH
10492: LD_INT 25
10494: PUSH
10495: LD_VAR 0 4
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PPUSH
10504: CALL_OW 72
10508: ST_TO_ADDR
// if index <= 0 then
10509: LD_VAR 0 5
10513: PUSH
10514: LD_INT 0
10516: LESSEQUAL
10517: IFFALSE 10527
// index := 1 ;
10519: LD_ADDR_VAR 0 5
10523: PUSH
10524: LD_INT 1
10526: ST_TO_ADDR
// if lidi >= index then
10527: LD_VAR 0 1
10531: PUSH
10532: LD_VAR 0 5
10536: GREATEREQUAL
10537: IFFALSE 10557
// result := lidi [ index ] else
10539: LD_ADDR_VAR 0 6
10543: PUSH
10544: LD_VAR 0 1
10548: PUSH
10549: LD_VAR 0 5
10553: ARRAY
10554: ST_TO_ADDR
10555: GO 10565
// result := 0 ;
10557: LD_ADDR_VAR 0 6
10561: PUSH
10562: LD_INT 0
10564: ST_TO_ADDR
// end ;
10565: LD_VAR 0 6
10569: RET
// export function see_any ( strana , sez ) ; var i ; begin
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// result := [ ] ;
10574: LD_ADDR_VAR 0 3
10578: PUSH
10579: EMPTY
10580: ST_TO_ADDR
// for i in sez do
10581: LD_ADDR_VAR 0 4
10585: PUSH
10586: LD_VAR 0 2
10590: PUSH
10591: FOR_IN
10592: IFFALSE 10628
// if See ( strana , i ) then
10594: LD_VAR 0 1
10598: PPUSH
10599: LD_VAR 0 4
10603: PPUSH
10604: CALL_OW 292
10608: IFFALSE 10626
// begin result := result ^ i ;
10610: LD_ADDR_VAR 0 3
10614: PUSH
10615: LD_VAR 0 3
10619: PUSH
10620: LD_VAR 0 4
10624: ADD
10625: ST_TO_ADDR
// end ;
10626: GO 10591
10628: POP
10629: POP
// ; end ;
10630: LD_VAR 0 3
10634: RET
// export function TalkOn ; begin
10635: LD_INT 0
10637: PPUSH
// stop_talking := true ;
10638: LD_ADDR_OWVAR 56
10642: PUSH
10643: LD_INT 1
10645: ST_TO_ADDR
// end ;
10646: LD_VAR 0 1
10650: RET
// export function TalkOff ; begin
10651: LD_INT 0
10653: PPUSH
// stop_talking := false ;
10654: LD_ADDR_OWVAR 56
10658: PUSH
10659: LD_INT 0
10661: ST_TO_ADDR
// end ;
10662: LD_VAR 0 1
10666: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
10667: LD_INT 0
10669: PPUSH
10670: PPUSH
10671: PPUSH
// result := [ ] ;
10672: LD_ADDR_VAR 0 3
10676: PUSH
10677: EMPTY
10678: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ f_side , you ] ) ;
10679: LD_ADDR_VAR 0 4
10683: PUSH
10684: LD_VAR 0 1
10688: PPUSH
10689: LD_INT 22
10691: PUSH
10692: LD_EXP 7
10696: PUSH
10697: EMPTY
10698: LIST
10699: LIST
10700: PPUSH
10701: CALL_OW 70
10705: ST_TO_ADDR
// for i in inbase do
10706: LD_ADDR_VAR 0 5
10710: PUSH
10711: LD_VAR 0 4
10715: PUSH
10716: FOR_IN
10717: IFFALSE 10790
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
10719: LD_VAR 0 5
10723: PPUSH
10724: CALL_OW 247
10728: PUSH
10729: LD_INT 3
10731: EQUAL
10732: PUSH
10733: LD_VAR 0 5
10737: PPUSH
10738: CALL_OW 247
10742: PUSH
10743: LD_INT 2
10745: EQUAL
10746: OR
10747: IFFALSE 10772
// begin result := result ^ UnitsInside ( i ) ;
10749: LD_ADDR_VAR 0 3
10753: PUSH
10754: LD_VAR 0 3
10758: PUSH
10759: LD_VAR 0 5
10763: PPUSH
10764: CALL_OW 313
10768: ADD
10769: ST_TO_ADDR
// end else
10770: GO 10788
// begin result := result ^ i ;
10772: LD_ADDR_VAR 0 3
10776: PUSH
10777: LD_VAR 0 3
10781: PUSH
10782: LD_VAR 0 5
10786: ADD
10787: ST_TO_ADDR
// end ; end ;
10788: GO 10716
10790: POP
10791: POP
// result := UnitFilter ( result , filter ) ;
10792: LD_ADDR_VAR 0 3
10796: PUSH
10797: LD_VAR 0 3
10801: PPUSH
10802: LD_VAR 0 2
10806: PPUSH
10807: CALL_OW 72
10811: ST_TO_ADDR
// end ;
10812: LD_VAR 0 3
10816: RET
// export function inside_units ( uns ) ; var i ; begin
10817: LD_INT 0
10819: PPUSH
10820: PPUSH
// result := [ ] ;
10821: LD_ADDR_VAR 0 2
10825: PUSH
10826: EMPTY
10827: ST_TO_ADDR
// for i in uns do
10828: LD_ADDR_VAR 0 3
10832: PUSH
10833: LD_VAR 0 1
10837: PUSH
10838: FOR_IN
10839: IFFALSE 10864
// result := result ^ UnitsInside ( i ) ;
10841: LD_ADDR_VAR 0 2
10845: PUSH
10846: LD_VAR 0 2
10850: PUSH
10851: LD_VAR 0 3
10855: PPUSH
10856: CALL_OW 313
10860: ADD
10861: ST_TO_ADDR
10862: GO 10838
10864: POP
10865: POP
// end ;
10866: LD_VAR 0 2
10870: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
10871: LD_INT 0
10873: PPUSH
10874: PPUSH
10875: PPUSH
10876: PPUSH
10877: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
10878: LD_ADDR_VAR 0 1
10882: PUSH
10883: LD_VAR 0 1
10887: PPUSH
10888: LD_INT 51
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL_OW 72
10898: PUSH
10899: EMPTY
10900: UNION
10901: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
10902: LD_ADDR_VAR 0 2
10906: PUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_INT 51
10914: PUSH
10915: EMPTY
10916: LIST
10917: PPUSH
10918: CALL_OW 72
10922: PUSH
10923: EMPTY
10924: UNION
10925: ST_TO_ADDR
// for i in cars do
10926: LD_ADDR_VAR 0 7
10930: PUSH
10931: LD_VAR 0 1
10935: PUSH
10936: FOR_IN
10937: IFFALSE 10972
// if not IsDrivenBy ( i ) then
10939: LD_VAR 0 7
10943: PPUSH
10944: CALL_OW 311
10948: NOT
10949: IFFALSE 10970
// empty := empty ^ [ i ] ;
10951: LD_ADDR_VAR 0 5
10955: PUSH
10956: LD_VAR 0 5
10960: PUSH
10961: LD_VAR 0 7
10965: PUSH
10966: EMPTY
10967: LIST
10968: ADD
10969: ST_TO_ADDR
10970: GO 10936
10972: POP
10973: POP
// if take_out then
10974: LD_VAR 0 3
10978: IFFALSE 11036
// begin for i in drivers do
10980: LD_ADDR_VAR 0 7
10984: PUSH
10985: LD_VAR 0 2
10989: PUSH
10990: FOR_IN
10991: IFFALSE 11032
// if not ( IsInUnit ( i ) in cars ) then
10993: LD_VAR 0 7
10997: PPUSH
10998: CALL_OW 310
11002: PUSH
11003: LD_VAR 0 1
11007: IN
11008: NOT
11009: IFFALSE 11030
// free := free ^ [ i ] ;
11011: LD_ADDR_VAR 0 6
11015: PUSH
11016: LD_VAR 0 6
11020: PUSH
11021: LD_VAR 0 7
11025: PUSH
11026: EMPTY
11027: LIST
11028: ADD
11029: ST_TO_ADDR
11030: GO 10990
11032: POP
11033: POP
// end else
11034: GO 11084
// begin for i in drivers do
11036: LD_ADDR_VAR 0 7
11040: PUSH
11041: LD_VAR 0 2
11045: PUSH
11046: FOR_IN
11047: IFFALSE 11082
// if not IsInUnit ( i ) then
11049: LD_VAR 0 7
11053: PPUSH
11054: CALL_OW 310
11058: NOT
11059: IFFALSE 11080
// free := free ^ [ i ] ;
11061: LD_ADDR_VAR 0 6
11065: PUSH
11066: LD_VAR 0 6
11070: PUSH
11071: LD_VAR 0 7
11075: PUSH
11076: EMPTY
11077: LIST
11078: ADD
11079: ST_TO_ADDR
11080: GO 11046
11082: POP
11083: POP
// end ; result := cars diff empty ;
11084: LD_ADDR_VAR 0 4
11088: PUSH
11089: LD_VAR 0 1
11093: PUSH
11094: LD_VAR 0 5
11098: DIFF
11099: ST_TO_ADDR
// if empty <= free then
11100: LD_VAR 0 5
11104: PUSH
11105: LD_VAR 0 6
11109: LESSEQUAL
11110: IFFALSE 11124
// konec := empty else
11112: LD_ADDR_VAR 0 8
11116: PUSH
11117: LD_VAR 0 5
11121: ST_TO_ADDR
11122: GO 11134
// konec := free ;
11124: LD_ADDR_VAR 0 8
11128: PUSH
11129: LD_VAR 0 6
11133: ST_TO_ADDR
// for i := 1 to konec do
11134: LD_ADDR_VAR 0 7
11138: PUSH
11139: DOUBLE
11140: LD_INT 1
11142: DEC
11143: ST_TO_ADDR
11144: LD_VAR 0 8
11148: PUSH
11149: FOR_TO
11150: IFFALSE 11205
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
11152: LD_VAR 0 6
11156: PUSH
11157: LD_VAR 0 7
11161: ARRAY
11162: PPUSH
11163: LD_VAR 0 5
11167: PUSH
11168: LD_VAR 0 7
11172: ARRAY
11173: PPUSH
11174: CALL_OW 120
// result := result ^ [ empty [ i ] ] ;
11178: LD_ADDR_VAR 0 4
11182: PUSH
11183: LD_VAR 0 4
11187: PUSH
11188: LD_VAR 0 5
11192: PUSH
11193: LD_VAR 0 7
11197: ARRAY
11198: PUSH
11199: EMPTY
11200: LIST
11201: ADD
11202: ST_TO_ADDR
// end ;
11203: GO 11149
11205: POP
11206: POP
// end ;
11207: LD_VAR 0 4
11211: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
11212: LD_INT 0
11214: PPUSH
11215: PPUSH
11216: PPUSH
// while remotes > mechs do
11217: LD_VAR 0 3
11221: PUSH
11222: LD_VAR 0 2
11226: GREATER
11227: IFFALSE 11243
// delete ( remotes , 1 ) ;
11229: LD_VAR 0 3
11233: PPUSH
11234: LD_INT 1
11236: PPUSH
11237: CALL_OW 3
11241: GO 11217
// for i := 1 to remotes do
11243: LD_ADDR_VAR 0 6
11247: PUSH
11248: DOUBLE
11249: LD_INT 1
11251: DEC
11252: ST_TO_ADDR
11253: LD_VAR 0 3
11257: PUSH
11258: FOR_TO
11259: IFFALSE 11289
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
11261: LD_VAR 0 2
11265: PUSH
11266: LD_VAR 0 6
11270: ARRAY
11271: PPUSH
11272: LD_VAR 0 3
11276: PUSH
11277: LD_VAR 0 6
11281: ARRAY
11282: PPUSH
11283: CALL_OW 120
11287: GO 11258
11289: POP
11290: POP
// end ;
11291: LD_VAR 0 4
11295: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
11296: LD_INT 0
11298: PPUSH
11299: PPUSH
11300: PPUSH
11301: PPUSH
// c := tick + cas ;
11302: LD_ADDR_VAR 0 5
11306: PUSH
11307: LD_OWVAR 1
11311: PUSH
11312: LD_VAR 0 3
11316: PLUS
11317: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
11318: LD_OWVAR 1
11322: PUSH
11323: LD_VAR 0 5
11327: LESS
11328: PUSH
11329: LD_VAR 0 2
11333: PPUSH
11334: CALL 10817 0 1
11338: PUSH
11339: LD_INT 0
11341: PLUS
11342: PUSH
11343: LD_VAR 0 2
11347: EQUAL
11348: NOT
11349: AND
11350: IFFALSE 11361
// wait ( 0 0$1 ) ;
11352: LD_INT 35
11354: PPUSH
11355: CALL_OW 67
11359: GO 11318
// unlinked := cars ;
11361: LD_ADDR_VAR 0 6
11365: PUSH
11366: LD_VAR 0 1
11370: ST_TO_ADDR
// for i in remotes do
11371: LD_ADDR_VAR 0 7
11375: PUSH
11376: LD_VAR 0 2
11380: PUSH
11381: FOR_IN
11382: IFFALSE 11431
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
11384: LD_VAR 0 6
11388: PPUSH
11389: LD_VAR 0 7
11393: PPUSH
11394: CALL_OW 313
11398: PPUSH
11399: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
11403: LD_ADDR_VAR 0 6
11407: PUSH
11408: LD_VAR 0 6
11412: PUSH
11413: LD_VAR 0 7
11417: PPUSH
11418: CALL_OW 313
11422: PPUSH
11423: CALL_OW 432
11427: DIFF
11428: ST_TO_ADDR
// end ;
11429: GO 11381
11431: POP
11432: POP
// end ;
11433: LD_VAR 0 4
11437: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , k , pockat ; begin
11438: LD_INT 0
11440: PPUSH
11441: PPUSH
11442: PPUSH
11443: PPUSH
11444: PPUSH
// k := 0 ;
11445: LD_ADDR_VAR 0 6
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// pockat := tick + cas ;
11453: LD_ADDR_VAR 0 7
11457: PUSH
11458: LD_OWVAR 1
11462: PUSH
11463: LD_VAR 0 2
11467: PLUS
11468: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
11469: LD_VAR 0 5
11473: NOT
11474: PUSH
11475: LD_OWVAR 1
11479: PUSH
11480: LD_VAR 0 7
11484: LESS
11485: AND
11486: IFFALSE 11556
// begin vsichni_ready := true ;
11488: LD_ADDR_VAR 0 5
11492: PUSH
11493: LD_INT 1
11495: ST_TO_ADDR
// k := k + 1 ;
11496: LD_ADDR_VAR 0 6
11500: PUSH
11501: LD_VAR 0 6
11505: PUSH
11506: LD_INT 1
11508: PLUS
11509: ST_TO_ADDR
// for i in cars do
11510: LD_ADDR_VAR 0 4
11514: PUSH
11515: LD_VAR 0 1
11519: PUSH
11520: FOR_IN
11521: IFFALSE 11545
// if not IsDrivenBy ( i ) then
11523: LD_VAR 0 4
11527: PPUSH
11528: CALL_OW 311
11532: NOT
11533: IFFALSE 11543
// vsichni_ready := false ;
11535: LD_ADDR_VAR 0 5
11539: PUSH
11540: LD_INT 0
11542: ST_TO_ADDR
11543: GO 11520
11545: POP
11546: POP
// wait ( 0 0$1.0 ) ;
11547: LD_INT 35
11549: PPUSH
11550: CALL_OW 67
// end ;
11554: GO 11469
// end ;
11556: LD_VAR 0 3
11560: RET
// export function rev ( list ) ; var i ; begin
11561: LD_INT 0
11563: PPUSH
11564: PPUSH
// for i := list + 0 to 1 do
11565: LD_ADDR_VAR 0 3
11569: PUSH
11570: DOUBLE
11571: LD_VAR 0 1
11575: PUSH
11576: LD_INT 0
11578: PLUS
11579: DEC
11580: ST_TO_ADDR
11581: LD_INT 1
11583: PUSH
11584: FOR_TO
11585: IFFALSE 11614
// result := result ^ [ list [ i ] ] ;
11587: LD_ADDR_VAR 0 2
11591: PUSH
11592: LD_VAR 0 2
11596: PUSH
11597: LD_VAR 0 1
11601: PUSH
11602: LD_VAR 0 3
11606: ARRAY
11607: PUSH
11608: EMPTY
11609: LIST
11610: ADD
11611: ST_TO_ADDR
11612: GO 11584
11614: POP
11615: POP
// end ; end_of_file
11616: LD_VAR 0 2
11620: RET
// export under_attack ; export near_base_area ; export function inicializace_ai_defend ; begin
11621: LD_INT 0
11623: PPUSH
// under_attack := [ false , false , false , false , false ] ;
11624: LD_ADDR_EXP 62
11628: PUSH
11629: LD_INT 0
11631: PUSH
11632: LD_INT 0
11634: PUSH
11635: LD_INT 0
11637: PUSH
11638: LD_INT 0
11640: PUSH
11641: LD_INT 0
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: ST_TO_ADDR
// near_base_area := [ nearA , nearB , nearC , nearD , nearE ] ;
11651: LD_ADDR_EXP 63
11655: PUSH
11656: LD_INT 24
11658: PUSH
11659: LD_INT 25
11661: PUSH
11662: LD_INT 26
11664: PUSH
11665: LD_INT 27
11667: PUSH
11668: LD_INT 28
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: ST_TO_ADDR
// end ;
11678: LD_VAR 0 1
11682: RET
// export BehMcRegId , BehMcAttId ; export function BehemothUtok ; begin
11683: LD_INT 0
11685: PPUSH
// if GetSide ( behemoth ) = you then
11686: LD_INT 125
11688: PPUSH
11689: CALL_OW 255
11693: PUSH
11694: LD_EXP 7
11698: EQUAL
11699: IFFALSE 11703
// exit ;
11701: GO 11869
// BehMcRegId := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11703: LD_ADDR_EXP 64
11707: PUSH
11708: LD_EXP 23
11712: PUSH
11713: LD_INT 1
11715: ARRAY
11716: PPUSH
11717: LD_INT 1
11719: PUSH
11720: LD_INT 140
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 4
11729: PUSH
11730: LD_EXP 42
11734: PUSH
11735: EMPTY
11736: LIST
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 10
11744: PUSH
11745: LD_EXP 41
11749: PUSH
11750: EMPTY
11751: LIST
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 3
11759: PUSH
11760: LD_EXP 63
11764: PUSH
11765: LD_EXP 25
11769: ARRAY
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 7
11777: PUSH
11778: LD_INT 8
11780: NEG
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: PPUSH
11790: CALL_OW 399
11794: ST_TO_ADDR
// BehMcAttId := McAttack ( 12 , BehMcRegId , [ behemoth ] , [ [ mc_retreat_area_vehicles , nearA ] , [ mc_retreat_area_people , nearA ] , [ mc_retreat_lives_vehicles , 600 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11795: LD_ADDR_EXP 65
11799: PUSH
11800: LD_INT 12
11802: PPUSH
11803: LD_EXP 64
11807: PPUSH
11808: LD_INT 125
11810: PUSH
11811: EMPTY
11812: LIST
11813: PPUSH
11814: LD_INT 8
11816: PUSH
11817: LD_INT 24
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PUSH
11824: LD_INT 7
11826: PUSH
11827: LD_INT 24
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 6
11836: PUSH
11837: LD_INT 600
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 5
11846: PUSH
11847: LD_INT 800
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 10
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 402
11868: ST_TO_ADDR
// end ;
11869: LD_VAR 0 1
11873: RET
// export ZouMcRegId , ZouMcAttId ; export function ZoufalUtok ; begin
11874: LD_INT 0
11876: PPUSH
// ZouMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11877: LD_ADDR_EXP 66
11881: PUSH
11882: LD_EXP 23
11886: PUSH
11887: LD_EXP 25
11891: ARRAY
11892: PPUSH
11893: LD_INT 1
11895: PUSH
11896: LD_INT 140
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: PUSH
11903: LD_INT 4
11905: PUSH
11906: LD_EXP 42
11910: PUSH
11911: EMPTY
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 10
11920: PUSH
11921: LD_EXP 41
11925: PUSH
11926: EMPTY
11927: LIST
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: LD_INT 3
11935: PUSH
11936: LD_EXP 63
11940: PUSH
11941: LD_EXP 25
11945: ARRAY
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 7
11953: PUSH
11954: LD_INT 8
11956: NEG
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: PPUSH
11966: CALL_OW 399
11970: ST_TO_ADDR
// ZouMcAttId := McAttack ( 12 , ZouMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11971: LD_ADDR_EXP 67
11975: PUSH
11976: LD_INT 12
11978: PPUSH
11979: LD_EXP 66
11983: PPUSH
11984: LD_EXP 77
11988: PUSH
11989: LD_EXP 25
11993: ARRAY
11994: PPUSH
11995: LD_INT 8
11997: PUSH
11998: LD_EXP 63
12002: PUSH
12003: LD_EXP 25
12007: ARRAY
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: PUSH
12013: LD_INT 7
12015: PUSH
12016: LD_EXP 63
12020: PUSH
12021: LD_EXP 25
12025: ARRAY
12026: PUSH
12027: EMPTY
12028: LIST
12029: LIST
12030: PUSH
12031: LD_INT 6
12033: PUSH
12034: LD_INT 100
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: PUSH
12041: LD_INT 5
12043: PUSH
12044: LD_INT 800
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: PUSH
12051: LD_INT 10
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: LIST
12058: LIST
12059: LIST
12060: PPUSH
12061: CALL_OW 402
12065: ST_TO_ADDR
// end ;
12066: LD_VAR 0 1
12070: RET
// export NorMcRegId , NorMcAttId ; export function NormalUtok ; begin
12071: LD_INT 0
12073: PPUSH
// NorMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ your_humans ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
12074: LD_ADDR_EXP 68
12078: PUSH
12079: LD_EXP 23
12083: PUSH
12084: LD_EXP 25
12088: ARRAY
12089: PPUSH
12090: LD_INT 1
12092: PUSH
12093: LD_INT 140
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 4
12102: PUSH
12103: LD_EXP 42
12107: PUSH
12108: EMPTY
12109: LIST
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: LD_INT 10
12117: PUSH
12118: LD_EXP 37
12122: PUSH
12123: EMPTY
12124: LIST
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 3
12132: PUSH
12133: LD_EXP 63
12137: PUSH
12138: LD_EXP 25
12142: ARRAY
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: PUSH
12148: LD_INT 7
12150: PUSH
12151: LD_INT 8
12153: NEG
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: PPUSH
12163: CALL_OW 399
12167: ST_TO_ADDR
// NorMcAttId := McAttack ( 12 , NorMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12168: LD_ADDR_EXP 69
12172: PUSH
12173: LD_INT 12
12175: PPUSH
12176: LD_EXP 68
12180: PPUSH
12181: LD_EXP 77
12185: PUSH
12186: LD_EXP 25
12190: ARRAY
12191: PPUSH
12192: LD_INT 8
12194: PUSH
12195: LD_EXP 63
12199: PUSH
12200: LD_EXP 25
12204: ARRAY
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: LD_INT 7
12212: PUSH
12213: LD_EXP 63
12217: PUSH
12218: LD_EXP 25
12222: ARRAY
12223: PUSH
12224: EMPTY
12225: LIST
12226: LIST
12227: PUSH
12228: LD_INT 6
12230: PUSH
12231: LD_INT 100
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PUSH
12238: LD_INT 5
12240: PUSH
12241: LD_INT 800
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: PUSH
12248: LD_INT 10
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: PPUSH
12258: CALL_OW 402
12262: ST_TO_ADDR
// end ;
12263: LD_VAR 0 1
12267: RET
// function utok_na_vetrelce ( vetrelci , index_strany ) ; var nearest , units ; begin
12268: LD_INT 0
12270: PPUSH
12271: PPUSH
12272: PPUSH
// if vetrelci and ( ai_s [ index_strany ] in aiZ ) then
12273: LD_VAR 0 1
12277: PUSH
12278: LD_EXP 23
12282: PUSH
12283: LD_VAR 0 2
12287: ARRAY
12288: PUSH
12289: LD_EXP 21
12293: IN
12294: AND
12295: IFFALSE 12398
// begin nearest := NearestUnitToUnit ( vetrelci , depots [ index_strany ] ) ;
12297: LD_ADDR_VAR 0 4
12301: PUSH
12302: LD_VAR 0 1
12306: PPUSH
12307: LD_EXP 74
12311: PUSH
12312: LD_VAR 0 2
12316: ARRAY
12317: PPUSH
12318: CALL_OW 74
12322: ST_TO_ADDR
// if nearest then
12323: LD_VAR 0 4
12327: IFFALSE 12398
// begin units := attack_units isect vehicles [ index_strany ] ;
12329: LD_ADDR_VAR 0 5
12333: PUSH
12334: LD_EXP 78
12338: PUSH
12339: LD_EXP 77
12343: PUSH
12344: LD_VAR 0 2
12348: ARRAY
12349: ISECT
12350: ST_TO_ADDR
// ComRemember ( units ) ;
12351: LD_VAR 0 5
12355: PPUSH
12356: CALL_OW 143
// AddComAgressiveMove ( units , GetX ( nearest ) , GetY ( nearest ) ) ;
12360: LD_VAR 0 5
12364: PPUSH
12365: LD_VAR 0 4
12369: PPUSH
12370: CALL_OW 250
12374: PPUSH
12375: LD_VAR 0 4
12379: PPUSH
12380: CALL_OW 251
12384: PPUSH
12385: CALL_OW 174
// AddComReturn ( units ) ;
12389: LD_VAR 0 5
12393: PPUSH
12394: CALL_OW 204
// end ; end ; end ;
12398: LD_VAR 0 3
12402: RET
// every 0 0$10 do var i , a ;
12403: GO 12405
12405: DISABLE
12406: LD_INT 0
12408: PPUSH
12409: PPUSH
// begin for i := 1 to 5 do
12410: LD_ADDR_VAR 0 1
12414: PUSH
12415: DOUBLE
12416: LD_INT 1
12418: DEC
12419: ST_TO_ADDR
12420: LD_INT 5
12422: PUSH
12423: FOR_TO
12424: IFFALSE 12563
// begin a := UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ i ] ] ] ) ;
12426: LD_ADDR_VAR 0 2
12430: PUSH
12431: LD_EXP 37
12435: PUSH
12436: LD_EXP 35
12440: ADD
12441: PPUSH
12442: LD_INT 95
12444: PUSH
12445: LD_EXP 63
12449: PUSH
12450: LD_VAR 0 1
12454: ARRAY
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: EMPTY
12461: LIST
12462: PPUSH
12463: CALL_OW 72
12467: ST_TO_ADDR
// if a and ai_s [ i ] in aiZ then
12468: LD_VAR 0 2
12472: PUSH
12473: LD_EXP 23
12477: PUSH
12478: LD_VAR 0 1
12482: ARRAY
12483: PUSH
12484: LD_EXP 21
12488: IN
12489: AND
12490: IFFALSE 12531
// begin under_attack := replace ( under_attack , i , true ) ;
12492: LD_ADDR_EXP 62
12496: PUSH
12497: LD_EXP 62
12501: PPUSH
12502: LD_VAR 0 1
12506: PPUSH
12507: LD_INT 1
12509: PPUSH
12510: CALL_OW 1
12514: ST_TO_ADDR
// utok_na_vetrelce ( a , i ) ;
12515: LD_VAR 0 2
12519: PPUSH
12520: LD_VAR 0 1
12524: PPUSH
12525: CALL 12268 0 2
// end else
12529: GO 12554
// under_attack := replace ( under_attack , i , false ) ;
12531: LD_ADDR_EXP 62
12535: PUSH
12536: LD_EXP 62
12540: PPUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_INT 0
12548: PPUSH
12549: CALL_OW 1
12553: ST_TO_ADDR
// wait ( 0 0$2 ) ;
12554: LD_INT 70
12556: PPUSH
12557: CALL_OW 67
// end ;
12561: GO 12423
12563: POP
12564: POP
// enable ;
12565: ENABLE
// end ; end_of_file
12566: PPOPN 2
12568: END
// var repair_site ; export rc ; export bc ; export function inicializace_ai_c_repair ; begin
12569: LD_INT 0
12571: PPUSH
// repair_site := [ [ 30 , 29 ] , [ 89 , 17 ] , [ 72 , 125 ] , [ 215 , 140 ] , [ 184 , 85 ] ] ;
12572: LD_ADDR_LOC 16
12576: PUSH
12577: LD_INT 30
12579: PUSH
12580: LD_INT 29
12582: PUSH
12583: EMPTY
12584: LIST
12585: LIST
12586: PUSH
12587: LD_INT 89
12589: PUSH
12590: LD_INT 17
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PUSH
12597: LD_INT 72
12599: PUSH
12600: LD_INT 125
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: PUSH
12607: LD_INT 215
12609: PUSH
12610: LD_INT 140
12612: PUSH
12613: EMPTY
12614: LIST
12615: LIST
12616: PUSH
12617: LD_INT 184
12619: PUSH
12620: LD_INT 85
12622: PUSH
12623: EMPTY
12624: LIST
12625: LIST
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: ST_TO_ADDR
// bc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12634: LD_ADDR_EXP 71
12638: PUSH
12639: EMPTY
12640: PUSH
12641: EMPTY
12642: PUSH
12643: EMPTY
12644: PUSH
12645: EMPTY
12646: PUSH
12647: EMPTY
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: ST_TO_ADDR
// rc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12656: LD_ADDR_EXP 70
12660: PUSH
12661: EMPTY
12662: PUSH
12663: EMPTY
12664: PUSH
12665: EMPTY
12666: PUSH
12667: EMPTY
12668: PUSH
12669: EMPTY
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: ST_TO_ADDR
// end ;
12678: LD_VAR 0 1
12682: RET
// every 0 0$5.0 + 0 0$0.5 do var i ;
12683: GO 12685
12685: DISABLE
12686: LD_INT 0
12688: PPUSH
// begin for i := 1 to 5 do
12689: LD_ADDR_VAR 0 1
12693: PUSH
12694: DOUBLE
12695: LD_INT 1
12697: DEC
12698: ST_TO_ADDR
12699: LD_INT 5
12701: PUSH
12702: FOR_TO
12703: IFFALSE 12758
// if ai_s [ i ] in ai then
12705: LD_EXP 23
12709: PUSH
12710: LD_VAR 0 1
12714: ARRAY
12715: PUSH
12716: LD_EXP 24
12720: IN
12721: IFFALSE 12756
// begin dop_pal ( vehicles [ i ] , depots [ i ] ) ;
12723: LD_EXP 77
12727: PUSH
12728: LD_VAR 0 1
12732: ARRAY
12733: PPUSH
12734: LD_EXP 74
12738: PUSH
12739: LD_VAR 0 1
12743: ARRAY
12744: PPUSH
12745: CALL 12764 0 2
// wait ( 0 0$1 ) ;
12749: LD_INT 35
12751: PPUSH
12752: CALL_OW 67
// end ;
12756: GO 12702
12758: POP
12759: POP
// enable ;
12760: ENABLE
// end ;
12761: PPOPN 1
12763: END
// function dop_pal ( tc , tdep ) ; var set_fuel , fuel ; begin
12764: LD_INT 0
12766: PPUSH
12767: PPUSH
12768: PPUSH
// for set_fuel in UnitFilter ( tc , [ [ f_dist , tdep , 40 ] ] ) do
12769: LD_ADDR_VAR 0 4
12773: PUSH
12774: LD_VAR 0 1
12778: PPUSH
12779: LD_INT 91
12781: PUSH
12782: LD_VAR 0 2
12786: PUSH
12787: LD_INT 40
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: PPUSH
12798: CALL_OW 72
12802: PUSH
12803: FOR_IN
12804: IFFALSE 12851
// begin fuel := GetFuel ( set_fuel ) ;
12806: LD_ADDR_VAR 0 5
12810: PUSH
12811: LD_VAR 0 4
12815: PPUSH
12816: CALL_OW 261
12820: ST_TO_ADDR
// if fuel <= 80 then
12821: LD_VAR 0 5
12825: PUSH
12826: LD_INT 80
12828: LESSEQUAL
12829: IFFALSE 12849
// SetFuel ( set_fuel , fuel + 20 ) ;
12831: LD_VAR 0 4
12835: PPUSH
12836: LD_VAR 0 5
12840: PUSH
12841: LD_INT 20
12843: PLUS
12844: PPUSH
12845: CALL_OW 240
// end ;
12849: GO 12803
12851: POP
12852: POP
// end ;
12853: LD_VAR 0 3
12857: RET
// every 0 0$5 + 0 0$0.3 do var zivoty , i , rem_t , add_t , k ;
12858: GO 12860
12860: DISABLE
12861: LD_INT 0
12863: PPUSH
12864: PPUSH
12865: PPUSH
12866: PPUSH
12867: PPUSH
// begin for k := 1 to 5 do
12868: LD_ADDR_VAR 0 5
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_INT 5
12880: PUSH
12881: FOR_TO
12882: IFFALSE 13200
// if ai_s [ k ] in ai then
12884: LD_EXP 23
12888: PUSH
12889: LD_VAR 0 5
12893: ARRAY
12894: PUSH
12895: LD_EXP 24
12899: IN
12900: IFFALSE 13176
// begin rem_t := [ ] ;
12902: LD_ADDR_VAR 0 3
12906: PUSH
12907: EMPTY
12908: ST_TO_ADDR
// add_t := [ ] ;
12909: LD_ADDR_VAR 0 4
12913: PUSH
12914: EMPTY
12915: ST_TO_ADDR
// for i in UnitFilter ( vehicles [ k ] , [ [ f_not , [ f_side , you ] ] ] ) do
12916: LD_ADDR_VAR 0 2
12920: PUSH
12921: LD_EXP 77
12925: PUSH
12926: LD_VAR 0 5
12930: ARRAY
12931: PPUSH
12932: LD_INT 3
12934: PUSH
12935: LD_INT 22
12937: PUSH
12938: LD_EXP 7
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: EMPTY
12952: LIST
12953: PPUSH
12954: CALL_OW 72
12958: PUSH
12959: FOR_IN
12960: IFFALSE 13028
// begin if GetLives ( i ) < 500 then
12962: LD_VAR 0 2
12966: PPUSH
12967: CALL_OW 256
12971: PUSH
12972: LD_INT 500
12974: LESS
12975: IFFALSE 12995
// begin rem_t := rem_t ^ i ;
12977: LD_ADDR_VAR 0 3
12981: PUSH
12982: LD_VAR 0 3
12986: PUSH
12987: LD_VAR 0 2
12991: ADD
12992: ST_TO_ADDR
// end else
12993: GO 13026
// if GetLives ( i ) >= 950 then
12995: LD_VAR 0 2
12999: PPUSH
13000: CALL_OW 256
13004: PUSH
13005: LD_INT 950
13007: GREATEREQUAL
13008: IFFALSE 13026
// begin add_t := add_t ^ i ;
13010: LD_ADDR_VAR 0 4
13014: PUSH
13015: LD_VAR 0 4
13019: PUSH
13020: LD_VAR 0 2
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12959
13028: POP
13029: POP
// bc := replace ( bc , k , bc [ k ] union rem_t ) ;
13030: LD_ADDR_EXP 71
13034: PUSH
13035: LD_EXP 71
13039: PPUSH
13040: LD_VAR 0 5
13044: PPUSH
13045: LD_EXP 71
13049: PUSH
13050: LD_VAR 0 5
13054: ARRAY
13055: PUSH
13056: LD_VAR 0 3
13060: UNION
13061: PPUSH
13062: CALL_OW 1
13066: ST_TO_ADDR
// bc := replace ( bc , k , bc [ k ] diff add_t ) ;
13067: LD_ADDR_EXP 71
13071: PUSH
13072: LD_EXP 71
13076: PPUSH
13077: LD_VAR 0 5
13081: PPUSH
13082: LD_EXP 71
13086: PUSH
13087: LD_VAR 0 5
13091: ARRAY
13092: PUSH
13093: LD_VAR 0 4
13097: DIFF
13098: PPUSH
13099: CALL_OW 1
13103: ST_TO_ADDR
// remove_from_vehicles ( rem_t ) ;
13104: LD_VAR 0 3
13108: PPUSH
13109: CALL 28260 0 1
// add_to_vehicles ( add_t ) ;
13113: LD_VAR 0 4
13117: PPUSH
13118: CALL 26929 0 1
// ComMoveXY ( bc [ k ] , repair_site [ k ] [ 1 ] , repair_site [ k ] [ 2 ] ) ;
13122: LD_EXP 71
13126: PUSH
13127: LD_VAR 0 5
13131: ARRAY
13132: PPUSH
13133: LD_LOC 16
13137: PUSH
13138: LD_VAR 0 5
13142: ARRAY
13143: PUSH
13144: LD_INT 1
13146: ARRAY
13147: PPUSH
13148: LD_LOC 16
13152: PUSH
13153: LD_VAR 0 5
13157: ARRAY
13158: PUSH
13159: LD_INT 2
13161: ARRAY
13162: PPUSH
13163: CALL_OW 111
// wait ( 0 0$0.9 ) ;
13167: LD_INT 32
13169: PPUSH
13170: CALL_OW 67
// end else
13174: GO 13198
// bc := replace ( bc , k , [ ] ) ;
13176: LD_ADDR_EXP 71
13180: PUSH
13181: LD_EXP 71
13185: PPUSH
13186: LD_VAR 0 5
13190: PPUSH
13191: EMPTY
13192: PPUSH
13193: CALL_OW 1
13197: ST_TO_ADDR
13198: GO 12881
13200: POP
13201: POP
// enable ;
13202: ENABLE
// end ;
13203: PPOPN 5
13205: END
// every 0 0$5 + 0 0$0.1 do var zivoty , i , rc_t , k ;
13206: GO 13208
13208: DISABLE
13209: LD_INT 0
13211: PPUSH
13212: PPUSH
13213: PPUSH
13214: PPUSH
// begin for k := 1 to 5 do
13215: LD_ADDR_VAR 0 4
13219: PUSH
13220: DOUBLE
13221: LD_INT 1
13223: DEC
13224: ST_TO_ADDR
13225: LD_INT 5
13227: PUSH
13228: FOR_TO
13229: IFFALSE 13396
// if ai_s [ k ] in ai then
13231: LD_EXP 23
13235: PUSH
13236: LD_VAR 0 4
13240: ARRAY
13241: PUSH
13242: LD_EXP 24
13246: IN
13247: IFFALSE 13372
// begin rc_t := [ ] ;
13249: LD_ADDR_VAR 0 3
13253: PUSH
13254: EMPTY
13255: ST_TO_ADDR
// for i in bc [ k ] do
13256: LD_ADDR_VAR 0 2
13260: PUSH
13261: LD_EXP 71
13265: PUSH
13266: LD_VAR 0 4
13270: ARRAY
13271: PUSH
13272: FOR_IN
13273: IFFALSE 13329
// begin if GetLives ( i ) < 950 then
13275: LD_VAR 0 2
13279: PPUSH
13280: CALL_OW 256
13284: PUSH
13285: LD_INT 950
13287: LESS
13288: IFFALSE 13327
// begin rc_t := rc_t ^ i ;
13290: LD_ADDR_VAR 0 3
13294: PUSH
13295: LD_VAR 0 3
13299: PUSH
13300: LD_VAR 0 2
13304: ADD
13305: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
13306: LD_ADDR_VAR 0 1
13310: PUSH
13311: LD_VAR 0 1
13315: PUSH
13316: LD_VAR 0 2
13320: PPUSH
13321: CALL_OW 256
13325: ADD
13326: ST_TO_ADDR
// end ; end ;
13327: GO 13272
13329: POP
13330: POP
// SortListByListAsc ( rc_t , zivoty ) ;
13331: LD_VAR 0 3
13335: PPUSH
13336: LD_VAR 0 1
13340: PPUSH
13341: CALL_OW 76
// rc := replace ( rc , k , rc_t ) ;
13345: LD_ADDR_EXP 70
13349: PUSH
13350: LD_EXP 70
13354: PPUSH
13355: LD_VAR 0 4
13359: PPUSH
13360: LD_VAR 0 3
13364: PPUSH
13365: CALL_OW 1
13369: ST_TO_ADDR
// end else
13370: GO 13394
// rc := replace ( rc , k , [ ] ) ;
13372: LD_ADDR_EXP 70
13376: PUSH
13377: LD_EXP 70
13381: PPUSH
13382: LD_VAR 0 4
13386: PPUSH
13387: EMPTY
13388: PPUSH
13389: CALL_OW 1
13393: ST_TO_ADDR
13394: GO 13228
13396: POP
13397: POP
// enable ;
13398: ENABLE
// end ;
13399: PPOPN 4
13401: END
// every 0 0$5 + 0 0$0.9 do var i ;
13402: GO 13404
13404: DISABLE
13405: LD_INT 0
13407: PPUSH
// begin for i := 1 to 5 do
13408: LD_ADDR_VAR 0 1
13412: PUSH
13413: DOUBLE
13414: LD_INT 1
13416: DEC
13417: ST_TO_ADDR
13418: LD_INT 5
13420: PUSH
13421: FOR_TO
13422: IFFALSE 13477
// if ai_s [ i ] in ai then
13424: LD_EXP 23
13428: PUSH
13429: LD_VAR 0 1
13433: ARRAY
13434: PUSH
13435: LD_EXP 24
13439: IN
13440: IFFALSE 13475
// begin rep ( ai_s [ i ] , rc [ i ] ) ;
13442: LD_EXP 23
13446: PUSH
13447: LD_VAR 0 1
13451: ARRAY
13452: PPUSH
13453: LD_EXP 70
13457: PUSH
13458: LD_VAR 0 1
13462: ARRAY
13463: PPUSH
13464: CALL 13483 0 2
// wait ( 0 0$0.8 ) ;
13468: LD_INT 28
13470: PPUSH
13471: CALL_OW 67
// end ;
13475: GO 13421
13477: POP
13478: POP
// enable ;
13479: ENABLE
// end ;
13480: PPOPN 1
13482: END
// function rep ( side , rep_cars ) ; var a ; begin
13483: LD_INT 0
13485: PPUSH
13486: PPUSH
// if ( side in ai ) and rep_cars then
13487: LD_VAR 0 1
13491: PUSH
13492: LD_EXP 24
13496: IN
13497: PUSH
13498: LD_VAR 0 2
13502: AND
13503: IFFALSE 14032
// begin if rep_cars [ 1 ] < 400 then
13505: LD_VAR 0 2
13509: PUSH
13510: LD_INT 1
13512: ARRAY
13513: PUSH
13514: LD_INT 400
13516: LESS
13517: IFFALSE 13616
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13519: LD_ADDR_VAR 0 4
13523: PUSH
13524: LD_EXP 86
13528: PPUSH
13529: LD_INT 22
13531: PUSH
13532: LD_VAR 0 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 91
13543: PUSH
13544: LD_VAR 0 2
13548: PUSH
13549: LD_INT 1
13551: ARRAY
13552: PUSH
13553: LD_INT 20
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PPUSH
13565: CALL_OW 72
13569: PPUSH
13570: LD_INT 2
13572: PPUSH
13573: LD_INT 3
13575: PPUSH
13576: LD_INT 0
13578: PPUSH
13579: LD_INT 0
13581: PPUSH
13582: CALL 10101 0 5
13586: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13587: LD_VAR 0 4
13591: PPUSH
13592: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13596: LD_VAR 0 4
13600: PPUSH
13601: LD_VAR 0 2
13605: PUSH
13606: LD_INT 1
13608: ARRAY
13609: PPUSH
13610: CALL_OW 189
// end else
13614: GO 14032
// if rep_cars [ 1 ] < 700 or rep_cars >= 2 then
13616: LD_VAR 0 2
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PUSH
13625: LD_INT 700
13627: LESS
13628: PUSH
13629: LD_VAR 0 2
13633: PUSH
13634: LD_INT 2
13636: GREATEREQUAL
13637: OR
13638: IFFALSE 13832
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , false ) ;
13640: LD_ADDR_VAR 0 4
13644: PUSH
13645: LD_EXP 86
13649: PPUSH
13650: LD_INT 22
13652: PUSH
13653: LD_VAR 0 1
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: LD_INT 91
13664: PUSH
13665: LD_VAR 0 2
13669: PUSH
13670: LD_INT 1
13672: ARRAY
13673: PUSH
13674: LD_INT 20
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: PUSH
13682: EMPTY
13683: LIST
13684: LIST
13685: PPUSH
13686: CALL_OW 72
13690: PPUSH
13691: LD_INT 1
13693: PPUSH
13694: LD_INT 3
13696: PPUSH
13697: LD_INT 0
13699: PPUSH
13700: LD_INT 0
13702: PPUSH
13703: CALL 10101 0 5
13707: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13708: LD_VAR 0 4
13712: PPUSH
13713: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13717: LD_VAR 0 4
13721: PPUSH
13722: LD_VAR 0 2
13726: PUSH
13727: LD_INT 1
13729: ARRAY
13730: PPUSH
13731: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , true ) ;
13735: LD_ADDR_VAR 0 4
13739: PUSH
13740: LD_EXP 86
13744: PPUSH
13745: LD_INT 22
13747: PUSH
13748: LD_VAR 0 1
13752: PUSH
13753: EMPTY
13754: LIST
13755: LIST
13756: PUSH
13757: LD_INT 91
13759: PUSH
13760: LD_VAR 0 2
13764: PUSH
13765: LD_INT 2
13767: ARRAY
13768: PUSH
13769: LD_INT 20
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: LIST
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: PPUSH
13781: CALL_OW 72
13785: PPUSH
13786: LD_INT 1
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 0
13794: PPUSH
13795: LD_INT 1
13797: PPUSH
13798: CALL 10101 0 5
13802: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13803: LD_VAR 0 4
13807: PPUSH
13808: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13812: LD_VAR 0 4
13816: PPUSH
13817: LD_VAR 0 2
13821: PUSH
13822: LD_INT 2
13824: ARRAY
13825: PPUSH
13826: CALL_OW 189
// end else
13830: GO 14032
// if rep_cars >= 3 then
13832: LD_VAR 0 2
13836: PUSH
13837: LD_INT 3
13839: GREATEREQUAL
13840: IFFALSE 14032
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13842: LD_ADDR_VAR 0 4
13846: PUSH
13847: LD_EXP 86
13851: PPUSH
13852: LD_INT 22
13854: PUSH
13855: LD_VAR 0 1
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: PUSH
13864: LD_INT 91
13866: PUSH
13867: LD_VAR 0 2
13871: PUSH
13872: LD_INT 1
13874: ARRAY
13875: PUSH
13876: LD_INT 20
13878: PUSH
13879: EMPTY
13880: LIST
13881: LIST
13882: LIST
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 72
13892: PPUSH
13893: LD_INT 2
13895: PPUSH
13896: LD_INT 3
13898: PPUSH
13899: LD_INT 0
13901: PPUSH
13902: LD_INT 0
13904: PPUSH
13905: CALL 10101 0 5
13909: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13910: LD_VAR 0 4
13914: PPUSH
13915: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13919: LD_VAR 0 4
13923: PPUSH
13924: LD_VAR 0 2
13928: PUSH
13929: LD_INT 1
13931: ARRAY
13932: PPUSH
13933: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , true ) ;
13937: LD_ADDR_VAR 0 4
13941: PUSH
13942: LD_EXP 86
13946: PPUSH
13947: LD_INT 22
13949: PUSH
13950: LD_VAR 0 1
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 91
13961: PUSH
13962: LD_VAR 0 2
13966: PUSH
13967: LD_INT 2
13969: ARRAY
13970: PUSH
13971: LD_INT 20
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PPUSH
13983: CALL_OW 72
13987: PPUSH
13988: LD_INT 2
13990: PPUSH
13991: LD_INT 3
13993: PPUSH
13994: LD_INT 0
13996: PPUSH
13997: LD_INT 1
13999: PPUSH
14000: CALL 10101 0 5
14004: ST_TO_ADDR
// ComExitBuilding ( a ) ;
14005: LD_VAR 0 4
14009: PPUSH
14010: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
14014: LD_VAR 0 4
14018: PPUSH
14019: LD_VAR 0 2
14023: PUSH
14024: LD_INT 2
14026: ARRAY
14027: PPUSH
14028: CALL_OW 189
// end ; end ; end ; end_of_file
14032: LD_VAR 0 3
14036: RET
// var d1 , d2 , d3 , d5 , d6 , d7 ; export function inicializace_ai_c_make ; begin
14037: LD_INT 0
14039: PPUSH
// d1 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ;
14040: LD_ADDR_LOC 17
14044: PUSH
14045: LD_INT 23
14047: PUSH
14048: LD_INT 1
14050: PUSH
14051: LD_INT 1
14053: PUSH
14054: LD_INT 43
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: LIST
14061: LIST
14062: ST_TO_ADDR
// d2 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] ;
14063: LD_ADDR_LOC 18
14067: PUSH
14068: LD_INT 23
14070: PUSH
14071: LD_INT 1
14073: PUSH
14074: LD_INT 1
14076: PUSH
14077: LD_INT 45
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: ST_TO_ADDR
// d3 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] ;
14086: LD_ADDR_LOC 19
14090: PUSH
14091: LD_INT 23
14093: PUSH
14094: LD_INT 1
14096: PUSH
14097: LD_INT 1
14099: PUSH
14100: LD_INT 46
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: ST_TO_ADDR
// d5 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_gatling_gun ] ;
14109: LD_ADDR_LOC 20
14113: PUSH
14114: LD_INT 23
14116: PUSH
14117: LD_INT 3
14119: PUSH
14120: LD_INT 3
14122: PUSH
14123: LD_INT 43
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: ST_TO_ADDR
// d6 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_rocket_launcher ] ;
14132: LD_ADDR_LOC 21
14136: PUSH
14137: LD_INT 23
14139: PUSH
14140: LD_INT 3
14142: PUSH
14143: LD_INT 3
14145: PUSH
14146: LD_INT 45
14148: PUSH
14149: EMPTY
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: ST_TO_ADDR
// d7 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_heavy_gun ] ;
14155: LD_ADDR_LOC 22
14159: PUSH
14160: LD_INT 23
14162: PUSH
14163: LD_INT 3
14165: PUSH
14166: LD_INT 3
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: ST_TO_ADDR
// end ;
14178: LD_VAR 0 1
14182: RET
// every 0 0$3 do var i , a ;
14183: GO 14185
14185: DISABLE
14186: LD_INT 0
14188: PPUSH
14189: PPUSH
// begin for i := 1 to 5 do
14190: LD_ADDR_VAR 0 1
14194: PUSH
14195: DOUBLE
14196: LD_INT 1
14198: DEC
14199: ST_TO_ADDR
14200: LD_INT 5
14202: PUSH
14203: FOR_TO
14204: IFFALSE 14428
// begin if ai_s [ i ] in ai then
14206: LD_EXP 23
14210: PUSH
14211: LD_VAR 0 1
14215: ARRAY
14216: PUSH
14217: LD_EXP 24
14221: IN
14222: IFFALSE 14426
// begin if depots [ i ] then
14224: LD_EXP 74
14228: PUSH
14229: LD_VAR 0 1
14233: ARRAY
14234: IFFALSE 14426
// begin if GetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans ) < 150 then
14236: LD_EXP 74
14240: PUSH
14241: LD_VAR 0 1
14245: ARRAY
14246: PUSH
14247: LD_INT 1
14249: ARRAY
14250: PPUSH
14251: CALL_OW 274
14255: PPUSH
14256: LD_INT 1
14258: PPUSH
14259: CALL_OW 275
14263: PUSH
14264: LD_INT 150
14266: LESS
14267: IFFALSE 14311
// SetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans , 150 + Rand ( 50 , 100 ) ) ;
14269: LD_EXP 74
14273: PUSH
14274: LD_VAR 0 1
14278: ARRAY
14279: PUSH
14280: LD_INT 1
14282: ARRAY
14283: PPUSH
14284: CALL_OW 274
14288: PPUSH
14289: LD_INT 1
14291: PPUSH
14292: LD_INT 150
14294: PUSH
14295: LD_INT 50
14297: PPUSH
14298: LD_INT 100
14300: PPUSH
14301: CALL_OW 12
14305: PLUS
14306: PPUSH
14307: CALL_OW 277
// a := GetListOfCratesInArea ( near_base_area [ i ] ) ;
14311: LD_ADDR_VAR 0 2
14315: PUSH
14316: LD_EXP 63
14320: PUSH
14321: LD_VAR 0 1
14325: ARRAY
14326: PPUSH
14327: CALL_OW 435
14331: ST_TO_ADDR
// if a > 6 then
14332: LD_VAR 0 2
14336: PUSH
14337: LD_INT 6
14339: GREATER
14340: IFFALSE 14426
// for i in a do
14342: LD_ADDR_VAR 0 1
14346: PUSH
14347: LD_VAR 0 2
14351: PUSH
14352: FOR_IN
14353: IFFALSE 14424
// if not SeeXY ( you , i [ 1 ] , i [ 2 ] ) then
14355: LD_EXP 7
14359: PPUSH
14360: LD_VAR 0 1
14364: PUSH
14365: LD_INT 1
14367: ARRAY
14368: PPUSH
14369: LD_VAR 0 1
14373: PUSH
14374: LD_INT 2
14376: ARRAY
14377: PPUSH
14378: CALL_OW 293
14382: NOT
14383: IFFALSE 14422
// begin MoveAreaXY ( hexik , i [ 1 ] , i [ 2 ] ) ;
14385: LD_INT 32
14387: PPUSH
14388: LD_VAR 0 1
14392: PUSH
14393: LD_INT 1
14395: ARRAY
14396: PPUSH
14397: LD_VAR 0 1
14401: PUSH
14402: LD_INT 2
14404: ARRAY
14405: PPUSH
14406: CALL_OW 425
// EraseResourceArea ( hexik , mat_cans ) ;
14410: LD_INT 32
14412: PPUSH
14413: LD_INT 1
14415: PPUSH
14416: CALL_OW 286
// break ;
14420: GO 14424
// end ;
14422: GO 14352
14424: POP
14425: POP
// end ; end ; end ;
14426: GO 14203
14428: POP
14429: POP
// end ;
14430: PPOPN 2
14432: END
// function MyCanBeConstructed ( tfact , d ) ; begin
14433: LD_INT 0
14435: PPUSH
// result := CanBeConstructed ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14436: LD_ADDR_VAR 0 3
14440: PUSH
14441: LD_VAR 0 1
14445: PPUSH
14446: LD_VAR 0 2
14450: PUSH
14451: LD_INT 1
14453: ARRAY
14454: PPUSH
14455: LD_VAR 0 2
14459: PUSH
14460: LD_INT 2
14462: ARRAY
14463: PPUSH
14464: LD_VAR 0 2
14468: PUSH
14469: LD_INT 3
14471: ARRAY
14472: PPUSH
14473: LD_VAR 0 2
14477: PUSH
14478: LD_INT 4
14480: ARRAY
14481: PPUSH
14482: CALL_OW 448
14486: ST_TO_ADDR
// end ;
14487: LD_VAR 0 3
14491: RET
// function MyComConstruct ( tfact , d ) ; begin
14492: LD_INT 0
14494: PPUSH
// result := ComConstruct ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14495: LD_ADDR_VAR 0 3
14499: PUSH
14500: LD_VAR 0 1
14504: PPUSH
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 1
14512: ARRAY
14513: PPUSH
14514: LD_VAR 0 2
14518: PUSH
14519: LD_INT 2
14521: ARRAY
14522: PPUSH
14523: LD_VAR 0 2
14527: PUSH
14528: LD_INT 3
14530: ARRAY
14531: PPUSH
14532: LD_VAR 0 2
14536: PUSH
14537: LD_INT 4
14539: ARRAY
14540: PPUSH
14541: CALL_OW 125
14545: ST_TO_ADDR
// end ;
14546: LD_VAR 0 3
14550: RET
// every 0 0$10 + 0 0$1.1 trigger IsOk ( factories [ 1 ] ) and IsIdle ( factories [ 1 ] ) do var a , tfact , def , att ;
14551: LD_EXP 73
14555: PUSH
14556: LD_INT 1
14558: ARRAY
14559: PPUSH
14560: CALL_OW 302
14564: PUSH
14565: LD_EXP 73
14569: PUSH
14570: LD_INT 1
14572: ARRAY
14573: PPUSH
14574: CALL_OW 316
14578: AND
14579: IFFALSE 14898
14581: GO 14583
14583: DISABLE
14584: LD_INT 0
14586: PPUSH
14587: PPUSH
14588: PPUSH
14589: PPUSH
// begin tfact := factories [ 1 ] ;
14590: LD_ADDR_VAR 0 2
14594: PUSH
14595: LD_EXP 73
14599: PUSH
14600: LD_INT 1
14602: ARRAY
14603: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 1 ] , [ mf_manu ] ) ;
14604: LD_ADDR_VAR 0 3
14608: PUSH
14609: LD_EXP 77
14613: PUSH
14614: LD_INT 1
14616: ARRAY
14617: PPUSH
14618: LD_EXP 61
14622: PUSH
14623: EMPTY
14624: LIST
14625: PPUSH
14626: CALL_OW 72
14630: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 1 ] , [ mf_comp ] ) ;
14631: LD_ADDR_VAR 0 4
14635: PUSH
14636: LD_EXP 77
14640: PUSH
14641: LD_INT 1
14643: ARRAY
14644: PPUSH
14645: LD_EXP 60
14649: PUSH
14650: EMPTY
14651: LIST
14652: PPUSH
14653: CALL_OW 72
14657: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14658: LD_INT 1
14660: PUSH
14661: LD_VAR 0 3
14665: PUSH
14666: LD_INT 2
14668: LESS
14669: PUSH
14670: LD_VAR 0 2
14674: PPUSH
14675: LD_LOC 18
14679: PPUSH
14680: CALL 14433 0 2
14684: AND
14685: DOUBLE
14686: EQUAL
14687: IFTRUE 14691
14689: GO 14708
14691: POP
// begin MyComConstruct ( tfact , d2 ) ;
14692: LD_VAR 0 2
14696: PPUSH
14697: LD_LOC 18
14701: PPUSH
14702: CALL 14492 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14706: GO 14897
14708: LD_VAR 0 3
14712: PUSH
14713: LD_INT 3
14715: LESS
14716: PUSH
14717: LD_VAR 0 2
14721: PPUSH
14722: LD_LOC 19
14726: PPUSH
14727: CALL 14433 0 2
14731: AND
14732: DOUBLE
14733: EQUAL
14734: IFTRUE 14738
14736: GO 14755
14738: POP
// begin MyComConstruct ( tfact , d3 ) ;
14739: LD_VAR 0 2
14743: PPUSH
14744: LD_LOC 19
14748: PPUSH
14749: CALL 14492 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
14753: GO 14897
14755: LD_VAR 0 4
14759: PUSH
14760: LD_INT 2
14762: LESS
14763: PUSH
14764: LD_VAR 0 2
14768: PPUSH
14769: LD_LOC 21
14773: PPUSH
14774: CALL 14433 0 2
14778: AND
14779: DOUBLE
14780: EQUAL
14781: IFTRUE 14785
14783: GO 14802
14785: POP
// begin MyComConstruct ( tfact , d6 ) ;
14786: LD_VAR 0 2
14790: PPUSH
14791: LD_LOC 21
14795: PPUSH
14796: CALL 14492 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
14800: GO 14897
14802: LD_VAR 0 4
14806: PUSH
14807: LD_INT 3
14809: LESS
14810: PUSH
14811: LD_VAR 0 2
14815: PPUSH
14816: LD_LOC 20
14820: PPUSH
14821: CALL 14433 0 2
14825: AND
14826: DOUBLE
14827: EQUAL
14828: IFTRUE 14832
14830: GO 14849
14832: POP
// begin MyComConstruct ( tfact , d5 ) ;
14833: LD_VAR 0 2
14837: PPUSH
14838: LD_LOC 20
14842: PPUSH
14843: CALL 14492 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
14847: GO 14897
14849: LD_VAR 0 4
14853: PUSH
14854: LD_INT 5
14856: LESS
14857: PUSH
14858: LD_VAR 0 2
14862: PPUSH
14863: LD_LOC 22
14867: PPUSH
14868: CALL 14433 0 2
14872: AND
14873: DOUBLE
14874: EQUAL
14875: IFTRUE 14879
14877: GO 14896
14879: POP
// begin MyComConstruct ( tfact , d7 ) ;
14880: LD_VAR 0 2
14884: PPUSH
14885: LD_LOC 22
14889: PPUSH
14890: CALL 14492 0 2
// end ; end ;
14894: GO 14897
14896: POP
// enable ;
14897: ENABLE
// end ;
14898: PPOPN 4
14900: END
// every 0 0$10 + 0 0$2.3 trigger IsOk ( factories [ 2 ] ) and IsIdle ( factories [ 2 ] ) do var a , tfact , def , att ;
14901: LD_EXP 73
14905: PUSH
14906: LD_INT 2
14908: ARRAY
14909: PPUSH
14910: CALL_OW 302
14914: PUSH
14915: LD_EXP 73
14919: PUSH
14920: LD_INT 2
14922: ARRAY
14923: PPUSH
14924: CALL_OW 316
14928: AND
14929: IFFALSE 15248
14931: GO 14933
14933: DISABLE
14934: LD_INT 0
14936: PPUSH
14937: PPUSH
14938: PPUSH
14939: PPUSH
// begin tfact := factories [ 2 ] ;
14940: LD_ADDR_VAR 0 2
14944: PUSH
14945: LD_EXP 73
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 2 ] , [ mf_manu ] ) ;
14954: LD_ADDR_VAR 0 3
14958: PUSH
14959: LD_EXP 77
14963: PUSH
14964: LD_INT 2
14966: ARRAY
14967: PPUSH
14968: LD_EXP 61
14972: PUSH
14973: EMPTY
14974: LIST
14975: PPUSH
14976: CALL_OW 72
14980: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 2 ] , [ mf_comp ] ) ;
14981: LD_ADDR_VAR 0 4
14985: PUSH
14986: LD_EXP 77
14990: PUSH
14991: LD_INT 2
14993: ARRAY
14994: PPUSH
14995: LD_EXP 60
14999: PUSH
15000: EMPTY
15001: LIST
15002: PPUSH
15003: CALL_OW 72
15007: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15008: LD_INT 1
15010: PUSH
15011: LD_VAR 0 3
15015: PUSH
15016: LD_INT 2
15018: LESS
15019: PUSH
15020: LD_VAR 0 2
15024: PPUSH
15025: LD_LOC 18
15029: PPUSH
15030: CALL 14433 0 2
15034: AND
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15058
15041: POP
// begin MyComConstruct ( tfact , d2 ) ;
15042: LD_VAR 0 2
15046: PPUSH
15047: LD_LOC 18
15051: PPUSH
15052: CALL 14492 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15056: GO 15247
15058: LD_VAR 0 3
15062: PUSH
15063: LD_INT 3
15065: LESS
15066: PUSH
15067: LD_VAR 0 2
15071: PPUSH
15072: LD_LOC 19
15076: PPUSH
15077: CALL 14433 0 2
15081: AND
15082: DOUBLE
15083: EQUAL
15084: IFTRUE 15088
15086: GO 15105
15088: POP
// begin MyComConstruct ( tfact , d3 ) ;
15089: LD_VAR 0 2
15093: PPUSH
15094: LD_LOC 19
15098: PPUSH
15099: CALL 14492 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15103: GO 15247
15105: LD_VAR 0 4
15109: PUSH
15110: LD_INT 2
15112: LESS
15113: PUSH
15114: LD_VAR 0 2
15118: PPUSH
15119: LD_LOC 21
15123: PPUSH
15124: CALL 14433 0 2
15128: AND
15129: DOUBLE
15130: EQUAL
15131: IFTRUE 15135
15133: GO 15152
15135: POP
// begin MyComConstruct ( tfact , d6 ) ;
15136: LD_VAR 0 2
15140: PPUSH
15141: LD_LOC 21
15145: PPUSH
15146: CALL 14492 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15150: GO 15247
15152: LD_VAR 0 4
15156: PUSH
15157: LD_INT 3
15159: LESS
15160: PUSH
15161: LD_VAR 0 2
15165: PPUSH
15166: LD_LOC 20
15170: PPUSH
15171: CALL 14433 0 2
15175: AND
15176: DOUBLE
15177: EQUAL
15178: IFTRUE 15182
15180: GO 15199
15182: POP
// begin MyComConstruct ( tfact , d5 ) ;
15183: LD_VAR 0 2
15187: PPUSH
15188: LD_LOC 20
15192: PPUSH
15193: CALL 14492 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15197: GO 15247
15199: LD_VAR 0 4
15203: PUSH
15204: LD_INT 5
15206: LESS
15207: PUSH
15208: LD_VAR 0 2
15212: PPUSH
15213: LD_LOC 22
15217: PPUSH
15218: CALL 14433 0 2
15222: AND
15223: DOUBLE
15224: EQUAL
15225: IFTRUE 15229
15227: GO 15246
15229: POP
// begin MyComConstruct ( tfact , d7 ) ;
15230: LD_VAR 0 2
15234: PPUSH
15235: LD_LOC 22
15239: PPUSH
15240: CALL 14492 0 2
// end ; end ;
15244: GO 15247
15246: POP
// enable ;
15247: ENABLE
// end ;
15248: PPOPN 4
15250: END
// every 0 0$10 + 0 0$3.4 trigger IsOk ( factories [ 3 ] ) and IsIdle ( factories [ 3 ] ) do var a , tfact , def , att ;
15251: LD_EXP 73
15255: PUSH
15256: LD_INT 3
15258: ARRAY
15259: PPUSH
15260: CALL_OW 302
15264: PUSH
15265: LD_EXP 73
15269: PUSH
15270: LD_INT 3
15272: ARRAY
15273: PPUSH
15274: CALL_OW 316
15278: AND
15279: IFFALSE 15504
15281: GO 15283
15283: DISABLE
15284: LD_INT 0
15286: PPUSH
15287: PPUSH
15288: PPUSH
15289: PPUSH
// begin tfact := factories [ 3 ] ;
15290: LD_ADDR_VAR 0 2
15294: PUSH
15295: LD_EXP 73
15299: PUSH
15300: LD_INT 3
15302: ARRAY
15303: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 3 ] , [ mf_manu ] ) ;
15304: LD_ADDR_VAR 0 3
15308: PUSH
15309: LD_EXP 77
15313: PUSH
15314: LD_INT 3
15316: ARRAY
15317: PPUSH
15318: LD_EXP 61
15322: PUSH
15323: EMPTY
15324: LIST
15325: PPUSH
15326: CALL_OW 72
15330: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 3 ] , [ mf_comp ] ) ;
15331: LD_ADDR_VAR 0 4
15335: PUSH
15336: LD_EXP 77
15340: PUSH
15341: LD_INT 3
15343: ARRAY
15344: PPUSH
15345: LD_EXP 60
15349: PUSH
15350: EMPTY
15351: LIST
15352: PPUSH
15353: CALL_OW 72
15357: ST_TO_ADDR
// case true of def < 1 and MyCanBeConstructed ( tfact , d2 ) :
15358: LD_INT 1
15360: PUSH
15361: LD_VAR 0 3
15365: PUSH
15366: LD_INT 1
15368: LESS
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_LOC 18
15379: PPUSH
15380: CALL 14433 0 2
15384: AND
15385: DOUBLE
15386: EQUAL
15387: IFTRUE 15391
15389: GO 15408
15391: POP
// begin MyComConstruct ( tfact , d2 ) ;
15392: LD_VAR 0 2
15396: PPUSH
15397: LD_LOC 18
15401: PPUSH
15402: CALL 14492 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15406: GO 15503
15408: LD_VAR 0 4
15412: PUSH
15413: LD_INT 2
15415: LESS
15416: PUSH
15417: LD_VAR 0 2
15421: PPUSH
15422: LD_LOC 21
15426: PPUSH
15427: CALL 14433 0 2
15431: AND
15432: DOUBLE
15433: EQUAL
15434: IFTRUE 15438
15436: GO 15455
15438: POP
// begin MyComConstruct ( tfact , d6 ) ;
15439: LD_VAR 0 2
15443: PPUSH
15444: LD_LOC 21
15448: PPUSH
15449: CALL 14492 0 2
// end ; att < 4 and MyCanBeConstructed ( tfact , d7 ) :
15453: GO 15503
15455: LD_VAR 0 4
15459: PUSH
15460: LD_INT 4
15462: LESS
15463: PUSH
15464: LD_VAR 0 2
15468: PPUSH
15469: LD_LOC 22
15473: PPUSH
15474: CALL 14433 0 2
15478: AND
15479: DOUBLE
15480: EQUAL
15481: IFTRUE 15485
15483: GO 15502
15485: POP
// begin MyComConstruct ( tfact , d7 ) ;
15486: LD_VAR 0 2
15490: PPUSH
15491: LD_LOC 22
15495: PPUSH
15496: CALL 14492 0 2
// end ; end ;
15500: GO 15503
15502: POP
// enable ;
15503: ENABLE
// end ;
15504: PPOPN 4
15506: END
// every 0 0$10 + 0 0$4.5 trigger IsOk ( factories [ 4 ] ) and IsIdle ( factories [ 4 ] ) do var a , tfact , def , att ;
15507: LD_EXP 73
15511: PUSH
15512: LD_INT 4
15514: ARRAY
15515: PPUSH
15516: CALL_OW 302
15520: PUSH
15521: LD_EXP 73
15525: PUSH
15526: LD_INT 4
15528: ARRAY
15529: PPUSH
15530: CALL_OW 316
15534: AND
15535: IFFALSE 15807
15537: GO 15539
15539: DISABLE
15540: LD_INT 0
15542: PPUSH
15543: PPUSH
15544: PPUSH
15545: PPUSH
// begin tfact := factories [ 4 ] ;
15546: LD_ADDR_VAR 0 2
15550: PUSH
15551: LD_EXP 73
15555: PUSH
15556: LD_INT 4
15558: ARRAY
15559: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 4 ] , [ mf_manu ] ) ;
15560: LD_ADDR_VAR 0 3
15564: PUSH
15565: LD_EXP 77
15569: PUSH
15570: LD_INT 4
15572: ARRAY
15573: PPUSH
15574: LD_EXP 61
15578: PUSH
15579: EMPTY
15580: LIST
15581: PPUSH
15582: CALL_OW 72
15586: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 4 ] , [ mf_comp ] ) ;
15587: LD_ADDR_VAR 0 4
15591: PUSH
15592: LD_EXP 77
15596: PUSH
15597: LD_INT 4
15599: ARRAY
15600: PPUSH
15601: LD_EXP 60
15605: PUSH
15606: EMPTY
15607: LIST
15608: PPUSH
15609: CALL_OW 72
15613: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15614: LD_INT 1
15616: PUSH
15617: LD_VAR 0 3
15621: PUSH
15622: LD_INT 2
15624: LESS
15625: PUSH
15626: LD_VAR 0 2
15630: PPUSH
15631: LD_LOC 18
15635: PPUSH
15636: CALL 14433 0 2
15640: AND
15641: DOUBLE
15642: EQUAL
15643: IFTRUE 15647
15645: GO 15664
15647: POP
// begin MyComConstruct ( tfact , d2 ) ;
15648: LD_VAR 0 2
15652: PPUSH
15653: LD_LOC 18
15657: PPUSH
15658: CALL 14492 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15662: GO 15806
15664: LD_VAR 0 3
15668: PUSH
15669: LD_INT 3
15671: LESS
15672: PUSH
15673: LD_VAR 0 2
15677: PPUSH
15678: LD_LOC 19
15682: PPUSH
15683: CALL 14433 0 2
15687: AND
15688: DOUBLE
15689: EQUAL
15690: IFTRUE 15694
15692: GO 15711
15694: POP
// begin MyComConstruct ( tfact , d3 ) ;
15695: LD_VAR 0 2
15699: PPUSH
15700: LD_LOC 19
15704: PPUSH
15705: CALL 14492 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15709: GO 15806
15711: LD_VAR 0 4
15715: PUSH
15716: LD_INT 2
15718: LESS
15719: PUSH
15720: LD_VAR 0 2
15724: PPUSH
15725: LD_LOC 21
15729: PPUSH
15730: CALL 14433 0 2
15734: AND
15735: DOUBLE
15736: EQUAL
15737: IFTRUE 15741
15739: GO 15758
15741: POP
// begin MyComConstruct ( tfact , d6 ) ;
15742: LD_VAR 0 2
15746: PPUSH
15747: LD_LOC 21
15751: PPUSH
15752: CALL 14492 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15756: GO 15806
15758: LD_VAR 0 4
15762: PUSH
15763: LD_INT 5
15765: LESS
15766: PUSH
15767: LD_VAR 0 2
15771: PPUSH
15772: LD_LOC 22
15776: PPUSH
15777: CALL 14433 0 2
15781: AND
15782: DOUBLE
15783: EQUAL
15784: IFTRUE 15788
15786: GO 15805
15788: POP
// begin MyComConstruct ( tfact , d7 ) ;
15789: LD_VAR 0 2
15793: PPUSH
15794: LD_LOC 22
15798: PPUSH
15799: CALL 14492 0 2
// end ; end ;
15803: GO 15806
15805: POP
// enable ;
15806: ENABLE
// end ;
15807: PPOPN 4
15809: END
// every 0 0$10 + 0 0$5.6 trigger IsOk ( factories [ 5 ] ) and IsIdle ( factories [ 5 ] ) do var a , tfact , def , att ;
15810: LD_EXP 73
15814: PUSH
15815: LD_INT 5
15817: ARRAY
15818: PPUSH
15819: CALL_OW 302
15823: PUSH
15824: LD_EXP 73
15828: PUSH
15829: LD_INT 5
15831: ARRAY
15832: PPUSH
15833: CALL_OW 316
15837: AND
15838: IFFALSE 16157
15840: GO 15842
15842: DISABLE
15843: LD_INT 0
15845: PPUSH
15846: PPUSH
15847: PPUSH
15848: PPUSH
// begin tfact := factories [ 5 ] ;
15849: LD_ADDR_VAR 0 2
15853: PUSH
15854: LD_EXP 73
15858: PUSH
15859: LD_INT 5
15861: ARRAY
15862: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 5 ] , [ mf_manu ] ) ;
15863: LD_ADDR_VAR 0 3
15867: PUSH
15868: LD_EXP 77
15872: PUSH
15873: LD_INT 5
15875: ARRAY
15876: PPUSH
15877: LD_EXP 61
15881: PUSH
15882: EMPTY
15883: LIST
15884: PPUSH
15885: CALL_OW 72
15889: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 5 ] , [ mf_comp ] ) ;
15890: LD_ADDR_VAR 0 4
15894: PUSH
15895: LD_EXP 77
15899: PUSH
15900: LD_INT 5
15902: ARRAY
15903: PPUSH
15904: LD_EXP 60
15908: PUSH
15909: EMPTY
15910: LIST
15911: PPUSH
15912: CALL_OW 72
15916: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15917: LD_INT 1
15919: PUSH
15920: LD_VAR 0 3
15924: PUSH
15925: LD_INT 2
15927: LESS
15928: PUSH
15929: LD_VAR 0 2
15933: PPUSH
15934: LD_LOC 18
15938: PPUSH
15939: CALL 14433 0 2
15943: AND
15944: DOUBLE
15945: EQUAL
15946: IFTRUE 15950
15948: GO 15967
15950: POP
// begin MyComConstruct ( tfact , d2 ) ;
15951: LD_VAR 0 2
15955: PPUSH
15956: LD_LOC 18
15960: PPUSH
15961: CALL 14492 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15965: GO 16156
15967: LD_VAR 0 3
15971: PUSH
15972: LD_INT 3
15974: LESS
15975: PUSH
15976: LD_VAR 0 2
15980: PPUSH
15981: LD_LOC 19
15985: PPUSH
15986: CALL 14433 0 2
15990: AND
15991: DOUBLE
15992: EQUAL
15993: IFTRUE 15997
15995: GO 16014
15997: POP
// begin MyComConstruct ( tfact , d3 ) ;
15998: LD_VAR 0 2
16002: PPUSH
16003: LD_LOC 19
16007: PPUSH
16008: CALL 14492 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
16012: GO 16156
16014: LD_VAR 0 4
16018: PUSH
16019: LD_INT 2
16021: LESS
16022: PUSH
16023: LD_VAR 0 2
16027: PPUSH
16028: LD_LOC 21
16032: PPUSH
16033: CALL 14433 0 2
16037: AND
16038: DOUBLE
16039: EQUAL
16040: IFTRUE 16044
16042: GO 16061
16044: POP
// begin MyComConstruct ( tfact , d6 ) ;
16045: LD_VAR 0 2
16049: PPUSH
16050: LD_LOC 21
16054: PPUSH
16055: CALL 14492 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
16059: GO 16156
16061: LD_VAR 0 4
16065: PUSH
16066: LD_INT 3
16068: LESS
16069: PUSH
16070: LD_VAR 0 2
16074: PPUSH
16075: LD_LOC 20
16079: PPUSH
16080: CALL 14433 0 2
16084: AND
16085: DOUBLE
16086: EQUAL
16087: IFTRUE 16091
16089: GO 16108
16091: POP
// begin MyComConstruct ( tfact , d5 ) ;
16092: LD_VAR 0 2
16096: PPUSH
16097: LD_LOC 20
16101: PPUSH
16102: CALL 14492 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
16106: GO 16156
16108: LD_VAR 0 4
16112: PUSH
16113: LD_INT 5
16115: LESS
16116: PUSH
16117: LD_VAR 0 2
16121: PPUSH
16122: LD_LOC 22
16126: PPUSH
16127: CALL 14433 0 2
16131: AND
16132: DOUBLE
16133: EQUAL
16134: IFTRUE 16138
16136: GO 16155
16138: POP
// begin MyComConstruct ( tfact , d7 ) ;
16139: LD_VAR 0 2
16143: PPUSH
16144: LD_LOC 22
16148: PPUSH
16149: CALL 14492 0 2
// end ; end ;
16153: GO 16156
16155: POP
// enable ;
16156: ENABLE
// end ; end_of_file
16157: PPOPN 4
16159: END
// var builds ; var aici ; var in_depots ; var abase ; export hlavouni ; var upgradeable ; var trough_upgrade ; export function inicializace_ai_b_build ; begin
16160: LD_INT 0
16162: PPUSH
// upgradeable := [ b_depot , b_workshop , b_armoury , b_lab , b_lab_half , b_lab ] ;
16163: LD_ADDR_LOC 27
16167: PUSH
16168: LD_INT 0
16170: PUSH
16171: LD_INT 2
16173: PUSH
16174: LD_INT 4
16176: PUSH
16177: LD_INT 6
16179: PUSH
16180: LD_INT 7
16182: PUSH
16183: LD_INT 6
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: LIST
16191: LIST
16192: LIST
16193: ST_TO_ADDR
// trough_upgrade := [ b_warehouse , b_factory , b_barracks , b_lab_half , b_lab_full , b_lab_full ] ;
16194: LD_ADDR_LOC 28
16198: PUSH
16199: LD_INT 1
16201: PUSH
16202: LD_INT 3
16204: PUSH
16205: LD_INT 5
16207: PUSH
16208: LD_INT 7
16210: PUSH
16211: LD_INT 8
16213: PUSH
16214: LD_INT 8
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: ST_TO_ADDR
// abase := [ abase1 , abase2 , abase3 , abase4 , abase5 ] ;
16225: LD_ADDR_LOC 26
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 4
16235: PUSH
16236: LD_INT 3
16238: PUSH
16239: LD_INT 2
16241: PUSH
16242: LD_INT 1
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: ST_TO_ADDR
// aici := [ [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 6 ] , [ 3 , class_scientistic , 6 ] , [ 8 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] , [ [ 1 , class_engineer , 8 ] , [ 3 , class_scientistic , 8 ] , [ 8 , class_soldier , 8 ] , [ 3 , class_mechanic , 8 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 3 , class_scientistic , 5 ] , [ 5 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 0 , class_scientistic , 4 ] , [ 2 , class_soldier , 4 ] , [ 1 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 4 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 4 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 4 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 1 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 1 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ] ;
16252: LD_ADDR_LOC 24
16256: PUSH
16257: LD_INT 1
16259: PUSH
16260: LD_INT 2
16262: PUSH
16263: LD_INT 4
16265: PUSH
16266: EMPTY
16267: LIST
16268: LIST
16269: LIST
16270: PUSH
16271: LD_INT 3
16273: PUSH
16274: LD_INT 4
16276: PUSH
16277: LD_INT 4
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: LIST
16284: PUSH
16285: LD_INT 8
16287: PUSH
16288: LD_INT 1
16290: PUSH
16291: LD_INT 4
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: LIST
16298: PUSH
16299: LD_INT 3
16301: PUSH
16302: LD_INT 3
16304: PUSH
16305: LD_INT 4
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: LIST
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: PUSH
16319: LD_INT 1
16321: PUSH
16322: LD_INT 2
16324: PUSH
16325: LD_INT 6
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: LIST
16332: PUSH
16333: LD_INT 3
16335: PUSH
16336: LD_INT 4
16338: PUSH
16339: LD_INT 6
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: LIST
16346: PUSH
16347: LD_INT 8
16349: PUSH
16350: LD_INT 1
16352: PUSH
16353: LD_INT 6
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: LIST
16360: PUSH
16361: LD_INT 3
16363: PUSH
16364: LD_INT 3
16366: PUSH
16367: LD_INT 6
16369: PUSH
16370: EMPTY
16371: LIST
16372: LIST
16373: LIST
16374: PUSH
16375: EMPTY
16376: LIST
16377: LIST
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 1
16383: PUSH
16384: LD_INT 2
16386: PUSH
16387: LD_INT 8
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: LIST
16394: PUSH
16395: LD_INT 3
16397: PUSH
16398: LD_INT 4
16400: PUSH
16401: LD_INT 8
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: LIST
16408: PUSH
16409: LD_INT 8
16411: PUSH
16412: LD_INT 1
16414: PUSH
16415: LD_INT 8
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: LIST
16422: PUSH
16423: LD_INT 3
16425: PUSH
16426: LD_INT 3
16428: PUSH
16429: LD_INT 8
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: LIST
16447: PUSH
16448: LD_OWVAR 67
16452: ARRAY
16453: PUSH
16454: LD_INT 1
16456: PUSH
16457: LD_INT 2
16459: PUSH
16460: LD_INT 4
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: LIST
16467: PUSH
16468: LD_INT 3
16470: PUSH
16471: LD_INT 4
16473: PUSH
16474: LD_INT 4
16476: PUSH
16477: EMPTY
16478: LIST
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 5
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: LD_INT 4
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 3
16498: PUSH
16499: LD_INT 3
16501: PUSH
16502: LD_INT 4
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: LIST
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 1
16518: PUSH
16519: LD_INT 2
16521: PUSH
16522: LD_INT 4
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 3
16532: PUSH
16533: LD_INT 4
16535: PUSH
16536: LD_INT 4
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: LIST
16543: PUSH
16544: LD_INT 5
16546: PUSH
16547: LD_INT 1
16549: PUSH
16550: LD_INT 4
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 3
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: LD_INT 4
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: LIST
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: LIST
16576: LIST
16577: PUSH
16578: LD_INT 1
16580: PUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 5
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: LIST
16591: PUSH
16592: LD_INT 3
16594: PUSH
16595: LD_INT 4
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: LIST
16605: PUSH
16606: LD_INT 5
16608: PUSH
16609: LD_INT 1
16611: PUSH
16612: LD_INT 5
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: LIST
16619: PUSH
16620: LD_INT 3
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 5
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PUSH
16645: LD_OWVAR 67
16649: ARRAY
16650: PUSH
16651: LD_INT 1
16653: PUSH
16654: LD_INT 2
16656: PUSH
16657: LD_INT 4
16659: PUSH
16660: EMPTY
16661: LIST
16662: LIST
16663: LIST
16664: PUSH
16665: LD_INT 0
16667: PUSH
16668: LD_INT 4
16670: PUSH
16671: LD_INT 4
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: LIST
16678: PUSH
16679: LD_INT 2
16681: PUSH
16682: LD_INT 1
16684: PUSH
16685: LD_INT 4
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: LD_INT 3
16698: PUSH
16699: LD_INT 4
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: LIST
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: LD_INT 2
16718: PUSH
16719: LD_INT 5
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: LIST
16726: PUSH
16727: LD_INT 0
16729: PUSH
16730: LD_INT 4
16732: PUSH
16733: LD_INT 5
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 1
16746: PUSH
16747: LD_INT 5
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: LIST
16754: PUSH
16755: LD_INT 1
16757: PUSH
16758: LD_INT 3
16760: PUSH
16761: LD_INT 5
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: LIST
16773: LIST
16774: PUSH
16775: LD_INT 1
16777: PUSH
16778: LD_INT 2
16780: PUSH
16781: LD_INT 5
16783: PUSH
16784: EMPTY
16785: LIST
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 0
16791: PUSH
16792: LD_INT 4
16794: PUSH
16795: LD_INT 5
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: LIST
16802: PUSH
16803: LD_INT 2
16805: PUSH
16806: LD_INT 1
16808: PUSH
16809: LD_INT 5
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: LIST
16816: PUSH
16817: LD_INT 1
16819: PUSH
16820: LD_INT 3
16822: PUSH
16823: LD_INT 5
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: LIST
16830: PUSH
16831: EMPTY
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: LIST
16841: PUSH
16842: LD_OWVAR 67
16846: ARRAY
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: LD_INT 2
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PUSH
16862: LD_INT 4
16864: PUSH
16865: LD_INT 4
16867: PUSH
16868: LD_INT 4
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: LIST
16875: PUSH
16876: LD_INT 3
16878: PUSH
16879: LD_INT 1
16881: PUSH
16882: LD_INT 4
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 3
16892: PUSH
16893: LD_INT 3
16895: PUSH
16896: LD_INT 4
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 1
16912: PUSH
16913: LD_INT 2
16915: PUSH
16916: LD_INT 5
16918: PUSH
16919: EMPTY
16920: LIST
16921: LIST
16922: LIST
16923: PUSH
16924: LD_INT 4
16926: PUSH
16927: LD_INT 4
16929: PUSH
16930: LD_INT 5
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: PUSH
16938: LD_INT 3
16940: PUSH
16941: LD_INT 1
16943: PUSH
16944: LD_INT 5
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: LIST
16951: PUSH
16952: LD_INT 3
16954: PUSH
16955: LD_INT 3
16957: PUSH
16958: LD_INT 5
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: LD_INT 2
16977: PUSH
16978: LD_INT 6
16980: PUSH
16981: EMPTY
16982: LIST
16983: LIST
16984: LIST
16985: PUSH
16986: LD_INT 4
16988: PUSH
16989: LD_INT 4
16991: PUSH
16992: LD_INT 6
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: LIST
16999: PUSH
17000: LD_INT 3
17002: PUSH
17003: LD_INT 1
17005: PUSH
17006: LD_INT 6
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: LIST
17013: PUSH
17014: LD_INT 3
17016: PUSH
17017: LD_INT 3
17019: PUSH
17020: LD_INT 6
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: LIST
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: LIST
17032: LIST
17033: PUSH
17034: EMPTY
17035: LIST
17036: LIST
17037: LIST
17038: PUSH
17039: LD_OWVAR 67
17043: ARRAY
17044: PUSH
17045: LD_INT 1
17047: PUSH
17048: LD_INT 2
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 1
17061: PUSH
17062: LD_INT 4
17064: PUSH
17065: LD_INT 4
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: LIST
17072: PUSH
17073: LD_INT 3
17075: PUSH
17076: LD_INT 1
17078: PUSH
17079: LD_INT 4
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: PUSH
17087: LD_INT 3
17089: PUSH
17090: LD_INT 3
17092: PUSH
17093: LD_INT 4
17095: PUSH
17096: EMPTY
17097: LIST
17098: LIST
17099: LIST
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: PUSH
17107: LD_INT 1
17109: PUSH
17110: LD_INT 2
17112: PUSH
17113: LD_INT 5
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 1
17123: PUSH
17124: LD_INT 4
17126: PUSH
17127: LD_INT 5
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 3
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 5
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 3
17151: PUSH
17152: LD_INT 3
17154: PUSH
17155: LD_INT 5
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: PUSH
17169: LD_INT 1
17171: PUSH
17172: LD_INT 2
17174: PUSH
17175: LD_INT 6
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: PUSH
17183: LD_INT 1
17185: PUSH
17186: LD_INT 4
17188: PUSH
17189: LD_INT 6
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: LIST
17196: PUSH
17197: LD_INT 3
17199: PUSH
17200: LD_INT 1
17202: PUSH
17203: LD_INT 6
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 3
17213: PUSH
17214: LD_INT 3
17216: PUSH
17217: LD_INT 6
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: LIST
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: LIST
17235: PUSH
17236: LD_OWVAR 67
17240: ARRAY
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: LIST
17246: LIST
17247: LIST
17248: ST_TO_ADDR
// builds := [ [ [ b_warehouse , 24 , 9 , 3 , [ ] ] , [ b_barracks , 39 , 26 , 5 , [ ] ] , [ b_siberite_power , 9 , 11 , 2 , [ ] ] , [ b_turret , 45 , 20 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 44 , 25 , 2 , [ ru_heavy_gun ] ] , [ b_turret , 26 , 40 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 37 , 39 , 2 , [ ru_heavy_gun ] ] , [ b_bunker , 42 , 21 , 2 , [ ru_gatling_gun ] ] , [ b_bunker , 38 , 36 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 53 , 15 , 2 , [ ru_rocket_launcher ] ] , [ b_lab_full , 10 , 7 , 2 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_full , 34 , 10 , 3 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_factory , 20 , 21 , 2 , [ ] ] , [ b_ext_gun , 24 , 21 , 4 , [ ] ] , [ b_ext_rocket , 20 , 18 , 3 , [ ] ] , [ b_ext_siberium , 20 , 25 , 0 , [ ] ] , [ b_ext_computer , 17 , 21 , 1 , [ ] ] , [ b_ext_track , 16 , 17 , 2 , [ ] ] , [ b_siberite_mine , 20 , 34 , 0 , [ ] ] , [ b_siberite_power , 15 , 5 , 2 , [ ] ] , [ b_oil_mine , 14 , 23 , 2 , [ ] ] , [ b_teleport , 32 , 20 , 3 , [ ] ] ] , [ [ b_factory , 98 , 26 , 5 , [ ] ] , [ b_barracks , 80 , 13 , 0 , [ ] ] , [ b_siberite_power , 97 , 3 , 1 , [ ] ] , [ b_turret , 105 , 35 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 111 , 22 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 115 , 27 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 65 , 3 , 3 , [ ru_rocket_launcher ] , 20 20$0 ] , [ b_turret , 68 , 3 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 71 , 4 , 3 , [ ru_heavy_gun ] ] , [ b_siberite_power , 101 , 4 , 5 , [ ] ] , [ b_turret , 108 , 35 , 2 , [ ru_heavy_gun ] ] , [ b_ext_track , 101 , 26 , 4 , [ ] ] , [ b_ext_gun , 98 , 22 , 3 , [ ] ] , [ b_ext_siberium , 94 , 26 , 1 , [ ] ] , [ b_ext_rocket , 98 , 29 , 0 , [ ] ] , [ b_ext_noncombat , 102 , 30 , 5 , [ ] ] , [ b_warehouse , 86 , 6 , 3 , [ ] ] , [ b_siberite_mine , 102 , 9 , 4 , [ ] ] , [ b_oil_mine , 77 , 3 , 4 , [ ] ] , [ b_lab_full , 100 , 17 , 4 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_half , 94 , 6 , 3 , [ b_lab_computer , b_lab_basic ] ] ] , [ [ b_warehouse , 90 , 141 , 0 , [ ] ] , [ b_barracks , 98 , 133 , 4 , [ ] ] , [ b_siberite_power , 72 , 133 , 2 , [ ] ] , [ b_bunker , 95 , 128 , 0 , [ ru_rocket_launcher ] ] , [ b_bunker , 80 , 122 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 95 , 128 , 0 , [ ru_rocket_launcher ] , 15 15$0 ] , [ b_turret , 80 , 122 , 2 , [ ru_rocket_launcher ] , 17 17$0 ] , [ b_turret , 112 , 154 , 1 , [ ru_rocket_launcher ] , 16 16$0 ] , [ b_turret , 78 , 124 , 2 , [ ru_heavy_gun ] , 20 20$0 ] , [ b_turret , 99 , 130 , 1 , [ ru_heavy_gun ] , 22 22$0 ] , [ b_turret , 112 , 151 , 1 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_factory , 81 , 135 , 5 , [ ] ] , [ b_ext_siberium , 84 , 135 , 4 , [ ] ] , [ b_ext_gun , 85 , 139 , 5 , [ ] ] , [ b_ext_track , 77 , 135 , 1 , [ ] ] , [ b_ext_rocket , 81 , 138 , 0 , [ ] , 14 14$0 ] , [ b_siberite_mine , 71 , 137 , 0 , [ ] ] , [ b_oil_mine , 69 , 133 , 5 , [ ] ] , [ b_lab_half , 102 , 153 , 0 , [ b_lab_computer , b_lab_basic ] , 35 35$0 ] , [ b_lab_full , 97 , 145 , 2 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 74 , 137 , 2 , [ ] ] , [ b_ext_computer , 81 , 131 , 3 , [ ] ] ] , [ [ b_warehouse , 217 , 129 , 3 , [ ] ] , [ b_siberite_power , 233 , 154 , 4 , [ ] ] , [ b_turret , 205 , 123 , 0 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_turret , 200 , 142 , 4 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 135 , 4 , [ ru_heavy_gun ] , 28 28$0 ] , [ b_turret , 201 , 127 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 138 , 4 , [ ru_rocket_launcher ] ] , [ b_turret , 202 , 124 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 209 , 154 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 218 , 123 , 5 , [ ru_rocket_launcher ] ] , [ b_lab_full , 227 , 145 , 2 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_lab_full , 221 , 153 , 4 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 231 , 155 , 4 , [ ] ] , [ b_oil_mine , 224 , 134 , 4 , [ ] ] , [ b_siberite_mine , 224 , 150 , 2 , [ ] ] , [ b_factory , 207 , 141 , 1 , [ ] ] , [ b_ext_computer , 211 , 145 , 5 , [ ] ] , [ b_ext_siberium , 207 , 144 , 0 , [ ] ] , [ b_ext_rocket , 203 , 141 , 1 , [ ] ] , [ b_ext_track , 204 , 138 , 2 , [ ] ] , [ b_ext_gun , 207 , 137 , 3 , [ ] ] , [ b_armoury , 210 , 128 , 2 , [ ] , 35 35$0 ] , [ b_armoury , 210 , 128 , 2 , [ ] ] ] , [ [ b_warehouse , 184 , 73 , 3 , [ ] ] , [ b_barracks , 188 , 94 , 5 , [ ] ] , [ b_turret , 171 , 92 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 177 , 98 , 3 , [ ru_heavy_gun ] ] , [ b_turret , 169 , 69 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 170 , 66 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 184 , 62 , 5 , [ ru_gatling_gun ] ] , [ b_turret , 203 , 102 , 2 , [ ru_rocket_launcher ] , 30 30$0 ] , [ b_turret , 195 , 103 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 200 , 103 , 2 , [ ru_heavy_gun ] ] , [ b_siberite_power , 198 , 90 , 3 , [ ] ] , [ b_siberite_mine , 179 , 70 , 1 , [ ] ] , [ b_factory , 190 , 84 , 4 , [ ] ] , [ b_ext_gun , 190 , 88 , 0 , [ ] ] , [ b_ext_rocket , 193 , 87 , 5 , [ ] ] , [ b_ext_siberium , 194 , 84 , 4 , [ ] ] , [ b_ext_computer , 190 , 81 , 3 , [ ] ] , [ b_lab_full , 176 , 92 , 0 , [ b_lab_siberium , b_lab_basic ] ] , [ b_lab_full , 176 , 82 , 3 , [ b_lab_computer , b_lab_weapon ] ] , [ b_siberite_power , 196 , 92 , 5 , [ ] ] , [ b_siberite_power , 198 , 86 , 1 , [ ] ] , [ b_siberite_mine , 192 , 93 , 0 , [ ] ] ] ] ;
17249: LD_ADDR_LOC 23
17253: PUSH
17254: LD_INT 1
17256: PUSH
17257: LD_INT 24
17259: PUSH
17260: LD_INT 9
17262: PUSH
17263: LD_INT 3
17265: PUSH
17266: EMPTY
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: LIST
17272: LIST
17273: LIST
17274: PUSH
17275: LD_INT 5
17277: PUSH
17278: LD_INT 39
17280: PUSH
17281: LD_INT 26
17283: PUSH
17284: LD_INT 5
17286: PUSH
17287: EMPTY
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: LIST
17293: LIST
17294: LIST
17295: PUSH
17296: LD_INT 28
17298: PUSH
17299: LD_INT 9
17301: PUSH
17302: LD_INT 11
17304: PUSH
17305: LD_INT 2
17307: PUSH
17308: EMPTY
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: LIST
17314: LIST
17315: LIST
17316: PUSH
17317: LD_INT 33
17319: PUSH
17320: LD_INT 45
17322: PUSH
17323: LD_INT 20
17325: PUSH
17326: LD_INT 2
17328: PUSH
17329: LD_INT 45
17331: PUSH
17332: EMPTY
17333: LIST
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: PUSH
17342: LD_INT 33
17344: PUSH
17345: LD_INT 44
17347: PUSH
17348: LD_INT 25
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 46
17356: PUSH
17357: EMPTY
17358: LIST
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: LIST
17364: LIST
17365: LIST
17366: PUSH
17367: LD_INT 33
17369: PUSH
17370: LD_INT 26
17372: PUSH
17373: LD_INT 40
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: LD_INT 45
17381: PUSH
17382: EMPTY
17383: LIST
17384: PUSH
17385: EMPTY
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: PUSH
17392: LD_INT 33
17394: PUSH
17395: LD_INT 37
17397: PUSH
17398: LD_INT 39
17400: PUSH
17401: LD_INT 2
17403: PUSH
17404: LD_INT 46
17406: PUSH
17407: EMPTY
17408: LIST
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: LIST
17414: LIST
17415: LIST
17416: PUSH
17417: LD_INT 32
17419: PUSH
17420: LD_INT 42
17422: PUSH
17423: LD_INT 21
17425: PUSH
17426: LD_INT 2
17428: PUSH
17429: LD_INT 43
17431: PUSH
17432: EMPTY
17433: LIST
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: LIST
17439: LIST
17440: LIST
17441: PUSH
17442: LD_INT 32
17444: PUSH
17445: LD_INT 38
17447: PUSH
17448: LD_INT 36
17450: PUSH
17451: LD_INT 2
17453: PUSH
17454: LD_INT 43
17456: PUSH
17457: EMPTY
17458: LIST
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: LIST
17465: LIST
17466: PUSH
17467: LD_INT 33
17469: PUSH
17470: LD_INT 53
17472: PUSH
17473: LD_INT 15
17475: PUSH
17476: LD_INT 2
17478: PUSH
17479: LD_INT 45
17481: PUSH
17482: EMPTY
17483: LIST
17484: PUSH
17485: EMPTY
17486: LIST
17487: LIST
17488: LIST
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 8
17494: PUSH
17495: LD_INT 10
17497: PUSH
17498: LD_INT 7
17500: PUSH
17501: LD_INT 2
17503: PUSH
17504: LD_INT 11
17506: PUSH
17507: LD_INT 10
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: PUSH
17521: LD_INT 8
17523: PUSH
17524: LD_INT 34
17526: PUSH
17527: LD_INT 10
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 12
17535: PUSH
17536: LD_INT 14
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: LIST
17547: LIST
17548: LIST
17549: PUSH
17550: LD_INT 3
17552: PUSH
17553: LD_INT 20
17555: PUSH
17556: LD_INT 21
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: EMPTY
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: PUSH
17571: LD_INT 17
17573: PUSH
17574: LD_INT 24
17576: PUSH
17577: LD_INT 21
17579: PUSH
17580: LD_INT 4
17582: PUSH
17583: EMPTY
17584: PUSH
17585: EMPTY
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: PUSH
17592: LD_INT 18
17594: PUSH
17595: LD_INT 20
17597: PUSH
17598: LD_INT 18
17600: PUSH
17601: LD_INT 3
17603: PUSH
17604: EMPTY
17605: PUSH
17606: EMPTY
17607: LIST
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: PUSH
17613: LD_INT 21
17615: PUSH
17616: LD_INT 20
17618: PUSH
17619: LD_INT 25
17621: PUSH
17622: LD_INT 0
17624: PUSH
17625: EMPTY
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: LIST
17631: LIST
17632: LIST
17633: PUSH
17634: LD_INT 24
17636: PUSH
17637: LD_INT 17
17639: PUSH
17640: LD_INT 21
17642: PUSH
17643: LD_INT 1
17645: PUSH
17646: EMPTY
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: PUSH
17655: LD_INT 16
17657: PUSH
17658: LD_INT 16
17660: PUSH
17661: LD_INT 17
17663: PUSH
17664: LD_INT 2
17666: PUSH
17667: EMPTY
17668: PUSH
17669: EMPTY
17670: LIST
17671: LIST
17672: LIST
17673: LIST
17674: LIST
17675: PUSH
17676: LD_INT 30
17678: PUSH
17679: LD_INT 20
17681: PUSH
17682: LD_INT 34
17684: PUSH
17685: LD_INT 0
17687: PUSH
17688: EMPTY
17689: PUSH
17690: EMPTY
17691: LIST
17692: LIST
17693: LIST
17694: LIST
17695: LIST
17696: PUSH
17697: LD_INT 28
17699: PUSH
17700: LD_INT 15
17702: PUSH
17703: LD_INT 5
17705: PUSH
17706: LD_INT 2
17708: PUSH
17709: EMPTY
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: LIST
17715: LIST
17716: LIST
17717: PUSH
17718: LD_INT 29
17720: PUSH
17721: LD_INT 14
17723: PUSH
17724: LD_INT 23
17726: PUSH
17727: LD_INT 2
17729: PUSH
17730: EMPTY
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: PUSH
17739: LD_INT 34
17741: PUSH
17742: LD_INT 32
17744: PUSH
17745: LD_INT 20
17747: PUSH
17748: LD_INT 3
17750: PUSH
17751: EMPTY
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: LIST
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: PUSH
17784: LD_INT 3
17786: PUSH
17787: LD_INT 98
17789: PUSH
17790: LD_INT 26
17792: PUSH
17793: LD_INT 5
17795: PUSH
17796: EMPTY
17797: PUSH
17798: EMPTY
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: PUSH
17805: LD_INT 5
17807: PUSH
17808: LD_INT 80
17810: PUSH
17811: LD_INT 13
17813: PUSH
17814: LD_INT 0
17816: PUSH
17817: EMPTY
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: LIST
17824: LIST
17825: PUSH
17826: LD_INT 28
17828: PUSH
17829: LD_INT 97
17831: PUSH
17832: LD_INT 3
17834: PUSH
17835: LD_INT 1
17837: PUSH
17838: EMPTY
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: PUSH
17847: LD_INT 33
17849: PUSH
17850: LD_INT 105
17852: PUSH
17853: LD_INT 35
17855: PUSH
17856: LD_INT 3
17858: PUSH
17859: LD_INT 45
17861: PUSH
17862: EMPTY
17863: LIST
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: LIST
17869: LIST
17870: LIST
17871: PUSH
17872: LD_INT 33
17874: PUSH
17875: LD_INT 111
17877: PUSH
17878: LD_INT 22
17880: PUSH
17881: LD_INT 2
17883: PUSH
17884: LD_INT 43
17886: PUSH
17887: EMPTY
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: PUSH
17897: LD_INT 33
17899: PUSH
17900: LD_INT 115
17902: PUSH
17903: LD_INT 27
17905: PUSH
17906: LD_INT 2
17908: PUSH
17909: LD_INT 45
17911: PUSH
17912: EMPTY
17913: LIST
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: LIST
17919: LIST
17920: LIST
17921: PUSH
17922: LD_INT 33
17924: PUSH
17925: LD_INT 65
17927: PUSH
17928: LD_INT 3
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 45
17936: PUSH
17937: EMPTY
17938: LIST
17939: PUSH
17940: LD_INT 42000
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: LIST
17949: LIST
17950: PUSH
17951: LD_INT 33
17953: PUSH
17954: LD_INT 68
17956: PUSH
17957: LD_INT 3
17959: PUSH
17960: LD_INT 3
17962: PUSH
17963: LD_INT 45
17965: PUSH
17966: EMPTY
17967: LIST
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: PUSH
17976: LD_INT 33
17978: PUSH
17979: LD_INT 71
17981: PUSH
17982: LD_INT 4
17984: PUSH
17985: LD_INT 3
17987: PUSH
17988: LD_INT 46
17990: PUSH
17991: EMPTY
17992: LIST
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: PUSH
18001: LD_INT 28
18003: PUSH
18004: LD_INT 101
18006: PUSH
18007: LD_INT 4
18009: PUSH
18010: LD_INT 5
18012: PUSH
18013: EMPTY
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: PUSH
18022: LD_INT 33
18024: PUSH
18025: LD_INT 108
18027: PUSH
18028: LD_INT 35
18030: PUSH
18031: LD_INT 2
18033: PUSH
18034: LD_INT 46
18036: PUSH
18037: EMPTY
18038: LIST
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: PUSH
18047: LD_INT 16
18049: PUSH
18050: LD_INT 101
18052: PUSH
18053: LD_INT 26
18055: PUSH
18056: LD_INT 4
18058: PUSH
18059: EMPTY
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: PUSH
18068: LD_INT 17
18070: PUSH
18071: LD_INT 98
18073: PUSH
18074: LD_INT 22
18076: PUSH
18077: LD_INT 3
18079: PUSH
18080: EMPTY
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PUSH
18089: LD_INT 21
18091: PUSH
18092: LD_INT 94
18094: PUSH
18095: LD_INT 26
18097: PUSH
18098: LD_INT 1
18100: PUSH
18101: EMPTY
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: PUSH
18110: LD_INT 18
18112: PUSH
18113: LD_INT 98
18115: PUSH
18116: LD_INT 29
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: EMPTY
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: LIST
18130: PUSH
18131: LD_INT 19
18133: PUSH
18134: LD_INT 102
18136: PUSH
18137: LD_INT 30
18139: PUSH
18140: LD_INT 5
18142: PUSH
18143: EMPTY
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: LIST
18151: PUSH
18152: LD_INT 1
18154: PUSH
18155: LD_INT 86
18157: PUSH
18158: LD_INT 6
18160: PUSH
18161: LD_INT 3
18163: PUSH
18164: EMPTY
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 30
18175: PUSH
18176: LD_INT 102
18178: PUSH
18179: LD_INT 9
18181: PUSH
18182: LD_INT 4
18184: PUSH
18185: EMPTY
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: PUSH
18194: LD_INT 29
18196: PUSH
18197: LD_INT 77
18199: PUSH
18200: LD_INT 3
18202: PUSH
18203: LD_INT 4
18205: PUSH
18206: EMPTY
18207: PUSH
18208: EMPTY
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: PUSH
18215: LD_INT 8
18217: PUSH
18218: LD_INT 100
18220: PUSH
18221: LD_INT 17
18223: PUSH
18224: LD_INT 4
18226: PUSH
18227: LD_INT 11
18229: PUSH
18230: LD_INT 10
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: PUSH
18244: LD_INT 7
18246: PUSH
18247: LD_INT 94
18249: PUSH
18250: LD_INT 6
18252: PUSH
18253: LD_INT 3
18255: PUSH
18256: LD_INT 12
18258: PUSH
18259: LD_INT 9
18261: PUSH
18262: EMPTY
18263: LIST
18264: LIST
18265: PUSH
18266: EMPTY
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: LIST
18281: LIST
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: PUSH
18296: LD_INT 1
18298: PUSH
18299: LD_INT 90
18301: PUSH
18302: LD_INT 141
18304: PUSH
18305: LD_INT 0
18307: PUSH
18308: EMPTY
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: PUSH
18317: LD_INT 5
18319: PUSH
18320: LD_INT 98
18322: PUSH
18323: LD_INT 133
18325: PUSH
18326: LD_INT 4
18328: PUSH
18329: EMPTY
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: LIST
18337: PUSH
18338: LD_INT 28
18340: PUSH
18341: LD_INT 72
18343: PUSH
18344: LD_INT 133
18346: PUSH
18347: LD_INT 2
18349: PUSH
18350: EMPTY
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 32
18361: PUSH
18362: LD_INT 95
18364: PUSH
18365: LD_INT 128
18367: PUSH
18368: LD_INT 0
18370: PUSH
18371: LD_INT 45
18373: PUSH
18374: EMPTY
18375: LIST
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: PUSH
18384: LD_INT 32
18386: PUSH
18387: LD_INT 80
18389: PUSH
18390: LD_INT 122
18392: PUSH
18393: LD_INT 2
18395: PUSH
18396: LD_INT 45
18398: PUSH
18399: EMPTY
18400: LIST
18401: PUSH
18402: EMPTY
18403: LIST
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: PUSH
18409: LD_INT 33
18411: PUSH
18412: LD_INT 95
18414: PUSH
18415: LD_INT 128
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 45
18423: PUSH
18424: EMPTY
18425: LIST
18426: PUSH
18427: LD_INT 31500
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: PUSH
18438: LD_INT 33
18440: PUSH
18441: LD_INT 80
18443: PUSH
18444: LD_INT 122
18446: PUSH
18447: LD_INT 2
18449: PUSH
18450: LD_INT 45
18452: PUSH
18453: EMPTY
18454: LIST
18455: PUSH
18456: LD_INT 35700
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: LIST
18466: PUSH
18467: LD_INT 33
18469: PUSH
18470: LD_INT 112
18472: PUSH
18473: LD_INT 154
18475: PUSH
18476: LD_INT 1
18478: PUSH
18479: LD_INT 45
18481: PUSH
18482: EMPTY
18483: LIST
18484: PUSH
18485: LD_INT 33600
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: LIST
18494: LIST
18495: PUSH
18496: LD_INT 33
18498: PUSH
18499: LD_INT 78
18501: PUSH
18502: LD_INT 124
18504: PUSH
18505: LD_INT 2
18507: PUSH
18508: LD_INT 46
18510: PUSH
18511: EMPTY
18512: LIST
18513: PUSH
18514: LD_INT 42000
18516: PUSH
18517: EMPTY
18518: LIST
18519: LIST
18520: LIST
18521: LIST
18522: LIST
18523: LIST
18524: PUSH
18525: LD_INT 33
18527: PUSH
18528: LD_INT 99
18530: PUSH
18531: LD_INT 130
18533: PUSH
18534: LD_INT 1
18536: PUSH
18537: LD_INT 46
18539: PUSH
18540: EMPTY
18541: LIST
18542: PUSH
18543: LD_INT 46200
18545: PUSH
18546: EMPTY
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: PUSH
18554: LD_INT 33
18556: PUSH
18557: LD_INT 112
18559: PUSH
18560: LD_INT 151
18562: PUSH
18563: LD_INT 1
18565: PUSH
18566: LD_INT 43
18568: PUSH
18569: EMPTY
18570: LIST
18571: PUSH
18572: LD_INT 52500
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: PUSH
18583: LD_INT 3
18585: PUSH
18586: LD_INT 81
18588: PUSH
18589: LD_INT 135
18591: PUSH
18592: LD_INT 5
18594: PUSH
18595: EMPTY
18596: PUSH
18597: EMPTY
18598: LIST
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 21
18606: PUSH
18607: LD_INT 84
18609: PUSH
18610: LD_INT 135
18612: PUSH
18613: LD_INT 4
18615: PUSH
18616: EMPTY
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: PUSH
18625: LD_INT 17
18627: PUSH
18628: LD_INT 85
18630: PUSH
18631: LD_INT 139
18633: PUSH
18634: LD_INT 5
18636: PUSH
18637: EMPTY
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 16
18648: PUSH
18649: LD_INT 77
18651: PUSH
18652: LD_INT 135
18654: PUSH
18655: LD_INT 1
18657: PUSH
18658: EMPTY
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 18
18669: PUSH
18670: LD_INT 81
18672: PUSH
18673: LD_INT 138
18675: PUSH
18676: LD_INT 0
18678: PUSH
18679: EMPTY
18680: PUSH
18681: LD_INT 29400
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: PUSH
18692: LD_INT 30
18694: PUSH
18695: LD_INT 71
18697: PUSH
18698: LD_INT 137
18700: PUSH
18701: LD_INT 0
18703: PUSH
18704: EMPTY
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: PUSH
18713: LD_INT 29
18715: PUSH
18716: LD_INT 69
18718: PUSH
18719: LD_INT 133
18721: PUSH
18722: LD_INT 5
18724: PUSH
18725: EMPTY
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: LIST
18733: PUSH
18734: LD_INT 7
18736: PUSH
18737: LD_INT 102
18739: PUSH
18740: LD_INT 153
18742: PUSH
18743: LD_INT 0
18745: PUSH
18746: LD_INT 12
18748: PUSH
18749: LD_INT 9
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: LD_INT 73500
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 8
18769: PUSH
18770: LD_INT 97
18772: PUSH
18773: LD_INT 145
18775: PUSH
18776: LD_INT 2
18778: PUSH
18779: LD_INT 10
18781: PUSH
18782: LD_INT 11
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: PUSH
18796: LD_INT 28
18798: PUSH
18799: LD_INT 74
18801: PUSH
18802: LD_INT 137
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: EMPTY
18809: PUSH
18810: EMPTY
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 24
18819: PUSH
18820: LD_INT 81
18822: PUSH
18823: LD_INT 131
18825: PUSH
18826: LD_INT 3
18828: PUSH
18829: EMPTY
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: LIST
18861: PUSH
18862: LD_INT 1
18864: PUSH
18865: LD_INT 217
18867: PUSH
18868: LD_INT 129
18870: PUSH
18871: LD_INT 3
18873: PUSH
18874: EMPTY
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: LIST
18880: LIST
18881: LIST
18882: PUSH
18883: LD_INT 28
18885: PUSH
18886: LD_INT 233
18888: PUSH
18889: LD_INT 154
18891: PUSH
18892: LD_INT 4
18894: PUSH
18895: EMPTY
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: LIST
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 33
18906: PUSH
18907: LD_INT 205
18909: PUSH
18910: LD_INT 123
18912: PUSH
18913: LD_INT 0
18915: PUSH
18916: LD_INT 43
18918: PUSH
18919: EMPTY
18920: LIST
18921: PUSH
18922: LD_INT 52500
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: PUSH
18933: LD_INT 33
18935: PUSH
18936: LD_INT 200
18938: PUSH
18939: LD_INT 142
18941: PUSH
18942: LD_INT 4
18944: PUSH
18945: LD_INT 46
18947: PUSH
18948: EMPTY
18949: LIST
18950: PUSH
18951: EMPTY
18952: LIST
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: PUSH
18958: LD_INT 33
18960: PUSH
18961: LD_INT 199
18963: PUSH
18964: LD_INT 135
18966: PUSH
18967: LD_INT 4
18969: PUSH
18970: LD_INT 46
18972: PUSH
18973: EMPTY
18974: LIST
18975: PUSH
18976: LD_INT 58800
18978: PUSH
18979: EMPTY
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: PUSH
18987: LD_INT 33
18989: PUSH
18990: LD_INT 201
18992: PUSH
18993: LD_INT 127
18995: PUSH
18996: LD_INT 5
18998: PUSH
18999: LD_INT 46
19001: PUSH
19002: EMPTY
19003: LIST
19004: PUSH
19005: EMPTY
19006: LIST
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: PUSH
19012: LD_INT 33
19014: PUSH
19015: LD_INT 199
19017: PUSH
19018: LD_INT 138
19020: PUSH
19021: LD_INT 4
19023: PUSH
19024: LD_INT 45
19026: PUSH
19027: EMPTY
19028: LIST
19029: PUSH
19030: EMPTY
19031: LIST
19032: LIST
19033: LIST
19034: LIST
19035: LIST
19036: PUSH
19037: LD_INT 33
19039: PUSH
19040: LD_INT 202
19042: PUSH
19043: LD_INT 124
19045: PUSH
19046: LD_INT 5
19048: PUSH
19049: LD_INT 45
19051: PUSH
19052: EMPTY
19053: LIST
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: PUSH
19062: LD_INT 33
19064: PUSH
19065: LD_INT 209
19067: PUSH
19068: LD_INT 154
19070: PUSH
19071: LD_INT 3
19073: PUSH
19074: LD_INT 45
19076: PUSH
19077: EMPTY
19078: LIST
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: LIST
19084: LIST
19085: LIST
19086: PUSH
19087: LD_INT 33
19089: PUSH
19090: LD_INT 218
19092: PUSH
19093: LD_INT 123
19095: PUSH
19096: LD_INT 5
19098: PUSH
19099: LD_INT 45
19101: PUSH
19102: EMPTY
19103: LIST
19104: PUSH
19105: EMPTY
19106: LIST
19107: LIST
19108: LIST
19109: LIST
19110: LIST
19111: PUSH
19112: LD_INT 8
19114: PUSH
19115: LD_INT 227
19117: PUSH
19118: LD_INT 145
19120: PUSH
19121: LD_INT 2
19123: PUSH
19124: LD_INT 12
19126: PUSH
19127: LD_INT 14
19129: PUSH
19130: EMPTY
19131: LIST
19132: LIST
19133: PUSH
19134: EMPTY
19135: LIST
19136: LIST
19137: LIST
19138: LIST
19139: LIST
19140: PUSH
19141: LD_INT 8
19143: PUSH
19144: LD_INT 221
19146: PUSH
19147: LD_INT 153
19149: PUSH
19150: LD_INT 4
19152: PUSH
19153: LD_INT 10
19155: PUSH
19156: LD_INT 11
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: PUSH
19163: EMPTY
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: PUSH
19170: LD_INT 28
19172: PUSH
19173: LD_INT 231
19175: PUSH
19176: LD_INT 155
19178: PUSH
19179: LD_INT 4
19181: PUSH
19182: EMPTY
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: PUSH
19191: LD_INT 29
19193: PUSH
19194: LD_INT 224
19196: PUSH
19197: LD_INT 134
19199: PUSH
19200: LD_INT 4
19202: PUSH
19203: EMPTY
19204: PUSH
19205: EMPTY
19206: LIST
19207: LIST
19208: LIST
19209: LIST
19210: LIST
19211: PUSH
19212: LD_INT 30
19214: PUSH
19215: LD_INT 224
19217: PUSH
19218: LD_INT 150
19220: PUSH
19221: LD_INT 2
19223: PUSH
19224: EMPTY
19225: PUSH
19226: EMPTY
19227: LIST
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: PUSH
19233: LD_INT 3
19235: PUSH
19236: LD_INT 207
19238: PUSH
19239: LD_INT 141
19241: PUSH
19242: LD_INT 1
19244: PUSH
19245: EMPTY
19246: PUSH
19247: EMPTY
19248: LIST
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: PUSH
19254: LD_INT 24
19256: PUSH
19257: LD_INT 211
19259: PUSH
19260: LD_INT 145
19262: PUSH
19263: LD_INT 5
19265: PUSH
19266: EMPTY
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: LIST
19272: LIST
19273: LIST
19274: PUSH
19275: LD_INT 21
19277: PUSH
19278: LD_INT 207
19280: PUSH
19281: LD_INT 144
19283: PUSH
19284: LD_INT 0
19286: PUSH
19287: EMPTY
19288: PUSH
19289: EMPTY
19290: LIST
19291: LIST
19292: LIST
19293: LIST
19294: LIST
19295: PUSH
19296: LD_INT 18
19298: PUSH
19299: LD_INT 203
19301: PUSH
19302: LD_INT 141
19304: PUSH
19305: LD_INT 1
19307: PUSH
19308: EMPTY
19309: PUSH
19310: EMPTY
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 16
19319: PUSH
19320: LD_INT 204
19322: PUSH
19323: LD_INT 138
19325: PUSH
19326: LD_INT 2
19328: PUSH
19329: EMPTY
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: LIST
19336: LIST
19337: PUSH
19338: LD_INT 17
19340: PUSH
19341: LD_INT 207
19343: PUSH
19344: LD_INT 137
19346: PUSH
19347: LD_INT 3
19349: PUSH
19350: EMPTY
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: PUSH
19359: LD_INT 4
19361: PUSH
19362: LD_INT 210
19364: PUSH
19365: LD_INT 128
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: EMPTY
19372: PUSH
19373: LD_INT 73500
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: PUSH
19384: LD_INT 4
19386: PUSH
19387: LD_INT 210
19389: PUSH
19390: LD_INT 128
19392: PUSH
19393: LD_INT 2
19395: PUSH
19396: EMPTY
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: PUSH
19430: LD_INT 1
19432: PUSH
19433: LD_INT 184
19435: PUSH
19436: LD_INT 73
19438: PUSH
19439: LD_INT 3
19441: PUSH
19442: EMPTY
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: PUSH
19451: LD_INT 5
19453: PUSH
19454: LD_INT 188
19456: PUSH
19457: LD_INT 94
19459: PUSH
19460: LD_INT 5
19462: PUSH
19463: EMPTY
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: LIST
19469: LIST
19470: LIST
19471: PUSH
19472: LD_INT 33
19474: PUSH
19475: LD_INT 171
19477: PUSH
19478: LD_INT 92
19480: PUSH
19481: LD_INT 3
19483: PUSH
19484: LD_INT 45
19486: PUSH
19487: EMPTY
19488: LIST
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: PUSH
19497: LD_INT 33
19499: PUSH
19500: LD_INT 177
19502: PUSH
19503: LD_INT 98
19505: PUSH
19506: LD_INT 3
19508: PUSH
19509: LD_INT 46
19511: PUSH
19512: EMPTY
19513: LIST
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: PUSH
19522: LD_INT 33
19524: PUSH
19525: LD_INT 169
19527: PUSH
19528: LD_INT 69
19530: PUSH
19531: LD_INT 5
19533: PUSH
19534: LD_INT 46
19536: PUSH
19537: EMPTY
19538: LIST
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: LIST
19546: PUSH
19547: LD_INT 33
19549: PUSH
19550: LD_INT 170
19552: PUSH
19553: LD_INT 66
19555: PUSH
19556: LD_INT 5
19558: PUSH
19559: LD_INT 45
19561: PUSH
19562: EMPTY
19563: LIST
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: PUSH
19572: LD_INT 33
19574: PUSH
19575: LD_INT 184
19577: PUSH
19578: LD_INT 62
19580: PUSH
19581: LD_INT 5
19583: PUSH
19584: LD_INT 43
19586: PUSH
19587: EMPTY
19588: LIST
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: LIST
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 33
19599: PUSH
19600: LD_INT 203
19602: PUSH
19603: LD_INT 102
19605: PUSH
19606: LD_INT 2
19608: PUSH
19609: LD_INT 45
19611: PUSH
19612: EMPTY
19613: LIST
19614: PUSH
19615: LD_INT 63000
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: PUSH
19626: LD_INT 33
19628: PUSH
19629: LD_INT 195
19631: PUSH
19632: LD_INT 103
19634: PUSH
19635: LD_INT 2
19637: PUSH
19638: LD_INT 45
19640: PUSH
19641: EMPTY
19642: LIST
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: PUSH
19651: LD_INT 33
19653: PUSH
19654: LD_INT 200
19656: PUSH
19657: LD_INT 103
19659: PUSH
19660: LD_INT 2
19662: PUSH
19663: LD_INT 46
19665: PUSH
19666: EMPTY
19667: LIST
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: PUSH
19676: LD_INT 28
19678: PUSH
19679: LD_INT 198
19681: PUSH
19682: LD_INT 90
19684: PUSH
19685: LD_INT 3
19687: PUSH
19688: EMPTY
19689: PUSH
19690: EMPTY
19691: LIST
19692: LIST
19693: LIST
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 30
19699: PUSH
19700: LD_INT 179
19702: PUSH
19703: LD_INT 70
19705: PUSH
19706: LD_INT 1
19708: PUSH
19709: EMPTY
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: PUSH
19718: LD_INT 3
19720: PUSH
19721: LD_INT 190
19723: PUSH
19724: LD_INT 84
19726: PUSH
19727: LD_INT 4
19729: PUSH
19730: EMPTY
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: PUSH
19739: LD_INT 17
19741: PUSH
19742: LD_INT 190
19744: PUSH
19745: LD_INT 88
19747: PUSH
19748: LD_INT 0
19750: PUSH
19751: EMPTY
19752: PUSH
19753: EMPTY
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: PUSH
19760: LD_INT 18
19762: PUSH
19763: LD_INT 193
19765: PUSH
19766: LD_INT 87
19768: PUSH
19769: LD_INT 5
19771: PUSH
19772: EMPTY
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 21
19783: PUSH
19784: LD_INT 194
19786: PUSH
19787: LD_INT 84
19789: PUSH
19790: LD_INT 4
19792: PUSH
19793: EMPTY
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 24
19804: PUSH
19805: LD_INT 190
19807: PUSH
19808: LD_INT 81
19810: PUSH
19811: LD_INT 3
19813: PUSH
19814: EMPTY
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: LIST
19820: LIST
19821: LIST
19822: PUSH
19823: LD_INT 8
19825: PUSH
19826: LD_INT 176
19828: PUSH
19829: LD_INT 92
19831: PUSH
19832: LD_INT 0
19834: PUSH
19835: LD_INT 11
19837: PUSH
19838: LD_INT 9
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: PUSH
19852: LD_INT 8
19854: PUSH
19855: LD_INT 176
19857: PUSH
19858: LD_INT 82
19860: PUSH
19861: LD_INT 3
19863: PUSH
19864: LD_INT 12
19866: PUSH
19867: LD_INT 10
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: PUSH
19881: LD_INT 28
19883: PUSH
19884: LD_INT 196
19886: PUSH
19887: LD_INT 92
19889: PUSH
19890: LD_INT 5
19892: PUSH
19893: EMPTY
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: PUSH
19902: LD_INT 28
19904: PUSH
19905: LD_INT 198
19907: PUSH
19908: LD_INT 86
19910: PUSH
19911: LD_INT 1
19913: PUSH
19914: EMPTY
19915: PUSH
19916: EMPTY
19917: LIST
19918: LIST
19919: LIST
19920: LIST
19921: LIST
19922: PUSH
19923: LD_INT 30
19925: PUSH
19926: LD_INT 192
19928: PUSH
19929: LD_INT 93
19931: PUSH
19932: LD_INT 0
19934: PUSH
19935: EMPTY
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: PUSH
19968: EMPTY
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: ST_TO_ADDR
// in_depots := [ [ 820 , 720 , 421 ] , [ 770 , 620 , 320 ] , [ 680 , 900 , 310 ] , [ 730 , 920 , 240 ] , [ 510 , 810 , 300 ] ] ;
19975: LD_ADDR_LOC 25
19979: PUSH
19980: LD_INT 820
19982: PUSH
19983: LD_INT 720
19985: PUSH
19986: LD_INT 421
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: LIST
19993: PUSH
19994: LD_INT 770
19996: PUSH
19997: LD_INT 620
19999: PUSH
20000: LD_INT 320
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PUSH
20008: LD_INT 680
20010: PUSH
20011: LD_INT 900
20013: PUSH
20014: LD_INT 310
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 730
20024: PUSH
20025: LD_INT 920
20027: PUSH
20028: LD_INT 240
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: LIST
20035: PUSH
20036: LD_INT 510
20038: PUSH
20039: LD_INT 810
20041: PUSH
20042: LD_INT 300
20044: PUSH
20045: EMPTY
20046: LIST
20047: LIST
20048: LIST
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: LIST
20054: LIST
20055: LIST
20056: ST_TO_ADDR
// end ;
20057: LD_VAR 0 1
20061: RET
// function UpgradeableTo ( b , up ) ; var i ; begin
20062: LD_INT 0
20064: PPUSH
20065: PPUSH
// result := 0 ;
20066: LD_ADDR_VAR 0 3
20070: PUSH
20071: LD_INT 0
20073: ST_TO_ADDR
// for i := 1 to upgradeable do
20074: LD_ADDR_VAR 0 4
20078: PUSH
20079: DOUBLE
20080: LD_INT 1
20082: DEC
20083: ST_TO_ADDR
20084: LD_LOC 27
20088: PUSH
20089: FOR_TO
20090: IFFALSE 20142
// if b = upgradeable [ i ] and up = trough_upgrade [ i ] then
20092: LD_VAR 0 1
20096: PUSH
20097: LD_LOC 27
20101: PUSH
20102: LD_VAR 0 4
20106: ARRAY
20107: EQUAL
20108: PUSH
20109: LD_VAR 0 2
20113: PUSH
20114: LD_LOC 28
20118: PUSH
20119: LD_VAR 0 4
20123: ARRAY
20124: EQUAL
20125: AND
20126: IFFALSE 20140
// begin result := up ;
20128: LD_ADDR_VAR 0 3
20132: PUSH
20133: LD_VAR 0 2
20137: ST_TO_ADDR
// break ;
20138: GO 20142
// end ;
20140: GO 20089
20142: POP
20143: POP
// end ;
20144: LD_VAR 0 3
20148: RET
// function IsUpgraded ( b ) ; begin
20149: LD_INT 0
20151: PPUSH
// result := 0 ;
20152: LD_ADDR_VAR 0 2
20156: PUSH
20157: LD_INT 0
20159: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20160: LD_VAR 0 1
20164: PUSH
20165: LD_LOC 28
20169: PUSH
20170: LD_INT 1
20172: ARRAY
20173: DOUBLE
20174: EQUAL
20175: IFTRUE 20179
20177: GO 20196
20179: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20180: LD_ADDR_VAR 0 2
20184: PUSH
20185: LD_LOC 27
20189: PUSH
20190: LD_INT 1
20192: ARRAY
20193: ST_TO_ADDR
20194: GO 20321
20196: LD_LOC 28
20200: PUSH
20201: LD_INT 2
20203: ARRAY
20204: DOUBLE
20205: EQUAL
20206: IFTRUE 20210
20208: GO 20227
20210: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20211: LD_ADDR_VAR 0 2
20215: PUSH
20216: LD_LOC 27
20220: PUSH
20221: LD_INT 2
20223: ARRAY
20224: ST_TO_ADDR
20225: GO 20321
20227: LD_LOC 28
20231: PUSH
20232: LD_INT 3
20234: ARRAY
20235: DOUBLE
20236: EQUAL
20237: IFTRUE 20241
20239: GO 20258
20241: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20242: LD_ADDR_VAR 0 2
20246: PUSH
20247: LD_LOC 27
20251: PUSH
20252: LD_INT 3
20254: ARRAY
20255: ST_TO_ADDR
20256: GO 20321
20258: LD_LOC 28
20262: PUSH
20263: LD_INT 4
20265: ARRAY
20266: DOUBLE
20267: EQUAL
20268: IFTRUE 20272
20270: GO 20289
20272: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 5 ] :
20273: LD_ADDR_VAR 0 2
20277: PUSH
20278: LD_LOC 27
20282: PUSH
20283: LD_INT 4
20285: ARRAY
20286: ST_TO_ADDR
20287: GO 20321
20289: LD_LOC 28
20293: PUSH
20294: LD_INT 5
20296: ARRAY
20297: DOUBLE
20298: EQUAL
20299: IFTRUE 20303
20301: GO 20320
20303: POP
// result := upgradeable [ 5 ] ; end ;
20304: LD_ADDR_VAR 0 2
20308: PUSH
20309: LD_LOC 27
20313: PUSH
20314: LD_INT 5
20316: ARRAY
20317: ST_TO_ADDR
20318: GO 20321
20320: POP
// end ;
20321: LD_VAR 0 2
20325: RET
// function BasicFrom ( b ) ; begin
20326: LD_INT 0
20328: PPUSH
// result := b ;
20329: LD_ADDR_VAR 0 2
20333: PUSH
20334: LD_VAR 0 1
20338: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20339: LD_VAR 0 1
20343: PUSH
20344: LD_LOC 28
20348: PUSH
20349: LD_INT 1
20351: ARRAY
20352: DOUBLE
20353: EQUAL
20354: IFTRUE 20358
20356: GO 20375
20358: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20359: LD_ADDR_VAR 0 2
20363: PUSH
20364: LD_LOC 27
20368: PUSH
20369: LD_INT 1
20371: ARRAY
20372: ST_TO_ADDR
20373: GO 20500
20375: LD_LOC 28
20379: PUSH
20380: LD_INT 2
20382: ARRAY
20383: DOUBLE
20384: EQUAL
20385: IFTRUE 20389
20387: GO 20406
20389: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20390: LD_ADDR_VAR 0 2
20394: PUSH
20395: LD_LOC 27
20399: PUSH
20400: LD_INT 2
20402: ARRAY
20403: ST_TO_ADDR
20404: GO 20500
20406: LD_LOC 28
20410: PUSH
20411: LD_INT 3
20413: ARRAY
20414: DOUBLE
20415: EQUAL
20416: IFTRUE 20420
20418: GO 20437
20420: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20421: LD_ADDR_VAR 0 2
20425: PUSH
20426: LD_LOC 27
20430: PUSH
20431: LD_INT 3
20433: ARRAY
20434: ST_TO_ADDR
20435: GO 20500
20437: LD_LOC 28
20441: PUSH
20442: LD_INT 4
20444: ARRAY
20445: DOUBLE
20446: EQUAL
20447: IFTRUE 20451
20449: GO 20468
20451: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 6 ] :
20452: LD_ADDR_VAR 0 2
20456: PUSH
20457: LD_LOC 27
20461: PUSH
20462: LD_INT 4
20464: ARRAY
20465: ST_TO_ADDR
20466: GO 20500
20468: LD_LOC 28
20472: PUSH
20473: LD_INT 6
20475: ARRAY
20476: DOUBLE
20477: EQUAL
20478: IFTRUE 20482
20480: GO 20499
20482: POP
// result := upgradeable [ 6 ] ; end ;
20483: LD_ADDR_VAR 0 2
20487: PUSH
20488: LD_LOC 27
20492: PUSH
20493: LD_INT 6
20495: ARRAY
20496: ST_TO_ADDR
20497: GO 20500
20499: POP
// end ;
20500: LD_VAR 0 2
20504: RET
// export function build_map ; var i , j ; begin
20505: LD_INT 0
20507: PPUSH
20508: PPUSH
20509: PPUSH
// for i := 1 to 5 do
20510: LD_ADDR_VAR 0 2
20514: PUSH
20515: DOUBLE
20516: LD_INT 1
20518: DEC
20519: ST_TO_ADDR
20520: LD_INT 5
20522: PUSH
20523: FOR_TO
20524: IFFALSE 20591
// buildings := replace ( buildings , i , place_base ( builds [ i ] , in_depots [ i ] , ai_s [ i ] , ai_nation ) ) ;
20526: LD_ADDR_EXP 75
20530: PUSH
20531: LD_EXP 75
20535: PPUSH
20536: LD_VAR 0 2
20540: PPUSH
20541: LD_LOC 23
20545: PUSH
20546: LD_VAR 0 2
20550: ARRAY
20551: PPUSH
20552: LD_LOC 25
20556: PUSH
20557: LD_VAR 0 2
20561: ARRAY
20562: PPUSH
20563: LD_EXP 23
20567: PUSH
20568: LD_VAR 0 2
20572: ARRAY
20573: PPUSH
20574: LD_EXP 22
20578: PPUSH
20579: CALL 20831 0 4
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
20589: GO 20523
20591: POP
20592: POP
// hlavouni := [ Platonov , Gossudarov , Borodin , Tsaritsyn , Davidov , Eisenstein ] ;
20593: LD_ADDR_EXP 72
20597: PUSH
20598: LD_EXP 42
20602: PUSH
20603: LD_EXP 43
20607: PUSH
20608: LD_EXP 46
20612: PUSH
20613: LD_EXP 47
20617: PUSH
20618: LD_EXP 48
20622: PUSH
20623: LD_EXP 49
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , da ) ;
20636: LD_EXP 42
20640: PPUSH
20641: LD_INT 1
20643: PPUSH
20644: CALL_OW 52
// PlaceHumanInUnit ( Gossudarov , art_cargo ) ;
20648: LD_EXP 43
20652: PPUSH
20653: LD_INT 121
20655: PPUSH
20656: CALL_OW 52
// PlaceHumanInUnit ( Borodin , db ) ;
20660: LD_EXP 46
20664: PPUSH
20665: LD_INT 51
20667: PPUSH
20668: CALL_OW 52
// PlaceHumanInUnit ( Tsaritsyn , dc ) ;
20672: LD_EXP 47
20676: PPUSH
20677: LD_INT 80
20679: PPUSH
20680: CALL_OW 52
// PlaceHumanInUnit ( Davidov , dd ) ;
20684: LD_EXP 48
20688: PPUSH
20689: LD_INT 28
20691: PPUSH
20692: CALL_OW 52
// PlaceHumanInUnit ( Eisenstein , de ) ;
20696: LD_EXP 49
20700: PPUSH
20701: LD_INT 37
20703: PPUSH
20704: CALL_OW 52
// for i := 1 to 5 do
20708: LD_ADDR_VAR 0 2
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_INT 5
20720: PUSH
20721: FOR_TO
20722: IFFALSE 20824
// begin humans := replace ( humans , i , place_aici ( aici [ i ] , abase [ i ] , ai_s [ i ] , ai_nation ) ) ;
20724: LD_ADDR_EXP 76
20728: PUSH
20729: LD_EXP 76
20733: PPUSH
20734: LD_VAR 0 2
20738: PPUSH
20739: LD_LOC 24
20743: PUSH
20744: LD_VAR 0 2
20748: ARRAY
20749: PPUSH
20750: LD_LOC 26
20754: PUSH
20755: LD_VAR 0 2
20759: ARRAY
20760: PPUSH
20761: LD_EXP 23
20765: PUSH
20766: LD_VAR 0 2
20770: ARRAY
20771: PPUSH
20772: LD_EXP 22
20776: PPUSH
20777: CALL 21283 0 4
20781: PPUSH
20782: CALL_OW 1
20786: ST_TO_ADDR
// for j in humans [ i ] do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: LD_EXP 76
20796: PUSH
20797: LD_VAR 0 2
20801: ARRAY
20802: PUSH
20803: FOR_IN
20804: IFFALSE 20820
// SetTag ( j , 1 ) ;
20806: LD_VAR 0 3
20810: PPUSH
20811: LD_INT 1
20813: PPUSH
20814: CALL_OW 109
20818: GO 20803
20820: POP
20821: POP
// end ;
20822: GO 20721
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 1
20830: RET
// function place_base ( builds , in_depot , side , nat ) ; var i , base , b , tb , bb , cans , oil , sib ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
// cans := in_depot [ 1 ] ;
20842: LD_ADDR_VAR 0 11
20846: PUSH
20847: LD_VAR 0 2
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: ST_TO_ADDR
// oil := in_depot [ 2 ] ;
20856: LD_ADDR_VAR 0 12
20860: PUSH
20861: LD_VAR 0 2
20865: PUSH
20866: LD_INT 2
20868: ARRAY
20869: ST_TO_ADDR
// sib := in_depot [ 3 ] ;
20870: LD_ADDR_VAR 0 13
20874: PUSH
20875: LD_VAR 0 2
20879: PUSH
20880: LD_INT 3
20882: ARRAY
20883: ST_TO_ADDR
// InitUc ;
20884: CALL_OW 18
// InitBc ;
20888: CALL_OW 21
// uc_side := side ;
20892: LD_ADDR_OWVAR 20
20896: PUSH
20897: LD_VAR 0 3
20901: ST_TO_ADDR
// uc_nation := nat ;
20902: LD_ADDR_OWVAR 21
20906: PUSH
20907: LD_VAR 0 4
20911: ST_TO_ADDR
// b := [ ] ;
20912: LD_ADDR_VAR 0 8
20916: PUSH
20917: EMPTY
20918: ST_TO_ADDR
// for i in builds do
20919: LD_ADDR_VAR 0 6
20923: PUSH
20924: LD_VAR 0 1
20928: PUSH
20929: FOR_IN
20930: IFFALSE 21160
// begin if i = 5 then
20932: LD_VAR 0 6
20936: PUSH
20937: LD_INT 5
20939: EQUAL
20940: IFFALSE 21158
// begin tb := get_build ( i [ 2 ] , i [ 3 ] , 0 ) ;
20942: LD_ADDR_VAR 0 9
20946: PUSH
20947: LD_VAR 0 6
20951: PUSH
20952: LD_INT 2
20954: ARRAY
20955: PPUSH
20956: LD_VAR 0 6
20960: PUSH
20961: LD_INT 3
20963: ARRAY
20964: PPUSH
20965: LD_INT 0
20967: PPUSH
20968: CALL 22128 0 3
20972: ST_TO_ADDR
// if not tb then
20973: LD_VAR 0 9
20977: NOT
20978: IFFALSE 21139
// begin bc_type := i [ 1 ] ;
20980: LD_ADDR_OWVAR 42
20984: PUSH
20985: LD_VAR 0 6
20989: PUSH
20990: LD_INT 1
20992: ARRAY
20993: ST_TO_ADDR
// if bc_type = b_lab or bc_type = b_lab_half or bc_type = b_lab_full then
20994: LD_OWVAR 42
20998: PUSH
20999: LD_INT 6
21001: EQUAL
21002: PUSH
21003: LD_OWVAR 42
21007: PUSH
21008: LD_INT 7
21010: EQUAL
21011: OR
21012: PUSH
21013: LD_OWVAR 42
21017: PUSH
21018: LD_INT 8
21020: EQUAL
21021: OR
21022: IFFALSE 21060
// begin bc_kind1 := i [ 5 ] [ 1 ] ;
21024: LD_ADDR_OWVAR 44
21028: PUSH
21029: LD_VAR 0 6
21033: PUSH
21034: LD_INT 5
21036: ARRAY
21037: PUSH
21038: LD_INT 1
21040: ARRAY
21041: ST_TO_ADDR
// bc_kind2 := i [ 5 ] [ 2 ] ;
21042: LD_ADDR_OWVAR 45
21046: PUSH
21047: LD_VAR 0 6
21051: PUSH
21052: LD_INT 5
21054: ARRAY
21055: PUSH
21056: LD_INT 2
21058: ARRAY
21059: ST_TO_ADDR
// end ; tb := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
21060: LD_ADDR_VAR 0 9
21064: PUSH
21065: LD_VAR 0 6
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: LD_VAR 0 6
21078: PUSH
21079: LD_INT 3
21081: ARRAY
21082: PPUSH
21083: LD_VAR 0 6
21087: PUSH
21088: LD_INT 4
21090: ARRAY
21091: PPUSH
21092: CALL_OW 47
21096: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
21097: LD_OWVAR 42
21101: PUSH
21102: LD_INT 32
21104: EQUAL
21105: PUSH
21106: LD_OWVAR 42
21110: PUSH
21111: LD_INT 33
21113: EQUAL
21114: OR
21115: IFFALSE 21139
// PlaceWeaponTurret ( tb , i [ 5 ] [ 1 ] ) ;
21117: LD_VAR 0 9
21121: PPUSH
21122: LD_VAR 0 6
21126: PUSH
21127: LD_INT 5
21129: ARRAY
21130: PUSH
21131: LD_INT 1
21133: ARRAY
21134: PPUSH
21135: CALL_OW 431
// end ; b := b ^ [ tb ] ;
21139: LD_ADDR_VAR 0 8
21143: PUSH
21144: LD_VAR 0 8
21148: PUSH
21149: LD_VAR 0 9
21153: PUSH
21154: EMPTY
21155: LIST
21156: ADD
21157: ST_TO_ADDR
// end ; end ;
21158: GO 20929
21160: POP
21161: POP
// bb := UnitFilter ( b , [ mf_dep ] ) ;
21162: LD_ADDR_VAR 0 10
21166: PUSH
21167: LD_VAR 0 8
21171: PPUSH
21172: LD_EXP 58
21176: PUSH
21177: EMPTY
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// for i in bb do
21185: LD_ADDR_VAR 0 6
21189: PUSH
21190: LD_VAR 0 10
21194: PUSH
21195: FOR_IN
21196: IFFALSE 21266
// begin base := GetBase ( i ) ;
21198: LD_ADDR_VAR 0 7
21202: PUSH
21203: LD_VAR 0 6
21207: PPUSH
21208: CALL_OW 274
21212: ST_TO_ADDR
// SetResourceType ( base , mat_cans , cans ) ;
21213: LD_VAR 0 7
21217: PPUSH
21218: LD_INT 1
21220: PPUSH
21221: LD_VAR 0 11
21225: PPUSH
21226: CALL_OW 277
// SetResourceType ( base , mat_oil , oil ) ;
21230: LD_VAR 0 7
21234: PPUSH
21235: LD_INT 2
21237: PPUSH
21238: LD_VAR 0 12
21242: PPUSH
21243: CALL_OW 277
// SetResourceType ( base , mat_siberit , sib ) ;
21247: LD_VAR 0 7
21251: PPUSH
21252: LD_INT 3
21254: PPUSH
21255: LD_VAR 0 13
21259: PPUSH
21260: CALL_OW 277
// end ;
21264: GO 21195
21266: POP
21267: POP
// result := b ;
21268: LD_ADDR_VAR 0 5
21272: PUSH
21273: LD_VAR 0 8
21277: ST_TO_ADDR
// end ;
21278: LD_VAR 0 5
21282: RET
// function place_aici ( aici , area , side , nat ) ; var i , j , a ; begin
21283: LD_INT 0
21285: PPUSH
21286: PPUSH
21287: PPUSH
21288: PPUSH
// InitUc ;
21289: CALL_OW 18
// InitHc ;
21293: CALL_OW 19
// uc_side := side ;
21297: LD_ADDR_OWVAR 20
21301: PUSH
21302: LD_VAR 0 3
21306: ST_TO_ADDR
// uc_nation := nat ;
21307: LD_ADDR_OWVAR 21
21311: PUSH
21312: LD_VAR 0 4
21316: ST_TO_ADDR
// a := [ ] ;
21317: LD_ADDR_VAR 0 8
21321: PUSH
21322: EMPTY
21323: ST_TO_ADDR
// for i in aici do
21324: LD_ADDR_VAR 0 6
21328: PUSH
21329: LD_VAR 0 1
21333: PUSH
21334: FOR_IN
21335: IFFALSE 21409
// begin for j := 1 to i [ 1 ] do
21337: LD_ADDR_VAR 0 7
21341: PUSH
21342: DOUBLE
21343: LD_INT 1
21345: DEC
21346: ST_TO_ADDR
21347: LD_VAR 0 6
21351: PUSH
21352: LD_INT 1
21354: ARRAY
21355: PUSH
21356: FOR_TO
21357: IFFALSE 21405
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
21359: LD_INT 0
21361: PPUSH
21362: LD_VAR 0 6
21366: PUSH
21367: LD_INT 2
21369: ARRAY
21370: PPUSH
21371: LD_VAR 0 6
21375: PUSH
21376: LD_INT 3
21378: ARRAY
21379: PPUSH
21380: CALL_OW 380
// a := a ^ [ CreateHuman ] ;
21384: LD_ADDR_VAR 0 8
21388: PUSH
21389: LD_VAR 0 8
21393: PUSH
21394: CALL_OW 44
21398: PUSH
21399: EMPTY
21400: LIST
21401: ADD
21402: ST_TO_ADDR
// end ;
21403: GO 21356
21405: POP
21406: POP
// end ;
21407: GO 21334
21409: POP
21410: POP
// for i in a do
21411: LD_ADDR_VAR 0 6
21415: PUSH
21416: LD_VAR 0 8
21420: PUSH
21421: FOR_IN
21422: IFFALSE 21443
// PlaceUnitArea ( i , area , false ) ;
21424: LD_VAR 0 6
21428: PPUSH
21429: LD_VAR 0 2
21433: PPUSH
21434: LD_INT 0
21436: PPUSH
21437: CALL_OW 49
21441: GO 21421
21443: POP
21444: POP
// result := a ;
21445: LD_ADDR_VAR 0 5
21449: PUSH
21450: LD_VAR 0 8
21454: ST_TO_ADDR
// end ;
21455: LD_VAR 0 5
21459: RET
// every 0 0$10 + 0 0$0.0 do var i , j , weap , k ;
21460: GO 21462
21462: DISABLE
21463: LD_INT 0
21465: PPUSH
21466: PPUSH
21467: PPUSH
21468: PPUSH
// begin for i in UnitFilter ( fort , [ mf_bunk ] ) do
21469: LD_ADDR_VAR 0 1
21473: PUSH
21474: LD_EXP 81
21478: PPUSH
21479: LD_EXP 57
21483: PUSH
21484: EMPTY
21485: LIST
21486: PPUSH
21487: CALL_OW 72
21491: PUSH
21492: FOR_IN
21493: IFFALSE 21663
// if not GetBWeapon ( i ) then
21495: LD_VAR 0 1
21499: PPUSH
21500: CALL_OW 269
21504: NOT
21505: IFFALSE 21661
// begin weap := 0 ;
21507: LD_ADDR_VAR 0 3
21511: PUSH
21512: LD_INT 0
21514: ST_TO_ADDR
// for k := 1 to 5 do
21515: LD_ADDR_VAR 0 4
21519: PUSH
21520: DOUBLE
21521: LD_INT 1
21523: DEC
21524: ST_TO_ADDR
21525: LD_INT 5
21527: PUSH
21528: FOR_TO
21529: IFFALSE 21639
// for j in builds [ k ] do
21531: LD_ADDR_VAR 0 2
21535: PUSH
21536: LD_LOC 23
21540: PUSH
21541: LD_VAR 0 4
21545: ARRAY
21546: PUSH
21547: FOR_IN
21548: IFFALSE 21635
// if GetX ( i ) = j [ 2 ] and GetY ( i ) = j [ 3 ] and GetBType ( i ) = j [ 1 ] then
21550: LD_VAR 0 1
21554: PPUSH
21555: CALL_OW 250
21559: PUSH
21560: LD_VAR 0 2
21564: PUSH
21565: LD_INT 2
21567: ARRAY
21568: EQUAL
21569: PUSH
21570: LD_VAR 0 1
21574: PPUSH
21575: CALL_OW 251
21579: PUSH
21580: LD_VAR 0 2
21584: PUSH
21585: LD_INT 3
21587: ARRAY
21588: EQUAL
21589: AND
21590: PUSH
21591: LD_VAR 0 1
21595: PPUSH
21596: CALL_OW 266
21600: PUSH
21601: LD_VAR 0 2
21605: PUSH
21606: LD_INT 1
21608: ARRAY
21609: EQUAL
21610: AND
21611: IFFALSE 21633
// begin weap := j [ 5 ] [ 1 ] ;
21613: LD_ADDR_VAR 0 3
21617: PUSH
21618: LD_VAR 0 2
21622: PUSH
21623: LD_INT 5
21625: ARRAY
21626: PUSH
21627: LD_INT 1
21629: ARRAY
21630: ST_TO_ADDR
// break ;
21631: GO 21635
// end ;
21633: GO 21547
21635: POP
21636: POP
21637: GO 21528
21639: POP
21640: POP
// if weap then
21641: LD_VAR 0 3
21645: IFFALSE 21661
// ComPlaceWeapon ( j , weap ) ;
21647: LD_VAR 0 2
21651: PPUSH
21652: LD_VAR 0 3
21656: PPUSH
21657: CALL_OW 148
// end ;
21661: GO 21492
21663: POP
21664: POP
// enable ;
21665: ENABLE
// end ;
21666: PPOPN 4
21668: END
// every 0 0$10 + 0 0$2.0 do var i , to_up , to_b , co_tam_stoji , k , je_cas_stavet ;
21669: GO 21671
21671: DISABLE
21672: LD_INT 0
21674: PPUSH
21675: PPUSH
21676: PPUSH
21677: PPUSH
21678: PPUSH
21679: PPUSH
// begin for k := 1 to 5 do
21680: LD_ADDR_VAR 0 5
21684: PUSH
21685: DOUBLE
21686: LD_INT 1
21688: DEC
21689: ST_TO_ADDR
21690: LD_INT 5
21692: PUSH
21693: FOR_TO
21694: IFFALSE 22122
// begin if not under_attack [ k ] then
21696: LD_EXP 62
21700: PUSH
21701: LD_VAR 0 5
21705: ARRAY
21706: NOT
21707: IFFALSE 22120
// begin to_b := [ ] ;
21709: LD_ADDR_VAR 0 3
21713: PUSH
21714: EMPTY
21715: ST_TO_ADDR
// to_up := [ ] ;
21716: LD_ADDR_VAR 0 2
21720: PUSH
21721: EMPTY
21722: ST_TO_ADDR
// je_cas_stavet := false ;
21723: LD_ADDR_VAR 0 6
21727: PUSH
21728: LD_INT 0
21730: ST_TO_ADDR
// for i in builds [ k ] do
21731: LD_ADDR_VAR 0 1
21735: PUSH
21736: LD_LOC 23
21740: PUSH
21741: LD_VAR 0 5
21745: ARRAY
21746: PUSH
21747: FOR_IN
21748: IFFALSE 21949
// begin je_cas_stavet := true ;
21750: LD_ADDR_VAR 0 6
21754: PUSH
21755: LD_INT 1
21757: ST_TO_ADDR
// if i = 6 then
21758: LD_VAR 0 1
21762: PUSH
21763: LD_INT 6
21765: EQUAL
21766: IFFALSE 21792
// if i [ 6 ] < tick then
21768: LD_VAR 0 1
21772: PUSH
21773: LD_INT 6
21775: ARRAY
21776: PUSH
21777: LD_OWVAR 1
21781: LESS
21782: IFFALSE 21792
// je_cas_stavet := false ;
21784: LD_ADDR_VAR 0 6
21788: PUSH
21789: LD_INT 0
21791: ST_TO_ADDR
// if je_cas_stavet then
21792: LD_VAR 0 6
21796: IFFALSE 21947
// begin co_tam_stoji := GetBType ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
21798: LD_ADDR_VAR 0 4
21802: PUSH
21803: LD_VAR 0 1
21807: PUSH
21808: LD_INT 2
21810: ARRAY
21811: PPUSH
21812: LD_VAR 0 1
21816: PUSH
21817: LD_INT 3
21819: ARRAY
21820: PPUSH
21821: LD_INT 0
21823: PPUSH
21824: CALL 22128 0 3
21828: PPUSH
21829: CALL_OW 266
21833: ST_TO_ADDR
// if co_tam_stoji = - 1 then
21834: LD_VAR 0 4
21838: PUSH
21839: LD_INT 1
21841: NEG
21842: EQUAL
21843: IFFALSE 21909
// begin to_b := [ BasicFrom ( i [ 1 ] ) , i [ 2 ] , i [ 3 ] , i [ 4 ] , i [ 5 ] ] ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 1
21857: ARRAY
21858: PPUSH
21859: CALL 20326 0 1
21863: PUSH
21864: LD_VAR 0 1
21868: PUSH
21869: LD_INT 2
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 1
21877: PUSH
21878: LD_INT 3
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 1
21886: PUSH
21887: LD_INT 4
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 1
21895: PUSH
21896: LD_INT 5
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: LIST
21906: ST_TO_ADDR
// end else
21907: GO 21939
// if UpgradeableTo ( co_tam_stoji , i [ 1 ] ) then
21909: LD_VAR 0 4
21913: PPUSH
21914: LD_VAR 0 1
21918: PUSH
21919: LD_INT 1
21921: ARRAY
21922: PPUSH
21923: CALL 20062 0 2
21927: IFFALSE 21939
// begin to_up := i ;
21929: LD_ADDR_VAR 0 2
21933: PUSH
21934: LD_VAR 0 1
21938: ST_TO_ADDR
// end ; if to_b then
21939: LD_VAR 0 3
21943: IFFALSE 21947
// break ;
21945: GO 21949
// end ; end ;
21947: GO 21747
21949: POP
21950: POP
// if to_b then
21951: LD_VAR 0 3
21955: IFFALSE 22077
// ComBuild ( NearestUnitToXY ( UnitFilter ( eng isect humans [ k ] , [ [ f_distxy , to_b [ 2 ] , to_b [ 3 ] , 40 ] ] ) , to_b [ 2 ] , to_b [ 3 ] ) , to_b [ 1 ] , to_b [ 2 ] , to_b [ 3 ] , to_b [ 4 ] ) else
21957: LD_EXP 84
21961: PUSH
21962: LD_EXP 76
21966: PUSH
21967: LD_VAR 0 5
21971: ARRAY
21972: ISECT
21973: PPUSH
21974: LD_INT 92
21976: PUSH
21977: LD_VAR 0 3
21981: PUSH
21982: LD_INT 2
21984: ARRAY
21985: PUSH
21986: LD_VAR 0 3
21990: PUSH
21991: LD_INT 3
21993: ARRAY
21994: PUSH
21995: LD_INT 40
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: LIST
22002: LIST
22003: PUSH
22004: EMPTY
22005: LIST
22006: PPUSH
22007: CALL_OW 72
22011: PPUSH
22012: LD_VAR 0 3
22016: PUSH
22017: LD_INT 2
22019: ARRAY
22020: PPUSH
22021: LD_VAR 0 3
22025: PUSH
22026: LD_INT 3
22028: ARRAY
22029: PPUSH
22030: CALL_OW 73
22034: PPUSH
22035: LD_VAR 0 3
22039: PUSH
22040: LD_INT 1
22042: ARRAY
22043: PPUSH
22044: LD_VAR 0 3
22048: PUSH
22049: LD_INT 2
22051: ARRAY
22052: PPUSH
22053: LD_VAR 0 3
22057: PUSH
22058: LD_INT 3
22060: ARRAY
22061: PPUSH
22062: LD_VAR 0 3
22066: PUSH
22067: LD_INT 4
22069: ARRAY
22070: PPUSH
22071: CALL_OW 145
22075: GO 22113
// if to_up then
22077: LD_VAR 0 2
22081: IFFALSE 22113
// ComUpgrade ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
22083: LD_VAR 0 1
22087: PUSH
22088: LD_INT 2
22090: ARRAY
22091: PPUSH
22092: LD_VAR 0 1
22096: PUSH
22097: LD_INT 3
22099: ARRAY
22100: PPUSH
22101: LD_INT 0
22103: PPUSH
22104: CALL 22128 0 3
22108: PPUSH
22109: CALL_OW 146
// wait ( 0 0$1.1 ) ;
22113: LD_INT 39
22115: PPUSH
22116: CALL_OW 67
// end ; end ;
22120: GO 21693
22122: POP
22123: POP
// enable ;
22124: ENABLE
// end ;
22125: PPOPN 6
22127: END
// function get_build ( x , y , btype ) ; begin
22128: LD_INT 0
22130: PPUSH
// result := HexInfo ( x , y ) ;
22131: LD_ADDR_VAR 0 4
22135: PUSH
22136: LD_VAR 0 1
22140: PPUSH
22141: LD_VAR 0 2
22145: PPUSH
22146: CALL_OW 428
22150: ST_TO_ADDR
// if result < 1 then
22151: LD_VAR 0 4
22155: PUSH
22156: LD_INT 1
22158: LESS
22159: IFFALSE 22169
// result := 0 ;
22161: LD_ADDR_VAR 0 4
22165: PUSH
22166: LD_INT 0
22168: ST_TO_ADDR
// if btype then
22169: LD_VAR 0 3
22173: IFFALSE 22225
// if btype <> GetBType ( result ) then
22175: LD_VAR 0 3
22179: PUSH
22180: LD_VAR 0 4
22184: PPUSH
22185: CALL_OW 266
22189: NONEQUAL
22190: IFFALSE 22202
// result := 0 else
22192: LD_ADDR_VAR 0 4
22196: PUSH
22197: LD_INT 0
22199: ST_TO_ADDR
22200: GO 22225
// if unit_building <> GetType ( result ) then
22202: LD_INT 3
22204: PUSH
22205: LD_VAR 0 4
22209: PPUSH
22210: CALL_OW 247
22214: NONEQUAL
22215: IFFALSE 22225
// result := 0 ;
22217: LD_ADDR_VAR 0 4
22221: PUSH
22222: LD_INT 0
22224: ST_TO_ADDR
// end ; end_of_file
22225: LD_VAR 0 4
22229: RET
// var opravit ; export function inicializace_ai_b_repair ; begin
22230: LD_INT 0
22232: PPUSH
// opravit := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22233: LD_ADDR_LOC 29
22237: PUSH
22238: EMPTY
22239: PUSH
22240: EMPTY
22241: PUSH
22242: EMPTY
22243: PUSH
22244: EMPTY
22245: PUSH
22246: EMPTY
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: ST_TO_ADDR
// end ;
22255: LD_VAR 0 1
22259: RET
// function HledejBudovyNaOpravy ( opravit_index , budovy ) ; var zivoty , i , opravit_tmp ; begin
22260: LD_INT 0
22262: PPUSH
22263: PPUSH
22264: PPUSH
22265: PPUSH
// opravit_tmp := [ ] ;
22266: LD_ADDR_VAR 0 6
22270: PUSH
22271: EMPTY
22272: ST_TO_ADDR
// zivoty := [ ] ;
22273: LD_ADDR_VAR 0 4
22277: PUSH
22278: EMPTY
22279: ST_TO_ADDR
// for i in budovy do
22280: LD_ADDR_VAR 0 5
22284: PUSH
22285: LD_VAR 0 2
22289: PUSH
22290: FOR_IN
22291: IFFALSE 22353
// begin if GetLives ( i ) < 1000 then
22293: LD_VAR 0 5
22297: PPUSH
22298: CALL_OW 256
22302: PUSH
22303: LD_INT 1000
22305: LESS
22306: IFFALSE 22351
// begin opravit_tmp := opravit_tmp ^ [ i ] ;
22308: LD_ADDR_VAR 0 6
22312: PUSH
22313: LD_VAR 0 6
22317: PUSH
22318: LD_VAR 0 5
22322: PUSH
22323: EMPTY
22324: LIST
22325: ADD
22326: ST_TO_ADDR
// zivoty := zivoty ^ [ GetLives ( i ) ] ;
22327: LD_ADDR_VAR 0 4
22331: PUSH
22332: LD_VAR 0 4
22336: PUSH
22337: LD_VAR 0 5
22341: PPUSH
22342: CALL_OW 256
22346: PUSH
22347: EMPTY
22348: LIST
22349: ADD
22350: ST_TO_ADDR
// end ; end ;
22351: GO 22290
22353: POP
22354: POP
// if opravit_tmp then
22355: LD_VAR 0 6
22359: IFFALSE 22381
// opravit_tmp := SortListByListAsc ( opravit_tmp , zivoty ) ;
22361: LD_ADDR_VAR 0 6
22365: PUSH
22366: LD_VAR 0 6
22370: PPUSH
22371: LD_VAR 0 4
22375: PPUSH
22376: CALL_OW 76
22380: ST_TO_ADDR
// opravit := Replace ( opravit , opravit_index , opravit_tmp ) ;
22381: LD_ADDR_LOC 29
22385: PUSH
22386: LD_LOC 29
22390: PPUSH
22391: LD_VAR 0 1
22395: PPUSH
22396: LD_VAR 0 6
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
// end ;
22406: LD_VAR 0 3
22410: RET
// every 0 0$5 do var i ;
22411: GO 22413
22413: DISABLE
22414: LD_INT 0
22416: PPUSH
// begin for i := 1 to 5 do
22417: LD_ADDR_VAR 0 1
22421: PUSH
22422: DOUBLE
22423: LD_INT 1
22425: DEC
22426: ST_TO_ADDR
22427: LD_INT 5
22429: PUSH
22430: FOR_TO
22431: IFFALSE 22475
// begin if not under_attack [ i ] then
22433: LD_EXP 62
22437: PUSH
22438: LD_VAR 0 1
22442: ARRAY
22443: NOT
22444: IFFALSE 22473
// begin HledejBudovyNaOpravy ( i , buildings [ i ] ) ;
22446: LD_VAR 0 1
22450: PPUSH
22451: LD_EXP 75
22455: PUSH
22456: LD_VAR 0 1
22460: ARRAY
22461: PPUSH
22462: CALL 22260 0 2
// wait ( 0 0$0.6 ) ;
22466: LD_INT 21
22468: PPUSH
22469: CALL_OW 67
// end ; end ;
22473: GO 22430
22475: POP
22476: POP
// enable ;
22477: ENABLE
// end ;
22478: PPOPN 1
22480: END
// every 0 0$5 do var i ;
22481: GO 22483
22483: DISABLE
22484: LD_INT 0
22486: PPUSH
// begin for i := 1 to 5 do
22487: LD_ADDR_VAR 0 1
22491: PUSH
22492: DOUBLE
22493: LD_INT 1
22495: DEC
22496: ST_TO_ADDR
22497: LD_INT 5
22499: PUSH
22500: FOR_TO
22501: IFFALSE 22650
// begin if opravit [ i ] then
22503: LD_LOC 29
22507: PUSH
22508: LD_VAR 0 1
22512: ARRAY
22513: IFFALSE 22648
// begin ComRepairBuilding ( UnitFilter ( eng , [ [ f_not , [ f_hastask ] ] , [ f_side , GetSide ( opravit [ i ] [ 1 ] ) ] , [ f_dist , opravit [ i ] [ 1 ] , ( ( ( 1000 div 30 ) + 5 ) - GetLives ( opravit [ i ] [ 1 ] ) div 30 ) ] ] ) , opravit [ i ] [ 1 ] ) ;
22515: LD_EXP 84
22519: PPUSH
22520: LD_INT 3
22522: PUSH
22523: LD_INT 60
22525: PUSH
22526: EMPTY
22527: LIST
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: PUSH
22533: LD_INT 22
22535: PUSH
22536: LD_LOC 29
22540: PUSH
22541: LD_VAR 0 1
22545: ARRAY
22546: PUSH
22547: LD_INT 1
22549: ARRAY
22550: PPUSH
22551: CALL_OW 255
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PUSH
22560: LD_INT 91
22562: PUSH
22563: LD_LOC 29
22567: PUSH
22568: LD_VAR 0 1
22572: ARRAY
22573: PUSH
22574: LD_INT 1
22576: ARRAY
22577: PUSH
22578: LD_INT 1000
22580: PUSH
22581: LD_INT 30
22583: DIV
22584: PUSH
22585: LD_INT 5
22587: PLUS
22588: PUSH
22589: LD_LOC 29
22593: PUSH
22594: LD_VAR 0 1
22598: ARRAY
22599: PUSH
22600: LD_INT 1
22602: ARRAY
22603: PPUSH
22604: CALL_OW 256
22608: PUSH
22609: LD_INT 30
22611: DIV
22612: MINUS
22613: PUSH
22614: EMPTY
22615: LIST
22616: LIST
22617: LIST
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: LIST
22623: PPUSH
22624: CALL_OW 72
22628: PPUSH
22629: LD_LOC 29
22633: PUSH
22634: LD_VAR 0 1
22638: ARRAY
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 130
// end ; end ;
22648: GO 22500
22650: POP
22651: POP
// enable ;
22652: ENABLE
// end ; end_of_file
22653: PPOPN 1
22655: END
// export factories ; export depots ; export buildings ; export humans ; export vehicles ; export attack_units ; export defence_units ; export mcdef_units ; export fort , sol , dep , eng , fact , mec , lab , sci ; export function inicializace_ai ; begin
22656: LD_INT 0
22658: PPUSH
// factories := [ 0 , 0 , 0 , 0 , 0 ] ;
22659: LD_ADDR_EXP 73
22663: PUSH
22664: LD_INT 0
22666: PUSH
22667: LD_INT 0
22669: PUSH
22670: LD_INT 0
22672: PUSH
22673: LD_INT 0
22675: PUSH
22676: LD_INT 0
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: LIST
22685: ST_TO_ADDR
// depots := [ 0 , 0 , 0 , 0 , 0 ] ;
22686: LD_ADDR_EXP 74
22690: PUSH
22691: LD_INT 0
22693: PUSH
22694: LD_INT 0
22696: PUSH
22697: LD_INT 0
22699: PUSH
22700: LD_INT 0
22702: PUSH
22703: LD_INT 0
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: ST_TO_ADDR
// buildings := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22713: LD_ADDR_EXP 75
22717: PUSH
22718: EMPTY
22719: PUSH
22720: EMPTY
22721: PUSH
22722: EMPTY
22723: PUSH
22724: EMPTY
22725: PUSH
22726: EMPTY
22727: PUSH
22728: EMPTY
22729: LIST
22730: LIST
22731: LIST
22732: LIST
22733: LIST
22734: ST_TO_ADDR
// humans := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22735: LD_ADDR_EXP 76
22739: PUSH
22740: EMPTY
22741: PUSH
22742: EMPTY
22743: PUSH
22744: EMPTY
22745: PUSH
22746: EMPTY
22747: PUSH
22748: EMPTY
22749: PUSH
22750: EMPTY
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: ST_TO_ADDR
// vehicles := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22757: LD_ADDR_EXP 77
22761: PUSH
22762: EMPTY
22763: PUSH
22764: EMPTY
22765: PUSH
22766: EMPTY
22767: PUSH
22768: EMPTY
22769: PUSH
22770: EMPTY
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: ST_TO_ADDR
// attack_units := [ ] ;
22779: LD_ADDR_EXP 78
22783: PUSH
22784: EMPTY
22785: ST_TO_ADDR
// defence_units := [ ] ;
22786: LD_ADDR_EXP 79
22790: PUSH
22791: EMPTY
22792: ST_TO_ADDR
// end ;
22793: LD_VAR 0 1
22797: RET
// export function get_groups ; var i ; begin
22798: LD_INT 0
22800: PPUSH
22801: PPUSH
// fort := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fort ] ) ;
22802: LD_ADDR_EXP 81
22806: PUSH
22807: LD_INT 3
22809: PUSH
22810: LD_INT 22
22812: PUSH
22813: LD_EXP 7
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: PUSH
22826: LD_EXP 56
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: PPUSH
22835: CALL_OW 69
22839: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sol ] ) diff hlavouni ;
22840: LD_ADDR_EXP 82
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: LD_INT 22
22850: PUSH
22851: LD_EXP 7
22855: PUSH
22856: EMPTY
22857: LIST
22858: LIST
22859: PUSH
22860: EMPTY
22861: LIST
22862: LIST
22863: PUSH
22864: LD_EXP 51
22868: PUSH
22869: EMPTY
22870: LIST
22871: LIST
22872: PPUSH
22873: CALL_OW 69
22877: PUSH
22878: LD_EXP 72
22882: DIFF
22883: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_dep ] ) ;
22884: LD_ADDR_EXP 83
22888: PUSH
22889: LD_INT 3
22891: PUSH
22892: LD_INT 22
22894: PUSH
22895: LD_EXP 7
22899: PUSH
22900: EMPTY
22901: LIST
22902: LIST
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PUSH
22908: LD_EXP 58
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: PPUSH
22917: CALL_OW 69
22921: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_eng ] ) diff hlavouni ;
22922: LD_ADDR_EXP 84
22926: PUSH
22927: LD_INT 3
22929: PUSH
22930: LD_INT 22
22932: PUSH
22933: LD_EXP 7
22937: PUSH
22938: EMPTY
22939: LIST
22940: LIST
22941: PUSH
22942: EMPTY
22943: LIST
22944: LIST
22945: PUSH
22946: LD_EXP 52
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PPUSH
22955: CALL_OW 69
22959: PUSH
22960: LD_EXP 72
22964: DIFF
22965: ST_TO_ADDR
// fact := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fact ] ) ;
22966: LD_ADDR_EXP 85
22970: PUSH
22971: LD_INT 3
22973: PUSH
22974: LD_INT 22
22976: PUSH
22977: LD_EXP 7
22981: PUSH
22982: EMPTY
22983: LIST
22984: LIST
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_EXP 59
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: PPUSH
22999: CALL_OW 69
23003: ST_TO_ADDR
// mec := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_mec ] ) diff hlavouni ;
23004: LD_ADDR_EXP 86
23008: PUSH
23009: LD_INT 3
23011: PUSH
23012: LD_INT 22
23014: PUSH
23015: LD_EXP 7
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_EXP 53
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: PPUSH
23037: CALL_OW 69
23041: PUSH
23042: LD_EXP 72
23046: DIFF
23047: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_lab ] ) ;
23048: LD_ADDR_EXP 87
23052: PUSH
23053: LD_INT 3
23055: PUSH
23056: LD_INT 22
23058: PUSH
23059: LD_EXP 7
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PUSH
23072: LD_EXP 55
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PPUSH
23081: CALL_OW 69
23085: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sci ] ) diff hlavouni ;
23086: LD_ADDR_EXP 88
23090: PUSH
23091: LD_INT 3
23093: PUSH
23094: LD_INT 22
23096: PUSH
23097: LD_EXP 7
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: PUSH
23110: LD_EXP 54
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: PPUSH
23119: CALL_OW 69
23123: PUSH
23124: LD_EXP 72
23128: DIFF
23129: ST_TO_ADDR
// for i := 1 to 5 do
23130: LD_ADDR_VAR 0 2
23134: PUSH
23135: DOUBLE
23136: LD_INT 1
23138: DEC
23139: ST_TO_ADDR
23140: LD_INT 5
23142: PUSH
23143: FOR_TO
23144: IFFALSE 23329
// begin humans := replace ( humans , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_human ] ] ) diff hlavouni ) ;
23146: LD_ADDR_EXP 76
23150: PUSH
23151: LD_EXP 76
23155: PPUSH
23156: LD_VAR 0 2
23160: PPUSH
23161: LD_INT 22
23163: PUSH
23164: LD_EXP 23
23168: PUSH
23169: LD_VAR 0 2
23173: ARRAY
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: PUSH
23179: LD_INT 21
23181: PUSH
23182: LD_INT 1
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: PPUSH
23193: CALL_OW 69
23197: PUSH
23198: LD_EXP 72
23202: DIFF
23203: PPUSH
23204: CALL_OW 1
23208: ST_TO_ADDR
// vehicles := replace ( vehicles , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_vehicle ] ] ) diff art_cargo ) ;
23209: LD_ADDR_EXP 77
23213: PUSH
23214: LD_EXP 77
23218: PPUSH
23219: LD_VAR 0 2
23223: PPUSH
23224: LD_INT 22
23226: PUSH
23227: LD_EXP 23
23231: PUSH
23232: LD_VAR 0 2
23236: ARRAY
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 21
23244: PUSH
23245: LD_INT 2
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: PPUSH
23256: CALL_OW 69
23260: PUSH
23261: LD_INT 121
23263: DIFF
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// buildings := replace ( buildings , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_building ] ] ) ) ;
23270: LD_ADDR_EXP 75
23274: PUSH
23275: LD_EXP 75
23279: PPUSH
23280: LD_VAR 0 2
23284: PPUSH
23285: LD_INT 22
23287: PUSH
23288: LD_EXP 23
23292: PUSH
23293: LD_VAR 0 2
23297: ARRAY
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: LD_INT 21
23305: PUSH
23306: LD_INT 3
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PPUSH
23317: CALL_OW 69
23321: PPUSH
23322: CALL_OW 1
23326: ST_TO_ADDR
// end ;
23327: GO 23143
23329: POP
23330: POP
// attack_units := FilterAllUnits ( [ [ f_control , control_computer ] ] ) ;
23331: LD_ADDR_EXP 78
23335: PUSH
23336: LD_INT 33
23338: PUSH
23339: LD_INT 3
23341: PUSH
23342: EMPTY
23343: LIST
23344: LIST
23345: PUSH
23346: EMPTY
23347: LIST
23348: PPUSH
23349: CALL_OW 69
23353: ST_TO_ADDR
// defence_units := FilterAllUnits ( [ [ f_control , control_manual ] ] ) diff art_cargo ;
23354: LD_ADDR_EXP 79
23358: PUSH
23359: LD_INT 33
23361: PUSH
23362: LD_INT 1
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: EMPTY
23370: LIST
23371: PPUSH
23372: CALL_OW 69
23376: PUSH
23377: LD_INT 121
23379: DIFF
23380: ST_TO_ADDR
// write_deps ;
23381: CALL 23394 0 0
// write_facts ;
23385: CALL 23513 0 0
// end ;
23389: LD_VAR 0 1
23393: RET
// export function write_deps ; var i , a ; begin
23394: LD_INT 0
23396: PPUSH
23397: PPUSH
23398: PPUSH
// for i := 1 to 5 do
23399: LD_ADDR_VAR 0 2
23403: PUSH
23404: DOUBLE
23405: LD_INT 1
23407: DEC
23408: ST_TO_ADDR
23409: LD_INT 5
23411: PUSH
23412: FOR_TO
23413: IFFALSE 23506
// begin a := UnitFilter ( buildings [ i ] , [ mf_dep ] ) ;
23415: LD_ADDR_VAR 0 3
23419: PUSH
23420: LD_EXP 75
23424: PUSH
23425: LD_VAR 0 2
23429: ARRAY
23430: PPUSH
23431: LD_EXP 58
23435: PUSH
23436: EMPTY
23437: LIST
23438: PPUSH
23439: CALL_OW 72
23443: ST_TO_ADDR
// if a then
23444: LD_VAR 0 3
23448: IFFALSE 23481
// depots := replace ( depots , i , a [ 1 ] ) else
23450: LD_ADDR_EXP 74
23454: PUSH
23455: LD_EXP 74
23459: PPUSH
23460: LD_VAR 0 2
23464: PPUSH
23465: LD_VAR 0 3
23469: PUSH
23470: LD_INT 1
23472: ARRAY
23473: PPUSH
23474: CALL_OW 1
23478: ST_TO_ADDR
23479: GO 23504
// depots := replace ( depots , i , 0 ) ;
23481: LD_ADDR_EXP 74
23485: PUSH
23486: LD_EXP 74
23490: PPUSH
23491: LD_VAR 0 2
23495: PPUSH
23496: LD_INT 0
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// end ;
23504: GO 23412
23506: POP
23507: POP
// end ;
23508: LD_VAR 0 1
23512: RET
// export function write_facts ; var i , a ; begin
23513: LD_INT 0
23515: PPUSH
23516: PPUSH
23517: PPUSH
// for i := 1 to 5 do
23518: LD_ADDR_VAR 0 2
23522: PUSH
23523: DOUBLE
23524: LD_INT 1
23526: DEC
23527: ST_TO_ADDR
23528: LD_INT 5
23530: PUSH
23531: FOR_TO
23532: IFFALSE 23625
// begin a := UnitFilter ( buildings [ i ] , [ mf_fact ] ) ;
23534: LD_ADDR_VAR 0 3
23538: PUSH
23539: LD_EXP 75
23543: PUSH
23544: LD_VAR 0 2
23548: ARRAY
23549: PPUSH
23550: LD_EXP 59
23554: PUSH
23555: EMPTY
23556: LIST
23557: PPUSH
23558: CALL_OW 72
23562: ST_TO_ADDR
// if a then
23563: LD_VAR 0 3
23567: IFFALSE 23600
// factories := replace ( factories , i , a [ 1 ] ) else
23569: LD_ADDR_EXP 73
23573: PUSH
23574: LD_EXP 73
23578: PPUSH
23579: LD_VAR 0 2
23583: PPUSH
23584: LD_VAR 0 3
23588: PUSH
23589: LD_INT 1
23591: ARRAY
23592: PPUSH
23593: CALL_OW 1
23597: ST_TO_ADDR
23598: GO 23623
// factories := replace ( factories , i , 0 ) ;
23600: LD_ADDR_EXP 73
23604: PUSH
23605: LD_EXP 73
23609: PPUSH
23610: LD_VAR 0 2
23614: PPUSH
23615: LD_INT 0
23617: PPUSH
23618: CALL_OW 1
23622: ST_TO_ADDR
// end ;
23623: GO 23531
23625: POP
23626: POP
// end ;
23627: LD_VAR 0 1
23631: RET
// every 0 0$6 + 0 0$0.9 do var i , j , blds , hums , cars ;
23632: GO 23634
23634: DISABLE
23635: LD_INT 0
23637: PPUSH
23638: PPUSH
23639: PPUSH
23640: PPUSH
23641: PPUSH
// begin hums := [ ] ;
23642: LD_ADDR_VAR 0 4
23646: PUSH
23647: EMPTY
23648: ST_TO_ADDR
// for i in sol do
23649: LD_ADDR_VAR 0 1
23653: PUSH
23654: LD_EXP 82
23658: PUSH
23659: FOR_IN
23660: IFFALSE 23736
// if ( not HasTask ( i ) and not ( GetBType ( IsInUnit ( i ) ) = b_bunker or GetBType ( IsInUnit ( i ) ) = b_breastwork ) ) then
23662: LD_VAR 0 1
23666: PPUSH
23667: CALL_OW 314
23671: NOT
23672: PUSH
23673: LD_VAR 0 1
23677: PPUSH
23678: CALL_OW 310
23682: PPUSH
23683: CALL_OW 266
23687: PUSH
23688: LD_INT 32
23690: EQUAL
23691: PUSH
23692: LD_VAR 0 1
23696: PPUSH
23697: CALL_OW 310
23701: PPUSH
23702: CALL_OW 266
23706: PUSH
23707: LD_INT 31
23709: EQUAL
23710: OR
23711: NOT
23712: AND
23713: IFFALSE 23734
// hums := hums ^ [ i ] ;
23715: LD_ADDR_VAR 0 4
23719: PUSH
23720: LD_VAR 0 4
23724: PUSH
23725: LD_VAR 0 1
23729: PUSH
23730: EMPTY
23731: LIST
23732: ADD
23733: ST_TO_ADDR
23734: GO 23659
23736: POP
23737: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ mf_bunk ] ] ) ;
23738: LD_ADDR_VAR 0 3
23742: PUSH
23743: LD_EXP 81
23747: PPUSH
23748: LD_INT 3
23750: PUSH
23751: LD_INT 59
23753: PUSH
23754: EMPTY
23755: LIST
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: LD_EXP 57
23765: PUSH
23766: EMPTY
23767: LIST
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PPUSH
23773: CALL_OW 72
23777: ST_TO_ADDR
// for i in blds do
23778: LD_ADDR_VAR 0 1
23782: PUSH
23783: LD_VAR 0 3
23787: PUSH
23788: FOR_IN
23789: IFFALSE 23894
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 40 ] ] ) , i ) ;
23791: LD_ADDR_VAR 0 2
23795: PUSH
23796: LD_VAR 0 4
23800: PPUSH
23801: LD_INT 22
23803: PUSH
23804: LD_VAR 0 1
23808: PPUSH
23809: CALL_OW 255
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: PUSH
23818: LD_INT 91
23820: PUSH
23821: LD_VAR 0 1
23825: PUSH
23826: LD_INT 40
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: LIST
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PPUSH
23838: CALL_OW 72
23842: PPUSH
23843: LD_VAR 0 1
23847: PPUSH
23848: CALL_OW 74
23852: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23853: LD_VAR 0 2
23857: PPUSH
23858: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23862: LD_VAR 0 2
23866: PPUSH
23867: LD_VAR 0 1
23871: PPUSH
23872: CALL_OW 180
// hums := hums diff j ;
23876: LD_ADDR_VAR 0 4
23880: PUSH
23881: LD_VAR 0 4
23885: PUSH
23886: LD_VAR 0 2
23890: DIFF
23891: ST_TO_ADDR
// end ;
23892: GO 23788
23894: POP
23895: POP
// cars := UnitFilter ( defence_units , [ f_not , [ f_occupied ] ] ) ;
23896: LD_ADDR_VAR 0 5
23900: PUSH
23901: LD_EXP 79
23905: PPUSH
23906: LD_INT 3
23908: PUSH
23909: LD_INT 59
23911: PUSH
23912: EMPTY
23913: LIST
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: PPUSH
23919: CALL_OW 72
23923: ST_TO_ADDR
// for i in cars do
23924: LD_ADDR_VAR 0 1
23928: PUSH
23929: LD_VAR 0 5
23933: PUSH
23934: FOR_IN
23935: IFFALSE 24040
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
23937: LD_ADDR_VAR 0 2
23941: PUSH
23942: LD_VAR 0 4
23946: PPUSH
23947: LD_INT 22
23949: PUSH
23950: LD_VAR 0 1
23954: PPUSH
23955: CALL_OW 255
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: LD_INT 91
23966: PUSH
23967: LD_VAR 0 1
23971: PUSH
23972: LD_INT 30
23974: PUSH
23975: EMPTY
23976: LIST
23977: LIST
23978: LIST
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PPUSH
23984: CALL_OW 72
23988: PPUSH
23989: LD_VAR 0 1
23993: PPUSH
23994: CALL_OW 74
23998: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23999: LD_VAR 0 2
24003: PPUSH
24004: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
24008: LD_VAR 0 2
24012: PPUSH
24013: LD_VAR 0 1
24017: PPUSH
24018: CALL_OW 180
// hums := hums diff j ;
24022: LD_ADDR_VAR 0 4
24026: PUSH
24027: LD_VAR 0 4
24031: PUSH
24032: LD_VAR 0 2
24036: DIFF
24037: ST_TO_ADDR
// end ;
24038: GO 23934
24040: POP
24041: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
24042: LD_ADDR_VAR 0 3
24046: PUSH
24047: LD_EXP 81
24051: PPUSH
24052: LD_INT 3
24054: PUSH
24055: LD_INT 59
24057: PUSH
24058: EMPTY
24059: LIST
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: LD_INT 2
24067: PUSH
24068: LD_INT 30
24070: PUSH
24071: LD_INT 5
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 30
24080: PUSH
24081: LD_INT 4
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: PPUSH
24097: CALL_OW 72
24101: ST_TO_ADDR
// for i in blds do
24102: LD_ADDR_VAR 0 1
24106: PUSH
24107: LD_VAR 0 3
24111: PUSH
24112: FOR_IN
24113: IFFALSE 24173
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24115: LD_VAR 0 4
24119: PPUSH
24120: LD_INT 22
24122: PUSH
24123: LD_VAR 0 1
24127: PPUSH
24128: CALL_OW 255
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 91
24139: PUSH
24140: LD_VAR 0 1
24144: PUSH
24145: LD_INT 30
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: PPUSH
24157: CALL_OW 72
24161: PPUSH
24162: LD_VAR 0 1
24166: PPUSH
24167: CALL_OW 120
24171: GO 24112
24173: POP
24174: POP
// enable ;
24175: ENABLE
// end ;
24176: PPOPN 5
24178: END
// every 0 0$2 + 0 0$0.5 do var i , j , blds , hums ;
24179: GO 24181
24181: DISABLE
24182: LD_INT 0
24184: PPUSH
24185: PPUSH
24186: PPUSH
24187: PPUSH
// begin blds := dep ;
24188: LD_ADDR_VAR 0 3
24192: PUSH
24193: LD_EXP 83
24197: ST_TO_ADDR
// hums := [ ] ;
24198: LD_ADDR_VAR 0 4
24202: PUSH
24203: EMPTY
24204: ST_TO_ADDR
// for i in eng do
24205: LD_ADDR_VAR 0 1
24209: PUSH
24210: LD_EXP 84
24214: PUSH
24215: FOR_IN
24216: IFFALSE 24263
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24218: LD_VAR 0 1
24222: PPUSH
24223: CALL_OW 315
24227: NOT
24228: PUSH
24229: LD_VAR 0 1
24233: PPUSH
24234: CALL_OW 310
24238: NOT
24239: AND
24240: IFFALSE 24261
// hums := hums ^ [ i ] ;
24242: LD_ADDR_VAR 0 4
24246: PUSH
24247: LD_VAR 0 4
24251: PUSH
24252: LD_VAR 0 1
24256: PUSH
24257: EMPTY
24258: LIST
24259: ADD
24260: ST_TO_ADDR
24261: GO 24215
24263: POP
24264: POP
// for i in blds do
24265: LD_ADDR_VAR 0 1
24269: PUSH
24270: LD_VAR 0 3
24274: PUSH
24275: FOR_IN
24276: IFFALSE 24336
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , GetSide ( i ) ] , [ f_dist , i , 25 ] ] ) , i ) ;
24278: LD_VAR 0 4
24282: PPUSH
24283: LD_INT 22
24285: PUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 255
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: LD_INT 91
24302: PUSH
24303: LD_VAR 0 1
24307: PUSH
24308: LD_INT 25
24310: PUSH
24311: EMPTY
24312: LIST
24313: LIST
24314: LIST
24315: PUSH
24316: EMPTY
24317: LIST
24318: LIST
24319: PPUSH
24320: CALL_OW 72
24324: PPUSH
24325: LD_VAR 0 1
24329: PPUSH
24330: CALL_OW 120
24334: GO 24275
24336: POP
24337: POP
// enable ;
24338: ENABLE
// end ;
24339: PPOPN 4
24341: END
// every 0 0$2 + 0 0$0.7 do var i , j , blds , hums ;
24342: GO 24344
24344: DISABLE
24345: LD_INT 0
24347: PPUSH
24348: PPUSH
24349: PPUSH
24350: PPUSH
// begin blds := fact ;
24351: LD_ADDR_VAR 0 3
24355: PUSH
24356: LD_EXP 85
24360: ST_TO_ADDR
// hums := [ ] ;
24361: LD_ADDR_VAR 0 4
24365: PUSH
24366: EMPTY
24367: ST_TO_ADDR
// for i in mec do
24368: LD_ADDR_VAR 0 1
24372: PUSH
24373: LD_EXP 86
24377: PUSH
24378: FOR_IN
24379: IFFALSE 24426
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24381: LD_VAR 0 1
24385: PPUSH
24386: CALL_OW 315
24390: NOT
24391: PUSH
24392: LD_VAR 0 1
24396: PPUSH
24397: CALL_OW 310
24401: NOT
24402: AND
24403: IFFALSE 24424
// hums := hums ^ [ i ] ;
24405: LD_ADDR_VAR 0 4
24409: PUSH
24410: LD_VAR 0 4
24414: PUSH
24415: LD_VAR 0 1
24419: PUSH
24420: EMPTY
24421: LIST
24422: ADD
24423: ST_TO_ADDR
24424: GO 24378
24426: POP
24427: POP
// for i in blds do
24428: LD_ADDR_VAR 0 1
24432: PUSH
24433: LD_VAR 0 3
24437: PUSH
24438: FOR_IN
24439: IFFALSE 24499
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24441: LD_VAR 0 4
24445: PPUSH
24446: LD_INT 22
24448: PUSH
24449: LD_VAR 0 1
24453: PPUSH
24454: CALL_OW 255
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 91
24465: PUSH
24466: LD_VAR 0 1
24470: PUSH
24471: LD_INT 30
24473: PUSH
24474: EMPTY
24475: LIST
24476: LIST
24477: LIST
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: PPUSH
24483: CALL_OW 72
24487: PPUSH
24488: LD_VAR 0 1
24492: PPUSH
24493: CALL_OW 120
24497: GO 24438
24499: POP
24500: POP
// enable ;
24501: ENABLE
// end ;
24502: PPOPN 4
24504: END
// every 0 0$2 + 0 0$0.9 do var i , j , blds , hums ;
24505: GO 24507
24507: DISABLE
24508: LD_INT 0
24510: PPUSH
24511: PPUSH
24512: PPUSH
24513: PPUSH
// begin blds := lab ;
24514: LD_ADDR_VAR 0 3
24518: PUSH
24519: LD_EXP 87
24523: ST_TO_ADDR
// hums := [ ] ;
24524: LD_ADDR_VAR 0 4
24528: PUSH
24529: EMPTY
24530: ST_TO_ADDR
// for i in sci do
24531: LD_ADDR_VAR 0 1
24535: PUSH
24536: LD_EXP 88
24540: PUSH
24541: FOR_IN
24542: IFFALSE 24589
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24544: LD_VAR 0 1
24548: PPUSH
24549: CALL_OW 315
24553: NOT
24554: PUSH
24555: LD_VAR 0 1
24559: PPUSH
24560: CALL_OW 310
24564: NOT
24565: AND
24566: IFFALSE 24587
// hums := hums ^ [ i ] ;
24568: LD_ADDR_VAR 0 4
24572: PUSH
24573: LD_VAR 0 4
24577: PUSH
24578: LD_VAR 0 1
24582: PUSH
24583: EMPTY
24584: LIST
24585: ADD
24586: ST_TO_ADDR
24587: GO 24541
24589: POP
24590: POP
// for i in blds do
24591: LD_ADDR_VAR 0 1
24595: PUSH
24596: LD_VAR 0 3
24600: PUSH
24601: FOR_IN
24602: IFFALSE 24662
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24604: LD_VAR 0 4
24608: PPUSH
24609: LD_INT 22
24611: PUSH
24612: LD_VAR 0 1
24616: PPUSH
24617: CALL_OW 255
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 91
24628: PUSH
24629: LD_VAR 0 1
24633: PUSH
24634: LD_INT 30
24636: PUSH
24637: EMPTY
24638: LIST
24639: LIST
24640: LIST
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PPUSH
24646: CALL_OW 72
24650: PPUSH
24651: LD_VAR 0 1
24655: PPUSH
24656: CALL_OW 120
24660: GO 24601
24662: POP
24663: POP
// enable ;
24664: ENABLE
// end ; end_of_file
24665: PPOPN 4
24667: END
// on UnitDestroyed ( un ) do var h , hinfo , a ;
24668: LD_INT 0
24670: PPUSH
24671: PPUSH
24672: PPUSH
// begin if un = Burlak then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_EXP 41
24682: EQUAL
24683: IFFALSE 24692
// begin YouLost ( Burlak ) ;
24685: LD_STRING Burlak
24687: PPUSH
24688: CALL_OW 104
// end ; if un = Platonov then
24692: LD_VAR 0 1
24696: PUSH
24697: LD_EXP 42
24701: EQUAL
24702: IFFALSE 24727
// begin SurrenderBase ( t_kill , GetSide ( un ) ) ;
24704: LD_EXP 1
24708: PPUSH
24709: LD_VAR 0 1
24713: PPUSH
24714: CALL_OW 255
24718: PPUSH
24719: CALL 30354 0 2
// VyhraPlaton ;
24723: CALL 358 0 0
// end ; if GetSide ( un ) <> you then
24727: LD_VAR 0 1
24731: PPUSH
24732: CALL_OW 255
24736: PUSH
24737: LD_EXP 7
24741: NONEQUAL
24742: IFFALSE 24771
// begin remove_from_vehicles ( un ) ;
24744: LD_VAR 0 1
24748: PPUSH
24749: CALL 28260 0 1
// remove_from_humans ( un ) ;
24753: LD_VAR 0 1
24757: PPUSH
24758: CALL 28022 0 1
// remove_from_builds ( un ) ;
24762: LD_VAR 0 1
24766: PPUSH
24767: CALL 27776 0 1
// end ; if not GetSide ( un ) in your_bases then
24771: LD_VAR 0 1
24775: PPUSH
24776: CALL_OW 255
24780: PUSH
24781: LD_EXP 18
24785: IN
24786: NOT
24787: IFFALSE 24909
// begin if un = Borodin then
24789: LD_VAR 0 1
24793: PUSH
24794: LD_EXP 46
24798: EQUAL
24799: IFFALSE 24819
// begin SurrenderBase ( t_kill , ai_s [ 2 ] ) ;
24801: LD_EXP 1
24805: PPUSH
24806: LD_EXP 23
24810: PUSH
24811: LD_INT 2
24813: ARRAY
24814: PPUSH
24815: CALL 30354 0 2
// end ; if un = Tsaritsyn then
24819: LD_VAR 0 1
24823: PUSH
24824: LD_EXP 47
24828: EQUAL
24829: IFFALSE 24849
// begin SurrenderBase ( t_kill , ai_s [ 3 ] ) ;
24831: LD_EXP 1
24835: PPUSH
24836: LD_EXP 23
24840: PUSH
24841: LD_INT 3
24843: ARRAY
24844: PPUSH
24845: CALL 30354 0 2
// end ; if un = Davidov then
24849: LD_VAR 0 1
24853: PUSH
24854: LD_EXP 48
24858: EQUAL
24859: IFFALSE 24879
// begin SurrenderBase ( t_kill , ai_s [ 4 ] ) ;
24861: LD_EXP 1
24865: PPUSH
24866: LD_EXP 23
24870: PUSH
24871: LD_INT 4
24873: ARRAY
24874: PPUSH
24875: CALL 30354 0 2
// end ; if un = Eisenstein then
24879: LD_VAR 0 1
24883: PUSH
24884: LD_EXP 49
24888: EQUAL
24889: IFFALSE 24909
// begin SurrenderBase ( t_kill , ai_s [ 5 ] ) ;
24891: LD_EXP 1
24895: PPUSH
24896: LD_EXP 23
24900: PUSH
24901: LD_INT 5
24903: ARRAY
24904: PPUSH
24905: CALL 30354 0 2
// end ; end ; if GetSide ( un ) = you then
24909: LD_VAR 0 1
24913: PPUSH
24914: CALL_OW 255
24918: PUSH
24919: LD_EXP 7
24923: EQUAL
24924: IFFALSE 25044
// case true of GetType ( un ) = unit_building :
24926: LD_INT 1
24928: PUSH
24929: LD_VAR 0 1
24933: PPUSH
24934: CALL_OW 247
24938: PUSH
24939: LD_INT 3
24941: EQUAL
24942: DOUBLE
24943: EQUAL
24944: IFTRUE 24948
24946: GO 24967
24948: POP
// your_builds := your_builds diff un ; GetType ( un ) = unit_vehicle :
24949: LD_ADDR_EXP 36
24953: PUSH
24954: LD_EXP 36
24958: PUSH
24959: LD_VAR 0 1
24963: DIFF
24964: ST_TO_ADDR
24965: GO 25044
24967: LD_VAR 0 1
24971: PPUSH
24972: CALL_OW 247
24976: PUSH
24977: LD_INT 2
24979: EQUAL
24980: DOUBLE
24981: EQUAL
24982: IFTRUE 24986
24984: GO 25005
24986: POP
// your_cars := your_cars diff un ; GetType ( un ) = unit_human :
24987: LD_ADDR_EXP 35
24991: PUSH
24992: LD_EXP 35
24996: PUSH
24997: LD_VAR 0 1
25001: DIFF
25002: ST_TO_ADDR
25003: GO 25044
25005: LD_VAR 0 1
25009: PPUSH
25010: CALL_OW 247
25014: PUSH
25015: LD_INT 1
25017: EQUAL
25018: DOUBLE
25019: EQUAL
25020: IFTRUE 25024
25022: GO 25043
25024: POP
// your_humans := your_humans diff un ; end ;
25025: LD_ADDR_EXP 37
25029: PUSH
25030: LD_EXP 37
25034: PUSH
25035: LD_VAR 0 1
25039: DIFF
25040: ST_TO_ADDR
25041: GO 25044
25043: POP
// end ;
25044: PPOPN 4
25046: END
// on UnitGoesToRed ( un ) do var a ;
25047: LD_INT 0
25049: PPUSH
// begin if not GetSide ( un ) in your_bases ^ you then
25050: LD_VAR 0 1
25054: PPUSH
25055: CALL_OW 255
25059: PUSH
25060: LD_EXP 18
25064: PUSH
25065: LD_EXP 7
25069: ADD
25070: IN
25071: NOT
25072: IFFALSE 25305
// begin if GetBType ( un ) in [ b_depot , b_warehouse ] then
25074: LD_VAR 0 1
25078: PPUSH
25079: CALL_OW 266
25083: PUSH
25084: LD_INT 0
25086: PUSH
25087: LD_INT 1
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: IN
25094: IFFALSE 25305
// begin a := FilterAllUnits ( [ [ f_side , GetSide ( un ) ] ] ) ;
25096: LD_ADDR_VAR 0 2
25100: PUSH
25101: LD_INT 22
25103: PUSH
25104: LD_VAR 0 1
25108: PPUSH
25109: CALL_OW 255
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: EMPTY
25119: LIST
25120: PPUSH
25121: CALL_OW 69
25125: ST_TO_ADDR
// if GetSide ( un ) = ai_s [ 1 ] and IsDead ( behemoth ) and UnitFilter ( a , [ mf_sol ] ) <= 2 and UnitFilter ( a , [ [ f_type , unit_vehicle ] , [ f_or , [ [ f_control , control_manual ] , [ f_occupied ] ] , [ f_control , control_computer ] ] ] ) <= 1 then
25126: LD_VAR 0 1
25130: PPUSH
25131: CALL_OW 255
25135: PUSH
25136: LD_EXP 23
25140: PUSH
25141: LD_INT 1
25143: ARRAY
25144: EQUAL
25145: PUSH
25146: LD_INT 125
25148: PPUSH
25149: CALL_OW 301
25153: AND
25154: PUSH
25155: LD_VAR 0 2
25159: PPUSH
25160: LD_EXP 51
25164: PUSH
25165: EMPTY
25166: LIST
25167: PPUSH
25168: CALL_OW 72
25172: PUSH
25173: LD_INT 2
25175: LESSEQUAL
25176: AND
25177: PUSH
25178: LD_VAR 0 2
25182: PPUSH
25183: LD_INT 21
25185: PUSH
25186: LD_INT 2
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: LD_INT 2
25195: PUSH
25196: LD_INT 33
25198: PUSH
25199: LD_INT 1
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: PUSH
25206: LD_INT 59
25208: PUSH
25209: EMPTY
25210: LIST
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: LD_INT 3
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: LIST
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PPUSH
25235: CALL_OW 72
25239: PUSH
25240: LD_INT 1
25242: LESSEQUAL
25243: AND
25244: IFFALSE 25265
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25246: LD_EXP 6
25250: PPUSH
25251: LD_VAR 0 1
25255: PPUSH
25256: CALL_OW 255
25260: PPUSH
25261: CALL 30354 0 2
// if GetSide ( un ) <> ai_s [ 1 ] then
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 255
25274: PUSH
25275: LD_EXP 23
25279: PUSH
25280: LD_INT 1
25282: ARRAY
25283: NONEQUAL
25284: IFFALSE 25305
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25286: LD_EXP 6
25290: PPUSH
25291: LD_VAR 0 1
25295: PPUSH
25296: CALL_OW 255
25300: PPUSH
25301: CALL 30354 0 2
// end ; end ; end ;
25305: PPOPN 2
25307: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside in ai then
25308: LD_VAR 0 3
25312: PUSH
25313: LD_EXP 24
25317: IN
25318: IFFALSE 25381
// begin remove_from_vehicles ( vehold ) ;
25320: LD_VAR 0 2
25324: PPUSH
25325: CALL 28260 0 1
// if GetAttitude ( origside , you ) = att_neutral then
25329: LD_VAR 0 3
25333: PPUSH
25334: LD_EXP 7
25338: PPUSH
25339: CALL_OW 81
25343: PUSH
25344: LD_INT 0
25346: EQUAL
25347: IFFALSE 25381
// begin ComExitVehicle ( vehnew ) ;
25349: LD_VAR 0 1
25353: PPUSH
25354: CALL_OW 121
// SetSide ( vehnew , origside ) ;
25358: LD_VAR 0 1
25362: PPUSH
25363: LD_VAR 0 3
25367: PPUSH
25368: CALL_OW 235
// add_to_vehicles ( vehnew ) ;
25372: LD_VAR 0 1
25376: PPUSH
25377: CALL 26929 0 1
// end ; end ; if Getside ( vehnew ) in ai then
25381: LD_VAR 0 1
25385: PPUSH
25386: CALL_OW 255
25390: PUSH
25391: LD_EXP 24
25395: IN
25396: IFFALSE 25407
// begin add_to_vehicles ( vehnew ) ;
25398: LD_VAR 0 1
25402: PPUSH
25403: CALL 26929 0 1
// end ; if origside = you then
25407: LD_VAR 0 3
25411: PUSH
25412: LD_EXP 7
25416: EQUAL
25417: IFFALSE 25435
// your_cars := your_cars diff vehold ;
25419: LD_ADDR_EXP 35
25423: PUSH
25424: LD_EXP 35
25428: PUSH
25429: LD_VAR 0 2
25433: DIFF
25434: ST_TO_ADDR
// if GetSide ( vehnew ) = you then
25435: LD_VAR 0 1
25439: PPUSH
25440: CALL_OW 255
25444: PUSH
25445: LD_EXP 7
25449: EQUAL
25450: IFFALSE 25468
// your_cars := your_cars union vehnew ;
25452: LD_ADDR_EXP 35
25456: PUSH
25457: LD_EXP 35
25461: PUSH
25462: LD_VAR 0 1
25466: UNION
25467: ST_TO_ADDR
// if getside ( vehnew ) and GetCargo ( vehnew , mat_artefact ) > 0 then
25468: LD_VAR 0 1
25472: PPUSH
25473: CALL_OW 255
25477: PUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: LD_INT 4
25485: PPUSH
25486: CALL_OW 289
25490: PUSH
25491: LD_INT 0
25493: GREATER
25494: AND
25495: IFFALSE 25505
// maji_artifact := true ;
25497: LD_ADDR_EXP 39
25501: PUSH
25502: LD_INT 1
25504: ST_TO_ADDR
// if origside = you and GetCargo ( vehnew , mat_artefact ) > 0 then
25505: LD_VAR 0 3
25509: PUSH
25510: LD_EXP 7
25514: EQUAL
25515: PUSH
25516: LD_VAR 0 1
25520: PPUSH
25521: LD_INT 4
25523: PPUSH
25524: CALL_OW 289
25528: PUSH
25529: LD_INT 0
25531: GREATER
25532: AND
25533: IFFALSE 25543
// maji_artifact := false ;
25535: LD_ADDR_EXP 39
25539: PUSH
25540: LD_INT 0
25542: ST_TO_ADDR
// end ;
25543: PPOPN 4
25545: END
// on BuildingCaptured ( build , origside , eng ) do begin if origside = you then
25546: LD_VAR 0 2
25550: PUSH
25551: LD_EXP 7
25555: EQUAL
25556: IFFALSE 25574
// begin your_builds := your_builds diff build ;
25558: LD_ADDR_EXP 36
25562: PUSH
25563: LD_EXP 36
25567: PUSH
25568: LD_VAR 0 1
25572: DIFF
25573: ST_TO_ADDR
// end ; if GetSide ( build ) = you then
25574: LD_VAR 0 1
25578: PPUSH
25579: CALL_OW 255
25583: PUSH
25584: LD_EXP 7
25588: EQUAL
25589: IFFALSE 25607
// begin your_builds := your_builds union build ;
25591: LD_ADDR_EXP 36
25595: PUSH
25596: LD_EXP 36
25600: PUSH
25601: LD_VAR 0 1
25605: UNION
25606: ST_TO_ADDR
// end ; if origside in ai then
25607: LD_VAR 0 2
25611: PUSH
25612: LD_EXP 24
25616: IN
25617: IFFALSE 25628
// begin remove_from_builds ( build ) ;
25619: LD_VAR 0 1
25623: PPUSH
25624: CALL 27776 0 1
// end ; if GetSide ( build ) in ai then
25628: LD_VAR 0 1
25632: PPUSH
25633: CALL_OW 255
25637: PUSH
25638: LD_EXP 24
25642: IN
25643: IFFALSE 25654
// begin add_to_builds ( build ) ;
25645: LD_VAR 0 1
25649: PPUSH
25650: CALL 27274 0 1
// end ; end ;
25654: PPOPN 3
25656: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
25657: LD_VAR 0 1
25661: PPUSH
25662: CALL_OW 255
25666: PUSH
25667: LD_EXP 7
25671: EQUAL
25672: IFFALSE 25690
// begin your_builds := your_builds union build ;
25674: LD_ADDR_EXP 36
25678: PUSH
25679: LD_EXP 36
25683: PUSH
25684: LD_VAR 0 1
25688: UNION
25689: ST_TO_ADDR
// end ; if GetSide ( build ) in ai then
25690: LD_VAR 0 1
25694: PPUSH
25695: CALL_OW 255
25699: PUSH
25700: LD_EXP 24
25704: IN
25705: IFFALSE 25716
// begin add_to_builds ( build ) ;
25707: LD_VAR 0 1
25711: PPUSH
25712: CALL 27274 0 1
// end ; end ;
25716: PPOPN 1
25718: END
// on VehicleConstructed ( veh , fact ) do begin if GetSide ( veh ) = you then
25719: LD_VAR 0 1
25723: PPUSH
25724: CALL_OW 255
25728: PUSH
25729: LD_EXP 7
25733: EQUAL
25734: IFFALSE 25752
// begin your_cars := your_cars union veh ;
25736: LD_ADDR_EXP 35
25740: PUSH
25741: LD_EXP 35
25745: PUSH
25746: LD_VAR 0 1
25750: UNION
25751: ST_TO_ADDR
// end ; if GetSide ( veh ) in ai then
25752: LD_VAR 0 1
25756: PPUSH
25757: CALL_OW 255
25761: PUSH
25762: LD_EXP 24
25766: IN
25767: IFFALSE 26116
// begin if GetControl ( veh ) = control_computer then
25769: LD_VAR 0 1
25773: PPUSH
25774: CALL_OW 263
25778: PUSH
25779: LD_INT 3
25781: EQUAL
25782: IFFALSE 25942
// case GetSide ( veh ) of ai_s [ 1 ] :
25784: LD_VAR 0 1
25788: PPUSH
25789: CALL_OW 255
25793: PUSH
25794: LD_EXP 23
25798: PUSH
25799: LD_INT 1
25801: ARRAY
25802: DOUBLE
25803: EQUAL
25804: IFTRUE 25808
25806: GO 25823
25808: POP
// ComMoveToArea ( veh , pro_attA ) ; ai_s [ 2 ] :
25809: LD_VAR 0 1
25813: PPUSH
25814: LD_INT 8
25816: PPUSH
25817: CALL_OW 113
25821: GO 25940
25823: LD_EXP 23
25827: PUSH
25828: LD_INT 2
25830: ARRAY
25831: DOUBLE
25832: EQUAL
25833: IFTRUE 25837
25835: GO 25852
25837: POP
// ComMoveToArea ( veh , pro_attB ) ; ai_s [ 3 ] :
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 10
25845: PPUSH
25846: CALL_OW 113
25850: GO 25940
25852: LD_EXP 23
25856: PUSH
25857: LD_INT 3
25859: ARRAY
25860: DOUBLE
25861: EQUAL
25862: IFTRUE 25866
25864: GO 25881
25866: POP
// ComMoveToArea ( veh , pro_attC ) ; ai_s [ 4 ] :
25867: LD_VAR 0 1
25871: PPUSH
25872: LD_INT 17
25874: PPUSH
25875: CALL_OW 113
25879: GO 25940
25881: LD_EXP 23
25885: PUSH
25886: LD_INT 4
25888: ARRAY
25889: DOUBLE
25890: EQUAL
25891: IFTRUE 25895
25893: GO 25910
25895: POP
// ComMoveToArea ( veh , pro_attD ) ; ai_s [ 5 ] :
25896: LD_VAR 0 1
25900: PPUSH
25901: LD_INT 15
25903: PPUSH
25904: CALL_OW 113
25908: GO 25940
25910: LD_EXP 23
25914: PUSH
25915: LD_INT 5
25917: ARRAY
25918: DOUBLE
25919: EQUAL
25920: IFTRUE 25924
25922: GO 25939
25924: POP
// ComMoveToArea ( veh , pro_attE ) ; end else
25925: LD_VAR 0 1
25929: PPUSH
25930: LD_INT 12
25932: PPUSH
25933: CALL_OW 113
25937: GO 25940
25939: POP
25940: GO 26098
// case GetSide ( veh ) of ai_s [ 1 ] :
25942: LD_VAR 0 1
25946: PPUSH
25947: CALL_OW 255
25951: PUSH
25952: LD_EXP 23
25956: PUSH
25957: LD_INT 1
25959: ARRAY
25960: DOUBLE
25961: EQUAL
25962: IFTRUE 25966
25964: GO 25981
25966: POP
// ComMoveToArea ( veh , pro_defA ) ; ai_s [ 2 ] :
25967: LD_VAR 0 1
25971: PPUSH
25972: LD_INT 9
25974: PPUSH
25975: CALL_OW 113
25979: GO 26098
25981: LD_EXP 23
25985: PUSH
25986: LD_INT 2
25988: ARRAY
25989: DOUBLE
25990: EQUAL
25991: IFTRUE 25995
25993: GO 26010
25995: POP
// ComMoveToArea ( veh , pro_defB ) ; ai_s [ 3 ] :
25996: LD_VAR 0 1
26000: PPUSH
26001: LD_INT 11
26003: PPUSH
26004: CALL_OW 113
26008: GO 26098
26010: LD_EXP 23
26014: PUSH
26015: LD_INT 3
26017: ARRAY
26018: DOUBLE
26019: EQUAL
26020: IFTRUE 26024
26022: GO 26039
26024: POP
// ComMoveToArea ( veh , pro_defC ) ; ai_s [ 4 ] :
26025: LD_VAR 0 1
26029: PPUSH
26030: LD_INT 16
26032: PPUSH
26033: CALL_OW 113
26037: GO 26098
26039: LD_EXP 23
26043: PUSH
26044: LD_INT 4
26046: ARRAY
26047: DOUBLE
26048: EQUAL
26049: IFTRUE 26053
26051: GO 26068
26053: POP
// ComMoveToArea ( veh , pro_defD ) ; ai_s [ 5 ] :
26054: LD_VAR 0 1
26058: PPUSH
26059: LD_INT 14
26061: PPUSH
26062: CALL_OW 113
26066: GO 26098
26068: LD_EXP 23
26072: PUSH
26073: LD_INT 5
26075: ARRAY
26076: DOUBLE
26077: EQUAL
26078: IFTRUE 26082
26080: GO 26097
26082: POP
// ComMoveToArea ( veh , pro_defE ) ; end ;
26083: LD_VAR 0 1
26087: PPUSH
26088: LD_INT 13
26090: PPUSH
26091: CALL_OW 113
26095: GO 26098
26097: POP
// AddComExitVehicle ( veh ) ;
26098: LD_VAR 0 1
26102: PPUSH
26103: CALL_OW 181
// add_to_vehicles ( veh ) ;
26107: LD_VAR 0 1
26111: PPUSH
26112: CALL 26929 0 1
// end ; end ;
26116: PPOPN 2
26118: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) = you then
26119: LD_VAR 0 1
26123: PPUSH
26124: CALL_OW 255
26128: PUSH
26129: LD_EXP 7
26133: EQUAL
26134: IFFALSE 26144
// maji_artifact := true ;
26136: LD_ADDR_EXP 39
26140: PUSH
26141: LD_INT 1
26143: ST_TO_ADDR
// art_cargo1 := un ;
26144: LD_ADDR_EXP 34
26148: PUSH
26149: LD_VAR 0 1
26153: ST_TO_ADDR
// end ;
26154: PPOPN 2
26156: END
// on ArtifactUnloaded ( un , size ) do begin if GetSide ( un ) = you then
26157: LD_VAR 0 1
26161: PPUSH
26162: CALL_OW 255
26166: PUSH
26167: LD_EXP 7
26171: EQUAL
26172: IFFALSE 26182
// maji_artifact := false ;
26174: LD_ADDR_EXP 39
26178: PUSH
26179: LD_INT 0
26181: ST_TO_ADDR
// art_cargo1 := 0 ;
26182: LD_ADDR_EXP 34
26186: PUSH
26187: LD_INT 0
26189: ST_TO_ADDR
// end ;
26190: PPOPN 2
26192: END
// on Command ( comm ) do begin if not Getside ( Eisenstein ) = you and IsInUnit ( Eisenstein ) then
26193: LD_EXP 49
26197: PPUSH
26198: CALL_OW 255
26202: PUSH
26203: LD_EXP 7
26207: EQUAL
26208: NOT
26209: PUSH
26210: LD_EXP 49
26214: PPUSH
26215: CALL_OW 310
26219: AND
26220: IFFALSE 26231
// RemoveTasks ( Eisenstein ) ;
26222: LD_EXP 49
26226: PPUSH
26227: CALL_OW 493
// if not Getside ( Davidov ) = you and IsInUnit ( Davidov ) then
26231: LD_EXP 48
26235: PPUSH
26236: CALL_OW 255
26240: PUSH
26241: LD_EXP 7
26245: EQUAL
26246: NOT
26247: PUSH
26248: LD_EXP 48
26252: PPUSH
26253: CALL_OW 310
26257: AND
26258: IFFALSE 26269
// RemoveTasks ( Davidov ) ;
26260: LD_EXP 48
26264: PPUSH
26265: CALL_OW 493
// if not Getside ( Tsaritsyn ) = you and IsInUnit ( Tsaritsyn ) then
26269: LD_EXP 47
26273: PPUSH
26274: CALL_OW 255
26278: PUSH
26279: LD_EXP 7
26283: EQUAL
26284: NOT
26285: PUSH
26286: LD_EXP 47
26290: PPUSH
26291: CALL_OW 310
26295: AND
26296: IFFALSE 26307
// RemoveTasks ( Tsaritsyn ) ;
26298: LD_EXP 47
26302: PPUSH
26303: CALL_OW 493
// if not Getside ( Borodin ) = you and IsInUnit ( Borodin ) then
26307: LD_EXP 46
26311: PPUSH
26312: CALL_OW 255
26316: PUSH
26317: LD_EXP 7
26321: EQUAL
26322: NOT
26323: PUSH
26324: LD_EXP 46
26328: PPUSH
26329: CALL_OW 310
26333: AND
26334: IFFALSE 26345
// RemoveTasks ( Borodin ) ;
26336: LD_EXP 46
26340: PPUSH
26341: CALL_OW 493
// end ;
26345: PPOPN 1
26347: END
// on McAttackDone ( mcid , surv ) do begin msg ( [ mcid , McAttackDone , surv ] ) ;
26348: LD_VAR 0 1
26352: PUSH
26353: LD_STRING McAttackDone
26355: PUSH
26356: LD_VAR 0 2
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: LIST
26365: PPUSH
26366: CALL_OW 100
// end ;
26370: PPOPN 2
26372: END
// on McRegistryResultChanges ( mcid , count , strength ) do begin if mcid = BehMcRegId then
26373: LD_VAR 0 1
26377: PUSH
26378: LD_EXP 64
26382: EQUAL
26383: IFFALSE 26434
// debug_strings := replace ( debug_strings , 2 , [ mcid , count , strength , GetMcUnits ( BehMcAttId ) ] ) ;
26385: LD_ADDR_OWVAR 48
26389: PUSH
26390: LD_OWVAR 48
26394: PPUSH
26395: LD_INT 2
26397: PPUSH
26398: LD_VAR 0 1
26402: PUSH
26403: LD_VAR 0 2
26407: PUSH
26408: LD_VAR 0 3
26412: PUSH
26413: LD_EXP 65
26417: PPUSH
26418: CALL_OW 389
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: LIST
26427: LIST
26428: PPUSH
26429: CALL_OW 1
26433: ST_TO_ADDR
// end ;
26434: PPOPN 3
26436: END
// export function add_to ( un ) ; begin
26437: LD_INT 0
26439: PPUSH
// add_to_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
26440: LD_VAR 0 1
26444: PPUSH
26445: LD_INT 21
26447: PUSH
26448: LD_INT 1
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PUSH
26455: EMPTY
26456: LIST
26457: PPUSH
26458: CALL_OW 72
26462: PPUSH
26463: CALL 26526 0 1
// add_to_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
26467: LD_VAR 0 1
26471: PPUSH
26472: LD_INT 21
26474: PUSH
26475: LD_INT 3
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: EMPTY
26483: LIST
26484: PPUSH
26485: CALL_OW 72
26489: PPUSH
26490: CALL 27274 0 1
// add_to_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
26494: LD_VAR 0 1
26498: PPUSH
26499: LD_INT 21
26501: PUSH
26502: LD_INT 2
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: EMPTY
26510: LIST
26511: PPUSH
26512: CALL_OW 72
26516: PPUSH
26517: CALL 26929 0 1
// end ;
26521: LD_VAR 0 2
26525: RET
// export function add_to_humans ( un ) ; var i ; begin
26526: LD_INT 0
26528: PPUSH
26529: PPUSH
// sol := sol union UnitFilter ( un , [ mf_sol ] ) ;
26530: LD_ADDR_EXP 82
26534: PUSH
26535: LD_EXP 82
26539: PUSH
26540: LD_VAR 0 1
26544: PPUSH
26545: LD_EXP 51
26549: PUSH
26550: EMPTY
26551: LIST
26552: PPUSH
26553: CALL_OW 72
26557: UNION
26558: ST_TO_ADDR
// eng := eng union UnitFilter ( un , [ mf_eng ] ) ;
26559: LD_ADDR_EXP 84
26563: PUSH
26564: LD_EXP 84
26568: PUSH
26569: LD_VAR 0 1
26573: PPUSH
26574: LD_EXP 52
26578: PUSH
26579: EMPTY
26580: LIST
26581: PPUSH
26582: CALL_OW 72
26586: UNION
26587: ST_TO_ADDR
// mec := mec union UnitFilter ( un , [ mf_mec ] ) ;
26588: LD_ADDR_EXP 86
26592: PUSH
26593: LD_EXP 86
26597: PUSH
26598: LD_VAR 0 1
26602: PPUSH
26603: LD_EXP 53
26607: PUSH
26608: EMPTY
26609: LIST
26610: PPUSH
26611: CALL_OW 72
26615: UNION
26616: ST_TO_ADDR
// sci := sci union UnitFilter ( un , [ mf_sci ] ) ;
26617: LD_ADDR_EXP 88
26621: PUSH
26622: LD_EXP 88
26626: PUSH
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_EXP 54
26636: PUSH
26637: EMPTY
26638: LIST
26639: PPUSH
26640: CALL_OW 72
26644: UNION
26645: ST_TO_ADDR
// for i in un do
26646: LD_ADDR_VAR 0 3
26650: PUSH
26651: LD_VAR 0 1
26655: PUSH
26656: FOR_IN
26657: IFFALSE 26922
// begin case GetSide ( i ) of ai_s [ 1 ] :
26659: LD_VAR 0 3
26663: PPUSH
26664: CALL_OW 255
26668: PUSH
26669: LD_EXP 23
26673: PUSH
26674: LD_INT 1
26676: ARRAY
26677: DOUBLE
26678: EQUAL
26679: IFTRUE 26683
26681: GO 26719
26683: POP
// humans := replace ( humans , 1 , humans [ 1 ] union i ) ; ai_s [ 2 ] :
26684: LD_ADDR_EXP 76
26688: PUSH
26689: LD_EXP 76
26693: PPUSH
26694: LD_INT 1
26696: PPUSH
26697: LD_EXP 76
26701: PUSH
26702: LD_INT 1
26704: ARRAY
26705: PUSH
26706: LD_VAR 0 3
26710: UNION
26711: PPUSH
26712: CALL_OW 1
26716: ST_TO_ADDR
26717: GO 26920
26719: LD_EXP 23
26723: PUSH
26724: LD_INT 2
26726: ARRAY
26727: DOUBLE
26728: EQUAL
26729: IFTRUE 26733
26731: GO 26769
26733: POP
// humans := replace ( humans , 2 , humans [ 2 ] union i ) ; ai_s [ 3 ] :
26734: LD_ADDR_EXP 76
26738: PUSH
26739: LD_EXP 76
26743: PPUSH
26744: LD_INT 2
26746: PPUSH
26747: LD_EXP 76
26751: PUSH
26752: LD_INT 2
26754: ARRAY
26755: PUSH
26756: LD_VAR 0 3
26760: UNION
26761: PPUSH
26762: CALL_OW 1
26766: ST_TO_ADDR
26767: GO 26920
26769: LD_EXP 23
26773: PUSH
26774: LD_INT 3
26776: ARRAY
26777: DOUBLE
26778: EQUAL
26779: IFTRUE 26783
26781: GO 26819
26783: POP
// humans := replace ( humans , 3 , humans [ 3 ] union i ) ; ai_s [ 4 ] :
26784: LD_ADDR_EXP 76
26788: PUSH
26789: LD_EXP 76
26793: PPUSH
26794: LD_INT 3
26796: PPUSH
26797: LD_EXP 76
26801: PUSH
26802: LD_INT 3
26804: ARRAY
26805: PUSH
26806: LD_VAR 0 3
26810: UNION
26811: PPUSH
26812: CALL_OW 1
26816: ST_TO_ADDR
26817: GO 26920
26819: LD_EXP 23
26823: PUSH
26824: LD_INT 4
26826: ARRAY
26827: DOUBLE
26828: EQUAL
26829: IFTRUE 26833
26831: GO 26869
26833: POP
// humans := replace ( humans , 4 , humans [ 4 ] union i ) ; ai_s [ 5 ] :
26834: LD_ADDR_EXP 76
26838: PUSH
26839: LD_EXP 76
26843: PPUSH
26844: LD_INT 4
26846: PPUSH
26847: LD_EXP 76
26851: PUSH
26852: LD_INT 4
26854: ARRAY
26855: PUSH
26856: LD_VAR 0 3
26860: UNION
26861: PPUSH
26862: CALL_OW 1
26866: ST_TO_ADDR
26867: GO 26920
26869: LD_EXP 23
26873: PUSH
26874: LD_INT 5
26876: ARRAY
26877: DOUBLE
26878: EQUAL
26879: IFTRUE 26883
26881: GO 26919
26883: POP
// humans := replace ( humans , 5 , humans [ 5 ] union i ) ; end ;
26884: LD_ADDR_EXP 76
26888: PUSH
26889: LD_EXP 76
26893: PPUSH
26894: LD_INT 5
26896: PPUSH
26897: LD_EXP 76
26901: PUSH
26902: LD_INT 5
26904: ARRAY
26905: PUSH
26906: LD_VAR 0 3
26910: UNION
26911: PPUSH
26912: CALL_OW 1
26916: ST_TO_ADDR
26917: GO 26920
26919: POP
// end ;
26920: GO 26656
26922: POP
26923: POP
// end ;
26924: LD_VAR 0 2
26928: RET
// export function add_to_vehicles ( un ) ; var i ; begin
26929: LD_INT 0
26931: PPUSH
26932: PPUSH
// attack_units := attack_units union UnitFilter ( un , [ mf_comp ] ) ;
26933: LD_ADDR_EXP 78
26937: PUSH
26938: LD_EXP 78
26942: PUSH
26943: LD_VAR 0 1
26947: PPUSH
26948: LD_EXP 60
26952: PUSH
26953: EMPTY
26954: LIST
26955: PPUSH
26956: CALL_OW 72
26960: UNION
26961: ST_TO_ADDR
// defence_units := defence_units union UnitFilter ( un , [ mf_manu ] ) ;
26962: LD_ADDR_EXP 79
26966: PUSH
26967: LD_EXP 79
26971: PUSH
26972: LD_VAR 0 1
26976: PPUSH
26977: LD_EXP 61
26981: PUSH
26982: EMPTY
26983: LIST
26984: PPUSH
26985: CALL_OW 72
26989: UNION
26990: ST_TO_ADDR
// for i in un do
26991: LD_ADDR_VAR 0 3
26995: PUSH
26996: LD_VAR 0 1
27000: PUSH
27001: FOR_IN
27002: IFFALSE 27267
// begin case getside ( i ) of ai_s [ 1 ] :
27004: LD_VAR 0 3
27008: PPUSH
27009: CALL_OW 255
27013: PUSH
27014: LD_EXP 23
27018: PUSH
27019: LD_INT 1
27021: ARRAY
27022: DOUBLE
27023: EQUAL
27024: IFTRUE 27028
27026: GO 27064
27028: POP
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] union i ) ; ai_s [ 2 ] :
27029: LD_ADDR_EXP 77
27033: PUSH
27034: LD_EXP 77
27038: PPUSH
27039: LD_INT 1
27041: PPUSH
27042: LD_EXP 77
27046: PUSH
27047: LD_INT 1
27049: ARRAY
27050: PUSH
27051: LD_VAR 0 3
27055: UNION
27056: PPUSH
27057: CALL_OW 1
27061: ST_TO_ADDR
27062: GO 27265
27064: LD_EXP 23
27068: PUSH
27069: LD_INT 2
27071: ARRAY
27072: DOUBLE
27073: EQUAL
27074: IFTRUE 27078
27076: GO 27114
27078: POP
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] union i ) ; ai_s [ 3 ] :
27079: LD_ADDR_EXP 77
27083: PUSH
27084: LD_EXP 77
27088: PPUSH
27089: LD_INT 2
27091: PPUSH
27092: LD_EXP 77
27096: PUSH
27097: LD_INT 2
27099: ARRAY
27100: PUSH
27101: LD_VAR 0 3
27105: UNION
27106: PPUSH
27107: CALL_OW 1
27111: ST_TO_ADDR
27112: GO 27265
27114: LD_EXP 23
27118: PUSH
27119: LD_INT 3
27121: ARRAY
27122: DOUBLE
27123: EQUAL
27124: IFTRUE 27128
27126: GO 27164
27128: POP
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] union i ) ; ai_s [ 4 ] :
27129: LD_ADDR_EXP 77
27133: PUSH
27134: LD_EXP 77
27138: PPUSH
27139: LD_INT 3
27141: PPUSH
27142: LD_EXP 77
27146: PUSH
27147: LD_INT 3
27149: ARRAY
27150: PUSH
27151: LD_VAR 0 3
27155: UNION
27156: PPUSH
27157: CALL_OW 1
27161: ST_TO_ADDR
27162: GO 27265
27164: LD_EXP 23
27168: PUSH
27169: LD_INT 4
27171: ARRAY
27172: DOUBLE
27173: EQUAL
27174: IFTRUE 27178
27176: GO 27214
27178: POP
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] union i ) ; ai_s [ 5 ] :
27179: LD_ADDR_EXP 77
27183: PUSH
27184: LD_EXP 77
27188: PPUSH
27189: LD_INT 4
27191: PPUSH
27192: LD_EXP 77
27196: PUSH
27197: LD_INT 4
27199: ARRAY
27200: PUSH
27201: LD_VAR 0 3
27205: UNION
27206: PPUSH
27207: CALL_OW 1
27211: ST_TO_ADDR
27212: GO 27265
27214: LD_EXP 23
27218: PUSH
27219: LD_INT 5
27221: ARRAY
27222: DOUBLE
27223: EQUAL
27224: IFTRUE 27228
27226: GO 27264
27228: POP
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] union i ) ; end ;
27229: LD_ADDR_EXP 77
27233: PUSH
27234: LD_EXP 77
27238: PPUSH
27239: LD_INT 5
27241: PPUSH
27242: LD_EXP 77
27246: PUSH
27247: LD_INT 5
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 3
27255: UNION
27256: PPUSH
27257: CALL_OW 1
27261: ST_TO_ADDR
27262: GO 27265
27264: POP
// end ;
27265: GO 27001
27267: POP
27268: POP
// end ;
27269: LD_VAR 0 2
27273: RET
// export function add_to_builds ( un ) ; var i , j , bt ; begin
27274: LD_INT 0
27276: PPUSH
27277: PPUSH
27278: PPUSH
27279: PPUSH
// fort := fort union UnitFilter ( un , [ mf_fort ] ) ;
27280: LD_ADDR_EXP 81
27284: PUSH
27285: LD_EXP 81
27289: PUSH
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_EXP 56
27299: PUSH
27300: EMPTY
27301: LIST
27302: PPUSH
27303: CALL_OW 72
27307: UNION
27308: ST_TO_ADDR
// dep := dep union UnitFilter ( un , [ mf_dep ] ) ;
27309: LD_ADDR_EXP 83
27313: PUSH
27314: LD_EXP 83
27318: PUSH
27319: LD_VAR 0 1
27323: PPUSH
27324: LD_EXP 58
27328: PUSH
27329: EMPTY
27330: LIST
27331: PPUSH
27332: CALL_OW 72
27336: UNION
27337: ST_TO_ADDR
// fact := fact union UnitFilter ( un , [ mf_fact ] ) ;
27338: LD_ADDR_EXP 85
27342: PUSH
27343: LD_EXP 85
27347: PUSH
27348: LD_VAR 0 1
27352: PPUSH
27353: LD_EXP 59
27357: PUSH
27358: EMPTY
27359: LIST
27360: PPUSH
27361: CALL_OW 72
27365: UNION
27366: ST_TO_ADDR
// lab := lab union UnitFilter ( un , [ mf_lab ] ) ;
27367: LD_ADDR_EXP 87
27371: PUSH
27372: LD_EXP 87
27376: PUSH
27377: LD_VAR 0 1
27381: PPUSH
27382: LD_EXP 55
27386: PUSH
27387: EMPTY
27388: LIST
27389: PPUSH
27390: CALL_OW 72
27394: UNION
27395: ST_TO_ADDR
// for i in un do
27396: LD_ADDR_VAR 0 3
27400: PUSH
27401: LD_VAR 0 1
27405: PUSH
27406: FOR_IN
27407: IFFALSE 27672
// begin case GetSide ( i ) of ai_s [ 1 ] :
27409: LD_VAR 0 3
27413: PPUSH
27414: CALL_OW 255
27418: PUSH
27419: LD_EXP 23
27423: PUSH
27424: LD_INT 1
27426: ARRAY
27427: DOUBLE
27428: EQUAL
27429: IFTRUE 27433
27431: GO 27469
27433: POP
// buildings := replace ( buildings , 1 , buildings [ 1 ] union i ) ; ai_s [ 2 ] :
27434: LD_ADDR_EXP 75
27438: PUSH
27439: LD_EXP 75
27443: PPUSH
27444: LD_INT 1
27446: PPUSH
27447: LD_EXP 75
27451: PUSH
27452: LD_INT 1
27454: ARRAY
27455: PUSH
27456: LD_VAR 0 3
27460: UNION
27461: PPUSH
27462: CALL_OW 1
27466: ST_TO_ADDR
27467: GO 27670
27469: LD_EXP 23
27473: PUSH
27474: LD_INT 2
27476: ARRAY
27477: DOUBLE
27478: EQUAL
27479: IFTRUE 27483
27481: GO 27519
27483: POP
// buildings := replace ( buildings , 2 , buildings [ 2 ] union i ) ; ai_s [ 3 ] :
27484: LD_ADDR_EXP 75
27488: PUSH
27489: LD_EXP 75
27493: PPUSH
27494: LD_INT 2
27496: PPUSH
27497: LD_EXP 75
27501: PUSH
27502: LD_INT 2
27504: ARRAY
27505: PUSH
27506: LD_VAR 0 3
27510: UNION
27511: PPUSH
27512: CALL_OW 1
27516: ST_TO_ADDR
27517: GO 27670
27519: LD_EXP 23
27523: PUSH
27524: LD_INT 3
27526: ARRAY
27527: DOUBLE
27528: EQUAL
27529: IFTRUE 27533
27531: GO 27569
27533: POP
// buildings := replace ( buildings , 3 , buildings [ 3 ] union i ) ; ai_s [ 4 ] :
27534: LD_ADDR_EXP 75
27538: PUSH
27539: LD_EXP 75
27543: PPUSH
27544: LD_INT 3
27546: PPUSH
27547: LD_EXP 75
27551: PUSH
27552: LD_INT 3
27554: ARRAY
27555: PUSH
27556: LD_VAR 0 3
27560: UNION
27561: PPUSH
27562: CALL_OW 1
27566: ST_TO_ADDR
27567: GO 27670
27569: LD_EXP 23
27573: PUSH
27574: LD_INT 4
27576: ARRAY
27577: DOUBLE
27578: EQUAL
27579: IFTRUE 27583
27581: GO 27619
27583: POP
// buildings := replace ( buildings , 4 , buildings [ 4 ] union i ) ; ai_s [ 5 ] :
27584: LD_ADDR_EXP 75
27588: PUSH
27589: LD_EXP 75
27593: PPUSH
27594: LD_INT 4
27596: PPUSH
27597: LD_EXP 75
27601: PUSH
27602: LD_INT 4
27604: ARRAY
27605: PUSH
27606: LD_VAR 0 3
27610: UNION
27611: PPUSH
27612: CALL_OW 1
27616: ST_TO_ADDR
27617: GO 27670
27619: LD_EXP 23
27623: PUSH
27624: LD_INT 5
27626: ARRAY
27627: DOUBLE
27628: EQUAL
27629: IFTRUE 27633
27631: GO 27669
27633: POP
// buildings := replace ( buildings , 5 , buildings [ 5 ] union i ) ; end ;
27634: LD_ADDR_EXP 75
27638: PUSH
27639: LD_EXP 75
27643: PPUSH
27644: LD_INT 5
27646: PPUSH
27647: LD_EXP 75
27651: PUSH
27652: LD_INT 5
27654: ARRAY
27655: PUSH
27656: LD_VAR 0 3
27660: UNION
27661: PPUSH
27662: CALL_OW 1
27666: ST_TO_ADDR
27667: GO 27670
27669: POP
// end ;
27670: GO 27406
27672: POP
27673: POP
// write_deps ;
27674: CALL 23394 0 0
// write_facts ;
27678: CALL 23513 0 0
// end ;
27682: LD_VAR 0 2
27686: RET
// export function remove_from ( un ) ; begin
27687: LD_INT 0
27689: PPUSH
// remove_from_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
27690: LD_VAR 0 1
27694: PPUSH
27695: LD_INT 21
27697: PUSH
27698: LD_INT 1
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: EMPTY
27706: LIST
27707: PPUSH
27708: CALL_OW 72
27712: PPUSH
27713: CALL 28022 0 1
// remove_from_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
27717: LD_VAR 0 1
27721: PPUSH
27722: LD_INT 21
27724: PUSH
27725: LD_INT 3
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: EMPTY
27733: LIST
27734: PPUSH
27735: CALL_OW 72
27739: PPUSH
27740: CALL 27776 0 1
// remove_from_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
27744: LD_VAR 0 1
27748: PPUSH
27749: LD_INT 21
27751: PUSH
27752: LD_INT 2
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: EMPTY
27760: LIST
27761: PPUSH
27762: CALL_OW 72
27766: PPUSH
27767: CALL 28260 0 1
// end ;
27771: LD_VAR 0 2
27775: RET
// export function remove_from_builds ( un ) ; var i ; begin
27776: LD_INT 0
27778: PPUSH
27779: PPUSH
// fact := fact diff un ;
27780: LD_ADDR_EXP 85
27784: PUSH
27785: LD_EXP 85
27789: PUSH
27790: LD_VAR 0 1
27794: DIFF
27795: ST_TO_ADDR
// fort := fort diff un ;
27796: LD_ADDR_EXP 81
27800: PUSH
27801: LD_EXP 81
27805: PUSH
27806: LD_VAR 0 1
27810: DIFF
27811: ST_TO_ADDR
// lab := lab diff un ;
27812: LD_ADDR_EXP 87
27816: PUSH
27817: LD_EXP 87
27821: PUSH
27822: LD_VAR 0 1
27826: DIFF
27827: ST_TO_ADDR
// dep := dep diff un ;
27828: LD_ADDR_EXP 83
27832: PUSH
27833: LD_EXP 83
27837: PUSH
27838: LD_VAR 0 1
27842: DIFF
27843: ST_TO_ADDR
// buildings := replace ( buildings , 1 , buildings [ 1 ] diff un ) ;
27844: LD_ADDR_EXP 75
27848: PUSH
27849: LD_EXP 75
27853: PPUSH
27854: LD_INT 1
27856: PPUSH
27857: LD_EXP 75
27861: PUSH
27862: LD_INT 1
27864: ARRAY
27865: PUSH
27866: LD_VAR 0 1
27870: DIFF
27871: PPUSH
27872: CALL_OW 1
27876: ST_TO_ADDR
// buildings := replace ( buildings , 2 , buildings [ 2 ] diff un ) ;
27877: LD_ADDR_EXP 75
27881: PUSH
27882: LD_EXP 75
27886: PPUSH
27887: LD_INT 2
27889: PPUSH
27890: LD_EXP 75
27894: PUSH
27895: LD_INT 2
27897: ARRAY
27898: PUSH
27899: LD_VAR 0 1
27903: DIFF
27904: PPUSH
27905: CALL_OW 1
27909: ST_TO_ADDR
// buildings := replace ( buildings , 3 , buildings [ 3 ] diff un ) ;
27910: LD_ADDR_EXP 75
27914: PUSH
27915: LD_EXP 75
27919: PPUSH
27920: LD_INT 3
27922: PPUSH
27923: LD_EXP 75
27927: PUSH
27928: LD_INT 3
27930: ARRAY
27931: PUSH
27932: LD_VAR 0 1
27936: DIFF
27937: PPUSH
27938: CALL_OW 1
27942: ST_TO_ADDR
// buildings := replace ( buildings , 4 , buildings [ 4 ] diff un ) ;
27943: LD_ADDR_EXP 75
27947: PUSH
27948: LD_EXP 75
27952: PPUSH
27953: LD_INT 4
27955: PPUSH
27956: LD_EXP 75
27960: PUSH
27961: LD_INT 4
27963: ARRAY
27964: PUSH
27965: LD_VAR 0 1
27969: DIFF
27970: PPUSH
27971: CALL_OW 1
27975: ST_TO_ADDR
// buildings := replace ( buildings , 5 , buildings [ 5 ] diff un ) ;
27976: LD_ADDR_EXP 75
27980: PUSH
27981: LD_EXP 75
27985: PPUSH
27986: LD_INT 5
27988: PPUSH
27989: LD_EXP 75
27993: PUSH
27994: LD_INT 5
27996: ARRAY
27997: PUSH
27998: LD_VAR 0 1
28002: DIFF
28003: PPUSH
28004: CALL_OW 1
28008: ST_TO_ADDR
// write_deps ;
28009: CALL 23394 0 0
// write_facts ;
28013: CALL 23513 0 0
// end ;
28017: LD_VAR 0 2
28021: RET
// export function remove_from_humans ( un ) ; var i ; begin
28022: LD_INT 0
28024: PPUSH
28025: PPUSH
// sol := sol diff un ;
28026: LD_ADDR_EXP 82
28030: PUSH
28031: LD_EXP 82
28035: PUSH
28036: LD_VAR 0 1
28040: DIFF
28041: ST_TO_ADDR
// eng := eng diff un ;
28042: LD_ADDR_EXP 84
28046: PUSH
28047: LD_EXP 84
28051: PUSH
28052: LD_VAR 0 1
28056: DIFF
28057: ST_TO_ADDR
// mec := mec diff un ;
28058: LD_ADDR_EXP 86
28062: PUSH
28063: LD_EXP 86
28067: PUSH
28068: LD_VAR 0 1
28072: DIFF
28073: ST_TO_ADDR
// sci := sci diff un ;
28074: LD_ADDR_EXP 88
28078: PUSH
28079: LD_EXP 88
28083: PUSH
28084: LD_VAR 0 1
28088: DIFF
28089: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff un ) ;
28090: LD_ADDR_EXP 76
28094: PUSH
28095: LD_EXP 76
28099: PPUSH
28100: LD_INT 1
28102: PPUSH
28103: LD_EXP 76
28107: PUSH
28108: LD_INT 1
28110: ARRAY
28111: PUSH
28112: LD_VAR 0 1
28116: DIFF
28117: PPUSH
28118: CALL_OW 1
28122: ST_TO_ADDR
// humans := replace ( humans , 2 , humans [ 2 ] diff un ) ;
28123: LD_ADDR_EXP 76
28127: PUSH
28128: LD_EXP 76
28132: PPUSH
28133: LD_INT 2
28135: PPUSH
28136: LD_EXP 76
28140: PUSH
28141: LD_INT 2
28143: ARRAY
28144: PUSH
28145: LD_VAR 0 1
28149: DIFF
28150: PPUSH
28151: CALL_OW 1
28155: ST_TO_ADDR
// humans := replace ( humans , 3 , humans [ 3 ] diff un ) ;
28156: LD_ADDR_EXP 76
28160: PUSH
28161: LD_EXP 76
28165: PPUSH
28166: LD_INT 3
28168: PPUSH
28169: LD_EXP 76
28173: PUSH
28174: LD_INT 3
28176: ARRAY
28177: PUSH
28178: LD_VAR 0 1
28182: DIFF
28183: PPUSH
28184: CALL_OW 1
28188: ST_TO_ADDR
// humans := replace ( humans , 4 , humans [ 4 ] diff un ) ;
28189: LD_ADDR_EXP 76
28193: PUSH
28194: LD_EXP 76
28198: PPUSH
28199: LD_INT 4
28201: PPUSH
28202: LD_EXP 76
28206: PUSH
28207: LD_INT 4
28209: ARRAY
28210: PUSH
28211: LD_VAR 0 1
28215: DIFF
28216: PPUSH
28217: CALL_OW 1
28221: ST_TO_ADDR
// humans := replace ( humans , 5 , humans [ 5 ] diff un ) ;
28222: LD_ADDR_EXP 76
28226: PUSH
28227: LD_EXP 76
28231: PPUSH
28232: LD_INT 5
28234: PPUSH
28235: LD_EXP 76
28239: PUSH
28240: LD_INT 5
28242: ARRAY
28243: PUSH
28244: LD_VAR 0 1
28248: DIFF
28249: PPUSH
28250: CALL_OW 1
28254: ST_TO_ADDR
// end ;
28255: LD_VAR 0 2
28259: RET
// export function remove_from_vehicles ( un ) ; var i ; begin
28260: LD_INT 0
28262: PPUSH
28263: PPUSH
// attack_units := attack_units diff un ;
28264: LD_ADDR_EXP 78
28268: PUSH
28269: LD_EXP 78
28273: PUSH
28274: LD_VAR 0 1
28278: DIFF
28279: ST_TO_ADDR
// defence_units := defence_units diff un ;
28280: LD_ADDR_EXP 79
28284: PUSH
28285: LD_EXP 79
28289: PUSH
28290: LD_VAR 0 1
28294: DIFF
28295: ST_TO_ADDR
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] diff un ) ;
28296: LD_ADDR_EXP 77
28300: PUSH
28301: LD_EXP 77
28305: PPUSH
28306: LD_INT 1
28308: PPUSH
28309: LD_EXP 77
28313: PUSH
28314: LD_INT 1
28316: ARRAY
28317: PUSH
28318: LD_VAR 0 1
28322: DIFF
28323: PPUSH
28324: CALL_OW 1
28328: ST_TO_ADDR
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] diff un ) ;
28329: LD_ADDR_EXP 77
28333: PUSH
28334: LD_EXP 77
28338: PPUSH
28339: LD_INT 2
28341: PPUSH
28342: LD_EXP 77
28346: PUSH
28347: LD_INT 2
28349: ARRAY
28350: PUSH
28351: LD_VAR 0 1
28355: DIFF
28356: PPUSH
28357: CALL_OW 1
28361: ST_TO_ADDR
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] diff un ) ;
28362: LD_ADDR_EXP 77
28366: PUSH
28367: LD_EXP 77
28371: PPUSH
28372: LD_INT 3
28374: PPUSH
28375: LD_EXP 77
28379: PUSH
28380: LD_INT 3
28382: ARRAY
28383: PUSH
28384: LD_VAR 0 1
28388: DIFF
28389: PPUSH
28390: CALL_OW 1
28394: ST_TO_ADDR
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] diff un ) ;
28395: LD_ADDR_EXP 77
28399: PUSH
28400: LD_EXP 77
28404: PPUSH
28405: LD_INT 4
28407: PPUSH
28408: LD_EXP 77
28412: PUSH
28413: LD_INT 4
28415: ARRAY
28416: PUSH
28417: LD_VAR 0 1
28421: DIFF
28422: PPUSH
28423: CALL_OW 1
28427: ST_TO_ADDR
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] diff un ) ;
28428: LD_ADDR_EXP 77
28432: PUSH
28433: LD_EXP 77
28437: PPUSH
28438: LD_INT 5
28440: PPUSH
28441: LD_EXP 77
28445: PUSH
28446: LD_INT 5
28448: ARRAY
28449: PUSH
28450: LD_VAR 0 1
28454: DIFF
28455: PPUSH
28456: CALL_OW 1
28460: ST_TO_ADDR
// bc := replace ( bc , 1 , bc [ 1 ] diff un ) ;
28461: LD_ADDR_EXP 71
28465: PUSH
28466: LD_EXP 71
28470: PPUSH
28471: LD_INT 1
28473: PPUSH
28474: LD_EXP 71
28478: PUSH
28479: LD_INT 1
28481: ARRAY
28482: PUSH
28483: LD_VAR 0 1
28487: DIFF
28488: PPUSH
28489: CALL_OW 1
28493: ST_TO_ADDR
// bc := replace ( bc , 2 , bc [ 2 ] diff un ) ;
28494: LD_ADDR_EXP 71
28498: PUSH
28499: LD_EXP 71
28503: PPUSH
28504: LD_INT 2
28506: PPUSH
28507: LD_EXP 71
28511: PUSH
28512: LD_INT 2
28514: ARRAY
28515: PUSH
28516: LD_VAR 0 1
28520: DIFF
28521: PPUSH
28522: CALL_OW 1
28526: ST_TO_ADDR
// bc := replace ( bc , 3 , bc [ 3 ] diff un ) ;
28527: LD_ADDR_EXP 71
28531: PUSH
28532: LD_EXP 71
28536: PPUSH
28537: LD_INT 3
28539: PPUSH
28540: LD_EXP 71
28544: PUSH
28545: LD_INT 3
28547: ARRAY
28548: PUSH
28549: LD_VAR 0 1
28553: DIFF
28554: PPUSH
28555: CALL_OW 1
28559: ST_TO_ADDR
// bc := replace ( bc , 4 , bc [ 4 ] diff un ) ;
28560: LD_ADDR_EXP 71
28564: PUSH
28565: LD_EXP 71
28569: PPUSH
28570: LD_INT 4
28572: PPUSH
28573: LD_EXP 71
28577: PUSH
28578: LD_INT 4
28580: ARRAY
28581: PUSH
28582: LD_VAR 0 1
28586: DIFF
28587: PPUSH
28588: CALL_OW 1
28592: ST_TO_ADDR
// bc := replace ( bc , 5 , bc [ 5 ] diff un ) ;
28593: LD_ADDR_EXP 71
28597: PUSH
28598: LD_EXP 71
28602: PPUSH
28603: LD_INT 5
28605: PPUSH
28606: LD_EXP 71
28610: PUSH
28611: LD_INT 5
28613: ARRAY
28614: PUSH
28615: LD_VAR 0 1
28619: DIFF
28620: PPUSH
28621: CALL_OW 1
28625: ST_TO_ADDR
// rc := replace ( rc , 1 , rc [ 1 ] diff un ) ;
28626: LD_ADDR_EXP 70
28630: PUSH
28631: LD_EXP 70
28635: PPUSH
28636: LD_INT 1
28638: PPUSH
28639: LD_EXP 70
28643: PUSH
28644: LD_INT 1
28646: ARRAY
28647: PUSH
28648: LD_VAR 0 1
28652: DIFF
28653: PPUSH
28654: CALL_OW 1
28658: ST_TO_ADDR
// rc := replace ( rc , 2 , rc [ 2 ] diff un ) ;
28659: LD_ADDR_EXP 70
28663: PUSH
28664: LD_EXP 70
28668: PPUSH
28669: LD_INT 2
28671: PPUSH
28672: LD_EXP 70
28676: PUSH
28677: LD_INT 2
28679: ARRAY
28680: PUSH
28681: LD_VAR 0 1
28685: DIFF
28686: PPUSH
28687: CALL_OW 1
28691: ST_TO_ADDR
// rc := replace ( rc , 3 , rc [ 3 ] diff un ) ;
28692: LD_ADDR_EXP 70
28696: PUSH
28697: LD_EXP 70
28701: PPUSH
28702: LD_INT 3
28704: PPUSH
28705: LD_EXP 70
28709: PUSH
28710: LD_INT 3
28712: ARRAY
28713: PUSH
28714: LD_VAR 0 1
28718: DIFF
28719: PPUSH
28720: CALL_OW 1
28724: ST_TO_ADDR
// rc := replace ( rc , 4 , rc [ 4 ] diff un ) ;
28725: LD_ADDR_EXP 70
28729: PUSH
28730: LD_EXP 70
28734: PPUSH
28735: LD_INT 4
28737: PPUSH
28738: LD_EXP 70
28742: PUSH
28743: LD_INT 4
28745: ARRAY
28746: PUSH
28747: LD_VAR 0 1
28751: DIFF
28752: PPUSH
28753: CALL_OW 1
28757: ST_TO_ADDR
// rc := replace ( rc , 5 , rc [ 5 ] diff un ) ;
28758: LD_ADDR_EXP 70
28762: PUSH
28763: LD_EXP 70
28767: PPUSH
28768: LD_INT 5
28770: PPUSH
28771: LD_EXP 70
28775: PUSH
28776: LD_INT 5
28778: ARRAY
28779: PUSH
28780: LD_VAR 0 1
28784: DIFF
28785: PPUSH
28786: CALL_OW 1
28790: ST_TO_ADDR
// end ; end_of_file
28791: LD_VAR 0 2
28795: RET
// var objevovani_zasilek ; every 1 do
28796: GO 28798
28798: DISABLE
// begin objevovani_zasilek := [ 2 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 ] ;
28799: LD_ADDR_LOC 30
28803: PUSH
28804: LD_INT 2
28806: PUSH
28807: LD_INT 3
28809: PUSH
28810: LD_INT 1
28812: PUSH
28813: LD_INT 5
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: LD_INT 1
28821: PUSH
28822: LD_INT 4
28824: PUSH
28825: LD_INT 1
28827: PUSH
28828: LD_INT 0
28830: PUSH
28831: LD_INT 3
28833: PUSH
28834: LD_INT 3
28836: PUSH
28837: LD_INT 1
28839: PUSH
28840: LD_INT 5
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: LD_INT 1
28848: PUSH
28849: LD_INT 4
28851: PUSH
28852: LD_INT 1
28854: PUSH
28855: LD_INT 0
28857: PUSH
28858: LD_INT 3
28860: PUSH
28861: LD_INT 3
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: LD_INT 5
28869: PUSH
28870: LD_INT 1
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: LD_INT 4
28878: PUSH
28879: LD_INT 1
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: LD_INT 3
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: LIST
28907: LIST
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: ST_TO_ADDR
// Randomize ;
28918: CALL_OW 10
// end ;
28922: END
// every 5 5$0 do
28923: GO 28925
28925: DISABLE
// begin Randomize ;
28926: CALL_OW 10
// enable ;
28930: ENABLE
// end ;
28931: END
// every 0 0$15 do
28932: GO 28934
28934: DISABLE
// begin padaji_bedny ;
28935: CALL 28949 0 0
// end ;
28939: END
// every 5 5$0 + 0 0$15 do
28940: GO 28942
28942: DISABLE
// begin padaji_bedny ;
28943: CALL 28949 0 0
// enable ;
28947: ENABLE
// end ;
28948: END
// function padaji_bedny ; var x , i , cek , cek2 , last , min5 ; begin
28949: LD_INT 0
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
28956: PPUSH
28957: PPUSH
// min5 := ( ( tick div 5 5$0 ) + 1 ) mod objevovani_zasilek ;
28958: LD_ADDR_VAR 0 7
28962: PUSH
28963: LD_OWVAR 1
28967: PUSH
28968: LD_INT 10500
28970: DIV
28971: PUSH
28972: LD_INT 1
28974: PLUS
28975: PUSH
28976: LD_LOC 30
28980: MOD
28981: ST_TO_ADDR
// cek := [ ] ;
28982: LD_ADDR_VAR 0 4
28986: PUSH
28987: EMPTY
28988: ST_TO_ADDR
// cek2 := [ ] ;
28989: LD_ADDR_VAR 0 5
28993: PUSH
28994: EMPTY
28995: ST_TO_ADDR
// last := 0 ;
28996: LD_ADDR_VAR 0 6
29000: PUSH
29001: LD_INT 0
29003: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
29004: LD_ADDR_VAR 0 2
29008: PUSH
29009: LD_LOC 30
29013: PUSH
29014: LD_VAR 0 7
29018: ARRAY
29019: ST_TO_ADDR
// for i := 1 to x do
29020: LD_ADDR_VAR 0 3
29024: PUSH
29025: DOUBLE
29026: LD_INT 1
29028: DEC
29029: ST_TO_ADDR
29030: LD_VAR 0 2
29034: PUSH
29035: FOR_TO
29036: IFFALSE 29062
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
29038: LD_ADDR_VAR 0 4
29042: PUSH
29043: LD_VAR 0 4
29047: PUSH
29048: LD_INT 525
29050: PPUSH
29051: LD_INT 10500
29053: PPUSH
29054: CALL_OW 12
29058: ADD
29059: ST_TO_ADDR
29060: GO 29035
29062: POP
29063: POP
// cek := SortListByListAsc ( cek , cek ) ;
29064: LD_ADDR_VAR 0 4
29068: PUSH
29069: LD_VAR 0 4
29073: PPUSH
29074: LD_VAR 0 4
29078: PPUSH
29079: CALL_OW 76
29083: ST_TO_ADDR
// for i in cek do
29084: LD_ADDR_VAR 0 3
29088: PUSH
29089: LD_VAR 0 4
29093: PUSH
29094: FOR_IN
29095: IFFALSE 29131
// begin cek2 := cek2 ^ i - last ;
29097: LD_ADDR_VAR 0 5
29101: PUSH
29102: LD_VAR 0 5
29106: PUSH
29107: LD_VAR 0 3
29111: PUSH
29112: LD_VAR 0 6
29116: MINUS
29117: ADD
29118: ST_TO_ADDR
// last := i ;
29119: LD_ADDR_VAR 0 6
29123: PUSH
29124: LD_VAR 0 3
29128: ST_TO_ADDR
// end ;
29129: GO 29094
29131: POP
29132: POP
// for i := 1 to x do
29133: LD_ADDR_VAR 0 3
29137: PUSH
29138: DOUBLE
29139: LD_INT 1
29141: DEC
29142: ST_TO_ADDR
29143: LD_VAR 0 2
29147: PUSH
29148: FOR_TO
29149: IFFALSE 29178
// begin CreateCratesAnywhere ( 5 , true ) ;
29151: LD_INT 5
29153: PPUSH
29154: LD_INT 1
29156: PPUSH
29157: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
29161: LD_VAR 0 5
29165: PUSH
29166: LD_VAR 0 3
29170: ARRAY
29171: PPUSH
29172: CALL_OW 67
// end ;
29176: GO 29148
29178: POP
29179: POP
// end ; end_of_file
29180: LD_VAR 0 1
29184: RET
// var rDef1 , rDef2 , rDef3 , rDef4 , rDef5 ; var idDef1 , idDef2 , idDef3 , idDef4 , idDef5 ; export toDef1 , toDef2 , toDef3 , toDef4 , toDef5 ; every 0 0$1 do
29185: GO 29187
29187: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29188: LD_ADDR_EXP 89
29192: PUSH
29193: LD_EXP 76
29197: PUSH
29198: LD_INT 1
29200: ARRAY
29201: PPUSH
29202: LD_EXP 51
29206: PUSH
29207: EMPTY
29208: LIST
29209: PPUSH
29210: CALL_OW 72
29214: PUSH
29215: LD_EXP 77
29219: PUSH
29220: LD_INT 1
29222: ARRAY
29223: ADD
29224: PUSH
29225: LD_EXP 75
29229: PUSH
29230: LD_INT 1
29232: ARRAY
29233: PPUSH
29234: LD_EXP 56
29238: PUSH
29239: EMPTY
29240: LIST
29241: PPUSH
29242: CALL_OW 72
29246: ADD
29247: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29248: LD_ADDR_EXP 90
29252: PUSH
29253: LD_EXP 76
29257: PUSH
29258: LD_INT 2
29260: ARRAY
29261: PPUSH
29262: LD_EXP 51
29266: PUSH
29267: EMPTY
29268: LIST
29269: PPUSH
29270: CALL_OW 72
29274: PUSH
29275: LD_EXP 77
29279: PUSH
29280: LD_INT 2
29282: ARRAY
29283: ADD
29284: PUSH
29285: LD_EXP 75
29289: PUSH
29290: LD_INT 2
29292: ARRAY
29293: PPUSH
29294: LD_EXP 56
29298: PUSH
29299: EMPTY
29300: LIST
29301: PPUSH
29302: CALL_OW 72
29306: ADD
29307: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29308: LD_ADDR_EXP 91
29312: PUSH
29313: LD_EXP 76
29317: PUSH
29318: LD_INT 3
29320: ARRAY
29321: PPUSH
29322: LD_EXP 51
29326: PUSH
29327: EMPTY
29328: LIST
29329: PPUSH
29330: CALL_OW 72
29334: PUSH
29335: LD_EXP 77
29339: PUSH
29340: LD_INT 3
29342: ARRAY
29343: ADD
29344: PUSH
29345: LD_EXP 75
29349: PUSH
29350: LD_INT 3
29352: ARRAY
29353: PPUSH
29354: LD_EXP 56
29358: PUSH
29359: EMPTY
29360: LIST
29361: PPUSH
29362: CALL_OW 72
29366: ADD
29367: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
29368: LD_ADDR_EXP 92
29372: PUSH
29373: LD_EXP 76
29377: PUSH
29378: LD_INT 4
29380: ARRAY
29381: PPUSH
29382: LD_EXP 51
29386: PUSH
29387: EMPTY
29388: LIST
29389: PPUSH
29390: CALL_OW 72
29394: PUSH
29395: LD_EXP 77
29399: PUSH
29400: LD_INT 4
29402: ARRAY
29403: ADD
29404: PUSH
29405: LD_EXP 75
29409: PUSH
29410: LD_INT 4
29412: ARRAY
29413: PPUSH
29414: LD_EXP 56
29418: PUSH
29419: EMPTY
29420: LIST
29421: PPUSH
29422: CALL_OW 72
29426: ADD
29427: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
29428: LD_ADDR_EXP 93
29432: PUSH
29433: LD_EXP 76
29437: PUSH
29438: LD_INT 5
29440: ARRAY
29441: PPUSH
29442: LD_EXP 51
29446: PUSH
29447: EMPTY
29448: LIST
29449: PPUSH
29450: CALL_OW 72
29454: PUSH
29455: LD_EXP 77
29459: PUSH
29460: LD_INT 5
29462: ARRAY
29463: ADD
29464: PUSH
29465: LD_EXP 75
29469: PUSH
29470: LD_INT 5
29472: ARRAY
29473: PPUSH
29474: LD_EXP 56
29478: PUSH
29479: EMPTY
29480: LIST
29481: PPUSH
29482: CALL_OW 72
29486: ADD
29487: ST_TO_ADDR
// rDef1 := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearA ] , [ mc_reg_area_to_protect , nearA ] ] ) ;
29488: LD_ADDR_LOC 31
29492: PUSH
29493: LD_EXP 23
29497: PUSH
29498: LD_INT 1
29500: ARRAY
29501: PPUSH
29502: LD_INT 1
29504: PUSH
29505: LD_INT 70
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: LD_INT 2
29514: PUSH
29515: LD_INT 24
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 3
29524: PUSH
29525: LD_INT 24
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: LIST
29536: PPUSH
29537: CALL_OW 399
29541: ST_TO_ADDR
// rDef2 := McRegistry ( ai_s [ 2 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearB ] , [ mc_reg_area_to_protect , nearB ] ] ) ;
29542: LD_ADDR_LOC 32
29546: PUSH
29547: LD_EXP 23
29551: PUSH
29552: LD_INT 2
29554: ARRAY
29555: PPUSH
29556: LD_INT 1
29558: PUSH
29559: LD_INT 70
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 25
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 3
29578: PUSH
29579: LD_INT 25
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: LIST
29590: PPUSH
29591: CALL_OW 399
29595: ST_TO_ADDR
// rDef3 := McRegistry ( ai_s [ 3 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearC ] , [ mc_reg_area_to_protect , nearC ] ] ) ;
29596: LD_ADDR_LOC 33
29600: PUSH
29601: LD_EXP 23
29605: PUSH
29606: LD_INT 3
29608: ARRAY
29609: PPUSH
29610: LD_INT 1
29612: PUSH
29613: LD_INT 70
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 2
29622: PUSH
29623: LD_INT 26
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 3
29632: PUSH
29633: LD_INT 26
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: LIST
29644: PPUSH
29645: CALL_OW 399
29649: ST_TO_ADDR
// rDef4 := McRegistry ( ai_s [ 4 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearD ] , [ mc_reg_area_to_protect , nearD ] ] ) ;
29650: LD_ADDR_LOC 34
29654: PUSH
29655: LD_EXP 23
29659: PUSH
29660: LD_INT 4
29662: ARRAY
29663: PPUSH
29664: LD_INT 1
29666: PUSH
29667: LD_INT 70
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 2
29676: PUSH
29677: LD_INT 27
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 3
29686: PUSH
29687: LD_INT 27
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: LIST
29698: PPUSH
29699: CALL_OW 399
29703: ST_TO_ADDR
// rDef5 := McRegistry ( ai_s [ 5 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearE ] , [ mc_reg_area_to_protect , nearE ] ] ) ;
29704: LD_ADDR_LOC 35
29708: PUSH
29709: LD_EXP 23
29713: PUSH
29714: LD_INT 5
29716: ARRAY
29717: PPUSH
29718: LD_INT 1
29720: PUSH
29721: LD_INT 70
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 2
29730: PUSH
29731: LD_INT 28
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 3
29740: PUSH
29741: LD_INT 28
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: LIST
29752: PPUSH
29753: CALL_OW 399
29757: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef1_difficulty ] ) ;
29758: LD_ADDR_LOC 36
29762: PUSH
29763: LD_INT 10
29765: PPUSH
29766: LD_LOC 31
29770: PPUSH
29771: LD_EXP 89
29775: PPUSH
29776: LD_INT 1
29778: PUSH
29779: LD_EXP 11
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PPUSH
29788: CALL_OW 401
29792: ST_TO_ADDR
// idDef2 := McDefend ( 10 , rDef2 , toDef2 , [ mc_def_advantage , mcdef2_difficulty ] ) ;
29793: LD_ADDR_LOC 37
29797: PUSH
29798: LD_INT 10
29800: PPUSH
29801: LD_LOC 32
29805: PPUSH
29806: LD_EXP 90
29810: PPUSH
29811: LD_INT 1
29813: PUSH
29814: LD_EXP 12
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PPUSH
29823: CALL_OW 401
29827: ST_TO_ADDR
// idDef3 := McDefend ( 10 , rDef3 , toDef3 , [ mc_def_advantage , mcdef3_difficulty ] ) ;
29828: LD_ADDR_LOC 38
29832: PUSH
29833: LD_INT 10
29835: PPUSH
29836: LD_LOC 33
29840: PPUSH
29841: LD_EXP 91
29845: PPUSH
29846: LD_INT 1
29848: PUSH
29849: LD_EXP 13
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 401
29862: ST_TO_ADDR
// idDef4 := McDefend ( 10 , rDef4 , toDef4 , [ mc_def_advantage , mcdef4_difficulty ] ) ;
29863: LD_ADDR_LOC 39
29867: PUSH
29868: LD_INT 10
29870: PPUSH
29871: LD_LOC 34
29875: PPUSH
29876: LD_EXP 92
29880: PPUSH
29881: LD_INT 1
29883: PUSH
29884: LD_EXP 14
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PPUSH
29893: CALL_OW 401
29897: ST_TO_ADDR
// idDef5 := McDefend ( 10 , rDef5 , toDef5 , [ mc_def_advantage , mcdef5_difficulty ] ) ;
29898: LD_ADDR_LOC 40
29902: PUSH
29903: LD_INT 10
29905: PPUSH
29906: LD_LOC 35
29910: PPUSH
29911: LD_EXP 93
29915: PPUSH
29916: LD_INT 1
29918: PUSH
29919: LD_EXP 15
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PPUSH
29928: CALL_OW 401
29932: ST_TO_ADDR
// end ;
29933: END
// every 0 0$10 do
29934: GO 29936
29936: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29937: LD_ADDR_EXP 89
29941: PUSH
29942: LD_EXP 76
29946: PUSH
29947: LD_INT 1
29949: ARRAY
29950: PPUSH
29951: LD_EXP 51
29955: PUSH
29956: EMPTY
29957: LIST
29958: PPUSH
29959: CALL_OW 72
29963: PUSH
29964: LD_EXP 77
29968: PUSH
29969: LD_INT 1
29971: ARRAY
29972: ADD
29973: PUSH
29974: LD_EXP 75
29978: PUSH
29979: LD_INT 1
29981: ARRAY
29982: PPUSH
29983: LD_EXP 56
29987: PUSH
29988: EMPTY
29989: LIST
29990: PPUSH
29991: CALL_OW 72
29995: ADD
29996: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29997: LD_ADDR_EXP 90
30001: PUSH
30002: LD_EXP 76
30006: PUSH
30007: LD_INT 2
30009: ARRAY
30010: PPUSH
30011: LD_EXP 51
30015: PUSH
30016: EMPTY
30017: LIST
30018: PPUSH
30019: CALL_OW 72
30023: PUSH
30024: LD_EXP 77
30028: PUSH
30029: LD_INT 2
30031: ARRAY
30032: ADD
30033: PUSH
30034: LD_EXP 75
30038: PUSH
30039: LD_INT 2
30041: ARRAY
30042: PPUSH
30043: LD_EXP 56
30047: PUSH
30048: EMPTY
30049: LIST
30050: PPUSH
30051: CALL_OW 72
30055: ADD
30056: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
30057: LD_ADDR_EXP 91
30061: PUSH
30062: LD_EXP 76
30066: PUSH
30067: LD_INT 3
30069: ARRAY
30070: PPUSH
30071: LD_EXP 51
30075: PUSH
30076: EMPTY
30077: LIST
30078: PPUSH
30079: CALL_OW 72
30083: PUSH
30084: LD_EXP 77
30088: PUSH
30089: LD_INT 3
30091: ARRAY
30092: ADD
30093: PUSH
30094: LD_EXP 75
30098: PUSH
30099: LD_INT 3
30101: ARRAY
30102: PPUSH
30103: LD_EXP 56
30107: PUSH
30108: EMPTY
30109: LIST
30110: PPUSH
30111: CALL_OW 72
30115: ADD
30116: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
30117: LD_ADDR_EXP 92
30121: PUSH
30122: LD_EXP 76
30126: PUSH
30127: LD_INT 4
30129: ARRAY
30130: PPUSH
30131: LD_EXP 51
30135: PUSH
30136: EMPTY
30137: LIST
30138: PPUSH
30139: CALL_OW 72
30143: PUSH
30144: LD_EXP 77
30148: PUSH
30149: LD_INT 4
30151: ARRAY
30152: ADD
30153: PUSH
30154: LD_EXP 75
30158: PUSH
30159: LD_INT 4
30161: ARRAY
30162: PPUSH
30163: LD_EXP 56
30167: PUSH
30168: EMPTY
30169: LIST
30170: PPUSH
30171: CALL_OW 72
30175: ADD
30176: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
30177: LD_ADDR_EXP 93
30181: PUSH
30182: LD_EXP 76
30186: PUSH
30187: LD_INT 5
30189: ARRAY
30190: PPUSH
30191: LD_EXP 51
30195: PUSH
30196: EMPTY
30197: LIST
30198: PPUSH
30199: CALL_OW 72
30203: PUSH
30204: LD_EXP 77
30208: PUSH
30209: LD_INT 5
30211: ARRAY
30212: ADD
30213: PUSH
30214: LD_EXP 75
30218: PUSH
30219: LD_INT 5
30221: ARRAY
30222: PPUSH
30223: LD_EXP 56
30227: PUSH
30228: EMPTY
30229: LIST
30230: PPUSH
30231: CALL_OW 72
30235: ADD
30236: ST_TO_ADDR
// ClearMcUnits ( idDef1 ) ;
30237: LD_LOC 36
30241: PPUSH
30242: CALL_OW 392
// AddMcUnits ( idDef1 , todef1 ) ;
30246: LD_LOC 36
30250: PPUSH
30251: LD_EXP 89
30255: PPUSH
30256: CALL_OW 390
// ClearMcUnits ( idDef2 ) ;
30260: LD_LOC 37
30264: PPUSH
30265: CALL_OW 392
// AddMcUnits ( idDef2 , todef2 ) ;
30269: LD_LOC 37
30273: PPUSH
30274: LD_EXP 90
30278: PPUSH
30279: CALL_OW 390
// ClearMcUnits ( idDef3 ) ;
30283: LD_LOC 38
30287: PPUSH
30288: CALL_OW 392
// AddMcUnits ( idDef3 , todef3 ) ;
30292: LD_LOC 38
30296: PPUSH
30297: LD_EXP 91
30301: PPUSH
30302: CALL_OW 390
// ClearMcUnits ( idDef4 ) ;
30306: LD_LOC 39
30310: PPUSH
30311: CALL_OW 392
// AddMcUnits ( idDef4 , todef4 ) ;
30315: LD_LOC 39
30319: PPUSH
30320: LD_EXP 92
30324: PPUSH
30325: CALL_OW 390
// ClearMcUnits ( idDef5 ) ;
30329: LD_LOC 40
30333: PPUSH
30334: CALL_OW 392
// AddMcUnits ( idDef5 , todef5 ) ;
30338: LD_LOC 40
30342: PPUSH
30343: LD_EXP 93
30347: PPUSH
30348: CALL_OW 390
// enable ;
30352: ENABLE
// end ; end_of_file
30353: END
// export function SurrenderBase ( type , side ) ; var a , cars ; begin
30354: LD_INT 0
30356: PPUSH
30357: PPUSH
30358: PPUSH
// if not ( side in your_bases ) then
30359: LD_VAR 0 2
30363: PUSH
30364: LD_EXP 18
30368: IN
30369: NOT
30370: IFFALSE 30984
// begin SetAttitude ( you , side , att_friend , true ) ;
30372: LD_EXP 7
30376: PPUSH
30377: LD_VAR 0 2
30381: PPUSH
30382: LD_INT 1
30384: PPUSH
30385: LD_INT 1
30387: PPUSH
30388: CALL_OW 80
// case type of t_kill :
30392: LD_VAR 0 1
30396: PUSH
30397: LD_EXP 1
30401: DOUBLE
30402: EQUAL
30403: IFTRUE 30407
30405: GO 30478
30407: POP
// begin if side = ai_s [ 1 ] then
30408: LD_VAR 0 2
30412: PUSH
30413: LD_EXP 23
30417: PUSH
30418: LD_INT 1
30420: ARRAY
30421: EQUAL
30422: IFFALSE 30447
// begin DXbaseSurrender ( side ) ;
30424: LD_VAR 0 2
30428: PPUSH
30429: CALL 7933 0 1
// SurrenderNormal ( true , side ) ;
30433: LD_INT 1
30435: PPUSH
30436: LD_VAR 0 2
30440: PPUSH
30441: CALL 30989 0 2
// end else
30445: GO 30476
// begin diplomacy := false ;
30447: LD_ADDR_EXP 27
30451: PUSH
30452: LD_INT 0
30454: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30455: LD_VAR 0 2
30459: PPUSH
30460: CALL 7933 0 1
// SurrenderNormal ( true , side ) ;
30464: LD_INT 1
30466: PPUSH
30467: LD_VAR 0 2
30471: PPUSH
30472: CALL 30989 0 2
// end ; end ; t_killbeat :
30476: GO 30816
30478: LD_EXP 6
30482: DOUBLE
30483: EQUAL
30484: IFTRUE 30488
30486: GO 30559
30488: POP
// begin if side = ai_s [ 1 ] then
30489: LD_VAR 0 2
30493: PUSH
30494: LD_EXP 23
30498: PUSH
30499: LD_INT 1
30501: ARRAY
30502: EQUAL
30503: IFFALSE 30528
// begin DXbaseSurrender ( side ) ;
30505: LD_VAR 0 2
30509: PPUSH
30510: CALL 7933 0 1
// SurrenderNormal ( true , side ) ;
30514: LD_INT 1
30516: PPUSH
30517: LD_VAR 0 2
30521: PPUSH
30522: CALL 30989 0 2
// end else
30526: GO 30557
// begin diplomacy := false ;
30528: LD_ADDR_EXP 27
30532: PUSH
30533: LD_INT 0
30535: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30536: LD_VAR 0 2
30540: PPUSH
30541: CALL 7933 0 1
// SurrenderNormal ( true , side ) ;
30545: LD_INT 1
30547: PPUSH
30548: LD_VAR 0 2
30552: PPUSH
30553: CALL 30989 0 2
// end ; end ; t_intimidate :
30557: GO 30816
30559: LD_EXP 2
30563: DOUBLE
30564: EQUAL
30565: IFTRUE 30569
30567: GO 30623
30569: POP
// begin if side = ai_s [ 2 ] then
30570: LD_VAR 0 2
30574: PUSH
30575: LD_EXP 23
30579: PUSH
30580: LD_INT 2
30582: ARRAY
30583: EQUAL
30584: IFFALSE 30621
// begin DB_BaseAccept ( cap_bases = 0 ) ;
30586: LD_EXP 17
30590: PUSH
30591: LD_INT 0
30593: EQUAL
30594: PPUSH
30595: CALL 4597 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 2 ] ) ;
30599: LD_EXP 17
30603: PUSH
30604: LD_INT 0
30606: EQUAL
30607: PPUSH
30608: LD_EXP 23
30612: PUSH
30613: LD_INT 2
30615: ARRAY
30616: PPUSH
30617: CALL 30989 0 2
// end ; end ; t_persuade :
30621: GO 30816
30623: LD_EXP 3
30627: DOUBLE
30628: EQUAL
30629: IFTRUE 30633
30631: GO 30687
30633: POP
// begin if side = ai_s [ 3 ] then
30634: LD_VAR 0 2
30638: PUSH
30639: LD_EXP 23
30643: PUSH
30644: LD_INT 3
30646: ARRAY
30647: EQUAL
30648: IFFALSE 30685
// begin DQrML_Right ( cap_bases = 0 ) ;
30650: LD_EXP 17
30654: PUSH
30655: LD_INT 0
30657: EQUAL
30658: PPUSH
30659: CALL 6756 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 3 ] ) ;
30663: LD_EXP 17
30667: PUSH
30668: LD_INT 0
30670: EQUAL
30671: PPUSH
30672: LD_EXP 23
30676: PUSH
30677: LD_INT 3
30679: ARRAY
30680: PPUSH
30681: CALL 30989 0 2
// end ; end ; t_pay :
30685: GO 30816
30687: LD_EXP 4
30691: DOUBLE
30692: EQUAL
30693: IFTRUE 30697
30695: GO 30751
30697: POP
// begin if side = ai_s [ 4 ] then
30698: LD_VAR 0 2
30702: PUSH
30703: LD_EXP 23
30707: PUSH
30708: LD_INT 4
30710: ARRAY
30711: EQUAL
30712: IFFALSE 30749
// begin DD_BaseAccept ( cap_bases = 0 ) ;
30714: LD_EXP 17
30718: PUSH
30719: LD_INT 0
30721: EQUAL
30722: PPUSH
30723: CALL 7320 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 4 ] ) ;
30727: LD_EXP 17
30731: PUSH
30732: LD_INT 0
30734: EQUAL
30735: PPUSH
30736: LD_EXP 23
30740: PUSH
30741: LD_INT 4
30743: ARRAY
30744: PPUSH
30745: CALL 30989 0 2
// end ; end ; t_beat :
30749: GO 30816
30751: LD_EXP 5
30755: DOUBLE
30756: EQUAL
30757: IFTRUE 30761
30759: GO 30815
30761: POP
// begin if side = ai_s [ 5 ] then
30762: LD_VAR 0 2
30766: PUSH
30767: LD_EXP 23
30771: PUSH
30772: LD_INT 5
30774: ARRAY
30775: EQUAL
30776: IFFALSE 30813
// begin DE_BaseAccept ( cap_bases = 0 ) ;
30778: LD_EXP 17
30782: PUSH
30783: LD_INT 0
30785: EQUAL
30786: PPUSH
30787: CALL 7873 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 5 ] ) ;
30791: LD_EXP 17
30795: PUSH
30796: LD_INT 0
30798: EQUAL
30799: PPUSH
30800: LD_EXP 23
30804: PUSH
30805: LD_INT 5
30807: ARRAY
30808: PPUSH
30809: CALL 30989 0 2
// end ; end ; end ;
30813: GO 30816
30815: POP
// your_humans := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
30816: LD_ADDR_EXP 37
30820: PUSH
30821: LD_INT 22
30823: PUSH
30824: LD_EXP 7
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: LD_INT 21
30835: PUSH
30836: LD_INT 1
30838: PUSH
30839: EMPTY
30840: LIST
30841: LIST
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PPUSH
30847: CALL_OW 69
30851: ST_TO_ADDR
// your_builds := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
30852: LD_ADDR_EXP 36
30856: PUSH
30857: LD_INT 22
30859: PUSH
30860: LD_EXP 7
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 21
30871: PUSH
30872: LD_INT 3
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PPUSH
30883: CALL_OW 69
30887: ST_TO_ADDR
// your_cars := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
30888: LD_ADDR_EXP 35
30892: PUSH
30893: LD_INT 22
30895: PUSH
30896: LD_EXP 7
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 21
30907: PUSH
30908: LD_INT 2
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PPUSH
30919: CALL_OW 69
30923: ST_TO_ADDR
// remove_from_humans ( your_humans ) ;
30924: LD_EXP 37
30928: PPUSH
30929: CALL 28022 0 1
// remove_from_builds ( your_builds ) ;
30933: LD_EXP 36
30937: PPUSH
30938: CALL 27776 0 1
// remove_from_vehicles ( your_cars ) ;
30942: LD_EXP 35
30946: PPUSH
30947: CALL 28260 0 1
// cap_bases := cap_bases + 1 ;
30951: LD_ADDR_EXP 17
30955: PUSH
30956: LD_EXP 17
30960: PUSH
30961: LD_INT 1
30963: PLUS
30964: ST_TO_ADDR
// your_bases := your_bases ^ [ side ] ;
30965: LD_ADDR_EXP 18
30969: PUSH
30970: LD_EXP 18
30974: PUSH
30975: LD_VAR 0 2
30979: PUSH
30980: EMPTY
30981: LIST
30982: ADD
30983: ST_TO_ADDR
// end ; end ;
30984: LD_VAR 0 3
30988: RET
// function SurrenderNormal ( first , side ) ; var yours , take , theirs , i , max , t_sci , t_lab ; begin
30989: LD_INT 0
30991: PPUSH
30992: PPUSH
30993: PPUSH
30994: PPUSH
30995: PPUSH
30996: PPUSH
30997: PPUSH
30998: PPUSH
// yours := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
30999: LD_ADDR_VAR 0 4
31003: PUSH
31004: LD_INT 22
31006: PUSH
31007: LD_EXP 7
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 21
31018: PUSH
31019: LD_INT 1
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 23
31028: PUSH
31029: LD_INT 3
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: LIST
31040: PPUSH
31041: CALL_OW 69
31045: ST_TO_ADDR
// theirs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31046: LD_ADDR_VAR 0 6
31050: PUSH
31051: LD_INT 22
31053: PUSH
31054: LD_VAR 0 2
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 21
31065: PUSH
31066: LD_INT 1
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 23
31075: PUSH
31076: LD_INT 3
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: LIST
31087: PPUSH
31088: CALL_OW 69
31092: ST_TO_ADDR
// for i in theirs do
31093: LD_ADDR_VAR 0 7
31097: PUSH
31098: LD_VAR 0 6
31102: PUSH
31103: FOR_IN
31104: IFFALSE 31139
// if GetLives ( i ) < hranice_umirani then
31106: LD_VAR 0 7
31110: PPUSH
31111: CALL_OW 256
31115: PUSH
31116: LD_INT 250
31118: LESS
31119: IFFALSE 31137
// SetLives ( i , hranice_umirani + 50 ) ;
31121: LD_VAR 0 7
31125: PPUSH
31126: LD_INT 250
31128: PUSH
31129: LD_INT 50
31131: PLUS
31132: PPUSH
31133: CALL_OW 234
31137: GO 31103
31139: POP
31140: POP
// InGameOn ;
31141: CALL_OW 8
// while UnitFilter ( theirs , [ [ f_inside ] ] ) diff hlavouni do
31145: LD_VAR 0 6
31149: PPUSH
31150: LD_INT 54
31152: PUSH
31153: EMPTY
31154: LIST
31155: PUSH
31156: EMPTY
31157: LIST
31158: PPUSH
31159: CALL_OW 72
31163: PUSH
31164: LD_EXP 72
31168: DIFF
31169: IFFALSE 31198
// begin ComExitBuilding ( theirs ) ;
31171: LD_VAR 0 6
31175: PPUSH
31176: CALL_OW 122
// AddComExitVehicle ( theirs ) ;
31180: LD_VAR 0 6
31184: PPUSH
31185: CALL_OW 181
// wait ( 0 0$2 ) ;
31189: LD_INT 70
31191: PPUSH
31192: CALL_OW 67
// end ;
31196: GO 31145
// InGameOff ;
31198: CALL_OW 9
// if first then
31202: LD_VAR 0 1
31206: IFFALSE 31872
// begin SetTech ( tech_SibLoc , you , state_researched ) ;
31208: LD_INT 19
31210: PPUSH
31211: LD_EXP 7
31215: PPUSH
31216: LD_INT 2
31218: PPUSH
31219: CALL_OW 322
// ai := ai diff side ;
31223: LD_ADDR_EXP 24
31227: PUSH
31228: LD_EXP 24
31232: PUSH
31233: LD_VAR 0 2
31237: DIFF
31238: ST_TO_ADDR
// case side of ai_s [ 1 ] :
31239: LD_VAR 0 2
31243: PUSH
31244: LD_EXP 23
31248: PUSH
31249: LD_INT 1
31251: ARRAY
31252: DOUBLE
31253: EQUAL
31254: IFTRUE 31258
31256: GO 31320
31258: POP
// begin SetSideBase_custom ( GetBase ( depots [ 1 ] ) , you ) ;
31259: LD_EXP 74
31263: PUSH
31264: LD_INT 1
31266: ARRAY
31267: PPUSH
31268: CALL_OW 274
31272: PPUSH
31273: LD_EXP 7
31277: PPUSH
31278: CALL 32759 0 2
// SetSide ( humans [ 1 ] , you ) ;
31282: LD_EXP 76
31286: PUSH
31287: LD_INT 1
31289: ARRAY
31290: PPUSH
31291: LD_EXP 7
31295: PPUSH
31296: CALL_OW 235
// SetSide ( vehicles [ 1 ] , you ) ;
31300: LD_EXP 77
31304: PUSH
31305: LD_INT 1
31307: ARRAY
31308: PPUSH
31309: LD_EXP 7
31313: PPUSH
31314: CALL_OW 235
// end ; ai_s [ 2 ] :
31318: GO 31870
31320: LD_EXP 23
31324: PUSH
31325: LD_INT 2
31327: ARRAY
31328: DOUBLE
31329: EQUAL
31330: IFTRUE 31334
31332: GO 31410
31334: POP
// begin SetSideBase_custom ( GetBase ( depots [ 2 ] ) , you ) ;
31335: LD_EXP 74
31339: PUSH
31340: LD_INT 2
31342: ARRAY
31343: PPUSH
31344: CALL_OW 274
31348: PPUSH
31349: LD_EXP 7
31353: PPUSH
31354: CALL 32759 0 2
// SetSide ( humans [ 2 ] , you ) ;
31358: LD_EXP 76
31362: PUSH
31363: LD_INT 2
31365: ARRAY
31366: PPUSH
31367: LD_EXP 7
31371: PPUSH
31372: CALL_OW 235
// SetSide ( vehicles [ 2 ] , you ) ;
31376: LD_EXP 77
31380: PUSH
31381: LD_INT 2
31383: ARRAY
31384: PPUSH
31385: LD_EXP 7
31389: PPUSH
31390: CALL_OW 235
// SetSide ( Borodin , you ) ;
31394: LD_EXP 46
31398: PPUSH
31399: LD_EXP 7
31403: PPUSH
31404: CALL_OW 235
// end ; ai_s [ 3 ] :
31408: GO 31870
31410: LD_EXP 23
31414: PUSH
31415: LD_INT 3
31417: ARRAY
31418: DOUBLE
31419: EQUAL
31420: IFTRUE 31424
31422: GO 31500
31424: POP
// begin SetSideBase_custom ( GetBase ( depots [ 3 ] ) , you ) ;
31425: LD_EXP 74
31429: PUSH
31430: LD_INT 3
31432: ARRAY
31433: PPUSH
31434: CALL_OW 274
31438: PPUSH
31439: LD_EXP 7
31443: PPUSH
31444: CALL 32759 0 2
// SetSide ( humans [ 3 ] , you ) ;
31448: LD_EXP 76
31452: PUSH
31453: LD_INT 3
31455: ARRAY
31456: PPUSH
31457: LD_EXP 7
31461: PPUSH
31462: CALL_OW 235
// SetSide ( vehicles [ 3 ] , you ) ;
31466: LD_EXP 77
31470: PUSH
31471: LD_INT 3
31473: ARRAY
31474: PPUSH
31475: LD_EXP 7
31479: PPUSH
31480: CALL_OW 235
// SetSide ( Tsaritsyn , you ) ;
31484: LD_EXP 47
31488: PPUSH
31489: LD_EXP 7
31493: PPUSH
31494: CALL_OW 235
// end ; ai_s [ 4 ] :
31498: GO 31870
31500: LD_EXP 23
31504: PUSH
31505: LD_INT 4
31507: ARRAY
31508: DOUBLE
31509: EQUAL
31510: IFTRUE 31514
31512: GO 31779
31514: POP
// begin t_sci := sci isect humans [ 4 ] ;
31515: LD_ADDR_VAR 0 9
31519: PUSH
31520: LD_EXP 88
31524: PUSH
31525: LD_EXP 76
31529: PUSH
31530: LD_INT 4
31532: ARRAY
31533: ISECT
31534: ST_TO_ADDR
// if t_sci > 3 then
31535: LD_VAR 0 9
31539: PUSH
31540: LD_INT 3
31542: GREATER
31543: IFFALSE 31579
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
31545: LD_ADDR_VAR 0 9
31549: PUSH
31550: LD_VAR 0 9
31554: PUSH
31555: LD_INT 1
31557: ARRAY
31558: PUSH
31559: LD_VAR 0 9
31563: PUSH
31564: LD_INT 2
31566: ARRAY
31567: ADD
31568: PUSH
31569: LD_VAR 0 9
31573: PUSH
31574: LD_INT 3
31576: ARRAY
31577: ADD
31578: ST_TO_ADDR
// t_lab := UnitFilter ( buildings [ 4 ] , [ mf_lab ] ) ;
31579: LD_ADDR_VAR 0 10
31583: PUSH
31584: LD_EXP 75
31588: PUSH
31589: LD_INT 4
31591: ARRAY
31592: PPUSH
31593: LD_EXP 55
31597: PUSH
31598: EMPTY
31599: LIST
31600: PPUSH
31601: CALL_OW 72
31605: ST_TO_ADDR
// for i in t_lab do
31606: LD_ADDR_VAR 0 7
31610: PUSH
31611: LD_VAR 0 10
31615: PUSH
31616: FOR_IN
31617: IFFALSE 31669
// if GetLabKind ( i , 1 ) = b_lab_spacetime or GetLabKind ( i , 2 ) = b_lab_spacetime then
31619: LD_VAR 0 7
31623: PPUSH
31624: LD_INT 1
31626: PPUSH
31627: CALL_OW 268
31631: PUSH
31632: LD_INT 14
31634: EQUAL
31635: PUSH
31636: LD_VAR 0 7
31640: PPUSH
31641: LD_INT 2
31643: PPUSH
31644: CALL_OW 268
31648: PUSH
31649: LD_INT 14
31651: EQUAL
31652: OR
31653: IFFALSE 31667
// begin t_lab := i ;
31655: LD_ADDR_VAR 0 10
31659: PUSH
31660: LD_VAR 0 7
31664: ST_TO_ADDR
// break ;
31665: GO 31669
// end ;
31667: GO 31616
31669: POP
31670: POP
// SetSideBase_custom ( GetBase ( depots [ 4 ] ) , you ) ;
31671: LD_EXP 74
31675: PUSH
31676: LD_INT 4
31678: ARRAY
31679: PPUSH
31680: CALL_OW 274
31684: PPUSH
31685: LD_EXP 7
31689: PPUSH
31690: CALL 32759 0 2
// SetSide ( humans [ 4 ] diff t_sci , you ) ;
31694: LD_EXP 76
31698: PUSH
31699: LD_INT 4
31701: ARRAY
31702: PUSH
31703: LD_VAR 0 9
31707: DIFF
31708: PPUSH
31709: LD_EXP 7
31713: PPUSH
31714: CALL_OW 235
// SetSide ( vehicles [ 4 ] , you ) ;
31718: LD_EXP 77
31722: PUSH
31723: LD_INT 4
31725: ARRAY
31726: PPUSH
31727: LD_EXP 7
31731: PPUSH
31732: CALL_OW 235
// SetSide ( t_lab , ai_s [ 4 ] ) ;
31736: LD_VAR 0 10
31740: PPUSH
31741: LD_EXP 23
31745: PUSH
31746: LD_INT 4
31748: ARRAY
31749: PPUSH
31750: CALL_OW 235
// ComEnterUnit ( t_sci ^ [ Davidov ] , t_lab ) ;
31754: LD_VAR 0 9
31758: PUSH
31759: LD_EXP 48
31763: PUSH
31764: EMPTY
31765: LIST
31766: ADD
31767: PPUSH
31768: LD_VAR 0 10
31772: PPUSH
31773: CALL_OW 120
// end ; ai_s [ 5 ] :
31777: GO 31870
31779: LD_EXP 23
31783: PUSH
31784: LD_INT 5
31786: ARRAY
31787: DOUBLE
31788: EQUAL
31789: IFTRUE 31793
31791: GO 31869
31793: POP
// begin SetSideBase_custom ( GetBase ( depots [ 5 ] ) , you ) ;
31794: LD_EXP 74
31798: PUSH
31799: LD_INT 5
31801: ARRAY
31802: PPUSH
31803: CALL_OW 274
31807: PPUSH
31808: LD_EXP 7
31812: PPUSH
31813: CALL 32759 0 2
// SetSide ( humans [ 5 ] , you ) ;
31817: LD_EXP 76
31821: PUSH
31822: LD_INT 5
31824: ARRAY
31825: PPUSH
31826: LD_EXP 7
31830: PPUSH
31831: CALL_OW 235
// SetSide ( vehicles [ 5 ] , you ) ;
31835: LD_EXP 77
31839: PUSH
31840: LD_INT 5
31842: ARRAY
31843: PPUSH
31844: LD_EXP 7
31848: PPUSH
31849: CALL_OW 235
// SetSide ( Eisenstein , you ) ;
31853: LD_EXP 49
31857: PPUSH
31858: LD_EXP 7
31862: PPUSH
31863: CALL_OW 235
// end ; end ;
31867: GO 31870
31869: POP
// end else
31870: GO 32669
// begin case side of ai_s [ 1 ] :
31872: LD_VAR 0 2
31876: PUSH
31877: LD_EXP 23
31881: PUSH
31882: LD_INT 1
31884: ARRAY
31885: DOUBLE
31886: EQUAL
31887: IFTRUE 31891
31889: GO 31928
31891: POP
// take := humans [ 1 ] ^ buildings [ 1 ] ^ vehicles [ 1 ] ; ai_s [ 2 ] :
31892: LD_ADDR_VAR 0 5
31896: PUSH
31897: LD_EXP 76
31901: PUSH
31902: LD_INT 1
31904: ARRAY
31905: PUSH
31906: LD_EXP 75
31910: PUSH
31911: LD_INT 1
31913: ARRAY
31914: ADD
31915: PUSH
31916: LD_EXP 77
31920: PUSH
31921: LD_INT 1
31923: ARRAY
31924: ADD
31925: ST_TO_ADDR
31926: GO 32669
31928: LD_EXP 23
31932: PUSH
31933: LD_INT 2
31935: ARRAY
31936: DOUBLE
31937: EQUAL
31938: IFTRUE 31942
31940: GO 32094
31942: POP
// begin if humans [ 2 ] < 3 then
31943: LD_EXP 76
31947: PUSH
31948: LD_INT 2
31950: ARRAY
31951: PUSH
31952: LD_INT 3
31954: LESS
31955: IFFALSE 31967
// max := 1 else
31957: LD_ADDR_VAR 0 8
31961: PUSH
31962: LD_INT 1
31964: ST_TO_ADDR
31965: GO 31985
// max := humans [ 2 ] - 2 ;
31967: LD_ADDR_VAR 0 8
31971: PUSH
31972: LD_EXP 76
31976: PUSH
31977: LD_INT 2
31979: ARRAY
31980: PUSH
31981: LD_INT 2
31983: MINUS
31984: ST_TO_ADDR
// if max > 5 then
31985: LD_VAR 0 8
31989: PUSH
31990: LD_INT 5
31992: GREATER
31993: IFFALSE 32003
// max := 5 ;
31995: LD_ADDR_VAR 0 8
31999: PUSH
32000: LD_INT 5
32002: ST_TO_ADDR
// take := CharacterSelection ( B-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 2 ] ^ [ sel_not_changeable ] ^ [ Borodin ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32003: LD_ADDR_VAR 0 5
32007: PUSH
32008: LD_STRING B-Base
32010: PPUSH
32011: LD_INT 1
32013: PPUSH
32014: LD_VAR 0 8
32018: PPUSH
32019: LD_VAR 0 4
32023: PUSH
32024: LD_INT -2
32026: PUSH
32027: LD_INT -3
32029: PUSH
32030: LD_INT -6
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: LIST
32037: ADD
32038: PUSH
32039: LD_EXP 76
32043: PUSH
32044: LD_INT 2
32046: ARRAY
32047: ADD
32048: PUSH
32049: LD_INT -4
32051: PUSH
32052: EMPTY
32053: LIST
32054: ADD
32055: PUSH
32056: LD_EXP 46
32060: PUSH
32061: EMPTY
32062: LIST
32063: ADD
32064: PPUSH
32065: LD_INT 1
32067: PUSH
32068: LD_INT 3
32070: PUSH
32071: LD_INT 2
32073: PUSH
32074: LD_INT 4
32076: PUSH
32077: LD_INT 9
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: PPUSH
32087: CALL_OW 42
32091: ST_TO_ADDR
// end ; ai_s [ 3 ] :
32092: GO 32669
32094: LD_EXP 23
32098: PUSH
32099: LD_INT 3
32101: ARRAY
32102: DOUBLE
32103: EQUAL
32104: IFTRUE 32108
32106: GO 32260
32108: POP
// begin if humans [ 3 ] < 3 then
32109: LD_EXP 76
32113: PUSH
32114: LD_INT 3
32116: ARRAY
32117: PUSH
32118: LD_INT 3
32120: LESS
32121: IFFALSE 32133
// max := 1 else
32123: LD_ADDR_VAR 0 8
32127: PUSH
32128: LD_INT 1
32130: ST_TO_ADDR
32131: GO 32151
// max := humans [ 3 ] - 2 ;
32133: LD_ADDR_VAR 0 8
32137: PUSH
32138: LD_EXP 76
32142: PUSH
32143: LD_INT 3
32145: ARRAY
32146: PUSH
32147: LD_INT 2
32149: MINUS
32150: ST_TO_ADDR
// if max > 3 then
32151: LD_VAR 0 8
32155: PUSH
32156: LD_INT 3
32158: GREATER
32159: IFFALSE 32169
// max := 3 ;
32161: LD_ADDR_VAR 0 8
32165: PUSH
32166: LD_INT 3
32168: ST_TO_ADDR
// take := CharacterSelection ( C-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 3 ] ^ [ sel_not_changeable ] ^ [ Tsaritsyn ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32169: LD_ADDR_VAR 0 5
32173: PUSH
32174: LD_STRING C-Base
32176: PPUSH
32177: LD_INT 1
32179: PPUSH
32180: LD_VAR 0 8
32184: PPUSH
32185: LD_VAR 0 4
32189: PUSH
32190: LD_INT -2
32192: PUSH
32193: LD_INT -3
32195: PUSH
32196: LD_INT -6
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: LIST
32203: ADD
32204: PUSH
32205: LD_EXP 76
32209: PUSH
32210: LD_INT 3
32212: ARRAY
32213: ADD
32214: PUSH
32215: LD_INT -4
32217: PUSH
32218: EMPTY
32219: LIST
32220: ADD
32221: PUSH
32222: LD_EXP 47
32226: PUSH
32227: EMPTY
32228: LIST
32229: ADD
32230: PPUSH
32231: LD_INT 1
32233: PUSH
32234: LD_INT 3
32236: PUSH
32237: LD_INT 2
32239: PUSH
32240: LD_INT 4
32242: PUSH
32243: LD_INT 9
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: PPUSH
32253: CALL_OW 42
32257: ST_TO_ADDR
// end ; ai_s [ 4 ] :
32258: GO 32669
32260: LD_EXP 23
32264: PUSH
32265: LD_INT 4
32267: ARRAY
32268: DOUBLE
32269: EQUAL
32270: IFTRUE 32274
32272: GO 32502
32274: POP
// begin if humans [ 4 ] < 3 then
32275: LD_EXP 76
32279: PUSH
32280: LD_INT 4
32282: ARRAY
32283: PUSH
32284: LD_INT 3
32286: LESS
32287: IFFALSE 32299
// max := 1 else
32289: LD_ADDR_VAR 0 8
32293: PUSH
32294: LD_INT 1
32296: ST_TO_ADDR
32297: GO 32317
// max := humans [ 4 ] - 2 ;
32299: LD_ADDR_VAR 0 8
32303: PUSH
32304: LD_EXP 76
32308: PUSH
32309: LD_INT 4
32311: ARRAY
32312: PUSH
32313: LD_INT 2
32315: MINUS
32316: ST_TO_ADDR
// if max > 2 then
32317: LD_VAR 0 8
32321: PUSH
32322: LD_INT 2
32324: GREATER
32325: IFFALSE 32335
// max := 2 ;
32327: LD_ADDR_VAR 0 8
32331: PUSH
32332: LD_INT 2
32334: ST_TO_ADDR
// t_sci := sci isect humans [ 4 ] ;
32335: LD_ADDR_VAR 0 9
32339: PUSH
32340: LD_EXP 88
32344: PUSH
32345: LD_EXP 76
32349: PUSH
32350: LD_INT 4
32352: ARRAY
32353: ISECT
32354: ST_TO_ADDR
// if t_sci > 3 then
32355: LD_VAR 0 9
32359: PUSH
32360: LD_INT 3
32362: GREATER
32363: IFFALSE 32399
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
32365: LD_ADDR_VAR 0 9
32369: PUSH
32370: LD_VAR 0 9
32374: PUSH
32375: LD_INT 1
32377: ARRAY
32378: PUSH
32379: LD_VAR 0 9
32383: PUSH
32384: LD_INT 2
32386: ARRAY
32387: ADD
32388: PUSH
32389: LD_VAR 0 9
32393: PUSH
32394: LD_INT 3
32396: ARRAY
32397: ADD
32398: ST_TO_ADDR
// take := CharacterSelection ( D-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ ( humans [ 4 ] diff t_sci ) ^ [ sel_not_changeable ] ^ t_sci ^ [ Davidov ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32399: LD_ADDR_VAR 0 5
32403: PUSH
32404: LD_STRING D-Base
32406: PPUSH
32407: LD_INT 1
32409: PPUSH
32410: LD_VAR 0 8
32414: PPUSH
32415: LD_VAR 0 4
32419: PUSH
32420: LD_INT -2
32422: PUSH
32423: LD_INT -3
32425: PUSH
32426: LD_INT -6
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: LIST
32433: ADD
32434: PUSH
32435: LD_EXP 76
32439: PUSH
32440: LD_INT 4
32442: ARRAY
32443: PUSH
32444: LD_VAR 0 9
32448: DIFF
32449: ADD
32450: PUSH
32451: LD_INT -4
32453: PUSH
32454: EMPTY
32455: LIST
32456: ADD
32457: PUSH
32458: LD_VAR 0 9
32462: ADD
32463: PUSH
32464: LD_EXP 48
32468: PUSH
32469: EMPTY
32470: LIST
32471: ADD
32472: PPUSH
32473: LD_INT 1
32475: PUSH
32476: LD_INT 3
32478: PUSH
32479: LD_INT 2
32481: PUSH
32482: LD_INT 4
32484: PUSH
32485: LD_INT 9
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: PPUSH
32495: CALL_OW 42
32499: ST_TO_ADDR
// end ; ai_s [ 5 ] :
32500: GO 32669
32502: LD_EXP 23
32506: PUSH
32507: LD_INT 5
32509: ARRAY
32510: DOUBLE
32511: EQUAL
32512: IFTRUE 32516
32514: GO 32668
32516: POP
// begin if humans [ 5 ] < 3 then
32517: LD_EXP 76
32521: PUSH
32522: LD_INT 5
32524: ARRAY
32525: PUSH
32526: LD_INT 3
32528: LESS
32529: IFFALSE 32541
// max := 1 else
32531: LD_ADDR_VAR 0 8
32535: PUSH
32536: LD_INT 1
32538: ST_TO_ADDR
32539: GO 32559
// max := humans [ 5 ] - 2 ;
32541: LD_ADDR_VAR 0 8
32545: PUSH
32546: LD_EXP 76
32550: PUSH
32551: LD_INT 5
32553: ARRAY
32554: PUSH
32555: LD_INT 2
32557: MINUS
32558: ST_TO_ADDR
// if max > 5 then
32559: LD_VAR 0 8
32563: PUSH
32564: LD_INT 5
32566: GREATER
32567: IFFALSE 32577
// max := 5 ;
32569: LD_ADDR_VAR 0 8
32573: PUSH
32574: LD_INT 5
32576: ST_TO_ADDR
// take := CharacterSelection ( E-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 5 ] ^ [ sel_not_changeable ] ^ [ Eisenstein ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_STRING E-Base
32584: PPUSH
32585: LD_INT 1
32587: PPUSH
32588: LD_VAR 0 8
32592: PPUSH
32593: LD_VAR 0 4
32597: PUSH
32598: LD_INT -2
32600: PUSH
32601: LD_INT -3
32603: PUSH
32604: LD_INT -6
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: LIST
32611: ADD
32612: PUSH
32613: LD_EXP 76
32617: PUSH
32618: LD_INT 5
32620: ARRAY
32621: ADD
32622: PUSH
32623: LD_INT -4
32625: PUSH
32626: EMPTY
32627: LIST
32628: ADD
32629: PUSH
32630: LD_EXP 49
32634: PUSH
32635: EMPTY
32636: LIST
32637: ADD
32638: PPUSH
32639: LD_INT 1
32641: PUSH
32642: LD_INT 3
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: LD_INT 4
32650: PUSH
32651: LD_INT 9
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: PPUSH
32661: CALL_OW 42
32665: ST_TO_ADDR
// end ; end ;
32666: GO 32669
32668: POP
// end ; ComExitVehicle ( take ) ;
32669: LD_VAR 0 5
32673: PPUSH
32674: CALL_OW 121
// AddComExitBuilding ( take ) ;
32678: LD_VAR 0 5
32682: PPUSH
32683: CALL_OW 182
// take := take union FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) ;
32687: LD_ADDR_VAR 0 5
32691: PUSH
32692: LD_VAR 0 5
32696: PUSH
32697: LD_INT 22
32699: PUSH
32700: LD_VAR 0 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 21
32711: PUSH
32712: LD_INT 2
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 33
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: LIST
32733: PPUSH
32734: CALL_OW 69
32738: UNION
32739: ST_TO_ADDR
// SetSide ( take , you ) ;
32740: LD_VAR 0 5
32744: PPUSH
32745: LD_EXP 7
32749: PPUSH
32750: CALL_OW 235
// end ;
32754: LD_VAR 0 3
32758: RET
// export function SetSideBase_custom ( base , side ) ; var b , depot , orig_side ; begin
32759: LD_INT 0
32761: PPUSH
32762: PPUSH
32763: PPUSH
32764: PPUSH
// depot = - 1 ;
32765: LD_ADDR_VAR 0 5
32769: PUSH
32770: LD_INT 1
32772: NEG
32773: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
32774: LD_ADDR_VAR 0 4
32778: PUSH
32779: LD_INT 2
32781: PUSH
32782: LD_INT 30
32784: PUSH
32785: LD_INT 0
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 30
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: LIST
32806: PUSH
32807: EMPTY
32808: LIST
32809: PPUSH
32810: CALL_OW 69
32814: PUSH
32815: FOR_IN
32816: IFFALSE 32849
// if GetBase ( b ) = base then
32818: LD_VAR 0 4
32822: PPUSH
32823: CALL_OW 274
32827: PUSH
32828: LD_VAR 0 1
32832: EQUAL
32833: IFFALSE 32847
// begin depot = b ;
32835: LD_ADDR_VAR 0 5
32839: PUSH
32840: LD_VAR 0 4
32844: ST_TO_ADDR
// break ;
32845: GO 32849
// end ;
32847: GO 32815
32849: POP
32850: POP
// orig_side = GetSide ( depot ) ;
32851: LD_ADDR_VAR 0 6
32855: PUSH
32856: LD_VAR 0 5
32860: PPUSH
32861: CALL_OW 255
32865: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , orig_side ] , [ f_type , unit_building ] ] ) diff depot do
32866: LD_ADDR_VAR 0 4
32870: PUSH
32871: LD_INT 22
32873: PUSH
32874: LD_VAR 0 6
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 21
32885: PUSH
32886: LD_INT 3
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PPUSH
32897: CALL_OW 69
32901: PUSH
32902: LD_VAR 0 5
32906: DIFF
32907: PUSH
32908: FOR_IN
32909: IFFALSE 32944
// if GetBase ( b ) = base then
32911: LD_VAR 0 4
32915: PPUSH
32916: CALL_OW 274
32920: PUSH
32921: LD_VAR 0 1
32925: EQUAL
32926: IFFALSE 32942
// SetSide ( b , side ) ;
32928: LD_VAR 0 4
32932: PPUSH
32933: LD_VAR 0 2
32937: PPUSH
32938: CALL_OW 235
32942: GO 32908
32944: POP
32945: POP
// SetSide ( depot , side ) ;
32946: LD_VAR 0 5
32950: PPUSH
32951: LD_VAR 0 2
32955: PPUSH
32956: CALL_OW 235
// end ; end_of_file
32960: LD_VAR 0 3
32964: RET
// every 0 0$2 + 0 0$0.1 do
32965: GO 32967
32967: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
32968: LD_INT 22
32970: PUSH
32971: LD_INT 3
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 2
32980: PUSH
32981: LD_INT 25
32983: PUSH
32984: LD_INT 12
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 25
32993: PUSH
32994: LD_INT 16
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 25
33003: PUSH
33004: LD_INT 15
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 25
33013: PUSH
33014: LD_INT 17
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PPUSH
33032: CALL_OW 69
33036: PUSH
33037: LD_INT 22
33039: PUSH
33040: LD_INT 3
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 21
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 3
33059: PUSH
33060: LD_INT 2
33062: PUSH
33063: LD_INT 25
33065: PUSH
33066: LD_INT 12
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 25
33075: PUSH
33076: LD_INT 16
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: LD_INT 25
33085: PUSH
33086: LD_INT 15
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 25
33095: PUSH
33096: LD_INT 17
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: LIST
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: LIST
33118: PPUSH
33119: CALL_OW 69
33123: GREATER
33124: IFFALSE 33135
// begin SetAchievement ( ACH_POTA ) ;
33126: LD_STRING ACH_POTA
33128: PPUSH
33129: CALL_OW 543
// exit ;
33133: GO 33136
// end ; enable ;
33135: ENABLE
// end ;
33136: END
// export function SA_OnMissionStart ; begin
33137: LD_INT 0
33139: PPUSH
// SetAchievement ( ACH_RPAT ) ;
33140: LD_STRING ACH_RPAT
33142: PPUSH
33143: CALL_OW 543
// end ;
33147: LD_VAR 0 1
33151: RET
// export function SA_OnTsaritsynQuizPerfectCleared ( qg ) ; begin
33152: LD_INT 0
33154: PPUSH
// SetAchievementEX ( ACH_CAD , qg ) ;
33155: LD_STRING ACH_CAD
33157: PPUSH
33158: LD_VAR 0 1
33162: PPUSH
33163: CALL_OW 564
// if qg = 6 then
33167: LD_VAR 0 1
33171: PUSH
33172: LD_INT 6
33174: EQUAL
33175: IFFALSE 33184
// SetAchievement ( ACH_CAD ) ;
33177: LD_STRING ACH_CAD
33179: PPUSH
33180: CALL_OW 543
// end ; end_of_file
33184: LD_VAR 0 2
33188: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
33189: LD_INT 0
33191: PPUSH
33192: PPUSH
// if not missionNumber then
33193: LD_VAR 0 2
33197: NOT
33198: IFFALSE 33202
// exit ;
33200: GO 33332
// achiv := false ;
33202: LD_ADDR_VAR 0 7
33206: PUSH
33207: LD_INT 0
33209: ST_TO_ADDR
// case campaignNumber of 1 :
33210: LD_VAR 0 1
33214: PUSH
33215: LD_INT 1
33217: DOUBLE
33218: EQUAL
33219: IFTRUE 33223
33221: GO 33234
33223: POP
// achiv := ACH_GOTA ; 2 :
33224: LD_ADDR_VAR 0 7
33228: PUSH
33229: LD_STRING ACH_GOTA
33231: ST_TO_ADDR
33232: GO 33284
33234: LD_INT 2
33236: DOUBLE
33237: EQUAL
33238: IFTRUE 33242
33240: GO 33245
33242: POP
// ; 3 :
33243: GO 33284
33245: LD_INT 3
33247: DOUBLE
33248: EQUAL
33249: IFTRUE 33253
33251: GO 33264
33253: POP
// achiv := ACH_MOTSU ; 4 :
33254: LD_ADDR_VAR 0 7
33258: PUSH
33259: LD_STRING ACH_MOTSU
33261: ST_TO_ADDR
33262: GO 33284
33264: LD_INT 4
33266: DOUBLE
33267: EQUAL
33268: IFTRUE 33272
33270: GO 33283
33272: POP
// achiv := ACH_LOP ; end ;
33273: LD_ADDR_VAR 0 7
33277: PUSH
33278: LD_STRING ACH_LOP
33280: ST_TO_ADDR
33281: GO 33284
33283: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
33284: LD_OWVAR 67
33288: PUSH
33289: LD_INT 3
33291: EQUAL
33292: PUSH
33293: LD_VAR 0 7
33297: AND
33298: PUSH
33299: LD_VAR 0 3
33303: AND
33304: PUSH
33305: LD_VAR 0 4
33309: AND
33310: PUSH
33311: LD_VAR 0 5
33315: AND
33316: IFFALSE 33332
// SetAchievementEX ( achiv , missionNumber ) ;
33318: LD_VAR 0 7
33322: PPUSH
33323: LD_VAR 0 2
33327: PPUSH
33328: CALL_OW 564
// end ;
33332: LD_VAR 0 6
33336: RET
// export function SA_BehemothConstructed ; begin
33337: LD_INT 0
33339: PPUSH
// SetAchievement ( ACH_SMC ) ;
33340: LD_STRING ACH_SMC
33342: PPUSH
33343: CALL_OW 543
// end ;
33347: LD_VAR 0 1
33351: RET

// export t_kill , t_intimidate , t_persuade , t_pay , t_beat , t_killbeat ; export you , americans , arabians , nature ; export mcdef1_difficulty , mcdef2_difficulty , mcdef3_difficulty , mcdef4_difficulty , mcdef5_difficulty ; export gossudarov_mech_skill ; export cap_bases ; export your_bases ; export aiH , aiN , aiZ ; export ai_nation ; export ai_s ; export ai ; export plat_i ; export apemans ; export Diplomacy , Goss ; export BehemothSeen ; export vedci_zacali_zdrhat ; export run_sci ; export utek , utek_e ; export art_cargo1 ; export your_cars ; export your_builds ; export your_humans ; export function inicializace_main ; begin
   0: LD_INT 0
   2: PPUSH
// you := 3 ;
   3: LD_ADDR_EXP 7
   7: PUSH
   8: LD_INT 3
  10: ST_TO_ADDR
// americans := 1 ;
  11: LD_ADDR_EXP 8
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabians := 2 ;
  19: LD_ADDR_EXP 9
  23: PUSH
  24: LD_INT 2
  26: ST_TO_ADDR
// nature := 0 ;
  27: LD_ADDR_EXP 10
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// utek := [ [ 55 , 21 ] , [ 83 , 36 ] , [ 103 , 70 ] , [ 142 , 88 ] ] ;
  35: LD_ADDR_EXP 32
  39: PUSH
  40: LD_INT 55
  42: PUSH
  43: LD_INT 21
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: PUSH
  50: LD_INT 83
  52: PUSH
  53: LD_INT 36
  55: PUSH
  56: EMPTY
  57: LIST
  58: LIST
  59: PUSH
  60: LD_INT 103
  62: PUSH
  63: LD_INT 70
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: PUSH
  70: LD_INT 142
  72: PUSH
  73: LD_INT 88
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: PUSH
  80: EMPTY
  81: LIST
  82: LIST
  83: LIST
  84: LIST
  85: ST_TO_ADDR
// utek_e := [ 186 , 55 ] ;
  86: LD_ADDR_EXP 33
  90: PUSH
  91: LD_INT 186
  93: PUSH
  94: LD_INT 55
  96: PUSH
  97: EMPTY
  98: LIST
  99: LIST
 100: ST_TO_ADDR
// cap_bases := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// t_kill := 1 ;
 109: LD_ADDR_EXP 1
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// t_intimidate := 2 ;
 117: LD_ADDR_EXP 2
 121: PUSH
 122: LD_INT 2
 124: ST_TO_ADDR
// t_persuade := 3 ;
 125: LD_ADDR_EXP 3
 129: PUSH
 130: LD_INT 3
 132: ST_TO_ADDR
// t_pay := 4 ;
 133: LD_ADDR_EXP 4
 137: PUSH
 138: LD_INT 4
 140: ST_TO_ADDR
// t_beat := 5 ;
 141: LD_ADDR_EXP 5
 145: PUSH
 146: LD_INT 5
 148: ST_TO_ADDR
// t_killbeat := 10 ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 10
 156: ST_TO_ADDR
// Diplomacy := true ;
 157: LD_ADDR_EXP 27
 161: PUSH
 162: LD_INT 1
 164: ST_TO_ADDR
// Goss := true ;
 165: LD_ADDR_EXP 28
 169: PUSH
 170: LD_INT 1
 172: ST_TO_ADDR
// ai_s := [ 6 , 5 , 2 , 8 , 7 ] ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 6
 180: PUSH
 181: LD_INT 5
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: LD_INT 7
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// ai := [ 6 , 5 , 2 , 8 , 7 ] ;
 200: LD_ADDR_EXP 24
 204: PUSH
 205: LD_INT 6
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 2
 213: PUSH
 214: LD_INT 8
 216: PUSH
 217: LD_INT 7
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: ST_TO_ADDR
// plat_i := 1 ;
 227: LD_ADDR_EXP 25
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// aiH := [ ] ;
 235: LD_ADDR_EXP 19
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// aiN := [ ai_s [ 2 ] , ai_s [ 3 ] , ai_s [ 4 ] , ai_s [ 5 ] ] ;
 242: LD_ADDR_EXP 20
 246: PUSH
 247: LD_EXP 23
 251: PUSH
 252: LD_INT 2
 254: ARRAY
 255: PUSH
 256: LD_EXP 23
 260: PUSH
 261: LD_INT 3
 263: ARRAY
 264: PUSH
 265: LD_EXP 23
 269: PUSH
 270: LD_INT 4
 272: ARRAY
 273: PUSH
 274: LD_EXP 23
 278: PUSH
 279: LD_INT 5
 281: ARRAY
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: ST_TO_ADDR
// aiZ := [ ai_s [ 1 ] ] ;
 289: LD_ADDR_EXP 21
 293: PUSH
 294: LD_EXP 23
 298: PUSH
 299: LD_INT 1
 301: ARRAY
 302: PUSH
 303: EMPTY
 304: LIST
 305: ST_TO_ADDR
// your_bases := [ ] ;
 306: LD_ADDR_EXP 18
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// cap_bases := 0 ;
 313: LD_ADDR_EXP 17
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// art_cargo1 := art_cargo ;
 321: LD_ADDR_EXP 34
 325: PUSH
 326: LD_INT 121
 328: ST_TO_ADDR
// ai_nation := nation_russian ;
 329: LD_ADDR_EXP 22
 333: PUSH
 334: LD_INT 3
 336: ST_TO_ADDR
// debug_strings := [ [ ] , [ ] , [ ] ] ;
 337: LD_ADDR_OWVAR 48
 341: PUSH
 342: EMPTY
 343: PUSH
 344: EMPTY
 345: PUSH
 346: EMPTY
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: ST_TO_ADDR
// end ;
 353: LD_VAR 0 1
 357: RET
// export vyhrano ; export function VyhraPlaton ; begin
 358: LD_INT 0
 360: PPUSH
// if not vyhrano then
 361: LD_EXP 38
 365: NOT
 366: IFFALSE 497
// begin vyhrano := true ;
 368: LD_ADDR_EXP 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// cap_bases := 5 ;
 376: LD_ADDR_EXP 17
 380: PUSH
 381: LD_INT 5
 383: ST_TO_ADDR
// Query ( QEndInfo ) ;
 384: LD_STRING QEndInfo
 386: PPUSH
 387: CALL_OW 97
// ExclusiveOn ;
 391: CALL_OW 4
// wait ( 1 ) ;
 395: LD_INT 1
 397: PPUSH
 398: CALL_OW 67
// DEnd ;
 402: CALL 8132 0 0
// ExclusiveOff ;
 406: CALL_OW 5
// SetMedals ;
 410: CALL 502 0 0
// GiveMedals ( Platon ) ;
 414: LD_STRING Platon
 416: PPUSH
 417: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ) ;
 421: LD_INT 22
 423: PUSH
 424: LD_EXP 7
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 21
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 3
 445: PUSH
 446: LD_INT 23
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: PPUSH
 470: CALL_OW 43
// Save ;
 474: CALL 9127 0 0
// YouWin ;
 478: CALL_OW 103
// ExclusiveOn ;
 482: CALL_OW 4
// wait ( 1 ) ;
 486: LD_INT 1
 488: PPUSH
 489: CALL_OW 67
// ExclusiveOff ;
 493: CALL_OW 5
// end ; end ;
 497: LD_VAR 0 1
 501: RET
// export function SetMedals ; begin
 502: LD_INT 0
 504: PPUSH
// AddMedal ( All , cap_bases = 5 ) ;
 505: LD_STRING All
 507: PPUSH
 508: LD_EXP 17
 512: PUSH
 513: LD_INT 5
 515: EQUAL
 516: PPUSH
 517: CALL_OW 101
// AddMedal ( Diplomacy , Diplomacy ) ;
 521: LD_STRING Diplomacy
 523: PPUSH
 524: LD_EXP 27
 528: PPUSH
 529: CALL_OW 101
// AddMedal ( Goss , Goss ) ;
 533: LD_STRING Goss
 535: PPUSH
 536: LD_EXP 28
 540: PPUSH
 541: CALL_OW 101
// end ;
 545: LD_VAR 0 1
 549: RET
// export function LostBurlak ; begin
 550: LD_INT 0
 552: PPUSH
// YouLost ( Burlak ) ;
 553: LD_STRING Burlak
 555: PPUSH
 556: CALL_OW 104
// end ;
 560: LD_VAR 0 1
 564: RET
// export function LostArte ; begin
 565: LD_INT 0
 567: PPUSH
// YouLost ( Arte ) ;
 568: LD_STRING Arte
 570: PPUSH
 571: CALL_OW 104
// end ;
 575: LD_VAR 0 1
 579: RET
// export function set_difficulty ; begin
 580: LD_INT 0
 582: PPUSH
// mcdef1_difficulty := [ 200 , 230 , 260 ] [ difficulty ] ;
 583: LD_ADDR_EXP 11
 587: PUSH
 588: LD_INT 200
 590: PUSH
 591: LD_INT 230
 593: PUSH
 594: LD_INT 260
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PUSH
 602: LD_OWVAR 67
 606: ARRAY
 607: ST_TO_ADDR
// mcdef2_difficulty := [ 150 , 180 , 200 ] [ difficulty ] ;
 608: LD_ADDR_EXP 12
 612: PUSH
 613: LD_INT 150
 615: PUSH
 616: LD_INT 180
 618: PUSH
 619: LD_INT 200
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: PUSH
 627: LD_OWVAR 67
 631: ARRAY
 632: ST_TO_ADDR
// mcdef3_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 633: LD_ADDR_EXP 13
 637: PUSH
 638: LD_INT 170
 640: PUSH
 641: LD_INT 200
 643: PUSH
 644: LD_INT 230
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_OWVAR 67
 656: ARRAY
 657: ST_TO_ADDR
// mcdef4_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 658: LD_ADDR_EXP 14
 662: PUSH
 663: LD_INT 170
 665: PUSH
 666: LD_INT 200
 668: PUSH
 669: LD_INT 230
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_OWVAR 67
 681: ARRAY
 682: ST_TO_ADDR
// mcdef5_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 683: LD_ADDR_EXP 15
 687: PUSH
 688: LD_INT 170
 690: PUSH
 691: LD_INT 200
 693: PUSH
 694: LD_INT 230
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_OWVAR 67
 706: ARRAY
 707: ST_TO_ADDR
// gossudarov_mech_skill := [ 0 , 2 , 4 ] [ difficulty ] ;
 708: LD_ADDR_EXP 16
 712: PUSH
 713: LD_INT 0
 715: PUSH
 716: LD_INT 2
 718: PUSH
 719: LD_INT 4
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: ST_TO_ADDR
// end ;
 733: LD_VAR 0 1
 737: RET
// export function get_your_units ; var a ; begin
 738: LD_INT 0
 740: PPUSH
 741: PPUSH
// a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
 742: LD_ADDR_VAR 0 2
 746: PUSH
 747: LD_INT 22
 749: PUSH
 750: LD_EXP 7
 754: PUSH
 755: EMPTY
 756: LIST
 757: LIST
 758: PUSH
 759: EMPTY
 760: LIST
 761: PPUSH
 762: CALL_OW 69
 766: ST_TO_ADDR
// your_humans := UnitFilter ( a , [ [ f_type , unit_human ] ] ) ;
 767: LD_ADDR_EXP 37
 771: PUSH
 772: LD_VAR 0 2
 776: PPUSH
 777: LD_INT 21
 779: PUSH
 780: LD_INT 1
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: PUSH
 787: EMPTY
 788: LIST
 789: PPUSH
 790: CALL_OW 72
 794: ST_TO_ADDR
// your_cars := UnitFilter ( a , [ [ f_type , unit_vehicle ] ] ) ;
 795: LD_ADDR_EXP 35
 799: PUSH
 800: LD_VAR 0 2
 804: PPUSH
 805: LD_INT 21
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL_OW 72
 822: ST_TO_ADDR
// your_builds := UnitFilter ( a , [ [ f_type , unit_building ] ] ) ;
 823: LD_ADDR_EXP 36
 827: PUSH
 828: LD_VAR 0 2
 832: PPUSH
 833: LD_INT 21
 835: PUSH
 836: LD_INT 3
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: EMPTY
 844: LIST
 845: PPUSH
 846: CALL_OW 72
 850: ST_TO_ADDR
// end ;
 851: LD_VAR 0 1
 855: RET
// every 0 0$1 do var i ;
 856: GO 858
 858: DISABLE
 859: LD_INT 0
 861: PPUSH
// begin for i in ai do
 862: LD_ADDR_VAR 0 1
 866: PUSH
 867: LD_EXP 24
 871: PUSH
 872: FOR_IN
 873: IFFALSE 1070
// case GetAttitude ( i , you ) of att_friend :
 875: LD_VAR 0 1
 879: PPUSH
 880: LD_EXP 7
 884: PPUSH
 885: CALL_OW 81
 889: PUSH
 890: LD_INT 1
 892: DOUBLE
 893: EQUAL
 894: IFTRUE 898
 896: GO 949
 898: POP
// begin aiH := aiH union i ;
 899: LD_ADDR_EXP 19
 903: PUSH
 904: LD_EXP 19
 908: PUSH
 909: LD_VAR 0 1
 913: UNION
 914: ST_TO_ADDR
// aiZ := aiZ diff i ;
 915: LD_ADDR_EXP 21
 919: PUSH
 920: LD_EXP 21
 924: PUSH
 925: LD_VAR 0 1
 929: DIFF
 930: ST_TO_ADDR
// aiN := aiN diff i ;
 931: LD_ADDR_EXP 20
 935: PUSH
 936: LD_EXP 20
 940: PUSH
 941: LD_VAR 0 1
 945: DIFF
 946: ST_TO_ADDR
// end ; att_neutral :
 947: GO 1068
 949: LD_INT 0
 951: DOUBLE
 952: EQUAL
 953: IFTRUE 957
 955: GO 1008
 957: POP
// begin aiN := aiN union i ;
 958: LD_ADDR_EXP 20
 962: PUSH
 963: LD_EXP 20
 967: PUSH
 968: LD_VAR 0 1
 972: UNION
 973: ST_TO_ADDR
// aiZ := aiZ diff i ;
 974: LD_ADDR_EXP 21
 978: PUSH
 979: LD_EXP 21
 983: PUSH
 984: LD_VAR 0 1
 988: DIFF
 989: ST_TO_ADDR
// aiH := aiH diff i ;
 990: LD_ADDR_EXP 19
 994: PUSH
 995: LD_EXP 19
 999: PUSH
1000: LD_VAR 0 1
1004: DIFF
1005: ST_TO_ADDR
// end ; att_enemy :
1006: GO 1068
1008: LD_INT 2
1010: DOUBLE
1011: EQUAL
1012: IFTRUE 1016
1014: GO 1067
1016: POP
// begin aiZ := aiZ union i ;
1017: LD_ADDR_EXP 21
1021: PUSH
1022: LD_EXP 21
1026: PUSH
1027: LD_VAR 0 1
1031: UNION
1032: ST_TO_ADDR
// aiH := aiH diff i ;
1033: LD_ADDR_EXP 19
1037: PUSH
1038: LD_EXP 19
1042: PUSH
1043: LD_VAR 0 1
1047: DIFF
1048: ST_TO_ADDR
// aiN := aiN diff i ;
1049: LD_ADDR_EXP 20
1053: PUSH
1054: LD_EXP 20
1058: PUSH
1059: LD_VAR 0 1
1063: DIFF
1064: ST_TO_ADDR
// end ; end ;
1065: GO 1068
1067: POP
1068: GO 872
1070: POP
1071: POP
// enable ;
1072: ENABLE
// end ;
1073: PPOPN 1
1075: END
// every 0 0$1 do
1076: GO 1078
1078: DISABLE
// begin debug_strings := [ [ ( tick div 0 0$1 ) div 60 , ( tick div 0 0$1 ) mod 60 ] , debug_strings [ 2 ] , debug_strings [ 3 ] ] ;
1079: LD_ADDR_OWVAR 48
1083: PUSH
1084: LD_OWVAR 1
1088: PUSH
1089: LD_INT 35
1091: DIV
1092: PUSH
1093: LD_INT 60
1095: DIV
1096: PUSH
1097: LD_OWVAR 1
1101: PUSH
1102: LD_INT 35
1104: DIV
1105: PUSH
1106: LD_INT 60
1108: MOD
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: PUSH
1114: LD_OWVAR 48
1118: PUSH
1119: LD_INT 2
1121: ARRAY
1122: PUSH
1123: LD_OWVAR 48
1127: PUSH
1128: LD_INT 3
1130: ARRAY
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: ST_TO_ADDR
// enable ;
1137: ENABLE
// end ;
1138: END
// starting begin SA_OnMissionStart ;
1139: CALL 33096 0 0
// inicializace_main ;
1143: CALL 0 0 0
// inicializace_ai ;
1147: CALL 22615 0 0
// inicializace_functions ;
1151: CALL 9781 0 0
// inicializace_ai_b_repair ;
1155: CALL 22189 0 0
// inicializace_ai_b_build ;
1159: CALL 16119 0 0
// inicializace_ai_defend ;
1163: CALL 11597 0 0
// inicializace_ai_c_make ;
1167: CALL 13996 0 0
// inicializace_ai_c_repair ;
1171: CALL 12528 0 0
// disable ( 10 ) ;
1175: LD_INT 10
1177: DISABLE_MARKED
// disable ( 11 ) ;
1178: LD_INT 11
1180: DISABLE_MARKED
// disable ( 12 ) ;
1181: LD_INT 12
1183: DISABLE_MARKED
// disable ( 115 ) ;
1184: LD_INT 115
1186: DISABLE_MARKED
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_type , unit_human ] , [ f_class , class_apeman ] ] ) ;
1187: LD_ADDR_EXP 26
1191: PUSH
1192: LD_INT 23
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: PUSH
1202: LD_INT 21
1204: PUSH
1205: LD_INT 1
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 25
1214: PUSH
1215: LD_INT 12
1217: PUSH
1218: EMPTY
1219: LIST
1220: LIST
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: CALL_OW 69
1231: ST_TO_ADDR
// set_difficulty ;
1232: CALL 580 0 0
// SetCargo ( art_cargo1 , mat_artifact , 4 * 10 ) ;
1236: LD_EXP 34
1240: PPUSH
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 4
1246: PUSH
1247: LD_INT 10
1249: MUL
1250: PPUSH
1251: CALL_OW 290
// load ;
1255: CALL 8280 0 0
// inicializace_dialogues ;
1259: CALL 1284 0 0
// place_ru ;
1263: CALL 8821 0 0
// build_map ;
1267: CALL 20464 0 0
// get_groups ;
1271: CALL 22757 0 0
// get_your_units ;
1275: CALL 738 0 0
// DStart ;
1279: CALL 1459 0 0
// end ; end_of_file
1283: END
// var Gla , Bur , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ; var talking ; export function inicializace_dialogues ; begin
1284: LD_INT 0
1286: PPUSH
// Bur := Burlak ;
1287: LD_ADDR_LOC 2
1291: PUSH
1292: LD_EXP 41
1296: ST_TO_ADDR
// Gla := Gladkov ;
1297: LD_ADDR_LOC 1
1301: PUSH
1302: LD_EXP 44
1306: ST_TO_ADDR
// Glb := Gleb ;
1307: LD_ADDR_LOC 10
1311: PUSH
1312: LD_EXP 50
1316: ST_TO_ADDR
// Pla := Platonov ;
1317: LD_ADDR_LOC 3
1321: PUSH
1322: LD_EXP 42
1326: ST_TO_ADDR
// Gos := Gossudarov ;
1327: LD_ADDR_LOC 4
1331: PUSH
1332: LD_EXP 43
1336: ST_TO_ADDR
// Fad := Fadeev ;
1337: LD_ADDR_LOC 5
1341: PUSH
1342: LD_EXP 45
1346: ST_TO_ADDR
// Bor := Borodin ;
1347: LD_ADDR_LOC 6
1351: PUSH
1352: LD_EXP 46
1356: ST_TO_ADDR
// Tsr := Tsaritsyn ;
1357: LD_ADDR_LOC 7
1361: PUSH
1362: LD_EXP 47
1366: ST_TO_ADDR
// Dav := Davidov ;
1367: LD_ADDR_LOC 8
1371: PUSH
1372: LD_EXP 48
1376: ST_TO_ADDR
// Eis := Eisenstein ;
1377: LD_ADDR_LOC 9
1381: PUSH
1382: LD_EXP 49
1386: ST_TO_ADDR
// talking := [ Bur , Gla , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ] ;
1387: LD_ADDR_LOC 11
1391: PUSH
1392: LD_LOC 2
1396: PUSH
1397: LD_LOC 1
1401: PUSH
1402: LD_LOC 3
1406: PUSH
1407: LD_LOC 4
1411: PUSH
1412: LD_LOC 5
1416: PUSH
1417: LD_LOC 6
1421: PUSH
1422: LD_LOC 7
1426: PUSH
1427: LD_LOC 8
1431: PUSH
1432: LD_LOC 9
1436: PUSH
1437: LD_LOC 10
1441: PUSH
1442: EMPTY
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: ST_TO_ADDR
// end ;
1454: LD_VAR 0 1
1458: RET
// export function DStart ; begin
1459: LD_INT 0
1461: PPUSH
// hide_interface_automaticaly := true ;
1462: LD_ADDR_OWVAR 53
1466: PUSH
1467: LD_INT 1
1469: ST_TO_ADDR
// InGameOn ;
1470: CALL_OW 8
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
1474: LD_LOC 2
1478: PPUSH
1479: CALL_OW 310
1483: PPUSH
1484: CALL_OW 87
// CenterNowOnUnits ( Bur ) ;
1488: LD_LOC 2
1492: PPUSH
1493: CALL_OW 87
// while IsInUnit ( bur ) do
1497: LD_LOC 2
1501: PPUSH
1502: CALL_OW 310
1506: IFFALSE 1526
// begin ComExitVehicle ( Bur ) ;
1508: LD_LOC 2
1512: PPUSH
1513: CALL_OW 121
// wait ( 0 0$0.3 ) ;
1517: LD_INT 10
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1497
// Say ( Bur , DStart-Bur-1 ) ;
1526: LD_LOC 2
1530: PPUSH
1531: LD_STRING DStart-Bur-1
1533: PPUSH
1534: CALL_OW 88
// Say ( Gla , DStart-Gla-1 ) ;
1538: LD_LOC 1
1542: PPUSH
1543: LD_STRING DStart-Gla-1
1545: PPUSH
1546: CALL_OW 88
// Say ( Bur , DStart-Bur-2 ) ;
1550: LD_LOC 2
1554: PPUSH
1555: LD_STRING DStart-Bur-2
1557: PPUSH
1558: CALL_OW 88
// Say ( Gla , DStart-Gla-2 ) ;
1562: LD_LOC 1
1566: PPUSH
1567: LD_STRING DStart-Gla-2
1569: PPUSH
1570: CALL_OW 88
// Say ( Bur , DStart-Bur-3 ) ;
1574: LD_LOC 2
1578: PPUSH
1579: LD_STRING DStart-Bur-3
1581: PPUSH
1582: CALL_OW 88
// Say ( Gla , DStart-Gla-3 ) ;
1586: LD_LOC 1
1590: PPUSH
1591: LD_STRING DStart-Gla-3
1593: PPUSH
1594: CALL_OW 88
// Say ( Bur , DStart-Bur-4 ) ;
1598: LD_LOC 2
1602: PPUSH
1603: LD_STRING DStart-Bur-4
1605: PPUSH
1606: CALL_OW 88
// SetBName ( da , bluekher ) ;
1610: LD_INT 1
1612: PPUSH
1613: LD_STRING bluekher
1615: PPUSH
1616: CALL_OW 500
// SetBName ( dc , yegorov ) ;
1620: LD_INT 80
1622: PPUSH
1623: LD_STRING yegorov
1625: PPUSH
1626: CALL_OW 500
// SetBName ( dd , ryutin ) ;
1630: LD_INT 28
1632: PPUSH
1633: LD_STRING ryutin
1635: PPUSH
1636: CALL_OW 500
// SetBName ( db , budonny ) ;
1640: LD_INT 51
1642: PPUSH
1643: LD_STRING budonny
1645: PPUSH
1646: CALL_OW 500
// SetBName ( de , yakir ) ;
1650: LD_INT 37
1652: PPUSH
1653: LD_STRING yakir
1655: PPUSH
1656: CALL_OW 500
// RevealFogArea ( you , near_base ) ;
1660: LD_EXP 7
1664: PPUSH
1665: LD_INT 7
1667: PPUSH
1668: CALL_OW 332
// CenterOnUnits ( dc ) ;
1672: LD_INT 80
1674: PPUSH
1675: CALL_OW 85
// DWait ( 0 0$2 ) ;
1679: LD_INT 70
1681: PPUSH
1682: CALL_OW 68
// Say ( Gla , DStart-Gla-4 ) ;
1686: LD_LOC 1
1690: PPUSH
1691: LD_STRING DStart-Gla-4
1693: PPUSH
1694: CALL_OW 88
// CenterOnUnits ( dd ) ;
1698: LD_INT 28
1700: PPUSH
1701: CALL_OW 85
// DWait ( 0 0$2 ) ;
1705: LD_INT 70
1707: PPUSH
1708: CALL_OW 68
// Say ( Gla , DStart-Gla-4a ) ;
1712: LD_LOC 1
1716: PPUSH
1717: LD_STRING DStart-Gla-4a
1719: PPUSH
1720: CALL_OW 88
// CenterOnUnits ( de ) ;
1724: LD_INT 37
1726: PPUSH
1727: CALL_OW 85
// DWait ( 0 0$2 ) ;
1731: LD_INT 70
1733: PPUSH
1734: CALL_OW 68
// Say ( Gla , DStart-Gla-4b ) ;
1738: LD_LOC 1
1742: PPUSH
1743: LD_STRING DStart-Gla-4b
1745: PPUSH
1746: CALL_OW 88
// CenterOnUnits ( db ) ;
1750: LD_INT 51
1752: PPUSH
1753: CALL_OW 85
// DWait ( 0 0$2 ) ;
1757: LD_INT 70
1759: PPUSH
1760: CALL_OW 68
// Say ( Gla , DStart-Gla-4c ) ;
1764: LD_LOC 1
1768: PPUSH
1769: LD_STRING DStart-Gla-4c
1771: PPUSH
1772: CALL_OW 88
// CenterOnUnits ( da ) ;
1776: LD_INT 1
1778: PPUSH
1779: CALL_OW 85
// DWait ( 0 0$2 ) ;
1783: LD_INT 70
1785: PPUSH
1786: CALL_OW 68
// Say ( Gla , DStart-Gla-4d ) ;
1790: LD_LOC 1
1794: PPUSH
1795: LD_STRING DStart-Gla-4d
1797: PPUSH
1798: CALL_OW 88
// Say ( Gla , DStart-Gla-4e ) ;
1802: LD_LOC 1
1806: PPUSH
1807: LD_STRING DStart-Gla-4e
1809: PPUSH
1810: CALL_OW 88
// SaveForQuickRestart ;
1814: CALL_OW 22
// CenterNowOnUnits ( Bur ) ;
1818: LD_LOC 2
1822: PPUSH
1823: CALL_OW 87
// ChangeMissionObjectives ( MStart ) ;
1827: LD_STRING MStart
1829: PPUSH
1830: CALL_OW 337
// InGameOff ;
1834: CALL_OW 9
// end ;
1838: LD_VAR 0 1
1842: RET
// every 29 29$0 marked 111 do
1843: GO 1845
1845: DISABLE
// begin disable ( 112 ) ;
1846: LD_INT 112
1848: DISABLE_MARKED
// zdrhaji ;
1849: CALL 1878 0 0
// end ;
1853: END
// every 0 0$30 trigger kecali_o_artefaktu marked 112 do
1854: LD_EXP 40
1858: IFFALSE 1877
1860: GO 1862
1862: DISABLE
// begin disable ( 111 ) ;
1863: LD_INT 111
1865: DISABLE_MARKED
// wait ( 2 2$15 ) ;
1866: LD_INT 4725
1868: PPUSH
1869: CALL_OW 67
// zdrhaji ;
1873: CALL 1878 0 0
// end ;
1877: END
// function zdrhaji ; var ai1sci , i , mytick ; begin
1878: LD_INT 0
1880: PPUSH
1881: PPUSH
1882: PPUSH
1883: PPUSH
// vedci_zacali_zdrhat := true ;
1884: LD_ADDR_EXP 30
1888: PUSH
1889: LD_INT 1
1891: ST_TO_ADDR
// TeleportExit ( telp1 , 136 , 88 ) ;
1892: LD_INT 15
1894: PPUSH
1895: LD_INT 136
1897: PPUSH
1898: LD_INT 88
1900: PPUSH
1901: CALL_OW 243
// ai1sci := UnitFilter ( humans [ 1 ] , [ mf_sci ] ) ;
1905: LD_ADDR_VAR 0 2
1909: PUSH
1910: LD_EXP 76
1914: PUSH
1915: LD_INT 1
1917: ARRAY
1918: PPUSH
1919: LD_EXP 54
1923: PUSH
1924: EMPTY
1925: LIST
1926: PPUSH
1927: CALL_OW 72
1931: ST_TO_ADDR
// if ai1sci then
1932: LD_VAR 0 2
1936: IFFALSE 1948
// run_sci := ai1sci ;
1938: LD_ADDR_EXP 31
1942: PUSH
1943: LD_VAR 0 2
1947: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff run_sci ) ;
1948: LD_ADDR_EXP 76
1952: PUSH
1953: LD_EXP 76
1957: PPUSH
1958: LD_INT 1
1960: PPUSH
1961: LD_EXP 76
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PUSH
1970: LD_EXP 31
1974: DIFF
1975: PPUSH
1976: CALL_OW 1
1980: ST_TO_ADDR
// sci := sci diff run_sci ;
1981: LD_ADDR_EXP 88
1985: PUSH
1986: LD_EXP 88
1990: PUSH
1991: LD_EXP 31
1995: DIFF
1996: ST_TO_ADDR
// for i in utek do
1997: LD_ADDR_VAR 0 3
2001: PUSH
2002: LD_EXP 32
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2039
// AddComMoveXY ( run_sci , i [ 1 ] , i [ 2 ] ) ;
2010: LD_EXP 31
2014: PPUSH
2015: LD_VAR 0 3
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: PPUSH
2024: LD_VAR 0 3
2028: PUSH
2029: LD_INT 2
2031: ARRAY
2032: PPUSH
2033: CALL_OW 171
2037: GO 2007
2039: POP
2040: POP
// wait ( 0 0$10 ) ;
2041: LD_INT 350
2043: PPUSH
2044: CALL_OW 67
// DGossudarov ;
2048: CALL 2699 0 0
// mytick := tick + 1 1$30 ;
2052: LD_ADDR_VAR 0 4
2056: PUSH
2057: LD_OWVAR 1
2061: PUSH
2062: LD_INT 3150
2064: PLUS
2065: ST_TO_ADDR
// while mytick > tick and not UnitFilter ( run_sci , [ f_or , [ f_not , [ f_alive ] ] , [ f_distxy , 142 , 88 , 10 ] ] ) do
2066: LD_VAR 0 4
2070: PUSH
2071: LD_OWVAR 1
2075: GREATER
2076: PUSH
2077: LD_EXP 31
2081: PPUSH
2082: LD_INT 2
2084: PUSH
2085: LD_INT 3
2087: PUSH
2088: LD_INT 51
2090: PUSH
2091: EMPTY
2092: LIST
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 92
2100: PUSH
2101: LD_INT 142
2103: PUSH
2104: LD_INT 88
2106: PUSH
2107: LD_INT 10
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: EMPTY
2117: LIST
2118: LIST
2119: LIST
2120: PPUSH
2121: CALL_OW 72
2125: NOT
2126: AND
2127: IFFALSE 2138
// wait ( 0 0$1 ) ;
2129: LD_INT 35
2131: PPUSH
2132: CALL_OW 67
2136: GO 2066
// ComExitVehicle ( Gossudarov ) ;
2138: LD_EXP 43
2142: PPUSH
2143: CALL_OW 121
// while not UnitsInside ( art_cargo ) do
2147: LD_INT 121
2149: PPUSH
2150: CALL_OW 313
2154: NOT
2155: IFFALSE 2178
// begin ComEnterUnit ( Gossudarov , art_cargo ) ;
2157: LD_EXP 43
2161: PPUSH
2162: LD_INT 121
2164: PPUSH
2165: CALL_OW 120
// wait ( 0 0$1 ) ;
2169: LD_INT 35
2171: PPUSH
2172: CALL_OW 67
// end ;
2176: GO 2147
// if UnitFilter ( run_sci , [ [ f_distxy , 142 , 88 , 12 ] ] ) then
2178: LD_EXP 31
2182: PPUSH
2183: LD_INT 92
2185: PUSH
2186: LD_INT 142
2188: PUSH
2189: LD_INT 88
2191: PUSH
2192: LD_INT 12
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: PUSH
2201: EMPTY
2202: LIST
2203: PPUSH
2204: CALL_OW 72
2208: IFFALSE 2260
// while not UnitFilter ( art_cargo , [ [ f_distxy , 136 , 88 , 15 ] ] ) do
2210: LD_INT 121
2212: PPUSH
2213: LD_INT 92
2215: PUSH
2216: LD_INT 136
2218: PUSH
2219: LD_INT 88
2221: PUSH
2222: LD_INT 15
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: LIST
2230: PUSH
2231: EMPTY
2232: LIST
2233: PPUSH
2234: CALL_OW 72
2238: NOT
2239: IFFALSE 2260
// begin ComMoveUnit ( art_cargo , telp1 ) ;
2241: LD_INT 121
2243: PPUSH
2244: LD_INT 15
2246: PPUSH
2247: CALL_OW 112
// wait ( 0 0$1 ) ;
2251: LD_INT 35
2253: PPUSH
2254: CALL_OW 67
// end ;
2258: GO 2210
// while UnitFilter ( run_sci ^ art_cargo , [ [ f_placed ] ] ) do
2260: LD_EXP 31
2264: PUSH
2265: LD_INT 121
2267: ADD
2268: PPUSH
2269: LD_INT 52
2271: PUSH
2272: EMPTY
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: PPUSH
2278: CALL_OW 72
2282: IFFALSE 2416
// begin ComMoveXY ( ( run_sci ) ^ art_cargo , utek_e [ 1 ] , utek_e [ 2 ] ) ;
2284: LD_EXP 31
2288: PUSH
2289: LD_INT 121
2291: ADD
2292: PPUSH
2293: LD_EXP 33
2297: PUSH
2298: LD_INT 1
2300: ARRAY
2301: PPUSH
2302: LD_EXP 33
2306: PUSH
2307: LD_INT 2
2309: ARRAY
2310: PPUSH
2311: CALL_OW 111
// for i in UnitFilter ( ( run_sci ) ^ art_cargo , [ [ f_distxy , utek_e [ 1 ] , utek_e [ 2 ] , 5 ] ] ) do
2315: LD_ADDR_VAR 0 3
2319: PUSH
2320: LD_EXP 31
2324: PUSH
2325: LD_INT 121
2327: ADD
2328: PPUSH
2329: LD_INT 92
2331: PUSH
2332: LD_EXP 33
2336: PUSH
2337: LD_INT 1
2339: ARRAY
2340: PUSH
2341: LD_EXP 33
2345: PUSH
2346: LD_INT 2
2348: ARRAY
2349: PUSH
2350: LD_INT 5
2352: PUSH
2353: EMPTY
2354: LIST
2355: LIST
2356: LIST
2357: LIST
2358: PUSH
2359: EMPTY
2360: LIST
2361: PPUSH
2362: CALL_OW 72
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2405
// if i = art_cargo then
2370: LD_VAR 0 3
2374: PUSH
2375: LD_INT 121
2377: EQUAL
2378: IFFALSE 2386
// LostArte else
2380: CALL 565 0 0
2384: GO 2403
// begin RemoveUnit ( i ) ;
2386: LD_VAR 0 3
2390: PPUSH
2391: CALL_OW 64
// Goss := false ;
2395: LD_ADDR_EXP 28
2399: PUSH
2400: LD_INT 0
2402: ST_TO_ADDR
// end ;
2403: GO 2367
2405: POP
2406: POP
// wait ( 0 0$1 ) ;
2407: LD_INT 35
2409: PPUSH
2410: CALL_OW 67
// end ;
2414: GO 2260
// end ;
2416: LD_VAR 0 1
2420: RET
// every 0 0$1 trigger vedci_zacali_zdrhat and UnitFilter ( run_sci ^ Gossudarov , [ [ f_alive ] , [ f_placed ] ] ) = 0 do
2421: LD_EXP 30
2425: PUSH
2426: LD_EXP 31
2430: PUSH
2431: LD_EXP 43
2435: ADD
2436: PPUSH
2437: LD_INT 51
2439: PUSH
2440: EMPTY
2441: LIST
2442: PUSH
2443: LD_INT 52
2445: PUSH
2446: EMPTY
2447: LIST
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PPUSH
2453: CALL_OW 72
2457: PUSH
2458: LD_INT 0
2460: EQUAL
2461: AND
2462: IFFALSE 2474
2464: GO 2466
2466: DISABLE
// begin ChangeMissionObjectives ( MGossSciOut ) ;
2467: LD_STRING MGossSciOut
2469: PPUSH
2470: CALL_OW 337
// end ;
2474: END
// every 0 0$1 do var h , hinfo , i ;
2475: GO 2477
2477: DISABLE
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
2482: PPUSH
// begin h := FindArtifact ( 4 ) ;
2483: LD_ADDR_VAR 0 1
2487: PUSH
2488: LD_INT 4
2490: PPUSH
2491: CALL_OW 469
2495: ST_TO_ADDR
// if h then
2496: LD_VAR 0 1
2500: IFFALSE 2695
// begin hinfo := HexInfo ( h [ 1 ] , h [ 2 ] ) ;
2502: LD_ADDR_VAR 0 2
2506: PUSH
2507: LD_VAR 0 1
2511: PUSH
2512: LD_INT 1
2514: ARRAY
2515: PPUSH
2516: LD_VAR 0 1
2520: PUSH
2521: LD_INT 2
2523: ARRAY
2524: PPUSH
2525: CALL_OW 428
2529: ST_TO_ADDR
// if hinfo > 0 then
2530: LD_VAR 0 2
2534: PUSH
2535: LD_INT 0
2537: GREATER
2538: IFFALSE 2577
// begin if GetSide ( hinfo ) = you then
2540: LD_VAR 0 2
2544: PPUSH
2545: CALL_OW 255
2549: PUSH
2550: LD_EXP 7
2554: EQUAL
2555: IFFALSE 2567
// maji_artifact := true else
2557: LD_ADDR_EXP 39
2561: PUSH
2562: LD_INT 1
2564: ST_TO_ADDR
2565: GO 2575
// maji_artifact := false ;
2567: LD_ADDR_EXP 39
2571: PUSH
2572: LD_INT 0
2574: ST_TO_ADDR
// end else
2575: GO 2695
// begin maji_artifact := false ;
2577: LD_ADDR_EXP 39
2581: PUSH
2582: LD_INT 0
2584: ST_TO_ADDR
// for i := 1 to 5 do
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: DOUBLE
2591: LD_INT 1
2593: DEC
2594: ST_TO_ADDR
2595: LD_INT 5
2597: PUSH
2598: FOR_TO
2599: IFFALSE 2693
// if ( ai_s [ i ] in your_bases ) and ( InArea ( h [ 1 ] , h [ 2 ] , near_base_area [ i ] ) or InArea ( h [ 1 ] , h [ 2 ] , nearD ) ) then
2601: LD_EXP 23
2605: PUSH
2606: LD_VAR 0 3
2610: ARRAY
2611: PUSH
2612: LD_EXP 18
2616: IN
2617: PUSH
2618: LD_VAR 0 1
2622: PUSH
2623: LD_INT 1
2625: ARRAY
2626: PPUSH
2627: LD_VAR 0 1
2631: PUSH
2632: LD_INT 2
2634: ARRAY
2635: PPUSH
2636: LD_EXP 63
2640: PUSH
2641: LD_VAR 0 3
2645: ARRAY
2646: PPUSH
2647: CALL_OW 309
2651: PUSH
2652: LD_VAR 0 1
2656: PUSH
2657: LD_INT 1
2659: ARRAY
2660: PPUSH
2661: LD_VAR 0 1
2665: PUSH
2666: LD_INT 2
2668: ARRAY
2669: PPUSH
2670: LD_INT 27
2672: PPUSH
2673: CALL_OW 309
2677: OR
2678: AND
2679: IFFALSE 2691
// begin maji_artifact := true ;
2681: LD_ADDR_EXP 39
2685: PUSH
2686: LD_INT 1
2688: ST_TO_ADDR
// break ;
2689: GO 2693
// end ;
2691: GO 2598
2693: POP
2694: POP
// end ; end ; enable ;
2695: ENABLE
// end ;
2696: PPOPN 3
2698: END
// export function DGossudarov ; var x , y ; begin
2699: LD_INT 0
2701: PPUSH
2702: PPUSH
2703: PPUSH
// x := GetX ( run_sci [ 1 ] ) ;
2704: LD_ADDR_VAR 0 2
2708: PUSH
2709: LD_EXP 31
2713: PUSH
2714: LD_INT 1
2716: ARRAY
2717: PPUSH
2718: CALL_OW 250
2722: ST_TO_ADDR
// y := GetY ( run_sci [ 1 ] ) ;
2723: LD_ADDR_VAR 0 3
2727: PUSH
2728: LD_EXP 31
2732: PUSH
2733: LD_INT 1
2735: ARRAY
2736: PPUSH
2737: CALL_OW 251
2741: ST_TO_ADDR
// PlaceSeeing ( x , y , You , 10 ) ;
2742: LD_VAR 0 2
2746: PPUSH
2747: LD_VAR 0 3
2751: PPUSH
2752: LD_EXP 7
2756: PPUSH
2757: LD_INT 10
2759: PPUSH
2760: CALL_OW 330
// CenterNowOnXY ( x , y ) ;
2764: LD_VAR 0 2
2768: PPUSH
2769: LD_VAR 0 3
2773: PPUSH
2774: CALL_OW 86
// wait ( 0 0$1 ) ;
2778: LD_INT 35
2780: PPUSH
2781: CALL_OW 67
// DialogueOn ;
2785: CALL_OW 6
// Say ( Fad , DGossudarov-Fad-1 ) ;
2789: LD_LOC 5
2793: PPUSH
2794: LD_STRING DGossudarov-Fad-1
2796: PPUSH
2797: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-1 ) ;
2801: LD_LOC 2
2805: PPUSH
2806: LD_STRING DGossudarov-Bur-1
2808: PPUSH
2809: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-1 ) ;
2813: LD_LOC 4
2817: PPUSH
2818: LD_STRING DGossudarov-Gos-1
2820: PPUSH
2821: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-2 ) ;
2825: LD_LOC 2
2829: PPUSH
2830: LD_STRING DGossudarov-Bur-2
2832: PPUSH
2833: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-2 ) ;
2837: LD_LOC 4
2841: PPUSH
2842: LD_STRING DGossudarov-Gos-2
2844: PPUSH
2845: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-3 ) ;
2849: LD_LOC 2
2853: PPUSH
2854: LD_STRING DGossudarov-Bur-3
2856: PPUSH
2857: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-3 ) ;
2861: LD_LOC 4
2865: PPUSH
2866: LD_STRING DGossudarov-Gos-3
2868: PPUSH
2869: CALL_OW 88
// ChangeMissionObjectives ( MGoss ) ;
2873: LD_STRING MGoss
2875: PPUSH
2876: CALL_OW 337
// DialogueOff ;
2880: CALL_OW 7
// wait ( 0 0$5 ) ;
2884: LD_INT 175
2886: PPUSH
2887: CALL_OW 67
// RemoveSeeing ( x , y , You ) ;
2891: LD_VAR 0 2
2895: PPUSH
2896: LD_VAR 0 3
2900: PPUSH
2901: LD_EXP 7
2905: PPUSH
2906: CALL_OW 331
// end ;
2910: LD_VAR 0 1
2914: RET
// every 0 0$2 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
2915: LD_EXP 23
2919: PUSH
2920: LD_EXP 25
2924: ARRAY
2925: PPUSH
2926: LD_EXP 37
2930: PUSH
2931: LD_EXP 35
2935: ADD
2936: PPUSH
2937: CALL 10546 0 2
2941: PUSH
2942: LD_EXP 37
2946: PUSH
2947: LD_EXP 35
2951: ADD
2952: PPUSH
2953: LD_INT 95
2955: PUSH
2956: LD_EXP 63
2960: PUSH
2961: LD_EXP 25
2965: ARRAY
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: EMPTY
2972: LIST
2973: PPUSH
2974: CALL_OW 72
2978: AND
2979: IFFALSE 2988
2981: GO 2983
2983: DISABLE
// begin DA_BaseContact ;
2984: CALL 2989 0 0
// end ;
2988: END
// export function DA_BaseContact ; begin
2989: LD_INT 0
2991: PPUSH
// DialogueOn ;
2992: CALL_OW 6
// Say ( Pla , DA-BaseContact-Pla-1 ) ;
2996: LD_LOC 3
3000: PPUSH
3001: LD_STRING DA-BaseContact-Pla-1
3003: PPUSH
3004: CALL_OW 88
// Say ( Bur , DA-BaseContact-Bur-1 ) ;
3008: LD_LOC 2
3012: PPUSH
3013: LD_STRING DA-BaseContact-Bur-1
3015: PPUSH
3016: CALL_OW 88
// DialogueOff ;
3020: CALL_OW 7
// end ;
3024: LD_VAR 0 1
3028: RET
// every 0 0$20 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
3029: LD_EXP 23
3033: PUSH
3034: LD_EXP 25
3038: ARRAY
3039: PPUSH
3040: LD_EXP 37
3044: PUSH
3045: LD_EXP 35
3049: ADD
3050: PPUSH
3051: CALL 10546 0 2
3055: PUSH
3056: LD_EXP 37
3060: PUSH
3061: LD_EXP 35
3065: ADD
3066: PPUSH
3067: LD_INT 95
3069: PUSH
3070: LD_EXP 63
3074: PUSH
3075: LD_EXP 25
3079: ARRAY
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: EMPTY
3086: LIST
3087: PPUSH
3088: CALL_OW 72
3092: AND
3093: IFFALSE 3176
3095: GO 3097
3097: DISABLE
// begin wait ( 0 0$20 ) ;
3098: LD_INT 700
3100: PPUSH
3101: CALL_OW 67
// if see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) then
3105: LD_EXP 23
3109: PUSH
3110: LD_EXP 25
3114: ARRAY
3115: PPUSH
3116: LD_EXP 37
3120: PUSH
3121: LD_EXP 35
3125: ADD
3126: PPUSH
3127: CALL 10546 0 2
3131: PUSH
3132: LD_EXP 37
3136: PUSH
3137: LD_EXP 35
3141: ADD
3142: PPUSH
3143: LD_INT 95
3145: PUSH
3146: LD_EXP 63
3150: PUSH
3151: LD_EXP 25
3155: ARRAY
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PUSH
3161: EMPTY
3162: LIST
3163: PPUSH
3164: CALL_OW 72
3168: AND
3169: IFFALSE 3175
// DA_BaseRefuse ;
3171: CALL 3956 0 0
// enable ;
3175: ENABLE
// end ;
3176: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 12 do
3177: LD_EXP 76
3181: PUSH
3182: LD_EXP 25
3186: ARRAY
3187: PPUSH
3188: LD_INT 3
3190: PUSH
3191: LD_EXP 54
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL_OW 72
3204: PUSH
3205: LD_INT 12
3207: LESS
3208: IFFALSE 3221
3210: GO 3212
3212: DISABLE
// begin DA_BaseRefuse ;
3213: CALL 3956 0 0
// ZoufalUtok ;
3217: CALL 11833 0 0
// end ;
3221: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 10 do
3222: LD_EXP 76
3226: PUSH
3227: LD_EXP 25
3231: ARRAY
3232: PPUSH
3233: LD_INT 3
3235: PUSH
3236: LD_EXP 54
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PPUSH
3245: CALL_OW 72
3249: PUSH
3250: LD_INT 10
3252: LESS
3253: IFFALSE 3266
3255: GO 3257
3257: DISABLE
// begin DA_BaseRefuse ;
3258: CALL 3956 0 0
// BehemothUtok ;
3262: CALL 11659 0 0
// end ;
3266: END
// every 25 25$0 do
3267: GO 3269
3269: DISABLE
// begin BehemothUtok ;
3270: CALL 11659 0 0
// end ;
3274: END
// every 10 10$0 + 0 0$5 do
3275: GO 3277
3277: DISABLE
// begin NormalUtok ;
3278: CALL 12030 0 0
// end ;
3282: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) <= 7 and UnitFilter ( buildings [ plat_i ] , [ f_or , [ f_btype , b_turret ] , [ [ f_occupied ] , mf_fort ] ] ) <= 2 do var kam_zdrha , k_dispozici , mt , kam_telp , h , i , kam_zdrha_i ;
3283: LD_EXP 76
3287: PUSH
3288: LD_EXP 25
3292: ARRAY
3293: PPUSH
3294: LD_INT 3
3296: PUSH
3297: LD_EXP 54
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 72
3310: PUSH
3311: LD_INT 7
3313: LESSEQUAL
3314: PUSH
3315: LD_EXP 75
3319: PUSH
3320: LD_EXP 25
3324: ARRAY
3325: PPUSH
3326: LD_INT 2
3328: PUSH
3329: LD_INT 30
3331: PUSH
3332: LD_INT 33
3334: PUSH
3335: EMPTY
3336: LIST
3337: LIST
3338: PUSH
3339: LD_INT 59
3341: PUSH
3342: EMPTY
3343: LIST
3344: PUSH
3345: LD_EXP 56
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: LIST
3358: PPUSH
3359: CALL_OW 72
3363: PUSH
3364: LD_INT 2
3366: LESSEQUAL
3367: AND
3368: IFFALSE 3953
3370: GO 3372
3372: DISABLE
3373: LD_INT 0
3375: PPUSH
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
3380: PPUSH
3381: PPUSH
// begin k_dispozici := ( ai diff ( ai [ 1 ] ^ your_bases ) ) ;
3382: LD_ADDR_VAR 0 2
3386: PUSH
3387: LD_EXP 24
3391: PUSH
3392: LD_EXP 24
3396: PUSH
3397: LD_INT 1
3399: ARRAY
3400: PUSH
3401: LD_EXP 18
3405: ADD
3406: DIFF
3407: ST_TO_ADDR
// if k_dispozici then
3408: LD_VAR 0 2
3412: IFFALSE 3908
// begin kam_zdrha := ( k_dispozici ) [ Rand ( 1 , k_dispozici ) ] ;
3414: LD_ADDR_VAR 0 1
3418: PUSH
3419: LD_VAR 0 2
3423: PUSH
3424: LD_INT 1
3426: PPUSH
3427: LD_VAR 0 2
3431: PPUSH
3432: CALL_OW 12
3436: ARRAY
3437: ST_TO_ADDR
// case kam_zdrha of ai_s [ 2 ] :
3438: LD_VAR 0 1
3442: PUSH
3443: LD_EXP 23
3447: PUSH
3448: LD_INT 2
3450: ARRAY
3451: DOUBLE
3452: EQUAL
3453: IFTRUE 3457
3455: GO 3468
3457: POP
// kam_telp := b_base ; ai_s [ 3 ] :
3458: LD_ADDR_VAR 0 4
3462: PUSH
3463: LD_INT 20
3465: ST_TO_ADDR
3466: GO 3544
3468: LD_EXP 23
3472: PUSH
3473: LD_INT 3
3475: ARRAY
3476: DOUBLE
3477: EQUAL
3478: IFTRUE 3482
3480: GO 3493
3482: POP
// kam_telp := c_base ; ai_s [ 4 ] :
3483: LD_ADDR_VAR 0 4
3487: PUSH
3488: LD_INT 23
3490: ST_TO_ADDR
3491: GO 3544
3493: LD_EXP 23
3497: PUSH
3498: LD_INT 4
3500: ARRAY
3501: DOUBLE
3502: EQUAL
3503: IFTRUE 3507
3505: GO 3518
3507: POP
// kam_telp := d_base ; ai_s [ 5 ] :
3508: LD_ADDR_VAR 0 4
3512: PUSH
3513: LD_INT 22
3515: ST_TO_ADDR
3516: GO 3544
3518: LD_EXP 23
3522: PUSH
3523: LD_INT 5
3525: ARRAY
3526: DOUBLE
3527: EQUAL
3528: IFTRUE 3532
3530: GO 3543
3532: POP
// kam_telp := e_base ; end ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: LD_INT 21
3540: ST_TO_ADDR
3541: GO 3544
3543: POP
// repeat h := RandHexArea ( kam_telp , false ) ;
3544: LD_ADDR_VAR 0 5
3548: PUSH
3549: LD_VAR 0 4
3553: PPUSH
3554: LD_INT 0
3556: PPUSH
3557: CALL_OW 16
3561: ST_TO_ADDR
// until HexInfo ( h [ 1 ] , h [ 2 ] ) = 0 ;
3562: LD_VAR 0 5
3566: PUSH
3567: LD_INT 1
3569: ARRAY
3570: PPUSH
3571: LD_VAR 0 5
3575: PUSH
3576: LD_INT 2
3578: ARRAY
3579: PPUSH
3580: CALL_OW 428
3584: PUSH
3585: LD_INT 0
3587: EQUAL
3588: IFFALSE 3544
// TeleportExit ( telp1 , h [ 1 ] , h [ 2 ] ) ;
3590: LD_INT 15
3592: PPUSH
3593: LD_VAR 0 5
3597: PUSH
3598: LD_INT 1
3600: ARRAY
3601: PPUSH
3602: LD_VAR 0 5
3606: PUSH
3607: LD_INT 2
3609: ARRAY
3610: PPUSH
3611: CALL_OW 243
// ComExitVehicle ( Platonov ) ;
3615: LD_EXP 42
3619: PPUSH
3620: CALL_OW 121
// AddComExitBuilding ( Platonov ) ;
3624: LD_EXP 42
3628: PPUSH
3629: CALL_OW 182
// AddComEnterUnit ( Platonov , telp1 ) ;
3633: LD_EXP 42
3637: PPUSH
3638: LD_INT 15
3640: PPUSH
3641: CALL_OW 180
// for i := 1 to 5 do
3645: LD_ADDR_VAR 0 6
3649: PUSH
3650: DOUBLE
3651: LD_INT 1
3653: DEC
3654: ST_TO_ADDR
3655: LD_INT 5
3657: PUSH
3658: FOR_TO
3659: IFFALSE 3691
// if ai_s [ i ] = kam_zdrha then
3661: LD_EXP 23
3665: PUSH
3666: LD_VAR 0 6
3670: ARRAY
3671: PUSH
3672: LD_VAR 0 1
3676: EQUAL
3677: IFFALSE 3689
// kam_zdrha_i := i ;
3679: LD_ADDR_VAR 0 7
3683: PUSH
3684: LD_VAR 0 6
3688: ST_TO_ADDR
3689: GO 3658
3691: POP
3692: POP
// plat_i := kam_zdrha_i ;
3693: LD_ADDR_EXP 25
3697: PUSH
3698: LD_VAR 0 7
3702: ST_TO_ADDR
// ai_s := replace ( ai_s , kam_zdrha_i , ai_s [ 1 ] ) ;
3703: LD_ADDR_EXP 23
3707: PUSH
3708: LD_EXP 23
3712: PPUSH
3713: LD_VAR 0 7
3717: PPUSH
3718: LD_EXP 23
3722: PUSH
3723: LD_INT 1
3725: ARRAY
3726: PPUSH
3727: CALL_OW 1
3731: ST_TO_ADDR
// wait ( 0 0$5 ) ;
3732: LD_INT 175
3734: PPUSH
3735: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3739: LD_EXP 42
3743: PPUSH
3744: LD_EXP 74
3748: PUSH
3749: LD_VAR 0 7
3753: ARRAY
3754: PPUSH
3755: CALL_OW 180
// DA_BaseAccept ;
3759: CALL 4006 0 0
// SurrenderBase ( t_killbeat , ai_s [ plat_i ] ) ;
3763: LD_EXP 6
3767: PPUSH
3768: LD_EXP 23
3772: PUSH
3773: LD_EXP 25
3777: ARRAY
3778: PPUSH
3779: CALL 30313 0 2
// SetAttitude ( ai_s [ plat_i ] , you , att_enemy , true ) ;
3783: LD_EXP 23
3787: PUSH
3788: LD_EXP 25
3792: ARRAY
3793: PPUSH
3794: LD_EXP 7
3798: PPUSH
3799: LD_INT 2
3801: PPUSH
3802: LD_INT 1
3804: PPUSH
3805: CALL_OW 80
// SetSideBase_custom ( GetBase ( depots [ plat_i ] ) , ai_s [ plat_i ] ) ;
3809: LD_EXP 74
3813: PUSH
3814: LD_EXP 25
3818: ARRAY
3819: PPUSH
3820: CALL_OW 274
3824: PPUSH
3825: LD_EXP 23
3829: PUSH
3830: LD_EXP 25
3834: ARRAY
3835: PPUSH
3836: CALL 32718 0 2
// SetSide ( FilterAllUnits ( [ [ f_side , kam_zdrha ] ] ) , ai_s [ plat_i ] ) ;
3840: LD_INT 22
3842: PUSH
3843: LD_VAR 0 1
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: EMPTY
3853: LIST
3854: PPUSH
3855: CALL_OW 69
3859: PPUSH
3860: LD_EXP 23
3864: PUSH
3865: LD_EXP 25
3869: ARRAY
3870: PPUSH
3871: CALL_OW 235
// wait ( 1 1$0 ) ;
3875: LD_INT 2100
3877: PPUSH
3878: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3882: LD_EXP 42
3886: PPUSH
3887: LD_EXP 74
3891: PUSH
3892: LD_VAR 0 7
3896: ARRAY
3897: PPUSH
3898: CALL_OW 180
// ZoufalUtok ;
3902: CALL 11833 0 0
// end else
3906: GO 3953
// begin while not IsDead ( Platonov ) do
3908: LD_EXP 42
3912: PPUSH
3913: CALL_OW 301
3917: NOT
3918: IFFALSE 3953
// begin ComAttackUnit ( Platonov , NearestUnitToUnit ( your_humans , Platonov ) ) ;
3920: LD_EXP 42
3924: PPUSH
3925: LD_EXP 37
3929: PPUSH
3930: LD_EXP 42
3934: PPUSH
3935: CALL_OW 74
3939: PPUSH
3940: CALL_OW 115
// wait ( 0 0$5 ) ;
3944: LD_INT 175
3946: PPUSH
3947: CALL_OW 67
// end ;
3951: GO 3908
// end ; end ;
3953: PPOPN 7
3955: END
// export function DA_BaseRefuse ; begin
3956: LD_INT 0
3958: PPUSH
// DialogueOn ;
3959: CALL_OW 6
// if not IsDead ( Pla ) then
3963: LD_LOC 3
3967: PPUSH
3968: CALL_OW 301
3972: NOT
3973: IFFALSE 3997
// if not Say ( Pla , DA-BaseReguse-Pla-1 ) then
3975: LD_LOC 3
3979: PPUSH
3980: LD_STRING DA-BaseReguse-Pla-1
3982: PPUSH
3983: CALL_OW 88
3987: NOT
3988: IFFALSE 3997
// msg ( bad ident: DA-BaseReguse-Pla-1 ) ;
3990: LD_STRING bad ident: DA-BaseReguse-Pla-1
3992: PPUSH
3993: CALL_OW 100
// DialogueOff ;
3997: CALL_OW 7
// end ;
4001: LD_VAR 0 1
4005: RET
// export function DA_BaseAccept ; begin
4006: LD_INT 0
4008: PPUSH
// DialogueOn ;
4009: CALL_OW 6
// Say ( Pla , DA-BaseAccept-Pla-1 ) ;
4013: LD_LOC 3
4017: PPUSH
4018: LD_STRING DA-BaseAccept-Pla-1
4020: PPUSH
4021: CALL_OW 88
// DialogueOff ;
4025: CALL_OW 7
// end ;
4029: LD_VAR 0 1
4033: RET
// every 0 0$2 trigger See ( you , behemoth ) do
4034: LD_EXP 7
4038: PPUSH
4039: LD_INT 125
4041: PPUSH
4042: CALL_OW 292
4046: IFFALSE 4079
4048: GO 4050
4050: DISABLE
// begin if See ( you , behemoth ) then
4051: LD_EXP 7
4055: PPUSH
4056: LD_INT 125
4058: PPUSH
4059: CALL_OW 292
4063: IFFALSE 4078
// begin CenterNowOnUnits ( behemoth ) ;
4065: LD_INT 125
4067: PPUSH
4068: CALL_OW 87
// DBehemoth end else
4072: CALL 4080 0 0
4076: GO 4079
// enable ;
4078: ENABLE
// end ;
4079: END
// export function DBehemoth ; var who ; begin
4080: LD_INT 0
4082: PPUSH
4083: PPUSH
// who := WhoSayAny ( your_humans diff talking , you , sex_male , 0 , 0 ) ;
4084: LD_ADDR_VAR 0 2
4088: PUSH
4089: LD_EXP 37
4093: PUSH
4094: LD_LOC 11
4098: DIFF
4099: PPUSH
4100: LD_EXP 7
4104: PPUSH
4105: LD_INT 1
4107: PPUSH
4108: LD_INT 0
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL 10352 0 5
4118: ST_TO_ADDR
// BehemothSeen := true ;
4119: LD_ADDR_EXP 29
4123: PUSH
4124: LD_INT 1
4126: ST_TO_ADDR
// DialogueOn ;
4127: CALL_OW 6
// Say ( who , DBehemoth-Rsol1-1 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING DBehemoth-Rsol1-1
4138: PPUSH
4139: CALL_OW 88
// Say ( Pla , DBehemoth-Pla-1 ) ;
4143: LD_LOC 3
4147: PPUSH
4148: LD_STRING DBehemoth-Pla-1
4150: PPUSH
4151: CALL_OW 88
// Say ( Bur , DBehemoth-Bur-1 ) ;
4155: LD_LOC 2
4159: PPUSH
4160: LD_STRING DBehemoth-Bur-1
4162: PPUSH
4163: CALL_OW 88
// DialogueOff ;
4167: CALL_OW 7
// end ;
4171: LD_VAR 0 1
4175: RET
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] do
4176: LD_LOC 2
4180: PPUSH
4181: LD_INT 20
4183: PPUSH
4184: CALL_OW 308
4188: PUSH
4189: LD_EXP 23
4193: PUSH
4194: LD_INT 1
4196: ARRAY
4197: PUSH
4198: LD_EXP 23
4202: PUSH
4203: LD_INT 2
4205: ARRAY
4206: NONEQUAL
4207: AND
4208: IFFALSE 4288
4210: GO 4212
4212: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4213: LD_EXP 37
4217: PUSH
4218: LD_INT 12
4220: LESS
4221: PUSH
4222: LD_EXP 35
4226: PUSH
4227: LD_INT 20
4229: LESS
4230: AND
4231: IFFALSE 4253
// begin DB_BaseContact ;
4233: CALL 4492 0 0
// DB_BaseRefuse1st ;
4237: CALL 4520 0 0
// wait ( 0 0$30 ) ;
4241: LD_INT 1050
4243: PPUSH
4244: CALL_OW 67
// enable ( 10 ) ;
4248: LD_INT 10
4250: ENABLE_MARKED
// end else
4251: GO 4288
// begin if not ai_s [ 2 ] in your_bases then
4253: LD_EXP 23
4257: PUSH
4258: LD_INT 2
4260: ARRAY
4261: PUSH
4262: LD_EXP 18
4266: IN
4267: NOT
4268: IFFALSE 4288
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4270: LD_EXP 2
4274: PPUSH
4275: LD_EXP 23
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: CALL 30313 0 2
// end ; end ; end ;
4288: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] marked 10 do
4289: LD_LOC 2
4293: PPUSH
4294: LD_INT 20
4296: PPUSH
4297: CALL_OW 308
4301: PUSH
4302: LD_EXP 23
4306: PUSH
4307: LD_INT 1
4309: ARRAY
4310: PUSH
4311: LD_EXP 23
4315: PUSH
4316: LD_INT 2
4318: ARRAY
4319: NONEQUAL
4320: AND
4321: IFFALSE 4418
4323: GO 4325
4325: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4326: LD_EXP 37
4330: PUSH
4331: LD_INT 12
4333: LESS
4334: PUSH
4335: LD_EXP 35
4339: PUSH
4340: LD_INT 20
4342: LESS
4343: AND
4344: IFFALSE 4383
// begin DB_BaseRefuse ;
4346: CALL 4548 0 0
// while IsInArea ( Bur , b_base ) do
4350: LD_LOC 2
4354: PPUSH
4355: LD_INT 20
4357: PPUSH
4358: CALL_OW 308
4362: IFFALSE 4373
// wait ( 0 0$1 ) ;
4364: LD_INT 35
4366: PPUSH
4367: CALL_OW 67
4371: GO 4350
// wait ( 0 0$20 ) ;
4373: LD_INT 700
4375: PPUSH
4376: CALL_OW 67
// enable ;
4380: ENABLE
// end else
4381: GO 4418
// begin if not ai_s [ 2 ] in your_bases then
4383: LD_EXP 23
4387: PUSH
4388: LD_INT 2
4390: ARRAY
4391: PUSH
4392: LD_EXP 18
4396: IN
4397: NOT
4398: IFFALSE 4418
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4400: LD_EXP 2
4404: PPUSH
4405: LD_EXP 23
4409: PUSH
4410: LD_INT 2
4412: ARRAY
4413: PPUSH
4414: CALL 30313 0 2
// end ; end ; end ;
4418: END
// every 0 0$2 trigger humans [ 2 ] <= 6 and ai_s [ 1 ] <> ai_s [ 2 ] do
4419: LD_EXP 76
4423: PUSH
4424: LD_INT 2
4426: ARRAY
4427: PUSH
4428: LD_INT 6
4430: LESSEQUAL
4431: PUSH
4432: LD_EXP 23
4436: PUSH
4437: LD_INT 1
4439: ARRAY
4440: PUSH
4441: LD_EXP 23
4445: PUSH
4446: LD_INT 2
4448: ARRAY
4449: NONEQUAL
4450: AND
4451: IFFALSE 4491
4453: GO 4455
4455: DISABLE
// begin if not ai_s [ 2 ] in your_bases then
4456: LD_EXP 23
4460: PUSH
4461: LD_INT 2
4463: ARRAY
4464: PUSH
4465: LD_EXP 18
4469: IN
4470: NOT
4471: IFFALSE 4491
// SurrenderBase ( t_killbeat , ai_s [ 2 ] ) ;
4473: LD_EXP 6
4477: PPUSH
4478: LD_EXP 23
4482: PUSH
4483: LD_INT 2
4485: ARRAY
4486: PPUSH
4487: CALL 30313 0 2
// end ;
4491: END
// export function DB_BaseContact ; begin
4492: LD_INT 0
4494: PPUSH
// DialogueOn ;
4495: CALL_OW 6
// Say ( Bor , DB-BaseContact-Bor-1 ) ;
4499: LD_LOC 6
4503: PPUSH
4504: LD_STRING DB-BaseContact-Bor-1
4506: PPUSH
4507: CALL_OW 88
// DialogueOff ;
4511: CALL_OW 7
// end ;
4515: LD_VAR 0 1
4519: RET
// export function DB_BaseRefuse1st ; begin
4520: LD_INT 0
4522: PPUSH
// DialogueOn ;
4523: CALL_OW 6
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4527: LD_LOC 6
4531: PPUSH
4532: LD_STRING DB-BaseRefuse-Bor-1
4534: PPUSH
4535: CALL_OW 88
// DialogueOff ;
4539: CALL_OW 7
// end ;
4543: LD_VAR 0 1
4547: RET
// export function DB_BaseRefuse ; begin
4548: LD_INT 0
4550: PPUSH
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4551: LD_LOC 6
4555: PPUSH
4556: LD_STRING DB-BaseRefuse-Bor-1
4558: PPUSH
4559: CALL_OW 88
// end ;
4563: LD_VAR 0 1
4567: RET
// export function DB_BaseAccept ( first ) ; begin
4568: LD_INT 0
4570: PPUSH
// DialogueOn ;
4571: CALL_OW 6
// Say ( Bor , DB-BaseAccept-Bor-1 ) ;
4575: LD_LOC 6
4579: PPUSH
4580: LD_STRING DB-BaseAccept-Bor-1
4582: PPUSH
4583: CALL_OW 88
// if first then
4587: LD_VAR 0 1
4591: IFFALSE 4607
// Say ( Bor , DB-BaseAccept-Bor-1a ) else
4593: LD_LOC 6
4597: PPUSH
4598: LD_STRING DB-BaseAccept-Bor-1a
4600: PPUSH
4601: CALL_OW 88
4605: GO 4619
// Say ( Bor , DB-BaseAccept-Bor-1b ) ;
4607: LD_LOC 6
4611: PPUSH
4612: LD_STRING DB-BaseAccept-Bor-1b
4614: PPUSH
4615: CALL_OW 88
// DialogueOff ;
4619: CALL_OW 7
// end ;
4623: LD_VAR 0 2
4627: RET
// var jeste_nebylo ; every 0 0$2 trigger IsInArea ( Bur , c_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
4628: LD_LOC 2
4632: PPUSH
4633: LD_INT 23
4635: PPUSH
4636: CALL_OW 308
4640: PUSH
4641: LD_EXP 23
4645: PUSH
4646: LD_INT 1
4648: ARRAY
4649: PUSH
4650: LD_EXP 23
4654: PUSH
4655: LD_INT 4
4657: ARRAY
4658: NONEQUAL
4659: AND
4660: IFFALSE 4757
4662: GO 4664
4664: DISABLE
// begin jeste_nebylo := [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
4665: LD_ADDR_LOC 12
4669: PUSH
4670: LD_INT 1
4672: PUSH
4673: LD_INT 2
4675: PUSH
4676: LD_INT 3
4678: PUSH
4679: LD_INT 4
4681: PUSH
4682: LD_INT 5
4684: PUSH
4685: LD_INT 6
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: LIST
4693: LIST
4694: LIST
4695: ST_TO_ADDR
// DC_BaseContact ;
4696: CALL 5452 0 0
// if otazky then
4700: CALL 4877 0 0
4704: IFFALSE 4757
// if not ai_s [ 3 ] in your_bases then
4706: LD_EXP 23
4710: PUSH
4711: LD_INT 3
4713: ARRAY
4714: PUSH
4715: LD_EXP 18
4719: IN
4720: NOT
4721: IFFALSE 4743
// SurrenderBase ( t_persuade , ai_s [ 3 ] ) else
4723: LD_EXP 3
4727: PPUSH
4728: LD_EXP 23
4732: PUSH
4733: LD_INT 3
4735: ARRAY
4736: PPUSH
4737: CALL 30313 0 2
4741: GO 4757
// begin DQrML_Wrong ;
4743: CALL 6792 0 0
// wait ( 0 0$30 ) ;
4747: LD_INT 1050
4749: PPUSH
4750: CALL_OW 67
// enable ( 11 ) ;
4754: LD_INT 11
4756: ENABLE_MARKED
// end ; end ;
4757: END
// every 0 0$2 trigger IsInArea ( Bur , c_base ) marked 11 do
4758: LD_LOC 2
4762: PPUSH
4763: LD_INT 23
4765: PPUSH
4766: CALL_OW 308
4770: IFFALSE 4803
4772: GO 4774
4774: DISABLE
// begin if not otazky then
4775: CALL 4877 0 0
4779: NOT
4780: IFFALSE 4785
// enable else
4782: ENABLE
4783: GO 4803
// SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4785: LD_EXP 2
4789: PPUSH
4790: LD_EXP 23
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: CALL 30313 0 2
// end ;
4803: END
// every 0 0$2 trigger humans [ 3 ] <= 2 and ai_s [ 1 ] <> ai_s [ 4 ] do
4804: LD_EXP 76
4808: PUSH
4809: LD_INT 3
4811: ARRAY
4812: PUSH
4813: LD_INT 2
4815: LESSEQUAL
4816: PUSH
4817: LD_EXP 23
4821: PUSH
4822: LD_INT 1
4824: ARRAY
4825: PUSH
4826: LD_EXP 23
4830: PUSH
4831: LD_INT 4
4833: ARRAY
4834: NONEQUAL
4835: AND
4836: IFFALSE 4876
4838: GO 4840
4840: DISABLE
// begin if not ai_s [ 3 ] in your_bases then
4841: LD_EXP 23
4845: PUSH
4846: LD_INT 3
4848: ARRAY
4849: PUSH
4850: LD_EXP 18
4854: IN
4855: NOT
4856: IFFALSE 4876
// SurrenderBase ( t_killbeat , ai_s [ 3 ] ) ;
4858: LD_EXP 6
4862: PPUSH
4863: LD_EXP 23
4867: PUSH
4868: LD_INT 3
4870: ARRAY
4871: PPUSH
4872: CALL 30313 0 2
// end ;
4876: END
// function otazky ; var qb , qg , q ; begin
4877: LD_INT 0
4879: PPUSH
4880: PPUSH
4881: PPUSH
4882: PPUSH
// DC_BaseQuestion ;
4883: CALL 5480 0 0
// qb := 0 ;
4887: LD_ADDR_VAR 0 2
4891: PUSH
4892: LD_INT 0
4894: ST_TO_ADDR
// qg := 0 ;
4895: LD_ADDR_VAR 0 3
4899: PUSH
4900: LD_INT 0
4902: ST_TO_ADDR
// q := 0 ;
4903: LD_ADDR_VAR 0 4
4907: PUSH
4908: LD_INT 0
4910: ST_TO_ADDR
// while [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] and jeste_nebylo do
4911: LD_VAR 0 2
4915: PUSH
4916: LD_INT 2
4918: LESSEQUAL
4919: PUSH
4920: LD_VAR 0 2
4924: PUSH
4925: LD_INT 1
4927: LESSEQUAL
4928: PUSH
4929: LD_VAR 0 2
4933: PUSH
4934: LD_INT 0
4936: LESSEQUAL
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: PUSH
4943: LD_OWVAR 67
4947: ARRAY
4948: PUSH
4949: LD_LOC 12
4953: AND
4954: IFFALSE 5376
// begin q := q + 1 ;
4956: LD_ADDR_VAR 0 4
4960: PUSH
4961: LD_VAR 0 4
4965: PUSH
4966: LD_INT 1
4968: PLUS
4969: ST_TO_ADDR
// case jeste_nebylo [ Rand ( 1 , jeste_nebylo ) ] of 1 :
4970: LD_LOC 12
4974: PUSH
4975: LD_INT 1
4977: PPUSH
4978: LD_LOC 12
4982: PPUSH
4983: CALL_OW 12
4987: ARRAY
4988: PUSH
4989: LD_INT 1
4991: DOUBLE
4992: EQUAL
4993: IFTRUE 4997
4995: GO 5053
4997: POP
// begin if QML1 then
4998: CALL 5508 0 0
5002: IFFALSE 5020
// qg := qg + 1 else
5004: LD_ADDR_VAR 0 3
5008: PUSH
5009: LD_VAR 0 3
5013: PUSH
5014: LD_INT 1
5016: PLUS
5017: ST_TO_ADDR
5018: GO 5034
// qb := qb + 1 ;
5020: LD_ADDR_VAR 0 2
5024: PUSH
5025: LD_VAR 0 2
5029: PUSH
5030: LD_INT 1
5032: PLUS
5033: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 1 ] ;
5034: LD_ADDR_LOC 12
5038: PUSH
5039: LD_LOC 12
5043: PUSH
5044: LD_INT 1
5046: PUSH
5047: EMPTY
5048: LIST
5049: DIFF
5050: ST_TO_ADDR
// end ; 2 :
5051: GO 5374
5053: LD_INT 2
5055: DOUBLE
5056: EQUAL
5057: IFTRUE 5061
5059: GO 5117
5061: POP
// begin if QML2 then
5062: CALL 5712 0 0
5066: IFFALSE 5084
// qg := qg + 1 else
5068: LD_ADDR_VAR 0 3
5072: PUSH
5073: LD_VAR 0 3
5077: PUSH
5078: LD_INT 1
5080: PLUS
5081: ST_TO_ADDR
5082: GO 5098
// qb := qb + 1 ;
5084: LD_ADDR_VAR 0 2
5088: PUSH
5089: LD_VAR 0 2
5093: PUSH
5094: LD_INT 1
5096: PLUS
5097: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 2 ] ;
5098: LD_ADDR_LOC 12
5102: PUSH
5103: LD_LOC 12
5107: PUSH
5108: LD_INT 2
5110: PUSH
5111: EMPTY
5112: LIST
5113: DIFF
5114: ST_TO_ADDR
// end ; 3 :
5115: GO 5374
5117: LD_INT 3
5119: DOUBLE
5120: EQUAL
5121: IFTRUE 5125
5123: GO 5181
5125: POP
// begin if QML3 then
5126: CALL 5916 0 0
5130: IFFALSE 5148
// qg := qg + 1 else
5132: LD_ADDR_VAR 0 3
5136: PUSH
5137: LD_VAR 0 3
5141: PUSH
5142: LD_INT 1
5144: PLUS
5145: ST_TO_ADDR
5146: GO 5162
// qb := qb + 1 ;
5148: LD_ADDR_VAR 0 2
5152: PUSH
5153: LD_VAR 0 2
5157: PUSH
5158: LD_INT 1
5160: PLUS
5161: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 3 ] ;
5162: LD_ADDR_LOC 12
5166: PUSH
5167: LD_LOC 12
5171: PUSH
5172: LD_INT 3
5174: PUSH
5175: EMPTY
5176: LIST
5177: DIFF
5178: ST_TO_ADDR
// end ; 4 :
5179: GO 5374
5181: LD_INT 4
5183: DOUBLE
5184: EQUAL
5185: IFTRUE 5189
5187: GO 5245
5189: POP
// begin if QML4 then
5190: CALL 6120 0 0
5194: IFFALSE 5212
// qg := qg + 1 else
5196: LD_ADDR_VAR 0 3
5200: PUSH
5201: LD_VAR 0 3
5205: PUSH
5206: LD_INT 1
5208: PLUS
5209: ST_TO_ADDR
5210: GO 5226
// qb := qb + 1 ;
5212: LD_ADDR_VAR 0 2
5216: PUSH
5217: LD_VAR 0 2
5221: PUSH
5222: LD_INT 1
5224: PLUS
5225: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 4 ] ;
5226: LD_ADDR_LOC 12
5230: PUSH
5231: LD_LOC 12
5235: PUSH
5236: LD_INT 4
5238: PUSH
5239: EMPTY
5240: LIST
5241: DIFF
5242: ST_TO_ADDR
// end ; 5 :
5243: GO 5374
5245: LD_INT 5
5247: DOUBLE
5248: EQUAL
5249: IFTRUE 5253
5251: GO 5309
5253: POP
// begin if QML5 then
5254: CALL 6324 0 0
5258: IFFALSE 5276
// qg := qg + 1 else
5260: LD_ADDR_VAR 0 3
5264: PUSH
5265: LD_VAR 0 3
5269: PUSH
5270: LD_INT 1
5272: PLUS
5273: ST_TO_ADDR
5274: GO 5290
// qb := qb + 1 ;
5276: LD_ADDR_VAR 0 2
5280: PUSH
5281: LD_VAR 0 2
5285: PUSH
5286: LD_INT 1
5288: PLUS
5289: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 5 ] ;
5290: LD_ADDR_LOC 12
5294: PUSH
5295: LD_LOC 12
5299: PUSH
5300: LD_INT 5
5302: PUSH
5303: EMPTY
5304: LIST
5305: DIFF
5306: ST_TO_ADDR
// end ; 6 :
5307: GO 5374
5309: LD_INT 6
5311: DOUBLE
5312: EQUAL
5313: IFTRUE 5317
5315: GO 5373
5317: POP
// begin if QML6 then
5318: CALL 6528 0 0
5322: IFFALSE 5340
// qg := qg + 1 else
5324: LD_ADDR_VAR 0 3
5328: PUSH
5329: LD_VAR 0 3
5333: PUSH
5334: LD_INT 1
5336: PLUS
5337: ST_TO_ADDR
5338: GO 5354
// qb := qb + 1 ;
5340: LD_ADDR_VAR 0 2
5344: PUSH
5345: LD_VAR 0 2
5349: PUSH
5350: LD_INT 1
5352: PLUS
5353: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 6 ] ;
5354: LD_ADDR_LOC 12
5358: PUSH
5359: LD_LOC 12
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: EMPTY
5368: LIST
5369: DIFF
5370: ST_TO_ADDR
// end ; end ;
5371: GO 5374
5373: POP
// end ;
5374: GO 4911
// if qg = 6 then
5376: LD_VAR 0 3
5380: PUSH
5381: LD_INT 6
5383: EQUAL
5384: IFFALSE 5390
// SA_OnTsaritsynQuizPerfectCleared ;
5386: CALL 33111 0 0
// if [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] then
5390: LD_VAR 0 2
5394: PUSH
5395: LD_INT 2
5397: LESSEQUAL
5398: PUSH
5399: LD_VAR 0 2
5403: PUSH
5404: LD_INT 1
5406: LESSEQUAL
5407: PUSH
5408: LD_VAR 0 2
5412: PUSH
5413: LD_INT 0
5415: LESSEQUAL
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: LIST
5421: PUSH
5422: LD_OWVAR 67
5426: ARRAY
5427: IFFALSE 5439
// result := true else
5429: LD_ADDR_VAR 0 1
5433: PUSH
5434: LD_INT 1
5436: ST_TO_ADDR
5437: GO 5447
// result := false ;
5439: LD_ADDR_VAR 0 1
5443: PUSH
5444: LD_INT 0
5446: ST_TO_ADDR
// end ;
5447: LD_VAR 0 1
5451: RET
// export function DC_BaseContact ; begin
5452: LD_INT 0
5454: PPUSH
// DialogueOn ;
5455: CALL_OW 6
// Say ( Tsr , DC-BaseContact-Tsr-1 ) ;
5459: LD_LOC 7
5463: PPUSH
5464: LD_STRING DC-BaseContact-Tsr-1
5466: PPUSH
5467: CALL_OW 88
// DialogueOff ;
5471: CALL_OW 7
// end ;
5475: LD_VAR 0 1
5479: RET
// export function DC_BaseQuestion ; begin
5480: LD_INT 0
5482: PPUSH
// DialogueOn ;
5483: CALL_OW 6
// Say ( Tsr , DC-BaseQuestion-Tsr-1 ) ;
5487: LD_LOC 7
5491: PPUSH
5492: LD_STRING DC-BaseQuestion-Tsr-1
5494: PPUSH
5495: CALL_OW 88
// DialogueOff ;
5499: CALL_OW 7
// end ;
5503: LD_VAR 0 1
5507: RET
// function QML1 ; var mozn , qr , a , bad ; begin
5508: LD_INT 0
5510: PPUSH
5511: PPUSH
5512: PPUSH
5513: PPUSH
5514: PPUSH
// bad := [ 1 , 3 ] ;
5515: LD_ADDR_VAR 0 5
5519: PUSH
5520: LD_INT 1
5522: PUSH
5523: LD_INT 3
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5530: LD_ADDR_VAR 0 2
5534: PUSH
5535: LD_INT 1
5537: PUSH
5538: LD_INT 2
5540: PUSH
5541: LD_INT 3
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: LIST
5548: ST_TO_ADDR
// if IsOk ( Gleb ) then
5549: LD_EXP 50
5553: PPUSH
5554: CALL_OW 302
5558: IFFALSE 5577
// mozn := mozn ^ [ 4 ] ;
5560: LD_ADDR_VAR 0 2
5564: PUSH
5565: LD_VAR 0 2
5569: PUSH
5570: LD_INT 4
5572: PUSH
5573: EMPTY
5574: LIST
5575: ADD
5576: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5577: LD_ADDR_VAR 0 3
5581: PUSH
5582: LD_STRING QML1
5584: PPUSH
5585: LD_VAR 0 2
5589: PPUSH
5590: CALL_OW 98
5594: ST_TO_ADDR
// if qr = 4 then
5595: LD_VAR 0 3
5599: PUSH
5600: LD_INT 4
5602: EQUAL
5603: IFFALSE 5677
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5605: LD_ADDR_VAR 0 4
5609: PUSH
5610: LD_VAR 0 5
5614: PUSH
5615: LD_INT 1
5617: PPUSH
5618: LD_INT 2
5620: PPUSH
5621: CALL_OW 12
5625: ARRAY
5626: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5627: LD_VAR 0 4
5631: PPUSH
5632: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
5636: LD_ADDR_VAR 0 2
5640: PUSH
5641: LD_VAR 0 2
5645: PUSH
5646: LD_VAR 0 4
5650: PUSH
5651: LD_INT 4
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: DIFF
5658: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5659: LD_ADDR_VAR 0 3
5663: PUSH
5664: LD_STRING QML1
5666: PPUSH
5667: LD_VAR 0 2
5671: PPUSH
5672: CALL_OW 98
5676: ST_TO_ADDR
// end ; if qr in bad then
5677: LD_VAR 0 3
5681: PUSH
5682: LD_VAR 0 5
5686: IN
5687: IFFALSE 5699
// result := false else
5689: LD_ADDR_VAR 0 1
5693: PUSH
5694: LD_INT 0
5696: ST_TO_ADDR
5697: GO 5707
// result := true ;
5699: LD_ADDR_VAR 0 1
5703: PUSH
5704: LD_INT 1
5706: ST_TO_ADDR
// end ;
5707: LD_VAR 0 1
5711: RET
// function QML2 ; var mozn , qr , a , bad ; begin
5712: LD_INT 0
5714: PPUSH
5715: PPUSH
5716: PPUSH
5717: PPUSH
5718: PPUSH
// bad := [ 2 , 3 ] ;
5719: LD_ADDR_VAR 0 5
5723: PUSH
5724: LD_INT 2
5726: PUSH
5727: LD_INT 3
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5734: LD_ADDR_VAR 0 2
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 3
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: ST_TO_ADDR
// if IsOk ( Gleb ) then
5753: LD_EXP 50
5757: PPUSH
5758: CALL_OW 302
5762: IFFALSE 5781
// mozn := mozn ^ [ 4 ] ;
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: LD_VAR 0 2
5773: PUSH
5774: LD_INT 4
5776: PUSH
5777: EMPTY
5778: LIST
5779: ADD
5780: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_STRING QML2
5788: PPUSH
5789: LD_VAR 0 2
5793: PPUSH
5794: CALL_OW 98
5798: ST_TO_ADDR
// if qr = 4 then
5799: LD_VAR 0 3
5803: PUSH
5804: LD_INT 4
5806: EQUAL
5807: IFFALSE 5881
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5809: LD_ADDR_VAR 0 4
5813: PUSH
5814: LD_VAR 0 5
5818: PUSH
5819: LD_INT 1
5821: PPUSH
5822: LD_INT 2
5824: PPUSH
5825: CALL_OW 12
5829: ARRAY
5830: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5831: LD_VAR 0 4
5835: PPUSH
5836: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
5840: LD_ADDR_VAR 0 2
5844: PUSH
5845: LD_VAR 0 2
5849: PUSH
5850: LD_VAR 0 4
5854: PUSH
5855: LD_INT 4
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: DIFF
5862: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5863: LD_ADDR_VAR 0 3
5867: PUSH
5868: LD_STRING QML2
5870: PPUSH
5871: LD_VAR 0 2
5875: PPUSH
5876: CALL_OW 98
5880: ST_TO_ADDR
// end ; if qr in bad then
5881: LD_VAR 0 3
5885: PUSH
5886: LD_VAR 0 5
5890: IN
5891: IFFALSE 5903
// result := false else
5893: LD_ADDR_VAR 0 1
5897: PUSH
5898: LD_INT 0
5900: ST_TO_ADDR
5901: GO 5911
// result := true ;
5903: LD_ADDR_VAR 0 1
5907: PUSH
5908: LD_INT 1
5910: ST_TO_ADDR
// end ;
5911: LD_VAR 0 1
5915: RET
// function QML3 ; var mozn , qr , a , bad ; begin
5916: LD_INT 0
5918: PPUSH
5919: PPUSH
5920: PPUSH
5921: PPUSH
5922: PPUSH
// bad := [ 1 , 3 ] ;
5923: LD_ADDR_VAR 0 5
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 3
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5938: LD_ADDR_VAR 0 2
5942: PUSH
5943: LD_INT 1
5945: PUSH
5946: LD_INT 2
5948: PUSH
5949: LD_INT 3
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: ST_TO_ADDR
// if IsOk ( Gleb ) then
5957: LD_EXP 50
5961: PPUSH
5962: CALL_OW 302
5966: IFFALSE 5985
// mozn := mozn ^ [ 4 ] ;
5968: LD_ADDR_VAR 0 2
5972: PUSH
5973: LD_VAR 0 2
5977: PUSH
5978: LD_INT 4
5980: PUSH
5981: EMPTY
5982: LIST
5983: ADD
5984: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
5985: LD_ADDR_VAR 0 3
5989: PUSH
5990: LD_STRING QML3
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 98
6002: ST_TO_ADDR
// if qr = 4 then
6003: LD_VAR 0 3
6007: PUSH
6008: LD_INT 4
6010: EQUAL
6011: IFFALSE 6085
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6013: LD_ADDR_VAR 0 4
6017: PUSH
6018: LD_VAR 0 5
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6035: LD_VAR 0 4
6039: PPUSH
6040: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
6044: LD_ADDR_VAR 0 2
6048: PUSH
6049: LD_VAR 0 2
6053: PUSH
6054: LD_VAR 0 4
6058: PUSH
6059: LD_INT 4
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: DIFF
6066: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6067: LD_ADDR_VAR 0 3
6071: PUSH
6072: LD_STRING QML3
6074: PPUSH
6075: LD_VAR 0 2
6079: PPUSH
6080: CALL_OW 98
6084: ST_TO_ADDR
// end ; if qr in bad then
6085: LD_VAR 0 3
6089: PUSH
6090: LD_VAR 0 5
6094: IN
6095: IFFALSE 6107
// result := false else
6097: LD_ADDR_VAR 0 1
6101: PUSH
6102: LD_INT 0
6104: ST_TO_ADDR
6105: GO 6115
// result := true ;
6107: LD_ADDR_VAR 0 1
6111: PUSH
6112: LD_INT 1
6114: ST_TO_ADDR
// end ;
6115: LD_VAR 0 1
6119: RET
// function QML4 ; var mozn , qr , a , bad ; begin
6120: LD_INT 0
6122: PPUSH
6123: PPUSH
6124: PPUSH
6125: PPUSH
6126: PPUSH
// bad := [ 1 , 2 ] ;
6127: LD_ADDR_VAR 0 5
6131: PUSH
6132: LD_INT 1
6134: PUSH
6135: LD_INT 2
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: LD_INT 2
6152: PUSH
6153: LD_INT 3
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: LIST
6160: ST_TO_ADDR
// if IsOk ( Gleb ) then
6161: LD_EXP 50
6165: PPUSH
6166: CALL_OW 302
6170: IFFALSE 6189
// mozn := mozn ^ [ 4 ] ;
6172: LD_ADDR_VAR 0 2
6176: PUSH
6177: LD_VAR 0 2
6181: PUSH
6182: LD_INT 4
6184: PUSH
6185: EMPTY
6186: LIST
6187: ADD
6188: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6189: LD_ADDR_VAR 0 3
6193: PUSH
6194: LD_STRING QML4
6196: PPUSH
6197: LD_VAR 0 2
6201: PPUSH
6202: CALL_OW 98
6206: ST_TO_ADDR
// if qr = 4 then
6207: LD_VAR 0 3
6211: PUSH
6212: LD_INT 4
6214: EQUAL
6215: IFFALSE 6289
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6217: LD_ADDR_VAR 0 4
6221: PUSH
6222: LD_VAR 0 5
6226: PUSH
6227: LD_INT 1
6229: PPUSH
6230: LD_INT 2
6232: PPUSH
6233: CALL_OW 12
6237: ARRAY
6238: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6239: LD_VAR 0 4
6243: PPUSH
6244: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
6248: LD_ADDR_VAR 0 2
6252: PUSH
6253: LD_VAR 0 2
6257: PUSH
6258: LD_VAR 0 4
6262: PUSH
6263: LD_INT 4
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: DIFF
6270: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6271: LD_ADDR_VAR 0 3
6275: PUSH
6276: LD_STRING QML4
6278: PPUSH
6279: LD_VAR 0 2
6283: PPUSH
6284: CALL_OW 98
6288: ST_TO_ADDR
// end ; if qr in bad then
6289: LD_VAR 0 3
6293: PUSH
6294: LD_VAR 0 5
6298: IN
6299: IFFALSE 6311
// result := false else
6301: LD_ADDR_VAR 0 1
6305: PUSH
6306: LD_INT 0
6308: ST_TO_ADDR
6309: GO 6319
// result := true ;
6311: LD_ADDR_VAR 0 1
6315: PUSH
6316: LD_INT 1
6318: ST_TO_ADDR
// end ;
6319: LD_VAR 0 1
6323: RET
// function QML5 ; var mozn , qr , a , bad ; begin
6324: LD_INT 0
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
// bad := [ 1 , 3 ] ;
6331: LD_ADDR_VAR 0 5
6335: PUSH
6336: LD_INT 1
6338: PUSH
6339: LD_INT 3
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6346: LD_ADDR_VAR 0 2
6350: PUSH
6351: LD_INT 1
6353: PUSH
6354: LD_INT 2
6356: PUSH
6357: LD_INT 3
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: ST_TO_ADDR
// if IsOk ( Gleb ) then
6365: LD_EXP 50
6369: PPUSH
6370: CALL_OW 302
6374: IFFALSE 6393
// mozn := mozn ^ [ 4 ] ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_VAR 0 2
6385: PUSH
6386: LD_INT 4
6388: PUSH
6389: EMPTY
6390: LIST
6391: ADD
6392: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6393: LD_ADDR_VAR 0 3
6397: PUSH
6398: LD_STRING QML5
6400: PPUSH
6401: LD_VAR 0 2
6405: PPUSH
6406: CALL_OW 98
6410: ST_TO_ADDR
// if qr = 4 then
6411: LD_VAR 0 3
6415: PUSH
6416: LD_INT 4
6418: EQUAL
6419: IFFALSE 6493
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_VAR 0 5
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6443: LD_VAR 0 4
6447: PPUSH
6448: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
6452: LD_ADDR_VAR 0 2
6456: PUSH
6457: LD_VAR 0 2
6461: PUSH
6462: LD_VAR 0 4
6466: PUSH
6467: LD_INT 4
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: DIFF
6474: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6475: LD_ADDR_VAR 0 3
6479: PUSH
6480: LD_STRING QML5
6482: PPUSH
6483: LD_VAR 0 2
6487: PPUSH
6488: CALL_OW 98
6492: ST_TO_ADDR
// end ; if qr in bad then
6493: LD_VAR 0 3
6497: PUSH
6498: LD_VAR 0 5
6502: IN
6503: IFFALSE 6515
// result := false else
6505: LD_ADDR_VAR 0 1
6509: PUSH
6510: LD_INT 0
6512: ST_TO_ADDR
6513: GO 6523
// result := true ;
6515: LD_ADDR_VAR 0 1
6519: PUSH
6520: LD_INT 1
6522: ST_TO_ADDR
// end ;
6523: LD_VAR 0 1
6527: RET
// function QML6 ; var mozn , qr , a , bad ; begin
6528: LD_INT 0
6530: PPUSH
6531: PPUSH
6532: PPUSH
6533: PPUSH
6534: PPUSH
// bad := [ 2 , 3 ] ;
6535: LD_ADDR_VAR 0 5
6539: PUSH
6540: LD_INT 2
6542: PUSH
6543: LD_INT 3
6545: PUSH
6546: EMPTY
6547: LIST
6548: LIST
6549: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6550: LD_ADDR_VAR 0 2
6554: PUSH
6555: LD_INT 1
6557: PUSH
6558: LD_INT 2
6560: PUSH
6561: LD_INT 3
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: LIST
6568: ST_TO_ADDR
// if IsOk ( Gleb ) then
6569: LD_EXP 50
6573: PPUSH
6574: CALL_OW 302
6578: IFFALSE 6597
// mozn := mozn ^ [ 4 ] ;
6580: LD_ADDR_VAR 0 2
6584: PUSH
6585: LD_VAR 0 2
6589: PUSH
6590: LD_INT 4
6592: PUSH
6593: EMPTY
6594: LIST
6595: ADD
6596: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6597: LD_ADDR_VAR 0 3
6601: PUSH
6602: LD_STRING QML6
6604: PPUSH
6605: LD_VAR 0 2
6609: PPUSH
6610: CALL_OW 98
6614: ST_TO_ADDR
// if qr = 4 then
6615: LD_VAR 0 3
6619: PUSH
6620: LD_INT 4
6622: EQUAL
6623: IFFALSE 6697
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6625: LD_ADDR_VAR 0 4
6629: PUSH
6630: LD_VAR 0 5
6634: PUSH
6635: LD_INT 1
6637: PPUSH
6638: LD_INT 2
6640: PPUSH
6641: CALL_OW 12
6645: ARRAY
6646: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6647: LD_VAR 0 4
6651: PPUSH
6652: CALL 6820 0 1
// mozn := mozn diff [ a , 4 ] ;
6656: LD_ADDR_VAR 0 2
6660: PUSH
6661: LD_VAR 0 2
6665: PUSH
6666: LD_VAR 0 4
6670: PUSH
6671: LD_INT 4
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: DIFF
6678: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6679: LD_ADDR_VAR 0 3
6683: PUSH
6684: LD_STRING QML6
6686: PPUSH
6687: LD_VAR 0 2
6691: PPUSH
6692: CALL_OW 98
6696: ST_TO_ADDR
// end ; if qr in bad then
6697: LD_VAR 0 3
6701: PUSH
6702: LD_VAR 0 5
6706: IN
6707: IFFALSE 6719
// result := false else
6709: LD_ADDR_VAR 0 1
6713: PUSH
6714: LD_INT 0
6716: ST_TO_ADDR
6717: GO 6727
// result := true ;
6719: LD_ADDR_VAR 0 1
6723: PUSH
6724: LD_INT 1
6726: ST_TO_ADDR
// end ;
6727: LD_VAR 0 1
6731: RET
// export function DQrML_Right ( first ) ; begin
6732: LD_INT 0
6734: PPUSH
// DialogueOn ;
6735: CALL_OW 6
// Say ( Tsr , DQrML#Right-Tsr-1 ) ;
6739: LD_LOC 7
6743: PPUSH
6744: LD_STRING DQrML#Right-Tsr-1
6746: PPUSH
6747: CALL_OW 88
// if first then
6751: LD_VAR 0 1
6755: IFFALSE 6771
// Say ( Tsr , DQrML#Right-Tsr-1a ) else
6757: LD_LOC 7
6761: PPUSH
6762: LD_STRING DQrML#Right-Tsr-1a
6764: PPUSH
6765: CALL_OW 88
6769: GO 6783
// Say ( Tsr , DQrML#Right-Tsr-1b ) ;
6771: LD_LOC 7
6775: PPUSH
6776: LD_STRING DQrML#Right-Tsr-1b
6778: PPUSH
6779: CALL_OW 88
// DialogueOff ;
6783: CALL_OW 7
// end ;
6787: LD_VAR 0 2
6791: RET
// export function DQrML_Wrong ; begin
6792: LD_INT 0
6794: PPUSH
// DialogueOn ;
6795: CALL_OW 6
// Say ( Tsr , DQrML#Wrong-Tsr-1 ) ;
6799: LD_LOC 7
6803: PPUSH
6804: LD_STRING DQrML#Wrong-Tsr-1
6806: PPUSH
6807: CALL_OW 88
// DialogueOff ;
6811: CALL_OW 7
// end ;
6815: LD_VAR 0 1
6819: RET
// function DQrML_Gleb ( num ) ; begin
6820: LD_INT 0
6822: PPUSH
// DialogueOn ;
6823: CALL_OW 6
// case num of 1 :
6827: LD_VAR 0 1
6831: PUSH
6832: LD_INT 1
6834: DOUBLE
6835: EQUAL
6836: IFTRUE 6840
6838: GO 6855
6840: POP
// Say ( Glb , DQrML#Gleb-Glb-1 ) ; 2 :
6841: LD_LOC 10
6845: PPUSH
6846: LD_STRING DQrML#Gleb-Glb-1
6848: PPUSH
6849: CALL_OW 88
6853: GO 6902
6855: LD_INT 2
6857: DOUBLE
6858: EQUAL
6859: IFTRUE 6863
6861: GO 6878
6863: POP
// Say ( Glb , DQrML#Gleb-Glb-1a ) ; 3 :
6864: LD_LOC 10
6868: PPUSH
6869: LD_STRING DQrML#Gleb-Glb-1a
6871: PPUSH
6872: CALL_OW 88
6876: GO 6902
6878: LD_INT 3
6880: DOUBLE
6881: EQUAL
6882: IFTRUE 6886
6884: GO 6901
6886: POP
// Say ( Glb , DQrML#Gleb-Glb-1b ) ; end ;
6887: LD_LOC 10
6891: PPUSH
6892: LD_STRING DQrML#Gleb-Glb-1b
6894: PPUSH
6895: CALL_OW 88
6899: GO 6902
6901: POP
// DialogueOff ;
6902: CALL_OW 7
// end ;
6906: LD_VAR 0 2
6910: RET
// export maji_artifact ; every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
6911: LD_LOC 2
6915: PPUSH
6916: LD_INT 22
6918: PPUSH
6919: CALL_OW 308
6923: PUSH
6924: LD_EXP 23
6928: PUSH
6929: LD_INT 1
6931: ARRAY
6932: PUSH
6933: LD_EXP 23
6937: PUSH
6938: LD_INT 4
6940: ARRAY
6941: NONEQUAL
6942: AND
6943: IFFALSE 7033
6945: GO 6947
6947: DISABLE
// begin DD_BaseContact ;
6948: CALL 7200 0 0
// if maji_artifact then
6952: LD_EXP 39
6956: IFFALSE 6995
// begin if not ai_s [ 4 ] in your_bases then
6958: LD_EXP 23
6962: PUSH
6963: LD_INT 4
6965: ARRAY
6966: PUSH
6967: LD_EXP 18
6971: IN
6972: NOT
6973: IFFALSE 6993
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
6975: LD_EXP 4
6979: PPUSH
6980: LD_EXP 23
6984: PUSH
6985: LD_INT 4
6987: ARRAY
6988: PPUSH
6989: CALL 30313 0 2
// end else
6993: GO 7030
// begin DD_BaseRefuse1st ;
6995: CALL 7248 0 0
// while IsInArea ( Bur , d_base ) do
6999: LD_LOC 2
7003: PPUSH
7004: LD_INT 22
7006: PPUSH
7007: CALL_OW 308
7011: IFFALSE 7022
// wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
7020: GO 6999
// wait ( 0 0$20 ) ;
7022: LD_INT 700
7024: PPUSH
7025: CALL_OW 67
// enable ;
7029: ENABLE
// end ; enable ( 12 ) ;
7030: LD_INT 12
7032: ENABLE_MARKED
// end ;
7033: END
// every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] marked 12 do
7034: LD_LOC 2
7038: PPUSH
7039: LD_INT 22
7041: PPUSH
7042: CALL_OW 308
7046: PUSH
7047: LD_EXP 23
7051: PUSH
7052: LD_INT 1
7054: ARRAY
7055: PUSH
7056: LD_EXP 23
7060: PUSH
7061: LD_INT 4
7063: ARRAY
7064: NONEQUAL
7065: AND
7066: IFFALSE 7126
7068: GO 7070
7070: DISABLE
// begin if maji_artifact then
7071: LD_EXP 39
7075: IFFALSE 7114
// begin if not ai_s [ 4 ] in your_bases then
7077: LD_EXP 23
7081: PUSH
7082: LD_INT 4
7084: ARRAY
7085: PUSH
7086: LD_EXP 18
7090: IN
7091: NOT
7092: IFFALSE 7112
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7094: LD_EXP 4
7098: PPUSH
7099: LD_EXP 23
7103: PUSH
7104: LD_INT 4
7106: ARRAY
7107: PPUSH
7108: CALL 30313 0 2
// end else
7112: GO 7126
// begin DD_BaseRefuse ;
7114: CALL 7276 0 0
// wait ( 0 0$20 ) ;
7118: LD_INT 700
7120: PPUSH
7121: CALL_OW 67
// enable ;
7125: ENABLE
// end ; end ;
7126: END
// every 0 0$2 trigger humans [ 4 ] <= 4 and ai_s [ 1 ] <> ai_s [ 4 ] do
7127: LD_EXP 76
7131: PUSH
7132: LD_INT 4
7134: ARRAY
7135: PUSH
7136: LD_INT 4
7138: LESSEQUAL
7139: PUSH
7140: LD_EXP 23
7144: PUSH
7145: LD_INT 1
7147: ARRAY
7148: PUSH
7149: LD_EXP 23
7153: PUSH
7154: LD_INT 4
7156: ARRAY
7157: NONEQUAL
7158: AND
7159: IFFALSE 7199
7161: GO 7163
7163: DISABLE
// begin if not ai_s [ 4 ] in your_bases then
7164: LD_EXP 23
7168: PUSH
7169: LD_INT 4
7171: ARRAY
7172: PUSH
7173: LD_EXP 18
7177: IN
7178: NOT
7179: IFFALSE 7199
// SurrenderBase ( t_killbeat , ai_s [ 4 ] ) ;
7181: LD_EXP 6
7185: PPUSH
7186: LD_EXP 23
7190: PUSH
7191: LD_INT 4
7193: ARRAY
7194: PPUSH
7195: CALL 30313 0 2
// end ;
7199: END
// export kecali_o_artefaktu ; export function DD_BaseContact ; begin
7200: LD_INT 0
7202: PPUSH
// DialogueOn ;
7203: CALL_OW 6
// Say ( Dav , DD-BaseContact-Dav-1 ) ;
7207: LD_LOC 8
7211: PPUSH
7212: LD_STRING DD-BaseContact-Dav-1
7214: PPUSH
7215: CALL_OW 88
// Say ( Bur , DD-BaseContact-Bur-1 ) ;
7219: LD_LOC 2
7223: PPUSH
7224: LD_STRING DD-BaseContact-Bur-1
7226: PPUSH
7227: CALL_OW 88
// kecali_o_artefaktu := true ;
7231: LD_ADDR_EXP 40
7235: PUSH
7236: LD_INT 1
7238: ST_TO_ADDR
// DialogueOff ;
7239: CALL_OW 7
// end ;
7243: LD_VAR 0 1
7247: RET
// export function DD_BaseRefuse1st ; begin
7248: LD_INT 0
7250: PPUSH
// DialogueOn ;
7251: CALL_OW 6
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7255: LD_LOC 8
7259: PPUSH
7260: LD_STRING DD-BaseRefuse-Dav-1
7262: PPUSH
7263: CALL_OW 88
// DialogueOff ;
7267: CALL_OW 7
// end ;
7271: LD_VAR 0 1
7275: RET
// export function DD_BaseRefuse ; begin
7276: LD_INT 0
7278: PPUSH
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7279: LD_LOC 8
7283: PPUSH
7284: LD_STRING DD-BaseRefuse-Dav-1
7286: PPUSH
7287: CALL_OW 88
// end ;
7291: LD_VAR 0 1
7295: RET
// export function DD_BaseAccept ( first ) ; begin
7296: LD_INT 0
7298: PPUSH
// DialogueOn ;
7299: CALL_OW 6
// Say ( Dav , DD-BaseAccept-Dav-1 ) ;
7303: LD_LOC 8
7307: PPUSH
7308: LD_STRING DD-BaseAccept-Dav-1
7310: PPUSH
7311: CALL_OW 88
// if first then
7315: LD_VAR 0 1
7319: IFFALSE 7335
// Say ( Dav , DD-BaseAccept-Dav-1a ) else
7321: LD_LOC 8
7325: PPUSH
7326: LD_STRING DD-BaseAccept-Dav-1a
7328: PPUSH
7329: CALL_OW 88
7333: GO 7347
// Say ( Dav , DD-BaseAccept-Dav-1b ) ;
7335: LD_LOC 8
7339: PPUSH
7340: LD_STRING DD-BaseAccept-Dav-1b
7342: PPUSH
7343: CALL_OW 88
// DialogueOff ;
7347: CALL_OW 7
// end ;
7351: LD_VAR 0 2
7355: RET
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] do
7356: LD_LOC 2
7360: PPUSH
7361: LD_INT 21
7363: PPUSH
7364: CALL_OW 308
7368: PUSH
7369: LD_EXP 23
7373: PUSH
7374: LD_INT 1
7376: ARRAY
7377: PUSH
7378: LD_EXP 23
7382: PUSH
7383: LD_INT 5
7385: ARRAY
7386: NONEQUAL
7387: AND
7388: IFFALSE 7499
7390: GO 7392
7392: DISABLE
// begin DE_BaseContact ;
7393: CALL 7761 0 0
// if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7397: LD_EXP 76
7401: PUSH
7402: LD_INT 5
7404: ARRAY
7405: PPUSH
7406: LD_INT 50
7408: PUSH
7409: EMPTY
7410: LIST
7411: PUSH
7412: EMPTY
7413: LIST
7414: PPUSH
7415: CALL_OW 72
7419: PUSH
7420: LD_INT 6
7422: GREATER
7423: IFFALSE 7464
// begin DE_BaseRefuse1st ;
7425: CALL 7801 0 0
// while IsInArea ( Bur , e_base ) do
7429: LD_LOC 2
7433: PPUSH
7434: LD_INT 21
7436: PPUSH
7437: CALL_OW 308
7441: IFFALSE 7452
// wait ( 0 0$1 ) ;
7443: LD_INT 35
7445: PPUSH
7446: CALL_OW 67
7450: GO 7429
// wait ( 0 0$20 ) ;
7452: LD_INT 700
7454: PPUSH
7455: CALL_OW 67
// enable ( 115 ) ;
7459: LD_INT 115
7461: ENABLE_MARKED
// end else
7462: GO 7499
// if not ai_s [ 5 ] in your_bases then
7464: LD_EXP 23
7468: PUSH
7469: LD_INT 5
7471: ARRAY
7472: PUSH
7473: LD_EXP 18
7477: IN
7478: NOT
7479: IFFALSE 7499
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7481: LD_EXP 5
7485: PPUSH
7486: LD_EXP 23
7490: PUSH
7491: LD_INT 5
7493: ARRAY
7494: PPUSH
7495: CALL 30313 0 2
// end ;
7499: END
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] marked 115 do
7500: LD_LOC 2
7504: PPUSH
7505: LD_INT 21
7507: PPUSH
7508: CALL_OW 308
7512: PUSH
7513: LD_EXP 23
7517: PUSH
7518: LD_INT 1
7520: ARRAY
7521: PUSH
7522: LD_EXP 23
7526: PUSH
7527: LD_INT 5
7529: ARRAY
7530: NONEQUAL
7531: AND
7532: IFFALSE 7600
7534: GO 7536
7536: DISABLE
// begin if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7537: LD_EXP 76
7541: PUSH
7542: LD_INT 5
7544: ARRAY
7545: PPUSH
7546: LD_INT 50
7548: PUSH
7549: EMPTY
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: PPUSH
7555: CALL_OW 72
7559: PUSH
7560: LD_INT 6
7562: GREATER
7563: IFFALSE 7599
// begin DE_BaseRefuse ;
7565: CALL 7829 0 0
// while IsInArea ( Bur , e_base ) do
7569: LD_LOC 2
7573: PPUSH
7574: LD_INT 21
7576: PPUSH
7577: CALL_OW 308
7581: IFFALSE 7592
// wait ( 0 0$1 ) ;
7583: LD_INT 35
7585: PPUSH
7586: CALL_OW 67
7590: GO 7569
// wait ( 0 0$20 ) ;
7592: LD_INT 700
7594: PPUSH
7595: CALL_OW 67
// end ; enable ;
7599: ENABLE
// end ;
7600: END
// every 0 0$2 trigger UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) <= 6 and ai_s [ 1 ] <> ai_s [ 5 ] do
7601: LD_EXP 76
7605: PUSH
7606: LD_INT 5
7608: ARRAY
7609: PPUSH
7610: LD_INT 50
7612: PUSH
7613: EMPTY
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: PPUSH
7619: CALL_OW 72
7623: PUSH
7624: LD_INT 6
7626: LESSEQUAL
7627: PUSH
7628: LD_EXP 23
7632: PUSH
7633: LD_INT 1
7635: ARRAY
7636: PUSH
7637: LD_EXP 23
7641: PUSH
7642: LD_INT 5
7644: ARRAY
7645: NONEQUAL
7646: AND
7647: IFFALSE 7687
7649: GO 7651
7651: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7652: LD_EXP 23
7656: PUSH
7657: LD_INT 5
7659: ARRAY
7660: PUSH
7661: LD_EXP 18
7665: IN
7666: NOT
7667: IFFALSE 7687
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7669: LD_EXP 5
7673: PPUSH
7674: LD_EXP 23
7678: PUSH
7679: LD_INT 5
7681: ARRAY
7682: PPUSH
7683: CALL 30313 0 2
// end ;
7687: END
// every 0 0$2 trigger humans [ 5 ] <= 4 and ai_s [ 1 ] <> ai_s [ 5 ] do
7688: LD_EXP 76
7692: PUSH
7693: LD_INT 5
7695: ARRAY
7696: PUSH
7697: LD_INT 4
7699: LESSEQUAL
7700: PUSH
7701: LD_EXP 23
7705: PUSH
7706: LD_INT 1
7708: ARRAY
7709: PUSH
7710: LD_EXP 23
7714: PUSH
7715: LD_INT 5
7717: ARRAY
7718: NONEQUAL
7719: AND
7720: IFFALSE 7760
7722: GO 7724
7724: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7725: LD_EXP 23
7729: PUSH
7730: LD_INT 5
7732: ARRAY
7733: PUSH
7734: LD_EXP 18
7738: IN
7739: NOT
7740: IFFALSE 7760
// SurrenderBase ( t_killbeat , ai_s [ 5 ] ) ;
7742: LD_EXP 6
7746: PPUSH
7747: LD_EXP 23
7751: PUSH
7752: LD_INT 5
7754: ARRAY
7755: PPUSH
7756: CALL 30313 0 2
// end ;
7760: END
// export function DE_BaseContact ; begin
7761: LD_INT 0
7763: PPUSH
// DialogueOn ;
7764: CALL_OW 6
// Say ( Eis , DE-BaseContact-Eis-1 ) ;
7768: LD_LOC 9
7772: PPUSH
7773: LD_STRING DE-BaseContact-Eis-1
7775: PPUSH
7776: CALL_OW 88
// Say ( Bur , DE-BaseContact-Bur-1 ) ;
7780: LD_LOC 2
7784: PPUSH
7785: LD_STRING DE-BaseContact-Bur-1
7787: PPUSH
7788: CALL_OW 88
// DialogueOff ;
7792: CALL_OW 7
// end ;
7796: LD_VAR 0 1
7800: RET
// export function DE_BaseRefuse1st ; begin
7801: LD_INT 0
7803: PPUSH
// DialogueOn ;
7804: CALL_OW 6
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7808: LD_LOC 9
7812: PPUSH
7813: LD_STRING DE-BaseRefuse-Eis-1
7815: PPUSH
7816: CALL_OW 88
// DialogueOff ;
7820: CALL_OW 7
// end ;
7824: LD_VAR 0 1
7828: RET
// export function DE_BaseRefuse ; begin
7829: LD_INT 0
7831: PPUSH
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7832: LD_LOC 9
7836: PPUSH
7837: LD_STRING DE-BaseRefuse-Eis-1
7839: PPUSH
7840: CALL_OW 88
// end ;
7844: LD_VAR 0 1
7848: RET
// export function DE_BaseAccept ( first ) ; begin
7849: LD_INT 0
7851: PPUSH
// DialogueOn ;
7852: CALL_OW 6
// Say ( Eis , DE-BaseAccept-Eis-1 ) ;
7856: LD_LOC 9
7860: PPUSH
7861: LD_STRING DE-BaseAccept-Eis-1
7863: PPUSH
7864: CALL_OW 88
// if first then
7868: LD_VAR 0 1
7872: IFFALSE 7888
// Say ( Eis , DE-BaseAccept-Eis-1a ) else
7874: LD_LOC 9
7878: PPUSH
7879: LD_STRING DE-BaseAccept-Eis-1a
7881: PPUSH
7882: CALL_OW 88
7886: GO 7900
// Say ( Eis , DE-BaseAccept-Eis-1b ) ;
7888: LD_LOC 9
7892: PPUSH
7893: LD_STRING DE-BaseAccept-Eis-1b
7895: PPUSH
7896: CALL_OW 88
// DialogueOff ;
7900: CALL_OW 7
// end ;
7904: LD_VAR 0 2
7908: RET
// export function DXbaseSurrender ( side ) ; var who ; begin
7909: LD_INT 0
7911: PPUSH
7912: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , side , sex_male , 0 , 0 ) ;
7913: LD_ADDR_VAR 0 3
7917: PUSH
7918: LD_INT 21
7920: PUSH
7921: LD_INT 1
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: LD_INT 23
7930: PUSH
7931: LD_INT 3
7933: PUSH
7934: EMPTY
7935: LIST
7936: LIST
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PPUSH
7942: CALL_OW 69
7946: PUSH
7947: LD_LOC 11
7951: DIFF
7952: PPUSH
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 1
7960: PPUSH
7961: LD_INT 0
7963: PPUSH
7964: LD_INT 0
7966: PPUSH
7967: CALL 10352 0 5
7971: ST_TO_ADDR
// DialogueOn ;
7972: CALL_OW 6
// Say ( who , DXbaseSurrender-Rsol1-1 ) ;
7976: LD_VAR 0 3
7980: PPUSH
7981: LD_STRING DXbaseSurrender-Rsol1-1
7983: PPUSH
7984: CALL_OW 88
// DialogueOff ;
7988: CALL_OW 7
// end ;
7992: LD_VAR 0 2
7996: RET
// export function DRocket ; var who ; begin
7997: LD_INT 0
7999: PPUSH
8000: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , class_scientistic , 0 ) ;
8001: LD_ADDR_VAR 0 2
8005: PUSH
8006: LD_INT 21
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 23
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: PUSH
8035: LD_LOC 11
8039: DIFF
8040: PPUSH
8041: LD_EXP 7
8045: PPUSH
8046: LD_INT 1
8048: PPUSH
8049: LD_INT 4
8051: PPUSH
8052: LD_INT 0
8054: PPUSH
8055: CALL 10352 0 5
8059: ST_TO_ADDR
// TalkOn ;
8060: CALL 10611 0 0
// Say ( who , DRocket-RSci1-1 ) ;
8064: LD_VAR 0 2
8068: PPUSH
8069: LD_STRING DRocket-RSci1-1
8071: PPUSH
8072: CALL_OW 88
// TalkOff ;
8076: CALL 10627 0 0
// end ;
8080: LD_VAR 0 1
8084: RET
// every 0 0$1 trigger cap_bases >= 4 do
8085: LD_EXP 17
8089: PUSH
8090: LD_INT 4
8092: GREATEREQUAL
8093: IFFALSE 8109
8095: GO 8097
8097: DISABLE
// begin QEnd ;
8098: CALL 8110 0 0
// ChangeMissionObjectives ( MDestroy ) ;
8102: LD_STRING MDestroy
8104: PPUSH
8105: CALL_OW 337
// end ;
8109: END
// export function QEnd ; var qr ; begin
8110: LD_INT 0
8112: PPUSH
8113: PPUSH
// qr := Query ( QKill ) ;
8114: LD_ADDR_VAR 0 2
8118: PUSH
8119: LD_STRING QKill
8121: PPUSH
8122: CALL_OW 97
8126: ST_TO_ADDR
// end ;
8127: LD_VAR 0 1
8131: RET
// export function DEnd ; var who ; begin
8132: LD_INT 0
8134: PPUSH
8135: PPUSH
// who := Gla ;
8136: LD_ADDR_VAR 0 2
8140: PUSH
8141: LD_LOC 1
8145: ST_TO_ADDR
// if not IsOk ( Gla ) then
8146: LD_LOC 1
8150: PPUSH
8151: CALL_OW 302
8155: NOT
8156: IFFALSE 8217
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , 0 , 0 ) ;
8158: LD_ADDR_VAR 0 2
8162: PUSH
8163: LD_INT 21
8165: PUSH
8166: LD_INT 1
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PUSH
8173: LD_INT 23
8175: PUSH
8176: LD_INT 3
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PPUSH
8187: CALL_OW 69
8191: PUSH
8192: LD_LOC 11
8196: DIFF
8197: PPUSH
8198: LD_EXP 7
8202: PPUSH
8203: LD_INT 1
8205: PPUSH
8206: LD_INT 0
8208: PPUSH
8209: LD_INT 0
8211: PPUSH
8212: CALL 10352 0 5
8216: ST_TO_ADDR
// DialogueOn ;
8217: CALL_OW 6
// Say ( Bur , DEnd-Bur-1 ) ;
8221: LD_LOC 2
8225: PPUSH
8226: LD_STRING DEnd-Bur-1
8228: PPUSH
8229: CALL_OW 88
// if Say ( who , DEnd-Gla-1 ) then
8233: LD_VAR 0 2
8237: PPUSH
8238: LD_STRING DEnd-Gla-1
8240: PPUSH
8241: CALL_OW 88
8245: IFFALSE 8259
// Say ( Bur , DEnd-Bur-2 ) ;
8247: LD_LOC 2
8251: PPUSH
8252: LD_STRING DEnd-Bur-2
8254: PPUSH
8255: CALL_OW 88
// Say ( Bur , DEnd-Bur-2a ) ;
8259: LD_LOC 2
8263: PPUSH
8264: LD_STRING DEnd-Bur-2a
8266: PPUSH
8267: CALL_OW 88
// DialogueOff ;
8271: CALL_OW 7
// end ; end_of_file
8275: LD_VAR 0 1
8279: RET
// export Burlak , Platonov , Gossudarov , Gladkov , Fadeev , Borodin , Tsaritsyn , Davidov , Eisenstein , Gleb ; var masha_def , masha ; var used ; export function Load ; var i ; begin
8280: LD_INT 0
8282: PPUSH
8283: PPUSH
// Masha := LoadVariable ( Masha , [ ] ) ;
8284: LD_ADDR_LOC 14
8288: PUSH
8289: LD_STRING Masha
8291: PPUSH
8292: EMPTY
8293: PPUSH
8294: CALL_OW 30
8298: ST_TO_ADDR
// InitUc ;
8299: CALL_OW 18
// InitHc ;
8303: CALL_OW 19
// uc_nation := nation_russian ;
8307: LD_ADDR_OWVAR 21
8311: PUSH
8312: LD_INT 3
8314: ST_TO_ADDR
// uc_side := ai_s [ 1 ] ;
8315: LD_ADDR_OWVAR 20
8319: PUSH
8320: LD_EXP 23
8324: PUSH
8325: LD_INT 1
8327: ARRAY
8328: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
8329: LD_ADDR_EXP 42
8333: PUSH
8334: LD_STRING Platonov
8336: PPUSH
8337: LD_INT 1
8339: PPUSH
8340: LD_INT 1
8342: PPUSH
8343: CALL 8944 0 3
8347: ST_TO_ADDR
// Gossudarov := MyCreateCharacter ( Gossudarov , class_scientistic , false ) ;
8348: LD_ADDR_EXP 43
8352: PUSH
8353: LD_STRING Gossudarov
8355: PPUSH
8356: LD_INT 4
8358: PPUSH
8359: LD_INT 0
8361: PPUSH
8362: CALL 8944 0 3
8366: ST_TO_ADDR
// SetSkill ( Gossudarov , skill_mechanical , gossudarov_mech_skill ) ;
8367: LD_EXP 43
8371: PPUSH
8372: LD_INT 3
8374: PPUSH
8375: LD_EXP 16
8379: PPUSH
8380: CALL_OW 237
// uc_side := ai_s [ 2 ] ;
8384: LD_ADDR_OWVAR 20
8388: PUSH
8389: LD_EXP 23
8393: PUSH
8394: LD_INT 2
8396: ARRAY
8397: ST_TO_ADDR
// Borodin := MyCreateCharacter ( Borodin , 0 , true ) ;
8398: LD_ADDR_EXP 46
8402: PUSH
8403: LD_STRING Borodin
8405: PPUSH
8406: LD_INT 0
8408: PPUSH
8409: LD_INT 1
8411: PPUSH
8412: CALL 8944 0 3
8416: ST_TO_ADDR
// uc_side := ai_s [ 3 ] ;
8417: LD_ADDR_OWVAR 20
8421: PUSH
8422: LD_EXP 23
8426: PUSH
8427: LD_INT 3
8429: ARRAY
8430: ST_TO_ADDR
// Tsaritsyn := MyCreateCharacter ( Tsaritsyn , 0 , true ) ;
8431: LD_ADDR_EXP 47
8435: PUSH
8436: LD_STRING Tsaritsyn
8438: PPUSH
8439: LD_INT 0
8441: PPUSH
8442: LD_INT 1
8444: PPUSH
8445: CALL 8944 0 3
8449: ST_TO_ADDR
// uc_side := ai_s [ 4 ] ;
8450: LD_ADDR_OWVAR 20
8454: PUSH
8455: LD_EXP 23
8459: PUSH
8460: LD_INT 4
8462: ARRAY
8463: ST_TO_ADDR
// Davidov := MyCreateCharacter ( Davidov , class_scientistic , true ) ;
8464: LD_ADDR_EXP 48
8468: PUSH
8469: LD_STRING Davidov
8471: PPUSH
8472: LD_INT 4
8474: PPUSH
8475: LD_INT 1
8477: PPUSH
8478: CALL 8944 0 3
8482: ST_TO_ADDR
// uc_side := ai_s [ 5 ] ;
8483: LD_ADDR_OWVAR 20
8487: PUSH
8488: LD_EXP 23
8492: PUSH
8493: LD_INT 5
8495: ARRAY
8496: ST_TO_ADDR
// Eisenstein := MyCreateCharacter ( Eisenstein , 0 , true ) ;
8497: LD_ADDR_EXP 49
8501: PUSH
8502: LD_STRING Eisenstein
8504: PPUSH
8505: LD_INT 0
8507: PPUSH
8508: LD_INT 1
8510: PPUSH
8511: CALL 8944 0 3
8515: ST_TO_ADDR
// uc_side := you ;
8516: LD_ADDR_OWVAR 20
8520: PUSH
8521: LD_EXP 7
8525: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
8526: LD_ADDR_EXP 41
8530: PUSH
8531: LD_STRING Burlak
8533: PPUSH
8534: LD_INT 3
8536: PPUSH
8537: LD_INT 0
8539: PPUSH
8540: CALL 8944 0 3
8544: ST_TO_ADDR
// Gladkov := MyCreateCharacter ( Gladkov , 0 , true ) ;
8545: LD_ADDR_EXP 44
8549: PUSH
8550: LD_STRING Gladkov
8552: PPUSH
8553: LD_INT 0
8555: PPUSH
8556: LD_INT 1
8558: PPUSH
8559: CALL 8944 0 3
8563: ST_TO_ADDR
// Fadeev := MyCreateCharacter ( Fadeev , 0 , true ) ;
8564: LD_ADDR_EXP 45
8568: PUSH
8569: LD_STRING Fadeev
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: LD_INT 1
8577: PPUSH
8578: CALL 8944 0 3
8582: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , false ) ;
8583: LD_ADDR_EXP 50
8587: PUSH
8588: LD_STRING Gleb
8590: PPUSH
8591: LD_INT 1
8593: PPUSH
8594: LD_INT 0
8596: PPUSH
8597: CALL 8944 0 3
8601: ST_TO_ADDR
// masha_def := LoadVariable ( Masha , [ ] ) ;
8602: LD_ADDR_LOC 13
8606: PUSH
8607: LD_STRING Masha
8609: PPUSH
8610: EMPTY
8611: PPUSH
8612: CALL_OW 30
8616: ST_TO_ADDR
// if masha_def then
8617: LD_LOC 13
8621: IFFALSE 8693
// begin InitVc ;
8623: CALL_OW 20
// vc_chassis := masha_def [ 1 ] ;
8627: LD_ADDR_OWVAR 37
8631: PUSH
8632: LD_LOC 13
8636: PUSH
8637: LD_INT 1
8639: ARRAY
8640: ST_TO_ADDR
// vc_engine := masha_def [ 2 ] ;
8641: LD_ADDR_OWVAR 39
8645: PUSH
8646: LD_LOC 13
8650: PUSH
8651: LD_INT 2
8653: ARRAY
8654: ST_TO_ADDR
// vc_control := masha_def [ 3 ] ;
8655: LD_ADDR_OWVAR 38
8659: PUSH
8660: LD_LOC 13
8664: PUSH
8665: LD_INT 3
8667: ARRAY
8668: ST_TO_ADDR
// vc_weapon := masha_def [ 4 ] ;
8669: LD_ADDR_OWVAR 40
8673: PUSH
8674: LD_LOC 13
8678: PUSH
8679: LD_INT 4
8681: ARRAY
8682: ST_TO_ADDR
// masha := CreateVehicle ;
8683: LD_ADDR_LOC 14
8687: PUSH
8688: CALL_OW 45
8692: ST_TO_ADDR
// end ; used := [ ] ;
8693: LD_ADDR_LOC 15
8697: PUSH
8698: EMPTY
8699: ST_TO_ADDR
// used := [ Gleb ] diff 0 ;
8700: LD_ADDR_LOC 15
8704: PUSH
8705: LD_EXP 50
8709: PUSH
8710: EMPTY
8711: LIST
8712: PUSH
8713: LD_INT 0
8715: DIFF
8716: ST_TO_ADDR
// used := used ^ [ Fadeev , Gladkov ] ;
8717: LD_ADDR_LOC 15
8721: PUSH
8722: LD_LOC 15
8726: PUSH
8727: LD_EXP 45
8731: PUSH
8732: LD_EXP 44
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: ADD
8741: ST_TO_ADDR
// for i := used + 1 to 3 do
8742: LD_ADDR_VAR 0 2
8746: PUSH
8747: DOUBLE
8748: LD_LOC 15
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: DEC
8757: ST_TO_ADDR
8758: LD_INT 3
8760: PUSH
8761: FOR_TO
8762: IFFALSE 8795
// begin PrepareSoldier ( sex_male , 6 ) ;
8764: LD_INT 1
8766: PPUSH
8767: LD_INT 6
8769: PPUSH
8770: CALL_OW 381
// used := used ^ [ CreateHuman ] ;
8774: LD_ADDR_LOC 15
8778: PUSH
8779: LD_LOC 15
8783: PUSH
8784: CALL_OW 44
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
// end ;
8793: GO 8761
8795: POP
8796: POP
// used := used ^ [ Burlak ] ;
8797: LD_ADDR_LOC 15
8801: PUSH
8802: LD_LOC 15
8806: PUSH
8807: LD_EXP 41
8811: PUSH
8812: EMPTY
8813: LIST
8814: ADD
8815: ST_TO_ADDR
// end ;
8816: LD_VAR 0 1
8820: RET
// export function place_ru ; var i ; begin
8821: LD_INT 0
8823: PPUSH
8824: PPUSH
// for i in used diff burlak do
8825: LD_ADDR_VAR 0 2
8829: PUSH
8830: LD_LOC 15
8834: PUSH
8835: LD_EXP 41
8839: DIFF
8840: PUSH
8841: FOR_IN
8842: IFFALSE 8861
// PlaceUnitArea ( i , ru_place , false ) ;
8844: LD_VAR 0 2
8848: PPUSH
8849: LD_INT 6
8851: PPUSH
8852: LD_INT 0
8854: PPUSH
8855: CALL_OW 49
8859: GO 8841
8861: POP
8862: POP
// if masha then
8863: LD_LOC 14
8867: IFFALSE 8924
// begin SetMark ( masha , 1 ) ;
8869: LD_LOC 14
8873: PPUSH
8874: LD_INT 1
8876: PPUSH
8877: CALL_OW 242
// PlaceHumanInUnit ( Burlak , masha ) ;
8881: LD_EXP 41
8885: PPUSH
8886: LD_LOC 14
8890: PPUSH
8891: CALL_OW 52
// PlaceUnitArea ( masha , ru_place , false ) ;
8895: LD_LOC 14
8899: PPUSH
8900: LD_INT 6
8902: PPUSH
8903: LD_INT 0
8905: PPUSH
8906: CALL_OW 49
// SetMark ( masha , 1 ) ;
8910: LD_LOC 14
8914: PPUSH
8915: LD_INT 1
8917: PPUSH
8918: CALL_OW 242
// end else
8922: GO 8939
// PlaceUnitArea ( Burlak , ru_place , false ) ;
8924: LD_EXP 41
8928: PPUSH
8929: LD_INT 6
8931: PPUSH
8932: LD_INT 0
8934: PPUSH
8935: CALL_OW 49
// end ;
8939: LD_VAR 0 1
8943: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
8944: LD_INT 0
8946: PPUSH
// if ( new and NewCharacter ( name ) ) or TestCharacters ( name ) then
8947: LD_VAR 0 3
8951: PUSH
8952: LD_VAR 0 1
8956: PPUSH
8957: CALL_OW 25
8961: AND
8962: PUSH
8963: LD_VAR 0 1
8967: PPUSH
8968: CALL_OW 28
8972: OR
8973: IFFALSE 9056
// begin if new then
8975: LD_VAR 0 3
8979: IFFALSE 8998
// result := NewCharacter ( name ) else
8981: LD_ADDR_VAR 0 4
8985: PUSH
8986: LD_VAR 0 1
8990: PPUSH
8991: CALL_OW 25
8995: ST_TO_ADDR
8996: GO 9034
// begin if CheckCharacterSet ( name ) then
8998: LD_VAR 0 1
9002: PPUSH
9003: CALL_OW 29
9007: IFFALSE 9026
// result := CreateCharacter ( name ) else
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_VAR 0 1
9018: PPUSH
9019: CALL_OW 34
9023: ST_TO_ADDR
9024: GO 9034
// result := 0 ;
9026: LD_ADDR_VAR 0 4
9030: PUSH
9031: LD_INT 0
9033: ST_TO_ADDR
// end ; if unclass then
9034: LD_VAR 0 2
9038: IFFALSE 9054
// SetClass ( result , unclass ) ;
9040: LD_VAR 0 4
9044: PPUSH
9045: LD_VAR 0 2
9049: PPUSH
9050: CALL_OW 336
// end else
9054: GO 9122
// begin Msg ( Chybi  & name & ! ) ;
9056: LD_STRING Chybi 
9058: PUSH
9059: LD_VAR 0 1
9063: STR
9064: PUSH
9065: LD_STRING !
9067: STR
9068: PPUSH
9069: CALL_OW 100
// hc_name := name ;
9073: LD_ADDR_OWVAR 26
9077: PUSH
9078: LD_VAR 0 1
9082: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
9083: LD_INT 1
9085: PPUSH
9086: LD_INT 0
9088: PPUSH
9089: LD_INT 3
9091: PPUSH
9092: CALL_OW 380
// if unclass then
9096: LD_VAR 0 2
9100: IFFALSE 9112
// hc_class := unclass ;
9102: LD_ADDR_OWVAR 28
9106: PUSH
9107: LD_VAR 0 2
9111: ST_TO_ADDR
// result := CreateHuman ;
9112: LD_ADDR_VAR 0 4
9116: PUSH
9117: CALL_OW 44
9121: ST_TO_ADDR
// end ; end ;
9122: LD_VAR 0 4
9126: RET
// export function Save ; var tmp , Bluekher , t ; begin
9127: LD_INT 0
9129: PPUSH
9130: PPUSH
9131: PPUSH
9132: PPUSH
// SaveCharacters ( Burlak , Burlak ) ;
9133: LD_EXP 41
9137: PPUSH
9138: LD_STRING Burlak
9140: PPUSH
9141: CALL_OW 38
// SaveCharacters ( Gladkov , Gladkov ) ;
9145: LD_EXP 44
9149: PPUSH
9150: LD_STRING Gladkov
9152: PPUSH
9153: CALL_OW 38
// SaveCharacters ( Fadeev , Fadeev ) ;
9157: LD_EXP 45
9161: PPUSH
9162: LD_STRING Fadeev
9164: PPUSH
9165: CALL_OW 38
// DeleteCharacters ( Platonov ) ;
9169: LD_STRING Platonov
9171: PPUSH
9172: CALL_OW 40
// SaveVariable ( not IsLive ( Platonov ) , PlatonovKilled ) ;
9176: LD_EXP 42
9180: PPUSH
9181: CALL_OW 300
9185: NOT
9186: PPUSH
9187: LD_STRING PlatonovKilled
9189: PPUSH
9190: CALL_OW 39
// SaveVariable ( BehemothSeen , BehemothSeen ) ;
9194: LD_EXP 29
9198: PPUSH
9199: LD_STRING BehemothSeen
9201: PPUSH
9202: CALL_OW 39
// if IsDead ( masha ) then
9206: LD_LOC 14
9210: PPUSH
9211: CALL_OW 301
9215: IFFALSE 9224
// DeleteVariable ( Masha ) ;
9217: LD_STRING Masha
9219: PPUSH
9220: CALL_OW 41
// SaveCharacters ( Borodin , Borodin ) ;
9224: LD_EXP 46
9228: PPUSH
9229: LD_STRING Borodin
9231: PPUSH
9232: CALL_OW 38
// SaveCharacters ( Tsaritsyn , Tsaritsyn ) ;
9236: LD_EXP 47
9240: PPUSH
9241: LD_STRING Tsaritsyn
9243: PPUSH
9244: CALL_OW 38
// SaveCharacters ( Davidov , Davidov ) ;
9248: LD_EXP 48
9252: PPUSH
9253: LD_STRING Davidov
9255: PPUSH
9256: CALL_OW 38
// SaveCharacters ( Eisenstein , Eisenstein ) ;
9260: LD_EXP 49
9264: PPUSH
9265: LD_STRING Eisenstein
9267: PPUSH
9268: CALL_OW 38
// if Gleb then
9272: LD_EXP 50
9276: IFFALSE 9290
// SaveCharacters ( Gleb , Gleb ) ;
9278: LD_EXP 50
9282: PPUSH
9283: LD_STRING Gleb
9285: PPUSH
9286: CALL_OW 38
// DeleteCharacters ( Gossudarov ) ;
9290: LD_STRING Gossudarov
9292: PPUSH
9293: CALL_OW 40
// tmp := FilterUnitsInArea ( Bluekher_area , [ [ f_type , unit_building ] ] ) ;
9297: LD_ADDR_VAR 0 2
9301: PUSH
9302: LD_INT 18
9304: PPUSH
9305: LD_INT 21
9307: PUSH
9308: LD_INT 3
9310: PUSH
9311: EMPTY
9312: LIST
9313: LIST
9314: PUSH
9315: EMPTY
9316: LIST
9317: PPUSH
9318: CALL_OW 70
9322: ST_TO_ADDR
// Bluekher := [ ] ;
9323: LD_ADDR_VAR 0 3
9327: PUSH
9328: EMPTY
9329: ST_TO_ADDR
// for t in tmp do
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 2
9339: PUSH
9340: FOR_IN
9341: IFFALSE 9728
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
9343: LD_VAR 0 4
9347: PPUSH
9348: CALL_OW 266
9352: PUSH
9353: LD_INT 9
9355: DOUBLE
9356: EQUAL
9357: IFTRUE 9397
9359: LD_INT 10
9361: DOUBLE
9362: EQUAL
9363: IFTRUE 9397
9365: LD_INT 13
9367: DOUBLE
9368: EQUAL
9369: IFTRUE 9397
9371: LD_INT 12
9373: DOUBLE
9374: EQUAL
9375: IFTRUE 9397
9377: LD_INT 15
9379: DOUBLE
9380: EQUAL
9381: IFTRUE 9397
9383: LD_INT 11
9385: DOUBLE
9386: EQUAL
9387: IFTRUE 9397
9389: LD_INT 14
9391: DOUBLE
9392: EQUAL
9393: IFTRUE 9397
9395: GO 9400
9397: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
9398: GO 9726
9400: LD_INT 6
9402: DOUBLE
9403: EQUAL
9404: IFTRUE 9420
9406: LD_INT 7
9408: DOUBLE
9409: EQUAL
9410: IFTRUE 9420
9412: LD_INT 8
9414: DOUBLE
9415: EQUAL
9416: IFTRUE 9420
9418: GO 9533
9420: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , getlabkind ( t , 1 ) , getlabkind ( t , 2 ) ] ] ; b_bunker , b_turret :
9421: LD_ADDR_VAR 0 3
9425: PUSH
9426: LD_VAR 0 3
9430: PUSH
9431: LD_VAR 0 4
9435: PPUSH
9436: CALL_OW 250
9440: PUSH
9441: LD_VAR 0 4
9445: PPUSH
9446: CALL_OW 251
9450: PUSH
9451: LD_VAR 0 4
9455: PPUSH
9456: CALL_OW 254
9460: PUSH
9461: LD_VAR 0 4
9465: PPUSH
9466: CALL_OW 266
9470: PUSH
9471: LD_VAR 0 4
9475: PPUSH
9476: CALL_OW 267
9480: PUSH
9481: LD_VAR 0 4
9485: PPUSH
9486: CALL_OW 248
9490: PUSH
9491: LD_VAR 0 4
9495: PPUSH
9496: LD_INT 1
9498: PPUSH
9499: CALL_OW 268
9503: PUSH
9504: LD_VAR 0 4
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: CALL_OW 268
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: EMPTY
9528: LIST
9529: ADD
9530: ST_TO_ADDR
9531: GO 9726
9533: LD_INT 32
9535: DOUBLE
9536: EQUAL
9537: IFTRUE 9547
9539: LD_INT 33
9541: DOUBLE
9542: EQUAL
9543: IFTRUE 9547
9545: GO 9643
9547: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , GetWeapon ( t ) ] ] ; else
9548: LD_ADDR_VAR 0 3
9552: PUSH
9553: LD_VAR 0 3
9557: PUSH
9558: LD_VAR 0 4
9562: PPUSH
9563: CALL_OW 250
9567: PUSH
9568: LD_VAR 0 4
9572: PPUSH
9573: CALL_OW 251
9577: PUSH
9578: LD_VAR 0 4
9582: PPUSH
9583: CALL_OW 254
9587: PUSH
9588: LD_VAR 0 4
9592: PPUSH
9593: CALL_OW 266
9597: PUSH
9598: LD_VAR 0 4
9602: PPUSH
9603: CALL_OW 267
9607: PUSH
9608: LD_VAR 0 4
9612: PPUSH
9613: CALL_OW 248
9617: PUSH
9618: LD_VAR 0 4
9622: PPUSH
9623: CALL_OW 264
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: PUSH
9637: EMPTY
9638: LIST
9639: ADD
9640: ST_TO_ADDR
9641: GO 9726
9643: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) ] ] ; end ;
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 3
9653: PUSH
9654: LD_VAR 0 4
9658: PPUSH
9659: CALL_OW 250
9663: PUSH
9664: LD_VAR 0 4
9668: PPUSH
9669: CALL_OW 251
9673: PUSH
9674: LD_VAR 0 4
9678: PPUSH
9679: CALL_OW 254
9683: PUSH
9684: LD_VAR 0 4
9688: PPUSH
9689: CALL_OW 266
9693: PUSH
9694: LD_VAR 0 4
9698: PPUSH
9699: CALL_OW 267
9703: PUSH
9704: LD_VAR 0 4
9708: PPUSH
9709: CALL_OW 248
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: EMPTY
9723: LIST
9724: ADD
9725: ST_TO_ADDR
// end ;
9726: GO 9340
9728: POP
9729: POP
// SaveVariable ( Bluekher , Bluekher ) ;
9730: LD_VAR 0 3
9734: PPUSH
9735: LD_STRING Bluekher
9737: PPUSH
9738: CALL_OW 39
// if CheckCharacterSet ( survivors3 ) then
9742: LD_STRING survivors3
9744: PPUSH
9745: CALL_OW 29
9749: IFFALSE 9776
// begin tmp = CreateCharacterSet ( survivors3 ) ;
9751: LD_ADDR_VAR 0 2
9755: PUSH
9756: LD_STRING survivors3
9758: PPUSH
9759: CALL_OW 31
9763: ST_TO_ADDR
// SaveCharacters ( tmp , survivors4 ) ;
9764: LD_VAR 0 2
9768: PPUSH
9769: LD_STRING survivors4
9771: PPUSH
9772: CALL_OW 38
// end ; end ; end_of_file
9776: LD_VAR 0 1
9780: RET
// export mf_sol ; export mf_eng ; export mf_mec ; export mf_sci ; export mf_lab ; export mf_fort ; export mf_bunk ; export mf_dep ; export mf_fact ; export mf_comp ; export mf_manu ; export function inicializace_functions ; begin
9781: LD_INT 0
9783: PPUSH
// mf_sol := [ f_class , class_soldier ] ;
9784: LD_ADDR_EXP 51
9788: PUSH
9789: LD_INT 25
9791: PUSH
9792: LD_INT 1
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// mf_eng := [ f_class , class_engineer ] ;
9799: LD_ADDR_EXP 52
9803: PUSH
9804: LD_INT 25
9806: PUSH
9807: LD_INT 2
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: ST_TO_ADDR
// mf_mec := [ f_class , class_mechanic ] ;
9814: LD_ADDR_EXP 53
9818: PUSH
9819: LD_INT 25
9821: PUSH
9822: LD_INT 3
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: ST_TO_ADDR
// mf_sci := [ f_class , class_scientistic ] ;
9829: LD_ADDR_EXP 54
9833: PUSH
9834: LD_INT 25
9836: PUSH
9837: LD_INT 4
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: ST_TO_ADDR
// mf_lab := [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ;
9844: LD_ADDR_EXP 55
9848: PUSH
9849: LD_INT 2
9851: PUSH
9852: LD_INT 30
9854: PUSH
9855: LD_INT 6
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PUSH
9862: LD_INT 30
9864: PUSH
9865: LD_INT 7
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: PUSH
9872: LD_INT 30
9874: PUSH
9875: LD_INT 8
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: LIST
9886: LIST
9887: ST_TO_ADDR
// mf_fort := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ;
9888: LD_ADDR_EXP 56
9892: PUSH
9893: LD_INT 2
9895: PUSH
9896: LD_INT 30
9898: PUSH
9899: LD_INT 32
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 30
9908: PUSH
9909: LD_INT 31
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PUSH
9916: LD_INT 30
9918: PUSH
9919: LD_INT 4
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PUSH
9926: LD_INT 30
9928: PUSH
9929: LD_INT 5
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: LIST
9942: ST_TO_ADDR
// mf_bunk := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ;
9943: LD_ADDR_EXP 57
9947: PUSH
9948: LD_INT 2
9950: PUSH
9951: LD_INT 30
9953: PUSH
9954: LD_INT 32
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: PUSH
9961: LD_INT 30
9963: PUSH
9964: LD_INT 31
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: ST_TO_ADDR
// mf_dep := [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ;
9976: LD_ADDR_EXP 58
9980: PUSH
9981: LD_INT 2
9983: PUSH
9984: LD_INT 30
9986: PUSH
9987: LD_INT 0
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PUSH
9994: LD_INT 30
9996: PUSH
9997: LD_INT 1
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PUSH
10004: EMPTY
10005: LIST
10006: LIST
10007: LIST
10008: ST_TO_ADDR
// mf_fact := [ f_or , [ f_btype , b_factory ] , [ f_btype , b_workshop ] ] ;
10009: LD_ADDR_EXP 59
10013: PUSH
10014: LD_INT 2
10016: PUSH
10017: LD_INT 30
10019: PUSH
10020: LD_INT 3
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 30
10029: PUSH
10030: LD_INT 2
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: LIST
10041: ST_TO_ADDR
// mf_comp := [ f_control , control_computer ] ;
10042: LD_ADDR_EXP 60
10046: PUSH
10047: LD_INT 33
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: ST_TO_ADDR
// mf_manu := [ f_control , control_manual ] ;
10057: LD_ADDR_EXP 61
10061: PUSH
10062: LD_INT 33
10064: PUSH
10065: LD_INT 1
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: ST_TO_ADDR
// end ;
10072: LD_VAR 0 1
10076: RET
// export function get_x_best ( lidi , num , skill , mclass , idle ) ; var i , skills ; begin
10077: LD_INT 0
10079: PPUSH
10080: PPUSH
10081: PPUSH
// if mclass then
10082: LD_VAR 0 4
10086: IFFALSE 10118
// lidi := UnitFilter ( lidi , [ [ f_class , mclass ] ] ) ;
10088: LD_ADDR_VAR 0 1
10092: PUSH
10093: LD_VAR 0 1
10097: PPUSH
10098: LD_INT 25
10100: PUSH
10101: LD_VAR 0 4
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: EMPTY
10111: LIST
10112: PPUSH
10113: CALL_OW 72
10117: ST_TO_ADDR
// skills := [ ] ;
10118: LD_ADDR_VAR 0 8
10122: PUSH
10123: EMPTY
10124: ST_TO_ADDR
// for i in lidi do
10125: LD_ADDR_VAR 0 7
10129: PUSH
10130: LD_VAR 0 1
10134: PUSH
10135: FOR_IN
10136: IFFALSE 10169
// skills := skills ^ [ GetSkill ( i , skill ) ] ;
10138: LD_ADDR_VAR 0 8
10142: PUSH
10143: LD_VAR 0 8
10147: PUSH
10148: LD_VAR 0 7
10152: PPUSH
10153: LD_VAR 0 3
10157: PPUSH
10158: CALL_OW 259
10162: PUSH
10163: EMPTY
10164: LIST
10165: ADD
10166: ST_TO_ADDR
10167: GO 10135
10169: POP
10170: POP
// lidi := SortListByListDesc ( lidi , skills ) ;
10171: LD_ADDR_VAR 0 1
10175: PUSH
10176: LD_VAR 0 1
10180: PPUSH
10181: LD_VAR 0 8
10185: PPUSH
10186: CALL_OW 77
10190: ST_TO_ADDR
// if num > lidi then
10191: LD_VAR 0 2
10195: PUSH
10196: LD_VAR 0 1
10200: GREATER
10201: IFFALSE 10217
// num := lidi + 0 ;
10203: LD_ADDR_VAR 0 2
10207: PUSH
10208: LD_VAR 0 1
10212: PUSH
10213: LD_INT 0
10215: PLUS
10216: ST_TO_ADDR
// i := 1 ;
10217: LD_ADDR_VAR 0 7
10221: PUSH
10222: LD_INT 1
10224: ST_TO_ADDR
// result := [ ] ;
10225: LD_ADDR_VAR 0 6
10229: PUSH
10230: EMPTY
10231: ST_TO_ADDR
// while i <= lidi and result < num do
10232: LD_VAR 0 7
10236: PUSH
10237: LD_VAR 0 1
10241: LESSEQUAL
10242: PUSH
10243: LD_VAR 0 6
10247: PUSH
10248: LD_VAR 0 2
10252: LESS
10253: AND
10254: IFFALSE 10347
// begin if idle then
10256: LD_VAR 0 5
10260: IFFALSE 10306
// begin if IsIdle ( lidi [ i ] ) then
10262: LD_VAR 0 1
10266: PUSH
10267: LD_VAR 0 7
10271: ARRAY
10272: PPUSH
10273: CALL_OW 316
10277: IFFALSE 10304
// result := result ^ [ lidi [ i ] ] ;
10279: LD_ADDR_VAR 0 6
10283: PUSH
10284: LD_VAR 0 6
10288: PUSH
10289: LD_VAR 0 1
10293: PUSH
10294: LD_VAR 0 7
10298: ARRAY
10299: PUSH
10300: EMPTY
10301: LIST
10302: ADD
10303: ST_TO_ADDR
// end else
10304: GO 10331
// result := result ^ [ lidi [ i ] ] ;
10306: LD_ADDR_VAR 0 6
10310: PUSH
10311: LD_VAR 0 6
10315: PUSH
10316: LD_VAR 0 1
10320: PUSH
10321: LD_VAR 0 7
10325: ARRAY
10326: PUSH
10327: EMPTY
10328: LIST
10329: ADD
10330: ST_TO_ADDR
// i := i + 1 ;
10331: LD_ADDR_VAR 0 7
10335: PUSH
10336: LD_VAR 0 7
10340: PUSH
10341: LD_INT 1
10343: PLUS
10344: ST_TO_ADDR
// end ;
10345: GO 10232
// end ;
10347: LD_VAR 0 6
10351: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
10352: LD_INT 0
10354: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
10355: LD_ADDR_VAR 0 1
10359: PUSH
10360: LD_VAR 0 1
10364: PPUSH
10365: LD_INT 21
10367: PUSH
10368: LD_INT 1
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: PUSH
10375: LD_INT 22
10377: PUSH
10378: LD_VAR 0 2
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 3
10389: PUSH
10390: LD_INT 23
10392: PUSH
10393: LD_INT 0
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: PPUSH
10406: CALL_OW 72
10410: ST_TO_ADDR
// if sex <> 0 then
10411: LD_VAR 0 3
10415: PUSH
10416: LD_INT 0
10418: NONEQUAL
10419: IFFALSE 10448
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
10421: LD_ADDR_VAR 0 1
10425: PUSH
10426: LD_VAR 0 1
10430: PPUSH
10431: LD_INT 26
10433: PUSH
10434: LD_VAR 0 3
10438: PUSH
10439: EMPTY
10440: LIST
10441: LIST
10442: PPUSH
10443: CALL_OW 72
10447: ST_TO_ADDR
// if Hclass <> 0 then
10448: LD_VAR 0 4
10452: PUSH
10453: LD_INT 0
10455: NONEQUAL
10456: IFFALSE 10485
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
10458: LD_ADDR_VAR 0 1
10462: PUSH
10463: LD_VAR 0 1
10467: PPUSH
10468: LD_INT 25
10470: PUSH
10471: LD_VAR 0 4
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 72
10484: ST_TO_ADDR
// if index <= 0 then
10485: LD_VAR 0 5
10489: PUSH
10490: LD_INT 0
10492: LESSEQUAL
10493: IFFALSE 10503
// index := 1 ;
10495: LD_ADDR_VAR 0 5
10499: PUSH
10500: LD_INT 1
10502: ST_TO_ADDR
// if lidi >= index then
10503: LD_VAR 0 1
10507: PUSH
10508: LD_VAR 0 5
10512: GREATEREQUAL
10513: IFFALSE 10533
// result := lidi [ index ] else
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: LD_VAR 0 1
10524: PUSH
10525: LD_VAR 0 5
10529: ARRAY
10530: ST_TO_ADDR
10531: GO 10541
// result := 0 ;
10533: LD_ADDR_VAR 0 6
10537: PUSH
10538: LD_INT 0
10540: ST_TO_ADDR
// end ;
10541: LD_VAR 0 6
10545: RET
// export function see_any ( strana , sez ) ; var i ; begin
10546: LD_INT 0
10548: PPUSH
10549: PPUSH
// result := [ ] ;
10550: LD_ADDR_VAR 0 3
10554: PUSH
10555: EMPTY
10556: ST_TO_ADDR
// for i in sez do
10557: LD_ADDR_VAR 0 4
10561: PUSH
10562: LD_VAR 0 2
10566: PUSH
10567: FOR_IN
10568: IFFALSE 10604
// if See ( strana , i ) then
10570: LD_VAR 0 1
10574: PPUSH
10575: LD_VAR 0 4
10579: PPUSH
10580: CALL_OW 292
10584: IFFALSE 10602
// begin result := result ^ i ;
10586: LD_ADDR_VAR 0 3
10590: PUSH
10591: LD_VAR 0 3
10595: PUSH
10596: LD_VAR 0 4
10600: ADD
10601: ST_TO_ADDR
// end ;
10602: GO 10567
10604: POP
10605: POP
// ; end ;
10606: LD_VAR 0 3
10610: RET
// export function TalkOn ; begin
10611: LD_INT 0
10613: PPUSH
// stop_talking := true ;
10614: LD_ADDR_OWVAR 56
10618: PUSH
10619: LD_INT 1
10621: ST_TO_ADDR
// end ;
10622: LD_VAR 0 1
10626: RET
// export function TalkOff ; begin
10627: LD_INT 0
10629: PPUSH
// stop_talking := false ;
10630: LD_ADDR_OWVAR 56
10634: PUSH
10635: LD_INT 0
10637: ST_TO_ADDR
// end ;
10638: LD_VAR 0 1
10642: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
10643: LD_INT 0
10645: PPUSH
10646: PPUSH
10647: PPUSH
// result := [ ] ;
10648: LD_ADDR_VAR 0 3
10652: PUSH
10653: EMPTY
10654: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ f_side , you ] ) ;
10655: LD_ADDR_VAR 0 4
10659: PUSH
10660: LD_VAR 0 1
10664: PPUSH
10665: LD_INT 22
10667: PUSH
10668: LD_EXP 7
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PPUSH
10677: CALL_OW 70
10681: ST_TO_ADDR
// for i in inbase do
10682: LD_ADDR_VAR 0 5
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: FOR_IN
10693: IFFALSE 10766
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
10695: LD_VAR 0 5
10699: PPUSH
10700: CALL_OW 247
10704: PUSH
10705: LD_INT 3
10707: EQUAL
10708: PUSH
10709: LD_VAR 0 5
10713: PPUSH
10714: CALL_OW 247
10718: PUSH
10719: LD_INT 2
10721: EQUAL
10722: OR
10723: IFFALSE 10748
// begin result := result ^ UnitsInside ( i ) ;
10725: LD_ADDR_VAR 0 3
10729: PUSH
10730: LD_VAR 0 3
10734: PUSH
10735: LD_VAR 0 5
10739: PPUSH
10740: CALL_OW 313
10744: ADD
10745: ST_TO_ADDR
// end else
10746: GO 10764
// begin result := result ^ i ;
10748: LD_ADDR_VAR 0 3
10752: PUSH
10753: LD_VAR 0 3
10757: PUSH
10758: LD_VAR 0 5
10762: ADD
10763: ST_TO_ADDR
// end ; end ;
10764: GO 10692
10766: POP
10767: POP
// result := UnitFilter ( result , filter ) ;
10768: LD_ADDR_VAR 0 3
10772: PUSH
10773: LD_VAR 0 3
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: CALL_OW 72
10787: ST_TO_ADDR
// end ;
10788: LD_VAR 0 3
10792: RET
// export function inside_units ( uns ) ; var i ; begin
10793: LD_INT 0
10795: PPUSH
10796: PPUSH
// result := [ ] ;
10797: LD_ADDR_VAR 0 2
10801: PUSH
10802: EMPTY
10803: ST_TO_ADDR
// for i in uns do
10804: LD_ADDR_VAR 0 3
10808: PUSH
10809: LD_VAR 0 1
10813: PUSH
10814: FOR_IN
10815: IFFALSE 10840
// result := result ^ UnitsInside ( i ) ;
10817: LD_ADDR_VAR 0 2
10821: PUSH
10822: LD_VAR 0 2
10826: PUSH
10827: LD_VAR 0 3
10831: PPUSH
10832: CALL_OW 313
10836: ADD
10837: ST_TO_ADDR
10838: GO 10814
10840: POP
10841: POP
// end ;
10842: LD_VAR 0 2
10846: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
10847: LD_INT 0
10849: PPUSH
10850: PPUSH
10851: PPUSH
10852: PPUSH
10853: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
10854: LD_ADDR_VAR 0 1
10858: PUSH
10859: LD_VAR 0 1
10863: PPUSH
10864: LD_INT 51
10866: PUSH
10867: EMPTY
10868: LIST
10869: PPUSH
10870: CALL_OW 72
10874: PUSH
10875: EMPTY
10876: UNION
10877: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
10878: LD_ADDR_VAR 0 2
10882: PUSH
10883: LD_VAR 0 2
10887: PPUSH
10888: LD_INT 51
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL_OW 72
10898: PUSH
10899: EMPTY
10900: UNION
10901: ST_TO_ADDR
// for i in cars do
10902: LD_ADDR_VAR 0 7
10906: PUSH
10907: LD_VAR 0 1
10911: PUSH
10912: FOR_IN
10913: IFFALSE 10948
// if not IsDrivenBy ( i ) then
10915: LD_VAR 0 7
10919: PPUSH
10920: CALL_OW 311
10924: NOT
10925: IFFALSE 10946
// empty := empty ^ [ i ] ;
10927: LD_ADDR_VAR 0 5
10931: PUSH
10932: LD_VAR 0 5
10936: PUSH
10937: LD_VAR 0 7
10941: PUSH
10942: EMPTY
10943: LIST
10944: ADD
10945: ST_TO_ADDR
10946: GO 10912
10948: POP
10949: POP
// if take_out then
10950: LD_VAR 0 3
10954: IFFALSE 11012
// begin for i in drivers do
10956: LD_ADDR_VAR 0 7
10960: PUSH
10961: LD_VAR 0 2
10965: PUSH
10966: FOR_IN
10967: IFFALSE 11008
// if not ( IsInUnit ( i ) in cars ) then
10969: LD_VAR 0 7
10973: PPUSH
10974: CALL_OW 310
10978: PUSH
10979: LD_VAR 0 1
10983: IN
10984: NOT
10985: IFFALSE 11006
// free := free ^ [ i ] ;
10987: LD_ADDR_VAR 0 6
10991: PUSH
10992: LD_VAR 0 6
10996: PUSH
10997: LD_VAR 0 7
11001: PUSH
11002: EMPTY
11003: LIST
11004: ADD
11005: ST_TO_ADDR
11006: GO 10966
11008: POP
11009: POP
// end else
11010: GO 11060
// begin for i in drivers do
11012: LD_ADDR_VAR 0 7
11016: PUSH
11017: LD_VAR 0 2
11021: PUSH
11022: FOR_IN
11023: IFFALSE 11058
// if not IsInUnit ( i ) then
11025: LD_VAR 0 7
11029: PPUSH
11030: CALL_OW 310
11034: NOT
11035: IFFALSE 11056
// free := free ^ [ i ] ;
11037: LD_ADDR_VAR 0 6
11041: PUSH
11042: LD_VAR 0 6
11046: PUSH
11047: LD_VAR 0 7
11051: PUSH
11052: EMPTY
11053: LIST
11054: ADD
11055: ST_TO_ADDR
11056: GO 11022
11058: POP
11059: POP
// end ; result := cars diff empty ;
11060: LD_ADDR_VAR 0 4
11064: PUSH
11065: LD_VAR 0 1
11069: PUSH
11070: LD_VAR 0 5
11074: DIFF
11075: ST_TO_ADDR
// if empty <= free then
11076: LD_VAR 0 5
11080: PUSH
11081: LD_VAR 0 6
11085: LESSEQUAL
11086: IFFALSE 11100
// konec := empty else
11088: LD_ADDR_VAR 0 8
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
11098: GO 11110
// konec := free ;
11100: LD_ADDR_VAR 0 8
11104: PUSH
11105: LD_VAR 0 6
11109: ST_TO_ADDR
// for i := 1 to konec do
11110: LD_ADDR_VAR 0 7
11114: PUSH
11115: DOUBLE
11116: LD_INT 1
11118: DEC
11119: ST_TO_ADDR
11120: LD_VAR 0 8
11124: PUSH
11125: FOR_TO
11126: IFFALSE 11181
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
11128: LD_VAR 0 6
11132: PUSH
11133: LD_VAR 0 7
11137: ARRAY
11138: PPUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_VAR 0 7
11148: ARRAY
11149: PPUSH
11150: CALL_OW 120
// result := result ^ [ empty [ i ] ] ;
11154: LD_ADDR_VAR 0 4
11158: PUSH
11159: LD_VAR 0 4
11163: PUSH
11164: LD_VAR 0 5
11168: PUSH
11169: LD_VAR 0 7
11173: ARRAY
11174: PUSH
11175: EMPTY
11176: LIST
11177: ADD
11178: ST_TO_ADDR
// end ;
11179: GO 11125
11181: POP
11182: POP
// end ;
11183: LD_VAR 0 4
11187: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
11188: LD_INT 0
11190: PPUSH
11191: PPUSH
11192: PPUSH
// while remotes > mechs do
11193: LD_VAR 0 3
11197: PUSH
11198: LD_VAR 0 2
11202: GREATER
11203: IFFALSE 11219
// delete ( remotes , 1 ) ;
11205: LD_VAR 0 3
11209: PPUSH
11210: LD_INT 1
11212: PPUSH
11213: CALL_OW 3
11217: GO 11193
// for i := 1 to remotes do
11219: LD_ADDR_VAR 0 6
11223: PUSH
11224: DOUBLE
11225: LD_INT 1
11227: DEC
11228: ST_TO_ADDR
11229: LD_VAR 0 3
11233: PUSH
11234: FOR_TO
11235: IFFALSE 11265
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
11237: LD_VAR 0 2
11241: PUSH
11242: LD_VAR 0 6
11246: ARRAY
11247: PPUSH
11248: LD_VAR 0 3
11252: PUSH
11253: LD_VAR 0 6
11257: ARRAY
11258: PPUSH
11259: CALL_OW 120
11263: GO 11234
11265: POP
11266: POP
// end ;
11267: LD_VAR 0 4
11271: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
11272: LD_INT 0
11274: PPUSH
11275: PPUSH
11276: PPUSH
11277: PPUSH
// c := tick + cas ;
11278: LD_ADDR_VAR 0 5
11282: PUSH
11283: LD_OWVAR 1
11287: PUSH
11288: LD_VAR 0 3
11292: PLUS
11293: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
11294: LD_OWVAR 1
11298: PUSH
11299: LD_VAR 0 5
11303: LESS
11304: PUSH
11305: LD_VAR 0 2
11309: PPUSH
11310: CALL 10793 0 1
11314: PUSH
11315: LD_INT 0
11317: PLUS
11318: PUSH
11319: LD_VAR 0 2
11323: EQUAL
11324: NOT
11325: AND
11326: IFFALSE 11337
// wait ( 0 0$1 ) ;
11328: LD_INT 35
11330: PPUSH
11331: CALL_OW 67
11335: GO 11294
// unlinked := cars ;
11337: LD_ADDR_VAR 0 6
11341: PUSH
11342: LD_VAR 0 1
11346: ST_TO_ADDR
// for i in remotes do
11347: LD_ADDR_VAR 0 7
11351: PUSH
11352: LD_VAR 0 2
11356: PUSH
11357: FOR_IN
11358: IFFALSE 11407
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
11360: LD_VAR 0 6
11364: PPUSH
11365: LD_VAR 0 7
11369: PPUSH
11370: CALL_OW 313
11374: PPUSH
11375: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
11379: LD_ADDR_VAR 0 6
11383: PUSH
11384: LD_VAR 0 6
11388: PUSH
11389: LD_VAR 0 7
11393: PPUSH
11394: CALL_OW 313
11398: PPUSH
11399: CALL_OW 432
11403: DIFF
11404: ST_TO_ADDR
// end ;
11405: GO 11357
11407: POP
11408: POP
// end ;
11409: LD_VAR 0 4
11413: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , k , pockat ; begin
11414: LD_INT 0
11416: PPUSH
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
// k := 0 ;
11421: LD_ADDR_VAR 0 6
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// pockat := tick + cas ;
11429: LD_ADDR_VAR 0 7
11433: PUSH
11434: LD_OWVAR 1
11438: PUSH
11439: LD_VAR 0 2
11443: PLUS
11444: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
11445: LD_VAR 0 5
11449: NOT
11450: PUSH
11451: LD_OWVAR 1
11455: PUSH
11456: LD_VAR 0 7
11460: LESS
11461: AND
11462: IFFALSE 11532
// begin vsichni_ready := true ;
11464: LD_ADDR_VAR 0 5
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// k := k + 1 ;
11472: LD_ADDR_VAR 0 6
11476: PUSH
11477: LD_VAR 0 6
11481: PUSH
11482: LD_INT 1
11484: PLUS
11485: ST_TO_ADDR
// for i in cars do
11486: LD_ADDR_VAR 0 4
11490: PUSH
11491: LD_VAR 0 1
11495: PUSH
11496: FOR_IN
11497: IFFALSE 11521
// if not IsDrivenBy ( i ) then
11499: LD_VAR 0 4
11503: PPUSH
11504: CALL_OW 311
11508: NOT
11509: IFFALSE 11519
// vsichni_ready := false ;
11511: LD_ADDR_VAR 0 5
11515: PUSH
11516: LD_INT 0
11518: ST_TO_ADDR
11519: GO 11496
11521: POP
11522: POP
// wait ( 0 0$1.0 ) ;
11523: LD_INT 35
11525: PPUSH
11526: CALL_OW 67
// end ;
11530: GO 11445
// end ;
11532: LD_VAR 0 3
11536: RET
// export function rev ( list ) ; var i ; begin
11537: LD_INT 0
11539: PPUSH
11540: PPUSH
// for i := list + 0 to 1 do
11541: LD_ADDR_VAR 0 3
11545: PUSH
11546: DOUBLE
11547: LD_VAR 0 1
11551: PUSH
11552: LD_INT 0
11554: PLUS
11555: DEC
11556: ST_TO_ADDR
11557: LD_INT 1
11559: PUSH
11560: FOR_TO
11561: IFFALSE 11590
// result := result ^ [ list [ i ] ] ;
11563: LD_ADDR_VAR 0 2
11567: PUSH
11568: LD_VAR 0 2
11572: PUSH
11573: LD_VAR 0 1
11577: PUSH
11578: LD_VAR 0 3
11582: ARRAY
11583: PUSH
11584: EMPTY
11585: LIST
11586: ADD
11587: ST_TO_ADDR
11588: GO 11560
11590: POP
11591: POP
// end ; end_of_file
11592: LD_VAR 0 2
11596: RET
// export under_attack ; export near_base_area ; export function inicializace_ai_defend ; begin
11597: LD_INT 0
11599: PPUSH
// under_attack := [ false , false , false , false , false ] ;
11600: LD_ADDR_EXP 62
11604: PUSH
11605: LD_INT 0
11607: PUSH
11608: LD_INT 0
11610: PUSH
11611: LD_INT 0
11613: PUSH
11614: LD_INT 0
11616: PUSH
11617: LD_INT 0
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: ST_TO_ADDR
// near_base_area := [ nearA , nearB , nearC , nearD , nearE ] ;
11627: LD_ADDR_EXP 63
11631: PUSH
11632: LD_INT 24
11634: PUSH
11635: LD_INT 25
11637: PUSH
11638: LD_INT 26
11640: PUSH
11641: LD_INT 27
11643: PUSH
11644: LD_INT 28
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: ST_TO_ADDR
// end ;
11654: LD_VAR 0 1
11658: RET
// export BehMcRegId , BehMcAttId ; export function BehemothUtok ; begin
11659: LD_INT 0
11661: PPUSH
// BehMcRegId := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11662: LD_ADDR_EXP 64
11666: PUSH
11667: LD_EXP 23
11671: PUSH
11672: LD_INT 1
11674: ARRAY
11675: PPUSH
11676: LD_INT 1
11678: PUSH
11679: LD_INT 140
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: PUSH
11686: LD_INT 4
11688: PUSH
11689: LD_EXP 42
11693: PUSH
11694: EMPTY
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 10
11703: PUSH
11704: LD_EXP 41
11708: PUSH
11709: EMPTY
11710: LIST
11711: PUSH
11712: EMPTY
11713: LIST
11714: LIST
11715: PUSH
11716: LD_INT 3
11718: PUSH
11719: LD_EXP 63
11723: PUSH
11724: LD_EXP 25
11728: ARRAY
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 7
11736: PUSH
11737: LD_INT 8
11739: NEG
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: PPUSH
11749: CALL_OW 399
11753: ST_TO_ADDR
// BehMcAttId := McAttack ( 12 , BehMcRegId , [ behemoth ] , [ [ mc_retreat_area_vehicles , nearA ] , [ mc_retreat_area_people , nearA ] , [ mc_retreat_lives_vehicles , 600 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11754: LD_ADDR_EXP 65
11758: PUSH
11759: LD_INT 12
11761: PPUSH
11762: LD_EXP 64
11766: PPUSH
11767: LD_INT 125
11769: PUSH
11770: EMPTY
11771: LIST
11772: PPUSH
11773: LD_INT 8
11775: PUSH
11776: LD_INT 24
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 7
11785: PUSH
11786: LD_INT 24
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: LD_INT 6
11795: PUSH
11796: LD_INT 600
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PUSH
11803: LD_INT 5
11805: PUSH
11806: LD_INT 800
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: PUSH
11813: LD_INT 10
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: PPUSH
11823: CALL_OW 402
11827: ST_TO_ADDR
// end ;
11828: LD_VAR 0 1
11832: RET
// export ZouMcRegId , ZouMcAttId ; export function ZoufalUtok ; begin
11833: LD_INT 0
11835: PPUSH
// ZouMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11836: LD_ADDR_EXP 66
11840: PUSH
11841: LD_EXP 23
11845: PUSH
11846: LD_EXP 25
11850: ARRAY
11851: PPUSH
11852: LD_INT 1
11854: PUSH
11855: LD_INT 140
11857: PUSH
11858: EMPTY
11859: LIST
11860: LIST
11861: PUSH
11862: LD_INT 4
11864: PUSH
11865: LD_EXP 42
11869: PUSH
11870: EMPTY
11871: LIST
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 10
11879: PUSH
11880: LD_EXP 41
11884: PUSH
11885: EMPTY
11886: LIST
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 3
11894: PUSH
11895: LD_EXP 63
11899: PUSH
11900: LD_EXP 25
11904: ARRAY
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 7
11912: PUSH
11913: LD_INT 8
11915: NEG
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: LIST
11924: PPUSH
11925: CALL_OW 399
11929: ST_TO_ADDR
// ZouMcAttId := McAttack ( 12 , ZouMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11930: LD_ADDR_EXP 67
11934: PUSH
11935: LD_INT 12
11937: PPUSH
11938: LD_EXP 66
11942: PPUSH
11943: LD_EXP 77
11947: PUSH
11948: LD_EXP 25
11952: ARRAY
11953: PPUSH
11954: LD_INT 8
11956: PUSH
11957: LD_EXP 63
11961: PUSH
11962: LD_EXP 25
11966: ARRAY
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 7
11974: PUSH
11975: LD_EXP 63
11979: PUSH
11980: LD_EXP 25
11984: ARRAY
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 6
11992: PUSH
11993: LD_INT 100
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: LD_INT 5
12002: PUSH
12003: LD_INT 800
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 10
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: PPUSH
12020: CALL_OW 402
12024: ST_TO_ADDR
// end ;
12025: LD_VAR 0 1
12029: RET
// export NorMcRegId , NorMcAttId ; export function NormalUtok ; begin
12030: LD_INT 0
12032: PPUSH
// NorMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ your_humans ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
12033: LD_ADDR_EXP 68
12037: PUSH
12038: LD_EXP 23
12042: PUSH
12043: LD_EXP 25
12047: ARRAY
12048: PPUSH
12049: LD_INT 1
12051: PUSH
12052: LD_INT 140
12054: PUSH
12055: EMPTY
12056: LIST
12057: LIST
12058: PUSH
12059: LD_INT 4
12061: PUSH
12062: LD_EXP 42
12066: PUSH
12067: EMPTY
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 10
12076: PUSH
12077: LD_EXP 37
12081: PUSH
12082: EMPTY
12083: LIST
12084: PUSH
12085: EMPTY
12086: LIST
12087: LIST
12088: PUSH
12089: LD_INT 3
12091: PUSH
12092: LD_EXP 63
12096: PUSH
12097: LD_EXP 25
12101: ARRAY
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 7
12109: PUSH
12110: LD_INT 8
12112: NEG
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: PPUSH
12122: CALL_OW 399
12126: ST_TO_ADDR
// NorMcAttId := McAttack ( 12 , NorMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12127: LD_ADDR_EXP 69
12131: PUSH
12132: LD_INT 12
12134: PPUSH
12135: LD_EXP 68
12139: PPUSH
12140: LD_EXP 77
12144: PUSH
12145: LD_EXP 25
12149: ARRAY
12150: PPUSH
12151: LD_INT 8
12153: PUSH
12154: LD_EXP 63
12158: PUSH
12159: LD_EXP 25
12163: ARRAY
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 7
12171: PUSH
12172: LD_EXP 63
12176: PUSH
12177: LD_EXP 25
12181: ARRAY
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 6
12189: PUSH
12190: LD_INT 100
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 5
12199: PUSH
12200: LD_INT 800
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 10
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: PPUSH
12217: CALL_OW 402
12221: ST_TO_ADDR
// end ;
12222: LD_VAR 0 1
12226: RET
// function utok_na_vetrelce ( vetrelci , index_strany ) ; var nearest , units ; begin
12227: LD_INT 0
12229: PPUSH
12230: PPUSH
12231: PPUSH
// if vetrelci and ( ai_s [ index_strany ] in aiZ ) then
12232: LD_VAR 0 1
12236: PUSH
12237: LD_EXP 23
12241: PUSH
12242: LD_VAR 0 2
12246: ARRAY
12247: PUSH
12248: LD_EXP 21
12252: IN
12253: AND
12254: IFFALSE 12357
// begin nearest := NearestUnitToUnit ( vetrelci , depots [ index_strany ] ) ;
12256: LD_ADDR_VAR 0 4
12260: PUSH
12261: LD_VAR 0 1
12265: PPUSH
12266: LD_EXP 74
12270: PUSH
12271: LD_VAR 0 2
12275: ARRAY
12276: PPUSH
12277: CALL_OW 74
12281: ST_TO_ADDR
// if nearest then
12282: LD_VAR 0 4
12286: IFFALSE 12357
// begin units := attack_units isect vehicles [ index_strany ] ;
12288: LD_ADDR_VAR 0 5
12292: PUSH
12293: LD_EXP 78
12297: PUSH
12298: LD_EXP 77
12302: PUSH
12303: LD_VAR 0 2
12307: ARRAY
12308: ISECT
12309: ST_TO_ADDR
// ComRemember ( units ) ;
12310: LD_VAR 0 5
12314: PPUSH
12315: CALL_OW 143
// AddComAgressiveMove ( units , GetX ( nearest ) , GetY ( nearest ) ) ;
12319: LD_VAR 0 5
12323: PPUSH
12324: LD_VAR 0 4
12328: PPUSH
12329: CALL_OW 250
12333: PPUSH
12334: LD_VAR 0 4
12338: PPUSH
12339: CALL_OW 251
12343: PPUSH
12344: CALL_OW 174
// AddComReturn ( units ) ;
12348: LD_VAR 0 5
12352: PPUSH
12353: CALL_OW 204
// end ; end ; end ;
12357: LD_VAR 0 3
12361: RET
// every 0 0$10 do var i , a ;
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
12368: PPUSH
// begin for i := 1 to 5 do
12369: LD_ADDR_VAR 0 1
12373: PUSH
12374: DOUBLE
12375: LD_INT 1
12377: DEC
12378: ST_TO_ADDR
12379: LD_INT 5
12381: PUSH
12382: FOR_TO
12383: IFFALSE 12522
// begin a := UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ i ] ] ] ) ;
12385: LD_ADDR_VAR 0 2
12389: PUSH
12390: LD_EXP 37
12394: PUSH
12395: LD_EXP 35
12399: ADD
12400: PPUSH
12401: LD_INT 95
12403: PUSH
12404: LD_EXP 63
12408: PUSH
12409: LD_VAR 0 1
12413: ARRAY
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PUSH
12419: EMPTY
12420: LIST
12421: PPUSH
12422: CALL_OW 72
12426: ST_TO_ADDR
// if a and ai_s [ i ] in aiZ then
12427: LD_VAR 0 2
12431: PUSH
12432: LD_EXP 23
12436: PUSH
12437: LD_VAR 0 1
12441: ARRAY
12442: PUSH
12443: LD_EXP 21
12447: IN
12448: AND
12449: IFFALSE 12490
// begin under_attack := replace ( under_attack , i , true ) ;
12451: LD_ADDR_EXP 62
12455: PUSH
12456: LD_EXP 62
12460: PPUSH
12461: LD_VAR 0 1
12465: PPUSH
12466: LD_INT 1
12468: PPUSH
12469: CALL_OW 1
12473: ST_TO_ADDR
// utok_na_vetrelce ( a , i ) ;
12474: LD_VAR 0 2
12478: PPUSH
12479: LD_VAR 0 1
12483: PPUSH
12484: CALL 12227 0 2
// end else
12488: GO 12513
// under_attack := replace ( under_attack , i , false ) ;
12490: LD_ADDR_EXP 62
12494: PUSH
12495: LD_EXP 62
12499: PPUSH
12500: LD_VAR 0 1
12504: PPUSH
12505: LD_INT 0
12507: PPUSH
12508: CALL_OW 1
12512: ST_TO_ADDR
// wait ( 0 0$2 ) ;
12513: LD_INT 70
12515: PPUSH
12516: CALL_OW 67
// end ;
12520: GO 12382
12522: POP
12523: POP
// enable ;
12524: ENABLE
// end ; end_of_file
12525: PPOPN 2
12527: END
// var repair_site ; export rc ; export bc ; export function inicializace_ai_c_repair ; begin
12528: LD_INT 0
12530: PPUSH
// repair_site := [ [ 30 , 29 ] , [ 89 , 17 ] , [ 72 , 125 ] , [ 215 , 140 ] , [ 184 , 85 ] ] ;
12531: LD_ADDR_LOC 16
12535: PUSH
12536: LD_INT 30
12538: PUSH
12539: LD_INT 29
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 89
12548: PUSH
12549: LD_INT 17
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 72
12558: PUSH
12559: LD_INT 125
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 215
12568: PUSH
12569: LD_INT 140
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: LD_INT 184
12578: PUSH
12579: LD_INT 85
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: ST_TO_ADDR
// bc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12593: LD_ADDR_EXP 71
12597: PUSH
12598: EMPTY
12599: PUSH
12600: EMPTY
12601: PUSH
12602: EMPTY
12603: PUSH
12604: EMPTY
12605: PUSH
12606: EMPTY
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: ST_TO_ADDR
// rc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12615: LD_ADDR_EXP 70
12619: PUSH
12620: EMPTY
12621: PUSH
12622: EMPTY
12623: PUSH
12624: EMPTY
12625: PUSH
12626: EMPTY
12627: PUSH
12628: EMPTY
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: ST_TO_ADDR
// end ;
12637: LD_VAR 0 1
12641: RET
// every 0 0$5.0 + 0 0$0.5 do var i ;
12642: GO 12644
12644: DISABLE
12645: LD_INT 0
12647: PPUSH
// begin for i := 1 to 5 do
12648: LD_ADDR_VAR 0 1
12652: PUSH
12653: DOUBLE
12654: LD_INT 1
12656: DEC
12657: ST_TO_ADDR
12658: LD_INT 5
12660: PUSH
12661: FOR_TO
12662: IFFALSE 12717
// if ai_s [ i ] in ai then
12664: LD_EXP 23
12668: PUSH
12669: LD_VAR 0 1
12673: ARRAY
12674: PUSH
12675: LD_EXP 24
12679: IN
12680: IFFALSE 12715
// begin dop_pal ( vehicles [ i ] , depots [ i ] ) ;
12682: LD_EXP 77
12686: PUSH
12687: LD_VAR 0 1
12691: ARRAY
12692: PPUSH
12693: LD_EXP 74
12697: PUSH
12698: LD_VAR 0 1
12702: ARRAY
12703: PPUSH
12704: CALL 12723 0 2
// wait ( 0 0$1 ) ;
12708: LD_INT 35
12710: PPUSH
12711: CALL_OW 67
// end ;
12715: GO 12661
12717: POP
12718: POP
// enable ;
12719: ENABLE
// end ;
12720: PPOPN 1
12722: END
// function dop_pal ( tc , tdep ) ; var set_fuel , fuel ; begin
12723: LD_INT 0
12725: PPUSH
12726: PPUSH
12727: PPUSH
// for set_fuel in UnitFilter ( tc , [ [ f_dist , tdep , 40 ] ] ) do
12728: LD_ADDR_VAR 0 4
12732: PUSH
12733: LD_VAR 0 1
12737: PPUSH
12738: LD_INT 91
12740: PUSH
12741: LD_VAR 0 2
12745: PUSH
12746: LD_INT 40
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: LIST
12753: PUSH
12754: EMPTY
12755: LIST
12756: PPUSH
12757: CALL_OW 72
12761: PUSH
12762: FOR_IN
12763: IFFALSE 12810
// begin fuel := GetFuel ( set_fuel ) ;
12765: LD_ADDR_VAR 0 5
12769: PUSH
12770: LD_VAR 0 4
12774: PPUSH
12775: CALL_OW 261
12779: ST_TO_ADDR
// if fuel <= 80 then
12780: LD_VAR 0 5
12784: PUSH
12785: LD_INT 80
12787: LESSEQUAL
12788: IFFALSE 12808
// SetFuel ( set_fuel , fuel + 20 ) ;
12790: LD_VAR 0 4
12794: PPUSH
12795: LD_VAR 0 5
12799: PUSH
12800: LD_INT 20
12802: PLUS
12803: PPUSH
12804: CALL_OW 240
// end ;
12808: GO 12762
12810: POP
12811: POP
// end ;
12812: LD_VAR 0 3
12816: RET
// every 0 0$5 + 0 0$0.3 do var zivoty , i , rem_t , add_t , k ;
12817: GO 12819
12819: DISABLE
12820: LD_INT 0
12822: PPUSH
12823: PPUSH
12824: PPUSH
12825: PPUSH
12826: PPUSH
// begin for k := 1 to 5 do
12827: LD_ADDR_VAR 0 5
12831: PUSH
12832: DOUBLE
12833: LD_INT 1
12835: DEC
12836: ST_TO_ADDR
12837: LD_INT 5
12839: PUSH
12840: FOR_TO
12841: IFFALSE 13159
// if ai_s [ k ] in ai then
12843: LD_EXP 23
12847: PUSH
12848: LD_VAR 0 5
12852: ARRAY
12853: PUSH
12854: LD_EXP 24
12858: IN
12859: IFFALSE 13135
// begin rem_t := [ ] ;
12861: LD_ADDR_VAR 0 3
12865: PUSH
12866: EMPTY
12867: ST_TO_ADDR
// add_t := [ ] ;
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: EMPTY
12874: ST_TO_ADDR
// for i in UnitFilter ( vehicles [ k ] , [ [ f_not , [ f_side , you ] ] ] ) do
12875: LD_ADDR_VAR 0 2
12879: PUSH
12880: LD_EXP 77
12884: PUSH
12885: LD_VAR 0 5
12889: ARRAY
12890: PPUSH
12891: LD_INT 3
12893: PUSH
12894: LD_INT 22
12896: PUSH
12897: LD_EXP 7
12901: PUSH
12902: EMPTY
12903: LIST
12904: LIST
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: PUSH
12910: EMPTY
12911: LIST
12912: PPUSH
12913: CALL_OW 72
12917: PUSH
12918: FOR_IN
12919: IFFALSE 12987
// begin if GetLives ( i ) < 500 then
12921: LD_VAR 0 2
12925: PPUSH
12926: CALL_OW 256
12930: PUSH
12931: LD_INT 500
12933: LESS
12934: IFFALSE 12954
// begin rem_t := rem_t ^ i ;
12936: LD_ADDR_VAR 0 3
12940: PUSH
12941: LD_VAR 0 3
12945: PUSH
12946: LD_VAR 0 2
12950: ADD
12951: ST_TO_ADDR
// end else
12952: GO 12985
// if GetLives ( i ) >= 950 then
12954: LD_VAR 0 2
12958: PPUSH
12959: CALL_OW 256
12963: PUSH
12964: LD_INT 950
12966: GREATEREQUAL
12967: IFFALSE 12985
// begin add_t := add_t ^ i ;
12969: LD_ADDR_VAR 0 4
12973: PUSH
12974: LD_VAR 0 4
12978: PUSH
12979: LD_VAR 0 2
12983: ADD
12984: ST_TO_ADDR
// end ; end ;
12985: GO 12918
12987: POP
12988: POP
// bc := replace ( bc , k , bc [ k ] union rem_t ) ;
12989: LD_ADDR_EXP 71
12993: PUSH
12994: LD_EXP 71
12998: PPUSH
12999: LD_VAR 0 5
13003: PPUSH
13004: LD_EXP 71
13008: PUSH
13009: LD_VAR 0 5
13013: ARRAY
13014: PUSH
13015: LD_VAR 0 3
13019: UNION
13020: PPUSH
13021: CALL_OW 1
13025: ST_TO_ADDR
// bc := replace ( bc , k , bc [ k ] diff add_t ) ;
13026: LD_ADDR_EXP 71
13030: PUSH
13031: LD_EXP 71
13035: PPUSH
13036: LD_VAR 0 5
13040: PPUSH
13041: LD_EXP 71
13045: PUSH
13046: LD_VAR 0 5
13050: ARRAY
13051: PUSH
13052: LD_VAR 0 4
13056: DIFF
13057: PPUSH
13058: CALL_OW 1
13062: ST_TO_ADDR
// remove_from_vehicles ( rem_t ) ;
13063: LD_VAR 0 3
13067: PPUSH
13068: CALL 28219 0 1
// add_to_vehicles ( add_t ) ;
13072: LD_VAR 0 4
13076: PPUSH
13077: CALL 26888 0 1
// ComMoveXY ( bc [ k ] , repair_site [ k ] [ 1 ] , repair_site [ k ] [ 2 ] ) ;
13081: LD_EXP 71
13085: PUSH
13086: LD_VAR 0 5
13090: ARRAY
13091: PPUSH
13092: LD_LOC 16
13096: PUSH
13097: LD_VAR 0 5
13101: ARRAY
13102: PUSH
13103: LD_INT 1
13105: ARRAY
13106: PPUSH
13107: LD_LOC 16
13111: PUSH
13112: LD_VAR 0 5
13116: ARRAY
13117: PUSH
13118: LD_INT 2
13120: ARRAY
13121: PPUSH
13122: CALL_OW 111
// wait ( 0 0$0.9 ) ;
13126: LD_INT 32
13128: PPUSH
13129: CALL_OW 67
// end else
13133: GO 13157
// bc := replace ( bc , k , [ ] ) ;
13135: LD_ADDR_EXP 71
13139: PUSH
13140: LD_EXP 71
13144: PPUSH
13145: LD_VAR 0 5
13149: PPUSH
13150: EMPTY
13151: PPUSH
13152: CALL_OW 1
13156: ST_TO_ADDR
13157: GO 12840
13159: POP
13160: POP
// enable ;
13161: ENABLE
// end ;
13162: PPOPN 5
13164: END
// every 0 0$5 + 0 0$0.1 do var zivoty , i , rc_t , k ;
13165: GO 13167
13167: DISABLE
13168: LD_INT 0
13170: PPUSH
13171: PPUSH
13172: PPUSH
13173: PPUSH
// begin for k := 1 to 5 do
13174: LD_ADDR_VAR 0 4
13178: PUSH
13179: DOUBLE
13180: LD_INT 1
13182: DEC
13183: ST_TO_ADDR
13184: LD_INT 5
13186: PUSH
13187: FOR_TO
13188: IFFALSE 13355
// if ai_s [ k ] in ai then
13190: LD_EXP 23
13194: PUSH
13195: LD_VAR 0 4
13199: ARRAY
13200: PUSH
13201: LD_EXP 24
13205: IN
13206: IFFALSE 13331
// begin rc_t := [ ] ;
13208: LD_ADDR_VAR 0 3
13212: PUSH
13213: EMPTY
13214: ST_TO_ADDR
// for i in bc [ k ] do
13215: LD_ADDR_VAR 0 2
13219: PUSH
13220: LD_EXP 71
13224: PUSH
13225: LD_VAR 0 4
13229: ARRAY
13230: PUSH
13231: FOR_IN
13232: IFFALSE 13288
// begin if GetLives ( i ) < 950 then
13234: LD_VAR 0 2
13238: PPUSH
13239: CALL_OW 256
13243: PUSH
13244: LD_INT 950
13246: LESS
13247: IFFALSE 13286
// begin rc_t := rc_t ^ i ;
13249: LD_ADDR_VAR 0 3
13253: PUSH
13254: LD_VAR 0 3
13258: PUSH
13259: LD_VAR 0 2
13263: ADD
13264: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
13265: LD_ADDR_VAR 0 1
13269: PUSH
13270: LD_VAR 0 1
13274: PUSH
13275: LD_VAR 0 2
13279: PPUSH
13280: CALL_OW 256
13284: ADD
13285: ST_TO_ADDR
// end ; end ;
13286: GO 13231
13288: POP
13289: POP
// SortListByListAsc ( rc_t , zivoty ) ;
13290: LD_VAR 0 3
13294: PPUSH
13295: LD_VAR 0 1
13299: PPUSH
13300: CALL_OW 76
// rc := replace ( rc , k , rc_t ) ;
13304: LD_ADDR_EXP 70
13308: PUSH
13309: LD_EXP 70
13313: PPUSH
13314: LD_VAR 0 4
13318: PPUSH
13319: LD_VAR 0 3
13323: PPUSH
13324: CALL_OW 1
13328: ST_TO_ADDR
// end else
13329: GO 13353
// rc := replace ( rc , k , [ ] ) ;
13331: LD_ADDR_EXP 70
13335: PUSH
13336: LD_EXP 70
13340: PPUSH
13341: LD_VAR 0 4
13345: PPUSH
13346: EMPTY
13347: PPUSH
13348: CALL_OW 1
13352: ST_TO_ADDR
13353: GO 13187
13355: POP
13356: POP
// enable ;
13357: ENABLE
// end ;
13358: PPOPN 4
13360: END
// every 0 0$5 + 0 0$0.9 do var i ;
13361: GO 13363
13363: DISABLE
13364: LD_INT 0
13366: PPUSH
// begin for i := 1 to 5 do
13367: LD_ADDR_VAR 0 1
13371: PUSH
13372: DOUBLE
13373: LD_INT 1
13375: DEC
13376: ST_TO_ADDR
13377: LD_INT 5
13379: PUSH
13380: FOR_TO
13381: IFFALSE 13436
// if ai_s [ i ] in ai then
13383: LD_EXP 23
13387: PUSH
13388: LD_VAR 0 1
13392: ARRAY
13393: PUSH
13394: LD_EXP 24
13398: IN
13399: IFFALSE 13434
// begin rep ( ai_s [ i ] , rc [ i ] ) ;
13401: LD_EXP 23
13405: PUSH
13406: LD_VAR 0 1
13410: ARRAY
13411: PPUSH
13412: LD_EXP 70
13416: PUSH
13417: LD_VAR 0 1
13421: ARRAY
13422: PPUSH
13423: CALL 13442 0 2
// wait ( 0 0$0.8 ) ;
13427: LD_INT 28
13429: PPUSH
13430: CALL_OW 67
// end ;
13434: GO 13380
13436: POP
13437: POP
// enable ;
13438: ENABLE
// end ;
13439: PPOPN 1
13441: END
// function rep ( side , rep_cars ) ; var a ; begin
13442: LD_INT 0
13444: PPUSH
13445: PPUSH
// if ( side in ai ) and rep_cars then
13446: LD_VAR 0 1
13450: PUSH
13451: LD_EXP 24
13455: IN
13456: PUSH
13457: LD_VAR 0 2
13461: AND
13462: IFFALSE 13991
// begin if rep_cars [ 1 ] < 400 then
13464: LD_VAR 0 2
13468: PUSH
13469: LD_INT 1
13471: ARRAY
13472: PUSH
13473: LD_INT 400
13475: LESS
13476: IFFALSE 13575
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13478: LD_ADDR_VAR 0 4
13482: PUSH
13483: LD_EXP 86
13487: PPUSH
13488: LD_INT 22
13490: PUSH
13491: LD_VAR 0 1
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 91
13502: PUSH
13503: LD_VAR 0 2
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_INT 20
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 72
13528: PPUSH
13529: LD_INT 2
13531: PPUSH
13532: LD_INT 3
13534: PPUSH
13535: LD_INT 0
13537: PPUSH
13538: LD_INT 0
13540: PPUSH
13541: CALL 10077 0 5
13545: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13546: LD_VAR 0 4
13550: PPUSH
13551: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13555: LD_VAR 0 4
13559: PPUSH
13560: LD_VAR 0 2
13564: PUSH
13565: LD_INT 1
13567: ARRAY
13568: PPUSH
13569: CALL_OW 189
// end else
13573: GO 13991
// if rep_cars [ 1 ] < 700 or rep_cars >= 2 then
13575: LD_VAR 0 2
13579: PUSH
13580: LD_INT 1
13582: ARRAY
13583: PUSH
13584: LD_INT 700
13586: LESS
13587: PUSH
13588: LD_VAR 0 2
13592: PUSH
13593: LD_INT 2
13595: GREATEREQUAL
13596: OR
13597: IFFALSE 13791
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , false ) ;
13599: LD_ADDR_VAR 0 4
13603: PUSH
13604: LD_EXP 86
13608: PPUSH
13609: LD_INT 22
13611: PUSH
13612: LD_VAR 0 1
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 91
13623: PUSH
13624: LD_VAR 0 2
13628: PUSH
13629: LD_INT 1
13631: ARRAY
13632: PUSH
13633: LD_INT 20
13635: PUSH
13636: EMPTY
13637: LIST
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PPUSH
13645: CALL_OW 72
13649: PPUSH
13650: LD_INT 1
13652: PPUSH
13653: LD_INT 3
13655: PPUSH
13656: LD_INT 0
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL 10077 0 5
13666: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13667: LD_VAR 0 4
13671: PPUSH
13672: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13676: LD_VAR 0 4
13680: PPUSH
13681: LD_VAR 0 2
13685: PUSH
13686: LD_INT 1
13688: ARRAY
13689: PPUSH
13690: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , true ) ;
13694: LD_ADDR_VAR 0 4
13698: PUSH
13699: LD_EXP 86
13703: PPUSH
13704: LD_INT 22
13706: PUSH
13707: LD_VAR 0 1
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: PUSH
13716: LD_INT 91
13718: PUSH
13719: LD_VAR 0 2
13723: PUSH
13724: LD_INT 2
13726: ARRAY
13727: PUSH
13728: LD_INT 20
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: LIST
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: PPUSH
13740: CALL_OW 72
13744: PPUSH
13745: LD_INT 1
13747: PPUSH
13748: LD_INT 3
13750: PPUSH
13751: LD_INT 0
13753: PPUSH
13754: LD_INT 1
13756: PPUSH
13757: CALL 10077 0 5
13761: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13762: LD_VAR 0 4
13766: PPUSH
13767: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13771: LD_VAR 0 4
13775: PPUSH
13776: LD_VAR 0 2
13780: PUSH
13781: LD_INT 2
13783: ARRAY
13784: PPUSH
13785: CALL_OW 189
// end else
13789: GO 13991
// if rep_cars >= 3 then
13791: LD_VAR 0 2
13795: PUSH
13796: LD_INT 3
13798: GREATEREQUAL
13799: IFFALSE 13991
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13801: LD_ADDR_VAR 0 4
13805: PUSH
13806: LD_EXP 86
13810: PPUSH
13811: LD_INT 22
13813: PUSH
13814: LD_VAR 0 1
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: PUSH
13823: LD_INT 91
13825: PUSH
13826: LD_VAR 0 2
13830: PUSH
13831: LD_INT 1
13833: ARRAY
13834: PUSH
13835: LD_INT 20
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: LIST
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 72
13851: PPUSH
13852: LD_INT 2
13854: PPUSH
13855: LD_INT 3
13857: PPUSH
13858: LD_INT 0
13860: PPUSH
13861: LD_INT 0
13863: PPUSH
13864: CALL 10077 0 5
13868: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13869: LD_VAR 0 4
13873: PPUSH
13874: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13878: LD_VAR 0 4
13882: PPUSH
13883: LD_VAR 0 2
13887: PUSH
13888: LD_INT 1
13890: ARRAY
13891: PPUSH
13892: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , true ) ;
13896: LD_ADDR_VAR 0 4
13900: PUSH
13901: LD_EXP 86
13905: PPUSH
13906: LD_INT 22
13908: PUSH
13909: LD_VAR 0 1
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: PUSH
13918: LD_INT 91
13920: PUSH
13921: LD_VAR 0 2
13925: PUSH
13926: LD_INT 2
13928: ARRAY
13929: PUSH
13930: LD_INT 20
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: LIST
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: PPUSH
13942: CALL_OW 72
13946: PPUSH
13947: LD_INT 2
13949: PPUSH
13950: LD_INT 3
13952: PPUSH
13953: LD_INT 0
13955: PPUSH
13956: LD_INT 1
13958: PPUSH
13959: CALL 10077 0 5
13963: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13964: LD_VAR 0 4
13968: PPUSH
13969: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13973: LD_VAR 0 4
13977: PPUSH
13978: LD_VAR 0 2
13982: PUSH
13983: LD_INT 2
13985: ARRAY
13986: PPUSH
13987: CALL_OW 189
// end ; end ; end ; end_of_file
13991: LD_VAR 0 3
13995: RET
// var d1 , d2 , d3 , d5 , d6 , d7 ; export function inicializace_ai_c_make ; begin
13996: LD_INT 0
13998: PPUSH
// d1 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ;
13999: LD_ADDR_LOC 17
14003: PUSH
14004: LD_INT 23
14006: PUSH
14007: LD_INT 1
14009: PUSH
14010: LD_INT 1
14012: PUSH
14013: LD_INT 43
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: ST_TO_ADDR
// d2 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] ;
14022: LD_ADDR_LOC 18
14026: PUSH
14027: LD_INT 23
14029: PUSH
14030: LD_INT 1
14032: PUSH
14033: LD_INT 1
14035: PUSH
14036: LD_INT 45
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: ST_TO_ADDR
// d3 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] ;
14045: LD_ADDR_LOC 19
14049: PUSH
14050: LD_INT 23
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: LD_INT 1
14058: PUSH
14059: LD_INT 46
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: ST_TO_ADDR
// d5 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_gatling_gun ] ;
14068: LD_ADDR_LOC 20
14072: PUSH
14073: LD_INT 23
14075: PUSH
14076: LD_INT 3
14078: PUSH
14079: LD_INT 3
14081: PUSH
14082: LD_INT 43
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: ST_TO_ADDR
// d6 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_rocket_launcher ] ;
14091: LD_ADDR_LOC 21
14095: PUSH
14096: LD_INT 23
14098: PUSH
14099: LD_INT 3
14101: PUSH
14102: LD_INT 3
14104: PUSH
14105: LD_INT 45
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: ST_TO_ADDR
// d7 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_heavy_gun ] ;
14114: LD_ADDR_LOC 22
14118: PUSH
14119: LD_INT 23
14121: PUSH
14122: LD_INT 3
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 46
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: ST_TO_ADDR
// end ;
14137: LD_VAR 0 1
14141: RET
// every 0 0$3 do var i , a ;
14142: GO 14144
14144: DISABLE
14145: LD_INT 0
14147: PPUSH
14148: PPUSH
// begin for i := 1 to 5 do
14149: LD_ADDR_VAR 0 1
14153: PUSH
14154: DOUBLE
14155: LD_INT 1
14157: DEC
14158: ST_TO_ADDR
14159: LD_INT 5
14161: PUSH
14162: FOR_TO
14163: IFFALSE 14387
// begin if ai_s [ i ] in ai then
14165: LD_EXP 23
14169: PUSH
14170: LD_VAR 0 1
14174: ARRAY
14175: PUSH
14176: LD_EXP 24
14180: IN
14181: IFFALSE 14385
// begin if depots [ i ] then
14183: LD_EXP 74
14187: PUSH
14188: LD_VAR 0 1
14192: ARRAY
14193: IFFALSE 14385
// begin if GetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans ) < 150 then
14195: LD_EXP 74
14199: PUSH
14200: LD_VAR 0 1
14204: ARRAY
14205: PUSH
14206: LD_INT 1
14208: ARRAY
14209: PPUSH
14210: CALL_OW 274
14214: PPUSH
14215: LD_INT 1
14217: PPUSH
14218: CALL_OW 275
14222: PUSH
14223: LD_INT 150
14225: LESS
14226: IFFALSE 14270
// SetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans , 150 + Rand ( 50 , 100 ) ) ;
14228: LD_EXP 74
14232: PUSH
14233: LD_VAR 0 1
14237: ARRAY
14238: PUSH
14239: LD_INT 1
14241: ARRAY
14242: PPUSH
14243: CALL_OW 274
14247: PPUSH
14248: LD_INT 1
14250: PPUSH
14251: LD_INT 150
14253: PUSH
14254: LD_INT 50
14256: PPUSH
14257: LD_INT 100
14259: PPUSH
14260: CALL_OW 12
14264: PLUS
14265: PPUSH
14266: CALL_OW 277
// a := GetListOfCratesInArea ( near_base_area [ i ] ) ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_EXP 63
14279: PUSH
14280: LD_VAR 0 1
14284: ARRAY
14285: PPUSH
14286: CALL_OW 435
14290: ST_TO_ADDR
// if a > 6 then
14291: LD_VAR 0 2
14295: PUSH
14296: LD_INT 6
14298: GREATER
14299: IFFALSE 14385
// for i in a do
14301: LD_ADDR_VAR 0 1
14305: PUSH
14306: LD_VAR 0 2
14310: PUSH
14311: FOR_IN
14312: IFFALSE 14383
// if not SeeXY ( you , i [ 1 ] , i [ 2 ] ) then
14314: LD_EXP 7
14318: PPUSH
14319: LD_VAR 0 1
14323: PUSH
14324: LD_INT 1
14326: ARRAY
14327: PPUSH
14328: LD_VAR 0 1
14332: PUSH
14333: LD_INT 2
14335: ARRAY
14336: PPUSH
14337: CALL_OW 293
14341: NOT
14342: IFFALSE 14381
// begin MoveAreaXY ( hexik , i [ 1 ] , i [ 2 ] ) ;
14344: LD_INT 32
14346: PPUSH
14347: LD_VAR 0 1
14351: PUSH
14352: LD_INT 1
14354: ARRAY
14355: PPUSH
14356: LD_VAR 0 1
14360: PUSH
14361: LD_INT 2
14363: ARRAY
14364: PPUSH
14365: CALL_OW 425
// EraseResourceArea ( hexik , mat_cans ) ;
14369: LD_INT 32
14371: PPUSH
14372: LD_INT 1
14374: PPUSH
14375: CALL_OW 286
// break ;
14379: GO 14383
// end ;
14381: GO 14311
14383: POP
14384: POP
// end ; end ; end ;
14385: GO 14162
14387: POP
14388: POP
// end ;
14389: PPOPN 2
14391: END
// function MyCanBeConstructed ( tfact , d ) ; begin
14392: LD_INT 0
14394: PPUSH
// result := CanBeConstructed ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14395: LD_ADDR_VAR 0 3
14399: PUSH
14400: LD_VAR 0 1
14404: PPUSH
14405: LD_VAR 0 2
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: LD_VAR 0 2
14418: PUSH
14419: LD_INT 2
14421: ARRAY
14422: PPUSH
14423: LD_VAR 0 2
14427: PUSH
14428: LD_INT 3
14430: ARRAY
14431: PPUSH
14432: LD_VAR 0 2
14436: PUSH
14437: LD_INT 4
14439: ARRAY
14440: PPUSH
14441: CALL_OW 448
14445: ST_TO_ADDR
// end ;
14446: LD_VAR 0 3
14450: RET
// function MyComConstruct ( tfact , d ) ; begin
14451: LD_INT 0
14453: PPUSH
// result := ComConstruct ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14454: LD_ADDR_VAR 0 3
14458: PUSH
14459: LD_VAR 0 1
14463: PPUSH
14464: LD_VAR 0 2
14468: PUSH
14469: LD_INT 1
14471: ARRAY
14472: PPUSH
14473: LD_VAR 0 2
14477: PUSH
14478: LD_INT 2
14480: ARRAY
14481: PPUSH
14482: LD_VAR 0 2
14486: PUSH
14487: LD_INT 3
14489: ARRAY
14490: PPUSH
14491: LD_VAR 0 2
14495: PUSH
14496: LD_INT 4
14498: ARRAY
14499: PPUSH
14500: CALL_OW 125
14504: ST_TO_ADDR
// end ;
14505: LD_VAR 0 3
14509: RET
// every 0 0$10 + 0 0$1.1 trigger IsOk ( factories [ 1 ] ) and IsIdle ( factories [ 1 ] ) do var a , tfact , def , att ;
14510: LD_EXP 73
14514: PUSH
14515: LD_INT 1
14517: ARRAY
14518: PPUSH
14519: CALL_OW 302
14523: PUSH
14524: LD_EXP 73
14528: PUSH
14529: LD_INT 1
14531: ARRAY
14532: PPUSH
14533: CALL_OW 316
14537: AND
14538: IFFALSE 14857
14540: GO 14542
14542: DISABLE
14543: LD_INT 0
14545: PPUSH
14546: PPUSH
14547: PPUSH
14548: PPUSH
// begin tfact := factories [ 1 ] ;
14549: LD_ADDR_VAR 0 2
14553: PUSH
14554: LD_EXP 73
14558: PUSH
14559: LD_INT 1
14561: ARRAY
14562: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 1 ] , [ mf_manu ] ) ;
14563: LD_ADDR_VAR 0 3
14567: PUSH
14568: LD_EXP 77
14572: PUSH
14573: LD_INT 1
14575: ARRAY
14576: PPUSH
14577: LD_EXP 61
14581: PUSH
14582: EMPTY
14583: LIST
14584: PPUSH
14585: CALL_OW 72
14589: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 1 ] , [ mf_comp ] ) ;
14590: LD_ADDR_VAR 0 4
14594: PUSH
14595: LD_EXP 77
14599: PUSH
14600: LD_INT 1
14602: ARRAY
14603: PPUSH
14604: LD_EXP 60
14608: PUSH
14609: EMPTY
14610: LIST
14611: PPUSH
14612: CALL_OW 72
14616: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14617: LD_INT 1
14619: PUSH
14620: LD_VAR 0 3
14624: PUSH
14625: LD_INT 2
14627: LESS
14628: PUSH
14629: LD_VAR 0 2
14633: PPUSH
14634: LD_LOC 18
14638: PPUSH
14639: CALL 14392 0 2
14643: AND
14644: DOUBLE
14645: EQUAL
14646: IFTRUE 14650
14648: GO 14667
14650: POP
// begin MyComConstruct ( tfact , d2 ) ;
14651: LD_VAR 0 2
14655: PPUSH
14656: LD_LOC 18
14660: PPUSH
14661: CALL 14451 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14665: GO 14856
14667: LD_VAR 0 3
14671: PUSH
14672: LD_INT 3
14674: LESS
14675: PUSH
14676: LD_VAR 0 2
14680: PPUSH
14681: LD_LOC 19
14685: PPUSH
14686: CALL 14392 0 2
14690: AND
14691: DOUBLE
14692: EQUAL
14693: IFTRUE 14697
14695: GO 14714
14697: POP
// begin MyComConstruct ( tfact , d3 ) ;
14698: LD_VAR 0 2
14702: PPUSH
14703: LD_LOC 19
14707: PPUSH
14708: CALL 14451 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
14712: GO 14856
14714: LD_VAR 0 4
14718: PUSH
14719: LD_INT 2
14721: LESS
14722: PUSH
14723: LD_VAR 0 2
14727: PPUSH
14728: LD_LOC 21
14732: PPUSH
14733: CALL 14392 0 2
14737: AND
14738: DOUBLE
14739: EQUAL
14740: IFTRUE 14744
14742: GO 14761
14744: POP
// begin MyComConstruct ( tfact , d6 ) ;
14745: LD_VAR 0 2
14749: PPUSH
14750: LD_LOC 21
14754: PPUSH
14755: CALL 14451 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
14759: GO 14856
14761: LD_VAR 0 4
14765: PUSH
14766: LD_INT 3
14768: LESS
14769: PUSH
14770: LD_VAR 0 2
14774: PPUSH
14775: LD_LOC 20
14779: PPUSH
14780: CALL 14392 0 2
14784: AND
14785: DOUBLE
14786: EQUAL
14787: IFTRUE 14791
14789: GO 14808
14791: POP
// begin MyComConstruct ( tfact , d5 ) ;
14792: LD_VAR 0 2
14796: PPUSH
14797: LD_LOC 20
14801: PPUSH
14802: CALL 14451 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
14806: GO 14856
14808: LD_VAR 0 4
14812: PUSH
14813: LD_INT 5
14815: LESS
14816: PUSH
14817: LD_VAR 0 2
14821: PPUSH
14822: LD_LOC 22
14826: PPUSH
14827: CALL 14392 0 2
14831: AND
14832: DOUBLE
14833: EQUAL
14834: IFTRUE 14838
14836: GO 14855
14838: POP
// begin MyComConstruct ( tfact , d7 ) ;
14839: LD_VAR 0 2
14843: PPUSH
14844: LD_LOC 22
14848: PPUSH
14849: CALL 14451 0 2
// end ; end ;
14853: GO 14856
14855: POP
// enable ;
14856: ENABLE
// end ;
14857: PPOPN 4
14859: END
// every 0 0$10 + 0 0$2.3 trigger IsOk ( factories [ 2 ] ) and IsIdle ( factories [ 2 ] ) do var a , tfact , def , att ;
14860: LD_EXP 73
14864: PUSH
14865: LD_INT 2
14867: ARRAY
14868: PPUSH
14869: CALL_OW 302
14873: PUSH
14874: LD_EXP 73
14878: PUSH
14879: LD_INT 2
14881: ARRAY
14882: PPUSH
14883: CALL_OW 316
14887: AND
14888: IFFALSE 15207
14890: GO 14892
14892: DISABLE
14893: LD_INT 0
14895: PPUSH
14896: PPUSH
14897: PPUSH
14898: PPUSH
// begin tfact := factories [ 2 ] ;
14899: LD_ADDR_VAR 0 2
14903: PUSH
14904: LD_EXP 73
14908: PUSH
14909: LD_INT 2
14911: ARRAY
14912: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 2 ] , [ mf_manu ] ) ;
14913: LD_ADDR_VAR 0 3
14917: PUSH
14918: LD_EXP 77
14922: PUSH
14923: LD_INT 2
14925: ARRAY
14926: PPUSH
14927: LD_EXP 61
14931: PUSH
14932: EMPTY
14933: LIST
14934: PPUSH
14935: CALL_OW 72
14939: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 2 ] , [ mf_comp ] ) ;
14940: LD_ADDR_VAR 0 4
14944: PUSH
14945: LD_EXP 77
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: PPUSH
14954: LD_EXP 60
14958: PUSH
14959: EMPTY
14960: LIST
14961: PPUSH
14962: CALL_OW 72
14966: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14967: LD_INT 1
14969: PUSH
14970: LD_VAR 0 3
14974: PUSH
14975: LD_INT 2
14977: LESS
14978: PUSH
14979: LD_VAR 0 2
14983: PPUSH
14984: LD_LOC 18
14988: PPUSH
14989: CALL 14392 0 2
14993: AND
14994: DOUBLE
14995: EQUAL
14996: IFTRUE 15000
14998: GO 15017
15000: POP
// begin MyComConstruct ( tfact , d2 ) ;
15001: LD_VAR 0 2
15005: PPUSH
15006: LD_LOC 18
15010: PPUSH
15011: CALL 14451 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15015: GO 15206
15017: LD_VAR 0 3
15021: PUSH
15022: LD_INT 3
15024: LESS
15025: PUSH
15026: LD_VAR 0 2
15030: PPUSH
15031: LD_LOC 19
15035: PPUSH
15036: CALL 14392 0 2
15040: AND
15041: DOUBLE
15042: EQUAL
15043: IFTRUE 15047
15045: GO 15064
15047: POP
// begin MyComConstruct ( tfact , d3 ) ;
15048: LD_VAR 0 2
15052: PPUSH
15053: LD_LOC 19
15057: PPUSH
15058: CALL 14451 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15062: GO 15206
15064: LD_VAR 0 4
15068: PUSH
15069: LD_INT 2
15071: LESS
15072: PUSH
15073: LD_VAR 0 2
15077: PPUSH
15078: LD_LOC 21
15082: PPUSH
15083: CALL 14392 0 2
15087: AND
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15111
15094: POP
// begin MyComConstruct ( tfact , d6 ) ;
15095: LD_VAR 0 2
15099: PPUSH
15100: LD_LOC 21
15104: PPUSH
15105: CALL 14451 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15109: GO 15206
15111: LD_VAR 0 4
15115: PUSH
15116: LD_INT 3
15118: LESS
15119: PUSH
15120: LD_VAR 0 2
15124: PPUSH
15125: LD_LOC 20
15129: PPUSH
15130: CALL 14392 0 2
15134: AND
15135: DOUBLE
15136: EQUAL
15137: IFTRUE 15141
15139: GO 15158
15141: POP
// begin MyComConstruct ( tfact , d5 ) ;
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_LOC 20
15151: PPUSH
15152: CALL 14451 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15156: GO 15206
15158: LD_VAR 0 4
15162: PUSH
15163: LD_INT 5
15165: LESS
15166: PUSH
15167: LD_VAR 0 2
15171: PPUSH
15172: LD_LOC 22
15176: PPUSH
15177: CALL 14392 0 2
15181: AND
15182: DOUBLE
15183: EQUAL
15184: IFTRUE 15188
15186: GO 15205
15188: POP
// begin MyComConstruct ( tfact , d7 ) ;
15189: LD_VAR 0 2
15193: PPUSH
15194: LD_LOC 22
15198: PPUSH
15199: CALL 14451 0 2
// end ; end ;
15203: GO 15206
15205: POP
// enable ;
15206: ENABLE
// end ;
15207: PPOPN 4
15209: END
// every 0 0$10 + 0 0$3.4 trigger IsOk ( factories [ 3 ] ) and IsIdle ( factories [ 3 ] ) do var a , tfact , def , att ;
15210: LD_EXP 73
15214: PUSH
15215: LD_INT 3
15217: ARRAY
15218: PPUSH
15219: CALL_OW 302
15223: PUSH
15224: LD_EXP 73
15228: PUSH
15229: LD_INT 3
15231: ARRAY
15232: PPUSH
15233: CALL_OW 316
15237: AND
15238: IFFALSE 15463
15240: GO 15242
15242: DISABLE
15243: LD_INT 0
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
// begin tfact := factories [ 3 ] ;
15249: LD_ADDR_VAR 0 2
15253: PUSH
15254: LD_EXP 73
15258: PUSH
15259: LD_INT 3
15261: ARRAY
15262: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 3 ] , [ mf_manu ] ) ;
15263: LD_ADDR_VAR 0 3
15267: PUSH
15268: LD_EXP 77
15272: PUSH
15273: LD_INT 3
15275: ARRAY
15276: PPUSH
15277: LD_EXP 61
15281: PUSH
15282: EMPTY
15283: LIST
15284: PPUSH
15285: CALL_OW 72
15289: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 3 ] , [ mf_comp ] ) ;
15290: LD_ADDR_VAR 0 4
15294: PUSH
15295: LD_EXP 77
15299: PUSH
15300: LD_INT 3
15302: ARRAY
15303: PPUSH
15304: LD_EXP 60
15308: PUSH
15309: EMPTY
15310: LIST
15311: PPUSH
15312: CALL_OW 72
15316: ST_TO_ADDR
// case true of def < 1 and MyCanBeConstructed ( tfact , d2 ) :
15317: LD_INT 1
15319: PUSH
15320: LD_VAR 0 3
15324: PUSH
15325: LD_INT 1
15327: LESS
15328: PUSH
15329: LD_VAR 0 2
15333: PPUSH
15334: LD_LOC 18
15338: PPUSH
15339: CALL 14392 0 2
15343: AND
15344: DOUBLE
15345: EQUAL
15346: IFTRUE 15350
15348: GO 15367
15350: POP
// begin MyComConstruct ( tfact , d2 ) ;
15351: LD_VAR 0 2
15355: PPUSH
15356: LD_LOC 18
15360: PPUSH
15361: CALL 14451 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15365: GO 15462
15367: LD_VAR 0 4
15371: PUSH
15372: LD_INT 2
15374: LESS
15375: PUSH
15376: LD_VAR 0 2
15380: PPUSH
15381: LD_LOC 21
15385: PPUSH
15386: CALL 14392 0 2
15390: AND
15391: DOUBLE
15392: EQUAL
15393: IFTRUE 15397
15395: GO 15414
15397: POP
// begin MyComConstruct ( tfact , d6 ) ;
15398: LD_VAR 0 2
15402: PPUSH
15403: LD_LOC 21
15407: PPUSH
15408: CALL 14451 0 2
// end ; att < 4 and MyCanBeConstructed ( tfact , d7 ) :
15412: GO 15462
15414: LD_VAR 0 4
15418: PUSH
15419: LD_INT 4
15421: LESS
15422: PUSH
15423: LD_VAR 0 2
15427: PPUSH
15428: LD_LOC 22
15432: PPUSH
15433: CALL 14392 0 2
15437: AND
15438: DOUBLE
15439: EQUAL
15440: IFTRUE 15444
15442: GO 15461
15444: POP
// begin MyComConstruct ( tfact , d7 ) ;
15445: LD_VAR 0 2
15449: PPUSH
15450: LD_LOC 22
15454: PPUSH
15455: CALL 14451 0 2
// end ; end ;
15459: GO 15462
15461: POP
// enable ;
15462: ENABLE
// end ;
15463: PPOPN 4
15465: END
// every 0 0$10 + 0 0$4.5 trigger IsOk ( factories [ 4 ] ) and IsIdle ( factories [ 4 ] ) do var a , tfact , def , att ;
15466: LD_EXP 73
15470: PUSH
15471: LD_INT 4
15473: ARRAY
15474: PPUSH
15475: CALL_OW 302
15479: PUSH
15480: LD_EXP 73
15484: PUSH
15485: LD_INT 4
15487: ARRAY
15488: PPUSH
15489: CALL_OW 316
15493: AND
15494: IFFALSE 15766
15496: GO 15498
15498: DISABLE
15499: LD_INT 0
15501: PPUSH
15502: PPUSH
15503: PPUSH
15504: PPUSH
// begin tfact := factories [ 4 ] ;
15505: LD_ADDR_VAR 0 2
15509: PUSH
15510: LD_EXP 73
15514: PUSH
15515: LD_INT 4
15517: ARRAY
15518: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 4 ] , [ mf_manu ] ) ;
15519: LD_ADDR_VAR 0 3
15523: PUSH
15524: LD_EXP 77
15528: PUSH
15529: LD_INT 4
15531: ARRAY
15532: PPUSH
15533: LD_EXP 61
15537: PUSH
15538: EMPTY
15539: LIST
15540: PPUSH
15541: CALL_OW 72
15545: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 4 ] , [ mf_comp ] ) ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_EXP 77
15555: PUSH
15556: LD_INT 4
15558: ARRAY
15559: PPUSH
15560: LD_EXP 60
15564: PUSH
15565: EMPTY
15566: LIST
15567: PPUSH
15568: CALL_OW 72
15572: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15573: LD_INT 1
15575: PUSH
15576: LD_VAR 0 3
15580: PUSH
15581: LD_INT 2
15583: LESS
15584: PUSH
15585: LD_VAR 0 2
15589: PPUSH
15590: LD_LOC 18
15594: PPUSH
15595: CALL 14392 0 2
15599: AND
15600: DOUBLE
15601: EQUAL
15602: IFTRUE 15606
15604: GO 15623
15606: POP
// begin MyComConstruct ( tfact , d2 ) ;
15607: LD_VAR 0 2
15611: PPUSH
15612: LD_LOC 18
15616: PPUSH
15617: CALL 14451 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15621: GO 15765
15623: LD_VAR 0 3
15627: PUSH
15628: LD_INT 3
15630: LESS
15631: PUSH
15632: LD_VAR 0 2
15636: PPUSH
15637: LD_LOC 19
15641: PPUSH
15642: CALL 14392 0 2
15646: AND
15647: DOUBLE
15648: EQUAL
15649: IFTRUE 15653
15651: GO 15670
15653: POP
// begin MyComConstruct ( tfact , d3 ) ;
15654: LD_VAR 0 2
15658: PPUSH
15659: LD_LOC 19
15663: PPUSH
15664: CALL 14451 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15668: GO 15765
15670: LD_VAR 0 4
15674: PUSH
15675: LD_INT 2
15677: LESS
15678: PUSH
15679: LD_VAR 0 2
15683: PPUSH
15684: LD_LOC 21
15688: PPUSH
15689: CALL 14392 0 2
15693: AND
15694: DOUBLE
15695: EQUAL
15696: IFTRUE 15700
15698: GO 15717
15700: POP
// begin MyComConstruct ( tfact , d6 ) ;
15701: LD_VAR 0 2
15705: PPUSH
15706: LD_LOC 21
15710: PPUSH
15711: CALL 14451 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15715: GO 15765
15717: LD_VAR 0 4
15721: PUSH
15722: LD_INT 5
15724: LESS
15725: PUSH
15726: LD_VAR 0 2
15730: PPUSH
15731: LD_LOC 22
15735: PPUSH
15736: CALL 14392 0 2
15740: AND
15741: DOUBLE
15742: EQUAL
15743: IFTRUE 15747
15745: GO 15764
15747: POP
// begin MyComConstruct ( tfact , d7 ) ;
15748: LD_VAR 0 2
15752: PPUSH
15753: LD_LOC 22
15757: PPUSH
15758: CALL 14451 0 2
// end ; end ;
15762: GO 15765
15764: POP
// enable ;
15765: ENABLE
// end ;
15766: PPOPN 4
15768: END
// every 0 0$10 + 0 0$5.6 trigger IsOk ( factories [ 5 ] ) and IsIdle ( factories [ 5 ] ) do var a , tfact , def , att ;
15769: LD_EXP 73
15773: PUSH
15774: LD_INT 5
15776: ARRAY
15777: PPUSH
15778: CALL_OW 302
15782: PUSH
15783: LD_EXP 73
15787: PUSH
15788: LD_INT 5
15790: ARRAY
15791: PPUSH
15792: CALL_OW 316
15796: AND
15797: IFFALSE 16116
15799: GO 15801
15801: DISABLE
15802: LD_INT 0
15804: PPUSH
15805: PPUSH
15806: PPUSH
15807: PPUSH
// begin tfact := factories [ 5 ] ;
15808: LD_ADDR_VAR 0 2
15812: PUSH
15813: LD_EXP 73
15817: PUSH
15818: LD_INT 5
15820: ARRAY
15821: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 5 ] , [ mf_manu ] ) ;
15822: LD_ADDR_VAR 0 3
15826: PUSH
15827: LD_EXP 77
15831: PUSH
15832: LD_INT 5
15834: ARRAY
15835: PPUSH
15836: LD_EXP 61
15840: PUSH
15841: EMPTY
15842: LIST
15843: PPUSH
15844: CALL_OW 72
15848: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 5 ] , [ mf_comp ] ) ;
15849: LD_ADDR_VAR 0 4
15853: PUSH
15854: LD_EXP 77
15858: PUSH
15859: LD_INT 5
15861: ARRAY
15862: PPUSH
15863: LD_EXP 60
15867: PUSH
15868: EMPTY
15869: LIST
15870: PPUSH
15871: CALL_OW 72
15875: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15876: LD_INT 1
15878: PUSH
15879: LD_VAR 0 3
15883: PUSH
15884: LD_INT 2
15886: LESS
15887: PUSH
15888: LD_VAR 0 2
15892: PPUSH
15893: LD_LOC 18
15897: PPUSH
15898: CALL 14392 0 2
15902: AND
15903: DOUBLE
15904: EQUAL
15905: IFTRUE 15909
15907: GO 15926
15909: POP
// begin MyComConstruct ( tfact , d2 ) ;
15910: LD_VAR 0 2
15914: PPUSH
15915: LD_LOC 18
15919: PPUSH
15920: CALL 14451 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15924: GO 16115
15926: LD_VAR 0 3
15930: PUSH
15931: LD_INT 3
15933: LESS
15934: PUSH
15935: LD_VAR 0 2
15939: PPUSH
15940: LD_LOC 19
15944: PPUSH
15945: CALL 14392 0 2
15949: AND
15950: DOUBLE
15951: EQUAL
15952: IFTRUE 15956
15954: GO 15973
15956: POP
// begin MyComConstruct ( tfact , d3 ) ;
15957: LD_VAR 0 2
15961: PPUSH
15962: LD_LOC 19
15966: PPUSH
15967: CALL 14451 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15971: GO 16115
15973: LD_VAR 0 4
15977: PUSH
15978: LD_INT 2
15980: LESS
15981: PUSH
15982: LD_VAR 0 2
15986: PPUSH
15987: LD_LOC 21
15991: PPUSH
15992: CALL 14392 0 2
15996: AND
15997: DOUBLE
15998: EQUAL
15999: IFTRUE 16003
16001: GO 16020
16003: POP
// begin MyComConstruct ( tfact , d6 ) ;
16004: LD_VAR 0 2
16008: PPUSH
16009: LD_LOC 21
16013: PPUSH
16014: CALL 14451 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
16018: GO 16115
16020: LD_VAR 0 4
16024: PUSH
16025: LD_INT 3
16027: LESS
16028: PUSH
16029: LD_VAR 0 2
16033: PPUSH
16034: LD_LOC 20
16038: PPUSH
16039: CALL 14392 0 2
16043: AND
16044: DOUBLE
16045: EQUAL
16046: IFTRUE 16050
16048: GO 16067
16050: POP
// begin MyComConstruct ( tfact , d5 ) ;
16051: LD_VAR 0 2
16055: PPUSH
16056: LD_LOC 20
16060: PPUSH
16061: CALL 14451 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
16065: GO 16115
16067: LD_VAR 0 4
16071: PUSH
16072: LD_INT 5
16074: LESS
16075: PUSH
16076: LD_VAR 0 2
16080: PPUSH
16081: LD_LOC 22
16085: PPUSH
16086: CALL 14392 0 2
16090: AND
16091: DOUBLE
16092: EQUAL
16093: IFTRUE 16097
16095: GO 16114
16097: POP
// begin MyComConstruct ( tfact , d7 ) ;
16098: LD_VAR 0 2
16102: PPUSH
16103: LD_LOC 22
16107: PPUSH
16108: CALL 14451 0 2
// end ; end ;
16112: GO 16115
16114: POP
// enable ;
16115: ENABLE
// end ; end_of_file
16116: PPOPN 4
16118: END
// var builds ; var aici ; var in_depots ; var abase ; export hlavouni ; var upgradeable ; var trough_upgrade ; export function inicializace_ai_b_build ; begin
16119: LD_INT 0
16121: PPUSH
// upgradeable := [ b_depot , b_workshop , b_armoury , b_lab , b_lab_half , b_lab ] ;
16122: LD_ADDR_LOC 27
16126: PUSH
16127: LD_INT 0
16129: PUSH
16130: LD_INT 2
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 6
16138: PUSH
16139: LD_INT 7
16141: PUSH
16142: LD_INT 6
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: LIST
16149: LIST
16150: LIST
16151: LIST
16152: ST_TO_ADDR
// trough_upgrade := [ b_warehouse , b_factory , b_barracks , b_lab_half , b_lab_full , b_lab_full ] ;
16153: LD_ADDR_LOC 28
16157: PUSH
16158: LD_INT 1
16160: PUSH
16161: LD_INT 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 7
16169: PUSH
16170: LD_INT 8
16172: PUSH
16173: LD_INT 8
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: ST_TO_ADDR
// abase := [ abase1 , abase2 , abase3 , abase4 , abase5 ] ;
16184: LD_ADDR_LOC 26
16188: PUSH
16189: LD_INT 5
16191: PUSH
16192: LD_INT 4
16194: PUSH
16195: LD_INT 3
16197: PUSH
16198: LD_INT 2
16200: PUSH
16201: LD_INT 1
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: LIST
16208: LIST
16209: LIST
16210: ST_TO_ADDR
// aici := [ [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 6 ] , [ 3 , class_scientistic , 6 ] , [ 8 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] , [ [ 1 , class_engineer , 8 ] , [ 3 , class_scientistic , 8 ] , [ 8 , class_soldier , 8 ] , [ 3 , class_mechanic , 8 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 3 , class_scientistic , 5 ] , [ 5 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 0 , class_scientistic , 4 ] , [ 2 , class_soldier , 4 ] , [ 1 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 4 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 4 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 4 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 1 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 1 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ] ;
16211: LD_ADDR_LOC 24
16215: PUSH
16216: LD_INT 1
16218: PUSH
16219: LD_INT 2
16221: PUSH
16222: LD_INT 4
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 3
16232: PUSH
16233: LD_INT 4
16235: PUSH
16236: LD_INT 4
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: LIST
16243: PUSH
16244: LD_INT 8
16246: PUSH
16247: LD_INT 1
16249: PUSH
16250: LD_INT 4
16252: PUSH
16253: EMPTY
16254: LIST
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 3
16260: PUSH
16261: LD_INT 3
16263: PUSH
16264: LD_INT 4
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: LIST
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: LIST
16276: LIST
16277: PUSH
16278: LD_INT 1
16280: PUSH
16281: LD_INT 2
16283: PUSH
16284: LD_INT 6
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: LIST
16291: PUSH
16292: LD_INT 3
16294: PUSH
16295: LD_INT 4
16297: PUSH
16298: LD_INT 6
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: LIST
16305: PUSH
16306: LD_INT 8
16308: PUSH
16309: LD_INT 1
16311: PUSH
16312: LD_INT 6
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: LIST
16319: PUSH
16320: LD_INT 3
16322: PUSH
16323: LD_INT 3
16325: PUSH
16326: LD_INT 6
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: LIST
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: LIST
16338: LIST
16339: PUSH
16340: LD_INT 1
16342: PUSH
16343: LD_INT 2
16345: PUSH
16346: LD_INT 8
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 3
16356: PUSH
16357: LD_INT 4
16359: PUSH
16360: LD_INT 8
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 8
16370: PUSH
16371: LD_INT 1
16373: PUSH
16374: LD_INT 8
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 3
16384: PUSH
16385: LD_INT 3
16387: PUSH
16388: LD_INT 8
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: LIST
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: PUSH
16407: LD_OWVAR 67
16411: ARRAY
16412: PUSH
16413: LD_INT 1
16415: PUSH
16416: LD_INT 2
16418: PUSH
16419: LD_INT 4
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: LIST
16426: PUSH
16427: LD_INT 3
16429: PUSH
16430: LD_INT 4
16432: PUSH
16433: LD_INT 4
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: PUSH
16441: LD_INT 5
16443: PUSH
16444: LD_INT 1
16446: PUSH
16447: LD_INT 4
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: LIST
16454: PUSH
16455: LD_INT 3
16457: PUSH
16458: LD_INT 3
16460: PUSH
16461: LD_INT 4
16463: PUSH
16464: EMPTY
16465: LIST
16466: LIST
16467: LIST
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: LIST
16473: LIST
16474: PUSH
16475: LD_INT 1
16477: PUSH
16478: LD_INT 2
16480: PUSH
16481: LD_INT 4
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: LIST
16488: PUSH
16489: LD_INT 3
16491: PUSH
16492: LD_INT 4
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 5
16505: PUSH
16506: LD_INT 1
16508: PUSH
16509: LD_INT 4
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 3
16519: PUSH
16520: LD_INT 3
16522: PUSH
16523: LD_INT 4
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: LIST
16535: LIST
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: LD_INT 2
16542: PUSH
16543: LD_INT 5
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: LIST
16550: PUSH
16551: LD_INT 3
16553: PUSH
16554: LD_INT 4
16556: PUSH
16557: LD_INT 5
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PUSH
16565: LD_INT 5
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: LD_INT 5
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 3
16581: PUSH
16582: LD_INT 3
16584: PUSH
16585: LD_INT 5
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: PUSH
16593: EMPTY
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: LIST
16603: PUSH
16604: LD_OWVAR 67
16608: ARRAY
16609: PUSH
16610: LD_INT 1
16612: PUSH
16613: LD_INT 2
16615: PUSH
16616: LD_INT 4
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: LIST
16623: PUSH
16624: LD_INT 0
16626: PUSH
16627: LD_INT 4
16629: PUSH
16630: LD_INT 4
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: LIST
16637: PUSH
16638: LD_INT 2
16640: PUSH
16641: LD_INT 1
16643: PUSH
16644: LD_INT 4
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: PUSH
16652: LD_INT 1
16654: PUSH
16655: LD_INT 3
16657: PUSH
16658: LD_INT 4
16660: PUSH
16661: EMPTY
16662: LIST
16663: LIST
16664: LIST
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: PUSH
16672: LD_INT 1
16674: PUSH
16675: LD_INT 2
16677: PUSH
16678: LD_INT 5
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: LIST
16685: PUSH
16686: LD_INT 0
16688: PUSH
16689: LD_INT 4
16691: PUSH
16692: LD_INT 5
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: LIST
16699: PUSH
16700: LD_INT 2
16702: PUSH
16703: LD_INT 1
16705: PUSH
16706: LD_INT 5
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: PUSH
16714: LD_INT 1
16716: PUSH
16717: LD_INT 3
16719: PUSH
16720: LD_INT 5
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: LIST
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: PUSH
16734: LD_INT 1
16736: PUSH
16737: LD_INT 2
16739: PUSH
16740: LD_INT 5
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 0
16750: PUSH
16751: LD_INT 4
16753: PUSH
16754: LD_INT 5
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: LIST
16761: PUSH
16762: LD_INT 2
16764: PUSH
16765: LD_INT 1
16767: PUSH
16768: LD_INT 5
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: LIST
16775: PUSH
16776: LD_INT 1
16778: PUSH
16779: LD_INT 3
16781: PUSH
16782: LD_INT 5
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: LIST
16789: PUSH
16790: EMPTY
16791: LIST
16792: LIST
16793: LIST
16794: LIST
16795: PUSH
16796: EMPTY
16797: LIST
16798: LIST
16799: LIST
16800: PUSH
16801: LD_OWVAR 67
16805: ARRAY
16806: PUSH
16807: LD_INT 1
16809: PUSH
16810: LD_INT 2
16812: PUSH
16813: LD_INT 4
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: LIST
16820: PUSH
16821: LD_INT 4
16823: PUSH
16824: LD_INT 4
16826: PUSH
16827: LD_INT 4
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: LD_INT 1
16840: PUSH
16841: LD_INT 4
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: PUSH
16849: LD_INT 3
16851: PUSH
16852: LD_INT 3
16854: PUSH
16855: LD_INT 4
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: PUSH
16869: LD_INT 1
16871: PUSH
16872: LD_INT 2
16874: PUSH
16875: LD_INT 5
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: PUSH
16883: LD_INT 4
16885: PUSH
16886: LD_INT 4
16888: PUSH
16889: LD_INT 5
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: LIST
16896: PUSH
16897: LD_INT 3
16899: PUSH
16900: LD_INT 1
16902: PUSH
16903: LD_INT 5
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: PUSH
16911: LD_INT 3
16913: PUSH
16914: LD_INT 3
16916: PUSH
16917: LD_INT 5
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 1
16933: PUSH
16934: LD_INT 2
16936: PUSH
16937: LD_INT 6
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: LIST
16944: PUSH
16945: LD_INT 4
16947: PUSH
16948: LD_INT 4
16950: PUSH
16951: LD_INT 6
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 3
16961: PUSH
16962: LD_INT 1
16964: PUSH
16965: LD_INT 6
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: PUSH
16973: LD_INT 3
16975: PUSH
16976: LD_INT 3
16978: PUSH
16979: LD_INT 6
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: PUSH
16998: LD_OWVAR 67
17002: ARRAY
17003: PUSH
17004: LD_INT 1
17006: PUSH
17007: LD_INT 2
17009: PUSH
17010: LD_INT 4
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 1
17020: PUSH
17021: LD_INT 4
17023: PUSH
17024: LD_INT 4
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: LIST
17031: PUSH
17032: LD_INT 3
17034: PUSH
17035: LD_INT 1
17037: PUSH
17038: LD_INT 4
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: LIST
17045: PUSH
17046: LD_INT 3
17048: PUSH
17049: LD_INT 3
17051: PUSH
17052: LD_INT 4
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: PUSH
17066: LD_INT 1
17068: PUSH
17069: LD_INT 2
17071: PUSH
17072: LD_INT 5
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: LIST
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 4
17085: PUSH
17086: LD_INT 5
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 3
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 5
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 3
17110: PUSH
17111: LD_INT 3
17113: PUSH
17114: LD_INT 5
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: LIST
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: PUSH
17128: LD_INT 1
17130: PUSH
17131: LD_INT 2
17133: PUSH
17134: LD_INT 6
17136: PUSH
17137: EMPTY
17138: LIST
17139: LIST
17140: LIST
17141: PUSH
17142: LD_INT 1
17144: PUSH
17145: LD_INT 4
17147: PUSH
17148: LD_INT 6
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 3
17158: PUSH
17159: LD_INT 1
17161: PUSH
17162: LD_INT 6
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 3
17172: PUSH
17173: LD_INT 3
17175: PUSH
17176: LD_INT 6
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: LIST
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: LIST
17194: PUSH
17195: LD_OWVAR 67
17199: ARRAY
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: ST_TO_ADDR
// builds := [ [ [ b_warehouse , 24 , 9 , 3 , [ ] ] , [ b_barracks , 39 , 26 , 5 , [ ] ] , [ b_siberite_power , 9 , 11 , 2 , [ ] ] , [ b_turret , 45 , 20 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 44 , 25 , 2 , [ ru_heavy_gun ] ] , [ b_turret , 26 , 40 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 37 , 39 , 2 , [ ru_heavy_gun ] ] , [ b_bunker , 42 , 21 , 2 , [ ru_gatling_gun ] ] , [ b_bunker , 38 , 36 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 53 , 15 , 2 , [ ru_rocket_launcher ] ] , [ b_lab_full , 10 , 7 , 2 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_full , 34 , 10 , 3 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_factory , 20 , 21 , 2 , [ ] ] , [ b_ext_gun , 24 , 21 , 4 , [ ] ] , [ b_ext_rocket , 20 , 18 , 3 , [ ] ] , [ b_ext_siberium , 20 , 25 , 0 , [ ] ] , [ b_ext_computer , 17 , 21 , 1 , [ ] ] , [ b_ext_track , 16 , 17 , 2 , [ ] ] , [ b_siberite_mine , 20 , 34 , 0 , [ ] ] , [ b_siberite_power , 15 , 5 , 2 , [ ] ] , [ b_oil_mine , 14 , 23 , 2 , [ ] ] , [ b_teleport , 32 , 20 , 3 , [ ] ] ] , [ [ b_factory , 98 , 26 , 5 , [ ] ] , [ b_barracks , 80 , 13 , 0 , [ ] ] , [ b_siberite_power , 97 , 3 , 1 , [ ] ] , [ b_turret , 105 , 35 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 111 , 22 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 115 , 27 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 65 , 3 , 3 , [ ru_rocket_launcher ] , 20 20$0 ] , [ b_turret , 68 , 3 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 71 , 4 , 3 , [ ru_heavy_gun ] ] , [ b_siberite_power , 101 , 4 , 5 , [ ] ] , [ b_turret , 108 , 35 , 2 , [ ru_heavy_gun ] ] , [ b_ext_track , 101 , 26 , 4 , [ ] ] , [ b_ext_gun , 98 , 22 , 3 , [ ] ] , [ b_ext_siberium , 94 , 26 , 1 , [ ] ] , [ b_ext_rocket , 98 , 29 , 0 , [ ] ] , [ b_ext_noncombat , 102 , 30 , 5 , [ ] ] , [ b_warehouse , 86 , 6 , 3 , [ ] ] , [ b_siberite_mine , 102 , 9 , 4 , [ ] ] , [ b_oil_mine , 77 , 3 , 4 , [ ] ] , [ b_lab_full , 100 , 17 , 4 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_half , 94 , 6 , 3 , [ b_lab_computer , b_lab_basic ] ] ] , [ [ b_warehouse , 90 , 141 , 0 , [ ] ] , [ b_barracks , 98 , 133 , 4 , [ ] ] , [ b_siberite_power , 72 , 133 , 2 , [ ] ] , [ b_bunker , 95 , 128 , 0 , [ ru_rocket_launcher ] ] , [ b_bunker , 80 , 122 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 95 , 128 , 0 , [ ru_rocket_launcher ] , 15 15$0 ] , [ b_turret , 80 , 122 , 2 , [ ru_rocket_launcher ] , 17 17$0 ] , [ b_turret , 112 , 154 , 1 , [ ru_rocket_launcher ] , 16 16$0 ] , [ b_turret , 78 , 124 , 2 , [ ru_heavy_gun ] , 20 20$0 ] , [ b_turret , 99 , 130 , 1 , [ ru_heavy_gun ] , 22 22$0 ] , [ b_turret , 112 , 151 , 1 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_factory , 81 , 135 , 5 , [ ] ] , [ b_ext_siberium , 84 , 135 , 4 , [ ] ] , [ b_ext_gun , 85 , 139 , 5 , [ ] ] , [ b_ext_track , 77 , 135 , 1 , [ ] ] , [ b_ext_rocket , 81 , 138 , 0 , [ ] , 14 14$0 ] , [ b_siberite_mine , 71 , 137 , 0 , [ ] ] , [ b_oil_mine , 69 , 133 , 5 , [ ] ] , [ b_lab_half , 102 , 153 , 0 , [ b_lab_computer , b_lab_basic ] , 35 35$0 ] , [ b_lab_full , 97 , 145 , 2 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 74 , 137 , 2 , [ ] ] , [ b_ext_computer , 81 , 131 , 3 , [ ] ] ] , [ [ b_warehouse , 217 , 129 , 3 , [ ] ] , [ b_siberite_power , 233 , 154 , 4 , [ ] ] , [ b_turret , 205 , 123 , 0 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_turret , 200 , 142 , 4 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 135 , 4 , [ ru_heavy_gun ] , 28 28$0 ] , [ b_turret , 201 , 127 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 138 , 4 , [ ru_rocket_launcher ] ] , [ b_turret , 202 , 124 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 209 , 154 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 218 , 123 , 5 , [ ru_rocket_launcher ] ] , [ b_lab_full , 227 , 145 , 2 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_lab_full , 221 , 153 , 4 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 231 , 155 , 4 , [ ] ] , [ b_oil_mine , 224 , 134 , 4 , [ ] ] , [ b_siberite_mine , 224 , 150 , 2 , [ ] ] , [ b_factory , 207 , 141 , 1 , [ ] ] , [ b_ext_computer , 211 , 145 , 5 , [ ] ] , [ b_ext_siberium , 207 , 144 , 0 , [ ] ] , [ b_ext_rocket , 203 , 141 , 1 , [ ] ] , [ b_ext_track , 204 , 138 , 2 , [ ] ] , [ b_ext_gun , 207 , 137 , 3 , [ ] ] , [ b_armoury , 210 , 128 , 2 , [ ] , 35 35$0 ] , [ b_armoury , 210 , 128 , 2 , [ ] ] ] , [ [ b_warehouse , 184 , 73 , 3 , [ ] ] , [ b_barracks , 188 , 94 , 5 , [ ] ] , [ b_turret , 171 , 92 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 177 , 98 , 3 , [ ru_heavy_gun ] ] , [ b_turret , 169 , 69 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 170 , 66 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 184 , 62 , 5 , [ ru_gatling_gun ] ] , [ b_turret , 203 , 102 , 2 , [ ru_rocket_launcher ] , 30 30$0 ] , [ b_turret , 195 , 103 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 200 , 103 , 2 , [ ru_heavy_gun ] ] , [ b_siberite_power , 198 , 90 , 3 , [ ] ] , [ b_siberite_mine , 179 , 70 , 1 , [ ] ] , [ b_factory , 190 , 84 , 4 , [ ] ] , [ b_ext_gun , 190 , 88 , 0 , [ ] ] , [ b_ext_rocket , 193 , 87 , 5 , [ ] ] , [ b_ext_siberium , 194 , 84 , 4 , [ ] ] , [ b_ext_computer , 190 , 81 , 3 , [ ] ] , [ b_lab_full , 176 , 92 , 0 , [ b_lab_siberium , b_lab_basic ] ] , [ b_lab_full , 176 , 82 , 3 , [ b_lab_computer , b_lab_weapon ] ] , [ b_siberite_power , 196 , 92 , 5 , [ ] ] , [ b_siberite_power , 198 , 86 , 1 , [ ] ] , [ b_siberite_mine , 192 , 93 , 0 , [ ] ] ] ] ;
17208: LD_ADDR_LOC 23
17212: PUSH
17213: LD_INT 1
17215: PUSH
17216: LD_INT 24
17218: PUSH
17219: LD_INT 9
17221: PUSH
17222: LD_INT 3
17224: PUSH
17225: EMPTY
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 5
17236: PUSH
17237: LD_INT 39
17239: PUSH
17240: LD_INT 26
17242: PUSH
17243: LD_INT 5
17245: PUSH
17246: EMPTY
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: LIST
17252: LIST
17253: LIST
17254: PUSH
17255: LD_INT 28
17257: PUSH
17258: LD_INT 9
17260: PUSH
17261: LD_INT 11
17263: PUSH
17264: LD_INT 2
17266: PUSH
17267: EMPTY
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: LIST
17273: LIST
17274: LIST
17275: PUSH
17276: LD_INT 33
17278: PUSH
17279: LD_INT 45
17281: PUSH
17282: LD_INT 20
17284: PUSH
17285: LD_INT 2
17287: PUSH
17288: LD_INT 45
17290: PUSH
17291: EMPTY
17292: LIST
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: LIST
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 33
17303: PUSH
17304: LD_INT 44
17306: PUSH
17307: LD_INT 25
17309: PUSH
17310: LD_INT 2
17312: PUSH
17313: LD_INT 46
17315: PUSH
17316: EMPTY
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 33
17328: PUSH
17329: LD_INT 26
17331: PUSH
17332: LD_INT 40
17334: PUSH
17335: LD_INT 3
17337: PUSH
17338: LD_INT 45
17340: PUSH
17341: EMPTY
17342: LIST
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: LIST
17350: PUSH
17351: LD_INT 33
17353: PUSH
17354: LD_INT 37
17356: PUSH
17357: LD_INT 39
17359: PUSH
17360: LD_INT 2
17362: PUSH
17363: LD_INT 46
17365: PUSH
17366: EMPTY
17367: LIST
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: LIST
17373: LIST
17374: LIST
17375: PUSH
17376: LD_INT 32
17378: PUSH
17379: LD_INT 42
17381: PUSH
17382: LD_INT 21
17384: PUSH
17385: LD_INT 2
17387: PUSH
17388: LD_INT 43
17390: PUSH
17391: EMPTY
17392: LIST
17393: PUSH
17394: EMPTY
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: PUSH
17401: LD_INT 32
17403: PUSH
17404: LD_INT 38
17406: PUSH
17407: LD_INT 36
17409: PUSH
17410: LD_INT 2
17412: PUSH
17413: LD_INT 43
17415: PUSH
17416: EMPTY
17417: LIST
17418: PUSH
17419: EMPTY
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: PUSH
17426: LD_INT 33
17428: PUSH
17429: LD_INT 53
17431: PUSH
17432: LD_INT 15
17434: PUSH
17435: LD_INT 2
17437: PUSH
17438: LD_INT 45
17440: PUSH
17441: EMPTY
17442: LIST
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: PUSH
17451: LD_INT 8
17453: PUSH
17454: LD_INT 10
17456: PUSH
17457: LD_INT 7
17459: PUSH
17460: LD_INT 2
17462: PUSH
17463: LD_INT 11
17465: PUSH
17466: LD_INT 10
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: PUSH
17473: EMPTY
17474: LIST
17475: LIST
17476: LIST
17477: LIST
17478: LIST
17479: PUSH
17480: LD_INT 8
17482: PUSH
17483: LD_INT 34
17485: PUSH
17486: LD_INT 10
17488: PUSH
17489: LD_INT 3
17491: PUSH
17492: LD_INT 12
17494: PUSH
17495: LD_INT 14
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: LIST
17507: LIST
17508: PUSH
17509: LD_INT 3
17511: PUSH
17512: LD_INT 20
17514: PUSH
17515: LD_INT 21
17517: PUSH
17518: LD_INT 2
17520: PUSH
17521: EMPTY
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 17
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 21
17538: PUSH
17539: LD_INT 4
17541: PUSH
17542: EMPTY
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: LIST
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 18
17553: PUSH
17554: LD_INT 20
17556: PUSH
17557: LD_INT 18
17559: PUSH
17560: LD_INT 3
17562: PUSH
17563: EMPTY
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: LIST
17571: PUSH
17572: LD_INT 21
17574: PUSH
17575: LD_INT 20
17577: PUSH
17578: LD_INT 25
17580: PUSH
17581: LD_INT 0
17583: PUSH
17584: EMPTY
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: PUSH
17593: LD_INT 24
17595: PUSH
17596: LD_INT 17
17598: PUSH
17599: LD_INT 21
17601: PUSH
17602: LD_INT 1
17604: PUSH
17605: EMPTY
17606: PUSH
17607: EMPTY
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: LIST
17613: PUSH
17614: LD_INT 16
17616: PUSH
17617: LD_INT 16
17619: PUSH
17620: LD_INT 17
17622: PUSH
17623: LD_INT 2
17625: PUSH
17626: EMPTY
17627: PUSH
17628: EMPTY
17629: LIST
17630: LIST
17631: LIST
17632: LIST
17633: LIST
17634: PUSH
17635: LD_INT 30
17637: PUSH
17638: LD_INT 20
17640: PUSH
17641: LD_INT 34
17643: PUSH
17644: LD_INT 0
17646: PUSH
17647: EMPTY
17648: PUSH
17649: EMPTY
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: PUSH
17656: LD_INT 28
17658: PUSH
17659: LD_INT 15
17661: PUSH
17662: LD_INT 5
17664: PUSH
17665: LD_INT 2
17667: PUSH
17668: EMPTY
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: LIST
17674: LIST
17675: LIST
17676: PUSH
17677: LD_INT 29
17679: PUSH
17680: LD_INT 14
17682: PUSH
17683: LD_INT 23
17685: PUSH
17686: LD_INT 2
17688: PUSH
17689: EMPTY
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: LIST
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 34
17700: PUSH
17701: LD_INT 32
17703: PUSH
17704: LD_INT 20
17706: PUSH
17707: LD_INT 3
17709: PUSH
17710: EMPTY
17711: PUSH
17712: EMPTY
17713: LIST
17714: LIST
17715: LIST
17716: LIST
17717: LIST
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: LIST
17728: LIST
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: LIST
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: LIST
17739: LIST
17740: LIST
17741: LIST
17742: PUSH
17743: LD_INT 3
17745: PUSH
17746: LD_INT 98
17748: PUSH
17749: LD_INT 26
17751: PUSH
17752: LD_INT 5
17754: PUSH
17755: EMPTY
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: PUSH
17764: LD_INT 5
17766: PUSH
17767: LD_INT 80
17769: PUSH
17770: LD_INT 13
17772: PUSH
17773: LD_INT 0
17775: PUSH
17776: EMPTY
17777: PUSH
17778: EMPTY
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: PUSH
17785: LD_INT 28
17787: PUSH
17788: LD_INT 97
17790: PUSH
17791: LD_INT 3
17793: PUSH
17794: LD_INT 1
17796: PUSH
17797: EMPTY
17798: PUSH
17799: EMPTY
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: PUSH
17806: LD_INT 33
17808: PUSH
17809: LD_INT 105
17811: PUSH
17812: LD_INT 35
17814: PUSH
17815: LD_INT 3
17817: PUSH
17818: LD_INT 45
17820: PUSH
17821: EMPTY
17822: LIST
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: PUSH
17831: LD_INT 33
17833: PUSH
17834: LD_INT 111
17836: PUSH
17837: LD_INT 22
17839: PUSH
17840: LD_INT 2
17842: PUSH
17843: LD_INT 43
17845: PUSH
17846: EMPTY
17847: LIST
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: LIST
17855: PUSH
17856: LD_INT 33
17858: PUSH
17859: LD_INT 115
17861: PUSH
17862: LD_INT 27
17864: PUSH
17865: LD_INT 2
17867: PUSH
17868: LD_INT 45
17870: PUSH
17871: EMPTY
17872: LIST
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: LIST
17878: LIST
17879: LIST
17880: PUSH
17881: LD_INT 33
17883: PUSH
17884: LD_INT 65
17886: PUSH
17887: LD_INT 3
17889: PUSH
17890: LD_INT 3
17892: PUSH
17893: LD_INT 45
17895: PUSH
17896: EMPTY
17897: LIST
17898: PUSH
17899: LD_INT 42000
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: LIST
17909: PUSH
17910: LD_INT 33
17912: PUSH
17913: LD_INT 68
17915: PUSH
17916: LD_INT 3
17918: PUSH
17919: LD_INT 3
17921: PUSH
17922: LD_INT 45
17924: PUSH
17925: EMPTY
17926: LIST
17927: PUSH
17928: EMPTY
17929: LIST
17930: LIST
17931: LIST
17932: LIST
17933: LIST
17934: PUSH
17935: LD_INT 33
17937: PUSH
17938: LD_INT 71
17940: PUSH
17941: LD_INT 4
17943: PUSH
17944: LD_INT 3
17946: PUSH
17947: LD_INT 46
17949: PUSH
17950: EMPTY
17951: LIST
17952: PUSH
17953: EMPTY
17954: LIST
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: PUSH
17960: LD_INT 28
17962: PUSH
17963: LD_INT 101
17965: PUSH
17966: LD_INT 4
17968: PUSH
17969: LD_INT 5
17971: PUSH
17972: EMPTY
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 33
17983: PUSH
17984: LD_INT 108
17986: PUSH
17987: LD_INT 35
17989: PUSH
17990: LD_INT 2
17992: PUSH
17993: LD_INT 46
17995: PUSH
17996: EMPTY
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: PUSH
18006: LD_INT 16
18008: PUSH
18009: LD_INT 101
18011: PUSH
18012: LD_INT 26
18014: PUSH
18015: LD_INT 4
18017: PUSH
18018: EMPTY
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 17
18029: PUSH
18030: LD_INT 98
18032: PUSH
18033: LD_INT 22
18035: PUSH
18036: LD_INT 3
18038: PUSH
18039: EMPTY
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: PUSH
18048: LD_INT 21
18050: PUSH
18051: LD_INT 94
18053: PUSH
18054: LD_INT 26
18056: PUSH
18057: LD_INT 1
18059: PUSH
18060: EMPTY
18061: PUSH
18062: EMPTY
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 18
18071: PUSH
18072: LD_INT 98
18074: PUSH
18075: LD_INT 29
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: EMPTY
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 19
18092: PUSH
18093: LD_INT 102
18095: PUSH
18096: LD_INT 30
18098: PUSH
18099: LD_INT 5
18101: PUSH
18102: EMPTY
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 1
18113: PUSH
18114: LD_INT 86
18116: PUSH
18117: LD_INT 6
18119: PUSH
18120: LD_INT 3
18122: PUSH
18123: EMPTY
18124: PUSH
18125: EMPTY
18126: LIST
18127: LIST
18128: LIST
18129: LIST
18130: LIST
18131: PUSH
18132: LD_INT 30
18134: PUSH
18135: LD_INT 102
18137: PUSH
18138: LD_INT 9
18140: PUSH
18141: LD_INT 4
18143: PUSH
18144: EMPTY
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: LIST
18150: LIST
18151: LIST
18152: PUSH
18153: LD_INT 29
18155: PUSH
18156: LD_INT 77
18158: PUSH
18159: LD_INT 3
18161: PUSH
18162: LD_INT 4
18164: PUSH
18165: EMPTY
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: LIST
18171: LIST
18172: LIST
18173: PUSH
18174: LD_INT 8
18176: PUSH
18177: LD_INT 100
18179: PUSH
18180: LD_INT 17
18182: PUSH
18183: LD_INT 4
18185: PUSH
18186: LD_INT 11
18188: PUSH
18189: LD_INT 10
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: LIST
18200: LIST
18201: LIST
18202: PUSH
18203: LD_INT 7
18205: PUSH
18206: LD_INT 94
18208: PUSH
18209: LD_INT 6
18211: PUSH
18212: LD_INT 3
18214: PUSH
18215: LD_INT 12
18217: PUSH
18218: LD_INT 9
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: EMPTY
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: PUSH
18255: LD_INT 1
18257: PUSH
18258: LD_INT 90
18260: PUSH
18261: LD_INT 141
18263: PUSH
18264: LD_INT 0
18266: PUSH
18267: EMPTY
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: PUSH
18276: LD_INT 5
18278: PUSH
18279: LD_INT 98
18281: PUSH
18282: LD_INT 133
18284: PUSH
18285: LD_INT 4
18287: PUSH
18288: EMPTY
18289: PUSH
18290: EMPTY
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: PUSH
18297: LD_INT 28
18299: PUSH
18300: LD_INT 72
18302: PUSH
18303: LD_INT 133
18305: PUSH
18306: LD_INT 2
18308: PUSH
18309: EMPTY
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: PUSH
18318: LD_INT 32
18320: PUSH
18321: LD_INT 95
18323: PUSH
18324: LD_INT 128
18326: PUSH
18327: LD_INT 0
18329: PUSH
18330: LD_INT 45
18332: PUSH
18333: EMPTY
18334: LIST
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: PUSH
18343: LD_INT 32
18345: PUSH
18346: LD_INT 80
18348: PUSH
18349: LD_INT 122
18351: PUSH
18352: LD_INT 2
18354: PUSH
18355: LD_INT 45
18357: PUSH
18358: EMPTY
18359: LIST
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: LIST
18365: LIST
18366: LIST
18367: PUSH
18368: LD_INT 33
18370: PUSH
18371: LD_INT 95
18373: PUSH
18374: LD_INT 128
18376: PUSH
18377: LD_INT 0
18379: PUSH
18380: LD_INT 45
18382: PUSH
18383: EMPTY
18384: LIST
18385: PUSH
18386: LD_INT 31500
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 33
18399: PUSH
18400: LD_INT 80
18402: PUSH
18403: LD_INT 122
18405: PUSH
18406: LD_INT 2
18408: PUSH
18409: LD_INT 45
18411: PUSH
18412: EMPTY
18413: LIST
18414: PUSH
18415: LD_INT 35700
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: LIST
18424: LIST
18425: PUSH
18426: LD_INT 33
18428: PUSH
18429: LD_INT 112
18431: PUSH
18432: LD_INT 154
18434: PUSH
18435: LD_INT 1
18437: PUSH
18438: LD_INT 45
18440: PUSH
18441: EMPTY
18442: LIST
18443: PUSH
18444: LD_INT 33600
18446: PUSH
18447: EMPTY
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: PUSH
18455: LD_INT 33
18457: PUSH
18458: LD_INT 78
18460: PUSH
18461: LD_INT 124
18463: PUSH
18464: LD_INT 2
18466: PUSH
18467: LD_INT 46
18469: PUSH
18470: EMPTY
18471: LIST
18472: PUSH
18473: LD_INT 42000
18475: PUSH
18476: EMPTY
18477: LIST
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 33
18486: PUSH
18487: LD_INT 99
18489: PUSH
18490: LD_INT 130
18492: PUSH
18493: LD_INT 1
18495: PUSH
18496: LD_INT 46
18498: PUSH
18499: EMPTY
18500: LIST
18501: PUSH
18502: LD_INT 46200
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: PUSH
18513: LD_INT 33
18515: PUSH
18516: LD_INT 112
18518: PUSH
18519: LD_INT 151
18521: PUSH
18522: LD_INT 1
18524: PUSH
18525: LD_INT 43
18527: PUSH
18528: EMPTY
18529: LIST
18530: PUSH
18531: LD_INT 52500
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: LIST
18540: LIST
18541: PUSH
18542: LD_INT 3
18544: PUSH
18545: LD_INT 81
18547: PUSH
18548: LD_INT 135
18550: PUSH
18551: LD_INT 5
18553: PUSH
18554: EMPTY
18555: PUSH
18556: EMPTY
18557: LIST
18558: LIST
18559: LIST
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 21
18565: PUSH
18566: LD_INT 84
18568: PUSH
18569: LD_INT 135
18571: PUSH
18572: LD_INT 4
18574: PUSH
18575: EMPTY
18576: PUSH
18577: EMPTY
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: LIST
18583: PUSH
18584: LD_INT 17
18586: PUSH
18587: LD_INT 85
18589: PUSH
18590: LD_INT 139
18592: PUSH
18593: LD_INT 5
18595: PUSH
18596: EMPTY
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: LIST
18604: PUSH
18605: LD_INT 16
18607: PUSH
18608: LD_INT 77
18610: PUSH
18611: LD_INT 135
18613: PUSH
18614: LD_INT 1
18616: PUSH
18617: EMPTY
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: LIST
18625: PUSH
18626: LD_INT 18
18628: PUSH
18629: LD_INT 81
18631: PUSH
18632: LD_INT 138
18634: PUSH
18635: LD_INT 0
18637: PUSH
18638: EMPTY
18639: PUSH
18640: LD_INT 29400
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: LIST
18647: LIST
18648: LIST
18649: LIST
18650: PUSH
18651: LD_INT 30
18653: PUSH
18654: LD_INT 71
18656: PUSH
18657: LD_INT 137
18659: PUSH
18660: LD_INT 0
18662: PUSH
18663: EMPTY
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: LIST
18669: LIST
18670: LIST
18671: PUSH
18672: LD_INT 29
18674: PUSH
18675: LD_INT 69
18677: PUSH
18678: LD_INT 133
18680: PUSH
18681: LD_INT 5
18683: PUSH
18684: EMPTY
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 7
18695: PUSH
18696: LD_INT 102
18698: PUSH
18699: LD_INT 153
18701: PUSH
18702: LD_INT 0
18704: PUSH
18705: LD_INT 12
18707: PUSH
18708: LD_INT 9
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: PUSH
18715: LD_INT 73500
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: PUSH
18726: LD_INT 8
18728: PUSH
18729: LD_INT 97
18731: PUSH
18732: LD_INT 145
18734: PUSH
18735: LD_INT 2
18737: PUSH
18738: LD_INT 10
18740: PUSH
18741: LD_INT 11
18743: PUSH
18744: EMPTY
18745: LIST
18746: LIST
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: LIST
18754: PUSH
18755: LD_INT 28
18757: PUSH
18758: LD_INT 74
18760: PUSH
18761: LD_INT 137
18763: PUSH
18764: LD_INT 2
18766: PUSH
18767: EMPTY
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: LIST
18775: PUSH
18776: LD_INT 24
18778: PUSH
18779: LD_INT 81
18781: PUSH
18782: LD_INT 131
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: PUSH
18821: LD_INT 1
18823: PUSH
18824: LD_INT 217
18826: PUSH
18827: LD_INT 129
18829: PUSH
18830: LD_INT 3
18832: PUSH
18833: EMPTY
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 28
18844: PUSH
18845: LD_INT 233
18847: PUSH
18848: LD_INT 154
18850: PUSH
18851: LD_INT 4
18853: PUSH
18854: EMPTY
18855: PUSH
18856: EMPTY
18857: LIST
18858: LIST
18859: LIST
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 33
18865: PUSH
18866: LD_INT 205
18868: PUSH
18869: LD_INT 123
18871: PUSH
18872: LD_INT 0
18874: PUSH
18875: LD_INT 43
18877: PUSH
18878: EMPTY
18879: LIST
18880: PUSH
18881: LD_INT 52500
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: PUSH
18892: LD_INT 33
18894: PUSH
18895: LD_INT 200
18897: PUSH
18898: LD_INT 142
18900: PUSH
18901: LD_INT 4
18903: PUSH
18904: LD_INT 46
18906: PUSH
18907: EMPTY
18908: LIST
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 33
18919: PUSH
18920: LD_INT 199
18922: PUSH
18923: LD_INT 135
18925: PUSH
18926: LD_INT 4
18928: PUSH
18929: LD_INT 46
18931: PUSH
18932: EMPTY
18933: LIST
18934: PUSH
18935: LD_INT 58800
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 33
18948: PUSH
18949: LD_INT 201
18951: PUSH
18952: LD_INT 127
18954: PUSH
18955: LD_INT 5
18957: PUSH
18958: LD_INT 46
18960: PUSH
18961: EMPTY
18962: LIST
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: LIST
18970: PUSH
18971: LD_INT 33
18973: PUSH
18974: LD_INT 199
18976: PUSH
18977: LD_INT 138
18979: PUSH
18980: LD_INT 4
18982: PUSH
18983: LD_INT 45
18985: PUSH
18986: EMPTY
18987: LIST
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: LIST
18993: LIST
18994: LIST
18995: PUSH
18996: LD_INT 33
18998: PUSH
18999: LD_INT 202
19001: PUSH
19002: LD_INT 124
19004: PUSH
19005: LD_INT 5
19007: PUSH
19008: LD_INT 45
19010: PUSH
19011: EMPTY
19012: LIST
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: LIST
19018: LIST
19019: LIST
19020: PUSH
19021: LD_INT 33
19023: PUSH
19024: LD_INT 209
19026: PUSH
19027: LD_INT 154
19029: PUSH
19030: LD_INT 3
19032: PUSH
19033: LD_INT 45
19035: PUSH
19036: EMPTY
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: LIST
19045: PUSH
19046: LD_INT 33
19048: PUSH
19049: LD_INT 218
19051: PUSH
19052: LD_INT 123
19054: PUSH
19055: LD_INT 5
19057: PUSH
19058: LD_INT 45
19060: PUSH
19061: EMPTY
19062: LIST
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: LIST
19068: LIST
19069: LIST
19070: PUSH
19071: LD_INT 8
19073: PUSH
19074: LD_INT 227
19076: PUSH
19077: LD_INT 145
19079: PUSH
19080: LD_INT 2
19082: PUSH
19083: LD_INT 12
19085: PUSH
19086: LD_INT 14
19088: PUSH
19089: EMPTY
19090: LIST
19091: LIST
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 8
19102: PUSH
19103: LD_INT 221
19105: PUSH
19106: LD_INT 153
19108: PUSH
19109: LD_INT 4
19111: PUSH
19112: LD_INT 10
19114: PUSH
19115: LD_INT 11
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: EMPTY
19123: LIST
19124: LIST
19125: LIST
19126: LIST
19127: LIST
19128: PUSH
19129: LD_INT 28
19131: PUSH
19132: LD_INT 231
19134: PUSH
19135: LD_INT 155
19137: PUSH
19138: LD_INT 4
19140: PUSH
19141: EMPTY
19142: PUSH
19143: EMPTY
19144: LIST
19145: LIST
19146: LIST
19147: LIST
19148: LIST
19149: PUSH
19150: LD_INT 29
19152: PUSH
19153: LD_INT 224
19155: PUSH
19156: LD_INT 134
19158: PUSH
19159: LD_INT 4
19161: PUSH
19162: EMPTY
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: PUSH
19171: LD_INT 30
19173: PUSH
19174: LD_INT 224
19176: PUSH
19177: LD_INT 150
19179: PUSH
19180: LD_INT 2
19182: PUSH
19183: EMPTY
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: PUSH
19192: LD_INT 3
19194: PUSH
19195: LD_INT 207
19197: PUSH
19198: LD_INT 141
19200: PUSH
19201: LD_INT 1
19203: PUSH
19204: EMPTY
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: LIST
19210: LIST
19211: LIST
19212: PUSH
19213: LD_INT 24
19215: PUSH
19216: LD_INT 211
19218: PUSH
19219: LD_INT 145
19221: PUSH
19222: LD_INT 5
19224: PUSH
19225: EMPTY
19226: PUSH
19227: EMPTY
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: LIST
19233: PUSH
19234: LD_INT 21
19236: PUSH
19237: LD_INT 207
19239: PUSH
19240: LD_INT 144
19242: PUSH
19243: LD_INT 0
19245: PUSH
19246: EMPTY
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: PUSH
19255: LD_INT 18
19257: PUSH
19258: LD_INT 203
19260: PUSH
19261: LD_INT 141
19263: PUSH
19264: LD_INT 1
19266: PUSH
19267: EMPTY
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: LIST
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 16
19278: PUSH
19279: LD_INT 204
19281: PUSH
19282: LD_INT 138
19284: PUSH
19285: LD_INT 2
19287: PUSH
19288: EMPTY
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: LIST
19294: LIST
19295: LIST
19296: PUSH
19297: LD_INT 17
19299: PUSH
19300: LD_INT 207
19302: PUSH
19303: LD_INT 137
19305: PUSH
19306: LD_INT 3
19308: PUSH
19309: EMPTY
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: PUSH
19318: LD_INT 4
19320: PUSH
19321: LD_INT 210
19323: PUSH
19324: LD_INT 128
19326: PUSH
19327: LD_INT 2
19329: PUSH
19330: EMPTY
19331: PUSH
19332: LD_INT 73500
19334: PUSH
19335: EMPTY
19336: LIST
19337: LIST
19338: LIST
19339: LIST
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 4
19345: PUSH
19346: LD_INT 210
19348: PUSH
19349: LD_INT 128
19351: PUSH
19352: LD_INT 2
19354: PUSH
19355: EMPTY
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: LIST
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 1
19391: PUSH
19392: LD_INT 184
19394: PUSH
19395: LD_INT 73
19397: PUSH
19398: LD_INT 3
19400: PUSH
19401: EMPTY
19402: PUSH
19403: EMPTY
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: PUSH
19410: LD_INT 5
19412: PUSH
19413: LD_INT 188
19415: PUSH
19416: LD_INT 94
19418: PUSH
19419: LD_INT 5
19421: PUSH
19422: EMPTY
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: PUSH
19431: LD_INT 33
19433: PUSH
19434: LD_INT 171
19436: PUSH
19437: LD_INT 92
19439: PUSH
19440: LD_INT 3
19442: PUSH
19443: LD_INT 45
19445: PUSH
19446: EMPTY
19447: LIST
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: PUSH
19456: LD_INT 33
19458: PUSH
19459: LD_INT 177
19461: PUSH
19462: LD_INT 98
19464: PUSH
19465: LD_INT 3
19467: PUSH
19468: LD_INT 46
19470: PUSH
19471: EMPTY
19472: LIST
19473: PUSH
19474: EMPTY
19475: LIST
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: PUSH
19481: LD_INT 33
19483: PUSH
19484: LD_INT 169
19486: PUSH
19487: LD_INT 69
19489: PUSH
19490: LD_INT 5
19492: PUSH
19493: LD_INT 46
19495: PUSH
19496: EMPTY
19497: LIST
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: PUSH
19506: LD_INT 33
19508: PUSH
19509: LD_INT 170
19511: PUSH
19512: LD_INT 66
19514: PUSH
19515: LD_INT 5
19517: PUSH
19518: LD_INT 45
19520: PUSH
19521: EMPTY
19522: LIST
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: PUSH
19531: LD_INT 33
19533: PUSH
19534: LD_INT 184
19536: PUSH
19537: LD_INT 62
19539: PUSH
19540: LD_INT 5
19542: PUSH
19543: LD_INT 43
19545: PUSH
19546: EMPTY
19547: LIST
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: LIST
19553: LIST
19554: LIST
19555: PUSH
19556: LD_INT 33
19558: PUSH
19559: LD_INT 203
19561: PUSH
19562: LD_INT 102
19564: PUSH
19565: LD_INT 2
19567: PUSH
19568: LD_INT 45
19570: PUSH
19571: EMPTY
19572: LIST
19573: PUSH
19574: LD_INT 63000
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: LIST
19584: PUSH
19585: LD_INT 33
19587: PUSH
19588: LD_INT 195
19590: PUSH
19591: LD_INT 103
19593: PUSH
19594: LD_INT 2
19596: PUSH
19597: LD_INT 45
19599: PUSH
19600: EMPTY
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: LIST
19609: PUSH
19610: LD_INT 33
19612: PUSH
19613: LD_INT 200
19615: PUSH
19616: LD_INT 103
19618: PUSH
19619: LD_INT 2
19621: PUSH
19622: LD_INT 46
19624: PUSH
19625: EMPTY
19626: LIST
19627: PUSH
19628: EMPTY
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: PUSH
19635: LD_INT 28
19637: PUSH
19638: LD_INT 198
19640: PUSH
19641: LD_INT 90
19643: PUSH
19644: LD_INT 3
19646: PUSH
19647: EMPTY
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: PUSH
19656: LD_INT 30
19658: PUSH
19659: LD_INT 179
19661: PUSH
19662: LD_INT 70
19664: PUSH
19665: LD_INT 1
19667: PUSH
19668: EMPTY
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: PUSH
19677: LD_INT 3
19679: PUSH
19680: LD_INT 190
19682: PUSH
19683: LD_INT 84
19685: PUSH
19686: LD_INT 4
19688: PUSH
19689: EMPTY
19690: PUSH
19691: EMPTY
19692: LIST
19693: LIST
19694: LIST
19695: LIST
19696: LIST
19697: PUSH
19698: LD_INT 17
19700: PUSH
19701: LD_INT 190
19703: PUSH
19704: LD_INT 88
19706: PUSH
19707: LD_INT 0
19709: PUSH
19710: EMPTY
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: PUSH
19719: LD_INT 18
19721: PUSH
19722: LD_INT 193
19724: PUSH
19725: LD_INT 87
19727: PUSH
19728: LD_INT 5
19730: PUSH
19731: EMPTY
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: PUSH
19740: LD_INT 21
19742: PUSH
19743: LD_INT 194
19745: PUSH
19746: LD_INT 84
19748: PUSH
19749: LD_INT 4
19751: PUSH
19752: EMPTY
19753: PUSH
19754: EMPTY
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: PUSH
19761: LD_INT 24
19763: PUSH
19764: LD_INT 190
19766: PUSH
19767: LD_INT 81
19769: PUSH
19770: LD_INT 3
19772: PUSH
19773: EMPTY
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: PUSH
19782: LD_INT 8
19784: PUSH
19785: LD_INT 176
19787: PUSH
19788: LD_INT 92
19790: PUSH
19791: LD_INT 0
19793: PUSH
19794: LD_INT 11
19796: PUSH
19797: LD_INT 9
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: PUSH
19804: EMPTY
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: PUSH
19811: LD_INT 8
19813: PUSH
19814: LD_INT 176
19816: PUSH
19817: LD_INT 82
19819: PUSH
19820: LD_INT 3
19822: PUSH
19823: LD_INT 12
19825: PUSH
19826: LD_INT 10
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: PUSH
19833: EMPTY
19834: LIST
19835: LIST
19836: LIST
19837: LIST
19838: LIST
19839: PUSH
19840: LD_INT 28
19842: PUSH
19843: LD_INT 196
19845: PUSH
19846: LD_INT 92
19848: PUSH
19849: LD_INT 5
19851: PUSH
19852: EMPTY
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: PUSH
19861: LD_INT 28
19863: PUSH
19864: LD_INT 198
19866: PUSH
19867: LD_INT 86
19869: PUSH
19870: LD_INT 1
19872: PUSH
19873: EMPTY
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: PUSH
19882: LD_INT 30
19884: PUSH
19885: LD_INT 192
19887: PUSH
19888: LD_INT 93
19890: PUSH
19891: LD_INT 0
19893: PUSH
19894: EMPTY
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: LIST
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: LIST
19919: LIST
19920: LIST
19921: LIST
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: LIST
19933: ST_TO_ADDR
// in_depots := [ [ 820 , 720 , 421 ] , [ 770 , 620 , 320 ] , [ 680 , 900 , 310 ] , [ 730 , 920 , 240 ] , [ 510 , 810 , 300 ] ] ;
19934: LD_ADDR_LOC 25
19938: PUSH
19939: LD_INT 820
19941: PUSH
19942: LD_INT 720
19944: PUSH
19945: LD_INT 421
19947: PUSH
19948: EMPTY
19949: LIST
19950: LIST
19951: LIST
19952: PUSH
19953: LD_INT 770
19955: PUSH
19956: LD_INT 620
19958: PUSH
19959: LD_INT 320
19961: PUSH
19962: EMPTY
19963: LIST
19964: LIST
19965: LIST
19966: PUSH
19967: LD_INT 680
19969: PUSH
19970: LD_INT 900
19972: PUSH
19973: LD_INT 310
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: LIST
19980: PUSH
19981: LD_INT 730
19983: PUSH
19984: LD_INT 920
19986: PUSH
19987: LD_INT 240
19989: PUSH
19990: EMPTY
19991: LIST
19992: LIST
19993: LIST
19994: PUSH
19995: LD_INT 510
19997: PUSH
19998: LD_INT 810
20000: PUSH
20001: LD_INT 300
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: LIST
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: ST_TO_ADDR
// end ;
20016: LD_VAR 0 1
20020: RET
// function UpgradeableTo ( b , up ) ; var i ; begin
20021: LD_INT 0
20023: PPUSH
20024: PPUSH
// result := 0 ;
20025: LD_ADDR_VAR 0 3
20029: PUSH
20030: LD_INT 0
20032: ST_TO_ADDR
// for i := 1 to upgradeable do
20033: LD_ADDR_VAR 0 4
20037: PUSH
20038: DOUBLE
20039: LD_INT 1
20041: DEC
20042: ST_TO_ADDR
20043: LD_LOC 27
20047: PUSH
20048: FOR_TO
20049: IFFALSE 20101
// if b = upgradeable [ i ] and up = trough_upgrade [ i ] then
20051: LD_VAR 0 1
20055: PUSH
20056: LD_LOC 27
20060: PUSH
20061: LD_VAR 0 4
20065: ARRAY
20066: EQUAL
20067: PUSH
20068: LD_VAR 0 2
20072: PUSH
20073: LD_LOC 28
20077: PUSH
20078: LD_VAR 0 4
20082: ARRAY
20083: EQUAL
20084: AND
20085: IFFALSE 20099
// begin result := up ;
20087: LD_ADDR_VAR 0 3
20091: PUSH
20092: LD_VAR 0 2
20096: ST_TO_ADDR
// break ;
20097: GO 20101
// end ;
20099: GO 20048
20101: POP
20102: POP
// end ;
20103: LD_VAR 0 3
20107: RET
// function IsUpgraded ( b ) ; begin
20108: LD_INT 0
20110: PPUSH
// result := 0 ;
20111: LD_ADDR_VAR 0 2
20115: PUSH
20116: LD_INT 0
20118: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20119: LD_VAR 0 1
20123: PUSH
20124: LD_LOC 28
20128: PUSH
20129: LD_INT 1
20131: ARRAY
20132: DOUBLE
20133: EQUAL
20134: IFTRUE 20138
20136: GO 20155
20138: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20139: LD_ADDR_VAR 0 2
20143: PUSH
20144: LD_LOC 27
20148: PUSH
20149: LD_INT 1
20151: ARRAY
20152: ST_TO_ADDR
20153: GO 20280
20155: LD_LOC 28
20159: PUSH
20160: LD_INT 2
20162: ARRAY
20163: DOUBLE
20164: EQUAL
20165: IFTRUE 20169
20167: GO 20186
20169: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20170: LD_ADDR_VAR 0 2
20174: PUSH
20175: LD_LOC 27
20179: PUSH
20180: LD_INT 2
20182: ARRAY
20183: ST_TO_ADDR
20184: GO 20280
20186: LD_LOC 28
20190: PUSH
20191: LD_INT 3
20193: ARRAY
20194: DOUBLE
20195: EQUAL
20196: IFTRUE 20200
20198: GO 20217
20200: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20201: LD_ADDR_VAR 0 2
20205: PUSH
20206: LD_LOC 27
20210: PUSH
20211: LD_INT 3
20213: ARRAY
20214: ST_TO_ADDR
20215: GO 20280
20217: LD_LOC 28
20221: PUSH
20222: LD_INT 4
20224: ARRAY
20225: DOUBLE
20226: EQUAL
20227: IFTRUE 20231
20229: GO 20248
20231: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 5 ] :
20232: LD_ADDR_VAR 0 2
20236: PUSH
20237: LD_LOC 27
20241: PUSH
20242: LD_INT 4
20244: ARRAY
20245: ST_TO_ADDR
20246: GO 20280
20248: LD_LOC 28
20252: PUSH
20253: LD_INT 5
20255: ARRAY
20256: DOUBLE
20257: EQUAL
20258: IFTRUE 20262
20260: GO 20279
20262: POP
// result := upgradeable [ 5 ] ; end ;
20263: LD_ADDR_VAR 0 2
20267: PUSH
20268: LD_LOC 27
20272: PUSH
20273: LD_INT 5
20275: ARRAY
20276: ST_TO_ADDR
20277: GO 20280
20279: POP
// end ;
20280: LD_VAR 0 2
20284: RET
// function BasicFrom ( b ) ; begin
20285: LD_INT 0
20287: PPUSH
// result := b ;
20288: LD_ADDR_VAR 0 2
20292: PUSH
20293: LD_VAR 0 1
20297: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20298: LD_VAR 0 1
20302: PUSH
20303: LD_LOC 28
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: DOUBLE
20312: EQUAL
20313: IFTRUE 20317
20315: GO 20334
20317: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20318: LD_ADDR_VAR 0 2
20322: PUSH
20323: LD_LOC 27
20327: PUSH
20328: LD_INT 1
20330: ARRAY
20331: ST_TO_ADDR
20332: GO 20459
20334: LD_LOC 28
20338: PUSH
20339: LD_INT 2
20341: ARRAY
20342: DOUBLE
20343: EQUAL
20344: IFTRUE 20348
20346: GO 20365
20348: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_LOC 27
20358: PUSH
20359: LD_INT 2
20361: ARRAY
20362: ST_TO_ADDR
20363: GO 20459
20365: LD_LOC 28
20369: PUSH
20370: LD_INT 3
20372: ARRAY
20373: DOUBLE
20374: EQUAL
20375: IFTRUE 20379
20377: GO 20396
20379: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20380: LD_ADDR_VAR 0 2
20384: PUSH
20385: LD_LOC 27
20389: PUSH
20390: LD_INT 3
20392: ARRAY
20393: ST_TO_ADDR
20394: GO 20459
20396: LD_LOC 28
20400: PUSH
20401: LD_INT 4
20403: ARRAY
20404: DOUBLE
20405: EQUAL
20406: IFTRUE 20410
20408: GO 20427
20410: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 6 ] :
20411: LD_ADDR_VAR 0 2
20415: PUSH
20416: LD_LOC 27
20420: PUSH
20421: LD_INT 4
20423: ARRAY
20424: ST_TO_ADDR
20425: GO 20459
20427: LD_LOC 28
20431: PUSH
20432: LD_INT 6
20434: ARRAY
20435: DOUBLE
20436: EQUAL
20437: IFTRUE 20441
20439: GO 20458
20441: POP
// result := upgradeable [ 6 ] ; end ;
20442: LD_ADDR_VAR 0 2
20446: PUSH
20447: LD_LOC 27
20451: PUSH
20452: LD_INT 6
20454: ARRAY
20455: ST_TO_ADDR
20456: GO 20459
20458: POP
// end ;
20459: LD_VAR 0 2
20463: RET
// export function build_map ; var i , j ; begin
20464: LD_INT 0
20466: PPUSH
20467: PPUSH
20468: PPUSH
// for i := 1 to 5 do
20469: LD_ADDR_VAR 0 2
20473: PUSH
20474: DOUBLE
20475: LD_INT 1
20477: DEC
20478: ST_TO_ADDR
20479: LD_INT 5
20481: PUSH
20482: FOR_TO
20483: IFFALSE 20550
// buildings := replace ( buildings , i , place_base ( builds [ i ] , in_depots [ i ] , ai_s [ i ] , ai_nation ) ) ;
20485: LD_ADDR_EXP 75
20489: PUSH
20490: LD_EXP 75
20494: PPUSH
20495: LD_VAR 0 2
20499: PPUSH
20500: LD_LOC 23
20504: PUSH
20505: LD_VAR 0 2
20509: ARRAY
20510: PPUSH
20511: LD_LOC 25
20515: PUSH
20516: LD_VAR 0 2
20520: ARRAY
20521: PPUSH
20522: LD_EXP 23
20526: PUSH
20527: LD_VAR 0 2
20531: ARRAY
20532: PPUSH
20533: LD_EXP 22
20537: PPUSH
20538: CALL 20790 0 4
20542: PPUSH
20543: CALL_OW 1
20547: ST_TO_ADDR
20548: GO 20482
20550: POP
20551: POP
// hlavouni := [ Platonov , Gossudarov , Borodin , Tsaritsyn , Davidov , Eisenstein ] ;
20552: LD_ADDR_EXP 72
20556: PUSH
20557: LD_EXP 42
20561: PUSH
20562: LD_EXP 43
20566: PUSH
20567: LD_EXP 46
20571: PUSH
20572: LD_EXP 47
20576: PUSH
20577: LD_EXP 48
20581: PUSH
20582: LD_EXP 49
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , da ) ;
20595: LD_EXP 42
20599: PPUSH
20600: LD_INT 1
20602: PPUSH
20603: CALL_OW 52
// PlaceHumanInUnit ( Gossudarov , art_cargo ) ;
20607: LD_EXP 43
20611: PPUSH
20612: LD_INT 121
20614: PPUSH
20615: CALL_OW 52
// PlaceHumanInUnit ( Borodin , db ) ;
20619: LD_EXP 46
20623: PPUSH
20624: LD_INT 51
20626: PPUSH
20627: CALL_OW 52
// PlaceHumanInUnit ( Tsaritsyn , dc ) ;
20631: LD_EXP 47
20635: PPUSH
20636: LD_INT 80
20638: PPUSH
20639: CALL_OW 52
// PlaceHumanInUnit ( Davidov , dd ) ;
20643: LD_EXP 48
20647: PPUSH
20648: LD_INT 28
20650: PPUSH
20651: CALL_OW 52
// PlaceHumanInUnit ( Eisenstein , de ) ;
20655: LD_EXP 49
20659: PPUSH
20660: LD_INT 37
20662: PPUSH
20663: CALL_OW 52
// for i := 1 to 5 do
20667: LD_ADDR_VAR 0 2
20671: PUSH
20672: DOUBLE
20673: LD_INT 1
20675: DEC
20676: ST_TO_ADDR
20677: LD_INT 5
20679: PUSH
20680: FOR_TO
20681: IFFALSE 20783
// begin humans := replace ( humans , i , place_aici ( aici [ i ] , abase [ i ] , ai_s [ i ] , ai_nation ) ) ;
20683: LD_ADDR_EXP 76
20687: PUSH
20688: LD_EXP 76
20692: PPUSH
20693: LD_VAR 0 2
20697: PPUSH
20698: LD_LOC 24
20702: PUSH
20703: LD_VAR 0 2
20707: ARRAY
20708: PPUSH
20709: LD_LOC 26
20713: PUSH
20714: LD_VAR 0 2
20718: ARRAY
20719: PPUSH
20720: LD_EXP 23
20724: PUSH
20725: LD_VAR 0 2
20729: ARRAY
20730: PPUSH
20731: LD_EXP 22
20735: PPUSH
20736: CALL 21242 0 4
20740: PPUSH
20741: CALL_OW 1
20745: ST_TO_ADDR
// for j in humans [ i ] do
20746: LD_ADDR_VAR 0 3
20750: PUSH
20751: LD_EXP 76
20755: PUSH
20756: LD_VAR 0 2
20760: ARRAY
20761: PUSH
20762: FOR_IN
20763: IFFALSE 20779
// SetTag ( j , 1 ) ;
20765: LD_VAR 0 3
20769: PPUSH
20770: LD_INT 1
20772: PPUSH
20773: CALL_OW 109
20777: GO 20762
20779: POP
20780: POP
// end ;
20781: GO 20680
20783: POP
20784: POP
// end ;
20785: LD_VAR 0 1
20789: RET
// function place_base ( builds , in_depot , side , nat ) ; var i , base , b , tb , bb , cans , oil , sib ; begin
20790: LD_INT 0
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
20796: PPUSH
20797: PPUSH
20798: PPUSH
20799: PPUSH
20800: PPUSH
// cans := in_depot [ 1 ] ;
20801: LD_ADDR_VAR 0 11
20805: PUSH
20806: LD_VAR 0 2
20810: PUSH
20811: LD_INT 1
20813: ARRAY
20814: ST_TO_ADDR
// oil := in_depot [ 2 ] ;
20815: LD_ADDR_VAR 0 12
20819: PUSH
20820: LD_VAR 0 2
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: ST_TO_ADDR
// sib := in_depot [ 3 ] ;
20829: LD_ADDR_VAR 0 13
20833: PUSH
20834: LD_VAR 0 2
20838: PUSH
20839: LD_INT 3
20841: ARRAY
20842: ST_TO_ADDR
// InitUc ;
20843: CALL_OW 18
// InitBc ;
20847: CALL_OW 21
// uc_side := side ;
20851: LD_ADDR_OWVAR 20
20855: PUSH
20856: LD_VAR 0 3
20860: ST_TO_ADDR
// uc_nation := nat ;
20861: LD_ADDR_OWVAR 21
20865: PUSH
20866: LD_VAR 0 4
20870: ST_TO_ADDR
// b := [ ] ;
20871: LD_ADDR_VAR 0 8
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// for i in builds do
20878: LD_ADDR_VAR 0 6
20882: PUSH
20883: LD_VAR 0 1
20887: PUSH
20888: FOR_IN
20889: IFFALSE 21119
// begin if i = 5 then
20891: LD_VAR 0 6
20895: PUSH
20896: LD_INT 5
20898: EQUAL
20899: IFFALSE 21117
// begin tb := get_build ( i [ 2 ] , i [ 3 ] , 0 ) ;
20901: LD_ADDR_VAR 0 9
20905: PUSH
20906: LD_VAR 0 6
20910: PUSH
20911: LD_INT 2
20913: ARRAY
20914: PPUSH
20915: LD_VAR 0 6
20919: PUSH
20920: LD_INT 3
20922: ARRAY
20923: PPUSH
20924: LD_INT 0
20926: PPUSH
20927: CALL 22087 0 3
20931: ST_TO_ADDR
// if not tb then
20932: LD_VAR 0 9
20936: NOT
20937: IFFALSE 21098
// begin bc_type := i [ 1 ] ;
20939: LD_ADDR_OWVAR 42
20943: PUSH
20944: LD_VAR 0 6
20948: PUSH
20949: LD_INT 1
20951: ARRAY
20952: ST_TO_ADDR
// if bc_type = b_lab or bc_type = b_lab_half or bc_type = b_lab_full then
20953: LD_OWVAR 42
20957: PUSH
20958: LD_INT 6
20960: EQUAL
20961: PUSH
20962: LD_OWVAR 42
20966: PUSH
20967: LD_INT 7
20969: EQUAL
20970: OR
20971: PUSH
20972: LD_OWVAR 42
20976: PUSH
20977: LD_INT 8
20979: EQUAL
20980: OR
20981: IFFALSE 21019
// begin bc_kind1 := i [ 5 ] [ 1 ] ;
20983: LD_ADDR_OWVAR 44
20987: PUSH
20988: LD_VAR 0 6
20992: PUSH
20993: LD_INT 5
20995: ARRAY
20996: PUSH
20997: LD_INT 1
20999: ARRAY
21000: ST_TO_ADDR
// bc_kind2 := i [ 5 ] [ 2 ] ;
21001: LD_ADDR_OWVAR 45
21005: PUSH
21006: LD_VAR 0 6
21010: PUSH
21011: LD_INT 5
21013: ARRAY
21014: PUSH
21015: LD_INT 2
21017: ARRAY
21018: ST_TO_ADDR
// end ; tb := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
21019: LD_ADDR_VAR 0 9
21023: PUSH
21024: LD_VAR 0 6
21028: PUSH
21029: LD_INT 2
21031: ARRAY
21032: PPUSH
21033: LD_VAR 0 6
21037: PUSH
21038: LD_INT 3
21040: ARRAY
21041: PPUSH
21042: LD_VAR 0 6
21046: PUSH
21047: LD_INT 4
21049: ARRAY
21050: PPUSH
21051: CALL_OW 47
21055: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
21056: LD_OWVAR 42
21060: PUSH
21061: LD_INT 32
21063: EQUAL
21064: PUSH
21065: LD_OWVAR 42
21069: PUSH
21070: LD_INT 33
21072: EQUAL
21073: OR
21074: IFFALSE 21098
// PlaceWeaponTurret ( tb , i [ 5 ] [ 1 ] ) ;
21076: LD_VAR 0 9
21080: PPUSH
21081: LD_VAR 0 6
21085: PUSH
21086: LD_INT 5
21088: ARRAY
21089: PUSH
21090: LD_INT 1
21092: ARRAY
21093: PPUSH
21094: CALL_OW 431
// end ; b := b ^ [ tb ] ;
21098: LD_ADDR_VAR 0 8
21102: PUSH
21103: LD_VAR 0 8
21107: PUSH
21108: LD_VAR 0 9
21112: PUSH
21113: EMPTY
21114: LIST
21115: ADD
21116: ST_TO_ADDR
// end ; end ;
21117: GO 20888
21119: POP
21120: POP
// bb := UnitFilter ( b , [ mf_dep ] ) ;
21121: LD_ADDR_VAR 0 10
21125: PUSH
21126: LD_VAR 0 8
21130: PPUSH
21131: LD_EXP 58
21135: PUSH
21136: EMPTY
21137: LIST
21138: PPUSH
21139: CALL_OW 72
21143: ST_TO_ADDR
// for i in bb do
21144: LD_ADDR_VAR 0 6
21148: PUSH
21149: LD_VAR 0 10
21153: PUSH
21154: FOR_IN
21155: IFFALSE 21225
// begin base := GetBase ( i ) ;
21157: LD_ADDR_VAR 0 7
21161: PUSH
21162: LD_VAR 0 6
21166: PPUSH
21167: CALL_OW 274
21171: ST_TO_ADDR
// SetResourceType ( base , mat_cans , cans ) ;
21172: LD_VAR 0 7
21176: PPUSH
21177: LD_INT 1
21179: PPUSH
21180: LD_VAR 0 11
21184: PPUSH
21185: CALL_OW 277
// SetResourceType ( base , mat_oil , oil ) ;
21189: LD_VAR 0 7
21193: PPUSH
21194: LD_INT 2
21196: PPUSH
21197: LD_VAR 0 12
21201: PPUSH
21202: CALL_OW 277
// SetResourceType ( base , mat_siberit , sib ) ;
21206: LD_VAR 0 7
21210: PPUSH
21211: LD_INT 3
21213: PPUSH
21214: LD_VAR 0 13
21218: PPUSH
21219: CALL_OW 277
// end ;
21223: GO 21154
21225: POP
21226: POP
// result := b ;
21227: LD_ADDR_VAR 0 5
21231: PUSH
21232: LD_VAR 0 8
21236: ST_TO_ADDR
// end ;
21237: LD_VAR 0 5
21241: RET
// function place_aici ( aici , area , side , nat ) ; var i , j , a ; begin
21242: LD_INT 0
21244: PPUSH
21245: PPUSH
21246: PPUSH
21247: PPUSH
// InitUc ;
21248: CALL_OW 18
// InitHc ;
21252: CALL_OW 19
// uc_side := side ;
21256: LD_ADDR_OWVAR 20
21260: PUSH
21261: LD_VAR 0 3
21265: ST_TO_ADDR
// uc_nation := nat ;
21266: LD_ADDR_OWVAR 21
21270: PUSH
21271: LD_VAR 0 4
21275: ST_TO_ADDR
// a := [ ] ;
21276: LD_ADDR_VAR 0 8
21280: PUSH
21281: EMPTY
21282: ST_TO_ADDR
// for i in aici do
21283: LD_ADDR_VAR 0 6
21287: PUSH
21288: LD_VAR 0 1
21292: PUSH
21293: FOR_IN
21294: IFFALSE 21368
// begin for j := 1 to i [ 1 ] do
21296: LD_ADDR_VAR 0 7
21300: PUSH
21301: DOUBLE
21302: LD_INT 1
21304: DEC
21305: ST_TO_ADDR
21306: LD_VAR 0 6
21310: PUSH
21311: LD_INT 1
21313: ARRAY
21314: PUSH
21315: FOR_TO
21316: IFFALSE 21364
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
21318: LD_INT 0
21320: PPUSH
21321: LD_VAR 0 6
21325: PUSH
21326: LD_INT 2
21328: ARRAY
21329: PPUSH
21330: LD_VAR 0 6
21334: PUSH
21335: LD_INT 3
21337: ARRAY
21338: PPUSH
21339: CALL_OW 380
// a := a ^ [ CreateHuman ] ;
21343: LD_ADDR_VAR 0 8
21347: PUSH
21348: LD_VAR 0 8
21352: PUSH
21353: CALL_OW 44
21357: PUSH
21358: EMPTY
21359: LIST
21360: ADD
21361: ST_TO_ADDR
// end ;
21362: GO 21315
21364: POP
21365: POP
// end ;
21366: GO 21293
21368: POP
21369: POP
// for i in a do
21370: LD_ADDR_VAR 0 6
21374: PUSH
21375: LD_VAR 0 8
21379: PUSH
21380: FOR_IN
21381: IFFALSE 21402
// PlaceUnitArea ( i , area , false ) ;
21383: LD_VAR 0 6
21387: PPUSH
21388: LD_VAR 0 2
21392: PPUSH
21393: LD_INT 0
21395: PPUSH
21396: CALL_OW 49
21400: GO 21380
21402: POP
21403: POP
// result := a ;
21404: LD_ADDR_VAR 0 5
21408: PUSH
21409: LD_VAR 0 8
21413: ST_TO_ADDR
// end ;
21414: LD_VAR 0 5
21418: RET
// every 0 0$10 + 0 0$0.0 do var i , j , weap , k ;
21419: GO 21421
21421: DISABLE
21422: LD_INT 0
21424: PPUSH
21425: PPUSH
21426: PPUSH
21427: PPUSH
// begin for i in UnitFilter ( fort , [ mf_bunk ] ) do
21428: LD_ADDR_VAR 0 1
21432: PUSH
21433: LD_EXP 81
21437: PPUSH
21438: LD_EXP 57
21442: PUSH
21443: EMPTY
21444: LIST
21445: PPUSH
21446: CALL_OW 72
21450: PUSH
21451: FOR_IN
21452: IFFALSE 21622
// if not GetBWeapon ( i ) then
21454: LD_VAR 0 1
21458: PPUSH
21459: CALL_OW 269
21463: NOT
21464: IFFALSE 21620
// begin weap := 0 ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_INT 0
21473: ST_TO_ADDR
// for k := 1 to 5 do
21474: LD_ADDR_VAR 0 4
21478: PUSH
21479: DOUBLE
21480: LD_INT 1
21482: DEC
21483: ST_TO_ADDR
21484: LD_INT 5
21486: PUSH
21487: FOR_TO
21488: IFFALSE 21598
// for j in builds [ k ] do
21490: LD_ADDR_VAR 0 2
21494: PUSH
21495: LD_LOC 23
21499: PUSH
21500: LD_VAR 0 4
21504: ARRAY
21505: PUSH
21506: FOR_IN
21507: IFFALSE 21594
// if GetX ( i ) = j [ 2 ] and GetY ( i ) = j [ 3 ] and GetBType ( i ) = j [ 1 ] then
21509: LD_VAR 0 1
21513: PPUSH
21514: CALL_OW 250
21518: PUSH
21519: LD_VAR 0 2
21523: PUSH
21524: LD_INT 2
21526: ARRAY
21527: EQUAL
21528: PUSH
21529: LD_VAR 0 1
21533: PPUSH
21534: CALL_OW 251
21538: PUSH
21539: LD_VAR 0 2
21543: PUSH
21544: LD_INT 3
21546: ARRAY
21547: EQUAL
21548: AND
21549: PUSH
21550: LD_VAR 0 1
21554: PPUSH
21555: CALL_OW 266
21559: PUSH
21560: LD_VAR 0 2
21564: PUSH
21565: LD_INT 1
21567: ARRAY
21568: EQUAL
21569: AND
21570: IFFALSE 21592
// begin weap := j [ 5 ] [ 1 ] ;
21572: LD_ADDR_VAR 0 3
21576: PUSH
21577: LD_VAR 0 2
21581: PUSH
21582: LD_INT 5
21584: ARRAY
21585: PUSH
21586: LD_INT 1
21588: ARRAY
21589: ST_TO_ADDR
// break ;
21590: GO 21594
// end ;
21592: GO 21506
21594: POP
21595: POP
21596: GO 21487
21598: POP
21599: POP
// if weap then
21600: LD_VAR 0 3
21604: IFFALSE 21620
// ComPlaceWeapon ( j , weap ) ;
21606: LD_VAR 0 2
21610: PPUSH
21611: LD_VAR 0 3
21615: PPUSH
21616: CALL_OW 148
// end ;
21620: GO 21451
21622: POP
21623: POP
// enable ;
21624: ENABLE
// end ;
21625: PPOPN 4
21627: END
// every 0 0$10 + 0 0$2.0 do var i , to_up , to_b , co_tam_stoji , k , je_cas_stavet ;
21628: GO 21630
21630: DISABLE
21631: LD_INT 0
21633: PPUSH
21634: PPUSH
21635: PPUSH
21636: PPUSH
21637: PPUSH
21638: PPUSH
// begin for k := 1 to 5 do
21639: LD_ADDR_VAR 0 5
21643: PUSH
21644: DOUBLE
21645: LD_INT 1
21647: DEC
21648: ST_TO_ADDR
21649: LD_INT 5
21651: PUSH
21652: FOR_TO
21653: IFFALSE 22081
// begin if not under_attack [ k ] then
21655: LD_EXP 62
21659: PUSH
21660: LD_VAR 0 5
21664: ARRAY
21665: NOT
21666: IFFALSE 22079
// begin to_b := [ ] ;
21668: LD_ADDR_VAR 0 3
21672: PUSH
21673: EMPTY
21674: ST_TO_ADDR
// to_up := [ ] ;
21675: LD_ADDR_VAR 0 2
21679: PUSH
21680: EMPTY
21681: ST_TO_ADDR
// je_cas_stavet := false ;
21682: LD_ADDR_VAR 0 6
21686: PUSH
21687: LD_INT 0
21689: ST_TO_ADDR
// for i in builds [ k ] do
21690: LD_ADDR_VAR 0 1
21694: PUSH
21695: LD_LOC 23
21699: PUSH
21700: LD_VAR 0 5
21704: ARRAY
21705: PUSH
21706: FOR_IN
21707: IFFALSE 21908
// begin je_cas_stavet := true ;
21709: LD_ADDR_VAR 0 6
21713: PUSH
21714: LD_INT 1
21716: ST_TO_ADDR
// if i = 6 then
21717: LD_VAR 0 1
21721: PUSH
21722: LD_INT 6
21724: EQUAL
21725: IFFALSE 21751
// if i [ 6 ] < tick then
21727: LD_VAR 0 1
21731: PUSH
21732: LD_INT 6
21734: ARRAY
21735: PUSH
21736: LD_OWVAR 1
21740: LESS
21741: IFFALSE 21751
// je_cas_stavet := false ;
21743: LD_ADDR_VAR 0 6
21747: PUSH
21748: LD_INT 0
21750: ST_TO_ADDR
// if je_cas_stavet then
21751: LD_VAR 0 6
21755: IFFALSE 21906
// begin co_tam_stoji := GetBType ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
21757: LD_ADDR_VAR 0 4
21761: PUSH
21762: LD_VAR 0 1
21766: PUSH
21767: LD_INT 2
21769: ARRAY
21770: PPUSH
21771: LD_VAR 0 1
21775: PUSH
21776: LD_INT 3
21778: ARRAY
21779: PPUSH
21780: LD_INT 0
21782: PPUSH
21783: CALL 22087 0 3
21787: PPUSH
21788: CALL_OW 266
21792: ST_TO_ADDR
// if co_tam_stoji = - 1 then
21793: LD_VAR 0 4
21797: PUSH
21798: LD_INT 1
21800: NEG
21801: EQUAL
21802: IFFALSE 21868
// begin to_b := [ BasicFrom ( i [ 1 ] ) , i [ 2 ] , i [ 3 ] , i [ 4 ] , i [ 5 ] ] ;
21804: LD_ADDR_VAR 0 3
21808: PUSH
21809: LD_VAR 0 1
21813: PUSH
21814: LD_INT 1
21816: ARRAY
21817: PPUSH
21818: CALL 20285 0 1
21822: PUSH
21823: LD_VAR 0 1
21827: PUSH
21828: LD_INT 2
21830: ARRAY
21831: PUSH
21832: LD_VAR 0 1
21836: PUSH
21837: LD_INT 3
21839: ARRAY
21840: PUSH
21841: LD_VAR 0 1
21845: PUSH
21846: LD_INT 4
21848: ARRAY
21849: PUSH
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 5
21857: ARRAY
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: LIST
21863: LIST
21864: LIST
21865: ST_TO_ADDR
// end else
21866: GO 21898
// if UpgradeableTo ( co_tam_stoji , i [ 1 ] ) then
21868: LD_VAR 0 4
21872: PPUSH
21873: LD_VAR 0 1
21877: PUSH
21878: LD_INT 1
21880: ARRAY
21881: PPUSH
21882: CALL 20021 0 2
21886: IFFALSE 21898
// begin to_up := i ;
21888: LD_ADDR_VAR 0 2
21892: PUSH
21893: LD_VAR 0 1
21897: ST_TO_ADDR
// end ; if to_b then
21898: LD_VAR 0 3
21902: IFFALSE 21906
// break ;
21904: GO 21908
// end ; end ;
21906: GO 21706
21908: POP
21909: POP
// if to_b then
21910: LD_VAR 0 3
21914: IFFALSE 22036
// ComBuild ( NearestUnitToXY ( UnitFilter ( eng isect humans [ k ] , [ [ f_distxy , to_b [ 2 ] , to_b [ 3 ] , 40 ] ] ) , to_b [ 2 ] , to_b [ 3 ] ) , to_b [ 1 ] , to_b [ 2 ] , to_b [ 3 ] , to_b [ 4 ] ) else
21916: LD_EXP 84
21920: PUSH
21921: LD_EXP 76
21925: PUSH
21926: LD_VAR 0 5
21930: ARRAY
21931: ISECT
21932: PPUSH
21933: LD_INT 92
21935: PUSH
21936: LD_VAR 0 3
21940: PUSH
21941: LD_INT 2
21943: ARRAY
21944: PUSH
21945: LD_VAR 0 3
21949: PUSH
21950: LD_INT 3
21952: ARRAY
21953: PUSH
21954: LD_INT 40
21956: PUSH
21957: EMPTY
21958: LIST
21959: LIST
21960: LIST
21961: LIST
21962: PUSH
21963: EMPTY
21964: LIST
21965: PPUSH
21966: CALL_OW 72
21970: PPUSH
21971: LD_VAR 0 3
21975: PUSH
21976: LD_INT 2
21978: ARRAY
21979: PPUSH
21980: LD_VAR 0 3
21984: PUSH
21985: LD_INT 3
21987: ARRAY
21988: PPUSH
21989: CALL_OW 73
21993: PPUSH
21994: LD_VAR 0 3
21998: PUSH
21999: LD_INT 1
22001: ARRAY
22002: PPUSH
22003: LD_VAR 0 3
22007: PUSH
22008: LD_INT 2
22010: ARRAY
22011: PPUSH
22012: LD_VAR 0 3
22016: PUSH
22017: LD_INT 3
22019: ARRAY
22020: PPUSH
22021: LD_VAR 0 3
22025: PUSH
22026: LD_INT 4
22028: ARRAY
22029: PPUSH
22030: CALL_OW 145
22034: GO 22072
// if to_up then
22036: LD_VAR 0 2
22040: IFFALSE 22072
// ComUpgrade ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
22042: LD_VAR 0 1
22046: PUSH
22047: LD_INT 2
22049: ARRAY
22050: PPUSH
22051: LD_VAR 0 1
22055: PUSH
22056: LD_INT 3
22058: ARRAY
22059: PPUSH
22060: LD_INT 0
22062: PPUSH
22063: CALL 22087 0 3
22067: PPUSH
22068: CALL_OW 146
// wait ( 0 0$1.1 ) ;
22072: LD_INT 39
22074: PPUSH
22075: CALL_OW 67
// end ; end ;
22079: GO 21652
22081: POP
22082: POP
// enable ;
22083: ENABLE
// end ;
22084: PPOPN 6
22086: END
// function get_build ( x , y , btype ) ; begin
22087: LD_INT 0
22089: PPUSH
// result := HexInfo ( x , y ) ;
22090: LD_ADDR_VAR 0 4
22094: PUSH
22095: LD_VAR 0 1
22099: PPUSH
22100: LD_VAR 0 2
22104: PPUSH
22105: CALL_OW 428
22109: ST_TO_ADDR
// if result < 1 then
22110: LD_VAR 0 4
22114: PUSH
22115: LD_INT 1
22117: LESS
22118: IFFALSE 22128
// result := 0 ;
22120: LD_ADDR_VAR 0 4
22124: PUSH
22125: LD_INT 0
22127: ST_TO_ADDR
// if btype then
22128: LD_VAR 0 3
22132: IFFALSE 22184
// if btype <> GetBType ( result ) then
22134: LD_VAR 0 3
22138: PUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: CALL_OW 266
22148: NONEQUAL
22149: IFFALSE 22161
// result := 0 else
22151: LD_ADDR_VAR 0 4
22155: PUSH
22156: LD_INT 0
22158: ST_TO_ADDR
22159: GO 22184
// if unit_building <> GetType ( result ) then
22161: LD_INT 3
22163: PUSH
22164: LD_VAR 0 4
22168: PPUSH
22169: CALL_OW 247
22173: NONEQUAL
22174: IFFALSE 22184
// result := 0 ;
22176: LD_ADDR_VAR 0 4
22180: PUSH
22181: LD_INT 0
22183: ST_TO_ADDR
// end ; end_of_file
22184: LD_VAR 0 4
22188: RET
// var opravit ; export function inicializace_ai_b_repair ; begin
22189: LD_INT 0
22191: PPUSH
// opravit := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22192: LD_ADDR_LOC 29
22196: PUSH
22197: EMPTY
22198: PUSH
22199: EMPTY
22200: PUSH
22201: EMPTY
22202: PUSH
22203: EMPTY
22204: PUSH
22205: EMPTY
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: ST_TO_ADDR
// end ;
22214: LD_VAR 0 1
22218: RET
// function HledejBudovyNaOpravy ( opravit_index , budovy ) ; var zivoty , i , opravit_tmp ; begin
22219: LD_INT 0
22221: PPUSH
22222: PPUSH
22223: PPUSH
22224: PPUSH
// opravit_tmp := [ ] ;
22225: LD_ADDR_VAR 0 6
22229: PUSH
22230: EMPTY
22231: ST_TO_ADDR
// zivoty := [ ] ;
22232: LD_ADDR_VAR 0 4
22236: PUSH
22237: EMPTY
22238: ST_TO_ADDR
// for i in budovy do
22239: LD_ADDR_VAR 0 5
22243: PUSH
22244: LD_VAR 0 2
22248: PUSH
22249: FOR_IN
22250: IFFALSE 22312
// begin if GetLives ( i ) < 1000 then
22252: LD_VAR 0 5
22256: PPUSH
22257: CALL_OW 256
22261: PUSH
22262: LD_INT 1000
22264: LESS
22265: IFFALSE 22310
// begin opravit_tmp := opravit_tmp ^ [ i ] ;
22267: LD_ADDR_VAR 0 6
22271: PUSH
22272: LD_VAR 0 6
22276: PUSH
22277: LD_VAR 0 5
22281: PUSH
22282: EMPTY
22283: LIST
22284: ADD
22285: ST_TO_ADDR
// zivoty := zivoty ^ [ GetLives ( i ) ] ;
22286: LD_ADDR_VAR 0 4
22290: PUSH
22291: LD_VAR 0 4
22295: PUSH
22296: LD_VAR 0 5
22300: PPUSH
22301: CALL_OW 256
22305: PUSH
22306: EMPTY
22307: LIST
22308: ADD
22309: ST_TO_ADDR
// end ; end ;
22310: GO 22249
22312: POP
22313: POP
// if opravit_tmp then
22314: LD_VAR 0 6
22318: IFFALSE 22340
// opravit_tmp := SortListByListAsc ( opravit_tmp , zivoty ) ;
22320: LD_ADDR_VAR 0 6
22324: PUSH
22325: LD_VAR 0 6
22329: PPUSH
22330: LD_VAR 0 4
22334: PPUSH
22335: CALL_OW 76
22339: ST_TO_ADDR
// opravit := Replace ( opravit , opravit_index , opravit_tmp ) ;
22340: LD_ADDR_LOC 29
22344: PUSH
22345: LD_LOC 29
22349: PPUSH
22350: LD_VAR 0 1
22354: PPUSH
22355: LD_VAR 0 6
22359: PPUSH
22360: CALL_OW 1
22364: ST_TO_ADDR
// end ;
22365: LD_VAR 0 3
22369: RET
// every 0 0$5 do var i ;
22370: GO 22372
22372: DISABLE
22373: LD_INT 0
22375: PPUSH
// begin for i := 1 to 5 do
22376: LD_ADDR_VAR 0 1
22380: PUSH
22381: DOUBLE
22382: LD_INT 1
22384: DEC
22385: ST_TO_ADDR
22386: LD_INT 5
22388: PUSH
22389: FOR_TO
22390: IFFALSE 22434
// begin if not under_attack [ i ] then
22392: LD_EXP 62
22396: PUSH
22397: LD_VAR 0 1
22401: ARRAY
22402: NOT
22403: IFFALSE 22432
// begin HledejBudovyNaOpravy ( i , buildings [ i ] ) ;
22405: LD_VAR 0 1
22409: PPUSH
22410: LD_EXP 75
22414: PUSH
22415: LD_VAR 0 1
22419: ARRAY
22420: PPUSH
22421: CALL 22219 0 2
// wait ( 0 0$0.6 ) ;
22425: LD_INT 21
22427: PPUSH
22428: CALL_OW 67
// end ; end ;
22432: GO 22389
22434: POP
22435: POP
// enable ;
22436: ENABLE
// end ;
22437: PPOPN 1
22439: END
// every 0 0$5 do var i ;
22440: GO 22442
22442: DISABLE
22443: LD_INT 0
22445: PPUSH
// begin for i := 1 to 5 do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: DOUBLE
22452: LD_INT 1
22454: DEC
22455: ST_TO_ADDR
22456: LD_INT 5
22458: PUSH
22459: FOR_TO
22460: IFFALSE 22609
// begin if opravit [ i ] then
22462: LD_LOC 29
22466: PUSH
22467: LD_VAR 0 1
22471: ARRAY
22472: IFFALSE 22607
// begin ComRepairBuilding ( UnitFilter ( eng , [ [ f_not , [ f_hastask ] ] , [ f_side , GetSide ( opravit [ i ] [ 1 ] ) ] , [ f_dist , opravit [ i ] [ 1 ] , ( ( ( 1000 div 30 ) + 5 ) - GetLives ( opravit [ i ] [ 1 ] ) div 30 ) ] ] ) , opravit [ i ] [ 1 ] ) ;
22474: LD_EXP 84
22478: PPUSH
22479: LD_INT 3
22481: PUSH
22482: LD_INT 60
22484: PUSH
22485: EMPTY
22486: LIST
22487: PUSH
22488: EMPTY
22489: LIST
22490: LIST
22491: PUSH
22492: LD_INT 22
22494: PUSH
22495: LD_LOC 29
22499: PUSH
22500: LD_VAR 0 1
22504: ARRAY
22505: PUSH
22506: LD_INT 1
22508: ARRAY
22509: PPUSH
22510: CALL_OW 255
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 91
22521: PUSH
22522: LD_LOC 29
22526: PUSH
22527: LD_VAR 0 1
22531: ARRAY
22532: PUSH
22533: LD_INT 1
22535: ARRAY
22536: PUSH
22537: LD_INT 1000
22539: PUSH
22540: LD_INT 30
22542: DIV
22543: PUSH
22544: LD_INT 5
22546: PLUS
22547: PUSH
22548: LD_LOC 29
22552: PUSH
22553: LD_VAR 0 1
22557: ARRAY
22558: PUSH
22559: LD_INT 1
22561: ARRAY
22562: PPUSH
22563: CALL_OW 256
22567: PUSH
22568: LD_INT 30
22570: DIV
22571: MINUS
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: LIST
22577: PUSH
22578: EMPTY
22579: LIST
22580: LIST
22581: LIST
22582: PPUSH
22583: CALL_OW 72
22587: PPUSH
22588: LD_LOC 29
22592: PUSH
22593: LD_VAR 0 1
22597: ARRAY
22598: PUSH
22599: LD_INT 1
22601: ARRAY
22602: PPUSH
22603: CALL_OW 130
// end ; end ;
22607: GO 22459
22609: POP
22610: POP
// enable ;
22611: ENABLE
// end ; end_of_file
22612: PPOPN 1
22614: END
// export factories ; export depots ; export buildings ; export humans ; export vehicles ; export attack_units ; export defence_units ; export mcdef_units ; export fort , sol , dep , eng , fact , mec , lab , sci ; export function inicializace_ai ; begin
22615: LD_INT 0
22617: PPUSH
// factories := [ 0 , 0 , 0 , 0 , 0 ] ;
22618: LD_ADDR_EXP 73
22622: PUSH
22623: LD_INT 0
22625: PUSH
22626: LD_INT 0
22628: PUSH
22629: LD_INT 0
22631: PUSH
22632: LD_INT 0
22634: PUSH
22635: LD_INT 0
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: LIST
22642: LIST
22643: LIST
22644: ST_TO_ADDR
// depots := [ 0 , 0 , 0 , 0 , 0 ] ;
22645: LD_ADDR_EXP 74
22649: PUSH
22650: LD_INT 0
22652: PUSH
22653: LD_INT 0
22655: PUSH
22656: LD_INT 0
22658: PUSH
22659: LD_INT 0
22661: PUSH
22662: LD_INT 0
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: ST_TO_ADDR
// buildings := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22672: LD_ADDR_EXP 75
22676: PUSH
22677: EMPTY
22678: PUSH
22679: EMPTY
22680: PUSH
22681: EMPTY
22682: PUSH
22683: EMPTY
22684: PUSH
22685: EMPTY
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: LIST
22691: LIST
22692: LIST
22693: ST_TO_ADDR
// humans := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22694: LD_ADDR_EXP 76
22698: PUSH
22699: EMPTY
22700: PUSH
22701: EMPTY
22702: PUSH
22703: EMPTY
22704: PUSH
22705: EMPTY
22706: PUSH
22707: EMPTY
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// vehicles := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22716: LD_ADDR_EXP 77
22720: PUSH
22721: EMPTY
22722: PUSH
22723: EMPTY
22724: PUSH
22725: EMPTY
22726: PUSH
22727: EMPTY
22728: PUSH
22729: EMPTY
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: LIST
22735: LIST
22736: LIST
22737: ST_TO_ADDR
// attack_units := [ ] ;
22738: LD_ADDR_EXP 78
22742: PUSH
22743: EMPTY
22744: ST_TO_ADDR
// defence_units := [ ] ;
22745: LD_ADDR_EXP 79
22749: PUSH
22750: EMPTY
22751: ST_TO_ADDR
// end ;
22752: LD_VAR 0 1
22756: RET
// export function get_groups ; var i ; begin
22757: LD_INT 0
22759: PPUSH
22760: PPUSH
// fort := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fort ] ) ;
22761: LD_ADDR_EXP 81
22765: PUSH
22766: LD_INT 3
22768: PUSH
22769: LD_INT 22
22771: PUSH
22772: LD_EXP 7
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: EMPTY
22782: LIST
22783: LIST
22784: PUSH
22785: LD_EXP 56
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: PPUSH
22794: CALL_OW 69
22798: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sol ] ) diff hlavouni ;
22799: LD_ADDR_EXP 82
22803: PUSH
22804: LD_INT 3
22806: PUSH
22807: LD_INT 22
22809: PUSH
22810: LD_EXP 7
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: PUSH
22823: LD_EXP 51
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: PPUSH
22832: CALL_OW 69
22836: PUSH
22837: LD_EXP 72
22841: DIFF
22842: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_dep ] ) ;
22843: LD_ADDR_EXP 83
22847: PUSH
22848: LD_INT 3
22850: PUSH
22851: LD_INT 22
22853: PUSH
22854: LD_EXP 7
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: LD_EXP 58
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: PPUSH
22876: CALL_OW 69
22880: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_eng ] ) diff hlavouni ;
22881: LD_ADDR_EXP 84
22885: PUSH
22886: LD_INT 3
22888: PUSH
22889: LD_INT 22
22891: PUSH
22892: LD_EXP 7
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: PUSH
22905: LD_EXP 52
22909: PUSH
22910: EMPTY
22911: LIST
22912: LIST
22913: PPUSH
22914: CALL_OW 69
22918: PUSH
22919: LD_EXP 72
22923: DIFF
22924: ST_TO_ADDR
// fact := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fact ] ) ;
22925: LD_ADDR_EXP 85
22929: PUSH
22930: LD_INT 3
22932: PUSH
22933: LD_INT 22
22935: PUSH
22936: LD_EXP 7
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: PUSH
22945: EMPTY
22946: LIST
22947: LIST
22948: PUSH
22949: LD_EXP 59
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PPUSH
22958: CALL_OW 69
22962: ST_TO_ADDR
// mec := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_mec ] ) diff hlavouni ;
22963: LD_ADDR_EXP 86
22967: PUSH
22968: LD_INT 3
22970: PUSH
22971: LD_INT 22
22973: PUSH
22974: LD_EXP 7
22978: PUSH
22979: EMPTY
22980: LIST
22981: LIST
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: PUSH
22987: LD_EXP 53
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: PPUSH
22996: CALL_OW 69
23000: PUSH
23001: LD_EXP 72
23005: DIFF
23006: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_lab ] ) ;
23007: LD_ADDR_EXP 87
23011: PUSH
23012: LD_INT 3
23014: PUSH
23015: LD_INT 22
23017: PUSH
23018: LD_EXP 7
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: PUSH
23031: LD_EXP 55
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PPUSH
23040: CALL_OW 69
23044: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sci ] ) diff hlavouni ;
23045: LD_ADDR_EXP 88
23049: PUSH
23050: LD_INT 3
23052: PUSH
23053: LD_INT 22
23055: PUSH
23056: LD_EXP 7
23060: PUSH
23061: EMPTY
23062: LIST
23063: LIST
23064: PUSH
23065: EMPTY
23066: LIST
23067: LIST
23068: PUSH
23069: LD_EXP 54
23073: PUSH
23074: EMPTY
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 69
23082: PUSH
23083: LD_EXP 72
23087: DIFF
23088: ST_TO_ADDR
// for i := 1 to 5 do
23089: LD_ADDR_VAR 0 2
23093: PUSH
23094: DOUBLE
23095: LD_INT 1
23097: DEC
23098: ST_TO_ADDR
23099: LD_INT 5
23101: PUSH
23102: FOR_TO
23103: IFFALSE 23288
// begin humans := replace ( humans , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_human ] ] ) diff hlavouni ) ;
23105: LD_ADDR_EXP 76
23109: PUSH
23110: LD_EXP 76
23114: PPUSH
23115: LD_VAR 0 2
23119: PPUSH
23120: LD_INT 22
23122: PUSH
23123: LD_EXP 23
23127: PUSH
23128: LD_VAR 0 2
23132: ARRAY
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: PUSH
23138: LD_INT 21
23140: PUSH
23141: LD_INT 1
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PPUSH
23152: CALL_OW 69
23156: PUSH
23157: LD_EXP 72
23161: DIFF
23162: PPUSH
23163: CALL_OW 1
23167: ST_TO_ADDR
// vehicles := replace ( vehicles , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_vehicle ] ] ) diff art_cargo ) ;
23168: LD_ADDR_EXP 77
23172: PUSH
23173: LD_EXP 77
23177: PPUSH
23178: LD_VAR 0 2
23182: PPUSH
23183: LD_INT 22
23185: PUSH
23186: LD_EXP 23
23190: PUSH
23191: LD_VAR 0 2
23195: ARRAY
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: PUSH
23201: LD_INT 21
23203: PUSH
23204: LD_INT 2
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: PPUSH
23215: CALL_OW 69
23219: PUSH
23220: LD_INT 121
23222: DIFF
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// buildings := replace ( buildings , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_building ] ] ) ) ;
23229: LD_ADDR_EXP 75
23233: PUSH
23234: LD_EXP 75
23238: PPUSH
23239: LD_VAR 0 2
23243: PPUSH
23244: LD_INT 22
23246: PUSH
23247: LD_EXP 23
23251: PUSH
23252: LD_VAR 0 2
23256: ARRAY
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PUSH
23262: LD_INT 21
23264: PUSH
23265: LD_INT 3
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: PPUSH
23276: CALL_OW 69
23280: PPUSH
23281: CALL_OW 1
23285: ST_TO_ADDR
// end ;
23286: GO 23102
23288: POP
23289: POP
// attack_units := FilterAllUnits ( [ [ f_control , control_computer ] ] ) ;
23290: LD_ADDR_EXP 78
23294: PUSH
23295: LD_INT 33
23297: PUSH
23298: LD_INT 3
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PUSH
23305: EMPTY
23306: LIST
23307: PPUSH
23308: CALL_OW 69
23312: ST_TO_ADDR
// defence_units := FilterAllUnits ( [ [ f_control , control_manual ] ] ) diff art_cargo ;
23313: LD_ADDR_EXP 79
23317: PUSH
23318: LD_INT 33
23320: PUSH
23321: LD_INT 1
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: EMPTY
23329: LIST
23330: PPUSH
23331: CALL_OW 69
23335: PUSH
23336: LD_INT 121
23338: DIFF
23339: ST_TO_ADDR
// write_deps ;
23340: CALL 23353 0 0
// write_facts ;
23344: CALL 23472 0 0
// end ;
23348: LD_VAR 0 1
23352: RET
// export function write_deps ; var i , a ; begin
23353: LD_INT 0
23355: PPUSH
23356: PPUSH
23357: PPUSH
// for i := 1 to 5 do
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: DOUBLE
23364: LD_INT 1
23366: DEC
23367: ST_TO_ADDR
23368: LD_INT 5
23370: PUSH
23371: FOR_TO
23372: IFFALSE 23465
// begin a := UnitFilter ( buildings [ i ] , [ mf_dep ] ) ;
23374: LD_ADDR_VAR 0 3
23378: PUSH
23379: LD_EXP 75
23383: PUSH
23384: LD_VAR 0 2
23388: ARRAY
23389: PPUSH
23390: LD_EXP 58
23394: PUSH
23395: EMPTY
23396: LIST
23397: PPUSH
23398: CALL_OW 72
23402: ST_TO_ADDR
// if a then
23403: LD_VAR 0 3
23407: IFFALSE 23440
// depots := replace ( depots , i , a [ 1 ] ) else
23409: LD_ADDR_EXP 74
23413: PUSH
23414: LD_EXP 74
23418: PPUSH
23419: LD_VAR 0 2
23423: PPUSH
23424: LD_VAR 0 3
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
23438: GO 23463
// depots := replace ( depots , i , 0 ) ;
23440: LD_ADDR_EXP 74
23444: PUSH
23445: LD_EXP 74
23449: PPUSH
23450: LD_VAR 0 2
23454: PPUSH
23455: LD_INT 0
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// end ;
23463: GO 23371
23465: POP
23466: POP
// end ;
23467: LD_VAR 0 1
23471: RET
// export function write_facts ; var i , a ; begin
23472: LD_INT 0
23474: PPUSH
23475: PPUSH
23476: PPUSH
// for i := 1 to 5 do
23477: LD_ADDR_VAR 0 2
23481: PUSH
23482: DOUBLE
23483: LD_INT 1
23485: DEC
23486: ST_TO_ADDR
23487: LD_INT 5
23489: PUSH
23490: FOR_TO
23491: IFFALSE 23584
// begin a := UnitFilter ( buildings [ i ] , [ mf_fact ] ) ;
23493: LD_ADDR_VAR 0 3
23497: PUSH
23498: LD_EXP 75
23502: PUSH
23503: LD_VAR 0 2
23507: ARRAY
23508: PPUSH
23509: LD_EXP 59
23513: PUSH
23514: EMPTY
23515: LIST
23516: PPUSH
23517: CALL_OW 72
23521: ST_TO_ADDR
// if a then
23522: LD_VAR 0 3
23526: IFFALSE 23559
// factories := replace ( factories , i , a [ 1 ] ) else
23528: LD_ADDR_EXP 73
23532: PUSH
23533: LD_EXP 73
23537: PPUSH
23538: LD_VAR 0 2
23542: PPUSH
23543: LD_VAR 0 3
23547: PUSH
23548: LD_INT 1
23550: ARRAY
23551: PPUSH
23552: CALL_OW 1
23556: ST_TO_ADDR
23557: GO 23582
// factories := replace ( factories , i , 0 ) ;
23559: LD_ADDR_EXP 73
23563: PUSH
23564: LD_EXP 73
23568: PPUSH
23569: LD_VAR 0 2
23573: PPUSH
23574: LD_INT 0
23576: PPUSH
23577: CALL_OW 1
23581: ST_TO_ADDR
// end ;
23582: GO 23490
23584: POP
23585: POP
// end ;
23586: LD_VAR 0 1
23590: RET
// every 0 0$6 + 0 0$0.9 do var i , j , blds , hums , cars ;
23591: GO 23593
23593: DISABLE
23594: LD_INT 0
23596: PPUSH
23597: PPUSH
23598: PPUSH
23599: PPUSH
23600: PPUSH
// begin hums := [ ] ;
23601: LD_ADDR_VAR 0 4
23605: PUSH
23606: EMPTY
23607: ST_TO_ADDR
// for i in sol do
23608: LD_ADDR_VAR 0 1
23612: PUSH
23613: LD_EXP 82
23617: PUSH
23618: FOR_IN
23619: IFFALSE 23695
// if ( not HasTask ( i ) and not ( GetBType ( IsInUnit ( i ) ) = b_bunker or GetBType ( IsInUnit ( i ) ) = b_breastwork ) ) then
23621: LD_VAR 0 1
23625: PPUSH
23626: CALL_OW 314
23630: NOT
23631: PUSH
23632: LD_VAR 0 1
23636: PPUSH
23637: CALL_OW 310
23641: PPUSH
23642: CALL_OW 266
23646: PUSH
23647: LD_INT 32
23649: EQUAL
23650: PUSH
23651: LD_VAR 0 1
23655: PPUSH
23656: CALL_OW 310
23660: PPUSH
23661: CALL_OW 266
23665: PUSH
23666: LD_INT 31
23668: EQUAL
23669: OR
23670: NOT
23671: AND
23672: IFFALSE 23693
// hums := hums ^ [ i ] ;
23674: LD_ADDR_VAR 0 4
23678: PUSH
23679: LD_VAR 0 4
23683: PUSH
23684: LD_VAR 0 1
23688: PUSH
23689: EMPTY
23690: LIST
23691: ADD
23692: ST_TO_ADDR
23693: GO 23618
23695: POP
23696: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ mf_bunk ] ] ) ;
23697: LD_ADDR_VAR 0 3
23701: PUSH
23702: LD_EXP 81
23706: PPUSH
23707: LD_INT 3
23709: PUSH
23710: LD_INT 59
23712: PUSH
23713: EMPTY
23714: LIST
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: PUSH
23720: LD_EXP 57
23724: PUSH
23725: EMPTY
23726: LIST
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PPUSH
23732: CALL_OW 72
23736: ST_TO_ADDR
// for i in blds do
23737: LD_ADDR_VAR 0 1
23741: PUSH
23742: LD_VAR 0 3
23746: PUSH
23747: FOR_IN
23748: IFFALSE 23853
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 40 ] ] ) , i ) ;
23750: LD_ADDR_VAR 0 2
23754: PUSH
23755: LD_VAR 0 4
23759: PPUSH
23760: LD_INT 22
23762: PUSH
23763: LD_VAR 0 1
23767: PPUSH
23768: CALL_OW 255
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: PUSH
23777: LD_INT 91
23779: PUSH
23780: LD_VAR 0 1
23784: PUSH
23785: LD_INT 40
23787: PUSH
23788: EMPTY
23789: LIST
23790: LIST
23791: LIST
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PPUSH
23797: CALL_OW 72
23801: PPUSH
23802: LD_VAR 0 1
23806: PPUSH
23807: CALL_OW 74
23811: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23812: LD_VAR 0 2
23816: PPUSH
23817: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23821: LD_VAR 0 2
23825: PPUSH
23826: LD_VAR 0 1
23830: PPUSH
23831: CALL_OW 180
// hums := hums diff j ;
23835: LD_ADDR_VAR 0 4
23839: PUSH
23840: LD_VAR 0 4
23844: PUSH
23845: LD_VAR 0 2
23849: DIFF
23850: ST_TO_ADDR
// end ;
23851: GO 23747
23853: POP
23854: POP
// cars := UnitFilter ( defence_units , [ f_not , [ f_occupied ] ] ) ;
23855: LD_ADDR_VAR 0 5
23859: PUSH
23860: LD_EXP 79
23864: PPUSH
23865: LD_INT 3
23867: PUSH
23868: LD_INT 59
23870: PUSH
23871: EMPTY
23872: LIST
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: PPUSH
23878: CALL_OW 72
23882: ST_TO_ADDR
// for i in cars do
23883: LD_ADDR_VAR 0 1
23887: PUSH
23888: LD_VAR 0 5
23892: PUSH
23893: FOR_IN
23894: IFFALSE 23999
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
23896: LD_ADDR_VAR 0 2
23900: PUSH
23901: LD_VAR 0 4
23905: PPUSH
23906: LD_INT 22
23908: PUSH
23909: LD_VAR 0 1
23913: PPUSH
23914: CALL_OW 255
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: LD_INT 91
23925: PUSH
23926: LD_VAR 0 1
23930: PUSH
23931: LD_INT 30
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: LIST
23938: PUSH
23939: EMPTY
23940: LIST
23941: LIST
23942: PPUSH
23943: CALL_OW 72
23947: PPUSH
23948: LD_VAR 0 1
23952: PPUSH
23953: CALL_OW 74
23957: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23958: LD_VAR 0 2
23962: PPUSH
23963: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23967: LD_VAR 0 2
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: CALL_OW 180
// hums := hums diff j ;
23981: LD_ADDR_VAR 0 4
23985: PUSH
23986: LD_VAR 0 4
23990: PUSH
23991: LD_VAR 0 2
23995: DIFF
23996: ST_TO_ADDR
// end ;
23997: GO 23893
23999: POP
24000: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
24001: LD_ADDR_VAR 0 3
24005: PUSH
24006: LD_EXP 81
24010: PPUSH
24011: LD_INT 3
24013: PUSH
24014: LD_INT 59
24016: PUSH
24017: EMPTY
24018: LIST
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: LD_INT 2
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: LD_INT 5
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 30
24039: PUSH
24040: LD_INT 4
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: LIST
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: PPUSH
24056: CALL_OW 72
24060: ST_TO_ADDR
// for i in blds do
24061: LD_ADDR_VAR 0 1
24065: PUSH
24066: LD_VAR 0 3
24070: PUSH
24071: FOR_IN
24072: IFFALSE 24132
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24074: LD_VAR 0 4
24078: PPUSH
24079: LD_INT 22
24081: PUSH
24082: LD_VAR 0 1
24086: PPUSH
24087: CALL_OW 255
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PUSH
24096: LD_INT 91
24098: PUSH
24099: LD_VAR 0 1
24103: PUSH
24104: LD_INT 30
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: LIST
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: PPUSH
24116: CALL_OW 72
24120: PPUSH
24121: LD_VAR 0 1
24125: PPUSH
24126: CALL_OW 120
24130: GO 24071
24132: POP
24133: POP
// enable ;
24134: ENABLE
// end ;
24135: PPOPN 5
24137: END
// every 0 0$2 + 0 0$0.5 do var i , j , blds , hums ;
24138: GO 24140
24140: DISABLE
24141: LD_INT 0
24143: PPUSH
24144: PPUSH
24145: PPUSH
24146: PPUSH
// begin blds := dep ;
24147: LD_ADDR_VAR 0 3
24151: PUSH
24152: LD_EXP 83
24156: ST_TO_ADDR
// hums := [ ] ;
24157: LD_ADDR_VAR 0 4
24161: PUSH
24162: EMPTY
24163: ST_TO_ADDR
// for i in eng do
24164: LD_ADDR_VAR 0 1
24168: PUSH
24169: LD_EXP 84
24173: PUSH
24174: FOR_IN
24175: IFFALSE 24222
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24177: LD_VAR 0 1
24181: PPUSH
24182: CALL_OW 315
24186: NOT
24187: PUSH
24188: LD_VAR 0 1
24192: PPUSH
24193: CALL_OW 310
24197: NOT
24198: AND
24199: IFFALSE 24220
// hums := hums ^ [ i ] ;
24201: LD_ADDR_VAR 0 4
24205: PUSH
24206: LD_VAR 0 4
24210: PUSH
24211: LD_VAR 0 1
24215: PUSH
24216: EMPTY
24217: LIST
24218: ADD
24219: ST_TO_ADDR
24220: GO 24174
24222: POP
24223: POP
// for i in blds do
24224: LD_ADDR_VAR 0 1
24228: PUSH
24229: LD_VAR 0 3
24233: PUSH
24234: FOR_IN
24235: IFFALSE 24295
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , GetSide ( i ) ] , [ f_dist , i , 25 ] ] ) , i ) ;
24237: LD_VAR 0 4
24241: PPUSH
24242: LD_INT 22
24244: PUSH
24245: LD_VAR 0 1
24249: PPUSH
24250: CALL_OW 255
24254: PUSH
24255: EMPTY
24256: LIST
24257: LIST
24258: PUSH
24259: LD_INT 91
24261: PUSH
24262: LD_VAR 0 1
24266: PUSH
24267: LD_INT 25
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PPUSH
24279: CALL_OW 72
24283: PPUSH
24284: LD_VAR 0 1
24288: PPUSH
24289: CALL_OW 120
24293: GO 24234
24295: POP
24296: POP
// enable ;
24297: ENABLE
// end ;
24298: PPOPN 4
24300: END
// every 0 0$2 + 0 0$0.7 do var i , j , blds , hums ;
24301: GO 24303
24303: DISABLE
24304: LD_INT 0
24306: PPUSH
24307: PPUSH
24308: PPUSH
24309: PPUSH
// begin blds := fact ;
24310: LD_ADDR_VAR 0 3
24314: PUSH
24315: LD_EXP 85
24319: ST_TO_ADDR
// hums := [ ] ;
24320: LD_ADDR_VAR 0 4
24324: PUSH
24325: EMPTY
24326: ST_TO_ADDR
// for i in mec do
24327: LD_ADDR_VAR 0 1
24331: PUSH
24332: LD_EXP 86
24336: PUSH
24337: FOR_IN
24338: IFFALSE 24385
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24340: LD_VAR 0 1
24344: PPUSH
24345: CALL_OW 315
24349: NOT
24350: PUSH
24351: LD_VAR 0 1
24355: PPUSH
24356: CALL_OW 310
24360: NOT
24361: AND
24362: IFFALSE 24383
// hums := hums ^ [ i ] ;
24364: LD_ADDR_VAR 0 4
24368: PUSH
24369: LD_VAR 0 4
24373: PUSH
24374: LD_VAR 0 1
24378: PUSH
24379: EMPTY
24380: LIST
24381: ADD
24382: ST_TO_ADDR
24383: GO 24337
24385: POP
24386: POP
// for i in blds do
24387: LD_ADDR_VAR 0 1
24391: PUSH
24392: LD_VAR 0 3
24396: PUSH
24397: FOR_IN
24398: IFFALSE 24458
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24400: LD_VAR 0 4
24404: PPUSH
24405: LD_INT 22
24407: PUSH
24408: LD_VAR 0 1
24412: PPUSH
24413: CALL_OW 255
24417: PUSH
24418: EMPTY
24419: LIST
24420: LIST
24421: PUSH
24422: LD_INT 91
24424: PUSH
24425: LD_VAR 0 1
24429: PUSH
24430: LD_INT 30
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: LIST
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: PPUSH
24442: CALL_OW 72
24446: PPUSH
24447: LD_VAR 0 1
24451: PPUSH
24452: CALL_OW 120
24456: GO 24397
24458: POP
24459: POP
// enable ;
24460: ENABLE
// end ;
24461: PPOPN 4
24463: END
// every 0 0$2 + 0 0$0.9 do var i , j , blds , hums ;
24464: GO 24466
24466: DISABLE
24467: LD_INT 0
24469: PPUSH
24470: PPUSH
24471: PPUSH
24472: PPUSH
// begin blds := lab ;
24473: LD_ADDR_VAR 0 3
24477: PUSH
24478: LD_EXP 87
24482: ST_TO_ADDR
// hums := [ ] ;
24483: LD_ADDR_VAR 0 4
24487: PUSH
24488: EMPTY
24489: ST_TO_ADDR
// for i in sci do
24490: LD_ADDR_VAR 0 1
24494: PUSH
24495: LD_EXP 88
24499: PUSH
24500: FOR_IN
24501: IFFALSE 24548
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24503: LD_VAR 0 1
24507: PPUSH
24508: CALL_OW 315
24512: NOT
24513: PUSH
24514: LD_VAR 0 1
24518: PPUSH
24519: CALL_OW 310
24523: NOT
24524: AND
24525: IFFALSE 24546
// hums := hums ^ [ i ] ;
24527: LD_ADDR_VAR 0 4
24531: PUSH
24532: LD_VAR 0 4
24536: PUSH
24537: LD_VAR 0 1
24541: PUSH
24542: EMPTY
24543: LIST
24544: ADD
24545: ST_TO_ADDR
24546: GO 24500
24548: POP
24549: POP
// for i in blds do
24550: LD_ADDR_VAR 0 1
24554: PUSH
24555: LD_VAR 0 3
24559: PUSH
24560: FOR_IN
24561: IFFALSE 24621
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24563: LD_VAR 0 4
24567: PPUSH
24568: LD_INT 22
24570: PUSH
24571: LD_VAR 0 1
24575: PPUSH
24576: CALL_OW 255
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: PUSH
24585: LD_INT 91
24587: PUSH
24588: LD_VAR 0 1
24592: PUSH
24593: LD_INT 30
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: LIST
24600: PUSH
24601: EMPTY
24602: LIST
24603: LIST
24604: PPUSH
24605: CALL_OW 72
24609: PPUSH
24610: LD_VAR 0 1
24614: PPUSH
24615: CALL_OW 120
24619: GO 24560
24621: POP
24622: POP
// enable ;
24623: ENABLE
// end ; end_of_file
24624: PPOPN 4
24626: END
// on UnitDestroyed ( un ) do var h , hinfo , a ;
24627: LD_INT 0
24629: PPUSH
24630: PPUSH
24631: PPUSH
// begin if un = Burlak then
24632: LD_VAR 0 1
24636: PUSH
24637: LD_EXP 41
24641: EQUAL
24642: IFFALSE 24651
// begin YouLost ( Burlak ) ;
24644: LD_STRING Burlak
24646: PPUSH
24647: CALL_OW 104
// end ; if un = Platonov then
24651: LD_VAR 0 1
24655: PUSH
24656: LD_EXP 42
24660: EQUAL
24661: IFFALSE 24686
// begin SurrenderBase ( t_kill , GetSide ( un ) ) ;
24663: LD_EXP 1
24667: PPUSH
24668: LD_VAR 0 1
24672: PPUSH
24673: CALL_OW 255
24677: PPUSH
24678: CALL 30313 0 2
// VyhraPlaton ;
24682: CALL 358 0 0
// end ; if GetSide ( un ) <> you then
24686: LD_VAR 0 1
24690: PPUSH
24691: CALL_OW 255
24695: PUSH
24696: LD_EXP 7
24700: NONEQUAL
24701: IFFALSE 24730
// begin remove_from_vehicles ( un ) ;
24703: LD_VAR 0 1
24707: PPUSH
24708: CALL 28219 0 1
// remove_from_humans ( un ) ;
24712: LD_VAR 0 1
24716: PPUSH
24717: CALL 27981 0 1
// remove_from_builds ( un ) ;
24721: LD_VAR 0 1
24725: PPUSH
24726: CALL 27735 0 1
// end ; if not GetSide ( un ) in your_bases then
24730: LD_VAR 0 1
24734: PPUSH
24735: CALL_OW 255
24739: PUSH
24740: LD_EXP 18
24744: IN
24745: NOT
24746: IFFALSE 24868
// begin if un = Borodin then
24748: LD_VAR 0 1
24752: PUSH
24753: LD_EXP 46
24757: EQUAL
24758: IFFALSE 24778
// begin SurrenderBase ( t_kill , ai_s [ 2 ] ) ;
24760: LD_EXP 1
24764: PPUSH
24765: LD_EXP 23
24769: PUSH
24770: LD_INT 2
24772: ARRAY
24773: PPUSH
24774: CALL 30313 0 2
// end ; if un = Tsaritsyn then
24778: LD_VAR 0 1
24782: PUSH
24783: LD_EXP 47
24787: EQUAL
24788: IFFALSE 24808
// begin SurrenderBase ( t_kill , ai_s [ 3 ] ) ;
24790: LD_EXP 1
24794: PPUSH
24795: LD_EXP 23
24799: PUSH
24800: LD_INT 3
24802: ARRAY
24803: PPUSH
24804: CALL 30313 0 2
// end ; if un = Davidov then
24808: LD_VAR 0 1
24812: PUSH
24813: LD_EXP 48
24817: EQUAL
24818: IFFALSE 24838
// begin SurrenderBase ( t_kill , ai_s [ 4 ] ) ;
24820: LD_EXP 1
24824: PPUSH
24825: LD_EXP 23
24829: PUSH
24830: LD_INT 4
24832: ARRAY
24833: PPUSH
24834: CALL 30313 0 2
// end ; if un = Eisenstein then
24838: LD_VAR 0 1
24842: PUSH
24843: LD_EXP 49
24847: EQUAL
24848: IFFALSE 24868
// begin SurrenderBase ( t_kill , ai_s [ 5 ] ) ;
24850: LD_EXP 1
24854: PPUSH
24855: LD_EXP 23
24859: PUSH
24860: LD_INT 5
24862: ARRAY
24863: PPUSH
24864: CALL 30313 0 2
// end ; end ; if GetSide ( un ) = you then
24868: LD_VAR 0 1
24872: PPUSH
24873: CALL_OW 255
24877: PUSH
24878: LD_EXP 7
24882: EQUAL
24883: IFFALSE 25003
// case true of GetType ( un ) = unit_building :
24885: LD_INT 1
24887: PUSH
24888: LD_VAR 0 1
24892: PPUSH
24893: CALL_OW 247
24897: PUSH
24898: LD_INT 3
24900: EQUAL
24901: DOUBLE
24902: EQUAL
24903: IFTRUE 24907
24905: GO 24926
24907: POP
// your_builds := your_builds diff un ; GetType ( un ) = unit_vehicle :
24908: LD_ADDR_EXP 36
24912: PUSH
24913: LD_EXP 36
24917: PUSH
24918: LD_VAR 0 1
24922: DIFF
24923: ST_TO_ADDR
24924: GO 25003
24926: LD_VAR 0 1
24930: PPUSH
24931: CALL_OW 247
24935: PUSH
24936: LD_INT 2
24938: EQUAL
24939: DOUBLE
24940: EQUAL
24941: IFTRUE 24945
24943: GO 24964
24945: POP
// your_cars := your_cars diff un ; GetType ( un ) = unit_human :
24946: LD_ADDR_EXP 35
24950: PUSH
24951: LD_EXP 35
24955: PUSH
24956: LD_VAR 0 1
24960: DIFF
24961: ST_TO_ADDR
24962: GO 25003
24964: LD_VAR 0 1
24968: PPUSH
24969: CALL_OW 247
24973: PUSH
24974: LD_INT 1
24976: EQUAL
24977: DOUBLE
24978: EQUAL
24979: IFTRUE 24983
24981: GO 25002
24983: POP
// your_humans := your_humans diff un ; end ;
24984: LD_ADDR_EXP 37
24988: PUSH
24989: LD_EXP 37
24993: PUSH
24994: LD_VAR 0 1
24998: DIFF
24999: ST_TO_ADDR
25000: GO 25003
25002: POP
// end ;
25003: PPOPN 4
25005: END
// on UnitGoesToRed ( un ) do var a ;
25006: LD_INT 0
25008: PPUSH
// begin if not GetSide ( un ) in your_bases ^ you then
25009: LD_VAR 0 1
25013: PPUSH
25014: CALL_OW 255
25018: PUSH
25019: LD_EXP 18
25023: PUSH
25024: LD_EXP 7
25028: ADD
25029: IN
25030: NOT
25031: IFFALSE 25264
// begin if GetBType ( un ) in [ b_depot , b_warehouse ] then
25033: LD_VAR 0 1
25037: PPUSH
25038: CALL_OW 266
25042: PUSH
25043: LD_INT 0
25045: PUSH
25046: LD_INT 1
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: IN
25053: IFFALSE 25264
// begin a := FilterAllUnits ( [ [ f_side , GetSide ( un ) ] ] ) ;
25055: LD_ADDR_VAR 0 2
25059: PUSH
25060: LD_INT 22
25062: PUSH
25063: LD_VAR 0 1
25067: PPUSH
25068: CALL_OW 255
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: EMPTY
25078: LIST
25079: PPUSH
25080: CALL_OW 69
25084: ST_TO_ADDR
// if GetSide ( un ) = ai_s [ 1 ] and IsDead ( behemoth ) and UnitFilter ( a , [ mf_sol ] ) <= 2 and UnitFilter ( a , [ [ f_type , unit_vehicle ] , [ f_or , [ [ f_control , control_manual ] , [ f_occupied ] ] , [ f_control , control_computer ] ] ] ) <= 1 then
25085: LD_VAR 0 1
25089: PPUSH
25090: CALL_OW 255
25094: PUSH
25095: LD_EXP 23
25099: PUSH
25100: LD_INT 1
25102: ARRAY
25103: EQUAL
25104: PUSH
25105: LD_INT 125
25107: PPUSH
25108: CALL_OW 301
25112: AND
25113: PUSH
25114: LD_VAR 0 2
25118: PPUSH
25119: LD_EXP 51
25123: PUSH
25124: EMPTY
25125: LIST
25126: PPUSH
25127: CALL_OW 72
25131: PUSH
25132: LD_INT 2
25134: LESSEQUAL
25135: AND
25136: PUSH
25137: LD_VAR 0 2
25141: PPUSH
25142: LD_INT 21
25144: PUSH
25145: LD_INT 2
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: PUSH
25152: LD_INT 2
25154: PUSH
25155: LD_INT 33
25157: PUSH
25158: LD_INT 1
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: PUSH
25165: LD_INT 59
25167: PUSH
25168: EMPTY
25169: LIST
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PUSH
25175: LD_INT 33
25177: PUSH
25178: LD_INT 3
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: EMPTY
25186: LIST
25187: LIST
25188: LIST
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PPUSH
25194: CALL_OW 72
25198: PUSH
25199: LD_INT 1
25201: LESSEQUAL
25202: AND
25203: IFFALSE 25224
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25205: LD_EXP 6
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 255
25219: PPUSH
25220: CALL 30313 0 2
// if GetSide ( un ) <> ai_s [ 1 ] then
25224: LD_VAR 0 1
25228: PPUSH
25229: CALL_OW 255
25233: PUSH
25234: LD_EXP 23
25238: PUSH
25239: LD_INT 1
25241: ARRAY
25242: NONEQUAL
25243: IFFALSE 25264
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25245: LD_EXP 6
25249: PPUSH
25250: LD_VAR 0 1
25254: PPUSH
25255: CALL_OW 255
25259: PPUSH
25260: CALL 30313 0 2
// end ; end ; end ;
25264: PPOPN 2
25266: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside in ai then
25267: LD_VAR 0 3
25271: PUSH
25272: LD_EXP 24
25276: IN
25277: IFFALSE 25340
// begin remove_from_vehicles ( vehold ) ;
25279: LD_VAR 0 2
25283: PPUSH
25284: CALL 28219 0 1
// if GetAttitude ( origside , you ) = att_neutral then
25288: LD_VAR 0 3
25292: PPUSH
25293: LD_EXP 7
25297: PPUSH
25298: CALL_OW 81
25302: PUSH
25303: LD_INT 0
25305: EQUAL
25306: IFFALSE 25340
// begin ComExitVehicle ( vehnew ) ;
25308: LD_VAR 0 1
25312: PPUSH
25313: CALL_OW 121
// SetSide ( vehnew , origside ) ;
25317: LD_VAR 0 1
25321: PPUSH
25322: LD_VAR 0 3
25326: PPUSH
25327: CALL_OW 235
// add_to_vehicles ( vehnew ) ;
25331: LD_VAR 0 1
25335: PPUSH
25336: CALL 26888 0 1
// end ; end ; if Getside ( vehnew ) in ai then
25340: LD_VAR 0 1
25344: PPUSH
25345: CALL_OW 255
25349: PUSH
25350: LD_EXP 24
25354: IN
25355: IFFALSE 25366
// begin add_to_vehicles ( vehnew ) ;
25357: LD_VAR 0 1
25361: PPUSH
25362: CALL 26888 0 1
// end ; if origside = you then
25366: LD_VAR 0 3
25370: PUSH
25371: LD_EXP 7
25375: EQUAL
25376: IFFALSE 25394
// your_cars := your_cars diff vehold ;
25378: LD_ADDR_EXP 35
25382: PUSH
25383: LD_EXP 35
25387: PUSH
25388: LD_VAR 0 2
25392: DIFF
25393: ST_TO_ADDR
// if GetSide ( vehnew ) = you then
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 255
25403: PUSH
25404: LD_EXP 7
25408: EQUAL
25409: IFFALSE 25427
// your_cars := your_cars union vehnew ;
25411: LD_ADDR_EXP 35
25415: PUSH
25416: LD_EXP 35
25420: PUSH
25421: LD_VAR 0 1
25425: UNION
25426: ST_TO_ADDR
// if getside ( vehnew ) and GetCargo ( vehnew , mat_artefact ) > 0 then
25427: LD_VAR 0 1
25431: PPUSH
25432: CALL_OW 255
25436: PUSH
25437: LD_VAR 0 1
25441: PPUSH
25442: LD_INT 4
25444: PPUSH
25445: CALL_OW 289
25449: PUSH
25450: LD_INT 0
25452: GREATER
25453: AND
25454: IFFALSE 25464
// maji_artifact := true ;
25456: LD_ADDR_EXP 39
25460: PUSH
25461: LD_INT 1
25463: ST_TO_ADDR
// if origside = you and GetCargo ( vehnew , mat_artefact ) > 0 then
25464: LD_VAR 0 3
25468: PUSH
25469: LD_EXP 7
25473: EQUAL
25474: PUSH
25475: LD_VAR 0 1
25479: PPUSH
25480: LD_INT 4
25482: PPUSH
25483: CALL_OW 289
25487: PUSH
25488: LD_INT 0
25490: GREATER
25491: AND
25492: IFFALSE 25502
// maji_artifact := false ;
25494: LD_ADDR_EXP 39
25498: PUSH
25499: LD_INT 0
25501: ST_TO_ADDR
// end ;
25502: PPOPN 4
25504: END
// on BuildingCaptured ( build , origside , eng ) do begin if origside = you then
25505: LD_VAR 0 2
25509: PUSH
25510: LD_EXP 7
25514: EQUAL
25515: IFFALSE 25533
// begin your_builds := your_builds diff build ;
25517: LD_ADDR_EXP 36
25521: PUSH
25522: LD_EXP 36
25526: PUSH
25527: LD_VAR 0 1
25531: DIFF
25532: ST_TO_ADDR
// end ; if GetSide ( build ) = you then
25533: LD_VAR 0 1
25537: PPUSH
25538: CALL_OW 255
25542: PUSH
25543: LD_EXP 7
25547: EQUAL
25548: IFFALSE 25566
// begin your_builds := your_builds union build ;
25550: LD_ADDR_EXP 36
25554: PUSH
25555: LD_EXP 36
25559: PUSH
25560: LD_VAR 0 1
25564: UNION
25565: ST_TO_ADDR
// end ; if origside in ai then
25566: LD_VAR 0 2
25570: PUSH
25571: LD_EXP 24
25575: IN
25576: IFFALSE 25587
// begin remove_from_builds ( build ) ;
25578: LD_VAR 0 1
25582: PPUSH
25583: CALL 27735 0 1
// end ; if GetSide ( build ) in ai then
25587: LD_VAR 0 1
25591: PPUSH
25592: CALL_OW 255
25596: PUSH
25597: LD_EXP 24
25601: IN
25602: IFFALSE 25613
// begin add_to_builds ( build ) ;
25604: LD_VAR 0 1
25608: PPUSH
25609: CALL 27233 0 1
// end ; end ;
25613: PPOPN 3
25615: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
25616: LD_VAR 0 1
25620: PPUSH
25621: CALL_OW 255
25625: PUSH
25626: LD_EXP 7
25630: EQUAL
25631: IFFALSE 25649
// begin your_builds := your_builds union build ;
25633: LD_ADDR_EXP 36
25637: PUSH
25638: LD_EXP 36
25642: PUSH
25643: LD_VAR 0 1
25647: UNION
25648: ST_TO_ADDR
// end ; if GetSide ( build ) in ai then
25649: LD_VAR 0 1
25653: PPUSH
25654: CALL_OW 255
25658: PUSH
25659: LD_EXP 24
25663: IN
25664: IFFALSE 25675
// begin add_to_builds ( build ) ;
25666: LD_VAR 0 1
25670: PPUSH
25671: CALL 27233 0 1
// end ; end ;
25675: PPOPN 1
25677: END
// on VehicleConstructed ( veh , fact ) do begin if GetSide ( veh ) = you then
25678: LD_VAR 0 1
25682: PPUSH
25683: CALL_OW 255
25687: PUSH
25688: LD_EXP 7
25692: EQUAL
25693: IFFALSE 25711
// begin your_cars := your_cars union veh ;
25695: LD_ADDR_EXP 35
25699: PUSH
25700: LD_EXP 35
25704: PUSH
25705: LD_VAR 0 1
25709: UNION
25710: ST_TO_ADDR
// end ; if GetSide ( veh ) in ai then
25711: LD_VAR 0 1
25715: PPUSH
25716: CALL_OW 255
25720: PUSH
25721: LD_EXP 24
25725: IN
25726: IFFALSE 26075
// begin if GetControl ( veh ) = control_computer then
25728: LD_VAR 0 1
25732: PPUSH
25733: CALL_OW 263
25737: PUSH
25738: LD_INT 3
25740: EQUAL
25741: IFFALSE 25901
// case GetSide ( veh ) of ai_s [ 1 ] :
25743: LD_VAR 0 1
25747: PPUSH
25748: CALL_OW 255
25752: PUSH
25753: LD_EXP 23
25757: PUSH
25758: LD_INT 1
25760: ARRAY
25761: DOUBLE
25762: EQUAL
25763: IFTRUE 25767
25765: GO 25782
25767: POP
// ComMoveToArea ( veh , pro_attA ) ; ai_s [ 2 ] :
25768: LD_VAR 0 1
25772: PPUSH
25773: LD_INT 8
25775: PPUSH
25776: CALL_OW 113
25780: GO 25899
25782: LD_EXP 23
25786: PUSH
25787: LD_INT 2
25789: ARRAY
25790: DOUBLE
25791: EQUAL
25792: IFTRUE 25796
25794: GO 25811
25796: POP
// ComMoveToArea ( veh , pro_attB ) ; ai_s [ 3 ] :
25797: LD_VAR 0 1
25801: PPUSH
25802: LD_INT 10
25804: PPUSH
25805: CALL_OW 113
25809: GO 25899
25811: LD_EXP 23
25815: PUSH
25816: LD_INT 3
25818: ARRAY
25819: DOUBLE
25820: EQUAL
25821: IFTRUE 25825
25823: GO 25840
25825: POP
// ComMoveToArea ( veh , pro_attC ) ; ai_s [ 4 ] :
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 17
25833: PPUSH
25834: CALL_OW 113
25838: GO 25899
25840: LD_EXP 23
25844: PUSH
25845: LD_INT 4
25847: ARRAY
25848: DOUBLE
25849: EQUAL
25850: IFTRUE 25854
25852: GO 25869
25854: POP
// ComMoveToArea ( veh , pro_attD ) ; ai_s [ 5 ] :
25855: LD_VAR 0 1
25859: PPUSH
25860: LD_INT 15
25862: PPUSH
25863: CALL_OW 113
25867: GO 25899
25869: LD_EXP 23
25873: PUSH
25874: LD_INT 5
25876: ARRAY
25877: DOUBLE
25878: EQUAL
25879: IFTRUE 25883
25881: GO 25898
25883: POP
// ComMoveToArea ( veh , pro_attE ) ; end else
25884: LD_VAR 0 1
25888: PPUSH
25889: LD_INT 12
25891: PPUSH
25892: CALL_OW 113
25896: GO 25899
25898: POP
25899: GO 26057
// case GetSide ( veh ) of ai_s [ 1 ] :
25901: LD_VAR 0 1
25905: PPUSH
25906: CALL_OW 255
25910: PUSH
25911: LD_EXP 23
25915: PUSH
25916: LD_INT 1
25918: ARRAY
25919: DOUBLE
25920: EQUAL
25921: IFTRUE 25925
25923: GO 25940
25925: POP
// ComMoveToArea ( veh , pro_defA ) ; ai_s [ 2 ] :
25926: LD_VAR 0 1
25930: PPUSH
25931: LD_INT 9
25933: PPUSH
25934: CALL_OW 113
25938: GO 26057
25940: LD_EXP 23
25944: PUSH
25945: LD_INT 2
25947: ARRAY
25948: DOUBLE
25949: EQUAL
25950: IFTRUE 25954
25952: GO 25969
25954: POP
// ComMoveToArea ( veh , pro_defB ) ; ai_s [ 3 ] :
25955: LD_VAR 0 1
25959: PPUSH
25960: LD_INT 11
25962: PPUSH
25963: CALL_OW 113
25967: GO 26057
25969: LD_EXP 23
25973: PUSH
25974: LD_INT 3
25976: ARRAY
25977: DOUBLE
25978: EQUAL
25979: IFTRUE 25983
25981: GO 25998
25983: POP
// ComMoveToArea ( veh , pro_defC ) ; ai_s [ 4 ] :
25984: LD_VAR 0 1
25988: PPUSH
25989: LD_INT 16
25991: PPUSH
25992: CALL_OW 113
25996: GO 26057
25998: LD_EXP 23
26002: PUSH
26003: LD_INT 4
26005: ARRAY
26006: DOUBLE
26007: EQUAL
26008: IFTRUE 26012
26010: GO 26027
26012: POP
// ComMoveToArea ( veh , pro_defD ) ; ai_s [ 5 ] :
26013: LD_VAR 0 1
26017: PPUSH
26018: LD_INT 14
26020: PPUSH
26021: CALL_OW 113
26025: GO 26057
26027: LD_EXP 23
26031: PUSH
26032: LD_INT 5
26034: ARRAY
26035: DOUBLE
26036: EQUAL
26037: IFTRUE 26041
26039: GO 26056
26041: POP
// ComMoveToArea ( veh , pro_defE ) ; end ;
26042: LD_VAR 0 1
26046: PPUSH
26047: LD_INT 13
26049: PPUSH
26050: CALL_OW 113
26054: GO 26057
26056: POP
// AddComExitVehicle ( veh ) ;
26057: LD_VAR 0 1
26061: PPUSH
26062: CALL_OW 181
// add_to_vehicles ( veh ) ;
26066: LD_VAR 0 1
26070: PPUSH
26071: CALL 26888 0 1
// end ; end ;
26075: PPOPN 2
26077: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) = you then
26078: LD_VAR 0 1
26082: PPUSH
26083: CALL_OW 255
26087: PUSH
26088: LD_EXP 7
26092: EQUAL
26093: IFFALSE 26103
// maji_artifact := true ;
26095: LD_ADDR_EXP 39
26099: PUSH
26100: LD_INT 1
26102: ST_TO_ADDR
// art_cargo1 := un ;
26103: LD_ADDR_EXP 34
26107: PUSH
26108: LD_VAR 0 1
26112: ST_TO_ADDR
// end ;
26113: PPOPN 2
26115: END
// on ArtifactUnloaded ( un , size ) do begin if GetSide ( un ) = you then
26116: LD_VAR 0 1
26120: PPUSH
26121: CALL_OW 255
26125: PUSH
26126: LD_EXP 7
26130: EQUAL
26131: IFFALSE 26141
// maji_artifact := false ;
26133: LD_ADDR_EXP 39
26137: PUSH
26138: LD_INT 0
26140: ST_TO_ADDR
// art_cargo1 := 0 ;
26141: LD_ADDR_EXP 34
26145: PUSH
26146: LD_INT 0
26148: ST_TO_ADDR
// end ;
26149: PPOPN 2
26151: END
// on Command ( comm ) do begin if not Getside ( Eisenstein ) = you and IsInUnit ( Eisenstein ) then
26152: LD_EXP 49
26156: PPUSH
26157: CALL_OW 255
26161: PUSH
26162: LD_EXP 7
26166: EQUAL
26167: NOT
26168: PUSH
26169: LD_EXP 49
26173: PPUSH
26174: CALL_OW 310
26178: AND
26179: IFFALSE 26190
// RemoveTasks ( Eisenstein ) ;
26181: LD_EXP 49
26185: PPUSH
26186: CALL_OW 493
// if not Getside ( Davidov ) = you and IsInUnit ( Davidov ) then
26190: LD_EXP 48
26194: PPUSH
26195: CALL_OW 255
26199: PUSH
26200: LD_EXP 7
26204: EQUAL
26205: NOT
26206: PUSH
26207: LD_EXP 48
26211: PPUSH
26212: CALL_OW 310
26216: AND
26217: IFFALSE 26228
// RemoveTasks ( Davidov ) ;
26219: LD_EXP 48
26223: PPUSH
26224: CALL_OW 493
// if not Getside ( Tsaritsyn ) = you and IsInUnit ( Tsaritsyn ) then
26228: LD_EXP 47
26232: PPUSH
26233: CALL_OW 255
26237: PUSH
26238: LD_EXP 7
26242: EQUAL
26243: NOT
26244: PUSH
26245: LD_EXP 47
26249: PPUSH
26250: CALL_OW 310
26254: AND
26255: IFFALSE 26266
// RemoveTasks ( Tsaritsyn ) ;
26257: LD_EXP 47
26261: PPUSH
26262: CALL_OW 493
// if not Getside ( Borodin ) = you and IsInUnit ( Borodin ) then
26266: LD_EXP 46
26270: PPUSH
26271: CALL_OW 255
26275: PUSH
26276: LD_EXP 7
26280: EQUAL
26281: NOT
26282: PUSH
26283: LD_EXP 46
26287: PPUSH
26288: CALL_OW 310
26292: AND
26293: IFFALSE 26304
// RemoveTasks ( Borodin ) ;
26295: LD_EXP 46
26299: PPUSH
26300: CALL_OW 493
// end ;
26304: PPOPN 1
26306: END
// on McAttackDone ( mcid , surv ) do begin msg ( [ mcid , McAttackDone , surv ] ) ;
26307: LD_VAR 0 1
26311: PUSH
26312: LD_STRING McAttackDone
26314: PUSH
26315: LD_VAR 0 2
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: LIST
26324: PPUSH
26325: CALL_OW 100
// end ;
26329: PPOPN 2
26331: END
// on McRegistryResultChanges ( mcid , count , strength ) do begin if mcid = BehMcRegId then
26332: LD_VAR 0 1
26336: PUSH
26337: LD_EXP 64
26341: EQUAL
26342: IFFALSE 26393
// debug_strings := replace ( debug_strings , 2 , [ mcid , count , strength , GetMcUnits ( BehMcAttId ) ] ) ;
26344: LD_ADDR_OWVAR 48
26348: PUSH
26349: LD_OWVAR 48
26353: PPUSH
26354: LD_INT 2
26356: PPUSH
26357: LD_VAR 0 1
26361: PUSH
26362: LD_VAR 0 2
26366: PUSH
26367: LD_VAR 0 3
26371: PUSH
26372: LD_EXP 65
26376: PPUSH
26377: CALL_OW 389
26381: PUSH
26382: EMPTY
26383: LIST
26384: LIST
26385: LIST
26386: LIST
26387: PPUSH
26388: CALL_OW 1
26392: ST_TO_ADDR
// end ;
26393: PPOPN 3
26395: END
// export function add_to ( un ) ; begin
26396: LD_INT 0
26398: PPUSH
// add_to_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
26399: LD_VAR 0 1
26403: PPUSH
26404: LD_INT 21
26406: PUSH
26407: LD_INT 1
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: EMPTY
26415: LIST
26416: PPUSH
26417: CALL_OW 72
26421: PPUSH
26422: CALL 26485 0 1
// add_to_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
26426: LD_VAR 0 1
26430: PPUSH
26431: LD_INT 21
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: EMPTY
26442: LIST
26443: PPUSH
26444: CALL_OW 72
26448: PPUSH
26449: CALL 27233 0 1
// add_to_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
26453: LD_VAR 0 1
26457: PPUSH
26458: LD_INT 21
26460: PUSH
26461: LD_INT 2
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: EMPTY
26469: LIST
26470: PPUSH
26471: CALL_OW 72
26475: PPUSH
26476: CALL 26888 0 1
// end ;
26480: LD_VAR 0 2
26484: RET
// export function add_to_humans ( un ) ; var i ; begin
26485: LD_INT 0
26487: PPUSH
26488: PPUSH
// sol := sol union UnitFilter ( un , [ mf_sol ] ) ;
26489: LD_ADDR_EXP 82
26493: PUSH
26494: LD_EXP 82
26498: PUSH
26499: LD_VAR 0 1
26503: PPUSH
26504: LD_EXP 51
26508: PUSH
26509: EMPTY
26510: LIST
26511: PPUSH
26512: CALL_OW 72
26516: UNION
26517: ST_TO_ADDR
// eng := eng union UnitFilter ( un , [ mf_eng ] ) ;
26518: LD_ADDR_EXP 84
26522: PUSH
26523: LD_EXP 84
26527: PUSH
26528: LD_VAR 0 1
26532: PPUSH
26533: LD_EXP 52
26537: PUSH
26538: EMPTY
26539: LIST
26540: PPUSH
26541: CALL_OW 72
26545: UNION
26546: ST_TO_ADDR
// mec := mec union UnitFilter ( un , [ mf_mec ] ) ;
26547: LD_ADDR_EXP 86
26551: PUSH
26552: LD_EXP 86
26556: PUSH
26557: LD_VAR 0 1
26561: PPUSH
26562: LD_EXP 53
26566: PUSH
26567: EMPTY
26568: LIST
26569: PPUSH
26570: CALL_OW 72
26574: UNION
26575: ST_TO_ADDR
// sci := sci union UnitFilter ( un , [ mf_sci ] ) ;
26576: LD_ADDR_EXP 88
26580: PUSH
26581: LD_EXP 88
26585: PUSH
26586: LD_VAR 0 1
26590: PPUSH
26591: LD_EXP 54
26595: PUSH
26596: EMPTY
26597: LIST
26598: PPUSH
26599: CALL_OW 72
26603: UNION
26604: ST_TO_ADDR
// for i in un do
26605: LD_ADDR_VAR 0 3
26609: PUSH
26610: LD_VAR 0 1
26614: PUSH
26615: FOR_IN
26616: IFFALSE 26881
// begin case GetSide ( i ) of ai_s [ 1 ] :
26618: LD_VAR 0 3
26622: PPUSH
26623: CALL_OW 255
26627: PUSH
26628: LD_EXP 23
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: DOUBLE
26637: EQUAL
26638: IFTRUE 26642
26640: GO 26678
26642: POP
// humans := replace ( humans , 1 , humans [ 1 ] union i ) ; ai_s [ 2 ] :
26643: LD_ADDR_EXP 76
26647: PUSH
26648: LD_EXP 76
26652: PPUSH
26653: LD_INT 1
26655: PPUSH
26656: LD_EXP 76
26660: PUSH
26661: LD_INT 1
26663: ARRAY
26664: PUSH
26665: LD_VAR 0 3
26669: UNION
26670: PPUSH
26671: CALL_OW 1
26675: ST_TO_ADDR
26676: GO 26879
26678: LD_EXP 23
26682: PUSH
26683: LD_INT 2
26685: ARRAY
26686: DOUBLE
26687: EQUAL
26688: IFTRUE 26692
26690: GO 26728
26692: POP
// humans := replace ( humans , 2 , humans [ 2 ] union i ) ; ai_s [ 3 ] :
26693: LD_ADDR_EXP 76
26697: PUSH
26698: LD_EXP 76
26702: PPUSH
26703: LD_INT 2
26705: PPUSH
26706: LD_EXP 76
26710: PUSH
26711: LD_INT 2
26713: ARRAY
26714: PUSH
26715: LD_VAR 0 3
26719: UNION
26720: PPUSH
26721: CALL_OW 1
26725: ST_TO_ADDR
26726: GO 26879
26728: LD_EXP 23
26732: PUSH
26733: LD_INT 3
26735: ARRAY
26736: DOUBLE
26737: EQUAL
26738: IFTRUE 26742
26740: GO 26778
26742: POP
// humans := replace ( humans , 3 , humans [ 3 ] union i ) ; ai_s [ 4 ] :
26743: LD_ADDR_EXP 76
26747: PUSH
26748: LD_EXP 76
26752: PPUSH
26753: LD_INT 3
26755: PPUSH
26756: LD_EXP 76
26760: PUSH
26761: LD_INT 3
26763: ARRAY
26764: PUSH
26765: LD_VAR 0 3
26769: UNION
26770: PPUSH
26771: CALL_OW 1
26775: ST_TO_ADDR
26776: GO 26879
26778: LD_EXP 23
26782: PUSH
26783: LD_INT 4
26785: ARRAY
26786: DOUBLE
26787: EQUAL
26788: IFTRUE 26792
26790: GO 26828
26792: POP
// humans := replace ( humans , 4 , humans [ 4 ] union i ) ; ai_s [ 5 ] :
26793: LD_ADDR_EXP 76
26797: PUSH
26798: LD_EXP 76
26802: PPUSH
26803: LD_INT 4
26805: PPUSH
26806: LD_EXP 76
26810: PUSH
26811: LD_INT 4
26813: ARRAY
26814: PUSH
26815: LD_VAR 0 3
26819: UNION
26820: PPUSH
26821: CALL_OW 1
26825: ST_TO_ADDR
26826: GO 26879
26828: LD_EXP 23
26832: PUSH
26833: LD_INT 5
26835: ARRAY
26836: DOUBLE
26837: EQUAL
26838: IFTRUE 26842
26840: GO 26878
26842: POP
// humans := replace ( humans , 5 , humans [ 5 ] union i ) ; end ;
26843: LD_ADDR_EXP 76
26847: PUSH
26848: LD_EXP 76
26852: PPUSH
26853: LD_INT 5
26855: PPUSH
26856: LD_EXP 76
26860: PUSH
26861: LD_INT 5
26863: ARRAY
26864: PUSH
26865: LD_VAR 0 3
26869: UNION
26870: PPUSH
26871: CALL_OW 1
26875: ST_TO_ADDR
26876: GO 26879
26878: POP
// end ;
26879: GO 26615
26881: POP
26882: POP
// end ;
26883: LD_VAR 0 2
26887: RET
// export function add_to_vehicles ( un ) ; var i ; begin
26888: LD_INT 0
26890: PPUSH
26891: PPUSH
// attack_units := attack_units union UnitFilter ( un , [ mf_comp ] ) ;
26892: LD_ADDR_EXP 78
26896: PUSH
26897: LD_EXP 78
26901: PUSH
26902: LD_VAR 0 1
26906: PPUSH
26907: LD_EXP 60
26911: PUSH
26912: EMPTY
26913: LIST
26914: PPUSH
26915: CALL_OW 72
26919: UNION
26920: ST_TO_ADDR
// defence_units := defence_units union UnitFilter ( un , [ mf_manu ] ) ;
26921: LD_ADDR_EXP 79
26925: PUSH
26926: LD_EXP 79
26930: PUSH
26931: LD_VAR 0 1
26935: PPUSH
26936: LD_EXP 61
26940: PUSH
26941: EMPTY
26942: LIST
26943: PPUSH
26944: CALL_OW 72
26948: UNION
26949: ST_TO_ADDR
// for i in un do
26950: LD_ADDR_VAR 0 3
26954: PUSH
26955: LD_VAR 0 1
26959: PUSH
26960: FOR_IN
26961: IFFALSE 27226
// begin case getside ( i ) of ai_s [ 1 ] :
26963: LD_VAR 0 3
26967: PPUSH
26968: CALL_OW 255
26972: PUSH
26973: LD_EXP 23
26977: PUSH
26978: LD_INT 1
26980: ARRAY
26981: DOUBLE
26982: EQUAL
26983: IFTRUE 26987
26985: GO 27023
26987: POP
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] union i ) ; ai_s [ 2 ] :
26988: LD_ADDR_EXP 77
26992: PUSH
26993: LD_EXP 77
26997: PPUSH
26998: LD_INT 1
27000: PPUSH
27001: LD_EXP 77
27005: PUSH
27006: LD_INT 1
27008: ARRAY
27009: PUSH
27010: LD_VAR 0 3
27014: UNION
27015: PPUSH
27016: CALL_OW 1
27020: ST_TO_ADDR
27021: GO 27224
27023: LD_EXP 23
27027: PUSH
27028: LD_INT 2
27030: ARRAY
27031: DOUBLE
27032: EQUAL
27033: IFTRUE 27037
27035: GO 27073
27037: POP
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] union i ) ; ai_s [ 3 ] :
27038: LD_ADDR_EXP 77
27042: PUSH
27043: LD_EXP 77
27047: PPUSH
27048: LD_INT 2
27050: PPUSH
27051: LD_EXP 77
27055: PUSH
27056: LD_INT 2
27058: ARRAY
27059: PUSH
27060: LD_VAR 0 3
27064: UNION
27065: PPUSH
27066: CALL_OW 1
27070: ST_TO_ADDR
27071: GO 27224
27073: LD_EXP 23
27077: PUSH
27078: LD_INT 3
27080: ARRAY
27081: DOUBLE
27082: EQUAL
27083: IFTRUE 27087
27085: GO 27123
27087: POP
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] union i ) ; ai_s [ 4 ] :
27088: LD_ADDR_EXP 77
27092: PUSH
27093: LD_EXP 77
27097: PPUSH
27098: LD_INT 3
27100: PPUSH
27101: LD_EXP 77
27105: PUSH
27106: LD_INT 3
27108: ARRAY
27109: PUSH
27110: LD_VAR 0 3
27114: UNION
27115: PPUSH
27116: CALL_OW 1
27120: ST_TO_ADDR
27121: GO 27224
27123: LD_EXP 23
27127: PUSH
27128: LD_INT 4
27130: ARRAY
27131: DOUBLE
27132: EQUAL
27133: IFTRUE 27137
27135: GO 27173
27137: POP
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] union i ) ; ai_s [ 5 ] :
27138: LD_ADDR_EXP 77
27142: PUSH
27143: LD_EXP 77
27147: PPUSH
27148: LD_INT 4
27150: PPUSH
27151: LD_EXP 77
27155: PUSH
27156: LD_INT 4
27158: ARRAY
27159: PUSH
27160: LD_VAR 0 3
27164: UNION
27165: PPUSH
27166: CALL_OW 1
27170: ST_TO_ADDR
27171: GO 27224
27173: LD_EXP 23
27177: PUSH
27178: LD_INT 5
27180: ARRAY
27181: DOUBLE
27182: EQUAL
27183: IFTRUE 27187
27185: GO 27223
27187: POP
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] union i ) ; end ;
27188: LD_ADDR_EXP 77
27192: PUSH
27193: LD_EXP 77
27197: PPUSH
27198: LD_INT 5
27200: PPUSH
27201: LD_EXP 77
27205: PUSH
27206: LD_INT 5
27208: ARRAY
27209: PUSH
27210: LD_VAR 0 3
27214: UNION
27215: PPUSH
27216: CALL_OW 1
27220: ST_TO_ADDR
27221: GO 27224
27223: POP
// end ;
27224: GO 26960
27226: POP
27227: POP
// end ;
27228: LD_VAR 0 2
27232: RET
// export function add_to_builds ( un ) ; var i , j , bt ; begin
27233: LD_INT 0
27235: PPUSH
27236: PPUSH
27237: PPUSH
27238: PPUSH
// fort := fort union UnitFilter ( un , [ mf_fort ] ) ;
27239: LD_ADDR_EXP 81
27243: PUSH
27244: LD_EXP 81
27248: PUSH
27249: LD_VAR 0 1
27253: PPUSH
27254: LD_EXP 56
27258: PUSH
27259: EMPTY
27260: LIST
27261: PPUSH
27262: CALL_OW 72
27266: UNION
27267: ST_TO_ADDR
// dep := dep union UnitFilter ( un , [ mf_dep ] ) ;
27268: LD_ADDR_EXP 83
27272: PUSH
27273: LD_EXP 83
27277: PUSH
27278: LD_VAR 0 1
27282: PPUSH
27283: LD_EXP 58
27287: PUSH
27288: EMPTY
27289: LIST
27290: PPUSH
27291: CALL_OW 72
27295: UNION
27296: ST_TO_ADDR
// fact := fact union UnitFilter ( un , [ mf_fact ] ) ;
27297: LD_ADDR_EXP 85
27301: PUSH
27302: LD_EXP 85
27306: PUSH
27307: LD_VAR 0 1
27311: PPUSH
27312: LD_EXP 59
27316: PUSH
27317: EMPTY
27318: LIST
27319: PPUSH
27320: CALL_OW 72
27324: UNION
27325: ST_TO_ADDR
// lab := lab union UnitFilter ( un , [ mf_lab ] ) ;
27326: LD_ADDR_EXP 87
27330: PUSH
27331: LD_EXP 87
27335: PUSH
27336: LD_VAR 0 1
27340: PPUSH
27341: LD_EXP 55
27345: PUSH
27346: EMPTY
27347: LIST
27348: PPUSH
27349: CALL_OW 72
27353: UNION
27354: ST_TO_ADDR
// for i in un do
27355: LD_ADDR_VAR 0 3
27359: PUSH
27360: LD_VAR 0 1
27364: PUSH
27365: FOR_IN
27366: IFFALSE 27631
// begin case GetSide ( i ) of ai_s [ 1 ] :
27368: LD_VAR 0 3
27372: PPUSH
27373: CALL_OW 255
27377: PUSH
27378: LD_EXP 23
27382: PUSH
27383: LD_INT 1
27385: ARRAY
27386: DOUBLE
27387: EQUAL
27388: IFTRUE 27392
27390: GO 27428
27392: POP
// buildings := replace ( buildings , 1 , buildings [ 1 ] union i ) ; ai_s [ 2 ] :
27393: LD_ADDR_EXP 75
27397: PUSH
27398: LD_EXP 75
27402: PPUSH
27403: LD_INT 1
27405: PPUSH
27406: LD_EXP 75
27410: PUSH
27411: LD_INT 1
27413: ARRAY
27414: PUSH
27415: LD_VAR 0 3
27419: UNION
27420: PPUSH
27421: CALL_OW 1
27425: ST_TO_ADDR
27426: GO 27629
27428: LD_EXP 23
27432: PUSH
27433: LD_INT 2
27435: ARRAY
27436: DOUBLE
27437: EQUAL
27438: IFTRUE 27442
27440: GO 27478
27442: POP
// buildings := replace ( buildings , 2 , buildings [ 2 ] union i ) ; ai_s [ 3 ] :
27443: LD_ADDR_EXP 75
27447: PUSH
27448: LD_EXP 75
27452: PPUSH
27453: LD_INT 2
27455: PPUSH
27456: LD_EXP 75
27460: PUSH
27461: LD_INT 2
27463: ARRAY
27464: PUSH
27465: LD_VAR 0 3
27469: UNION
27470: PPUSH
27471: CALL_OW 1
27475: ST_TO_ADDR
27476: GO 27629
27478: LD_EXP 23
27482: PUSH
27483: LD_INT 3
27485: ARRAY
27486: DOUBLE
27487: EQUAL
27488: IFTRUE 27492
27490: GO 27528
27492: POP
// buildings := replace ( buildings , 3 , buildings [ 3 ] union i ) ; ai_s [ 4 ] :
27493: LD_ADDR_EXP 75
27497: PUSH
27498: LD_EXP 75
27502: PPUSH
27503: LD_INT 3
27505: PPUSH
27506: LD_EXP 75
27510: PUSH
27511: LD_INT 3
27513: ARRAY
27514: PUSH
27515: LD_VAR 0 3
27519: UNION
27520: PPUSH
27521: CALL_OW 1
27525: ST_TO_ADDR
27526: GO 27629
27528: LD_EXP 23
27532: PUSH
27533: LD_INT 4
27535: ARRAY
27536: DOUBLE
27537: EQUAL
27538: IFTRUE 27542
27540: GO 27578
27542: POP
// buildings := replace ( buildings , 4 , buildings [ 4 ] union i ) ; ai_s [ 5 ] :
27543: LD_ADDR_EXP 75
27547: PUSH
27548: LD_EXP 75
27552: PPUSH
27553: LD_INT 4
27555: PPUSH
27556: LD_EXP 75
27560: PUSH
27561: LD_INT 4
27563: ARRAY
27564: PUSH
27565: LD_VAR 0 3
27569: UNION
27570: PPUSH
27571: CALL_OW 1
27575: ST_TO_ADDR
27576: GO 27629
27578: LD_EXP 23
27582: PUSH
27583: LD_INT 5
27585: ARRAY
27586: DOUBLE
27587: EQUAL
27588: IFTRUE 27592
27590: GO 27628
27592: POP
// buildings := replace ( buildings , 5 , buildings [ 5 ] union i ) ; end ;
27593: LD_ADDR_EXP 75
27597: PUSH
27598: LD_EXP 75
27602: PPUSH
27603: LD_INT 5
27605: PPUSH
27606: LD_EXP 75
27610: PUSH
27611: LD_INT 5
27613: ARRAY
27614: PUSH
27615: LD_VAR 0 3
27619: UNION
27620: PPUSH
27621: CALL_OW 1
27625: ST_TO_ADDR
27626: GO 27629
27628: POP
// end ;
27629: GO 27365
27631: POP
27632: POP
// write_deps ;
27633: CALL 23353 0 0
// write_facts ;
27637: CALL 23472 0 0
// end ;
27641: LD_VAR 0 2
27645: RET
// export function remove_from ( un ) ; begin
27646: LD_INT 0
27648: PPUSH
// remove_from_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
27649: LD_VAR 0 1
27653: PPUSH
27654: LD_INT 21
27656: PUSH
27657: LD_INT 1
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PUSH
27664: EMPTY
27665: LIST
27666: PPUSH
27667: CALL_OW 72
27671: PPUSH
27672: CALL 27981 0 1
// remove_from_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
27676: LD_VAR 0 1
27680: PPUSH
27681: LD_INT 21
27683: PUSH
27684: LD_INT 3
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: EMPTY
27692: LIST
27693: PPUSH
27694: CALL_OW 72
27698: PPUSH
27699: CALL 27735 0 1
// remove_from_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
27703: LD_VAR 0 1
27707: PPUSH
27708: LD_INT 21
27710: PUSH
27711: LD_INT 2
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: EMPTY
27719: LIST
27720: PPUSH
27721: CALL_OW 72
27725: PPUSH
27726: CALL 28219 0 1
// end ;
27730: LD_VAR 0 2
27734: RET
// export function remove_from_builds ( un ) ; var i ; begin
27735: LD_INT 0
27737: PPUSH
27738: PPUSH
// fact := fact diff un ;
27739: LD_ADDR_EXP 85
27743: PUSH
27744: LD_EXP 85
27748: PUSH
27749: LD_VAR 0 1
27753: DIFF
27754: ST_TO_ADDR
// fort := fort diff un ;
27755: LD_ADDR_EXP 81
27759: PUSH
27760: LD_EXP 81
27764: PUSH
27765: LD_VAR 0 1
27769: DIFF
27770: ST_TO_ADDR
// lab := lab diff un ;
27771: LD_ADDR_EXP 87
27775: PUSH
27776: LD_EXP 87
27780: PUSH
27781: LD_VAR 0 1
27785: DIFF
27786: ST_TO_ADDR
// dep := dep diff un ;
27787: LD_ADDR_EXP 83
27791: PUSH
27792: LD_EXP 83
27796: PUSH
27797: LD_VAR 0 1
27801: DIFF
27802: ST_TO_ADDR
// buildings := replace ( buildings , 1 , buildings [ 1 ] diff un ) ;
27803: LD_ADDR_EXP 75
27807: PUSH
27808: LD_EXP 75
27812: PPUSH
27813: LD_INT 1
27815: PPUSH
27816: LD_EXP 75
27820: PUSH
27821: LD_INT 1
27823: ARRAY
27824: PUSH
27825: LD_VAR 0 1
27829: DIFF
27830: PPUSH
27831: CALL_OW 1
27835: ST_TO_ADDR
// buildings := replace ( buildings , 2 , buildings [ 2 ] diff un ) ;
27836: LD_ADDR_EXP 75
27840: PUSH
27841: LD_EXP 75
27845: PPUSH
27846: LD_INT 2
27848: PPUSH
27849: LD_EXP 75
27853: PUSH
27854: LD_INT 2
27856: ARRAY
27857: PUSH
27858: LD_VAR 0 1
27862: DIFF
27863: PPUSH
27864: CALL_OW 1
27868: ST_TO_ADDR
// buildings := replace ( buildings , 3 , buildings [ 3 ] diff un ) ;
27869: LD_ADDR_EXP 75
27873: PUSH
27874: LD_EXP 75
27878: PPUSH
27879: LD_INT 3
27881: PPUSH
27882: LD_EXP 75
27886: PUSH
27887: LD_INT 3
27889: ARRAY
27890: PUSH
27891: LD_VAR 0 1
27895: DIFF
27896: PPUSH
27897: CALL_OW 1
27901: ST_TO_ADDR
// buildings := replace ( buildings , 4 , buildings [ 4 ] diff un ) ;
27902: LD_ADDR_EXP 75
27906: PUSH
27907: LD_EXP 75
27911: PPUSH
27912: LD_INT 4
27914: PPUSH
27915: LD_EXP 75
27919: PUSH
27920: LD_INT 4
27922: ARRAY
27923: PUSH
27924: LD_VAR 0 1
27928: DIFF
27929: PPUSH
27930: CALL_OW 1
27934: ST_TO_ADDR
// buildings := replace ( buildings , 5 , buildings [ 5 ] diff un ) ;
27935: LD_ADDR_EXP 75
27939: PUSH
27940: LD_EXP 75
27944: PPUSH
27945: LD_INT 5
27947: PPUSH
27948: LD_EXP 75
27952: PUSH
27953: LD_INT 5
27955: ARRAY
27956: PUSH
27957: LD_VAR 0 1
27961: DIFF
27962: PPUSH
27963: CALL_OW 1
27967: ST_TO_ADDR
// write_deps ;
27968: CALL 23353 0 0
// write_facts ;
27972: CALL 23472 0 0
// end ;
27976: LD_VAR 0 2
27980: RET
// export function remove_from_humans ( un ) ; var i ; begin
27981: LD_INT 0
27983: PPUSH
27984: PPUSH
// sol := sol diff un ;
27985: LD_ADDR_EXP 82
27989: PUSH
27990: LD_EXP 82
27994: PUSH
27995: LD_VAR 0 1
27999: DIFF
28000: ST_TO_ADDR
// eng := eng diff un ;
28001: LD_ADDR_EXP 84
28005: PUSH
28006: LD_EXP 84
28010: PUSH
28011: LD_VAR 0 1
28015: DIFF
28016: ST_TO_ADDR
// mec := mec diff un ;
28017: LD_ADDR_EXP 86
28021: PUSH
28022: LD_EXP 86
28026: PUSH
28027: LD_VAR 0 1
28031: DIFF
28032: ST_TO_ADDR
// sci := sci diff un ;
28033: LD_ADDR_EXP 88
28037: PUSH
28038: LD_EXP 88
28042: PUSH
28043: LD_VAR 0 1
28047: DIFF
28048: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff un ) ;
28049: LD_ADDR_EXP 76
28053: PUSH
28054: LD_EXP 76
28058: PPUSH
28059: LD_INT 1
28061: PPUSH
28062: LD_EXP 76
28066: PUSH
28067: LD_INT 1
28069: ARRAY
28070: PUSH
28071: LD_VAR 0 1
28075: DIFF
28076: PPUSH
28077: CALL_OW 1
28081: ST_TO_ADDR
// humans := replace ( humans , 2 , humans [ 2 ] diff un ) ;
28082: LD_ADDR_EXP 76
28086: PUSH
28087: LD_EXP 76
28091: PPUSH
28092: LD_INT 2
28094: PPUSH
28095: LD_EXP 76
28099: PUSH
28100: LD_INT 2
28102: ARRAY
28103: PUSH
28104: LD_VAR 0 1
28108: DIFF
28109: PPUSH
28110: CALL_OW 1
28114: ST_TO_ADDR
// humans := replace ( humans , 3 , humans [ 3 ] diff un ) ;
28115: LD_ADDR_EXP 76
28119: PUSH
28120: LD_EXP 76
28124: PPUSH
28125: LD_INT 3
28127: PPUSH
28128: LD_EXP 76
28132: PUSH
28133: LD_INT 3
28135: ARRAY
28136: PUSH
28137: LD_VAR 0 1
28141: DIFF
28142: PPUSH
28143: CALL_OW 1
28147: ST_TO_ADDR
// humans := replace ( humans , 4 , humans [ 4 ] diff un ) ;
28148: LD_ADDR_EXP 76
28152: PUSH
28153: LD_EXP 76
28157: PPUSH
28158: LD_INT 4
28160: PPUSH
28161: LD_EXP 76
28165: PUSH
28166: LD_INT 4
28168: ARRAY
28169: PUSH
28170: LD_VAR 0 1
28174: DIFF
28175: PPUSH
28176: CALL_OW 1
28180: ST_TO_ADDR
// humans := replace ( humans , 5 , humans [ 5 ] diff un ) ;
28181: LD_ADDR_EXP 76
28185: PUSH
28186: LD_EXP 76
28190: PPUSH
28191: LD_INT 5
28193: PPUSH
28194: LD_EXP 76
28198: PUSH
28199: LD_INT 5
28201: ARRAY
28202: PUSH
28203: LD_VAR 0 1
28207: DIFF
28208: PPUSH
28209: CALL_OW 1
28213: ST_TO_ADDR
// end ;
28214: LD_VAR 0 2
28218: RET
// export function remove_from_vehicles ( un ) ; var i ; begin
28219: LD_INT 0
28221: PPUSH
28222: PPUSH
// attack_units := attack_units diff un ;
28223: LD_ADDR_EXP 78
28227: PUSH
28228: LD_EXP 78
28232: PUSH
28233: LD_VAR 0 1
28237: DIFF
28238: ST_TO_ADDR
// defence_units := defence_units diff un ;
28239: LD_ADDR_EXP 79
28243: PUSH
28244: LD_EXP 79
28248: PUSH
28249: LD_VAR 0 1
28253: DIFF
28254: ST_TO_ADDR
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] diff un ) ;
28255: LD_ADDR_EXP 77
28259: PUSH
28260: LD_EXP 77
28264: PPUSH
28265: LD_INT 1
28267: PPUSH
28268: LD_EXP 77
28272: PUSH
28273: LD_INT 1
28275: ARRAY
28276: PUSH
28277: LD_VAR 0 1
28281: DIFF
28282: PPUSH
28283: CALL_OW 1
28287: ST_TO_ADDR
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] diff un ) ;
28288: LD_ADDR_EXP 77
28292: PUSH
28293: LD_EXP 77
28297: PPUSH
28298: LD_INT 2
28300: PPUSH
28301: LD_EXP 77
28305: PUSH
28306: LD_INT 2
28308: ARRAY
28309: PUSH
28310: LD_VAR 0 1
28314: DIFF
28315: PPUSH
28316: CALL_OW 1
28320: ST_TO_ADDR
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] diff un ) ;
28321: LD_ADDR_EXP 77
28325: PUSH
28326: LD_EXP 77
28330: PPUSH
28331: LD_INT 3
28333: PPUSH
28334: LD_EXP 77
28338: PUSH
28339: LD_INT 3
28341: ARRAY
28342: PUSH
28343: LD_VAR 0 1
28347: DIFF
28348: PPUSH
28349: CALL_OW 1
28353: ST_TO_ADDR
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] diff un ) ;
28354: LD_ADDR_EXP 77
28358: PUSH
28359: LD_EXP 77
28363: PPUSH
28364: LD_INT 4
28366: PPUSH
28367: LD_EXP 77
28371: PUSH
28372: LD_INT 4
28374: ARRAY
28375: PUSH
28376: LD_VAR 0 1
28380: DIFF
28381: PPUSH
28382: CALL_OW 1
28386: ST_TO_ADDR
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] diff un ) ;
28387: LD_ADDR_EXP 77
28391: PUSH
28392: LD_EXP 77
28396: PPUSH
28397: LD_INT 5
28399: PPUSH
28400: LD_EXP 77
28404: PUSH
28405: LD_INT 5
28407: ARRAY
28408: PUSH
28409: LD_VAR 0 1
28413: DIFF
28414: PPUSH
28415: CALL_OW 1
28419: ST_TO_ADDR
// bc := replace ( bc , 1 , bc [ 1 ] diff un ) ;
28420: LD_ADDR_EXP 71
28424: PUSH
28425: LD_EXP 71
28429: PPUSH
28430: LD_INT 1
28432: PPUSH
28433: LD_EXP 71
28437: PUSH
28438: LD_INT 1
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: DIFF
28447: PPUSH
28448: CALL_OW 1
28452: ST_TO_ADDR
// bc := replace ( bc , 2 , bc [ 2 ] diff un ) ;
28453: LD_ADDR_EXP 71
28457: PUSH
28458: LD_EXP 71
28462: PPUSH
28463: LD_INT 2
28465: PPUSH
28466: LD_EXP 71
28470: PUSH
28471: LD_INT 2
28473: ARRAY
28474: PUSH
28475: LD_VAR 0 1
28479: DIFF
28480: PPUSH
28481: CALL_OW 1
28485: ST_TO_ADDR
// bc := replace ( bc , 3 , bc [ 3 ] diff un ) ;
28486: LD_ADDR_EXP 71
28490: PUSH
28491: LD_EXP 71
28495: PPUSH
28496: LD_INT 3
28498: PPUSH
28499: LD_EXP 71
28503: PUSH
28504: LD_INT 3
28506: ARRAY
28507: PUSH
28508: LD_VAR 0 1
28512: DIFF
28513: PPUSH
28514: CALL_OW 1
28518: ST_TO_ADDR
// bc := replace ( bc , 4 , bc [ 4 ] diff un ) ;
28519: LD_ADDR_EXP 71
28523: PUSH
28524: LD_EXP 71
28528: PPUSH
28529: LD_INT 4
28531: PPUSH
28532: LD_EXP 71
28536: PUSH
28537: LD_INT 4
28539: ARRAY
28540: PUSH
28541: LD_VAR 0 1
28545: DIFF
28546: PPUSH
28547: CALL_OW 1
28551: ST_TO_ADDR
// bc := replace ( bc , 5 , bc [ 5 ] diff un ) ;
28552: LD_ADDR_EXP 71
28556: PUSH
28557: LD_EXP 71
28561: PPUSH
28562: LD_INT 5
28564: PPUSH
28565: LD_EXP 71
28569: PUSH
28570: LD_INT 5
28572: ARRAY
28573: PUSH
28574: LD_VAR 0 1
28578: DIFF
28579: PPUSH
28580: CALL_OW 1
28584: ST_TO_ADDR
// rc := replace ( rc , 1 , rc [ 1 ] diff un ) ;
28585: LD_ADDR_EXP 70
28589: PUSH
28590: LD_EXP 70
28594: PPUSH
28595: LD_INT 1
28597: PPUSH
28598: LD_EXP 70
28602: PUSH
28603: LD_INT 1
28605: ARRAY
28606: PUSH
28607: LD_VAR 0 1
28611: DIFF
28612: PPUSH
28613: CALL_OW 1
28617: ST_TO_ADDR
// rc := replace ( rc , 2 , rc [ 2 ] diff un ) ;
28618: LD_ADDR_EXP 70
28622: PUSH
28623: LD_EXP 70
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: LD_EXP 70
28635: PUSH
28636: LD_INT 2
28638: ARRAY
28639: PUSH
28640: LD_VAR 0 1
28644: DIFF
28645: PPUSH
28646: CALL_OW 1
28650: ST_TO_ADDR
// rc := replace ( rc , 3 , rc [ 3 ] diff un ) ;
28651: LD_ADDR_EXP 70
28655: PUSH
28656: LD_EXP 70
28660: PPUSH
28661: LD_INT 3
28663: PPUSH
28664: LD_EXP 70
28668: PUSH
28669: LD_INT 3
28671: ARRAY
28672: PUSH
28673: LD_VAR 0 1
28677: DIFF
28678: PPUSH
28679: CALL_OW 1
28683: ST_TO_ADDR
// rc := replace ( rc , 4 , rc [ 4 ] diff un ) ;
28684: LD_ADDR_EXP 70
28688: PUSH
28689: LD_EXP 70
28693: PPUSH
28694: LD_INT 4
28696: PPUSH
28697: LD_EXP 70
28701: PUSH
28702: LD_INT 4
28704: ARRAY
28705: PUSH
28706: LD_VAR 0 1
28710: DIFF
28711: PPUSH
28712: CALL_OW 1
28716: ST_TO_ADDR
// rc := replace ( rc , 5 , rc [ 5 ] diff un ) ;
28717: LD_ADDR_EXP 70
28721: PUSH
28722: LD_EXP 70
28726: PPUSH
28727: LD_INT 5
28729: PPUSH
28730: LD_EXP 70
28734: PUSH
28735: LD_INT 5
28737: ARRAY
28738: PUSH
28739: LD_VAR 0 1
28743: DIFF
28744: PPUSH
28745: CALL_OW 1
28749: ST_TO_ADDR
// end ; end_of_file
28750: LD_VAR 0 2
28754: RET
// var objevovani_zasilek ; every 1 do
28755: GO 28757
28757: DISABLE
// begin objevovani_zasilek := [ 2 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 ] ;
28758: LD_ADDR_LOC 30
28762: PUSH
28763: LD_INT 2
28765: PUSH
28766: LD_INT 3
28768: PUSH
28769: LD_INT 1
28771: PUSH
28772: LD_INT 5
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: LD_INT 1
28780: PUSH
28781: LD_INT 4
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 3
28792: PUSH
28793: LD_INT 3
28795: PUSH
28796: LD_INT 1
28798: PUSH
28799: LD_INT 5
28801: PUSH
28802: LD_INT 1
28804: PUSH
28805: LD_INT 1
28807: PUSH
28808: LD_INT 4
28810: PUSH
28811: LD_INT 1
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: LD_INT 3
28819: PUSH
28820: LD_INT 3
28822: PUSH
28823: LD_INT 1
28825: PUSH
28826: LD_INT 5
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: LD_INT 1
28834: PUSH
28835: LD_INT 4
28837: PUSH
28838: LD_INT 1
28840: PUSH
28841: LD_INT 0
28843: PUSH
28844: LD_INT 3
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: LIST
28873: LIST
28874: LIST
28875: LIST
28876: ST_TO_ADDR
// Randomize ;
28877: CALL_OW 10
// end ;
28881: END
// every 5 5$0 do
28882: GO 28884
28884: DISABLE
// begin Randomize ;
28885: CALL_OW 10
// enable ;
28889: ENABLE
// end ;
28890: END
// every 0 0$15 do
28891: GO 28893
28893: DISABLE
// begin padaji_bedny ;
28894: CALL 28908 0 0
// end ;
28898: END
// every 5 5$0 + 0 0$15 do
28899: GO 28901
28901: DISABLE
// begin padaji_bedny ;
28902: CALL 28908 0 0
// enable ;
28906: ENABLE
// end ;
28907: END
// function padaji_bedny ; var x , i , cek , cek2 , last , min5 ; begin
28908: LD_INT 0
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
// min5 := ( ( tick div 5 5$0 ) + 1 ) mod objevovani_zasilek ;
28917: LD_ADDR_VAR 0 7
28921: PUSH
28922: LD_OWVAR 1
28926: PUSH
28927: LD_INT 10500
28929: DIV
28930: PUSH
28931: LD_INT 1
28933: PLUS
28934: PUSH
28935: LD_LOC 30
28939: MOD
28940: ST_TO_ADDR
// cek := [ ] ;
28941: LD_ADDR_VAR 0 4
28945: PUSH
28946: EMPTY
28947: ST_TO_ADDR
// cek2 := [ ] ;
28948: LD_ADDR_VAR 0 5
28952: PUSH
28953: EMPTY
28954: ST_TO_ADDR
// last := 0 ;
28955: LD_ADDR_VAR 0 6
28959: PUSH
28960: LD_INT 0
28962: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
28963: LD_ADDR_VAR 0 2
28967: PUSH
28968: LD_LOC 30
28972: PUSH
28973: LD_VAR 0 7
28977: ARRAY
28978: ST_TO_ADDR
// for i := 1 to x do
28979: LD_ADDR_VAR 0 3
28983: PUSH
28984: DOUBLE
28985: LD_INT 1
28987: DEC
28988: ST_TO_ADDR
28989: LD_VAR 0 2
28993: PUSH
28994: FOR_TO
28995: IFFALSE 29021
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
28997: LD_ADDR_VAR 0 4
29001: PUSH
29002: LD_VAR 0 4
29006: PUSH
29007: LD_INT 525
29009: PPUSH
29010: LD_INT 10500
29012: PPUSH
29013: CALL_OW 12
29017: ADD
29018: ST_TO_ADDR
29019: GO 28994
29021: POP
29022: POP
// cek := SortListByListAsc ( cek , cek ) ;
29023: LD_ADDR_VAR 0 4
29027: PUSH
29028: LD_VAR 0 4
29032: PPUSH
29033: LD_VAR 0 4
29037: PPUSH
29038: CALL_OW 76
29042: ST_TO_ADDR
// for i in cek do
29043: LD_ADDR_VAR 0 3
29047: PUSH
29048: LD_VAR 0 4
29052: PUSH
29053: FOR_IN
29054: IFFALSE 29090
// begin cek2 := cek2 ^ i - last ;
29056: LD_ADDR_VAR 0 5
29060: PUSH
29061: LD_VAR 0 5
29065: PUSH
29066: LD_VAR 0 3
29070: PUSH
29071: LD_VAR 0 6
29075: MINUS
29076: ADD
29077: ST_TO_ADDR
// last := i ;
29078: LD_ADDR_VAR 0 6
29082: PUSH
29083: LD_VAR 0 3
29087: ST_TO_ADDR
// end ;
29088: GO 29053
29090: POP
29091: POP
// for i := 1 to x do
29092: LD_ADDR_VAR 0 3
29096: PUSH
29097: DOUBLE
29098: LD_INT 1
29100: DEC
29101: ST_TO_ADDR
29102: LD_VAR 0 2
29106: PUSH
29107: FOR_TO
29108: IFFALSE 29137
// begin CreateCratesAnywhere ( 5 , true ) ;
29110: LD_INT 5
29112: PPUSH
29113: LD_INT 1
29115: PPUSH
29116: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
29120: LD_VAR 0 5
29124: PUSH
29125: LD_VAR 0 3
29129: ARRAY
29130: PPUSH
29131: CALL_OW 67
// end ;
29135: GO 29107
29137: POP
29138: POP
// end ; end_of_file
29139: LD_VAR 0 1
29143: RET
// var rDef1 , rDef2 , rDef3 , rDef4 , rDef5 ; var idDef1 , idDef2 , idDef3 , idDef4 , idDef5 ; export toDef1 , toDef2 , toDef3 , toDef4 , toDef5 ; every 0 0$1 do
29144: GO 29146
29146: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29147: LD_ADDR_EXP 89
29151: PUSH
29152: LD_EXP 76
29156: PUSH
29157: LD_INT 1
29159: ARRAY
29160: PPUSH
29161: LD_EXP 51
29165: PUSH
29166: EMPTY
29167: LIST
29168: PPUSH
29169: CALL_OW 72
29173: PUSH
29174: LD_EXP 77
29178: PUSH
29179: LD_INT 1
29181: ARRAY
29182: ADD
29183: PUSH
29184: LD_EXP 75
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: LD_EXP 56
29197: PUSH
29198: EMPTY
29199: LIST
29200: PPUSH
29201: CALL_OW 72
29205: ADD
29206: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29207: LD_ADDR_EXP 90
29211: PUSH
29212: LD_EXP 76
29216: PUSH
29217: LD_INT 2
29219: ARRAY
29220: PPUSH
29221: LD_EXP 51
29225: PUSH
29226: EMPTY
29227: LIST
29228: PPUSH
29229: CALL_OW 72
29233: PUSH
29234: LD_EXP 77
29238: PUSH
29239: LD_INT 2
29241: ARRAY
29242: ADD
29243: PUSH
29244: LD_EXP 75
29248: PUSH
29249: LD_INT 2
29251: ARRAY
29252: PPUSH
29253: LD_EXP 56
29257: PUSH
29258: EMPTY
29259: LIST
29260: PPUSH
29261: CALL_OW 72
29265: ADD
29266: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29267: LD_ADDR_EXP 91
29271: PUSH
29272: LD_EXP 76
29276: PUSH
29277: LD_INT 3
29279: ARRAY
29280: PPUSH
29281: LD_EXP 51
29285: PUSH
29286: EMPTY
29287: LIST
29288: PPUSH
29289: CALL_OW 72
29293: PUSH
29294: LD_EXP 77
29298: PUSH
29299: LD_INT 3
29301: ARRAY
29302: ADD
29303: PUSH
29304: LD_EXP 75
29308: PUSH
29309: LD_INT 3
29311: ARRAY
29312: PPUSH
29313: LD_EXP 56
29317: PUSH
29318: EMPTY
29319: LIST
29320: PPUSH
29321: CALL_OW 72
29325: ADD
29326: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
29327: LD_ADDR_EXP 92
29331: PUSH
29332: LD_EXP 76
29336: PUSH
29337: LD_INT 4
29339: ARRAY
29340: PPUSH
29341: LD_EXP 51
29345: PUSH
29346: EMPTY
29347: LIST
29348: PPUSH
29349: CALL_OW 72
29353: PUSH
29354: LD_EXP 77
29358: PUSH
29359: LD_INT 4
29361: ARRAY
29362: ADD
29363: PUSH
29364: LD_EXP 75
29368: PUSH
29369: LD_INT 4
29371: ARRAY
29372: PPUSH
29373: LD_EXP 56
29377: PUSH
29378: EMPTY
29379: LIST
29380: PPUSH
29381: CALL_OW 72
29385: ADD
29386: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
29387: LD_ADDR_EXP 93
29391: PUSH
29392: LD_EXP 76
29396: PUSH
29397: LD_INT 5
29399: ARRAY
29400: PPUSH
29401: LD_EXP 51
29405: PUSH
29406: EMPTY
29407: LIST
29408: PPUSH
29409: CALL_OW 72
29413: PUSH
29414: LD_EXP 77
29418: PUSH
29419: LD_INT 5
29421: ARRAY
29422: ADD
29423: PUSH
29424: LD_EXP 75
29428: PUSH
29429: LD_INT 5
29431: ARRAY
29432: PPUSH
29433: LD_EXP 56
29437: PUSH
29438: EMPTY
29439: LIST
29440: PPUSH
29441: CALL_OW 72
29445: ADD
29446: ST_TO_ADDR
// rDef1 := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearA ] , [ mc_reg_area_to_protect , nearA ] ] ) ;
29447: LD_ADDR_LOC 31
29451: PUSH
29452: LD_EXP 23
29456: PUSH
29457: LD_INT 1
29459: ARRAY
29460: PPUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 70
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 2
29473: PUSH
29474: LD_INT 24
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 3
29483: PUSH
29484: LD_INT 24
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: LIST
29495: PPUSH
29496: CALL_OW 399
29500: ST_TO_ADDR
// rDef2 := McRegistry ( ai_s [ 2 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearB ] , [ mc_reg_area_to_protect , nearB ] ] ) ;
29501: LD_ADDR_LOC 32
29505: PUSH
29506: LD_EXP 23
29510: PUSH
29511: LD_INT 2
29513: ARRAY
29514: PPUSH
29515: LD_INT 1
29517: PUSH
29518: LD_INT 70
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: LD_INT 25
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 3
29537: PUSH
29538: LD_INT 25
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: LIST
29549: PPUSH
29550: CALL_OW 399
29554: ST_TO_ADDR
// rDef3 := McRegistry ( ai_s [ 3 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearC ] , [ mc_reg_area_to_protect , nearC ] ] ) ;
29555: LD_ADDR_LOC 33
29559: PUSH
29560: LD_EXP 23
29564: PUSH
29565: LD_INT 3
29567: ARRAY
29568: PPUSH
29569: LD_INT 1
29571: PUSH
29572: LD_INT 70
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: LD_INT 26
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: LD_INT 3
29591: PUSH
29592: LD_INT 26
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: LIST
29603: PPUSH
29604: CALL_OW 399
29608: ST_TO_ADDR
// rDef4 := McRegistry ( ai_s [ 4 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearD ] , [ mc_reg_area_to_protect , nearD ] ] ) ;
29609: LD_ADDR_LOC 34
29613: PUSH
29614: LD_EXP 23
29618: PUSH
29619: LD_INT 4
29621: ARRAY
29622: PPUSH
29623: LD_INT 1
29625: PUSH
29626: LD_INT 70
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 2
29635: PUSH
29636: LD_INT 27
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 3
29645: PUSH
29646: LD_INT 27
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 399
29662: ST_TO_ADDR
// rDef5 := McRegistry ( ai_s [ 5 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearE ] , [ mc_reg_area_to_protect , nearE ] ] ) ;
29663: LD_ADDR_LOC 35
29667: PUSH
29668: LD_EXP 23
29672: PUSH
29673: LD_INT 5
29675: ARRAY
29676: PPUSH
29677: LD_INT 1
29679: PUSH
29680: LD_INT 70
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: LD_INT 28
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 3
29699: PUSH
29700: LD_INT 28
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: LIST
29711: PPUSH
29712: CALL_OW 399
29716: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef1_difficulty ] ) ;
29717: LD_ADDR_LOC 36
29721: PUSH
29722: LD_INT 10
29724: PPUSH
29725: LD_LOC 31
29729: PPUSH
29730: LD_EXP 89
29734: PPUSH
29735: LD_INT 1
29737: PUSH
29738: LD_EXP 11
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PPUSH
29747: CALL_OW 401
29751: ST_TO_ADDR
// idDef2 := McDefend ( 10 , rDef2 , toDef2 , [ mc_def_advantage , mcdef2_difficulty ] ) ;
29752: LD_ADDR_LOC 37
29756: PUSH
29757: LD_INT 10
29759: PPUSH
29760: LD_LOC 32
29764: PPUSH
29765: LD_EXP 90
29769: PPUSH
29770: LD_INT 1
29772: PUSH
29773: LD_EXP 12
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PPUSH
29782: CALL_OW 401
29786: ST_TO_ADDR
// idDef3 := McDefend ( 10 , rDef3 , toDef3 , [ mc_def_advantage , mcdef3_difficulty ] ) ;
29787: LD_ADDR_LOC 38
29791: PUSH
29792: LD_INT 10
29794: PPUSH
29795: LD_LOC 33
29799: PPUSH
29800: LD_EXP 91
29804: PPUSH
29805: LD_INT 1
29807: PUSH
29808: LD_EXP 13
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PPUSH
29817: CALL_OW 401
29821: ST_TO_ADDR
// idDef4 := McDefend ( 10 , rDef4 , toDef4 , [ mc_def_advantage , mcdef4_difficulty ] ) ;
29822: LD_ADDR_LOC 39
29826: PUSH
29827: LD_INT 10
29829: PPUSH
29830: LD_LOC 34
29834: PPUSH
29835: LD_EXP 92
29839: PPUSH
29840: LD_INT 1
29842: PUSH
29843: LD_EXP 14
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PPUSH
29852: CALL_OW 401
29856: ST_TO_ADDR
// idDef5 := McDefend ( 10 , rDef5 , toDef5 , [ mc_def_advantage , mcdef5_difficulty ] ) ;
29857: LD_ADDR_LOC 40
29861: PUSH
29862: LD_INT 10
29864: PPUSH
29865: LD_LOC 35
29869: PPUSH
29870: LD_EXP 93
29874: PPUSH
29875: LD_INT 1
29877: PUSH
29878: LD_EXP 15
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PPUSH
29887: CALL_OW 401
29891: ST_TO_ADDR
// end ;
29892: END
// every 0 0$10 do
29893: GO 29895
29895: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29896: LD_ADDR_EXP 89
29900: PUSH
29901: LD_EXP 76
29905: PUSH
29906: LD_INT 1
29908: ARRAY
29909: PPUSH
29910: LD_EXP 51
29914: PUSH
29915: EMPTY
29916: LIST
29917: PPUSH
29918: CALL_OW 72
29922: PUSH
29923: LD_EXP 77
29927: PUSH
29928: LD_INT 1
29930: ARRAY
29931: ADD
29932: PUSH
29933: LD_EXP 75
29937: PUSH
29938: LD_INT 1
29940: ARRAY
29941: PPUSH
29942: LD_EXP 56
29946: PUSH
29947: EMPTY
29948: LIST
29949: PPUSH
29950: CALL_OW 72
29954: ADD
29955: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29956: LD_ADDR_EXP 90
29960: PUSH
29961: LD_EXP 76
29965: PUSH
29966: LD_INT 2
29968: ARRAY
29969: PPUSH
29970: LD_EXP 51
29974: PUSH
29975: EMPTY
29976: LIST
29977: PPUSH
29978: CALL_OW 72
29982: PUSH
29983: LD_EXP 77
29987: PUSH
29988: LD_INT 2
29990: ARRAY
29991: ADD
29992: PUSH
29993: LD_EXP 75
29997: PUSH
29998: LD_INT 2
30000: ARRAY
30001: PPUSH
30002: LD_EXP 56
30006: PUSH
30007: EMPTY
30008: LIST
30009: PPUSH
30010: CALL_OW 72
30014: ADD
30015: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
30016: LD_ADDR_EXP 91
30020: PUSH
30021: LD_EXP 76
30025: PUSH
30026: LD_INT 3
30028: ARRAY
30029: PPUSH
30030: LD_EXP 51
30034: PUSH
30035: EMPTY
30036: LIST
30037: PPUSH
30038: CALL_OW 72
30042: PUSH
30043: LD_EXP 77
30047: PUSH
30048: LD_INT 3
30050: ARRAY
30051: ADD
30052: PUSH
30053: LD_EXP 75
30057: PUSH
30058: LD_INT 3
30060: ARRAY
30061: PPUSH
30062: LD_EXP 56
30066: PUSH
30067: EMPTY
30068: LIST
30069: PPUSH
30070: CALL_OW 72
30074: ADD
30075: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
30076: LD_ADDR_EXP 92
30080: PUSH
30081: LD_EXP 76
30085: PUSH
30086: LD_INT 4
30088: ARRAY
30089: PPUSH
30090: LD_EXP 51
30094: PUSH
30095: EMPTY
30096: LIST
30097: PPUSH
30098: CALL_OW 72
30102: PUSH
30103: LD_EXP 77
30107: PUSH
30108: LD_INT 4
30110: ARRAY
30111: ADD
30112: PUSH
30113: LD_EXP 75
30117: PUSH
30118: LD_INT 4
30120: ARRAY
30121: PPUSH
30122: LD_EXP 56
30126: PUSH
30127: EMPTY
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ADD
30135: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
30136: LD_ADDR_EXP 93
30140: PUSH
30141: LD_EXP 76
30145: PUSH
30146: LD_INT 5
30148: ARRAY
30149: PPUSH
30150: LD_EXP 51
30154: PUSH
30155: EMPTY
30156: LIST
30157: PPUSH
30158: CALL_OW 72
30162: PUSH
30163: LD_EXP 77
30167: PUSH
30168: LD_INT 5
30170: ARRAY
30171: ADD
30172: PUSH
30173: LD_EXP 75
30177: PUSH
30178: LD_INT 5
30180: ARRAY
30181: PPUSH
30182: LD_EXP 56
30186: PUSH
30187: EMPTY
30188: LIST
30189: PPUSH
30190: CALL_OW 72
30194: ADD
30195: ST_TO_ADDR
// ClearMcUnits ( idDef1 ) ;
30196: LD_LOC 36
30200: PPUSH
30201: CALL_OW 392
// AddMcUnits ( idDef1 , todef1 ) ;
30205: LD_LOC 36
30209: PPUSH
30210: LD_EXP 89
30214: PPUSH
30215: CALL_OW 390
// ClearMcUnits ( idDef2 ) ;
30219: LD_LOC 37
30223: PPUSH
30224: CALL_OW 392
// AddMcUnits ( idDef2 , todef2 ) ;
30228: LD_LOC 37
30232: PPUSH
30233: LD_EXP 90
30237: PPUSH
30238: CALL_OW 390
// ClearMcUnits ( idDef3 ) ;
30242: LD_LOC 38
30246: PPUSH
30247: CALL_OW 392
// AddMcUnits ( idDef3 , todef3 ) ;
30251: LD_LOC 38
30255: PPUSH
30256: LD_EXP 91
30260: PPUSH
30261: CALL_OW 390
// ClearMcUnits ( idDef4 ) ;
30265: LD_LOC 39
30269: PPUSH
30270: CALL_OW 392
// AddMcUnits ( idDef4 , todef4 ) ;
30274: LD_LOC 39
30278: PPUSH
30279: LD_EXP 92
30283: PPUSH
30284: CALL_OW 390
// ClearMcUnits ( idDef5 ) ;
30288: LD_LOC 40
30292: PPUSH
30293: CALL_OW 392
// AddMcUnits ( idDef5 , todef5 ) ;
30297: LD_LOC 40
30301: PPUSH
30302: LD_EXP 93
30306: PPUSH
30307: CALL_OW 390
// enable ;
30311: ENABLE
// end ; end_of_file
30312: END
// export function SurrenderBase ( type , side ) ; var a , cars ; begin
30313: LD_INT 0
30315: PPUSH
30316: PPUSH
30317: PPUSH
// if not ( side in your_bases ) then
30318: LD_VAR 0 2
30322: PUSH
30323: LD_EXP 18
30327: IN
30328: NOT
30329: IFFALSE 30943
// begin SetAttitude ( you , side , att_friend , true ) ;
30331: LD_EXP 7
30335: PPUSH
30336: LD_VAR 0 2
30340: PPUSH
30341: LD_INT 1
30343: PPUSH
30344: LD_INT 1
30346: PPUSH
30347: CALL_OW 80
// case type of t_kill :
30351: LD_VAR 0 1
30355: PUSH
30356: LD_EXP 1
30360: DOUBLE
30361: EQUAL
30362: IFTRUE 30366
30364: GO 30437
30366: POP
// begin if side = ai_s [ 1 ] then
30367: LD_VAR 0 2
30371: PUSH
30372: LD_EXP 23
30376: PUSH
30377: LD_INT 1
30379: ARRAY
30380: EQUAL
30381: IFFALSE 30406
// begin DXbaseSurrender ( side ) ;
30383: LD_VAR 0 2
30387: PPUSH
30388: CALL 7909 0 1
// SurrenderNormal ( true , side ) ;
30392: LD_INT 1
30394: PPUSH
30395: LD_VAR 0 2
30399: PPUSH
30400: CALL 30948 0 2
// end else
30404: GO 30435
// begin diplomacy := false ;
30406: LD_ADDR_EXP 27
30410: PUSH
30411: LD_INT 0
30413: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30414: LD_VAR 0 2
30418: PPUSH
30419: CALL 7909 0 1
// SurrenderNormal ( true , side ) ;
30423: LD_INT 1
30425: PPUSH
30426: LD_VAR 0 2
30430: PPUSH
30431: CALL 30948 0 2
// end ; end ; t_killbeat :
30435: GO 30775
30437: LD_EXP 6
30441: DOUBLE
30442: EQUAL
30443: IFTRUE 30447
30445: GO 30518
30447: POP
// begin if side = ai_s [ 1 ] then
30448: LD_VAR 0 2
30452: PUSH
30453: LD_EXP 23
30457: PUSH
30458: LD_INT 1
30460: ARRAY
30461: EQUAL
30462: IFFALSE 30487
// begin DXbaseSurrender ( side ) ;
30464: LD_VAR 0 2
30468: PPUSH
30469: CALL 7909 0 1
// SurrenderNormal ( true , side ) ;
30473: LD_INT 1
30475: PPUSH
30476: LD_VAR 0 2
30480: PPUSH
30481: CALL 30948 0 2
// end else
30485: GO 30516
// begin diplomacy := false ;
30487: LD_ADDR_EXP 27
30491: PUSH
30492: LD_INT 0
30494: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30495: LD_VAR 0 2
30499: PPUSH
30500: CALL 7909 0 1
// SurrenderNormal ( true , side ) ;
30504: LD_INT 1
30506: PPUSH
30507: LD_VAR 0 2
30511: PPUSH
30512: CALL 30948 0 2
// end ; end ; t_intimidate :
30516: GO 30775
30518: LD_EXP 2
30522: DOUBLE
30523: EQUAL
30524: IFTRUE 30528
30526: GO 30582
30528: POP
// begin if side = ai_s [ 2 ] then
30529: LD_VAR 0 2
30533: PUSH
30534: LD_EXP 23
30538: PUSH
30539: LD_INT 2
30541: ARRAY
30542: EQUAL
30543: IFFALSE 30580
// begin DB_BaseAccept ( cap_bases = 0 ) ;
30545: LD_EXP 17
30549: PUSH
30550: LD_INT 0
30552: EQUAL
30553: PPUSH
30554: CALL 4568 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 2 ] ) ;
30558: LD_EXP 17
30562: PUSH
30563: LD_INT 0
30565: EQUAL
30566: PPUSH
30567: LD_EXP 23
30571: PUSH
30572: LD_INT 2
30574: ARRAY
30575: PPUSH
30576: CALL 30948 0 2
// end ; end ; t_persuade :
30580: GO 30775
30582: LD_EXP 3
30586: DOUBLE
30587: EQUAL
30588: IFTRUE 30592
30590: GO 30646
30592: POP
// begin if side = ai_s [ 3 ] then
30593: LD_VAR 0 2
30597: PUSH
30598: LD_EXP 23
30602: PUSH
30603: LD_INT 3
30605: ARRAY
30606: EQUAL
30607: IFFALSE 30644
// begin DQrML_Right ( cap_bases = 0 ) ;
30609: LD_EXP 17
30613: PUSH
30614: LD_INT 0
30616: EQUAL
30617: PPUSH
30618: CALL 6732 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 3 ] ) ;
30622: LD_EXP 17
30626: PUSH
30627: LD_INT 0
30629: EQUAL
30630: PPUSH
30631: LD_EXP 23
30635: PUSH
30636: LD_INT 3
30638: ARRAY
30639: PPUSH
30640: CALL 30948 0 2
// end ; end ; t_pay :
30644: GO 30775
30646: LD_EXP 4
30650: DOUBLE
30651: EQUAL
30652: IFTRUE 30656
30654: GO 30710
30656: POP
// begin if side = ai_s [ 4 ] then
30657: LD_VAR 0 2
30661: PUSH
30662: LD_EXP 23
30666: PUSH
30667: LD_INT 4
30669: ARRAY
30670: EQUAL
30671: IFFALSE 30708
// begin DD_BaseAccept ( cap_bases = 0 ) ;
30673: LD_EXP 17
30677: PUSH
30678: LD_INT 0
30680: EQUAL
30681: PPUSH
30682: CALL 7296 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 4 ] ) ;
30686: LD_EXP 17
30690: PUSH
30691: LD_INT 0
30693: EQUAL
30694: PPUSH
30695: LD_EXP 23
30699: PUSH
30700: LD_INT 4
30702: ARRAY
30703: PPUSH
30704: CALL 30948 0 2
// end ; end ; t_beat :
30708: GO 30775
30710: LD_EXP 5
30714: DOUBLE
30715: EQUAL
30716: IFTRUE 30720
30718: GO 30774
30720: POP
// begin if side = ai_s [ 5 ] then
30721: LD_VAR 0 2
30725: PUSH
30726: LD_EXP 23
30730: PUSH
30731: LD_INT 5
30733: ARRAY
30734: EQUAL
30735: IFFALSE 30772
// begin DE_BaseAccept ( cap_bases = 0 ) ;
30737: LD_EXP 17
30741: PUSH
30742: LD_INT 0
30744: EQUAL
30745: PPUSH
30746: CALL 7849 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 5 ] ) ;
30750: LD_EXP 17
30754: PUSH
30755: LD_INT 0
30757: EQUAL
30758: PPUSH
30759: LD_EXP 23
30763: PUSH
30764: LD_INT 5
30766: ARRAY
30767: PPUSH
30768: CALL 30948 0 2
// end ; end ; end ;
30772: GO 30775
30774: POP
// your_humans := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
30775: LD_ADDR_EXP 37
30779: PUSH
30780: LD_INT 22
30782: PUSH
30783: LD_EXP 7
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 21
30794: PUSH
30795: LD_INT 1
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PPUSH
30806: CALL_OW 69
30810: ST_TO_ADDR
// your_builds := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
30811: LD_ADDR_EXP 36
30815: PUSH
30816: LD_INT 22
30818: PUSH
30819: LD_EXP 7
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: LD_INT 21
30830: PUSH
30831: LD_INT 3
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PPUSH
30842: CALL_OW 69
30846: ST_TO_ADDR
// your_cars := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
30847: LD_ADDR_EXP 35
30851: PUSH
30852: LD_INT 22
30854: PUSH
30855: LD_EXP 7
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 21
30866: PUSH
30867: LD_INT 2
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PPUSH
30878: CALL_OW 69
30882: ST_TO_ADDR
// remove_from_humans ( your_humans ) ;
30883: LD_EXP 37
30887: PPUSH
30888: CALL 27981 0 1
// remove_from_builds ( your_builds ) ;
30892: LD_EXP 36
30896: PPUSH
30897: CALL 27735 0 1
// remove_from_vehicles ( your_cars ) ;
30901: LD_EXP 35
30905: PPUSH
30906: CALL 28219 0 1
// cap_bases := cap_bases + 1 ;
30910: LD_ADDR_EXP 17
30914: PUSH
30915: LD_EXP 17
30919: PUSH
30920: LD_INT 1
30922: PLUS
30923: ST_TO_ADDR
// your_bases := your_bases ^ [ side ] ;
30924: LD_ADDR_EXP 18
30928: PUSH
30929: LD_EXP 18
30933: PUSH
30934: LD_VAR 0 2
30938: PUSH
30939: EMPTY
30940: LIST
30941: ADD
30942: ST_TO_ADDR
// end ; end ;
30943: LD_VAR 0 3
30947: RET
// function SurrenderNormal ( first , side ) ; var yours , take , theirs , i , max , t_sci , t_lab ; begin
30948: LD_INT 0
30950: PPUSH
30951: PPUSH
30952: PPUSH
30953: PPUSH
30954: PPUSH
30955: PPUSH
30956: PPUSH
30957: PPUSH
// yours := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
30958: LD_ADDR_VAR 0 4
30962: PUSH
30963: LD_INT 22
30965: PUSH
30966: LD_EXP 7
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 21
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 23
30987: PUSH
30988: LD_INT 3
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: LIST
30999: PPUSH
31000: CALL_OW 69
31004: ST_TO_ADDR
// theirs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31005: LD_ADDR_VAR 0 6
31009: PUSH
31010: LD_INT 22
31012: PUSH
31013: LD_VAR 0 2
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 21
31024: PUSH
31025: LD_INT 1
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 23
31034: PUSH
31035: LD_INT 3
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: LIST
31046: PPUSH
31047: CALL_OW 69
31051: ST_TO_ADDR
// for i in theirs do
31052: LD_ADDR_VAR 0 7
31056: PUSH
31057: LD_VAR 0 6
31061: PUSH
31062: FOR_IN
31063: IFFALSE 31098
// if GetLives ( i ) < hranice_umirani then
31065: LD_VAR 0 7
31069: PPUSH
31070: CALL_OW 256
31074: PUSH
31075: LD_INT 250
31077: LESS
31078: IFFALSE 31096
// SetLives ( i , hranice_umirani + 50 ) ;
31080: LD_VAR 0 7
31084: PPUSH
31085: LD_INT 250
31087: PUSH
31088: LD_INT 50
31090: PLUS
31091: PPUSH
31092: CALL_OW 234
31096: GO 31062
31098: POP
31099: POP
// InGameOn ;
31100: CALL_OW 8
// while UnitFilter ( theirs , [ [ f_inside ] ] ) diff hlavouni do
31104: LD_VAR 0 6
31108: PPUSH
31109: LD_INT 54
31111: PUSH
31112: EMPTY
31113: LIST
31114: PUSH
31115: EMPTY
31116: LIST
31117: PPUSH
31118: CALL_OW 72
31122: PUSH
31123: LD_EXP 72
31127: DIFF
31128: IFFALSE 31157
// begin ComExitBuilding ( theirs ) ;
31130: LD_VAR 0 6
31134: PPUSH
31135: CALL_OW 122
// AddComExitVehicle ( theirs ) ;
31139: LD_VAR 0 6
31143: PPUSH
31144: CALL_OW 181
// wait ( 0 0$2 ) ;
31148: LD_INT 70
31150: PPUSH
31151: CALL_OW 67
// end ;
31155: GO 31104
// InGameOff ;
31157: CALL_OW 9
// if first then
31161: LD_VAR 0 1
31165: IFFALSE 31831
// begin SetTech ( tech_SibLoc , you , state_researched ) ;
31167: LD_INT 19
31169: PPUSH
31170: LD_EXP 7
31174: PPUSH
31175: LD_INT 2
31177: PPUSH
31178: CALL_OW 322
// ai := ai diff side ;
31182: LD_ADDR_EXP 24
31186: PUSH
31187: LD_EXP 24
31191: PUSH
31192: LD_VAR 0 2
31196: DIFF
31197: ST_TO_ADDR
// case side of ai_s [ 1 ] :
31198: LD_VAR 0 2
31202: PUSH
31203: LD_EXP 23
31207: PUSH
31208: LD_INT 1
31210: ARRAY
31211: DOUBLE
31212: EQUAL
31213: IFTRUE 31217
31215: GO 31279
31217: POP
// begin SetSideBase_custom ( GetBase ( depots [ 1 ] ) , you ) ;
31218: LD_EXP 74
31222: PUSH
31223: LD_INT 1
31225: ARRAY
31226: PPUSH
31227: CALL_OW 274
31231: PPUSH
31232: LD_EXP 7
31236: PPUSH
31237: CALL 32718 0 2
// SetSide ( humans [ 1 ] , you ) ;
31241: LD_EXP 76
31245: PUSH
31246: LD_INT 1
31248: ARRAY
31249: PPUSH
31250: LD_EXP 7
31254: PPUSH
31255: CALL_OW 235
// SetSide ( vehicles [ 1 ] , you ) ;
31259: LD_EXP 77
31263: PUSH
31264: LD_INT 1
31266: ARRAY
31267: PPUSH
31268: LD_EXP 7
31272: PPUSH
31273: CALL_OW 235
// end ; ai_s [ 2 ] :
31277: GO 31829
31279: LD_EXP 23
31283: PUSH
31284: LD_INT 2
31286: ARRAY
31287: DOUBLE
31288: EQUAL
31289: IFTRUE 31293
31291: GO 31369
31293: POP
// begin SetSideBase_custom ( GetBase ( depots [ 2 ] ) , you ) ;
31294: LD_EXP 74
31298: PUSH
31299: LD_INT 2
31301: ARRAY
31302: PPUSH
31303: CALL_OW 274
31307: PPUSH
31308: LD_EXP 7
31312: PPUSH
31313: CALL 32718 0 2
// SetSide ( humans [ 2 ] , you ) ;
31317: LD_EXP 76
31321: PUSH
31322: LD_INT 2
31324: ARRAY
31325: PPUSH
31326: LD_EXP 7
31330: PPUSH
31331: CALL_OW 235
// SetSide ( vehicles [ 2 ] , you ) ;
31335: LD_EXP 77
31339: PUSH
31340: LD_INT 2
31342: ARRAY
31343: PPUSH
31344: LD_EXP 7
31348: PPUSH
31349: CALL_OW 235
// SetSide ( Borodin , you ) ;
31353: LD_EXP 46
31357: PPUSH
31358: LD_EXP 7
31362: PPUSH
31363: CALL_OW 235
// end ; ai_s [ 3 ] :
31367: GO 31829
31369: LD_EXP 23
31373: PUSH
31374: LD_INT 3
31376: ARRAY
31377: DOUBLE
31378: EQUAL
31379: IFTRUE 31383
31381: GO 31459
31383: POP
// begin SetSideBase_custom ( GetBase ( depots [ 3 ] ) , you ) ;
31384: LD_EXP 74
31388: PUSH
31389: LD_INT 3
31391: ARRAY
31392: PPUSH
31393: CALL_OW 274
31397: PPUSH
31398: LD_EXP 7
31402: PPUSH
31403: CALL 32718 0 2
// SetSide ( humans [ 3 ] , you ) ;
31407: LD_EXP 76
31411: PUSH
31412: LD_INT 3
31414: ARRAY
31415: PPUSH
31416: LD_EXP 7
31420: PPUSH
31421: CALL_OW 235
// SetSide ( vehicles [ 3 ] , you ) ;
31425: LD_EXP 77
31429: PUSH
31430: LD_INT 3
31432: ARRAY
31433: PPUSH
31434: LD_EXP 7
31438: PPUSH
31439: CALL_OW 235
// SetSide ( Tsaritsyn , you ) ;
31443: LD_EXP 47
31447: PPUSH
31448: LD_EXP 7
31452: PPUSH
31453: CALL_OW 235
// end ; ai_s [ 4 ] :
31457: GO 31829
31459: LD_EXP 23
31463: PUSH
31464: LD_INT 4
31466: ARRAY
31467: DOUBLE
31468: EQUAL
31469: IFTRUE 31473
31471: GO 31738
31473: POP
// begin t_sci := sci isect humans [ 4 ] ;
31474: LD_ADDR_VAR 0 9
31478: PUSH
31479: LD_EXP 88
31483: PUSH
31484: LD_EXP 76
31488: PUSH
31489: LD_INT 4
31491: ARRAY
31492: ISECT
31493: ST_TO_ADDR
// if t_sci > 3 then
31494: LD_VAR 0 9
31498: PUSH
31499: LD_INT 3
31501: GREATER
31502: IFFALSE 31538
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
31504: LD_ADDR_VAR 0 9
31508: PUSH
31509: LD_VAR 0 9
31513: PUSH
31514: LD_INT 1
31516: ARRAY
31517: PUSH
31518: LD_VAR 0 9
31522: PUSH
31523: LD_INT 2
31525: ARRAY
31526: ADD
31527: PUSH
31528: LD_VAR 0 9
31532: PUSH
31533: LD_INT 3
31535: ARRAY
31536: ADD
31537: ST_TO_ADDR
// t_lab := UnitFilter ( buildings [ 4 ] , [ mf_lab ] ) ;
31538: LD_ADDR_VAR 0 10
31542: PUSH
31543: LD_EXP 75
31547: PUSH
31548: LD_INT 4
31550: ARRAY
31551: PPUSH
31552: LD_EXP 55
31556: PUSH
31557: EMPTY
31558: LIST
31559: PPUSH
31560: CALL_OW 72
31564: ST_TO_ADDR
// for i in t_lab do
31565: LD_ADDR_VAR 0 7
31569: PUSH
31570: LD_VAR 0 10
31574: PUSH
31575: FOR_IN
31576: IFFALSE 31628
// if GetLabKind ( i , 1 ) = b_lab_spacetime or GetLabKind ( i , 2 ) = b_lab_spacetime then
31578: LD_VAR 0 7
31582: PPUSH
31583: LD_INT 1
31585: PPUSH
31586: CALL_OW 268
31590: PUSH
31591: LD_INT 14
31593: EQUAL
31594: PUSH
31595: LD_VAR 0 7
31599: PPUSH
31600: LD_INT 2
31602: PPUSH
31603: CALL_OW 268
31607: PUSH
31608: LD_INT 14
31610: EQUAL
31611: OR
31612: IFFALSE 31626
// begin t_lab := i ;
31614: LD_ADDR_VAR 0 10
31618: PUSH
31619: LD_VAR 0 7
31623: ST_TO_ADDR
// break ;
31624: GO 31628
// end ;
31626: GO 31575
31628: POP
31629: POP
// SetSideBase_custom ( GetBase ( depots [ 4 ] ) , you ) ;
31630: LD_EXP 74
31634: PUSH
31635: LD_INT 4
31637: ARRAY
31638: PPUSH
31639: CALL_OW 274
31643: PPUSH
31644: LD_EXP 7
31648: PPUSH
31649: CALL 32718 0 2
// SetSide ( humans [ 4 ] diff t_sci , you ) ;
31653: LD_EXP 76
31657: PUSH
31658: LD_INT 4
31660: ARRAY
31661: PUSH
31662: LD_VAR 0 9
31666: DIFF
31667: PPUSH
31668: LD_EXP 7
31672: PPUSH
31673: CALL_OW 235
// SetSide ( vehicles [ 4 ] , you ) ;
31677: LD_EXP 77
31681: PUSH
31682: LD_INT 4
31684: ARRAY
31685: PPUSH
31686: LD_EXP 7
31690: PPUSH
31691: CALL_OW 235
// SetSide ( t_lab , ai_s [ 4 ] ) ;
31695: LD_VAR 0 10
31699: PPUSH
31700: LD_EXP 23
31704: PUSH
31705: LD_INT 4
31707: ARRAY
31708: PPUSH
31709: CALL_OW 235
// ComEnterUnit ( t_sci ^ [ Davidov ] , t_lab ) ;
31713: LD_VAR 0 9
31717: PUSH
31718: LD_EXP 48
31722: PUSH
31723: EMPTY
31724: LIST
31725: ADD
31726: PPUSH
31727: LD_VAR 0 10
31731: PPUSH
31732: CALL_OW 120
// end ; ai_s [ 5 ] :
31736: GO 31829
31738: LD_EXP 23
31742: PUSH
31743: LD_INT 5
31745: ARRAY
31746: DOUBLE
31747: EQUAL
31748: IFTRUE 31752
31750: GO 31828
31752: POP
// begin SetSideBase_custom ( GetBase ( depots [ 5 ] ) , you ) ;
31753: LD_EXP 74
31757: PUSH
31758: LD_INT 5
31760: ARRAY
31761: PPUSH
31762: CALL_OW 274
31766: PPUSH
31767: LD_EXP 7
31771: PPUSH
31772: CALL 32718 0 2
// SetSide ( humans [ 5 ] , you ) ;
31776: LD_EXP 76
31780: PUSH
31781: LD_INT 5
31783: ARRAY
31784: PPUSH
31785: LD_EXP 7
31789: PPUSH
31790: CALL_OW 235
// SetSide ( vehicles [ 5 ] , you ) ;
31794: LD_EXP 77
31798: PUSH
31799: LD_INT 5
31801: ARRAY
31802: PPUSH
31803: LD_EXP 7
31807: PPUSH
31808: CALL_OW 235
// SetSide ( Eisenstein , you ) ;
31812: LD_EXP 49
31816: PPUSH
31817: LD_EXP 7
31821: PPUSH
31822: CALL_OW 235
// end ; end ;
31826: GO 31829
31828: POP
// end else
31829: GO 32628
// begin case side of ai_s [ 1 ] :
31831: LD_VAR 0 2
31835: PUSH
31836: LD_EXP 23
31840: PUSH
31841: LD_INT 1
31843: ARRAY
31844: DOUBLE
31845: EQUAL
31846: IFTRUE 31850
31848: GO 31887
31850: POP
// take := humans [ 1 ] ^ buildings [ 1 ] ^ vehicles [ 1 ] ; ai_s [ 2 ] :
31851: LD_ADDR_VAR 0 5
31855: PUSH
31856: LD_EXP 76
31860: PUSH
31861: LD_INT 1
31863: ARRAY
31864: PUSH
31865: LD_EXP 75
31869: PUSH
31870: LD_INT 1
31872: ARRAY
31873: ADD
31874: PUSH
31875: LD_EXP 77
31879: PUSH
31880: LD_INT 1
31882: ARRAY
31883: ADD
31884: ST_TO_ADDR
31885: GO 32628
31887: LD_EXP 23
31891: PUSH
31892: LD_INT 2
31894: ARRAY
31895: DOUBLE
31896: EQUAL
31897: IFTRUE 31901
31899: GO 32053
31901: POP
// begin if humans [ 2 ] < 3 then
31902: LD_EXP 76
31906: PUSH
31907: LD_INT 2
31909: ARRAY
31910: PUSH
31911: LD_INT 3
31913: LESS
31914: IFFALSE 31926
// max := 1 else
31916: LD_ADDR_VAR 0 8
31920: PUSH
31921: LD_INT 1
31923: ST_TO_ADDR
31924: GO 31944
// max := humans [ 2 ] - 2 ;
31926: LD_ADDR_VAR 0 8
31930: PUSH
31931: LD_EXP 76
31935: PUSH
31936: LD_INT 2
31938: ARRAY
31939: PUSH
31940: LD_INT 2
31942: MINUS
31943: ST_TO_ADDR
// if max > 5 then
31944: LD_VAR 0 8
31948: PUSH
31949: LD_INT 5
31951: GREATER
31952: IFFALSE 31962
// max := 5 ;
31954: LD_ADDR_VAR 0 8
31958: PUSH
31959: LD_INT 5
31961: ST_TO_ADDR
// take := CharacterSelection ( B-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 2 ] ^ [ sel_not_changeable ] ^ [ Borodin ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
31962: LD_ADDR_VAR 0 5
31966: PUSH
31967: LD_STRING B-Base
31969: PPUSH
31970: LD_INT 1
31972: PPUSH
31973: LD_VAR 0 8
31977: PPUSH
31978: LD_VAR 0 4
31982: PUSH
31983: LD_INT -2
31985: PUSH
31986: LD_INT -3
31988: PUSH
31989: LD_INT -6
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: LIST
31996: ADD
31997: PUSH
31998: LD_EXP 76
32002: PUSH
32003: LD_INT 2
32005: ARRAY
32006: ADD
32007: PUSH
32008: LD_INT -4
32010: PUSH
32011: EMPTY
32012: LIST
32013: ADD
32014: PUSH
32015: LD_EXP 46
32019: PUSH
32020: EMPTY
32021: LIST
32022: ADD
32023: PPUSH
32024: LD_INT 1
32026: PUSH
32027: LD_INT 3
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 4
32035: PUSH
32036: LD_INT 9
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 42
32050: ST_TO_ADDR
// end ; ai_s [ 3 ] :
32051: GO 32628
32053: LD_EXP 23
32057: PUSH
32058: LD_INT 3
32060: ARRAY
32061: DOUBLE
32062: EQUAL
32063: IFTRUE 32067
32065: GO 32219
32067: POP
// begin if humans [ 3 ] < 3 then
32068: LD_EXP 76
32072: PUSH
32073: LD_INT 3
32075: ARRAY
32076: PUSH
32077: LD_INT 3
32079: LESS
32080: IFFALSE 32092
// max := 1 else
32082: LD_ADDR_VAR 0 8
32086: PUSH
32087: LD_INT 1
32089: ST_TO_ADDR
32090: GO 32110
// max := humans [ 3 ] - 2 ;
32092: LD_ADDR_VAR 0 8
32096: PUSH
32097: LD_EXP 76
32101: PUSH
32102: LD_INT 3
32104: ARRAY
32105: PUSH
32106: LD_INT 2
32108: MINUS
32109: ST_TO_ADDR
// if max > 3 then
32110: LD_VAR 0 8
32114: PUSH
32115: LD_INT 3
32117: GREATER
32118: IFFALSE 32128
// max := 3 ;
32120: LD_ADDR_VAR 0 8
32124: PUSH
32125: LD_INT 3
32127: ST_TO_ADDR
// take := CharacterSelection ( C-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 3 ] ^ [ sel_not_changeable ] ^ [ Tsaritsyn ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32128: LD_ADDR_VAR 0 5
32132: PUSH
32133: LD_STRING C-Base
32135: PPUSH
32136: LD_INT 1
32138: PPUSH
32139: LD_VAR 0 8
32143: PPUSH
32144: LD_VAR 0 4
32148: PUSH
32149: LD_INT -2
32151: PUSH
32152: LD_INT -3
32154: PUSH
32155: LD_INT -6
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: LIST
32162: ADD
32163: PUSH
32164: LD_EXP 76
32168: PUSH
32169: LD_INT 3
32171: ARRAY
32172: ADD
32173: PUSH
32174: LD_INT -4
32176: PUSH
32177: EMPTY
32178: LIST
32179: ADD
32180: PUSH
32181: LD_EXP 47
32185: PUSH
32186: EMPTY
32187: LIST
32188: ADD
32189: PPUSH
32190: LD_INT 1
32192: PUSH
32193: LD_INT 3
32195: PUSH
32196: LD_INT 2
32198: PUSH
32199: LD_INT 4
32201: PUSH
32202: LD_INT 9
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: PPUSH
32212: CALL_OW 42
32216: ST_TO_ADDR
// end ; ai_s [ 4 ] :
32217: GO 32628
32219: LD_EXP 23
32223: PUSH
32224: LD_INT 4
32226: ARRAY
32227: DOUBLE
32228: EQUAL
32229: IFTRUE 32233
32231: GO 32461
32233: POP
// begin if humans [ 4 ] < 3 then
32234: LD_EXP 76
32238: PUSH
32239: LD_INT 4
32241: ARRAY
32242: PUSH
32243: LD_INT 3
32245: LESS
32246: IFFALSE 32258
// max := 1 else
32248: LD_ADDR_VAR 0 8
32252: PUSH
32253: LD_INT 1
32255: ST_TO_ADDR
32256: GO 32276
// max := humans [ 4 ] - 2 ;
32258: LD_ADDR_VAR 0 8
32262: PUSH
32263: LD_EXP 76
32267: PUSH
32268: LD_INT 4
32270: ARRAY
32271: PUSH
32272: LD_INT 2
32274: MINUS
32275: ST_TO_ADDR
// if max > 2 then
32276: LD_VAR 0 8
32280: PUSH
32281: LD_INT 2
32283: GREATER
32284: IFFALSE 32294
// max := 2 ;
32286: LD_ADDR_VAR 0 8
32290: PUSH
32291: LD_INT 2
32293: ST_TO_ADDR
// t_sci := sci isect humans [ 4 ] ;
32294: LD_ADDR_VAR 0 9
32298: PUSH
32299: LD_EXP 88
32303: PUSH
32304: LD_EXP 76
32308: PUSH
32309: LD_INT 4
32311: ARRAY
32312: ISECT
32313: ST_TO_ADDR
// if t_sci > 3 then
32314: LD_VAR 0 9
32318: PUSH
32319: LD_INT 3
32321: GREATER
32322: IFFALSE 32358
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
32324: LD_ADDR_VAR 0 9
32328: PUSH
32329: LD_VAR 0 9
32333: PUSH
32334: LD_INT 1
32336: ARRAY
32337: PUSH
32338: LD_VAR 0 9
32342: PUSH
32343: LD_INT 2
32345: ARRAY
32346: ADD
32347: PUSH
32348: LD_VAR 0 9
32352: PUSH
32353: LD_INT 3
32355: ARRAY
32356: ADD
32357: ST_TO_ADDR
// take := CharacterSelection ( D-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ ( humans [ 4 ] diff t_sci ) ^ [ sel_not_changeable ] ^ t_sci ^ [ Davidov ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32358: LD_ADDR_VAR 0 5
32362: PUSH
32363: LD_STRING D-Base
32365: PPUSH
32366: LD_INT 1
32368: PPUSH
32369: LD_VAR 0 8
32373: PPUSH
32374: LD_VAR 0 4
32378: PUSH
32379: LD_INT -2
32381: PUSH
32382: LD_INT -3
32384: PUSH
32385: LD_INT -6
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: LIST
32392: ADD
32393: PUSH
32394: LD_EXP 76
32398: PUSH
32399: LD_INT 4
32401: ARRAY
32402: PUSH
32403: LD_VAR 0 9
32407: DIFF
32408: ADD
32409: PUSH
32410: LD_INT -4
32412: PUSH
32413: EMPTY
32414: LIST
32415: ADD
32416: PUSH
32417: LD_VAR 0 9
32421: ADD
32422: PUSH
32423: LD_EXP 48
32427: PUSH
32428: EMPTY
32429: LIST
32430: ADD
32431: PPUSH
32432: LD_INT 1
32434: PUSH
32435: LD_INT 3
32437: PUSH
32438: LD_INT 2
32440: PUSH
32441: LD_INT 4
32443: PUSH
32444: LD_INT 9
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: PPUSH
32454: CALL_OW 42
32458: ST_TO_ADDR
// end ; ai_s [ 5 ] :
32459: GO 32628
32461: LD_EXP 23
32465: PUSH
32466: LD_INT 5
32468: ARRAY
32469: DOUBLE
32470: EQUAL
32471: IFTRUE 32475
32473: GO 32627
32475: POP
// begin if humans [ 5 ] < 3 then
32476: LD_EXP 76
32480: PUSH
32481: LD_INT 5
32483: ARRAY
32484: PUSH
32485: LD_INT 3
32487: LESS
32488: IFFALSE 32500
// max := 1 else
32490: LD_ADDR_VAR 0 8
32494: PUSH
32495: LD_INT 1
32497: ST_TO_ADDR
32498: GO 32518
// max := humans [ 5 ] - 2 ;
32500: LD_ADDR_VAR 0 8
32504: PUSH
32505: LD_EXP 76
32509: PUSH
32510: LD_INT 5
32512: ARRAY
32513: PUSH
32514: LD_INT 2
32516: MINUS
32517: ST_TO_ADDR
// if max > 5 then
32518: LD_VAR 0 8
32522: PUSH
32523: LD_INT 5
32525: GREATER
32526: IFFALSE 32536
// max := 5 ;
32528: LD_ADDR_VAR 0 8
32532: PUSH
32533: LD_INT 5
32535: ST_TO_ADDR
// take := CharacterSelection ( E-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 5 ] ^ [ sel_not_changeable ] ^ [ Eisenstein ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32536: LD_ADDR_VAR 0 5
32540: PUSH
32541: LD_STRING E-Base
32543: PPUSH
32544: LD_INT 1
32546: PPUSH
32547: LD_VAR 0 8
32551: PPUSH
32552: LD_VAR 0 4
32556: PUSH
32557: LD_INT -2
32559: PUSH
32560: LD_INT -3
32562: PUSH
32563: LD_INT -6
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: LIST
32570: ADD
32571: PUSH
32572: LD_EXP 76
32576: PUSH
32577: LD_INT 5
32579: ARRAY
32580: ADD
32581: PUSH
32582: LD_INT -4
32584: PUSH
32585: EMPTY
32586: LIST
32587: ADD
32588: PUSH
32589: LD_EXP 49
32593: PUSH
32594: EMPTY
32595: LIST
32596: ADD
32597: PPUSH
32598: LD_INT 1
32600: PUSH
32601: LD_INT 3
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: LD_INT 4
32609: PUSH
32610: LD_INT 9
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: PPUSH
32620: CALL_OW 42
32624: ST_TO_ADDR
// end ; end ;
32625: GO 32628
32627: POP
// end ; ComExitVehicle ( take ) ;
32628: LD_VAR 0 5
32632: PPUSH
32633: CALL_OW 121
// AddComExitBuilding ( take ) ;
32637: LD_VAR 0 5
32641: PPUSH
32642: CALL_OW 182
// take := take union FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) ;
32646: LD_ADDR_VAR 0 5
32650: PUSH
32651: LD_VAR 0 5
32655: PUSH
32656: LD_INT 22
32658: PUSH
32659: LD_VAR 0 2
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 21
32670: PUSH
32671: LD_INT 2
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 33
32680: PUSH
32681: LD_INT 1
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: LIST
32692: PPUSH
32693: CALL_OW 69
32697: UNION
32698: ST_TO_ADDR
// SetSide ( take , you ) ;
32699: LD_VAR 0 5
32703: PPUSH
32704: LD_EXP 7
32708: PPUSH
32709: CALL_OW 235
// end ;
32713: LD_VAR 0 3
32717: RET
// export function SetSideBase_custom ( base , side ) ; var b , depot , orig_side ; begin
32718: LD_INT 0
32720: PPUSH
32721: PPUSH
32722: PPUSH
32723: PPUSH
// depot = - 1 ;
32724: LD_ADDR_VAR 0 5
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
32733: LD_ADDR_VAR 0 4
32737: PUSH
32738: LD_INT 2
32740: PUSH
32741: LD_INT 30
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 30
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: PUSH
32766: EMPTY
32767: LIST
32768: PPUSH
32769: CALL_OW 69
32773: PUSH
32774: FOR_IN
32775: IFFALSE 32808
// if GetBase ( b ) = base then
32777: LD_VAR 0 4
32781: PPUSH
32782: CALL_OW 274
32786: PUSH
32787: LD_VAR 0 1
32791: EQUAL
32792: IFFALSE 32806
// begin depot = b ;
32794: LD_ADDR_VAR 0 5
32798: PUSH
32799: LD_VAR 0 4
32803: ST_TO_ADDR
// break ;
32804: GO 32808
// end ;
32806: GO 32774
32808: POP
32809: POP
// orig_side = GetSide ( depot ) ;
32810: LD_ADDR_VAR 0 6
32814: PUSH
32815: LD_VAR 0 5
32819: PPUSH
32820: CALL_OW 255
32824: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , orig_side ] , [ f_type , unit_building ] ] ) diff depot do
32825: LD_ADDR_VAR 0 4
32829: PUSH
32830: LD_INT 22
32832: PUSH
32833: LD_VAR 0 6
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 21
32844: PUSH
32845: LD_INT 3
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PPUSH
32856: CALL_OW 69
32860: PUSH
32861: LD_VAR 0 5
32865: DIFF
32866: PUSH
32867: FOR_IN
32868: IFFALSE 32903
// if GetBase ( b ) = base then
32870: LD_VAR 0 4
32874: PPUSH
32875: CALL_OW 274
32879: PUSH
32880: LD_VAR 0 1
32884: EQUAL
32885: IFFALSE 32901
// SetSide ( b , side ) ;
32887: LD_VAR 0 4
32891: PPUSH
32892: LD_VAR 0 2
32896: PPUSH
32897: CALL_OW 235
32901: GO 32867
32903: POP
32904: POP
// SetSide ( depot , side ) ;
32905: LD_VAR 0 5
32909: PPUSH
32910: LD_VAR 0 2
32914: PPUSH
32915: CALL_OW 235
// end ; end_of_file
32919: LD_VAR 0 3
32923: RET
// every 0 0$2 + 0 0$0.1 do
32924: GO 32926
32926: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
32927: LD_INT 22
32929: PUSH
32930: LD_INT 3
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 2
32939: PUSH
32940: LD_INT 25
32942: PUSH
32943: LD_INT 12
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 25
32952: PUSH
32953: LD_INT 16
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 25
32962: PUSH
32963: LD_INT 15
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 25
32972: PUSH
32973: LD_INT 17
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PPUSH
32991: CALL_OW 69
32995: PUSH
32996: LD_INT 22
32998: PUSH
32999: LD_INT 3
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 21
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 3
33018: PUSH
33019: LD_INT 2
33021: PUSH
33022: LD_INT 25
33024: PUSH
33025: LD_INT 12
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 25
33034: PUSH
33035: LD_INT 16
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 25
33044: PUSH
33045: LD_INT 15
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 25
33054: PUSH
33055: LD_INT 17
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: LIST
33077: PPUSH
33078: CALL_OW 69
33082: GREATER
33083: IFFALSE 33094
// begin SetAchievement ( ACH_POTA ) ;
33085: LD_STRING ACH_POTA
33087: PPUSH
33088: CALL_OW 543
// exit ;
33092: GO 33095
// end ; enable ;
33094: ENABLE
// end ;
33095: END
// export function SA_OnMissionStart ; begin
33096: LD_INT 0
33098: PPUSH
// SetAchievement ( ACH_RPAT ) ;
33099: LD_STRING ACH_RPAT
33101: PPUSH
33102: CALL_OW 543
// end ;
33106: LD_VAR 0 1
33110: RET
// export function SA_OnTsaritsynQuizPerfectCleared ; begin
33111: LD_INT 0
33113: PPUSH
// SetAchievement ( ACH_CAD ) ;
33114: LD_STRING ACH_CAD
33116: PPUSH
33117: CALL_OW 543
// end ;
33121: LD_VAR 0 1
33125: RET

// export t_kill , t_intimidate , t_persuade , t_pay , t_beat , t_killbeat ; export you , americans , arabians , nature ; export mcdef1_difficulty , mcdef2_difficulty , mcdef3_difficulty , mcdef4_difficulty , mcdef5_difficulty ; export gossudarov_mech_skill ; export cap_bases ; export your_bases ; export aiH , aiN , aiZ ; export ai_nation ; export ai_s ; export ai ; export plat_i ; export apemans ; export Diplomacy , Goss ; export BehemothSeen ; export vedci_zacali_zdrhat ; export run_sci ; export utek , utek_e ; export art_cargo1 ; export your_cars ; export your_builds ; export your_humans ; export function inicializace_main ; begin
   0: LD_INT 0
   2: PPUSH
// you := 3 ;
   3: LD_ADDR_EXP 7
   7: PUSH
   8: LD_INT 3
  10: ST_TO_ADDR
// americans := 1 ;
  11: LD_ADDR_EXP 8
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabians := 2 ;
  19: LD_ADDR_EXP 9
  23: PUSH
  24: LD_INT 2
  26: ST_TO_ADDR
// nature := 0 ;
  27: LD_ADDR_EXP 10
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// utek := [ [ 55 , 21 ] , [ 83 , 36 ] , [ 103 , 70 ] , [ 142 , 88 ] ] ;
  35: LD_ADDR_EXP 32
  39: PUSH
  40: LD_INT 55
  42: PUSH
  43: LD_INT 21
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: PUSH
  50: LD_INT 83
  52: PUSH
  53: LD_INT 36
  55: PUSH
  56: EMPTY
  57: LIST
  58: LIST
  59: PUSH
  60: LD_INT 103
  62: PUSH
  63: LD_INT 70
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: PUSH
  70: LD_INT 142
  72: PUSH
  73: LD_INT 88
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: PUSH
  80: EMPTY
  81: LIST
  82: LIST
  83: LIST
  84: LIST
  85: ST_TO_ADDR
// utek_e := [ 186 , 55 ] ;
  86: LD_ADDR_EXP 33
  90: PUSH
  91: LD_INT 186
  93: PUSH
  94: LD_INT 55
  96: PUSH
  97: EMPTY
  98: LIST
  99: LIST
 100: ST_TO_ADDR
// cap_bases := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// t_kill := 1 ;
 109: LD_ADDR_EXP 1
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// t_intimidate := 2 ;
 117: LD_ADDR_EXP 2
 121: PUSH
 122: LD_INT 2
 124: ST_TO_ADDR
// t_persuade := 3 ;
 125: LD_ADDR_EXP 3
 129: PUSH
 130: LD_INT 3
 132: ST_TO_ADDR
// t_pay := 4 ;
 133: LD_ADDR_EXP 4
 137: PUSH
 138: LD_INT 4
 140: ST_TO_ADDR
// t_beat := 5 ;
 141: LD_ADDR_EXP 5
 145: PUSH
 146: LD_INT 5
 148: ST_TO_ADDR
// t_killbeat := 10 ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 10
 156: ST_TO_ADDR
// Diplomacy := true ;
 157: LD_ADDR_EXP 27
 161: PUSH
 162: LD_INT 1
 164: ST_TO_ADDR
// Goss := true ;
 165: LD_ADDR_EXP 28
 169: PUSH
 170: LD_INT 1
 172: ST_TO_ADDR
// ai_s := [ 6 , 5 , 2 , 8 , 7 ] ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 6
 180: PUSH
 181: LD_INT 5
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: LD_INT 7
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// ai := [ 6 , 5 , 2 , 8 , 7 ] ;
 200: LD_ADDR_EXP 24
 204: PUSH
 205: LD_INT 6
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 2
 213: PUSH
 214: LD_INT 8
 216: PUSH
 217: LD_INT 7
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: ST_TO_ADDR
// plat_i := 1 ;
 227: LD_ADDR_EXP 25
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// aiH := [ ] ;
 235: LD_ADDR_EXP 19
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// aiN := [ ai_s [ 2 ] , ai_s [ 3 ] , ai_s [ 4 ] , ai_s [ 5 ] ] ;
 242: LD_ADDR_EXP 20
 246: PUSH
 247: LD_EXP 23
 251: PUSH
 252: LD_INT 2
 254: ARRAY
 255: PUSH
 256: LD_EXP 23
 260: PUSH
 261: LD_INT 3
 263: ARRAY
 264: PUSH
 265: LD_EXP 23
 269: PUSH
 270: LD_INT 4
 272: ARRAY
 273: PUSH
 274: LD_EXP 23
 278: PUSH
 279: LD_INT 5
 281: ARRAY
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: ST_TO_ADDR
// aiZ := [ ai_s [ 1 ] ] ;
 289: LD_ADDR_EXP 21
 293: PUSH
 294: LD_EXP 23
 298: PUSH
 299: LD_INT 1
 301: ARRAY
 302: PUSH
 303: EMPTY
 304: LIST
 305: ST_TO_ADDR
// your_bases := [ ] ;
 306: LD_ADDR_EXP 18
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// cap_bases := 0 ;
 313: LD_ADDR_EXP 17
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// art_cargo1 := art_cargo ;
 321: LD_ADDR_EXP 34
 325: PUSH
 326: LD_INT 121
 328: ST_TO_ADDR
// ai_nation := nation_russian ;
 329: LD_ADDR_EXP 22
 333: PUSH
 334: LD_INT 3
 336: ST_TO_ADDR
// debug_strings := [ [ ] , [ ] , [ ] ] ;
 337: LD_ADDR_OWVAR 48
 341: PUSH
 342: EMPTY
 343: PUSH
 344: EMPTY
 345: PUSH
 346: EMPTY
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: ST_TO_ADDR
// end ;
 353: LD_VAR 0 1
 357: RET
// export vyhrano ; export function VyhraPlaton ; begin
 358: LD_INT 0
 360: PPUSH
// if not vyhrano then
 361: LD_EXP 38
 365: NOT
 366: IFFALSE 497
// begin vyhrano := true ;
 368: LD_ADDR_EXP 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// cap_bases := 5 ;
 376: LD_ADDR_EXP 17
 380: PUSH
 381: LD_INT 5
 383: ST_TO_ADDR
// Query ( QEndInfo ) ;
 384: LD_STRING QEndInfo
 386: PPUSH
 387: CALL_OW 97
// ExclusiveOn ;
 391: CALL_OW 4
// wait ( 1 ) ;
 395: LD_INT 1
 397: PPUSH
 398: CALL_OW 67
// DEnd ;
 402: CALL 8124 0 0
// ExclusiveOff ;
 406: CALL_OW 5
// SetMedals ;
 410: CALL 502 0 0
// GiveMedals ( Platon ) ;
 414: LD_STRING Platon
 416: PPUSH
 417: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ) ;
 421: LD_INT 22
 423: PUSH
 424: LD_EXP 7
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 21
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 3
 445: PUSH
 446: LD_INT 23
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: PPUSH
 470: CALL_OW 43
// Save ;
 474: CALL 9119 0 0
// YouWin ;
 478: CALL_OW 103
// ExclusiveOn ;
 482: CALL_OW 4
// wait ( 1 ) ;
 486: LD_INT 1
 488: PPUSH
 489: CALL_OW 67
// ExclusiveOff ;
 493: CALL_OW 5
// end ; end ;
 497: LD_VAR 0 1
 501: RET
// export function SetMedals ; begin
 502: LD_INT 0
 504: PPUSH
// AddMedal ( All , cap_bases = 5 ) ;
 505: LD_STRING All
 507: PPUSH
 508: LD_EXP 17
 512: PUSH
 513: LD_INT 5
 515: EQUAL
 516: PPUSH
 517: CALL_OW 101
// AddMedal ( Diplomacy , Diplomacy ) ;
 521: LD_STRING Diplomacy
 523: PPUSH
 524: LD_EXP 27
 528: PPUSH
 529: CALL_OW 101
// AddMedal ( Goss , Goss ) ;
 533: LD_STRING Goss
 535: PPUSH
 536: LD_EXP 28
 540: PPUSH
 541: CALL_OW 101
// end ;
 545: LD_VAR 0 1
 549: RET
// export function LostBurlak ; begin
 550: LD_INT 0
 552: PPUSH
// YouLost ( Burlak ) ;
 553: LD_STRING Burlak
 555: PPUSH
 556: CALL_OW 104
// end ;
 560: LD_VAR 0 1
 564: RET
// export function LostArte ; begin
 565: LD_INT 0
 567: PPUSH
// YouLost ( Arte ) ;
 568: LD_STRING Arte
 570: PPUSH
 571: CALL_OW 104
// end ;
 575: LD_VAR 0 1
 579: RET
// export function set_difficulty ; begin
 580: LD_INT 0
 582: PPUSH
// mcdef1_difficulty := [ 200 , 230 , 260 ] [ difficulty ] ;
 583: LD_ADDR_EXP 11
 587: PUSH
 588: LD_INT 200
 590: PUSH
 591: LD_INT 230
 593: PUSH
 594: LD_INT 260
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PUSH
 602: LD_OWVAR 67
 606: ARRAY
 607: ST_TO_ADDR
// mcdef2_difficulty := [ 150 , 180 , 200 ] [ difficulty ] ;
 608: LD_ADDR_EXP 12
 612: PUSH
 613: LD_INT 150
 615: PUSH
 616: LD_INT 180
 618: PUSH
 619: LD_INT 200
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: PUSH
 627: LD_OWVAR 67
 631: ARRAY
 632: ST_TO_ADDR
// mcdef3_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 633: LD_ADDR_EXP 13
 637: PUSH
 638: LD_INT 170
 640: PUSH
 641: LD_INT 200
 643: PUSH
 644: LD_INT 230
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_OWVAR 67
 656: ARRAY
 657: ST_TO_ADDR
// mcdef4_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 658: LD_ADDR_EXP 14
 662: PUSH
 663: LD_INT 170
 665: PUSH
 666: LD_INT 200
 668: PUSH
 669: LD_INT 230
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_OWVAR 67
 681: ARRAY
 682: ST_TO_ADDR
// mcdef5_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 683: LD_ADDR_EXP 15
 687: PUSH
 688: LD_INT 170
 690: PUSH
 691: LD_INT 200
 693: PUSH
 694: LD_INT 230
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_OWVAR 67
 706: ARRAY
 707: ST_TO_ADDR
// gossudarov_mech_skill := [ 0 , 2 , 4 ] [ difficulty ] ;
 708: LD_ADDR_EXP 16
 712: PUSH
 713: LD_INT 0
 715: PUSH
 716: LD_INT 2
 718: PUSH
 719: LD_INT 4
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: ST_TO_ADDR
// end ;
 733: LD_VAR 0 1
 737: RET
// export function get_your_units ; var a ; begin
 738: LD_INT 0
 740: PPUSH
 741: PPUSH
// a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
 742: LD_ADDR_VAR 0 2
 746: PUSH
 747: LD_INT 22
 749: PUSH
 750: LD_EXP 7
 754: PUSH
 755: EMPTY
 756: LIST
 757: LIST
 758: PUSH
 759: EMPTY
 760: LIST
 761: PPUSH
 762: CALL_OW 69
 766: ST_TO_ADDR
// your_humans := UnitFilter ( a , [ [ f_type , unit_human ] ] ) ;
 767: LD_ADDR_EXP 37
 771: PUSH
 772: LD_VAR 0 2
 776: PPUSH
 777: LD_INT 21
 779: PUSH
 780: LD_INT 1
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: PUSH
 787: EMPTY
 788: LIST
 789: PPUSH
 790: CALL_OW 72
 794: ST_TO_ADDR
// your_cars := UnitFilter ( a , [ [ f_type , unit_vehicle ] ] ) ;
 795: LD_ADDR_EXP 35
 799: PUSH
 800: LD_VAR 0 2
 804: PPUSH
 805: LD_INT 21
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL_OW 72
 822: ST_TO_ADDR
// your_builds := UnitFilter ( a , [ [ f_type , unit_building ] ] ) ;
 823: LD_ADDR_EXP 36
 827: PUSH
 828: LD_VAR 0 2
 832: PPUSH
 833: LD_INT 21
 835: PUSH
 836: LD_INT 3
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: EMPTY
 844: LIST
 845: PPUSH
 846: CALL_OW 72
 850: ST_TO_ADDR
// end ;
 851: LD_VAR 0 1
 855: RET
// every 0 0$1 do var i ;
 856: GO 858
 858: DISABLE
 859: LD_INT 0
 861: PPUSH
// begin for i in ai do
 862: LD_ADDR_VAR 0 1
 866: PUSH
 867: LD_EXP 24
 871: PUSH
 872: FOR_IN
 873: IFFALSE 1070
// case GetAttitude ( i , you ) of att_friend :
 875: LD_VAR 0 1
 879: PPUSH
 880: LD_EXP 7
 884: PPUSH
 885: CALL_OW 81
 889: PUSH
 890: LD_INT 1
 892: DOUBLE
 893: EQUAL
 894: IFTRUE 898
 896: GO 949
 898: POP
// begin aiH := aiH union i ;
 899: LD_ADDR_EXP 19
 903: PUSH
 904: LD_EXP 19
 908: PUSH
 909: LD_VAR 0 1
 913: UNION
 914: ST_TO_ADDR
// aiZ := aiZ diff i ;
 915: LD_ADDR_EXP 21
 919: PUSH
 920: LD_EXP 21
 924: PUSH
 925: LD_VAR 0 1
 929: DIFF
 930: ST_TO_ADDR
// aiN := aiN diff i ;
 931: LD_ADDR_EXP 20
 935: PUSH
 936: LD_EXP 20
 940: PUSH
 941: LD_VAR 0 1
 945: DIFF
 946: ST_TO_ADDR
// end ; att_neutral :
 947: GO 1068
 949: LD_INT 0
 951: DOUBLE
 952: EQUAL
 953: IFTRUE 957
 955: GO 1008
 957: POP
// begin aiN := aiN union i ;
 958: LD_ADDR_EXP 20
 962: PUSH
 963: LD_EXP 20
 967: PUSH
 968: LD_VAR 0 1
 972: UNION
 973: ST_TO_ADDR
// aiZ := aiZ diff i ;
 974: LD_ADDR_EXP 21
 978: PUSH
 979: LD_EXP 21
 983: PUSH
 984: LD_VAR 0 1
 988: DIFF
 989: ST_TO_ADDR
// aiH := aiH diff i ;
 990: LD_ADDR_EXP 19
 994: PUSH
 995: LD_EXP 19
 999: PUSH
1000: LD_VAR 0 1
1004: DIFF
1005: ST_TO_ADDR
// end ; att_enemy :
1006: GO 1068
1008: LD_INT 2
1010: DOUBLE
1011: EQUAL
1012: IFTRUE 1016
1014: GO 1067
1016: POP
// begin aiZ := aiZ union i ;
1017: LD_ADDR_EXP 21
1021: PUSH
1022: LD_EXP 21
1026: PUSH
1027: LD_VAR 0 1
1031: UNION
1032: ST_TO_ADDR
// aiH := aiH diff i ;
1033: LD_ADDR_EXP 19
1037: PUSH
1038: LD_EXP 19
1042: PUSH
1043: LD_VAR 0 1
1047: DIFF
1048: ST_TO_ADDR
// aiN := aiN diff i ;
1049: LD_ADDR_EXP 20
1053: PUSH
1054: LD_EXP 20
1058: PUSH
1059: LD_VAR 0 1
1063: DIFF
1064: ST_TO_ADDR
// end ; end ;
1065: GO 1068
1067: POP
1068: GO 872
1070: POP
1071: POP
// enable ;
1072: ENABLE
// end ;
1073: PPOPN 1
1075: END
// every 0 0$1 do
1076: GO 1078
1078: DISABLE
// begin debug_strings := [ [ ( tick div 0 0$1 ) div 60 , ( tick div 0 0$1 ) mod 60 ] , debug_strings [ 2 ] , debug_strings [ 3 ] ] ;
1079: LD_ADDR_OWVAR 48
1083: PUSH
1084: LD_OWVAR 1
1088: PUSH
1089: LD_INT 35
1091: DIV
1092: PUSH
1093: LD_INT 60
1095: DIV
1096: PUSH
1097: LD_OWVAR 1
1101: PUSH
1102: LD_INT 35
1104: DIV
1105: PUSH
1106: LD_INT 60
1108: MOD
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: PUSH
1114: LD_OWVAR 48
1118: PUSH
1119: LD_INT 2
1121: ARRAY
1122: PUSH
1123: LD_OWVAR 48
1127: PUSH
1128: LD_INT 3
1130: ARRAY
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: ST_TO_ADDR
// enable ;
1137: ENABLE
// end ;
1138: END
// starting begin SA_OnMissionStart ;
1139: CALL 33071 0 0
// inicializace_main ;
1143: CALL 0 0 0
// inicializace_ai ;
1147: CALL 22590 0 0
// inicializace_functions ;
1151: CALL 9739 0 0
// inicializace_ai_b_repair ;
1155: CALL 22164 0 0
// inicializace_ai_b_build ;
1159: CALL 16094 0 0
// inicializace_ai_defend ;
1163: CALL 11555 0 0
// inicializace_ai_c_make ;
1167: CALL 13971 0 0
// inicializace_ai_c_repair ;
1171: CALL 12503 0 0
// disable ( 10 ) ;
1175: LD_INT 10
1177: DISABLE_MARKED
// disable ( 11 ) ;
1178: LD_INT 11
1180: DISABLE_MARKED
// disable ( 12 ) ;
1181: LD_INT 12
1183: DISABLE_MARKED
// disable ( 115 ) ;
1184: LD_INT 115
1186: DISABLE_MARKED
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_type , unit_human ] , [ f_class , class_apeman ] ] ) ;
1187: LD_ADDR_EXP 26
1191: PUSH
1192: LD_INT 23
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: PUSH
1202: LD_INT 21
1204: PUSH
1205: LD_INT 1
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 25
1214: PUSH
1215: LD_INT 12
1217: PUSH
1218: EMPTY
1219: LIST
1220: LIST
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: CALL_OW 69
1231: ST_TO_ADDR
// set_difficulty ;
1232: CALL 580 0 0
// SetCargo ( art_cargo1 , mat_artifact , 4 * 10 ) ;
1236: LD_EXP 34
1240: PPUSH
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 4
1246: PUSH
1247: LD_INT 10
1249: MUL
1250: PPUSH
1251: CALL_OW 290
// load ;
1255: CALL 8272 0 0
// inicializace_dialogues ;
1259: CALL 1284 0 0
// place_ru ;
1263: CALL 8813 0 0
// build_map ;
1267: CALL 20439 0 0
// get_groups ;
1271: CALL 22732 0 0
// get_your_units ;
1275: CALL 738 0 0
// DStart ;
1279: CALL 1459 0 0
// end ; end_of_file
1283: END
// var Gla , Bur , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ; var talking ; export function inicializace_dialogues ; begin
1284: LD_INT 0
1286: PPUSH
// Bur := Burlak ;
1287: LD_ADDR_LOC 2
1291: PUSH
1292: LD_EXP 41
1296: ST_TO_ADDR
// Gla := Gladkov ;
1297: LD_ADDR_LOC 1
1301: PUSH
1302: LD_EXP 44
1306: ST_TO_ADDR
// Glb := Gleb ;
1307: LD_ADDR_LOC 10
1311: PUSH
1312: LD_EXP 50
1316: ST_TO_ADDR
// Pla := Platonov ;
1317: LD_ADDR_LOC 3
1321: PUSH
1322: LD_EXP 42
1326: ST_TO_ADDR
// Gos := Gossudarov ;
1327: LD_ADDR_LOC 4
1331: PUSH
1332: LD_EXP 43
1336: ST_TO_ADDR
// Fad := Fadeev ;
1337: LD_ADDR_LOC 5
1341: PUSH
1342: LD_EXP 45
1346: ST_TO_ADDR
// Bor := Borodin ;
1347: LD_ADDR_LOC 6
1351: PUSH
1352: LD_EXP 46
1356: ST_TO_ADDR
// Tsr := Tsaritsyn ;
1357: LD_ADDR_LOC 7
1361: PUSH
1362: LD_EXP 47
1366: ST_TO_ADDR
// Dav := Davidov ;
1367: LD_ADDR_LOC 8
1371: PUSH
1372: LD_EXP 48
1376: ST_TO_ADDR
// Eis := Eisenstein ;
1377: LD_ADDR_LOC 9
1381: PUSH
1382: LD_EXP 49
1386: ST_TO_ADDR
// talking := [ Bur , Gla , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ] ;
1387: LD_ADDR_LOC 11
1391: PUSH
1392: LD_LOC 2
1396: PUSH
1397: LD_LOC 1
1401: PUSH
1402: LD_LOC 3
1406: PUSH
1407: LD_LOC 4
1411: PUSH
1412: LD_LOC 5
1416: PUSH
1417: LD_LOC 6
1421: PUSH
1422: LD_LOC 7
1426: PUSH
1427: LD_LOC 8
1431: PUSH
1432: LD_LOC 9
1436: PUSH
1437: LD_LOC 10
1441: PUSH
1442: EMPTY
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: ST_TO_ADDR
// end ;
1454: LD_VAR 0 1
1458: RET
// export function DStart ; begin
1459: LD_INT 0
1461: PPUSH
// hide_interface_automaticaly := true ;
1462: LD_ADDR_OWVAR 53
1466: PUSH
1467: LD_INT 1
1469: ST_TO_ADDR
// InGameOn ;
1470: CALL_OW 8
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
1474: LD_LOC 2
1478: PPUSH
1479: CALL_OW 310
1483: PPUSH
1484: CALL_OW 87
// CenterNowOnUnits ( Bur ) ;
1488: LD_LOC 2
1492: PPUSH
1493: CALL_OW 87
// while IsInUnit ( bur ) do
1497: LD_LOC 2
1501: PPUSH
1502: CALL_OW 310
1506: IFFALSE 1526
// begin ComExitVehicle ( Bur ) ;
1508: LD_LOC 2
1512: PPUSH
1513: CALL_OW 121
// wait ( 0 0$0.3 ) ;
1517: LD_INT 10
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1497
// Say ( Bur , DStart-Bur-1 ) ;
1526: LD_LOC 2
1530: PPUSH
1531: LD_STRING DStart-Bur-1
1533: PPUSH
1534: CALL_OW 88
// Say ( Gla , DStart-Gla-1 ) ;
1538: LD_LOC 1
1542: PPUSH
1543: LD_STRING DStart-Gla-1
1545: PPUSH
1546: CALL_OW 88
// Say ( Bur , DStart-Bur-2 ) ;
1550: LD_LOC 2
1554: PPUSH
1555: LD_STRING DStart-Bur-2
1557: PPUSH
1558: CALL_OW 88
// Say ( Gla , DStart-Gla-2 ) ;
1562: LD_LOC 1
1566: PPUSH
1567: LD_STRING DStart-Gla-2
1569: PPUSH
1570: CALL_OW 88
// Say ( Bur , DStart-Bur-3 ) ;
1574: LD_LOC 2
1578: PPUSH
1579: LD_STRING DStart-Bur-3
1581: PPUSH
1582: CALL_OW 88
// Say ( Gla , DStart-Gla-3 ) ;
1586: LD_LOC 1
1590: PPUSH
1591: LD_STRING DStart-Gla-3
1593: PPUSH
1594: CALL_OW 88
// Say ( Bur , DStart-Bur-4 ) ;
1598: LD_LOC 2
1602: PPUSH
1603: LD_STRING DStart-Bur-4
1605: PPUSH
1606: CALL_OW 88
// SetBName ( da , bluekher ) ;
1610: LD_INT 1
1612: PPUSH
1613: LD_STRING bluekher
1615: PPUSH
1616: CALL_OW 500
// SetBName ( dc , yegorov ) ;
1620: LD_INT 80
1622: PPUSH
1623: LD_STRING yegorov
1625: PPUSH
1626: CALL_OW 500
// SetBName ( dd , ryutin ) ;
1630: LD_INT 28
1632: PPUSH
1633: LD_STRING ryutin
1635: PPUSH
1636: CALL_OW 500
// SetBName ( db , budonny ) ;
1640: LD_INT 51
1642: PPUSH
1643: LD_STRING budonny
1645: PPUSH
1646: CALL_OW 500
// SetBName ( de , yakir ) ;
1650: LD_INT 37
1652: PPUSH
1653: LD_STRING yakir
1655: PPUSH
1656: CALL_OW 500
// RevealFogArea ( you , near_base ) ;
1660: LD_EXP 7
1664: PPUSH
1665: LD_INT 7
1667: PPUSH
1668: CALL_OW 332
// CenterOnUnits ( dc ) ;
1672: LD_INT 80
1674: PPUSH
1675: CALL_OW 85
// DWait ( 0 0$2 ) ;
1679: LD_INT 70
1681: PPUSH
1682: CALL_OW 68
// Say ( Gla , DStart-Gla-4 ) ;
1686: LD_LOC 1
1690: PPUSH
1691: LD_STRING DStart-Gla-4
1693: PPUSH
1694: CALL_OW 88
// CenterOnUnits ( dd ) ;
1698: LD_INT 28
1700: PPUSH
1701: CALL_OW 85
// DWait ( 0 0$2 ) ;
1705: LD_INT 70
1707: PPUSH
1708: CALL_OW 68
// Say ( Gla , DStart-Gla-4a ) ;
1712: LD_LOC 1
1716: PPUSH
1717: LD_STRING DStart-Gla-4a
1719: PPUSH
1720: CALL_OW 88
// CenterOnUnits ( de ) ;
1724: LD_INT 37
1726: PPUSH
1727: CALL_OW 85
// DWait ( 0 0$2 ) ;
1731: LD_INT 70
1733: PPUSH
1734: CALL_OW 68
// Say ( Gla , DStart-Gla-4b ) ;
1738: LD_LOC 1
1742: PPUSH
1743: LD_STRING DStart-Gla-4b
1745: PPUSH
1746: CALL_OW 88
// CenterOnUnits ( db ) ;
1750: LD_INT 51
1752: PPUSH
1753: CALL_OW 85
// DWait ( 0 0$2 ) ;
1757: LD_INT 70
1759: PPUSH
1760: CALL_OW 68
// Say ( Gla , DStart-Gla-4c ) ;
1764: LD_LOC 1
1768: PPUSH
1769: LD_STRING DStart-Gla-4c
1771: PPUSH
1772: CALL_OW 88
// CenterOnUnits ( da ) ;
1776: LD_INT 1
1778: PPUSH
1779: CALL_OW 85
// DWait ( 0 0$2 ) ;
1783: LD_INT 70
1785: PPUSH
1786: CALL_OW 68
// Say ( Gla , DStart-Gla-4d ) ;
1790: LD_LOC 1
1794: PPUSH
1795: LD_STRING DStart-Gla-4d
1797: PPUSH
1798: CALL_OW 88
// Say ( Gla , DStart-Gla-4e ) ;
1802: LD_LOC 1
1806: PPUSH
1807: LD_STRING DStart-Gla-4e
1809: PPUSH
1810: CALL_OW 88
// SaveForQuickRestart ;
1814: CALL_OW 22
// CenterNowOnUnits ( Bur ) ;
1818: LD_LOC 2
1822: PPUSH
1823: CALL_OW 87
// ChangeMissionObjectives ( MStart ) ;
1827: LD_STRING MStart
1829: PPUSH
1830: CALL_OW 337
// InGameOff ;
1834: CALL_OW 9
// end ;
1838: LD_VAR 0 1
1842: RET
// every 29 29$0 marked 111 do
1843: GO 1845
1845: DISABLE
// begin disable ( 112 ) ;
1846: LD_INT 112
1848: DISABLE_MARKED
// zdrhaji ;
1849: CALL 1878 0 0
// end ;
1853: END
// every 0 0$30 trigger kecali_o_artefaktu marked 112 do
1854: LD_EXP 40
1858: IFFALSE 1877
1860: GO 1862
1862: DISABLE
// begin disable ( 111 ) ;
1863: LD_INT 111
1865: DISABLE_MARKED
// wait ( 2 2$15 ) ;
1866: LD_INT 4725
1868: PPUSH
1869: CALL_OW 67
// zdrhaji ;
1873: CALL 1878 0 0
// end ;
1877: END
// function zdrhaji ; var ai1sci , i , mytick ; begin
1878: LD_INT 0
1880: PPUSH
1881: PPUSH
1882: PPUSH
1883: PPUSH
// vedci_zacali_zdrhat := true ;
1884: LD_ADDR_EXP 30
1888: PUSH
1889: LD_INT 1
1891: ST_TO_ADDR
// TeleportExit ( telp1 , 136 , 88 ) ;
1892: LD_INT 15
1894: PPUSH
1895: LD_INT 136
1897: PPUSH
1898: LD_INT 88
1900: PPUSH
1901: CALL_OW 243
// ai1sci := UnitFilter ( humans [ 1 ] , [ mf_sci ] ) ;
1905: LD_ADDR_VAR 0 2
1909: PUSH
1910: LD_EXP 76
1914: PUSH
1915: LD_INT 1
1917: ARRAY
1918: PPUSH
1919: LD_EXP 54
1923: PUSH
1924: EMPTY
1925: LIST
1926: PPUSH
1927: CALL_OW 72
1931: ST_TO_ADDR
// if ai1sci then
1932: LD_VAR 0 2
1936: IFFALSE 1948
// run_sci := ai1sci ;
1938: LD_ADDR_EXP 31
1942: PUSH
1943: LD_VAR 0 2
1947: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff run_sci ) ;
1948: LD_ADDR_EXP 76
1952: PUSH
1953: LD_EXP 76
1957: PPUSH
1958: LD_INT 1
1960: PPUSH
1961: LD_EXP 76
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PUSH
1970: LD_EXP 31
1974: DIFF
1975: PPUSH
1976: CALL_OW 1
1980: ST_TO_ADDR
// sci := sci diff run_sci ;
1981: LD_ADDR_EXP 88
1985: PUSH
1986: LD_EXP 88
1990: PUSH
1991: LD_EXP 31
1995: DIFF
1996: ST_TO_ADDR
// for i in utek do
1997: LD_ADDR_VAR 0 3
2001: PUSH
2002: LD_EXP 32
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2039
// AddComMoveXY ( run_sci , i [ 1 ] , i [ 2 ] ) ;
2010: LD_EXP 31
2014: PPUSH
2015: LD_VAR 0 3
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: PPUSH
2024: LD_VAR 0 3
2028: PUSH
2029: LD_INT 2
2031: ARRAY
2032: PPUSH
2033: CALL_OW 171
2037: GO 2007
2039: POP
2040: POP
// wait ( 0 0$10 ) ;
2041: LD_INT 350
2043: PPUSH
2044: CALL_OW 67
// DGossudarov ;
2048: CALL 2699 0 0
// mytick := tick + 1 1$30 ;
2052: LD_ADDR_VAR 0 4
2056: PUSH
2057: LD_OWVAR 1
2061: PUSH
2062: LD_INT 3150
2064: PLUS
2065: ST_TO_ADDR
// while mytick > tick and not UnitFilter ( run_sci , [ f_or , [ f_not , [ f_alive ] ] , [ f_distxy , 142 , 88 , 10 ] ] ) do
2066: LD_VAR 0 4
2070: PUSH
2071: LD_OWVAR 1
2075: GREATER
2076: PUSH
2077: LD_EXP 31
2081: PPUSH
2082: LD_INT 2
2084: PUSH
2085: LD_INT 3
2087: PUSH
2088: LD_INT 51
2090: PUSH
2091: EMPTY
2092: LIST
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 92
2100: PUSH
2101: LD_INT 142
2103: PUSH
2104: LD_INT 88
2106: PUSH
2107: LD_INT 10
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: EMPTY
2117: LIST
2118: LIST
2119: LIST
2120: PPUSH
2121: CALL_OW 72
2125: NOT
2126: AND
2127: IFFALSE 2138
// wait ( 0 0$1 ) ;
2129: LD_INT 35
2131: PPUSH
2132: CALL_OW 67
2136: GO 2066
// ComExitVehicle ( Gossudarov ) ;
2138: LD_EXP 43
2142: PPUSH
2143: CALL_OW 121
// while not UnitsInside ( art_cargo ) do
2147: LD_INT 121
2149: PPUSH
2150: CALL_OW 313
2154: NOT
2155: IFFALSE 2178
// begin ComEnterUnit ( Gossudarov , art_cargo ) ;
2157: LD_EXP 43
2161: PPUSH
2162: LD_INT 121
2164: PPUSH
2165: CALL_OW 120
// wait ( 0 0$1 ) ;
2169: LD_INT 35
2171: PPUSH
2172: CALL_OW 67
// end ;
2176: GO 2147
// if UnitFilter ( run_sci , [ [ f_distxy , 142 , 88 , 12 ] ] ) then
2178: LD_EXP 31
2182: PPUSH
2183: LD_INT 92
2185: PUSH
2186: LD_INT 142
2188: PUSH
2189: LD_INT 88
2191: PUSH
2192: LD_INT 12
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: PUSH
2201: EMPTY
2202: LIST
2203: PPUSH
2204: CALL_OW 72
2208: IFFALSE 2260
// while not UnitFilter ( art_cargo , [ [ f_distxy , 136 , 88 , 15 ] ] ) do
2210: LD_INT 121
2212: PPUSH
2213: LD_INT 92
2215: PUSH
2216: LD_INT 136
2218: PUSH
2219: LD_INT 88
2221: PUSH
2222: LD_INT 15
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: LIST
2230: PUSH
2231: EMPTY
2232: LIST
2233: PPUSH
2234: CALL_OW 72
2238: NOT
2239: IFFALSE 2260
// begin ComMoveUnit ( art_cargo , telp1 ) ;
2241: LD_INT 121
2243: PPUSH
2244: LD_INT 15
2246: PPUSH
2247: CALL_OW 112
// wait ( 0 0$1 ) ;
2251: LD_INT 35
2253: PPUSH
2254: CALL_OW 67
// end ;
2258: GO 2210
// while UnitFilter ( run_sci ^ art_cargo , [ [ f_placed ] ] ) do
2260: LD_EXP 31
2264: PUSH
2265: LD_INT 121
2267: ADD
2268: PPUSH
2269: LD_INT 52
2271: PUSH
2272: EMPTY
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: PPUSH
2278: CALL_OW 72
2282: IFFALSE 2416
// begin ComMoveXY ( ( run_sci ) ^ art_cargo , utek_e [ 1 ] , utek_e [ 2 ] ) ;
2284: LD_EXP 31
2288: PUSH
2289: LD_INT 121
2291: ADD
2292: PPUSH
2293: LD_EXP 33
2297: PUSH
2298: LD_INT 1
2300: ARRAY
2301: PPUSH
2302: LD_EXP 33
2306: PUSH
2307: LD_INT 2
2309: ARRAY
2310: PPUSH
2311: CALL_OW 111
// for i in UnitFilter ( ( run_sci ) ^ art_cargo , [ [ f_distxy , utek_e [ 1 ] , utek_e [ 2 ] , 5 ] ] ) do
2315: LD_ADDR_VAR 0 3
2319: PUSH
2320: LD_EXP 31
2324: PUSH
2325: LD_INT 121
2327: ADD
2328: PPUSH
2329: LD_INT 92
2331: PUSH
2332: LD_EXP 33
2336: PUSH
2337: LD_INT 1
2339: ARRAY
2340: PUSH
2341: LD_EXP 33
2345: PUSH
2346: LD_INT 2
2348: ARRAY
2349: PUSH
2350: LD_INT 5
2352: PUSH
2353: EMPTY
2354: LIST
2355: LIST
2356: LIST
2357: LIST
2358: PUSH
2359: EMPTY
2360: LIST
2361: PPUSH
2362: CALL_OW 72
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2405
// if i = art_cargo then
2370: LD_VAR 0 3
2374: PUSH
2375: LD_INT 121
2377: EQUAL
2378: IFFALSE 2386
// LostArte else
2380: CALL 565 0 0
2384: GO 2403
// begin RemoveUnit ( i ) ;
2386: LD_VAR 0 3
2390: PPUSH
2391: CALL_OW 64
// Goss := false ;
2395: LD_ADDR_EXP 28
2399: PUSH
2400: LD_INT 0
2402: ST_TO_ADDR
// end ;
2403: GO 2367
2405: POP
2406: POP
// wait ( 0 0$1 ) ;
2407: LD_INT 35
2409: PPUSH
2410: CALL_OW 67
// end ;
2414: GO 2260
// end ;
2416: LD_VAR 0 1
2420: RET
// every 0 0$1 trigger vedci_zacali_zdrhat and UnitFilter ( run_sci ^ Gossudarov , [ [ f_alive ] , [ f_placed ] ] ) = 0 do
2421: LD_EXP 30
2425: PUSH
2426: LD_EXP 31
2430: PUSH
2431: LD_EXP 43
2435: ADD
2436: PPUSH
2437: LD_INT 51
2439: PUSH
2440: EMPTY
2441: LIST
2442: PUSH
2443: LD_INT 52
2445: PUSH
2446: EMPTY
2447: LIST
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PPUSH
2453: CALL_OW 72
2457: PUSH
2458: LD_INT 0
2460: EQUAL
2461: AND
2462: IFFALSE 2474
2464: GO 2466
2466: DISABLE
// begin ChangeMissionObjectives ( MGossSciOut ) ;
2467: LD_STRING MGossSciOut
2469: PPUSH
2470: CALL_OW 337
// end ;
2474: END
// every 0 0$1 do var h , hinfo , i ;
2475: GO 2477
2477: DISABLE
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
2482: PPUSH
// begin h := FindArtifact ( 4 ) ;
2483: LD_ADDR_VAR 0 1
2487: PUSH
2488: LD_INT 4
2490: PPUSH
2491: CALL_OW 469
2495: ST_TO_ADDR
// if h then
2496: LD_VAR 0 1
2500: IFFALSE 2695
// begin hinfo := HexInfo ( h [ 1 ] , h [ 2 ] ) ;
2502: LD_ADDR_VAR 0 2
2506: PUSH
2507: LD_VAR 0 1
2511: PUSH
2512: LD_INT 1
2514: ARRAY
2515: PPUSH
2516: LD_VAR 0 1
2520: PUSH
2521: LD_INT 2
2523: ARRAY
2524: PPUSH
2525: CALL_OW 428
2529: ST_TO_ADDR
// if hinfo > 0 then
2530: LD_VAR 0 2
2534: PUSH
2535: LD_INT 0
2537: GREATER
2538: IFFALSE 2577
// begin if GetSide ( hinfo ) = you then
2540: LD_VAR 0 2
2544: PPUSH
2545: CALL_OW 255
2549: PUSH
2550: LD_EXP 7
2554: EQUAL
2555: IFFALSE 2567
// maji_artifact := true else
2557: LD_ADDR_EXP 39
2561: PUSH
2562: LD_INT 1
2564: ST_TO_ADDR
2565: GO 2575
// maji_artifact := false ;
2567: LD_ADDR_EXP 39
2571: PUSH
2572: LD_INT 0
2574: ST_TO_ADDR
// end else
2575: GO 2695
// begin maji_artifact := false ;
2577: LD_ADDR_EXP 39
2581: PUSH
2582: LD_INT 0
2584: ST_TO_ADDR
// for i := 1 to 5 do
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: DOUBLE
2591: LD_INT 1
2593: DEC
2594: ST_TO_ADDR
2595: LD_INT 5
2597: PUSH
2598: FOR_TO
2599: IFFALSE 2693
// if ( ai_s [ i ] in your_bases ) and ( InArea ( h [ 1 ] , h [ 2 ] , near_base_area [ i ] ) or InArea ( h [ 1 ] , h [ 2 ] , nearD ) ) then
2601: LD_EXP 23
2605: PUSH
2606: LD_VAR 0 3
2610: ARRAY
2611: PUSH
2612: LD_EXP 18
2616: IN
2617: PUSH
2618: LD_VAR 0 1
2622: PUSH
2623: LD_INT 1
2625: ARRAY
2626: PPUSH
2627: LD_VAR 0 1
2631: PUSH
2632: LD_INT 2
2634: ARRAY
2635: PPUSH
2636: LD_EXP 63
2640: PUSH
2641: LD_VAR 0 3
2645: ARRAY
2646: PPUSH
2647: CALL_OW 309
2651: PUSH
2652: LD_VAR 0 1
2656: PUSH
2657: LD_INT 1
2659: ARRAY
2660: PPUSH
2661: LD_VAR 0 1
2665: PUSH
2666: LD_INT 2
2668: ARRAY
2669: PPUSH
2670: LD_INT 27
2672: PPUSH
2673: CALL_OW 309
2677: OR
2678: AND
2679: IFFALSE 2691
// begin maji_artifact := true ;
2681: LD_ADDR_EXP 39
2685: PUSH
2686: LD_INT 1
2688: ST_TO_ADDR
// break ;
2689: GO 2693
// end ;
2691: GO 2598
2693: POP
2694: POP
// end ; end ; enable ;
2695: ENABLE
// end ;
2696: PPOPN 3
2698: END
// export function DGossudarov ; var x , y ; begin
2699: LD_INT 0
2701: PPUSH
2702: PPUSH
2703: PPUSH
// x := GetX ( run_sci [ 1 ] ) ;
2704: LD_ADDR_VAR 0 2
2708: PUSH
2709: LD_EXP 31
2713: PUSH
2714: LD_INT 1
2716: ARRAY
2717: PPUSH
2718: CALL_OW 250
2722: ST_TO_ADDR
// y := GetY ( run_sci [ 1 ] ) ;
2723: LD_ADDR_VAR 0 3
2727: PUSH
2728: LD_EXP 31
2732: PUSH
2733: LD_INT 1
2735: ARRAY
2736: PPUSH
2737: CALL_OW 251
2741: ST_TO_ADDR
// PlaceSeeing ( x , y , You , 10 ) ;
2742: LD_VAR 0 2
2746: PPUSH
2747: LD_VAR 0 3
2751: PPUSH
2752: LD_EXP 7
2756: PPUSH
2757: LD_INT 10
2759: PPUSH
2760: CALL_OW 330
// CenterNowOnXY ( x , y ) ;
2764: LD_VAR 0 2
2768: PPUSH
2769: LD_VAR 0 3
2773: PPUSH
2774: CALL_OW 86
// wait ( 0 0$1 ) ;
2778: LD_INT 35
2780: PPUSH
2781: CALL_OW 67
// DialogueOn ;
2785: CALL_OW 6
// Say ( Fad , DGossudarov-Fad-1 ) ;
2789: LD_LOC 5
2793: PPUSH
2794: LD_STRING DGossudarov-Fad-1
2796: PPUSH
2797: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-1 ) ;
2801: LD_LOC 2
2805: PPUSH
2806: LD_STRING DGossudarov-Bur-1
2808: PPUSH
2809: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-1 ) ;
2813: LD_LOC 4
2817: PPUSH
2818: LD_STRING DGossudarov-Gos-1
2820: PPUSH
2821: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-2 ) ;
2825: LD_LOC 2
2829: PPUSH
2830: LD_STRING DGossudarov-Bur-2
2832: PPUSH
2833: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-2 ) ;
2837: LD_LOC 4
2841: PPUSH
2842: LD_STRING DGossudarov-Gos-2
2844: PPUSH
2845: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-3 ) ;
2849: LD_LOC 2
2853: PPUSH
2854: LD_STRING DGossudarov-Bur-3
2856: PPUSH
2857: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-3 ) ;
2861: LD_LOC 4
2865: PPUSH
2866: LD_STRING DGossudarov-Gos-3
2868: PPUSH
2869: CALL_OW 88
// ChangeMissionObjectives ( MGoss ) ;
2873: LD_STRING MGoss
2875: PPUSH
2876: CALL_OW 337
// DialogueOff ;
2880: CALL_OW 7
// wait ( 0 0$5 ) ;
2884: LD_INT 175
2886: PPUSH
2887: CALL_OW 67
// RemoveSeeing ( x , y , You ) ;
2891: LD_VAR 0 2
2895: PPUSH
2896: LD_VAR 0 3
2900: PPUSH
2901: LD_EXP 7
2905: PPUSH
2906: CALL_OW 331
// end ;
2910: LD_VAR 0 1
2914: RET
// every 0 0$2 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
2915: LD_EXP 23
2919: PUSH
2920: LD_EXP 25
2924: ARRAY
2925: PPUSH
2926: LD_EXP 37
2930: PUSH
2931: LD_EXP 35
2935: ADD
2936: PPUSH
2937: CALL 10504 0 2
2941: PUSH
2942: LD_EXP 37
2946: PUSH
2947: LD_EXP 35
2951: ADD
2952: PPUSH
2953: LD_INT 95
2955: PUSH
2956: LD_EXP 63
2960: PUSH
2961: LD_EXP 25
2965: ARRAY
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: EMPTY
2972: LIST
2973: PPUSH
2974: CALL_OW 72
2978: AND
2979: IFFALSE 2988
2981: GO 2983
2983: DISABLE
// begin DA_BaseContact ;
2984: CALL 2989 0 0
// end ;
2988: END
// export function DA_BaseContact ; begin
2989: LD_INT 0
2991: PPUSH
// DialogueOn ;
2992: CALL_OW 6
// Say ( Pla , DA-BaseContact-Pla-1 ) ;
2996: LD_LOC 3
3000: PPUSH
3001: LD_STRING DA-BaseContact-Pla-1
3003: PPUSH
3004: CALL_OW 88
// Say ( Bur , DA-BaseContact-Bur-1 ) ;
3008: LD_LOC 2
3012: PPUSH
3013: LD_STRING DA-BaseContact-Bur-1
3015: PPUSH
3016: CALL_OW 88
// DialogueOff ;
3020: CALL_OW 7
// end ;
3024: LD_VAR 0 1
3028: RET
// every 0 0$20 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
3029: LD_EXP 23
3033: PUSH
3034: LD_EXP 25
3038: ARRAY
3039: PPUSH
3040: LD_EXP 37
3044: PUSH
3045: LD_EXP 35
3049: ADD
3050: PPUSH
3051: CALL 10504 0 2
3055: PUSH
3056: LD_EXP 37
3060: PUSH
3061: LD_EXP 35
3065: ADD
3066: PPUSH
3067: LD_INT 95
3069: PUSH
3070: LD_EXP 63
3074: PUSH
3075: LD_EXP 25
3079: ARRAY
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: EMPTY
3086: LIST
3087: PPUSH
3088: CALL_OW 72
3092: AND
3093: IFFALSE 3176
3095: GO 3097
3097: DISABLE
// begin wait ( 0 0$20 ) ;
3098: LD_INT 700
3100: PPUSH
3101: CALL_OW 67
// if see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) then
3105: LD_EXP 23
3109: PUSH
3110: LD_EXP 25
3114: ARRAY
3115: PPUSH
3116: LD_EXP 37
3120: PUSH
3121: LD_EXP 35
3125: ADD
3126: PPUSH
3127: CALL 10504 0 2
3131: PUSH
3132: LD_EXP 37
3136: PUSH
3137: LD_EXP 35
3141: ADD
3142: PPUSH
3143: LD_INT 95
3145: PUSH
3146: LD_EXP 63
3150: PUSH
3151: LD_EXP 25
3155: ARRAY
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PUSH
3161: EMPTY
3162: LIST
3163: PPUSH
3164: CALL_OW 72
3168: AND
3169: IFFALSE 3175
// DA_BaseRefuse ;
3171: CALL 3956 0 0
// enable ;
3175: ENABLE
// end ;
3176: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 12 do
3177: LD_EXP 76
3181: PUSH
3182: LD_EXP 25
3186: ARRAY
3187: PPUSH
3188: LD_INT 3
3190: PUSH
3191: LD_EXP 54
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL_OW 72
3204: PUSH
3205: LD_INT 12
3207: LESS
3208: IFFALSE 3221
3210: GO 3212
3212: DISABLE
// begin DA_BaseRefuse ;
3213: CALL 3956 0 0
// ZoufalUtok ;
3217: CALL 11808 0 0
// end ;
3221: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 10 do
3222: LD_EXP 76
3226: PUSH
3227: LD_EXP 25
3231: ARRAY
3232: PPUSH
3233: LD_INT 3
3235: PUSH
3236: LD_EXP 54
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PPUSH
3245: CALL_OW 72
3249: PUSH
3250: LD_INT 10
3252: LESS
3253: IFFALSE 3266
3255: GO 3257
3257: DISABLE
// begin DA_BaseRefuse ;
3258: CALL 3956 0 0
// BehemothUtok ;
3262: CALL 11617 0 0
// end ;
3266: END
// every 25 25$0 do
3267: GO 3269
3269: DISABLE
// begin BehemothUtok ;
3270: CALL 11617 0 0
// end ;
3274: END
// every 10 10$0 + 0 0$5 do
3275: GO 3277
3277: DISABLE
// begin NormalUtok ;
3278: CALL 12005 0 0
// end ;
3282: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) <= 7 and UnitFilter ( buildings [ plat_i ] , [ f_or , [ f_btype , b_turret ] , [ [ f_occupied ] , mf_fort ] ] ) <= 2 do var kam_zdrha , k_dispozici , mt , kam_telp , h , i , kam_zdrha_i ;
3283: LD_EXP 76
3287: PUSH
3288: LD_EXP 25
3292: ARRAY
3293: PPUSH
3294: LD_INT 3
3296: PUSH
3297: LD_EXP 54
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 72
3310: PUSH
3311: LD_INT 7
3313: LESSEQUAL
3314: PUSH
3315: LD_EXP 75
3319: PUSH
3320: LD_EXP 25
3324: ARRAY
3325: PPUSH
3326: LD_INT 2
3328: PUSH
3329: LD_INT 30
3331: PUSH
3332: LD_INT 33
3334: PUSH
3335: EMPTY
3336: LIST
3337: LIST
3338: PUSH
3339: LD_INT 59
3341: PUSH
3342: EMPTY
3343: LIST
3344: PUSH
3345: LD_EXP 56
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: LIST
3358: PPUSH
3359: CALL_OW 72
3363: PUSH
3364: LD_INT 2
3366: LESSEQUAL
3367: AND
3368: IFFALSE 3953
3370: GO 3372
3372: DISABLE
3373: LD_INT 0
3375: PPUSH
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
3380: PPUSH
3381: PPUSH
// begin k_dispozici := ( ai diff ( ai [ 1 ] ^ your_bases ) ) ;
3382: LD_ADDR_VAR 0 2
3386: PUSH
3387: LD_EXP 24
3391: PUSH
3392: LD_EXP 24
3396: PUSH
3397: LD_INT 1
3399: ARRAY
3400: PUSH
3401: LD_EXP 18
3405: ADD
3406: DIFF
3407: ST_TO_ADDR
// if k_dispozici then
3408: LD_VAR 0 2
3412: IFFALSE 3908
// begin kam_zdrha := ( k_dispozici ) [ Rand ( 1 , k_dispozici ) ] ;
3414: LD_ADDR_VAR 0 1
3418: PUSH
3419: LD_VAR 0 2
3423: PUSH
3424: LD_INT 1
3426: PPUSH
3427: LD_VAR 0 2
3431: PPUSH
3432: CALL_OW 12
3436: ARRAY
3437: ST_TO_ADDR
// case kam_zdrha of ai_s [ 2 ] :
3438: LD_VAR 0 1
3442: PUSH
3443: LD_EXP 23
3447: PUSH
3448: LD_INT 2
3450: ARRAY
3451: DOUBLE
3452: EQUAL
3453: IFTRUE 3457
3455: GO 3468
3457: POP
// kam_telp := b_base ; ai_s [ 3 ] :
3458: LD_ADDR_VAR 0 4
3462: PUSH
3463: LD_INT 20
3465: ST_TO_ADDR
3466: GO 3544
3468: LD_EXP 23
3472: PUSH
3473: LD_INT 3
3475: ARRAY
3476: DOUBLE
3477: EQUAL
3478: IFTRUE 3482
3480: GO 3493
3482: POP
// kam_telp := c_base ; ai_s [ 4 ] :
3483: LD_ADDR_VAR 0 4
3487: PUSH
3488: LD_INT 23
3490: ST_TO_ADDR
3491: GO 3544
3493: LD_EXP 23
3497: PUSH
3498: LD_INT 4
3500: ARRAY
3501: DOUBLE
3502: EQUAL
3503: IFTRUE 3507
3505: GO 3518
3507: POP
// kam_telp := d_base ; ai_s [ 5 ] :
3508: LD_ADDR_VAR 0 4
3512: PUSH
3513: LD_INT 22
3515: ST_TO_ADDR
3516: GO 3544
3518: LD_EXP 23
3522: PUSH
3523: LD_INT 5
3525: ARRAY
3526: DOUBLE
3527: EQUAL
3528: IFTRUE 3532
3530: GO 3543
3532: POP
// kam_telp := e_base ; end ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: LD_INT 21
3540: ST_TO_ADDR
3541: GO 3544
3543: POP
// repeat h := RandHexArea ( kam_telp , false ) ;
3544: LD_ADDR_VAR 0 5
3548: PUSH
3549: LD_VAR 0 4
3553: PPUSH
3554: LD_INT 0
3556: PPUSH
3557: CALL_OW 16
3561: ST_TO_ADDR
// until HexInfo ( h [ 1 ] , h [ 2 ] ) = 0 ;
3562: LD_VAR 0 5
3566: PUSH
3567: LD_INT 1
3569: ARRAY
3570: PPUSH
3571: LD_VAR 0 5
3575: PUSH
3576: LD_INT 2
3578: ARRAY
3579: PPUSH
3580: CALL_OW 428
3584: PUSH
3585: LD_INT 0
3587: EQUAL
3588: IFFALSE 3544
// TeleportExit ( telp1 , h [ 1 ] , h [ 2 ] ) ;
3590: LD_INT 15
3592: PPUSH
3593: LD_VAR 0 5
3597: PUSH
3598: LD_INT 1
3600: ARRAY
3601: PPUSH
3602: LD_VAR 0 5
3606: PUSH
3607: LD_INT 2
3609: ARRAY
3610: PPUSH
3611: CALL_OW 243
// ComExitVehicle ( Platonov ) ;
3615: LD_EXP 42
3619: PPUSH
3620: CALL_OW 121
// AddComExitBuilding ( Platonov ) ;
3624: LD_EXP 42
3628: PPUSH
3629: CALL_OW 182
// AddComEnterUnit ( Platonov , telp1 ) ;
3633: LD_EXP 42
3637: PPUSH
3638: LD_INT 15
3640: PPUSH
3641: CALL_OW 180
// for i := 1 to 5 do
3645: LD_ADDR_VAR 0 6
3649: PUSH
3650: DOUBLE
3651: LD_INT 1
3653: DEC
3654: ST_TO_ADDR
3655: LD_INT 5
3657: PUSH
3658: FOR_TO
3659: IFFALSE 3691
// if ai_s [ i ] = kam_zdrha then
3661: LD_EXP 23
3665: PUSH
3666: LD_VAR 0 6
3670: ARRAY
3671: PUSH
3672: LD_VAR 0 1
3676: EQUAL
3677: IFFALSE 3689
// kam_zdrha_i := i ;
3679: LD_ADDR_VAR 0 7
3683: PUSH
3684: LD_VAR 0 6
3688: ST_TO_ADDR
3689: GO 3658
3691: POP
3692: POP
// plat_i := kam_zdrha_i ;
3693: LD_ADDR_EXP 25
3697: PUSH
3698: LD_VAR 0 7
3702: ST_TO_ADDR
// ai_s := replace ( ai_s , kam_zdrha_i , ai_s [ 1 ] ) ;
3703: LD_ADDR_EXP 23
3707: PUSH
3708: LD_EXP 23
3712: PPUSH
3713: LD_VAR 0 7
3717: PPUSH
3718: LD_EXP 23
3722: PUSH
3723: LD_INT 1
3725: ARRAY
3726: PPUSH
3727: CALL_OW 1
3731: ST_TO_ADDR
// wait ( 0 0$5 ) ;
3732: LD_INT 175
3734: PPUSH
3735: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3739: LD_EXP 42
3743: PPUSH
3744: LD_EXP 74
3748: PUSH
3749: LD_VAR 0 7
3753: ARRAY
3754: PPUSH
3755: CALL_OW 180
// DA_BaseAccept ;
3759: CALL 4006 0 0
// SurrenderBase ( t_killbeat , ai_s [ plat_i ] ) ;
3763: LD_EXP 6
3767: PPUSH
3768: LD_EXP 23
3772: PUSH
3773: LD_EXP 25
3777: ARRAY
3778: PPUSH
3779: CALL 30288 0 2
// SetAttitude ( ai_s [ plat_i ] , you , att_enemy , true ) ;
3783: LD_EXP 23
3787: PUSH
3788: LD_EXP 25
3792: ARRAY
3793: PPUSH
3794: LD_EXP 7
3798: PPUSH
3799: LD_INT 2
3801: PPUSH
3802: LD_INT 1
3804: PPUSH
3805: CALL_OW 80
// SetSideBase_custom ( GetBase ( depots [ plat_i ] ) , ai_s [ plat_i ] ) ;
3809: LD_EXP 74
3813: PUSH
3814: LD_EXP 25
3818: ARRAY
3819: PPUSH
3820: CALL_OW 274
3824: PPUSH
3825: LD_EXP 23
3829: PUSH
3830: LD_EXP 25
3834: ARRAY
3835: PPUSH
3836: CALL 32693 0 2
// SetSide ( FilterAllUnits ( [ [ f_side , kam_zdrha ] ] ) , ai_s [ plat_i ] ) ;
3840: LD_INT 22
3842: PUSH
3843: LD_VAR 0 1
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: EMPTY
3853: LIST
3854: PPUSH
3855: CALL_OW 69
3859: PPUSH
3860: LD_EXP 23
3864: PUSH
3865: LD_EXP 25
3869: ARRAY
3870: PPUSH
3871: CALL_OW 235
// wait ( 1 1$0 ) ;
3875: LD_INT 2100
3877: PPUSH
3878: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3882: LD_EXP 42
3886: PPUSH
3887: LD_EXP 74
3891: PUSH
3892: LD_VAR 0 7
3896: ARRAY
3897: PPUSH
3898: CALL_OW 180
// ZoufalUtok ;
3902: CALL 11808 0 0
// end else
3906: GO 3953
// begin while not IsDead ( Platonov ) do
3908: LD_EXP 42
3912: PPUSH
3913: CALL_OW 301
3917: NOT
3918: IFFALSE 3953
// begin ComAttackUnit ( Platonov , NearestUnitToUnit ( your_humans , Platonov ) ) ;
3920: LD_EXP 42
3924: PPUSH
3925: LD_EXP 37
3929: PPUSH
3930: LD_EXP 42
3934: PPUSH
3935: CALL_OW 74
3939: PPUSH
3940: CALL_OW 115
// wait ( 0 0$5 ) ;
3944: LD_INT 175
3946: PPUSH
3947: CALL_OW 67
// end ;
3951: GO 3908
// end ; end ;
3953: PPOPN 7
3955: END
// export function DA_BaseRefuse ; begin
3956: LD_INT 0
3958: PPUSH
// DialogueOn ;
3959: CALL_OW 6
// if not IsDead ( Pla ) then
3963: LD_LOC 3
3967: PPUSH
3968: CALL_OW 301
3972: NOT
3973: IFFALSE 3997
// if not Say ( Pla , DA-BaseReguse-Pla-1 ) then
3975: LD_LOC 3
3979: PPUSH
3980: LD_STRING DA-BaseReguse-Pla-1
3982: PPUSH
3983: CALL_OW 88
3987: NOT
3988: IFFALSE 3997
// msg ( bad ident: DA-BaseReguse-Pla-1 ) ;
3990: LD_STRING bad ident: DA-BaseReguse-Pla-1
3992: PPUSH
3993: CALL_OW 100
// DialogueOff ;
3997: CALL_OW 7
// end ;
4001: LD_VAR 0 1
4005: RET
// export function DA_BaseAccept ; begin
4006: LD_INT 0
4008: PPUSH
// DialogueOn ;
4009: CALL_OW 6
// Say ( Pla , DA-BaseAccept-Pla-1 ) ;
4013: LD_LOC 3
4017: PPUSH
4018: LD_STRING DA-BaseAccept-Pla-1
4020: PPUSH
4021: CALL_OW 88
// DialogueOff ;
4025: CALL_OW 7
// end ;
4029: LD_VAR 0 1
4033: RET
// every 0 0$2 trigger See ( you , behemoth ) do var who ;
4034: LD_EXP 7
4038: PPUSH
4039: LD_INT 125
4041: PPUSH
4042: CALL_OW 292
4046: IFFALSE 4165
4048: GO 4050
4050: DISABLE
4051: LD_INT 0
4053: PPUSH
// begin BehemothSeen := true ;
4054: LD_ADDR_EXP 29
4058: PUSH
4059: LD_INT 1
4061: ST_TO_ADDR
// if GetSide ( behemoth ) = you then
4062: LD_INT 125
4064: PPUSH
4065: CALL_OW 255
4069: PUSH
4070: LD_EXP 7
4074: EQUAL
4075: IFFALSE 4079
// exit ;
4077: GO 4165
// CenterNowOnUnits ( behemoth ) ;
4079: LD_INT 125
4081: PPUSH
4082: CALL_OW 87
// who := WhoSayAny ( your_humans diff talking , you , sex_male , 0 , 0 ) ;
4086: LD_ADDR_VAR 0 1
4090: PUSH
4091: LD_EXP 37
4095: PUSH
4096: LD_LOC 11
4100: DIFF
4101: PPUSH
4102: LD_EXP 7
4106: PPUSH
4107: LD_INT 1
4109: PPUSH
4110: LD_INT 0
4112: PPUSH
4113: LD_INT 0
4115: PPUSH
4116: CALL 10310 0 5
4120: ST_TO_ADDR
// DialogueOn ;
4121: CALL_OW 6
// Say ( who , DBehemoth-Rsol1-1 ) ;
4125: LD_VAR 0 1
4129: PPUSH
4130: LD_STRING DBehemoth-Rsol1-1
4132: PPUSH
4133: CALL_OW 88
// Say ( Pla , DBehemoth-Pla-1 ) ;
4137: LD_LOC 3
4141: PPUSH
4142: LD_STRING DBehemoth-Pla-1
4144: PPUSH
4145: CALL_OW 88
// Say ( Bur , DBehemoth-Bur-1 ) ;
4149: LD_LOC 2
4153: PPUSH
4154: LD_STRING DBehemoth-Bur-1
4156: PPUSH
4157: CALL_OW 88
// DialogueOff ;
4161: CALL_OW 7
// end ;
4165: PPOPN 1
4167: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] do
4168: LD_LOC 2
4172: PPUSH
4173: LD_INT 20
4175: PPUSH
4176: CALL_OW 308
4180: PUSH
4181: LD_EXP 23
4185: PUSH
4186: LD_INT 1
4188: ARRAY
4189: PUSH
4190: LD_EXP 23
4194: PUSH
4195: LD_INT 2
4197: ARRAY
4198: NONEQUAL
4199: AND
4200: IFFALSE 4280
4202: GO 4204
4204: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4205: LD_EXP 37
4209: PUSH
4210: LD_INT 12
4212: LESS
4213: PUSH
4214: LD_EXP 35
4218: PUSH
4219: LD_INT 20
4221: LESS
4222: AND
4223: IFFALSE 4245
// begin DB_BaseContact ;
4225: CALL 4484 0 0
// DB_BaseRefuse1st ;
4229: CALL 4512 0 0
// wait ( 0 0$30 ) ;
4233: LD_INT 1050
4235: PPUSH
4236: CALL_OW 67
// enable ( 10 ) ;
4240: LD_INT 10
4242: ENABLE_MARKED
// end else
4243: GO 4280
// begin if not ai_s [ 2 ] in your_bases then
4245: LD_EXP 23
4249: PUSH
4250: LD_INT 2
4252: ARRAY
4253: PUSH
4254: LD_EXP 18
4258: IN
4259: NOT
4260: IFFALSE 4280
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4262: LD_EXP 2
4266: PPUSH
4267: LD_EXP 23
4271: PUSH
4272: LD_INT 2
4274: ARRAY
4275: PPUSH
4276: CALL 30288 0 2
// end ; end ; end ;
4280: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] marked 10 do
4281: LD_LOC 2
4285: PPUSH
4286: LD_INT 20
4288: PPUSH
4289: CALL_OW 308
4293: PUSH
4294: LD_EXP 23
4298: PUSH
4299: LD_INT 1
4301: ARRAY
4302: PUSH
4303: LD_EXP 23
4307: PUSH
4308: LD_INT 2
4310: ARRAY
4311: NONEQUAL
4312: AND
4313: IFFALSE 4410
4315: GO 4317
4317: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4318: LD_EXP 37
4322: PUSH
4323: LD_INT 12
4325: LESS
4326: PUSH
4327: LD_EXP 35
4331: PUSH
4332: LD_INT 20
4334: LESS
4335: AND
4336: IFFALSE 4375
// begin DB_BaseRefuse ;
4338: CALL 4540 0 0
// while IsInArea ( Bur , b_base ) do
4342: LD_LOC 2
4346: PPUSH
4347: LD_INT 20
4349: PPUSH
4350: CALL_OW 308
4354: IFFALSE 4365
// wait ( 0 0$1 ) ;
4356: LD_INT 35
4358: PPUSH
4359: CALL_OW 67
4363: GO 4342
// wait ( 0 0$20 ) ;
4365: LD_INT 700
4367: PPUSH
4368: CALL_OW 67
// enable ;
4372: ENABLE
// end else
4373: GO 4410
// begin if not ai_s [ 2 ] in your_bases then
4375: LD_EXP 23
4379: PUSH
4380: LD_INT 2
4382: ARRAY
4383: PUSH
4384: LD_EXP 18
4388: IN
4389: NOT
4390: IFFALSE 4410
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4392: LD_EXP 2
4396: PPUSH
4397: LD_EXP 23
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: CALL 30288 0 2
// end ; end ; end ;
4410: END
// every 0 0$2 trigger humans [ 2 ] <= 6 and ai_s [ 1 ] <> ai_s [ 2 ] do
4411: LD_EXP 76
4415: PUSH
4416: LD_INT 2
4418: ARRAY
4419: PUSH
4420: LD_INT 6
4422: LESSEQUAL
4423: PUSH
4424: LD_EXP 23
4428: PUSH
4429: LD_INT 1
4431: ARRAY
4432: PUSH
4433: LD_EXP 23
4437: PUSH
4438: LD_INT 2
4440: ARRAY
4441: NONEQUAL
4442: AND
4443: IFFALSE 4483
4445: GO 4447
4447: DISABLE
// begin if not ai_s [ 2 ] in your_bases then
4448: LD_EXP 23
4452: PUSH
4453: LD_INT 2
4455: ARRAY
4456: PUSH
4457: LD_EXP 18
4461: IN
4462: NOT
4463: IFFALSE 4483
// SurrenderBase ( t_killbeat , ai_s [ 2 ] ) ;
4465: LD_EXP 6
4469: PPUSH
4470: LD_EXP 23
4474: PUSH
4475: LD_INT 2
4477: ARRAY
4478: PPUSH
4479: CALL 30288 0 2
// end ;
4483: END
// export function DB_BaseContact ; begin
4484: LD_INT 0
4486: PPUSH
// DialogueOn ;
4487: CALL_OW 6
// Say ( Bor , DB-BaseContact-Bor-1 ) ;
4491: LD_LOC 6
4495: PPUSH
4496: LD_STRING DB-BaseContact-Bor-1
4498: PPUSH
4499: CALL_OW 88
// DialogueOff ;
4503: CALL_OW 7
// end ;
4507: LD_VAR 0 1
4511: RET
// export function DB_BaseRefuse1st ; begin
4512: LD_INT 0
4514: PPUSH
// DialogueOn ;
4515: CALL_OW 6
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4519: LD_LOC 6
4523: PPUSH
4524: LD_STRING DB-BaseRefuse-Bor-1
4526: PPUSH
4527: CALL_OW 88
// DialogueOff ;
4531: CALL_OW 7
// end ;
4535: LD_VAR 0 1
4539: RET
// export function DB_BaseRefuse ; begin
4540: LD_INT 0
4542: PPUSH
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4543: LD_LOC 6
4547: PPUSH
4548: LD_STRING DB-BaseRefuse-Bor-1
4550: PPUSH
4551: CALL_OW 88
// end ;
4555: LD_VAR 0 1
4559: RET
// export function DB_BaseAccept ( first ) ; begin
4560: LD_INT 0
4562: PPUSH
// DialogueOn ;
4563: CALL_OW 6
// Say ( Bor , DB-BaseAccept-Bor-1 ) ;
4567: LD_LOC 6
4571: PPUSH
4572: LD_STRING DB-BaseAccept-Bor-1
4574: PPUSH
4575: CALL_OW 88
// if first then
4579: LD_VAR 0 1
4583: IFFALSE 4599
// Say ( Bor , DB-BaseAccept-Bor-1a ) else
4585: LD_LOC 6
4589: PPUSH
4590: LD_STRING DB-BaseAccept-Bor-1a
4592: PPUSH
4593: CALL_OW 88
4597: GO 4611
// Say ( Bor , DB-BaseAccept-Bor-1b ) ;
4599: LD_LOC 6
4603: PPUSH
4604: LD_STRING DB-BaseAccept-Bor-1b
4606: PPUSH
4607: CALL_OW 88
// DialogueOff ;
4611: CALL_OW 7
// end ;
4615: LD_VAR 0 2
4619: RET
// var jeste_nebylo ; every 0 0$2 trigger IsInArea ( Bur , c_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
4620: LD_LOC 2
4624: PPUSH
4625: LD_INT 23
4627: PPUSH
4628: CALL_OW 308
4632: PUSH
4633: LD_EXP 23
4637: PUSH
4638: LD_INT 1
4640: ARRAY
4641: PUSH
4642: LD_EXP 23
4646: PUSH
4647: LD_INT 4
4649: ARRAY
4650: NONEQUAL
4651: AND
4652: IFFALSE 4749
4654: GO 4656
4656: DISABLE
// begin jeste_nebylo := [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
4657: LD_ADDR_LOC 12
4661: PUSH
4662: LD_INT 1
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: LD_INT 3
4670: PUSH
4671: LD_INT 4
4673: PUSH
4674: LD_INT 5
4676: PUSH
4677: LD_INT 6
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: ST_TO_ADDR
// DC_BaseContact ;
4688: CALL 5444 0 0
// if otazky then
4692: CALL 4869 0 0
4696: IFFALSE 4749
// if not ai_s [ 3 ] in your_bases then
4698: LD_EXP 23
4702: PUSH
4703: LD_INT 3
4705: ARRAY
4706: PUSH
4707: LD_EXP 18
4711: IN
4712: NOT
4713: IFFALSE 4735
// SurrenderBase ( t_persuade , ai_s [ 3 ] ) else
4715: LD_EXP 3
4719: PPUSH
4720: LD_EXP 23
4724: PUSH
4725: LD_INT 3
4727: ARRAY
4728: PPUSH
4729: CALL 30288 0 2
4733: GO 4749
// begin DQrML_Wrong ;
4735: CALL 6784 0 0
// wait ( 0 0$30 ) ;
4739: LD_INT 1050
4741: PPUSH
4742: CALL_OW 67
// enable ( 11 ) ;
4746: LD_INT 11
4748: ENABLE_MARKED
// end ; end ;
4749: END
// every 0 0$2 trigger IsInArea ( Bur , c_base ) marked 11 do
4750: LD_LOC 2
4754: PPUSH
4755: LD_INT 23
4757: PPUSH
4758: CALL_OW 308
4762: IFFALSE 4795
4764: GO 4766
4766: DISABLE
// begin if not otazky then
4767: CALL 4869 0 0
4771: NOT
4772: IFFALSE 4777
// enable else
4774: ENABLE
4775: GO 4795
// SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4777: LD_EXP 2
4781: PPUSH
4782: LD_EXP 23
4786: PUSH
4787: LD_INT 2
4789: ARRAY
4790: PPUSH
4791: CALL 30288 0 2
// end ;
4795: END
// every 0 0$2 trigger humans [ 3 ] <= 2 and ai_s [ 1 ] <> ai_s [ 4 ] do
4796: LD_EXP 76
4800: PUSH
4801: LD_INT 3
4803: ARRAY
4804: PUSH
4805: LD_INT 2
4807: LESSEQUAL
4808: PUSH
4809: LD_EXP 23
4813: PUSH
4814: LD_INT 1
4816: ARRAY
4817: PUSH
4818: LD_EXP 23
4822: PUSH
4823: LD_INT 4
4825: ARRAY
4826: NONEQUAL
4827: AND
4828: IFFALSE 4868
4830: GO 4832
4832: DISABLE
// begin if not ai_s [ 3 ] in your_bases then
4833: LD_EXP 23
4837: PUSH
4838: LD_INT 3
4840: ARRAY
4841: PUSH
4842: LD_EXP 18
4846: IN
4847: NOT
4848: IFFALSE 4868
// SurrenderBase ( t_killbeat , ai_s [ 3 ] ) ;
4850: LD_EXP 6
4854: PPUSH
4855: LD_EXP 23
4859: PUSH
4860: LD_INT 3
4862: ARRAY
4863: PPUSH
4864: CALL 30288 0 2
// end ;
4868: END
// function otazky ; var qb , qg , q ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
4874: PPUSH
// DC_BaseQuestion ;
4875: CALL 5472 0 0
// qb := 0 ;
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_INT 0
4886: ST_TO_ADDR
// qg := 0 ;
4887: LD_ADDR_VAR 0 3
4891: PUSH
4892: LD_INT 0
4894: ST_TO_ADDR
// q := 0 ;
4895: LD_ADDR_VAR 0 4
4899: PUSH
4900: LD_INT 0
4902: ST_TO_ADDR
// while [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] and jeste_nebylo do
4903: LD_VAR 0 2
4907: PUSH
4908: LD_INT 2
4910: LESSEQUAL
4911: PUSH
4912: LD_VAR 0 2
4916: PUSH
4917: LD_INT 1
4919: LESSEQUAL
4920: PUSH
4921: LD_VAR 0 2
4925: PUSH
4926: LD_INT 0
4928: LESSEQUAL
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: LIST
4934: PUSH
4935: LD_OWVAR 67
4939: ARRAY
4940: PUSH
4941: LD_LOC 12
4945: AND
4946: IFFALSE 5368
// begin q := q + 1 ;
4948: LD_ADDR_VAR 0 4
4952: PUSH
4953: LD_VAR 0 4
4957: PUSH
4958: LD_INT 1
4960: PLUS
4961: ST_TO_ADDR
// case jeste_nebylo [ Rand ( 1 , jeste_nebylo ) ] of 1 :
4962: LD_LOC 12
4966: PUSH
4967: LD_INT 1
4969: PPUSH
4970: LD_LOC 12
4974: PPUSH
4975: CALL_OW 12
4979: ARRAY
4980: PUSH
4981: LD_INT 1
4983: DOUBLE
4984: EQUAL
4985: IFTRUE 4989
4987: GO 5045
4989: POP
// begin if QML1 then
4990: CALL 5500 0 0
4994: IFFALSE 5012
// qg := qg + 1 else
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 1
5008: PLUS
5009: ST_TO_ADDR
5010: GO 5026
// qb := qb + 1 ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: LD_VAR 0 2
5021: PUSH
5022: LD_INT 1
5024: PLUS
5025: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 1 ] ;
5026: LD_ADDR_LOC 12
5030: PUSH
5031: LD_LOC 12
5035: PUSH
5036: LD_INT 1
5038: PUSH
5039: EMPTY
5040: LIST
5041: DIFF
5042: ST_TO_ADDR
// end ; 2 :
5043: GO 5366
5045: LD_INT 2
5047: DOUBLE
5048: EQUAL
5049: IFTRUE 5053
5051: GO 5109
5053: POP
// begin if QML2 then
5054: CALL 5704 0 0
5058: IFFALSE 5076
// qg := qg + 1 else
5060: LD_ADDR_VAR 0 3
5064: PUSH
5065: LD_VAR 0 3
5069: PUSH
5070: LD_INT 1
5072: PLUS
5073: ST_TO_ADDR
5074: GO 5090
// qb := qb + 1 ;
5076: LD_ADDR_VAR 0 2
5080: PUSH
5081: LD_VAR 0 2
5085: PUSH
5086: LD_INT 1
5088: PLUS
5089: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 2 ] ;
5090: LD_ADDR_LOC 12
5094: PUSH
5095: LD_LOC 12
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: DIFF
5106: ST_TO_ADDR
// end ; 3 :
5107: GO 5366
5109: LD_INT 3
5111: DOUBLE
5112: EQUAL
5113: IFTRUE 5117
5115: GO 5173
5117: POP
// begin if QML3 then
5118: CALL 5908 0 0
5122: IFFALSE 5140
// qg := qg + 1 else
5124: LD_ADDR_VAR 0 3
5128: PUSH
5129: LD_VAR 0 3
5133: PUSH
5134: LD_INT 1
5136: PLUS
5137: ST_TO_ADDR
5138: GO 5154
// qb := qb + 1 ;
5140: LD_ADDR_VAR 0 2
5144: PUSH
5145: LD_VAR 0 2
5149: PUSH
5150: LD_INT 1
5152: PLUS
5153: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 3 ] ;
5154: LD_ADDR_LOC 12
5158: PUSH
5159: LD_LOC 12
5163: PUSH
5164: LD_INT 3
5166: PUSH
5167: EMPTY
5168: LIST
5169: DIFF
5170: ST_TO_ADDR
// end ; 4 :
5171: GO 5366
5173: LD_INT 4
5175: DOUBLE
5176: EQUAL
5177: IFTRUE 5181
5179: GO 5237
5181: POP
// begin if QML4 then
5182: CALL 6112 0 0
5186: IFFALSE 5204
// qg := qg + 1 else
5188: LD_ADDR_VAR 0 3
5192: PUSH
5193: LD_VAR 0 3
5197: PUSH
5198: LD_INT 1
5200: PLUS
5201: ST_TO_ADDR
5202: GO 5218
// qb := qb + 1 ;
5204: LD_ADDR_VAR 0 2
5208: PUSH
5209: LD_VAR 0 2
5213: PUSH
5214: LD_INT 1
5216: PLUS
5217: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 4 ] ;
5218: LD_ADDR_LOC 12
5222: PUSH
5223: LD_LOC 12
5227: PUSH
5228: LD_INT 4
5230: PUSH
5231: EMPTY
5232: LIST
5233: DIFF
5234: ST_TO_ADDR
// end ; 5 :
5235: GO 5366
5237: LD_INT 5
5239: DOUBLE
5240: EQUAL
5241: IFTRUE 5245
5243: GO 5301
5245: POP
// begin if QML5 then
5246: CALL 6316 0 0
5250: IFFALSE 5268
// qg := qg + 1 else
5252: LD_ADDR_VAR 0 3
5256: PUSH
5257: LD_VAR 0 3
5261: PUSH
5262: LD_INT 1
5264: PLUS
5265: ST_TO_ADDR
5266: GO 5282
// qb := qb + 1 ;
5268: LD_ADDR_VAR 0 2
5272: PUSH
5273: LD_VAR 0 2
5277: PUSH
5278: LD_INT 1
5280: PLUS
5281: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 5 ] ;
5282: LD_ADDR_LOC 12
5286: PUSH
5287: LD_LOC 12
5291: PUSH
5292: LD_INT 5
5294: PUSH
5295: EMPTY
5296: LIST
5297: DIFF
5298: ST_TO_ADDR
// end ; 6 :
5299: GO 5366
5301: LD_INT 6
5303: DOUBLE
5304: EQUAL
5305: IFTRUE 5309
5307: GO 5365
5309: POP
// begin if QML6 then
5310: CALL 6520 0 0
5314: IFFALSE 5332
// qg := qg + 1 else
5316: LD_ADDR_VAR 0 3
5320: PUSH
5321: LD_VAR 0 3
5325: PUSH
5326: LD_INT 1
5328: PLUS
5329: ST_TO_ADDR
5330: GO 5346
// qb := qb + 1 ;
5332: LD_ADDR_VAR 0 2
5336: PUSH
5337: LD_VAR 0 2
5341: PUSH
5342: LD_INT 1
5344: PLUS
5345: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 6 ] ;
5346: LD_ADDR_LOC 12
5350: PUSH
5351: LD_LOC 12
5355: PUSH
5356: LD_INT 6
5358: PUSH
5359: EMPTY
5360: LIST
5361: DIFF
5362: ST_TO_ADDR
// end ; end ;
5363: GO 5366
5365: POP
// end ;
5366: GO 4903
// if qg = 6 then
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 6
5375: EQUAL
5376: IFFALSE 5382
// SA_OnTsaritsynQuizPerfectCleared ;
5378: CALL 33086 0 0
// if [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] then
5382: LD_VAR 0 2
5386: PUSH
5387: LD_INT 2
5389: LESSEQUAL
5390: PUSH
5391: LD_VAR 0 2
5395: PUSH
5396: LD_INT 1
5398: LESSEQUAL
5399: PUSH
5400: LD_VAR 0 2
5404: PUSH
5405: LD_INT 0
5407: LESSEQUAL
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: PUSH
5414: LD_OWVAR 67
5418: ARRAY
5419: IFFALSE 5431
// result := true else
5421: LD_ADDR_VAR 0 1
5425: PUSH
5426: LD_INT 1
5428: ST_TO_ADDR
5429: GO 5439
// result := false ;
5431: LD_ADDR_VAR 0 1
5435: PUSH
5436: LD_INT 0
5438: ST_TO_ADDR
// end ;
5439: LD_VAR 0 1
5443: RET
// export function DC_BaseContact ; begin
5444: LD_INT 0
5446: PPUSH
// DialogueOn ;
5447: CALL_OW 6
// Say ( Tsr , DC-BaseContact-Tsr-1 ) ;
5451: LD_LOC 7
5455: PPUSH
5456: LD_STRING DC-BaseContact-Tsr-1
5458: PPUSH
5459: CALL_OW 88
// DialogueOff ;
5463: CALL_OW 7
// end ;
5467: LD_VAR 0 1
5471: RET
// export function DC_BaseQuestion ; begin
5472: LD_INT 0
5474: PPUSH
// DialogueOn ;
5475: CALL_OW 6
// Say ( Tsr , DC-BaseQuestion-Tsr-1 ) ;
5479: LD_LOC 7
5483: PPUSH
5484: LD_STRING DC-BaseQuestion-Tsr-1
5486: PPUSH
5487: CALL_OW 88
// DialogueOff ;
5491: CALL_OW 7
// end ;
5495: LD_VAR 0 1
5499: RET
// function QML1 ; var mozn , qr , a , bad ; begin
5500: LD_INT 0
5502: PPUSH
5503: PPUSH
5504: PPUSH
5505: PPUSH
5506: PPUSH
// bad := [ 1 , 3 ] ;
5507: LD_ADDR_VAR 0 5
5511: PUSH
5512: LD_INT 1
5514: PUSH
5515: LD_INT 3
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5522: LD_ADDR_VAR 0 2
5526: PUSH
5527: LD_INT 1
5529: PUSH
5530: LD_INT 2
5532: PUSH
5533: LD_INT 3
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: ST_TO_ADDR
// if IsOk ( Gleb ) then
5541: LD_EXP 50
5545: PPUSH
5546: CALL_OW 302
5550: IFFALSE 5569
// mozn := mozn ^ [ 4 ] ;
5552: LD_ADDR_VAR 0 2
5556: PUSH
5557: LD_VAR 0 2
5561: PUSH
5562: LD_INT 4
5564: PUSH
5565: EMPTY
5566: LIST
5567: ADD
5568: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5569: LD_ADDR_VAR 0 3
5573: PUSH
5574: LD_STRING QML1
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 98
5586: ST_TO_ADDR
// if qr = 4 then
5587: LD_VAR 0 3
5591: PUSH
5592: LD_INT 4
5594: EQUAL
5595: IFFALSE 5669
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5597: LD_ADDR_VAR 0 4
5601: PUSH
5602: LD_VAR 0 5
5606: PUSH
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PPUSH
5613: CALL_OW 12
5617: ARRAY
5618: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5619: LD_VAR 0 4
5623: PPUSH
5624: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
5628: LD_ADDR_VAR 0 2
5632: PUSH
5633: LD_VAR 0 2
5637: PUSH
5638: LD_VAR 0 4
5642: PUSH
5643: LD_INT 4
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: DIFF
5650: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5651: LD_ADDR_VAR 0 3
5655: PUSH
5656: LD_STRING QML1
5658: PPUSH
5659: LD_VAR 0 2
5663: PPUSH
5664: CALL_OW 98
5668: ST_TO_ADDR
// end ; if qr in bad then
5669: LD_VAR 0 3
5673: PUSH
5674: LD_VAR 0 5
5678: IN
5679: IFFALSE 5691
// result := false else
5681: LD_ADDR_VAR 0 1
5685: PUSH
5686: LD_INT 0
5688: ST_TO_ADDR
5689: GO 5699
// result := true ;
5691: LD_ADDR_VAR 0 1
5695: PUSH
5696: LD_INT 1
5698: ST_TO_ADDR
// end ;
5699: LD_VAR 0 1
5703: RET
// function QML2 ; var mozn , qr , a , bad ; begin
5704: LD_INT 0
5706: PPUSH
5707: PPUSH
5708: PPUSH
5709: PPUSH
5710: PPUSH
// bad := [ 2 , 3 ] ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 3
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5726: LD_ADDR_VAR 0 2
5730: PUSH
5731: LD_INT 1
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 3
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: ST_TO_ADDR
// if IsOk ( Gleb ) then
5745: LD_EXP 50
5749: PPUSH
5750: CALL_OW 302
5754: IFFALSE 5773
// mozn := mozn ^ [ 4 ] ;
5756: LD_ADDR_VAR 0 2
5760: PUSH
5761: LD_VAR 0 2
5765: PUSH
5766: LD_INT 4
5768: PUSH
5769: EMPTY
5770: LIST
5771: ADD
5772: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5773: LD_ADDR_VAR 0 3
5777: PUSH
5778: LD_STRING QML2
5780: PPUSH
5781: LD_VAR 0 2
5785: PPUSH
5786: CALL_OW 98
5790: ST_TO_ADDR
// if qr = 4 then
5791: LD_VAR 0 3
5795: PUSH
5796: LD_INT 4
5798: EQUAL
5799: IFFALSE 5873
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5801: LD_ADDR_VAR 0 4
5805: PUSH
5806: LD_VAR 0 5
5810: PUSH
5811: LD_INT 1
5813: PPUSH
5814: LD_INT 2
5816: PPUSH
5817: CALL_OW 12
5821: ARRAY
5822: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5823: LD_VAR 0 4
5827: PPUSH
5828: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
5832: LD_ADDR_VAR 0 2
5836: PUSH
5837: LD_VAR 0 2
5841: PUSH
5842: LD_VAR 0 4
5846: PUSH
5847: LD_INT 4
5849: PUSH
5850: EMPTY
5851: LIST
5852: LIST
5853: DIFF
5854: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5855: LD_ADDR_VAR 0 3
5859: PUSH
5860: LD_STRING QML2
5862: PPUSH
5863: LD_VAR 0 2
5867: PPUSH
5868: CALL_OW 98
5872: ST_TO_ADDR
// end ; if qr in bad then
5873: LD_VAR 0 3
5877: PUSH
5878: LD_VAR 0 5
5882: IN
5883: IFFALSE 5895
// result := false else
5885: LD_ADDR_VAR 0 1
5889: PUSH
5890: LD_INT 0
5892: ST_TO_ADDR
5893: GO 5903
// result := true ;
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: LD_INT 1
5902: ST_TO_ADDR
// end ;
5903: LD_VAR 0 1
5907: RET
// function QML3 ; var mozn , qr , a , bad ; begin
5908: LD_INT 0
5910: PPUSH
5911: PPUSH
5912: PPUSH
5913: PPUSH
5914: PPUSH
// bad := [ 1 , 3 ] ;
5915: LD_ADDR_VAR 0 5
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 3
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5930: LD_ADDR_VAR 0 2
5934: PUSH
5935: LD_INT 1
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 3
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: LIST
5948: ST_TO_ADDR
// if IsOk ( Gleb ) then
5949: LD_EXP 50
5953: PPUSH
5954: CALL_OW 302
5958: IFFALSE 5977
// mozn := mozn ^ [ 4 ] ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PUSH
5970: LD_INT 4
5972: PUSH
5973: EMPTY
5974: LIST
5975: ADD
5976: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
5977: LD_ADDR_VAR 0 3
5981: PUSH
5982: LD_STRING QML3
5984: PPUSH
5985: LD_VAR 0 2
5989: PPUSH
5990: CALL_OW 98
5994: ST_TO_ADDR
// if qr = 4 then
5995: LD_VAR 0 3
5999: PUSH
6000: LD_INT 4
6002: EQUAL
6003: IFFALSE 6077
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6005: LD_ADDR_VAR 0 4
6009: PUSH
6010: LD_VAR 0 5
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6027: LD_VAR 0 4
6031: PPUSH
6032: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
6036: LD_ADDR_VAR 0 2
6040: PUSH
6041: LD_VAR 0 2
6045: PUSH
6046: LD_VAR 0 4
6050: PUSH
6051: LD_INT 4
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: DIFF
6058: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6059: LD_ADDR_VAR 0 3
6063: PUSH
6064: LD_STRING QML3
6066: PPUSH
6067: LD_VAR 0 2
6071: PPUSH
6072: CALL_OW 98
6076: ST_TO_ADDR
// end ; if qr in bad then
6077: LD_VAR 0 3
6081: PUSH
6082: LD_VAR 0 5
6086: IN
6087: IFFALSE 6099
// result := false else
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: LD_INT 0
6096: ST_TO_ADDR
6097: GO 6107
// result := true ;
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_INT 1
6106: ST_TO_ADDR
// end ;
6107: LD_VAR 0 1
6111: RET
// function QML4 ; var mozn , qr , a , bad ; begin
6112: LD_INT 0
6114: PPUSH
6115: PPUSH
6116: PPUSH
6117: PPUSH
6118: PPUSH
// bad := [ 1 , 2 ] ;
6119: LD_ADDR_VAR 0 5
6123: PUSH
6124: LD_INT 1
6126: PUSH
6127: LD_INT 2
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6134: LD_ADDR_VAR 0 2
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 3
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: ST_TO_ADDR
// if IsOk ( Gleb ) then
6153: LD_EXP 50
6157: PPUSH
6158: CALL_OW 302
6162: IFFALSE 6181
// mozn := mozn ^ [ 4 ] ;
6164: LD_ADDR_VAR 0 2
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: LD_INT 4
6176: PUSH
6177: EMPTY
6178: LIST
6179: ADD
6180: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6181: LD_ADDR_VAR 0 3
6185: PUSH
6186: LD_STRING QML4
6188: PPUSH
6189: LD_VAR 0 2
6193: PPUSH
6194: CALL_OW 98
6198: ST_TO_ADDR
// if qr = 4 then
6199: LD_VAR 0 3
6203: PUSH
6204: LD_INT 4
6206: EQUAL
6207: IFFALSE 6281
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6209: LD_ADDR_VAR 0 4
6213: PUSH
6214: LD_VAR 0 5
6218: PUSH
6219: LD_INT 1
6221: PPUSH
6222: LD_INT 2
6224: PPUSH
6225: CALL_OW 12
6229: ARRAY
6230: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6231: LD_VAR 0 4
6235: PPUSH
6236: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_VAR 0 2
6249: PUSH
6250: LD_VAR 0 4
6254: PUSH
6255: LD_INT 4
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: DIFF
6262: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6263: LD_ADDR_VAR 0 3
6267: PUSH
6268: LD_STRING QML4
6270: PPUSH
6271: LD_VAR 0 2
6275: PPUSH
6276: CALL_OW 98
6280: ST_TO_ADDR
// end ; if qr in bad then
6281: LD_VAR 0 3
6285: PUSH
6286: LD_VAR 0 5
6290: IN
6291: IFFALSE 6303
// result := false else
6293: LD_ADDR_VAR 0 1
6297: PUSH
6298: LD_INT 0
6300: ST_TO_ADDR
6301: GO 6311
// result := true ;
6303: LD_ADDR_VAR 0 1
6307: PUSH
6308: LD_INT 1
6310: ST_TO_ADDR
// end ;
6311: LD_VAR 0 1
6315: RET
// function QML5 ; var mozn , qr , a , bad ; begin
6316: LD_INT 0
6318: PPUSH
6319: PPUSH
6320: PPUSH
6321: PPUSH
6322: PPUSH
// bad := [ 1 , 3 ] ;
6323: LD_ADDR_VAR 0 5
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 3
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_INT 1
6345: PUSH
6346: LD_INT 2
6348: PUSH
6349: LD_INT 3
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: ST_TO_ADDR
// if IsOk ( Gleb ) then
6357: LD_EXP 50
6361: PPUSH
6362: CALL_OW 302
6366: IFFALSE 6385
// mozn := mozn ^ [ 4 ] ;
6368: LD_ADDR_VAR 0 2
6372: PUSH
6373: LD_VAR 0 2
6377: PUSH
6378: LD_INT 4
6380: PUSH
6381: EMPTY
6382: LIST
6383: ADD
6384: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6385: LD_ADDR_VAR 0 3
6389: PUSH
6390: LD_STRING QML5
6392: PPUSH
6393: LD_VAR 0 2
6397: PPUSH
6398: CALL_OW 98
6402: ST_TO_ADDR
// if qr = 4 then
6403: LD_VAR 0 3
6407: PUSH
6408: LD_INT 4
6410: EQUAL
6411: IFFALSE 6485
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6413: LD_ADDR_VAR 0 4
6417: PUSH
6418: LD_VAR 0 5
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6435: LD_VAR 0 4
6439: PPUSH
6440: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
6444: LD_ADDR_VAR 0 2
6448: PUSH
6449: LD_VAR 0 2
6453: PUSH
6454: LD_VAR 0 4
6458: PUSH
6459: LD_INT 4
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: DIFF
6466: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6467: LD_ADDR_VAR 0 3
6471: PUSH
6472: LD_STRING QML5
6474: PPUSH
6475: LD_VAR 0 2
6479: PPUSH
6480: CALL_OW 98
6484: ST_TO_ADDR
// end ; if qr in bad then
6485: LD_VAR 0 3
6489: PUSH
6490: LD_VAR 0 5
6494: IN
6495: IFFALSE 6507
// result := false else
6497: LD_ADDR_VAR 0 1
6501: PUSH
6502: LD_INT 0
6504: ST_TO_ADDR
6505: GO 6515
// result := true ;
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: LD_INT 1
6514: ST_TO_ADDR
// end ;
6515: LD_VAR 0 1
6519: RET
// function QML6 ; var mozn , qr , a , bad ; begin
6520: LD_INT 0
6522: PPUSH
6523: PPUSH
6524: PPUSH
6525: PPUSH
6526: PPUSH
// bad := [ 2 , 3 ] ;
6527: LD_ADDR_VAR 0 5
6531: PUSH
6532: LD_INT 2
6534: PUSH
6535: LD_INT 3
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6542: LD_ADDR_VAR 0 2
6546: PUSH
6547: LD_INT 1
6549: PUSH
6550: LD_INT 2
6552: PUSH
6553: LD_INT 3
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: ST_TO_ADDR
// if IsOk ( Gleb ) then
6561: LD_EXP 50
6565: PPUSH
6566: CALL_OW 302
6570: IFFALSE 6589
// mozn := mozn ^ [ 4 ] ;
6572: LD_ADDR_VAR 0 2
6576: PUSH
6577: LD_VAR 0 2
6581: PUSH
6582: LD_INT 4
6584: PUSH
6585: EMPTY
6586: LIST
6587: ADD
6588: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6589: LD_ADDR_VAR 0 3
6593: PUSH
6594: LD_STRING QML6
6596: PPUSH
6597: LD_VAR 0 2
6601: PPUSH
6602: CALL_OW 98
6606: ST_TO_ADDR
// if qr = 4 then
6607: LD_VAR 0 3
6611: PUSH
6612: LD_INT 4
6614: EQUAL
6615: IFFALSE 6689
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6617: LD_ADDR_VAR 0 4
6621: PUSH
6622: LD_VAR 0 5
6626: PUSH
6627: LD_INT 1
6629: PPUSH
6630: LD_INT 2
6632: PPUSH
6633: CALL_OW 12
6637: ARRAY
6638: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6639: LD_VAR 0 4
6643: PPUSH
6644: CALL 6812 0 1
// mozn := mozn diff [ a , 4 ] ;
6648: LD_ADDR_VAR 0 2
6652: PUSH
6653: LD_VAR 0 2
6657: PUSH
6658: LD_VAR 0 4
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: DIFF
6670: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6671: LD_ADDR_VAR 0 3
6675: PUSH
6676: LD_STRING QML6
6678: PPUSH
6679: LD_VAR 0 2
6683: PPUSH
6684: CALL_OW 98
6688: ST_TO_ADDR
// end ; if qr in bad then
6689: LD_VAR 0 3
6693: PUSH
6694: LD_VAR 0 5
6698: IN
6699: IFFALSE 6711
// result := false else
6701: LD_ADDR_VAR 0 1
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
6709: GO 6719
// result := true ;
6711: LD_ADDR_VAR 0 1
6715: PUSH
6716: LD_INT 1
6718: ST_TO_ADDR
// end ;
6719: LD_VAR 0 1
6723: RET
// export function DQrML_Right ( first ) ; begin
6724: LD_INT 0
6726: PPUSH
// DialogueOn ;
6727: CALL_OW 6
// Say ( Tsr , DQrML#Right-Tsr-1 ) ;
6731: LD_LOC 7
6735: PPUSH
6736: LD_STRING DQrML#Right-Tsr-1
6738: PPUSH
6739: CALL_OW 88
// if first then
6743: LD_VAR 0 1
6747: IFFALSE 6763
// Say ( Tsr , DQrML#Right-Tsr-1a ) else
6749: LD_LOC 7
6753: PPUSH
6754: LD_STRING DQrML#Right-Tsr-1a
6756: PPUSH
6757: CALL_OW 88
6761: GO 6775
// Say ( Tsr , DQrML#Right-Tsr-1b ) ;
6763: LD_LOC 7
6767: PPUSH
6768: LD_STRING DQrML#Right-Tsr-1b
6770: PPUSH
6771: CALL_OW 88
// DialogueOff ;
6775: CALL_OW 7
// end ;
6779: LD_VAR 0 2
6783: RET
// export function DQrML_Wrong ; begin
6784: LD_INT 0
6786: PPUSH
// DialogueOn ;
6787: CALL_OW 6
// Say ( Tsr , DQrML#Wrong-Tsr-1 ) ;
6791: LD_LOC 7
6795: PPUSH
6796: LD_STRING DQrML#Wrong-Tsr-1
6798: PPUSH
6799: CALL_OW 88
// DialogueOff ;
6803: CALL_OW 7
// end ;
6807: LD_VAR 0 1
6811: RET
// function DQrML_Gleb ( num ) ; begin
6812: LD_INT 0
6814: PPUSH
// DialogueOn ;
6815: CALL_OW 6
// case num of 1 :
6819: LD_VAR 0 1
6823: PUSH
6824: LD_INT 1
6826: DOUBLE
6827: EQUAL
6828: IFTRUE 6832
6830: GO 6847
6832: POP
// Say ( Glb , DQrML#Gleb-Glb-1 ) ; 2 :
6833: LD_LOC 10
6837: PPUSH
6838: LD_STRING DQrML#Gleb-Glb-1
6840: PPUSH
6841: CALL_OW 88
6845: GO 6894
6847: LD_INT 2
6849: DOUBLE
6850: EQUAL
6851: IFTRUE 6855
6853: GO 6870
6855: POP
// Say ( Glb , DQrML#Gleb-Glb-1a ) ; 3 :
6856: LD_LOC 10
6860: PPUSH
6861: LD_STRING DQrML#Gleb-Glb-1a
6863: PPUSH
6864: CALL_OW 88
6868: GO 6894
6870: LD_INT 3
6872: DOUBLE
6873: EQUAL
6874: IFTRUE 6878
6876: GO 6893
6878: POP
// Say ( Glb , DQrML#Gleb-Glb-1b ) ; end ;
6879: LD_LOC 10
6883: PPUSH
6884: LD_STRING DQrML#Gleb-Glb-1b
6886: PPUSH
6887: CALL_OW 88
6891: GO 6894
6893: POP
// DialogueOff ;
6894: CALL_OW 7
// end ;
6898: LD_VAR 0 2
6902: RET
// export maji_artifact ; every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
6903: LD_LOC 2
6907: PPUSH
6908: LD_INT 22
6910: PPUSH
6911: CALL_OW 308
6915: PUSH
6916: LD_EXP 23
6920: PUSH
6921: LD_INT 1
6923: ARRAY
6924: PUSH
6925: LD_EXP 23
6929: PUSH
6930: LD_INT 4
6932: ARRAY
6933: NONEQUAL
6934: AND
6935: IFFALSE 7025
6937: GO 6939
6939: DISABLE
// begin DD_BaseContact ;
6940: CALL 7192 0 0
// if maji_artifact then
6944: LD_EXP 39
6948: IFFALSE 6987
// begin if not ai_s [ 4 ] in your_bases then
6950: LD_EXP 23
6954: PUSH
6955: LD_INT 4
6957: ARRAY
6958: PUSH
6959: LD_EXP 18
6963: IN
6964: NOT
6965: IFFALSE 6985
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
6967: LD_EXP 4
6971: PPUSH
6972: LD_EXP 23
6976: PUSH
6977: LD_INT 4
6979: ARRAY
6980: PPUSH
6981: CALL 30288 0 2
// end else
6985: GO 7022
// begin DD_BaseRefuse1st ;
6987: CALL 7240 0 0
// while IsInArea ( Bur , d_base ) do
6991: LD_LOC 2
6995: PPUSH
6996: LD_INT 22
6998: PPUSH
6999: CALL_OW 308
7003: IFFALSE 7014
// wait ( 0 0$1 ) ;
7005: LD_INT 35
7007: PPUSH
7008: CALL_OW 67
7012: GO 6991
// wait ( 0 0$20 ) ;
7014: LD_INT 700
7016: PPUSH
7017: CALL_OW 67
// enable ;
7021: ENABLE
// end ; enable ( 12 ) ;
7022: LD_INT 12
7024: ENABLE_MARKED
// end ;
7025: END
// every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] marked 12 do
7026: LD_LOC 2
7030: PPUSH
7031: LD_INT 22
7033: PPUSH
7034: CALL_OW 308
7038: PUSH
7039: LD_EXP 23
7043: PUSH
7044: LD_INT 1
7046: ARRAY
7047: PUSH
7048: LD_EXP 23
7052: PUSH
7053: LD_INT 4
7055: ARRAY
7056: NONEQUAL
7057: AND
7058: IFFALSE 7118
7060: GO 7062
7062: DISABLE
// begin if maji_artifact then
7063: LD_EXP 39
7067: IFFALSE 7106
// begin if not ai_s [ 4 ] in your_bases then
7069: LD_EXP 23
7073: PUSH
7074: LD_INT 4
7076: ARRAY
7077: PUSH
7078: LD_EXP 18
7082: IN
7083: NOT
7084: IFFALSE 7104
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7086: LD_EXP 4
7090: PPUSH
7091: LD_EXP 23
7095: PUSH
7096: LD_INT 4
7098: ARRAY
7099: PPUSH
7100: CALL 30288 0 2
// end else
7104: GO 7118
// begin DD_BaseRefuse ;
7106: CALL 7268 0 0
// wait ( 0 0$20 ) ;
7110: LD_INT 700
7112: PPUSH
7113: CALL_OW 67
// enable ;
7117: ENABLE
// end ; end ;
7118: END
// every 0 0$2 trigger humans [ 4 ] <= 4 and ai_s [ 1 ] <> ai_s [ 4 ] do
7119: LD_EXP 76
7123: PUSH
7124: LD_INT 4
7126: ARRAY
7127: PUSH
7128: LD_INT 4
7130: LESSEQUAL
7131: PUSH
7132: LD_EXP 23
7136: PUSH
7137: LD_INT 1
7139: ARRAY
7140: PUSH
7141: LD_EXP 23
7145: PUSH
7146: LD_INT 4
7148: ARRAY
7149: NONEQUAL
7150: AND
7151: IFFALSE 7191
7153: GO 7155
7155: DISABLE
// begin if not ai_s [ 4 ] in your_bases then
7156: LD_EXP 23
7160: PUSH
7161: LD_INT 4
7163: ARRAY
7164: PUSH
7165: LD_EXP 18
7169: IN
7170: NOT
7171: IFFALSE 7191
// SurrenderBase ( t_killbeat , ai_s [ 4 ] ) ;
7173: LD_EXP 6
7177: PPUSH
7178: LD_EXP 23
7182: PUSH
7183: LD_INT 4
7185: ARRAY
7186: PPUSH
7187: CALL 30288 0 2
// end ;
7191: END
// export kecali_o_artefaktu ; export function DD_BaseContact ; begin
7192: LD_INT 0
7194: PPUSH
// DialogueOn ;
7195: CALL_OW 6
// Say ( Dav , DD-BaseContact-Dav-1 ) ;
7199: LD_LOC 8
7203: PPUSH
7204: LD_STRING DD-BaseContact-Dav-1
7206: PPUSH
7207: CALL_OW 88
// Say ( Bur , DD-BaseContact-Bur-1 ) ;
7211: LD_LOC 2
7215: PPUSH
7216: LD_STRING DD-BaseContact-Bur-1
7218: PPUSH
7219: CALL_OW 88
// kecali_o_artefaktu := true ;
7223: LD_ADDR_EXP 40
7227: PUSH
7228: LD_INT 1
7230: ST_TO_ADDR
// DialogueOff ;
7231: CALL_OW 7
// end ;
7235: LD_VAR 0 1
7239: RET
// export function DD_BaseRefuse1st ; begin
7240: LD_INT 0
7242: PPUSH
// DialogueOn ;
7243: CALL_OW 6
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7247: LD_LOC 8
7251: PPUSH
7252: LD_STRING DD-BaseRefuse-Dav-1
7254: PPUSH
7255: CALL_OW 88
// DialogueOff ;
7259: CALL_OW 7
// end ;
7263: LD_VAR 0 1
7267: RET
// export function DD_BaseRefuse ; begin
7268: LD_INT 0
7270: PPUSH
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7271: LD_LOC 8
7275: PPUSH
7276: LD_STRING DD-BaseRefuse-Dav-1
7278: PPUSH
7279: CALL_OW 88
// end ;
7283: LD_VAR 0 1
7287: RET
// export function DD_BaseAccept ( first ) ; begin
7288: LD_INT 0
7290: PPUSH
// DialogueOn ;
7291: CALL_OW 6
// Say ( Dav , DD-BaseAccept-Dav-1 ) ;
7295: LD_LOC 8
7299: PPUSH
7300: LD_STRING DD-BaseAccept-Dav-1
7302: PPUSH
7303: CALL_OW 88
// if first then
7307: LD_VAR 0 1
7311: IFFALSE 7327
// Say ( Dav , DD-BaseAccept-Dav-1a ) else
7313: LD_LOC 8
7317: PPUSH
7318: LD_STRING DD-BaseAccept-Dav-1a
7320: PPUSH
7321: CALL_OW 88
7325: GO 7339
// Say ( Dav , DD-BaseAccept-Dav-1b ) ;
7327: LD_LOC 8
7331: PPUSH
7332: LD_STRING DD-BaseAccept-Dav-1b
7334: PPUSH
7335: CALL_OW 88
// DialogueOff ;
7339: CALL_OW 7
// end ;
7343: LD_VAR 0 2
7347: RET
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] do
7348: LD_LOC 2
7352: PPUSH
7353: LD_INT 21
7355: PPUSH
7356: CALL_OW 308
7360: PUSH
7361: LD_EXP 23
7365: PUSH
7366: LD_INT 1
7368: ARRAY
7369: PUSH
7370: LD_EXP 23
7374: PUSH
7375: LD_INT 5
7377: ARRAY
7378: NONEQUAL
7379: AND
7380: IFFALSE 7491
7382: GO 7384
7384: DISABLE
// begin DE_BaseContact ;
7385: CALL 7753 0 0
// if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7389: LD_EXP 76
7393: PUSH
7394: LD_INT 5
7396: ARRAY
7397: PPUSH
7398: LD_INT 50
7400: PUSH
7401: EMPTY
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: PPUSH
7407: CALL_OW 72
7411: PUSH
7412: LD_INT 6
7414: GREATER
7415: IFFALSE 7456
// begin DE_BaseRefuse1st ;
7417: CALL 7793 0 0
// while IsInArea ( Bur , e_base ) do
7421: LD_LOC 2
7425: PPUSH
7426: LD_INT 21
7428: PPUSH
7429: CALL_OW 308
7433: IFFALSE 7444
// wait ( 0 0$1 ) ;
7435: LD_INT 35
7437: PPUSH
7438: CALL_OW 67
7442: GO 7421
// wait ( 0 0$20 ) ;
7444: LD_INT 700
7446: PPUSH
7447: CALL_OW 67
// enable ( 115 ) ;
7451: LD_INT 115
7453: ENABLE_MARKED
// end else
7454: GO 7491
// if not ai_s [ 5 ] in your_bases then
7456: LD_EXP 23
7460: PUSH
7461: LD_INT 5
7463: ARRAY
7464: PUSH
7465: LD_EXP 18
7469: IN
7470: NOT
7471: IFFALSE 7491
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7473: LD_EXP 5
7477: PPUSH
7478: LD_EXP 23
7482: PUSH
7483: LD_INT 5
7485: ARRAY
7486: PPUSH
7487: CALL 30288 0 2
// end ;
7491: END
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] marked 115 do
7492: LD_LOC 2
7496: PPUSH
7497: LD_INT 21
7499: PPUSH
7500: CALL_OW 308
7504: PUSH
7505: LD_EXP 23
7509: PUSH
7510: LD_INT 1
7512: ARRAY
7513: PUSH
7514: LD_EXP 23
7518: PUSH
7519: LD_INT 5
7521: ARRAY
7522: NONEQUAL
7523: AND
7524: IFFALSE 7592
7526: GO 7528
7528: DISABLE
// begin if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7529: LD_EXP 76
7533: PUSH
7534: LD_INT 5
7536: ARRAY
7537: PPUSH
7538: LD_INT 50
7540: PUSH
7541: EMPTY
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: PPUSH
7547: CALL_OW 72
7551: PUSH
7552: LD_INT 6
7554: GREATER
7555: IFFALSE 7591
// begin DE_BaseRefuse ;
7557: CALL 7821 0 0
// while IsInArea ( Bur , e_base ) do
7561: LD_LOC 2
7565: PPUSH
7566: LD_INT 21
7568: PPUSH
7569: CALL_OW 308
7573: IFFALSE 7584
// wait ( 0 0$1 ) ;
7575: LD_INT 35
7577: PPUSH
7578: CALL_OW 67
7582: GO 7561
// wait ( 0 0$20 ) ;
7584: LD_INT 700
7586: PPUSH
7587: CALL_OW 67
// end ; enable ;
7591: ENABLE
// end ;
7592: END
// every 0 0$2 trigger UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) <= 6 and ai_s [ 1 ] <> ai_s [ 5 ] do
7593: LD_EXP 76
7597: PUSH
7598: LD_INT 5
7600: ARRAY
7601: PPUSH
7602: LD_INT 50
7604: PUSH
7605: EMPTY
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: PPUSH
7611: CALL_OW 72
7615: PUSH
7616: LD_INT 6
7618: LESSEQUAL
7619: PUSH
7620: LD_EXP 23
7624: PUSH
7625: LD_INT 1
7627: ARRAY
7628: PUSH
7629: LD_EXP 23
7633: PUSH
7634: LD_INT 5
7636: ARRAY
7637: NONEQUAL
7638: AND
7639: IFFALSE 7679
7641: GO 7643
7643: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7644: LD_EXP 23
7648: PUSH
7649: LD_INT 5
7651: ARRAY
7652: PUSH
7653: LD_EXP 18
7657: IN
7658: NOT
7659: IFFALSE 7679
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7661: LD_EXP 5
7665: PPUSH
7666: LD_EXP 23
7670: PUSH
7671: LD_INT 5
7673: ARRAY
7674: PPUSH
7675: CALL 30288 0 2
// end ;
7679: END
// every 0 0$2 trigger humans [ 5 ] <= 4 and ai_s [ 1 ] <> ai_s [ 5 ] do
7680: LD_EXP 76
7684: PUSH
7685: LD_INT 5
7687: ARRAY
7688: PUSH
7689: LD_INT 4
7691: LESSEQUAL
7692: PUSH
7693: LD_EXP 23
7697: PUSH
7698: LD_INT 1
7700: ARRAY
7701: PUSH
7702: LD_EXP 23
7706: PUSH
7707: LD_INT 5
7709: ARRAY
7710: NONEQUAL
7711: AND
7712: IFFALSE 7752
7714: GO 7716
7716: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7717: LD_EXP 23
7721: PUSH
7722: LD_INT 5
7724: ARRAY
7725: PUSH
7726: LD_EXP 18
7730: IN
7731: NOT
7732: IFFALSE 7752
// SurrenderBase ( t_killbeat , ai_s [ 5 ] ) ;
7734: LD_EXP 6
7738: PPUSH
7739: LD_EXP 23
7743: PUSH
7744: LD_INT 5
7746: ARRAY
7747: PPUSH
7748: CALL 30288 0 2
// end ;
7752: END
// export function DE_BaseContact ; begin
7753: LD_INT 0
7755: PPUSH
// DialogueOn ;
7756: CALL_OW 6
// Say ( Eis , DE-BaseContact-Eis-1 ) ;
7760: LD_LOC 9
7764: PPUSH
7765: LD_STRING DE-BaseContact-Eis-1
7767: PPUSH
7768: CALL_OW 88
// Say ( Bur , DE-BaseContact-Bur-1 ) ;
7772: LD_LOC 2
7776: PPUSH
7777: LD_STRING DE-BaseContact-Bur-1
7779: PPUSH
7780: CALL_OW 88
// DialogueOff ;
7784: CALL_OW 7
// end ;
7788: LD_VAR 0 1
7792: RET
// export function DE_BaseRefuse1st ; begin
7793: LD_INT 0
7795: PPUSH
// DialogueOn ;
7796: CALL_OW 6
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7800: LD_LOC 9
7804: PPUSH
7805: LD_STRING DE-BaseRefuse-Eis-1
7807: PPUSH
7808: CALL_OW 88
// DialogueOff ;
7812: CALL_OW 7
// end ;
7816: LD_VAR 0 1
7820: RET
// export function DE_BaseRefuse ; begin
7821: LD_INT 0
7823: PPUSH
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7824: LD_LOC 9
7828: PPUSH
7829: LD_STRING DE-BaseRefuse-Eis-1
7831: PPUSH
7832: CALL_OW 88
// end ;
7836: LD_VAR 0 1
7840: RET
// export function DE_BaseAccept ( first ) ; begin
7841: LD_INT 0
7843: PPUSH
// DialogueOn ;
7844: CALL_OW 6
// Say ( Eis , DE-BaseAccept-Eis-1 ) ;
7848: LD_LOC 9
7852: PPUSH
7853: LD_STRING DE-BaseAccept-Eis-1
7855: PPUSH
7856: CALL_OW 88
// if first then
7860: LD_VAR 0 1
7864: IFFALSE 7880
// Say ( Eis , DE-BaseAccept-Eis-1a ) else
7866: LD_LOC 9
7870: PPUSH
7871: LD_STRING DE-BaseAccept-Eis-1a
7873: PPUSH
7874: CALL_OW 88
7878: GO 7892
// Say ( Eis , DE-BaseAccept-Eis-1b ) ;
7880: LD_LOC 9
7884: PPUSH
7885: LD_STRING DE-BaseAccept-Eis-1b
7887: PPUSH
7888: CALL_OW 88
// DialogueOff ;
7892: CALL_OW 7
// end ;
7896: LD_VAR 0 2
7900: RET
// export function DXbaseSurrender ( side ) ; var who ; begin
7901: LD_INT 0
7903: PPUSH
7904: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , side , sex_male , 0 , 0 ) ;
7905: LD_ADDR_VAR 0 3
7909: PUSH
7910: LD_INT 21
7912: PUSH
7913: LD_INT 1
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 23
7922: PUSH
7923: LD_INT 3
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: PPUSH
7934: CALL_OW 69
7938: PUSH
7939: LD_LOC 11
7943: DIFF
7944: PPUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: LD_INT 1
7952: PPUSH
7953: LD_INT 0
7955: PPUSH
7956: LD_INT 0
7958: PPUSH
7959: CALL 10310 0 5
7963: ST_TO_ADDR
// DialogueOn ;
7964: CALL_OW 6
// Say ( who , DXbaseSurrender-Rsol1-1 ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: LD_STRING DXbaseSurrender-Rsol1-1
7975: PPUSH
7976: CALL_OW 88
// DialogueOff ;
7980: CALL_OW 7
// end ;
7984: LD_VAR 0 2
7988: RET
// export function DRocket ; var who ; begin
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , class_scientistic , 0 ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_INT 21
8000: PUSH
8001: LD_INT 1
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 23
8010: PUSH
8011: LD_INT 3
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PPUSH
8022: CALL_OW 69
8026: PUSH
8027: LD_LOC 11
8031: DIFF
8032: PPUSH
8033: LD_EXP 7
8037: PPUSH
8038: LD_INT 1
8040: PPUSH
8041: LD_INT 4
8043: PPUSH
8044: LD_INT 0
8046: PPUSH
8047: CALL 10310 0 5
8051: ST_TO_ADDR
// TalkOn ;
8052: CALL 10569 0 0
// Say ( who , DRocket-RSci1-1 ) ;
8056: LD_VAR 0 2
8060: PPUSH
8061: LD_STRING DRocket-RSci1-1
8063: PPUSH
8064: CALL_OW 88
// TalkOff ;
8068: CALL 10585 0 0
// end ;
8072: LD_VAR 0 1
8076: RET
// every 0 0$1 trigger cap_bases >= 4 do
8077: LD_EXP 17
8081: PUSH
8082: LD_INT 4
8084: GREATEREQUAL
8085: IFFALSE 8101
8087: GO 8089
8089: DISABLE
// begin QEnd ;
8090: CALL 8102 0 0
// ChangeMissionObjectives ( MDestroy ) ;
8094: LD_STRING MDestroy
8096: PPUSH
8097: CALL_OW 337
// end ;
8101: END
// export function QEnd ; var qr ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
// qr := Query ( QKill ) ;
8106: LD_ADDR_VAR 0 2
8110: PUSH
8111: LD_STRING QKill
8113: PPUSH
8114: CALL_OW 97
8118: ST_TO_ADDR
// end ;
8119: LD_VAR 0 1
8123: RET
// export function DEnd ; var who ; begin
8124: LD_INT 0
8126: PPUSH
8127: PPUSH
// who := Gla ;
8128: LD_ADDR_VAR 0 2
8132: PUSH
8133: LD_LOC 1
8137: ST_TO_ADDR
// if not IsOk ( Gla ) then
8138: LD_LOC 1
8142: PPUSH
8143: CALL_OW 302
8147: NOT
8148: IFFALSE 8209
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , 0 , 0 ) ;
8150: LD_ADDR_VAR 0 2
8154: PUSH
8155: LD_INT 21
8157: PUSH
8158: LD_INT 1
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: LD_INT 23
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PPUSH
8179: CALL_OW 69
8183: PUSH
8184: LD_LOC 11
8188: DIFF
8189: PPUSH
8190: LD_EXP 7
8194: PPUSH
8195: LD_INT 1
8197: PPUSH
8198: LD_INT 0
8200: PPUSH
8201: LD_INT 0
8203: PPUSH
8204: CALL 10310 0 5
8208: ST_TO_ADDR
// DialogueOn ;
8209: CALL_OW 6
// Say ( Bur , DEnd-Bur-1 ) ;
8213: LD_LOC 2
8217: PPUSH
8218: LD_STRING DEnd-Bur-1
8220: PPUSH
8221: CALL_OW 88
// if Say ( who , DEnd-Gla-1 ) then
8225: LD_VAR 0 2
8229: PPUSH
8230: LD_STRING DEnd-Gla-1
8232: PPUSH
8233: CALL_OW 88
8237: IFFALSE 8251
// Say ( Bur , DEnd-Bur-2 ) ;
8239: LD_LOC 2
8243: PPUSH
8244: LD_STRING DEnd-Bur-2
8246: PPUSH
8247: CALL_OW 88
// Say ( Bur , DEnd-Bur-2a ) ;
8251: LD_LOC 2
8255: PPUSH
8256: LD_STRING DEnd-Bur-2a
8258: PPUSH
8259: CALL_OW 88
// DialogueOff ;
8263: CALL_OW 7
// end ; end_of_file
8267: LD_VAR 0 1
8271: RET
// export Burlak , Platonov , Gossudarov , Gladkov , Fadeev , Borodin , Tsaritsyn , Davidov , Eisenstein , Gleb ; var masha_def , masha ; var used ; export function Load ; var i ; begin
8272: LD_INT 0
8274: PPUSH
8275: PPUSH
// Masha := LoadVariable ( Masha , [ ] ) ;
8276: LD_ADDR_LOC 14
8280: PUSH
8281: LD_STRING Masha
8283: PPUSH
8284: EMPTY
8285: PPUSH
8286: CALL_OW 30
8290: ST_TO_ADDR
// InitUc ;
8291: CALL_OW 18
// InitHc ;
8295: CALL_OW 19
// uc_nation := nation_russian ;
8299: LD_ADDR_OWVAR 21
8303: PUSH
8304: LD_INT 3
8306: ST_TO_ADDR
// uc_side := ai_s [ 1 ] ;
8307: LD_ADDR_OWVAR 20
8311: PUSH
8312: LD_EXP 23
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
8321: LD_ADDR_EXP 42
8325: PUSH
8326: LD_STRING Platonov
8328: PPUSH
8329: LD_INT 1
8331: PPUSH
8332: LD_INT 1
8334: PPUSH
8335: CALL 8936 0 3
8339: ST_TO_ADDR
// Gossudarov := MyCreateCharacter ( Gossudarov , class_scientistic , false ) ;
8340: LD_ADDR_EXP 43
8344: PUSH
8345: LD_STRING Gossudarov
8347: PPUSH
8348: LD_INT 4
8350: PPUSH
8351: LD_INT 0
8353: PPUSH
8354: CALL 8936 0 3
8358: ST_TO_ADDR
// SetSkill ( Gossudarov , skill_mechanical , gossudarov_mech_skill ) ;
8359: LD_EXP 43
8363: PPUSH
8364: LD_INT 3
8366: PPUSH
8367: LD_EXP 16
8371: PPUSH
8372: CALL_OW 237
// uc_side := ai_s [ 2 ] ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_EXP 23
8385: PUSH
8386: LD_INT 2
8388: ARRAY
8389: ST_TO_ADDR
// Borodin := MyCreateCharacter ( Borodin , 0 , true ) ;
8390: LD_ADDR_EXP 46
8394: PUSH
8395: LD_STRING Borodin
8397: PPUSH
8398: LD_INT 0
8400: PPUSH
8401: LD_INT 1
8403: PPUSH
8404: CALL 8936 0 3
8408: ST_TO_ADDR
// uc_side := ai_s [ 3 ] ;
8409: LD_ADDR_OWVAR 20
8413: PUSH
8414: LD_EXP 23
8418: PUSH
8419: LD_INT 3
8421: ARRAY
8422: ST_TO_ADDR
// Tsaritsyn := MyCreateCharacter ( Tsaritsyn , 0 , true ) ;
8423: LD_ADDR_EXP 47
8427: PUSH
8428: LD_STRING Tsaritsyn
8430: PPUSH
8431: LD_INT 0
8433: PPUSH
8434: LD_INT 1
8436: PPUSH
8437: CALL 8936 0 3
8441: ST_TO_ADDR
// uc_side := ai_s [ 4 ] ;
8442: LD_ADDR_OWVAR 20
8446: PUSH
8447: LD_EXP 23
8451: PUSH
8452: LD_INT 4
8454: ARRAY
8455: ST_TO_ADDR
// Davidov := MyCreateCharacter ( Davidov , class_scientistic , true ) ;
8456: LD_ADDR_EXP 48
8460: PUSH
8461: LD_STRING Davidov
8463: PPUSH
8464: LD_INT 4
8466: PPUSH
8467: LD_INT 1
8469: PPUSH
8470: CALL 8936 0 3
8474: ST_TO_ADDR
// uc_side := ai_s [ 5 ] ;
8475: LD_ADDR_OWVAR 20
8479: PUSH
8480: LD_EXP 23
8484: PUSH
8485: LD_INT 5
8487: ARRAY
8488: ST_TO_ADDR
// Eisenstein := MyCreateCharacter ( Eisenstein , 0 , true ) ;
8489: LD_ADDR_EXP 49
8493: PUSH
8494: LD_STRING Eisenstein
8496: PPUSH
8497: LD_INT 0
8499: PPUSH
8500: LD_INT 1
8502: PPUSH
8503: CALL 8936 0 3
8507: ST_TO_ADDR
// uc_side := you ;
8508: LD_ADDR_OWVAR 20
8512: PUSH
8513: LD_EXP 7
8517: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
8518: LD_ADDR_EXP 41
8522: PUSH
8523: LD_STRING Burlak
8525: PPUSH
8526: LD_INT 3
8528: PPUSH
8529: LD_INT 0
8531: PPUSH
8532: CALL 8936 0 3
8536: ST_TO_ADDR
// Gladkov := MyCreateCharacter ( Gladkov , 0 , true ) ;
8537: LD_ADDR_EXP 44
8541: PUSH
8542: LD_STRING Gladkov
8544: PPUSH
8545: LD_INT 0
8547: PPUSH
8548: LD_INT 1
8550: PPUSH
8551: CALL 8936 0 3
8555: ST_TO_ADDR
// Fadeev := MyCreateCharacter ( Fadeev , 0 , true ) ;
8556: LD_ADDR_EXP 45
8560: PUSH
8561: LD_STRING Fadeev
8563: PPUSH
8564: LD_INT 0
8566: PPUSH
8567: LD_INT 1
8569: PPUSH
8570: CALL 8936 0 3
8574: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , false ) ;
8575: LD_ADDR_EXP 50
8579: PUSH
8580: LD_STRING Gleb
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_INT 0
8588: PPUSH
8589: CALL 8936 0 3
8593: ST_TO_ADDR
// masha_def := LoadVariable ( Masha , [ ] ) ;
8594: LD_ADDR_LOC 13
8598: PUSH
8599: LD_STRING Masha
8601: PPUSH
8602: EMPTY
8603: PPUSH
8604: CALL_OW 30
8608: ST_TO_ADDR
// if masha_def then
8609: LD_LOC 13
8613: IFFALSE 8685
// begin InitVc ;
8615: CALL_OW 20
// vc_chassis := masha_def [ 1 ] ;
8619: LD_ADDR_OWVAR 37
8623: PUSH
8624: LD_LOC 13
8628: PUSH
8629: LD_INT 1
8631: ARRAY
8632: ST_TO_ADDR
// vc_engine := masha_def [ 2 ] ;
8633: LD_ADDR_OWVAR 39
8637: PUSH
8638: LD_LOC 13
8642: PUSH
8643: LD_INT 2
8645: ARRAY
8646: ST_TO_ADDR
// vc_control := masha_def [ 3 ] ;
8647: LD_ADDR_OWVAR 38
8651: PUSH
8652: LD_LOC 13
8656: PUSH
8657: LD_INT 3
8659: ARRAY
8660: ST_TO_ADDR
// vc_weapon := masha_def [ 4 ] ;
8661: LD_ADDR_OWVAR 40
8665: PUSH
8666: LD_LOC 13
8670: PUSH
8671: LD_INT 4
8673: ARRAY
8674: ST_TO_ADDR
// masha := CreateVehicle ;
8675: LD_ADDR_LOC 14
8679: PUSH
8680: CALL_OW 45
8684: ST_TO_ADDR
// end ; used := [ ] ;
8685: LD_ADDR_LOC 15
8689: PUSH
8690: EMPTY
8691: ST_TO_ADDR
// used := [ Gleb ] diff 0 ;
8692: LD_ADDR_LOC 15
8696: PUSH
8697: LD_EXP 50
8701: PUSH
8702: EMPTY
8703: LIST
8704: PUSH
8705: LD_INT 0
8707: DIFF
8708: ST_TO_ADDR
// used := used ^ [ Fadeev , Gladkov ] ;
8709: LD_ADDR_LOC 15
8713: PUSH
8714: LD_LOC 15
8718: PUSH
8719: LD_EXP 45
8723: PUSH
8724: LD_EXP 44
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: ADD
8733: ST_TO_ADDR
// for i := used + 1 to 3 do
8734: LD_ADDR_VAR 0 2
8738: PUSH
8739: DOUBLE
8740: LD_LOC 15
8744: PUSH
8745: LD_INT 1
8747: PLUS
8748: DEC
8749: ST_TO_ADDR
8750: LD_INT 3
8752: PUSH
8753: FOR_TO
8754: IFFALSE 8787
// begin PrepareSoldier ( sex_male , 6 ) ;
8756: LD_INT 1
8758: PPUSH
8759: LD_INT 6
8761: PPUSH
8762: CALL_OW 381
// used := used ^ [ CreateHuman ] ;
8766: LD_ADDR_LOC 15
8770: PUSH
8771: LD_LOC 15
8775: PUSH
8776: CALL_OW 44
8780: PUSH
8781: EMPTY
8782: LIST
8783: ADD
8784: ST_TO_ADDR
// end ;
8785: GO 8753
8787: POP
8788: POP
// used := used ^ [ Burlak ] ;
8789: LD_ADDR_LOC 15
8793: PUSH
8794: LD_LOC 15
8798: PUSH
8799: LD_EXP 41
8803: PUSH
8804: EMPTY
8805: LIST
8806: ADD
8807: ST_TO_ADDR
// end ;
8808: LD_VAR 0 1
8812: RET
// export function place_ru ; var i ; begin
8813: LD_INT 0
8815: PPUSH
8816: PPUSH
// for i in used diff burlak do
8817: LD_ADDR_VAR 0 2
8821: PUSH
8822: LD_LOC 15
8826: PUSH
8827: LD_EXP 41
8831: DIFF
8832: PUSH
8833: FOR_IN
8834: IFFALSE 8853
// PlaceUnitArea ( i , ru_place , false ) ;
8836: LD_VAR 0 2
8840: PPUSH
8841: LD_INT 6
8843: PPUSH
8844: LD_INT 0
8846: PPUSH
8847: CALL_OW 49
8851: GO 8833
8853: POP
8854: POP
// if masha then
8855: LD_LOC 14
8859: IFFALSE 8916
// begin SetMark ( masha , 1 ) ;
8861: LD_LOC 14
8865: PPUSH
8866: LD_INT 1
8868: PPUSH
8869: CALL_OW 242
// PlaceHumanInUnit ( Burlak , masha ) ;
8873: LD_EXP 41
8877: PPUSH
8878: LD_LOC 14
8882: PPUSH
8883: CALL_OW 52
// PlaceUnitArea ( masha , ru_place , false ) ;
8887: LD_LOC 14
8891: PPUSH
8892: LD_INT 6
8894: PPUSH
8895: LD_INT 0
8897: PPUSH
8898: CALL_OW 49
// SetMark ( masha , 1 ) ;
8902: LD_LOC 14
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 242
// end else
8914: GO 8931
// PlaceUnitArea ( Burlak , ru_place , false ) ;
8916: LD_EXP 41
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: LD_INT 0
8926: PPUSH
8927: CALL_OW 49
// end ;
8931: LD_VAR 0 1
8935: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
8936: LD_INT 0
8938: PPUSH
// if ( new and NewCharacter ( name ) ) or TestCharacters ( name ) then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_VAR 0 1
8948: PPUSH
8949: CALL_OW 25
8953: AND
8954: PUSH
8955: LD_VAR 0 1
8959: PPUSH
8960: CALL_OW 28
8964: OR
8965: IFFALSE 9048
// begin if new then
8967: LD_VAR 0 3
8971: IFFALSE 8990
// result := NewCharacter ( name ) else
8973: LD_ADDR_VAR 0 4
8977: PUSH
8978: LD_VAR 0 1
8982: PPUSH
8983: CALL_OW 25
8987: ST_TO_ADDR
8988: GO 9026
// begin if CheckCharacterSet ( name ) then
8990: LD_VAR 0 1
8994: PPUSH
8995: CALL_OW 29
8999: IFFALSE 9018
// result := CreateCharacter ( name ) else
9001: LD_ADDR_VAR 0 4
9005: PUSH
9006: LD_VAR 0 1
9010: PPUSH
9011: CALL_OW 34
9015: ST_TO_ADDR
9016: GO 9026
// result := 0 ;
9018: LD_ADDR_VAR 0 4
9022: PUSH
9023: LD_INT 0
9025: ST_TO_ADDR
// end ; if unclass then
9026: LD_VAR 0 2
9030: IFFALSE 9046
// SetClass ( result , unclass ) ;
9032: LD_VAR 0 4
9036: PPUSH
9037: LD_VAR 0 2
9041: PPUSH
9042: CALL_OW 336
// end else
9046: GO 9114
// begin Msg ( Chybi  & name & ! ) ;
9048: LD_STRING Chybi 
9050: PUSH
9051: LD_VAR 0 1
9055: STR
9056: PUSH
9057: LD_STRING !
9059: STR
9060: PPUSH
9061: CALL_OW 100
// hc_name := name ;
9065: LD_ADDR_OWVAR 26
9069: PUSH
9070: LD_VAR 0 1
9074: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
9075: LD_INT 1
9077: PPUSH
9078: LD_INT 0
9080: PPUSH
9081: LD_INT 3
9083: PPUSH
9084: CALL_OW 380
// if unclass then
9088: LD_VAR 0 2
9092: IFFALSE 9104
// hc_class := unclass ;
9094: LD_ADDR_OWVAR 28
9098: PUSH
9099: LD_VAR 0 2
9103: ST_TO_ADDR
// result := CreateHuman ;
9104: LD_ADDR_VAR 0 4
9108: PUSH
9109: CALL_OW 44
9113: ST_TO_ADDR
// end ; end ;
9114: LD_VAR 0 4
9118: RET
// export function Save ; var tmp , Bluekher , t ; begin
9119: LD_INT 0
9121: PPUSH
9122: PPUSH
9123: PPUSH
9124: PPUSH
// SaveCharacters ( Burlak , Burlak ) ;
9125: LD_EXP 41
9129: PPUSH
9130: LD_STRING Burlak
9132: PPUSH
9133: CALL_OW 38
// SaveCharacters ( Gladkov , Gladkov ) ;
9137: LD_EXP 44
9141: PPUSH
9142: LD_STRING Gladkov
9144: PPUSH
9145: CALL_OW 38
// SaveCharacters ( Fadeev , Fadeev ) ;
9149: LD_EXP 45
9153: PPUSH
9154: LD_STRING Fadeev
9156: PPUSH
9157: CALL_OW 38
// DeleteCharacters ( Platonov ) ;
9161: LD_STRING Platonov
9163: PPUSH
9164: CALL_OW 40
// SaveVariable ( not IsLive ( Platonov ) , PlatonovKilled ) ;
9168: LD_EXP 42
9172: PPUSH
9173: CALL_OW 300
9177: NOT
9178: PPUSH
9179: LD_STRING PlatonovKilled
9181: PPUSH
9182: CALL_OW 39
// SaveVariable ( BehemothSeen , BehemothSeen ) ;
9186: LD_EXP 29
9190: PPUSH
9191: LD_STRING BehemothSeen
9193: PPUSH
9194: CALL_OW 39
// if IsDead ( masha ) then
9198: LD_LOC 14
9202: PPUSH
9203: CALL_OW 301
9207: IFFALSE 9216
// DeleteVariable ( Masha ) ;
9209: LD_STRING Masha
9211: PPUSH
9212: CALL_OW 41
// SaveCharacters ( Borodin , Borodin ) ;
9216: LD_EXP 46
9220: PPUSH
9221: LD_STRING Borodin
9223: PPUSH
9224: CALL_OW 38
// SaveCharacters ( Tsaritsyn , Tsaritsyn ) ;
9228: LD_EXP 47
9232: PPUSH
9233: LD_STRING Tsaritsyn
9235: PPUSH
9236: CALL_OW 38
// SaveCharacters ( Davidov , Davidov ) ;
9240: LD_EXP 48
9244: PPUSH
9245: LD_STRING Davidov
9247: PPUSH
9248: CALL_OW 38
// SaveCharacters ( Eisenstein , Eisenstein ) ;
9252: LD_EXP 49
9256: PPUSH
9257: LD_STRING Eisenstein
9259: PPUSH
9260: CALL_OW 38
// if Gleb then
9264: LD_EXP 50
9268: IFFALSE 9282
// SaveCharacters ( Gleb , Gleb ) ;
9270: LD_EXP 50
9274: PPUSH
9275: LD_STRING Gleb
9277: PPUSH
9278: CALL_OW 38
// DeleteCharacters ( Gossudarov ) ;
9282: LD_STRING Gossudarov
9284: PPUSH
9285: CALL_OW 40
// tmp := FilterUnitsInArea ( Bluekher_area , [ [ f_type , unit_building ] ] ) ;
9289: LD_ADDR_VAR 0 2
9293: PUSH
9294: LD_INT 18
9296: PPUSH
9297: LD_INT 21
9299: PUSH
9300: LD_INT 3
9302: PUSH
9303: EMPTY
9304: LIST
9305: LIST
9306: PUSH
9307: EMPTY
9308: LIST
9309: PPUSH
9310: CALL_OW 70
9314: ST_TO_ADDR
// Bluekher := [ ] ;
9315: LD_ADDR_VAR 0 3
9319: PUSH
9320: EMPTY
9321: ST_TO_ADDR
// for t in tmp do
9322: LD_ADDR_VAR 0 4
9326: PUSH
9327: LD_VAR 0 2
9331: PUSH
9332: FOR_IN
9333: IFFALSE 9720
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
9335: LD_VAR 0 4
9339: PPUSH
9340: CALL_OW 266
9344: PUSH
9345: LD_INT 9
9347: DOUBLE
9348: EQUAL
9349: IFTRUE 9389
9351: LD_INT 10
9353: DOUBLE
9354: EQUAL
9355: IFTRUE 9389
9357: LD_INT 13
9359: DOUBLE
9360: EQUAL
9361: IFTRUE 9389
9363: LD_INT 12
9365: DOUBLE
9366: EQUAL
9367: IFTRUE 9389
9369: LD_INT 15
9371: DOUBLE
9372: EQUAL
9373: IFTRUE 9389
9375: LD_INT 11
9377: DOUBLE
9378: EQUAL
9379: IFTRUE 9389
9381: LD_INT 14
9383: DOUBLE
9384: EQUAL
9385: IFTRUE 9389
9387: GO 9392
9389: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
9390: GO 9718
9392: LD_INT 6
9394: DOUBLE
9395: EQUAL
9396: IFTRUE 9412
9398: LD_INT 7
9400: DOUBLE
9401: EQUAL
9402: IFTRUE 9412
9404: LD_INT 8
9406: DOUBLE
9407: EQUAL
9408: IFTRUE 9412
9410: GO 9525
9412: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , getlabkind ( t , 1 ) , getlabkind ( t , 2 ) ] ] ; b_bunker , b_turret :
9413: LD_ADDR_VAR 0 3
9417: PUSH
9418: LD_VAR 0 3
9422: PUSH
9423: LD_VAR 0 4
9427: PPUSH
9428: CALL_OW 250
9432: PUSH
9433: LD_VAR 0 4
9437: PPUSH
9438: CALL_OW 251
9442: PUSH
9443: LD_VAR 0 4
9447: PPUSH
9448: CALL_OW 254
9452: PUSH
9453: LD_VAR 0 4
9457: PPUSH
9458: CALL_OW 266
9462: PUSH
9463: LD_VAR 0 4
9467: PPUSH
9468: CALL_OW 267
9472: PUSH
9473: LD_VAR 0 4
9477: PPUSH
9478: CALL_OW 248
9482: PUSH
9483: LD_VAR 0 4
9487: PPUSH
9488: LD_INT 1
9490: PPUSH
9491: CALL_OW 268
9495: PUSH
9496: LD_VAR 0 4
9500: PPUSH
9501: LD_INT 2
9503: PPUSH
9504: CALL_OW 268
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: PUSH
9519: EMPTY
9520: LIST
9521: ADD
9522: ST_TO_ADDR
9523: GO 9718
9525: LD_INT 32
9527: DOUBLE
9528: EQUAL
9529: IFTRUE 9539
9531: LD_INT 33
9533: DOUBLE
9534: EQUAL
9535: IFTRUE 9539
9537: GO 9635
9539: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , GetWeapon ( t ) ] ] ; else
9540: LD_ADDR_VAR 0 3
9544: PUSH
9545: LD_VAR 0 3
9549: PUSH
9550: LD_VAR 0 4
9554: PPUSH
9555: CALL_OW 250
9559: PUSH
9560: LD_VAR 0 4
9564: PPUSH
9565: CALL_OW 251
9569: PUSH
9570: LD_VAR 0 4
9574: PPUSH
9575: CALL_OW 254
9579: PUSH
9580: LD_VAR 0 4
9584: PPUSH
9585: CALL_OW 266
9589: PUSH
9590: LD_VAR 0 4
9594: PPUSH
9595: CALL_OW 267
9599: PUSH
9600: LD_VAR 0 4
9604: PPUSH
9605: CALL_OW 248
9609: PUSH
9610: LD_VAR 0 4
9614: PPUSH
9615: CALL_OW 264
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: EMPTY
9630: LIST
9631: ADD
9632: ST_TO_ADDR
9633: GO 9718
9635: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) ] ] ; end ;
9636: LD_ADDR_VAR 0 3
9640: PUSH
9641: LD_VAR 0 3
9645: PUSH
9646: LD_VAR 0 4
9650: PPUSH
9651: CALL_OW 250
9655: PUSH
9656: LD_VAR 0 4
9660: PPUSH
9661: CALL_OW 251
9665: PUSH
9666: LD_VAR 0 4
9670: PPUSH
9671: CALL_OW 254
9675: PUSH
9676: LD_VAR 0 4
9680: PPUSH
9681: CALL_OW 266
9685: PUSH
9686: LD_VAR 0 4
9690: PPUSH
9691: CALL_OW 267
9695: PUSH
9696: LD_VAR 0 4
9700: PPUSH
9701: CALL_OW 248
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: PUSH
9714: EMPTY
9715: LIST
9716: ADD
9717: ST_TO_ADDR
// end ;
9718: GO 9332
9720: POP
9721: POP
// SaveVariable ( Bluekher , Bluekher ) ;
9722: LD_VAR 0 3
9726: PPUSH
9727: LD_STRING Bluekher
9729: PPUSH
9730: CALL_OW 39
// end ; end_of_file
9734: LD_VAR 0 1
9738: RET
// export mf_sol ; export mf_eng ; export mf_mec ; export mf_sci ; export mf_lab ; export mf_fort ; export mf_bunk ; export mf_dep ; export mf_fact ; export mf_comp ; export mf_manu ; export function inicializace_functions ; begin
9739: LD_INT 0
9741: PPUSH
// mf_sol := [ f_class , class_soldier ] ;
9742: LD_ADDR_EXP 51
9746: PUSH
9747: LD_INT 25
9749: PUSH
9750: LD_INT 1
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: ST_TO_ADDR
// mf_eng := [ f_class , class_engineer ] ;
9757: LD_ADDR_EXP 52
9761: PUSH
9762: LD_INT 25
9764: PUSH
9765: LD_INT 2
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: ST_TO_ADDR
// mf_mec := [ f_class , class_mechanic ] ;
9772: LD_ADDR_EXP 53
9776: PUSH
9777: LD_INT 25
9779: PUSH
9780: LD_INT 3
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: ST_TO_ADDR
// mf_sci := [ f_class , class_scientistic ] ;
9787: LD_ADDR_EXP 54
9791: PUSH
9792: LD_INT 25
9794: PUSH
9795: LD_INT 4
9797: PUSH
9798: EMPTY
9799: LIST
9800: LIST
9801: ST_TO_ADDR
// mf_lab := [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ;
9802: LD_ADDR_EXP 55
9806: PUSH
9807: LD_INT 2
9809: PUSH
9810: LD_INT 30
9812: PUSH
9813: LD_INT 6
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: PUSH
9820: LD_INT 30
9822: PUSH
9823: LD_INT 7
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: PUSH
9830: LD_INT 30
9832: PUSH
9833: LD_INT 8
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: ST_TO_ADDR
// mf_fort := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ;
9846: LD_ADDR_EXP 56
9850: PUSH
9851: LD_INT 2
9853: PUSH
9854: LD_INT 30
9856: PUSH
9857: LD_INT 32
9859: PUSH
9860: EMPTY
9861: LIST
9862: LIST
9863: PUSH
9864: LD_INT 30
9866: PUSH
9867: LD_INT 31
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PUSH
9874: LD_INT 30
9876: PUSH
9877: LD_INT 4
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PUSH
9884: LD_INT 30
9886: PUSH
9887: LD_INT 5
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: ST_TO_ADDR
// mf_bunk := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ;
9901: LD_ADDR_EXP 57
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: LD_INT 30
9911: PUSH
9912: LD_INT 32
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 30
9921: PUSH
9922: LD_INT 31
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: LIST
9933: ST_TO_ADDR
// mf_dep := [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ;
9934: LD_ADDR_EXP 58
9938: PUSH
9939: LD_INT 2
9941: PUSH
9942: LD_INT 30
9944: PUSH
9945: LD_INT 0
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: PUSH
9952: LD_INT 30
9954: PUSH
9955: LD_INT 1
9957: PUSH
9958: EMPTY
9959: LIST
9960: LIST
9961: PUSH
9962: EMPTY
9963: LIST
9964: LIST
9965: LIST
9966: ST_TO_ADDR
// mf_fact := [ f_or , [ f_btype , b_factory ] , [ f_btype , b_workshop ] ] ;
9967: LD_ADDR_EXP 59
9971: PUSH
9972: LD_INT 2
9974: PUSH
9975: LD_INT 30
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: LD_INT 30
9987: PUSH
9988: LD_INT 2
9990: PUSH
9991: EMPTY
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: LIST
9999: ST_TO_ADDR
// mf_comp := [ f_control , control_computer ] ;
10000: LD_ADDR_EXP 60
10004: PUSH
10005: LD_INT 33
10007: PUSH
10008: LD_INT 3
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: ST_TO_ADDR
// mf_manu := [ f_control , control_manual ] ;
10015: LD_ADDR_EXP 61
10019: PUSH
10020: LD_INT 33
10022: PUSH
10023: LD_INT 1
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: ST_TO_ADDR
// end ;
10030: LD_VAR 0 1
10034: RET
// export function get_x_best ( lidi , num , skill , mclass , idle ) ; var i , skills ; begin
10035: LD_INT 0
10037: PPUSH
10038: PPUSH
10039: PPUSH
// if mclass then
10040: LD_VAR 0 4
10044: IFFALSE 10076
// lidi := UnitFilter ( lidi , [ [ f_class , mclass ] ] ) ;
10046: LD_ADDR_VAR 0 1
10050: PUSH
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 25
10058: PUSH
10059: LD_VAR 0 4
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: EMPTY
10069: LIST
10070: PPUSH
10071: CALL_OW 72
10075: ST_TO_ADDR
// skills := [ ] ;
10076: LD_ADDR_VAR 0 8
10080: PUSH
10081: EMPTY
10082: ST_TO_ADDR
// for i in lidi do
10083: LD_ADDR_VAR 0 7
10087: PUSH
10088: LD_VAR 0 1
10092: PUSH
10093: FOR_IN
10094: IFFALSE 10127
// skills := skills ^ [ GetSkill ( i , skill ) ] ;
10096: LD_ADDR_VAR 0 8
10100: PUSH
10101: LD_VAR 0 8
10105: PUSH
10106: LD_VAR 0 7
10110: PPUSH
10111: LD_VAR 0 3
10115: PPUSH
10116: CALL_OW 259
10120: PUSH
10121: EMPTY
10122: LIST
10123: ADD
10124: ST_TO_ADDR
10125: GO 10093
10127: POP
10128: POP
// lidi := SortListByListDesc ( lidi , skills ) ;
10129: LD_ADDR_VAR 0 1
10133: PUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: LD_VAR 0 8
10143: PPUSH
10144: CALL_OW 77
10148: ST_TO_ADDR
// if num > lidi then
10149: LD_VAR 0 2
10153: PUSH
10154: LD_VAR 0 1
10158: GREATER
10159: IFFALSE 10175
// num := lidi + 0 ;
10161: LD_ADDR_VAR 0 2
10165: PUSH
10166: LD_VAR 0 1
10170: PUSH
10171: LD_INT 0
10173: PLUS
10174: ST_TO_ADDR
// i := 1 ;
10175: LD_ADDR_VAR 0 7
10179: PUSH
10180: LD_INT 1
10182: ST_TO_ADDR
// result := [ ] ;
10183: LD_ADDR_VAR 0 6
10187: PUSH
10188: EMPTY
10189: ST_TO_ADDR
// while i <= lidi and result < num do
10190: LD_VAR 0 7
10194: PUSH
10195: LD_VAR 0 1
10199: LESSEQUAL
10200: PUSH
10201: LD_VAR 0 6
10205: PUSH
10206: LD_VAR 0 2
10210: LESS
10211: AND
10212: IFFALSE 10305
// begin if idle then
10214: LD_VAR 0 5
10218: IFFALSE 10264
// begin if IsIdle ( lidi [ i ] ) then
10220: LD_VAR 0 1
10224: PUSH
10225: LD_VAR 0 7
10229: ARRAY
10230: PPUSH
10231: CALL_OW 316
10235: IFFALSE 10262
// result := result ^ [ lidi [ i ] ] ;
10237: LD_ADDR_VAR 0 6
10241: PUSH
10242: LD_VAR 0 6
10246: PUSH
10247: LD_VAR 0 1
10251: PUSH
10252: LD_VAR 0 7
10256: ARRAY
10257: PUSH
10258: EMPTY
10259: LIST
10260: ADD
10261: ST_TO_ADDR
// end else
10262: GO 10289
// result := result ^ [ lidi [ i ] ] ;
10264: LD_ADDR_VAR 0 6
10268: PUSH
10269: LD_VAR 0 6
10273: PUSH
10274: LD_VAR 0 1
10278: PUSH
10279: LD_VAR 0 7
10283: ARRAY
10284: PUSH
10285: EMPTY
10286: LIST
10287: ADD
10288: ST_TO_ADDR
// i := i + 1 ;
10289: LD_ADDR_VAR 0 7
10293: PUSH
10294: LD_VAR 0 7
10298: PUSH
10299: LD_INT 1
10301: PLUS
10302: ST_TO_ADDR
// end ;
10303: GO 10190
// end ;
10305: LD_VAR 0 6
10309: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
10310: LD_INT 0
10312: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
10313: LD_ADDR_VAR 0 1
10317: PUSH
10318: LD_VAR 0 1
10322: PPUSH
10323: LD_INT 21
10325: PUSH
10326: LD_INT 1
10328: PUSH
10329: EMPTY
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_VAR 0 2
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PUSH
10345: LD_INT 3
10347: PUSH
10348: LD_INT 23
10350: PUSH
10351: LD_INT 0
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: PPUSH
10364: CALL_OW 72
10368: ST_TO_ADDR
// if sex <> 0 then
10369: LD_VAR 0 3
10373: PUSH
10374: LD_INT 0
10376: NONEQUAL
10377: IFFALSE 10406
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
10379: LD_ADDR_VAR 0 1
10383: PUSH
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 26
10391: PUSH
10392: LD_VAR 0 3
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PPUSH
10401: CALL_OW 72
10405: ST_TO_ADDR
// if Hclass <> 0 then
10406: LD_VAR 0 4
10410: PUSH
10411: LD_INT 0
10413: NONEQUAL
10414: IFFALSE 10443
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
10416: LD_ADDR_VAR 0 1
10420: PUSH
10421: LD_VAR 0 1
10425: PPUSH
10426: LD_INT 25
10428: PUSH
10429: LD_VAR 0 4
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PPUSH
10438: CALL_OW 72
10442: ST_TO_ADDR
// if index <= 0 then
10443: LD_VAR 0 5
10447: PUSH
10448: LD_INT 0
10450: LESSEQUAL
10451: IFFALSE 10461
// index := 1 ;
10453: LD_ADDR_VAR 0 5
10457: PUSH
10458: LD_INT 1
10460: ST_TO_ADDR
// if lidi >= index then
10461: LD_VAR 0 1
10465: PUSH
10466: LD_VAR 0 5
10470: GREATEREQUAL
10471: IFFALSE 10491
// result := lidi [ index ] else
10473: LD_ADDR_VAR 0 6
10477: PUSH
10478: LD_VAR 0 1
10482: PUSH
10483: LD_VAR 0 5
10487: ARRAY
10488: ST_TO_ADDR
10489: GO 10499
// result := 0 ;
10491: LD_ADDR_VAR 0 6
10495: PUSH
10496: LD_INT 0
10498: ST_TO_ADDR
// end ;
10499: LD_VAR 0 6
10503: RET
// export function see_any ( strana , sez ) ; var i ; begin
10504: LD_INT 0
10506: PPUSH
10507: PPUSH
// result := [ ] ;
10508: LD_ADDR_VAR 0 3
10512: PUSH
10513: EMPTY
10514: ST_TO_ADDR
// for i in sez do
10515: LD_ADDR_VAR 0 4
10519: PUSH
10520: LD_VAR 0 2
10524: PUSH
10525: FOR_IN
10526: IFFALSE 10562
// if See ( strana , i ) then
10528: LD_VAR 0 1
10532: PPUSH
10533: LD_VAR 0 4
10537: PPUSH
10538: CALL_OW 292
10542: IFFALSE 10560
// begin result := result ^ i ;
10544: LD_ADDR_VAR 0 3
10548: PUSH
10549: LD_VAR 0 3
10553: PUSH
10554: LD_VAR 0 4
10558: ADD
10559: ST_TO_ADDR
// end ;
10560: GO 10525
10562: POP
10563: POP
// ; end ;
10564: LD_VAR 0 3
10568: RET
// export function TalkOn ; begin
10569: LD_INT 0
10571: PPUSH
// stop_talking := true ;
10572: LD_ADDR_OWVAR 56
10576: PUSH
10577: LD_INT 1
10579: ST_TO_ADDR
// end ;
10580: LD_VAR 0 1
10584: RET
// export function TalkOff ; begin
10585: LD_INT 0
10587: PPUSH
// stop_talking := false ;
10588: LD_ADDR_OWVAR 56
10592: PUSH
10593: LD_INT 0
10595: ST_TO_ADDR
// end ;
10596: LD_VAR 0 1
10600: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
10601: LD_INT 0
10603: PPUSH
10604: PPUSH
10605: PPUSH
// result := [ ] ;
10606: LD_ADDR_VAR 0 3
10610: PUSH
10611: EMPTY
10612: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ f_side , you ] ) ;
10613: LD_ADDR_VAR 0 4
10617: PUSH
10618: LD_VAR 0 1
10622: PPUSH
10623: LD_INT 22
10625: PUSH
10626: LD_EXP 7
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PPUSH
10635: CALL_OW 70
10639: ST_TO_ADDR
// for i in inbase do
10640: LD_ADDR_VAR 0 5
10644: PUSH
10645: LD_VAR 0 4
10649: PUSH
10650: FOR_IN
10651: IFFALSE 10724
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
10653: LD_VAR 0 5
10657: PPUSH
10658: CALL_OW 247
10662: PUSH
10663: LD_INT 3
10665: EQUAL
10666: PUSH
10667: LD_VAR 0 5
10671: PPUSH
10672: CALL_OW 247
10676: PUSH
10677: LD_INT 2
10679: EQUAL
10680: OR
10681: IFFALSE 10706
// begin result := result ^ UnitsInside ( i ) ;
10683: LD_ADDR_VAR 0 3
10687: PUSH
10688: LD_VAR 0 3
10692: PUSH
10693: LD_VAR 0 5
10697: PPUSH
10698: CALL_OW 313
10702: ADD
10703: ST_TO_ADDR
// end else
10704: GO 10722
// begin result := result ^ i ;
10706: LD_ADDR_VAR 0 3
10710: PUSH
10711: LD_VAR 0 3
10715: PUSH
10716: LD_VAR 0 5
10720: ADD
10721: ST_TO_ADDR
// end ; end ;
10722: GO 10650
10724: POP
10725: POP
// result := UnitFilter ( result , filter ) ;
10726: LD_ADDR_VAR 0 3
10730: PUSH
10731: LD_VAR 0 3
10735: PPUSH
10736: LD_VAR 0 2
10740: PPUSH
10741: CALL_OW 72
10745: ST_TO_ADDR
// end ;
10746: LD_VAR 0 3
10750: RET
// export function inside_units ( uns ) ; var i ; begin
10751: LD_INT 0
10753: PPUSH
10754: PPUSH
// result := [ ] ;
10755: LD_ADDR_VAR 0 2
10759: PUSH
10760: EMPTY
10761: ST_TO_ADDR
// for i in uns do
10762: LD_ADDR_VAR 0 3
10766: PUSH
10767: LD_VAR 0 1
10771: PUSH
10772: FOR_IN
10773: IFFALSE 10798
// result := result ^ UnitsInside ( i ) ;
10775: LD_ADDR_VAR 0 2
10779: PUSH
10780: LD_VAR 0 2
10784: PUSH
10785: LD_VAR 0 3
10789: PPUSH
10790: CALL_OW 313
10794: ADD
10795: ST_TO_ADDR
10796: GO 10772
10798: POP
10799: POP
// end ;
10800: LD_VAR 0 2
10804: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
10805: LD_INT 0
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
10812: LD_ADDR_VAR 0 1
10816: PUSH
10817: LD_VAR 0 1
10821: PPUSH
10822: LD_INT 51
10824: PUSH
10825: EMPTY
10826: LIST
10827: PPUSH
10828: CALL_OW 72
10832: PUSH
10833: EMPTY
10834: UNION
10835: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
10836: LD_ADDR_VAR 0 2
10840: PUSH
10841: LD_VAR 0 2
10845: PPUSH
10846: LD_INT 51
10848: PUSH
10849: EMPTY
10850: LIST
10851: PPUSH
10852: CALL_OW 72
10856: PUSH
10857: EMPTY
10858: UNION
10859: ST_TO_ADDR
// for i in cars do
10860: LD_ADDR_VAR 0 7
10864: PUSH
10865: LD_VAR 0 1
10869: PUSH
10870: FOR_IN
10871: IFFALSE 10906
// if not IsDrivenBy ( i ) then
10873: LD_VAR 0 7
10877: PPUSH
10878: CALL_OW 311
10882: NOT
10883: IFFALSE 10904
// empty := empty ^ [ i ] ;
10885: LD_ADDR_VAR 0 5
10889: PUSH
10890: LD_VAR 0 5
10894: PUSH
10895: LD_VAR 0 7
10899: PUSH
10900: EMPTY
10901: LIST
10902: ADD
10903: ST_TO_ADDR
10904: GO 10870
10906: POP
10907: POP
// if take_out then
10908: LD_VAR 0 3
10912: IFFALSE 10970
// begin for i in drivers do
10914: LD_ADDR_VAR 0 7
10918: PUSH
10919: LD_VAR 0 2
10923: PUSH
10924: FOR_IN
10925: IFFALSE 10966
// if not ( IsInUnit ( i ) in cars ) then
10927: LD_VAR 0 7
10931: PPUSH
10932: CALL_OW 310
10936: PUSH
10937: LD_VAR 0 1
10941: IN
10942: NOT
10943: IFFALSE 10964
// free := free ^ [ i ] ;
10945: LD_ADDR_VAR 0 6
10949: PUSH
10950: LD_VAR 0 6
10954: PUSH
10955: LD_VAR 0 7
10959: PUSH
10960: EMPTY
10961: LIST
10962: ADD
10963: ST_TO_ADDR
10964: GO 10924
10966: POP
10967: POP
// end else
10968: GO 11018
// begin for i in drivers do
10970: LD_ADDR_VAR 0 7
10974: PUSH
10975: LD_VAR 0 2
10979: PUSH
10980: FOR_IN
10981: IFFALSE 11016
// if not IsInUnit ( i ) then
10983: LD_VAR 0 7
10987: PPUSH
10988: CALL_OW 310
10992: NOT
10993: IFFALSE 11014
// free := free ^ [ i ] ;
10995: LD_ADDR_VAR 0 6
10999: PUSH
11000: LD_VAR 0 6
11004: PUSH
11005: LD_VAR 0 7
11009: PUSH
11010: EMPTY
11011: LIST
11012: ADD
11013: ST_TO_ADDR
11014: GO 10980
11016: POP
11017: POP
// end ; result := cars diff empty ;
11018: LD_ADDR_VAR 0 4
11022: PUSH
11023: LD_VAR 0 1
11027: PUSH
11028: LD_VAR 0 5
11032: DIFF
11033: ST_TO_ADDR
// if empty <= free then
11034: LD_VAR 0 5
11038: PUSH
11039: LD_VAR 0 6
11043: LESSEQUAL
11044: IFFALSE 11058
// konec := empty else
11046: LD_ADDR_VAR 0 8
11050: PUSH
11051: LD_VAR 0 5
11055: ST_TO_ADDR
11056: GO 11068
// konec := free ;
11058: LD_ADDR_VAR 0 8
11062: PUSH
11063: LD_VAR 0 6
11067: ST_TO_ADDR
// for i := 1 to konec do
11068: LD_ADDR_VAR 0 7
11072: PUSH
11073: DOUBLE
11074: LD_INT 1
11076: DEC
11077: ST_TO_ADDR
11078: LD_VAR 0 8
11082: PUSH
11083: FOR_TO
11084: IFFALSE 11139
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
11086: LD_VAR 0 6
11090: PUSH
11091: LD_VAR 0 7
11095: ARRAY
11096: PPUSH
11097: LD_VAR 0 5
11101: PUSH
11102: LD_VAR 0 7
11106: ARRAY
11107: PPUSH
11108: CALL_OW 120
// result := result ^ [ empty [ i ] ] ;
11112: LD_ADDR_VAR 0 4
11116: PUSH
11117: LD_VAR 0 4
11121: PUSH
11122: LD_VAR 0 5
11126: PUSH
11127: LD_VAR 0 7
11131: ARRAY
11132: PUSH
11133: EMPTY
11134: LIST
11135: ADD
11136: ST_TO_ADDR
// end ;
11137: GO 11083
11139: POP
11140: POP
// end ;
11141: LD_VAR 0 4
11145: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
11146: LD_INT 0
11148: PPUSH
11149: PPUSH
11150: PPUSH
// while remotes > mechs do
11151: LD_VAR 0 3
11155: PUSH
11156: LD_VAR 0 2
11160: GREATER
11161: IFFALSE 11177
// delete ( remotes , 1 ) ;
11163: LD_VAR 0 3
11167: PPUSH
11168: LD_INT 1
11170: PPUSH
11171: CALL_OW 3
11175: GO 11151
// for i := 1 to remotes do
11177: LD_ADDR_VAR 0 6
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 3
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11223
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
11195: LD_VAR 0 2
11199: PUSH
11200: LD_VAR 0 6
11204: ARRAY
11205: PPUSH
11206: LD_VAR 0 3
11210: PUSH
11211: LD_VAR 0 6
11215: ARRAY
11216: PPUSH
11217: CALL_OW 120
11221: GO 11192
11223: POP
11224: POP
// end ;
11225: LD_VAR 0 4
11229: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
11230: LD_INT 0
11232: PPUSH
11233: PPUSH
11234: PPUSH
11235: PPUSH
// c := tick + cas ;
11236: LD_ADDR_VAR 0 5
11240: PUSH
11241: LD_OWVAR 1
11245: PUSH
11246: LD_VAR 0 3
11250: PLUS
11251: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
11252: LD_OWVAR 1
11256: PUSH
11257: LD_VAR 0 5
11261: LESS
11262: PUSH
11263: LD_VAR 0 2
11267: PPUSH
11268: CALL 10751 0 1
11272: PUSH
11273: LD_INT 0
11275: PLUS
11276: PUSH
11277: LD_VAR 0 2
11281: EQUAL
11282: NOT
11283: AND
11284: IFFALSE 11295
// wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
11293: GO 11252
// unlinked := cars ;
11295: LD_ADDR_VAR 0 6
11299: PUSH
11300: LD_VAR 0 1
11304: ST_TO_ADDR
// for i in remotes do
11305: LD_ADDR_VAR 0 7
11309: PUSH
11310: LD_VAR 0 2
11314: PUSH
11315: FOR_IN
11316: IFFALSE 11365
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
11318: LD_VAR 0 6
11322: PPUSH
11323: LD_VAR 0 7
11327: PPUSH
11328: CALL_OW 313
11332: PPUSH
11333: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
11337: LD_ADDR_VAR 0 6
11341: PUSH
11342: LD_VAR 0 6
11346: PUSH
11347: LD_VAR 0 7
11351: PPUSH
11352: CALL_OW 313
11356: PPUSH
11357: CALL_OW 432
11361: DIFF
11362: ST_TO_ADDR
// end ;
11363: GO 11315
11365: POP
11366: POP
// end ;
11367: LD_VAR 0 4
11371: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , k , pockat ; begin
11372: LD_INT 0
11374: PPUSH
11375: PPUSH
11376: PPUSH
11377: PPUSH
11378: PPUSH
// k := 0 ;
11379: LD_ADDR_VAR 0 6
11383: PUSH
11384: LD_INT 0
11386: ST_TO_ADDR
// pockat := tick + cas ;
11387: LD_ADDR_VAR 0 7
11391: PUSH
11392: LD_OWVAR 1
11396: PUSH
11397: LD_VAR 0 2
11401: PLUS
11402: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
11403: LD_VAR 0 5
11407: NOT
11408: PUSH
11409: LD_OWVAR 1
11413: PUSH
11414: LD_VAR 0 7
11418: LESS
11419: AND
11420: IFFALSE 11490
// begin vsichni_ready := true ;
11422: LD_ADDR_VAR 0 5
11426: PUSH
11427: LD_INT 1
11429: ST_TO_ADDR
// k := k + 1 ;
11430: LD_ADDR_VAR 0 6
11434: PUSH
11435: LD_VAR 0 6
11439: PUSH
11440: LD_INT 1
11442: PLUS
11443: ST_TO_ADDR
// for i in cars do
11444: LD_ADDR_VAR 0 4
11448: PUSH
11449: LD_VAR 0 1
11453: PUSH
11454: FOR_IN
11455: IFFALSE 11479
// if not IsDrivenBy ( i ) then
11457: LD_VAR 0 4
11461: PPUSH
11462: CALL_OW 311
11466: NOT
11467: IFFALSE 11477
// vsichni_ready := false ;
11469: LD_ADDR_VAR 0 5
11473: PUSH
11474: LD_INT 0
11476: ST_TO_ADDR
11477: GO 11454
11479: POP
11480: POP
// wait ( 0 0$1.0 ) ;
11481: LD_INT 35
11483: PPUSH
11484: CALL_OW 67
// end ;
11488: GO 11403
// end ;
11490: LD_VAR 0 3
11494: RET
// export function rev ( list ) ; var i ; begin
11495: LD_INT 0
11497: PPUSH
11498: PPUSH
// for i := list + 0 to 1 do
11499: LD_ADDR_VAR 0 3
11503: PUSH
11504: DOUBLE
11505: LD_VAR 0 1
11509: PUSH
11510: LD_INT 0
11512: PLUS
11513: DEC
11514: ST_TO_ADDR
11515: LD_INT 1
11517: PUSH
11518: FOR_TO
11519: IFFALSE 11548
// result := result ^ [ list [ i ] ] ;
11521: LD_ADDR_VAR 0 2
11525: PUSH
11526: LD_VAR 0 2
11530: PUSH
11531: LD_VAR 0 1
11535: PUSH
11536: LD_VAR 0 3
11540: ARRAY
11541: PUSH
11542: EMPTY
11543: LIST
11544: ADD
11545: ST_TO_ADDR
11546: GO 11518
11548: POP
11549: POP
// end ; end_of_file
11550: LD_VAR 0 2
11554: RET
// export under_attack ; export near_base_area ; export function inicializace_ai_defend ; begin
11555: LD_INT 0
11557: PPUSH
// under_attack := [ false , false , false , false , false ] ;
11558: LD_ADDR_EXP 62
11562: PUSH
11563: LD_INT 0
11565: PUSH
11566: LD_INT 0
11568: PUSH
11569: LD_INT 0
11571: PUSH
11572: LD_INT 0
11574: PUSH
11575: LD_INT 0
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: ST_TO_ADDR
// near_base_area := [ nearA , nearB , nearC , nearD , nearE ] ;
11585: LD_ADDR_EXP 63
11589: PUSH
11590: LD_INT 24
11592: PUSH
11593: LD_INT 25
11595: PUSH
11596: LD_INT 26
11598: PUSH
11599: LD_INT 27
11601: PUSH
11602: LD_INT 28
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: ST_TO_ADDR
// end ;
11612: LD_VAR 0 1
11616: RET
// export BehMcRegId , BehMcAttId ; export function BehemothUtok ; begin
11617: LD_INT 0
11619: PPUSH
// if GetSide ( behemoth ) = you then
11620: LD_INT 125
11622: PPUSH
11623: CALL_OW 255
11627: PUSH
11628: LD_EXP 7
11632: EQUAL
11633: IFFALSE 11637
// exit ;
11635: GO 11803
// BehMcRegId := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11637: LD_ADDR_EXP 64
11641: PUSH
11642: LD_EXP 23
11646: PUSH
11647: LD_INT 1
11649: ARRAY
11650: PPUSH
11651: LD_INT 1
11653: PUSH
11654: LD_INT 140
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 4
11663: PUSH
11664: LD_EXP 42
11668: PUSH
11669: EMPTY
11670: LIST
11671: PUSH
11672: EMPTY
11673: LIST
11674: LIST
11675: PUSH
11676: LD_INT 10
11678: PUSH
11679: LD_EXP 41
11683: PUSH
11684: EMPTY
11685: LIST
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 3
11693: PUSH
11694: LD_EXP 63
11698: PUSH
11699: LD_EXP 25
11703: ARRAY
11704: PUSH
11705: EMPTY
11706: LIST
11707: LIST
11708: PUSH
11709: LD_INT 7
11711: PUSH
11712: LD_INT 8
11714: NEG
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 399
11728: ST_TO_ADDR
// BehMcAttId := McAttack ( 12 , BehMcRegId , [ behemoth ] , [ [ mc_retreat_area_vehicles , nearA ] , [ mc_retreat_area_people , nearA ] , [ mc_retreat_lives_vehicles , 600 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11729: LD_ADDR_EXP 65
11733: PUSH
11734: LD_INT 12
11736: PPUSH
11737: LD_EXP 64
11741: PPUSH
11742: LD_INT 125
11744: PUSH
11745: EMPTY
11746: LIST
11747: PPUSH
11748: LD_INT 8
11750: PUSH
11751: LD_INT 24
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 7
11760: PUSH
11761: LD_INT 24
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: PUSH
11768: LD_INT 6
11770: PUSH
11771: LD_INT 600
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PUSH
11778: LD_INT 5
11780: PUSH
11781: LD_INT 800
11783: PUSH
11784: EMPTY
11785: LIST
11786: LIST
11787: PUSH
11788: LD_INT 10
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 402
11802: ST_TO_ADDR
// end ;
11803: LD_VAR 0 1
11807: RET
// export ZouMcRegId , ZouMcAttId ; export function ZoufalUtok ; begin
11808: LD_INT 0
11810: PPUSH
// ZouMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11811: LD_ADDR_EXP 66
11815: PUSH
11816: LD_EXP 23
11820: PUSH
11821: LD_EXP 25
11825: ARRAY
11826: PPUSH
11827: LD_INT 1
11829: PUSH
11830: LD_INT 140
11832: PUSH
11833: EMPTY
11834: LIST
11835: LIST
11836: PUSH
11837: LD_INT 4
11839: PUSH
11840: LD_EXP 42
11844: PUSH
11845: EMPTY
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: PUSH
11852: LD_INT 10
11854: PUSH
11855: LD_EXP 41
11859: PUSH
11860: EMPTY
11861: LIST
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 3
11869: PUSH
11870: LD_EXP 63
11874: PUSH
11875: LD_EXP 25
11879: ARRAY
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PUSH
11885: LD_INT 7
11887: PUSH
11888: LD_INT 8
11890: NEG
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: LIST
11896: LIST
11897: LIST
11898: LIST
11899: PPUSH
11900: CALL_OW 399
11904: ST_TO_ADDR
// ZouMcAttId := McAttack ( 12 , ZouMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11905: LD_ADDR_EXP 67
11909: PUSH
11910: LD_INT 12
11912: PPUSH
11913: LD_EXP 66
11917: PPUSH
11918: LD_EXP 77
11922: PUSH
11923: LD_EXP 25
11927: ARRAY
11928: PPUSH
11929: LD_INT 8
11931: PUSH
11932: LD_EXP 63
11936: PUSH
11937: LD_EXP 25
11941: ARRAY
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 7
11949: PUSH
11950: LD_EXP 63
11954: PUSH
11955: LD_EXP 25
11959: ARRAY
11960: PUSH
11961: EMPTY
11962: LIST
11963: LIST
11964: PUSH
11965: LD_INT 6
11967: PUSH
11968: LD_INT 100
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 5
11977: PUSH
11978: LD_INT 800
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PUSH
11985: LD_INT 10
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: PPUSH
11995: CALL_OW 402
11999: ST_TO_ADDR
// end ;
12000: LD_VAR 0 1
12004: RET
// export NorMcRegId , NorMcAttId ; export function NormalUtok ; begin
12005: LD_INT 0
12007: PPUSH
// NorMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ your_humans ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
12008: LD_ADDR_EXP 68
12012: PUSH
12013: LD_EXP 23
12017: PUSH
12018: LD_EXP 25
12022: ARRAY
12023: PPUSH
12024: LD_INT 1
12026: PUSH
12027: LD_INT 140
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 4
12036: PUSH
12037: LD_EXP 42
12041: PUSH
12042: EMPTY
12043: LIST
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PUSH
12049: LD_INT 10
12051: PUSH
12052: LD_EXP 37
12056: PUSH
12057: EMPTY
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 3
12066: PUSH
12067: LD_EXP 63
12071: PUSH
12072: LD_EXP 25
12076: ARRAY
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 7
12084: PUSH
12085: LD_INT 8
12087: NEG
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: PPUSH
12097: CALL_OW 399
12101: ST_TO_ADDR
// NorMcAttId := McAttack ( 12 , NorMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12102: LD_ADDR_EXP 69
12106: PUSH
12107: LD_INT 12
12109: PPUSH
12110: LD_EXP 68
12114: PPUSH
12115: LD_EXP 77
12119: PUSH
12120: LD_EXP 25
12124: ARRAY
12125: PPUSH
12126: LD_INT 8
12128: PUSH
12129: LD_EXP 63
12133: PUSH
12134: LD_EXP 25
12138: ARRAY
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 7
12146: PUSH
12147: LD_EXP 63
12151: PUSH
12152: LD_EXP 25
12156: ARRAY
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 6
12164: PUSH
12165: LD_INT 100
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: LD_INT 5
12174: PUSH
12175: LD_INT 800
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 10
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: LIST
12189: LIST
12190: LIST
12191: PPUSH
12192: CALL_OW 402
12196: ST_TO_ADDR
// end ;
12197: LD_VAR 0 1
12201: RET
// function utok_na_vetrelce ( vetrelci , index_strany ) ; var nearest , units ; begin
12202: LD_INT 0
12204: PPUSH
12205: PPUSH
12206: PPUSH
// if vetrelci and ( ai_s [ index_strany ] in aiZ ) then
12207: LD_VAR 0 1
12211: PUSH
12212: LD_EXP 23
12216: PUSH
12217: LD_VAR 0 2
12221: ARRAY
12222: PUSH
12223: LD_EXP 21
12227: IN
12228: AND
12229: IFFALSE 12332
// begin nearest := NearestUnitToUnit ( vetrelci , depots [ index_strany ] ) ;
12231: LD_ADDR_VAR 0 4
12235: PUSH
12236: LD_VAR 0 1
12240: PPUSH
12241: LD_EXP 74
12245: PUSH
12246: LD_VAR 0 2
12250: ARRAY
12251: PPUSH
12252: CALL_OW 74
12256: ST_TO_ADDR
// if nearest then
12257: LD_VAR 0 4
12261: IFFALSE 12332
// begin units := attack_units isect vehicles [ index_strany ] ;
12263: LD_ADDR_VAR 0 5
12267: PUSH
12268: LD_EXP 78
12272: PUSH
12273: LD_EXP 77
12277: PUSH
12278: LD_VAR 0 2
12282: ARRAY
12283: ISECT
12284: ST_TO_ADDR
// ComRemember ( units ) ;
12285: LD_VAR 0 5
12289: PPUSH
12290: CALL_OW 143
// AddComAgressiveMove ( units , GetX ( nearest ) , GetY ( nearest ) ) ;
12294: LD_VAR 0 5
12298: PPUSH
12299: LD_VAR 0 4
12303: PPUSH
12304: CALL_OW 250
12308: PPUSH
12309: LD_VAR 0 4
12313: PPUSH
12314: CALL_OW 251
12318: PPUSH
12319: CALL_OW 174
// AddComReturn ( units ) ;
12323: LD_VAR 0 5
12327: PPUSH
12328: CALL_OW 204
// end ; end ; end ;
12332: LD_VAR 0 3
12336: RET
// every 0 0$10 do var i , a ;
12337: GO 12339
12339: DISABLE
12340: LD_INT 0
12342: PPUSH
12343: PPUSH
// begin for i := 1 to 5 do
12344: LD_ADDR_VAR 0 1
12348: PUSH
12349: DOUBLE
12350: LD_INT 1
12352: DEC
12353: ST_TO_ADDR
12354: LD_INT 5
12356: PUSH
12357: FOR_TO
12358: IFFALSE 12497
// begin a := UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ i ] ] ] ) ;
12360: LD_ADDR_VAR 0 2
12364: PUSH
12365: LD_EXP 37
12369: PUSH
12370: LD_EXP 35
12374: ADD
12375: PPUSH
12376: LD_INT 95
12378: PUSH
12379: LD_EXP 63
12383: PUSH
12384: LD_VAR 0 1
12388: ARRAY
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: PPUSH
12397: CALL_OW 72
12401: ST_TO_ADDR
// if a and ai_s [ i ] in aiZ then
12402: LD_VAR 0 2
12406: PUSH
12407: LD_EXP 23
12411: PUSH
12412: LD_VAR 0 1
12416: ARRAY
12417: PUSH
12418: LD_EXP 21
12422: IN
12423: AND
12424: IFFALSE 12465
// begin under_attack := replace ( under_attack , i , true ) ;
12426: LD_ADDR_EXP 62
12430: PUSH
12431: LD_EXP 62
12435: PPUSH
12436: LD_VAR 0 1
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: CALL_OW 1
12448: ST_TO_ADDR
// utok_na_vetrelce ( a , i ) ;
12449: LD_VAR 0 2
12453: PPUSH
12454: LD_VAR 0 1
12458: PPUSH
12459: CALL 12202 0 2
// end else
12463: GO 12488
// under_attack := replace ( under_attack , i , false ) ;
12465: LD_ADDR_EXP 62
12469: PUSH
12470: LD_EXP 62
12474: PPUSH
12475: LD_VAR 0 1
12479: PPUSH
12480: LD_INT 0
12482: PPUSH
12483: CALL_OW 1
12487: ST_TO_ADDR
// wait ( 0 0$2 ) ;
12488: LD_INT 70
12490: PPUSH
12491: CALL_OW 67
// end ;
12495: GO 12357
12497: POP
12498: POP
// enable ;
12499: ENABLE
// end ; end_of_file
12500: PPOPN 2
12502: END
// var repair_site ; export rc ; export bc ; export function inicializace_ai_c_repair ; begin
12503: LD_INT 0
12505: PPUSH
// repair_site := [ [ 30 , 29 ] , [ 89 , 17 ] , [ 72 , 125 ] , [ 215 , 140 ] , [ 184 , 85 ] ] ;
12506: LD_ADDR_LOC 16
12510: PUSH
12511: LD_INT 30
12513: PUSH
12514: LD_INT 29
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 89
12523: PUSH
12524: LD_INT 17
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: LD_INT 72
12533: PUSH
12534: LD_INT 125
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 215
12543: PUSH
12544: LD_INT 140
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 184
12553: PUSH
12554: LD_INT 85
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: ST_TO_ADDR
// bc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12568: LD_ADDR_EXP 71
12572: PUSH
12573: EMPTY
12574: PUSH
12575: EMPTY
12576: PUSH
12577: EMPTY
12578: PUSH
12579: EMPTY
12580: PUSH
12581: EMPTY
12582: PUSH
12583: EMPTY
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: ST_TO_ADDR
// rc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12590: LD_ADDR_EXP 70
12594: PUSH
12595: EMPTY
12596: PUSH
12597: EMPTY
12598: PUSH
12599: EMPTY
12600: PUSH
12601: EMPTY
12602: PUSH
12603: EMPTY
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: ST_TO_ADDR
// end ;
12612: LD_VAR 0 1
12616: RET
// every 0 0$5.0 + 0 0$0.5 do var i ;
12617: GO 12619
12619: DISABLE
12620: LD_INT 0
12622: PPUSH
// begin for i := 1 to 5 do
12623: LD_ADDR_VAR 0 1
12627: PUSH
12628: DOUBLE
12629: LD_INT 1
12631: DEC
12632: ST_TO_ADDR
12633: LD_INT 5
12635: PUSH
12636: FOR_TO
12637: IFFALSE 12692
// if ai_s [ i ] in ai then
12639: LD_EXP 23
12643: PUSH
12644: LD_VAR 0 1
12648: ARRAY
12649: PUSH
12650: LD_EXP 24
12654: IN
12655: IFFALSE 12690
// begin dop_pal ( vehicles [ i ] , depots [ i ] ) ;
12657: LD_EXP 77
12661: PUSH
12662: LD_VAR 0 1
12666: ARRAY
12667: PPUSH
12668: LD_EXP 74
12672: PUSH
12673: LD_VAR 0 1
12677: ARRAY
12678: PPUSH
12679: CALL 12698 0 2
// wait ( 0 0$1 ) ;
12683: LD_INT 35
12685: PPUSH
12686: CALL_OW 67
// end ;
12690: GO 12636
12692: POP
12693: POP
// enable ;
12694: ENABLE
// end ;
12695: PPOPN 1
12697: END
// function dop_pal ( tc , tdep ) ; var set_fuel , fuel ; begin
12698: LD_INT 0
12700: PPUSH
12701: PPUSH
12702: PPUSH
// for set_fuel in UnitFilter ( tc , [ [ f_dist , tdep , 40 ] ] ) do
12703: LD_ADDR_VAR 0 4
12707: PUSH
12708: LD_VAR 0 1
12712: PPUSH
12713: LD_INT 91
12715: PUSH
12716: LD_VAR 0 2
12720: PUSH
12721: LD_INT 40
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: LIST
12728: PUSH
12729: EMPTY
12730: LIST
12731: PPUSH
12732: CALL_OW 72
12736: PUSH
12737: FOR_IN
12738: IFFALSE 12785
// begin fuel := GetFuel ( set_fuel ) ;
12740: LD_ADDR_VAR 0 5
12744: PUSH
12745: LD_VAR 0 4
12749: PPUSH
12750: CALL_OW 261
12754: ST_TO_ADDR
// if fuel <= 80 then
12755: LD_VAR 0 5
12759: PUSH
12760: LD_INT 80
12762: LESSEQUAL
12763: IFFALSE 12783
// SetFuel ( set_fuel , fuel + 20 ) ;
12765: LD_VAR 0 4
12769: PPUSH
12770: LD_VAR 0 5
12774: PUSH
12775: LD_INT 20
12777: PLUS
12778: PPUSH
12779: CALL_OW 240
// end ;
12783: GO 12737
12785: POP
12786: POP
// end ;
12787: LD_VAR 0 3
12791: RET
// every 0 0$5 + 0 0$0.3 do var zivoty , i , rem_t , add_t , k ;
12792: GO 12794
12794: DISABLE
12795: LD_INT 0
12797: PPUSH
12798: PPUSH
12799: PPUSH
12800: PPUSH
12801: PPUSH
// begin for k := 1 to 5 do
12802: LD_ADDR_VAR 0 5
12806: PUSH
12807: DOUBLE
12808: LD_INT 1
12810: DEC
12811: ST_TO_ADDR
12812: LD_INT 5
12814: PUSH
12815: FOR_TO
12816: IFFALSE 13134
// if ai_s [ k ] in ai then
12818: LD_EXP 23
12822: PUSH
12823: LD_VAR 0 5
12827: ARRAY
12828: PUSH
12829: LD_EXP 24
12833: IN
12834: IFFALSE 13110
// begin rem_t := [ ] ;
12836: LD_ADDR_VAR 0 3
12840: PUSH
12841: EMPTY
12842: ST_TO_ADDR
// add_t := [ ] ;
12843: LD_ADDR_VAR 0 4
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i in UnitFilter ( vehicles [ k ] , [ [ f_not , [ f_side , you ] ] ] ) do
12850: LD_ADDR_VAR 0 2
12854: PUSH
12855: LD_EXP 77
12859: PUSH
12860: LD_VAR 0 5
12864: ARRAY
12865: PPUSH
12866: LD_INT 3
12868: PUSH
12869: LD_INT 22
12871: PUSH
12872: LD_EXP 7
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: EMPTY
12886: LIST
12887: PPUSH
12888: CALL_OW 72
12892: PUSH
12893: FOR_IN
12894: IFFALSE 12962
// begin if GetLives ( i ) < 500 then
12896: LD_VAR 0 2
12900: PPUSH
12901: CALL_OW 256
12905: PUSH
12906: LD_INT 500
12908: LESS
12909: IFFALSE 12929
// begin rem_t := rem_t ^ i ;
12911: LD_ADDR_VAR 0 3
12915: PUSH
12916: LD_VAR 0 3
12920: PUSH
12921: LD_VAR 0 2
12925: ADD
12926: ST_TO_ADDR
// end else
12927: GO 12960
// if GetLives ( i ) >= 950 then
12929: LD_VAR 0 2
12933: PPUSH
12934: CALL_OW 256
12938: PUSH
12939: LD_INT 950
12941: GREATEREQUAL
12942: IFFALSE 12960
// begin add_t := add_t ^ i ;
12944: LD_ADDR_VAR 0 4
12948: PUSH
12949: LD_VAR 0 4
12953: PUSH
12954: LD_VAR 0 2
12958: ADD
12959: ST_TO_ADDR
// end ; end ;
12960: GO 12893
12962: POP
12963: POP
// bc := replace ( bc , k , bc [ k ] union rem_t ) ;
12964: LD_ADDR_EXP 71
12968: PUSH
12969: LD_EXP 71
12973: PPUSH
12974: LD_VAR 0 5
12978: PPUSH
12979: LD_EXP 71
12983: PUSH
12984: LD_VAR 0 5
12988: ARRAY
12989: PUSH
12990: LD_VAR 0 3
12994: UNION
12995: PPUSH
12996: CALL_OW 1
13000: ST_TO_ADDR
// bc := replace ( bc , k , bc [ k ] diff add_t ) ;
13001: LD_ADDR_EXP 71
13005: PUSH
13006: LD_EXP 71
13010: PPUSH
13011: LD_VAR 0 5
13015: PPUSH
13016: LD_EXP 71
13020: PUSH
13021: LD_VAR 0 5
13025: ARRAY
13026: PUSH
13027: LD_VAR 0 4
13031: DIFF
13032: PPUSH
13033: CALL_OW 1
13037: ST_TO_ADDR
// remove_from_vehicles ( rem_t ) ;
13038: LD_VAR 0 3
13042: PPUSH
13043: CALL 28194 0 1
// add_to_vehicles ( add_t ) ;
13047: LD_VAR 0 4
13051: PPUSH
13052: CALL 26863 0 1
// ComMoveXY ( bc [ k ] , repair_site [ k ] [ 1 ] , repair_site [ k ] [ 2 ] ) ;
13056: LD_EXP 71
13060: PUSH
13061: LD_VAR 0 5
13065: ARRAY
13066: PPUSH
13067: LD_LOC 16
13071: PUSH
13072: LD_VAR 0 5
13076: ARRAY
13077: PUSH
13078: LD_INT 1
13080: ARRAY
13081: PPUSH
13082: LD_LOC 16
13086: PUSH
13087: LD_VAR 0 5
13091: ARRAY
13092: PUSH
13093: LD_INT 2
13095: ARRAY
13096: PPUSH
13097: CALL_OW 111
// wait ( 0 0$0.9 ) ;
13101: LD_INT 32
13103: PPUSH
13104: CALL_OW 67
// end else
13108: GO 13132
// bc := replace ( bc , k , [ ] ) ;
13110: LD_ADDR_EXP 71
13114: PUSH
13115: LD_EXP 71
13119: PPUSH
13120: LD_VAR 0 5
13124: PPUSH
13125: EMPTY
13126: PPUSH
13127: CALL_OW 1
13131: ST_TO_ADDR
13132: GO 12815
13134: POP
13135: POP
// enable ;
13136: ENABLE
// end ;
13137: PPOPN 5
13139: END
// every 0 0$5 + 0 0$0.1 do var zivoty , i , rc_t , k ;
13140: GO 13142
13142: DISABLE
13143: LD_INT 0
13145: PPUSH
13146: PPUSH
13147: PPUSH
13148: PPUSH
// begin for k := 1 to 5 do
13149: LD_ADDR_VAR 0 4
13153: PUSH
13154: DOUBLE
13155: LD_INT 1
13157: DEC
13158: ST_TO_ADDR
13159: LD_INT 5
13161: PUSH
13162: FOR_TO
13163: IFFALSE 13330
// if ai_s [ k ] in ai then
13165: LD_EXP 23
13169: PUSH
13170: LD_VAR 0 4
13174: ARRAY
13175: PUSH
13176: LD_EXP 24
13180: IN
13181: IFFALSE 13306
// begin rc_t := [ ] ;
13183: LD_ADDR_VAR 0 3
13187: PUSH
13188: EMPTY
13189: ST_TO_ADDR
// for i in bc [ k ] do
13190: LD_ADDR_VAR 0 2
13194: PUSH
13195: LD_EXP 71
13199: PUSH
13200: LD_VAR 0 4
13204: ARRAY
13205: PUSH
13206: FOR_IN
13207: IFFALSE 13263
// begin if GetLives ( i ) < 950 then
13209: LD_VAR 0 2
13213: PPUSH
13214: CALL_OW 256
13218: PUSH
13219: LD_INT 950
13221: LESS
13222: IFFALSE 13261
// begin rc_t := rc_t ^ i ;
13224: LD_ADDR_VAR 0 3
13228: PUSH
13229: LD_VAR 0 3
13233: PUSH
13234: LD_VAR 0 2
13238: ADD
13239: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
13240: LD_ADDR_VAR 0 1
13244: PUSH
13245: LD_VAR 0 1
13249: PUSH
13250: LD_VAR 0 2
13254: PPUSH
13255: CALL_OW 256
13259: ADD
13260: ST_TO_ADDR
// end ; end ;
13261: GO 13206
13263: POP
13264: POP
// SortListByListAsc ( rc_t , zivoty ) ;
13265: LD_VAR 0 3
13269: PPUSH
13270: LD_VAR 0 1
13274: PPUSH
13275: CALL_OW 76
// rc := replace ( rc , k , rc_t ) ;
13279: LD_ADDR_EXP 70
13283: PUSH
13284: LD_EXP 70
13288: PPUSH
13289: LD_VAR 0 4
13293: PPUSH
13294: LD_VAR 0 3
13298: PPUSH
13299: CALL_OW 1
13303: ST_TO_ADDR
// end else
13304: GO 13328
// rc := replace ( rc , k , [ ] ) ;
13306: LD_ADDR_EXP 70
13310: PUSH
13311: LD_EXP 70
13315: PPUSH
13316: LD_VAR 0 4
13320: PPUSH
13321: EMPTY
13322: PPUSH
13323: CALL_OW 1
13327: ST_TO_ADDR
13328: GO 13162
13330: POP
13331: POP
// enable ;
13332: ENABLE
// end ;
13333: PPOPN 4
13335: END
// every 0 0$5 + 0 0$0.9 do var i ;
13336: GO 13338
13338: DISABLE
13339: LD_INT 0
13341: PPUSH
// begin for i := 1 to 5 do
13342: LD_ADDR_VAR 0 1
13346: PUSH
13347: DOUBLE
13348: LD_INT 1
13350: DEC
13351: ST_TO_ADDR
13352: LD_INT 5
13354: PUSH
13355: FOR_TO
13356: IFFALSE 13411
// if ai_s [ i ] in ai then
13358: LD_EXP 23
13362: PUSH
13363: LD_VAR 0 1
13367: ARRAY
13368: PUSH
13369: LD_EXP 24
13373: IN
13374: IFFALSE 13409
// begin rep ( ai_s [ i ] , rc [ i ] ) ;
13376: LD_EXP 23
13380: PUSH
13381: LD_VAR 0 1
13385: ARRAY
13386: PPUSH
13387: LD_EXP 70
13391: PUSH
13392: LD_VAR 0 1
13396: ARRAY
13397: PPUSH
13398: CALL 13417 0 2
// wait ( 0 0$0.8 ) ;
13402: LD_INT 28
13404: PPUSH
13405: CALL_OW 67
// end ;
13409: GO 13355
13411: POP
13412: POP
// enable ;
13413: ENABLE
// end ;
13414: PPOPN 1
13416: END
// function rep ( side , rep_cars ) ; var a ; begin
13417: LD_INT 0
13419: PPUSH
13420: PPUSH
// if ( side in ai ) and rep_cars then
13421: LD_VAR 0 1
13425: PUSH
13426: LD_EXP 24
13430: IN
13431: PUSH
13432: LD_VAR 0 2
13436: AND
13437: IFFALSE 13966
// begin if rep_cars [ 1 ] < 400 then
13439: LD_VAR 0 2
13443: PUSH
13444: LD_INT 1
13446: ARRAY
13447: PUSH
13448: LD_INT 400
13450: LESS
13451: IFFALSE 13550
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13453: LD_ADDR_VAR 0 4
13457: PUSH
13458: LD_EXP 86
13462: PPUSH
13463: LD_INT 22
13465: PUSH
13466: LD_VAR 0 1
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: PUSH
13475: LD_INT 91
13477: PUSH
13478: LD_VAR 0 2
13482: PUSH
13483: LD_INT 1
13485: ARRAY
13486: PUSH
13487: LD_INT 20
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PPUSH
13499: CALL_OW 72
13503: PPUSH
13504: LD_INT 2
13506: PPUSH
13507: LD_INT 3
13509: PPUSH
13510: LD_INT 0
13512: PPUSH
13513: LD_INT 0
13515: PPUSH
13516: CALL 10035 0 5
13520: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13521: LD_VAR 0 4
13525: PPUSH
13526: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13530: LD_VAR 0 4
13534: PPUSH
13535: LD_VAR 0 2
13539: PUSH
13540: LD_INT 1
13542: ARRAY
13543: PPUSH
13544: CALL_OW 189
// end else
13548: GO 13966
// if rep_cars [ 1 ] < 700 or rep_cars >= 2 then
13550: LD_VAR 0 2
13554: PUSH
13555: LD_INT 1
13557: ARRAY
13558: PUSH
13559: LD_INT 700
13561: LESS
13562: PUSH
13563: LD_VAR 0 2
13567: PUSH
13568: LD_INT 2
13570: GREATEREQUAL
13571: OR
13572: IFFALSE 13766
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , false ) ;
13574: LD_ADDR_VAR 0 4
13578: PUSH
13579: LD_EXP 86
13583: PPUSH
13584: LD_INT 22
13586: PUSH
13587: LD_VAR 0 1
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 91
13598: PUSH
13599: LD_VAR 0 2
13603: PUSH
13604: LD_INT 1
13606: ARRAY
13607: PUSH
13608: LD_INT 20
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: PPUSH
13620: CALL_OW 72
13624: PPUSH
13625: LD_INT 1
13627: PPUSH
13628: LD_INT 3
13630: PPUSH
13631: LD_INT 0
13633: PPUSH
13634: LD_INT 0
13636: PPUSH
13637: CALL 10035 0 5
13641: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13642: LD_VAR 0 4
13646: PPUSH
13647: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13651: LD_VAR 0 4
13655: PPUSH
13656: LD_VAR 0 2
13660: PUSH
13661: LD_INT 1
13663: ARRAY
13664: PPUSH
13665: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , true ) ;
13669: LD_ADDR_VAR 0 4
13673: PUSH
13674: LD_EXP 86
13678: PPUSH
13679: LD_INT 22
13681: PUSH
13682: LD_VAR 0 1
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: LD_INT 91
13693: PUSH
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 2
13701: ARRAY
13702: PUSH
13703: LD_INT 20
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: LIST
13710: PUSH
13711: EMPTY
13712: LIST
13713: LIST
13714: PPUSH
13715: CALL_OW 72
13719: PPUSH
13720: LD_INT 1
13722: PPUSH
13723: LD_INT 3
13725: PPUSH
13726: LD_INT 0
13728: PPUSH
13729: LD_INT 1
13731: PPUSH
13732: CALL 10035 0 5
13736: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13737: LD_VAR 0 4
13741: PPUSH
13742: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13746: LD_VAR 0 4
13750: PPUSH
13751: LD_VAR 0 2
13755: PUSH
13756: LD_INT 2
13758: ARRAY
13759: PPUSH
13760: CALL_OW 189
// end else
13764: GO 13966
// if rep_cars >= 3 then
13766: LD_VAR 0 2
13770: PUSH
13771: LD_INT 3
13773: GREATEREQUAL
13774: IFFALSE 13966
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13776: LD_ADDR_VAR 0 4
13780: PUSH
13781: LD_EXP 86
13785: PPUSH
13786: LD_INT 22
13788: PUSH
13789: LD_VAR 0 1
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PUSH
13798: LD_INT 91
13800: PUSH
13801: LD_VAR 0 2
13805: PUSH
13806: LD_INT 1
13808: ARRAY
13809: PUSH
13810: LD_INT 20
13812: PUSH
13813: EMPTY
13814: LIST
13815: LIST
13816: LIST
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: PPUSH
13822: CALL_OW 72
13826: PPUSH
13827: LD_INT 2
13829: PPUSH
13830: LD_INT 3
13832: PPUSH
13833: LD_INT 0
13835: PPUSH
13836: LD_INT 0
13838: PPUSH
13839: CALL 10035 0 5
13843: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13844: LD_VAR 0 4
13848: PPUSH
13849: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13853: LD_VAR 0 4
13857: PPUSH
13858: LD_VAR 0 2
13862: PUSH
13863: LD_INT 1
13865: ARRAY
13866: PPUSH
13867: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , true ) ;
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: LD_EXP 86
13880: PPUSH
13881: LD_INT 22
13883: PUSH
13884: LD_VAR 0 1
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PUSH
13893: LD_INT 91
13895: PUSH
13896: LD_VAR 0 2
13900: PUSH
13901: LD_INT 2
13903: ARRAY
13904: PUSH
13905: LD_INT 20
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PPUSH
13917: CALL_OW 72
13921: PPUSH
13922: LD_INT 2
13924: PPUSH
13925: LD_INT 3
13927: PPUSH
13928: LD_INT 0
13930: PPUSH
13931: LD_INT 1
13933: PPUSH
13934: CALL 10035 0 5
13938: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13939: LD_VAR 0 4
13943: PPUSH
13944: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13948: LD_VAR 0 4
13952: PPUSH
13953: LD_VAR 0 2
13957: PUSH
13958: LD_INT 2
13960: ARRAY
13961: PPUSH
13962: CALL_OW 189
// end ; end ; end ; end_of_file
13966: LD_VAR 0 3
13970: RET
// var d1 , d2 , d3 , d5 , d6 , d7 ; export function inicializace_ai_c_make ; begin
13971: LD_INT 0
13973: PPUSH
// d1 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ;
13974: LD_ADDR_LOC 17
13978: PUSH
13979: LD_INT 23
13981: PUSH
13982: LD_INT 1
13984: PUSH
13985: LD_INT 1
13987: PUSH
13988: LD_INT 43
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: ST_TO_ADDR
// d2 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] ;
13997: LD_ADDR_LOC 18
14001: PUSH
14002: LD_INT 23
14004: PUSH
14005: LD_INT 1
14007: PUSH
14008: LD_INT 1
14010: PUSH
14011: LD_INT 45
14013: PUSH
14014: EMPTY
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: ST_TO_ADDR
// d3 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] ;
14020: LD_ADDR_LOC 19
14024: PUSH
14025: LD_INT 23
14027: PUSH
14028: LD_INT 1
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: LD_INT 46
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: ST_TO_ADDR
// d5 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_gatling_gun ] ;
14043: LD_ADDR_LOC 20
14047: PUSH
14048: LD_INT 23
14050: PUSH
14051: LD_INT 3
14053: PUSH
14054: LD_INT 3
14056: PUSH
14057: LD_INT 43
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: ST_TO_ADDR
// d6 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_rocket_launcher ] ;
14066: LD_ADDR_LOC 21
14070: PUSH
14071: LD_INT 23
14073: PUSH
14074: LD_INT 3
14076: PUSH
14077: LD_INT 3
14079: PUSH
14080: LD_INT 45
14082: PUSH
14083: EMPTY
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: ST_TO_ADDR
// d7 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_heavy_gun ] ;
14089: LD_ADDR_LOC 22
14093: PUSH
14094: LD_INT 23
14096: PUSH
14097: LD_INT 3
14099: PUSH
14100: LD_INT 3
14102: PUSH
14103: LD_INT 46
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: ST_TO_ADDR
// end ;
14112: LD_VAR 0 1
14116: RET
// every 0 0$3 do var i , a ;
14117: GO 14119
14119: DISABLE
14120: LD_INT 0
14122: PPUSH
14123: PPUSH
// begin for i := 1 to 5 do
14124: LD_ADDR_VAR 0 1
14128: PUSH
14129: DOUBLE
14130: LD_INT 1
14132: DEC
14133: ST_TO_ADDR
14134: LD_INT 5
14136: PUSH
14137: FOR_TO
14138: IFFALSE 14362
// begin if ai_s [ i ] in ai then
14140: LD_EXP 23
14144: PUSH
14145: LD_VAR 0 1
14149: ARRAY
14150: PUSH
14151: LD_EXP 24
14155: IN
14156: IFFALSE 14360
// begin if depots [ i ] then
14158: LD_EXP 74
14162: PUSH
14163: LD_VAR 0 1
14167: ARRAY
14168: IFFALSE 14360
// begin if GetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans ) < 150 then
14170: LD_EXP 74
14174: PUSH
14175: LD_VAR 0 1
14179: ARRAY
14180: PUSH
14181: LD_INT 1
14183: ARRAY
14184: PPUSH
14185: CALL_OW 274
14189: PPUSH
14190: LD_INT 1
14192: PPUSH
14193: CALL_OW 275
14197: PUSH
14198: LD_INT 150
14200: LESS
14201: IFFALSE 14245
// SetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans , 150 + Rand ( 50 , 100 ) ) ;
14203: LD_EXP 74
14207: PUSH
14208: LD_VAR 0 1
14212: ARRAY
14213: PUSH
14214: LD_INT 1
14216: ARRAY
14217: PPUSH
14218: CALL_OW 274
14222: PPUSH
14223: LD_INT 1
14225: PPUSH
14226: LD_INT 150
14228: PUSH
14229: LD_INT 50
14231: PPUSH
14232: LD_INT 100
14234: PPUSH
14235: CALL_OW 12
14239: PLUS
14240: PPUSH
14241: CALL_OW 277
// a := GetListOfCratesInArea ( near_base_area [ i ] ) ;
14245: LD_ADDR_VAR 0 2
14249: PUSH
14250: LD_EXP 63
14254: PUSH
14255: LD_VAR 0 1
14259: ARRAY
14260: PPUSH
14261: CALL_OW 435
14265: ST_TO_ADDR
// if a > 6 then
14266: LD_VAR 0 2
14270: PUSH
14271: LD_INT 6
14273: GREATER
14274: IFFALSE 14360
// for i in a do
14276: LD_ADDR_VAR 0 1
14280: PUSH
14281: LD_VAR 0 2
14285: PUSH
14286: FOR_IN
14287: IFFALSE 14358
// if not SeeXY ( you , i [ 1 ] , i [ 2 ] ) then
14289: LD_EXP 7
14293: PPUSH
14294: LD_VAR 0 1
14298: PUSH
14299: LD_INT 1
14301: ARRAY
14302: PPUSH
14303: LD_VAR 0 1
14307: PUSH
14308: LD_INT 2
14310: ARRAY
14311: PPUSH
14312: CALL_OW 293
14316: NOT
14317: IFFALSE 14356
// begin MoveAreaXY ( hexik , i [ 1 ] , i [ 2 ] ) ;
14319: LD_INT 32
14321: PPUSH
14322: LD_VAR 0 1
14326: PUSH
14327: LD_INT 1
14329: ARRAY
14330: PPUSH
14331: LD_VAR 0 1
14335: PUSH
14336: LD_INT 2
14338: ARRAY
14339: PPUSH
14340: CALL_OW 425
// EraseResourceArea ( hexik , mat_cans ) ;
14344: LD_INT 32
14346: PPUSH
14347: LD_INT 1
14349: PPUSH
14350: CALL_OW 286
// break ;
14354: GO 14358
// end ;
14356: GO 14286
14358: POP
14359: POP
// end ; end ; end ;
14360: GO 14137
14362: POP
14363: POP
// end ;
14364: PPOPN 2
14366: END
// function MyCanBeConstructed ( tfact , d ) ; begin
14367: LD_INT 0
14369: PPUSH
// result := CanBeConstructed ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14370: LD_ADDR_VAR 0 3
14374: PUSH
14375: LD_VAR 0 1
14379: PPUSH
14380: LD_VAR 0 2
14384: PUSH
14385: LD_INT 1
14387: ARRAY
14388: PPUSH
14389: LD_VAR 0 2
14393: PUSH
14394: LD_INT 2
14396: ARRAY
14397: PPUSH
14398: LD_VAR 0 2
14402: PUSH
14403: LD_INT 3
14405: ARRAY
14406: PPUSH
14407: LD_VAR 0 2
14411: PUSH
14412: LD_INT 4
14414: ARRAY
14415: PPUSH
14416: CALL_OW 448
14420: ST_TO_ADDR
// end ;
14421: LD_VAR 0 3
14425: RET
// function MyComConstruct ( tfact , d ) ; begin
14426: LD_INT 0
14428: PPUSH
// result := ComConstruct ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_VAR 0 1
14438: PPUSH
14439: LD_VAR 0 2
14443: PUSH
14444: LD_INT 1
14446: ARRAY
14447: PPUSH
14448: LD_VAR 0 2
14452: PUSH
14453: LD_INT 2
14455: ARRAY
14456: PPUSH
14457: LD_VAR 0 2
14461: PUSH
14462: LD_INT 3
14464: ARRAY
14465: PPUSH
14466: LD_VAR 0 2
14470: PUSH
14471: LD_INT 4
14473: ARRAY
14474: PPUSH
14475: CALL_OW 125
14479: ST_TO_ADDR
// end ;
14480: LD_VAR 0 3
14484: RET
// every 0 0$10 + 0 0$1.1 trigger IsOk ( factories [ 1 ] ) and IsIdle ( factories [ 1 ] ) do var a , tfact , def , att ;
14485: LD_EXP 73
14489: PUSH
14490: LD_INT 1
14492: ARRAY
14493: PPUSH
14494: CALL_OW 302
14498: PUSH
14499: LD_EXP 73
14503: PUSH
14504: LD_INT 1
14506: ARRAY
14507: PPUSH
14508: CALL_OW 316
14512: AND
14513: IFFALSE 14832
14515: GO 14517
14517: DISABLE
14518: LD_INT 0
14520: PPUSH
14521: PPUSH
14522: PPUSH
14523: PPUSH
// begin tfact := factories [ 1 ] ;
14524: LD_ADDR_VAR 0 2
14528: PUSH
14529: LD_EXP 73
14533: PUSH
14534: LD_INT 1
14536: ARRAY
14537: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 1 ] , [ mf_manu ] ) ;
14538: LD_ADDR_VAR 0 3
14542: PUSH
14543: LD_EXP 77
14547: PUSH
14548: LD_INT 1
14550: ARRAY
14551: PPUSH
14552: LD_EXP 61
14556: PUSH
14557: EMPTY
14558: LIST
14559: PPUSH
14560: CALL_OW 72
14564: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 1 ] , [ mf_comp ] ) ;
14565: LD_ADDR_VAR 0 4
14569: PUSH
14570: LD_EXP 77
14574: PUSH
14575: LD_INT 1
14577: ARRAY
14578: PPUSH
14579: LD_EXP 60
14583: PUSH
14584: EMPTY
14585: LIST
14586: PPUSH
14587: CALL_OW 72
14591: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14592: LD_INT 1
14594: PUSH
14595: LD_VAR 0 3
14599: PUSH
14600: LD_INT 2
14602: LESS
14603: PUSH
14604: LD_VAR 0 2
14608: PPUSH
14609: LD_LOC 18
14613: PPUSH
14614: CALL 14367 0 2
14618: AND
14619: DOUBLE
14620: EQUAL
14621: IFTRUE 14625
14623: GO 14642
14625: POP
// begin MyComConstruct ( tfact , d2 ) ;
14626: LD_VAR 0 2
14630: PPUSH
14631: LD_LOC 18
14635: PPUSH
14636: CALL 14426 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14640: GO 14831
14642: LD_VAR 0 3
14646: PUSH
14647: LD_INT 3
14649: LESS
14650: PUSH
14651: LD_VAR 0 2
14655: PPUSH
14656: LD_LOC 19
14660: PPUSH
14661: CALL 14367 0 2
14665: AND
14666: DOUBLE
14667: EQUAL
14668: IFTRUE 14672
14670: GO 14689
14672: POP
// begin MyComConstruct ( tfact , d3 ) ;
14673: LD_VAR 0 2
14677: PPUSH
14678: LD_LOC 19
14682: PPUSH
14683: CALL 14426 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
14687: GO 14831
14689: LD_VAR 0 4
14693: PUSH
14694: LD_INT 2
14696: LESS
14697: PUSH
14698: LD_VAR 0 2
14702: PPUSH
14703: LD_LOC 21
14707: PPUSH
14708: CALL 14367 0 2
14712: AND
14713: DOUBLE
14714: EQUAL
14715: IFTRUE 14719
14717: GO 14736
14719: POP
// begin MyComConstruct ( tfact , d6 ) ;
14720: LD_VAR 0 2
14724: PPUSH
14725: LD_LOC 21
14729: PPUSH
14730: CALL 14426 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
14734: GO 14831
14736: LD_VAR 0 4
14740: PUSH
14741: LD_INT 3
14743: LESS
14744: PUSH
14745: LD_VAR 0 2
14749: PPUSH
14750: LD_LOC 20
14754: PPUSH
14755: CALL 14367 0 2
14759: AND
14760: DOUBLE
14761: EQUAL
14762: IFTRUE 14766
14764: GO 14783
14766: POP
// begin MyComConstruct ( tfact , d5 ) ;
14767: LD_VAR 0 2
14771: PPUSH
14772: LD_LOC 20
14776: PPUSH
14777: CALL 14426 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
14781: GO 14831
14783: LD_VAR 0 4
14787: PUSH
14788: LD_INT 5
14790: LESS
14791: PUSH
14792: LD_VAR 0 2
14796: PPUSH
14797: LD_LOC 22
14801: PPUSH
14802: CALL 14367 0 2
14806: AND
14807: DOUBLE
14808: EQUAL
14809: IFTRUE 14813
14811: GO 14830
14813: POP
// begin MyComConstruct ( tfact , d7 ) ;
14814: LD_VAR 0 2
14818: PPUSH
14819: LD_LOC 22
14823: PPUSH
14824: CALL 14426 0 2
// end ; end ;
14828: GO 14831
14830: POP
// enable ;
14831: ENABLE
// end ;
14832: PPOPN 4
14834: END
// every 0 0$10 + 0 0$2.3 trigger IsOk ( factories [ 2 ] ) and IsIdle ( factories [ 2 ] ) do var a , tfact , def , att ;
14835: LD_EXP 73
14839: PUSH
14840: LD_INT 2
14842: ARRAY
14843: PPUSH
14844: CALL_OW 302
14848: PUSH
14849: LD_EXP 73
14853: PUSH
14854: LD_INT 2
14856: ARRAY
14857: PPUSH
14858: CALL_OW 316
14862: AND
14863: IFFALSE 15182
14865: GO 14867
14867: DISABLE
14868: LD_INT 0
14870: PPUSH
14871: PPUSH
14872: PPUSH
14873: PPUSH
// begin tfact := factories [ 2 ] ;
14874: LD_ADDR_VAR 0 2
14878: PUSH
14879: LD_EXP 73
14883: PUSH
14884: LD_INT 2
14886: ARRAY
14887: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 2 ] , [ mf_manu ] ) ;
14888: LD_ADDR_VAR 0 3
14892: PUSH
14893: LD_EXP 77
14897: PUSH
14898: LD_INT 2
14900: ARRAY
14901: PPUSH
14902: LD_EXP 61
14906: PUSH
14907: EMPTY
14908: LIST
14909: PPUSH
14910: CALL_OW 72
14914: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 2 ] , [ mf_comp ] ) ;
14915: LD_ADDR_VAR 0 4
14919: PUSH
14920: LD_EXP 77
14924: PUSH
14925: LD_INT 2
14927: ARRAY
14928: PPUSH
14929: LD_EXP 60
14933: PUSH
14934: EMPTY
14935: LIST
14936: PPUSH
14937: CALL_OW 72
14941: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14942: LD_INT 1
14944: PUSH
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 2
14952: LESS
14953: PUSH
14954: LD_VAR 0 2
14958: PPUSH
14959: LD_LOC 18
14963: PPUSH
14964: CALL 14367 0 2
14968: AND
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 14992
14975: POP
// begin MyComConstruct ( tfact , d2 ) ;
14976: LD_VAR 0 2
14980: PPUSH
14981: LD_LOC 18
14985: PPUSH
14986: CALL 14426 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14990: GO 15181
14992: LD_VAR 0 3
14996: PUSH
14997: LD_INT 3
14999: LESS
15000: PUSH
15001: LD_VAR 0 2
15005: PPUSH
15006: LD_LOC 19
15010: PPUSH
15011: CALL 14367 0 2
15015: AND
15016: DOUBLE
15017: EQUAL
15018: IFTRUE 15022
15020: GO 15039
15022: POP
// begin MyComConstruct ( tfact , d3 ) ;
15023: LD_VAR 0 2
15027: PPUSH
15028: LD_LOC 19
15032: PPUSH
15033: CALL 14426 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15037: GO 15181
15039: LD_VAR 0 4
15043: PUSH
15044: LD_INT 2
15046: LESS
15047: PUSH
15048: LD_VAR 0 2
15052: PPUSH
15053: LD_LOC 21
15057: PPUSH
15058: CALL 14367 0 2
15062: AND
15063: DOUBLE
15064: EQUAL
15065: IFTRUE 15069
15067: GO 15086
15069: POP
// begin MyComConstruct ( tfact , d6 ) ;
15070: LD_VAR 0 2
15074: PPUSH
15075: LD_LOC 21
15079: PPUSH
15080: CALL 14426 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15084: GO 15181
15086: LD_VAR 0 4
15090: PUSH
15091: LD_INT 3
15093: LESS
15094: PUSH
15095: LD_VAR 0 2
15099: PPUSH
15100: LD_LOC 20
15104: PPUSH
15105: CALL 14367 0 2
15109: AND
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15133
15116: POP
// begin MyComConstruct ( tfact , d5 ) ;
15117: LD_VAR 0 2
15121: PPUSH
15122: LD_LOC 20
15126: PPUSH
15127: CALL 14426 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15131: GO 15181
15133: LD_VAR 0 4
15137: PUSH
15138: LD_INT 5
15140: LESS
15141: PUSH
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_LOC 22
15151: PPUSH
15152: CALL 14367 0 2
15156: AND
15157: DOUBLE
15158: EQUAL
15159: IFTRUE 15163
15161: GO 15180
15163: POP
// begin MyComConstruct ( tfact , d7 ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: LD_LOC 22
15173: PPUSH
15174: CALL 14426 0 2
// end ; end ;
15178: GO 15181
15180: POP
// enable ;
15181: ENABLE
// end ;
15182: PPOPN 4
15184: END
// every 0 0$10 + 0 0$3.4 trigger IsOk ( factories [ 3 ] ) and IsIdle ( factories [ 3 ] ) do var a , tfact , def , att ;
15185: LD_EXP 73
15189: PUSH
15190: LD_INT 3
15192: ARRAY
15193: PPUSH
15194: CALL_OW 302
15198: PUSH
15199: LD_EXP 73
15203: PUSH
15204: LD_INT 3
15206: ARRAY
15207: PPUSH
15208: CALL_OW 316
15212: AND
15213: IFFALSE 15438
15215: GO 15217
15217: DISABLE
15218: LD_INT 0
15220: PPUSH
15221: PPUSH
15222: PPUSH
15223: PPUSH
// begin tfact := factories [ 3 ] ;
15224: LD_ADDR_VAR 0 2
15228: PUSH
15229: LD_EXP 73
15233: PUSH
15234: LD_INT 3
15236: ARRAY
15237: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 3 ] , [ mf_manu ] ) ;
15238: LD_ADDR_VAR 0 3
15242: PUSH
15243: LD_EXP 77
15247: PUSH
15248: LD_INT 3
15250: ARRAY
15251: PPUSH
15252: LD_EXP 61
15256: PUSH
15257: EMPTY
15258: LIST
15259: PPUSH
15260: CALL_OW 72
15264: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 3 ] , [ mf_comp ] ) ;
15265: LD_ADDR_VAR 0 4
15269: PUSH
15270: LD_EXP 77
15274: PUSH
15275: LD_INT 3
15277: ARRAY
15278: PPUSH
15279: LD_EXP 60
15283: PUSH
15284: EMPTY
15285: LIST
15286: PPUSH
15287: CALL_OW 72
15291: ST_TO_ADDR
// case true of def < 1 and MyCanBeConstructed ( tfact , d2 ) :
15292: LD_INT 1
15294: PUSH
15295: LD_VAR 0 3
15299: PUSH
15300: LD_INT 1
15302: LESS
15303: PUSH
15304: LD_VAR 0 2
15308: PPUSH
15309: LD_LOC 18
15313: PPUSH
15314: CALL 14367 0 2
15318: AND
15319: DOUBLE
15320: EQUAL
15321: IFTRUE 15325
15323: GO 15342
15325: POP
// begin MyComConstruct ( tfact , d2 ) ;
15326: LD_VAR 0 2
15330: PPUSH
15331: LD_LOC 18
15335: PPUSH
15336: CALL 14426 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15340: GO 15437
15342: LD_VAR 0 4
15346: PUSH
15347: LD_INT 2
15349: LESS
15350: PUSH
15351: LD_VAR 0 2
15355: PPUSH
15356: LD_LOC 21
15360: PPUSH
15361: CALL 14367 0 2
15365: AND
15366: DOUBLE
15367: EQUAL
15368: IFTRUE 15372
15370: GO 15389
15372: POP
// begin MyComConstruct ( tfact , d6 ) ;
15373: LD_VAR 0 2
15377: PPUSH
15378: LD_LOC 21
15382: PPUSH
15383: CALL 14426 0 2
// end ; att < 4 and MyCanBeConstructed ( tfact , d7 ) :
15387: GO 15437
15389: LD_VAR 0 4
15393: PUSH
15394: LD_INT 4
15396: LESS
15397: PUSH
15398: LD_VAR 0 2
15402: PPUSH
15403: LD_LOC 22
15407: PPUSH
15408: CALL 14367 0 2
15412: AND
15413: DOUBLE
15414: EQUAL
15415: IFTRUE 15419
15417: GO 15436
15419: POP
// begin MyComConstruct ( tfact , d7 ) ;
15420: LD_VAR 0 2
15424: PPUSH
15425: LD_LOC 22
15429: PPUSH
15430: CALL 14426 0 2
// end ; end ;
15434: GO 15437
15436: POP
// enable ;
15437: ENABLE
// end ;
15438: PPOPN 4
15440: END
// every 0 0$10 + 0 0$4.5 trigger IsOk ( factories [ 4 ] ) and IsIdle ( factories [ 4 ] ) do var a , tfact , def , att ;
15441: LD_EXP 73
15445: PUSH
15446: LD_INT 4
15448: ARRAY
15449: PPUSH
15450: CALL_OW 302
15454: PUSH
15455: LD_EXP 73
15459: PUSH
15460: LD_INT 4
15462: ARRAY
15463: PPUSH
15464: CALL_OW 316
15468: AND
15469: IFFALSE 15741
15471: GO 15473
15473: DISABLE
15474: LD_INT 0
15476: PPUSH
15477: PPUSH
15478: PPUSH
15479: PPUSH
// begin tfact := factories [ 4 ] ;
15480: LD_ADDR_VAR 0 2
15484: PUSH
15485: LD_EXP 73
15489: PUSH
15490: LD_INT 4
15492: ARRAY
15493: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 4 ] , [ mf_manu ] ) ;
15494: LD_ADDR_VAR 0 3
15498: PUSH
15499: LD_EXP 77
15503: PUSH
15504: LD_INT 4
15506: ARRAY
15507: PPUSH
15508: LD_EXP 61
15512: PUSH
15513: EMPTY
15514: LIST
15515: PPUSH
15516: CALL_OW 72
15520: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 4 ] , [ mf_comp ] ) ;
15521: LD_ADDR_VAR 0 4
15525: PUSH
15526: LD_EXP 77
15530: PUSH
15531: LD_INT 4
15533: ARRAY
15534: PPUSH
15535: LD_EXP 60
15539: PUSH
15540: EMPTY
15541: LIST
15542: PPUSH
15543: CALL_OW 72
15547: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15548: LD_INT 1
15550: PUSH
15551: LD_VAR 0 3
15555: PUSH
15556: LD_INT 2
15558: LESS
15559: PUSH
15560: LD_VAR 0 2
15564: PPUSH
15565: LD_LOC 18
15569: PPUSH
15570: CALL 14367 0 2
15574: AND
15575: DOUBLE
15576: EQUAL
15577: IFTRUE 15581
15579: GO 15598
15581: POP
// begin MyComConstruct ( tfact , d2 ) ;
15582: LD_VAR 0 2
15586: PPUSH
15587: LD_LOC 18
15591: PPUSH
15592: CALL 14426 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15596: GO 15740
15598: LD_VAR 0 3
15602: PUSH
15603: LD_INT 3
15605: LESS
15606: PUSH
15607: LD_VAR 0 2
15611: PPUSH
15612: LD_LOC 19
15616: PPUSH
15617: CALL 14367 0 2
15621: AND
15622: DOUBLE
15623: EQUAL
15624: IFTRUE 15628
15626: GO 15645
15628: POP
// begin MyComConstruct ( tfact , d3 ) ;
15629: LD_VAR 0 2
15633: PPUSH
15634: LD_LOC 19
15638: PPUSH
15639: CALL 14426 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15643: GO 15740
15645: LD_VAR 0 4
15649: PUSH
15650: LD_INT 2
15652: LESS
15653: PUSH
15654: LD_VAR 0 2
15658: PPUSH
15659: LD_LOC 21
15663: PPUSH
15664: CALL 14367 0 2
15668: AND
15669: DOUBLE
15670: EQUAL
15671: IFTRUE 15675
15673: GO 15692
15675: POP
// begin MyComConstruct ( tfact , d6 ) ;
15676: LD_VAR 0 2
15680: PPUSH
15681: LD_LOC 21
15685: PPUSH
15686: CALL 14426 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15690: GO 15740
15692: LD_VAR 0 4
15696: PUSH
15697: LD_INT 5
15699: LESS
15700: PUSH
15701: LD_VAR 0 2
15705: PPUSH
15706: LD_LOC 22
15710: PPUSH
15711: CALL 14367 0 2
15715: AND
15716: DOUBLE
15717: EQUAL
15718: IFTRUE 15722
15720: GO 15739
15722: POP
// begin MyComConstruct ( tfact , d7 ) ;
15723: LD_VAR 0 2
15727: PPUSH
15728: LD_LOC 22
15732: PPUSH
15733: CALL 14426 0 2
// end ; end ;
15737: GO 15740
15739: POP
// enable ;
15740: ENABLE
// end ;
15741: PPOPN 4
15743: END
// every 0 0$10 + 0 0$5.6 trigger IsOk ( factories [ 5 ] ) and IsIdle ( factories [ 5 ] ) do var a , tfact , def , att ;
15744: LD_EXP 73
15748: PUSH
15749: LD_INT 5
15751: ARRAY
15752: PPUSH
15753: CALL_OW 302
15757: PUSH
15758: LD_EXP 73
15762: PUSH
15763: LD_INT 5
15765: ARRAY
15766: PPUSH
15767: CALL_OW 316
15771: AND
15772: IFFALSE 16091
15774: GO 15776
15776: DISABLE
15777: LD_INT 0
15779: PPUSH
15780: PPUSH
15781: PPUSH
15782: PPUSH
// begin tfact := factories [ 5 ] ;
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: LD_EXP 73
15792: PUSH
15793: LD_INT 5
15795: ARRAY
15796: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 5 ] , [ mf_manu ] ) ;
15797: LD_ADDR_VAR 0 3
15801: PUSH
15802: LD_EXP 77
15806: PUSH
15807: LD_INT 5
15809: ARRAY
15810: PPUSH
15811: LD_EXP 61
15815: PUSH
15816: EMPTY
15817: LIST
15818: PPUSH
15819: CALL_OW 72
15823: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 5 ] , [ mf_comp ] ) ;
15824: LD_ADDR_VAR 0 4
15828: PUSH
15829: LD_EXP 77
15833: PUSH
15834: LD_INT 5
15836: ARRAY
15837: PPUSH
15838: LD_EXP 60
15842: PUSH
15843: EMPTY
15844: LIST
15845: PPUSH
15846: CALL_OW 72
15850: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15851: LD_INT 1
15853: PUSH
15854: LD_VAR 0 3
15858: PUSH
15859: LD_INT 2
15861: LESS
15862: PUSH
15863: LD_VAR 0 2
15867: PPUSH
15868: LD_LOC 18
15872: PPUSH
15873: CALL 14367 0 2
15877: AND
15878: DOUBLE
15879: EQUAL
15880: IFTRUE 15884
15882: GO 15901
15884: POP
// begin MyComConstruct ( tfact , d2 ) ;
15885: LD_VAR 0 2
15889: PPUSH
15890: LD_LOC 18
15894: PPUSH
15895: CALL 14426 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15899: GO 16090
15901: LD_VAR 0 3
15905: PUSH
15906: LD_INT 3
15908: LESS
15909: PUSH
15910: LD_VAR 0 2
15914: PPUSH
15915: LD_LOC 19
15919: PPUSH
15920: CALL 14367 0 2
15924: AND
15925: DOUBLE
15926: EQUAL
15927: IFTRUE 15931
15929: GO 15948
15931: POP
// begin MyComConstruct ( tfact , d3 ) ;
15932: LD_VAR 0 2
15936: PPUSH
15937: LD_LOC 19
15941: PPUSH
15942: CALL 14426 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15946: GO 16090
15948: LD_VAR 0 4
15952: PUSH
15953: LD_INT 2
15955: LESS
15956: PUSH
15957: LD_VAR 0 2
15961: PPUSH
15962: LD_LOC 21
15966: PPUSH
15967: CALL 14367 0 2
15971: AND
15972: DOUBLE
15973: EQUAL
15974: IFTRUE 15978
15976: GO 15995
15978: POP
// begin MyComConstruct ( tfact , d6 ) ;
15979: LD_VAR 0 2
15983: PPUSH
15984: LD_LOC 21
15988: PPUSH
15989: CALL 14426 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15993: GO 16090
15995: LD_VAR 0 4
15999: PUSH
16000: LD_INT 3
16002: LESS
16003: PUSH
16004: LD_VAR 0 2
16008: PPUSH
16009: LD_LOC 20
16013: PPUSH
16014: CALL 14367 0 2
16018: AND
16019: DOUBLE
16020: EQUAL
16021: IFTRUE 16025
16023: GO 16042
16025: POP
// begin MyComConstruct ( tfact , d5 ) ;
16026: LD_VAR 0 2
16030: PPUSH
16031: LD_LOC 20
16035: PPUSH
16036: CALL 14426 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
16040: GO 16090
16042: LD_VAR 0 4
16046: PUSH
16047: LD_INT 5
16049: LESS
16050: PUSH
16051: LD_VAR 0 2
16055: PPUSH
16056: LD_LOC 22
16060: PPUSH
16061: CALL 14367 0 2
16065: AND
16066: DOUBLE
16067: EQUAL
16068: IFTRUE 16072
16070: GO 16089
16072: POP
// begin MyComConstruct ( tfact , d7 ) ;
16073: LD_VAR 0 2
16077: PPUSH
16078: LD_LOC 22
16082: PPUSH
16083: CALL 14426 0 2
// end ; end ;
16087: GO 16090
16089: POP
// enable ;
16090: ENABLE
// end ; end_of_file
16091: PPOPN 4
16093: END
// var builds ; var aici ; var in_depots ; var abase ; export hlavouni ; var upgradeable ; var trough_upgrade ; export function inicializace_ai_b_build ; begin
16094: LD_INT 0
16096: PPUSH
// upgradeable := [ b_depot , b_workshop , b_armoury , b_lab , b_lab_half , b_lab ] ;
16097: LD_ADDR_LOC 27
16101: PUSH
16102: LD_INT 0
16104: PUSH
16105: LD_INT 2
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 6
16113: PUSH
16114: LD_INT 7
16116: PUSH
16117: LD_INT 6
16119: PUSH
16120: EMPTY
16121: LIST
16122: LIST
16123: LIST
16124: LIST
16125: LIST
16126: LIST
16127: ST_TO_ADDR
// trough_upgrade := [ b_warehouse , b_factory , b_barracks , b_lab_half , b_lab_full , b_lab_full ] ;
16128: LD_ADDR_LOC 28
16132: PUSH
16133: LD_INT 1
16135: PUSH
16136: LD_INT 3
16138: PUSH
16139: LD_INT 5
16141: PUSH
16142: LD_INT 7
16144: PUSH
16145: LD_INT 8
16147: PUSH
16148: LD_INT 8
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: ST_TO_ADDR
// abase := [ abase1 , abase2 , abase3 , abase4 , abase5 ] ;
16159: LD_ADDR_LOC 26
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 4
16169: PUSH
16170: LD_INT 3
16172: PUSH
16173: LD_INT 2
16175: PUSH
16176: LD_INT 1
16178: PUSH
16179: EMPTY
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: ST_TO_ADDR
// aici := [ [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 6 ] , [ 3 , class_scientistic , 6 ] , [ 8 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] , [ [ 1 , class_engineer , 8 ] , [ 3 , class_scientistic , 8 ] , [ 8 , class_soldier , 8 ] , [ 3 , class_mechanic , 8 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 3 , class_scientistic , 5 ] , [ 5 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 0 , class_scientistic , 4 ] , [ 2 , class_soldier , 4 ] , [ 1 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 4 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 4 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 4 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 1 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 1 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ] ;
16186: LD_ADDR_LOC 24
16190: PUSH
16191: LD_INT 1
16193: PUSH
16194: LD_INT 2
16196: PUSH
16197: LD_INT 4
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: LIST
16204: PUSH
16205: LD_INT 3
16207: PUSH
16208: LD_INT 4
16210: PUSH
16211: LD_INT 4
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: LIST
16218: PUSH
16219: LD_INT 8
16221: PUSH
16222: LD_INT 1
16224: PUSH
16225: LD_INT 4
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 3
16235: PUSH
16236: LD_INT 3
16238: PUSH
16239: LD_INT 4
16241: PUSH
16242: EMPTY
16243: LIST
16244: LIST
16245: LIST
16246: PUSH
16247: EMPTY
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: PUSH
16253: LD_INT 1
16255: PUSH
16256: LD_INT 2
16258: PUSH
16259: LD_INT 6
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: LIST
16266: PUSH
16267: LD_INT 3
16269: PUSH
16270: LD_INT 4
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: LIST
16280: PUSH
16281: LD_INT 8
16283: PUSH
16284: LD_INT 1
16286: PUSH
16287: LD_INT 6
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: LIST
16294: PUSH
16295: LD_INT 3
16297: PUSH
16298: LD_INT 3
16300: PUSH
16301: LD_INT 6
16303: PUSH
16304: EMPTY
16305: LIST
16306: LIST
16307: LIST
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: LIST
16313: LIST
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: LD_INT 2
16320: PUSH
16321: LD_INT 8
16323: PUSH
16324: EMPTY
16325: LIST
16326: LIST
16327: LIST
16328: PUSH
16329: LD_INT 3
16331: PUSH
16332: LD_INT 4
16334: PUSH
16335: LD_INT 8
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: LIST
16342: PUSH
16343: LD_INT 8
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: LD_INT 8
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: PUSH
16357: LD_INT 3
16359: PUSH
16360: LD_INT 3
16362: PUSH
16363: LD_INT 8
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: LIST
16370: PUSH
16371: EMPTY
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: LIST
16381: PUSH
16382: LD_OWVAR 67
16386: ARRAY
16387: PUSH
16388: LD_INT 1
16390: PUSH
16391: LD_INT 2
16393: PUSH
16394: LD_INT 4
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 3
16404: PUSH
16405: LD_INT 4
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: LIST
16415: PUSH
16416: LD_INT 5
16418: PUSH
16419: LD_INT 1
16421: PUSH
16422: LD_INT 4
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: LIST
16429: PUSH
16430: LD_INT 3
16432: PUSH
16433: LD_INT 3
16435: PUSH
16436: LD_INT 4
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: LIST
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: LIST
16448: LIST
16449: PUSH
16450: LD_INT 1
16452: PUSH
16453: LD_INT 2
16455: PUSH
16456: LD_INT 4
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: LIST
16463: PUSH
16464: LD_INT 3
16466: PUSH
16467: LD_INT 4
16469: PUSH
16470: LD_INT 4
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: LIST
16477: PUSH
16478: LD_INT 5
16480: PUSH
16481: LD_INT 1
16483: PUSH
16484: LD_INT 4
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 3
16494: PUSH
16495: LD_INT 3
16497: PUSH
16498: LD_INT 4
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 2
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: LIST
16525: PUSH
16526: LD_INT 3
16528: PUSH
16529: LD_INT 4
16531: PUSH
16532: LD_INT 5
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: LIST
16539: PUSH
16540: LD_INT 5
16542: PUSH
16543: LD_INT 1
16545: PUSH
16546: LD_INT 5
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: PUSH
16554: LD_INT 3
16556: PUSH
16557: LD_INT 3
16559: PUSH
16560: LD_INT 5
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: LIST
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: LIST
16572: LIST
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: LIST
16578: PUSH
16579: LD_OWVAR 67
16583: ARRAY
16584: PUSH
16585: LD_INT 1
16587: PUSH
16588: LD_INT 2
16590: PUSH
16591: LD_INT 4
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: LD_INT 0
16601: PUSH
16602: LD_INT 4
16604: PUSH
16605: LD_INT 4
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: LIST
16612: PUSH
16613: LD_INT 2
16615: PUSH
16616: LD_INT 1
16618: PUSH
16619: LD_INT 4
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: LIST
16626: PUSH
16627: LD_INT 1
16629: PUSH
16630: LD_INT 3
16632: PUSH
16633: LD_INT 4
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: LIST
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 1
16649: PUSH
16650: LD_INT 2
16652: PUSH
16653: LD_INT 5
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PUSH
16661: LD_INT 0
16663: PUSH
16664: LD_INT 4
16666: PUSH
16667: LD_INT 5
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: LIST
16674: PUSH
16675: LD_INT 2
16677: PUSH
16678: LD_INT 1
16680: PUSH
16681: LD_INT 5
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PUSH
16689: LD_INT 1
16691: PUSH
16692: LD_INT 3
16694: PUSH
16695: LD_INT 5
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 1
16711: PUSH
16712: LD_INT 2
16714: PUSH
16715: LD_INT 5
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 0
16725: PUSH
16726: LD_INT 4
16728: PUSH
16729: LD_INT 5
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: LIST
16736: PUSH
16737: LD_INT 2
16739: PUSH
16740: LD_INT 1
16742: PUSH
16743: LD_INT 5
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: LIST
16750: PUSH
16751: LD_INT 1
16753: PUSH
16754: LD_INT 3
16756: PUSH
16757: LD_INT 5
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: LIST
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: LIST
16775: PUSH
16776: LD_OWVAR 67
16780: ARRAY
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: LD_INT 2
16787: PUSH
16788: LD_INT 4
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: LIST
16795: PUSH
16796: LD_INT 4
16798: PUSH
16799: LD_INT 4
16801: PUSH
16802: LD_INT 4
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: LIST
16809: PUSH
16810: LD_INT 3
16812: PUSH
16813: LD_INT 1
16815: PUSH
16816: LD_INT 4
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: PUSH
16824: LD_INT 3
16826: PUSH
16827: LD_INT 3
16829: PUSH
16830: LD_INT 4
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: PUSH
16844: LD_INT 1
16846: PUSH
16847: LD_INT 2
16849: PUSH
16850: LD_INT 5
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 4
16860: PUSH
16861: LD_INT 4
16863: PUSH
16864: LD_INT 5
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: PUSH
16872: LD_INT 3
16874: PUSH
16875: LD_INT 1
16877: PUSH
16878: LD_INT 5
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: PUSH
16886: LD_INT 3
16888: PUSH
16889: LD_INT 3
16891: PUSH
16892: LD_INT 5
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: LIST
16904: LIST
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 6
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: PUSH
16920: LD_INT 4
16922: PUSH
16923: LD_INT 4
16925: PUSH
16926: LD_INT 6
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: LIST
16933: PUSH
16934: LD_INT 3
16936: PUSH
16937: LD_INT 1
16939: PUSH
16940: LD_INT 6
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: LIST
16947: PUSH
16948: LD_INT 3
16950: PUSH
16951: LD_INT 3
16953: PUSH
16954: LD_INT 6
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: LIST
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: PUSH
16973: LD_OWVAR 67
16977: ARRAY
16978: PUSH
16979: LD_INT 1
16981: PUSH
16982: LD_INT 2
16984: PUSH
16985: LD_INT 4
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: LD_INT 4
16998: PUSH
16999: LD_INT 4
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: LIST
17006: PUSH
17007: LD_INT 3
17009: PUSH
17010: LD_INT 1
17012: PUSH
17013: LD_INT 4
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 3
17023: PUSH
17024: LD_INT 3
17026: PUSH
17027: LD_INT 4
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: LIST
17039: LIST
17040: PUSH
17041: LD_INT 1
17043: PUSH
17044: LD_INT 2
17046: PUSH
17047: LD_INT 5
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 1
17057: PUSH
17058: LD_INT 4
17060: PUSH
17061: LD_INT 5
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: LIST
17068: PUSH
17069: LD_INT 3
17071: PUSH
17072: LD_INT 1
17074: PUSH
17075: LD_INT 5
17077: PUSH
17078: EMPTY
17079: LIST
17080: LIST
17081: LIST
17082: PUSH
17083: LD_INT 3
17085: PUSH
17086: LD_INT 3
17088: PUSH
17089: LD_INT 5
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: LIST
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: LIST
17101: LIST
17102: PUSH
17103: LD_INT 1
17105: PUSH
17106: LD_INT 2
17108: PUSH
17109: LD_INT 6
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PUSH
17120: LD_INT 4
17122: PUSH
17123: LD_INT 6
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 3
17133: PUSH
17134: LD_INT 1
17136: PUSH
17137: LD_INT 6
17139: PUSH
17140: EMPTY
17141: LIST
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 3
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 6
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: LIST
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PUSH
17170: LD_OWVAR 67
17174: ARRAY
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: LIST
17182: ST_TO_ADDR
// builds := [ [ [ b_warehouse , 24 , 9 , 3 , [ ] ] , [ b_barracks , 39 , 26 , 5 , [ ] ] , [ b_siberite_power , 9 , 11 , 2 , [ ] ] , [ b_turret , 45 , 20 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 44 , 25 , 2 , [ ru_heavy_gun ] ] , [ b_turret , 26 , 40 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 37 , 39 , 2 , [ ru_heavy_gun ] ] , [ b_bunker , 42 , 21 , 2 , [ ru_gatling_gun ] ] , [ b_bunker , 38 , 36 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 53 , 15 , 2 , [ ru_rocket_launcher ] ] , [ b_lab_full , 10 , 7 , 2 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_full , 34 , 10 , 3 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_factory , 20 , 21 , 2 , [ ] ] , [ b_ext_gun , 24 , 21 , 4 , [ ] ] , [ b_ext_rocket , 20 , 18 , 3 , [ ] ] , [ b_ext_siberium , 20 , 25 , 0 , [ ] ] , [ b_ext_computer , 17 , 21 , 1 , [ ] ] , [ b_ext_track , 16 , 17 , 2 , [ ] ] , [ b_siberite_mine , 20 , 34 , 0 , [ ] ] , [ b_siberite_power , 15 , 5 , 2 , [ ] ] , [ b_oil_mine , 14 , 23 , 2 , [ ] ] , [ b_teleport , 32 , 20 , 3 , [ ] ] ] , [ [ b_factory , 98 , 26 , 5 , [ ] ] , [ b_barracks , 80 , 13 , 0 , [ ] ] , [ b_siberite_power , 97 , 3 , 1 , [ ] ] , [ b_turret , 105 , 35 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 111 , 22 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 115 , 27 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 65 , 3 , 3 , [ ru_rocket_launcher ] , 20 20$0 ] , [ b_turret , 68 , 3 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 71 , 4 , 3 , [ ru_heavy_gun ] ] , [ b_siberite_power , 101 , 4 , 5 , [ ] ] , [ b_turret , 108 , 35 , 2 , [ ru_heavy_gun ] ] , [ b_ext_track , 101 , 26 , 4 , [ ] ] , [ b_ext_gun , 98 , 22 , 3 , [ ] ] , [ b_ext_siberium , 94 , 26 , 1 , [ ] ] , [ b_ext_rocket , 98 , 29 , 0 , [ ] ] , [ b_ext_noncombat , 102 , 30 , 5 , [ ] ] , [ b_warehouse , 86 , 6 , 3 , [ ] ] , [ b_siberite_mine , 102 , 9 , 4 , [ ] ] , [ b_oil_mine , 77 , 3 , 4 , [ ] ] , [ b_lab_full , 100 , 17 , 4 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_half , 94 , 6 , 3 , [ b_lab_computer , b_lab_basic ] ] ] , [ [ b_warehouse , 90 , 141 , 0 , [ ] ] , [ b_barracks , 98 , 133 , 4 , [ ] ] , [ b_siberite_power , 72 , 133 , 2 , [ ] ] , [ b_bunker , 95 , 128 , 0 , [ ru_rocket_launcher ] ] , [ b_bunker , 80 , 122 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 95 , 128 , 0 , [ ru_rocket_launcher ] , 15 15$0 ] , [ b_turret , 80 , 122 , 2 , [ ru_rocket_launcher ] , 17 17$0 ] , [ b_turret , 112 , 154 , 1 , [ ru_rocket_launcher ] , 16 16$0 ] , [ b_turret , 78 , 124 , 2 , [ ru_heavy_gun ] , 20 20$0 ] , [ b_turret , 99 , 130 , 1 , [ ru_heavy_gun ] , 22 22$0 ] , [ b_turret , 112 , 151 , 1 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_factory , 81 , 135 , 5 , [ ] ] , [ b_ext_siberium , 84 , 135 , 4 , [ ] ] , [ b_ext_gun , 85 , 139 , 5 , [ ] ] , [ b_ext_track , 77 , 135 , 1 , [ ] ] , [ b_ext_rocket , 81 , 138 , 0 , [ ] , 14 14$0 ] , [ b_siberite_mine , 71 , 137 , 0 , [ ] ] , [ b_oil_mine , 69 , 133 , 5 , [ ] ] , [ b_lab_half , 102 , 153 , 0 , [ b_lab_computer , b_lab_basic ] , 35 35$0 ] , [ b_lab_full , 97 , 145 , 2 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 74 , 137 , 2 , [ ] ] , [ b_ext_computer , 81 , 131 , 3 , [ ] ] ] , [ [ b_warehouse , 217 , 129 , 3 , [ ] ] , [ b_siberite_power , 233 , 154 , 4 , [ ] ] , [ b_turret , 205 , 123 , 0 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_turret , 200 , 142 , 4 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 135 , 4 , [ ru_heavy_gun ] , 28 28$0 ] , [ b_turret , 201 , 127 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 138 , 4 , [ ru_rocket_launcher ] ] , [ b_turret , 202 , 124 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 209 , 154 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 218 , 123 , 5 , [ ru_rocket_launcher ] ] , [ b_lab_full , 227 , 145 , 2 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_lab_full , 221 , 153 , 4 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 231 , 155 , 4 , [ ] ] , [ b_oil_mine , 224 , 134 , 4 , [ ] ] , [ b_siberite_mine , 224 , 150 , 2 , [ ] ] , [ b_factory , 207 , 141 , 1 , [ ] ] , [ b_ext_computer , 211 , 145 , 5 , [ ] ] , [ b_ext_siberium , 207 , 144 , 0 , [ ] ] , [ b_ext_rocket , 203 , 141 , 1 , [ ] ] , [ b_ext_track , 204 , 138 , 2 , [ ] ] , [ b_ext_gun , 207 , 137 , 3 , [ ] ] , [ b_armoury , 210 , 128 , 2 , [ ] , 35 35$0 ] , [ b_armoury , 210 , 128 , 2 , [ ] ] ] , [ [ b_warehouse , 184 , 73 , 3 , [ ] ] , [ b_barracks , 188 , 94 , 5 , [ ] ] , [ b_turret , 171 , 92 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 177 , 98 , 3 , [ ru_heavy_gun ] ] , [ b_turret , 169 , 69 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 170 , 66 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 184 , 62 , 5 , [ ru_gatling_gun ] ] , [ b_turret , 203 , 102 , 2 , [ ru_rocket_launcher ] , 30 30$0 ] , [ b_turret , 195 , 103 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 200 , 103 , 2 , [ ru_heavy_gun ] ] , [ b_siberite_power , 198 , 90 , 3 , [ ] ] , [ b_siberite_mine , 179 , 70 , 1 , [ ] ] , [ b_factory , 190 , 84 , 4 , [ ] ] , [ b_ext_gun , 190 , 88 , 0 , [ ] ] , [ b_ext_rocket , 193 , 87 , 5 , [ ] ] , [ b_ext_siberium , 194 , 84 , 4 , [ ] ] , [ b_ext_computer , 190 , 81 , 3 , [ ] ] , [ b_lab_full , 176 , 92 , 0 , [ b_lab_siberium , b_lab_basic ] ] , [ b_lab_full , 176 , 82 , 3 , [ b_lab_computer , b_lab_weapon ] ] , [ b_siberite_power , 196 , 92 , 5 , [ ] ] , [ b_siberite_power , 198 , 86 , 1 , [ ] ] , [ b_siberite_mine , 192 , 93 , 0 , [ ] ] ] ] ;
17183: LD_ADDR_LOC 23
17187: PUSH
17188: LD_INT 1
17190: PUSH
17191: LD_INT 24
17193: PUSH
17194: LD_INT 9
17196: PUSH
17197: LD_INT 3
17199: PUSH
17200: EMPTY
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: PUSH
17209: LD_INT 5
17211: PUSH
17212: LD_INT 39
17214: PUSH
17215: LD_INT 26
17217: PUSH
17218: LD_INT 5
17220: PUSH
17221: EMPTY
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: LIST
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 28
17232: PUSH
17233: LD_INT 9
17235: PUSH
17236: LD_INT 11
17238: PUSH
17239: LD_INT 2
17241: PUSH
17242: EMPTY
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: LIST
17248: LIST
17249: LIST
17250: PUSH
17251: LD_INT 33
17253: PUSH
17254: LD_INT 45
17256: PUSH
17257: LD_INT 20
17259: PUSH
17260: LD_INT 2
17262: PUSH
17263: LD_INT 45
17265: PUSH
17266: EMPTY
17267: LIST
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: LIST
17273: LIST
17274: LIST
17275: PUSH
17276: LD_INT 33
17278: PUSH
17279: LD_INT 44
17281: PUSH
17282: LD_INT 25
17284: PUSH
17285: LD_INT 2
17287: PUSH
17288: LD_INT 46
17290: PUSH
17291: EMPTY
17292: LIST
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: LIST
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 33
17303: PUSH
17304: LD_INT 26
17306: PUSH
17307: LD_INT 40
17309: PUSH
17310: LD_INT 3
17312: PUSH
17313: LD_INT 45
17315: PUSH
17316: EMPTY
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 33
17328: PUSH
17329: LD_INT 37
17331: PUSH
17332: LD_INT 39
17334: PUSH
17335: LD_INT 2
17337: PUSH
17338: LD_INT 46
17340: PUSH
17341: EMPTY
17342: LIST
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: LIST
17350: PUSH
17351: LD_INT 32
17353: PUSH
17354: LD_INT 42
17356: PUSH
17357: LD_INT 21
17359: PUSH
17360: LD_INT 2
17362: PUSH
17363: LD_INT 43
17365: PUSH
17366: EMPTY
17367: LIST
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: LIST
17373: LIST
17374: LIST
17375: PUSH
17376: LD_INT 32
17378: PUSH
17379: LD_INT 38
17381: PUSH
17382: LD_INT 36
17384: PUSH
17385: LD_INT 2
17387: PUSH
17388: LD_INT 43
17390: PUSH
17391: EMPTY
17392: LIST
17393: PUSH
17394: EMPTY
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: PUSH
17401: LD_INT 33
17403: PUSH
17404: LD_INT 53
17406: PUSH
17407: LD_INT 15
17409: PUSH
17410: LD_INT 2
17412: PUSH
17413: LD_INT 45
17415: PUSH
17416: EMPTY
17417: LIST
17418: PUSH
17419: EMPTY
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: PUSH
17426: LD_INT 8
17428: PUSH
17429: LD_INT 10
17431: PUSH
17432: LD_INT 7
17434: PUSH
17435: LD_INT 2
17437: PUSH
17438: LD_INT 11
17440: PUSH
17441: LD_INT 10
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: LIST
17454: PUSH
17455: LD_INT 8
17457: PUSH
17458: LD_INT 34
17460: PUSH
17461: LD_INT 10
17463: PUSH
17464: LD_INT 3
17466: PUSH
17467: LD_INT 12
17469: PUSH
17470: LD_INT 14
17472: PUSH
17473: EMPTY
17474: LIST
17475: LIST
17476: PUSH
17477: EMPTY
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: LIST
17483: PUSH
17484: LD_INT 3
17486: PUSH
17487: LD_INT 20
17489: PUSH
17490: LD_INT 21
17492: PUSH
17493: LD_INT 2
17495: PUSH
17496: EMPTY
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: PUSH
17505: LD_INT 17
17507: PUSH
17508: LD_INT 24
17510: PUSH
17511: LD_INT 21
17513: PUSH
17514: LD_INT 4
17516: PUSH
17517: EMPTY
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: PUSH
17526: LD_INT 18
17528: PUSH
17529: LD_INT 20
17531: PUSH
17532: LD_INT 18
17534: PUSH
17535: LD_INT 3
17537: PUSH
17538: EMPTY
17539: PUSH
17540: EMPTY
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: PUSH
17547: LD_INT 21
17549: PUSH
17550: LD_INT 20
17552: PUSH
17553: LD_INT 25
17555: PUSH
17556: LD_INT 0
17558: PUSH
17559: EMPTY
17560: PUSH
17561: EMPTY
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: PUSH
17568: LD_INT 24
17570: PUSH
17571: LD_INT 17
17573: PUSH
17574: LD_INT 21
17576: PUSH
17577: LD_INT 1
17579: PUSH
17580: EMPTY
17581: PUSH
17582: EMPTY
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: PUSH
17589: LD_INT 16
17591: PUSH
17592: LD_INT 16
17594: PUSH
17595: LD_INT 17
17597: PUSH
17598: LD_INT 2
17600: PUSH
17601: EMPTY
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: LIST
17609: PUSH
17610: LD_INT 30
17612: PUSH
17613: LD_INT 20
17615: PUSH
17616: LD_INT 34
17618: PUSH
17619: LD_INT 0
17621: PUSH
17622: EMPTY
17623: PUSH
17624: EMPTY
17625: LIST
17626: LIST
17627: LIST
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 28
17633: PUSH
17634: LD_INT 15
17636: PUSH
17637: LD_INT 5
17639: PUSH
17640: LD_INT 2
17642: PUSH
17643: EMPTY
17644: PUSH
17645: EMPTY
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: PUSH
17652: LD_INT 29
17654: PUSH
17655: LD_INT 14
17657: PUSH
17658: LD_INT 23
17660: PUSH
17661: LD_INT 2
17663: PUSH
17664: EMPTY
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: LIST
17670: LIST
17671: LIST
17672: PUSH
17673: LD_INT 34
17675: PUSH
17676: LD_INT 32
17678: PUSH
17679: LD_INT 20
17681: PUSH
17682: LD_INT 3
17684: PUSH
17685: EMPTY
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: LIST
17691: LIST
17692: LIST
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: LIST
17699: LIST
17700: LIST
17701: LIST
17702: LIST
17703: LIST
17704: LIST
17705: LIST
17706: LIST
17707: LIST
17708: LIST
17709: LIST
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: LIST
17715: LIST
17716: LIST
17717: PUSH
17718: LD_INT 3
17720: PUSH
17721: LD_INT 98
17723: PUSH
17724: LD_INT 26
17726: PUSH
17727: LD_INT 5
17729: PUSH
17730: EMPTY
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: PUSH
17739: LD_INT 5
17741: PUSH
17742: LD_INT 80
17744: PUSH
17745: LD_INT 13
17747: PUSH
17748: LD_INT 0
17750: PUSH
17751: EMPTY
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: LIST
17759: PUSH
17760: LD_INT 28
17762: PUSH
17763: LD_INT 97
17765: PUSH
17766: LD_INT 3
17768: PUSH
17769: LD_INT 1
17771: PUSH
17772: EMPTY
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: PUSH
17781: LD_INT 33
17783: PUSH
17784: LD_INT 105
17786: PUSH
17787: LD_INT 35
17789: PUSH
17790: LD_INT 3
17792: PUSH
17793: LD_INT 45
17795: PUSH
17796: EMPTY
17797: LIST
17798: PUSH
17799: EMPTY
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: PUSH
17806: LD_INT 33
17808: PUSH
17809: LD_INT 111
17811: PUSH
17812: LD_INT 22
17814: PUSH
17815: LD_INT 2
17817: PUSH
17818: LD_INT 43
17820: PUSH
17821: EMPTY
17822: LIST
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: PUSH
17831: LD_INT 33
17833: PUSH
17834: LD_INT 115
17836: PUSH
17837: LD_INT 27
17839: PUSH
17840: LD_INT 2
17842: PUSH
17843: LD_INT 45
17845: PUSH
17846: EMPTY
17847: LIST
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: LIST
17855: PUSH
17856: LD_INT 33
17858: PUSH
17859: LD_INT 65
17861: PUSH
17862: LD_INT 3
17864: PUSH
17865: LD_INT 3
17867: PUSH
17868: LD_INT 45
17870: PUSH
17871: EMPTY
17872: LIST
17873: PUSH
17874: LD_INT 42000
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: LIST
17884: PUSH
17885: LD_INT 33
17887: PUSH
17888: LD_INT 68
17890: PUSH
17891: LD_INT 3
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: LD_INT 45
17899: PUSH
17900: EMPTY
17901: LIST
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: LIST
17909: PUSH
17910: LD_INT 33
17912: PUSH
17913: LD_INT 71
17915: PUSH
17916: LD_INT 4
17918: PUSH
17919: LD_INT 3
17921: PUSH
17922: LD_INT 46
17924: PUSH
17925: EMPTY
17926: LIST
17927: PUSH
17928: EMPTY
17929: LIST
17930: LIST
17931: LIST
17932: LIST
17933: LIST
17934: PUSH
17935: LD_INT 28
17937: PUSH
17938: LD_INT 101
17940: PUSH
17941: LD_INT 4
17943: PUSH
17944: LD_INT 5
17946: PUSH
17947: EMPTY
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: LIST
17953: LIST
17954: LIST
17955: PUSH
17956: LD_INT 33
17958: PUSH
17959: LD_INT 108
17961: PUSH
17962: LD_INT 35
17964: PUSH
17965: LD_INT 2
17967: PUSH
17968: LD_INT 46
17970: PUSH
17971: EMPTY
17972: LIST
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 16
17983: PUSH
17984: LD_INT 101
17986: PUSH
17987: LD_INT 26
17989: PUSH
17990: LD_INT 4
17992: PUSH
17993: EMPTY
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: PUSH
18002: LD_INT 17
18004: PUSH
18005: LD_INT 98
18007: PUSH
18008: LD_INT 22
18010: PUSH
18011: LD_INT 3
18013: PUSH
18014: EMPTY
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 21
18025: PUSH
18026: LD_INT 94
18028: PUSH
18029: LD_INT 26
18031: PUSH
18032: LD_INT 1
18034: PUSH
18035: EMPTY
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: PUSH
18044: LD_INT 18
18046: PUSH
18047: LD_INT 98
18049: PUSH
18050: LD_INT 29
18052: PUSH
18053: LD_INT 0
18055: PUSH
18056: EMPTY
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: PUSH
18065: LD_INT 19
18067: PUSH
18068: LD_INT 102
18070: PUSH
18071: LD_INT 30
18073: PUSH
18074: LD_INT 5
18076: PUSH
18077: EMPTY
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: LIST
18083: LIST
18084: LIST
18085: PUSH
18086: LD_INT 1
18088: PUSH
18089: LD_INT 86
18091: PUSH
18092: LD_INT 6
18094: PUSH
18095: LD_INT 3
18097: PUSH
18098: EMPTY
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: PUSH
18107: LD_INT 30
18109: PUSH
18110: LD_INT 102
18112: PUSH
18113: LD_INT 9
18115: PUSH
18116: LD_INT 4
18118: PUSH
18119: EMPTY
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: PUSH
18128: LD_INT 29
18130: PUSH
18131: LD_INT 77
18133: PUSH
18134: LD_INT 3
18136: PUSH
18137: LD_INT 4
18139: PUSH
18140: EMPTY
18141: PUSH
18142: EMPTY
18143: LIST
18144: LIST
18145: LIST
18146: LIST
18147: LIST
18148: PUSH
18149: LD_INT 8
18151: PUSH
18152: LD_INT 100
18154: PUSH
18155: LD_INT 17
18157: PUSH
18158: LD_INT 4
18160: PUSH
18161: LD_INT 11
18163: PUSH
18164: LD_INT 10
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: LIST
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 7
18180: PUSH
18181: LD_INT 94
18183: PUSH
18184: LD_INT 6
18186: PUSH
18187: LD_INT 3
18189: PUSH
18190: LD_INT 12
18192: PUSH
18193: LD_INT 9
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: PUSH
18230: LD_INT 1
18232: PUSH
18233: LD_INT 90
18235: PUSH
18236: LD_INT 141
18238: PUSH
18239: LD_INT 0
18241: PUSH
18242: EMPTY
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: PUSH
18251: LD_INT 5
18253: PUSH
18254: LD_INT 98
18256: PUSH
18257: LD_INT 133
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: PUSH
18272: LD_INT 28
18274: PUSH
18275: LD_INT 72
18277: PUSH
18278: LD_INT 133
18280: PUSH
18281: LD_INT 2
18283: PUSH
18284: EMPTY
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: PUSH
18293: LD_INT 32
18295: PUSH
18296: LD_INT 95
18298: PUSH
18299: LD_INT 128
18301: PUSH
18302: LD_INT 0
18304: PUSH
18305: LD_INT 45
18307: PUSH
18308: EMPTY
18309: LIST
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: PUSH
18318: LD_INT 32
18320: PUSH
18321: LD_INT 80
18323: PUSH
18324: LD_INT 122
18326: PUSH
18327: LD_INT 2
18329: PUSH
18330: LD_INT 45
18332: PUSH
18333: EMPTY
18334: LIST
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: PUSH
18343: LD_INT 33
18345: PUSH
18346: LD_INT 95
18348: PUSH
18349: LD_INT 128
18351: PUSH
18352: LD_INT 0
18354: PUSH
18355: LD_INT 45
18357: PUSH
18358: EMPTY
18359: LIST
18360: PUSH
18361: LD_INT 31500
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: LIST
18371: PUSH
18372: LD_INT 33
18374: PUSH
18375: LD_INT 80
18377: PUSH
18378: LD_INT 122
18380: PUSH
18381: LD_INT 2
18383: PUSH
18384: LD_INT 45
18386: PUSH
18387: EMPTY
18388: LIST
18389: PUSH
18390: LD_INT 35700
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: PUSH
18401: LD_INT 33
18403: PUSH
18404: LD_INT 112
18406: PUSH
18407: LD_INT 154
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: LD_INT 45
18415: PUSH
18416: EMPTY
18417: LIST
18418: PUSH
18419: LD_INT 33600
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: LIST
18426: LIST
18427: LIST
18428: LIST
18429: PUSH
18430: LD_INT 33
18432: PUSH
18433: LD_INT 78
18435: PUSH
18436: LD_INT 124
18438: PUSH
18439: LD_INT 2
18441: PUSH
18442: LD_INT 46
18444: PUSH
18445: EMPTY
18446: LIST
18447: PUSH
18448: LD_INT 42000
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: PUSH
18459: LD_INT 33
18461: PUSH
18462: LD_INT 99
18464: PUSH
18465: LD_INT 130
18467: PUSH
18468: LD_INT 1
18470: PUSH
18471: LD_INT 46
18473: PUSH
18474: EMPTY
18475: LIST
18476: PUSH
18477: LD_INT 46200
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: LIST
18486: LIST
18487: PUSH
18488: LD_INT 33
18490: PUSH
18491: LD_INT 112
18493: PUSH
18494: LD_INT 151
18496: PUSH
18497: LD_INT 1
18499: PUSH
18500: LD_INT 43
18502: PUSH
18503: EMPTY
18504: LIST
18505: PUSH
18506: LD_INT 52500
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: PUSH
18517: LD_INT 3
18519: PUSH
18520: LD_INT 81
18522: PUSH
18523: LD_INT 135
18525: PUSH
18526: LD_INT 5
18528: PUSH
18529: EMPTY
18530: PUSH
18531: EMPTY
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: LIST
18537: PUSH
18538: LD_INT 21
18540: PUSH
18541: LD_INT 84
18543: PUSH
18544: LD_INT 135
18546: PUSH
18547: LD_INT 4
18549: PUSH
18550: EMPTY
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: PUSH
18559: LD_INT 17
18561: PUSH
18562: LD_INT 85
18564: PUSH
18565: LD_INT 139
18567: PUSH
18568: LD_INT 5
18570: PUSH
18571: EMPTY
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: LIST
18579: PUSH
18580: LD_INT 16
18582: PUSH
18583: LD_INT 77
18585: PUSH
18586: LD_INT 135
18588: PUSH
18589: LD_INT 1
18591: PUSH
18592: EMPTY
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: LIST
18600: PUSH
18601: LD_INT 18
18603: PUSH
18604: LD_INT 81
18606: PUSH
18607: LD_INT 138
18609: PUSH
18610: LD_INT 0
18612: PUSH
18613: EMPTY
18614: PUSH
18615: LD_INT 29400
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: LIST
18625: PUSH
18626: LD_INT 30
18628: PUSH
18629: LD_INT 71
18631: PUSH
18632: LD_INT 137
18634: PUSH
18635: LD_INT 0
18637: PUSH
18638: EMPTY
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: LIST
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 29
18649: PUSH
18650: LD_INT 69
18652: PUSH
18653: LD_INT 133
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 7
18670: PUSH
18671: LD_INT 102
18673: PUSH
18674: LD_INT 153
18676: PUSH
18677: LD_INT 0
18679: PUSH
18680: LD_INT 12
18682: PUSH
18683: LD_INT 9
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PUSH
18690: LD_INT 73500
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: PUSH
18701: LD_INT 8
18703: PUSH
18704: LD_INT 97
18706: PUSH
18707: LD_INT 145
18709: PUSH
18710: LD_INT 2
18712: PUSH
18713: LD_INT 10
18715: PUSH
18716: LD_INT 11
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: PUSH
18730: LD_INT 28
18732: PUSH
18733: LD_INT 74
18735: PUSH
18736: LD_INT 137
18738: PUSH
18739: LD_INT 2
18741: PUSH
18742: EMPTY
18743: PUSH
18744: EMPTY
18745: LIST
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: PUSH
18751: LD_INT 24
18753: PUSH
18754: LD_INT 81
18756: PUSH
18757: LD_INT 131
18759: PUSH
18760: LD_INT 3
18762: PUSH
18763: EMPTY
18764: PUSH
18765: EMPTY
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: PUSH
18772: EMPTY
18773: LIST
18774: LIST
18775: LIST
18776: LIST
18777: LIST
18778: LIST
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: PUSH
18796: LD_INT 1
18798: PUSH
18799: LD_INT 217
18801: PUSH
18802: LD_INT 129
18804: PUSH
18805: LD_INT 3
18807: PUSH
18808: EMPTY
18809: PUSH
18810: EMPTY
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 28
18819: PUSH
18820: LD_INT 233
18822: PUSH
18823: LD_INT 154
18825: PUSH
18826: LD_INT 4
18828: PUSH
18829: EMPTY
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 33
18840: PUSH
18841: LD_INT 205
18843: PUSH
18844: LD_INT 123
18846: PUSH
18847: LD_INT 0
18849: PUSH
18850: LD_INT 43
18852: PUSH
18853: EMPTY
18854: LIST
18855: PUSH
18856: LD_INT 52500
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: LIST
18865: LIST
18866: PUSH
18867: LD_INT 33
18869: PUSH
18870: LD_INT 200
18872: PUSH
18873: LD_INT 142
18875: PUSH
18876: LD_INT 4
18878: PUSH
18879: LD_INT 46
18881: PUSH
18882: EMPTY
18883: LIST
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: PUSH
18892: LD_INT 33
18894: PUSH
18895: LD_INT 199
18897: PUSH
18898: LD_INT 135
18900: PUSH
18901: LD_INT 4
18903: PUSH
18904: LD_INT 46
18906: PUSH
18907: EMPTY
18908: LIST
18909: PUSH
18910: LD_INT 58800
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 33
18923: PUSH
18924: LD_INT 201
18926: PUSH
18927: LD_INT 127
18929: PUSH
18930: LD_INT 5
18932: PUSH
18933: LD_INT 46
18935: PUSH
18936: EMPTY
18937: LIST
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 33
18948: PUSH
18949: LD_INT 199
18951: PUSH
18952: LD_INT 138
18954: PUSH
18955: LD_INT 4
18957: PUSH
18958: LD_INT 45
18960: PUSH
18961: EMPTY
18962: LIST
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: LIST
18970: PUSH
18971: LD_INT 33
18973: PUSH
18974: LD_INT 202
18976: PUSH
18977: LD_INT 124
18979: PUSH
18980: LD_INT 5
18982: PUSH
18983: LD_INT 45
18985: PUSH
18986: EMPTY
18987: LIST
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: LIST
18993: LIST
18994: LIST
18995: PUSH
18996: LD_INT 33
18998: PUSH
18999: LD_INT 209
19001: PUSH
19002: LD_INT 154
19004: PUSH
19005: LD_INT 3
19007: PUSH
19008: LD_INT 45
19010: PUSH
19011: EMPTY
19012: LIST
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: LIST
19018: LIST
19019: LIST
19020: PUSH
19021: LD_INT 33
19023: PUSH
19024: LD_INT 218
19026: PUSH
19027: LD_INT 123
19029: PUSH
19030: LD_INT 5
19032: PUSH
19033: LD_INT 45
19035: PUSH
19036: EMPTY
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: LIST
19045: PUSH
19046: LD_INT 8
19048: PUSH
19049: LD_INT 227
19051: PUSH
19052: LD_INT 145
19054: PUSH
19055: LD_INT 2
19057: PUSH
19058: LD_INT 12
19060: PUSH
19061: LD_INT 14
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: EMPTY
19069: LIST
19070: LIST
19071: LIST
19072: LIST
19073: LIST
19074: PUSH
19075: LD_INT 8
19077: PUSH
19078: LD_INT 221
19080: PUSH
19081: LD_INT 153
19083: PUSH
19084: LD_INT 4
19086: PUSH
19087: LD_INT 10
19089: PUSH
19090: LD_INT 11
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: PUSH
19104: LD_INT 28
19106: PUSH
19107: LD_INT 231
19109: PUSH
19110: LD_INT 155
19112: PUSH
19113: LD_INT 4
19115: PUSH
19116: EMPTY
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: LIST
19124: PUSH
19125: LD_INT 29
19127: PUSH
19128: LD_INT 224
19130: PUSH
19131: LD_INT 134
19133: PUSH
19134: LD_INT 4
19136: PUSH
19137: EMPTY
19138: PUSH
19139: EMPTY
19140: LIST
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: PUSH
19146: LD_INT 30
19148: PUSH
19149: LD_INT 224
19151: PUSH
19152: LD_INT 150
19154: PUSH
19155: LD_INT 2
19157: PUSH
19158: EMPTY
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: LIST
19164: LIST
19165: LIST
19166: PUSH
19167: LD_INT 3
19169: PUSH
19170: LD_INT 207
19172: PUSH
19173: LD_INT 141
19175: PUSH
19176: LD_INT 1
19178: PUSH
19179: EMPTY
19180: PUSH
19181: EMPTY
19182: LIST
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: PUSH
19188: LD_INT 24
19190: PUSH
19191: LD_INT 211
19193: PUSH
19194: LD_INT 145
19196: PUSH
19197: LD_INT 5
19199: PUSH
19200: EMPTY
19201: PUSH
19202: EMPTY
19203: LIST
19204: LIST
19205: LIST
19206: LIST
19207: LIST
19208: PUSH
19209: LD_INT 21
19211: PUSH
19212: LD_INT 207
19214: PUSH
19215: LD_INT 144
19217: PUSH
19218: LD_INT 0
19220: PUSH
19221: EMPTY
19222: PUSH
19223: EMPTY
19224: LIST
19225: LIST
19226: LIST
19227: LIST
19228: LIST
19229: PUSH
19230: LD_INT 18
19232: PUSH
19233: LD_INT 203
19235: PUSH
19236: LD_INT 141
19238: PUSH
19239: LD_INT 1
19241: PUSH
19242: EMPTY
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: LIST
19250: PUSH
19251: LD_INT 16
19253: PUSH
19254: LD_INT 204
19256: PUSH
19257: LD_INT 138
19259: PUSH
19260: LD_INT 2
19262: PUSH
19263: EMPTY
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: LIST
19271: PUSH
19272: LD_INT 17
19274: PUSH
19275: LD_INT 207
19277: PUSH
19278: LD_INT 137
19280: PUSH
19281: LD_INT 3
19283: PUSH
19284: EMPTY
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: LIST
19290: LIST
19291: LIST
19292: PUSH
19293: LD_INT 4
19295: PUSH
19296: LD_INT 210
19298: PUSH
19299: LD_INT 128
19301: PUSH
19302: LD_INT 2
19304: PUSH
19305: EMPTY
19306: PUSH
19307: LD_INT 73500
19309: PUSH
19310: EMPTY
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: PUSH
19318: LD_INT 4
19320: PUSH
19321: LD_INT 210
19323: PUSH
19324: LD_INT 128
19326: PUSH
19327: LD_INT 2
19329: PUSH
19330: EMPTY
19331: PUSH
19332: EMPTY
19333: LIST
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: LIST
19343: LIST
19344: LIST
19345: LIST
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: LIST
19352: LIST
19353: LIST
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: PUSH
19364: LD_INT 1
19366: PUSH
19367: LD_INT 184
19369: PUSH
19370: LD_INT 73
19372: PUSH
19373: LD_INT 3
19375: PUSH
19376: EMPTY
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: PUSH
19385: LD_INT 5
19387: PUSH
19388: LD_INT 188
19390: PUSH
19391: LD_INT 94
19393: PUSH
19394: LD_INT 5
19396: PUSH
19397: EMPTY
19398: PUSH
19399: EMPTY
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: PUSH
19406: LD_INT 33
19408: PUSH
19409: LD_INT 171
19411: PUSH
19412: LD_INT 92
19414: PUSH
19415: LD_INT 3
19417: PUSH
19418: LD_INT 45
19420: PUSH
19421: EMPTY
19422: LIST
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: PUSH
19431: LD_INT 33
19433: PUSH
19434: LD_INT 177
19436: PUSH
19437: LD_INT 98
19439: PUSH
19440: LD_INT 3
19442: PUSH
19443: LD_INT 46
19445: PUSH
19446: EMPTY
19447: LIST
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: PUSH
19456: LD_INT 33
19458: PUSH
19459: LD_INT 169
19461: PUSH
19462: LD_INT 69
19464: PUSH
19465: LD_INT 5
19467: PUSH
19468: LD_INT 46
19470: PUSH
19471: EMPTY
19472: LIST
19473: PUSH
19474: EMPTY
19475: LIST
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: PUSH
19481: LD_INT 33
19483: PUSH
19484: LD_INT 170
19486: PUSH
19487: LD_INT 66
19489: PUSH
19490: LD_INT 5
19492: PUSH
19493: LD_INT 45
19495: PUSH
19496: EMPTY
19497: LIST
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: PUSH
19506: LD_INT 33
19508: PUSH
19509: LD_INT 184
19511: PUSH
19512: LD_INT 62
19514: PUSH
19515: LD_INT 5
19517: PUSH
19518: LD_INT 43
19520: PUSH
19521: EMPTY
19522: LIST
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: PUSH
19531: LD_INT 33
19533: PUSH
19534: LD_INT 203
19536: PUSH
19537: LD_INT 102
19539: PUSH
19540: LD_INT 2
19542: PUSH
19543: LD_INT 45
19545: PUSH
19546: EMPTY
19547: LIST
19548: PUSH
19549: LD_INT 63000
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: PUSH
19560: LD_INT 33
19562: PUSH
19563: LD_INT 195
19565: PUSH
19566: LD_INT 103
19568: PUSH
19569: LD_INT 2
19571: PUSH
19572: LD_INT 45
19574: PUSH
19575: EMPTY
19576: LIST
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: LIST
19584: PUSH
19585: LD_INT 33
19587: PUSH
19588: LD_INT 200
19590: PUSH
19591: LD_INT 103
19593: PUSH
19594: LD_INT 2
19596: PUSH
19597: LD_INT 46
19599: PUSH
19600: EMPTY
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: LIST
19609: PUSH
19610: LD_INT 28
19612: PUSH
19613: LD_INT 198
19615: PUSH
19616: LD_INT 90
19618: PUSH
19619: LD_INT 3
19621: PUSH
19622: EMPTY
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 30
19633: PUSH
19634: LD_INT 179
19636: PUSH
19637: LD_INT 70
19639: PUSH
19640: LD_INT 1
19642: PUSH
19643: EMPTY
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: PUSH
19652: LD_INT 3
19654: PUSH
19655: LD_INT 190
19657: PUSH
19658: LD_INT 84
19660: PUSH
19661: LD_INT 4
19663: PUSH
19664: EMPTY
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: PUSH
19673: LD_INT 17
19675: PUSH
19676: LD_INT 190
19678: PUSH
19679: LD_INT 88
19681: PUSH
19682: LD_INT 0
19684: PUSH
19685: EMPTY
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: LIST
19691: LIST
19692: LIST
19693: PUSH
19694: LD_INT 18
19696: PUSH
19697: LD_INT 193
19699: PUSH
19700: LD_INT 87
19702: PUSH
19703: LD_INT 5
19705: PUSH
19706: EMPTY
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: PUSH
19715: LD_INT 21
19717: PUSH
19718: LD_INT 194
19720: PUSH
19721: LD_INT 84
19723: PUSH
19724: LD_INT 4
19726: PUSH
19727: EMPTY
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: PUSH
19736: LD_INT 24
19738: PUSH
19739: LD_INT 190
19741: PUSH
19742: LD_INT 81
19744: PUSH
19745: LD_INT 3
19747: PUSH
19748: EMPTY
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: PUSH
19757: LD_INT 8
19759: PUSH
19760: LD_INT 176
19762: PUSH
19763: LD_INT 92
19765: PUSH
19766: LD_INT 0
19768: PUSH
19769: LD_INT 11
19771: PUSH
19772: LD_INT 9
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: PUSH
19786: LD_INT 8
19788: PUSH
19789: LD_INT 176
19791: PUSH
19792: LD_INT 82
19794: PUSH
19795: LD_INT 3
19797: PUSH
19798: LD_INT 12
19800: PUSH
19801: LD_INT 10
19803: PUSH
19804: EMPTY
19805: LIST
19806: LIST
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: PUSH
19815: LD_INT 28
19817: PUSH
19818: LD_INT 196
19820: PUSH
19821: LD_INT 92
19823: PUSH
19824: LD_INT 5
19826: PUSH
19827: EMPTY
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 28
19838: PUSH
19839: LD_INT 198
19841: PUSH
19842: LD_INT 86
19844: PUSH
19845: LD_INT 1
19847: PUSH
19848: EMPTY
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: PUSH
19857: LD_INT 30
19859: PUSH
19860: LD_INT 192
19862: PUSH
19863: LD_INT 93
19865: PUSH
19866: LD_INT 0
19868: PUSH
19869: EMPTY
19870: PUSH
19871: EMPTY
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: LIST
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: ST_TO_ADDR
// in_depots := [ [ 820 , 720 , 421 ] , [ 770 , 620 , 320 ] , [ 680 , 900 , 310 ] , [ 730 , 920 , 240 ] , [ 510 , 810 , 300 ] ] ;
19909: LD_ADDR_LOC 25
19913: PUSH
19914: LD_INT 820
19916: PUSH
19917: LD_INT 720
19919: PUSH
19920: LD_INT 421
19922: PUSH
19923: EMPTY
19924: LIST
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 770
19930: PUSH
19931: LD_INT 620
19933: PUSH
19934: LD_INT 320
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: LIST
19941: PUSH
19942: LD_INT 680
19944: PUSH
19945: LD_INT 900
19947: PUSH
19948: LD_INT 310
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: PUSH
19956: LD_INT 730
19958: PUSH
19959: LD_INT 920
19961: PUSH
19962: LD_INT 240
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: LIST
19969: PUSH
19970: LD_INT 510
19972: PUSH
19973: LD_INT 810
19975: PUSH
19976: LD_INT 300
19978: PUSH
19979: EMPTY
19980: LIST
19981: LIST
19982: LIST
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: ST_TO_ADDR
// end ;
19991: LD_VAR 0 1
19995: RET
// function UpgradeableTo ( b , up ) ; var i ; begin
19996: LD_INT 0
19998: PPUSH
19999: PPUSH
// result := 0 ;
20000: LD_ADDR_VAR 0 3
20004: PUSH
20005: LD_INT 0
20007: ST_TO_ADDR
// for i := 1 to upgradeable do
20008: LD_ADDR_VAR 0 4
20012: PUSH
20013: DOUBLE
20014: LD_INT 1
20016: DEC
20017: ST_TO_ADDR
20018: LD_LOC 27
20022: PUSH
20023: FOR_TO
20024: IFFALSE 20076
// if b = upgradeable [ i ] and up = trough_upgrade [ i ] then
20026: LD_VAR 0 1
20030: PUSH
20031: LD_LOC 27
20035: PUSH
20036: LD_VAR 0 4
20040: ARRAY
20041: EQUAL
20042: PUSH
20043: LD_VAR 0 2
20047: PUSH
20048: LD_LOC 28
20052: PUSH
20053: LD_VAR 0 4
20057: ARRAY
20058: EQUAL
20059: AND
20060: IFFALSE 20074
// begin result := up ;
20062: LD_ADDR_VAR 0 3
20066: PUSH
20067: LD_VAR 0 2
20071: ST_TO_ADDR
// break ;
20072: GO 20076
// end ;
20074: GO 20023
20076: POP
20077: POP
// end ;
20078: LD_VAR 0 3
20082: RET
// function IsUpgraded ( b ) ; begin
20083: LD_INT 0
20085: PPUSH
// result := 0 ;
20086: LD_ADDR_VAR 0 2
20090: PUSH
20091: LD_INT 0
20093: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20094: LD_VAR 0 1
20098: PUSH
20099: LD_LOC 28
20103: PUSH
20104: LD_INT 1
20106: ARRAY
20107: DOUBLE
20108: EQUAL
20109: IFTRUE 20113
20111: GO 20130
20113: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20114: LD_ADDR_VAR 0 2
20118: PUSH
20119: LD_LOC 27
20123: PUSH
20124: LD_INT 1
20126: ARRAY
20127: ST_TO_ADDR
20128: GO 20255
20130: LD_LOC 28
20134: PUSH
20135: LD_INT 2
20137: ARRAY
20138: DOUBLE
20139: EQUAL
20140: IFTRUE 20144
20142: GO 20161
20144: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20145: LD_ADDR_VAR 0 2
20149: PUSH
20150: LD_LOC 27
20154: PUSH
20155: LD_INT 2
20157: ARRAY
20158: ST_TO_ADDR
20159: GO 20255
20161: LD_LOC 28
20165: PUSH
20166: LD_INT 3
20168: ARRAY
20169: DOUBLE
20170: EQUAL
20171: IFTRUE 20175
20173: GO 20192
20175: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20176: LD_ADDR_VAR 0 2
20180: PUSH
20181: LD_LOC 27
20185: PUSH
20186: LD_INT 3
20188: ARRAY
20189: ST_TO_ADDR
20190: GO 20255
20192: LD_LOC 28
20196: PUSH
20197: LD_INT 4
20199: ARRAY
20200: DOUBLE
20201: EQUAL
20202: IFTRUE 20206
20204: GO 20223
20206: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 5 ] :
20207: LD_ADDR_VAR 0 2
20211: PUSH
20212: LD_LOC 27
20216: PUSH
20217: LD_INT 4
20219: ARRAY
20220: ST_TO_ADDR
20221: GO 20255
20223: LD_LOC 28
20227: PUSH
20228: LD_INT 5
20230: ARRAY
20231: DOUBLE
20232: EQUAL
20233: IFTRUE 20237
20235: GO 20254
20237: POP
// result := upgradeable [ 5 ] ; end ;
20238: LD_ADDR_VAR 0 2
20242: PUSH
20243: LD_LOC 27
20247: PUSH
20248: LD_INT 5
20250: ARRAY
20251: ST_TO_ADDR
20252: GO 20255
20254: POP
// end ;
20255: LD_VAR 0 2
20259: RET
// function BasicFrom ( b ) ; begin
20260: LD_INT 0
20262: PPUSH
// result := b ;
20263: LD_ADDR_VAR 0 2
20267: PUSH
20268: LD_VAR 0 1
20272: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20273: LD_VAR 0 1
20277: PUSH
20278: LD_LOC 28
20282: PUSH
20283: LD_INT 1
20285: ARRAY
20286: DOUBLE
20287: EQUAL
20288: IFTRUE 20292
20290: GO 20309
20292: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20293: LD_ADDR_VAR 0 2
20297: PUSH
20298: LD_LOC 27
20302: PUSH
20303: LD_INT 1
20305: ARRAY
20306: ST_TO_ADDR
20307: GO 20434
20309: LD_LOC 28
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: DOUBLE
20318: EQUAL
20319: IFTRUE 20323
20321: GO 20340
20323: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20324: LD_ADDR_VAR 0 2
20328: PUSH
20329: LD_LOC 27
20333: PUSH
20334: LD_INT 2
20336: ARRAY
20337: ST_TO_ADDR
20338: GO 20434
20340: LD_LOC 28
20344: PUSH
20345: LD_INT 3
20347: ARRAY
20348: DOUBLE
20349: EQUAL
20350: IFTRUE 20354
20352: GO 20371
20354: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20355: LD_ADDR_VAR 0 2
20359: PUSH
20360: LD_LOC 27
20364: PUSH
20365: LD_INT 3
20367: ARRAY
20368: ST_TO_ADDR
20369: GO 20434
20371: LD_LOC 28
20375: PUSH
20376: LD_INT 4
20378: ARRAY
20379: DOUBLE
20380: EQUAL
20381: IFTRUE 20385
20383: GO 20402
20385: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 6 ] :
20386: LD_ADDR_VAR 0 2
20390: PUSH
20391: LD_LOC 27
20395: PUSH
20396: LD_INT 4
20398: ARRAY
20399: ST_TO_ADDR
20400: GO 20434
20402: LD_LOC 28
20406: PUSH
20407: LD_INT 6
20409: ARRAY
20410: DOUBLE
20411: EQUAL
20412: IFTRUE 20416
20414: GO 20433
20416: POP
// result := upgradeable [ 6 ] ; end ;
20417: LD_ADDR_VAR 0 2
20421: PUSH
20422: LD_LOC 27
20426: PUSH
20427: LD_INT 6
20429: ARRAY
20430: ST_TO_ADDR
20431: GO 20434
20433: POP
// end ;
20434: LD_VAR 0 2
20438: RET
// export function build_map ; var i , j ; begin
20439: LD_INT 0
20441: PPUSH
20442: PPUSH
20443: PPUSH
// for i := 1 to 5 do
20444: LD_ADDR_VAR 0 2
20448: PUSH
20449: DOUBLE
20450: LD_INT 1
20452: DEC
20453: ST_TO_ADDR
20454: LD_INT 5
20456: PUSH
20457: FOR_TO
20458: IFFALSE 20525
// buildings := replace ( buildings , i , place_base ( builds [ i ] , in_depots [ i ] , ai_s [ i ] , ai_nation ) ) ;
20460: LD_ADDR_EXP 75
20464: PUSH
20465: LD_EXP 75
20469: PPUSH
20470: LD_VAR 0 2
20474: PPUSH
20475: LD_LOC 23
20479: PUSH
20480: LD_VAR 0 2
20484: ARRAY
20485: PPUSH
20486: LD_LOC 25
20490: PUSH
20491: LD_VAR 0 2
20495: ARRAY
20496: PPUSH
20497: LD_EXP 23
20501: PUSH
20502: LD_VAR 0 2
20506: ARRAY
20507: PPUSH
20508: LD_EXP 22
20512: PPUSH
20513: CALL 20765 0 4
20517: PPUSH
20518: CALL_OW 1
20522: ST_TO_ADDR
20523: GO 20457
20525: POP
20526: POP
// hlavouni := [ Platonov , Gossudarov , Borodin , Tsaritsyn , Davidov , Eisenstein ] ;
20527: LD_ADDR_EXP 72
20531: PUSH
20532: LD_EXP 42
20536: PUSH
20537: LD_EXP 43
20541: PUSH
20542: LD_EXP 46
20546: PUSH
20547: LD_EXP 47
20551: PUSH
20552: LD_EXP 48
20556: PUSH
20557: LD_EXP 49
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , da ) ;
20570: LD_EXP 42
20574: PPUSH
20575: LD_INT 1
20577: PPUSH
20578: CALL_OW 52
// PlaceHumanInUnit ( Gossudarov , art_cargo ) ;
20582: LD_EXP 43
20586: PPUSH
20587: LD_INT 121
20589: PPUSH
20590: CALL_OW 52
// PlaceHumanInUnit ( Borodin , db ) ;
20594: LD_EXP 46
20598: PPUSH
20599: LD_INT 51
20601: PPUSH
20602: CALL_OW 52
// PlaceHumanInUnit ( Tsaritsyn , dc ) ;
20606: LD_EXP 47
20610: PPUSH
20611: LD_INT 80
20613: PPUSH
20614: CALL_OW 52
// PlaceHumanInUnit ( Davidov , dd ) ;
20618: LD_EXP 48
20622: PPUSH
20623: LD_INT 28
20625: PPUSH
20626: CALL_OW 52
// PlaceHumanInUnit ( Eisenstein , de ) ;
20630: LD_EXP 49
20634: PPUSH
20635: LD_INT 37
20637: PPUSH
20638: CALL_OW 52
// for i := 1 to 5 do
20642: LD_ADDR_VAR 0 2
20646: PUSH
20647: DOUBLE
20648: LD_INT 1
20650: DEC
20651: ST_TO_ADDR
20652: LD_INT 5
20654: PUSH
20655: FOR_TO
20656: IFFALSE 20758
// begin humans := replace ( humans , i , place_aici ( aici [ i ] , abase [ i ] , ai_s [ i ] , ai_nation ) ) ;
20658: LD_ADDR_EXP 76
20662: PUSH
20663: LD_EXP 76
20667: PPUSH
20668: LD_VAR 0 2
20672: PPUSH
20673: LD_LOC 24
20677: PUSH
20678: LD_VAR 0 2
20682: ARRAY
20683: PPUSH
20684: LD_LOC 26
20688: PUSH
20689: LD_VAR 0 2
20693: ARRAY
20694: PPUSH
20695: LD_EXP 23
20699: PUSH
20700: LD_VAR 0 2
20704: ARRAY
20705: PPUSH
20706: LD_EXP 22
20710: PPUSH
20711: CALL 21217 0 4
20715: PPUSH
20716: CALL_OW 1
20720: ST_TO_ADDR
// for j in humans [ i ] do
20721: LD_ADDR_VAR 0 3
20725: PUSH
20726: LD_EXP 76
20730: PUSH
20731: LD_VAR 0 2
20735: ARRAY
20736: PUSH
20737: FOR_IN
20738: IFFALSE 20754
// SetTag ( j , 1 ) ;
20740: LD_VAR 0 3
20744: PPUSH
20745: LD_INT 1
20747: PPUSH
20748: CALL_OW 109
20752: GO 20737
20754: POP
20755: POP
// end ;
20756: GO 20655
20758: POP
20759: POP
// end ;
20760: LD_VAR 0 1
20764: RET
// function place_base ( builds , in_depot , side , nat ) ; var i , base , b , tb , bb , cans , oil , sib ; begin
20765: LD_INT 0
20767: PPUSH
20768: PPUSH
20769: PPUSH
20770: PPUSH
20771: PPUSH
20772: PPUSH
20773: PPUSH
20774: PPUSH
20775: PPUSH
// cans := in_depot [ 1 ] ;
20776: LD_ADDR_VAR 0 11
20780: PUSH
20781: LD_VAR 0 2
20785: PUSH
20786: LD_INT 1
20788: ARRAY
20789: ST_TO_ADDR
// oil := in_depot [ 2 ] ;
20790: LD_ADDR_VAR 0 12
20794: PUSH
20795: LD_VAR 0 2
20799: PUSH
20800: LD_INT 2
20802: ARRAY
20803: ST_TO_ADDR
// sib := in_depot [ 3 ] ;
20804: LD_ADDR_VAR 0 13
20808: PUSH
20809: LD_VAR 0 2
20813: PUSH
20814: LD_INT 3
20816: ARRAY
20817: ST_TO_ADDR
// InitUc ;
20818: CALL_OW 18
// InitBc ;
20822: CALL_OW 21
// uc_side := side ;
20826: LD_ADDR_OWVAR 20
20830: PUSH
20831: LD_VAR 0 3
20835: ST_TO_ADDR
// uc_nation := nat ;
20836: LD_ADDR_OWVAR 21
20840: PUSH
20841: LD_VAR 0 4
20845: ST_TO_ADDR
// b := [ ] ;
20846: LD_ADDR_VAR 0 8
20850: PUSH
20851: EMPTY
20852: ST_TO_ADDR
// for i in builds do
20853: LD_ADDR_VAR 0 6
20857: PUSH
20858: LD_VAR 0 1
20862: PUSH
20863: FOR_IN
20864: IFFALSE 21094
// begin if i = 5 then
20866: LD_VAR 0 6
20870: PUSH
20871: LD_INT 5
20873: EQUAL
20874: IFFALSE 21092
// begin tb := get_build ( i [ 2 ] , i [ 3 ] , 0 ) ;
20876: LD_ADDR_VAR 0 9
20880: PUSH
20881: LD_VAR 0 6
20885: PUSH
20886: LD_INT 2
20888: ARRAY
20889: PPUSH
20890: LD_VAR 0 6
20894: PUSH
20895: LD_INT 3
20897: ARRAY
20898: PPUSH
20899: LD_INT 0
20901: PPUSH
20902: CALL 22062 0 3
20906: ST_TO_ADDR
// if not tb then
20907: LD_VAR 0 9
20911: NOT
20912: IFFALSE 21073
// begin bc_type := i [ 1 ] ;
20914: LD_ADDR_OWVAR 42
20918: PUSH
20919: LD_VAR 0 6
20923: PUSH
20924: LD_INT 1
20926: ARRAY
20927: ST_TO_ADDR
// if bc_type = b_lab or bc_type = b_lab_half or bc_type = b_lab_full then
20928: LD_OWVAR 42
20932: PUSH
20933: LD_INT 6
20935: EQUAL
20936: PUSH
20937: LD_OWVAR 42
20941: PUSH
20942: LD_INT 7
20944: EQUAL
20945: OR
20946: PUSH
20947: LD_OWVAR 42
20951: PUSH
20952: LD_INT 8
20954: EQUAL
20955: OR
20956: IFFALSE 20994
// begin bc_kind1 := i [ 5 ] [ 1 ] ;
20958: LD_ADDR_OWVAR 44
20962: PUSH
20963: LD_VAR 0 6
20967: PUSH
20968: LD_INT 5
20970: ARRAY
20971: PUSH
20972: LD_INT 1
20974: ARRAY
20975: ST_TO_ADDR
// bc_kind2 := i [ 5 ] [ 2 ] ;
20976: LD_ADDR_OWVAR 45
20980: PUSH
20981: LD_VAR 0 6
20985: PUSH
20986: LD_INT 5
20988: ARRAY
20989: PUSH
20990: LD_INT 2
20992: ARRAY
20993: ST_TO_ADDR
// end ; tb := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
20994: LD_ADDR_VAR 0 9
20998: PUSH
20999: LD_VAR 0 6
21003: PUSH
21004: LD_INT 2
21006: ARRAY
21007: PPUSH
21008: LD_VAR 0 6
21012: PUSH
21013: LD_INT 3
21015: ARRAY
21016: PPUSH
21017: LD_VAR 0 6
21021: PUSH
21022: LD_INT 4
21024: ARRAY
21025: PPUSH
21026: CALL_OW 47
21030: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
21031: LD_OWVAR 42
21035: PUSH
21036: LD_INT 32
21038: EQUAL
21039: PUSH
21040: LD_OWVAR 42
21044: PUSH
21045: LD_INT 33
21047: EQUAL
21048: OR
21049: IFFALSE 21073
// PlaceWeaponTurret ( tb , i [ 5 ] [ 1 ] ) ;
21051: LD_VAR 0 9
21055: PPUSH
21056: LD_VAR 0 6
21060: PUSH
21061: LD_INT 5
21063: ARRAY
21064: PUSH
21065: LD_INT 1
21067: ARRAY
21068: PPUSH
21069: CALL_OW 431
// end ; b := b ^ [ tb ] ;
21073: LD_ADDR_VAR 0 8
21077: PUSH
21078: LD_VAR 0 8
21082: PUSH
21083: LD_VAR 0 9
21087: PUSH
21088: EMPTY
21089: LIST
21090: ADD
21091: ST_TO_ADDR
// end ; end ;
21092: GO 20863
21094: POP
21095: POP
// bb := UnitFilter ( b , [ mf_dep ] ) ;
21096: LD_ADDR_VAR 0 10
21100: PUSH
21101: LD_VAR 0 8
21105: PPUSH
21106: LD_EXP 58
21110: PUSH
21111: EMPTY
21112: LIST
21113: PPUSH
21114: CALL_OW 72
21118: ST_TO_ADDR
// for i in bb do
21119: LD_ADDR_VAR 0 6
21123: PUSH
21124: LD_VAR 0 10
21128: PUSH
21129: FOR_IN
21130: IFFALSE 21200
// begin base := GetBase ( i ) ;
21132: LD_ADDR_VAR 0 7
21136: PUSH
21137: LD_VAR 0 6
21141: PPUSH
21142: CALL_OW 274
21146: ST_TO_ADDR
// SetResourceType ( base , mat_cans , cans ) ;
21147: LD_VAR 0 7
21151: PPUSH
21152: LD_INT 1
21154: PPUSH
21155: LD_VAR 0 11
21159: PPUSH
21160: CALL_OW 277
// SetResourceType ( base , mat_oil , oil ) ;
21164: LD_VAR 0 7
21168: PPUSH
21169: LD_INT 2
21171: PPUSH
21172: LD_VAR 0 12
21176: PPUSH
21177: CALL_OW 277
// SetResourceType ( base , mat_siberit , sib ) ;
21181: LD_VAR 0 7
21185: PPUSH
21186: LD_INT 3
21188: PPUSH
21189: LD_VAR 0 13
21193: PPUSH
21194: CALL_OW 277
// end ;
21198: GO 21129
21200: POP
21201: POP
// result := b ;
21202: LD_ADDR_VAR 0 5
21206: PUSH
21207: LD_VAR 0 8
21211: ST_TO_ADDR
// end ;
21212: LD_VAR 0 5
21216: RET
// function place_aici ( aici , area , side , nat ) ; var i , j , a ; begin
21217: LD_INT 0
21219: PPUSH
21220: PPUSH
21221: PPUSH
21222: PPUSH
// InitUc ;
21223: CALL_OW 18
// InitHc ;
21227: CALL_OW 19
// uc_side := side ;
21231: LD_ADDR_OWVAR 20
21235: PUSH
21236: LD_VAR 0 3
21240: ST_TO_ADDR
// uc_nation := nat ;
21241: LD_ADDR_OWVAR 21
21245: PUSH
21246: LD_VAR 0 4
21250: ST_TO_ADDR
// a := [ ] ;
21251: LD_ADDR_VAR 0 8
21255: PUSH
21256: EMPTY
21257: ST_TO_ADDR
// for i in aici do
21258: LD_ADDR_VAR 0 6
21262: PUSH
21263: LD_VAR 0 1
21267: PUSH
21268: FOR_IN
21269: IFFALSE 21343
// begin for j := 1 to i [ 1 ] do
21271: LD_ADDR_VAR 0 7
21275: PUSH
21276: DOUBLE
21277: LD_INT 1
21279: DEC
21280: ST_TO_ADDR
21281: LD_VAR 0 6
21285: PUSH
21286: LD_INT 1
21288: ARRAY
21289: PUSH
21290: FOR_TO
21291: IFFALSE 21339
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
21293: LD_INT 0
21295: PPUSH
21296: LD_VAR 0 6
21300: PUSH
21301: LD_INT 2
21303: ARRAY
21304: PPUSH
21305: LD_VAR 0 6
21309: PUSH
21310: LD_INT 3
21312: ARRAY
21313: PPUSH
21314: CALL_OW 380
// a := a ^ [ CreateHuman ] ;
21318: LD_ADDR_VAR 0 8
21322: PUSH
21323: LD_VAR 0 8
21327: PUSH
21328: CALL_OW 44
21332: PUSH
21333: EMPTY
21334: LIST
21335: ADD
21336: ST_TO_ADDR
// end ;
21337: GO 21290
21339: POP
21340: POP
// end ;
21341: GO 21268
21343: POP
21344: POP
// for i in a do
21345: LD_ADDR_VAR 0 6
21349: PUSH
21350: LD_VAR 0 8
21354: PUSH
21355: FOR_IN
21356: IFFALSE 21377
// PlaceUnitArea ( i , area , false ) ;
21358: LD_VAR 0 6
21362: PPUSH
21363: LD_VAR 0 2
21367: PPUSH
21368: LD_INT 0
21370: PPUSH
21371: CALL_OW 49
21375: GO 21355
21377: POP
21378: POP
// result := a ;
21379: LD_ADDR_VAR 0 5
21383: PUSH
21384: LD_VAR 0 8
21388: ST_TO_ADDR
// end ;
21389: LD_VAR 0 5
21393: RET
// every 0 0$10 + 0 0$0.0 do var i , j , weap , k ;
21394: GO 21396
21396: DISABLE
21397: LD_INT 0
21399: PPUSH
21400: PPUSH
21401: PPUSH
21402: PPUSH
// begin for i in UnitFilter ( fort , [ mf_bunk ] ) do
21403: LD_ADDR_VAR 0 1
21407: PUSH
21408: LD_EXP 81
21412: PPUSH
21413: LD_EXP 57
21417: PUSH
21418: EMPTY
21419: LIST
21420: PPUSH
21421: CALL_OW 72
21425: PUSH
21426: FOR_IN
21427: IFFALSE 21597
// if not GetBWeapon ( i ) then
21429: LD_VAR 0 1
21433: PPUSH
21434: CALL_OW 269
21438: NOT
21439: IFFALSE 21595
// begin weap := 0 ;
21441: LD_ADDR_VAR 0 3
21445: PUSH
21446: LD_INT 0
21448: ST_TO_ADDR
// for k := 1 to 5 do
21449: LD_ADDR_VAR 0 4
21453: PUSH
21454: DOUBLE
21455: LD_INT 1
21457: DEC
21458: ST_TO_ADDR
21459: LD_INT 5
21461: PUSH
21462: FOR_TO
21463: IFFALSE 21573
// for j in builds [ k ] do
21465: LD_ADDR_VAR 0 2
21469: PUSH
21470: LD_LOC 23
21474: PUSH
21475: LD_VAR 0 4
21479: ARRAY
21480: PUSH
21481: FOR_IN
21482: IFFALSE 21569
// if GetX ( i ) = j [ 2 ] and GetY ( i ) = j [ 3 ] and GetBType ( i ) = j [ 1 ] then
21484: LD_VAR 0 1
21488: PPUSH
21489: CALL_OW 250
21493: PUSH
21494: LD_VAR 0 2
21498: PUSH
21499: LD_INT 2
21501: ARRAY
21502: EQUAL
21503: PUSH
21504: LD_VAR 0 1
21508: PPUSH
21509: CALL_OW 251
21513: PUSH
21514: LD_VAR 0 2
21518: PUSH
21519: LD_INT 3
21521: ARRAY
21522: EQUAL
21523: AND
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 266
21534: PUSH
21535: LD_VAR 0 2
21539: PUSH
21540: LD_INT 1
21542: ARRAY
21543: EQUAL
21544: AND
21545: IFFALSE 21567
// begin weap := j [ 5 ] [ 1 ] ;
21547: LD_ADDR_VAR 0 3
21551: PUSH
21552: LD_VAR 0 2
21556: PUSH
21557: LD_INT 5
21559: ARRAY
21560: PUSH
21561: LD_INT 1
21563: ARRAY
21564: ST_TO_ADDR
// break ;
21565: GO 21569
// end ;
21567: GO 21481
21569: POP
21570: POP
21571: GO 21462
21573: POP
21574: POP
// if weap then
21575: LD_VAR 0 3
21579: IFFALSE 21595
// ComPlaceWeapon ( j , weap ) ;
21581: LD_VAR 0 2
21585: PPUSH
21586: LD_VAR 0 3
21590: PPUSH
21591: CALL_OW 148
// end ;
21595: GO 21426
21597: POP
21598: POP
// enable ;
21599: ENABLE
// end ;
21600: PPOPN 4
21602: END
// every 0 0$10 + 0 0$2.0 do var i , to_up , to_b , co_tam_stoji , k , je_cas_stavet ;
21603: GO 21605
21605: DISABLE
21606: LD_INT 0
21608: PPUSH
21609: PPUSH
21610: PPUSH
21611: PPUSH
21612: PPUSH
21613: PPUSH
// begin for k := 1 to 5 do
21614: LD_ADDR_VAR 0 5
21618: PUSH
21619: DOUBLE
21620: LD_INT 1
21622: DEC
21623: ST_TO_ADDR
21624: LD_INT 5
21626: PUSH
21627: FOR_TO
21628: IFFALSE 22056
// begin if not under_attack [ k ] then
21630: LD_EXP 62
21634: PUSH
21635: LD_VAR 0 5
21639: ARRAY
21640: NOT
21641: IFFALSE 22054
// begin to_b := [ ] ;
21643: LD_ADDR_VAR 0 3
21647: PUSH
21648: EMPTY
21649: ST_TO_ADDR
// to_up := [ ] ;
21650: LD_ADDR_VAR 0 2
21654: PUSH
21655: EMPTY
21656: ST_TO_ADDR
// je_cas_stavet := false ;
21657: LD_ADDR_VAR 0 6
21661: PUSH
21662: LD_INT 0
21664: ST_TO_ADDR
// for i in builds [ k ] do
21665: LD_ADDR_VAR 0 1
21669: PUSH
21670: LD_LOC 23
21674: PUSH
21675: LD_VAR 0 5
21679: ARRAY
21680: PUSH
21681: FOR_IN
21682: IFFALSE 21883
// begin je_cas_stavet := true ;
21684: LD_ADDR_VAR 0 6
21688: PUSH
21689: LD_INT 1
21691: ST_TO_ADDR
// if i = 6 then
21692: LD_VAR 0 1
21696: PUSH
21697: LD_INT 6
21699: EQUAL
21700: IFFALSE 21726
// if i [ 6 ] < tick then
21702: LD_VAR 0 1
21706: PUSH
21707: LD_INT 6
21709: ARRAY
21710: PUSH
21711: LD_OWVAR 1
21715: LESS
21716: IFFALSE 21726
// je_cas_stavet := false ;
21718: LD_ADDR_VAR 0 6
21722: PUSH
21723: LD_INT 0
21725: ST_TO_ADDR
// if je_cas_stavet then
21726: LD_VAR 0 6
21730: IFFALSE 21881
// begin co_tam_stoji := GetBType ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
21732: LD_ADDR_VAR 0 4
21736: PUSH
21737: LD_VAR 0 1
21741: PUSH
21742: LD_INT 2
21744: ARRAY
21745: PPUSH
21746: LD_VAR 0 1
21750: PUSH
21751: LD_INT 3
21753: ARRAY
21754: PPUSH
21755: LD_INT 0
21757: PPUSH
21758: CALL 22062 0 3
21762: PPUSH
21763: CALL_OW 266
21767: ST_TO_ADDR
// if co_tam_stoji = - 1 then
21768: LD_VAR 0 4
21772: PUSH
21773: LD_INT 1
21775: NEG
21776: EQUAL
21777: IFFALSE 21843
// begin to_b := [ BasicFrom ( i [ 1 ] ) , i [ 2 ] , i [ 3 ] , i [ 4 ] , i [ 5 ] ] ;
21779: LD_ADDR_VAR 0 3
21783: PUSH
21784: LD_VAR 0 1
21788: PUSH
21789: LD_INT 1
21791: ARRAY
21792: PPUSH
21793: CALL 20260 0 1
21797: PUSH
21798: LD_VAR 0 1
21802: PUSH
21803: LD_INT 2
21805: ARRAY
21806: PUSH
21807: LD_VAR 0 1
21811: PUSH
21812: LD_INT 3
21814: ARRAY
21815: PUSH
21816: LD_VAR 0 1
21820: PUSH
21821: LD_INT 4
21823: ARRAY
21824: PUSH
21825: LD_VAR 0 1
21829: PUSH
21830: LD_INT 5
21832: ARRAY
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: ST_TO_ADDR
// end else
21841: GO 21873
// if UpgradeableTo ( co_tam_stoji , i [ 1 ] ) then
21843: LD_VAR 0 4
21847: PPUSH
21848: LD_VAR 0 1
21852: PUSH
21853: LD_INT 1
21855: ARRAY
21856: PPUSH
21857: CALL 19996 0 2
21861: IFFALSE 21873
// begin to_up := i ;
21863: LD_ADDR_VAR 0 2
21867: PUSH
21868: LD_VAR 0 1
21872: ST_TO_ADDR
// end ; if to_b then
21873: LD_VAR 0 3
21877: IFFALSE 21881
// break ;
21879: GO 21883
// end ; end ;
21881: GO 21681
21883: POP
21884: POP
// if to_b then
21885: LD_VAR 0 3
21889: IFFALSE 22011
// ComBuild ( NearestUnitToXY ( UnitFilter ( eng isect humans [ k ] , [ [ f_distxy , to_b [ 2 ] , to_b [ 3 ] , 40 ] ] ) , to_b [ 2 ] , to_b [ 3 ] ) , to_b [ 1 ] , to_b [ 2 ] , to_b [ 3 ] , to_b [ 4 ] ) else
21891: LD_EXP 84
21895: PUSH
21896: LD_EXP 76
21900: PUSH
21901: LD_VAR 0 5
21905: ARRAY
21906: ISECT
21907: PPUSH
21908: LD_INT 92
21910: PUSH
21911: LD_VAR 0 3
21915: PUSH
21916: LD_INT 2
21918: ARRAY
21919: PUSH
21920: LD_VAR 0 3
21924: PUSH
21925: LD_INT 3
21927: ARRAY
21928: PUSH
21929: LD_INT 40
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: PUSH
21938: EMPTY
21939: LIST
21940: PPUSH
21941: CALL_OW 72
21945: PPUSH
21946: LD_VAR 0 3
21950: PUSH
21951: LD_INT 2
21953: ARRAY
21954: PPUSH
21955: LD_VAR 0 3
21959: PUSH
21960: LD_INT 3
21962: ARRAY
21963: PPUSH
21964: CALL_OW 73
21968: PPUSH
21969: LD_VAR 0 3
21973: PUSH
21974: LD_INT 1
21976: ARRAY
21977: PPUSH
21978: LD_VAR 0 3
21982: PUSH
21983: LD_INT 2
21985: ARRAY
21986: PPUSH
21987: LD_VAR 0 3
21991: PUSH
21992: LD_INT 3
21994: ARRAY
21995: PPUSH
21996: LD_VAR 0 3
22000: PUSH
22001: LD_INT 4
22003: ARRAY
22004: PPUSH
22005: CALL_OW 145
22009: GO 22047
// if to_up then
22011: LD_VAR 0 2
22015: IFFALSE 22047
// ComUpgrade ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
22017: LD_VAR 0 1
22021: PUSH
22022: LD_INT 2
22024: ARRAY
22025: PPUSH
22026: LD_VAR 0 1
22030: PUSH
22031: LD_INT 3
22033: ARRAY
22034: PPUSH
22035: LD_INT 0
22037: PPUSH
22038: CALL 22062 0 3
22042: PPUSH
22043: CALL_OW 146
// wait ( 0 0$1.1 ) ;
22047: LD_INT 39
22049: PPUSH
22050: CALL_OW 67
// end ; end ;
22054: GO 21627
22056: POP
22057: POP
// enable ;
22058: ENABLE
// end ;
22059: PPOPN 6
22061: END
// function get_build ( x , y , btype ) ; begin
22062: LD_INT 0
22064: PPUSH
// result := HexInfo ( x , y ) ;
22065: LD_ADDR_VAR 0 4
22069: PUSH
22070: LD_VAR 0 1
22074: PPUSH
22075: LD_VAR 0 2
22079: PPUSH
22080: CALL_OW 428
22084: ST_TO_ADDR
// if result < 1 then
22085: LD_VAR 0 4
22089: PUSH
22090: LD_INT 1
22092: LESS
22093: IFFALSE 22103
// result := 0 ;
22095: LD_ADDR_VAR 0 4
22099: PUSH
22100: LD_INT 0
22102: ST_TO_ADDR
// if btype then
22103: LD_VAR 0 3
22107: IFFALSE 22159
// if btype <> GetBType ( result ) then
22109: LD_VAR 0 3
22113: PUSH
22114: LD_VAR 0 4
22118: PPUSH
22119: CALL_OW 266
22123: NONEQUAL
22124: IFFALSE 22136
// result := 0 else
22126: LD_ADDR_VAR 0 4
22130: PUSH
22131: LD_INT 0
22133: ST_TO_ADDR
22134: GO 22159
// if unit_building <> GetType ( result ) then
22136: LD_INT 3
22138: PUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: CALL_OW 247
22148: NONEQUAL
22149: IFFALSE 22159
// result := 0 ;
22151: LD_ADDR_VAR 0 4
22155: PUSH
22156: LD_INT 0
22158: ST_TO_ADDR
// end ; end_of_file
22159: LD_VAR 0 4
22163: RET
// var opravit ; export function inicializace_ai_b_repair ; begin
22164: LD_INT 0
22166: PPUSH
// opravit := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22167: LD_ADDR_LOC 29
22171: PUSH
22172: EMPTY
22173: PUSH
22174: EMPTY
22175: PUSH
22176: EMPTY
22177: PUSH
22178: EMPTY
22179: PUSH
22180: EMPTY
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: LIST
22186: LIST
22187: LIST
22188: ST_TO_ADDR
// end ;
22189: LD_VAR 0 1
22193: RET
// function HledejBudovyNaOpravy ( opravit_index , budovy ) ; var zivoty , i , opravit_tmp ; begin
22194: LD_INT 0
22196: PPUSH
22197: PPUSH
22198: PPUSH
22199: PPUSH
// opravit_tmp := [ ] ;
22200: LD_ADDR_VAR 0 6
22204: PUSH
22205: EMPTY
22206: ST_TO_ADDR
// zivoty := [ ] ;
22207: LD_ADDR_VAR 0 4
22211: PUSH
22212: EMPTY
22213: ST_TO_ADDR
// for i in budovy do
22214: LD_ADDR_VAR 0 5
22218: PUSH
22219: LD_VAR 0 2
22223: PUSH
22224: FOR_IN
22225: IFFALSE 22287
// begin if GetLives ( i ) < 1000 then
22227: LD_VAR 0 5
22231: PPUSH
22232: CALL_OW 256
22236: PUSH
22237: LD_INT 1000
22239: LESS
22240: IFFALSE 22285
// begin opravit_tmp := opravit_tmp ^ [ i ] ;
22242: LD_ADDR_VAR 0 6
22246: PUSH
22247: LD_VAR 0 6
22251: PUSH
22252: LD_VAR 0 5
22256: PUSH
22257: EMPTY
22258: LIST
22259: ADD
22260: ST_TO_ADDR
// zivoty := zivoty ^ [ GetLives ( i ) ] ;
22261: LD_ADDR_VAR 0 4
22265: PUSH
22266: LD_VAR 0 4
22270: PUSH
22271: LD_VAR 0 5
22275: PPUSH
22276: CALL_OW 256
22280: PUSH
22281: EMPTY
22282: LIST
22283: ADD
22284: ST_TO_ADDR
// end ; end ;
22285: GO 22224
22287: POP
22288: POP
// if opravit_tmp then
22289: LD_VAR 0 6
22293: IFFALSE 22315
// opravit_tmp := SortListByListAsc ( opravit_tmp , zivoty ) ;
22295: LD_ADDR_VAR 0 6
22299: PUSH
22300: LD_VAR 0 6
22304: PPUSH
22305: LD_VAR 0 4
22309: PPUSH
22310: CALL_OW 76
22314: ST_TO_ADDR
// opravit := Replace ( opravit , opravit_index , opravit_tmp ) ;
22315: LD_ADDR_LOC 29
22319: PUSH
22320: LD_LOC 29
22324: PPUSH
22325: LD_VAR 0 1
22329: PPUSH
22330: LD_VAR 0 6
22334: PPUSH
22335: CALL_OW 1
22339: ST_TO_ADDR
// end ;
22340: LD_VAR 0 3
22344: RET
// every 0 0$5 do var i ;
22345: GO 22347
22347: DISABLE
22348: LD_INT 0
22350: PPUSH
// begin for i := 1 to 5 do
22351: LD_ADDR_VAR 0 1
22355: PUSH
22356: DOUBLE
22357: LD_INT 1
22359: DEC
22360: ST_TO_ADDR
22361: LD_INT 5
22363: PUSH
22364: FOR_TO
22365: IFFALSE 22409
// begin if not under_attack [ i ] then
22367: LD_EXP 62
22371: PUSH
22372: LD_VAR 0 1
22376: ARRAY
22377: NOT
22378: IFFALSE 22407
// begin HledejBudovyNaOpravy ( i , buildings [ i ] ) ;
22380: LD_VAR 0 1
22384: PPUSH
22385: LD_EXP 75
22389: PUSH
22390: LD_VAR 0 1
22394: ARRAY
22395: PPUSH
22396: CALL 22194 0 2
// wait ( 0 0$0.6 ) ;
22400: LD_INT 21
22402: PPUSH
22403: CALL_OW 67
// end ; end ;
22407: GO 22364
22409: POP
22410: POP
// enable ;
22411: ENABLE
// end ;
22412: PPOPN 1
22414: END
// every 0 0$5 do var i ;
22415: GO 22417
22417: DISABLE
22418: LD_INT 0
22420: PPUSH
// begin for i := 1 to 5 do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: DOUBLE
22427: LD_INT 1
22429: DEC
22430: ST_TO_ADDR
22431: LD_INT 5
22433: PUSH
22434: FOR_TO
22435: IFFALSE 22584
// begin if opravit [ i ] then
22437: LD_LOC 29
22441: PUSH
22442: LD_VAR 0 1
22446: ARRAY
22447: IFFALSE 22582
// begin ComRepairBuilding ( UnitFilter ( eng , [ [ f_not , [ f_hastask ] ] , [ f_side , GetSide ( opravit [ i ] [ 1 ] ) ] , [ f_dist , opravit [ i ] [ 1 ] , ( ( ( 1000 div 30 ) + 5 ) - GetLives ( opravit [ i ] [ 1 ] ) div 30 ) ] ] ) , opravit [ i ] [ 1 ] ) ;
22449: LD_EXP 84
22453: PPUSH
22454: LD_INT 3
22456: PUSH
22457: LD_INT 60
22459: PUSH
22460: EMPTY
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: PUSH
22467: LD_INT 22
22469: PUSH
22470: LD_LOC 29
22474: PUSH
22475: LD_VAR 0 1
22479: ARRAY
22480: PUSH
22481: LD_INT 1
22483: ARRAY
22484: PPUSH
22485: CALL_OW 255
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: PUSH
22494: LD_INT 91
22496: PUSH
22497: LD_LOC 29
22501: PUSH
22502: LD_VAR 0 1
22506: ARRAY
22507: PUSH
22508: LD_INT 1
22510: ARRAY
22511: PUSH
22512: LD_INT 1000
22514: PUSH
22515: LD_INT 30
22517: DIV
22518: PUSH
22519: LD_INT 5
22521: PLUS
22522: PUSH
22523: LD_LOC 29
22527: PUSH
22528: LD_VAR 0 1
22532: ARRAY
22533: PUSH
22534: LD_INT 1
22536: ARRAY
22537: PPUSH
22538: CALL_OW 256
22542: PUSH
22543: LD_INT 30
22545: DIV
22546: MINUS
22547: PUSH
22548: EMPTY
22549: LIST
22550: LIST
22551: LIST
22552: PUSH
22553: EMPTY
22554: LIST
22555: LIST
22556: LIST
22557: PPUSH
22558: CALL_OW 72
22562: PPUSH
22563: LD_LOC 29
22567: PUSH
22568: LD_VAR 0 1
22572: ARRAY
22573: PUSH
22574: LD_INT 1
22576: ARRAY
22577: PPUSH
22578: CALL_OW 130
// end ; end ;
22582: GO 22434
22584: POP
22585: POP
// enable ;
22586: ENABLE
// end ; end_of_file
22587: PPOPN 1
22589: END
// export factories ; export depots ; export buildings ; export humans ; export vehicles ; export attack_units ; export defence_units ; export mcdef_units ; export fort , sol , dep , eng , fact , mec , lab , sci ; export function inicializace_ai ; begin
22590: LD_INT 0
22592: PPUSH
// factories := [ 0 , 0 , 0 , 0 , 0 ] ;
22593: LD_ADDR_EXP 73
22597: PUSH
22598: LD_INT 0
22600: PUSH
22601: LD_INT 0
22603: PUSH
22604: LD_INT 0
22606: PUSH
22607: LD_INT 0
22609: PUSH
22610: LD_INT 0
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: LIST
22617: LIST
22618: LIST
22619: ST_TO_ADDR
// depots := [ 0 , 0 , 0 , 0 , 0 ] ;
22620: LD_ADDR_EXP 74
22624: PUSH
22625: LD_INT 0
22627: PUSH
22628: LD_INT 0
22630: PUSH
22631: LD_INT 0
22633: PUSH
22634: LD_INT 0
22636: PUSH
22637: LD_INT 0
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: LIST
22644: LIST
22645: LIST
22646: ST_TO_ADDR
// buildings := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22647: LD_ADDR_EXP 75
22651: PUSH
22652: EMPTY
22653: PUSH
22654: EMPTY
22655: PUSH
22656: EMPTY
22657: PUSH
22658: EMPTY
22659: PUSH
22660: EMPTY
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: ST_TO_ADDR
// humans := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22669: LD_ADDR_EXP 76
22673: PUSH
22674: EMPTY
22675: PUSH
22676: EMPTY
22677: PUSH
22678: EMPTY
22679: PUSH
22680: EMPTY
22681: PUSH
22682: EMPTY
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: ST_TO_ADDR
// vehicles := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22691: LD_ADDR_EXP 77
22695: PUSH
22696: EMPTY
22697: PUSH
22698: EMPTY
22699: PUSH
22700: EMPTY
22701: PUSH
22702: EMPTY
22703: PUSH
22704: EMPTY
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: ST_TO_ADDR
// attack_units := [ ] ;
22713: LD_ADDR_EXP 78
22717: PUSH
22718: EMPTY
22719: ST_TO_ADDR
// defence_units := [ ] ;
22720: LD_ADDR_EXP 79
22724: PUSH
22725: EMPTY
22726: ST_TO_ADDR
// end ;
22727: LD_VAR 0 1
22731: RET
// export function get_groups ; var i ; begin
22732: LD_INT 0
22734: PPUSH
22735: PPUSH
// fort := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fort ] ) ;
22736: LD_ADDR_EXP 81
22740: PUSH
22741: LD_INT 3
22743: PUSH
22744: LD_INT 22
22746: PUSH
22747: LD_EXP 7
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PUSH
22760: LD_EXP 56
22764: PUSH
22765: EMPTY
22766: LIST
22767: LIST
22768: PPUSH
22769: CALL_OW 69
22773: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sol ] ) diff hlavouni ;
22774: LD_ADDR_EXP 82
22778: PUSH
22779: LD_INT 3
22781: PUSH
22782: LD_INT 22
22784: PUSH
22785: LD_EXP 7
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: PUSH
22798: LD_EXP 51
22802: PUSH
22803: EMPTY
22804: LIST
22805: LIST
22806: PPUSH
22807: CALL_OW 69
22811: PUSH
22812: LD_EXP 72
22816: DIFF
22817: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_dep ] ) ;
22818: LD_ADDR_EXP 83
22822: PUSH
22823: LD_INT 3
22825: PUSH
22826: LD_INT 22
22828: PUSH
22829: LD_EXP 7
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: PUSH
22838: EMPTY
22839: LIST
22840: LIST
22841: PUSH
22842: LD_EXP 58
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PPUSH
22851: CALL_OW 69
22855: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_eng ] ) diff hlavouni ;
22856: LD_ADDR_EXP 84
22860: PUSH
22861: LD_INT 3
22863: PUSH
22864: LD_INT 22
22866: PUSH
22867: LD_EXP 7
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PUSH
22880: LD_EXP 52
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PPUSH
22889: CALL_OW 69
22893: PUSH
22894: LD_EXP 72
22898: DIFF
22899: ST_TO_ADDR
// fact := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fact ] ) ;
22900: LD_ADDR_EXP 85
22904: PUSH
22905: LD_INT 3
22907: PUSH
22908: LD_INT 22
22910: PUSH
22911: LD_EXP 7
22915: PUSH
22916: EMPTY
22917: LIST
22918: LIST
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PUSH
22924: LD_EXP 59
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: PPUSH
22933: CALL_OW 69
22937: ST_TO_ADDR
// mec := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_mec ] ) diff hlavouni ;
22938: LD_ADDR_EXP 86
22942: PUSH
22943: LD_INT 3
22945: PUSH
22946: LD_INT 22
22948: PUSH
22949: LD_EXP 7
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: PUSH
22962: LD_EXP 53
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PPUSH
22971: CALL_OW 69
22975: PUSH
22976: LD_EXP 72
22980: DIFF
22981: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_lab ] ) ;
22982: LD_ADDR_EXP 87
22986: PUSH
22987: LD_INT 3
22989: PUSH
22990: LD_INT 22
22992: PUSH
22993: LD_EXP 7
22997: PUSH
22998: EMPTY
22999: LIST
23000: LIST
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: PUSH
23006: LD_EXP 55
23010: PUSH
23011: EMPTY
23012: LIST
23013: LIST
23014: PPUSH
23015: CALL_OW 69
23019: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sci ] ) diff hlavouni ;
23020: LD_ADDR_EXP 88
23024: PUSH
23025: LD_INT 3
23027: PUSH
23028: LD_INT 22
23030: PUSH
23031: LD_EXP 7
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PUSH
23044: LD_EXP 54
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PPUSH
23053: CALL_OW 69
23057: PUSH
23058: LD_EXP 72
23062: DIFF
23063: ST_TO_ADDR
// for i := 1 to 5 do
23064: LD_ADDR_VAR 0 2
23068: PUSH
23069: DOUBLE
23070: LD_INT 1
23072: DEC
23073: ST_TO_ADDR
23074: LD_INT 5
23076: PUSH
23077: FOR_TO
23078: IFFALSE 23263
// begin humans := replace ( humans , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_human ] ] ) diff hlavouni ) ;
23080: LD_ADDR_EXP 76
23084: PUSH
23085: LD_EXP 76
23089: PPUSH
23090: LD_VAR 0 2
23094: PPUSH
23095: LD_INT 22
23097: PUSH
23098: LD_EXP 23
23102: PUSH
23103: LD_VAR 0 2
23107: ARRAY
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PUSH
23113: LD_INT 21
23115: PUSH
23116: LD_INT 1
23118: PUSH
23119: EMPTY
23120: LIST
23121: LIST
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PPUSH
23127: CALL_OW 69
23131: PUSH
23132: LD_EXP 72
23136: DIFF
23137: PPUSH
23138: CALL_OW 1
23142: ST_TO_ADDR
// vehicles := replace ( vehicles , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_vehicle ] ] ) diff art_cargo ) ;
23143: LD_ADDR_EXP 77
23147: PUSH
23148: LD_EXP 77
23152: PPUSH
23153: LD_VAR 0 2
23157: PPUSH
23158: LD_INT 22
23160: PUSH
23161: LD_EXP 23
23165: PUSH
23166: LD_VAR 0 2
23170: ARRAY
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PUSH
23176: LD_INT 21
23178: PUSH
23179: LD_INT 2
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: EMPTY
23187: LIST
23188: LIST
23189: PPUSH
23190: CALL_OW 69
23194: PUSH
23195: LD_INT 121
23197: DIFF
23198: PPUSH
23199: CALL_OW 1
23203: ST_TO_ADDR
// buildings := replace ( buildings , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_building ] ] ) ) ;
23204: LD_ADDR_EXP 75
23208: PUSH
23209: LD_EXP 75
23213: PPUSH
23214: LD_VAR 0 2
23218: PPUSH
23219: LD_INT 22
23221: PUSH
23222: LD_EXP 23
23226: PUSH
23227: LD_VAR 0 2
23231: ARRAY
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: PUSH
23237: LD_INT 21
23239: PUSH
23240: LD_INT 3
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: EMPTY
23248: LIST
23249: LIST
23250: PPUSH
23251: CALL_OW 69
23255: PPUSH
23256: CALL_OW 1
23260: ST_TO_ADDR
// end ;
23261: GO 23077
23263: POP
23264: POP
// attack_units := FilterAllUnits ( [ [ f_control , control_computer ] ] ) ;
23265: LD_ADDR_EXP 78
23269: PUSH
23270: LD_INT 33
23272: PUSH
23273: LD_INT 3
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: EMPTY
23281: LIST
23282: PPUSH
23283: CALL_OW 69
23287: ST_TO_ADDR
// defence_units := FilterAllUnits ( [ [ f_control , control_manual ] ] ) diff art_cargo ;
23288: LD_ADDR_EXP 79
23292: PUSH
23293: LD_INT 33
23295: PUSH
23296: LD_INT 1
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: PPUSH
23306: CALL_OW 69
23310: PUSH
23311: LD_INT 121
23313: DIFF
23314: ST_TO_ADDR
// write_deps ;
23315: CALL 23328 0 0
// write_facts ;
23319: CALL 23447 0 0
// end ;
23323: LD_VAR 0 1
23327: RET
// export function write_deps ; var i , a ; begin
23328: LD_INT 0
23330: PPUSH
23331: PPUSH
23332: PPUSH
// for i := 1 to 5 do
23333: LD_ADDR_VAR 0 2
23337: PUSH
23338: DOUBLE
23339: LD_INT 1
23341: DEC
23342: ST_TO_ADDR
23343: LD_INT 5
23345: PUSH
23346: FOR_TO
23347: IFFALSE 23440
// begin a := UnitFilter ( buildings [ i ] , [ mf_dep ] ) ;
23349: LD_ADDR_VAR 0 3
23353: PUSH
23354: LD_EXP 75
23358: PUSH
23359: LD_VAR 0 2
23363: ARRAY
23364: PPUSH
23365: LD_EXP 58
23369: PUSH
23370: EMPTY
23371: LIST
23372: PPUSH
23373: CALL_OW 72
23377: ST_TO_ADDR
// if a then
23378: LD_VAR 0 3
23382: IFFALSE 23415
// depots := replace ( depots , i , a [ 1 ] ) else
23384: LD_ADDR_EXP 74
23388: PUSH
23389: LD_EXP 74
23393: PPUSH
23394: LD_VAR 0 2
23398: PPUSH
23399: LD_VAR 0 3
23403: PUSH
23404: LD_INT 1
23406: ARRAY
23407: PPUSH
23408: CALL_OW 1
23412: ST_TO_ADDR
23413: GO 23438
// depots := replace ( depots , i , 0 ) ;
23415: LD_ADDR_EXP 74
23419: PUSH
23420: LD_EXP 74
23424: PPUSH
23425: LD_VAR 0 2
23429: PPUSH
23430: LD_INT 0
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// end ;
23438: GO 23346
23440: POP
23441: POP
// end ;
23442: LD_VAR 0 1
23446: RET
// export function write_facts ; var i , a ; begin
23447: LD_INT 0
23449: PPUSH
23450: PPUSH
23451: PPUSH
// for i := 1 to 5 do
23452: LD_ADDR_VAR 0 2
23456: PUSH
23457: DOUBLE
23458: LD_INT 1
23460: DEC
23461: ST_TO_ADDR
23462: LD_INT 5
23464: PUSH
23465: FOR_TO
23466: IFFALSE 23559
// begin a := UnitFilter ( buildings [ i ] , [ mf_fact ] ) ;
23468: LD_ADDR_VAR 0 3
23472: PUSH
23473: LD_EXP 75
23477: PUSH
23478: LD_VAR 0 2
23482: ARRAY
23483: PPUSH
23484: LD_EXP 59
23488: PUSH
23489: EMPTY
23490: LIST
23491: PPUSH
23492: CALL_OW 72
23496: ST_TO_ADDR
// if a then
23497: LD_VAR 0 3
23501: IFFALSE 23534
// factories := replace ( factories , i , a [ 1 ] ) else
23503: LD_ADDR_EXP 73
23507: PUSH
23508: LD_EXP 73
23512: PPUSH
23513: LD_VAR 0 2
23517: PPUSH
23518: LD_VAR 0 3
23522: PUSH
23523: LD_INT 1
23525: ARRAY
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
23532: GO 23557
// factories := replace ( factories , i , 0 ) ;
23534: LD_ADDR_EXP 73
23538: PUSH
23539: LD_EXP 73
23543: PPUSH
23544: LD_VAR 0 2
23548: PPUSH
23549: LD_INT 0
23551: PPUSH
23552: CALL_OW 1
23556: ST_TO_ADDR
// end ;
23557: GO 23465
23559: POP
23560: POP
// end ;
23561: LD_VAR 0 1
23565: RET
// every 0 0$6 + 0 0$0.9 do var i , j , blds , hums , cars ;
23566: GO 23568
23568: DISABLE
23569: LD_INT 0
23571: PPUSH
23572: PPUSH
23573: PPUSH
23574: PPUSH
23575: PPUSH
// begin hums := [ ] ;
23576: LD_ADDR_VAR 0 4
23580: PUSH
23581: EMPTY
23582: ST_TO_ADDR
// for i in sol do
23583: LD_ADDR_VAR 0 1
23587: PUSH
23588: LD_EXP 82
23592: PUSH
23593: FOR_IN
23594: IFFALSE 23670
// if ( not HasTask ( i ) and not ( GetBType ( IsInUnit ( i ) ) = b_bunker or GetBType ( IsInUnit ( i ) ) = b_breastwork ) ) then
23596: LD_VAR 0 1
23600: PPUSH
23601: CALL_OW 314
23605: NOT
23606: PUSH
23607: LD_VAR 0 1
23611: PPUSH
23612: CALL_OW 310
23616: PPUSH
23617: CALL_OW 266
23621: PUSH
23622: LD_INT 32
23624: EQUAL
23625: PUSH
23626: LD_VAR 0 1
23630: PPUSH
23631: CALL_OW 310
23635: PPUSH
23636: CALL_OW 266
23640: PUSH
23641: LD_INT 31
23643: EQUAL
23644: OR
23645: NOT
23646: AND
23647: IFFALSE 23668
// hums := hums ^ [ i ] ;
23649: LD_ADDR_VAR 0 4
23653: PUSH
23654: LD_VAR 0 4
23658: PUSH
23659: LD_VAR 0 1
23663: PUSH
23664: EMPTY
23665: LIST
23666: ADD
23667: ST_TO_ADDR
23668: GO 23593
23670: POP
23671: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ mf_bunk ] ] ) ;
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: LD_EXP 81
23681: PPUSH
23682: LD_INT 3
23684: PUSH
23685: LD_INT 59
23687: PUSH
23688: EMPTY
23689: LIST
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: PUSH
23695: LD_EXP 57
23699: PUSH
23700: EMPTY
23701: LIST
23702: PUSH
23703: EMPTY
23704: LIST
23705: LIST
23706: PPUSH
23707: CALL_OW 72
23711: ST_TO_ADDR
// for i in blds do
23712: LD_ADDR_VAR 0 1
23716: PUSH
23717: LD_VAR 0 3
23721: PUSH
23722: FOR_IN
23723: IFFALSE 23828
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 40 ] ] ) , i ) ;
23725: LD_ADDR_VAR 0 2
23729: PUSH
23730: LD_VAR 0 4
23734: PPUSH
23735: LD_INT 22
23737: PUSH
23738: LD_VAR 0 1
23742: PPUSH
23743: CALL_OW 255
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: PUSH
23752: LD_INT 91
23754: PUSH
23755: LD_VAR 0 1
23759: PUSH
23760: LD_INT 40
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: LIST
23767: PUSH
23768: EMPTY
23769: LIST
23770: LIST
23771: PPUSH
23772: CALL_OW 72
23776: PPUSH
23777: LD_VAR 0 1
23781: PPUSH
23782: CALL_OW 74
23786: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23787: LD_VAR 0 2
23791: PPUSH
23792: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23796: LD_VAR 0 2
23800: PPUSH
23801: LD_VAR 0 1
23805: PPUSH
23806: CALL_OW 180
// hums := hums diff j ;
23810: LD_ADDR_VAR 0 4
23814: PUSH
23815: LD_VAR 0 4
23819: PUSH
23820: LD_VAR 0 2
23824: DIFF
23825: ST_TO_ADDR
// end ;
23826: GO 23722
23828: POP
23829: POP
// cars := UnitFilter ( defence_units , [ f_not , [ f_occupied ] ] ) ;
23830: LD_ADDR_VAR 0 5
23834: PUSH
23835: LD_EXP 79
23839: PPUSH
23840: LD_INT 3
23842: PUSH
23843: LD_INT 59
23845: PUSH
23846: EMPTY
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 72
23857: ST_TO_ADDR
// for i in cars do
23858: LD_ADDR_VAR 0 1
23862: PUSH
23863: LD_VAR 0 5
23867: PUSH
23868: FOR_IN
23869: IFFALSE 23974
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
23871: LD_ADDR_VAR 0 2
23875: PUSH
23876: LD_VAR 0 4
23880: PPUSH
23881: LD_INT 22
23883: PUSH
23884: LD_VAR 0 1
23888: PPUSH
23889: CALL_OW 255
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: LD_INT 91
23900: PUSH
23901: LD_VAR 0 1
23905: PUSH
23906: LD_INT 30
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: LIST
23913: PUSH
23914: EMPTY
23915: LIST
23916: LIST
23917: PPUSH
23918: CALL_OW 72
23922: PPUSH
23923: LD_VAR 0 1
23927: PPUSH
23928: CALL_OW 74
23932: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23933: LD_VAR 0 2
23937: PPUSH
23938: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23942: LD_VAR 0 2
23946: PPUSH
23947: LD_VAR 0 1
23951: PPUSH
23952: CALL_OW 180
// hums := hums diff j ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_VAR 0 4
23965: PUSH
23966: LD_VAR 0 2
23970: DIFF
23971: ST_TO_ADDR
// end ;
23972: GO 23868
23974: POP
23975: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
23976: LD_ADDR_VAR 0 3
23980: PUSH
23981: LD_EXP 81
23985: PPUSH
23986: LD_INT 3
23988: PUSH
23989: LD_INT 59
23991: PUSH
23992: EMPTY
23993: LIST
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 2
24001: PUSH
24002: LD_INT 30
24004: PUSH
24005: LD_INT 5
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 30
24014: PUSH
24015: LD_INT 4
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: PPUSH
24031: CALL_OW 72
24035: ST_TO_ADDR
// for i in blds do
24036: LD_ADDR_VAR 0 1
24040: PUSH
24041: LD_VAR 0 3
24045: PUSH
24046: FOR_IN
24047: IFFALSE 24107
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24049: LD_VAR 0 4
24053: PPUSH
24054: LD_INT 22
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL_OW 255
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: PUSH
24071: LD_INT 91
24073: PUSH
24074: LD_VAR 0 1
24078: PUSH
24079: LD_INT 30
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: PPUSH
24091: CALL_OW 72
24095: PPUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: CALL_OW 120
24105: GO 24046
24107: POP
24108: POP
// enable ;
24109: ENABLE
// end ;
24110: PPOPN 5
24112: END
// every 0 0$2 + 0 0$0.5 do var i , j , blds , hums ;
24113: GO 24115
24115: DISABLE
24116: LD_INT 0
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
// begin blds := dep ;
24122: LD_ADDR_VAR 0 3
24126: PUSH
24127: LD_EXP 83
24131: ST_TO_ADDR
// hums := [ ] ;
24132: LD_ADDR_VAR 0 4
24136: PUSH
24137: EMPTY
24138: ST_TO_ADDR
// for i in eng do
24139: LD_ADDR_VAR 0 1
24143: PUSH
24144: LD_EXP 84
24148: PUSH
24149: FOR_IN
24150: IFFALSE 24197
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24152: LD_VAR 0 1
24156: PPUSH
24157: CALL_OW 315
24161: NOT
24162: PUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 310
24172: NOT
24173: AND
24174: IFFALSE 24195
// hums := hums ^ [ i ] ;
24176: LD_ADDR_VAR 0 4
24180: PUSH
24181: LD_VAR 0 4
24185: PUSH
24186: LD_VAR 0 1
24190: PUSH
24191: EMPTY
24192: LIST
24193: ADD
24194: ST_TO_ADDR
24195: GO 24149
24197: POP
24198: POP
// for i in blds do
24199: LD_ADDR_VAR 0 1
24203: PUSH
24204: LD_VAR 0 3
24208: PUSH
24209: FOR_IN
24210: IFFALSE 24270
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , GetSide ( i ) ] , [ f_dist , i , 25 ] ] ) , i ) ;
24212: LD_VAR 0 4
24216: PPUSH
24217: LD_INT 22
24219: PUSH
24220: LD_VAR 0 1
24224: PPUSH
24225: CALL_OW 255
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: PUSH
24234: LD_INT 91
24236: PUSH
24237: LD_VAR 0 1
24241: PUSH
24242: LD_INT 25
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: LIST
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PPUSH
24254: CALL_OW 72
24258: PPUSH
24259: LD_VAR 0 1
24263: PPUSH
24264: CALL_OW 120
24268: GO 24209
24270: POP
24271: POP
// enable ;
24272: ENABLE
// end ;
24273: PPOPN 4
24275: END
// every 0 0$2 + 0 0$0.7 do var i , j , blds , hums ;
24276: GO 24278
24278: DISABLE
24279: LD_INT 0
24281: PPUSH
24282: PPUSH
24283: PPUSH
24284: PPUSH
// begin blds := fact ;
24285: LD_ADDR_VAR 0 3
24289: PUSH
24290: LD_EXP 85
24294: ST_TO_ADDR
// hums := [ ] ;
24295: LD_ADDR_VAR 0 4
24299: PUSH
24300: EMPTY
24301: ST_TO_ADDR
// for i in mec do
24302: LD_ADDR_VAR 0 1
24306: PUSH
24307: LD_EXP 86
24311: PUSH
24312: FOR_IN
24313: IFFALSE 24360
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24315: LD_VAR 0 1
24319: PPUSH
24320: CALL_OW 315
24324: NOT
24325: PUSH
24326: LD_VAR 0 1
24330: PPUSH
24331: CALL_OW 310
24335: NOT
24336: AND
24337: IFFALSE 24358
// hums := hums ^ [ i ] ;
24339: LD_ADDR_VAR 0 4
24343: PUSH
24344: LD_VAR 0 4
24348: PUSH
24349: LD_VAR 0 1
24353: PUSH
24354: EMPTY
24355: LIST
24356: ADD
24357: ST_TO_ADDR
24358: GO 24312
24360: POP
24361: POP
// for i in blds do
24362: LD_ADDR_VAR 0 1
24366: PUSH
24367: LD_VAR 0 3
24371: PUSH
24372: FOR_IN
24373: IFFALSE 24433
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24375: LD_VAR 0 4
24379: PPUSH
24380: LD_INT 22
24382: PUSH
24383: LD_VAR 0 1
24387: PPUSH
24388: CALL_OW 255
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: PUSH
24397: LD_INT 91
24399: PUSH
24400: LD_VAR 0 1
24404: PUSH
24405: LD_INT 30
24407: PUSH
24408: EMPTY
24409: LIST
24410: LIST
24411: LIST
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PPUSH
24417: CALL_OW 72
24421: PPUSH
24422: LD_VAR 0 1
24426: PPUSH
24427: CALL_OW 120
24431: GO 24372
24433: POP
24434: POP
// enable ;
24435: ENABLE
// end ;
24436: PPOPN 4
24438: END
// every 0 0$2 + 0 0$0.9 do var i , j , blds , hums ;
24439: GO 24441
24441: DISABLE
24442: LD_INT 0
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
// begin blds := lab ;
24448: LD_ADDR_VAR 0 3
24452: PUSH
24453: LD_EXP 87
24457: ST_TO_ADDR
// hums := [ ] ;
24458: LD_ADDR_VAR 0 4
24462: PUSH
24463: EMPTY
24464: ST_TO_ADDR
// for i in sci do
24465: LD_ADDR_VAR 0 1
24469: PUSH
24470: LD_EXP 88
24474: PUSH
24475: FOR_IN
24476: IFFALSE 24523
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24478: LD_VAR 0 1
24482: PPUSH
24483: CALL_OW 315
24487: NOT
24488: PUSH
24489: LD_VAR 0 1
24493: PPUSH
24494: CALL_OW 310
24498: NOT
24499: AND
24500: IFFALSE 24521
// hums := hums ^ [ i ] ;
24502: LD_ADDR_VAR 0 4
24506: PUSH
24507: LD_VAR 0 4
24511: PUSH
24512: LD_VAR 0 1
24516: PUSH
24517: EMPTY
24518: LIST
24519: ADD
24520: ST_TO_ADDR
24521: GO 24475
24523: POP
24524: POP
// for i in blds do
24525: LD_ADDR_VAR 0 1
24529: PUSH
24530: LD_VAR 0 3
24534: PUSH
24535: FOR_IN
24536: IFFALSE 24596
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24538: LD_VAR 0 4
24542: PPUSH
24543: LD_INT 22
24545: PUSH
24546: LD_VAR 0 1
24550: PPUSH
24551: CALL_OW 255
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: LD_INT 91
24562: PUSH
24563: LD_VAR 0 1
24567: PUSH
24568: LD_INT 30
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: LIST
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PPUSH
24580: CALL_OW 72
24584: PPUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: CALL_OW 120
24594: GO 24535
24596: POP
24597: POP
// enable ;
24598: ENABLE
// end ; end_of_file
24599: PPOPN 4
24601: END
// on UnitDestroyed ( un ) do var h , hinfo , a ;
24602: LD_INT 0
24604: PPUSH
24605: PPUSH
24606: PPUSH
// begin if un = Burlak then
24607: LD_VAR 0 1
24611: PUSH
24612: LD_EXP 41
24616: EQUAL
24617: IFFALSE 24626
// begin YouLost ( Burlak ) ;
24619: LD_STRING Burlak
24621: PPUSH
24622: CALL_OW 104
// end ; if un = Platonov then
24626: LD_VAR 0 1
24630: PUSH
24631: LD_EXP 42
24635: EQUAL
24636: IFFALSE 24661
// begin SurrenderBase ( t_kill , GetSide ( un ) ) ;
24638: LD_EXP 1
24642: PPUSH
24643: LD_VAR 0 1
24647: PPUSH
24648: CALL_OW 255
24652: PPUSH
24653: CALL 30288 0 2
// VyhraPlaton ;
24657: CALL 358 0 0
// end ; if GetSide ( un ) <> you then
24661: LD_VAR 0 1
24665: PPUSH
24666: CALL_OW 255
24670: PUSH
24671: LD_EXP 7
24675: NONEQUAL
24676: IFFALSE 24705
// begin remove_from_vehicles ( un ) ;
24678: LD_VAR 0 1
24682: PPUSH
24683: CALL 28194 0 1
// remove_from_humans ( un ) ;
24687: LD_VAR 0 1
24691: PPUSH
24692: CALL 27956 0 1
// remove_from_builds ( un ) ;
24696: LD_VAR 0 1
24700: PPUSH
24701: CALL 27710 0 1
// end ; if not GetSide ( un ) in your_bases then
24705: LD_VAR 0 1
24709: PPUSH
24710: CALL_OW 255
24714: PUSH
24715: LD_EXP 18
24719: IN
24720: NOT
24721: IFFALSE 24843
// begin if un = Borodin then
24723: LD_VAR 0 1
24727: PUSH
24728: LD_EXP 46
24732: EQUAL
24733: IFFALSE 24753
// begin SurrenderBase ( t_kill , ai_s [ 2 ] ) ;
24735: LD_EXP 1
24739: PPUSH
24740: LD_EXP 23
24744: PUSH
24745: LD_INT 2
24747: ARRAY
24748: PPUSH
24749: CALL 30288 0 2
// end ; if un = Tsaritsyn then
24753: LD_VAR 0 1
24757: PUSH
24758: LD_EXP 47
24762: EQUAL
24763: IFFALSE 24783
// begin SurrenderBase ( t_kill , ai_s [ 3 ] ) ;
24765: LD_EXP 1
24769: PPUSH
24770: LD_EXP 23
24774: PUSH
24775: LD_INT 3
24777: ARRAY
24778: PPUSH
24779: CALL 30288 0 2
// end ; if un = Davidov then
24783: LD_VAR 0 1
24787: PUSH
24788: LD_EXP 48
24792: EQUAL
24793: IFFALSE 24813
// begin SurrenderBase ( t_kill , ai_s [ 4 ] ) ;
24795: LD_EXP 1
24799: PPUSH
24800: LD_EXP 23
24804: PUSH
24805: LD_INT 4
24807: ARRAY
24808: PPUSH
24809: CALL 30288 0 2
// end ; if un = Eisenstein then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_EXP 49
24822: EQUAL
24823: IFFALSE 24843
// begin SurrenderBase ( t_kill , ai_s [ 5 ] ) ;
24825: LD_EXP 1
24829: PPUSH
24830: LD_EXP 23
24834: PUSH
24835: LD_INT 5
24837: ARRAY
24838: PPUSH
24839: CALL 30288 0 2
// end ; end ; if GetSide ( un ) = you then
24843: LD_VAR 0 1
24847: PPUSH
24848: CALL_OW 255
24852: PUSH
24853: LD_EXP 7
24857: EQUAL
24858: IFFALSE 24978
// case true of GetType ( un ) = unit_building :
24860: LD_INT 1
24862: PUSH
24863: LD_VAR 0 1
24867: PPUSH
24868: CALL_OW 247
24872: PUSH
24873: LD_INT 3
24875: EQUAL
24876: DOUBLE
24877: EQUAL
24878: IFTRUE 24882
24880: GO 24901
24882: POP
// your_builds := your_builds diff un ; GetType ( un ) = unit_vehicle :
24883: LD_ADDR_EXP 36
24887: PUSH
24888: LD_EXP 36
24892: PUSH
24893: LD_VAR 0 1
24897: DIFF
24898: ST_TO_ADDR
24899: GO 24978
24901: LD_VAR 0 1
24905: PPUSH
24906: CALL_OW 247
24910: PUSH
24911: LD_INT 2
24913: EQUAL
24914: DOUBLE
24915: EQUAL
24916: IFTRUE 24920
24918: GO 24939
24920: POP
// your_cars := your_cars diff un ; GetType ( un ) = unit_human :
24921: LD_ADDR_EXP 35
24925: PUSH
24926: LD_EXP 35
24930: PUSH
24931: LD_VAR 0 1
24935: DIFF
24936: ST_TO_ADDR
24937: GO 24978
24939: LD_VAR 0 1
24943: PPUSH
24944: CALL_OW 247
24948: PUSH
24949: LD_INT 1
24951: EQUAL
24952: DOUBLE
24953: EQUAL
24954: IFTRUE 24958
24956: GO 24977
24958: POP
// your_humans := your_humans diff un ; end ;
24959: LD_ADDR_EXP 37
24963: PUSH
24964: LD_EXP 37
24968: PUSH
24969: LD_VAR 0 1
24973: DIFF
24974: ST_TO_ADDR
24975: GO 24978
24977: POP
// end ;
24978: PPOPN 4
24980: END
// on UnitGoesToRed ( un ) do var a ;
24981: LD_INT 0
24983: PPUSH
// begin if not GetSide ( un ) in your_bases ^ you then
24984: LD_VAR 0 1
24988: PPUSH
24989: CALL_OW 255
24993: PUSH
24994: LD_EXP 18
24998: PUSH
24999: LD_EXP 7
25003: ADD
25004: IN
25005: NOT
25006: IFFALSE 25239
// begin if GetBType ( un ) in [ b_depot , b_warehouse ] then
25008: LD_VAR 0 1
25012: PPUSH
25013: CALL_OW 266
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 1
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: IN
25028: IFFALSE 25239
// begin a := FilterAllUnits ( [ [ f_side , GetSide ( un ) ] ] ) ;
25030: LD_ADDR_VAR 0 2
25034: PUSH
25035: LD_INT 22
25037: PUSH
25038: LD_VAR 0 1
25042: PPUSH
25043: CALL_OW 255
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: EMPTY
25053: LIST
25054: PPUSH
25055: CALL_OW 69
25059: ST_TO_ADDR
// if GetSide ( un ) = ai_s [ 1 ] and IsDead ( behemoth ) and UnitFilter ( a , [ mf_sol ] ) <= 2 and UnitFilter ( a , [ [ f_type , unit_vehicle ] , [ f_or , [ [ f_control , control_manual ] , [ f_occupied ] ] , [ f_control , control_computer ] ] ] ) <= 1 then
25060: LD_VAR 0 1
25064: PPUSH
25065: CALL_OW 255
25069: PUSH
25070: LD_EXP 23
25074: PUSH
25075: LD_INT 1
25077: ARRAY
25078: EQUAL
25079: PUSH
25080: LD_INT 125
25082: PPUSH
25083: CALL_OW 301
25087: AND
25088: PUSH
25089: LD_VAR 0 2
25093: PPUSH
25094: LD_EXP 51
25098: PUSH
25099: EMPTY
25100: LIST
25101: PPUSH
25102: CALL_OW 72
25106: PUSH
25107: LD_INT 2
25109: LESSEQUAL
25110: AND
25111: PUSH
25112: LD_VAR 0 2
25116: PPUSH
25117: LD_INT 21
25119: PUSH
25120: LD_INT 2
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PUSH
25127: LD_INT 2
25129: PUSH
25130: LD_INT 33
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: EMPTY
25137: LIST
25138: LIST
25139: PUSH
25140: LD_INT 59
25142: PUSH
25143: EMPTY
25144: LIST
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: LD_INT 33
25152: PUSH
25153: LD_INT 3
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: PUSH
25160: EMPTY
25161: LIST
25162: LIST
25163: LIST
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PPUSH
25169: CALL_OW 72
25173: PUSH
25174: LD_INT 1
25176: LESSEQUAL
25177: AND
25178: IFFALSE 25199
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25180: LD_EXP 6
25184: PPUSH
25185: LD_VAR 0 1
25189: PPUSH
25190: CALL_OW 255
25194: PPUSH
25195: CALL 30288 0 2
// if GetSide ( un ) <> ai_s [ 1 ] then
25199: LD_VAR 0 1
25203: PPUSH
25204: CALL_OW 255
25208: PUSH
25209: LD_EXP 23
25213: PUSH
25214: LD_INT 1
25216: ARRAY
25217: NONEQUAL
25218: IFFALSE 25239
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25220: LD_EXP 6
25224: PPUSH
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 255
25234: PPUSH
25235: CALL 30288 0 2
// end ; end ; end ;
25239: PPOPN 2
25241: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside in ai then
25242: LD_VAR 0 3
25246: PUSH
25247: LD_EXP 24
25251: IN
25252: IFFALSE 25315
// begin remove_from_vehicles ( vehold ) ;
25254: LD_VAR 0 2
25258: PPUSH
25259: CALL 28194 0 1
// if GetAttitude ( origside , you ) = att_neutral then
25263: LD_VAR 0 3
25267: PPUSH
25268: LD_EXP 7
25272: PPUSH
25273: CALL_OW 81
25277: PUSH
25278: LD_INT 0
25280: EQUAL
25281: IFFALSE 25315
// begin ComExitVehicle ( vehnew ) ;
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 121
// SetSide ( vehnew , origside ) ;
25292: LD_VAR 0 1
25296: PPUSH
25297: LD_VAR 0 3
25301: PPUSH
25302: CALL_OW 235
// add_to_vehicles ( vehnew ) ;
25306: LD_VAR 0 1
25310: PPUSH
25311: CALL 26863 0 1
// end ; end ; if Getside ( vehnew ) in ai then
25315: LD_VAR 0 1
25319: PPUSH
25320: CALL_OW 255
25324: PUSH
25325: LD_EXP 24
25329: IN
25330: IFFALSE 25341
// begin add_to_vehicles ( vehnew ) ;
25332: LD_VAR 0 1
25336: PPUSH
25337: CALL 26863 0 1
// end ; if origside = you then
25341: LD_VAR 0 3
25345: PUSH
25346: LD_EXP 7
25350: EQUAL
25351: IFFALSE 25369
// your_cars := your_cars diff vehold ;
25353: LD_ADDR_EXP 35
25357: PUSH
25358: LD_EXP 35
25362: PUSH
25363: LD_VAR 0 2
25367: DIFF
25368: ST_TO_ADDR
// if GetSide ( vehnew ) = you then
25369: LD_VAR 0 1
25373: PPUSH
25374: CALL_OW 255
25378: PUSH
25379: LD_EXP 7
25383: EQUAL
25384: IFFALSE 25402
// your_cars := your_cars union vehnew ;
25386: LD_ADDR_EXP 35
25390: PUSH
25391: LD_EXP 35
25395: PUSH
25396: LD_VAR 0 1
25400: UNION
25401: ST_TO_ADDR
// if getside ( vehnew ) and GetCargo ( vehnew , mat_artefact ) > 0 then
25402: LD_VAR 0 1
25406: PPUSH
25407: CALL_OW 255
25411: PUSH
25412: LD_VAR 0 1
25416: PPUSH
25417: LD_INT 4
25419: PPUSH
25420: CALL_OW 289
25424: PUSH
25425: LD_INT 0
25427: GREATER
25428: AND
25429: IFFALSE 25439
// maji_artifact := true ;
25431: LD_ADDR_EXP 39
25435: PUSH
25436: LD_INT 1
25438: ST_TO_ADDR
// if origside = you and GetCargo ( vehnew , mat_artefact ) > 0 then
25439: LD_VAR 0 3
25443: PUSH
25444: LD_EXP 7
25448: EQUAL
25449: PUSH
25450: LD_VAR 0 1
25454: PPUSH
25455: LD_INT 4
25457: PPUSH
25458: CALL_OW 289
25462: PUSH
25463: LD_INT 0
25465: GREATER
25466: AND
25467: IFFALSE 25477
// maji_artifact := false ;
25469: LD_ADDR_EXP 39
25473: PUSH
25474: LD_INT 0
25476: ST_TO_ADDR
// end ;
25477: PPOPN 4
25479: END
// on BuildingCaptured ( build , origside , eng ) do begin if origside = you then
25480: LD_VAR 0 2
25484: PUSH
25485: LD_EXP 7
25489: EQUAL
25490: IFFALSE 25508
// begin your_builds := your_builds diff build ;
25492: LD_ADDR_EXP 36
25496: PUSH
25497: LD_EXP 36
25501: PUSH
25502: LD_VAR 0 1
25506: DIFF
25507: ST_TO_ADDR
// end ; if GetSide ( build ) = you then
25508: LD_VAR 0 1
25512: PPUSH
25513: CALL_OW 255
25517: PUSH
25518: LD_EXP 7
25522: EQUAL
25523: IFFALSE 25541
// begin your_builds := your_builds union build ;
25525: LD_ADDR_EXP 36
25529: PUSH
25530: LD_EXP 36
25534: PUSH
25535: LD_VAR 0 1
25539: UNION
25540: ST_TO_ADDR
// end ; if origside in ai then
25541: LD_VAR 0 2
25545: PUSH
25546: LD_EXP 24
25550: IN
25551: IFFALSE 25562
// begin remove_from_builds ( build ) ;
25553: LD_VAR 0 1
25557: PPUSH
25558: CALL 27710 0 1
// end ; if GetSide ( build ) in ai then
25562: LD_VAR 0 1
25566: PPUSH
25567: CALL_OW 255
25571: PUSH
25572: LD_EXP 24
25576: IN
25577: IFFALSE 25588
// begin add_to_builds ( build ) ;
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL 27208 0 1
// end ; end ;
25588: PPOPN 3
25590: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
25591: LD_VAR 0 1
25595: PPUSH
25596: CALL_OW 255
25600: PUSH
25601: LD_EXP 7
25605: EQUAL
25606: IFFALSE 25624
// begin your_builds := your_builds union build ;
25608: LD_ADDR_EXP 36
25612: PUSH
25613: LD_EXP 36
25617: PUSH
25618: LD_VAR 0 1
25622: UNION
25623: ST_TO_ADDR
// end ; if GetSide ( build ) in ai then
25624: LD_VAR 0 1
25628: PPUSH
25629: CALL_OW 255
25633: PUSH
25634: LD_EXP 24
25638: IN
25639: IFFALSE 25650
// begin add_to_builds ( build ) ;
25641: LD_VAR 0 1
25645: PPUSH
25646: CALL 27208 0 1
// end ; end ;
25650: PPOPN 1
25652: END
// on VehicleConstructed ( veh , fact ) do begin if GetSide ( veh ) = you then
25653: LD_VAR 0 1
25657: PPUSH
25658: CALL_OW 255
25662: PUSH
25663: LD_EXP 7
25667: EQUAL
25668: IFFALSE 25686
// begin your_cars := your_cars union veh ;
25670: LD_ADDR_EXP 35
25674: PUSH
25675: LD_EXP 35
25679: PUSH
25680: LD_VAR 0 1
25684: UNION
25685: ST_TO_ADDR
// end ; if GetSide ( veh ) in ai then
25686: LD_VAR 0 1
25690: PPUSH
25691: CALL_OW 255
25695: PUSH
25696: LD_EXP 24
25700: IN
25701: IFFALSE 26050
// begin if GetControl ( veh ) = control_computer then
25703: LD_VAR 0 1
25707: PPUSH
25708: CALL_OW 263
25712: PUSH
25713: LD_INT 3
25715: EQUAL
25716: IFFALSE 25876
// case GetSide ( veh ) of ai_s [ 1 ] :
25718: LD_VAR 0 1
25722: PPUSH
25723: CALL_OW 255
25727: PUSH
25728: LD_EXP 23
25732: PUSH
25733: LD_INT 1
25735: ARRAY
25736: DOUBLE
25737: EQUAL
25738: IFTRUE 25742
25740: GO 25757
25742: POP
// ComMoveToArea ( veh , pro_attA ) ; ai_s [ 2 ] :
25743: LD_VAR 0 1
25747: PPUSH
25748: LD_INT 8
25750: PPUSH
25751: CALL_OW 113
25755: GO 25874
25757: LD_EXP 23
25761: PUSH
25762: LD_INT 2
25764: ARRAY
25765: DOUBLE
25766: EQUAL
25767: IFTRUE 25771
25769: GO 25786
25771: POP
// ComMoveToArea ( veh , pro_attB ) ; ai_s [ 3 ] :
25772: LD_VAR 0 1
25776: PPUSH
25777: LD_INT 10
25779: PPUSH
25780: CALL_OW 113
25784: GO 25874
25786: LD_EXP 23
25790: PUSH
25791: LD_INT 3
25793: ARRAY
25794: DOUBLE
25795: EQUAL
25796: IFTRUE 25800
25798: GO 25815
25800: POP
// ComMoveToArea ( veh , pro_attC ) ; ai_s [ 4 ] :
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 17
25808: PPUSH
25809: CALL_OW 113
25813: GO 25874
25815: LD_EXP 23
25819: PUSH
25820: LD_INT 4
25822: ARRAY
25823: DOUBLE
25824: EQUAL
25825: IFTRUE 25829
25827: GO 25844
25829: POP
// ComMoveToArea ( veh , pro_attD ) ; ai_s [ 5 ] :
25830: LD_VAR 0 1
25834: PPUSH
25835: LD_INT 15
25837: PPUSH
25838: CALL_OW 113
25842: GO 25874
25844: LD_EXP 23
25848: PUSH
25849: LD_INT 5
25851: ARRAY
25852: DOUBLE
25853: EQUAL
25854: IFTRUE 25858
25856: GO 25873
25858: POP
// ComMoveToArea ( veh , pro_attE ) ; end else
25859: LD_VAR 0 1
25863: PPUSH
25864: LD_INT 12
25866: PPUSH
25867: CALL_OW 113
25871: GO 25874
25873: POP
25874: GO 26032
// case GetSide ( veh ) of ai_s [ 1 ] :
25876: LD_VAR 0 1
25880: PPUSH
25881: CALL_OW 255
25885: PUSH
25886: LD_EXP 23
25890: PUSH
25891: LD_INT 1
25893: ARRAY
25894: DOUBLE
25895: EQUAL
25896: IFTRUE 25900
25898: GO 25915
25900: POP
// ComMoveToArea ( veh , pro_defA ) ; ai_s [ 2 ] :
25901: LD_VAR 0 1
25905: PPUSH
25906: LD_INT 9
25908: PPUSH
25909: CALL_OW 113
25913: GO 26032
25915: LD_EXP 23
25919: PUSH
25920: LD_INT 2
25922: ARRAY
25923: DOUBLE
25924: EQUAL
25925: IFTRUE 25929
25927: GO 25944
25929: POP
// ComMoveToArea ( veh , pro_defB ) ; ai_s [ 3 ] :
25930: LD_VAR 0 1
25934: PPUSH
25935: LD_INT 11
25937: PPUSH
25938: CALL_OW 113
25942: GO 26032
25944: LD_EXP 23
25948: PUSH
25949: LD_INT 3
25951: ARRAY
25952: DOUBLE
25953: EQUAL
25954: IFTRUE 25958
25956: GO 25973
25958: POP
// ComMoveToArea ( veh , pro_defC ) ; ai_s [ 4 ] :
25959: LD_VAR 0 1
25963: PPUSH
25964: LD_INT 16
25966: PPUSH
25967: CALL_OW 113
25971: GO 26032
25973: LD_EXP 23
25977: PUSH
25978: LD_INT 4
25980: ARRAY
25981: DOUBLE
25982: EQUAL
25983: IFTRUE 25987
25985: GO 26002
25987: POP
// ComMoveToArea ( veh , pro_defD ) ; ai_s [ 5 ] :
25988: LD_VAR 0 1
25992: PPUSH
25993: LD_INT 14
25995: PPUSH
25996: CALL_OW 113
26000: GO 26032
26002: LD_EXP 23
26006: PUSH
26007: LD_INT 5
26009: ARRAY
26010: DOUBLE
26011: EQUAL
26012: IFTRUE 26016
26014: GO 26031
26016: POP
// ComMoveToArea ( veh , pro_defE ) ; end ;
26017: LD_VAR 0 1
26021: PPUSH
26022: LD_INT 13
26024: PPUSH
26025: CALL_OW 113
26029: GO 26032
26031: POP
// AddComExitVehicle ( veh ) ;
26032: LD_VAR 0 1
26036: PPUSH
26037: CALL_OW 181
// add_to_vehicles ( veh ) ;
26041: LD_VAR 0 1
26045: PPUSH
26046: CALL 26863 0 1
// end ; end ;
26050: PPOPN 2
26052: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) = you then
26053: LD_VAR 0 1
26057: PPUSH
26058: CALL_OW 255
26062: PUSH
26063: LD_EXP 7
26067: EQUAL
26068: IFFALSE 26078
// maji_artifact := true ;
26070: LD_ADDR_EXP 39
26074: PUSH
26075: LD_INT 1
26077: ST_TO_ADDR
// art_cargo1 := un ;
26078: LD_ADDR_EXP 34
26082: PUSH
26083: LD_VAR 0 1
26087: ST_TO_ADDR
// end ;
26088: PPOPN 2
26090: END
// on ArtifactUnloaded ( un , size ) do begin if GetSide ( un ) = you then
26091: LD_VAR 0 1
26095: PPUSH
26096: CALL_OW 255
26100: PUSH
26101: LD_EXP 7
26105: EQUAL
26106: IFFALSE 26116
// maji_artifact := false ;
26108: LD_ADDR_EXP 39
26112: PUSH
26113: LD_INT 0
26115: ST_TO_ADDR
// art_cargo1 := 0 ;
26116: LD_ADDR_EXP 34
26120: PUSH
26121: LD_INT 0
26123: ST_TO_ADDR
// end ;
26124: PPOPN 2
26126: END
// on Command ( comm ) do begin if not Getside ( Eisenstein ) = you and IsInUnit ( Eisenstein ) then
26127: LD_EXP 49
26131: PPUSH
26132: CALL_OW 255
26136: PUSH
26137: LD_EXP 7
26141: EQUAL
26142: NOT
26143: PUSH
26144: LD_EXP 49
26148: PPUSH
26149: CALL_OW 310
26153: AND
26154: IFFALSE 26165
// RemoveTasks ( Eisenstein ) ;
26156: LD_EXP 49
26160: PPUSH
26161: CALL_OW 493
// if not Getside ( Davidov ) = you and IsInUnit ( Davidov ) then
26165: LD_EXP 48
26169: PPUSH
26170: CALL_OW 255
26174: PUSH
26175: LD_EXP 7
26179: EQUAL
26180: NOT
26181: PUSH
26182: LD_EXP 48
26186: PPUSH
26187: CALL_OW 310
26191: AND
26192: IFFALSE 26203
// RemoveTasks ( Davidov ) ;
26194: LD_EXP 48
26198: PPUSH
26199: CALL_OW 493
// if not Getside ( Tsaritsyn ) = you and IsInUnit ( Tsaritsyn ) then
26203: LD_EXP 47
26207: PPUSH
26208: CALL_OW 255
26212: PUSH
26213: LD_EXP 7
26217: EQUAL
26218: NOT
26219: PUSH
26220: LD_EXP 47
26224: PPUSH
26225: CALL_OW 310
26229: AND
26230: IFFALSE 26241
// RemoveTasks ( Tsaritsyn ) ;
26232: LD_EXP 47
26236: PPUSH
26237: CALL_OW 493
// if not Getside ( Borodin ) = you and IsInUnit ( Borodin ) then
26241: LD_EXP 46
26245: PPUSH
26246: CALL_OW 255
26250: PUSH
26251: LD_EXP 7
26255: EQUAL
26256: NOT
26257: PUSH
26258: LD_EXP 46
26262: PPUSH
26263: CALL_OW 310
26267: AND
26268: IFFALSE 26279
// RemoveTasks ( Borodin ) ;
26270: LD_EXP 46
26274: PPUSH
26275: CALL_OW 493
// end ;
26279: PPOPN 1
26281: END
// on McAttackDone ( mcid , surv ) do begin msg ( [ mcid , McAttackDone , surv ] ) ;
26282: LD_VAR 0 1
26286: PUSH
26287: LD_STRING McAttackDone
26289: PUSH
26290: LD_VAR 0 2
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: PPUSH
26300: CALL_OW 100
// end ;
26304: PPOPN 2
26306: END
// on McRegistryResultChanges ( mcid , count , strength ) do begin if mcid = BehMcRegId then
26307: LD_VAR 0 1
26311: PUSH
26312: LD_EXP 64
26316: EQUAL
26317: IFFALSE 26368
// debug_strings := replace ( debug_strings , 2 , [ mcid , count , strength , GetMcUnits ( BehMcAttId ) ] ) ;
26319: LD_ADDR_OWVAR 48
26323: PUSH
26324: LD_OWVAR 48
26328: PPUSH
26329: LD_INT 2
26331: PPUSH
26332: LD_VAR 0 1
26336: PUSH
26337: LD_VAR 0 2
26341: PUSH
26342: LD_VAR 0 3
26346: PUSH
26347: LD_EXP 65
26351: PPUSH
26352: CALL_OW 389
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: PPUSH
26363: CALL_OW 1
26367: ST_TO_ADDR
// end ;
26368: PPOPN 3
26370: END
// export function add_to ( un ) ; begin
26371: LD_INT 0
26373: PPUSH
// add_to_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
26374: LD_VAR 0 1
26378: PPUSH
26379: LD_INT 21
26381: PUSH
26382: LD_INT 1
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: EMPTY
26390: LIST
26391: PPUSH
26392: CALL_OW 72
26396: PPUSH
26397: CALL 26460 0 1
// add_to_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
26401: LD_VAR 0 1
26405: PPUSH
26406: LD_INT 21
26408: PUSH
26409: LD_INT 3
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: EMPTY
26417: LIST
26418: PPUSH
26419: CALL_OW 72
26423: PPUSH
26424: CALL 27208 0 1
// add_to_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
26428: LD_VAR 0 1
26432: PPUSH
26433: LD_INT 21
26435: PUSH
26436: LD_INT 2
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: EMPTY
26444: LIST
26445: PPUSH
26446: CALL_OW 72
26450: PPUSH
26451: CALL 26863 0 1
// end ;
26455: LD_VAR 0 2
26459: RET
// export function add_to_humans ( un ) ; var i ; begin
26460: LD_INT 0
26462: PPUSH
26463: PPUSH
// sol := sol union UnitFilter ( un , [ mf_sol ] ) ;
26464: LD_ADDR_EXP 82
26468: PUSH
26469: LD_EXP 82
26473: PUSH
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_EXP 51
26483: PUSH
26484: EMPTY
26485: LIST
26486: PPUSH
26487: CALL_OW 72
26491: UNION
26492: ST_TO_ADDR
// eng := eng union UnitFilter ( un , [ mf_eng ] ) ;
26493: LD_ADDR_EXP 84
26497: PUSH
26498: LD_EXP 84
26502: PUSH
26503: LD_VAR 0 1
26507: PPUSH
26508: LD_EXP 52
26512: PUSH
26513: EMPTY
26514: LIST
26515: PPUSH
26516: CALL_OW 72
26520: UNION
26521: ST_TO_ADDR
// mec := mec union UnitFilter ( un , [ mf_mec ] ) ;
26522: LD_ADDR_EXP 86
26526: PUSH
26527: LD_EXP 86
26531: PUSH
26532: LD_VAR 0 1
26536: PPUSH
26537: LD_EXP 53
26541: PUSH
26542: EMPTY
26543: LIST
26544: PPUSH
26545: CALL_OW 72
26549: UNION
26550: ST_TO_ADDR
// sci := sci union UnitFilter ( un , [ mf_sci ] ) ;
26551: LD_ADDR_EXP 88
26555: PUSH
26556: LD_EXP 88
26560: PUSH
26561: LD_VAR 0 1
26565: PPUSH
26566: LD_EXP 54
26570: PUSH
26571: EMPTY
26572: LIST
26573: PPUSH
26574: CALL_OW 72
26578: UNION
26579: ST_TO_ADDR
// for i in un do
26580: LD_ADDR_VAR 0 3
26584: PUSH
26585: LD_VAR 0 1
26589: PUSH
26590: FOR_IN
26591: IFFALSE 26856
// begin case GetSide ( i ) of ai_s [ 1 ] :
26593: LD_VAR 0 3
26597: PPUSH
26598: CALL_OW 255
26602: PUSH
26603: LD_EXP 23
26607: PUSH
26608: LD_INT 1
26610: ARRAY
26611: DOUBLE
26612: EQUAL
26613: IFTRUE 26617
26615: GO 26653
26617: POP
// humans := replace ( humans , 1 , humans [ 1 ] union i ) ; ai_s [ 2 ] :
26618: LD_ADDR_EXP 76
26622: PUSH
26623: LD_EXP 76
26627: PPUSH
26628: LD_INT 1
26630: PPUSH
26631: LD_EXP 76
26635: PUSH
26636: LD_INT 1
26638: ARRAY
26639: PUSH
26640: LD_VAR 0 3
26644: UNION
26645: PPUSH
26646: CALL_OW 1
26650: ST_TO_ADDR
26651: GO 26854
26653: LD_EXP 23
26657: PUSH
26658: LD_INT 2
26660: ARRAY
26661: DOUBLE
26662: EQUAL
26663: IFTRUE 26667
26665: GO 26703
26667: POP
// humans := replace ( humans , 2 , humans [ 2 ] union i ) ; ai_s [ 3 ] :
26668: LD_ADDR_EXP 76
26672: PUSH
26673: LD_EXP 76
26677: PPUSH
26678: LD_INT 2
26680: PPUSH
26681: LD_EXP 76
26685: PUSH
26686: LD_INT 2
26688: ARRAY
26689: PUSH
26690: LD_VAR 0 3
26694: UNION
26695: PPUSH
26696: CALL_OW 1
26700: ST_TO_ADDR
26701: GO 26854
26703: LD_EXP 23
26707: PUSH
26708: LD_INT 3
26710: ARRAY
26711: DOUBLE
26712: EQUAL
26713: IFTRUE 26717
26715: GO 26753
26717: POP
// humans := replace ( humans , 3 , humans [ 3 ] union i ) ; ai_s [ 4 ] :
26718: LD_ADDR_EXP 76
26722: PUSH
26723: LD_EXP 76
26727: PPUSH
26728: LD_INT 3
26730: PPUSH
26731: LD_EXP 76
26735: PUSH
26736: LD_INT 3
26738: ARRAY
26739: PUSH
26740: LD_VAR 0 3
26744: UNION
26745: PPUSH
26746: CALL_OW 1
26750: ST_TO_ADDR
26751: GO 26854
26753: LD_EXP 23
26757: PUSH
26758: LD_INT 4
26760: ARRAY
26761: DOUBLE
26762: EQUAL
26763: IFTRUE 26767
26765: GO 26803
26767: POP
// humans := replace ( humans , 4 , humans [ 4 ] union i ) ; ai_s [ 5 ] :
26768: LD_ADDR_EXP 76
26772: PUSH
26773: LD_EXP 76
26777: PPUSH
26778: LD_INT 4
26780: PPUSH
26781: LD_EXP 76
26785: PUSH
26786: LD_INT 4
26788: ARRAY
26789: PUSH
26790: LD_VAR 0 3
26794: UNION
26795: PPUSH
26796: CALL_OW 1
26800: ST_TO_ADDR
26801: GO 26854
26803: LD_EXP 23
26807: PUSH
26808: LD_INT 5
26810: ARRAY
26811: DOUBLE
26812: EQUAL
26813: IFTRUE 26817
26815: GO 26853
26817: POP
// humans := replace ( humans , 5 , humans [ 5 ] union i ) ; end ;
26818: LD_ADDR_EXP 76
26822: PUSH
26823: LD_EXP 76
26827: PPUSH
26828: LD_INT 5
26830: PPUSH
26831: LD_EXP 76
26835: PUSH
26836: LD_INT 5
26838: ARRAY
26839: PUSH
26840: LD_VAR 0 3
26844: UNION
26845: PPUSH
26846: CALL_OW 1
26850: ST_TO_ADDR
26851: GO 26854
26853: POP
// end ;
26854: GO 26590
26856: POP
26857: POP
// end ;
26858: LD_VAR 0 2
26862: RET
// export function add_to_vehicles ( un ) ; var i ; begin
26863: LD_INT 0
26865: PPUSH
26866: PPUSH
// attack_units := attack_units union UnitFilter ( un , [ mf_comp ] ) ;
26867: LD_ADDR_EXP 78
26871: PUSH
26872: LD_EXP 78
26876: PUSH
26877: LD_VAR 0 1
26881: PPUSH
26882: LD_EXP 60
26886: PUSH
26887: EMPTY
26888: LIST
26889: PPUSH
26890: CALL_OW 72
26894: UNION
26895: ST_TO_ADDR
// defence_units := defence_units union UnitFilter ( un , [ mf_manu ] ) ;
26896: LD_ADDR_EXP 79
26900: PUSH
26901: LD_EXP 79
26905: PUSH
26906: LD_VAR 0 1
26910: PPUSH
26911: LD_EXP 61
26915: PUSH
26916: EMPTY
26917: LIST
26918: PPUSH
26919: CALL_OW 72
26923: UNION
26924: ST_TO_ADDR
// for i in un do
26925: LD_ADDR_VAR 0 3
26929: PUSH
26930: LD_VAR 0 1
26934: PUSH
26935: FOR_IN
26936: IFFALSE 27201
// begin case getside ( i ) of ai_s [ 1 ] :
26938: LD_VAR 0 3
26942: PPUSH
26943: CALL_OW 255
26947: PUSH
26948: LD_EXP 23
26952: PUSH
26953: LD_INT 1
26955: ARRAY
26956: DOUBLE
26957: EQUAL
26958: IFTRUE 26962
26960: GO 26998
26962: POP
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] union i ) ; ai_s [ 2 ] :
26963: LD_ADDR_EXP 77
26967: PUSH
26968: LD_EXP 77
26972: PPUSH
26973: LD_INT 1
26975: PPUSH
26976: LD_EXP 77
26980: PUSH
26981: LD_INT 1
26983: ARRAY
26984: PUSH
26985: LD_VAR 0 3
26989: UNION
26990: PPUSH
26991: CALL_OW 1
26995: ST_TO_ADDR
26996: GO 27199
26998: LD_EXP 23
27002: PUSH
27003: LD_INT 2
27005: ARRAY
27006: DOUBLE
27007: EQUAL
27008: IFTRUE 27012
27010: GO 27048
27012: POP
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] union i ) ; ai_s [ 3 ] :
27013: LD_ADDR_EXP 77
27017: PUSH
27018: LD_EXP 77
27022: PPUSH
27023: LD_INT 2
27025: PPUSH
27026: LD_EXP 77
27030: PUSH
27031: LD_INT 2
27033: ARRAY
27034: PUSH
27035: LD_VAR 0 3
27039: UNION
27040: PPUSH
27041: CALL_OW 1
27045: ST_TO_ADDR
27046: GO 27199
27048: LD_EXP 23
27052: PUSH
27053: LD_INT 3
27055: ARRAY
27056: DOUBLE
27057: EQUAL
27058: IFTRUE 27062
27060: GO 27098
27062: POP
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] union i ) ; ai_s [ 4 ] :
27063: LD_ADDR_EXP 77
27067: PUSH
27068: LD_EXP 77
27072: PPUSH
27073: LD_INT 3
27075: PPUSH
27076: LD_EXP 77
27080: PUSH
27081: LD_INT 3
27083: ARRAY
27084: PUSH
27085: LD_VAR 0 3
27089: UNION
27090: PPUSH
27091: CALL_OW 1
27095: ST_TO_ADDR
27096: GO 27199
27098: LD_EXP 23
27102: PUSH
27103: LD_INT 4
27105: ARRAY
27106: DOUBLE
27107: EQUAL
27108: IFTRUE 27112
27110: GO 27148
27112: POP
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] union i ) ; ai_s [ 5 ] :
27113: LD_ADDR_EXP 77
27117: PUSH
27118: LD_EXP 77
27122: PPUSH
27123: LD_INT 4
27125: PPUSH
27126: LD_EXP 77
27130: PUSH
27131: LD_INT 4
27133: ARRAY
27134: PUSH
27135: LD_VAR 0 3
27139: UNION
27140: PPUSH
27141: CALL_OW 1
27145: ST_TO_ADDR
27146: GO 27199
27148: LD_EXP 23
27152: PUSH
27153: LD_INT 5
27155: ARRAY
27156: DOUBLE
27157: EQUAL
27158: IFTRUE 27162
27160: GO 27198
27162: POP
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] union i ) ; end ;
27163: LD_ADDR_EXP 77
27167: PUSH
27168: LD_EXP 77
27172: PPUSH
27173: LD_INT 5
27175: PPUSH
27176: LD_EXP 77
27180: PUSH
27181: LD_INT 5
27183: ARRAY
27184: PUSH
27185: LD_VAR 0 3
27189: UNION
27190: PPUSH
27191: CALL_OW 1
27195: ST_TO_ADDR
27196: GO 27199
27198: POP
// end ;
27199: GO 26935
27201: POP
27202: POP
// end ;
27203: LD_VAR 0 2
27207: RET
// export function add_to_builds ( un ) ; var i , j , bt ; begin
27208: LD_INT 0
27210: PPUSH
27211: PPUSH
27212: PPUSH
27213: PPUSH
// fort := fort union UnitFilter ( un , [ mf_fort ] ) ;
27214: LD_ADDR_EXP 81
27218: PUSH
27219: LD_EXP 81
27223: PUSH
27224: LD_VAR 0 1
27228: PPUSH
27229: LD_EXP 56
27233: PUSH
27234: EMPTY
27235: LIST
27236: PPUSH
27237: CALL_OW 72
27241: UNION
27242: ST_TO_ADDR
// dep := dep union UnitFilter ( un , [ mf_dep ] ) ;
27243: LD_ADDR_EXP 83
27247: PUSH
27248: LD_EXP 83
27252: PUSH
27253: LD_VAR 0 1
27257: PPUSH
27258: LD_EXP 58
27262: PUSH
27263: EMPTY
27264: LIST
27265: PPUSH
27266: CALL_OW 72
27270: UNION
27271: ST_TO_ADDR
// fact := fact union UnitFilter ( un , [ mf_fact ] ) ;
27272: LD_ADDR_EXP 85
27276: PUSH
27277: LD_EXP 85
27281: PUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: LD_EXP 59
27291: PUSH
27292: EMPTY
27293: LIST
27294: PPUSH
27295: CALL_OW 72
27299: UNION
27300: ST_TO_ADDR
// lab := lab union UnitFilter ( un , [ mf_lab ] ) ;
27301: LD_ADDR_EXP 87
27305: PUSH
27306: LD_EXP 87
27310: PUSH
27311: LD_VAR 0 1
27315: PPUSH
27316: LD_EXP 55
27320: PUSH
27321: EMPTY
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: UNION
27329: ST_TO_ADDR
// for i in un do
27330: LD_ADDR_VAR 0 3
27334: PUSH
27335: LD_VAR 0 1
27339: PUSH
27340: FOR_IN
27341: IFFALSE 27606
// begin case GetSide ( i ) of ai_s [ 1 ] :
27343: LD_VAR 0 3
27347: PPUSH
27348: CALL_OW 255
27352: PUSH
27353: LD_EXP 23
27357: PUSH
27358: LD_INT 1
27360: ARRAY
27361: DOUBLE
27362: EQUAL
27363: IFTRUE 27367
27365: GO 27403
27367: POP
// buildings := replace ( buildings , 1 , buildings [ 1 ] union i ) ; ai_s [ 2 ] :
27368: LD_ADDR_EXP 75
27372: PUSH
27373: LD_EXP 75
27377: PPUSH
27378: LD_INT 1
27380: PPUSH
27381: LD_EXP 75
27385: PUSH
27386: LD_INT 1
27388: ARRAY
27389: PUSH
27390: LD_VAR 0 3
27394: UNION
27395: PPUSH
27396: CALL_OW 1
27400: ST_TO_ADDR
27401: GO 27604
27403: LD_EXP 23
27407: PUSH
27408: LD_INT 2
27410: ARRAY
27411: DOUBLE
27412: EQUAL
27413: IFTRUE 27417
27415: GO 27453
27417: POP
// buildings := replace ( buildings , 2 , buildings [ 2 ] union i ) ; ai_s [ 3 ] :
27418: LD_ADDR_EXP 75
27422: PUSH
27423: LD_EXP 75
27427: PPUSH
27428: LD_INT 2
27430: PPUSH
27431: LD_EXP 75
27435: PUSH
27436: LD_INT 2
27438: ARRAY
27439: PUSH
27440: LD_VAR 0 3
27444: UNION
27445: PPUSH
27446: CALL_OW 1
27450: ST_TO_ADDR
27451: GO 27604
27453: LD_EXP 23
27457: PUSH
27458: LD_INT 3
27460: ARRAY
27461: DOUBLE
27462: EQUAL
27463: IFTRUE 27467
27465: GO 27503
27467: POP
// buildings := replace ( buildings , 3 , buildings [ 3 ] union i ) ; ai_s [ 4 ] :
27468: LD_ADDR_EXP 75
27472: PUSH
27473: LD_EXP 75
27477: PPUSH
27478: LD_INT 3
27480: PPUSH
27481: LD_EXP 75
27485: PUSH
27486: LD_INT 3
27488: ARRAY
27489: PUSH
27490: LD_VAR 0 3
27494: UNION
27495: PPUSH
27496: CALL_OW 1
27500: ST_TO_ADDR
27501: GO 27604
27503: LD_EXP 23
27507: PUSH
27508: LD_INT 4
27510: ARRAY
27511: DOUBLE
27512: EQUAL
27513: IFTRUE 27517
27515: GO 27553
27517: POP
// buildings := replace ( buildings , 4 , buildings [ 4 ] union i ) ; ai_s [ 5 ] :
27518: LD_ADDR_EXP 75
27522: PUSH
27523: LD_EXP 75
27527: PPUSH
27528: LD_INT 4
27530: PPUSH
27531: LD_EXP 75
27535: PUSH
27536: LD_INT 4
27538: ARRAY
27539: PUSH
27540: LD_VAR 0 3
27544: UNION
27545: PPUSH
27546: CALL_OW 1
27550: ST_TO_ADDR
27551: GO 27604
27553: LD_EXP 23
27557: PUSH
27558: LD_INT 5
27560: ARRAY
27561: DOUBLE
27562: EQUAL
27563: IFTRUE 27567
27565: GO 27603
27567: POP
// buildings := replace ( buildings , 5 , buildings [ 5 ] union i ) ; end ;
27568: LD_ADDR_EXP 75
27572: PUSH
27573: LD_EXP 75
27577: PPUSH
27578: LD_INT 5
27580: PPUSH
27581: LD_EXP 75
27585: PUSH
27586: LD_INT 5
27588: ARRAY
27589: PUSH
27590: LD_VAR 0 3
27594: UNION
27595: PPUSH
27596: CALL_OW 1
27600: ST_TO_ADDR
27601: GO 27604
27603: POP
// end ;
27604: GO 27340
27606: POP
27607: POP
// write_deps ;
27608: CALL 23328 0 0
// write_facts ;
27612: CALL 23447 0 0
// end ;
27616: LD_VAR 0 2
27620: RET
// export function remove_from ( un ) ; begin
27621: LD_INT 0
27623: PPUSH
// remove_from_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
27624: LD_VAR 0 1
27628: PPUSH
27629: LD_INT 21
27631: PUSH
27632: LD_INT 1
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: EMPTY
27640: LIST
27641: PPUSH
27642: CALL_OW 72
27646: PPUSH
27647: CALL 27956 0 1
// remove_from_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
27651: LD_VAR 0 1
27655: PPUSH
27656: LD_INT 21
27658: PUSH
27659: LD_INT 3
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: EMPTY
27667: LIST
27668: PPUSH
27669: CALL_OW 72
27673: PPUSH
27674: CALL 27710 0 1
// remove_from_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
27678: LD_VAR 0 1
27682: PPUSH
27683: LD_INT 21
27685: PUSH
27686: LD_INT 2
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: PUSH
27693: EMPTY
27694: LIST
27695: PPUSH
27696: CALL_OW 72
27700: PPUSH
27701: CALL 28194 0 1
// end ;
27705: LD_VAR 0 2
27709: RET
// export function remove_from_builds ( un ) ; var i ; begin
27710: LD_INT 0
27712: PPUSH
27713: PPUSH
// fact := fact diff un ;
27714: LD_ADDR_EXP 85
27718: PUSH
27719: LD_EXP 85
27723: PUSH
27724: LD_VAR 0 1
27728: DIFF
27729: ST_TO_ADDR
// fort := fort diff un ;
27730: LD_ADDR_EXP 81
27734: PUSH
27735: LD_EXP 81
27739: PUSH
27740: LD_VAR 0 1
27744: DIFF
27745: ST_TO_ADDR
// lab := lab diff un ;
27746: LD_ADDR_EXP 87
27750: PUSH
27751: LD_EXP 87
27755: PUSH
27756: LD_VAR 0 1
27760: DIFF
27761: ST_TO_ADDR
// dep := dep diff un ;
27762: LD_ADDR_EXP 83
27766: PUSH
27767: LD_EXP 83
27771: PUSH
27772: LD_VAR 0 1
27776: DIFF
27777: ST_TO_ADDR
// buildings := replace ( buildings , 1 , buildings [ 1 ] diff un ) ;
27778: LD_ADDR_EXP 75
27782: PUSH
27783: LD_EXP 75
27787: PPUSH
27788: LD_INT 1
27790: PPUSH
27791: LD_EXP 75
27795: PUSH
27796: LD_INT 1
27798: ARRAY
27799: PUSH
27800: LD_VAR 0 1
27804: DIFF
27805: PPUSH
27806: CALL_OW 1
27810: ST_TO_ADDR
// buildings := replace ( buildings , 2 , buildings [ 2 ] diff un ) ;
27811: LD_ADDR_EXP 75
27815: PUSH
27816: LD_EXP 75
27820: PPUSH
27821: LD_INT 2
27823: PPUSH
27824: LD_EXP 75
27828: PUSH
27829: LD_INT 2
27831: ARRAY
27832: PUSH
27833: LD_VAR 0 1
27837: DIFF
27838: PPUSH
27839: CALL_OW 1
27843: ST_TO_ADDR
// buildings := replace ( buildings , 3 , buildings [ 3 ] diff un ) ;
27844: LD_ADDR_EXP 75
27848: PUSH
27849: LD_EXP 75
27853: PPUSH
27854: LD_INT 3
27856: PPUSH
27857: LD_EXP 75
27861: PUSH
27862: LD_INT 3
27864: ARRAY
27865: PUSH
27866: LD_VAR 0 1
27870: DIFF
27871: PPUSH
27872: CALL_OW 1
27876: ST_TO_ADDR
// buildings := replace ( buildings , 4 , buildings [ 4 ] diff un ) ;
27877: LD_ADDR_EXP 75
27881: PUSH
27882: LD_EXP 75
27886: PPUSH
27887: LD_INT 4
27889: PPUSH
27890: LD_EXP 75
27894: PUSH
27895: LD_INT 4
27897: ARRAY
27898: PUSH
27899: LD_VAR 0 1
27903: DIFF
27904: PPUSH
27905: CALL_OW 1
27909: ST_TO_ADDR
// buildings := replace ( buildings , 5 , buildings [ 5 ] diff un ) ;
27910: LD_ADDR_EXP 75
27914: PUSH
27915: LD_EXP 75
27919: PPUSH
27920: LD_INT 5
27922: PPUSH
27923: LD_EXP 75
27927: PUSH
27928: LD_INT 5
27930: ARRAY
27931: PUSH
27932: LD_VAR 0 1
27936: DIFF
27937: PPUSH
27938: CALL_OW 1
27942: ST_TO_ADDR
// write_deps ;
27943: CALL 23328 0 0
// write_facts ;
27947: CALL 23447 0 0
// end ;
27951: LD_VAR 0 2
27955: RET
// export function remove_from_humans ( un ) ; var i ; begin
27956: LD_INT 0
27958: PPUSH
27959: PPUSH
// sol := sol diff un ;
27960: LD_ADDR_EXP 82
27964: PUSH
27965: LD_EXP 82
27969: PUSH
27970: LD_VAR 0 1
27974: DIFF
27975: ST_TO_ADDR
// eng := eng diff un ;
27976: LD_ADDR_EXP 84
27980: PUSH
27981: LD_EXP 84
27985: PUSH
27986: LD_VAR 0 1
27990: DIFF
27991: ST_TO_ADDR
// mec := mec diff un ;
27992: LD_ADDR_EXP 86
27996: PUSH
27997: LD_EXP 86
28001: PUSH
28002: LD_VAR 0 1
28006: DIFF
28007: ST_TO_ADDR
// sci := sci diff un ;
28008: LD_ADDR_EXP 88
28012: PUSH
28013: LD_EXP 88
28017: PUSH
28018: LD_VAR 0 1
28022: DIFF
28023: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff un ) ;
28024: LD_ADDR_EXP 76
28028: PUSH
28029: LD_EXP 76
28033: PPUSH
28034: LD_INT 1
28036: PPUSH
28037: LD_EXP 76
28041: PUSH
28042: LD_INT 1
28044: ARRAY
28045: PUSH
28046: LD_VAR 0 1
28050: DIFF
28051: PPUSH
28052: CALL_OW 1
28056: ST_TO_ADDR
// humans := replace ( humans , 2 , humans [ 2 ] diff un ) ;
28057: LD_ADDR_EXP 76
28061: PUSH
28062: LD_EXP 76
28066: PPUSH
28067: LD_INT 2
28069: PPUSH
28070: LD_EXP 76
28074: PUSH
28075: LD_INT 2
28077: ARRAY
28078: PUSH
28079: LD_VAR 0 1
28083: DIFF
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// humans := replace ( humans , 3 , humans [ 3 ] diff un ) ;
28090: LD_ADDR_EXP 76
28094: PUSH
28095: LD_EXP 76
28099: PPUSH
28100: LD_INT 3
28102: PPUSH
28103: LD_EXP 76
28107: PUSH
28108: LD_INT 3
28110: ARRAY
28111: PUSH
28112: LD_VAR 0 1
28116: DIFF
28117: PPUSH
28118: CALL_OW 1
28122: ST_TO_ADDR
// humans := replace ( humans , 4 , humans [ 4 ] diff un ) ;
28123: LD_ADDR_EXP 76
28127: PUSH
28128: LD_EXP 76
28132: PPUSH
28133: LD_INT 4
28135: PPUSH
28136: LD_EXP 76
28140: PUSH
28141: LD_INT 4
28143: ARRAY
28144: PUSH
28145: LD_VAR 0 1
28149: DIFF
28150: PPUSH
28151: CALL_OW 1
28155: ST_TO_ADDR
// humans := replace ( humans , 5 , humans [ 5 ] diff un ) ;
28156: LD_ADDR_EXP 76
28160: PUSH
28161: LD_EXP 76
28165: PPUSH
28166: LD_INT 5
28168: PPUSH
28169: LD_EXP 76
28173: PUSH
28174: LD_INT 5
28176: ARRAY
28177: PUSH
28178: LD_VAR 0 1
28182: DIFF
28183: PPUSH
28184: CALL_OW 1
28188: ST_TO_ADDR
// end ;
28189: LD_VAR 0 2
28193: RET
// export function remove_from_vehicles ( un ) ; var i ; begin
28194: LD_INT 0
28196: PPUSH
28197: PPUSH
// attack_units := attack_units diff un ;
28198: LD_ADDR_EXP 78
28202: PUSH
28203: LD_EXP 78
28207: PUSH
28208: LD_VAR 0 1
28212: DIFF
28213: ST_TO_ADDR
// defence_units := defence_units diff un ;
28214: LD_ADDR_EXP 79
28218: PUSH
28219: LD_EXP 79
28223: PUSH
28224: LD_VAR 0 1
28228: DIFF
28229: ST_TO_ADDR
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] diff un ) ;
28230: LD_ADDR_EXP 77
28234: PUSH
28235: LD_EXP 77
28239: PPUSH
28240: LD_INT 1
28242: PPUSH
28243: LD_EXP 77
28247: PUSH
28248: LD_INT 1
28250: ARRAY
28251: PUSH
28252: LD_VAR 0 1
28256: DIFF
28257: PPUSH
28258: CALL_OW 1
28262: ST_TO_ADDR
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] diff un ) ;
28263: LD_ADDR_EXP 77
28267: PUSH
28268: LD_EXP 77
28272: PPUSH
28273: LD_INT 2
28275: PPUSH
28276: LD_EXP 77
28280: PUSH
28281: LD_INT 2
28283: ARRAY
28284: PUSH
28285: LD_VAR 0 1
28289: DIFF
28290: PPUSH
28291: CALL_OW 1
28295: ST_TO_ADDR
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] diff un ) ;
28296: LD_ADDR_EXP 77
28300: PUSH
28301: LD_EXP 77
28305: PPUSH
28306: LD_INT 3
28308: PPUSH
28309: LD_EXP 77
28313: PUSH
28314: LD_INT 3
28316: ARRAY
28317: PUSH
28318: LD_VAR 0 1
28322: DIFF
28323: PPUSH
28324: CALL_OW 1
28328: ST_TO_ADDR
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] diff un ) ;
28329: LD_ADDR_EXP 77
28333: PUSH
28334: LD_EXP 77
28338: PPUSH
28339: LD_INT 4
28341: PPUSH
28342: LD_EXP 77
28346: PUSH
28347: LD_INT 4
28349: ARRAY
28350: PUSH
28351: LD_VAR 0 1
28355: DIFF
28356: PPUSH
28357: CALL_OW 1
28361: ST_TO_ADDR
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] diff un ) ;
28362: LD_ADDR_EXP 77
28366: PUSH
28367: LD_EXP 77
28371: PPUSH
28372: LD_INT 5
28374: PPUSH
28375: LD_EXP 77
28379: PUSH
28380: LD_INT 5
28382: ARRAY
28383: PUSH
28384: LD_VAR 0 1
28388: DIFF
28389: PPUSH
28390: CALL_OW 1
28394: ST_TO_ADDR
// bc := replace ( bc , 1 , bc [ 1 ] diff un ) ;
28395: LD_ADDR_EXP 71
28399: PUSH
28400: LD_EXP 71
28404: PPUSH
28405: LD_INT 1
28407: PPUSH
28408: LD_EXP 71
28412: PUSH
28413: LD_INT 1
28415: ARRAY
28416: PUSH
28417: LD_VAR 0 1
28421: DIFF
28422: PPUSH
28423: CALL_OW 1
28427: ST_TO_ADDR
// bc := replace ( bc , 2 , bc [ 2 ] diff un ) ;
28428: LD_ADDR_EXP 71
28432: PUSH
28433: LD_EXP 71
28437: PPUSH
28438: LD_INT 2
28440: PPUSH
28441: LD_EXP 71
28445: PUSH
28446: LD_INT 2
28448: ARRAY
28449: PUSH
28450: LD_VAR 0 1
28454: DIFF
28455: PPUSH
28456: CALL_OW 1
28460: ST_TO_ADDR
// bc := replace ( bc , 3 , bc [ 3 ] diff un ) ;
28461: LD_ADDR_EXP 71
28465: PUSH
28466: LD_EXP 71
28470: PPUSH
28471: LD_INT 3
28473: PPUSH
28474: LD_EXP 71
28478: PUSH
28479: LD_INT 3
28481: ARRAY
28482: PUSH
28483: LD_VAR 0 1
28487: DIFF
28488: PPUSH
28489: CALL_OW 1
28493: ST_TO_ADDR
// bc := replace ( bc , 4 , bc [ 4 ] diff un ) ;
28494: LD_ADDR_EXP 71
28498: PUSH
28499: LD_EXP 71
28503: PPUSH
28504: LD_INT 4
28506: PPUSH
28507: LD_EXP 71
28511: PUSH
28512: LD_INT 4
28514: ARRAY
28515: PUSH
28516: LD_VAR 0 1
28520: DIFF
28521: PPUSH
28522: CALL_OW 1
28526: ST_TO_ADDR
// bc := replace ( bc , 5 , bc [ 5 ] diff un ) ;
28527: LD_ADDR_EXP 71
28531: PUSH
28532: LD_EXP 71
28536: PPUSH
28537: LD_INT 5
28539: PPUSH
28540: LD_EXP 71
28544: PUSH
28545: LD_INT 5
28547: ARRAY
28548: PUSH
28549: LD_VAR 0 1
28553: DIFF
28554: PPUSH
28555: CALL_OW 1
28559: ST_TO_ADDR
// rc := replace ( rc , 1 , rc [ 1 ] diff un ) ;
28560: LD_ADDR_EXP 70
28564: PUSH
28565: LD_EXP 70
28569: PPUSH
28570: LD_INT 1
28572: PPUSH
28573: LD_EXP 70
28577: PUSH
28578: LD_INT 1
28580: ARRAY
28581: PUSH
28582: LD_VAR 0 1
28586: DIFF
28587: PPUSH
28588: CALL_OW 1
28592: ST_TO_ADDR
// rc := replace ( rc , 2 , rc [ 2 ] diff un ) ;
28593: LD_ADDR_EXP 70
28597: PUSH
28598: LD_EXP 70
28602: PPUSH
28603: LD_INT 2
28605: PPUSH
28606: LD_EXP 70
28610: PUSH
28611: LD_INT 2
28613: ARRAY
28614: PUSH
28615: LD_VAR 0 1
28619: DIFF
28620: PPUSH
28621: CALL_OW 1
28625: ST_TO_ADDR
// rc := replace ( rc , 3 , rc [ 3 ] diff un ) ;
28626: LD_ADDR_EXP 70
28630: PUSH
28631: LD_EXP 70
28635: PPUSH
28636: LD_INT 3
28638: PPUSH
28639: LD_EXP 70
28643: PUSH
28644: LD_INT 3
28646: ARRAY
28647: PUSH
28648: LD_VAR 0 1
28652: DIFF
28653: PPUSH
28654: CALL_OW 1
28658: ST_TO_ADDR
// rc := replace ( rc , 4 , rc [ 4 ] diff un ) ;
28659: LD_ADDR_EXP 70
28663: PUSH
28664: LD_EXP 70
28668: PPUSH
28669: LD_INT 4
28671: PPUSH
28672: LD_EXP 70
28676: PUSH
28677: LD_INT 4
28679: ARRAY
28680: PUSH
28681: LD_VAR 0 1
28685: DIFF
28686: PPUSH
28687: CALL_OW 1
28691: ST_TO_ADDR
// rc := replace ( rc , 5 , rc [ 5 ] diff un ) ;
28692: LD_ADDR_EXP 70
28696: PUSH
28697: LD_EXP 70
28701: PPUSH
28702: LD_INT 5
28704: PPUSH
28705: LD_EXP 70
28709: PUSH
28710: LD_INT 5
28712: ARRAY
28713: PUSH
28714: LD_VAR 0 1
28718: DIFF
28719: PPUSH
28720: CALL_OW 1
28724: ST_TO_ADDR
// end ; end_of_file
28725: LD_VAR 0 2
28729: RET
// var objevovani_zasilek ; every 1 do
28730: GO 28732
28732: DISABLE
// begin objevovani_zasilek := [ 2 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 ] ;
28733: LD_ADDR_LOC 30
28737: PUSH
28738: LD_INT 2
28740: PUSH
28741: LD_INT 3
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 5
28749: PUSH
28750: LD_INT 1
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: LD_INT 4
28758: PUSH
28759: LD_INT 1
28761: PUSH
28762: LD_INT 0
28764: PUSH
28765: LD_INT 3
28767: PUSH
28768: LD_INT 3
28770: PUSH
28771: LD_INT 1
28773: PUSH
28774: LD_INT 5
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: LD_INT 1
28782: PUSH
28783: LD_INT 4
28785: PUSH
28786: LD_INT 1
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: LD_INT 3
28794: PUSH
28795: LD_INT 3
28797: PUSH
28798: LD_INT 1
28800: PUSH
28801: LD_INT 5
28803: PUSH
28804: LD_INT 1
28806: PUSH
28807: LD_INT 1
28809: PUSH
28810: LD_INT 4
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: LD_INT 0
28818: PUSH
28819: LD_INT 3
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: LIST
28839: LIST
28840: LIST
28841: LIST
28842: LIST
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: ST_TO_ADDR
// Randomize ;
28852: CALL_OW 10
// end ;
28856: END
// every 5 5$0 do
28857: GO 28859
28859: DISABLE
// begin Randomize ;
28860: CALL_OW 10
// enable ;
28864: ENABLE
// end ;
28865: END
// every 0 0$15 do
28866: GO 28868
28868: DISABLE
// begin padaji_bedny ;
28869: CALL 28883 0 0
// end ;
28873: END
// every 5 5$0 + 0 0$15 do
28874: GO 28876
28876: DISABLE
// begin padaji_bedny ;
28877: CALL 28883 0 0
// enable ;
28881: ENABLE
// end ;
28882: END
// function padaji_bedny ; var x , i , cek , cek2 , last , min5 ; begin
28883: LD_INT 0
28885: PPUSH
28886: PPUSH
28887: PPUSH
28888: PPUSH
28889: PPUSH
28890: PPUSH
28891: PPUSH
// min5 := ( ( tick div 5 5$0 ) + 1 ) mod objevovani_zasilek ;
28892: LD_ADDR_VAR 0 7
28896: PUSH
28897: LD_OWVAR 1
28901: PUSH
28902: LD_INT 10500
28904: DIV
28905: PUSH
28906: LD_INT 1
28908: PLUS
28909: PUSH
28910: LD_LOC 30
28914: MOD
28915: ST_TO_ADDR
// cek := [ ] ;
28916: LD_ADDR_VAR 0 4
28920: PUSH
28921: EMPTY
28922: ST_TO_ADDR
// cek2 := [ ] ;
28923: LD_ADDR_VAR 0 5
28927: PUSH
28928: EMPTY
28929: ST_TO_ADDR
// last := 0 ;
28930: LD_ADDR_VAR 0 6
28934: PUSH
28935: LD_INT 0
28937: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
28938: LD_ADDR_VAR 0 2
28942: PUSH
28943: LD_LOC 30
28947: PUSH
28948: LD_VAR 0 7
28952: ARRAY
28953: ST_TO_ADDR
// for i := 1 to x do
28954: LD_ADDR_VAR 0 3
28958: PUSH
28959: DOUBLE
28960: LD_INT 1
28962: DEC
28963: ST_TO_ADDR
28964: LD_VAR 0 2
28968: PUSH
28969: FOR_TO
28970: IFFALSE 28996
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
28972: LD_ADDR_VAR 0 4
28976: PUSH
28977: LD_VAR 0 4
28981: PUSH
28982: LD_INT 525
28984: PPUSH
28985: LD_INT 10500
28987: PPUSH
28988: CALL_OW 12
28992: ADD
28993: ST_TO_ADDR
28994: GO 28969
28996: POP
28997: POP
// cek := SortListByListAsc ( cek , cek ) ;
28998: LD_ADDR_VAR 0 4
29002: PUSH
29003: LD_VAR 0 4
29007: PPUSH
29008: LD_VAR 0 4
29012: PPUSH
29013: CALL_OW 76
29017: ST_TO_ADDR
// for i in cek do
29018: LD_ADDR_VAR 0 3
29022: PUSH
29023: LD_VAR 0 4
29027: PUSH
29028: FOR_IN
29029: IFFALSE 29065
// begin cek2 := cek2 ^ i - last ;
29031: LD_ADDR_VAR 0 5
29035: PUSH
29036: LD_VAR 0 5
29040: PUSH
29041: LD_VAR 0 3
29045: PUSH
29046: LD_VAR 0 6
29050: MINUS
29051: ADD
29052: ST_TO_ADDR
// last := i ;
29053: LD_ADDR_VAR 0 6
29057: PUSH
29058: LD_VAR 0 3
29062: ST_TO_ADDR
// end ;
29063: GO 29028
29065: POP
29066: POP
// for i := 1 to x do
29067: LD_ADDR_VAR 0 3
29071: PUSH
29072: DOUBLE
29073: LD_INT 1
29075: DEC
29076: ST_TO_ADDR
29077: LD_VAR 0 2
29081: PUSH
29082: FOR_TO
29083: IFFALSE 29112
// begin CreateCratesAnywhere ( 5 , true ) ;
29085: LD_INT 5
29087: PPUSH
29088: LD_INT 1
29090: PPUSH
29091: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
29095: LD_VAR 0 5
29099: PUSH
29100: LD_VAR 0 3
29104: ARRAY
29105: PPUSH
29106: CALL_OW 67
// end ;
29110: GO 29082
29112: POP
29113: POP
// end ; end_of_file
29114: LD_VAR 0 1
29118: RET
// var rDef1 , rDef2 , rDef3 , rDef4 , rDef5 ; var idDef1 , idDef2 , idDef3 , idDef4 , idDef5 ; export toDef1 , toDef2 , toDef3 , toDef4 , toDef5 ; every 0 0$1 do
29119: GO 29121
29121: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29122: LD_ADDR_EXP 89
29126: PUSH
29127: LD_EXP 76
29131: PUSH
29132: LD_INT 1
29134: ARRAY
29135: PPUSH
29136: LD_EXP 51
29140: PUSH
29141: EMPTY
29142: LIST
29143: PPUSH
29144: CALL_OW 72
29148: PUSH
29149: LD_EXP 77
29153: PUSH
29154: LD_INT 1
29156: ARRAY
29157: ADD
29158: PUSH
29159: LD_EXP 75
29163: PUSH
29164: LD_INT 1
29166: ARRAY
29167: PPUSH
29168: LD_EXP 56
29172: PUSH
29173: EMPTY
29174: LIST
29175: PPUSH
29176: CALL_OW 72
29180: ADD
29181: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29182: LD_ADDR_EXP 90
29186: PUSH
29187: LD_EXP 76
29191: PUSH
29192: LD_INT 2
29194: ARRAY
29195: PPUSH
29196: LD_EXP 51
29200: PUSH
29201: EMPTY
29202: LIST
29203: PPUSH
29204: CALL_OW 72
29208: PUSH
29209: LD_EXP 77
29213: PUSH
29214: LD_INT 2
29216: ARRAY
29217: ADD
29218: PUSH
29219: LD_EXP 75
29223: PUSH
29224: LD_INT 2
29226: ARRAY
29227: PPUSH
29228: LD_EXP 56
29232: PUSH
29233: EMPTY
29234: LIST
29235: PPUSH
29236: CALL_OW 72
29240: ADD
29241: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29242: LD_ADDR_EXP 91
29246: PUSH
29247: LD_EXP 76
29251: PUSH
29252: LD_INT 3
29254: ARRAY
29255: PPUSH
29256: LD_EXP 51
29260: PUSH
29261: EMPTY
29262: LIST
29263: PPUSH
29264: CALL_OW 72
29268: PUSH
29269: LD_EXP 77
29273: PUSH
29274: LD_INT 3
29276: ARRAY
29277: ADD
29278: PUSH
29279: LD_EXP 75
29283: PUSH
29284: LD_INT 3
29286: ARRAY
29287: PPUSH
29288: LD_EXP 56
29292: PUSH
29293: EMPTY
29294: LIST
29295: PPUSH
29296: CALL_OW 72
29300: ADD
29301: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
29302: LD_ADDR_EXP 92
29306: PUSH
29307: LD_EXP 76
29311: PUSH
29312: LD_INT 4
29314: ARRAY
29315: PPUSH
29316: LD_EXP 51
29320: PUSH
29321: EMPTY
29322: LIST
29323: PPUSH
29324: CALL_OW 72
29328: PUSH
29329: LD_EXP 77
29333: PUSH
29334: LD_INT 4
29336: ARRAY
29337: ADD
29338: PUSH
29339: LD_EXP 75
29343: PUSH
29344: LD_INT 4
29346: ARRAY
29347: PPUSH
29348: LD_EXP 56
29352: PUSH
29353: EMPTY
29354: LIST
29355: PPUSH
29356: CALL_OW 72
29360: ADD
29361: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
29362: LD_ADDR_EXP 93
29366: PUSH
29367: LD_EXP 76
29371: PUSH
29372: LD_INT 5
29374: ARRAY
29375: PPUSH
29376: LD_EXP 51
29380: PUSH
29381: EMPTY
29382: LIST
29383: PPUSH
29384: CALL_OW 72
29388: PUSH
29389: LD_EXP 77
29393: PUSH
29394: LD_INT 5
29396: ARRAY
29397: ADD
29398: PUSH
29399: LD_EXP 75
29403: PUSH
29404: LD_INT 5
29406: ARRAY
29407: PPUSH
29408: LD_EXP 56
29412: PUSH
29413: EMPTY
29414: LIST
29415: PPUSH
29416: CALL_OW 72
29420: ADD
29421: ST_TO_ADDR
// rDef1 := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearA ] , [ mc_reg_area_to_protect , nearA ] ] ) ;
29422: LD_ADDR_LOC 31
29426: PUSH
29427: LD_EXP 23
29431: PUSH
29432: LD_INT 1
29434: ARRAY
29435: PPUSH
29436: LD_INT 1
29438: PUSH
29439: LD_INT 70
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: LD_INT 24
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 3
29458: PUSH
29459: LD_INT 24
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: LIST
29470: PPUSH
29471: CALL_OW 399
29475: ST_TO_ADDR
// rDef2 := McRegistry ( ai_s [ 2 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearB ] , [ mc_reg_area_to_protect , nearB ] ] ) ;
29476: LD_ADDR_LOC 32
29480: PUSH
29481: LD_EXP 23
29485: PUSH
29486: LD_INT 2
29488: ARRAY
29489: PPUSH
29490: LD_INT 1
29492: PUSH
29493: LD_INT 70
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: PUSH
29503: LD_INT 25
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 3
29512: PUSH
29513: LD_INT 25
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: LIST
29524: PPUSH
29525: CALL_OW 399
29529: ST_TO_ADDR
// rDef3 := McRegistry ( ai_s [ 3 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearC ] , [ mc_reg_area_to_protect , nearC ] ] ) ;
29530: LD_ADDR_LOC 33
29534: PUSH
29535: LD_EXP 23
29539: PUSH
29540: LD_INT 3
29542: ARRAY
29543: PPUSH
29544: LD_INT 1
29546: PUSH
29547: LD_INT 70
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 2
29556: PUSH
29557: LD_INT 26
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 3
29566: PUSH
29567: LD_INT 26
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: LIST
29578: PPUSH
29579: CALL_OW 399
29583: ST_TO_ADDR
// rDef4 := McRegistry ( ai_s [ 4 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearD ] , [ mc_reg_area_to_protect , nearD ] ] ) ;
29584: LD_ADDR_LOC 34
29588: PUSH
29589: LD_EXP 23
29593: PUSH
29594: LD_INT 4
29596: ARRAY
29597: PPUSH
29598: LD_INT 1
29600: PUSH
29601: LD_INT 70
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 27
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: LD_INT 3
29620: PUSH
29621: LD_INT 27
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 399
29637: ST_TO_ADDR
// rDef5 := McRegistry ( ai_s [ 5 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearE ] , [ mc_reg_area_to_protect , nearE ] ] ) ;
29638: LD_ADDR_LOC 35
29642: PUSH
29643: LD_EXP 23
29647: PUSH
29648: LD_INT 5
29650: ARRAY
29651: PPUSH
29652: LD_INT 1
29654: PUSH
29655: LD_INT 70
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 2
29664: PUSH
29665: LD_INT 28
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 3
29674: PUSH
29675: LD_INT 28
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: LIST
29686: PPUSH
29687: CALL_OW 399
29691: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef1_difficulty ] ) ;
29692: LD_ADDR_LOC 36
29696: PUSH
29697: LD_INT 10
29699: PPUSH
29700: LD_LOC 31
29704: PPUSH
29705: LD_EXP 89
29709: PPUSH
29710: LD_INT 1
29712: PUSH
29713: LD_EXP 11
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PPUSH
29722: CALL_OW 401
29726: ST_TO_ADDR
// idDef2 := McDefend ( 10 , rDef2 , toDef2 , [ mc_def_advantage , mcdef2_difficulty ] ) ;
29727: LD_ADDR_LOC 37
29731: PUSH
29732: LD_INT 10
29734: PPUSH
29735: LD_LOC 32
29739: PPUSH
29740: LD_EXP 90
29744: PPUSH
29745: LD_INT 1
29747: PUSH
29748: LD_EXP 12
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PPUSH
29757: CALL_OW 401
29761: ST_TO_ADDR
// idDef3 := McDefend ( 10 , rDef3 , toDef3 , [ mc_def_advantage , mcdef3_difficulty ] ) ;
29762: LD_ADDR_LOC 38
29766: PUSH
29767: LD_INT 10
29769: PPUSH
29770: LD_LOC 33
29774: PPUSH
29775: LD_EXP 91
29779: PPUSH
29780: LD_INT 1
29782: PUSH
29783: LD_EXP 13
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PPUSH
29792: CALL_OW 401
29796: ST_TO_ADDR
// idDef4 := McDefend ( 10 , rDef4 , toDef4 , [ mc_def_advantage , mcdef4_difficulty ] ) ;
29797: LD_ADDR_LOC 39
29801: PUSH
29802: LD_INT 10
29804: PPUSH
29805: LD_LOC 34
29809: PPUSH
29810: LD_EXP 92
29814: PPUSH
29815: LD_INT 1
29817: PUSH
29818: LD_EXP 14
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PPUSH
29827: CALL_OW 401
29831: ST_TO_ADDR
// idDef5 := McDefend ( 10 , rDef5 , toDef5 , [ mc_def_advantage , mcdef5_difficulty ] ) ;
29832: LD_ADDR_LOC 40
29836: PUSH
29837: LD_INT 10
29839: PPUSH
29840: LD_LOC 35
29844: PPUSH
29845: LD_EXP 93
29849: PPUSH
29850: LD_INT 1
29852: PUSH
29853: LD_EXP 15
29857: PUSH
29858: EMPTY
29859: LIST
29860: LIST
29861: PPUSH
29862: CALL_OW 401
29866: ST_TO_ADDR
// end ;
29867: END
// every 0 0$10 do
29868: GO 29870
29870: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29871: LD_ADDR_EXP 89
29875: PUSH
29876: LD_EXP 76
29880: PUSH
29881: LD_INT 1
29883: ARRAY
29884: PPUSH
29885: LD_EXP 51
29889: PUSH
29890: EMPTY
29891: LIST
29892: PPUSH
29893: CALL_OW 72
29897: PUSH
29898: LD_EXP 77
29902: PUSH
29903: LD_INT 1
29905: ARRAY
29906: ADD
29907: PUSH
29908: LD_EXP 75
29912: PUSH
29913: LD_INT 1
29915: ARRAY
29916: PPUSH
29917: LD_EXP 56
29921: PUSH
29922: EMPTY
29923: LIST
29924: PPUSH
29925: CALL_OW 72
29929: ADD
29930: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29931: LD_ADDR_EXP 90
29935: PUSH
29936: LD_EXP 76
29940: PUSH
29941: LD_INT 2
29943: ARRAY
29944: PPUSH
29945: LD_EXP 51
29949: PUSH
29950: EMPTY
29951: LIST
29952: PPUSH
29953: CALL_OW 72
29957: PUSH
29958: LD_EXP 77
29962: PUSH
29963: LD_INT 2
29965: ARRAY
29966: ADD
29967: PUSH
29968: LD_EXP 75
29972: PUSH
29973: LD_INT 2
29975: ARRAY
29976: PPUSH
29977: LD_EXP 56
29981: PUSH
29982: EMPTY
29983: LIST
29984: PPUSH
29985: CALL_OW 72
29989: ADD
29990: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29991: LD_ADDR_EXP 91
29995: PUSH
29996: LD_EXP 76
30000: PUSH
30001: LD_INT 3
30003: ARRAY
30004: PPUSH
30005: LD_EXP 51
30009: PUSH
30010: EMPTY
30011: LIST
30012: PPUSH
30013: CALL_OW 72
30017: PUSH
30018: LD_EXP 77
30022: PUSH
30023: LD_INT 3
30025: ARRAY
30026: ADD
30027: PUSH
30028: LD_EXP 75
30032: PUSH
30033: LD_INT 3
30035: ARRAY
30036: PPUSH
30037: LD_EXP 56
30041: PUSH
30042: EMPTY
30043: LIST
30044: PPUSH
30045: CALL_OW 72
30049: ADD
30050: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
30051: LD_ADDR_EXP 92
30055: PUSH
30056: LD_EXP 76
30060: PUSH
30061: LD_INT 4
30063: ARRAY
30064: PPUSH
30065: LD_EXP 51
30069: PUSH
30070: EMPTY
30071: LIST
30072: PPUSH
30073: CALL_OW 72
30077: PUSH
30078: LD_EXP 77
30082: PUSH
30083: LD_INT 4
30085: ARRAY
30086: ADD
30087: PUSH
30088: LD_EXP 75
30092: PUSH
30093: LD_INT 4
30095: ARRAY
30096: PPUSH
30097: LD_EXP 56
30101: PUSH
30102: EMPTY
30103: LIST
30104: PPUSH
30105: CALL_OW 72
30109: ADD
30110: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
30111: LD_ADDR_EXP 93
30115: PUSH
30116: LD_EXP 76
30120: PUSH
30121: LD_INT 5
30123: ARRAY
30124: PPUSH
30125: LD_EXP 51
30129: PUSH
30130: EMPTY
30131: LIST
30132: PPUSH
30133: CALL_OW 72
30137: PUSH
30138: LD_EXP 77
30142: PUSH
30143: LD_INT 5
30145: ARRAY
30146: ADD
30147: PUSH
30148: LD_EXP 75
30152: PUSH
30153: LD_INT 5
30155: ARRAY
30156: PPUSH
30157: LD_EXP 56
30161: PUSH
30162: EMPTY
30163: LIST
30164: PPUSH
30165: CALL_OW 72
30169: ADD
30170: ST_TO_ADDR
// ClearMcUnits ( idDef1 ) ;
30171: LD_LOC 36
30175: PPUSH
30176: CALL_OW 392
// AddMcUnits ( idDef1 , todef1 ) ;
30180: LD_LOC 36
30184: PPUSH
30185: LD_EXP 89
30189: PPUSH
30190: CALL_OW 390
// ClearMcUnits ( idDef2 ) ;
30194: LD_LOC 37
30198: PPUSH
30199: CALL_OW 392
// AddMcUnits ( idDef2 , todef2 ) ;
30203: LD_LOC 37
30207: PPUSH
30208: LD_EXP 90
30212: PPUSH
30213: CALL_OW 390
// ClearMcUnits ( idDef3 ) ;
30217: LD_LOC 38
30221: PPUSH
30222: CALL_OW 392
// AddMcUnits ( idDef3 , todef3 ) ;
30226: LD_LOC 38
30230: PPUSH
30231: LD_EXP 91
30235: PPUSH
30236: CALL_OW 390
// ClearMcUnits ( idDef4 ) ;
30240: LD_LOC 39
30244: PPUSH
30245: CALL_OW 392
// AddMcUnits ( idDef4 , todef4 ) ;
30249: LD_LOC 39
30253: PPUSH
30254: LD_EXP 92
30258: PPUSH
30259: CALL_OW 390
// ClearMcUnits ( idDef5 ) ;
30263: LD_LOC 40
30267: PPUSH
30268: CALL_OW 392
// AddMcUnits ( idDef5 , todef5 ) ;
30272: LD_LOC 40
30276: PPUSH
30277: LD_EXP 93
30281: PPUSH
30282: CALL_OW 390
// enable ;
30286: ENABLE
// end ; end_of_file
30287: END
// export function SurrenderBase ( type , side ) ; var a , cars ; begin
30288: LD_INT 0
30290: PPUSH
30291: PPUSH
30292: PPUSH
// if not ( side in your_bases ) then
30293: LD_VAR 0 2
30297: PUSH
30298: LD_EXP 18
30302: IN
30303: NOT
30304: IFFALSE 30918
// begin SetAttitude ( you , side , att_friend , true ) ;
30306: LD_EXP 7
30310: PPUSH
30311: LD_VAR 0 2
30315: PPUSH
30316: LD_INT 1
30318: PPUSH
30319: LD_INT 1
30321: PPUSH
30322: CALL_OW 80
// case type of t_kill :
30326: LD_VAR 0 1
30330: PUSH
30331: LD_EXP 1
30335: DOUBLE
30336: EQUAL
30337: IFTRUE 30341
30339: GO 30412
30341: POP
// begin if side = ai_s [ 1 ] then
30342: LD_VAR 0 2
30346: PUSH
30347: LD_EXP 23
30351: PUSH
30352: LD_INT 1
30354: ARRAY
30355: EQUAL
30356: IFFALSE 30381
// begin DXbaseSurrender ( side ) ;
30358: LD_VAR 0 2
30362: PPUSH
30363: CALL 7901 0 1
// SurrenderNormal ( true , side ) ;
30367: LD_INT 1
30369: PPUSH
30370: LD_VAR 0 2
30374: PPUSH
30375: CALL 30923 0 2
// end else
30379: GO 30410
// begin diplomacy := false ;
30381: LD_ADDR_EXP 27
30385: PUSH
30386: LD_INT 0
30388: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30389: LD_VAR 0 2
30393: PPUSH
30394: CALL 7901 0 1
// SurrenderNormal ( true , side ) ;
30398: LD_INT 1
30400: PPUSH
30401: LD_VAR 0 2
30405: PPUSH
30406: CALL 30923 0 2
// end ; end ; t_killbeat :
30410: GO 30750
30412: LD_EXP 6
30416: DOUBLE
30417: EQUAL
30418: IFTRUE 30422
30420: GO 30493
30422: POP
// begin if side = ai_s [ 1 ] then
30423: LD_VAR 0 2
30427: PUSH
30428: LD_EXP 23
30432: PUSH
30433: LD_INT 1
30435: ARRAY
30436: EQUAL
30437: IFFALSE 30462
// begin DXbaseSurrender ( side ) ;
30439: LD_VAR 0 2
30443: PPUSH
30444: CALL 7901 0 1
// SurrenderNormal ( true , side ) ;
30448: LD_INT 1
30450: PPUSH
30451: LD_VAR 0 2
30455: PPUSH
30456: CALL 30923 0 2
// end else
30460: GO 30491
// begin diplomacy := false ;
30462: LD_ADDR_EXP 27
30466: PUSH
30467: LD_INT 0
30469: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30470: LD_VAR 0 2
30474: PPUSH
30475: CALL 7901 0 1
// SurrenderNormal ( true , side ) ;
30479: LD_INT 1
30481: PPUSH
30482: LD_VAR 0 2
30486: PPUSH
30487: CALL 30923 0 2
// end ; end ; t_intimidate :
30491: GO 30750
30493: LD_EXP 2
30497: DOUBLE
30498: EQUAL
30499: IFTRUE 30503
30501: GO 30557
30503: POP
// begin if side = ai_s [ 2 ] then
30504: LD_VAR 0 2
30508: PUSH
30509: LD_EXP 23
30513: PUSH
30514: LD_INT 2
30516: ARRAY
30517: EQUAL
30518: IFFALSE 30555
// begin DB_BaseAccept ( cap_bases = 0 ) ;
30520: LD_EXP 17
30524: PUSH
30525: LD_INT 0
30527: EQUAL
30528: PPUSH
30529: CALL 4560 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 2 ] ) ;
30533: LD_EXP 17
30537: PUSH
30538: LD_INT 0
30540: EQUAL
30541: PPUSH
30542: LD_EXP 23
30546: PUSH
30547: LD_INT 2
30549: ARRAY
30550: PPUSH
30551: CALL 30923 0 2
// end ; end ; t_persuade :
30555: GO 30750
30557: LD_EXP 3
30561: DOUBLE
30562: EQUAL
30563: IFTRUE 30567
30565: GO 30621
30567: POP
// begin if side = ai_s [ 3 ] then
30568: LD_VAR 0 2
30572: PUSH
30573: LD_EXP 23
30577: PUSH
30578: LD_INT 3
30580: ARRAY
30581: EQUAL
30582: IFFALSE 30619
// begin DQrML_Right ( cap_bases = 0 ) ;
30584: LD_EXP 17
30588: PUSH
30589: LD_INT 0
30591: EQUAL
30592: PPUSH
30593: CALL 6724 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 3 ] ) ;
30597: LD_EXP 17
30601: PUSH
30602: LD_INT 0
30604: EQUAL
30605: PPUSH
30606: LD_EXP 23
30610: PUSH
30611: LD_INT 3
30613: ARRAY
30614: PPUSH
30615: CALL 30923 0 2
// end ; end ; t_pay :
30619: GO 30750
30621: LD_EXP 4
30625: DOUBLE
30626: EQUAL
30627: IFTRUE 30631
30629: GO 30685
30631: POP
// begin if side = ai_s [ 4 ] then
30632: LD_VAR 0 2
30636: PUSH
30637: LD_EXP 23
30641: PUSH
30642: LD_INT 4
30644: ARRAY
30645: EQUAL
30646: IFFALSE 30683
// begin DD_BaseAccept ( cap_bases = 0 ) ;
30648: LD_EXP 17
30652: PUSH
30653: LD_INT 0
30655: EQUAL
30656: PPUSH
30657: CALL 7288 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 4 ] ) ;
30661: LD_EXP 17
30665: PUSH
30666: LD_INT 0
30668: EQUAL
30669: PPUSH
30670: LD_EXP 23
30674: PUSH
30675: LD_INT 4
30677: ARRAY
30678: PPUSH
30679: CALL 30923 0 2
// end ; end ; t_beat :
30683: GO 30750
30685: LD_EXP 5
30689: DOUBLE
30690: EQUAL
30691: IFTRUE 30695
30693: GO 30749
30695: POP
// begin if side = ai_s [ 5 ] then
30696: LD_VAR 0 2
30700: PUSH
30701: LD_EXP 23
30705: PUSH
30706: LD_INT 5
30708: ARRAY
30709: EQUAL
30710: IFFALSE 30747
// begin DE_BaseAccept ( cap_bases = 0 ) ;
30712: LD_EXP 17
30716: PUSH
30717: LD_INT 0
30719: EQUAL
30720: PPUSH
30721: CALL 7841 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 5 ] ) ;
30725: LD_EXP 17
30729: PUSH
30730: LD_INT 0
30732: EQUAL
30733: PPUSH
30734: LD_EXP 23
30738: PUSH
30739: LD_INT 5
30741: ARRAY
30742: PPUSH
30743: CALL 30923 0 2
// end ; end ; end ;
30747: GO 30750
30749: POP
// your_humans := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
30750: LD_ADDR_EXP 37
30754: PUSH
30755: LD_INT 22
30757: PUSH
30758: LD_EXP 7
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 21
30769: PUSH
30770: LD_INT 1
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PPUSH
30781: CALL_OW 69
30785: ST_TO_ADDR
// your_builds := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
30786: LD_ADDR_EXP 36
30790: PUSH
30791: LD_INT 22
30793: PUSH
30794: LD_EXP 7
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 21
30805: PUSH
30806: LD_INT 3
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PPUSH
30817: CALL_OW 69
30821: ST_TO_ADDR
// your_cars := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
30822: LD_ADDR_EXP 35
30826: PUSH
30827: LD_INT 22
30829: PUSH
30830: LD_EXP 7
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 21
30841: PUSH
30842: LD_INT 2
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PPUSH
30853: CALL_OW 69
30857: ST_TO_ADDR
// remove_from_humans ( your_humans ) ;
30858: LD_EXP 37
30862: PPUSH
30863: CALL 27956 0 1
// remove_from_builds ( your_builds ) ;
30867: LD_EXP 36
30871: PPUSH
30872: CALL 27710 0 1
// remove_from_vehicles ( your_cars ) ;
30876: LD_EXP 35
30880: PPUSH
30881: CALL 28194 0 1
// cap_bases := cap_bases + 1 ;
30885: LD_ADDR_EXP 17
30889: PUSH
30890: LD_EXP 17
30894: PUSH
30895: LD_INT 1
30897: PLUS
30898: ST_TO_ADDR
// your_bases := your_bases ^ [ side ] ;
30899: LD_ADDR_EXP 18
30903: PUSH
30904: LD_EXP 18
30908: PUSH
30909: LD_VAR 0 2
30913: PUSH
30914: EMPTY
30915: LIST
30916: ADD
30917: ST_TO_ADDR
// end ; end ;
30918: LD_VAR 0 3
30922: RET
// function SurrenderNormal ( first , side ) ; var yours , take , theirs , i , max , t_sci , t_lab ; begin
30923: LD_INT 0
30925: PPUSH
30926: PPUSH
30927: PPUSH
30928: PPUSH
30929: PPUSH
30930: PPUSH
30931: PPUSH
30932: PPUSH
// yours := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
30933: LD_ADDR_VAR 0 4
30937: PUSH
30938: LD_INT 22
30940: PUSH
30941: LD_EXP 7
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 21
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 23
30962: PUSH
30963: LD_INT 3
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: LIST
30974: PPUSH
30975: CALL_OW 69
30979: ST_TO_ADDR
// theirs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
30980: LD_ADDR_VAR 0 6
30984: PUSH
30985: LD_INT 22
30987: PUSH
30988: LD_VAR 0 2
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: LD_INT 21
30999: PUSH
31000: LD_INT 1
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 23
31009: PUSH
31010: LD_INT 3
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: LIST
31021: PPUSH
31022: CALL_OW 69
31026: ST_TO_ADDR
// for i in theirs do
31027: LD_ADDR_VAR 0 7
31031: PUSH
31032: LD_VAR 0 6
31036: PUSH
31037: FOR_IN
31038: IFFALSE 31073
// if GetLives ( i ) < hranice_umirani then
31040: LD_VAR 0 7
31044: PPUSH
31045: CALL_OW 256
31049: PUSH
31050: LD_INT 250
31052: LESS
31053: IFFALSE 31071
// SetLives ( i , hranice_umirani + 50 ) ;
31055: LD_VAR 0 7
31059: PPUSH
31060: LD_INT 250
31062: PUSH
31063: LD_INT 50
31065: PLUS
31066: PPUSH
31067: CALL_OW 234
31071: GO 31037
31073: POP
31074: POP
// InGameOn ;
31075: CALL_OW 8
// while UnitFilter ( theirs , [ [ f_inside ] ] ) diff hlavouni do
31079: LD_VAR 0 6
31083: PPUSH
31084: LD_INT 54
31086: PUSH
31087: EMPTY
31088: LIST
31089: PUSH
31090: EMPTY
31091: LIST
31092: PPUSH
31093: CALL_OW 72
31097: PUSH
31098: LD_EXP 72
31102: DIFF
31103: IFFALSE 31132
// begin ComExitBuilding ( theirs ) ;
31105: LD_VAR 0 6
31109: PPUSH
31110: CALL_OW 122
// AddComExitVehicle ( theirs ) ;
31114: LD_VAR 0 6
31118: PPUSH
31119: CALL_OW 181
// wait ( 0 0$2 ) ;
31123: LD_INT 70
31125: PPUSH
31126: CALL_OW 67
// end ;
31130: GO 31079
// InGameOff ;
31132: CALL_OW 9
// if first then
31136: LD_VAR 0 1
31140: IFFALSE 31806
// begin SetTech ( tech_SibLoc , you , state_researched ) ;
31142: LD_INT 19
31144: PPUSH
31145: LD_EXP 7
31149: PPUSH
31150: LD_INT 2
31152: PPUSH
31153: CALL_OW 322
// ai := ai diff side ;
31157: LD_ADDR_EXP 24
31161: PUSH
31162: LD_EXP 24
31166: PUSH
31167: LD_VAR 0 2
31171: DIFF
31172: ST_TO_ADDR
// case side of ai_s [ 1 ] :
31173: LD_VAR 0 2
31177: PUSH
31178: LD_EXP 23
31182: PUSH
31183: LD_INT 1
31185: ARRAY
31186: DOUBLE
31187: EQUAL
31188: IFTRUE 31192
31190: GO 31254
31192: POP
// begin SetSideBase_custom ( GetBase ( depots [ 1 ] ) , you ) ;
31193: LD_EXP 74
31197: PUSH
31198: LD_INT 1
31200: ARRAY
31201: PPUSH
31202: CALL_OW 274
31206: PPUSH
31207: LD_EXP 7
31211: PPUSH
31212: CALL 32693 0 2
// SetSide ( humans [ 1 ] , you ) ;
31216: LD_EXP 76
31220: PUSH
31221: LD_INT 1
31223: ARRAY
31224: PPUSH
31225: LD_EXP 7
31229: PPUSH
31230: CALL_OW 235
// SetSide ( vehicles [ 1 ] , you ) ;
31234: LD_EXP 77
31238: PUSH
31239: LD_INT 1
31241: ARRAY
31242: PPUSH
31243: LD_EXP 7
31247: PPUSH
31248: CALL_OW 235
// end ; ai_s [ 2 ] :
31252: GO 31804
31254: LD_EXP 23
31258: PUSH
31259: LD_INT 2
31261: ARRAY
31262: DOUBLE
31263: EQUAL
31264: IFTRUE 31268
31266: GO 31344
31268: POP
// begin SetSideBase_custom ( GetBase ( depots [ 2 ] ) , you ) ;
31269: LD_EXP 74
31273: PUSH
31274: LD_INT 2
31276: ARRAY
31277: PPUSH
31278: CALL_OW 274
31282: PPUSH
31283: LD_EXP 7
31287: PPUSH
31288: CALL 32693 0 2
// SetSide ( humans [ 2 ] , you ) ;
31292: LD_EXP 76
31296: PUSH
31297: LD_INT 2
31299: ARRAY
31300: PPUSH
31301: LD_EXP 7
31305: PPUSH
31306: CALL_OW 235
// SetSide ( vehicles [ 2 ] , you ) ;
31310: LD_EXP 77
31314: PUSH
31315: LD_INT 2
31317: ARRAY
31318: PPUSH
31319: LD_EXP 7
31323: PPUSH
31324: CALL_OW 235
// SetSide ( Borodin , you ) ;
31328: LD_EXP 46
31332: PPUSH
31333: LD_EXP 7
31337: PPUSH
31338: CALL_OW 235
// end ; ai_s [ 3 ] :
31342: GO 31804
31344: LD_EXP 23
31348: PUSH
31349: LD_INT 3
31351: ARRAY
31352: DOUBLE
31353: EQUAL
31354: IFTRUE 31358
31356: GO 31434
31358: POP
// begin SetSideBase_custom ( GetBase ( depots [ 3 ] ) , you ) ;
31359: LD_EXP 74
31363: PUSH
31364: LD_INT 3
31366: ARRAY
31367: PPUSH
31368: CALL_OW 274
31372: PPUSH
31373: LD_EXP 7
31377: PPUSH
31378: CALL 32693 0 2
// SetSide ( humans [ 3 ] , you ) ;
31382: LD_EXP 76
31386: PUSH
31387: LD_INT 3
31389: ARRAY
31390: PPUSH
31391: LD_EXP 7
31395: PPUSH
31396: CALL_OW 235
// SetSide ( vehicles [ 3 ] , you ) ;
31400: LD_EXP 77
31404: PUSH
31405: LD_INT 3
31407: ARRAY
31408: PPUSH
31409: LD_EXP 7
31413: PPUSH
31414: CALL_OW 235
// SetSide ( Tsaritsyn , you ) ;
31418: LD_EXP 47
31422: PPUSH
31423: LD_EXP 7
31427: PPUSH
31428: CALL_OW 235
// end ; ai_s [ 4 ] :
31432: GO 31804
31434: LD_EXP 23
31438: PUSH
31439: LD_INT 4
31441: ARRAY
31442: DOUBLE
31443: EQUAL
31444: IFTRUE 31448
31446: GO 31713
31448: POP
// begin t_sci := sci isect humans [ 4 ] ;
31449: LD_ADDR_VAR 0 9
31453: PUSH
31454: LD_EXP 88
31458: PUSH
31459: LD_EXP 76
31463: PUSH
31464: LD_INT 4
31466: ARRAY
31467: ISECT
31468: ST_TO_ADDR
// if t_sci > 3 then
31469: LD_VAR 0 9
31473: PUSH
31474: LD_INT 3
31476: GREATER
31477: IFFALSE 31513
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
31479: LD_ADDR_VAR 0 9
31483: PUSH
31484: LD_VAR 0 9
31488: PUSH
31489: LD_INT 1
31491: ARRAY
31492: PUSH
31493: LD_VAR 0 9
31497: PUSH
31498: LD_INT 2
31500: ARRAY
31501: ADD
31502: PUSH
31503: LD_VAR 0 9
31507: PUSH
31508: LD_INT 3
31510: ARRAY
31511: ADD
31512: ST_TO_ADDR
// t_lab := UnitFilter ( buildings [ 4 ] , [ mf_lab ] ) ;
31513: LD_ADDR_VAR 0 10
31517: PUSH
31518: LD_EXP 75
31522: PUSH
31523: LD_INT 4
31525: ARRAY
31526: PPUSH
31527: LD_EXP 55
31531: PUSH
31532: EMPTY
31533: LIST
31534: PPUSH
31535: CALL_OW 72
31539: ST_TO_ADDR
// for i in t_lab do
31540: LD_ADDR_VAR 0 7
31544: PUSH
31545: LD_VAR 0 10
31549: PUSH
31550: FOR_IN
31551: IFFALSE 31603
// if GetLabKind ( i , 1 ) = b_lab_spacetime or GetLabKind ( i , 2 ) = b_lab_spacetime then
31553: LD_VAR 0 7
31557: PPUSH
31558: LD_INT 1
31560: PPUSH
31561: CALL_OW 268
31565: PUSH
31566: LD_INT 14
31568: EQUAL
31569: PUSH
31570: LD_VAR 0 7
31574: PPUSH
31575: LD_INT 2
31577: PPUSH
31578: CALL_OW 268
31582: PUSH
31583: LD_INT 14
31585: EQUAL
31586: OR
31587: IFFALSE 31601
// begin t_lab := i ;
31589: LD_ADDR_VAR 0 10
31593: PUSH
31594: LD_VAR 0 7
31598: ST_TO_ADDR
// break ;
31599: GO 31603
// end ;
31601: GO 31550
31603: POP
31604: POP
// SetSideBase_custom ( GetBase ( depots [ 4 ] ) , you ) ;
31605: LD_EXP 74
31609: PUSH
31610: LD_INT 4
31612: ARRAY
31613: PPUSH
31614: CALL_OW 274
31618: PPUSH
31619: LD_EXP 7
31623: PPUSH
31624: CALL 32693 0 2
// SetSide ( humans [ 4 ] diff t_sci , you ) ;
31628: LD_EXP 76
31632: PUSH
31633: LD_INT 4
31635: ARRAY
31636: PUSH
31637: LD_VAR 0 9
31641: DIFF
31642: PPUSH
31643: LD_EXP 7
31647: PPUSH
31648: CALL_OW 235
// SetSide ( vehicles [ 4 ] , you ) ;
31652: LD_EXP 77
31656: PUSH
31657: LD_INT 4
31659: ARRAY
31660: PPUSH
31661: LD_EXP 7
31665: PPUSH
31666: CALL_OW 235
// SetSide ( t_lab , ai_s [ 4 ] ) ;
31670: LD_VAR 0 10
31674: PPUSH
31675: LD_EXP 23
31679: PUSH
31680: LD_INT 4
31682: ARRAY
31683: PPUSH
31684: CALL_OW 235
// ComEnterUnit ( t_sci ^ [ Davidov ] , t_lab ) ;
31688: LD_VAR 0 9
31692: PUSH
31693: LD_EXP 48
31697: PUSH
31698: EMPTY
31699: LIST
31700: ADD
31701: PPUSH
31702: LD_VAR 0 10
31706: PPUSH
31707: CALL_OW 120
// end ; ai_s [ 5 ] :
31711: GO 31804
31713: LD_EXP 23
31717: PUSH
31718: LD_INT 5
31720: ARRAY
31721: DOUBLE
31722: EQUAL
31723: IFTRUE 31727
31725: GO 31803
31727: POP
// begin SetSideBase_custom ( GetBase ( depots [ 5 ] ) , you ) ;
31728: LD_EXP 74
31732: PUSH
31733: LD_INT 5
31735: ARRAY
31736: PPUSH
31737: CALL_OW 274
31741: PPUSH
31742: LD_EXP 7
31746: PPUSH
31747: CALL 32693 0 2
// SetSide ( humans [ 5 ] , you ) ;
31751: LD_EXP 76
31755: PUSH
31756: LD_INT 5
31758: ARRAY
31759: PPUSH
31760: LD_EXP 7
31764: PPUSH
31765: CALL_OW 235
// SetSide ( vehicles [ 5 ] , you ) ;
31769: LD_EXP 77
31773: PUSH
31774: LD_INT 5
31776: ARRAY
31777: PPUSH
31778: LD_EXP 7
31782: PPUSH
31783: CALL_OW 235
// SetSide ( Eisenstein , you ) ;
31787: LD_EXP 49
31791: PPUSH
31792: LD_EXP 7
31796: PPUSH
31797: CALL_OW 235
// end ; end ;
31801: GO 31804
31803: POP
// end else
31804: GO 32603
// begin case side of ai_s [ 1 ] :
31806: LD_VAR 0 2
31810: PUSH
31811: LD_EXP 23
31815: PUSH
31816: LD_INT 1
31818: ARRAY
31819: DOUBLE
31820: EQUAL
31821: IFTRUE 31825
31823: GO 31862
31825: POP
// take := humans [ 1 ] ^ buildings [ 1 ] ^ vehicles [ 1 ] ; ai_s [ 2 ] :
31826: LD_ADDR_VAR 0 5
31830: PUSH
31831: LD_EXP 76
31835: PUSH
31836: LD_INT 1
31838: ARRAY
31839: PUSH
31840: LD_EXP 75
31844: PUSH
31845: LD_INT 1
31847: ARRAY
31848: ADD
31849: PUSH
31850: LD_EXP 77
31854: PUSH
31855: LD_INT 1
31857: ARRAY
31858: ADD
31859: ST_TO_ADDR
31860: GO 32603
31862: LD_EXP 23
31866: PUSH
31867: LD_INT 2
31869: ARRAY
31870: DOUBLE
31871: EQUAL
31872: IFTRUE 31876
31874: GO 32028
31876: POP
// begin if humans [ 2 ] < 3 then
31877: LD_EXP 76
31881: PUSH
31882: LD_INT 2
31884: ARRAY
31885: PUSH
31886: LD_INT 3
31888: LESS
31889: IFFALSE 31901
// max := 1 else
31891: LD_ADDR_VAR 0 8
31895: PUSH
31896: LD_INT 1
31898: ST_TO_ADDR
31899: GO 31919
// max := humans [ 2 ] - 2 ;
31901: LD_ADDR_VAR 0 8
31905: PUSH
31906: LD_EXP 76
31910: PUSH
31911: LD_INT 2
31913: ARRAY
31914: PUSH
31915: LD_INT 2
31917: MINUS
31918: ST_TO_ADDR
// if max > 5 then
31919: LD_VAR 0 8
31923: PUSH
31924: LD_INT 5
31926: GREATER
31927: IFFALSE 31937
// max := 5 ;
31929: LD_ADDR_VAR 0 8
31933: PUSH
31934: LD_INT 5
31936: ST_TO_ADDR
// take := CharacterSelection ( B-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 2 ] ^ [ sel_not_changeable ] ^ [ Borodin ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
31937: LD_ADDR_VAR 0 5
31941: PUSH
31942: LD_STRING B-Base
31944: PPUSH
31945: LD_INT 1
31947: PPUSH
31948: LD_VAR 0 8
31952: PPUSH
31953: LD_VAR 0 4
31957: PUSH
31958: LD_INT -2
31960: PUSH
31961: LD_INT -3
31963: PUSH
31964: LD_INT -6
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: LIST
31971: ADD
31972: PUSH
31973: LD_EXP 76
31977: PUSH
31978: LD_INT 2
31980: ARRAY
31981: ADD
31982: PUSH
31983: LD_INT -4
31985: PUSH
31986: EMPTY
31987: LIST
31988: ADD
31989: PUSH
31990: LD_EXP 46
31994: PUSH
31995: EMPTY
31996: LIST
31997: ADD
31998: PPUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 3
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: LD_INT 4
32010: PUSH
32011: LD_INT 9
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: PPUSH
32021: CALL_OW 42
32025: ST_TO_ADDR
// end ; ai_s [ 3 ] :
32026: GO 32603
32028: LD_EXP 23
32032: PUSH
32033: LD_INT 3
32035: ARRAY
32036: DOUBLE
32037: EQUAL
32038: IFTRUE 32042
32040: GO 32194
32042: POP
// begin if humans [ 3 ] < 3 then
32043: LD_EXP 76
32047: PUSH
32048: LD_INT 3
32050: ARRAY
32051: PUSH
32052: LD_INT 3
32054: LESS
32055: IFFALSE 32067
// max := 1 else
32057: LD_ADDR_VAR 0 8
32061: PUSH
32062: LD_INT 1
32064: ST_TO_ADDR
32065: GO 32085
// max := humans [ 3 ] - 2 ;
32067: LD_ADDR_VAR 0 8
32071: PUSH
32072: LD_EXP 76
32076: PUSH
32077: LD_INT 3
32079: ARRAY
32080: PUSH
32081: LD_INT 2
32083: MINUS
32084: ST_TO_ADDR
// if max > 3 then
32085: LD_VAR 0 8
32089: PUSH
32090: LD_INT 3
32092: GREATER
32093: IFFALSE 32103
// max := 3 ;
32095: LD_ADDR_VAR 0 8
32099: PUSH
32100: LD_INT 3
32102: ST_TO_ADDR
// take := CharacterSelection ( C-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 3 ] ^ [ sel_not_changeable ] ^ [ Tsaritsyn ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32103: LD_ADDR_VAR 0 5
32107: PUSH
32108: LD_STRING C-Base
32110: PPUSH
32111: LD_INT 1
32113: PPUSH
32114: LD_VAR 0 8
32118: PPUSH
32119: LD_VAR 0 4
32123: PUSH
32124: LD_INT -2
32126: PUSH
32127: LD_INT -3
32129: PUSH
32130: LD_INT -6
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: LIST
32137: ADD
32138: PUSH
32139: LD_EXP 76
32143: PUSH
32144: LD_INT 3
32146: ARRAY
32147: ADD
32148: PUSH
32149: LD_INT -4
32151: PUSH
32152: EMPTY
32153: LIST
32154: ADD
32155: PUSH
32156: LD_EXP 47
32160: PUSH
32161: EMPTY
32162: LIST
32163: ADD
32164: PPUSH
32165: LD_INT 1
32167: PUSH
32168: LD_INT 3
32170: PUSH
32171: LD_INT 2
32173: PUSH
32174: LD_INT 4
32176: PUSH
32177: LD_INT 9
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: PPUSH
32187: CALL_OW 42
32191: ST_TO_ADDR
// end ; ai_s [ 4 ] :
32192: GO 32603
32194: LD_EXP 23
32198: PUSH
32199: LD_INT 4
32201: ARRAY
32202: DOUBLE
32203: EQUAL
32204: IFTRUE 32208
32206: GO 32436
32208: POP
// begin if humans [ 4 ] < 3 then
32209: LD_EXP 76
32213: PUSH
32214: LD_INT 4
32216: ARRAY
32217: PUSH
32218: LD_INT 3
32220: LESS
32221: IFFALSE 32233
// max := 1 else
32223: LD_ADDR_VAR 0 8
32227: PUSH
32228: LD_INT 1
32230: ST_TO_ADDR
32231: GO 32251
// max := humans [ 4 ] - 2 ;
32233: LD_ADDR_VAR 0 8
32237: PUSH
32238: LD_EXP 76
32242: PUSH
32243: LD_INT 4
32245: ARRAY
32246: PUSH
32247: LD_INT 2
32249: MINUS
32250: ST_TO_ADDR
// if max > 2 then
32251: LD_VAR 0 8
32255: PUSH
32256: LD_INT 2
32258: GREATER
32259: IFFALSE 32269
// max := 2 ;
32261: LD_ADDR_VAR 0 8
32265: PUSH
32266: LD_INT 2
32268: ST_TO_ADDR
// t_sci := sci isect humans [ 4 ] ;
32269: LD_ADDR_VAR 0 9
32273: PUSH
32274: LD_EXP 88
32278: PUSH
32279: LD_EXP 76
32283: PUSH
32284: LD_INT 4
32286: ARRAY
32287: ISECT
32288: ST_TO_ADDR
// if t_sci > 3 then
32289: LD_VAR 0 9
32293: PUSH
32294: LD_INT 3
32296: GREATER
32297: IFFALSE 32333
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
32299: LD_ADDR_VAR 0 9
32303: PUSH
32304: LD_VAR 0 9
32308: PUSH
32309: LD_INT 1
32311: ARRAY
32312: PUSH
32313: LD_VAR 0 9
32317: PUSH
32318: LD_INT 2
32320: ARRAY
32321: ADD
32322: PUSH
32323: LD_VAR 0 9
32327: PUSH
32328: LD_INT 3
32330: ARRAY
32331: ADD
32332: ST_TO_ADDR
// take := CharacterSelection ( D-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ ( humans [ 4 ] diff t_sci ) ^ [ sel_not_changeable ] ^ t_sci ^ [ Davidov ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32333: LD_ADDR_VAR 0 5
32337: PUSH
32338: LD_STRING D-Base
32340: PPUSH
32341: LD_INT 1
32343: PPUSH
32344: LD_VAR 0 8
32348: PPUSH
32349: LD_VAR 0 4
32353: PUSH
32354: LD_INT -2
32356: PUSH
32357: LD_INT -3
32359: PUSH
32360: LD_INT -6
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: LIST
32367: ADD
32368: PUSH
32369: LD_EXP 76
32373: PUSH
32374: LD_INT 4
32376: ARRAY
32377: PUSH
32378: LD_VAR 0 9
32382: DIFF
32383: ADD
32384: PUSH
32385: LD_INT -4
32387: PUSH
32388: EMPTY
32389: LIST
32390: ADD
32391: PUSH
32392: LD_VAR 0 9
32396: ADD
32397: PUSH
32398: LD_EXP 48
32402: PUSH
32403: EMPTY
32404: LIST
32405: ADD
32406: PPUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 3
32412: PUSH
32413: LD_INT 2
32415: PUSH
32416: LD_INT 4
32418: PUSH
32419: LD_INT 9
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: PPUSH
32429: CALL_OW 42
32433: ST_TO_ADDR
// end ; ai_s [ 5 ] :
32434: GO 32603
32436: LD_EXP 23
32440: PUSH
32441: LD_INT 5
32443: ARRAY
32444: DOUBLE
32445: EQUAL
32446: IFTRUE 32450
32448: GO 32602
32450: POP
// begin if humans [ 5 ] < 3 then
32451: LD_EXP 76
32455: PUSH
32456: LD_INT 5
32458: ARRAY
32459: PUSH
32460: LD_INT 3
32462: LESS
32463: IFFALSE 32475
// max := 1 else
32465: LD_ADDR_VAR 0 8
32469: PUSH
32470: LD_INT 1
32472: ST_TO_ADDR
32473: GO 32493
// max := humans [ 5 ] - 2 ;
32475: LD_ADDR_VAR 0 8
32479: PUSH
32480: LD_EXP 76
32484: PUSH
32485: LD_INT 5
32487: ARRAY
32488: PUSH
32489: LD_INT 2
32491: MINUS
32492: ST_TO_ADDR
// if max > 5 then
32493: LD_VAR 0 8
32497: PUSH
32498: LD_INT 5
32500: GREATER
32501: IFFALSE 32511
// max := 5 ;
32503: LD_ADDR_VAR 0 8
32507: PUSH
32508: LD_INT 5
32510: ST_TO_ADDR
// take := CharacterSelection ( E-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 5 ] ^ [ sel_not_changeable ] ^ [ Eisenstein ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32511: LD_ADDR_VAR 0 5
32515: PUSH
32516: LD_STRING E-Base
32518: PPUSH
32519: LD_INT 1
32521: PPUSH
32522: LD_VAR 0 8
32526: PPUSH
32527: LD_VAR 0 4
32531: PUSH
32532: LD_INT -2
32534: PUSH
32535: LD_INT -3
32537: PUSH
32538: LD_INT -6
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: LIST
32545: ADD
32546: PUSH
32547: LD_EXP 76
32551: PUSH
32552: LD_INT 5
32554: ARRAY
32555: ADD
32556: PUSH
32557: LD_INT -4
32559: PUSH
32560: EMPTY
32561: LIST
32562: ADD
32563: PUSH
32564: LD_EXP 49
32568: PUSH
32569: EMPTY
32570: LIST
32571: ADD
32572: PPUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 3
32578: PUSH
32579: LD_INT 2
32581: PUSH
32582: LD_INT 4
32584: PUSH
32585: LD_INT 9
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: PPUSH
32595: CALL_OW 42
32599: ST_TO_ADDR
// end ; end ;
32600: GO 32603
32602: POP
// end ; ComExitVehicle ( take ) ;
32603: LD_VAR 0 5
32607: PPUSH
32608: CALL_OW 121
// AddComExitBuilding ( take ) ;
32612: LD_VAR 0 5
32616: PPUSH
32617: CALL_OW 182
// take := take union FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) ;
32621: LD_ADDR_VAR 0 5
32625: PUSH
32626: LD_VAR 0 5
32630: PUSH
32631: LD_INT 22
32633: PUSH
32634: LD_VAR 0 2
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 21
32645: PUSH
32646: LD_INT 2
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 33
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: LIST
32667: PPUSH
32668: CALL_OW 69
32672: UNION
32673: ST_TO_ADDR
// SetSide ( take , you ) ;
32674: LD_VAR 0 5
32678: PPUSH
32679: LD_EXP 7
32683: PPUSH
32684: CALL_OW 235
// end ;
32688: LD_VAR 0 3
32692: RET
// export function SetSideBase_custom ( base , side ) ; var b , depot , orig_side ; begin
32693: LD_INT 0
32695: PPUSH
32696: PPUSH
32697: PPUSH
32698: PPUSH
// depot = - 1 ;
32699: LD_ADDR_VAR 0 5
32703: PUSH
32704: LD_INT 1
32706: NEG
32707: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
32708: LD_ADDR_VAR 0 4
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: LD_INT 30
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 30
32728: PUSH
32729: LD_INT 1
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: LIST
32740: PUSH
32741: EMPTY
32742: LIST
32743: PPUSH
32744: CALL_OW 69
32748: PUSH
32749: FOR_IN
32750: IFFALSE 32783
// if GetBase ( b ) = base then
32752: LD_VAR 0 4
32756: PPUSH
32757: CALL_OW 274
32761: PUSH
32762: LD_VAR 0 1
32766: EQUAL
32767: IFFALSE 32781
// begin depot = b ;
32769: LD_ADDR_VAR 0 5
32773: PUSH
32774: LD_VAR 0 4
32778: ST_TO_ADDR
// break ;
32779: GO 32783
// end ;
32781: GO 32749
32783: POP
32784: POP
// orig_side = GetSide ( depot ) ;
32785: LD_ADDR_VAR 0 6
32789: PUSH
32790: LD_VAR 0 5
32794: PPUSH
32795: CALL_OW 255
32799: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , orig_side ] , [ f_type , unit_building ] ] ) diff depot do
32800: LD_ADDR_VAR 0 4
32804: PUSH
32805: LD_INT 22
32807: PUSH
32808: LD_VAR 0 6
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 21
32819: PUSH
32820: LD_INT 3
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PPUSH
32831: CALL_OW 69
32835: PUSH
32836: LD_VAR 0 5
32840: DIFF
32841: PUSH
32842: FOR_IN
32843: IFFALSE 32878
// if GetBase ( b ) = base then
32845: LD_VAR 0 4
32849: PPUSH
32850: CALL_OW 274
32854: PUSH
32855: LD_VAR 0 1
32859: EQUAL
32860: IFFALSE 32876
// SetSide ( b , side ) ;
32862: LD_VAR 0 4
32866: PPUSH
32867: LD_VAR 0 2
32871: PPUSH
32872: CALL_OW 235
32876: GO 32842
32878: POP
32879: POP
// SetSide ( depot , side ) ;
32880: LD_VAR 0 5
32884: PPUSH
32885: LD_VAR 0 2
32889: PPUSH
32890: CALL_OW 235
// end ; end_of_file
32894: LD_VAR 0 3
32898: RET
// every 0 0$2 + 0 0$0.1 do
32899: GO 32901
32901: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
32902: LD_INT 22
32904: PUSH
32905: LD_INT 3
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 2
32914: PUSH
32915: LD_INT 25
32917: PUSH
32918: LD_INT 12
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: LD_INT 25
32927: PUSH
32928: LD_INT 16
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 25
32937: PUSH
32938: LD_INT 15
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 25
32947: PUSH
32948: LD_INT 17
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PPUSH
32966: CALL_OW 69
32970: PUSH
32971: LD_INT 22
32973: PUSH
32974: LD_INT 3
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 21
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 3
32993: PUSH
32994: LD_INT 2
32996: PUSH
32997: LD_INT 25
32999: PUSH
33000: LD_INT 12
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 25
33009: PUSH
33010: LD_INT 16
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 25
33019: PUSH
33020: LD_INT 15
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 25
33029: PUSH
33030: LD_INT 17
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: LIST
33052: PPUSH
33053: CALL_OW 69
33057: GREATER
33058: IFFALSE 33069
// begin SetAchievement ( ACH_POTA ) ;
33060: LD_STRING ACH_POTA
33062: PPUSH
33063: CALL_OW 543
// exit ;
33067: GO 33070
// end ; enable ;
33069: ENABLE
// end ;
33070: END
// export function SA_OnMissionStart ; begin
33071: LD_INT 0
33073: PPUSH
// SetAchievement ( ACH_RPAT ) ;
33074: LD_STRING ACH_RPAT
33076: PPUSH
33077: CALL_OW 543
// end ;
33081: LD_VAR 0 1
33085: RET
// export function SA_OnTsaritsynQuizPerfectCleared ; begin
33086: LD_INT 0
33088: PPUSH
// SetAchievement ( ACH_CAD ) ;
33089: LD_STRING ACH_CAD
33091: PPUSH
33092: CALL_OW 543
// end ;
33096: LD_VAR 0 1
33100: RET

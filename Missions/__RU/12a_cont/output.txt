// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 4 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 4
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$40 , 0 0$30 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1400
 345: PUSH
 346: LD_INT 1050
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 1 1$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 2100
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
// uc_side = ally ;
 613: LD_ADDR_OWVAR 20
 617: PUSH
 618: LD_EXP 25
 622: ST_TO_ADDR
// uc_nation := nation_russian ;
 623: LD_ADDR_OWVAR 21
 627: PUSH
 628: LD_INT 3
 630: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 631: LD_ADDR_EXP 8
 635: PUSH
 636: LD_STRING Gossudarov
 638: PPUSH
 639: CALL 565 0 1
 643: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 644: LD_EXP 8
 648: PPUSH
 649: LD_INT 55
 651: PPUSH
 652: LD_INT 89
 654: PPUSH
 655: LD_INT 0
 657: PPUSH
 658: CALL_OW 48
// ComHold ( Gossudarov ) ;
 662: LD_EXP 8
 666: PPUSH
 667: CALL_OW 140
// uc_side = rus ;
 671: LD_ADDR_OWVAR 20
 675: PUSH
 676: LD_EXP 24
 680: ST_TO_ADDR
// uc_nation := nation_russian ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 3
 688: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 689: LD_ADDR_EXP 2
 693: PUSH
 694: LD_STRING Belkov
 696: PPUSH
 697: CALL 565 0 1
 701: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 702: LD_ADDR_EXP 3
 706: PUSH
 707: LD_STRING Gnyevko
 709: PPUSH
 710: CALL 565 0 1
 714: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 715: LD_ADDR_EXP 4
 719: PUSH
 720: LD_STRING Kirilenkova
 722: PPUSH
 723: CALL 565 0 1
 727: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_STRING Gleb
 735: PPUSH
 736: CALL 565 0 1
 740: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 741: LD_ADDR_EXP 6
 745: PUSH
 746: LD_STRING Petrosyan
 748: PPUSH
 749: CALL 565 0 1
 753: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 754: LD_ADDR_EXP 7
 758: PUSH
 759: LD_STRING Titov
 761: PPUSH
 762: CALL 565 0 1
 766: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_STRING Kovalyuk
 774: PPUSH
 775: CALL 565 0 1
 779: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 780: LD_ADDR_EXP 10
 784: PUSH
 785: LD_STRING Scholtze
 787: PPUSH
 788: CALL 565 0 1
 792: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 793: LD_ADDR_EXP 11
 797: PUSH
 798: LD_STRING Kuzmov
 800: PPUSH
 801: CALL 565 0 1
 805: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 806: LD_ADDR_EXP 12
 810: PUSH
 811: LD_STRING Karamazov
 813: PPUSH
 814: CALL 565 0 1
 818: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 819: LD_ADDR_EXP 13
 823: PUSH
 824: LD_STRING Petrovova
 826: PPUSH
 827: CALL 565 0 1
 831: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 832: LD_ADDR_EXP 14
 836: PUSH
 837: LD_STRING Lipschin
 839: PPUSH
 840: CALL 565 0 1
 844: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 845: LD_ADDR_EXP 15
 849: PUSH
 850: LD_STRING Dolgov
 852: PPUSH
 853: CALL 565 0 1
 857: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 858: LD_ADDR_EXP 16
 862: PUSH
 863: LD_STRING Xavier
 865: PPUSH
 866: CALL 565 0 1
 870: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 871: LD_ADDR_EXP 17
 875: PUSH
 876: LD_STRING Oblukov
 878: PPUSH
 879: CALL 565 0 1
 883: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 884: LD_ADDR_EXP 18
 888: PUSH
 889: LD_STRING Kozlov
 891: PPUSH
 892: CALL 565 0 1
 896: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 897: LD_ADDR_EXP 19
 901: PUSH
 902: LD_STRING Kapitsova
 904: PPUSH
 905: CALL 565 0 1
 909: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 910: LD_ADDR_EXP 39
 914: PUSH
 915: LD_EXP 3
 919: PUSH
 920: LD_EXP 2
 924: PUSH
 925: LD_EXP 4
 929: PUSH
 930: LD_EXP 5
 934: PUSH
 935: LD_EXP 6
 939: PUSH
 940: LD_EXP 7
 944: PUSH
 945: LD_EXP 9
 949: PUSH
 950: LD_EXP 10
 954: PUSH
 955: LD_EXP 11
 959: PUSH
 960: LD_EXP 12
 964: PUSH
 965: LD_EXP 13
 969: PUSH
 970: LD_EXP 14
 974: PUSH
 975: LD_EXP 15
 979: PUSH
 980: LD_EXP 16
 984: PUSH
 985: LD_EXP 17
 989: PUSH
 990: LD_EXP 18
 994: PUSH
 995: LD_EXP 19
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 0
1021: DIFF
1022: ST_TO_ADDR
// survivors3 = [ ] ;
1023: LD_ADDR_EXP 22
1027: PUSH
1028: EMPTY
1029: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1030: LD_STRING survivors3
1032: PPUSH
1033: CALL_OW 29
1037: IFFALSE 1052
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1039: LD_ADDR_EXP 22
1043: PUSH
1044: LD_STRING survivors3
1046: PPUSH
1047: CALL_OW 31
1051: ST_TO_ADDR
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1052: LD_ADDR_EXP 40
1056: PUSH
1057: LD_EXP 39
1061: PUSH
1062: LD_EXP 22
1066: ADD
1067: PPUSH
1068: LD_INT 25
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL_OW 72
1082: ST_TO_ADDR
// survivors3 = survivors3 diff scientists ;
1083: LD_ADDR_EXP 22
1087: PUSH
1088: LD_EXP 22
1092: PUSH
1093: LD_EXP 40
1097: DIFF
1098: ST_TO_ADDR
// if scientists > 5 then
1099: LD_EXP 40
1103: PUSH
1104: LD_INT 5
1106: GREATER
1107: IFFALSE 1153
// for i := 6 to scientists do
1109: LD_ADDR_LOC 2
1113: PUSH
1114: DOUBLE
1115: LD_INT 6
1117: DEC
1118: ST_TO_ADDR
1119: LD_EXP 40
1123: PUSH
1124: FOR_TO
1125: IFFALSE 1151
// scientists := scientists diff scientists [ i ] ;
1127: LD_ADDR_EXP 40
1131: PUSH
1132: LD_EXP 40
1136: PUSH
1137: LD_EXP 40
1141: PUSH
1142: LD_LOC 2
1146: ARRAY
1147: DIFF
1148: ST_TO_ADDR
1149: GO 1124
1151: POP
1152: POP
// if scientists < 5 then
1153: LD_EXP 40
1157: PUSH
1158: LD_INT 5
1160: LESS
1161: IFFALSE 1252
// for i := 1 to 5 - scientists do
1163: LD_ADDR_LOC 2
1167: PUSH
1168: DOUBLE
1169: LD_INT 1
1171: DEC
1172: ST_TO_ADDR
1173: LD_INT 5
1175: PUSH
1176: LD_EXP 40
1180: MINUS
1181: PUSH
1182: FOR_TO
1183: IFFALSE 1250
// begin uc_side = ally ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_EXP 25
1194: ST_TO_ADDR
// uc_nation := nation_russian ;
1195: LD_ADDR_OWVAR 21
1199: PUSH
1200: LD_INT 3
1202: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1203: LD_INT 0
1205: PPUSH
1206: LD_INT 4
1208: PPUSH
1209: LD_INT 5
1211: PPUSH
1212: LD_INT 7
1214: PPUSH
1215: CALL_OW 12
1219: PPUSH
1220: CALL_OW 380
// hc_name :=  ;
1224: LD_ADDR_OWVAR 26
1228: PUSH
1229: LD_STRING 
1231: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1232: LD_ADDR_EXP 40
1236: PUSH
1237: LD_EXP 40
1241: PUSH
1242: CALL_OW 44
1246: ADD
1247: ST_TO_ADDR
// end ;
1248: GO 1182
1250: POP
1251: POP
// for un in scientists do
1252: LD_ADDR_VAR 0 2
1256: PUSH
1257: LD_EXP 40
1261: PUSH
1262: FOR_IN
1263: IFFALSE 1281
// SetSide ( un , ally ) ;
1265: LD_VAR 0 2
1269: PPUSH
1270: LD_EXP 25
1274: PPUSH
1275: CALL_OW 235
1279: GO 1262
1281: POP
1282: POP
// possible := all_possible diff scientists ;
1283: LD_ADDR_EXP 38
1287: PUSH
1288: LD_EXP 39
1292: PUSH
1293: LD_EXP 40
1297: DIFF
1298: ST_TO_ADDR
// for un in scientists do
1299: LD_ADDR_VAR 0 2
1303: PUSH
1304: LD_EXP 40
1308: PUSH
1309: FOR_IN
1310: IFFALSE 1326
// PlaceHumanInUnit ( un , 2 ) ;
1312: LD_VAR 0 2
1316: PPUSH
1317: LD_INT 2
1319: PPUSH
1320: CALL_OW 52
1324: GO 1309
1326: POP
1327: POP
// new := [ ] ;
1328: LD_ADDR_EXP 36
1332: PUSH
1333: EMPTY
1334: ST_TO_ADDR
// if possible < 10 then
1335: LD_EXP 38
1339: PUSH
1340: LD_INT 10
1342: LESS
1343: IFFALSE 1426
// for i := 1 to 10 - possible do
1345: LD_ADDR_LOC 2
1349: PUSH
1350: DOUBLE
1351: LD_INT 1
1353: DEC
1354: ST_TO_ADDR
1355: LD_INT 10
1357: PUSH
1358: LD_EXP 38
1362: MINUS
1363: PUSH
1364: FOR_TO
1365: IFFALSE 1424
// begin uc_side = rus ;
1367: LD_ADDR_OWVAR 20
1371: PUSH
1372: LD_EXP 24
1376: ST_TO_ADDR
// uc_nation := nation_russian ;
1377: LD_ADDR_OWVAR 21
1381: PUSH
1382: LD_INT 3
1384: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1385: LD_INT 0
1387: PPUSH
1388: LD_INT 0
1390: PPUSH
1391: LD_INT 5
1393: PPUSH
1394: CALL_OW 380
// hc_name :=  ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING 
1405: ST_TO_ADDR
// new := new ^ CreateHuman ;
1406: LD_ADDR_EXP 36
1410: PUSH
1411: LD_EXP 36
1415: PUSH
1416: CALL_OW 44
1420: ADD
1421: ST_TO_ADDR
// end ;
1422: GO 1364
1424: POP
1425: POP
// uc_side = rus ;
1426: LD_ADDR_OWVAR 20
1430: PUSH
1431: LD_EXP 24
1435: ST_TO_ADDR
// uc_nation := nation_russian ;
1436: LD_ADDR_OWVAR 21
1440: PUSH
1441: LD_INT 3
1443: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1444: LD_ADDR_EXP 1
1448: PUSH
1449: LD_STRING Burlak
1451: PPUSH
1452: CALL 565 0 1
1456: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1457: LD_EXP 1
1461: PPUSH
1462: LD_INT 3
1464: PPUSH
1465: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1469: LD_ADDR_EXP 20
1473: PUSH
1474: LD_STRING Platonov
1476: PPUSH
1477: CALL_OW 25
1481: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1482: LD_INT 1
1484: PPUSH
1485: LD_INT 1
1487: PPUSH
1488: LD_INT 4
1490: PPUSH
1491: CALL_OW 380
// hc_name :=  ;
1495: LD_ADDR_OWVAR 26
1499: PUSH
1500: LD_STRING 
1502: ST_TO_ADDR
// RSoldier := CreateHuman ;
1503: LD_ADDR_EXP 21
1507: PUSH
1508: CALL_OW 44
1512: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1513: LD_ADDR_LOC 2
1517: PUSH
1518: DOUBLE
1519: LD_INT 1
1521: DEC
1522: ST_TO_ADDR
1523: LD_EXP 31
1527: PUSH
1528: LD_INT 3
1530: PUSH
1531: LD_EXP 30
1535: MUL
1536: PLUS
1537: PUSH
1538: FOR_TO
1539: IFFALSE 1631
// begin case Rand ( 1 , 2 ) of 1 :
1541: LD_INT 1
1543: PPUSH
1544: LD_INT 2
1546: PPUSH
1547: CALL_OW 12
1551: PUSH
1552: LD_INT 1
1554: DOUBLE
1555: EQUAL
1556: IFTRUE 1560
1558: GO 1578
1560: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1561: LD_INT 1
1563: PPUSH
1564: LD_INT 1
1566: PPUSH
1567: LD_EXP 32
1571: PPUSH
1572: CALL_OW 380
1576: GO 1605
1578: LD_INT 2
1580: DOUBLE
1581: EQUAL
1582: IFTRUE 1586
1584: GO 1604
1586: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 9
1592: PPUSH
1593: LD_EXP 32
1597: PPUSH
1598: CALL_OW 380
1602: GO 1605
1604: POP
// hc_name :=  ;
1605: LD_ADDR_OWVAR 26
1609: PUSH
1610: LD_STRING 
1612: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1613: LD_ADDR_EXP 29
1617: PUSH
1618: LD_EXP 29
1622: PUSH
1623: CALL_OW 44
1627: ADD
1628: ST_TO_ADDR
// end ;
1629: GO 1538
1631: POP
1632: POP
// end ;
1633: LD_VAR 0 1
1637: RET
// function select_people ; var units , un ; begin
1638: LD_INT 0
1640: PPUSH
1641: PPUSH
1642: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1643: LD_ADDR_EXP 41
1647: PUSH
1648: LD_STRING 
1650: PPUSH
1651: LD_INT 5
1653: PPUSH
1654: LD_INT 5
1656: PPUSH
1657: LD_INT -1
1659: PUSH
1660: LD_INT -4
1662: PUSH
1663: LD_INT -6
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_EXP 1
1675: ADD
1676: PUSH
1677: LD_INT -2
1679: PUSH
1680: LD_INT -4
1682: PUSH
1683: LD_INT -6
1685: PUSH
1686: EMPTY
1687: LIST
1688: LIST
1689: LIST
1690: ADD
1691: PUSH
1692: LD_EXP 20
1696: ADD
1697: PUSH
1698: LD_INT -2
1700: PUSH
1701: LD_INT -5
1703: PUSH
1704: LD_INT -3
1706: PUSH
1707: EMPTY
1708: LIST
1709: LIST
1710: LIST
1711: ADD
1712: PUSH
1713: LD_EXP 38
1717: ADD
1718: PUSH
1719: LD_EXP 22
1723: ADD
1724: PUSH
1725: LD_EXP 36
1729: ADD
1730: PPUSH
1731: LD_INT 1
1733: PUSH
1734: LD_INT 3
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: LD_INT 4
1742: PUSH
1743: LD_INT 9
1745: PUSH
1746: LD_INT 0
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: EMPTY
1753: LIST
1754: LIST
1755: LIST
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PPUSH
1764: CALL_OW 42
1768: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1769: LD_EXP 41
1773: PUSH
1774: LD_EXP 1
1778: DIFF
1779: PPUSH
1780: LD_EXP 27
1784: PPUSH
1785: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1789: LD_ADDR_VAR 0 3
1793: PUSH
1794: LD_EXP 41
1798: PUSH
1799: LD_EXP 1
1803: DIFF
1804: PUSH
1805: FOR_IN
1806: IFFALSE 1825
// PlaceUnitArea ( un , BaseArea , false ) ;
1808: LD_VAR 0 3
1812: PPUSH
1813: LD_INT 2
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 49
1823: GO 1805
1825: POP
1826: POP
// end ;
1827: LD_VAR 0 1
1831: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
1832: LD_INT 0
1834: PPUSH
1835: PPUSH
1836: PPUSH
1837: PPUSH
1838: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
1839: LD_ADDR_VAR 0 3
1843: PUSH
1844: LD_STRING EscapeVehicle_12a
1846: PPUSH
1847: LD_INT 1
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: LD_INT 0
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: PPUSH
1861: CALL_OW 30
1865: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
1866: LD_ADDR_LOC 1
1870: PUSH
1871: LD_VAR 0 3
1875: PUSH
1876: LD_INT 1
1878: ARRAY
1879: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_VAR 0 3
1889: PUSH
1890: LD_INT 2
1892: ARRAY
1893: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 3
1903: PUSH
1904: LD_INT 3
1906: ARRAY
1907: ST_TO_ADDR
// if MashaWanted then
1908: LD_LOC 1
1912: IFFALSE 2128
// begin veh := LoadVariable ( Masha , false ) ;
1914: LD_ADDR_VAR 0 2
1918: PUSH
1919: LD_STRING Masha
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 30
1929: ST_TO_ADDR
// if veh then
1930: LD_VAR 0 2
1934: IFFALSE 2050
// begin uc_side := rus ;
1936: LD_ADDR_OWVAR 20
1940: PUSH
1941: LD_EXP 24
1945: ST_TO_ADDR
// uc_nation := nation_russian ;
1946: LD_ADDR_OWVAR 21
1950: PUSH
1951: LD_INT 3
1953: ST_TO_ADDR
// uc_direction := 2 ;
1954: LD_ADDR_OWVAR 24
1958: PUSH
1959: LD_INT 2
1961: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
1962: LD_ADDR_OWVAR 37
1966: PUSH
1967: LD_VAR 0 2
1971: PUSH
1972: LD_INT 1
1974: ARRAY
1975: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
1976: LD_ADDR_OWVAR 39
1980: PUSH
1981: LD_VAR 0 2
1985: PUSH
1986: LD_INT 2
1988: ARRAY
1989: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
1990: LD_ADDR_OWVAR 38
1994: PUSH
1995: LD_VAR 0 2
1999: PUSH
2000: LD_INT 3
2002: ARRAY
2003: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2004: LD_ADDR_OWVAR 40
2008: PUSH
2009: LD_VAR 0 2
2013: PUSH
2014: LD_INT 4
2016: ARRAY
2017: ST_TO_ADDR
// RealMasha := true ;
2018: LD_ADDR_EXP 42
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// Masha := CreateVehicle ;
2026: LD_ADDR_EXP 43
2030: PUSH
2031: CALL_OW 45
2035: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
2036: LD_EXP 43
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 242
// end else
2048: GO 2126
// begin uc_side := rus ;
2050: LD_ADDR_OWVAR 20
2054: PUSH
2055: LD_EXP 24
2059: ST_TO_ADDR
// uc_nation := nation_russian ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 3
2067: ST_TO_ADDR
// uc_direction := 2 ;
2068: LD_ADDR_OWVAR 24
2072: PUSH
2073: LD_INT 2
2075: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2076: LD_ADDR_OWVAR 37
2080: PUSH
2081: LD_INT 22
2083: ST_TO_ADDR
// vc_engine := engine_siberite ;
2084: LD_ADDR_OWVAR 39
2088: PUSH
2089: LD_INT 3
2091: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 43
2099: ST_TO_ADDR
// vc_control := control_manual ;
2100: LD_ADDR_OWVAR 38
2104: PUSH
2105: LD_INT 1
2107: ST_TO_ADDR
// RealMasha := false ;
2108: LD_ADDR_EXP 42
2112: PUSH
2113: LD_INT 0
2115: ST_TO_ADDR
// Masha := CreateVehicle ;
2116: LD_ADDR_EXP 43
2120: PUSH
2121: CALL_OW 45
2125: ST_TO_ADDR
// end ; end else
2126: GO 2208
// begin uc_side := rus ;
2128: LD_ADDR_OWVAR 20
2132: PUSH
2133: LD_EXP 24
2137: ST_TO_ADDR
// uc_nation := nation_russian ;
2138: LD_ADDR_OWVAR 21
2142: PUSH
2143: LD_INT 3
2145: ST_TO_ADDR
// uc_direction := 2 ;
2146: LD_ADDR_OWVAR 24
2150: PUSH
2151: LD_INT 2
2153: ST_TO_ADDR
// vc_chassis := Chassis ;
2154: LD_ADDR_OWVAR 37
2158: PUSH
2159: LD_VAR 0 4
2163: ST_TO_ADDR
// vc_engine := engine_siberite ;
2164: LD_ADDR_OWVAR 39
2168: PUSH
2169: LD_INT 3
2171: ST_TO_ADDR
// vc_weapon := Weapon ;
2172: LD_ADDR_OWVAR 40
2176: PUSH
2177: LD_VAR 0 5
2181: ST_TO_ADDR
// vc_control := control_manual ;
2182: LD_ADDR_OWVAR 38
2186: PUSH
2187: LD_INT 1
2189: ST_TO_ADDR
// RealMasha := false ;
2190: LD_ADDR_EXP 42
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// Masha := CreateVehicle ;
2198: LD_ADDR_EXP 43
2202: PUSH
2203: CALL_OW 45
2207: ST_TO_ADDR
// end ; if GetEngine ( Masha ) <> engine_siberite then
2208: LD_EXP 43
2212: PPUSH
2213: CALL_OW 262
2217: PUSH
2218: LD_INT 3
2220: NONEQUAL
2221: IFFALSE 2243
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2223: LD_EXP 43
2227: PPUSH
2228: LD_INT 70
2230: PPUSH
2231: LD_INT 95
2233: PPUSH
2234: CALL_OW 12
2238: PPUSH
2239: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2243: LD_EXP 43
2247: PPUSH
2248: LD_INT 47
2250: PPUSH
2251: LD_INT 87
2253: PPUSH
2254: LD_INT 0
2256: PPUSH
2257: CALL_OW 48
// end ;
2261: LD_VAR 0 1
2265: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2266: LD_INT 1
2268: PPUSH
2269: LD_STRING bluekher
2271: PPUSH
2272: CALL_OW 500
// IngameOn ;
2276: CALL_OW 8
// Randomize ;
2280: CALL_OW 10
// RandomizeAll ;
2284: CALL_OW 11
// InitBc ;
2288: CALL_OW 21
// InitHc ;
2292: CALL_OW 19
// InitUc ;
2296: CALL_OW 18
// InitVc ;
2300: CALL_OW 20
// disable ( 1 ) ;
2304: LD_INT 1
2306: DISABLE_MARKED
// disable ( 2 ) ;
2307: LD_INT 2
2309: DISABLE_MARKED
// disable ( 3 ) ;
2310: LD_INT 3
2312: DISABLE_MARKED
// disable ( 4 ) ;
2313: LD_INT 4
2315: DISABLE_MARKED
// disable ( 6 ) ;
2316: LD_INT 6
2318: DISABLE_MARKED
// disable ( 7 ) ;
2319: LD_INT 7
2321: DISABLE_MARKED
// disable ( 8 ) ;
2322: LD_INT 8
2324: DISABLE_MARKED
// disable ( 9 ) ;
2325: LD_INT 9
2327: DISABLE_MARKED
// disable ( 333 ) ;
2328: LD_INT 333
2330: DISABLE_MARKED
// disable ( 337 ) ;
2331: LD_INT 337
2333: DISABLE_MARKED
// disable ( 401 ) ;
2334: LD_INT 401
2336: DISABLE_MARKED
// read_parameters ;
2337: CALL 0 0 0
// set_difficulty ;
2341: CALL 257 0 0
// create_people ;
2345: CALL 609 0 0
// select_people ;
2349: CALL 1638 0 0
// place_masha ;
2353: CALL 1832 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2357: LD_INT 53
2359: PPUSH
2360: LD_INT 90
2362: PPUSH
2363: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2367: LD_EXP 1
2371: PPUSH
2372: LD_INT 51
2374: PPUSH
2375: LD_INT 88
2377: PPUSH
2378: LD_INT 0
2380: PPUSH
2381: CALL_OW 48
// ComHold ( Burlak ) ;
2385: LD_EXP 1
2389: PPUSH
2390: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2394: LD_EXP 21
2398: PPUSH
2399: LD_INT 54
2401: PPUSH
2402: LD_INT 90
2404: PPUSH
2405: LD_INT 0
2407: PPUSH
2408: CALL_OW 48
// ComHold ( RSoldier ) ;
2412: LD_EXP 21
2416: PPUSH
2417: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2421: LD_EXP 1
2425: PPUSH
2426: LD_EXP 21
2430: PPUSH
2431: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2435: LD_EXP 21
2439: PPUSH
2440: LD_EXP 1
2444: PPUSH
2445: CALL_OW 119
// D_Platonov ;
2449: CALL 5052 0 0
// IngameOff ;
2453: CALL_OW 9
// SaveForQuickRestart ;
2457: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2461: LD_STRING MRun
2463: PPUSH
2464: CALL_OW 337
// ChangeSideFog ( you , you ) ;
2468: LD_EXP 23
2472: PPUSH
2473: LD_EXP 23
2477: PPUSH
2478: CALL_OW 343
// SetSide ( Burlak , you ) ;
2482: LD_EXP 1
2486: PPUSH
2487: LD_EXP 23
2491: PPUSH
2492: CALL_OW 235
// SetSide ( Masha , you ) ;
2496: LD_EXP 43
2500: PPUSH
2501: LD_EXP 23
2505: PPUSH
2506: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2510: LD_INT 1
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: CALL_OW 12
2520: PUSH
2521: LD_INT 1
2523: DOUBLE
2524: EQUAL
2525: IFTRUE 2529
2527: GO 2587
2529: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2530: LD_ADDR_LOC 2
2534: PUSH
2535: DOUBLE
2536: LD_EXP 31
2540: PUSH
2541: LD_INT 1
2543: PLUS
2544: DEC
2545: ST_TO_ADDR
2546: LD_EXP 31
2550: PUSH
2551: LD_EXP 30
2555: PLUS
2556: PUSH
2557: FOR_TO
2558: IFFALSE 2583
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2560: LD_EXP 29
2564: PUSH
2565: LD_LOC 2
2569: ARRAY
2570: PPUSH
2571: LD_INT 4
2573: PPUSH
2574: LD_INT 0
2576: PPUSH
2577: CALL_OW 49
2581: GO 2557
2583: POP
2584: POP
// end ; 2 :
2585: GO 2654
2587: LD_INT 2
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2595
2593: GO 2653
2595: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2596: LD_ADDR_LOC 2
2600: PUSH
2601: DOUBLE
2602: LD_EXP 31
2606: PUSH
2607: LD_INT 1
2609: PLUS
2610: DEC
2611: ST_TO_ADDR
2612: LD_EXP 31
2616: PUSH
2617: LD_EXP 30
2621: PLUS
2622: PUSH
2623: FOR_TO
2624: IFFALSE 2649
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2626: LD_EXP 29
2630: PUSH
2631: LD_LOC 2
2635: ARRAY
2636: PPUSH
2637: LD_INT 5
2639: PPUSH
2640: LD_INT 0
2642: PPUSH
2643: CALL_OW 49
2647: GO 2623
2649: POP
2650: POP
// end ; end ;
2651: GO 2654
2653: POP
// case Rand ( 1 , 2 ) of 1 :
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: CALL_OW 12
2664: PUSH
2665: LD_INT 1
2667: DOUBLE
2668: EQUAL
2669: IFTRUE 2673
2671: GO 2741
2673: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2674: LD_ADDR_LOC 2
2678: PUSH
2679: DOUBLE
2680: LD_EXP 31
2684: PUSH
2685: LD_INT 1
2687: PLUS
2688: PUSH
2689: LD_EXP 30
2693: PLUS
2694: DEC
2695: ST_TO_ADDR
2696: LD_EXP 31
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: LD_EXP 30
2708: MUL
2709: PLUS
2710: PUSH
2711: FOR_TO
2712: IFFALSE 2737
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2714: LD_EXP 29
2718: PUSH
2719: LD_LOC 2
2723: ARRAY
2724: PPUSH
2725: LD_INT 8
2727: PPUSH
2728: LD_INT 0
2730: PPUSH
2731: CALL_OW 49
2735: GO 2711
2737: POP
2738: POP
// end ; 2 :
2739: GO 2818
2741: LD_INT 2
2743: DOUBLE
2744: EQUAL
2745: IFTRUE 2749
2747: GO 2817
2749: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2750: LD_ADDR_LOC 2
2754: PUSH
2755: DOUBLE
2756: LD_EXP 31
2760: PUSH
2761: LD_INT 1
2763: PLUS
2764: PUSH
2765: LD_EXP 30
2769: PLUS
2770: DEC
2771: ST_TO_ADDR
2772: LD_EXP 31
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: LD_EXP 30
2784: MUL
2785: PLUS
2786: PUSH
2787: FOR_TO
2788: IFFALSE 2813
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
2790: LD_EXP 29
2794: PUSH
2795: LD_LOC 2
2799: ARRAY
2800: PPUSH
2801: LD_INT 7
2803: PPUSH
2804: LD_INT 0
2806: PPUSH
2807: CALL_OW 49
2811: GO 2787
2813: POP
2814: POP
// end ; end ;
2815: GO 2818
2817: POP
// case Rand ( 1 , 2 ) of 1 :
2818: LD_INT 1
2820: PPUSH
2821: LD_INT 2
2823: PPUSH
2824: CALL_OW 12
2828: PUSH
2829: LD_INT 1
2831: DOUBLE
2832: EQUAL
2833: IFTRUE 2837
2835: GO 2909
2837: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
2838: LD_ADDR_LOC 2
2842: PUSH
2843: DOUBLE
2844: LD_EXP 31
2848: PUSH
2849: LD_INT 1
2851: PLUS
2852: PUSH
2853: LD_INT 2
2855: PUSH
2856: LD_EXP 30
2860: MUL
2861: PLUS
2862: DEC
2863: ST_TO_ADDR
2864: LD_EXP 31
2868: PUSH
2869: LD_INT 3
2871: PUSH
2872: LD_EXP 30
2876: MUL
2877: PLUS
2878: PUSH
2879: FOR_TO
2880: IFFALSE 2905
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
2882: LD_EXP 29
2886: PUSH
2887: LD_LOC 2
2891: ARRAY
2892: PPUSH
2893: LD_INT 6
2895: PPUSH
2896: LD_INT 0
2898: PPUSH
2899: CALL_OW 49
2903: GO 2879
2905: POP
2906: POP
// end ; 2 :
2907: GO 2990
2909: LD_INT 2
2911: DOUBLE
2912: EQUAL
2913: IFTRUE 2917
2915: GO 2989
2917: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
2918: LD_ADDR_LOC 2
2922: PUSH
2923: DOUBLE
2924: LD_EXP 31
2928: PUSH
2929: LD_INT 1
2931: PLUS
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: LD_EXP 30
2940: MUL
2941: PLUS
2942: DEC
2943: ST_TO_ADDR
2944: LD_EXP 31
2948: PUSH
2949: LD_INT 3
2951: PUSH
2952: LD_EXP 30
2956: MUL
2957: PLUS
2958: PUSH
2959: FOR_TO
2960: IFFALSE 2985
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
2962: LD_EXP 29
2966: PUSH
2967: LD_LOC 2
2971: ARRAY
2972: PPUSH
2973: LD_INT 16
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: CALL_OW 49
2983: GO 2959
2985: POP
2986: POP
// end ; end ;
2987: GO 2990
2989: POP
// ComMoveXY ( Masha , 40 , 69 ) ;
2990: LD_EXP 43
2994: PPUSH
2995: LD_INT 40
2997: PPUSH
2998: LD_INT 69
3000: PPUSH
3001: CALL_OW 111
// Wait ( 1 1$0 ) ;
3005: LD_INT 2100
3007: PPUSH
3008: CALL_OW 67
// for i := 1 to pursuers_base do
3012: LD_ADDR_LOC 2
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_EXP 31
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3097
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3030: LD_EXP 29
3034: PUSH
3035: LD_LOC 2
3039: ARRAY
3040: PPUSH
3041: LD_INT 9
3043: PPUSH
3044: LD_INT 0
3046: PPUSH
3047: CALL_OW 49
3051: NOT
3052: IFFALSE 3075
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3054: LD_EXP 29
3058: PUSH
3059: LD_LOC 2
3063: ARRAY
3064: PPUSH
3065: LD_INT 3
3067: PPUSH
3068: LD_INT 0
3070: PPUSH
3071: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3075: LD_EXP 29
3079: PUSH
3080: LD_LOC 2
3084: ARRAY
3085: PPUSH
3086: LD_EXP 1
3090: PPUSH
3091: CALL_OW 115
// end ;
3095: GO 3027
3097: POP
3098: POP
// Wait ( straz_start ) ;
3099: LD_EXP 35
3103: PPUSH
3104: CALL_OW 67
// enable ( 1 ) ;
3108: LD_INT 1
3110: ENABLE_MARKED
// enable ( 2 ) ;
3111: LD_INT 2
3113: ENABLE_MARKED
// end ;
3114: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
3123: PPUSH
3124: PPUSH
3125: PPUSH
3126: PPUSH
3127: PPUSH
3128: PPUSH
3129: PPUSH
3130: PPUSH
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
3137: PPUSH
3138: PPUSH
3139: PPUSH
3140: PPUSH
// gained_medals := [ ] ;
3141: LD_ADDR_OWVAR 61
3145: PUSH
3146: EMPTY
3147: ST_TO_ADDR
// missing_medals := [ ] ;
3148: LD_ADDR_OWVAR 62
3152: PUSH
3153: EMPTY
3154: ST_TO_ADDR
// reward_units := [ ] ;
3155: LD_ADDR_VAR 0 5
3159: PUSH
3160: EMPTY
3161: ST_TO_ADDR
// if scientists_dead = 0 then
3162: LD_EXP 49
3166: PUSH
3167: LD_INT 0
3169: EQUAL
3170: IFFALSE 3184
// AddMedal ( Science , 1 ) else
3172: LD_STRING Science
3174: PPUSH
3175: LD_INT 1
3177: PPUSH
3178: CALL_OW 101
3182: GO 3195
// AddMedal ( Science , - 1 ) ;
3184: LD_STRING Science
3186: PPUSH
3187: LD_INT 1
3189: NEG
3190: PPUSH
3191: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3195: LD_ADDR_VAR 0 4
3199: PUSH
3200: LD_INT 22
3202: PUSH
3203: LD_EXP 23
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 2
3214: PUSH
3215: LD_INT 30
3217: PUSH
3218: LD_INT 0
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 30
3227: PUSH
3228: LD_INT 1
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 69
3248: ST_TO_ADDR
// matros := 0 ;
3249: LD_ADDR_VAR 0 2
3253: PUSH
3254: LD_INT 0
3256: ST_TO_ADDR
// if 0 + filter <> 0 then
3257: LD_INT 0
3259: PUSH
3260: LD_VAR 0 4
3264: PLUS
3265: PUSH
3266: LD_INT 0
3268: NONEQUAL
3269: IFFALSE 3317
// for un in filter do
3271: LD_ADDR_VAR 0 3
3275: PUSH
3276: LD_VAR 0 4
3280: PUSH
3281: FOR_IN
3282: IFFALSE 3315
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3284: LD_ADDR_VAR 0 2
3288: PUSH
3289: LD_VAR 0 2
3293: PUSH
3294: LD_VAR 0 3
3298: PPUSH
3299: CALL_OW 274
3303: PPUSH
3304: LD_INT 1
3306: PPUSH
3307: CALL_OW 275
3311: PLUS
3312: ST_TO_ADDR
3313: GO 3281
3315: POP
3316: POP
// if matros > 100 then
3317: LD_VAR 0 2
3321: PUSH
3322: LD_INT 100
3324: GREATER
3325: IFFALSE 3339
// AddMedal ( Effectivity , 1 ) else
3327: LD_STRING Effectivity
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: CALL_OW 101
3337: GO 3350
// AddMedal ( Effectivity , - 1 ) ;
3339: LD_STRING Effectivity
3341: PPUSH
3342: LD_INT 1
3344: NEG
3345: PPUSH
3346: CALL_OW 101
// rus_building_destroyed := false ;
3350: LD_ADDR_VAR 0 7
3354: PUSH
3355: LD_INT 0
3357: ST_TO_ADDR
// for un in rus_mcrep_bui do
3358: LD_ADDR_VAR 0 3
3362: PUSH
3363: LD_EXP 64
3367: PUSH
3368: FOR_IN
3369: IFFALSE 3399
// if not IsLive ( un ) then
3371: LD_VAR 0 3
3375: PPUSH
3376: CALL_OW 300
3380: NOT
3381: IFFALSE 3397
// rus_building_destroyed := rus_building_destroyed + 1 ;
3383: LD_ADDR_VAR 0 7
3387: PUSH
3388: LD_VAR 0 7
3392: PUSH
3393: LD_INT 1
3395: PLUS
3396: ST_TO_ADDR
3397: GO 3368
3399: POP
3400: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3401: LD_EXP 53
3405: PUSH
3406: LD_INT 5
3408: GREATEREQUAL
3409: PUSH
3410: LD_VAR 0 7
3414: PUSH
3415: LD_INT 2
3417: GREATEREQUAL
3418: OR
3419: IFFALSE 3434
// AddMedal ( LittleLosses , - 1 ) else
3421: LD_STRING LittleLosses
3423: PPUSH
3424: LD_INT 1
3426: NEG
3427: PPUSH
3428: CALL_OW 101
3432: GO 3444
// AddMedal ( LittleLosses , 1 ) ;
3434: LD_STRING LittleLosses
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 101
// GiveMedals ( Main ) ;
3444: LD_STRING Main
3446: PPUSH
3447: CALL_OW 102
// for un in player_units do
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: LD_EXP 41
3460: PUSH
3461: FOR_IN
3462: IFFALSE 3494
// if not IsDead ( un ) then
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 301
3473: NOT
3474: IFFALSE 3492
// reward_units := reward_units ^ un ;
3476: LD_ADDR_VAR 0 5
3480: PUSH
3481: LD_VAR 0 5
3485: PUSH
3486: LD_VAR 0 3
3490: ADD
3491: ST_TO_ADDR
3492: GO 3461
3494: POP
3495: POP
// RewardPeople ( reward_units ) ;
3496: LD_VAR 0 5
3500: PPUSH
3501: CALL_OW 43
// SaveCharacters ( scientists diff ( possible ^ Gossudarov ) , scientists ) ;
3505: LD_EXP 40
3509: PUSH
3510: LD_EXP 38
3514: PUSH
3515: LD_EXP 8
3519: ADD
3520: DIFF
3521: PPUSH
3522: LD_STRING scientists
3524: PPUSH
3525: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_EXP 41
3538: PUSH
3539: LD_EXP 39
3543: PUSH
3544: LD_EXP 40
3548: ADD
3549: PUSH
3550: LD_EXP 1
3554: ADD
3555: PUSH
3556: LD_EXP 8
3560: ADD
3561: DIFF
3562: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3563: LD_VAR 0 6
3567: PPUSH
3568: LD_STRING survivors5
3570: PPUSH
3571: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3575: LD_EXP 1
3579: PPUSH
3580: LD_STRING Burlak
3582: PPUSH
3583: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3587: LD_EXP 2
3591: PPUSH
3592: LD_STRING Belkov
3594: PPUSH
3595: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3599: LD_EXP 3
3603: PPUSH
3604: LD_STRING Gnyevko
3606: PPUSH
3607: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3611: LD_EXP 4
3615: PPUSH
3616: LD_STRING Kirilenkova
3618: PPUSH
3619: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3623: LD_EXP 5
3627: PPUSH
3628: LD_STRING Gleb
3630: PPUSH
3631: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3635: LD_EXP 6
3639: PPUSH
3640: LD_STRING Petrosyan
3642: PPUSH
3643: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3647: LD_EXP 7
3651: PPUSH
3652: LD_STRING Titov
3654: PPUSH
3655: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3659: LD_EXP 8
3663: PPUSH
3664: LD_STRING Gossudarov
3666: PPUSH
3667: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3671: LD_EXP 9
3675: PPUSH
3676: LD_STRING Kovalyuk
3678: PPUSH
3679: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3683: LD_EXP 10
3687: PPUSH
3688: LD_STRING Scholtze
3690: PPUSH
3691: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3695: LD_EXP 11
3699: PPUSH
3700: LD_STRING Kuzmov
3702: PPUSH
3703: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3707: LD_EXP 12
3711: PPUSH
3712: LD_STRING Karamazov
3714: PPUSH
3715: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3719: LD_EXP 13
3723: PPUSH
3724: LD_STRING Petrovova
3726: PPUSH
3727: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3731: LD_EXP 14
3735: PPUSH
3736: LD_STRING Lipshchin
3738: PPUSH
3739: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3743: LD_EXP 15
3747: PPUSH
3748: LD_STRING Dolgov
3750: PPUSH
3751: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
3755: LD_EXP 16
3759: PPUSH
3760: LD_STRING Xavier
3762: PPUSH
3763: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
3767: LD_EXP 17
3771: PPUSH
3772: LD_STRING Oblukov
3774: PPUSH
3775: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
3779: LD_EXP 18
3783: PPUSH
3784: LD_STRING Kozlov
3786: PPUSH
3787: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
3791: LD_EXP 19
3795: PPUSH
3796: LD_STRING Kapitsova
3798: PPUSH
3799: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
3803: LD_EXP 42
3807: PUSH
3808: LD_EXP 52
3812: AND
3813: PUSH
3814: LD_LOC 1
3818: NOT
3819: OR
3820: IFFALSE 3829
// DeleteVariable ( Masha ) ;
3822: LD_STRING Masha
3824: PPUSH
3825: CALL_OW 41
// if Belkov in scientists then
3829: LD_EXP 2
3833: PUSH
3834: LD_EXP 40
3838: IN
3839: IFFALSE 3851
// belkov_side := 2 else
3841: LD_ADDR_VAR 0 8
3845: PUSH
3846: LD_INT 2
3848: ST_TO_ADDR
3849: GO 3881
// if Belkov in player_units then
3851: LD_EXP 2
3855: PUSH
3856: LD_EXP 41
3860: IN
3861: IFFALSE 3873
// belkov_side := 1 else
3863: LD_ADDR_VAR 0 8
3867: PUSH
3868: LD_INT 1
3870: ST_TO_ADDR
3871: GO 3881
// belkov_side := 0 ;
3873: LD_ADDR_VAR 0 8
3877: PUSH
3878: LD_INT 0
3880: ST_TO_ADDR
// if Gnyevko in scientists then
3881: LD_EXP 3
3885: PUSH
3886: LD_EXP 40
3890: IN
3891: IFFALSE 3903
// gnyevko_side := 2 else
3893: LD_ADDR_VAR 0 9
3897: PUSH
3898: LD_INT 2
3900: ST_TO_ADDR
3901: GO 3933
// if Gnyevko in player_units then
3903: LD_EXP 3
3907: PUSH
3908: LD_EXP 41
3912: IN
3913: IFFALSE 3925
// gnyevko_side := 1 else
3915: LD_ADDR_VAR 0 9
3919: PUSH
3920: LD_INT 1
3922: ST_TO_ADDR
3923: GO 3933
// gnyevko_side := 0 ;
3925: LD_ADDR_VAR 0 9
3929: PUSH
3930: LD_INT 0
3932: ST_TO_ADDR
// if Kirilenkova in scientists then
3933: LD_EXP 4
3937: PUSH
3938: LD_EXP 40
3942: IN
3943: IFFALSE 3955
// kiril_side := 2 else
3945: LD_ADDR_VAR 0 10
3949: PUSH
3950: LD_INT 2
3952: ST_TO_ADDR
3953: GO 3985
// if Kirilenkova in player_units then
3955: LD_EXP 4
3959: PUSH
3960: LD_EXP 41
3964: IN
3965: IFFALSE 3977
// kiril_side := 1 else
3967: LD_ADDR_VAR 0 10
3971: PUSH
3972: LD_INT 1
3974: ST_TO_ADDR
3975: GO 3985
// kiril_side := 0 ;
3977: LD_ADDR_VAR 0 10
3981: PUSH
3982: LD_INT 0
3984: ST_TO_ADDR
// if Gleb in scientists then
3985: LD_EXP 5
3989: PUSH
3990: LD_EXP 40
3994: IN
3995: IFFALSE 4007
// gleb_side := 2 else
3997: LD_ADDR_VAR 0 16
4001: PUSH
4002: LD_INT 2
4004: ST_TO_ADDR
4005: GO 4037
// if Gleb in player_units then
4007: LD_EXP 5
4011: PUSH
4012: LD_EXP 41
4016: IN
4017: IFFALSE 4029
// gleb_side := 1 else
4019: LD_ADDR_VAR 0 16
4023: PUSH
4024: LD_INT 1
4026: ST_TO_ADDR
4027: GO 4037
// gleb_side := 0 ;
4029: LD_ADDR_VAR 0 16
4033: PUSH
4034: LD_INT 0
4036: ST_TO_ADDR
// if Petrosyan in scientists then
4037: LD_EXP 6
4041: PUSH
4042: LD_EXP 40
4046: IN
4047: IFFALSE 4059
// petros_side := 2 else
4049: LD_ADDR_VAR 0 15
4053: PUSH
4054: LD_INT 2
4056: ST_TO_ADDR
4057: GO 4089
// if Petrosyan in player_units then
4059: LD_EXP 6
4063: PUSH
4064: LD_EXP 41
4068: IN
4069: IFFALSE 4081
// petros_side := 1 else
4071: LD_ADDR_VAR 0 15
4075: PUSH
4076: LD_INT 1
4078: ST_TO_ADDR
4079: GO 4089
// petros_side := 0 ;
4081: LD_ADDR_VAR 0 15
4085: PUSH
4086: LD_INT 0
4088: ST_TO_ADDR
// if Titov in scientists then
4089: LD_EXP 7
4093: PUSH
4094: LD_EXP 40
4098: IN
4099: IFFALSE 4111
// titov_side := 2 else
4101: LD_ADDR_VAR 0 19
4105: PUSH
4106: LD_INT 2
4108: ST_TO_ADDR
4109: GO 4141
// if Titov in player_units then
4111: LD_EXP 7
4115: PUSH
4116: LD_EXP 41
4120: IN
4121: IFFALSE 4133
// titov_side := 1 else
4123: LD_ADDR_VAR 0 19
4127: PUSH
4128: LD_INT 1
4130: ST_TO_ADDR
4131: GO 4141
// titov_side := 0 ;
4133: LD_ADDR_VAR 0 19
4137: PUSH
4138: LD_INT 0
4140: ST_TO_ADDR
// if Kovalyuk in scientists then
4141: LD_EXP 9
4145: PUSH
4146: LD_EXP 40
4150: IN
4151: IFFALSE 4163
// kovalyuk_side := 2 else
4153: LD_ADDR_VAR 0 11
4157: PUSH
4158: LD_INT 2
4160: ST_TO_ADDR
4161: GO 4193
// if Kovalyuk in player_units then
4163: LD_EXP 9
4167: PUSH
4168: LD_EXP 41
4172: IN
4173: IFFALSE 4185
// kovalyuk_side := 1 else
4175: LD_ADDR_VAR 0 11
4179: PUSH
4180: LD_INT 1
4182: ST_TO_ADDR
4183: GO 4193
// kovalyuk_side := 0 ;
4185: LD_ADDR_VAR 0 11
4189: PUSH
4190: LD_INT 0
4192: ST_TO_ADDR
// if Scholtze in scientists then
4193: LD_EXP 10
4197: PUSH
4198: LD_EXP 40
4202: IN
4203: IFFALSE 4215
// scholtze_side := 2 else
4205: LD_ADDR_VAR 0 12
4209: PUSH
4210: LD_INT 2
4212: ST_TO_ADDR
4213: GO 4245
// if Scholtze in player_units then
4215: LD_EXP 10
4219: PUSH
4220: LD_EXP 41
4224: IN
4225: IFFALSE 4237
// scholtze_side := 1 else
4227: LD_ADDR_VAR 0 12
4231: PUSH
4232: LD_INT 1
4234: ST_TO_ADDR
4235: GO 4245
// scholtze_side := 0 ;
4237: LD_ADDR_VAR 0 12
4241: PUSH
4242: LD_INT 0
4244: ST_TO_ADDR
// if Kuzmov in scientists then
4245: LD_EXP 11
4249: PUSH
4250: LD_EXP 40
4254: IN
4255: IFFALSE 4267
// kuzmov_side := 2 else
4257: LD_ADDR_VAR 0 13
4261: PUSH
4262: LD_INT 2
4264: ST_TO_ADDR
4265: GO 4297
// if Kuzmov in player_units then
4267: LD_EXP 11
4271: PUSH
4272: LD_EXP 41
4276: IN
4277: IFFALSE 4289
// kuzmov_side := 1 else
4279: LD_ADDR_VAR 0 13
4283: PUSH
4284: LD_INT 1
4286: ST_TO_ADDR
4287: GO 4297
// kuzmov_side := 0 ;
4289: LD_ADDR_VAR 0 13
4293: PUSH
4294: LD_INT 0
4296: ST_TO_ADDR
// if Karamazov in scientists then
4297: LD_EXP 12
4301: PUSH
4302: LD_EXP 40
4306: IN
4307: IFFALSE 4319
// karam_side := 2 else
4309: LD_ADDR_VAR 0 14
4313: PUSH
4314: LD_INT 2
4316: ST_TO_ADDR
4317: GO 4349
// if Karamazov in player_units then
4319: LD_EXP 12
4323: PUSH
4324: LD_EXP 41
4328: IN
4329: IFFALSE 4341
// karam_side := 1 else
4331: LD_ADDR_VAR 0 14
4335: PUSH
4336: LD_INT 1
4338: ST_TO_ADDR
4339: GO 4349
// karam_side := 0 ;
4341: LD_ADDR_VAR 0 14
4345: PUSH
4346: LD_INT 0
4348: ST_TO_ADDR
// if Petrovova in scientists then
4349: LD_EXP 13
4353: PUSH
4354: LD_EXP 40
4358: IN
4359: IFFALSE 4371
// petrov_side := 2 else
4361: LD_ADDR_VAR 0 17
4365: PUSH
4366: LD_INT 2
4368: ST_TO_ADDR
4369: GO 4401
// if Petrovova in player_units then
4371: LD_EXP 13
4375: PUSH
4376: LD_EXP 41
4380: IN
4381: IFFALSE 4393
// petrov_side := 1 else
4383: LD_ADDR_VAR 0 17
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
4391: GO 4401
// petrov_side := 0 ;
4393: LD_ADDR_VAR 0 17
4397: PUSH
4398: LD_INT 0
4400: ST_TO_ADDR
// if Lipshchin in scientists then
4401: LD_EXP 14
4405: PUSH
4406: LD_EXP 40
4410: IN
4411: IFFALSE 4423
// lipshchin_side := 2 else
4413: LD_ADDR_VAR 0 18
4417: PUSH
4418: LD_INT 2
4420: ST_TO_ADDR
4421: GO 4453
// if Lipshchin in player_units then
4423: LD_EXP 14
4427: PUSH
4428: LD_EXP 41
4432: IN
4433: IFFALSE 4445
// lipshchin_side := 1 else
4435: LD_ADDR_VAR 0 18
4439: PUSH
4440: LD_INT 1
4442: ST_TO_ADDR
4443: GO 4453
// lipshchin_side := 0 ;
4445: LD_ADDR_VAR 0 18
4449: PUSH
4450: LD_INT 0
4452: ST_TO_ADDR
// if Dolgov in scientists then
4453: LD_EXP 15
4457: PUSH
4458: LD_EXP 40
4462: IN
4463: IFFALSE 4475
// dolgov_side := 2 else
4465: LD_ADDR_VAR 0 20
4469: PUSH
4470: LD_INT 2
4472: ST_TO_ADDR
4473: GO 4505
// if Dolgov in player_units then
4475: LD_EXP 15
4479: PUSH
4480: LD_EXP 41
4484: IN
4485: IFFALSE 4497
// dolgov_side := 1 else
4487: LD_ADDR_VAR 0 20
4491: PUSH
4492: LD_INT 1
4494: ST_TO_ADDR
4495: GO 4505
// dolgov_side := 0 ;
4497: LD_ADDR_VAR 0 20
4501: PUSH
4502: LD_INT 0
4504: ST_TO_ADDR
// if Xavier in scientists then
4505: LD_EXP 16
4509: PUSH
4510: LD_EXP 40
4514: IN
4515: IFFALSE 4527
// xavier_side := 2 else
4517: LD_ADDR_VAR 0 21
4521: PUSH
4522: LD_INT 2
4524: ST_TO_ADDR
4525: GO 4557
// if Xavier in player_units then
4527: LD_EXP 16
4531: PUSH
4532: LD_EXP 41
4536: IN
4537: IFFALSE 4549
// xavier_side := 1 else
4539: LD_ADDR_VAR 0 21
4543: PUSH
4544: LD_INT 1
4546: ST_TO_ADDR
4547: GO 4557
// xavier_side := 0 ;
4549: LD_ADDR_VAR 0 21
4553: PUSH
4554: LD_INT 0
4556: ST_TO_ADDR
// if Oblukov in scientists then
4557: LD_EXP 17
4561: PUSH
4562: LD_EXP 40
4566: IN
4567: IFFALSE 4579
// oblukov_side := 2 else
4569: LD_ADDR_VAR 0 22
4573: PUSH
4574: LD_INT 2
4576: ST_TO_ADDR
4577: GO 4609
// if Oblukov in player_units then
4579: LD_EXP 17
4583: PUSH
4584: LD_EXP 41
4588: IN
4589: IFFALSE 4601
// oblukov_side := 1 else
4591: LD_ADDR_VAR 0 22
4595: PUSH
4596: LD_INT 1
4598: ST_TO_ADDR
4599: GO 4609
// oblukov_side := 0 ;
4601: LD_ADDR_VAR 0 22
4605: PUSH
4606: LD_INT 0
4608: ST_TO_ADDR
// if Kozlov in scientists then
4609: LD_EXP 18
4613: PUSH
4614: LD_EXP 40
4618: IN
4619: IFFALSE 4631
// kozlov_side := 2 else
4621: LD_ADDR_VAR 0 23
4625: PUSH
4626: LD_INT 2
4628: ST_TO_ADDR
4629: GO 4661
// if Kozlov in player_units then
4631: LD_EXP 18
4635: PUSH
4636: LD_EXP 41
4640: IN
4641: IFFALSE 4653
// kozlov_side := 1 else
4643: LD_ADDR_VAR 0 23
4647: PUSH
4648: LD_INT 1
4650: ST_TO_ADDR
4651: GO 4661
// kozlov_side := 0 ;
4653: LD_ADDR_VAR 0 23
4657: PUSH
4658: LD_INT 0
4660: ST_TO_ADDR
// if Kapitsova in scientists then
4661: LD_EXP 19
4665: PUSH
4666: LD_EXP 40
4670: IN
4671: IFFALSE 4683
// kapitsova_side := 2 else
4673: LD_ADDR_VAR 0 24
4677: PUSH
4678: LD_INT 2
4680: ST_TO_ADDR
4681: GO 4713
// if Kapitsova in player_units then
4683: LD_EXP 19
4687: PUSH
4688: LD_EXP 41
4692: IN
4693: IFFALSE 4705
// kapitsova_side := 1 else
4695: LD_ADDR_VAR 0 24
4699: PUSH
4700: LD_INT 1
4702: ST_TO_ADDR
4703: GO 4713
// kapitsova_side := 0 ;
4705: LD_ADDR_VAR 0 24
4709: PUSH
4710: LD_INT 0
4712: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4713: LD_VAR 0 8
4717: PPUSH
4718: LD_STRING belkov_side
4720: PPUSH
4721: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4725: LD_VAR 0 9
4729: PPUSH
4730: LD_STRING gnyevko_side
4732: PPUSH
4733: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4737: LD_VAR 0 10
4741: PPUSH
4742: LD_STRING kiril_side
4744: PPUSH
4745: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4749: LD_VAR 0 16
4753: PPUSH
4754: LD_STRING gleb_side
4756: PPUSH
4757: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
4761: LD_VAR 0 15
4765: PPUSH
4766: LD_STRING petros_side
4768: PPUSH
4769: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
4773: LD_VAR 0 19
4777: PPUSH
4778: LD_STRING titov_side
4780: PPUSH
4781: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
4785: LD_VAR 0 11
4789: PPUSH
4790: LD_STRING kovalyuk_side
4792: PPUSH
4793: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
4797: LD_VAR 0 12
4801: PPUSH
4802: LD_STRING scholtze_side
4804: PPUSH
4805: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
4809: LD_VAR 0 13
4813: PPUSH
4814: LD_STRING kuzmov_side
4816: PPUSH
4817: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
4821: LD_VAR 0 14
4825: PPUSH
4826: LD_STRING karam_side
4828: PPUSH
4829: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
4833: LD_VAR 0 17
4837: PPUSH
4838: LD_STRING petrov_side
4840: PPUSH
4841: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
4845: LD_VAR 0 18
4849: PPUSH
4850: LD_STRING lipshchin_side
4852: PPUSH
4853: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
4857: LD_VAR 0 20
4861: PPUSH
4862: LD_STRING dolgov_side
4864: PPUSH
4865: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
4869: LD_VAR 0 21
4873: PPUSH
4874: LD_STRING xavier_side
4876: PPUSH
4877: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
4881: LD_VAR 0 22
4885: PPUSH
4886: LD_STRING oblukov_side
4888: PPUSH
4889: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
4893: LD_VAR 0 23
4897: PPUSH
4898: LD_STRING kozlov_side
4900: PPUSH
4901: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
4905: LD_VAR 0 24
4909: PPUSH
4910: LD_STRING kapitsova_side
4912: PPUSH
4913: CALL_OW 39
// YouWin ;
4917: CALL_OW 103
// exit ;
4921: GO 4923
// end ; end_of_file
4923: LD_VAR 0 1
4927: RET
// export function D_Start ; begin
4928: LD_INT 0
4930: PPUSH
// DisableExclamations ;
4931: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
4935: LD_EXP 8
4939: PPUSH
4940: LD_STRING DStart-Gos-1
4942: PPUSH
4943: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
4947: LD_EXP 1
4951: PPUSH
4952: LD_STRING DStart-Bur-1
4954: PPUSH
4955: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
4959: LD_EXP 8
4963: PPUSH
4964: LD_STRING DStart-Gos-2
4966: PPUSH
4967: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
4971: LD_EXP 1
4975: PPUSH
4976: LD_STRING DStart-Bur-2
4978: PPUSH
4979: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
4983: LD_EXP 8
4987: PPUSH
4988: LD_STRING DStart-Gos-3
4990: PPUSH
4991: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
4995: LD_EXP 1
4999: PPUSH
5000: LD_STRING DStart-Bur-3
5002: PPUSH
5003: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5007: LD_EXP 8
5011: PPUSH
5012: LD_STRING DStart-Gos-4
5014: PPUSH
5015: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5019: LD_EXP 1
5023: PPUSH
5024: LD_STRING DStart-Bur-4
5026: PPUSH
5027: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5031: LD_EXP 8
5035: PPUSH
5036: LD_STRING DStart-Gos-5
5038: PPUSH
5039: CALL_OW 88
// EnableExclamations ;
5043: CALL_OW 473
// end ;
5047: LD_VAR 0 1
5051: RET
// export function D_Platonov ; begin
5052: LD_INT 0
5054: PPUSH
// DisableExclamations ;
5055: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5059: LD_EXP 21
5063: PPUSH
5064: LD_STRING DPlatonov-Rsol1-1
5066: PPUSH
5067: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5071: LD_EXP 1
5075: PPUSH
5076: LD_STRING DPlatonov-Bur-1
5078: PPUSH
5079: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5083: LD_EXP 21
5087: PPUSH
5088: LD_STRING DPlatonov-Rsol1-2
5090: PPUSH
5091: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5095: LD_EXP 1
5099: PPUSH
5100: LD_STRING DPlatonov-Bur-2
5102: PPUSH
5103: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5107: LD_EXP 1
5111: PPUSH
5112: LD_EXP 43
5116: PPUSH
5117: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5121: LD_EXP 21
5125: PPUSH
5126: LD_STRING DPlatonov-Rsol1-3
5128: PPUSH
5129: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5133: LD_INT 7
5135: PPUSH
5136: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5140: LD_EXP 43
5144: PPUSH
5145: CALL_OW 311
5149: PUSH
5150: LD_EXP 1
5154: EQUAL
5155: IFFALSE 5133
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5157: LD_EXP 1
5161: PPUSH
5162: LD_STRING DPlatonov-Bur-3
5164: PPUSH
5165: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5169: LD_EXP 1
5173: PPUSH
5174: LD_EXP 21
5178: PPUSH
5179: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5183: LD_INT 7
5185: PPUSH
5186: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5190: LD_EXP 43
5194: PPUSH
5195: CALL_OW 320
5199: PUSH
5200: LD_EXP 21
5204: EQUAL
5205: IFFALSE 5183
// Wait ( 0 0$0.5 ) ;
5207: LD_INT 18
5209: PPUSH
5210: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5214: LD_EXP 21
5218: PPUSH
5219: LD_STRING DPlatonov-Rsol1-4
5221: PPUSH
5222: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5226: LD_EXP 21
5230: PPUSH
5231: LD_EXP 43
5235: PPUSH
5236: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5240: LD_EXP 1
5244: PPUSH
5245: LD_EXP 21
5249: PPUSH
5250: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5254: LD_EXP 20
5258: PPUSH
5259: LD_STRING DPlatonov-Pla-4
5261: PPUSH
5262: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5266: LD_EXP 20
5270: PPUSH
5271: LD_STRING DPlatonov-Pla-4a
5273: PPUSH
5274: CALL_OW 88
// EnableExclamations ;
5278: CALL_OW 473
// end ;
5282: LD_VAR 0 1
5286: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
5291: PPUSH
5292: PPUSH
// DisableExclamations ;
5293: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5297: LD_EXP 2
5301: PPUSH
5302: CALL_OW 302
5306: PUSH
5307: LD_EXP 2
5311: PPUSH
5312: CALL_OW 255
5316: PUSH
5317: LD_EXP 23
5321: EQUAL
5322: AND
5323: IFFALSE 5337
// Say ( Belkov , DGosStart-Bel-1 ) ;
5325: LD_EXP 2
5329: PPUSH
5330: LD_STRING DGosStart-Bel-1
5332: PPUSH
5333: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5337: LD_EXP 3
5341: PPUSH
5342: CALL_OW 302
5346: PUSH
5347: LD_EXP 3
5351: PPUSH
5352: CALL_OW 255
5356: PUSH
5357: LD_EXP 23
5361: EQUAL
5362: AND
5363: IFFALSE 5377
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5365: LD_EXP 3
5369: PPUSH
5370: LD_STRING DGosStart-Gny-1
5372: PPUSH
5373: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5377: LD_EXP 5
5381: PPUSH
5382: CALL_OW 302
5386: PUSH
5387: LD_EXP 5
5391: PPUSH
5392: CALL_OW 255
5396: PUSH
5397: LD_EXP 23
5401: EQUAL
5402: AND
5403: IFFALSE 5417
// Say ( Gleb , DGosStart-Glb-1 ) ;
5405: LD_EXP 5
5409: PPUSH
5410: LD_STRING DGosStart-Glb-1
5412: PPUSH
5413: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5417: LD_EXP 6
5421: PPUSH
5422: CALL_OW 302
5426: PUSH
5427: LD_EXP 6
5431: PPUSH
5432: CALL_OW 255
5436: PUSH
5437: LD_EXP 23
5441: EQUAL
5442: AND
5443: IFFALSE 5457
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5445: LD_EXP 6
5449: PPUSH
5450: LD_STRING DGosStart-Pty-1
5452: PPUSH
5453: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5457: LD_EXP 7
5461: PPUSH
5462: CALL_OW 302
5466: PUSH
5467: LD_EXP 7
5471: PPUSH
5472: CALL_OW 255
5476: PUSH
5477: LD_EXP 23
5481: EQUAL
5482: AND
5483: IFFALSE 5497
// Say ( Titov , DGosStart-Tit-1 ) ;
5485: LD_EXP 7
5489: PPUSH
5490: LD_STRING DGosStart-Tit-1
5492: PPUSH
5493: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5497: LD_EXP 4
5501: PPUSH
5502: CALL_OW 302
5506: PUSH
5507: LD_EXP 4
5511: PPUSH
5512: CALL_OW 255
5516: PUSH
5517: LD_EXP 23
5521: EQUAL
5522: AND
5523: IFFALSE 5537
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5525: LD_EXP 4
5529: PPUSH
5530: LD_STRING DGosStart-Kir-1
5532: PPUSH
5533: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5537: LD_EXP 2
5541: PPUSH
5542: CALL_OW 302
5546: PUSH
5547: LD_EXP 2
5551: PPUSH
5552: CALL_OW 255
5556: PUSH
5557: LD_EXP 23
5561: EQUAL
5562: AND
5563: PUSH
5564: LD_EXP 3
5568: PPUSH
5569: CALL_OW 302
5573: PUSH
5574: LD_EXP 3
5578: PPUSH
5579: CALL_OW 255
5583: PUSH
5584: LD_EXP 23
5588: EQUAL
5589: AND
5590: OR
5591: PUSH
5592: LD_EXP 5
5596: PPUSH
5597: CALL_OW 302
5601: PUSH
5602: LD_EXP 5
5606: PPUSH
5607: CALL_OW 255
5611: PUSH
5612: LD_EXP 23
5616: EQUAL
5617: AND
5618: OR
5619: PUSH
5620: LD_EXP 6
5624: PPUSH
5625: CALL_OW 302
5629: PUSH
5630: LD_EXP 6
5634: PPUSH
5635: CALL_OW 255
5639: PUSH
5640: LD_EXP 23
5644: EQUAL
5645: AND
5646: OR
5647: PUSH
5648: LD_EXP 7
5652: PPUSH
5653: CALL_OW 302
5657: PUSH
5658: LD_EXP 7
5662: PPUSH
5663: CALL_OW 255
5667: PUSH
5668: LD_EXP 23
5672: EQUAL
5673: AND
5674: OR
5675: PUSH
5676: LD_EXP 4
5680: PPUSH
5681: CALL_OW 302
5685: PUSH
5686: LD_EXP 4
5690: PPUSH
5691: CALL_OW 255
5695: PUSH
5696: LD_EXP 23
5700: EQUAL
5701: AND
5702: OR
5703: NOT
5704: IFFALSE 6068
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5706: LD_ADDR_VAR 0 4
5710: PUSH
5711: LD_INT 22
5713: PUSH
5714: LD_EXP 23
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 26
5725: PUSH
5726: LD_INT 1
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: LD_INT 50
5735: PUSH
5736: EMPTY
5737: LIST
5738: PUSH
5739: LD_INT 3
5741: PUSH
5742: LD_INT 23
5744: PUSH
5745: LD_INT 0
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PPUSH
5762: CALL_OW 69
5766: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
5767: LD_ADDR_VAR 0 4
5771: PUSH
5772: LD_VAR 0 4
5776: PUSH
5777: LD_EXP 1
5781: DIFF
5782: ST_TO_ADDR
// if 0 + filter_all > 0 then
5783: LD_INT 0
5785: PUSH
5786: LD_VAR 0 4
5790: PLUS
5791: PUSH
5792: LD_INT 0
5794: GREATER
5795: IFFALSE 5896
// begin filter := [ ] ;
5797: LD_ADDR_VAR 0 3
5801: PUSH
5802: EMPTY
5803: ST_TO_ADDR
// for un in filter_all do
5804: LD_ADDR_VAR 0 2
5808: PUSH
5809: LD_VAR 0 4
5813: PUSH
5814: FOR_IN
5815: IFFALSE 5848
// if not ( un in all_possible ) then
5817: LD_VAR 0 2
5821: PUSH
5822: LD_EXP 39
5826: IN
5827: NOT
5828: IFFALSE 5846
// filter := filter union un ;
5830: LD_ADDR_VAR 0 3
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_VAR 0 2
5844: UNION
5845: ST_TO_ADDR
5846: GO 5814
5848: POP
5849: POP
// if filter > 0 then
5850: LD_VAR 0 3
5854: PUSH
5855: LD_INT 0
5857: GREATER
5858: IFFALSE 5878
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
5860: LD_VAR 0 3
5864: PUSH
5865: LD_INT 1
5867: ARRAY
5868: PPUSH
5869: LD_STRING DGosStart-Sol1-1
5871: PPUSH
5872: CALL_OW 88
5876: GO 5894
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
5878: LD_VAR 0 4
5882: PUSH
5883: LD_INT 1
5885: ARRAY
5886: PPUSH
5887: LD_STRING DGosStart-Sol1-1
5889: PPUSH
5890: CALL_OW 88
// end else
5894: GO 6068
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5896: LD_ADDR_VAR 0 4
5900: PUSH
5901: LD_INT 22
5903: PUSH
5904: LD_EXP 23
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PUSH
5913: LD_INT 26
5915: PUSH
5916: LD_INT 2
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 50
5925: PUSH
5926: EMPTY
5927: LIST
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 23
5934: PUSH
5935: LD_INT 0
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: PPUSH
5952: CALL_OW 69
5956: ST_TO_ADDR
// if 0 + filter_all > 0 then
5957: LD_INT 0
5959: PUSH
5960: LD_VAR 0 4
5964: PLUS
5965: PUSH
5966: LD_INT 0
5968: GREATER
5969: IFFALSE 6068
// begin filter := [ ] ;
5971: LD_ADDR_VAR 0 3
5975: PUSH
5976: EMPTY
5977: ST_TO_ADDR
// for un in filter_all do
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_VAR 0 4
5987: PUSH
5988: FOR_IN
5989: IFFALSE 6022
// if not ( un in all_possible ) then
5991: LD_VAR 0 2
5995: PUSH
5996: LD_EXP 39
6000: IN
6001: NOT
6002: IFFALSE 6020
// filter := filter union un ;
6004: LD_ADDR_VAR 0 3
6008: PUSH
6009: LD_VAR 0 3
6013: PUSH
6014: LD_VAR 0 2
6018: UNION
6019: ST_TO_ADDR
6020: GO 5988
6022: POP
6023: POP
// if filter > 0 then
6024: LD_VAR 0 3
6028: PUSH
6029: LD_INT 0
6031: GREATER
6032: IFFALSE 6052
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6034: LD_VAR 0 3
6038: PUSH
6039: LD_INT 1
6041: ARRAY
6042: PPUSH
6043: LD_STRING DGosStart-FSol1-1
6045: PPUSH
6046: CALL_OW 88
6050: GO 6068
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6052: LD_VAR 0 4
6056: PUSH
6057: LD_INT 1
6059: ARRAY
6060: PPUSH
6061: LD_STRING DGosStart-FSol1-1
6063: PPUSH
6064: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6068: LD_EXP 1
6072: PPUSH
6073: LD_STRING DGosStart-Bur-1
6075: PPUSH
6076: CALL_OW 88
// Wait ( 0 0$20 ) ;
6080: LD_INT 700
6082: PPUSH
6083: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6087: LD_EXP 1
6091: PPUSH
6092: LD_STRING DGosStart-Bur-1a
6094: PPUSH
6095: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6099: LD_EXP 8
6103: PPUSH
6104: LD_STRING DGosStart-Gos-1
6106: PPUSH
6107: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6111: LD_EXP 1
6115: PPUSH
6116: LD_STRING DGosStart-Bur-2
6118: PPUSH
6119: CALL_OW 88
// Hint ( Signal ) ;
6123: LD_STRING Signal
6125: PPUSH
6126: CALL_OW 339
// attackAvalaible = 1 ;
6130: LD_ADDR_EXP 61
6134: PUSH
6135: LD_INT 1
6137: ST_TO_ADDR
// enable ( 6 ) ;
6138: LD_INT 6
6140: ENABLE_MARKED
// EnableExclamations ;
6141: CALL_OW 473
// end ;
6145: LD_VAR 0 1
6149: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6150: LD_INT 0
6152: PPUSH
6153: PPUSH
6154: PPUSH
6155: PPUSH
// DisableExclamations ;
6156: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6160: LD_EXP 1
6164: PPUSH
6165: LD_STRING DSituation-Bur-1
6167: PPUSH
6168: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6172: LD_ADDR_VAR 0 4
6176: PUSH
6177: LD_INT 22
6179: PUSH
6180: LD_EXP 23
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: LD_INT 26
6191: PUSH
6192: LD_INT 2
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 50
6201: PUSH
6202: EMPTY
6203: LIST
6204: PUSH
6205: LD_INT 3
6207: PUSH
6208: LD_INT 23
6210: PUSH
6211: LD_INT 0
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PPUSH
6228: CALL_OW 69
6232: ST_TO_ADDR
// if 0 + filter_all > 0 then
6233: LD_INT 0
6235: PUSH
6236: LD_VAR 0 4
6240: PLUS
6241: PUSH
6242: LD_INT 0
6244: GREATER
6245: IFFALSE 6346
// begin filter := [ ] ;
6247: LD_ADDR_VAR 0 3
6251: PUSH
6252: EMPTY
6253: ST_TO_ADDR
// for un in filter_all do
6254: LD_ADDR_VAR 0 2
6258: PUSH
6259: LD_VAR 0 4
6263: PUSH
6264: FOR_IN
6265: IFFALSE 6298
// if not ( un in all_possible ) then
6267: LD_VAR 0 2
6271: PUSH
6272: LD_EXP 39
6276: IN
6277: NOT
6278: IFFALSE 6296
// filter := filter union un ;
6280: LD_ADDR_VAR 0 3
6284: PUSH
6285: LD_VAR 0 3
6289: PUSH
6290: LD_VAR 0 2
6294: UNION
6295: ST_TO_ADDR
6296: GO 6264
6298: POP
6299: POP
// if filter > 0 then
6300: LD_VAR 0 3
6304: PUSH
6305: LD_INT 0
6307: GREATER
6308: IFFALSE 6328
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6310: LD_VAR 0 3
6314: PUSH
6315: LD_INT 1
6317: ARRAY
6318: PPUSH
6319: LD_STRING DSituation-RFSol1-1
6321: PPUSH
6322: CALL_OW 88
6326: GO 6344
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6328: LD_VAR 0 4
6332: PUSH
6333: LD_INT 1
6335: ARRAY
6336: PPUSH
6337: LD_STRING DSituation-RFSol1-1
6339: PPUSH
6340: CALL_OW 88
// end else
6344: GO 6534
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6346: LD_ADDR_VAR 0 4
6350: PUSH
6351: LD_INT 22
6353: PUSH
6354: LD_EXP 23
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 26
6365: PUSH
6366: LD_INT 1
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 50
6375: PUSH
6376: EMPTY
6377: LIST
6378: PUSH
6379: LD_INT 3
6381: PUSH
6382: LD_INT 23
6384: PUSH
6385: LD_INT 0
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6407: LD_ADDR_VAR 0 4
6411: PUSH
6412: LD_VAR 0 4
6416: PUSH
6417: LD_EXP 1
6421: DIFF
6422: ST_TO_ADDR
// if 0 + filter_all > 0 then
6423: LD_INT 0
6425: PUSH
6426: LD_VAR 0 4
6430: PLUS
6431: PUSH
6432: LD_INT 0
6434: GREATER
6435: IFFALSE 6534
// begin filter := [ ] ;
6437: LD_ADDR_VAR 0 3
6441: PUSH
6442: EMPTY
6443: ST_TO_ADDR
// for un in filter_all do
6444: LD_ADDR_VAR 0 2
6448: PUSH
6449: LD_VAR 0 4
6453: PUSH
6454: FOR_IN
6455: IFFALSE 6488
// if not ( un in all_possible ) then
6457: LD_VAR 0 2
6461: PUSH
6462: LD_EXP 39
6466: IN
6467: NOT
6468: IFFALSE 6486
// filter := filter union un ;
6470: LD_ADDR_VAR 0 3
6474: PUSH
6475: LD_VAR 0 3
6479: PUSH
6480: LD_VAR 0 2
6484: UNION
6485: ST_TO_ADDR
6486: GO 6454
6488: POP
6489: POP
// if filter > 0 then
6490: LD_VAR 0 3
6494: PUSH
6495: LD_INT 0
6497: GREATER
6498: IFFALSE 6518
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6500: LD_VAR 0 3
6504: PUSH
6505: LD_INT 1
6507: ARRAY
6508: PPUSH
6509: LD_STRING DSituation-RSol1-1
6511: PPUSH
6512: CALL_OW 88
6516: GO 6534
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6518: LD_VAR 0 4
6522: PUSH
6523: LD_INT 1
6525: ARRAY
6526: PPUSH
6527: LD_STRING DSituation-RSol1-1
6529: PPUSH
6530: CALL_OW 88
// end ; end ; EnableExclamations ;
6534: CALL_OW 473
// end ;
6538: LD_VAR 0 1
6542: RET
// export function D_GO1 ; begin
6543: LD_INT 0
6545: PPUSH
// DisableExclamations ;
6546: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6550: LD_EXP 1
6554: PPUSH
6555: LD_STRING DGO#1-Bur-1
6557: PPUSH
6558: CALL_OW 88
// EnableExclamations ;
6562: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6566: LD_INT 11
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: CALL_OW 424
// end ;
6576: LD_VAR 0 1
6580: RET
// export function D_SeeYou ; begin
6581: LD_INT 0
6583: PPUSH
// DisableExclamations ;
6584: CALL_OW 474
// DialogueOn ;
6588: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6592: LD_EXP 8
6596: PPUSH
6597: LD_STRING DSeeYou-Gos-1
6599: PPUSH
6600: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6604: LD_EXP 1
6608: PPUSH
6609: LD_STRING DSeeYou-Bur-1
6611: PPUSH
6612: CALL_OW 88
// DialogueOff ;
6616: CALL_OW 7
// EnableExclamations ;
6620: CALL_OW 473
// end ; end_of_file
6624: LD_VAR 0 1
6628: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6629: GO 6631
6631: DISABLE
6632: LD_INT 0
6634: PPUSH
6635: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6636: LD_EXP 1
6640: PPUSH
6641: LD_INT 1
6643: PPUSH
6644: CALL_OW 308
6648: IFFALSE 6714
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6650: LD_ADDR_VAR 0 1
6654: PUSH
6655: LD_INT 22
6657: PUSH
6658: LD_EXP 27
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 69
6671: ST_TO_ADDR
// for un in filter do
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: LD_VAR 0 1
6681: PUSH
6682: FOR_IN
6683: IFFALSE 6701
// setside ( un , you ) ;
6685: LD_VAR 0 2
6689: PPUSH
6690: LD_EXP 23
6694: PPUSH
6695: CALL_OW 235
6699: GO 6682
6701: POP
6702: POP
// BurlakReachedBase := true ;
6703: LD_ADDR_EXP 28
6707: PUSH
6708: LD_INT 1
6710: ST_TO_ADDR
// disable ;
6711: DISABLE
// end else
6712: GO 6715
// enable ;
6714: ENABLE
// end ;
6715: PPOPN 2
6717: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6718: GO 6720
6720: DISABLE
6721: LD_INT 0
6723: PPUSH
6724: PPUSH
6725: PPUSH
6726: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6727: LD_EXP 1
6731: PPUSH
6732: LD_INT 10
6734: PPUSH
6735: CALL_OW 308
6739: IFFALSE 6970
// begin DisableExclamations ;
6741: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6745: LD_ADDR_VAR 0 1
6749: PUSH
6750: LD_INT 22
6752: PUSH
6753: LD_EXP 27
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: PPUSH
6762: CALL_OW 69
6766: ST_TO_ADDR
// skill := 0 ;
6767: LD_ADDR_VAR 0 3
6771: PUSH
6772: LD_INT 0
6774: ST_TO_ADDR
// for un in filter do
6775: LD_ADDR_VAR 0 2
6779: PUSH
6780: LD_VAR 0 1
6784: PUSH
6785: FOR_IN
6786: IFFALSE 6820
// if GetSkill ( un , skill_engineering ) >= skill then
6788: LD_VAR 0 2
6792: PPUSH
6793: LD_INT 2
6795: PPUSH
6796: CALL_OW 259
6800: PUSH
6801: LD_VAR 0 3
6805: GREATEREQUAL
6806: IFFALSE 6818
// inzenyr := un ;
6808: LD_ADDR_VAR 0 4
6812: PUSH
6813: LD_VAR 0 2
6817: ST_TO_ADDR
6818: GO 6785
6820: POP
6821: POP
// ComStop ( inzenyr ) ;
6822: LD_VAR 0 4
6826: PPUSH
6827: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
6831: LD_VAR 0 4
6835: PPUSH
6836: CALL_OW 257
6840: PUSH
6841: LD_INT 2
6843: NONEQUAL
6844: IFFALSE 6935
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
6846: LD_ADDR_VAR 0 1
6850: PUSH
6851: LD_INT 30
6853: PUSH
6854: LD_INT 1
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PUSH
6861: LD_INT 22
6863: PUSH
6864: LD_EXP 27
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL_OW 69
6881: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
6882: LD_VAR 0 4
6886: PPUSH
6887: LD_VAR 0 1
6891: PUSH
6892: LD_INT 1
6894: ARRAY
6895: PPUSH
6896: CALL_OW 120
// Wait ( 10 ) ;
6900: LD_INT 10
6902: PPUSH
6903: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
6907: LD_VAR 0 4
6911: PPUSH
6912: LD_INT 2
6914: PPUSH
6915: CALL_OW 183
// Wait ( 10 ) ;
6919: LD_INT 10
6921: PPUSH
6922: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
6926: LD_VAR 0 4
6930: PPUSH
6931: CALL_OW 182
// end ; Wait ( 10 ) ;
6935: LD_INT 10
6937: PPUSH
6938: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
6942: LD_VAR 0 4
6946: PPUSH
6947: LD_INT 26
6949: PPUSH
6950: LD_INT 126
6952: PPUSH
6953: LD_INT 17
6955: PPUSH
6956: LD_INT 5
6958: PPUSH
6959: CALL_OW 205
// EnableExclamations ;
6963: CALL_OW 473
// disable ;
6967: DISABLE
// end else
6968: GO 6971
// enable ;
6970: ENABLE
// end ;
6971: PPOPN 4
6973: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
6974: GO 6976
6976: DISABLE
6977: LD_INT 0
6979: PPUSH
6980: PPUSH
// begin if straz < bazooker then
6981: LD_EXP 45
6985: PUSH
6986: LD_EXP 51
6990: LESS
6991: IFFALSE 7139
// begin bazooker := bazooker + 1 ;
6993: LD_ADDR_EXP 51
6997: PUSH
6998: LD_EXP 51
7002: PUSH
7003: LD_INT 1
7005: PLUS
7006: ST_TO_ADDR
// while straz < bazooker do
7007: LD_EXP 45
7011: PUSH
7012: LD_EXP 51
7016: LESS
7017: IFFALSE 7139
// begin uc_side := rus ;
7019: LD_ADDR_OWVAR 20
7023: PUSH
7024: LD_EXP 24
7028: ST_TO_ADDR
// uc_nation := nation_russian ;
7029: LD_ADDR_OWVAR 21
7033: PUSH
7034: LD_INT 3
7036: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 7 + difficulty ) ;
7037: LD_INT 1
7039: PPUSH
7040: LD_INT 9
7042: PPUSH
7043: LD_INT 7
7045: PUSH
7046: LD_OWVAR 67
7050: PLUS
7051: PPUSH
7052: CALL_OW 380
// hc_name :=  ;
7056: LD_ADDR_OWVAR 26
7060: PUSH
7061: LD_STRING 
7063: ST_TO_ADDR
// bazukr := CreateHuman ;
7064: LD_ADDR_VAR 0 2
7068: PUSH
7069: CALL_OW 44
7073: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7074: LD_EXP 62
7078: PPUSH
7079: LD_VAR 0 2
7083: PPUSH
7084: LD_INT 1
7086: PPUSH
7087: CALL_OW 394
// straz := straz ^ bazukr ;
7091: LD_ADDR_EXP 45
7095: PUSH
7096: LD_EXP 45
7100: PUSH
7101: LD_VAR 0 2
7105: ADD
7106: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7107: LD_VAR 0 2
7111: PPUSH
7112: LD_INT 9
7114: PPUSH
7115: LD_INT 0
7117: PPUSH
7118: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7122: LD_VAR 0 2
7126: PPUSH
7127: LD_INT 66
7129: PPUSH
7130: LD_INT 48
7132: PPUSH
7133: CALL_OW 114
// end ;
7137: GO 7007
// end ; end ;
7139: PPOPN 2
7141: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7142: GO 7144
7144: DISABLE
7145: LD_INT 0
7147: PPUSH
// begin if ( 0 + straz ) <> 0 then
7148: LD_INT 0
7150: PUSH
7151: LD_EXP 45
7155: PLUS
7156: PUSH
7157: LD_INT 0
7159: NONEQUAL
7160: IFFALSE 7403
// begin for un in straz do
7162: LD_ADDR_VAR 0 1
7166: PUSH
7167: LD_EXP 45
7171: PUSH
7172: FOR_IN
7173: IFFALSE 7401
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7175: LD_VAR 0 1
7179: PPUSH
7180: CALL_OW 314
7184: NOT
7185: PUSH
7186: LD_VAR 0 1
7190: PPUSH
7191: CALL_OW 256
7195: PUSH
7196: LD_INT 601
7198: GREATER
7199: AND
7200: IFFALSE 7399
// begin if GetY ( un ) > 60 then
7202: LD_VAR 0 1
7206: PPUSH
7207: CALL_OW 251
7211: PUSH
7212: LD_INT 60
7214: GREATER
7215: IFFALSE 7309
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7217: LD_VAR 0 1
7221: PPUSH
7222: LD_INT 66
7224: PPUSH
7225: LD_INT 48
7227: PPUSH
7228: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7232: LD_VAR 0 1
7236: PPUSH
7237: LD_INT 63
7239: PPUSH
7240: LD_INT 74
7242: PPUSH
7243: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7247: LD_VAR 0 1
7251: PPUSH
7252: LD_INT 73
7254: PPUSH
7255: LD_INT 90
7257: PPUSH
7258: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7262: LD_VAR 0 1
7266: PPUSH
7267: LD_INT 76
7269: PPUSH
7270: LD_INT 95
7272: PPUSH
7273: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7277: LD_VAR 0 1
7281: PPUSH
7282: LD_INT 72
7284: PPUSH
7285: LD_INT 95
7287: PPUSH
7288: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7292: LD_VAR 0 1
7296: PPUSH
7297: LD_INT 50
7299: PPUSH
7300: LD_INT 73
7302: PPUSH
7303: CALL_OW 174
// end else
7307: GO 7399
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7309: LD_VAR 0 1
7313: PPUSH
7314: LD_INT 73
7316: PPUSH
7317: LD_INT 90
7319: PPUSH
7320: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7324: LD_VAR 0 1
7328: PPUSH
7329: LD_INT 76
7331: PPUSH
7332: LD_INT 95
7334: PPUSH
7335: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_INT 72
7346: PPUSH
7347: LD_INT 95
7349: PPUSH
7350: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7354: LD_VAR 0 1
7358: PPUSH
7359: LD_INT 50
7361: PPUSH
7362: LD_INT 73
7364: PPUSH
7365: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7369: LD_VAR 0 1
7373: PPUSH
7374: LD_INT 63
7376: PPUSH
7377: LD_INT 74
7379: PPUSH
7380: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7384: LD_VAR 0 1
7388: PPUSH
7389: LD_INT 66
7391: PPUSH
7392: LD_INT 48
7394: PPUSH
7395: CALL_OW 174
// end ; end ; end ;
7399: GO 7172
7401: POP
7402: POP
// end ; enable ;
7403: ENABLE
// end ;
7404: PPOPN 1
7406: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7407: GO 7409
7409: DISABLE
7410: LD_INT 0
7412: PPUSH
7413: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7414: LD_EXP 1
7418: PPUSH
7419: LD_INT 2
7421: PPUSH
7422: CALL_OW 308
7426: IFFALSE 7470
// begin disabled5 := true ;
7428: LD_ADDR_LOC 4
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// D_GosStart ;
7436: CALL 5287 0 0
// Wait ( 0 0$5 ) ;
7440: LD_INT 175
7442: PPUSH
7443: CALL_OW 67
// D_Situation ;
7447: CALL 6150 0 0
// ChangeMissionObjectives ( MHold ) ;
7451: LD_STRING MHold
7453: PPUSH
7454: CALL_OW 337
// disable ;
7458: DISABLE
// enable ( 333 ) ;
7459: LD_INT 333
7461: ENABLE_MARKED
// enable ( 334 ) ;
7462: LD_INT 334
7464: ENABLE_MARKED
// enable ( 337 ) ;
7465: LD_INT 337
7467: ENABLE_MARKED
// end else
7468: GO 7471
// enable ;
7470: ENABLE
// end ;
7471: PPOPN 2
7473: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7474: GO 7476
7476: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7477: LD_EXP 8
7481: PPUSH
7482: CALL_OW 306
7486: PUSH
7487: LD_INT 1
7489: EQUAL
7490: IFFALSE 7516
// begin if WasSelected = false then
7492: LD_EXP 46
7496: PUSH
7497: LD_INT 0
7499: EQUAL
7500: IFFALSE 7514
// begin QueryQGO ;
7502: CALL 7533 0 0
// WasSelected := true ;
7506: LD_ADDR_EXP 46
7510: PUSH
7511: LD_INT 1
7513: ST_TO_ADDR
// end ; end else
7514: GO 7524
// WasSelected := false ;
7516: LD_ADDR_EXP 46
7520: PUSH
7521: LD_INT 0
7523: ST_TO_ADDR
// if not disabled3 then
7524: LD_LOC 3
7528: NOT
7529: IFFALSE 7532
// enable ;
7531: ENABLE
// end ;
7532: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7533: LD_INT 0
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
// res := Query ( QGO ) ;
7541: LD_ADDR_VAR 0 2
7545: PUSH
7546: LD_STRING QGO
7548: PPUSH
7549: CALL_OW 97
7553: ST_TO_ADDR
// if res = 1 then
7554: LD_VAR 0 2
7558: PUSH
7559: LD_INT 1
7561: EQUAL
7562: IFFALSE 7938
// begin disabled3 := true ;
7564: LD_ADDR_LOC 3
7568: PUSH
7569: LD_INT 1
7571: ST_TO_ADDR
// D_GO1 ;
7572: CALL 6543 0 0
// ChangeMissionObjectives ( MGuide ) ;
7576: LD_STRING MGuide
7578: PPUSH
7579: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7583: LD_ADDR_VAR 0 3
7587: PUSH
7588: LD_INT 3
7590: PPUSH
7591: LD_INT 21
7593: PUSH
7594: LD_INT 2
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 51
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL_OW 70
7619: ST_TO_ADDR
// if filter = 0 then
7620: LD_VAR 0 3
7624: PUSH
7625: LD_INT 0
7627: EQUAL
7628: IFFALSE 7779
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7630: LD_EXP 8
7634: PPUSH
7635: LD_INT 57
7637: PPUSH
7638: LD_INT 98
7640: PPUSH
7641: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7645: LD_INT 35
7647: PPUSH
7648: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7652: LD_EXP 8
7656: PPUSH
7657: CALL_OW 314
7661: NOT
7662: IFFALSE 7645
// RemoveUnit ( Gossudarov ) ;
7664: LD_EXP 8
7668: PPUSH
7669: CALL_OW 64
// uc_side := ally ;
7673: LD_ADDR_OWVAR 20
7677: PUSH
7678: LD_EXP 25
7682: ST_TO_ADDR
// uc_nation := nation_russian ;
7683: LD_ADDR_OWVAR 21
7687: PUSH
7688: LD_INT 3
7690: ST_TO_ADDR
// uc_direction := 5 ;
7691: LD_ADDR_OWVAR 24
7695: PUSH
7696: LD_INT 5
7698: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7699: LD_ADDR_OWVAR 37
7703: PUSH
7704: LD_INT 21
7706: ST_TO_ADDR
// vc_engine := engine_combustion ;
7707: LD_ADDR_OWVAR 39
7711: PUSH
7712: LD_INT 1
7714: ST_TO_ADDR
// vc_control := control_manual ;
7715: LD_ADDR_OWVAR 38
7719: PUSH
7720: LD_INT 1
7722: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7723: LD_ADDR_OWVAR 40
7727: PUSH
7728: LD_INT 51
7730: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7731: LD_ADDR_VAR 0 4
7735: PUSH
7736: CALL_OW 45
7740: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7741: LD_EXP 8
7745: PPUSH
7746: LD_VAR 0 4
7750: PPUSH
7751: CALL_OW 52
// Wait ( 0 0$5 ) ;
7755: LD_INT 175
7757: PPUSH
7758: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
7762: LD_VAR 0 4
7766: PPUSH
7767: LD_INT 9
7769: PPUSH
7770: LD_INT 0
7772: PPUSH
7773: CALL_OW 49
// end else
7777: GO 7797
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
7779: LD_EXP 8
7783: PPUSH
7784: LD_VAR 0 3
7788: PUSH
7789: LD_INT 1
7791: ARRAY
7792: PPUSH
7793: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
7797: LD_EXP 8
7801: PPUSH
7802: LD_INT 4
7804: PPUSH
7805: CALL_OW 469
7809: PUSH
7810: LD_INT 1
7812: ARRAY
7813: PPUSH
7814: LD_INT 4
7816: PPUSH
7817: CALL_OW 469
7821: PUSH
7822: LD_INT 2
7824: ARRAY
7825: PPUSH
7826: CALL_OW 220
// Wait ( 0 0$5 ) ;
7830: LD_INT 175
7832: PPUSH
7833: CALL_OW 67
// ComExitBuilding ( scientists ) ;
7837: LD_EXP 40
7841: PPUSH
7842: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
7846: LD_EXP 40
7850: PUSH
7851: LD_EXP 8
7855: ADD
7856: PPUSH
7857: LD_INT 50
7859: PPUSH
7860: LD_INT 58
7862: PPUSH
7863: CALL_OW 171
// for un in scientists ^ Gossudarov do
7867: LD_ADDR_VAR 0 6
7871: PUSH
7872: LD_EXP 40
7876: PUSH
7877: LD_EXP 8
7881: ADD
7882: PUSH
7883: FOR_IN
7884: IFFALSE 7902
// AddComSailEvent ( un , un ) ;
7886: LD_VAR 0 6
7890: PPUSH
7891: LD_VAR 0 6
7895: PPUSH
7896: CALL_OW 224
7900: GO 7883
7902: POP
7903: POP
// player_units := player_units union scientists union Gossudarov ;
7904: LD_ADDR_EXP 41
7908: PUSH
7909: LD_EXP 41
7913: PUSH
7914: LD_EXP 40
7918: UNION
7919: PUSH
7920: LD_EXP 8
7924: UNION
7925: ST_TO_ADDR
// enable ( 4 ) ;
7926: LD_INT 4
7928: ENABLE_MARKED
// enable ( 7 ) ;
7929: LD_INT 7
7931: ENABLE_MARKED
// enable ( 8 ) ;
7932: LD_INT 8
7934: ENABLE_MARKED
// enable ( 9 ) ;
7935: LD_INT 9
7937: ENABLE_MARKED
// end ; end ;
7938: LD_VAR 0 1
7942: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
7943: GO 7945
7945: DISABLE
7946: LD_INT 0
7948: PPUSH
// begin for un in scientists do
7949: LD_ADDR_VAR 0 1
7953: PUSH
7954: LD_EXP 40
7958: PUSH
7959: FOR_IN
7960: IFFALSE 8030
// begin if IsInArea ( un , ExitArea ) then
7962: LD_VAR 0 1
7966: PPUSH
7967: LD_INT 11
7969: PPUSH
7970: CALL_OW 308
7974: IFFALSE 8001
// begin scientists_saved := scientists_saved union un ;
7976: LD_ADDR_EXP 48
7980: PUSH
7981: LD_EXP 48
7985: PUSH
7986: LD_VAR 0 1
7990: UNION
7991: ST_TO_ADDR
// RemoveUnit ( un ) ;
7992: LD_VAR 0 1
7996: PPUSH
7997: CALL_OW 64
// end ; if IsDead ( un ) then
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 301
8010: IFFALSE 8028
// scientists_dead := scientists_dead union un ;
8012: LD_ADDR_EXP 49
8016: PUSH
8017: LD_EXP 49
8021: PUSH
8022: LD_VAR 0 1
8026: UNION
8027: ST_TO_ADDR
// end ;
8028: GO 7959
8030: POP
8031: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8032: LD_EXP 8
8036: PPUSH
8037: LD_INT 11
8039: PPUSH
8040: CALL_OW 308
8044: PUSH
8045: LD_EXP 8
8049: PPUSH
8050: CALL_OW 310
8054: PPUSH
8055: LD_INT 11
8057: PPUSH
8058: CALL_OW 308
8062: OR
8063: PUSH
8064: LD_EXP 48
8068: PUSH
8069: LD_EXP 49
8073: PLUS
8074: PUSH
8075: LD_EXP 40
8079: EQUAL
8080: AND
8081: PUSH
8082: LD_EXP 50
8086: PPUSH
8087: CALL_OW 255
8091: PUSH
8092: LD_EXP 23
8096: EQUAL
8097: AND
8098: PUSH
8099: LD_EXP 50
8103: PPUSH
8104: LD_INT 11
8106: PPUSH
8107: CALL_OW 308
8111: AND
8112: PUSH
8113: LD_EXP 50
8117: PPUSH
8118: LD_INT 4
8120: PPUSH
8121: CALL_OW 289
8125: PUSH
8126: LD_INT 40
8128: EQUAL
8129: AND
8130: IFFALSE 8142
// begin D_SeeYou ;
8132: CALL 6581 0 0
// TheEnd ;
8136: CALL 3115 0 0
// end else
8140: GO 8143
// enable ;
8142: ENABLE
// end ;
8143: PPOPN 1
8145: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8146: GO 8148
8148: DISABLE
8149: LD_INT 0
8151: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8152: LD_EXP 1
8156: PPUSH
8157: LD_INT 18
8159: PPUSH
8160: CALL_OW 308
8164: PUSH
8165: LD_EXP 43
8169: PPUSH
8170: LD_INT 18
8172: PPUSH
8173: CALL_OW 308
8177: OR
8178: IFFALSE 8195
// begin Wait ( 0 0$3 ) ;
8180: LD_INT 105
8182: PPUSH
8183: CALL_OW 67
// Attack1 := true ;
8187: LD_ADDR_LOC 5
8191: PUSH
8192: LD_INT 1
8194: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8195: LD_EXP 1
8199: PPUSH
8200: LD_INT 19
8202: PPUSH
8203: CALL_OW 308
8207: PUSH
8208: LD_EXP 43
8212: PPUSH
8213: LD_INT 19
8215: PPUSH
8216: CALL_OW 308
8220: OR
8221: IFFALSE 8238
// begin Wait ( 0 0$3 ) ;
8223: LD_INT 105
8225: PPUSH
8226: CALL_OW 67
// Attack2 := true ;
8230: LD_ADDR_LOC 6
8234: PUSH
8235: LD_INT 1
8237: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8238: LD_EXP 1
8242: PPUSH
8243: LD_INT 20
8245: PPUSH
8246: CALL_OW 308
8250: PUSH
8251: LD_EXP 43
8255: PPUSH
8256: LD_INT 20
8258: PPUSH
8259: CALL_OW 308
8263: OR
8264: IFFALSE 8281
// begin Wait ( 0 0$3 ) ;
8266: LD_INT 105
8268: PPUSH
8269: CALL_OW 67
// Attack3 := true ;
8273: LD_ADDR_LOC 7
8277: PUSH
8278: LD_INT 1
8280: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8281: LD_LOC 5
8285: PUSH
8286: LD_LOC 6
8290: NOT
8291: AND
8292: PUSH
8293: LD_LOC 7
8297: NOT
8298: AND
8299: IFFALSE 8362
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: DOUBLE
8307: LD_EXP 31
8311: PUSH
8312: LD_INT 1
8314: PLUS
8315: DEC
8316: ST_TO_ADDR
8317: LD_EXP 31
8321: PUSH
8322: LD_EXP 30
8326: PLUS
8327: PUSH
8328: FOR_TO
8329: IFFALSE 8360
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8331: LD_EXP 29
8335: PUSH
8336: LD_VAR 0 1
8340: ARRAY
8341: PPUSH
8342: LD_EXP 1
8346: PPUSH
8347: CALL_OW 115
// Wait ( 2 ) ;
8351: LD_INT 2
8353: PPUSH
8354: CALL_OW 67
// end ;
8358: GO 8328
8360: POP
8361: POP
// if Attack1 and Attack2 and not Attack3 then
8362: LD_LOC 5
8366: PUSH
8367: LD_LOC 6
8371: AND
8372: PUSH
8373: LD_LOC 7
8377: NOT
8378: AND
8379: IFFALSE 8446
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8381: LD_ADDR_VAR 0 1
8385: PUSH
8386: DOUBLE
8387: LD_EXP 31
8391: PUSH
8392: LD_INT 1
8394: PLUS
8395: DEC
8396: ST_TO_ADDR
8397: LD_EXP 31
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_EXP 30
8409: MUL
8410: PLUS
8411: PUSH
8412: FOR_TO
8413: IFFALSE 8444
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8415: LD_EXP 29
8419: PUSH
8420: LD_VAR 0 1
8424: ARRAY
8425: PPUSH
8426: LD_EXP 1
8430: PPUSH
8431: CALL_OW 115
// Wait ( 2 ) ;
8435: LD_INT 2
8437: PPUSH
8438: CALL_OW 67
// end ;
8442: GO 8412
8444: POP
8445: POP
// if Attack1 and Attack2 and Attack3 then
8446: LD_LOC 5
8450: PUSH
8451: LD_LOC 6
8455: AND
8456: PUSH
8457: LD_LOC 7
8461: AND
8462: IFFALSE 8529
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8464: LD_ADDR_VAR 0 1
8468: PUSH
8469: DOUBLE
8470: LD_EXP 31
8474: PUSH
8475: LD_INT 1
8477: PLUS
8478: DEC
8479: ST_TO_ADDR
8480: LD_EXP 31
8484: PUSH
8485: LD_INT 3
8487: PUSH
8488: LD_EXP 30
8492: MUL
8493: PLUS
8494: PUSH
8495: FOR_TO
8496: IFFALSE 8527
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8498: LD_EXP 29
8502: PUSH
8503: LD_VAR 0 1
8507: ARRAY
8508: PPUSH
8509: LD_EXP 1
8513: PPUSH
8514: CALL_OW 115
// Wait ( 2 ) ;
8518: LD_INT 2
8520: PPUSH
8521: CALL_OW 67
// end ;
8525: GO 8495
8527: POP
8528: POP
// for i := 1 to pursuers_base do
8529: LD_ADDR_VAR 0 1
8533: PUSH
8534: DOUBLE
8535: LD_INT 1
8537: DEC
8538: ST_TO_ADDR
8539: LD_EXP 31
8543: PUSH
8544: FOR_TO
8545: IFFALSE 8576
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8547: LD_EXP 29
8551: PUSH
8552: LD_VAR 0 1
8556: ARRAY
8557: PPUSH
8558: LD_EXP 1
8562: PPUSH
8563: CALL_OW 115
// Wait ( 2 ) ;
8567: LD_INT 2
8569: PPUSH
8570: CALL_OW 67
// end ;
8574: GO 8544
8576: POP
8577: POP
// if not disabled5 then
8578: LD_LOC 4
8582: NOT
8583: IFFALSE 8586
// enable ;
8585: ENABLE
// end ;
8586: PPOPN 1
8588: END
// every 0 0$1 marked 6 do
8589: GO 8591
8591: DISABLE
// begin if Goss_time > 0 then
8592: LD_EXP 47
8596: PUSH
8597: LD_INT 0
8599: GREATER
8600: IFFALSE 8636
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8602: LD_ADDR_OWVAR 47
8606: PUSH
8607: LD_STRING #Ru12a-1
8609: PUSH
8610: LD_EXP 47
8614: PUSH
8615: EMPTY
8616: LIST
8617: LIST
8618: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8619: LD_ADDR_EXP 47
8623: PUSH
8624: LD_EXP 47
8628: PUSH
8629: LD_INT 35
8631: MINUS
8632: ST_TO_ADDR
// enable ;
8633: ENABLE
// end else
8634: GO 8647
// begin display_strings :=  ;
8636: LD_ADDR_OWVAR 47
8640: PUSH
8641: LD_STRING 
8643: ST_TO_ADDR
// enable ( 3 ) ;
8644: LD_INT 3
8646: ENABLE_MARKED
// end ; end ;
8647: END
// every 0 0$1 marked 7 do
8648: GO 8650
8650: DISABLE
// begin if FindArtifact ( 4 ) then
8651: LD_INT 4
8653: PPUSH
8654: CALL_OW 469
8658: IFFALSE 8712
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8660: LD_LOC 8
8664: PPUSH
8665: LD_INT 4
8667: PPUSH
8668: CALL_OW 469
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PPUSH
8677: LD_INT 4
8679: PPUSH
8680: CALL_OW 469
8684: PUSH
8685: LD_INT 2
8687: ARRAY
8688: PPUSH
8689: CALL_OW 160
// Wait ( 3 ) ;
8693: LD_INT 3
8695: PPUSH
8696: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8700: LD_LOC 8
8704: PPUSH
8705: LD_INT 9
8707: PPUSH
8708: CALL_OW 173
// end ; enable ;
8712: ENABLE
// end ;
8713: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8714: GO 8716
8716: DISABLE
8717: LD_INT 0
8719: PPUSH
8720: PPUSH
8721: PPUSH
8722: PPUSH
// begin Wait ( pausa ) ;
8723: LD_EXP 37
8727: PPUSH
8728: CALL_OW 67
// sc_utok := [ ] ;
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: EMPTY
8738: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8739: LD_ADDR_VAR 0 1
8743: PUSH
8744: DOUBLE
8745: LD_INT 1
8747: DEC
8748: ST_TO_ADDR
8749: LD_INT 2
8751: PUSH
8752: LD_OWVAR 67
8756: PLUS
8757: PUSH
8758: FOR_TO
8759: IFFALSE 8963
// begin uc_side := rus ;
8761: LD_ADDR_OWVAR 20
8765: PUSH
8766: LD_EXP 24
8770: ST_TO_ADDR
// uc_nation := nation_russian ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 3
8778: ST_TO_ADDR
// uc_direction := 5 ;
8779: LD_ADDR_OWVAR 24
8783: PUSH
8784: LD_INT 5
8786: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
8787: LD_INT 1
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: CALL_OW 12
8797: PUSH
8798: LD_INT 1
8800: DOUBLE
8801: EQUAL
8802: IFTRUE 8806
8804: GO 8830
8806: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
8807: LD_INT 1
8809: PPUSH
8810: LD_INT 1
8812: PPUSH
8813: LD_INT 4
8815: PPUSH
8816: LD_INT 8
8818: PPUSH
8819: CALL_OW 12
8823: PPUSH
8824: CALL_OW 380
8828: GO 8869
8830: LD_INT 2
8832: DOUBLE
8833: GREATEREQUAL
8834: IFFALSE 8842
8836: LD_INT 3
8838: DOUBLE
8839: LESSEQUAL
8840: IFTRUE 8844
8842: GO 8868
8844: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
8845: LD_INT 1
8847: PPUSH
8848: LD_INT 9
8850: PPUSH
8851: LD_INT 3
8853: PPUSH
8854: LD_INT 7
8856: PPUSH
8857: CALL_OW 12
8861: PPUSH
8862: CALL_OW 380
8866: GO 8869
8868: POP
// hc_name :=  ;
8869: LD_ADDR_OWVAR 26
8873: PUSH
8874: LD_STRING 
8876: ST_TO_ADDR
// clovek := CreateHuman ;
8877: LD_ADDR_VAR 0 2
8881: PUSH
8882: CALL_OW 44
8886: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
8887: LD_VAR 0 2
8891: PPUSH
8892: LD_INT 9
8894: PPUSH
8895: LD_INT 0
8897: PPUSH
8898: CALL_OW 49
// Wait ( 0 0$2 ) ;
8902: LD_INT 70
8904: PPUSH
8905: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
8909: LD_VAR 0 2
8913: PPUSH
8914: LD_INT 50
8916: PPUSH
8917: LD_INT 84
8919: PPUSH
8920: CALL_OW 111
// Wait ( 2 ) ;
8924: LD_INT 2
8926: PPUSH
8927: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
8931: LD_VAR 0 2
8935: PPUSH
8936: LD_EXP 50
8940: PPUSH
8941: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
8945: LD_ADDR_VAR 0 3
8949: PUSH
8950: LD_VAR 0 3
8954: PUSH
8955: LD_VAR 0 2
8959: ADD
8960: ST_TO_ADDR
// end ;
8961: GO 8758
8963: POP
8964: POP
// Wait ( 0 0$10 ) ;
8965: LD_INT 350
8967: PPUSH
8968: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
8972: LD_LOC 8
8976: PPUSH
8977: CALL_OW 302
8981: NOT
8982: IFFALSE 9089
// begin uc_side := rus ;
8984: LD_ADDR_OWVAR 20
8988: PUSH
8989: LD_EXP 24
8993: ST_TO_ADDR
// uc_nation := nation_russian ;
8994: LD_ADDR_OWVAR 21
8998: PUSH
8999: LD_INT 3
9001: ST_TO_ADDR
// uc_direction := 5 ;
9002: LD_ADDR_OWVAR 24
9006: PUSH
9007: LD_INT 5
9009: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9010: LD_ADDR_OWVAR 37
9014: PUSH
9015: LD_INT 22
9017: ST_TO_ADDR
// vc_control := control_computer ;
9018: LD_ADDR_OWVAR 38
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// vc_engine := engine_siberite ;
9026: LD_ADDR_OWVAR 39
9030: PUSH
9031: LD_INT 3
9033: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9034: LD_ADDR_OWVAR 40
9038: PUSH
9039: LD_INT 51
9041: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9042: LD_ADDR_LOC 8
9046: PUSH
9047: CALL_OW 45
9051: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9052: LD_LOC 8
9056: PPUSH
9057: LD_INT 9
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9067: LD_INT 18
9069: PPUSH
9070: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9074: LD_LOC 8
9078: PPUSH
9079: LD_INT 55
9081: PPUSH
9082: LD_INT 84
9084: PPUSH
9085: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9089: LD_VAR 0 3
9093: PUSH
9094: LD_LOC 8
9098: PPUSH
9099: CALL_OW 302
9103: AND
9104: IFFALSE 9174
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: LD_EXP 50
9115: PPUSH
9116: CALL_OW 115
// Wait ( 0 0$2 ) ;
9120: LD_INT 70
9122: PPUSH
9123: CALL_OW 67
// for un in sc_utok do
9127: LD_ADDR_VAR 0 4
9131: PUSH
9132: LD_VAR 0 3
9136: PUSH
9137: FOR_IN
9138: IFFALSE 9170
// if not IsOK ( un ) then
9140: LD_VAR 0 4
9144: PPUSH
9145: CALL_OW 302
9149: NOT
9150: IFFALSE 9168
// sc_utok := sc_utok diff un ;
9152: LD_ADDR_VAR 0 3
9156: PUSH
9157: LD_VAR 0 3
9161: PUSH
9162: LD_VAR 0 4
9166: DIFF
9167: ST_TO_ADDR
9168: GO 9137
9170: POP
9171: POP
// end ;
9172: GO 9089
// Wait ( 0 0$5 ) ;
9174: LD_INT 175
9176: PPUSH
9177: CALL_OW 67
// enable ;
9181: ENABLE
// end ;
9182: PPOPN 4
9184: END
// every 0 0$3 marked 9 do
9185: GO 9187
9187: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9188: LD_LOC 8
9192: PPUSH
9193: LD_INT 3
9195: PPUSH
9196: CALL_OW 308
9200: PUSH
9201: LD_LOC 8
9205: PPUSH
9206: LD_INT 4
9208: PPUSH
9209: CALL_OW 289
9213: PUSH
9214: LD_INT 40
9216: EQUAL
9217: AND
9218: IFFALSE 9227
// YouLost ( Artefact ) ;
9220: LD_STRING Artefact
9222: PPUSH
9223: CALL_OW 104
// enable ;
9227: ENABLE
// end ;
9228: END
// on UnitDestroyed ( human ) do var i , un ;
9229: LD_INT 0
9231: PPUSH
9232: PPUSH
// begin if human = Burlak then
9233: LD_VAR 0 1
9237: PUSH
9238: LD_EXP 1
9242: EQUAL
9243: IFFALSE 9252
// YouLost ( Burlak ) ;
9245: LD_STRING Burlak
9247: PPUSH
9248: CALL_OW 104
// if human = Gossudarov then
9252: LD_VAR 0 1
9256: PUSH
9257: LD_EXP 8
9261: EQUAL
9262: IFFALSE 9271
// YouLost ( Gossudarov ) ;
9264: LD_STRING Gossudarov
9266: PPUSH
9267: CALL_OW 104
// if un = Masha then
9271: LD_VAR 0 3
9275: PUSH
9276: LD_EXP 43
9280: EQUAL
9281: IFFALSE 9291
// lost_masha := true ;
9283: LD_ADDR_EXP 52
9287: PUSH
9288: LD_INT 1
9290: ST_TO_ADDR
// if human in straz then
9291: LD_VAR 0 1
9295: PUSH
9296: LD_EXP 45
9300: IN
9301: IFFALSE 9350
// begin straz := straz diff human ;
9303: LD_ADDR_EXP 45
9307: PUSH
9308: LD_EXP 45
9312: PUSH
9313: LD_VAR 0 1
9317: DIFF
9318: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9319: LD_EXP 62
9323: PPUSH
9324: LD_VAR 0 1
9328: PPUSH
9329: LD_INT 1
9331: PPUSH
9332: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9336: LD_ADDR_EXP 53
9340: PUSH
9341: LD_EXP 53
9345: PUSH
9346: LD_INT 1
9348: PLUS
9349: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9350: LD_VAR 0 1
9354: PPUSH
9355: CALL_OW 255
9359: PUSH
9360: LD_INT 3
9362: EQUAL
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_EXP 60
9373: IN
9374: AND
9375: IFFALSE 9422
// begin for i in attackGroup do
9377: LD_ADDR_VAR 0 2
9381: PUSH
9382: LD_EXP 60
9386: PUSH
9387: FOR_IN
9388: IFFALSE 9420
// if i = human then
9390: LD_VAR 0 2
9394: PUSH
9395: LD_VAR 0 1
9399: EQUAL
9400: IFFALSE 9418
// attackGroup = attackGroup diff i ;
9402: LD_ADDR_EXP 60
9406: PUSH
9407: LD_EXP 60
9411: PUSH
9412: LD_VAR 0 2
9416: DIFF
9417: ST_TO_ADDR
9418: GO 9387
9420: POP
9421: POP
// end ; end ;
9422: PPOPN 3
9424: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9425: LD_VAR 0 1
9429: PUSH
9430: LD_EXP 8
9434: EQUAL
9435: IFFALSE 9456
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9437: LD_EXP 8
9441: PPUSH
9442: CALL_OW 310
9446: PPUSH
9447: LD_EXP 23
9451: PPUSH
9452: CALL_OW 235
// SetSide ( num , you ) ;
9456: LD_VAR 0 1
9460: PPUSH
9461: LD_EXP 23
9465: PPUSH
9466: CALL_OW 235
// end ;
9470: PPOPN 1
9472: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9473: LD_VAR 0 1
9477: PPUSH
9478: CALL_OW 255
9482: PUSH
9483: LD_EXP 24
9487: NONEQUAL
9488: IFFALSE 9500
// Artifact_cargo := un ;
9490: LD_ADDR_EXP 50
9494: PUSH
9495: LD_VAR 0 1
9499: ST_TO_ADDR
// end ; end_of_file
9500: PPOPN 2
9502: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9503: GO 9505
9505: DISABLE
9506: LD_INT 0
9508: PPUSH
9509: PPUSH
9510: PPUSH
9511: PPUSH
9512: PPUSH
9513: PPUSH
9514: PPUSH
// begin case tick of 0 .. 30000 :
9515: LD_OWVAR 1
9519: PUSH
9520: LD_INT 0
9522: DOUBLE
9523: GREATEREQUAL
9524: IFFALSE 9532
9526: LD_INT 30000
9528: DOUBLE
9529: LESSEQUAL
9530: IFTRUE 9534
9532: GO 9544
9534: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9535: LD_INT 1050
9537: PPUSH
9538: CALL_OW 67
9542: GO 9720
9544: LD_INT 30001
9546: DOUBLE
9547: GREATEREQUAL
9548: IFFALSE 9556
9550: LD_INT 50000
9552: DOUBLE
9553: LESSEQUAL
9554: IFTRUE 9558
9556: GO 9568
9558: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9559: LD_INT 1575
9561: PPUSH
9562: CALL_OW 67
9566: GO 9720
9568: LD_INT 50001
9570: DOUBLE
9571: GREATEREQUAL
9572: IFFALSE 9580
9574: LD_INT 70000
9576: DOUBLE
9577: LESSEQUAL
9578: IFTRUE 9582
9580: GO 9592
9582: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9583: LD_INT 2100
9585: PPUSH
9586: CALL_OW 67
9590: GO 9720
9592: LD_INT 70001
9594: DOUBLE
9595: GREATEREQUAL
9596: IFFALSE 9604
9598: LD_INT 90000
9600: DOUBLE
9601: LESSEQUAL
9602: IFTRUE 9606
9604: GO 9616
9606: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9607: LD_INT 2625
9609: PPUSH
9610: CALL_OW 67
9614: GO 9720
9616: LD_INT 70001
9618: DOUBLE
9619: GREATEREQUAL
9620: IFFALSE 9628
9622: LD_INT 90000
9624: DOUBLE
9625: LESSEQUAL
9626: IFTRUE 9630
9628: GO 9640
9630: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9631: LD_INT 3150
9633: PPUSH
9634: CALL_OW 67
9638: GO 9720
9640: LD_INT 90001
9642: DOUBLE
9643: GREATEREQUAL
9644: IFFALSE 9652
9646: LD_INT 110000
9648: DOUBLE
9649: LESSEQUAL
9650: IFTRUE 9654
9652: GO 9664
9654: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9655: LD_INT 3675
9657: PPUSH
9658: CALL_OW 67
9662: GO 9720
9664: LD_INT 110001
9666: DOUBLE
9667: GREATEREQUAL
9668: IFFALSE 9676
9670: LD_INT 130000
9672: DOUBLE
9673: LESSEQUAL
9674: IFTRUE 9678
9676: GO 9688
9678: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9679: LD_INT 4200
9681: PPUSH
9682: CALL_OW 67
9686: GO 9720
9688: LD_INT 130001
9690: DOUBLE
9691: GREATEREQUAL
9692: IFFALSE 9700
9694: LD_INT 150000
9696: DOUBLE
9697: LESSEQUAL
9698: IFTRUE 9702
9700: GO 9712
9702: POP
// Wait ( 2 2$15 ) ; else
9703: LD_INT 4725
9705: PPUSH
9706: CALL_OW 67
9710: GO 9720
9712: POP
// Wait ( 2 2$30 ) ; end ;
9713: LD_INT 5250
9715: PPUSH
9716: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9720: LD_ADDR_LOC 9
9724: PUSH
9725: LD_INT 22
9727: PUSH
9728: LD_INT 3
9730: PUSH
9731: LD_INT 1
9733: PUSH
9734: LD_INT 43
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: LIST
9742: PUSH
9743: LD_INT 23
9745: PUSH
9746: LD_INT 3
9748: PUSH
9749: LD_INT 1
9751: PUSH
9752: LD_INT 45
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: PUSH
9761: LD_INT 21
9763: PUSH
9764: LD_INT 3
9766: PUSH
9767: LD_INT 1
9769: PUSH
9770: LD_INT 43
9772: PUSH
9773: EMPTY
9774: LIST
9775: LIST
9776: LIST
9777: LIST
9778: PUSH
9779: LD_INT 24
9781: PUSH
9782: LD_INT 3
9784: PUSH
9785: LD_INT 1
9787: PUSH
9788: LD_INT 45
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 21
9799: PUSH
9800: LD_INT 3
9802: PUSH
9803: LD_INT 1
9805: PUSH
9806: LD_INT 45
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: PUSH
9815: LD_INT 22
9817: PUSH
9818: LD_INT 3
9820: PUSH
9821: LD_INT 1
9823: PUSH
9824: LD_INT 44
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: PUSH
9833: LD_INT 24
9835: PUSH
9836: LD_INT 3
9838: PUSH
9839: LD_INT 3
9841: PUSH
9842: LD_INT 46
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: PUSH
9851: LD_INT 23
9853: PUSH
9854: LD_INT 3
9856: PUSH
9857: LD_INT 3
9859: PUSH
9860: LD_INT 46
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_INT 24
9871: PUSH
9872: LD_INT 3
9874: PUSH
9875: LD_INT 3
9877: PUSH
9878: LD_INT 46
9880: PUSH
9881: EMPTY
9882: LIST
9883: LIST
9884: LIST
9885: LIST
9886: PUSH
9887: LD_INT 23
9889: PUSH
9890: LD_INT 3
9892: PUSH
9893: LD_INT 3
9895: PUSH
9896: LD_INT 47
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_INT 24
9907: PUSH
9908: LD_INT 3
9910: PUSH
9911: LD_INT 3
9913: PUSH
9914: LD_INT 49
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 23
9925: PUSH
9926: LD_INT 3
9928: PUSH
9929: LD_INT 1
9931: PUSH
9932: LD_INT 49
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: LIST
9939: LIST
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
9955: LD_ADDR_VAR 0 1
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_EXP 23
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: PUSH
9972: LD_INT 21
9974: PUSH
9975: LD_INT 2
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: PPUSH
9986: CALL_OW 69
9990: ST_TO_ADDR
// if filter < 3 then
9991: LD_VAR 0 1
9995: PUSH
9996: LD_INT 3
9998: LESS
9999: IFFALSE 10009
// filter := 3 ;
10001: LD_ADDR_VAR 0 1
10005: PUSH
10006: LD_INT 3
10008: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10009: LD_INT 22
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: LD_INT 21
10021: PUSH
10022: LD_INT 2
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 50
10031: PUSH
10032: EMPTY
10033: LIST
10034: PUSH
10035: LD_INT 2
10037: PUSH
10038: LD_INT 34
10040: PUSH
10041: LD_INT 43
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 34
10050: PUSH
10051: LD_INT 45
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 34
10060: PUSH
10061: LD_INT 44
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: LD_INT 34
10070: PUSH
10071: LD_INT 46
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 34
10080: PUSH
10081: LD_INT 47
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 34
10090: PUSH
10091: LD_INT 49
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: PPUSH
10113: CALL_OW 69
10117: PUSH
10118: LD_INT 6
10120: LESSEQUAL
10121: IFFALSE 10652
// for i := 1 to ( filter div 3 ) do
10123: LD_ADDR_VAR 0 2
10127: PUSH
10128: DOUBLE
10129: LD_INT 1
10131: DEC
10132: ST_TO_ADDR
10133: LD_VAR 0 1
10137: PUSH
10138: LD_INT 3
10140: DIV
10141: PUSH
10142: FOR_TO
10143: IFFALSE 10650
// begin uc_side := rus ;
10145: LD_ADDR_OWVAR 20
10149: PUSH
10150: LD_EXP 24
10154: ST_TO_ADDR
// uc_nation := nation_russian ;
10155: LD_ADDR_OWVAR 21
10159: PUSH
10160: LD_INT 3
10162: ST_TO_ADDR
// uc_direction := 5 ;
10163: LD_ADDR_OWVAR 24
10167: PUSH
10168: LD_INT 5
10170: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10171: LD_OWVAR 1
10175: PUSH
10176: LD_INT 60000
10178: LESS
10179: PUSH
10180: LD_INT 28
10182: PPUSH
10183: LD_EXP 23
10187: PPUSH
10188: CALL_OW 321
10192: PUSH
10193: LD_INT 2
10195: EQUAL
10196: OR
10197: IFFALSE 10223
// typ := rand ( 1 , vehicles - 2 ) else
10199: LD_ADDR_VAR 0 4
10203: PUSH
10204: LD_INT 1
10206: PPUSH
10207: LD_LOC 9
10211: PUSH
10212: LD_INT 2
10214: MINUS
10215: PPUSH
10216: CALL_OW 12
10220: ST_TO_ADDR
10221: GO 10241
// typ := rand ( 1 , vehicles ) ;
10223: LD_ADDR_VAR 0 4
10227: PUSH
10228: LD_INT 1
10230: PPUSH
10231: LD_LOC 9
10235: PPUSH
10236: CALL_OW 12
10240: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10241: LD_ADDR_OWVAR 37
10245: PUSH
10246: LD_LOC 9
10250: PUSH
10251: LD_VAR 0 4
10255: ARRAY
10256: PUSH
10257: LD_INT 1
10259: ARRAY
10260: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10261: LD_ADDR_OWVAR 38
10265: PUSH
10266: LD_LOC 9
10270: PUSH
10271: LD_VAR 0 4
10275: ARRAY
10276: PUSH
10277: LD_INT 2
10279: ARRAY
10280: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10281: LD_ADDR_OWVAR 39
10285: PUSH
10286: LD_LOC 9
10290: PUSH
10291: LD_VAR 0 4
10295: ARRAY
10296: PUSH
10297: LD_INT 3
10299: ARRAY
10300: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10301: LD_ADDR_OWVAR 40
10305: PUSH
10306: LD_LOC 9
10310: PUSH
10311: LD_VAR 0 4
10315: ARRAY
10316: PUSH
10317: LD_INT 4
10319: ARRAY
10320: ST_TO_ADDR
// auto := CreateVehicle ;
10321: LD_ADDR_VAR 0 5
10325: PUSH
10326: CALL_OW 45
10330: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10331: LD_VAR 0 5
10335: PPUSH
10336: LD_INT 9
10338: PPUSH
10339: LD_INT 0
10341: PPUSH
10342: CALL_OW 49
// attack := attack ^ auto ;
10346: LD_ADDR_LOC 10
10350: PUSH
10351: LD_LOC 10
10355: PUSH
10356: LD_VAR 0 5
10360: ADD
10361: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10362: LD_VAR 0 5
10366: PPUSH
10367: LD_INT 52
10369: PPUSH
10370: LD_INT 61
10372: PPUSH
10373: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10377: LD_VAR 0 5
10381: PPUSH
10382: LD_INT 52
10384: PPUSH
10385: LD_INT 61
10387: PPUSH
10388: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10392: LD_INT 1
10394: PPUSH
10395: LD_INT 2
10397: PPUSH
10398: CALL_OW 12
10402: PUSH
10403: LD_INT 1
10405: DOUBLE
10406: EQUAL
10407: IFTRUE 10411
10409: GO 10429
10411: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10412: LD_VAR 0 5
10416: PPUSH
10417: LD_INT 35
10419: PPUSH
10420: LD_INT 30
10422: PPUSH
10423: CALL_OW 174
10427: GO 10456
10429: LD_INT 2
10431: DOUBLE
10432: EQUAL
10433: IFTRUE 10437
10435: GO 10455
10437: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10438: LD_VAR 0 5
10442: PPUSH
10443: LD_INT 17
10445: PPUSH
10446: LD_INT 29
10448: PPUSH
10449: CALL_OW 174
10453: GO 10456
10455: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10456: LD_VAR 0 5
10460: PPUSH
10461: LD_INT 29
10463: PPUSH
10464: LD_INT 5
10466: PPUSH
10467: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10471: LD_INT 1
10473: PPUSH
10474: LD_INT 2
10476: PPUSH
10477: CALL_OW 12
10481: PUSH
10482: LD_INT 1
10484: DOUBLE
10485: EQUAL
10486: IFTRUE 10490
10488: GO 10508
10490: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10491: LD_VAR 0 5
10495: PPUSH
10496: LD_INT 60
10498: PPUSH
10499: LD_INT 30
10501: PPUSH
10502: CALL_OW 174
10506: GO 10535
10508: LD_INT 2
10510: DOUBLE
10511: EQUAL
10512: IFTRUE 10516
10514: GO 10534
10516: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10517: LD_VAR 0 5
10521: PPUSH
10522: LD_INT 84
10524: PPUSH
10525: LD_INT 30
10527: PPUSH
10528: CALL_OW 174
10532: GO 10535
10534: POP
// case Rand ( 1 , 2 ) of 1 :
10535: LD_INT 1
10537: PPUSH
10538: LD_INT 2
10540: PPUSH
10541: CALL_OW 12
10545: PUSH
10546: LD_INT 1
10548: DOUBLE
10549: EQUAL
10550: IFTRUE 10554
10552: GO 10572
10554: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10555: LD_VAR 0 5
10559: PPUSH
10560: LD_INT 71
10562: PPUSH
10563: LD_INT 59
10565: PPUSH
10566: CALL_OW 174
10570: GO 10599
10572: LD_INT 2
10574: DOUBLE
10575: EQUAL
10576: IFTRUE 10580
10578: GO 10598
10580: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10581: LD_VAR 0 5
10585: PPUSH
10586: LD_INT 92
10588: PPUSH
10589: LD_INT 66
10591: PPUSH
10592: CALL_OW 174
10596: GO 10599
10598: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10599: LD_VAR 0 5
10603: PPUSH
10604: LD_INT 78
10606: PPUSH
10607: LD_INT 88
10609: PPUSH
10610: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10614: LD_VAR 0 5
10618: PPUSH
10619: LD_INT 117
10621: PPUSH
10622: LD_INT 90
10624: PPUSH
10625: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10629: LD_VAR 0 5
10633: PPUSH
10634: LD_INT 15
10636: PPUSH
10637: CALL_OW 173
// Wait ( 0 0$4 ) ;
10641: LD_INT 140
10643: PPUSH
10644: CALL_OW 67
// end ;
10648: GO 10142
10650: POP
10651: POP
// enable ;
10652: ENABLE
// end ;
10653: PPOPN 7
10655: END
// export function PrepareInfantry ; var i , clovek ; begin
10656: LD_INT 0
10658: PPUSH
10659: PPUSH
10660: PPUSH
// for i = 1 to 6 do
10661: LD_ADDR_VAR 0 2
10665: PUSH
10666: DOUBLE
10667: LD_INT 1
10669: DEC
10670: ST_TO_ADDR
10671: LD_INT 6
10673: PUSH
10674: FOR_TO
10675: IFFALSE 10840
// begin uc_side = 3 ;
10677: LD_ADDR_OWVAR 20
10681: PUSH
10682: LD_INT 3
10684: ST_TO_ADDR
// uc_nation = 3 ;
10685: LD_ADDR_OWVAR 21
10689: PUSH
10690: LD_INT 3
10692: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10693: LD_INT 1
10695: PPUSH
10696: LD_INT 3
10698: PPUSH
10699: CALL_OW 12
10703: PUSH
10704: LD_INT 1
10706: DOUBLE
10707: EQUAL
10708: IFTRUE 10712
10710: GO 10736
10712: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
10713: LD_INT 1
10715: PPUSH
10716: LD_INT 1
10718: PPUSH
10719: LD_INT 4
10721: PPUSH
10722: LD_INT 8
10724: PPUSH
10725: CALL_OW 12
10729: PPUSH
10730: CALL_OW 380
10734: GO 10775
10736: LD_INT 2
10738: DOUBLE
10739: GREATEREQUAL
10740: IFFALSE 10748
10742: LD_INT 3
10744: DOUBLE
10745: LESSEQUAL
10746: IFTRUE 10750
10748: GO 10774
10750: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
10751: LD_INT 1
10753: PPUSH
10754: LD_INT 9
10756: PPUSH
10757: LD_INT 3
10759: PPUSH
10760: LD_INT 7
10762: PPUSH
10763: CALL_OW 12
10767: PPUSH
10768: CALL_OW 380
10772: GO 10775
10774: POP
// hc_name :=  ;
10775: LD_ADDR_OWVAR 26
10779: PUSH
10780: LD_STRING 
10782: ST_TO_ADDR
// clovek := CreateHuman ;
10783: LD_ADDR_VAR 0 3
10787: PUSH
10788: CALL_OW 44
10792: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
10793: LD_VAR 0 3
10797: PPUSH
10798: LD_INT 9
10800: PPUSH
10801: LD_INT 0
10803: PPUSH
10804: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
10808: LD_ADDR_EXP 59
10812: PUSH
10813: LD_EXP 59
10817: PUSH
10818: LD_INT 1
10820: MINUS
10821: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
10822: LD_ADDR_EXP 60
10826: PUSH
10827: LD_EXP 60
10831: PUSH
10832: LD_VAR 0 3
10836: ADD
10837: ST_TO_ADDR
// end ;
10838: GO 10674
10840: POP
10841: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
10842: LD_EXP 60
10846: PPUSH
10847: LD_INT 52
10849: PPUSH
10850: LD_INT 61
10852: PPUSH
10853: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
10857: LD_INT 1
10859: PPUSH
10860: LD_INT 2
10862: PPUSH
10863: CALL_OW 12
10867: PUSH
10868: LD_INT 1
10870: DOUBLE
10871: EQUAL
10872: IFTRUE 10876
10874: GO 10894
10876: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
10877: LD_EXP 60
10881: PPUSH
10882: LD_INT 35
10884: PPUSH
10885: LD_INT 30
10887: PPUSH
10888: CALL_OW 174
10892: GO 10921
10894: LD_INT 2
10896: DOUBLE
10897: EQUAL
10898: IFTRUE 10902
10900: GO 10920
10902: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
10903: LD_EXP 60
10907: PPUSH
10908: LD_INT 17
10910: PPUSH
10911: LD_INT 29
10913: PPUSH
10914: CALL_OW 174
10918: GO 10921
10920: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
10921: LD_EXP 60
10925: PPUSH
10926: LD_INT 29
10928: PPUSH
10929: LD_INT 5
10931: PPUSH
10932: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10936: LD_INT 1
10938: PPUSH
10939: LD_INT 2
10941: PPUSH
10942: CALL_OW 12
10946: PUSH
10947: LD_INT 1
10949: DOUBLE
10950: EQUAL
10951: IFTRUE 10955
10953: GO 10973
10955: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
10956: LD_EXP 60
10960: PPUSH
10961: LD_INT 60
10963: PPUSH
10964: LD_INT 30
10966: PPUSH
10967: CALL_OW 174
10971: GO 11000
10973: LD_INT 2
10975: DOUBLE
10976: EQUAL
10977: IFTRUE 10981
10979: GO 10999
10981: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
10982: LD_EXP 60
10986: PPUSH
10987: LD_INT 84
10989: PPUSH
10990: LD_INT 30
10992: PPUSH
10993: CALL_OW 174
10997: GO 11000
10999: POP
// case Rand ( 1 , 2 ) of 1 :
11000: LD_INT 1
11002: PPUSH
11003: LD_INT 2
11005: PPUSH
11006: CALL_OW 12
11010: PUSH
11011: LD_INT 1
11013: DOUBLE
11014: EQUAL
11015: IFTRUE 11019
11017: GO 11037
11019: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11020: LD_EXP 60
11024: PPUSH
11025: LD_INT 71
11027: PPUSH
11028: LD_INT 59
11030: PPUSH
11031: CALL_OW 174
11035: GO 11064
11037: LD_INT 2
11039: DOUBLE
11040: EQUAL
11041: IFTRUE 11045
11043: GO 11063
11045: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11046: LD_EXP 60
11050: PPUSH
11051: LD_INT 92
11053: PPUSH
11054: LD_INT 66
11056: PPUSH
11057: CALL_OW 174
11061: GO 11064
11063: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11064: LD_EXP 60
11068: PPUSH
11069: LD_INT 78
11071: PPUSH
11072: LD_INT 88
11074: PPUSH
11075: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11079: LD_EXP 60
11083: PPUSH
11084: LD_INT 117
11086: PPUSH
11087: LD_INT 90
11089: PPUSH
11090: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11094: LD_EXP 60
11098: PPUSH
11099: LD_INT 15
11101: PPUSH
11102: CALL_OW 173
// end ;
11106: LD_VAR 0 1
11110: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11111: LD_EXP 60
11115: PUSH
11116: EMPTY
11117: EQUAL
11118: PUSH
11119: LD_EXP 61
11123: PUSH
11124: LD_INT 1
11126: EQUAL
11127: AND
11128: IFFALSE 11138
11130: GO 11132
11132: DISABLE
// begin enable ;
11133: ENABLE
// PrepareInfantry ;
11134: CALL 10656 0 0
// end ;
11138: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11139: GO 11141
11141: DISABLE
11142: LD_INT 0
11144: PPUSH
11145: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11146: LD_ADDR_VAR 0 1
11150: PUSH
11151: LD_INT 15
11153: PPUSH
11154: LD_INT 22
11156: PUSH
11157: LD_EXP 24
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PUSH
11166: LD_INT 50
11168: PUSH
11169: EMPTY
11170: LIST
11171: PUSH
11172: LD_INT 2
11174: PUSH
11175: LD_INT 21
11177: PUSH
11178: LD_INT 2
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 21
11187: PUSH
11188: LD_INT 1
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: EMPTY
11196: LIST
11197: LIST
11198: LIST
11199: PUSH
11200: EMPTY
11201: LIST
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 70
11209: ST_TO_ADDR
// case tick of 0 .. 30000 :
11210: LD_OWVAR 1
11214: PUSH
11215: LD_INT 0
11217: DOUBLE
11218: GREATEREQUAL
11219: IFFALSE 11227
11221: LD_INT 30000
11223: DOUBLE
11224: LESSEQUAL
11225: IFTRUE 11229
11227: GO 11246
11229: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11230: LD_ADDR_VAR 0 2
11234: PUSH
11235: LD_EXP 34
11239: PUSH
11240: LD_INT 4
11242: MINUS
11243: ST_TO_ADDR
11244: GO 11350
11246: LD_INT 30001
11248: DOUBLE
11249: GREATEREQUAL
11250: IFFALSE 11258
11252: LD_INT 50000
11254: DOUBLE
11255: LESSEQUAL
11256: IFTRUE 11260
11258: GO 11277
11260: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11261: LD_ADDR_VAR 0 2
11265: PUSH
11266: LD_EXP 34
11270: PUSH
11271: LD_INT 3
11273: MINUS
11274: ST_TO_ADDR
11275: GO 11350
11277: LD_INT 50001
11279: DOUBLE
11280: GREATEREQUAL
11281: IFFALSE 11289
11283: LD_INT 70000
11285: DOUBLE
11286: LESSEQUAL
11287: IFTRUE 11291
11289: GO 11308
11291: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11292: LD_ADDR_VAR 0 2
11296: PUSH
11297: LD_EXP 34
11301: PUSH
11302: LD_INT 2
11304: MINUS
11305: ST_TO_ADDR
11306: GO 11350
11308: LD_INT 70001
11310: DOUBLE
11311: GREATEREQUAL
11312: IFFALSE 11320
11314: LD_INT 90000
11316: DOUBLE
11317: LESSEQUAL
11318: IFTRUE 11322
11320: GO 11339
11322: POP
// mnozstvi := maxaut - 1 ; else
11323: LD_ADDR_VAR 0 2
11327: PUSH
11328: LD_EXP 34
11332: PUSH
11333: LD_INT 1
11335: MINUS
11336: ST_TO_ADDR
11337: GO 11350
11339: POP
// mnozstvi := maxaut ; end ;
11340: LD_ADDR_VAR 0 2
11344: PUSH
11345: LD_EXP 34
11349: ST_TO_ADDR
// if filter >= mnozstvi then
11350: LD_VAR 0 1
11354: PUSH
11355: LD_VAR 0 2
11359: GREATEREQUAL
11360: IFFALSE 11377
// ComMoveXY ( filter , 138 , 69 ) ;
11362: LD_VAR 0 1
11366: PPUSH
11367: LD_INT 138
11369: PPUSH
11370: LD_INT 69
11372: PPUSH
11373: CALL_OW 111
// enable ;
11377: ENABLE
// end ;
11378: PPOPN 2
11380: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11381: GO 11383
11383: DISABLE
11384: LD_INT 0
11386: PPUSH
11387: PPUSH
11388: PPUSH
11389: PPUSH
11390: PPUSH
11391: PPUSH
// begin enable ;
11392: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11393: LD_ADDR_VAR 0 1
11397: PUSH
11398: LD_INT 12
11400: PPUSH
11401: LD_INT 22
11403: PUSH
11404: LD_EXP 24
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: PUSH
11413: LD_INT 50
11415: PUSH
11416: EMPTY
11417: LIST
11418: PUSH
11419: LD_INT 3
11421: PUSH
11422: LD_INT 34
11424: PUSH
11425: LD_INT 49
11427: PUSH
11428: EMPTY
11429: LIST
11430: LIST
11431: PUSH
11432: EMPTY
11433: LIST
11434: LIST
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: LIST
11440: PPUSH
11441: CALL_OW 70
11445: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11446: LD_INT 33
11448: PPUSH
11449: LD_EXP 23
11453: PPUSH
11454: CALL_OW 321
11458: PUSH
11459: LD_INT 2
11461: EQUAL
11462: IFFALSE 11516
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11464: LD_ADDR_VAR 0 2
11468: PUSH
11469: LD_INT 12
11471: PPUSH
11472: LD_INT 22
11474: PUSH
11475: LD_EXP 23
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: PUSH
11484: LD_INT 25
11486: PUSH
11487: LD_INT 4
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PUSH
11494: LD_INT 101
11496: PUSH
11497: LD_EXP 24
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: LIST
11510: PPUSH
11511: CALL_OW 70
11515: ST_TO_ADDR
// if filter_you = 0 then
11516: LD_VAR 0 2
11520: PUSH
11521: LD_INT 0
11523: EQUAL
11524: IFFALSE 11633
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11526: LD_ADDR_VAR 0 2
11530: PUSH
11531: LD_INT 22
11533: PUSH
11534: LD_EXP 23
11538: PUSH
11539: EMPTY
11540: LIST
11541: LIST
11542: PUSH
11543: LD_INT 50
11545: PUSH
11546: EMPTY
11547: LIST
11548: PUSH
11549: LD_INT 2
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 21
11564: PUSH
11565: LD_INT 2
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 21
11574: PUSH
11575: LD_INT 3
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: LIST
11592: PPUSH
11593: CALL_OW 69
11597: ST_TO_ADDR
// if filter_you = 0 then
11598: LD_VAR 0 2
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11633
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11608: LD_ADDR_VAR 0 2
11612: PUSH
11613: LD_INT 12
11615: PPUSH
11616: LD_INT 22
11618: PUSH
11619: LD_EXP 23
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PPUSH
11628: CALL_OW 70
11632: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11633: LD_VAR 0 1
11637: PUSH
11638: LD_INT 0
11640: GREATER
11641: PUSH
11642: LD_VAR 0 2
11646: PUSH
11647: LD_INT 0
11649: GREATER
11650: AND
11651: IFFALSE 12042
// begin for un_rus in filter_rus do
11653: LD_ADDR_VAR 0 3
11657: PUSH
11658: LD_VAR 0 1
11662: PUSH
11663: FOR_IN
11664: IFFALSE 12040
// begin Wait ( 5 ) ;
11666: LD_INT 5
11668: PPUSH
11669: CALL_OW 67
// min := 99999 ;
11673: LD_ADDR_VAR 0 5
11677: PUSH
11678: LD_INT 99999
11680: ST_TO_ADDR
// cil := 0 ;
11681: LD_ADDR_VAR 0 6
11685: PUSH
11686: LD_INT 0
11688: ST_TO_ADDR
// for un_you in filter_you do
11689: LD_ADDR_VAR 0 4
11693: PUSH
11694: LD_VAR 0 2
11698: PUSH
11699: FOR_IN
11700: IFFALSE 11896
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11702: LD_VAR 0 4
11706: PPUSH
11707: CALL_OW 320
11711: PUSH
11712: LD_VAR 0 4
11716: PPUSH
11717: CALL_OW 256
11721: PUSH
11722: LD_VAR 0 5
11726: LESS
11727: AND
11728: PUSH
11729: LD_VAR 0 3
11733: PPUSH
11734: LD_VAR 0 4
11738: PPUSH
11739: CALL_OW 296
11743: PUSH
11744: LD_INT 2
11746: PUSH
11747: LD_INT 2
11749: PUSH
11750: LD_INT 4
11752: PUSH
11753: LD_INT 6
11755: PUSH
11756: LD_INT 5
11758: PUSH
11759: LD_INT 9
11761: PUSH
11762: LD_INT 0
11764: PUSH
11765: LD_INT 2
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: PUSH
11778: LD_VAR 0 3
11782: PPUSH
11783: CALL_OW 264
11787: PUSH
11788: LD_INT 41
11790: MINUS
11791: ARRAY
11792: GREATEREQUAL
11793: AND
11794: PUSH
11795: LD_VAR 0 3
11799: PPUSH
11800: LD_VAR 0 4
11804: PPUSH
11805: CALL_OW 296
11809: PUSH
11810: LD_INT 15
11812: PUSH
11813: LD_INT 16
11815: PUSH
11816: LD_INT 17
11818: PUSH
11819: LD_INT 22
11821: PUSH
11822: LD_INT 20
11824: PUSH
11825: LD_INT 28
11827: PUSH
11828: LD_INT 0
11830: PUSH
11831: LD_INT 51
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: PUSH
11844: LD_VAR 0 3
11848: PPUSH
11849: CALL_OW 264
11853: PUSH
11854: LD_INT 41
11856: MINUS
11857: ARRAY
11858: LESSEQUAL
11859: AND
11860: IFFALSE 11887
// begin min := GetLives ( un_you ) ;
11862: LD_ADDR_VAR 0 5
11866: PUSH
11867: LD_VAR 0 4
11871: PPUSH
11872: CALL_OW 256
11876: ST_TO_ADDR
// cil := un_you ;
11877: LD_ADDR_VAR 0 6
11881: PUSH
11882: LD_VAR 0 4
11886: ST_TO_ADDR
// end ; Wait ( 5 ) ;
11887: LD_INT 5
11889: PPUSH
11890: CALL_OW 67
// end ;
11894: GO 11699
11896: POP
11897: POP
// if cil <> 0 then
11898: LD_VAR 0 6
11902: PUSH
11903: LD_INT 0
11905: NONEQUAL
11906: IFFALSE 11924
// ComAttackUnit ( un_rus , cil ) else
11908: LD_VAR 0 3
11912: PPUSH
11913: LD_VAR 0 6
11917: PPUSH
11918: CALL_OW 115
11922: GO 12038
// begin for un_you in filter_you do
11924: LD_ADDR_VAR 0 4
11928: PUSH
11929: LD_VAR 0 2
11933: PUSH
11934: FOR_IN
11935: IFFALSE 12022
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
11937: LD_VAR 0 4
11941: PPUSH
11942: CALL_OW 266
11946: PUSH
11947: LD_INT 0
11949: PUSH
11950: LD_INT 1
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: IN
11957: IFFALSE 11971
// cil := un_you else
11959: LD_ADDR_VAR 0 6
11963: PUSH
11964: LD_VAR 0 4
11968: ST_TO_ADDR
11969: GO 12013
// if GetLives ( un_you ) < min then
11971: LD_VAR 0 4
11975: PPUSH
11976: CALL_OW 256
11980: PUSH
11981: LD_VAR 0 5
11985: LESS
11986: IFFALSE 12013
// begin min := GetLives ( un_you ) ;
11988: LD_ADDR_VAR 0 5
11992: PUSH
11993: LD_VAR 0 4
11997: PPUSH
11998: CALL_OW 256
12002: ST_TO_ADDR
// cil := un_you ;
12003: LD_ADDR_VAR 0 6
12007: PUSH
12008: LD_VAR 0 4
12012: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12013: LD_INT 5
12015: PPUSH
12016: CALL_OW 67
// end ;
12020: GO 11934
12022: POP
12023: POP
// ComAttackUnit ( un_rus , cil ) end ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_VAR 0 6
12033: PPUSH
12034: CALL_OW 115
// end ;
12038: GO 11663
12040: POP
12041: POP
// end ; end ;
12042: PPOPN 6
12044: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12045: GO 12047
12047: DISABLE
12048: LD_INT 0
12050: PPUSH
12051: PPUSH
12052: PPUSH
12053: PPUSH
12054: PPUSH
12055: PPUSH
// begin enable ;
12056: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12057: LD_ADDR_VAR 0 1
12061: PUSH
12062: LD_INT 21
12064: PPUSH
12065: LD_INT 22
12067: PUSH
12068: LD_EXP 24
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PUSH
12077: LD_INT 3
12079: PUSH
12080: LD_INT 2
12082: PUSH
12083: LD_INT 21
12085: PUSH
12086: LD_INT 3
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 34
12095: PUSH
12096: LD_INT 49
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 51
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 4
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 2
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 54
12135: PUSH
12136: EMPTY
12137: LIST
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: LIST
12143: LIST
12144: LIST
12145: LIST
12146: LIST
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: LIST
12152: PPUSH
12153: CALL_OW 70
12157: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12158: LD_ADDR_VAR 0 1
12162: PUSH
12163: LD_VAR 0 1
12167: PUSH
12168: LD_EXP 45
12172: DIFF
12173: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12174: LD_ADDR_VAR 0 2
12178: PUSH
12179: LD_INT 21
12181: PPUSH
12182: LD_INT 22
12184: PUSH
12185: LD_EXP 23
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 21
12196: PUSH
12197: LD_INT 2
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PPUSH
12208: CALL_OW 70
12212: ST_TO_ADDR
// if not filter_you then
12213: LD_VAR 0 2
12217: NOT
12218: IFFALSE 12291
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12220: LD_ADDR_VAR 0 2
12224: PUSH
12225: LD_INT 21
12227: PPUSH
12228: LD_INT 22
12230: PUSH
12231: LD_EXP 23
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 25
12242: PUSH
12243: LD_INT 4
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: EMPTY
12251: LIST
12252: LIST
12253: PPUSH
12254: CALL_OW 70
12258: ST_TO_ADDR
// if not filter_you then
12259: LD_VAR 0 2
12263: NOT
12264: IFFALSE 12291
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12266: LD_ADDR_VAR 0 2
12270: PUSH
12271: LD_INT 21
12273: PPUSH
12274: LD_INT 22
12276: PUSH
12277: LD_EXP 23
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PPUSH
12286: CALL_OW 70
12290: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12291: LD_VAR 0 1
12295: PUSH
12296: LD_INT 0
12298: GREATER
12299: PUSH
12300: LD_VAR 0 2
12304: PUSH
12305: LD_INT 0
12307: GREATER
12308: AND
12309: IFFALSE 12700
// begin for un_rus in filter_rus do
12311: LD_ADDR_VAR 0 3
12315: PUSH
12316: LD_VAR 0 1
12320: PUSH
12321: FOR_IN
12322: IFFALSE 12698
// begin Wait ( 5 ) ;
12324: LD_INT 5
12326: PPUSH
12327: CALL_OW 67
// min := 99999 ;
12331: LD_ADDR_VAR 0 5
12335: PUSH
12336: LD_INT 99999
12338: ST_TO_ADDR
// cil := 0 ;
12339: LD_ADDR_VAR 0 6
12343: PUSH
12344: LD_INT 0
12346: ST_TO_ADDR
// for un_you in filter_you do
12347: LD_ADDR_VAR 0 4
12351: PUSH
12352: LD_VAR 0 2
12356: PUSH
12357: FOR_IN
12358: IFFALSE 12554
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12360: LD_VAR 0 4
12364: PPUSH
12365: CALL_OW 302
12369: PUSH
12370: LD_VAR 0 4
12374: PPUSH
12375: CALL_OW 256
12379: PUSH
12380: LD_VAR 0 5
12384: LESS
12385: AND
12386: PUSH
12387: LD_VAR 0 3
12391: PPUSH
12392: LD_VAR 0 4
12396: PPUSH
12397: CALL_OW 296
12401: PUSH
12402: LD_INT 2
12404: PUSH
12405: LD_INT 2
12407: PUSH
12408: LD_INT 4
12410: PUSH
12411: LD_INT 6
12413: PUSH
12414: LD_INT 5
12416: PUSH
12417: LD_INT 9
12419: PUSH
12420: LD_INT 0
12422: PUSH
12423: LD_INT 2
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: LIST
12434: LIST
12435: PUSH
12436: LD_VAR 0 3
12440: PPUSH
12441: CALL_OW 264
12445: PUSH
12446: LD_INT 41
12448: MINUS
12449: ARRAY
12450: GREATEREQUAL
12451: AND
12452: PUSH
12453: LD_VAR 0 3
12457: PPUSH
12458: LD_VAR 0 4
12462: PPUSH
12463: CALL_OW 296
12467: PUSH
12468: LD_INT 15
12470: PUSH
12471: LD_INT 16
12473: PUSH
12474: LD_INT 17
12476: PUSH
12477: LD_INT 22
12479: PUSH
12480: LD_INT 20
12482: PUSH
12483: LD_INT 28
12485: PUSH
12486: LD_INT 0
12488: PUSH
12489: LD_INT 51
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: PUSH
12502: LD_VAR 0 3
12506: PPUSH
12507: CALL_OW 264
12511: PUSH
12512: LD_INT 41
12514: MINUS
12515: ARRAY
12516: LESSEQUAL
12517: AND
12518: IFFALSE 12545
// begin min := GetLives ( un_you ) ;
12520: LD_ADDR_VAR 0 5
12524: PUSH
12525: LD_VAR 0 4
12529: PPUSH
12530: CALL_OW 256
12534: ST_TO_ADDR
// cil := un_you ;
12535: LD_ADDR_VAR 0 6
12539: PUSH
12540: LD_VAR 0 4
12544: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12545: LD_INT 5
12547: PPUSH
12548: CALL_OW 67
// end ;
12552: GO 12357
12554: POP
12555: POP
// if cil <> 0 then
12556: LD_VAR 0 6
12560: PUSH
12561: LD_INT 0
12563: NONEQUAL
12564: IFFALSE 12582
// ComAttackUnit ( un_rus , cil ) else
12566: LD_VAR 0 3
12570: PPUSH
12571: LD_VAR 0 6
12575: PPUSH
12576: CALL_OW 115
12580: GO 12696
// begin for un_you in filter_you do
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_VAR 0 2
12591: PUSH
12592: FOR_IN
12593: IFFALSE 12680
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12595: LD_VAR 0 4
12599: PPUSH
12600: CALL_OW 266
12604: PUSH
12605: LD_INT 0
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: IN
12615: IFFALSE 12629
// cil := un_you else
12617: LD_ADDR_VAR 0 6
12621: PUSH
12622: LD_VAR 0 4
12626: ST_TO_ADDR
12627: GO 12671
// if GetLives ( un_you ) < min then
12629: LD_VAR 0 4
12633: PPUSH
12634: CALL_OW 256
12638: PUSH
12639: LD_VAR 0 5
12643: LESS
12644: IFFALSE 12671
// begin min := GetLives ( un_you ) ;
12646: LD_ADDR_VAR 0 5
12650: PUSH
12651: LD_VAR 0 4
12655: PPUSH
12656: CALL_OW 256
12660: ST_TO_ADDR
// cil := un_you ;
12661: LD_ADDR_VAR 0 6
12665: PUSH
12666: LD_VAR 0 4
12670: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12671: LD_INT 5
12673: PPUSH
12674: CALL_OW 67
// end ;
12678: GO 12592
12680: POP
12681: POP
// ComAttackUnit ( un_rus , cil ) end ;
12682: LD_VAR 0 3
12686: PPUSH
12687: LD_VAR 0 6
12691: PPUSH
12692: CALL_OW 115
// end ;
12696: GO 12321
12698: POP
12699: POP
// end ; end ;
12700: PPOPN 6
12702: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12703: GO 12705
12705: DISABLE
12706: LD_INT 0
12708: PPUSH
12709: PPUSH
12710: PPUSH
12711: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12712: LD_INT 28
12714: PPUSH
12715: LD_EXP 23
12719: PPUSH
12720: CALL_OW 321
12724: PUSH
12725: LD_INT 2
12727: EQUAL
12728: NOT
12729: IFFALSE 12732
// enable ;
12731: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_INT 12
12739: PPUSH
12740: LD_INT 22
12742: PUSH
12743: LD_EXP 24
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 50
12754: PUSH
12755: EMPTY
12756: LIST
12757: PUSH
12758: LD_INT 34
12760: PUSH
12761: LD_INT 49
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: LIST
12772: PPUSH
12773: CALL_OW 70
12777: ST_TO_ADDR
// if filter_rus > 0 then
12778: LD_VAR 0 1
12782: PUSH
12783: LD_INT 0
12785: GREATER
12786: IFFALSE 12827
// for un_rus in filter_rus do
12788: LD_ADDR_VAR 0 3
12792: PUSH
12793: LD_VAR 0 1
12797: PUSH
12798: FOR_IN
12799: IFFALSE 12825
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
12801: LD_VAR 0 3
12805: PPUSH
12806: LD_INT 122
12808: PPUSH
12809: LD_INT 27
12811: PPUSH
12812: CALL_OW 111
// Wait ( 5 ) ;
12816: LD_INT 5
12818: PPUSH
12819: CALL_OW 67
// end ;
12823: GO 12798
12825: POP
12826: POP
// end ;
12827: PPOPN 4
12829: END
// every 1 1$0 + 0 0$5.5 do
12830: GO 12832
12832: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
12833: LD_INT 59
12835: PPUSH
12836: LD_EXP 24
12840: PPUSH
12841: CALL_OW 321
12845: PUSH
12846: LD_INT 2
12848: EQUAL
12849: NOT
12850: PUSH
12851: LD_OWVAR 1
12855: PUSH
12856: LD_EXP 54
12860: GREATEREQUAL
12861: AND
12862: IFFALSE 12879
// SetTech ( tech_Comp3 , rus , state_researched ) ;
12864: LD_INT 59
12866: PPUSH
12867: LD_EXP 24
12871: PPUSH
12872: LD_INT 2
12874: PPUSH
12875: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
12879: LD_INT 50
12881: PPUSH
12882: LD_EXP 24
12886: PPUSH
12887: CALL_OW 321
12891: PUSH
12892: LD_INT 2
12894: EQUAL
12895: NOT
12896: PUSH
12897: LD_OWVAR 1
12901: PUSH
12902: LD_EXP 55
12906: GREATEREQUAL
12907: AND
12908: IFFALSE 12925
// SetTech ( tech_Tech3 , rus , state_researched ) ;
12910: LD_INT 50
12912: PPUSH
12913: LD_EXP 24
12917: PPUSH
12918: LD_INT 2
12920: PPUSH
12921: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
12925: LD_INT 53
12927: PPUSH
12928: LD_EXP 24
12932: PPUSH
12933: CALL_OW 321
12937: PUSH
12938: LD_INT 2
12940: EQUAL
12941: NOT
12942: PUSH
12943: LD_OWVAR 1
12947: PUSH
12948: LD_EXP 56
12952: GREATEREQUAL
12953: AND
12954: IFFALSE 12971
// SetTech ( tech_Weap3 , rus , state_researched ) ;
12956: LD_INT 53
12958: PPUSH
12959: LD_EXP 24
12963: PPUSH
12964: LD_INT 2
12966: PPUSH
12967: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
12971: LD_INT 56
12973: PPUSH
12974: LD_EXP 24
12978: PPUSH
12979: CALL_OW 321
12983: PUSH
12984: LD_INT 2
12986: EQUAL
12987: NOT
12988: PUSH
12989: LD_OWVAR 1
12993: PUSH
12994: LD_EXP 57
12998: GREATEREQUAL
12999: AND
13000: IFFALSE 13017
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13002: LD_INT 56
13004: PPUSH
13005: LD_EXP 24
13009: PPUSH
13010: LD_INT 2
13012: PPUSH
13013: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13017: LD_INT 65
13019: PPUSH
13020: LD_EXP 24
13024: PPUSH
13025: CALL_OW 321
13029: PUSH
13030: LD_INT 2
13032: EQUAL
13033: NOT
13034: PUSH
13035: LD_OWVAR 1
13039: PUSH
13040: LD_EXP 58
13044: GREATEREQUAL
13045: AND
13046: IFFALSE 13063
// SetTech ( tech_ST3 , rus , state_researched ) ;
13048: LD_INT 65
13050: PPUSH
13051: LD_EXP 24
13055: PPUSH
13056: LD_INT 2
13058: PPUSH
13059: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13063: LD_INT 59
13065: PPUSH
13066: LD_EXP 24
13070: PPUSH
13071: CALL_OW 321
13075: PUSH
13076: LD_INT 2
13078: EQUAL
13079: PUSH
13080: LD_INT 50
13082: PPUSH
13083: LD_EXP 24
13087: PPUSH
13088: CALL_OW 321
13092: PUSH
13093: LD_INT 2
13095: EQUAL
13096: AND
13097: PUSH
13098: LD_INT 53
13100: PPUSH
13101: LD_EXP 24
13105: PPUSH
13106: CALL_OW 321
13110: PUSH
13111: LD_INT 2
13113: EQUAL
13114: AND
13115: PUSH
13116: LD_INT 56
13118: PPUSH
13119: LD_EXP 24
13123: PPUSH
13124: CALL_OW 321
13128: PUSH
13129: LD_INT 2
13131: EQUAL
13132: AND
13133: PUSH
13134: LD_INT 65
13136: PPUSH
13137: LD_EXP 24
13141: PPUSH
13142: CALL_OW 321
13146: PUSH
13147: LD_INT 2
13149: EQUAL
13150: AND
13151: NOT
13152: IFFALSE 13155
// enable ;
13154: ENABLE
// end ; end_of_file
13155: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13156: GO 13158
13158: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13159: LD_ADDR_EXP 63
13163: PUSH
13164: LD_INT 14
13166: PUSH
13167: LD_INT 18
13169: PUSH
13170: LD_INT 19
13172: PUSH
13173: LD_INT 20
13175: PUSH
13176: LD_INT 21
13178: PUSH
13179: LD_INT 22
13181: PUSH
13182: LD_INT 23
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13194: LD_ADDR_EXP 64
13198: PUSH
13199: LD_INT 22
13201: PUSH
13202: LD_EXP 24
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: PUSH
13211: LD_INT 21
13213: PUSH
13214: LD_INT 3
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: PUSH
13230: LD_INT 14
13232: PUSH
13233: LD_INT 15
13235: PUSH
13236: EMPTY
13237: LIST
13238: LIST
13239: ADD
13240: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13241: LD_ADDR_EXP 65
13245: PUSH
13246: LD_INT 22
13248: PUSH
13249: LD_EXP 24
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: PUSH
13258: LD_INT 30
13260: PUSH
13261: LD_INT 1
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PPUSH
13272: CALL_OW 69
13276: PUSH
13277: LD_INT 1
13279: ARRAY
13280: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13281: LD_ADDR_EXP 66
13285: PUSH
13286: LD_INT 22
13288: PUSH
13289: LD_EXP 24
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: PUSH
13298: LD_INT 30
13300: PUSH
13301: LD_INT 8
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: PUSH
13308: EMPTY
13309: LIST
13310: LIST
13311: PPUSH
13312: CALL_OW 69
13316: PUSH
13317: LD_INT 1
13319: ARRAY
13320: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13321: LD_ADDR_EXP 67
13325: PUSH
13326: LD_INT 22
13328: PUSH
13329: LD_EXP 24
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PUSH
13338: LD_INT 30
13340: PUSH
13341: LD_INT 31
13343: PUSH
13344: EMPTY
13345: LIST
13346: LIST
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: PPUSH
13352: CALL_OW 69
13356: PUSH
13357: LD_INT 1
13359: ARRAY
13360: ST_TO_ADDR
// enable ( 401 ) ;
13361: LD_INT 401
13363: ENABLE_MARKED
// end ;
13364: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13365: GO 13367
13367: DISABLE
13368: LD_INT 0
13370: PPUSH
13371: PPUSH
13372: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13373: LD_EXP 62
13377: PPUSH
13378: CALL_OW 386
13382: NOT
13383: IFFALSE 13438
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13385: LD_ADDR_EXP 62
13389: PUSH
13390: LD_INT 100
13392: PPUSH
13393: LD_EXP 63
13397: PPUSH
13398: LD_EXP 64
13402: PUSH
13403: LD_EXP 63
13407: ADD
13408: PPUSH
13409: LD_INT 1
13411: PUSH
13412: LD_INT 23
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 10
13421: PUSH
13422: LD_INT 22
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PPUSH
13433: CALL_OW 414
13437: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13438: LD_EXP 65
13442: PPUSH
13443: CALL_OW 300
13447: PUSH
13448: LD_EXP 66
13452: PPUSH
13453: CALL_OW 300
13457: OR
13458: PUSH
13459: LD_EXP 67
13463: PPUSH
13464: CALL_OW 300
13468: OR
13469: IFFALSE 13695
// begin for un in rus_mcrep_units do
13471: LD_ADDR_VAR 0 1
13475: PUSH
13476: LD_EXP 63
13480: PUSH
13481: FOR_IN
13482: IFFALSE 13693
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13484: LD_VAR 0 1
13488: PPUSH
13489: CALL_OW 388
13493: PUSH
13494: LD_INT 0
13496: EQUAL
13497: PUSH
13498: LD_VAR 0 1
13502: PPUSH
13503: CALL_OW 256
13507: PUSH
13508: LD_INT 1000
13510: EQUAL
13511: AND
13512: IFFALSE 13679
// case GetClass ( un ) of class_engineer :
13514: LD_VAR 0 1
13518: PPUSH
13519: CALL_OW 257
13523: PUSH
13524: LD_INT 2
13526: DOUBLE
13527: EQUAL
13528: IFTRUE 13532
13530: GO 13576
13532: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13533: LD_EXP 65
13537: PPUSH
13538: CALL_OW 300
13542: PUSH
13543: LD_EXP 65
13547: PPUSH
13548: CALL_OW 313
13552: PUSH
13553: LD_INT 6
13555: EQUAL
13556: NOT
13557: AND
13558: IFFALSE 13574
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13560: LD_VAR 0 1
13564: PPUSH
13565: LD_EXP 65
13569: PPUSH
13570: CALL_OW 120
13574: GO 13677
13576: LD_INT 4
13578: DOUBLE
13579: EQUAL
13580: IFTRUE 13584
13582: GO 13628
13584: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13585: LD_EXP 66
13589: PPUSH
13590: CALL_OW 300
13594: PUSH
13595: LD_EXP 66
13599: PPUSH
13600: CALL_OW 313
13604: PUSH
13605: LD_INT 6
13607: EQUAL
13608: NOT
13609: AND
13610: IFFALSE 13626
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13612: LD_VAR 0 1
13616: PPUSH
13617: LD_EXP 66
13621: PPUSH
13622: CALL_OW 120
13626: GO 13677
13628: LD_INT 1
13630: DOUBLE
13631: EQUAL
13632: IFTRUE 13636
13634: GO 13676
13636: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13637: LD_EXP 67
13641: PPUSH
13642: CALL_OW 300
13646: PUSH
13647: LD_EXP 67
13651: PPUSH
13652: CALL_OW 313
13656: NOT
13657: AND
13658: IFFALSE 13674
// ComEnterUnit ( un , rus_breastwork ) ; end else
13660: LD_VAR 0 1
13664: PPUSH
13665: LD_EXP 67
13669: PPUSH
13670: CALL_OW 120
13674: GO 13677
13676: POP
13677: GO 13691
// ComMoveToArea ( un , BluekherRepairArea ) ;
13679: LD_VAR 0 1
13683: PPUSH
13684: LD_INT 23
13686: PPUSH
13687: CALL_OW 113
13691: GO 13481
13693: POP
13694: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13695: LD_ADDR_VAR 0 3
13699: PUSH
13700: LD_INT 22
13702: PPUSH
13703: LD_INT 22
13705: PUSH
13706: LD_EXP 24
13710: PUSH
13711: EMPTY
13712: LIST
13713: LIST
13714: PUSH
13715: LD_INT 2
13717: PUSH
13718: LD_INT 25
13720: PUSH
13721: LD_INT 2
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PUSH
13728: LD_INT 25
13730: PUSH
13731: LD_INT 4
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: EMPTY
13739: LIST
13740: LIST
13741: LIST
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PPUSH
13747: CALL_OW 71
13751: ST_TO_ADDR
// if filter then
13752: LD_VAR 0 3
13756: IFFALSE 13773
// ComMoveXY ( filter , 48 , 88 ) ;
13758: LD_VAR 0 3
13762: PPUSH
13763: LD_INT 48
13765: PPUSH
13766: LD_INT 88
13768: PPUSH
13769: CALL_OW 111
// enable ;
13773: ENABLE
// end ; end_of_file
13774: PPOPN 3
13776: END
// every 0 0$2 + 0 0$0.1 do
13777: GO 13779
13779: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
13780: LD_INT 22
13782: PUSH
13783: LD_INT 7
13785: PUSH
13786: EMPTY
13787: LIST
13788: LIST
13789: PUSH
13790: LD_INT 2
13792: PUSH
13793: LD_INT 25
13795: PUSH
13796: LD_INT 12
13798: PUSH
13799: EMPTY
13800: LIST
13801: LIST
13802: PUSH
13803: LD_INT 25
13805: PUSH
13806: LD_INT 16
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: PUSH
13813: LD_INT 25
13815: PUSH
13816: LD_INT 15
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: PUSH
13823: LD_INT 25
13825: PUSH
13826: LD_INT 17
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: PPUSH
13844: CALL_OW 69
13848: PUSH
13849: LD_INT 22
13851: PUSH
13852: LD_INT 7
13854: PUSH
13855: EMPTY
13856: LIST
13857: LIST
13858: PUSH
13859: LD_INT 21
13861: PUSH
13862: LD_INT 1
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: PUSH
13869: LD_INT 3
13871: PUSH
13872: LD_INT 2
13874: PUSH
13875: LD_INT 25
13877: PUSH
13878: LD_INT 12
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: PUSH
13885: LD_INT 25
13887: PUSH
13888: LD_INT 16
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: PUSH
13895: LD_INT 25
13897: PUSH
13898: LD_INT 15
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: PUSH
13905: LD_INT 25
13907: PUSH
13908: LD_INT 17
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: LIST
13930: PPUSH
13931: CALL_OW 69
13935: GREATER
13936: IFFALSE 13947
// begin SetAchievement ( ACH_POTA ) ;
13938: LD_STRING ACH_POTA
13940: PPUSH
13941: CALL_OW 543
// exit ;
13945: GO 13948
// end ; enable ;
13947: ENABLE
// end ;
13948: END

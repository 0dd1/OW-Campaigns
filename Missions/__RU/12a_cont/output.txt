// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 4 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 4
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$40 , 0 0$30 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1400
 345: PUSH
 346: LD_INT 1050
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 1 1$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 2100
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// if scientists > 5 then
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1304
// for i := 6 to scientists do
1260: LD_ADDR_VAR 0 3
1264: PUSH
1265: DOUBLE
1266: LD_INT 6
1268: DEC
1269: ST_TO_ADDR
1270: LD_EXP 40
1274: PUSH
1275: FOR_TO
1276: IFFALSE 1302
// scientists := scientists diff scientists [ i ] ;
1278: LD_ADDR_EXP 40
1282: PUSH
1283: LD_EXP 40
1287: PUSH
1288: LD_EXP 40
1292: PUSH
1293: LD_VAR 0 3
1297: ARRAY
1298: DIFF
1299: ST_TO_ADDR
1300: GO 1275
1302: POP
1303: POP
// survivors3 = survivors3 diff scientists ;
1304: LD_ADDR_EXP 22
1308: PUSH
1309: LD_EXP 22
1313: PUSH
1314: LD_EXP 40
1318: DIFF
1319: ST_TO_ADDR
// if scientists < 5 then
1320: LD_EXP 40
1324: PUSH
1325: LD_INT 5
1327: LESS
1328: IFFALSE 1419
// for i := 1 to 5 - scientists do
1330: LD_ADDR_VAR 0 3
1334: PUSH
1335: DOUBLE
1336: LD_INT 1
1338: DEC
1339: ST_TO_ADDR
1340: LD_INT 5
1342: PUSH
1343: LD_EXP 40
1347: MINUS
1348: PUSH
1349: FOR_TO
1350: IFFALSE 1417
// begin uc_side = ally ;
1352: LD_ADDR_OWVAR 20
1356: PUSH
1357: LD_EXP 25
1361: ST_TO_ADDR
// uc_nation := nation_russian ;
1362: LD_ADDR_OWVAR 21
1366: PUSH
1367: LD_INT 3
1369: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1370: LD_INT 0
1372: PPUSH
1373: LD_INT 4
1375: PPUSH
1376: LD_INT 5
1378: PPUSH
1379: LD_INT 7
1381: PPUSH
1382: CALL_OW 12
1386: PPUSH
1387: CALL_OW 380
// hc_name :=  ;
1391: LD_ADDR_OWVAR 26
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1399: LD_ADDR_EXP 40
1403: PUSH
1404: LD_EXP 40
1408: PUSH
1409: CALL_OW 44
1413: ADD
1414: ST_TO_ADDR
// end ;
1415: GO 1349
1417: POP
1418: POP
// for un in scientists do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_EXP 40
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1448
// SetSide ( un , ally ) ;
1432: LD_VAR 0 2
1436: PPUSH
1437: LD_EXP 25
1441: PPUSH
1442: CALL_OW 235
1446: GO 1429
1448: POP
1449: POP
// possible := all_possible diff scientists ;
1450: LD_ADDR_EXP 38
1454: PUSH
1455: LD_EXP 39
1459: PUSH
1460: LD_EXP 40
1464: DIFF
1465: ST_TO_ADDR
// for un in scientists do
1466: LD_ADDR_VAR 0 2
1470: PUSH
1471: LD_EXP 40
1475: PUSH
1476: FOR_IN
1477: IFFALSE 1493
// PlaceHumanInUnit ( un , 2 ) ;
1479: LD_VAR 0 2
1483: PPUSH
1484: LD_INT 2
1486: PPUSH
1487: CALL_OW 52
1491: GO 1476
1493: POP
1494: POP
// new := [ ] ;
1495: LD_ADDR_EXP 36
1499: PUSH
1500: EMPTY
1501: ST_TO_ADDR
// if possible < 10 then
1502: LD_EXP 38
1506: PUSH
1507: LD_INT 10
1509: LESS
1510: IFFALSE 1593
// for i := 1 to 10 - possible do
1512: LD_ADDR_VAR 0 3
1516: PUSH
1517: DOUBLE
1518: LD_INT 1
1520: DEC
1521: ST_TO_ADDR
1522: LD_INT 10
1524: PUSH
1525: LD_EXP 38
1529: MINUS
1530: PUSH
1531: FOR_TO
1532: IFFALSE 1591
// begin uc_side = rus ;
1534: LD_ADDR_OWVAR 20
1538: PUSH
1539: LD_EXP 24
1543: ST_TO_ADDR
// uc_nation := nation_russian ;
1544: LD_ADDR_OWVAR 21
1548: PUSH
1549: LD_INT 3
1551: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1552: LD_INT 0
1554: PPUSH
1555: LD_INT 0
1557: PPUSH
1558: LD_INT 5
1560: PPUSH
1561: CALL_OW 380
// hc_name :=  ;
1565: LD_ADDR_OWVAR 26
1569: PUSH
1570: LD_STRING 
1572: ST_TO_ADDR
// new := new ^ CreateHuman ;
1573: LD_ADDR_EXP 36
1577: PUSH
1578: LD_EXP 36
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// end ;
1589: GO 1531
1591: POP
1592: POP
// uc_side = rus ;
1593: LD_ADDR_OWVAR 20
1597: PUSH
1598: LD_EXP 24
1602: ST_TO_ADDR
// uc_nation := nation_russian ;
1603: LD_ADDR_OWVAR 21
1607: PUSH
1608: LD_INT 3
1610: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1611: LD_ADDR_EXP 1
1615: PUSH
1616: LD_STRING Burlak
1618: PPUSH
1619: CALL 565 0 1
1623: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1624: LD_EXP 1
1628: PPUSH
1629: LD_INT 3
1631: PPUSH
1632: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1636: LD_ADDR_EXP 20
1640: PUSH
1641: LD_STRING Platonov
1643: PPUSH
1644: CALL_OW 25
1648: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 1
1654: PPUSH
1655: LD_INT 4
1657: PPUSH
1658: CALL_OW 380
// hc_name :=  ;
1662: LD_ADDR_OWVAR 26
1666: PUSH
1667: LD_STRING 
1669: ST_TO_ADDR
// RSoldier := CreateHuman ;
1670: LD_ADDR_EXP 21
1674: PUSH
1675: CALL_OW 44
1679: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1680: LD_ADDR_VAR 0 3
1684: PUSH
1685: DOUBLE
1686: LD_INT 1
1688: DEC
1689: ST_TO_ADDR
1690: LD_EXP 31
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: LD_EXP 30
1702: MUL
1703: PLUS
1704: PUSH
1705: FOR_TO
1706: IFFALSE 1798
// begin case Rand ( 1 , 2 ) of 1 :
1708: LD_INT 1
1710: PPUSH
1711: LD_INT 2
1713: PPUSH
1714: CALL_OW 12
1718: PUSH
1719: LD_INT 1
1721: DOUBLE
1722: EQUAL
1723: IFTRUE 1727
1725: GO 1745
1727: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1728: LD_INT 1
1730: PPUSH
1731: LD_INT 1
1733: PPUSH
1734: LD_EXP 32
1738: PPUSH
1739: CALL_OW 380
1743: GO 1772
1745: LD_INT 2
1747: DOUBLE
1748: EQUAL
1749: IFTRUE 1753
1751: GO 1771
1753: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1754: LD_INT 1
1756: PPUSH
1757: LD_INT 9
1759: PPUSH
1760: LD_EXP 32
1764: PPUSH
1765: CALL_OW 380
1769: GO 1772
1771: POP
// hc_name :=  ;
1772: LD_ADDR_OWVAR 26
1776: PUSH
1777: LD_STRING 
1779: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1780: LD_ADDR_EXP 29
1784: PUSH
1785: LD_EXP 29
1789: PUSH
1790: CALL_OW 44
1794: ADD
1795: ST_TO_ADDR
// end ;
1796: GO 1705
1798: POP
1799: POP
// end ;
1800: LD_VAR 0 1
1804: RET
// function select_people ; var units , un ; begin
1805: LD_INT 0
1807: PPUSH
1808: PPUSH
1809: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1810: LD_ADDR_EXP 41
1814: PUSH
1815: LD_STRING 
1817: PPUSH
1818: LD_INT 5
1820: PPUSH
1821: LD_INT 5
1823: PPUSH
1824: LD_INT -1
1826: PUSH
1827: LD_INT -4
1829: PUSH
1830: LD_INT -6
1832: PUSH
1833: EMPTY
1834: LIST
1835: LIST
1836: LIST
1837: PUSH
1838: LD_EXP 1
1842: ADD
1843: PUSH
1844: LD_INT -2
1846: PUSH
1847: LD_INT -4
1849: PUSH
1850: LD_INT -6
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: ADD
1858: PUSH
1859: LD_EXP 20
1863: ADD
1864: PUSH
1865: LD_INT -2
1867: PUSH
1868: LD_INT -5
1870: PUSH
1871: LD_INT -3
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: LIST
1878: ADD
1879: PUSH
1880: LD_EXP 38
1884: ADD
1885: PUSH
1886: LD_EXP 22
1890: ADD
1891: PUSH
1892: LD_EXP 36
1896: ADD
1897: PPUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 2
1906: PUSH
1907: LD_INT 4
1909: PUSH
1910: LD_INT 9
1912: PUSH
1913: LD_INT 0
1915: PUSH
1916: LD_INT 2
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: PUSH
1924: EMPTY
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: PPUSH
1931: CALL_OW 42
1935: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1936: LD_EXP 41
1940: PUSH
1941: LD_EXP 1
1945: DIFF
1946: PPUSH
1947: LD_EXP 27
1951: PPUSH
1952: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1956: LD_ADDR_VAR 0 3
1960: PUSH
1961: LD_EXP 41
1965: PUSH
1966: LD_EXP 1
1970: DIFF
1971: PUSH
1972: FOR_IN
1973: IFFALSE 1992
// PlaceUnitArea ( un , BaseArea , false ) ;
1975: LD_VAR 0 3
1979: PPUSH
1980: LD_INT 2
1982: PPUSH
1983: LD_INT 0
1985: PPUSH
1986: CALL_OW 49
1990: GO 1972
1992: POP
1993: POP
// end ;
1994: LD_VAR 0 1
1998: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
1999: LD_INT 0
2001: PPUSH
2002: PPUSH
2003: PPUSH
2004: PPUSH
2005: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2006: LD_ADDR_VAR 0 3
2010: PUSH
2011: LD_STRING EscapeVehicle_12a
2013: PPUSH
2014: LD_INT 1
2016: PUSH
2017: LD_INT 0
2019: PUSH
2020: LD_INT 0
2022: PUSH
2023: EMPTY
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 30
2032: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2033: LD_ADDR_LOC 1
2037: PUSH
2038: LD_VAR 0 3
2042: PUSH
2043: LD_INT 1
2045: ARRAY
2046: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2047: LD_ADDR_VAR 0 4
2051: PUSH
2052: LD_VAR 0 3
2056: PUSH
2057: LD_INT 2
2059: ARRAY
2060: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2061: LD_ADDR_VAR 0 5
2065: PUSH
2066: LD_VAR 0 3
2070: PUSH
2071: LD_INT 3
2073: ARRAY
2074: ST_TO_ADDR
// if MashaWanted then
2075: LD_LOC 1
2079: IFFALSE 2295
// begin veh := LoadVariable ( Masha , false ) ;
2081: LD_ADDR_VAR 0 2
2085: PUSH
2086: LD_STRING Masha
2088: PPUSH
2089: LD_INT 0
2091: PPUSH
2092: CALL_OW 30
2096: ST_TO_ADDR
// if veh then
2097: LD_VAR 0 2
2101: IFFALSE 2217
// begin uc_side := rus ;
2103: LD_ADDR_OWVAR 20
2107: PUSH
2108: LD_EXP 24
2112: ST_TO_ADDR
// uc_nation := nation_russian ;
2113: LD_ADDR_OWVAR 21
2117: PUSH
2118: LD_INT 3
2120: ST_TO_ADDR
// uc_direction := 2 ;
2121: LD_ADDR_OWVAR 24
2125: PUSH
2126: LD_INT 2
2128: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2129: LD_ADDR_OWVAR 37
2133: PUSH
2134: LD_VAR 0 2
2138: PUSH
2139: LD_INT 1
2141: ARRAY
2142: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2143: LD_ADDR_OWVAR 39
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_INT 2
2155: ARRAY
2156: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2157: LD_ADDR_OWVAR 38
2161: PUSH
2162: LD_VAR 0 2
2166: PUSH
2167: LD_INT 3
2169: ARRAY
2170: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2171: LD_ADDR_OWVAR 40
2175: PUSH
2176: LD_VAR 0 2
2180: PUSH
2181: LD_INT 4
2183: ARRAY
2184: ST_TO_ADDR
// RealMasha := true ;
2185: LD_ADDR_EXP 42
2189: PUSH
2190: LD_INT 1
2192: ST_TO_ADDR
// Masha := CreateVehicle ;
2193: LD_ADDR_EXP 43
2197: PUSH
2198: CALL_OW 45
2202: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
2203: LD_EXP 43
2207: PPUSH
2208: LD_INT 1
2210: PPUSH
2211: CALL_OW 242
// end else
2215: GO 2293
// begin uc_side := rus ;
2217: LD_ADDR_OWVAR 20
2221: PUSH
2222: LD_EXP 24
2226: ST_TO_ADDR
// uc_nation := nation_russian ;
2227: LD_ADDR_OWVAR 21
2231: PUSH
2232: LD_INT 3
2234: ST_TO_ADDR
// uc_direction := 2 ;
2235: LD_ADDR_OWVAR 24
2239: PUSH
2240: LD_INT 2
2242: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2243: LD_ADDR_OWVAR 37
2247: PUSH
2248: LD_INT 22
2250: ST_TO_ADDR
// vc_engine := engine_siberite ;
2251: LD_ADDR_OWVAR 39
2255: PUSH
2256: LD_INT 3
2258: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2259: LD_ADDR_OWVAR 40
2263: PUSH
2264: LD_INT 43
2266: ST_TO_ADDR
// vc_control := control_manual ;
2267: LD_ADDR_OWVAR 38
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
// RealMasha := false ;
2275: LD_ADDR_EXP 42
2279: PUSH
2280: LD_INT 0
2282: ST_TO_ADDR
// Masha := CreateVehicle ;
2283: LD_ADDR_EXP 43
2287: PUSH
2288: CALL_OW 45
2292: ST_TO_ADDR
// end ; end else
2293: GO 2375
// begin uc_side := rus ;
2295: LD_ADDR_OWVAR 20
2299: PUSH
2300: LD_EXP 24
2304: ST_TO_ADDR
// uc_nation := nation_russian ;
2305: LD_ADDR_OWVAR 21
2309: PUSH
2310: LD_INT 3
2312: ST_TO_ADDR
// uc_direction := 2 ;
2313: LD_ADDR_OWVAR 24
2317: PUSH
2318: LD_INT 2
2320: ST_TO_ADDR
// vc_chassis := Chassis ;
2321: LD_ADDR_OWVAR 37
2325: PUSH
2326: LD_VAR 0 4
2330: ST_TO_ADDR
// vc_engine := engine_siberite ;
2331: LD_ADDR_OWVAR 39
2335: PUSH
2336: LD_INT 3
2338: ST_TO_ADDR
// vc_weapon := Weapon ;
2339: LD_ADDR_OWVAR 40
2343: PUSH
2344: LD_VAR 0 5
2348: ST_TO_ADDR
// vc_control := control_manual ;
2349: LD_ADDR_OWVAR 38
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// RealMasha := false ;
2357: LD_ADDR_EXP 42
2361: PUSH
2362: LD_INT 0
2364: ST_TO_ADDR
// Masha := CreateVehicle ;
2365: LD_ADDR_EXP 43
2369: PUSH
2370: CALL_OW 45
2374: ST_TO_ADDR
// end ; if GetEngine ( Masha ) <> engine_siberite then
2375: LD_EXP 43
2379: PPUSH
2380: CALL_OW 262
2384: PUSH
2385: LD_INT 3
2387: NONEQUAL
2388: IFFALSE 2410
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2390: LD_EXP 43
2394: PPUSH
2395: LD_INT 70
2397: PPUSH
2398: LD_INT 95
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2410: LD_EXP 43
2414: PPUSH
2415: LD_INT 47
2417: PPUSH
2418: LD_INT 87
2420: PPUSH
2421: LD_INT 0
2423: PPUSH
2424: CALL_OW 48
// end ;
2428: LD_VAR 0 1
2432: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2433: LD_INT 1
2435: PPUSH
2436: LD_STRING bluekher
2438: PPUSH
2439: CALL_OW 500
// IngameOn ;
2443: CALL_OW 8
// Randomize ;
2447: CALL_OW 10
// RandomizeAll ;
2451: CALL_OW 11
// InitBc ;
2455: CALL_OW 21
// InitHc ;
2459: CALL_OW 19
// InitUc ;
2463: CALL_OW 18
// InitVc ;
2467: CALL_OW 20
// disable ( 1 ) ;
2471: LD_INT 1
2473: DISABLE_MARKED
// disable ( 2 ) ;
2474: LD_INT 2
2476: DISABLE_MARKED
// disable ( 3 ) ;
2477: LD_INT 3
2479: DISABLE_MARKED
// disable ( 4 ) ;
2480: LD_INT 4
2482: DISABLE_MARKED
// disable ( 6 ) ;
2483: LD_INT 6
2485: DISABLE_MARKED
// disable ( 7 ) ;
2486: LD_INT 7
2488: DISABLE_MARKED
// disable ( 8 ) ;
2489: LD_INT 8
2491: DISABLE_MARKED
// disable ( 9 ) ;
2492: LD_INT 9
2494: DISABLE_MARKED
// disable ( 333 ) ;
2495: LD_INT 333
2497: DISABLE_MARKED
// disable ( 337 ) ;
2498: LD_INT 337
2500: DISABLE_MARKED
// disable ( 401 ) ;
2501: LD_INT 401
2503: DISABLE_MARKED
// read_parameters ;
2504: CALL 0 0 0
// set_difficulty ;
2508: CALL 257 0 0
// create_people ;
2512: CALL 609 0 0
// select_people ;
2516: CALL 1805 0 0
// place_masha ;
2520: CALL 1999 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2524: LD_INT 53
2526: PPUSH
2527: LD_INT 90
2529: PPUSH
2530: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2534: LD_EXP 1
2538: PPUSH
2539: LD_INT 51
2541: PPUSH
2542: LD_INT 88
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 48
// ComHold ( Burlak ) ;
2552: LD_EXP 1
2556: PPUSH
2557: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2561: LD_EXP 21
2565: PPUSH
2566: LD_INT 54
2568: PPUSH
2569: LD_INT 90
2571: PPUSH
2572: LD_INT 0
2574: PPUSH
2575: CALL_OW 48
// ComHold ( RSoldier ) ;
2579: LD_EXP 21
2583: PPUSH
2584: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2588: LD_EXP 1
2592: PPUSH
2593: LD_EXP 21
2597: PPUSH
2598: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2602: LD_EXP 21
2606: PPUSH
2607: LD_EXP 1
2611: PPUSH
2612: CALL_OW 119
// D_Platonov ;
2616: CALL 5266 0 0
// IngameOff ;
2620: CALL_OW 9
// SaveForQuickRestart ;
2624: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2628: LD_STRING MRun
2630: PPUSH
2631: CALL_OW 337
// ChangeSideFog ( you , you ) ;
2635: LD_EXP 23
2639: PPUSH
2640: LD_EXP 23
2644: PPUSH
2645: CALL_OW 343
// SetSide ( Burlak , you ) ;
2649: LD_EXP 1
2653: PPUSH
2654: LD_EXP 23
2658: PPUSH
2659: CALL_OW 235
// SetSide ( Masha , you ) ;
2663: LD_EXP 43
2667: PPUSH
2668: LD_EXP 23
2672: PPUSH
2673: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2677: LD_INT 1
2679: PPUSH
2680: LD_INT 2
2682: PPUSH
2683: CALL_OW 12
2687: PUSH
2688: LD_INT 1
2690: DOUBLE
2691: EQUAL
2692: IFTRUE 2696
2694: GO 2754
2696: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2697: LD_ADDR_LOC 2
2701: PUSH
2702: DOUBLE
2703: LD_EXP 31
2707: PUSH
2708: LD_INT 1
2710: PLUS
2711: DEC
2712: ST_TO_ADDR
2713: LD_EXP 31
2717: PUSH
2718: LD_EXP 30
2722: PLUS
2723: PUSH
2724: FOR_TO
2725: IFFALSE 2750
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2727: LD_EXP 29
2731: PUSH
2732: LD_LOC 2
2736: ARRAY
2737: PPUSH
2738: LD_INT 4
2740: PPUSH
2741: LD_INT 0
2743: PPUSH
2744: CALL_OW 49
2748: GO 2724
2750: POP
2751: POP
// end ; 2 :
2752: GO 2821
2754: LD_INT 2
2756: DOUBLE
2757: EQUAL
2758: IFTRUE 2762
2760: GO 2820
2762: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2763: LD_ADDR_LOC 2
2767: PUSH
2768: DOUBLE
2769: LD_EXP 31
2773: PUSH
2774: LD_INT 1
2776: PLUS
2777: DEC
2778: ST_TO_ADDR
2779: LD_EXP 31
2783: PUSH
2784: LD_EXP 30
2788: PLUS
2789: PUSH
2790: FOR_TO
2791: IFFALSE 2816
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2793: LD_EXP 29
2797: PUSH
2798: LD_LOC 2
2802: ARRAY
2803: PPUSH
2804: LD_INT 5
2806: PPUSH
2807: LD_INT 0
2809: PPUSH
2810: CALL_OW 49
2814: GO 2790
2816: POP
2817: POP
// end ; end ;
2818: GO 2821
2820: POP
// case Rand ( 1 , 2 ) of 1 :
2821: LD_INT 1
2823: PPUSH
2824: LD_INT 2
2826: PPUSH
2827: CALL_OW 12
2831: PUSH
2832: LD_INT 1
2834: DOUBLE
2835: EQUAL
2836: IFTRUE 2840
2838: GO 2908
2840: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2841: LD_ADDR_LOC 2
2845: PUSH
2846: DOUBLE
2847: LD_EXP 31
2851: PUSH
2852: LD_INT 1
2854: PLUS
2855: PUSH
2856: LD_EXP 30
2860: PLUS
2861: DEC
2862: ST_TO_ADDR
2863: LD_EXP 31
2867: PUSH
2868: LD_INT 2
2870: PUSH
2871: LD_EXP 30
2875: MUL
2876: PLUS
2877: PUSH
2878: FOR_TO
2879: IFFALSE 2904
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2881: LD_EXP 29
2885: PUSH
2886: LD_LOC 2
2890: ARRAY
2891: PPUSH
2892: LD_INT 8
2894: PPUSH
2895: LD_INT 0
2897: PPUSH
2898: CALL_OW 49
2902: GO 2878
2904: POP
2905: POP
// end ; 2 :
2906: GO 2985
2908: LD_INT 2
2910: DOUBLE
2911: EQUAL
2912: IFTRUE 2916
2914: GO 2984
2916: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2917: LD_ADDR_LOC 2
2921: PUSH
2922: DOUBLE
2923: LD_EXP 31
2927: PUSH
2928: LD_INT 1
2930: PLUS
2931: PUSH
2932: LD_EXP 30
2936: PLUS
2937: DEC
2938: ST_TO_ADDR
2939: LD_EXP 31
2943: PUSH
2944: LD_INT 2
2946: PUSH
2947: LD_EXP 30
2951: MUL
2952: PLUS
2953: PUSH
2954: FOR_TO
2955: IFFALSE 2980
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
2957: LD_EXP 29
2961: PUSH
2962: LD_LOC 2
2966: ARRAY
2967: PPUSH
2968: LD_INT 7
2970: PPUSH
2971: LD_INT 0
2973: PPUSH
2974: CALL_OW 49
2978: GO 2954
2980: POP
2981: POP
// end ; end ;
2982: GO 2985
2984: POP
// case Rand ( 1 , 2 ) of 1 :
2985: LD_INT 1
2987: PPUSH
2988: LD_INT 2
2990: PPUSH
2991: CALL_OW 12
2995: PUSH
2996: LD_INT 1
2998: DOUBLE
2999: EQUAL
3000: IFTRUE 3004
3002: GO 3076
3004: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3005: LD_ADDR_LOC 2
3009: PUSH
3010: DOUBLE
3011: LD_EXP 31
3015: PUSH
3016: LD_INT 1
3018: PLUS
3019: PUSH
3020: LD_INT 2
3022: PUSH
3023: LD_EXP 30
3027: MUL
3028: PLUS
3029: DEC
3030: ST_TO_ADDR
3031: LD_EXP 31
3035: PUSH
3036: LD_INT 3
3038: PUSH
3039: LD_EXP 30
3043: MUL
3044: PLUS
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3072
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3049: LD_EXP 29
3053: PUSH
3054: LD_LOC 2
3058: ARRAY
3059: PPUSH
3060: LD_INT 6
3062: PPUSH
3063: LD_INT 0
3065: PPUSH
3066: CALL_OW 49
3070: GO 3046
3072: POP
3073: POP
// end ; 2 :
3074: GO 3157
3076: LD_INT 2
3078: DOUBLE
3079: EQUAL
3080: IFTRUE 3084
3082: GO 3156
3084: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3085: LD_ADDR_LOC 2
3089: PUSH
3090: DOUBLE
3091: LD_EXP 31
3095: PUSH
3096: LD_INT 1
3098: PLUS
3099: PUSH
3100: LD_INT 2
3102: PUSH
3103: LD_EXP 30
3107: MUL
3108: PLUS
3109: DEC
3110: ST_TO_ADDR
3111: LD_EXP 31
3115: PUSH
3116: LD_INT 3
3118: PUSH
3119: LD_EXP 30
3123: MUL
3124: PLUS
3125: PUSH
3126: FOR_TO
3127: IFFALSE 3152
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3129: LD_EXP 29
3133: PUSH
3134: LD_LOC 2
3138: ARRAY
3139: PPUSH
3140: LD_INT 16
3142: PPUSH
3143: LD_INT 0
3145: PPUSH
3146: CALL_OW 49
3150: GO 3126
3152: POP
3153: POP
// end ; end ;
3154: GO 3157
3156: POP
// ComMoveXY ( Masha , 40 , 69 ) ;
3157: LD_EXP 43
3161: PPUSH
3162: LD_INT 40
3164: PPUSH
3165: LD_INT 69
3167: PPUSH
3168: CALL_OW 111
// Wait ( 1 1$0 ) ;
3172: LD_INT 2100
3174: PPUSH
3175: CALL_OW 67
// for i := 1 to pursuers_base do
3179: LD_ADDR_LOC 2
3183: PUSH
3184: DOUBLE
3185: LD_INT 1
3187: DEC
3188: ST_TO_ADDR
3189: LD_EXP 31
3193: PUSH
3194: FOR_TO
3195: IFFALSE 3264
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3197: LD_EXP 29
3201: PUSH
3202: LD_LOC 2
3206: ARRAY
3207: PPUSH
3208: LD_INT 9
3210: PPUSH
3211: LD_INT 0
3213: PPUSH
3214: CALL_OW 49
3218: NOT
3219: IFFALSE 3242
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3221: LD_EXP 29
3225: PUSH
3226: LD_LOC 2
3230: ARRAY
3231: PPUSH
3232: LD_INT 3
3234: PPUSH
3235: LD_INT 0
3237: PPUSH
3238: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3242: LD_EXP 29
3246: PUSH
3247: LD_LOC 2
3251: ARRAY
3252: PPUSH
3253: LD_EXP 1
3257: PPUSH
3258: CALL_OW 115
// end ;
3262: GO 3194
3264: POP
3265: POP
// Wait ( straz_start ) ;
3266: LD_EXP 35
3270: PPUSH
3271: CALL_OW 67
// enable ( 1 ) ;
3275: LD_INT 1
3277: ENABLE_MARKED
// enable ( 2 ) ;
3278: LD_INT 2
3280: ENABLE_MARKED
// end ;
3281: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3282: LD_INT 0
3284: PPUSH
3285: PPUSH
3286: PPUSH
3287: PPUSH
3288: PPUSH
3289: PPUSH
3290: PPUSH
3291: PPUSH
3292: PPUSH
3293: PPUSH
3294: PPUSH
3295: PPUSH
3296: PPUSH
3297: PPUSH
3298: PPUSH
3299: PPUSH
3300: PPUSH
3301: PPUSH
3302: PPUSH
3303: PPUSH
3304: PPUSH
3305: PPUSH
3306: PPUSH
3307: PPUSH
// gained_medals := [ ] ;
3308: LD_ADDR_OWVAR 61
3312: PUSH
3313: EMPTY
3314: ST_TO_ADDR
// missing_medals := [ ] ;
3315: LD_ADDR_OWVAR 62
3319: PUSH
3320: EMPTY
3321: ST_TO_ADDR
// reward_units := [ ] ;
3322: LD_ADDR_VAR 0 5
3326: PUSH
3327: EMPTY
3328: ST_TO_ADDR
// if scientists_dead = 0 then
3329: LD_EXP 49
3333: PUSH
3334: LD_INT 0
3336: EQUAL
3337: IFFALSE 3351
// AddMedal ( Science , 1 ) else
3339: LD_STRING Science
3341: PPUSH
3342: LD_INT 1
3344: PPUSH
3345: CALL_OW 101
3349: GO 3362
// AddMedal ( Science , - 1 ) ;
3351: LD_STRING Science
3353: PPUSH
3354: LD_INT 1
3356: NEG
3357: PPUSH
3358: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3362: LD_ADDR_VAR 0 4
3366: PUSH
3367: LD_INT 22
3369: PUSH
3370: LD_EXP 23
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 2
3381: PUSH
3382: LD_INT 30
3384: PUSH
3385: LD_INT 0
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 30
3394: PUSH
3395: LD_INT 1
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PPUSH
3411: CALL_OW 69
3415: ST_TO_ADDR
// matros := 0 ;
3416: LD_ADDR_VAR 0 2
3420: PUSH
3421: LD_INT 0
3423: ST_TO_ADDR
// if 0 + filter <> 0 then
3424: LD_INT 0
3426: PUSH
3427: LD_VAR 0 4
3431: PLUS
3432: PUSH
3433: LD_INT 0
3435: NONEQUAL
3436: IFFALSE 3484
// for un in filter do
3438: LD_ADDR_VAR 0 3
3442: PUSH
3443: LD_VAR 0 4
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3482
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3451: LD_ADDR_VAR 0 2
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: CALL_OW 274
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: CALL_OW 275
3478: PLUS
3479: ST_TO_ADDR
3480: GO 3448
3482: POP
3483: POP
// if matros > 100 then
3484: LD_VAR 0 2
3488: PUSH
3489: LD_INT 100
3491: GREATER
3492: IFFALSE 3506
// AddMedal ( Effectivity , 1 ) else
3494: LD_STRING Effectivity
3496: PPUSH
3497: LD_INT 1
3499: PPUSH
3500: CALL_OW 101
3504: GO 3517
// AddMedal ( Effectivity , - 1 ) ;
3506: LD_STRING Effectivity
3508: PPUSH
3509: LD_INT 1
3511: NEG
3512: PPUSH
3513: CALL_OW 101
// rus_building_destroyed := false ;
3517: LD_ADDR_VAR 0 7
3521: PUSH
3522: LD_INT 0
3524: ST_TO_ADDR
// for un in rus_mcrep_bui do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: LD_EXP 64
3534: PUSH
3535: FOR_IN
3536: IFFALSE 3566
// if not IsLive ( un ) then
3538: LD_VAR 0 3
3542: PPUSH
3543: CALL_OW 300
3547: NOT
3548: IFFALSE 3564
// rus_building_destroyed := rus_building_destroyed + 1 ;
3550: LD_ADDR_VAR 0 7
3554: PUSH
3555: LD_VAR 0 7
3559: PUSH
3560: LD_INT 1
3562: PLUS
3563: ST_TO_ADDR
3564: GO 3535
3566: POP
3567: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3568: LD_EXP 53
3572: PUSH
3573: LD_INT 5
3575: GREATEREQUAL
3576: PUSH
3577: LD_VAR 0 7
3581: PUSH
3582: LD_INT 2
3584: GREATEREQUAL
3585: OR
3586: IFFALSE 3601
// AddMedal ( LittleLosses , - 1 ) else
3588: LD_STRING LittleLosses
3590: PPUSH
3591: LD_INT 1
3593: NEG
3594: PPUSH
3595: CALL_OW 101
3599: GO 3611
// AddMedal ( LittleLosses , 1 ) ;
3601: LD_STRING LittleLosses
3603: PPUSH
3604: LD_INT 1
3606: PPUSH
3607: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , killed_russians >= 5 or rus_building_destroyed >= 2 ) ;
3611: LD_INT 4
3613: PPUSH
3614: LD_INT 5
3616: PPUSH
3617: LD_EXP 49
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: PPUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 100
3633: GREATER
3634: PPUSH
3635: LD_EXP 53
3639: PUSH
3640: LD_INT 5
3642: GREATEREQUAL
3643: PUSH
3644: LD_VAR 0 7
3648: PUSH
3649: LD_INT 2
3651: GREATEREQUAL
3652: OR
3653: PPUSH
3654: CALL 14163 0 5
// GiveMedals ( Main ) ;
3658: LD_STRING Main
3660: PPUSH
3661: CALL_OW 102
// for un in player_units do
3665: LD_ADDR_VAR 0 3
3669: PUSH
3670: LD_EXP 41
3674: PUSH
3675: FOR_IN
3676: IFFALSE 3708
// if not IsDead ( un ) then
3678: LD_VAR 0 3
3682: PPUSH
3683: CALL_OW 301
3687: NOT
3688: IFFALSE 3706
// reward_units := reward_units ^ un ;
3690: LD_ADDR_VAR 0 5
3694: PUSH
3695: LD_VAR 0 5
3699: PUSH
3700: LD_VAR 0 3
3704: ADD
3705: ST_TO_ADDR
3706: GO 3675
3708: POP
3709: POP
// RewardPeople ( reward_units ) ;
3710: LD_VAR 0 5
3714: PPUSH
3715: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3719: LD_EXP 40
3723: PUSH
3724: LD_EXP 39
3728: PUSH
3729: LD_EXP 8
3733: ADD
3734: DIFF
3735: PPUSH
3736: LD_STRING scientists
3738: PPUSH
3739: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3743: LD_ADDR_VAR 0 6
3747: PUSH
3748: LD_EXP 41
3752: PUSH
3753: LD_EXP 39
3757: PUSH
3758: LD_EXP 40
3762: ADD
3763: PUSH
3764: LD_EXP 1
3768: ADD
3769: PUSH
3770: LD_EXP 8
3774: ADD
3775: DIFF
3776: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3777: LD_VAR 0 6
3781: PPUSH
3782: LD_STRING survivors5
3784: PPUSH
3785: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3789: LD_EXP 1
3793: PPUSH
3794: LD_STRING Burlak
3796: PPUSH
3797: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3801: LD_EXP 2
3805: PPUSH
3806: LD_STRING Belkov
3808: PPUSH
3809: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3813: LD_EXP 3
3817: PPUSH
3818: LD_STRING Gnyevko
3820: PPUSH
3821: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3825: LD_EXP 4
3829: PPUSH
3830: LD_STRING Kirilenkova
3832: PPUSH
3833: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3837: LD_EXP 5
3841: PPUSH
3842: LD_STRING Gleb
3844: PPUSH
3845: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3849: LD_EXP 6
3853: PPUSH
3854: LD_STRING Petrosyan
3856: PPUSH
3857: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3861: LD_EXP 7
3865: PPUSH
3866: LD_STRING Titov
3868: PPUSH
3869: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3873: LD_EXP 8
3877: PPUSH
3878: LD_STRING Gossudarov
3880: PPUSH
3881: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3885: LD_EXP 9
3889: PPUSH
3890: LD_STRING Kovalyuk
3892: PPUSH
3893: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3897: LD_EXP 10
3901: PPUSH
3902: LD_STRING Scholtze
3904: PPUSH
3905: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3909: LD_EXP 11
3913: PPUSH
3914: LD_STRING Kuzmov
3916: PPUSH
3917: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3921: LD_EXP 12
3925: PPUSH
3926: LD_STRING Karamazov
3928: PPUSH
3929: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3933: LD_EXP 13
3937: PPUSH
3938: LD_STRING Petrovova
3940: PPUSH
3941: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3945: LD_EXP 14
3949: PPUSH
3950: LD_STRING Lipshchin
3952: PPUSH
3953: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3957: LD_EXP 15
3961: PPUSH
3962: LD_STRING Dolgov
3964: PPUSH
3965: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
3969: LD_EXP 16
3973: PPUSH
3974: LD_STRING Xavier
3976: PPUSH
3977: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
3981: LD_EXP 17
3985: PPUSH
3986: LD_STRING Oblukov
3988: PPUSH
3989: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
3993: LD_EXP 18
3997: PPUSH
3998: LD_STRING Kozlov
4000: PPUSH
4001: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4005: LD_EXP 19
4009: PPUSH
4010: LD_STRING Kapitsova
4012: PPUSH
4013: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4017: LD_EXP 42
4021: PUSH
4022: LD_EXP 52
4026: AND
4027: PUSH
4028: LD_LOC 1
4032: NOT
4033: OR
4034: IFFALSE 4043
// DeleteVariable ( Masha ) ;
4036: LD_STRING Masha
4038: PPUSH
4039: CALL_OW 41
// if Belkov in scientists then
4043: LD_EXP 2
4047: PUSH
4048: LD_EXP 40
4052: IN
4053: IFFALSE 4065
// belkov_side := 2 else
4055: LD_ADDR_VAR 0 8
4059: PUSH
4060: LD_INT 2
4062: ST_TO_ADDR
4063: GO 4095
// if Belkov in player_units then
4065: LD_EXP 2
4069: PUSH
4070: LD_EXP 41
4074: IN
4075: IFFALSE 4087
// belkov_side := 1 else
4077: LD_ADDR_VAR 0 8
4081: PUSH
4082: LD_INT 1
4084: ST_TO_ADDR
4085: GO 4095
// belkov_side := 0 ;
4087: LD_ADDR_VAR 0 8
4091: PUSH
4092: LD_INT 0
4094: ST_TO_ADDR
// if Gnyevko in scientists then
4095: LD_EXP 3
4099: PUSH
4100: LD_EXP 40
4104: IN
4105: IFFALSE 4117
// gnyevko_side := 2 else
4107: LD_ADDR_VAR 0 9
4111: PUSH
4112: LD_INT 2
4114: ST_TO_ADDR
4115: GO 4147
// if Gnyevko in player_units then
4117: LD_EXP 3
4121: PUSH
4122: LD_EXP 41
4126: IN
4127: IFFALSE 4139
// gnyevko_side := 1 else
4129: LD_ADDR_VAR 0 9
4133: PUSH
4134: LD_INT 1
4136: ST_TO_ADDR
4137: GO 4147
// gnyevko_side := 0 ;
4139: LD_ADDR_VAR 0 9
4143: PUSH
4144: LD_INT 0
4146: ST_TO_ADDR
// if Kirilenkova in scientists then
4147: LD_EXP 4
4151: PUSH
4152: LD_EXP 40
4156: IN
4157: IFFALSE 4169
// kiril_side := 2 else
4159: LD_ADDR_VAR 0 10
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
4167: GO 4199
// if Kirilenkova in player_units then
4169: LD_EXP 4
4173: PUSH
4174: LD_EXP 41
4178: IN
4179: IFFALSE 4191
// kiril_side := 1 else
4181: LD_ADDR_VAR 0 10
4185: PUSH
4186: LD_INT 1
4188: ST_TO_ADDR
4189: GO 4199
// kiril_side := 0 ;
4191: LD_ADDR_VAR 0 10
4195: PUSH
4196: LD_INT 0
4198: ST_TO_ADDR
// if Gleb in scientists then
4199: LD_EXP 5
4203: PUSH
4204: LD_EXP 40
4208: IN
4209: IFFALSE 4221
// gleb_side := 2 else
4211: LD_ADDR_VAR 0 16
4215: PUSH
4216: LD_INT 2
4218: ST_TO_ADDR
4219: GO 4251
// if Gleb in player_units then
4221: LD_EXP 5
4225: PUSH
4226: LD_EXP 41
4230: IN
4231: IFFALSE 4243
// gleb_side := 1 else
4233: LD_ADDR_VAR 0 16
4237: PUSH
4238: LD_INT 1
4240: ST_TO_ADDR
4241: GO 4251
// gleb_side := 0 ;
4243: LD_ADDR_VAR 0 16
4247: PUSH
4248: LD_INT 0
4250: ST_TO_ADDR
// if Petrosyan in scientists then
4251: LD_EXP 6
4255: PUSH
4256: LD_EXP 40
4260: IN
4261: IFFALSE 4273
// petros_side := 2 else
4263: LD_ADDR_VAR 0 15
4267: PUSH
4268: LD_INT 2
4270: ST_TO_ADDR
4271: GO 4303
// if Petrosyan in player_units then
4273: LD_EXP 6
4277: PUSH
4278: LD_EXP 41
4282: IN
4283: IFFALSE 4295
// petros_side := 1 else
4285: LD_ADDR_VAR 0 15
4289: PUSH
4290: LD_INT 1
4292: ST_TO_ADDR
4293: GO 4303
// petros_side := 0 ;
4295: LD_ADDR_VAR 0 15
4299: PUSH
4300: LD_INT 0
4302: ST_TO_ADDR
// if Titov in scientists then
4303: LD_EXP 7
4307: PUSH
4308: LD_EXP 40
4312: IN
4313: IFFALSE 4325
// titov_side := 2 else
4315: LD_ADDR_VAR 0 19
4319: PUSH
4320: LD_INT 2
4322: ST_TO_ADDR
4323: GO 4355
// if Titov in player_units then
4325: LD_EXP 7
4329: PUSH
4330: LD_EXP 41
4334: IN
4335: IFFALSE 4347
// titov_side := 1 else
4337: LD_ADDR_VAR 0 19
4341: PUSH
4342: LD_INT 1
4344: ST_TO_ADDR
4345: GO 4355
// titov_side := 0 ;
4347: LD_ADDR_VAR 0 19
4351: PUSH
4352: LD_INT 0
4354: ST_TO_ADDR
// if Kovalyuk in scientists then
4355: LD_EXP 9
4359: PUSH
4360: LD_EXP 40
4364: IN
4365: IFFALSE 4377
// kovalyuk_side := 2 else
4367: LD_ADDR_VAR 0 11
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
4375: GO 4407
// if Kovalyuk in player_units then
4377: LD_EXP 9
4381: PUSH
4382: LD_EXP 41
4386: IN
4387: IFFALSE 4399
// kovalyuk_side := 1 else
4389: LD_ADDR_VAR 0 11
4393: PUSH
4394: LD_INT 1
4396: ST_TO_ADDR
4397: GO 4407
// kovalyuk_side := 0 ;
4399: LD_ADDR_VAR 0 11
4403: PUSH
4404: LD_INT 0
4406: ST_TO_ADDR
// if Scholtze in scientists then
4407: LD_EXP 10
4411: PUSH
4412: LD_EXP 40
4416: IN
4417: IFFALSE 4429
// scholtze_side := 2 else
4419: LD_ADDR_VAR 0 12
4423: PUSH
4424: LD_INT 2
4426: ST_TO_ADDR
4427: GO 4459
// if Scholtze in player_units then
4429: LD_EXP 10
4433: PUSH
4434: LD_EXP 41
4438: IN
4439: IFFALSE 4451
// scholtze_side := 1 else
4441: LD_ADDR_VAR 0 12
4445: PUSH
4446: LD_INT 1
4448: ST_TO_ADDR
4449: GO 4459
// scholtze_side := 0 ;
4451: LD_ADDR_VAR 0 12
4455: PUSH
4456: LD_INT 0
4458: ST_TO_ADDR
// if Kuzmov in scientists then
4459: LD_EXP 11
4463: PUSH
4464: LD_EXP 40
4468: IN
4469: IFFALSE 4481
// kuzmov_side := 2 else
4471: LD_ADDR_VAR 0 13
4475: PUSH
4476: LD_INT 2
4478: ST_TO_ADDR
4479: GO 4511
// if Kuzmov in player_units then
4481: LD_EXP 11
4485: PUSH
4486: LD_EXP 41
4490: IN
4491: IFFALSE 4503
// kuzmov_side := 1 else
4493: LD_ADDR_VAR 0 13
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
4501: GO 4511
// kuzmov_side := 0 ;
4503: LD_ADDR_VAR 0 13
4507: PUSH
4508: LD_INT 0
4510: ST_TO_ADDR
// if Karamazov in scientists then
4511: LD_EXP 12
4515: PUSH
4516: LD_EXP 40
4520: IN
4521: IFFALSE 4533
// karam_side := 2 else
4523: LD_ADDR_VAR 0 14
4527: PUSH
4528: LD_INT 2
4530: ST_TO_ADDR
4531: GO 4563
// if Karamazov in player_units then
4533: LD_EXP 12
4537: PUSH
4538: LD_EXP 41
4542: IN
4543: IFFALSE 4555
// karam_side := 1 else
4545: LD_ADDR_VAR 0 14
4549: PUSH
4550: LD_INT 1
4552: ST_TO_ADDR
4553: GO 4563
// karam_side := 0 ;
4555: LD_ADDR_VAR 0 14
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// if Petrovova in scientists then
4563: LD_EXP 13
4567: PUSH
4568: LD_EXP 40
4572: IN
4573: IFFALSE 4585
// petrov_side := 2 else
4575: LD_ADDR_VAR 0 17
4579: PUSH
4580: LD_INT 2
4582: ST_TO_ADDR
4583: GO 4615
// if Petrovova in player_units then
4585: LD_EXP 13
4589: PUSH
4590: LD_EXP 41
4594: IN
4595: IFFALSE 4607
// petrov_side := 1 else
4597: LD_ADDR_VAR 0 17
4601: PUSH
4602: LD_INT 1
4604: ST_TO_ADDR
4605: GO 4615
// petrov_side := 0 ;
4607: LD_ADDR_VAR 0 17
4611: PUSH
4612: LD_INT 0
4614: ST_TO_ADDR
// if Lipshchin in scientists then
4615: LD_EXP 14
4619: PUSH
4620: LD_EXP 40
4624: IN
4625: IFFALSE 4637
// lipshchin_side := 2 else
4627: LD_ADDR_VAR 0 18
4631: PUSH
4632: LD_INT 2
4634: ST_TO_ADDR
4635: GO 4667
// if Lipshchin in player_units then
4637: LD_EXP 14
4641: PUSH
4642: LD_EXP 41
4646: IN
4647: IFFALSE 4659
// lipshchin_side := 1 else
4649: LD_ADDR_VAR 0 18
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
4657: GO 4667
// lipshchin_side := 0 ;
4659: LD_ADDR_VAR 0 18
4663: PUSH
4664: LD_INT 0
4666: ST_TO_ADDR
// if Dolgov in scientists then
4667: LD_EXP 15
4671: PUSH
4672: LD_EXP 40
4676: IN
4677: IFFALSE 4689
// dolgov_side := 2 else
4679: LD_ADDR_VAR 0 20
4683: PUSH
4684: LD_INT 2
4686: ST_TO_ADDR
4687: GO 4719
// if Dolgov in player_units then
4689: LD_EXP 15
4693: PUSH
4694: LD_EXP 41
4698: IN
4699: IFFALSE 4711
// dolgov_side := 1 else
4701: LD_ADDR_VAR 0 20
4705: PUSH
4706: LD_INT 1
4708: ST_TO_ADDR
4709: GO 4719
// dolgov_side := 0 ;
4711: LD_ADDR_VAR 0 20
4715: PUSH
4716: LD_INT 0
4718: ST_TO_ADDR
// if Xavier in scientists then
4719: LD_EXP 16
4723: PUSH
4724: LD_EXP 40
4728: IN
4729: IFFALSE 4741
// xavier_side := 2 else
4731: LD_ADDR_VAR 0 21
4735: PUSH
4736: LD_INT 2
4738: ST_TO_ADDR
4739: GO 4771
// if Xavier in player_units then
4741: LD_EXP 16
4745: PUSH
4746: LD_EXP 41
4750: IN
4751: IFFALSE 4763
// xavier_side := 1 else
4753: LD_ADDR_VAR 0 21
4757: PUSH
4758: LD_INT 1
4760: ST_TO_ADDR
4761: GO 4771
// xavier_side := 0 ;
4763: LD_ADDR_VAR 0 21
4767: PUSH
4768: LD_INT 0
4770: ST_TO_ADDR
// if Oblukov in scientists then
4771: LD_EXP 17
4775: PUSH
4776: LD_EXP 40
4780: IN
4781: IFFALSE 4793
// oblukov_side := 2 else
4783: LD_ADDR_VAR 0 22
4787: PUSH
4788: LD_INT 2
4790: ST_TO_ADDR
4791: GO 4823
// if Oblukov in player_units then
4793: LD_EXP 17
4797: PUSH
4798: LD_EXP 41
4802: IN
4803: IFFALSE 4815
// oblukov_side := 1 else
4805: LD_ADDR_VAR 0 22
4809: PUSH
4810: LD_INT 1
4812: ST_TO_ADDR
4813: GO 4823
// oblukov_side := 0 ;
4815: LD_ADDR_VAR 0 22
4819: PUSH
4820: LD_INT 0
4822: ST_TO_ADDR
// if Kozlov in scientists then
4823: LD_EXP 18
4827: PUSH
4828: LD_EXP 40
4832: IN
4833: IFFALSE 4845
// kozlov_side := 2 else
4835: LD_ADDR_VAR 0 23
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
4843: GO 4875
// if Kozlov in player_units then
4845: LD_EXP 18
4849: PUSH
4850: LD_EXP 41
4854: IN
4855: IFFALSE 4867
// kozlov_side := 1 else
4857: LD_ADDR_VAR 0 23
4861: PUSH
4862: LD_INT 1
4864: ST_TO_ADDR
4865: GO 4875
// kozlov_side := 0 ;
4867: LD_ADDR_VAR 0 23
4871: PUSH
4872: LD_INT 0
4874: ST_TO_ADDR
// if Kapitsova in scientists then
4875: LD_EXP 19
4879: PUSH
4880: LD_EXP 40
4884: IN
4885: IFFALSE 4897
// kapitsova_side := 2 else
4887: LD_ADDR_VAR 0 24
4891: PUSH
4892: LD_INT 2
4894: ST_TO_ADDR
4895: GO 4927
// if Kapitsova in player_units then
4897: LD_EXP 19
4901: PUSH
4902: LD_EXP 41
4906: IN
4907: IFFALSE 4919
// kapitsova_side := 1 else
4909: LD_ADDR_VAR 0 24
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
4917: GO 4927
// kapitsova_side := 0 ;
4919: LD_ADDR_VAR 0 24
4923: PUSH
4924: LD_INT 0
4926: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4927: LD_VAR 0 8
4931: PPUSH
4932: LD_STRING belkov_side
4934: PPUSH
4935: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4939: LD_VAR 0 9
4943: PPUSH
4944: LD_STRING gnyevko_side
4946: PPUSH
4947: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4951: LD_VAR 0 10
4955: PPUSH
4956: LD_STRING kiril_side
4958: PPUSH
4959: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4963: LD_VAR 0 16
4967: PPUSH
4968: LD_STRING gleb_side
4970: PPUSH
4971: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
4975: LD_VAR 0 15
4979: PPUSH
4980: LD_STRING petros_side
4982: PPUSH
4983: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
4987: LD_VAR 0 19
4991: PPUSH
4992: LD_STRING titov_side
4994: PPUSH
4995: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
4999: LD_VAR 0 11
5003: PPUSH
5004: LD_STRING kovalyuk_side
5006: PPUSH
5007: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5011: LD_VAR 0 12
5015: PPUSH
5016: LD_STRING scholtze_side
5018: PPUSH
5019: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5023: LD_VAR 0 13
5027: PPUSH
5028: LD_STRING kuzmov_side
5030: PPUSH
5031: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5035: LD_VAR 0 14
5039: PPUSH
5040: LD_STRING karam_side
5042: PPUSH
5043: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5047: LD_VAR 0 17
5051: PPUSH
5052: LD_STRING petrov_side
5054: PPUSH
5055: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5059: LD_VAR 0 18
5063: PPUSH
5064: LD_STRING lipshchin_side
5066: PPUSH
5067: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5071: LD_VAR 0 20
5075: PPUSH
5076: LD_STRING dolgov_side
5078: PPUSH
5079: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5083: LD_VAR 0 21
5087: PPUSH
5088: LD_STRING xavier_side
5090: PPUSH
5091: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5095: LD_VAR 0 22
5099: PPUSH
5100: LD_STRING oblukov_side
5102: PPUSH
5103: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5107: LD_VAR 0 23
5111: PPUSH
5112: LD_STRING kozlov_side
5114: PPUSH
5115: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5119: LD_VAR 0 24
5123: PPUSH
5124: LD_STRING kapitsova_side
5126: PPUSH
5127: CALL_OW 39
// YouWin ;
5131: CALL_OW 103
// exit ;
5135: GO 5137
// end ; end_of_file
5137: LD_VAR 0 1
5141: RET
// export function D_Start ; begin
5142: LD_INT 0
5144: PPUSH
// DisableExclamations ;
5145: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5149: LD_EXP 8
5153: PPUSH
5154: LD_STRING DStart-Gos-1
5156: PPUSH
5157: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5161: LD_EXP 1
5165: PPUSH
5166: LD_STRING DStart-Bur-1
5168: PPUSH
5169: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5173: LD_EXP 8
5177: PPUSH
5178: LD_STRING DStart-Gos-2
5180: PPUSH
5181: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5185: LD_EXP 1
5189: PPUSH
5190: LD_STRING DStart-Bur-2
5192: PPUSH
5193: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5197: LD_EXP 8
5201: PPUSH
5202: LD_STRING DStart-Gos-3
5204: PPUSH
5205: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5209: LD_EXP 1
5213: PPUSH
5214: LD_STRING DStart-Bur-3
5216: PPUSH
5217: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5221: LD_EXP 8
5225: PPUSH
5226: LD_STRING DStart-Gos-4
5228: PPUSH
5229: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5233: LD_EXP 1
5237: PPUSH
5238: LD_STRING DStart-Bur-4
5240: PPUSH
5241: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5245: LD_EXP 8
5249: PPUSH
5250: LD_STRING DStart-Gos-5
5252: PPUSH
5253: CALL_OW 88
// EnableExclamations ;
5257: CALL_OW 473
// end ;
5261: LD_VAR 0 1
5265: RET
// export function D_Platonov ; begin
5266: LD_INT 0
5268: PPUSH
// DisableExclamations ;
5269: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5273: LD_EXP 21
5277: PPUSH
5278: LD_STRING DPlatonov-Rsol1-1
5280: PPUSH
5281: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5285: LD_EXP 1
5289: PPUSH
5290: LD_STRING DPlatonov-Bur-1
5292: PPUSH
5293: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5297: LD_EXP 21
5301: PPUSH
5302: LD_STRING DPlatonov-Rsol1-2
5304: PPUSH
5305: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5309: LD_EXP 1
5313: PPUSH
5314: LD_STRING DPlatonov-Bur-2
5316: PPUSH
5317: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5321: LD_EXP 1
5325: PPUSH
5326: LD_EXP 43
5330: PPUSH
5331: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5335: LD_EXP 21
5339: PPUSH
5340: LD_STRING DPlatonov-Rsol1-3
5342: PPUSH
5343: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5347: LD_INT 7
5349: PPUSH
5350: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5354: LD_EXP 43
5358: PPUSH
5359: CALL_OW 311
5363: PUSH
5364: LD_EXP 1
5368: EQUAL
5369: IFFALSE 5347
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5371: LD_EXP 1
5375: PPUSH
5376: LD_STRING DPlatonov-Bur-3
5378: PPUSH
5379: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5383: LD_EXP 1
5387: PPUSH
5388: LD_EXP 21
5392: PPUSH
5393: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5397: LD_INT 7
5399: PPUSH
5400: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5404: LD_EXP 43
5408: PPUSH
5409: CALL_OW 320
5413: PUSH
5414: LD_EXP 21
5418: EQUAL
5419: IFFALSE 5397
// Wait ( 0 0$0.5 ) ;
5421: LD_INT 18
5423: PPUSH
5424: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5428: LD_EXP 21
5432: PPUSH
5433: LD_STRING DPlatonov-Rsol1-4
5435: PPUSH
5436: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5440: LD_EXP 21
5444: PPUSH
5445: LD_EXP 43
5449: PPUSH
5450: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5454: LD_EXP 1
5458: PPUSH
5459: LD_EXP 21
5463: PPUSH
5464: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5468: LD_EXP 20
5472: PPUSH
5473: LD_STRING DPlatonov-Pla-4
5475: PPUSH
5476: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5480: LD_EXP 20
5484: PPUSH
5485: LD_STRING DPlatonov-Pla-4a
5487: PPUSH
5488: CALL_OW 88
// EnableExclamations ;
5492: CALL_OW 473
// end ;
5496: LD_VAR 0 1
5500: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5501: LD_INT 0
5503: PPUSH
5504: PPUSH
5505: PPUSH
5506: PPUSH
// DisableExclamations ;
5507: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5511: LD_EXP 2
5515: PPUSH
5516: CALL_OW 302
5520: PUSH
5521: LD_EXP 2
5525: PPUSH
5526: CALL_OW 255
5530: PUSH
5531: LD_EXP 23
5535: EQUAL
5536: AND
5537: IFFALSE 5551
// Say ( Belkov , DGosStart-Bel-1 ) ;
5539: LD_EXP 2
5543: PPUSH
5544: LD_STRING DGosStart-Bel-1
5546: PPUSH
5547: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5551: LD_EXP 3
5555: PPUSH
5556: CALL_OW 302
5560: PUSH
5561: LD_EXP 3
5565: PPUSH
5566: CALL_OW 255
5570: PUSH
5571: LD_EXP 23
5575: EQUAL
5576: AND
5577: IFFALSE 5591
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5579: LD_EXP 3
5583: PPUSH
5584: LD_STRING DGosStart-Gny-1
5586: PPUSH
5587: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5591: LD_EXP 5
5595: PPUSH
5596: CALL_OW 302
5600: PUSH
5601: LD_EXP 5
5605: PPUSH
5606: CALL_OW 255
5610: PUSH
5611: LD_EXP 23
5615: EQUAL
5616: AND
5617: IFFALSE 5631
// Say ( Gleb , DGosStart-Glb-1 ) ;
5619: LD_EXP 5
5623: PPUSH
5624: LD_STRING DGosStart-Glb-1
5626: PPUSH
5627: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5631: LD_EXP 6
5635: PPUSH
5636: CALL_OW 302
5640: PUSH
5641: LD_EXP 6
5645: PPUSH
5646: CALL_OW 255
5650: PUSH
5651: LD_EXP 23
5655: EQUAL
5656: AND
5657: IFFALSE 5671
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5659: LD_EXP 6
5663: PPUSH
5664: LD_STRING DGosStart-Pty-1
5666: PPUSH
5667: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5671: LD_EXP 7
5675: PPUSH
5676: CALL_OW 302
5680: PUSH
5681: LD_EXP 7
5685: PPUSH
5686: CALL_OW 255
5690: PUSH
5691: LD_EXP 23
5695: EQUAL
5696: AND
5697: IFFALSE 5711
// Say ( Titov , DGosStart-Tit-1 ) ;
5699: LD_EXP 7
5703: PPUSH
5704: LD_STRING DGosStart-Tit-1
5706: PPUSH
5707: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5711: LD_EXP 4
5715: PPUSH
5716: CALL_OW 302
5720: PUSH
5721: LD_EXP 4
5725: PPUSH
5726: CALL_OW 255
5730: PUSH
5731: LD_EXP 23
5735: EQUAL
5736: AND
5737: IFFALSE 5751
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5739: LD_EXP 4
5743: PPUSH
5744: LD_STRING DGosStart-Kir-1
5746: PPUSH
5747: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5751: LD_EXP 2
5755: PPUSH
5756: CALL_OW 302
5760: PUSH
5761: LD_EXP 2
5765: PPUSH
5766: CALL_OW 255
5770: PUSH
5771: LD_EXP 23
5775: EQUAL
5776: AND
5777: PUSH
5778: LD_EXP 3
5782: PPUSH
5783: CALL_OW 302
5787: PUSH
5788: LD_EXP 3
5792: PPUSH
5793: CALL_OW 255
5797: PUSH
5798: LD_EXP 23
5802: EQUAL
5803: AND
5804: OR
5805: PUSH
5806: LD_EXP 5
5810: PPUSH
5811: CALL_OW 302
5815: PUSH
5816: LD_EXP 5
5820: PPUSH
5821: CALL_OW 255
5825: PUSH
5826: LD_EXP 23
5830: EQUAL
5831: AND
5832: OR
5833: PUSH
5834: LD_EXP 6
5838: PPUSH
5839: CALL_OW 302
5843: PUSH
5844: LD_EXP 6
5848: PPUSH
5849: CALL_OW 255
5853: PUSH
5854: LD_EXP 23
5858: EQUAL
5859: AND
5860: OR
5861: PUSH
5862: LD_EXP 7
5866: PPUSH
5867: CALL_OW 302
5871: PUSH
5872: LD_EXP 7
5876: PPUSH
5877: CALL_OW 255
5881: PUSH
5882: LD_EXP 23
5886: EQUAL
5887: AND
5888: OR
5889: PUSH
5890: LD_EXP 4
5894: PPUSH
5895: CALL_OW 302
5899: PUSH
5900: LD_EXP 4
5904: PPUSH
5905: CALL_OW 255
5909: PUSH
5910: LD_EXP 23
5914: EQUAL
5915: AND
5916: OR
5917: NOT
5918: IFFALSE 6282
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5920: LD_ADDR_VAR 0 4
5924: PUSH
5925: LD_INT 22
5927: PUSH
5928: LD_EXP 23
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 26
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 50
5949: PUSH
5950: EMPTY
5951: LIST
5952: PUSH
5953: LD_INT 3
5955: PUSH
5956: LD_INT 23
5958: PUSH
5959: LD_INT 0
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: PPUSH
5976: CALL_OW 69
5980: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
5981: LD_ADDR_VAR 0 4
5985: PUSH
5986: LD_VAR 0 4
5990: PUSH
5991: LD_EXP 1
5995: DIFF
5996: ST_TO_ADDR
// if 0 + filter_all > 0 then
5997: LD_INT 0
5999: PUSH
6000: LD_VAR 0 4
6004: PLUS
6005: PUSH
6006: LD_INT 0
6008: GREATER
6009: IFFALSE 6110
// begin filter := [ ] ;
6011: LD_ADDR_VAR 0 3
6015: PUSH
6016: EMPTY
6017: ST_TO_ADDR
// for un in filter_all do
6018: LD_ADDR_VAR 0 2
6022: PUSH
6023: LD_VAR 0 4
6027: PUSH
6028: FOR_IN
6029: IFFALSE 6062
// if not ( un in all_possible ) then
6031: LD_VAR 0 2
6035: PUSH
6036: LD_EXP 39
6040: IN
6041: NOT
6042: IFFALSE 6060
// filter := filter union un ;
6044: LD_ADDR_VAR 0 3
6048: PUSH
6049: LD_VAR 0 3
6053: PUSH
6054: LD_VAR 0 2
6058: UNION
6059: ST_TO_ADDR
6060: GO 6028
6062: POP
6063: POP
// if filter > 0 then
6064: LD_VAR 0 3
6068: PUSH
6069: LD_INT 0
6071: GREATER
6072: IFFALSE 6092
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6074: LD_VAR 0 3
6078: PUSH
6079: LD_INT 1
6081: ARRAY
6082: PPUSH
6083: LD_STRING DGosStart-Sol1-1
6085: PPUSH
6086: CALL_OW 88
6090: GO 6108
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6092: LD_VAR 0 4
6096: PUSH
6097: LD_INT 1
6099: ARRAY
6100: PPUSH
6101: LD_STRING DGosStart-Sol1-1
6103: PPUSH
6104: CALL_OW 88
// end else
6108: GO 6282
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6110: LD_ADDR_VAR 0 4
6114: PUSH
6115: LD_INT 22
6117: PUSH
6118: LD_EXP 23
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 26
6129: PUSH
6130: LD_INT 2
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 50
6139: PUSH
6140: EMPTY
6141: LIST
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: LD_INT 23
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PPUSH
6166: CALL_OW 69
6170: ST_TO_ADDR
// if 0 + filter_all > 0 then
6171: LD_INT 0
6173: PUSH
6174: LD_VAR 0 4
6178: PLUS
6179: PUSH
6180: LD_INT 0
6182: GREATER
6183: IFFALSE 6282
// begin filter := [ ] ;
6185: LD_ADDR_VAR 0 3
6189: PUSH
6190: EMPTY
6191: ST_TO_ADDR
// for un in filter_all do
6192: LD_ADDR_VAR 0 2
6196: PUSH
6197: LD_VAR 0 4
6201: PUSH
6202: FOR_IN
6203: IFFALSE 6236
// if not ( un in all_possible ) then
6205: LD_VAR 0 2
6209: PUSH
6210: LD_EXP 39
6214: IN
6215: NOT
6216: IFFALSE 6234
// filter := filter union un ;
6218: LD_ADDR_VAR 0 3
6222: PUSH
6223: LD_VAR 0 3
6227: PUSH
6228: LD_VAR 0 2
6232: UNION
6233: ST_TO_ADDR
6234: GO 6202
6236: POP
6237: POP
// if filter > 0 then
6238: LD_VAR 0 3
6242: PUSH
6243: LD_INT 0
6245: GREATER
6246: IFFALSE 6266
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6248: LD_VAR 0 3
6252: PUSH
6253: LD_INT 1
6255: ARRAY
6256: PPUSH
6257: LD_STRING DGosStart-FSol1-1
6259: PPUSH
6260: CALL_OW 88
6264: GO 6282
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6266: LD_VAR 0 4
6270: PUSH
6271: LD_INT 1
6273: ARRAY
6274: PPUSH
6275: LD_STRING DGosStart-FSol1-1
6277: PPUSH
6278: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6282: LD_EXP 1
6286: PPUSH
6287: LD_STRING DGosStart-Bur-1
6289: PPUSH
6290: CALL_OW 88
// Wait ( 0 0$20 ) ;
6294: LD_INT 700
6296: PPUSH
6297: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6301: LD_EXP 1
6305: PPUSH
6306: LD_STRING DGosStart-Bur-1a
6308: PPUSH
6309: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6313: LD_EXP 8
6317: PPUSH
6318: LD_STRING DGosStart-Gos-1
6320: PPUSH
6321: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6325: LD_EXP 1
6329: PPUSH
6330: LD_STRING DGosStart-Bur-2
6332: PPUSH
6333: CALL_OW 88
// Hint ( Signal ) ;
6337: LD_STRING Signal
6339: PPUSH
6340: CALL_OW 339
// attackAvalaible = 1 ;
6344: LD_ADDR_EXP 61
6348: PUSH
6349: LD_INT 1
6351: ST_TO_ADDR
// enable ( 6 ) ;
6352: LD_INT 6
6354: ENABLE_MARKED
// EnableExclamations ;
6355: CALL_OW 473
// end ;
6359: LD_VAR 0 1
6363: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6364: LD_INT 0
6366: PPUSH
6367: PPUSH
6368: PPUSH
6369: PPUSH
// DisableExclamations ;
6370: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6374: LD_EXP 1
6378: PPUSH
6379: LD_STRING DSituation-Bur-1
6381: PPUSH
6382: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6386: LD_ADDR_VAR 0 4
6390: PUSH
6391: LD_INT 22
6393: PUSH
6394: LD_EXP 23
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 26
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PUSH
6413: LD_INT 50
6415: PUSH
6416: EMPTY
6417: LIST
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: LD_INT 23
6424: PUSH
6425: LD_INT 0
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PPUSH
6442: CALL_OW 69
6446: ST_TO_ADDR
// if 0 + filter_all > 0 then
6447: LD_INT 0
6449: PUSH
6450: LD_VAR 0 4
6454: PLUS
6455: PUSH
6456: LD_INT 0
6458: GREATER
6459: IFFALSE 6560
// begin filter := [ ] ;
6461: LD_ADDR_VAR 0 3
6465: PUSH
6466: EMPTY
6467: ST_TO_ADDR
// for un in filter_all do
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: LD_VAR 0 4
6477: PUSH
6478: FOR_IN
6479: IFFALSE 6512
// if not ( un in all_possible ) then
6481: LD_VAR 0 2
6485: PUSH
6486: LD_EXP 39
6490: IN
6491: NOT
6492: IFFALSE 6510
// filter := filter union un ;
6494: LD_ADDR_VAR 0 3
6498: PUSH
6499: LD_VAR 0 3
6503: PUSH
6504: LD_VAR 0 2
6508: UNION
6509: ST_TO_ADDR
6510: GO 6478
6512: POP
6513: POP
// if filter > 0 then
6514: LD_VAR 0 3
6518: PUSH
6519: LD_INT 0
6521: GREATER
6522: IFFALSE 6542
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6524: LD_VAR 0 3
6528: PUSH
6529: LD_INT 1
6531: ARRAY
6532: PPUSH
6533: LD_STRING DSituation-RFSol1-1
6535: PPUSH
6536: CALL_OW 88
6540: GO 6558
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6542: LD_VAR 0 4
6546: PUSH
6547: LD_INT 1
6549: ARRAY
6550: PPUSH
6551: LD_STRING DSituation-RFSol1-1
6553: PPUSH
6554: CALL_OW 88
// end else
6558: GO 6748
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6560: LD_ADDR_VAR 0 4
6564: PUSH
6565: LD_INT 22
6567: PUSH
6568: LD_EXP 23
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: PUSH
6577: LD_INT 26
6579: PUSH
6580: LD_INT 1
6582: PUSH
6583: EMPTY
6584: LIST
6585: LIST
6586: PUSH
6587: LD_INT 50
6589: PUSH
6590: EMPTY
6591: LIST
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: LD_INT 23
6598: PUSH
6599: LD_INT 0
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: LIST
6614: LIST
6615: PPUSH
6616: CALL_OW 69
6620: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6621: LD_ADDR_VAR 0 4
6625: PUSH
6626: LD_VAR 0 4
6630: PUSH
6631: LD_EXP 1
6635: DIFF
6636: ST_TO_ADDR
// if 0 + filter_all > 0 then
6637: LD_INT 0
6639: PUSH
6640: LD_VAR 0 4
6644: PLUS
6645: PUSH
6646: LD_INT 0
6648: GREATER
6649: IFFALSE 6748
// begin filter := [ ] ;
6651: LD_ADDR_VAR 0 3
6655: PUSH
6656: EMPTY
6657: ST_TO_ADDR
// for un in filter_all do
6658: LD_ADDR_VAR 0 2
6662: PUSH
6663: LD_VAR 0 4
6667: PUSH
6668: FOR_IN
6669: IFFALSE 6702
// if not ( un in all_possible ) then
6671: LD_VAR 0 2
6675: PUSH
6676: LD_EXP 39
6680: IN
6681: NOT
6682: IFFALSE 6700
// filter := filter union un ;
6684: LD_ADDR_VAR 0 3
6688: PUSH
6689: LD_VAR 0 3
6693: PUSH
6694: LD_VAR 0 2
6698: UNION
6699: ST_TO_ADDR
6700: GO 6668
6702: POP
6703: POP
// if filter > 0 then
6704: LD_VAR 0 3
6708: PUSH
6709: LD_INT 0
6711: GREATER
6712: IFFALSE 6732
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6714: LD_VAR 0 3
6718: PUSH
6719: LD_INT 1
6721: ARRAY
6722: PPUSH
6723: LD_STRING DSituation-RSol1-1
6725: PPUSH
6726: CALL_OW 88
6730: GO 6748
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6732: LD_VAR 0 4
6736: PUSH
6737: LD_INT 1
6739: ARRAY
6740: PPUSH
6741: LD_STRING DSituation-RSol1-1
6743: PPUSH
6744: CALL_OW 88
// end ; end ; EnableExclamations ;
6748: CALL_OW 473
// end ;
6752: LD_VAR 0 1
6756: RET
// export function D_GO1 ; begin
6757: LD_INT 0
6759: PPUSH
// DisableExclamations ;
6760: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6764: LD_EXP 1
6768: PPUSH
6769: LD_STRING DGO#1-Bur-1
6771: PPUSH
6772: CALL_OW 88
// EnableExclamations ;
6776: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6780: LD_INT 11
6782: PPUSH
6783: LD_INT 1
6785: PPUSH
6786: CALL_OW 424
// end ;
6790: LD_VAR 0 1
6794: RET
// export function D_SeeYou ; begin
6795: LD_INT 0
6797: PPUSH
// DisableExclamations ;
6798: CALL_OW 474
// DialogueOn ;
6802: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6806: LD_EXP 8
6810: PPUSH
6811: LD_STRING DSeeYou-Gos-1
6813: PPUSH
6814: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6818: LD_EXP 1
6822: PPUSH
6823: LD_STRING DSeeYou-Bur-1
6825: PPUSH
6826: CALL_OW 88
// DialogueOff ;
6830: CALL_OW 7
// EnableExclamations ;
6834: CALL_OW 473
// end ; end_of_file
6838: LD_VAR 0 1
6842: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6843: GO 6845
6845: DISABLE
6846: LD_INT 0
6848: PPUSH
6849: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6850: LD_EXP 1
6854: PPUSH
6855: LD_INT 1
6857: PPUSH
6858: CALL_OW 308
6862: IFFALSE 6928
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6864: LD_ADDR_VAR 0 1
6868: PUSH
6869: LD_INT 22
6871: PUSH
6872: LD_EXP 27
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PPUSH
6881: CALL_OW 69
6885: ST_TO_ADDR
// for un in filter do
6886: LD_ADDR_VAR 0 2
6890: PUSH
6891: LD_VAR 0 1
6895: PUSH
6896: FOR_IN
6897: IFFALSE 6915
// setside ( un , you ) ;
6899: LD_VAR 0 2
6903: PPUSH
6904: LD_EXP 23
6908: PPUSH
6909: CALL_OW 235
6913: GO 6896
6915: POP
6916: POP
// BurlakReachedBase := true ;
6917: LD_ADDR_EXP 28
6921: PUSH
6922: LD_INT 1
6924: ST_TO_ADDR
// disable ;
6925: DISABLE
// end else
6926: GO 6929
// enable ;
6928: ENABLE
// end ;
6929: PPOPN 2
6931: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6932: GO 6934
6934: DISABLE
6935: LD_INT 0
6937: PPUSH
6938: PPUSH
6939: PPUSH
6940: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6941: LD_EXP 1
6945: PPUSH
6946: LD_INT 10
6948: PPUSH
6949: CALL_OW 308
6953: IFFALSE 7184
// begin DisableExclamations ;
6955: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6959: LD_ADDR_VAR 0 1
6963: PUSH
6964: LD_INT 22
6966: PUSH
6967: LD_EXP 27
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: ST_TO_ADDR
// skill := 0 ;
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_INT 0
6988: ST_TO_ADDR
// for un in filter do
6989: LD_ADDR_VAR 0 2
6993: PUSH
6994: LD_VAR 0 1
6998: PUSH
6999: FOR_IN
7000: IFFALSE 7034
// if GetSkill ( un , skill_engineering ) >= skill then
7002: LD_VAR 0 2
7006: PPUSH
7007: LD_INT 2
7009: PPUSH
7010: CALL_OW 259
7014: PUSH
7015: LD_VAR 0 3
7019: GREATEREQUAL
7020: IFFALSE 7032
// inzenyr := un ;
7022: LD_ADDR_VAR 0 4
7026: PUSH
7027: LD_VAR 0 2
7031: ST_TO_ADDR
7032: GO 6999
7034: POP
7035: POP
// ComStop ( inzenyr ) ;
7036: LD_VAR 0 4
7040: PPUSH
7041: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7045: LD_VAR 0 4
7049: PPUSH
7050: CALL_OW 257
7054: PUSH
7055: LD_INT 2
7057: NONEQUAL
7058: IFFALSE 7149
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7060: LD_ADDR_VAR 0 1
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 1
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: LD_INT 22
7077: PUSH
7078: LD_EXP 27
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PPUSH
7091: CALL_OW 69
7095: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7096: LD_VAR 0 4
7100: PPUSH
7101: LD_VAR 0 1
7105: PUSH
7106: LD_INT 1
7108: ARRAY
7109: PPUSH
7110: CALL_OW 120
// Wait ( 10 ) ;
7114: LD_INT 10
7116: PPUSH
7117: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7121: LD_VAR 0 4
7125: PPUSH
7126: LD_INT 2
7128: PPUSH
7129: CALL_OW 183
// Wait ( 10 ) ;
7133: LD_INT 10
7135: PPUSH
7136: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7140: LD_VAR 0 4
7144: PPUSH
7145: CALL_OW 182
// end ; Wait ( 10 ) ;
7149: LD_INT 10
7151: PPUSH
7152: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 26
7163: PPUSH
7164: LD_INT 126
7166: PPUSH
7167: LD_INT 17
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: CALL_OW 205
// EnableExclamations ;
7177: CALL_OW 473
// disable ;
7181: DISABLE
// end else
7182: GO 7185
// enable ;
7184: ENABLE
// end ;
7185: PPOPN 4
7187: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7188: GO 7190
7190: DISABLE
7191: LD_INT 0
7193: PPUSH
7194: PPUSH
// begin if straz < bazooker then
7195: LD_EXP 45
7199: PUSH
7200: LD_EXP 51
7204: LESS
7205: IFFALSE 7353
// begin bazooker := bazooker + 1 ;
7207: LD_ADDR_EXP 51
7211: PUSH
7212: LD_EXP 51
7216: PUSH
7217: LD_INT 1
7219: PLUS
7220: ST_TO_ADDR
// while straz < bazooker do
7221: LD_EXP 45
7225: PUSH
7226: LD_EXP 51
7230: LESS
7231: IFFALSE 7353
// begin uc_side := rus ;
7233: LD_ADDR_OWVAR 20
7237: PUSH
7238: LD_EXP 24
7242: ST_TO_ADDR
// uc_nation := nation_russian ;
7243: LD_ADDR_OWVAR 21
7247: PUSH
7248: LD_INT 3
7250: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 7 + difficulty ) ;
7251: LD_INT 1
7253: PPUSH
7254: LD_INT 9
7256: PPUSH
7257: LD_INT 7
7259: PUSH
7260: LD_OWVAR 67
7264: PLUS
7265: PPUSH
7266: CALL_OW 380
// hc_name :=  ;
7270: LD_ADDR_OWVAR 26
7274: PUSH
7275: LD_STRING 
7277: ST_TO_ADDR
// bazukr := CreateHuman ;
7278: LD_ADDR_VAR 0 2
7282: PUSH
7283: CALL_OW 44
7287: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7288: LD_EXP 62
7292: PPUSH
7293: LD_VAR 0 2
7297: PPUSH
7298: LD_INT 1
7300: PPUSH
7301: CALL_OW 394
// straz := straz ^ bazukr ;
7305: LD_ADDR_EXP 45
7309: PUSH
7310: LD_EXP 45
7314: PUSH
7315: LD_VAR 0 2
7319: ADD
7320: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7321: LD_VAR 0 2
7325: PPUSH
7326: LD_INT 9
7328: PPUSH
7329: LD_INT 0
7331: PPUSH
7332: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7336: LD_VAR 0 2
7340: PPUSH
7341: LD_INT 66
7343: PPUSH
7344: LD_INT 48
7346: PPUSH
7347: CALL_OW 114
// end ;
7351: GO 7221
// end ; end ;
7353: PPOPN 2
7355: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7356: GO 7358
7358: DISABLE
7359: LD_INT 0
7361: PPUSH
// begin if ( 0 + straz ) <> 0 then
7362: LD_INT 0
7364: PUSH
7365: LD_EXP 45
7369: PLUS
7370: PUSH
7371: LD_INT 0
7373: NONEQUAL
7374: IFFALSE 7617
// begin for un in straz do
7376: LD_ADDR_VAR 0 1
7380: PUSH
7381: LD_EXP 45
7385: PUSH
7386: FOR_IN
7387: IFFALSE 7615
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7389: LD_VAR 0 1
7393: PPUSH
7394: CALL_OW 314
7398: NOT
7399: PUSH
7400: LD_VAR 0 1
7404: PPUSH
7405: CALL_OW 256
7409: PUSH
7410: LD_INT 601
7412: GREATER
7413: AND
7414: IFFALSE 7613
// begin if GetY ( un ) > 60 then
7416: LD_VAR 0 1
7420: PPUSH
7421: CALL_OW 251
7425: PUSH
7426: LD_INT 60
7428: GREATER
7429: IFFALSE 7523
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7431: LD_VAR 0 1
7435: PPUSH
7436: LD_INT 66
7438: PPUSH
7439: LD_INT 48
7441: PPUSH
7442: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7446: LD_VAR 0 1
7450: PPUSH
7451: LD_INT 63
7453: PPUSH
7454: LD_INT 74
7456: PPUSH
7457: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7461: LD_VAR 0 1
7465: PPUSH
7466: LD_INT 73
7468: PPUSH
7469: LD_INT 90
7471: PPUSH
7472: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7476: LD_VAR 0 1
7480: PPUSH
7481: LD_INT 76
7483: PPUSH
7484: LD_INT 95
7486: PPUSH
7487: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 72
7498: PPUSH
7499: LD_INT 95
7501: PPUSH
7502: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7506: LD_VAR 0 1
7510: PPUSH
7511: LD_INT 50
7513: PPUSH
7514: LD_INT 73
7516: PPUSH
7517: CALL_OW 174
// end else
7521: GO 7613
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7523: LD_VAR 0 1
7527: PPUSH
7528: LD_INT 73
7530: PPUSH
7531: LD_INT 90
7533: PPUSH
7534: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7538: LD_VAR 0 1
7542: PPUSH
7543: LD_INT 76
7545: PPUSH
7546: LD_INT 95
7548: PPUSH
7549: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7553: LD_VAR 0 1
7557: PPUSH
7558: LD_INT 72
7560: PPUSH
7561: LD_INT 95
7563: PPUSH
7564: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7568: LD_VAR 0 1
7572: PPUSH
7573: LD_INT 50
7575: PPUSH
7576: LD_INT 73
7578: PPUSH
7579: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7583: LD_VAR 0 1
7587: PPUSH
7588: LD_INT 63
7590: PPUSH
7591: LD_INT 74
7593: PPUSH
7594: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7598: LD_VAR 0 1
7602: PPUSH
7603: LD_INT 66
7605: PPUSH
7606: LD_INT 48
7608: PPUSH
7609: CALL_OW 174
// end ; end ; end ;
7613: GO 7386
7615: POP
7616: POP
// end ; enable ;
7617: ENABLE
// end ;
7618: PPOPN 1
7620: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7621: GO 7623
7623: DISABLE
7624: LD_INT 0
7626: PPUSH
7627: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7628: LD_EXP 1
7632: PPUSH
7633: LD_INT 2
7635: PPUSH
7636: CALL_OW 308
7640: IFFALSE 7684
// begin disabled5 := true ;
7642: LD_ADDR_LOC 4
7646: PUSH
7647: LD_INT 1
7649: ST_TO_ADDR
// D_GosStart ;
7650: CALL 5501 0 0
// Wait ( 0 0$5 ) ;
7654: LD_INT 175
7656: PPUSH
7657: CALL_OW 67
// D_Situation ;
7661: CALL 6364 0 0
// ChangeMissionObjectives ( MHold ) ;
7665: LD_STRING MHold
7667: PPUSH
7668: CALL_OW 337
// disable ;
7672: DISABLE
// enable ( 333 ) ;
7673: LD_INT 333
7675: ENABLE_MARKED
// enable ( 334 ) ;
7676: LD_INT 334
7678: ENABLE_MARKED
// enable ( 337 ) ;
7679: LD_INT 337
7681: ENABLE_MARKED
// end else
7682: GO 7685
// enable ;
7684: ENABLE
// end ;
7685: PPOPN 2
7687: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7688: GO 7690
7690: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7691: LD_EXP 8
7695: PPUSH
7696: CALL_OW 306
7700: PUSH
7701: LD_INT 1
7703: EQUAL
7704: IFFALSE 7730
// begin if WasSelected = false then
7706: LD_EXP 46
7710: PUSH
7711: LD_INT 0
7713: EQUAL
7714: IFFALSE 7728
// begin QueryQGO ;
7716: CALL 7747 0 0
// WasSelected := true ;
7720: LD_ADDR_EXP 46
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// end ; end else
7728: GO 7738
// WasSelected := false ;
7730: LD_ADDR_EXP 46
7734: PUSH
7735: LD_INT 0
7737: ST_TO_ADDR
// if not disabled3 then
7738: LD_LOC 3
7742: NOT
7743: IFFALSE 7746
// enable ;
7745: ENABLE
// end ;
7746: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7747: LD_INT 0
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
7753: PPUSH
7754: PPUSH
// res := Query ( QGO ) ;
7755: LD_ADDR_VAR 0 2
7759: PUSH
7760: LD_STRING QGO
7762: PPUSH
7763: CALL_OW 97
7767: ST_TO_ADDR
// if res = 1 then
7768: LD_VAR 0 2
7772: PUSH
7773: LD_INT 1
7775: EQUAL
7776: IFFALSE 8152
// begin disabled3 := true ;
7778: LD_ADDR_LOC 3
7782: PUSH
7783: LD_INT 1
7785: ST_TO_ADDR
// D_GO1 ;
7786: CALL 6757 0 0
// ChangeMissionObjectives ( MGuide ) ;
7790: LD_STRING MGuide
7792: PPUSH
7793: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_INT 3
7804: PPUSH
7805: LD_INT 21
7807: PUSH
7808: LD_INT 2
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PUSH
7815: LD_INT 34
7817: PUSH
7818: LD_INT 51
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PPUSH
7829: CALL_OW 70
7833: ST_TO_ADDR
// if filter = 0 then
7834: LD_VAR 0 3
7838: PUSH
7839: LD_INT 0
7841: EQUAL
7842: IFFALSE 7993
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7844: LD_EXP 8
7848: PPUSH
7849: LD_INT 57
7851: PPUSH
7852: LD_INT 98
7854: PPUSH
7855: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7859: LD_INT 35
7861: PPUSH
7862: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7866: LD_EXP 8
7870: PPUSH
7871: CALL_OW 314
7875: NOT
7876: IFFALSE 7859
// RemoveUnit ( Gossudarov ) ;
7878: LD_EXP 8
7882: PPUSH
7883: CALL_OW 64
// uc_side := ally ;
7887: LD_ADDR_OWVAR 20
7891: PUSH
7892: LD_EXP 25
7896: ST_TO_ADDR
// uc_nation := nation_russian ;
7897: LD_ADDR_OWVAR 21
7901: PUSH
7902: LD_INT 3
7904: ST_TO_ADDR
// uc_direction := 5 ;
7905: LD_ADDR_OWVAR 24
7909: PUSH
7910: LD_INT 5
7912: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7913: LD_ADDR_OWVAR 37
7917: PUSH
7918: LD_INT 21
7920: ST_TO_ADDR
// vc_engine := engine_combustion ;
7921: LD_ADDR_OWVAR 39
7925: PUSH
7926: LD_INT 1
7928: ST_TO_ADDR
// vc_control := control_manual ;
7929: LD_ADDR_OWVAR 38
7933: PUSH
7934: LD_INT 1
7936: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7937: LD_ADDR_OWVAR 40
7941: PUSH
7942: LD_INT 51
7944: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7945: LD_ADDR_VAR 0 4
7949: PUSH
7950: CALL_OW 45
7954: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7955: LD_EXP 8
7959: PPUSH
7960: LD_VAR 0 4
7964: PPUSH
7965: CALL_OW 52
// Wait ( 0 0$5 ) ;
7969: LD_INT 175
7971: PPUSH
7972: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
7976: LD_VAR 0 4
7980: PPUSH
7981: LD_INT 9
7983: PPUSH
7984: LD_INT 0
7986: PPUSH
7987: CALL_OW 49
// end else
7991: GO 8011
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
7993: LD_EXP 8
7997: PPUSH
7998: LD_VAR 0 3
8002: PUSH
8003: LD_INT 1
8005: ARRAY
8006: PPUSH
8007: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8011: LD_EXP 8
8015: PPUSH
8016: LD_INT 4
8018: PPUSH
8019: CALL_OW 469
8023: PUSH
8024: LD_INT 1
8026: ARRAY
8027: PPUSH
8028: LD_INT 4
8030: PPUSH
8031: CALL_OW 469
8035: PUSH
8036: LD_INT 2
8038: ARRAY
8039: PPUSH
8040: CALL_OW 220
// Wait ( 0 0$5 ) ;
8044: LD_INT 175
8046: PPUSH
8047: CALL_OW 67
// ComExitBuilding ( scientists ) ;
8051: LD_EXP 40
8055: PPUSH
8056: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8060: LD_EXP 40
8064: PUSH
8065: LD_EXP 8
8069: ADD
8070: PPUSH
8071: LD_INT 50
8073: PPUSH
8074: LD_INT 58
8076: PPUSH
8077: CALL_OW 171
// for un in scientists ^ Gossudarov do
8081: LD_ADDR_VAR 0 6
8085: PUSH
8086: LD_EXP 40
8090: PUSH
8091: LD_EXP 8
8095: ADD
8096: PUSH
8097: FOR_IN
8098: IFFALSE 8116
// AddComSailEvent ( un , un ) ;
8100: LD_VAR 0 6
8104: PPUSH
8105: LD_VAR 0 6
8109: PPUSH
8110: CALL_OW 224
8114: GO 8097
8116: POP
8117: POP
// player_units := player_units union scientists union Gossudarov ;
8118: LD_ADDR_EXP 41
8122: PUSH
8123: LD_EXP 41
8127: PUSH
8128: LD_EXP 40
8132: UNION
8133: PUSH
8134: LD_EXP 8
8138: UNION
8139: ST_TO_ADDR
// enable ( 4 ) ;
8140: LD_INT 4
8142: ENABLE_MARKED
// enable ( 7 ) ;
8143: LD_INT 7
8145: ENABLE_MARKED
// enable ( 8 ) ;
8146: LD_INT 8
8148: ENABLE_MARKED
// enable ( 9 ) ;
8149: LD_INT 9
8151: ENABLE_MARKED
// end ; end ;
8152: LD_VAR 0 1
8156: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8157: GO 8159
8159: DISABLE
8160: LD_INT 0
8162: PPUSH
// begin for un in scientists do
8163: LD_ADDR_VAR 0 1
8167: PUSH
8168: LD_EXP 40
8172: PUSH
8173: FOR_IN
8174: IFFALSE 8244
// begin if IsInArea ( un , ExitArea ) then
8176: LD_VAR 0 1
8180: PPUSH
8181: LD_INT 11
8183: PPUSH
8184: CALL_OW 308
8188: IFFALSE 8215
// begin scientists_saved := scientists_saved union un ;
8190: LD_ADDR_EXP 48
8194: PUSH
8195: LD_EXP 48
8199: PUSH
8200: LD_VAR 0 1
8204: UNION
8205: ST_TO_ADDR
// RemoveUnit ( un ) ;
8206: LD_VAR 0 1
8210: PPUSH
8211: CALL_OW 64
// end ; if IsDead ( un ) then
8215: LD_VAR 0 1
8219: PPUSH
8220: CALL_OW 301
8224: IFFALSE 8242
// scientists_dead := scientists_dead union un ;
8226: LD_ADDR_EXP 49
8230: PUSH
8231: LD_EXP 49
8235: PUSH
8236: LD_VAR 0 1
8240: UNION
8241: ST_TO_ADDR
// end ;
8242: GO 8173
8244: POP
8245: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8246: LD_EXP 8
8250: PPUSH
8251: LD_INT 11
8253: PPUSH
8254: CALL_OW 308
8258: PUSH
8259: LD_EXP 8
8263: PPUSH
8264: CALL_OW 310
8268: PPUSH
8269: LD_INT 11
8271: PPUSH
8272: CALL_OW 308
8276: OR
8277: PUSH
8278: LD_EXP 48
8282: PUSH
8283: LD_EXP 49
8287: PLUS
8288: PUSH
8289: LD_EXP 40
8293: EQUAL
8294: AND
8295: PUSH
8296: LD_EXP 50
8300: PPUSH
8301: CALL_OW 255
8305: PUSH
8306: LD_EXP 23
8310: EQUAL
8311: AND
8312: PUSH
8313: LD_EXP 50
8317: PPUSH
8318: LD_INT 11
8320: PPUSH
8321: CALL_OW 308
8325: AND
8326: PUSH
8327: LD_EXP 50
8331: PPUSH
8332: LD_INT 4
8334: PPUSH
8335: CALL_OW 289
8339: PUSH
8340: LD_INT 40
8342: EQUAL
8343: AND
8344: IFFALSE 8356
// begin D_SeeYou ;
8346: CALL 6795 0 0
// TheEnd ;
8350: CALL 3282 0 0
// end else
8354: GO 8357
// enable ;
8356: ENABLE
// end ;
8357: PPOPN 1
8359: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8360: GO 8362
8362: DISABLE
8363: LD_INT 0
8365: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8366: LD_EXP 1
8370: PPUSH
8371: LD_INT 18
8373: PPUSH
8374: CALL_OW 308
8378: PUSH
8379: LD_EXP 43
8383: PPUSH
8384: LD_INT 18
8386: PPUSH
8387: CALL_OW 308
8391: OR
8392: IFFALSE 8409
// begin Wait ( 0 0$3 ) ;
8394: LD_INT 105
8396: PPUSH
8397: CALL_OW 67
// Attack1 := true ;
8401: LD_ADDR_LOC 5
8405: PUSH
8406: LD_INT 1
8408: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8409: LD_EXP 1
8413: PPUSH
8414: LD_INT 19
8416: PPUSH
8417: CALL_OW 308
8421: PUSH
8422: LD_EXP 43
8426: PPUSH
8427: LD_INT 19
8429: PPUSH
8430: CALL_OW 308
8434: OR
8435: IFFALSE 8452
// begin Wait ( 0 0$3 ) ;
8437: LD_INT 105
8439: PPUSH
8440: CALL_OW 67
// Attack2 := true ;
8444: LD_ADDR_LOC 6
8448: PUSH
8449: LD_INT 1
8451: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8452: LD_EXP 1
8456: PPUSH
8457: LD_INT 20
8459: PPUSH
8460: CALL_OW 308
8464: PUSH
8465: LD_EXP 43
8469: PPUSH
8470: LD_INT 20
8472: PPUSH
8473: CALL_OW 308
8477: OR
8478: IFFALSE 8495
// begin Wait ( 0 0$3 ) ;
8480: LD_INT 105
8482: PPUSH
8483: CALL_OW 67
// Attack3 := true ;
8487: LD_ADDR_LOC 7
8491: PUSH
8492: LD_INT 1
8494: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8495: LD_LOC 5
8499: PUSH
8500: LD_LOC 6
8504: NOT
8505: AND
8506: PUSH
8507: LD_LOC 7
8511: NOT
8512: AND
8513: IFFALSE 8576
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8515: LD_ADDR_VAR 0 1
8519: PUSH
8520: DOUBLE
8521: LD_EXP 31
8525: PUSH
8526: LD_INT 1
8528: PLUS
8529: DEC
8530: ST_TO_ADDR
8531: LD_EXP 31
8535: PUSH
8536: LD_EXP 30
8540: PLUS
8541: PUSH
8542: FOR_TO
8543: IFFALSE 8574
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8545: LD_EXP 29
8549: PUSH
8550: LD_VAR 0 1
8554: ARRAY
8555: PPUSH
8556: LD_EXP 1
8560: PPUSH
8561: CALL_OW 115
// Wait ( 2 ) ;
8565: LD_INT 2
8567: PPUSH
8568: CALL_OW 67
// end ;
8572: GO 8542
8574: POP
8575: POP
// if Attack1 and Attack2 and not Attack3 then
8576: LD_LOC 5
8580: PUSH
8581: LD_LOC 6
8585: AND
8586: PUSH
8587: LD_LOC 7
8591: NOT
8592: AND
8593: IFFALSE 8660
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8595: LD_ADDR_VAR 0 1
8599: PUSH
8600: DOUBLE
8601: LD_EXP 31
8605: PUSH
8606: LD_INT 1
8608: PLUS
8609: DEC
8610: ST_TO_ADDR
8611: LD_EXP 31
8615: PUSH
8616: LD_INT 2
8618: PUSH
8619: LD_EXP 30
8623: MUL
8624: PLUS
8625: PUSH
8626: FOR_TO
8627: IFFALSE 8658
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8629: LD_EXP 29
8633: PUSH
8634: LD_VAR 0 1
8638: ARRAY
8639: PPUSH
8640: LD_EXP 1
8644: PPUSH
8645: CALL_OW 115
// Wait ( 2 ) ;
8649: LD_INT 2
8651: PPUSH
8652: CALL_OW 67
// end ;
8656: GO 8626
8658: POP
8659: POP
// if Attack1 and Attack2 and Attack3 then
8660: LD_LOC 5
8664: PUSH
8665: LD_LOC 6
8669: AND
8670: PUSH
8671: LD_LOC 7
8675: AND
8676: IFFALSE 8743
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8678: LD_ADDR_VAR 0 1
8682: PUSH
8683: DOUBLE
8684: LD_EXP 31
8688: PUSH
8689: LD_INT 1
8691: PLUS
8692: DEC
8693: ST_TO_ADDR
8694: LD_EXP 31
8698: PUSH
8699: LD_INT 3
8701: PUSH
8702: LD_EXP 30
8706: MUL
8707: PLUS
8708: PUSH
8709: FOR_TO
8710: IFFALSE 8741
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8712: LD_EXP 29
8716: PUSH
8717: LD_VAR 0 1
8721: ARRAY
8722: PPUSH
8723: LD_EXP 1
8727: PPUSH
8728: CALL_OW 115
// Wait ( 2 ) ;
8732: LD_INT 2
8734: PPUSH
8735: CALL_OW 67
// end ;
8739: GO 8709
8741: POP
8742: POP
// for i := 1 to pursuers_base do
8743: LD_ADDR_VAR 0 1
8747: PUSH
8748: DOUBLE
8749: LD_INT 1
8751: DEC
8752: ST_TO_ADDR
8753: LD_EXP 31
8757: PUSH
8758: FOR_TO
8759: IFFALSE 8790
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8761: LD_EXP 29
8765: PUSH
8766: LD_VAR 0 1
8770: ARRAY
8771: PPUSH
8772: LD_EXP 1
8776: PPUSH
8777: CALL_OW 115
// Wait ( 2 ) ;
8781: LD_INT 2
8783: PPUSH
8784: CALL_OW 67
// end ;
8788: GO 8758
8790: POP
8791: POP
// if not disabled5 then
8792: LD_LOC 4
8796: NOT
8797: IFFALSE 8800
// enable ;
8799: ENABLE
// end ;
8800: PPOPN 1
8802: END
// every 0 0$1 marked 6 do
8803: GO 8805
8805: DISABLE
// begin if Goss_time > 0 then
8806: LD_EXP 47
8810: PUSH
8811: LD_INT 0
8813: GREATER
8814: IFFALSE 8850
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8816: LD_ADDR_OWVAR 47
8820: PUSH
8821: LD_STRING #Ru12a-1
8823: PUSH
8824: LD_EXP 47
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8833: LD_ADDR_EXP 47
8837: PUSH
8838: LD_EXP 47
8842: PUSH
8843: LD_INT 35
8845: MINUS
8846: ST_TO_ADDR
// enable ;
8847: ENABLE
// end else
8848: GO 8861
// begin display_strings :=  ;
8850: LD_ADDR_OWVAR 47
8854: PUSH
8855: LD_STRING 
8857: ST_TO_ADDR
// enable ( 3 ) ;
8858: LD_INT 3
8860: ENABLE_MARKED
// end ; end ;
8861: END
// every 0 0$1 marked 7 do
8862: GO 8864
8864: DISABLE
// begin if FindArtifact ( 4 ) then
8865: LD_INT 4
8867: PPUSH
8868: CALL_OW 469
8872: IFFALSE 8926
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8874: LD_LOC 8
8878: PPUSH
8879: LD_INT 4
8881: PPUSH
8882: CALL_OW 469
8886: PUSH
8887: LD_INT 1
8889: ARRAY
8890: PPUSH
8891: LD_INT 4
8893: PPUSH
8894: CALL_OW 469
8898: PUSH
8899: LD_INT 2
8901: ARRAY
8902: PPUSH
8903: CALL_OW 160
// Wait ( 3 ) ;
8907: LD_INT 3
8909: PPUSH
8910: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8914: LD_LOC 8
8918: PPUSH
8919: LD_INT 9
8921: PPUSH
8922: CALL_OW 173
// end ; enable ;
8926: ENABLE
// end ;
8927: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8928: GO 8930
8930: DISABLE
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
// begin Wait ( pausa ) ;
8937: LD_EXP 37
8941: PPUSH
8942: CALL_OW 67
// sc_utok := [ ] ;
8946: LD_ADDR_VAR 0 3
8950: PUSH
8951: EMPTY
8952: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8953: LD_ADDR_VAR 0 1
8957: PUSH
8958: DOUBLE
8959: LD_INT 1
8961: DEC
8962: ST_TO_ADDR
8963: LD_INT 2
8965: PUSH
8966: LD_OWVAR 67
8970: PLUS
8971: PUSH
8972: FOR_TO
8973: IFFALSE 9177
// begin uc_side := rus ;
8975: LD_ADDR_OWVAR 20
8979: PUSH
8980: LD_EXP 24
8984: ST_TO_ADDR
// uc_nation := nation_russian ;
8985: LD_ADDR_OWVAR 21
8989: PUSH
8990: LD_INT 3
8992: ST_TO_ADDR
// uc_direction := 5 ;
8993: LD_ADDR_OWVAR 24
8997: PUSH
8998: LD_INT 5
9000: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9001: LD_INT 1
9003: PPUSH
9004: LD_INT 3
9006: PPUSH
9007: CALL_OW 12
9011: PUSH
9012: LD_INT 1
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9044
9020: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9021: LD_INT 1
9023: PPUSH
9024: LD_INT 1
9026: PPUSH
9027: LD_INT 4
9029: PPUSH
9030: LD_INT 8
9032: PPUSH
9033: CALL_OW 12
9037: PPUSH
9038: CALL_OW 380
9042: GO 9083
9044: LD_INT 2
9046: DOUBLE
9047: GREATEREQUAL
9048: IFFALSE 9056
9050: LD_INT 3
9052: DOUBLE
9053: LESSEQUAL
9054: IFTRUE 9058
9056: GO 9082
9058: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 9
9064: PPUSH
9065: LD_INT 3
9067: PPUSH
9068: LD_INT 7
9070: PPUSH
9071: CALL_OW 12
9075: PPUSH
9076: CALL_OW 380
9080: GO 9083
9082: POP
// hc_name :=  ;
9083: LD_ADDR_OWVAR 26
9087: PUSH
9088: LD_STRING 
9090: ST_TO_ADDR
// clovek := CreateHuman ;
9091: LD_ADDR_VAR 0 2
9095: PUSH
9096: CALL_OW 44
9100: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: LD_INT 9
9108: PPUSH
9109: LD_INT 0
9111: PPUSH
9112: CALL_OW 49
// Wait ( 0 0$2 ) ;
9116: LD_INT 70
9118: PPUSH
9119: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9123: LD_VAR 0 2
9127: PPUSH
9128: LD_INT 50
9130: PPUSH
9131: LD_INT 84
9133: PPUSH
9134: CALL_OW 111
// Wait ( 2 ) ;
9138: LD_INT 2
9140: PPUSH
9141: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9145: LD_VAR 0 2
9149: PPUSH
9150: LD_EXP 50
9154: PPUSH
9155: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9159: LD_ADDR_VAR 0 3
9163: PUSH
9164: LD_VAR 0 3
9168: PUSH
9169: LD_VAR 0 2
9173: ADD
9174: ST_TO_ADDR
// end ;
9175: GO 8972
9177: POP
9178: POP
// Wait ( 0 0$10 ) ;
9179: LD_INT 350
9181: PPUSH
9182: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9186: LD_LOC 8
9190: PPUSH
9191: CALL_OW 302
9195: NOT
9196: IFFALSE 9303
// begin uc_side := rus ;
9198: LD_ADDR_OWVAR 20
9202: PUSH
9203: LD_EXP 24
9207: ST_TO_ADDR
// uc_nation := nation_russian ;
9208: LD_ADDR_OWVAR 21
9212: PUSH
9213: LD_INT 3
9215: ST_TO_ADDR
// uc_direction := 5 ;
9216: LD_ADDR_OWVAR 24
9220: PUSH
9221: LD_INT 5
9223: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9224: LD_ADDR_OWVAR 37
9228: PUSH
9229: LD_INT 22
9231: ST_TO_ADDR
// vc_control := control_computer ;
9232: LD_ADDR_OWVAR 38
9236: PUSH
9237: LD_INT 3
9239: ST_TO_ADDR
// vc_engine := engine_siberite ;
9240: LD_ADDR_OWVAR 39
9244: PUSH
9245: LD_INT 3
9247: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9248: LD_ADDR_OWVAR 40
9252: PUSH
9253: LD_INT 51
9255: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9256: LD_ADDR_LOC 8
9260: PUSH
9261: CALL_OW 45
9265: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9266: LD_LOC 8
9270: PPUSH
9271: LD_INT 9
9273: PPUSH
9274: LD_INT 0
9276: PPUSH
9277: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9281: LD_INT 18
9283: PPUSH
9284: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9288: LD_LOC 8
9292: PPUSH
9293: LD_INT 55
9295: PPUSH
9296: LD_INT 84
9298: PPUSH
9299: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9303: LD_VAR 0 3
9307: PUSH
9308: LD_LOC 8
9312: PPUSH
9313: CALL_OW 302
9317: AND
9318: IFFALSE 9388
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9320: LD_VAR 0 3
9324: PPUSH
9325: LD_EXP 50
9329: PPUSH
9330: CALL_OW 115
// Wait ( 0 0$2 ) ;
9334: LD_INT 70
9336: PPUSH
9337: CALL_OW 67
// for un in sc_utok do
9341: LD_ADDR_VAR 0 4
9345: PUSH
9346: LD_VAR 0 3
9350: PUSH
9351: FOR_IN
9352: IFFALSE 9384
// if not IsOK ( un ) then
9354: LD_VAR 0 4
9358: PPUSH
9359: CALL_OW 302
9363: NOT
9364: IFFALSE 9382
// sc_utok := sc_utok diff un ;
9366: LD_ADDR_VAR 0 3
9370: PUSH
9371: LD_VAR 0 3
9375: PUSH
9376: LD_VAR 0 4
9380: DIFF
9381: ST_TO_ADDR
9382: GO 9351
9384: POP
9385: POP
// end ;
9386: GO 9303
// Wait ( 0 0$5 ) ;
9388: LD_INT 175
9390: PPUSH
9391: CALL_OW 67
// enable ;
9395: ENABLE
// end ;
9396: PPOPN 4
9398: END
// every 0 0$3 marked 9 do
9399: GO 9401
9401: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9402: LD_LOC 8
9406: PPUSH
9407: LD_INT 3
9409: PPUSH
9410: CALL_OW 308
9414: PUSH
9415: LD_LOC 8
9419: PPUSH
9420: LD_INT 4
9422: PPUSH
9423: CALL_OW 289
9427: PUSH
9428: LD_INT 40
9430: EQUAL
9431: AND
9432: IFFALSE 9441
// YouLost ( Artefact ) ;
9434: LD_STRING Artefact
9436: PPUSH
9437: CALL_OW 104
// enable ;
9441: ENABLE
// end ;
9442: END
// on UnitDestroyed ( human ) do var i , un ;
9443: LD_INT 0
9445: PPUSH
9446: PPUSH
// begin if human = Burlak then
9447: LD_VAR 0 1
9451: PUSH
9452: LD_EXP 1
9456: EQUAL
9457: IFFALSE 9466
// YouLost ( Burlak ) ;
9459: LD_STRING Burlak
9461: PPUSH
9462: CALL_OW 104
// if human = Gossudarov then
9466: LD_VAR 0 1
9470: PUSH
9471: LD_EXP 8
9475: EQUAL
9476: IFFALSE 9485
// YouLost ( Gossudarov ) ;
9478: LD_STRING Gossudarov
9480: PPUSH
9481: CALL_OW 104
// if human = Masha then
9485: LD_VAR 0 1
9489: PUSH
9490: LD_EXP 43
9494: EQUAL
9495: IFFALSE 9505
// lost_masha := true ;
9497: LD_ADDR_EXP 52
9501: PUSH
9502: LD_INT 1
9504: ST_TO_ADDR
// if human in straz then
9505: LD_VAR 0 1
9509: PUSH
9510: LD_EXP 45
9514: IN
9515: IFFALSE 9564
// begin straz := straz diff human ;
9517: LD_ADDR_EXP 45
9521: PUSH
9522: LD_EXP 45
9526: PUSH
9527: LD_VAR 0 1
9531: DIFF
9532: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9533: LD_EXP 62
9537: PPUSH
9538: LD_VAR 0 1
9542: PPUSH
9543: LD_INT 1
9545: PPUSH
9546: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9550: LD_ADDR_EXP 53
9554: PUSH
9555: LD_EXP 53
9559: PUSH
9560: LD_INT 1
9562: PLUS
9563: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9564: LD_VAR 0 1
9568: PPUSH
9569: CALL_OW 255
9573: PUSH
9574: LD_INT 3
9576: EQUAL
9577: PUSH
9578: LD_VAR 0 1
9582: PUSH
9583: LD_EXP 60
9587: IN
9588: AND
9589: IFFALSE 9636
// begin for i in attackGroup do
9591: LD_ADDR_VAR 0 2
9595: PUSH
9596: LD_EXP 60
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9634
// if i = human then
9604: LD_VAR 0 2
9608: PUSH
9609: LD_VAR 0 1
9613: EQUAL
9614: IFFALSE 9632
// attackGroup = attackGroup diff i ;
9616: LD_ADDR_EXP 60
9620: PUSH
9621: LD_EXP 60
9625: PUSH
9626: LD_VAR 0 2
9630: DIFF
9631: ST_TO_ADDR
9632: GO 9601
9634: POP
9635: POP
// end ; end ;
9636: PPOPN 3
9638: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9639: LD_VAR 0 1
9643: PUSH
9644: LD_EXP 8
9648: EQUAL
9649: IFFALSE 9670
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9651: LD_EXP 8
9655: PPUSH
9656: CALL_OW 310
9660: PPUSH
9661: LD_EXP 23
9665: PPUSH
9666: CALL_OW 235
// SetSide ( num , you ) ;
9670: LD_VAR 0 1
9674: PPUSH
9675: LD_EXP 23
9679: PPUSH
9680: CALL_OW 235
// end ;
9684: PPOPN 1
9686: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9687: LD_VAR 0 1
9691: PPUSH
9692: CALL_OW 255
9696: PUSH
9697: LD_EXP 24
9701: NONEQUAL
9702: IFFALSE 9714
// Artifact_cargo := un ;
9704: LD_ADDR_EXP 50
9708: PUSH
9709: LD_VAR 0 1
9713: ST_TO_ADDR
// end ; end_of_file
9714: PPOPN 2
9716: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9717: GO 9719
9719: DISABLE
9720: LD_INT 0
9722: PPUSH
9723: PPUSH
9724: PPUSH
9725: PPUSH
9726: PPUSH
9727: PPUSH
9728: PPUSH
// begin case tick of 0 .. 30000 :
9729: LD_OWVAR 1
9733: PUSH
9734: LD_INT 0
9736: DOUBLE
9737: GREATEREQUAL
9738: IFFALSE 9746
9740: LD_INT 30000
9742: DOUBLE
9743: LESSEQUAL
9744: IFTRUE 9748
9746: GO 9758
9748: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9749: LD_INT 1050
9751: PPUSH
9752: CALL_OW 67
9756: GO 9934
9758: LD_INT 30001
9760: DOUBLE
9761: GREATEREQUAL
9762: IFFALSE 9770
9764: LD_INT 50000
9766: DOUBLE
9767: LESSEQUAL
9768: IFTRUE 9772
9770: GO 9782
9772: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9773: LD_INT 1575
9775: PPUSH
9776: CALL_OW 67
9780: GO 9934
9782: LD_INT 50001
9784: DOUBLE
9785: GREATEREQUAL
9786: IFFALSE 9794
9788: LD_INT 70000
9790: DOUBLE
9791: LESSEQUAL
9792: IFTRUE 9796
9794: GO 9806
9796: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9797: LD_INT 2100
9799: PPUSH
9800: CALL_OW 67
9804: GO 9934
9806: LD_INT 70001
9808: DOUBLE
9809: GREATEREQUAL
9810: IFFALSE 9818
9812: LD_INT 90000
9814: DOUBLE
9815: LESSEQUAL
9816: IFTRUE 9820
9818: GO 9830
9820: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9821: LD_INT 2625
9823: PPUSH
9824: CALL_OW 67
9828: GO 9934
9830: LD_INT 70001
9832: DOUBLE
9833: GREATEREQUAL
9834: IFFALSE 9842
9836: LD_INT 90000
9838: DOUBLE
9839: LESSEQUAL
9840: IFTRUE 9844
9842: GO 9854
9844: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9845: LD_INT 3150
9847: PPUSH
9848: CALL_OW 67
9852: GO 9934
9854: LD_INT 90001
9856: DOUBLE
9857: GREATEREQUAL
9858: IFFALSE 9866
9860: LD_INT 110000
9862: DOUBLE
9863: LESSEQUAL
9864: IFTRUE 9868
9866: GO 9878
9868: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9869: LD_INT 3675
9871: PPUSH
9872: CALL_OW 67
9876: GO 9934
9878: LD_INT 110001
9880: DOUBLE
9881: GREATEREQUAL
9882: IFFALSE 9890
9884: LD_INT 130000
9886: DOUBLE
9887: LESSEQUAL
9888: IFTRUE 9892
9890: GO 9902
9892: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9893: LD_INT 4200
9895: PPUSH
9896: CALL_OW 67
9900: GO 9934
9902: LD_INT 130001
9904: DOUBLE
9905: GREATEREQUAL
9906: IFFALSE 9914
9908: LD_INT 150000
9910: DOUBLE
9911: LESSEQUAL
9912: IFTRUE 9916
9914: GO 9926
9916: POP
// Wait ( 2 2$15 ) ; else
9917: LD_INT 4725
9919: PPUSH
9920: CALL_OW 67
9924: GO 9934
9926: POP
// Wait ( 2 2$30 ) ; end ;
9927: LD_INT 5250
9929: PPUSH
9930: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9934: LD_ADDR_LOC 9
9938: PUSH
9939: LD_INT 22
9941: PUSH
9942: LD_INT 3
9944: PUSH
9945: LD_INT 1
9947: PUSH
9948: LD_INT 43
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 23
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: LD_INT 1
9965: PUSH
9966: LD_INT 45
9968: PUSH
9969: EMPTY
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: PUSH
9975: LD_INT 21
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: LD_INT 1
9983: PUSH
9984: LD_INT 43
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 24
9995: PUSH
9996: LD_INT 3
9998: PUSH
9999: LD_INT 1
10001: PUSH
10002: LD_INT 45
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: PUSH
10011: LD_INT 21
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: LD_INT 1
10019: PUSH
10020: LD_INT 45
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 22
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 1
10037: PUSH
10038: LD_INT 44
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 24
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: LD_INT 46
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: PUSH
10065: LD_INT 23
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: LD_INT 46
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 24
10085: PUSH
10086: LD_INT 3
10088: PUSH
10089: LD_INT 3
10091: PUSH
10092: LD_INT 46
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: PUSH
10101: LD_INT 23
10103: PUSH
10104: LD_INT 3
10106: PUSH
10107: LD_INT 3
10109: PUSH
10110: LD_INT 47
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_INT 24
10121: PUSH
10122: LD_INT 3
10124: PUSH
10125: LD_INT 3
10127: PUSH
10128: LD_INT 49
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: PUSH
10137: LD_INT 23
10139: PUSH
10140: LD_INT 3
10142: PUSH
10143: LD_INT 1
10145: PUSH
10146: LD_INT 49
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: LIST
10168: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10169: LD_ADDR_VAR 0 1
10173: PUSH
10174: LD_INT 22
10176: PUSH
10177: LD_EXP 23
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: PUSH
10186: LD_INT 21
10188: PUSH
10189: LD_INT 2
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PPUSH
10200: CALL_OW 69
10204: ST_TO_ADDR
// if filter < 3 then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 3
10212: LESS
10213: IFFALSE 10223
// filter := 3 ;
10215: LD_ADDR_VAR 0 1
10219: PUSH
10220: LD_INT 3
10222: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10223: LD_INT 22
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PUSH
10233: LD_INT 21
10235: PUSH
10236: LD_INT 2
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 50
10245: PUSH
10246: EMPTY
10247: LIST
10248: PUSH
10249: LD_INT 2
10251: PUSH
10252: LD_INT 34
10254: PUSH
10255: LD_INT 43
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: PUSH
10262: LD_INT 34
10264: PUSH
10265: LD_INT 45
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 34
10274: PUSH
10275: LD_INT 44
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 34
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 47
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: LD_INT 34
10304: PUSH
10305: LD_INT 49
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: PUSH
10332: LD_INT 6
10334: LESSEQUAL
10335: IFFALSE 10866
// for i := 1 to ( filter div 3 ) do
10337: LD_ADDR_VAR 0 2
10341: PUSH
10342: DOUBLE
10343: LD_INT 1
10345: DEC
10346: ST_TO_ADDR
10347: LD_VAR 0 1
10351: PUSH
10352: LD_INT 3
10354: DIV
10355: PUSH
10356: FOR_TO
10357: IFFALSE 10864
// begin uc_side := rus ;
10359: LD_ADDR_OWVAR 20
10363: PUSH
10364: LD_EXP 24
10368: ST_TO_ADDR
// uc_nation := nation_russian ;
10369: LD_ADDR_OWVAR 21
10373: PUSH
10374: LD_INT 3
10376: ST_TO_ADDR
// uc_direction := 5 ;
10377: LD_ADDR_OWVAR 24
10381: PUSH
10382: LD_INT 5
10384: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10385: LD_OWVAR 1
10389: PUSH
10390: LD_INT 60000
10392: LESS
10393: PUSH
10394: LD_INT 28
10396: PPUSH
10397: LD_EXP 23
10401: PPUSH
10402: CALL_OW 321
10406: PUSH
10407: LD_INT 2
10409: EQUAL
10410: OR
10411: IFFALSE 10437
// typ := rand ( 1 , vehicles - 2 ) else
10413: LD_ADDR_VAR 0 4
10417: PUSH
10418: LD_INT 1
10420: PPUSH
10421: LD_LOC 9
10425: PUSH
10426: LD_INT 2
10428: MINUS
10429: PPUSH
10430: CALL_OW 12
10434: ST_TO_ADDR
10435: GO 10455
// typ := rand ( 1 , vehicles ) ;
10437: LD_ADDR_VAR 0 4
10441: PUSH
10442: LD_INT 1
10444: PPUSH
10445: LD_LOC 9
10449: PPUSH
10450: CALL_OW 12
10454: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10455: LD_ADDR_OWVAR 37
10459: PUSH
10460: LD_LOC 9
10464: PUSH
10465: LD_VAR 0 4
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10475: LD_ADDR_OWVAR 38
10479: PUSH
10480: LD_LOC 9
10484: PUSH
10485: LD_VAR 0 4
10489: ARRAY
10490: PUSH
10491: LD_INT 2
10493: ARRAY
10494: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10495: LD_ADDR_OWVAR 39
10499: PUSH
10500: LD_LOC 9
10504: PUSH
10505: LD_VAR 0 4
10509: ARRAY
10510: PUSH
10511: LD_INT 3
10513: ARRAY
10514: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10515: LD_ADDR_OWVAR 40
10519: PUSH
10520: LD_LOC 9
10524: PUSH
10525: LD_VAR 0 4
10529: ARRAY
10530: PUSH
10531: LD_INT 4
10533: ARRAY
10534: ST_TO_ADDR
// auto := CreateVehicle ;
10535: LD_ADDR_VAR 0 5
10539: PUSH
10540: CALL_OW 45
10544: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10545: LD_VAR 0 5
10549: PPUSH
10550: LD_INT 9
10552: PPUSH
10553: LD_INT 0
10555: PPUSH
10556: CALL_OW 49
// attack := attack ^ auto ;
10560: LD_ADDR_LOC 10
10564: PUSH
10565: LD_LOC 10
10569: PUSH
10570: LD_VAR 0 5
10574: ADD
10575: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10576: LD_VAR 0 5
10580: PPUSH
10581: LD_INT 52
10583: PPUSH
10584: LD_INT 61
10586: PPUSH
10587: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10591: LD_VAR 0 5
10595: PPUSH
10596: LD_INT 52
10598: PPUSH
10599: LD_INT 61
10601: PPUSH
10602: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10606: LD_INT 1
10608: PPUSH
10609: LD_INT 2
10611: PPUSH
10612: CALL_OW 12
10616: PUSH
10617: LD_INT 1
10619: DOUBLE
10620: EQUAL
10621: IFTRUE 10625
10623: GO 10643
10625: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10626: LD_VAR 0 5
10630: PPUSH
10631: LD_INT 35
10633: PPUSH
10634: LD_INT 30
10636: PPUSH
10637: CALL_OW 174
10641: GO 10670
10643: LD_INT 2
10645: DOUBLE
10646: EQUAL
10647: IFTRUE 10651
10649: GO 10669
10651: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10652: LD_VAR 0 5
10656: PPUSH
10657: LD_INT 17
10659: PPUSH
10660: LD_INT 29
10662: PPUSH
10663: CALL_OW 174
10667: GO 10670
10669: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10670: LD_VAR 0 5
10674: PPUSH
10675: LD_INT 29
10677: PPUSH
10678: LD_INT 5
10680: PPUSH
10681: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10685: LD_INT 1
10687: PPUSH
10688: LD_INT 2
10690: PPUSH
10691: CALL_OW 12
10695: PUSH
10696: LD_INT 1
10698: DOUBLE
10699: EQUAL
10700: IFTRUE 10704
10702: GO 10722
10704: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10705: LD_VAR 0 5
10709: PPUSH
10710: LD_INT 60
10712: PPUSH
10713: LD_INT 30
10715: PPUSH
10716: CALL_OW 174
10720: GO 10749
10722: LD_INT 2
10724: DOUBLE
10725: EQUAL
10726: IFTRUE 10730
10728: GO 10748
10730: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10731: LD_VAR 0 5
10735: PPUSH
10736: LD_INT 84
10738: PPUSH
10739: LD_INT 30
10741: PPUSH
10742: CALL_OW 174
10746: GO 10749
10748: POP
// case Rand ( 1 , 2 ) of 1 :
10749: LD_INT 1
10751: PPUSH
10752: LD_INT 2
10754: PPUSH
10755: CALL_OW 12
10759: PUSH
10760: LD_INT 1
10762: DOUBLE
10763: EQUAL
10764: IFTRUE 10768
10766: GO 10786
10768: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10769: LD_VAR 0 5
10773: PPUSH
10774: LD_INT 71
10776: PPUSH
10777: LD_INT 59
10779: PPUSH
10780: CALL_OW 174
10784: GO 10813
10786: LD_INT 2
10788: DOUBLE
10789: EQUAL
10790: IFTRUE 10794
10792: GO 10812
10794: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10795: LD_VAR 0 5
10799: PPUSH
10800: LD_INT 92
10802: PPUSH
10803: LD_INT 66
10805: PPUSH
10806: CALL_OW 174
10810: GO 10813
10812: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10813: LD_VAR 0 5
10817: PPUSH
10818: LD_INT 78
10820: PPUSH
10821: LD_INT 88
10823: PPUSH
10824: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10828: LD_VAR 0 5
10832: PPUSH
10833: LD_INT 117
10835: PPUSH
10836: LD_INT 90
10838: PPUSH
10839: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10843: LD_VAR 0 5
10847: PPUSH
10848: LD_INT 15
10850: PPUSH
10851: CALL_OW 173
// Wait ( 0 0$4 ) ;
10855: LD_INT 140
10857: PPUSH
10858: CALL_OW 67
// end ;
10862: GO 10356
10864: POP
10865: POP
// enable ;
10866: ENABLE
// end ;
10867: PPOPN 7
10869: END
// export function PrepareInfantry ; var i , clovek ; begin
10870: LD_INT 0
10872: PPUSH
10873: PPUSH
10874: PPUSH
// for i = 1 to 6 do
10875: LD_ADDR_VAR 0 2
10879: PUSH
10880: DOUBLE
10881: LD_INT 1
10883: DEC
10884: ST_TO_ADDR
10885: LD_INT 6
10887: PUSH
10888: FOR_TO
10889: IFFALSE 11054
// begin uc_side = 3 ;
10891: LD_ADDR_OWVAR 20
10895: PUSH
10896: LD_INT 3
10898: ST_TO_ADDR
// uc_nation = 3 ;
10899: LD_ADDR_OWVAR 21
10903: PUSH
10904: LD_INT 3
10906: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10907: LD_INT 1
10909: PPUSH
10910: LD_INT 3
10912: PPUSH
10913: CALL_OW 12
10917: PUSH
10918: LD_INT 1
10920: DOUBLE
10921: EQUAL
10922: IFTRUE 10926
10924: GO 10950
10926: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
10927: LD_INT 1
10929: PPUSH
10930: LD_INT 1
10932: PPUSH
10933: LD_INT 4
10935: PPUSH
10936: LD_INT 8
10938: PPUSH
10939: CALL_OW 12
10943: PPUSH
10944: CALL_OW 380
10948: GO 10989
10950: LD_INT 2
10952: DOUBLE
10953: GREATEREQUAL
10954: IFFALSE 10962
10956: LD_INT 3
10958: DOUBLE
10959: LESSEQUAL
10960: IFTRUE 10964
10962: GO 10988
10964: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
10965: LD_INT 1
10967: PPUSH
10968: LD_INT 9
10970: PPUSH
10971: LD_INT 3
10973: PPUSH
10974: LD_INT 7
10976: PPUSH
10977: CALL_OW 12
10981: PPUSH
10982: CALL_OW 380
10986: GO 10989
10988: POP
// hc_name :=  ;
10989: LD_ADDR_OWVAR 26
10993: PUSH
10994: LD_STRING 
10996: ST_TO_ADDR
// clovek := CreateHuman ;
10997: LD_ADDR_VAR 0 3
11001: PUSH
11002: CALL_OW 44
11006: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11007: LD_VAR 0 3
11011: PPUSH
11012: LD_INT 9
11014: PPUSH
11015: LD_INT 0
11017: PPUSH
11018: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11022: LD_ADDR_EXP 59
11026: PUSH
11027: LD_EXP 59
11031: PUSH
11032: LD_INT 1
11034: MINUS
11035: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11036: LD_ADDR_EXP 60
11040: PUSH
11041: LD_EXP 60
11045: PUSH
11046: LD_VAR 0 3
11050: ADD
11051: ST_TO_ADDR
// end ;
11052: GO 10888
11054: POP
11055: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11056: LD_EXP 60
11060: PPUSH
11061: LD_INT 52
11063: PPUSH
11064: LD_INT 61
11066: PPUSH
11067: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11071: LD_INT 1
11073: PPUSH
11074: LD_INT 2
11076: PPUSH
11077: CALL_OW 12
11081: PUSH
11082: LD_INT 1
11084: DOUBLE
11085: EQUAL
11086: IFTRUE 11090
11088: GO 11108
11090: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11091: LD_EXP 60
11095: PPUSH
11096: LD_INT 35
11098: PPUSH
11099: LD_INT 30
11101: PPUSH
11102: CALL_OW 174
11106: GO 11135
11108: LD_INT 2
11110: DOUBLE
11111: EQUAL
11112: IFTRUE 11116
11114: GO 11134
11116: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11117: LD_EXP 60
11121: PPUSH
11122: LD_INT 17
11124: PPUSH
11125: LD_INT 29
11127: PPUSH
11128: CALL_OW 174
11132: GO 11135
11134: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11135: LD_EXP 60
11139: PPUSH
11140: LD_INT 29
11142: PPUSH
11143: LD_INT 5
11145: PPUSH
11146: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11150: LD_INT 1
11152: PPUSH
11153: LD_INT 2
11155: PPUSH
11156: CALL_OW 12
11160: PUSH
11161: LD_INT 1
11163: DOUBLE
11164: EQUAL
11165: IFTRUE 11169
11167: GO 11187
11169: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11170: LD_EXP 60
11174: PPUSH
11175: LD_INT 60
11177: PPUSH
11178: LD_INT 30
11180: PPUSH
11181: CALL_OW 174
11185: GO 11214
11187: LD_INT 2
11189: DOUBLE
11190: EQUAL
11191: IFTRUE 11195
11193: GO 11213
11195: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11196: LD_EXP 60
11200: PPUSH
11201: LD_INT 84
11203: PPUSH
11204: LD_INT 30
11206: PPUSH
11207: CALL_OW 174
11211: GO 11214
11213: POP
// case Rand ( 1 , 2 ) of 1 :
11214: LD_INT 1
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: CALL_OW 12
11224: PUSH
11225: LD_INT 1
11227: DOUBLE
11228: EQUAL
11229: IFTRUE 11233
11231: GO 11251
11233: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11234: LD_EXP 60
11238: PPUSH
11239: LD_INT 71
11241: PPUSH
11242: LD_INT 59
11244: PPUSH
11245: CALL_OW 174
11249: GO 11278
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11277
11259: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11260: LD_EXP 60
11264: PPUSH
11265: LD_INT 92
11267: PPUSH
11268: LD_INT 66
11270: PPUSH
11271: CALL_OW 174
11275: GO 11278
11277: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11278: LD_EXP 60
11282: PPUSH
11283: LD_INT 78
11285: PPUSH
11286: LD_INT 88
11288: PPUSH
11289: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11293: LD_EXP 60
11297: PPUSH
11298: LD_INT 117
11300: PPUSH
11301: LD_INT 90
11303: PPUSH
11304: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11308: LD_EXP 60
11312: PPUSH
11313: LD_INT 15
11315: PPUSH
11316: CALL_OW 173
// end ;
11320: LD_VAR 0 1
11324: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11325: LD_EXP 60
11329: PUSH
11330: EMPTY
11331: EQUAL
11332: PUSH
11333: LD_EXP 61
11337: PUSH
11338: LD_INT 1
11340: EQUAL
11341: AND
11342: IFFALSE 11352
11344: GO 11346
11346: DISABLE
// begin enable ;
11347: ENABLE
// PrepareInfantry ;
11348: CALL 10870 0 0
// end ;
11352: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11353: GO 11355
11355: DISABLE
11356: LD_INT 0
11358: PPUSH
11359: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11360: LD_ADDR_VAR 0 1
11364: PUSH
11365: LD_INT 15
11367: PPUSH
11368: LD_INT 22
11370: PUSH
11371: LD_EXP 24
11375: PUSH
11376: EMPTY
11377: LIST
11378: LIST
11379: PUSH
11380: LD_INT 50
11382: PUSH
11383: EMPTY
11384: LIST
11385: PUSH
11386: LD_INT 2
11388: PUSH
11389: LD_INT 21
11391: PUSH
11392: LD_INT 2
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: PUSH
11399: LD_INT 21
11401: PUSH
11402: LD_INT 1
11404: PUSH
11405: EMPTY
11406: LIST
11407: LIST
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: LIST
11413: PUSH
11414: EMPTY
11415: LIST
11416: LIST
11417: LIST
11418: PPUSH
11419: CALL_OW 70
11423: ST_TO_ADDR
// case tick of 0 .. 30000 :
11424: LD_OWVAR 1
11428: PUSH
11429: LD_INT 0
11431: DOUBLE
11432: GREATEREQUAL
11433: IFFALSE 11441
11435: LD_INT 30000
11437: DOUBLE
11438: LESSEQUAL
11439: IFTRUE 11443
11441: GO 11460
11443: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11444: LD_ADDR_VAR 0 2
11448: PUSH
11449: LD_EXP 34
11453: PUSH
11454: LD_INT 4
11456: MINUS
11457: ST_TO_ADDR
11458: GO 11564
11460: LD_INT 30001
11462: DOUBLE
11463: GREATEREQUAL
11464: IFFALSE 11472
11466: LD_INT 50000
11468: DOUBLE
11469: LESSEQUAL
11470: IFTRUE 11474
11472: GO 11491
11474: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11475: LD_ADDR_VAR 0 2
11479: PUSH
11480: LD_EXP 34
11484: PUSH
11485: LD_INT 3
11487: MINUS
11488: ST_TO_ADDR
11489: GO 11564
11491: LD_INT 50001
11493: DOUBLE
11494: GREATEREQUAL
11495: IFFALSE 11503
11497: LD_INT 70000
11499: DOUBLE
11500: LESSEQUAL
11501: IFTRUE 11505
11503: GO 11522
11505: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11506: LD_ADDR_VAR 0 2
11510: PUSH
11511: LD_EXP 34
11515: PUSH
11516: LD_INT 2
11518: MINUS
11519: ST_TO_ADDR
11520: GO 11564
11522: LD_INT 70001
11524: DOUBLE
11525: GREATEREQUAL
11526: IFFALSE 11534
11528: LD_INT 90000
11530: DOUBLE
11531: LESSEQUAL
11532: IFTRUE 11536
11534: GO 11553
11536: POP
// mnozstvi := maxaut - 1 ; else
11537: LD_ADDR_VAR 0 2
11541: PUSH
11542: LD_EXP 34
11546: PUSH
11547: LD_INT 1
11549: MINUS
11550: ST_TO_ADDR
11551: GO 11564
11553: POP
// mnozstvi := maxaut ; end ;
11554: LD_ADDR_VAR 0 2
11558: PUSH
11559: LD_EXP 34
11563: ST_TO_ADDR
// if filter >= mnozstvi then
11564: LD_VAR 0 1
11568: PUSH
11569: LD_VAR 0 2
11573: GREATEREQUAL
11574: IFFALSE 11591
// ComMoveXY ( filter , 138 , 69 ) ;
11576: LD_VAR 0 1
11580: PPUSH
11581: LD_INT 138
11583: PPUSH
11584: LD_INT 69
11586: PPUSH
11587: CALL_OW 111
// enable ;
11591: ENABLE
// end ;
11592: PPOPN 2
11594: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11595: GO 11597
11597: DISABLE
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
11604: PPUSH
11605: PPUSH
// begin enable ;
11606: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11607: LD_ADDR_VAR 0 1
11611: PUSH
11612: LD_INT 12
11614: PPUSH
11615: LD_INT 22
11617: PUSH
11618: LD_EXP 24
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PUSH
11627: LD_INT 50
11629: PUSH
11630: EMPTY
11631: LIST
11632: PUSH
11633: LD_INT 3
11635: PUSH
11636: LD_INT 34
11638: PUSH
11639: LD_INT 49
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: LIST
11654: PPUSH
11655: CALL_OW 70
11659: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11660: LD_INT 33
11662: PPUSH
11663: LD_EXP 23
11667: PPUSH
11668: CALL_OW 321
11672: PUSH
11673: LD_INT 2
11675: EQUAL
11676: IFFALSE 11730
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11678: LD_ADDR_VAR 0 2
11682: PUSH
11683: LD_INT 12
11685: PPUSH
11686: LD_INT 22
11688: PUSH
11689: LD_EXP 23
11693: PUSH
11694: EMPTY
11695: LIST
11696: LIST
11697: PUSH
11698: LD_INT 25
11700: PUSH
11701: LD_INT 4
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: PUSH
11708: LD_INT 101
11710: PUSH
11711: LD_EXP 24
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: LIST
11724: PPUSH
11725: CALL_OW 70
11729: ST_TO_ADDR
// if filter_you = 0 then
11730: LD_VAR 0 2
11734: PUSH
11735: LD_INT 0
11737: EQUAL
11738: IFFALSE 11847
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11740: LD_ADDR_VAR 0 2
11744: PUSH
11745: LD_INT 22
11747: PUSH
11748: LD_EXP 23
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 50
11759: PUSH
11760: EMPTY
11761: LIST
11762: PUSH
11763: LD_INT 2
11765: PUSH
11766: LD_INT 21
11768: PUSH
11769: LD_INT 1
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: PUSH
11776: LD_INT 21
11778: PUSH
11779: LD_INT 2
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: PUSH
11786: LD_INT 21
11788: PUSH
11789: LD_INT 3
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: PUSH
11796: EMPTY
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: PPUSH
11807: CALL_OW 69
11811: ST_TO_ADDR
// if filter_you = 0 then
11812: LD_VAR 0 2
11816: PUSH
11817: LD_INT 0
11819: EQUAL
11820: IFFALSE 11847
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11822: LD_ADDR_VAR 0 2
11826: PUSH
11827: LD_INT 12
11829: PPUSH
11830: LD_INT 22
11832: PUSH
11833: LD_EXP 23
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: CALL_OW 70
11846: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11847: LD_VAR 0 1
11851: PUSH
11852: LD_INT 0
11854: GREATER
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: LD_INT 0
11863: GREATER
11864: AND
11865: IFFALSE 12256
// begin for un_rus in filter_rus do
11867: LD_ADDR_VAR 0 3
11871: PUSH
11872: LD_VAR 0 1
11876: PUSH
11877: FOR_IN
11878: IFFALSE 12254
// begin Wait ( 5 ) ;
11880: LD_INT 5
11882: PPUSH
11883: CALL_OW 67
// min := 99999 ;
11887: LD_ADDR_VAR 0 5
11891: PUSH
11892: LD_INT 99999
11894: ST_TO_ADDR
// cil := 0 ;
11895: LD_ADDR_VAR 0 6
11899: PUSH
11900: LD_INT 0
11902: ST_TO_ADDR
// for un_you in filter_you do
11903: LD_ADDR_VAR 0 4
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: FOR_IN
11914: IFFALSE 12110
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11916: LD_VAR 0 4
11920: PPUSH
11921: CALL_OW 320
11925: PUSH
11926: LD_VAR 0 4
11930: PPUSH
11931: CALL_OW 256
11935: PUSH
11936: LD_VAR 0 5
11940: LESS
11941: AND
11942: PUSH
11943: LD_VAR 0 3
11947: PPUSH
11948: LD_VAR 0 4
11952: PPUSH
11953: CALL_OW 296
11957: PUSH
11958: LD_INT 2
11960: PUSH
11961: LD_INT 2
11963: PUSH
11964: LD_INT 4
11966: PUSH
11967: LD_INT 6
11969: PUSH
11970: LD_INT 5
11972: PUSH
11973: LD_INT 9
11975: PUSH
11976: LD_INT 0
11978: PUSH
11979: LD_INT 2
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: PUSH
11992: LD_VAR 0 3
11996: PPUSH
11997: CALL_OW 264
12001: PUSH
12002: LD_INT 41
12004: MINUS
12005: ARRAY
12006: GREATEREQUAL
12007: AND
12008: PUSH
12009: LD_VAR 0 3
12013: PPUSH
12014: LD_VAR 0 4
12018: PPUSH
12019: CALL_OW 296
12023: PUSH
12024: LD_INT 15
12026: PUSH
12027: LD_INT 16
12029: PUSH
12030: LD_INT 17
12032: PUSH
12033: LD_INT 22
12035: PUSH
12036: LD_INT 20
12038: PUSH
12039: LD_INT 28
12041: PUSH
12042: LD_INT 0
12044: PUSH
12045: LD_INT 51
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: LIST
12057: PUSH
12058: LD_VAR 0 3
12062: PPUSH
12063: CALL_OW 264
12067: PUSH
12068: LD_INT 41
12070: MINUS
12071: ARRAY
12072: LESSEQUAL
12073: AND
12074: IFFALSE 12101
// begin min := GetLives ( un_you ) ;
12076: LD_ADDR_VAR 0 5
12080: PUSH
12081: LD_VAR 0 4
12085: PPUSH
12086: CALL_OW 256
12090: ST_TO_ADDR
// cil := un_you ;
12091: LD_ADDR_VAR 0 6
12095: PUSH
12096: LD_VAR 0 4
12100: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12101: LD_INT 5
12103: PPUSH
12104: CALL_OW 67
// end ;
12108: GO 11913
12110: POP
12111: POP
// if cil <> 0 then
12112: LD_VAR 0 6
12116: PUSH
12117: LD_INT 0
12119: NONEQUAL
12120: IFFALSE 12138
// ComAttackUnit ( un_rus , cil ) else
12122: LD_VAR 0 3
12126: PPUSH
12127: LD_VAR 0 6
12131: PPUSH
12132: CALL_OW 115
12136: GO 12252
// begin for un_you in filter_you do
12138: LD_ADDR_VAR 0 4
12142: PUSH
12143: LD_VAR 0 2
12147: PUSH
12148: FOR_IN
12149: IFFALSE 12236
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12151: LD_VAR 0 4
12155: PPUSH
12156: CALL_OW 266
12160: PUSH
12161: LD_INT 0
12163: PUSH
12164: LD_INT 1
12166: PUSH
12167: EMPTY
12168: LIST
12169: LIST
12170: IN
12171: IFFALSE 12185
// cil := un_you else
12173: LD_ADDR_VAR 0 6
12177: PUSH
12178: LD_VAR 0 4
12182: ST_TO_ADDR
12183: GO 12227
// if GetLives ( un_you ) < min then
12185: LD_VAR 0 4
12189: PPUSH
12190: CALL_OW 256
12194: PUSH
12195: LD_VAR 0 5
12199: LESS
12200: IFFALSE 12227
// begin min := GetLives ( un_you ) ;
12202: LD_ADDR_VAR 0 5
12206: PUSH
12207: LD_VAR 0 4
12211: PPUSH
12212: CALL_OW 256
12216: ST_TO_ADDR
// cil := un_you ;
12217: LD_ADDR_VAR 0 6
12221: PUSH
12222: LD_VAR 0 4
12226: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12227: LD_INT 5
12229: PPUSH
12230: CALL_OW 67
// end ;
12234: GO 12148
12236: POP
12237: POP
// ComAttackUnit ( un_rus , cil ) end ;
12238: LD_VAR 0 3
12242: PPUSH
12243: LD_VAR 0 6
12247: PPUSH
12248: CALL_OW 115
// end ;
12252: GO 11877
12254: POP
12255: POP
// end ; end ;
12256: PPOPN 6
12258: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12259: GO 12261
12261: DISABLE
12262: LD_INT 0
12264: PPUSH
12265: PPUSH
12266: PPUSH
12267: PPUSH
12268: PPUSH
12269: PPUSH
// begin enable ;
12270: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12271: LD_ADDR_VAR 0 1
12275: PUSH
12276: LD_INT 21
12278: PPUSH
12279: LD_INT 22
12281: PUSH
12282: LD_EXP 24
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: PUSH
12291: LD_INT 3
12293: PUSH
12294: LD_INT 2
12296: PUSH
12297: LD_INT 21
12299: PUSH
12300: LD_INT 3
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: PUSH
12307: LD_INT 34
12309: PUSH
12310: LD_INT 49
12312: PUSH
12313: EMPTY
12314: LIST
12315: LIST
12316: PUSH
12317: LD_INT 34
12319: PUSH
12320: LD_INT 51
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: PUSH
12327: LD_INT 25
12329: PUSH
12330: LD_INT 4
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 25
12339: PUSH
12340: LD_INT 2
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: LD_INT 54
12349: PUSH
12350: EMPTY
12351: LIST
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: LIST
12366: PPUSH
12367: CALL_OW 70
12371: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12372: LD_ADDR_VAR 0 1
12376: PUSH
12377: LD_VAR 0 1
12381: PUSH
12382: LD_EXP 45
12386: DIFF
12387: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12388: LD_ADDR_VAR 0 2
12392: PUSH
12393: LD_INT 21
12395: PPUSH
12396: LD_INT 22
12398: PUSH
12399: LD_EXP 23
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 21
12410: PUSH
12411: LD_INT 2
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PPUSH
12422: CALL_OW 70
12426: ST_TO_ADDR
// if not filter_you then
12427: LD_VAR 0 2
12431: NOT
12432: IFFALSE 12505
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12434: LD_ADDR_VAR 0 2
12438: PUSH
12439: LD_INT 21
12441: PPUSH
12442: LD_INT 22
12444: PUSH
12445: LD_EXP 23
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: LD_INT 25
12456: PUSH
12457: LD_INT 4
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PPUSH
12468: CALL_OW 70
12472: ST_TO_ADDR
// if not filter_you then
12473: LD_VAR 0 2
12477: NOT
12478: IFFALSE 12505
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12480: LD_ADDR_VAR 0 2
12484: PUSH
12485: LD_INT 21
12487: PPUSH
12488: LD_INT 22
12490: PUSH
12491: LD_EXP 23
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PPUSH
12500: CALL_OW 70
12504: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12505: LD_VAR 0 1
12509: PUSH
12510: LD_INT 0
12512: GREATER
12513: PUSH
12514: LD_VAR 0 2
12518: PUSH
12519: LD_INT 0
12521: GREATER
12522: AND
12523: IFFALSE 12914
// begin for un_rus in filter_rus do
12525: LD_ADDR_VAR 0 3
12529: PUSH
12530: LD_VAR 0 1
12534: PUSH
12535: FOR_IN
12536: IFFALSE 12912
// begin Wait ( 5 ) ;
12538: LD_INT 5
12540: PPUSH
12541: CALL_OW 67
// min := 99999 ;
12545: LD_ADDR_VAR 0 5
12549: PUSH
12550: LD_INT 99999
12552: ST_TO_ADDR
// cil := 0 ;
12553: LD_ADDR_VAR 0 6
12557: PUSH
12558: LD_INT 0
12560: ST_TO_ADDR
// for un_you in filter_you do
12561: LD_ADDR_VAR 0 4
12565: PUSH
12566: LD_VAR 0 2
12570: PUSH
12571: FOR_IN
12572: IFFALSE 12768
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12574: LD_VAR 0 4
12578: PPUSH
12579: CALL_OW 302
12583: PUSH
12584: LD_VAR 0 4
12588: PPUSH
12589: CALL_OW 256
12593: PUSH
12594: LD_VAR 0 5
12598: LESS
12599: AND
12600: PUSH
12601: LD_VAR 0 3
12605: PPUSH
12606: LD_VAR 0 4
12610: PPUSH
12611: CALL_OW 296
12615: PUSH
12616: LD_INT 2
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: LD_INT 4
12624: PUSH
12625: LD_INT 6
12627: PUSH
12628: LD_INT 5
12630: PUSH
12631: LD_INT 9
12633: PUSH
12634: LD_INT 0
12636: PUSH
12637: LD_INT 2
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: PUSH
12650: LD_VAR 0 3
12654: PPUSH
12655: CALL_OW 264
12659: PUSH
12660: LD_INT 41
12662: MINUS
12663: ARRAY
12664: GREATEREQUAL
12665: AND
12666: PUSH
12667: LD_VAR 0 3
12671: PPUSH
12672: LD_VAR 0 4
12676: PPUSH
12677: CALL_OW 296
12681: PUSH
12682: LD_INT 15
12684: PUSH
12685: LD_INT 16
12687: PUSH
12688: LD_INT 17
12690: PUSH
12691: LD_INT 22
12693: PUSH
12694: LD_INT 20
12696: PUSH
12697: LD_INT 28
12699: PUSH
12700: LD_INT 0
12702: PUSH
12703: LD_INT 51
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: PUSH
12716: LD_VAR 0 3
12720: PPUSH
12721: CALL_OW 264
12725: PUSH
12726: LD_INT 41
12728: MINUS
12729: ARRAY
12730: LESSEQUAL
12731: AND
12732: IFFALSE 12759
// begin min := GetLives ( un_you ) ;
12734: LD_ADDR_VAR 0 5
12738: PUSH
12739: LD_VAR 0 4
12743: PPUSH
12744: CALL_OW 256
12748: ST_TO_ADDR
// cil := un_you ;
12749: LD_ADDR_VAR 0 6
12753: PUSH
12754: LD_VAR 0 4
12758: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12759: LD_INT 5
12761: PPUSH
12762: CALL_OW 67
// end ;
12766: GO 12571
12768: POP
12769: POP
// if cil <> 0 then
12770: LD_VAR 0 6
12774: PUSH
12775: LD_INT 0
12777: NONEQUAL
12778: IFFALSE 12796
// ComAttackUnit ( un_rus , cil ) else
12780: LD_VAR 0 3
12784: PPUSH
12785: LD_VAR 0 6
12789: PPUSH
12790: CALL_OW 115
12794: GO 12910
// begin for un_you in filter_you do
12796: LD_ADDR_VAR 0 4
12800: PUSH
12801: LD_VAR 0 2
12805: PUSH
12806: FOR_IN
12807: IFFALSE 12894
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12809: LD_VAR 0 4
12813: PPUSH
12814: CALL_OW 266
12818: PUSH
12819: LD_INT 0
12821: PUSH
12822: LD_INT 1
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: IN
12829: IFFALSE 12843
// cil := un_you else
12831: LD_ADDR_VAR 0 6
12835: PUSH
12836: LD_VAR 0 4
12840: ST_TO_ADDR
12841: GO 12885
// if GetLives ( un_you ) < min then
12843: LD_VAR 0 4
12847: PPUSH
12848: CALL_OW 256
12852: PUSH
12853: LD_VAR 0 5
12857: LESS
12858: IFFALSE 12885
// begin min := GetLives ( un_you ) ;
12860: LD_ADDR_VAR 0 5
12864: PUSH
12865: LD_VAR 0 4
12869: PPUSH
12870: CALL_OW 256
12874: ST_TO_ADDR
// cil := un_you ;
12875: LD_ADDR_VAR 0 6
12879: PUSH
12880: LD_VAR 0 4
12884: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12885: LD_INT 5
12887: PPUSH
12888: CALL_OW 67
// end ;
12892: GO 12806
12894: POP
12895: POP
// ComAttackUnit ( un_rus , cil ) end ;
12896: LD_VAR 0 3
12900: PPUSH
12901: LD_VAR 0 6
12905: PPUSH
12906: CALL_OW 115
// end ;
12910: GO 12535
12912: POP
12913: POP
// end ; end ;
12914: PPOPN 6
12916: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12917: GO 12919
12919: DISABLE
12920: LD_INT 0
12922: PPUSH
12923: PPUSH
12924: PPUSH
12925: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12926: LD_INT 28
12928: PPUSH
12929: LD_EXP 23
12933: PPUSH
12934: CALL_OW 321
12938: PUSH
12939: LD_INT 2
12941: EQUAL
12942: NOT
12943: IFFALSE 12946
// enable ;
12945: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12946: LD_ADDR_VAR 0 1
12950: PUSH
12951: LD_INT 12
12953: PPUSH
12954: LD_INT 22
12956: PUSH
12957: LD_EXP 24
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 50
12968: PUSH
12969: EMPTY
12970: LIST
12971: PUSH
12972: LD_INT 34
12974: PUSH
12975: LD_INT 49
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: PPUSH
12987: CALL_OW 70
12991: ST_TO_ADDR
// if filter_rus > 0 then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_INT 0
12999: GREATER
13000: IFFALSE 13041
// for un_rus in filter_rus do
13002: LD_ADDR_VAR 0 3
13006: PUSH
13007: LD_VAR 0 1
13011: PUSH
13012: FOR_IN
13013: IFFALSE 13039
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13015: LD_VAR 0 3
13019: PPUSH
13020: LD_INT 122
13022: PPUSH
13023: LD_INT 27
13025: PPUSH
13026: CALL_OW 111
// Wait ( 5 ) ;
13030: LD_INT 5
13032: PPUSH
13033: CALL_OW 67
// end ;
13037: GO 13012
13039: POP
13040: POP
// end ;
13041: PPOPN 4
13043: END
// every 1 1$0 + 0 0$5.5 do
13044: GO 13046
13046: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13047: LD_INT 59
13049: PPUSH
13050: LD_EXP 24
13054: PPUSH
13055: CALL_OW 321
13059: PUSH
13060: LD_INT 2
13062: EQUAL
13063: NOT
13064: PUSH
13065: LD_OWVAR 1
13069: PUSH
13070: LD_EXP 54
13074: GREATEREQUAL
13075: AND
13076: IFFALSE 13093
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13078: LD_INT 59
13080: PPUSH
13081: LD_EXP 24
13085: PPUSH
13086: LD_INT 2
13088: PPUSH
13089: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13093: LD_INT 50
13095: PPUSH
13096: LD_EXP 24
13100: PPUSH
13101: CALL_OW 321
13105: PUSH
13106: LD_INT 2
13108: EQUAL
13109: NOT
13110: PUSH
13111: LD_OWVAR 1
13115: PUSH
13116: LD_EXP 55
13120: GREATEREQUAL
13121: AND
13122: IFFALSE 13139
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13124: LD_INT 50
13126: PPUSH
13127: LD_EXP 24
13131: PPUSH
13132: LD_INT 2
13134: PPUSH
13135: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13139: LD_INT 53
13141: PPUSH
13142: LD_EXP 24
13146: PPUSH
13147: CALL_OW 321
13151: PUSH
13152: LD_INT 2
13154: EQUAL
13155: NOT
13156: PUSH
13157: LD_OWVAR 1
13161: PUSH
13162: LD_EXP 56
13166: GREATEREQUAL
13167: AND
13168: IFFALSE 13185
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13170: LD_INT 53
13172: PPUSH
13173: LD_EXP 24
13177: PPUSH
13178: LD_INT 2
13180: PPUSH
13181: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13185: LD_INT 56
13187: PPUSH
13188: LD_EXP 24
13192: PPUSH
13193: CALL_OW 321
13197: PUSH
13198: LD_INT 2
13200: EQUAL
13201: NOT
13202: PUSH
13203: LD_OWVAR 1
13207: PUSH
13208: LD_EXP 57
13212: GREATEREQUAL
13213: AND
13214: IFFALSE 13231
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13216: LD_INT 56
13218: PPUSH
13219: LD_EXP 24
13223: PPUSH
13224: LD_INT 2
13226: PPUSH
13227: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13231: LD_INT 65
13233: PPUSH
13234: LD_EXP 24
13238: PPUSH
13239: CALL_OW 321
13243: PUSH
13244: LD_INT 2
13246: EQUAL
13247: NOT
13248: PUSH
13249: LD_OWVAR 1
13253: PUSH
13254: LD_EXP 58
13258: GREATEREQUAL
13259: AND
13260: IFFALSE 13277
// SetTech ( tech_ST3 , rus , state_researched ) ;
13262: LD_INT 65
13264: PPUSH
13265: LD_EXP 24
13269: PPUSH
13270: LD_INT 2
13272: PPUSH
13273: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13277: LD_INT 59
13279: PPUSH
13280: LD_EXP 24
13284: PPUSH
13285: CALL_OW 321
13289: PUSH
13290: LD_INT 2
13292: EQUAL
13293: PUSH
13294: LD_INT 50
13296: PPUSH
13297: LD_EXP 24
13301: PPUSH
13302: CALL_OW 321
13306: PUSH
13307: LD_INT 2
13309: EQUAL
13310: AND
13311: PUSH
13312: LD_INT 53
13314: PPUSH
13315: LD_EXP 24
13319: PPUSH
13320: CALL_OW 321
13324: PUSH
13325: LD_INT 2
13327: EQUAL
13328: AND
13329: PUSH
13330: LD_INT 56
13332: PPUSH
13333: LD_EXP 24
13337: PPUSH
13338: CALL_OW 321
13342: PUSH
13343: LD_INT 2
13345: EQUAL
13346: AND
13347: PUSH
13348: LD_INT 65
13350: PPUSH
13351: LD_EXP 24
13355: PPUSH
13356: CALL_OW 321
13360: PUSH
13361: LD_INT 2
13363: EQUAL
13364: AND
13365: NOT
13366: IFFALSE 13369
// enable ;
13368: ENABLE
// end ; end_of_file
13369: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13370: GO 13372
13372: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13373: LD_ADDR_EXP 63
13377: PUSH
13378: LD_INT 14
13380: PUSH
13381: LD_INT 18
13383: PUSH
13384: LD_INT 19
13386: PUSH
13387: LD_INT 20
13389: PUSH
13390: LD_INT 21
13392: PUSH
13393: LD_INT 22
13395: PUSH
13396: LD_INT 23
13398: PUSH
13399: EMPTY
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13408: LD_ADDR_EXP 64
13412: PUSH
13413: LD_INT 22
13415: PUSH
13416: LD_EXP 24
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: LD_INT 21
13427: PUSH
13428: LD_INT 3
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: LD_INT 14
13446: PUSH
13447: LD_INT 15
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: ADD
13454: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13455: LD_ADDR_EXP 65
13459: PUSH
13460: LD_INT 22
13462: PUSH
13463: LD_EXP 24
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: LD_INT 30
13474: PUSH
13475: LD_INT 1
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PPUSH
13486: CALL_OW 69
13490: PUSH
13491: LD_INT 1
13493: ARRAY
13494: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13495: LD_ADDR_EXP 66
13499: PUSH
13500: LD_INT 22
13502: PUSH
13503: LD_EXP 24
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 30
13514: PUSH
13515: LD_INT 8
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: PPUSH
13526: CALL_OW 69
13530: PUSH
13531: LD_INT 1
13533: ARRAY
13534: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13535: LD_ADDR_EXP 67
13539: PUSH
13540: LD_INT 22
13542: PUSH
13543: LD_EXP 24
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: LD_INT 30
13554: PUSH
13555: LD_INT 31
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PPUSH
13566: CALL_OW 69
13570: PUSH
13571: LD_INT 1
13573: ARRAY
13574: ST_TO_ADDR
// enable ( 401 ) ;
13575: LD_INT 401
13577: ENABLE_MARKED
// end ;
13578: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13579: GO 13581
13581: DISABLE
13582: LD_INT 0
13584: PPUSH
13585: PPUSH
13586: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13587: LD_EXP 62
13591: PPUSH
13592: CALL_OW 386
13596: NOT
13597: IFFALSE 13652
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13599: LD_ADDR_EXP 62
13603: PUSH
13604: LD_INT 100
13606: PPUSH
13607: LD_EXP 63
13611: PPUSH
13612: LD_EXP 64
13616: PUSH
13617: LD_EXP 63
13621: ADD
13622: PPUSH
13623: LD_INT 1
13625: PUSH
13626: LD_INT 23
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: PUSH
13633: LD_INT 10
13635: PUSH
13636: LD_INT 22
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 414
13651: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13652: LD_EXP 65
13656: PPUSH
13657: CALL_OW 300
13661: PUSH
13662: LD_EXP 66
13666: PPUSH
13667: CALL_OW 300
13671: OR
13672: PUSH
13673: LD_EXP 67
13677: PPUSH
13678: CALL_OW 300
13682: OR
13683: IFFALSE 13909
// begin for un in rus_mcrep_units do
13685: LD_ADDR_VAR 0 1
13689: PUSH
13690: LD_EXP 63
13694: PUSH
13695: FOR_IN
13696: IFFALSE 13907
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13698: LD_VAR 0 1
13702: PPUSH
13703: CALL_OW 388
13707: PUSH
13708: LD_INT 0
13710: EQUAL
13711: PUSH
13712: LD_VAR 0 1
13716: PPUSH
13717: CALL_OW 256
13721: PUSH
13722: LD_INT 1000
13724: EQUAL
13725: AND
13726: IFFALSE 13893
// case GetClass ( un ) of class_engineer :
13728: LD_VAR 0 1
13732: PPUSH
13733: CALL_OW 257
13737: PUSH
13738: LD_INT 2
13740: DOUBLE
13741: EQUAL
13742: IFTRUE 13746
13744: GO 13790
13746: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13747: LD_EXP 65
13751: PPUSH
13752: CALL_OW 300
13756: PUSH
13757: LD_EXP 65
13761: PPUSH
13762: CALL_OW 313
13766: PUSH
13767: LD_INT 6
13769: EQUAL
13770: NOT
13771: AND
13772: IFFALSE 13788
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13774: LD_VAR 0 1
13778: PPUSH
13779: LD_EXP 65
13783: PPUSH
13784: CALL_OW 120
13788: GO 13891
13790: LD_INT 4
13792: DOUBLE
13793: EQUAL
13794: IFTRUE 13798
13796: GO 13842
13798: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13799: LD_EXP 66
13803: PPUSH
13804: CALL_OW 300
13808: PUSH
13809: LD_EXP 66
13813: PPUSH
13814: CALL_OW 313
13818: PUSH
13819: LD_INT 6
13821: EQUAL
13822: NOT
13823: AND
13824: IFFALSE 13840
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13826: LD_VAR 0 1
13830: PPUSH
13831: LD_EXP 66
13835: PPUSH
13836: CALL_OW 120
13840: GO 13891
13842: LD_INT 1
13844: DOUBLE
13845: EQUAL
13846: IFTRUE 13850
13848: GO 13890
13850: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13851: LD_EXP 67
13855: PPUSH
13856: CALL_OW 300
13860: PUSH
13861: LD_EXP 67
13865: PPUSH
13866: CALL_OW 313
13870: NOT
13871: AND
13872: IFFALSE 13888
// ComEnterUnit ( un , rus_breastwork ) ; end else
13874: LD_VAR 0 1
13878: PPUSH
13879: LD_EXP 67
13883: PPUSH
13884: CALL_OW 120
13888: GO 13891
13890: POP
13891: GO 13905
// ComMoveToArea ( un , BluekherRepairArea ) ;
13893: LD_VAR 0 1
13897: PPUSH
13898: LD_INT 23
13900: PPUSH
13901: CALL_OW 113
13905: GO 13695
13907: POP
13908: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13909: LD_ADDR_VAR 0 3
13913: PUSH
13914: LD_INT 22
13916: PPUSH
13917: LD_INT 22
13919: PUSH
13920: LD_EXP 24
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: LD_INT 2
13931: PUSH
13932: LD_INT 25
13934: PUSH
13935: LD_INT 2
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: PUSH
13942: LD_INT 25
13944: PUSH
13945: LD_INT 4
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: LIST
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PPUSH
13961: CALL_OW 71
13965: ST_TO_ADDR
// if filter then
13966: LD_VAR 0 3
13970: IFFALSE 13987
// ComMoveXY ( filter , 48 , 88 ) ;
13972: LD_VAR 0 3
13976: PPUSH
13977: LD_INT 48
13979: PPUSH
13980: LD_INT 88
13982: PPUSH
13983: CALL_OW 111
// enable ;
13987: ENABLE
// end ; end_of_file
13988: PPOPN 3
13990: END
// every 0 0$2 + 0 0$0.1 do
13991: GO 13993
13993: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
13994: LD_INT 22
13996: PUSH
13997: LD_INT 7
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: PUSH
14004: LD_INT 2
14006: PUSH
14007: LD_INT 25
14009: PUSH
14010: LD_INT 12
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 25
14019: PUSH
14020: LD_INT 16
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: LD_INT 25
14029: PUSH
14030: LD_INT 15
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: LD_INT 25
14039: PUSH
14040: LD_INT 17
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: LIST
14053: PUSH
14054: EMPTY
14055: LIST
14056: LIST
14057: PPUSH
14058: CALL_OW 69
14062: PUSH
14063: LD_INT 22
14065: PUSH
14066: LD_INT 7
14068: PUSH
14069: EMPTY
14070: LIST
14071: LIST
14072: PUSH
14073: LD_INT 21
14075: PUSH
14076: LD_INT 1
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: PUSH
14083: LD_INT 3
14085: PUSH
14086: LD_INT 2
14088: PUSH
14089: LD_INT 25
14091: PUSH
14092: LD_INT 12
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 25
14101: PUSH
14102: LD_INT 16
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: PUSH
14109: LD_INT 25
14111: PUSH
14112: LD_INT 15
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PUSH
14119: LD_INT 25
14121: PUSH
14122: LD_INT 17
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: LIST
14144: PPUSH
14145: CALL_OW 69
14149: GREATER
14150: IFFALSE 14161
// begin SetAchievement ( ACH_POTA ) ;
14152: LD_STRING ACH_POTA
14154: PPUSH
14155: CALL_OW 543
// exit ;
14159: GO 14162
// end ; enable ;
14161: ENABLE
// end ; end_of_file
14162: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14163: LD_INT 0
14165: PPUSH
14166: PPUSH
// if not missionNumber then
14167: LD_VAR 0 2
14171: NOT
14172: IFFALSE 14176
// exit ;
14174: GO 14306
// achiv := false ;
14176: LD_ADDR_VAR 0 7
14180: PUSH
14181: LD_INT 0
14183: ST_TO_ADDR
// case campaignNumber of 1 :
14184: LD_VAR 0 1
14188: PUSH
14189: LD_INT 1
14191: DOUBLE
14192: EQUAL
14193: IFTRUE 14197
14195: GO 14208
14197: POP
// achiv := ACH_GOTA ; 2 :
14198: LD_ADDR_VAR 0 7
14202: PUSH
14203: LD_STRING ACH_GOTA
14205: ST_TO_ADDR
14206: GO 14258
14208: LD_INT 2
14210: DOUBLE
14211: EQUAL
14212: IFTRUE 14216
14214: GO 14219
14216: POP
// ; 3 :
14217: GO 14258
14219: LD_INT 3
14221: DOUBLE
14222: EQUAL
14223: IFTRUE 14227
14225: GO 14238
14227: POP
// achiv := ACH_MOTSU ; 4 :
14228: LD_ADDR_VAR 0 7
14232: PUSH
14233: LD_STRING ACH_MOTSU
14235: ST_TO_ADDR
14236: GO 14258
14238: LD_INT 4
14240: DOUBLE
14241: EQUAL
14242: IFTRUE 14246
14244: GO 14257
14246: POP
// achiv := ACH_LOP ; end ;
14247: LD_ADDR_VAR 0 7
14251: PUSH
14252: LD_STRING ACH_LOP
14254: ST_TO_ADDR
14255: GO 14258
14257: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14258: LD_OWVAR 67
14262: PUSH
14263: LD_INT 3
14265: EQUAL
14266: PUSH
14267: LD_VAR 0 7
14271: AND
14272: PUSH
14273: LD_VAR 0 3
14277: AND
14278: PUSH
14279: LD_VAR 0 4
14283: AND
14284: PUSH
14285: LD_VAR 0 5
14289: AND
14290: IFFALSE 14306
// SetAchievementEX ( achiv , missionNumber ) ;
14292: LD_VAR 0 7
14296: PPUSH
14297: LD_VAR 0 2
14301: PPUSH
14302: CALL_OW 564
// end ;
14306: LD_VAR 0 6
14310: RET
// export function SA_BehemothConstructed ; begin
14311: LD_INT 0
14313: PPUSH
// SetAchievement ( ACH_SMC ) ;
14314: LD_STRING ACH_SMC
14316: PPUSH
14317: CALL_OW 543
// end ;
14321: LD_VAR 0 1
14325: RET

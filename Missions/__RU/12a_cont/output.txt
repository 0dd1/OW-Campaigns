// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 4 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 4
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$40 , 0 0$30 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1400
 345: PUSH
 346: LD_INT 1050
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 1 1$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 2100
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
// uc_side = ally ;
 613: LD_ADDR_OWVAR 20
 617: PUSH
 618: LD_EXP 25
 622: ST_TO_ADDR
// uc_nation := nation_russian ;
 623: LD_ADDR_OWVAR 21
 627: PUSH
 628: LD_INT 3
 630: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 631: LD_ADDR_EXP 8
 635: PUSH
 636: LD_STRING Gossudarov
 638: PPUSH
 639: CALL 565 0 1
 643: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 644: LD_EXP 8
 648: PPUSH
 649: LD_INT 55
 651: PPUSH
 652: LD_INT 89
 654: PPUSH
 655: LD_INT 0
 657: PPUSH
 658: CALL_OW 48
// ComHold ( Gossudarov ) ;
 662: LD_EXP 8
 666: PPUSH
 667: CALL_OW 140
// uc_side = rus ;
 671: LD_ADDR_OWVAR 20
 675: PUSH
 676: LD_EXP 24
 680: ST_TO_ADDR
// uc_nation := nation_russian ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 3
 688: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 689: LD_ADDR_EXP 2
 693: PUSH
 694: LD_STRING Belkov
 696: PPUSH
 697: CALL 565 0 1
 701: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 702: LD_ADDR_EXP 3
 706: PUSH
 707: LD_STRING Gnyevko
 709: PPUSH
 710: CALL 565 0 1
 714: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 715: LD_ADDR_EXP 4
 719: PUSH
 720: LD_STRING Kirilenkova
 722: PPUSH
 723: CALL 565 0 1
 727: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_STRING Gleb
 735: PPUSH
 736: CALL 565 0 1
 740: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 741: LD_ADDR_EXP 6
 745: PUSH
 746: LD_STRING Petrosyan
 748: PPUSH
 749: CALL 565 0 1
 753: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 754: LD_ADDR_EXP 7
 758: PUSH
 759: LD_STRING Titov
 761: PPUSH
 762: CALL 565 0 1
 766: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_STRING Kovalyuk
 774: PPUSH
 775: CALL 565 0 1
 779: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 780: LD_ADDR_EXP 10
 784: PUSH
 785: LD_STRING Scholtze
 787: PPUSH
 788: CALL 565 0 1
 792: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 793: LD_ADDR_EXP 11
 797: PUSH
 798: LD_STRING Kuzmov
 800: PPUSH
 801: CALL 565 0 1
 805: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 806: LD_ADDR_EXP 12
 810: PUSH
 811: LD_STRING Karamazov
 813: PPUSH
 814: CALL 565 0 1
 818: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 819: LD_ADDR_EXP 13
 823: PUSH
 824: LD_STRING Petrovova
 826: PPUSH
 827: CALL 565 0 1
 831: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 832: LD_ADDR_EXP 14
 836: PUSH
 837: LD_STRING Lipschin
 839: PPUSH
 840: CALL 565 0 1
 844: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 845: LD_ADDR_EXP 15
 849: PUSH
 850: LD_STRING Dolgov
 852: PPUSH
 853: CALL 565 0 1
 857: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 858: LD_ADDR_EXP 16
 862: PUSH
 863: LD_STRING Xavier
 865: PPUSH
 866: CALL 565 0 1
 870: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 871: LD_ADDR_EXP 17
 875: PUSH
 876: LD_STRING Oblukov
 878: PPUSH
 879: CALL 565 0 1
 883: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 884: LD_ADDR_EXP 18
 888: PUSH
 889: LD_STRING Kozlov
 891: PPUSH
 892: CALL 565 0 1
 896: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 897: LD_ADDR_EXP 19
 901: PUSH
 902: LD_STRING Kapitsova
 904: PPUSH
 905: CALL 565 0 1
 909: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 910: LD_ADDR_EXP 39
 914: PUSH
 915: LD_EXP 3
 919: PUSH
 920: LD_EXP 2
 924: PUSH
 925: LD_EXP 4
 929: PUSH
 930: LD_EXP 5
 934: PUSH
 935: LD_EXP 6
 939: PUSH
 940: LD_EXP 7
 944: PUSH
 945: LD_EXP 9
 949: PUSH
 950: LD_EXP 10
 954: PUSH
 955: LD_EXP 11
 959: PUSH
 960: LD_EXP 12
 964: PUSH
 965: LD_EXP 13
 969: PUSH
 970: LD_EXP 14
 974: PUSH
 975: LD_EXP 15
 979: PUSH
 980: LD_EXP 16
 984: PUSH
 985: LD_EXP 17
 989: PUSH
 990: LD_EXP 18
 994: PUSH
 995: LD_EXP 19
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 0
1021: DIFF
1022: ST_TO_ADDR
// survivors3 = [ ] ;
1023: LD_ADDR_EXP 22
1027: PUSH
1028: EMPTY
1029: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1030: LD_STRING survivors3
1032: PPUSH
1033: CALL_OW 29
1037: IFFALSE 1052
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1039: LD_ADDR_EXP 22
1043: PUSH
1044: LD_STRING survivors3
1046: PPUSH
1047: CALL_OW 31
1051: ST_TO_ADDR
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1052: LD_ADDR_EXP 40
1056: PUSH
1057: LD_EXP 39
1061: PUSH
1062: LD_EXP 22
1066: ADD
1067: PPUSH
1068: LD_INT 25
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL_OW 72
1082: ST_TO_ADDR
// survivors3 = survivors3 diff scientists ;
1083: LD_ADDR_EXP 22
1087: PUSH
1088: LD_EXP 22
1092: PUSH
1093: LD_EXP 40
1097: DIFF
1098: ST_TO_ADDR
// if scientists > 5 then
1099: LD_EXP 40
1103: PUSH
1104: LD_INT 5
1106: GREATER
1107: IFFALSE 1153
// for i := 6 to scientists do
1109: LD_ADDR_LOC 2
1113: PUSH
1114: DOUBLE
1115: LD_INT 6
1117: DEC
1118: ST_TO_ADDR
1119: LD_EXP 40
1123: PUSH
1124: FOR_TO
1125: IFFALSE 1151
// scientists := scientists diff scientists [ i ] ;
1127: LD_ADDR_EXP 40
1131: PUSH
1132: LD_EXP 40
1136: PUSH
1137: LD_EXP 40
1141: PUSH
1142: LD_LOC 2
1146: ARRAY
1147: DIFF
1148: ST_TO_ADDR
1149: GO 1124
1151: POP
1152: POP
// if scientists < 5 then
1153: LD_EXP 40
1157: PUSH
1158: LD_INT 5
1160: LESS
1161: IFFALSE 1252
// for i := 1 to 5 - scientists do
1163: LD_ADDR_LOC 2
1167: PUSH
1168: DOUBLE
1169: LD_INT 1
1171: DEC
1172: ST_TO_ADDR
1173: LD_INT 5
1175: PUSH
1176: LD_EXP 40
1180: MINUS
1181: PUSH
1182: FOR_TO
1183: IFFALSE 1250
// begin uc_side = ally ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_EXP 25
1194: ST_TO_ADDR
// uc_nation := nation_russian ;
1195: LD_ADDR_OWVAR 21
1199: PUSH
1200: LD_INT 3
1202: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1203: LD_INT 0
1205: PPUSH
1206: LD_INT 4
1208: PPUSH
1209: LD_INT 5
1211: PPUSH
1212: LD_INT 7
1214: PPUSH
1215: CALL_OW 12
1219: PPUSH
1220: CALL_OW 380
// hc_name :=  ;
1224: LD_ADDR_OWVAR 26
1228: PUSH
1229: LD_STRING 
1231: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1232: LD_ADDR_EXP 40
1236: PUSH
1237: LD_EXP 40
1241: PUSH
1242: CALL_OW 44
1246: ADD
1247: ST_TO_ADDR
// end ;
1248: GO 1182
1250: POP
1251: POP
// for un in scientists do
1252: LD_ADDR_VAR 0 2
1256: PUSH
1257: LD_EXP 40
1261: PUSH
1262: FOR_IN
1263: IFFALSE 1281
// SetSide ( un , ally ) ;
1265: LD_VAR 0 2
1269: PPUSH
1270: LD_EXP 25
1274: PPUSH
1275: CALL_OW 235
1279: GO 1262
1281: POP
1282: POP
// possible := all_possible diff scientists ;
1283: LD_ADDR_EXP 38
1287: PUSH
1288: LD_EXP 39
1292: PUSH
1293: LD_EXP 40
1297: DIFF
1298: ST_TO_ADDR
// for un in scientists do
1299: LD_ADDR_VAR 0 2
1303: PUSH
1304: LD_EXP 40
1308: PUSH
1309: FOR_IN
1310: IFFALSE 1326
// PlaceHumanInUnit ( un , 2 ) ;
1312: LD_VAR 0 2
1316: PPUSH
1317: LD_INT 2
1319: PPUSH
1320: CALL_OW 52
1324: GO 1309
1326: POP
1327: POP
// new := [ ] ;
1328: LD_ADDR_EXP 36
1332: PUSH
1333: EMPTY
1334: ST_TO_ADDR
// if possible < 10 then
1335: LD_EXP 38
1339: PUSH
1340: LD_INT 10
1342: LESS
1343: IFFALSE 1426
// for i := 1 to 10 - possible do
1345: LD_ADDR_LOC 2
1349: PUSH
1350: DOUBLE
1351: LD_INT 1
1353: DEC
1354: ST_TO_ADDR
1355: LD_INT 10
1357: PUSH
1358: LD_EXP 38
1362: MINUS
1363: PUSH
1364: FOR_TO
1365: IFFALSE 1424
// begin uc_side = rus ;
1367: LD_ADDR_OWVAR 20
1371: PUSH
1372: LD_EXP 24
1376: ST_TO_ADDR
// uc_nation := nation_russian ;
1377: LD_ADDR_OWVAR 21
1381: PUSH
1382: LD_INT 3
1384: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1385: LD_INT 0
1387: PPUSH
1388: LD_INT 0
1390: PPUSH
1391: LD_INT 5
1393: PPUSH
1394: CALL_OW 380
// hc_name :=  ;
1398: LD_ADDR_OWVAR 26
1402: PUSH
1403: LD_STRING 
1405: ST_TO_ADDR
// new := new ^ CreateHuman ;
1406: LD_ADDR_EXP 36
1410: PUSH
1411: LD_EXP 36
1415: PUSH
1416: CALL_OW 44
1420: ADD
1421: ST_TO_ADDR
// end ;
1422: GO 1364
1424: POP
1425: POP
// uc_side = rus ;
1426: LD_ADDR_OWVAR 20
1430: PUSH
1431: LD_EXP 24
1435: ST_TO_ADDR
// uc_nation := nation_russian ;
1436: LD_ADDR_OWVAR 21
1440: PUSH
1441: LD_INT 3
1443: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1444: LD_ADDR_EXP 1
1448: PUSH
1449: LD_STRING Burlak
1451: PPUSH
1452: CALL 565 0 1
1456: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1457: LD_EXP 1
1461: PPUSH
1462: LD_INT 3
1464: PPUSH
1465: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1469: LD_ADDR_EXP 20
1473: PUSH
1474: LD_STRING Platonov
1476: PPUSH
1477: CALL_OW 25
1481: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1482: LD_INT 1
1484: PPUSH
1485: LD_INT 1
1487: PPUSH
1488: LD_INT 4
1490: PPUSH
1491: CALL_OW 380
// hc_name :=  ;
1495: LD_ADDR_OWVAR 26
1499: PUSH
1500: LD_STRING 
1502: ST_TO_ADDR
// RSoldier := CreateHuman ;
1503: LD_ADDR_EXP 21
1507: PUSH
1508: CALL_OW 44
1512: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1513: LD_ADDR_LOC 2
1517: PUSH
1518: DOUBLE
1519: LD_INT 1
1521: DEC
1522: ST_TO_ADDR
1523: LD_EXP 31
1527: PUSH
1528: LD_INT 3
1530: PUSH
1531: LD_EXP 30
1535: MUL
1536: PLUS
1537: PUSH
1538: FOR_TO
1539: IFFALSE 1631
// begin case Rand ( 1 , 2 ) of 1 :
1541: LD_INT 1
1543: PPUSH
1544: LD_INT 2
1546: PPUSH
1547: CALL_OW 12
1551: PUSH
1552: LD_INT 1
1554: DOUBLE
1555: EQUAL
1556: IFTRUE 1560
1558: GO 1578
1560: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1561: LD_INT 1
1563: PPUSH
1564: LD_INT 1
1566: PPUSH
1567: LD_EXP 32
1571: PPUSH
1572: CALL_OW 380
1576: GO 1605
1578: LD_INT 2
1580: DOUBLE
1581: EQUAL
1582: IFTRUE 1586
1584: GO 1604
1586: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 9
1592: PPUSH
1593: LD_EXP 32
1597: PPUSH
1598: CALL_OW 380
1602: GO 1605
1604: POP
// hc_name :=  ;
1605: LD_ADDR_OWVAR 26
1609: PUSH
1610: LD_STRING 
1612: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1613: LD_ADDR_EXP 29
1617: PUSH
1618: LD_EXP 29
1622: PUSH
1623: CALL_OW 44
1627: ADD
1628: ST_TO_ADDR
// end ;
1629: GO 1538
1631: POP
1632: POP
// end ;
1633: LD_VAR 0 1
1637: RET
// function select_people ; var units , un ; begin
1638: LD_INT 0
1640: PPUSH
1641: PPUSH
1642: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1643: LD_ADDR_EXP 41
1647: PUSH
1648: LD_STRING 
1650: PPUSH
1651: LD_INT 5
1653: PPUSH
1654: LD_INT 5
1656: PPUSH
1657: LD_INT -1
1659: PUSH
1660: LD_INT -4
1662: PUSH
1663: LD_INT -6
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_EXP 1
1675: ADD
1676: PUSH
1677: LD_INT -2
1679: PUSH
1680: LD_INT -4
1682: PUSH
1683: LD_INT -6
1685: PUSH
1686: EMPTY
1687: LIST
1688: LIST
1689: LIST
1690: ADD
1691: PUSH
1692: LD_EXP 20
1696: ADD
1697: PUSH
1698: LD_INT -2
1700: PUSH
1701: LD_INT -5
1703: PUSH
1704: LD_INT -3
1706: PUSH
1707: EMPTY
1708: LIST
1709: LIST
1710: LIST
1711: ADD
1712: PUSH
1713: LD_EXP 38
1717: ADD
1718: PUSH
1719: LD_EXP 22
1723: ADD
1724: PUSH
1725: LD_EXP 36
1729: ADD
1730: PPUSH
1731: LD_INT 1
1733: PUSH
1734: LD_INT 3
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: LD_INT 4
1742: PUSH
1743: LD_INT 9
1745: PUSH
1746: LD_INT 0
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: EMPTY
1753: LIST
1754: LIST
1755: LIST
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PPUSH
1764: CALL_OW 42
1768: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1769: LD_EXP 41
1773: PUSH
1774: LD_EXP 1
1778: DIFF
1779: PPUSH
1780: LD_EXP 27
1784: PPUSH
1785: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1789: LD_ADDR_VAR 0 3
1793: PUSH
1794: LD_EXP 41
1798: PUSH
1799: LD_EXP 1
1803: DIFF
1804: PUSH
1805: FOR_IN
1806: IFFALSE 1825
// PlaceUnitArea ( un , BaseArea , false ) ;
1808: LD_VAR 0 3
1812: PPUSH
1813: LD_INT 2
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 49
1823: GO 1805
1825: POP
1826: POP
// end ;
1827: LD_VAR 0 1
1831: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
1832: LD_INT 0
1834: PPUSH
1835: PPUSH
1836: PPUSH
1837: PPUSH
1838: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
1839: LD_ADDR_VAR 0 3
1843: PUSH
1844: LD_STRING EscapeVehicle_12a
1846: PPUSH
1847: LD_INT 1
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: LD_INT 0
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: PPUSH
1861: CALL_OW 30
1865: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
1866: LD_ADDR_LOC 1
1870: PUSH
1871: LD_VAR 0 3
1875: PUSH
1876: LD_INT 1
1878: ARRAY
1879: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_VAR 0 3
1889: PUSH
1890: LD_INT 2
1892: ARRAY
1893: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 3
1903: PUSH
1904: LD_INT 3
1906: ARRAY
1907: ST_TO_ADDR
// if MashaWanted then
1908: LD_LOC 1
1912: IFFALSE 2128
// begin veh := LoadVariable ( Masha , false ) ;
1914: LD_ADDR_VAR 0 2
1918: PUSH
1919: LD_STRING Masha
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 30
1929: ST_TO_ADDR
// if veh then
1930: LD_VAR 0 2
1934: IFFALSE 2050
// begin uc_side := rus ;
1936: LD_ADDR_OWVAR 20
1940: PUSH
1941: LD_EXP 24
1945: ST_TO_ADDR
// uc_nation := nation_russian ;
1946: LD_ADDR_OWVAR 21
1950: PUSH
1951: LD_INT 3
1953: ST_TO_ADDR
// uc_direction := 2 ;
1954: LD_ADDR_OWVAR 24
1958: PUSH
1959: LD_INT 2
1961: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
1962: LD_ADDR_OWVAR 37
1966: PUSH
1967: LD_VAR 0 2
1971: PUSH
1972: LD_INT 1
1974: ARRAY
1975: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
1976: LD_ADDR_OWVAR 39
1980: PUSH
1981: LD_VAR 0 2
1985: PUSH
1986: LD_INT 2
1988: ARRAY
1989: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
1990: LD_ADDR_OWVAR 38
1994: PUSH
1995: LD_VAR 0 2
1999: PUSH
2000: LD_INT 3
2002: ARRAY
2003: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2004: LD_ADDR_OWVAR 40
2008: PUSH
2009: LD_VAR 0 2
2013: PUSH
2014: LD_INT 4
2016: ARRAY
2017: ST_TO_ADDR
// RealMasha := true ;
2018: LD_ADDR_EXP 42
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// Masha := CreateVehicle ;
2026: LD_ADDR_EXP 43
2030: PUSH
2031: CALL_OW 45
2035: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
2036: LD_EXP 43
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL_OW 242
// end else
2048: GO 2126
// begin uc_side := rus ;
2050: LD_ADDR_OWVAR 20
2054: PUSH
2055: LD_EXP 24
2059: ST_TO_ADDR
// uc_nation := nation_russian ;
2060: LD_ADDR_OWVAR 21
2064: PUSH
2065: LD_INT 3
2067: ST_TO_ADDR
// uc_direction := 2 ;
2068: LD_ADDR_OWVAR 24
2072: PUSH
2073: LD_INT 2
2075: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2076: LD_ADDR_OWVAR 37
2080: PUSH
2081: LD_INT 22
2083: ST_TO_ADDR
// vc_engine := engine_siberite ;
2084: LD_ADDR_OWVAR 39
2088: PUSH
2089: LD_INT 3
2091: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2092: LD_ADDR_OWVAR 40
2096: PUSH
2097: LD_INT 43
2099: ST_TO_ADDR
// vc_control := control_manual ;
2100: LD_ADDR_OWVAR 38
2104: PUSH
2105: LD_INT 1
2107: ST_TO_ADDR
// RealMasha := false ;
2108: LD_ADDR_EXP 42
2112: PUSH
2113: LD_INT 0
2115: ST_TO_ADDR
// Masha := CreateVehicle ;
2116: LD_ADDR_EXP 43
2120: PUSH
2121: CALL_OW 45
2125: ST_TO_ADDR
// end ; end else
2126: GO 2208
// begin uc_side := rus ;
2128: LD_ADDR_OWVAR 20
2132: PUSH
2133: LD_EXP 24
2137: ST_TO_ADDR
// uc_nation := nation_russian ;
2138: LD_ADDR_OWVAR 21
2142: PUSH
2143: LD_INT 3
2145: ST_TO_ADDR
// uc_direction := 2 ;
2146: LD_ADDR_OWVAR 24
2150: PUSH
2151: LD_INT 2
2153: ST_TO_ADDR
// vc_chassis := Chassis ;
2154: LD_ADDR_OWVAR 37
2158: PUSH
2159: LD_VAR 0 4
2163: ST_TO_ADDR
// vc_engine := engine_siberite ;
2164: LD_ADDR_OWVAR 39
2168: PUSH
2169: LD_INT 3
2171: ST_TO_ADDR
// vc_weapon := Weapon ;
2172: LD_ADDR_OWVAR 40
2176: PUSH
2177: LD_VAR 0 5
2181: ST_TO_ADDR
// vc_control := control_manual ;
2182: LD_ADDR_OWVAR 38
2186: PUSH
2187: LD_INT 1
2189: ST_TO_ADDR
// RealMasha := false ;
2190: LD_ADDR_EXP 42
2194: PUSH
2195: LD_INT 0
2197: ST_TO_ADDR
// Masha := CreateVehicle ;
2198: LD_ADDR_EXP 43
2202: PUSH
2203: CALL_OW 45
2207: ST_TO_ADDR
// end ; if GetEngine ( Masha ) <> engine_siberite then
2208: LD_EXP 43
2212: PPUSH
2213: CALL_OW 262
2217: PUSH
2218: LD_INT 3
2220: NONEQUAL
2221: IFFALSE 2243
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2223: LD_EXP 43
2227: PPUSH
2228: LD_INT 70
2230: PPUSH
2231: LD_INT 95
2233: PPUSH
2234: CALL_OW 12
2238: PPUSH
2239: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2243: LD_EXP 43
2247: PPUSH
2248: LD_INT 47
2250: PPUSH
2251: LD_INT 87
2253: PPUSH
2254: LD_INT 0
2256: PPUSH
2257: CALL_OW 48
// end ;
2261: LD_VAR 0 1
2265: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2266: LD_INT 1
2268: PPUSH
2269: LD_STRING bluekher
2271: PPUSH
2272: CALL_OW 500
// IngameOn ;
2276: CALL_OW 8
// Randomize ;
2280: CALL_OW 10
// RandomizeAll ;
2284: CALL_OW 11
// InitBc ;
2288: CALL_OW 21
// InitHc ;
2292: CALL_OW 19
// InitUc ;
2296: CALL_OW 18
// InitVc ;
2300: CALL_OW 20
// disable ( 1 ) ;
2304: LD_INT 1
2306: DISABLE_MARKED
// disable ( 2 ) ;
2307: LD_INT 2
2309: DISABLE_MARKED
// disable ( 3 ) ;
2310: LD_INT 3
2312: DISABLE_MARKED
// disable ( 4 ) ;
2313: LD_INT 4
2315: DISABLE_MARKED
// disable ( 6 ) ;
2316: LD_INT 6
2318: DISABLE_MARKED
// disable ( 7 ) ;
2319: LD_INT 7
2321: DISABLE_MARKED
// disable ( 8 ) ;
2322: LD_INT 8
2324: DISABLE_MARKED
// disable ( 9 ) ;
2325: LD_INT 9
2327: DISABLE_MARKED
// disable ( 333 ) ;
2328: LD_INT 333
2330: DISABLE_MARKED
// disable ( 337 ) ;
2331: LD_INT 337
2333: DISABLE_MARKED
// disable ( 401 ) ;
2334: LD_INT 401
2336: DISABLE_MARKED
// read_parameters ;
2337: CALL 0 0 0
// set_difficulty ;
2341: CALL 257 0 0
// create_people ;
2345: CALL 609 0 0
// select_people ;
2349: CALL 1638 0 0
// place_masha ;
2353: CALL 1832 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2357: LD_INT 53
2359: PPUSH
2360: LD_INT 90
2362: PPUSH
2363: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2367: LD_EXP 1
2371: PPUSH
2372: LD_INT 51
2374: PPUSH
2375: LD_INT 88
2377: PPUSH
2378: LD_INT 0
2380: PPUSH
2381: CALL_OW 48
// ComHold ( Burlak ) ;
2385: LD_EXP 1
2389: PPUSH
2390: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2394: LD_EXP 21
2398: PPUSH
2399: LD_INT 54
2401: PPUSH
2402: LD_INT 90
2404: PPUSH
2405: LD_INT 0
2407: PPUSH
2408: CALL_OW 48
// ComHold ( RSoldier ) ;
2412: LD_EXP 21
2416: PPUSH
2417: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2421: LD_EXP 1
2425: PPUSH
2426: LD_EXP 21
2430: PPUSH
2431: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2435: LD_EXP 21
2439: PPUSH
2440: LD_EXP 1
2444: PPUSH
2445: CALL_OW 119
// D_Platonov ;
2449: CALL 5099 0 0
// IngameOff ;
2453: CALL_OW 9
// SaveForQuickRestart ;
2457: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2461: LD_STRING MRun
2463: PPUSH
2464: CALL_OW 337
// ChangeSideFog ( you , you ) ;
2468: LD_EXP 23
2472: PPUSH
2473: LD_EXP 23
2477: PPUSH
2478: CALL_OW 343
// SetSide ( Burlak , you ) ;
2482: LD_EXP 1
2486: PPUSH
2487: LD_EXP 23
2491: PPUSH
2492: CALL_OW 235
// SetSide ( Masha , you ) ;
2496: LD_EXP 43
2500: PPUSH
2501: LD_EXP 23
2505: PPUSH
2506: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2510: LD_INT 1
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: CALL_OW 12
2520: PUSH
2521: LD_INT 1
2523: DOUBLE
2524: EQUAL
2525: IFTRUE 2529
2527: GO 2587
2529: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2530: LD_ADDR_LOC 2
2534: PUSH
2535: DOUBLE
2536: LD_EXP 31
2540: PUSH
2541: LD_INT 1
2543: PLUS
2544: DEC
2545: ST_TO_ADDR
2546: LD_EXP 31
2550: PUSH
2551: LD_EXP 30
2555: PLUS
2556: PUSH
2557: FOR_TO
2558: IFFALSE 2583
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2560: LD_EXP 29
2564: PUSH
2565: LD_LOC 2
2569: ARRAY
2570: PPUSH
2571: LD_INT 4
2573: PPUSH
2574: LD_INT 0
2576: PPUSH
2577: CALL_OW 49
2581: GO 2557
2583: POP
2584: POP
// end ; 2 :
2585: GO 2654
2587: LD_INT 2
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2595
2593: GO 2653
2595: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2596: LD_ADDR_LOC 2
2600: PUSH
2601: DOUBLE
2602: LD_EXP 31
2606: PUSH
2607: LD_INT 1
2609: PLUS
2610: DEC
2611: ST_TO_ADDR
2612: LD_EXP 31
2616: PUSH
2617: LD_EXP 30
2621: PLUS
2622: PUSH
2623: FOR_TO
2624: IFFALSE 2649
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2626: LD_EXP 29
2630: PUSH
2631: LD_LOC 2
2635: ARRAY
2636: PPUSH
2637: LD_INT 5
2639: PPUSH
2640: LD_INT 0
2642: PPUSH
2643: CALL_OW 49
2647: GO 2623
2649: POP
2650: POP
// end ; end ;
2651: GO 2654
2653: POP
// case Rand ( 1 , 2 ) of 1 :
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: CALL_OW 12
2664: PUSH
2665: LD_INT 1
2667: DOUBLE
2668: EQUAL
2669: IFTRUE 2673
2671: GO 2741
2673: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2674: LD_ADDR_LOC 2
2678: PUSH
2679: DOUBLE
2680: LD_EXP 31
2684: PUSH
2685: LD_INT 1
2687: PLUS
2688: PUSH
2689: LD_EXP 30
2693: PLUS
2694: DEC
2695: ST_TO_ADDR
2696: LD_EXP 31
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: LD_EXP 30
2708: MUL
2709: PLUS
2710: PUSH
2711: FOR_TO
2712: IFFALSE 2737
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2714: LD_EXP 29
2718: PUSH
2719: LD_LOC 2
2723: ARRAY
2724: PPUSH
2725: LD_INT 8
2727: PPUSH
2728: LD_INT 0
2730: PPUSH
2731: CALL_OW 49
2735: GO 2711
2737: POP
2738: POP
// end ; 2 :
2739: GO 2818
2741: LD_INT 2
2743: DOUBLE
2744: EQUAL
2745: IFTRUE 2749
2747: GO 2817
2749: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2750: LD_ADDR_LOC 2
2754: PUSH
2755: DOUBLE
2756: LD_EXP 31
2760: PUSH
2761: LD_INT 1
2763: PLUS
2764: PUSH
2765: LD_EXP 30
2769: PLUS
2770: DEC
2771: ST_TO_ADDR
2772: LD_EXP 31
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: LD_EXP 30
2784: MUL
2785: PLUS
2786: PUSH
2787: FOR_TO
2788: IFFALSE 2813
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
2790: LD_EXP 29
2794: PUSH
2795: LD_LOC 2
2799: ARRAY
2800: PPUSH
2801: LD_INT 7
2803: PPUSH
2804: LD_INT 0
2806: PPUSH
2807: CALL_OW 49
2811: GO 2787
2813: POP
2814: POP
// end ; end ;
2815: GO 2818
2817: POP
// case Rand ( 1 , 2 ) of 1 :
2818: LD_INT 1
2820: PPUSH
2821: LD_INT 2
2823: PPUSH
2824: CALL_OW 12
2828: PUSH
2829: LD_INT 1
2831: DOUBLE
2832: EQUAL
2833: IFTRUE 2837
2835: GO 2909
2837: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
2838: LD_ADDR_LOC 2
2842: PUSH
2843: DOUBLE
2844: LD_EXP 31
2848: PUSH
2849: LD_INT 1
2851: PLUS
2852: PUSH
2853: LD_INT 2
2855: PUSH
2856: LD_EXP 30
2860: MUL
2861: PLUS
2862: DEC
2863: ST_TO_ADDR
2864: LD_EXP 31
2868: PUSH
2869: LD_INT 3
2871: PUSH
2872: LD_EXP 30
2876: MUL
2877: PLUS
2878: PUSH
2879: FOR_TO
2880: IFFALSE 2905
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
2882: LD_EXP 29
2886: PUSH
2887: LD_LOC 2
2891: ARRAY
2892: PPUSH
2893: LD_INT 6
2895: PPUSH
2896: LD_INT 0
2898: PPUSH
2899: CALL_OW 49
2903: GO 2879
2905: POP
2906: POP
// end ; 2 :
2907: GO 2990
2909: LD_INT 2
2911: DOUBLE
2912: EQUAL
2913: IFTRUE 2917
2915: GO 2989
2917: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
2918: LD_ADDR_LOC 2
2922: PUSH
2923: DOUBLE
2924: LD_EXP 31
2928: PUSH
2929: LD_INT 1
2931: PLUS
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: LD_EXP 30
2940: MUL
2941: PLUS
2942: DEC
2943: ST_TO_ADDR
2944: LD_EXP 31
2948: PUSH
2949: LD_INT 3
2951: PUSH
2952: LD_EXP 30
2956: MUL
2957: PLUS
2958: PUSH
2959: FOR_TO
2960: IFFALSE 2985
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
2962: LD_EXP 29
2966: PUSH
2967: LD_LOC 2
2971: ARRAY
2972: PPUSH
2973: LD_INT 16
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: CALL_OW 49
2983: GO 2959
2985: POP
2986: POP
// end ; end ;
2987: GO 2990
2989: POP
// ComMoveXY ( Masha , 40 , 69 ) ;
2990: LD_EXP 43
2994: PPUSH
2995: LD_INT 40
2997: PPUSH
2998: LD_INT 69
3000: PPUSH
3001: CALL_OW 111
// Wait ( 1 1$0 ) ;
3005: LD_INT 2100
3007: PPUSH
3008: CALL_OW 67
// for i := 1 to pursuers_base do
3012: LD_ADDR_LOC 2
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_EXP 31
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3097
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3030: LD_EXP 29
3034: PUSH
3035: LD_LOC 2
3039: ARRAY
3040: PPUSH
3041: LD_INT 9
3043: PPUSH
3044: LD_INT 0
3046: PPUSH
3047: CALL_OW 49
3051: NOT
3052: IFFALSE 3075
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3054: LD_EXP 29
3058: PUSH
3059: LD_LOC 2
3063: ARRAY
3064: PPUSH
3065: LD_INT 3
3067: PPUSH
3068: LD_INT 0
3070: PPUSH
3071: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3075: LD_EXP 29
3079: PUSH
3080: LD_LOC 2
3084: ARRAY
3085: PPUSH
3086: LD_EXP 1
3090: PPUSH
3091: CALL_OW 115
// end ;
3095: GO 3027
3097: POP
3098: POP
// Wait ( straz_start ) ;
3099: LD_EXP 35
3103: PPUSH
3104: CALL_OW 67
// enable ( 1 ) ;
3108: LD_INT 1
3110: ENABLE_MARKED
// enable ( 2 ) ;
3111: LD_INT 2
3113: ENABLE_MARKED
// end ;
3114: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
3123: PPUSH
3124: PPUSH
3125: PPUSH
3126: PPUSH
3127: PPUSH
3128: PPUSH
3129: PPUSH
3130: PPUSH
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
3137: PPUSH
3138: PPUSH
3139: PPUSH
3140: PPUSH
// gained_medals := [ ] ;
3141: LD_ADDR_OWVAR 61
3145: PUSH
3146: EMPTY
3147: ST_TO_ADDR
// missing_medals := [ ] ;
3148: LD_ADDR_OWVAR 62
3152: PUSH
3153: EMPTY
3154: ST_TO_ADDR
// reward_units := [ ] ;
3155: LD_ADDR_VAR 0 5
3159: PUSH
3160: EMPTY
3161: ST_TO_ADDR
// if scientists_dead = 0 then
3162: LD_EXP 49
3166: PUSH
3167: LD_INT 0
3169: EQUAL
3170: IFFALSE 3184
// AddMedal ( Science , 1 ) else
3172: LD_STRING Science
3174: PPUSH
3175: LD_INT 1
3177: PPUSH
3178: CALL_OW 101
3182: GO 3195
// AddMedal ( Science , - 1 ) ;
3184: LD_STRING Science
3186: PPUSH
3187: LD_INT 1
3189: NEG
3190: PPUSH
3191: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3195: LD_ADDR_VAR 0 4
3199: PUSH
3200: LD_INT 22
3202: PUSH
3203: LD_EXP 23
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 2
3214: PUSH
3215: LD_INT 30
3217: PUSH
3218: LD_INT 0
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 30
3227: PUSH
3228: LD_INT 1
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 69
3248: ST_TO_ADDR
// matros := 0 ;
3249: LD_ADDR_VAR 0 2
3253: PUSH
3254: LD_INT 0
3256: ST_TO_ADDR
// if 0 + filter <> 0 then
3257: LD_INT 0
3259: PUSH
3260: LD_VAR 0 4
3264: PLUS
3265: PUSH
3266: LD_INT 0
3268: NONEQUAL
3269: IFFALSE 3317
// for un in filter do
3271: LD_ADDR_VAR 0 3
3275: PUSH
3276: LD_VAR 0 4
3280: PUSH
3281: FOR_IN
3282: IFFALSE 3315
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3284: LD_ADDR_VAR 0 2
3288: PUSH
3289: LD_VAR 0 2
3293: PUSH
3294: LD_VAR 0 3
3298: PPUSH
3299: CALL_OW 274
3303: PPUSH
3304: LD_INT 1
3306: PPUSH
3307: CALL_OW 275
3311: PLUS
3312: ST_TO_ADDR
3313: GO 3281
3315: POP
3316: POP
// if matros > 100 then
3317: LD_VAR 0 2
3321: PUSH
3322: LD_INT 100
3324: GREATER
3325: IFFALSE 3339
// AddMedal ( Effectivity , 1 ) else
3327: LD_STRING Effectivity
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: CALL_OW 101
3337: GO 3350
// AddMedal ( Effectivity , - 1 ) ;
3339: LD_STRING Effectivity
3341: PPUSH
3342: LD_INT 1
3344: NEG
3345: PPUSH
3346: CALL_OW 101
// rus_building_destroyed := false ;
3350: LD_ADDR_VAR 0 7
3354: PUSH
3355: LD_INT 0
3357: ST_TO_ADDR
// for un in rus_mcrep_bui do
3358: LD_ADDR_VAR 0 3
3362: PUSH
3363: LD_EXP 64
3367: PUSH
3368: FOR_IN
3369: IFFALSE 3399
// if not IsLive ( un ) then
3371: LD_VAR 0 3
3375: PPUSH
3376: CALL_OW 300
3380: NOT
3381: IFFALSE 3397
// rus_building_destroyed := rus_building_destroyed + 1 ;
3383: LD_ADDR_VAR 0 7
3387: PUSH
3388: LD_VAR 0 7
3392: PUSH
3393: LD_INT 1
3395: PLUS
3396: ST_TO_ADDR
3397: GO 3368
3399: POP
3400: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3401: LD_EXP 53
3405: PUSH
3406: LD_INT 5
3408: GREATEREQUAL
3409: PUSH
3410: LD_VAR 0 7
3414: PUSH
3415: LD_INT 2
3417: GREATEREQUAL
3418: OR
3419: IFFALSE 3434
// AddMedal ( LittleLosses , - 1 ) else
3421: LD_STRING LittleLosses
3423: PPUSH
3424: LD_INT 1
3426: NEG
3427: PPUSH
3428: CALL_OW 101
3432: GO 3444
// AddMedal ( LittleLosses , 1 ) ;
3434: LD_STRING LittleLosses
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , killed_russians >= 5 or rus_building_destroyed >= 2 ) ;
3444: LD_INT 4
3446: PPUSH
3447: LD_INT 5
3449: PPUSH
3450: LD_EXP 49
3454: PUSH
3455: LD_INT 0
3457: EQUAL
3458: PPUSH
3459: LD_VAR 0 2
3463: PUSH
3464: LD_INT 100
3466: GREATER
3467: PPUSH
3468: LD_EXP 53
3472: PUSH
3473: LD_INT 5
3475: GREATEREQUAL
3476: PUSH
3477: LD_VAR 0 7
3481: PUSH
3482: LD_INT 2
3484: GREATEREQUAL
3485: OR
3486: PPUSH
3487: CALL 13996 0 5
// GiveMedals ( Main ) ;
3491: LD_STRING Main
3493: PPUSH
3494: CALL_OW 102
// for un in player_units do
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_EXP 41
3507: PUSH
3508: FOR_IN
3509: IFFALSE 3541
// if not IsDead ( un ) then
3511: LD_VAR 0 3
3515: PPUSH
3516: CALL_OW 301
3520: NOT
3521: IFFALSE 3539
// reward_units := reward_units ^ un ;
3523: LD_ADDR_VAR 0 5
3527: PUSH
3528: LD_VAR 0 5
3532: PUSH
3533: LD_VAR 0 3
3537: ADD
3538: ST_TO_ADDR
3539: GO 3508
3541: POP
3542: POP
// RewardPeople ( reward_units ) ;
3543: LD_VAR 0 5
3547: PPUSH
3548: CALL_OW 43
// SaveCharacters ( scientists diff ( possible ^ Gossudarov ) , scientists ) ;
3552: LD_EXP 40
3556: PUSH
3557: LD_EXP 38
3561: PUSH
3562: LD_EXP 8
3566: ADD
3567: DIFF
3568: PPUSH
3569: LD_STRING scientists
3571: PPUSH
3572: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3576: LD_ADDR_VAR 0 6
3580: PUSH
3581: LD_EXP 41
3585: PUSH
3586: LD_EXP 39
3590: PUSH
3591: LD_EXP 40
3595: ADD
3596: PUSH
3597: LD_EXP 1
3601: ADD
3602: PUSH
3603: LD_EXP 8
3607: ADD
3608: DIFF
3609: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3610: LD_VAR 0 6
3614: PPUSH
3615: LD_STRING survivors5
3617: PPUSH
3618: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3622: LD_EXP 1
3626: PPUSH
3627: LD_STRING Burlak
3629: PPUSH
3630: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3634: LD_EXP 2
3638: PPUSH
3639: LD_STRING Belkov
3641: PPUSH
3642: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3646: LD_EXP 3
3650: PPUSH
3651: LD_STRING Gnyevko
3653: PPUSH
3654: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3658: LD_EXP 4
3662: PPUSH
3663: LD_STRING Kirilenkova
3665: PPUSH
3666: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3670: LD_EXP 5
3674: PPUSH
3675: LD_STRING Gleb
3677: PPUSH
3678: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3682: LD_EXP 6
3686: PPUSH
3687: LD_STRING Petrosyan
3689: PPUSH
3690: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3694: LD_EXP 7
3698: PPUSH
3699: LD_STRING Titov
3701: PPUSH
3702: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3706: LD_EXP 8
3710: PPUSH
3711: LD_STRING Gossudarov
3713: PPUSH
3714: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3718: LD_EXP 9
3722: PPUSH
3723: LD_STRING Kovalyuk
3725: PPUSH
3726: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3730: LD_EXP 10
3734: PPUSH
3735: LD_STRING Scholtze
3737: PPUSH
3738: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3742: LD_EXP 11
3746: PPUSH
3747: LD_STRING Kuzmov
3749: PPUSH
3750: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3754: LD_EXP 12
3758: PPUSH
3759: LD_STRING Karamazov
3761: PPUSH
3762: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3766: LD_EXP 13
3770: PPUSH
3771: LD_STRING Petrovova
3773: PPUSH
3774: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3778: LD_EXP 14
3782: PPUSH
3783: LD_STRING Lipshchin
3785: PPUSH
3786: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3790: LD_EXP 15
3794: PPUSH
3795: LD_STRING Dolgov
3797: PPUSH
3798: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
3802: LD_EXP 16
3806: PPUSH
3807: LD_STRING Xavier
3809: PPUSH
3810: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
3814: LD_EXP 17
3818: PPUSH
3819: LD_STRING Oblukov
3821: PPUSH
3822: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
3826: LD_EXP 18
3830: PPUSH
3831: LD_STRING Kozlov
3833: PPUSH
3834: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
3838: LD_EXP 19
3842: PPUSH
3843: LD_STRING Kapitsova
3845: PPUSH
3846: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
3850: LD_EXP 42
3854: PUSH
3855: LD_EXP 52
3859: AND
3860: PUSH
3861: LD_LOC 1
3865: NOT
3866: OR
3867: IFFALSE 3876
// DeleteVariable ( Masha ) ;
3869: LD_STRING Masha
3871: PPUSH
3872: CALL_OW 41
// if Belkov in scientists then
3876: LD_EXP 2
3880: PUSH
3881: LD_EXP 40
3885: IN
3886: IFFALSE 3898
// belkov_side := 2 else
3888: LD_ADDR_VAR 0 8
3892: PUSH
3893: LD_INT 2
3895: ST_TO_ADDR
3896: GO 3928
// if Belkov in player_units then
3898: LD_EXP 2
3902: PUSH
3903: LD_EXP 41
3907: IN
3908: IFFALSE 3920
// belkov_side := 1 else
3910: LD_ADDR_VAR 0 8
3914: PUSH
3915: LD_INT 1
3917: ST_TO_ADDR
3918: GO 3928
// belkov_side := 0 ;
3920: LD_ADDR_VAR 0 8
3924: PUSH
3925: LD_INT 0
3927: ST_TO_ADDR
// if Gnyevko in scientists then
3928: LD_EXP 3
3932: PUSH
3933: LD_EXP 40
3937: IN
3938: IFFALSE 3950
// gnyevko_side := 2 else
3940: LD_ADDR_VAR 0 9
3944: PUSH
3945: LD_INT 2
3947: ST_TO_ADDR
3948: GO 3980
// if Gnyevko in player_units then
3950: LD_EXP 3
3954: PUSH
3955: LD_EXP 41
3959: IN
3960: IFFALSE 3972
// gnyevko_side := 1 else
3962: LD_ADDR_VAR 0 9
3966: PUSH
3967: LD_INT 1
3969: ST_TO_ADDR
3970: GO 3980
// gnyevko_side := 0 ;
3972: LD_ADDR_VAR 0 9
3976: PUSH
3977: LD_INT 0
3979: ST_TO_ADDR
// if Kirilenkova in scientists then
3980: LD_EXP 4
3984: PUSH
3985: LD_EXP 40
3989: IN
3990: IFFALSE 4002
// kiril_side := 2 else
3992: LD_ADDR_VAR 0 10
3996: PUSH
3997: LD_INT 2
3999: ST_TO_ADDR
4000: GO 4032
// if Kirilenkova in player_units then
4002: LD_EXP 4
4006: PUSH
4007: LD_EXP 41
4011: IN
4012: IFFALSE 4024
// kiril_side := 1 else
4014: LD_ADDR_VAR 0 10
4018: PUSH
4019: LD_INT 1
4021: ST_TO_ADDR
4022: GO 4032
// kiril_side := 0 ;
4024: LD_ADDR_VAR 0 10
4028: PUSH
4029: LD_INT 0
4031: ST_TO_ADDR
// if Gleb in scientists then
4032: LD_EXP 5
4036: PUSH
4037: LD_EXP 40
4041: IN
4042: IFFALSE 4054
// gleb_side := 2 else
4044: LD_ADDR_VAR 0 16
4048: PUSH
4049: LD_INT 2
4051: ST_TO_ADDR
4052: GO 4084
// if Gleb in player_units then
4054: LD_EXP 5
4058: PUSH
4059: LD_EXP 41
4063: IN
4064: IFFALSE 4076
// gleb_side := 1 else
4066: LD_ADDR_VAR 0 16
4070: PUSH
4071: LD_INT 1
4073: ST_TO_ADDR
4074: GO 4084
// gleb_side := 0 ;
4076: LD_ADDR_VAR 0 16
4080: PUSH
4081: LD_INT 0
4083: ST_TO_ADDR
// if Petrosyan in scientists then
4084: LD_EXP 6
4088: PUSH
4089: LD_EXP 40
4093: IN
4094: IFFALSE 4106
// petros_side := 2 else
4096: LD_ADDR_VAR 0 15
4100: PUSH
4101: LD_INT 2
4103: ST_TO_ADDR
4104: GO 4136
// if Petrosyan in player_units then
4106: LD_EXP 6
4110: PUSH
4111: LD_EXP 41
4115: IN
4116: IFFALSE 4128
// petros_side := 1 else
4118: LD_ADDR_VAR 0 15
4122: PUSH
4123: LD_INT 1
4125: ST_TO_ADDR
4126: GO 4136
// petros_side := 0 ;
4128: LD_ADDR_VAR 0 15
4132: PUSH
4133: LD_INT 0
4135: ST_TO_ADDR
// if Titov in scientists then
4136: LD_EXP 7
4140: PUSH
4141: LD_EXP 40
4145: IN
4146: IFFALSE 4158
// titov_side := 2 else
4148: LD_ADDR_VAR 0 19
4152: PUSH
4153: LD_INT 2
4155: ST_TO_ADDR
4156: GO 4188
// if Titov in player_units then
4158: LD_EXP 7
4162: PUSH
4163: LD_EXP 41
4167: IN
4168: IFFALSE 4180
// titov_side := 1 else
4170: LD_ADDR_VAR 0 19
4174: PUSH
4175: LD_INT 1
4177: ST_TO_ADDR
4178: GO 4188
// titov_side := 0 ;
4180: LD_ADDR_VAR 0 19
4184: PUSH
4185: LD_INT 0
4187: ST_TO_ADDR
// if Kovalyuk in scientists then
4188: LD_EXP 9
4192: PUSH
4193: LD_EXP 40
4197: IN
4198: IFFALSE 4210
// kovalyuk_side := 2 else
4200: LD_ADDR_VAR 0 11
4204: PUSH
4205: LD_INT 2
4207: ST_TO_ADDR
4208: GO 4240
// if Kovalyuk in player_units then
4210: LD_EXP 9
4214: PUSH
4215: LD_EXP 41
4219: IN
4220: IFFALSE 4232
// kovalyuk_side := 1 else
4222: LD_ADDR_VAR 0 11
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
4230: GO 4240
// kovalyuk_side := 0 ;
4232: LD_ADDR_VAR 0 11
4236: PUSH
4237: LD_INT 0
4239: ST_TO_ADDR
// if Scholtze in scientists then
4240: LD_EXP 10
4244: PUSH
4245: LD_EXP 40
4249: IN
4250: IFFALSE 4262
// scholtze_side := 2 else
4252: LD_ADDR_VAR 0 12
4256: PUSH
4257: LD_INT 2
4259: ST_TO_ADDR
4260: GO 4292
// if Scholtze in player_units then
4262: LD_EXP 10
4266: PUSH
4267: LD_EXP 41
4271: IN
4272: IFFALSE 4284
// scholtze_side := 1 else
4274: LD_ADDR_VAR 0 12
4278: PUSH
4279: LD_INT 1
4281: ST_TO_ADDR
4282: GO 4292
// scholtze_side := 0 ;
4284: LD_ADDR_VAR 0 12
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// if Kuzmov in scientists then
4292: LD_EXP 11
4296: PUSH
4297: LD_EXP 40
4301: IN
4302: IFFALSE 4314
// kuzmov_side := 2 else
4304: LD_ADDR_VAR 0 13
4308: PUSH
4309: LD_INT 2
4311: ST_TO_ADDR
4312: GO 4344
// if Kuzmov in player_units then
4314: LD_EXP 11
4318: PUSH
4319: LD_EXP 41
4323: IN
4324: IFFALSE 4336
// kuzmov_side := 1 else
4326: LD_ADDR_VAR 0 13
4330: PUSH
4331: LD_INT 1
4333: ST_TO_ADDR
4334: GO 4344
// kuzmov_side := 0 ;
4336: LD_ADDR_VAR 0 13
4340: PUSH
4341: LD_INT 0
4343: ST_TO_ADDR
// if Karamazov in scientists then
4344: LD_EXP 12
4348: PUSH
4349: LD_EXP 40
4353: IN
4354: IFFALSE 4366
// karam_side := 2 else
4356: LD_ADDR_VAR 0 14
4360: PUSH
4361: LD_INT 2
4363: ST_TO_ADDR
4364: GO 4396
// if Karamazov in player_units then
4366: LD_EXP 12
4370: PUSH
4371: LD_EXP 41
4375: IN
4376: IFFALSE 4388
// karam_side := 1 else
4378: LD_ADDR_VAR 0 14
4382: PUSH
4383: LD_INT 1
4385: ST_TO_ADDR
4386: GO 4396
// karam_side := 0 ;
4388: LD_ADDR_VAR 0 14
4392: PUSH
4393: LD_INT 0
4395: ST_TO_ADDR
// if Petrovova in scientists then
4396: LD_EXP 13
4400: PUSH
4401: LD_EXP 40
4405: IN
4406: IFFALSE 4418
// petrov_side := 2 else
4408: LD_ADDR_VAR 0 17
4412: PUSH
4413: LD_INT 2
4415: ST_TO_ADDR
4416: GO 4448
// if Petrovova in player_units then
4418: LD_EXP 13
4422: PUSH
4423: LD_EXP 41
4427: IN
4428: IFFALSE 4440
// petrov_side := 1 else
4430: LD_ADDR_VAR 0 17
4434: PUSH
4435: LD_INT 1
4437: ST_TO_ADDR
4438: GO 4448
// petrov_side := 0 ;
4440: LD_ADDR_VAR 0 17
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// if Lipshchin in scientists then
4448: LD_EXP 14
4452: PUSH
4453: LD_EXP 40
4457: IN
4458: IFFALSE 4470
// lipshchin_side := 2 else
4460: LD_ADDR_VAR 0 18
4464: PUSH
4465: LD_INT 2
4467: ST_TO_ADDR
4468: GO 4500
// if Lipshchin in player_units then
4470: LD_EXP 14
4474: PUSH
4475: LD_EXP 41
4479: IN
4480: IFFALSE 4492
// lipshchin_side := 1 else
4482: LD_ADDR_VAR 0 18
4486: PUSH
4487: LD_INT 1
4489: ST_TO_ADDR
4490: GO 4500
// lipshchin_side := 0 ;
4492: LD_ADDR_VAR 0 18
4496: PUSH
4497: LD_INT 0
4499: ST_TO_ADDR
// if Dolgov in scientists then
4500: LD_EXP 15
4504: PUSH
4505: LD_EXP 40
4509: IN
4510: IFFALSE 4522
// dolgov_side := 2 else
4512: LD_ADDR_VAR 0 20
4516: PUSH
4517: LD_INT 2
4519: ST_TO_ADDR
4520: GO 4552
// if Dolgov in player_units then
4522: LD_EXP 15
4526: PUSH
4527: LD_EXP 41
4531: IN
4532: IFFALSE 4544
// dolgov_side := 1 else
4534: LD_ADDR_VAR 0 20
4538: PUSH
4539: LD_INT 1
4541: ST_TO_ADDR
4542: GO 4552
// dolgov_side := 0 ;
4544: LD_ADDR_VAR 0 20
4548: PUSH
4549: LD_INT 0
4551: ST_TO_ADDR
// if Xavier in scientists then
4552: LD_EXP 16
4556: PUSH
4557: LD_EXP 40
4561: IN
4562: IFFALSE 4574
// xavier_side := 2 else
4564: LD_ADDR_VAR 0 21
4568: PUSH
4569: LD_INT 2
4571: ST_TO_ADDR
4572: GO 4604
// if Xavier in player_units then
4574: LD_EXP 16
4578: PUSH
4579: LD_EXP 41
4583: IN
4584: IFFALSE 4596
// xavier_side := 1 else
4586: LD_ADDR_VAR 0 21
4590: PUSH
4591: LD_INT 1
4593: ST_TO_ADDR
4594: GO 4604
// xavier_side := 0 ;
4596: LD_ADDR_VAR 0 21
4600: PUSH
4601: LD_INT 0
4603: ST_TO_ADDR
// if Oblukov in scientists then
4604: LD_EXP 17
4608: PUSH
4609: LD_EXP 40
4613: IN
4614: IFFALSE 4626
// oblukov_side := 2 else
4616: LD_ADDR_VAR 0 22
4620: PUSH
4621: LD_INT 2
4623: ST_TO_ADDR
4624: GO 4656
// if Oblukov in player_units then
4626: LD_EXP 17
4630: PUSH
4631: LD_EXP 41
4635: IN
4636: IFFALSE 4648
// oblukov_side := 1 else
4638: LD_ADDR_VAR 0 22
4642: PUSH
4643: LD_INT 1
4645: ST_TO_ADDR
4646: GO 4656
// oblukov_side := 0 ;
4648: LD_ADDR_VAR 0 22
4652: PUSH
4653: LD_INT 0
4655: ST_TO_ADDR
// if Kozlov in scientists then
4656: LD_EXP 18
4660: PUSH
4661: LD_EXP 40
4665: IN
4666: IFFALSE 4678
// kozlov_side := 2 else
4668: LD_ADDR_VAR 0 23
4672: PUSH
4673: LD_INT 2
4675: ST_TO_ADDR
4676: GO 4708
// if Kozlov in player_units then
4678: LD_EXP 18
4682: PUSH
4683: LD_EXP 41
4687: IN
4688: IFFALSE 4700
// kozlov_side := 1 else
4690: LD_ADDR_VAR 0 23
4694: PUSH
4695: LD_INT 1
4697: ST_TO_ADDR
4698: GO 4708
// kozlov_side := 0 ;
4700: LD_ADDR_VAR 0 23
4704: PUSH
4705: LD_INT 0
4707: ST_TO_ADDR
// if Kapitsova in scientists then
4708: LD_EXP 19
4712: PUSH
4713: LD_EXP 40
4717: IN
4718: IFFALSE 4730
// kapitsova_side := 2 else
4720: LD_ADDR_VAR 0 24
4724: PUSH
4725: LD_INT 2
4727: ST_TO_ADDR
4728: GO 4760
// if Kapitsova in player_units then
4730: LD_EXP 19
4734: PUSH
4735: LD_EXP 41
4739: IN
4740: IFFALSE 4752
// kapitsova_side := 1 else
4742: LD_ADDR_VAR 0 24
4746: PUSH
4747: LD_INT 1
4749: ST_TO_ADDR
4750: GO 4760
// kapitsova_side := 0 ;
4752: LD_ADDR_VAR 0 24
4756: PUSH
4757: LD_INT 0
4759: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4760: LD_VAR 0 8
4764: PPUSH
4765: LD_STRING belkov_side
4767: PPUSH
4768: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4772: LD_VAR 0 9
4776: PPUSH
4777: LD_STRING gnyevko_side
4779: PPUSH
4780: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4784: LD_VAR 0 10
4788: PPUSH
4789: LD_STRING kiril_side
4791: PPUSH
4792: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4796: LD_VAR 0 16
4800: PPUSH
4801: LD_STRING gleb_side
4803: PPUSH
4804: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
4808: LD_VAR 0 15
4812: PPUSH
4813: LD_STRING petros_side
4815: PPUSH
4816: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
4820: LD_VAR 0 19
4824: PPUSH
4825: LD_STRING titov_side
4827: PPUSH
4828: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
4832: LD_VAR 0 11
4836: PPUSH
4837: LD_STRING kovalyuk_side
4839: PPUSH
4840: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
4844: LD_VAR 0 12
4848: PPUSH
4849: LD_STRING scholtze_side
4851: PPUSH
4852: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
4856: LD_VAR 0 13
4860: PPUSH
4861: LD_STRING kuzmov_side
4863: PPUSH
4864: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
4868: LD_VAR 0 14
4872: PPUSH
4873: LD_STRING karam_side
4875: PPUSH
4876: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
4880: LD_VAR 0 17
4884: PPUSH
4885: LD_STRING petrov_side
4887: PPUSH
4888: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
4892: LD_VAR 0 18
4896: PPUSH
4897: LD_STRING lipshchin_side
4899: PPUSH
4900: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
4904: LD_VAR 0 20
4908: PPUSH
4909: LD_STRING dolgov_side
4911: PPUSH
4912: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
4916: LD_VAR 0 21
4920: PPUSH
4921: LD_STRING xavier_side
4923: PPUSH
4924: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
4928: LD_VAR 0 22
4932: PPUSH
4933: LD_STRING oblukov_side
4935: PPUSH
4936: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
4940: LD_VAR 0 23
4944: PPUSH
4945: LD_STRING kozlov_side
4947: PPUSH
4948: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
4952: LD_VAR 0 24
4956: PPUSH
4957: LD_STRING kapitsova_side
4959: PPUSH
4960: CALL_OW 39
// YouWin ;
4964: CALL_OW 103
// exit ;
4968: GO 4970
// end ; end_of_file
4970: LD_VAR 0 1
4974: RET
// export function D_Start ; begin
4975: LD_INT 0
4977: PPUSH
// DisableExclamations ;
4978: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
4982: LD_EXP 8
4986: PPUSH
4987: LD_STRING DStart-Gos-1
4989: PPUSH
4990: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
4994: LD_EXP 1
4998: PPUSH
4999: LD_STRING DStart-Bur-1
5001: PPUSH
5002: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5006: LD_EXP 8
5010: PPUSH
5011: LD_STRING DStart-Gos-2
5013: PPUSH
5014: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5018: LD_EXP 1
5022: PPUSH
5023: LD_STRING DStart-Bur-2
5025: PPUSH
5026: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5030: LD_EXP 8
5034: PPUSH
5035: LD_STRING DStart-Gos-3
5037: PPUSH
5038: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5042: LD_EXP 1
5046: PPUSH
5047: LD_STRING DStart-Bur-3
5049: PPUSH
5050: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5054: LD_EXP 8
5058: PPUSH
5059: LD_STRING DStart-Gos-4
5061: PPUSH
5062: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5066: LD_EXP 1
5070: PPUSH
5071: LD_STRING DStart-Bur-4
5073: PPUSH
5074: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5078: LD_EXP 8
5082: PPUSH
5083: LD_STRING DStart-Gos-5
5085: PPUSH
5086: CALL_OW 88
// EnableExclamations ;
5090: CALL_OW 473
// end ;
5094: LD_VAR 0 1
5098: RET
// export function D_Platonov ; begin
5099: LD_INT 0
5101: PPUSH
// DisableExclamations ;
5102: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5106: LD_EXP 21
5110: PPUSH
5111: LD_STRING DPlatonov-Rsol1-1
5113: PPUSH
5114: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5118: LD_EXP 1
5122: PPUSH
5123: LD_STRING DPlatonov-Bur-1
5125: PPUSH
5126: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5130: LD_EXP 21
5134: PPUSH
5135: LD_STRING DPlatonov-Rsol1-2
5137: PPUSH
5138: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5142: LD_EXP 1
5146: PPUSH
5147: LD_STRING DPlatonov-Bur-2
5149: PPUSH
5150: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5154: LD_EXP 1
5158: PPUSH
5159: LD_EXP 43
5163: PPUSH
5164: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5168: LD_EXP 21
5172: PPUSH
5173: LD_STRING DPlatonov-Rsol1-3
5175: PPUSH
5176: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5180: LD_INT 7
5182: PPUSH
5183: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5187: LD_EXP 43
5191: PPUSH
5192: CALL_OW 311
5196: PUSH
5197: LD_EXP 1
5201: EQUAL
5202: IFFALSE 5180
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5204: LD_EXP 1
5208: PPUSH
5209: LD_STRING DPlatonov-Bur-3
5211: PPUSH
5212: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5216: LD_EXP 1
5220: PPUSH
5221: LD_EXP 21
5225: PPUSH
5226: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5230: LD_INT 7
5232: PPUSH
5233: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5237: LD_EXP 43
5241: PPUSH
5242: CALL_OW 320
5246: PUSH
5247: LD_EXP 21
5251: EQUAL
5252: IFFALSE 5230
// Wait ( 0 0$0.5 ) ;
5254: LD_INT 18
5256: PPUSH
5257: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5261: LD_EXP 21
5265: PPUSH
5266: LD_STRING DPlatonov-Rsol1-4
5268: PPUSH
5269: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5273: LD_EXP 21
5277: PPUSH
5278: LD_EXP 43
5282: PPUSH
5283: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5287: LD_EXP 1
5291: PPUSH
5292: LD_EXP 21
5296: PPUSH
5297: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5301: LD_EXP 20
5305: PPUSH
5306: LD_STRING DPlatonov-Pla-4
5308: PPUSH
5309: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5313: LD_EXP 20
5317: PPUSH
5318: LD_STRING DPlatonov-Pla-4a
5320: PPUSH
5321: CALL_OW 88
// EnableExclamations ;
5325: CALL_OW 473
// end ;
5329: LD_VAR 0 1
5333: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5334: LD_INT 0
5336: PPUSH
5337: PPUSH
5338: PPUSH
5339: PPUSH
// DisableExclamations ;
5340: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5344: LD_EXP 2
5348: PPUSH
5349: CALL_OW 302
5353: PUSH
5354: LD_EXP 2
5358: PPUSH
5359: CALL_OW 255
5363: PUSH
5364: LD_EXP 23
5368: EQUAL
5369: AND
5370: IFFALSE 5384
// Say ( Belkov , DGosStart-Bel-1 ) ;
5372: LD_EXP 2
5376: PPUSH
5377: LD_STRING DGosStart-Bel-1
5379: PPUSH
5380: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5384: LD_EXP 3
5388: PPUSH
5389: CALL_OW 302
5393: PUSH
5394: LD_EXP 3
5398: PPUSH
5399: CALL_OW 255
5403: PUSH
5404: LD_EXP 23
5408: EQUAL
5409: AND
5410: IFFALSE 5424
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5412: LD_EXP 3
5416: PPUSH
5417: LD_STRING DGosStart-Gny-1
5419: PPUSH
5420: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5424: LD_EXP 5
5428: PPUSH
5429: CALL_OW 302
5433: PUSH
5434: LD_EXP 5
5438: PPUSH
5439: CALL_OW 255
5443: PUSH
5444: LD_EXP 23
5448: EQUAL
5449: AND
5450: IFFALSE 5464
// Say ( Gleb , DGosStart-Glb-1 ) ;
5452: LD_EXP 5
5456: PPUSH
5457: LD_STRING DGosStart-Glb-1
5459: PPUSH
5460: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5464: LD_EXP 6
5468: PPUSH
5469: CALL_OW 302
5473: PUSH
5474: LD_EXP 6
5478: PPUSH
5479: CALL_OW 255
5483: PUSH
5484: LD_EXP 23
5488: EQUAL
5489: AND
5490: IFFALSE 5504
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5492: LD_EXP 6
5496: PPUSH
5497: LD_STRING DGosStart-Pty-1
5499: PPUSH
5500: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5504: LD_EXP 7
5508: PPUSH
5509: CALL_OW 302
5513: PUSH
5514: LD_EXP 7
5518: PPUSH
5519: CALL_OW 255
5523: PUSH
5524: LD_EXP 23
5528: EQUAL
5529: AND
5530: IFFALSE 5544
// Say ( Titov , DGosStart-Tit-1 ) ;
5532: LD_EXP 7
5536: PPUSH
5537: LD_STRING DGosStart-Tit-1
5539: PPUSH
5540: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5544: LD_EXP 4
5548: PPUSH
5549: CALL_OW 302
5553: PUSH
5554: LD_EXP 4
5558: PPUSH
5559: CALL_OW 255
5563: PUSH
5564: LD_EXP 23
5568: EQUAL
5569: AND
5570: IFFALSE 5584
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5572: LD_EXP 4
5576: PPUSH
5577: LD_STRING DGosStart-Kir-1
5579: PPUSH
5580: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5584: LD_EXP 2
5588: PPUSH
5589: CALL_OW 302
5593: PUSH
5594: LD_EXP 2
5598: PPUSH
5599: CALL_OW 255
5603: PUSH
5604: LD_EXP 23
5608: EQUAL
5609: AND
5610: PUSH
5611: LD_EXP 3
5615: PPUSH
5616: CALL_OW 302
5620: PUSH
5621: LD_EXP 3
5625: PPUSH
5626: CALL_OW 255
5630: PUSH
5631: LD_EXP 23
5635: EQUAL
5636: AND
5637: OR
5638: PUSH
5639: LD_EXP 5
5643: PPUSH
5644: CALL_OW 302
5648: PUSH
5649: LD_EXP 5
5653: PPUSH
5654: CALL_OW 255
5658: PUSH
5659: LD_EXP 23
5663: EQUAL
5664: AND
5665: OR
5666: PUSH
5667: LD_EXP 6
5671: PPUSH
5672: CALL_OW 302
5676: PUSH
5677: LD_EXP 6
5681: PPUSH
5682: CALL_OW 255
5686: PUSH
5687: LD_EXP 23
5691: EQUAL
5692: AND
5693: OR
5694: PUSH
5695: LD_EXP 7
5699: PPUSH
5700: CALL_OW 302
5704: PUSH
5705: LD_EXP 7
5709: PPUSH
5710: CALL_OW 255
5714: PUSH
5715: LD_EXP 23
5719: EQUAL
5720: AND
5721: OR
5722: PUSH
5723: LD_EXP 4
5727: PPUSH
5728: CALL_OW 302
5732: PUSH
5733: LD_EXP 4
5737: PPUSH
5738: CALL_OW 255
5742: PUSH
5743: LD_EXP 23
5747: EQUAL
5748: AND
5749: OR
5750: NOT
5751: IFFALSE 6115
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5753: LD_ADDR_VAR 0 4
5757: PUSH
5758: LD_INT 22
5760: PUSH
5761: LD_EXP 23
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 26
5772: PUSH
5773: LD_INT 1
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 50
5782: PUSH
5783: EMPTY
5784: LIST
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: LD_INT 23
5791: PUSH
5792: LD_INT 0
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL_OW 69
5813: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
5814: LD_ADDR_VAR 0 4
5818: PUSH
5819: LD_VAR 0 4
5823: PUSH
5824: LD_EXP 1
5828: DIFF
5829: ST_TO_ADDR
// if 0 + filter_all > 0 then
5830: LD_INT 0
5832: PUSH
5833: LD_VAR 0 4
5837: PLUS
5838: PUSH
5839: LD_INT 0
5841: GREATER
5842: IFFALSE 5943
// begin filter := [ ] ;
5844: LD_ADDR_VAR 0 3
5848: PUSH
5849: EMPTY
5850: ST_TO_ADDR
// for un in filter_all do
5851: LD_ADDR_VAR 0 2
5855: PUSH
5856: LD_VAR 0 4
5860: PUSH
5861: FOR_IN
5862: IFFALSE 5895
// if not ( un in all_possible ) then
5864: LD_VAR 0 2
5868: PUSH
5869: LD_EXP 39
5873: IN
5874: NOT
5875: IFFALSE 5893
// filter := filter union un ;
5877: LD_ADDR_VAR 0 3
5881: PUSH
5882: LD_VAR 0 3
5886: PUSH
5887: LD_VAR 0 2
5891: UNION
5892: ST_TO_ADDR
5893: GO 5861
5895: POP
5896: POP
// if filter > 0 then
5897: LD_VAR 0 3
5901: PUSH
5902: LD_INT 0
5904: GREATER
5905: IFFALSE 5925
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
5907: LD_VAR 0 3
5911: PUSH
5912: LD_INT 1
5914: ARRAY
5915: PPUSH
5916: LD_STRING DGosStart-Sol1-1
5918: PPUSH
5919: CALL_OW 88
5923: GO 5941
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
5925: LD_VAR 0 4
5929: PUSH
5930: LD_INT 1
5932: ARRAY
5933: PPUSH
5934: LD_STRING DGosStart-Sol1-1
5936: PPUSH
5937: CALL_OW 88
// end else
5941: GO 6115
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5943: LD_ADDR_VAR 0 4
5947: PUSH
5948: LD_INT 22
5950: PUSH
5951: LD_EXP 23
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PUSH
5960: LD_INT 26
5962: PUSH
5963: LD_INT 2
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: PUSH
5970: LD_INT 50
5972: PUSH
5973: EMPTY
5974: LIST
5975: PUSH
5976: LD_INT 3
5978: PUSH
5979: LD_INT 23
5981: PUSH
5982: LD_INT 0
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 69
6003: ST_TO_ADDR
// if 0 + filter_all > 0 then
6004: LD_INT 0
6006: PUSH
6007: LD_VAR 0 4
6011: PLUS
6012: PUSH
6013: LD_INT 0
6015: GREATER
6016: IFFALSE 6115
// begin filter := [ ] ;
6018: LD_ADDR_VAR 0 3
6022: PUSH
6023: EMPTY
6024: ST_TO_ADDR
// for un in filter_all do
6025: LD_ADDR_VAR 0 2
6029: PUSH
6030: LD_VAR 0 4
6034: PUSH
6035: FOR_IN
6036: IFFALSE 6069
// if not ( un in all_possible ) then
6038: LD_VAR 0 2
6042: PUSH
6043: LD_EXP 39
6047: IN
6048: NOT
6049: IFFALSE 6067
// filter := filter union un ;
6051: LD_ADDR_VAR 0 3
6055: PUSH
6056: LD_VAR 0 3
6060: PUSH
6061: LD_VAR 0 2
6065: UNION
6066: ST_TO_ADDR
6067: GO 6035
6069: POP
6070: POP
// if filter > 0 then
6071: LD_VAR 0 3
6075: PUSH
6076: LD_INT 0
6078: GREATER
6079: IFFALSE 6099
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6081: LD_VAR 0 3
6085: PUSH
6086: LD_INT 1
6088: ARRAY
6089: PPUSH
6090: LD_STRING DGosStart-FSol1-1
6092: PPUSH
6093: CALL_OW 88
6097: GO 6115
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6099: LD_VAR 0 4
6103: PUSH
6104: LD_INT 1
6106: ARRAY
6107: PPUSH
6108: LD_STRING DGosStart-FSol1-1
6110: PPUSH
6111: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6115: LD_EXP 1
6119: PPUSH
6120: LD_STRING DGosStart-Bur-1
6122: PPUSH
6123: CALL_OW 88
// Wait ( 0 0$20 ) ;
6127: LD_INT 700
6129: PPUSH
6130: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6134: LD_EXP 1
6138: PPUSH
6139: LD_STRING DGosStart-Bur-1a
6141: PPUSH
6142: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6146: LD_EXP 8
6150: PPUSH
6151: LD_STRING DGosStart-Gos-1
6153: PPUSH
6154: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6158: LD_EXP 1
6162: PPUSH
6163: LD_STRING DGosStart-Bur-2
6165: PPUSH
6166: CALL_OW 88
// Hint ( Signal ) ;
6170: LD_STRING Signal
6172: PPUSH
6173: CALL_OW 339
// attackAvalaible = 1 ;
6177: LD_ADDR_EXP 61
6181: PUSH
6182: LD_INT 1
6184: ST_TO_ADDR
// enable ( 6 ) ;
6185: LD_INT 6
6187: ENABLE_MARKED
// EnableExclamations ;
6188: CALL_OW 473
// end ;
6192: LD_VAR 0 1
6196: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6197: LD_INT 0
6199: PPUSH
6200: PPUSH
6201: PPUSH
6202: PPUSH
// DisableExclamations ;
6203: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6207: LD_EXP 1
6211: PPUSH
6212: LD_STRING DSituation-Bur-1
6214: PPUSH
6215: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6219: LD_ADDR_VAR 0 4
6223: PUSH
6224: LD_INT 22
6226: PUSH
6227: LD_EXP 23
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 26
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 50
6248: PUSH
6249: EMPTY
6250: LIST
6251: PUSH
6252: LD_INT 3
6254: PUSH
6255: LD_INT 23
6257: PUSH
6258: LD_INT 0
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: PPUSH
6275: CALL_OW 69
6279: ST_TO_ADDR
// if 0 + filter_all > 0 then
6280: LD_INT 0
6282: PUSH
6283: LD_VAR 0 4
6287: PLUS
6288: PUSH
6289: LD_INT 0
6291: GREATER
6292: IFFALSE 6393
// begin filter := [ ] ;
6294: LD_ADDR_VAR 0 3
6298: PUSH
6299: EMPTY
6300: ST_TO_ADDR
// for un in filter_all do
6301: LD_ADDR_VAR 0 2
6305: PUSH
6306: LD_VAR 0 4
6310: PUSH
6311: FOR_IN
6312: IFFALSE 6345
// if not ( un in all_possible ) then
6314: LD_VAR 0 2
6318: PUSH
6319: LD_EXP 39
6323: IN
6324: NOT
6325: IFFALSE 6343
// filter := filter union un ;
6327: LD_ADDR_VAR 0 3
6331: PUSH
6332: LD_VAR 0 3
6336: PUSH
6337: LD_VAR 0 2
6341: UNION
6342: ST_TO_ADDR
6343: GO 6311
6345: POP
6346: POP
// if filter > 0 then
6347: LD_VAR 0 3
6351: PUSH
6352: LD_INT 0
6354: GREATER
6355: IFFALSE 6375
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6357: LD_VAR 0 3
6361: PUSH
6362: LD_INT 1
6364: ARRAY
6365: PPUSH
6366: LD_STRING DSituation-RFSol1-1
6368: PPUSH
6369: CALL_OW 88
6373: GO 6391
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6375: LD_VAR 0 4
6379: PUSH
6380: LD_INT 1
6382: ARRAY
6383: PPUSH
6384: LD_STRING DSituation-RFSol1-1
6386: PPUSH
6387: CALL_OW 88
// end else
6391: GO 6581
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6393: LD_ADDR_VAR 0 4
6397: PUSH
6398: LD_INT 22
6400: PUSH
6401: LD_EXP 23
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 26
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 50
6422: PUSH
6423: EMPTY
6424: LIST
6425: PUSH
6426: LD_INT 3
6428: PUSH
6429: LD_INT 23
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PUSH
6439: EMPTY
6440: LIST
6441: LIST
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: LIST
6447: LIST
6448: PPUSH
6449: CALL_OW 69
6453: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6454: LD_ADDR_VAR 0 4
6458: PUSH
6459: LD_VAR 0 4
6463: PUSH
6464: LD_EXP 1
6468: DIFF
6469: ST_TO_ADDR
// if 0 + filter_all > 0 then
6470: LD_INT 0
6472: PUSH
6473: LD_VAR 0 4
6477: PLUS
6478: PUSH
6479: LD_INT 0
6481: GREATER
6482: IFFALSE 6581
// begin filter := [ ] ;
6484: LD_ADDR_VAR 0 3
6488: PUSH
6489: EMPTY
6490: ST_TO_ADDR
// for un in filter_all do
6491: LD_ADDR_VAR 0 2
6495: PUSH
6496: LD_VAR 0 4
6500: PUSH
6501: FOR_IN
6502: IFFALSE 6535
// if not ( un in all_possible ) then
6504: LD_VAR 0 2
6508: PUSH
6509: LD_EXP 39
6513: IN
6514: NOT
6515: IFFALSE 6533
// filter := filter union un ;
6517: LD_ADDR_VAR 0 3
6521: PUSH
6522: LD_VAR 0 3
6526: PUSH
6527: LD_VAR 0 2
6531: UNION
6532: ST_TO_ADDR
6533: GO 6501
6535: POP
6536: POP
// if filter > 0 then
6537: LD_VAR 0 3
6541: PUSH
6542: LD_INT 0
6544: GREATER
6545: IFFALSE 6565
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6547: LD_VAR 0 3
6551: PUSH
6552: LD_INT 1
6554: ARRAY
6555: PPUSH
6556: LD_STRING DSituation-RSol1-1
6558: PPUSH
6559: CALL_OW 88
6563: GO 6581
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6565: LD_VAR 0 4
6569: PUSH
6570: LD_INT 1
6572: ARRAY
6573: PPUSH
6574: LD_STRING DSituation-RSol1-1
6576: PPUSH
6577: CALL_OW 88
// end ; end ; EnableExclamations ;
6581: CALL_OW 473
// end ;
6585: LD_VAR 0 1
6589: RET
// export function D_GO1 ; begin
6590: LD_INT 0
6592: PPUSH
// DisableExclamations ;
6593: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6597: LD_EXP 1
6601: PPUSH
6602: LD_STRING DGO#1-Bur-1
6604: PPUSH
6605: CALL_OW 88
// EnableExclamations ;
6609: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6613: LD_INT 11
6615: PPUSH
6616: LD_INT 1
6618: PPUSH
6619: CALL_OW 424
// end ;
6623: LD_VAR 0 1
6627: RET
// export function D_SeeYou ; begin
6628: LD_INT 0
6630: PPUSH
// DisableExclamations ;
6631: CALL_OW 474
// DialogueOn ;
6635: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6639: LD_EXP 8
6643: PPUSH
6644: LD_STRING DSeeYou-Gos-1
6646: PPUSH
6647: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6651: LD_EXP 1
6655: PPUSH
6656: LD_STRING DSeeYou-Bur-1
6658: PPUSH
6659: CALL_OW 88
// DialogueOff ;
6663: CALL_OW 7
// EnableExclamations ;
6667: CALL_OW 473
// end ; end_of_file
6671: LD_VAR 0 1
6675: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6676: GO 6678
6678: DISABLE
6679: LD_INT 0
6681: PPUSH
6682: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6683: LD_EXP 1
6687: PPUSH
6688: LD_INT 1
6690: PPUSH
6691: CALL_OW 308
6695: IFFALSE 6761
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6697: LD_ADDR_VAR 0 1
6701: PUSH
6702: LD_INT 22
6704: PUSH
6705: LD_EXP 27
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PPUSH
6714: CALL_OW 69
6718: ST_TO_ADDR
// for un in filter do
6719: LD_ADDR_VAR 0 2
6723: PUSH
6724: LD_VAR 0 1
6728: PUSH
6729: FOR_IN
6730: IFFALSE 6748
// setside ( un , you ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_EXP 23
6741: PPUSH
6742: CALL_OW 235
6746: GO 6729
6748: POP
6749: POP
// BurlakReachedBase := true ;
6750: LD_ADDR_EXP 28
6754: PUSH
6755: LD_INT 1
6757: ST_TO_ADDR
// disable ;
6758: DISABLE
// end else
6759: GO 6762
// enable ;
6761: ENABLE
// end ;
6762: PPOPN 2
6764: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6765: GO 6767
6767: DISABLE
6768: LD_INT 0
6770: PPUSH
6771: PPUSH
6772: PPUSH
6773: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6774: LD_EXP 1
6778: PPUSH
6779: LD_INT 10
6781: PPUSH
6782: CALL_OW 308
6786: IFFALSE 7017
// begin DisableExclamations ;
6788: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6792: LD_ADDR_VAR 0 1
6796: PUSH
6797: LD_INT 22
6799: PUSH
6800: LD_EXP 27
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: PPUSH
6809: CALL_OW 69
6813: ST_TO_ADDR
// skill := 0 ;
6814: LD_ADDR_VAR 0 3
6818: PUSH
6819: LD_INT 0
6821: ST_TO_ADDR
// for un in filter do
6822: LD_ADDR_VAR 0 2
6826: PUSH
6827: LD_VAR 0 1
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6867
// if GetSkill ( un , skill_engineering ) >= skill then
6835: LD_VAR 0 2
6839: PPUSH
6840: LD_INT 2
6842: PPUSH
6843: CALL_OW 259
6847: PUSH
6848: LD_VAR 0 3
6852: GREATEREQUAL
6853: IFFALSE 6865
// inzenyr := un ;
6855: LD_ADDR_VAR 0 4
6859: PUSH
6860: LD_VAR 0 2
6864: ST_TO_ADDR
6865: GO 6832
6867: POP
6868: POP
// ComStop ( inzenyr ) ;
6869: LD_VAR 0 4
6873: PPUSH
6874: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
6878: LD_VAR 0 4
6882: PPUSH
6883: CALL_OW 257
6887: PUSH
6888: LD_INT 2
6890: NONEQUAL
6891: IFFALSE 6982
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
6893: LD_ADDR_VAR 0 1
6897: PUSH
6898: LD_INT 30
6900: PUSH
6901: LD_INT 1
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: LD_INT 22
6910: PUSH
6911: LD_EXP 27
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PPUSH
6924: CALL_OW 69
6928: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
6929: LD_VAR 0 4
6933: PPUSH
6934: LD_VAR 0 1
6938: PUSH
6939: LD_INT 1
6941: ARRAY
6942: PPUSH
6943: CALL_OW 120
// Wait ( 10 ) ;
6947: LD_INT 10
6949: PPUSH
6950: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
6954: LD_VAR 0 4
6958: PPUSH
6959: LD_INT 2
6961: PPUSH
6962: CALL_OW 183
// Wait ( 10 ) ;
6966: LD_INT 10
6968: PPUSH
6969: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
6973: LD_VAR 0 4
6977: PPUSH
6978: CALL_OW 182
// end ; Wait ( 10 ) ;
6982: LD_INT 10
6984: PPUSH
6985: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
6989: LD_VAR 0 4
6993: PPUSH
6994: LD_INT 26
6996: PPUSH
6997: LD_INT 126
6999: PPUSH
7000: LD_INT 17
7002: PPUSH
7003: LD_INT 5
7005: PPUSH
7006: CALL_OW 205
// EnableExclamations ;
7010: CALL_OW 473
// disable ;
7014: DISABLE
// end else
7015: GO 7018
// enable ;
7017: ENABLE
// end ;
7018: PPOPN 4
7020: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7021: GO 7023
7023: DISABLE
7024: LD_INT 0
7026: PPUSH
7027: PPUSH
// begin if straz < bazooker then
7028: LD_EXP 45
7032: PUSH
7033: LD_EXP 51
7037: LESS
7038: IFFALSE 7186
// begin bazooker := bazooker + 1 ;
7040: LD_ADDR_EXP 51
7044: PUSH
7045: LD_EXP 51
7049: PUSH
7050: LD_INT 1
7052: PLUS
7053: ST_TO_ADDR
// while straz < bazooker do
7054: LD_EXP 45
7058: PUSH
7059: LD_EXP 51
7063: LESS
7064: IFFALSE 7186
// begin uc_side := rus ;
7066: LD_ADDR_OWVAR 20
7070: PUSH
7071: LD_EXP 24
7075: ST_TO_ADDR
// uc_nation := nation_russian ;
7076: LD_ADDR_OWVAR 21
7080: PUSH
7081: LD_INT 3
7083: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 7 + difficulty ) ;
7084: LD_INT 1
7086: PPUSH
7087: LD_INT 9
7089: PPUSH
7090: LD_INT 7
7092: PUSH
7093: LD_OWVAR 67
7097: PLUS
7098: PPUSH
7099: CALL_OW 380
// hc_name :=  ;
7103: LD_ADDR_OWVAR 26
7107: PUSH
7108: LD_STRING 
7110: ST_TO_ADDR
// bazukr := CreateHuman ;
7111: LD_ADDR_VAR 0 2
7115: PUSH
7116: CALL_OW 44
7120: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7121: LD_EXP 62
7125: PPUSH
7126: LD_VAR 0 2
7130: PPUSH
7131: LD_INT 1
7133: PPUSH
7134: CALL_OW 394
// straz := straz ^ bazukr ;
7138: LD_ADDR_EXP 45
7142: PUSH
7143: LD_EXP 45
7147: PUSH
7148: LD_VAR 0 2
7152: ADD
7153: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7154: LD_VAR 0 2
7158: PPUSH
7159: LD_INT 9
7161: PPUSH
7162: LD_INT 0
7164: PPUSH
7165: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 66
7176: PPUSH
7177: LD_INT 48
7179: PPUSH
7180: CALL_OW 114
// end ;
7184: GO 7054
// end ; end ;
7186: PPOPN 2
7188: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7189: GO 7191
7191: DISABLE
7192: LD_INT 0
7194: PPUSH
// begin if ( 0 + straz ) <> 0 then
7195: LD_INT 0
7197: PUSH
7198: LD_EXP 45
7202: PLUS
7203: PUSH
7204: LD_INT 0
7206: NONEQUAL
7207: IFFALSE 7450
// begin for un in straz do
7209: LD_ADDR_VAR 0 1
7213: PUSH
7214: LD_EXP 45
7218: PUSH
7219: FOR_IN
7220: IFFALSE 7448
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7222: LD_VAR 0 1
7226: PPUSH
7227: CALL_OW 314
7231: NOT
7232: PUSH
7233: LD_VAR 0 1
7237: PPUSH
7238: CALL_OW 256
7242: PUSH
7243: LD_INT 601
7245: GREATER
7246: AND
7247: IFFALSE 7446
// begin if GetY ( un ) > 60 then
7249: LD_VAR 0 1
7253: PPUSH
7254: CALL_OW 251
7258: PUSH
7259: LD_INT 60
7261: GREATER
7262: IFFALSE 7356
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7264: LD_VAR 0 1
7268: PPUSH
7269: LD_INT 66
7271: PPUSH
7272: LD_INT 48
7274: PPUSH
7275: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7279: LD_VAR 0 1
7283: PPUSH
7284: LD_INT 63
7286: PPUSH
7287: LD_INT 74
7289: PPUSH
7290: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7294: LD_VAR 0 1
7298: PPUSH
7299: LD_INT 73
7301: PPUSH
7302: LD_INT 90
7304: PPUSH
7305: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7309: LD_VAR 0 1
7313: PPUSH
7314: LD_INT 76
7316: PPUSH
7317: LD_INT 95
7319: PPUSH
7320: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7324: LD_VAR 0 1
7328: PPUSH
7329: LD_INT 72
7331: PPUSH
7332: LD_INT 95
7334: PPUSH
7335: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_INT 50
7346: PPUSH
7347: LD_INT 73
7349: PPUSH
7350: CALL_OW 174
// end else
7354: GO 7446
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 73
7363: PPUSH
7364: LD_INT 90
7366: PPUSH
7367: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7371: LD_VAR 0 1
7375: PPUSH
7376: LD_INT 76
7378: PPUSH
7379: LD_INT 95
7381: PPUSH
7382: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7386: LD_VAR 0 1
7390: PPUSH
7391: LD_INT 72
7393: PPUSH
7394: LD_INT 95
7396: PPUSH
7397: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7401: LD_VAR 0 1
7405: PPUSH
7406: LD_INT 50
7408: PPUSH
7409: LD_INT 73
7411: PPUSH
7412: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7416: LD_VAR 0 1
7420: PPUSH
7421: LD_INT 63
7423: PPUSH
7424: LD_INT 74
7426: PPUSH
7427: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7431: LD_VAR 0 1
7435: PPUSH
7436: LD_INT 66
7438: PPUSH
7439: LD_INT 48
7441: PPUSH
7442: CALL_OW 174
// end ; end ; end ;
7446: GO 7219
7448: POP
7449: POP
// end ; enable ;
7450: ENABLE
// end ;
7451: PPOPN 1
7453: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7454: GO 7456
7456: DISABLE
7457: LD_INT 0
7459: PPUSH
7460: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7461: LD_EXP 1
7465: PPUSH
7466: LD_INT 2
7468: PPUSH
7469: CALL_OW 308
7473: IFFALSE 7517
// begin disabled5 := true ;
7475: LD_ADDR_LOC 4
7479: PUSH
7480: LD_INT 1
7482: ST_TO_ADDR
// D_GosStart ;
7483: CALL 5334 0 0
// Wait ( 0 0$5 ) ;
7487: LD_INT 175
7489: PPUSH
7490: CALL_OW 67
// D_Situation ;
7494: CALL 6197 0 0
// ChangeMissionObjectives ( MHold ) ;
7498: LD_STRING MHold
7500: PPUSH
7501: CALL_OW 337
// disable ;
7505: DISABLE
// enable ( 333 ) ;
7506: LD_INT 333
7508: ENABLE_MARKED
// enable ( 334 ) ;
7509: LD_INT 334
7511: ENABLE_MARKED
// enable ( 337 ) ;
7512: LD_INT 337
7514: ENABLE_MARKED
// end else
7515: GO 7518
// enable ;
7517: ENABLE
// end ;
7518: PPOPN 2
7520: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7521: GO 7523
7523: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7524: LD_EXP 8
7528: PPUSH
7529: CALL_OW 306
7533: PUSH
7534: LD_INT 1
7536: EQUAL
7537: IFFALSE 7563
// begin if WasSelected = false then
7539: LD_EXP 46
7543: PUSH
7544: LD_INT 0
7546: EQUAL
7547: IFFALSE 7561
// begin QueryQGO ;
7549: CALL 7580 0 0
// WasSelected := true ;
7553: LD_ADDR_EXP 46
7557: PUSH
7558: LD_INT 1
7560: ST_TO_ADDR
// end ; end else
7561: GO 7571
// WasSelected := false ;
7563: LD_ADDR_EXP 46
7567: PUSH
7568: LD_INT 0
7570: ST_TO_ADDR
// if not disabled3 then
7571: LD_LOC 3
7575: NOT
7576: IFFALSE 7579
// enable ;
7578: ENABLE
// end ;
7579: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7580: LD_INT 0
7582: PPUSH
7583: PPUSH
7584: PPUSH
7585: PPUSH
7586: PPUSH
7587: PPUSH
// res := Query ( QGO ) ;
7588: LD_ADDR_VAR 0 2
7592: PUSH
7593: LD_STRING QGO
7595: PPUSH
7596: CALL_OW 97
7600: ST_TO_ADDR
// if res = 1 then
7601: LD_VAR 0 2
7605: PUSH
7606: LD_INT 1
7608: EQUAL
7609: IFFALSE 7985
// begin disabled3 := true ;
7611: LD_ADDR_LOC 3
7615: PUSH
7616: LD_INT 1
7618: ST_TO_ADDR
// D_GO1 ;
7619: CALL 6590 0 0
// ChangeMissionObjectives ( MGuide ) ;
7623: LD_STRING MGuide
7625: PPUSH
7626: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7630: LD_ADDR_VAR 0 3
7634: PUSH
7635: LD_INT 3
7637: PPUSH
7638: LD_INT 21
7640: PUSH
7641: LD_INT 2
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 34
7650: PUSH
7651: LD_INT 51
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PPUSH
7662: CALL_OW 70
7666: ST_TO_ADDR
// if filter = 0 then
7667: LD_VAR 0 3
7671: PUSH
7672: LD_INT 0
7674: EQUAL
7675: IFFALSE 7826
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7677: LD_EXP 8
7681: PPUSH
7682: LD_INT 57
7684: PPUSH
7685: LD_INT 98
7687: PPUSH
7688: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7692: LD_INT 35
7694: PPUSH
7695: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7699: LD_EXP 8
7703: PPUSH
7704: CALL_OW 314
7708: NOT
7709: IFFALSE 7692
// RemoveUnit ( Gossudarov ) ;
7711: LD_EXP 8
7715: PPUSH
7716: CALL_OW 64
// uc_side := ally ;
7720: LD_ADDR_OWVAR 20
7724: PUSH
7725: LD_EXP 25
7729: ST_TO_ADDR
// uc_nation := nation_russian ;
7730: LD_ADDR_OWVAR 21
7734: PUSH
7735: LD_INT 3
7737: ST_TO_ADDR
// uc_direction := 5 ;
7738: LD_ADDR_OWVAR 24
7742: PUSH
7743: LD_INT 5
7745: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7746: LD_ADDR_OWVAR 37
7750: PUSH
7751: LD_INT 21
7753: ST_TO_ADDR
// vc_engine := engine_combustion ;
7754: LD_ADDR_OWVAR 39
7758: PUSH
7759: LD_INT 1
7761: ST_TO_ADDR
// vc_control := control_manual ;
7762: LD_ADDR_OWVAR 38
7766: PUSH
7767: LD_INT 1
7769: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7770: LD_ADDR_OWVAR 40
7774: PUSH
7775: LD_INT 51
7777: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7778: LD_ADDR_VAR 0 4
7782: PUSH
7783: CALL_OW 45
7787: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7788: LD_EXP 8
7792: PPUSH
7793: LD_VAR 0 4
7797: PPUSH
7798: CALL_OW 52
// Wait ( 0 0$5 ) ;
7802: LD_INT 175
7804: PPUSH
7805: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
7809: LD_VAR 0 4
7813: PPUSH
7814: LD_INT 9
7816: PPUSH
7817: LD_INT 0
7819: PPUSH
7820: CALL_OW 49
// end else
7824: GO 7844
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
7826: LD_EXP 8
7830: PPUSH
7831: LD_VAR 0 3
7835: PUSH
7836: LD_INT 1
7838: ARRAY
7839: PPUSH
7840: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
7844: LD_EXP 8
7848: PPUSH
7849: LD_INT 4
7851: PPUSH
7852: CALL_OW 469
7856: PUSH
7857: LD_INT 1
7859: ARRAY
7860: PPUSH
7861: LD_INT 4
7863: PPUSH
7864: CALL_OW 469
7868: PUSH
7869: LD_INT 2
7871: ARRAY
7872: PPUSH
7873: CALL_OW 220
// Wait ( 0 0$5 ) ;
7877: LD_INT 175
7879: PPUSH
7880: CALL_OW 67
// ComExitBuilding ( scientists ) ;
7884: LD_EXP 40
7888: PPUSH
7889: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
7893: LD_EXP 40
7897: PUSH
7898: LD_EXP 8
7902: ADD
7903: PPUSH
7904: LD_INT 50
7906: PPUSH
7907: LD_INT 58
7909: PPUSH
7910: CALL_OW 171
// for un in scientists ^ Gossudarov do
7914: LD_ADDR_VAR 0 6
7918: PUSH
7919: LD_EXP 40
7923: PUSH
7924: LD_EXP 8
7928: ADD
7929: PUSH
7930: FOR_IN
7931: IFFALSE 7949
// AddComSailEvent ( un , un ) ;
7933: LD_VAR 0 6
7937: PPUSH
7938: LD_VAR 0 6
7942: PPUSH
7943: CALL_OW 224
7947: GO 7930
7949: POP
7950: POP
// player_units := player_units union scientists union Gossudarov ;
7951: LD_ADDR_EXP 41
7955: PUSH
7956: LD_EXP 41
7960: PUSH
7961: LD_EXP 40
7965: UNION
7966: PUSH
7967: LD_EXP 8
7971: UNION
7972: ST_TO_ADDR
// enable ( 4 ) ;
7973: LD_INT 4
7975: ENABLE_MARKED
// enable ( 7 ) ;
7976: LD_INT 7
7978: ENABLE_MARKED
// enable ( 8 ) ;
7979: LD_INT 8
7981: ENABLE_MARKED
// enable ( 9 ) ;
7982: LD_INT 9
7984: ENABLE_MARKED
// end ; end ;
7985: LD_VAR 0 1
7989: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
7990: GO 7992
7992: DISABLE
7993: LD_INT 0
7995: PPUSH
// begin for un in scientists do
7996: LD_ADDR_VAR 0 1
8000: PUSH
8001: LD_EXP 40
8005: PUSH
8006: FOR_IN
8007: IFFALSE 8077
// begin if IsInArea ( un , ExitArea ) then
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 11
8016: PPUSH
8017: CALL_OW 308
8021: IFFALSE 8048
// begin scientists_saved := scientists_saved union un ;
8023: LD_ADDR_EXP 48
8027: PUSH
8028: LD_EXP 48
8032: PUSH
8033: LD_VAR 0 1
8037: UNION
8038: ST_TO_ADDR
// RemoveUnit ( un ) ;
8039: LD_VAR 0 1
8043: PPUSH
8044: CALL_OW 64
// end ; if IsDead ( un ) then
8048: LD_VAR 0 1
8052: PPUSH
8053: CALL_OW 301
8057: IFFALSE 8075
// scientists_dead := scientists_dead union un ;
8059: LD_ADDR_EXP 49
8063: PUSH
8064: LD_EXP 49
8068: PUSH
8069: LD_VAR 0 1
8073: UNION
8074: ST_TO_ADDR
// end ;
8075: GO 8006
8077: POP
8078: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8079: LD_EXP 8
8083: PPUSH
8084: LD_INT 11
8086: PPUSH
8087: CALL_OW 308
8091: PUSH
8092: LD_EXP 8
8096: PPUSH
8097: CALL_OW 310
8101: PPUSH
8102: LD_INT 11
8104: PPUSH
8105: CALL_OW 308
8109: OR
8110: PUSH
8111: LD_EXP 48
8115: PUSH
8116: LD_EXP 49
8120: PLUS
8121: PUSH
8122: LD_EXP 40
8126: EQUAL
8127: AND
8128: PUSH
8129: LD_EXP 50
8133: PPUSH
8134: CALL_OW 255
8138: PUSH
8139: LD_EXP 23
8143: EQUAL
8144: AND
8145: PUSH
8146: LD_EXP 50
8150: PPUSH
8151: LD_INT 11
8153: PPUSH
8154: CALL_OW 308
8158: AND
8159: PUSH
8160: LD_EXP 50
8164: PPUSH
8165: LD_INT 4
8167: PPUSH
8168: CALL_OW 289
8172: PUSH
8173: LD_INT 40
8175: EQUAL
8176: AND
8177: IFFALSE 8189
// begin D_SeeYou ;
8179: CALL 6628 0 0
// TheEnd ;
8183: CALL 3115 0 0
// end else
8187: GO 8190
// enable ;
8189: ENABLE
// end ;
8190: PPOPN 1
8192: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8193: GO 8195
8195: DISABLE
8196: LD_INT 0
8198: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8199: LD_EXP 1
8203: PPUSH
8204: LD_INT 18
8206: PPUSH
8207: CALL_OW 308
8211: PUSH
8212: LD_EXP 43
8216: PPUSH
8217: LD_INT 18
8219: PPUSH
8220: CALL_OW 308
8224: OR
8225: IFFALSE 8242
// begin Wait ( 0 0$3 ) ;
8227: LD_INT 105
8229: PPUSH
8230: CALL_OW 67
// Attack1 := true ;
8234: LD_ADDR_LOC 5
8238: PUSH
8239: LD_INT 1
8241: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8242: LD_EXP 1
8246: PPUSH
8247: LD_INT 19
8249: PPUSH
8250: CALL_OW 308
8254: PUSH
8255: LD_EXP 43
8259: PPUSH
8260: LD_INT 19
8262: PPUSH
8263: CALL_OW 308
8267: OR
8268: IFFALSE 8285
// begin Wait ( 0 0$3 ) ;
8270: LD_INT 105
8272: PPUSH
8273: CALL_OW 67
// Attack2 := true ;
8277: LD_ADDR_LOC 6
8281: PUSH
8282: LD_INT 1
8284: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8285: LD_EXP 1
8289: PPUSH
8290: LD_INT 20
8292: PPUSH
8293: CALL_OW 308
8297: PUSH
8298: LD_EXP 43
8302: PPUSH
8303: LD_INT 20
8305: PPUSH
8306: CALL_OW 308
8310: OR
8311: IFFALSE 8328
// begin Wait ( 0 0$3 ) ;
8313: LD_INT 105
8315: PPUSH
8316: CALL_OW 67
// Attack3 := true ;
8320: LD_ADDR_LOC 7
8324: PUSH
8325: LD_INT 1
8327: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8328: LD_LOC 5
8332: PUSH
8333: LD_LOC 6
8337: NOT
8338: AND
8339: PUSH
8340: LD_LOC 7
8344: NOT
8345: AND
8346: IFFALSE 8409
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8348: LD_ADDR_VAR 0 1
8352: PUSH
8353: DOUBLE
8354: LD_EXP 31
8358: PUSH
8359: LD_INT 1
8361: PLUS
8362: DEC
8363: ST_TO_ADDR
8364: LD_EXP 31
8368: PUSH
8369: LD_EXP 30
8373: PLUS
8374: PUSH
8375: FOR_TO
8376: IFFALSE 8407
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8378: LD_EXP 29
8382: PUSH
8383: LD_VAR 0 1
8387: ARRAY
8388: PPUSH
8389: LD_EXP 1
8393: PPUSH
8394: CALL_OW 115
// Wait ( 2 ) ;
8398: LD_INT 2
8400: PPUSH
8401: CALL_OW 67
// end ;
8405: GO 8375
8407: POP
8408: POP
// if Attack1 and Attack2 and not Attack3 then
8409: LD_LOC 5
8413: PUSH
8414: LD_LOC 6
8418: AND
8419: PUSH
8420: LD_LOC 7
8424: NOT
8425: AND
8426: IFFALSE 8493
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8428: LD_ADDR_VAR 0 1
8432: PUSH
8433: DOUBLE
8434: LD_EXP 31
8438: PUSH
8439: LD_INT 1
8441: PLUS
8442: DEC
8443: ST_TO_ADDR
8444: LD_EXP 31
8448: PUSH
8449: LD_INT 2
8451: PUSH
8452: LD_EXP 30
8456: MUL
8457: PLUS
8458: PUSH
8459: FOR_TO
8460: IFFALSE 8491
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8462: LD_EXP 29
8466: PUSH
8467: LD_VAR 0 1
8471: ARRAY
8472: PPUSH
8473: LD_EXP 1
8477: PPUSH
8478: CALL_OW 115
// Wait ( 2 ) ;
8482: LD_INT 2
8484: PPUSH
8485: CALL_OW 67
// end ;
8489: GO 8459
8491: POP
8492: POP
// if Attack1 and Attack2 and Attack3 then
8493: LD_LOC 5
8497: PUSH
8498: LD_LOC 6
8502: AND
8503: PUSH
8504: LD_LOC 7
8508: AND
8509: IFFALSE 8576
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8511: LD_ADDR_VAR 0 1
8515: PUSH
8516: DOUBLE
8517: LD_EXP 31
8521: PUSH
8522: LD_INT 1
8524: PLUS
8525: DEC
8526: ST_TO_ADDR
8527: LD_EXP 31
8531: PUSH
8532: LD_INT 3
8534: PUSH
8535: LD_EXP 30
8539: MUL
8540: PLUS
8541: PUSH
8542: FOR_TO
8543: IFFALSE 8574
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8545: LD_EXP 29
8549: PUSH
8550: LD_VAR 0 1
8554: ARRAY
8555: PPUSH
8556: LD_EXP 1
8560: PPUSH
8561: CALL_OW 115
// Wait ( 2 ) ;
8565: LD_INT 2
8567: PPUSH
8568: CALL_OW 67
// end ;
8572: GO 8542
8574: POP
8575: POP
// for i := 1 to pursuers_base do
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: DOUBLE
8582: LD_INT 1
8584: DEC
8585: ST_TO_ADDR
8586: LD_EXP 31
8590: PUSH
8591: FOR_TO
8592: IFFALSE 8623
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8594: LD_EXP 29
8598: PUSH
8599: LD_VAR 0 1
8603: ARRAY
8604: PPUSH
8605: LD_EXP 1
8609: PPUSH
8610: CALL_OW 115
// Wait ( 2 ) ;
8614: LD_INT 2
8616: PPUSH
8617: CALL_OW 67
// end ;
8621: GO 8591
8623: POP
8624: POP
// if not disabled5 then
8625: LD_LOC 4
8629: NOT
8630: IFFALSE 8633
// enable ;
8632: ENABLE
// end ;
8633: PPOPN 1
8635: END
// every 0 0$1 marked 6 do
8636: GO 8638
8638: DISABLE
// begin if Goss_time > 0 then
8639: LD_EXP 47
8643: PUSH
8644: LD_INT 0
8646: GREATER
8647: IFFALSE 8683
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8649: LD_ADDR_OWVAR 47
8653: PUSH
8654: LD_STRING #Ru12a-1
8656: PUSH
8657: LD_EXP 47
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8666: LD_ADDR_EXP 47
8670: PUSH
8671: LD_EXP 47
8675: PUSH
8676: LD_INT 35
8678: MINUS
8679: ST_TO_ADDR
// enable ;
8680: ENABLE
// end else
8681: GO 8694
// begin display_strings :=  ;
8683: LD_ADDR_OWVAR 47
8687: PUSH
8688: LD_STRING 
8690: ST_TO_ADDR
// enable ( 3 ) ;
8691: LD_INT 3
8693: ENABLE_MARKED
// end ; end ;
8694: END
// every 0 0$1 marked 7 do
8695: GO 8697
8697: DISABLE
// begin if FindArtifact ( 4 ) then
8698: LD_INT 4
8700: PPUSH
8701: CALL_OW 469
8705: IFFALSE 8759
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8707: LD_LOC 8
8711: PPUSH
8712: LD_INT 4
8714: PPUSH
8715: CALL_OW 469
8719: PUSH
8720: LD_INT 1
8722: ARRAY
8723: PPUSH
8724: LD_INT 4
8726: PPUSH
8727: CALL_OW 469
8731: PUSH
8732: LD_INT 2
8734: ARRAY
8735: PPUSH
8736: CALL_OW 160
// Wait ( 3 ) ;
8740: LD_INT 3
8742: PPUSH
8743: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8747: LD_LOC 8
8751: PPUSH
8752: LD_INT 9
8754: PPUSH
8755: CALL_OW 173
// end ; enable ;
8759: ENABLE
// end ;
8760: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8761: GO 8763
8763: DISABLE
8764: LD_INT 0
8766: PPUSH
8767: PPUSH
8768: PPUSH
8769: PPUSH
// begin Wait ( pausa ) ;
8770: LD_EXP 37
8774: PPUSH
8775: CALL_OW 67
// sc_utok := [ ] ;
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: EMPTY
8785: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8786: LD_ADDR_VAR 0 1
8790: PUSH
8791: DOUBLE
8792: LD_INT 1
8794: DEC
8795: ST_TO_ADDR
8796: LD_INT 2
8798: PUSH
8799: LD_OWVAR 67
8803: PLUS
8804: PUSH
8805: FOR_TO
8806: IFFALSE 9010
// begin uc_side := rus ;
8808: LD_ADDR_OWVAR 20
8812: PUSH
8813: LD_EXP 24
8817: ST_TO_ADDR
// uc_nation := nation_russian ;
8818: LD_ADDR_OWVAR 21
8822: PUSH
8823: LD_INT 3
8825: ST_TO_ADDR
// uc_direction := 5 ;
8826: LD_ADDR_OWVAR 24
8830: PUSH
8831: LD_INT 5
8833: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PUSH
8845: LD_INT 1
8847: DOUBLE
8848: EQUAL
8849: IFTRUE 8853
8851: GO 8877
8853: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
8854: LD_INT 1
8856: PPUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 4
8862: PPUSH
8863: LD_INT 8
8865: PPUSH
8866: CALL_OW 12
8870: PPUSH
8871: CALL_OW 380
8875: GO 8916
8877: LD_INT 2
8879: DOUBLE
8880: GREATEREQUAL
8881: IFFALSE 8889
8883: LD_INT 3
8885: DOUBLE
8886: LESSEQUAL
8887: IFTRUE 8891
8889: GO 8915
8891: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
8892: LD_INT 1
8894: PPUSH
8895: LD_INT 9
8897: PPUSH
8898: LD_INT 3
8900: PPUSH
8901: LD_INT 7
8903: PPUSH
8904: CALL_OW 12
8908: PPUSH
8909: CALL_OW 380
8913: GO 8916
8915: POP
// hc_name :=  ;
8916: LD_ADDR_OWVAR 26
8920: PUSH
8921: LD_STRING 
8923: ST_TO_ADDR
// clovek := CreateHuman ;
8924: LD_ADDR_VAR 0 2
8928: PUSH
8929: CALL_OW 44
8933: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
8934: LD_VAR 0 2
8938: PPUSH
8939: LD_INT 9
8941: PPUSH
8942: LD_INT 0
8944: PPUSH
8945: CALL_OW 49
// Wait ( 0 0$2 ) ;
8949: LD_INT 70
8951: PPUSH
8952: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
8956: LD_VAR 0 2
8960: PPUSH
8961: LD_INT 50
8963: PPUSH
8964: LD_INT 84
8966: PPUSH
8967: CALL_OW 111
// Wait ( 2 ) ;
8971: LD_INT 2
8973: PPUSH
8974: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
8978: LD_VAR 0 2
8982: PPUSH
8983: LD_EXP 50
8987: PPUSH
8988: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
8992: LD_ADDR_VAR 0 3
8996: PUSH
8997: LD_VAR 0 3
9001: PUSH
9002: LD_VAR 0 2
9006: ADD
9007: ST_TO_ADDR
// end ;
9008: GO 8805
9010: POP
9011: POP
// Wait ( 0 0$10 ) ;
9012: LD_INT 350
9014: PPUSH
9015: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9019: LD_LOC 8
9023: PPUSH
9024: CALL_OW 302
9028: NOT
9029: IFFALSE 9136
// begin uc_side := rus ;
9031: LD_ADDR_OWVAR 20
9035: PUSH
9036: LD_EXP 24
9040: ST_TO_ADDR
// uc_nation := nation_russian ;
9041: LD_ADDR_OWVAR 21
9045: PUSH
9046: LD_INT 3
9048: ST_TO_ADDR
// uc_direction := 5 ;
9049: LD_ADDR_OWVAR 24
9053: PUSH
9054: LD_INT 5
9056: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9057: LD_ADDR_OWVAR 37
9061: PUSH
9062: LD_INT 22
9064: ST_TO_ADDR
// vc_control := control_computer ;
9065: LD_ADDR_OWVAR 38
9069: PUSH
9070: LD_INT 3
9072: ST_TO_ADDR
// vc_engine := engine_siberite ;
9073: LD_ADDR_OWVAR 39
9077: PUSH
9078: LD_INT 3
9080: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9081: LD_ADDR_OWVAR 40
9085: PUSH
9086: LD_INT 51
9088: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9089: LD_ADDR_LOC 8
9093: PUSH
9094: CALL_OW 45
9098: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9099: LD_LOC 8
9103: PPUSH
9104: LD_INT 9
9106: PPUSH
9107: LD_INT 0
9109: PPUSH
9110: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9114: LD_INT 18
9116: PPUSH
9117: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9121: LD_LOC 8
9125: PPUSH
9126: LD_INT 55
9128: PPUSH
9129: LD_INT 84
9131: PPUSH
9132: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9136: LD_VAR 0 3
9140: PUSH
9141: LD_LOC 8
9145: PPUSH
9146: CALL_OW 302
9150: AND
9151: IFFALSE 9221
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9153: LD_VAR 0 3
9157: PPUSH
9158: LD_EXP 50
9162: PPUSH
9163: CALL_OW 115
// Wait ( 0 0$2 ) ;
9167: LD_INT 70
9169: PPUSH
9170: CALL_OW 67
// for un in sc_utok do
9174: LD_ADDR_VAR 0 4
9178: PUSH
9179: LD_VAR 0 3
9183: PUSH
9184: FOR_IN
9185: IFFALSE 9217
// if not IsOK ( un ) then
9187: LD_VAR 0 4
9191: PPUSH
9192: CALL_OW 302
9196: NOT
9197: IFFALSE 9215
// sc_utok := sc_utok diff un ;
9199: LD_ADDR_VAR 0 3
9203: PUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 4
9213: DIFF
9214: ST_TO_ADDR
9215: GO 9184
9217: POP
9218: POP
// end ;
9219: GO 9136
// Wait ( 0 0$5 ) ;
9221: LD_INT 175
9223: PPUSH
9224: CALL_OW 67
// enable ;
9228: ENABLE
// end ;
9229: PPOPN 4
9231: END
// every 0 0$3 marked 9 do
9232: GO 9234
9234: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9235: LD_LOC 8
9239: PPUSH
9240: LD_INT 3
9242: PPUSH
9243: CALL_OW 308
9247: PUSH
9248: LD_LOC 8
9252: PPUSH
9253: LD_INT 4
9255: PPUSH
9256: CALL_OW 289
9260: PUSH
9261: LD_INT 40
9263: EQUAL
9264: AND
9265: IFFALSE 9274
// YouLost ( Artefact ) ;
9267: LD_STRING Artefact
9269: PPUSH
9270: CALL_OW 104
// enable ;
9274: ENABLE
// end ;
9275: END
// on UnitDestroyed ( human ) do var i , un ;
9276: LD_INT 0
9278: PPUSH
9279: PPUSH
// begin if human = Burlak then
9280: LD_VAR 0 1
9284: PUSH
9285: LD_EXP 1
9289: EQUAL
9290: IFFALSE 9299
// YouLost ( Burlak ) ;
9292: LD_STRING Burlak
9294: PPUSH
9295: CALL_OW 104
// if human = Gossudarov then
9299: LD_VAR 0 1
9303: PUSH
9304: LD_EXP 8
9308: EQUAL
9309: IFFALSE 9318
// YouLost ( Gossudarov ) ;
9311: LD_STRING Gossudarov
9313: PPUSH
9314: CALL_OW 104
// if un = Masha then
9318: LD_VAR 0 3
9322: PUSH
9323: LD_EXP 43
9327: EQUAL
9328: IFFALSE 9338
// lost_masha := true ;
9330: LD_ADDR_EXP 52
9334: PUSH
9335: LD_INT 1
9337: ST_TO_ADDR
// if human in straz then
9338: LD_VAR 0 1
9342: PUSH
9343: LD_EXP 45
9347: IN
9348: IFFALSE 9397
// begin straz := straz diff human ;
9350: LD_ADDR_EXP 45
9354: PUSH
9355: LD_EXP 45
9359: PUSH
9360: LD_VAR 0 1
9364: DIFF
9365: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9366: LD_EXP 62
9370: PPUSH
9371: LD_VAR 0 1
9375: PPUSH
9376: LD_INT 1
9378: PPUSH
9379: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9383: LD_ADDR_EXP 53
9387: PUSH
9388: LD_EXP 53
9392: PUSH
9393: LD_INT 1
9395: PLUS
9396: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9397: LD_VAR 0 1
9401: PPUSH
9402: CALL_OW 255
9406: PUSH
9407: LD_INT 3
9409: EQUAL
9410: PUSH
9411: LD_VAR 0 1
9415: PUSH
9416: LD_EXP 60
9420: IN
9421: AND
9422: IFFALSE 9469
// begin for i in attackGroup do
9424: LD_ADDR_VAR 0 2
9428: PUSH
9429: LD_EXP 60
9433: PUSH
9434: FOR_IN
9435: IFFALSE 9467
// if i = human then
9437: LD_VAR 0 2
9441: PUSH
9442: LD_VAR 0 1
9446: EQUAL
9447: IFFALSE 9465
// attackGroup = attackGroup diff i ;
9449: LD_ADDR_EXP 60
9453: PUSH
9454: LD_EXP 60
9458: PUSH
9459: LD_VAR 0 2
9463: DIFF
9464: ST_TO_ADDR
9465: GO 9434
9467: POP
9468: POP
// end ; end ;
9469: PPOPN 3
9471: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9472: LD_VAR 0 1
9476: PUSH
9477: LD_EXP 8
9481: EQUAL
9482: IFFALSE 9503
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9484: LD_EXP 8
9488: PPUSH
9489: CALL_OW 310
9493: PPUSH
9494: LD_EXP 23
9498: PPUSH
9499: CALL_OW 235
// SetSide ( num , you ) ;
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 23
9512: PPUSH
9513: CALL_OW 235
// end ;
9517: PPOPN 1
9519: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9520: LD_VAR 0 1
9524: PPUSH
9525: CALL_OW 255
9529: PUSH
9530: LD_EXP 24
9534: NONEQUAL
9535: IFFALSE 9547
// Artifact_cargo := un ;
9537: LD_ADDR_EXP 50
9541: PUSH
9542: LD_VAR 0 1
9546: ST_TO_ADDR
// end ; end_of_file
9547: PPOPN 2
9549: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9550: GO 9552
9552: DISABLE
9553: LD_INT 0
9555: PPUSH
9556: PPUSH
9557: PPUSH
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// begin case tick of 0 .. 30000 :
9562: LD_OWVAR 1
9566: PUSH
9567: LD_INT 0
9569: DOUBLE
9570: GREATEREQUAL
9571: IFFALSE 9579
9573: LD_INT 30000
9575: DOUBLE
9576: LESSEQUAL
9577: IFTRUE 9581
9579: GO 9591
9581: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9582: LD_INT 1050
9584: PPUSH
9585: CALL_OW 67
9589: GO 9767
9591: LD_INT 30001
9593: DOUBLE
9594: GREATEREQUAL
9595: IFFALSE 9603
9597: LD_INT 50000
9599: DOUBLE
9600: LESSEQUAL
9601: IFTRUE 9605
9603: GO 9615
9605: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9606: LD_INT 1575
9608: PPUSH
9609: CALL_OW 67
9613: GO 9767
9615: LD_INT 50001
9617: DOUBLE
9618: GREATEREQUAL
9619: IFFALSE 9627
9621: LD_INT 70000
9623: DOUBLE
9624: LESSEQUAL
9625: IFTRUE 9629
9627: GO 9639
9629: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9630: LD_INT 2100
9632: PPUSH
9633: CALL_OW 67
9637: GO 9767
9639: LD_INT 70001
9641: DOUBLE
9642: GREATEREQUAL
9643: IFFALSE 9651
9645: LD_INT 90000
9647: DOUBLE
9648: LESSEQUAL
9649: IFTRUE 9653
9651: GO 9663
9653: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9654: LD_INT 2625
9656: PPUSH
9657: CALL_OW 67
9661: GO 9767
9663: LD_INT 70001
9665: DOUBLE
9666: GREATEREQUAL
9667: IFFALSE 9675
9669: LD_INT 90000
9671: DOUBLE
9672: LESSEQUAL
9673: IFTRUE 9677
9675: GO 9687
9677: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9678: LD_INT 3150
9680: PPUSH
9681: CALL_OW 67
9685: GO 9767
9687: LD_INT 90001
9689: DOUBLE
9690: GREATEREQUAL
9691: IFFALSE 9699
9693: LD_INT 110000
9695: DOUBLE
9696: LESSEQUAL
9697: IFTRUE 9701
9699: GO 9711
9701: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9702: LD_INT 3675
9704: PPUSH
9705: CALL_OW 67
9709: GO 9767
9711: LD_INT 110001
9713: DOUBLE
9714: GREATEREQUAL
9715: IFFALSE 9723
9717: LD_INT 130000
9719: DOUBLE
9720: LESSEQUAL
9721: IFTRUE 9725
9723: GO 9735
9725: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9726: LD_INT 4200
9728: PPUSH
9729: CALL_OW 67
9733: GO 9767
9735: LD_INT 130001
9737: DOUBLE
9738: GREATEREQUAL
9739: IFFALSE 9747
9741: LD_INT 150000
9743: DOUBLE
9744: LESSEQUAL
9745: IFTRUE 9749
9747: GO 9759
9749: POP
// Wait ( 2 2$15 ) ; else
9750: LD_INT 4725
9752: PPUSH
9753: CALL_OW 67
9757: GO 9767
9759: POP
// Wait ( 2 2$30 ) ; end ;
9760: LD_INT 5250
9762: PPUSH
9763: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9767: LD_ADDR_LOC 9
9771: PUSH
9772: LD_INT 22
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 1
9780: PUSH
9781: LD_INT 43
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: LD_INT 23
9792: PUSH
9793: LD_INT 3
9795: PUSH
9796: LD_INT 1
9798: PUSH
9799: LD_INT 45
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: PUSH
9808: LD_INT 21
9810: PUSH
9811: LD_INT 3
9813: PUSH
9814: LD_INT 1
9816: PUSH
9817: LD_INT 43
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: PUSH
9826: LD_INT 24
9828: PUSH
9829: LD_INT 3
9831: PUSH
9832: LD_INT 1
9834: PUSH
9835: LD_INT 45
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: PUSH
9844: LD_INT 21
9846: PUSH
9847: LD_INT 3
9849: PUSH
9850: LD_INT 1
9852: PUSH
9853: LD_INT 45
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: PUSH
9862: LD_INT 22
9864: PUSH
9865: LD_INT 3
9867: PUSH
9868: LD_INT 1
9870: PUSH
9871: LD_INT 44
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: LIST
9878: LIST
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: LD_INT 3
9888: PUSH
9889: LD_INT 46
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_INT 23
9900: PUSH
9901: LD_INT 3
9903: PUSH
9904: LD_INT 3
9906: PUSH
9907: LD_INT 46
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: PUSH
9916: LD_INT 24
9918: PUSH
9919: LD_INT 3
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: LD_INT 46
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 23
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: LD_INT 3
9942: PUSH
9943: LD_INT 47
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: PUSH
9952: LD_INT 24
9954: PUSH
9955: LD_INT 3
9957: PUSH
9958: LD_INT 3
9960: PUSH
9961: LD_INT 49
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: PUSH
9970: LD_INT 23
9972: PUSH
9973: LD_INT 3
9975: PUSH
9976: LD_INT 1
9978: PUSH
9979: LD_INT 49
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: LIST
10001: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10002: LD_ADDR_VAR 0 1
10006: PUSH
10007: LD_INT 22
10009: PUSH
10010: LD_EXP 23
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: LD_INT 21
10021: PUSH
10022: LD_INT 2
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 69
10037: ST_TO_ADDR
// if filter < 3 then
10038: LD_VAR 0 1
10042: PUSH
10043: LD_INT 3
10045: LESS
10046: IFFALSE 10056
// filter := 3 ;
10048: LD_ADDR_VAR 0 1
10052: PUSH
10053: LD_INT 3
10055: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10056: LD_INT 22
10058: PUSH
10059: LD_INT 3
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: LD_INT 21
10068: PUSH
10069: LD_INT 2
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PUSH
10076: LD_INT 50
10078: PUSH
10079: EMPTY
10080: LIST
10081: PUSH
10082: LD_INT 2
10084: PUSH
10085: LD_INT 34
10087: PUSH
10088: LD_INT 43
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: PUSH
10095: LD_INT 34
10097: PUSH
10098: LD_INT 45
10100: PUSH
10101: EMPTY
10102: LIST
10103: LIST
10104: PUSH
10105: LD_INT 34
10107: PUSH
10108: LD_INT 44
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PUSH
10115: LD_INT 34
10117: PUSH
10118: LD_INT 46
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PUSH
10125: LD_INT 34
10127: PUSH
10128: LD_INT 47
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 34
10137: PUSH
10138: LD_INT 49
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: LIST
10158: LIST
10159: PPUSH
10160: CALL_OW 69
10164: PUSH
10165: LD_INT 6
10167: LESSEQUAL
10168: IFFALSE 10699
// for i := 1 to ( filter div 3 ) do
10170: LD_ADDR_VAR 0 2
10174: PUSH
10175: DOUBLE
10176: LD_INT 1
10178: DEC
10179: ST_TO_ADDR
10180: LD_VAR 0 1
10184: PUSH
10185: LD_INT 3
10187: DIV
10188: PUSH
10189: FOR_TO
10190: IFFALSE 10697
// begin uc_side := rus ;
10192: LD_ADDR_OWVAR 20
10196: PUSH
10197: LD_EXP 24
10201: ST_TO_ADDR
// uc_nation := nation_russian ;
10202: LD_ADDR_OWVAR 21
10206: PUSH
10207: LD_INT 3
10209: ST_TO_ADDR
// uc_direction := 5 ;
10210: LD_ADDR_OWVAR 24
10214: PUSH
10215: LD_INT 5
10217: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10218: LD_OWVAR 1
10222: PUSH
10223: LD_INT 60000
10225: LESS
10226: PUSH
10227: LD_INT 28
10229: PPUSH
10230: LD_EXP 23
10234: PPUSH
10235: CALL_OW 321
10239: PUSH
10240: LD_INT 2
10242: EQUAL
10243: OR
10244: IFFALSE 10270
// typ := rand ( 1 , vehicles - 2 ) else
10246: LD_ADDR_VAR 0 4
10250: PUSH
10251: LD_INT 1
10253: PPUSH
10254: LD_LOC 9
10258: PUSH
10259: LD_INT 2
10261: MINUS
10262: PPUSH
10263: CALL_OW 12
10267: ST_TO_ADDR
10268: GO 10288
// typ := rand ( 1 , vehicles ) ;
10270: LD_ADDR_VAR 0 4
10274: PUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_LOC 9
10282: PPUSH
10283: CALL_OW 12
10287: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10288: LD_ADDR_OWVAR 37
10292: PUSH
10293: LD_LOC 9
10297: PUSH
10298: LD_VAR 0 4
10302: ARRAY
10303: PUSH
10304: LD_INT 1
10306: ARRAY
10307: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10308: LD_ADDR_OWVAR 38
10312: PUSH
10313: LD_LOC 9
10317: PUSH
10318: LD_VAR 0 4
10322: ARRAY
10323: PUSH
10324: LD_INT 2
10326: ARRAY
10327: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10328: LD_ADDR_OWVAR 39
10332: PUSH
10333: LD_LOC 9
10337: PUSH
10338: LD_VAR 0 4
10342: ARRAY
10343: PUSH
10344: LD_INT 3
10346: ARRAY
10347: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10348: LD_ADDR_OWVAR 40
10352: PUSH
10353: LD_LOC 9
10357: PUSH
10358: LD_VAR 0 4
10362: ARRAY
10363: PUSH
10364: LD_INT 4
10366: ARRAY
10367: ST_TO_ADDR
// auto := CreateVehicle ;
10368: LD_ADDR_VAR 0 5
10372: PUSH
10373: CALL_OW 45
10377: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10378: LD_VAR 0 5
10382: PPUSH
10383: LD_INT 9
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// attack := attack ^ auto ;
10393: LD_ADDR_LOC 10
10397: PUSH
10398: LD_LOC 10
10402: PUSH
10403: LD_VAR 0 5
10407: ADD
10408: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10409: LD_VAR 0 5
10413: PPUSH
10414: LD_INT 52
10416: PPUSH
10417: LD_INT 61
10419: PPUSH
10420: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10424: LD_VAR 0 5
10428: PPUSH
10429: LD_INT 52
10431: PPUSH
10432: LD_INT 61
10434: PPUSH
10435: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10439: LD_INT 1
10441: PPUSH
10442: LD_INT 2
10444: PPUSH
10445: CALL_OW 12
10449: PUSH
10450: LD_INT 1
10452: DOUBLE
10453: EQUAL
10454: IFTRUE 10458
10456: GO 10476
10458: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10459: LD_VAR 0 5
10463: PPUSH
10464: LD_INT 35
10466: PPUSH
10467: LD_INT 30
10469: PPUSH
10470: CALL_OW 174
10474: GO 10503
10476: LD_INT 2
10478: DOUBLE
10479: EQUAL
10480: IFTRUE 10484
10482: GO 10502
10484: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10485: LD_VAR 0 5
10489: PPUSH
10490: LD_INT 17
10492: PPUSH
10493: LD_INT 29
10495: PPUSH
10496: CALL_OW 174
10500: GO 10503
10502: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10503: LD_VAR 0 5
10507: PPUSH
10508: LD_INT 29
10510: PPUSH
10511: LD_INT 5
10513: PPUSH
10514: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10518: LD_INT 1
10520: PPUSH
10521: LD_INT 2
10523: PPUSH
10524: CALL_OW 12
10528: PUSH
10529: LD_INT 1
10531: DOUBLE
10532: EQUAL
10533: IFTRUE 10537
10535: GO 10555
10537: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10538: LD_VAR 0 5
10542: PPUSH
10543: LD_INT 60
10545: PPUSH
10546: LD_INT 30
10548: PPUSH
10549: CALL_OW 174
10553: GO 10582
10555: LD_INT 2
10557: DOUBLE
10558: EQUAL
10559: IFTRUE 10563
10561: GO 10581
10563: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10564: LD_VAR 0 5
10568: PPUSH
10569: LD_INT 84
10571: PPUSH
10572: LD_INT 30
10574: PPUSH
10575: CALL_OW 174
10579: GO 10582
10581: POP
// case Rand ( 1 , 2 ) of 1 :
10582: LD_INT 1
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: CALL_OW 12
10592: PUSH
10593: LD_INT 1
10595: DOUBLE
10596: EQUAL
10597: IFTRUE 10601
10599: GO 10619
10601: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10602: LD_VAR 0 5
10606: PPUSH
10607: LD_INT 71
10609: PPUSH
10610: LD_INT 59
10612: PPUSH
10613: CALL_OW 174
10617: GO 10646
10619: LD_INT 2
10621: DOUBLE
10622: EQUAL
10623: IFTRUE 10627
10625: GO 10645
10627: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10628: LD_VAR 0 5
10632: PPUSH
10633: LD_INT 92
10635: PPUSH
10636: LD_INT 66
10638: PPUSH
10639: CALL_OW 174
10643: GO 10646
10645: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10646: LD_VAR 0 5
10650: PPUSH
10651: LD_INT 78
10653: PPUSH
10654: LD_INT 88
10656: PPUSH
10657: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10661: LD_VAR 0 5
10665: PPUSH
10666: LD_INT 117
10668: PPUSH
10669: LD_INT 90
10671: PPUSH
10672: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10676: LD_VAR 0 5
10680: PPUSH
10681: LD_INT 15
10683: PPUSH
10684: CALL_OW 173
// Wait ( 0 0$4 ) ;
10688: LD_INT 140
10690: PPUSH
10691: CALL_OW 67
// end ;
10695: GO 10189
10697: POP
10698: POP
// enable ;
10699: ENABLE
// end ;
10700: PPOPN 7
10702: END
// export function PrepareInfantry ; var i , clovek ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
// for i = 1 to 6 do
10708: LD_ADDR_VAR 0 2
10712: PUSH
10713: DOUBLE
10714: LD_INT 1
10716: DEC
10717: ST_TO_ADDR
10718: LD_INT 6
10720: PUSH
10721: FOR_TO
10722: IFFALSE 10887
// begin uc_side = 3 ;
10724: LD_ADDR_OWVAR 20
10728: PUSH
10729: LD_INT 3
10731: ST_TO_ADDR
// uc_nation = 3 ;
10732: LD_ADDR_OWVAR 21
10736: PUSH
10737: LD_INT 3
10739: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10740: LD_INT 1
10742: PPUSH
10743: LD_INT 3
10745: PPUSH
10746: CALL_OW 12
10750: PUSH
10751: LD_INT 1
10753: DOUBLE
10754: EQUAL
10755: IFTRUE 10759
10757: GO 10783
10759: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
10760: LD_INT 1
10762: PPUSH
10763: LD_INT 1
10765: PPUSH
10766: LD_INT 4
10768: PPUSH
10769: LD_INT 8
10771: PPUSH
10772: CALL_OW 12
10776: PPUSH
10777: CALL_OW 380
10781: GO 10822
10783: LD_INT 2
10785: DOUBLE
10786: GREATEREQUAL
10787: IFFALSE 10795
10789: LD_INT 3
10791: DOUBLE
10792: LESSEQUAL
10793: IFTRUE 10797
10795: GO 10821
10797: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
10798: LD_INT 1
10800: PPUSH
10801: LD_INT 9
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_INT 7
10809: PPUSH
10810: CALL_OW 12
10814: PPUSH
10815: CALL_OW 380
10819: GO 10822
10821: POP
// hc_name :=  ;
10822: LD_ADDR_OWVAR 26
10826: PUSH
10827: LD_STRING 
10829: ST_TO_ADDR
// clovek := CreateHuman ;
10830: LD_ADDR_VAR 0 3
10834: PUSH
10835: CALL_OW 44
10839: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
10840: LD_VAR 0 3
10844: PPUSH
10845: LD_INT 9
10847: PPUSH
10848: LD_INT 0
10850: PPUSH
10851: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
10855: LD_ADDR_EXP 59
10859: PUSH
10860: LD_EXP 59
10864: PUSH
10865: LD_INT 1
10867: MINUS
10868: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
10869: LD_ADDR_EXP 60
10873: PUSH
10874: LD_EXP 60
10878: PUSH
10879: LD_VAR 0 3
10883: ADD
10884: ST_TO_ADDR
// end ;
10885: GO 10721
10887: POP
10888: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
10889: LD_EXP 60
10893: PPUSH
10894: LD_INT 52
10896: PPUSH
10897: LD_INT 61
10899: PPUSH
10900: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
10904: LD_INT 1
10906: PPUSH
10907: LD_INT 2
10909: PPUSH
10910: CALL_OW 12
10914: PUSH
10915: LD_INT 1
10917: DOUBLE
10918: EQUAL
10919: IFTRUE 10923
10921: GO 10941
10923: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
10924: LD_EXP 60
10928: PPUSH
10929: LD_INT 35
10931: PPUSH
10932: LD_INT 30
10934: PPUSH
10935: CALL_OW 174
10939: GO 10968
10941: LD_INT 2
10943: DOUBLE
10944: EQUAL
10945: IFTRUE 10949
10947: GO 10967
10949: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
10950: LD_EXP 60
10954: PPUSH
10955: LD_INT 17
10957: PPUSH
10958: LD_INT 29
10960: PPUSH
10961: CALL_OW 174
10965: GO 10968
10967: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
10968: LD_EXP 60
10972: PPUSH
10973: LD_INT 29
10975: PPUSH
10976: LD_INT 5
10978: PPUSH
10979: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10983: LD_INT 1
10985: PPUSH
10986: LD_INT 2
10988: PPUSH
10989: CALL_OW 12
10993: PUSH
10994: LD_INT 1
10996: DOUBLE
10997: EQUAL
10998: IFTRUE 11002
11000: GO 11020
11002: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11003: LD_EXP 60
11007: PPUSH
11008: LD_INT 60
11010: PPUSH
11011: LD_INT 30
11013: PPUSH
11014: CALL_OW 174
11018: GO 11047
11020: LD_INT 2
11022: DOUBLE
11023: EQUAL
11024: IFTRUE 11028
11026: GO 11046
11028: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11029: LD_EXP 60
11033: PPUSH
11034: LD_INT 84
11036: PPUSH
11037: LD_INT 30
11039: PPUSH
11040: CALL_OW 174
11044: GO 11047
11046: POP
// case Rand ( 1 , 2 ) of 1 :
11047: LD_INT 1
11049: PPUSH
11050: LD_INT 2
11052: PPUSH
11053: CALL_OW 12
11057: PUSH
11058: LD_INT 1
11060: DOUBLE
11061: EQUAL
11062: IFTRUE 11066
11064: GO 11084
11066: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11067: LD_EXP 60
11071: PPUSH
11072: LD_INT 71
11074: PPUSH
11075: LD_INT 59
11077: PPUSH
11078: CALL_OW 174
11082: GO 11111
11084: LD_INT 2
11086: DOUBLE
11087: EQUAL
11088: IFTRUE 11092
11090: GO 11110
11092: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11093: LD_EXP 60
11097: PPUSH
11098: LD_INT 92
11100: PPUSH
11101: LD_INT 66
11103: PPUSH
11104: CALL_OW 174
11108: GO 11111
11110: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11111: LD_EXP 60
11115: PPUSH
11116: LD_INT 78
11118: PPUSH
11119: LD_INT 88
11121: PPUSH
11122: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11126: LD_EXP 60
11130: PPUSH
11131: LD_INT 117
11133: PPUSH
11134: LD_INT 90
11136: PPUSH
11137: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11141: LD_EXP 60
11145: PPUSH
11146: LD_INT 15
11148: PPUSH
11149: CALL_OW 173
// end ;
11153: LD_VAR 0 1
11157: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11158: LD_EXP 60
11162: PUSH
11163: EMPTY
11164: EQUAL
11165: PUSH
11166: LD_EXP 61
11170: PUSH
11171: LD_INT 1
11173: EQUAL
11174: AND
11175: IFFALSE 11185
11177: GO 11179
11179: DISABLE
// begin enable ;
11180: ENABLE
// PrepareInfantry ;
11181: CALL 10703 0 0
// end ;
11185: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11186: GO 11188
11188: DISABLE
11189: LD_INT 0
11191: PPUSH
11192: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11193: LD_ADDR_VAR 0 1
11197: PUSH
11198: LD_INT 15
11200: PPUSH
11201: LD_INT 22
11203: PUSH
11204: LD_EXP 24
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: LD_INT 50
11215: PUSH
11216: EMPTY
11217: LIST
11218: PUSH
11219: LD_INT 2
11221: PUSH
11222: LD_INT 21
11224: PUSH
11225: LD_INT 2
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: PUSH
11232: LD_INT 21
11234: PUSH
11235: LD_INT 1
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: EMPTY
11243: LIST
11244: LIST
11245: LIST
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: LIST
11251: PPUSH
11252: CALL_OW 70
11256: ST_TO_ADDR
// case tick of 0 .. 30000 :
11257: LD_OWVAR 1
11261: PUSH
11262: LD_INT 0
11264: DOUBLE
11265: GREATEREQUAL
11266: IFFALSE 11274
11268: LD_INT 30000
11270: DOUBLE
11271: LESSEQUAL
11272: IFTRUE 11276
11274: GO 11293
11276: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11277: LD_ADDR_VAR 0 2
11281: PUSH
11282: LD_EXP 34
11286: PUSH
11287: LD_INT 4
11289: MINUS
11290: ST_TO_ADDR
11291: GO 11397
11293: LD_INT 30001
11295: DOUBLE
11296: GREATEREQUAL
11297: IFFALSE 11305
11299: LD_INT 50000
11301: DOUBLE
11302: LESSEQUAL
11303: IFTRUE 11307
11305: GO 11324
11307: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_EXP 34
11317: PUSH
11318: LD_INT 3
11320: MINUS
11321: ST_TO_ADDR
11322: GO 11397
11324: LD_INT 50001
11326: DOUBLE
11327: GREATEREQUAL
11328: IFFALSE 11336
11330: LD_INT 70000
11332: DOUBLE
11333: LESSEQUAL
11334: IFTRUE 11338
11336: GO 11355
11338: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11339: LD_ADDR_VAR 0 2
11343: PUSH
11344: LD_EXP 34
11348: PUSH
11349: LD_INT 2
11351: MINUS
11352: ST_TO_ADDR
11353: GO 11397
11355: LD_INT 70001
11357: DOUBLE
11358: GREATEREQUAL
11359: IFFALSE 11367
11361: LD_INT 90000
11363: DOUBLE
11364: LESSEQUAL
11365: IFTRUE 11369
11367: GO 11386
11369: POP
// mnozstvi := maxaut - 1 ; else
11370: LD_ADDR_VAR 0 2
11374: PUSH
11375: LD_EXP 34
11379: PUSH
11380: LD_INT 1
11382: MINUS
11383: ST_TO_ADDR
11384: GO 11397
11386: POP
// mnozstvi := maxaut ; end ;
11387: LD_ADDR_VAR 0 2
11391: PUSH
11392: LD_EXP 34
11396: ST_TO_ADDR
// if filter >= mnozstvi then
11397: LD_VAR 0 1
11401: PUSH
11402: LD_VAR 0 2
11406: GREATEREQUAL
11407: IFFALSE 11424
// ComMoveXY ( filter , 138 , 69 ) ;
11409: LD_VAR 0 1
11413: PPUSH
11414: LD_INT 138
11416: PPUSH
11417: LD_INT 69
11419: PPUSH
11420: CALL_OW 111
// enable ;
11424: ENABLE
// end ;
11425: PPOPN 2
11427: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11428: GO 11430
11430: DISABLE
11431: LD_INT 0
11433: PPUSH
11434: PPUSH
11435: PPUSH
11436: PPUSH
11437: PPUSH
11438: PPUSH
// begin enable ;
11439: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11440: LD_ADDR_VAR 0 1
11444: PUSH
11445: LD_INT 12
11447: PPUSH
11448: LD_INT 22
11450: PUSH
11451: LD_EXP 24
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: PUSH
11460: LD_INT 50
11462: PUSH
11463: EMPTY
11464: LIST
11465: PUSH
11466: LD_INT 3
11468: PUSH
11469: LD_INT 34
11471: PUSH
11472: LD_INT 49
11474: PUSH
11475: EMPTY
11476: LIST
11477: LIST
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: LIST
11487: PPUSH
11488: CALL_OW 70
11492: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11493: LD_INT 33
11495: PPUSH
11496: LD_EXP 23
11500: PPUSH
11501: CALL_OW 321
11505: PUSH
11506: LD_INT 2
11508: EQUAL
11509: IFFALSE 11563
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11511: LD_ADDR_VAR 0 2
11515: PUSH
11516: LD_INT 12
11518: PPUSH
11519: LD_INT 22
11521: PUSH
11522: LD_EXP 23
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PUSH
11531: LD_INT 25
11533: PUSH
11534: LD_INT 4
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: PUSH
11541: LD_INT 101
11543: PUSH
11544: LD_EXP 24
11548: PUSH
11549: EMPTY
11550: LIST
11551: LIST
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: LIST
11557: PPUSH
11558: CALL_OW 70
11562: ST_TO_ADDR
// if filter_you = 0 then
11563: LD_VAR 0 2
11567: PUSH
11568: LD_INT 0
11570: EQUAL
11571: IFFALSE 11680
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11573: LD_ADDR_VAR 0 2
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_EXP 23
11585: PUSH
11586: EMPTY
11587: LIST
11588: LIST
11589: PUSH
11590: LD_INT 50
11592: PUSH
11593: EMPTY
11594: LIST
11595: PUSH
11596: LD_INT 2
11598: PUSH
11599: LD_INT 21
11601: PUSH
11602: LD_INT 1
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 21
11611: PUSH
11612: LD_INT 2
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 21
11621: PUSH
11622: LD_INT 3
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: PUSH
11629: EMPTY
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: LIST
11639: PPUSH
11640: CALL_OW 69
11644: ST_TO_ADDR
// if filter_you = 0 then
11645: LD_VAR 0 2
11649: PUSH
11650: LD_INT 0
11652: EQUAL
11653: IFFALSE 11680
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11655: LD_ADDR_VAR 0 2
11659: PUSH
11660: LD_INT 12
11662: PPUSH
11663: LD_INT 22
11665: PUSH
11666: LD_EXP 23
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PPUSH
11675: CALL_OW 70
11679: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11680: LD_VAR 0 1
11684: PUSH
11685: LD_INT 0
11687: GREATER
11688: PUSH
11689: LD_VAR 0 2
11693: PUSH
11694: LD_INT 0
11696: GREATER
11697: AND
11698: IFFALSE 12089
// begin for un_rus in filter_rus do
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 1
11709: PUSH
11710: FOR_IN
11711: IFFALSE 12087
// begin Wait ( 5 ) ;
11713: LD_INT 5
11715: PPUSH
11716: CALL_OW 67
// min := 99999 ;
11720: LD_ADDR_VAR 0 5
11724: PUSH
11725: LD_INT 99999
11727: ST_TO_ADDR
// cil := 0 ;
11728: LD_ADDR_VAR 0 6
11732: PUSH
11733: LD_INT 0
11735: ST_TO_ADDR
// for un_you in filter_you do
11736: LD_ADDR_VAR 0 4
11740: PUSH
11741: LD_VAR 0 2
11745: PUSH
11746: FOR_IN
11747: IFFALSE 11943
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11749: LD_VAR 0 4
11753: PPUSH
11754: CALL_OW 320
11758: PUSH
11759: LD_VAR 0 4
11763: PPUSH
11764: CALL_OW 256
11768: PUSH
11769: LD_VAR 0 5
11773: LESS
11774: AND
11775: PUSH
11776: LD_VAR 0 3
11780: PPUSH
11781: LD_VAR 0 4
11785: PPUSH
11786: CALL_OW 296
11790: PUSH
11791: LD_INT 2
11793: PUSH
11794: LD_INT 2
11796: PUSH
11797: LD_INT 4
11799: PUSH
11800: LD_INT 6
11802: PUSH
11803: LD_INT 5
11805: PUSH
11806: LD_INT 9
11808: PUSH
11809: LD_INT 0
11811: PUSH
11812: LD_INT 2
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: PUSH
11825: LD_VAR 0 3
11829: PPUSH
11830: CALL_OW 264
11834: PUSH
11835: LD_INT 41
11837: MINUS
11838: ARRAY
11839: GREATEREQUAL
11840: AND
11841: PUSH
11842: LD_VAR 0 3
11846: PPUSH
11847: LD_VAR 0 4
11851: PPUSH
11852: CALL_OW 296
11856: PUSH
11857: LD_INT 15
11859: PUSH
11860: LD_INT 16
11862: PUSH
11863: LD_INT 17
11865: PUSH
11866: LD_INT 22
11868: PUSH
11869: LD_INT 20
11871: PUSH
11872: LD_INT 28
11874: PUSH
11875: LD_INT 0
11877: PUSH
11878: LD_INT 51
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: PUSH
11891: LD_VAR 0 3
11895: PPUSH
11896: CALL_OW 264
11900: PUSH
11901: LD_INT 41
11903: MINUS
11904: ARRAY
11905: LESSEQUAL
11906: AND
11907: IFFALSE 11934
// begin min := GetLives ( un_you ) ;
11909: LD_ADDR_VAR 0 5
11913: PUSH
11914: LD_VAR 0 4
11918: PPUSH
11919: CALL_OW 256
11923: ST_TO_ADDR
// cil := un_you ;
11924: LD_ADDR_VAR 0 6
11928: PUSH
11929: LD_VAR 0 4
11933: ST_TO_ADDR
// end ; Wait ( 5 ) ;
11934: LD_INT 5
11936: PPUSH
11937: CALL_OW 67
// end ;
11941: GO 11746
11943: POP
11944: POP
// if cil <> 0 then
11945: LD_VAR 0 6
11949: PUSH
11950: LD_INT 0
11952: NONEQUAL
11953: IFFALSE 11971
// ComAttackUnit ( un_rus , cil ) else
11955: LD_VAR 0 3
11959: PPUSH
11960: LD_VAR 0 6
11964: PPUSH
11965: CALL_OW 115
11969: GO 12085
// begin for un_you in filter_you do
11971: LD_ADDR_VAR 0 4
11975: PUSH
11976: LD_VAR 0 2
11980: PUSH
11981: FOR_IN
11982: IFFALSE 12069
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
11984: LD_VAR 0 4
11988: PPUSH
11989: CALL_OW 266
11993: PUSH
11994: LD_INT 0
11996: PUSH
11997: LD_INT 1
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: IN
12004: IFFALSE 12018
// cil := un_you else
12006: LD_ADDR_VAR 0 6
12010: PUSH
12011: LD_VAR 0 4
12015: ST_TO_ADDR
12016: GO 12060
// if GetLives ( un_you ) < min then
12018: LD_VAR 0 4
12022: PPUSH
12023: CALL_OW 256
12027: PUSH
12028: LD_VAR 0 5
12032: LESS
12033: IFFALSE 12060
// begin min := GetLives ( un_you ) ;
12035: LD_ADDR_VAR 0 5
12039: PUSH
12040: LD_VAR 0 4
12044: PPUSH
12045: CALL_OW 256
12049: ST_TO_ADDR
// cil := un_you ;
12050: LD_ADDR_VAR 0 6
12054: PUSH
12055: LD_VAR 0 4
12059: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12060: LD_INT 5
12062: PPUSH
12063: CALL_OW 67
// end ;
12067: GO 11981
12069: POP
12070: POP
// ComAttackUnit ( un_rus , cil ) end ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_VAR 0 6
12080: PPUSH
12081: CALL_OW 115
// end ;
12085: GO 11710
12087: POP
12088: POP
// end ; end ;
12089: PPOPN 6
12091: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12092: GO 12094
12094: DISABLE
12095: LD_INT 0
12097: PPUSH
12098: PPUSH
12099: PPUSH
12100: PPUSH
12101: PPUSH
12102: PPUSH
// begin enable ;
12103: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12104: LD_ADDR_VAR 0 1
12108: PUSH
12109: LD_INT 21
12111: PPUSH
12112: LD_INT 22
12114: PUSH
12115: LD_EXP 24
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 3
12126: PUSH
12127: LD_INT 2
12129: PUSH
12130: LD_INT 21
12132: PUSH
12133: LD_INT 3
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: LD_INT 34
12142: PUSH
12143: LD_INT 49
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 34
12152: PUSH
12153: LD_INT 51
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 4
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: LD_INT 25
12172: PUSH
12173: LD_INT 2
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: PUSH
12180: LD_INT 54
12182: PUSH
12183: EMPTY
12184: LIST
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: PUSH
12195: EMPTY
12196: LIST
12197: LIST
12198: LIST
12199: PPUSH
12200: CALL_OW 70
12204: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12205: LD_ADDR_VAR 0 1
12209: PUSH
12210: LD_VAR 0 1
12214: PUSH
12215: LD_EXP 45
12219: DIFF
12220: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12221: LD_ADDR_VAR 0 2
12225: PUSH
12226: LD_INT 21
12228: PPUSH
12229: LD_INT 22
12231: PUSH
12232: LD_EXP 23
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 21
12243: PUSH
12244: LD_INT 2
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PPUSH
12255: CALL_OW 70
12259: ST_TO_ADDR
// if not filter_you then
12260: LD_VAR 0 2
12264: NOT
12265: IFFALSE 12338
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12267: LD_ADDR_VAR 0 2
12271: PUSH
12272: LD_INT 21
12274: PPUSH
12275: LD_INT 22
12277: PUSH
12278: LD_EXP 23
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: LD_INT 25
12289: PUSH
12290: LD_INT 4
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PPUSH
12301: CALL_OW 70
12305: ST_TO_ADDR
// if not filter_you then
12306: LD_VAR 0 2
12310: NOT
12311: IFFALSE 12338
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12313: LD_ADDR_VAR 0 2
12317: PUSH
12318: LD_INT 21
12320: PPUSH
12321: LD_INT 22
12323: PUSH
12324: LD_EXP 23
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PPUSH
12333: CALL_OW 70
12337: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12338: LD_VAR 0 1
12342: PUSH
12343: LD_INT 0
12345: GREATER
12346: PUSH
12347: LD_VAR 0 2
12351: PUSH
12352: LD_INT 0
12354: GREATER
12355: AND
12356: IFFALSE 12747
// begin for un_rus in filter_rus do
12358: LD_ADDR_VAR 0 3
12362: PUSH
12363: LD_VAR 0 1
12367: PUSH
12368: FOR_IN
12369: IFFALSE 12745
// begin Wait ( 5 ) ;
12371: LD_INT 5
12373: PPUSH
12374: CALL_OW 67
// min := 99999 ;
12378: LD_ADDR_VAR 0 5
12382: PUSH
12383: LD_INT 99999
12385: ST_TO_ADDR
// cil := 0 ;
12386: LD_ADDR_VAR 0 6
12390: PUSH
12391: LD_INT 0
12393: ST_TO_ADDR
// for un_you in filter_you do
12394: LD_ADDR_VAR 0 4
12398: PUSH
12399: LD_VAR 0 2
12403: PUSH
12404: FOR_IN
12405: IFFALSE 12601
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12407: LD_VAR 0 4
12411: PPUSH
12412: CALL_OW 302
12416: PUSH
12417: LD_VAR 0 4
12421: PPUSH
12422: CALL_OW 256
12426: PUSH
12427: LD_VAR 0 5
12431: LESS
12432: AND
12433: PUSH
12434: LD_VAR 0 3
12438: PPUSH
12439: LD_VAR 0 4
12443: PPUSH
12444: CALL_OW 296
12448: PUSH
12449: LD_INT 2
12451: PUSH
12452: LD_INT 2
12454: PUSH
12455: LD_INT 4
12457: PUSH
12458: LD_INT 6
12460: PUSH
12461: LD_INT 5
12463: PUSH
12464: LD_INT 9
12466: PUSH
12467: LD_INT 0
12469: PUSH
12470: LD_INT 2
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: LIST
12477: LIST
12478: LIST
12479: LIST
12480: LIST
12481: LIST
12482: PUSH
12483: LD_VAR 0 3
12487: PPUSH
12488: CALL_OW 264
12492: PUSH
12493: LD_INT 41
12495: MINUS
12496: ARRAY
12497: GREATEREQUAL
12498: AND
12499: PUSH
12500: LD_VAR 0 3
12504: PPUSH
12505: LD_VAR 0 4
12509: PPUSH
12510: CALL_OW 296
12514: PUSH
12515: LD_INT 15
12517: PUSH
12518: LD_INT 16
12520: PUSH
12521: LD_INT 17
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 20
12529: PUSH
12530: LD_INT 28
12532: PUSH
12533: LD_INT 0
12535: PUSH
12536: LD_INT 51
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: PUSH
12549: LD_VAR 0 3
12553: PPUSH
12554: CALL_OW 264
12558: PUSH
12559: LD_INT 41
12561: MINUS
12562: ARRAY
12563: LESSEQUAL
12564: AND
12565: IFFALSE 12592
// begin min := GetLives ( un_you ) ;
12567: LD_ADDR_VAR 0 5
12571: PUSH
12572: LD_VAR 0 4
12576: PPUSH
12577: CALL_OW 256
12581: ST_TO_ADDR
// cil := un_you ;
12582: LD_ADDR_VAR 0 6
12586: PUSH
12587: LD_VAR 0 4
12591: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12592: LD_INT 5
12594: PPUSH
12595: CALL_OW 67
// end ;
12599: GO 12404
12601: POP
12602: POP
// if cil <> 0 then
12603: LD_VAR 0 6
12607: PUSH
12608: LD_INT 0
12610: NONEQUAL
12611: IFFALSE 12629
// ComAttackUnit ( un_rus , cil ) else
12613: LD_VAR 0 3
12617: PPUSH
12618: LD_VAR 0 6
12622: PPUSH
12623: CALL_OW 115
12627: GO 12743
// begin for un_you in filter_you do
12629: LD_ADDR_VAR 0 4
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: FOR_IN
12640: IFFALSE 12727
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12642: LD_VAR 0 4
12646: PPUSH
12647: CALL_OW 266
12651: PUSH
12652: LD_INT 0
12654: PUSH
12655: LD_INT 1
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: IN
12662: IFFALSE 12676
// cil := un_you else
12664: LD_ADDR_VAR 0 6
12668: PUSH
12669: LD_VAR 0 4
12673: ST_TO_ADDR
12674: GO 12718
// if GetLives ( un_you ) < min then
12676: LD_VAR 0 4
12680: PPUSH
12681: CALL_OW 256
12685: PUSH
12686: LD_VAR 0 5
12690: LESS
12691: IFFALSE 12718
// begin min := GetLives ( un_you ) ;
12693: LD_ADDR_VAR 0 5
12697: PUSH
12698: LD_VAR 0 4
12702: PPUSH
12703: CALL_OW 256
12707: ST_TO_ADDR
// cil := un_you ;
12708: LD_ADDR_VAR 0 6
12712: PUSH
12713: LD_VAR 0 4
12717: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12718: LD_INT 5
12720: PPUSH
12721: CALL_OW 67
// end ;
12725: GO 12639
12727: POP
12728: POP
// ComAttackUnit ( un_rus , cil ) end ;
12729: LD_VAR 0 3
12733: PPUSH
12734: LD_VAR 0 6
12738: PPUSH
12739: CALL_OW 115
// end ;
12743: GO 12368
12745: POP
12746: POP
// end ; end ;
12747: PPOPN 6
12749: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12750: GO 12752
12752: DISABLE
12753: LD_INT 0
12755: PPUSH
12756: PPUSH
12757: PPUSH
12758: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12759: LD_INT 28
12761: PPUSH
12762: LD_EXP 23
12766: PPUSH
12767: CALL_OW 321
12771: PUSH
12772: LD_INT 2
12774: EQUAL
12775: NOT
12776: IFFALSE 12779
// enable ;
12778: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12779: LD_ADDR_VAR 0 1
12783: PUSH
12784: LD_INT 12
12786: PPUSH
12787: LD_INT 22
12789: PUSH
12790: LD_EXP 24
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: LD_INT 50
12801: PUSH
12802: EMPTY
12803: LIST
12804: PUSH
12805: LD_INT 34
12807: PUSH
12808: LD_INT 49
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 70
12824: ST_TO_ADDR
// if filter_rus > 0 then
12825: LD_VAR 0 1
12829: PUSH
12830: LD_INT 0
12832: GREATER
12833: IFFALSE 12874
// for un_rus in filter_rus do
12835: LD_ADDR_VAR 0 3
12839: PUSH
12840: LD_VAR 0 1
12844: PUSH
12845: FOR_IN
12846: IFFALSE 12872
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
12848: LD_VAR 0 3
12852: PPUSH
12853: LD_INT 122
12855: PPUSH
12856: LD_INT 27
12858: PPUSH
12859: CALL_OW 111
// Wait ( 5 ) ;
12863: LD_INT 5
12865: PPUSH
12866: CALL_OW 67
// end ;
12870: GO 12845
12872: POP
12873: POP
// end ;
12874: PPOPN 4
12876: END
// every 1 1$0 + 0 0$5.5 do
12877: GO 12879
12879: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
12880: LD_INT 59
12882: PPUSH
12883: LD_EXP 24
12887: PPUSH
12888: CALL_OW 321
12892: PUSH
12893: LD_INT 2
12895: EQUAL
12896: NOT
12897: PUSH
12898: LD_OWVAR 1
12902: PUSH
12903: LD_EXP 54
12907: GREATEREQUAL
12908: AND
12909: IFFALSE 12926
// SetTech ( tech_Comp3 , rus , state_researched ) ;
12911: LD_INT 59
12913: PPUSH
12914: LD_EXP 24
12918: PPUSH
12919: LD_INT 2
12921: PPUSH
12922: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
12926: LD_INT 50
12928: PPUSH
12929: LD_EXP 24
12933: PPUSH
12934: CALL_OW 321
12938: PUSH
12939: LD_INT 2
12941: EQUAL
12942: NOT
12943: PUSH
12944: LD_OWVAR 1
12948: PUSH
12949: LD_EXP 55
12953: GREATEREQUAL
12954: AND
12955: IFFALSE 12972
// SetTech ( tech_Tech3 , rus , state_researched ) ;
12957: LD_INT 50
12959: PPUSH
12960: LD_EXP 24
12964: PPUSH
12965: LD_INT 2
12967: PPUSH
12968: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
12972: LD_INT 53
12974: PPUSH
12975: LD_EXP 24
12979: PPUSH
12980: CALL_OW 321
12984: PUSH
12985: LD_INT 2
12987: EQUAL
12988: NOT
12989: PUSH
12990: LD_OWVAR 1
12994: PUSH
12995: LD_EXP 56
12999: GREATEREQUAL
13000: AND
13001: IFFALSE 13018
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13003: LD_INT 53
13005: PPUSH
13006: LD_EXP 24
13010: PPUSH
13011: LD_INT 2
13013: PPUSH
13014: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13018: LD_INT 56
13020: PPUSH
13021: LD_EXP 24
13025: PPUSH
13026: CALL_OW 321
13030: PUSH
13031: LD_INT 2
13033: EQUAL
13034: NOT
13035: PUSH
13036: LD_OWVAR 1
13040: PUSH
13041: LD_EXP 57
13045: GREATEREQUAL
13046: AND
13047: IFFALSE 13064
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13049: LD_INT 56
13051: PPUSH
13052: LD_EXP 24
13056: PPUSH
13057: LD_INT 2
13059: PPUSH
13060: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13064: LD_INT 65
13066: PPUSH
13067: LD_EXP 24
13071: PPUSH
13072: CALL_OW 321
13076: PUSH
13077: LD_INT 2
13079: EQUAL
13080: NOT
13081: PUSH
13082: LD_OWVAR 1
13086: PUSH
13087: LD_EXP 58
13091: GREATEREQUAL
13092: AND
13093: IFFALSE 13110
// SetTech ( tech_ST3 , rus , state_researched ) ;
13095: LD_INT 65
13097: PPUSH
13098: LD_EXP 24
13102: PPUSH
13103: LD_INT 2
13105: PPUSH
13106: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13110: LD_INT 59
13112: PPUSH
13113: LD_EXP 24
13117: PPUSH
13118: CALL_OW 321
13122: PUSH
13123: LD_INT 2
13125: EQUAL
13126: PUSH
13127: LD_INT 50
13129: PPUSH
13130: LD_EXP 24
13134: PPUSH
13135: CALL_OW 321
13139: PUSH
13140: LD_INT 2
13142: EQUAL
13143: AND
13144: PUSH
13145: LD_INT 53
13147: PPUSH
13148: LD_EXP 24
13152: PPUSH
13153: CALL_OW 321
13157: PUSH
13158: LD_INT 2
13160: EQUAL
13161: AND
13162: PUSH
13163: LD_INT 56
13165: PPUSH
13166: LD_EXP 24
13170: PPUSH
13171: CALL_OW 321
13175: PUSH
13176: LD_INT 2
13178: EQUAL
13179: AND
13180: PUSH
13181: LD_INT 65
13183: PPUSH
13184: LD_EXP 24
13188: PPUSH
13189: CALL_OW 321
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: AND
13198: NOT
13199: IFFALSE 13202
// enable ;
13201: ENABLE
// end ; end_of_file
13202: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13203: GO 13205
13205: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13206: LD_ADDR_EXP 63
13210: PUSH
13211: LD_INT 14
13213: PUSH
13214: LD_INT 18
13216: PUSH
13217: LD_INT 19
13219: PUSH
13220: LD_INT 20
13222: PUSH
13223: LD_INT 21
13225: PUSH
13226: LD_INT 22
13228: PUSH
13229: LD_INT 23
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13241: LD_ADDR_EXP 64
13245: PUSH
13246: LD_INT 22
13248: PUSH
13249: LD_EXP 24
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: PUSH
13258: LD_INT 21
13260: PUSH
13261: LD_INT 3
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PPUSH
13272: CALL_OW 69
13276: PUSH
13277: LD_INT 14
13279: PUSH
13280: LD_INT 15
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: ADD
13287: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13288: LD_ADDR_EXP 65
13292: PUSH
13293: LD_INT 22
13295: PUSH
13296: LD_EXP 24
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: PUSH
13305: LD_INT 30
13307: PUSH
13308: LD_INT 1
13310: PUSH
13311: EMPTY
13312: LIST
13313: LIST
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PPUSH
13319: CALL_OW 69
13323: PUSH
13324: LD_INT 1
13326: ARRAY
13327: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13328: LD_ADDR_EXP 66
13332: PUSH
13333: LD_INT 22
13335: PUSH
13336: LD_EXP 24
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: LD_INT 30
13347: PUSH
13348: LD_INT 8
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: PPUSH
13359: CALL_OW 69
13363: PUSH
13364: LD_INT 1
13366: ARRAY
13367: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13368: LD_ADDR_EXP 67
13372: PUSH
13373: LD_INT 22
13375: PUSH
13376: LD_EXP 24
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: LD_INT 30
13387: PUSH
13388: LD_INT 31
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PPUSH
13399: CALL_OW 69
13403: PUSH
13404: LD_INT 1
13406: ARRAY
13407: ST_TO_ADDR
// enable ( 401 ) ;
13408: LD_INT 401
13410: ENABLE_MARKED
// end ;
13411: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13412: GO 13414
13414: DISABLE
13415: LD_INT 0
13417: PPUSH
13418: PPUSH
13419: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13420: LD_EXP 62
13424: PPUSH
13425: CALL_OW 386
13429: NOT
13430: IFFALSE 13485
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13432: LD_ADDR_EXP 62
13436: PUSH
13437: LD_INT 100
13439: PPUSH
13440: LD_EXP 63
13444: PPUSH
13445: LD_EXP 64
13449: PUSH
13450: LD_EXP 63
13454: ADD
13455: PPUSH
13456: LD_INT 1
13458: PUSH
13459: LD_INT 23
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 10
13468: PUSH
13469: LD_INT 22
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 414
13484: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13485: LD_EXP 65
13489: PPUSH
13490: CALL_OW 300
13494: PUSH
13495: LD_EXP 66
13499: PPUSH
13500: CALL_OW 300
13504: OR
13505: PUSH
13506: LD_EXP 67
13510: PPUSH
13511: CALL_OW 300
13515: OR
13516: IFFALSE 13742
// begin for un in rus_mcrep_units do
13518: LD_ADDR_VAR 0 1
13522: PUSH
13523: LD_EXP 63
13527: PUSH
13528: FOR_IN
13529: IFFALSE 13740
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13531: LD_VAR 0 1
13535: PPUSH
13536: CALL_OW 388
13540: PUSH
13541: LD_INT 0
13543: EQUAL
13544: PUSH
13545: LD_VAR 0 1
13549: PPUSH
13550: CALL_OW 256
13554: PUSH
13555: LD_INT 1000
13557: EQUAL
13558: AND
13559: IFFALSE 13726
// case GetClass ( un ) of class_engineer :
13561: LD_VAR 0 1
13565: PPUSH
13566: CALL_OW 257
13570: PUSH
13571: LD_INT 2
13573: DOUBLE
13574: EQUAL
13575: IFTRUE 13579
13577: GO 13623
13579: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13580: LD_EXP 65
13584: PPUSH
13585: CALL_OW 300
13589: PUSH
13590: LD_EXP 65
13594: PPUSH
13595: CALL_OW 313
13599: PUSH
13600: LD_INT 6
13602: EQUAL
13603: NOT
13604: AND
13605: IFFALSE 13621
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13607: LD_VAR 0 1
13611: PPUSH
13612: LD_EXP 65
13616: PPUSH
13617: CALL_OW 120
13621: GO 13724
13623: LD_INT 4
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13675
13631: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13632: LD_EXP 66
13636: PPUSH
13637: CALL_OW 300
13641: PUSH
13642: LD_EXP 66
13646: PPUSH
13647: CALL_OW 313
13651: PUSH
13652: LD_INT 6
13654: EQUAL
13655: NOT
13656: AND
13657: IFFALSE 13673
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13659: LD_VAR 0 1
13663: PPUSH
13664: LD_EXP 66
13668: PPUSH
13669: CALL_OW 120
13673: GO 13724
13675: LD_INT 1
13677: DOUBLE
13678: EQUAL
13679: IFTRUE 13683
13681: GO 13723
13683: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13684: LD_EXP 67
13688: PPUSH
13689: CALL_OW 300
13693: PUSH
13694: LD_EXP 67
13698: PPUSH
13699: CALL_OW 313
13703: NOT
13704: AND
13705: IFFALSE 13721
// ComEnterUnit ( un , rus_breastwork ) ; end else
13707: LD_VAR 0 1
13711: PPUSH
13712: LD_EXP 67
13716: PPUSH
13717: CALL_OW 120
13721: GO 13724
13723: POP
13724: GO 13738
// ComMoveToArea ( un , BluekherRepairArea ) ;
13726: LD_VAR 0 1
13730: PPUSH
13731: LD_INT 23
13733: PPUSH
13734: CALL_OW 113
13738: GO 13528
13740: POP
13741: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13742: LD_ADDR_VAR 0 3
13746: PUSH
13747: LD_INT 22
13749: PPUSH
13750: LD_INT 22
13752: PUSH
13753: LD_EXP 24
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PUSH
13762: LD_INT 2
13764: PUSH
13765: LD_INT 25
13767: PUSH
13768: LD_INT 2
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: PUSH
13775: LD_INT 25
13777: PUSH
13778: LD_INT 4
13780: PUSH
13781: EMPTY
13782: LIST
13783: LIST
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: LIST
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: PPUSH
13794: CALL_OW 71
13798: ST_TO_ADDR
// if filter then
13799: LD_VAR 0 3
13803: IFFALSE 13820
// ComMoveXY ( filter , 48 , 88 ) ;
13805: LD_VAR 0 3
13809: PPUSH
13810: LD_INT 48
13812: PPUSH
13813: LD_INT 88
13815: PPUSH
13816: CALL_OW 111
// enable ;
13820: ENABLE
// end ; end_of_file
13821: PPOPN 3
13823: END
// every 0 0$2 + 0 0$0.1 do
13824: GO 13826
13826: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
13827: LD_INT 22
13829: PUSH
13830: LD_INT 7
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: PUSH
13837: LD_INT 2
13839: PUSH
13840: LD_INT 25
13842: PUSH
13843: LD_INT 12
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: PUSH
13850: LD_INT 25
13852: PUSH
13853: LD_INT 16
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: PUSH
13860: LD_INT 25
13862: PUSH
13863: LD_INT 15
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: PUSH
13870: LD_INT 25
13872: PUSH
13873: LD_INT 17
13875: PUSH
13876: EMPTY
13877: LIST
13878: LIST
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: PPUSH
13891: CALL_OW 69
13895: PUSH
13896: LD_INT 22
13898: PUSH
13899: LD_INT 7
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PUSH
13906: LD_INT 21
13908: PUSH
13909: LD_INT 1
13911: PUSH
13912: EMPTY
13913: LIST
13914: LIST
13915: PUSH
13916: LD_INT 3
13918: PUSH
13919: LD_INT 2
13921: PUSH
13922: LD_INT 25
13924: PUSH
13925: LD_INT 12
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: LD_INT 25
13934: PUSH
13935: LD_INT 16
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: PUSH
13942: LD_INT 25
13944: PUSH
13945: LD_INT 15
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 25
13954: PUSH
13955: LD_INT 17
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 69
13982: GREATER
13983: IFFALSE 13994
// begin SetAchievement ( ACH_POTA ) ;
13985: LD_STRING ACH_POTA
13987: PPUSH
13988: CALL_OW 543
// exit ;
13992: GO 13995
// end ; enable ;
13994: ENABLE
// end ; end_of_file
13995: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
13996: LD_INT 0
13998: PPUSH
13999: PPUSH
// if not missionNumber then
14000: LD_VAR 0 2
14004: NOT
14005: IFFALSE 14009
// exit ;
14007: GO 14139
// achiv := false ;
14009: LD_ADDR_VAR 0 7
14013: PUSH
14014: LD_INT 0
14016: ST_TO_ADDR
// case campaignNumber of 1 :
14017: LD_VAR 0 1
14021: PUSH
14022: LD_INT 1
14024: DOUBLE
14025: EQUAL
14026: IFTRUE 14030
14028: GO 14041
14030: POP
// achiv := ACH_GOTA ; 2 :
14031: LD_ADDR_VAR 0 7
14035: PUSH
14036: LD_STRING ACH_GOTA
14038: ST_TO_ADDR
14039: GO 14091
14041: LD_INT 2
14043: DOUBLE
14044: EQUAL
14045: IFTRUE 14049
14047: GO 14052
14049: POP
// ; 3 :
14050: GO 14091
14052: LD_INT 3
14054: DOUBLE
14055: EQUAL
14056: IFTRUE 14060
14058: GO 14071
14060: POP
// achiv := ACH_MOTSU ; 4 :
14061: LD_ADDR_VAR 0 7
14065: PUSH
14066: LD_STRING ACH_MOTSU
14068: ST_TO_ADDR
14069: GO 14091
14071: LD_INT 4
14073: DOUBLE
14074: EQUAL
14075: IFTRUE 14079
14077: GO 14090
14079: POP
// achiv := ACH_LOP ; end ;
14080: LD_ADDR_VAR 0 7
14084: PUSH
14085: LD_STRING ACH_LOP
14087: ST_TO_ADDR
14088: GO 14091
14090: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14091: LD_OWVAR 67
14095: PUSH
14096: LD_INT 3
14098: EQUAL
14099: PUSH
14100: LD_VAR 0 7
14104: AND
14105: PUSH
14106: LD_VAR 0 3
14110: AND
14111: PUSH
14112: LD_VAR 0 4
14116: AND
14117: PUSH
14118: LD_VAR 0 5
14122: AND
14123: IFFALSE 14139
// SetAchievementEX ( achiv , missionNumber ) ;
14125: LD_VAR 0 7
14129: PPUSH
14130: LD_VAR 0 2
14134: PPUSH
14135: CALL_OW 564
// end ;
14139: LD_VAR 0 6
14143: RET
// export function SA_BehemothConstructed ; begin
14144: LD_INT 0
14146: PPUSH
// SetAchievement ( ACH_SMC ) ;
14147: LD_STRING ACH_SMC
14149: PPUSH
14150: CALL_OW 543
// end ;
14154: LD_VAR 0 1
14158: RET

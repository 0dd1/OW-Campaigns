// export You , Amici , Rusi , You2 , Rusi2 , You3 , NoLosses ; export belkov_returns , belkov_american_clash ; export belkovSave ; starting begin InitVars ;
   0: CALL 1496 0 0
// disable_prediction = true ;
   4: LD_ADDR_OWVAR 50
   8: PUSH
   9: LD_INT 1
  11: ST_TO_ADDR
// debug_strings = [ ] ;
  12: LD_ADDR_OWVAR 48
  16: PUSH
  17: EMPTY
  18: ST_TO_ADDR
// RandomizeAll ;
  19: CALL_OW 11
// InitHc ;
  23: CALL_OW 19
// InitUc ;
  27: CALL_OW 18
// InitVc ;
  31: CALL_OW 20
// You = 3 ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 3
  42: ST_TO_ADDR
// Rusi = You ;
  43: LD_ADDR_EXP 3
  47: PUSH
  48: LD_EXP 1
  52: ST_TO_ADDR
// Amici = 1 ;
  53: LD_ADDR_EXP 2
  57: PUSH
  58: LD_INT 1
  60: ST_TO_ADDR
// You2 = 6 ;
  61: LD_ADDR_EXP 4
  65: PUSH
  66: LD_INT 6
  68: ST_TO_ADDR
// You3 = 5 ;
  69: LD_ADDR_EXP 6
  73: PUSH
  74: LD_INT 5
  76: ST_TO_ADDR
// Rusi2 = You2 ;
  77: LD_ADDR_EXP 5
  81: PUSH
  82: LD_EXP 4
  86: ST_TO_ADDR
// NoLosses := true ;
  87: LD_ADDR_EXP 7
  91: PUSH
  92: LD_INT 1
  94: ST_TO_ADDR
// belkovSave = false ;
  95: LD_ADDR_EXP 10
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// belkov_returns = false ;
 103: LD_ADDR_EXP 8
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// belkov_american_clash = false ;
 111: LD_ADDR_EXP 9
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// set_difficulty ;
 119: CALL 5082 0 0
// load_postav ;
 123: CALL 1338 0 0
// create_rusi_navic ;
 127: CALL 16191 0 0
// amici_breast ;
 131: CALL 3745 0 0
// create_amici_past ;
 135: CALL 3976 0 0
// create_amici_staveni_w ;
 139: CALL 4122 0 0
// create_utok_na_belkova ;
 143: CALL 4359 0 0
// create_vojaci_zacatek ;
 147: CALL 4618 0 0
// uklid_rusu ;
 151: CALL 13148 0 0
// InGameOn ;
 155: CALL_OW 8
// ChangeSideFog ( You , You2 ) ;
 159: LD_EXP 1
 163: PPUSH
 164: LD_EXP 4
 168: PPUSH
 169: CALL_OW 343
// InGameOn ;
 173: CALL_OW 8
// CenterOnXY ( 117 , 101 ) ;
 177: LD_INT 117
 179: PPUSH
 180: LD_INT 101
 182: PPUSH
 183: CALL_OW 84
// end ;
 187: END
// on UnitDestroyed ( un ) do begin if un = bur then
 188: LD_VAR 0 1
 192: PUSH
 193: LD_EXP 50
 197: EQUAL
 198: IFFALSE 207
// YouLost ( Burlak ) ;
 200: LD_STRING Burlak
 202: PPUSH
 203: CALL_OW 104
// enable ;
 207: ENABLE
// end ;
 208: PPOPN 1
 210: END
// on HumanDestroyed ( un , side , nat , x , y , dir , sex , cl ) do begin if ( side = You ) then
 211: LD_VAR 0 2
 215: PUSH
 216: LD_EXP 1
 220: EQUAL
 221: IFFALSE 231
// NoLosses := false ;
 223: LD_ADDR_EXP 7
 227: PUSH
 228: LD_INT 0
 230: ST_TO_ADDR
// end ;
 231: PPOPN 8
 233: END
// export function konec_mise_utok ; begin
 234: LD_INT 0
 236: PPUSH
// YouLost ( SelfAttack ) ;
 237: LD_STRING SelfAttack
 239: PPUSH
 240: CALL_OW 104
// end ;
 244: LD_VAR 0 1
 248: RET
// export function konec_mise ; var i , pom , pom1 ; var zivi ; var drv ; var a , b , c , d , e , f ; var budovy ; var material ; var bw ; var all_lidi ; var lidi ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
 267: PPUSH
// DisableExclamations ;
 268: CALL_OW 474
// gained_medals := [ ] ;
 272: LD_ADDR_OWVAR 61
 276: PUSH
 277: EMPTY
 278: ST_TO_ADDR
// missing_medals := [ ] ;
 279: LD_ADDR_OWVAR 62
 283: PUSH
 284: EMPTY
 285: ST_TO_ADDR
// zivi = 0 ;
 286: LD_ADDR_VAR 0 5
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// if NoLosses then
 294: LD_EXP 7
 298: IFFALSE 312
// AddMedal ( NoLosses , 1 ) else
 300: LD_STRING NoLosses
 302: PPUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 101
 310: GO 323
// AddMedal ( NoLosses , - 1 ) ;
 312: LD_STRING NoLosses
 314: PPUSH
 315: LD_INT 1
 317: NEG
 318: PPUSH
 319: CALL_OW 101
// if BelkovFreed then
 323: LD_EXP 16
 327: IFFALSE 402
// if IsOK ( bel ) then
 329: LD_EXP 52
 333: PPUSH
 334: CALL_OW 302
 338: IFFALSE 352
// AddMedal ( Belkov , 1 ) else
 340: LD_STRING Belkov
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL_OW 101
 350: GO 400
// if UnitFilter ( BelkovComp , [ f_OK ] ) + 0 > 0 then
 352: LD_EXP 17
 356: PPUSH
 357: LD_INT 50
 359: PUSH
 360: EMPTY
 361: LIST
 362: PPUSH
 363: CALL_OW 72
 367: PUSH
 368: LD_INT 0
 370: PLUS
 371: PUSH
 372: LD_INT 0
 374: GREATER
 375: IFFALSE 389
// AddMedal ( Belkov , 2 ) else
 377: LD_STRING Belkov
 379: PPUSH
 380: LD_INT 2
 382: PPUSH
 383: CALL_OW 101
 387: GO 400
// AddMedal ( Belkov , - 3 ) else
 389: LD_STRING Belkov
 391: PPUSH
 392: LD_INT 3
 394: NEG
 395: PPUSH
 396: CALL_OW 101
 400: GO 442
// if objBelkov and belkovSave = false then
 402: LD_EXP 28
 406: PUSH
 407: LD_EXP 10
 411: PUSH
 412: LD_INT 0
 414: EQUAL
 415: AND
 416: IFFALSE 431
// AddMedal ( Belkov , - 2 ) else
 418: LD_STRING Belkov
 420: PPUSH
 421: LD_INT 2
 423: NEG
 424: PPUSH
 425: CALL_OW 101
 429: GO 442
// AddMedal ( Belkov , - 1 ) ;
 431: LD_STRING Belkov
 433: PPUSH
 434: LD_INT 1
 436: NEG
 437: PPUSH
 438: CALL_OW 101
// case stav_utoku of 1 :
 442: LD_EXP 59
 446: PUSH
 447: LD_INT 1
 449: DOUBLE
 450: EQUAL
 451: IFTRUE 455
 453: GO 468
 455: POP
// AddMedal ( Initiative , 1 ) ; 2 :
 456: LD_STRING Initiative
 458: PPUSH
 459: LD_INT 1
 461: PPUSH
 462: CALL_OW 101
 466: GO 523
 468: LD_INT 2
 470: DOUBLE
 471: EQUAL
 472: IFTRUE 476
 474: GO 490
 476: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
 477: LD_STRING Initiative
 479: PPUSH
 480: LD_INT 2
 482: NEG
 483: PPUSH
 484: CALL_OW 101
 488: GO 523
 490: LD_INT 3
 492: DOUBLE
 493: EQUAL
 494: IFTRUE 498
 496: GO 512
 498: POP
// AddMedal ( Initiative , - 1 ) ; else
 499: LD_STRING Initiative
 501: PPUSH
 502: LD_INT 1
 504: NEG
 505: PPUSH
 506: CALL_OW 101
 510: GO 523
 512: POP
// AddMedal ( Initiative , 1 ) ; end ;
 513: LD_STRING Initiative
 515: PPUSH
 516: LD_INT 1
 518: PPUSH
 519: CALL_OW 101
// GiveMedals ( Main ) ;
 523: LD_STRING Main
 525: PPUSH
 526: CALL_OW 102
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_human ] ] ) ;
 530: LD_ADDR_VAR 0 3
 534: PUSH
 535: LD_INT 22
 537: PUSH
 538: LD_EXP 1
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 21
 549: PUSH
 550: LD_INT 1
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: PPUSH
 561: CALL_OW 69
 565: ST_TO_ADDR
// pom1 = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
 566: LD_ADDR_VAR 0 4
 570: PUSH
 571: LD_INT 22
 573: PUSH
 574: LD_EXP 1
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 21
 585: PUSH
 586: LD_INT 2
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: PPUSH
 597: CALL_OW 69
 601: ST_TO_ADDR
// for i in pom1 do
 602: LD_ADDR_VAR 0 2
 606: PUSH
 607: LD_VAR 0 4
 611: PUSH
 612: FOR_IN
 613: IFFALSE 672
// if IsDrivenBy ( i ) then
 615: LD_VAR 0 2
 619: PPUSH
 620: CALL_OW 311
 624: IFFALSE 670
// begin drv = IsDrivenBy ( i ) ;
 626: LD_ADDR_VAR 0 6
 630: PUSH
 631: LD_VAR 0 2
 635: PPUSH
 636: CALL_OW 311
 640: ST_TO_ADDR
// if not ( drv in pom ) then
 641: LD_VAR 0 6
 645: PUSH
 646: LD_VAR 0 3
 650: IN
 651: NOT
 652: IFFALSE 670
// pom = pom ^ drv ;
 654: LD_ADDR_VAR 0 3
 658: PUSH
 659: LD_VAR 0 3
 663: PUSH
 664: LD_VAR 0 6
 668: ADD
 669: ST_TO_ADDR
// end ;
 670: GO 612
 672: POP
 673: POP
// all_lidi = pom ;
 674: LD_ADDR_VAR 0 16
 678: PUSH
 679: LD_VAR 0 3
 683: ST_TO_ADDR
// RewardPeople ( all_lidi ) ;
 684: LD_VAR 0 16
 688: PPUSH
 689: CALL_OW 43
// SaveCharacters ( bur , Burlak ) ;
 693: LD_EXP 50
 697: PPUSH
 698: LD_STRING Burlak
 700: PPUSH
 701: CALL_OW 38
// SaveCharacters ( plat , Platonov ) ;
 705: LD_EXP 54
 709: PPUSH
 710: LD_STRING Platonov
 712: PPUSH
 713: CALL_OW 38
// SaveCharacters ( kurin , Kurin ) ;
 717: LD_EXP 53
 721: PPUSH
 722: LD_STRING Kurin
 724: PPUSH
 725: CALL_OW 38
// SaveCharacters ( bel , Belkov ) ;
 729: LD_EXP 52
 733: PPUSH
 734: LD_STRING Belkov
 736: PPUSH
 737: CALL_OW 38
// SaveCharacters ( gny , Gnyevko ) ;
 741: LD_EXP 49
 745: PPUSH
 746: LD_STRING Gnyevko
 748: PPUSH
 749: CALL_OW 38
// SaveCharacters ( kov , Kovalyuk ) ;
 753: LD_EXP 51
 757: PPUSH
 758: LD_STRING Kovalyuk
 760: PPUSH
 761: CALL_OW 38
// all_lidi = pom diff [ bur , plat , kurin , bel , gny , kov ] ;
 765: LD_ADDR_VAR 0 16
 769: PUSH
 770: LD_VAR 0 3
 774: PUSH
 775: LD_EXP 50
 779: PUSH
 780: LD_EXP 54
 784: PUSH
 785: LD_EXP 53
 789: PUSH
 790: LD_EXP 52
 794: PUSH
 795: LD_EXP 49
 799: PUSH
 800: LD_EXP 51
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: DIFF
 813: ST_TO_ADDR
// all_lidi = all_lidi union rusi_survivors ;
 814: LD_ADDR_VAR 0 16
 818: PUSH
 819: LD_VAR 0 16
 823: PUSH
 824: LD_EXP 58
 828: UNION
 829: ST_TO_ADDR
// SaveCharacters ( all_lidi , survivors1 ) ;
 830: LD_VAR 0 16
 834: PPUSH
 835: LD_STRING survivors1
 837: PPUSH
 838: CALL_OW 38
// if BelkovFreed then
 842: LD_EXP 16
 846: IFFALSE 860
// SaveVariable ( 1 , belkov_saved ) else
 848: LD_INT 1
 850: PPUSH
 851: LD_STRING belkov_saved
 853: PPUSH
 854: CALL_OW 39
 858: GO 870
// SaveVariable ( 0 , belkov_saved ) ;
 860: LD_INT 0
 862: PPUSH
 863: LD_STRING belkov_saved
 865: PPUSH
 866: CALL_OW 39
// case stav_utoku of 0 :
 870: LD_EXP 59
 874: PUSH
 875: LD_INT 0
 877: DOUBLE
 878: EQUAL
 879: IFTRUE 883
 881: GO 896
 883: POP
// SaveVariable ( 3 , utok_stav ) ; 1 :
 884: LD_INT 3
 886: PPUSH
 887: LD_STRING utok_stav
 889: PPUSH
 890: CALL_OW 39
 894: GO 960
 896: LD_INT 1
 898: DOUBLE
 899: EQUAL
 900: IFTRUE 904
 902: GO 917
 904: POP
// SaveVariable ( 1 , utok_stav ) ; 2 :
 905: LD_INT 1
 907: PPUSH
 908: LD_STRING utok_stav
 910: PPUSH
 911: CALL_OW 39
 915: GO 960
 917: LD_INT 2
 919: DOUBLE
 920: EQUAL
 921: IFTRUE 925
 923: GO 938
 925: POP
// SaveVariable ( 2 , utok_stav ) ; 3 :
 926: LD_INT 2
 928: PPUSH
 929: LD_STRING utok_stav
 931: PPUSH
 932: CALL_OW 39
 936: GO 960
 938: LD_INT 3
 940: DOUBLE
 941: EQUAL
 942: IFTRUE 946
 944: GO 959
 946: POP
// SaveVariable ( 3 , utok_stav ) ; end ;
 947: LD_INT 3
 949: PPUSH
 950: LD_STRING utok_stav
 952: PPUSH
 953: CALL_OW 39
 957: GO 960
 959: POP
// budovy = [ ] ;
 960: LD_ADDR_VAR 0 13
 964: PUSH
 965: EMPTY
 966: ST_TO_ADDR
// bw = 0 ;
 967: LD_ADDR_VAR 0 15
 971: PUSH
 972: LD_INT 0
 974: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_building ] ] ) ;
 975: LD_ADDR_VAR 0 3
 979: PUSH
 980: LD_INT 22
 982: PUSH
 983: LD_EXP 1
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: LD_INT 21
 994: PUSH
 995: LD_INT 3
 997: PUSH
 998: EMPTY
 999: LIST
1000: LIST
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: PPUSH
1006: CALL_OW 69
1010: ST_TO_ADDR
// for i in pom do
1011: LD_ADDR_VAR 0 2
1015: PUSH
1016: LD_VAR 0 3
1020: PUSH
1021: FOR_IN
1022: IFFALSE 1178
// begin a = GetBType ( i ) ;
1024: LD_ADDR_VAR 0 7
1028: PUSH
1029: LD_VAR 0 2
1033: PPUSH
1034: CALL_OW 266
1038: ST_TO_ADDR
// b = GetBLevel ( i ) ;
1039: LD_ADDR_VAR 0 8
1043: PUSH
1044: LD_VAR 0 2
1048: PPUSH
1049: CALL_OW 267
1053: ST_TO_ADDR
// c = GetX ( i ) ;
1054: LD_ADDR_VAR 0 9
1058: PUSH
1059: LD_VAR 0 2
1063: PPUSH
1064: CALL_OW 250
1068: ST_TO_ADDR
// d = GetY ( i ) ;
1069: LD_ADDR_VAR 0 10
1073: PUSH
1074: LD_VAR 0 2
1078: PPUSH
1079: CALL_OW 251
1083: ST_TO_ADDR
// e = GetDir ( i ) ;
1084: LD_ADDR_VAR 0 11
1088: PUSH
1089: LD_VAR 0 2
1093: PPUSH
1094: CALL_OW 254
1098: ST_TO_ADDR
// f = GetNation ( i ) ;
1099: LD_ADDR_VAR 0 12
1103: PUSH
1104: LD_VAR 0 2
1108: PPUSH
1109: CALL_OW 248
1113: ST_TO_ADDR
// pom1 = [ a , b , c , d , e , f ] ;
1114: LD_ADDR_VAR 0 4
1118: PUSH
1119: LD_VAR 0 7
1123: PUSH
1124: LD_VAR 0 8
1128: PUSH
1129: LD_VAR 0 9
1133: PUSH
1134: LD_VAR 0 10
1138: PUSH
1139: LD_VAR 0 11
1143: PUSH
1144: LD_VAR 0 12
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: ST_TO_ADDR
// budovy = budovy ^ [ pom1 ] ;
1157: LD_ADDR_VAR 0 13
1161: PUSH
1162: LD_VAR 0 13
1166: PUSH
1167: LD_VAR 0 4
1171: PUSH
1172: EMPTY
1173: LIST
1174: ADD
1175: ST_TO_ADDR
// end ;
1176: GO 1021
1178: POP
1179: POP
// SaveVariable ( budovy , budovy ) ;
1180: LD_VAR 0 13
1184: PPUSH
1185: LD_STRING budovy
1187: PPUSH
1188: CALL_OW 39
// if isOK ( am_bre1 ) then
1192: LD_INT 30
1194: PPUSH
1195: CALL_OW 302
1199: IFFALSE 1215
// bw = bw + 1 ;
1201: LD_ADDR_VAR 0 15
1205: PUSH
1206: LD_VAR 0 15
1210: PUSH
1211: LD_INT 1
1213: PLUS
1214: ST_TO_ADDR
// if IsOK ( am_bre2 ) then
1215: LD_INT 31
1217: PPUSH
1218: CALL_OW 302
1222: IFFALSE 1238
// bw = bw + 2 ;
1224: LD_ADDR_VAR 0 15
1228: PUSH
1229: LD_VAR 0 15
1233: PUSH
1234: LD_INT 2
1236: PLUS
1237: ST_TO_ADDR
// SaveVariable ( bw , bw_east ) ;
1238: LD_VAR 0 15
1242: PPUSH
1243: LD_STRING bw_east
1245: PPUSH
1246: CALL_OW 39
// pom = [ ] ;
1250: LD_ADDR_VAR 0 3
1254: PUSH
1255: EMPTY
1256: ST_TO_ADDR
// if ISOK ( ABW1 ) then
1257: LD_EXP 76
1261: PPUSH
1262: CALL_OW 302
1266: IFFALSE 1284
// pom = pom ^ ABW1 ;
1268: LD_ADDR_VAR 0 3
1272: PUSH
1273: LD_VAR 0 3
1277: PUSH
1278: LD_EXP 76
1282: ADD
1283: ST_TO_ADDR
// if ISOK ( ABW2 ) then
1284: LD_EXP 77
1288: PPUSH
1289: CALL_OW 302
1293: IFFALSE 1311
// pom = pom ^ ABW2 ;
1295: LD_ADDR_VAR 0 3
1299: PUSH
1300: LD_VAR 0 3
1304: PUSH
1305: LD_EXP 77
1309: ADD
1310: ST_TO_ADDR
// SaveCharacters ( pom , amici_bw ) ;
1311: LD_VAR 0 3
1315: PPUSH
1316: LD_STRING amici_bw
1318: PPUSH
1319: CALL_OW 38
// YouWin ;
1323: CALL_OW 103
// EnableExclamations ;
1327: CALL_OW 473
// exit ;
1331: GO 1333
// end ;
1333: LD_VAR 0 1
1337: RET
// function load_postav ; begin
1338: LD_INT 0
1340: PPUSH
// kurin = NewCharacter ( kurin ) ;
1341: LD_ADDR_EXP 53
1345: PUSH
1346: LD_STRING kurin
1348: PPUSH
1349: CALL_OW 25
1353: ST_TO_ADDR
// if CheckCharacterSet ( Belkov ) then
1354: LD_STRING Belkov
1356: PPUSH
1357: CALL_OW 29
1361: IFFALSE 1373
// BELKOV_MRTVY = false else
1363: LD_ADDR_EXP 46
1367: PUSH
1368: LD_INT 0
1370: ST_TO_ADDR
1371: GO 1381
// BELKOV_MRTVY = true ;
1373: LD_ADDR_EXP 46
1377: PUSH
1378: LD_INT 1
1380: ST_TO_ADDR
// if BELKOV_MRTVY then
1381: LD_EXP 46
1385: IFFALSE 1402
// begin bel = NewCharacter ( Belkov2 ) ;
1387: LD_ADDR_EXP 52
1391: PUSH
1392: LD_STRING Belkov2
1394: PPUSH
1395: CALL_OW 25
1399: ST_TO_ADDR
// end else
1400: GO 1415
// bel = nacti_osobu ( Belkov ) ;
1402: LD_ADDR_EXP 52
1406: PUSH
1407: LD_STRING Belkov
1409: PPUSH
1410: CALL 4925 0 1
1414: ST_TO_ADDR
// kov = NewCharacter ( Kovalyuk ) ;
1415: LD_ADDR_EXP 51
1419: PUSH
1420: LD_STRING Kovalyuk
1422: PPUSH
1423: CALL_OW 25
1427: ST_TO_ADDR
// bur = nacti_osobu ( Burlak ) ;
1428: LD_ADDR_EXP 50
1432: PUSH
1433: LD_STRING Burlak
1435: PPUSH
1436: CALL 4925 0 1
1440: ST_TO_ADDR
// gny = nacti_osobu ( Gnyevko ) ;
1441: LD_ADDR_EXP 49
1445: PUSH
1446: LD_STRING Gnyevko
1448: PPUSH
1449: CALL 4925 0 1
1453: ST_TO_ADDR
// plat = NewCharacter ( Platonov ) ;
1454: LD_ADDR_EXP 54
1458: PUSH
1459: LD_STRING Platonov
1461: PPUSH
1462: CALL_OW 25
1466: ST_TO_ADDR
// DoNotAttack ( 1 , plat ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_EXP 54
1474: PPUSH
1475: CALL_OW 471
// DoNotAttack ( 4 , plat ) ;
1479: LD_INT 4
1481: PPUSH
1482: LD_EXP 54
1486: PPUSH
1487: CALL_OW 471
// end ; end_of_file
1491: LD_VAR 0 1
1495: RET
// export CarCount , WBW , EBW , BurlakComp , BurlakOut , BelkovFreed , BelkovComp , WBWSpotted , WBWAttacked , WBWDestroyed , WBWReported , EBWSpotted , EBWDestroyed , EBWReported , Charted , QAttAm , objAttack , objBelkov , objReturn , Reinforcements , InWest , BeriaVisited , CanReturn , playing , d19a , McCestaNaSever ; export function InitVars ; begin
1496: LD_INT 0
1498: PPUSH
// CarCount = 0 ;
1499: LD_ADDR_EXP 11
1503: PUSH
1504: LD_INT 0
1506: ST_TO_ADDR
// WBWSpotted := false ;
1507: LD_ADDR_EXP 18
1511: PUSH
1512: LD_INT 0
1514: ST_TO_ADDR
// WBWAttacked := false ;
1515: LD_ADDR_EXP 19
1519: PUSH
1520: LD_INT 0
1522: ST_TO_ADDR
// WBWDestroyed := false ;
1523: LD_ADDR_EXP 20
1527: PUSH
1528: LD_INT 0
1530: ST_TO_ADDR
// WBWReported := false ;
1531: LD_ADDR_EXP 21
1535: PUSH
1536: LD_INT 0
1538: ST_TO_ADDR
// EBWSpotted := false ;
1539: LD_ADDR_EXP 22
1543: PUSH
1544: LD_INT 0
1546: ST_TO_ADDR
// EBWDestroyed := false ;
1547: LD_ADDR_EXP 23
1551: PUSH
1552: LD_INT 0
1554: ST_TO_ADDR
// EBWReported := false ;
1555: LD_ADDR_EXP 24
1559: PUSH
1560: LD_INT 0
1562: ST_TO_ADDR
// BelkovFreed := false ;
1563: LD_ADDR_EXP 16
1567: PUSH
1568: LD_INT 0
1570: ST_TO_ADDR
// BelkovComp := [ ] ;
1571: LD_ADDR_EXP 17
1575: PUSH
1576: EMPTY
1577: ST_TO_ADDR
// QAttAm := false ;
1578: LD_ADDR_EXP 26
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// d19a := false ;
1586: LD_ADDR_EXP 35
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// objAttack := false ;
1594: LD_ADDR_EXP 27
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// Reinforcements := false ;
1602: LD_ADDR_EXP 30
1606: PUSH
1607: LD_INT 0
1609: ST_TO_ADDR
// Charted := false ;
1610: LD_ADDR_EXP 25
1614: PUSH
1615: LD_INT 0
1617: ST_TO_ADDR
// objBelkov := false ;
1618: LD_ADDR_EXP 28
1622: PUSH
1623: LD_INT 0
1625: ST_TO_ADDR
// objReturn := false ;
1626: LD_ADDR_EXP 29
1630: PUSH
1631: LD_INT 0
1633: ST_TO_ADDR
// BeriaVisited := false ;
1634: LD_ADDR_EXP 32
1638: PUSH
1639: LD_INT 0
1641: ST_TO_ADDR
// InWest := false ;
1642: LD_ADDR_EXP 31
1646: PUSH
1647: LD_INT 0
1649: ST_TO_ADDR
// playing := false ;
1650: LD_ADDR_EXP 34
1654: PUSH
1655: LD_INT 0
1657: ST_TO_ADDR
// EBW := [ Am_bre1 , Am_bre2 ] ;
1658: LD_ADDR_EXP 13
1662: PUSH
1663: LD_INT 30
1665: PUSH
1666: LD_INT 31
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: ST_TO_ADDR
// BurlakOut := [ ] ;
1673: LD_ADDR_EXP 15
1677: PUSH
1678: EMPTY
1679: ST_TO_ADDR
// CanReturn := false ;
1680: LD_ADDR_EXP 33
1684: PUSH
1685: LD_INT 0
1687: ST_TO_ADDR
// McCestaNaSever := 0 ;
1688: LD_ADDR_EXP 36
1692: PUSH
1693: LD_INT 0
1695: ST_TO_ADDR
// disable ( 99 ) ;
1696: LD_INT 99
1698: DISABLE_MARKED
// disable ( 100 ) ;
1699: LD_INT 100
1701: DISABLE_MARKED
// disable ( 101 ) ;
1702: LD_INT 101
1704: DISABLE_MARKED
// disable ( 300 ) ;
1705: LD_INT 300
1707: DISABLE_MARKED
// disable ( 301 ) ;
1708: LD_INT 301
1710: DISABLE_MARKED
// disable ( 302 ) ;
1711: LD_INT 302
1713: DISABLE_MARKED
// end ;
1714: LD_VAR 0 1
1718: RET
// function ListAttacks ( who , whom ) ; var i ; begin
1719: LD_INT 0
1721: PPUSH
1722: PPUSH
// result := false ;
1723: LD_ADDR_VAR 0 3
1727: PUSH
1728: LD_INT 0
1730: ST_TO_ADDR
// for i in who do
1731: LD_ADDR_VAR 0 4
1735: PUSH
1736: LD_VAR 0 1
1740: PUSH
1741: FOR_IN
1742: IFFALSE 1773
// begin if Attacks ( i ) in whom then
1744: LD_VAR 0 4
1748: PPUSH
1749: CALL_OW 320
1753: PUSH
1754: LD_VAR 0 2
1758: IN
1759: IFFALSE 1771
// begin result := true ;
1761: LD_ADDR_VAR 0 3
1765: PUSH
1766: LD_INT 1
1768: ST_TO_ADDR
// break end ;
1769: GO 1773
// end ;
1771: GO 1741
1773: POP
1774: POP
// end ;
1775: LD_VAR 0 3
1779: RET
// function ListSee ( side , who ) ; var i ; begin
1780: LD_INT 0
1782: PPUSH
1783: PPUSH
// result := false ;
1784: LD_ADDR_VAR 0 3
1788: PUSH
1789: LD_INT 0
1791: ST_TO_ADDR
// for i in who do
1792: LD_ADDR_VAR 0 4
1796: PUSH
1797: LD_VAR 0 2
1801: PUSH
1802: FOR_IN
1803: IFFALSE 1833
// begin if see ( side , i ) then
1805: LD_VAR 0 1
1809: PPUSH
1810: LD_VAR 0 4
1814: PPUSH
1815: CALL_OW 292
1819: IFFALSE 1831
// begin result := true ;
1821: LD_ADDR_VAR 0 3
1825: PUSH
1826: LD_INT 1
1828: ST_TO_ADDR
// break ;
1829: GO 1833
// end ; end ;
1831: GO 1802
1833: POP
1834: POP
// end ;
1835: LD_VAR 0 3
1839: RET
// function BurlakInArea ( area ) ; var i , pom , hum ; begin
1840: LD_INT 0
1842: PPUSH
1843: PPUSH
1844: PPUSH
1845: PPUSH
// hum := [ ] ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: EMPTY
1852: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , you ] , [ f_ready ] ] ) ;
1853: LD_ADDR_VAR 0 4
1857: PUSH
1858: LD_VAR 0 1
1862: PPUSH
1863: LD_INT 22
1865: PUSH
1866: LD_EXP 1
1870: PUSH
1871: EMPTY
1872: LIST
1873: LIST
1874: PUSH
1875: LD_INT 53
1877: PUSH
1878: EMPTY
1879: LIST
1880: PUSH
1881: EMPTY
1882: LIST
1883: LIST
1884: PPUSH
1885: CALL_OW 70
1889: ST_TO_ADDR
// for i in pom do
1890: LD_ADDR_VAR 0 3
1894: PUSH
1895: LD_VAR 0 4
1899: PUSH
1900: FOR_IN
1901: IFFALSE 1987
// begin if GetType ( i ) = unit_human then
1903: LD_VAR 0 3
1907: PPUSH
1908: CALL_OW 247
1912: PUSH
1913: LD_INT 1
1915: EQUAL
1916: IFFALSE 1934
// begin hum := hum ^ i ;
1918: LD_ADDR_VAR 0 5
1922: PUSH
1923: LD_VAR 0 5
1927: PUSH
1928: LD_VAR 0 3
1932: ADD
1933: ST_TO_ADDR
// end ; if ( GetType ( i ) = unit_building ) or ( GetType ( i ) = unit_vehicle ) then
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 247
1943: PUSH
1944: LD_INT 3
1946: EQUAL
1947: PUSH
1948: LD_VAR 0 3
1952: PPUSH
1953: CALL_OW 247
1957: PUSH
1958: LD_INT 2
1960: EQUAL
1961: OR
1962: IFFALSE 1985
// begin hum := hum union UnitsInside ( i ) ;
1964: LD_ADDR_VAR 0 5
1968: PUSH
1969: LD_VAR 0 5
1973: PUSH
1974: LD_VAR 0 3
1978: PPUSH
1979: CALL_OW 313
1983: UNION
1984: ST_TO_ADDR
// end ; end ;
1985: GO 1900
1987: POP
1988: POP
// if ( hum isect BurlakOut ) > 0 then
1989: LD_VAR 0 5
1993: PUSH
1994: LD_EXP 15
1998: ISECT
1999: PUSH
2000: LD_INT 0
2002: GREATER
2003: IFFALSE 2015
// result := true else
2005: LD_ADDR_VAR 0 2
2009: PUSH
2010: LD_INT 1
2012: ST_TO_ADDR
2013: GO 2023
// result := false ;
2015: LD_ADDR_VAR 0 2
2019: PUSH
2020: LD_INT 0
2022: ST_TO_ADDR
// end ;
2023: LD_VAR 0 2
2027: RET
// export function MissionProper ; begin
2028: LD_INT 0
2030: PPUSH
// enable ( 99 ) ;
2031: LD_INT 99
2033: ENABLE_MARKED
// enable ( 100 ) ;
2034: LD_INT 100
2036: ENABLE_MARKED
// CanReturn := false ;
2037: LD_ADDR_EXP 33
2041: PUSH
2042: LD_INT 0
2044: ST_TO_ADDR
// end ;
2045: LD_VAR 0 1
2049: RET
// function ShouldReturn ; begin
2050: LD_INT 0
2052: PPUSH
// if Charted and ( BelkovFreed or ( not objBelkov ) ) and ( WBWDestroyed or ( not objAttack ) ) and ( not objReturn ) then
2053: LD_EXP 25
2057: PUSH
2058: LD_EXP 16
2062: PUSH
2063: LD_EXP 28
2067: NOT
2068: OR
2069: AND
2070: PUSH
2071: LD_EXP 20
2075: PUSH
2076: LD_EXP 27
2080: NOT
2081: OR
2082: AND
2083: PUSH
2084: LD_EXP 29
2088: NOT
2089: AND
2090: IFFALSE 2107
// begin ChangeMissionObjectives ( M10a ) ;
2092: LD_STRING M10a
2094: PPUSH
2095: CALL_OW 337
// objReturn := true ;
2099: LD_ADDR_EXP 29
2103: PUSH
2104: LD_INT 1
2106: ST_TO_ADDR
// end ; end ;
2107: LD_VAR 0 1
2111: RET
// on VehicleConstructed ( veh , fact ) do begin CarCount := CarCount + 1 ;
2112: LD_ADDR_EXP 11
2116: PUSH
2117: LD_EXP 11
2121: PUSH
2122: LD_INT 1
2124: PLUS
2125: ST_TO_ADDR
// if CarCount = 1 then
2126: LD_EXP 11
2130: PUSH
2131: LD_INT 1
2133: EQUAL
2134: IFFALSE 2139
// enable ( 300 ) ;
2136: LD_INT 300
2138: ENABLE_MARKED
// if CarCount = UnitFilter ( Rusi_enter , [ f_OK ] ) and not belkov_returns then
2139: LD_EXP 11
2143: PUSH
2144: LD_EXP 55
2148: PPUSH
2149: LD_INT 50
2151: PUSH
2152: EMPTY
2153: LIST
2154: PPUSH
2155: CALL_OW 72
2159: EQUAL
2160: PUSH
2161: LD_EXP 8
2165: NOT
2166: AND
2167: IFFALSE 2177
// belkov_returns = true ;
2169: LD_ADDR_EXP 8
2173: PUSH
2174: LD_INT 1
2176: ST_TO_ADDR
// if CarCount = UnitFilter ( Rusi_enter , [ f_OK ] ) + 1 and not belkov_american_clash then
2177: LD_EXP 11
2181: PUSH
2182: LD_EXP 55
2186: PPUSH
2187: LD_INT 50
2189: PUSH
2190: EMPTY
2191: LIST
2192: PPUSH
2193: CALL_OW 72
2197: PUSH
2198: LD_INT 1
2200: PLUS
2201: EQUAL
2202: PUSH
2203: LD_EXP 9
2207: NOT
2208: AND
2209: IFFALSE 2219
// belkov_american_clash = true ;
2211: LD_ADDR_EXP 9
2215: PUSH
2216: LD_INT 1
2218: ST_TO_ADDR
// end ;
2219: PPOPN 2
2221: END
// every 0 0$1 trigger belkov_american_clash do
2222: LD_EXP 9
2226: IFFALSE 2243
2228: GO 2230
2230: DISABLE
// begin rozhovor_ukonceni_m5 ;
2231: CALL 8500 0 0
// stav = 7 ;
2235: LD_ADDR_EXP 60
2239: PUSH
2240: LD_INT 7
2242: ST_TO_ADDR
// end ;
2243: END
// every 0 0$5 trigger ( ListSee ( you , WBW ) or ListAttacks ( WBW , BurlakOut ) ) and ( not WBWDestroyed ) do
2244: LD_EXP 1
2248: PPUSH
2249: LD_EXP 12
2253: PPUSH
2254: CALL 1780 0 2
2258: PUSH
2259: LD_EXP 12
2263: PPUSH
2264: LD_EXP 15
2268: PPUSH
2269: CALL 1719 0 2
2273: OR
2274: PUSH
2275: LD_EXP 20
2279: NOT
2280: AND
2281: IFFALSE 2535
2283: GO 2285
2285: DISABLE
// begin if BurlakInArea ( kopec ) then
2286: LD_INT 26
2288: PPUSH
2289: CALL 1840 0 1
2293: IFFALSE 2303
// begin InWest := true ;
2295: LD_ADDR_EXP 31
2299: PUSH
2300: LD_INT 1
2302: ST_TO_ADDR
// end ; if not WBWSpotted then
2303: LD_EXP 18
2307: NOT
2308: IFFALSE 2314
// begin play_dialog_15 ;
2310: CALL 10788 0 0
// end ; WBWSpotted := true ;
2314: LD_ADDR_EXP 18
2318: PUSH
2319: LD_INT 1
2321: ST_TO_ADDR
// if InWest and ( not QAttAm ) and ( not objAttack ) then
2322: LD_EXP 31
2326: PUSH
2327: LD_EXP 26
2331: NOT
2332: AND
2333: PUSH
2334: LD_EXP 27
2338: NOT
2339: AND
2340: IFFALSE 2459
// begin case query ( QAttackBw ) of 1 :
2342: LD_STRING QAttackBw
2344: PPUSH
2345: CALL_OW 97
2349: PUSH
2350: LD_INT 1
2352: DOUBLE
2353: EQUAL
2354: IFTRUE 2358
2356: GO 2373
2358: POP
// begin play_dialog_qwbw1 ;
2359: CALL 10993 0 0
// stav_utoku := 1 ;
2363: LD_ADDR_EXP 59
2367: PUSH
2368: LD_INT 1
2370: ST_TO_ADDR
// end ; 2 :
2371: GO 2432
2373: LD_INT 2
2375: DOUBLE
2376: EQUAL
2377: IFTRUE 2381
2379: GO 2412
2381: POP
// begin play_dialog_qwbw2 ;
2382: CALL 11080 0 0
// posily_go := true ;
2386: LD_ADDR_EXP 68
2390: PUSH
2391: LD_INT 1
2393: ST_TO_ADDR
// Reinforcements := true ;
2394: LD_ADDR_EXP 30
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// stav_utoku := 2 ;
2402: LD_ADDR_EXP 59
2406: PUSH
2407: LD_INT 2
2409: ST_TO_ADDR
// end ; 3 :
2410: GO 2432
2412: LD_INT 3
2414: DOUBLE
2415: EQUAL
2416: IFTRUE 2420
2418: GO 2431
2420: POP
// begin stav_utoku := 3 end ; end ;
2421: LD_ADDR_EXP 59
2425: PUSH
2426: LD_INT 3
2428: ST_TO_ADDR
2429: GO 2432
2431: POP
// ChangeMissionObjectives ( M7 ) ;
2432: LD_STRING M7
2434: PPUSH
2435: CALL_OW 337
// objAttack := true ;
2439: LD_ADDR_EXP 27
2443: PUSH
2444: LD_INT 1
2446: ST_TO_ADDR
// play_dialog_19 ;
2447: CALL 11167 0 0
// WBWAttacked := true ;
2451: LD_ADDR_EXP 19
2455: PUSH
2456: LD_INT 1
2458: ST_TO_ADDR
// end ; if ( not InWest ) and ListAttacks ( BurlakOut , WBW ) and ( not d19a ) then
2459: LD_EXP 31
2463: NOT
2464: PUSH
2465: LD_EXP 15
2469: PPUSH
2470: LD_EXP 12
2474: PPUSH
2475: CALL 1719 0 2
2479: AND
2480: PUSH
2481: LD_EXP 35
2485: NOT
2486: AND
2487: IFFALSE 2524
// begin wait ( 0 0$5 ) ;
2489: LD_INT 175
2491: PPUSH
2492: CALL_OW 67
// if ListAttacks ( BurlakOut , WBW ) then
2496: LD_EXP 15
2500: PPUSH
2501: LD_EXP 12
2505: PPUSH
2506: CALL 1719 0 2
2510: IFFALSE 2524
// begin play_dialog_19a ;
2512: CALL 11278 0 0
// d19a := true ;
2516: LD_ADDR_EXP 35
2520: PUSH
2521: LD_INT 1
2523: ST_TO_ADDR
// end ; end ; if ( not InWest ) then
2524: LD_EXP 31
2528: NOT
2529: IFFALSE 2534
// enable else
2531: ENABLE
2532: GO 2535
// disable ;
2534: DISABLE
// end ;
2535: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_OK ] , [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) do var pom ;
2536: LD_INT 9
2538: PPUSH
2539: LD_INT 50
2541: PUSH
2542: EMPTY
2543: LIST
2544: PUSH
2545: LD_INT 22
2547: PUSH
2548: LD_EXP 2
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PUSH
2557: LD_INT 30
2559: PUSH
2560: LD_INT 31
2562: PUSH
2563: EMPTY
2564: LIST
2565: LIST
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: LIST
2571: PPUSH
2572: CALL_OW 70
2576: IFFALSE 2711
2578: GO 2580
2580: DISABLE
2581: LD_INT 0
2583: PPUSH
// begin pom := FilterUnitsInArea ( Am_base , [ [ f_OK ] , [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
2584: LD_ADDR_VAR 0 1
2588: PUSH
2589: LD_INT 9
2591: PPUSH
2592: LD_INT 50
2594: PUSH
2595: EMPTY
2596: LIST
2597: PUSH
2598: LD_INT 22
2600: PUSH
2601: LD_EXP 2
2605: PUSH
2606: EMPTY
2607: LIST
2608: LIST
2609: PUSH
2610: LD_INT 30
2612: PUSH
2613: LD_INT 31
2615: PUSH
2616: EMPTY
2617: LIST
2618: LIST
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: LIST
2624: PPUSH
2625: CALL_OW 70
2629: ST_TO_ADDR
// BWW_1 = pom [ 1 ] ;
2630: LD_ADDR_EXP 74
2634: PUSH
2635: LD_VAR 0 1
2639: PUSH
2640: LD_INT 1
2642: ARRAY
2643: ST_TO_ADDR
// enable ( 101 ) ;
2644: LD_INT 101
2646: ENABLE_MARKED
// WBW := [ BWW_1 ] ;
2647: LD_ADDR_EXP 12
2651: PUSH
2652: LD_EXP 74
2656: PUSH
2657: EMPTY
2658: LIST
2659: ST_TO_ADDR
// if pom + 0 > 1 then
2660: LD_VAR 0 1
2664: PUSH
2665: LD_INT 0
2667: PLUS
2668: PUSH
2669: LD_INT 1
2671: GREATER
2672: IFFALSE 2710
// begin BWW_2 := pom [ 2 ] ;
2674: LD_ADDR_EXP 75
2678: PUSH
2679: LD_VAR 0 1
2683: PUSH
2684: LD_INT 2
2686: ARRAY
2687: ST_TO_ADDR
// WBW := WBW ^ [ BWW_2 ] ;
2688: LD_ADDR_EXP 12
2692: PUSH
2693: LD_EXP 12
2697: PUSH
2698: LD_EXP 75
2702: PUSH
2703: EMPTY
2704: LIST
2705: ADD
2706: ST_TO_ADDR
// disable ;
2707: DISABLE
// end else
2708: GO 2711
// begin enable ;
2710: ENABLE
// end ; end ;
2711: PPOPN 1
2713: END
// every 0 0$3 trigger ( UnitFilter ( WBW , [ [ f_OK ] , [ f_side , amici ] ] ) = 0 ) marked 101 do
2714: LD_EXP 12
2718: PPUSH
2719: LD_INT 50
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: LD_INT 22
2727: PUSH
2728: LD_EXP 2
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: PPUSH
2741: CALL_OW 72
2745: PUSH
2746: LD_INT 0
2748: EQUAL
2749: IFFALSE 2784
2751: GO 2753
2753: DISABLE
// begin play_dialog_20 ;
2754: CALL 11510 0 0
// WBWDestroyed := true ;
2758: LD_ADDR_EXP 20
2762: PUSH
2763: LD_INT 1
2765: ST_TO_ADDR
// if objAttack then
2766: LD_EXP 27
2770: IFFALSE 2779
// ChangeMissionObjectives ( M8 ) ;
2772: LD_STRING M8
2774: PPUSH
2775: CALL_OW 337
// ShouldReturn ;
2779: CALL 2050 0 0
// disable end ;
2783: DISABLE
2784: END
// every 0 0$5 trigger ListSee ( you , EBW ) or ListAttacks ( EBW , BurlakOut ) do var pom ;
2785: LD_EXP 1
2789: PPUSH
2790: LD_EXP 13
2794: PPUSH
2795: CALL 1780 0 2
2799: PUSH
2800: LD_EXP 13
2804: PPUSH
2805: LD_EXP 15
2809: PPUSH
2810: CALL 1719 0 2
2814: OR
2815: IFFALSE 2836
2817: GO 2819
2819: DISABLE
2820: LD_INT 0
2822: PPUSH
// begin play_dialog_16 ;
2823: CALL 11365 0 0
// EBWSpotted := true ;
2827: LD_ADDR_EXP 22
2831: PUSH
2832: LD_INT 1
2834: ST_TO_ADDR
// disable ;
2835: DISABLE
// end ;
2836: PPOPN 1
2838: END
// every 0 0$3 trigger ( UnitFilter ( EBW , [ f_OK ] ) = 0 ) do
2839: LD_EXP 13
2843: PPUSH
2844: LD_INT 50
2846: PUSH
2847: EMPTY
2848: LIST
2849: PPUSH
2850: CALL_OW 72
2854: PUSH
2855: LD_INT 0
2857: EQUAL
2858: IFFALSE 2876
2860: GO 2862
2862: DISABLE
// begin play_dialog_20a ;
2863: CALL 11573 0 0
// EBWDestroyed := true ;
2867: LD_ADDR_EXP 23
2871: PUSH
2872: LD_INT 1
2874: ST_TO_ADDR
// disable end ;
2875: DISABLE
2876: END
// every 0 0$5 trigger ( BurlakInArea ( Test4 ) ) do
2877: LD_INT 12
2879: PPUSH
2880: CALL 1840 0 1
2884: IFFALSE 2982
2886: GO 2888
2888: DISABLE
// begin if ( not objBelkov ) and ( IsOK ( Bel ) ) then
2889: LD_EXP 28
2893: NOT
2894: PUSH
2895: LD_EXP 52
2899: PPUSH
2900: CALL_OW 302
2904: AND
2905: IFFALSE 2973
// begin objBelkov := true ;
2907: LD_ADDR_EXP 28
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
// case query ( QAttackAm ) of 1 :
2915: LD_STRING QAttackAm
2917: PPUSH
2918: CALL_OW 97
2922: PUSH
2923: LD_INT 1
2925: DOUBLE
2926: EQUAL
2927: IFTRUE 2931
2929: GO 2938
2931: POP
// play_dialog_qAtAm1 ; 2 :
2932: CALL 11636 0 0
2936: GO 2962
2938: LD_INT 2
2940: DOUBLE
2941: EQUAL
2942: IFTRUE 2946
2944: GO 2961
2946: POP
// begin play_dialog_qAtAm2 ;
2947: CALL 11699 0 0
// posily_go = true ;
2951: LD_ADDR_EXP 68
2955: PUSH
2956: LD_INT 1
2958: ST_TO_ADDR
// end ; end ;
2959: GO 2962
2961: POP
// ChangeMissionObjectives ( M9 ) ;
2962: LD_STRING M9
2964: PPUSH
2965: CALL_OW 337
// play_dialog_23 ;
2969: CALL 11815 0 0
// end ; QAttAm := true ;
2973: LD_ADDR_EXP 26
2977: PUSH
2978: LD_INT 1
2980: ST_TO_ADDR
// disable end ;
2981: DISABLE
2982: END
// every 0 0$5 trigger ( BurlakInArea ( belkov_kop ) ) do var i ;
2983: LD_INT 25
2985: PPUSH
2986: CALL 1840 0 1
2990: IFFALSE 3139
2992: GO 2994
2994: DISABLE
2995: LD_INT 0
2997: PPUSH
// begin if ( not objBelkov ) then
2998: LD_EXP 28
3002: NOT
3003: IFFALSE 3007
// exit ;
3005: GO 3139
// play_dialog_24 ;
3007: CALL 11889 0 0
// BelkovFreed := true ;
3011: LD_ADDR_EXP 16
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// if objBelkov then
3019: LD_EXP 28
3023: IFFALSE 3032
// ChangeMissionObjectives ( M9a ) ;
3025: LD_STRING M9a
3027: PPUSH
3028: CALL_OW 337
// if ( WBWSpotted ) and ( not WBWDestroyed ) and ( not objAttack ) then
3032: LD_EXP 18
3036: PUSH
3037: LD_EXP 20
3041: NOT
3042: AND
3043: PUSH
3044: LD_EXP 27
3048: NOT
3049: AND
3050: IFFALSE 3075
// begin ChangeMissionObjectives ( M7 ) ;
3052: LD_STRING M7
3054: PPUSH
3055: CALL_OW 337
// objAttack := true ;
3059: LD_ADDR_EXP 27
3063: PUSH
3064: LD_INT 1
3066: ST_TO_ADDR
// stav_utoku := 1 ;
3067: LD_ADDR_EXP 59
3071: PUSH
3072: LD_INT 1
3074: ST_TO_ADDR
// end ; BelkovComp = FilterUnitsInArea ( Belkov_kop_prebarvi , [ [ f_side , You2 ] ] ) ;
3075: LD_ADDR_EXP 17
3079: PUSH
3080: LD_INT 31
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_EXP 4
3090: PUSH
3091: EMPTY
3092: LIST
3093: LIST
3094: PUSH
3095: EMPTY
3096: LIST
3097: PPUSH
3098: CALL_OW 70
3102: ST_TO_ADDR
// for i in BelkovComp do
3103: LD_ADDR_VAR 0 1
3107: PUSH
3108: LD_EXP 17
3112: PUSH
3113: FOR_IN
3114: IFFALSE 3132
// SetSide ( i , You ) ;
3116: LD_VAR 0 1
3120: PPUSH
3121: LD_EXP 1
3125: PPUSH
3126: CALL_OW 235
3130: GO 3113
3132: POP
3133: POP
// ShouldReturn ;
3134: CALL 2050 0 0
// disable end ;
3138: DISABLE
3139: PPOPN 1
3141: END
// every 0 0$10 do var pom ;
3142: GO 3144
3144: DISABLE
3145: LD_INT 0
3147: PPUSH
// begin pom = SeeGreyArea ( You , Narea ) ;
3148: LD_ADDR_VAR 0 1
3152: PUSH
3153: LD_EXP 1
3157: PPUSH
3158: LD_INT 24
3160: PPUSH
3161: CALL_OW 452
3165: ST_TO_ADDR
// if pom >= procento_odkrytych_pro_vyhru [ difficulty ] then
3166: LD_VAR 0 1
3170: PUSH
3171: LD_EXP 42
3175: PUSH
3176: LD_OWVAR 67
3180: ARRAY
3181: GREATEREQUAL
3182: IFFALSE 3205
// begin ChangeMissionObjectives ( M10 ) ;
3184: LD_STRING M10
3186: PPUSH
3187: CALL_OW 337
// Charted := true ;
3191: LD_ADDR_EXP 25
3195: PUSH
3196: LD_INT 1
3198: ST_TO_ADDR
// ShouldReturn ;
3199: CALL 2050 0 0
// end else
3203: GO 3206
// enable ;
3205: ENABLE
// end ;
3206: PPOPN 1
3208: END
// every 0 0$5 trigger ( not BurlakInArea ( RU2_base ) ) marked 99 do var i ;
3209: LD_INT 1
3211: PPUSH
3212: CALL 1840 0 1
3216: NOT
3217: IFFALSE 3337
3219: GO 3221
3221: DISABLE
3222: LD_INT 0
3224: PPUSH
// begin BurlakComp := UnitFilter ( BurlakComp , [ f_alive ] ) ;
3225: LD_ADDR_EXP 14
3229: PUSH
3230: LD_EXP 14
3234: PPUSH
3235: LD_INT 51
3237: PUSH
3238: EMPTY
3239: LIST
3240: PPUSH
3241: CALL_OW 72
3245: ST_TO_ADDR
// BurlakOut := [ ] ;
3246: LD_ADDR_EXP 15
3250: PUSH
3251: EMPTY
3252: ST_TO_ADDR
// for i in BurlakComp do
3253: LD_ADDR_VAR 0 1
3257: PUSH
3258: LD_EXP 14
3262: PUSH
3263: FOR_IN
3264: IFFALSE 3302
// begin if ( not IsInArea ( i , Ru2_base ) ) then
3266: LD_VAR 0 1
3270: PPUSH
3271: LD_INT 1
3273: PPUSH
3274: CALL_OW 308
3278: NOT
3279: IFFALSE 3300
// BurlakOut := BurlakOut ^ [ i ] ;
3281: LD_ADDR_EXP 15
3285: PUSH
3286: LD_EXP 15
3290: PUSH
3291: LD_VAR 0 1
3295: PUSH
3296: EMPTY
3297: LIST
3298: ADD
3299: ST_TO_ADDR
// end ;
3300: GO 3263
3302: POP
3303: POP
// if BurlakOut + 0 > 0 then
3304: LD_EXP 15
3308: PUSH
3309: LD_INT 0
3311: PLUS
3312: PUSH
3313: LD_INT 0
3315: GREATER
3316: IFFALSE 3328
// CanReturn := true else
3318: LD_ADDR_EXP 33
3322: PUSH
3323: LD_INT 1
3325: ST_TO_ADDR
3326: GO 3336
// CanReturn := false ;
3328: LD_ADDR_EXP 33
3332: PUSH
3333: LD_INT 0
3335: ST_TO_ADDR
// enable ;
3336: ENABLE
// end ;
3337: PPOPN 1
3339: END
// every 0 0$5 trigger ( BurlakInArea ( RU2_base ) ) marked 100 do var i ;
3340: LD_INT 1
3342: PPUSH
3343: CALL 1840 0 1
3347: IFFALSE 3684
3349: GO 3351
3351: DISABLE
3352: LD_INT 0
3354: PPUSH
// begin enable ;
3355: ENABLE
// if objReturn then
3356: LD_EXP 29
3360: IFFALSE 3413
// begin for i in BurlakComp do
3362: LD_ADDR_VAR 0 1
3366: PUSH
3367: LD_EXP 14
3371: PUSH
3372: FOR_IN
3373: IFFALSE 3396
// begin if not IsInArea ( i , RU2_base ) then
3375: LD_VAR 0 1
3379: PPUSH
3380: LD_INT 1
3382: PPUSH
3383: CALL_OW 308
3387: NOT
3388: IFFALSE 3394
// exit ;
3390: POP
3391: POP
3392: GO 3684
// end ;
3394: GO 3372
3396: POP
3397: POP
// ChangeMissionObjectives ( M10b ) ;
3398: LD_STRING M10b
3400: PPUSH
3401: CALL_OW 337
// objReturn := false ;
3405: LD_ADDR_EXP 29
3409: PUSH
3410: LD_INT 0
3412: ST_TO_ADDR
// end ; if Charted and WBWDestroyed and ( BelkovFreed or not ( IsOK ( Bel ) ) ) then
3413: LD_EXP 25
3417: PUSH
3418: LD_EXP 20
3422: AND
3423: PUSH
3424: LD_EXP 16
3428: PUSH
3429: LD_EXP 52
3433: PPUSH
3434: CALL_OW 302
3438: NOT
3439: OR
3440: AND
3441: IFFALSE 3456
// begin konec_mise ;
3443: CALL 249 0 0
// wait ( 0 0$1 ) ;
3447: LD_INT 35
3449: PPUSH
3450: CALL_OW 67
// exit ;
3454: GO 3684
// end ; if Charted and WBWDestroyed and ( not objBelkov ) and ( IsOK ( Bel ) ) then
3456: LD_EXP 25
3460: PUSH
3461: LD_EXP 20
3465: AND
3466: PUSH
3467: LD_EXP 28
3471: NOT
3472: AND
3473: PUSH
3474: LD_EXP 52
3478: PPUSH
3479: CALL_OW 302
3483: AND
3484: IFFALSE 3538
// begin case Query ( QContMission ) of 1 :
3486: LD_STRING QContMission
3488: PPUSH
3489: CALL_OW 97
3493: PUSH
3494: LD_INT 1
3496: DOUBLE
3497: EQUAL
3498: IFTRUE 3502
3500: GO 3509
3502: POP
// konec_mise ; 2 :
3503: CALL 249 0 0
3507: GO 3536
3509: LD_INT 2
3511: DOUBLE
3512: EQUAL
3513: IFTRUE 3517
3515: GO 3535
3517: POP
// begin ChangeMissionObjectives ( M9 ) ;
3518: LD_STRING M9
3520: PPUSH
3521: CALL_OW 337
// objBelkov := true ;
3525: LD_ADDR_EXP 28
3529: PUSH
3530: LD_INT 1
3532: ST_TO_ADDR
// end ; end ;
3533: GO 3536
3535: POP
// exit ;
3536: GO 3684
// end ; if not CanReturn then
3538: LD_EXP 33
3542: NOT
3543: IFFALSE 3547
// exit ;
3545: GO 3684
// CanReturn := false ;
3547: LD_ADDR_EXP 33
3551: PUSH
3552: LD_INT 0
3554: ST_TO_ADDR
// if ( not WBWDestroyed ) or ( not EBWDestroyed ) then
3555: LD_EXP 20
3559: NOT
3560: PUSH
3561: LD_EXP 23
3565: NOT
3566: OR
3567: IFFALSE 3586
// begin if not BeriaVisited then
3569: LD_EXP 32
3573: NOT
3574: IFFALSE 3582
// play_dialog_25 else
3576: CALL 12085 0 0
3580: GO 3586
// play_dialog_25a ;
3582: CALL 12348 0 0
// end ; BeriaVisited := true ;
3586: LD_ADDR_EXP 32
3590: PUSH
3591: LD_INT 1
3593: ST_TO_ADDR
// if WBWSpotted and ( not WBWDestroyed ) and ( not Reinforcements ) then
3594: LD_EXP 18
3598: PUSH
3599: LD_EXP 20
3603: NOT
3604: AND
3605: PUSH
3606: LD_EXP 30
3610: NOT
3611: AND
3612: IFFALSE 3666
// begin play_dialog_25b ;
3614: CALL 12535 0 0
// posily_go := true ;
3618: LD_ADDR_EXP 68
3622: PUSH
3623: LD_INT 1
3625: ST_TO_ADDR
// Reinforcements := true ;
3626: LD_ADDR_EXP 30
3630: PUSH
3631: LD_INT 1
3633: ST_TO_ADDR
// if ( not objAttack ) then
3634: LD_EXP 27
3638: NOT
3639: IFFALSE 3664
// begin ChangeMissionObjectives ( M7 ) ;
3641: LD_STRING M7
3643: PPUSH
3644: CALL_OW 337
// objAttack := true ;
3648: LD_ADDR_EXP 27
3652: PUSH
3653: LD_INT 1
3655: ST_TO_ADDR
// stav_utoku := 1 ;
3656: LD_ADDR_EXP 59
3660: PUSH
3661: LD_INT 1
3663: ST_TO_ADDR
// end ; exit ;
3664: GO 3684
// end ; if ( not Charted ) or ( not WBWSpotted ) then
3666: LD_EXP 25
3670: NOT
3671: PUSH
3672: LD_EXP 18
3676: NOT
3677: OR
3678: IFFALSE 3684
// begin play_dialog_25c ;
3680: CALL 12586 0 0
// end ; end ; end_of_file
3684: PPOPN 1
3686: END
// export AMICI_PAST_LIST ; export AMICI_STAVENI_BASE_LIST ; export AMICI_UTOK_BELKOV_LIST ; var ah , av ; export function get_human ( sex , clas , level , name ) ; var pom ; begin
3687: LD_INT 0
3689: PPUSH
3690: PPUSH
// PrepareHuman ( sex , clas , level ) ;
3691: LD_VAR 0 1
3695: PPUSH
3696: LD_VAR 0 2
3700: PPUSH
3701: LD_VAR 0 3
3705: PPUSH
3706: CALL_OW 380
// hc_name := name ;
3710: LD_ADDR_OWVAR 26
3714: PUSH
3715: LD_VAR 0 4
3719: ST_TO_ADDR
// pom = CreateHuman ;
3720: LD_ADDR_VAR 0 6
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// result := pom ;
3730: LD_ADDR_VAR 0 5
3734: PUSH
3735: LD_VAR 0 6
3739: ST_TO_ADDR
// end ;
3740: LD_VAR 0 5
3744: RET
// export function amici_breast ; begin
3745: LD_INT 0
3747: PPUSH
// uc_nation = nation_american ;
3748: LD_ADDR_OWVAR 21
3752: PUSH
3753: LD_INT 1
3755: ST_TO_ADDR
// uc_side = Amici ;
3756: LD_ADDR_OWVAR 20
3760: PUSH
3761: LD_EXP 2
3765: ST_TO_ADDR
// ah = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] , David Love ) ;
3766: LD_ADDR_LOC 1
3770: PUSH
3771: LD_INT 1
3773: PPUSH
3774: LD_INT 1
3776: PPUSH
3777: LD_EXP 40
3781: PUSH
3782: LD_OWVAR 67
3786: ARRAY
3787: PPUSH
3788: LD_STRING David Love
3790: PPUSH
3791: CALL 3687 0 4
3795: ST_TO_ADDR
// PlaceUnitXY ( ah , 107 , 63 , false ) ;
3796: LD_LOC 1
3800: PPUSH
3801: LD_INT 107
3803: PPUSH
3804: LD_INT 63
3806: PPUSH
3807: LD_INT 0
3809: PPUSH
3810: CALL_OW 48
// ComMoveXY ( ah , 92 , 56 ) ;
3814: LD_LOC 1
3818: PPUSH
3819: LD_INT 92
3821: PPUSH
3822: LD_INT 56
3824: PPUSH
3825: CALL_OW 111
// ABW1 = ah ;
3829: LD_ADDR_EXP 76
3833: PUSH
3834: LD_LOC 1
3838: ST_TO_ADDR
// AddComEnterUnit ( ah , am_bre1 ) ;
3839: LD_LOC 1
3843: PPUSH
3844: LD_INT 30
3846: PPUSH
3847: CALL_OW 180
// ah = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] , John Kraninger ) ;
3851: LD_ADDR_LOC 1
3855: PUSH
3856: LD_INT 1
3858: PPUSH
3859: LD_INT 1
3861: PPUSH
3862: LD_EXP 40
3866: PUSH
3867: LD_OWVAR 67
3871: ARRAY
3872: PPUSH
3873: LD_STRING John Kraninger
3875: PPUSH
3876: CALL 3687 0 4
3880: ST_TO_ADDR
// PlaceUnitXY ( ah , 106 , 65 , false ) ;
3881: LD_LOC 1
3885: PPUSH
3886: LD_INT 106
3888: PPUSH
3889: LD_INT 65
3891: PPUSH
3892: LD_INT 0
3894: PPUSH
3895: CALL_OW 48
// ComMoveXY ( ah , 95 , 61 ) ;
3899: LD_LOC 1
3903: PPUSH
3904: LD_INT 95
3906: PPUSH
3907: LD_INT 61
3909: PPUSH
3910: CALL_OW 111
// AddComEnterUnit ( ah , am_bre2 ) ;
3914: LD_LOC 1
3918: PPUSH
3919: LD_INT 31
3921: PPUSH
3922: CALL_OW 180
// ABW2 = ah ;
3926: LD_ADDR_EXP 77
3930: PUSH
3931: LD_LOC 1
3935: ST_TO_ADDR
// end ;
3936: LD_VAR 0 1
3940: RET
// function get_sex ; begin
3941: LD_INT 0
3943: PPUSH
// if Prob ( 20 ) then
3944: LD_INT 20
3946: PPUSH
3947: CALL_OW 13
3951: IFFALSE 3963
// result = sex_female else
3953: LD_ADDR_VAR 0 1
3957: PUSH
3958: LD_INT 2
3960: ST_TO_ADDR
3961: GO 3971
// result = sex_male ;
3963: LD_ADDR_VAR 0 1
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// end ;
3971: LD_VAR 0 1
3975: RET
// export function create_amici_past ; var i ; var a ; var p_vojaku ; begin
3976: LD_INT 0
3978: PPUSH
3979: PPUSH
3980: PPUSH
3981: PPUSH
// a = [ ] ;
3982: LD_ADDR_VAR 0 3
3986: PUSH
3987: EMPTY
3988: ST_TO_ADDR
// p_vojaku = amici_past_pocet [ difficulty ] ;
3989: LD_ADDR_VAR 0 4
3993: PUSH
3994: LD_EXP 41
3998: PUSH
3999: LD_OWVAR 67
4003: ARRAY
4004: ST_TO_ADDR
// a = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] + 1 ,  ) ;
4005: LD_ADDR_VAR 0 3
4009: PUSH
4010: LD_INT 1
4012: PPUSH
4013: LD_INT 1
4015: PPUSH
4016: LD_EXP 40
4020: PUSH
4021: LD_OWVAR 67
4025: ARRAY
4026: PUSH
4027: LD_INT 1
4029: PLUS
4030: PPUSH
4031: LD_STRING 
4033: PPUSH
4034: CALL 3687 0 4
4038: ST_TO_ADDR
// for i := 1 to p_vojaku - 1 do
4039: LD_ADDR_VAR 0 2
4043: PUSH
4044: DOUBLE
4045: LD_INT 1
4047: DEC
4048: ST_TO_ADDR
4049: LD_VAR 0 4
4053: PUSH
4054: LD_INT 1
4056: MINUS
4057: PUSH
4058: FOR_TO
4059: IFFALSE 4105
// a = a ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] + 1 ,  ) ;
4061: LD_ADDR_VAR 0 3
4065: PUSH
4066: LD_VAR 0 3
4070: PUSH
4071: CALL 3941 0 0
4075: PPUSH
4076: LD_INT 1
4078: PPUSH
4079: LD_EXP 40
4083: PUSH
4084: LD_OWVAR 67
4088: ARRAY
4089: PUSH
4090: LD_INT 1
4092: PLUS
4093: PPUSH
4094: LD_STRING 
4096: PPUSH
4097: CALL 3687 0 4
4101: ADD
4102: ST_TO_ADDR
4103: GO 4058
4105: POP
4106: POP
// AMICI_PAST_LIST = a ;
4107: LD_ADDR_EXP 37
4111: PUSH
4112: LD_VAR 0 3
4116: ST_TO_ADDR
// end ;
4117: LD_VAR 0 1
4121: RET
// export function create_amici_staveni_w ; var a ; begin
4122: LD_INT 0
4124: PPUSH
4125: PPUSH
// a = get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: CALL 3941 0 0
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_EXP 40
4143: PUSH
4144: LD_OWVAR 67
4148: ARRAY
4149: PPUSH
4150: LD_STRING 
4152: PPUSH
4153: CALL 3687 0 4
4157: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: LD_VAR 0 2
4167: PUSH
4168: CALL 3941 0 0
4172: PPUSH
4173: LD_INT 1
4175: PPUSH
4176: LD_EXP 40
4180: PUSH
4181: LD_OWVAR 67
4185: ARRAY
4186: PPUSH
4187: LD_STRING 
4189: PPUSH
4190: CALL 3687 0 4
4194: ADD
4195: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_engineer , LEVELY_AMICI [ difficulty ] ,  ) ;
4196: LD_ADDR_VAR 0 2
4200: PUSH
4201: LD_VAR 0 2
4205: PUSH
4206: CALL 3941 0 0
4210: PPUSH
4211: LD_INT 2
4213: PPUSH
4214: LD_EXP 40
4218: PUSH
4219: LD_OWVAR 67
4223: ARRAY
4224: PPUSH
4225: LD_STRING 
4227: PPUSH
4228: CALL 3687 0 4
4232: ADD
4233: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_engineer , LEVELY_AMICI [ difficulty ] ,  ) ;
4234: LD_ADDR_VAR 0 2
4238: PUSH
4239: LD_VAR 0 2
4243: PUSH
4244: CALL 3941 0 0
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_EXP 40
4256: PUSH
4257: LD_OWVAR 67
4261: ARRAY
4262: PPUSH
4263: LD_STRING 
4265: PPUSH
4266: CALL 3687 0 4
4270: ADD
4271: ST_TO_ADDR
// AMICI_STAVENI_BASE_LIST = a ;
4272: LD_ADDR_EXP 38
4276: PUSH
4277: LD_VAR 0 2
4281: ST_TO_ADDR
// end ;
4282: LD_VAR 0 1
4286: RET
// export function vyber_cloveka ( list , cla ) ; var i ; var a ; begin
4287: LD_INT 0
4289: PPUSH
4290: PPUSH
4291: PPUSH
// a = 0 ;
4292: LD_ADDR_VAR 0 5
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// for i in list do
4300: LD_ADDR_VAR 0 4
4304: PUSH
4305: LD_VAR 0 1
4309: PUSH
4310: FOR_IN
4311: IFFALSE 4342
// if GetClass ( i ) = cla then
4313: LD_VAR 0 4
4317: PPUSH
4318: CALL_OW 257
4322: PUSH
4323: LD_VAR 0 2
4327: EQUAL
4328: IFFALSE 4340
// a = i ;
4330: LD_ADDR_VAR 0 5
4334: PUSH
4335: LD_VAR 0 4
4339: ST_TO_ADDR
4340: GO 4310
4342: POP
4343: POP
// result = a ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: LD_VAR 0 5
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 3
4358: RET
// export function create_utok_na_belkova ; var pom ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
// uc_side = Amici ;
4363: LD_ADDR_OWVAR 20
4367: PUSH
4368: LD_EXP 2
4372: ST_TO_ADDR
// uc_nation = nation_american ;
4373: LD_ADDR_OWVAR 21
4377: PUSH
4378: LD_INT 1
4380: ST_TO_ADDR
// pom = get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4381: LD_ADDR_VAR 0 2
4385: PUSH
4386: CALL 3941 0 0
4390: PPUSH
4391: LD_INT 1
4393: PPUSH
4394: LD_EXP 40
4398: PUSH
4399: LD_OWVAR 67
4403: ARRAY
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 3687 0 4
4412: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4413: LD_ADDR_VAR 0 2
4417: PUSH
4418: LD_VAR 0 2
4422: PUSH
4423: CALL 3941 0 0
4427: PPUSH
4428: LD_INT 1
4430: PPUSH
4431: LD_EXP 40
4435: PUSH
4436: LD_OWVAR 67
4440: ARRAY
4441: PPUSH
4442: LD_STRING 
4444: PPUSH
4445: CALL 3687 0 4
4449: ADD
4450: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: LD_VAR 0 2
4460: PUSH
4461: CALL 3941 0 0
4465: PPUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_EXP 40
4473: PUSH
4474: LD_OWVAR 67
4478: ARRAY
4479: PPUSH
4480: LD_STRING 
4482: PPUSH
4483: CALL 3687 0 4
4487: ADD
4488: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4489: LD_ADDR_VAR 0 2
4493: PUSH
4494: LD_VAR 0 2
4498: PUSH
4499: CALL 3941 0 0
4503: PPUSH
4504: LD_INT 1
4506: PPUSH
4507: LD_EXP 40
4511: PUSH
4512: LD_OWVAR 67
4516: ARRAY
4517: PPUSH
4518: LD_STRING 
4520: PPUSH
4521: CALL 3687 0 4
4525: ADD
4526: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4527: LD_ADDR_VAR 0 2
4531: PUSH
4532: LD_VAR 0 2
4536: PUSH
4537: CALL 3941 0 0
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_EXP 40
4549: PUSH
4550: LD_OWVAR 67
4554: ARRAY
4555: PPUSH
4556: LD_STRING 
4558: PPUSH
4559: CALL 3687 0 4
4563: ADD
4564: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4565: LD_ADDR_VAR 0 2
4569: PUSH
4570: LD_VAR 0 2
4574: PUSH
4575: CALL 3941 0 0
4579: PPUSH
4580: LD_INT 1
4582: PPUSH
4583: LD_EXP 40
4587: PUSH
4588: LD_OWVAR 67
4592: ARRAY
4593: PPUSH
4594: LD_STRING 
4596: PPUSH
4597: CALL 3687 0 4
4601: ADD
4602: ST_TO_ADDR
// AMICI_UTOK_BELKOV_LIST = pom ;
4603: LD_ADDR_EXP 39
4607: PUSH
4608: LD_VAR 0 2
4612: ST_TO_ADDR
// end ;
4613: LD_VAR 0 1
4617: RET
// export function create_vojaci_zacatek ; var pom_gny ; begin
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
// uc_nation = nation_russian ;
4622: LD_ADDR_OWVAR 21
4626: PUSH
4627: LD_INT 3
4629: ST_TO_ADDR
// uc_side = You ;
4630: LD_ADDR_OWVAR 20
4634: PUSH
4635: LD_EXP 1
4639: ST_TO_ADDR
// SetSide ( Kurin , You2 ) ;
4640: LD_EXP 53
4644: PPUSH
4645: LD_EXP 4
4649: PPUSH
4650: CALL_OW 235
// PlaceUnitXY ( kurin , 121 , 101 , false ) ;
4654: LD_EXP 53
4658: PPUSH
4659: LD_INT 121
4661: PPUSH
4662: LD_INT 101
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 48
// Setclass ( bel , class_soldier ) ;
4672: LD_EXP 52
4676: PPUSH
4677: LD_INT 1
4679: PPUSH
4680: CALL_OW 336
// SetSide ( bel , You2 ) ;
4684: LD_EXP 52
4688: PPUSH
4689: LD_EXP 4
4693: PPUSH
4694: CALL_OW 235
// PlaceUnitXY ( bel , 121 , 104 , false ) ;
4698: LD_EXP 52
4702: PPUSH
4703: LD_INT 121
4705: PPUSH
4706: LD_INT 104
4708: PPUSH
4709: LD_INT 0
4711: PPUSH
4712: CALL_OW 48
// SetSide ( kov , You ) ;
4716: LD_EXP 51
4720: PPUSH
4721: LD_EXP 1
4725: PPUSH
4726: CALL_OW 235
// PlaceUnitXY ( kov , 126 , 105 , false ) ;
4730: LD_EXP 51
4734: PPUSH
4735: LD_INT 126
4737: PPUSH
4738: LD_INT 105
4740: PPUSH
4741: LD_INT 0
4743: PPUSH
4744: CALL_OW 48
// SetClass ( bur , class_mechanic ) ;
4748: LD_EXP 50
4752: PPUSH
4753: LD_INT 3
4755: PPUSH
4756: CALL_OW 336
// SetSide ( bur , You ) ;
4760: LD_EXP 50
4764: PPUSH
4765: LD_EXP 1
4769: PPUSH
4770: CALL_OW 235
// PlaceUnitXY ( bur , 124 , 105 , false ) ;
4774: LD_EXP 50
4778: PPUSH
4779: LD_INT 124
4781: PPUSH
4782: LD_INT 105
4784: PPUSH
4785: LD_INT 0
4787: PPUSH
4788: CALL_OW 48
// if gny <> 0 then
4792: LD_EXP 49
4796: PUSH
4797: LD_INT 0
4799: NONEQUAL
4800: IFFALSE 4848
// begin SetClass ( gny , class_soldier ) ;
4802: LD_EXP 49
4806: PPUSH
4807: LD_INT 1
4809: PPUSH
4810: CALL_OW 336
// SetSide ( gny , You ) ;
4814: LD_EXP 49
4818: PPUSH
4819: LD_EXP 1
4823: PPUSH
4824: CALL_OW 235
// PlaceUnitXY ( gny , 120 , 103 , false ) ;
4828: LD_EXP 49
4832: PPUSH
4833: LD_INT 120
4835: PPUSH
4836: LD_INT 103
4838: PPUSH
4839: LD_INT 0
4841: PPUSH
4842: CALL_OW 48
// end else
4846: GO 4888
// begin pom_gny = get_human ( sex_male , class_soldier , 2 ,  ) ;
4848: LD_ADDR_VAR 0 2
4852: PUSH
4853: LD_INT 1
4855: PPUSH
4856: LD_INT 1
4858: PPUSH
4859: LD_INT 2
4861: PPUSH
4862: LD_STRING 
4864: PPUSH
4865: CALL 3687 0 4
4869: ST_TO_ADDR
// PlaceUnitXY ( pom_gny , 120 , 103 , false ) ;
4870: LD_VAR 0 2
4874: PPUSH
4875: LD_INT 120
4877: PPUSH
4878: LD_INT 103
4880: PPUSH
4881: LD_INT 0
4883: PPUSH
4884: CALL_OW 48
// end ; SetSide ( plat , You3 ) ;
4888: LD_EXP 54
4892: PPUSH
4893: LD_EXP 6
4897: PPUSH
4898: CALL_OW 235
// PlaceUnitXY ( plat , 66 , 90 , false ) ;
4902: LD_EXP 54
4906: PPUSH
4907: LD_INT 66
4909: PPUSH
4910: LD_INT 90
4912: PPUSH
4913: LD_INT 0
4915: PPUSH
4916: CALL_OW 48
// end ;
4920: LD_VAR 0 1
4924: RET
// export function nacti_osobu ( ident ) ; begin
4925: LD_INT 0
4927: PPUSH
// if CheckCharacterSet ( ident ) then
4928: LD_VAR 0 1
4932: PPUSH
4933: CALL_OW 29
4937: IFFALSE 4956
// result := CreateCharacter ( ident ) else
4939: LD_ADDR_VAR 0 2
4943: PUSH
4944: LD_VAR 0 1
4948: PPUSH
4949: CALL_OW 34
4953: ST_TO_ADDR
4954: GO 4964
// result := 0 ;
4956: LD_ADDR_VAR 0 2
4960: PUSH
4961: LD_INT 0
4963: ST_TO_ADDR
// end ;
4964: LD_VAR 0 2
4968: RET
// export function place_amik_k_videni ; begin
4969: LD_INT 0
4971: PPUSH
// uc_side = Amici ;
4972: LD_ADDR_OWVAR 20
4976: PUSH
4977: LD_EXP 2
4981: ST_TO_ADDR
// uc_nation = nation_american ;
4982: LD_ADDR_OWVAR 21
4986: PUSH
4987: LD_INT 1
4989: ST_TO_ADDR
// ah = get_human ( get_sex , class_soldier , 3 ,  ) ;
4990: LD_ADDR_LOC 1
4994: PUSH
4995: CALL 3941 0 0
4999: PPUSH
5000: LD_INT 1
5002: PPUSH
5003: LD_INT 3
5005: PPUSH
5006: LD_STRING 
5008: PPUSH
5009: CALL 3687 0 4
5013: ST_TO_ADDR
// PlaceUnitXYR ( ah , 72 , 28 , 3 , false ) ;
5014: LD_LOC 1
5018: PPUSH
5019: LD_INT 72
5021: PPUSH
5022: LD_INT 28
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 0
5030: PPUSH
5031: CALL_OW 50
// result := ah ;
5035: LD_ADDR_VAR 0 1
5039: PUSH
5040: LD_LOC 1
5044: ST_TO_ADDR
// end ;
5045: LD_VAR 0 1
5049: RET
// every 0 0$1 trigger GetLives ( plat ) < 1000 do
5050: LD_EXP 54
5054: PPUSH
5055: CALL_OW 256
5059: PUSH
5060: LD_INT 1000
5062: LESS
5063: IFFALSE 5081
5065: GO 5067
5067: DISABLE
// begin enable ;
5068: ENABLE
// SetLives ( plat , 1000 ) ;
5069: LD_EXP 54
5073: PPUSH
5074: LD_INT 1000
5076: PPUSH
5077: CALL_OW 234
// end ; end_of_file
5081: END
// export LEVELY_AMICI ; export amici_past_pocet ; export procento_odkrytych_pro_vyhru ; export cas_na_zachranu_belkova ; export levely_bw_na_zapade ; export levely_bw_na_vychode ; export BELKOV_MRTVY ; export function set_difficulty ; begin
5082: LD_INT 0
5084: PPUSH
// LEVELY_AMICI = [ 1 , 2 , 3 ] ;
5085: LD_ADDR_EXP 40
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: LD_INT 2
5095: PUSH
5096: LD_INT 3
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: ST_TO_ADDR
// amici_past_pocet = [ 3 , 5 , 7 ] ;
5104: LD_ADDR_EXP 41
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: LD_INT 5
5114: PUSH
5115: LD_INT 7
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: LIST
5122: ST_TO_ADDR
// procento_odkrytych_pro_vyhru = [ 3400 , 3600 , 3800 ] ;
5123: LD_ADDR_EXP 42
5127: PUSH
5128: LD_INT 3400
5130: PUSH
5131: LD_INT 3600
5133: PUSH
5134: LD_INT 3800
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: LIST
5141: ST_TO_ADDR
// cas_na_zachranu_belkova = [ 20 20$0 , 15 15$0 , 10 10$0 ] ;
5142: LD_ADDR_EXP 43
5146: PUSH
5147: LD_INT 42000
5149: PUSH
5150: LD_INT 31500
5152: PUSH
5153: LD_INT 21000
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: LIST
5160: ST_TO_ADDR
// levely_bw_na_zapade = [ 1 , 2 , 3 ] ;
5161: LD_ADDR_EXP 44
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 3
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: ST_TO_ADDR
// levely_bw_na_vychode = [ 1 , 2 , 3 ] ;
5180: LD_ADDR_EXP 45
5184: PUSH
5185: LD_INT 1
5187: PUSH
5188: LD_INT 2
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: ST_TO_ADDR
// end ;
5199: LD_VAR 0 1
5203: RET
// every 0 0$0.1 do
5204: GO 5206
5206: DISABLE
// begin SetBName ( RU1_dep , kirov ) ;
5207: LD_INT 1
5209: PPUSH
5210: LD_STRING kirov
5212: PPUSH
5213: CALL_OW 500
// SetBName ( RU2_dep , beria ) ;
5217: LD_INT 26
5219: PPUSH
5220: LD_STRING beria
5222: PPUSH
5223: CALL_OW 500
// end ; end_of_file
5227: END
// var prilis_na_north ; var is_out_base ; var wasattack ; var ridic_1_auta ; var je_mimo ; var byl_v_zakladne ; var kecal_s_platonovem ; var znicene_bw ; var bw_e_nasli ; var cont_mission ; var kecy_bw_w ; export navrat_a_konec ; export belkov_solved ; var skurveny_mission_objectiv_uz_prosel ; var konstanta_utoceni ; var kecy_pri_vraceni_belkova ; every 0 0$0.1 do var i ;
5228: GO 5230
5230: DISABLE
5231: LD_INT 0
5233: PPUSH
// begin prilis_na_north = [ 1 , 2 , 4 , 5 , 6 ] ;
5234: LD_ADDR_LOC 3
5238: PUSH
5239: LD_INT 1
5241: PUSH
5242: LD_INT 2
5244: PUSH
5245: LD_INT 4
5247: PUSH
5248: LD_INT 5
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: ST_TO_ADDR
// is_out_base = [ 3 ] ;
5261: LD_ADDR_LOC 4
5265: PUSH
5266: LD_INT 3
5268: PUSH
5269: EMPTY
5270: LIST
5271: ST_TO_ADDR
// bw_e_nasli = false ;
5272: LD_ADDR_LOC 11
5276: PUSH
5277: LD_INT 0
5279: ST_TO_ADDR
// kecy_bw_w = false ;
5280: LD_ADDR_LOC 13
5284: PUSH
5285: LD_INT 0
5287: ST_TO_ADDR
// wasattack = false ;
5288: LD_ADDR_LOC 5
5292: PUSH
5293: LD_INT 0
5295: ST_TO_ADDR
// je_mimo = false ;
5296: LD_ADDR_LOC 7
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// byl_v_zakladne = false ;
5304: LD_ADDR_LOC 8
5308: PUSH
5309: LD_INT 0
5311: ST_TO_ADDR
// kecal_s_platonovem = false ;
5312: LD_ADDR_LOC 9
5316: PUSH
5317: LD_INT 0
5319: ST_TO_ADDR
// znicene_bw = false ;
5320: LD_ADDR_LOC 10
5324: PUSH
5325: LD_INT 0
5327: ST_TO_ADDR
// belkov_solved = 1 ;
5328: LD_ADDR_EXP 48
5332: PUSH
5333: LD_INT 1
5335: ST_TO_ADDR
// konstanta_utoceni = 0 ;
5336: LD_ADDR_LOC 15
5340: PUSH
5341: LD_INT 0
5343: ST_TO_ADDR
// navrat_a_konec = false ;
5344: LD_ADDR_EXP 47
5348: PUSH
5349: LD_INT 0
5351: ST_TO_ADDR
// cont_mission = false ;
5352: LD_ADDR_LOC 12
5356: PUSH
5357: LD_INT 0
5359: ST_TO_ADDR
// skurveny_mission_objectiv_uz_prosel = false ;
5360: LD_ADDR_LOC 14
5364: PUSH
5365: LD_INT 0
5367: ST_TO_ADDR
// kecy_pri_vraceni_belkova = 0 ;
5368: LD_ADDR_LOC 16
5372: PUSH
5373: LD_INT 0
5375: ST_TO_ADDR
// for i in [ 991 , 992 ] do
5376: LD_ADDR_VAR 0 1
5380: PUSH
5381: LD_INT 991
5383: PUSH
5384: LD_INT 992
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PUSH
5391: FOR_IN
5392: IFFALSE 5401
// disable ( i ) ;
5394: LD_VAR 0 1
5398: DISABLE_MARKED
5399: GO 5391
5401: POP
5402: POP
// end ;
5403: PPOPN 1
5405: END
// every 0 0$3 do
5406: GO 5408
5408: DISABLE
// begin ComTurnUnit ( kurin , bur ) ;
5409: LD_EXP 53
5413: PPUSH
5414: LD_EXP 50
5418: PPUSH
5419: CALL_OW 119
// ComTurnUnit ( bur , kurin ) ;
5423: LD_EXP 50
5427: PPUSH
5428: LD_EXP 53
5432: PPUSH
5433: CALL_OW 119
// Say ( kurin , D1-Kur-1 ) ;
5437: LD_EXP 53
5441: PPUSH
5442: LD_STRING D1-Kur-1
5444: PPUSH
5445: CALL_OW 88
// Say ( bur , D1-Bur-1 ) ;
5449: LD_EXP 50
5453: PPUSH
5454: LD_STRING D1-Bur-1
5456: PPUSH
5457: CALL_OW 88
// Say ( kurin , D1-Kur-2 ) ;
5461: LD_EXP 53
5465: PPUSH
5466: LD_STRING D1-Kur-2
5468: PPUSH
5469: CALL_OW 88
// Say ( bur , D1-Bur-2 ) ;
5473: LD_EXP 50
5477: PPUSH
5478: LD_STRING D1-Bur-2
5480: PPUSH
5481: CALL_OW 88
// Say ( kurin , D1-Kur-3 ) ;
5485: LD_EXP 53
5489: PPUSH
5490: LD_STRING D1-Kur-3
5492: PPUSH
5493: CALL_OW 88
// if gny <> 0 then
5497: LD_EXP 49
5501: PUSH
5502: LD_INT 0
5504: NONEQUAL
5505: IFFALSE 5519
// Say ( kurin , D1-Kur-3a ) ;
5507: LD_EXP 53
5511: PPUSH
5512: LD_STRING D1-Kur-3a
5514: PPUSH
5515: CALL_OW 88
// SaveForQuickRestart ;
5519: CALL_OW 22
// wait ( 0 0$1 ) ;
5523: LD_INT 35
5525: PPUSH
5526: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5530: LD_STRING M1
5532: PPUSH
5533: CALL_OW 337
// InGameOff ;
5537: CALL_OW 9
// stav = 1 ;
5541: LD_ADDR_EXP 60
5545: PUSH
5546: LD_INT 1
5548: ST_TO_ADDR
// enable ( 991 ) ;
5549: LD_INT 991
5551: ENABLE_MARKED
// end ;
5552: END
// every 0 0$1 trigger SeeXY ( You , 69 , 83 ) or SeeXY ( You , 73 , 96 ) and ( not kecal_s_platonovem ) do var pom ; var sq ;
5553: LD_EXP 1
5557: PPUSH
5558: LD_INT 69
5560: PPUSH
5561: LD_INT 83
5563: PPUSH
5564: CALL_OW 293
5568: PUSH
5569: LD_EXP 1
5573: PPUSH
5574: LD_INT 73
5576: PPUSH
5577: LD_INT 96
5579: PPUSH
5580: CALL_OW 293
5584: PUSH
5585: LD_LOC 9
5589: NOT
5590: AND
5591: OR
5592: IFFALSE 5688
5594: GO 5596
5596: DISABLE
5597: LD_INT 0
5599: PPUSH
5600: PPUSH
// begin DialogueOn ;
5601: CALL_OW 6
// if SeeXY ( You , 71 , 84 ) then
5605: LD_EXP 1
5609: PPUSH
5610: LD_INT 71
5612: PPUSH
5613: LD_INT 84
5615: PPUSH
5616: CALL_OW 293
5620: IFFALSE 5632
// pom = Ru2_vb1 else
5622: LD_ADDR_VAR 0 1
5626: PUSH
5627: LD_INT 9
5629: ST_TO_ADDR
5630: GO 5640
// pom = Ru2_vb2 ;
5632: LD_ADDR_VAR 0 1
5636: PUSH
5637: LD_INT 10
5639: ST_TO_ADDR
// Say ( pom , D2-RSol1-1 ) ;
5640: LD_VAR 0 1
5644: PPUSH
5645: LD_STRING D2-RSol1-1
5647: PPUSH
5648: CALL_OW 88
// Say ( bur , D2-Bur-1 ) ;
5652: LD_EXP 50
5656: PPUSH
5657: LD_STRING D2-Bur-1
5659: PPUSH
5660: CALL_OW 88
// Say ( pom , D2-RSol1-2 ) ;
5664: LD_VAR 0 1
5668: PPUSH
5669: LD_STRING D2-RSol1-2
5671: PPUSH
5672: CALL_OW 88
// stav = 2 ;
5676: LD_ADDR_EXP 60
5680: PUSH
5681: LD_INT 2
5683: ST_TO_ADDR
// DialogueOff ;
5684: CALL_OW 7
// end ;
5688: PPOPN 2
5690: END
// every 0 0$1 trigger IsInArea ( bur , near_plat ) do
5691: LD_EXP 50
5695: PPUSH
5696: LD_INT 5
5698: PPUSH
5699: CALL_OW 308
5703: IFFALSE 6057
5705: GO 5707
5707: DISABLE
// begin kecal_s_platonovem = true ;
5708: LD_ADDR_LOC 9
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// DialogueOn ;
5716: CALL_OW 6
// ComHold ( bur ) ;
5720: LD_EXP 50
5724: PPUSH
5725: CALL_OW 140
// ComTurnUnit ( plat , bur ) ;
5729: LD_EXP 54
5733: PPUSH
5734: LD_EXP 50
5738: PPUSH
5739: CALL_OW 119
// AddComTurnUnit ( bur , plat ) ;
5743: LD_EXP 50
5747: PPUSH
5748: LD_EXP 54
5752: PPUSH
5753: CALL_OW 179
// Say ( plat , D2-Pla-2 ) ;
5757: LD_EXP 54
5761: PPUSH
5762: LD_STRING D2-Pla-2
5764: PPUSH
5765: CALL_OW 88
// Say ( bur , D2-Bur-2 ) ;
5769: LD_EXP 50
5773: PPUSH
5774: LD_STRING D2-Bur-2
5776: PPUSH
5777: CALL_OW 88
// Say ( plat , D2-Pla-3 ) ;
5781: LD_EXP 54
5785: PPUSH
5786: LD_STRING D2-Pla-3
5788: PPUSH
5789: CALL_OW 88
// Say ( bur , D2-Bur-3 ) ;
5793: LD_EXP 50
5797: PPUSH
5798: LD_STRING D2-Bur-3
5800: PPUSH
5801: CALL_OW 88
// Say ( plat , D2-Pla-4 ) ;
5805: LD_EXP 54
5809: PPUSH
5810: LD_STRING D2-Pla-4
5812: PPUSH
5813: CALL_OW 88
// Say ( bur , D2-Bur-4 ) ;
5817: LD_EXP 50
5821: PPUSH
5822: LD_STRING D2-Bur-4
5824: PPUSH
5825: CALL_OW 88
// Say ( plat , D2-Pla-5 ) ;
5829: LD_EXP 54
5833: PPUSH
5834: LD_STRING D2-Pla-5
5836: PPUSH
5837: CALL_OW 88
// info_q ( [ 1 , 2 , 3 , 4 ] ) ;
5841: LD_INT 1
5843: PUSH
5844: LD_INT 2
5846: PUSH
5847: LD_INT 3
5849: PUSH
5850: LD_INT 4
5852: PUSH
5853: EMPTY
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: PPUSH
5859: CALL 6058 0 1
// Say ( plat , D3-Pla-1 ) ;
5863: LD_EXP 54
5867: PPUSH
5868: LD_STRING D3-Pla-1
5870: PPUSH
5871: CALL_OW 88
// Say ( bur , D3-Bur-1 ) ;
5875: LD_EXP 50
5879: PPUSH
5880: LD_STRING D3-Bur-1
5882: PPUSH
5883: CALL_OW 88
// ChangeMissionObjectives ( M2a ) ;
5887: LD_STRING M2a
5889: PPUSH
5890: CALL_OW 337
// Hint ( Base ) ;
5894: LD_STRING Base
5896: PPUSH
5897: CALL_OW 339
// Hint ( Depot ) ;
5901: LD_STRING Depot
5903: PPUSH
5904: CALL_OW 339
// Hint ( Construction ) ;
5908: LD_STRING Construction
5910: PPUSH
5911: CALL_OW 339
// DialogueOff ;
5915: CALL_OW 7
// ComFree ( plat ) ;
5919: LD_EXP 54
5923: PPUSH
5924: CALL_OW 139
// AddComFree ( bur ) ;
5928: LD_EXP 50
5932: PPUSH
5933: CALL_OW 199
// stav = 3 ;
5937: LD_ADDR_EXP 60
5941: PUSH
5942: LD_INT 3
5944: ST_TO_ADDR
// SetSide ( RU2_dep , You ) ;
5945: LD_INT 26
5947: PPUSH
5948: LD_EXP 1
5952: PPUSH
5953: CALL_OW 235
// SetSide ( plat , You2 ) ;
5957: LD_EXP 54
5961: PPUSH
5962: LD_EXP 4
5966: PPUSH
5967: CALL_OW 235
// SetSide ( RU2_bu1 , You2 ) ;
5971: LD_INT 4
5973: PPUSH
5974: LD_EXP 4
5978: PPUSH
5979: CALL_OW 235
// SetSide ( RU2_bu2 , You2 ) ;
5983: LD_INT 11
5985: PPUSH
5986: LD_EXP 4
5990: PPUSH
5991: CALL_OW 235
// SetSide ( RU2_vb1 , You2 ) ;
5995: LD_INT 9
5997: PPUSH
5998: LD_EXP 4
6002: PPUSH
6003: CALL_OW 235
// SetSide ( RU2_vb2 , You2 ) ;
6007: LD_INT 10
6009: PPUSH
6010: LD_EXP 4
6014: PPUSH
6015: CALL_OW 235
// SetSide ( RU2_hv1 , You2 ) ;
6019: LD_INT 15
6021: PPUSH
6022: LD_EXP 4
6026: PPUSH
6027: CALL_OW 235
// SetSide ( RU2_hv2 , You2 ) ;
6031: LD_INT 16
6033: PPUSH
6034: LD_EXP 4
6038: PPUSH
6039: CALL_OW 235
// ComStop ( RU2_hv1 ) ;
6043: LD_INT 15
6045: PPUSH
6046: CALL_OW 141
// ComStop ( RU2_hv2 ) ;
6050: LD_INT 16
6052: PPUSH
6053: CALL_OW 141
// end ;
6057: END
// function info_q ( q ) ; var pom ; var q1 ; begin
6058: LD_INT 0
6060: PPUSH
6061: PPUSH
6062: PPUSH
// pom = SelectiveQuery ( QMoreInfo , q ) ;
6063: LD_ADDR_VAR 0 3
6067: PUSH
6068: LD_STRING QMoreInfo
6070: PPUSH
6071: LD_VAR 0 1
6075: PPUSH
6076: CALL_OW 98
6080: ST_TO_ADDR
// case pom of 1 :
6081: LD_VAR 0 3
6085: PUSH
6086: LD_INT 1
6088: DOUBLE
6089: EQUAL
6090: IFTRUE 6094
6092: GO 6154
6094: POP
// begin Say ( bur , D2a-Bur-1 ) ;
6095: LD_EXP 50
6099: PPUSH
6100: LD_STRING D2a-Bur-1
6102: PPUSH
6103: CALL_OW 88
// Say ( plat , D2a-Pla-1 ) ;
6107: LD_EXP 54
6111: PPUSH
6112: LD_STRING D2a-Pla-1
6114: PPUSH
6115: CALL_OW 88
// q1 = q diff 1 ;
6119: LD_ADDR_VAR 0 4
6123: PUSH
6124: LD_VAR 0 1
6128: PUSH
6129: LD_INT 1
6131: DIFF
6132: ST_TO_ADDR
// if q1 >= 2 then
6133: LD_VAR 0 4
6137: PUSH
6138: LD_INT 2
6140: GREATEREQUAL
6141: IFFALSE 6152
// info_q ( q1 ) ;
6143: LD_VAR 0 4
6147: PPUSH
6148: CALL 6058 0 1
// end ; 2 :
6152: GO 6291
6154: LD_INT 2
6156: DOUBLE
6157: EQUAL
6158: IFTRUE 6162
6160: GO 6222
6162: POP
// begin Say ( bur , D2b-Bur-1 ) ;
6163: LD_EXP 50
6167: PPUSH
6168: LD_STRING D2b-Bur-1
6170: PPUSH
6171: CALL_OW 88
// Say ( plat , D2b-Pla-1 ) ;
6175: LD_EXP 54
6179: PPUSH
6180: LD_STRING D2b-Pla-1
6182: PPUSH
6183: CALL_OW 88
// q1 = q diff 2 ;
6187: LD_ADDR_VAR 0 4
6191: PUSH
6192: LD_VAR 0 1
6196: PUSH
6197: LD_INT 2
6199: DIFF
6200: ST_TO_ADDR
// if q1 >= 2 then
6201: LD_VAR 0 4
6205: PUSH
6206: LD_INT 2
6208: GREATEREQUAL
6209: IFFALSE 6220
// info_q ( q1 ) ;
6211: LD_VAR 0 4
6215: PPUSH
6216: CALL 6058 0 1
// end ; 3 :
6220: GO 6291
6222: LD_INT 3
6224: DOUBLE
6225: EQUAL
6226: IFTRUE 6230
6228: GO 6290
6230: POP
// begin Say ( bur , D2c-Bur-1 ) ;
6231: LD_EXP 50
6235: PPUSH
6236: LD_STRING D2c-Bur-1
6238: PPUSH
6239: CALL_OW 88
// Say ( plat , D2c-Pla-1 ) ;
6243: LD_EXP 54
6247: PPUSH
6248: LD_STRING D2c-Pla-1
6250: PPUSH
6251: CALL_OW 88
// q1 = q diff 3 ;
6255: LD_ADDR_VAR 0 4
6259: PUSH
6260: LD_VAR 0 1
6264: PUSH
6265: LD_INT 3
6267: DIFF
6268: ST_TO_ADDR
// if q1 >= 2 then
6269: LD_VAR 0 4
6273: PUSH
6274: LD_INT 2
6276: GREATEREQUAL
6277: IFFALSE 6288
// info_q ( q1 ) ;
6279: LD_VAR 0 4
6283: PPUSH
6284: CALL 6058 0 1
// end ; end ;
6288: GO 6291
6290: POP
// end ;
6291: LD_VAR 0 2
6295: RET
// every 0 0$1 trigger stav in prilis_na_north do var pom ;
6296: LD_EXP 60
6300: PUSH
6301: LD_LOC 3
6305: IN
6306: IFFALSE 6461
6308: GO 6310
6310: DISABLE
6311: LD_INT 0
6313: PPUSH
// begin pom = FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) ;
6314: LD_ADDR_VAR 0 1
6318: PUSH
6319: LD_INT 2
6321: PPUSH
6322: LD_INT 22
6324: PUSH
6325: LD_EXP 1
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: EMPTY
6335: LIST
6336: PPUSH
6337: CALL_OW 70
6341: ST_TO_ADDR
// if pom > 0 then
6342: LD_VAR 0 1
6346: PUSH
6347: LD_INT 0
6349: GREATER
6350: IFFALSE 6460
// begin ComHold ( pom ) ;
6352: LD_VAR 0 1
6356: PPUSH
6357: CALL_OW 140
// DialogueOn ;
6361: CALL_OW 6
// posli_lidi_zpet ;
6365: CALL 15820 0 0
// if bur in pom then
6369: LD_EXP 50
6373: PUSH
6374: LD_VAR 0 1
6378: IN
6379: IFFALSE 6395
// Say ( Bur , D1b-Bur-1 ) else
6381: LD_EXP 50
6385: PPUSH
6386: LD_STRING D1b-Bur-1
6388: PPUSH
6389: CALL_OW 88
6393: GO 6407
// Say ( Kov , D1b-Kov-1 ) ;
6395: LD_EXP 51
6399: PPUSH
6400: LD_STRING D1b-Kov-1
6402: PPUSH
6403: CALL_OW 88
// DialogueOff ;
6407: CALL_OW 7
// InGameOn ;
6411: CALL_OW 8
// while FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) <> 0 do
6415: LD_INT 2
6417: PPUSH
6418: LD_INT 22
6420: PUSH
6421: LD_EXP 1
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: EMPTY
6431: LIST
6432: PPUSH
6433: CALL_OW 70
6437: PUSH
6438: LD_INT 0
6440: NONEQUAL
6441: IFFALSE 6456
// begin wait ( 0 0$2 ) ;
6443: LD_INT 70
6445: PPUSH
6446: CALL_OW 67
// posli_lidi_zpet ;
6450: CALL 15820 0 0
// end ;
6454: GO 6415
// InGameOff ;
6456: CALL_OW 9
// end ; enable ;
6460: ENABLE
// end ;
6461: PPOPN 1
6463: END
// every 0 0$1 trigger FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) = 1 do var pom , pom1 ;
6464: LD_INT 1
6466: PPUSH
6467: LD_INT 22
6469: PUSH
6470: LD_EXP 1
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PUSH
6479: LD_INT 30
6481: PUSH
6482: LD_INT 6
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PPUSH
6493: CALL_OW 70
6497: PUSH
6498: LD_INT 1
6500: EQUAL
6501: IFFALSE 6748
6503: GO 6505
6505: DISABLE
6506: LD_INT 0
6508: PPUSH
6509: PPUSH
// begin pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) ;
6510: LD_ADDR_VAR 0 1
6514: PUSH
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 22
6520: PUSH
6521: LD_EXP 1
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 30
6532: PUSH
6533: LD_INT 6
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: PPUSH
6544: CALL_OW 70
6548: ST_TO_ADDR
// pom1 = 7 ;
6549: LD_ADDR_VAR 0 2
6553: PUSH
6554: LD_INT 7
6556: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
6557: LD_VAR 0 1
6561: PUSH
6562: LD_INT 1
6564: ARRAY
6565: PPUSH
6566: CALL_OW 304
6570: PUSH
6571: LD_INT 0
6573: NONEQUAL
6574: IFFALSE 6585
// wait ( 0 0$2 ) ;
6576: LD_INT 70
6578: PPUSH
6579: CALL_OW 67
6583: GO 6557
// DialogueOn ;
6585: CALL_OW 6
// Hint ( Laboratory ) ;
6589: LD_STRING Laboratory
6591: PPUSH
6592: CALL_OW 339
// Hint ( Healing ) ;
6596: LD_STRING Healing
6598: PPUSH
6599: CALL_OW 339
// Say ( bur , D5a-Bur-1 ) ;
6603: LD_EXP 50
6607: PPUSH
6608: LD_STRING D5a-Bur-1
6610: PPUSH
6611: CALL_OW 88
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) ;
6615: LD_ADDR_VAR 0 1
6619: PUSH
6620: LD_INT 1
6622: PPUSH
6623: LD_INT 22
6625: PUSH
6626: LD_EXP 1
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 30
6637: PUSH
6638: LD_INT 2
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: PPUSH
6649: CALL_OW 70
6653: ST_TO_ADDR
// if pom > 0 then
6654: LD_VAR 0 1
6658: PUSH
6659: LD_INT 0
6661: GREATER
6662: IFFALSE 6683
// pom1 = IsConstructed ( pom [ 1 ] ) ;
6664: LD_ADDR_VAR 0 2
6668: PUSH
6669: LD_VAR 0 1
6673: PUSH
6674: LD_INT 1
6676: ARRAY
6677: PPUSH
6678: CALL_OW 304
6682: ST_TO_ADDR
// if pom1 = 0 then
6683: LD_VAR 0 2
6687: PUSH
6688: LD_INT 0
6690: EQUAL
6691: IFFALSE 6725
// begin Say ( plat , D5a-Pla-1 ) ;
6693: LD_EXP 54
6697: PPUSH
6698: LD_STRING D5a-Pla-1
6700: PPUSH
6701: CALL_OW 88
// ChangeMissionObjectives ( M2 ) ;
6705: LD_STRING M2
6707: PPUSH
6708: CALL_OW 337
// pokracovani_rozhovoru ;
6712: CALL 7058 0 0
// Hint ( BuildingVehicles ) ;
6716: LD_STRING BuildingVehicles
6718: PPUSH
6719: CALL_OW 339
// end else
6723: GO 6744
// begin Say ( plat , D5a-Pla-1a ) ;
6725: LD_EXP 54
6729: PPUSH
6730: LD_STRING D5a-Pla-1a
6732: PPUSH
6733: CALL_OW 88
// ChangeMissionObjectives ( M2b ) ;
6737: LD_STRING M2b
6739: PPUSH
6740: CALL_OW 337
// end ; DialogueOff ;
6744: CALL_OW 7
// end ;
6748: PPOPN 2
6750: END
// every 0 0$1 trigger FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) = 1 do var pom , pom1 ;
6751: LD_INT 1
6753: PPUSH
6754: LD_INT 22
6756: PUSH
6757: LD_EXP 1
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 30
6768: PUSH
6769: LD_INT 2
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: EMPTY
6777: LIST
6778: LIST
6779: PPUSH
6780: CALL_OW 70
6784: PUSH
6785: LD_INT 1
6787: EQUAL
6788: IFFALSE 7055
6790: GO 6792
6792: DISABLE
6793: LD_INT 0
6795: PPUSH
6796: PPUSH
// begin pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) ;
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_INT 22
6807: PUSH
6808: LD_EXP 1
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PUSH
6817: LD_INT 30
6819: PUSH
6820: LD_INT 2
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: PPUSH
6831: CALL_OW 70
6835: ST_TO_ADDR
// pom1 = 7 ;
6836: LD_ADDR_VAR 0 2
6840: PUSH
6841: LD_INT 7
6843: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
6844: LD_VAR 0 1
6848: PUSH
6849: LD_INT 1
6851: ARRAY
6852: PPUSH
6853: CALL_OW 304
6857: PUSH
6858: LD_INT 0
6860: NONEQUAL
6861: IFFALSE 6872
// wait ( 0 0$2 ) ;
6863: LD_INT 70
6865: PPUSH
6866: CALL_OW 67
6870: GO 6844
// DialogueOn ;
6872: CALL_OW 6
// if GetTech ( tech_OilEng , You ) = state_researched then
6876: LD_INT 47
6878: PPUSH
6879: LD_EXP 1
6883: PPUSH
6884: CALL_OW 321
6888: PUSH
6889: LD_INT 2
6891: EQUAL
6892: IFFALSE 6903
// Hint ( Workshop2 ) else
6894: LD_STRING Workshop2
6896: PPUSH
6897: CALL_OW 339
6901: GO 6910
// Hint ( Workshop1 ) ;
6903: LD_STRING Workshop1
6905: PPUSH
6906: CALL_OW 339
// Say ( bur , D5b-Bur-1 ) ;
6910: LD_EXP 50
6914: PPUSH
6915: LD_STRING D5b-Bur-1
6917: PPUSH
6918: CALL_OW 88
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) ;
6922: LD_ADDR_VAR 0 1
6926: PUSH
6927: LD_INT 1
6929: PPUSH
6930: LD_INT 22
6932: PUSH
6933: LD_EXP 1
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PUSH
6942: LD_INT 30
6944: PUSH
6945: LD_INT 6
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL_OW 70
6960: ST_TO_ADDR
// if pom > 0 then
6961: LD_VAR 0 1
6965: PUSH
6966: LD_INT 0
6968: GREATER
6969: IFFALSE 6990
// pom1 = IsConstructed ( pom [ 1 ] ) ;
6971: LD_ADDR_VAR 0 2
6975: PUSH
6976: LD_VAR 0 1
6980: PUSH
6981: LD_INT 1
6983: ARRAY
6984: PPUSH
6985: CALL_OW 304
6989: ST_TO_ADDR
// if pom1 = 0 then
6990: LD_VAR 0 2
6994: PUSH
6995: LD_INT 0
6997: EQUAL
6998: IFFALSE 7032
// begin Say ( plat , D5b-Pla-1 ) ;
7000: LD_EXP 54
7004: PPUSH
7005: LD_STRING D5b-Pla-1
7007: PPUSH
7008: CALL_OW 88
// ChangeMissionObjectives ( M2 ) ;
7012: LD_STRING M2
7014: PPUSH
7015: CALL_OW 337
// pokracovani_rozhovoru ;
7019: CALL 7058 0 0
// Hint ( BuildingVehicles ) ;
7023: LD_STRING BuildingVehicles
7025: PPUSH
7026: CALL_OW 339
// end else
7030: GO 7051
// begin Say ( plat , D5b-Pla-1a ) ;
7032: LD_EXP 54
7036: PPUSH
7037: LD_STRING D5b-Pla-1a
7039: PPUSH
7040: CALL_OW 88
// ChangeMissionObjectives ( M2c ) ;
7044: LD_STRING M2c
7046: PPUSH
7047: CALL_OW 337
// end ; DialogueOff ;
7051: CALL_OW 7
// end ;
7055: PPOPN 2
7057: END
// function pokracovani_rozhovoru ; begin
7058: LD_INT 0
7060: PPUSH
// if Researched ( You , tech_OilEng ) then
7061: LD_EXP 1
7065: PPUSH
7066: LD_INT 47
7068: PPUSH
7069: CALL_OW 325
7073: IFFALSE 7101
// begin Say ( bur , D7b-Bur-1 ) ;
7075: LD_EXP 50
7079: PPUSH
7080: LD_STRING D7b-Bur-1
7082: PPUSH
7083: CALL_OW 88
// Say ( plat , D7b-Pla-1 ) ;
7087: LD_EXP 54
7091: PPUSH
7092: LD_STRING D7b-Pla-1
7094: PPUSH
7095: CALL_OW 88
// end else
7099: GO 7125
// begin Say ( bur , D7a-Bur-1 ) ;
7101: LD_EXP 50
7105: PPUSH
7106: LD_STRING D7a-Bur-1
7108: PPUSH
7109: CALL_OW 88
// Say ( plat , D7a-Pla-1 ) ;
7113: LD_EXP 54
7117: PPUSH
7118: LD_STRING D7a-Pla-1
7120: PPUSH
7121: CALL_OW 88
// end ; end ;
7125: LD_VAR 0 1
7129: RET
// every 0 0$1 trigger stav in is_out_base do var pom , pom1 ;
7130: LD_EXP 60
7134: PUSH
7135: LD_LOC 4
7139: IN
7140: IFFALSE 7328
7142: GO 7144
7144: DISABLE
7145: LD_INT 0
7147: PPUSH
7148: PPUSH
// begin pom = FilterUnitsInArea ( Out_base , [ [ f_side , You ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
7149: LD_ADDR_VAR 0 1
7153: PUSH
7154: LD_INT 6
7156: PPUSH
7157: LD_INT 22
7159: PUSH
7160: LD_EXP 1
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: LD_INT 2
7171: PUSH
7172: LD_INT 21
7174: PUSH
7175: LD_INT 2
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PUSH
7182: LD_INT 21
7184: PUSH
7185: LD_INT 1
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: LIST
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PPUSH
7201: CALL_OW 70
7205: ST_TO_ADDR
// if pom > 0 then
7206: LD_VAR 0 1
7210: PUSH
7211: LD_INT 0
7213: GREATER
7214: IFFALSE 7327
// begin ComHold ( pom ) ;
7216: LD_VAR 0 1
7220: PPUSH
7221: CALL_OW 140
// DialogueOn ;
7225: CALL_OW 6
// Say ( plat , D8-Pla-1 ) ;
7229: LD_EXP 54
7233: PPUSH
7234: LD_STRING D8-Pla-1
7236: PPUSH
7237: CALL_OW 88
// DialogueOff ;
7241: CALL_OW 7
// InGameOn ;
7245: CALL_OW 8
// posli_rusi_zpet_out_base ;
7249: CALL 15869 0 0
// while FilterUnitsInArea ( Out_base , [ [ f_side , You ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) <> 0 do
7253: LD_INT 6
7255: PPUSH
7256: LD_INT 22
7258: PUSH
7259: LD_EXP 1
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: LD_INT 2
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 2
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: LD_INT 21
7283: PUSH
7284: LD_INT 1
7286: PUSH
7287: EMPTY
7288: LIST
7289: LIST
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL_OW 70
7304: PUSH
7305: LD_INT 0
7307: NONEQUAL
7308: IFFALSE 7323
// begin wait ( 0 0$2 ) ;
7310: LD_INT 70
7312: PPUSH
7313: CALL_OW 67
// posli_rusi_zpet_out_base ;
7317: CALL 15869 0 0
// end ;
7321: GO 7253
// InGameOff ;
7323: CALL_OW 9
// end ; enable ;
7327: ENABLE
// end ;
7328: PPOPN 2
7330: END
// every 0 0$1 marked 300 do var pom ;
7331: GO 7333
7333: DISABLE
7334: LD_INT 0
7336: PPUSH
// begin wait ( 0 0$4 ) ;
7337: LD_INT 140
7339: PPUSH
7340: CALL_OW 67
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7344: LD_ADDR_VAR 0 1
7348: PUSH
7349: LD_INT 1
7351: PPUSH
7352: LD_INT 22
7354: PUSH
7355: LD_EXP 1
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PUSH
7364: LD_INT 21
7366: PUSH
7367: LD_INT 2
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: PPUSH
7378: CALL_OW 70
7382: ST_TO_ADDR
// DialogueOn ;
7383: CALL_OW 6
// Say ( bur , D9-Bur-1 ) ;
7387: LD_EXP 50
7391: PPUSH
7392: LD_STRING D9-Bur-1
7394: PPUSH
7395: CALL_OW 88
// Say ( plat , D9-Pla-1 ) ;
7399: LD_EXP 54
7403: PPUSH
7404: LD_STRING D9-Pla-1
7406: PPUSH
7407: CALL_OW 88
// ChangeMissionObjectives ( M3 ) ;
7411: LD_STRING M3
7413: PPUSH
7414: CALL_OW 337
// stav = 4 ;
7418: LD_ADDR_EXP 60
7422: PUSH
7423: LD_INT 4
7425: ST_TO_ADDR
// DialogueOff ;
7426: CALL_OW 7
// Hint ( Driving ) ;
7430: LD_STRING Driving
7432: PPUSH
7433: CALL_OW 339
// wait ( 0 0$10 ) ;
7437: LD_INT 350
7439: PPUSH
7440: CALL_OW 67
// end ;
7444: PPOPN 1
7446: END
// every 0 0$5 trigger stav > 3 do var pom , i ; var a ;
7447: LD_EXP 60
7451: PUSH
7452: LD_INT 3
7454: GREATER
7455: IFFALSE 7565
7457: GO 7459
7459: DISABLE
7460: LD_INT 0
7462: PPUSH
7463: PPUSH
7464: PPUSH
// begin a = false ;
7465: LD_ADDR_VAR 0 3
7469: PUSH
7470: LD_INT 0
7472: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7473: LD_ADDR_VAR 0 1
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_EXP 1
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 21
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PPUSH
7504: CALL_OW 69
7508: ST_TO_ADDR
// for i in pom do
7509: LD_ADDR_VAR 0 2
7513: PUSH
7514: LD_VAR 0 1
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7547
// if GetLives ( i ) < 900 then
7522: LD_VAR 0 2
7526: PPUSH
7527: CALL_OW 256
7531: PUSH
7532: LD_INT 900
7534: LESS
7535: IFFALSE 7545
// a = true ;
7537: LD_ADDR_VAR 0 3
7541: PUSH
7542: LD_INT 1
7544: ST_TO_ADDR
7545: GO 7519
7547: POP
7548: POP
// if a then
7549: LD_VAR 0 3
7553: IFFALSE 7564
// Hint ( Repair ) else
7555: LD_STRING Repair
7557: PPUSH
7558: CALL_OW 339
7562: GO 7565
// enable ;
7564: ENABLE
// end ;
7565: PPOPN 3
7567: END
// every 0 0$5 trigger stav > 3 do var pom , i ; var a ;
7568: LD_EXP 60
7572: PUSH
7573: LD_INT 3
7575: GREATER
7576: IFFALSE 7686
7578: GO 7580
7580: DISABLE
7581: LD_INT 0
7583: PPUSH
7584: PPUSH
7585: PPUSH
// begin a = false ;
7586: LD_ADDR_VAR 0 3
7590: PUSH
7591: LD_INT 0
7593: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7594: LD_ADDR_VAR 0 1
7598: PUSH
7599: LD_INT 22
7601: PUSH
7602: LD_EXP 1
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 21
7613: PUSH
7614: LD_INT 2
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PPUSH
7625: CALL_OW 69
7629: ST_TO_ADDR
// for i in pom do
7630: LD_ADDR_VAR 0 2
7634: PUSH
7635: LD_VAR 0 1
7639: PUSH
7640: FOR_IN
7641: IFFALSE 7668
// if GetFuel ( i ) < 20 then
7643: LD_VAR 0 2
7647: PPUSH
7648: CALL_OW 261
7652: PUSH
7653: LD_INT 20
7655: LESS
7656: IFFALSE 7666
// a = true ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 1
7665: ST_TO_ADDR
7666: GO 7640
7668: POP
7669: POP
// if a then
7670: LD_VAR 0 3
7674: IFFALSE 7685
// Hint ( Fuel ) else
7676: LD_STRING Fuel
7678: PPUSH
7679: CALL_OW 339
7683: GO 7686
// enable ;
7685: ENABLE
// end ;
7686: PPOPN 3
7688: END
// every 0 0$2 trigger stav = 4 and test_is_auto_in_area do var auto ; var ridic ;
7689: LD_EXP 60
7693: PUSH
7694: LD_INT 4
7696: EQUAL
7697: PUSH
7698: CALL 15492 0 0
7702: AND
7703: IFFALSE 8136
7705: GO 7707
7707: DISABLE
7708: LD_INT 0
7710: PPUSH
7711: PPUSH
// begin disable ( 991 ) ;
7712: LD_INT 991
7714: DISABLE_MARKED
// InGameOn ;
7715: CALL_OW 8
// auto = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7719: LD_ADDR_VAR 0 1
7723: PUSH
7724: LD_INT 3
7726: PPUSH
7727: LD_INT 22
7729: PUSH
7730: LD_EXP 1
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 21
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PPUSH
7753: CALL_OW 70
7757: ST_TO_ADDR
// auto = auto [ 1 ] ;
7758: LD_ADDR_VAR 0 1
7762: PUSH
7763: LD_VAR 0 1
7767: PUSH
7768: LD_INT 1
7770: ARRAY
7771: ST_TO_ADDR
// ridic = IsDrivenBy ( auto ) ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 1
7781: PPUSH
7782: CALL_OW 311
7786: ST_TO_ADDR
// ComMoveXY ( ridic , 117 , 101 ) ;
7787: LD_VAR 0 2
7791: PPUSH
7792: LD_INT 117
7794: PPUSH
7795: LD_INT 101
7797: PPUSH
7798: CALL_OW 111
// CenterOnUnits ( [ auto ] ) ;
7802: LD_VAR 0 1
7806: PUSH
7807: EMPTY
7808: LIST
7809: PPUSH
7810: CALL_OW 85
// SetFuel ( [ auto ] , 100 ) ;
7814: LD_VAR 0 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: PPUSH
7822: LD_INT 100
7824: PPUSH
7825: CALL_OW 240
// Say ( kurin , D10-Kur-1 ) ;
7829: LD_EXP 53
7833: PPUSH
7834: LD_STRING D10-Kur-1
7836: PPUSH
7837: CALL_OW 88
// Say ( bel , D10-Bel-1 ) ;
7841: LD_EXP 52
7845: PPUSH
7846: LD_STRING D10-Bel-1
7848: PPUSH
7849: CALL_OW 88
// ComExitVehicle ( ridic ) ;
7853: LD_VAR 0 2
7857: PPUSH
7858: CALL_OW 121
// AddComHold ( ridic ) ;
7862: LD_VAR 0 2
7866: PPUSH
7867: CALL_OW 200
// wait ( 0 0$1 ) ;
7871: LD_INT 35
7873: PPUSH
7874: CALL_OW 67
// if BELKOV_MRTVY then
7878: LD_EXP 46
7882: IFFALSE 7920
// begin Say ( bur , D10-Bur-1 ) ;
7884: LD_EXP 50
7888: PPUSH
7889: LD_STRING D10-Bur-1
7891: PPUSH
7892: CALL_OW 88
// Say ( bel , D10-Bel-2 ) ;
7896: LD_EXP 52
7900: PPUSH
7901: LD_STRING D10-Bel-2
7903: PPUSH
7904: CALL_OW 88
// Say ( bur , D10-Bur-2 ) ;
7908: LD_EXP 50
7912: PPUSH
7913: LD_STRING D10-Bur-2
7915: PPUSH
7916: CALL_OW 88
// end ; AddComHold ( ridic ) ;
7920: LD_VAR 0 2
7924: PPUSH
7925: CALL_OW 200
// if BELKOV_MRTVY then
7929: LD_EXP 46
7933: IFFALSE 7949
// Say ( kurin , D10-Kur-2a ) else
7935: LD_EXP 53
7939: PPUSH
7940: LD_STRING D10-Kur-2a
7942: PPUSH
7943: CALL_OW 88
7947: GO 7961
// Say ( kurin , D10-Kur-2 ) ;
7949: LD_EXP 53
7953: PPUSH
7954: LD_STRING D10-Kur-2
7956: PPUSH
7957: CALL_OW 88
// ComExitBuilding ( bel ) ;
7961: LD_EXP 52
7965: PPUSH
7966: CALL_OW 122
// while IsInUnit ( ridic ) <> 0 do
7970: LD_VAR 0 2
7974: PPUSH
7975: CALL_OW 310
7979: PUSH
7980: LD_INT 0
7982: NONEQUAL
7983: IFFALSE 8003
// begin wait ( 0 0$1 ) ;
7985: LD_INT 35
7987: PPUSH
7988: CALL_OW 67
// ComExitVehicle ( ridic ) ;
7992: LD_VAR 0 2
7996: PPUSH
7997: CALL_OW 121
// end ;
8001: GO 7970
// AddComEnterUnit ( bel , auto ) ;
8003: LD_EXP 52
8007: PPUSH
8008: LD_VAR 0 1
8012: PPUSH
8013: CALL_OW 180
// wait ( 0 0$1 ) ;
8017: LD_INT 35
8019: PPUSH
8020: CALL_OW 67
// while IsInUnit ( bel ) = 0 do
8024: LD_EXP 52
8028: PPUSH
8029: CALL_OW 310
8033: PUSH
8034: LD_INT 0
8036: EQUAL
8037: IFFALSE 8071
// begin wait ( 0 0$1 ) ;
8039: LD_INT 35
8041: PPUSH
8042: CALL_OW 67
// ComExitBuilding ( bel ) ;
8046: LD_EXP 52
8050: PPUSH
8051: CALL_OW 122
// AddComEnterUnit ( bel , auto ) ;
8055: LD_EXP 52
8059: PPUSH
8060: LD_VAR 0 1
8064: PPUSH
8065: CALL_OW 180
// end ;
8069: GO 8024
// ComFree ( ridic ) ;
8071: LD_VAR 0 2
8075: PPUSH
8076: CALL_OW 139
// Say ( kurin , D10-Kur-2b ) ;
8080: LD_EXP 53
8084: PPUSH
8085: LD_STRING D10-Kur-2b
8087: PPUSH
8088: CALL_OW 88
// ridic_1_auta = ridic ;
8092: LD_ADDR_LOC 6
8096: PUSH
8097: LD_VAR 0 2
8101: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
8102: LD_STRING M4
8104: PPUSH
8105: CALL_OW 337
// objReturn := true ;
8109: LD_ADDR_EXP 29
8113: PUSH
8114: LD_INT 1
8116: ST_TO_ADDR
// stav = 5 ;
8117: LD_ADDR_EXP 60
8121: PUSH
8122: LD_INT 5
8124: ST_TO_ADDR
// InGameOff ;
8125: CALL_OW 9
// rusi_cesta_na_sever ;
8129: CALL 14196 0 0
// enable ( 992 ) ;
8133: LD_INT 992
8135: ENABLE_MARKED
// end ;
8136: PPOPN 2
8138: END
// every 0 0$1 trigger stav = 5 and IsInArea ( ridic_1_auta , RU2_base ) do var poc , i ;
8139: LD_EXP 60
8143: PUSH
8144: LD_INT 5
8146: EQUAL
8147: PUSH
8148: LD_LOC 6
8152: PPUSH
8153: LD_INT 1
8155: PPUSH
8156: CALL_OW 308
8160: AND
8161: IFFALSE 8318
8163: GO 8165
8165: DISABLE
8166: LD_INT 0
8168: PPUSH
8169: PPUSH
// begin poc = 0 ;
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_INT 0
8177: ST_TO_ADDR
// DialogueOn ;
8178: CALL_OW 6
// Say ( plat , D11-Pla-1 ) ;
8182: LD_EXP 54
8186: PPUSH
8187: LD_STRING D11-Pla-1
8189: PPUSH
8190: CALL_OW 88
// for i in Rusi_enter do
8194: LD_ADDR_VAR 0 2
8198: PUSH
8199: LD_EXP 55
8203: PUSH
8204: FOR_IN
8205: IFFALSE 8234
// if IsLive ( i ) then
8207: LD_VAR 0 2
8211: PPUSH
8212: CALL_OW 300
8216: IFFALSE 8232
// poc = poc + 1 ;
8218: LD_ADDR_VAR 0 1
8222: PUSH
8223: LD_VAR 0 1
8227: PUSH
8228: LD_INT 1
8230: PLUS
8231: ST_TO_ADDR
8232: GO 8204
8234: POP
8235: POP
// if poc > 1 then
8236: LD_VAR 0 1
8240: PUSH
8241: LD_INT 1
8243: GREATER
8244: IFFALSE 8260
// Say ( bur , D11-Bur-1a ) else
8246: LD_EXP 50
8250: PPUSH
8251: LD_STRING D11-Bur-1a
8253: PPUSH
8254: CALL_OW 88
8258: GO 8272
// Say ( bur , D11-Bur-1 ) ;
8260: LD_EXP 50
8264: PPUSH
8265: LD_STRING D11-Bur-1
8267: PPUSH
8268: CALL_OW 88
// ChangeMissionObjectives ( M5 ) ;
8272: LD_STRING M5
8274: PPUSH
8275: CALL_OW 337
// objReturn := false ;
8279: LD_ADDR_EXP 29
8283: PUSH
8284: LD_INT 0
8286: ST_TO_ADDR
// CreateCratesXYR ( 2 , 64 , 83 , 6 , true ) ;
8287: LD_INT 2
8289: PPUSH
8290: LD_INT 64
8292: PPUSH
8293: LD_INT 83
8295: PPUSH
8296: LD_INT 6
8298: PPUSH
8299: LD_INT 1
8301: PPUSH
8302: CALL_OW 56
// stav = 6 ;
8306: LD_ADDR_EXP 60
8310: PUSH
8311: LD_INT 6
8313: ST_TO_ADDR
// DialogueOff ;
8314: CALL_OW 7
// end ;
8318: PPOPN 2
8320: END
// export function dialog_boreni ; begin
8321: LD_INT 0
8323: PPUSH
// Say ( plat , D6-Pla-1 ) ;
8324: LD_EXP 54
8328: PPUSH
8329: LD_STRING D6-Pla-1
8331: PPUSH
8332: CALL_OW 88
// Say ( bur , D6-Bur-1 ) ;
8336: LD_EXP 50
8340: PPUSH
8341: LD_STRING D6-Bur-1
8343: PPUSH
8344: CALL_OW 88
// end ;
8348: LD_VAR 0 1
8352: RET
// export function dialog_past_amici ; var pom , i ; begin
8353: LD_INT 0
8355: PPUSH
8356: PPUSH
8357: PPUSH
// DialogueOn ;
8358: CALL_OW 6
// CenterOnUnits ( Rusi_sever ) ;
8362: LD_EXP 56
8366: PPUSH
8367: CALL_OW 85
// wait ( 0 0$2 ) ;
8371: LD_INT 70
8373: PPUSH
8374: CALL_OW 67
// pom = UnitFilter ( Amici_past , [ [ f_ok ] , [ f_type , unit_human ] ] ) ;
8378: LD_ADDR_VAR 0 2
8382: PUSH
8383: LD_EXP 72
8387: PPUSH
8388: LD_INT 50
8390: PUSH
8391: EMPTY
8392: LIST
8393: PUSH
8394: LD_INT 21
8396: PUSH
8397: LD_INT 1
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PPUSH
8408: CALL_OW 72
8412: ST_TO_ADDR
// for i in pom do
8413: LD_ADDR_VAR 0 3
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: FOR_IN
8424: IFFALSE 8457
// if GetSex ( i ) = sex_male then
8426: LD_VAR 0 3
8430: PPUSH
8431: CALL_OW 258
8435: PUSH
8436: LD_INT 1
8438: EQUAL
8439: IFFALSE 8455
// begin SayRadio ( i , D13-Sol1-1 ) ;
8441: LD_VAR 0 3
8445: PPUSH
8446: LD_STRING D13-Sol1-1
8448: PPUSH
8449: CALL_OW 94
// break ;
8453: GO 8457
// end ;
8455: GO 8423
8457: POP
8458: POP
// SayRadio ( bel , D13-Bel-1 ) ;
8459: LD_EXP 52
8463: PPUSH
8464: LD_STRING D13-Bel-1
8466: PPUSH
8467: CALL_OW 94
// SayRadio ( kurin , D13-Kur-1 ) ;
8471: LD_EXP 53
8475: PPUSH
8476: LD_STRING D13-Kur-1
8478: PPUSH
8479: CALL_OW 94
// SayRadio ( bel , D13-Bel-2 ) ;
8483: LD_EXP 52
8487: PPUSH
8488: LD_STRING D13-Bel-2
8490: PPUSH
8491: CALL_OW 94
// end ;
8495: LD_VAR 0 1
8499: RET
// export function rozhovor_ukonceni_m5 ; begin
8500: LD_INT 0
8502: PPUSH
// wait ( 0 0$2 ) ;
8503: LD_INT 70
8505: PPUSH
8506: CALL_OW 67
// DialogueOn ;
8510: CALL_OW 6
// Say ( bur , D12-Bur-1 ) ;
8514: LD_EXP 50
8518: PPUSH
8519: LD_STRING D12-Bur-1
8521: PPUSH
8522: CALL_OW 88
// Say ( plat , D12-Pla-1 ) ;
8526: LD_EXP 54
8530: PPUSH
8531: LD_STRING D12-Pla-1
8533: PPUSH
8534: CALL_OW 88
// Say ( bur , D12-Bur-2 ) ;
8538: LD_EXP 50
8542: PPUSH
8543: LD_STRING D12-Bur-2
8545: PPUSH
8546: CALL_OW 88
// Say ( plat , D12-Pla-2 ) ;
8550: LD_EXP 54
8554: PPUSH
8555: LD_STRING D12-Pla-2
8557: PPUSH
8558: CALL_OW 88
// Say ( bur , D12-Bur-3 ) ;
8562: LD_EXP 50
8566: PPUSH
8567: LD_STRING D12-Bur-3
8569: PPUSH
8570: CALL_OW 88
// Say ( plat , D12-Pla-3 ) ;
8574: LD_EXP 54
8578: PPUSH
8579: LD_STRING D12-Pla-3
8581: PPUSH
8582: CALL_OW 88
// ChangeMissionObjectives ( M6 ) ;
8586: LD_STRING M6
8588: PPUSH
8589: CALL_OW 337
// DialogueOff ;
8593: CALL_OW 7
// disable ( 992 ) ;
8597: LD_INT 992
8599: DISABLE_MARKED
// MissionProper ;
8600: CALL 2028 0 0
// end ;
8604: LD_VAR 0 1
8608: RET
// every 0 0$5 trigger stav = 7 do var i ; var pom ; var avideni ;
8609: LD_EXP 60
8613: PUSH
8614: LD_INT 7
8616: EQUAL
8617: IFFALSE 9406
8619: GO 8621
8621: DISABLE
8622: LD_INT 0
8624: PPUSH
8625: PPUSH
8626: PPUSH
// begin wait ( 0 0$1 ) ;
8627: LD_INT 35
8629: PPUSH
8630: CALL_OW 67
// dialog_past_amici ;
8634: CALL 8353 0 0
// CenterNowOnXY ( 58 , 17 ) ;
8638: LD_INT 58
8640: PPUSH
8641: LD_INT 17
8643: PPUSH
8644: CALL_OW 86
// ComMoveXY ( Rusi_sever , 59 , 16 ) ;
8648: LD_EXP 56
8652: PPUSH
8653: LD_INT 59
8655: PPUSH
8656: LD_INT 16
8658: PPUSH
8659: CALL_OW 111
// pom = FilterAllUnits ( [ [ f_side , You ] ] ) ;
8663: LD_ADDR_VAR 0 2
8667: PUSH
8668: LD_INT 22
8670: PUSH
8671: LD_EXP 1
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: PUSH
8680: EMPTY
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: ST_TO_ADDR
// ComStop ( pom ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 141
// for i in pom do
8697: LD_ADDR_VAR 0 1
8701: PUSH
8702: LD_VAR 0 2
8706: PUSH
8707: FOR_IN
8708: IFFALSE 8726
// DoNotAttack ( Amici , i ) ;
8710: LD_EXP 2
8714: PPUSH
8715: LD_VAR 0 1
8719: PPUSH
8720: CALL_OW 471
8724: GO 8707
8726: POP
8727: POP
// DoNotAttack ( Amici , bel ) ;
8728: LD_EXP 2
8732: PPUSH
8733: LD_EXP 52
8737: PPUSH
8738: CALL_OW 471
// DialogueOff ;
8742: CALL_OW 7
// InGameOn ;
8746: CALL_OW 8
// avideni = place_amik_k_videni ;
8750: LD_ADDR_VAR 0 3
8754: PUSH
8755: CALL 4969 0 0
8759: ST_TO_ADDR
// ComMoveXY ( avideni , 55 , 11 ) ;
8760: LD_VAR 0 3
8764: PPUSH
8765: LD_INT 55
8767: PPUSH
8768: LD_INT 11
8770: PPUSH
8771: CALL_OW 111
// while FilterAllUnits ( [ [ f_side , Amici ] , [ f_see , You2 ] ] ) = 0 do
8775: LD_INT 22
8777: PUSH
8778: LD_EXP 2
8782: PUSH
8783: EMPTY
8784: LIST
8785: LIST
8786: PUSH
8787: LD_INT 101
8789: PUSH
8790: LD_EXP 4
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PUSH
8808: LD_INT 0
8810: EQUAL
8811: IFFALSE 8837
// begin wait ( 0 0$03 ) ;
8813: LD_INT 105
8815: PPUSH
8816: CALL_OW 67
// ComMoveXY ( avideni , 55 , 11 ) ;
8820: LD_VAR 0 3
8824: PPUSH
8825: LD_INT 55
8827: PPUSH
8828: LD_INT 11
8830: PPUSH
8831: CALL_OW 111
// end ;
8835: GO 8775
// DoNotAttack ( Amici , auto_belkov ) ;
8837: LD_EXP 2
8841: PPUSH
8842: LD_EXP 70
8846: PPUSH
8847: CALL_OW 471
// while IsInUnit ( bel ) do
8851: LD_EXP 52
8855: PPUSH
8856: CALL_OW 310
8860: IFFALSE 8880
// begin ComExitVehicle ( bel ) ;
8862: LD_EXP 52
8866: PPUSH
8867: CALL_OW 121
// wait ( 0 0$0.1 ) ;
8871: LD_INT 4
8873: PPUSH
8874: CALL_OW 67
// end ;
8878: GO 8851
// Amici_past = Amici_past ^ avideni ;
8880: LD_ADDR_EXP 72
8884: PUSH
8885: LD_EXP 72
8889: PUSH
8890: LD_VAR 0 3
8894: ADD
8895: ST_TO_ADDR
// wait ( 0 0$0.5 ) ;
8896: LD_INT 18
8898: PPUSH
8899: CALL_OW 67
// AddComMoveXY ( bel , 47 , 7 ) ;
8903: LD_EXP 52
8907: PPUSH
8908: LD_INT 47
8910: PPUSH
8911: LD_INT 7
8913: PPUSH
8914: CALL_OW 171
// AddComMoveXY ( bel , 33 , 5 ) ;
8918: LD_EXP 52
8922: PPUSH
8923: LD_INT 33
8925: PPUSH
8926: LD_INT 5
8928: PPUSH
8929: CALL_OW 171
// AddComMoveXY ( bel , 34 , 11 ) ;
8933: LD_EXP 52
8937: PPUSH
8938: LD_INT 34
8940: PPUSH
8941: LD_INT 11
8943: PPUSH
8944: CALL_OW 171
// AddComMoveXY ( bel , 45 , 13 ) ;
8948: LD_EXP 52
8952: PPUSH
8953: LD_INT 45
8955: PPUSH
8956: LD_INT 13
8958: PPUSH
8959: CALL_OW 171
// SetLives ( IsInUnit ( bel ) , 600 ) ;
8963: LD_EXP 52
8967: PPUSH
8968: CALL_OW 310
8972: PPUSH
8973: LD_INT 600
8975: PPUSH
8976: CALL_OW 234
// ComWalk ( Amici_past ) ;
8980: LD_EXP 72
8984: PPUSH
8985: CALL_OW 138
// InGameOff ;
8989: CALL_OW 9
// DialogueOn ;
8993: CALL_OW 6
// Say ( Amici_past [ 1 ] , D14-Sol1-1 ) ;
8997: LD_EXP 72
9001: PUSH
9002: LD_INT 1
9004: ARRAY
9005: PPUSH
9006: LD_STRING D14-Sol1-1
9008: PPUSH
9009: CALL_OW 88
// DialogueOff ;
9013: CALL_OW 7
// music_class = music_combat ;
9017: LD_ADDR_OWVAR 72
9021: PUSH
9022: LD_INT 1
9024: ST_TO_ADDR
// InGameOn ;
9025: CALL_OW 8
// for i in Rusi_sever do
9029: LD_ADDR_VAR 0 1
9033: PUSH
9034: LD_EXP 56
9038: PUSH
9039: FOR_IN
9040: IFFALSE 9075
// if GetType ( i ) = unit_vehicle then
9042: LD_VAR 0 1
9046: PPUSH
9047: CALL_OW 247
9051: PUSH
9052: LD_INT 2
9054: EQUAL
9055: IFFALSE 9073
// Rusi_sever = Rusi_sever diff i ;
9057: LD_ADDR_EXP 56
9061: PUSH
9062: LD_EXP 56
9066: PUSH
9067: LD_VAR 0 1
9071: DIFF
9072: ST_TO_ADDR
9073: GO 9039
9075: POP
9076: POP
// ComMoveXY ( Rusi_sever , 47 , 7 ) ;
9077: LD_EXP 56
9081: PPUSH
9082: LD_INT 47
9084: PPUSH
9085: LD_INT 7
9087: PPUSH
9088: CALL_OW 111
// AddComMoveXY ( Rusi_sever , 33 , 5 ) ;
9092: LD_EXP 56
9096: PPUSH
9097: LD_INT 33
9099: PPUSH
9100: LD_INT 5
9102: PPUSH
9103: CALL_OW 171
// AddComMoveXY ( Rusi_sever , 34 , 11 ) ;
9107: LD_EXP 56
9111: PPUSH
9112: LD_INT 34
9114: PPUSH
9115: LD_INT 11
9117: PPUSH
9118: CALL_OW 171
// AddComMoveXY ( Rusi_sever , 45 , 13 ) ;
9122: LD_EXP 56
9126: PPUSH
9127: LD_INT 45
9129: PPUSH
9130: LD_INT 13
9132: PPUSH
9133: CALL_OW 171
// Rusi_sever = Rusi_sever ^ bel ;
9137: LD_ADDR_EXP 56
9141: PUSH
9142: LD_EXP 56
9146: PUSH
9147: LD_EXP 52
9151: ADD
9152: ST_TO_ADDR
// InGameOff ;
9153: CALL_OW 9
// DialogueOn ;
9157: CALL_OW 6
// Say ( bel , D14-Bel-1 ) ;
9161: LD_EXP 52
9165: PPUSH
9166: LD_STRING D14-Bel-1
9168: PPUSH
9169: CALL_OW 88
// DialogueOff ;
9173: CALL_OW 7
// InGameOn ;
9177: CALL_OW 8
// ComAgressiveMove ( Amici_past , 62 , 18 ) ;
9181: LD_EXP 72
9185: PPUSH
9186: LD_INT 62
9188: PPUSH
9189: LD_INT 18
9191: PPUSH
9192: CALL_OW 114
// wait ( 2 ) ;
9196: LD_INT 2
9198: PPUSH
9199: CALL_OW 67
// rusi_save_belkov ;
9203: CALL 15918 0 0
// amici_boj ;
9207: CALL 17768 0 0
// belkov_solved = 1 ;
9211: LD_ADDR_EXP 48
9215: PUSH
9216: LD_INT 1
9218: ST_TO_ADDR
// CenterOnUnits ( [ bel ] ) ;
9219: LD_EXP 52
9223: PUSH
9224: EMPTY
9225: LIST
9226: PPUSH
9227: CALL_OW 85
// wait ( 0 0$2 ) ;
9231: LD_INT 70
9233: PPUSH
9234: CALL_OW 67
// while not See ( Amici , bel ) do
9238: LD_EXP 2
9242: PPUSH
9243: LD_EXP 52
9247: PPUSH
9248: CALL_OW 292
9252: NOT
9253: IFFALSE 9278
// begin AddComMoveUnit ( Amici_past , bel ) ;
9255: LD_EXP 72
9259: PPUSH
9260: LD_EXP 52
9264: PPUSH
9265: CALL_OW 172
// wait ( 0 0$1 ) ;
9269: LD_INT 35
9271: PPUSH
9272: CALL_OW 67
// end ;
9276: GO 9238
// InGameOff ;
9278: CALL_OW 9
// DialogueOn ;
9282: CALL_OW 6
// SayRadio ( bel , D14-Bel-1a ) ;
9286: LD_EXP 52
9290: PPUSH
9291: LD_STRING D14-Bel-1a
9293: PPUSH
9294: CALL_OW 94
// SayRadio ( kurin , D14-Kur-1 ) ;
9298: LD_EXP 53
9302: PPUSH
9303: LD_STRING D14-Kur-1
9305: PPUSH
9306: CALL_OW 94
// SayRadio ( bel , D14-Bel-2 ) ;
9310: LD_EXP 52
9314: PPUSH
9315: LD_STRING D14-Bel-2
9317: PPUSH
9318: CALL_OW 94
// SayRadio ( kurin , D14-Kur-2 ) ;
9322: LD_EXP 53
9326: PPUSH
9327: LD_STRING D14-Kur-2
9329: PPUSH
9330: CALL_OW 94
// DialogueOff ;
9334: CALL_OW 7
// music_class = 0 ;
9338: LD_ADDR_OWVAR 72
9342: PUSH
9343: LD_INT 0
9345: ST_TO_ADDR
// for i in pom do
9346: LD_ADDR_VAR 0 1
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: FOR_IN
9357: IFFALSE 9375
// NormalAttack ( Amici , i ) ;
9359: LD_EXP 2
9363: PPUSH
9364: LD_VAR 0 1
9368: PPUSH
9369: CALL_OW 472
9373: GO 9356
9375: POP
9376: POP
// NormalAttack ( Amici , bel ) ;
9377: LD_EXP 2
9381: PPUSH
9382: LD_EXP 52
9386: PPUSH
9387: CALL_OW 472
// amici_po_kecech ;
9391: CALL 19046 0 0
// wait ( 0 0$5 ) ;
9395: LD_INT 175
9397: PPUSH
9398: CALL_OW 67
// dialog_burlak_help ;
9402: CALL 9409 0 0
// end ;
9406: PPOPN 3
9408: END
// function dialog_burlak_help ; begin
9409: LD_INT 0
9411: PPUSH
// DialogueOn ;
9412: CALL_OW 6
// Say ( bur , D14a-Bur-1 ) ;
9416: LD_EXP 50
9420: PPUSH
9421: LD_STRING D14a-Bur-1
9423: PPUSH
9424: CALL_OW 88
// Say ( plat , D14a-Pla-1 ) ;
9428: LD_EXP 54
9432: PPUSH
9433: LD_STRING D14a-Pla-1
9435: PPUSH
9436: CALL_OW 88
// Say ( bur , D14a-Bur-2 ) ;
9440: LD_EXP 50
9444: PPUSH
9445: LD_STRING D14a-Bur-2
9447: PPUSH
9448: CALL_OW 88
// Say ( plat , D14a-Pla-2 ) ;
9452: LD_EXP 54
9456: PPUSH
9457: LD_STRING D14a-Pla-2
9459: PPUSH
9460: CALL_OW 88
// Say ( bur , D14a-Bur-3 ) ;
9464: LD_EXP 50
9468: PPUSH
9469: LD_STRING D14a-Bur-3
9471: PPUSH
9472: CALL_OW 88
// Say ( plat , D14a-Pla-3 ) ;
9476: LD_EXP 54
9480: PPUSH
9481: LD_STRING D14a-Pla-3
9483: PPUSH
9484: CALL_OW 88
// Say ( bur , D14a-Bur-4 ) ;
9488: LD_EXP 50
9492: PPUSH
9493: LD_STRING D14a-Bur-4
9495: PPUSH
9496: CALL_OW 88
// Say ( plat , D14a-Pla-4 ) ;
9500: LD_EXP 54
9504: PPUSH
9505: LD_STRING D14a-Pla-4
9507: PPUSH
9508: CALL_OW 88
// DialogueOff ;
9512: CALL_OW 7
// end ;
9516: LD_VAR 0 1
9520: RET
// every 0 0$6 trigger bedny_hint do
9521: LD_EXP 65
9525: IFFALSE 9537
9527: GO 9529
9529: DISABLE
// begin Hint ( GatheringMaterial ) ;
9530: LD_STRING GatheringMaterial
9532: PPUSH
9533: CALL_OW 339
// end ;
9537: END
// export function hlaska_platonov_bedny ; begin
9538: LD_INT 0
9540: PPUSH
// Say ( plat , D4-Pla-1 ) ;
9541: LD_EXP 54
9545: PPUSH
9546: LD_STRING D4-Pla-1
9548: PPUSH
9549: CALL_OW 88
// end ;
9553: LD_VAR 0 1
9557: RET
// function GetPeople ( sex , povolani , diffseznam ) ; var pom , pom1 , pom2 , pom3 , pom4 ; begin
9558: LD_INT 0
9560: PPUSH
9561: PPUSH
9562: PPUSH
9563: PPUSH
9564: PPUSH
9565: PPUSH
// pom1 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_scientistic ] , [ f_sex , sex ] ] ) ;
9566: LD_ADDR_VAR 0 6
9570: PUSH
9571: LD_INT 22
9573: PUSH
9574: LD_EXP 1
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 25
9585: PUSH
9586: LD_INT 4
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: PUSH
9593: LD_INT 26
9595: PUSH
9596: LD_VAR 0 1
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: ST_TO_ADDR
// pom2 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_mechanic ] , [ f_sex , sex ] ] ) ;
9615: LD_ADDR_VAR 0 7
9619: PUSH
9620: LD_INT 22
9622: PUSH
9623: LD_EXP 1
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: PUSH
9632: LD_INT 25
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: PUSH
9642: LD_INT 26
9644: PUSH
9645: LD_VAR 0 1
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: LIST
9658: PPUSH
9659: CALL_OW 69
9663: ST_TO_ADDR
// pom3 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_engineer ] , [ f_sex , sex ] ] ) ;
9664: LD_ADDR_VAR 0 8
9668: PUSH
9669: LD_INT 22
9671: PUSH
9672: LD_EXP 1
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PUSH
9681: LD_INT 25
9683: PUSH
9684: LD_INT 2
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 26
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: LIST
9707: PPUSH
9708: CALL_OW 69
9712: ST_TO_ADDR
// pom4 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_soldier ] , [ f_sex , sex ] ] ) ;
9713: LD_ADDR_VAR 0 9
9717: PUSH
9718: LD_INT 22
9720: PUSH
9721: LD_EXP 1
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: LD_INT 25
9732: PUSH
9733: LD_INT 1
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 26
9742: PUSH
9743: LD_VAR 0 1
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PPUSH
9757: CALL_OW 69
9761: ST_TO_ADDR
// case povolani of class_scientistic :
9762: LD_VAR 0 2
9766: PUSH
9767: LD_INT 4
9769: DOUBLE
9770: EQUAL
9771: IFTRUE 9775
9773: GO 9788
9775: POP
// pom = pom1 ; class_mechanic :
9776: LD_ADDR_VAR 0 5
9780: PUSH
9781: LD_VAR 0 6
9785: ST_TO_ADDR
9786: GO 9852
9788: LD_INT 3
9790: DOUBLE
9791: EQUAL
9792: IFTRUE 9796
9794: GO 9809
9796: POP
// pom = pom2 ; class_engineer :
9797: LD_ADDR_VAR 0 5
9801: PUSH
9802: LD_VAR 0 7
9806: ST_TO_ADDR
9807: GO 9852
9809: LD_INT 2
9811: DOUBLE
9812: EQUAL
9813: IFTRUE 9817
9815: GO 9830
9817: POP
// pom = pom3 ; class_soldier :
9818: LD_ADDR_VAR 0 5
9822: PUSH
9823: LD_VAR 0 8
9827: ST_TO_ADDR
9828: GO 9852
9830: LD_INT 1
9832: DOUBLE
9833: EQUAL
9834: IFTRUE 9838
9836: GO 9851
9838: POP
// pom = pom4 ; end ;
9839: LD_ADDR_VAR 0 5
9843: PUSH
9844: LD_VAR 0 9
9848: ST_TO_ADDR
9849: GO 9852
9851: POP
// if povolani <> class_scientistic then
9852: LD_VAR 0 2
9856: PUSH
9857: LD_INT 4
9859: NONEQUAL
9860: IFFALSE 9878
// pom = pom ^ pom1 ;
9862: LD_ADDR_VAR 0 5
9866: PUSH
9867: LD_VAR 0 5
9871: PUSH
9872: LD_VAR 0 6
9876: ADD
9877: ST_TO_ADDR
// if povolani <> class_mechanic then
9878: LD_VAR 0 2
9882: PUSH
9883: LD_INT 3
9885: NONEQUAL
9886: IFFALSE 9904
// pom = pom ^ pom2 ;
9888: LD_ADDR_VAR 0 5
9892: PUSH
9893: LD_VAR 0 5
9897: PUSH
9898: LD_VAR 0 7
9902: ADD
9903: ST_TO_ADDR
// if povolani <> class_engineer then
9904: LD_VAR 0 2
9908: PUSH
9909: LD_INT 2
9911: NONEQUAL
9912: IFFALSE 9930
// pom = pom ^ pom3 ;
9914: LD_ADDR_VAR 0 5
9918: PUSH
9919: LD_VAR 0 5
9923: PUSH
9924: LD_VAR 0 8
9928: ADD
9929: ST_TO_ADDR
// if povolani <> class_soldier then
9930: LD_VAR 0 2
9934: PUSH
9935: LD_INT 1
9937: NONEQUAL
9938: IFFALSE 9956
// pom = pom ^ pom4 ;
9940: LD_ADDR_VAR 0 5
9944: PUSH
9945: LD_VAR 0 5
9949: PUSH
9950: LD_VAR 0 9
9954: ADD
9955: ST_TO_ADDR
// result := pom diff diffseznam ;
9956: LD_ADDR_VAR 0 4
9960: PUSH
9961: LD_VAR 0 5
9965: PUSH
9966: LD_VAR 0 3
9970: DIFF
9971: ST_TO_ADDR
// end ;
9972: LD_VAR 0 4
9976: RET
// every 0 0$1 trigger test_is_in_area_burlak and venku marked 991 do var pom ;
9977: CALL 13411 0 0
9981: PUSH
9982: LD_EXP 61
9986: AND
9987: IFFALSE 10074
9989: GO 9991
9991: DISABLE
9992: LD_INT 0
9994: PPUSH
// begin pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: LD_INT 3
10002: PPUSH
10003: LD_INT 22
10005: PUSH
10006: LD_EXP 1
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PUSH
10015: LD_INT 21
10017: PUSH
10018: LD_INT 2
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PPUSH
10029: CALL_OW 70
10033: ST_TO_ADDR
// if pom > 0 then
10034: LD_VAR 0 1
10038: PUSH
10039: LD_INT 0
10041: GREATER
10042: IFFALSE 10046
// exit ;
10044: GO 10074
// InGameOn ;
10046: CALL_OW 8
// Say ( kurin , D1a-Kur-1 ) ;
10050: LD_EXP 53
10054: PPUSH
10055: LD_STRING D1a-Kur-1
10057: PPUSH
10058: CALL_OW 88
// InGameOff ;
10062: CALL_OW 9
// venku = false ;
10066: LD_ADDR_EXP 61
10070: PUSH
10071: LD_INT 0
10073: ST_TO_ADDR
// end ;
10074: PPOPN 1
10076: END
// every 0 0$1 trigger test_is_in_area_burlak and venku marked 992 do var pom ;
10077: CALL 13411 0 0
10081: PUSH
10082: LD_EXP 61
10086: AND
10087: IFFALSE 10175
10089: GO 10091
10091: DISABLE
10092: LD_INT 0
10094: PPUSH
// begin pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
10095: LD_ADDR_VAR 0 1
10099: PUSH
10100: LD_INT 3
10102: PPUSH
10103: LD_INT 22
10105: PUSH
10106: LD_EXP 1
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PUSH
10115: LD_INT 21
10117: PUSH
10118: LD_INT 2
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 70
10133: ST_TO_ADDR
// if pom > 0 then
10134: LD_VAR 0 1
10138: PUSH
10139: LD_INT 0
10141: GREATER
10142: IFFALSE 10174
// begin InGameOn ;
10144: CALL_OW 8
// Say ( kurin , D1a-Kur-1a ) ;
10148: LD_EXP 53
10152: PPUSH
10153: LD_STRING D1a-Kur-1a
10155: PPUSH
10156: CALL_OW 88
// InGameOff ;
10160: CALL_OW 9
// venku = false ;
10164: LD_ADDR_EXP 61
10168: PUSH
10169: LD_INT 0
10171: ST_TO_ADDR
// end else
10172: GO 10175
// enable ;
10174: ENABLE
// end ;
10175: PPOPN 1
10177: END
// every 0 0$2 trigger stav > 6 and not IsInArea ( bur , RU2_base ) do
10178: LD_EXP 60
10182: PUSH
10183: LD_INT 6
10185: GREATER
10186: PUSH
10187: LD_EXP 50
10191: PPUSH
10192: LD_INT 1
10194: PPUSH
10195: CALL_OW 308
10199: NOT
10200: AND
10201: IFFALSE 10215
10203: GO 10205
10205: DISABLE
// begin je_mimo = true ;
10206: LD_ADDR_LOC 7
10210: PUSH
10211: LD_INT 1
10213: ST_TO_ADDR
// enable ;
10214: ENABLE
// end ;
10215: END
// export function dialog_belkov_smrt ; var pom ; begin
10216: LD_INT 0
10218: PPUSH
10219: PPUSH
// InGameOn ;
10220: CALL_OW 8
// belkov_solved = 3 ;
10224: LD_ADDR_EXP 48
10228: PUSH
10229: LD_INT 3
10231: ST_TO_ADDR
// if pom >= procento_odkrytych_pro_vyhru [ difficulty ] and FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) = 0 then
10232: LD_VAR 0 2
10236: PUSH
10237: LD_EXP 42
10241: PUSH
10242: LD_OWVAR 67
10246: ARRAY
10247: GREATEREQUAL
10248: PUSH
10249: LD_INT 9
10251: PPUSH
10252: LD_INT 22
10254: PUSH
10255: LD_EXP 2
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 30
10266: PUSH
10267: LD_INT 31
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: PPUSH
10278: CALL_OW 70
10282: PUSH
10283: LD_INT 0
10285: EQUAL
10286: AND
10287: IFFALSE 10306
// begin navrat_a_konec = true ;
10289: LD_ADDR_EXP 47
10293: PUSH
10294: LD_INT 1
10296: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
10297: LD_STRING M10a
10299: PPUSH
10300: CALL_OW 337
// end else
10304: GO 10313
// ChangeMissionObjectives ( M9a ) ;
10306: LD_STRING M9a
10308: PPUSH
10309: CALL_OW 337
// InGameOff ;
10313: CALL_OW 9
// end ;
10317: LD_VAR 0 1
10321: RET
// every 0 0$1 do var pom , i ; var Ru_Units ;
10322: GO 10324
10324: DISABLE
10325: LD_INT 0
10327: PPUSH
10328: PPUSH
10329: PPUSH
// begin Ru_Units = FilterAllUnits ( [ [ f_side , You ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10330: LD_ADDR_VAR 0 3
10334: PUSH
10335: LD_INT 22
10337: PUSH
10338: LD_EXP 1
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 2
10349: PUSH
10350: LD_INT 21
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 21
10362: PUSH
10363: LD_INT 2
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: EMPTY
10371: LIST
10372: LIST
10373: LIST
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: PPUSH
10379: CALL_OW 69
10383: ST_TO_ADDR
// for i in Ru_Units do
10384: LD_ADDR_VAR 0 2
10388: PUSH
10389: LD_VAR 0 3
10393: PUSH
10394: FOR_IN
10395: IFFALSE 10514
// begin pom = Attacks ( i ) ;
10397: LD_ADDR_VAR 0 1
10401: PUSH
10402: LD_VAR 0 2
10406: PPUSH
10407: CALL_OW 320
10411: ST_TO_ADDR
// if pom <> 0 then
10412: LD_VAR 0 1
10416: PUSH
10417: LD_INT 0
10419: NONEQUAL
10420: IFFALSE 10462
// if Getside ( pom ) in [ You2 , You3 ] then
10422: LD_VAR 0 1
10426: PPUSH
10427: CALL_OW 255
10431: PUSH
10432: LD_EXP 4
10436: PUSH
10437: LD_EXP 6
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: IN
10446: IFFALSE 10462
// konstanta_utoceni = konstanta_utoceni + 1 ;
10448: LD_ADDR_LOC 15
10452: PUSH
10453: LD_LOC 15
10457: PUSH
10458: LD_INT 1
10460: PLUS
10461: ST_TO_ADDR
// if pom = bel or pom = plat or pom = kurin then
10462: LD_VAR 0 1
10466: PUSH
10467: LD_EXP 52
10471: EQUAL
10472: PUSH
10473: LD_VAR 0 1
10477: PUSH
10478: LD_EXP 54
10482: EQUAL
10483: OR
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 53
10494: EQUAL
10495: OR
10496: IFFALSE 10512
// konstanta_utoceni = konstanta_utoceni + 10 ;
10498: LD_ADDR_LOC 15
10502: PUSH
10503: LD_LOC 15
10507: PUSH
10508: LD_INT 10
10510: PLUS
10511: ST_TO_ADDR
// end ;
10512: GO 10394
10514: POP
10515: POP
// if konstanta_utoceni < 10 then
10516: LD_LOC 15
10520: PUSH
10521: LD_INT 10
10523: LESS
10524: IFFALSE 10527
// enable ;
10526: ENABLE
// end ;
10527: PPOPN 3
10529: END
// every 0 0$1 trigger konstanta_utoceni >= 10 do
10530: LD_LOC 15
10534: PUSH
10535: LD_INT 10
10537: GREATEREQUAL
10538: IFFALSE 10547
10540: GO 10542
10542: DISABLE
// begin konec_mise_utok ;
10543: CALL 234 0 0
// end ;
10547: END
// export function hint_skilly ; begin
10548: LD_INT 0
10550: PPUSH
// Hint ( Skills ) ;
10551: LD_STRING Skills
10553: PPUSH
10554: CALL_OW 339
// end ;
10558: LD_VAR 0 1
10562: RET
// every 0 0$2 do var pom ; var i ; var hinton ;
10563: GO 10565
10565: DISABLE
10566: LD_INT 0
10568: PPUSH
10569: PPUSH
10570: PPUSH
// begin hinton = false ;
10571: LD_ADDR_VAR 0 3
10575: PUSH
10576: LD_INT 0
10578: ST_TO_ADDR
// pom = FilterUnitsInArea ( VEHCAP , [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) ;
10579: LD_ADDR_VAR 0 1
10583: PUSH
10584: LD_INT 30
10586: PPUSH
10587: LD_INT 22
10589: PUSH
10590: LD_EXP 2
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: PUSH
10599: LD_INT 21
10601: PUSH
10602: LD_INT 2
10604: PUSH
10605: EMPTY
10606: LIST
10607: LIST
10608: PUSH
10609: EMPTY
10610: LIST
10611: LIST
10612: PPUSH
10613: CALL_OW 70
10617: ST_TO_ADDR
// for i in pom do
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_VAR 0 1
10627: PUSH
10628: FOR_IN
10629: IFFALSE 10656
// if IsDrivenBy ( i ) = 0 then
10631: LD_VAR 0 2
10635: PPUSH
10636: CALL_OW 311
10640: PUSH
10641: LD_INT 0
10643: EQUAL
10644: IFFALSE 10654
// hinton = true ;
10646: LD_ADDR_VAR 0 3
10650: PUSH
10651: LD_INT 1
10653: ST_TO_ADDR
10654: GO 10628
10656: POP
10657: POP
// if hinton then
10658: LD_VAR 0 3
10662: IFFALSE 10673
// Hint ( CapturingVehicles1 ) else
10664: LD_STRING CapturingVehicles1
10666: PPUSH
10667: CALL_OW 339
10671: GO 10674
// enable ;
10673: ENABLE
// end ;
10674: PPOPN 3
10676: END
// every 0 0$2 do var pom , i ; var BUDE_hint ;
10677: GO 10679
10679: DISABLE
10680: LD_INT 0
10682: PPUSH
10683: PPUSH
10684: PPUSH
// begin BUDE_hint = false ;
10685: LD_ADDR_VAR 0 3
10689: PUSH
10690: LD_INT 0
10692: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_building ] ] ) ;
10693: LD_ADDR_VAR 0 1
10697: PUSH
10698: LD_INT 22
10700: PUSH
10701: LD_EXP 1
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PUSH
10710: LD_INT 21
10712: PUSH
10713: LD_INT 3
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PPUSH
10724: CALL_OW 69
10728: ST_TO_ADDR
// for i in pom do
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_VAR 0 1
10738: PUSH
10739: FOR_IN
10740: IFFALSE 10767
// if IsConstructed ( i ) <> 0 then
10742: LD_VAR 0 2
10746: PPUSH
10747: CALL_OW 304
10751: PUSH
10752: LD_INT 0
10754: NONEQUAL
10755: IFFALSE 10765
// BUDE_hint = true ;
10757: LD_ADDR_VAR 0 3
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
10765: GO 10739
10767: POP
10768: POP
// if BUDE_hint then
10769: LD_VAR 0 3
10773: IFFALSE 10784
// Hint ( Building2 ) else
10775: LD_STRING Building2
10777: PPUSH
10778: CALL_OW 339
10782: GO 10785
// enable ;
10784: ENABLE
// end ; end_of_file
10785: PPOPN 3
10787: END
// var PlayingLooped ; export function play_dialog_15 ; begin
10788: LD_INT 0
10790: PPUSH
// while playing do
10791: LD_EXP 34
10795: IFFALSE 10806
// wait ( 0 0$1 ) ;
10797: LD_INT 35
10799: PPUSH
10800: CALL_OW 67
10804: GO 10791
// playing := true ;
10806: LD_ADDR_EXP 34
10810: PUSH
10811: LD_INT 1
10813: ST_TO_ADDR
// CenterOnXY ( 60 , 52 ) ;
10814: LD_INT 60
10816: PPUSH
10817: LD_INT 52
10819: PPUSH
10820: CALL_OW 84
// DialogueOn ;
10824: CALL_OW 6
// say ( Bur , D15-Bur-1 ) ;
10828: LD_EXP 50
10832: PPUSH
10833: LD_STRING D15-Bur-1
10835: PPUSH
10836: CALL_OW 88
// if IsOK ( Gny ) then
10840: LD_EXP 49
10844: PPUSH
10845: CALL_OW 302
10849: IFFALSE 10865
// say ( Gny , D15-Gny-1 ) else
10851: LD_EXP 49
10855: PPUSH
10856: LD_STRING D15-Gny-1
10858: PPUSH
10859: CALL_OW 88
10863: GO 10904
// if not BelkovFreed and IsOK ( Kov ) then
10865: LD_EXP 16
10869: NOT
10870: PUSH
10871: LD_EXP 51
10875: PPUSH
10876: CALL_OW 302
10880: AND
10881: IFFALSE 10897
// say ( Kov , D15-Kov-1 ) else
10883: LD_EXP 51
10887: PPUSH
10888: LD_STRING D15-Kov-1
10890: PPUSH
10891: CALL_OW 88
10895: GO 10904
// Wait ( 0 0$5 ) ;
10897: LD_INT 175
10899: PPUSH
10900: CALL_OW 67
// if not InWest then
10904: LD_EXP 31
10908: NOT
10909: IFFALSE 10967
// begin say ( Bur , D15-Bur-2 ) ;
10911: LD_EXP 50
10915: PPUSH
10916: LD_STRING D15-Bur-2
10918: PPUSH
10919: CALL_OW 88
// if IsOK ( Kov ) then
10923: LD_EXP 51
10927: PPUSH
10928: CALL_OW 302
10932: IFFALSE 10948
// say ( Kov , D15-Kov-2 ) else
10934: LD_EXP 51
10938: PPUSH
10939: LD_STRING D15-Kov-2
10941: PPUSH
10942: CALL_OW 88
10946: GO 10955
// wait ( 0 0$5 ) ;
10948: LD_INT 175
10950: PPUSH
10951: CALL_OW 67
// say ( Bur , D15-Bur-3 ) ;
10955: LD_EXP 50
10959: PPUSH
10960: LD_STRING D15-Bur-3
10962: PPUSH
10963: CALL_OW 88
// end ; DialogueOff ;
10967: CALL_OW 7
// CenterOnUnits ( BurlakComp ) ;
10971: LD_EXP 14
10975: PPUSH
10976: CALL_OW 85
// playing := false ;
10980: LD_ADDR_EXP 34
10984: PUSH
10985: LD_INT 0
10987: ST_TO_ADDR
// end ;
10988: LD_VAR 0 1
10992: RET
// export function play_dialog_qwbw1 ; begin
10993: LD_INT 0
10995: PPUSH
// while playing do
10996: LD_EXP 34
11000: IFFALSE 11011
// wait ( 0 0$1 ) ;
11002: LD_INT 35
11004: PPUSH
11005: CALL_OW 67
11009: GO 10996
// playing := true ;
11011: LD_ADDR_EXP 34
11015: PUSH
11016: LD_INT 1
11018: ST_TO_ADDR
// say ( Bur , D17-Bur-1 ) ;
11019: LD_EXP 50
11023: PPUSH
11024: LD_STRING D17-Bur-1
11026: PPUSH
11027: CALL_OW 88
// say ( Plat , D17-Pla-1 ) ;
11031: LD_EXP 54
11035: PPUSH
11036: LD_STRING D17-Pla-1
11038: PPUSH
11039: CALL_OW 88
// say ( Bur , D17-Bur-2 ) ;
11043: LD_EXP 50
11047: PPUSH
11048: LD_STRING D17-Bur-2
11050: PPUSH
11051: CALL_OW 88
// say ( Plat , D17-Pla-2 ) ;
11055: LD_EXP 54
11059: PPUSH
11060: LD_STRING D17-Pla-2
11062: PPUSH
11063: CALL_OW 88
// playing := false ;
11067: LD_ADDR_EXP 34
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
// end ;
11075: LD_VAR 0 1
11079: RET
// export function play_dialog_qwbw2 ; begin
11080: LD_INT 0
11082: PPUSH
// while playing do
11083: LD_EXP 34
11087: IFFALSE 11098
// wait ( 0 0$1 ) ;
11089: LD_INT 35
11091: PPUSH
11092: CALL_OW 67
11096: GO 11083
// playing := true ;
11098: LD_ADDR_EXP 34
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// say ( Bur , D18-Bur-1 ) ;
11106: LD_EXP 50
11110: PPUSH
11111: LD_STRING D18-Bur-1
11113: PPUSH
11114: CALL_OW 88
// say ( Plat , D18-Pla-1 ) ;
11118: LD_EXP 54
11122: PPUSH
11123: LD_STRING D18-Pla-1
11125: PPUSH
11126: CALL_OW 88
// say ( Bur , D18-Bur-2 ) ;
11130: LD_EXP 50
11134: PPUSH
11135: LD_STRING D18-Bur-2
11137: PPUSH
11138: CALL_OW 88
// say ( Plat , D18-Pla-2 ) ;
11142: LD_EXP 54
11146: PPUSH
11147: LD_STRING D18-Pla-2
11149: PPUSH
11150: CALL_OW 88
// playing := false ;
11154: LD_ADDR_EXP 34
11158: PUSH
11159: LD_INT 0
11161: ST_TO_ADDR
// end ;
11162: LD_VAR 0 1
11166: RET
// export function play_dialog_19 ; begin
11167: LD_INT 0
11169: PPUSH
// while playing do
11170: LD_EXP 34
11174: IFFALSE 11185
// wait ( 0 0$1 ) ;
11176: LD_INT 35
11178: PPUSH
11179: CALL_OW 67
11183: GO 11170
// playing := true ;
11185: LD_ADDR_EXP 34
11189: PUSH
11190: LD_INT 1
11192: ST_TO_ADDR
// if IsOK ( Gny ) then
11193: LD_EXP 49
11197: PPUSH
11198: CALL_OW 302
11202: IFFALSE 11230
// begin say ( Gny , D19-Gny-1 ) ;
11204: LD_EXP 49
11208: PPUSH
11209: LD_STRING D19-Gny-1
11211: PPUSH
11212: CALL_OW 88
// say ( Bur , D19-Bur-1 ) ;
11216: LD_EXP 50
11220: PPUSH
11221: LD_STRING D19-Bur-1
11223: PPUSH
11224: CALL_OW 88
// end else
11228: GO 11265
// if IsOK ( Kov ) then
11230: LD_EXP 51
11234: PPUSH
11235: CALL_OW 302
11239: IFFALSE 11265
// begin say ( Kov , D19-Kov-1 ) ;
11241: LD_EXP 51
11245: PPUSH
11246: LD_STRING D19-Kov-1
11248: PPUSH
11249: CALL_OW 88
// say ( Bur , D19-Bur-2 ) ;
11253: LD_EXP 50
11257: PPUSH
11258: LD_STRING D19-Bur-2
11260: PPUSH
11261: CALL_OW 88
// end ; playing := false ;
11265: LD_ADDR_EXP 34
11269: PUSH
11270: LD_INT 0
11272: ST_TO_ADDR
// end ;
11273: LD_VAR 0 1
11277: RET
// export function play_dialog_19a ; begin
11278: LD_INT 0
11280: PPUSH
// while playing do
11281: LD_EXP 34
11285: IFFALSE 11296
// wait ( 0 0$1 ) ;
11287: LD_INT 35
11289: PPUSH
11290: CALL_OW 67
11294: GO 11281
// playing := true ;
11296: LD_ADDR_EXP 34
11300: PUSH
11301: LD_INT 1
11303: ST_TO_ADDR
// if IsOK ( Gny ) then
11304: LD_EXP 49
11308: PPUSH
11309: CALL_OW 302
11313: IFFALSE 11329
// say ( Gny , D19A-Gny-1 ) else
11315: LD_EXP 49
11319: PPUSH
11320: LD_STRING D19A-Gny-1
11322: PPUSH
11323: CALL_OW 88
11327: GO 11352
// if IsOK ( Kov ) then
11329: LD_EXP 51
11333: PPUSH
11334: CALL_OW 302
11338: IFFALSE 11352
// say ( Kov , D19A-Kov-1 ) ;
11340: LD_EXP 51
11344: PPUSH
11345: LD_STRING D19A-Kov-1
11347: PPUSH
11348: CALL_OW 88
// playing := false ;
11352: LD_ADDR_EXP 34
11356: PUSH
11357: LD_INT 0
11359: ST_TO_ADDR
// end ;
11360: LD_VAR 0 1
11364: RET
// export function play_dialog_16 ; begin
11365: LD_INT 0
11367: PPUSH
// while playing do
11368: LD_EXP 34
11372: IFFALSE 11383
// wait ( 0 0$1 ) ;
11374: LD_INT 35
11376: PPUSH
11377: CALL_OW 67
11381: GO 11368
// playing := true ;
11383: LD_ADDR_EXP 34
11387: PUSH
11388: LD_INT 1
11390: ST_TO_ADDR
// CenterOnXY ( 90 , 57 ) ;
11391: LD_INT 90
11393: PPUSH
11394: LD_INT 57
11396: PPUSH
11397: CALL_OW 84
// DialogueOn ;
11401: CALL_OW 6
// if IsOK ( Kov ) then
11405: LD_EXP 51
11409: PPUSH
11410: CALL_OW 302
11414: IFFALSE 11449
// if not WBWSpotted then
11416: LD_EXP 18
11420: NOT
11421: IFFALSE 11437
// say ( Kov , D16-Kov-1 ) else
11423: LD_EXP 51
11427: PPUSH
11428: LD_STRING D16-Kov-1
11430: PPUSH
11431: CALL_OW 88
11435: GO 11449
// say ( Kov , D16-Kov-1a ) ;
11437: LD_EXP 51
11441: PPUSH
11442: LD_STRING D16-Kov-1a
11444: PPUSH
11445: CALL_OW 88
// say ( Bur , D16-Bur-1 ) ;
11449: LD_EXP 50
11453: PPUSH
11454: LD_STRING D16-Bur-1
11456: PPUSH
11457: CALL_OW 88
// if IsOK ( Gny ) then
11461: LD_EXP 49
11465: PPUSH
11466: CALL_OW 302
11470: IFFALSE 11484
// say ( Gny , D16-Gny-1 ) ;
11472: LD_EXP 49
11476: PPUSH
11477: LD_STRING D16-Gny-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// CenterOnUnits ( BurlakComp ) ;
11488: LD_EXP 14
11492: PPUSH
11493: CALL_OW 85
// playing := false ;
11497: LD_ADDR_EXP 34
11501: PUSH
11502: LD_INT 0
11504: ST_TO_ADDR
// end ;
11505: LD_VAR 0 1
11509: RET
// export function play_dialog_20 ; begin
11510: LD_INT 0
11512: PPUSH
// while playing do
11513: LD_EXP 34
11517: IFFALSE 11528
// wait ( 0 0$1 ) ;
11519: LD_INT 35
11521: PPUSH
11522: CALL_OW 67
11526: GO 11513
// playing := true ;
11528: LD_ADDR_EXP 34
11532: PUSH
11533: LD_INT 1
11535: ST_TO_ADDR
// say ( Bur , D20-Bur-1 ) ;
11536: LD_EXP 50
11540: PPUSH
11541: LD_STRING D20-Bur-1
11543: PPUSH
11544: CALL_OW 88
// say ( Plat , D20-Pla-1 ) ;
11548: LD_EXP 54
11552: PPUSH
11553: LD_STRING D20-Pla-1
11555: PPUSH
11556: CALL_OW 88
// playing := false ;
11560: LD_ADDR_EXP 34
11564: PUSH
11565: LD_INT 0
11567: ST_TO_ADDR
// end ;
11568: LD_VAR 0 1
11572: RET
// export function play_dialog_20a ; begin
11573: LD_INT 0
11575: PPUSH
// while playing do
11576: LD_EXP 34
11580: IFFALSE 11591
// wait ( 0 0$1 ) ;
11582: LD_INT 35
11584: PPUSH
11585: CALL_OW 67
11589: GO 11576
// playing := true ;
11591: LD_ADDR_EXP 34
11595: PUSH
11596: LD_INT 1
11598: ST_TO_ADDR
// say ( Bur , D20a-Bur-1 ) ;
11599: LD_EXP 50
11603: PPUSH
11604: LD_STRING D20a-Bur-1
11606: PPUSH
11607: CALL_OW 88
// say ( Plat , D20a-Pla-1 ) ;
11611: LD_EXP 54
11615: PPUSH
11616: LD_STRING D20a-Pla-1
11618: PPUSH
11619: CALL_OW 88
// playing := false ;
11623: LD_ADDR_EXP 34
11627: PUSH
11628: LD_INT 0
11630: ST_TO_ADDR
// end ;
11631: LD_VAR 0 1
11635: RET
// export function play_dialog_qAtAm1 ; begin
11636: LD_INT 0
11638: PPUSH
// while playing do
11639: LD_EXP 34
11643: IFFALSE 11654
// wait ( 0 0$1 ) ;
11645: LD_INT 35
11647: PPUSH
11648: CALL_OW 67
11652: GO 11639
// playing := true ;
11654: LD_ADDR_EXP 34
11658: PUSH
11659: LD_INT 1
11661: ST_TO_ADDR
// say ( Bur , D21-Bur-1 ) ;
11662: LD_EXP 50
11666: PPUSH
11667: LD_STRING D21-Bur-1
11669: PPUSH
11670: CALL_OW 88
// say ( Plat , D21-Pla-1 ) ;
11674: LD_EXP 54
11678: PPUSH
11679: LD_STRING D21-Pla-1
11681: PPUSH
11682: CALL_OW 88
// playing := false ;
11686: LD_ADDR_EXP 34
11690: PUSH
11691: LD_INT 0
11693: ST_TO_ADDR
// end ;
11694: LD_VAR 0 1
11698: RET
// export function play_dialog_qAtAm2 ; begin
11699: LD_INT 0
11701: PPUSH
// while playing do
11702: LD_EXP 34
11706: IFFALSE 11717
// wait ( 0 0$1 ) ;
11708: LD_INT 35
11710: PPUSH
11711: CALL_OW 67
11715: GO 11702
// playing := true ;
11717: LD_ADDR_EXP 34
11721: PUSH
11722: LD_INT 1
11724: ST_TO_ADDR
// say ( Bur , D22-Bur-1 ) ;
11725: LD_EXP 50
11729: PPUSH
11730: LD_STRING D22-Bur-1
11732: PPUSH
11733: CALL_OW 88
// if ( not Reinforcements ) and ( WBWDestroyed ) then
11737: LD_EXP 30
11741: NOT
11742: PUSH
11743: LD_EXP 20
11747: AND
11748: IFFALSE 11764
// say ( Plat , D22-Pla-1 ) else
11750: LD_EXP 54
11754: PPUSH
11755: LD_STRING D22-Pla-1
11757: PPUSH
11758: CALL_OW 88
11762: GO 11802
// if ( Reinforcements ) and ( WBWDestroyed ) then
11764: LD_EXP 30
11768: PUSH
11769: LD_EXP 20
11773: AND
11774: IFFALSE 11790
// say ( Plat , D22-Pla-1b ) else
11776: LD_EXP 54
11780: PPUSH
11781: LD_STRING D22-Pla-1b
11783: PPUSH
11784: CALL_OW 88
11788: GO 11802
// say ( Plat , D22-Pla-1a ) ;
11790: LD_EXP 54
11794: PPUSH
11795: LD_STRING D22-Pla-1a
11797: PPUSH
11798: CALL_OW 88
// playing := false ;
11802: LD_ADDR_EXP 34
11806: PUSH
11807: LD_INT 0
11809: ST_TO_ADDR
// end ;
11810: LD_VAR 0 1
11814: RET
// export function play_dialog_23 ; begin
11815: LD_INT 0
11817: PPUSH
// while playing do
11818: LD_EXP 34
11822: IFFALSE 11833
// wait ( 0 0$1 ) ;
11824: LD_INT 35
11826: PPUSH
11827: CALL_OW 67
11831: GO 11818
// playing := true ;
11833: LD_ADDR_EXP 34
11837: PUSH
11838: LD_INT 1
11840: ST_TO_ADDR
// if IsOK ( Gny ) then
11841: LD_EXP 49
11845: PPUSH
11846: CALL_OW 302
11850: IFFALSE 11876
// begin say ( Gny , D23-Gny-1 ) ;
11852: LD_EXP 49
11856: PPUSH
11857: LD_STRING D23-Gny-1
11859: PPUSH
11860: CALL_OW 88
// say ( Bur , D23-Bur-1 ) ;
11864: LD_EXP 50
11868: PPUSH
11869: LD_STRING D23-Bur-1
11871: PPUSH
11872: CALL_OW 88
// end ; playing := false ;
11876: LD_ADDR_EXP 34
11880: PUSH
11881: LD_INT 0
11883: ST_TO_ADDR
// end ;
11884: LD_VAR 0 1
11888: RET
// export function play_dialog_24 ; begin
11889: LD_INT 0
11891: PPUSH
// while playing do
11892: LD_EXP 34
11896: IFFALSE 11907
// wait ( 0 0$1 ) ;
11898: LD_INT 35
11900: PPUSH
11901: CALL_OW 67
11905: GO 11892
// playing := true ;
11907: LD_ADDR_EXP 34
11911: PUSH
11912: LD_INT 1
11914: ST_TO_ADDR
// if not IsOK ( Bel ) then
11915: LD_EXP 52
11919: PPUSH
11920: CALL_OW 302
11924: NOT
11925: IFFALSE 11938
// begin Msg ( Bel is killed. Please report this bug. Mission will now be terminated. ) ;
11927: LD_STRING Bel is killed. Please report this bug. Mission will now be terminated.
11929: PPUSH
11930: CALL_OW 100
// konec_mise ;
11934: CALL 249 0 0
// end ; say ( Bel , D24-Bel-1 ) ;
11938: LD_EXP 52
11942: PPUSH
11943: LD_STRING D24-Bel-1
11945: PPUSH
11946: CALL_OW 88
// if BELKOV_MRTVY then
11950: LD_EXP 46
11954: IFFALSE 11970
// say ( Bur , D24-Bur-1a ) else
11956: LD_EXP 50
11960: PPUSH
11961: LD_STRING D24-Bur-1a
11963: PPUSH
11964: CALL_OW 88
11968: GO 11982
// say ( Bur , D24-Bur-1 ) ;
11970: LD_EXP 50
11974: PPUSH
11975: LD_STRING D24-Bur-1
11977: PPUSH
11978: CALL_OW 88
// say ( Bel , D24-Bel-2 ) ;
11982: LD_EXP 52
11986: PPUSH
11987: LD_STRING D24-Bel-2
11989: PPUSH
11990: CALL_OW 88
// say ( Bur , D24-Bur-2 ) ;
11994: LD_EXP 50
11998: PPUSH
11999: LD_STRING D24-Bur-2
12001: PPUSH
12002: CALL_OW 88
// if ( GetSide ( auto_belkov ) = you ) then
12006: LD_EXP 70
12010: PPUSH
12011: CALL_OW 255
12015: PUSH
12016: LD_EXP 1
12020: EQUAL
12021: IFFALSE 12035
// begin say ( Bur , D24-Bur-2a ) ;
12023: LD_EXP 50
12027: PPUSH
12028: LD_STRING D24-Bur-2a
12030: PPUSH
12031: CALL_OW 88
// end ; say ( Plat , D24-Pla-2 ) ;
12035: LD_EXP 54
12039: PPUSH
12040: LD_STRING D24-Pla-2
12042: PPUSH
12043: CALL_OW 88
// if WBWSpotted and ( not WBWDestroyed ) then
12047: LD_EXP 18
12051: PUSH
12052: LD_EXP 20
12056: NOT
12057: AND
12058: IFFALSE 12072
// begin say ( Plat , D24-Pla-2a ) ;
12060: LD_EXP 54
12064: PPUSH
12065: LD_STRING D24-Pla-2a
12067: PPUSH
12068: CALL_OW 88
// end ; playing := false ;
12072: LD_ADDR_EXP 34
12076: PUSH
12077: LD_INT 0
12079: ST_TO_ADDR
// end ;
12080: LD_VAR 0 1
12084: RET
// export function play_dialog_25 ; var SomethingNew ; begin
12085: LD_INT 0
12087: PPUSH
12088: PPUSH
// while playing do
12089: LD_EXP 34
12093: IFFALSE 12104
// wait ( 0 0$1 ) ;
12095: LD_INT 35
12097: PPUSH
12098: CALL_OW 67
12102: GO 12089
// playing := true ;
12104: LD_ADDR_EXP 34
12108: PUSH
12109: LD_INT 1
12111: ST_TO_ADDR
// say ( Plat , D25-Pla-1 ) ;
12112: LD_EXP 54
12116: PPUSH
12117: LD_STRING D25-Pla-1
12119: PPUSH
12120: CALL_OW 88
// SomethingNew := false ;
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_INT 0
12131: ST_TO_ADDR
// if ( WBWSpotted ) and ( not WBWDestroyed ) and ( not WBWReported ) and ( EBWSpotted ) and ( not EBWDestroyed ) and ( not EBWReported ) then
12132: LD_EXP 18
12136: PUSH
12137: LD_EXP 20
12141: NOT
12142: AND
12143: PUSH
12144: LD_EXP 21
12148: NOT
12149: AND
12150: PUSH
12151: LD_EXP 22
12155: AND
12156: PUSH
12157: LD_EXP 23
12161: NOT
12162: AND
12163: PUSH
12164: LD_EXP 24
12168: NOT
12169: AND
12170: IFFALSE 12208
// begin say ( Bur , D25-Bur-1 ) ;
12172: LD_EXP 50
12176: PPUSH
12177: LD_STRING D25-Bur-1
12179: PPUSH
12180: CALL_OW 88
// WBWReported := true ;
12184: LD_ADDR_EXP 21
12188: PUSH
12189: LD_INT 1
12191: ST_TO_ADDR
// EBWReported := true ;
12192: LD_ADDR_EXP 24
12196: PUSH
12197: LD_INT 1
12199: ST_TO_ADDR
// SomethingNew := true ;
12200: LD_ADDR_VAR 0 2
12204: PUSH
12205: LD_INT 1
12207: ST_TO_ADDR
// end ; if EBWSpotted and ( not EBWDestroyed ) and ( not EBWReported ) then
12208: LD_EXP 22
12212: PUSH
12213: LD_EXP 23
12217: NOT
12218: AND
12219: PUSH
12220: LD_EXP 24
12224: NOT
12225: AND
12226: IFFALSE 12256
// begin say ( Bur , D25-Bur-1a ) ;
12228: LD_EXP 50
12232: PPUSH
12233: LD_STRING D25-Bur-1a
12235: PPUSH
12236: CALL_OW 88
// EBWReported := true ;
12240: LD_ADDR_EXP 24
12244: PUSH
12245: LD_INT 1
12247: ST_TO_ADDR
// SomethingNew := true ;
12248: LD_ADDR_VAR 0 2
12252: PUSH
12253: LD_INT 1
12255: ST_TO_ADDR
// end ; if WBWSpotted and ( not WBWDestroyed ) and ( not WBWReported ) then
12256: LD_EXP 18
12260: PUSH
12261: LD_EXP 20
12265: NOT
12266: AND
12267: PUSH
12268: LD_EXP 21
12272: NOT
12273: AND
12274: IFFALSE 12316
// begin say ( Bur , D25-Bur-1b ) ;
12276: LD_EXP 50
12280: PPUSH
12281: LD_STRING D25-Bur-1b
12283: PPUSH
12284: CALL_OW 88
// say ( Bur , D25b-Bur-1 ) ;
12288: LD_EXP 50
12292: PPUSH
12293: LD_STRING D25b-Bur-1
12295: PPUSH
12296: CALL_OW 88
// WBWReported := true ;
12300: LD_ADDR_EXP 21
12304: PUSH
12305: LD_INT 1
12307: ST_TO_ADDR
// SomethingNew := true ;
12308: LD_ADDR_VAR 0 2
12312: PUSH
12313: LD_INT 1
12315: ST_TO_ADDR
// end ; if ( not SomethingNew ) then
12316: LD_VAR 0 2
12320: NOT
12321: IFFALSE 12335
// say ( Bur , D25-Bur-1c ) ;
12323: LD_EXP 50
12327: PPUSH
12328: LD_STRING D25-Bur-1c
12330: PPUSH
12331: CALL_OW 88
// playing := false ;
12335: LD_ADDR_EXP 34
12339: PUSH
12340: LD_INT 0
12342: ST_TO_ADDR
// end ;
12343: LD_VAR 0 1
12347: RET
// export function play_dialog_25a ; var SomethingNew ; begin
12348: LD_INT 0
12350: PPUSH
12351: PPUSH
// while playing do
12352: LD_EXP 34
12356: IFFALSE 12367
// wait ( 0 0$1 ) ;
12358: LD_INT 35
12360: PPUSH
12361: CALL_OW 67
12365: GO 12352
// playing := true ;
12367: LD_ADDR_EXP 34
12371: PUSH
12372: LD_INT 1
12374: ST_TO_ADDR
// say ( Plat , D25a-Pla-1 ) ;
12375: LD_EXP 54
12379: PPUSH
12380: LD_STRING D25a-Pla-1
12382: PPUSH
12383: CALL_OW 88
// SomethingNew := false ;
12387: LD_ADDR_VAR 0 2
12391: PUSH
12392: LD_INT 0
12394: ST_TO_ADDR
// if WBWSpotted and ( not WBWDestroyed ) and ( not WBWReported ) then
12395: LD_EXP 18
12399: PUSH
12400: LD_EXP 20
12404: NOT
12405: AND
12406: PUSH
12407: LD_EXP 21
12411: NOT
12412: AND
12413: IFFALSE 12455
// begin say ( Bur , D25a-Bur-1b ) ;
12415: LD_EXP 50
12419: PPUSH
12420: LD_STRING D25a-Bur-1b
12422: PPUSH
12423: CALL_OW 88
// say ( Bur , D25b-Bur-1 ) ;
12427: LD_EXP 50
12431: PPUSH
12432: LD_STRING D25b-Bur-1
12434: PPUSH
12435: CALL_OW 88
// WBWReported := true ;
12439: LD_ADDR_EXP 21
12443: PUSH
12444: LD_INT 1
12446: ST_TO_ADDR
// SomethingNew := true ;
12447: LD_ADDR_VAR 0 2
12451: PUSH
12452: LD_INT 1
12454: ST_TO_ADDR
// end ; if EBWSpotted and ( not EBWDestroyed ) and ( not EBWReported ) then
12455: LD_EXP 22
12459: PUSH
12460: LD_EXP 23
12464: NOT
12465: AND
12466: PUSH
12467: LD_EXP 24
12471: NOT
12472: AND
12473: IFFALSE 12503
// begin say ( Bur , D25a-Bur-1a ) ;
12475: LD_EXP 50
12479: PPUSH
12480: LD_STRING D25a-Bur-1a
12482: PPUSH
12483: CALL_OW 88
// EBWReported := true ;
12487: LD_ADDR_EXP 24
12491: PUSH
12492: LD_INT 1
12494: ST_TO_ADDR
// SomethingNew := true ;
12495: LD_ADDR_VAR 0 2
12499: PUSH
12500: LD_INT 1
12502: ST_TO_ADDR
// end ; if ( not SomethingNew ) then
12503: LD_VAR 0 2
12507: NOT
12508: IFFALSE 12522
// say ( Bur , D25a-Bur-1 ) ;
12510: LD_EXP 50
12514: PPUSH
12515: LD_STRING D25a-Bur-1
12517: PPUSH
12518: CALL_OW 88
// playing := false ;
12522: LD_ADDR_EXP 34
12526: PUSH
12527: LD_INT 0
12529: ST_TO_ADDR
// end ;
12530: LD_VAR 0 1
12534: RET
// export function play_dialog_25b ; begin
12535: LD_INT 0
12537: PPUSH
// while playing do
12538: LD_EXP 34
12542: IFFALSE 12553
// wait ( 0 0$1 ) ;
12544: LD_INT 35
12546: PPUSH
12547: CALL_OW 67
12551: GO 12538
// playing := true ;
12553: LD_ADDR_EXP 34
12557: PUSH
12558: LD_INT 1
12560: ST_TO_ADDR
// say ( Plat , D25b-Pla-1 ) ;
12561: LD_EXP 54
12565: PPUSH
12566: LD_STRING D25b-Pla-1
12568: PPUSH
12569: CALL_OW 88
// playing := false ;
12573: LD_ADDR_EXP 34
12577: PUSH
12578: LD_INT 0
12580: ST_TO_ADDR
// end ;
12581: LD_VAR 0 1
12585: RET
// export function play_dialog_25c ; begin
12586: LD_INT 0
12588: PPUSH
// while playing do
12589: LD_EXP 34
12593: IFFALSE 12604
// wait ( 0 0$1 ) ;
12595: LD_INT 35
12597: PPUSH
12598: CALL_OW 67
12602: GO 12589
// playing := true ;
12604: LD_ADDR_EXP 34
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// if ( not WBWSpotted ) then
12612: LD_EXP 18
12616: NOT
12617: IFFALSE 12633
// say ( Plat , D25c-Pla-1 ) else
12619: LD_EXP 54
12623: PPUSH
12624: LD_STRING D25c-Pla-1
12626: PPUSH
12627: CALL_OW 88
12631: GO 12645
// say ( Plat , D25c-Pla-1a ) ;
12633: LD_EXP 54
12637: PPUSH
12638: LD_STRING D25c-Pla-1a
12640: PPUSH
12641: CALL_OW 88
// playing := false ;
12645: LD_ADDR_EXP 34
12649: PUSH
12650: LD_INT 0
12652: ST_TO_ADDR
// end ;
12653: LD_VAR 0 1
12657: RET
// every 0 0$5 do
12658: GO 12660
12660: DISABLE
// begin if Playing then
12661: LD_EXP 34
12665: IFFALSE 12683
// PlayingLooped := PlayingLooped + 1 else
12667: LD_ADDR_LOC 17
12671: PUSH
12672: LD_LOC 17
12676: PUSH
12677: LD_INT 1
12679: PLUS
12680: ST_TO_ADDR
12681: GO 12691
// PlayingLooped := 0 ;
12683: LD_ADDR_LOC 17
12687: PUSH
12688: LD_INT 0
12690: ST_TO_ADDR
// if PlayingLooped >= 30 then
12691: LD_LOC 17
12695: PUSH
12696: LD_INT 30
12698: GREATEREQUAL
12699: IFFALSE 12716
// begin msg ( Playing too long. Possible bug. Please report. ) ;
12701: LD_STRING Playing too long. Possible bug. Please report.
12703: PPUSH
12704: CALL_OW 100
// Playing := false ;
12708: LD_ADDR_EXP 34
12712: PUSH
12713: LD_INT 0
12715: ST_TO_ADDR
// end ; enable end ; end_of_file
12716: ENABLE
12717: END
// export Gny ; export bur ; export Kov ; export bel ; export kurin ; export plat ; export Rusi_enter ; export Rusi_sever ; export Rusi_01 ; export rusi_survivors ; export stav_utoku ; export stav ; export venku ; export videli_w ; export videli_e ; export bedny ; export bedny_hint ; export videne ; export zasilek ; export posily_go ; export saved_bel ; export auto_belkov ; var pocet_uukazani ; var BurSk ; var BelSk ; var GnySk ; every 0 0$0.1 do var i ;
12718: GO 12720
12720: DISABLE
12721: LD_INT 0
12723: PPUSH
// begin zasilek = 0 ;
12724: LD_ADDR_EXP 67
12728: PUSH
12729: LD_INT 0
12731: ST_TO_ADDR
// bedny_hint = false ;
12732: LD_ADDR_EXP 65
12736: PUSH
12737: LD_INT 0
12739: ST_TO_ADDR
// stav = 0 ;
12740: LD_ADDR_EXP 60
12744: PUSH
12745: LD_INT 0
12747: ST_TO_ADDR
// Rusi_enter = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] ] ) ;
12748: LD_ADDR_EXP 55
12752: PUSH
12753: LD_INT 3
12755: PPUSH
12756: LD_INT 22
12758: PUSH
12759: LD_EXP 1
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: EMPTY
12769: LIST
12770: PPUSH
12771: CALL_OW 70
12775: ST_TO_ADDR
// BurlakComp = Rusi_enter ;
12776: LD_ADDR_EXP 14
12780: PUSH
12781: LD_EXP 55
12785: ST_TO_ADDR
// venku = false ;
12786: LD_ADDR_EXP 61
12790: PUSH
12791: LD_INT 0
12793: ST_TO_ADDR
// stav_utoku = 0 ;
12794: LD_ADDR_EXP 59
12798: PUSH
12799: LD_INT 0
12801: ST_TO_ADDR
// videli_w = false ;
12802: LD_ADDR_EXP 62
12806: PUSH
12807: LD_INT 0
12809: ST_TO_ADDR
// videli_e = false ;
12810: LD_ADDR_EXP 63
12814: PUSH
12815: LD_INT 0
12817: ST_TO_ADDR
// bedny = [ ] ;
12818: LD_ADDR_EXP 64
12822: PUSH
12823: EMPTY
12824: ST_TO_ADDR
// videne = [ ] ;
12825: LD_ADDR_EXP 66
12829: PUSH
12830: EMPTY
12831: ST_TO_ADDR
// Rusi_sever = [ bel ] ;
12832: LD_ADDR_EXP 56
12836: PUSH
12837: LD_EXP 52
12841: PUSH
12842: EMPTY
12843: LIST
12844: ST_TO_ADDR
// Rusi_01 = [ ] ;
12845: LD_ADDR_EXP 57
12849: PUSH
12850: EMPTY
12851: ST_TO_ADDR
// posily_go = false ;
12852: LD_ADDR_EXP 68
12856: PUSH
12857: LD_INT 0
12859: ST_TO_ADDR
// saved_bel = false ;
12860: LD_ADDR_EXP 69
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// pocet_uukazani = 0 ;
12868: LD_ADDR_LOC 18
12872: PUSH
12873: LD_INT 0
12875: ST_TO_ADDR
// for i in [ 501 , 502 , 503 , 599 ] do
12876: LD_ADDR_VAR 0 1
12880: PUSH
12881: LD_INT 501
12883: PUSH
12884: LD_INT 502
12886: PUSH
12887: LD_INT 503
12889: PUSH
12890: LD_INT 599
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: PUSH
12899: FOR_IN
12900: IFFALSE 12909
// disable ( i ) ;
12902: LD_VAR 0 1
12906: DISABLE_MARKED
12907: GO 12899
12909: POP
12910: POP
// nastaveni_zacatku_skillu ;
12911: CALL 12918 0 0
// end ;
12915: PPOPN 1
12917: END
// function nastaveni_zacatku_skillu ; begin
12918: LD_INT 0
12920: PPUSH
// if IsOK ( bur ) then
12921: LD_EXP 50
12925: PPUSH
12926: CALL_OW 302
12930: IFFALSE 12995
// BurSk := [ GetSkill ( bur , 1 ) , GetSkill ( bur , 2 ) , GetSkill ( bur , 3 ) , GetSkill ( bur , 4 ) ] ;
12932: LD_ADDR_LOC 19
12936: PUSH
12937: LD_EXP 50
12941: PPUSH
12942: LD_INT 1
12944: PPUSH
12945: CALL_OW 259
12949: PUSH
12950: LD_EXP 50
12954: PPUSH
12955: LD_INT 2
12957: PPUSH
12958: CALL_OW 259
12962: PUSH
12963: LD_EXP 50
12967: PPUSH
12968: LD_INT 3
12970: PPUSH
12971: CALL_OW 259
12975: PUSH
12976: LD_EXP 50
12980: PPUSH
12981: LD_INT 4
12983: PPUSH
12984: CALL_OW 259
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// if IsOK ( Gny ) then
12995: LD_EXP 49
12999: PPUSH
13000: CALL_OW 302
13004: IFFALSE 13069
// GnySk := [ GetSkill ( Gny , 1 ) , GetSkill ( Gny , 2 ) , GetSkill ( Gny , 3 ) , GetSkill ( Gny , 4 ) ] ;
13006: LD_ADDR_LOC 21
13010: PUSH
13011: LD_EXP 49
13015: PPUSH
13016: LD_INT 1
13018: PPUSH
13019: CALL_OW 259
13023: PUSH
13024: LD_EXP 49
13028: PPUSH
13029: LD_INT 2
13031: PPUSH
13032: CALL_OW 259
13036: PUSH
13037: LD_EXP 49
13041: PPUSH
13042: LD_INT 3
13044: PPUSH
13045: CALL_OW 259
13049: PUSH
13050: LD_EXP 49
13054: PPUSH
13055: LD_INT 4
13057: PPUSH
13058: CALL_OW 259
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: LIST
13067: LIST
13068: ST_TO_ADDR
// if IsOK ( bel ) then
13069: LD_EXP 52
13073: PPUSH
13074: CALL_OW 302
13078: IFFALSE 13143
// BelSk := [ GetSkill ( bel , 1 ) , GetSkill ( bel , 2 ) , GetSkill ( bel , 3 ) , GetSkill ( bel , 4 ) ] ;
13080: LD_ADDR_LOC 20
13084: PUSH
13085: LD_EXP 52
13089: PPUSH
13090: LD_INT 1
13092: PPUSH
13093: CALL_OW 259
13097: PUSH
13098: LD_EXP 52
13102: PPUSH
13103: LD_INT 2
13105: PPUSH
13106: CALL_OW 259
13110: PUSH
13111: LD_EXP 52
13115: PPUSH
13116: LD_INT 3
13118: PPUSH
13119: CALL_OW 259
13123: PUSH
13124: LD_EXP 52
13128: PPUSH
13129: LD_INT 4
13131: PPUSH
13132: CALL_OW 259
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: ST_TO_ADDR
// end ;
13143: LD_VAR 0 1
13147: RET
// export function uklid_rusu ; begin
13148: LD_INT 0
13150: PPUSH
// ComEnterUnit ( RU1_vb1 , RU1_bu1 ) ;
13151: LD_INT 12
13153: PPUSH
13154: LD_INT 6
13156: PPUSH
13157: CALL_OW 120
// ComEnterUnit ( RU1_vb2 , RU1_bu2 ) ;
13161: LD_INT 13
13163: PPUSH
13164: LD_INT 14
13166: PPUSH
13167: CALL_OW 120
// ComEnterUnit ( bel , RU1_bar ) ;
13171: LD_EXP 52
13175: PPUSH
13176: LD_INT 5
13178: PPUSH
13179: CALL_OW 120
// ComEnterUnit ( RU1_sol1 , RU1_bar ) ;
13183: LD_INT 28
13185: PPUSH
13186: LD_INT 5
13188: PPUSH
13189: CALL_OW 120
// ComEnterUnit ( RU1_sol2 , RU1_bar ) ;
13193: LD_INT 29
13195: PPUSH
13196: LD_INT 5
13198: PPUSH
13199: CALL_OW 120
// ComEnterUnit ( RU1_vo1 , RU1_bar ) ;
13203: LD_INT 20
13205: PPUSH
13206: LD_INT 5
13208: PPUSH
13209: CALL_OW 120
// ComEnterUnit ( RU1_sci1 , RU1_lab ) ;
13213: LD_INT 27
13215: PPUSH
13216: LD_INT 3
13218: PPUSH
13219: CALL_OW 120
// ComEnterUnit ( RU1_sci2 , RU1_lab ) ;
13223: LD_INT 19
13225: PPUSH
13226: LD_INT 3
13228: PPUSH
13229: CALL_OW 120
// ComEnterUnit ( RU1_eng1 , RU1_dep ) ;
13233: LD_INT 18
13235: PPUSH
13236: LD_INT 1
13238: PPUSH
13239: CALL_OW 120
// ComEnterUnit ( RU1_me1 , RU1_tov ) ;
13243: LD_INT 17
13245: PPUSH
13246: LD_INT 2
13248: PPUSH
13249: CALL_OW 120
// ComMoveXY ( plat , 67 , 90 ) ;
13253: LD_EXP 54
13257: PPUSH
13258: LD_INT 67
13260: PPUSH
13261: LD_INT 90
13263: PPUSH
13264: CALL_OW 111
// AddComHold ( plat ) ;
13268: LD_EXP 54
13272: PPUSH
13273: CALL_OW 200
// ComEnterUnit ( Ru2_vb1 , Ru2_bu1 ) ;
13277: LD_INT 9
13279: PPUSH
13280: LD_INT 4
13282: PPUSH
13283: CALL_OW 120
// ComEnterUnit ( Ru2_vb2 , Ru2_bu2 ) ;
13287: LD_INT 10
13289: PPUSH
13290: LD_INT 11
13292: PPUSH
13293: CALL_OW 120
// end ;
13297: LD_VAR 0 1
13301: RET
// every 0 0$30 trigger stav > 2 and stav < 7 do var pom ;
13302: LD_EXP 60
13306: PUSH
13307: LD_INT 2
13309: GREATER
13310: PUSH
13311: LD_EXP 60
13315: PUSH
13316: LD_INT 7
13318: LESS
13319: AND
13320: IFFALSE 13381
13322: GO 13324
13324: DISABLE
13325: LD_INT 0
13327: PPUSH
// begin ComFree ( plat ) ;
13328: LD_EXP 54
13332: PPUSH
13333: CALL_OW 139
// pom = RandHexArea ( RU2_base , true ) ;
13337: LD_ADDR_VAR 0 1
13341: PUSH
13342: LD_INT 1
13344: PPUSH
13345: LD_INT 1
13347: PPUSH
13348: CALL_OW 16
13352: ST_TO_ADDR
// AddComMoveXY ( plat , pom [ 1 ] , pom [ 2 ] ) ;
13353: LD_EXP 54
13357: PPUSH
13358: LD_VAR 0 1
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PPUSH
13367: LD_VAR 0 1
13371: PUSH
13372: LD_INT 2
13374: ARRAY
13375: PPUSH
13376: CALL_OW 171
// enable ;
13380: ENABLE
// end ;
13381: PPOPN 1
13383: END
// every 0 0$1 trigger not venku and not test_is_in_area_burlak do
13384: LD_EXP 61
13388: NOT
13389: PUSH
13390: CALL 13411 0 0
13394: NOT
13395: AND
13396: IFFALSE 13410
13398: GO 13400
13400: DISABLE
// begin venku = true ;
13401: LD_ADDR_EXP 61
13405: PUSH
13406: LD_INT 1
13408: ST_TO_ADDR
// enable ;
13409: ENABLE
// end ;
13410: END
// export function test_is_in_area_burlak ; var a ; var pom , i ; begin
13411: LD_INT 0
13413: PPUSH
13414: PPUSH
13415: PPUSH
13416: PPUSH
// a = false ;
13417: LD_ADDR_VAR 0 2
13421: PUSH
13422: LD_INT 0
13424: ST_TO_ADDR
// if IsInArea ( bur , RU1_base ) then
13425: LD_EXP 50
13429: PPUSH
13430: LD_INT 3
13432: PPUSH
13433: CALL_OW 308
13437: IFFALSE 13447
// a = true ;
13439: LD_ADDR_VAR 0 2
13443: PUSH
13444: LD_INT 1
13446: ST_TO_ADDR
// pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
13447: LD_ADDR_VAR 0 3
13451: PUSH
13452: LD_INT 3
13454: PPUSH
13455: LD_INT 22
13457: PUSH
13458: LD_EXP 1
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: PUSH
13467: LD_INT 21
13469: PUSH
13470: LD_INT 2
13472: PUSH
13473: EMPTY
13474: LIST
13475: LIST
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: PPUSH
13481: CALL_OW 70
13485: ST_TO_ADDR
// if pom > 0 then
13486: LD_VAR 0 3
13490: PUSH
13491: LD_INT 0
13493: GREATER
13494: IFFALSE 13538
// for i in pom do
13496: LD_ADDR_VAR 0 4
13500: PUSH
13501: LD_VAR 0 3
13505: PUSH
13506: FOR_IN
13507: IFFALSE 13536
// if IsDrivenBy ( i ) = bur then
13509: LD_VAR 0 4
13513: PPUSH
13514: CALL_OW 311
13518: PUSH
13519: LD_EXP 50
13523: EQUAL
13524: IFFALSE 13534
// a = true ;
13526: LD_ADDR_VAR 0 2
13530: PUSH
13531: LD_INT 1
13533: ST_TO_ADDR
13534: GO 13506
13536: POP
13537: POP
// result = a ;
13538: LD_ADDR_VAR 0 1
13542: PUSH
13543: LD_VAR 0 2
13547: ST_TO_ADDR
// end ;
13548: LD_VAR 0 1
13552: RET
// every 0 0$7 do var pom ;
13553: GO 13555
13555: DISABLE
13556: LD_INT 0
13558: PPUSH
// begin pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_breastwork ] , [ f_nation , nation_russian ] ] ) ;
13559: LD_ADDR_VAR 0 1
13563: PUSH
13564: LD_INT 22
13566: PUSH
13567: LD_EXP 1
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 30
13578: PUSH
13579: LD_INT 31
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: LD_INT 23
13588: PUSH
13589: LD_INT 3
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: LIST
13600: PPUSH
13601: CALL_OW 69
13605: ST_TO_ADDR
// if pom > 0 then
13606: LD_VAR 0 1
13610: PUSH
13611: LD_INT 0
13613: GREATER
13614: IFFALSE 13628
// destroy ( pom , b_breastwork ) ;
13616: LD_VAR 0 1
13620: PPUSH
13621: LD_INT 31
13623: PPUSH
13624: CALL 13770 0 2
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_armoury ] , [ f_nation , nation_russian ] ] ) ;
13628: LD_ADDR_VAR 0 1
13632: PUSH
13633: LD_INT 22
13635: PUSH
13636: LD_EXP 1
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 30
13647: PUSH
13648: LD_INT 4
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PUSH
13655: LD_INT 23
13657: PUSH
13658: LD_INT 3
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: PPUSH
13670: CALL_OW 69
13674: ST_TO_ADDR
// if pom > 0 then
13675: LD_VAR 0 1
13679: PUSH
13680: LD_INT 0
13682: GREATER
13683: IFFALSE 13697
// destroy ( pom , b_armoury ) ;
13685: LD_VAR 0 1
13689: PPUSH
13690: LD_INT 4
13692: PPUSH
13693: CALL 13770 0 2
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_oil_power ] , [ f_nation , nation_russian ] ] ) ;
13697: LD_ADDR_VAR 0 1
13701: PUSH
13702: LD_INT 22
13704: PUSH
13705: LD_EXP 1
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: PUSH
13714: LD_INT 30
13716: PUSH
13717: LD_INT 26
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: PUSH
13724: LD_INT 23
13726: PUSH
13727: LD_INT 3
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: LIST
13738: PPUSH
13739: CALL_OW 69
13743: ST_TO_ADDR
// if pom > 0 then
13744: LD_VAR 0 1
13748: PUSH
13749: LD_INT 0
13751: GREATER
13752: IFFALSE 13766
// destroy ( pom , b_oil_power ) ;
13754: LD_VAR 0 1
13758: PPUSH
13759: LD_INT 26
13761: PPUSH
13762: CALL 13770 0 2
// enable ;
13766: ENABLE
// end ;
13767: PPOPN 1
13769: END
// function destroy ( sez , typ ) ; var i , j ; var pom ; var res ; begin
13770: LD_INT 0
13772: PPUSH
13773: PPUSH
13774: PPUSH
13775: PPUSH
13776: PPUSH
// InGameOn ;
13777: CALL_OW 8
// dialog_boreni ;
13781: CALL 8321 0 0
// for i in sez do
13785: LD_ADDR_VAR 0 4
13789: PUSH
13790: LD_VAR 0 1
13794: PUSH
13795: FOR_IN
13796: IFFALSE 13980
// begin pom = UnitsInside ( i ) ;
13798: LD_ADDR_VAR 0 6
13802: PUSH
13803: LD_VAR 0 4
13807: PPUSH
13808: CALL_OW 313
13812: ST_TO_ADDR
// ComExitBuilding ( pom ) ;
13813: LD_VAR 0 6
13817: PPUSH
13818: CALL_OW 122
// wait ( 0 0$2 ) ;
13822: LD_INT 70
13824: PPUSH
13825: CALL_OW 67
// DestroyUnit ( i ) ;
13829: LD_VAR 0 4
13833: PPUSH
13834: CALL_OW 65
// case typ of b_breastwork :
13838: LD_VAR 0 2
13842: PUSH
13843: LD_INT 31
13845: DOUBLE
13846: EQUAL
13847: IFTRUE 13851
13849: GO 13872
13851: POP
// res = [ [ mat_cans , 10 ] ] ; b_armoury :
13852: LD_ADDR_VAR 0 7
13856: PUSH
13857: LD_INT 1
13859: PUSH
13860: LD_INT 10
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PUSH
13867: EMPTY
13868: LIST
13869: ST_TO_ADDR
13870: GO 13931
13872: LD_INT 4
13874: DOUBLE
13875: EQUAL
13876: IFTRUE 13880
13878: GO 13901
13880: POP
// res = [ [ mat_cans , 30 ] ] ; b_oil_power :
13881: LD_ADDR_VAR 0 7
13885: PUSH
13886: LD_INT 1
13888: PUSH
13889: LD_INT 30
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: EMPTY
13897: LIST
13898: ST_TO_ADDR
13899: GO 13931
13901: LD_INT 26
13903: DOUBLE
13904: EQUAL
13905: IFTRUE 13909
13907: GO 13930
13909: POP
// res = [ [ mat_cans , 20 ] ] ; end ;
13910: LD_ADDR_VAR 0 7
13914: PUSH
13915: LD_INT 1
13917: PUSH
13918: LD_INT 20
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: PUSH
13925: EMPTY
13926: LIST
13927: ST_TO_ADDR
13928: GO 13931
13930: POP
// for j in res do
13931: LD_ADDR_VAR 0 5
13935: PUSH
13936: LD_VAR 0 7
13940: PUSH
13941: FOR_IN
13942: IFFALSE 13976
// AddResourceType ( GetBase ( RU2_dep ) , j [ 1 ] , j [ 2 ] ) ;
13944: LD_INT 26
13946: PPUSH
13947: CALL_OW 274
13951: PPUSH
13952: LD_VAR 0 5
13956: PUSH
13957: LD_INT 1
13959: ARRAY
13960: PPUSH
13961: LD_VAR 0 5
13965: PUSH
13966: LD_INT 2
13968: ARRAY
13969: PPUSH
13970: CALL_OW 276
13974: GO 13941
13976: POP
13977: POP
// end ;
13978: GO 13795
13980: POP
13981: POP
// InGameOff ;
13982: CALL_OW 9
// end ;
13986: LD_VAR 0 3
13990: RET
// on McDone ( ID , state ) do var u , w , dist , tol , Arrived ;
13991: LD_INT 0
13993: PPUSH
13994: PPUSH
13995: PPUSH
13996: PPUSH
13997: PPUSH
// begin tol := 8 ;
13998: LD_ADDR_VAR 0 6
14002: PUSH
14003: LD_INT 8
14005: ST_TO_ADDR
// if ID <> McCestaNaSever then
14006: LD_VAR 0 1
14010: PUSH
14011: LD_EXP 36
14015: NONEQUAL
14016: IFFALSE 14020
// exit ;
14018: GO 14193
// repeat Arrived := true ;
14020: LD_ADDR_VAR 0 7
14024: PUSH
14025: LD_INT 1
14027: ST_TO_ADDR
// for u in Rusi_sever do
14028: LD_ADDR_VAR 0 3
14032: PUSH
14033: LD_EXP 56
14037: PUSH
14038: FOR_IN
14039: IFFALSE 14178
// if GetDistUnitXY ( u , wptCestaNaSever [ wptCestaNaSever ] [ 1 ] , wptCestaNaSever [ wptCestaNaSever ] [ 2 ] ) > tol then
14041: LD_VAR 0 3
14045: PPUSH
14046: LD_EXP 71
14050: PUSH
14051: LD_EXP 71
14055: ARRAY
14056: PUSH
14057: LD_INT 1
14059: ARRAY
14060: PPUSH
14061: LD_EXP 71
14065: PUSH
14066: LD_EXP 71
14070: ARRAY
14071: PUSH
14072: LD_INT 2
14074: ARRAY
14075: PPUSH
14076: CALL_OW 297
14080: PUSH
14081: LD_VAR 0 6
14085: GREATER
14086: IFFALSE 14176
// begin Arrived := false ;
14088: LD_ADDR_VAR 0 7
14092: PUSH
14093: LD_INT 0
14095: ST_TO_ADDR
// ComStop ( u ) ;
14096: LD_VAR 0 3
14100: PPUSH
14101: CALL_OW 141
// for w in wptCestaNaSever do
14105: LD_ADDR_VAR 0 4
14109: PUSH
14110: LD_EXP 71
14114: PUSH
14115: FOR_IN
14116: IFFALSE 14174
// begin if GetY ( u ) > w [ 2 ] + tol then
14118: LD_VAR 0 3
14122: PPUSH
14123: CALL_OW 251
14127: PUSH
14128: LD_VAR 0 4
14132: PUSH
14133: LD_INT 2
14135: ARRAY
14136: PUSH
14137: LD_VAR 0 6
14141: PLUS
14142: GREATER
14143: IFFALSE 14172
// begin AddComMoveXY ( u , w [ 1 ] , w [ 2 ] ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: LD_VAR 0 4
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: LD_VAR 0 4
14163: PUSH
14164: LD_INT 2
14166: ARRAY
14167: PPUSH
14168: CALL_OW 171
// end ; end ;
14172: GO 14115
14174: POP
14175: POP
// end ;
14176: GO 14038
14178: POP
14179: POP
// wait ( 0 0$15 ) until Arrived ;
14180: LD_INT 525
14182: PPUSH
14183: CALL_OW 67
14187: LD_VAR 0 7
14191: IFFALSE 14020
// end ;
14193: PPOPN 7
14195: END
// export wptCestaNaSever ; export function rusi_cesta_na_sever ; var pom ; begin
14196: LD_INT 0
14198: PPUSH
14199: PPUSH
// if rusi_survivors < 3 then
14200: LD_EXP 58
14204: PUSH
14205: LD_INT 3
14207: LESS
14208: IFFALSE 14235
// rusi_survivors = rusi_survivors ^ [ RU1_sol1 , RU1_sol2 , RU1_sci1 ] ;
14210: LD_ADDR_EXP 58
14214: PUSH
14215: LD_EXP 58
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 27
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: LIST
14233: ADD
14234: ST_TO_ADDR
// Rusi_01 = rusi_survivors ;
14235: LD_ADDR_EXP 57
14239: PUSH
14240: LD_EXP 58
14244: ST_TO_ADDR
// pom = [ IsInUnit ( bel ) , Rusi_01 [ 1 ] , Rusi_01 [ 2 ] , Rusi_01 [ 3 ] ] ;
14245: LD_ADDR_VAR 0 2
14249: PUSH
14250: LD_EXP 52
14254: PPUSH
14255: CALL_OW 310
14259: PUSH
14260: LD_EXP 57
14264: PUSH
14265: LD_INT 1
14267: ARRAY
14268: PUSH
14269: LD_EXP 57
14273: PUSH
14274: LD_INT 2
14276: ARRAY
14277: PUSH
14278: LD_EXP 57
14282: PUSH
14283: LD_INT 3
14285: ARRAY
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: ST_TO_ADDR
// ComExitBuilding ( [ Rusi_01 [ 1 ] , Rusi_01 [ 2 ] , Rusi_01 [ 3 ] ] ) ;
14293: LD_EXP 57
14297: PUSH
14298: LD_INT 1
14300: ARRAY
14301: PUSH
14302: LD_EXP 57
14306: PUSH
14307: LD_INT 2
14309: ARRAY
14310: PUSH
14311: LD_EXP 57
14315: PUSH
14316: LD_INT 3
14318: ARRAY
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: LIST
14324: PPUSH
14325: CALL_OW 122
// wptCestaNaSever := [ [ 87 , 93 ] , [ 77 , 74 ] , [ 68 , 58 ] , [ 66 , 46 ] , [ 59 , 28 ] , [ 59 , 12 ] ] ;
14329: LD_ADDR_EXP 71
14333: PUSH
14334: LD_INT 87
14336: PUSH
14337: LD_INT 93
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: LD_INT 77
14346: PUSH
14347: LD_INT 74
14349: PUSH
14350: EMPTY
14351: LIST
14352: LIST
14353: PUSH
14354: LD_INT 68
14356: PUSH
14357: LD_INT 58
14359: PUSH
14360: EMPTY
14361: LIST
14362: LIST
14363: PUSH
14364: LD_INT 66
14366: PUSH
14367: LD_INT 46
14369: PUSH
14370: EMPTY
14371: LIST
14372: LIST
14373: PUSH
14374: LD_INT 59
14376: PUSH
14377: LD_INT 28
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 59
14386: PUSH
14387: LD_INT 12
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: ST_TO_ADDR
// mcCestaNaSever = McMove ( 1 , pom , wptCestaNaSever , [ mc_move_waitwp ] ) ;
14402: LD_ADDR_EXP 36
14406: PUSH
14407: LD_INT 1
14409: PPUSH
14410: LD_VAR 0 2
14414: PPUSH
14415: LD_EXP 71
14419: PPUSH
14420: LD_INT 3
14422: PUSH
14423: EMPTY
14424: LIST
14425: PPUSH
14426: CALL_OW 398
14430: ST_TO_ADDR
// Rusi_sever = pom ;
14431: LD_ADDR_EXP 56
14435: PUSH
14436: LD_VAR 0 2
14440: ST_TO_ADDR
// rusi_survivors = Rusi_01 diff pom ;
14441: LD_ADDR_EXP 58
14445: PUSH
14446: LD_EXP 57
14450: PUSH
14451: LD_VAR 0 2
14455: DIFF
14456: ST_TO_ADDR
// repeat wait ( 0 0$5 ) until ( FilterUnitsInArea ( RU1_base , [ ] ) isect Rusi_sever ) = 0 ;
14457: LD_INT 175
14459: PPUSH
14460: CALL_OW 67
14464: LD_INT 3
14466: PPUSH
14467: EMPTY
14468: PPUSH
14469: CALL_OW 70
14473: PUSH
14474: LD_EXP 56
14478: ISECT
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: IFFALSE 14457
// wait ( 1 1$0 ) ;
14485: LD_INT 2100
14487: PPUSH
14488: CALL_OW 67
// stavba_am_baze ;
14492: CALL 16937 0 0
// end ;
14496: LD_VAR 0 1
14500: RET
// every 0 0$4 do var pom ;
14501: GO 14503
14503: DISABLE
14504: LD_INT 0
14506: PPUSH
// begin pom = FilterUnitsInArea ( Test2 , [ [ f_side , You2 ] ] ) ;
14507: LD_ADDR_VAR 0 1
14511: PUSH
14512: LD_INT 10
14514: PPUSH
14515: LD_INT 22
14517: PUSH
14518: LD_EXP 4
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: EMPTY
14528: LIST
14529: PPUSH
14530: CALL_OW 70
14534: ST_TO_ADDR
// if pom + 0 = Rusi_sever + 0 then
14535: LD_VAR 0 1
14539: PUSH
14540: LD_INT 0
14542: PLUS
14543: PUSH
14544: LD_EXP 56
14548: PUSH
14549: LD_INT 0
14551: PLUS
14552: EQUAL
14553: IFFALSE 14562
// begin manage_rusi_sever ;
14555: CALL 15568 0 0
// disable ;
14559: DISABLE
// end else
14560: GO 14563
// enable ;
14562: ENABLE
// end ;
14563: PPOPN 1
14565: END
// every 0 0$20 trigger stav > 2 and stav < 7 do var i ; var misto ;
14566: LD_EXP 60
14570: PUSH
14571: LD_INT 2
14573: GREATER
14574: PUSH
14575: LD_EXP 60
14579: PUSH
14580: LD_INT 7
14582: LESS
14583: AND
14584: IFFALSE 14872
14586: GO 14588
14588: DISABLE
14589: LD_INT 0
14591: PPUSH
14592: PPUSH
// begin misto = [ ] ;
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: EMPTY
14599: ST_TO_ADDR
// for i in bedny do
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_EXP 64
14609: PUSH
14610: FOR_IN
14611: IFFALSE 14697
// if SeeXY ( You2 , i [ 1 ] , i [ 2 ] ) then
14613: LD_EXP 4
14617: PPUSH
14618: LD_VAR 0 1
14622: PUSH
14623: LD_INT 1
14625: ARRAY
14626: PPUSH
14627: LD_VAR 0 1
14631: PUSH
14632: LD_INT 2
14634: ARRAY
14635: PPUSH
14636: CALL_OW 293
14640: IFFALSE 14695
// if i in videne then
14642: LD_VAR 0 1
14646: PUSH
14647: LD_EXP 66
14651: IN
14652: IFFALSE 14666
// misto = misto else
14654: LD_ADDR_VAR 0 2
14658: PUSH
14659: LD_VAR 0 2
14663: ST_TO_ADDR
14664: GO 14695
// begin misto = i ;
14666: LD_ADDR_VAR 0 2
14670: PUSH
14671: LD_VAR 0 1
14675: ST_TO_ADDR
// videne = videne ^ [ i ] ;
14676: LD_ADDR_EXP 66
14680: PUSH
14681: LD_EXP 66
14685: PUSH
14686: LD_VAR 0 1
14690: PUSH
14691: EMPTY
14692: LIST
14693: ADD
14694: ST_TO_ADDR
// end ;
14695: GO 14610
14697: POP
14698: POP
// if misto <> 0 then
14699: LD_VAR 0 2
14703: PUSH
14704: LD_INT 0
14706: NONEQUAL
14707: IFFALSE 14844
// begin bedny_hint = true ;
14709: LD_ADDR_EXP 65
14713: PUSH
14714: LD_INT 1
14716: ST_TO_ADDR
// ComMoveXY ( plat , misto [ 1 ] , misto [ 2 ] ) ;
14717: LD_EXP 54
14721: PPUSH
14722: LD_VAR 0 2
14726: PUSH
14727: LD_INT 1
14729: ARRAY
14730: PPUSH
14731: LD_VAR 0 2
14735: PUSH
14736: LD_INT 2
14738: ARRAY
14739: PPUSH
14740: CALL_OW 111
// wait ( 0 0$5 ) ;
14744: LD_INT 175
14746: PPUSH
14747: CALL_OW 67
// if HexInfo ( misto [ 1 ] , misto [ 2 ] ) <> 0 or HexInfo ( misto [ 1 ] , misto [ 2 ] ) <> plat then
14751: LD_VAR 0 2
14755: PUSH
14756: LD_INT 1
14758: ARRAY
14759: PPUSH
14760: LD_VAR 0 2
14764: PUSH
14765: LD_INT 2
14767: ARRAY
14768: PPUSH
14769: CALL_OW 428
14773: PUSH
14774: LD_INT 0
14776: NONEQUAL
14777: PUSH
14778: LD_VAR 0 2
14782: PUSH
14783: LD_INT 1
14785: ARRAY
14786: PPUSH
14787: LD_VAR 0 2
14791: PUSH
14792: LD_INT 2
14794: ARRAY
14795: PPUSH
14796: CALL_OW 428
14800: PUSH
14801: LD_EXP 54
14805: NONEQUAL
14806: OR
14807: IFFALSE 14844
// begin hlaska_platonov_bedny ;
14809: CALL 9538 0 0
// pocet_uukazani = pocet_uukazani + 1 ;
14813: LD_ADDR_LOC 18
14817: PUSH
14818: LD_LOC 18
14822: PUSH
14823: LD_INT 1
14825: PLUS
14826: ST_TO_ADDR
// debug_strings = [ Platonov bvedny , pocet_uukazani ] ;
14827: LD_ADDR_OWVAR 48
14831: PUSH
14832: LD_STRING Platonov bvedny
14834: PUSH
14835: LD_LOC 18
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: ST_TO_ADDR
// end ; end ; debug_strings = [ Platonov bvedny , pocet_uukazani ] ;
14844: LD_ADDR_OWVAR 48
14848: PUSH
14849: LD_STRING Platonov bvedny
14851: PUSH
14852: LD_LOC 18
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: ST_TO_ADDR
// if pocet_uukazani < 6 then
14861: LD_LOC 18
14865: PUSH
14866: LD_INT 6
14868: LESS
14869: IFFALSE 14872
// enable ;
14871: ENABLE
// end ;
14872: PPOPN 2
14874: END
// every 0 0$13 trigger stav > 2 and stav < 7 do var i ; var a ;
14875: LD_EXP 60
14879: PUSH
14880: LD_INT 2
14882: GREATER
14883: PUSH
14884: LD_EXP 60
14888: PUSH
14889: LD_INT 7
14891: LESS
14892: AND
14893: IFFALSE 14984
14895: GO 14897
14897: DISABLE
14898: LD_INT 0
14900: PPUSH
14901: PPUSH
// begin a = [ ] ;
14902: LD_ADDR_VAR 0 2
14906: PUSH
14907: EMPTY
14908: ST_TO_ADDR
// for i in bedny do
14909: LD_ADDR_VAR 0 1
14913: PUSH
14914: LD_EXP 64
14918: PUSH
14919: FOR_IN
14920: IFFALSE 14971
// if GetResourceAmountXY ( i [ 1 ] , i [ 2 ] ) <> 0 then
14922: LD_VAR 0 1
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: PPUSH
14931: LD_VAR 0 1
14935: PUSH
14936: LD_INT 2
14938: ARRAY
14939: PPUSH
14940: CALL_OW 284
14944: PUSH
14945: LD_INT 0
14947: NONEQUAL
14948: IFFALSE 14969
// a = a ^ [ i ] ;
14950: LD_ADDR_VAR 0 2
14954: PUSH
14955: LD_VAR 0 2
14959: PUSH
14960: LD_VAR 0 1
14964: PUSH
14965: EMPTY
14966: LIST
14967: ADD
14968: ST_TO_ADDR
14969: GO 14919
14971: POP
14972: POP
// bedny = a ;
14973: LD_ADDR_EXP 64
14977: PUSH
14978: LD_VAR 0 2
14982: ST_TO_ADDR
// enable ;
14983: ENABLE
// end ;
14984: PPOPN 2
14986: END
// every 0 0$10 trigger stav = 3 do var hex ;
14987: LD_EXP 60
14991: PUSH
14992: LD_INT 3
14994: EQUAL
14995: IFFALSE 15127
14997: GO 14999
14999: DISABLE
15000: LD_INT 0
15002: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$0 ) ) ;
15003: LD_INT 1050
15005: PPUSH
15006: LD_INT 2100
15008: PPUSH
15009: CALL_OW 12
15013: PPUSH
15014: CALL_OW 67
// hex = RandHexArea ( bedny_ar , true ) ;
15018: LD_ADDR_VAR 0 1
15022: PUSH
15023: LD_INT 28
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 16
15033: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15034: LD_VAR 0 1
15038: PUSH
15039: LD_INT 1
15041: ARRAY
15042: PPUSH
15043: LD_VAR 0 1
15047: PUSH
15048: LD_INT 2
15050: ARRAY
15051: PPUSH
15052: CALL_OW 428
15056: PUSH
15057: LD_INT 0
15059: NONEQUAL
15060: IFFALSE 15080
// hex = RandHexArea ( bedny_ar , true ) ;
15062: LD_ADDR_VAR 0 1
15066: PUSH
15067: LD_INT 28
15069: PPUSH
15070: LD_INT 1
15072: PPUSH
15073: CALL_OW 16
15077: ST_TO_ADDR
15078: GO 15034
// CreateCratesXY ( 4 , hex [ 1 ] , hex [ 2 ] , true ) ;
15080: LD_INT 4
15082: PPUSH
15083: LD_VAR 0 1
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: PPUSH
15092: LD_VAR 0 1
15096: PUSH
15097: LD_INT 2
15099: ARRAY
15100: PPUSH
15101: LD_INT 1
15103: PPUSH
15104: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15108: LD_ADDR_EXP 64
15112: PUSH
15113: LD_EXP 64
15117: PUSH
15118: LD_VAR 0 1
15122: PUSH
15123: EMPTY
15124: LIST
15125: ADD
15126: ST_TO_ADDR
// end ;
15127: PPOPN 1
15129: END
// every 0 0$10 trigger stav >= 6 and stav < 7 do var hex ;
15130: LD_EXP 60
15134: PUSH
15135: LD_INT 6
15137: GREATEREQUAL
15138: PUSH
15139: LD_EXP 60
15143: PUSH
15144: LD_INT 7
15146: LESS
15147: AND
15148: IFFALSE 15303
15150: GO 15152
15152: DISABLE
15153: LD_INT 0
15155: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
15156: LD_INT 1050
15158: PPUSH
15159: LD_INT 3150
15161: PPUSH
15162: CALL_OW 12
15166: PPUSH
15167: CALL_OW 67
// hex = RandHexArea ( bedny_ar , true ) ;
15171: LD_ADDR_VAR 0 1
15175: PUSH
15176: LD_INT 28
15178: PPUSH
15179: LD_INT 1
15181: PPUSH
15182: CALL_OW 16
15186: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15187: LD_VAR 0 1
15191: PUSH
15192: LD_INT 1
15194: ARRAY
15195: PPUSH
15196: LD_VAR 0 1
15200: PUSH
15201: LD_INT 2
15203: ARRAY
15204: PPUSH
15205: CALL_OW 428
15209: PUSH
15210: LD_INT 0
15212: NONEQUAL
15213: IFFALSE 15233
// hex = RandHexArea ( bedny_ar , true ) ;
15215: LD_ADDR_VAR 0 1
15219: PUSH
15220: LD_INT 28
15222: PPUSH
15223: LD_INT 1
15225: PPUSH
15226: CALL_OW 16
15230: ST_TO_ADDR
15231: GO 15187
// CreateCratesXY ( Rand ( 3 , 5 ) , hex [ 1 ] , hex [ 2 ] , true ) ;
15233: LD_INT 3
15235: PPUSH
15236: LD_INT 5
15238: PPUSH
15239: CALL_OW 12
15243: PPUSH
15244: LD_VAR 0 1
15248: PUSH
15249: LD_INT 1
15251: ARRAY
15252: PPUSH
15253: LD_VAR 0 1
15257: PUSH
15258: LD_INT 2
15260: ARRAY
15261: PPUSH
15262: LD_INT 1
15264: PPUSH
15265: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15269: LD_ADDR_EXP 64
15273: PUSH
15274: LD_EXP 64
15278: PUSH
15279: LD_VAR 0 1
15283: PUSH
15284: EMPTY
15285: LIST
15286: ADD
15287: ST_TO_ADDR
// zasilek = zasilek + 1 ;
15288: LD_ADDR_EXP 67
15292: PUSH
15293: LD_EXP 67
15297: PUSH
15298: LD_INT 1
15300: PLUS
15301: ST_TO_ADDR
// enable ;
15302: ENABLE
// end ;
15303: PPOPN 1
15305: END
// every 0 0$10 trigger stav >= 5 and stav < 7 marked 503 do var hex ;
15306: LD_EXP 60
15310: PUSH
15311: LD_INT 5
15313: GREATEREQUAL
15314: PUSH
15315: LD_EXP 60
15319: PUSH
15320: LD_INT 7
15322: LESS
15323: AND
15324: IFFALSE 15489
15326: GO 15328
15328: DISABLE
15329: LD_INT 0
15331: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
15332: LD_INT 1050
15334: PPUSH
15335: LD_INT 3150
15337: PPUSH
15338: CALL_OW 12
15342: PPUSH
15343: CALL_OW 67
// hex = RandHexArea ( RU2_base , true ) ;
15347: LD_ADDR_VAR 0 1
15351: PUSH
15352: LD_INT 1
15354: PPUSH
15355: LD_INT 1
15357: PPUSH
15358: CALL_OW 16
15362: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15363: LD_VAR 0 1
15367: PUSH
15368: LD_INT 1
15370: ARRAY
15371: PPUSH
15372: LD_VAR 0 1
15376: PUSH
15377: LD_INT 2
15379: ARRAY
15380: PPUSH
15381: CALL_OW 428
15385: PUSH
15386: LD_INT 0
15388: NONEQUAL
15389: IFFALSE 15409
// hex = RandHexArea ( RU2_base , true ) ;
15391: LD_ADDR_VAR 0 1
15395: PUSH
15396: LD_INT 1
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 16
15406: ST_TO_ADDR
15407: GO 15363
// CreateCratesXY ( Rand ( 3 , 5 ) , hex [ 1 ] , hex [ 2 ] , true ) ;
15409: LD_INT 3
15411: PPUSH
15412: LD_INT 5
15414: PPUSH
15415: CALL_OW 12
15419: PPUSH
15420: LD_VAR 0 1
15424: PUSH
15425: LD_INT 1
15427: ARRAY
15428: PPUSH
15429: LD_VAR 0 1
15433: PUSH
15434: LD_INT 2
15436: ARRAY
15437: PPUSH
15438: LD_INT 1
15440: PPUSH
15441: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15445: LD_ADDR_EXP 64
15449: PUSH
15450: LD_EXP 64
15454: PUSH
15455: LD_VAR 0 1
15459: PUSH
15460: EMPTY
15461: LIST
15462: ADD
15463: ST_TO_ADDR
// zasilek = zasilek + 1 ;
15464: LD_ADDR_EXP 67
15468: PUSH
15469: LD_EXP 67
15473: PUSH
15474: LD_INT 1
15476: PLUS
15477: ST_TO_ADDR
// if zasilek < 4 then
15478: LD_EXP 67
15482: PUSH
15483: LD_INT 4
15485: LESS
15486: IFFALSE 15489
// enable ;
15488: ENABLE
// end ;
15489: PPOPN 1
15491: END
// export function test_is_auto_in_area ; var pom ; begin
15492: LD_INT 0
15494: PPUSH
15495: PPUSH
// pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
15496: LD_ADDR_VAR 0 2
15500: PUSH
15501: LD_INT 3
15503: PPUSH
15504: LD_INT 22
15506: PUSH
15507: LD_EXP 1
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 21
15518: PUSH
15519: LD_INT 2
15521: PUSH
15522: EMPTY
15523: LIST
15524: LIST
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PPUSH
15530: CALL_OW 70
15534: ST_TO_ADDR
// if pom > 0 then
15535: LD_VAR 0 2
15539: PUSH
15540: LD_INT 0
15542: GREATER
15543: IFFALSE 15555
// result = true else
15545: LD_ADDR_VAR 0 1
15549: PUSH
15550: LD_INT 1
15552: ST_TO_ADDR
15553: GO 15563
// result = false ;
15555: LD_ADDR_VAR 0 1
15559: PUSH
15560: LD_INT 0
15562: ST_TO_ADDR
// end ;
15563: LD_VAR 0 1
15567: RET
// function manage_rusi_sever ; begin
15568: LD_INT 0
15570: PPUSH
// wait ( 0 0$20 ) ;
15571: LD_INT 700
15573: PPUSH
15574: CALL_OW 67
// ComMoveXY ( Rusi_sever , 90 , 25 ) ;
15578: LD_EXP 56
15582: PPUSH
15583: LD_INT 90
15585: PPUSH
15586: LD_INT 25
15588: PPUSH
15589: CALL_OW 111
// end ;
15593: LD_VAR 0 1
15597: RET
// every 0 0$1 trigger FilterUnitsInArea ( Odber_bel , [ [ f_side , You2 ] ] ) > 0 do var pom , i ;
15598: LD_INT 14
15600: PPUSH
15601: LD_INT 22
15603: PUSH
15604: LD_EXP 4
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: PUSH
15613: EMPTY
15614: LIST
15615: PPUSH
15616: CALL_OW 70
15620: PUSH
15621: LD_INT 0
15623: GREATER
15624: IFFALSE 15734
15626: GO 15628
15628: DISABLE
15629: LD_INT 0
15631: PPUSH
15632: PPUSH
// begin pom = FilterUnitsInArea ( Odber_bel , [ [ f_side , You2 ] ] ) ;
15633: LD_ADDR_VAR 0 1
15637: PUSH
15638: LD_INT 14
15640: PPUSH
15641: LD_INT 22
15643: PUSH
15644: LD_EXP 4
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PUSH
15653: EMPTY
15654: LIST
15655: PPUSH
15656: CALL_OW 70
15660: ST_TO_ADDR
// for i in pom do
15661: LD_ADDR_VAR 0 2
15665: PUSH
15666: LD_VAR 0 1
15670: PUSH
15671: FOR_IN
15672: IFFALSE 15697
// if i in Rusi_sever then
15674: LD_VAR 0 2
15678: PUSH
15679: LD_EXP 56
15683: IN
15684: IFFALSE 15695
// RemoveUnit ( i ) ;
15686: LD_VAR 0 2
15690: PPUSH
15691: CALL_OW 64
15695: GO 15671
15697: POP
15698: POP
// pom = UnitFilter ( Rusi_sever , [ [ f_OK ] ] ) ;
15699: LD_ADDR_VAR 0 1
15703: PUSH
15704: LD_EXP 56
15708: PPUSH
15709: LD_INT 50
15711: PUSH
15712: EMPTY
15713: LIST
15714: PUSH
15715: EMPTY
15716: LIST
15717: PPUSH
15718: CALL_OW 72
15722: ST_TO_ADDR
// if pom > 0 then
15723: LD_VAR 0 1
15727: PUSH
15728: LD_INT 0
15730: GREATER
15731: IFFALSE 15734
// enable ;
15733: ENABLE
// end ;
15734: PPOPN 2
15736: END
// every 0 0$1 trigger belkov_returns do
15737: LD_EXP 8
15741: IFFALSE 15754
15743: GO 15745
15745: DISABLE
// begin placni_amiky_past ;
15746: CALL 16775 0 0
// placni_zpet_rusy_sever ;
15750: CALL 15755 0 0
// end ;
15754: END
// function placni_zpet_rusy_sever ; var i ; begin
15755: LD_INT 0
15757: PPUSH
15758: PPUSH
// for i in Rusi_sever do
15759: LD_ADDR_VAR 0 2
15763: PUSH
15764: LD_EXP 56
15768: PUSH
15769: FOR_IN
15770: IFFALSE 15789
// PlaceUnitArea ( i , Zpet_bel , false ) ;
15772: LD_VAR 0 2
15776: PPUSH
15777: LD_INT 15
15779: PPUSH
15780: LD_INT 0
15782: PPUSH
15783: CALL_OW 49
15787: GO 15769
15789: POP
15790: POP
// ComMoveXY ( Rusi_sever , 56 , 9 ) ;
15791: LD_EXP 56
15795: PPUSH
15796: LD_INT 56
15798: PPUSH
15799: LD_INT 9
15801: PPUSH
15802: CALL_OW 111
// AddComHold ( Rusi_sever ) ;
15806: LD_EXP 56
15810: PPUSH
15811: CALL_OW 200
// end ;
15815: LD_VAR 0 1
15819: RET
// export function posli_lidi_zpet ; var pom ; begin
15820: LD_INT 0
15822: PPUSH
15823: PPUSH
// pom = FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) ;
15824: LD_ADDR_VAR 0 2
15828: PUSH
15829: LD_INT 2
15831: PPUSH
15832: LD_INT 22
15834: PUSH
15835: LD_EXP 1
15839: PUSH
15840: EMPTY
15841: LIST
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: PPUSH
15847: CALL_OW 70
15851: ST_TO_ADDR
// ComMoveToArea ( pom , RU2_base ) ;
15852: LD_VAR 0 2
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: CALL_OW 113
// end ;
15864: LD_VAR 0 1
15868: RET
// export function posli_rusi_zpet_out_base ; var pom ; begin
15869: LD_INT 0
15871: PPUSH
15872: PPUSH
// pom = FilterUnitsInArea ( Out_base , [ [ f_side , You ] ] ) ;
15873: LD_ADDR_VAR 0 2
15877: PUSH
15878: LD_INT 6
15880: PPUSH
15881: LD_INT 22
15883: PUSH
15884: LD_EXP 1
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: PUSH
15893: EMPTY
15894: LIST
15895: PPUSH
15896: CALL_OW 70
15900: ST_TO_ADDR
// ComMoveToArea ( pom , RU2_base ) ;
15901: LD_VAR 0 2
15905: PPUSH
15906: LD_INT 1
15908: PPUSH
15909: CALL_OW 113
// end ;
15913: LD_VAR 0 1
15917: RET
// export function rusi_save_belkov ; begin
15918: LD_INT 0
15920: PPUSH
// enable ( 501 ) ;
15921: LD_INT 501
15923: ENABLE_MARKED
// enable ( 502 ) ;
15924: LD_INT 502
15926: ENABLE_MARKED
// enable ( 599 ) ;
15927: LD_INT 599
15929: ENABLE_MARKED
// end ;
15930: LD_VAR 0 1
15934: RET
// every 0 0$1 trigger GetLives ( bel ) < 800 marked 501 do
15935: LD_EXP 52
15939: PPUSH
15940: CALL_OW 256
15944: PUSH
15945: LD_INT 800
15947: LESS
15948: IFFALSE 15966
15950: GO 15952
15952: DISABLE
// begin SetLives ( bel , 800 ) ;
15953: LD_EXP 52
15957: PPUSH
15958: LD_INT 800
15960: PPUSH
15961: CALL_OW 234
// enable ;
15965: ENABLE
// end ;
15966: END
// every 0 0$1 trigger saved_bel do
15967: LD_EXP 69
15971: IFFALSE 15979
15973: GO 15975
15975: DISABLE
// begin disable ( 501 ) ;
15976: LD_INT 501
15978: DISABLE_MARKED
// end ;
15979: END
// every 0 0$1 trigger GetSide ( bel ) = You marked 599 do
15980: LD_EXP 52
15984: PPUSH
15985: CALL_OW 255
15989: PUSH
15990: LD_EXP 1
15994: EQUAL
15995: IFFALSE 16003
15997: GO 15999
15999: DISABLE
// begin disable ( 501 ) ;
16000: LD_INT 501
16002: DISABLE_MARKED
// end ;
16003: END
// every 0 0$1 marked 502 do var i ; var pom ;
16004: GO 16006
16006: DISABLE
16007: LD_INT 0
16009: PPUSH
16010: PPUSH
// begin pom = false ;
16011: LD_ADDR_VAR 0 2
16015: PUSH
16016: LD_INT 0
16018: ST_TO_ADDR
// wait ( cas_na_zachranu_belkova [ difficulty ] ) ;
16019: LD_EXP 43
16023: PUSH
16024: LD_OWVAR 67
16028: ARRAY
16029: PPUSH
16030: CALL_OW 67
// disable ( 501 ) ;
16034: LD_INT 501
16036: DISABLE_MARKED
// if IsOK ( bel ) and ( not saved_bel ) then
16037: LD_EXP 52
16041: PPUSH
16042: CALL_OW 302
16046: PUSH
16047: LD_EXP 69
16051: NOT
16052: AND
16053: IFFALSE 16059
// amici_attack_belkov ;
16055: CALL 18116 0 0
// while ( FilterUnitsInArea ( Belkov_kop , [ f_side , You2 ] ) + 0 > 0 ) and ( UnitFilter ( AMICI_UTOK_BELKOV_LIST , [ f_OK ] ) + 0 > 0 ) do
16059: LD_INT 25
16061: PPUSH
16062: LD_INT 22
16064: PUSH
16065: LD_EXP 4
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: PPUSH
16074: CALL_OW 70
16078: PUSH
16079: LD_INT 0
16081: PLUS
16082: PUSH
16083: LD_INT 0
16085: GREATER
16086: PUSH
16087: LD_EXP 39
16091: PPUSH
16092: LD_INT 50
16094: PUSH
16095: EMPTY
16096: LIST
16097: PPUSH
16098: CALL_OW 72
16102: PUSH
16103: LD_INT 0
16105: PLUS
16106: PUSH
16107: LD_INT 0
16109: GREATER
16110: AND
16111: IFFALSE 16171
// begin wait ( 0 0$1 ) ;
16113: LD_INT 35
16115: PPUSH
16116: CALL_OW 67
// if objBelkov and IsDead ( bel ) and GetSide ( bel ) = 6 then
16120: LD_EXP 28
16124: PUSH
16125: LD_EXP 52
16129: PPUSH
16130: CALL_OW 301
16134: AND
16135: PUSH
16136: LD_EXP 52
16140: PPUSH
16141: CALL_OW 255
16145: PUSH
16146: LD_INT 6
16148: EQUAL
16149: AND
16150: IFFALSE 16169
// begin belkovSave = false ;
16152: LD_ADDR_EXP 10
16156: PUSH
16157: LD_INT 0
16159: ST_TO_ADDR
// wait ( 1 ) ;
16160: LD_INT 1
16162: PPUSH
16163: CALL_OW 67
// exit ;
16167: GO 16175
// end ; end ;
16169: GO 16059
// amici_retreat ;
16171: CALL 18263 0 0
// end ;
16175: PPOPN 2
16177: END
// every 0 0$2 trigger saved_bel do
16178: LD_EXP 69
16182: IFFALSE 16190
16184: GO 16186
16186: DISABLE
// begin disable ( 502 ) ;
16187: LD_INT 502
16189: DISABLE_MARKED
// end ;
16190: END
// export function create_rusi_navic ; var pom , i ; begin
16191: LD_INT 0
16193: PPUSH
16194: PPUSH
16195: PPUSH
// if CheckCharacterSet ( survivors1 ) then
16196: LD_STRING survivors1
16198: PPUSH
16199: CALL_OW 29
16203: IFFALSE 16220
// pom = CreateCharacterSet ( survivors1 ) else
16205: LD_ADDR_VAR 0 2
16209: PUSH
16210: LD_STRING survivors1
16212: PPUSH
16213: CALL_OW 31
16217: ST_TO_ADDR
16218: GO 16227
// pom = [ ] ;
16220: LD_ADDR_VAR 0 2
16224: PUSH
16225: EMPTY
16226: ST_TO_ADDR
// for i in pom do
16227: LD_ADDR_VAR 0 3
16231: PUSH
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_IN
16238: IFFALSE 16277
// begin SetSide ( i , You2 ) ;
16240: LD_VAR 0 3
16244: PPUSH
16245: LD_EXP 4
16249: PPUSH
16250: CALL_OW 235
// PlaceUnitXYR ( i , 129 , 111 , 5 , false ) ;
16254: LD_VAR 0 3
16258: PPUSH
16259: LD_INT 129
16261: PPUSH
16262: LD_INT 111
16264: PPUSH
16265: LD_INT 5
16267: PPUSH
16268: LD_INT 0
16270: PPUSH
16271: CALL_OW 50
// end ;
16275: GO 16237
16277: POP
16278: POP
// if pom <> 0 then
16279: LD_VAR 0 2
16283: PUSH
16284: LD_INT 0
16286: NONEQUAL
16287: IFFALSE 16301
// ComEnterUnit ( pom , RU1_tov ) ;
16289: LD_VAR 0 2
16293: PPUSH
16294: LD_INT 2
16296: PPUSH
16297: CALL_OW 120
// rusi_survivors = pom ;
16301: LD_ADDR_EXP 58
16305: PUSH
16306: LD_VAR 0 2
16310: ST_TO_ADDR
// end ;
16311: LD_VAR 0 1
16315: RET
// every 0 0$5 do var zmena ;
16316: GO 16318
16318: DISABLE
16319: LD_INT 0
16321: PPUSH
// begin zmena = false ;
16322: LD_ADDR_VAR 0 1
16326: PUSH
16327: LD_INT 0
16329: ST_TO_ADDR
// if IsOk ( bur ) then
16330: LD_EXP 50
16334: PPUSH
16335: CALL_OW 302
16339: IFFALSE 16445
// if ( ( GetSkill ( bur , 1 ) <> BurSk [ 1 ] ) or ( GetSkill ( bur , 2 ) <> BurSk [ 2 ] ) or ( GetSkill ( bur , 3 ) <> BurSk [ 3 ] ) or ( GetSkill ( bur , 4 ) <> BurSk [ 4 ] ) ) then
16341: LD_EXP 50
16345: PPUSH
16346: LD_INT 1
16348: PPUSH
16349: CALL_OW 259
16353: PUSH
16354: LD_LOC 19
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: NONEQUAL
16363: PUSH
16364: LD_EXP 50
16368: PPUSH
16369: LD_INT 2
16371: PPUSH
16372: CALL_OW 259
16376: PUSH
16377: LD_LOC 19
16381: PUSH
16382: LD_INT 2
16384: ARRAY
16385: NONEQUAL
16386: OR
16387: PUSH
16388: LD_EXP 50
16392: PPUSH
16393: LD_INT 3
16395: PPUSH
16396: CALL_OW 259
16400: PUSH
16401: LD_LOC 19
16405: PUSH
16406: LD_INT 3
16408: ARRAY
16409: NONEQUAL
16410: OR
16411: PUSH
16412: LD_EXP 50
16416: PPUSH
16417: LD_INT 4
16419: PPUSH
16420: CALL_OW 259
16424: PUSH
16425: LD_LOC 19
16429: PUSH
16430: LD_INT 4
16432: ARRAY
16433: NONEQUAL
16434: OR
16435: IFFALSE 16445
// zmena = true ;
16437: LD_ADDR_VAR 0 1
16441: PUSH
16442: LD_INT 1
16444: ST_TO_ADDR
// if IsOk ( Gny ) then
16445: LD_EXP 49
16449: PPUSH
16450: CALL_OW 302
16454: IFFALSE 16560
// if ( ( GetSkill ( Gny , 1 ) <> GnySk [ 1 ] ) or ( GetSkill ( Gny , 2 ) <> GnySk [ 2 ] ) or ( GetSkill ( Gny , 3 ) <> GnySk [ 3 ] ) or ( GetSkill ( Gny , 4 ) <> GnySk [ 4 ] ) ) then
16456: LD_EXP 49
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL_OW 259
16468: PUSH
16469: LD_LOC 21
16473: PUSH
16474: LD_INT 1
16476: ARRAY
16477: NONEQUAL
16478: PUSH
16479: LD_EXP 49
16483: PPUSH
16484: LD_INT 2
16486: PPUSH
16487: CALL_OW 259
16491: PUSH
16492: LD_LOC 21
16496: PUSH
16497: LD_INT 2
16499: ARRAY
16500: NONEQUAL
16501: OR
16502: PUSH
16503: LD_EXP 49
16507: PPUSH
16508: LD_INT 3
16510: PPUSH
16511: CALL_OW 259
16515: PUSH
16516: LD_LOC 21
16520: PUSH
16521: LD_INT 3
16523: ARRAY
16524: NONEQUAL
16525: OR
16526: PUSH
16527: LD_EXP 49
16531: PPUSH
16532: LD_INT 4
16534: PPUSH
16535: CALL_OW 259
16539: PUSH
16540: LD_LOC 21
16544: PUSH
16545: LD_INT 4
16547: ARRAY
16548: NONEQUAL
16549: OR
16550: IFFALSE 16560
// zmena = true ;
16552: LD_ADDR_VAR 0 1
16556: PUSH
16557: LD_INT 1
16559: ST_TO_ADDR
// if IsOk ( bel ) then
16560: LD_EXP 52
16564: PPUSH
16565: CALL_OW 302
16569: IFFALSE 16675
// if ( ( GetSkill ( bel , 1 ) <> BelSk [ 1 ] ) or ( GetSkill ( bel , 2 ) <> BelSk [ 2 ] ) or ( GetSkill ( bel , 3 ) <> BelSk [ 3 ] ) or ( GetSkill ( bel , 4 ) <> BelSk [ 4 ] ) ) then
16571: LD_EXP 52
16575: PPUSH
16576: LD_INT 1
16578: PPUSH
16579: CALL_OW 259
16583: PUSH
16584: LD_LOC 20
16588: PUSH
16589: LD_INT 1
16591: ARRAY
16592: NONEQUAL
16593: PUSH
16594: LD_EXP 52
16598: PPUSH
16599: LD_INT 2
16601: PPUSH
16602: CALL_OW 259
16606: PUSH
16607: LD_LOC 20
16611: PUSH
16612: LD_INT 2
16614: ARRAY
16615: NONEQUAL
16616: OR
16617: PUSH
16618: LD_EXP 52
16622: PPUSH
16623: LD_INT 3
16625: PPUSH
16626: CALL_OW 259
16630: PUSH
16631: LD_LOC 20
16635: PUSH
16636: LD_INT 3
16638: ARRAY
16639: NONEQUAL
16640: OR
16641: PUSH
16642: LD_EXP 52
16646: PPUSH
16647: LD_INT 4
16649: PPUSH
16650: CALL_OW 259
16654: PUSH
16655: LD_LOC 20
16659: PUSH
16660: LD_INT 4
16662: ARRAY
16663: NONEQUAL
16664: OR
16665: IFFALSE 16675
// zmena = true ;
16667: LD_ADDR_VAR 0 1
16671: PUSH
16672: LD_INT 1
16674: ST_TO_ADDR
// if zmena then
16675: LD_VAR 0 1
16679: IFFALSE 16687
// hint_skilly else
16681: CALL 10548 0 0
16685: GO 16688
// enable ;
16687: ENABLE
// end ;
16688: PPOPN 1
16690: END
// every 0 0$3 trigger IsOk ( plat ) do
16691: LD_EXP 54
16695: PPUSH
16696: CALL_OW 302
16700: IFFALSE 16762
16702: GO 16704
16704: DISABLE
// begin enable ;
16705: ENABLE
// if GetLives ( plat ) < 1000 then
16706: LD_EXP 54
16710: PPUSH
16711: CALL_OW 256
16715: PUSH
16716: LD_INT 1000
16718: LESS
16719: IFFALSE 16733
// SetLives ( plat , 1000 ) ;
16721: LD_EXP 54
16725: PPUSH
16726: LD_INT 1000
16728: PPUSH
16729: CALL_OW 234
// if IsInArea ( plat , Out_base ) then
16733: LD_EXP 54
16737: PPUSH
16738: LD_INT 6
16740: PPUSH
16741: CALL_OW 308
16745: IFFALSE 16762
// ComMoveXY ( plat , 66 , 92 ) ;
16747: LD_EXP 54
16751: PPUSH
16752: LD_INT 66
16754: PPUSH
16755: LD_INT 92
16757: PPUSH
16758: CALL_OW 111
// end ; end_of_file
16762: END
// export Amici_past ; export Amici_baze ; export BWW_1 , BWW_2 ; export ABW1 , ABW2 ; var opravy ; var Am_opravari ; every 0 0$0.1 do
16763: GO 16765
16765: DISABLE
// begin opravy = false ;
16766: LD_ADDR_LOC 22
16770: PUSH
16771: LD_INT 0
16773: ST_TO_ADDR
// end ;
16774: END
// export function placni_amiky_past ; var i ; begin
16775: LD_INT 0
16777: PPUSH
16778: PPUSH
// for i in AMICI_PAST_LIST do
16779: LD_ADDR_VAR 0 2
16783: PUSH
16784: LD_EXP 37
16788: PUSH
16789: FOR_IN
16790: IFFALSE 16809
// PlaceUnitArea ( i , Am_past , false ) ;
16792: LD_VAR 0 2
16796: PPUSH
16797: LD_INT 7
16799: PPUSH
16800: LD_INT 0
16802: PPUSH
16803: CALL_OW 49
16807: GO 16789
16809: POP
16810: POP
// Amici_past = AMICI_PAST_LIST ;
16811: LD_ADDR_EXP 72
16815: PUSH
16816: LD_EXP 37
16820: ST_TO_ADDR
// AddComCrawl ( AMICI_PAST_LIST ) ;
16821: LD_EXP 37
16825: PPUSH
16826: CALL_OW 197
// for i = 1 to 3 do
16830: LD_ADDR_VAR 0 2
16834: PUSH
16835: DOUBLE
16836: LD_INT 1
16838: DEC
16839: ST_TO_ADDR
16840: LD_INT 3
16842: PUSH
16843: FOR_TO
16844: IFFALSE 16883
// begin if i > AMICI_PAST_LIST then
16846: LD_VAR 0 2
16850: PUSH
16851: LD_EXP 37
16855: GREATER
16856: IFFALSE 16860
// break ;
16858: GO 16883
// AddComMoveXY ( AMICI_PAST_LIST [ i ] , 60 , 28 ) ;
16860: LD_EXP 37
16864: PUSH
16865: LD_VAR 0 2
16869: ARRAY
16870: PPUSH
16871: LD_INT 60
16873: PPUSH
16874: LD_INT 28
16876: PPUSH
16877: CALL_OW 171
// end ;
16881: GO 16843
16883: POP
16884: POP
// for i = 4 to AMICI_PAST_LIST + 0 do
16885: LD_ADDR_VAR 0 2
16889: PUSH
16890: DOUBLE
16891: LD_INT 4
16893: DEC
16894: ST_TO_ADDR
16895: LD_EXP 37
16899: PUSH
16900: LD_INT 0
16902: PLUS
16903: PUSH
16904: FOR_TO
16905: IFFALSE 16930
// AddComMoveXY ( AMICI_PAST_LIST [ i ] , 73 , 21 ) ;
16907: LD_EXP 37
16911: PUSH
16912: LD_VAR 0 2
16916: ARRAY
16917: PPUSH
16918: LD_INT 73
16920: PPUSH
16921: LD_INT 21
16923: PPUSH
16924: CALL_OW 171
16928: GO 16904
16930: POP
16931: POP
// end ;
16932: LD_VAR 0 1
16936: RET
// export function stavba_am_baze ; var i ; var pom ; begin
16937: LD_INT 0
16939: PPUSH
16940: PPUSH
16941: PPUSH
// Amici_baze = AMICI_STAVENI_BASE_LIST ;
16942: LD_ADDR_EXP 73
16946: PUSH
16947: LD_EXP 38
16951: ST_TO_ADDR
// for i in AMICI_STAVENI_BASE_LIST do
16952: LD_ADDR_VAR 0 2
16956: PUSH
16957: LD_EXP 38
16961: PUSH
16962: FOR_IN
16963: IFFALSE 16982
// PlaceUnitArea ( i , Amici_enter , false ) ;
16965: LD_VAR 0 2
16969: PPUSH
16970: LD_INT 8
16972: PPUSH
16973: LD_INT 0
16975: PPUSH
16976: CALL_OW 49
16980: GO 16962
16982: POP
16983: POP
// ComMoveXY ( Amici_baze , 53 , 55 ) ;
16984: LD_EXP 73
16988: PPUSH
16989: LD_INT 53
16991: PPUSH
16992: LD_INT 55
16994: PPUSH
16995: CALL_OW 111
// uc_nation := nation_american ;
16999: LD_ADDR_OWVAR 21
17003: PUSH
17004: LD_INT 1
17006: ST_TO_ADDR
// uc_side := amici ;
17007: LD_ADDR_OWVAR 20
17011: PUSH
17012: LD_EXP 2
17016: ST_TO_ADDR
// bc_type := b_depot ;
17017: LD_ADDR_OWVAR 42
17021: PUSH
17022: LD_INT 0
17024: ST_TO_ADDR
// bc_level := 0 ;
17025: LD_ADDR_OWVAR 43
17029: PUSH
17030: LD_INT 0
17032: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 52 , 48 , 2 ) ;
17033: LD_INT 52
17035: PPUSH
17036: LD_INT 48
17038: PPUSH
17039: LD_INT 2
17041: PPUSH
17042: CALL_OW 47
// end ;
17046: LD_VAR 0 1
17050: RET
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) > 0 do var pom , i ;
17051: LD_INT 9
17053: PPUSH
17054: LD_INT 22
17056: PUSH
17057: LD_EXP 2
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: PUSH
17066: LD_INT 30
17068: PUSH
17069: LD_INT 0
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PPUSH
17080: CALL_OW 70
17084: PUSH
17085: LD_INT 0
17087: GREATER
17088: IFFALSE 17251
17090: GO 17092
17092: DISABLE
17093: LD_INT 0
17095: PPUSH
17096: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
17097: LD_ADDR_VAR 0 1
17101: PUSH
17102: LD_INT 9
17104: PPUSH
17105: LD_INT 22
17107: PUSH
17108: LD_EXP 2
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 30
17119: PUSH
17120: LD_INT 0
17122: PUSH
17123: EMPTY
17124: LIST
17125: LIST
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PPUSH
17131: CALL_OW 70
17135: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
17136: LD_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ARRAY
17144: PPUSH
17145: CALL_OW 304
17149: PUSH
17150: LD_INT 0
17152: NONEQUAL
17153: IFFALSE 17164
// wait ( 0 0$2 ) ;
17155: LD_INT 70
17157: PPUSH
17158: CALL_OW 67
17162: GO 17136
// AddResourceType ( GetBase ( pom [ 1 ] ) , mat_cans , 40 ) ;
17164: LD_VAR 0 1
17168: PUSH
17169: LD_INT 1
17171: ARRAY
17172: PPUSH
17173: CALL_OW 274
17177: PPUSH
17178: LD_INT 1
17180: PPUSH
17181: LD_INT 40
17183: PPUSH
17184: CALL_OW 276
// for i in Amici_baze do
17188: LD_ADDR_VAR 0 2
17192: PUSH
17193: LD_EXP 73
17197: PUSH
17198: FOR_IN
17199: IFFALSE 17228
// if GetClass ( i ) = class_engineer then
17201: LD_VAR 0 2
17205: PPUSH
17206: CALL_OW 257
17210: PUSH
17211: LD_INT 2
17213: EQUAL
17214: IFFALSE 17226
// pom = i ;
17216: LD_ADDR_VAR 0 1
17220: PUSH
17221: LD_VAR 0 2
17225: ST_TO_ADDR
17226: GO 17198
17228: POP
17229: POP
// AddComBuild ( pom , b_breastwork , 61 , 52 , 4 ) ;
17230: LD_VAR 0 1
17234: PPUSH
17235: LD_INT 31
17237: PPUSH
17238: LD_INT 61
17240: PPUSH
17241: LD_INT 52
17243: PPUSH
17244: LD_INT 4
17246: PPUSH
17247: CALL_OW 205
// end ;
17251: PPOPN 2
17253: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) > 0 do var pom , i ;
17254: LD_INT 9
17256: PPUSH
17257: LD_INT 22
17259: PUSH
17260: LD_EXP 2
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PUSH
17269: LD_INT 30
17271: PUSH
17272: LD_INT 31
17274: PUSH
17275: EMPTY
17276: LIST
17277: LIST
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PPUSH
17283: CALL_OW 70
17287: PUSH
17288: LD_INT 0
17290: GREATER
17291: IFFALSE 17430
17293: GO 17295
17295: DISABLE
17296: LD_INT 0
17298: PPUSH
17299: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
17300: LD_ADDR_VAR 0 1
17304: PUSH
17305: LD_INT 9
17307: PPUSH
17308: LD_INT 22
17310: PUSH
17311: LD_EXP 2
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: PUSH
17320: LD_INT 30
17322: PUSH
17323: LD_INT 31
17325: PUSH
17326: EMPTY
17327: LIST
17328: LIST
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 70
17338: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
17339: LD_VAR 0 1
17343: PUSH
17344: LD_INT 1
17346: ARRAY
17347: PPUSH
17348: CALL_OW 304
17352: PUSH
17353: LD_INT 0
17355: NONEQUAL
17356: IFFALSE 17367
// wait ( 0 0$2 ) ;
17358: LD_INT 70
17360: PPUSH
17361: CALL_OW 67
17365: GO 17339
// for i in Amici_baze do
17367: LD_ADDR_VAR 0 2
17371: PUSH
17372: LD_EXP 73
17376: PUSH
17377: FOR_IN
17378: IFFALSE 17407
// if GetClass ( i ) = class_engineer then
17380: LD_VAR 0 2
17384: PPUSH
17385: CALL_OW 257
17389: PUSH
17390: LD_INT 2
17392: EQUAL
17393: IFFALSE 17405
// pom = i ;
17395: LD_ADDR_VAR 0 1
17399: PUSH
17400: LD_VAR 0 2
17404: ST_TO_ADDR
17405: GO 17377
17407: POP
17408: POP
// AddComBuild ( pom , b_breastwork , 62 , 56 , 4 ) ;
17409: LD_VAR 0 1
17413: PPUSH
17414: LD_INT 31
17416: PPUSH
17417: LD_INT 62
17419: PPUSH
17420: LD_INT 56
17422: PPUSH
17423: LD_INT 4
17425: PPUSH
17426: CALL_OW 205
// end ;
17430: PPOPN 2
17432: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) > 1 do var pom , i , pom1 ;
17433: LD_INT 9
17435: PPUSH
17436: LD_INT 22
17438: PUSH
17439: LD_EXP 2
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PUSH
17448: LD_INT 30
17450: PUSH
17451: LD_INT 31
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: PUSH
17458: EMPTY
17459: LIST
17460: LIST
17461: PPUSH
17462: CALL_OW 70
17466: PUSH
17467: LD_INT 1
17469: GREATER
17470: IFFALSE 17765
17472: GO 17474
17474: DISABLE
17475: LD_INT 0
17477: PPUSH
17478: PPUSH
17479: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
17480: LD_ADDR_VAR 0 1
17484: PUSH
17485: LD_INT 9
17487: PPUSH
17488: LD_INT 22
17490: PUSH
17491: LD_EXP 2
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PUSH
17500: LD_INT 30
17502: PUSH
17503: LD_INT 31
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PPUSH
17514: CALL_OW 70
17518: ST_TO_ADDR
// pom1 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_class , class_soldier ] ] ) ;
17519: LD_ADDR_VAR 0 3
17523: PUSH
17524: LD_INT 9
17526: PPUSH
17527: LD_INT 22
17529: PUSH
17530: LD_EXP 2
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PUSH
17539: LD_INT 25
17541: PUSH
17542: LD_INT 1
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: PPUSH
17553: CALL_OW 70
17557: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) or IsConstructed ( pom [ 2 ] ) <> 0 do
17558: LD_VAR 0 1
17562: PUSH
17563: LD_INT 1
17565: ARRAY
17566: PPUSH
17567: CALL_OW 304
17571: PUSH
17572: LD_VAR 0 1
17576: PUSH
17577: LD_INT 2
17579: ARRAY
17580: PPUSH
17581: CALL_OW 304
17585: PUSH
17586: LD_INT 0
17588: NONEQUAL
17589: OR
17590: IFFALSE 17601
// wait ( 0 0$1 ) ;
17592: LD_INT 35
17594: PPUSH
17595: CALL_OW 67
17599: GO 17558
// ComEnterUnit ( pom1 [ 1 ] , pom [ 1 ] ) ;
17601: LD_VAR 0 3
17605: PUSH
17606: LD_INT 1
17608: ARRAY
17609: PPUSH
17610: LD_VAR 0 1
17614: PUSH
17615: LD_INT 1
17617: ARRAY
17618: PPUSH
17619: CALL_OW 120
// ComEnterUnit ( pom1 [ 2 ] , pom [ 2 ] ) ;
17623: LD_VAR 0 3
17627: PUSH
17628: LD_INT 2
17630: ARRAY
17631: PPUSH
17632: LD_VAR 0 1
17636: PUSH
17637: LD_INT 2
17639: ARRAY
17640: PPUSH
17641: CALL_OW 120
// SetBLevel ( pom , levely_bw_na_zapade [ difficulty ] ) ;
17645: LD_VAR 0 1
17649: PPUSH
17650: LD_EXP 44
17654: PUSH
17655: LD_OWVAR 67
17659: ARRAY
17660: PPUSH
17661: CALL_OW 241
// pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
17665: LD_ADDR_VAR 0 1
17669: PUSH
17670: LD_INT 9
17672: PPUSH
17673: LD_INT 22
17675: PUSH
17676: LD_EXP 2
17680: PUSH
17681: EMPTY
17682: LIST
17683: LIST
17684: PUSH
17685: LD_INT 30
17687: PUSH
17688: LD_INT 0
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: PPUSH
17699: CALL_OW 70
17703: ST_TO_ADDR
// pom1 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_class , class_engineer ] ] ) ;
17704: LD_ADDR_VAR 0 3
17708: PUSH
17709: LD_INT 9
17711: PPUSH
17712: LD_INT 22
17714: PUSH
17715: LD_EXP 2
17719: PUSH
17720: EMPTY
17721: LIST
17722: LIST
17723: PUSH
17724: LD_INT 25
17726: PUSH
17727: LD_INT 2
17729: PUSH
17730: EMPTY
17731: LIST
17732: LIST
17733: PUSH
17734: EMPTY
17735: LIST
17736: LIST
17737: PPUSH
17738: CALL_OW 70
17742: ST_TO_ADDR
// ComEnterUnit ( pom1 , pom [ 1 ] ) ;
17743: LD_VAR 0 3
17747: PPUSH
17748: LD_VAR 0 1
17752: PUSH
17753: LD_INT 1
17755: ARRAY
17756: PPUSH
17757: CALL_OW 120
// nastav_levely_budov ;
17761: CALL 19339 0 0
// end ;
17765: PPOPN 3
17767: END
// export function amici_boj ; var mech ; var auto ; var i ; var AP ; begin
17768: LD_INT 0
17770: PPUSH
17771: PPUSH
17772: PPUSH
17773: PPUSH
17774: PPUSH
// ComMoveXY ( Amici_past , 64 , 16 ) ;
17775: LD_EXP 72
17779: PPUSH
17780: LD_INT 64
17782: PPUSH
17783: LD_INT 16
17785: PPUSH
17786: CALL_OW 111
// mech = vyber_cloveka ( Amici_past , class_mechanic ) ;
17790: LD_ADDR_VAR 0 2
17794: PUSH
17795: LD_EXP 72
17799: PPUSH
17800: LD_INT 3
17802: PPUSH
17803: CALL 4287 0 2
17807: ST_TO_ADDR
// if mech = 0 or ( not IsOK ( mech ) ) then
17808: LD_VAR 0 2
17812: PUSH
17813: LD_INT 0
17815: EQUAL
17816: PUSH
17817: LD_VAR 0 2
17821: PPUSH
17822: CALL_OW 302
17826: NOT
17827: OR
17828: IFFALSE 17858
// mech = UnitFilter ( Amici_past , [ [ f_ok ] ] ) [ 1 ] ;
17830: LD_ADDR_VAR 0 2
17834: PUSH
17835: LD_EXP 72
17839: PPUSH
17840: LD_INT 50
17842: PUSH
17843: EMPTY
17844: LIST
17845: PUSH
17846: EMPTY
17847: LIST
17848: PPUSH
17849: CALL_OW 72
17853: PUSH
17854: LD_INT 1
17856: ARRAY
17857: ST_TO_ADDR
// auto = FilterAllUnits ( [ [ f_side , You2 ] , [ f_type , unit_vehicle ] ] ) ;
17858: LD_ADDR_VAR 0 3
17862: PUSH
17863: LD_INT 22
17865: PUSH
17866: LD_EXP 4
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 21
17877: PUSH
17878: LD_INT 2
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: PPUSH
17889: CALL_OW 69
17893: ST_TO_ADDR
// if auto > 0 then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 0
17901: GREATER
17902: IFFALSE 17918
// auto = auto [ 1 ] ;
17904: LD_ADDR_VAR 0 3
17908: PUSH
17909: LD_VAR 0 3
17913: PUSH
17914: LD_INT 1
17916: ARRAY
17917: ST_TO_ADDR
// if mech = 0 then
17918: LD_VAR 0 2
17922: PUSH
17923: LD_INT 0
17925: EQUAL
17926: IFFALSE 17942
// mech = Amici_past [ 1 ] ;
17928: LD_ADDR_VAR 0 2
17932: PUSH
17933: LD_EXP 72
17937: PUSH
17938: LD_INT 1
17940: ARRAY
17941: ST_TO_ADDR
// ComEnterUnit ( mech , auto ) ;
17942: LD_VAR 0 2
17946: PPUSH
17947: LD_VAR 0 3
17951: PPUSH
17952: CALL_OW 120
// AddComMoveXY ( Amici_past , 69 , 18 ) ;
17956: LD_EXP 72
17960: PPUSH
17961: LD_INT 69
17963: PPUSH
17964: LD_INT 18
17966: PPUSH
17967: CALL_OW 171
// AddComMoveXY ( auto , 72 , 21 ) ;
17971: LD_VAR 0 3
17975: PPUSH
17976: LD_INT 72
17978: PPUSH
17979: LD_INT 21
17981: PPUSH
17982: CALL_OW 171
// wait ( 0 0$3 ) ;
17986: LD_INT 105
17988: PPUSH
17989: CALL_OW 67
// zaber_to_auto ;
17993: CALL 19206 0 0
// while FilterAllUnits ( [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) = 0 do
17997: LD_INT 22
17999: PUSH
18000: LD_EXP 2
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 21
18011: PUSH
18012: LD_INT 2
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL_OW 69
18027: PUSH
18028: LD_INT 0
18030: EQUAL
18031: IFFALSE 18111
// begin for i in Amici_past do
18033: LD_ADDR_VAR 0 4
18037: PUSH
18038: LD_EXP 72
18042: PUSH
18043: FOR_IN
18044: IFFALSE 18071
// if IsOK ( i ) then
18046: LD_VAR 0 4
18050: PPUSH
18051: CALL_OW 302
18055: IFFALSE 18069
// begin AP = i ;
18057: LD_ADDR_VAR 0 5
18061: PUSH
18062: LD_VAR 0 4
18066: ST_TO_ADDR
// break ;
18067: GO 18071
// end ;
18069: GO 18043
18071: POP
18072: POP
// ComEnterUnit ( AP , Auto_belkov ) ;
18073: LD_VAR 0 5
18077: PPUSH
18078: LD_EXP 70
18082: PPUSH
18083: CALL_OW 120
// AddComMoveXY ( AP , 73 , 22 ) ;
18087: LD_VAR 0 5
18091: PPUSH
18092: LD_INT 73
18094: PPUSH
18095: LD_INT 22
18097: PPUSH
18098: CALL_OW 171
// wait ( 0 0$2 ) ;
18102: LD_INT 70
18104: PPUSH
18105: CALL_OW 67
// end ;
18109: GO 17997
// end ;
18111: LD_VAR 0 1
18115: RET
// export function amici_attack_belkov ; var i ; begin
18116: LD_INT 0
18118: PPUSH
18119: PPUSH
// if GetSide ( bel ) <> You then
18120: LD_EXP 52
18124: PPUSH
18125: CALL_OW 255
18129: PUSH
18130: LD_EXP 1
18134: NONEQUAL
18135: IFFALSE 18258
// begin for i in AMICI_UTOK_BELKOV_LIST do
18137: LD_ADDR_VAR 0 2
18141: PUSH
18142: LD_EXP 39
18146: PUSH
18147: FOR_IN
18148: IFFALSE 18167
// PlaceUnitArea ( i , Zpet_bel , false ) ;
18150: LD_VAR 0 2
18154: PPUSH
18155: LD_INT 15
18157: PPUSH
18158: LD_INT 0
18160: PPUSH
18161: CALL_OW 49
18165: GO 18147
18167: POP
18168: POP
// McMove ( 1 , AMICI_UTOK_BELKOV_LIST , [ [ 44 , 6 ] , [ 36 , 5 ] , [ 36 , 10 ] , [ GetX ( bel ) , GetY ( bel ) ] , [ 52 , 2 ] ] , [ mc_move_agressive ] ) ;
18169: LD_INT 1
18171: PPUSH
18172: LD_EXP 39
18176: PPUSH
18177: LD_INT 44
18179: PUSH
18180: LD_INT 6
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: PUSH
18187: LD_INT 36
18189: PUSH
18190: LD_INT 5
18192: PUSH
18193: EMPTY
18194: LIST
18195: LIST
18196: PUSH
18197: LD_INT 36
18199: PUSH
18200: LD_INT 10
18202: PUSH
18203: EMPTY
18204: LIST
18205: LIST
18206: PUSH
18207: LD_EXP 52
18211: PPUSH
18212: CALL_OW 250
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: CALL_OW 251
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: PUSH
18231: LD_INT 52
18233: PUSH
18234: LD_INT 2
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: EMPTY
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: PPUSH
18248: LD_INT 6
18250: PUSH
18251: EMPTY
18252: LIST
18253: PPUSH
18254: CALL_OW 398
// end ; end ;
18258: LD_VAR 0 1
18262: RET
// export function amici_retreat ; var i , Amici_All ; begin
18263: LD_INT 0
18265: PPUSH
18266: PPUSH
18267: PPUSH
// Amici_All := AMICI_UTOK_BELKOV_LIST union AMICI_PAST_LIST ^ auto_belkov ;
18268: LD_ADDR_VAR 0 3
18272: PUSH
18273: LD_EXP 39
18277: PUSH
18278: LD_EXP 37
18282: PUSH
18283: LD_EXP 70
18287: ADD
18288: UNION
18289: ST_TO_ADDR
// repeat ComMoveToArea ( Amici_All , Zpet_bel ) ;
18290: LD_VAR 0 3
18294: PPUSH
18295: LD_INT 15
18297: PPUSH
18298: CALL_OW 113
// wait ( 0 0$1 ) ;
18302: LD_INT 35
18304: PPUSH
18305: CALL_OW 67
// for i in Amici_All do
18309: LD_ADDR_VAR 0 2
18313: PUSH
18314: LD_VAR 0 3
18318: PUSH
18319: FOR_IN
18320: IFFALSE 18391
// begin if not ( IsOK ( i ) ) then
18322: LD_VAR 0 2
18326: PPUSH
18327: CALL_OW 302
18331: NOT
18332: IFFALSE 18350
// Amici_All := Amici_All diff i ;
18334: LD_ADDR_VAR 0 3
18338: PUSH
18339: LD_VAR 0 3
18343: PUSH
18344: LD_VAR 0 2
18348: DIFF
18349: ST_TO_ADDR
// if IsInArea ( i , Zpet_bel ) then
18350: LD_VAR 0 2
18354: PPUSH
18355: LD_INT 15
18357: PPUSH
18358: CALL_OW 308
18362: IFFALSE 18389
// begin Amici_All := Amici_All diff i ;
18364: LD_ADDR_VAR 0 3
18368: PUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_VAR 0 2
18378: DIFF
18379: ST_TO_ADDR
// RemoveUnit ( i ) ;
18380: LD_VAR 0 2
18384: PPUSH
18385: CALL_OW 64
// end ; end ;
18389: GO 18319
18391: POP
18392: POP
// until Amici_All = [ ] ;
18393: LD_VAR 0 3
18397: PUSH
18398: EMPTY
18399: EQUAL
18400: IFFALSE 18290
// end ;
18402: LD_VAR 0 1
18406: RET
// every 0 0$2 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) = 2 do
18407: LD_INT 9
18409: PPUSH
18410: LD_INT 22
18412: PUSH
18413: LD_EXP 2
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: LD_INT 30
18424: PUSH
18425: LD_INT 31
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PPUSH
18436: CALL_OW 70
18440: PUSH
18441: LD_INT 2
18443: EQUAL
18444: IFFALSE 18485
18446: GO 18448
18448: DISABLE
// begin Am_opravari = UnitFilter ( Amici_baze , [ [ f_class , class_engineer ] ] ) ;
18449: LD_ADDR_LOC 23
18453: PUSH
18454: LD_EXP 73
18458: PPUSH
18459: LD_INT 25
18461: PUSH
18462: LD_INT 2
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PUSH
18469: EMPTY
18470: LIST
18471: PPUSH
18472: CALL_OW 72
18476: ST_TO_ADDR
// opravy = true ;
18477: LD_ADDR_LOC 22
18481: PUSH
18482: LD_INT 1
18484: ST_TO_ADDR
// end ;
18485: END
// every 0 0$4 trigger opravy do var pom , i ; var pom1 , pom2 ;
18486: LD_LOC 22
18490: IFFALSE 18966
18492: GO 18494
18494: DISABLE
18495: LD_INT 0
18497: PPUSH
18498: PPUSH
18499: PPUSH
18500: PPUSH
// begin pom1 = [ ] ;
18501: LD_ADDR_VAR 0 3
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
18508: LD_ADDR_VAR 0 1
18512: PUSH
18513: LD_INT 9
18515: PPUSH
18516: LD_INT 22
18518: PUSH
18519: LD_EXP 2
18523: PUSH
18524: EMPTY
18525: LIST
18526: LIST
18527: PUSH
18528: LD_INT 30
18530: PUSH
18531: LD_INT 31
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: PPUSH
18542: CALL_OW 70
18546: ST_TO_ADDR
// for i in pom do
18547: LD_ADDR_VAR 0 2
18551: PUSH
18552: LD_VAR 0 1
18556: PUSH
18557: FOR_IN
18558: IFFALSE 18593
// if GetLives ( i ) < 1000 then
18560: LD_VAR 0 2
18564: PPUSH
18565: CALL_OW 256
18569: PUSH
18570: LD_INT 1000
18572: LESS
18573: IFFALSE 18591
// pom1 = pom1 ^ i ;
18575: LD_ADDR_VAR 0 3
18579: PUSH
18580: LD_VAR 0 3
18584: PUSH
18585: LD_VAR 0 2
18589: ADD
18590: ST_TO_ADDR
18591: GO 18557
18593: POP
18594: POP
// case pom1 + 0 of 1 :
18595: LD_VAR 0 3
18599: PUSH
18600: LD_INT 0
18602: PLUS
18603: PUSH
18604: LD_INT 1
18606: DOUBLE
18607: EQUAL
18608: IFTRUE 18612
18610: GO 18716
18612: POP
// begin ComExitBuilding ( Am_opravari ) ;
18613: LD_LOC 23
18617: PPUSH
18618: CALL_OW 122
// AddComRepairBuilding ( Am_opravari , pom1 [ 1 ] ) ;
18622: LD_LOC 23
18626: PPUSH
18627: LD_VAR 0 3
18631: PUSH
18632: LD_INT 1
18634: ARRAY
18635: PPUSH
18636: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18640: LD_ADDR_VAR 0 4
18644: PUSH
18645: LD_INT 9
18647: PPUSH
18648: LD_INT 22
18650: PUSH
18651: LD_EXP 2
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PUSH
18660: LD_INT 30
18662: PUSH
18663: LD_INT 0
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: PPUSH
18674: CALL_OW 70
18678: ST_TO_ADDR
// if pom2 > 0 then
18679: LD_VAR 0 4
18683: PUSH
18684: LD_INT 0
18686: GREATER
18687: IFFALSE 18707
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
18689: LD_LOC 23
18693: PPUSH
18694: LD_VAR 0 4
18698: PUSH
18699: LD_INT 1
18701: ARRAY
18702: PPUSH
18703: CALL_OW 180
// wait ( 0 0$5 ) ;
18707: LD_INT 175
18709: PPUSH
18710: CALL_OW 67
// end ; 2 :
18714: GO 18965
18716: LD_INT 2
18718: DOUBLE
18719: EQUAL
18720: IFTRUE 18724
18722: GO 18964
18724: POP
// begin if Am_opravari + 0 = 2 then
18725: LD_LOC 23
18729: PUSH
18730: LD_INT 0
18732: PLUS
18733: PUSH
18734: LD_INT 2
18736: EQUAL
18737: IFFALSE 18861
// begin ComExitBuilding ( Am_opravari ) ;
18739: LD_LOC 23
18743: PPUSH
18744: CALL_OW 122
// AddComRepairBuilding ( Am_opravari [ 2 ] , pom1 [ 1 ] ) ;
18748: LD_LOC 23
18752: PUSH
18753: LD_INT 2
18755: ARRAY
18756: PPUSH
18757: LD_VAR 0 3
18761: PUSH
18762: LD_INT 1
18764: ARRAY
18765: PPUSH
18766: CALL_OW 190
// AddComRepairBuilding ( Am_opravari [ 1 ] , pom1 [ 1 ] ) ;
18770: LD_LOC 23
18774: PUSH
18775: LD_INT 1
18777: ARRAY
18778: PPUSH
18779: LD_VAR 0 3
18783: PUSH
18784: LD_INT 1
18786: ARRAY
18787: PPUSH
18788: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18792: LD_ADDR_VAR 0 4
18796: PUSH
18797: LD_INT 9
18799: PPUSH
18800: LD_INT 22
18802: PUSH
18803: LD_EXP 2
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: LD_INT 30
18814: PUSH
18815: LD_INT 0
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: EMPTY
18823: LIST
18824: LIST
18825: PPUSH
18826: CALL_OW 70
18830: ST_TO_ADDR
// if pom2 > 0 then
18831: LD_VAR 0 4
18835: PUSH
18836: LD_INT 0
18838: GREATER
18839: IFFALSE 18859
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
18841: LD_LOC 23
18845: PPUSH
18846: LD_VAR 0 4
18850: PUSH
18851: LD_INT 1
18853: ARRAY
18854: PPUSH
18855: CALL_OW 180
// end else
18859: GO 18955
// begin ComExitBuilding ( Am_opravari ) ;
18861: LD_LOC 23
18865: PPUSH
18866: CALL_OW 122
// AddComRepairBuilding ( Am_opravari , pom1 [ 1 ] ) ;
18870: LD_LOC 23
18874: PPUSH
18875: LD_VAR 0 3
18879: PUSH
18880: LD_INT 1
18882: ARRAY
18883: PPUSH
18884: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18888: LD_ADDR_VAR 0 4
18892: PUSH
18893: LD_INT 9
18895: PPUSH
18896: LD_INT 22
18898: PUSH
18899: LD_EXP 2
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 30
18910: PUSH
18911: LD_INT 0
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: PPUSH
18922: CALL_OW 70
18926: ST_TO_ADDR
// if pom2 > 0 then
18927: LD_VAR 0 4
18931: PUSH
18932: LD_INT 0
18934: GREATER
18935: IFFALSE 18955
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
18937: LD_LOC 23
18941: PPUSH
18942: LD_VAR 0 4
18946: PUSH
18947: LD_INT 1
18949: ARRAY
18950: PPUSH
18951: CALL_OW 180
// end ; wait ( 0 0$5 ) ;
18955: LD_INT 175
18957: PPUSH
18958: CALL_OW 67
// end ; end ;
18962: GO 18965
18964: POP
// enable ;
18965: ENABLE
// end ;
18966: PPOPN 4
18968: END
// every 0 0$1 trigger opravy do var pom , i ;
18969: LD_LOC 22
18973: IFFALSE 19043
18975: GO 18977
18977: DISABLE
18978: LD_INT 0
18980: PPUSH
18981: PPUSH
// begin pom = [ ] ;
18982: LD_ADDR_VAR 0 1
18986: PUSH
18987: EMPTY
18988: ST_TO_ADDR
// for i in Am_opravari do
18989: LD_ADDR_VAR 0 2
18993: PUSH
18994: LD_LOC 23
18998: PUSH
18999: FOR_IN
19000: IFFALSE 19031
// if IsOK ( i ) then
19002: LD_VAR 0 2
19006: PPUSH
19007: CALL_OW 302
19011: IFFALSE 19029
// pom = pom ^ i ;
19013: LD_ADDR_VAR 0 1
19017: PUSH
19018: LD_VAR 0 1
19022: PUSH
19023: LD_VAR 0 2
19027: ADD
19028: ST_TO_ADDR
19029: GO 18999
19031: POP
19032: POP
// Am_opravari = pom ;
19033: LD_ADDR_LOC 23
19037: PUSH
19038: LD_VAR 0 1
19042: ST_TO_ADDR
// end ;
19043: PPOPN 2
19045: END
// export function amici_po_kecech ; var i , j ; var pom ; begin
19046: LD_INT 0
19048: PPUSH
19049: PPUSH
19050: PPUSH
19051: PPUSH
// i = 1 ;
19052: LD_ADDR_VAR 0 2
19056: PUSH
19057: LD_INT 1
19059: ST_TO_ADDR
// if GetSide ( auto_belkov ) <> Amici then
19060: LD_EXP 70
19064: PPUSH
19065: CALL_OW 255
19069: PUSH
19070: LD_EXP 2
19074: NONEQUAL
19075: IFFALSE 19158
// begin for i in Amici_past do
19077: LD_ADDR_VAR 0 2
19081: PUSH
19082: LD_EXP 72
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19113
// if IsOK ( i ) then
19090: LD_VAR 0 2
19094: PPUSH
19095: CALL_OW 302
19099: IFFALSE 19111
// pom = i ;
19101: LD_ADDR_VAR 0 4
19105: PUSH
19106: LD_VAR 0 2
19110: ST_TO_ADDR
19111: GO 19087
19113: POP
19114: POP
// ComEnterUnit ( pom , auto_belkov ) ;
19115: LD_VAR 0 4
19119: PPUSH
19120: LD_EXP 70
19124: PPUSH
19125: CALL_OW 120
// AddComMoveXY ( pom , 74 , 22 ) ;
19129: LD_VAR 0 4
19133: PPUSH
19134: LD_INT 74
19136: PPUSH
19137: LD_INT 22
19139: PPUSH
19140: CALL_OW 171
// i = i + 1 ;
19144: LD_ADDR_VAR 0 2
19148: PUSH
19149: LD_VAR 0 2
19153: PUSH
19154: LD_INT 1
19156: PLUS
19157: ST_TO_ADDR
// end ; for i in Amici_past do
19158: LD_ADDR_VAR 0 2
19162: PUSH
19163: LD_EXP 72
19167: PUSH
19168: FOR_IN
19169: IFFALSE 19199
// if IsOK ( i ) then
19171: LD_VAR 0 2
19175: PPUSH
19176: CALL_OW 302
19180: IFFALSE 19197
// ComMoveXY ( i , 72 , 25 ) ;
19182: LD_VAR 0 2
19186: PPUSH
19187: LD_INT 72
19189: PPUSH
19190: LD_INT 25
19192: PPUSH
19193: CALL_OW 111
19197: GO 19168
19199: POP
19200: POP
// end ;
19201: LD_VAR 0 1
19205: RET
// function zaber_to_auto ; var i , pom ; begin
19206: LD_INT 0
19208: PPUSH
19209: PPUSH
19210: PPUSH
// while ( FilterAllUnits ( [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) = 0 ) and IsOK ( auto_belkov ) do
19211: LD_INT 22
19213: PUSH
19214: LD_EXP 2
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: PUSH
19223: LD_INT 21
19225: PUSH
19226: LD_INT 2
19228: PUSH
19229: EMPTY
19230: LIST
19231: LIST
19232: PUSH
19233: EMPTY
19234: LIST
19235: LIST
19236: PPUSH
19237: CALL_OW 69
19241: PUSH
19242: LD_INT 0
19244: EQUAL
19245: PUSH
19246: LD_EXP 70
19250: PPUSH
19251: CALL_OW 302
19255: AND
19256: IFFALSE 19334
// begin for i in Amici_past do
19258: LD_ADDR_VAR 0 2
19262: PUSH
19263: LD_EXP 72
19267: PUSH
19268: FOR_IN
19269: IFFALSE 19294
// if IsOK ( i ) then
19271: LD_VAR 0 2
19275: PPUSH
19276: CALL_OW 302
19280: IFFALSE 19292
// pom = i ;
19282: LD_ADDR_VAR 0 3
19286: PUSH
19287: LD_VAR 0 2
19291: ST_TO_ADDR
19292: GO 19268
19294: POP
19295: POP
// ComEnterUnit ( pom , auto_belkov ) ;
19296: LD_VAR 0 3
19300: PPUSH
19301: LD_EXP 70
19305: PPUSH
19306: CALL_OW 120
// AddComMoveXY ( pom , 72 , 20 ) ;
19310: LD_VAR 0 3
19314: PPUSH
19315: LD_INT 72
19317: PPUSH
19318: LD_INT 20
19320: PPUSH
19321: CALL_OW 171
// wait ( 0 0$2 ) ;
19325: LD_INT 70
19327: PPUSH
19328: CALL_OW 67
// end ;
19332: GO 19211
// end ;
19334: LD_VAR 0 1
19338: RET
// function nastav_levely_budov ; begin
19339: LD_INT 0
19341: PPUSH
// SetBLevel ( [ Am_bre1 , Am_bre2 ] , levely_bw_na_vychode ) ;
19342: LD_INT 30
19344: PUSH
19345: LD_INT 31
19347: PUSH
19348: EMPTY
19349: LIST
19350: LIST
19351: PPUSH
19352: LD_EXP 45
19356: PPUSH
19357: CALL_OW 241
// SetBLevel ( [ BWW_1 , BWW_2 ] , levely_bw_na_vychode ) ;
19361: LD_EXP 74
19365: PUSH
19366: LD_EXP 75
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PPUSH
19375: LD_EXP 45
19379: PPUSH
19380: CALL_OW 241
// end ; end_of_file
19384: LD_VAR 0 1
19388: RET
// every 0 0$5 trigger posily_go do var pom ; var i ;
19389: LD_EXP 68
19393: IFFALSE 19507
19395: GO 19397
19397: DISABLE
19398: LD_INT 0
19400: PPUSH
19401: PPUSH
// begin pom = [ RU2_hv1 , RU2_hv2 ] ;
19402: LD_ADDR_VAR 0 1
19406: PUSH
19407: LD_INT 15
19409: PUSH
19410: LD_INT 16
19412: PUSH
19413: EMPTY
19414: LIST
19415: LIST
19416: ST_TO_ADDR
// wait ( 2 ) ;
19417: LD_INT 2
19419: PPUSH
19420: CALL_OW 67
// AddComAgressiveMove ( pom , GetX ( bur ) , GetY ( bur ) ) ;
19424: LD_VAR 0 1
19428: PPUSH
19429: LD_EXP 50
19433: PPUSH
19434: CALL_OW 250
19438: PPUSH
19439: LD_EXP 50
19443: PPUSH
19444: CALL_OW 251
19448: PPUSH
19449: CALL_OW 174
// wait ( 0 0$6 ) ;
19453: LD_INT 210
19455: PPUSH
19456: CALL_OW 67
// for i in pom do
19460: LD_ADDR_VAR 0 2
19464: PUSH
19465: LD_VAR 0 1
19469: PUSH
19470: FOR_IN
19471: IFFALSE 19505
// begin SetSide ( i , You ) ;
19473: LD_VAR 0 2
19477: PPUSH
19478: LD_EXP 1
19482: PPUSH
19483: CALL_OW 235
// BurlakComp = BurlakComp ^ i ;
19487: LD_ADDR_EXP 14
19491: PUSH
19492: LD_EXP 14
19496: PUSH
19497: LD_VAR 0 2
19501: ADD
19502: ST_TO_ADDR
// end ;
19503: GO 19470
19505: POP
19506: POP
// end ;
19507: PPOPN 2
19509: END
// on VehicleCaptured ( vehicle , ab , side , human ) do begin if ab = auto_belkov then
19510: LD_VAR 0 2
19514: PUSH
19515: LD_EXP 70
19519: EQUAL
19520: IFFALSE 19532
// auto_belkov = vehicle ;
19522: LD_ADDR_EXP 70
19526: PUSH
19527: LD_VAR 0 1
19531: ST_TO_ADDR
// debug_strings = [ auto_belkov , GetSide ( auto_belkov ) , bel , IsDrivenBy ( auto_belkov ) ] ;
19532: LD_ADDR_OWVAR 48
19536: PUSH
19537: LD_EXP 70
19541: PUSH
19542: LD_EXP 70
19546: PPUSH
19547: CALL_OW 255
19551: PUSH
19552: LD_EXP 52
19556: PUSH
19557: LD_EXP 70
19561: PPUSH
19562: CALL_OW 311
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: ST_TO_ADDR
// enable ;
19573: ENABLE
// end ;
19574: PPOPN 4
19576: END
// on Command ( com ) do var i , j , temp ;
19577: LD_INT 0
19579: PPUSH
19580: PPUSH
19581: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
19582: LD_ADDR_VAR 0 2
19586: PUSH
19587: LD_INT 22
19589: PUSH
19590: LD_INT 3
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 21
19599: PUSH
19600: LD_INT 1
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: PUSH
19607: EMPTY
19608: LIST
19609: LIST
19610: PPUSH
19611: CALL_OW 69
19615: PUSH
19616: FOR_IN
19617: IFFALSE 19709
// if GetTaskList ( i ) > 0 then
19619: LD_VAR 0 2
19623: PPUSH
19624: CALL_OW 437
19628: PUSH
19629: LD_INT 0
19631: GREATER
19632: IFFALSE 19707
// for j = 1 to GetTaskList ( i ) do
19634: LD_ADDR_VAR 0 3
19638: PUSH
19639: DOUBLE
19640: LD_INT 1
19642: DEC
19643: ST_TO_ADDR
19644: LD_VAR 0 2
19648: PPUSH
19649: CALL_OW 437
19653: PUSH
19654: FOR_TO
19655: IFFALSE 19705
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
19657: LD_ADDR_VAR 0 4
19661: PUSH
19662: LD_VAR 0 2
19666: PPUSH
19667: CALL_OW 437
19671: PUSH
19672: LD_VAR 0 3
19676: ARRAY
19677: PUSH
19678: LD_INT 4
19680: ARRAY
19681: ST_TO_ADDR
// if temp = RU1_dep then
19682: LD_VAR 0 4
19686: PUSH
19687: LD_INT 1
19689: EQUAL
19690: IFFALSE 19703
// SetTaskList ( i , [ ] ) ;
19692: LD_VAR 0 2
19696: PPUSH
19697: EMPTY
19698: PPUSH
19699: CALL_OW 446
// end ;
19703: GO 19654
19705: POP
19706: POP
19707: GO 19616
19709: POP
19710: POP
// end ;
19711: PPOPN 4
19713: END

// export You , Amici , Rusi , You2 , Rusi2 , You3 , NoLosses ; export belkov_returns , belkov_american_clash ; export belkovSave ; starting begin InitVars ;
   0: CALL 1588 0 0
// disable_prediction = true ;
   4: LD_ADDR_OWVAR 50
   8: PUSH
   9: LD_INT 1
  11: ST_TO_ADDR
// debug_strings = [ ] ;
  12: LD_ADDR_OWVAR 48
  16: PUSH
  17: EMPTY
  18: ST_TO_ADDR
// RandomizeAll ;
  19: CALL_OW 11
// InitHc ;
  23: CALL_OW 19
// InitUc ;
  27: CALL_OW 18
// InitVc ;
  31: CALL_OW 20
// You = 3 ;
  35: LD_ADDR_EXP 1
  39: PUSH
  40: LD_INT 3
  42: ST_TO_ADDR
// Rusi = You ;
  43: LD_ADDR_EXP 3
  47: PUSH
  48: LD_EXP 1
  52: ST_TO_ADDR
// Amici = 1 ;
  53: LD_ADDR_EXP 2
  57: PUSH
  58: LD_INT 1
  60: ST_TO_ADDR
// You2 = 6 ;
  61: LD_ADDR_EXP 4
  65: PUSH
  66: LD_INT 6
  68: ST_TO_ADDR
// You3 = 5 ;
  69: LD_ADDR_EXP 6
  73: PUSH
  74: LD_INT 5
  76: ST_TO_ADDR
// Rusi2 = You2 ;
  77: LD_ADDR_EXP 5
  81: PUSH
  82: LD_EXP 4
  86: ST_TO_ADDR
// NoLosses := true ;
  87: LD_ADDR_EXP 7
  91: PUSH
  92: LD_INT 1
  94: ST_TO_ADDR
// belkovSave = false ;
  95: LD_ADDR_EXP 10
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// belkov_returns = false ;
 103: LD_ADDR_EXP 8
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// belkov_american_clash = false ;
 111: LD_ADDR_EXP 9
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// set_difficulty ;
 119: CALL 5174 0 0
// load_postav ;
 123: CALL 1430 0 0
// create_rusi_navic ;
 127: CALL 16286 0 0
// amici_breast ;
 131: CALL 3837 0 0
// create_amici_past ;
 135: CALL 4068 0 0
// create_amici_staveni_w ;
 139: CALL 4214 0 0
// create_utok_na_belkova ;
 143: CALL 4451 0 0
// create_vojaci_zacatek ;
 147: CALL 4710 0 0
// uklid_rusu ;
 151: CALL 13240 0 0
// InGameOn ;
 155: CALL_OW 8
// ChangeSideFog ( You , You2 ) ;
 159: LD_EXP 1
 163: PPUSH
 164: LD_EXP 4
 168: PPUSH
 169: CALL_OW 343
// InGameOn ;
 173: CALL_OW 8
// CenterOnXY ( 117 , 101 ) ;
 177: LD_INT 117
 179: PPUSH
 180: LD_INT 101
 182: PPUSH
 183: CALL_OW 84
// end ;
 187: END
// on UnitDestroyed ( un ) do begin if un = bur then
 188: LD_VAR 0 1
 192: PUSH
 193: LD_EXP 50
 197: EQUAL
 198: IFFALSE 207
// YouLost ( Burlak ) ;
 200: LD_STRING Burlak
 202: PPUSH
 203: CALL_OW 104
// enable ;
 207: ENABLE
// end ;
 208: PPOPN 1
 210: END
// on HumanDestroyed ( un , side , nat , x , y , dir , sex , cl ) do begin if ( side = You ) then
 211: LD_VAR 0 2
 215: PUSH
 216: LD_EXP 1
 220: EQUAL
 221: IFFALSE 231
// NoLosses := false ;
 223: LD_ADDR_EXP 7
 227: PUSH
 228: LD_INT 0
 230: ST_TO_ADDR
// end ;
 231: PPOPN 8
 233: END
// export function konec_mise_utok ; begin
 234: LD_INT 0
 236: PPUSH
// YouLost ( SelfAttack ) ;
 237: LD_STRING SelfAttack
 239: PPUSH
 240: CALL_OW 104
// end ;
 244: LD_VAR 0 1
 248: RET
// export function konec_mise ; var i , pom , pom1 ; var zivi ; var drv ; var a , b , c , d , e , f ; var budovy ; var material ; var bw ; var all_lidi ; var medal1 , medal2 , medal3 ; var lidi ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
 267: PPUSH
 268: PPUSH
 269: PPUSH
 270: PPUSH
// medal1 := false ;
 271: LD_ADDR_VAR 0 17
 275: PUSH
 276: LD_INT 0
 278: ST_TO_ADDR
// medal2 := false ;
 279: LD_ADDR_VAR 0 18
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// medal3 := false ;
 287: LD_ADDR_VAR 0 19
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// DisableExclamations ;
 295: CALL_OW 474
// gained_medals := [ ] ;
 299: LD_ADDR_OWVAR 61
 303: PUSH
 304: EMPTY
 305: ST_TO_ADDR
// missing_medals := [ ] ;
 306: LD_ADDR_OWVAR 62
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// zivi = 0 ;
 313: LD_ADDR_VAR 0 5
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// if NoLosses then
 321: LD_EXP 7
 325: IFFALSE 347
// begin medal1 := true ;
 327: LD_ADDR_VAR 0 17
 331: PUSH
 332: LD_INT 1
 334: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
 335: LD_STRING NoLosses
 337: PPUSH
 338: LD_INT 1
 340: PPUSH
 341: CALL_OW 101
// end else
 345: GO 358
// AddMedal ( NoLosses , - 1 ) ;
 347: LD_STRING NoLosses
 349: PPUSH
 350: LD_INT 1
 352: NEG
 353: PPUSH
 354: CALL_OW 101
// if BelkovFreed then
 358: LD_EXP 16
 362: IFFALSE 453
// if IsOK ( bel ) then
 364: LD_EXP 52
 368: PPUSH
 369: CALL_OW 302
 373: IFFALSE 395
// begin medal2 := true ;
 375: LD_ADDR_VAR 0 18
 379: PUSH
 380: LD_INT 1
 382: ST_TO_ADDR
// AddMedal ( Belkov , 1 ) ;
 383: LD_STRING Belkov
 385: PPUSH
 386: LD_INT 1
 388: PPUSH
 389: CALL_OW 101
// end else
 393: GO 451
// if UnitFilter ( BelkovComp , [ f_OK ] ) + 0 > 0 then
 395: LD_EXP 17
 399: PPUSH
 400: LD_INT 50
 402: PUSH
 403: EMPTY
 404: LIST
 405: PPUSH
 406: CALL_OW 72
 410: PUSH
 411: LD_INT 0
 413: PLUS
 414: PUSH
 415: LD_INT 0
 417: GREATER
 418: IFFALSE 440
// begin medal2 := true ;
 420: LD_ADDR_VAR 0 18
 424: PUSH
 425: LD_INT 1
 427: ST_TO_ADDR
// AddMedal ( Belkov , 2 ) ;
 428: LD_STRING Belkov
 430: PPUSH
 431: LD_INT 2
 433: PPUSH
 434: CALL_OW 101
// end else
 438: GO 451
// AddMedal ( Belkov , - 3 ) else
 440: LD_STRING Belkov
 442: PPUSH
 443: LD_INT 3
 445: NEG
 446: PPUSH
 447: CALL_OW 101
 451: GO 493
// if objBelkov and belkovSave = false then
 453: LD_EXP 28
 457: PUSH
 458: LD_EXP 10
 462: PUSH
 463: LD_INT 0
 465: EQUAL
 466: AND
 467: IFFALSE 482
// AddMedal ( Belkov , - 2 ) else
 469: LD_STRING Belkov
 471: PPUSH
 472: LD_INT 2
 474: NEG
 475: PPUSH
 476: CALL_OW 101
 480: GO 493
// AddMedal ( Belkov , - 1 ) ;
 482: LD_STRING Belkov
 484: PPUSH
 485: LD_INT 1
 487: NEG
 488: PPUSH
 489: CALL_OW 101
// case stav_utoku of 1 :
 493: LD_EXP 59
 497: PUSH
 498: LD_INT 1
 500: DOUBLE
 501: EQUAL
 502: IFTRUE 506
 504: GO 527
 506: POP
// begin medal3 := true ;
 507: LD_ADDR_VAR 0 19
 511: PUSH
 512: LD_INT 1
 514: ST_TO_ADDR
// AddMedal ( Initiative , 1 ) ;
 515: LD_STRING Initiative
 517: PPUSH
 518: LD_INT 1
 520: PPUSH
 521: CALL_OW 101
// end ; 2 :
 525: GO 590
 527: LD_INT 2
 529: DOUBLE
 530: EQUAL
 531: IFTRUE 535
 533: GO 549
 535: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
 536: LD_STRING Initiative
 538: PPUSH
 539: LD_INT 2
 541: NEG
 542: PPUSH
 543: CALL_OW 101
 547: GO 590
 549: LD_INT 3
 551: DOUBLE
 552: EQUAL
 553: IFTRUE 557
 555: GO 571
 557: POP
// AddMedal ( Initiative , - 1 ) ; else
 558: LD_STRING Initiative
 560: PPUSH
 561: LD_INT 1
 563: NEG
 564: PPUSH
 565: CALL_OW 101
 569: GO 590
 571: POP
// begin medal3 := true ;
 572: LD_ADDR_VAR 0 19
 576: PUSH
 577: LD_INT 1
 579: ST_TO_ADDR
// AddMedal ( Initiative , 1 ) ;
 580: LD_STRING Initiative
 582: PPUSH
 583: LD_INT 1
 585: PPUSH
 586: CALL_OW 101
// end ; end ; SA_EndMission ( 3 , 2 , medal1 , medal2 , medal3 ) ;
 590: LD_INT 3
 592: PPUSH
 593: LD_INT 2
 595: PPUSH
 596: LD_VAR 0 17
 600: PPUSH
 601: LD_VAR 0 18
 605: PPUSH
 606: LD_VAR 0 19
 610: PPUSH
 611: CALL 19883 0 5
// GiveMedals ( Main ) ;
 615: LD_STRING Main
 617: PPUSH
 618: CALL_OW 102
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_human ] ] ) ;
 622: LD_ADDR_VAR 0 3
 626: PUSH
 627: LD_INT 22
 629: PUSH
 630: LD_EXP 1
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 21
 641: PUSH
 642: LD_INT 1
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL_OW 69
 657: ST_TO_ADDR
// pom1 = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
 658: LD_ADDR_VAR 0 4
 662: PUSH
 663: LD_INT 22
 665: PUSH
 666: LD_EXP 1
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 21
 677: PUSH
 678: LD_INT 2
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: PUSH
 685: EMPTY
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL_OW 69
 693: ST_TO_ADDR
// for i in pom1 do
 694: LD_ADDR_VAR 0 2
 698: PUSH
 699: LD_VAR 0 4
 703: PUSH
 704: FOR_IN
 705: IFFALSE 764
// if IsDrivenBy ( i ) then
 707: LD_VAR 0 2
 711: PPUSH
 712: CALL_OW 311
 716: IFFALSE 762
// begin drv = IsDrivenBy ( i ) ;
 718: LD_ADDR_VAR 0 6
 722: PUSH
 723: LD_VAR 0 2
 727: PPUSH
 728: CALL_OW 311
 732: ST_TO_ADDR
// if not ( drv in pom ) then
 733: LD_VAR 0 6
 737: PUSH
 738: LD_VAR 0 3
 742: IN
 743: NOT
 744: IFFALSE 762
// pom = pom ^ drv ;
 746: LD_ADDR_VAR 0 3
 750: PUSH
 751: LD_VAR 0 3
 755: PUSH
 756: LD_VAR 0 6
 760: ADD
 761: ST_TO_ADDR
// end ;
 762: GO 704
 764: POP
 765: POP
// all_lidi = pom ;
 766: LD_ADDR_VAR 0 16
 770: PUSH
 771: LD_VAR 0 3
 775: ST_TO_ADDR
// RewardPeople ( all_lidi ) ;
 776: LD_VAR 0 16
 780: PPUSH
 781: CALL_OW 43
// SaveCharacters ( bur , Burlak ) ;
 785: LD_EXP 50
 789: PPUSH
 790: LD_STRING Burlak
 792: PPUSH
 793: CALL_OW 38
// SaveCharacters ( plat , Platonov ) ;
 797: LD_EXP 54
 801: PPUSH
 802: LD_STRING Platonov
 804: PPUSH
 805: CALL_OW 38
// SaveCharacters ( kurin , Kurin ) ;
 809: LD_EXP 53
 813: PPUSH
 814: LD_STRING Kurin
 816: PPUSH
 817: CALL_OW 38
// SaveCharacters ( bel , Belkov ) ;
 821: LD_EXP 52
 825: PPUSH
 826: LD_STRING Belkov
 828: PPUSH
 829: CALL_OW 38
// SaveCharacters ( gny , Gnyevko ) ;
 833: LD_EXP 49
 837: PPUSH
 838: LD_STRING Gnyevko
 840: PPUSH
 841: CALL_OW 38
// SaveCharacters ( kov , Kovalyuk ) ;
 845: LD_EXP 51
 849: PPUSH
 850: LD_STRING Kovalyuk
 852: PPUSH
 853: CALL_OW 38
// all_lidi = pom diff [ bur , plat , kurin , bel , gny , kov ] ;
 857: LD_ADDR_VAR 0 16
 861: PUSH
 862: LD_VAR 0 3
 866: PUSH
 867: LD_EXP 50
 871: PUSH
 872: LD_EXP 54
 876: PUSH
 877: LD_EXP 53
 881: PUSH
 882: LD_EXP 52
 886: PUSH
 887: LD_EXP 49
 891: PUSH
 892: LD_EXP 51
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: DIFF
 905: ST_TO_ADDR
// all_lidi = all_lidi union rusi_survivors ;
 906: LD_ADDR_VAR 0 16
 910: PUSH
 911: LD_VAR 0 16
 915: PUSH
 916: LD_EXP 58
 920: UNION
 921: ST_TO_ADDR
// SaveCharacters ( all_lidi , survivors1 ) ;
 922: LD_VAR 0 16
 926: PPUSH
 927: LD_STRING survivors1
 929: PPUSH
 930: CALL_OW 38
// if BelkovFreed then
 934: LD_EXP 16
 938: IFFALSE 952
// SaveVariable ( 1 , belkov_saved ) else
 940: LD_INT 1
 942: PPUSH
 943: LD_STRING belkov_saved
 945: PPUSH
 946: CALL_OW 39
 950: GO 962
// SaveVariable ( 0 , belkov_saved ) ;
 952: LD_INT 0
 954: PPUSH
 955: LD_STRING belkov_saved
 957: PPUSH
 958: CALL_OW 39
// case stav_utoku of 0 :
 962: LD_EXP 59
 966: PUSH
 967: LD_INT 0
 969: DOUBLE
 970: EQUAL
 971: IFTRUE 975
 973: GO 988
 975: POP
// SaveVariable ( 3 , utok_stav ) ; 1 :
 976: LD_INT 3
 978: PPUSH
 979: LD_STRING utok_stav
 981: PPUSH
 982: CALL_OW 39
 986: GO 1052
 988: LD_INT 1
 990: DOUBLE
 991: EQUAL
 992: IFTRUE 996
 994: GO 1009
 996: POP
// SaveVariable ( 1 , utok_stav ) ; 2 :
 997: LD_INT 1
 999: PPUSH
1000: LD_STRING utok_stav
1002: PPUSH
1003: CALL_OW 39
1007: GO 1052
1009: LD_INT 2
1011: DOUBLE
1012: EQUAL
1013: IFTRUE 1017
1015: GO 1030
1017: POP
// SaveVariable ( 2 , utok_stav ) ; 3 :
1018: LD_INT 2
1020: PPUSH
1021: LD_STRING utok_stav
1023: PPUSH
1024: CALL_OW 39
1028: GO 1052
1030: LD_INT 3
1032: DOUBLE
1033: EQUAL
1034: IFTRUE 1038
1036: GO 1051
1038: POP
// SaveVariable ( 3 , utok_stav ) ; end ;
1039: LD_INT 3
1041: PPUSH
1042: LD_STRING utok_stav
1044: PPUSH
1045: CALL_OW 39
1049: GO 1052
1051: POP
// budovy = [ ] ;
1052: LD_ADDR_VAR 0 13
1056: PUSH
1057: EMPTY
1058: ST_TO_ADDR
// bw = 0 ;
1059: LD_ADDR_VAR 0 15
1063: PUSH
1064: LD_INT 0
1066: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_building ] ] ) ;
1067: LD_ADDR_VAR 0 3
1071: PUSH
1072: LD_INT 22
1074: PUSH
1075: LD_EXP 1
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 21
1086: PUSH
1087: LD_INT 3
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: PPUSH
1098: CALL_OW 69
1102: ST_TO_ADDR
// for i in pom do
1103: LD_ADDR_VAR 0 2
1107: PUSH
1108: LD_VAR 0 3
1112: PUSH
1113: FOR_IN
1114: IFFALSE 1270
// begin a = GetBType ( i ) ;
1116: LD_ADDR_VAR 0 7
1120: PUSH
1121: LD_VAR 0 2
1125: PPUSH
1126: CALL_OW 266
1130: ST_TO_ADDR
// b = GetBLevel ( i ) ;
1131: LD_ADDR_VAR 0 8
1135: PUSH
1136: LD_VAR 0 2
1140: PPUSH
1141: CALL_OW 267
1145: ST_TO_ADDR
// c = GetX ( i ) ;
1146: LD_ADDR_VAR 0 9
1150: PUSH
1151: LD_VAR 0 2
1155: PPUSH
1156: CALL_OW 250
1160: ST_TO_ADDR
// d = GetY ( i ) ;
1161: LD_ADDR_VAR 0 10
1165: PUSH
1166: LD_VAR 0 2
1170: PPUSH
1171: CALL_OW 251
1175: ST_TO_ADDR
// e = GetDir ( i ) ;
1176: LD_ADDR_VAR 0 11
1180: PUSH
1181: LD_VAR 0 2
1185: PPUSH
1186: CALL_OW 254
1190: ST_TO_ADDR
// f = GetNation ( i ) ;
1191: LD_ADDR_VAR 0 12
1195: PUSH
1196: LD_VAR 0 2
1200: PPUSH
1201: CALL_OW 248
1205: ST_TO_ADDR
// pom1 = [ a , b , c , d , e , f ] ;
1206: LD_ADDR_VAR 0 4
1210: PUSH
1211: LD_VAR 0 7
1215: PUSH
1216: LD_VAR 0 8
1220: PUSH
1221: LD_VAR 0 9
1225: PUSH
1226: LD_VAR 0 10
1230: PUSH
1231: LD_VAR 0 11
1235: PUSH
1236: LD_VAR 0 12
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: ST_TO_ADDR
// budovy = budovy ^ [ pom1 ] ;
1249: LD_ADDR_VAR 0 13
1253: PUSH
1254: LD_VAR 0 13
1258: PUSH
1259: LD_VAR 0 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: ADD
1267: ST_TO_ADDR
// end ;
1268: GO 1113
1270: POP
1271: POP
// SaveVariable ( budovy , budovy ) ;
1272: LD_VAR 0 13
1276: PPUSH
1277: LD_STRING budovy
1279: PPUSH
1280: CALL_OW 39
// if isOK ( am_bre1 ) then
1284: LD_INT 30
1286: PPUSH
1287: CALL_OW 302
1291: IFFALSE 1307
// bw = bw + 1 ;
1293: LD_ADDR_VAR 0 15
1297: PUSH
1298: LD_VAR 0 15
1302: PUSH
1303: LD_INT 1
1305: PLUS
1306: ST_TO_ADDR
// if IsOK ( am_bre2 ) then
1307: LD_INT 31
1309: PPUSH
1310: CALL_OW 302
1314: IFFALSE 1330
// bw = bw + 2 ;
1316: LD_ADDR_VAR 0 15
1320: PUSH
1321: LD_VAR 0 15
1325: PUSH
1326: LD_INT 2
1328: PLUS
1329: ST_TO_ADDR
// SaveVariable ( bw , bw_east ) ;
1330: LD_VAR 0 15
1334: PPUSH
1335: LD_STRING bw_east
1337: PPUSH
1338: CALL_OW 39
// pom = [ ] ;
1342: LD_ADDR_VAR 0 3
1346: PUSH
1347: EMPTY
1348: ST_TO_ADDR
// if ISOK ( ABW1 ) then
1349: LD_EXP 76
1353: PPUSH
1354: CALL_OW 302
1358: IFFALSE 1376
// pom = pom ^ ABW1 ;
1360: LD_ADDR_VAR 0 3
1364: PUSH
1365: LD_VAR 0 3
1369: PUSH
1370: LD_EXP 76
1374: ADD
1375: ST_TO_ADDR
// if ISOK ( ABW2 ) then
1376: LD_EXP 77
1380: PPUSH
1381: CALL_OW 302
1385: IFFALSE 1403
// pom = pom ^ ABW2 ;
1387: LD_ADDR_VAR 0 3
1391: PUSH
1392: LD_VAR 0 3
1396: PUSH
1397: LD_EXP 77
1401: ADD
1402: ST_TO_ADDR
// SaveCharacters ( pom , amici_bw ) ;
1403: LD_VAR 0 3
1407: PPUSH
1408: LD_STRING amici_bw
1410: PPUSH
1411: CALL_OW 38
// YouWin ;
1415: CALL_OW 103
// EnableExclamations ;
1419: CALL_OW 473
// exit ;
1423: GO 1425
// end ;
1425: LD_VAR 0 1
1429: RET
// function load_postav ; begin
1430: LD_INT 0
1432: PPUSH
// kurin = NewCharacter ( kurin ) ;
1433: LD_ADDR_EXP 53
1437: PUSH
1438: LD_STRING kurin
1440: PPUSH
1441: CALL_OW 25
1445: ST_TO_ADDR
// if CheckCharacterSet ( Belkov ) then
1446: LD_STRING Belkov
1448: PPUSH
1449: CALL_OW 29
1453: IFFALSE 1465
// BELKOV_MRTVY = false else
1455: LD_ADDR_EXP 46
1459: PUSH
1460: LD_INT 0
1462: ST_TO_ADDR
1463: GO 1473
// BELKOV_MRTVY = true ;
1465: LD_ADDR_EXP 46
1469: PUSH
1470: LD_INT 1
1472: ST_TO_ADDR
// if BELKOV_MRTVY then
1473: LD_EXP 46
1477: IFFALSE 1494
// begin bel = NewCharacter ( Belkov2 ) ;
1479: LD_ADDR_EXP 52
1483: PUSH
1484: LD_STRING Belkov2
1486: PPUSH
1487: CALL_OW 25
1491: ST_TO_ADDR
// end else
1492: GO 1507
// bel = nacti_osobu ( Belkov ) ;
1494: LD_ADDR_EXP 52
1498: PUSH
1499: LD_STRING Belkov
1501: PPUSH
1502: CALL 5017 0 1
1506: ST_TO_ADDR
// kov = NewCharacter ( Kovalyuk ) ;
1507: LD_ADDR_EXP 51
1511: PUSH
1512: LD_STRING Kovalyuk
1514: PPUSH
1515: CALL_OW 25
1519: ST_TO_ADDR
// bur = nacti_osobu ( Burlak ) ;
1520: LD_ADDR_EXP 50
1524: PUSH
1525: LD_STRING Burlak
1527: PPUSH
1528: CALL 5017 0 1
1532: ST_TO_ADDR
// gny = nacti_osobu ( Gnyevko ) ;
1533: LD_ADDR_EXP 49
1537: PUSH
1538: LD_STRING Gnyevko
1540: PPUSH
1541: CALL 5017 0 1
1545: ST_TO_ADDR
// plat = NewCharacter ( Platonov ) ;
1546: LD_ADDR_EXP 54
1550: PUSH
1551: LD_STRING Platonov
1553: PPUSH
1554: CALL_OW 25
1558: ST_TO_ADDR
// DoNotAttack ( 1 , plat ) ;
1559: LD_INT 1
1561: PPUSH
1562: LD_EXP 54
1566: PPUSH
1567: CALL_OW 471
// DoNotAttack ( 4 , plat ) ;
1571: LD_INT 4
1573: PPUSH
1574: LD_EXP 54
1578: PPUSH
1579: CALL_OW 471
// end ; end_of_file
1583: LD_VAR 0 1
1587: RET
// export CarCount , WBW , EBW , BurlakComp , BurlakOut , BelkovFreed , BelkovComp , WBWSpotted , WBWAttacked , WBWDestroyed , WBWReported , EBWSpotted , EBWDestroyed , EBWReported , Charted , QAttAm , objAttack , objBelkov , objReturn , Reinforcements , InWest , BeriaVisited , CanReturn , playing , d19a , McCestaNaSever ; export function InitVars ; begin
1588: LD_INT 0
1590: PPUSH
// CarCount = 0 ;
1591: LD_ADDR_EXP 11
1595: PUSH
1596: LD_INT 0
1598: ST_TO_ADDR
// WBWSpotted := false ;
1599: LD_ADDR_EXP 18
1603: PUSH
1604: LD_INT 0
1606: ST_TO_ADDR
// WBWAttacked := false ;
1607: LD_ADDR_EXP 19
1611: PUSH
1612: LD_INT 0
1614: ST_TO_ADDR
// WBWDestroyed := false ;
1615: LD_ADDR_EXP 20
1619: PUSH
1620: LD_INT 0
1622: ST_TO_ADDR
// WBWReported := false ;
1623: LD_ADDR_EXP 21
1627: PUSH
1628: LD_INT 0
1630: ST_TO_ADDR
// EBWSpotted := false ;
1631: LD_ADDR_EXP 22
1635: PUSH
1636: LD_INT 0
1638: ST_TO_ADDR
// EBWDestroyed := false ;
1639: LD_ADDR_EXP 23
1643: PUSH
1644: LD_INT 0
1646: ST_TO_ADDR
// EBWReported := false ;
1647: LD_ADDR_EXP 24
1651: PUSH
1652: LD_INT 0
1654: ST_TO_ADDR
// BelkovFreed := false ;
1655: LD_ADDR_EXP 16
1659: PUSH
1660: LD_INT 0
1662: ST_TO_ADDR
// BelkovComp := [ ] ;
1663: LD_ADDR_EXP 17
1667: PUSH
1668: EMPTY
1669: ST_TO_ADDR
// QAttAm := false ;
1670: LD_ADDR_EXP 26
1674: PUSH
1675: LD_INT 0
1677: ST_TO_ADDR
// d19a := false ;
1678: LD_ADDR_EXP 35
1682: PUSH
1683: LD_INT 0
1685: ST_TO_ADDR
// objAttack := false ;
1686: LD_ADDR_EXP 27
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
// Reinforcements := false ;
1694: LD_ADDR_EXP 30
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// Charted := false ;
1702: LD_ADDR_EXP 25
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// objBelkov := false ;
1710: LD_ADDR_EXP 28
1714: PUSH
1715: LD_INT 0
1717: ST_TO_ADDR
// objReturn := false ;
1718: LD_ADDR_EXP 29
1722: PUSH
1723: LD_INT 0
1725: ST_TO_ADDR
// BeriaVisited := false ;
1726: LD_ADDR_EXP 32
1730: PUSH
1731: LD_INT 0
1733: ST_TO_ADDR
// InWest := false ;
1734: LD_ADDR_EXP 31
1738: PUSH
1739: LD_INT 0
1741: ST_TO_ADDR
// playing := false ;
1742: LD_ADDR_EXP 34
1746: PUSH
1747: LD_INT 0
1749: ST_TO_ADDR
// EBW := [ Am_bre1 , Am_bre2 ] ;
1750: LD_ADDR_EXP 13
1754: PUSH
1755: LD_INT 30
1757: PUSH
1758: LD_INT 31
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: ST_TO_ADDR
// BurlakOut := [ ] ;
1765: LD_ADDR_EXP 15
1769: PUSH
1770: EMPTY
1771: ST_TO_ADDR
// CanReturn := false ;
1772: LD_ADDR_EXP 33
1776: PUSH
1777: LD_INT 0
1779: ST_TO_ADDR
// McCestaNaSever := 0 ;
1780: LD_ADDR_EXP 36
1784: PUSH
1785: LD_INT 0
1787: ST_TO_ADDR
// disable ( 99 ) ;
1788: LD_INT 99
1790: DISABLE_MARKED
// disable ( 100 ) ;
1791: LD_INT 100
1793: DISABLE_MARKED
// disable ( 101 ) ;
1794: LD_INT 101
1796: DISABLE_MARKED
// disable ( 300 ) ;
1797: LD_INT 300
1799: DISABLE_MARKED
// disable ( 301 ) ;
1800: LD_INT 301
1802: DISABLE_MARKED
// disable ( 302 ) ;
1803: LD_INT 302
1805: DISABLE_MARKED
// end ;
1806: LD_VAR 0 1
1810: RET
// function ListAttacks ( who , whom ) ; var i ; begin
1811: LD_INT 0
1813: PPUSH
1814: PPUSH
// result := false ;
1815: LD_ADDR_VAR 0 3
1819: PUSH
1820: LD_INT 0
1822: ST_TO_ADDR
// for i in who do
1823: LD_ADDR_VAR 0 4
1827: PUSH
1828: LD_VAR 0 1
1832: PUSH
1833: FOR_IN
1834: IFFALSE 1865
// begin if Attacks ( i ) in whom then
1836: LD_VAR 0 4
1840: PPUSH
1841: CALL_OW 320
1845: PUSH
1846: LD_VAR 0 2
1850: IN
1851: IFFALSE 1863
// begin result := true ;
1853: LD_ADDR_VAR 0 3
1857: PUSH
1858: LD_INT 1
1860: ST_TO_ADDR
// break end ;
1861: GO 1865
// end ;
1863: GO 1833
1865: POP
1866: POP
// end ;
1867: LD_VAR 0 3
1871: RET
// function ListSee ( side , who ) ; var i ; begin
1872: LD_INT 0
1874: PPUSH
1875: PPUSH
// result := false ;
1876: LD_ADDR_VAR 0 3
1880: PUSH
1881: LD_INT 0
1883: ST_TO_ADDR
// for i in who do
1884: LD_ADDR_VAR 0 4
1888: PUSH
1889: LD_VAR 0 2
1893: PUSH
1894: FOR_IN
1895: IFFALSE 1925
// begin if see ( side , i ) then
1897: LD_VAR 0 1
1901: PPUSH
1902: LD_VAR 0 4
1906: PPUSH
1907: CALL_OW 292
1911: IFFALSE 1923
// begin result := true ;
1913: LD_ADDR_VAR 0 3
1917: PUSH
1918: LD_INT 1
1920: ST_TO_ADDR
// break ;
1921: GO 1925
// end ; end ;
1923: GO 1894
1925: POP
1926: POP
// end ;
1927: LD_VAR 0 3
1931: RET
// function BurlakInArea ( area ) ; var i , pom , hum ; begin
1932: LD_INT 0
1934: PPUSH
1935: PPUSH
1936: PPUSH
1937: PPUSH
// hum := [ ] ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: EMPTY
1944: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , you ] , [ f_ready ] ] ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 1
1954: PPUSH
1955: LD_INT 22
1957: PUSH
1958: LD_EXP 1
1962: PUSH
1963: EMPTY
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 53
1969: PUSH
1970: EMPTY
1971: LIST
1972: PUSH
1973: EMPTY
1974: LIST
1975: LIST
1976: PPUSH
1977: CALL_OW 70
1981: ST_TO_ADDR
// for i in pom do
1982: LD_ADDR_VAR 0 3
1986: PUSH
1987: LD_VAR 0 4
1991: PUSH
1992: FOR_IN
1993: IFFALSE 2079
// begin if GetType ( i ) = unit_human then
1995: LD_VAR 0 3
1999: PPUSH
2000: CALL_OW 247
2004: PUSH
2005: LD_INT 1
2007: EQUAL
2008: IFFALSE 2026
// begin hum := hum ^ i ;
2010: LD_ADDR_VAR 0 5
2014: PUSH
2015: LD_VAR 0 5
2019: PUSH
2020: LD_VAR 0 3
2024: ADD
2025: ST_TO_ADDR
// end ; if ( GetType ( i ) = unit_building ) or ( GetType ( i ) = unit_vehicle ) then
2026: LD_VAR 0 3
2030: PPUSH
2031: CALL_OW 247
2035: PUSH
2036: LD_INT 3
2038: EQUAL
2039: PUSH
2040: LD_VAR 0 3
2044: PPUSH
2045: CALL_OW 247
2049: PUSH
2050: LD_INT 2
2052: EQUAL
2053: OR
2054: IFFALSE 2077
// begin hum := hum union UnitsInside ( i ) ;
2056: LD_ADDR_VAR 0 5
2060: PUSH
2061: LD_VAR 0 5
2065: PUSH
2066: LD_VAR 0 3
2070: PPUSH
2071: CALL_OW 313
2075: UNION
2076: ST_TO_ADDR
// end ; end ;
2077: GO 1992
2079: POP
2080: POP
// if ( hum isect BurlakOut ) > 0 then
2081: LD_VAR 0 5
2085: PUSH
2086: LD_EXP 15
2090: ISECT
2091: PUSH
2092: LD_INT 0
2094: GREATER
2095: IFFALSE 2107
// result := true else
2097: LD_ADDR_VAR 0 2
2101: PUSH
2102: LD_INT 1
2104: ST_TO_ADDR
2105: GO 2115
// result := false ;
2107: LD_ADDR_VAR 0 2
2111: PUSH
2112: LD_INT 0
2114: ST_TO_ADDR
// end ;
2115: LD_VAR 0 2
2119: RET
// export function MissionProper ; begin
2120: LD_INT 0
2122: PPUSH
// enable ( 99 ) ;
2123: LD_INT 99
2125: ENABLE_MARKED
// enable ( 100 ) ;
2126: LD_INT 100
2128: ENABLE_MARKED
// CanReturn := false ;
2129: LD_ADDR_EXP 33
2133: PUSH
2134: LD_INT 0
2136: ST_TO_ADDR
// end ;
2137: LD_VAR 0 1
2141: RET
// function ShouldReturn ; begin
2142: LD_INT 0
2144: PPUSH
// if Charted and ( BelkovFreed or ( not objBelkov ) ) and ( WBWDestroyed or ( not objAttack ) ) and ( not objReturn ) then
2145: LD_EXP 25
2149: PUSH
2150: LD_EXP 16
2154: PUSH
2155: LD_EXP 28
2159: NOT
2160: OR
2161: AND
2162: PUSH
2163: LD_EXP 20
2167: PUSH
2168: LD_EXP 27
2172: NOT
2173: OR
2174: AND
2175: PUSH
2176: LD_EXP 29
2180: NOT
2181: AND
2182: IFFALSE 2199
// begin ChangeMissionObjectives ( M10a ) ;
2184: LD_STRING M10a
2186: PPUSH
2187: CALL_OW 337
// objReturn := true ;
2191: LD_ADDR_EXP 29
2195: PUSH
2196: LD_INT 1
2198: ST_TO_ADDR
// end ; end ;
2199: LD_VAR 0 1
2203: RET
// on VehicleConstructed ( veh , fact ) do begin CarCount := CarCount + 1 ;
2204: LD_ADDR_EXP 11
2208: PUSH
2209: LD_EXP 11
2213: PUSH
2214: LD_INT 1
2216: PLUS
2217: ST_TO_ADDR
// if CarCount = 1 then
2218: LD_EXP 11
2222: PUSH
2223: LD_INT 1
2225: EQUAL
2226: IFFALSE 2231
// enable ( 300 ) ;
2228: LD_INT 300
2230: ENABLE_MARKED
// if CarCount = UnitFilter ( Rusi_enter , [ f_OK ] ) and not belkov_returns then
2231: LD_EXP 11
2235: PUSH
2236: LD_EXP 55
2240: PPUSH
2241: LD_INT 50
2243: PUSH
2244: EMPTY
2245: LIST
2246: PPUSH
2247: CALL_OW 72
2251: EQUAL
2252: PUSH
2253: LD_EXP 8
2257: NOT
2258: AND
2259: IFFALSE 2269
// belkov_returns = true ;
2261: LD_ADDR_EXP 8
2265: PUSH
2266: LD_INT 1
2268: ST_TO_ADDR
// if CarCount = UnitFilter ( Rusi_enter , [ f_OK ] ) + 1 and not belkov_american_clash then
2269: LD_EXP 11
2273: PUSH
2274: LD_EXP 55
2278: PPUSH
2279: LD_INT 50
2281: PUSH
2282: EMPTY
2283: LIST
2284: PPUSH
2285: CALL_OW 72
2289: PUSH
2290: LD_INT 1
2292: PLUS
2293: EQUAL
2294: PUSH
2295: LD_EXP 9
2299: NOT
2300: AND
2301: IFFALSE 2311
// belkov_american_clash = true ;
2303: LD_ADDR_EXP 9
2307: PUSH
2308: LD_INT 1
2310: ST_TO_ADDR
// end ;
2311: PPOPN 2
2313: END
// every 0 0$1 trigger belkov_american_clash do
2314: LD_EXP 9
2318: IFFALSE 2335
2320: GO 2322
2322: DISABLE
// begin rozhovor_ukonceni_m5 ;
2323: CALL 8592 0 0
// stav = 7 ;
2327: LD_ADDR_EXP 60
2331: PUSH
2332: LD_INT 7
2334: ST_TO_ADDR
// end ;
2335: END
// every 0 0$5 trigger ( ListSee ( you , WBW ) or ListAttacks ( WBW , BurlakOut ) ) and ( not WBWDestroyed ) do
2336: LD_EXP 1
2340: PPUSH
2341: LD_EXP 12
2345: PPUSH
2346: CALL 1872 0 2
2350: PUSH
2351: LD_EXP 12
2355: PPUSH
2356: LD_EXP 15
2360: PPUSH
2361: CALL 1811 0 2
2365: OR
2366: PUSH
2367: LD_EXP 20
2371: NOT
2372: AND
2373: IFFALSE 2627
2375: GO 2377
2377: DISABLE
// begin if BurlakInArea ( kopec ) then
2378: LD_INT 26
2380: PPUSH
2381: CALL 1932 0 1
2385: IFFALSE 2395
// begin InWest := true ;
2387: LD_ADDR_EXP 31
2391: PUSH
2392: LD_INT 1
2394: ST_TO_ADDR
// end ; if not WBWSpotted then
2395: LD_EXP 18
2399: NOT
2400: IFFALSE 2406
// begin play_dialog_15 ;
2402: CALL 10880 0 0
// end ; WBWSpotted := true ;
2406: LD_ADDR_EXP 18
2410: PUSH
2411: LD_INT 1
2413: ST_TO_ADDR
// if InWest and ( not QAttAm ) and ( not objAttack ) then
2414: LD_EXP 31
2418: PUSH
2419: LD_EXP 26
2423: NOT
2424: AND
2425: PUSH
2426: LD_EXP 27
2430: NOT
2431: AND
2432: IFFALSE 2551
// begin case query ( QAttackBw ) of 1 :
2434: LD_STRING QAttackBw
2436: PPUSH
2437: CALL_OW 97
2441: PUSH
2442: LD_INT 1
2444: DOUBLE
2445: EQUAL
2446: IFTRUE 2450
2448: GO 2465
2450: POP
// begin play_dialog_qwbw1 ;
2451: CALL 11085 0 0
// stav_utoku := 1 ;
2455: LD_ADDR_EXP 59
2459: PUSH
2460: LD_INT 1
2462: ST_TO_ADDR
// end ; 2 :
2463: GO 2524
2465: LD_INT 2
2467: DOUBLE
2468: EQUAL
2469: IFTRUE 2473
2471: GO 2504
2473: POP
// begin play_dialog_qwbw2 ;
2474: CALL 11172 0 0
// posily_go := true ;
2478: LD_ADDR_EXP 68
2482: PUSH
2483: LD_INT 1
2485: ST_TO_ADDR
// Reinforcements := true ;
2486: LD_ADDR_EXP 30
2490: PUSH
2491: LD_INT 1
2493: ST_TO_ADDR
// stav_utoku := 2 ;
2494: LD_ADDR_EXP 59
2498: PUSH
2499: LD_INT 2
2501: ST_TO_ADDR
// end ; 3 :
2502: GO 2524
2504: LD_INT 3
2506: DOUBLE
2507: EQUAL
2508: IFTRUE 2512
2510: GO 2523
2512: POP
// begin stav_utoku := 3 end ; end ;
2513: LD_ADDR_EXP 59
2517: PUSH
2518: LD_INT 3
2520: ST_TO_ADDR
2521: GO 2524
2523: POP
// ChangeMissionObjectives ( M7 ) ;
2524: LD_STRING M7
2526: PPUSH
2527: CALL_OW 337
// objAttack := true ;
2531: LD_ADDR_EXP 27
2535: PUSH
2536: LD_INT 1
2538: ST_TO_ADDR
// play_dialog_19 ;
2539: CALL 11259 0 0
// WBWAttacked := true ;
2543: LD_ADDR_EXP 19
2547: PUSH
2548: LD_INT 1
2550: ST_TO_ADDR
// end ; if ( not InWest ) and ListAttacks ( BurlakOut , WBW ) and ( not d19a ) then
2551: LD_EXP 31
2555: NOT
2556: PUSH
2557: LD_EXP 15
2561: PPUSH
2562: LD_EXP 12
2566: PPUSH
2567: CALL 1811 0 2
2571: AND
2572: PUSH
2573: LD_EXP 35
2577: NOT
2578: AND
2579: IFFALSE 2616
// begin wait ( 0 0$5 ) ;
2581: LD_INT 175
2583: PPUSH
2584: CALL_OW 67
// if ListAttacks ( BurlakOut , WBW ) then
2588: LD_EXP 15
2592: PPUSH
2593: LD_EXP 12
2597: PPUSH
2598: CALL 1811 0 2
2602: IFFALSE 2616
// begin play_dialog_19a ;
2604: CALL 11370 0 0
// d19a := true ;
2608: LD_ADDR_EXP 35
2612: PUSH
2613: LD_INT 1
2615: ST_TO_ADDR
// end ; end ; if ( not InWest ) then
2616: LD_EXP 31
2620: NOT
2621: IFFALSE 2626
// enable else
2623: ENABLE
2624: GO 2627
// disable ;
2626: DISABLE
// end ;
2627: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_OK ] , [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) do var pom ;
2628: LD_INT 9
2630: PPUSH
2631: LD_INT 50
2633: PUSH
2634: EMPTY
2635: LIST
2636: PUSH
2637: LD_INT 22
2639: PUSH
2640: LD_EXP 2
2644: PUSH
2645: EMPTY
2646: LIST
2647: LIST
2648: PUSH
2649: LD_INT 30
2651: PUSH
2652: LD_INT 31
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: LIST
2663: PPUSH
2664: CALL_OW 70
2668: IFFALSE 2803
2670: GO 2672
2672: DISABLE
2673: LD_INT 0
2675: PPUSH
// begin pom := FilterUnitsInArea ( Am_base , [ [ f_OK ] , [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
2676: LD_ADDR_VAR 0 1
2680: PUSH
2681: LD_INT 9
2683: PPUSH
2684: LD_INT 50
2686: PUSH
2687: EMPTY
2688: LIST
2689: PUSH
2690: LD_INT 22
2692: PUSH
2693: LD_EXP 2
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: PUSH
2702: LD_INT 30
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: LIST
2716: PPUSH
2717: CALL_OW 70
2721: ST_TO_ADDR
// BWW_1 = pom [ 1 ] ;
2722: LD_ADDR_EXP 74
2726: PUSH
2727: LD_VAR 0 1
2731: PUSH
2732: LD_INT 1
2734: ARRAY
2735: ST_TO_ADDR
// enable ( 101 ) ;
2736: LD_INT 101
2738: ENABLE_MARKED
// WBW := [ BWW_1 ] ;
2739: LD_ADDR_EXP 12
2743: PUSH
2744: LD_EXP 74
2748: PUSH
2749: EMPTY
2750: LIST
2751: ST_TO_ADDR
// if pom + 0 > 1 then
2752: LD_VAR 0 1
2756: PUSH
2757: LD_INT 0
2759: PLUS
2760: PUSH
2761: LD_INT 1
2763: GREATER
2764: IFFALSE 2802
// begin BWW_2 := pom [ 2 ] ;
2766: LD_ADDR_EXP 75
2770: PUSH
2771: LD_VAR 0 1
2775: PUSH
2776: LD_INT 2
2778: ARRAY
2779: ST_TO_ADDR
// WBW := WBW ^ [ BWW_2 ] ;
2780: LD_ADDR_EXP 12
2784: PUSH
2785: LD_EXP 12
2789: PUSH
2790: LD_EXP 75
2794: PUSH
2795: EMPTY
2796: LIST
2797: ADD
2798: ST_TO_ADDR
// disable ;
2799: DISABLE
// end else
2800: GO 2803
// begin enable ;
2802: ENABLE
// end ; end ;
2803: PPOPN 1
2805: END
// every 0 0$3 trigger ( UnitFilter ( WBW , [ [ f_OK ] , [ f_side , amici ] ] ) = 0 ) marked 101 do
2806: LD_EXP 12
2810: PPUSH
2811: LD_INT 50
2813: PUSH
2814: EMPTY
2815: LIST
2816: PUSH
2817: LD_INT 22
2819: PUSH
2820: LD_EXP 2
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: PPUSH
2833: CALL_OW 72
2837: PUSH
2838: LD_INT 0
2840: EQUAL
2841: IFFALSE 2876
2843: GO 2845
2845: DISABLE
// begin play_dialog_20 ;
2846: CALL 11602 0 0
// WBWDestroyed := true ;
2850: LD_ADDR_EXP 20
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// if objAttack then
2858: LD_EXP 27
2862: IFFALSE 2871
// ChangeMissionObjectives ( M8 ) ;
2864: LD_STRING M8
2866: PPUSH
2867: CALL_OW 337
// ShouldReturn ;
2871: CALL 2142 0 0
// disable end ;
2875: DISABLE
2876: END
// every 0 0$5 trigger ListSee ( you , EBW ) or ListAttacks ( EBW , BurlakOut ) do var pom ;
2877: LD_EXP 1
2881: PPUSH
2882: LD_EXP 13
2886: PPUSH
2887: CALL 1872 0 2
2891: PUSH
2892: LD_EXP 13
2896: PPUSH
2897: LD_EXP 15
2901: PPUSH
2902: CALL 1811 0 2
2906: OR
2907: IFFALSE 2928
2909: GO 2911
2911: DISABLE
2912: LD_INT 0
2914: PPUSH
// begin play_dialog_16 ;
2915: CALL 11457 0 0
// EBWSpotted := true ;
2919: LD_ADDR_EXP 22
2923: PUSH
2924: LD_INT 1
2926: ST_TO_ADDR
// disable ;
2927: DISABLE
// end ;
2928: PPOPN 1
2930: END
// every 0 0$3 trigger ( UnitFilter ( EBW , [ f_OK ] ) = 0 ) do
2931: LD_EXP 13
2935: PPUSH
2936: LD_INT 50
2938: PUSH
2939: EMPTY
2940: LIST
2941: PPUSH
2942: CALL_OW 72
2946: PUSH
2947: LD_INT 0
2949: EQUAL
2950: IFFALSE 2968
2952: GO 2954
2954: DISABLE
// begin play_dialog_20a ;
2955: CALL 11665 0 0
// EBWDestroyed := true ;
2959: LD_ADDR_EXP 23
2963: PUSH
2964: LD_INT 1
2966: ST_TO_ADDR
// disable end ;
2967: DISABLE
2968: END
// every 0 0$5 trigger ( BurlakInArea ( Test4 ) ) do
2969: LD_INT 12
2971: PPUSH
2972: CALL 1932 0 1
2976: IFFALSE 3074
2978: GO 2980
2980: DISABLE
// begin if ( not objBelkov ) and ( IsOK ( Bel ) ) then
2981: LD_EXP 28
2985: NOT
2986: PUSH
2987: LD_EXP 52
2991: PPUSH
2992: CALL_OW 302
2996: AND
2997: IFFALSE 3065
// begin objBelkov := true ;
2999: LD_ADDR_EXP 28
3003: PUSH
3004: LD_INT 1
3006: ST_TO_ADDR
// case query ( QAttackAm ) of 1 :
3007: LD_STRING QAttackAm
3009: PPUSH
3010: CALL_OW 97
3014: PUSH
3015: LD_INT 1
3017: DOUBLE
3018: EQUAL
3019: IFTRUE 3023
3021: GO 3030
3023: POP
// play_dialog_qAtAm1 ; 2 :
3024: CALL 11728 0 0
3028: GO 3054
3030: LD_INT 2
3032: DOUBLE
3033: EQUAL
3034: IFTRUE 3038
3036: GO 3053
3038: POP
// begin play_dialog_qAtAm2 ;
3039: CALL 11791 0 0
// posily_go = true ;
3043: LD_ADDR_EXP 68
3047: PUSH
3048: LD_INT 1
3050: ST_TO_ADDR
// end ; end ;
3051: GO 3054
3053: POP
// ChangeMissionObjectives ( M9 ) ;
3054: LD_STRING M9
3056: PPUSH
3057: CALL_OW 337
// play_dialog_23 ;
3061: CALL 11907 0 0
// end ; QAttAm := true ;
3065: LD_ADDR_EXP 26
3069: PUSH
3070: LD_INT 1
3072: ST_TO_ADDR
// disable end ;
3073: DISABLE
3074: END
// every 0 0$5 trigger ( BurlakInArea ( belkov_kop ) ) do var i ;
3075: LD_INT 25
3077: PPUSH
3078: CALL 1932 0 1
3082: IFFALSE 3231
3084: GO 3086
3086: DISABLE
3087: LD_INT 0
3089: PPUSH
// begin if ( not objBelkov ) then
3090: LD_EXP 28
3094: NOT
3095: IFFALSE 3099
// exit ;
3097: GO 3231
// play_dialog_24 ;
3099: CALL 11981 0 0
// BelkovFreed := true ;
3103: LD_ADDR_EXP 16
3107: PUSH
3108: LD_INT 1
3110: ST_TO_ADDR
// if objBelkov then
3111: LD_EXP 28
3115: IFFALSE 3124
// ChangeMissionObjectives ( M9a ) ;
3117: LD_STRING M9a
3119: PPUSH
3120: CALL_OW 337
// if ( WBWSpotted ) and ( not WBWDestroyed ) and ( not objAttack ) then
3124: LD_EXP 18
3128: PUSH
3129: LD_EXP 20
3133: NOT
3134: AND
3135: PUSH
3136: LD_EXP 27
3140: NOT
3141: AND
3142: IFFALSE 3167
// begin ChangeMissionObjectives ( M7 ) ;
3144: LD_STRING M7
3146: PPUSH
3147: CALL_OW 337
// objAttack := true ;
3151: LD_ADDR_EXP 27
3155: PUSH
3156: LD_INT 1
3158: ST_TO_ADDR
// stav_utoku := 1 ;
3159: LD_ADDR_EXP 59
3163: PUSH
3164: LD_INT 1
3166: ST_TO_ADDR
// end ; BelkovComp = FilterUnitsInArea ( Belkov_kop_prebarvi , [ [ f_side , You2 ] ] ) ;
3167: LD_ADDR_EXP 17
3171: PUSH
3172: LD_INT 31
3174: PPUSH
3175: LD_INT 22
3177: PUSH
3178: LD_EXP 4
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: EMPTY
3188: LIST
3189: PPUSH
3190: CALL_OW 70
3194: ST_TO_ADDR
// for i in BelkovComp do
3195: LD_ADDR_VAR 0 1
3199: PUSH
3200: LD_EXP 17
3204: PUSH
3205: FOR_IN
3206: IFFALSE 3224
// SetSide ( i , You ) ;
3208: LD_VAR 0 1
3212: PPUSH
3213: LD_EXP 1
3217: PPUSH
3218: CALL_OW 235
3222: GO 3205
3224: POP
3225: POP
// ShouldReturn ;
3226: CALL 2142 0 0
// disable end ;
3230: DISABLE
3231: PPOPN 1
3233: END
// every 0 0$10 do var pom ;
3234: GO 3236
3236: DISABLE
3237: LD_INT 0
3239: PPUSH
// begin pom = SeeGreyArea ( You , Narea ) ;
3240: LD_ADDR_VAR 0 1
3244: PUSH
3245: LD_EXP 1
3249: PPUSH
3250: LD_INT 24
3252: PPUSH
3253: CALL_OW 452
3257: ST_TO_ADDR
// if pom >= procento_odkrytych_pro_vyhru [ difficulty ] then
3258: LD_VAR 0 1
3262: PUSH
3263: LD_EXP 42
3267: PUSH
3268: LD_OWVAR 67
3272: ARRAY
3273: GREATEREQUAL
3274: IFFALSE 3297
// begin ChangeMissionObjectives ( M10 ) ;
3276: LD_STRING M10
3278: PPUSH
3279: CALL_OW 337
// Charted := true ;
3283: LD_ADDR_EXP 25
3287: PUSH
3288: LD_INT 1
3290: ST_TO_ADDR
// ShouldReturn ;
3291: CALL 2142 0 0
// end else
3295: GO 3298
// enable ;
3297: ENABLE
// end ;
3298: PPOPN 1
3300: END
// every 0 0$5 trigger ( not BurlakInArea ( RU2_base ) ) marked 99 do var i ;
3301: LD_INT 1
3303: PPUSH
3304: CALL 1932 0 1
3308: NOT
3309: IFFALSE 3429
3311: GO 3313
3313: DISABLE
3314: LD_INT 0
3316: PPUSH
// begin BurlakComp := UnitFilter ( BurlakComp , [ f_alive ] ) ;
3317: LD_ADDR_EXP 14
3321: PUSH
3322: LD_EXP 14
3326: PPUSH
3327: LD_INT 51
3329: PUSH
3330: EMPTY
3331: LIST
3332: PPUSH
3333: CALL_OW 72
3337: ST_TO_ADDR
// BurlakOut := [ ] ;
3338: LD_ADDR_EXP 15
3342: PUSH
3343: EMPTY
3344: ST_TO_ADDR
// for i in BurlakComp do
3345: LD_ADDR_VAR 0 1
3349: PUSH
3350: LD_EXP 14
3354: PUSH
3355: FOR_IN
3356: IFFALSE 3394
// begin if ( not IsInArea ( i , Ru2_base ) ) then
3358: LD_VAR 0 1
3362: PPUSH
3363: LD_INT 1
3365: PPUSH
3366: CALL_OW 308
3370: NOT
3371: IFFALSE 3392
// BurlakOut := BurlakOut ^ [ i ] ;
3373: LD_ADDR_EXP 15
3377: PUSH
3378: LD_EXP 15
3382: PUSH
3383: LD_VAR 0 1
3387: PUSH
3388: EMPTY
3389: LIST
3390: ADD
3391: ST_TO_ADDR
// end ;
3392: GO 3355
3394: POP
3395: POP
// if BurlakOut + 0 > 0 then
3396: LD_EXP 15
3400: PUSH
3401: LD_INT 0
3403: PLUS
3404: PUSH
3405: LD_INT 0
3407: GREATER
3408: IFFALSE 3420
// CanReturn := true else
3410: LD_ADDR_EXP 33
3414: PUSH
3415: LD_INT 1
3417: ST_TO_ADDR
3418: GO 3428
// CanReturn := false ;
3420: LD_ADDR_EXP 33
3424: PUSH
3425: LD_INT 0
3427: ST_TO_ADDR
// enable ;
3428: ENABLE
// end ;
3429: PPOPN 1
3431: END
// every 0 0$5 trigger ( BurlakInArea ( RU2_base ) ) marked 100 do var i ;
3432: LD_INT 1
3434: PPUSH
3435: CALL 1932 0 1
3439: IFFALSE 3776
3441: GO 3443
3443: DISABLE
3444: LD_INT 0
3446: PPUSH
// begin enable ;
3447: ENABLE
// if objReturn then
3448: LD_EXP 29
3452: IFFALSE 3505
// begin for i in BurlakComp do
3454: LD_ADDR_VAR 0 1
3458: PUSH
3459: LD_EXP 14
3463: PUSH
3464: FOR_IN
3465: IFFALSE 3488
// begin if not IsInArea ( i , RU2_base ) then
3467: LD_VAR 0 1
3471: PPUSH
3472: LD_INT 1
3474: PPUSH
3475: CALL_OW 308
3479: NOT
3480: IFFALSE 3486
// exit ;
3482: POP
3483: POP
3484: GO 3776
// end ;
3486: GO 3464
3488: POP
3489: POP
// ChangeMissionObjectives ( M10b ) ;
3490: LD_STRING M10b
3492: PPUSH
3493: CALL_OW 337
// objReturn := false ;
3497: LD_ADDR_EXP 29
3501: PUSH
3502: LD_INT 0
3504: ST_TO_ADDR
// end ; if Charted and WBWDestroyed and ( BelkovFreed or not ( IsOK ( Bel ) ) ) then
3505: LD_EXP 25
3509: PUSH
3510: LD_EXP 20
3514: AND
3515: PUSH
3516: LD_EXP 16
3520: PUSH
3521: LD_EXP 52
3525: PPUSH
3526: CALL_OW 302
3530: NOT
3531: OR
3532: AND
3533: IFFALSE 3548
// begin konec_mise ;
3535: CALL 249 0 0
// wait ( 0 0$1 ) ;
3539: LD_INT 35
3541: PPUSH
3542: CALL_OW 67
// exit ;
3546: GO 3776
// end ; if Charted and WBWDestroyed and ( not objBelkov ) and ( IsOK ( Bel ) ) then
3548: LD_EXP 25
3552: PUSH
3553: LD_EXP 20
3557: AND
3558: PUSH
3559: LD_EXP 28
3563: NOT
3564: AND
3565: PUSH
3566: LD_EXP 52
3570: PPUSH
3571: CALL_OW 302
3575: AND
3576: IFFALSE 3630
// begin case Query ( QContMission ) of 1 :
3578: LD_STRING QContMission
3580: PPUSH
3581: CALL_OW 97
3585: PUSH
3586: LD_INT 1
3588: DOUBLE
3589: EQUAL
3590: IFTRUE 3594
3592: GO 3601
3594: POP
// konec_mise ; 2 :
3595: CALL 249 0 0
3599: GO 3628
3601: LD_INT 2
3603: DOUBLE
3604: EQUAL
3605: IFTRUE 3609
3607: GO 3627
3609: POP
// begin ChangeMissionObjectives ( M9 ) ;
3610: LD_STRING M9
3612: PPUSH
3613: CALL_OW 337
// objBelkov := true ;
3617: LD_ADDR_EXP 28
3621: PUSH
3622: LD_INT 1
3624: ST_TO_ADDR
// end ; end ;
3625: GO 3628
3627: POP
// exit ;
3628: GO 3776
// end ; if not CanReturn then
3630: LD_EXP 33
3634: NOT
3635: IFFALSE 3639
// exit ;
3637: GO 3776
// CanReturn := false ;
3639: LD_ADDR_EXP 33
3643: PUSH
3644: LD_INT 0
3646: ST_TO_ADDR
// if ( not WBWDestroyed ) or ( not EBWDestroyed ) then
3647: LD_EXP 20
3651: NOT
3652: PUSH
3653: LD_EXP 23
3657: NOT
3658: OR
3659: IFFALSE 3678
// begin if not BeriaVisited then
3661: LD_EXP 32
3665: NOT
3666: IFFALSE 3674
// play_dialog_25 else
3668: CALL 12177 0 0
3672: GO 3678
// play_dialog_25a ;
3674: CALL 12440 0 0
// end ; BeriaVisited := true ;
3678: LD_ADDR_EXP 32
3682: PUSH
3683: LD_INT 1
3685: ST_TO_ADDR
// if WBWSpotted and ( not WBWDestroyed ) and ( not Reinforcements ) then
3686: LD_EXP 18
3690: PUSH
3691: LD_EXP 20
3695: NOT
3696: AND
3697: PUSH
3698: LD_EXP 30
3702: NOT
3703: AND
3704: IFFALSE 3758
// begin play_dialog_25b ;
3706: CALL 12627 0 0
// posily_go := true ;
3710: LD_ADDR_EXP 68
3714: PUSH
3715: LD_INT 1
3717: ST_TO_ADDR
// Reinforcements := true ;
3718: LD_ADDR_EXP 30
3722: PUSH
3723: LD_INT 1
3725: ST_TO_ADDR
// if ( not objAttack ) then
3726: LD_EXP 27
3730: NOT
3731: IFFALSE 3756
// begin ChangeMissionObjectives ( M7 ) ;
3733: LD_STRING M7
3735: PPUSH
3736: CALL_OW 337
// objAttack := true ;
3740: LD_ADDR_EXP 27
3744: PUSH
3745: LD_INT 1
3747: ST_TO_ADDR
// stav_utoku := 1 ;
3748: LD_ADDR_EXP 59
3752: PUSH
3753: LD_INT 1
3755: ST_TO_ADDR
// end ; exit ;
3756: GO 3776
// end ; if ( not Charted ) or ( not WBWSpotted ) then
3758: LD_EXP 25
3762: NOT
3763: PUSH
3764: LD_EXP 18
3768: NOT
3769: OR
3770: IFFALSE 3776
// begin play_dialog_25c ;
3772: CALL 12678 0 0
// end ; end ; end_of_file
3776: PPOPN 1
3778: END
// export AMICI_PAST_LIST ; export AMICI_STAVENI_BASE_LIST ; export AMICI_UTOK_BELKOV_LIST ; var ah , av ; export function get_human ( sex , clas , level , name ) ; var pom ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
// PrepareHuman ( sex , clas , level ) ;
3783: LD_VAR 0 1
3787: PPUSH
3788: LD_VAR 0 2
3792: PPUSH
3793: LD_VAR 0 3
3797: PPUSH
3798: CALL_OW 380
// hc_name := name ;
3802: LD_ADDR_OWVAR 26
3806: PUSH
3807: LD_VAR 0 4
3811: ST_TO_ADDR
// pom = CreateHuman ;
3812: LD_ADDR_VAR 0 6
3816: PUSH
3817: CALL_OW 44
3821: ST_TO_ADDR
// result := pom ;
3822: LD_ADDR_VAR 0 5
3826: PUSH
3827: LD_VAR 0 6
3831: ST_TO_ADDR
// end ;
3832: LD_VAR 0 5
3836: RET
// export function amici_breast ; begin
3837: LD_INT 0
3839: PPUSH
// uc_nation = nation_american ;
3840: LD_ADDR_OWVAR 21
3844: PUSH
3845: LD_INT 1
3847: ST_TO_ADDR
// uc_side = Amici ;
3848: LD_ADDR_OWVAR 20
3852: PUSH
3853: LD_EXP 2
3857: ST_TO_ADDR
// ah = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] , David Love ) ;
3858: LD_ADDR_LOC 1
3862: PUSH
3863: LD_INT 1
3865: PPUSH
3866: LD_INT 1
3868: PPUSH
3869: LD_EXP 40
3873: PUSH
3874: LD_OWVAR 67
3878: ARRAY
3879: PPUSH
3880: LD_STRING David Love
3882: PPUSH
3883: CALL 3779 0 4
3887: ST_TO_ADDR
// PlaceUnitXY ( ah , 107 , 63 , false ) ;
3888: LD_LOC 1
3892: PPUSH
3893: LD_INT 107
3895: PPUSH
3896: LD_INT 63
3898: PPUSH
3899: LD_INT 0
3901: PPUSH
3902: CALL_OW 48
// ComMoveXY ( ah , 92 , 56 ) ;
3906: LD_LOC 1
3910: PPUSH
3911: LD_INT 92
3913: PPUSH
3914: LD_INT 56
3916: PPUSH
3917: CALL_OW 111
// ABW1 = ah ;
3921: LD_ADDR_EXP 76
3925: PUSH
3926: LD_LOC 1
3930: ST_TO_ADDR
// AddComEnterUnit ( ah , am_bre1 ) ;
3931: LD_LOC 1
3935: PPUSH
3936: LD_INT 30
3938: PPUSH
3939: CALL_OW 180
// ah = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] , John Kraninger ) ;
3943: LD_ADDR_LOC 1
3947: PUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: LD_EXP 40
3958: PUSH
3959: LD_OWVAR 67
3963: ARRAY
3964: PPUSH
3965: LD_STRING John Kraninger
3967: PPUSH
3968: CALL 3779 0 4
3972: ST_TO_ADDR
// PlaceUnitXY ( ah , 106 , 65 , false ) ;
3973: LD_LOC 1
3977: PPUSH
3978: LD_INT 106
3980: PPUSH
3981: LD_INT 65
3983: PPUSH
3984: LD_INT 0
3986: PPUSH
3987: CALL_OW 48
// ComMoveXY ( ah , 95 , 61 ) ;
3991: LD_LOC 1
3995: PPUSH
3996: LD_INT 95
3998: PPUSH
3999: LD_INT 61
4001: PPUSH
4002: CALL_OW 111
// AddComEnterUnit ( ah , am_bre2 ) ;
4006: LD_LOC 1
4010: PPUSH
4011: LD_INT 31
4013: PPUSH
4014: CALL_OW 180
// ABW2 = ah ;
4018: LD_ADDR_EXP 77
4022: PUSH
4023: LD_LOC 1
4027: ST_TO_ADDR
// end ;
4028: LD_VAR 0 1
4032: RET
// function get_sex ; begin
4033: LD_INT 0
4035: PPUSH
// if Prob ( 20 ) then
4036: LD_INT 20
4038: PPUSH
4039: CALL_OW 13
4043: IFFALSE 4055
// result = sex_female else
4045: LD_ADDR_VAR 0 1
4049: PUSH
4050: LD_INT 2
4052: ST_TO_ADDR
4053: GO 4063
// result = sex_male ;
4055: LD_ADDR_VAR 0 1
4059: PUSH
4060: LD_INT 1
4062: ST_TO_ADDR
// end ;
4063: LD_VAR 0 1
4067: RET
// export function create_amici_past ; var i ; var a ; var p_vojaku ; begin
4068: LD_INT 0
4070: PPUSH
4071: PPUSH
4072: PPUSH
4073: PPUSH
// a = [ ] ;
4074: LD_ADDR_VAR 0 3
4078: PUSH
4079: EMPTY
4080: ST_TO_ADDR
// p_vojaku = amici_past_pocet [ difficulty ] ;
4081: LD_ADDR_VAR 0 4
4085: PUSH
4086: LD_EXP 41
4090: PUSH
4091: LD_OWVAR 67
4095: ARRAY
4096: ST_TO_ADDR
// a = get_human ( sex_male , class_soldier , LEVELY_AMICI [ difficulty ] + 1 ,  ) ;
4097: LD_ADDR_VAR 0 3
4101: PUSH
4102: LD_INT 1
4104: PPUSH
4105: LD_INT 1
4107: PPUSH
4108: LD_EXP 40
4112: PUSH
4113: LD_OWVAR 67
4117: ARRAY
4118: PUSH
4119: LD_INT 1
4121: PLUS
4122: PPUSH
4123: LD_STRING 
4125: PPUSH
4126: CALL 3779 0 4
4130: ST_TO_ADDR
// for i := 1 to p_vojaku - 1 do
4131: LD_ADDR_VAR 0 2
4135: PUSH
4136: DOUBLE
4137: LD_INT 1
4139: DEC
4140: ST_TO_ADDR
4141: LD_VAR 0 4
4145: PUSH
4146: LD_INT 1
4148: MINUS
4149: PUSH
4150: FOR_TO
4151: IFFALSE 4197
// a = a ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] + 1 ,  ) ;
4153: LD_ADDR_VAR 0 3
4157: PUSH
4158: LD_VAR 0 3
4162: PUSH
4163: CALL 4033 0 0
4167: PPUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_EXP 40
4175: PUSH
4176: LD_OWVAR 67
4180: ARRAY
4181: PUSH
4182: LD_INT 1
4184: PLUS
4185: PPUSH
4186: LD_STRING 
4188: PPUSH
4189: CALL 3779 0 4
4193: ADD
4194: ST_TO_ADDR
4195: GO 4150
4197: POP
4198: POP
// AMICI_PAST_LIST = a ;
4199: LD_ADDR_EXP 37
4203: PUSH
4204: LD_VAR 0 3
4208: ST_TO_ADDR
// end ;
4209: LD_VAR 0 1
4213: RET
// export function create_amici_staveni_w ; var a ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
// a = get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: CALL 4033 0 0
4227: PPUSH
4228: LD_INT 1
4230: PPUSH
4231: LD_EXP 40
4235: PUSH
4236: LD_OWVAR 67
4240: ARRAY
4241: PPUSH
4242: LD_STRING 
4244: PPUSH
4245: CALL 3779 0 4
4249: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4250: LD_ADDR_VAR 0 2
4254: PUSH
4255: LD_VAR 0 2
4259: PUSH
4260: CALL 4033 0 0
4264: PPUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_EXP 40
4272: PUSH
4273: LD_OWVAR 67
4277: ARRAY
4278: PPUSH
4279: LD_STRING 
4281: PPUSH
4282: CALL 3779 0 4
4286: ADD
4287: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_engineer , LEVELY_AMICI [ difficulty ] ,  ) ;
4288: LD_ADDR_VAR 0 2
4292: PUSH
4293: LD_VAR 0 2
4297: PUSH
4298: CALL 4033 0 0
4302: PPUSH
4303: LD_INT 2
4305: PPUSH
4306: LD_EXP 40
4310: PUSH
4311: LD_OWVAR 67
4315: ARRAY
4316: PPUSH
4317: LD_STRING 
4319: PPUSH
4320: CALL 3779 0 4
4324: ADD
4325: ST_TO_ADDR
// a = a ^ get_human ( get_sex , class_engineer , LEVELY_AMICI [ difficulty ] ,  ) ;
4326: LD_ADDR_VAR 0 2
4330: PUSH
4331: LD_VAR 0 2
4335: PUSH
4336: CALL 4033 0 0
4340: PPUSH
4341: LD_INT 2
4343: PPUSH
4344: LD_EXP 40
4348: PUSH
4349: LD_OWVAR 67
4353: ARRAY
4354: PPUSH
4355: LD_STRING 
4357: PPUSH
4358: CALL 3779 0 4
4362: ADD
4363: ST_TO_ADDR
// AMICI_STAVENI_BASE_LIST = a ;
4364: LD_ADDR_EXP 38
4368: PUSH
4369: LD_VAR 0 2
4373: ST_TO_ADDR
// end ;
4374: LD_VAR 0 1
4378: RET
// export function vyber_cloveka ( list , cla ) ; var i ; var a ; begin
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
// a = 0 ;
4384: LD_ADDR_VAR 0 5
4388: PUSH
4389: LD_INT 0
4391: ST_TO_ADDR
// for i in list do
4392: LD_ADDR_VAR 0 4
4396: PUSH
4397: LD_VAR 0 1
4401: PUSH
4402: FOR_IN
4403: IFFALSE 4434
// if GetClass ( i ) = cla then
4405: LD_VAR 0 4
4409: PPUSH
4410: CALL_OW 257
4414: PUSH
4415: LD_VAR 0 2
4419: EQUAL
4420: IFFALSE 4432
// a = i ;
4422: LD_ADDR_VAR 0 5
4426: PUSH
4427: LD_VAR 0 4
4431: ST_TO_ADDR
4432: GO 4402
4434: POP
4435: POP
// result = a ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: LD_VAR 0 5
4445: ST_TO_ADDR
// end ;
4446: LD_VAR 0 3
4450: RET
// export function create_utok_na_belkova ; var pom ; begin
4451: LD_INT 0
4453: PPUSH
4454: PPUSH
// uc_side = Amici ;
4455: LD_ADDR_OWVAR 20
4459: PUSH
4460: LD_EXP 2
4464: ST_TO_ADDR
// uc_nation = nation_american ;
4465: LD_ADDR_OWVAR 21
4469: PUSH
4470: LD_INT 1
4472: ST_TO_ADDR
// pom = get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4473: LD_ADDR_VAR 0 2
4477: PUSH
4478: CALL 4033 0 0
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: LD_EXP 40
4490: PUSH
4491: LD_OWVAR 67
4495: ARRAY
4496: PPUSH
4497: LD_STRING 
4499: PPUSH
4500: CALL 3779 0 4
4504: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4505: LD_ADDR_VAR 0 2
4509: PUSH
4510: LD_VAR 0 2
4514: PUSH
4515: CALL 4033 0 0
4519: PPUSH
4520: LD_INT 1
4522: PPUSH
4523: LD_EXP 40
4527: PUSH
4528: LD_OWVAR 67
4532: ARRAY
4533: PPUSH
4534: LD_STRING 
4536: PPUSH
4537: CALL 3779 0 4
4541: ADD
4542: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4543: LD_ADDR_VAR 0 2
4547: PUSH
4548: LD_VAR 0 2
4552: PUSH
4553: CALL 4033 0 0
4557: PPUSH
4558: LD_INT 1
4560: PPUSH
4561: LD_EXP 40
4565: PUSH
4566: LD_OWVAR 67
4570: ARRAY
4571: PPUSH
4572: LD_STRING 
4574: PPUSH
4575: CALL 3779 0 4
4579: ADD
4580: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4581: LD_ADDR_VAR 0 2
4585: PUSH
4586: LD_VAR 0 2
4590: PUSH
4591: CALL 4033 0 0
4595: PPUSH
4596: LD_INT 1
4598: PPUSH
4599: LD_EXP 40
4603: PUSH
4604: LD_OWVAR 67
4608: ARRAY
4609: PPUSH
4610: LD_STRING 
4612: PPUSH
4613: CALL 3779 0 4
4617: ADD
4618: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4619: LD_ADDR_VAR 0 2
4623: PUSH
4624: LD_VAR 0 2
4628: PUSH
4629: CALL 4033 0 0
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: LD_EXP 40
4641: PUSH
4642: LD_OWVAR 67
4646: ARRAY
4647: PPUSH
4648: LD_STRING 
4650: PPUSH
4651: CALL 3779 0 4
4655: ADD
4656: ST_TO_ADDR
// pom = pom ^ get_human ( get_sex , class_soldier , LEVELY_AMICI [ difficulty ] ,  ) ;
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_VAR 0 2
4666: PUSH
4667: CALL 4033 0 0
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_EXP 40
4679: PUSH
4680: LD_OWVAR 67
4684: ARRAY
4685: PPUSH
4686: LD_STRING 
4688: PPUSH
4689: CALL 3779 0 4
4693: ADD
4694: ST_TO_ADDR
// AMICI_UTOK_BELKOV_LIST = pom ;
4695: LD_ADDR_EXP 39
4699: PUSH
4700: LD_VAR 0 2
4704: ST_TO_ADDR
// end ;
4705: LD_VAR 0 1
4709: RET
// export function create_vojaci_zacatek ; var pom_gny ; begin
4710: LD_INT 0
4712: PPUSH
4713: PPUSH
// uc_nation = nation_russian ;
4714: LD_ADDR_OWVAR 21
4718: PUSH
4719: LD_INT 3
4721: ST_TO_ADDR
// uc_side = You ;
4722: LD_ADDR_OWVAR 20
4726: PUSH
4727: LD_EXP 1
4731: ST_TO_ADDR
// SetSide ( Kurin , You2 ) ;
4732: LD_EXP 53
4736: PPUSH
4737: LD_EXP 4
4741: PPUSH
4742: CALL_OW 235
// PlaceUnitXY ( kurin , 121 , 101 , false ) ;
4746: LD_EXP 53
4750: PPUSH
4751: LD_INT 121
4753: PPUSH
4754: LD_INT 101
4756: PPUSH
4757: LD_INT 0
4759: PPUSH
4760: CALL_OW 48
// Setclass ( bel , class_soldier ) ;
4764: LD_EXP 52
4768: PPUSH
4769: LD_INT 1
4771: PPUSH
4772: CALL_OW 336
// SetSide ( bel , You2 ) ;
4776: LD_EXP 52
4780: PPUSH
4781: LD_EXP 4
4785: PPUSH
4786: CALL_OW 235
// PlaceUnitXY ( bel , 121 , 104 , false ) ;
4790: LD_EXP 52
4794: PPUSH
4795: LD_INT 121
4797: PPUSH
4798: LD_INT 104
4800: PPUSH
4801: LD_INT 0
4803: PPUSH
4804: CALL_OW 48
// SetSide ( kov , You ) ;
4808: LD_EXP 51
4812: PPUSH
4813: LD_EXP 1
4817: PPUSH
4818: CALL_OW 235
// PlaceUnitXY ( kov , 126 , 105 , false ) ;
4822: LD_EXP 51
4826: PPUSH
4827: LD_INT 126
4829: PPUSH
4830: LD_INT 105
4832: PPUSH
4833: LD_INT 0
4835: PPUSH
4836: CALL_OW 48
// SetClass ( bur , class_mechanic ) ;
4840: LD_EXP 50
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: CALL_OW 336
// SetSide ( bur , You ) ;
4852: LD_EXP 50
4856: PPUSH
4857: LD_EXP 1
4861: PPUSH
4862: CALL_OW 235
// PlaceUnitXY ( bur , 124 , 105 , false ) ;
4866: LD_EXP 50
4870: PPUSH
4871: LD_INT 124
4873: PPUSH
4874: LD_INT 105
4876: PPUSH
4877: LD_INT 0
4879: PPUSH
4880: CALL_OW 48
// if gny <> 0 then
4884: LD_EXP 49
4888: PUSH
4889: LD_INT 0
4891: NONEQUAL
4892: IFFALSE 4940
// begin SetClass ( gny , class_soldier ) ;
4894: LD_EXP 49
4898: PPUSH
4899: LD_INT 1
4901: PPUSH
4902: CALL_OW 336
// SetSide ( gny , You ) ;
4906: LD_EXP 49
4910: PPUSH
4911: LD_EXP 1
4915: PPUSH
4916: CALL_OW 235
// PlaceUnitXY ( gny , 120 , 103 , false ) ;
4920: LD_EXP 49
4924: PPUSH
4925: LD_INT 120
4927: PPUSH
4928: LD_INT 103
4930: PPUSH
4931: LD_INT 0
4933: PPUSH
4934: CALL_OW 48
// end else
4938: GO 4980
// begin pom_gny = get_human ( sex_male , class_soldier , 2 ,  ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 1
4947: PPUSH
4948: LD_INT 1
4950: PPUSH
4951: LD_INT 2
4953: PPUSH
4954: LD_STRING 
4956: PPUSH
4957: CALL 3779 0 4
4961: ST_TO_ADDR
// PlaceUnitXY ( pom_gny , 120 , 103 , false ) ;
4962: LD_VAR 0 2
4966: PPUSH
4967: LD_INT 120
4969: PPUSH
4970: LD_INT 103
4972: PPUSH
4973: LD_INT 0
4975: PPUSH
4976: CALL_OW 48
// end ; SetSide ( plat , You3 ) ;
4980: LD_EXP 54
4984: PPUSH
4985: LD_EXP 6
4989: PPUSH
4990: CALL_OW 235
// PlaceUnitXY ( plat , 66 , 90 , false ) ;
4994: LD_EXP 54
4998: PPUSH
4999: LD_INT 66
5001: PPUSH
5002: LD_INT 90
5004: PPUSH
5005: LD_INT 0
5007: PPUSH
5008: CALL_OW 48
// end ;
5012: LD_VAR 0 1
5016: RET
// export function nacti_osobu ( ident ) ; begin
5017: LD_INT 0
5019: PPUSH
// if CheckCharacterSet ( ident ) then
5020: LD_VAR 0 1
5024: PPUSH
5025: CALL_OW 29
5029: IFFALSE 5048
// result := CreateCharacter ( ident ) else
5031: LD_ADDR_VAR 0 2
5035: PUSH
5036: LD_VAR 0 1
5040: PPUSH
5041: CALL_OW 34
5045: ST_TO_ADDR
5046: GO 5056
// result := 0 ;
5048: LD_ADDR_VAR 0 2
5052: PUSH
5053: LD_INT 0
5055: ST_TO_ADDR
// end ;
5056: LD_VAR 0 2
5060: RET
// export function place_amik_k_videni ; begin
5061: LD_INT 0
5063: PPUSH
// uc_side = Amici ;
5064: LD_ADDR_OWVAR 20
5068: PUSH
5069: LD_EXP 2
5073: ST_TO_ADDR
// uc_nation = nation_american ;
5074: LD_ADDR_OWVAR 21
5078: PUSH
5079: LD_INT 1
5081: ST_TO_ADDR
// ah = get_human ( get_sex , class_soldier , 3 ,  ) ;
5082: LD_ADDR_LOC 1
5086: PUSH
5087: CALL 4033 0 0
5091: PPUSH
5092: LD_INT 1
5094: PPUSH
5095: LD_INT 3
5097: PPUSH
5098: LD_STRING 
5100: PPUSH
5101: CALL 3779 0 4
5105: ST_TO_ADDR
// PlaceUnitXYR ( ah , 72 , 28 , 3 , false ) ;
5106: LD_LOC 1
5110: PPUSH
5111: LD_INT 72
5113: PPUSH
5114: LD_INT 28
5116: PPUSH
5117: LD_INT 3
5119: PPUSH
5120: LD_INT 0
5122: PPUSH
5123: CALL_OW 50
// result := ah ;
5127: LD_ADDR_VAR 0 1
5131: PUSH
5132: LD_LOC 1
5136: ST_TO_ADDR
// end ;
5137: LD_VAR 0 1
5141: RET
// every 0 0$1 trigger GetLives ( plat ) < 1000 do
5142: LD_EXP 54
5146: PPUSH
5147: CALL_OW 256
5151: PUSH
5152: LD_INT 1000
5154: LESS
5155: IFFALSE 5173
5157: GO 5159
5159: DISABLE
// begin enable ;
5160: ENABLE
// SetLives ( plat , 1000 ) ;
5161: LD_EXP 54
5165: PPUSH
5166: LD_INT 1000
5168: PPUSH
5169: CALL_OW 234
// end ; end_of_file
5173: END
// export LEVELY_AMICI ; export amici_past_pocet ; export procento_odkrytych_pro_vyhru ; export cas_na_zachranu_belkova ; export levely_bw_na_zapade ; export levely_bw_na_vychode ; export BELKOV_MRTVY ; export function set_difficulty ; begin
5174: LD_INT 0
5176: PPUSH
// LEVELY_AMICI = [ 1 , 2 , 3 ] ;
5177: LD_ADDR_EXP 40
5181: PUSH
5182: LD_INT 1
5184: PUSH
5185: LD_INT 2
5187: PUSH
5188: LD_INT 3
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: ST_TO_ADDR
// amici_past_pocet = [ 3 , 5 , 7 ] ;
5196: LD_ADDR_EXP 41
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: LD_INT 5
5206: PUSH
5207: LD_INT 7
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: LIST
5214: ST_TO_ADDR
// procento_odkrytych_pro_vyhru = [ 3400 , 3600 , 3800 ] ;
5215: LD_ADDR_EXP 42
5219: PUSH
5220: LD_INT 3400
5222: PUSH
5223: LD_INT 3600
5225: PUSH
5226: LD_INT 3800
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: LIST
5233: ST_TO_ADDR
// cas_na_zachranu_belkova = [ 20 20$0 , 15 15$0 , 10 10$0 ] ;
5234: LD_ADDR_EXP 43
5238: PUSH
5239: LD_INT 42000
5241: PUSH
5242: LD_INT 31500
5244: PUSH
5245: LD_INT 21000
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: ST_TO_ADDR
// levely_bw_na_zapade = [ 1 , 2 , 3 ] ;
5253: LD_ADDR_EXP 44
5257: PUSH
5258: LD_INT 1
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: LD_INT 3
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: LIST
5271: ST_TO_ADDR
// levely_bw_na_vychode = [ 1 , 2 , 3 ] ;
5272: LD_ADDR_EXP 45
5276: PUSH
5277: LD_INT 1
5279: PUSH
5280: LD_INT 2
5282: PUSH
5283: LD_INT 3
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: LIST
5290: ST_TO_ADDR
// end ;
5291: LD_VAR 0 1
5295: RET
// every 0 0$0.1 do
5296: GO 5298
5298: DISABLE
// begin SetBName ( RU1_dep , kirov ) ;
5299: LD_INT 1
5301: PPUSH
5302: LD_STRING kirov
5304: PPUSH
5305: CALL_OW 500
// SetBName ( RU2_dep , beria ) ;
5309: LD_INT 26
5311: PPUSH
5312: LD_STRING beria
5314: PPUSH
5315: CALL_OW 500
// end ; end_of_file
5319: END
// var prilis_na_north ; var is_out_base ; var wasattack ; var ridic_1_auta ; var je_mimo ; var byl_v_zakladne ; var kecal_s_platonovem ; var znicene_bw ; var bw_e_nasli ; var cont_mission ; var kecy_bw_w ; export navrat_a_konec ; export belkov_solved ; var skurveny_mission_objectiv_uz_prosel ; var konstanta_utoceni ; var kecy_pri_vraceni_belkova ; every 0 0$0.1 do var i ;
5320: GO 5322
5322: DISABLE
5323: LD_INT 0
5325: PPUSH
// begin prilis_na_north = [ 1 , 2 , 4 , 5 , 6 ] ;
5326: LD_ADDR_LOC 3
5330: PUSH
5331: LD_INT 1
5333: PUSH
5334: LD_INT 2
5336: PUSH
5337: LD_INT 4
5339: PUSH
5340: LD_INT 5
5342: PUSH
5343: LD_INT 6
5345: PUSH
5346: EMPTY
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// is_out_base = [ 3 ] ;
5353: LD_ADDR_LOC 4
5357: PUSH
5358: LD_INT 3
5360: PUSH
5361: EMPTY
5362: LIST
5363: ST_TO_ADDR
// bw_e_nasli = false ;
5364: LD_ADDR_LOC 11
5368: PUSH
5369: LD_INT 0
5371: ST_TO_ADDR
// kecy_bw_w = false ;
5372: LD_ADDR_LOC 13
5376: PUSH
5377: LD_INT 0
5379: ST_TO_ADDR
// wasattack = false ;
5380: LD_ADDR_LOC 5
5384: PUSH
5385: LD_INT 0
5387: ST_TO_ADDR
// je_mimo = false ;
5388: LD_ADDR_LOC 7
5392: PUSH
5393: LD_INT 0
5395: ST_TO_ADDR
// byl_v_zakladne = false ;
5396: LD_ADDR_LOC 8
5400: PUSH
5401: LD_INT 0
5403: ST_TO_ADDR
// kecal_s_platonovem = false ;
5404: LD_ADDR_LOC 9
5408: PUSH
5409: LD_INT 0
5411: ST_TO_ADDR
// znicene_bw = false ;
5412: LD_ADDR_LOC 10
5416: PUSH
5417: LD_INT 0
5419: ST_TO_ADDR
// belkov_solved = 1 ;
5420: LD_ADDR_EXP 48
5424: PUSH
5425: LD_INT 1
5427: ST_TO_ADDR
// konstanta_utoceni = 0 ;
5428: LD_ADDR_LOC 15
5432: PUSH
5433: LD_INT 0
5435: ST_TO_ADDR
// navrat_a_konec = false ;
5436: LD_ADDR_EXP 47
5440: PUSH
5441: LD_INT 0
5443: ST_TO_ADDR
// cont_mission = false ;
5444: LD_ADDR_LOC 12
5448: PUSH
5449: LD_INT 0
5451: ST_TO_ADDR
// skurveny_mission_objectiv_uz_prosel = false ;
5452: LD_ADDR_LOC 14
5456: PUSH
5457: LD_INT 0
5459: ST_TO_ADDR
// kecy_pri_vraceni_belkova = 0 ;
5460: LD_ADDR_LOC 16
5464: PUSH
5465: LD_INT 0
5467: ST_TO_ADDR
// for i in [ 991 , 992 ] do
5468: LD_ADDR_VAR 0 1
5472: PUSH
5473: LD_INT 991
5475: PUSH
5476: LD_INT 992
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PUSH
5483: FOR_IN
5484: IFFALSE 5493
// disable ( i ) ;
5486: LD_VAR 0 1
5490: DISABLE_MARKED
5491: GO 5483
5493: POP
5494: POP
// end ;
5495: PPOPN 1
5497: END
// every 0 0$3 do
5498: GO 5500
5500: DISABLE
// begin ComTurnUnit ( kurin , bur ) ;
5501: LD_EXP 53
5505: PPUSH
5506: LD_EXP 50
5510: PPUSH
5511: CALL_OW 119
// ComTurnUnit ( bur , kurin ) ;
5515: LD_EXP 50
5519: PPUSH
5520: LD_EXP 53
5524: PPUSH
5525: CALL_OW 119
// Say ( kurin , D1-Kur-1 ) ;
5529: LD_EXP 53
5533: PPUSH
5534: LD_STRING D1-Kur-1
5536: PPUSH
5537: CALL_OW 88
// Say ( bur , D1-Bur-1 ) ;
5541: LD_EXP 50
5545: PPUSH
5546: LD_STRING D1-Bur-1
5548: PPUSH
5549: CALL_OW 88
// Say ( kurin , D1-Kur-2 ) ;
5553: LD_EXP 53
5557: PPUSH
5558: LD_STRING D1-Kur-2
5560: PPUSH
5561: CALL_OW 88
// Say ( bur , D1-Bur-2 ) ;
5565: LD_EXP 50
5569: PPUSH
5570: LD_STRING D1-Bur-2
5572: PPUSH
5573: CALL_OW 88
// Say ( kurin , D1-Kur-3 ) ;
5577: LD_EXP 53
5581: PPUSH
5582: LD_STRING D1-Kur-3
5584: PPUSH
5585: CALL_OW 88
// if gny <> 0 then
5589: LD_EXP 49
5593: PUSH
5594: LD_INT 0
5596: NONEQUAL
5597: IFFALSE 5611
// Say ( kurin , D1-Kur-3a ) ;
5599: LD_EXP 53
5603: PPUSH
5604: LD_STRING D1-Kur-3a
5606: PPUSH
5607: CALL_OW 88
// SaveForQuickRestart ;
5611: CALL_OW 22
// wait ( 0 0$1 ) ;
5615: LD_INT 35
5617: PPUSH
5618: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5622: LD_STRING M1
5624: PPUSH
5625: CALL_OW 337
// InGameOff ;
5629: CALL_OW 9
// stav = 1 ;
5633: LD_ADDR_EXP 60
5637: PUSH
5638: LD_INT 1
5640: ST_TO_ADDR
// enable ( 991 ) ;
5641: LD_INT 991
5643: ENABLE_MARKED
// end ;
5644: END
// every 0 0$1 trigger SeeXY ( You , 69 , 83 ) or SeeXY ( You , 73 , 96 ) and ( not kecal_s_platonovem ) do var pom ; var sq ;
5645: LD_EXP 1
5649: PPUSH
5650: LD_INT 69
5652: PPUSH
5653: LD_INT 83
5655: PPUSH
5656: CALL_OW 293
5660: PUSH
5661: LD_EXP 1
5665: PPUSH
5666: LD_INT 73
5668: PPUSH
5669: LD_INT 96
5671: PPUSH
5672: CALL_OW 293
5676: PUSH
5677: LD_LOC 9
5681: NOT
5682: AND
5683: OR
5684: IFFALSE 5780
5686: GO 5688
5688: DISABLE
5689: LD_INT 0
5691: PPUSH
5692: PPUSH
// begin DialogueOn ;
5693: CALL_OW 6
// if SeeXY ( You , 71 , 84 ) then
5697: LD_EXP 1
5701: PPUSH
5702: LD_INT 71
5704: PPUSH
5705: LD_INT 84
5707: PPUSH
5708: CALL_OW 293
5712: IFFALSE 5724
// pom = Ru2_vb1 else
5714: LD_ADDR_VAR 0 1
5718: PUSH
5719: LD_INT 9
5721: ST_TO_ADDR
5722: GO 5732
// pom = Ru2_vb2 ;
5724: LD_ADDR_VAR 0 1
5728: PUSH
5729: LD_INT 10
5731: ST_TO_ADDR
// Say ( pom , D2-RSol1-1 ) ;
5732: LD_VAR 0 1
5736: PPUSH
5737: LD_STRING D2-RSol1-1
5739: PPUSH
5740: CALL_OW 88
// Say ( bur , D2-Bur-1 ) ;
5744: LD_EXP 50
5748: PPUSH
5749: LD_STRING D2-Bur-1
5751: PPUSH
5752: CALL_OW 88
// Say ( pom , D2-RSol1-2 ) ;
5756: LD_VAR 0 1
5760: PPUSH
5761: LD_STRING D2-RSol1-2
5763: PPUSH
5764: CALL_OW 88
// stav = 2 ;
5768: LD_ADDR_EXP 60
5772: PUSH
5773: LD_INT 2
5775: ST_TO_ADDR
// DialogueOff ;
5776: CALL_OW 7
// end ;
5780: PPOPN 2
5782: END
// every 0 0$1 trigger IsInArea ( bur , near_plat ) do
5783: LD_EXP 50
5787: PPUSH
5788: LD_INT 5
5790: PPUSH
5791: CALL_OW 308
5795: IFFALSE 6149
5797: GO 5799
5799: DISABLE
// begin kecal_s_platonovem = true ;
5800: LD_ADDR_LOC 9
5804: PUSH
5805: LD_INT 1
5807: ST_TO_ADDR
// DialogueOn ;
5808: CALL_OW 6
// ComHold ( bur ) ;
5812: LD_EXP 50
5816: PPUSH
5817: CALL_OW 140
// ComTurnUnit ( plat , bur ) ;
5821: LD_EXP 54
5825: PPUSH
5826: LD_EXP 50
5830: PPUSH
5831: CALL_OW 119
// AddComTurnUnit ( bur , plat ) ;
5835: LD_EXP 50
5839: PPUSH
5840: LD_EXP 54
5844: PPUSH
5845: CALL_OW 179
// Say ( plat , D2-Pla-2 ) ;
5849: LD_EXP 54
5853: PPUSH
5854: LD_STRING D2-Pla-2
5856: PPUSH
5857: CALL_OW 88
// Say ( bur , D2-Bur-2 ) ;
5861: LD_EXP 50
5865: PPUSH
5866: LD_STRING D2-Bur-2
5868: PPUSH
5869: CALL_OW 88
// Say ( plat , D2-Pla-3 ) ;
5873: LD_EXP 54
5877: PPUSH
5878: LD_STRING D2-Pla-3
5880: PPUSH
5881: CALL_OW 88
// Say ( bur , D2-Bur-3 ) ;
5885: LD_EXP 50
5889: PPUSH
5890: LD_STRING D2-Bur-3
5892: PPUSH
5893: CALL_OW 88
// Say ( plat , D2-Pla-4 ) ;
5897: LD_EXP 54
5901: PPUSH
5902: LD_STRING D2-Pla-4
5904: PPUSH
5905: CALL_OW 88
// Say ( bur , D2-Bur-4 ) ;
5909: LD_EXP 50
5913: PPUSH
5914: LD_STRING D2-Bur-4
5916: PPUSH
5917: CALL_OW 88
// Say ( plat , D2-Pla-5 ) ;
5921: LD_EXP 54
5925: PPUSH
5926: LD_STRING D2-Pla-5
5928: PPUSH
5929: CALL_OW 88
// info_q ( [ 1 , 2 , 3 , 4 ] ) ;
5933: LD_INT 1
5935: PUSH
5936: LD_INT 2
5938: PUSH
5939: LD_INT 3
5941: PUSH
5942: LD_INT 4
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: PPUSH
5951: CALL 6150 0 1
// Say ( plat , D3-Pla-1 ) ;
5955: LD_EXP 54
5959: PPUSH
5960: LD_STRING D3-Pla-1
5962: PPUSH
5963: CALL_OW 88
// Say ( bur , D3-Bur-1 ) ;
5967: LD_EXP 50
5971: PPUSH
5972: LD_STRING D3-Bur-1
5974: PPUSH
5975: CALL_OW 88
// ChangeMissionObjectives ( M2a ) ;
5979: LD_STRING M2a
5981: PPUSH
5982: CALL_OW 337
// Hint ( Base ) ;
5986: LD_STRING Base
5988: PPUSH
5989: CALL_OW 339
// Hint ( Depot ) ;
5993: LD_STRING Depot
5995: PPUSH
5996: CALL_OW 339
// Hint ( Construction ) ;
6000: LD_STRING Construction
6002: PPUSH
6003: CALL_OW 339
// DialogueOff ;
6007: CALL_OW 7
// ComFree ( plat ) ;
6011: LD_EXP 54
6015: PPUSH
6016: CALL_OW 139
// AddComFree ( bur ) ;
6020: LD_EXP 50
6024: PPUSH
6025: CALL_OW 199
// stav = 3 ;
6029: LD_ADDR_EXP 60
6033: PUSH
6034: LD_INT 3
6036: ST_TO_ADDR
// SetSide ( RU2_dep , You ) ;
6037: LD_INT 26
6039: PPUSH
6040: LD_EXP 1
6044: PPUSH
6045: CALL_OW 235
// SetSide ( plat , You2 ) ;
6049: LD_EXP 54
6053: PPUSH
6054: LD_EXP 4
6058: PPUSH
6059: CALL_OW 235
// SetSide ( RU2_bu1 , You2 ) ;
6063: LD_INT 4
6065: PPUSH
6066: LD_EXP 4
6070: PPUSH
6071: CALL_OW 235
// SetSide ( RU2_bu2 , You2 ) ;
6075: LD_INT 11
6077: PPUSH
6078: LD_EXP 4
6082: PPUSH
6083: CALL_OW 235
// SetSide ( RU2_vb1 , You2 ) ;
6087: LD_INT 9
6089: PPUSH
6090: LD_EXP 4
6094: PPUSH
6095: CALL_OW 235
// SetSide ( RU2_vb2 , You2 ) ;
6099: LD_INT 10
6101: PPUSH
6102: LD_EXP 4
6106: PPUSH
6107: CALL_OW 235
// SetSide ( RU2_hv1 , You2 ) ;
6111: LD_INT 15
6113: PPUSH
6114: LD_EXP 4
6118: PPUSH
6119: CALL_OW 235
// SetSide ( RU2_hv2 , You2 ) ;
6123: LD_INT 16
6125: PPUSH
6126: LD_EXP 4
6130: PPUSH
6131: CALL_OW 235
// ComStop ( RU2_hv1 ) ;
6135: LD_INT 15
6137: PPUSH
6138: CALL_OW 141
// ComStop ( RU2_hv2 ) ;
6142: LD_INT 16
6144: PPUSH
6145: CALL_OW 141
// end ;
6149: END
// function info_q ( q ) ; var pom ; var q1 ; begin
6150: LD_INT 0
6152: PPUSH
6153: PPUSH
6154: PPUSH
// pom = SelectiveQuery ( QMoreInfo , q ) ;
6155: LD_ADDR_VAR 0 3
6159: PUSH
6160: LD_STRING QMoreInfo
6162: PPUSH
6163: LD_VAR 0 1
6167: PPUSH
6168: CALL_OW 98
6172: ST_TO_ADDR
// case pom of 1 :
6173: LD_VAR 0 3
6177: PUSH
6178: LD_INT 1
6180: DOUBLE
6181: EQUAL
6182: IFTRUE 6186
6184: GO 6246
6186: POP
// begin Say ( bur , D2a-Bur-1 ) ;
6187: LD_EXP 50
6191: PPUSH
6192: LD_STRING D2a-Bur-1
6194: PPUSH
6195: CALL_OW 88
// Say ( plat , D2a-Pla-1 ) ;
6199: LD_EXP 54
6203: PPUSH
6204: LD_STRING D2a-Pla-1
6206: PPUSH
6207: CALL_OW 88
// q1 = q diff 1 ;
6211: LD_ADDR_VAR 0 4
6215: PUSH
6216: LD_VAR 0 1
6220: PUSH
6221: LD_INT 1
6223: DIFF
6224: ST_TO_ADDR
// if q1 >= 2 then
6225: LD_VAR 0 4
6229: PUSH
6230: LD_INT 2
6232: GREATEREQUAL
6233: IFFALSE 6244
// info_q ( q1 ) ;
6235: LD_VAR 0 4
6239: PPUSH
6240: CALL 6150 0 1
// end ; 2 :
6244: GO 6383
6246: LD_INT 2
6248: DOUBLE
6249: EQUAL
6250: IFTRUE 6254
6252: GO 6314
6254: POP
// begin Say ( bur , D2b-Bur-1 ) ;
6255: LD_EXP 50
6259: PPUSH
6260: LD_STRING D2b-Bur-1
6262: PPUSH
6263: CALL_OW 88
// Say ( plat , D2b-Pla-1 ) ;
6267: LD_EXP 54
6271: PPUSH
6272: LD_STRING D2b-Pla-1
6274: PPUSH
6275: CALL_OW 88
// q1 = q diff 2 ;
6279: LD_ADDR_VAR 0 4
6283: PUSH
6284: LD_VAR 0 1
6288: PUSH
6289: LD_INT 2
6291: DIFF
6292: ST_TO_ADDR
// if q1 >= 2 then
6293: LD_VAR 0 4
6297: PUSH
6298: LD_INT 2
6300: GREATEREQUAL
6301: IFFALSE 6312
// info_q ( q1 ) ;
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 6150 0 1
// end ; 3 :
6312: GO 6383
6314: LD_INT 3
6316: DOUBLE
6317: EQUAL
6318: IFTRUE 6322
6320: GO 6382
6322: POP
// begin Say ( bur , D2c-Bur-1 ) ;
6323: LD_EXP 50
6327: PPUSH
6328: LD_STRING D2c-Bur-1
6330: PPUSH
6331: CALL_OW 88
// Say ( plat , D2c-Pla-1 ) ;
6335: LD_EXP 54
6339: PPUSH
6340: LD_STRING D2c-Pla-1
6342: PPUSH
6343: CALL_OW 88
// q1 = q diff 3 ;
6347: LD_ADDR_VAR 0 4
6351: PUSH
6352: LD_VAR 0 1
6356: PUSH
6357: LD_INT 3
6359: DIFF
6360: ST_TO_ADDR
// if q1 >= 2 then
6361: LD_VAR 0 4
6365: PUSH
6366: LD_INT 2
6368: GREATEREQUAL
6369: IFFALSE 6380
// info_q ( q1 ) ;
6371: LD_VAR 0 4
6375: PPUSH
6376: CALL 6150 0 1
// end ; end ;
6380: GO 6383
6382: POP
// end ;
6383: LD_VAR 0 2
6387: RET
// every 0 0$1 trigger stav in prilis_na_north do var pom ;
6388: LD_EXP 60
6392: PUSH
6393: LD_LOC 3
6397: IN
6398: IFFALSE 6553
6400: GO 6402
6402: DISABLE
6403: LD_INT 0
6405: PPUSH
// begin pom = FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) ;
6406: LD_ADDR_VAR 0 1
6410: PUSH
6411: LD_INT 2
6413: PPUSH
6414: LD_INT 22
6416: PUSH
6417: LD_EXP 1
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PUSH
6426: EMPTY
6427: LIST
6428: PPUSH
6429: CALL_OW 70
6433: ST_TO_ADDR
// if pom > 0 then
6434: LD_VAR 0 1
6438: PUSH
6439: LD_INT 0
6441: GREATER
6442: IFFALSE 6552
// begin ComHold ( pom ) ;
6444: LD_VAR 0 1
6448: PPUSH
6449: CALL_OW 140
// DialogueOn ;
6453: CALL_OW 6
// posli_lidi_zpet ;
6457: CALL 15912 0 0
// if bur in pom then
6461: LD_EXP 50
6465: PUSH
6466: LD_VAR 0 1
6470: IN
6471: IFFALSE 6487
// Say ( Bur , D1b-Bur-1 ) else
6473: LD_EXP 50
6477: PPUSH
6478: LD_STRING D1b-Bur-1
6480: PPUSH
6481: CALL_OW 88
6485: GO 6499
// Say ( Kov , D1b-Kov-1 ) ;
6487: LD_EXP 51
6491: PPUSH
6492: LD_STRING D1b-Kov-1
6494: PPUSH
6495: CALL_OW 88
// DialogueOff ;
6499: CALL_OW 7
// InGameOn ;
6503: CALL_OW 8
// while FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) <> 0 do
6507: LD_INT 2
6509: PPUSH
6510: LD_INT 22
6512: PUSH
6513: LD_EXP 1
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: EMPTY
6523: LIST
6524: PPUSH
6525: CALL_OW 70
6529: PUSH
6530: LD_INT 0
6532: NONEQUAL
6533: IFFALSE 6548
// begin wait ( 0 0$2 ) ;
6535: LD_INT 70
6537: PPUSH
6538: CALL_OW 67
// posli_lidi_zpet ;
6542: CALL 15912 0 0
// end ;
6546: GO 6507
// InGameOff ;
6548: CALL_OW 9
// end ; enable ;
6552: ENABLE
// end ;
6553: PPOPN 1
6555: END
// every 0 0$1 trigger FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) = 1 do var pom , pom1 ;
6556: LD_INT 1
6558: PPUSH
6559: LD_INT 22
6561: PUSH
6562: LD_EXP 1
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: LD_INT 30
6573: PUSH
6574: LD_INT 6
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PPUSH
6585: CALL_OW 70
6589: PUSH
6590: LD_INT 1
6592: EQUAL
6593: IFFALSE 6840
6595: GO 6597
6597: DISABLE
6598: LD_INT 0
6600: PPUSH
6601: PPUSH
// begin pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) ;
6602: LD_ADDR_VAR 0 1
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 22
6612: PUSH
6613: LD_EXP 1
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 30
6624: PUSH
6625: LD_INT 6
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 70
6640: ST_TO_ADDR
// pom1 = 7 ;
6641: LD_ADDR_VAR 0 2
6645: PUSH
6646: LD_INT 7
6648: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
6649: LD_VAR 0 1
6653: PUSH
6654: LD_INT 1
6656: ARRAY
6657: PPUSH
6658: CALL_OW 304
6662: PUSH
6663: LD_INT 0
6665: NONEQUAL
6666: IFFALSE 6677
// wait ( 0 0$2 ) ;
6668: LD_INT 70
6670: PPUSH
6671: CALL_OW 67
6675: GO 6649
// DialogueOn ;
6677: CALL_OW 6
// Hint ( Laboratory ) ;
6681: LD_STRING Laboratory
6683: PPUSH
6684: CALL_OW 339
// Hint ( Healing ) ;
6688: LD_STRING Healing
6690: PPUSH
6691: CALL_OW 339
// Say ( bur , D5a-Bur-1 ) ;
6695: LD_EXP 50
6699: PPUSH
6700: LD_STRING D5a-Bur-1
6702: PPUSH
6703: CALL_OW 88
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) ;
6707: LD_ADDR_VAR 0 1
6711: PUSH
6712: LD_INT 1
6714: PPUSH
6715: LD_INT 22
6717: PUSH
6718: LD_EXP 1
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: LD_INT 30
6729: PUSH
6730: LD_INT 2
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: PPUSH
6741: CALL_OW 70
6745: ST_TO_ADDR
// if pom > 0 then
6746: LD_VAR 0 1
6750: PUSH
6751: LD_INT 0
6753: GREATER
6754: IFFALSE 6775
// pom1 = IsConstructed ( pom [ 1 ] ) ;
6756: LD_ADDR_VAR 0 2
6760: PUSH
6761: LD_VAR 0 1
6765: PUSH
6766: LD_INT 1
6768: ARRAY
6769: PPUSH
6770: CALL_OW 304
6774: ST_TO_ADDR
// if pom1 = 0 then
6775: LD_VAR 0 2
6779: PUSH
6780: LD_INT 0
6782: EQUAL
6783: IFFALSE 6817
// begin Say ( plat , D5a-Pla-1 ) ;
6785: LD_EXP 54
6789: PPUSH
6790: LD_STRING D5a-Pla-1
6792: PPUSH
6793: CALL_OW 88
// ChangeMissionObjectives ( M2 ) ;
6797: LD_STRING M2
6799: PPUSH
6800: CALL_OW 337
// pokracovani_rozhovoru ;
6804: CALL 7150 0 0
// Hint ( BuildingVehicles ) ;
6808: LD_STRING BuildingVehicles
6810: PPUSH
6811: CALL_OW 339
// end else
6815: GO 6836
// begin Say ( plat , D5a-Pla-1a ) ;
6817: LD_EXP 54
6821: PPUSH
6822: LD_STRING D5a-Pla-1a
6824: PPUSH
6825: CALL_OW 88
// ChangeMissionObjectives ( M2b ) ;
6829: LD_STRING M2b
6831: PPUSH
6832: CALL_OW 337
// end ; DialogueOff ;
6836: CALL_OW 7
// end ;
6840: PPOPN 2
6842: END
// every 0 0$1 trigger FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) = 1 do var pom , pom1 ;
6843: LD_INT 1
6845: PPUSH
6846: LD_INT 22
6848: PUSH
6849: LD_EXP 1
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 30
6860: PUSH
6861: LD_INT 2
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: PPUSH
6872: CALL_OW 70
6876: PUSH
6877: LD_INT 1
6879: EQUAL
6880: IFFALSE 7147
6882: GO 6884
6884: DISABLE
6885: LD_INT 0
6887: PPUSH
6888: PPUSH
// begin pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_workshop ] ] ) ;
6889: LD_ADDR_VAR 0 1
6893: PUSH
6894: LD_INT 1
6896: PPUSH
6897: LD_INT 22
6899: PUSH
6900: LD_EXP 1
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PUSH
6909: LD_INT 30
6911: PUSH
6912: LD_INT 2
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: EMPTY
6920: LIST
6921: LIST
6922: PPUSH
6923: CALL_OW 70
6927: ST_TO_ADDR
// pom1 = 7 ;
6928: LD_ADDR_VAR 0 2
6932: PUSH
6933: LD_INT 7
6935: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
6936: LD_VAR 0 1
6940: PUSH
6941: LD_INT 1
6943: ARRAY
6944: PPUSH
6945: CALL_OW 304
6949: PUSH
6950: LD_INT 0
6952: NONEQUAL
6953: IFFALSE 6964
// wait ( 0 0$2 ) ;
6955: LD_INT 70
6957: PPUSH
6958: CALL_OW 67
6962: GO 6936
// DialogueOn ;
6964: CALL_OW 6
// if GetTech ( tech_OilEng , You ) = state_researched then
6968: LD_INT 47
6970: PPUSH
6971: LD_EXP 1
6975: PPUSH
6976: CALL_OW 321
6980: PUSH
6981: LD_INT 2
6983: EQUAL
6984: IFFALSE 6995
// Hint ( Workshop2 ) else
6986: LD_STRING Workshop2
6988: PPUSH
6989: CALL_OW 339
6993: GO 7002
// Hint ( Workshop1 ) ;
6995: LD_STRING Workshop1
6997: PPUSH
6998: CALL_OW 339
// Say ( bur , D5b-Bur-1 ) ;
7002: LD_EXP 50
7006: PPUSH
7007: LD_STRING D5b-Bur-1
7009: PPUSH
7010: CALL_OW 88
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_btype , b_lab ] ] ) ;
7014: LD_ADDR_VAR 0 1
7018: PUSH
7019: LD_INT 1
7021: PPUSH
7022: LD_INT 22
7024: PUSH
7025: LD_EXP 1
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 30
7036: PUSH
7037: LD_INT 6
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PPUSH
7048: CALL_OW 70
7052: ST_TO_ADDR
// if pom > 0 then
7053: LD_VAR 0 1
7057: PUSH
7058: LD_INT 0
7060: GREATER
7061: IFFALSE 7082
// pom1 = IsConstructed ( pom [ 1 ] ) ;
7063: LD_ADDR_VAR 0 2
7067: PUSH
7068: LD_VAR 0 1
7072: PUSH
7073: LD_INT 1
7075: ARRAY
7076: PPUSH
7077: CALL_OW 304
7081: ST_TO_ADDR
// if pom1 = 0 then
7082: LD_VAR 0 2
7086: PUSH
7087: LD_INT 0
7089: EQUAL
7090: IFFALSE 7124
// begin Say ( plat , D5b-Pla-1 ) ;
7092: LD_EXP 54
7096: PPUSH
7097: LD_STRING D5b-Pla-1
7099: PPUSH
7100: CALL_OW 88
// ChangeMissionObjectives ( M2 ) ;
7104: LD_STRING M2
7106: PPUSH
7107: CALL_OW 337
// pokracovani_rozhovoru ;
7111: CALL 7150 0 0
// Hint ( BuildingVehicles ) ;
7115: LD_STRING BuildingVehicles
7117: PPUSH
7118: CALL_OW 339
// end else
7122: GO 7143
// begin Say ( plat , D5b-Pla-1a ) ;
7124: LD_EXP 54
7128: PPUSH
7129: LD_STRING D5b-Pla-1a
7131: PPUSH
7132: CALL_OW 88
// ChangeMissionObjectives ( M2c ) ;
7136: LD_STRING M2c
7138: PPUSH
7139: CALL_OW 337
// end ; DialogueOff ;
7143: CALL_OW 7
// end ;
7147: PPOPN 2
7149: END
// function pokracovani_rozhovoru ; begin
7150: LD_INT 0
7152: PPUSH
// if Researched ( You , tech_OilEng ) then
7153: LD_EXP 1
7157: PPUSH
7158: LD_INT 47
7160: PPUSH
7161: CALL_OW 325
7165: IFFALSE 7193
// begin Say ( bur , D7b-Bur-1 ) ;
7167: LD_EXP 50
7171: PPUSH
7172: LD_STRING D7b-Bur-1
7174: PPUSH
7175: CALL_OW 88
// Say ( plat , D7b-Pla-1 ) ;
7179: LD_EXP 54
7183: PPUSH
7184: LD_STRING D7b-Pla-1
7186: PPUSH
7187: CALL_OW 88
// end else
7191: GO 7217
// begin Say ( bur , D7a-Bur-1 ) ;
7193: LD_EXP 50
7197: PPUSH
7198: LD_STRING D7a-Bur-1
7200: PPUSH
7201: CALL_OW 88
// Say ( plat , D7a-Pla-1 ) ;
7205: LD_EXP 54
7209: PPUSH
7210: LD_STRING D7a-Pla-1
7212: PPUSH
7213: CALL_OW 88
// end ; end ;
7217: LD_VAR 0 1
7221: RET
// every 0 0$1 trigger stav in is_out_base do var pom , pom1 ;
7222: LD_EXP 60
7226: PUSH
7227: LD_LOC 4
7231: IN
7232: IFFALSE 7420
7234: GO 7236
7236: DISABLE
7237: LD_INT 0
7239: PPUSH
7240: PPUSH
// begin pom = FilterUnitsInArea ( Out_base , [ [ f_side , You ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
7241: LD_ADDR_VAR 0 1
7245: PUSH
7246: LD_INT 6
7248: PPUSH
7249: LD_INT 22
7251: PUSH
7252: LD_EXP 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 2
7263: PUSH
7264: LD_INT 21
7266: PUSH
7267: LD_INT 2
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: LD_INT 21
7276: PUSH
7277: LD_INT 1
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PUSH
7284: EMPTY
7285: LIST
7286: LIST
7287: LIST
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: PPUSH
7293: CALL_OW 70
7297: ST_TO_ADDR
// if pom > 0 then
7298: LD_VAR 0 1
7302: PUSH
7303: LD_INT 0
7305: GREATER
7306: IFFALSE 7419
// begin ComHold ( pom ) ;
7308: LD_VAR 0 1
7312: PPUSH
7313: CALL_OW 140
// DialogueOn ;
7317: CALL_OW 6
// Say ( plat , D8-Pla-1 ) ;
7321: LD_EXP 54
7325: PPUSH
7326: LD_STRING D8-Pla-1
7328: PPUSH
7329: CALL_OW 88
// DialogueOff ;
7333: CALL_OW 7
// InGameOn ;
7337: CALL_OW 8
// posli_rusi_zpet_out_base ;
7341: CALL 15961 0 0
// while FilterUnitsInArea ( Out_base , [ [ f_side , You ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) <> 0 do
7345: LD_INT 6
7347: PPUSH
7348: LD_INT 22
7350: PUSH
7351: LD_EXP 1
7355: PUSH
7356: EMPTY
7357: LIST
7358: LIST
7359: PUSH
7360: LD_INT 2
7362: PUSH
7363: LD_INT 21
7365: PUSH
7366: LD_INT 2
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PUSH
7373: LD_INT 21
7375: PUSH
7376: LD_INT 1
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PUSH
7383: EMPTY
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PPUSH
7392: CALL_OW 70
7396: PUSH
7397: LD_INT 0
7399: NONEQUAL
7400: IFFALSE 7415
// begin wait ( 0 0$2 ) ;
7402: LD_INT 70
7404: PPUSH
7405: CALL_OW 67
// posli_rusi_zpet_out_base ;
7409: CALL 15961 0 0
// end ;
7413: GO 7345
// InGameOff ;
7415: CALL_OW 9
// end ; enable ;
7419: ENABLE
// end ;
7420: PPOPN 2
7422: END
// every 0 0$1 marked 300 do var pom ;
7423: GO 7425
7425: DISABLE
7426: LD_INT 0
7428: PPUSH
// begin wait ( 0 0$4 ) ;
7429: LD_INT 140
7431: PPUSH
7432: CALL_OW 67
// pom = FilterUnitsInArea ( RU2_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7436: LD_ADDR_VAR 0 1
7440: PUSH
7441: LD_INT 1
7443: PPUSH
7444: LD_INT 22
7446: PUSH
7447: LD_EXP 1
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 21
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 70
7474: ST_TO_ADDR
// DialogueOn ;
7475: CALL_OW 6
// Say ( bur , D9-Bur-1 ) ;
7479: LD_EXP 50
7483: PPUSH
7484: LD_STRING D9-Bur-1
7486: PPUSH
7487: CALL_OW 88
// Say ( plat , D9-Pla-1 ) ;
7491: LD_EXP 54
7495: PPUSH
7496: LD_STRING D9-Pla-1
7498: PPUSH
7499: CALL_OW 88
// ChangeMissionObjectives ( M3 ) ;
7503: LD_STRING M3
7505: PPUSH
7506: CALL_OW 337
// stav = 4 ;
7510: LD_ADDR_EXP 60
7514: PUSH
7515: LD_INT 4
7517: ST_TO_ADDR
// DialogueOff ;
7518: CALL_OW 7
// Hint ( Driving ) ;
7522: LD_STRING Driving
7524: PPUSH
7525: CALL_OW 339
// wait ( 0 0$10 ) ;
7529: LD_INT 350
7531: PPUSH
7532: CALL_OW 67
// end ;
7536: PPOPN 1
7538: END
// every 0 0$5 trigger stav > 3 do var pom , i ; var a ;
7539: LD_EXP 60
7543: PUSH
7544: LD_INT 3
7546: GREATER
7547: IFFALSE 7657
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
7555: PPUSH
7556: PPUSH
// begin a = false ;
7557: LD_ADDR_VAR 0 3
7561: PUSH
7562: LD_INT 0
7564: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7565: LD_ADDR_VAR 0 1
7569: PUSH
7570: LD_INT 22
7572: PUSH
7573: LD_EXP 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: LD_INT 21
7584: PUSH
7585: LD_INT 2
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PPUSH
7596: CALL_OW 69
7600: ST_TO_ADDR
// for i in pom do
7601: LD_ADDR_VAR 0 2
7605: PUSH
7606: LD_VAR 0 1
7610: PUSH
7611: FOR_IN
7612: IFFALSE 7639
// if GetLives ( i ) < 900 then
7614: LD_VAR 0 2
7618: PPUSH
7619: CALL_OW 256
7623: PUSH
7624: LD_INT 900
7626: LESS
7627: IFFALSE 7637
// a = true ;
7629: LD_ADDR_VAR 0 3
7633: PUSH
7634: LD_INT 1
7636: ST_TO_ADDR
7637: GO 7611
7639: POP
7640: POP
// if a then
7641: LD_VAR 0 3
7645: IFFALSE 7656
// Hint ( Repair ) else
7647: LD_STRING Repair
7649: PPUSH
7650: CALL_OW 339
7654: GO 7657
// enable ;
7656: ENABLE
// end ;
7657: PPOPN 3
7659: END
// every 0 0$5 trigger stav > 3 do var pom , i ; var a ;
7660: LD_EXP 60
7664: PUSH
7665: LD_INT 3
7667: GREATER
7668: IFFALSE 7778
7670: GO 7672
7672: DISABLE
7673: LD_INT 0
7675: PPUSH
7676: PPUSH
7677: PPUSH
// begin a = false ;
7678: LD_ADDR_VAR 0 3
7682: PUSH
7683: LD_INT 0
7685: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7686: LD_ADDR_VAR 0 1
7690: PUSH
7691: LD_INT 22
7693: PUSH
7694: LD_EXP 1
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: LD_INT 21
7705: PUSH
7706: LD_INT 2
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PPUSH
7717: CALL_OW 69
7721: ST_TO_ADDR
// for i in pom do
7722: LD_ADDR_VAR 0 2
7726: PUSH
7727: LD_VAR 0 1
7731: PUSH
7732: FOR_IN
7733: IFFALSE 7760
// if GetFuel ( i ) < 20 then
7735: LD_VAR 0 2
7739: PPUSH
7740: CALL_OW 261
7744: PUSH
7745: LD_INT 20
7747: LESS
7748: IFFALSE 7758
// a = true ;
7750: LD_ADDR_VAR 0 3
7754: PUSH
7755: LD_INT 1
7757: ST_TO_ADDR
7758: GO 7732
7760: POP
7761: POP
// if a then
7762: LD_VAR 0 3
7766: IFFALSE 7777
// Hint ( Fuel ) else
7768: LD_STRING Fuel
7770: PPUSH
7771: CALL_OW 339
7775: GO 7778
// enable ;
7777: ENABLE
// end ;
7778: PPOPN 3
7780: END
// every 0 0$2 trigger stav = 4 and test_is_auto_in_area do var auto ; var ridic ;
7781: LD_EXP 60
7785: PUSH
7786: LD_INT 4
7788: EQUAL
7789: PUSH
7790: CALL 15584 0 0
7794: AND
7795: IFFALSE 8228
7797: GO 7799
7799: DISABLE
7800: LD_INT 0
7802: PPUSH
7803: PPUSH
// begin disable ( 991 ) ;
7804: LD_INT 991
7806: DISABLE_MARKED
// InGameOn ;
7807: CALL_OW 8
// auto = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
7811: LD_ADDR_VAR 0 1
7815: PUSH
7816: LD_INT 3
7818: PPUSH
7819: LD_INT 22
7821: PUSH
7822: LD_EXP 1
7826: PUSH
7827: EMPTY
7828: LIST
7829: LIST
7830: PUSH
7831: LD_INT 21
7833: PUSH
7834: LD_INT 2
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 70
7849: ST_TO_ADDR
// auto = auto [ 1 ] ;
7850: LD_ADDR_VAR 0 1
7854: PUSH
7855: LD_VAR 0 1
7859: PUSH
7860: LD_INT 1
7862: ARRAY
7863: ST_TO_ADDR
// ridic = IsDrivenBy ( auto ) ;
7864: LD_ADDR_VAR 0 2
7868: PUSH
7869: LD_VAR 0 1
7873: PPUSH
7874: CALL_OW 311
7878: ST_TO_ADDR
// ComMoveXY ( ridic , 117 , 101 ) ;
7879: LD_VAR 0 2
7883: PPUSH
7884: LD_INT 117
7886: PPUSH
7887: LD_INT 101
7889: PPUSH
7890: CALL_OW 111
// CenterOnUnits ( [ auto ] ) ;
7894: LD_VAR 0 1
7898: PUSH
7899: EMPTY
7900: LIST
7901: PPUSH
7902: CALL_OW 85
// SetFuel ( [ auto ] , 100 ) ;
7906: LD_VAR 0 1
7910: PUSH
7911: EMPTY
7912: LIST
7913: PPUSH
7914: LD_INT 100
7916: PPUSH
7917: CALL_OW 240
// Say ( kurin , D10-Kur-1 ) ;
7921: LD_EXP 53
7925: PPUSH
7926: LD_STRING D10-Kur-1
7928: PPUSH
7929: CALL_OW 88
// Say ( bel , D10-Bel-1 ) ;
7933: LD_EXP 52
7937: PPUSH
7938: LD_STRING D10-Bel-1
7940: PPUSH
7941: CALL_OW 88
// ComExitVehicle ( ridic ) ;
7945: LD_VAR 0 2
7949: PPUSH
7950: CALL_OW 121
// AddComHold ( ridic ) ;
7954: LD_VAR 0 2
7958: PPUSH
7959: CALL_OW 200
// wait ( 0 0$1 ) ;
7963: LD_INT 35
7965: PPUSH
7966: CALL_OW 67
// if BELKOV_MRTVY then
7970: LD_EXP 46
7974: IFFALSE 8012
// begin Say ( bur , D10-Bur-1 ) ;
7976: LD_EXP 50
7980: PPUSH
7981: LD_STRING D10-Bur-1
7983: PPUSH
7984: CALL_OW 88
// Say ( bel , D10-Bel-2 ) ;
7988: LD_EXP 52
7992: PPUSH
7993: LD_STRING D10-Bel-2
7995: PPUSH
7996: CALL_OW 88
// Say ( bur , D10-Bur-2 ) ;
8000: LD_EXP 50
8004: PPUSH
8005: LD_STRING D10-Bur-2
8007: PPUSH
8008: CALL_OW 88
// end ; AddComHold ( ridic ) ;
8012: LD_VAR 0 2
8016: PPUSH
8017: CALL_OW 200
// if BELKOV_MRTVY then
8021: LD_EXP 46
8025: IFFALSE 8041
// Say ( kurin , D10-Kur-2a ) else
8027: LD_EXP 53
8031: PPUSH
8032: LD_STRING D10-Kur-2a
8034: PPUSH
8035: CALL_OW 88
8039: GO 8053
// Say ( kurin , D10-Kur-2 ) ;
8041: LD_EXP 53
8045: PPUSH
8046: LD_STRING D10-Kur-2
8048: PPUSH
8049: CALL_OW 88
// ComExitBuilding ( bel ) ;
8053: LD_EXP 52
8057: PPUSH
8058: CALL_OW 122
// while IsInUnit ( ridic ) <> 0 do
8062: LD_VAR 0 2
8066: PPUSH
8067: CALL_OW 310
8071: PUSH
8072: LD_INT 0
8074: NONEQUAL
8075: IFFALSE 8095
// begin wait ( 0 0$1 ) ;
8077: LD_INT 35
8079: PPUSH
8080: CALL_OW 67
// ComExitVehicle ( ridic ) ;
8084: LD_VAR 0 2
8088: PPUSH
8089: CALL_OW 121
// end ;
8093: GO 8062
// AddComEnterUnit ( bel , auto ) ;
8095: LD_EXP 52
8099: PPUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 180
// wait ( 0 0$1 ) ;
8109: LD_INT 35
8111: PPUSH
8112: CALL_OW 67
// while IsInUnit ( bel ) = 0 do
8116: LD_EXP 52
8120: PPUSH
8121: CALL_OW 310
8125: PUSH
8126: LD_INT 0
8128: EQUAL
8129: IFFALSE 8163
// begin wait ( 0 0$1 ) ;
8131: LD_INT 35
8133: PPUSH
8134: CALL_OW 67
// ComExitBuilding ( bel ) ;
8138: LD_EXP 52
8142: PPUSH
8143: CALL_OW 122
// AddComEnterUnit ( bel , auto ) ;
8147: LD_EXP 52
8151: PPUSH
8152: LD_VAR 0 1
8156: PPUSH
8157: CALL_OW 180
// end ;
8161: GO 8116
// ComFree ( ridic ) ;
8163: LD_VAR 0 2
8167: PPUSH
8168: CALL_OW 139
// Say ( kurin , D10-Kur-2b ) ;
8172: LD_EXP 53
8176: PPUSH
8177: LD_STRING D10-Kur-2b
8179: PPUSH
8180: CALL_OW 88
// ridic_1_auta = ridic ;
8184: LD_ADDR_LOC 6
8188: PUSH
8189: LD_VAR 0 2
8193: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
8194: LD_STRING M4
8196: PPUSH
8197: CALL_OW 337
// objReturn := true ;
8201: LD_ADDR_EXP 29
8205: PUSH
8206: LD_INT 1
8208: ST_TO_ADDR
// stav = 5 ;
8209: LD_ADDR_EXP 60
8213: PUSH
8214: LD_INT 5
8216: ST_TO_ADDR
// InGameOff ;
8217: CALL_OW 9
// rusi_cesta_na_sever ;
8221: CALL 14288 0 0
// enable ( 992 ) ;
8225: LD_INT 992
8227: ENABLE_MARKED
// end ;
8228: PPOPN 2
8230: END
// every 0 0$1 trigger stav = 5 and IsInArea ( ridic_1_auta , RU2_base ) do var poc , i ;
8231: LD_EXP 60
8235: PUSH
8236: LD_INT 5
8238: EQUAL
8239: PUSH
8240: LD_LOC 6
8244: PPUSH
8245: LD_INT 1
8247: PPUSH
8248: CALL_OW 308
8252: AND
8253: IFFALSE 8410
8255: GO 8257
8257: DISABLE
8258: LD_INT 0
8260: PPUSH
8261: PPUSH
// begin poc = 0 ;
8262: LD_ADDR_VAR 0 1
8266: PUSH
8267: LD_INT 0
8269: ST_TO_ADDR
// DialogueOn ;
8270: CALL_OW 6
// Say ( plat , D11-Pla-1 ) ;
8274: LD_EXP 54
8278: PPUSH
8279: LD_STRING D11-Pla-1
8281: PPUSH
8282: CALL_OW 88
// for i in Rusi_enter do
8286: LD_ADDR_VAR 0 2
8290: PUSH
8291: LD_EXP 55
8295: PUSH
8296: FOR_IN
8297: IFFALSE 8326
// if IsLive ( i ) then
8299: LD_VAR 0 2
8303: PPUSH
8304: CALL_OW 300
8308: IFFALSE 8324
// poc = poc + 1 ;
8310: LD_ADDR_VAR 0 1
8314: PUSH
8315: LD_VAR 0 1
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ST_TO_ADDR
8324: GO 8296
8326: POP
8327: POP
// if poc > 1 then
8328: LD_VAR 0 1
8332: PUSH
8333: LD_INT 1
8335: GREATER
8336: IFFALSE 8352
// Say ( bur , D11-Bur-1a ) else
8338: LD_EXP 50
8342: PPUSH
8343: LD_STRING D11-Bur-1a
8345: PPUSH
8346: CALL_OW 88
8350: GO 8364
// Say ( bur , D11-Bur-1 ) ;
8352: LD_EXP 50
8356: PPUSH
8357: LD_STRING D11-Bur-1
8359: PPUSH
8360: CALL_OW 88
// ChangeMissionObjectives ( M5 ) ;
8364: LD_STRING M5
8366: PPUSH
8367: CALL_OW 337
// objReturn := false ;
8371: LD_ADDR_EXP 29
8375: PUSH
8376: LD_INT 0
8378: ST_TO_ADDR
// CreateCratesXYR ( 2 , 64 , 83 , 6 , true ) ;
8379: LD_INT 2
8381: PPUSH
8382: LD_INT 64
8384: PPUSH
8385: LD_INT 83
8387: PPUSH
8388: LD_INT 6
8390: PPUSH
8391: LD_INT 1
8393: PPUSH
8394: CALL_OW 56
// stav = 6 ;
8398: LD_ADDR_EXP 60
8402: PUSH
8403: LD_INT 6
8405: ST_TO_ADDR
// DialogueOff ;
8406: CALL_OW 7
// end ;
8410: PPOPN 2
8412: END
// export function dialog_boreni ; begin
8413: LD_INT 0
8415: PPUSH
// Say ( plat , D6-Pla-1 ) ;
8416: LD_EXP 54
8420: PPUSH
8421: LD_STRING D6-Pla-1
8423: PPUSH
8424: CALL_OW 88
// Say ( bur , D6-Bur-1 ) ;
8428: LD_EXP 50
8432: PPUSH
8433: LD_STRING D6-Bur-1
8435: PPUSH
8436: CALL_OW 88
// end ;
8440: LD_VAR 0 1
8444: RET
// export function dialog_past_amici ; var pom , i ; begin
8445: LD_INT 0
8447: PPUSH
8448: PPUSH
8449: PPUSH
// DialogueOn ;
8450: CALL_OW 6
// CenterOnUnits ( Rusi_sever ) ;
8454: LD_EXP 56
8458: PPUSH
8459: CALL_OW 85
// wait ( 0 0$2 ) ;
8463: LD_INT 70
8465: PPUSH
8466: CALL_OW 67
// pom = UnitFilter ( Amici_past , [ [ f_ok ] , [ f_type , unit_human ] ] ) ;
8470: LD_ADDR_VAR 0 2
8474: PUSH
8475: LD_EXP 72
8479: PPUSH
8480: LD_INT 50
8482: PUSH
8483: EMPTY
8484: LIST
8485: PUSH
8486: LD_INT 21
8488: PUSH
8489: LD_INT 1
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: PPUSH
8500: CALL_OW 72
8504: ST_TO_ADDR
// for i in pom do
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_VAR 0 2
8514: PUSH
8515: FOR_IN
8516: IFFALSE 8549
// if GetSex ( i ) = sex_male then
8518: LD_VAR 0 3
8522: PPUSH
8523: CALL_OW 258
8527: PUSH
8528: LD_INT 1
8530: EQUAL
8531: IFFALSE 8547
// begin SayRadio ( i , D13-Sol1-1 ) ;
8533: LD_VAR 0 3
8537: PPUSH
8538: LD_STRING D13-Sol1-1
8540: PPUSH
8541: CALL_OW 94
// break ;
8545: GO 8549
// end ;
8547: GO 8515
8549: POP
8550: POP
// SayRadio ( bel , D13-Bel-1 ) ;
8551: LD_EXP 52
8555: PPUSH
8556: LD_STRING D13-Bel-1
8558: PPUSH
8559: CALL_OW 94
// SayRadio ( kurin , D13-Kur-1 ) ;
8563: LD_EXP 53
8567: PPUSH
8568: LD_STRING D13-Kur-1
8570: PPUSH
8571: CALL_OW 94
// SayRadio ( bel , D13-Bel-2 ) ;
8575: LD_EXP 52
8579: PPUSH
8580: LD_STRING D13-Bel-2
8582: PPUSH
8583: CALL_OW 94
// end ;
8587: LD_VAR 0 1
8591: RET
// export function rozhovor_ukonceni_m5 ; begin
8592: LD_INT 0
8594: PPUSH
// wait ( 0 0$2 ) ;
8595: LD_INT 70
8597: PPUSH
8598: CALL_OW 67
// DialogueOn ;
8602: CALL_OW 6
// Say ( bur , D12-Bur-1 ) ;
8606: LD_EXP 50
8610: PPUSH
8611: LD_STRING D12-Bur-1
8613: PPUSH
8614: CALL_OW 88
// Say ( plat , D12-Pla-1 ) ;
8618: LD_EXP 54
8622: PPUSH
8623: LD_STRING D12-Pla-1
8625: PPUSH
8626: CALL_OW 88
// Say ( bur , D12-Bur-2 ) ;
8630: LD_EXP 50
8634: PPUSH
8635: LD_STRING D12-Bur-2
8637: PPUSH
8638: CALL_OW 88
// Say ( plat , D12-Pla-2 ) ;
8642: LD_EXP 54
8646: PPUSH
8647: LD_STRING D12-Pla-2
8649: PPUSH
8650: CALL_OW 88
// Say ( bur , D12-Bur-3 ) ;
8654: LD_EXP 50
8658: PPUSH
8659: LD_STRING D12-Bur-3
8661: PPUSH
8662: CALL_OW 88
// Say ( plat , D12-Pla-3 ) ;
8666: LD_EXP 54
8670: PPUSH
8671: LD_STRING D12-Pla-3
8673: PPUSH
8674: CALL_OW 88
// ChangeMissionObjectives ( M6 ) ;
8678: LD_STRING M6
8680: PPUSH
8681: CALL_OW 337
// DialogueOff ;
8685: CALL_OW 7
// disable ( 992 ) ;
8689: LD_INT 992
8691: DISABLE_MARKED
// MissionProper ;
8692: CALL 2120 0 0
// end ;
8696: LD_VAR 0 1
8700: RET
// every 0 0$5 trigger stav = 7 do var i ; var pom ; var avideni ;
8701: LD_EXP 60
8705: PUSH
8706: LD_INT 7
8708: EQUAL
8709: IFFALSE 9498
8711: GO 8713
8713: DISABLE
8714: LD_INT 0
8716: PPUSH
8717: PPUSH
8718: PPUSH
// begin wait ( 0 0$1 ) ;
8719: LD_INT 35
8721: PPUSH
8722: CALL_OW 67
// dialog_past_amici ;
8726: CALL 8445 0 0
// CenterNowOnXY ( 58 , 17 ) ;
8730: LD_INT 58
8732: PPUSH
8733: LD_INT 17
8735: PPUSH
8736: CALL_OW 86
// ComMoveXY ( Rusi_sever , 59 , 16 ) ;
8740: LD_EXP 56
8744: PPUSH
8745: LD_INT 59
8747: PPUSH
8748: LD_INT 16
8750: PPUSH
8751: CALL_OW 111
// pom = FilterAllUnits ( [ [ f_side , You ] ] ) ;
8755: LD_ADDR_VAR 0 2
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_EXP 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: EMPTY
8773: LIST
8774: PPUSH
8775: CALL_OW 69
8779: ST_TO_ADDR
// ComStop ( pom ) ;
8780: LD_VAR 0 2
8784: PPUSH
8785: CALL_OW 141
// for i in pom do
8789: LD_ADDR_VAR 0 1
8793: PUSH
8794: LD_VAR 0 2
8798: PUSH
8799: FOR_IN
8800: IFFALSE 8818
// DoNotAttack ( Amici , i ) ;
8802: LD_EXP 2
8806: PPUSH
8807: LD_VAR 0 1
8811: PPUSH
8812: CALL_OW 471
8816: GO 8799
8818: POP
8819: POP
// DoNotAttack ( Amici , bel ) ;
8820: LD_EXP 2
8824: PPUSH
8825: LD_EXP 52
8829: PPUSH
8830: CALL_OW 471
// DialogueOff ;
8834: CALL_OW 7
// InGameOn ;
8838: CALL_OW 8
// avideni = place_amik_k_videni ;
8842: LD_ADDR_VAR 0 3
8846: PUSH
8847: CALL 5061 0 0
8851: ST_TO_ADDR
// ComMoveXY ( avideni , 55 , 11 ) ;
8852: LD_VAR 0 3
8856: PPUSH
8857: LD_INT 55
8859: PPUSH
8860: LD_INT 11
8862: PPUSH
8863: CALL_OW 111
// while FilterAllUnits ( [ [ f_side , Amici ] , [ f_see , You2 ] ] ) = 0 do
8867: LD_INT 22
8869: PUSH
8870: LD_EXP 2
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 101
8881: PUSH
8882: LD_EXP 4
8886: PUSH
8887: EMPTY
8888: LIST
8889: LIST
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: PPUSH
8895: CALL_OW 69
8899: PUSH
8900: LD_INT 0
8902: EQUAL
8903: IFFALSE 8929
// begin wait ( 0 0$03 ) ;
8905: LD_INT 105
8907: PPUSH
8908: CALL_OW 67
// ComMoveXY ( avideni , 55 , 11 ) ;
8912: LD_VAR 0 3
8916: PPUSH
8917: LD_INT 55
8919: PPUSH
8920: LD_INT 11
8922: PPUSH
8923: CALL_OW 111
// end ;
8927: GO 8867
// DoNotAttack ( Amici , auto_belkov ) ;
8929: LD_EXP 2
8933: PPUSH
8934: LD_EXP 70
8938: PPUSH
8939: CALL_OW 471
// while IsInUnit ( bel ) do
8943: LD_EXP 52
8947: PPUSH
8948: CALL_OW 310
8952: IFFALSE 8972
// begin ComExitVehicle ( bel ) ;
8954: LD_EXP 52
8958: PPUSH
8959: CALL_OW 121
// wait ( 0 0$0.1 ) ;
8963: LD_INT 4
8965: PPUSH
8966: CALL_OW 67
// end ;
8970: GO 8943
// Amici_past = Amici_past ^ avideni ;
8972: LD_ADDR_EXP 72
8976: PUSH
8977: LD_EXP 72
8981: PUSH
8982: LD_VAR 0 3
8986: ADD
8987: ST_TO_ADDR
// wait ( 0 0$0.5 ) ;
8988: LD_INT 18
8990: PPUSH
8991: CALL_OW 67
// AddComMoveXY ( bel , 47 , 7 ) ;
8995: LD_EXP 52
8999: PPUSH
9000: LD_INT 47
9002: PPUSH
9003: LD_INT 7
9005: PPUSH
9006: CALL_OW 171
// AddComMoveXY ( bel , 33 , 5 ) ;
9010: LD_EXP 52
9014: PPUSH
9015: LD_INT 33
9017: PPUSH
9018: LD_INT 5
9020: PPUSH
9021: CALL_OW 171
// AddComMoveXY ( bel , 34 , 11 ) ;
9025: LD_EXP 52
9029: PPUSH
9030: LD_INT 34
9032: PPUSH
9033: LD_INT 11
9035: PPUSH
9036: CALL_OW 171
// AddComMoveXY ( bel , 45 , 13 ) ;
9040: LD_EXP 52
9044: PPUSH
9045: LD_INT 45
9047: PPUSH
9048: LD_INT 13
9050: PPUSH
9051: CALL_OW 171
// SetLives ( IsInUnit ( bel ) , 600 ) ;
9055: LD_EXP 52
9059: PPUSH
9060: CALL_OW 310
9064: PPUSH
9065: LD_INT 600
9067: PPUSH
9068: CALL_OW 234
// ComWalk ( Amici_past ) ;
9072: LD_EXP 72
9076: PPUSH
9077: CALL_OW 138
// InGameOff ;
9081: CALL_OW 9
// DialogueOn ;
9085: CALL_OW 6
// Say ( Amici_past [ 1 ] , D14-Sol1-1 ) ;
9089: LD_EXP 72
9093: PUSH
9094: LD_INT 1
9096: ARRAY
9097: PPUSH
9098: LD_STRING D14-Sol1-1
9100: PPUSH
9101: CALL_OW 88
// DialogueOff ;
9105: CALL_OW 7
// music_class = music_combat ;
9109: LD_ADDR_OWVAR 72
9113: PUSH
9114: LD_INT 1
9116: ST_TO_ADDR
// InGameOn ;
9117: CALL_OW 8
// for i in Rusi_sever do
9121: LD_ADDR_VAR 0 1
9125: PUSH
9126: LD_EXP 56
9130: PUSH
9131: FOR_IN
9132: IFFALSE 9167
// if GetType ( i ) = unit_vehicle then
9134: LD_VAR 0 1
9138: PPUSH
9139: CALL_OW 247
9143: PUSH
9144: LD_INT 2
9146: EQUAL
9147: IFFALSE 9165
// Rusi_sever = Rusi_sever diff i ;
9149: LD_ADDR_EXP 56
9153: PUSH
9154: LD_EXP 56
9158: PUSH
9159: LD_VAR 0 1
9163: DIFF
9164: ST_TO_ADDR
9165: GO 9131
9167: POP
9168: POP
// ComMoveXY ( Rusi_sever , 47 , 7 ) ;
9169: LD_EXP 56
9173: PPUSH
9174: LD_INT 47
9176: PPUSH
9177: LD_INT 7
9179: PPUSH
9180: CALL_OW 111
// AddComMoveXY ( Rusi_sever , 33 , 5 ) ;
9184: LD_EXP 56
9188: PPUSH
9189: LD_INT 33
9191: PPUSH
9192: LD_INT 5
9194: PPUSH
9195: CALL_OW 171
// AddComMoveXY ( Rusi_sever , 34 , 11 ) ;
9199: LD_EXP 56
9203: PPUSH
9204: LD_INT 34
9206: PPUSH
9207: LD_INT 11
9209: PPUSH
9210: CALL_OW 171
// AddComMoveXY ( Rusi_sever , 45 , 13 ) ;
9214: LD_EXP 56
9218: PPUSH
9219: LD_INT 45
9221: PPUSH
9222: LD_INT 13
9224: PPUSH
9225: CALL_OW 171
// Rusi_sever = Rusi_sever ^ bel ;
9229: LD_ADDR_EXP 56
9233: PUSH
9234: LD_EXP 56
9238: PUSH
9239: LD_EXP 52
9243: ADD
9244: ST_TO_ADDR
// InGameOff ;
9245: CALL_OW 9
// DialogueOn ;
9249: CALL_OW 6
// Say ( bel , D14-Bel-1 ) ;
9253: LD_EXP 52
9257: PPUSH
9258: LD_STRING D14-Bel-1
9260: PPUSH
9261: CALL_OW 88
// DialogueOff ;
9265: CALL_OW 7
// InGameOn ;
9269: CALL_OW 8
// ComAgressiveMove ( Amici_past , 62 , 18 ) ;
9273: LD_EXP 72
9277: PPUSH
9278: LD_INT 62
9280: PPUSH
9281: LD_INT 18
9283: PPUSH
9284: CALL_OW 114
// wait ( 2 ) ;
9288: LD_INT 2
9290: PPUSH
9291: CALL_OW 67
// rusi_save_belkov ;
9295: CALL 16013 0 0
// amici_boj ;
9299: CALL 17863 0 0
// belkov_solved = 1 ;
9303: LD_ADDR_EXP 48
9307: PUSH
9308: LD_INT 1
9310: ST_TO_ADDR
// CenterOnUnits ( [ bel ] ) ;
9311: LD_EXP 52
9315: PUSH
9316: EMPTY
9317: LIST
9318: PPUSH
9319: CALL_OW 85
// wait ( 0 0$2 ) ;
9323: LD_INT 70
9325: PPUSH
9326: CALL_OW 67
// while not See ( Amici , bel ) do
9330: LD_EXP 2
9334: PPUSH
9335: LD_EXP 52
9339: PPUSH
9340: CALL_OW 292
9344: NOT
9345: IFFALSE 9370
// begin AddComMoveUnit ( Amici_past , bel ) ;
9347: LD_EXP 72
9351: PPUSH
9352: LD_EXP 52
9356: PPUSH
9357: CALL_OW 172
// wait ( 0 0$1 ) ;
9361: LD_INT 35
9363: PPUSH
9364: CALL_OW 67
// end ;
9368: GO 9330
// InGameOff ;
9370: CALL_OW 9
// DialogueOn ;
9374: CALL_OW 6
// SayRadio ( bel , D14-Bel-1a ) ;
9378: LD_EXP 52
9382: PPUSH
9383: LD_STRING D14-Bel-1a
9385: PPUSH
9386: CALL_OW 94
// SayRadio ( kurin , D14-Kur-1 ) ;
9390: LD_EXP 53
9394: PPUSH
9395: LD_STRING D14-Kur-1
9397: PPUSH
9398: CALL_OW 94
// SayRadio ( bel , D14-Bel-2 ) ;
9402: LD_EXP 52
9406: PPUSH
9407: LD_STRING D14-Bel-2
9409: PPUSH
9410: CALL_OW 94
// SayRadio ( kurin , D14-Kur-2 ) ;
9414: LD_EXP 53
9418: PPUSH
9419: LD_STRING D14-Kur-2
9421: PPUSH
9422: CALL_OW 94
// DialogueOff ;
9426: CALL_OW 7
// music_class = 0 ;
9430: LD_ADDR_OWVAR 72
9434: PUSH
9435: LD_INT 0
9437: ST_TO_ADDR
// for i in pom do
9438: LD_ADDR_VAR 0 1
9442: PUSH
9443: LD_VAR 0 2
9447: PUSH
9448: FOR_IN
9449: IFFALSE 9467
// NormalAttack ( Amici , i ) ;
9451: LD_EXP 2
9455: PPUSH
9456: LD_VAR 0 1
9460: PPUSH
9461: CALL_OW 472
9465: GO 9448
9467: POP
9468: POP
// NormalAttack ( Amici , bel ) ;
9469: LD_EXP 2
9473: PPUSH
9474: LD_EXP 52
9478: PPUSH
9479: CALL_OW 472
// amici_po_kecech ;
9483: CALL 19141 0 0
// wait ( 0 0$5 ) ;
9487: LD_INT 175
9489: PPUSH
9490: CALL_OW 67
// dialog_burlak_help ;
9494: CALL 9501 0 0
// end ;
9498: PPOPN 3
9500: END
// function dialog_burlak_help ; begin
9501: LD_INT 0
9503: PPUSH
// DialogueOn ;
9504: CALL_OW 6
// Say ( bur , D14a-Bur-1 ) ;
9508: LD_EXP 50
9512: PPUSH
9513: LD_STRING D14a-Bur-1
9515: PPUSH
9516: CALL_OW 88
// Say ( plat , D14a-Pla-1 ) ;
9520: LD_EXP 54
9524: PPUSH
9525: LD_STRING D14a-Pla-1
9527: PPUSH
9528: CALL_OW 88
// Say ( bur , D14a-Bur-2 ) ;
9532: LD_EXP 50
9536: PPUSH
9537: LD_STRING D14a-Bur-2
9539: PPUSH
9540: CALL_OW 88
// Say ( plat , D14a-Pla-2 ) ;
9544: LD_EXP 54
9548: PPUSH
9549: LD_STRING D14a-Pla-2
9551: PPUSH
9552: CALL_OW 88
// Say ( bur , D14a-Bur-3 ) ;
9556: LD_EXP 50
9560: PPUSH
9561: LD_STRING D14a-Bur-3
9563: PPUSH
9564: CALL_OW 88
// Say ( plat , D14a-Pla-3 ) ;
9568: LD_EXP 54
9572: PPUSH
9573: LD_STRING D14a-Pla-3
9575: PPUSH
9576: CALL_OW 88
// Say ( bur , D14a-Bur-4 ) ;
9580: LD_EXP 50
9584: PPUSH
9585: LD_STRING D14a-Bur-4
9587: PPUSH
9588: CALL_OW 88
// Say ( plat , D14a-Pla-4 ) ;
9592: LD_EXP 54
9596: PPUSH
9597: LD_STRING D14a-Pla-4
9599: PPUSH
9600: CALL_OW 88
// DialogueOff ;
9604: CALL_OW 7
// end ;
9608: LD_VAR 0 1
9612: RET
// every 0 0$6 trigger bedny_hint do
9613: LD_EXP 65
9617: IFFALSE 9629
9619: GO 9621
9621: DISABLE
// begin Hint ( GatheringMaterial ) ;
9622: LD_STRING GatheringMaterial
9624: PPUSH
9625: CALL_OW 339
// end ;
9629: END
// export function hlaska_platonov_bedny ; begin
9630: LD_INT 0
9632: PPUSH
// Say ( plat , D4-Pla-1 ) ;
9633: LD_EXP 54
9637: PPUSH
9638: LD_STRING D4-Pla-1
9640: PPUSH
9641: CALL_OW 88
// end ;
9645: LD_VAR 0 1
9649: RET
// function GetPeople ( sex , povolani , diffseznam ) ; var pom , pom1 , pom2 , pom3 , pom4 ; begin
9650: LD_INT 0
9652: PPUSH
9653: PPUSH
9654: PPUSH
9655: PPUSH
9656: PPUSH
9657: PPUSH
// pom1 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_scientistic ] , [ f_sex , sex ] ] ) ;
9658: LD_ADDR_VAR 0 6
9662: PUSH
9663: LD_INT 22
9665: PUSH
9666: LD_EXP 1
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 25
9677: PUSH
9678: LD_INT 4
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: PUSH
9685: LD_INT 26
9687: PUSH
9688: LD_VAR 0 1
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 69
9706: ST_TO_ADDR
// pom2 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_mechanic ] , [ f_sex , sex ] ] ) ;
9707: LD_ADDR_VAR 0 7
9711: PUSH
9712: LD_INT 22
9714: PUSH
9715: LD_EXP 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 25
9726: PUSH
9727: LD_INT 3
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: LD_INT 26
9736: PUSH
9737: LD_VAR 0 1
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: LIST
9750: PPUSH
9751: CALL_OW 69
9755: ST_TO_ADDR
// pom3 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_engineer ] , [ f_sex , sex ] ] ) ;
9756: LD_ADDR_VAR 0 8
9760: PUSH
9761: LD_INT 22
9763: PUSH
9764: LD_EXP 1
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 25
9775: PUSH
9776: LD_INT 2
9778: PUSH
9779: EMPTY
9780: LIST
9781: LIST
9782: PUSH
9783: LD_INT 26
9785: PUSH
9786: LD_VAR 0 1
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: PPUSH
9800: CALL_OW 69
9804: ST_TO_ADDR
// pom4 = FilterAllUnits ( [ [ f_side , You ] , [ f_class , class_soldier ] , [ f_sex , sex ] ] ) ;
9805: LD_ADDR_VAR 0 9
9809: PUSH
9810: LD_INT 22
9812: PUSH
9813: LD_EXP 1
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: PUSH
9822: LD_INT 25
9824: PUSH
9825: LD_INT 1
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: LD_INT 26
9834: PUSH
9835: LD_VAR 0 1
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: PUSH
9844: EMPTY
9845: LIST
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: ST_TO_ADDR
// case povolani of class_scientistic :
9854: LD_VAR 0 2
9858: PUSH
9859: LD_INT 4
9861: DOUBLE
9862: EQUAL
9863: IFTRUE 9867
9865: GO 9880
9867: POP
// pom = pom1 ; class_mechanic :
9868: LD_ADDR_VAR 0 5
9872: PUSH
9873: LD_VAR 0 6
9877: ST_TO_ADDR
9878: GO 9944
9880: LD_INT 3
9882: DOUBLE
9883: EQUAL
9884: IFTRUE 9888
9886: GO 9901
9888: POP
// pom = pom2 ; class_engineer :
9889: LD_ADDR_VAR 0 5
9893: PUSH
9894: LD_VAR 0 7
9898: ST_TO_ADDR
9899: GO 9944
9901: LD_INT 2
9903: DOUBLE
9904: EQUAL
9905: IFTRUE 9909
9907: GO 9922
9909: POP
// pom = pom3 ; class_soldier :
9910: LD_ADDR_VAR 0 5
9914: PUSH
9915: LD_VAR 0 8
9919: ST_TO_ADDR
9920: GO 9944
9922: LD_INT 1
9924: DOUBLE
9925: EQUAL
9926: IFTRUE 9930
9928: GO 9943
9930: POP
// pom = pom4 ; end ;
9931: LD_ADDR_VAR 0 5
9935: PUSH
9936: LD_VAR 0 9
9940: ST_TO_ADDR
9941: GO 9944
9943: POP
// if povolani <> class_scientistic then
9944: LD_VAR 0 2
9948: PUSH
9949: LD_INT 4
9951: NONEQUAL
9952: IFFALSE 9970
// pom = pom ^ pom1 ;
9954: LD_ADDR_VAR 0 5
9958: PUSH
9959: LD_VAR 0 5
9963: PUSH
9964: LD_VAR 0 6
9968: ADD
9969: ST_TO_ADDR
// if povolani <> class_mechanic then
9970: LD_VAR 0 2
9974: PUSH
9975: LD_INT 3
9977: NONEQUAL
9978: IFFALSE 9996
// pom = pom ^ pom2 ;
9980: LD_ADDR_VAR 0 5
9984: PUSH
9985: LD_VAR 0 5
9989: PUSH
9990: LD_VAR 0 7
9994: ADD
9995: ST_TO_ADDR
// if povolani <> class_engineer then
9996: LD_VAR 0 2
10000: PUSH
10001: LD_INT 2
10003: NONEQUAL
10004: IFFALSE 10022
// pom = pom ^ pom3 ;
10006: LD_ADDR_VAR 0 5
10010: PUSH
10011: LD_VAR 0 5
10015: PUSH
10016: LD_VAR 0 8
10020: ADD
10021: ST_TO_ADDR
// if povolani <> class_soldier then
10022: LD_VAR 0 2
10026: PUSH
10027: LD_INT 1
10029: NONEQUAL
10030: IFFALSE 10048
// pom = pom ^ pom4 ;
10032: LD_ADDR_VAR 0 5
10036: PUSH
10037: LD_VAR 0 5
10041: PUSH
10042: LD_VAR 0 9
10046: ADD
10047: ST_TO_ADDR
// result := pom diff diffseznam ;
10048: LD_ADDR_VAR 0 4
10052: PUSH
10053: LD_VAR 0 5
10057: PUSH
10058: LD_VAR 0 3
10062: DIFF
10063: ST_TO_ADDR
// end ;
10064: LD_VAR 0 4
10068: RET
// every 0 0$1 trigger test_is_in_area_burlak and venku marked 991 do var pom ;
10069: CALL 13503 0 0
10073: PUSH
10074: LD_EXP 61
10078: AND
10079: IFFALSE 10166
10081: GO 10083
10083: DISABLE
10084: LD_INT 0
10086: PPUSH
// begin pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PPUSH
10095: LD_INT 22
10097: PUSH
10098: LD_EXP 1
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: PUSH
10107: LD_INT 21
10109: PUSH
10110: LD_INT 2
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 70
10125: ST_TO_ADDR
// if pom > 0 then
10126: LD_VAR 0 1
10130: PUSH
10131: LD_INT 0
10133: GREATER
10134: IFFALSE 10138
// exit ;
10136: GO 10166
// InGameOn ;
10138: CALL_OW 8
// Say ( kurin , D1a-Kur-1 ) ;
10142: LD_EXP 53
10146: PPUSH
10147: LD_STRING D1a-Kur-1
10149: PPUSH
10150: CALL_OW 88
// InGameOff ;
10154: CALL_OW 9
// venku = false ;
10158: LD_ADDR_EXP 61
10162: PUSH
10163: LD_INT 0
10165: ST_TO_ADDR
// end ;
10166: PPOPN 1
10168: END
// every 0 0$1 trigger test_is_in_area_burlak and venku marked 992 do var pom ;
10169: CALL 13503 0 0
10173: PUSH
10174: LD_EXP 61
10178: AND
10179: IFFALSE 10267
10181: GO 10183
10183: DISABLE
10184: LD_INT 0
10186: PPUSH
// begin pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
10187: LD_ADDR_VAR 0 1
10191: PUSH
10192: LD_INT 3
10194: PPUSH
10195: LD_INT 22
10197: PUSH
10198: LD_EXP 1
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 21
10209: PUSH
10210: LD_INT 2
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PPUSH
10221: CALL_OW 70
10225: ST_TO_ADDR
// if pom > 0 then
10226: LD_VAR 0 1
10230: PUSH
10231: LD_INT 0
10233: GREATER
10234: IFFALSE 10266
// begin InGameOn ;
10236: CALL_OW 8
// Say ( kurin , D1a-Kur-1a ) ;
10240: LD_EXP 53
10244: PPUSH
10245: LD_STRING D1a-Kur-1a
10247: PPUSH
10248: CALL_OW 88
// InGameOff ;
10252: CALL_OW 9
// venku = false ;
10256: LD_ADDR_EXP 61
10260: PUSH
10261: LD_INT 0
10263: ST_TO_ADDR
// end else
10264: GO 10267
// enable ;
10266: ENABLE
// end ;
10267: PPOPN 1
10269: END
// every 0 0$2 trigger stav > 6 and not IsInArea ( bur , RU2_base ) do
10270: LD_EXP 60
10274: PUSH
10275: LD_INT 6
10277: GREATER
10278: PUSH
10279: LD_EXP 50
10283: PPUSH
10284: LD_INT 1
10286: PPUSH
10287: CALL_OW 308
10291: NOT
10292: AND
10293: IFFALSE 10307
10295: GO 10297
10297: DISABLE
// begin je_mimo = true ;
10298: LD_ADDR_LOC 7
10302: PUSH
10303: LD_INT 1
10305: ST_TO_ADDR
// enable ;
10306: ENABLE
// end ;
10307: END
// export function dialog_belkov_smrt ; var pom ; begin
10308: LD_INT 0
10310: PPUSH
10311: PPUSH
// InGameOn ;
10312: CALL_OW 8
// belkov_solved = 3 ;
10316: LD_ADDR_EXP 48
10320: PUSH
10321: LD_INT 3
10323: ST_TO_ADDR
// if pom >= procento_odkrytych_pro_vyhru [ difficulty ] and FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) = 0 then
10324: LD_VAR 0 2
10328: PUSH
10329: LD_EXP 42
10333: PUSH
10334: LD_OWVAR 67
10338: ARRAY
10339: GREATEREQUAL
10340: PUSH
10341: LD_INT 9
10343: PPUSH
10344: LD_INT 22
10346: PUSH
10347: LD_EXP 2
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: LD_INT 30
10358: PUSH
10359: LD_INT 31
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PPUSH
10370: CALL_OW 70
10374: PUSH
10375: LD_INT 0
10377: EQUAL
10378: AND
10379: IFFALSE 10398
// begin navrat_a_konec = true ;
10381: LD_ADDR_EXP 47
10385: PUSH
10386: LD_INT 1
10388: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
10389: LD_STRING M10a
10391: PPUSH
10392: CALL_OW 337
// end else
10396: GO 10405
// ChangeMissionObjectives ( M9a ) ;
10398: LD_STRING M9a
10400: PPUSH
10401: CALL_OW 337
// InGameOff ;
10405: CALL_OW 9
// end ;
10409: LD_VAR 0 1
10413: RET
// every 0 0$1 do var pom , i ; var Ru_Units ;
10414: GO 10416
10416: DISABLE
10417: LD_INT 0
10419: PPUSH
10420: PPUSH
10421: PPUSH
// begin Ru_Units = FilterAllUnits ( [ [ f_side , You ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10422: LD_ADDR_VAR 0 3
10426: PUSH
10427: LD_INT 22
10429: PUSH
10430: LD_EXP 1
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 2
10441: PUSH
10442: LD_INT 21
10444: PUSH
10445: LD_INT 1
10447: PUSH
10448: EMPTY
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 21
10454: PUSH
10455: LD_INT 2
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PPUSH
10471: CALL_OW 69
10475: ST_TO_ADDR
// for i in Ru_Units do
10476: LD_ADDR_VAR 0 2
10480: PUSH
10481: LD_VAR 0 3
10485: PUSH
10486: FOR_IN
10487: IFFALSE 10606
// begin pom = Attacks ( i ) ;
10489: LD_ADDR_VAR 0 1
10493: PUSH
10494: LD_VAR 0 2
10498: PPUSH
10499: CALL_OW 320
10503: ST_TO_ADDR
// if pom <> 0 then
10504: LD_VAR 0 1
10508: PUSH
10509: LD_INT 0
10511: NONEQUAL
10512: IFFALSE 10554
// if Getside ( pom ) in [ You2 , You3 ] then
10514: LD_VAR 0 1
10518: PPUSH
10519: CALL_OW 255
10523: PUSH
10524: LD_EXP 4
10528: PUSH
10529: LD_EXP 6
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: IN
10538: IFFALSE 10554
// konstanta_utoceni = konstanta_utoceni + 1 ;
10540: LD_ADDR_LOC 15
10544: PUSH
10545: LD_LOC 15
10549: PUSH
10550: LD_INT 1
10552: PLUS
10553: ST_TO_ADDR
// if pom = bel or pom = plat or pom = kurin then
10554: LD_VAR 0 1
10558: PUSH
10559: LD_EXP 52
10563: EQUAL
10564: PUSH
10565: LD_VAR 0 1
10569: PUSH
10570: LD_EXP 54
10574: EQUAL
10575: OR
10576: PUSH
10577: LD_VAR 0 1
10581: PUSH
10582: LD_EXP 53
10586: EQUAL
10587: OR
10588: IFFALSE 10604
// konstanta_utoceni = konstanta_utoceni + 10 ;
10590: LD_ADDR_LOC 15
10594: PUSH
10595: LD_LOC 15
10599: PUSH
10600: LD_INT 10
10602: PLUS
10603: ST_TO_ADDR
// end ;
10604: GO 10486
10606: POP
10607: POP
// if konstanta_utoceni < 10 then
10608: LD_LOC 15
10612: PUSH
10613: LD_INT 10
10615: LESS
10616: IFFALSE 10619
// enable ;
10618: ENABLE
// end ;
10619: PPOPN 3
10621: END
// every 0 0$1 trigger konstanta_utoceni >= 10 do
10622: LD_LOC 15
10626: PUSH
10627: LD_INT 10
10629: GREATEREQUAL
10630: IFFALSE 10639
10632: GO 10634
10634: DISABLE
// begin konec_mise_utok ;
10635: CALL 234 0 0
// end ;
10639: END
// export function hint_skilly ; begin
10640: LD_INT 0
10642: PPUSH
// Hint ( Skills ) ;
10643: LD_STRING Skills
10645: PPUSH
10646: CALL_OW 339
// end ;
10650: LD_VAR 0 1
10654: RET
// every 0 0$2 do var pom ; var i ; var hinton ;
10655: GO 10657
10657: DISABLE
10658: LD_INT 0
10660: PPUSH
10661: PPUSH
10662: PPUSH
// begin hinton = false ;
10663: LD_ADDR_VAR 0 3
10667: PUSH
10668: LD_INT 0
10670: ST_TO_ADDR
// pom = FilterUnitsInArea ( VEHCAP , [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) ;
10671: LD_ADDR_VAR 0 1
10675: PUSH
10676: LD_INT 30
10678: PPUSH
10679: LD_INT 22
10681: PUSH
10682: LD_EXP 2
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: PUSH
10691: LD_INT 21
10693: PUSH
10694: LD_INT 2
10696: PUSH
10697: EMPTY
10698: LIST
10699: LIST
10700: PUSH
10701: EMPTY
10702: LIST
10703: LIST
10704: PPUSH
10705: CALL_OW 70
10709: ST_TO_ADDR
// for i in pom do
10710: LD_ADDR_VAR 0 2
10714: PUSH
10715: LD_VAR 0 1
10719: PUSH
10720: FOR_IN
10721: IFFALSE 10748
// if IsDrivenBy ( i ) = 0 then
10723: LD_VAR 0 2
10727: PPUSH
10728: CALL_OW 311
10732: PUSH
10733: LD_INT 0
10735: EQUAL
10736: IFFALSE 10746
// hinton = true ;
10738: LD_ADDR_VAR 0 3
10742: PUSH
10743: LD_INT 1
10745: ST_TO_ADDR
10746: GO 10720
10748: POP
10749: POP
// if hinton then
10750: LD_VAR 0 3
10754: IFFALSE 10765
// Hint ( CapturingVehicles1 ) else
10756: LD_STRING CapturingVehicles1
10758: PPUSH
10759: CALL_OW 339
10763: GO 10766
// enable ;
10765: ENABLE
// end ;
10766: PPOPN 3
10768: END
// every 0 0$2 do var pom , i ; var BUDE_hint ;
10769: GO 10771
10771: DISABLE
10772: LD_INT 0
10774: PPUSH
10775: PPUSH
10776: PPUSH
// begin BUDE_hint = false ;
10777: LD_ADDR_VAR 0 3
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_type , unit_building ] ] ) ;
10785: LD_ADDR_VAR 0 1
10789: PUSH
10790: LD_INT 22
10792: PUSH
10793: LD_EXP 1
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 21
10804: PUSH
10805: LD_INT 3
10807: PUSH
10808: EMPTY
10809: LIST
10810: LIST
10811: PUSH
10812: EMPTY
10813: LIST
10814: LIST
10815: PPUSH
10816: CALL_OW 69
10820: ST_TO_ADDR
// for i in pom do
10821: LD_ADDR_VAR 0 2
10825: PUSH
10826: LD_VAR 0 1
10830: PUSH
10831: FOR_IN
10832: IFFALSE 10859
// if IsConstructed ( i ) <> 0 then
10834: LD_VAR 0 2
10838: PPUSH
10839: CALL_OW 304
10843: PUSH
10844: LD_INT 0
10846: NONEQUAL
10847: IFFALSE 10857
// BUDE_hint = true ;
10849: LD_ADDR_VAR 0 3
10853: PUSH
10854: LD_INT 1
10856: ST_TO_ADDR
10857: GO 10831
10859: POP
10860: POP
// if BUDE_hint then
10861: LD_VAR 0 3
10865: IFFALSE 10876
// Hint ( Building2 ) else
10867: LD_STRING Building2
10869: PPUSH
10870: CALL_OW 339
10874: GO 10877
// enable ;
10876: ENABLE
// end ; end_of_file
10877: PPOPN 3
10879: END
// var PlayingLooped ; export function play_dialog_15 ; begin
10880: LD_INT 0
10882: PPUSH
// while playing do
10883: LD_EXP 34
10887: IFFALSE 10898
// wait ( 0 0$1 ) ;
10889: LD_INT 35
10891: PPUSH
10892: CALL_OW 67
10896: GO 10883
// playing := true ;
10898: LD_ADDR_EXP 34
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// CenterOnXY ( 60 , 52 ) ;
10906: LD_INT 60
10908: PPUSH
10909: LD_INT 52
10911: PPUSH
10912: CALL_OW 84
// DialogueOn ;
10916: CALL_OW 6
// say ( Bur , D15-Bur-1 ) ;
10920: LD_EXP 50
10924: PPUSH
10925: LD_STRING D15-Bur-1
10927: PPUSH
10928: CALL_OW 88
// if IsOK ( Gny ) then
10932: LD_EXP 49
10936: PPUSH
10937: CALL_OW 302
10941: IFFALSE 10957
// say ( Gny , D15-Gny-1 ) else
10943: LD_EXP 49
10947: PPUSH
10948: LD_STRING D15-Gny-1
10950: PPUSH
10951: CALL_OW 88
10955: GO 10996
// if not BelkovFreed and IsOK ( Kov ) then
10957: LD_EXP 16
10961: NOT
10962: PUSH
10963: LD_EXP 51
10967: PPUSH
10968: CALL_OW 302
10972: AND
10973: IFFALSE 10989
// say ( Kov , D15-Kov-1 ) else
10975: LD_EXP 51
10979: PPUSH
10980: LD_STRING D15-Kov-1
10982: PPUSH
10983: CALL_OW 88
10987: GO 10996
// Wait ( 0 0$5 ) ;
10989: LD_INT 175
10991: PPUSH
10992: CALL_OW 67
// if not InWest then
10996: LD_EXP 31
11000: NOT
11001: IFFALSE 11059
// begin say ( Bur , D15-Bur-2 ) ;
11003: LD_EXP 50
11007: PPUSH
11008: LD_STRING D15-Bur-2
11010: PPUSH
11011: CALL_OW 88
// if IsOK ( Kov ) then
11015: LD_EXP 51
11019: PPUSH
11020: CALL_OW 302
11024: IFFALSE 11040
// say ( Kov , D15-Kov-2 ) else
11026: LD_EXP 51
11030: PPUSH
11031: LD_STRING D15-Kov-2
11033: PPUSH
11034: CALL_OW 88
11038: GO 11047
// wait ( 0 0$5 ) ;
11040: LD_INT 175
11042: PPUSH
11043: CALL_OW 67
// say ( Bur , D15-Bur-3 ) ;
11047: LD_EXP 50
11051: PPUSH
11052: LD_STRING D15-Bur-3
11054: PPUSH
11055: CALL_OW 88
// end ; DialogueOff ;
11059: CALL_OW 7
// CenterOnUnits ( BurlakComp ) ;
11063: LD_EXP 14
11067: PPUSH
11068: CALL_OW 85
// playing := false ;
11072: LD_ADDR_EXP 34
11076: PUSH
11077: LD_INT 0
11079: ST_TO_ADDR
// end ;
11080: LD_VAR 0 1
11084: RET
// export function play_dialog_qwbw1 ; begin
11085: LD_INT 0
11087: PPUSH
// while playing do
11088: LD_EXP 34
11092: IFFALSE 11103
// wait ( 0 0$1 ) ;
11094: LD_INT 35
11096: PPUSH
11097: CALL_OW 67
11101: GO 11088
// playing := true ;
11103: LD_ADDR_EXP 34
11107: PUSH
11108: LD_INT 1
11110: ST_TO_ADDR
// say ( Bur , D17-Bur-1 ) ;
11111: LD_EXP 50
11115: PPUSH
11116: LD_STRING D17-Bur-1
11118: PPUSH
11119: CALL_OW 88
// say ( Plat , D17-Pla-1 ) ;
11123: LD_EXP 54
11127: PPUSH
11128: LD_STRING D17-Pla-1
11130: PPUSH
11131: CALL_OW 88
// say ( Bur , D17-Bur-2 ) ;
11135: LD_EXP 50
11139: PPUSH
11140: LD_STRING D17-Bur-2
11142: PPUSH
11143: CALL_OW 88
// say ( Plat , D17-Pla-2 ) ;
11147: LD_EXP 54
11151: PPUSH
11152: LD_STRING D17-Pla-2
11154: PPUSH
11155: CALL_OW 88
// playing := false ;
11159: LD_ADDR_EXP 34
11163: PUSH
11164: LD_INT 0
11166: ST_TO_ADDR
// end ;
11167: LD_VAR 0 1
11171: RET
// export function play_dialog_qwbw2 ; begin
11172: LD_INT 0
11174: PPUSH
// while playing do
11175: LD_EXP 34
11179: IFFALSE 11190
// wait ( 0 0$1 ) ;
11181: LD_INT 35
11183: PPUSH
11184: CALL_OW 67
11188: GO 11175
// playing := true ;
11190: LD_ADDR_EXP 34
11194: PUSH
11195: LD_INT 1
11197: ST_TO_ADDR
// say ( Bur , D18-Bur-1 ) ;
11198: LD_EXP 50
11202: PPUSH
11203: LD_STRING D18-Bur-1
11205: PPUSH
11206: CALL_OW 88
// say ( Plat , D18-Pla-1 ) ;
11210: LD_EXP 54
11214: PPUSH
11215: LD_STRING D18-Pla-1
11217: PPUSH
11218: CALL_OW 88
// say ( Bur , D18-Bur-2 ) ;
11222: LD_EXP 50
11226: PPUSH
11227: LD_STRING D18-Bur-2
11229: PPUSH
11230: CALL_OW 88
// say ( Plat , D18-Pla-2 ) ;
11234: LD_EXP 54
11238: PPUSH
11239: LD_STRING D18-Pla-2
11241: PPUSH
11242: CALL_OW 88
// playing := false ;
11246: LD_ADDR_EXP 34
11250: PUSH
11251: LD_INT 0
11253: ST_TO_ADDR
// end ;
11254: LD_VAR 0 1
11258: RET
// export function play_dialog_19 ; begin
11259: LD_INT 0
11261: PPUSH
// while playing do
11262: LD_EXP 34
11266: IFFALSE 11277
// wait ( 0 0$1 ) ;
11268: LD_INT 35
11270: PPUSH
11271: CALL_OW 67
11275: GO 11262
// playing := true ;
11277: LD_ADDR_EXP 34
11281: PUSH
11282: LD_INT 1
11284: ST_TO_ADDR
// if IsOK ( Gny ) then
11285: LD_EXP 49
11289: PPUSH
11290: CALL_OW 302
11294: IFFALSE 11322
// begin say ( Gny , D19-Gny-1 ) ;
11296: LD_EXP 49
11300: PPUSH
11301: LD_STRING D19-Gny-1
11303: PPUSH
11304: CALL_OW 88
// say ( Bur , D19-Bur-1 ) ;
11308: LD_EXP 50
11312: PPUSH
11313: LD_STRING D19-Bur-1
11315: PPUSH
11316: CALL_OW 88
// end else
11320: GO 11357
// if IsOK ( Kov ) then
11322: LD_EXP 51
11326: PPUSH
11327: CALL_OW 302
11331: IFFALSE 11357
// begin say ( Kov , D19-Kov-1 ) ;
11333: LD_EXP 51
11337: PPUSH
11338: LD_STRING D19-Kov-1
11340: PPUSH
11341: CALL_OW 88
// say ( Bur , D19-Bur-2 ) ;
11345: LD_EXP 50
11349: PPUSH
11350: LD_STRING D19-Bur-2
11352: PPUSH
11353: CALL_OW 88
// end ; playing := false ;
11357: LD_ADDR_EXP 34
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// end ;
11365: LD_VAR 0 1
11369: RET
// export function play_dialog_19a ; begin
11370: LD_INT 0
11372: PPUSH
// while playing do
11373: LD_EXP 34
11377: IFFALSE 11388
// wait ( 0 0$1 ) ;
11379: LD_INT 35
11381: PPUSH
11382: CALL_OW 67
11386: GO 11373
// playing := true ;
11388: LD_ADDR_EXP 34
11392: PUSH
11393: LD_INT 1
11395: ST_TO_ADDR
// if IsOK ( Gny ) then
11396: LD_EXP 49
11400: PPUSH
11401: CALL_OW 302
11405: IFFALSE 11421
// say ( Gny , D19A-Gny-1 ) else
11407: LD_EXP 49
11411: PPUSH
11412: LD_STRING D19A-Gny-1
11414: PPUSH
11415: CALL_OW 88
11419: GO 11444
// if IsOK ( Kov ) then
11421: LD_EXP 51
11425: PPUSH
11426: CALL_OW 302
11430: IFFALSE 11444
// say ( Kov , D19A-Kov-1 ) ;
11432: LD_EXP 51
11436: PPUSH
11437: LD_STRING D19A-Kov-1
11439: PPUSH
11440: CALL_OW 88
// playing := false ;
11444: LD_ADDR_EXP 34
11448: PUSH
11449: LD_INT 0
11451: ST_TO_ADDR
// end ;
11452: LD_VAR 0 1
11456: RET
// export function play_dialog_16 ; begin
11457: LD_INT 0
11459: PPUSH
// while playing do
11460: LD_EXP 34
11464: IFFALSE 11475
// wait ( 0 0$1 ) ;
11466: LD_INT 35
11468: PPUSH
11469: CALL_OW 67
11473: GO 11460
// playing := true ;
11475: LD_ADDR_EXP 34
11479: PUSH
11480: LD_INT 1
11482: ST_TO_ADDR
// CenterOnXY ( 90 , 57 ) ;
11483: LD_INT 90
11485: PPUSH
11486: LD_INT 57
11488: PPUSH
11489: CALL_OW 84
// DialogueOn ;
11493: CALL_OW 6
// if IsOK ( Kov ) then
11497: LD_EXP 51
11501: PPUSH
11502: CALL_OW 302
11506: IFFALSE 11541
// if not WBWSpotted then
11508: LD_EXP 18
11512: NOT
11513: IFFALSE 11529
// say ( Kov , D16-Kov-1 ) else
11515: LD_EXP 51
11519: PPUSH
11520: LD_STRING D16-Kov-1
11522: PPUSH
11523: CALL_OW 88
11527: GO 11541
// say ( Kov , D16-Kov-1a ) ;
11529: LD_EXP 51
11533: PPUSH
11534: LD_STRING D16-Kov-1a
11536: PPUSH
11537: CALL_OW 88
// say ( Bur , D16-Bur-1 ) ;
11541: LD_EXP 50
11545: PPUSH
11546: LD_STRING D16-Bur-1
11548: PPUSH
11549: CALL_OW 88
// if IsOK ( Gny ) then
11553: LD_EXP 49
11557: PPUSH
11558: CALL_OW 302
11562: IFFALSE 11576
// say ( Gny , D16-Gny-1 ) ;
11564: LD_EXP 49
11568: PPUSH
11569: LD_STRING D16-Gny-1
11571: PPUSH
11572: CALL_OW 88
// DialogueOff ;
11576: CALL_OW 7
// CenterOnUnits ( BurlakComp ) ;
11580: LD_EXP 14
11584: PPUSH
11585: CALL_OW 85
// playing := false ;
11589: LD_ADDR_EXP 34
11593: PUSH
11594: LD_INT 0
11596: ST_TO_ADDR
// end ;
11597: LD_VAR 0 1
11601: RET
// export function play_dialog_20 ; begin
11602: LD_INT 0
11604: PPUSH
// while playing do
11605: LD_EXP 34
11609: IFFALSE 11620
// wait ( 0 0$1 ) ;
11611: LD_INT 35
11613: PPUSH
11614: CALL_OW 67
11618: GO 11605
// playing := true ;
11620: LD_ADDR_EXP 34
11624: PUSH
11625: LD_INT 1
11627: ST_TO_ADDR
// say ( Bur , D20-Bur-1 ) ;
11628: LD_EXP 50
11632: PPUSH
11633: LD_STRING D20-Bur-1
11635: PPUSH
11636: CALL_OW 88
// say ( Plat , D20-Pla-1 ) ;
11640: LD_EXP 54
11644: PPUSH
11645: LD_STRING D20-Pla-1
11647: PPUSH
11648: CALL_OW 88
// playing := false ;
11652: LD_ADDR_EXP 34
11656: PUSH
11657: LD_INT 0
11659: ST_TO_ADDR
// end ;
11660: LD_VAR 0 1
11664: RET
// export function play_dialog_20a ; begin
11665: LD_INT 0
11667: PPUSH
// while playing do
11668: LD_EXP 34
11672: IFFALSE 11683
// wait ( 0 0$1 ) ;
11674: LD_INT 35
11676: PPUSH
11677: CALL_OW 67
11681: GO 11668
// playing := true ;
11683: LD_ADDR_EXP 34
11687: PUSH
11688: LD_INT 1
11690: ST_TO_ADDR
// say ( Bur , D20a-Bur-1 ) ;
11691: LD_EXP 50
11695: PPUSH
11696: LD_STRING D20a-Bur-1
11698: PPUSH
11699: CALL_OW 88
// say ( Plat , D20a-Pla-1 ) ;
11703: LD_EXP 54
11707: PPUSH
11708: LD_STRING D20a-Pla-1
11710: PPUSH
11711: CALL_OW 88
// playing := false ;
11715: LD_ADDR_EXP 34
11719: PUSH
11720: LD_INT 0
11722: ST_TO_ADDR
// end ;
11723: LD_VAR 0 1
11727: RET
// export function play_dialog_qAtAm1 ; begin
11728: LD_INT 0
11730: PPUSH
// while playing do
11731: LD_EXP 34
11735: IFFALSE 11746
// wait ( 0 0$1 ) ;
11737: LD_INT 35
11739: PPUSH
11740: CALL_OW 67
11744: GO 11731
// playing := true ;
11746: LD_ADDR_EXP 34
11750: PUSH
11751: LD_INT 1
11753: ST_TO_ADDR
// say ( Bur , D21-Bur-1 ) ;
11754: LD_EXP 50
11758: PPUSH
11759: LD_STRING D21-Bur-1
11761: PPUSH
11762: CALL_OW 88
// say ( Plat , D21-Pla-1 ) ;
11766: LD_EXP 54
11770: PPUSH
11771: LD_STRING D21-Pla-1
11773: PPUSH
11774: CALL_OW 88
// playing := false ;
11778: LD_ADDR_EXP 34
11782: PUSH
11783: LD_INT 0
11785: ST_TO_ADDR
// end ;
11786: LD_VAR 0 1
11790: RET
// export function play_dialog_qAtAm2 ; begin
11791: LD_INT 0
11793: PPUSH
// while playing do
11794: LD_EXP 34
11798: IFFALSE 11809
// wait ( 0 0$1 ) ;
11800: LD_INT 35
11802: PPUSH
11803: CALL_OW 67
11807: GO 11794
// playing := true ;
11809: LD_ADDR_EXP 34
11813: PUSH
11814: LD_INT 1
11816: ST_TO_ADDR
// say ( Bur , D22-Bur-1 ) ;
11817: LD_EXP 50
11821: PPUSH
11822: LD_STRING D22-Bur-1
11824: PPUSH
11825: CALL_OW 88
// if ( not Reinforcements ) and ( WBWDestroyed ) then
11829: LD_EXP 30
11833: NOT
11834: PUSH
11835: LD_EXP 20
11839: AND
11840: IFFALSE 11856
// say ( Plat , D22-Pla-1 ) else
11842: LD_EXP 54
11846: PPUSH
11847: LD_STRING D22-Pla-1
11849: PPUSH
11850: CALL_OW 88
11854: GO 11894
// if ( Reinforcements ) and ( WBWDestroyed ) then
11856: LD_EXP 30
11860: PUSH
11861: LD_EXP 20
11865: AND
11866: IFFALSE 11882
// say ( Plat , D22-Pla-1b ) else
11868: LD_EXP 54
11872: PPUSH
11873: LD_STRING D22-Pla-1b
11875: PPUSH
11876: CALL_OW 88
11880: GO 11894
// say ( Plat , D22-Pla-1a ) ;
11882: LD_EXP 54
11886: PPUSH
11887: LD_STRING D22-Pla-1a
11889: PPUSH
11890: CALL_OW 88
// playing := false ;
11894: LD_ADDR_EXP 34
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// end ;
11902: LD_VAR 0 1
11906: RET
// export function play_dialog_23 ; begin
11907: LD_INT 0
11909: PPUSH
// while playing do
11910: LD_EXP 34
11914: IFFALSE 11925
// wait ( 0 0$1 ) ;
11916: LD_INT 35
11918: PPUSH
11919: CALL_OW 67
11923: GO 11910
// playing := true ;
11925: LD_ADDR_EXP 34
11929: PUSH
11930: LD_INT 1
11932: ST_TO_ADDR
// if IsOK ( Gny ) then
11933: LD_EXP 49
11937: PPUSH
11938: CALL_OW 302
11942: IFFALSE 11968
// begin say ( Gny , D23-Gny-1 ) ;
11944: LD_EXP 49
11948: PPUSH
11949: LD_STRING D23-Gny-1
11951: PPUSH
11952: CALL_OW 88
// say ( Bur , D23-Bur-1 ) ;
11956: LD_EXP 50
11960: PPUSH
11961: LD_STRING D23-Bur-1
11963: PPUSH
11964: CALL_OW 88
// end ; playing := false ;
11968: LD_ADDR_EXP 34
11972: PUSH
11973: LD_INT 0
11975: ST_TO_ADDR
// end ;
11976: LD_VAR 0 1
11980: RET
// export function play_dialog_24 ; begin
11981: LD_INT 0
11983: PPUSH
// while playing do
11984: LD_EXP 34
11988: IFFALSE 11999
// wait ( 0 0$1 ) ;
11990: LD_INT 35
11992: PPUSH
11993: CALL_OW 67
11997: GO 11984
// playing := true ;
11999: LD_ADDR_EXP 34
12003: PUSH
12004: LD_INT 1
12006: ST_TO_ADDR
// if not IsOK ( Bel ) then
12007: LD_EXP 52
12011: PPUSH
12012: CALL_OW 302
12016: NOT
12017: IFFALSE 12030
// begin Msg ( Bel is killed. Please report this bug. Mission will now be terminated. ) ;
12019: LD_STRING Bel is killed. Please report this bug. Mission will now be terminated.
12021: PPUSH
12022: CALL_OW 100
// konec_mise ;
12026: CALL 249 0 0
// end ; say ( Bel , D24-Bel-1 ) ;
12030: LD_EXP 52
12034: PPUSH
12035: LD_STRING D24-Bel-1
12037: PPUSH
12038: CALL_OW 88
// if BELKOV_MRTVY then
12042: LD_EXP 46
12046: IFFALSE 12062
// say ( Bur , D24-Bur-1a ) else
12048: LD_EXP 50
12052: PPUSH
12053: LD_STRING D24-Bur-1a
12055: PPUSH
12056: CALL_OW 88
12060: GO 12074
// say ( Bur , D24-Bur-1 ) ;
12062: LD_EXP 50
12066: PPUSH
12067: LD_STRING D24-Bur-1
12069: PPUSH
12070: CALL_OW 88
// say ( Bel , D24-Bel-2 ) ;
12074: LD_EXP 52
12078: PPUSH
12079: LD_STRING D24-Bel-2
12081: PPUSH
12082: CALL_OW 88
// say ( Bur , D24-Bur-2 ) ;
12086: LD_EXP 50
12090: PPUSH
12091: LD_STRING D24-Bur-2
12093: PPUSH
12094: CALL_OW 88
// if ( GetSide ( auto_belkov ) = you ) then
12098: LD_EXP 70
12102: PPUSH
12103: CALL_OW 255
12107: PUSH
12108: LD_EXP 1
12112: EQUAL
12113: IFFALSE 12127
// begin say ( Bur , D24-Bur-2a ) ;
12115: LD_EXP 50
12119: PPUSH
12120: LD_STRING D24-Bur-2a
12122: PPUSH
12123: CALL_OW 88
// end ; say ( Plat , D24-Pla-2 ) ;
12127: LD_EXP 54
12131: PPUSH
12132: LD_STRING D24-Pla-2
12134: PPUSH
12135: CALL_OW 88
// if WBWSpotted and ( not WBWDestroyed ) then
12139: LD_EXP 18
12143: PUSH
12144: LD_EXP 20
12148: NOT
12149: AND
12150: IFFALSE 12164
// begin say ( Plat , D24-Pla-2a ) ;
12152: LD_EXP 54
12156: PPUSH
12157: LD_STRING D24-Pla-2a
12159: PPUSH
12160: CALL_OW 88
// end ; playing := false ;
12164: LD_ADDR_EXP 34
12168: PUSH
12169: LD_INT 0
12171: ST_TO_ADDR
// end ;
12172: LD_VAR 0 1
12176: RET
// export function play_dialog_25 ; var SomethingNew ; begin
12177: LD_INT 0
12179: PPUSH
12180: PPUSH
// while playing do
12181: LD_EXP 34
12185: IFFALSE 12196
// wait ( 0 0$1 ) ;
12187: LD_INT 35
12189: PPUSH
12190: CALL_OW 67
12194: GO 12181
// playing := true ;
12196: LD_ADDR_EXP 34
12200: PUSH
12201: LD_INT 1
12203: ST_TO_ADDR
// say ( Plat , D25-Pla-1 ) ;
12204: LD_EXP 54
12208: PPUSH
12209: LD_STRING D25-Pla-1
12211: PPUSH
12212: CALL_OW 88
// SomethingNew := false ;
12216: LD_ADDR_VAR 0 2
12220: PUSH
12221: LD_INT 0
12223: ST_TO_ADDR
// if ( WBWSpotted ) and ( not WBWDestroyed ) and ( not WBWReported ) and ( EBWSpotted ) and ( not EBWDestroyed ) and ( not EBWReported ) then
12224: LD_EXP 18
12228: PUSH
12229: LD_EXP 20
12233: NOT
12234: AND
12235: PUSH
12236: LD_EXP 21
12240: NOT
12241: AND
12242: PUSH
12243: LD_EXP 22
12247: AND
12248: PUSH
12249: LD_EXP 23
12253: NOT
12254: AND
12255: PUSH
12256: LD_EXP 24
12260: NOT
12261: AND
12262: IFFALSE 12300
// begin say ( Bur , D25-Bur-1 ) ;
12264: LD_EXP 50
12268: PPUSH
12269: LD_STRING D25-Bur-1
12271: PPUSH
12272: CALL_OW 88
// WBWReported := true ;
12276: LD_ADDR_EXP 21
12280: PUSH
12281: LD_INT 1
12283: ST_TO_ADDR
// EBWReported := true ;
12284: LD_ADDR_EXP 24
12288: PUSH
12289: LD_INT 1
12291: ST_TO_ADDR
// SomethingNew := true ;
12292: LD_ADDR_VAR 0 2
12296: PUSH
12297: LD_INT 1
12299: ST_TO_ADDR
// end ; if EBWSpotted and ( not EBWDestroyed ) and ( not EBWReported ) then
12300: LD_EXP 22
12304: PUSH
12305: LD_EXP 23
12309: NOT
12310: AND
12311: PUSH
12312: LD_EXP 24
12316: NOT
12317: AND
12318: IFFALSE 12348
// begin say ( Bur , D25-Bur-1a ) ;
12320: LD_EXP 50
12324: PPUSH
12325: LD_STRING D25-Bur-1a
12327: PPUSH
12328: CALL_OW 88
// EBWReported := true ;
12332: LD_ADDR_EXP 24
12336: PUSH
12337: LD_INT 1
12339: ST_TO_ADDR
// SomethingNew := true ;
12340: LD_ADDR_VAR 0 2
12344: PUSH
12345: LD_INT 1
12347: ST_TO_ADDR
// end ; if WBWSpotted and ( not WBWDestroyed ) and ( not WBWReported ) then
12348: LD_EXP 18
12352: PUSH
12353: LD_EXP 20
12357: NOT
12358: AND
12359: PUSH
12360: LD_EXP 21
12364: NOT
12365: AND
12366: IFFALSE 12408
// begin say ( Bur , D25-Bur-1b ) ;
12368: LD_EXP 50
12372: PPUSH
12373: LD_STRING D25-Bur-1b
12375: PPUSH
12376: CALL_OW 88
// say ( Bur , D25b-Bur-1 ) ;
12380: LD_EXP 50
12384: PPUSH
12385: LD_STRING D25b-Bur-1
12387: PPUSH
12388: CALL_OW 88
// WBWReported := true ;
12392: LD_ADDR_EXP 21
12396: PUSH
12397: LD_INT 1
12399: ST_TO_ADDR
// SomethingNew := true ;
12400: LD_ADDR_VAR 0 2
12404: PUSH
12405: LD_INT 1
12407: ST_TO_ADDR
// end ; if ( not SomethingNew ) then
12408: LD_VAR 0 2
12412: NOT
12413: IFFALSE 12427
// say ( Bur , D25-Bur-1c ) ;
12415: LD_EXP 50
12419: PPUSH
12420: LD_STRING D25-Bur-1c
12422: PPUSH
12423: CALL_OW 88
// playing := false ;
12427: LD_ADDR_EXP 34
12431: PUSH
12432: LD_INT 0
12434: ST_TO_ADDR
// end ;
12435: LD_VAR 0 1
12439: RET
// export function play_dialog_25a ; var SomethingNew ; begin
12440: LD_INT 0
12442: PPUSH
12443: PPUSH
// while playing do
12444: LD_EXP 34
12448: IFFALSE 12459
// wait ( 0 0$1 ) ;
12450: LD_INT 35
12452: PPUSH
12453: CALL_OW 67
12457: GO 12444
// playing := true ;
12459: LD_ADDR_EXP 34
12463: PUSH
12464: LD_INT 1
12466: ST_TO_ADDR
// say ( Plat , D25a-Pla-1 ) ;
12467: LD_EXP 54
12471: PPUSH
12472: LD_STRING D25a-Pla-1
12474: PPUSH
12475: CALL_OW 88
// SomethingNew := false ;
12479: LD_ADDR_VAR 0 2
12483: PUSH
12484: LD_INT 0
12486: ST_TO_ADDR
// if WBWSpotted and ( not WBWDestroyed ) and ( not WBWReported ) then
12487: LD_EXP 18
12491: PUSH
12492: LD_EXP 20
12496: NOT
12497: AND
12498: PUSH
12499: LD_EXP 21
12503: NOT
12504: AND
12505: IFFALSE 12547
// begin say ( Bur , D25a-Bur-1b ) ;
12507: LD_EXP 50
12511: PPUSH
12512: LD_STRING D25a-Bur-1b
12514: PPUSH
12515: CALL_OW 88
// say ( Bur , D25b-Bur-1 ) ;
12519: LD_EXP 50
12523: PPUSH
12524: LD_STRING D25b-Bur-1
12526: PPUSH
12527: CALL_OW 88
// WBWReported := true ;
12531: LD_ADDR_EXP 21
12535: PUSH
12536: LD_INT 1
12538: ST_TO_ADDR
// SomethingNew := true ;
12539: LD_ADDR_VAR 0 2
12543: PUSH
12544: LD_INT 1
12546: ST_TO_ADDR
// end ; if EBWSpotted and ( not EBWDestroyed ) and ( not EBWReported ) then
12547: LD_EXP 22
12551: PUSH
12552: LD_EXP 23
12556: NOT
12557: AND
12558: PUSH
12559: LD_EXP 24
12563: NOT
12564: AND
12565: IFFALSE 12595
// begin say ( Bur , D25a-Bur-1a ) ;
12567: LD_EXP 50
12571: PPUSH
12572: LD_STRING D25a-Bur-1a
12574: PPUSH
12575: CALL_OW 88
// EBWReported := true ;
12579: LD_ADDR_EXP 24
12583: PUSH
12584: LD_INT 1
12586: ST_TO_ADDR
// SomethingNew := true ;
12587: LD_ADDR_VAR 0 2
12591: PUSH
12592: LD_INT 1
12594: ST_TO_ADDR
// end ; if ( not SomethingNew ) then
12595: LD_VAR 0 2
12599: NOT
12600: IFFALSE 12614
// say ( Bur , D25a-Bur-1 ) ;
12602: LD_EXP 50
12606: PPUSH
12607: LD_STRING D25a-Bur-1
12609: PPUSH
12610: CALL_OW 88
// playing := false ;
12614: LD_ADDR_EXP 34
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 1
12626: RET
// export function play_dialog_25b ; begin
12627: LD_INT 0
12629: PPUSH
// while playing do
12630: LD_EXP 34
12634: IFFALSE 12645
// wait ( 0 0$1 ) ;
12636: LD_INT 35
12638: PPUSH
12639: CALL_OW 67
12643: GO 12630
// playing := true ;
12645: LD_ADDR_EXP 34
12649: PUSH
12650: LD_INT 1
12652: ST_TO_ADDR
// say ( Plat , D25b-Pla-1 ) ;
12653: LD_EXP 54
12657: PPUSH
12658: LD_STRING D25b-Pla-1
12660: PPUSH
12661: CALL_OW 88
// playing := false ;
12665: LD_ADDR_EXP 34
12669: PUSH
12670: LD_INT 0
12672: ST_TO_ADDR
// end ;
12673: LD_VAR 0 1
12677: RET
// export function play_dialog_25c ; begin
12678: LD_INT 0
12680: PPUSH
// while playing do
12681: LD_EXP 34
12685: IFFALSE 12696
// wait ( 0 0$1 ) ;
12687: LD_INT 35
12689: PPUSH
12690: CALL_OW 67
12694: GO 12681
// playing := true ;
12696: LD_ADDR_EXP 34
12700: PUSH
12701: LD_INT 1
12703: ST_TO_ADDR
// if ( not WBWSpotted ) then
12704: LD_EXP 18
12708: NOT
12709: IFFALSE 12725
// say ( Plat , D25c-Pla-1 ) else
12711: LD_EXP 54
12715: PPUSH
12716: LD_STRING D25c-Pla-1
12718: PPUSH
12719: CALL_OW 88
12723: GO 12737
// say ( Plat , D25c-Pla-1a ) ;
12725: LD_EXP 54
12729: PPUSH
12730: LD_STRING D25c-Pla-1a
12732: PPUSH
12733: CALL_OW 88
// playing := false ;
12737: LD_ADDR_EXP 34
12741: PUSH
12742: LD_INT 0
12744: ST_TO_ADDR
// end ;
12745: LD_VAR 0 1
12749: RET
// every 0 0$5 do
12750: GO 12752
12752: DISABLE
// begin if Playing then
12753: LD_EXP 34
12757: IFFALSE 12775
// PlayingLooped := PlayingLooped + 1 else
12759: LD_ADDR_LOC 17
12763: PUSH
12764: LD_LOC 17
12768: PUSH
12769: LD_INT 1
12771: PLUS
12772: ST_TO_ADDR
12773: GO 12783
// PlayingLooped := 0 ;
12775: LD_ADDR_LOC 17
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if PlayingLooped >= 30 then
12783: LD_LOC 17
12787: PUSH
12788: LD_INT 30
12790: GREATEREQUAL
12791: IFFALSE 12808
// begin msg ( Playing too long. Possible bug. Please report. ) ;
12793: LD_STRING Playing too long. Possible bug. Please report.
12795: PPUSH
12796: CALL_OW 100
// Playing := false ;
12800: LD_ADDR_EXP 34
12804: PUSH
12805: LD_INT 0
12807: ST_TO_ADDR
// end ; enable end ; end_of_file
12808: ENABLE
12809: END
// export Gny ; export bur ; export Kov ; export bel ; export kurin ; export plat ; export Rusi_enter ; export Rusi_sever ; export Rusi_01 ; export rusi_survivors ; export stav_utoku ; export stav ; export venku ; export videli_w ; export videli_e ; export bedny ; export bedny_hint ; export videne ; export zasilek ; export posily_go ; export saved_bel ; export auto_belkov ; var pocet_uukazani ; var BurSk ; var BelSk ; var GnySk ; every 0 0$0.1 do var i ;
12810: GO 12812
12812: DISABLE
12813: LD_INT 0
12815: PPUSH
// begin zasilek = 0 ;
12816: LD_ADDR_EXP 67
12820: PUSH
12821: LD_INT 0
12823: ST_TO_ADDR
// bedny_hint = false ;
12824: LD_ADDR_EXP 65
12828: PUSH
12829: LD_INT 0
12831: ST_TO_ADDR
// stav = 0 ;
12832: LD_ADDR_EXP 60
12836: PUSH
12837: LD_INT 0
12839: ST_TO_ADDR
// Rusi_enter = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] ] ) ;
12840: LD_ADDR_EXP 55
12844: PUSH
12845: LD_INT 3
12847: PPUSH
12848: LD_INT 22
12850: PUSH
12851: LD_EXP 1
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PUSH
12860: EMPTY
12861: LIST
12862: PPUSH
12863: CALL_OW 70
12867: ST_TO_ADDR
// BurlakComp = Rusi_enter ;
12868: LD_ADDR_EXP 14
12872: PUSH
12873: LD_EXP 55
12877: ST_TO_ADDR
// venku = false ;
12878: LD_ADDR_EXP 61
12882: PUSH
12883: LD_INT 0
12885: ST_TO_ADDR
// stav_utoku = 0 ;
12886: LD_ADDR_EXP 59
12890: PUSH
12891: LD_INT 0
12893: ST_TO_ADDR
// videli_w = false ;
12894: LD_ADDR_EXP 62
12898: PUSH
12899: LD_INT 0
12901: ST_TO_ADDR
// videli_e = false ;
12902: LD_ADDR_EXP 63
12906: PUSH
12907: LD_INT 0
12909: ST_TO_ADDR
// bedny = [ ] ;
12910: LD_ADDR_EXP 64
12914: PUSH
12915: EMPTY
12916: ST_TO_ADDR
// videne = [ ] ;
12917: LD_ADDR_EXP 66
12921: PUSH
12922: EMPTY
12923: ST_TO_ADDR
// Rusi_sever = [ bel ] ;
12924: LD_ADDR_EXP 56
12928: PUSH
12929: LD_EXP 52
12933: PUSH
12934: EMPTY
12935: LIST
12936: ST_TO_ADDR
// Rusi_01 = [ ] ;
12937: LD_ADDR_EXP 57
12941: PUSH
12942: EMPTY
12943: ST_TO_ADDR
// posily_go = false ;
12944: LD_ADDR_EXP 68
12948: PUSH
12949: LD_INT 0
12951: ST_TO_ADDR
// saved_bel = false ;
12952: LD_ADDR_EXP 69
12956: PUSH
12957: LD_INT 0
12959: ST_TO_ADDR
// pocet_uukazani = 0 ;
12960: LD_ADDR_LOC 18
12964: PUSH
12965: LD_INT 0
12967: ST_TO_ADDR
// for i in [ 501 , 502 , 503 , 599 ] do
12968: LD_ADDR_VAR 0 1
12972: PUSH
12973: LD_INT 501
12975: PUSH
12976: LD_INT 502
12978: PUSH
12979: LD_INT 503
12981: PUSH
12982: LD_INT 599
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: PUSH
12991: FOR_IN
12992: IFFALSE 13001
// disable ( i ) ;
12994: LD_VAR 0 1
12998: DISABLE_MARKED
12999: GO 12991
13001: POP
13002: POP
// nastaveni_zacatku_skillu ;
13003: CALL 13010 0 0
// end ;
13007: PPOPN 1
13009: END
// function nastaveni_zacatku_skillu ; begin
13010: LD_INT 0
13012: PPUSH
// if IsOK ( bur ) then
13013: LD_EXP 50
13017: PPUSH
13018: CALL_OW 302
13022: IFFALSE 13087
// BurSk := [ GetSkill ( bur , 1 ) , GetSkill ( bur , 2 ) , GetSkill ( bur , 3 ) , GetSkill ( bur , 4 ) ] ;
13024: LD_ADDR_LOC 19
13028: PUSH
13029: LD_EXP 50
13033: PPUSH
13034: LD_INT 1
13036: PPUSH
13037: CALL_OW 259
13041: PUSH
13042: LD_EXP 50
13046: PPUSH
13047: LD_INT 2
13049: PPUSH
13050: CALL_OW 259
13054: PUSH
13055: LD_EXP 50
13059: PPUSH
13060: LD_INT 3
13062: PPUSH
13063: CALL_OW 259
13067: PUSH
13068: LD_EXP 50
13072: PPUSH
13073: LD_INT 4
13075: PPUSH
13076: CALL_OW 259
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: ST_TO_ADDR
// if IsOK ( Gny ) then
13087: LD_EXP 49
13091: PPUSH
13092: CALL_OW 302
13096: IFFALSE 13161
// GnySk := [ GetSkill ( Gny , 1 ) , GetSkill ( Gny , 2 ) , GetSkill ( Gny , 3 ) , GetSkill ( Gny , 4 ) ] ;
13098: LD_ADDR_LOC 21
13102: PUSH
13103: LD_EXP 49
13107: PPUSH
13108: LD_INT 1
13110: PPUSH
13111: CALL_OW 259
13115: PUSH
13116: LD_EXP 49
13120: PPUSH
13121: LD_INT 2
13123: PPUSH
13124: CALL_OW 259
13128: PUSH
13129: LD_EXP 49
13133: PPUSH
13134: LD_INT 3
13136: PPUSH
13137: CALL_OW 259
13141: PUSH
13142: LD_EXP 49
13146: PPUSH
13147: LD_INT 4
13149: PPUSH
13150: CALL_OW 259
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: ST_TO_ADDR
// if IsOK ( bel ) then
13161: LD_EXP 52
13165: PPUSH
13166: CALL_OW 302
13170: IFFALSE 13235
// BelSk := [ GetSkill ( bel , 1 ) , GetSkill ( bel , 2 ) , GetSkill ( bel , 3 ) , GetSkill ( bel , 4 ) ] ;
13172: LD_ADDR_LOC 20
13176: PUSH
13177: LD_EXP 52
13181: PPUSH
13182: LD_INT 1
13184: PPUSH
13185: CALL_OW 259
13189: PUSH
13190: LD_EXP 52
13194: PPUSH
13195: LD_INT 2
13197: PPUSH
13198: CALL_OW 259
13202: PUSH
13203: LD_EXP 52
13207: PPUSH
13208: LD_INT 3
13210: PPUSH
13211: CALL_OW 259
13215: PUSH
13216: LD_EXP 52
13220: PPUSH
13221: LD_INT 4
13223: PPUSH
13224: CALL_OW 259
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: ST_TO_ADDR
// end ;
13235: LD_VAR 0 1
13239: RET
// export function uklid_rusu ; begin
13240: LD_INT 0
13242: PPUSH
// ComEnterUnit ( RU1_vb1 , RU1_bu1 ) ;
13243: LD_INT 12
13245: PPUSH
13246: LD_INT 6
13248: PPUSH
13249: CALL_OW 120
// ComEnterUnit ( RU1_vb2 , RU1_bu2 ) ;
13253: LD_INT 13
13255: PPUSH
13256: LD_INT 14
13258: PPUSH
13259: CALL_OW 120
// ComEnterUnit ( bel , RU1_bar ) ;
13263: LD_EXP 52
13267: PPUSH
13268: LD_INT 5
13270: PPUSH
13271: CALL_OW 120
// ComEnterUnit ( RU1_sol1 , RU1_bar ) ;
13275: LD_INT 28
13277: PPUSH
13278: LD_INT 5
13280: PPUSH
13281: CALL_OW 120
// ComEnterUnit ( RU1_sol2 , RU1_bar ) ;
13285: LD_INT 29
13287: PPUSH
13288: LD_INT 5
13290: PPUSH
13291: CALL_OW 120
// ComEnterUnit ( RU1_vo1 , RU1_bar ) ;
13295: LD_INT 20
13297: PPUSH
13298: LD_INT 5
13300: PPUSH
13301: CALL_OW 120
// ComEnterUnit ( RU1_sci1 , RU1_lab ) ;
13305: LD_INT 27
13307: PPUSH
13308: LD_INT 3
13310: PPUSH
13311: CALL_OW 120
// ComEnterUnit ( RU1_sci2 , RU1_lab ) ;
13315: LD_INT 19
13317: PPUSH
13318: LD_INT 3
13320: PPUSH
13321: CALL_OW 120
// ComEnterUnit ( RU1_eng1 , RU1_dep ) ;
13325: LD_INT 18
13327: PPUSH
13328: LD_INT 1
13330: PPUSH
13331: CALL_OW 120
// ComEnterUnit ( RU1_me1 , RU1_tov ) ;
13335: LD_INT 17
13337: PPUSH
13338: LD_INT 2
13340: PPUSH
13341: CALL_OW 120
// ComMoveXY ( plat , 67 , 90 ) ;
13345: LD_EXP 54
13349: PPUSH
13350: LD_INT 67
13352: PPUSH
13353: LD_INT 90
13355: PPUSH
13356: CALL_OW 111
// AddComHold ( plat ) ;
13360: LD_EXP 54
13364: PPUSH
13365: CALL_OW 200
// ComEnterUnit ( Ru2_vb1 , Ru2_bu1 ) ;
13369: LD_INT 9
13371: PPUSH
13372: LD_INT 4
13374: PPUSH
13375: CALL_OW 120
// ComEnterUnit ( Ru2_vb2 , Ru2_bu2 ) ;
13379: LD_INT 10
13381: PPUSH
13382: LD_INT 11
13384: PPUSH
13385: CALL_OW 120
// end ;
13389: LD_VAR 0 1
13393: RET
// every 0 0$30 trigger stav > 2 and stav < 7 do var pom ;
13394: LD_EXP 60
13398: PUSH
13399: LD_INT 2
13401: GREATER
13402: PUSH
13403: LD_EXP 60
13407: PUSH
13408: LD_INT 7
13410: LESS
13411: AND
13412: IFFALSE 13473
13414: GO 13416
13416: DISABLE
13417: LD_INT 0
13419: PPUSH
// begin ComFree ( plat ) ;
13420: LD_EXP 54
13424: PPUSH
13425: CALL_OW 139
// pom = RandHexArea ( RU2_base , true ) ;
13429: LD_ADDR_VAR 0 1
13433: PUSH
13434: LD_INT 1
13436: PPUSH
13437: LD_INT 1
13439: PPUSH
13440: CALL_OW 16
13444: ST_TO_ADDR
// AddComMoveXY ( plat , pom [ 1 ] , pom [ 2 ] ) ;
13445: LD_EXP 54
13449: PPUSH
13450: LD_VAR 0 1
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: PPUSH
13459: LD_VAR 0 1
13463: PUSH
13464: LD_INT 2
13466: ARRAY
13467: PPUSH
13468: CALL_OW 171
// enable ;
13472: ENABLE
// end ;
13473: PPOPN 1
13475: END
// every 0 0$1 trigger not venku and not test_is_in_area_burlak do
13476: LD_EXP 61
13480: NOT
13481: PUSH
13482: CALL 13503 0 0
13486: NOT
13487: AND
13488: IFFALSE 13502
13490: GO 13492
13492: DISABLE
// begin venku = true ;
13493: LD_ADDR_EXP 61
13497: PUSH
13498: LD_INT 1
13500: ST_TO_ADDR
// enable ;
13501: ENABLE
// end ;
13502: END
// export function test_is_in_area_burlak ; var a ; var pom , i ; begin
13503: LD_INT 0
13505: PPUSH
13506: PPUSH
13507: PPUSH
13508: PPUSH
// a = false ;
13509: LD_ADDR_VAR 0 2
13513: PUSH
13514: LD_INT 0
13516: ST_TO_ADDR
// if IsInArea ( bur , RU1_base ) then
13517: LD_EXP 50
13521: PPUSH
13522: LD_INT 3
13524: PPUSH
13525: CALL_OW 308
13529: IFFALSE 13539
// a = true ;
13531: LD_ADDR_VAR 0 2
13535: PUSH
13536: LD_INT 1
13538: ST_TO_ADDR
// pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
13539: LD_ADDR_VAR 0 3
13543: PUSH
13544: LD_INT 3
13546: PPUSH
13547: LD_INT 22
13549: PUSH
13550: LD_EXP 1
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 21
13561: PUSH
13562: LD_INT 2
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 70
13577: ST_TO_ADDR
// if pom > 0 then
13578: LD_VAR 0 3
13582: PUSH
13583: LD_INT 0
13585: GREATER
13586: IFFALSE 13630
// for i in pom do
13588: LD_ADDR_VAR 0 4
13592: PUSH
13593: LD_VAR 0 3
13597: PUSH
13598: FOR_IN
13599: IFFALSE 13628
// if IsDrivenBy ( i ) = bur then
13601: LD_VAR 0 4
13605: PPUSH
13606: CALL_OW 311
13610: PUSH
13611: LD_EXP 50
13615: EQUAL
13616: IFFALSE 13626
// a = true ;
13618: LD_ADDR_VAR 0 2
13622: PUSH
13623: LD_INT 1
13625: ST_TO_ADDR
13626: GO 13598
13628: POP
13629: POP
// result = a ;
13630: LD_ADDR_VAR 0 1
13634: PUSH
13635: LD_VAR 0 2
13639: ST_TO_ADDR
// end ;
13640: LD_VAR 0 1
13644: RET
// every 0 0$7 do var pom ;
13645: GO 13647
13647: DISABLE
13648: LD_INT 0
13650: PPUSH
// begin pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_breastwork ] , [ f_nation , nation_russian ] ] ) ;
13651: LD_ADDR_VAR 0 1
13655: PUSH
13656: LD_INT 22
13658: PUSH
13659: LD_EXP 1
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: LD_INT 30
13670: PUSH
13671: LD_INT 31
13673: PUSH
13674: EMPTY
13675: LIST
13676: LIST
13677: PUSH
13678: LD_INT 23
13680: PUSH
13681: LD_INT 3
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: PUSH
13688: EMPTY
13689: LIST
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: ST_TO_ADDR
// if pom > 0 then
13698: LD_VAR 0 1
13702: PUSH
13703: LD_INT 0
13705: GREATER
13706: IFFALSE 13720
// destroy ( pom , b_breastwork ) ;
13708: LD_VAR 0 1
13712: PPUSH
13713: LD_INT 31
13715: PPUSH
13716: CALL 13862 0 2
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_armoury ] , [ f_nation , nation_russian ] ] ) ;
13720: LD_ADDR_VAR 0 1
13724: PUSH
13725: LD_INT 22
13727: PUSH
13728: LD_EXP 1
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: LD_INT 30
13739: PUSH
13740: LD_INT 4
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PUSH
13747: LD_INT 23
13749: PUSH
13750: LD_INT 3
13752: PUSH
13753: EMPTY
13754: LIST
13755: LIST
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: LIST
13761: PPUSH
13762: CALL_OW 69
13766: ST_TO_ADDR
// if pom > 0 then
13767: LD_VAR 0 1
13771: PUSH
13772: LD_INT 0
13774: GREATER
13775: IFFALSE 13789
// destroy ( pom , b_armoury ) ;
13777: LD_VAR 0 1
13781: PPUSH
13782: LD_INT 4
13784: PPUSH
13785: CALL 13862 0 2
// pom = FilterAllUnits ( [ [ f_side , You ] , [ f_btype , b_oil_power ] , [ f_nation , nation_russian ] ] ) ;
13789: LD_ADDR_VAR 0 1
13793: PUSH
13794: LD_INT 22
13796: PUSH
13797: LD_EXP 1
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: PUSH
13806: LD_INT 30
13808: PUSH
13809: LD_INT 26
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PUSH
13816: LD_INT 23
13818: PUSH
13819: LD_INT 3
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: LIST
13830: PPUSH
13831: CALL_OW 69
13835: ST_TO_ADDR
// if pom > 0 then
13836: LD_VAR 0 1
13840: PUSH
13841: LD_INT 0
13843: GREATER
13844: IFFALSE 13858
// destroy ( pom , b_oil_power ) ;
13846: LD_VAR 0 1
13850: PPUSH
13851: LD_INT 26
13853: PPUSH
13854: CALL 13862 0 2
// enable ;
13858: ENABLE
// end ;
13859: PPOPN 1
13861: END
// function destroy ( sez , typ ) ; var i , j ; var pom ; var res ; begin
13862: LD_INT 0
13864: PPUSH
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// InGameOn ;
13869: CALL_OW 8
// dialog_boreni ;
13873: CALL 8413 0 0
// for i in sez do
13877: LD_ADDR_VAR 0 4
13881: PUSH
13882: LD_VAR 0 1
13886: PUSH
13887: FOR_IN
13888: IFFALSE 14072
// begin pom = UnitsInside ( i ) ;
13890: LD_ADDR_VAR 0 6
13894: PUSH
13895: LD_VAR 0 4
13899: PPUSH
13900: CALL_OW 313
13904: ST_TO_ADDR
// ComExitBuilding ( pom ) ;
13905: LD_VAR 0 6
13909: PPUSH
13910: CALL_OW 122
// wait ( 0 0$2 ) ;
13914: LD_INT 70
13916: PPUSH
13917: CALL_OW 67
// DestroyUnit ( i ) ;
13921: LD_VAR 0 4
13925: PPUSH
13926: CALL_OW 65
// case typ of b_breastwork :
13930: LD_VAR 0 2
13934: PUSH
13935: LD_INT 31
13937: DOUBLE
13938: EQUAL
13939: IFTRUE 13943
13941: GO 13964
13943: POP
// res = [ [ mat_cans , 10 ] ] ; b_armoury :
13944: LD_ADDR_VAR 0 7
13948: PUSH
13949: LD_INT 1
13951: PUSH
13952: LD_INT 10
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: EMPTY
13960: LIST
13961: ST_TO_ADDR
13962: GO 14023
13964: LD_INT 4
13966: DOUBLE
13967: EQUAL
13968: IFTRUE 13972
13970: GO 13993
13972: POP
// res = [ [ mat_cans , 30 ] ] ; b_oil_power :
13973: LD_ADDR_VAR 0 7
13977: PUSH
13978: LD_INT 1
13980: PUSH
13981: LD_INT 30
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PUSH
13988: EMPTY
13989: LIST
13990: ST_TO_ADDR
13991: GO 14023
13993: LD_INT 26
13995: DOUBLE
13996: EQUAL
13997: IFTRUE 14001
13999: GO 14022
14001: POP
// res = [ [ mat_cans , 20 ] ] ; end ;
14002: LD_ADDR_VAR 0 7
14006: PUSH
14007: LD_INT 1
14009: PUSH
14010: LD_INT 20
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: EMPTY
14018: LIST
14019: ST_TO_ADDR
14020: GO 14023
14022: POP
// for j in res do
14023: LD_ADDR_VAR 0 5
14027: PUSH
14028: LD_VAR 0 7
14032: PUSH
14033: FOR_IN
14034: IFFALSE 14068
// AddResourceType ( GetBase ( RU2_dep ) , j [ 1 ] , j [ 2 ] ) ;
14036: LD_INT 26
14038: PPUSH
14039: CALL_OW 274
14043: PPUSH
14044: LD_VAR 0 5
14048: PUSH
14049: LD_INT 1
14051: ARRAY
14052: PPUSH
14053: LD_VAR 0 5
14057: PUSH
14058: LD_INT 2
14060: ARRAY
14061: PPUSH
14062: CALL_OW 276
14066: GO 14033
14068: POP
14069: POP
// end ;
14070: GO 13887
14072: POP
14073: POP
// InGameOff ;
14074: CALL_OW 9
// end ;
14078: LD_VAR 0 3
14082: RET
// on McDone ( ID , state ) do var u , w , dist , tol , Arrived ;
14083: LD_INT 0
14085: PPUSH
14086: PPUSH
14087: PPUSH
14088: PPUSH
14089: PPUSH
// begin tol := 8 ;
14090: LD_ADDR_VAR 0 6
14094: PUSH
14095: LD_INT 8
14097: ST_TO_ADDR
// if ID <> McCestaNaSever then
14098: LD_VAR 0 1
14102: PUSH
14103: LD_EXP 36
14107: NONEQUAL
14108: IFFALSE 14112
// exit ;
14110: GO 14285
// repeat Arrived := true ;
14112: LD_ADDR_VAR 0 7
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// for u in Rusi_sever do
14120: LD_ADDR_VAR 0 3
14124: PUSH
14125: LD_EXP 56
14129: PUSH
14130: FOR_IN
14131: IFFALSE 14270
// if GetDistUnitXY ( u , wptCestaNaSever [ wptCestaNaSever ] [ 1 ] , wptCestaNaSever [ wptCestaNaSever ] [ 2 ] ) > tol then
14133: LD_VAR 0 3
14137: PPUSH
14138: LD_EXP 71
14142: PUSH
14143: LD_EXP 71
14147: ARRAY
14148: PUSH
14149: LD_INT 1
14151: ARRAY
14152: PPUSH
14153: LD_EXP 71
14157: PUSH
14158: LD_EXP 71
14162: ARRAY
14163: PUSH
14164: LD_INT 2
14166: ARRAY
14167: PPUSH
14168: CALL_OW 297
14172: PUSH
14173: LD_VAR 0 6
14177: GREATER
14178: IFFALSE 14268
// begin Arrived := false ;
14180: LD_ADDR_VAR 0 7
14184: PUSH
14185: LD_INT 0
14187: ST_TO_ADDR
// ComStop ( u ) ;
14188: LD_VAR 0 3
14192: PPUSH
14193: CALL_OW 141
// for w in wptCestaNaSever do
14197: LD_ADDR_VAR 0 4
14201: PUSH
14202: LD_EXP 71
14206: PUSH
14207: FOR_IN
14208: IFFALSE 14266
// begin if GetY ( u ) > w [ 2 ] + tol then
14210: LD_VAR 0 3
14214: PPUSH
14215: CALL_OW 251
14219: PUSH
14220: LD_VAR 0 4
14224: PUSH
14225: LD_INT 2
14227: ARRAY
14228: PUSH
14229: LD_VAR 0 6
14233: PLUS
14234: GREATER
14235: IFFALSE 14264
// begin AddComMoveXY ( u , w [ 1 ] , w [ 2 ] ) ;
14237: LD_VAR 0 3
14241: PPUSH
14242: LD_VAR 0 4
14246: PUSH
14247: LD_INT 1
14249: ARRAY
14250: PPUSH
14251: LD_VAR 0 4
14255: PUSH
14256: LD_INT 2
14258: ARRAY
14259: PPUSH
14260: CALL_OW 171
// end ; end ;
14264: GO 14207
14266: POP
14267: POP
// end ;
14268: GO 14130
14270: POP
14271: POP
// wait ( 0 0$15 ) until Arrived ;
14272: LD_INT 525
14274: PPUSH
14275: CALL_OW 67
14279: LD_VAR 0 7
14283: IFFALSE 14112
// end ;
14285: PPOPN 7
14287: END
// export wptCestaNaSever ; export function rusi_cesta_na_sever ; var pom ; begin
14288: LD_INT 0
14290: PPUSH
14291: PPUSH
// if rusi_survivors < 3 then
14292: LD_EXP 58
14296: PUSH
14297: LD_INT 3
14299: LESS
14300: IFFALSE 14327
// rusi_survivors = rusi_survivors ^ [ RU1_sol1 , RU1_sol2 , RU1_sci1 ] ;
14302: LD_ADDR_EXP 58
14306: PUSH
14307: LD_EXP 58
14311: PUSH
14312: LD_INT 28
14314: PUSH
14315: LD_INT 29
14317: PUSH
14318: LD_INT 27
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: ADD
14326: ST_TO_ADDR
// Rusi_01 = rusi_survivors ;
14327: LD_ADDR_EXP 57
14331: PUSH
14332: LD_EXP 58
14336: ST_TO_ADDR
// pom = [ IsInUnit ( bel ) , Rusi_01 [ 1 ] , Rusi_01 [ 2 ] , Rusi_01 [ 3 ] ] ;
14337: LD_ADDR_VAR 0 2
14341: PUSH
14342: LD_EXP 52
14346: PPUSH
14347: CALL_OW 310
14351: PUSH
14352: LD_EXP 57
14356: PUSH
14357: LD_INT 1
14359: ARRAY
14360: PUSH
14361: LD_EXP 57
14365: PUSH
14366: LD_INT 2
14368: ARRAY
14369: PUSH
14370: LD_EXP 57
14374: PUSH
14375: LD_INT 3
14377: ARRAY
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: ST_TO_ADDR
// ComExitBuilding ( [ Rusi_01 [ 1 ] , Rusi_01 [ 2 ] , Rusi_01 [ 3 ] ] ) ;
14385: LD_EXP 57
14389: PUSH
14390: LD_INT 1
14392: ARRAY
14393: PUSH
14394: LD_EXP 57
14398: PUSH
14399: LD_INT 2
14401: ARRAY
14402: PUSH
14403: LD_EXP 57
14407: PUSH
14408: LD_INT 3
14410: ARRAY
14411: PUSH
14412: EMPTY
14413: LIST
14414: LIST
14415: LIST
14416: PPUSH
14417: CALL_OW 122
// wptCestaNaSever := [ [ 87 , 93 ] , [ 77 , 74 ] , [ 68 , 58 ] , [ 66 , 46 ] , [ 59 , 28 ] , [ 59 , 12 ] ] ;
14421: LD_ADDR_EXP 71
14425: PUSH
14426: LD_INT 87
14428: PUSH
14429: LD_INT 93
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PUSH
14436: LD_INT 77
14438: PUSH
14439: LD_INT 74
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PUSH
14446: LD_INT 68
14448: PUSH
14449: LD_INT 58
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 66
14458: PUSH
14459: LD_INT 46
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 59
14468: PUSH
14469: LD_INT 28
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: LD_INT 59
14478: PUSH
14479: LD_INT 12
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: ST_TO_ADDR
// mcCestaNaSever = McMove ( 1 , pom , wptCestaNaSever , [ mc_move_waitwp ] ) ;
14494: LD_ADDR_EXP 36
14498: PUSH
14499: LD_INT 1
14501: PPUSH
14502: LD_VAR 0 2
14506: PPUSH
14507: LD_EXP 71
14511: PPUSH
14512: LD_INT 3
14514: PUSH
14515: EMPTY
14516: LIST
14517: PPUSH
14518: CALL_OW 398
14522: ST_TO_ADDR
// Rusi_sever = pom ;
14523: LD_ADDR_EXP 56
14527: PUSH
14528: LD_VAR 0 2
14532: ST_TO_ADDR
// rusi_survivors = Rusi_01 diff pom ;
14533: LD_ADDR_EXP 58
14537: PUSH
14538: LD_EXP 57
14542: PUSH
14543: LD_VAR 0 2
14547: DIFF
14548: ST_TO_ADDR
// repeat wait ( 0 0$5 ) until ( FilterUnitsInArea ( RU1_base , [ ] ) isect Rusi_sever ) = 0 ;
14549: LD_INT 175
14551: PPUSH
14552: CALL_OW 67
14556: LD_INT 3
14558: PPUSH
14559: EMPTY
14560: PPUSH
14561: CALL_OW 70
14565: PUSH
14566: LD_EXP 56
14570: ISECT
14571: PUSH
14572: LD_INT 0
14574: EQUAL
14575: IFFALSE 14549
// wait ( 1 1$0 ) ;
14577: LD_INT 2100
14579: PPUSH
14580: CALL_OW 67
// stavba_am_baze ;
14584: CALL 17032 0 0
// end ;
14588: LD_VAR 0 1
14592: RET
// every 0 0$4 do var pom ;
14593: GO 14595
14595: DISABLE
14596: LD_INT 0
14598: PPUSH
// begin pom = FilterUnitsInArea ( Test2 , [ [ f_side , You2 ] ] ) ;
14599: LD_ADDR_VAR 0 1
14603: PUSH
14604: LD_INT 10
14606: PPUSH
14607: LD_INT 22
14609: PUSH
14610: LD_EXP 4
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: PUSH
14619: EMPTY
14620: LIST
14621: PPUSH
14622: CALL_OW 70
14626: ST_TO_ADDR
// if pom + 0 = Rusi_sever + 0 then
14627: LD_VAR 0 1
14631: PUSH
14632: LD_INT 0
14634: PLUS
14635: PUSH
14636: LD_EXP 56
14640: PUSH
14641: LD_INT 0
14643: PLUS
14644: EQUAL
14645: IFFALSE 14654
// begin manage_rusi_sever ;
14647: CALL 15660 0 0
// disable ;
14651: DISABLE
// end else
14652: GO 14655
// enable ;
14654: ENABLE
// end ;
14655: PPOPN 1
14657: END
// every 0 0$20 trigger stav > 2 and stav < 7 do var i ; var misto ;
14658: LD_EXP 60
14662: PUSH
14663: LD_INT 2
14665: GREATER
14666: PUSH
14667: LD_EXP 60
14671: PUSH
14672: LD_INT 7
14674: LESS
14675: AND
14676: IFFALSE 14964
14678: GO 14680
14680: DISABLE
14681: LD_INT 0
14683: PPUSH
14684: PPUSH
// begin misto = [ ] ;
14685: LD_ADDR_VAR 0 2
14689: PUSH
14690: EMPTY
14691: ST_TO_ADDR
// for i in bedny do
14692: LD_ADDR_VAR 0 1
14696: PUSH
14697: LD_EXP 64
14701: PUSH
14702: FOR_IN
14703: IFFALSE 14789
// if SeeXY ( You2 , i [ 1 ] , i [ 2 ] ) then
14705: LD_EXP 4
14709: PPUSH
14710: LD_VAR 0 1
14714: PUSH
14715: LD_INT 1
14717: ARRAY
14718: PPUSH
14719: LD_VAR 0 1
14723: PUSH
14724: LD_INT 2
14726: ARRAY
14727: PPUSH
14728: CALL_OW 293
14732: IFFALSE 14787
// if i in videne then
14734: LD_VAR 0 1
14738: PUSH
14739: LD_EXP 66
14743: IN
14744: IFFALSE 14758
// misto = misto else
14746: LD_ADDR_VAR 0 2
14750: PUSH
14751: LD_VAR 0 2
14755: ST_TO_ADDR
14756: GO 14787
// begin misto = i ;
14758: LD_ADDR_VAR 0 2
14762: PUSH
14763: LD_VAR 0 1
14767: ST_TO_ADDR
// videne = videne ^ [ i ] ;
14768: LD_ADDR_EXP 66
14772: PUSH
14773: LD_EXP 66
14777: PUSH
14778: LD_VAR 0 1
14782: PUSH
14783: EMPTY
14784: LIST
14785: ADD
14786: ST_TO_ADDR
// end ;
14787: GO 14702
14789: POP
14790: POP
// if misto <> 0 then
14791: LD_VAR 0 2
14795: PUSH
14796: LD_INT 0
14798: NONEQUAL
14799: IFFALSE 14936
// begin bedny_hint = true ;
14801: LD_ADDR_EXP 65
14805: PUSH
14806: LD_INT 1
14808: ST_TO_ADDR
// ComMoveXY ( plat , misto [ 1 ] , misto [ 2 ] ) ;
14809: LD_EXP 54
14813: PPUSH
14814: LD_VAR 0 2
14818: PUSH
14819: LD_INT 1
14821: ARRAY
14822: PPUSH
14823: LD_VAR 0 2
14827: PUSH
14828: LD_INT 2
14830: ARRAY
14831: PPUSH
14832: CALL_OW 111
// wait ( 0 0$5 ) ;
14836: LD_INT 175
14838: PPUSH
14839: CALL_OW 67
// if HexInfo ( misto [ 1 ] , misto [ 2 ] ) <> 0 or HexInfo ( misto [ 1 ] , misto [ 2 ] ) <> plat then
14843: LD_VAR 0 2
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: PPUSH
14852: LD_VAR 0 2
14856: PUSH
14857: LD_INT 2
14859: ARRAY
14860: PPUSH
14861: CALL_OW 428
14865: PUSH
14866: LD_INT 0
14868: NONEQUAL
14869: PUSH
14870: LD_VAR 0 2
14874: PUSH
14875: LD_INT 1
14877: ARRAY
14878: PPUSH
14879: LD_VAR 0 2
14883: PUSH
14884: LD_INT 2
14886: ARRAY
14887: PPUSH
14888: CALL_OW 428
14892: PUSH
14893: LD_EXP 54
14897: NONEQUAL
14898: OR
14899: IFFALSE 14936
// begin hlaska_platonov_bedny ;
14901: CALL 9630 0 0
// pocet_uukazani = pocet_uukazani + 1 ;
14905: LD_ADDR_LOC 18
14909: PUSH
14910: LD_LOC 18
14914: PUSH
14915: LD_INT 1
14917: PLUS
14918: ST_TO_ADDR
// debug_strings = [ Platonov bvedny , pocet_uukazani ] ;
14919: LD_ADDR_OWVAR 48
14923: PUSH
14924: LD_STRING Platonov bvedny
14926: PUSH
14927: LD_LOC 18
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: ST_TO_ADDR
// end ; end ; debug_strings = [ Platonov bvedny , pocet_uukazani ] ;
14936: LD_ADDR_OWVAR 48
14940: PUSH
14941: LD_STRING Platonov bvedny
14943: PUSH
14944: LD_LOC 18
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: ST_TO_ADDR
// if pocet_uukazani < 6 then
14953: LD_LOC 18
14957: PUSH
14958: LD_INT 6
14960: LESS
14961: IFFALSE 14964
// enable ;
14963: ENABLE
// end ;
14964: PPOPN 2
14966: END
// every 0 0$13 trigger stav > 2 and stav < 7 do var i ; var a ;
14967: LD_EXP 60
14971: PUSH
14972: LD_INT 2
14974: GREATER
14975: PUSH
14976: LD_EXP 60
14980: PUSH
14981: LD_INT 7
14983: LESS
14984: AND
14985: IFFALSE 15076
14987: GO 14989
14989: DISABLE
14990: LD_INT 0
14992: PPUSH
14993: PPUSH
// begin a = [ ] ;
14994: LD_ADDR_VAR 0 2
14998: PUSH
14999: EMPTY
15000: ST_TO_ADDR
// for i in bedny do
15001: LD_ADDR_VAR 0 1
15005: PUSH
15006: LD_EXP 64
15010: PUSH
15011: FOR_IN
15012: IFFALSE 15063
// if GetResourceAmountXY ( i [ 1 ] , i [ 2 ] ) <> 0 then
15014: LD_VAR 0 1
15018: PUSH
15019: LD_INT 1
15021: ARRAY
15022: PPUSH
15023: LD_VAR 0 1
15027: PUSH
15028: LD_INT 2
15030: ARRAY
15031: PPUSH
15032: CALL_OW 284
15036: PUSH
15037: LD_INT 0
15039: NONEQUAL
15040: IFFALSE 15061
// a = a ^ [ i ] ;
15042: LD_ADDR_VAR 0 2
15046: PUSH
15047: LD_VAR 0 2
15051: PUSH
15052: LD_VAR 0 1
15056: PUSH
15057: EMPTY
15058: LIST
15059: ADD
15060: ST_TO_ADDR
15061: GO 15011
15063: POP
15064: POP
// bedny = a ;
15065: LD_ADDR_EXP 64
15069: PUSH
15070: LD_VAR 0 2
15074: ST_TO_ADDR
// enable ;
15075: ENABLE
// end ;
15076: PPOPN 2
15078: END
// every 0 0$10 trigger stav = 3 do var hex ;
15079: LD_EXP 60
15083: PUSH
15084: LD_INT 3
15086: EQUAL
15087: IFFALSE 15219
15089: GO 15091
15091: DISABLE
15092: LD_INT 0
15094: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$0 ) ) ;
15095: LD_INT 1050
15097: PPUSH
15098: LD_INT 2100
15100: PPUSH
15101: CALL_OW 12
15105: PPUSH
15106: CALL_OW 67
// hex = RandHexArea ( bedny_ar , true ) ;
15110: LD_ADDR_VAR 0 1
15114: PUSH
15115: LD_INT 28
15117: PPUSH
15118: LD_INT 1
15120: PPUSH
15121: CALL_OW 16
15125: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15126: LD_VAR 0 1
15130: PUSH
15131: LD_INT 1
15133: ARRAY
15134: PPUSH
15135: LD_VAR 0 1
15139: PUSH
15140: LD_INT 2
15142: ARRAY
15143: PPUSH
15144: CALL_OW 428
15148: PUSH
15149: LD_INT 0
15151: NONEQUAL
15152: IFFALSE 15172
// hex = RandHexArea ( bedny_ar , true ) ;
15154: LD_ADDR_VAR 0 1
15158: PUSH
15159: LD_INT 28
15161: PPUSH
15162: LD_INT 1
15164: PPUSH
15165: CALL_OW 16
15169: ST_TO_ADDR
15170: GO 15126
// CreateCratesXY ( 4 , hex [ 1 ] , hex [ 2 ] , true ) ;
15172: LD_INT 4
15174: PPUSH
15175: LD_VAR 0 1
15179: PUSH
15180: LD_INT 1
15182: ARRAY
15183: PPUSH
15184: LD_VAR 0 1
15188: PUSH
15189: LD_INT 2
15191: ARRAY
15192: PPUSH
15193: LD_INT 1
15195: PPUSH
15196: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15200: LD_ADDR_EXP 64
15204: PUSH
15205: LD_EXP 64
15209: PUSH
15210: LD_VAR 0 1
15214: PUSH
15215: EMPTY
15216: LIST
15217: ADD
15218: ST_TO_ADDR
// end ;
15219: PPOPN 1
15221: END
// every 0 0$10 trigger stav >= 6 and stav < 7 do var hex ;
15222: LD_EXP 60
15226: PUSH
15227: LD_INT 6
15229: GREATEREQUAL
15230: PUSH
15231: LD_EXP 60
15235: PUSH
15236: LD_INT 7
15238: LESS
15239: AND
15240: IFFALSE 15395
15242: GO 15244
15244: DISABLE
15245: LD_INT 0
15247: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
15248: LD_INT 1050
15250: PPUSH
15251: LD_INT 3150
15253: PPUSH
15254: CALL_OW 12
15258: PPUSH
15259: CALL_OW 67
// hex = RandHexArea ( bedny_ar , true ) ;
15263: LD_ADDR_VAR 0 1
15267: PUSH
15268: LD_INT 28
15270: PPUSH
15271: LD_INT 1
15273: PPUSH
15274: CALL_OW 16
15278: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15279: LD_VAR 0 1
15283: PUSH
15284: LD_INT 1
15286: ARRAY
15287: PPUSH
15288: LD_VAR 0 1
15292: PUSH
15293: LD_INT 2
15295: ARRAY
15296: PPUSH
15297: CALL_OW 428
15301: PUSH
15302: LD_INT 0
15304: NONEQUAL
15305: IFFALSE 15325
// hex = RandHexArea ( bedny_ar , true ) ;
15307: LD_ADDR_VAR 0 1
15311: PUSH
15312: LD_INT 28
15314: PPUSH
15315: LD_INT 1
15317: PPUSH
15318: CALL_OW 16
15322: ST_TO_ADDR
15323: GO 15279
// CreateCratesXY ( Rand ( 3 , 5 ) , hex [ 1 ] , hex [ 2 ] , true ) ;
15325: LD_INT 3
15327: PPUSH
15328: LD_INT 5
15330: PPUSH
15331: CALL_OW 12
15335: PPUSH
15336: LD_VAR 0 1
15340: PUSH
15341: LD_INT 1
15343: ARRAY
15344: PPUSH
15345: LD_VAR 0 1
15349: PUSH
15350: LD_INT 2
15352: ARRAY
15353: PPUSH
15354: LD_INT 1
15356: PPUSH
15357: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15361: LD_ADDR_EXP 64
15365: PUSH
15366: LD_EXP 64
15370: PUSH
15371: LD_VAR 0 1
15375: PUSH
15376: EMPTY
15377: LIST
15378: ADD
15379: ST_TO_ADDR
// zasilek = zasilek + 1 ;
15380: LD_ADDR_EXP 67
15384: PUSH
15385: LD_EXP 67
15389: PUSH
15390: LD_INT 1
15392: PLUS
15393: ST_TO_ADDR
// enable ;
15394: ENABLE
// end ;
15395: PPOPN 1
15397: END
// every 0 0$10 trigger stav >= 5 and stav < 7 marked 503 do var hex ;
15398: LD_EXP 60
15402: PUSH
15403: LD_INT 5
15405: GREATEREQUAL
15406: PUSH
15407: LD_EXP 60
15411: PUSH
15412: LD_INT 7
15414: LESS
15415: AND
15416: IFFALSE 15581
15418: GO 15420
15420: DISABLE
15421: LD_INT 0
15423: PPUSH
// begin wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
15424: LD_INT 1050
15426: PPUSH
15427: LD_INT 3150
15429: PPUSH
15430: CALL_OW 12
15434: PPUSH
15435: CALL_OW 67
// hex = RandHexArea ( RU2_base , true ) ;
15439: LD_ADDR_VAR 0 1
15443: PUSH
15444: LD_INT 1
15446: PPUSH
15447: LD_INT 1
15449: PPUSH
15450: CALL_OW 16
15454: ST_TO_ADDR
// while HexInfo ( hex [ 1 ] , hex [ 2 ] ) <> 0 do
15455: LD_VAR 0 1
15459: PUSH
15460: LD_INT 1
15462: ARRAY
15463: PPUSH
15464: LD_VAR 0 1
15468: PUSH
15469: LD_INT 2
15471: ARRAY
15472: PPUSH
15473: CALL_OW 428
15477: PUSH
15478: LD_INT 0
15480: NONEQUAL
15481: IFFALSE 15501
// hex = RandHexArea ( RU2_base , true ) ;
15483: LD_ADDR_VAR 0 1
15487: PUSH
15488: LD_INT 1
15490: PPUSH
15491: LD_INT 1
15493: PPUSH
15494: CALL_OW 16
15498: ST_TO_ADDR
15499: GO 15455
// CreateCratesXY ( Rand ( 3 , 5 ) , hex [ 1 ] , hex [ 2 ] , true ) ;
15501: LD_INT 3
15503: PPUSH
15504: LD_INT 5
15506: PPUSH
15507: CALL_OW 12
15511: PPUSH
15512: LD_VAR 0 1
15516: PUSH
15517: LD_INT 1
15519: ARRAY
15520: PPUSH
15521: LD_VAR 0 1
15525: PUSH
15526: LD_INT 2
15528: ARRAY
15529: PPUSH
15530: LD_INT 1
15532: PPUSH
15533: CALL_OW 54
// bedny = bedny ^ [ hex ] ;
15537: LD_ADDR_EXP 64
15541: PUSH
15542: LD_EXP 64
15546: PUSH
15547: LD_VAR 0 1
15551: PUSH
15552: EMPTY
15553: LIST
15554: ADD
15555: ST_TO_ADDR
// zasilek = zasilek + 1 ;
15556: LD_ADDR_EXP 67
15560: PUSH
15561: LD_EXP 67
15565: PUSH
15566: LD_INT 1
15568: PLUS
15569: ST_TO_ADDR
// if zasilek < 4 then
15570: LD_EXP 67
15574: PUSH
15575: LD_INT 4
15577: LESS
15578: IFFALSE 15581
// enable ;
15580: ENABLE
// end ;
15581: PPOPN 1
15583: END
// export function test_is_auto_in_area ; var pom ; begin
15584: LD_INT 0
15586: PPUSH
15587: PPUSH
// pom = FilterUnitsInArea ( RU1_base , [ [ f_side , You ] , [ f_type , unit_vehicle ] ] ) ;
15588: LD_ADDR_VAR 0 2
15592: PUSH
15593: LD_INT 3
15595: PPUSH
15596: LD_INT 22
15598: PUSH
15599: LD_EXP 1
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PUSH
15608: LD_INT 21
15610: PUSH
15611: LD_INT 2
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: EMPTY
15619: LIST
15620: LIST
15621: PPUSH
15622: CALL_OW 70
15626: ST_TO_ADDR
// if pom > 0 then
15627: LD_VAR 0 2
15631: PUSH
15632: LD_INT 0
15634: GREATER
15635: IFFALSE 15647
// result = true else
15637: LD_ADDR_VAR 0 1
15641: PUSH
15642: LD_INT 1
15644: ST_TO_ADDR
15645: GO 15655
// result = false ;
15647: LD_ADDR_VAR 0 1
15651: PUSH
15652: LD_INT 0
15654: ST_TO_ADDR
// end ;
15655: LD_VAR 0 1
15659: RET
// function manage_rusi_sever ; begin
15660: LD_INT 0
15662: PPUSH
// wait ( 0 0$20 ) ;
15663: LD_INT 700
15665: PPUSH
15666: CALL_OW 67
// ComMoveXY ( Rusi_sever , 90 , 25 ) ;
15670: LD_EXP 56
15674: PPUSH
15675: LD_INT 90
15677: PPUSH
15678: LD_INT 25
15680: PPUSH
15681: CALL_OW 111
// end ;
15685: LD_VAR 0 1
15689: RET
// every 0 0$1 trigger FilterUnitsInArea ( Odber_bel , [ [ f_side , You2 ] ] ) > 0 do var pom , i ;
15690: LD_INT 14
15692: PPUSH
15693: LD_INT 22
15695: PUSH
15696: LD_EXP 4
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PUSH
15705: EMPTY
15706: LIST
15707: PPUSH
15708: CALL_OW 70
15712: PUSH
15713: LD_INT 0
15715: GREATER
15716: IFFALSE 15826
15718: GO 15720
15720: DISABLE
15721: LD_INT 0
15723: PPUSH
15724: PPUSH
// begin pom = FilterUnitsInArea ( Odber_bel , [ [ f_side , You2 ] ] ) ;
15725: LD_ADDR_VAR 0 1
15729: PUSH
15730: LD_INT 14
15732: PPUSH
15733: LD_INT 22
15735: PUSH
15736: LD_EXP 4
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: EMPTY
15746: LIST
15747: PPUSH
15748: CALL_OW 70
15752: ST_TO_ADDR
// for i in pom do
15753: LD_ADDR_VAR 0 2
15757: PUSH
15758: LD_VAR 0 1
15762: PUSH
15763: FOR_IN
15764: IFFALSE 15789
// if i in Rusi_sever then
15766: LD_VAR 0 2
15770: PUSH
15771: LD_EXP 56
15775: IN
15776: IFFALSE 15787
// RemoveUnit ( i ) ;
15778: LD_VAR 0 2
15782: PPUSH
15783: CALL_OW 64
15787: GO 15763
15789: POP
15790: POP
// pom = UnitFilter ( Rusi_sever , [ [ f_OK ] ] ) ;
15791: LD_ADDR_VAR 0 1
15795: PUSH
15796: LD_EXP 56
15800: PPUSH
15801: LD_INT 50
15803: PUSH
15804: EMPTY
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: PPUSH
15810: CALL_OW 72
15814: ST_TO_ADDR
// if pom > 0 then
15815: LD_VAR 0 1
15819: PUSH
15820: LD_INT 0
15822: GREATER
15823: IFFALSE 15826
// enable ;
15825: ENABLE
// end ;
15826: PPOPN 2
15828: END
// every 0 0$1 trigger belkov_returns do
15829: LD_EXP 8
15833: IFFALSE 15846
15835: GO 15837
15837: DISABLE
// begin placni_amiky_past ;
15838: CALL 16870 0 0
// placni_zpet_rusy_sever ;
15842: CALL 15847 0 0
// end ;
15846: END
// function placni_zpet_rusy_sever ; var i ; begin
15847: LD_INT 0
15849: PPUSH
15850: PPUSH
// for i in Rusi_sever do
15851: LD_ADDR_VAR 0 2
15855: PUSH
15856: LD_EXP 56
15860: PUSH
15861: FOR_IN
15862: IFFALSE 15881
// PlaceUnitArea ( i , Zpet_bel , false ) ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 15
15871: PPUSH
15872: LD_INT 0
15874: PPUSH
15875: CALL_OW 49
15879: GO 15861
15881: POP
15882: POP
// ComMoveXY ( Rusi_sever , 56 , 9 ) ;
15883: LD_EXP 56
15887: PPUSH
15888: LD_INT 56
15890: PPUSH
15891: LD_INT 9
15893: PPUSH
15894: CALL_OW 111
// AddComHold ( Rusi_sever ) ;
15898: LD_EXP 56
15902: PPUSH
15903: CALL_OW 200
// end ;
15907: LD_VAR 0 1
15911: RET
// export function posli_lidi_zpet ; var pom ; begin
15912: LD_INT 0
15914: PPUSH
15915: PPUSH
// pom = FilterUnitsInArea ( Upozarea , [ [ f_side , You ] ] ) ;
15916: LD_ADDR_VAR 0 2
15920: PUSH
15921: LD_INT 2
15923: PPUSH
15924: LD_INT 22
15926: PUSH
15927: LD_EXP 1
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: EMPTY
15937: LIST
15938: PPUSH
15939: CALL_OW 70
15943: ST_TO_ADDR
// ComMoveToArea ( pom , RU2_base ) ;
15944: LD_VAR 0 2
15948: PPUSH
15949: LD_INT 1
15951: PPUSH
15952: CALL_OW 113
// end ;
15956: LD_VAR 0 1
15960: RET
// export function posli_rusi_zpet_out_base ; var pom ; begin
15961: LD_INT 0
15963: PPUSH
15964: PPUSH
// pom = FilterUnitsInArea ( Out_base , [ [ f_side , You ] ] ) ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_INT 6
15972: PPUSH
15973: LD_INT 22
15975: PUSH
15976: LD_EXP 1
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PUSH
15985: EMPTY
15986: LIST
15987: PPUSH
15988: CALL_OW 70
15992: ST_TO_ADDR
// ComMoveXY ( pom , 66 , 91 ) ;
15993: LD_VAR 0 2
15997: PPUSH
15998: LD_INT 66
16000: PPUSH
16001: LD_INT 91
16003: PPUSH
16004: CALL_OW 111
// end ;
16008: LD_VAR 0 1
16012: RET
// export function rusi_save_belkov ; begin
16013: LD_INT 0
16015: PPUSH
// enable ( 501 ) ;
16016: LD_INT 501
16018: ENABLE_MARKED
// enable ( 502 ) ;
16019: LD_INT 502
16021: ENABLE_MARKED
// enable ( 599 ) ;
16022: LD_INT 599
16024: ENABLE_MARKED
// end ;
16025: LD_VAR 0 1
16029: RET
// every 0 0$1 trigger GetLives ( bel ) < 800 marked 501 do
16030: LD_EXP 52
16034: PPUSH
16035: CALL_OW 256
16039: PUSH
16040: LD_INT 800
16042: LESS
16043: IFFALSE 16061
16045: GO 16047
16047: DISABLE
// begin SetLives ( bel , 800 ) ;
16048: LD_EXP 52
16052: PPUSH
16053: LD_INT 800
16055: PPUSH
16056: CALL_OW 234
// enable ;
16060: ENABLE
// end ;
16061: END
// every 0 0$1 trigger saved_bel do
16062: LD_EXP 69
16066: IFFALSE 16074
16068: GO 16070
16070: DISABLE
// begin disable ( 501 ) ;
16071: LD_INT 501
16073: DISABLE_MARKED
// end ;
16074: END
// every 0 0$1 trigger GetSide ( bel ) = You marked 599 do
16075: LD_EXP 52
16079: PPUSH
16080: CALL_OW 255
16084: PUSH
16085: LD_EXP 1
16089: EQUAL
16090: IFFALSE 16098
16092: GO 16094
16094: DISABLE
// begin disable ( 501 ) ;
16095: LD_INT 501
16097: DISABLE_MARKED
// end ;
16098: END
// every 0 0$1 marked 502 do var i ; var pom ;
16099: GO 16101
16101: DISABLE
16102: LD_INT 0
16104: PPUSH
16105: PPUSH
// begin pom = false ;
16106: LD_ADDR_VAR 0 2
16110: PUSH
16111: LD_INT 0
16113: ST_TO_ADDR
// wait ( cas_na_zachranu_belkova [ difficulty ] ) ;
16114: LD_EXP 43
16118: PUSH
16119: LD_OWVAR 67
16123: ARRAY
16124: PPUSH
16125: CALL_OW 67
// disable ( 501 ) ;
16129: LD_INT 501
16131: DISABLE_MARKED
// if IsOK ( bel ) and ( not saved_bel ) then
16132: LD_EXP 52
16136: PPUSH
16137: CALL_OW 302
16141: PUSH
16142: LD_EXP 69
16146: NOT
16147: AND
16148: IFFALSE 16154
// amici_attack_belkov ;
16150: CALL 18211 0 0
// while ( FilterUnitsInArea ( Belkov_kop , [ f_side , You2 ] ) + 0 > 0 ) and ( UnitFilter ( AMICI_UTOK_BELKOV_LIST , [ f_OK ] ) + 0 > 0 ) do
16154: LD_INT 25
16156: PPUSH
16157: LD_INT 22
16159: PUSH
16160: LD_EXP 4
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PPUSH
16169: CALL_OW 70
16173: PUSH
16174: LD_INT 0
16176: PLUS
16177: PUSH
16178: LD_INT 0
16180: GREATER
16181: PUSH
16182: LD_EXP 39
16186: PPUSH
16187: LD_INT 50
16189: PUSH
16190: EMPTY
16191: LIST
16192: PPUSH
16193: CALL_OW 72
16197: PUSH
16198: LD_INT 0
16200: PLUS
16201: PUSH
16202: LD_INT 0
16204: GREATER
16205: AND
16206: IFFALSE 16266
// begin wait ( 0 0$1 ) ;
16208: LD_INT 35
16210: PPUSH
16211: CALL_OW 67
// if objBelkov and IsDead ( bel ) and GetSide ( bel ) = 6 then
16215: LD_EXP 28
16219: PUSH
16220: LD_EXP 52
16224: PPUSH
16225: CALL_OW 301
16229: AND
16230: PUSH
16231: LD_EXP 52
16235: PPUSH
16236: CALL_OW 255
16240: PUSH
16241: LD_INT 6
16243: EQUAL
16244: AND
16245: IFFALSE 16264
// begin belkovSave = false ;
16247: LD_ADDR_EXP 10
16251: PUSH
16252: LD_INT 0
16254: ST_TO_ADDR
// wait ( 1 ) ;
16255: LD_INT 1
16257: PPUSH
16258: CALL_OW 67
// exit ;
16262: GO 16270
// end ; end ;
16264: GO 16154
// amici_retreat ;
16266: CALL 18358 0 0
// end ;
16270: PPOPN 2
16272: END
// every 0 0$2 trigger saved_bel do
16273: LD_EXP 69
16277: IFFALSE 16285
16279: GO 16281
16281: DISABLE
// begin disable ( 502 ) ;
16282: LD_INT 502
16284: DISABLE_MARKED
// end ;
16285: END
// export function create_rusi_navic ; var pom , i ; begin
16286: LD_INT 0
16288: PPUSH
16289: PPUSH
16290: PPUSH
// if CheckCharacterSet ( survivors1 ) then
16291: LD_STRING survivors1
16293: PPUSH
16294: CALL_OW 29
16298: IFFALSE 16315
// pom = CreateCharacterSet ( survivors1 ) else
16300: LD_ADDR_VAR 0 2
16304: PUSH
16305: LD_STRING survivors1
16307: PPUSH
16308: CALL_OW 31
16312: ST_TO_ADDR
16313: GO 16322
// pom = [ ] ;
16315: LD_ADDR_VAR 0 2
16319: PUSH
16320: EMPTY
16321: ST_TO_ADDR
// for i in pom do
16322: LD_ADDR_VAR 0 3
16326: PUSH
16327: LD_VAR 0 2
16331: PUSH
16332: FOR_IN
16333: IFFALSE 16372
// begin SetSide ( i , You2 ) ;
16335: LD_VAR 0 3
16339: PPUSH
16340: LD_EXP 4
16344: PPUSH
16345: CALL_OW 235
// PlaceUnitXYR ( i , 129 , 111 , 5 , false ) ;
16349: LD_VAR 0 3
16353: PPUSH
16354: LD_INT 129
16356: PPUSH
16357: LD_INT 111
16359: PPUSH
16360: LD_INT 5
16362: PPUSH
16363: LD_INT 0
16365: PPUSH
16366: CALL_OW 50
// end ;
16370: GO 16332
16372: POP
16373: POP
// if pom <> 0 then
16374: LD_VAR 0 2
16378: PUSH
16379: LD_INT 0
16381: NONEQUAL
16382: IFFALSE 16396
// ComEnterUnit ( pom , RU1_tov ) ;
16384: LD_VAR 0 2
16388: PPUSH
16389: LD_INT 2
16391: PPUSH
16392: CALL_OW 120
// rusi_survivors = pom ;
16396: LD_ADDR_EXP 58
16400: PUSH
16401: LD_VAR 0 2
16405: ST_TO_ADDR
// end ;
16406: LD_VAR 0 1
16410: RET
// every 0 0$5 do var zmena ;
16411: GO 16413
16413: DISABLE
16414: LD_INT 0
16416: PPUSH
// begin zmena = false ;
16417: LD_ADDR_VAR 0 1
16421: PUSH
16422: LD_INT 0
16424: ST_TO_ADDR
// if IsOk ( bur ) then
16425: LD_EXP 50
16429: PPUSH
16430: CALL_OW 302
16434: IFFALSE 16540
// if ( ( GetSkill ( bur , 1 ) <> BurSk [ 1 ] ) or ( GetSkill ( bur , 2 ) <> BurSk [ 2 ] ) or ( GetSkill ( bur , 3 ) <> BurSk [ 3 ] ) or ( GetSkill ( bur , 4 ) <> BurSk [ 4 ] ) ) then
16436: LD_EXP 50
16440: PPUSH
16441: LD_INT 1
16443: PPUSH
16444: CALL_OW 259
16448: PUSH
16449: LD_LOC 19
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: NONEQUAL
16458: PUSH
16459: LD_EXP 50
16463: PPUSH
16464: LD_INT 2
16466: PPUSH
16467: CALL_OW 259
16471: PUSH
16472: LD_LOC 19
16476: PUSH
16477: LD_INT 2
16479: ARRAY
16480: NONEQUAL
16481: OR
16482: PUSH
16483: LD_EXP 50
16487: PPUSH
16488: LD_INT 3
16490: PPUSH
16491: CALL_OW 259
16495: PUSH
16496: LD_LOC 19
16500: PUSH
16501: LD_INT 3
16503: ARRAY
16504: NONEQUAL
16505: OR
16506: PUSH
16507: LD_EXP 50
16511: PPUSH
16512: LD_INT 4
16514: PPUSH
16515: CALL_OW 259
16519: PUSH
16520: LD_LOC 19
16524: PUSH
16525: LD_INT 4
16527: ARRAY
16528: NONEQUAL
16529: OR
16530: IFFALSE 16540
// zmena = true ;
16532: LD_ADDR_VAR 0 1
16536: PUSH
16537: LD_INT 1
16539: ST_TO_ADDR
// if IsOk ( Gny ) then
16540: LD_EXP 49
16544: PPUSH
16545: CALL_OW 302
16549: IFFALSE 16655
// if ( ( GetSkill ( Gny , 1 ) <> GnySk [ 1 ] ) or ( GetSkill ( Gny , 2 ) <> GnySk [ 2 ] ) or ( GetSkill ( Gny , 3 ) <> GnySk [ 3 ] ) or ( GetSkill ( Gny , 4 ) <> GnySk [ 4 ] ) ) then
16551: LD_EXP 49
16555: PPUSH
16556: LD_INT 1
16558: PPUSH
16559: CALL_OW 259
16563: PUSH
16564: LD_LOC 21
16568: PUSH
16569: LD_INT 1
16571: ARRAY
16572: NONEQUAL
16573: PUSH
16574: LD_EXP 49
16578: PPUSH
16579: LD_INT 2
16581: PPUSH
16582: CALL_OW 259
16586: PUSH
16587: LD_LOC 21
16591: PUSH
16592: LD_INT 2
16594: ARRAY
16595: NONEQUAL
16596: OR
16597: PUSH
16598: LD_EXP 49
16602: PPUSH
16603: LD_INT 3
16605: PPUSH
16606: CALL_OW 259
16610: PUSH
16611: LD_LOC 21
16615: PUSH
16616: LD_INT 3
16618: ARRAY
16619: NONEQUAL
16620: OR
16621: PUSH
16622: LD_EXP 49
16626: PPUSH
16627: LD_INT 4
16629: PPUSH
16630: CALL_OW 259
16634: PUSH
16635: LD_LOC 21
16639: PUSH
16640: LD_INT 4
16642: ARRAY
16643: NONEQUAL
16644: OR
16645: IFFALSE 16655
// zmena = true ;
16647: LD_ADDR_VAR 0 1
16651: PUSH
16652: LD_INT 1
16654: ST_TO_ADDR
// if IsOk ( bel ) then
16655: LD_EXP 52
16659: PPUSH
16660: CALL_OW 302
16664: IFFALSE 16770
// if ( ( GetSkill ( bel , 1 ) <> BelSk [ 1 ] ) or ( GetSkill ( bel , 2 ) <> BelSk [ 2 ] ) or ( GetSkill ( bel , 3 ) <> BelSk [ 3 ] ) or ( GetSkill ( bel , 4 ) <> BelSk [ 4 ] ) ) then
16666: LD_EXP 52
16670: PPUSH
16671: LD_INT 1
16673: PPUSH
16674: CALL_OW 259
16678: PUSH
16679: LD_LOC 20
16683: PUSH
16684: LD_INT 1
16686: ARRAY
16687: NONEQUAL
16688: PUSH
16689: LD_EXP 52
16693: PPUSH
16694: LD_INT 2
16696: PPUSH
16697: CALL_OW 259
16701: PUSH
16702: LD_LOC 20
16706: PUSH
16707: LD_INT 2
16709: ARRAY
16710: NONEQUAL
16711: OR
16712: PUSH
16713: LD_EXP 52
16717: PPUSH
16718: LD_INT 3
16720: PPUSH
16721: CALL_OW 259
16725: PUSH
16726: LD_LOC 20
16730: PUSH
16731: LD_INT 3
16733: ARRAY
16734: NONEQUAL
16735: OR
16736: PUSH
16737: LD_EXP 52
16741: PPUSH
16742: LD_INT 4
16744: PPUSH
16745: CALL_OW 259
16749: PUSH
16750: LD_LOC 20
16754: PUSH
16755: LD_INT 4
16757: ARRAY
16758: NONEQUAL
16759: OR
16760: IFFALSE 16770
// zmena = true ;
16762: LD_ADDR_VAR 0 1
16766: PUSH
16767: LD_INT 1
16769: ST_TO_ADDR
// if zmena then
16770: LD_VAR 0 1
16774: IFFALSE 16782
// hint_skilly else
16776: CALL 10640 0 0
16780: GO 16783
// enable ;
16782: ENABLE
// end ;
16783: PPOPN 1
16785: END
// every 0 0$3 trigger IsOk ( plat ) do
16786: LD_EXP 54
16790: PPUSH
16791: CALL_OW 302
16795: IFFALSE 16857
16797: GO 16799
16799: DISABLE
// begin enable ;
16800: ENABLE
// if GetLives ( plat ) < 1000 then
16801: LD_EXP 54
16805: PPUSH
16806: CALL_OW 256
16810: PUSH
16811: LD_INT 1000
16813: LESS
16814: IFFALSE 16828
// SetLives ( plat , 1000 ) ;
16816: LD_EXP 54
16820: PPUSH
16821: LD_INT 1000
16823: PPUSH
16824: CALL_OW 234
// if IsInArea ( plat , Out_base ) then
16828: LD_EXP 54
16832: PPUSH
16833: LD_INT 6
16835: PPUSH
16836: CALL_OW 308
16840: IFFALSE 16857
// ComMoveXY ( plat , 66 , 92 ) ;
16842: LD_EXP 54
16846: PPUSH
16847: LD_INT 66
16849: PPUSH
16850: LD_INT 92
16852: PPUSH
16853: CALL_OW 111
// end ; end_of_file
16857: END
// export Amici_past ; export Amici_baze ; export BWW_1 , BWW_2 ; export ABW1 , ABW2 ; var opravy ; var Am_opravari ; every 0 0$0.1 do
16858: GO 16860
16860: DISABLE
// begin opravy = false ;
16861: LD_ADDR_LOC 22
16865: PUSH
16866: LD_INT 0
16868: ST_TO_ADDR
// end ;
16869: END
// export function placni_amiky_past ; var i ; begin
16870: LD_INT 0
16872: PPUSH
16873: PPUSH
// for i in AMICI_PAST_LIST do
16874: LD_ADDR_VAR 0 2
16878: PUSH
16879: LD_EXP 37
16883: PUSH
16884: FOR_IN
16885: IFFALSE 16904
// PlaceUnitArea ( i , Am_past , false ) ;
16887: LD_VAR 0 2
16891: PPUSH
16892: LD_INT 7
16894: PPUSH
16895: LD_INT 0
16897: PPUSH
16898: CALL_OW 49
16902: GO 16884
16904: POP
16905: POP
// Amici_past = AMICI_PAST_LIST ;
16906: LD_ADDR_EXP 72
16910: PUSH
16911: LD_EXP 37
16915: ST_TO_ADDR
// AddComCrawl ( AMICI_PAST_LIST ) ;
16916: LD_EXP 37
16920: PPUSH
16921: CALL_OW 197
// for i = 1 to 3 do
16925: LD_ADDR_VAR 0 2
16929: PUSH
16930: DOUBLE
16931: LD_INT 1
16933: DEC
16934: ST_TO_ADDR
16935: LD_INT 3
16937: PUSH
16938: FOR_TO
16939: IFFALSE 16978
// begin if i > AMICI_PAST_LIST then
16941: LD_VAR 0 2
16945: PUSH
16946: LD_EXP 37
16950: GREATER
16951: IFFALSE 16955
// break ;
16953: GO 16978
// AddComMoveXY ( AMICI_PAST_LIST [ i ] , 60 , 28 ) ;
16955: LD_EXP 37
16959: PUSH
16960: LD_VAR 0 2
16964: ARRAY
16965: PPUSH
16966: LD_INT 60
16968: PPUSH
16969: LD_INT 28
16971: PPUSH
16972: CALL_OW 171
// end ;
16976: GO 16938
16978: POP
16979: POP
// for i = 4 to AMICI_PAST_LIST + 0 do
16980: LD_ADDR_VAR 0 2
16984: PUSH
16985: DOUBLE
16986: LD_INT 4
16988: DEC
16989: ST_TO_ADDR
16990: LD_EXP 37
16994: PUSH
16995: LD_INT 0
16997: PLUS
16998: PUSH
16999: FOR_TO
17000: IFFALSE 17025
// AddComMoveXY ( AMICI_PAST_LIST [ i ] , 73 , 21 ) ;
17002: LD_EXP 37
17006: PUSH
17007: LD_VAR 0 2
17011: ARRAY
17012: PPUSH
17013: LD_INT 73
17015: PPUSH
17016: LD_INT 21
17018: PPUSH
17019: CALL_OW 171
17023: GO 16999
17025: POP
17026: POP
// end ;
17027: LD_VAR 0 1
17031: RET
// export function stavba_am_baze ; var i ; var pom ; begin
17032: LD_INT 0
17034: PPUSH
17035: PPUSH
17036: PPUSH
// Amici_baze = AMICI_STAVENI_BASE_LIST ;
17037: LD_ADDR_EXP 73
17041: PUSH
17042: LD_EXP 38
17046: ST_TO_ADDR
// for i in AMICI_STAVENI_BASE_LIST do
17047: LD_ADDR_VAR 0 2
17051: PUSH
17052: LD_EXP 38
17056: PUSH
17057: FOR_IN
17058: IFFALSE 17077
// PlaceUnitArea ( i , Amici_enter , false ) ;
17060: LD_VAR 0 2
17064: PPUSH
17065: LD_INT 8
17067: PPUSH
17068: LD_INT 0
17070: PPUSH
17071: CALL_OW 49
17075: GO 17057
17077: POP
17078: POP
// ComMoveXY ( Amici_baze , 53 , 55 ) ;
17079: LD_EXP 73
17083: PPUSH
17084: LD_INT 53
17086: PPUSH
17087: LD_INT 55
17089: PPUSH
17090: CALL_OW 111
// uc_nation := nation_american ;
17094: LD_ADDR_OWVAR 21
17098: PUSH
17099: LD_INT 1
17101: ST_TO_ADDR
// uc_side := amici ;
17102: LD_ADDR_OWVAR 20
17106: PUSH
17107: LD_EXP 2
17111: ST_TO_ADDR
// bc_type := b_depot ;
17112: LD_ADDR_OWVAR 42
17116: PUSH
17117: LD_INT 0
17119: ST_TO_ADDR
// bc_level := 0 ;
17120: LD_ADDR_OWVAR 43
17124: PUSH
17125: LD_INT 0
17127: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 52 , 48 , 2 ) ;
17128: LD_INT 52
17130: PPUSH
17131: LD_INT 48
17133: PPUSH
17134: LD_INT 2
17136: PPUSH
17137: CALL_OW 47
// end ;
17141: LD_VAR 0 1
17145: RET
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) > 0 do var pom , i ;
17146: LD_INT 9
17148: PPUSH
17149: LD_INT 22
17151: PUSH
17152: LD_EXP 2
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: LD_INT 30
17163: PUSH
17164: LD_INT 0
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 70
17179: PUSH
17180: LD_INT 0
17182: GREATER
17183: IFFALSE 17346
17185: GO 17187
17187: DISABLE
17188: LD_INT 0
17190: PPUSH
17191: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
17192: LD_ADDR_VAR 0 1
17196: PUSH
17197: LD_INT 9
17199: PPUSH
17200: LD_INT 22
17202: PUSH
17203: LD_EXP 2
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PUSH
17212: LD_INT 30
17214: PUSH
17215: LD_INT 0
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PPUSH
17226: CALL_OW 70
17230: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
17231: LD_VAR 0 1
17235: PUSH
17236: LD_INT 1
17238: ARRAY
17239: PPUSH
17240: CALL_OW 304
17244: PUSH
17245: LD_INT 0
17247: NONEQUAL
17248: IFFALSE 17259
// wait ( 0 0$2 ) ;
17250: LD_INT 70
17252: PPUSH
17253: CALL_OW 67
17257: GO 17231
// AddResourceType ( GetBase ( pom [ 1 ] ) , mat_cans , 40 ) ;
17259: LD_VAR 0 1
17263: PUSH
17264: LD_INT 1
17266: ARRAY
17267: PPUSH
17268: CALL_OW 274
17272: PPUSH
17273: LD_INT 1
17275: PPUSH
17276: LD_INT 40
17278: PPUSH
17279: CALL_OW 276
// for i in Amici_baze do
17283: LD_ADDR_VAR 0 2
17287: PUSH
17288: LD_EXP 73
17292: PUSH
17293: FOR_IN
17294: IFFALSE 17323
// if GetClass ( i ) = class_engineer then
17296: LD_VAR 0 2
17300: PPUSH
17301: CALL_OW 257
17305: PUSH
17306: LD_INT 2
17308: EQUAL
17309: IFFALSE 17321
// pom = i ;
17311: LD_ADDR_VAR 0 1
17315: PUSH
17316: LD_VAR 0 2
17320: ST_TO_ADDR
17321: GO 17293
17323: POP
17324: POP
// AddComBuild ( pom , b_breastwork , 61 , 52 , 4 ) ;
17325: LD_VAR 0 1
17329: PPUSH
17330: LD_INT 31
17332: PPUSH
17333: LD_INT 61
17335: PPUSH
17336: LD_INT 52
17338: PPUSH
17339: LD_INT 4
17341: PPUSH
17342: CALL_OW 205
// end ;
17346: PPOPN 2
17348: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) > 0 do var pom , i ;
17349: LD_INT 9
17351: PPUSH
17352: LD_INT 22
17354: PUSH
17355: LD_EXP 2
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: PUSH
17364: LD_INT 30
17366: PUSH
17367: LD_INT 31
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PPUSH
17378: CALL_OW 70
17382: PUSH
17383: LD_INT 0
17385: GREATER
17386: IFFALSE 17525
17388: GO 17390
17390: DISABLE
17391: LD_INT 0
17393: PPUSH
17394: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
17395: LD_ADDR_VAR 0 1
17399: PUSH
17400: LD_INT 9
17402: PPUSH
17403: LD_INT 22
17405: PUSH
17406: LD_EXP 2
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: PUSH
17415: LD_INT 30
17417: PUSH
17418: LD_INT 31
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PPUSH
17429: CALL_OW 70
17433: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) <> 0 do
17434: LD_VAR 0 1
17438: PUSH
17439: LD_INT 1
17441: ARRAY
17442: PPUSH
17443: CALL_OW 304
17447: PUSH
17448: LD_INT 0
17450: NONEQUAL
17451: IFFALSE 17462
// wait ( 0 0$2 ) ;
17453: LD_INT 70
17455: PPUSH
17456: CALL_OW 67
17460: GO 17434
// for i in Amici_baze do
17462: LD_ADDR_VAR 0 2
17466: PUSH
17467: LD_EXP 73
17471: PUSH
17472: FOR_IN
17473: IFFALSE 17502
// if GetClass ( i ) = class_engineer then
17475: LD_VAR 0 2
17479: PPUSH
17480: CALL_OW 257
17484: PUSH
17485: LD_INT 2
17487: EQUAL
17488: IFFALSE 17500
// pom = i ;
17490: LD_ADDR_VAR 0 1
17494: PUSH
17495: LD_VAR 0 2
17499: ST_TO_ADDR
17500: GO 17472
17502: POP
17503: POP
// AddComBuild ( pom , b_breastwork , 62 , 56 , 4 ) ;
17504: LD_VAR 0 1
17508: PPUSH
17509: LD_INT 31
17511: PPUSH
17512: LD_INT 62
17514: PPUSH
17515: LD_INT 56
17517: PPUSH
17518: LD_INT 4
17520: PPUSH
17521: CALL_OW 205
// end ;
17525: PPOPN 2
17527: END
// every 0 0$5 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) > 1 do var pom , i , pom1 ;
17528: LD_INT 9
17530: PPUSH
17531: LD_INT 22
17533: PUSH
17534: LD_EXP 2
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: LD_INT 30
17545: PUSH
17546: LD_INT 31
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: PUSH
17553: EMPTY
17554: LIST
17555: LIST
17556: PPUSH
17557: CALL_OW 70
17561: PUSH
17562: LD_INT 1
17564: GREATER
17565: IFFALSE 17860
17567: GO 17569
17569: DISABLE
17570: LD_INT 0
17572: PPUSH
17573: PPUSH
17574: PPUSH
// begin pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
17575: LD_ADDR_VAR 0 1
17579: PUSH
17580: LD_INT 9
17582: PPUSH
17583: LD_INT 22
17585: PUSH
17586: LD_EXP 2
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PUSH
17595: LD_INT 30
17597: PUSH
17598: LD_INT 31
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: PUSH
17605: EMPTY
17606: LIST
17607: LIST
17608: PPUSH
17609: CALL_OW 70
17613: ST_TO_ADDR
// pom1 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_class , class_soldier ] ] ) ;
17614: LD_ADDR_VAR 0 3
17618: PUSH
17619: LD_INT 9
17621: PPUSH
17622: LD_INT 22
17624: PUSH
17625: LD_EXP 2
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: PUSH
17634: LD_INT 25
17636: PUSH
17637: LD_INT 1
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: PUSH
17644: EMPTY
17645: LIST
17646: LIST
17647: PPUSH
17648: CALL_OW 70
17652: ST_TO_ADDR
// while IsConstructed ( pom [ 1 ] ) or IsConstructed ( pom [ 2 ] ) <> 0 do
17653: LD_VAR 0 1
17657: PUSH
17658: LD_INT 1
17660: ARRAY
17661: PPUSH
17662: CALL_OW 304
17666: PUSH
17667: LD_VAR 0 1
17671: PUSH
17672: LD_INT 2
17674: ARRAY
17675: PPUSH
17676: CALL_OW 304
17680: PUSH
17681: LD_INT 0
17683: NONEQUAL
17684: OR
17685: IFFALSE 17696
// wait ( 0 0$1 ) ;
17687: LD_INT 35
17689: PPUSH
17690: CALL_OW 67
17694: GO 17653
// ComEnterUnit ( pom1 [ 1 ] , pom [ 1 ] ) ;
17696: LD_VAR 0 3
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: PPUSH
17705: LD_VAR 0 1
17709: PUSH
17710: LD_INT 1
17712: ARRAY
17713: PPUSH
17714: CALL_OW 120
// ComEnterUnit ( pom1 [ 2 ] , pom [ 2 ] ) ;
17718: LD_VAR 0 3
17722: PUSH
17723: LD_INT 2
17725: ARRAY
17726: PPUSH
17727: LD_VAR 0 1
17731: PUSH
17732: LD_INT 2
17734: ARRAY
17735: PPUSH
17736: CALL_OW 120
// SetBLevel ( pom , levely_bw_na_zapade [ difficulty ] ) ;
17740: LD_VAR 0 1
17744: PPUSH
17745: LD_EXP 44
17749: PUSH
17750: LD_OWVAR 67
17754: ARRAY
17755: PPUSH
17756: CALL_OW 241
// pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
17760: LD_ADDR_VAR 0 1
17764: PUSH
17765: LD_INT 9
17767: PPUSH
17768: LD_INT 22
17770: PUSH
17771: LD_EXP 2
17775: PUSH
17776: EMPTY
17777: LIST
17778: LIST
17779: PUSH
17780: LD_INT 30
17782: PUSH
17783: LD_INT 0
17785: PUSH
17786: EMPTY
17787: LIST
17788: LIST
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: PPUSH
17794: CALL_OW 70
17798: ST_TO_ADDR
// pom1 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_class , class_engineer ] ] ) ;
17799: LD_ADDR_VAR 0 3
17803: PUSH
17804: LD_INT 9
17806: PPUSH
17807: LD_INT 22
17809: PUSH
17810: LD_EXP 2
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 25
17821: PUSH
17822: LD_INT 2
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: PPUSH
17833: CALL_OW 70
17837: ST_TO_ADDR
// ComEnterUnit ( pom1 , pom [ 1 ] ) ;
17838: LD_VAR 0 3
17842: PPUSH
17843: LD_VAR 0 1
17847: PUSH
17848: LD_INT 1
17850: ARRAY
17851: PPUSH
17852: CALL_OW 120
// nastav_levely_budov ;
17856: CALL 19434 0 0
// end ;
17860: PPOPN 3
17862: END
// export function amici_boj ; var mech ; var auto ; var i ; var AP ; begin
17863: LD_INT 0
17865: PPUSH
17866: PPUSH
17867: PPUSH
17868: PPUSH
17869: PPUSH
// ComMoveXY ( Amici_past , 64 , 16 ) ;
17870: LD_EXP 72
17874: PPUSH
17875: LD_INT 64
17877: PPUSH
17878: LD_INT 16
17880: PPUSH
17881: CALL_OW 111
// mech = vyber_cloveka ( Amici_past , class_mechanic ) ;
17885: LD_ADDR_VAR 0 2
17889: PUSH
17890: LD_EXP 72
17894: PPUSH
17895: LD_INT 3
17897: PPUSH
17898: CALL 4379 0 2
17902: ST_TO_ADDR
// if mech = 0 or ( not IsOK ( mech ) ) then
17903: LD_VAR 0 2
17907: PUSH
17908: LD_INT 0
17910: EQUAL
17911: PUSH
17912: LD_VAR 0 2
17916: PPUSH
17917: CALL_OW 302
17921: NOT
17922: OR
17923: IFFALSE 17953
// mech = UnitFilter ( Amici_past , [ [ f_ok ] ] ) [ 1 ] ;
17925: LD_ADDR_VAR 0 2
17929: PUSH
17930: LD_EXP 72
17934: PPUSH
17935: LD_INT 50
17937: PUSH
17938: EMPTY
17939: LIST
17940: PUSH
17941: EMPTY
17942: LIST
17943: PPUSH
17944: CALL_OW 72
17948: PUSH
17949: LD_INT 1
17951: ARRAY
17952: ST_TO_ADDR
// auto = FilterAllUnits ( [ [ f_side , You2 ] , [ f_type , unit_vehicle ] ] ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_INT 22
17960: PUSH
17961: LD_EXP 4
17965: PUSH
17966: EMPTY
17967: LIST
17968: LIST
17969: PUSH
17970: LD_INT 21
17972: PUSH
17973: LD_INT 2
17975: PUSH
17976: EMPTY
17977: LIST
17978: LIST
17979: PUSH
17980: EMPTY
17981: LIST
17982: LIST
17983: PPUSH
17984: CALL_OW 69
17988: ST_TO_ADDR
// if auto > 0 then
17989: LD_VAR 0 3
17993: PUSH
17994: LD_INT 0
17996: GREATER
17997: IFFALSE 18013
// auto = auto [ 1 ] ;
17999: LD_ADDR_VAR 0 3
18003: PUSH
18004: LD_VAR 0 3
18008: PUSH
18009: LD_INT 1
18011: ARRAY
18012: ST_TO_ADDR
// if mech = 0 then
18013: LD_VAR 0 2
18017: PUSH
18018: LD_INT 0
18020: EQUAL
18021: IFFALSE 18037
// mech = Amici_past [ 1 ] ;
18023: LD_ADDR_VAR 0 2
18027: PUSH
18028: LD_EXP 72
18032: PUSH
18033: LD_INT 1
18035: ARRAY
18036: ST_TO_ADDR
// ComEnterUnit ( mech , auto ) ;
18037: LD_VAR 0 2
18041: PPUSH
18042: LD_VAR 0 3
18046: PPUSH
18047: CALL_OW 120
// AddComMoveXY ( Amici_past , 69 , 18 ) ;
18051: LD_EXP 72
18055: PPUSH
18056: LD_INT 69
18058: PPUSH
18059: LD_INT 18
18061: PPUSH
18062: CALL_OW 171
// AddComMoveXY ( auto , 72 , 21 ) ;
18066: LD_VAR 0 3
18070: PPUSH
18071: LD_INT 72
18073: PPUSH
18074: LD_INT 21
18076: PPUSH
18077: CALL_OW 171
// wait ( 0 0$3 ) ;
18081: LD_INT 105
18083: PPUSH
18084: CALL_OW 67
// zaber_to_auto ;
18088: CALL 19301 0 0
// while FilterAllUnits ( [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) = 0 do
18092: LD_INT 22
18094: PUSH
18095: LD_EXP 2
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PUSH
18104: LD_INT 21
18106: PUSH
18107: LD_INT 2
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: PPUSH
18118: CALL_OW 69
18122: PUSH
18123: LD_INT 0
18125: EQUAL
18126: IFFALSE 18206
// begin for i in Amici_past do
18128: LD_ADDR_VAR 0 4
18132: PUSH
18133: LD_EXP 72
18137: PUSH
18138: FOR_IN
18139: IFFALSE 18166
// if IsOK ( i ) then
18141: LD_VAR 0 4
18145: PPUSH
18146: CALL_OW 302
18150: IFFALSE 18164
// begin AP = i ;
18152: LD_ADDR_VAR 0 5
18156: PUSH
18157: LD_VAR 0 4
18161: ST_TO_ADDR
// break ;
18162: GO 18166
// end ;
18164: GO 18138
18166: POP
18167: POP
// ComEnterUnit ( AP , Auto_belkov ) ;
18168: LD_VAR 0 5
18172: PPUSH
18173: LD_EXP 70
18177: PPUSH
18178: CALL_OW 120
// AddComMoveXY ( AP , 73 , 22 ) ;
18182: LD_VAR 0 5
18186: PPUSH
18187: LD_INT 73
18189: PPUSH
18190: LD_INT 22
18192: PPUSH
18193: CALL_OW 171
// wait ( 0 0$2 ) ;
18197: LD_INT 70
18199: PPUSH
18200: CALL_OW 67
// end ;
18204: GO 18092
// end ;
18206: LD_VAR 0 1
18210: RET
// export function amici_attack_belkov ; var i ; begin
18211: LD_INT 0
18213: PPUSH
18214: PPUSH
// if GetSide ( bel ) <> You then
18215: LD_EXP 52
18219: PPUSH
18220: CALL_OW 255
18224: PUSH
18225: LD_EXP 1
18229: NONEQUAL
18230: IFFALSE 18353
// begin for i in AMICI_UTOK_BELKOV_LIST do
18232: LD_ADDR_VAR 0 2
18236: PUSH
18237: LD_EXP 39
18241: PUSH
18242: FOR_IN
18243: IFFALSE 18262
// PlaceUnitArea ( i , Zpet_bel , false ) ;
18245: LD_VAR 0 2
18249: PPUSH
18250: LD_INT 15
18252: PPUSH
18253: LD_INT 0
18255: PPUSH
18256: CALL_OW 49
18260: GO 18242
18262: POP
18263: POP
// McMove ( 1 , AMICI_UTOK_BELKOV_LIST , [ [ 44 , 6 ] , [ 36 , 5 ] , [ 36 , 10 ] , [ GetX ( bel ) , GetY ( bel ) ] , [ 52 , 2 ] ] , [ mc_move_agressive ] ) ;
18264: LD_INT 1
18266: PPUSH
18267: LD_EXP 39
18271: PPUSH
18272: LD_INT 44
18274: PUSH
18275: LD_INT 6
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: PUSH
18282: LD_INT 36
18284: PUSH
18285: LD_INT 5
18287: PUSH
18288: EMPTY
18289: LIST
18290: LIST
18291: PUSH
18292: LD_INT 36
18294: PUSH
18295: LD_INT 10
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PUSH
18302: LD_EXP 52
18306: PPUSH
18307: CALL_OW 250
18311: PUSH
18312: LD_EXP 52
18316: PPUSH
18317: CALL_OW 251
18321: PUSH
18322: EMPTY
18323: LIST
18324: LIST
18325: PUSH
18326: LD_INT 52
18328: PUSH
18329: LD_INT 2
18331: PUSH
18332: EMPTY
18333: LIST
18334: LIST
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: PPUSH
18343: LD_INT 6
18345: PUSH
18346: EMPTY
18347: LIST
18348: PPUSH
18349: CALL_OW 398
// end ; end ;
18353: LD_VAR 0 1
18357: RET
// export function amici_retreat ; var i , Amici_All ; begin
18358: LD_INT 0
18360: PPUSH
18361: PPUSH
18362: PPUSH
// Amici_All := AMICI_UTOK_BELKOV_LIST union AMICI_PAST_LIST ^ auto_belkov ;
18363: LD_ADDR_VAR 0 3
18367: PUSH
18368: LD_EXP 39
18372: PUSH
18373: LD_EXP 37
18377: PUSH
18378: LD_EXP 70
18382: ADD
18383: UNION
18384: ST_TO_ADDR
// repeat ComMoveToArea ( Amici_All , Zpet_bel ) ;
18385: LD_VAR 0 3
18389: PPUSH
18390: LD_INT 15
18392: PPUSH
18393: CALL_OW 113
// wait ( 0 0$1 ) ;
18397: LD_INT 35
18399: PPUSH
18400: CALL_OW 67
// for i in Amici_All do
18404: LD_ADDR_VAR 0 2
18408: PUSH
18409: LD_VAR 0 3
18413: PUSH
18414: FOR_IN
18415: IFFALSE 18486
// begin if not ( IsOK ( i ) ) then
18417: LD_VAR 0 2
18421: PPUSH
18422: CALL_OW 302
18426: NOT
18427: IFFALSE 18445
// Amici_All := Amici_All diff i ;
18429: LD_ADDR_VAR 0 3
18433: PUSH
18434: LD_VAR 0 3
18438: PUSH
18439: LD_VAR 0 2
18443: DIFF
18444: ST_TO_ADDR
// if IsInArea ( i , Zpet_bel ) then
18445: LD_VAR 0 2
18449: PPUSH
18450: LD_INT 15
18452: PPUSH
18453: CALL_OW 308
18457: IFFALSE 18484
// begin Amici_All := Amici_All diff i ;
18459: LD_ADDR_VAR 0 3
18463: PUSH
18464: LD_VAR 0 3
18468: PUSH
18469: LD_VAR 0 2
18473: DIFF
18474: ST_TO_ADDR
// RemoveUnit ( i ) ;
18475: LD_VAR 0 2
18479: PPUSH
18480: CALL_OW 64
// end ; end ;
18484: GO 18414
18486: POP
18487: POP
// until Amici_All = [ ] ;
18488: LD_VAR 0 3
18492: PUSH
18493: EMPTY
18494: EQUAL
18495: IFFALSE 18385
// end ;
18497: LD_VAR 0 1
18501: RET
// every 0 0$2 trigger FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) = 2 do
18502: LD_INT 9
18504: PPUSH
18505: LD_INT 22
18507: PUSH
18508: LD_EXP 2
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PUSH
18517: LD_INT 30
18519: PUSH
18520: LD_INT 31
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: PUSH
18527: EMPTY
18528: LIST
18529: LIST
18530: PPUSH
18531: CALL_OW 70
18535: PUSH
18536: LD_INT 2
18538: EQUAL
18539: IFFALSE 18580
18541: GO 18543
18543: DISABLE
// begin Am_opravari = UnitFilter ( Amici_baze , [ [ f_class , class_engineer ] ] ) ;
18544: LD_ADDR_LOC 23
18548: PUSH
18549: LD_EXP 73
18553: PPUSH
18554: LD_INT 25
18556: PUSH
18557: LD_INT 2
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: EMPTY
18565: LIST
18566: PPUSH
18567: CALL_OW 72
18571: ST_TO_ADDR
// opravy = true ;
18572: LD_ADDR_LOC 22
18576: PUSH
18577: LD_INT 1
18579: ST_TO_ADDR
// end ;
18580: END
// every 0 0$4 trigger opravy do var pom , i ; var pom1 , pom2 ;
18581: LD_LOC 22
18585: IFFALSE 19061
18587: GO 18589
18589: DISABLE
18590: LD_INT 0
18592: PPUSH
18593: PPUSH
18594: PPUSH
18595: PPUSH
// begin pom1 = [ ] ;
18596: LD_ADDR_VAR 0 3
18600: PUSH
18601: EMPTY
18602: ST_TO_ADDR
// pom = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_breastwork ] ] ) ;
18603: LD_ADDR_VAR 0 1
18607: PUSH
18608: LD_INT 9
18610: PPUSH
18611: LD_INT 22
18613: PUSH
18614: LD_EXP 2
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 30
18625: PUSH
18626: LD_INT 31
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PPUSH
18637: CALL_OW 70
18641: ST_TO_ADDR
// for i in pom do
18642: LD_ADDR_VAR 0 2
18646: PUSH
18647: LD_VAR 0 1
18651: PUSH
18652: FOR_IN
18653: IFFALSE 18688
// if GetLives ( i ) < 1000 then
18655: LD_VAR 0 2
18659: PPUSH
18660: CALL_OW 256
18664: PUSH
18665: LD_INT 1000
18667: LESS
18668: IFFALSE 18686
// pom1 = pom1 ^ i ;
18670: LD_ADDR_VAR 0 3
18674: PUSH
18675: LD_VAR 0 3
18679: PUSH
18680: LD_VAR 0 2
18684: ADD
18685: ST_TO_ADDR
18686: GO 18652
18688: POP
18689: POP
// case pom1 + 0 of 1 :
18690: LD_VAR 0 3
18694: PUSH
18695: LD_INT 0
18697: PLUS
18698: PUSH
18699: LD_INT 1
18701: DOUBLE
18702: EQUAL
18703: IFTRUE 18707
18705: GO 18811
18707: POP
// begin ComExitBuilding ( Am_opravari ) ;
18708: LD_LOC 23
18712: PPUSH
18713: CALL_OW 122
// AddComRepairBuilding ( Am_opravari , pom1 [ 1 ] ) ;
18717: LD_LOC 23
18721: PPUSH
18722: LD_VAR 0 3
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18735: LD_ADDR_VAR 0 4
18739: PUSH
18740: LD_INT 9
18742: PPUSH
18743: LD_INT 22
18745: PUSH
18746: LD_EXP 2
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: PUSH
18755: LD_INT 30
18757: PUSH
18758: LD_INT 0
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: EMPTY
18766: LIST
18767: LIST
18768: PPUSH
18769: CALL_OW 70
18773: ST_TO_ADDR
// if pom2 > 0 then
18774: LD_VAR 0 4
18778: PUSH
18779: LD_INT 0
18781: GREATER
18782: IFFALSE 18802
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
18784: LD_LOC 23
18788: PPUSH
18789: LD_VAR 0 4
18793: PUSH
18794: LD_INT 1
18796: ARRAY
18797: PPUSH
18798: CALL_OW 180
// wait ( 0 0$5 ) ;
18802: LD_INT 175
18804: PPUSH
18805: CALL_OW 67
// end ; 2 :
18809: GO 19060
18811: LD_INT 2
18813: DOUBLE
18814: EQUAL
18815: IFTRUE 18819
18817: GO 19059
18819: POP
// begin if Am_opravari + 0 = 2 then
18820: LD_LOC 23
18824: PUSH
18825: LD_INT 0
18827: PLUS
18828: PUSH
18829: LD_INT 2
18831: EQUAL
18832: IFFALSE 18956
// begin ComExitBuilding ( Am_opravari ) ;
18834: LD_LOC 23
18838: PPUSH
18839: CALL_OW 122
// AddComRepairBuilding ( Am_opravari [ 2 ] , pom1 [ 1 ] ) ;
18843: LD_LOC 23
18847: PUSH
18848: LD_INT 2
18850: ARRAY
18851: PPUSH
18852: LD_VAR 0 3
18856: PUSH
18857: LD_INT 1
18859: ARRAY
18860: PPUSH
18861: CALL_OW 190
// AddComRepairBuilding ( Am_opravari [ 1 ] , pom1 [ 1 ] ) ;
18865: LD_LOC 23
18869: PUSH
18870: LD_INT 1
18872: ARRAY
18873: PPUSH
18874: LD_VAR 0 3
18878: PUSH
18879: LD_INT 1
18881: ARRAY
18882: PPUSH
18883: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18887: LD_ADDR_VAR 0 4
18891: PUSH
18892: LD_INT 9
18894: PPUSH
18895: LD_INT 22
18897: PUSH
18898: LD_EXP 2
18902: PUSH
18903: EMPTY
18904: LIST
18905: LIST
18906: PUSH
18907: LD_INT 30
18909: PUSH
18910: LD_INT 0
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PPUSH
18921: CALL_OW 70
18925: ST_TO_ADDR
// if pom2 > 0 then
18926: LD_VAR 0 4
18930: PUSH
18931: LD_INT 0
18933: GREATER
18934: IFFALSE 18954
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
18936: LD_LOC 23
18940: PPUSH
18941: LD_VAR 0 4
18945: PUSH
18946: LD_INT 1
18948: ARRAY
18949: PPUSH
18950: CALL_OW 180
// end else
18954: GO 19050
// begin ComExitBuilding ( Am_opravari ) ;
18956: LD_LOC 23
18960: PPUSH
18961: CALL_OW 122
// AddComRepairBuilding ( Am_opravari , pom1 [ 1 ] ) ;
18965: LD_LOC 23
18969: PPUSH
18970: LD_VAR 0 3
18974: PUSH
18975: LD_INT 1
18977: ARRAY
18978: PPUSH
18979: CALL_OW 190
// pom2 = FilterUnitsInArea ( Am_base , [ [ f_side , Amici ] , [ f_btype , b_depot ] ] ) ;
18983: LD_ADDR_VAR 0 4
18987: PUSH
18988: LD_INT 9
18990: PPUSH
18991: LD_INT 22
18993: PUSH
18994: LD_EXP 2
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: PUSH
19003: LD_INT 30
19005: PUSH
19006: LD_INT 0
19008: PUSH
19009: EMPTY
19010: LIST
19011: LIST
19012: PUSH
19013: EMPTY
19014: LIST
19015: LIST
19016: PPUSH
19017: CALL_OW 70
19021: ST_TO_ADDR
// if pom2 > 0 then
19022: LD_VAR 0 4
19026: PUSH
19027: LD_INT 0
19029: GREATER
19030: IFFALSE 19050
// AddComEnterUnit ( Am_opravari , pom2 [ 1 ] ) ;
19032: LD_LOC 23
19036: PPUSH
19037: LD_VAR 0 4
19041: PUSH
19042: LD_INT 1
19044: ARRAY
19045: PPUSH
19046: CALL_OW 180
// end ; wait ( 0 0$5 ) ;
19050: LD_INT 175
19052: PPUSH
19053: CALL_OW 67
// end ; end ;
19057: GO 19060
19059: POP
// enable ;
19060: ENABLE
// end ;
19061: PPOPN 4
19063: END
// every 0 0$1 trigger opravy do var pom , i ;
19064: LD_LOC 22
19068: IFFALSE 19138
19070: GO 19072
19072: DISABLE
19073: LD_INT 0
19075: PPUSH
19076: PPUSH
// begin pom = [ ] ;
19077: LD_ADDR_VAR 0 1
19081: PUSH
19082: EMPTY
19083: ST_TO_ADDR
// for i in Am_opravari do
19084: LD_ADDR_VAR 0 2
19088: PUSH
19089: LD_LOC 23
19093: PUSH
19094: FOR_IN
19095: IFFALSE 19126
// if IsOK ( i ) then
19097: LD_VAR 0 2
19101: PPUSH
19102: CALL_OW 302
19106: IFFALSE 19124
// pom = pom ^ i ;
19108: LD_ADDR_VAR 0 1
19112: PUSH
19113: LD_VAR 0 1
19117: PUSH
19118: LD_VAR 0 2
19122: ADD
19123: ST_TO_ADDR
19124: GO 19094
19126: POP
19127: POP
// Am_opravari = pom ;
19128: LD_ADDR_LOC 23
19132: PUSH
19133: LD_VAR 0 1
19137: ST_TO_ADDR
// end ;
19138: PPOPN 2
19140: END
// export function amici_po_kecech ; var i , j ; var pom ; begin
19141: LD_INT 0
19143: PPUSH
19144: PPUSH
19145: PPUSH
19146: PPUSH
// i = 1 ;
19147: LD_ADDR_VAR 0 2
19151: PUSH
19152: LD_INT 1
19154: ST_TO_ADDR
// if GetSide ( auto_belkov ) <> Amici then
19155: LD_EXP 70
19159: PPUSH
19160: CALL_OW 255
19164: PUSH
19165: LD_EXP 2
19169: NONEQUAL
19170: IFFALSE 19253
// begin for i in Amici_past do
19172: LD_ADDR_VAR 0 2
19176: PUSH
19177: LD_EXP 72
19181: PUSH
19182: FOR_IN
19183: IFFALSE 19208
// if IsOK ( i ) then
19185: LD_VAR 0 2
19189: PPUSH
19190: CALL_OW 302
19194: IFFALSE 19206
// pom = i ;
19196: LD_ADDR_VAR 0 4
19200: PUSH
19201: LD_VAR 0 2
19205: ST_TO_ADDR
19206: GO 19182
19208: POP
19209: POP
// ComEnterUnit ( pom , auto_belkov ) ;
19210: LD_VAR 0 4
19214: PPUSH
19215: LD_EXP 70
19219: PPUSH
19220: CALL_OW 120
// AddComMoveXY ( pom , 74 , 22 ) ;
19224: LD_VAR 0 4
19228: PPUSH
19229: LD_INT 74
19231: PPUSH
19232: LD_INT 22
19234: PPUSH
19235: CALL_OW 171
// i = i + 1 ;
19239: LD_ADDR_VAR 0 2
19243: PUSH
19244: LD_VAR 0 2
19248: PUSH
19249: LD_INT 1
19251: PLUS
19252: ST_TO_ADDR
// end ; for i in Amici_past do
19253: LD_ADDR_VAR 0 2
19257: PUSH
19258: LD_EXP 72
19262: PUSH
19263: FOR_IN
19264: IFFALSE 19294
// if IsOK ( i ) then
19266: LD_VAR 0 2
19270: PPUSH
19271: CALL_OW 302
19275: IFFALSE 19292
// ComMoveXY ( i , 72 , 25 ) ;
19277: LD_VAR 0 2
19281: PPUSH
19282: LD_INT 72
19284: PPUSH
19285: LD_INT 25
19287: PPUSH
19288: CALL_OW 111
19292: GO 19263
19294: POP
19295: POP
// end ;
19296: LD_VAR 0 1
19300: RET
// function zaber_to_auto ; var i , pom ; begin
19301: LD_INT 0
19303: PPUSH
19304: PPUSH
19305: PPUSH
// while ( FilterAllUnits ( [ [ f_side , Amici ] , [ f_type , unit_vehicle ] ] ) = 0 ) and IsOK ( auto_belkov ) do
19306: LD_INT 22
19308: PUSH
19309: LD_EXP 2
19313: PUSH
19314: EMPTY
19315: LIST
19316: LIST
19317: PUSH
19318: LD_INT 21
19320: PUSH
19321: LD_INT 2
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: PUSH
19328: EMPTY
19329: LIST
19330: LIST
19331: PPUSH
19332: CALL_OW 69
19336: PUSH
19337: LD_INT 0
19339: EQUAL
19340: PUSH
19341: LD_EXP 70
19345: PPUSH
19346: CALL_OW 302
19350: AND
19351: IFFALSE 19429
// begin for i in Amici_past do
19353: LD_ADDR_VAR 0 2
19357: PUSH
19358: LD_EXP 72
19362: PUSH
19363: FOR_IN
19364: IFFALSE 19389
// if IsOK ( i ) then
19366: LD_VAR 0 2
19370: PPUSH
19371: CALL_OW 302
19375: IFFALSE 19387
// pom = i ;
19377: LD_ADDR_VAR 0 3
19381: PUSH
19382: LD_VAR 0 2
19386: ST_TO_ADDR
19387: GO 19363
19389: POP
19390: POP
// ComEnterUnit ( pom , auto_belkov ) ;
19391: LD_VAR 0 3
19395: PPUSH
19396: LD_EXP 70
19400: PPUSH
19401: CALL_OW 120
// AddComMoveXY ( pom , 72 , 20 ) ;
19405: LD_VAR 0 3
19409: PPUSH
19410: LD_INT 72
19412: PPUSH
19413: LD_INT 20
19415: PPUSH
19416: CALL_OW 171
// wait ( 0 0$2 ) ;
19420: LD_INT 70
19422: PPUSH
19423: CALL_OW 67
// end ;
19427: GO 19306
// end ;
19429: LD_VAR 0 1
19433: RET
// function nastav_levely_budov ; begin
19434: LD_INT 0
19436: PPUSH
// SetBLevel ( [ Am_bre1 , Am_bre2 ] , levely_bw_na_vychode ) ;
19437: LD_INT 30
19439: PUSH
19440: LD_INT 31
19442: PUSH
19443: EMPTY
19444: LIST
19445: LIST
19446: PPUSH
19447: LD_EXP 45
19451: PPUSH
19452: CALL_OW 241
// SetBLevel ( [ BWW_1 , BWW_2 ] , levely_bw_na_vychode ) ;
19456: LD_EXP 74
19460: PUSH
19461: LD_EXP 75
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: PPUSH
19470: LD_EXP 45
19474: PPUSH
19475: CALL_OW 241
// end ; end_of_file
19479: LD_VAR 0 1
19483: RET
// every 0 0$5 trigger posily_go do var pom ; var i ;
19484: LD_EXP 68
19488: IFFALSE 19602
19490: GO 19492
19492: DISABLE
19493: LD_INT 0
19495: PPUSH
19496: PPUSH
// begin pom = [ RU2_hv1 , RU2_hv2 ] ;
19497: LD_ADDR_VAR 0 1
19501: PUSH
19502: LD_INT 15
19504: PUSH
19505: LD_INT 16
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: ST_TO_ADDR
// wait ( 2 ) ;
19512: LD_INT 2
19514: PPUSH
19515: CALL_OW 67
// AddComAgressiveMove ( pom , GetX ( bur ) , GetY ( bur ) ) ;
19519: LD_VAR 0 1
19523: PPUSH
19524: LD_EXP 50
19528: PPUSH
19529: CALL_OW 250
19533: PPUSH
19534: LD_EXP 50
19538: PPUSH
19539: CALL_OW 251
19543: PPUSH
19544: CALL_OW 174
// wait ( 0 0$6 ) ;
19548: LD_INT 210
19550: PPUSH
19551: CALL_OW 67
// for i in pom do
19555: LD_ADDR_VAR 0 2
19559: PUSH
19560: LD_VAR 0 1
19564: PUSH
19565: FOR_IN
19566: IFFALSE 19600
// begin SetSide ( i , You ) ;
19568: LD_VAR 0 2
19572: PPUSH
19573: LD_EXP 1
19577: PPUSH
19578: CALL_OW 235
// BurlakComp = BurlakComp ^ i ;
19582: LD_ADDR_EXP 14
19586: PUSH
19587: LD_EXP 14
19591: PUSH
19592: LD_VAR 0 2
19596: ADD
19597: ST_TO_ADDR
// end ;
19598: GO 19565
19600: POP
19601: POP
// end ;
19602: PPOPN 2
19604: END
// on VehicleCaptured ( vehicle , ab , side , human ) do begin if side = 1 then
19605: LD_VAR 0 3
19609: PUSH
19610: LD_INT 1
19612: EQUAL
19613: IFFALSE 19619
// SA_RecaptureBielkovsTank ;
19615: CALL 19823 0 0
// if ab = auto_belkov then
19619: LD_VAR 0 2
19623: PUSH
19624: LD_EXP 70
19628: EQUAL
19629: IFFALSE 19641
// auto_belkov = vehicle ;
19631: LD_ADDR_EXP 70
19635: PUSH
19636: LD_VAR 0 1
19640: ST_TO_ADDR
// debug_strings = [ auto_belkov , GetSide ( auto_belkov ) , bel , IsDrivenBy ( auto_belkov ) ] ;
19641: LD_ADDR_OWVAR 48
19645: PUSH
19646: LD_EXP 70
19650: PUSH
19651: LD_EXP 70
19655: PPUSH
19656: CALL_OW 255
19660: PUSH
19661: LD_EXP 52
19665: PUSH
19666: LD_EXP 70
19670: PPUSH
19671: CALL_OW 311
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: LIST
19680: LIST
19681: ST_TO_ADDR
// enable ;
19682: ENABLE
// end ;
19683: PPOPN 4
19685: END
// on Command ( com ) do var i , j , temp ;
19686: LD_INT 0
19688: PPUSH
19689: PPUSH
19690: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
19691: LD_ADDR_VAR 0 2
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 3
19701: PUSH
19702: EMPTY
19703: LIST
19704: LIST
19705: PUSH
19706: LD_INT 21
19708: PUSH
19709: LD_INT 1
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PPUSH
19720: CALL_OW 69
19724: PUSH
19725: FOR_IN
19726: IFFALSE 19818
// if GetTaskList ( i ) > 0 then
19728: LD_VAR 0 2
19732: PPUSH
19733: CALL_OW 437
19737: PUSH
19738: LD_INT 0
19740: GREATER
19741: IFFALSE 19816
// for j = 1 to GetTaskList ( i ) do
19743: LD_ADDR_VAR 0 3
19747: PUSH
19748: DOUBLE
19749: LD_INT 1
19751: DEC
19752: ST_TO_ADDR
19753: LD_VAR 0 2
19757: PPUSH
19758: CALL_OW 437
19762: PUSH
19763: FOR_TO
19764: IFFALSE 19814
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
19766: LD_ADDR_VAR 0 4
19770: PUSH
19771: LD_VAR 0 2
19775: PPUSH
19776: CALL_OW 437
19780: PUSH
19781: LD_VAR 0 3
19785: ARRAY
19786: PUSH
19787: LD_INT 4
19789: ARRAY
19790: ST_TO_ADDR
// if temp = RU1_dep then
19791: LD_VAR 0 4
19795: PUSH
19796: LD_INT 1
19798: EQUAL
19799: IFFALSE 19812
// SetTaskList ( i , [ ] ) ;
19801: LD_VAR 0 2
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 446
// end ;
19812: GO 19763
19814: POP
19815: POP
19816: GO 19725
19818: POP
19819: POP
// end ; end_of_file
19820: PPOPN 4
19822: END
// export function SA_RecaptureBielkovsTank ; begin
19823: LD_INT 0
19825: PPUSH
// SetAchievement ( ACH_PRE ) ;
19826: LD_STRING ACH_PRE
19828: PPUSH
19829: CALL_OW 543
// end ;
19833: LD_VAR 0 1
19837: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) = 0 do
19838: LD_INT 22
19840: PUSH
19841: LD_INT 1
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: LD_INT 30
19850: PUSH
19851: LD_INT 31
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: PPUSH
19862: CALL_OW 69
19866: PUSH
19867: LD_INT 0
19869: EQUAL
19870: IFFALSE 19882
19872: GO 19874
19874: DISABLE
// SetAchievement ( ACH_SEC ) ; end_of_file
19875: LD_STRING ACH_SEC
19877: PPUSH
19878: CALL_OW 543
19882: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
19883: LD_INT 0
19885: PPUSH
19886: PPUSH
// if not missionNumber then
19887: LD_VAR 0 2
19891: NOT
19892: IFFALSE 19896
// exit ;
19894: GO 20026
// achiv := false ;
19896: LD_ADDR_VAR 0 7
19900: PUSH
19901: LD_INT 0
19903: ST_TO_ADDR
// case campaignNumber of 1 :
19904: LD_VAR 0 1
19908: PUSH
19909: LD_INT 1
19911: DOUBLE
19912: EQUAL
19913: IFTRUE 19917
19915: GO 19928
19917: POP
// achiv := ACH_GOTA ; 2 :
19918: LD_ADDR_VAR 0 7
19922: PUSH
19923: LD_STRING ACH_GOTA
19925: ST_TO_ADDR
19926: GO 19978
19928: LD_INT 2
19930: DOUBLE
19931: EQUAL
19932: IFTRUE 19936
19934: GO 19939
19936: POP
// ; 3 :
19937: GO 19978
19939: LD_INT 3
19941: DOUBLE
19942: EQUAL
19943: IFTRUE 19947
19945: GO 19958
19947: POP
// achiv := ACH_MOTSU ; 4 :
19948: LD_ADDR_VAR 0 7
19952: PUSH
19953: LD_STRING ACH_MOTSU
19955: ST_TO_ADDR
19956: GO 19978
19958: LD_INT 4
19960: DOUBLE
19961: EQUAL
19962: IFTRUE 19966
19964: GO 19977
19966: POP
// achiv := ACH_LOP ; end ;
19967: LD_ADDR_VAR 0 7
19971: PUSH
19972: LD_STRING ACH_LOP
19974: ST_TO_ADDR
19975: GO 19978
19977: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
19978: LD_OWVAR 67
19982: PUSH
19983: LD_INT 3
19985: EQUAL
19986: PUSH
19987: LD_VAR 0 7
19991: AND
19992: PUSH
19993: LD_VAR 0 3
19997: AND
19998: PUSH
19999: LD_VAR 0 4
20003: AND
20004: PUSH
20005: LD_VAR 0 5
20009: AND
20010: IFFALSE 20026
// SetAchievementEX ( achiv , missionNumber ) ;
20012: LD_VAR 0 7
20016: PPUSH
20017: LD_VAR 0 2
20021: PPUSH
20022: CALL_OW 564
// end ;
20026: LD_VAR 0 6
20030: RET
// export function SA_BehemothConstructed ; begin
20031: LD_INT 0
20033: PPUSH
// SetAchievement ( ACH_SMC ) ;
20034: LD_STRING ACH_SMC
20036: PPUSH
20037: CALL_OW 543
// end ;
20041: LD_VAR 0 1
20045: RET

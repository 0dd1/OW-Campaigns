// var Burlak , Bystrov ; var Belkov , Gnyevko , Kirilenkova ; var Kovalyuk , Scholtze ; var Kuzmov ; var Karamazov , Petrovova , Gleb , Petrosyan ; var Lipshchin , Titov , Dolgov , Xavier ; var Oblukov , Kozlov , Kapitsova ; var Survivors4 ; var Bluekher ; var Vybrano ; var Inzenyr ; var Depot ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// SetSide ( Result , 3 ) ;
  74: LD_VAR 0 2
  78: PPUSH
  79: LD_INT 3
  81: PPUSH
  82: CALL_OW 235
// end ;
  86: LD_VAR 0 2
  90: RET
// function load_set ( Ident ) ; begin
  91: LD_INT 0
  93: PPUSH
// if TestCharacters ( Ident ) then
  94: LD_VAR 0 1
  98: PPUSH
  99: CALL_OW 28
 103: IFFALSE 134
// begin Result = CreateCharacterSet ( Ident ) ;
 105: LD_ADDR_VAR 0 2
 109: PUSH
 110: LD_VAR 0 1
 114: PPUSH
 115: CALL_OW 31
 119: ST_TO_ADDR
// SetSide ( Result , 3 ) ;
 120: LD_VAR 0 2
 124: PPUSH
 125: LD_INT 3
 127: PPUSH
 128: CALL_OW 235
// end else
 132: GO 141
// Result = [ ] ;
 134: LD_ADDR_VAR 0 2
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// end ;
 141: LD_VAR 0 2
 145: RET
// function load ; begin
 146: LD_INT 0
 148: PPUSH
// InitUC ;
 149: CALL_OW 18
// InitHC ;
 153: CALL_OW 19
// UC_Side = 3 ;
 157: LD_ADDR_OWVAR 20
 161: PUSH
 162: LD_INT 3
 164: ST_TO_ADDR
// Bystrov = NewCharacter ( Bystrov ) ;
 165: LD_ADDR_LOC 2
 169: PUSH
 170: LD_STRING Bystrov
 172: PPUSH
 173: CALL_OW 25
 177: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 178: LD_ADDR_LOC 1
 182: PUSH
 183: LD_STRING Burlak
 185: PPUSH
 186: CALL 0 0 1
 190: ST_TO_ADDR
// Belkov = load_char ( Belkov ) ;
 191: LD_ADDR_LOC 3
 195: PUSH
 196: LD_STRING Belkov
 198: PPUSH
 199: CALL 0 0 1
 203: ST_TO_ADDR
// Gnyevko = load_char ( Gnyevko ) ;
 204: LD_ADDR_LOC 4
 208: PUSH
 209: LD_STRING Gnyevko
 211: PPUSH
 212: CALL 0 0 1
 216: ST_TO_ADDR
// Kirilenkova = load_char ( Kirilenkova ) ;
 217: LD_ADDR_LOC 5
 221: PUSH
 222: LD_STRING Kirilenkova
 224: PPUSH
 225: CALL 0 0 1
 229: ST_TO_ADDR
// Kovalyuk = load_char ( Kovalyuk ) ;
 230: LD_ADDR_LOC 6
 234: PUSH
 235: LD_STRING Kovalyuk
 237: PPUSH
 238: CALL 0 0 1
 242: ST_TO_ADDR
// Scholtze = load_char ( Scholtze ) ;
 243: LD_ADDR_LOC 7
 247: PUSH
 248: LD_STRING Scholtze
 250: PPUSH
 251: CALL 0 0 1
 255: ST_TO_ADDR
// Kuzmov = load_char ( Kuzmov ) ;
 256: LD_ADDR_LOC 8
 260: PUSH
 261: LD_STRING Kuzmov
 263: PPUSH
 264: CALL 0 0 1
 268: ST_TO_ADDR
// Karamazov = load_char ( Karamazov ) ;
 269: LD_ADDR_LOC 9
 273: PUSH
 274: LD_STRING Karamazov
 276: PPUSH
 277: CALL 0 0 1
 281: ST_TO_ADDR
// Petrovova = load_char ( Petrovova ) ;
 282: LD_ADDR_LOC 10
 286: PUSH
 287: LD_STRING Petrovova
 289: PPUSH
 290: CALL 0 0 1
 294: ST_TO_ADDR
// Gleb = load_char ( Gleb ) ;
 295: LD_ADDR_LOC 11
 299: PUSH
 300: LD_STRING Gleb
 302: PPUSH
 303: CALL 0 0 1
 307: ST_TO_ADDR
// Petrosyan = load_char ( Petrosyan ) ;
 308: LD_ADDR_LOC 12
 312: PUSH
 313: LD_STRING Petrosyan
 315: PPUSH
 316: CALL 0 0 1
 320: ST_TO_ADDR
// Lipshchin = load_char ( Lipshchin ) ;
 321: LD_ADDR_LOC 13
 325: PUSH
 326: LD_STRING Lipshchin
 328: PPUSH
 329: CALL 0 0 1
 333: ST_TO_ADDR
// Titov = load_char ( Titov ) ;
 334: LD_ADDR_LOC 14
 338: PUSH
 339: LD_STRING Titov
 341: PPUSH
 342: CALL 0 0 1
 346: ST_TO_ADDR
// Dolgov = load_char ( Dolgov ) ;
 347: LD_ADDR_LOC 15
 351: PUSH
 352: LD_STRING Dolgov
 354: PPUSH
 355: CALL 0 0 1
 359: ST_TO_ADDR
// Xavier = load_char ( Xavier ) ;
 360: LD_ADDR_LOC 16
 364: PUSH
 365: LD_STRING Xavier
 367: PPUSH
 368: CALL 0 0 1
 372: ST_TO_ADDR
// Oblukov = load_char ( Oblukov ) ;
 373: LD_ADDR_LOC 17
 377: PUSH
 378: LD_STRING Oblukov
 380: PPUSH
 381: CALL 0 0 1
 385: ST_TO_ADDR
// Kozlov = load_char ( Kozlov ) ;
 386: LD_ADDR_LOC 18
 390: PUSH
 391: LD_STRING Kozlov
 393: PPUSH
 394: CALL 0 0 1
 398: ST_TO_ADDR
// Kapitsova = load_char ( Kapitsova ) ;
 399: LD_ADDR_LOC 19
 403: PUSH
 404: LD_STRING Kapitsova
 406: PPUSH
 407: CALL 0 0 1
 411: ST_TO_ADDR
// Survivors4 = load_set ( Survivors4 ) ;
 412: LD_ADDR_LOC 20
 416: PUSH
 417: LD_STRING Survivors4
 419: PPUSH
 420: CALL 91 0 1
 424: ST_TO_ADDR
// end ;
 425: LD_VAR 0 1
 429: RET
// function vytvor_rusaka ; begin
 430: LD_INT 0
 432: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 433: LD_ADDR_OWVAR 21
 437: PUSH
 438: LD_INT 3
 440: ST_TO_ADDR
// UC_side = 3 ;
 441: LD_ADDR_OWVAR 20
 445: PUSH
 446: LD_INT 3
 448: ST_TO_ADDR
// HC_name =  ;
 449: LD_ADDR_OWVAR 26
 453: PUSH
 454: LD_STRING 
 456: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
 457: LD_ADDR_OWVAR 27
 461: PUSH
 462: LD_INT 1
 464: PPUSH
 465: LD_INT 2
 467: PPUSH
 468: CALL_OW 12
 472: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 473: LD_ADDR_OWVAR 28
 477: PUSH
 478: LD_INT 1
 480: ST_TO_ADDR
// PrepareSoldierSkills ( 2 ) ;
 481: LD_INT 2
 483: PPUSH
 484: CALL_OW 375
// Result = CreateHuman ;
 488: LD_ADDR_VAR 0 1
 492: PUSH
 493: CALL_OW 44
 497: ST_TO_ADDR
// end ;
 498: LD_VAR 0 1
 502: RET
// function vytvor_inzenyra ; begin
 503: LD_INT 0
 505: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 506: LD_ADDR_OWVAR 21
 510: PUSH
 511: LD_INT 3
 513: ST_TO_ADDR
// UC_side = 3 ;
 514: LD_ADDR_OWVAR 20
 518: PUSH
 519: LD_INT 3
 521: ST_TO_ADDR
// HC_name =  ;
 522: LD_ADDR_OWVAR 26
 526: PUSH
 527: LD_STRING 
 529: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
 530: LD_ADDR_OWVAR 27
 534: PUSH
 535: LD_INT 1
 537: PPUSH
 538: LD_INT 2
 540: PPUSH
 541: CALL_OW 12
 545: ST_TO_ADDR
// HC_class = CLASS_ENGINEER ;
 546: LD_ADDR_OWVAR 28
 550: PUSH
 551: LD_INT 2
 553: ST_TO_ADDR
// PrepareEngineerSkills ( 4 ) ;
 554: LD_INT 4
 556: PPUSH
 557: CALL_OW 376
// Result = CreateHuman ;
 561: LD_ADDR_VAR 0 1
 565: PUSH
 566: CALL_OW 44
 570: ST_TO_ADDR
// end ;
 571: LD_VAR 0 1
 575: RET
// function Intro ; var Hlavni , I , Vedlejsi , X , Y , Dum , Count ; begin
 576: LD_INT 0
 578: PPUSH
 579: PPUSH
 580: PPUSH
 581: PPUSH
 582: PPUSH
 583: PPUSH
 584: PPUSH
 585: PPUSH
// FogOff ( true ) ;
 586: LD_INT 1
 588: PPUSH
 589: CALL_OW 344
// InGameOn ;
 593: CALL_OW 8
// Dum = najdi_budovu ;
 597: LD_ADDR_VAR 0 7
 601: PUSH
 602: CALL 3983 0 0
 606: ST_TO_ADDR
// if Dum then
 607: LD_VAR 0 7
 611: IFFALSE 645
// begin X = GetX ( Dum ) ;
 613: LD_ADDR_VAR 0 5
 617: PUSH
 618: LD_VAR 0 7
 622: PPUSH
 623: CALL_OW 250
 627: ST_TO_ADDR
// Y = GetY ( Dum ) ;
 628: LD_ADDR_VAR 0 6
 632: PUSH
 633: LD_VAR 0 7
 637: PPUSH
 638: CALL_OW 251
 642: ST_TO_ADDR
// end else
 643: GO 661
// begin X = 41 ;
 645: LD_ADDR_VAR 0 5
 649: PUSH
 650: LD_INT 41
 652: ST_TO_ADDR
// Y = 33 ;
 653: LD_ADDR_VAR 0 6
 657: PUSH
 658: LD_INT 33
 660: ST_TO_ADDR
// end ; PlaceUnitXYR ( Bystrov , X , Y , 7 , false ) ;
 661: LD_LOC 2
 665: PPUSH
 666: LD_VAR 0 5
 670: PPUSH
 671: LD_VAR 0 6
 675: PPUSH
 676: LD_INT 7
 678: PPUSH
 679: LD_INT 0
 681: PPUSH
 682: CALL_OW 50
// PlaceUnitXYR ( Burlak , GetX ( Bystrov ) , GetY ( Bystrov ) + 10 , 6 , false ) ;
 686: LD_LOC 1
 690: PPUSH
 691: LD_LOC 2
 695: PPUSH
 696: CALL_OW 250
 700: PPUSH
 701: LD_LOC 2
 705: PPUSH
 706: CALL_OW 251
 710: PUSH
 711: LD_INT 10
 713: PLUS
 714: PPUSH
 715: LD_INT 6
 717: PPUSH
 718: LD_INT 0
 720: PPUSH
 721: CALL_OW 50
// CenterNowOnUnits ( [ Burlak ] ) ;
 725: LD_LOC 1
 729: PUSH
 730: EMPTY
 731: LIST
 732: PPUSH
 733: CALL_OW 87
// ComMoveUnit ( Burlak , Bystrov ) ;
 737: LD_LOC 1
 741: PPUSH
 742: LD_LOC 2
 746: PPUSH
 747: CALL_OW 112
// Count = 0 ;
 751: LD_ADDR_VAR 0 8
 755: PUSH
 756: LD_INT 0
 758: ST_TO_ADDR
// while ( GetDistUnits ( Bystrov , Burlak ) > 2 ) and ( Count < 10 ) do
 759: LD_LOC 2
 763: PPUSH
 764: LD_LOC 1
 768: PPUSH
 769: CALL_OW 296
 773: PUSH
 774: LD_INT 2
 776: GREATER
 777: PUSH
 778: LD_VAR 0 8
 782: PUSH
 783: LD_INT 10
 785: LESS
 786: AND
 787: IFFALSE 845
// begin Wait ( 0 0$1 ) ;
 789: LD_INT 35
 791: PPUSH
 792: CALL_OW 67
// CenterOnUnits ( [ Burlak ] ) ;
 796: LD_LOC 1
 800: PUSH
 801: EMPTY
 802: LIST
 803: PPUSH
 804: CALL_OW 85
// ComMoveUnit ( Burlak , Bystrov ) ;
 808: LD_LOC 1
 812: PPUSH
 813: LD_LOC 2
 817: PPUSH
 818: CALL_OW 112
// Wait ( 0 0$1 ) ;
 822: LD_INT 35
 824: PPUSH
 825: CALL_OW 67
// Count = Count + 1 ;
 829: LD_ADDR_VAR 0 8
 833: PUSH
 834: LD_VAR 0 8
 838: PUSH
 839: LD_INT 1
 841: PLUS
 842: ST_TO_ADDR
// end ;
 843: GO 759
// ComTurnUnit ( Burlak , Bystrov ) ;
 845: LD_LOC 1
 849: PPUSH
 850: LD_LOC 2
 854: PPUSH
 855: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
 859: LD_LOC 2
 863: PPUSH
 864: LD_LOC 1
 868: PPUSH
 869: CALL_OW 119
// Wait ( 0 0$0.5 ) ;
 873: LD_INT 18
 875: PPUSH
 876: CALL_OW 67
// ComHold ( [ Burlak , Bystrov ] ) ;
 880: LD_LOC 1
 884: PUSH
 885: LD_LOC 2
 889: PUSH
 890: EMPTY
 891: LIST
 892: LIST
 893: PPUSH
 894: CALL_OW 140
// CenterOnUnits ( [ Burlak , Bystrov ] ) ;
 898: LD_LOC 1
 902: PUSH
 903: LD_LOC 2
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PPUSH
 912: CALL_OW 85
// Wait ( 0 0$1 ) ;
 916: LD_INT 35
 918: PPUSH
 919: CALL_OW 67
// create_crates ;
 923: CALL 4156 0 0
// Say ( Burlak , DStart-Bur-1 ) ;
 927: LD_LOC 1
 931: PPUSH
 932: LD_STRING DStart-Bur-1
 934: PPUSH
 935: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
 939: LD_LOC 1
 943: PPUSH
 944: LD_LOC 2
 948: PPUSH
 949: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
 953: LD_LOC 2
 957: PPUSH
 958: LD_LOC 1
 962: PPUSH
 963: CALL_OW 119
// Say ( Bystrov , DStart-Bys-1 ) ;
 967: LD_LOC 2
 971: PPUSH
 972: LD_STRING DStart-Bys-1
 974: PPUSH
 975: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
 979: LD_LOC 1
 983: PPUSH
 984: LD_LOC 2
 988: PPUSH
 989: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
 993: LD_LOC 2
 997: PPUSH
 998: LD_LOC 1
1002: PPUSH
1003: CALL_OW 119
// Say ( Burlak , DStart-Bur-2 ) ;
1007: LD_LOC 1
1011: PPUSH
1012: LD_STRING DStart-Bur-2
1014: PPUSH
1015: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1019: LD_LOC 1
1023: PPUSH
1024: LD_LOC 2
1028: PPUSH
1029: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1033: LD_LOC 2
1037: PPUSH
1038: LD_LOC 1
1042: PPUSH
1043: CALL_OW 119
// Say ( Bystrov , DStart-Bys-2 ) ;
1047: LD_LOC 2
1051: PPUSH
1052: LD_STRING DStart-Bys-2
1054: PPUSH
1055: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1059: LD_LOC 1
1063: PPUSH
1064: LD_LOC 2
1068: PPUSH
1069: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1073: LD_LOC 2
1077: PPUSH
1078: LD_LOC 1
1082: PPUSH
1083: CALL_OW 119
// Say ( Burlak , DStart-Bur-3 ) ;
1087: LD_LOC 1
1091: PPUSH
1092: LD_STRING DStart-Bur-3
1094: PPUSH
1095: CALL_OW 88
// collect_crates ;
1099: CALL 4214 0 0
// Wait ( 0 0$1 ) ;
1103: LD_INT 35
1105: PPUSH
1106: CALL_OW 67
// ComMoveXY ( Bystrov , GetX ( Bystrov ) + Rand ( 2 , 6 ) , GetY ( Bystrov ) + Rand ( - 2 , 2 ) ) ;
1110: LD_LOC 2
1114: PPUSH
1115: LD_LOC 2
1119: PPUSH
1120: CALL_OW 250
1124: PUSH
1125: LD_INT 2
1127: PPUSH
1128: LD_INT 6
1130: PPUSH
1131: CALL_OW 12
1135: PLUS
1136: PPUSH
1137: LD_LOC 2
1141: PPUSH
1142: CALL_OW 251
1146: PUSH
1147: LD_INT 2
1149: NEG
1150: PPUSH
1151: LD_INT 2
1153: PPUSH
1154: CALL_OW 12
1158: PLUS
1159: PPUSH
1160: CALL_OW 111
// Wait ( 0 0$3 ) ;
1164: LD_INT 105
1166: PPUSH
1167: CALL_OW 67
// ComMoveUnit ( Burlak , Bystrov ) ;
1171: LD_LOC 1
1175: PPUSH
1176: LD_LOC 2
1180: PPUSH
1181: CALL_OW 112
// Count = 0 ;
1185: LD_ADDR_VAR 0 8
1189: PUSH
1190: LD_INT 0
1192: ST_TO_ADDR
// while ( GetDistUnits ( Bystrov , Burlak ) > 2 ) and ( Count < 10 ) do
1193: LD_LOC 2
1197: PPUSH
1198: LD_LOC 1
1202: PPUSH
1203: CALL_OW 296
1207: PUSH
1208: LD_INT 2
1210: GREATER
1211: PUSH
1212: LD_VAR 0 8
1216: PUSH
1217: LD_INT 10
1219: LESS
1220: AND
1221: IFFALSE 1267
// begin Wait ( 0 0$1 ) ;
1223: LD_INT 35
1225: PPUSH
1226: CALL_OW 67
// ComMoveUnit ( Burlak , Bystrov ) ;
1230: LD_LOC 1
1234: PPUSH
1235: LD_LOC 2
1239: PPUSH
1240: CALL_OW 112
// Wait ( 0 0$1 ) ;
1244: LD_INT 35
1246: PPUSH
1247: CALL_OW 67
// Count = Count + 1 ;
1251: LD_ADDR_VAR 0 8
1255: PUSH
1256: LD_VAR 0 8
1260: PUSH
1261: LD_INT 1
1263: PLUS
1264: ST_TO_ADDR
// end ;
1265: GO 1193
// ComTurnUnit ( Burlak , Bystrov ) ;
1267: LD_LOC 1
1271: PPUSH
1272: LD_LOC 2
1276: PPUSH
1277: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1281: LD_LOC 2
1285: PPUSH
1286: LD_LOC 1
1290: PPUSH
1291: CALL_OW 119
// Wait ( 0 0$0.5 ) ;
1295: LD_INT 18
1297: PPUSH
1298: CALL_OW 67
// ComHold ( [ Burlak , Bystrov ] ) ;
1302: LD_LOC 1
1306: PUSH
1307: LD_LOC 2
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: PPUSH
1316: CALL_OW 140
// Wait ( 0 0$1 ) ;
1320: LD_INT 35
1322: PPUSH
1323: CALL_OW 67
// Say ( Bystrov , DStart-Bys-3 ) ;
1327: LD_LOC 2
1331: PPUSH
1332: LD_STRING DStart-Bys-3
1334: PPUSH
1335: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1339: LD_LOC 1
1343: PPUSH
1344: LD_LOC 2
1348: PPUSH
1349: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1353: LD_LOC 2
1357: PPUSH
1358: LD_LOC 1
1362: PPUSH
1363: CALL_OW 119
// Say ( Burlak , DStart-Bur-4 ) ;
1367: LD_LOC 1
1371: PPUSH
1372: LD_STRING DStart-Bur-4
1374: PPUSH
1375: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1379: LD_LOC 1
1383: PPUSH
1384: LD_LOC 2
1388: PPUSH
1389: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1393: LD_LOC 2
1397: PPUSH
1398: LD_LOC 1
1402: PPUSH
1403: CALL_OW 119
// Say ( Bystrov , DStart-Bys-4 ) ;
1407: LD_LOC 2
1411: PPUSH
1412: LD_STRING DStart-Bys-4
1414: PPUSH
1415: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1419: LD_LOC 1
1423: PPUSH
1424: LD_LOC 2
1428: PPUSH
1429: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1433: LD_LOC 2
1437: PPUSH
1438: LD_LOC 1
1442: PPUSH
1443: CALL_OW 119
// Say ( Burlak , DStart-Bur-5 ) ;
1447: LD_LOC 1
1451: PPUSH
1452: LD_STRING DStart-Bur-5
1454: PPUSH
1455: CALL_OW 88
// Wait ( 0 0$1 ) ;
1459: LD_INT 35
1461: PPUSH
1462: CALL_OW 67
// ComTurnUnit ( Burlak , Bystrov ) ;
1466: LD_LOC 1
1470: PPUSH
1471: LD_LOC 2
1475: PPUSH
1476: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1480: LD_LOC 2
1484: PPUSH
1485: LD_LOC 1
1489: PPUSH
1490: CALL_OW 119
// Say ( Bystrov , DStart-Bys-5 ) ;
1494: LD_LOC 2
1498: PPUSH
1499: LD_STRING DStart-Bys-5
1501: PPUSH
1502: CALL_OW 88
// ComTurnUnit ( Burlak , Bystrov ) ;
1506: LD_LOC 1
1510: PPUSH
1511: LD_LOC 2
1515: PPUSH
1516: CALL_OW 119
// ComTurnUnit ( Bystrov , Burlak ) ;
1520: LD_LOC 2
1524: PPUSH
1525: LD_LOC 1
1529: PPUSH
1530: CALL_OW 119
// Say ( Burlak , DStart-Bur-6 ) ;
1534: LD_LOC 1
1538: PPUSH
1539: LD_STRING DStart-Bur-6
1541: PPUSH
1542: CALL_OW 88
// AddComWait ( Burlak , 0 0$2 ) ;
1546: LD_LOC 1
1550: PPUSH
1551: LD_INT 70
1553: PPUSH
1554: CALL_OW 202
// if Dum then
1558: LD_VAR 0 7
1562: IFFALSE 1589
// AddComEnterUnit ( [ Bystrov , Burlak ] , Dum ) else
1564: LD_LOC 2
1568: PUSH
1569: LD_LOC 1
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: PPUSH
1578: LD_VAR 0 7
1582: PPUSH
1583: CALL_OW 180
1587: GO 1613
// AddComMoveXY ( [ Bystrov , Burlak ] , 60 , 47 ) ;
1589: LD_LOC 2
1593: PUSH
1594: LD_LOC 1
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: PPUSH
1603: LD_INT 60
1605: PPUSH
1606: LD_INT 47
1608: PPUSH
1609: CALL_OW 171
// Wait ( 0 0$5 ) ;
1613: LD_INT 175
1615: PPUSH
1616: CALL_OW 67
// Hlavni = [ Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Survivors4 diff [ 0 ] ;
1620: LD_ADDR_VAR 0 2
1624: PUSH
1625: LD_LOC 3
1629: PUSH
1630: LD_LOC 4
1634: PUSH
1635: LD_LOC 5
1639: PUSH
1640: LD_LOC 6
1644: PUSH
1645: LD_LOC 7
1649: PUSH
1650: LD_LOC 8
1654: PUSH
1655: LD_LOC 9
1659: PUSH
1660: LD_LOC 10
1664: PUSH
1665: LD_LOC 11
1669: PUSH
1670: LD_LOC 12
1674: PUSH
1675: LD_LOC 13
1679: PUSH
1680: LD_LOC 14
1684: PUSH
1685: LD_LOC 15
1689: PUSH
1690: LD_LOC 16
1694: PUSH
1695: LD_LOC 17
1699: PUSH
1700: LD_LOC 18
1704: PUSH
1705: LD_LOC 19
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: LIST
1715: LIST
1716: LIST
1717: LIST
1718: LIST
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: LD_LOC 20
1733: UNION
1734: PUSH
1735: LD_INT 0
1737: PUSH
1738: EMPTY
1739: LIST
1740: DIFF
1741: ST_TO_ADDR
// Vedlejsi = [ ] ;
1742: LD_ADDR_VAR 0 4
1746: PUSH
1747: EMPTY
1748: ST_TO_ADDR
// for I = Hlavni to 6 do
1749: LD_ADDR_VAR 0 3
1753: PUSH
1754: DOUBLE
1755: LD_VAR 0 2
1759: DEC
1760: ST_TO_ADDR
1761: LD_INT 6
1763: PUSH
1764: FOR_TO
1765: IFFALSE 1788
// Vedlejsi = Vedlejsi union [ vytvor_rusaka ] ;
1767: LD_ADDR_VAR 0 4
1771: PUSH
1772: LD_VAR 0 4
1776: PUSH
1777: CALL 430 0 0
1781: PUSH
1782: EMPTY
1783: LIST
1784: UNION
1785: ST_TO_ADDR
1786: GO 1764
1788: POP
1789: POP
// Vybrano = CharacterSelection ( 1 , 3 , 6 , [ SEL_CHANGE_CLASS , Burlak , SEL_DONT_CHANGE_CLASS , Bystrov , SEL_CHANGE_CLASS , SEL_NOT_HIRED , SEL_CHANGEABLE ] ^ Hlavni ^ Vedlejsi , [ CLASS_SOLDIER , [ CLASS_ENGINEER , 1 ] , CLASS_MECHANIC , CLASS_SCIENTISTIC , [ CLASS_BAZOOKER , 0 , 2 ] ] ) ;
1790: LD_ADDR_LOC 22
1794: PUSH
1795: LD_STRING 1
1797: PPUSH
1798: LD_INT 3
1800: PPUSH
1801: LD_INT 6
1803: PPUSH
1804: LD_INT -5
1806: PUSH
1807: LD_LOC 1
1811: PUSH
1812: LD_INT -6
1814: PUSH
1815: LD_LOC 2
1819: PUSH
1820: LD_INT -5
1822: PUSH
1823: LD_INT -2
1825: PUSH
1826: LD_INT -3
1828: PUSH
1829: EMPTY
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: PUSH
1838: LD_VAR 0 2
1842: ADD
1843: PUSH
1844: LD_VAR 0 4
1848: ADD
1849: PPUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 1
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: PUSH
1863: LD_INT 3
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 9
1871: PUSH
1872: LD_INT 0
1874: PUSH
1875: LD_INT 2
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: PPUSH
1890: CALL_OW 42
1894: ST_TO_ADDR
// SaveCharacters ( [ Burlak ] , Burlak ) ;
1895: LD_LOC 1
1899: PUSH
1900: EMPTY
1901: LIST
1902: PPUSH
1903: LD_STRING Burlak
1905: PPUSH
1906: CALL_OW 38
// SaveCharacters ( [ Bystrov ] , Bystrov ) ;
1910: LD_LOC 2
1914: PUSH
1915: EMPTY
1916: LIST
1917: PPUSH
1918: LD_STRING Bystrov
1920: PPUSH
1921: CALL_OW 38
// if Belkov in Vybrano then
1925: LD_LOC 3
1929: PUSH
1930: LD_LOC 22
1934: IN
1935: IFFALSE 1947
// SaveVariable ( 13 , BelkovLoc ) ;
1937: LD_INT 13
1939: PPUSH
1940: LD_STRING BelkovLoc
1942: PPUSH
1943: CALL_OW 39
// if Belkov then
1947: LD_LOC 3
1951: IFFALSE 1968
// SaveCharacters ( [ Belkov ] , Belkov ) ;
1953: LD_LOC 3
1957: PUSH
1958: EMPTY
1959: LIST
1960: PPUSH
1961: LD_STRING Belkov
1963: PPUSH
1964: CALL_OW 38
// if Gnyevko in Vybrano then
1968: LD_LOC 4
1972: PUSH
1973: LD_LOC 22
1977: IN
1978: IFFALSE 1990
// SaveVariable ( 13 , GnyevkoLoc ) ;
1980: LD_INT 13
1982: PPUSH
1983: LD_STRING GnyevkoLoc
1985: PPUSH
1986: CALL_OW 39
// if Gnyevko then
1990: LD_LOC 4
1994: IFFALSE 2011
// SaveCharacters ( [ Gnyevko ] , Gnyevko ) ;
1996: LD_LOC 4
2000: PUSH
2001: EMPTY
2002: LIST
2003: PPUSH
2004: LD_STRING Gnyevko
2006: PPUSH
2007: CALL_OW 38
// if Kirilenkova in Vybrano then
2011: LD_LOC 5
2015: PUSH
2016: LD_LOC 22
2020: IN
2021: IFFALSE 2033
// SaveVariable ( 13 , KirilenkovaLoc ) ;
2023: LD_INT 13
2025: PPUSH
2026: LD_STRING KirilenkovaLoc
2028: PPUSH
2029: CALL_OW 39
// if Kirilenkova then
2033: LD_LOC 5
2037: IFFALSE 2054
// SaveCharacters ( [ Kirilenkova ] , Kirilenkova ) ;
2039: LD_LOC 5
2043: PUSH
2044: EMPTY
2045: LIST
2046: PPUSH
2047: LD_STRING Kirilenkova
2049: PPUSH
2050: CALL_OW 38
// if Kovalyuk in Vybrano then
2054: LD_LOC 6
2058: PUSH
2059: LD_LOC 22
2063: IN
2064: IFFALSE 2076
// SaveVariable ( 13 , KovalyukLoc ) ;
2066: LD_INT 13
2068: PPUSH
2069: LD_STRING KovalyukLoc
2071: PPUSH
2072: CALL_OW 39
// if Kovalyuk then
2076: LD_LOC 6
2080: IFFALSE 2097
// SaveCharacters ( [ Kovalyuk ] , Kovalyuk ) ;
2082: LD_LOC 6
2086: PUSH
2087: EMPTY
2088: LIST
2089: PPUSH
2090: LD_STRING Kovalyuk
2092: PPUSH
2093: CALL_OW 38
// if Scholtze in Vybrano then
2097: LD_LOC 7
2101: PUSH
2102: LD_LOC 22
2106: IN
2107: IFFALSE 2119
// SaveVariable ( 13 , ScholtzeLoc ) ;
2109: LD_INT 13
2111: PPUSH
2112: LD_STRING ScholtzeLoc
2114: PPUSH
2115: CALL_OW 39
// if Scholtze then
2119: LD_LOC 7
2123: IFFALSE 2140
// SaveCharacters ( [ Scholtze ] , Scholtze ) ;
2125: LD_LOC 7
2129: PUSH
2130: EMPTY
2131: LIST
2132: PPUSH
2133: LD_STRING Scholtze
2135: PPUSH
2136: CALL_OW 38
// if Kuzmov in Vybrano then
2140: LD_LOC 8
2144: PUSH
2145: LD_LOC 22
2149: IN
2150: IFFALSE 2162
// SaveVariable ( 13 , KuzmovLoc ) ;
2152: LD_INT 13
2154: PPUSH
2155: LD_STRING KuzmovLoc
2157: PPUSH
2158: CALL_OW 39
// if Kuzmov then
2162: LD_LOC 8
2166: IFFALSE 2183
// SaveCharacters ( [ Kuzmov ] , Kuzmov ) ;
2168: LD_LOC 8
2172: PUSH
2173: EMPTY
2174: LIST
2175: PPUSH
2176: LD_STRING Kuzmov
2178: PPUSH
2179: CALL_OW 38
// if Karamazov in Vybrano then
2183: LD_LOC 9
2187: PUSH
2188: LD_LOC 22
2192: IN
2193: IFFALSE 2205
// SaveVariable ( 13 , KaramazovLoc ) ;
2195: LD_INT 13
2197: PPUSH
2198: LD_STRING KaramazovLoc
2200: PPUSH
2201: CALL_OW 39
// if Karamazov then
2205: LD_LOC 9
2209: IFFALSE 2226
// SaveCharacters ( [ Karamazov ] , Karamazov ) ;
2211: LD_LOC 9
2215: PUSH
2216: EMPTY
2217: LIST
2218: PPUSH
2219: LD_STRING Karamazov
2221: PPUSH
2222: CALL_OW 38
// if Petrovova in Vybrano then
2226: LD_LOC 10
2230: PUSH
2231: LD_LOC 22
2235: IN
2236: IFFALSE 2248
// SaveVariable ( 13 , PetrovovaLoc ) ;
2238: LD_INT 13
2240: PPUSH
2241: LD_STRING PetrovovaLoc
2243: PPUSH
2244: CALL_OW 39
// if Petrovova then
2248: LD_LOC 10
2252: IFFALSE 2269
// SaveCharacters ( [ Petrovova ] , Petrovova ) ;
2254: LD_LOC 10
2258: PUSH
2259: EMPTY
2260: LIST
2261: PPUSH
2262: LD_STRING Petrovova
2264: PPUSH
2265: CALL_OW 38
// if Gleb in Vybrano then
2269: LD_LOC 11
2273: PUSH
2274: LD_LOC 22
2278: IN
2279: IFFALSE 2291
// SaveVariable ( 13 , GlebLoc ) ;
2281: LD_INT 13
2283: PPUSH
2284: LD_STRING GlebLoc
2286: PPUSH
2287: CALL_OW 39
// if Gleb then
2291: LD_LOC 11
2295: IFFALSE 2312
// SaveCharacters ( [ Gleb ] , Gleb ) ;
2297: LD_LOC 11
2301: PUSH
2302: EMPTY
2303: LIST
2304: PPUSH
2305: LD_STRING Gleb
2307: PPUSH
2308: CALL_OW 38
// if Petrosyan in Vybrano then
2312: LD_LOC 12
2316: PUSH
2317: LD_LOC 22
2321: IN
2322: IFFALSE 2334
// SaveVariable ( 13 , PetrosyanLoc ) ;
2324: LD_INT 13
2326: PPUSH
2327: LD_STRING PetrosyanLoc
2329: PPUSH
2330: CALL_OW 39
// if Petrosyan then
2334: LD_LOC 12
2338: IFFALSE 2355
// SaveCharacters ( [ Petrosyan ] , Petrosyan ) ;
2340: LD_LOC 12
2344: PUSH
2345: EMPTY
2346: LIST
2347: PPUSH
2348: LD_STRING Petrosyan
2350: PPUSH
2351: CALL_OW 38
// if Lipshchin in Vybrano then
2355: LD_LOC 13
2359: PUSH
2360: LD_LOC 22
2364: IN
2365: IFFALSE 2377
// SaveVariable ( 13 , LipshchinLoc ) ;
2367: LD_INT 13
2369: PPUSH
2370: LD_STRING LipshchinLoc
2372: PPUSH
2373: CALL_OW 39
// if Lipshchin then
2377: LD_LOC 13
2381: IFFALSE 2398
// SaveCharacters ( [ Lipshchin ] , Lipshchin ) ;
2383: LD_LOC 13
2387: PUSH
2388: EMPTY
2389: LIST
2390: PPUSH
2391: LD_STRING Lipshchin
2393: PPUSH
2394: CALL_OW 38
// if Titov in Vybrano then
2398: LD_LOC 14
2402: PUSH
2403: LD_LOC 22
2407: IN
2408: IFFALSE 2420
// SaveVariable ( 13 , TitovLoc ) ;
2410: LD_INT 13
2412: PPUSH
2413: LD_STRING TitovLoc
2415: PPUSH
2416: CALL_OW 39
// if Titov then
2420: LD_LOC 14
2424: IFFALSE 2441
// SaveCharacters ( [ Titov ] , Titov ) ;
2426: LD_LOC 14
2430: PUSH
2431: EMPTY
2432: LIST
2433: PPUSH
2434: LD_STRING Titov
2436: PPUSH
2437: CALL_OW 38
// if Dolgov in Vybrano then
2441: LD_LOC 15
2445: PUSH
2446: LD_LOC 22
2450: IN
2451: IFFALSE 2463
// SaveVariable ( 13 , DolgovLoc ) ;
2453: LD_INT 13
2455: PPUSH
2456: LD_STRING DolgovLoc
2458: PPUSH
2459: CALL_OW 39
// if Dolgov then
2463: LD_LOC 15
2467: IFFALSE 2484
// SaveCharacters ( [ Dolgov ] , Dolgov ) ;
2469: LD_LOC 15
2473: PUSH
2474: EMPTY
2475: LIST
2476: PPUSH
2477: LD_STRING Dolgov
2479: PPUSH
2480: CALL_OW 38
// if Xavier in Vybrano then
2484: LD_LOC 16
2488: PUSH
2489: LD_LOC 22
2493: IN
2494: IFFALSE 2506
// SaveVariable ( 13 , XavierLoc ) ;
2496: LD_INT 13
2498: PPUSH
2499: LD_STRING XavierLoc
2501: PPUSH
2502: CALL_OW 39
// if Xavier then
2506: LD_LOC 16
2510: IFFALSE 2527
// SaveCharacters ( [ Xavier ] , Xavier ) ;
2512: LD_LOC 16
2516: PUSH
2517: EMPTY
2518: LIST
2519: PPUSH
2520: LD_STRING Xavier
2522: PPUSH
2523: CALL_OW 38
// if Oblukov in Vybrano then
2527: LD_LOC 17
2531: PUSH
2532: LD_LOC 22
2536: IN
2537: IFFALSE 2549
// SaveVariable ( 13 , OblukovLoc ) ;
2539: LD_INT 13
2541: PPUSH
2542: LD_STRING OblukovLoc
2544: PPUSH
2545: CALL_OW 39
// if Oblukov then
2549: LD_LOC 17
2553: IFFALSE 2570
// SaveCharacters ( [ Oblukov ] , Oblukov ) ;
2555: LD_LOC 17
2559: PUSH
2560: EMPTY
2561: LIST
2562: PPUSH
2563: LD_STRING Oblukov
2565: PPUSH
2566: CALL_OW 38
// if Kozlov in Vybrano then
2570: LD_LOC 18
2574: PUSH
2575: LD_LOC 22
2579: IN
2580: IFFALSE 2592
// SaveVariable ( 13 , KozlovLoc ) ;
2582: LD_INT 13
2584: PPUSH
2585: LD_STRING KozlovLoc
2587: PPUSH
2588: CALL_OW 39
// if Kozlov then
2592: LD_LOC 18
2596: IFFALSE 2613
// SaveCharacters ( [ Kozlov ] , Kozlov ) ;
2598: LD_LOC 18
2602: PUSH
2603: EMPTY
2604: LIST
2605: PPUSH
2606: LD_STRING Kozlov
2608: PPUSH
2609: CALL_OW 38
// if Kapitsova in Vybrano then
2613: LD_LOC 19
2617: PUSH
2618: LD_LOC 22
2622: IN
2623: IFFALSE 2635
// SaveVariable ( 13 , KapitsovaLoc ) ;
2625: LD_INT 13
2627: PPUSH
2628: LD_STRING KapitsovaLoc
2630: PPUSH
2631: CALL_OW 39
// if Kapitsova then
2635: LD_LOC 19
2639: IFFALSE 2656
// SaveCharacters ( [ Kapitsova ] , Kapitsova ) ;
2641: LD_LOC 19
2645: PUSH
2646: EMPTY
2647: LIST
2648: PPUSH
2649: LD_STRING Kapitsova
2651: PPUSH
2652: CALL_OW 38
// Vedlejsi = Vybrano diff Hlavni ;
2656: LD_ADDR_VAR 0 4
2660: PUSH
2661: LD_LOC 22
2665: PUSH
2666: LD_VAR 0 2
2670: DIFF
2671: ST_TO_ADDR
// if Vedlejsi then
2672: LD_VAR 0 4
2676: IFFALSE 2690
// SaveCharacters ( Vedlejsi , Others_Ru13 ) ;
2678: LD_VAR 0 4
2682: PPUSH
2683: LD_STRING Others_Ru13
2685: PPUSH
2686: CALL_OW 38
// Survivors4 = Survivors4 diff Vybrano ;
2690: LD_ADDR_LOC 20
2694: PUSH
2695: LD_LOC 20
2699: PUSH
2700: LD_LOC 22
2704: DIFF
2705: ST_TO_ADDR
// SaveCharacters ( Survivors4 , Survivors4 ) ;
2706: LD_LOC 20
2710: PPUSH
2711: LD_STRING Survivors4
2713: PPUSH
2714: CALL_OW 38
// Wait ( 0 0$2 ) ;
2718: LD_INT 70
2720: PPUSH
2721: CALL_OW 67
// InGameOff ;
2725: CALL_OW 9
// end ;
2729: LD_VAR 0 1
2733: RET
// function zakladna ; var Bluekher , Spec , Tmp , Base ; begin
2734: LD_INT 0
2736: PPUSH
2737: PPUSH
2738: PPUSH
2739: PPUSH
2740: PPUSH
// Bluekher = LoadVariable ( Bluekher , [ ] ) ;
2741: LD_ADDR_VAR 0 2
2745: PUSH
2746: LD_STRING Bluekher
2748: PPUSH
2749: EMPTY
2750: PPUSH
2751: CALL_OW 30
2755: ST_TO_ADDR
// SetResourceVisibility ( 20 , 34 , 3 ) ;
2756: LD_INT 20
2758: PPUSH
2759: LD_INT 34
2761: PPUSH
2762: LD_INT 3
2764: PPUSH
2765: CALL_OW 441
// SetResourceVisibility ( 14 , 23 , 3 ) ;
2769: LD_INT 14
2771: PPUSH
2772: LD_INT 23
2774: PPUSH
2775: LD_INT 3
2777: PPUSH
2778: CALL_OW 441
// if not Bluekher then
2782: LD_VAR 0 2
2786: NOT
2787: IFFALSE 2971
// Bluekher = [ [ 20 , 34 , 5 , B_SIBERITE_MINE , 5 , NATION_RUSSIAN , 0 , 0 ] , [ 23 , 27 , 1 , B_DEPOT , 5 , NATION_RUSSIAN , 0 , 0 ] , [ 14 , 23 , 0 , B_OIL_MINE , 5 , NATION_RUSSIAN , 0 , 0 ] , [ 36 , 28 , 2 , B_LAB_FULL , 5 , NATION_RUSSIAN , B_LAB_SPACETIME , B_LAB_SIBERIUM ] , [ 49 , 37 , 4 , B_WORKSHOP , 5 , NATION_RUSSIAN , 0 , 0 ] ] ;
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: LD_INT 20
2796: PUSH
2797: LD_INT 34
2799: PUSH
2800: LD_INT 5
2802: PUSH
2803: LD_INT 30
2805: PUSH
2806: LD_INT 5
2808: PUSH
2809: LD_INT 3
2811: PUSH
2812: LD_INT 0
2814: PUSH
2815: LD_INT 0
2817: PUSH
2818: EMPTY
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: LIST
2827: PUSH
2828: LD_INT 23
2830: PUSH
2831: LD_INT 27
2833: PUSH
2834: LD_INT 1
2836: PUSH
2837: LD_INT 0
2839: PUSH
2840: LD_INT 5
2842: PUSH
2843: LD_INT 3
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: PUSH
2862: LD_INT 14
2864: PUSH
2865: LD_INT 23
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: LD_INT 29
2873: PUSH
2874: LD_INT 5
2876: PUSH
2877: LD_INT 3
2879: PUSH
2880: LD_INT 0
2882: PUSH
2883: LD_INT 0
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: LIST
2893: LIST
2894: LIST
2895: PUSH
2896: LD_INT 36
2898: PUSH
2899: LD_INT 28
2901: PUSH
2902: LD_INT 2
2904: PUSH
2905: LD_INT 8
2907: PUSH
2908: LD_INT 5
2910: PUSH
2911: LD_INT 3
2913: PUSH
2914: LD_INT 14
2916: PUSH
2917: LD_INT 11
2919: PUSH
2920: EMPTY
2921: LIST
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: PUSH
2930: LD_INT 49
2932: PUSH
2933: LD_INT 37
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 2
2941: PUSH
2942: LD_INT 5
2944: PUSH
2945: LD_INT 3
2947: PUSH
2948: LD_INT 0
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: PUSH
2964: EMPTY
2965: LIST
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: ST_TO_ADDR
// UC_Side = 3 ;
2971: LD_ADDR_OWVAR 20
2975: PUSH
2976: LD_INT 3
2978: ST_TO_ADDR
// Result = [ ] ;
2979: LD_ADDR_VAR 0 1
2983: PUSH
2984: EMPTY
2985: ST_TO_ADDR
// for Spec in Bluekher do
2986: LD_ADDR_VAR 0 3
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: FOR_IN
2997: IFFALSE 3207
// begin BC_Type = Spec [ 4 ] ;
2999: LD_ADDR_OWVAR 42
3003: PUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 4
3011: ARRAY
3012: ST_TO_ADDR
// BC_Level = Spec [ 5 ] ;
3013: LD_ADDR_OWVAR 43
3017: PUSH
3018: LD_VAR 0 3
3022: PUSH
3023: LD_INT 5
3025: ARRAY
3026: ST_TO_ADDR
// UC_Nation = Spec [ 6 ] ;
3027: LD_ADDR_OWVAR 21
3031: PUSH
3032: LD_VAR 0 3
3036: PUSH
3037: LD_INT 6
3039: ARRAY
3040: ST_TO_ADDR
// if BC_Type in [ B_LAB , B_LAB_HALF , B_LAB_FULL ] then
3041: LD_OWVAR 42
3045: PUSH
3046: LD_INT 6
3048: PUSH
3049: LD_INT 7
3051: PUSH
3052: LD_INT 8
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: LIST
3059: IN
3060: IFFALSE 3092
// begin BC_Kind1 = Spec [ 7 ] ;
3062: LD_ADDR_OWVAR 44
3066: PUSH
3067: LD_VAR 0 3
3071: PUSH
3072: LD_INT 7
3074: ARRAY
3075: ST_TO_ADDR
// BC_Kind2 = Spec [ 8 ] ;
3076: LD_ADDR_OWVAR 45
3080: PUSH
3081: LD_VAR 0 3
3085: PUSH
3086: LD_INT 8
3088: ARRAY
3089: ST_TO_ADDR
// end else
3090: GO 3108
// begin BC_Kind1 = 0 ;
3092: LD_ADDR_OWVAR 44
3096: PUSH
3097: LD_INT 0
3099: ST_TO_ADDR
// BC_Kind2 = 0 ;
3100: LD_ADDR_OWVAR 45
3104: PUSH
3105: LD_INT 0
3107: ST_TO_ADDR
// end ; Tmp = CreateAndPlaceBuildingXYD ( Spec [ 1 ] , Spec [ 2 ] , Spec [ 3 ] ) ;
3108: LD_ADDR_VAR 0 4
3112: PUSH
3113: LD_VAR 0 3
3117: PUSH
3118: LD_INT 1
3120: ARRAY
3121: PPUSH
3122: LD_VAR 0 3
3126: PUSH
3127: LD_INT 2
3129: ARRAY
3130: PPUSH
3131: LD_VAR 0 3
3135: PUSH
3136: LD_INT 3
3138: ARRAY
3139: PPUSH
3140: CALL_OW 47
3144: ST_TO_ADDR
// if not Tmp then
3145: LD_VAR 0 4
3149: NOT
3150: IFFALSE 3154
// continue ;
3152: GO 2996
// if BC_Type in [ B_TURRET , B_BUNKER ] then
3154: LD_OWVAR 42
3158: PUSH
3159: LD_INT 33
3161: PUSH
3162: LD_INT 32
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: IN
3169: IFFALSE 3189
// PlaceWeaponTurret ( Tmp , Spec [ 7 ] ) ;
3171: LD_VAR 0 4
3175: PPUSH
3176: LD_VAR 0 3
3180: PUSH
3181: LD_INT 7
3183: ARRAY
3184: PPUSH
3185: CALL_OW 431
// Result = Result ^ Tmp ;
3189: LD_ADDR_VAR 0 1
3193: PUSH
3194: LD_VAR 0 1
3198: PUSH
3199: LD_VAR 0 4
3203: ADD
3204: ST_TO_ADDR
// end ;
3205: GO 2996
3207: POP
3208: POP
// Tmp = UnitFilter ( Result , [ [ F_BTYPE , B_DEPOT ] ] ) union UnitFilter ( Result , [ [ F_BTYPE , B_WAREHOUSE ] ] ) ;
3209: LD_ADDR_VAR 0 4
3213: PUSH
3214: LD_VAR 0 1
3218: PPUSH
3219: LD_INT 30
3221: PUSH
3222: LD_INT 0
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: EMPTY
3230: LIST
3231: PPUSH
3232: CALL_OW 72
3236: PUSH
3237: LD_VAR 0 1
3241: PPUSH
3242: LD_INT 30
3244: PUSH
3245: LD_INT 1
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: EMPTY
3253: LIST
3254: PPUSH
3255: CALL_OW 72
3259: UNION
3260: ST_TO_ADDR
// SetBName ( Tmp , bluekher ) ;
3261: LD_VAR 0 4
3265: PPUSH
3266: LD_STRING bluekher
3268: PPUSH
3269: CALL_OW 500
// for Spec in Tmp do
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 4
3282: PUSH
3283: FOR_IN
3284: IFFALSE 3333
// begin Base = GetBase ( Spec ) ;
3286: LD_ADDR_VAR 0 5
3290: PUSH
3291: LD_VAR 0 3
3295: PPUSH
3296: CALL_OW 274
3300: ST_TO_ADDR
// AddResourceType ( Base , MAT_CANS , 250 ) ;
3301: LD_VAR 0 5
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 250
3311: PPUSH
3312: CALL_OW 276
// AddResourceType ( Base , MAT_OIL , 150 ) ;
3316: LD_VAR 0 5
3320: PPUSH
3321: LD_INT 2
3323: PPUSH
3324: LD_INT 150
3326: PPUSH
3327: CALL_OW 276
// end ;
3331: GO 3283
3333: POP
3334: POP
// end ;
3335: LD_VAR 0 1
3339: RET
// function krovi ; var Postava , Budova ; begin
3340: LD_INT 0
3342: PPUSH
3343: PPUSH
3344: PPUSH
// Budova = najdi_lab ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL 3681 0 0
3354: ST_TO_ADDR
// if Budova then
3355: LD_VAR 0 3
3359: IFFALSE 3424
// begin Postava = vytvor_postavu ( CLASS_SCIENTISTIC ) ;
3361: LD_ADDR_VAR 0 2
3365: PUSH
3366: LD_INT 4
3368: PPUSH
3369: CALL 3536 0 1
3373: ST_TO_ADDR
// PlaceHumanInUnit ( Postava , Budova ) ;
3374: LD_VAR 0 2
3378: PPUSH
3379: LD_VAR 0 3
3383: PPUSH
3384: CALL_OW 52
// AddComResearch ( Budova , TECH_TECH1 ) ;
3388: LD_VAR 0 3
3392: PPUSH
3393: LD_INT 48
3395: PPUSH
3396: CALL_OW 184
// AddComResearch ( Budova , TECH_TECH2 ) ;
3400: LD_VAR 0 3
3404: PPUSH
3405: LD_INT 49
3407: PPUSH
3408: CALL_OW 184
// AddComResearch ( Budova , TECH_TECH3 ) ;
3412: LD_VAR 0 3
3416: PPUSH
3417: LD_INT 50
3419: PPUSH
3420: CALL_OW 184
// end ; Depot = najdi_depot ;
3424: LD_ADDR_LOC 24
3428: PUSH
3429: CALL 3789 0 0
3433: ST_TO_ADDR
// if Depot then
3434: LD_LOC 24
3438: IFFALSE 3467
// begin Inzenyr = vytvor_postavu ( CLASS_ENGINEER ) ;
3440: LD_ADDR_LOC 23
3444: PUSH
3445: LD_INT 2
3447: PPUSH
3448: CALL 3536 0 1
3452: ST_TO_ADDR
// PlaceHumanInUnit ( Inzenyr , Depot ) ;
3453: LD_LOC 23
3457: PPUSH
3458: LD_LOC 24
3462: PPUSH
3463: CALL_OW 52
// end ; Budova = najdi_tovarnu ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL 3886 0 0
3476: ST_TO_ADDR
// if Budova then
3477: LD_VAR 0 3
3481: IFFALSE 3531
// begin Postava = vytvor_postavu ( CLASS_MECHANIC ) ;
3483: LD_ADDR_VAR 0 2
3487: PUSH
3488: LD_INT 3
3490: PPUSH
3491: CALL 3536 0 1
3495: ST_TO_ADDR
// PlaceHumanInUnit ( Postava , Budova ) ;
3496: LD_VAR 0 2
3500: PPUSH
3501: LD_VAR 0 3
3505: PPUSH
3506: CALL_OW 52
// AddComConstruct ( Budova , RU_MEDIUM_WHEELED , ENGINE_COMBUSTION , CONTROL_MANUAL , RU_HEAVY_MACHINE_GUN ) ;
3510: LD_VAR 0 3
3514: PPUSH
3515: LD_INT 21
3517: PPUSH
3518: LD_INT 1
3520: PPUSH
3521: LD_INT 1
3523: PPUSH
3524: LD_INT 42
3526: PPUSH
3527: CALL_OW 185
// end ; end ;
3531: LD_VAR 0 1
3535: RET
// function vytvor_postavu ( Cls ) ; begin
3536: LD_INT 0
3538: PPUSH
// HC_Name =  ;
3539: LD_ADDR_OWVAR 26
3543: PUSH
3544: LD_STRING 
3546: ST_TO_ADDR
// HC_Sex = Rand ( 1 , 2 ) ;
3547: LD_ADDR_OWVAR 27
3551: PUSH
3552: LD_INT 1
3554: PPUSH
3555: LD_INT 2
3557: PPUSH
3558: CALL_OW 12
3562: ST_TO_ADDR
// HC_Class = Cls ;
3563: LD_ADDR_OWVAR 28
3567: PUSH
3568: LD_VAR 0 1
3572: ST_TO_ADDR
// PrepareClassSkills ( Cls , 6 ) ;
3573: LD_VAR 0 1
3577: PPUSH
3578: LD_INT 6
3580: PPUSH
3581: CALL_OW 374
// Result = CreateHuman ;
3585: LD_ADDR_VAR 0 2
3589: PUSH
3590: CALL_OW 44
3594: ST_TO_ADDR
// end ;
3595: LD_VAR 0 2
3599: RET
// function najdi_dum ( Typ ) ; begin
3600: LD_INT 0
3602: PPUSH
// Result = FilterAllUnits ( [ [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , Typ ] ] ) ;
3603: LD_ADDR_VAR 0 2
3607: PUSH
3608: LD_INT 52
3610: PUSH
3611: EMPTY
3612: LIST
3613: PUSH
3614: LD_INT 21
3616: PUSH
3617: LD_INT 3
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 30
3626: PUSH
3627: LD_VAR 0 1
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: LIST
3640: PPUSH
3641: CALL_OW 69
3645: ST_TO_ADDR
// if Result then
3646: LD_VAR 0 2
3650: IFFALSE 3668
// Result = Result [ 1 ] else
3652: LD_ADDR_VAR 0 2
3656: PUSH
3657: LD_VAR 0 2
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: ST_TO_ADDR
3666: GO 3676
// Result = 0 ;
3668: LD_ADDR_VAR 0 2
3672: PUSH
3673: LD_INT 0
3675: ST_TO_ADDR
// end ;
3676: LD_VAR 0 2
3680: RET
// function najdi_lab ; begin
3681: LD_INT 0
3683: PPUSH
// Result = FilterAllUnits ( [ [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OR , [ F_BTYPE , B_LAB ] , [ F_BTYPE , B_LAB_HALF ] , [ F_BTYPE , B_LAB_FULL ] ] ] ) ;
3684: LD_ADDR_VAR 0 1
3688: PUSH
3689: LD_INT 52
3691: PUSH
3692: EMPTY
3693: LIST
3694: PUSH
3695: LD_INT 21
3697: PUSH
3698: LD_INT 3
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: PUSH
3705: LD_INT 2
3707: PUSH
3708: LD_INT 30
3710: PUSH
3711: LD_INT 6
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_INT 30
3720: PUSH
3721: LD_INT 7
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PUSH
3728: LD_INT 30
3730: PUSH
3731: LD_INT 8
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: LIST
3748: PPUSH
3749: CALL_OW 69
3753: ST_TO_ADDR
// if Result then
3754: LD_VAR 0 1
3758: IFFALSE 3776
// Result = Result [ 1 ] else
3760: LD_ADDR_VAR 0 1
3764: PUSH
3765: LD_VAR 0 1
3769: PUSH
3770: LD_INT 1
3772: ARRAY
3773: ST_TO_ADDR
3774: GO 3784
// Result = 0 ;
3776: LD_ADDR_VAR 0 1
3780: PUSH
3781: LD_INT 0
3783: ST_TO_ADDR
// end ;
3784: LD_VAR 0 1
3788: RET
// function najdi_depot ; begin
3789: LD_INT 0
3791: PPUSH
// Result = FilterAllUnits ( [ [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OR , [ F_BTYPE , B_WAREHOUSE ] , [ F_BTYPE , B_DEPOT ] ] ] ) ;
3792: LD_ADDR_VAR 0 1
3796: PUSH
3797: LD_INT 52
3799: PUSH
3800: EMPTY
3801: LIST
3802: PUSH
3803: LD_INT 21
3805: PUSH
3806: LD_INT 3
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: LD_INT 30
3818: PUSH
3819: LD_INT 1
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 0
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: ST_TO_ADDR
// if Result then
3851: LD_VAR 0 1
3855: IFFALSE 3873
// Result = Result [ 1 ] else
3857: LD_ADDR_VAR 0 1
3861: PUSH
3862: LD_VAR 0 1
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: ST_TO_ADDR
3871: GO 3881
// Result = 0 ;
3873: LD_ADDR_VAR 0 1
3877: PUSH
3878: LD_INT 0
3880: ST_TO_ADDR
// end ;
3881: LD_VAR 0 1
3885: RET
// function najdi_tovarnu ; begin
3886: LD_INT 0
3888: PPUSH
// Result = FilterAllUnits ( [ [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OR , [ F_BTYPE , B_WORKSHOP ] , [ F_BTYPE , B_FACTORY ] ] ] ) ;
3889: LD_ADDR_VAR 0 1
3893: PUSH
3894: LD_INT 52
3896: PUSH
3897: EMPTY
3898: LIST
3899: PUSH
3900: LD_INT 21
3902: PUSH
3903: LD_INT 3
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 2
3912: PUSH
3913: LD_INT 30
3915: PUSH
3916: LD_INT 2
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: LD_INT 30
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PUSH
3933: EMPTY
3934: LIST
3935: LIST
3936: LIST
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: LIST
3942: PPUSH
3943: CALL_OW 69
3947: ST_TO_ADDR
// if Result then
3948: LD_VAR 0 1
3952: IFFALSE 3970
// Result = Result [ 1 ] else
3954: LD_ADDR_VAR 0 1
3958: PUSH
3959: LD_VAR 0 1
3963: PUSH
3964: LD_INT 1
3966: ARRAY
3967: ST_TO_ADDR
3968: GO 3978
// Result = 0 ;
3970: LD_ADDR_VAR 0 1
3974: PUSH
3975: LD_INT 0
3977: ST_TO_ADDR
// end ;
3978: LD_VAR 0 1
3982: RET
// function najdi_budovu ; begin
3983: LD_INT 0
3985: PPUSH
// Result = najdi_dum ( B_LAB_FULL ) ;
3986: LD_ADDR_VAR 0 1
3990: PUSH
3991: LD_INT 8
3993: PPUSH
3994: CALL 3600 0 1
3998: ST_TO_ADDR
// if Result then
3999: LD_VAR 0 1
4003: IFFALSE 4007
// exit ;
4005: GO 4151
// Result = najdi_dum ( B_LAB_HALF ) ;
4007: LD_ADDR_VAR 0 1
4011: PUSH
4012: LD_INT 7
4014: PPUSH
4015: CALL 3600 0 1
4019: ST_TO_ADDR
// if Result then
4020: LD_VAR 0 1
4024: IFFALSE 4028
// exit ;
4026: GO 4151
// Result = najdi_dum ( B_LAB ) ;
4028: LD_ADDR_VAR 0 1
4032: PUSH
4033: LD_INT 6
4035: PPUSH
4036: CALL 3600 0 1
4040: ST_TO_ADDR
// if Result then
4041: LD_VAR 0 1
4045: IFFALSE 4049
// exit ;
4047: GO 4151
// Result = najdi_dum ( B_DEPOT ) ;
4049: LD_ADDR_VAR 0 1
4053: PUSH
4054: LD_INT 0
4056: PPUSH
4057: CALL 3600 0 1
4061: ST_TO_ADDR
// if Result then
4062: LD_VAR 0 1
4066: IFFALSE 4070
// exit ;
4068: GO 4151
// Result = najdi_dum ( B_WAREHOUSE ) ;
4070: LD_ADDR_VAR 0 1
4074: PUSH
4075: LD_INT 1
4077: PPUSH
4078: CALL 3600 0 1
4082: ST_TO_ADDR
// if Result then
4083: LD_VAR 0 1
4087: IFFALSE 4091
// exit ;
4089: GO 4151
// Result = FilterAllUnits ( [ [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
4091: LD_ADDR_VAR 0 1
4095: PUSH
4096: LD_INT 52
4098: PUSH
4099: EMPTY
4100: LIST
4101: PUSH
4102: LD_INT 21
4104: PUSH
4105: LD_INT 3
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: PPUSH
4116: CALL_OW 69
4120: ST_TO_ADDR
// if Result then
4121: LD_VAR 0 1
4125: IFFALSE 4143
// Result = Result [ 1 ] else
4127: LD_ADDR_VAR 0 1
4131: PUSH
4132: LD_VAR 0 1
4136: PUSH
4137: LD_INT 1
4139: ARRAY
4140: ST_TO_ADDR
4141: GO 4151
// Result = 0 ;
4143: LD_ADDR_VAR 0 1
4147: PUSH
4148: LD_INT 0
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// function create_crates ; begin
4156: LD_INT 0
4158: PPUSH
// if not Depot then
4159: LD_LOC 24
4163: NOT
4164: IFFALSE 4168
// exit ;
4166: GO 4209
// CreateCratesXYR ( 5 , GetX ( Depot ) + 3 , GetY ( Depot ) - 3 , 20 , true ) ;
4168: LD_INT 5
4170: PPUSH
4171: LD_LOC 24
4175: PPUSH
4176: CALL_OW 250
4180: PUSH
4181: LD_INT 3
4183: PLUS
4184: PPUSH
4185: LD_LOC 24
4189: PPUSH
4190: CALL_OW 251
4194: PUSH
4195: LD_INT 3
4197: MINUS
4198: PPUSH
4199: LD_INT 20
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: CALL_OW 56
// end ;
4209: LD_VAR 0 1
4213: RET
// function collect_crates ; var Bedny , Delka , I , X , Y ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
4221: PPUSH
// Bedny = GetListOfCratesInArea ( Celek ) ;
4222: LD_ADDR_VAR 0 2
4226: PUSH
4227: LD_INT 1
4229: PPUSH
4230: CALL_OW 435
4234: ST_TO_ADDR
// if not Bedny then
4235: LD_VAR 0 2
4239: NOT
4240: IFFALSE 4244
// exit ;
4242: GO 4366
// ComExitBuilding ( Inzenyr ) ;
4244: LD_LOC 23
4248: PPUSH
4249: CALL_OW 122
// Delka = Bedny div 2 ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: LD_VAR 0 2
4262: PUSH
4263: LD_INT 2
4265: DIV
4266: ST_TO_ADDR
// for I = 1 to Delka do
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: DOUBLE
4273: LD_INT 1
4275: DEC
4276: ST_TO_ADDR
4277: LD_VAR 0 3
4281: PUSH
4282: FOR_TO
4283: IFFALSE 4350
// begin X = Bedny [ 2 * I - 1 ] ;
4285: LD_ADDR_VAR 0 5
4289: PUSH
4290: LD_VAR 0 2
4294: PUSH
4295: LD_INT 2
4297: PUSH
4298: LD_VAR 0 4
4302: MUL
4303: PUSH
4304: LD_INT 1
4306: MINUS
4307: ARRAY
4308: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
4309: LD_ADDR_VAR 0 6
4313: PUSH
4314: LD_VAR 0 2
4318: PUSH
4319: LD_INT 2
4321: PUSH
4322: LD_VAR 0 4
4326: MUL
4327: ARRAY
4328: ST_TO_ADDR
// AddComCollect ( Inzenyr , X , Y ) ;
4329: LD_LOC 23
4333: PPUSH
4334: LD_VAR 0 5
4338: PPUSH
4339: LD_VAR 0 6
4343: PPUSH
4344: CALL_OW 177
// end ;
4348: GO 4282
4350: POP
4351: POP
// AddComEnterUnit ( Inzenyr , Depot ) ;
4352: LD_LOC 23
4356: PPUSH
4357: LD_LOC 24
4361: PPUSH
4362: CALL_OW 180
// end ;
4366: LD_VAR 0 1
4370: RET
// on VehicleConstructed ( Veh , Fact ) do begin Wait ( 0 0$1 ) ;
4371: LD_INT 35
4373: PPUSH
4374: CALL_OW 67
// ComMoveXY ( Veh , 32 , 6 ) ;
4378: LD_VAR 0 1
4382: PPUSH
4383: LD_INT 32
4385: PPUSH
4386: LD_INT 6
4388: PPUSH
4389: CALL_OW 111
// AddComMoveXY ( Veh , 3 , 3 ) ;
4393: LD_VAR 0 1
4397: PPUSH
4398: LD_INT 3
4400: PPUSH
4401: LD_INT 3
4403: PPUSH
4404: CALL_OW 171
// AddComMoveUnit ( Veh , Fact ) ;
4408: LD_VAR 0 1
4412: PPUSH
4413: LD_VAR 0 2
4417: PPUSH
4418: CALL_OW 172
// AddComMoveXY ( Veh , 32 , 6 ) ;
4422: LD_VAR 0 1
4426: PPUSH
4427: LD_INT 32
4429: PPUSH
4430: LD_INT 6
4432: PPUSH
4433: CALL_OW 171
// end ;
4437: PPOPN 2
4439: END
// starting begin load ;
4440: CALL 146 0 0
// zakladna ;
4444: CALL 2734 0 0
// krovi ;
4448: CALL 3340 0 0
// Intro ;
4452: CALL 576 0 0
// ChangeMap ( %_Cont , %_Cont ) ;
4456: LD_STRING %_Cont
4458: PPUSH
4459: LD_STRING %_Cont
4461: PPUSH
4462: CALL_OW 340
// end ;
4466: END

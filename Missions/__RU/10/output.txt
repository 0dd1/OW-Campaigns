// export you ; export Burlak , Gnyevko , Belkov , Kirilenkova , Kovalyuk , Popov , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Vsevolod , Xavier , Yashin , Oblukov , Kozlov , Kapitsova , Stolypin ; export LabCaptured , Trotskij , depot ; export people , map_env , survivor ; var animals ; function RemoveAnimals ; var un ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// for un in all_units do
   4: LD_ADDR_VAR 0 2
   8: PUSH
   9: LD_OWVAR 3
  13: PUSH
  14: FOR_IN
  15: IFFALSE 72
// begin animals := animals ^ [ [ un , GetX ( un ) , GetY ( un ) ] ] ;
  17: LD_ADDR_LOC 1
  21: PUSH
  22: LD_LOC 1
  26: PUSH
  27: LD_VAR 0 2
  31: PUSH
  32: LD_VAR 0 2
  36: PPUSH
  37: CALL_OW 250
  41: PUSH
  42: LD_VAR 0 2
  46: PPUSH
  47: CALL_OW 251
  51: PUSH
  52: EMPTY
  53: LIST
  54: LIST
  55: LIST
  56: PUSH
  57: EMPTY
  58: LIST
  59: ADD
  60: ST_TO_ADDR
// RemoveUnit ( un ) ;
  61: LD_VAR 0 2
  65: PPUSH
  66: CALL_OW 64
// end ;
  70: GO 14
  72: POP
  73: POP
// end ;
  74: LD_VAR 0 1
  78: RET
// function RestoreAnimals ; var un ; begin
  79: LD_INT 0
  81: PPUSH
  82: PPUSH
// for un in animals do
  83: LD_ADDR_VAR 0 2
  87: PUSH
  88: LD_LOC 1
  92: PUSH
  93: FOR_IN
  94: IFFALSE 135
// PlaceUnitXYR ( un [ 1 ] , un [ 2 ] , un [ 3 ] , 10 , false ) ;
  96: LD_VAR 0 2
 100: PUSH
 101: LD_INT 1
 103: ARRAY
 104: PPUSH
 105: LD_VAR 0 2
 109: PUSH
 110: LD_INT 2
 112: ARRAY
 113: PPUSH
 114: LD_VAR 0 2
 118: PUSH
 119: LD_INT 3
 121: ARRAY
 122: PPUSH
 123: LD_INT 10
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: CALL_OW 50
 133: GO 93
 135: POP
 136: POP
// end ;
 137: LD_VAR 0 1
 141: RET
// function prepare_map ; var un ; begin
 142: LD_INT 0
 144: PPUSH
 145: PPUSH
// map_env := LoadVariable ( Environment , [ ] ) ;
 146: LD_ADDR_EXP 28
 150: PUSH
 151: LD_STRING Environment
 153: PPUSH
 154: EMPTY
 155: PPUSH
 156: CALL_OW 30
 160: ST_TO_ADDR
// PlaceEnvironmentList ( map_env ) ;
 161: LD_EXP 28
 165: PPUSH
 166: CALL_OW 354
// end ;
 170: LD_VAR 0 1
 174: RET
// function prepare_base ; var building , un , weap , x , y , dir ; begin
 175: LD_INT 0
 177: PPUSH
 178: PPUSH
 179: PPUSH
 180: PPUSH
 181: PPUSH
 182: PPUSH
 183: PPUSH
// depot := false ;
 184: LD_ADDR_EXP 26
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// uc_side := you ;
 192: LD_ADDR_OWVAR 20
 196: PUSH
 197: LD_EXP 1
 201: ST_TO_ADDR
// Trotskij := LoadVariable ( Trotskij , [ ] ) ;
 202: LD_ADDR_EXP 25
 206: PUSH
 207: LD_STRING Trotskij
 209: PPUSH
 210: EMPTY
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// for building in Trotskij do
 217: LD_ADDR_VAR 0 2
 221: PUSH
 222: LD_EXP 25
 226: PUSH
 227: FOR_IN
 228: IFFALSE 600
// begin bc_type := building [ 1 ] ;
 230: LD_ADDR_OWVAR 42
 234: PUSH
 235: LD_VAR 0 2
 239: PUSH
 240: LD_INT 1
 242: ARRAY
 243: ST_TO_ADDR
// x := building [ 2 ] ;
 244: LD_ADDR_VAR 0 5
 248: PUSH
 249: LD_VAR 0 2
 253: PUSH
 254: LD_INT 2
 256: ARRAY
 257: ST_TO_ADDR
// y := building [ 3 ] ;
 258: LD_ADDR_VAR 0 6
 262: PUSH
 263: LD_VAR 0 2
 267: PUSH
 268: LD_INT 3
 270: ARRAY
 271: ST_TO_ADDR
// dir := building [ 4 ] ;
 272: LD_ADDR_VAR 0 7
 276: PUSH
 277: LD_VAR 0 2
 281: PUSH
 282: LD_INT 4
 284: ARRAY
 285: ST_TO_ADDR
// bc_level := building [ 5 ] + 1 ;
 286: LD_ADDR_OWVAR 43
 290: PUSH
 291: LD_VAR 0 2
 295: PUSH
 296: LD_INT 5
 298: ARRAY
 299: PUSH
 300: LD_INT 1
 302: PLUS
 303: ST_TO_ADDR
// uc_nation := building [ 6 ] ;
 304: LD_ADDR_OWVAR 21
 308: PUSH
 309: LD_VAR 0 2
 313: PUSH
 314: LD_INT 6
 316: ARRAY
 317: ST_TO_ADDR
// if building > 7 then
 318: LD_VAR 0 2
 322: PUSH
 323: LD_INT 7
 325: GREATER
 326: IFFALSE 356
// begin bc_kind1 := building [ 7 ] ;
 328: LD_ADDR_OWVAR 44
 332: PUSH
 333: LD_VAR 0 2
 337: PUSH
 338: LD_INT 7
 340: ARRAY
 341: ST_TO_ADDR
// bc_kind2 := building [ 8 ] ;
 342: LD_ADDR_OWVAR 45
 346: PUSH
 347: LD_VAR 0 2
 351: PUSH
 352: LD_INT 8
 354: ARRAY
 355: ST_TO_ADDR
// end ; if bc_type in [ b_oil_mine , b_siberite_mine ] then
 356: LD_OWVAR 42
 360: PUSH
 361: LD_INT 29
 363: PUSH
 364: LD_INT 30
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: IN
 371: IFFALSE 392
// SetResourceVisibility ( x , y , you ) ;
 373: LD_VAR 0 5
 377: PPUSH
 378: LD_VAR 0 6
 382: PPUSH
 383: LD_EXP 1
 387: PPUSH
 388: CALL_OW 441
// if bc_type = b_breastwork then
 392: LD_OWVAR 42
 396: PUSH
 397: LD_INT 31
 399: EQUAL
 400: IFFALSE 433
// bc_type := [ b_bunker , b_turret , b_turret ] [ Rand ( 1 , 3 ) ] ;
 402: LD_ADDR_OWVAR 42
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 33
 412: PUSH
 413: LD_INT 33
 415: PUSH
 416: EMPTY
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 1
 423: PPUSH
 424: LD_INT 3
 426: PPUSH
 427: CALL_OW 12
 431: ARRAY
 432: ST_TO_ADDR
// un := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
 433: LD_ADDR_VAR 0 3
 437: PUSH
 438: LD_VAR 0 5
 442: PPUSH
 443: LD_VAR 0 6
 447: PPUSH
 448: LD_VAR 0 7
 452: PPUSH
 453: CALL_OW 47
 457: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
 458: LD_OWVAR 42
 462: PUSH
 463: LD_INT 32
 465: PUSH
 466: LD_INT 33
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: IN
 473: IFFALSE 598
// begin weap := [ ru_gun , ru_rocket_launcher , ru_heavy_gun ] ;
 475: LD_ADDR_VAR 0 4
 479: PUSH
 480: LD_INT 44
 482: PUSH
 483: LD_INT 45
 485: PUSH
 486: LD_INT 46
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: ST_TO_ADDR
// if ( building > 6 ) then
 494: LD_VAR 0 2
 498: PUSH
 499: LD_INT 6
 501: GREATER
 502: IFFALSE 570
// begin if ( building [ 7 ] in weap ) then
 504: LD_VAR 0 2
 508: PUSH
 509: LD_INT 7
 511: ARRAY
 512: PUSH
 513: LD_VAR 0 4
 517: IN
 518: IFFALSE 540
// PlaceWeaponTurret ( un , building [ 7 ] ) else
 520: LD_VAR 0 3
 524: PPUSH
 525: LD_VAR 0 2
 529: PUSH
 530: LD_INT 7
 532: ARRAY
 533: PPUSH
 534: CALL_OW 431
 538: GO 568
// PlaceWeaponTurret ( un , weap [ Rand ( 1 , weap ) ] ) ;
 540: LD_VAR 0 3
 544: PPUSH
 545: LD_VAR 0 4
 549: PUSH
 550: LD_INT 1
 552: PPUSH
 553: LD_VAR 0 4
 557: PPUSH
 558: CALL_OW 12
 562: ARRAY
 563: PPUSH
 564: CALL_OW 431
// end else
 568: GO 598
// PlaceWeaponTurret ( un , weap [ Rand ( 1 , weap ) ] ) ;
 570: LD_VAR 0 3
 574: PPUSH
 575: LD_VAR 0 4
 579: PUSH
 580: LD_INT 1
 582: PPUSH
 583: LD_VAR 0 4
 587: PPUSH
 588: CALL_OW 12
 592: ARRAY
 593: PPUSH
 594: CALL_OW 431
// end ; end ;
 598: GO 227
 600: POP
 601: POP
// building := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 602: LD_ADDR_VAR 0 2
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_EXP 1
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 2
 621: PUSH
 622: LD_INT 30
 624: PUSH
 625: LD_INT 0
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: LD_INT 30
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: PPUSH
 651: CALL_OW 69
 655: ST_TO_ADDR
// for un in building do
 656: LD_ADDR_VAR 0 3
 660: PUSH
 661: LD_VAR 0 2
 665: PUSH
 666: FOR_IN
 667: IFFALSE 748
// begin if not depot then
 669: LD_EXP 26
 673: NOT
 674: IFFALSE 686
// depot := un ;
 676: LD_ADDR_EXP 26
 680: PUSH
 681: LD_VAR 0 3
 685: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 125 ) ;
 686: LD_VAR 0 3
 690: PPUSH
 691: CALL_OW 274
 695: PPUSH
 696: LD_INT 1
 698: PPUSH
 699: LD_INT 125
 701: PPUSH
 702: CALL_OW 277
// SetResourceType ( GetBase ( un ) , mat_oil , 38 ) ;
 706: LD_VAR 0 3
 710: PPUSH
 711: CALL_OW 274
 715: PPUSH
 716: LD_INT 2
 718: PPUSH
 719: LD_INT 38
 721: PPUSH
 722: CALL_OW 277
// SetResourceType ( GetBase ( un ) , mat_siberit , 12 ) ;
 726: LD_VAR 0 3
 730: PPUSH
 731: CALL_OW 274
 735: PPUSH
 736: LD_INT 3
 738: PPUSH
 739: LD_INT 12
 741: PPUSH
 742: CALL_OW 277
// end ;
 746: GO 666
 748: POP
 749: POP
// end ;
 750: LD_VAR 0 1
 754: RET
// function prepare_units ; var un , x , y , placed , num , veh , important , depot_list , depot , factory_list , mechanics , lab_list , scientists ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
 760: PPUSH
 761: PPUSH
 762: PPUSH
 763: PPUSH
 764: PPUSH
 765: PPUSH
 766: PPUSH
 767: PPUSH
 768: PPUSH
 769: PPUSH
 770: PPUSH
// uc_side = 3 ;
 771: LD_ADDR_OWVAR 20
 775: PUSH
 776: LD_INT 3
 778: ST_TO_ADDR
// uc_nation = nation_russian ;
 779: LD_ADDR_OWVAR 21
 783: PUSH
 784: LD_INT 3
 786: ST_TO_ADDR
// mechanics := [ ] ;
 787: LD_ADDR_VAR 0 12
 791: PUSH
 792: EMPTY
 793: ST_TO_ADDR
// scientists := [ ] ;
 794: LD_ADDR_VAR 0 14
 798: PUSH
 799: EMPTY
 800: ST_TO_ADDR
// LabCaptured := LoadVariable ( LabCaptured , false ) ;
 801: LD_ADDR_EXP 24
 805: PUSH
 806: LD_STRING LabCaptured
 808: PPUSH
 809: LD_INT 0
 811: PPUSH
 812: CALL_OW 30
 816: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 817: LD_ADDR_EXP 2
 821: PUSH
 822: LD_STRING Burlak
 824: PPUSH
 825: CALL_OW 34
 829: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
 830: LD_ADDR_EXP 19
 834: PUSH
 835: LD_STRING Yashin
 837: PPUSH
 838: CALL_OW 25
 842: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
 843: LD_ADDR_EXP 7
 847: PUSH
 848: LD_STRING Popov
 850: PPUSH
 851: CALL_OW 25
 855: ST_TO_ADDR
// SetClass ( Burlak , class_mechanic ) ;
 856: LD_EXP 2
 860: PPUSH
 861: LD_INT 3
 863: PPUSH
 864: CALL_OW 336
// if TestCharacters ( Vsevolod ) and CheckCharacterSet ( Vsevolod ) then
 868: LD_STRING Vsevolod
 870: PPUSH
 871: CALL_OW 28
 875: PUSH
 876: LD_STRING Vsevolod
 878: PPUSH
 879: CALL_OW 29
 883: AND
 884: IFFALSE 911
// begin Vsevolod := CreateCharacter ( Vsevolod ) ;
 886: LD_ADDR_EXP 17
 890: PUSH
 891: LD_STRING Vsevolod
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// survivor := vsevolod ;
 899: LD_ADDR_EXP 29
 903: PUSH
 904: LD_EXP 17
 908: ST_TO_ADDR
// end else
 909: GO 934
// begin Stolypin := NewCharacter ( Stolypin ) ;
 911: LD_ADDR_EXP 23
 915: PUSH
 916: LD_STRING Stolypin
 918: PPUSH
 919: CALL_OW 25
 923: ST_TO_ADDR
// survivor := Stolypin ;
 924: LD_ADDR_EXP 29
 928: PUSH
 929: LD_EXP 23
 933: ST_TO_ADDR
// end ; uc_direction := 3 ;
 934: LD_ADDR_OWVAR 24
 938: PUSH
 939: LD_INT 3
 941: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
 942: LD_ADDR_OWVAR 37
 946: PUSH
 947: LD_INT 22
 949: ST_TO_ADDR
// vc_engine := engine_combustion ;
 950: LD_ADDR_OWVAR 39
 954: PUSH
 955: LD_INT 1
 957: ST_TO_ADDR
// vc_control := control_manual ;
 958: LD_ADDR_OWVAR 38
 962: PUSH
 963: LD_INT 1
 965: ST_TO_ADDR
// vc_weapon := ru_gun ;
 966: LD_ADDR_OWVAR 40
 970: PUSH
 971: LD_INT 44
 973: ST_TO_ADDR
// veh := CreateVehicle ;
 974: LD_ADDR_VAR 0 7
 978: PUSH
 979: CALL_OW 45
 983: ST_TO_ADDR
// people := LoadAllMen ;
 984: LD_ADDR_EXP 27
 988: PUSH
 989: CALL 2745 0 0
 993: ST_TO_ADDR
// if people < 10 then
 994: LD_EXP 27
 998: PUSH
 999: LD_INT 10
1001: LESS
1002: IFFALSE 1059
// for un := 1 to ( 10 - people ) do
1004: LD_ADDR_VAR 0 2
1008: PUSH
1009: DOUBLE
1010: LD_INT 1
1012: DEC
1013: ST_TO_ADDR
1014: LD_INT 10
1016: PUSH
1017: LD_EXP 27
1021: MINUS
1022: PUSH
1023: FOR_TO
1024: IFFALSE 1057
// begin PrepareHuman ( 0 , 0 , 6 ) ;
1026: LD_INT 0
1028: PPUSH
1029: LD_INT 0
1031: PPUSH
1032: LD_INT 6
1034: PPUSH
1035: CALL_OW 380
// people := people ^ CreateHuman ;
1039: LD_ADDR_EXP 27
1043: PUSH
1044: LD_EXP 27
1048: PUSH
1049: CALL_OW 44
1053: ADD
1054: ST_TO_ADDR
// end ;
1055: GO 1023
1057: POP
1058: POP
// factory_list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
1059: LD_ADDR_VAR 0 11
1063: PUSH
1064: LD_INT 22
1066: PUSH
1067: LD_EXP 1
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: PUSH
1076: LD_INT 2
1078: PUSH
1079: LD_INT 30
1081: PUSH
1082: LD_INT 2
1084: PUSH
1085: EMPTY
1086: LIST
1087: LIST
1088: PUSH
1089: LD_INT 30
1091: PUSH
1092: LD_INT 3
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: PPUSH
1108: CALL_OW 69
1112: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ) ;
1113: LD_ADDR_VAR 0 13
1117: PUSH
1118: LD_INT 22
1120: PUSH
1121: LD_EXP 1
1125: PUSH
1126: EMPTY
1127: LIST
1128: LIST
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 30
1135: PUSH
1136: LD_INT 6
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: PUSH
1143: LD_INT 30
1145: PUSH
1146: LD_INT 8
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: PUSH
1153: LD_INT 30
1155: PUSH
1156: LD_INT 7
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: PPUSH
1173: CALL_OW 69
1177: ST_TO_ADDR
// if people > 12 then
1178: LD_EXP 27
1182: PUSH
1183: LD_INT 12
1185: GREATER
1186: IFFALSE 1198
// num := 6 else
1188: LD_ADDR_VAR 0 6
1192: PUSH
1193: LD_INT 6
1195: ST_TO_ADDR
1196: GO 1206
// num := 4 ;
1198: LD_ADDR_VAR 0 6
1202: PUSH
1203: LD_INT 4
1205: ST_TO_ADDR
// for un = 1 to num do
1206: LD_ADDR_VAR 0 2
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 6
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1256
// mechanics := mechanics ^ FindMaxSkill2 ( people diff mechanics , skill_mechanical ) ;
1224: LD_ADDR_VAR 0 12
1228: PUSH
1229: LD_VAR 0 12
1233: PUSH
1234: LD_EXP 27
1238: PUSH
1239: LD_VAR 0 12
1243: DIFF
1244: PPUSH
1245: LD_INT 3
1247: PPUSH
1248: CALL_OW 434
1252: ADD
1253: ST_TO_ADDR
1254: GO 1221
1256: POP
1257: POP
// for un = 1 to num do
1258: LD_ADDR_VAR 0 2
1262: PUSH
1263: DOUBLE
1264: LD_INT 1
1266: DEC
1267: ST_TO_ADDR
1268: LD_VAR 0 6
1272: PUSH
1273: FOR_TO
1274: IFFALSE 1314
// scientists := scientists ^ FindMaxSkill2 ( people diff ( mechanics ^ scientists ) , skill_scientistic ) ;
1276: LD_ADDR_VAR 0 14
1280: PUSH
1281: LD_VAR 0 14
1285: PUSH
1286: LD_EXP 27
1290: PUSH
1291: LD_VAR 0 12
1295: PUSH
1296: LD_VAR 0 14
1300: ADD
1301: DIFF
1302: PPUSH
1303: LD_INT 4
1305: PPUSH
1306: CALL_OW 434
1310: ADD
1311: ST_TO_ADDR
1312: GO 1273
1314: POP
1315: POP
// depot_list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
1316: LD_ADDR_VAR 0 9
1320: PUSH
1321: LD_INT 22
1323: PUSH
1324: LD_EXP 1
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: PUSH
1333: LD_INT 2
1335: PUSH
1336: LD_INT 30
1338: PUSH
1339: LD_INT 0
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 30
1348: PUSH
1349: LD_INT 1
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: PUSH
1356: EMPTY
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: PPUSH
1365: CALL_OW 69
1369: ST_TO_ADDR
// for un in depot_list do
1370: LD_ADDR_VAR 0 2
1374: PUSH
1375: LD_VAR 0 9
1379: PUSH
1380: FOR_IN
1381: IFFALSE 1427
// begin depot := un ;
1383: LD_ADDR_VAR 0 10
1387: PUSH
1388: LD_VAR 0 2
1392: ST_TO_ADDR
// x := GetX ( un ) ;
1393: LD_ADDR_VAR 0 3
1397: PUSH
1398: LD_VAR 0 2
1402: PPUSH
1403: CALL_OW 250
1407: ST_TO_ADDR
// y := GetY ( un ) ;
1408: LD_ADDR_VAR 0 4
1412: PUSH
1413: LD_VAR 0 2
1417: PPUSH
1418: CALL_OW 251
1422: ST_TO_ADDR
// break ;
1423: GO 1427
// end ;
1425: GO 1380
1427: POP
1428: POP
// PlaceUnitXYR ( Burlak , x , y , 10 , false ) ;
1429: LD_EXP 2
1433: PPUSH
1434: LD_VAR 0 3
1438: PPUSH
1439: LD_VAR 0 4
1443: PPUSH
1444: LD_INT 10
1446: PPUSH
1447: LD_INT 0
1449: PPUSH
1450: CALL_OW 50
// PlaceUnitXYR ( Yashin , x , y , 10 , false ) ;
1454: LD_EXP 19
1458: PPUSH
1459: LD_VAR 0 3
1463: PPUSH
1464: LD_VAR 0 4
1468: PPUSH
1469: LD_INT 10
1471: PPUSH
1472: LD_INT 0
1474: PPUSH
1475: CALL_OW 50
// PlaceUnitArea ( veh , survivor_place , false ) ;
1479: LD_VAR 0 7
1483: PPUSH
1484: LD_INT 3
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// PlaceHumanInUnit ( survivor , veh ) ;
1494: LD_EXP 29
1498: PPUSH
1499: LD_VAR 0 7
1503: PPUSH
1504: CALL_OW 52
// wait ( 10 ) ;
1508: LD_INT 10
1510: PPUSH
1511: CALL_OW 67
// if not IsOK ( survivor ) then
1515: LD_EXP 29
1519: PPUSH
1520: CALL_OW 302
1524: NOT
1525: IFFALSE 1542
// PlaceUnitArea ( survivor , survivor_place , false ) ;
1527: LD_EXP 29
1531: PPUSH
1532: LD_INT 3
1534: PPUSH
1535: LD_INT 0
1537: PPUSH
1538: CALL_OW 49
// wait ( 10 ) ;
1542: LD_INT 10
1544: PPUSH
1545: CALL_OW 67
// if not IsOK ( survivor ) then
1549: LD_EXP 29
1553: PPUSH
1554: CALL_OW 302
1558: NOT
1559: IFFALSE 1575
// PlaceHumanInUnit ( survivor , depot ) ;
1561: LD_EXP 29
1565: PPUSH
1566: LD_VAR 0 10
1570: PPUSH
1571: CALL_OW 52
// for un in people do
1575: LD_ADDR_VAR 0 2
1579: PUSH
1580: LD_EXP 27
1584: PUSH
1585: FOR_IN
1586: IFFALSE 1846
// begin placed := false ;
1588: LD_ADDR_VAR 0 5
1592: PUSH
1593: LD_INT 0
1595: ST_TO_ADDR
// if ( un in mechanics ) and factory_list then
1596: LD_VAR 0 2
1600: PUSH
1601: LD_VAR 0 12
1605: IN
1606: PUSH
1607: LD_VAR 0 11
1611: AND
1612: IFFALSE 1652
// begin SetClass ( un , class_mechanic ) ;
1614: LD_VAR 0 2
1618: PPUSH
1619: LD_INT 3
1621: PPUSH
1622: CALL_OW 336
// PlaceHumanInUnit ( un , factory_list [ 1 ] ) ;
1626: LD_VAR 0 2
1630: PPUSH
1631: LD_VAR 0 11
1635: PUSH
1636: LD_INT 1
1638: ARRAY
1639: PPUSH
1640: CALL_OW 52
// placed := true ;
1644: LD_ADDR_VAR 0 5
1648: PUSH
1649: LD_INT 1
1651: ST_TO_ADDR
// end ; if ( un in scientists ) and lab_list then
1652: LD_VAR 0 2
1656: PUSH
1657: LD_VAR 0 14
1661: IN
1662: PUSH
1663: LD_VAR 0 13
1667: AND
1668: IFFALSE 1708
// begin SetClass ( un , class_scientistic ) ;
1670: LD_VAR 0 2
1674: PPUSH
1675: LD_INT 4
1677: PPUSH
1678: CALL_OW 336
// PlaceHumanInUnit ( un , lab_list [ 1 ] ) ;
1682: LD_VAR 0 2
1686: PPUSH
1687: LD_VAR 0 13
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PPUSH
1696: CALL_OW 52
// placed := true ;
1700: LD_ADDR_VAR 0 5
1704: PUSH
1705: LD_INT 1
1707: ST_TO_ADDR
// end ; if not placed then
1708: LD_VAR 0 5
1712: NOT
1713: IFFALSE 1844
// begin case Rand ( 0 , 1 ) of 0 :
1715: LD_INT 0
1717: PPUSH
1718: LD_INT 1
1720: PPUSH
1721: CALL_OW 12
1725: PUSH
1726: LD_INT 0
1728: DOUBLE
1729: EQUAL
1730: IFTRUE 1734
1732: GO 1749
1734: POP
// SetClass ( un , class_soldier ) ; 1 :
1735: LD_VAR 0 2
1739: PPUSH
1740: LD_INT 1
1742: PPUSH
1743: CALL_OW 336
1747: GO 1773
1749: LD_INT 1
1751: DOUBLE
1752: EQUAL
1753: IFTRUE 1757
1755: GO 1772
1757: POP
// SetClass ( un , class_engineer ) ; end ;
1758: LD_VAR 0 2
1762: PPUSH
1763: LD_INT 2
1765: PPUSH
1766: CALL_OW 336
1770: GO 1773
1772: POP
// if ( GetClass ( un ) = class_engineer ) and ( UnitsInside ( depot ) < 6 ) then
1773: LD_VAR 0 2
1777: PPUSH
1778: CALL_OW 257
1782: PUSH
1783: LD_INT 2
1785: EQUAL
1786: PUSH
1787: LD_VAR 0 10
1791: PPUSH
1792: CALL_OW 313
1796: PUSH
1797: LD_INT 6
1799: LESS
1800: AND
1801: IFFALSE 1819
// PlaceHumanInUnit ( un , depot ) else
1803: LD_VAR 0 2
1807: PPUSH
1808: LD_VAR 0 10
1812: PPUSH
1813: CALL_OW 52
1817: GO 1844
// PlaceUnitXYR ( un , x , y , 10 , false ) ;
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_VAR 0 3
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_INT 10
1836: PPUSH
1837: LD_INT 0
1839: PPUSH
1840: CALL_OW 50
// end ; end ;
1844: GO 1585
1846: POP
1847: POP
// end ;
1848: LD_VAR 0 1
1852: RET
// function prepare_sides ; begin
1853: LD_INT 0
1855: PPUSH
// you := 3 ;
1856: LD_ADDR_EXP 1
1860: PUSH
1861: LD_INT 3
1863: ST_TO_ADDR
// end ;
1864: LD_VAR 0 1
1868: RET
// starting begin RandomizeAll ;
1869: CALL_OW 11
// prepare_sides ;
1873: CALL 1853 0 0
// RemoveAnimals ;
1877: CALL 0 0 0
// prepare_map ;
1881: CALL 142 0 0
// prepare_base ;
1885: CALL 175 0 0
// prepare_units ;
1889: CALL 755 0 0
// RestoreAnimals ;
1893: CALL 79 0 0
// starting_scene ;
1897: CALL 1902 0 0
// end ; end_of_file
1901: END
// export function starting_scene ; var selected , old_pos ; begin
1902: LD_INT 0
1904: PPUSH
1905: PPUSH
1906: PPUSH
// interface_hidden := true ;
1907: LD_ADDR_OWVAR 54
1911: PUSH
1912: LD_INT 1
1914: ST_TO_ADDR
// RevealFogArea ( you , all_map ) ;
1915: LD_EXP 1
1919: PPUSH
1920: LD_INT 2
1922: PPUSH
1923: CALL_OW 332
// CenterNowOnUnits ( Burlak ) ;
1927: LD_EXP 2
1931: PPUSH
1932: CALL_OW 87
// ComMoveUnit ( Burlak , Yashin ) ;
1936: LD_EXP 2
1940: PPUSH
1941: LD_EXP 19
1945: PPUSH
1946: CALL_OW 112
// ComMoveUnit ( Yashin , Burlak ) ;
1950: LD_EXP 19
1954: PPUSH
1955: LD_EXP 2
1959: PPUSH
1960: CALL_OW 112
// while ( GetDistUnits ( Burlak , Yashin ) > 4 ) do
1964: LD_EXP 2
1968: PPUSH
1969: LD_EXP 19
1973: PPUSH
1974: CALL_OW 296
1978: PUSH
1979: LD_INT 4
1981: GREATER
1982: IFFALSE 1993
// wait ( 0 0$1 ) ;
1984: LD_INT 35
1986: PPUSH
1987: CALL_OW 67
1991: GO 1964
// CenterOnUnits ( [ Burlak , Yashin ] ) ;
1993: LD_EXP 2
1997: PUSH
1998: LD_EXP 19
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: PPUSH
2007: CALL_OW 85
// ComTurnUnit ( Burlak , Yashin ) ;
2011: LD_EXP 2
2015: PPUSH
2016: LD_EXP 19
2020: PPUSH
2021: CALL_OW 119
// ComTurnUnit ( Yashin , Burlak ) ;
2025: LD_EXP 19
2029: PPUSH
2030: LD_EXP 2
2034: PPUSH
2035: CALL_OW 119
// wait ( 5 ) ;
2039: LD_INT 5
2041: PPUSH
2042: CALL_OW 67
// ComHold ( [ Yashin , Burlak ] ) ;
2046: LD_EXP 19
2050: PUSH
2051: LD_EXP 2
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: PPUSH
2060: CALL_OW 140
// InGameOn ;
2064: CALL_OW 8
// if LabCaptured then
2068: LD_EXP 24
2072: IFFALSE 2088
// Say ( Yashin , DStart1-Yas-1 ) else
2074: LD_EXP 19
2078: PPUSH
2079: LD_STRING DStart1-Yas-1
2081: PPUSH
2082: CALL_OW 88
2086: GO 2124
// begin Say ( Yashin , DStart2-Yas-1 ) ;
2088: LD_EXP 19
2092: PPUSH
2093: LD_STRING DStart2-Yas-1
2095: PPUSH
2096: CALL_OW 88
// Say ( Burlak , DStart2-Bur-1 ) ;
2100: LD_EXP 2
2104: PPUSH
2105: LD_STRING DStart2-Bur-1
2107: PPUSH
2108: CALL_OW 88
// Say ( Yashin , DStart2-Yas-2 ) ;
2112: LD_EXP 19
2116: PPUSH
2117: LD_STRING DStart2-Yas-2
2119: PPUSH
2120: CALL_OW 88
// end ; ComMoveUnit ( survivor , Yashin ) ;
2124: LD_EXP 29
2128: PPUSH
2129: LD_EXP 19
2133: PPUSH
2134: CALL_OW 112
// repeat old_pos := [ GetX ( survivor ) , GetY ( survivor ) ] ;
2138: LD_ADDR_VAR 0 3
2142: PUSH
2143: LD_EXP 29
2147: PPUSH
2148: CALL_OW 250
2152: PUSH
2153: LD_EXP 29
2157: PPUSH
2158: CALL_OW 251
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: ST_TO_ADDR
// wait ( 0 0$2 ) ;
2167: LD_INT 70
2169: PPUSH
2170: CALL_OW 67
// CenterOnUnits ( IsInUnit ( survivor ) ) ;
2174: LD_EXP 29
2178: PPUSH
2179: CALL_OW 310
2183: PPUSH
2184: CALL_OW 85
// if ( old_pos [ 1 ] = GetX ( survivor ) ) and ( old_pos [ 2 ] = GetY ( survivor ) ) then
2188: LD_VAR 0 3
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PUSH
2197: LD_EXP 29
2201: PPUSH
2202: CALL_OW 250
2206: EQUAL
2207: PUSH
2208: LD_VAR 0 3
2212: PUSH
2213: LD_INT 2
2215: ARRAY
2216: PUSH
2217: LD_EXP 29
2221: PPUSH
2222: CALL_OW 251
2226: EQUAL
2227: AND
2228: IFFALSE 2232
// break ;
2230: GO 2257
// until GetDistUnits ( IsInUnit ( survivor ) , Yashin ) < 7 ;
2232: LD_EXP 29
2236: PPUSH
2237: CALL_OW 310
2241: PPUSH
2242: LD_EXP 19
2246: PPUSH
2247: CALL_OW 296
2251: PUSH
2252: LD_INT 7
2254: LESS
2255: IFFALSE 2138
// ComExitVehicle ( survivor ) ;
2257: LD_EXP 29
2261: PPUSH
2262: CALL_OW 121
// while IsInUnit ( survivor ) do
2266: LD_EXP 29
2270: PPUSH
2271: CALL_OW 310
2275: IFFALSE 2286
// wait ( 5 ) ;
2277: LD_INT 5
2279: PPUSH
2280: CALL_OW 67
2284: GO 2266
// AddComMoveUnit ( survivor , Yashin ) ;
2286: LD_EXP 29
2290: PPUSH
2291: LD_EXP 19
2295: PPUSH
2296: CALL_OW 172
// repeat old_pos := [ GetX ( survivor ) , GetY ( survivor ) ] ;
2300: LD_ADDR_VAR 0 3
2304: PUSH
2305: LD_EXP 29
2309: PPUSH
2310: CALL_OW 250
2314: PUSH
2315: LD_EXP 29
2319: PPUSH
2320: CALL_OW 251
2324: PUSH
2325: EMPTY
2326: LIST
2327: LIST
2328: ST_TO_ADDR
// wait ( 0 0$2 ) ;
2329: LD_INT 70
2331: PPUSH
2332: CALL_OW 67
// CenterOnUnits ( IsInUnit ( survivor ) ) ;
2336: LD_EXP 29
2340: PPUSH
2341: CALL_OW 310
2345: PPUSH
2346: CALL_OW 85
// if ( old_pos [ 1 ] = GetX ( survivor ) ) and ( old_pos [ 2 ] = GetY ( survivor ) ) then
2350: LD_VAR 0 3
2354: PUSH
2355: LD_INT 1
2357: ARRAY
2358: PUSH
2359: LD_EXP 29
2363: PPUSH
2364: CALL_OW 250
2368: EQUAL
2369: PUSH
2370: LD_VAR 0 3
2374: PUSH
2375: LD_INT 2
2377: ARRAY
2378: PUSH
2379: LD_EXP 29
2383: PPUSH
2384: CALL_OW 251
2388: EQUAL
2389: AND
2390: IFFALSE 2394
// break ;
2392: GO 2414
// until GetDistUnits ( survivor , Yashin ) < 4 ;
2394: LD_EXP 29
2398: PPUSH
2399: LD_EXP 19
2403: PPUSH
2404: CALL_OW 296
2408: PUSH
2409: LD_INT 4
2411: LESS
2412: IFFALSE 2300
// CenterOnUnits ( [ Burlak , Yashin , survivor ] ) ;
2414: LD_EXP 2
2418: PUSH
2419: LD_EXP 19
2423: PUSH
2424: LD_EXP 29
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL_OW 85
// ComTurnUnit ( survivor , Yashin ) ;
2438: LD_EXP 29
2442: PPUSH
2443: LD_EXP 19
2447: PPUSH
2448: CALL_OW 119
// ComTurnUnit ( [ Yashin , Burlak ] , survivor ) ;
2452: LD_EXP 19
2456: PUSH
2457: LD_EXP 2
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: PPUSH
2466: LD_EXP 29
2470: PPUSH
2471: CALL_OW 119
// AddComHold ( [ Yashin , Burlak , survivor ] ) ;
2475: LD_EXP 19
2479: PUSH
2480: LD_EXP 2
2484: PUSH
2485: LD_EXP 29
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL_OW 200
// Say ( survivor , DStartCont-Vse-1 ) ;
2499: LD_EXP 29
2503: PPUSH
2504: LD_STRING DStartCont-Vse-1
2506: PPUSH
2507: CALL_OW 88
// Say ( Yashin , DStartCont-Yas-1 ) ;
2511: LD_EXP 19
2515: PPUSH
2516: LD_STRING DStartCont-Yas-1
2518: PPUSH
2519: CALL_OW 88
// SayRadio ( Popov , DStartCont-Pop-1 ) ;
2523: LD_EXP 7
2527: PPUSH
2528: LD_STRING DStartCont-Pop-1
2530: PPUSH
2531: CALL_OW 94
// Say ( Yashin , DStartCont-Yas-2 ) ;
2535: LD_EXP 19
2539: PPUSH
2540: LD_STRING DStartCont-Yas-2
2542: PPUSH
2543: CALL_OW 88
// SayRadio ( Popov , DStartCont-Pop-2 ) ;
2547: LD_EXP 7
2551: PPUSH
2552: LD_STRING DStartCont-Pop-2
2554: PPUSH
2555: CALL_OW 94
// Say ( Yashin , DStartCont-Yas-3 ) ;
2559: LD_EXP 19
2563: PPUSH
2564: LD_STRING DStartCont-Yas-3
2566: PPUSH
2567: CALL_OW 88
// Say ( Yashin , DStartCont-Yas-3a ) ;
2571: LD_EXP 19
2575: PPUSH
2576: LD_STRING DStartCont-Yas-3a
2578: PPUSH
2579: CALL_OW 88
// Say ( Burlak , DStartCont-Bur-3 ) ;
2583: LD_EXP 2
2587: PPUSH
2588: LD_STRING DStartCont-Bur-3
2590: PPUSH
2591: CALL_OW 88
// Say ( Yashin , DStartCont-Yas-4 ) ;
2595: LD_EXP 19
2599: PPUSH
2600: LD_STRING DStartCont-Yas-4
2602: PPUSH
2603: CALL_OW 88
// Say ( Burlak , DStartCont-Bur-4 ) ;
2607: LD_EXP 2
2611: PPUSH
2612: LD_STRING DStartCont-Bur-4
2614: PPUSH
2615: CALL_OW 88
// Say ( survivor , DStartCont-Vse-4 ) ;
2619: LD_EXP 29
2623: PPUSH
2624: LD_STRING DStartCont-Vse-4
2626: PPUSH
2627: CALL_OW 88
// wait ( 5 ) ;
2631: LD_INT 5
2633: PPUSH
2634: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
2638: LD_STRING MStart
2640: PPUSH
2641: CALL_OW 337
// Query ( QInfo ) ;
2645: LD_STRING QInfo
2647: PPUSH
2648: CALL_OW 97
// selected := CharacterSelection (  , 6 , 6 , [ Burlak , sel_not_hired , Yashin , survivor , sel_changeable , sel_change_class ] ^ people , [ class_soldier , class_bazooker , class_scientistic , class_mechanic ] ) ;
2652: LD_ADDR_VAR 0 2
2656: PUSH
2657: LD_STRING 
2659: PPUSH
2660: LD_INT 6
2662: PPUSH
2663: LD_INT 6
2665: PPUSH
2666: LD_EXP 2
2670: PUSH
2671: LD_INT -2
2673: PUSH
2674: LD_EXP 19
2678: PUSH
2679: LD_EXP 29
2683: PUSH
2684: LD_INT -3
2686: PUSH
2687: LD_INT -5
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: LIST
2696: LIST
2697: PUSH
2698: LD_EXP 27
2702: ADD
2703: PPUSH
2704: LD_INT 1
2706: PUSH
2707: LD_INT 9
2709: PUSH
2710: LD_INT 4
2712: PUSH
2713: LD_INT 3
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: LIST
2720: LIST
2721: PPUSH
2722: CALL_OW 42
2726: ST_TO_ADDR
// save_for_mission ( selected ) ;
2727: LD_VAR 0 2
2731: PPUSH
2732: CALL 3644 0 1
// InGameOff ;
2736: CALL_OW 9
// end ; end_of_file
2740: LD_VAR 0 1
2744: RET
// export survivors3 , old_chars ; export function LoadAllMen ; var list ; begin
2745: LD_INT 0
2747: PPUSH
2748: PPUSH
// uc_side = 3 ;
2749: LD_ADDR_OWVAR 20
2753: PUSH
2754: LD_INT 3
2756: ST_TO_ADDR
// uc_nation = nation_russian ;
2757: LD_ADDR_OWVAR 21
2761: PUSH
2762: LD_INT 3
2764: ST_TO_ADDR
// list := [ ] ;
2765: LD_ADDR_VAR 0 2
2769: PUSH
2770: EMPTY
2771: ST_TO_ADDR
// old_chars := [ ] ;
2772: LD_ADDR_EXP 31
2776: PUSH
2777: EMPTY
2778: ST_TO_ADDR
// survivors3 := [ ] ;
2779: LD_ADDR_EXP 30
2783: PUSH
2784: EMPTY
2785: ST_TO_ADDR
// if TestCharacters ( survivors3 ) then
2786: LD_STRING survivors3
2788: PPUSH
2789: CALL_OW 28
2793: IFFALSE 2808
// survivors3 := CreateCharacterSet ( survivors3 ) ;
2795: LD_ADDR_EXP 30
2799: PUSH
2800: LD_STRING survivors3
2802: PPUSH
2803: CALL_OW 31
2807: ST_TO_ADDR
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) then
2808: LD_STRING Belkov
2810: PPUSH
2811: CALL_OW 28
2815: PUSH
2816: LD_STRING Belkov
2818: PPUSH
2819: CALL_OW 29
2823: AND
2824: IFFALSE 2855
// begin Belkov := CreateCharacter ( Belkov ) ;
2826: LD_ADDR_EXP 4
2830: PUSH
2831: LD_STRING Belkov
2833: PPUSH
2834: CALL_OW 34
2838: ST_TO_ADDR
// list := list ^ Belkov ;
2839: LD_ADDR_VAR 0 2
2843: PUSH
2844: LD_VAR 0 2
2848: PUSH
2849: LD_EXP 4
2853: ADD
2854: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) then
2855: LD_STRING Gnyevko
2857: PPUSH
2858: CALL_OW 28
2862: PUSH
2863: LD_STRING Gnyevko
2865: PPUSH
2866: CALL_OW 29
2870: AND
2871: IFFALSE 2902
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
2873: LD_ADDR_EXP 3
2877: PUSH
2878: LD_STRING Gnyevko
2880: PPUSH
2881: CALL_OW 34
2885: ST_TO_ADDR
// list := list ^ Gnyevko ;
2886: LD_ADDR_VAR 0 2
2890: PUSH
2891: LD_VAR 0 2
2895: PUSH
2896: LD_EXP 3
2900: ADD
2901: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) then
2902: LD_STRING Kirilenkova
2904: PPUSH
2905: CALL_OW 28
2909: PUSH
2910: LD_STRING Kirilenkova
2912: PPUSH
2913: CALL_OW 29
2917: AND
2918: IFFALSE 2949
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
2920: LD_ADDR_EXP 5
2924: PUSH
2925: LD_STRING Kirilenkova
2927: PPUSH
2928: CALL_OW 34
2932: ST_TO_ADDR
// list := list ^ Kirilenkova ;
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: LD_VAR 0 2
2942: PUSH
2943: LD_EXP 5
2947: ADD
2948: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) then
2949: LD_STRING Kovalyuk
2951: PPUSH
2952: CALL_OW 28
2956: PUSH
2957: LD_STRING Kovalyuk
2959: PPUSH
2960: CALL_OW 29
2964: AND
2965: IFFALSE 2996
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
2967: LD_ADDR_EXP 6
2971: PUSH
2972: LD_STRING Kovalyuk
2974: PPUSH
2975: CALL_OW 34
2979: ST_TO_ADDR
// list := list ^ Kovalyuk ;
2980: LD_ADDR_VAR 0 2
2984: PUSH
2985: LD_VAR 0 2
2989: PUSH
2990: LD_EXP 6
2994: ADD
2995: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) then
2996: LD_STRING Scholtze
2998: PPUSH
2999: CALL_OW 28
3003: PUSH
3004: LD_STRING Scholtze
3006: PPUSH
3007: CALL_OW 29
3011: AND
3012: IFFALSE 3043
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3014: LD_ADDR_EXP 8
3018: PUSH
3019: LD_STRING Scholtze
3021: PPUSH
3022: CALL_OW 34
3026: ST_TO_ADDR
// list := list ^ Scholtze ;
3027: LD_ADDR_VAR 0 2
3031: PUSH
3032: LD_VAR 0 2
3036: PUSH
3037: LD_EXP 8
3041: ADD
3042: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) then
3043: LD_STRING Kuzmov
3045: PPUSH
3046: CALL_OW 28
3050: PUSH
3051: LD_STRING Kuzmov
3053: PPUSH
3054: CALL_OW 29
3058: AND
3059: IFFALSE 3090
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3061: LD_ADDR_EXP 9
3065: PUSH
3066: LD_STRING Kuzmov
3068: PPUSH
3069: CALL_OW 34
3073: ST_TO_ADDR
// list := list ^ Kuzmov ;
3074: LD_ADDR_VAR 0 2
3078: PUSH
3079: LD_VAR 0 2
3083: PUSH
3084: LD_EXP 9
3088: ADD
3089: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) then
3090: LD_STRING Karamazov
3092: PPUSH
3093: CALL_OW 28
3097: PUSH
3098: LD_STRING Karamazov
3100: PPUSH
3101: CALL_OW 29
3105: AND
3106: IFFALSE 3137
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3108: LD_ADDR_EXP 10
3112: PUSH
3113: LD_STRING Karamazov
3115: PPUSH
3116: CALL_OW 34
3120: ST_TO_ADDR
// list := list ^ Karamazov ;
3121: LD_ADDR_VAR 0 2
3125: PUSH
3126: LD_VAR 0 2
3130: PUSH
3131: LD_EXP 10
3135: ADD
3136: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) then
3137: LD_STRING Petrovova
3139: PPUSH
3140: CALL_OW 28
3144: PUSH
3145: LD_STRING Petrovova
3147: PPUSH
3148: CALL_OW 29
3152: AND
3153: IFFALSE 3184
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3155: LD_ADDR_EXP 11
3159: PUSH
3160: LD_STRING Petrovova
3162: PPUSH
3163: CALL_OW 34
3167: ST_TO_ADDR
// list := list ^ Petrovova ;
3168: LD_ADDR_VAR 0 2
3172: PUSH
3173: LD_VAR 0 2
3177: PUSH
3178: LD_EXP 11
3182: ADD
3183: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) then
3184: LD_STRING Gleb
3186: PPUSH
3187: CALL_OW 28
3191: PUSH
3192: LD_STRING Gleb
3194: PPUSH
3195: CALL_OW 29
3199: AND
3200: IFFALSE 3231
// begin Gleb := CreateCharacter ( Gleb ) ;
3202: LD_ADDR_EXP 12
3206: PUSH
3207: LD_STRING Gleb
3209: PPUSH
3210: CALL_OW 34
3214: ST_TO_ADDR
// list := list ^ Gleb ;
3215: LD_ADDR_VAR 0 2
3219: PUSH
3220: LD_VAR 0 2
3224: PUSH
3225: LD_EXP 12
3229: ADD
3230: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) then
3231: LD_STRING Petrosyan
3233: PPUSH
3234: CALL_OW 28
3238: PUSH
3239: LD_STRING Petrosyan
3241: PPUSH
3242: CALL_OW 29
3246: AND
3247: IFFALSE 3278
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
3249: LD_ADDR_EXP 13
3253: PUSH
3254: LD_STRING Petrosyan
3256: PPUSH
3257: CALL_OW 34
3261: ST_TO_ADDR
// list := list ^ Petrosyan ;
3262: LD_ADDR_VAR 0 2
3266: PUSH
3267: LD_VAR 0 2
3271: PUSH
3272: LD_EXP 13
3276: ADD
3277: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) then
3278: LD_STRING Lipshchin
3280: PPUSH
3281: CALL_OW 28
3285: PUSH
3286: LD_STRING Lipshchin
3288: PPUSH
3289: CALL_OW 29
3293: AND
3294: IFFALSE 3325
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3296: LD_ADDR_EXP 14
3300: PUSH
3301: LD_STRING Lipshchin
3303: PPUSH
3304: CALL_OW 34
3308: ST_TO_ADDR
// list := list ^ Lipshchin ;
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_VAR 0 2
3318: PUSH
3319: LD_EXP 14
3323: ADD
3324: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) then
3325: LD_STRING Titov
3327: PPUSH
3328: CALL_OW 28
3332: PUSH
3333: LD_STRING Titov
3335: PPUSH
3336: CALL_OW 29
3340: AND
3341: IFFALSE 3372
// begin Titov := CreateCharacter ( Titov ) ;
3343: LD_ADDR_EXP 15
3347: PUSH
3348: LD_STRING Titov
3350: PPUSH
3351: CALL_OW 34
3355: ST_TO_ADDR
// list := list ^ Titov ;
3356: LD_ADDR_VAR 0 2
3360: PUSH
3361: LD_VAR 0 2
3365: PUSH
3366: LD_EXP 15
3370: ADD
3371: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) then
3372: LD_STRING Dolgov
3374: PPUSH
3375: CALL_OW 28
3379: PUSH
3380: LD_STRING Dolgov
3382: PPUSH
3383: CALL_OW 29
3387: AND
3388: IFFALSE 3419
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3390: LD_ADDR_EXP 16
3394: PUSH
3395: LD_STRING Dolgov
3397: PPUSH
3398: CALL_OW 34
3402: ST_TO_ADDR
// list := list ^ Dolgov ;
3403: LD_ADDR_VAR 0 2
3407: PUSH
3408: LD_VAR 0 2
3412: PUSH
3413: LD_EXP 16
3417: ADD
3418: ST_TO_ADDR
// end ; if TestCharacters ( Xavier ) and CheckCharacterSet ( Xavier ) then
3419: LD_STRING Xavier
3421: PPUSH
3422: CALL_OW 28
3426: PUSH
3427: LD_STRING Xavier
3429: PPUSH
3430: CALL_OW 29
3434: AND
3435: IFFALSE 3466
// begin Xavier := CreateCharacter ( Xavier ) ;
3437: LD_ADDR_EXP 18
3441: PUSH
3442: LD_STRING Xavier
3444: PPUSH
3445: CALL_OW 34
3449: ST_TO_ADDR
// list := list ^ Xavier ;
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: LD_VAR 0 2
3459: PUSH
3460: LD_EXP 18
3464: ADD
3465: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) then
3466: LD_STRING Oblukov
3468: PPUSH
3469: CALL_OW 28
3473: PUSH
3474: LD_STRING Oblukov
3476: PPUSH
3477: CALL_OW 29
3481: AND
3482: IFFALSE 3513
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3484: LD_ADDR_EXP 20
3488: PUSH
3489: LD_STRING Oblukov
3491: PPUSH
3492: CALL_OW 34
3496: ST_TO_ADDR
// list := list ^ Oblukov ;
3497: LD_ADDR_VAR 0 2
3501: PUSH
3502: LD_VAR 0 2
3506: PUSH
3507: LD_EXP 20
3511: ADD
3512: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) then
3513: LD_STRING Kozlov
3515: PPUSH
3516: CALL_OW 28
3520: PUSH
3521: LD_STRING Kozlov
3523: PPUSH
3524: CALL_OW 29
3528: AND
3529: IFFALSE 3560
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3531: LD_ADDR_EXP 21
3535: PUSH
3536: LD_STRING Kozlov
3538: PPUSH
3539: CALL_OW 34
3543: ST_TO_ADDR
// list := list ^ Kozlov ;
3544: LD_ADDR_VAR 0 2
3548: PUSH
3549: LD_VAR 0 2
3553: PUSH
3554: LD_EXP 21
3558: ADD
3559: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) then
3560: LD_STRING Kapitsova
3562: PPUSH
3563: CALL_OW 28
3567: PUSH
3568: LD_STRING Kapitsova
3570: PPUSH
3571: CALL_OW 29
3575: AND
3576: IFFALSE 3607
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3578: LD_ADDR_EXP 22
3582: PUSH
3583: LD_STRING Kapitsova
3585: PPUSH
3586: CALL_OW 34
3590: ST_TO_ADDR
// list := list ^ Kapitsova ;
3591: LD_ADDR_VAR 0 2
3595: PUSH
3596: LD_VAR 0 2
3600: PUSH
3601: LD_EXP 22
3605: ADD
3606: ST_TO_ADDR
// end ; old_chars := list ;
3607: LD_ADDR_EXP 31
3611: PUSH
3612: LD_VAR 0 2
3616: ST_TO_ADDR
// result := old_chars ^ ( survivors3 diff list ) ;
3617: LD_ADDR_VAR 0 1
3621: PUSH
3622: LD_EXP 31
3626: PUSH
3627: LD_EXP 30
3631: PUSH
3632: LD_VAR 0 2
3636: DIFF
3637: ADD
3638: ST_TO_ADDR
// end ; end_of_file
3639: LD_VAR 0 1
3643: RET
// export function save_for_mission ( list ) ; begin
3644: LD_INT 0
3646: PPUSH
// if Belkov in list then
3647: LD_EXP 4
3651: PUSH
3652: LD_VAR 0 1
3656: IN
3657: IFFALSE 3681
// begin SaveCharacters ( Belkov , Belkov ) ;
3659: LD_EXP 4
3663: PPUSH
3664: LD_STRING Belkov
3666: PPUSH
3667: CALL_OW 38
// SaveVariable ( 1 , BelkovRu10 ) ;
3671: LD_INT 1
3673: PPUSH
3674: LD_STRING BelkovRu10
3676: PPUSH
3677: CALL_OW 39
// end ; if Gnyevko in list then
3681: LD_EXP 3
3685: PUSH
3686: LD_VAR 0 1
3690: IN
3691: IFFALSE 3715
// begin SaveCharacters ( Gnyevko , Gnyevko ) ;
3693: LD_EXP 3
3697: PPUSH
3698: LD_STRING Gnyevko
3700: PPUSH
3701: CALL_OW 38
// SaveVariable ( 1 , GnyevkoRu10 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_STRING GnyevkoRu10
3710: PPUSH
3711: CALL_OW 39
// end ; if Kirilenkova in list then
3715: LD_EXP 5
3719: PUSH
3720: LD_VAR 0 1
3724: IN
3725: IFFALSE 3749
// begin SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3727: LD_EXP 5
3731: PPUSH
3732: LD_STRING Kirilenkova
3734: PPUSH
3735: CALL_OW 38
// SaveVariable ( 1 , KirilenkovaRu10 ) ;
3739: LD_INT 1
3741: PPUSH
3742: LD_STRING KirilenkovaRu10
3744: PPUSH
3745: CALL_OW 39
// end ; if Kovalyuk in list then
3749: LD_EXP 6
3753: PUSH
3754: LD_VAR 0 1
3758: IN
3759: IFFALSE 3783
// begin SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3761: LD_EXP 6
3765: PPUSH
3766: LD_STRING Kovalyuk
3768: PPUSH
3769: CALL_OW 38
// SaveVariable ( 1 , KovalyukRu10 ) ;
3773: LD_INT 1
3775: PPUSH
3776: LD_STRING KovalyukRu10
3778: PPUSH
3779: CALL_OW 39
// end ; if Scholtze in list then
3783: LD_EXP 8
3787: PUSH
3788: LD_VAR 0 1
3792: IN
3793: IFFALSE 3817
// begin SaveCharacters ( Scholtze , Scholtze ) ;
3795: LD_EXP 8
3799: PPUSH
3800: LD_STRING Scholtze
3802: PPUSH
3803: CALL_OW 38
// SaveVariable ( 1 , ScholtzeRu10 ) ;
3807: LD_INT 1
3809: PPUSH
3810: LD_STRING ScholtzeRu10
3812: PPUSH
3813: CALL_OW 39
// end ; if Kuzmov in list then
3817: LD_EXP 9
3821: PUSH
3822: LD_VAR 0 1
3826: IN
3827: IFFALSE 3851
// begin SaveCharacters ( Kuzmov , Kuzmov ) ;
3829: LD_EXP 9
3833: PPUSH
3834: LD_STRING Kuzmov
3836: PPUSH
3837: CALL_OW 38
// SaveVariable ( 1 , KuzmovRu10 ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_STRING KuzmovRu10
3846: PPUSH
3847: CALL_OW 39
// end ; if Karamazov in list then
3851: LD_EXP 10
3855: PUSH
3856: LD_VAR 0 1
3860: IN
3861: IFFALSE 3885
// begin SaveCharacters ( Karamazov , Karamazov ) ;
3863: LD_EXP 10
3867: PPUSH
3868: LD_STRING Karamazov
3870: PPUSH
3871: CALL_OW 38
// SaveVariable ( 1 , KaramazovRu10 ) ;
3875: LD_INT 1
3877: PPUSH
3878: LD_STRING KaramazovRu10
3880: PPUSH
3881: CALL_OW 39
// end ; if Petrovova in list then
3885: LD_EXP 11
3889: PUSH
3890: LD_VAR 0 1
3894: IN
3895: IFFALSE 3919
// begin SaveCharacters ( Petrovova , Petrovova ) ;
3897: LD_EXP 11
3901: PPUSH
3902: LD_STRING Petrovova
3904: PPUSH
3905: CALL_OW 38
// SaveVariable ( 1 , PetrovovaRu10 ) ;
3909: LD_INT 1
3911: PPUSH
3912: LD_STRING PetrovovaRu10
3914: PPUSH
3915: CALL_OW 39
// end ; if Gleb in list then
3919: LD_EXP 12
3923: PUSH
3924: LD_VAR 0 1
3928: IN
3929: IFFALSE 3953
// begin SaveCharacters ( Gleb , Gleb ) ;
3931: LD_EXP 12
3935: PPUSH
3936: LD_STRING Gleb
3938: PPUSH
3939: CALL_OW 38
// SaveVariable ( 1 , GlebRu10 ) ;
3943: LD_INT 1
3945: PPUSH
3946: LD_STRING GlebRu10
3948: PPUSH
3949: CALL_OW 39
// end ; if Petrosyan in list then
3953: LD_EXP 13
3957: PUSH
3958: LD_VAR 0 1
3962: IN
3963: IFFALSE 3987
// begin SaveCharacters ( Petrosyan , Petrosyan ) ;
3965: LD_EXP 13
3969: PPUSH
3970: LD_STRING Petrosyan
3972: PPUSH
3973: CALL_OW 38
// SaveVariable ( 1 , PetrosyanRu10 ) ;
3977: LD_INT 1
3979: PPUSH
3980: LD_STRING PetrosyanRu10
3982: PPUSH
3983: CALL_OW 39
// end ; if Lipshchin in list then
3987: LD_EXP 14
3991: PUSH
3992: LD_VAR 0 1
3996: IN
3997: IFFALSE 4021
// begin SaveCharacters ( Lipshchin , Lipshchin ) ;
3999: LD_EXP 14
4003: PPUSH
4004: LD_STRING Lipshchin
4006: PPUSH
4007: CALL_OW 38
// SaveVariable ( 1 , LipshchinRu10 ) ;
4011: LD_INT 1
4013: PPUSH
4014: LD_STRING LipshchinRu10
4016: PPUSH
4017: CALL_OW 39
// end ; if Titov in list then
4021: LD_EXP 15
4025: PUSH
4026: LD_VAR 0 1
4030: IN
4031: IFFALSE 4055
// begin SaveCharacters ( Titov , Titov ) ;
4033: LD_EXP 15
4037: PPUSH
4038: LD_STRING Titov
4040: PPUSH
4041: CALL_OW 38
// SaveVariable ( 1 , TitovRu10 ) ;
4045: LD_INT 1
4047: PPUSH
4048: LD_STRING TitovRu10
4050: PPUSH
4051: CALL_OW 39
// end ; if Dolgov in list then
4055: LD_EXP 16
4059: PUSH
4060: LD_VAR 0 1
4064: IN
4065: IFFALSE 4089
// begin SaveCharacters ( Dolgov , Dolgov ) ;
4067: LD_EXP 16
4071: PPUSH
4072: LD_STRING Dolgov
4074: PPUSH
4075: CALL_OW 38
// SaveVariable ( 1 , DolgovRu10 ) ;
4079: LD_INT 1
4081: PPUSH
4082: LD_STRING DolgovRu10
4084: PPUSH
4085: CALL_OW 39
// end ; if Oblukov in list then
4089: LD_EXP 20
4093: PUSH
4094: LD_VAR 0 1
4098: IN
4099: IFFALSE 4123
// begin SaveCharacters ( Oblukov , Oblukov ) ;
4101: LD_EXP 20
4105: PPUSH
4106: LD_STRING Oblukov
4108: PPUSH
4109: CALL_OW 38
// SaveVariable ( 1 , OblukovRu10 ) ;
4113: LD_INT 1
4115: PPUSH
4116: LD_STRING OblukovRu10
4118: PPUSH
4119: CALL_OW 39
// end ; if Xavier in list then
4123: LD_EXP 18
4127: PUSH
4128: LD_VAR 0 1
4132: IN
4133: IFFALSE 4157
// begin SaveCharacters ( Xavier , Xavier ) ;
4135: LD_EXP 18
4139: PPUSH
4140: LD_STRING Xavier
4142: PPUSH
4143: CALL_OW 38
// SaveVariable ( 1 , XavierRu10 ) ;
4147: LD_INT 1
4149: PPUSH
4150: LD_STRING XavierRu10
4152: PPUSH
4153: CALL_OW 39
// end ; if Kozlov in list then
4157: LD_EXP 21
4161: PUSH
4162: LD_VAR 0 1
4166: IN
4167: IFFALSE 4191
// begin SaveCharacters ( Kozlov , Kozlov ) ;
4169: LD_EXP 21
4173: PPUSH
4174: LD_STRING Kozlov
4176: PPUSH
4177: CALL_OW 38
// SaveVariable ( 1 , KozlovRu10 ) ;
4181: LD_INT 1
4183: PPUSH
4184: LD_STRING KozlovRu10
4186: PPUSH
4187: CALL_OW 39
// end ; if Kapitsova in list then
4191: LD_EXP 22
4195: PUSH
4196: LD_VAR 0 1
4200: IN
4201: IFFALSE 4225
// begin SaveCharacters ( Kapitsova , Kapitsova ) ;
4203: LD_EXP 22
4207: PPUSH
4208: LD_STRING Kapitsova
4210: PPUSH
4211: CALL_OW 38
// SaveVariable ( 1 , KapitsovaRu10 ) ;
4215: LD_INT 1
4217: PPUSH
4218: LD_STRING KapitsovaRu10
4220: PPUSH
4221: CALL_OW 39
// end ; list := list diff old_chars ;
4225: LD_ADDR_VAR 0 1
4229: PUSH
4230: LD_VAR 0 1
4234: PUSH
4235: LD_EXP 31
4239: DIFF
4240: ST_TO_ADDR
// SaveCharacters ( list , Ru10trans ) ;
4241: LD_VAR 0 1
4245: PPUSH
4246: LD_STRING Ru10trans
4248: PPUSH
4249: CALL_OW 38
// SaveCharacters ( people diff list ^ [ Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Oblukov , Xavier , Kozlov , Kapitsova ] , survivors3 ) ;
4253: LD_EXP 27
4257: PUSH
4258: LD_VAR 0 1
4262: PUSH
4263: LD_EXP 4
4267: PUSH
4268: LD_EXP 3
4272: PUSH
4273: LD_EXP 5
4277: PUSH
4278: LD_EXP 6
4282: PUSH
4283: LD_EXP 8
4287: PUSH
4288: LD_EXP 9
4292: PUSH
4293: LD_EXP 10
4297: PUSH
4298: LD_EXP 11
4302: PUSH
4303: LD_EXP 12
4307: PUSH
4308: LD_EXP 13
4312: PUSH
4313: LD_EXP 14
4317: PUSH
4318: LD_EXP 15
4322: PUSH
4323: LD_EXP 16
4327: PUSH
4328: LD_EXP 20
4332: PUSH
4333: LD_EXP 18
4337: PUSH
4338: LD_EXP 21
4342: PUSH
4343: LD_EXP 22
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: LIST
4356: LIST
4357: LIST
4358: LIST
4359: LIST
4360: LIST
4361: LIST
4362: LIST
4363: LIST
4364: LIST
4365: LIST
4366: ADD
4367: DIFF
4368: PPUSH
4369: LD_STRING survivors3
4371: PPUSH
4372: CALL_OW 38
// SaveBaseTrotskij ;
4376: CALL 4395 0 0
// ChangeMap ( %_cont , %_cont ) ;
4380: LD_STRING %_cont
4382: PPUSH
4383: LD_STRING %_cont
4385: PPUSH
4386: CALL_OW 340
// end ;
4390: LD_VAR 0 2
4394: RET
// function SaveBaseTrotskij ; var Trotskij , filter , un ; begin
4395: LD_INT 0
4397: PPUSH
4398: PPUSH
4399: PPUSH
4400: PPUSH
// Trotskij := [ ] ;
4401: LD_ADDR_VAR 0 2
4405: PUSH
4406: EMPTY
4407: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
4408: LD_ADDR_VAR 0 3
4412: PUSH
4413: LD_INT 30
4415: PUSH
4416: LD_INT 3
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: EMPTY
4424: LIST
4425: PPUSH
4426: CALL_OW 69
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 3
4443: PUSH
4444: LD_INT 30
4446: PUSH
4447: LD_INT 3
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ADD
4467: ST_TO_ADDR
// for un in filter do
4468: LD_ADDR_VAR 0 4
4472: PUSH
4473: LD_VAR 0 3
4477: PUSH
4478: FOR_IN
4479: IFFALSE 4820
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
4481: LD_VAR 0 4
4485: PPUSH
4486: CALL_OW 266
4490: PUSH
4491: LD_INT 6
4493: PUSH
4494: LD_INT 7
4496: PUSH
4497: LD_INT 8
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: IN
4505: IFFALSE 4619
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4507: LD_ADDR_VAR 0 2
4511: PUSH
4512: LD_VAR 0 2
4516: PUSH
4517: LD_VAR 0 4
4521: PPUSH
4522: CALL_OW 266
4526: PUSH
4527: LD_VAR 0 4
4531: PPUSH
4532: CALL_OW 250
4536: PUSH
4537: LD_VAR 0 4
4541: PPUSH
4542: CALL_OW 251
4546: PUSH
4547: LD_VAR 0 4
4551: PPUSH
4552: CALL_OW 254
4556: PUSH
4557: LD_VAR 0 4
4561: PPUSH
4562: CALL_OW 267
4566: PUSH
4567: LD_VAR 0 4
4571: PPUSH
4572: CALL_OW 248
4576: PUSH
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 268
4589: PUSH
4590: LD_VAR 0 4
4594: PPUSH
4595: LD_INT 2
4597: PPUSH
4598: CALL_OW 268
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: PUSH
4613: EMPTY
4614: LIST
4615: ADD
4616: ST_TO_ADDR
4617: GO 4818
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4619: LD_VAR 0 4
4623: PPUSH
4624: CALL_OW 266
4628: PUSH
4629: LD_INT 32
4631: PUSH
4632: LD_INT 33
4634: PUSH
4635: EMPTY
4636: LIST
4637: LIST
4638: IN
4639: IFFALSE 4736
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4641: LD_ADDR_VAR 0 2
4645: PUSH
4646: LD_VAR 0 2
4650: PUSH
4651: LD_VAR 0 4
4655: PPUSH
4656: CALL_OW 266
4660: PUSH
4661: LD_VAR 0 4
4665: PPUSH
4666: CALL_OW 250
4670: PUSH
4671: LD_VAR 0 4
4675: PPUSH
4676: CALL_OW 251
4680: PUSH
4681: LD_VAR 0 4
4685: PPUSH
4686: CALL_OW 254
4690: PUSH
4691: LD_VAR 0 4
4695: PPUSH
4696: CALL_OW 267
4700: PUSH
4701: LD_VAR 0 4
4705: PPUSH
4706: CALL_OW 248
4710: PUSH
4711: LD_VAR 0 4
4715: PPUSH
4716: CALL_OW 269
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: ADD
4733: ST_TO_ADDR
4734: GO 4818
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4736: LD_ADDR_VAR 0 2
4740: PUSH
4741: LD_VAR 0 2
4745: PUSH
4746: LD_VAR 0 4
4750: PPUSH
4751: CALL_OW 266
4755: PUSH
4756: LD_VAR 0 4
4760: PPUSH
4761: CALL_OW 250
4765: PUSH
4766: LD_VAR 0 4
4770: PPUSH
4771: CALL_OW 251
4775: PUSH
4776: LD_VAR 0 4
4780: PPUSH
4781: CALL_OW 254
4785: PUSH
4786: LD_VAR 0 4
4790: PPUSH
4791: CALL_OW 267
4795: PUSH
4796: LD_VAR 0 4
4800: PPUSH
4801: CALL_OW 248
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: ADD
4817: ST_TO_ADDR
// end ;
4818: GO 4478
4820: POP
4821: POP
// SaveVariable ( trotskij , Trotskij ) ;
4822: LD_VAR 0 2
4826: PPUSH
4827: LD_STRING Trotskij
4829: PPUSH
4830: CALL_OW 39
// end ; end_of_file
4834: LD_VAR 0 1
4838: RET
// export function DisplayNames ; var i ; begin
4839: LD_INT 0
4841: PPUSH
4842: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) do
4843: LD_ADDR_VAR 0 2
4847: PUSH
4848: LD_INT 2
4850: PUSH
4851: LD_INT 30
4853: PUSH
4854: LD_INT 0
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: PUSH
4861: LD_INT 30
4863: PUSH
4864: LD_INT 1
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 69
4880: PUSH
4881: FOR_IN
4882: IFFALSE 4898
// SetBName ( i , trockij ) ;
4884: LD_VAR 0 2
4888: PPUSH
4889: LD_STRING trockij
4891: PPUSH
4892: CALL_OW 500
4896: GO 4881
4898: POP
4899: POP
// end ;
4900: LD_VAR 0 1
4904: RET
// every 0 0$2 do
4905: GO 4907
4907: DISABLE
// begin DisplayNames ;
4908: CALL 4839 0 0
// end ;
4912: END

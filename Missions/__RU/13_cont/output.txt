// export side_Neutral , side_Am , side_Ru ; export Burlak , Bystrov ; export Belkov , Gnyevko , Kirilenkova ; export Kovalyuk , Scholtze ; export Kuzmov ; export Karamazov , Petrovova , Gleb , Petrosyan ; export Lipshchin , Titov , Dolgov , Xavier ; export Oblukov , Kozlov , Kapitsova ; export Masha ; export Ostatni ; export Gladkov , GladkovFake ; export Rusove ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// if Result then
  74: LD_VAR 0 2
  78: IFFALSE 92
// SetSide ( Result , 3 ) ;
  80: LD_VAR 0 2
  84: PPUSH
  85: LD_INT 3
  87: PPUSH
  88: CALL_OW 235
// end ;
  92: LD_VAR 0 2
  96: RET
// function load_create ( Ident ) ; begin
  97: LD_INT 0
  99: PPUSH
// if TestCharacters ( Ident ) then
 100: LD_VAR 0 1
 104: PPUSH
 105: CALL_OW 28
 109: IFFALSE 156
// begin Result = CreateCharacter ( Ident ) ;
 111: LD_ADDR_VAR 0 2
 115: PUSH
 116: LD_VAR 0 1
 120: PPUSH
 121: CALL_OW 34
 125: ST_TO_ADDR
// if IsDead ( Result ) then
 126: LD_VAR 0 2
 130: PPUSH
 131: CALL_OW 301
 135: IFFALSE 154
// begin DestroyUnit ( Result ) ;
 137: LD_VAR 0 2
 141: PPUSH
 142: CALL_OW 65
// Result = 0 ;
 146: LD_ADDR_VAR 0 2
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ; end else
 154: GO 171
// Result = NewCharacter ( Ident ) ;
 156: LD_ADDR_VAR 0 2
 160: PUSH
 161: LD_VAR 0 1
 165: PPUSH
 166: CALL_OW 25
 170: ST_TO_ADDR
// if Result then
 171: LD_VAR 0 2
 175: IFFALSE 189
// SetSide ( Result , 3 ) ;
 177: LD_VAR 0 2
 181: PPUSH
 182: LD_INT 3
 184: PPUSH
 185: CALL_OW 235
// end ;
 189: LD_VAR 0 2
 193: RET
// function load_set ( Ident ) ; begin
 194: LD_INT 0
 196: PPUSH
// if TestCharacters ( Ident ) then
 197: LD_VAR 0 1
 201: PPUSH
 202: CALL_OW 28
 206: IFFALSE 225
// Result = CreateCharacterSet ( Ident ) else
 208: LD_ADDR_VAR 0 2
 212: PUSH
 213: LD_VAR 0 1
 217: PPUSH
 218: CALL_OW 31
 222: ST_TO_ADDR
 223: GO 232
// Result = [ ] ;
 225: LD_ADDR_VAR 0 2
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// end ;
 232: LD_VAR 0 2
 236: RET
// function vytvor_gladkova ; begin
 237: LD_INT 0
 239: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 240: LD_ADDR_OWVAR 21
 244: PUSH
 245: LD_INT 3
 247: ST_TO_ADDR
// UC_side = side_Ru ;
 248: LD_ADDR_OWVAR 20
 252: PUSH
 253: LD_EXP 3
 257: ST_TO_ADDR
// HC_name =  ;
 258: LD_ADDR_OWVAR 26
 262: PUSH
 263: LD_STRING 
 265: ST_TO_ADDR
// HC_sex = SEX_MALE ;
 266: LD_ADDR_OWVAR 27
 270: PUSH
 271: LD_INT 1
 273: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 274: LD_ADDR_OWVAR 28
 278: PUSH
 279: LD_INT 1
 281: ST_TO_ADDR
// PrepareSoldierSkills ( 7 ) ;
 282: LD_INT 7
 284: PPUSH
 285: CALL_OW 375
// Result = CreateHuman ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: CALL_OW 44
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// function load ; var MashaSpec ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// UC_Side = side_Ru ;
 308: LD_ADDR_OWVAR 20
 312: PUSH
 313: LD_EXP 3
 317: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
 318: LD_ADDR_OWVAR 21
 322: PUSH
 323: LD_INT 3
 325: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 326: LD_ADDR_EXP 4
 330: PUSH
 331: LD_STRING Burlak
 333: PPUSH
 334: CALL 0 0 1
 338: ST_TO_ADDR
// Bystrov = NewCharacter ( Bystrov ) ;
 339: LD_ADDR_EXP 5
 343: PUSH
 344: LD_STRING Bystrov
 346: PPUSH
 347: CALL_OW 25
 351: ST_TO_ADDR
// Gladkov = load_char ( Gladkov ) ;
 352: LD_ADDR_EXP 25
 356: PUSH
 357: LD_STRING Gladkov
 359: PPUSH
 360: CALL 0 0 1
 364: ST_TO_ADDR
// if not Gladkov then
 365: LD_EXP 25
 369: NOT
 370: IFFALSE 382
// GladkovFake = vytvor_gladkova ;
 372: LD_ADDR_EXP 26
 376: PUSH
 377: CALL 237 0 0
 381: ST_TO_ADDR
// MashaSpec = LoadVariable ( Masha , [ ] ) ;
 382: LD_ADDR_VAR 0 2
 386: PUSH
 387: LD_STRING Masha
 389: PPUSH
 390: EMPTY
 391: PPUSH
 392: CALL_OW 30
 396: ST_TO_ADDR
// if MashaSpec = 0 then
 397: LD_VAR 0 2
 401: PUSH
 402: LD_INT 0
 404: EQUAL
 405: IFFALSE 417
// Masha = 0 else
 407: LD_ADDR_EXP 23
 411: PUSH
 412: LD_INT 0
 414: ST_TO_ADDR
 415: GO 563
// begin UC_Nation = NATION_RUSSIAN ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 3
 424: ST_TO_ADDR
// UC_Side = side_Ru ;
 425: LD_ADDR_OWVAR 20
 429: PUSH
 430: LD_EXP 3
 434: ST_TO_ADDR
// VC_Chassis = MashaSpec [ 1 ] ;
 435: LD_ADDR_OWVAR 37
 439: PUSH
 440: LD_VAR 0 2
 444: PUSH
 445: LD_INT 1
 447: ARRAY
 448: ST_TO_ADDR
// VC_Engine = MashaSpec [ 2 ] ;
 449: LD_ADDR_OWVAR 39
 453: PUSH
 454: LD_VAR 0 2
 458: PUSH
 459: LD_INT 2
 461: ARRAY
 462: ST_TO_ADDR
// VC_Control = MashaSpec [ 3 ] ;
 463: LD_ADDR_OWVAR 38
 467: PUSH
 468: LD_VAR 0 2
 472: PUSH
 473: LD_INT 3
 475: ARRAY
 476: ST_TO_ADDR
// VC_Weapon = MashaSpec [ 4 ] ;
 477: LD_ADDR_OWVAR 40
 481: PUSH
 482: LD_VAR 0 2
 486: PUSH
 487: LD_INT 4
 489: ARRAY
 490: ST_TO_ADDR
// if ( VC_Weapon = 0 ) or ( VC_Control = 0 ) or ( VC_Engine = 0 ) or ( VC_Chassis = 0 ) then
 491: LD_OWVAR 40
 495: PUSH
 496: LD_INT 0
 498: EQUAL
 499: PUSH
 500: LD_OWVAR 38
 504: PUSH
 505: LD_INT 0
 507: EQUAL
 508: OR
 509: PUSH
 510: LD_OWVAR 39
 514: PUSH
 515: LD_INT 0
 517: EQUAL
 518: OR
 519: PUSH
 520: LD_OWVAR 37
 524: PUSH
 525: LD_INT 0
 527: EQUAL
 528: OR
 529: IFFALSE 541
// Masha = 0 else
 531: LD_ADDR_EXP 23
 535: PUSH
 536: LD_INT 0
 538: ST_TO_ADDR
 539: GO 563
// begin Masha = CreateVehicle ;
 541: LD_ADDR_EXP 23
 545: PUSH
 546: CALL_OW 45
 550: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
 551: LD_EXP 23
 555: PPUSH
 556: LD_INT 1
 558: PPUSH
 559: CALL_OW 242
// end ; end ; if LoadVariable ( GlebLoc , 0 ) = 13 then
 563: LD_STRING GlebLoc
 565: PPUSH
 566: LD_INT 0
 568: PPUSH
 569: CALL_OW 30
 573: PUSH
 574: LD_INT 13
 576: EQUAL
 577: IFFALSE 592
// Gleb = load_char ( Gleb ) ;
 579: LD_ADDR_EXP 14
 583: PUSH
 584: LD_STRING Gleb
 586: PPUSH
 587: CALL 0 0 1
 591: ST_TO_ADDR
// if LoadVariable ( BelkovLoc , 0 ) = 13 then
 592: LD_STRING BelkovLoc
 594: PPUSH
 595: LD_INT 0
 597: PPUSH
 598: CALL_OW 30
 602: PUSH
 603: LD_INT 13
 605: EQUAL
 606: IFFALSE 621
// Belkov = load_char ( Belkov ) ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_STRING Belkov
 615: PPUSH
 616: CALL 0 0 1
 620: ST_TO_ADDR
// if LoadVariable ( GnyevkoLoc , 0 ) = 13 then
 621: LD_STRING GnyevkoLoc
 623: PPUSH
 624: LD_INT 0
 626: PPUSH
 627: CALL_OW 30
 631: PUSH
 632: LD_INT 13
 634: EQUAL
 635: IFFALSE 650
// Gnyevko = load_char ( Gnyevko ) ;
 637: LD_ADDR_EXP 7
 641: PUSH
 642: LD_STRING Gnyevko
 644: PPUSH
 645: CALL 0 0 1
 649: ST_TO_ADDR
// if LoadVariable ( KirilenkovaLoc , 0 ) = 13 then
 650: LD_STRING KirilenkovaLoc
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 30
 660: PUSH
 661: LD_INT 13
 663: EQUAL
 664: IFFALSE 679
// Kirilenkova = load_char ( Kirilenkova ) ;
 666: LD_ADDR_EXP 8
 670: PUSH
 671: LD_STRING Kirilenkova
 673: PPUSH
 674: CALL 0 0 1
 678: ST_TO_ADDR
// if LoadVariable ( KovalyukLoc , 0 ) = 13 then
 679: LD_STRING KovalyukLoc
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL_OW 30
 689: PUSH
 690: LD_INT 13
 692: EQUAL
 693: IFFALSE 708
// Kovalyuk = load_char ( Kovalyuk ) ;
 695: LD_ADDR_EXP 9
 699: PUSH
 700: LD_STRING Kovalyuk
 702: PPUSH
 703: CALL 0 0 1
 707: ST_TO_ADDR
// if LoadVariable ( ScholtzeLoc , 0 ) = 13 then
 708: LD_STRING ScholtzeLoc
 710: PPUSH
 711: LD_INT 0
 713: PPUSH
 714: CALL_OW 30
 718: PUSH
 719: LD_INT 13
 721: EQUAL
 722: IFFALSE 737
// Scholtze = load_char ( Scholtze ) ;
 724: LD_ADDR_EXP 10
 728: PUSH
 729: LD_STRING Scholtze
 731: PPUSH
 732: CALL 0 0 1
 736: ST_TO_ADDR
// if LoadVariable ( KuzmovLoc , 0 ) = 13 then
 737: LD_STRING KuzmovLoc
 739: PPUSH
 740: LD_INT 0
 742: PPUSH
 743: CALL_OW 30
 747: PUSH
 748: LD_INT 13
 750: EQUAL
 751: IFFALSE 766
// Kuzmov = load_char ( Kuzmov ) ;
 753: LD_ADDR_EXP 11
 757: PUSH
 758: LD_STRING Kuzmov
 760: PPUSH
 761: CALL 0 0 1
 765: ST_TO_ADDR
// if LoadVariable ( KaramazovLoc , 0 ) = 13 then
 766: LD_STRING KaramazovLoc
 768: PPUSH
 769: LD_INT 0
 771: PPUSH
 772: CALL_OW 30
 776: PUSH
 777: LD_INT 13
 779: EQUAL
 780: IFFALSE 795
// Karamazov = load_char ( Karamazov ) ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_STRING Karamazov
 789: PPUSH
 790: CALL 0 0 1
 794: ST_TO_ADDR
// if LoadVariable ( PetrovovaLoc , 0 ) = 13 then
 795: LD_STRING PetrovovaLoc
 797: PPUSH
 798: LD_INT 0
 800: PPUSH
 801: CALL_OW 30
 805: PUSH
 806: LD_INT 13
 808: EQUAL
 809: IFFALSE 824
// Petrovova = load_char ( Petrovova ) ;
 811: LD_ADDR_EXP 13
 815: PUSH
 816: LD_STRING Petrovova
 818: PPUSH
 819: CALL 0 0 1
 823: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 13 then
 824: LD_STRING GlebLoc
 826: PPUSH
 827: LD_INT 0
 829: PPUSH
 830: CALL_OW 30
 834: PUSH
 835: LD_INT 13
 837: EQUAL
 838: IFFALSE 853
// Gleb = load_char ( Gleb ) ;
 840: LD_ADDR_EXP 14
 844: PUSH
 845: LD_STRING Gleb
 847: PPUSH
 848: CALL 0 0 1
 852: ST_TO_ADDR
// if LoadVariable ( PetrosyanLoc , 0 ) = 13 then
 853: LD_STRING PetrosyanLoc
 855: PPUSH
 856: LD_INT 0
 858: PPUSH
 859: CALL_OW 30
 863: PUSH
 864: LD_INT 13
 866: EQUAL
 867: IFFALSE 882
// Petrosyan = load_char ( Petrosyan ) ;
 869: LD_ADDR_EXP 15
 873: PUSH
 874: LD_STRING Petrosyan
 876: PPUSH
 877: CALL 0 0 1
 881: ST_TO_ADDR
// if LoadVariable ( LipshchinLoc , 0 ) = 13 then
 882: LD_STRING LipshchinLoc
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 30
 892: PUSH
 893: LD_INT 13
 895: EQUAL
 896: IFFALSE 911
// Lipshchin = load_char ( Lipshchin ) ;
 898: LD_ADDR_EXP 16
 902: PUSH
 903: LD_STRING Lipshchin
 905: PPUSH
 906: CALL 0 0 1
 910: ST_TO_ADDR
// if LoadVariable ( TitovLoc , 0 ) = 13 then
 911: LD_STRING TitovLoc
 913: PPUSH
 914: LD_INT 0
 916: PPUSH
 917: CALL_OW 30
 921: PUSH
 922: LD_INT 13
 924: EQUAL
 925: IFFALSE 940
// Titov = load_char ( Titov ) ;
 927: LD_ADDR_EXP 17
 931: PUSH
 932: LD_STRING Titov
 934: PPUSH
 935: CALL 0 0 1
 939: ST_TO_ADDR
// if LoadVariable ( DolgovLoc , 0 ) = 13 then
 940: LD_STRING DolgovLoc
 942: PPUSH
 943: LD_INT 0
 945: PPUSH
 946: CALL_OW 30
 950: PUSH
 951: LD_INT 13
 953: EQUAL
 954: IFFALSE 969
// Dolgov = load_char ( Dolgov ) ;
 956: LD_ADDR_EXP 18
 960: PUSH
 961: LD_STRING Dolgov
 963: PPUSH
 964: CALL 0 0 1
 968: ST_TO_ADDR
// if LoadVariable ( XavierLoc , 0 ) = 13 then
 969: LD_STRING XavierLoc
 971: PPUSH
 972: LD_INT 0
 974: PPUSH
 975: CALL_OW 30
 979: PUSH
 980: LD_INT 13
 982: EQUAL
 983: IFFALSE 998
// Xavier = load_char ( Xavier ) ;
 985: LD_ADDR_EXP 19
 989: PUSH
 990: LD_STRING Xavier
 992: PPUSH
 993: CALL 0 0 1
 997: ST_TO_ADDR
// if LoadVariable ( OblukovLoc , 0 ) = 13 then
 998: LD_STRING OblukovLoc
1000: PPUSH
1001: LD_INT 0
1003: PPUSH
1004: CALL_OW 30
1008: PUSH
1009: LD_INT 13
1011: EQUAL
1012: IFFALSE 1027
// Oblukov = load_char ( Oblukov ) ;
1014: LD_ADDR_EXP 20
1018: PUSH
1019: LD_STRING Oblukov
1021: PPUSH
1022: CALL 0 0 1
1026: ST_TO_ADDR
// if LoadVariable ( KozlovLoc , 0 ) = 13 then
1027: LD_STRING KozlovLoc
1029: PPUSH
1030: LD_INT 0
1032: PPUSH
1033: CALL_OW 30
1037: PUSH
1038: LD_INT 13
1040: EQUAL
1041: IFFALSE 1056
// Kozlov = load_char ( Kozlov ) ;
1043: LD_ADDR_EXP 21
1047: PUSH
1048: LD_STRING Kozlov
1050: PPUSH
1051: CALL 0 0 1
1055: ST_TO_ADDR
// if LoadVariable ( KapitsovaLoc , 0 ) = 13 then
1056: LD_STRING KapitsovaLoc
1058: PPUSH
1059: LD_INT 0
1061: PPUSH
1062: CALL_OW 30
1066: PUSH
1067: LD_INT 13
1069: EQUAL
1070: IFFALSE 1085
// Kapitsova = load_char ( Kapitsova ) ;
1072: LD_ADDR_EXP 22
1076: PUSH
1077: LD_STRING Kapitsova
1079: PPUSH
1080: CALL 0 0 1
1084: ST_TO_ADDR
// Ostatni = load_set ( Others_Ru13 ) ;
1085: LD_ADDR_EXP 24
1089: PUSH
1090: LD_STRING Others_Ru13
1092: PPUSH
1093: CALL 194 0 1
1097: ST_TO_ADDR
// DeleteCharacters ( Others_Ru13 ) ;
1098: LD_STRING Others_Ru13
1100: PPUSH
1101: CALL_OW 40
// Rusove = ( [ Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Ostatni ) diff [ 0 ] ;
1105: LD_ADDR_EXP 27
1109: PUSH
1110: LD_EXP 14
1114: PUSH
1115: LD_EXP 6
1119: PUSH
1120: LD_EXP 7
1124: PUSH
1125: LD_EXP 8
1129: PUSH
1130: LD_EXP 9
1134: PUSH
1135: LD_EXP 10
1139: PUSH
1140: LD_EXP 11
1144: PUSH
1145: LD_EXP 12
1149: PUSH
1150: LD_EXP 13
1154: PUSH
1155: LD_EXP 14
1159: PUSH
1160: LD_EXP 15
1164: PUSH
1165: LD_EXP 16
1169: PUSH
1170: LD_EXP 17
1174: PUSH
1175: LD_EXP 18
1179: PUSH
1180: LD_EXP 19
1184: PUSH
1185: LD_EXP 20
1189: PUSH
1190: LD_EXP 21
1194: PUSH
1195: LD_EXP 22
1199: PUSH
1200: EMPTY
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PUSH
1220: LD_EXP 24
1224: UNION
1225: PUSH
1226: LD_INT 0
1228: PUSH
1229: EMPTY
1230: LIST
1231: DIFF
1232: ST_TO_ADDR
// SetSide ( [ Burlak , Bystrov , Gladkov ] , side_Ru ) ;
1233: LD_EXP 4
1237: PUSH
1238: LD_EXP 5
1242: PUSH
1243: LD_EXP 25
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: PPUSH
1253: LD_EXP 3
1257: PPUSH
1258: CALL_OW 235
// SetSide ( Rusove , side_Ru ) ;
1262: LD_EXP 27
1266: PPUSH
1267: LD_EXP 3
1271: PPUSH
1272: CALL_OW 235
// end ;
1276: LD_VAR 0 1
1280: RET
// function save_char ( Handle , Ident ) ; begin
1281: LD_INT 0
1283: PPUSH
// if Handle then
1284: LD_VAR 0 1
1288: IFFALSE 1307
// SaveCharacters ( [ Handle ] , Ident ) ;
1290: LD_VAR 0 1
1294: PUSH
1295: EMPTY
1296: LIST
1297: PPUSH
1298: LD_VAR 0 2
1302: PPUSH
1303: CALL_OW 38
// end ;
1307: LD_VAR 0 3
1311: RET
// function save ; var MashaSpec , Survivors4 , O , Opice ; begin
1312: LD_INT 0
1314: PPUSH
1315: PPUSH
1316: PPUSH
1317: PPUSH
1318: PPUSH
// save_char ( Burlak , Burlak ) ;
1319: LD_EXP 4
1323: PPUSH
1324: LD_STRING Burlak
1326: PPUSH
1327: CALL 1281 0 2
// save_char ( Bystrov , Bystrov ) ;
1331: LD_EXP 5
1335: PPUSH
1336: LD_STRING Bystrov
1338: PPUSH
1339: CALL 1281 0 2
// save_char ( Gleb , Gleb ) ;
1343: LD_EXP 14
1347: PPUSH
1348: LD_STRING Gleb
1350: PPUSH
1351: CALL 1281 0 2
// save_char ( Belkov , Belkov ) ;
1355: LD_EXP 6
1359: PPUSH
1360: LD_STRING Belkov
1362: PPUSH
1363: CALL 1281 0 2
// save_char ( Gnyevko , Gnyevko ) ;
1367: LD_EXP 7
1371: PPUSH
1372: LD_STRING Gnyevko
1374: PPUSH
1375: CALL 1281 0 2
// save_char ( Kirilenkova , Kirilenkova ) ;
1379: LD_EXP 8
1383: PPUSH
1384: LD_STRING Kirilenkova
1386: PPUSH
1387: CALL 1281 0 2
// save_char ( Kovalyuk , Kovalyuk ) ;
1391: LD_EXP 9
1395: PPUSH
1396: LD_STRING Kovalyuk
1398: PPUSH
1399: CALL 1281 0 2
// save_char ( Scholtze , Scholtze ) ;
1403: LD_EXP 10
1407: PPUSH
1408: LD_STRING Scholtze
1410: PPUSH
1411: CALL 1281 0 2
// save_char ( Kuzmov , Kuzmov ) ;
1415: LD_EXP 11
1419: PPUSH
1420: LD_STRING Kuzmov
1422: PPUSH
1423: CALL 1281 0 2
// save_char ( Karamazov , Karamazov ) ;
1427: LD_EXP 12
1431: PPUSH
1432: LD_STRING Karamazov
1434: PPUSH
1435: CALL 1281 0 2
// save_char ( Petrovova , Petrovova ) ;
1439: LD_EXP 13
1443: PPUSH
1444: LD_STRING Petrovova
1446: PPUSH
1447: CALL 1281 0 2
// save_char ( Gleb , Gleb ) ;
1451: LD_EXP 14
1455: PPUSH
1456: LD_STRING Gleb
1458: PPUSH
1459: CALL 1281 0 2
// save_char ( Petrosyan , Petrosyan ) ;
1463: LD_EXP 15
1467: PPUSH
1468: LD_STRING Petrosyan
1470: PPUSH
1471: CALL 1281 0 2
// save_char ( Lipshchin , Lipshchin ) ;
1475: LD_EXP 16
1479: PPUSH
1480: LD_STRING Lipshchin
1482: PPUSH
1483: CALL 1281 0 2
// save_char ( Titov , Titov ) ;
1487: LD_EXP 17
1491: PPUSH
1492: LD_STRING Titov
1494: PPUSH
1495: CALL 1281 0 2
// save_char ( Dolgov , Dolgov ) ;
1499: LD_EXP 18
1503: PPUSH
1504: LD_STRING Dolgov
1506: PPUSH
1507: CALL 1281 0 2
// save_char ( Xavier , Xavier ) ;
1511: LD_EXP 19
1515: PPUSH
1516: LD_STRING Xavier
1518: PPUSH
1519: CALL 1281 0 2
// save_char ( Oblukov , Oblukov ) ;
1523: LD_EXP 20
1527: PPUSH
1528: LD_STRING Oblukov
1530: PPUSH
1531: CALL 1281 0 2
// save_char ( Kozlov , Kozlov ) ;
1535: LD_EXP 21
1539: PPUSH
1540: LD_STRING Kozlov
1542: PPUSH
1543: CALL 1281 0 2
// save_char ( Kapitsova , Kapitsova ) ;
1547: LD_EXP 22
1551: PPUSH
1552: LD_STRING Kapitsova
1554: PPUSH
1555: CALL 1281 0 2
// Survivors4 = load_set ( Survivors4 ) ;
1559: LD_ADDR_VAR 0 3
1563: PUSH
1564: LD_STRING Survivors4
1566: PPUSH
1567: CALL 194 0 1
1571: ST_TO_ADDR
// O = Rusove diff [ 0 , Burlak , Bystrov , Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] ;
1572: LD_ADDR_VAR 0 4
1576: PUSH
1577: LD_EXP 27
1581: PUSH
1582: LD_INT 0
1584: PUSH
1585: LD_EXP 4
1589: PUSH
1590: LD_EXP 5
1594: PUSH
1595: LD_EXP 14
1599: PUSH
1600: LD_EXP 6
1604: PUSH
1605: LD_EXP 7
1609: PUSH
1610: LD_EXP 8
1614: PUSH
1615: LD_EXP 9
1619: PUSH
1620: LD_EXP 10
1624: PUSH
1625: LD_EXP 11
1629: PUSH
1630: LD_EXP 12
1634: PUSH
1635: LD_EXP 13
1639: PUSH
1640: LD_EXP 14
1644: PUSH
1645: LD_EXP 15
1649: PUSH
1650: LD_EXP 16
1654: PUSH
1655: LD_EXP 17
1659: PUSH
1660: LD_EXP 18
1664: PUSH
1665: LD_EXP 19
1669: PUSH
1670: LD_EXP 20
1674: PUSH
1675: LD_EXP 21
1679: PUSH
1680: LD_EXP 22
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: DIFF
1708: ST_TO_ADDR
// Opice = UnitFilter ( Rusove , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
1709: LD_ADDR_VAR 0 5
1713: PUSH
1714: LD_EXP 27
1718: PPUSH
1719: LD_INT 2
1721: PUSH
1722: LD_INT 25
1724: PUSH
1725: LD_INT 12
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PUSH
1732: LD_INT 25
1734: PUSH
1735: LD_INT 15
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: PUSH
1742: LD_INT 25
1744: PUSH
1745: LD_INT 16
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: PUSH
1752: LD_INT 25
1754: PUSH
1755: LD_INT 17
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: LIST
1767: LIST
1768: PUSH
1769: EMPTY
1770: LIST
1771: PPUSH
1772: CALL_OW 72
1776: ST_TO_ADDR
// O = O diff Opice ;
1777: LD_ADDR_VAR 0 4
1781: PUSH
1782: LD_VAR 0 4
1786: PUSH
1787: LD_VAR 0 5
1791: DIFF
1792: ST_TO_ADDR
// SaveCharacters ( Survivors4 union O , Survivors4 ) ;
1793: LD_VAR 0 3
1797: PUSH
1798: LD_VAR 0 4
1802: UNION
1803: PPUSH
1804: LD_STRING Survivors4
1806: PPUSH
1807: CALL_OW 38
// SaveVariable ( JMM and IsDead ( JMM ) , JMMKilled ) ;
1811: LD_EXP 44
1815: PUSH
1816: LD_EXP 44
1820: PPUSH
1821: CALL_OW 301
1825: AND
1826: PPUSH
1827: LD_STRING JMMKilled
1829: PPUSH
1830: CALL_OW 39
// if Masha and IsOk ( Masha ) and ( GetSide ( Masha ) = side_Ru ) and IsInArea ( Masha , Cil ) then
1834: LD_EXP 23
1838: PUSH
1839: LD_EXP 23
1843: PPUSH
1844: CALL_OW 302
1848: AND
1849: PUSH
1850: LD_EXP 23
1854: PPUSH
1855: CALL_OW 255
1859: PUSH
1860: LD_EXP 3
1864: EQUAL
1865: AND
1866: PUSH
1867: LD_EXP 23
1871: PPUSH
1872: LD_INT 10
1874: PPUSH
1875: CALL_OW 308
1879: AND
1880: IFFALSE 1884
// begin end else
1882: GO 1891
// DeleteVariable ( Masha ) ;
1884: LD_STRING Masha
1886: PPUSH
1887: CALL_OW 41
// end ;
1891: LD_VAR 0 1
1895: RET
// function dej_medaile ; begin
1896: LD_INT 0
1898: PPUSH
// if JMM and IsDead ( JMM ) then
1899: LD_EXP 44
1903: PUSH
1904: LD_EXP 44
1908: PPUSH
1909: CALL_OW 301
1913: AND
1914: IFFALSE 1928
// AddMedal ( Macmillan , 1 ) else
1916: LD_STRING Macmillan
1918: PPUSH
1919: LD_INT 1
1921: PPUSH
1922: CALL_OW 101
1926: GO 1939
// AddMedal ( Macmillan , - 1 ) ;
1928: LD_STRING Macmillan
1930: PPUSH
1931: LD_INT 1
1933: NEG
1934: PPUSH
1935: CALL_OW 101
// if ( OK_North = 2 ) and ( OK_East = 2 ) then
1939: LD_EXP 31
1943: PUSH
1944: LD_INT 2
1946: EQUAL
1947: PUSH
1948: LD_EXP 32
1952: PUSH
1953: LD_INT 2
1955: EQUAL
1956: AND
1957: IFFALSE 1971
// AddMedal ( Precision , 1 ) else
1959: LD_STRING Precision
1961: PPUSH
1962: LD_INT 1
1964: PPUSH
1965: CALL_OW 101
1969: GO 1982
// AddMedal ( Precision , - 1 ) ;
1971: LD_STRING Precision
1973: PPUSH
1974: LD_INT 1
1976: NEG
1977: PPUSH
1978: CALL_OW 101
// if TimeLapser then
1982: LD_EXP 33
1986: IFFALSE 2000
// AddMedal ( TimeLapser , 1 ) else
1988: LD_STRING TimeLapser
1990: PPUSH
1991: LD_INT 1
1993: PPUSH
1994: CALL_OW 101
1998: GO 2011
// AddMedal ( TimeLapser , - 1 ) ;
2000: LD_STRING TimeLapser
2002: PPUSH
2003: LD_INT 1
2005: NEG
2006: PPUSH
2007: CALL_OW 101
// end ;
2011: LD_VAR 0 1
2015: RET
// export function vyhral ; var Lidi , Opice ; begin
2016: LD_INT 0
2018: PPUSH
2019: PPUSH
2020: PPUSH
// dej_medaile ;
2021: CALL 1896 0 0
// GiveMedals ( Main ) ;
2025: LD_STRING Main
2027: PPUSH
2028: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2032: LD_ADDR_VAR 0 2
2036: PUSH
2037: LD_INT 22
2039: PUSH
2040: LD_EXP 3
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: PUSH
2049: LD_INT 21
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: PUSH
2059: LD_INT 51
2061: PUSH
2062: EMPTY
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2075: LD_ADDR_VAR 0 3
2079: PUSH
2080: LD_VAR 0 2
2084: PPUSH
2085: LD_INT 2
2087: PUSH
2088: LD_INT 25
2090: PUSH
2091: LD_INT 12
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 25
2100: PUSH
2101: LD_INT 15
2103: PUSH
2104: EMPTY
2105: LIST
2106: LIST
2107: PUSH
2108: LD_INT 25
2110: PUSH
2111: LD_INT 16
2113: PUSH
2114: EMPTY
2115: LIST
2116: LIST
2117: PUSH
2118: LD_INT 25
2120: PUSH
2121: LD_INT 17
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: PUSH
2135: EMPTY
2136: LIST
2137: PPUSH
2138: CALL_OW 72
2142: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
2143: LD_VAR 0 2
2147: PUSH
2148: LD_VAR 0 3
2152: DIFF
2153: PPUSH
2154: CALL_OW 43
// save ;
2158: CALL 1312 0 0
// YouWin ;
2162: CALL_OW 103
// end ;
2166: LD_VAR 0 1
2170: RET
// starting begin RandomizeAll ;
2171: CALL_OW 11
// InitUC ;
2175: CALL_OW 18
// InitBC ;
2179: CALL_OW 21
// InitHC ;
2183: CALL_OW 19
// InitVC ;
2187: CALL_OW 20
// side_Neutral = 0 ;
2191: LD_ADDR_EXP 1
2195: PUSH
2196: LD_INT 0
2198: ST_TO_ADDR
// side_Am = 1 ;
2199: LD_ADDR_EXP 2
2203: PUSH
2204: LD_INT 1
2206: ST_TO_ADDR
// side_Ru = 3 ;
2207: LD_ADDR_EXP 3
2211: PUSH
2212: LD_INT 3
2214: ST_TO_ADDR
// load ;
2215: CALL 304 0 0
// init_difficulty ;
2219: CALL 11933 0 0
// init_suroviny ;
2223: CALL 12628 0 0
// init_nature ;
2227: CALL 17699 0 0
// init_rusove ;
2231: CALL 2248 0 0
// init_amici ;
2235: CALL 5221 0 0
// init_jmm ;
2239: CALL 13078 0 0
// uvod ;
2243: CALL 2539 0 0
// end ; end_of_file
2247: END
// var LabyST ; export ArtefaktMajAmici ; export KdeJeArtefakt ; export AutoSArtefaktem ; export OK_North , OK_East ; export TimeLapser ; var LabySArtefaktem ; var MericiLaborator ; var Slozitost ; export VelikostArtefaktu ; export function init_rusove ; begin
2248: LD_INT 0
2250: PPUSH
// disable ( 1 ) ;
2251: LD_INT 1
2253: DISABLE_MARKED
// disable ( 2 ) ;
2254: LD_INT 2
2256: DISABLE_MARKED
// VelikostArtefaktu = 4 ;
2257: LD_ADDR_EXP 34
2261: PUSH
2262: LD_INT 4
2264: ST_TO_ADDR
// OK_North = 0 ;
2265: LD_ADDR_EXP 31
2269: PUSH
2270: LD_INT 0
2272: ST_TO_ADDR
// OK_East = 0 ;
2273: LD_ADDR_EXP 32
2277: PUSH
2278: LD_INT 0
2280: ST_TO_ADDR
// LabyST = [ ] ;
2281: LD_ADDR_LOC 1
2285: PUSH
2286: EMPTY
2287: ST_TO_ADDR
// KdeJeArtefakt = 0 ;
2288: LD_ADDR_EXP 29
2292: PUSH
2293: LD_INT 0
2295: ST_TO_ADDR
// ArtefaktMajAmici = false ;
2296: LD_ADDR_EXP 28
2300: PUSH
2301: LD_INT 0
2303: ST_TO_ADDR
// AutoSArtefaktem = 0 ;
2304: LD_ADDR_EXP 30
2308: PUSH
2309: LD_INT 0
2311: ST_TO_ADDR
// LabySArtefaktem = [ ] ;
2312: LD_ADDR_LOC 2
2316: PUSH
2317: EMPTY
2318: ST_TO_ADDR
// MericiLaborator = 0 ;
2319: LD_ADDR_LOC 3
2323: PUSH
2324: LD_INT 0
2326: ST_TO_ADDR
// TimeLapser = false ;
2327: LD_ADDR_EXP 33
2331: PUSH
2332: LD_INT 0
2334: ST_TO_ADDR
// Slozitost = dif_ArtefaktDoba [ Difficulty ] ;
2335: LD_ADDR_LOC 4
2339: PUSH
2340: LD_EXP 43
2344: PUSH
2345: LD_OWVAR 67
2349: ARRAY
2350: ST_TO_ADDR
// end ;
2351: LD_VAR 0 1
2355: RET
// function vytvor_nakladak ( Material , Amount ) ; begin
2356: LD_INT 0
2358: PPUSH
// UC_Side = side_Ru ;
2359: LD_ADDR_OWVAR 20
2363: PUSH
2364: LD_EXP 3
2368: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
2369: LD_ADDR_OWVAR 21
2373: PUSH
2374: LD_INT 3
2376: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
2377: LD_ADDR_OWVAR 37
2381: PUSH
2382: LD_INT 21
2384: ST_TO_ADDR
// VC_Control = CONTROL_COMPUTER ;
2385: LD_ADDR_OWVAR 38
2389: PUSH
2390: LD_INT 3
2392: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
2393: LD_ADDR_OWVAR 39
2397: PUSH
2398: LD_INT 3
2400: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
2401: LD_ADDR_OWVAR 40
2405: PUSH
2406: LD_INT 51
2408: ST_TO_ADDR
// Result = CreateVehicle ;
2409: LD_ADDR_VAR 0 3
2413: PUSH
2414: CALL_OW 45
2418: ST_TO_ADDR
// if Amount > 0 then
2419: LD_VAR 0 2
2423: PUSH
2424: LD_INT 0
2426: GREATER
2427: IFFALSE 2448
// SetCargo ( Result , Material , Amount ) ;
2429: LD_VAR 0 3
2433: PPUSH
2434: LD_VAR 0 1
2438: PPUSH
2439: LD_VAR 0 2
2443: PPUSH
2444: CALL_OW 290
// end ;
2448: LD_VAR 0 3
2452: RET
// function vytvor_tank ( Zbran ) ; begin
2453: LD_INT 0
2455: PPUSH
// UC_Side = side_Ru ;
2456: LD_ADDR_OWVAR 20
2460: PUSH
2461: LD_EXP 3
2465: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
2466: LD_ADDR_OWVAR 21
2470: PUSH
2471: LD_INT 3
2473: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
2474: LD_ADDR_OWVAR 37
2478: PUSH
2479: LD_INT 21
2481: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
2482: LD_ADDR_OWVAR 38
2486: PUSH
2487: LD_INT 1
2489: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
2490: LD_ADDR_OWVAR 39
2494: PUSH
2495: LD_INT 1
2497: ST_TO_ADDR
// VC_Weapon = Zbran ;
2498: LD_ADDR_OWVAR 40
2502: PUSH
2503: LD_VAR 0 1
2507: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 70 , 90 ) ;
2508: LD_ADDR_OWVAR 41
2512: PUSH
2513: LD_INT 70
2515: PPUSH
2516: LD_INT 90
2518: PPUSH
2519: CALL_OW 12
2523: ST_TO_ADDR
// Result = CreateVehicle ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: CALL_OW 45
2533: ST_TO_ADDR
// end ;
2534: LD_VAR 0 2
2538: RET
// export function uvod ; var I , Auto ; begin
2539: LD_INT 0
2541: PPUSH
2542: PPUSH
2543: PPUSH
// if Masha then
2544: LD_EXP 23
2548: IFFALSE 2581
// begin PlaceHumanInUnit ( Burlak , Masha ) ;
2550: LD_EXP 4
2554: PPUSH
2555: LD_EXP 23
2559: PPUSH
2560: CALL_OW 52
// PlaceUnitArea ( Masha , Start , false ) ;
2564: LD_EXP 23
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: LD_INT 0
2574: PPUSH
2575: CALL_OW 49
// end else
2579: GO 2623
// begin Auto = vytvor_tank ( RU_GUN ) ;
2581: LD_ADDR_VAR 0 3
2585: PUSH
2586: LD_INT 44
2588: PPUSH
2589: CALL 2453 0 1
2593: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , Auto ) ;
2594: LD_EXP 4
2598: PPUSH
2599: LD_VAR 0 3
2603: PPUSH
2604: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
2608: LD_VAR 0 3
2612: PPUSH
2613: LD_INT 1
2615: PPUSH
2616: LD_INT 0
2618: PPUSH
2619: CALL_OW 49
// end ; PlaceUnitArea ( vytvor_nakladak ( MAT_OIL , 100 ) , Start , false ) ;
2623: LD_INT 2
2625: PPUSH
2626: LD_INT 100
2628: PPUSH
2629: CALL 2356 0 2
2633: PPUSH
2634: LD_INT 1
2636: PPUSH
2637: LD_INT 0
2639: PPUSH
2640: CALL_OW 49
// AutoSArtefaktem = vytvor_nakladak ( MAT_ARTIFACT , VelikostArtefaktu * 10 ) ;
2644: LD_ADDR_EXP 30
2648: PUSH
2649: LD_INT 4
2651: PPUSH
2652: LD_EXP 34
2656: PUSH
2657: LD_INT 10
2659: MUL
2660: PPUSH
2661: CALL 2356 0 2
2665: ST_TO_ADDR
// PlaceUnitArea ( AutoSArtefaktem , Start , false ) ;
2666: LD_EXP 30
2670: PPUSH
2671: LD_INT 1
2673: PPUSH
2674: LD_INT 0
2676: PPUSH
2677: CALL_OW 49
// PlaceUnitArea ( Bystrov , Start , false ) ;
2681: LD_EXP 5
2685: PPUSH
2686: LD_INT 1
2688: PPUSH
2689: LD_INT 0
2691: PPUSH
2692: CALL_OW 49
// for I in Rusove do
2696: LD_ADDR_VAR 0 2
2700: PUSH
2701: LD_EXP 27
2705: PUSH
2706: FOR_IN
2707: IFFALSE 2726
// PlaceUnitArea ( I , Start , false ) ;
2709: LD_VAR 0 2
2713: PPUSH
2714: LD_INT 1
2716: PPUSH
2717: LD_INT 0
2719: PPUSH
2720: CALL_OW 49
2724: GO 2706
2726: POP
2727: POP
// InGameOn ;
2728: CALL_OW 8
// I = IsInUnit ( Burlak ) ;
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_EXP 4
2741: PPUSH
2742: CALL_OW 310
2746: ST_TO_ADDR
// if I then
2747: LD_VAR 0 2
2751: IFFALSE 2764
// CenterNowOnUnits ( I ) else
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 87
2762: GO 2773
// CenterNowOnUnits ( Burlak ) ;
2764: LD_EXP 4
2768: PPUSH
2769: CALL_OW 87
// dialog_Arrival ;
2773: CALL 14867 0 0
// SaveForQuickRestart ;
2777: CALL_OW 22
// ChangeMissionObjectives ( MStart ) ;
2781: LD_STRING MStart
2783: PPUSH
2784: CALL_OW 337
// Hint ( LocateMotherlode ) ;
2788: LD_STRING LocateMotherlode
2790: PPUSH
2791: CALL_OW 339
// InGameOff ;
2795: CALL_OW 9
// end ;
2799: LD_VAR 0 1
2803: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
2804: LD_INT 0
2806: PPUSH
// if Un = Burlak then
2807: LD_VAR 0 1
2811: PUSH
2812: LD_EXP 4
2816: EQUAL
2817: IFFALSE 2828
// begin YouLost ( Burlak ) ;
2819: LD_STRING Burlak
2821: PPUSH
2822: CALL_OW 104
// exit ;
2826: GO 2894
// end ; if Un = AutoSArtefaktem then
2828: LD_VAR 0 1
2832: PUSH
2833: LD_EXP 30
2837: EQUAL
2838: IFFALSE 2859
// begin Wait ( 0 0$1 ) ;
2840: LD_INT 35
2842: PPUSH
2843: CALL_OW 67
// rusove_ArtifactUnloaded ( 0 , VelikostArtefaktu ) ;
2847: LD_INT 0
2849: PPUSH
2850: LD_EXP 34
2854: PPUSH
2855: CALL 4501 0 2
// end ; if Un in LabyST then
2859: LD_VAR 0 1
2863: PUSH
2864: LD_LOC 1
2868: IN
2869: IFFALSE 2894
// begin LabyST = LabyST diff [ Un ] ;
2871: LD_ADDR_LOC 1
2875: PUSH
2876: LD_LOC 1
2880: PUSH
2881: LD_VAR 0 1
2885: PUSH
2886: EMPTY
2887: LIST
2888: DIFF
2889: ST_TO_ADDR
// nastav_artefakt ;
2890: CALL 4876 0 0
// end ; end ;
2894: LD_VAR 0 2
2898: RET
// function je_NW_pulka ( X , Y ) ; begin
2899: LD_INT 0
2901: PPUSH
// X := X - ( Y div 2 ) ;
2902: LD_ADDR_VAR 0 1
2906: PUSH
2907: LD_VAR 0 1
2911: PUSH
2912: LD_VAR 0 2
2916: PUSH
2917: LD_INT 2
2919: DIV
2920: MINUS
2921: ST_TO_ADDR
// Result := ( X + Y ) <= 160 ;
2922: LD_ADDR_VAR 0 3
2926: PUSH
2927: LD_VAR 0 1
2931: PUSH
2932: LD_VAR 0 2
2936: PLUS
2937: PUSH
2938: LD_INT 160
2940: LESSEQUAL
2941: ST_TO_ADDR
// end ;
2942: LD_VAR 0 3
2946: RET
// export function rusove_BuildingStarted ( Bu , Hu ) ; var Typ ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
// if GetSide ( Bu ) <> side_Ru then
2951: LD_VAR 0 1
2955: PPUSH
2956: CALL_OW 255
2960: PUSH
2961: LD_EXP 3
2965: NONEQUAL
2966: IFFALSE 2970
// exit ;
2968: GO 3153
// Typ = GetBType ( Bu ) ;
2970: LD_ADDR_VAR 0 4
2974: PUSH
2975: LD_VAR 0 1
2979: PPUSH
2980: CALL_OW 266
2984: ST_TO_ADDR
// if Typ = B_DEPOT then
2985: LD_VAR 0 4
2989: PUSH
2990: LD_INT 0
2992: EQUAL
2993: IFFALSE 3069
// begin if not IsInArea ( Bu , Base_NDepot ) and not IsInArea ( Bu , Base_EDepot ) then
2995: LD_VAR 0 1
2999: PPUSH
3000: LD_INT 25
3002: PPUSH
3003: CALL_OW 308
3007: NOT
3008: PUSH
3009: LD_VAR 0 1
3013: PPUSH
3014: LD_INT 24
3016: PPUSH
3017: CALL_OW 308
3021: NOT
3022: AND
3023: IFFALSE 3069
// begin DialogueOn ;
3025: CALL_OW 6
// if je_NW_pulka ( GetX ( Bu ) , GetY ( Bu ) ) then
3029: LD_VAR 0 1
3033: PPUSH
3034: CALL_OW 250
3038: PPUSH
3039: LD_VAR 0 1
3043: PPUSH
3044: CALL_OW 251
3048: PPUSH
3049: CALL 2899 0 2
3053: IFFALSE 3061
// dialog_BadBaseN else
3055: CALL 14911 0 0
3059: GO 3065
// dialog_BadBaseE ;
3061: CALL 14942 0 0
// DialogueOff ;
3065: CALL_OW 7
// end ; end ; if Typ = B_LAB then
3069: LD_VAR 0 4
3073: PUSH
3074: LD_INT 6
3076: EQUAL
3077: IFFALSE 3153
// begin if not IsInArea ( Bu , Base_N2 ) and not IsInArea ( Bu , Base_E2 ) then
3079: LD_VAR 0 1
3083: PPUSH
3084: LD_INT 7
3086: PPUSH
3087: CALL_OW 308
3091: NOT
3092: PUSH
3093: LD_VAR 0 1
3097: PPUSH
3098: LD_INT 9
3100: PPUSH
3101: CALL_OW 308
3105: NOT
3106: AND
3107: IFFALSE 3153
// begin DialogueOn ;
3109: CALL_OW 6
// if je_NW_pulka ( GetX ( Bu ) , GetY ( Bu ) ) then
3113: LD_VAR 0 1
3117: PPUSH
3118: CALL_OW 250
3122: PPUSH
3123: LD_VAR 0 1
3127: PPUSH
3128: CALL_OW 251
3132: PPUSH
3133: CALL 2899 0 2
3137: IFFALSE 3145
// dialog_BadLabN else
3139: CALL 14973 0 0
3143: GO 3149
// dialog_BadLabE ;
3145: CALL 15004 0 0
// DialogueOff ;
3149: CALL_OW 7
// end ; end ; end ;
3153: LD_VAR 0 3
3157: RET
// function je_artefakt_v_zakladne ( Lab ) ; var X , Y , Found ; begin
3158: LD_INT 0
3160: PPUSH
3161: PPUSH
3162: PPUSH
3163: PPUSH
// Result = false ;
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_INT 0
3171: ST_TO_ADDR
// if ArtefaktMajAmici then
3172: LD_EXP 28
3176: IFFALSE 3180
// exit ;
3178: GO 3249
// if KdeJeArtefakt = 0 then
3180: LD_EXP 29
3184: PUSH
3185: LD_INT 0
3187: EQUAL
3188: IFFALSE 3192
// exit ;
3190: GO 3249
// X = KdeJeArtefakt [ 1 ] ;
3192: LD_ADDR_VAR 0 3
3196: PUSH
3197: LD_EXP 29
3201: PUSH
3202: LD_INT 1
3204: ARRAY
3205: ST_TO_ADDR
// Y = KdeJeArtefakt [ 2 ] ;
3206: LD_ADDR_VAR 0 4
3210: PUSH
3211: LD_EXP 29
3215: PUSH
3216: LD_INT 2
3218: ARRAY
3219: ST_TO_ADDR
// Result = GetDistUnitXY ( Lab , X , Y ) <= 9 ;
3220: LD_ADDR_VAR 0 2
3224: PUSH
3225: LD_VAR 0 1
3229: PPUSH
3230: LD_VAR 0 3
3234: PPUSH
3235: LD_VAR 0 4
3239: PPUSH
3240: CALL_OW 297
3244: PUSH
3245: LD_INT 9
3247: LESSEQUAL
3248: ST_TO_ADDR
// end ;
3249: LD_VAR 0 2
3253: RET
// function rusove_SpaceTimeHotovo ( Lab ) ; begin
3254: LD_INT 0
3256: PPUSH
// if not je_artefakt_v_zakladne ( Lab ) and ( IsInArea ( Lab , Base_N2 ) or IsInArea ( Lab , Base_E2 ) ) then
3257: LD_VAR 0 1
3261: PPUSH
3262: CALL 3158 0 1
3266: NOT
3267: PUSH
3268: LD_VAR 0 1
3272: PPUSH
3273: LD_INT 7
3275: PPUSH
3276: CALL_OW 308
3280: PUSH
3281: LD_VAR 0 1
3285: PPUSH
3286: LD_INT 9
3288: PPUSH
3289: CALL_OW 308
3293: OR
3294: AND
3295: IFFALSE 3309
// begin DialogueOn ;
3297: CALL_OW 6
// dialog_NoArtefact ;
3301: CALL 15035 0 0
// DialogueOff ;
3305: CALL_OW 7
// end ; end ;
3309: LD_VAR 0 2
3313: RET
// export function rusove_UpgradeComplete ( Build ) ; begin
3314: LD_INT 0
3316: PPUSH
// if ( GetSide ( Build ) = side_Ru ) and ( GetBType ( Build ) in [ B_LAB , B_LAB_HALF , B_LAB_FULL ] ) then
3317: LD_VAR 0 1
3321: PPUSH
3322: CALL_OW 255
3326: PUSH
3327: LD_EXP 3
3331: EQUAL
3332: PUSH
3333: LD_VAR 0 1
3337: PPUSH
3338: CALL_OW 266
3342: PUSH
3343: LD_INT 6
3345: PUSH
3346: LD_INT 7
3348: PUSH
3349: LD_INT 8
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: LIST
3356: IN
3357: AND
3358: IFFALSE 3441
// begin if not Build in LabyST then
3360: LD_VAR 0 1
3364: PUSH
3365: LD_LOC 1
3369: IN
3370: NOT
3371: IFFALSE 3441
// if ( GetLabKind ( Build , 1 ) = B_LAB_SPACETIME ) or ( GetLabKind ( Build , 2 ) = B_LAB_SPACETIME ) then
3373: LD_VAR 0 1
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: CALL_OW 268
3385: PUSH
3386: LD_INT 14
3388: EQUAL
3389: PUSH
3390: LD_VAR 0 1
3394: PPUSH
3395: LD_INT 2
3397: PPUSH
3398: CALL_OW 268
3402: PUSH
3403: LD_INT 14
3405: EQUAL
3406: OR
3407: IFFALSE 3441
// begin rusove_SpaceTimeHotovo ( Build ) ;
3409: LD_VAR 0 1
3413: PPUSH
3414: CALL 3254 0 1
// LabyST = LabyST union [ Build ] ;
3418: LD_ADDR_LOC 1
3422: PUSH
3423: LD_LOC 1
3427: PUSH
3428: LD_VAR 0 1
3432: PUSH
3433: EMPTY
3434: LIST
3435: UNION
3436: ST_TO_ADDR
// nastav_artefakt ;
3437: CALL 4876 0 0
// end ; end ; end ;
3441: LD_VAR 0 2
3445: RET
// export function rusove_ResearchComplete ( Tech , Lab ) ; begin
3446: LD_INT 0
3448: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3449: LD_VAR 0 2
3453: PPUSH
3454: CALL_OW 255
3458: PUSH
3459: LD_EXP 3
3463: NONEQUAL
3464: IFFALSE 3468
// exit ;
3466: GO 3515
// if Tech = TECH_LAPSER then
3468: LD_VAR 0 1
3472: PUSH
3473: LD_INT 31
3475: EQUAL
3476: IFFALSE 3504
// begin DialogueOn ;
3478: CALL_OW 6
// dialog_TimeLapser2 ;
3482: CALL 15176 0 0
// ChangeMissionObjectives ( MTimeLapser ) ;
3486: LD_STRING MTimeLapser
3488: PPUSH
3489: CALL_OW 337
// Hint ( TimeLapser ) ;
3493: LD_STRING TimeLapser
3495: PPUSH
3496: CALL_OW 339
// DialogueOff ;
3500: CALL_OW 7
// end ; Wait ( 0 0$1 ) ;
3504: LD_INT 35
3506: PPUSH
3507: CALL_OW 67
// nastav_artefakt ;
3511: CALL 4876 0 0
// end ;
3515: LD_VAR 0 3
3519: RET
// export function rusove_ResearchStarted ( Tech , Lab ) ; begin
3520: LD_INT 0
3522: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3523: LD_VAR 0 2
3527: PPUSH
3528: CALL_OW 255
3532: PUSH
3533: LD_EXP 3
3537: NONEQUAL
3538: IFFALSE 3542
// exit ;
3540: GO 3546
// nastav_artefakt ;
3542: CALL 4876 0 0
// end ;
3546: LD_VAR 0 3
3550: RET
// export function rusove_ResearchCancel ( Tech , Lab ) ; begin
3551: LD_INT 0
3553: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 255
3563: PUSH
3564: LD_EXP 3
3568: NONEQUAL
3569: IFFALSE 3573
// exit ;
3571: GO 3584
// Wait ( 0 0$0.2 ) ;
3573: LD_INT 7
3575: PPUSH
3576: CALL_OW 67
// nastav_artefakt ;
3580: CALL 4876 0 0
// end ;
3584: LD_VAR 0 3
3588: RET
// export function rusove_SpecResearchCancel ( Lab , Progress ) ; begin
3589: LD_INT 0
3591: PPUSH
// zrus_pouziti_artefaktu ;
3592: CALL 4718 0 0
// Wait ( 0 0$0.2 ) ;
3596: LD_INT 7
3598: PPUSH
3599: CALL_OW 67
// nastav_artefakt ;
3603: CALL 4876 0 0
// end ;
3607: LD_VAR 0 3
3611: RET
// function mereni_complete ( Lab ) ; var OldOKN , OldOKE ; begin
3612: LD_INT 0
3614: PPUSH
3615: PPUSH
3616: PPUSH
// if not je_artefakt_v_zakladne ( Lab ) then
3617: LD_VAR 0 1
3621: PPUSH
3622: CALL 3158 0 1
3626: NOT
3627: IFFALSE 3631
// exit ;
3629: GO 3960
// OldOKN = OK_North ;
3631: LD_ADDR_VAR 0 3
3635: PUSH
3636: LD_EXP 31
3640: ST_TO_ADDR
// OldOKE = OK_East ;
3641: LD_ADDR_VAR 0 4
3645: PUSH
3646: LD_EXP 32
3650: ST_TO_ADDR
// if IsInArea ( Lab , Base_N2 ) then
3651: LD_VAR 0 1
3655: PPUSH
3656: LD_INT 7
3658: PPUSH
3659: CALL_OW 308
3663: IFFALSE 3683
// OK_North = max ( OK_North , 1 ) ;
3665: LD_ADDR_EXP 31
3669: PUSH
3670: LD_EXP 31
3674: PPUSH
3675: LD_INT 1
3677: PPUSH
3678: CALL 15658 0 2
3682: ST_TO_ADDR
// if IsInArea ( Lab , Base_N1 ) then
3683: LD_VAR 0 1
3687: PPUSH
3688: LD_INT 6
3690: PPUSH
3691: CALL_OW 308
3695: IFFALSE 3715
// OK_North = max ( OK_North , 2 ) ;
3697: LD_ADDR_EXP 31
3701: PUSH
3702: LD_EXP 31
3706: PPUSH
3707: LD_INT 2
3709: PPUSH
3710: CALL 15658 0 2
3714: ST_TO_ADDR
// if IsInArea ( Lab , Base_E2 ) then
3715: LD_VAR 0 1
3719: PPUSH
3720: LD_INT 9
3722: PPUSH
3723: CALL_OW 308
3727: IFFALSE 3747
// OK_East = max ( OK_East , 1 ) ;
3729: LD_ADDR_EXP 32
3733: PUSH
3734: LD_EXP 32
3738: PPUSH
3739: LD_INT 1
3741: PPUSH
3742: CALL 15658 0 2
3746: ST_TO_ADDR
// if IsInArea ( Lab , Base_E1 ) then
3747: LD_VAR 0 1
3751: PPUSH
3752: LD_INT 8
3754: PPUSH
3755: CALL_OW 308
3759: IFFALSE 3779
// OK_East = max ( OK_East , 2 ) ;
3761: LD_ADDR_EXP 32
3765: PUSH
3766: LD_EXP 32
3770: PPUSH
3771: LD_INT 2
3773: PPUSH
3774: CALL 15658 0 2
3778: ST_TO_ADDR
// if not OldOKN and OK_North then
3779: LD_VAR 0 3
3783: NOT
3784: PUSH
3785: LD_EXP 31
3789: AND
3790: IFFALSE 3845
// begin DialogueOn ;
3792: CALL_OW 6
// if OK_East then
3796: LD_EXP 32
3800: IFFALSE 3808
// dialog_Done2 else
3802: CALL 15097 0 0
3806: GO 3834
// begin dialog_Done1 ;
3808: CALL 15066 0 0
// if GetTech ( TECH_LAPSER , side_Ru ) <> STATE_RESEARCHED then
3812: LD_INT 31
3814: PPUSH
3815: LD_EXP 3
3819: PPUSH
3820: CALL_OW 321
3824: PUSH
3825: LD_INT 2
3827: NONEQUAL
3828: IFFALSE 3834
// dialog_TimeLapser1 ;
3830: CALL 15128 0 0
// end ; DialogueOff ;
3834: CALL_OW 7
// ChangeMissionObjectives ( MOutNorth ) ;
3838: LD_STRING MOutNorth
3840: PPUSH
3841: CALL_OW 337
// end ; if not OldOKE and OK_East then
3845: LD_VAR 0 4
3849: NOT
3850: PUSH
3851: LD_EXP 32
3855: AND
3856: IFFALSE 3911
// begin DialogueOn ;
3858: CALL_OW 6
// if OK_North then
3862: LD_EXP 31
3866: IFFALSE 3874
// dialog_Done2 else
3868: CALL 15097 0 0
3872: GO 3900
// begin dialog_Done1 ;
3874: CALL 15066 0 0
// if GetTech ( TECH_LAPSER , side_Ru ) <> STATE_RESEARCHED then
3878: LD_INT 31
3880: PPUSH
3881: LD_EXP 3
3885: PPUSH
3886: CALL_OW 321
3890: PUSH
3891: LD_INT 2
3893: NONEQUAL
3894: IFFALSE 3900
// dialog_TimeLapser1 ;
3896: CALL 15128 0 0
// end ; DialogueOff ;
3900: CALL_OW 7
// ChangeMissionObjectives ( MOutEast ) ;
3904: LD_STRING MOutEast
3906: PPUSH
3907: CALL_OW 337
// end ; if not ( OldOKN and OldOKE ) and OK_North and OK_East then
3911: LD_VAR 0 3
3915: PUSH
3916: LD_VAR 0 4
3920: AND
3921: NOT
3922: PUSH
3923: LD_EXP 31
3927: AND
3928: PUSH
3929: LD_EXP 32
3933: AND
3934: IFFALSE 3956
// begin ChangeMissionObjectives ( MFinish ) ;
3936: LD_STRING MFinish
3938: PPUSH
3939: CALL_OW 337
// SetAreaMapShow ( Cil , 1 ) ;
3943: LD_INT 10
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: CALL_OW 424
// enable ( 1 ) ;
3953: LD_INT 1
3955: ENABLE_MARKED
// end ; nastav_artefakt ;
3956: CALL 4876 0 0
// end ;
3960: LD_VAR 0 2
3964: RET
// function postavil_lapser ; begin
3965: LD_INT 0
3967: PPUSH
// if not TimeLapser then
3968: LD_EXP 33
3972: NOT
3973: IFFALSE 3990
// begin TimeLapser = true ;
3975: LD_ADDR_EXP 33
3979: PUSH
3980: LD_INT 1
3982: ST_TO_ADDR
// ChangeMissionObjectives ( MTLOut ) ;
3983: LD_STRING MTLOut
3985: PPUSH
3986: CALL_OW 337
// end ; end ;
3990: LD_VAR 0 1
3994: RET
// export function rusove_VehicleConstructed ( Veh , Fact ) ; begin
3995: LD_INT 0
3997: PPUSH
// if ( GetSide ( Veh ) = side_Ru ) and ( GetWeapon ( Veh ) = RU_TIME_LAPSER ) then
3998: LD_VAR 0 1
4002: PPUSH
4003: CALL_OW 255
4007: PUSH
4008: LD_EXP 3
4012: EQUAL
4013: PUSH
4014: LD_VAR 0 1
4018: PPUSH
4019: CALL_OW 264
4023: PUSH
4024: LD_INT 49
4026: EQUAL
4027: AND
4028: IFFALSE 4034
// postavil_lapser ;
4030: CALL 3965 0 0
// end ;
4034: LD_VAR 0 3
4038: RET
// export function rusove_WeaponPlaced ( Build , Fact ) ; begin
4039: LD_INT 0
4041: PPUSH
// if ( GetSide ( Build ) = side_Ru ) and ( GetBWeapon ( Build ) = RU_TIME_LAPSER ) then
4042: LD_VAR 0 1
4046: PPUSH
4047: CALL_OW 255
4051: PUSH
4052: LD_EXP 3
4056: EQUAL
4057: PUSH
4058: LD_VAR 0 1
4062: PPUSH
4063: CALL_OW 269
4067: PUSH
4068: LD_INT 49
4070: EQUAL
4071: AND
4072: IFFALSE 4078
// postavil_lapser ;
4074: CALL 3965 0 0
// end ;
4078: LD_VAR 0 3
4082: RET
// function zjisti_konec ; var Lidi ; begin
4083: LD_INT 0
4085: PPUSH
4086: PPUSH
// End_The_Mission_Allowed = false ;
4087: LD_ADDR_OWVAR 57
4091: PUSH
4092: LD_INT 0
4094: ST_TO_ADDR
// if not IsInArea ( Burlak , Cil ) then
4095: LD_EXP 4
4099: PPUSH
4100: LD_INT 10
4102: PPUSH
4103: CALL_OW 308
4107: NOT
4108: IFFALSE 4112
// exit ;
4110: GO 4231
// if not AutoSArtefaktem then
4112: LD_EXP 30
4116: NOT
4117: IFFALSE 4121
// exit ;
4119: GO 4231
// if GetSide ( AutoSArtefaktem ) <> side_Ru then
4121: LD_EXP 30
4125: PPUSH
4126: CALL_OW 255
4130: PUSH
4131: LD_EXP 3
4135: NONEQUAL
4136: IFFALSE 4140
// exit ;
4138: GO 4231
// if not IsInArea ( AutoSArtefaktem , Cil ) then
4140: LD_EXP 30
4144: PPUSH
4145: LD_INT 10
4147: PPUSH
4148: CALL_OW 308
4152: NOT
4153: IFFALSE 4157
// exit ;
4155: GO 4231
// Lidi = FilterUnitsExceptArea ( Cil , [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
4157: LD_ADDR_VAR 0 2
4161: PUSH
4162: LD_INT 10
4164: PPUSH
4165: LD_INT 22
4167: PUSH
4168: LD_EXP 3
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PUSH
4177: LD_INT 52
4179: PUSH
4180: EMPTY
4181: LIST
4182: PUSH
4183: LD_INT 50
4185: PUSH
4186: EMPTY
4187: LIST
4188: PUSH
4189: LD_INT 21
4191: PUSH
4192: LD_INT 1
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: LIST
4204: PPUSH
4205: CALL_OW 71
4209: ST_TO_ADDR
// if not Lidi then
4210: LD_VAR 0 2
4214: NOT
4215: IFFALSE 4223
// vyhral else
4217: CALL 2016 0 0
4221: GO 4231
// begin End_The_Mission_Allowed = true ;
4223: LD_ADDR_OWVAR 57
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// end ; end ;
4231: LD_VAR 0 1
4235: RET
// on EndTheMissionRaised ( Unknown ) do var Lidi , I ;
4236: LD_INT 0
4238: PPUSH
4239: PPUSH
// begin Lidi = FilterUnitsExceptArea ( Cil , [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
4240: LD_ADDR_VAR 0 2
4244: PUSH
4245: LD_INT 10
4247: PPUSH
4248: LD_INT 22
4250: PUSH
4251: LD_EXP 3
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: PUSH
4260: LD_INT 52
4262: PUSH
4263: EMPTY
4264: LIST
4265: PUSH
4266: LD_INT 50
4268: PUSH
4269: EMPTY
4270: LIST
4271: PUSH
4272: LD_INT 21
4274: PUSH
4275: LD_INT 1
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: PPUSH
4288: CALL_OW 71
4292: ST_TO_ADDR
// for I in Lidi do
4293: LD_ADDR_VAR 0 3
4297: PUSH
4298: LD_VAR 0 2
4302: PUSH
4303: FOR_IN
4304: IFFALSE 4317
// DestroyUnit ( I ) ;
4306: LD_VAR 0 3
4310: PPUSH
4311: CALL_OW 65
4315: GO 4303
4317: POP
4318: POP
// vyhral ;
4319: CALL 2016 0 0
// end ;
4323: PPOPN 3
4325: END
// every 0 0$4.1 marked 1 do
4326: GO 4328
4328: DISABLE
// begin zjisti_konec ;
4329: CALL 4083 0 0
// enable ;
4333: ENABLE
// end ;
4334: END
// export function rusove_ArtifactLoaded ( Un , Size ) ; begin
4335: LD_INT 0
4337: PPUSH
// zrus_pouziti_artefaktu ;
4338: CALL 4718 0 0
// KdeJeArtefakt = 0 ;
4342: LD_ADDR_EXP 29
4346: PUSH
4347: LD_INT 0
4349: ST_TO_ADDR
// AutoSArtefaktem = Un ;
4350: LD_ADDR_EXP 30
4354: PUSH
4355: LD_VAR 0 1
4359: ST_TO_ADDR
// if GetSide ( Un ) = side_Ru then
4360: LD_VAR 0 1
4364: PPUSH
4365: CALL_OW 255
4369: PUSH
4370: LD_EXP 3
4374: EQUAL
4375: IFFALSE 4387
// ArtefaktMajAmici = false else
4377: LD_ADDR_EXP 28
4381: PUSH
4382: LD_INT 0
4384: ST_TO_ADDR
4385: GO 4407
// begin ArtefaktMajAmici = true ;
4387: LD_ADDR_EXP 28
4391: PUSH
4392: LD_INT 1
4394: ST_TO_ADDR
// DialogueOn ;
4395: CALL_OW 6
// dialog_ArtefactSteal ;
4399: CALL 15248 0 0
// DialogueOff ;
4403: CALL_OW 7
// end ; nastav_artefakt ;
4407: CALL 4876 0 0
// end ;
4411: LD_VAR 0 3
4415: RET
// export function event_ArtefactStolen ; begin
4416: LD_INT 0
4418: PPUSH
// YouLost ( Artefact ) ;
4419: LD_STRING Artefact
4421: PPUSH
4422: CALL_OW 104
// end ;
4426: LD_VAR 0 1
4430: RET
// every 0 0$5.1 trigger ArtefaktMajAmici do
4431: LD_EXP 28
4435: IFFALSE 4500
4437: GO 4439
4439: DISABLE
// begin if IsInArea ( AutoSArtefaktem , AmericaniArtefakt ) then
4440: LD_EXP 30
4444: PPUSH
4445: LD_INT 26
4447: PPUSH
4448: CALL_OW 308
4452: IFFALSE 4460
// event_ArtefactStolen else
4454: CALL 4416 0 0
4458: GO 4499
// begin ComAgressiveMove ( AutoSArtefaktem , 143 , 13 ) ;
4460: LD_EXP 30
4464: PPUSH
4465: LD_INT 143
4467: PPUSH
4468: LD_INT 13
4470: PPUSH
4471: CALL_OW 114
// AddComMoveToArea ( AutoSArtefaktem , AmericaniArtefakt ) ;
4475: LD_EXP 30
4479: PPUSH
4480: LD_INT 26
4482: PPUSH
4483: CALL_OW 173
// AddComSailEvent ( AutoSArtefaktem , 102 ) ;
4487: LD_EXP 30
4491: PPUSH
4492: LD_INT 102
4494: PPUSH
4495: CALL_OW 224
// end ; enable ;
4499: ENABLE
// end ;
4500: END
// export function rusove_ArtifactUnloaded ( Un , Size ) ; var Souradnice ; begin
4501: LD_INT 0
4503: PPUSH
4504: PPUSH
// AutoSArtefaktem = 0 ;
4505: LD_ADDR_EXP 30
4509: PUSH
4510: LD_INT 0
4512: ST_TO_ADDR
// ArtefaktMajAmici = false ;
4513: LD_ADDR_EXP 28
4517: PUSH
4518: LD_INT 0
4520: ST_TO_ADDR
// Souradnice = FindArtifact ( VelikostArtefaktu ) ;
4521: LD_ADDR_VAR 0 4
4525: PUSH
4526: LD_EXP 34
4530: PPUSH
4531: CALL_OW 469
4535: ST_TO_ADDR
// KdeJeArtefakt = [ Souradnice [ 1 ] , Souradnice [ 2 ] ] ;
4536: LD_ADDR_EXP 29
4540: PUSH
4541: LD_VAR 0 4
4545: PUSH
4546: LD_INT 1
4548: ARRAY
4549: PUSH
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 2
4557: ARRAY
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: ST_TO_ADDR
// nastav_artefakt ;
4563: CALL 4876 0 0
// end ;
4567: LD_VAR 0 3
4571: RET
// function je_lab ( Lab ) ; begin
4572: LD_INT 0
4574: PPUSH
// Result = GetBType ( Lab ) in [ B_LAB , B_LAB_HALF , B_LAB_FULL ] ;
4575: LD_ADDR_VAR 0 2
4579: PUSH
4580: LD_VAR 0 1
4584: PPUSH
4585: CALL_OW 266
4589: PUSH
4590: LD_INT 6
4592: PUSH
4593: LD_INT 7
4595: PUSH
4596: LD_INT 8
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: LIST
4603: IN
4604: ST_TO_ADDR
// end ;
4605: LD_VAR 0 2
4609: RET
// function muze_pouzit_artefakt ( Lab ) ; begin
4610: LD_INT 0
4612: PPUSH
// Result = false ;
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_INT 0
4620: ST_TO_ADDR
// if not IsInArea ( Lab , Base_N2 ) and not IsInArea ( Lab , Base_E2 ) then
4621: LD_VAR 0 1
4625: PPUSH
4626: LD_INT 7
4628: PPUSH
4629: CALL_OW 308
4633: NOT
4634: PUSH
4635: LD_VAR 0 1
4639: PPUSH
4640: LD_INT 9
4642: PPUSH
4643: CALL_OW 308
4647: NOT
4648: AND
4649: IFFALSE 4653
// exit ;
4651: GO 4713
// if not je_artefakt_v_zakladne ( Lab ) then
4653: LD_VAR 0 1
4657: PPUSH
4658: CALL 3158 0 1
4662: NOT
4663: IFFALSE 4667
// exit ;
4665: GO 4713
// if ( GetLabKind ( Lab , 1 ) <> B_LAB_SPACETIME ) and ( GetLabKind ( Lab , 2 ) <> B_LAB_SPACETIME ) then
4667: LD_VAR 0 1
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: CALL_OW 268
4679: PUSH
4680: LD_INT 14
4682: NONEQUAL
4683: PUSH
4684: LD_VAR 0 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 268
4696: PUSH
4697: LD_INT 14
4699: NONEQUAL
4700: AND
4701: IFFALSE 4705
// exit ;
4703: GO 4713
// Result = true ;
4705: LD_ADDR_VAR 0 2
4709: PUSH
4710: LD_INT 1
4712: ST_TO_ADDR
// end ;
4713: LD_VAR 0 2
4717: RET
// function zrus_pouziti_artefaktu ; begin
4718: LD_INT 0
4720: PPUSH
// SetNoActivity ( MericiLaborator ) ;
4721: LD_LOC 3
4725: PPUSH
4726: CALL_OW 487
// MericiLaborator = 0 ;
4730: LD_ADDR_LOC 3
4734: PUSH
4735: LD_INT 0
4737: ST_TO_ADDR
// end ;
4738: LD_VAR 0 1
4742: RET
// export function rusove_SpecResearchComplete ( Lab ) ; begin
4743: LD_INT 0
4745: PPUSH
// mereni_complete ( MericiLaborator ) ;
4746: LD_LOC 3
4750: PPUSH
4751: CALL 3612 0 1
// zrus_pouziti_artefaktu ;
4755: CALL 4718 0 0
// nastav_artefakt ;
4759: CALL 4876 0 0
// end ;
4763: LD_VAR 0 2
4767: RET
// export function rusove_ArtifactUsed ( Side , Number , P1 , P2 ) ; var Lab ; begin
4768: LD_INT 0
4770: PPUSH
4771: PPUSH
// if Side <> side_Ru then
4772: LD_VAR 0 1
4776: PUSH
4777: LD_EXP 3
4781: NONEQUAL
4782: IFFALSE 4786
// exit ;
4784: GO 4840
// if not LabySArtefaktem then
4786: LD_LOC 2
4790: NOT
4791: IFFALSE 4795
// exit ;
4793: GO 4840
// Lab = LabySArtefaktem [ 1 ] ;
4795: LD_ADDR_VAR 0 6
4799: PUSH
4800: LD_LOC 2
4804: PUSH
4805: LD_INT 1
4807: ARRAY
4808: ST_TO_ADDR
// MericiLaborator = Lab ;
4809: LD_ADDR_LOC 3
4813: PUSH
4814: LD_VAR 0 6
4818: ST_TO_ADDR
// SetSpecResearch ( Lab , Slozitost , true ) ;
4819: LD_VAR 0 6
4823: PPUSH
4824: LD_LOC 4
4828: PPUSH
4829: LD_INT 1
4831: PPUSH
4832: CALL_OW 486
// nastav_artefakt ;
4836: CALL 4876 0 0
// end ;
4840: LD_VAR 0 5
4844: RET
// function nastav_pouziti ( Jak , Lab ) ; var L ; begin
4845: LD_INT 0
4847: PPUSH
4848: PPUSH
// SetArtifactUse ( side_Ru , ART_USE_EYE , Jak , Lab ) ;
4849: LD_EXP 3
4853: PPUSH
4854: LD_INT 4
4856: PPUSH
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_VAR 0 2
4866: PPUSH
4867: CALL_OW 468
// end ;
4871: LD_VAR 0 3
4875: RET
// function nastav_artefakt ; var L ; begin
4876: LD_INT 0
4878: PPUSH
4879: PPUSH
// if MericiLaborator then
4880: LD_LOC 3
4884: IFFALSE 4917
// begin for L in LabySArtefaktem do
4886: LD_ADDR_VAR 0 2
4890: PUSH
4891: LD_LOC 2
4895: PUSH
4896: FOR_IN
4897: IFFALSE 4913
// nastav_pouziti ( ART_GRAY , L ) end else
4899: LD_INT 1
4901: PPUSH
4902: LD_VAR 0 2
4906: PPUSH
4907: CALL 4845 0 2
4911: GO 4896
4913: POP
4914: POP
4915: GO 5152
// begin for L in LabySArtefaktem do
4917: LD_ADDR_VAR 0 2
4921: PUSH
4922: LD_LOC 2
4926: PUSH
4927: FOR_IN
4928: IFFALSE 4944
// nastav_pouziti ( ART_NO , L ) ;
4930: LD_INT 0
4932: PPUSH
4933: LD_VAR 0 2
4937: PPUSH
4938: CALL 4845 0 2
4942: GO 4927
4944: POP
4945: POP
// LabySArtefaktem = [ ] ;
4946: LD_ADDR_LOC 2
4950: PUSH
4951: EMPTY
4952: ST_TO_ADDR
// if KdeJeArtefakt then
4953: LD_EXP 29
4957: IFFALSE 5079
// begin for L in LabyST do
4959: LD_ADDR_VAR 0 2
4963: PUSH
4964: LD_LOC 1
4968: PUSH
4969: FOR_IN
4970: IFFALSE 5004
// if muze_pouzit_artefakt ( L ) then
4972: LD_VAR 0 2
4976: PPUSH
4977: CALL 4610 0 1
4981: IFFALSE 5002
// LabySArtefaktem = LabySArtefaktem union [ L ] ;
4983: LD_ADDR_LOC 2
4987: PUSH
4988: LD_LOC 2
4992: PUSH
4993: LD_VAR 0 2
4997: PUSH
4998: EMPTY
4999: LIST
5000: UNION
5001: ST_TO_ADDR
5002: GO 4969
5004: POP
5005: POP
// if ( LabySArtefaktem > 1 ) then
5006: LD_LOC 2
5010: PUSH
5011: LD_INT 1
5013: GREATER
5014: IFFALSE 5077
// begin L = NearestUnitToXY ( LabySArtefaktem , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
5016: LD_ADDR_VAR 0 2
5020: PUSH
5021: LD_LOC 2
5025: PPUSH
5026: LD_EXP 29
5030: PUSH
5031: LD_INT 1
5033: ARRAY
5034: PPUSH
5035: LD_EXP 29
5039: PUSH
5040: LD_INT 2
5042: ARRAY
5043: PPUSH
5044: CALL_OW 73
5048: ST_TO_ADDR
// if L then
5049: LD_VAR 0 2
5053: IFFALSE 5070
// LabySArtefaktem = [ L ] else
5055: LD_ADDR_LOC 2
5059: PUSH
5060: LD_VAR 0 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: ST_TO_ADDR
5068: GO 5077
// LabySArtefaktem = [ ] ;
5070: LD_ADDR_LOC 2
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// end ; end else
5077: GO 5086
// LabySArtefaktem = [ ] ;
5079: LD_ADDR_LOC 2
5083: PUSH
5084: EMPTY
5085: ST_TO_ADDR
// if LabySArtefaktem then
5086: LD_LOC 2
5090: IFFALSE 5148
// begin for L in LabySArtefaktem do
5092: LD_ADDR_VAR 0 2
5096: PUSH
5097: LD_LOC 2
5101: PUSH
5102: FOR_IN
5103: IFFALSE 5144
// if GetActResearch ( L ) then
5105: LD_VAR 0 2
5109: PPUSH
5110: CALL_OW 485
5114: IFFALSE 5130
// nastav_pouziti ( ART_GRAY , L ) else
5116: LD_INT 1
5118: PPUSH
5119: LD_VAR 0 2
5123: PPUSH
5124: CALL 4845 0 2
5128: GO 5142
// nastav_pouziti ( ART_INSTANT , L ) ;
5130: LD_INT 2
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL 4845 0 2
5142: GO 5102
5144: POP
5145: POP
// end else
5146: GO 5152
// zrus_pouziti_artefaktu ;
5148: CALL 4718 0 0
// end ; end ;
5152: LD_VAR 0 1
5156: RET
// export function rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
5157: LD_INT 0
5159: PPUSH
// if Masha = VehOld then
5160: LD_EXP 23
5164: PUSH
5165: LD_VAR 0 2
5169: EQUAL
5170: IFFALSE 5182
// Masha = VehNew ;
5172: LD_ADDR_EXP 23
5176: PUSH
5177: LD_VAR 0 1
5181: ST_TO_ADDR
// if VehOld = AutoSArtefaktem then
5182: LD_VAR 0 2
5186: PUSH
5187: LD_EXP 30
5191: EQUAL
5192: IFFALSE 5216
// begin AutoSArtefaktem = VehNew ;
5194: LD_ADDR_EXP 30
5198: PUSH
5199: LD_VAR 0 1
5203: ST_TO_ADDR
// rusove_ArtifactLoaded ( VehNew , 0 ) ;
5204: LD_VAR 0 1
5208: PPUSH
5209: LD_INT 0
5211: PPUSH
5212: CALL 4335 0 2
// end ; end ; end_of_file
5216: LD_VAR 0 5
5220: RET
// var AmSci1 , AmSci2 , AmSci3 , AmSci4 ; var AmMech1 , AmMech2 , AmMech3 , AmMech4 ; var AmEng1 , AmEng2 ; var AmEng_Oil , AmEng_Sib ; var Obranci , Obranci_Oil , Obranci_Sib ; var Patrola ; var Konvoj , Doprovod ; var Tanky ; var Max_Tanky , Max_Doprovod ; var Kradenik ; var MamKontrolovatVyrobu ; var VyrobenoAut ; var ProbihaPrevoz ; var PrevozNalozil , PrevozVylozil ; var VidelRusa ; var ProbihaUtok ; var CisloUtoku ; var PrvniUtok ; var ZacalyUtoky ; var Utok_ZbyvaMinut ; var CasyUtoku ; var Utok_Auta ; var KdoLeci ; var KdoOpravuje ; var ZnicenOil , ZnicenSib ; var KonvojBylRozebran ; var RozebratAuta ; var RegUtok , RegPatrola ; var MakroObrana , MakroUtok , MakroUtokMove ; var MakroPatrola ; var MakroPrevoz ; export function init_amici ; var Base , Reg ; begin
5221: LD_INT 0
5223: PPUSH
5224: PPUSH
5225: PPUSH
// disable ( 21 ) ;
5226: LD_INT 21
5228: DISABLE_MARKED
// disable ( 22 ) ;
5229: LD_INT 22
5231: DISABLE_MARKED
// RevealFogArea ( side_Am , Americani ) ;
5232: LD_EXP 2
5236: PPUSH
5237: LD_INT 2
5239: PPUSH
5240: CALL_OW 332
// RevealFogArea ( side_Am , Americani_Oil ) ;
5244: LD_EXP 2
5248: PPUSH
5249: LD_INT 19
5251: PPUSH
5252: CALL_OW 332
// RevealFogArea ( side_Am , Americani_Sib ) ;
5256: LD_EXP 2
5260: PPUSH
5261: LD_INT 20
5263: PPUSH
5264: CALL_OW 332
// PrvniUtok = dif_PrvniUtok [ Difficulty ] ;
5268: LD_ADDR_LOC 35
5272: PUSH
5273: LD_EXP 41
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
5284: LD_ADDR_LOC 38
5288: PUSH
5289: LD_EXP 42
5293: PUSH
5294: LD_OWVAR 67
5298: ARRAY
5299: ST_TO_ADDR
// vytvor_postavy ;
5300: CALL 5818 0 0
// Kradenik = 0 ;
5304: LD_ADDR_LOC 26
5308: PUSH
5309: LD_INT 0
5311: ST_TO_ADDR
// Tanky = [ ] ;
5312: LD_ADDR_LOC 23
5316: PUSH
5317: EMPTY
5318: ST_TO_ADDR
// Konvoj = [ ] ;
5319: LD_ADDR_LOC 21
5323: PUSH
5324: EMPTY
5325: ST_TO_ADDR
// Doprovod = [ ] ;
5326: LD_ADDR_LOC 22
5330: PUSH
5331: EMPTY
5332: ST_TO_ADDR
// Max_Tanky = 7 ;
5333: LD_ADDR_LOC 24
5337: PUSH
5338: LD_INT 7
5340: ST_TO_ADDR
// Max_Doprovod = 2 ;
5341: LD_ADDR_LOC 25
5345: PUSH
5346: LD_INT 2
5348: ST_TO_ADDR
// ProbihaPrevoz = 0 ;
5349: LD_ADDR_LOC 29
5353: PUSH
5354: LD_INT 0
5356: ST_TO_ADDR
// VidelRusa = false ;
5357: LD_ADDR_LOC 32
5361: PUSH
5362: LD_INT 0
5364: ST_TO_ADDR
// ZacalyUtoky = false ;
5365: LD_ADDR_LOC 36
5369: PUSH
5370: LD_INT 0
5372: ST_TO_ADDR
// ProbihaUtok = false ;
5373: LD_ADDR_LOC 33
5377: PUSH
5378: LD_INT 0
5380: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
5381: LD_ADDR_LOC 37
5385: PUSH
5386: LD_INT 1
5388: NEG
5389: ST_TO_ADDR
// CisloUtoku = 1 ;
5390: LD_ADDR_LOC 34
5394: PUSH
5395: LD_INT 1
5397: ST_TO_ADDR
// Utok_Auta = [ ] ;
5398: LD_ADDR_LOC 39
5402: PUSH
5403: EMPTY
5404: ST_TO_ADDR
// KdoLeci = [ ] ;
5405: LD_ADDR_LOC 40
5409: PUSH
5410: EMPTY
5411: ST_TO_ADDR
// KdoOpravuje = [ ] ;
5412: LD_ADDR_LOC 41
5416: PUSH
5417: EMPTY
5418: ST_TO_ADDR
// ZnicenOil = false ;
5419: LD_ADDR_LOC 42
5423: PUSH
5424: LD_INT 0
5426: ST_TO_ADDR
// ZnicenSib = false ;
5427: LD_ADDR_LOC 43
5431: PUSH
5432: LD_INT 0
5434: ST_TO_ADDR
// KonvojBylRozebran = false ;
5435: LD_ADDR_LOC 44
5439: PUSH
5440: LD_INT 0
5442: ST_TO_ADDR
// RozebratAuta = false ;
5443: LD_ADDR_LOC 45
5447: PUSH
5448: LD_INT 0
5450: ST_TO_ADDR
// MamKontrolovatVyrobu = false ;
5451: LD_ADDR_LOC 27
5455: PUSH
5456: LD_INT 0
5458: ST_TO_ADDR
// VyrobenoAut = 0 ;
5459: LD_ADDR_LOC 28
5463: PUSH
5464: LD_INT 0
5466: ST_TO_ADDR
// sur ( AmDepot , 500 , 280 , 250 ) ;
5467: LD_INT 15
5469: PPUSH
5470: LD_INT 500
5472: PPUSH
5473: LD_INT 280
5475: PPUSH
5476: LD_INT 250
5478: PPUSH
5479: CALL 6801 0 4
// sur ( AmDepot_Oil , 180 - Difficulty * 30 , 50 , 0 ) ;
5483: LD_INT 1
5485: PPUSH
5486: LD_INT 180
5488: PUSH
5489: LD_OWVAR 67
5493: PUSH
5494: LD_INT 30
5496: MUL
5497: MINUS
5498: PPUSH
5499: LD_INT 50
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL 6801 0 4
// sur ( AmDepot_Sib , 180 - Difficulty * 30 , 30 , 50 ) ;
5509: LD_INT 3
5511: PPUSH
5512: LD_INT 180
5514: PUSH
5515: LD_OWVAR 67
5519: PUSH
5520: LD_INT 30
5522: MUL
5523: MINUS
5524: PPUSH
5525: LD_INT 30
5527: PPUSH
5528: LD_INT 50
5530: PPUSH
5531: CALL 6801 0 4
// zacni_zkoumat ;
5535: CALL 6561 0 0
// zacni_vyrabet ;
5539: CALL 6739 0 0
// if Obranci_Oil then
5543: LD_LOC 18
5547: IFFALSE 5596
// begin Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , Americani_Oil ] ] ) ;
5549: LD_ADDR_VAR 0 3
5553: PUSH
5554: LD_EXP 2
5558: PPUSH
5559: LD_INT 3
5561: PUSH
5562: LD_INT 19
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: EMPTY
5570: LIST
5571: PPUSH
5572: CALL_OW 399
5576: ST_TO_ADDR
// McDefend ( 1 , Reg , Obranci_Oil , [ ] ) ;
5577: LD_INT 1
5579: PPUSH
5580: LD_VAR 0 3
5584: PPUSH
5585: LD_LOC 18
5589: PPUSH
5590: EMPTY
5591: PPUSH
5592: CALL_OW 401
// end ; if Obranci_Sib then
5596: LD_LOC 19
5600: IFFALSE 5649
// begin Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , Americani_Sib ] ] ) ;
5602: LD_ADDR_VAR 0 3
5606: PUSH
5607: LD_EXP 2
5611: PPUSH
5612: LD_INT 3
5614: PUSH
5615: LD_INT 20
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: EMPTY
5623: LIST
5624: PPUSH
5625: CALL_OW 399
5629: ST_TO_ADDR
// McDefend ( 1 , Reg , Obranci_Sib , [ ] ) ;
5630: LD_INT 1
5632: PPUSH
5633: LD_VAR 0 3
5637: PPUSH
5638: LD_LOC 19
5642: PPUSH
5643: EMPTY
5644: PPUSH
5645: CALL_OW 401
// end ; RegUtok = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_GUARD , AreaUtok ] , MC_REG_IGNORE_FOG ] ) ;
5649: LD_ADDR_LOC 46
5653: PUSH
5654: LD_EXP 2
5658: PPUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 21
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: LD_INT 7
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: PPUSH
5676: CALL_OW 399
5680: ST_TO_ADDR
// RegPatrola = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_GUARD , AreaUtok ] , - MC_REG_ONLY_IMPORTANT ] ) ;
5681: LD_ADDR_LOC 47
5685: PUSH
5686: LD_EXP 2
5690: PPUSH
5691: LD_INT 2
5693: PUSH
5694: LD_INT 21
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 8
5703: NEG
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PPUSH
5709: CALL_OW 399
5713: ST_TO_ADDR
// Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , AmericaniObrana ] ] ) ;
5714: LD_ADDR_VAR 0 3
5718: PUSH
5719: LD_EXP 2
5723: PPUSH
5724: LD_INT 3
5726: PUSH
5727: LD_INT 23
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PUSH
5734: EMPTY
5735: LIST
5736: PPUSH
5737: CALL_OW 399
5741: ST_TO_ADDR
// MakroObrana = McDefend ( 2 , Reg , Tanky union Obranci , [ [ MC_AREA_DONT_LEAVE , Americani ] ] ) ;
5742: LD_ADDR_LOC 48
5746: PUSH
5747: LD_INT 2
5749: PPUSH
5750: LD_VAR 0 3
5754: PPUSH
5755: LD_LOC 23
5759: PUSH
5760: LD_LOC 17
5764: UNION
5765: PPUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 2
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: PPUSH
5779: CALL_OW 401
5783: ST_TO_ADDR
// MakroPatrola = McPatrol ( 100 , RegPatrola , Patrola , [ MC_NO_STOP ] ) ;
5784: LD_ADDR_LOC 51
5788: PUSH
5789: LD_INT 100
5791: PPUSH
5792: LD_LOC 47
5796: PPUSH
5797: LD_LOC 20
5801: PPUSH
5802: LD_INT 10
5804: PUSH
5805: EMPTY
5806: LIST
5807: PPUSH
5808: CALL_OW 403
5812: ST_TO_ADDR
// end ;
5813: LD_VAR 0 1
5817: RET
// function vytvor_postavy ; begin
5818: LD_INT 0
5820: PPUSH
// AmSci1 = vytvor_postavu_B ( AmLabWS , CLASS_SCIENTISTIC ) ;
5821: LD_ADDR_LOC 5
5825: PUSH
5826: LD_INT 24
5828: PPUSH
5829: LD_INT 4
5831: PPUSH
5832: CALL 6417 0 2
5836: ST_TO_ADDR
// AmSci2 = vytvor_postavu_B ( AmLabWS , CLASS_SCIENTISTIC ) ;
5837: LD_ADDR_LOC 6
5841: PUSH
5842: LD_INT 24
5844: PPUSH
5845: LD_INT 4
5847: PPUSH
5848: CALL 6417 0 2
5852: ST_TO_ADDR
// AmSci3 = vytvor_postavu_B ( AmLabCO , CLASS_SCIENTISTIC ) ;
5853: LD_ADDR_LOC 7
5857: PUSH
5858: LD_INT 25
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL 6417 0 2
5868: ST_TO_ADDR
// AmSci4 = vytvor_postavu_B ( AmLabCO , CLASS_SCIENTISTIC ) ;
5869: LD_ADDR_LOC 8
5873: PUSH
5874: LD_INT 25
5876: PPUSH
5877: LD_INT 4
5879: PPUSH
5880: CALL 6417 0 2
5884: ST_TO_ADDR
// AmMech1 = vytvor_postavu_B ( AmFactGun , CLASS_MECHANIC ) ;
5885: LD_ADDR_LOC 9
5889: PUSH
5890: LD_INT 30
5892: PPUSH
5893: LD_INT 3
5895: PPUSH
5896: CALL 6417 0 2
5900: ST_TO_ADDR
// AmMech2 = vytvor_postavu_B ( AmFactGun , CLASS_MECHANIC ) ;
5901: LD_ADDR_LOC 10
5905: PUSH
5906: LD_INT 30
5908: PPUSH
5909: LD_INT 3
5911: PPUSH
5912: CALL 6417 0 2
5916: ST_TO_ADDR
// AmMech3 = vytvor_postavu_B ( AmFactRock , CLASS_MECHANIC ) ;
5917: LD_ADDR_LOC 11
5921: PUSH
5922: LD_INT 26
5924: PPUSH
5925: LD_INT 3
5927: PPUSH
5928: CALL 6417 0 2
5932: ST_TO_ADDR
// AmMech4 = vytvor_postavu_B ( AmFactRock , CLASS_MECHANIC ) ;
5933: LD_ADDR_LOC 12
5937: PUSH
5938: LD_INT 26
5940: PPUSH
5941: LD_INT 3
5943: PPUSH
5944: CALL 6417 0 2
5948: ST_TO_ADDR
// AmEng1 = vytvor_postavu_A ( Americani , CLASS_ENGINEER ) ;
5949: LD_ADDR_LOC 13
5953: PUSH
5954: LD_INT 2
5956: PPUSH
5957: LD_INT 2
5959: PPUSH
5960: CALL 6454 0 2
5964: ST_TO_ADDR
// AmEng2 = vytvor_postavu_A ( Americani , CLASS_ENGINEER ) ;
5965: LD_ADDR_LOC 14
5969: PUSH
5970: LD_INT 2
5972: PPUSH
5973: LD_INT 2
5975: PPUSH
5976: CALL 6454 0 2
5980: ST_TO_ADDR
// AmEng_Oil = vytvor_postavu_B ( AmDepot_Oil , CLASS_ENGINEER ) ;
5981: LD_ADDR_LOC 15
5985: PUSH
5986: LD_INT 1
5988: PPUSH
5989: LD_INT 2
5991: PPUSH
5992: CALL 6417 0 2
5996: ST_TO_ADDR
// AmEng_Sib = vytvor_postavu_B ( AmDepot_Sib , CLASS_ENGINEER ) ;
5997: LD_ADDR_LOC 16
6001: PUSH
6002: LD_INT 3
6004: PPUSH
6005: LD_INT 2
6007: PPUSH
6008: CALL 6417 0 2
6012: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 8 , Americani , CLASS_SOLDIER ) union vytvor_postavy_A ( 2 , Americani , CLASS_SNIPER ) ;
6013: LD_ADDR_LOC 17
6017: PUSH
6018: LD_INT 8
6020: PPUSH
6021: LD_INT 2
6023: PPUSH
6024: LD_INT 1
6026: PPUSH
6027: CALL 6494 0 3
6031: PUSH
6032: LD_INT 2
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: LD_INT 5
6040: PPUSH
6041: CALL 6494 0 3
6045: UNION
6046: ST_TO_ADDR
// Patrola = vytvor_postavy_A ( Difficulty + 2 , Americani , CLASS_SOLDIER ) ;
6047: LD_ADDR_LOC 20
6051: PUSH
6052: LD_OWVAR 67
6056: PUSH
6057: LD_INT 2
6059: PLUS
6060: PPUSH
6061: LD_INT 2
6063: PPUSH
6064: LD_INT 1
6066: PPUSH
6067: CALL 6494 0 3
6071: ST_TO_ADDR
// Obranci_Oil = vytvor_postavy_A ( Difficulty - 1 , Americani_Oil , CLASS_SOLDIER ) ;
6072: LD_ADDR_LOC 18
6076: PUSH
6077: LD_OWVAR 67
6081: PUSH
6082: LD_INT 1
6084: MINUS
6085: PPUSH
6086: LD_INT 19
6088: PPUSH
6089: LD_INT 1
6091: PPUSH
6092: CALL 6494 0 3
6096: ST_TO_ADDR
// Obranci_Sib = vytvor_postavy_A ( Difficulty - 1 , Americani_Sib , CLASS_SOLDIER ) ;
6097: LD_ADDR_LOC 19
6101: PUSH
6102: LD_OWVAR 67
6106: PUSH
6107: LD_INT 1
6109: MINUS
6110: PPUSH
6111: LD_INT 20
6113: PPUSH
6114: LD_INT 1
6116: PPUSH
6117: CALL 6494 0 3
6121: ST_TO_ADDR
// end ;
6122: LD_VAR 0 1
6126: RET
// function zpet_domu ( Kdo ) ; begin
6127: LD_INT 0
6129: PPUSH
// if Kdo = AmSci1 then
6130: LD_VAR 0 1
6134: PUSH
6135: LD_LOC 5
6139: EQUAL
6140: IFFALSE 6156
// AddComEnterUnit ( Kdo , AmLabWS ) else
6142: LD_VAR 0 1
6146: PPUSH
6147: LD_INT 24
6149: PPUSH
6150: CALL_OW 180
6154: GO 6336
// if Kdo = AmSci2 then
6156: LD_VAR 0 1
6160: PUSH
6161: LD_LOC 6
6165: EQUAL
6166: IFFALSE 6182
// AddComEnterUnit ( Kdo , AmLabWS ) else
6168: LD_VAR 0 1
6172: PPUSH
6173: LD_INT 24
6175: PPUSH
6176: CALL_OW 180
6180: GO 6336
// if Kdo = AmSci3 then
6182: LD_VAR 0 1
6186: PUSH
6187: LD_LOC 7
6191: EQUAL
6192: IFFALSE 6208
// AddComEnterUnit ( Kdo , AmLabCO ) else
6194: LD_VAR 0 1
6198: PPUSH
6199: LD_INT 25
6201: PPUSH
6202: CALL_OW 180
6206: GO 6336
// if Kdo = AmSci4 then
6208: LD_VAR 0 1
6212: PUSH
6213: LD_LOC 8
6217: EQUAL
6218: IFFALSE 6234
// AddComEnterUnit ( Kdo , AmLabCO ) else
6220: LD_VAR 0 1
6224: PPUSH
6225: LD_INT 25
6227: PPUSH
6228: CALL_OW 180
6232: GO 6336
// if Kdo = AmMech1 then
6234: LD_VAR 0 1
6238: PUSH
6239: LD_LOC 9
6243: EQUAL
6244: IFFALSE 6260
// AddComEnterUnit ( Kdo , AmFactGun ) else
6246: LD_VAR 0 1
6250: PPUSH
6251: LD_INT 30
6253: PPUSH
6254: CALL_OW 180
6258: GO 6336
// if Kdo = AmMech2 then
6260: LD_VAR 0 1
6264: PUSH
6265: LD_LOC 10
6269: EQUAL
6270: IFFALSE 6286
// AddComEnterUnit ( Kdo , AmFactGun ) else
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 30
6279: PPUSH
6280: CALL_OW 180
6284: GO 6336
// if Kdo = AmMech3 then
6286: LD_VAR 0 1
6290: PUSH
6291: LD_LOC 11
6295: EQUAL
6296: IFFALSE 6312
// AddComEnterUnit ( Kdo , AmFactRock ) else
6298: LD_VAR 0 1
6302: PPUSH
6303: LD_INT 26
6305: PPUSH
6306: CALL_OW 180
6310: GO 6336
// if Kdo = AmMech4 then
6312: LD_VAR 0 1
6316: PUSH
6317: LD_LOC 12
6321: EQUAL
6322: IFFALSE 6336
// AddComEnterUnit ( Kdo , AmFactRock ) ;
6324: LD_VAR 0 1
6328: PPUSH
6329: LD_INT 26
6331: PPUSH
6332: CALL_OW 180
// end ;
6336: LD_VAR 0 2
6340: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
6341: LD_INT 0
6343: PPUSH
6344: PPUSH
6345: PPUSH
// UC_Side = side_Am ;
6346: LD_ADDR_OWVAR 20
6350: PUSH
6351: LD_EXP 2
6355: ST_TO_ADDR
// UC_Nation = NATION_AMERICAN ;
6356: LD_ADDR_OWVAR 21
6360: PUSH
6361: LD_INT 1
6363: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
6364: LD_ADDR_OWVAR 27
6368: PUSH
6369: LD_INT 1
6371: PPUSH
6372: LD_INT 2
6374: PPUSH
6375: CALL_OW 12
6379: ST_TO_ADDR
// HC_Class = Cls ;
6380: LD_ADDR_OWVAR 28
6384: PUSH
6385: LD_VAR 0 1
6389: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
6390: LD_VAR 0 1
6394: PPUSH
6395: LD_INT 7
6397: PPUSH
6398: CALL_OW 374
// Result = CreateHuman ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: CALL_OW 44
6411: ST_TO_ADDR
// end ;
6412: LD_VAR 0 2
6416: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
6417: LD_INT 0
6419: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6420: LD_ADDR_VAR 0 3
6424: PUSH
6425: LD_VAR 0 2
6429: PPUSH
6430: CALL 6341 0 1
6434: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
6435: LD_VAR 0 3
6439: PPUSH
6440: LD_VAR 0 1
6444: PPUSH
6445: CALL_OW 52
// end ;
6449: LD_VAR 0 3
6453: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
6454: LD_INT 0
6456: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6457: LD_ADDR_VAR 0 3
6461: PUSH
6462: LD_VAR 0 2
6466: PPUSH
6467: CALL 6341 0 1
6471: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
6472: LD_VAR 0 3
6476: PPUSH
6477: LD_VAR 0 1
6481: PPUSH
6482: LD_INT 0
6484: PPUSH
6485: CALL_OW 49
// end ;
6489: LD_VAR 0 3
6493: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
// Result = [ ] ;
6498: LD_ADDR_VAR 0 4
6502: PUSH
6503: EMPTY
6504: ST_TO_ADDR
// for I = 1 to Pocet do
6505: LD_ADDR_VAR 0 5
6509: PUSH
6510: DOUBLE
6511: LD_INT 1
6513: DEC
6514: ST_TO_ADDR
6515: LD_VAR 0 1
6519: PUSH
6520: FOR_TO
6521: IFFALSE 6554
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
6523: LD_ADDR_VAR 0 4
6527: PUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 6454 0 2
6547: PUSH
6548: EMPTY
6549: LIST
6550: UNION
6551: ST_TO_ADDR
6552: GO 6520
6554: POP
6555: POP
// end ;
6556: LD_VAR 0 4
6560: RET
// function zacni_zkoumat ; begin
6561: LD_INT 0
6563: PPUSH
// AddComResearch ( AmLabWS , TECH_TECH1 ) ;
6564: LD_INT 24
6566: PPUSH
6567: LD_INT 48
6569: PPUSH
6570: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP1 ) ;
6574: LD_INT 24
6576: PPUSH
6577: LD_INT 51
6579: PPUSH
6580: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB1 ) ;
6584: LD_INT 24
6586: PPUSH
6587: LD_INT 54
6589: PPUSH
6590: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_TECH2 ) ;
6594: LD_INT 24
6596: PPUSH
6597: LD_INT 49
6599: PPUSH
6600: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP2 ) ;
6604: LD_INT 24
6606: PPUSH
6607: LD_INT 52
6609: PPUSH
6610: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB2 ) ;
6614: LD_INT 24
6616: PPUSH
6617: LD_INT 55
6619: PPUSH
6620: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_TECH3 ) ;
6624: LD_INT 24
6626: PPUSH
6627: LD_INT 50
6629: PPUSH
6630: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP3 ) ;
6634: LD_INT 24
6636: PPUSH
6637: LD_INT 53
6639: PPUSH
6640: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB3 ) ;
6644: LD_INT 24
6646: PPUSH
6647: LD_INT 56
6649: PPUSH
6650: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_MATDET ) ;
6654: LD_INT 25
6656: PPUSH
6657: LD_INT 7
6659: PPUSH
6660: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_VIRUS ) ;
6664: LD_INT 25
6666: PPUSH
6667: LD_INT 33
6669: PPUSH
6670: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP1 ) ;
6674: LD_INT 25
6676: PPUSH
6677: LD_INT 57
6679: PPUSH
6680: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO1 ) ;
6684: LD_INT 25
6686: PPUSH
6687: LD_INT 60
6689: PPUSH
6690: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP2 ) ;
6694: LD_INT 25
6696: PPUSH
6697: LD_INT 58
6699: PPUSH
6700: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO2 ) ;
6704: LD_INT 25
6706: PPUSH
6707: LD_INT 61
6709: PPUSH
6710: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP3 ) ;
6714: LD_INT 25
6716: PPUSH
6717: LD_INT 59
6719: PPUSH
6720: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO3 ) ;
6724: LD_INT 25
6726: PPUSH
6727: LD_INT 62
6729: PPUSH
6730: CALL_OW 184
// end ;
6734: LD_VAR 0 1
6738: RET
// function zacni_vyrabet ; var I ; begin
6739: LD_INT 0
6741: PPUSH
6742: PPUSH
// for I = 1 to 2 do
6743: LD_ADDR_VAR 0 2
6747: PUSH
6748: DOUBLE
6749: LD_INT 1
6751: DEC
6752: ST_TO_ADDR
6753: LD_INT 2
6755: PUSH
6756: FOR_TO
6757: IFFALSE 6765
// vyrob_nakladak ;
6759: CALL 7525 0 0
6763: GO 6756
6765: POP
6766: POP
// for I = 1 to Max_Doprovod do
6767: LD_ADDR_VAR 0 2
6771: PUSH
6772: DOUBLE
6773: LD_INT 1
6775: DEC
6776: ST_TO_ADDR
6777: LD_LOC 25
6781: PUSH
6782: FOR_TO
6783: IFFALSE 6794
// vyrob_tank ( false ) ;
6785: LD_INT 0
6787: PPUSH
6788: CALL 7552 0 1
6792: GO 6782
6794: POP
6795: POP
// end ;
6796: LD_VAR 0 1
6800: RET
// function sur ( Budova , Cans , Oil , Sib ) ; var Base ; begin
6801: LD_INT 0
6803: PPUSH
6804: PPUSH
// Base = GetBase ( Budova ) ;
6805: LD_ADDR_VAR 0 6
6809: PUSH
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 274
6819: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Cans ) ;
6820: LD_VAR 0 6
6824: PPUSH
6825: LD_INT 1
6827: PPUSH
6828: LD_VAR 0 2
6832: PPUSH
6833: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Oil ) ;
6837: LD_VAR 0 6
6841: PPUSH
6842: LD_INT 2
6844: PPUSH
6845: LD_VAR 0 3
6849: PPUSH
6850: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Sib ) ;
6854: LD_VAR 0 6
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: LD_VAR 0 4
6866: PPUSH
6867: CALL_OW 277
// end ;
6871: LD_VAR 0 5
6875: RET
// export function amici_VehicleConstructed ( Veh , Fact ) ; var Weapon ; begin
6876: LD_INT 0
6878: PPUSH
6879: PPUSH
// if GetSide ( Veh ) = side_Am then
6880: LD_VAR 0 1
6884: PPUSH
6885: CALL_OW 255
6889: PUSH
6890: LD_EXP 2
6894: EQUAL
6895: IFFALSE 7107
// begin Weapon = GetWeapon ( Veh ) ;
6897: LD_ADDR_VAR 0 4
6901: PUSH
6902: LD_VAR 0 1
6906: PPUSH
6907: CALL_OW 264
6911: ST_TO_ADDR
// VyrobenoAut = VyrobenoAut + 1 ;
6912: LD_ADDR_LOC 28
6916: PUSH
6917: LD_LOC 28
6921: PUSH
6922: LD_INT 1
6924: PLUS
6925: ST_TO_ADDR
// if VyrobenoAut >= 2 + Max_Doprovod then
6926: LD_LOC 28
6930: PUSH
6931: LD_INT 2
6933: PUSH
6934: LD_LOC 25
6938: PLUS
6939: GREATEREQUAL
6940: IFFALSE 6950
// MamKontrolovatVyrobu = true ;
6942: LD_ADDR_LOC 27
6946: PUSH
6947: LD_INT 1
6949: ST_TO_ADDR
// if ( Weapon = US_CARGO_BAY ) then
6950: LD_VAR 0 4
6954: PUSH
6955: LD_INT 12
6957: EQUAL
6958: IFFALSE 7009
// begin if not Kradenik then
6960: LD_LOC 26
6964: NOT
6965: IFFALSE 6979
// Kradenik = Veh else
6967: LD_ADDR_LOC 26
6971: PUSH
6972: LD_VAR 0 1
6976: ST_TO_ADDR
6977: GO 6998
// Konvoj = Konvoj union [ Veh ] ;
6979: LD_ADDR_LOC 21
6983: PUSH
6984: LD_LOC 21
6988: PUSH
6989: LD_VAR 0 1
6993: PUSH
6994: EMPTY
6995: LIST
6996: UNION
6997: ST_TO_ADDR
// AddComHold ( Veh ) ;
6998: LD_VAR 0 1
7002: PPUSH
7003: CALL_OW 200
// end else
7007: GO 7107
// begin if not KonvojBylRozebran and ( Doprovod < Max_Doprovod ) and ( Weapon <> US_DOUBLE_LASER ) then
7009: LD_LOC 44
7013: NOT
7014: PUSH
7015: LD_LOC 22
7019: PUSH
7020: LD_LOC 25
7024: LESS
7025: AND
7026: PUSH
7027: LD_VAR 0 4
7031: PUSH
7032: LD_INT 10
7034: NONEQUAL
7035: AND
7036: IFFALSE 7059
// begin Doprovod = Doprovod union [ Veh ] ;
7038: LD_ADDR_LOC 22
7042: PUSH
7043: LD_LOC 22
7047: PUSH
7048: LD_VAR 0 1
7052: PUSH
7053: EMPTY
7054: LIST
7055: UNION
7056: ST_TO_ADDR
// end else
7057: GO 7107
// begin Tanky = Tanky union [ Veh ] ;
7059: LD_ADDR_LOC 23
7063: PUSH
7064: LD_LOC 23
7068: PUSH
7069: LD_VAR 0 1
7073: PUSH
7074: EMPTY
7075: LIST
7076: UNION
7077: ST_TO_ADDR
// ComMoveToArea ( Veh , Parkoviste ) ;
7078: LD_VAR 0 1
7082: PPUSH
7083: LD_INT 3
7085: PPUSH
7086: CALL_OW 113
// AddMcUnits ( MakroObrana , [ Veh ] ) ;
7090: LD_LOC 48
7094: PPUSH
7095: LD_VAR 0 1
7099: PUSH
7100: EMPTY
7101: LIST
7102: PPUSH
7103: CALL_OW 390
// end ; end ; end ; end ;
7107: LD_VAR 0 3
7111: RET
// function jednotka_pryc ( Un ) ; begin
7112: LD_INT 0
7114: PPUSH
// if Un = Kradenik then
7115: LD_VAR 0 1
7119: PUSH
7120: LD_LOC 26
7124: EQUAL
7125: IFFALSE 7135
// Kradenik = 0 ;
7127: LD_ADDR_LOC 26
7131: PUSH
7132: LD_INT 0
7134: ST_TO_ADDR
// if Un in Tanky then
7135: LD_VAR 0 1
7139: PUSH
7140: LD_LOC 23
7144: IN
7145: IFFALSE 7166
// Tanky = Tanky diff [ Un ] ;
7147: LD_ADDR_LOC 23
7151: PUSH
7152: LD_LOC 23
7156: PUSH
7157: LD_VAR 0 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: DIFF
7165: ST_TO_ADDR
// if Un in Konvoj then
7166: LD_VAR 0 1
7170: PUSH
7171: LD_LOC 21
7175: IN
7176: IFFALSE 7197
// Konvoj = Konvoj diff [ Un ] ;
7178: LD_ADDR_LOC 21
7182: PUSH
7183: LD_LOC 21
7187: PUSH
7188: LD_VAR 0 1
7192: PUSH
7193: EMPTY
7194: LIST
7195: DIFF
7196: ST_TO_ADDR
// if Un in Doprovod then
7197: LD_VAR 0 1
7201: PUSH
7202: LD_LOC 22
7206: IN
7207: IFFALSE 7228
// Doprovod = Doprovod diff [ Un ] ;
7209: LD_ADDR_LOC 22
7213: PUSH
7214: LD_LOC 22
7218: PUSH
7219: LD_VAR 0 1
7223: PUSH
7224: EMPTY
7225: LIST
7226: DIFF
7227: ST_TO_ADDR
// if Un in Obranci then
7228: LD_VAR 0 1
7232: PUSH
7233: LD_LOC 17
7237: IN
7238: IFFALSE 7259
// Obranci = Obranci diff [ Un ] ;
7240: LD_ADDR_LOC 17
7244: PUSH
7245: LD_LOC 17
7249: PUSH
7250: LD_VAR 0 1
7254: PUSH
7255: EMPTY
7256: LIST
7257: DIFF
7258: ST_TO_ADDR
// if Un in Patrola then
7259: LD_VAR 0 1
7263: PUSH
7264: LD_LOC 20
7268: IN
7269: IFFALSE 7290
// Patrola = Patrola diff [ Un ] ;
7271: LD_ADDR_LOC 20
7275: PUSH
7276: LD_LOC 20
7280: PUSH
7281: LD_VAR 0 1
7285: PUSH
7286: EMPTY
7287: LIST
7288: DIFF
7289: ST_TO_ADDR
// if Un in Utok_Auta then
7290: LD_VAR 0 1
7294: PUSH
7295: LD_LOC 39
7299: IN
7300: IFFALSE 7321
// Utok_Auta = Utok_Auta diff [ Un ] ;
7302: LD_ADDR_LOC 39
7306: PUSH
7307: LD_LOC 39
7311: PUSH
7312: LD_VAR 0 1
7316: PUSH
7317: EMPTY
7318: LIST
7319: DIFF
7320: ST_TO_ADDR
// if Un in RozebratAuta then
7321: LD_VAR 0 1
7325: PUSH
7326: LD_LOC 45
7330: IN
7331: IFFALSE 7352
// RozebratAuta = RozebratAuta diff [ Un ] ;
7333: LD_ADDR_LOC 45
7337: PUSH
7338: LD_LOC 45
7342: PUSH
7343: LD_VAR 0 1
7347: PUSH
7348: EMPTY
7349: LIST
7350: DIFF
7351: ST_TO_ADDR
// if Un in KdoLeci then
7352: LD_VAR 0 1
7356: PUSH
7357: LD_LOC 40
7361: IN
7362: IFFALSE 7383
// KdoLeci = KdoLeci diff [ Un ] ;
7364: LD_ADDR_LOC 40
7368: PUSH
7369: LD_LOC 40
7373: PUSH
7374: LD_VAR 0 1
7378: PUSH
7379: EMPTY
7380: LIST
7381: DIFF
7382: ST_TO_ADDR
// if Un in KdoOpravuje then
7383: LD_VAR 0 1
7387: PUSH
7388: LD_LOC 41
7392: IN
7393: IFFALSE 7414
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
7395: LD_ADDR_LOC 41
7399: PUSH
7400: LD_LOC 41
7404: PUSH
7405: LD_VAR 0 1
7409: PUSH
7410: EMPTY
7411: LIST
7412: DIFF
7413: ST_TO_ADDR
// if not Konvoj then
7414: LD_LOC 21
7418: NOT
7419: IFFALSE 7429
// ProbihaPrevoz = 0 ;
7421: LD_ADDR_LOC 29
7425: PUSH
7426: LD_INT 0
7428: ST_TO_ADDR
// if not Patrola then
7429: LD_LOC 20
7433: NOT
7434: IFFALSE 7445
// KillMc ( MakroPatrola ) ;
7436: LD_LOC 51
7440: PPUSH
7441: CALL_OW 387
// end ;
7445: LD_VAR 0 2
7449: RET
// export function amici_UnitDestroyed ( Un ) ; begin
7450: LD_INT 0
7452: PPUSH
// jednotka_pryc ( Un ) ;
7453: LD_VAR 0 1
7457: PPUSH
7458: CALL 7112 0 1
// end ;
7462: LD_VAR 0 2
7466: RET
// export function amici_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
7467: LD_INT 0
7469: PPUSH
// if ( OrigSide = side_Am ) then
7470: LD_VAR 0 3
7474: PUSH
7475: LD_EXP 2
7479: EQUAL
7480: IFFALSE 7491
// jednotka_pryc ( VehOld ) ;
7482: LD_VAR 0 2
7486: PPUSH
7487: CALL 7112 0 1
// end ;
7491: LD_VAR 0 5
7495: RET
// export function amici_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
7496: LD_INT 0
7498: PPUSH
// if ( OrigSide = side_Am ) then
7499: LD_VAR 0 2
7503: PUSH
7504: LD_EXP 2
7508: EQUAL
7509: IFFALSE 7520
// jednotka_pryc ( Build ) ;
7511: LD_VAR 0 1
7515: PPUSH
7516: CALL 7112 0 1
// end ;
7520: LD_VAR 0 4
7524: RET
// function vyrob_nakladak ; begin
7525: LD_INT 0
7527: PPUSH
// AddComConstruct ( AmFactRock , US_MEDIUM_WHEELED , ENGINE_SIBERITE , CONTROL_COMPUTER , US_CARGO_BAY ) ;
7528: LD_INT 26
7530: PPUSH
7531: LD_INT 2
7533: PPUSH
7534: LD_INT 3
7536: PPUSH
7537: LD_INT 3
7539: PPUSH
7540: LD_INT 12
7542: PPUSH
7543: CALL_OW 185
// end ;
7547: LD_VAR 0 1
7551: RET
// function vyrob_tank ( PovolitDblAPasy ) ; var P , Chassis , Weapon , Tovarna ; begin
7552: LD_INT 0
7554: PPUSH
7555: PPUSH
7556: PPUSH
7557: PPUSH
7558: PPUSH
// if PovolitDblAPasy then
7559: LD_VAR 0 1
7563: IFFALSE 7583
// P = Rand ( 1 , 100 ) else
7565: LD_ADDR_VAR 0 3
7569: PUSH
7570: LD_INT 1
7572: PPUSH
7573: LD_INT 100
7575: PPUSH
7576: CALL_OW 12
7580: ST_TO_ADDR
7581: GO 7637
// begin P = Rand ( 1 , 79 ) ;
7583: LD_ADDR_VAR 0 3
7587: PUSH
7588: LD_INT 1
7590: PPUSH
7591: LD_INT 79
7593: PPUSH
7594: CALL_OW 12
7598: ST_TO_ADDR
// while ( P >= 30 ) and ( P < 45 ) do
7599: LD_VAR 0 3
7603: PUSH
7604: LD_INT 30
7606: GREATEREQUAL
7607: PUSH
7608: LD_VAR 0 3
7612: PUSH
7613: LD_INT 45
7615: LESS
7616: AND
7617: IFFALSE 7637
// P = Rand ( 1 , 79 ) ;
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 1
7626: PPUSH
7627: LD_INT 79
7629: PPUSH
7630: CALL_OW 12
7634: ST_TO_ADDR
7635: GO 7599
// end ; if ( Difficulty = 1 ) and ( P >= 80 ) then
7637: LD_OWVAR 67
7641: PUSH
7642: LD_INT 1
7644: EQUAL
7645: PUSH
7646: LD_VAR 0 3
7650: PUSH
7651: LD_INT 80
7653: GREATEREQUAL
7654: AND
7655: IFFALSE 7673
// P = Rand ( 1 , 79 ) ;
7657: LD_ADDR_VAR 0 3
7661: PUSH
7662: LD_INT 1
7664: PPUSH
7665: LD_INT 79
7667: PPUSH
7668: CALL_OW 12
7672: ST_TO_ADDR
// if P < 15 then
7673: LD_VAR 0 3
7677: PUSH
7678: LD_INT 15
7680: LESS
7681: IFFALSE 7701
// begin Weapon = US_LASER ;
7683: LD_ADDR_VAR 0 5
7687: PUSH
7688: LD_INT 9
7690: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7691: LD_ADDR_VAR 0 4
7695: PUSH
7696: LD_INT 2
7698: ST_TO_ADDR
// end else
7699: GO 7829
// if P < 30 then
7701: LD_VAR 0 3
7705: PUSH
7706: LD_INT 30
7708: LESS
7709: IFFALSE 7729
// begin Weapon = US_GATLING_GUN ;
7711: LD_ADDR_VAR 0 5
7715: PUSH
7716: LD_INT 4
7718: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7719: LD_ADDR_VAR 0 4
7723: PUSH
7724: LD_INT 2
7726: ST_TO_ADDR
// end else
7727: GO 7829
// if P < 45 then
7729: LD_VAR 0 3
7733: PUSH
7734: LD_INT 45
7736: LESS
7737: IFFALSE 7757
// begin Weapon = US_HEAVY_GUN ;
7739: LD_ADDR_VAR 0 5
7743: PUSH
7744: LD_INT 6
7746: ST_TO_ADDR
// Chassis = US_HEAVY_TRACKED ;
7747: LD_ADDR_VAR 0 4
7751: PUSH
7752: LD_INT 4
7754: ST_TO_ADDR
// end else
7755: GO 7829
// if P < 60 then
7757: LD_VAR 0 3
7761: PUSH
7762: LD_INT 60
7764: LESS
7765: IFFALSE 7785
// begin Weapon = US_DOUBLE_GUN ;
7767: LD_ADDR_VAR 0 5
7771: PUSH
7772: LD_INT 5
7774: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7775: LD_ADDR_VAR 0 4
7779: PUSH
7780: LD_INT 2
7782: ST_TO_ADDR
// end else
7783: GO 7829
// if P < 80 then
7785: LD_VAR 0 3
7789: PUSH
7790: LD_INT 80
7792: LESS
7793: IFFALSE 7813
// begin Weapon = US_ROCKET_LAUNCHER ;
7795: LD_ADDR_VAR 0 5
7799: PUSH
7800: LD_INT 7
7802: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7803: LD_ADDR_VAR 0 4
7807: PUSH
7808: LD_INT 2
7810: ST_TO_ADDR
// end else
7811: GO 7829
// begin Weapon = US_DOUBLE_LASER ;
7813: LD_ADDR_VAR 0 5
7817: PUSH
7818: LD_INT 10
7820: ST_TO_ADDR
// Chassis = US_HEAVY_TRACKED ;
7821: LD_ADDR_VAR 0 4
7825: PUSH
7826: LD_INT 4
7828: ST_TO_ADDR
// end ; if PovolitDblAPasy then
7829: LD_VAR 0 1
7833: IFFALSE 7853
// Chassis = Rand ( Chassis , US_HEAVY_TRACKED ) ;
7835: LD_ADDR_VAR 0 4
7839: PUSH
7840: LD_VAR 0 4
7844: PPUSH
7845: LD_INT 4
7847: PPUSH
7848: CALL_OW 12
7852: ST_TO_ADDR
// if Weapon = US_ROCKET_LAUNCHER then
7853: LD_VAR 0 5
7857: PUSH
7858: LD_INT 7
7860: EQUAL
7861: IFFALSE 7873
// Tovarna = AmFactRock else
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_INT 26
7870: ST_TO_ADDR
7871: GO 7881
// Tovarna = AmFactGun ;
7873: LD_ADDR_VAR 0 6
7877: PUSH
7878: LD_INT 30
7880: ST_TO_ADDR
// AddComConstruct ( Tovarna , Chassis , ENGINE_SIBERITE , CONTROL_COMPUTER , Weapon ) ;
7881: LD_VAR 0 6
7885: PPUSH
7886: LD_VAR 0 4
7890: PPUSH
7891: LD_INT 3
7893: PPUSH
7894: LD_INT 3
7896: PPUSH
7897: LD_VAR 0 5
7901: PPUSH
7902: CALL_OW 185
// end ;
7906: LD_VAR 0 2
7910: RET
// function kontrola_jednotek ; var Base , Cans , Oil , Sib ; begin
7911: LD_INT 0
7913: PPUSH
7914: PPUSH
7915: PPUSH
7916: PPUSH
7917: PPUSH
// Base = GetBase ( AmDepot ) ;
7918: LD_ADDR_VAR 0 2
7922: PUSH
7923: LD_INT 15
7925: PPUSH
7926: CALL_OW 274
7930: ST_TO_ADDR
// if not Kradenik then
7931: LD_LOC 26
7935: NOT
7936: IFFALSE 7942
// vyrob_nakladak ;
7938: CALL 7525 0 0
// if not Konvoj and not KonvojBylRozebran then
7942: LD_LOC 21
7946: NOT
7947: PUSH
7948: LD_LOC 44
7952: NOT
7953: AND
7954: IFFALSE 7960
// vyrob_nakladak ;
7956: CALL 7525 0 0
// if ( Tanky < Max_Tanky ) or ( not KonvojBylRozebran and ( Doprovod < Max_Doprovod ) ) then
7960: LD_LOC 23
7964: PUSH
7965: LD_LOC 24
7969: LESS
7970: PUSH
7971: LD_LOC 44
7975: NOT
7976: PUSH
7977: LD_LOC 22
7981: PUSH
7982: LD_LOC 25
7986: LESS
7987: AND
7988: OR
7989: IFFALSE 8082
// begin Cans = GetResourceType ( Base , MAT_CANS ) ;
7991: LD_ADDR_VAR 0 3
7995: PUSH
7996: LD_VAR 0 2
8000: PPUSH
8001: LD_INT 1
8003: PPUSH
8004: CALL_OW 275
8008: ST_TO_ADDR
// Oil = GetResourceType ( Base , MAT_OIL ) ;
8009: LD_ADDR_VAR 0 4
8013: PUSH
8014: LD_VAR 0 2
8018: PPUSH
8019: LD_INT 2
8021: PPUSH
8022: CALL_OW 275
8026: ST_TO_ADDR
// Sib = GetResourceType ( Base , MAT_SIBERIT ) ;
8027: LD_ADDR_VAR 0 5
8031: PUSH
8032: LD_VAR 0 2
8036: PPUSH
8037: LD_INT 3
8039: PPUSH
8040: CALL_OW 275
8044: ST_TO_ADDR
// if ( Cans >= 200 ) and ( Oil >= 30 ) and ( Sib >= 20 ) then
8045: LD_VAR 0 3
8049: PUSH
8050: LD_INT 200
8052: GREATEREQUAL
8053: PUSH
8054: LD_VAR 0 4
8058: PUSH
8059: LD_INT 30
8061: GREATEREQUAL
8062: AND
8063: PUSH
8064: LD_VAR 0 5
8068: PUSH
8069: LD_INT 20
8071: GREATEREQUAL
8072: AND
8073: IFFALSE 8082
// vyrob_tank ( true ) ;
8075: LD_INT 1
8077: PPUSH
8078: CALL 7552 0 1
// end ; end ;
8082: LD_VAR 0 1
8086: RET
// every 0 0$51 + 0 0$3 trigger MamKontrolovatVyrobu do
8087: LD_LOC 27
8091: IFFALSE 8101
8093: GO 8095
8095: DISABLE
// begin kontrola_jednotek ;
8096: CALL 7911 0 0
// enable ;
8100: ENABLE
// end ;
8101: END
// every 1 1$7 do var Inz ;
8102: GO 8104
8104: DISABLE
8105: LD_INT 0
8107: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Am ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] , [ F_OK ] ] ) diff [ AmEng_Oil , AmEng_Sib ] ;
8108: LD_ADDR_VAR 0 1
8112: PUSH
8113: LD_INT 22
8115: PUSH
8116: LD_EXP 2
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PUSH
8125: LD_INT 21
8127: PUSH
8128: LD_INT 1
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PUSH
8135: LD_INT 25
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PUSH
8145: LD_INT 50
8147: PUSH
8148: EMPTY
8149: LIST
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: LIST
8155: LIST
8156: PPUSH
8157: CALL_OW 69
8161: PUSH
8162: LD_LOC 15
8166: PUSH
8167: LD_LOC 16
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: DIFF
8176: ST_TO_ADDR
// sbirej_bedny ( Inz , Americani ) ;
8177: LD_VAR 0 1
8181: PPUSH
8182: LD_INT 2
8184: PPUSH
8185: CALL 16237 0 2
// opravuj_budovy ( Inz , Americani , side_Am ) ;
8189: LD_VAR 0 1
8193: PPUSH
8194: LD_INT 2
8196: PPUSH
8197: LD_EXP 2
8201: PPUSH
8202: CALL 16095 0 3
// enable ;
8206: ENABLE
// end ;
8207: PPOPN 1
8209: END
// function kontrola_prevoz ; var Base , Base_Oil , Base_Sib ; var Ropa , Sibe , KolikRopy , KolikSibe ; begin
8210: LD_INT 0
8212: PPUSH
8213: PPUSH
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
8218: PPUSH
8219: PPUSH
// if ProbihaPrevoz then
8220: LD_LOC 29
8224: IFFALSE 8228
// exit ;
8226: GO 8584
// if not IsOK ( AmDepot ) or ( GetSide ( AmDepot ) <> side_Am ) then
8228: LD_INT 15
8230: PPUSH
8231: CALL_OW 302
8235: NOT
8236: PUSH
8237: LD_INT 15
8239: PPUSH
8240: CALL_OW 255
8244: PUSH
8245: LD_EXP 2
8249: NONEQUAL
8250: OR
8251: IFFALSE 8255
// exit ;
8253: GO 8584
// if not Konvoj then
8255: LD_LOC 21
8259: NOT
8260: IFFALSE 8264
// exit ;
8262: GO 8584
// if Doprovod < Max_Doprovod then
8264: LD_LOC 22
8268: PUSH
8269: LD_LOC 25
8273: LESS
8274: IFFALSE 8278
// exit ;
8276: GO 8584
// Base = GetBase ( AmDepot ) ;
8278: LD_ADDR_VAR 0 2
8282: PUSH
8283: LD_INT 15
8285: PPUSH
8286: CALL_OW 274
8290: ST_TO_ADDR
// Base_Oil = GetBase ( AmDepot_Oil ) ;
8291: LD_ADDR_VAR 0 3
8295: PUSH
8296: LD_INT 1
8298: PPUSH
8299: CALL_OW 274
8303: ST_TO_ADDR
// Base_Sib = GetBase ( AmDepot_Sib ) ;
8304: LD_ADDR_VAR 0 4
8308: PUSH
8309: LD_INT 3
8311: PPUSH
8312: CALL_OW 274
8316: ST_TO_ADDR
// KolikRopy = GetResourceType ( Base , MAT_OIL ) ;
8317: LD_ADDR_VAR 0 7
8321: PUSH
8322: LD_VAR 0 2
8326: PPUSH
8327: LD_INT 2
8329: PPUSH
8330: CALL_OW 275
8334: ST_TO_ADDR
// KolikSibe = GetResourceType ( Base , MAT_SIBERIT ) ;
8335: LD_ADDR_VAR 0 8
8339: PUSH
8340: LD_VAR 0 2
8344: PPUSH
8345: LD_INT 3
8347: PPUSH
8348: CALL_OW 275
8352: ST_TO_ADDR
// Ropa = IsOk ( AmDepot_Oil ) and ( GetSide ( AmDepot_Oil ) = side_Am ) and GetResourceType ( Base_Oil , MAT_OIL ) > 100 ;
8353: LD_ADDR_VAR 0 5
8357: PUSH
8358: LD_INT 1
8360: PPUSH
8361: CALL_OW 302
8365: PUSH
8366: LD_INT 1
8368: PPUSH
8369: CALL_OW 255
8373: PUSH
8374: LD_EXP 2
8378: EQUAL
8379: AND
8380: PUSH
8381: LD_VAR 0 3
8385: PPUSH
8386: LD_INT 2
8388: PPUSH
8389: CALL_OW 275
8393: PUSH
8394: LD_INT 100
8396: GREATER
8397: AND
8398: ST_TO_ADDR
// Sibe = IsOk ( AmDepot_Sib ) and ( GetSide ( AmDepot_Sib ) = side_Am ) and GetResourceType ( Base_Sib , MAT_SIBERIT ) > 20 ;
8399: LD_ADDR_VAR 0 6
8403: PUSH
8404: LD_INT 3
8406: PPUSH
8407: CALL_OW 302
8411: PUSH
8412: LD_INT 3
8414: PPUSH
8415: CALL_OW 255
8419: PUSH
8420: LD_EXP 2
8424: EQUAL
8425: AND
8426: PUSH
8427: LD_VAR 0 4
8431: PPUSH
8432: LD_INT 3
8434: PPUSH
8435: CALL_OW 275
8439: PUSH
8440: LD_INT 20
8442: GREATER
8443: AND
8444: ST_TO_ADDR
// if Ropa or Sibe then
8445: LD_VAR 0 5
8449: PUSH
8450: LD_VAR 0 6
8454: OR
8455: IFFALSE 8584
// begin if Ropa and Sibe then
8457: LD_VAR 0 5
8461: PUSH
8462: LD_VAR 0 6
8466: AND
8467: IFFALSE 8568
// if KolikSibe < 30 then
8469: LD_VAR 0 8
8473: PUSH
8474: LD_INT 30
8476: LESS
8477: IFFALSE 8489
// Ropa = false else
8479: LD_ADDR_VAR 0 5
8483: PUSH
8484: LD_INT 0
8486: ST_TO_ADDR
8487: GO 8568
// if KolikRopy > 10 * KolikSibe then
8489: LD_VAR 0 7
8493: PUSH
8494: LD_INT 10
8496: PUSH
8497: LD_VAR 0 8
8501: MUL
8502: GREATER
8503: IFFALSE 8515
// Ropa = false else
8505: LD_ADDR_VAR 0 5
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
8513: GO 8568
// if KolikRopy < 5 * KolikSibe then
8515: LD_VAR 0 7
8519: PUSH
8520: LD_INT 5
8522: PUSH
8523: LD_VAR 0 8
8527: MUL
8528: LESS
8529: IFFALSE 8541
// Sibe = false else
8531: LD_ADDR_VAR 0 6
8535: PUSH
8536: LD_INT 0
8538: ST_TO_ADDR
8539: GO 8568
// if Prob ( 50 ) then
8541: LD_INT 50
8543: PPUSH
8544: CALL_OW 13
8548: IFFALSE 8560
// Ropa = false else
8550: LD_ADDR_VAR 0 5
8554: PUSH
8555: LD_INT 0
8557: ST_TO_ADDR
8558: GO 8568
// Sibe = false ;
8560: LD_ADDR_VAR 0 6
8564: PUSH
8565: LD_INT 0
8567: ST_TO_ADDR
// if Sibe then
8568: LD_VAR 0 6
8572: IFFALSE 8580
// prevoz_sibe else
8574: CALL 8975 0 0
8578: GO 8584
// prevoz_ropa ;
8580: CALL 8787 0 0
// end ; end ;
8584: LD_VAR 0 1
8588: RET
// function prevoz_init ( Co ) ; begin
8589: LD_INT 0
8591: PPUSH
// ProbihaPrevoz = Co ;
8592: LD_ADDR_LOC 29
8596: PUSH
8597: LD_VAR 0 1
8601: ST_TO_ADDR
// PrevozNalozil = false ;
8602: LD_ADDR_LOC 30
8606: PUSH
8607: LD_INT 0
8609: ST_TO_ADDR
// PrevozVylozil = false ;
8610: LD_ADDR_LOC 31
8614: PUSH
8615: LD_INT 0
8617: ST_TO_ADDR
// end ;
8618: LD_VAR 0 2
8622: RET
// export function amici_McDone ( McId , State ) ; begin
8623: LD_INT 0
8625: PPUSH
// if MakroPrevoz and ( McId = MakroPrevoz ) then
8626: LD_LOC 52
8630: PUSH
8631: LD_VAR 0 1
8635: PUSH
8636: LD_LOC 52
8640: EQUAL
8641: AND
8642: IFFALSE 8695
// begin case ProbihaPrevoz of 1 :
8644: LD_LOC 29
8648: PUSH
8649: LD_INT 1
8651: DOUBLE
8652: EQUAL
8653: IFTRUE 8657
8655: GO 8664
8657: POP
// prevoz_ropa_2 ; 2 :
8658: CALL 8850 0 0
8662: GO 8695
8664: LD_INT 2
8666: DOUBLE
8667: EQUAL
8668: IFTRUE 8672
8670: GO 8679
8672: POP
// prevoz_sibe_2 ; 3 :
8673: CALL 9038 0 0
8677: GO 8695
8679: LD_INT 3
8681: DOUBLE
8682: EQUAL
8683: IFTRUE 8687
8685: GO 8694
8687: POP
// prevoz_konec ; end ;
8688: CALL 9163 0 0
8692: GO 8695
8694: POP
// end ; if MakroUtokMove and ( McId = MakroUtokMove ) then
8695: LD_LOC 50
8699: PUSH
8700: LD_VAR 0 1
8704: PUSH
8705: LD_LOC 50
8709: EQUAL
8710: AND
8711: IFFALSE 8782
// begin MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , Parkoviste ] , [ MC_RETREAT_AREA_VEHICLES , Parkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8713: LD_ADDR_LOC 49
8717: PUSH
8718: LD_INT 10
8720: PPUSH
8721: LD_LOC 46
8725: PPUSH
8726: LD_LOC 39
8730: PPUSH
8731: LD_INT 7
8733: PUSH
8734: LD_INT 3
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: PUSH
8741: LD_INT 8
8743: PUSH
8744: LD_INT 3
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: PUSH
8751: LD_INT 5
8753: PUSH
8754: LD_INT 10
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: PUSH
8761: LD_INT 6
8763: PUSH
8764: LD_INT 10
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PUSH
8771: EMPTY
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: PPUSH
8777: CALL_OW 402
8781: ST_TO_ADDR
// end ; end ;
8782: LD_VAR 0 3
8786: RET
// function prevoz_ropa ; var Way ; begin
8787: LD_INT 0
8789: PPUSH
8790: PPUSH
// prevoz_init ( 1 ) ;
8791: LD_INT 1
8793: PPUSH
8794: CALL 8589 0 1
// Way = cesta_B_X ^ cesta_X_O ;
8798: LD_ADDR_VAR 0 2
8802: PUSH
8803: CALL 9296 0 0
8807: PUSH
8808: CALL 9447 0 0
8812: ADD
8813: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
8814: LD_ADDR_LOC 52
8818: PUSH
8819: LD_INT 50
8821: PPUSH
8822: LD_LOC 21
8826: PUSH
8827: LD_LOC 22
8831: UNION
8832: PPUSH
8833: LD_VAR 0 2
8837: PPUSH
8838: EMPTY
8839: PPUSH
8840: CALL_OW 398
8844: ST_TO_ADDR
// end ;
8845: LD_VAR 0 1
8849: RET
// function prevoz_ropa_2 ; var I , Way ; begin
8850: LD_INT 0
8852: PPUSH
8853: PPUSH
8854: PPUSH
// if not ProbihaPrevoz then
8855: LD_LOC 29
8859: NOT
8860: IFFALSE 8864
// exit ;
8862: GO 8970
// if PrevozNalozil then
8864: LD_LOC 30
8868: IFFALSE 8872
// exit ;
8870: GO 8970
// ProbihaPrevoz = 3 ;
8872: LD_ADDR_LOC 29
8876: PUSH
8877: LD_INT 3
8879: ST_TO_ADDR
// PrevozNalozil = true ;
8880: LD_ADDR_LOC 30
8884: PUSH
8885: LD_INT 1
8887: ST_TO_ADDR
// for I in Konvoj do
8888: LD_ADDR_VAR 0 2
8892: PUSH
8893: LD_LOC 21
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8921
// naloz ( I , AmDepot_Oil , MAT_OIL , 100 ) ;
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: LD_INT 100
8914: PPUSH
8915: CALL 15700 0 4
8919: GO 8898
8921: POP
8922: POP
// Way = cesta_O_X ^ cesta_X_B ;
8923: LD_ADDR_VAR 0 3
8927: PUSH
8928: CALL 9517 0 0
8932: PUSH
8933: CALL 9366 0 0
8937: ADD
8938: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
8939: LD_ADDR_LOC 52
8943: PUSH
8944: LD_INT 50
8946: PPUSH
8947: LD_LOC 21
8951: PUSH
8952: LD_LOC 22
8956: UNION
8957: PPUSH
8958: LD_VAR 0 3
8962: PPUSH
8963: EMPTY
8964: PPUSH
8965: CALL_OW 398
8969: ST_TO_ADDR
// end ;
8970: LD_VAR 0 1
8974: RET
// function prevoz_sibe ; var Way ; begin
8975: LD_INT 0
8977: PPUSH
8978: PPUSH
// prevoz_init ( 2 ) ;
8979: LD_INT 2
8981: PPUSH
8982: CALL 8589 0 1
// Way = cesta_B_X ^ cesta_X_S ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: CALL 9296 0 0
8995: PUSH
8996: CALL 9576 0 0
9000: ADD
9001: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
9002: LD_ADDR_LOC 52
9006: PUSH
9007: LD_INT 50
9009: PPUSH
9010: LD_LOC 21
9014: PUSH
9015: LD_LOC 22
9019: UNION
9020: PPUSH
9021: LD_VAR 0 2
9025: PPUSH
9026: EMPTY
9027: PPUSH
9028: CALL_OW 398
9032: ST_TO_ADDR
// end ;
9033: LD_VAR 0 1
9037: RET
// function prevoz_sibe_2 ; var I , Way ; begin
9038: LD_INT 0
9040: PPUSH
9041: PPUSH
9042: PPUSH
// if not ProbihaPrevoz then
9043: LD_LOC 29
9047: NOT
9048: IFFALSE 9052
// exit ;
9050: GO 9158
// if PrevozNalozil then
9052: LD_LOC 30
9056: IFFALSE 9060
// exit ;
9058: GO 9158
// ProbihaPrevoz = 3 ;
9060: LD_ADDR_LOC 29
9064: PUSH
9065: LD_INT 3
9067: ST_TO_ADDR
// PrevozNalozil = true ;
9068: LD_ADDR_LOC 30
9072: PUSH
9073: LD_INT 1
9075: ST_TO_ADDR
// for I in Konvoj do
9076: LD_ADDR_VAR 0 2
9080: PUSH
9081: LD_LOC 21
9085: PUSH
9086: FOR_IN
9087: IFFALSE 9109
// naloz ( I , AmDepot_Sib , MAT_SIBERIT , 100 ) ;
9089: LD_VAR 0 2
9093: PPUSH
9094: LD_INT 3
9096: PPUSH
9097: LD_INT 3
9099: PPUSH
9100: LD_INT 100
9102: PPUSH
9103: CALL 15700 0 4
9107: GO 9086
9109: POP
9110: POP
// Way = cesta_S_X ^ cesta_X_B ;
9111: LD_ADDR_VAR 0 3
9115: PUSH
9116: CALL 9635 0 0
9120: PUSH
9121: CALL 9366 0 0
9125: ADD
9126: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
9127: LD_ADDR_LOC 52
9131: PUSH
9132: LD_INT 50
9134: PPUSH
9135: LD_LOC 21
9139: PUSH
9140: LD_LOC 22
9144: UNION
9145: PPUSH
9146: LD_VAR 0 3
9150: PPUSH
9151: EMPTY
9152: PPUSH
9153: CALL_OW 398
9157: ST_TO_ADDR
// end ;
9158: LD_VAR 0 1
9162: RET
// function prevoz_konec ; var Nakladaky ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
// if not ProbihaPrevoz then
9167: LD_LOC 29
9171: NOT
9172: IFFALSE 9176
// exit ;
9174: GO 9275
// ProbihaPrevoz = 0 ;
9176: LD_ADDR_LOC 29
9180: PUSH
9181: LD_INT 0
9183: ST_TO_ADDR
// if PrevozVylozil then
9184: LD_LOC 31
9188: IFFALSE 9192
// exit ;
9190: GO 9275
// PrevozVylozil = true ;
9192: LD_ADDR_LOC 31
9196: PUSH
9197: LD_INT 1
9199: ST_TO_ADDR
// Nakladaky = UnitFilter ( Konvoj , [ [ F_WEAPON , US_CARGO_BAY ] ] ) ;
9200: LD_ADDR_VAR 0 2
9204: PUSH
9205: LD_LOC 21
9209: PPUSH
9210: LD_INT 34
9212: PUSH
9213: LD_INT 12
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: PUSH
9220: EMPTY
9221: LIST
9222: PPUSH
9223: CALL_OW 72
9227: ST_TO_ADDR
// AddComMoveUnit ( Nakladaky , AmDepot ) ;
9228: LD_VAR 0 2
9232: PPUSH
9233: LD_INT 15
9235: PPUSH
9236: CALL_OW 172
// AddComMoveToArea ( Konvoj union Doprovod , Parkoviste ) ;
9240: LD_LOC 21
9244: PUSH
9245: LD_LOC 22
9249: UNION
9250: PPUSH
9251: LD_INT 3
9253: PPUSH
9254: CALL_OW 173
// AddComHold ( Konvoj ) ;
9258: LD_LOC 21
9262: PPUSH
9263: CALL_OW 200
// ProbihaPrevoz = false ;
9267: LD_ADDR_LOC 29
9271: PUSH
9272: LD_INT 0
9274: ST_TO_ADDR
// end ;
9275: LD_VAR 0 1
9279: RET
// every 1 1$5 do
9280: GO 9282
9282: DISABLE
// begin kontrola_prevoz ;
9283: CALL 8210 0 0
// if not KonvojBylRozebran then
9287: LD_LOC 44
9291: NOT
9292: IFFALSE 9295
// enable ;
9294: ENABLE
// end ;
9295: END
// function cesta_B_X ; begin
9296: LD_INT 0
9298: PPUSH
// Result = [ [ 148 , 44 ] , [ 157 , 57 ] , [ 148 , 73 ] , [ 136 , 75 ] , [ 119 , 78 ] ] ;
9299: LD_ADDR_VAR 0 1
9303: PUSH
9304: LD_INT 148
9306: PUSH
9307: LD_INT 44
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 157
9316: PUSH
9317: LD_INT 57
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 148
9326: PUSH
9327: LD_INT 73
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 136
9336: PUSH
9337: LD_INT 75
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: LD_INT 119
9346: PUSH
9347: LD_INT 78
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: LIST
9360: ST_TO_ADDR
// end ;
9361: LD_VAR 0 1
9365: RET
// function cesta_X_B ; begin
9366: LD_INT 0
9368: PPUSH
// Result = [ [ 121 , 78 ] , [ 135 , 75 ] , [ 151 , 71 ] , [ 156 , 58 ] , [ 142 , 37 ] , [ 139 , 14 ] ] ;
9369: LD_ADDR_VAR 0 1
9373: PUSH
9374: LD_INT 121
9376: PUSH
9377: LD_INT 78
9379: PUSH
9380: EMPTY
9381: LIST
9382: LIST
9383: PUSH
9384: LD_INT 135
9386: PUSH
9387: LD_INT 75
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: PUSH
9394: LD_INT 151
9396: PUSH
9397: LD_INT 71
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PUSH
9404: LD_INT 156
9406: PUSH
9407: LD_INT 58
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: LD_INT 142
9416: PUSH
9417: LD_INT 37
9419: PUSH
9420: EMPTY
9421: LIST
9422: LIST
9423: PUSH
9424: LD_INT 139
9426: PUSH
9427: LD_INT 14
9429: PUSH
9430: EMPTY
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: ST_TO_ADDR
// end ;
9442: LD_VAR 0 1
9446: RET
// function cesta_X_O ; begin
9447: LD_INT 0
9449: PPUSH
// Result = [ [ 108 , 78 ] , [ 96 , 77 ] , [ 86 , 72 ] , [ 79 , 74 ] , [ 67 , 72 ] ] ;
9450: LD_ADDR_VAR 0 1
9454: PUSH
9455: LD_INT 108
9457: PUSH
9458: LD_INT 78
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: PUSH
9465: LD_INT 96
9467: PUSH
9468: LD_INT 77
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PUSH
9475: LD_INT 86
9477: PUSH
9478: LD_INT 72
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: PUSH
9485: LD_INT 79
9487: PUSH
9488: LD_INT 74
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PUSH
9495: LD_INT 67
9497: PUSH
9498: LD_INT 72
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: PUSH
9505: EMPTY
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: ST_TO_ADDR
// end ;
9512: LD_VAR 0 1
9516: RET
// function cesta_O_X ; begin
9517: LD_INT 0
9519: PPUSH
// Result = [ [ 74 , 72 ] , [ 88 , 73 ] , [ 103 , 79 ] , [ 109 , 78 ] ] ;
9520: LD_ADDR_VAR 0 1
9524: PUSH
9525: LD_INT 74
9527: PUSH
9528: LD_INT 72
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: LD_INT 88
9537: PUSH
9538: LD_INT 73
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PUSH
9545: LD_INT 103
9547: PUSH
9548: LD_INT 79
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: PUSH
9555: LD_INT 109
9557: PUSH
9558: LD_INT 78
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: ST_TO_ADDR
// end ;
9571: LD_VAR 0 1
9575: RET
// function cesta_X_S ; begin
9576: LD_INT 0
9578: PPUSH
// Result = [ [ 121 , 90 ] , [ 126 , 98 ] , [ 134 , 113 ] , [ 135 , 124 ] ] ;
9579: LD_ADDR_VAR 0 1
9583: PUSH
9584: LD_INT 121
9586: PUSH
9587: LD_INT 90
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: PUSH
9594: LD_INT 126
9596: PUSH
9597: LD_INT 98
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 134
9606: PUSH
9607: LD_INT 113
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 135
9616: PUSH
9617: LD_INT 124
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: ST_TO_ADDR
// end ;
9630: LD_VAR 0 1
9634: RET
// function cesta_S_X ; begin
9635: LD_INT 0
9637: PPUSH
// Result = [ [ 135 , 122 ] , [ 132 , 110 ] , [ 128 , 104 ] , [ 122 , 92 ] , [ 118 , 86 ] ] ;
9638: LD_ADDR_VAR 0 1
9642: PUSH
9643: LD_INT 135
9645: PUSH
9646: LD_INT 122
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: PUSH
9653: LD_INT 132
9655: PUSH
9656: LD_INT 110
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: PUSH
9663: LD_INT 128
9665: PUSH
9666: LD_INT 104
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: LD_INT 122
9675: PUSH
9676: LD_INT 92
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 118
9685: PUSH
9686: LD_INT 86
9688: PUSH
9689: EMPTY
9690: LIST
9691: LIST
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: ST_TO_ADDR
// end ;
9700: LD_VAR 0 1
9704: RET
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Am , side_Ru ) do
9705: LD_EXP 2
9709: PPUSH
9710: LD_EXP 3
9714: PPUSH
9715: CALL 15914 0 2
9719: IFFALSE 9732
9721: GO 9723
9723: DISABLE
// begin VidelRusa = true ;
9724: LD_ADDR_LOC 32
9728: PUSH
9729: LD_INT 1
9731: ST_TO_ADDR
// end ;
9732: END
// function zkontroluj_artefakt ; begin
9733: LD_INT 0
9735: PPUSH
// if ArtefaktMajAmici then
9736: LD_EXP 28
9740: IFFALSE 9744
// exit ;
9742: GO 9893
// if AutoSArtefaktem then
9744: LD_EXP 30
9748: IFFALSE 9752
// exit ;
9750: GO 9893
// if not KdeJeArtefakt then
9752: LD_EXP 29
9756: NOT
9757: IFFALSE 9761
// exit ;
9759: GO 9893
// if not Kradenik then
9761: LD_LOC 26
9765: NOT
9766: IFFALSE 9770
// exit ;
9768: GO 9893
// ComMoveUnit ( Kradenik , AmDepot ) ;
9770: LD_LOC 26
9774: PPUSH
9775: LD_INT 15
9777: PPUSH
9778: CALL_OW 112
// AddComMoveXY ( Kradenik , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
9782: LD_LOC 26
9786: PPUSH
9787: LD_EXP 29
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_EXP 29
9800: PUSH
9801: LD_INT 2
9803: ARRAY
9804: PPUSH
9805: CALL_OW 171
// AddComSailEvent ( Kradenik , 111 ) ;
9809: LD_LOC 26
9813: PPUSH
9814: LD_INT 111
9816: PPUSH
9817: CALL_OW 224
// AddComWait ( Kradenik , 0 0$1 ) ;
9821: LD_LOC 26
9825: PPUSH
9826: LD_INT 35
9828: PPUSH
9829: CALL_OW 202
// AddComCollect ( Kradenik , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
9833: LD_LOC 26
9837: PPUSH
9838: LD_EXP 29
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: PPUSH
9847: LD_EXP 29
9851: PUSH
9852: LD_INT 2
9854: ARRAY
9855: PPUSH
9856: CALL_OW 177
// AddComMoveToArea ( Kradenik , Americani ) ;
9860: LD_LOC 26
9864: PPUSH
9865: LD_INT 2
9867: PPUSH
9868: CALL_OW 173
// AddComMoveUnit ( Kradenik , AmDepot ) ;
9872: LD_LOC 26
9876: PPUSH
9877: LD_INT 15
9879: PPUSH
9880: CALL_OW 172
// AddComHold ( Kradenik ) ;
9884: LD_LOC 26
9888: PPUSH
9889: CALL_OW 200
// end ;
9893: LD_VAR 0 1
9897: RET
// export function event_KradenikPredKradenim ; begin
9898: LD_INT 0
9900: PPUSH
// if not IsOk ( Kradenik ) then
9901: LD_LOC 26
9905: PPUSH
9906: CALL_OW 302
9910: NOT
9911: IFFALSE 9915
// exit ;
9913: GO 9933
// uvolni_auto ( Kradenik , 10 * VelikostArtefaktu ) ;
9915: LD_LOC 26
9919: PPUSH
9920: LD_INT 10
9922: PUSH
9923: LD_EXP 34
9927: MUL
9928: PPUSH
9929: CALL 17397 0 2
// end ;
9933: LD_VAR 0 1
9937: RET
// every 2 2$1 do
9938: GO 9940
9940: DISABLE
// begin if Difficulty = 1 then
9941: LD_OWVAR 67
9945: PUSH
9946: LD_INT 1
9948: EQUAL
9949: IFFALSE 9953
// exit ;
9951: GO 9958
// zkontroluj_artefakt ;
9953: CALL 9733 0 0
// enable ;
9957: ENABLE
// end ;
9958: END
// export function amici_vezmi_doprovod ; var KolikChci , Volne , Vsechny , Dbl , I ; begin
9959: LD_INT 0
9961: PPUSH
9962: PPUSH
9963: PPUSH
9964: PPUSH
9965: PPUSH
9966: PPUSH
// Result = [ ] ;
9967: LD_ADDR_VAR 0 1
9971: PUSH
9972: EMPTY
9973: ST_TO_ADDR
// KolikChci = dif_JMMDoprovodPocet [ Difficulty ] ;
9974: LD_ADDR_VAR 0 2
9978: PUSH
9979: LD_EXP 39
9983: PUSH
9984: LD_OWVAR 67
9988: ARRAY
9989: ST_TO_ADDR
// Vsechny = Tanky diff Utok_Auta ;
9990: LD_ADDR_VAR 0 4
9994: PUSH
9995: LD_LOC 23
9999: PUSH
10000: LD_LOC 39
10004: DIFF
10005: ST_TO_ADDR
// Volne = UnitFilter ( Vsechny , [ [ F_CONTROL , CONTROL_COMPUTER ] ] ) ;
10006: LD_ADDR_VAR 0 3
10010: PUSH
10011: LD_VAR 0 4
10015: PPUSH
10016: LD_INT 33
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: PUSH
10026: EMPTY
10027: LIST
10028: PPUSH
10029: CALL_OW 72
10033: ST_TO_ADDR
// Dbl = UnitFilter ( Volne , [ [ F_WEAPON , US_DOUBLE_LASER ] ] ) ;
10034: LD_ADDR_VAR 0 5
10038: PUSH
10039: LD_VAR 0 3
10043: PPUSH
10044: LD_INT 34
10046: PUSH
10047: LD_INT 10
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PUSH
10054: EMPTY
10055: LIST
10056: PPUSH
10057: CALL_OW 72
10061: ST_TO_ADDR
// Volne = Volne diff Dbl ;
10062: LD_ADDR_VAR 0 3
10066: PUSH
10067: LD_VAR 0 3
10071: PUSH
10072: LD_VAR 0 5
10076: DIFF
10077: ST_TO_ADDR
// if Volne < KolikChci then
10078: LD_VAR 0 3
10082: PUSH
10083: LD_VAR 0 2
10087: LESS
10088: IFFALSE 10092
// exit ;
10090: GO 10155
// for I = 1 to KolikChci do
10092: LD_ADDR_VAR 0 6
10096: PUSH
10097: DOUBLE
10098: LD_INT 1
10100: DEC
10101: ST_TO_ADDR
10102: LD_VAR 0 2
10106: PUSH
10107: FOR_TO
10108: IFFALSE 10137
// Result = Result union [ Volne [ I ] ] ;
10110: LD_ADDR_VAR 0 1
10114: PUSH
10115: LD_VAR 0 1
10119: PUSH
10120: LD_VAR 0 3
10124: PUSH
10125: LD_VAR 0 6
10129: ARRAY
10130: PUSH
10131: EMPTY
10132: LIST
10133: UNION
10134: ST_TO_ADDR
10135: GO 10107
10137: POP
10138: POP
// Tanky = Tanky diff Result ;
10139: LD_ADDR_LOC 23
10143: PUSH
10144: LD_LOC 23
10148: PUSH
10149: LD_VAR 0 1
10153: DIFF
10154: ST_TO_ADDR
// end ;
10155: LD_VAR 0 1
10159: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne , Dbl ; begin
10160: LD_INT 0
10162: PPUSH
10163: PPUSH
10164: PPUSH
10165: PPUSH
10166: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
10167: LD_ADDR_VAR 0 2
10171: PUSH
10172: LD_EXP 40
10176: PUSH
10177: LD_OWVAR 67
10181: ARRAY
10182: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
10183: LD_ADDR_VAR 0 3
10187: PUSH
10188: LD_INT 1
10190: PPUSH
10191: LD_INT 100
10193: PPUSH
10194: CALL_OW 12
10198: ST_TO_ADDR
// if ( I < 25 ) then
10199: LD_VAR 0 3
10203: PUSH
10204: LD_INT 25
10206: LESS
10207: IFFALSE 10225
// KolikChci = KolikChci - 1 else
10209: LD_ADDR_VAR 0 2
10213: PUSH
10214: LD_VAR 0 2
10218: PUSH
10219: LD_INT 1
10221: MINUS
10222: ST_TO_ADDR
10223: GO 10259
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
10225: LD_VAR 0 3
10229: PUSH
10230: LD_INT 75
10232: GREATER
10233: PUSH
10234: LD_LOC 34
10238: PUSH
10239: LD_INT 1
10241: GREATER
10242: AND
10243: IFFALSE 10259
// KolikChci = KolikChci + 1 ;
10245: LD_ADDR_VAR 0 2
10249: PUSH
10250: LD_VAR 0 2
10254: PUSH
10255: LD_INT 1
10257: PLUS
10258: ST_TO_ADDR
// Riditelne = [ ] ;
10259: LD_ADDR_VAR 0 4
10263: PUSH
10264: EMPTY
10265: ST_TO_ADDR
// for I in Tanky do
10266: LD_ADDR_VAR 0 3
10270: PUSH
10271: LD_LOC 23
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10363
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
10279: LD_VAR 0 3
10283: PPUSH
10284: CALL_OW 263
10288: PUSH
10289: LD_INT 1
10291: EQUAL
10292: PUSH
10293: LD_VAR 0 3
10297: PPUSH
10298: CALL_OW 311
10302: NOT
10303: AND
10304: IFFALSE 10308
// continue ;
10306: GO 10276
// if ( GetWeapon ( I ) = US_CARGO_BAY ) then
10308: LD_VAR 0 3
10312: PPUSH
10313: CALL_OW 264
10317: PUSH
10318: LD_INT 12
10320: EQUAL
10321: IFFALSE 10325
// continue ;
10323: GO 10276
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
10325: LD_VAR 0 3
10329: PPUSH
10330: CALL_OW 256
10334: PUSH
10335: LD_INT 1000
10337: LESS
10338: IFFALSE 10342
// continue ;
10340: GO 10276
// Riditelne = Riditelne union [ I ] ;
10342: LD_ADDR_VAR 0 4
10346: PUSH
10347: LD_VAR 0 4
10351: PUSH
10352: LD_VAR 0 3
10356: PUSH
10357: EMPTY
10358: LIST
10359: UNION
10360: ST_TO_ADDR
// end ;
10361: GO 10276
10363: POP
10364: POP
// Dbl = UnitFilter ( Riditelne , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_WEAPON , US_DOUBLE_LASER ] ] ) ;
10365: LD_ADDR_VAR 0 5
10369: PUSH
10370: LD_VAR 0 4
10374: PPUSH
10375: LD_INT 21
10377: PUSH
10378: LD_INT 2
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PUSH
10385: LD_INT 34
10387: PUSH
10388: LD_INT 10
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 72
10403: ST_TO_ADDR
// Riditelne = Riditelne diff Dbl ;
10404: LD_ADDR_VAR 0 4
10408: PUSH
10409: LD_VAR 0 4
10413: PUSH
10414: LD_VAR 0 5
10418: DIFF
10419: ST_TO_ADDR
// if ( Dbl >= 2 ) then
10420: LD_VAR 0 5
10424: PUSH
10425: LD_INT 2
10427: GREATEREQUAL
10428: IFFALSE 10463
// begin Riditelne = [ Dbl [ 1 ] , Dbl [ 2 ] ] ^ Riditelne ;
10430: LD_ADDR_VAR 0 4
10434: PUSH
10435: LD_VAR 0 5
10439: PUSH
10440: LD_INT 1
10442: ARRAY
10443: PUSH
10444: LD_VAR 0 5
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PUSH
10457: LD_VAR 0 4
10461: ADD
10462: ST_TO_ADDR
// end ; if ( CisloUtoku = 1 ) and ( KolikChci > Riditelne ) then
10463: LD_LOC 34
10467: PUSH
10468: LD_INT 1
10470: EQUAL
10471: PUSH
10472: LD_VAR 0 2
10476: PUSH
10477: LD_VAR 0 4
10481: GREATER
10482: AND
10483: IFFALSE 10497
// Result = Riditelne else
10485: LD_ADDR_VAR 0 1
10489: PUSH
10490: LD_VAR 0 4
10494: ST_TO_ADDR
10495: GO 10569
// if Riditelne >= KolikChci then
10497: LD_VAR 0 4
10501: PUSH
10502: LD_VAR 0 2
10506: GREATEREQUAL
10507: IFFALSE 10562
// begin Result = [ ] ;
10509: LD_ADDR_VAR 0 1
10513: PUSH
10514: EMPTY
10515: ST_TO_ADDR
// for I = 1 to KolikChci do
10516: LD_ADDR_VAR 0 3
10520: PUSH
10521: DOUBLE
10522: LD_INT 1
10524: DEC
10525: ST_TO_ADDR
10526: LD_VAR 0 2
10530: PUSH
10531: FOR_TO
10532: IFFALSE 10558
// Result = Result union Riditelne [ I ] ;
10534: LD_ADDR_VAR 0 1
10538: PUSH
10539: LD_VAR 0 1
10543: PUSH
10544: LD_VAR 0 4
10548: PUSH
10549: LD_VAR 0 3
10553: ARRAY
10554: UNION
10555: ST_TO_ADDR
10556: GO 10531
10558: POP
10559: POP
// end else
10560: GO 10569
// Result = [ ] ;
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: EMPTY
10568: ST_TO_ADDR
// if Prob ( 50 ) and ( Obranci > 4 ) then
10569: LD_INT 50
10571: PPUSH
10572: CALL_OW 13
10576: PUSH
10577: LD_LOC 17
10581: PUSH
10582: LD_INT 4
10584: GREATER
10585: AND
10586: IFFALSE 10641
// for I = 1 to Rand ( 1 , 2 ) do
10588: LD_ADDR_VAR 0 3
10592: PUSH
10593: DOUBLE
10594: LD_INT 1
10596: DEC
10597: ST_TO_ADDR
10598: LD_INT 1
10600: PPUSH
10601: LD_INT 2
10603: PPUSH
10604: CALL_OW 12
10608: PUSH
10609: FOR_TO
10610: IFFALSE 10639
// Result = Result union [ Obranci [ I ] ] ;
10612: LD_ADDR_VAR 0 1
10616: PUSH
10617: LD_VAR 0 1
10621: PUSH
10622: LD_LOC 17
10626: PUSH
10627: LD_VAR 0 3
10631: ARRAY
10632: PUSH
10633: EMPTY
10634: LIST
10635: UNION
10636: ST_TO_ADDR
10637: GO 10609
10639: POP
10640: POP
// end ;
10641: LD_VAR 0 1
10645: RET
// function zacni_utok ; var Area , I , Prio ; begin
10646: LD_INT 0
10648: PPUSH
10649: PPUSH
10650: PPUSH
10651: PPUSH
// ProbihaUtok = true ;
10652: LD_ADDR_LOC 33
10656: PUSH
10657: LD_INT 1
10659: ST_TO_ADDR
// MakroUtokMove = McMove ( 11 , Utok_Auta , [ [ 135 , 15 ] , [ 142 , 40 ] , [ 156 , 56 ] ] , [ MC_MOVE_DONTCAPTURE ] ) ;
10660: LD_ADDR_LOC 50
10664: PUSH
10665: LD_INT 11
10667: PPUSH
10668: LD_LOC 39
10672: PPUSH
10673: LD_INT 135
10675: PUSH
10676: LD_INT 15
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 142
10685: PUSH
10686: LD_INT 40
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 156
10695: PUSH
10696: LD_INT 56
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: LIST
10707: PPUSH
10708: LD_INT 5
10710: PUSH
10711: EMPTY
10712: LIST
10713: PPUSH
10714: CALL_OW 398
10718: ST_TO_ADDR
// end ;
10719: LD_VAR 0 1
10723: RET
// function rozeber_konvoj ; var I , F ; begin
10724: LD_INT 0
10726: PPUSH
10727: PPUSH
10728: PPUSH
// if KonvojBylRozebran then
10729: LD_LOC 44
10733: IFFALSE 10737
// exit ;
10735: GO 10791
// KonvojBylRozebran = true ;
10737: LD_ADDR_LOC 44
10741: PUSH
10742: LD_INT 1
10744: ST_TO_ADDR
// Tanky = Tanky union Doprovod ;
10745: LD_ADDR_LOC 23
10749: PUSH
10750: LD_LOC 23
10754: PUSH
10755: LD_LOC 22
10759: UNION
10760: ST_TO_ADDR
// Doprovod = [ ] ;
10761: LD_ADDR_LOC 22
10765: PUSH
10766: EMPTY
10767: ST_TO_ADDR
// RozebratAuta = RozebratAuta union Konvoj ;
10768: LD_ADDR_LOC 45
10772: PUSH
10773: LD_LOC 45
10777: PUSH
10778: LD_LOC 21
10782: UNION
10783: ST_TO_ADDR
// Konvoj = [ ] ;
10784: LD_ADDR_LOC 21
10788: PUSH
10789: EMPTY
10790: ST_TO_ADDR
// end ;
10791: LD_VAR 0 1
10795: RET
// every 0 0$5.3 trigger ProbihaPrevoz = 0 marked 22 do
10796: LD_LOC 29
10800: PUSH
10801: LD_INT 0
10803: EQUAL
10804: IFFALSE 10813
10806: GO 10808
10808: DISABLE
// begin rozeber_konvoj ;
10809: CALL 10724 0 0
// end ;
10813: END
// function vrat_utok ; var I ; begin
10814: LD_INT 0
10816: PPUSH
10817: PPUSH
// ProbihaUtok = false ;
10818: LD_ADDR_LOC 33
10822: PUSH
10823: LD_INT 0
10825: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
10826: LD_ADDR_LOC 34
10830: PUSH
10831: LD_LOC 34
10835: PUSH
10836: LD_INT 1
10838: PLUS
10839: ST_TO_ADDR
// MakroUtok = 0 ;
10840: LD_ADDR_LOC 49
10844: PUSH
10845: LD_INT 0
10847: ST_TO_ADDR
// MakroUtokMove = 0 ;
10848: LD_ADDR_LOC 50
10852: PUSH
10853: LD_INT 0
10855: ST_TO_ADDR
// AddComMoveToArea ( Utok_Auta , Parkoviste ) ;
10856: LD_LOC 39
10860: PPUSH
10861: LD_INT 3
10863: PPUSH
10864: CALL_OW 173
// end ;
10868: LD_VAR 0 1
10872: RET
// export function amici_McAttackDone ( McId , Un ) ; begin
10873: LD_INT 0
10875: PPUSH
// vrat_utok ;
10876: CALL 10814 0 0
// end ;
10880: LD_VAR 0 3
10884: RET
// function zjisti_cas_utoku ; begin
10885: LD_INT 0
10887: PPUSH
// if CasyUtoku then
10888: LD_LOC 38
10892: IFFALSE 10938
// begin Result = CasyUtoku [ 1 ] ;
10894: LD_ADDR_VAR 0 1
10898: PUSH
10899: LD_LOC 38
10903: PUSH
10904: LD_INT 1
10906: ARRAY
10907: ST_TO_ADDR
// if CasyUtoku > 1 then
10908: LD_LOC 38
10912: PUSH
10913: LD_INT 1
10915: GREATER
10916: IFFALSE 10936
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
10918: LD_ADDR_LOC 38
10922: PUSH
10923: LD_LOC 38
10927: PPUSH
10928: LD_INT 1
10930: PPUSH
10931: CALL_OW 3
10935: ST_TO_ADDR
// end else
10936: GO 10946
// Result = 5 ;
10938: LD_ADDR_VAR 0 1
10942: PUSH
10943: LD_INT 5
10945: ST_TO_ADDR
// end ;
10946: LD_VAR 0 1
10950: RET
// function utoceni_splneny_predpoklady ; begin
10951: LD_INT 0
10953: PPUSH
// Result = VidelRusa or ( Tick > 12 12$0 ) ;
10954: LD_ADDR_VAR 0 1
10958: PUSH
10959: LD_LOC 32
10963: PUSH
10964: LD_OWVAR 1
10968: PUSH
10969: LD_INT 25200
10971: GREATER
10972: OR
10973: ST_TO_ADDR
// if not ZnicenSib and not ZnicenOil and ( Tick < 15 15$0 ) then
10974: LD_LOC 43
10978: NOT
10979: PUSH
10980: LD_LOC 42
10984: NOT
10985: AND
10986: PUSH
10987: LD_OWVAR 1
10991: PUSH
10992: LD_INT 31500
10994: LESS
10995: AND
10996: IFFALSE 11006
// Result = false ;
10998: LD_ADDR_VAR 0 1
11002: PUSH
11003: LD_INT 0
11005: ST_TO_ADDR
// if Prob ( 25 ) then
11006: LD_INT 25
11008: PPUSH
11009: CALL_OW 13
11013: IFFALSE 11023
// Result = false ;
11015: LD_ADDR_VAR 0 1
11019: PUSH
11020: LD_INT 0
11022: ST_TO_ADDR
// end ;
11023: LD_VAR 0 1
11027: RET
// function casovac_utok ; begin
11028: LD_INT 0
11030: PPUSH
// if ProbihaUtok then
11031: LD_LOC 33
11035: IFFALSE 11039
// exit ;
11037: GO 11164
// if Utok_ZbyvaMinut = - 1 then
11039: LD_LOC 37
11043: PUSH
11044: LD_INT 1
11046: NEG
11047: EQUAL
11048: IFFALSE 11060
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
11050: LD_ADDR_LOC 37
11054: PUSH
11055: CALL 10885 0 0
11059: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
11060: LD_LOC 37
11064: PUSH
11065: LD_INT 0
11067: GREATER
11068: IFFALSE 11084
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
11070: LD_ADDR_LOC 37
11074: PUSH
11075: LD_LOC 37
11079: PUSH
11080: LD_INT 1
11082: MINUS
11083: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
11084: CALL 10951 0 0
11088: NOT
11089: IFFALSE 11093
// exit ;
11091: GO 11164
// if Utok_ZbyvaMinut > 0 then
11093: LD_LOC 37
11097: PUSH
11098: LD_INT 0
11100: GREATER
11101: IFFALSE 11105
// exit ;
11103: GO 11164
// if not ZacalyUtoky then
11105: LD_LOC 36
11109: NOT
11110: IFFALSE 11123
// begin enable ( 22 ) ;
11112: LD_INT 22
11114: ENABLE_MARKED
// ZacalyUtoky = true ;
11115: LD_ADDR_LOC 36
11119: PUSH
11120: LD_INT 1
11122: ST_TO_ADDR
// end ; if ProbihaPrevoz then
11123: LD_LOC 29
11127: IFFALSE 11131
// exit ;
11129: GO 11164
// Utok_Auta = zjisti_auta_na_utok ;
11131: LD_ADDR_LOC 39
11135: PUSH
11136: CALL 10160 0 0
11140: ST_TO_ADDR
// if not Utok_Auta then
11141: LD_LOC 39
11145: NOT
11146: IFFALSE 11150
// exit ;
11148: GO 11164
// zacni_utok ;
11150: CALL 10646 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
11154: LD_ADDR_LOC 37
11158: PUSH
11159: CALL 10885 0 0
11163: ST_TO_ADDR
// end ;
11164: LD_VAR 0 1
11168: RET
// every 0 0$45 marked 21 do
11169: GO 11171
11171: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
11172: LD_INT 0
11174: PPUSH
11175: LD_INT 1050
11177: PPUSH
11178: CALL_OW 12
11182: PPUSH
11183: CALL_OW 67
// casovac_utok ;
11187: CALL 11028 0 0
// enable ;
11191: ENABLE
// end ;
11192: END
// every 0 0$30 do
11193: GO 11195
11195: DISABLE
// begin Wait ( 1 1$0 * Rand ( PrvniUtok [ 1 ] , PrvniUtok [ 2 ] ) ) ;
11196: LD_INT 2100
11198: PUSH
11199: LD_LOC 35
11203: PUSH
11204: LD_INT 1
11206: ARRAY
11207: PPUSH
11208: LD_LOC 35
11212: PUSH
11213: LD_INT 2
11215: ARRAY
11216: PPUSH
11217: CALL_OW 12
11221: MUL
11222: PPUSH
11223: CALL_OW 67
// enable ( 21 ) ;
11227: LD_INT 21
11229: ENABLE_MARKED
// end ;
11230: END
// function opravuj ; begin
11231: LD_INT 0
11233: PPUSH
// if KdoOpravuje then
11234: LD_LOC 41
11238: IFFALSE 11242
// exit ;
11240: GO 11294
// KdoOpravuje = opravuj_auta ( [ AmMech1 , AmMech2 , AmMech3 , AmMech4 ] , 114 , Americani , side_Am , Utok_Auta ) ;
11242: LD_ADDR_LOC 41
11246: PUSH
11247: LD_LOC 9
11251: PUSH
11252: LD_LOC 10
11256: PUSH
11257: LD_LOC 11
11261: PUSH
11262: LD_LOC 12
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: PPUSH
11273: LD_INT 114
11275: PPUSH
11276: LD_INT 2
11278: PPUSH
11279: LD_EXP 2
11283: PPUSH
11284: LD_LOC 39
11288: PPUSH
11289: CALL 16467 0 5
11293: ST_TO_ADDR
// end ;
11294: LD_VAR 0 1
11298: RET
// function kuryruj ; begin
11299: LD_INT 0
11301: PPUSH
// if KdoLeci then
11302: LD_LOC 40
11306: IFFALSE 11310
// exit ;
11308: GO 11357
// KdoLeci = kuryruj_lidi ( [ AmSci1 , AmSci2 , AmSci3 , AmSci4 ] , 113 , Americani , side_Am ) ;
11310: LD_ADDR_LOC 40
11314: PUSH
11315: LD_LOC 5
11319: PUSH
11320: LD_LOC 6
11324: PUSH
11325: LD_LOC 7
11329: PUSH
11330: LD_LOC 8
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: LIST
11339: LIST
11340: PPUSH
11341: LD_INT 113
11343: PPUSH
11344: LD_INT 2
11346: PPUSH
11347: LD_EXP 2
11351: PPUSH
11352: CALL 16769 0 4
11356: ST_TO_ADDR
// end ;
11357: LD_VAR 0 1
11361: RET
// export function event_AmiciOprava ( Event ) ; var Kdo ; begin
11362: LD_INT 0
11364: PPUSH
11365: PPUSH
// case Event of 113 :
11366: LD_VAR 0 1
11370: PUSH
11371: LD_INT 113
11373: DOUBLE
11374: EQUAL
11375: IFTRUE 11379
11377: GO 11415
11379: POP
// begin for Kdo in KdoLeci do
11380: LD_ADDR_VAR 0 3
11384: PUSH
11385: LD_LOC 40
11389: PUSH
11390: FOR_IN
11391: IFFALSE 11404
// zpet_domu ( Kdo ) ;
11393: LD_VAR 0 3
11397: PPUSH
11398: CALL 6127 0 1
11402: GO 11390
11404: POP
11405: POP
// KdoLeci = [ ] ;
11406: LD_ADDR_LOC 40
11410: PUSH
11411: EMPTY
11412: ST_TO_ADDR
// end ; 114 :
11413: GO 11460
11415: LD_INT 114
11417: DOUBLE
11418: EQUAL
11419: IFTRUE 11423
11421: GO 11459
11423: POP
// begin for Kdo in KdoOpravuje do
11424: LD_ADDR_VAR 0 3
11428: PUSH
11429: LD_LOC 41
11433: PUSH
11434: FOR_IN
11435: IFFALSE 11448
// zpet_domu ( Kdo ) ;
11437: LD_VAR 0 3
11441: PPUSH
11442: CALL 6127 0 1
11446: GO 11434
11448: POP
11449: POP
// KdoOpravuje = [ ] ;
11450: LD_ADDR_LOC 41
11454: PUSH
11455: EMPTY
11456: ST_TO_ADDR
// end ; end ;
11457: GO 11460
11459: POP
// end ;
11460: LD_VAR 0 2
11464: RET
// every 0 0$57 do
11465: GO 11467
11467: DISABLE
// begin opravuj ;
11468: CALL 11231 0 0
// kuryruj ;
11472: CALL 11299 0 0
// enable ;
11476: ENABLE
// end ;
11477: END
// every 0 0$7.1 do
11478: GO 11480
11480: DISABLE
// begin if zije_zakladna ( side_Am , AmDepot_Oil , Americani_Oil , Obranci_Oil ) then
11481: LD_EXP 2
11485: PPUSH
11486: LD_INT 1
11488: PPUSH
11489: LD_INT 19
11491: PPUSH
11492: LD_LOC 18
11496: PPUSH
11497: CALL 17057 0 4
11501: IFFALSE 11506
// enable else
11503: ENABLE
11504: GO 11514
// ZnicenOil = true ;
11506: LD_ADDR_LOC 42
11510: PUSH
11511: LD_INT 1
11513: ST_TO_ADDR
// end ;
11514: END
// every 0 0$7.9 do
11515: GO 11517
11517: DISABLE
// begin if zije_zakladna ( side_Am , AmDepot_Sib , Americani_Sib , Obranci_Sib ) then
11518: LD_EXP 2
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: LD_INT 20
11528: PPUSH
11529: LD_LOC 19
11533: PPUSH
11534: CALL 17057 0 4
11538: IFFALSE 11543
// enable else
11540: ENABLE
11541: GO 11551
// ZnicenSib = true ;
11543: LD_ADDR_LOC 43
11547: PUSH
11548: LD_INT 1
11550: ST_TO_ADDR
// end ;
11551: END
// function zkontroluj_suroviny ( Mat , Amount ) ; var Base , Inz ; begin
11552: LD_INT 0
11554: PPUSH
11555: PPUSH
11556: PPUSH
// if not IsOk ( AmDepot ) then
11557: LD_INT 15
11559: PPUSH
11560: CALL_OW 302
11564: NOT
11565: IFFALSE 11569
// exit ;
11567: GO 11724
// Base = GetBase ( AmDepot ) ;
11569: LD_ADDR_VAR 0 4
11573: PUSH
11574: LD_INT 15
11576: PPUSH
11577: CALL_OW 274
11581: ST_TO_ADDR
// if GetResourceType ( Base , Mat ) >= Amount then
11582: LD_VAR 0 4
11586: PPUSH
11587: LD_VAR 0 1
11591: PPUSH
11592: CALL_OW 275
11596: PUSH
11597: LD_VAR 0 2
11601: GREATEREQUAL
11602: IFFALSE 11606
// exit ;
11604: GO 11724
// Inz = FilterUnitsInArea ( Americani , [ [ F_SIDE , side_Am ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
11606: LD_ADDR_VAR 0 5
11610: PUSH
11611: LD_INT 2
11613: PPUSH
11614: LD_INT 22
11616: PUSH
11617: LD_EXP 2
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 21
11628: PUSH
11629: LD_INT 1
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: LD_INT 25
11638: PUSH
11639: LD_INT 2
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: LIST
11650: PPUSH
11651: CALL_OW 70
11655: ST_TO_ADDR
// if Inz and ( GetListOfCratesInArea ( Americani ) < 15 ) then
11656: LD_VAR 0 5
11660: PUSH
11661: LD_INT 2
11663: PPUSH
11664: CALL_OW 435
11668: PUSH
11669: LD_INT 15
11671: LESS
11672: AND
11673: IFFALSE 11707
// begin CreateResourcesArea ( Mat , 5 , BednyAmericani , true ) ;
11675: LD_VAR 0 1
11679: PPUSH
11680: LD_INT 5
11682: PPUSH
11683: LD_INT 22
11685: PPUSH
11686: LD_INT 1
11688: PPUSH
11689: CALL_OW 59
// sbirej_bedny ( Inz , BednyAmericani ) ;
11693: LD_VAR 0 5
11697: PPUSH
11698: LD_INT 22
11700: PPUSH
11701: CALL 16237 0 2
// end else
11705: GO 11724
// begin AddResourceType ( Base , Mat , 50 ) ;
11707: LD_VAR 0 4
11711: PPUSH
11712: LD_VAR 0 1
11716: PPUSH
11717: LD_INT 50
11719: PPUSH
11720: CALL_OW 276
// end ; end ;
11724: LD_VAR 0 3
11728: RET
// every 2 2$12 do
11729: GO 11731
11731: DISABLE
// begin zkontroluj_suroviny ( MAT_CANS , 250 ) ;
11732: LD_INT 1
11734: PPUSH
11735: LD_INT 250
11737: PPUSH
11738: CALL 11552 0 2
// zkontroluj_suroviny ( MAT_SIBERIT , 50 ) ;
11742: LD_INT 3
11744: PPUSH
11745: LD_INT 50
11747: PPUSH
11748: CALL 11552 0 2
// zkontroluj_suroviny ( MAT_OIL , 150 ) ;
11752: LD_INT 2
11754: PPUSH
11755: LD_INT 150
11757: PPUSH
11758: CALL 11552 0 2
// enable ;
11762: ENABLE
// end ;
11763: END
// every 0 0$17 trigger RozebratAuta do var F , Hotovo , I ;
11764: LD_LOC 45
11768: IFFALSE 11930
11770: GO 11772
11772: DISABLE
11773: LD_INT 0
11775: PPUSH
11776: PPUSH
11777: PPUSH
// begin F = UnitFilter ( [ AmFactGun , AmFactRock ] , [ [ F_SIDE , side_Am ] , [ F_OK ] ] ) ;
11778: LD_ADDR_VAR 0 1
11782: PUSH
11783: LD_INT 30
11785: PUSH
11786: LD_INT 26
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PPUSH
11793: LD_INT 22
11795: PUSH
11796: LD_EXP 2
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 50
11807: PUSH
11808: EMPTY
11809: LIST
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: PPUSH
11815: CALL_OW 72
11819: ST_TO_ADDR
// if F then
11820: LD_VAR 0 1
11824: IFFALSE 11929
// begin Hotovo = [ ] ;
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: EMPTY
11832: ST_TO_ADDR
// for I in RozebratAuta do
11833: LD_ADDR_VAR 0 3
11837: PUSH
11838: LD_LOC 45
11842: PUSH
11843: FOR_IN
11844: IFFALSE 11911
// begin if IsDead ( I ) then
11846: LD_VAR 0 3
11850: PPUSH
11851: CALL_OW 301
11855: IFFALSE 11878
// Hotovo = Hotovo union [ I ] else
11857: LD_ADDR_VAR 0 2
11861: PUSH
11862: LD_VAR 0 2
11866: PUSH
11867: LD_VAR 0 3
11871: PUSH
11872: EMPTY
11873: LIST
11874: UNION
11875: ST_TO_ADDR
11876: GO 11909
// if not HasTask ( I ) then
11878: LD_VAR 0 3
11882: PPUSH
11883: CALL_OW 314
11887: NOT
11888: IFFALSE 11909
// ComRecycle ( I , nahoda_seznam ( F ) ) ;
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 1
11899: PPUSH
11900: CALL 17253 0 1
11904: PPUSH
11905: CALL_OW 168
// end ;
11909: GO 11843
11911: POP
11912: POP
// RozebratAuta = RozebratAuta diff Hotovo ;
11913: LD_ADDR_LOC 45
11917: PUSH
11918: LD_LOC 45
11922: PUSH
11923: LD_VAR 0 2
11927: DIFF
11928: ST_TO_ADDR
// end ; enable ;
11929: ENABLE
// end ; end_of_file
11930: PPOPN 3
11932: END
// export dif_BednyStart , dif_BednyRZ , dif_BednyRV ; export dif_CekamJMM , dif_JMMDoprovodPocet ; export dif_UtokSkupina , dif_PrvniUtok , dif_CasovacUtoku ; export dif_ArtefaktDoba ; export function init_difficulty ; begin
11933: LD_INT 0
11935: PPUSH
// dif_BednyRZ = [ 10 , 8 , 6 ] ;
11936: LD_ADDR_EXP 36
11940: PUSH
11941: LD_INT 10
11943: PUSH
11944: LD_INT 8
11946: PUSH
11947: LD_INT 6
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: LIST
11954: ST_TO_ADDR
// dif_BednyRV = [ 10 , 8 , 6 ] ;
11955: LD_ADDR_EXP 37
11959: PUSH
11960: LD_INT 10
11962: PUSH
11963: LD_INT 8
11965: PUSH
11966: LD_INT 6
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: LIST
11973: ST_TO_ADDR
// dif_BednyStart = [ 6 , 5 , 4 ] ;
11974: LD_ADDR_EXP 35
11978: PUSH
11979: LD_INT 6
11981: PUSH
11982: LD_INT 5
11984: PUSH
11985: LD_INT 4
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: LIST
11992: ST_TO_ADDR
// dif_CekamJMM = [ [ 24 24$0 , 28 28$0 ] , [ 20 20$0 , 24 24$0 ] , [ 16 16$0 , 20 20$0 ] ] ;
11993: LD_ADDR_EXP 38
11997: PUSH
11998: LD_INT 50400
12000: PUSH
12001: LD_INT 58800
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 42000
12010: PUSH
12011: LD_INT 50400
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 33600
12020: PUSH
12021: LD_INT 42000
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: LIST
12032: ST_TO_ADDR
// dif_JMMDoprovodPocet = [ 2 , 3 , 5 ] ;
12033: LD_ADDR_EXP 39
12037: PUSH
12038: LD_INT 2
12040: PUSH
12041: LD_INT 3
12043: PUSH
12044: LD_INT 5
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: LIST
12051: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_INT 3
12059: PUSH
12060: LD_INT 4
12062: PUSH
12063: LD_INT 6
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: LIST
12070: ST_TO_ADDR
// dif_PrvniUtok = [ [ 6 , 8 ] , [ 4 , 5 ] , [ 3 , 7 ] ] ;
12071: LD_ADDR_EXP 41
12075: PUSH
12076: LD_INT 6
12078: PUSH
12079: LD_INT 8
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PUSH
12086: LD_INT 4
12088: PUSH
12089: LD_INT 5
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: LD_INT 3
12098: PUSH
12099: LD_INT 7
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: LIST
12110: ST_TO_ADDR
// dif_CasovacUtoku = [ [ 10 , 8 ] , [ 8 , 8 , 7 ] , [ 6 , 5 , 5 ] ] ;
12111: LD_ADDR_EXP 42
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: LD_INT 8
12121: PUSH
12122: EMPTY
12123: LIST
12124: LIST
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: LD_INT 8
12131: PUSH
12132: LD_INT 7
12134: PUSH
12135: EMPTY
12136: LIST
12137: LIST
12138: LIST
12139: PUSH
12140: LD_INT 6
12142: PUSH
12143: LD_INT 5
12145: PUSH
12146: LD_INT 5
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: LIST
12158: ST_TO_ADDR
// dif_ArtefaktDoba = [ 250 , 400 , 600 ] ;
12159: LD_ADDR_EXP 43
12163: PUSH
12164: LD_INT 250
12166: PUSH
12167: LD_INT 400
12169: PUSH
12170: LD_INT 600
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: ST_TO_ADDR
// end ; end_of_file
12178: LD_VAR 0 1
12182: RET
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
12183: LD_VAR 0 1
12187: PPUSH
12188: CALL 2804 0 1
// amici_UnitDestroyed ( Un ) ;
12192: LD_VAR 0 1
12196: PPUSH
12197: CALL 7450 0 1
// jmm_UnitDestroyed ( Un ) ;
12201: LD_VAR 0 1
12205: PPUSH
12206: CALL 14206 0 1
// end ;
12210: PPOPN 1
12212: END
// on VehicleConstructed ( Veh , Fact ) do begin amici_VehicleConstructed ( Veh , Fact ) ;
12213: LD_VAR 0 1
12217: PPUSH
12218: LD_VAR 0 2
12222: PPUSH
12223: CALL 6876 0 2
// rusove_VehicleConstructed ( Veh , Fact ) ;
12227: LD_VAR 0 1
12231: PPUSH
12232: LD_VAR 0 2
12236: PPUSH
12237: CALL 3995 0 2
// end ;
12241: PPOPN 2
12243: END
// on WeaponPlaced ( Build , Fact ) do begin rusove_WeaponPlaced ( Build , Fact ) ;
12244: LD_VAR 0 1
12248: PPUSH
12249: LD_VAR 0 2
12253: PPUSH
12254: CALL 4039 0 2
// end ;
12258: PPOPN 2
12260: END
// on SpecResearchComplete ( Lab ) do begin rusove_SpecResearchComplete ( Lab ) ;
12261: LD_VAR 0 1
12265: PPUSH
12266: CALL 4743 0 1
// end ;
12270: PPOPN 1
12272: END
// on SpecResearchCancel ( Lab , Progress ) do begin rusove_SpecResearchCancel ( Lab , Progress ) ;
12273: LD_VAR 0 1
12277: PPUSH
12278: LD_VAR 0 2
12282: PPUSH
12283: CALL 3589 0 2
// end ;
12287: PPOPN 2
12289: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin amici_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
12290: LD_VAR 0 1
12294: PPUSH
12295: LD_VAR 0 2
12299: PPUSH
12300: LD_VAR 0 3
12304: PPUSH
12305: LD_VAR 0 4
12309: PPUSH
12310: CALL 7467 0 4
// rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
12314: LD_VAR 0 1
12318: PPUSH
12319: LD_VAR 0 2
12323: PPUSH
12324: LD_VAR 0 3
12328: PPUSH
12329: LD_VAR 0 4
12333: PPUSH
12334: CALL 5157 0 4
// end ;
12338: PPOPN 4
12340: END
// on SailEvent ( Event ) do begin case Event of 102 :
12341: LD_VAR 0 1
12345: PUSH
12346: LD_INT 102
12348: DOUBLE
12349: EQUAL
12350: IFTRUE 12354
12352: GO 12361
12354: POP
// event_ArtefactStolen ; 111 :
12355: CALL 4416 0 0
12359: GO 12403
12361: LD_INT 111
12363: DOUBLE
12364: EQUAL
12365: IFTRUE 12369
12367: GO 12376
12369: POP
// event_KradenikPredKradenim ; 113 , 114 :
12370: CALL 9898 0 0
12374: GO 12403
12376: LD_INT 113
12378: DOUBLE
12379: EQUAL
12380: IFTRUE 12390
12382: LD_INT 114
12384: DOUBLE
12385: EQUAL
12386: IFTRUE 12390
12388: GO 12402
12390: POP
// event_AmiciOprava ( Event ) ; end ;
12391: LD_VAR 0 1
12395: PPUSH
12396: CALL 11362 0 1
12400: GO 12403
12402: POP
// end ;
12403: PPOPN 1
12405: END
// on UpgradeComplete ( Build ) do begin rusove_UpgradeComplete ( Build ) ;
12406: LD_VAR 0 1
12410: PPUSH
12411: CALL 3314 0 1
// end ;
12415: PPOPN 1
12417: END
// on ResearchComplete ( Tech , Lab ) do begin rusove_ResearchComplete ( Tech , Lab ) ;
12418: LD_VAR 0 1
12422: PPUSH
12423: LD_VAR 0 2
12427: PPUSH
12428: CALL 3446 0 2
// end ;
12432: PPOPN 2
12434: END
// on ResearchStarted ( Tech , Lab ) do begin rusove_ResearchStarted ( Tech , Lab ) ;
12435: LD_VAR 0 1
12439: PPUSH
12440: LD_VAR 0 2
12444: PPUSH
12445: CALL 3520 0 2
// end ;
12449: PPOPN 2
12451: END
// on ResearchCancel ( Tech , Lab ) do begin rusove_ResearchCancel ( Tech , Lab ) ;
12452: LD_VAR 0 1
12456: PPUSH
12457: LD_VAR 0 2
12461: PPUSH
12462: CALL 3551 0 2
// end ;
12466: PPOPN 2
12468: END
// on BuildingStarted ( Build , Hum ) do begin rusove_BuildingStarted ( Build , Hum ) ;
12469: LD_VAR 0 1
12473: PPUSH
12474: LD_VAR 0 2
12478: PPUSH
12479: CALL 2947 0 2
// end ;
12483: PPOPN 2
12485: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin amici_BuildingCaptured ( Build , OrigSide , Eng ) ;
12486: LD_VAR 0 1
12490: PPUSH
12491: LD_VAR 0 2
12495: PPUSH
12496: LD_VAR 0 3
12500: PPUSH
12501: CALL 7496 0 3
// end ;
12505: PPOPN 3
12507: END
// on ArtifactLoaded ( Un , Size ) do begin rusove_ArtifactLoaded ( Un , Size ) ;
12508: LD_VAR 0 1
12512: PPUSH
12513: LD_VAR 0 2
12517: PPUSH
12518: CALL 4335 0 2
// end ;
12522: PPOPN 2
12524: END
// on ArtifactUnloaded ( Un , Size ) do begin rusove_ArtifactUnloaded ( Un , Size ) ;
12525: LD_VAR 0 1
12529: PPUSH
12530: LD_VAR 0 2
12534: PPUSH
12535: CALL 4501 0 2
// end ;
12539: PPOPN 2
12541: END
// on ArtifactUsed ( Side , Number , P1 , P2 ) do begin rusove_ArtifactUsed ( Side , Number , P1 , P2 ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: LD_VAR 0 2
12551: PPUSH
12552: LD_VAR 0 3
12556: PPUSH
12557: LD_VAR 0 4
12561: PPUSH
12562: CALL 4768 0 4
// end ;
12566: PPOPN 4
12568: END
// on McAttackDone ( McId , Un ) do begin amici_McAttackDone ( McId , Un ) ;
12569: LD_VAR 0 1
12573: PPUSH
12574: LD_VAR 0 2
12578: PPUSH
12579: CALL 10873 0 2
// end ;
12583: PPOPN 2
12585: END
// on McDone ( McId , State ) do begin amici_McDone ( McId , State ) ;
12586: LD_VAR 0 1
12590: PPUSH
12591: LD_VAR 0 2
12595: PPUSH
12596: CALL 8623 0 2
// end ;
12600: PPOPN 2
12602: END
// on EvacuateVehicle ( Hum , Veh , Unk1 , Unk2 ) do begin jmm_EvacuateVehicle ( Hum , Veh ) ;
12603: LD_VAR 0 1
12607: PPUSH
12608: LD_VAR 0 2
12612: PPUSH
12613: CALL 14376 0 2
// end ;
12617: PPOPN 4
12619: END
// every 1 1$59 do
12620: GO 12622
12622: DISABLE
// begin RandomizeAll ;
12623: CALL_OW 11
// end ; end_of_file
12627: END
// var BednyRZ , BednyRV ; export function init_suroviny ; var I ; begin
12628: LD_INT 0
12630: PPUSH
12631: PPUSH
// BednyRZ = dif_BednyRZ [ Difficulty ] ;
12632: LD_ADDR_LOC 53
12636: PUSH
12637: LD_EXP 36
12641: PUSH
12642: LD_OWVAR 67
12646: ARRAY
12647: ST_TO_ADDR
// BednyRV = dif_BednyRV [ Difficulty ] ;
12648: LD_ADDR_LOC 54
12652: PUSH
12653: LD_EXP 37
12657: PUSH
12658: LD_OWVAR 67
12662: ARRAY
12663: ST_TO_ADDR
// CreateCratesArea ( 5 , BednyRusoveZStart , false ) ;
12664: LD_INT 5
12666: PPUSH
12667: LD_INT 17
12669: PPUSH
12670: LD_INT 0
12672: PPUSH
12673: CALL_OW 55
// CreateCratesArea ( 5 , BednyRusoveVStart , false ) ;
12677: LD_INT 5
12679: PPUSH
12680: LD_INT 18
12682: PPUSH
12683: LD_INT 0
12685: PPUSH
12686: CALL_OW 55
// for I = 2 to dif_BednyStart [ Difficulty ] do
12690: LD_ADDR_VAR 0 2
12694: PUSH
12695: DOUBLE
12696: LD_INT 2
12698: DEC
12699: ST_TO_ADDR
12700: LD_EXP 35
12704: PUSH
12705: LD_OWVAR 67
12709: ARRAY
12710: PUSH
12711: FOR_TO
12712: IFFALSE 12758
// begin CreateCratesArea ( Rand ( 4 , 5 ) , BednyRusoveZ , false ) ;
12714: LD_INT 4
12716: PPUSH
12717: LD_INT 5
12719: PPUSH
12720: CALL_OW 12
12724: PPUSH
12725: LD_INT 15
12727: PPUSH
12728: LD_INT 0
12730: PPUSH
12731: CALL_OW 55
// CreateCratesArea ( Rand ( 4 , 5 ) , BednyRusoveV , false ) ;
12735: LD_INT 4
12737: PPUSH
12738: LD_INT 5
12740: PPUSH
12741: CALL_OW 12
12745: PPUSH
12746: LD_INT 16
12748: PPUSH
12749: LD_INT 0
12751: PPUSH
12752: CALL_OW 55
// end ;
12756: GO 12711
12758: POP
12759: POP
// end ;
12760: LD_VAR 0 1
12764: RET
// every 2 2$34 do var Baze ;
12765: GO 12767
12767: DISABLE
12768: LD_INT 0
12770: PPUSH
// begin if IsOK ( AmDepot ) then
12771: LD_INT 15
12773: PPUSH
12774: CALL_OW 302
12778: IFFALSE 12839
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
12780: LD_INT 35
12782: PPUSH
12783: LD_INT 1050
12785: PPUSH
12786: CALL_OW 12
12790: PPUSH
12791: CALL_OW 67
// Baze = GetBase ( AmDepot ) ;
12795: LD_ADDR_VAR 0 1
12799: PUSH
12800: LD_INT 15
12802: PPUSH
12803: CALL_OW 274
12807: ST_TO_ADDR
// if GetResourceType ( Baze , MAT_CANS ) < 1500 then
12808: LD_VAR 0 1
12812: PPUSH
12813: LD_INT 1
12815: PPUSH
12816: CALL_OW 275
12820: PUSH
12821: LD_INT 1500
12823: LESS
12824: IFFALSE 12839
// CreateCratesArea ( 5 , BednyAmericani , true ) ;
12826: LD_INT 5
12828: PPUSH
12829: LD_INT 22
12831: PPUSH
12832: LD_INT 1
12834: PPUSH
12835: CALL_OW 55
// end ; enable ;
12839: ENABLE
// end ;
12840: PPOPN 1
12842: END
// every 5 5$13.7 + 5 5$9 do var Pocet ;
12843: GO 12845
12845: DISABLE
12846: LD_INT 0
12848: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
12849: LD_INT 35
12851: PPUSH
12852: LD_INT 2100
12854: PPUSH
12855: CALL_OW 12
12859: PPUSH
12860: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
12864: LD_ADDR_VAR 0 1
12868: PUSH
12869: LD_INT 0
12871: PPUSH
12872: LD_INT 5
12874: PPUSH
12875: CALL_OW 12
12879: ST_TO_ADDR
// if Pocet > 0 then
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 0
12887: GREATER
12888: IFFALSE 12902
// CreateCratesAnywhere ( Pocet , true ) ;
12890: LD_VAR 0 1
12894: PPUSH
12895: LD_INT 1
12897: PPUSH
12898: CALL_OW 57
// enable ;
12902: ENABLE
// end ;
12903: PPOPN 1
12905: END
// every 3 3$43 + 1 1$30 do
12906: GO 12908
12908: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
12909: LD_INT 35
12911: PPUSH
12912: LD_INT 4200
12914: PPUSH
12915: CALL_OW 12
12919: PPUSH
12920: CALL_OW 67
// if ( BednyRZ <> 0 ) then
12924: LD_LOC 53
12928: PUSH
12929: LD_INT 0
12931: NONEQUAL
12932: IFFALSE 12991
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
12934: LD_INT 3
12936: PPUSH
12937: LD_INT 5
12939: PPUSH
12940: CALL_OW 12
12944: PPUSH
12945: LD_INT 15
12947: PPUSH
12948: LD_INT 1
12950: PPUSH
12951: CALL_OW 55
// if ( BednyRZ <> - 1 ) then
12955: LD_LOC 53
12959: PUSH
12960: LD_INT 1
12962: NEG
12963: NONEQUAL
12964: IFFALSE 12980
// BednyRZ = BednyRZ - 1 ;
12966: LD_ADDR_LOC 53
12970: PUSH
12971: LD_LOC 53
12975: PUSH
12976: LD_INT 1
12978: MINUS
12979: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
12980: LD_LOC 53
12984: PUSH
12985: LD_INT 0
12987: NONEQUAL
12988: IFFALSE 12991
// enable ;
12990: ENABLE
// end ; end ;
12991: END
// every 3 3$53 + 0 0$59 do
12992: GO 12994
12994: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
12995: LD_INT 35
12997: PPUSH
12998: LD_INT 4200
13000: PPUSH
13001: CALL_OW 12
13005: PPUSH
13006: CALL_OW 67
// if ( BednyRV <> 0 ) then
13010: LD_LOC 54
13014: PUSH
13015: LD_INT 0
13017: NONEQUAL
13018: IFFALSE 13077
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
13020: LD_INT 3
13022: PPUSH
13023: LD_INT 5
13025: PPUSH
13026: CALL_OW 12
13030: PPUSH
13031: LD_INT 16
13033: PPUSH
13034: LD_INT 1
13036: PPUSH
13037: CALL_OW 55
// if ( BednyRV <> - 1 ) then
13041: LD_LOC 54
13045: PUSH
13046: LD_INT 1
13048: NEG
13049: NONEQUAL
13050: IFFALSE 13066
// BednyRV = BednyRV - 1 ;
13052: LD_ADDR_LOC 54
13056: PUSH
13057: LD_LOC 54
13061: PUSH
13062: LD_INT 1
13064: MINUS
13065: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
13066: LD_LOC 54
13070: PUSH
13071: LD_INT 0
13073: NONEQUAL
13074: IFFALSE 13077
// enable ;
13076: ENABLE
// end ; end ; end_of_file
13077: END
// export JMM ; var JMMAuto , JMMDoprovod ; var CekatJMM ; var MakroMove ; var JMMUtekl ; var VidelJMM ; export function init_jmm ; begin
13078: LD_INT 0
13080: PPUSH
// disable ( 11 ) ;
13081: LD_INT 11
13083: DISABLE_MARKED
// disable ( 12 ) ;
13084: LD_INT 12
13086: DISABLE_MARKED
// disable ( 13 ) ;
13087: LD_INT 13
13089: DISABLE_MARKED
// disable ( 14 ) ;
13090: LD_INT 14
13092: DISABLE_MARKED
// disable ( 15 ) ;
13093: LD_INT 15
13095: DISABLE_MARKED
// CekatJMM = dif_CekamJMM [ Difficulty ] ;
13096: LD_ADDR_LOC 57
13100: PUSH
13101: LD_EXP 38
13105: PUSH
13106: LD_OWVAR 67
13110: ARRAY
13111: ST_TO_ADDR
// JMMDoprovod = [ ] ;
13112: LD_ADDR_LOC 56
13116: PUSH
13117: EMPTY
13118: ST_TO_ADDR
// MakroMove = 0 ;
13119: LD_ADDR_LOC 58
13123: PUSH
13124: LD_INT 0
13126: ST_TO_ADDR
// JMMUtekl = false ;
13127: LD_ADDR_LOC 59
13131: PUSH
13132: LD_INT 0
13134: ST_TO_ADDR
// VidelJMM = false ;
13135: LD_ADDR_LOC 60
13139: PUSH
13140: LD_INT 0
13142: ST_TO_ADDR
// vytvor_jmm ;
13143: CALL 13194 0 0
// vytvor_jmm_auto ;
13147: CALL 13271 0 0
// PlaceHumanInUnit ( JMM , JMMAuto ) ;
13151: LD_EXP 44
13155: PPUSH
13156: LD_LOC 55
13160: PPUSH
13161: CALL_OW 52
// PlaceUnitArea ( JMMAuto , JMMStart , false ) ;
13165: LD_LOC 55
13169: PPUSH
13170: LD_INT 4
13172: PPUSH
13173: LD_INT 0
13175: PPUSH
13176: CALL_OW 49
// ComHold ( JMMAuto ) ;
13180: LD_LOC 55
13184: PPUSH
13185: CALL_OW 140
// end ;
13189: LD_VAR 0 1
13193: RET
// function vytvor_jmm ; begin
13194: LD_INT 0
13196: PPUSH
// if JMM then
13197: LD_EXP 44
13201: IFFALSE 13205
// exit ;
13203: GO 13266
// UC_Side = side_Am ;
13205: LD_ADDR_OWVAR 20
13209: PUSH
13210: LD_EXP 2
13214: ST_TO_ADDR
// if TestCharacters ( Macmillan ) then
13215: LD_STRING Macmillan
13217: PPUSH
13218: CALL_OW 28
13222: IFFALSE 13239
// JMM = CreateCharacter ( Macmillan ) else
13224: LD_ADDR_EXP 44
13228: PUSH
13229: LD_STRING Macmillan
13231: PPUSH
13232: CALL_OW 34
13236: ST_TO_ADDR
13237: GO 13252
// JMM = NewCharacter ( Macmillan ) ;
13239: LD_ADDR_EXP 44
13243: PUSH
13244: LD_STRING Macmillan
13246: PPUSH
13247: CALL_OW 25
13251: ST_TO_ADDR
// SetSide ( JMM , side_Am ) ;
13252: LD_EXP 44
13256: PPUSH
13257: LD_EXP 2
13261: PPUSH
13262: CALL_OW 235
// end ;
13266: LD_VAR 0 1
13270: RET
// function vytvor_jmm_auto ; begin
13271: LD_INT 0
13273: PPUSH
// if JMMAuto then
13274: LD_LOC 55
13278: IFFALSE 13282
// exit ;
13280: GO 13368
// UC_Side = side_Am ;
13282: LD_ADDR_OWVAR 20
13286: PUSH
13287: LD_EXP 2
13291: ST_TO_ADDR
// UC_Nation = NATION_AMERICAN ;
13292: LD_ADDR_OWVAR 21
13296: PUSH
13297: LD_INT 1
13299: ST_TO_ADDR
// VC_Chassis = US_MORPHLING ;
13300: LD_ADDR_OWVAR 37
13304: PUSH
13305: LD_INT 5
13307: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
13308: LD_ADDR_OWVAR 38
13312: PUSH
13313: LD_INT 1
13315: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
13316: LD_ADDR_OWVAR 39
13320: PUSH
13321: LD_INT 3
13323: ST_TO_ADDR
// VC_Weapon = US_HEAVY_GUN ;
13324: LD_ADDR_OWVAR 40
13328: PUSH
13329: LD_INT 6
13331: ST_TO_ADDR
// JMMAuto = CreateVehicle ;
13332: LD_ADDR_LOC 55
13336: PUSH
13337: CALL_OW 45
13341: ST_TO_ADDR
// SetMark ( JMMAuto , 1 ) ;
13342: LD_LOC 55
13346: PPUSH
13347: LD_INT 1
13349: PPUSH
13350: CALL_OW 242
// SetSide ( JMMAuto , side_Am ) ;
13354: LD_LOC 55
13358: PPUSH
13359: LD_EXP 2
13363: PPUSH
13364: CALL_OW 235
// end ;
13368: LD_VAR 0 1
13372: RET
// function jmm_start ; begin
13373: LD_INT 0
13375: PPUSH
// DialogueOn ;
13376: CALL_OW 6
// dialog_JMMStart ;
13380: CALL 15268 0 0
// ChangeMissionObjectives ( MJMM ) ;
13384: LD_STRING MJMM
13386: PPUSH
13387: CALL_OW 337
// DialogueOff ;
13391: CALL_OW 7
// enable ( 11 ) ;
13395: LD_INT 11
13397: ENABLE_MARKED
// end ;
13398: LD_VAR 0 1
13402: RET
// function jmm_appear ; var Kdo ; begin
13403: LD_INT 0
13405: PPUSH
13406: PPUSH
// Result = false ;
13407: LD_ADDR_VAR 0 1
13411: PUSH
13412: LD_INT 0
13414: ST_TO_ADDR
// JMMDoprovod = amici_vezmi_doprovod ;
13415: LD_ADDR_LOC 56
13419: PUSH
13420: CALL 9959 0 0
13424: ST_TO_ADDR
// if not JMMDoprovod then
13425: LD_LOC 56
13429: NOT
13430: IFFALSE 13434
// exit ;
13432: GO 13674
// enable ( 15 ) ;
13434: LD_INT 15
13436: ENABLE_MARKED
// Kdo = IsInUnit ( JMM ) ;
13437: LD_ADDR_VAR 0 2
13441: PUSH
13442: LD_EXP 44
13446: PPUSH
13447: CALL_OW 310
13451: ST_TO_ADDR
// if not Kdo then
13452: LD_VAR 0 2
13456: NOT
13457: IFFALSE 13469
// Kdo = JMM ;
13459: LD_ADDR_VAR 0 2
13463: PUSH
13464: LD_EXP 44
13468: ST_TO_ADDR
// ComFree ( Kdo ) ;
13469: LD_VAR 0 2
13473: PPUSH
13474: CALL_OW 139
// Wait ( 0 0$1 ) ;
13478: LD_INT 35
13480: PPUSH
13481: CALL_OW 67
// MakroMove = McMove ( 50 , JMMDoprovod union [ Kdo ] , [ [ 142 , 38 ] , [ 153 , 49 ] , [ 156 , 60 ] , [ 152 , 67 ] , [ 151 , 72 ] , [ 144 , 74 ] , [ 135 , 76 ] , [ 129 , 75 ] , [ 119 , 78 ] , [ 105 , 105 ] , [ 98 , 125 ] , [ 80 , 155 ] ] , [ MC_MOVE_WAITWP , MC_MOVE_DONTCAPTURE , MC_MOVE_AGRESSIVE ] ) ;
13485: LD_ADDR_LOC 58
13489: PUSH
13490: LD_INT 50
13492: PPUSH
13493: LD_LOC 56
13497: PUSH
13498: LD_VAR 0 2
13502: PUSH
13503: EMPTY
13504: LIST
13505: UNION
13506: PPUSH
13507: LD_INT 142
13509: PUSH
13510: LD_INT 38
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PUSH
13517: LD_INT 153
13519: PUSH
13520: LD_INT 49
13522: PUSH
13523: EMPTY
13524: LIST
13525: LIST
13526: PUSH
13527: LD_INT 156
13529: PUSH
13530: LD_INT 60
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: PUSH
13537: LD_INT 152
13539: PUSH
13540: LD_INT 67
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 151
13549: PUSH
13550: LD_INT 72
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 144
13559: PUSH
13560: LD_INT 74
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 135
13569: PUSH
13570: LD_INT 76
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 129
13579: PUSH
13580: LD_INT 75
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 119
13589: PUSH
13590: LD_INT 78
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 105
13599: PUSH
13600: LD_INT 105
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: LD_INT 98
13609: PUSH
13610: LD_INT 125
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: LD_INT 80
13619: PUSH
13620: LD_INT 155
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: PPUSH
13641: LD_INT 3
13643: PUSH
13644: LD_INT 5
13646: PUSH
13647: LD_INT 6
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: LIST
13654: PPUSH
13655: CALL_OW 398
13659: ST_TO_ADDR
// enable ( 12 ) ;
13660: LD_INT 12
13662: ENABLE_MARKED
// enable ( 14 ) ;
13663: LD_INT 14
13665: ENABLE_MARKED
// Result = true ;
13666: LD_ADDR_VAR 0 1
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// end ;
13674: LD_VAR 0 1
13678: RET
// every 0 0$0.8 marked 15 do var Vidi , Auto ;
13679: GO 13681
13681: DISABLE
13682: LD_INT 0
13684: PPUSH
13685: PPUSH
// begin if VidelJMM then
13686: LD_LOC 60
13690: IFFALSE 13694
// exit ;
13692: GO 13780
// Auto = IsInUnit ( JMM ) ;
13694: LD_ADDR_VAR 0 2
13698: PUSH
13699: LD_EXP 44
13703: PPUSH
13704: CALL_OW 310
13708: ST_TO_ADDR
// Vidi = See ( side_Ru , JMM ) or ( Auto and See ( side_Ru , Auto ) ) ;
13709: LD_ADDR_VAR 0 1
13713: PUSH
13714: LD_EXP 3
13718: PPUSH
13719: LD_EXP 44
13723: PPUSH
13724: CALL_OW 292
13728: PUSH
13729: LD_VAR 0 2
13733: PUSH
13734: LD_EXP 3
13738: PPUSH
13739: LD_VAR 0 2
13743: PPUSH
13744: CALL_OW 292
13748: AND
13749: OR
13750: ST_TO_ADDR
// if Vidi then
13751: LD_VAR 0 1
13755: IFFALSE 13779
// begin VidelJMM = true ;
13757: LD_ADDR_LOC 60
13761: PUSH
13762: LD_INT 1
13764: ST_TO_ADDR
// DialogueOn ;
13765: CALL_OW 6
// dialog_JMMAppear ;
13769: CALL 15416 0 0
// DialogueOff ;
13773: CALL_OW 7
// end else
13777: GO 13780
// enable ;
13779: ENABLE
// end ;
13780: PPOPN 2
13782: END
// every 0 0$30 do
13783: GO 13785
13785: DISABLE
// begin Wait ( Rand ( CekatJMM [ 1 ] , CekatJMM [ 2 ] ) ) ;
13786: LD_LOC 57
13790: PUSH
13791: LD_INT 1
13793: ARRAY
13794: PPUSH
13795: LD_LOC 57
13799: PUSH
13800: LD_INT 2
13802: ARRAY
13803: PPUSH
13804: CALL_OW 12
13808: PPUSH
13809: CALL_OW 67
// jmm_start ;
13813: CALL 13373 0 0
// end ;
13817: END
// every 1 1$30 marked 11 do
13818: GO 13820
13820: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
13821: LD_INT 35
13823: PPUSH
13824: LD_INT 2100
13826: PPUSH
13827: CALL_OW 12
13831: PPUSH
13832: CALL_OW 67
// if not jmm_appear then
13836: CALL 13403 0 0
13840: NOT
13841: IFFALSE 13844
// enable ;
13843: ENABLE
// end ;
13844: END
// every 0 0$1 marked 12 do
13845: GO 13847
13847: DISABLE
// begin WaitForMc ( MakroMove ) ;
13848: LD_LOC 58
13852: PPUSH
13853: CALL_OW 385
// enable ( 13 ) ;
13857: LD_INT 13
13859: ENABLE_MARKED
// end ;
13860: END
// function presun_unikova_zona ; var Kdo , List ; begin
13861: LD_INT 0
13863: PPUSH
13864: PPUSH
13865: PPUSH
// Kdo = IsInUnit ( JMM ) ;
13866: LD_ADDR_VAR 0 2
13870: PUSH
13871: LD_EXP 44
13875: PPUSH
13876: CALL_OW 310
13880: ST_TO_ADDR
// if not Kdo then
13881: LD_VAR 0 2
13885: NOT
13886: IFFALSE 13898
// Kdo = JMM ;
13888: LD_ADDR_VAR 0 2
13892: PUSH
13893: LD_EXP 44
13897: ST_TO_ADDR
// List = [ Kdo ] union JMMDoprovod ;
13898: LD_ADDR_VAR 0 3
13902: PUSH
13903: LD_VAR 0 2
13907: PUSH
13908: EMPTY
13909: LIST
13910: PUSH
13911: LD_LOC 56
13915: UNION
13916: ST_TO_ADDR
// Result = true ;
13917: LD_ADDR_VAR 0 1
13921: PUSH
13922: LD_INT 1
13924: ST_TO_ADDR
// for Kdo in List do
13925: LD_ADDR_VAR 0 2
13929: PUSH
13930: LD_VAR 0 3
13934: PUSH
13935: FOR_IN
13936: IFFALSE 13990
// begin if not IsPlaced ( Kdo ) then
13938: LD_VAR 0 2
13942: PPUSH
13943: CALL_OW 305
13947: NOT
13948: IFFALSE 13952
// continue ;
13950: GO 13935
// if IsInArea ( Kdo , JMMUtek ) then
13952: LD_VAR 0 2
13956: PPUSH
13957: LD_INT 5
13959: PPUSH
13960: CALL_OW 308
13964: IFFALSE 13968
// continue ;
13966: GO 13935
// ComMoveToArea ( Kdo , JMMUtek ) ;
13968: LD_VAR 0 2
13972: PPUSH
13973: LD_INT 5
13975: PPUSH
13976: CALL_OW 113
// Result = false ;
13980: LD_ADDR_VAR 0 1
13984: PUSH
13985: LD_INT 0
13987: ST_TO_ADDR
// end ;
13988: GO 13935
13990: POP
13991: POP
// end ;
13992: LD_VAR 0 1
13996: RET
// every 0 0$3.4 marked 13 do
13997: GO 13999
13999: DISABLE
// begin if not presun_unikova_zona then
14000: CALL 13861 0 0
14004: NOT
14005: IFFALSE 14008
// enable ;
14007: ENABLE
// end ;
14008: END
// every 0 0$1.2 marked 14 do var Kdo , List , Odstraneno ;
14009: GO 14011
14011: DISABLE
14012: LD_INT 0
14014: PPUSH
14015: PPUSH
14016: PPUSH
// begin if JMMDoprovod then
14017: LD_LOC 56
14021: IFFALSE 14116
// begin Odstraneno = [ ] ;
14023: LD_ADDR_VAR 0 3
14027: PUSH
14028: EMPTY
14029: ST_TO_ADDR
// for Kdo in JMMDoprovod do
14030: LD_ADDR_VAR 0 1
14034: PUSH
14035: LD_LOC 56
14039: PUSH
14040: FOR_IN
14041: IFFALSE 14098
// if IsPlaced ( Kdo ) and IsInArea ( Kdo , JMMUtek ) then
14043: LD_VAR 0 1
14047: PPUSH
14048: CALL_OW 305
14052: PUSH
14053: LD_VAR 0 1
14057: PPUSH
14058: LD_INT 5
14060: PPUSH
14061: CALL_OW 308
14065: AND
14066: IFFALSE 14096
// begin RemoveUnit ( Kdo ) ;
14068: LD_VAR 0 1
14072: PPUSH
14073: CALL_OW 64
// Odstraneno = Odstraneno union [ Kdo ] ;
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: LD_VAR 0 3
14086: PUSH
14087: LD_VAR 0 1
14091: PUSH
14092: EMPTY
14093: LIST
14094: UNION
14095: ST_TO_ADDR
// end ;
14096: GO 14040
14098: POP
14099: POP
// JMMDoprovod = JMMDoprovod diff Odstraneno ;
14100: LD_ADDR_LOC 56
14104: PUSH
14105: LD_LOC 56
14109: PUSH
14110: LD_VAR 0 3
14114: DIFF
14115: ST_TO_ADDR
// end ; if not JMMUtekl then
14116: LD_LOC 59
14120: NOT
14121: IFFALSE 14184
// begin Kdo = IsInUnit ( JMM ) ;
14123: LD_ADDR_VAR 0 1
14127: PUSH
14128: LD_EXP 44
14132: PPUSH
14133: CALL_OW 310
14137: ST_TO_ADDR
// if not Kdo then
14138: LD_VAR 0 1
14142: NOT
14143: IFFALSE 14155
// Kdo = JMM ;
14145: LD_ADDR_VAR 0 1
14149: PUSH
14150: LD_EXP 44
14154: ST_TO_ADDR
// if IsPlaced ( Kdo ) and IsInArea ( Kdo , JMMUtek ) then
14155: LD_VAR 0 1
14159: PPUSH
14160: CALL_OW 305
14164: PUSH
14165: LD_VAR 0 1
14169: PPUSH
14170: LD_INT 5
14172: PPUSH
14173: CALL_OW 308
14177: AND
14178: IFFALSE 14184
// jmm_Escapes ;
14180: CALL 14303 0 0
// end ; if JmmDoprovod or not JMMUtekl then
14184: LD_LOC 56
14188: PUSH
14189: LD_LOC 59
14193: NOT
14194: OR
14195: IFFALSE 14200
// enable else
14197: ENABLE
14198: GO 14203
// disable ( 13 ) ;
14200: LD_INT 13
14202: DISABLE_MARKED
// end ;
14203: PPOPN 3
14205: END
// export function jmm_UnitDestroyed ( Un ) ; begin
14206: LD_INT 0
14208: PPUSH
// if Un = JMMAuto then
14209: LD_VAR 0 1
14213: PUSH
14214: LD_LOC 55
14218: EQUAL
14219: IFFALSE 14229
// JMMAuto = 0 ;
14221: LD_ADDR_LOC 55
14225: PUSH
14226: LD_INT 0
14228: ST_TO_ADDR
// if Un in JMMDoprovod then
14229: LD_VAR 0 1
14233: PUSH
14234: LD_LOC 56
14238: IN
14239: IFFALSE 14260
// JMMDoprovod = JMMDoprovod diff [ Un ] ;
14241: LD_ADDR_LOC 56
14245: PUSH
14246: LD_LOC 56
14250: PUSH
14251: LD_VAR 0 1
14255: PUSH
14256: EMPTY
14257: LIST
14258: DIFF
14259: ST_TO_ADDR
// if Un = JMM then
14260: LD_VAR 0 1
14264: PUSH
14265: LD_EXP 44
14269: EQUAL
14270: IFFALSE 14298
// begin disable ( 15 ) ;
14272: LD_INT 15
14274: DISABLE_MARKED
// DialogueOn ;
14275: CALL_OW 6
// dialog_JMMDies ;
14279: CALL 15572 0 0
// SA_OnJMMKilled ;
14283: CALL 17975 0 0
// ChangeMissionObjectives ( MJMMOut ) ;
14287: LD_STRING MJMMOut
14289: PPUSH
14290: CALL_OW 337
// DialogueOff ;
14294: CALL_OW 7
// end ; end ;
14298: LD_VAR 0 2
14302: RET
// function jmm_Escapes ; var I ; begin
14303: LD_INT 0
14305: PPUSH
14306: PPUSH
// disable ( 15 ) ;
14307: LD_INT 15
14309: DISABLE_MARKED
// DialogueOn ;
14310: CALL_OW 6
// JMMUtekl = true ;
14314: LD_ADDR_LOC 59
14318: PUSH
14319: LD_INT 1
14321: ST_TO_ADDR
// I = IsInUnit ( JMM ) ;
14322: LD_ADDR_VAR 0 2
14326: PUSH
14327: LD_EXP 44
14331: PPUSH
14332: CALL_OW 310
14336: ST_TO_ADDR
// if I then
14337: LD_VAR 0 2
14341: IFFALSE 14354
// RemoveUnit ( I ) else
14343: LD_VAR 0 2
14347: PPUSH
14348: CALL_OW 64
14352: GO 14363
// RemoveUnit ( JMM ) ;
14354: LD_EXP 44
14358: PPUSH
14359: CALL_OW 64
// dialog_JMMEscapes ;
14363: CALL 15453 0 0
// DialogueOff ;
14367: CALL_OW 7
// end ;
14371: LD_VAR 0 1
14375: RET
// export function jmm_EvacuateVehicle ( Hum , Veh ) ; begin
14376: LD_INT 0
14378: PPUSH
// if MakroMove and ( Hum = JMM ) then
14379: LD_LOC 58
14383: PUSH
14384: LD_VAR 0 1
14388: PUSH
14389: LD_EXP 44
14393: EQUAL
14394: AND
14395: IFFALSE 14433
// begin JMMAuto = 0 ;
14397: LD_ADDR_LOC 55
14401: PUSH
14402: LD_INT 0
14404: ST_TO_ADDR
// RemoveMcUnits ( MakroMove , Veh ) ;
14405: LD_LOC 58
14409: PPUSH
14410: LD_VAR 0 2
14414: PPUSH
14415: CALL_OW 391
// AddMcUnits ( JMM , Veh ) ;
14419: LD_EXP 44
14423: PPUSH
14424: LD_VAR 0 2
14428: PPUSH
14429: CALL_OW 390
// end ; end ; end_of_file
14433: LD_VAR 0 3
14437: RET
// function najdi_nekoho ; var Lidi ; begin
14438: LD_INT 0
14440: PPUSH
14441: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
14442: LD_ADDR_VAR 0 2
14446: PUSH
14447: LD_INT 22
14449: PUSH
14450: LD_EXP 3
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 50
14461: PUSH
14462: EMPTY
14463: LIST
14464: PUSH
14465: LD_INT 52
14467: PUSH
14468: EMPTY
14469: LIST
14470: PUSH
14471: LD_INT 21
14473: PUSH
14474: LD_INT 1
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 26
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: PPUSH
14498: CALL_OW 69
14502: PUSH
14503: LD_EXP 4
14507: PUSH
14508: EMPTY
14509: LIST
14510: DIFF
14511: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
14512: LD_ADDR_VAR 0 2
14516: PUSH
14517: LD_VAR 0 2
14521: PPUSH
14522: CALL 16002 0 1
14526: ST_TO_ADDR
// if Lidi then
14527: LD_VAR 0 2
14531: IFFALSE 14549
// Result = Lidi [ 1 ] else
14533: LD_ADDR_VAR 0 1
14537: PUSH
14538: LD_VAR 0 2
14542: PUSH
14543: LD_INT 1
14545: ARRAY
14546: ST_TO_ADDR
14547: GO 14559
// Result = Burlak ;
14549: LD_ADDR_VAR 0 1
14553: PUSH
14554: LD_EXP 4
14558: ST_TO_ADDR
// end ;
14559: LD_VAR 0 1
14563: RET
// function najdi_vedce ; var Vedci ; begin
14564: LD_INT 0
14566: PPUSH
14567: PPUSH
// Vedci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] , [ F_SEX , SEX_MALE ] ] ) diff [ Bystrov , Burlak ] ;
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: LD_INT 22
14575: PUSH
14576: LD_EXP 3
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: PUSH
14585: LD_INT 50
14587: PUSH
14588: EMPTY
14589: LIST
14590: PUSH
14591: LD_INT 52
14593: PUSH
14594: EMPTY
14595: LIST
14596: PUSH
14597: LD_INT 21
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: LD_INT 25
14609: PUSH
14610: LD_INT 4
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PUSH
14617: LD_INT 26
14619: PUSH
14620: LD_INT 1
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_EXP 5
14644: PUSH
14645: LD_EXP 4
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: DIFF
14654: ST_TO_ADDR
// Vedci = bez_opic ( Vedci ) ;
14655: LD_ADDR_VAR 0 2
14659: PUSH
14660: LD_VAR 0 2
14664: PPUSH
14665: CALL 16002 0 1
14669: ST_TO_ADDR
// if Vedci then
14670: LD_VAR 0 2
14674: IFFALSE 14692
// Result = Vedci [ 1 ] else
14676: LD_ADDR_VAR 0 1
14680: PUSH
14681: LD_VAR 0 2
14685: PUSH
14686: LD_INT 1
14688: ARRAY
14689: ST_TO_ADDR
14690: GO 14725
// if IsOK ( Bystrov ) then
14692: LD_EXP 5
14696: PPUSH
14697: CALL_OW 302
14701: IFFALSE 14715
// Result = Bystrov else
14703: LD_ADDR_VAR 0 1
14707: PUSH
14708: LD_EXP 5
14712: ST_TO_ADDR
14713: GO 14725
// Result = najdi_nekoho ;
14715: LD_ADDR_VAR 0 1
14719: PUSH
14720: CALL 14438 0 0
14724: ST_TO_ADDR
// end ;
14725: LD_VAR 0 1
14729: RET
// function najdi_vojaka ; var Vojaci ; begin
14730: LD_INT 0
14732: PPUSH
14733: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SOLDIER ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
14734: LD_ADDR_VAR 0 2
14738: PUSH
14739: LD_INT 22
14741: PUSH
14742: LD_EXP 3
14746: PUSH
14747: EMPTY
14748: LIST
14749: LIST
14750: PUSH
14751: LD_INT 50
14753: PUSH
14754: EMPTY
14755: LIST
14756: PUSH
14757: LD_INT 52
14759: PUSH
14760: EMPTY
14761: LIST
14762: PUSH
14763: LD_INT 21
14765: PUSH
14766: LD_INT 1
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PUSH
14773: LD_INT 25
14775: PUSH
14776: LD_INT 1
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: PUSH
14783: LD_INT 26
14785: PUSH
14786: LD_INT 1
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: PPUSH
14801: CALL_OW 69
14805: PUSH
14806: LD_EXP 4
14810: PUSH
14811: EMPTY
14812: LIST
14813: DIFF
14814: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
14815: LD_ADDR_VAR 0 2
14819: PUSH
14820: LD_VAR 0 2
14824: PPUSH
14825: CALL 16002 0 1
14829: ST_TO_ADDR
// if Vojaci then
14830: LD_VAR 0 2
14834: IFFALSE 14852
// Result = Vojaci [ 1 ] else
14836: LD_ADDR_VAR 0 1
14840: PUSH
14841: LD_VAR 0 2
14845: PUSH
14846: LD_INT 1
14848: ARRAY
14849: ST_TO_ADDR
14850: GO 14862
// Result = najdi_nekoho ;
14852: LD_ADDR_VAR 0 1
14856: PUSH
14857: CALL 14438 0 0
14861: ST_TO_ADDR
// end ;
14862: LD_VAR 0 1
14866: RET
// export function dialog_Arrival ; begin
14867: LD_INT 0
14869: PPUSH
// Say ( Burlak , DArrival-Bur-1 ) ;
14870: LD_EXP 4
14874: PPUSH
14875: LD_STRING DArrival-Bur-1
14877: PPUSH
14878: CALL_OW 88
// Say ( Bystrov , DArrival-Bys-1 ) ;
14882: LD_EXP 5
14886: PPUSH
14887: LD_STRING DArrival-Bys-1
14889: PPUSH
14890: CALL_OW 88
// Say ( Burlak , DArrival-Bur-2 ) ;
14894: LD_EXP 4
14898: PPUSH
14899: LD_STRING DArrival-Bur-2
14901: PPUSH
14902: CALL_OW 88
// end ;
14906: LD_VAR 0 1
14910: RET
// export function dialog_BadBaseN ; begin
14911: LD_INT 0
14913: PPUSH
// if IsOK ( Bystrov ) then
14914: LD_EXP 5
14918: PPUSH
14919: CALL_OW 302
14923: IFFALSE 14937
// Say ( Bystrov , DBadBase-Bys-1 ) ;
14925: LD_EXP 5
14929: PPUSH
14930: LD_STRING DBadBase-Bys-1
14932: PPUSH
14933: CALL_OW 88
// end ;
14937: LD_VAR 0 1
14941: RET
// export function dialog_BadBaseE ; begin
14942: LD_INT 0
14944: PPUSH
// if IsOK ( Bystrov ) then
14945: LD_EXP 5
14949: PPUSH
14950: CALL_OW 302
14954: IFFALSE 14968
// Say ( Bystrov , DBadBase-Bys-1a ) ;
14956: LD_EXP 5
14960: PPUSH
14961: LD_STRING DBadBase-Bys-1a
14963: PPUSH
14964: CALL_OW 88
// end ;
14968: LD_VAR 0 1
14972: RET
// export function dialog_BadLabN ; begin
14973: LD_INT 0
14975: PPUSH
// if IsOK ( Bystrov ) then
14976: LD_EXP 5
14980: PPUSH
14981: CALL_OW 302
14985: IFFALSE 14999
// Say ( Bystrov , DBasLab-Bys-1 ) ;
14987: LD_EXP 5
14991: PPUSH
14992: LD_STRING DBasLab-Bys-1
14994: PPUSH
14995: CALL_OW 88
// end ;
14999: LD_VAR 0 1
15003: RET
// export function dialog_BadLabE ; begin
15004: LD_INT 0
15006: PPUSH
// if IsOK ( Bystrov ) then
15007: LD_EXP 5
15011: PPUSH
15012: CALL_OW 302
15016: IFFALSE 15030
// Say ( Bystrov , DBasLab-Bys-1a ) ;
15018: LD_EXP 5
15022: PPUSH
15023: LD_STRING DBasLab-Bys-1a
15025: PPUSH
15026: CALL_OW 88
// end ;
15030: LD_VAR 0 1
15034: RET
// export function dialog_NoArtefact ; begin
15035: LD_INT 0
15037: PPUSH
// if IsOK ( Bystrov ) then
15038: LD_EXP 5
15042: PPUSH
15043: CALL_OW 302
15047: IFFALSE 15061
// Say ( Bystrov , DNoArtefact-Bys-1 ) ;
15049: LD_EXP 5
15053: PPUSH
15054: LD_STRING DNoArtefact-Bys-1
15056: PPUSH
15057: CALL_OW 88
// end ;
15061: LD_VAR 0 1
15065: RET
// export function dialog_Done1 ; begin
15066: LD_INT 0
15068: PPUSH
// if IsOK ( Bystrov ) then
15069: LD_EXP 5
15073: PPUSH
15074: CALL_OW 302
15078: IFFALSE 15092
// Say ( Bystrov , DDone-Bys-1 ) ;
15080: LD_EXP 5
15084: PPUSH
15085: LD_STRING DDone-Bys-1
15087: PPUSH
15088: CALL_OW 88
// end ;
15092: LD_VAR 0 1
15096: RET
// export function dialog_Done2 ; begin
15097: LD_INT 0
15099: PPUSH
// if IsOK ( Bystrov ) then
15100: LD_EXP 5
15104: PPUSH
15105: CALL_OW 302
15109: IFFALSE 15123
// Say ( Bystrov , DDone-Bys-1a ) ;
15111: LD_EXP 5
15115: PPUSH
15116: LD_STRING DDone-Bys-1a
15118: PPUSH
15119: CALL_OW 88
// end ;
15123: LD_VAR 0 1
15127: RET
// export function dialog_TimeLapser1 ; var Sci ; begin
15128: LD_INT 0
15130: PPUSH
15131: PPUSH
// Sci = najdi_vedce ;
15132: LD_ADDR_VAR 0 2
15136: PUSH
15137: CALL 14564 0 0
15141: ST_TO_ADDR
// if Sci and IsOK ( Sci ) then
15142: LD_VAR 0 2
15146: PUSH
15147: LD_VAR 0 2
15151: PPUSH
15152: CALL_OW 302
15156: AND
15157: IFFALSE 15171
// Say ( Sci , DTimeLapser1-Sci1-1 ) ;
15159: LD_VAR 0 2
15163: PPUSH
15164: LD_STRING DTimeLapser1-Sci1-1
15166: PPUSH
15167: CALL_OW 88
// end ;
15171: LD_VAR 0 1
15175: RET
// export function dialog_TimeLapser2 ; var Sci ; begin
15176: LD_INT 0
15178: PPUSH
15179: PPUSH
// Sci = najdi_vedce ;
15180: LD_ADDR_VAR 0 2
15184: PUSH
15185: CALL 14564 0 0
15189: ST_TO_ADDR
// if Sci and IsOK ( Sci ) then
15190: LD_VAR 0 2
15194: PUSH
15195: LD_VAR 0 2
15199: PPUSH
15200: CALL_OW 302
15204: AND
15205: IFFALSE 15243
// begin Say ( Sci , DTimeLapser2-Sci1-1 ) ;
15207: LD_VAR 0 2
15211: PPUSH
15212: LD_STRING DTimeLapser2-Sci1-1
15214: PPUSH
15215: CALL_OW 88
// Say ( Burlak , DTimeLapser2-Bur-1 ) ;
15219: LD_EXP 4
15223: PPUSH
15224: LD_STRING DTimeLapser2-Bur-1
15226: PPUSH
15227: CALL_OW 88
// Say ( Sci , DTimeLapser2-Sci1-2 ) ;
15231: LD_VAR 0 2
15235: PPUSH
15236: LD_STRING DTimeLapser2-Sci1-2
15238: PPUSH
15239: CALL_OW 88
// end ; end ;
15243: LD_VAR 0 1
15247: RET
// export function dialog_ArtefactSteal ; begin
15248: LD_INT 0
15250: PPUSH
// Say ( Burlak , DArtefactSteal-Bur-1 ) ;
15251: LD_EXP 4
15255: PPUSH
15256: LD_STRING DArtefactSteal-Bur-1
15258: PPUSH
15259: CALL_OW 88
// end ;
15263: LD_VAR 0 1
15267: RET
// export function dialog_JMMStart ; var G ; begin
15268: LD_INT 0
15270: PPUSH
15271: PPUSH
// if Gladkov then
15272: LD_EXP 25
15276: IFFALSE 15290
// G = Gladkov else
15278: LD_ADDR_VAR 0 2
15282: PUSH
15283: LD_EXP 25
15287: ST_TO_ADDR
15288: GO 15300
// G = GladkovFake ;
15290: LD_ADDR_VAR 0 2
15294: PUSH
15295: LD_EXP 26
15299: ST_TO_ADDR
// SayRadio ( G , DJMMStart-Gla-1 ) ;
15300: LD_VAR 0 2
15304: PPUSH
15305: LD_STRING DJMMStart-Gla-1
15307: PPUSH
15308: CALL_OW 94
// SayRadio ( Burlak , DJMMStart-Bur-1 ) ;
15312: LD_EXP 4
15316: PPUSH
15317: LD_STRING DJMMStart-Bur-1
15319: PPUSH
15320: CALL_OW 94
// if Kuzmov and IsOK ( Kuzmov ) then
15324: LD_EXP 11
15328: PUSH
15329: LD_EXP 11
15333: PPUSH
15334: CALL_OW 302
15338: AND
15339: IFFALSE 15353
// Say ( Kuzmov , DJMMStart-Kuz-1 ) ;
15341: LD_EXP 11
15345: PPUSH
15346: LD_STRING DJMMStart-Kuz-1
15348: PPUSH
15349: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15353: LD_EXP 7
15357: PUSH
15358: LD_EXP 7
15362: PPUSH
15363: CALL_OW 302
15367: AND
15368: IFFALSE 15382
// Say ( Gnyevko , DJMMStart-Gny-1 ) ;
15370: LD_EXP 7
15374: PPUSH
15375: LD_STRING DJMMStart-Gny-1
15377: PPUSH
15378: CALL_OW 88
// if Petrovova and IsOK ( Petrovova ) then
15382: LD_EXP 13
15386: PUSH
15387: LD_EXP 13
15391: PPUSH
15392: CALL_OW 302
15396: AND
15397: IFFALSE 15411
// Say ( Petrovova , DJMMStart-Ptr-1 ) ;
15399: LD_EXP 13
15403: PPUSH
15404: LD_STRING DJMMStart-Ptr-1
15406: PPUSH
15407: CALL_OW 88
// end ;
15411: LD_VAR 0 1
15415: RET
// export function dialog_JMMAppear ; var Nekdo ; begin
15416: LD_INT 0
15418: PPUSH
15419: PPUSH
// Nekdo = najdi_vojaka ;
15420: LD_ADDR_VAR 0 2
15424: PUSH
15425: CALL 14730 0 0
15429: ST_TO_ADDR
// if Nekdo then
15430: LD_VAR 0 2
15434: IFFALSE 15448
// Say ( Nekdo , DJMMAppear-RSol1-1 ) ;
15436: LD_VAR 0 2
15440: PPUSH
15441: LD_STRING DJMMAppear-RSol1-1
15443: PPUSH
15444: CALL_OW 88
// end ;
15448: LD_VAR 0 1
15452: RET
// export function dialog_JMMEscapes ; var Nekdo ; begin
15453: LD_INT 0
15455: PPUSH
15456: PPUSH
// Nekdo = najdi_vojaka ;
15457: LD_ADDR_VAR 0 2
15461: PUSH
15462: CALL 14730 0 0
15466: ST_TO_ADDR
// if Nekdo and ( Nekdo <> Kuzmov ) and ( Nekdo <> Gnyevko ) then
15467: LD_VAR 0 2
15471: PUSH
15472: LD_VAR 0 2
15476: PUSH
15477: LD_EXP 11
15481: NONEQUAL
15482: AND
15483: PUSH
15484: LD_VAR 0 2
15488: PUSH
15489: LD_EXP 7
15493: NONEQUAL
15494: AND
15495: IFFALSE 15509
// Say ( Nekdo , DJMMEscapes-RSol1-1 ) ;
15497: LD_VAR 0 2
15501: PPUSH
15502: LD_STRING DJMMEscapes-RSol1-1
15504: PPUSH
15505: CALL_OW 88
// if Kuzmov and IsOK ( Kuzmov ) then
15509: LD_EXP 11
15513: PUSH
15514: LD_EXP 11
15518: PPUSH
15519: CALL_OW 302
15523: AND
15524: IFFALSE 15538
// Say ( Kuzmov , DJMMEscapes-Kuz-1 ) ;
15526: LD_EXP 11
15530: PPUSH
15531: LD_STRING DJMMEscapes-Kuz-1
15533: PPUSH
15534: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15538: LD_EXP 7
15542: PUSH
15543: LD_EXP 7
15547: PPUSH
15548: CALL_OW 302
15552: AND
15553: IFFALSE 15567
// Say ( Gnyevko , DJMMEscapes-Gny-1 ) ;
15555: LD_EXP 7
15559: PPUSH
15560: LD_STRING DJMMEscapes-Gny-1
15562: PPUSH
15563: CALL_OW 88
// end ;
15567: LD_VAR 0 1
15571: RET
// export function dialog_JMMDies ; var Nekdo ; begin
15572: LD_INT 0
15574: PPUSH
15575: PPUSH
// Nekdo = najdi_vojaka ;
15576: LD_ADDR_VAR 0 2
15580: PUSH
15581: CALL 14730 0 0
15585: ST_TO_ADDR
// Say ( Burlak , DJMMDies-Bur-1 ) ;
15586: LD_EXP 4
15590: PPUSH
15591: LD_STRING DJMMDies-Bur-1
15593: PPUSH
15594: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15598: LD_EXP 7
15602: PUSH
15603: LD_EXP 7
15607: PPUSH
15608: CALL_OW 302
15612: AND
15613: IFFALSE 15629
// Say ( Gnyevko , DJMMDies-Gny-1 ) else
15615: LD_EXP 7
15619: PPUSH
15620: LD_STRING DJMMDies-Gny-1
15622: PPUSH
15623: CALL_OW 88
15627: GO 15653
// if ( Nekdo <> Burlak ) then
15629: LD_VAR 0 2
15633: PUSH
15634: LD_EXP 4
15638: NONEQUAL
15639: IFFALSE 15653
// Say ( Nekdo , DJMMDies-RSol1-1 ) ;
15641: LD_VAR 0 2
15645: PPUSH
15646: LD_STRING DJMMDies-RSol1-1
15648: PPUSH
15649: CALL_OW 88
// end ; end_of_file
15653: LD_VAR 0 1
15657: RET
// export function max ( A , B ) ; begin
15658: LD_INT 0
15660: PPUSH
// if A > B then
15661: LD_VAR 0 1
15665: PUSH
15666: LD_VAR 0 2
15670: GREATER
15671: IFFALSE 15685
// Result = A else
15673: LD_ADDR_VAR 0 3
15677: PUSH
15678: LD_VAR 0 1
15682: ST_TO_ADDR
15683: GO 15695
// Result = B ;
15685: LD_ADDR_VAR 0 3
15689: PUSH
15690: LD_VAR 0 2
15694: ST_TO_ADDR
// end ;
15695: LD_VAR 0 3
15699: RET
// export function naloz ( Auto , Budova , Material , Pocet ) ; var Base , Kolik , Volno ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
15704: PPUSH
15705: PPUSH
// if not GetWeapon ( Auto ) in [ US_CARGO_BAY , RU_CARGO_BAY , AR_CARGO_BAY ] then
15706: LD_VAR 0 1
15710: PPUSH
15711: CALL_OW 264
15715: PUSH
15716: LD_INT 12
15718: PUSH
15719: LD_INT 51
15721: PUSH
15722: LD_INT 32
15724: PUSH
15725: EMPTY
15726: LIST
15727: LIST
15728: LIST
15729: IN
15730: NOT
15731: IFFALSE 15735
// exit ;
15733: GO 15909
// Base = GetBase ( Budova ) ;
15735: LD_ADDR_VAR 0 6
15739: PUSH
15740: LD_VAR 0 2
15744: PPUSH
15745: CALL_OW 274
15749: ST_TO_ADDR
// Kolik = GetResourceType ( Base , Material ) ;
15750: LD_ADDR_VAR 0 7
15754: PUSH
15755: LD_VAR 0 6
15759: PPUSH
15760: LD_VAR 0 3
15764: PPUSH
15765: CALL_OW 275
15769: ST_TO_ADDR
// if Kolik = 0 then
15770: LD_VAR 0 7
15774: PUSH
15775: LD_INT 0
15777: EQUAL
15778: IFFALSE 15782
// exit ;
15780: GO 15909
// Volno = CanCarryHowMuch ( Auto ) ;
15782: LD_ADDR_VAR 0 8
15786: PUSH
15787: LD_VAR 0 1
15791: PPUSH
15792: CALL_OW 466
15796: ST_TO_ADDR
// if Volno = 0 then
15797: LD_VAR 0 8
15801: PUSH
15802: LD_INT 0
15804: EQUAL
15805: IFFALSE 15809
// exit ;
15807: GO 15909
// if Pocet > Kolik then
15809: LD_VAR 0 4
15813: PUSH
15814: LD_VAR 0 7
15818: GREATER
15819: IFFALSE 15831
// Pocet = Kolik ;
15821: LD_ADDR_VAR 0 4
15825: PUSH
15826: LD_VAR 0 7
15830: ST_TO_ADDR
// if Pocet > Volno then
15831: LD_VAR 0 4
15835: PUSH
15836: LD_VAR 0 8
15840: GREATER
15841: IFFALSE 15853
// Pocet = Volno ;
15843: LD_ADDR_VAR 0 4
15847: PUSH
15848: LD_VAR 0 8
15852: ST_TO_ADDR
// if Pocet = 0 then
15853: LD_VAR 0 4
15857: PUSH
15858: LD_INT 0
15860: EQUAL
15861: IFFALSE 15865
// exit ;
15863: GO 15909
// SetResourceType ( Base , Material , Kolik - Pocet ) ;
15865: LD_VAR 0 6
15869: PPUSH
15870: LD_VAR 0 3
15874: PPUSH
15875: LD_VAR 0 7
15879: PUSH
15880: LD_VAR 0 4
15884: MINUS
15885: PPUSH
15886: CALL_OW 277
// AddCargo ( Auto , Material , Pocet ) ;
15890: LD_VAR 0 1
15894: PPUSH
15895: LD_VAR 0 3
15899: PPUSH
15900: LD_VAR 0 4
15904: PPUSH
15905: CALL_OW 291
// end ;
15909: LD_VAR 0 5
15913: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
15914: LD_INT 0
15916: PPUSH
15917: PPUSH
15918: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
15919: LD_ADDR_VAR 0 4
15923: PUSH
15924: LD_INT 22
15926: PUSH
15927: LD_VAR 0 2
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: EMPTY
15937: LIST
15938: PPUSH
15939: CALL_OW 69
15943: ST_TO_ADDR
// for Jednotka in KohoJednotky do
15944: LD_ADDR_VAR 0 5
15948: PUSH
15949: LD_VAR 0 4
15953: PUSH
15954: FOR_IN
15955: IFFALSE 15987
// if See ( Kdo , Jednotka ) then
15957: LD_VAR 0 1
15961: PPUSH
15962: LD_VAR 0 5
15966: PPUSH
15967: CALL_OW 292
15971: IFFALSE 15985
// begin Result = true ;
15973: LD_ADDR_VAR 0 3
15977: PUSH
15978: LD_INT 1
15980: ST_TO_ADDR
// exit ;
15981: POP
15982: POP
15983: GO 15997
// end ;
15985: GO 15954
15987: POP
15988: POP
// Result = false ;
15989: LD_ADDR_VAR 0 3
15993: PUSH
15994: LD_INT 0
15996: ST_TO_ADDR
// end ;
15997: LD_VAR 0 3
16001: RET
// export function bez_opic ( List ) ; var Opice ; begin
16002: LD_INT 0
16004: PPUSH
16005: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
16006: LD_ADDR_VAR 0 3
16010: PUSH
16011: LD_VAR 0 1
16015: PPUSH
16016: LD_INT 2
16018: PUSH
16019: LD_INT 25
16021: PUSH
16022: LD_INT 12
16024: PUSH
16025: EMPTY
16026: LIST
16027: LIST
16028: PUSH
16029: LD_INT 25
16031: PUSH
16032: LD_INT 15
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PUSH
16039: LD_INT 25
16041: PUSH
16042: LD_INT 16
16044: PUSH
16045: EMPTY
16046: LIST
16047: LIST
16048: PUSH
16049: LD_INT 25
16051: PUSH
16052: LD_INT 17
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: PUSH
16059: EMPTY
16060: LIST
16061: LIST
16062: LIST
16063: LIST
16064: LIST
16065: PUSH
16066: EMPTY
16067: LIST
16068: PPUSH
16069: CALL_OW 72
16073: ST_TO_ADDR
// Result = List diff Opice ;
16074: LD_ADDR_VAR 0 2
16078: PUSH
16079: LD_VAR 0 1
16083: PUSH
16084: LD_VAR 0 3
16088: DIFF
16089: ST_TO_ADDR
// end ;
16090: LD_VAR 0 2
16094: RET
// export function opravuj_budovy ( Jednotky , Area , Side ) ; var Budovy , Opravit , I , Kde ; begin
16095: LD_INT 0
16097: PPUSH
16098: PPUSH
16099: PPUSH
16100: PPUSH
16101: PPUSH
// Budovy = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , Side ] ] ) ;
16102: LD_ADDR_VAR 0 5
16106: PUSH
16107: LD_VAR 0 2
16111: PPUSH
16112: LD_INT 21
16114: PUSH
16115: LD_INT 3
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 22
16124: PUSH
16125: LD_VAR 0 3
16129: PUSH
16130: EMPTY
16131: LIST
16132: LIST
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 70
16142: ST_TO_ADDR
// Opravit = [ ] ;
16143: LD_ADDR_VAR 0 6
16147: PUSH
16148: EMPTY
16149: ST_TO_ADDR
// for I in Budovy do
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_VAR 0 5
16159: PUSH
16160: FOR_IN
16161: IFFALSE 16199
// if GetLives ( I ) < HRANICE_ZDRAVI then
16163: LD_VAR 0 7
16167: PPUSH
16168: CALL_OW 256
16172: PUSH
16173: LD_INT 1000
16175: LESS
16176: IFFALSE 16197
// Opravit = Opravit union [ I ] ;
16178: LD_ADDR_VAR 0 6
16182: PUSH
16183: LD_VAR 0 6
16187: PUSH
16188: LD_VAR 0 7
16192: PUSH
16193: EMPTY
16194: LIST
16195: UNION
16196: ST_TO_ADDR
16197: GO 16160
16199: POP
16200: POP
// for I in Opravit do
16201: LD_ADDR_VAR 0 7
16205: PUSH
16206: LD_VAR 0 6
16210: PUSH
16211: FOR_IN
16212: IFFALSE 16230
// AddComRepairBuilding ( Jednotky , I ) ;
16214: LD_VAR 0 1
16218: PPUSH
16219: LD_VAR 0 7
16223: PPUSH
16224: CALL_OW 190
16228: GO 16211
16230: POP
16231: POP
// end ;
16232: LD_VAR 0 4
16236: RET
// export function sbirej_bedny ( Jednotky , Area ) ; var I , Ok , Kdo , Bedny , Delka , X , Y ; begin
16237: LD_INT 0
16239: PPUSH
16240: PPUSH
16241: PPUSH
16242: PPUSH
16243: PPUSH
16244: PPUSH
16245: PPUSH
16246: PPUSH
// Ok = false ;
16247: LD_ADDR_VAR 0 5
16251: PUSH
16252: LD_INT 0
16254: ST_TO_ADDR
// for Kdo in Jednotky do
16255: LD_ADDR_VAR 0 6
16259: PUSH
16260: LD_VAR 0 1
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16291
// if IsOk ( Kdo ) then
16268: LD_VAR 0 6
16272: PPUSH
16273: CALL_OW 302
16277: IFFALSE 16289
// begin Ok = true ;
16279: LD_ADDR_VAR 0 5
16283: PUSH
16284: LD_INT 1
16286: ST_TO_ADDR
// break ;
16287: GO 16291
// end ;
16289: GO 16265
16291: POP
16292: POP
// if not Ok then
16293: LD_VAR 0 5
16297: NOT
16298: IFFALSE 16302
// exit ;
16300: GO 16462
// Bedny = GetListOfCratesInArea ( Area ) ;
16302: LD_ADDR_VAR 0 7
16306: PUSH
16307: LD_VAR 0 2
16311: PPUSH
16312: CALL_OW 435
16316: ST_TO_ADDR
// if not Bedny then
16317: LD_VAR 0 7
16321: NOT
16322: IFFALSE 16326
// exit ;
16324: GO 16462
// Delka = Bedny div 2 ;
16326: LD_ADDR_VAR 0 8
16330: PUSH
16331: LD_VAR 0 7
16335: PUSH
16336: LD_INT 2
16338: DIV
16339: ST_TO_ADDR
// for I = 1 to Delka do
16340: LD_ADDR_VAR 0 4
16344: PUSH
16345: DOUBLE
16346: LD_INT 1
16348: DEC
16349: ST_TO_ADDR
16350: LD_VAR 0 8
16354: PUSH
16355: FOR_TO
16356: IFFALSE 16460
// begin X = Bedny [ 2 * I - 1 ] ;
16358: LD_ADDR_VAR 0 9
16362: PUSH
16363: LD_VAR 0 7
16367: PUSH
16368: LD_INT 2
16370: PUSH
16371: LD_VAR 0 4
16375: MUL
16376: PUSH
16377: LD_INT 1
16379: MINUS
16380: ARRAY
16381: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
16382: LD_ADDR_VAR 0 10
16386: PUSH
16387: LD_VAR 0 7
16391: PUSH
16392: LD_INT 2
16394: PUSH
16395: LD_VAR 0 4
16399: MUL
16400: ARRAY
16401: ST_TO_ADDR
// for Kdo in Jednotky do
16402: LD_ADDR_VAR 0 6
16406: PUSH
16407: LD_VAR 0 1
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16456
// if IsOk ( Kdo ) and Prob ( 50 ) then
16415: LD_VAR 0 6
16419: PPUSH
16420: CALL_OW 302
16424: PUSH
16425: LD_INT 50
16427: PPUSH
16428: CALL_OW 13
16432: AND
16433: IFFALSE 16454
// AddComCollect ( Kdo , X , Y ) ;
16435: LD_VAR 0 6
16439: PPUSH
16440: LD_VAR 0 9
16444: PPUSH
16445: LD_VAR 0 10
16449: PPUSH
16450: CALL_OW 177
16454: GO 16412
16456: POP
16457: POP
// end ;
16458: GO 16355
16460: POP
16461: POP
// end ;
16462: LD_VAR 0 3
16466: RET
// export function opravuj_auta ( List , Event , Area , Side , Ignore ) ; var Auta , Opravit , I , Kde , Mech ; begin
16467: LD_INT 0
16469: PPUSH
16470: PPUSH
16471: PPUSH
16472: PPUSH
16473: PPUSH
16474: PPUSH
// Result = [ ] ;
16475: LD_ADDR_VAR 0 6
16479: PUSH
16480: EMPTY
16481: ST_TO_ADDR
// Mech = 0 ;
16482: LD_ADDR_VAR 0 11
16486: PUSH
16487: LD_INT 0
16489: ST_TO_ADDR
// for I in List do
16490: LD_ADDR_VAR 0 9
16494: PUSH
16495: LD_VAR 0 1
16499: PUSH
16500: FOR_IN
16501: IFFALSE 16528
// if IsOk ( I ) then
16503: LD_VAR 0 9
16507: PPUSH
16508: CALL_OW 302
16512: IFFALSE 16526
// begin Mech = I ;
16514: LD_ADDR_VAR 0 11
16518: PUSH
16519: LD_VAR 0 9
16523: ST_TO_ADDR
// break ;
16524: GO 16528
// end ;
16526: GO 16500
16528: POP
16529: POP
// if not Mech then
16530: LD_VAR 0 11
16534: NOT
16535: IFFALSE 16539
// exit ;
16537: GO 16764
// Auta = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , Side ] ] ) diff Ignore ;
16539: LD_ADDR_VAR 0 7
16543: PUSH
16544: LD_VAR 0 3
16548: PPUSH
16549: LD_INT 21
16551: PUSH
16552: LD_INT 2
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: LD_INT 22
16561: PUSH
16562: LD_VAR 0 4
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 70
16579: PUSH
16580: LD_VAR 0 5
16584: DIFF
16585: ST_TO_ADDR
// Opravit = [ ] ;
16586: LD_ADDR_VAR 0 8
16590: PUSH
16591: EMPTY
16592: ST_TO_ADDR
// for I in Auta do
16593: LD_ADDR_VAR 0 9
16597: PUSH
16598: LD_VAR 0 7
16602: PUSH
16603: FOR_IN
16604: IFFALSE 16642
// if GetLives ( I ) < HRANICE_ZDRAVI then
16606: LD_VAR 0 9
16610: PPUSH
16611: CALL_OW 256
16615: PUSH
16616: LD_INT 1000
16618: LESS
16619: IFFALSE 16640
// Opravit = Opravit union [ I ] ;
16621: LD_ADDR_VAR 0 8
16625: PUSH
16626: LD_VAR 0 8
16630: PUSH
16631: LD_VAR 0 9
16635: PUSH
16636: EMPTY
16637: LIST
16638: UNION
16639: ST_TO_ADDR
16640: GO 16603
16642: POP
16643: POP
// if Opravit then
16644: LD_VAR 0 8
16648: IFFALSE 16764
// begin Kde = IsInUnit ( Mech ) ;
16650: LD_ADDR_VAR 0 10
16654: PUSH
16655: LD_VAR 0 11
16659: PPUSH
16660: CALL_OW 310
16664: ST_TO_ADDR
// if Kde then
16665: LD_VAR 0 10
16669: IFFALSE 16706
// if GetType ( Kde ) = UNIT_BUILDING then
16671: LD_VAR 0 10
16675: PPUSH
16676: CALL_OW 247
16680: PUSH
16681: LD_INT 3
16683: EQUAL
16684: IFFALSE 16697
// ComExitBuilding ( Mech ) else
16686: LD_VAR 0 11
16690: PPUSH
16691: CALL_OW 122
16695: GO 16706
// ComExitVehicle ( Mech ) ;
16697: LD_VAR 0 11
16701: PPUSH
16702: CALL_OW 121
// for I in Opravit do
16706: LD_ADDR_VAR 0 9
16710: PUSH
16711: LD_VAR 0 8
16715: PUSH
16716: FOR_IN
16717: IFFALSE 16735
// AddComRepairVehicle ( Mech , I ) ;
16719: LD_VAR 0 11
16723: PPUSH
16724: LD_VAR 0 9
16728: PPUSH
16729: CALL_OW 189
16733: GO 16716
16735: POP
16736: POP
// AddComSailEvent ( Mech , Event ) ;
16737: LD_VAR 0 11
16741: PPUSH
16742: LD_VAR 0 2
16746: PPUSH
16747: CALL_OW 224
// Result = [ Mech ] ;
16751: LD_ADDR_VAR 0 6
16755: PUSH
16756: LD_VAR 0 11
16760: PUSH
16761: EMPTY
16762: LIST
16763: ST_TO_ADDR
// end ; end ;
16764: LD_VAR 0 6
16768: RET
// export function kuryruj_lidi ( List , Event , Area , Side ) ; var Lidi , Opravit , I , Kde , Felcar , Budova ; begin
16769: LD_INT 0
16771: PPUSH
16772: PPUSH
16773: PPUSH
16774: PPUSH
16775: PPUSH
16776: PPUSH
16777: PPUSH
// Result = [ ] ;
16778: LD_ADDR_VAR 0 5
16782: PUSH
16783: EMPTY
16784: ST_TO_ADDR
// Felcar = 0 ;
16785: LD_ADDR_VAR 0 10
16789: PUSH
16790: LD_INT 0
16792: ST_TO_ADDR
// for I in List do
16793: LD_ADDR_VAR 0 8
16797: PUSH
16798: LD_VAR 0 1
16802: PUSH
16803: FOR_IN
16804: IFFALSE 16831
// if IsOk ( I ) then
16806: LD_VAR 0 8
16810: PPUSH
16811: CALL_OW 302
16815: IFFALSE 16829
// begin Felcar = I ;
16817: LD_ADDR_VAR 0 10
16821: PUSH
16822: LD_VAR 0 8
16826: ST_TO_ADDR
// break ;
16827: GO 16831
// end ;
16829: GO 16803
16831: POP
16832: POP
// Lidi = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , Side ] ] ) ;
16833: LD_ADDR_VAR 0 6
16837: PUSH
16838: LD_VAR 0 3
16842: PPUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 1
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: LD_INT 22
16855: PUSH
16856: LD_VAR 0 4
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: PPUSH
16869: CALL_OW 70
16873: ST_TO_ADDR
// Opravit = [ ] ;
16874: LD_ADDR_VAR 0 7
16878: PUSH
16879: EMPTY
16880: ST_TO_ADDR
// for I in Lidi do
16881: LD_ADDR_VAR 0 8
16885: PUSH
16886: LD_VAR 0 6
16890: PUSH
16891: FOR_IN
16892: IFFALSE 16930
// if GetLives ( I ) < HRANICE_ZDRAVI then
16894: LD_VAR 0 8
16898: PPUSH
16899: CALL_OW 256
16903: PUSH
16904: LD_INT 1000
16906: LESS
16907: IFFALSE 16928
// Opravit = Opravit union [ I ] ;
16909: LD_ADDR_VAR 0 7
16913: PUSH
16914: LD_VAR 0 7
16918: PUSH
16919: LD_VAR 0 8
16923: PUSH
16924: EMPTY
16925: LIST
16926: UNION
16927: ST_TO_ADDR
16928: GO 16891
16930: POP
16931: POP
// if Opravit then
16932: LD_VAR 0 7
16936: IFFALSE 17052
// begin Kde = IsInUnit ( Felcar ) ;
16938: LD_ADDR_VAR 0 9
16942: PUSH
16943: LD_VAR 0 10
16947: PPUSH
16948: CALL_OW 310
16952: ST_TO_ADDR
// if Kde then
16953: LD_VAR 0 9
16957: IFFALSE 16994
// if GetType ( Kde ) = UNIT_BUILDING then
16959: LD_VAR 0 9
16963: PPUSH
16964: CALL_OW 247
16968: PUSH
16969: LD_INT 3
16971: EQUAL
16972: IFFALSE 16985
// ComExitBuilding ( Felcar ) else
16974: LD_VAR 0 10
16978: PPUSH
16979: CALL_OW 122
16983: GO 16994
// ComExitVehicle ( Felcar ) ;
16985: LD_VAR 0 10
16989: PPUSH
16990: CALL_OW 121
// for I in Opravit do
16994: LD_ADDR_VAR 0 8
16998: PUSH
16999: LD_VAR 0 7
17003: PUSH
17004: FOR_IN
17005: IFFALSE 17023
// AddComHeal ( Felcar , I ) ;
17007: LD_VAR 0 10
17011: PPUSH
17012: LD_VAR 0 8
17016: PPUSH
17017: CALL_OW 188
17021: GO 17004
17023: POP
17024: POP
// AddComSailEvent ( Felcar , Event ) ;
17025: LD_VAR 0 10
17029: PPUSH
17030: LD_VAR 0 2
17034: PPUSH
17035: CALL_OW 224
// Result = [ Felcar ] ;
17039: LD_ADDR_VAR 0 5
17043: PUSH
17044: LD_VAR 0 10
17048: PUSH
17049: EMPTY
17050: LIST
17051: ST_TO_ADDR
// end ; end ;
17052: LD_VAR 0 5
17056: RET
// export function zije_zakladna ( Side , Depot , Area , Lidi ) ; var I , List ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
// Result = true ;
17062: LD_ADDR_VAR 0 5
17066: PUSH
17067: LD_INT 1
17069: ST_TO_ADDR
// for I in Lidi do
17070: LD_ADDR_VAR 0 6
17074: PUSH
17075: LD_VAR 0 4
17079: PUSH
17080: FOR_IN
17081: IFFALSE 17117
// if ( GetSide ( I ) = Side ) and IsOk ( I ) then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 255
17092: PUSH
17093: LD_VAR 0 1
17097: EQUAL
17098: PUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 302
17108: AND
17109: IFFALSE 17115
// exit ;
17111: POP
17112: POP
17113: GO 17248
17115: GO 17080
17117: POP
17118: POP
// List = FilterUnitsInArea ( Area , [ [ F_SIDE , Side ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_OR , [ F_BTYPE , B_DEPOT ] , [ F_BTYPE , B_WAREHOUSE ] ] ] ) ;
17119: LD_ADDR_VAR 0 7
17123: PUSH
17124: LD_VAR 0 3
17128: PPUSH
17129: LD_INT 22
17131: PUSH
17132: LD_VAR 0 1
17136: PUSH
17137: EMPTY
17138: LIST
17139: LIST
17140: PUSH
17141: LD_INT 21
17143: PUSH
17144: LD_INT 3
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: PUSH
17151: LD_INT 50
17153: PUSH
17154: EMPTY
17155: LIST
17156: PUSH
17157: LD_INT 2
17159: PUSH
17160: LD_INT 30
17162: PUSH
17163: LD_INT 0
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 30
17172: PUSH
17173: LD_INT 1
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: PPUSH
17191: CALL_OW 70
17195: ST_TO_ADDR
// if List then
17196: LD_VAR 0 7
17200: IFFALSE 17204
// exit ;
17202: GO 17248
// if Depot and ( GetSide ( Depot ) = Side ) and IsOk ( Depot ) then
17204: LD_VAR 0 2
17208: PUSH
17209: LD_VAR 0 2
17213: PPUSH
17214: CALL_OW 255
17218: PUSH
17219: LD_VAR 0 1
17223: EQUAL
17224: AND
17225: PUSH
17226: LD_VAR 0 2
17230: PPUSH
17231: CALL_OW 302
17235: AND
17236: IFFALSE 17240
// exit ;
17238: GO 17248
// Result = false ;
17240: LD_ADDR_VAR 0 5
17244: PUSH
17245: LD_INT 0
17247: ST_TO_ADDR
// end ;
17248: LD_VAR 0 5
17252: RET
// export function nahoda_seznam ( Seznam ) ; begin
17253: LD_INT 0
17255: PPUSH
// if Seznam then
17256: LD_VAR 0 1
17260: IFFALSE 17288
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
17262: LD_ADDR_VAR 0 2
17266: PUSH
17267: LD_VAR 0 1
17271: PUSH
17272: LD_INT 1
17274: PPUSH
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL_OW 12
17284: ARRAY
17285: ST_TO_ADDR
17286: GO 17296
// Result = 0 ;
17288: LD_ADDR_VAR 0 2
17292: PUSH
17293: LD_INT 0
17295: ST_TO_ADDR
// end ;
17296: LD_VAR 0 2
17300: RET
// function uvolni_material ( Auto , Kolik , Co ) ; var Veze ; begin
17301: LD_INT 0
17303: PPUSH
17304: PPUSH
// Veze = GetCargo ( Auto , Co ) ;
17305: LD_ADDR_VAR 0 5
17309: PUSH
17310: LD_VAR 0 1
17314: PPUSH
17315: LD_VAR 0 3
17319: PPUSH
17320: CALL_OW 289
17324: ST_TO_ADDR
// if Veze > 0 then
17325: LD_VAR 0 5
17329: PUSH
17330: LD_INT 0
17332: GREATER
17333: IFFALSE 17392
// begin if ( Kolik >= Veze ) then
17335: LD_VAR 0 2
17339: PUSH
17340: LD_VAR 0 5
17344: GREATEREQUAL
17345: IFFALSE 17357
// Veze = 0 else
17347: LD_ADDR_VAR 0 5
17351: PUSH
17352: LD_INT 0
17354: ST_TO_ADDR
17355: GO 17373
// Veze = Veze - Kolik ;
17357: LD_ADDR_VAR 0 5
17361: PUSH
17362: LD_VAR 0 5
17366: PUSH
17367: LD_VAR 0 2
17371: MINUS
17372: ST_TO_ADDR
// SetCargo ( Auto , Co , Veze ) ;
17373: LD_VAR 0 1
17377: PPUSH
17378: LD_VAR 0 3
17382: PPUSH
17383: LD_VAR 0 5
17387: PPUSH
17388: CALL_OW 290
// end ; end ;
17392: LD_VAR 0 4
17396: RET
// export function uvolni_auto ( Auto , Kolik ) ; var Uveze ; begin
17397: LD_INT 0
17399: PPUSH
17400: PPUSH
// Uveze = CanCarryHowMuch ( Auto ) ;
17401: LD_ADDR_VAR 0 4
17405: PUSH
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL_OW 466
17415: ST_TO_ADDR
// if Uveze >= Kolik then
17416: LD_VAR 0 4
17420: PUSH
17421: LD_VAR 0 2
17425: GREATEREQUAL
17426: IFFALSE 17430
// exit ;
17428: GO 17557
// uvolni_material ( Auto , Kolik - Uveze , MAT_CANS ) ;
17430: LD_VAR 0 1
17434: PPUSH
17435: LD_VAR 0 2
17439: PUSH
17440: LD_VAR 0 4
17444: MINUS
17445: PPUSH
17446: LD_INT 1
17448: PPUSH
17449: CALL 17301 0 3
// Uveze = CanCarryHowMuch ( Auto ) ;
17453: LD_ADDR_VAR 0 4
17457: PUSH
17458: LD_VAR 0 1
17462: PPUSH
17463: CALL_OW 466
17467: ST_TO_ADDR
// if Uveze >= Kolik then
17468: LD_VAR 0 4
17472: PUSH
17473: LD_VAR 0 2
17477: GREATEREQUAL
17478: IFFALSE 17482
// exit ;
17480: GO 17557
// uvolni_material ( Auto , Kolik - Uveze , MAT_OIL ) ;
17482: LD_VAR 0 1
17486: PPUSH
17487: LD_VAR 0 2
17491: PUSH
17492: LD_VAR 0 4
17496: MINUS
17497: PPUSH
17498: LD_INT 2
17500: PPUSH
17501: CALL 17301 0 3
// Uveze = CanCarryHowMuch ( Auto ) ;
17505: LD_ADDR_VAR 0 4
17509: PUSH
17510: LD_VAR 0 1
17514: PPUSH
17515: CALL_OW 466
17519: ST_TO_ADDR
// if Uveze >= Kolik then
17520: LD_VAR 0 4
17524: PUSH
17525: LD_VAR 0 2
17529: GREATEREQUAL
17530: IFFALSE 17534
// exit ;
17532: GO 17557
// uvolni_material ( Auto , Kolik - Uveze , MAT_SIBERIT ) ;
17534: LD_VAR 0 1
17538: PPUSH
17539: LD_VAR 0 2
17543: PUSH
17544: LD_VAR 0 4
17548: MINUS
17549: PPUSH
17550: LD_INT 3
17552: PPUSH
17553: CALL 17301 0 3
// end ; end_of_file
17557: LD_VAR 0 3
17561: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
17562: LD_INT 0
17564: PPUSH
17565: PPUSH
17566: PPUSH
// Result = [ ] ;
17567: LD_ADDR_VAR 0 4
17571: PUSH
17572: EMPTY
17573: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
17574: LD_ADDR_OWVAR 21
17578: PUSH
17579: LD_INT 0
17581: ST_TO_ADDR
// UC_side = side_neutral ;
17582: LD_ADDR_OWVAR 20
17586: PUSH
17587: LD_EXP 1
17591: ST_TO_ADDR
// HC_Class = Cls ;
17592: LD_ADDR_OWVAR 28
17596: PUSH
17597: LD_VAR 0 1
17601: ST_TO_ADDR
// HC_Name =  ;
17602: LD_ADDR_OWVAR 26
17606: PUSH
17607: LD_STRING 
17609: ST_TO_ADDR
// hc_agressivity = rand ( 0 , 20 ) ;
17610: LD_ADDR_OWVAR 35
17614: PUSH
17615: LD_INT 0
17617: PPUSH
17618: LD_INT 20
17620: PPUSH
17621: CALL_OW 12
17625: ST_TO_ADDR
// for i = 1 to Cnt do
17626: LD_ADDR_VAR 0 5
17630: PUSH
17631: DOUBLE
17632: LD_INT 1
17634: DEC
17635: ST_TO_ADDR
17636: LD_VAR 0 2
17640: PUSH
17641: FOR_TO
17642: IFFALSE 17692
// begin h = CreateHuman ;
17644: LD_ADDR_VAR 0 6
17648: PUSH
17649: CALL_OW 44
17653: ST_TO_ADDR
// Result = Result union [ h ] ;
17654: LD_ADDR_VAR 0 4
17658: PUSH
17659: LD_VAR 0 4
17663: PUSH
17664: LD_VAR 0 6
17668: PUSH
17669: EMPTY
17670: LIST
17671: UNION
17672: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
17673: LD_VAR 0 6
17677: PPUSH
17678: LD_VAR 0 3
17682: PPUSH
17683: LD_INT 0
17685: PPUSH
17686: CALL_OW 49
// end ;
17690: GO 17641
17692: POP
17693: POP
// end ;
17694: LD_VAR 0 4
17698: RET
// export function init_nature ; begin
17699: LD_INT 0
17701: PPUSH
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les_N ) ;
17702: LD_INT 12
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: LD_INT 7
17710: PPUSH
17711: CALL_OW 12
17715: PUSH
17716: LD_OWVAR 67
17720: MINUS
17721: PPUSH
17722: LD_INT 11
17724: PPUSH
17725: CALL 17562 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les_S ) ;
17729: LD_INT 12
17731: PPUSH
17732: LD_INT 5
17734: PPUSH
17735: LD_INT 7
17737: PPUSH
17738: CALL_OW 12
17742: PUSH
17743: LD_OWVAR 67
17747: MINUS
17748: PPUSH
17749: LD_INT 12
17751: PPUSH
17752: CALL 17562 0 3
// create_nature ( CLASS_TIGER , Rand ( 3 , 5 ) , Les ) ;
17756: LD_INT 14
17758: PPUSH
17759: LD_INT 3
17761: PPUSH
17762: LD_INT 5
17764: PPUSH
17765: CALL_OW 12
17769: PPUSH
17770: LD_INT 13
17772: PPUSH
17773: CALL 17562 0 3
// create_nature ( CLASS_PHORORHACOS , Rand ( 2 , 4 ) , Louka ) ;
17777: LD_INT 18
17779: PPUSH
17780: LD_INT 2
17782: PPUSH
17783: LD_INT 4
17785: PPUSH
17786: CALL_OW 12
17790: PPUSH
17791: LD_INT 14
17793: PPUSH
17794: CALL 17562 0 3
// end ; end_of_file
17798: LD_VAR 0 1
17802: RET
// every 0 0$2 + 0 0$0.1 do
17803: GO 17805
17805: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17806: LD_INT 22
17808: PUSH
17809: LD_INT 3
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: PUSH
17816: LD_INT 2
17818: PUSH
17819: LD_INT 25
17821: PUSH
17822: LD_INT 12
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PUSH
17829: LD_INT 25
17831: PUSH
17832: LD_INT 16
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: PUSH
17839: LD_INT 25
17841: PUSH
17842: LD_INT 15
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: PUSH
17849: LD_INT 25
17851: PUSH
17852: LD_INT 17
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PPUSH
17870: CALL_OW 69
17874: PUSH
17875: LD_INT 22
17877: PUSH
17878: LD_INT 3
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: LD_INT 21
17887: PUSH
17888: LD_INT 1
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: PUSH
17895: LD_INT 3
17897: PUSH
17898: LD_INT 2
17900: PUSH
17901: LD_INT 25
17903: PUSH
17904: LD_INT 12
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PUSH
17911: LD_INT 25
17913: PUSH
17914: LD_INT 16
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 25
17923: PUSH
17924: LD_INT 15
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: LD_INT 25
17933: PUSH
17934: LD_INT 17
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: LIST
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: LIST
17956: PPUSH
17957: CALL_OW 69
17961: GREATER
17962: IFFALSE 17973
// begin SetAchievement ( ACH_POTA ) ;
17964: LD_STRING ACH_POTA
17966: PPUSH
17967: CALL_OW 543
// exit ;
17971: GO 17974
// end ; enable ;
17973: ENABLE
// end ;
17974: END
// export function SA_OnJMMKilled ; begin
17975: LD_INT 0
17977: PPUSH
// SetAchievement ( ACH_FRWL ) ;
17978: LD_STRING ACH_FRWL
17980: PPUSH
17981: CALL_OW 543
// end ;
17985: LD_VAR 0 1
17989: RET

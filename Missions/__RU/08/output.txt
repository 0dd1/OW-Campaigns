// export Burlak , Popov , Belkov , Kirilenkova , Gnyevko , Kapitsova , Dietrich , Gleb , Petrosyan , Kuzmov , Heike , Kovalyuk , Kurt , Mercenary1 , Scholtze , ASoldier1 , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Dolgov , Xavier , other , player_units , amattack , depot_build , depotX , depotY , you , ally , arab , merc , usa , GenscherBetrayed , HeikeCaptured , HeikeKilled , MercPaid , MercHandedOver , MercWillBeHandedOver , MercHandoverDone , MercHandoverArabsSpawned , MercAccepted , HeikeDismissed , PopovAsked , HuntingAccepted , BuildingsDone , TurretsDone , WeaponsDone , TechnoDone , MortarDone , GalleryBuild , AvailableWeapons , AvailableBuildings , AvailableTechno , FreeMan , FreeWoman , FreeTimeGranted , Masha , CompVehConstructed , LimitTeleportResearched , LimitTeleportTested , AmAttackDone , HeikeSend , GalleryAsked , HuntingAsked , FreetimeAsked , MortarAsked , MashaAsked , AmAttackStarted , hunter , speed , am_attack_skill , weaker , stronger , countdown , pocetmercenaries , snipers_positions , ar_human , MercenaryWillBeHealen , KurtWillBeHealen , WasSelected , CountTrees , GenCount , disabled2 , disabled3 , disabled4 , disabled5 , disabled6 , disabled7 , disabled8 , disabled9 , disabled102 ; export testing ; function read_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// you := 3 ;
   4: LD_ADDR_EXP 31
   8: PUSH
   9: LD_INT 3
  11: ST_TO_ADDR
// ally := 6 ;
  12: LD_ADDR_EXP 32
  16: PUSH
  17: LD_INT 6
  19: ST_TO_ADDR
// arab := 2 ;
  20: LD_ADDR_EXP 33
  24: PUSH
  25: LD_INT 2
  27: ST_TO_ADDR
// merc := 5 ;
  28: LD_ADDR_EXP 34
  32: PUSH
  33: LD_INT 5
  35: ST_TO_ADDR
// usa := 1 ;
  36: LD_ADDR_EXP 35
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// HeikeCaptured := LoadVariable ( HeikeCaptured , true ) ;
  44: LD_ADDR_EXP 37
  48: PUSH
  49: LD_STRING HeikeCaptured
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: CALL_OW 30
  59: ST_TO_ADDR
// SetAttitude ( you , ally , att_friend , true ) ;
  60: LD_EXP 31
  64: PPUSH
  65: LD_EXP 32
  69: PPUSH
  70: LD_INT 1
  72: PPUSH
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 80
// SetAttitude ( you , merc , att_neutral , true ) ;
  80: LD_EXP 31
  84: PPUSH
  85: LD_EXP 34
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: CALL_OW 80
// SetAttitude ( you , arab , att_neutral , true ) ;
 100: LD_EXP 31
 104: PPUSH
 105: LD_EXP 33
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: CALL_OW 80
// SetAttitude ( you , usa , att_enemy , true ) ;
 120: LD_EXP 31
 124: PPUSH
 125: LD_EXP 35
 129: PPUSH
 130: LD_INT 2
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 80
// SetAttitude ( ally , merc , att_friend , true ) ;
 140: LD_EXP 32
 144: PPUSH
 145: LD_EXP 34
 149: PPUSH
 150: LD_INT 1
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 80
// SetAttitude ( ally , arab , att_friend , true ) ;
 160: LD_EXP 32
 164: PPUSH
 165: LD_EXP 33
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 80
// SetAttitude ( ally , usa , att_friend , true ) ;
 180: LD_EXP 32
 184: PPUSH
 185: LD_EXP 35
 189: PPUSH
 190: LD_INT 1
 192: PPUSH
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 80
// SetAttitude ( merc , usa , att_neutral , true ) ;
 200: LD_EXP 34
 204: PPUSH
 205: LD_EXP 35
 209: PPUSH
 210: LD_INT 0
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: CALL_OW 80
// SetAttitude ( arab , usa , att_neutral , true ) ;
 220: LD_EXP 33
 224: PPUSH
 225: LD_EXP 35
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 1
 235: PPUSH
 236: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 240: LD_EXP 32
 244: PPUSH
 245: LD_EXP 31
 249: PPUSH
 250: CALL_OW 343
// HeikeDismissed := false ;
 254: LD_ADDR_EXP 45
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// MercAccepted := false ;
 262: LD_ADDR_EXP 44
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// MercPaid := false ;
 270: LD_ADDR_EXP 39
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// BuildingsDone := false ;
 278: LD_ADDR_EXP 48
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// WeaponsDone := false ;
 286: LD_ADDR_EXP 50
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// TechnoDone := false ;
 294: LD_ADDR_EXP 51
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// MortarDone := false ;
 302: LD_ADDR_EXP 52
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// TurretsDone := false ;
 310: LD_ADDR_EXP 49
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// GalleryBuild := false ;
 318: LD_ADDR_EXP 53
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// CompVehConstructed := false ;
 326: LD_ADDR_EXP 61
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// LimitTeleportResearched := false ;
 334: LD_ADDR_EXP 62
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// LimitTeleportTested := false ;
 342: LD_ADDR_EXP 63
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// AmAttackDone := false ;
 350: LD_ADDR_EXP 64
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// HeikeSend := false ;
 358: LD_ADDR_EXP 65
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// HeikeKilled := false ;
 366: LD_ADDR_EXP 38
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// Masha := 0 ;
 374: LD_ADDR_EXP 60
 378: PUSH
 379: LD_INT 0
 381: ST_TO_ADDR
// GalleryAsked := false ;
 382: LD_ADDR_EXP 66
 386: PUSH
 387: LD_INT 0
 389: ST_TO_ADDR
// HuntingAsked := false ;
 390: LD_ADDR_EXP 67
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// FreetimeAsked := false ;
 398: LD_ADDR_EXP 68
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// MashaAsked := false ;
 406: LD_ADDR_EXP 70
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// GenscherBetrayed := false ;
 414: LD_ADDR_EXP 36
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// AvailableWeapons := [ 42 , 43 , 44 , 45 , 46 ] ;
 422: LD_ADDR_EXP 54
 426: PUSH
 427: LD_INT 42
 429: PUSH
 430: LD_INT 43
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: LD_INT 45
 438: PUSH
 439: LD_INT 46
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// AvailableBuildings = [ ] ;
 449: LD_ADDR_EXP 55
 453: PUSH
 454: EMPTY
 455: ST_TO_ADDR
// for i := 0 to 50 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 0
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 50
 468: PUSH
 469: FOR_TO
 470: IFFALSE 510
// if GetRestrict ( i , you ) = 1 then
 472: LD_VAR 0 2
 476: PPUSH
 477: LD_EXP 31
 481: PPUSH
 482: CALL_OW 323
 486: PUSH
 487: LD_INT 1
 489: EQUAL
 490: IFFALSE 508
// AvailableBuildings := AvailableBuildings ^ i ;
 492: LD_ADDR_EXP 55
 496: PUSH
 497: LD_EXP 55
 501: PUSH
 502: LD_VAR 0 2
 506: ADD
 507: ST_TO_ADDR
 508: GO 469
 510: POP
 511: POP
// AvailableBuildings := AvailableBuildings diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
 512: LD_ADDR_EXP 55
 516: PUSH
 517: LD_EXP 55
 521: PUSH
 522: LD_INT 0
 524: PUSH
 525: LD_INT 2
 527: PUSH
 528: LD_INT 4
 530: PUSH
 531: LD_INT 6
 533: PUSH
 534: LD_INT 7
 536: PUSH
 537: LD_INT 8
 539: PUSH
 540: LD_INT 9
 542: PUSH
 543: LD_INT 10
 545: PUSH
 546: LD_INT 11
 548: PUSH
 549: LD_INT 12
 551: PUSH
 552: LD_INT 14
 554: PUSH
 555: LD_INT 22
 557: PUSH
 558: LD_INT 31
 560: PUSH
 561: LD_INT 32
 563: PUSH
 564: LD_INT 33
 566: PUSH
 567: LD_INT 39
 569: PUSH
 570: LD_INT 40
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: DIFF
 592: ST_TO_ADDR
// AvailableTechno = [ ] ;
 593: LD_ADDR_EXP 56
 597: PUSH
 598: EMPTY
 599: ST_TO_ADDR
// for i := 0 to 72 do
 600: LD_ADDR_VAR 0 2
 604: PUSH
 605: DOUBLE
 606: LD_INT 0
 608: DEC
 609: ST_TO_ADDR
 610: LD_INT 72
 612: PUSH
 613: FOR_TO
 614: IFFALSE 654
// if GetTech ( i , you ) = 1 then
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_EXP 31
 625: PPUSH
 626: CALL_OW 321
 630: PUSH
 631: LD_INT 1
 633: EQUAL
 634: IFFALSE 652
// AvailableTechno := AvailableTechno ^ i ;
 636: LD_ADDR_EXP 56
 640: PUSH
 641: LD_EXP 56
 645: PUSH
 646: LD_VAR 0 2
 650: ADD
 651: ST_TO_ADDR
 652: GO 613
 654: POP
 655: POP
// AvailableTechno := AvailableTechno diff 72 ;
 656: LD_ADDR_EXP 56
 660: PUSH
 661: LD_EXP 56
 665: PUSH
 666: LD_INT 72
 668: DIFF
 669: ST_TO_ADDR
// end ;
 670: LD_VAR 0 1
 674: RET
// function set_difficulty ; begin
 675: LD_INT 0
 677: PPUSH
// countdown := [ 2 2$0 , 1 1$30 , 1 1$0 ] [ difficulty ] ;
 678: LD_ADDR_EXP 77
 682: PUSH
 683: LD_INT 4200
 685: PUSH
 686: LD_INT 3150
 688: PUSH
 689: LD_INT 2100
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_OWVAR 67
 701: ARRAY
 702: ST_TO_ADDR
// pocetmercenaries := [ 20 , 40 , 60 ] [ difficulty ] ;
 703: LD_ADDR_EXP 78
 707: PUSH
 708: LD_INT 20
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 60
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: ST_TO_ADDR
// am_attack_skill := [ 4 , 6 , 8 ] [ difficulty ] ;
 728: LD_ADDR_EXP 74
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: LD_INT 6
 738: PUSH
 739: LD_INT 8
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_OWVAR 67
 751: ARRAY
 752: ST_TO_ADDR
// weaker := [ 10 , 15 , 20 ] [ difficulty ] ;
 753: LD_ADDR_EXP 75
 757: PUSH
 758: LD_INT 10
 760: PUSH
 761: LD_INT 15
 763: PUSH
 764: LD_INT 20
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_OWVAR 67
 776: ARRAY
 777: ST_TO_ADDR
// stronger := [ 20 , 25 , 30 ] [ difficulty ] ;
 778: LD_ADDR_EXP 76
 782: PUSH
 783: LD_INT 20
 785: PUSH
 786: LD_INT 25
 788: PUSH
 789: LD_INT 30
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: PUSH
 797: LD_OWVAR 67
 801: ARRAY
 802: ST_TO_ADDR
// speed := [ 60 60$0 , 45 45$0 , 38 38$0 ] [ difficulty ] ;
 803: LD_ADDR_EXP 73
 807: PUSH
 808: LD_INT 126000
 810: PUSH
 811: LD_INT 94500
 813: PUSH
 814: LD_INT 79800
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// snipers_positions := [ [ [ 115 , 77 ] , [ 127 , 67 ] , [ 15 , 2 ] , [ 71 , 1 ] ] , [ [ 120 , 70 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] , [ [ 115 , 77 ] , [ 127 , 67 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] ] [ difficulty ] ;
 828: LD_ADDR_EXP 79
 832: PUSH
 833: LD_INT 115
 835: PUSH
 836: LD_INT 77
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 127
 845: PUSH
 846: LD_INT 67
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 15
 855: PUSH
 856: LD_INT 2
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 71
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 120
 881: PUSH
 882: LD_INT 70
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 11
 891: PUSH
 892: LD_INT 20
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 50
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 71
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_INT 115
 938: PUSH
 939: LD_INT 77
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 127
 948: PUSH
 949: LD_INT 67
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 11
 958: PUSH
 959: LD_INT 20
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: PUSH
 966: LD_INT 15
 968: PUSH
 969: LD_INT 2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 50
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 71
 988: PUSH
 989: LD_INT 1
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: ST_TO_ADDR
// end ;
1015: LD_VAR 0 1
1019: RET
// function nacti_osobu ( ident ) ; begin
1020: LD_INT 0
1022: PPUSH
// if CheckCharacterSet ( ident ) then
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 29
1032: IFFALSE 1051
// result := CreateCharacter ( ident ) else
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: LD_VAR 0 1
1043: PPUSH
1044: CALL_OW 34
1048: ST_TO_ADDR
1049: GO 1059
// result := 0 ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// function create_people ; var def , i , x , y , un ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
1068: PPUSH
1069: PPUSH
1070: PPUSH
1071: PPUSH
// uc_side = you ;
1072: LD_ADDR_OWVAR 20
1076: PUSH
1077: LD_EXP 31
1081: ST_TO_ADDR
// uc_nation := nation_russian ;
1082: LD_ADDR_OWVAR 21
1086: PUSH
1087: LD_INT 3
1089: ST_TO_ADDR
// other := CreateCharacterSet ( survivors1 ) ;
1090: LD_ADDR_EXP 25
1094: PUSH
1095: LD_STRING survivors1
1097: PPUSH
1098: CALL_OW 31
1102: ST_TO_ADDR
// other := other union CreateCharacterSet ( survivors2 ) ;
1103: LD_ADDR_EXP 25
1107: PUSH
1108: LD_EXP 25
1112: PUSH
1113: LD_STRING survivors2
1115: PPUSH
1116: CALL_OW 31
1120: UNION
1121: ST_TO_ADDR
// other := other diff 0 ;
1122: LD_ADDR_EXP 25
1126: PUSH
1127: LD_EXP 25
1131: PUSH
1132: LD_INT 0
1134: DIFF
1135: ST_TO_ADDR
// if not testing then
1136: LD_EXP 95
1140: NOT
1141: IFFALSE 1158
// Burlak := nacti_osobu ( Burlak ) else
1143: LD_ADDR_EXP 1
1147: PUSH
1148: LD_STRING Burlak
1150: PPUSH
1151: CALL 1020 0 1
1155: ST_TO_ADDR
1156: GO 1186
// begin PrepareMechanic ( sex_male , 7 ) ;
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 383
// hc_name = Burlak ;
1168: LD_ADDR_OWVAR 26
1172: PUSH
1173: LD_STRING Burlak
1175: ST_TO_ADDR
// Burlak = CreateHuman ;
1176: LD_ADDR_EXP 1
1180: PUSH
1181: CALL_OW 44
1185: ST_TO_ADDR
// end ; Belkov := nacti_osobu ( Belkov ) ;
1186: LD_ADDR_EXP 3
1190: PUSH
1191: LD_STRING Belkov
1193: PPUSH
1194: CALL 1020 0 1
1198: ST_TO_ADDR
// Gnyevko := nacti_osobu ( Gnyevko ) ;
1199: LD_ADDR_EXP 5
1203: PUSH
1204: LD_STRING Gnyevko
1206: PPUSH
1207: CALL 1020 0 1
1211: ST_TO_ADDR
// Kirilenkova := nacti_osobu ( Kirilenkova ) ;
1212: LD_ADDR_EXP 4
1216: PUSH
1217: LD_STRING Kirilenkova
1219: PPUSH
1220: CALL 1020 0 1
1224: ST_TO_ADDR
// Kovalyuk := nacti_osobu ( Kovalyuk ) ;
1225: LD_ADDR_EXP 12
1229: PUSH
1230: LD_STRING Kovalyuk
1232: PPUSH
1233: CALL 1020 0 1
1237: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
1238: LD_ADDR_EXP 2
1242: PUSH
1243: LD_STRING Popov
1245: PPUSH
1246: CALL_OW 25
1250: ST_TO_ADDR
// Scholtze := nacti_osobu ( Scholtze ) ;
1251: LD_ADDR_EXP 15
1255: PUSH
1256: LD_STRING Scholtze
1258: PPUSH
1259: CALL 1020 0 1
1263: ST_TO_ADDR
// Kuzmov := nacti_osobu ( Kuzmov ) ;
1264: LD_ADDR_EXP 10
1268: PUSH
1269: LD_STRING Kuzmov
1271: PPUSH
1272: CALL 1020 0 1
1276: ST_TO_ADDR
// Karamazov := nacti_osobu ( Karamazov ) ;
1277: LD_ADDR_EXP 17
1281: PUSH
1282: LD_STRING Karamazov
1284: PPUSH
1285: CALL 1020 0 1
1289: ST_TO_ADDR
// Petrovova := nacti_osobu ( Petrovova ) ;
1290: LD_ADDR_EXP 21
1294: PUSH
1295: LD_STRING Petrovova
1297: PPUSH
1298: CALL 1020 0 1
1302: ST_TO_ADDR
// Gleb := nacti_osobu ( Gleb ) ;
1303: LD_ADDR_EXP 8
1307: PUSH
1308: LD_STRING Gleb
1310: PPUSH
1311: CALL 1020 0 1
1315: ST_TO_ADDR
// Petrosyan := nacti_osobu ( Petrosyan ) ;
1316: LD_ADDR_EXP 9
1320: PUSH
1321: LD_STRING Petrosyan
1323: PPUSH
1324: CALL 1020 0 1
1328: ST_TO_ADDR
// Lipshchin := nacti_osobu ( Lipshchin ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Lipshchin
1336: PPUSH
1337: CALL 1020 0 1
1341: ST_TO_ADDR
// Titov := nacti_osobu ( Titov ) ;
1342: LD_ADDR_EXP 18
1346: PUSH
1347: LD_STRING Titov
1349: PPUSH
1350: CALL 1020 0 1
1354: ST_TO_ADDR
// Dolgov := nacti_osobu ( Dolgov ) ;
1355: LD_ADDR_EXP 23
1359: PUSH
1360: LD_STRING Dolgov
1362: PPUSH
1363: CALL 1020 0 1
1367: ST_TO_ADDR
// Xavier := nacti_osobu ( Xavier ) ;
1368: LD_ADDR_EXP 24
1372: PUSH
1373: LD_STRING Xavier
1375: PPUSH
1376: CALL 1020 0 1
1380: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1381: LD_ADDR_EXP 19
1385: PUSH
1386: LD_STRING Oblukov
1388: PPUSH
1389: CALL_OW 25
1393: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
1394: LD_ADDR_EXP 20
1398: PUSH
1399: LD_STRING Kozlov
1401: PPUSH
1402: CALL_OW 25
1406: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1407: LD_ADDR_EXP 6
1411: PUSH
1412: LD_STRING Kapitsova
1414: PPUSH
1415: CALL_OW 25
1419: ST_TO_ADDR
// uc_side = ally ;
1420: LD_ADDR_OWVAR 20
1424: PUSH
1425: LD_EXP 32
1429: ST_TO_ADDR
// uc_nation := nation_arabian ;
1430: LD_ADDR_OWVAR 21
1434: PUSH
1435: LD_INT 2
1437: ST_TO_ADDR
// if not testing then
1438: LD_EXP 95
1442: NOT
1443: IFFALSE 1460
// Heike := nacti_osobu ( Heike ) else
1445: LD_ADDR_EXP 11
1449: PUSH
1450: LD_STRING Heike
1452: PPUSH
1453: CALL 1020 0 1
1457: ST_TO_ADDR
1458: GO 1488
// begin PrepareSoldier ( sex_female , 7 ) ;
1460: LD_INT 2
1462: PPUSH
1463: LD_INT 7
1465: PPUSH
1466: CALL_OW 381
// hc_name = Heike ;
1470: LD_ADDR_OWVAR 26
1474: PUSH
1475: LD_STRING Heike
1477: ST_TO_ADDR
// Heike = CreateHuman ;
1478: LD_ADDR_EXP 11
1482: PUSH
1483: CALL_OW 44
1487: ST_TO_ADDR
// end ; SetClass ( Heike , class_engineer ) ;
1488: LD_EXP 11
1492: PPUSH
1493: LD_INT 2
1495: PPUSH
1496: CALL_OW 336
// uc_side = arab ;
1500: LD_ADDR_OWVAR 20
1504: PUSH
1505: LD_EXP 33
1509: ST_TO_ADDR
// uc_nation := nation_arabian ;
1510: LD_ADDR_OWVAR 21
1514: PUSH
1515: LD_INT 2
1517: ST_TO_ADDR
// Dietrich := NewCharacter ( Dietrich ) ;
1518: LD_ADDR_EXP 7
1522: PUSH
1523: LD_STRING Dietrich
1525: PPUSH
1526: CALL_OW 25
1530: ST_TO_ADDR
// uc_side = merc ;
1531: LD_ADDR_OWVAR 20
1535: PUSH
1536: LD_EXP 34
1540: ST_TO_ADDR
// uc_nation := nation_arabian ;
1541: LD_ADDR_OWVAR 21
1545: PUSH
1546: LD_INT 2
1548: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
1549: LD_ADDR_EXP 13
1553: PUSH
1554: LD_STRING Kurt
1556: PPUSH
1557: CALL_OW 25
1561: ST_TO_ADDR
// PrepareHuman ( sex_male , class_engineer , 2 ) ;
1562: LD_INT 1
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: CALL_OW 380
// hc_name :=  ;
1575: LD_ADDR_OWVAR 26
1579: PUSH
1580: LD_STRING 
1582: ST_TO_ADDR
// Mercenary1 := CreateHuman ;
1583: LD_ADDR_EXP 14
1587: PUSH
1588: CALL_OW 44
1592: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 1 ) ;
1593: LD_INT 1
1595: PPUSH
1596: LD_INT 1
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 380
// hc_name :=  ;
1606: LD_ADDR_OWVAR 26
1610: PUSH
1611: LD_STRING 
1613: ST_TO_ADDR
// ASoldier1 := CreateHuman ;
1614: LD_ADDR_EXP 16
1618: PUSH
1619: CALL_OW 44
1623: ST_TO_ADDR
// player_units := ( [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) diff [ 0 ] ;
1624: LD_ADDR_EXP 26
1628: PUSH
1629: LD_EXP 1
1633: PUSH
1634: LD_EXP 3
1638: PUSH
1639: LD_EXP 4
1643: PUSH
1644: LD_EXP 5
1648: PUSH
1649: LD_EXP 6
1653: PUSH
1654: LD_EXP 8
1658: PUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_EXP 12
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 17
1678: PUSH
1679: LD_EXP 18
1683: PUSH
1684: LD_EXP 19
1688: PUSH
1689: LD_EXP 20
1693: PUSH
1694: LD_EXP 21
1698: PUSH
1699: LD_EXP 22
1703: PUSH
1704: LD_EXP 9
1708: PUSH
1709: LD_EXP 23
1713: PUSH
1714: LD_EXP 24
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_INT 0
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: ST_TO_ADDR
// for i = 1 to 2 do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: DOUBLE
1752: LD_INT 1
1754: DEC
1755: ST_TO_ADDR
1756: LD_INT 2
1758: PUSH
1759: FOR_TO
1760: IFFALSE 1814
// if other >= i and other [ i ] > 0 then
1762: LD_EXP 25
1766: PUSH
1767: LD_VAR 0 3
1771: GREATEREQUAL
1772: PUSH
1773: LD_EXP 25
1777: PUSH
1778: LD_VAR 0 3
1782: ARRAY
1783: PUSH
1784: LD_INT 0
1786: GREATER
1787: AND
1788: IFFALSE 1812
// player_units = player_units ^ other [ i ] ;
1790: LD_ADDR_EXP 26
1794: PUSH
1795: LD_EXP 26
1799: PUSH
1800: LD_EXP 25
1804: PUSH
1805: LD_VAR 0 3
1809: ARRAY
1810: ADD
1811: ST_TO_ADDR
1812: GO 1759
1814: POP
1815: POP
// uc_side = you ;
1816: LD_ADDR_OWVAR 20
1820: PUSH
1821: LD_EXP 31
1825: ST_TO_ADDR
// uc_nation := nation_russian ;
1826: LD_ADDR_OWVAR 21
1830: PUSH
1831: LD_INT 3
1833: ST_TO_ADDR
// if 0 + player_units < 15 then
1834: LD_INT 0
1836: PUSH
1837: LD_EXP 26
1841: PLUS
1842: PUSH
1843: LD_INT 15
1845: LESS
1846: IFFALSE 1910
// for i := 1 to 0 + other do
1848: LD_ADDR_VAR 0 3
1852: PUSH
1853: DOUBLE
1854: LD_INT 1
1856: DEC
1857: ST_TO_ADDR
1858: LD_INT 0
1860: PUSH
1861: LD_EXP 25
1865: PLUS
1866: PUSH
1867: FOR_TO
1868: IFFALSE 1908
// if 0 + player_units < 15 then
1870: LD_INT 0
1872: PUSH
1873: LD_EXP 26
1877: PLUS
1878: PUSH
1879: LD_INT 15
1881: LESS
1882: IFFALSE 1906
// player_units := player_units ^ other [ i ] ;
1884: LD_ADDR_EXP 26
1888: PUSH
1889: LD_EXP 26
1893: PUSH
1894: LD_EXP 25
1898: PUSH
1899: LD_VAR 0 3
1903: ARRAY
1904: ADD
1905: ST_TO_ADDR
1906: GO 1867
1908: POP
1909: POP
// if 0 + player_units < 15 then
1910: LD_INT 0
1912: PUSH
1913: LD_EXP 26
1917: PLUS
1918: PUSH
1919: LD_INT 15
1921: LESS
1922: IFFALSE 1987
// for i := 1 to 15 - player_units do
1924: LD_ADDR_VAR 0 3
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_INT 15
1936: PUSH
1937: LD_EXP 26
1941: MINUS
1942: PUSH
1943: FOR_TO
1944: IFFALSE 1985
// begin PrepareHuman ( 0 , 0 , 4 ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 0
1951: PPUSH
1952: LD_INT 4
1954: PPUSH
1955: CALL_OW 380
// hc_name :=  ;
1959: LD_ADDR_OWVAR 26
1963: PUSH
1964: LD_STRING 
1966: ST_TO_ADDR
// player_units := player_units ^ CreateHuman ;
1967: LD_ADDR_EXP 26
1971: PUSH
1972: LD_EXP 26
1976: PUSH
1977: CALL_OW 44
1981: ADD
1982: ST_TO_ADDR
// end ;
1983: GO 1943
1985: POP
1986: POP
// Randomize ;
1987: CALL_OW 10
// RandomizeAll ;
1991: CALL_OW 11
// for un in player_units do
1995: LD_ADDR_VAR 0 6
1999: PUSH
2000: LD_EXP 26
2004: PUSH
2005: FOR_IN
2006: IFFALSE 2025
// PlaceUnitArea ( un , EnterArea , false ) ;
2008: LD_VAR 0 6
2012: PPUSH
2013: LD_INT 3
2015: PPUSH
2016: LD_INT 0
2018: PPUSH
2019: CALL_OW 49
2023: GO 2005
2025: POP
2026: POP
// end ;
2027: LD_VAR 0 1
2031: RET
// function create_vehicles ; var i , auto ; begin
2032: LD_INT 0
2034: PPUSH
2035: PPUSH
2036: PPUSH
// for i := 1 to 5 do
2037: LD_ADDR_VAR 0 2
2041: PUSH
2042: DOUBLE
2043: LD_INT 1
2045: DEC
2046: ST_TO_ADDR
2047: LD_INT 5
2049: PUSH
2050: FOR_TO
2051: IFFALSE 2208
// begin uc_side := you ;
2053: LD_ADDR_OWVAR 20
2057: PUSH
2058: LD_EXP 31
2062: ST_TO_ADDR
// uc_nation := nation_russian ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 3
2070: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2071: LD_ADDR_OWVAR 24
2075: PUSH
2076: LD_INT 0
2078: PPUSH
2079: LD_INT 5
2081: PPUSH
2082: CALL_OW 12
2086: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2087: LD_ADDR_OWVAR 37
2091: PUSH
2092: LD_INT 21
2094: ST_TO_ADDR
// vc_engine := engine_combustion ;
2095: LD_ADDR_OWVAR 39
2099: PUSH
2100: LD_INT 1
2102: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2103: LD_ADDR_OWVAR 40
2107: PUSH
2108: LD_INT 51
2110: ST_TO_ADDR
// vc_control := control_manual ;
2111: LD_ADDR_OWVAR 38
2115: PUSH
2116: LD_INT 1
2118: ST_TO_ADDR
// auto := CreateVehicle ;
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: CALL_OW 45
2128: ST_TO_ADDR
// if i <= 4 then
2129: LD_VAR 0 2
2133: PUSH
2134: LD_INT 4
2136: LESSEQUAL
2137: IFFALSE 2156
// SetCargo ( auto , mat_cans , 100 ) else
2139: LD_VAR 0 3
2143: PPUSH
2144: LD_INT 1
2146: PPUSH
2147: LD_INT 100
2149: PPUSH
2150: CALL_OW 290
2154: GO 2171
// SetCargo ( auto , mat_oil , 100 ) ;
2156: LD_VAR 0 3
2160: PPUSH
2161: LD_INT 2
2163: PPUSH
2164: LD_INT 100
2166: PPUSH
2167: CALL_OW 290
// SetFuel ( auto , Rand ( 40 , 80 ) ) ;
2171: LD_VAR 0 3
2175: PPUSH
2176: LD_INT 40
2178: PPUSH
2179: LD_INT 80
2181: PPUSH
2182: CALL_OW 12
2186: PPUSH
2187: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2191: LD_VAR 0 3
2195: PPUSH
2196: LD_INT 3
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 49
// end ;
2206: GO 2050
2208: POP
2209: POP
// uc_side := you ;
2210: LD_ADDR_OWVAR 20
2214: PUSH
2215: LD_EXP 31
2219: ST_TO_ADDR
// uc_nation := nation_russian ;
2220: LD_ADDR_OWVAR 21
2224: PUSH
2225: LD_INT 3
2227: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2228: LD_ADDR_OWVAR 24
2232: PUSH
2233: LD_INT 0
2235: PPUSH
2236: LD_INT 5
2238: PPUSH
2239: CALL_OW 12
2243: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 22
2251: ST_TO_ADDR
// vc_engine := engine_combustion ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 1
2259: ST_TO_ADDR
// vc_weapon := ru_crane ;
2260: LD_ADDR_OWVAR 40
2264: PUSH
2265: LD_INT 52
2267: ST_TO_ADDR
// vc_control := control_manual ;
2268: LD_ADDR_OWVAR 38
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// auto := CreateVehicle ;
2276: LD_ADDR_VAR 0 3
2280: PUSH
2281: CALL_OW 45
2285: ST_TO_ADDR
// SetFuel ( auto , Rand ( 90 , 100 ) ) ;
2286: LD_VAR 0 3
2290: PPUSH
2291: LD_INT 90
2293: PPUSH
2294: LD_INT 100
2296: PPUSH
2297: CALL_OW 12
2301: PPUSH
2302: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2306: LD_VAR 0 3
2310: PPUSH
2311: LD_INT 3
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 49
// for i := 1 to 3 do
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 3
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2450
// begin uc_side := you ;
2337: LD_ADDR_OWVAR 20
2341: PUSH
2342: LD_EXP 31
2346: ST_TO_ADDR
// uc_nation := nation_russian ;
2347: LD_ADDR_OWVAR 21
2351: PUSH
2352: LD_INT 3
2354: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2355: LD_ADDR_OWVAR 24
2359: PUSH
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 5
2365: PPUSH
2366: CALL_OW 12
2370: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2371: LD_ADDR_OWVAR 37
2375: PUSH
2376: LD_INT 24
2378: ST_TO_ADDR
// vc_engine := engine_combustion ;
2379: LD_ADDR_OWVAR 39
2383: PUSH
2384: LD_INT 1
2386: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2387: LD_ADDR_OWVAR 40
2391: PUSH
2392: LD_INT 53
2394: ST_TO_ADDR
// vc_control := control_manual ;
2395: LD_ADDR_OWVAR 38
2399: PUSH
2400: LD_INT 1
2402: ST_TO_ADDR
// auto := CreateVehicle ;
2403: LD_ADDR_VAR 0 3
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetFuel ( auto , Rand ( 80 , 100 ) ) ;
2413: LD_VAR 0 3
2417: PPUSH
2418: LD_INT 80
2420: PPUSH
2421: LD_INT 100
2423: PPUSH
2424: CALL_OW 12
2428: PPUSH
2429: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2433: LD_VAR 0 3
2437: PPUSH
2438: LD_INT 3
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL_OW 49
// end ;
2448: GO 2334
2450: POP
2451: POP
// end ;
2452: LD_VAR 0 1
2456: RET
// export function create_snipers ; var xy ; begin
2457: LD_INT 0
2459: PPUSH
2460: PPUSH
// for xy in snipers_positions do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_EXP 79
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2616
// begin uc_side = usa ;
2474: LD_ADDR_OWVAR 20
2478: PUSH
2479: LD_EXP 35
2483: ST_TO_ADDR
// uc_nation := nation_american ;
2484: LD_ADDR_OWVAR 21
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
2492: LD_ADDR_OWVAR 30
2496: PUSH
2497: LD_INT 0
2499: PUSH
2500: LD_INT 0
2502: PUSH
2503: LD_INT 0
2505: PUSH
2506: LD_INT 0
2508: PUSH
2509: EMPTY
2510: LIST
2511: LIST
2512: LIST
2513: LIST
2514: ST_TO_ADDR
// hc_skills := [ difficulty - 1 , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2515: LD_ADDR_OWVAR 31
2519: PUSH
2520: LD_OWVAR 67
2524: PUSH
2525: LD_INT 1
2527: MINUS
2528: PUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: PUSH
2540: LD_INT 0
2542: PPUSH
2543: LD_INT 2
2545: PPUSH
2546: CALL_OW 12
2550: PUSH
2551: LD_INT 0
2553: PPUSH
2554: LD_INT 2
2556: PPUSH
2557: CALL_OW 12
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: LIST
2566: LIST
2567: ST_TO_ADDR
// hc_class := class_sniper ;
2568: LD_ADDR_OWVAR 28
2572: PUSH
2573: LD_INT 5
2575: ST_TO_ADDR
// hc_name :=  ;
2576: LD_ADDR_OWVAR 26
2580: PUSH
2581: LD_STRING 
2583: ST_TO_ADDR
// PlaceUnitXY ( CreateHuman , xy [ 1 ] , xy [ 2 ] , false ) ;
2584: CALL_OW 44
2588: PPUSH
2589: LD_VAR 0 2
2593: PUSH
2594: LD_INT 1
2596: ARRAY
2597: PPUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_INT 2
2605: ARRAY
2606: PPUSH
2607: LD_INT 0
2609: PPUSH
2610: CALL_OW 48
// end ;
2614: GO 2471
2616: POP
2617: POP
// end ;
2618: LD_VAR 0 1
2622: RET
// export function create_heike ; var auto , filter , x , y , d , Guard1 , Guard2 ; begin
2623: LD_INT 0
2625: PPUSH
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := ally ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_EXP 32
2642: ST_TO_ADDR
// uc_nation := nation_russian ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_INT 3
2650: ST_TO_ADDR
// uc_direction := Rand ( 3 , 5 ) ;
2651: LD_ADDR_OWVAR 24
2655: PUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 5
2661: PPUSH
2662: CALL_OW 12
2666: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2667: LD_INT 0
2669: PPUSH
2670: LD_INT 1
2672: PPUSH
2673: LD_INT 6
2675: PPUSH
2676: CALL_OW 380
// hc_name :=  ;
2680: LD_ADDR_OWVAR 26
2684: PUSH
2685: LD_STRING 
2687: ST_TO_ADDR
// Guard1 := CreateHuman ;
2688: LD_ADDR_VAR 0 7
2692: PUSH
2693: CALL_OW 44
2697: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2698: LD_INT 0
2700: PPUSH
2701: LD_INT 1
2703: PPUSH
2704: LD_INT 6
2706: PPUSH
2707: CALL_OW 380
// hc_name :=  ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING 
2718: ST_TO_ADDR
// Guard2 := CreateHuman ;
2719: LD_ADDR_VAR 0 8
2723: PUSH
2724: CALL_OW 44
2728: ST_TO_ADDR
// PlaceUnitArea ( Guard1 , EnterArea , false ) ;
2729: LD_VAR 0 7
2733: PPUSH
2734: LD_INT 3
2736: PPUSH
2737: LD_INT 0
2739: PPUSH
2740: CALL_OW 49
// PlaceUnitArea ( Guard2 , EnterArea , false ) ;
2744: LD_VAR 0 8
2748: PPUSH
2749: LD_INT 3
2751: PPUSH
2752: LD_INT 0
2754: PPUSH
2755: CALL_OW 49
// PlaceUnitArea ( Heike , EnterArea , false ) ;
2759: LD_EXP 11
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: LD_INT 0
2769: PPUSH
2770: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
2774: LD_ADDR_VAR 0 3
2778: PUSH
2779: LD_INT 22
2781: PUSH
2782: LD_EXP 31
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: LD_INT 30
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 1
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PUSH
2819: EMPTY
2820: LIST
2821: PUSH
2822: EMPTY
2823: LIST
2824: LIST
2825: PPUSH
2826: CALL_OW 69
2830: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
2831: LD_INT 0
2833: PUSH
2834: LD_VAR 0 3
2838: PLUS
2839: PUSH
2840: LD_INT 0
2842: NONEQUAL
2843: IFFALSE 2904
// begin x := GetX ( filter [ 1 ] ) ;
2845: LD_ADDR_VAR 0 4
2849: PUSH
2850: LD_VAR 0 3
2854: PUSH
2855: LD_INT 1
2857: ARRAY
2858: PPUSH
2859: CALL_OW 250
2863: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
2864: LD_ADDR_VAR 0 5
2868: PUSH
2869: LD_VAR 0 3
2873: PUSH
2874: LD_INT 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 251
2882: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
2883: LD_ADDR_VAR 0 6
2887: PUSH
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 1
2895: ARRAY
2896: PPUSH
2897: CALL_OW 254
2901: ST_TO_ADDR
// end else
2902: GO 2942
// begin x := GetX ( Burlak ) ;
2904: LD_ADDR_VAR 0 4
2908: PUSH
2909: LD_EXP 1
2913: PPUSH
2914: CALL_OW 250
2918: ST_TO_ADDR
// y := GetY ( Burlak ) ;
2919: LD_ADDR_VAR 0 5
2923: PUSH
2924: LD_EXP 1
2928: PPUSH
2929: CALL_OW 251
2933: ST_TO_ADDR
// d := 1 ;
2934: LD_ADDR_VAR 0 6
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// end ; repeat ComMoveXY ( Guard1 , x , y ) ;
2942: LD_VAR 0 7
2946: PPUSH
2947: LD_VAR 0 4
2951: PPUSH
2952: LD_VAR 0 5
2956: PPUSH
2957: CALL_OW 111
// ComMoveUnit ( Heike , Guard1 ) ;
2961: LD_EXP 11
2965: PPUSH
2966: LD_VAR 0 7
2970: PPUSH
2971: CALL_OW 112
// ComMoveUnit ( Guard2 , Heike ) ;
2975: LD_VAR 0 8
2979: PPUSH
2980: LD_EXP 11
2984: PPUSH
2985: CALL_OW 112
// Wait ( 0 0$1 ) ;
2989: LD_INT 35
2991: PPUSH
2992: CALL_OW 67
// until ( GetDistUnitXY ( Guard1 , x , y ) < 10 ) and ( GetDistUnitXY ( Guard2 , x , y ) < 10 ) ;
2996: LD_VAR 0 7
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_VAR 0 5
3010: PPUSH
3011: CALL_OW 297
3015: PUSH
3016: LD_INT 10
3018: LESS
3019: PUSH
3020: LD_VAR 0 8
3024: PPUSH
3025: LD_VAR 0 4
3029: PPUSH
3030: LD_VAR 0 5
3034: PPUSH
3035: CALL_OW 297
3039: PUSH
3040: LD_INT 10
3042: LESS
3043: AND
3044: IFFALSE 2942
// ComStop ( [ Guard1 , Guard2 , Heike ] ) ;
3046: LD_VAR 0 7
3050: PUSH
3051: LD_VAR 0 8
3055: PUSH
3056: LD_EXP 11
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 141
// Wait ( 10 ) ;
3070: LD_INT 10
3072: PPUSH
3073: CALL_OW 67
// ComMoveXY ( [ Guard1 , Guard2 ] , 113 , 29 ) ;
3077: LD_VAR 0 7
3081: PUSH
3082: LD_VAR 0 8
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PPUSH
3091: LD_INT 113
3093: PPUSH
3094: LD_INT 29
3096: PPUSH
3097: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
3101: LD_INT 35
3103: PPUSH
3104: CALL_OW 67
// until not HasTask ( Guard1 ) and not HasTask ( Guard2 ) ;
3108: LD_VAR 0 7
3112: PPUSH
3113: CALL_OW 314
3117: NOT
3118: PUSH
3119: LD_VAR 0 8
3123: PPUSH
3124: CALL_OW 314
3128: NOT
3129: AND
3130: IFFALSE 3101
// DestroyUnit ( Guard1 ) ;
3132: LD_VAR 0 7
3136: PPUSH
3137: CALL_OW 65
// DestroyUnit ( Guard2 ) ;
3141: LD_VAR 0 8
3145: PPUSH
3146: CALL_OW 65
// end ;
3150: LD_VAR 0 1
3154: RET
// export function create_kurt ; begin
3155: LD_INT 0
3157: PPUSH
// PlaceUnitArea ( Mercenary1 , MercEnterArea , false ) ;
3158: LD_EXP 14
3162: PPUSH
3163: LD_INT 4
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 49
// PlaceUnitArea ( Kurt , MercEnterArea , false ) ;
3173: LD_EXP 13
3177: PPUSH
3178: LD_INT 4
3180: PPUSH
3181: LD_INT 0
3183: PPUSH
3184: CALL_OW 49
// enable ( 2 ) ;
3188: LD_INT 2
3190: ENABLE_MARKED
// end ;
3191: LD_VAR 0 1
3195: RET
// starting begin FogOff ( false ) ;
3196: LD_INT 0
3198: PPUSH
3199: CALL_OW 344
// Randomize ;
3203: CALL_OW 10
// RandomizeAll ;
3207: CALL_OW 11
// testing = false ;
3211: LD_ADDR_EXP 95
3215: PUSH
3216: LD_INT 0
3218: ST_TO_ADDR
// InitBc ;
3219: CALL_OW 21
// InitHc ;
3223: CALL_OW 19
// InitUc ;
3227: CALL_OW 18
// InitVc ;
3231: CALL_OW 20
// disable ( 1 ) ;
3235: LD_INT 1
3237: DISABLE_MARKED
// disable ( 2 ) ;
3238: LD_INT 2
3240: DISABLE_MARKED
// disable ( 3 ) ;
3241: LD_INT 3
3243: DISABLE_MARKED
// disable ( 4 ) ;
3244: LD_INT 4
3246: DISABLE_MARKED
// disable ( 5 ) ;
3247: LD_INT 5
3249: DISABLE_MARKED
// disable ( 6 ) ;
3250: LD_INT 6
3252: DISABLE_MARKED
// disable ( 7 ) ;
3253: LD_INT 7
3255: DISABLE_MARKED
// disable ( 8 ) ;
3256: LD_INT 8
3258: DISABLE_MARKED
// disable ( 9 ) ;
3259: LD_INT 9
3261: DISABLE_MARKED
// disable ( 10 ) ;
3262: LD_INT 10
3264: DISABLE_MARKED
// disable ( 11 ) ;
3265: LD_INT 11
3267: DISABLE_MARKED
// disable ( 13 ) ;
3268: LD_INT 13
3270: DISABLE_MARKED
// disable ( 20 ) ;
3271: LD_INT 20
3273: DISABLE_MARKED
// disable ( 23 ) ;
3274: LD_INT 23
3276: DISABLE_MARKED
// disable ( 24 ) ;
3277: LD_INT 24
3279: DISABLE_MARKED
// disable ( 50 ) ;
3280: LD_INT 50
3282: DISABLE_MARKED
// disable ( 101 ) ;
3283: LD_INT 101
3285: DISABLE_MARKED
// disable ( 102 ) ;
3286: LD_INT 102
3288: DISABLE_MARKED
// disable ( 201 ) ;
3289: LD_INT 201
3291: DISABLE_MARKED
// disable ( 202 ) ;
3292: LD_INT 202
3294: DISABLE_MARKED
// disable ( 203 ) ;
3295: LD_INT 203
3297: DISABLE_MARKED
// disable ( 301 ) ;
3298: LD_INT 301
3300: DISABLE_MARKED
// disable ( 401 ) ;
3301: LD_INT 401
3303: DISABLE_MARKED
// disable ( 402 ) ;
3304: LD_INT 402
3306: DISABLE_MARKED
// disable ( 501 ) ;
3307: LD_INT 501
3309: DISABLE_MARKED
// disable ( 502 ) ;
3310: LD_INT 502
3312: DISABLE_MARKED
// disable ( 601 ) ;
3313: LD_INT 601
3315: DISABLE_MARKED
// disable ( 999 ) ;
3316: LD_INT 999
3318: DISABLE_MARKED
// PlaceTreesToArea ( TreeArea1 , [ 2 , 10 , 11 , 27 , 35 ] , 20 , 10 , 4 ) ;
3319: LD_INT 24
3321: PPUSH
3322: LD_INT 2
3324: PUSH
3325: LD_INT 10
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: LD_INT 35
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: LD_INT 20
3346: PPUSH
3347: LD_INT 10
3349: PPUSH
3350: LD_INT 4
3352: PPUSH
3353: CALL_OW 352
// PlaceTreesToArea ( TreeArea2 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3357: LD_INT 25
3359: PPUSH
3360: LD_INT 9
3362: PUSH
3363: LD_INT 10
3365: PUSH
3366: LD_INT 27
3368: PUSH
3369: LD_INT 35
3371: PUSH
3372: LD_INT 48
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: PPUSH
3382: LD_INT 20
3384: PPUSH
3385: LD_INT 10
3387: PPUSH
3388: LD_INT 4
3390: PPUSH
3391: CALL_OW 352
// PlaceTreesToArea ( TreeArea3 , [ 2 , 9 , 10 , 11 , 27 ] , 20 , 10 , 4 ) ;
3395: LD_INT 26
3397: PPUSH
3398: LD_INT 2
3400: PUSH
3401: LD_INT 9
3403: PUSH
3404: LD_INT 10
3406: PUSH
3407: LD_INT 11
3409: PUSH
3410: LD_INT 27
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PPUSH
3420: LD_INT 20
3422: PPUSH
3423: LD_INT 10
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL_OW 352
// PlaceTreesToArea ( TreeArea4 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3433: LD_INT 27
3435: PPUSH
3436: LD_INT 9
3438: PUSH
3439: LD_INT 10
3441: PUSH
3442: LD_INT 27
3444: PUSH
3445: LD_INT 35
3447: PUSH
3448: LD_INT 48
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PPUSH
3458: LD_INT 20
3460: PPUSH
3461: LD_INT 10
3463: PPUSH
3464: LD_INT 4
3466: PPUSH
3467: CALL_OW 352
// PlaceTreesToArea ( TreeArea5 , [ 2 , 9 , 10 , 11 , 48 ] , 20 , 10 , 4 ) ;
3471: LD_INT 28
3473: PPUSH
3474: LD_INT 2
3476: PUSH
3477: LD_INT 9
3479: PUSH
3480: LD_INT 10
3482: PUSH
3483: LD_INT 11
3485: PUSH
3486: LD_INT 48
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: PPUSH
3496: LD_INT 20
3498: PPUSH
3499: LD_INT 10
3501: PPUSH
3502: LD_INT 4
3504: PPUSH
3505: CALL_OW 352
// PlaceTreesToArea ( TreeArea6 , [ 2 , 11 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3509: LD_INT 29
3511: PPUSH
3512: LD_INT 2
3514: PUSH
3515: LD_INT 11
3517: PUSH
3518: LD_INT 27
3520: PUSH
3521: LD_INT 35
3523: PUSH
3524: LD_INT 48
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: PPUSH
3534: LD_INT 20
3536: PPUSH
3537: LD_INT 10
3539: PPUSH
3540: LD_INT 4
3542: PPUSH
3543: CALL_OW 352
// read_parameters ;
3547: CALL 0 0 0
// set_difficulty ;
3551: CALL 675 0 0
// create_people ;
3555: CALL 1064 0 0
// create_vehicles ;
3559: CALL 2032 0 0
// create_snipers ;
3563: CALL 2457 0 0
// prepare_am_attack ;
3567: CALL 18549 0 0
// CenterNowOnXY ( 112 , 32 ) ;
3571: LD_INT 112
3573: PPUSH
3574: LD_INT 32
3576: PPUSH
3577: CALL_OW 86
// D_Start ;
3581: CALL 4894 0 0
// SaveForQuickRestart ;
3585: CALL_OW 22
// end ;
3589: END
// every 0 0$10 marked 999 do var filter , prumer , un , un1 , un2 , distance , pole , budova1 , budova2 , i , trotskij , medal1 , medal2 , medal3 ;
3590: GO 3592
3592: DISABLE
3593: LD_INT 0
3595: PPUSH
3596: PPUSH
3597: PPUSH
3598: PPUSH
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
3604: PPUSH
3605: PPUSH
3606: PPUSH
3607: PPUSH
3608: PPUSH
// begin if BuildingsDone and WeaponsDone and TechnoDone and CompVehConstructed and LimitTeleportTested and Masha and AmAttackDone then
3609: LD_EXP 48
3613: PUSH
3614: LD_EXP 50
3618: AND
3619: PUSH
3620: LD_EXP 51
3624: AND
3625: PUSH
3626: LD_EXP 61
3630: AND
3631: PUSH
3632: LD_EXP 63
3636: AND
3637: PUSH
3638: LD_EXP 60
3642: AND
3643: PUSH
3644: LD_EXP 64
3648: AND
3649: IFFALSE 4890
// begin medal1 := false ;
3651: LD_ADDR_VAR 0 12
3655: PUSH
3656: LD_INT 0
3658: ST_TO_ADDR
// medal2 := false ;
3659: LD_ADDR_VAR 0 13
3663: PUSH
3664: LD_INT 0
3666: ST_TO_ADDR
// medal3 := false ;
3667: LD_ADDR_VAR 0 14
3671: PUSH
3672: LD_INT 0
3674: ST_TO_ADDR
// disable ;
3675: DISABLE
// gained_medals := [ ] ;
3676: LD_ADDR_OWVAR 61
3680: PUSH
3681: EMPTY
3682: ST_TO_ADDR
// missing_medals := [ ] ;
3683: LD_ADDR_OWVAR 62
3687: PUSH
3688: EMPTY
3689: ST_TO_ADDR
// if HeikeCaptured then
3690: LD_EXP 37
3694: IFFALSE 3735
// if MortarDone then
3696: LD_EXP 52
3700: IFFALSE 3722
// begin medal1 := true ;
3702: LD_ADDR_VAR 0 12
3706: PUSH
3707: LD_INT 1
3709: ST_TO_ADDR
// AddMedal ( ArabBarracks , 1 ) ;
3710: LD_STRING ArabBarracks
3712: PPUSH
3713: LD_INT 1
3715: PPUSH
3716: CALL_OW 101
// end else
3720: GO 3733
// AddMedal ( ArabBarracks , - 1 ) else
3722: LD_STRING ArabBarracks
3724: PPUSH
3725: LD_INT 1
3727: NEG
3728: PPUSH
3729: CALL_OW 101
3733: GO 3778
// if tick < speed then
3735: LD_OWVAR 1
3739: PUSH
3740: LD_EXP 73
3744: LESS
3745: IFFALSE 3767
// begin medal2 := true ;
3747: LD_ADDR_VAR 0 13
3751: PUSH
3752: LD_INT 1
3754: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
3755: LD_STRING Speed
3757: PPUSH
3758: LD_INT 1
3760: PPUSH
3761: CALL_OW 101
// end else
3765: GO 3778
// AddMedal ( Speed , - 1 ) ;
3767: LD_STRING Speed
3769: PPUSH
3770: LD_INT 1
3772: NEG
3773: PPUSH
3774: CALL_OW 101
// AddMedal ( ArtisticImpression , 1 ) ;
3778: LD_STRING ArtisticImpression
3780: PPUSH
3781: LD_INT 1
3783: PPUSH
3784: CALL_OW 101
// medal3 := true ;
3788: LD_ADDR_VAR 0 14
3792: PUSH
3793: LD_INT 1
3795: ST_TO_ADDR
// SA_EndMission ( 3 , 8 , medal1 , medal2 , medal3 ) ;
3796: LD_INT 3
3798: PPUSH
3799: LD_INT 8
3801: PPUSH
3802: LD_VAR 0 12
3806: PPUSH
3807: LD_VAR 0 13
3811: PPUSH
3812: LD_VAR 0 14
3816: PPUSH
3817: CALL 19148 0 5
// if ( 0 + player_units ) <= 11 then
3821: LD_INT 0
3823: PUSH
3824: LD_EXP 26
3828: PLUS
3829: PUSH
3830: LD_INT 11
3832: LESSEQUAL
3833: IFFALSE 3848
// AddMedal ( FavouriteCommander , - 1 ) else
3835: LD_STRING FavouriteCommander
3837: PPUSH
3838: LD_INT 1
3840: NEG
3841: PPUSH
3842: CALL_OW 101
3846: GO 3920
// if FreeTimeGranted and HuntingAccepted and GalleryBuild then
3848: LD_EXP 59
3852: PUSH
3853: LD_EXP 47
3857: AND
3858: PUSH
3859: LD_EXP 53
3863: AND
3864: IFFALSE 3878
// AddMedal ( FavouriteCommander , 1 ) else
3866: LD_STRING FavouriteCommander
3868: PPUSH
3869: LD_INT 1
3871: PPUSH
3872: CALL_OW 101
3876: GO 3920
// if FreeTimeGranted or HuntingAccepted or GalleryBuild then
3878: LD_EXP 59
3882: PUSH
3883: LD_EXP 47
3887: OR
3888: PUSH
3889: LD_EXP 53
3893: OR
3894: IFFALSE 3909
// AddMedal ( FavouriteCommander , - 3 ) else
3896: LD_STRING FavouriteCommander
3898: PPUSH
3899: LD_INT 3
3901: NEG
3902: PPUSH
3903: CALL_OW 101
3907: GO 3920
// AddMedal ( FavouriteCommander , - 2 ) ;
3909: LD_STRING FavouriteCommander
3911: PPUSH
3912: LD_INT 2
3914: NEG
3915: PPUSH
3916: CALL_OW 101
// if MortarDone and not HeikeDismissed then
3920: LD_EXP 52
3924: PUSH
3925: LD_EXP 45
3929: NOT
3930: AND
3931: IFFALSE 3937
// SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ;
3933: CALL 19133 0 0
// GiveMedals ( Main ) ;
3937: LD_STRING Main
3939: PPUSH
3940: CALL_OW 102
// for un1 in player_units do
3944: LD_ADDR_VAR 0 4
3948: PUSH
3949: LD_EXP 26
3953: PUSH
3954: FOR_IN
3955: IFFALSE 3986
// if IsDead ( un1 ) then
3957: LD_VAR 0 4
3961: PPUSH
3962: CALL_OW 301
3966: IFFALSE 3984
// player_units := player_units diff un1 ;
3968: LD_ADDR_EXP 26
3972: PUSH
3973: LD_EXP 26
3977: PUSH
3978: LD_VAR 0 4
3982: DIFF
3983: ST_TO_ADDR
3984: GO 3954
3986: POP
3987: POP
// RewardPeople ( player_units ) ;
3988: LD_EXP 26
3992: PPUSH
3993: CALL_OW 43
// trotskij := [ ] ;
3997: LD_ADDR_VAR 0 11
4001: PUSH
4002: EMPTY
4003: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
4004: LD_ADDR_VAR 0 1
4008: PUSH
4009: LD_INT 22
4011: PUSH
4012: LD_INT 3
4014: PUSH
4015: EMPTY
4016: LIST
4017: LIST
4018: PUSH
4019: LD_INT 30
4021: PUSH
4022: LD_INT 3
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: PPUSH
4033: CALL_OW 69
4037: PUSH
4038: LD_INT 22
4040: PUSH
4041: LD_INT 3
4043: PUSH
4044: EMPTY
4045: LIST
4046: LIST
4047: PUSH
4048: LD_INT 21
4050: PUSH
4051: LD_INT 3
4053: PUSH
4054: EMPTY
4055: LIST
4056: LIST
4057: PUSH
4058: LD_INT 3
4060: PUSH
4061: LD_INT 30
4063: PUSH
4064: LD_INT 3
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: LIST
4079: PPUSH
4080: CALL_OW 69
4084: ADD
4085: ST_TO_ADDR
// for un in filter do
4086: LD_ADDR_VAR 0 3
4090: PUSH
4091: LD_VAR 0 1
4095: PUSH
4096: FOR_IN
4097: IFFALSE 4438
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
4099: LD_VAR 0 3
4103: PPUSH
4104: CALL_OW 266
4108: PUSH
4109: LD_INT 6
4111: PUSH
4112: LD_INT 7
4114: PUSH
4115: LD_INT 8
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: LIST
4122: IN
4123: IFFALSE 4237
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4125: LD_ADDR_VAR 0 11
4129: PUSH
4130: LD_VAR 0 11
4134: PUSH
4135: LD_VAR 0 3
4139: PPUSH
4140: CALL_OW 266
4144: PUSH
4145: LD_VAR 0 3
4149: PPUSH
4150: CALL_OW 250
4154: PUSH
4155: LD_VAR 0 3
4159: PPUSH
4160: CALL_OW 251
4164: PUSH
4165: LD_VAR 0 3
4169: PPUSH
4170: CALL_OW 254
4174: PUSH
4175: LD_VAR 0 3
4179: PPUSH
4180: CALL_OW 267
4184: PUSH
4185: LD_VAR 0 3
4189: PPUSH
4190: CALL_OW 248
4194: PUSH
4195: LD_VAR 0 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 268
4207: PUSH
4208: LD_VAR 0 3
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 268
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: ADD
4234: ST_TO_ADDR
4235: GO 4436
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4237: LD_VAR 0 3
4241: PPUSH
4242: CALL_OW 266
4246: PUSH
4247: LD_INT 32
4249: PUSH
4250: LD_INT 33
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: IN
4257: IFFALSE 4354
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4259: LD_ADDR_VAR 0 11
4263: PUSH
4264: LD_VAR 0 11
4268: PUSH
4269: LD_VAR 0 3
4273: PPUSH
4274: CALL_OW 266
4278: PUSH
4279: LD_VAR 0 3
4283: PPUSH
4284: CALL_OW 250
4288: PUSH
4289: LD_VAR 0 3
4293: PPUSH
4294: CALL_OW 251
4298: PUSH
4299: LD_VAR 0 3
4303: PPUSH
4304: CALL_OW 254
4308: PUSH
4309: LD_VAR 0 3
4313: PPUSH
4314: CALL_OW 267
4318: PUSH
4319: LD_VAR 0 3
4323: PPUSH
4324: CALL_OW 248
4328: PUSH
4329: LD_VAR 0 3
4333: PPUSH
4334: CALL_OW 269
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: ADD
4351: ST_TO_ADDR
4352: GO 4436
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4354: LD_ADDR_VAR 0 11
4358: PUSH
4359: LD_VAR 0 11
4363: PUSH
4364: LD_VAR 0 3
4368: PPUSH
4369: CALL_OW 266
4373: PUSH
4374: LD_VAR 0 3
4378: PPUSH
4379: CALL_OW 250
4383: PUSH
4384: LD_VAR 0 3
4388: PPUSH
4389: CALL_OW 251
4393: PUSH
4394: LD_VAR 0 3
4398: PPUSH
4399: CALL_OW 254
4403: PUSH
4404: LD_VAR 0 3
4408: PPUSH
4409: CALL_OW 267
4413: PUSH
4414: LD_VAR 0 3
4418: PPUSH
4419: CALL_OW 248
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: LIST
4430: LIST
4431: PUSH
4432: EMPTY
4433: LIST
4434: ADD
4435: ST_TO_ADDR
// end ;
4436: GO 4096
4438: POP
4439: POP
// SaveVariable ( trotskij , Trotskij ) ;
4440: LD_VAR 0 11
4444: PPUSH
4445: LD_STRING Trotskij
4447: PPUSH
4448: CALL_OW 39
// SaveVariable ( ListEnvironmentArea ( WholeMapArea ) , Environment ) ;
4452: LD_INT 10
4454: PPUSH
4455: CALL_OW 353
4459: PPUSH
4460: LD_STRING Environment
4462: PPUSH
4463: CALL_OW 39
// SaveVariable ( HeikeKilled , HeikeKilled ) ;
4467: LD_EXP 38
4471: PPUSH
4472: LD_STRING HeikeKilled
4474: PPUSH
4475: CALL_OW 39
// SaveVariable ( MercPaid , MercPaid ) ;
4479: LD_EXP 39
4483: PPUSH
4484: LD_STRING MercPaid
4486: PPUSH
4487: CALL_OW 39
// SaveVariable ( MercHandedOver , MercHandedOver ) ;
4491: LD_EXP 40
4495: PPUSH
4496: LD_STRING MercHandedOver
4498: PPUSH
4499: CALL_OW 39
// SaveVariable ( MercAccepted , MercAccepted ) ;
4503: LD_EXP 44
4507: PPUSH
4508: LD_STRING MercAccepted
4510: PPUSH
4511: CALL_OW 39
// SaveVariable ( GenscherBetrayed , GenscherBetrayed ) ;
4515: LD_EXP 36
4519: PPUSH
4520: LD_STRING GenscherBetrayed
4522: PPUSH
4523: CALL_OW 39
// SaveCharacters ( Heike , Heike ) ;
4527: LD_EXP 11
4531: PPUSH
4532: LD_STRING Heike
4534: PPUSH
4535: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
4539: LD_EXP 9
4543: PPUSH
4544: LD_STRING Petrosyan
4546: PPUSH
4547: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4551: LD_EXP 23
4555: PPUSH
4556: LD_STRING Dolgov
4558: PPUSH
4559: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4563: LD_EXP 24
4567: PPUSH
4568: LD_STRING Xavier
4570: PPUSH
4571: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
4575: LD_EXP 1
4579: PPUSH
4580: LD_STRING Burlak
4582: PPUSH
4583: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
4587: LD_EXP 3
4591: PPUSH
4592: LD_STRING Belkov
4594: PPUSH
4595: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
4599: LD_EXP 4
4603: PPUSH
4604: LD_STRING Kirilenkova
4606: PPUSH
4607: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
4611: LD_EXP 5
4615: PPUSH
4616: LD_STRING Gnyevko
4618: PPUSH
4619: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4623: LD_EXP 6
4627: PPUSH
4628: LD_STRING Kapitsova
4630: PPUSH
4631: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
4635: LD_EXP 8
4639: PPUSH
4640: LD_STRING Gleb
4642: PPUSH
4643: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
4647: LD_EXP 10
4651: PPUSH
4652: LD_STRING Kuzmov
4654: PPUSH
4655: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
4659: LD_EXP 12
4663: PPUSH
4664: LD_STRING Kovalyuk
4666: PPUSH
4667: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
4671: LD_EXP 15
4675: PPUSH
4676: LD_STRING Scholtze
4678: PPUSH
4679: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
4683: LD_EXP 17
4687: PPUSH
4688: LD_STRING Karamazov
4690: PPUSH
4691: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
4695: LD_EXP 18
4699: PPUSH
4700: LD_STRING Titov
4702: PPUSH
4703: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4707: LD_EXP 19
4711: PPUSH
4712: LD_STRING Oblukov
4714: PPUSH
4715: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4719: LD_EXP 20
4723: PPUSH
4724: LD_STRING Kozlov
4726: PPUSH
4727: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
4731: LD_EXP 21
4735: PPUSH
4736: LD_STRING Petrovova
4738: PPUSH
4739: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
4743: LD_EXP 22
4747: PPUSH
4748: LD_STRING Lipshchin
4750: PPUSH
4751: CALL_OW 38
// SaveCharacters ( ( ( player_units union other ) diff [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) , survivors3 ) ;
4755: LD_EXP 26
4759: PUSH
4760: LD_EXP 25
4764: UNION
4765: PUSH
4766: LD_EXP 1
4770: PUSH
4771: LD_EXP 3
4775: PUSH
4776: LD_EXP 4
4780: PUSH
4781: LD_EXP 5
4785: PUSH
4786: LD_EXP 6
4790: PUSH
4791: LD_EXP 8
4795: PUSH
4796: LD_EXP 10
4800: PUSH
4801: LD_EXP 12
4805: PUSH
4806: LD_EXP 15
4810: PUSH
4811: LD_EXP 17
4815: PUSH
4816: LD_EXP 18
4820: PUSH
4821: LD_EXP 19
4825: PUSH
4826: LD_EXP 20
4830: PUSH
4831: LD_EXP 21
4835: PUSH
4836: LD_EXP 22
4840: PUSH
4841: LD_EXP 9
4845: PUSH
4846: LD_EXP 23
4850: PUSH
4851: LD_EXP 24
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: DIFF
4876: PPUSH
4877: LD_STRING survivors3
4879: PPUSH
4880: CALL_OW 38
// YouWin ;
4884: CALL_OW 103
// exit ;
4888: GO 4891
// end ; enable ;
4890: ENABLE
// end ; end_of_file
4891: PPOPN 14
4893: END
// export function D_Start ; begin
4894: LD_INT 0
4896: PPUSH
// DialogueOn ;
4897: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
4901: LD_EXP 2
4905: PPUSH
4906: LD_STRING DStart-Pop-1
4908: PPUSH
4909: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
4913: LD_EXP 1
4917: PPUSH
4918: LD_STRING DStart-Bur-1
4920: PPUSH
4921: CALL_OW 88
// Wait ( 0 0$2 ) ;
4925: LD_INT 70
4927: PPUSH
4928: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
4932: LD_STRING MStart
4934: PPUSH
4935: CALL_OW 337
// display_strings := [ #Ru08-1 , ( 3 + AvailableBuildings ) , #Ru08-2 , ( 0 + AvailableWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
4939: LD_ADDR_OWVAR 47
4943: PUSH
4944: LD_STRING #Ru08-1
4946: PUSH
4947: LD_INT 3
4949: PUSH
4950: LD_EXP 55
4954: PLUS
4955: PUSH
4956: LD_STRING #Ru08-2
4958: PUSH
4959: LD_INT 0
4961: PUSH
4962: LD_EXP 54
4966: PLUS
4967: PUSH
4968: LD_STRING #Ru08-3
4970: PUSH
4971: LD_INT 0
4973: PUSH
4974: LD_EXP 56
4978: PLUS
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: ST_TO_ADDR
// DialogueOff ;
4988: CALL_OW 7
// end ;
4992: LD_VAR 0 1
4996: RET
// export function D_Heike ; begin
4997: LD_INT 0
4999: PPUSH
// Say ( Popov , DHeike-Pop-1 ) ;
5000: LD_EXP 2
5004: PPUSH
5005: LD_STRING DHeike-Pop-1
5007: PPUSH
5008: CALL_OW 88
// Wait ( 0 0$2 ) ;
5012: LD_INT 70
5014: PPUSH
5015: CALL_OW 67
// create_heike ;
5019: CALL 2623 0 0
// end ;
5023: LD_VAR 0 1
5027: RET
// export function D_HeikeKilled ; begin
5028: LD_INT 0
5030: PPUSH
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
5031: LD_EXP 11
5035: PPUSH
5036: LD_STRING DHeikeKilled-Hke-1
5038: PPUSH
5039: CALL_OW 91
// end ;
5043: LD_VAR 0 1
5047: RET
// export function D_MercHelp ; begin
5048: LD_INT 0
5050: PPUSH
// DialogueOn ;
5051: CALL_OW 6
// Say ( Kurt , DMercHelp-Kurt-1 ) ;
5055: LD_EXP 13
5059: PPUSH
5060: LD_STRING DMercHelp-Kurt-1
5062: PPUSH
5063: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-1 ) ;
5067: LD_EXP 1
5071: PPUSH
5072: LD_STRING DMercHelp-Bur-1
5074: PPUSH
5075: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-2 ) ;
5079: LD_EXP 13
5083: PPUSH
5084: LD_STRING DMercHelp-Kurt-2
5086: PPUSH
5087: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-2 ) ;
5091: LD_EXP 1
5095: PPUSH
5096: LD_STRING DMercHelp-Bur-2
5098: PPUSH
5099: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-3 ) ;
5103: LD_EXP 13
5107: PPUSH
5108: LD_STRING DMercHelp-Kurt-3
5110: PPUSH
5111: CALL_OW 88
// DialogueOff ;
5115: CALL_OW 7
// end ;
5119: LD_VAR 0 1
5123: RET
// export function D_QrMerc1 ; begin
5124: LD_INT 0
5126: PPUSH
// DialogueOn ;
5127: CALL_OW 6
// Say ( Burlak , DQrMerc#1-Bur-1 ) ;
5131: LD_EXP 1
5135: PPUSH
5136: LD_STRING DQrMerc#1-Bur-1
5138: PPUSH
5139: CALL_OW 88
// Say ( Kurt , DQrMerc#1-Kurt-1 ) ;
5143: LD_EXP 13
5147: PPUSH
5148: LD_STRING DQrMerc#1-Kurt-1
5150: PPUSH
5151: CALL_OW 88
// DialogueOff ;
5155: CALL_OW 7
// end ;
5159: LD_VAR 0 1
5163: RET
// export function D_QrMerc2 ; begin
5164: LD_INT 0
5166: PPUSH
// DialogueOn ;
5167: CALL_OW 6
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
5171: LD_EXP 1
5175: PPUSH
5176: LD_STRING DQrMerc#2-Bur-1
5178: PPUSH
5179: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
5183: LD_EXP 2
5187: PPUSH
5188: LD_STRING DQrMerc#2-Pop-1
5190: PPUSH
5191: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
5195: LD_EXP 1
5199: PPUSH
5200: LD_STRING DQrMerc#2-Bur-2
5202: PPUSH
5203: CALL_OW 88
// DialogueOff ;
5207: CALL_OW 7
// end ;
5211: LD_VAR 0 1
5215: RET
// export function D_QrMerc3 ; begin
5216: LD_INT 0
5218: PPUSH
// DialogueOn ;
5219: CALL_OW 6
// Say ( Burlak , DQrMerc#3-Bur-1 ) ;
5223: LD_EXP 1
5227: PPUSH
5228: LD_STRING DQrMerc#3-Bur-1
5230: PPUSH
5231: CALL_OW 88
// DialogueOff ;
5235: CALL_OW 7
// end ;
5239: LD_VAR 0 1
5243: RET
// export function D_MercRefuseBuild ; begin
5244: LD_INT 0
5246: PPUSH
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
5247: LD_EXP 13
5251: PPUSH
5252: LD_STRING DMercRefuseBuild-Kurt-1
5254: PPUSH
5255: CALL_OW 88
// end ;
5259: LD_VAR 0 1
5263: RET
// export function D_MercCompleted ; begin
5264: LD_INT 0
5266: PPUSH
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
5267: LD_EXP 13
5271: PPUSH
5272: LD_STRING DMercCompleted-Kurt-1
5274: PPUSH
5275: CALL_OW 88
// end ;
5279: LD_VAR 0 1
5283: RET
// export function D_MercPopov ; begin
5284: LD_INT 0
5286: PPUSH
// DialogueOn ;
5287: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
5291: LD_EXP 2
5295: PPUSH
5296: LD_STRING DMercPopov-Pop-1
5298: PPUSH
5299: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
5303: LD_EXP 1
5307: PPUSH
5308: LD_STRING DMercPopov-Bur-1
5310: PPUSH
5311: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
5315: LD_EXP 2
5319: PPUSH
5320: LD_STRING DMercPopov-Pop-2
5322: PPUSH
5323: CALL_OW 94
// DialogueOff ;
5327: CALL_OW 7
// end ;
5331: LD_VAR 0 1
5335: RET
// export function D_MercAmbush ; begin
5336: LD_INT 0
5338: PPUSH
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
5339: LD_EXP 13
5343: PPUSH
5344: LD_STRING DMercAmbush-Kurt-1
5346: PPUSH
5347: CALL_OW 88
// SetAttitude ( you , merc , att_enemy , true ) ;
5351: LD_EXP 31
5355: PPUSH
5356: LD_EXP 34
5360: PPUSH
5361: LD_INT 2
5363: PPUSH
5364: LD_INT 1
5366: PPUSH
5367: CALL_OW 80
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
5371: LD_INT 8
5373: PPUSH
5374: LD_INT 0
5376: PPUSH
5377: CALL_OW 424
// disable ( 20 ) ;
5381: LD_INT 20
5383: DISABLE_MARKED
// end ;
5384: LD_VAR 0 1
5388: RET
// export function D_MercAttack ; begin
5389: LD_INT 0
5391: PPUSH
// Say ( Kurt , DMercAttack-Kurt-1 ) ;
5392: LD_EXP 13
5396: PPUSH
5397: LD_STRING DMercAttack-Kurt-1
5399: PPUSH
5400: CALL_OW 88
// end ;
5404: LD_VAR 0 1
5408: RET
// export function D_MercDeceived ; begin
5409: LD_INT 0
5411: PPUSH
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
5412: LD_EXP 13
5416: PPUSH
5417: LD_STRING DMercDeceived-Kurt-1
5419: PPUSH
5420: CALL_OW 88
// end ;
5424: LD_VAR 0 1
5428: RET
// export function D_ArabianRequest ; begin
5429: LD_INT 0
5431: PPUSH
// DialogueOn ;
5432: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
5436: LD_EXP 7
5440: PPUSH
5441: LD_STRING DArabianRequest-Diet-1
5443: PPUSH
5444: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
5448: LD_EXP 1
5452: PPUSH
5453: LD_STRING DArabianRequest-Bur-1
5455: PPUSH
5456: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
5460: LD_EXP 7
5464: PPUSH
5465: LD_STRING DArabianRequest-Diet-2
5467: PPUSH
5468: CALL_OW 94
// case Query ( QHandOver ) of 1 :
5472: LD_STRING QHandOver
5474: PPUSH
5475: CALL_OW 97
5479: PUSH
5480: LD_INT 1
5482: DOUBLE
5483: EQUAL
5484: IFTRUE 5488
5486: GO 5503
5488: POP
// begin D_QrHandOver1 ;
5489: CALL 5536 0 0
// MercWillBeHandedOver := true ;
5493: LD_ADDR_EXP 41
5497: PUSH
5498: LD_INT 1
5500: ST_TO_ADDR
// end ; 2 :
5501: GO 5527
5503: LD_INT 2
5505: DOUBLE
5506: EQUAL
5507: IFTRUE 5511
5509: GO 5526
5511: POP
// begin MercHandedOver = false ;
5512: LD_ADDR_EXP 40
5516: PUSH
5517: LD_INT 0
5519: ST_TO_ADDR
// D_QrHandOver2 ;
5520: CALL 5580 0 0
// end ; end ;
5524: GO 5527
5526: POP
// DialogueOff ;
5527: CALL_OW 7
// end ;
5531: LD_VAR 0 1
5535: RET
// export function D_QrHandOver1 ; begin
5536: LD_INT 0
5538: PPUSH
// DialogueOn ;
5539: CALL_OW 6
// Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
5543: LD_EXP 1
5547: PPUSH
5548: LD_STRING DQrHandOver#1-Bur-1
5550: PPUSH
5551: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
5555: LD_EXP 7
5559: PPUSH
5560: LD_STRING DQrHandOver#1-Diet-1
5562: PPUSH
5563: CALL_OW 94
// DialogueOff ;
5567: CALL_OW 7
// hand_over ;
5571: CALL 8492 0 0
// end ;
5575: LD_VAR 0 1
5579: RET
// export function D_QrHandOver2 ; begin
5580: LD_INT 0
5582: PPUSH
// DialogueOn ;
5583: CALL_OW 6
// Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
5587: LD_EXP 1
5591: PPUSH
5592: LD_STRING DQrHandOver#2-Bur-1
5594: PPUSH
5595: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
5599: LD_EXP 7
5603: PPUSH
5604: LD_STRING DQrHandOver#2-Diet-1
5606: PPUSH
5607: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
5611: LD_EXP 1
5615: PPUSH
5616: LD_STRING DQrHandOver#2-Bur-2
5618: PPUSH
5619: CALL_OW 88
// DialogueOff ;
5623: CALL_OW 7
// end ;
5627: LD_VAR 0 1
5631: RET
// export function D_HandOverCome ; begin
5632: LD_INT 0
5634: PPUSH
// DialogueOn ;
5635: CALL_OW 6
// Say ( ASoldier1 , DHandOverCome-ASol1-1 ) ;
5639: LD_EXP 16
5643: PPUSH
5644: LD_STRING DHandOverCome-ASol1-1
5646: PPUSH
5647: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
5651: LD_EXP 13
5655: PPUSH
5656: LD_STRING DHandOverCome-Kurt-1
5658: PPUSH
5659: CALL_OW 88
// DialogueOff ;
5663: CALL_OW 7
// end ;
5667: LD_VAR 0 1
5671: RET
// export function D_HandOverSpoiled ; begin
5672: LD_INT 0
5674: PPUSH
// DialogueOn ;
5675: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
5679: LD_EXP 7
5683: PPUSH
5684: LD_STRING DHandOverSpoiled-Diet-1
5686: PPUSH
5687: CALL_OW 94
// DialogueOff ;
5691: CALL_OW 7
// end ;
5695: LD_VAR 0 1
5699: RET
// export function D_LegionFormed ; begin
5700: LD_INT 0
5702: PPUSH
// DialogueOn ;
5703: CALL_OW 6
// Say ( Heike , DLegionFormed-Hke-1 ) ;
5707: LD_EXP 11
5711: PPUSH
5712: LD_STRING DLegionFormed-Hke-1
5714: PPUSH
5715: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
5719: LD_EXP 1
5723: PPUSH
5724: LD_STRING DLegionFormed-Bur-1
5726: PPUSH
5727: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-2 ) ;
5731: LD_EXP 11
5735: PPUSH
5736: LD_STRING DLegionFormed-Hke-2
5738: PPUSH
5739: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
5743: LD_EXP 1
5747: PPUSH
5748: LD_STRING DLegionFormed-Bur-2
5750: PPUSH
5751: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-3 ) ;
5755: LD_EXP 11
5759: PPUSH
5760: LD_STRING DLegionFormed-Hke-3
5762: PPUSH
5763: CALL_OW 88
// DialogueOff ;
5767: CALL_OW 7
// end ;
5771: LD_VAR 0 1
5775: RET
// export function D_QrLegion1 ; begin
5776: LD_INT 0
5778: PPUSH
// DialogueOn ;
5779: CALL_OW 6
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
5783: LD_EXP 1
5787: PPUSH
5788: LD_STRING DQrLegion#1-Bur-1
5790: PPUSH
5791: CALL_OW 88
// DialogueOff ;
5795: CALL_OW 7
// end ;
5799: LD_VAR 0 1
5803: RET
// export function D_QrLegion2 ; begin
5804: LD_INT 0
5806: PPUSH
// DialogueOn ;
5807: CALL_OW 6
// Say ( Burlak , DQrLegion#2-Bur-1 ) ;
5811: LD_EXP 1
5815: PPUSH
5816: LD_STRING DQrLegion#2-Bur-1
5818: PPUSH
5819: CALL_OW 88
// DialogueOff ;
5823: CALL_OW 7
// end ;
5827: LD_VAR 0 1
5831: RET
// export function D_FiringRange ; begin
5832: LD_INT 0
5834: PPUSH
// DialogueOn ;
5835: CALL_OW 6
// if IsOK ( Kuzmov ) then
5839: LD_EXP 10
5843: PPUSH
5844: CALL_OW 302
5848: IFFALSE 5864
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
5850: LD_EXP 10
5854: PPUSH
5855: LD_STRING DFiringRange-Kuz-1
5857: PPUSH
5858: CALL_OW 88
5862: GO 5876
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
5864: LD_EXP 19
5868: PPUSH
5869: LD_STRING DFiringRange-Obl-1
5871: PPUSH
5872: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
5876: LD_EXP 1
5880: PPUSH
5881: LD_STRING DFiringRange-Bur-1
5883: PPUSH
5884: CALL_OW 88
// CenterOnXY ( 59 , 34 ) ;
5888: LD_INT 59
5890: PPUSH
5891: LD_INT 34
5893: PPUSH
5894: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
5898: LD_INT 18
5900: PPUSH
5901: CALL_OW 67
// RevealFogArea ( you , ShootArea ) ;
5905: LD_EXP 31
5909: PPUSH
5910: LD_INT 11
5912: PPUSH
5913: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
5917: LD_INT 11
5919: PPUSH
5920: LD_INT 1
5922: PPUSH
5923: CALL_OW 424
// if IsOK ( Kuzmov ) then
5927: LD_EXP 10
5931: PPUSH
5932: CALL_OW 302
5936: IFFALSE 5952
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
5938: LD_EXP 10
5942: PPUSH
5943: LD_STRING DFiringRange-Kuz-2
5945: PPUSH
5946: CALL_OW 88
5950: GO 5964
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
5952: LD_EXP 19
5956: PPUSH
5957: LD_STRING DFiringRange-Obl-2
5959: PPUSH
5960: CALL_OW 88
// DialogueOff ;
5964: CALL_OW 7
// end ;
5968: LD_VAR 0 1
5972: RET
// export function D_QrShootingGallery1 ; begin
5973: LD_INT 0
5975: PPUSH
// Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
5976: LD_EXP 1
5980: PPUSH
5981: LD_STRING DQrShootingGallery#1-Bur-1
5983: PPUSH
5984: CALL_OW 88
// end ;
5988: LD_VAR 0 1
5992: RET
// export function D_QrShootingGallery2 ; begin
5993: LD_INT 0
5995: PPUSH
// Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
5996: LD_EXP 1
6000: PPUSH
6001: LD_STRING DQrShootingGallery#2-Bur-1
6003: PPUSH
6004: CALL_OW 88
// end ;
6008: LD_VAR 0 1
6012: RET
// export function D_Hunting ; var allhunters ; begin
6013: LD_INT 0
6015: PPUSH
6016: PPUSH
// DialogueOn ;
6017: CALL_OW 6
// allhunters := [ ] ;
6021: LD_ADDR_VAR 0 2
6025: PUSH
6026: EMPTY
6027: ST_TO_ADDR
// if IsOK ( Belkov ) then
6028: LD_EXP 3
6032: PPUSH
6033: CALL_OW 302
6037: IFFALSE 6055
// allhunters := allhunters ^ Belkov ;
6039: LD_ADDR_VAR 0 2
6043: PUSH
6044: LD_VAR 0 2
6048: PUSH
6049: LD_EXP 3
6053: ADD
6054: ST_TO_ADDR
// if IsOK ( Karamazov ) then
6055: LD_EXP 17
6059: PPUSH
6060: CALL_OW 302
6064: IFFALSE 6082
// allhunters := allhunters ^ Karamazov ;
6066: LD_ADDR_VAR 0 2
6070: PUSH
6071: LD_VAR 0 2
6075: PUSH
6076: LD_EXP 17
6080: ADD
6081: ST_TO_ADDR
// if IsOK ( Kozlov ) then
6082: LD_EXP 20
6086: PPUSH
6087: CALL_OW 302
6091: IFFALSE 6109
// allhunters := allhunters ^ Kozlov ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PUSH
6103: LD_EXP 20
6107: ADD
6108: ST_TO_ADDR
// Randomize ;
6109: CALL_OW 10
// RandomizeAll ;
6113: CALL_OW 11
// hunter := allhunters [ Rand ( 1 , ( allhunters + 0 ) ) ] ;
6117: LD_ADDR_EXP 72
6121: PUSH
6122: LD_VAR 0 2
6126: PUSH
6127: LD_INT 1
6129: PPUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_INT 0
6137: PLUS
6138: PPUSH
6139: CALL_OW 12
6143: ARRAY
6144: ST_TO_ADDR
// case hunter of Belkov :
6145: LD_EXP 72
6149: PUSH
6150: LD_EXP 3
6154: DOUBLE
6155: EQUAL
6156: IFTRUE 6160
6158: GO 6175
6160: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
6161: LD_EXP 3
6165: PPUSH
6166: LD_STRING DHunting-Bel-1
6168: PPUSH
6169: CALL_OW 88
6173: GO 6226
6175: LD_EXP 17
6179: DOUBLE
6180: EQUAL
6181: IFTRUE 6185
6183: GO 6200
6185: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
6186: LD_EXP 17
6190: PPUSH
6191: LD_STRING DHunting-Kar-1
6193: PPUSH
6194: CALL_OW 88
6198: GO 6226
6200: LD_EXP 20
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6225
6210: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
6211: LD_EXP 20
6215: PPUSH
6216: LD_STRING DHunting-Koz-1
6218: PPUSH
6219: CALL_OW 88
6223: GO 6226
6225: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
6226: LD_EXP 1
6230: PPUSH
6231: LD_STRING DHunting-Bur-1
6233: PPUSH
6234: CALL_OW 88
// case hunter of Belkov :
6238: LD_EXP 72
6242: PUSH
6243: LD_EXP 3
6247: DOUBLE
6248: EQUAL
6249: IFTRUE 6253
6251: GO 6268
6253: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
6254: LD_EXP 3
6258: PPUSH
6259: LD_STRING DHunting-Bel-2
6261: PPUSH
6262: CALL_OW 88
6266: GO 6319
6268: LD_EXP 17
6272: DOUBLE
6273: EQUAL
6274: IFTRUE 6278
6276: GO 6293
6278: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
6279: LD_EXP 17
6283: PPUSH
6284: LD_STRING DHunting-Kar-2
6286: PPUSH
6287: CALL_OW 88
6291: GO 6319
6293: LD_EXP 20
6297: DOUBLE
6298: EQUAL
6299: IFTRUE 6303
6301: GO 6318
6303: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
6304: LD_EXP 20
6308: PPUSH
6309: LD_STRING DHunting-Koz-2
6311: PPUSH
6312: CALL_OW 88
6316: GO 6319
6318: POP
// DialogueOff ;
6319: CALL_OW 7
// end ;
6323: LD_VAR 0 1
6327: RET
// export function D_QrHunting1 ; begin
6328: LD_INT 0
6330: PPUSH
// Say ( Burlak , DQrHunting#1-Bur-1 ) ;
6331: LD_EXP 1
6335: PPUSH
6336: LD_STRING DQrHunting#1-Bur-1
6338: PPUSH
6339: CALL_OW 88
// end ;
6343: LD_VAR 0 1
6347: RET
// export function D_QrHunting2 ; begin
6348: LD_INT 0
6350: PPUSH
// Say ( Burlak , DQrHunting#2-Bur-1 ) ;
6351: LD_EXP 1
6355: PPUSH
6356: LD_STRING DQrHunting#2-Bur-1
6358: PPUSH
6359: CALL_OW 88
// end ;
6363: LD_VAR 0 1
6367: RET
// export function D_FreeTime ; var pole ; begin
6368: LD_INT 0
6370: PPUSH
6371: PPUSH
// DialogueOn ;
6372: CALL_OW 6
// Randomize ;
6376: CALL_OW 10
// RandomizeAll ;
6380: CALL_OW 11
// pole := [ ] ;
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: EMPTY
6390: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
6391: LD_EXP 6
6395: PPUSH
6396: CALL_OW 302
6400: IFFALSE 6418
// pole := pole ^ Kapitsova ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PUSH
6412: LD_EXP 6
6416: ADD
6417: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Petrovova :
6418: LD_VAR 0 2
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 0
6428: PUSH
6429: LD_VAR 0 2
6433: PLUS
6434: PPUSH
6435: CALL_OW 12
6439: ARRAY
6440: PUSH
6441: LD_EXP 21
6445: DOUBLE
6446: EQUAL
6447: IFTRUE 6451
6449: GO 6476
6451: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
6452: LD_EXP 21
6456: PPUSH
6457: LD_STRING DFreeTime-Ptr-1
6459: PPUSH
6460: CALL_OW 88
// FreeWoman := Petrovova ;
6464: LD_ADDR_EXP 58
6468: PUSH
6469: LD_EXP 21
6473: ST_TO_ADDR
// end ; Kirilenkova :
6474: GO 6547
6476: LD_EXP 4
6480: DOUBLE
6481: EQUAL
6482: IFTRUE 6486
6484: GO 6511
6486: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
6487: LD_EXP 4
6491: PPUSH
6492: LD_STRING DFreeTime-Kir-1
6494: PPUSH
6495: CALL_OW 88
// FreeWoman := Kirilenkova ;
6499: LD_ADDR_EXP 58
6503: PUSH
6504: LD_EXP 4
6508: ST_TO_ADDR
// end ; Kapitsova :
6509: GO 6547
6511: LD_EXP 6
6515: DOUBLE
6516: EQUAL
6517: IFTRUE 6521
6519: GO 6546
6521: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
6522: LD_EXP 6
6526: PPUSH
6527: LD_STRING DFreeTime-Kap-1
6529: PPUSH
6530: CALL_OW 88
// FreeWoman := Kapitsova ;
6534: LD_ADDR_EXP 58
6538: PUSH
6539: LD_EXP 6
6543: ST_TO_ADDR
// end ; end ;
6544: GO 6547
6546: POP
// pole := [ ] ;
6547: LD_ADDR_VAR 0 2
6551: PUSH
6552: EMPTY
6553: ST_TO_ADDR
// if IsOK ( Kuzmov ) then
6554: LD_EXP 10
6558: PPUSH
6559: CALL_OW 302
6563: IFFALSE 6581
// pole := pole ^ Kuzmov ;
6565: LD_ADDR_VAR 0 2
6569: PUSH
6570: LD_VAR 0 2
6574: PUSH
6575: LD_EXP 10
6579: ADD
6580: ST_TO_ADDR
// if IsOK ( Titov ) then
6581: LD_EXP 18
6585: PPUSH
6586: CALL_OW 302
6590: IFFALSE 6608
// pole := pole ^ Titov ;
6592: LD_ADDR_VAR 0 2
6596: PUSH
6597: LD_VAR 0 2
6601: PUSH
6602: LD_EXP 18
6606: ADD
6607: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
6608: LD_EXP 5
6612: PPUSH
6613: CALL_OW 302
6617: IFFALSE 6635
// pole := pole ^ Gnyevko ;
6619: LD_ADDR_VAR 0 2
6623: PUSH
6624: LD_VAR 0 2
6628: PUSH
6629: LD_EXP 5
6633: ADD
6634: ST_TO_ADDR
// if IsOK ( Oblukov ) then
6635: LD_EXP 19
6639: PPUSH
6640: CALL_OW 302
6644: IFFALSE 6662
// pole := pole ^ Oblukov ;
6646: LD_ADDR_VAR 0 2
6650: PUSH
6651: LD_VAR 0 2
6655: PUSH
6656: LD_EXP 19
6660: ADD
6661: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Kuzmov :
6662: LD_VAR 0 2
6666: PUSH
6667: LD_INT 1
6669: PPUSH
6670: LD_INT 0
6672: PUSH
6673: LD_VAR 0 2
6677: PLUS
6678: PPUSH
6679: CALL_OW 12
6683: ARRAY
6684: PUSH
6685: LD_EXP 10
6689: DOUBLE
6690: EQUAL
6691: IFTRUE 6695
6693: GO 6720
6695: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
6696: LD_EXP 10
6700: PPUSH
6701: LD_STRING DFreeTime-Kuz-1
6703: PPUSH
6704: CALL_OW 88
// FreeMan := Kuzmov ;
6708: LD_ADDR_EXP 57
6712: PUSH
6713: LD_EXP 10
6717: ST_TO_ADDR
// end ; Titov :
6718: GO 6826
6720: LD_EXP 18
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6755
6730: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
6731: LD_EXP 18
6735: PPUSH
6736: LD_STRING DFreeTime-Tit-1
6738: PPUSH
6739: CALL_OW 88
// FreeMan := Titov ;
6743: LD_ADDR_EXP 57
6747: PUSH
6748: LD_EXP 18
6752: ST_TO_ADDR
// end ; Gnyevko :
6753: GO 6826
6755: LD_EXP 5
6759: DOUBLE
6760: EQUAL
6761: IFTRUE 6765
6763: GO 6790
6765: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
6766: LD_EXP 5
6770: PPUSH
6771: LD_STRING DFreeTime-Gny-1
6773: PPUSH
6774: CALL_OW 88
// FreeMan := Gnyevko ;
6778: LD_ADDR_EXP 57
6782: PUSH
6783: LD_EXP 5
6787: ST_TO_ADDR
// end ; Oblukov :
6788: GO 6826
6790: LD_EXP 19
6794: DOUBLE
6795: EQUAL
6796: IFTRUE 6800
6798: GO 6825
6800: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
6801: LD_EXP 19
6805: PPUSH
6806: LD_STRING DFreeTime-Obl-1
6808: PPUSH
6809: CALL_OW 88
// FreeMan := Oblukov ;
6813: LD_ADDR_EXP 57
6817: PUSH
6818: LD_EXP 19
6822: ST_TO_ADDR
// end ; end ;
6823: GO 6826
6825: POP
// DialogueOff ;
6826: CALL_OW 7
// end ;
6830: LD_VAR 0 1
6834: RET
// export function D_QrFreeTime1 ; begin
6835: LD_INT 0
6837: PPUSH
// Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
6838: LD_EXP 1
6842: PPUSH
6843: LD_STRING DQrFreeTime#1-Bur-1
6845: PPUSH
6846: CALL_OW 88
// end ;
6850: LD_VAR 0 1
6854: RET
// export function D_QrFreeTime2 ; begin
6855: LD_INT 0
6857: PPUSH
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ;
6858: LD_EXP 1
6862: PPUSH
6863: LD_STRING DQrFreeTime#2-Bur-1
6865: PPUSH
6866: CALL_OW 88
// end ;
6870: LD_VAR 0 1
6874: RET
// export function D_Masha ; begin
6875: LD_INT 0
6877: PPUSH
// DialogueOn ;
6878: CALL_OW 6
// Say ( Kozlov , DMasha-Koz-1 ) ;
6882: LD_EXP 20
6886: PPUSH
6887: LD_STRING DMasha-Koz-1
6889: PPUSH
6890: CALL_OW 88
// DialogueOff ;
6894: CALL_OW 7
// end ;
6898: LD_VAR 0 1
6902: RET
// export function D_Masha2 ; begin
6903: LD_INT 0
6905: PPUSH
// Say ( Burlak , DMasha2-Bur-1 ) ;
6906: LD_EXP 1
6910: PPUSH
6911: LD_STRING DMasha2-Bur-1
6913: PPUSH
6914: CALL_OW 88
// end ;
6918: LD_VAR 0 1
6922: RET
// export function D_AI ; begin
6923: LD_INT 0
6925: PPUSH
// DialogueOn ;
6926: CALL_OW 6
// if IsOK ( Scholtze ) then
6930: LD_EXP 15
6934: PPUSH
6935: CALL_OW 302
6939: IFFALSE 6955
// Say ( Scholtze , DAI-Sch-1 ) else
6941: LD_EXP 15
6945: PPUSH
6946: LD_STRING DAI-Sch-1
6948: PPUSH
6949: CALL_OW 88
6953: GO 6967
// Say ( Kapitsova , DAI-Kap-1 ) ;
6955: LD_EXP 6
6959: PPUSH
6960: LD_STRING DAI-Kap-1
6962: PPUSH
6963: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
6967: LD_EXP 1
6971: PPUSH
6972: LD_STRING DAI-Bur-1
6974: PPUSH
6975: CALL_OW 88
// if IsOK ( Scholtze ) then
6979: LD_EXP 15
6983: PPUSH
6984: CALL_OW 302
6988: IFFALSE 7004
// Say ( Scholtze , DAI-Sch-2 ) else
6990: LD_EXP 15
6994: PPUSH
6995: LD_STRING DAI-Sch-2
6997: PPUSH
6998: CALL_OW 88
7002: GO 7016
// Say ( Kapitsova , DAI-Kap-2 ) ;
7004: LD_EXP 6
7008: PPUSH
7009: LD_STRING DAI-Kap-2
7011: PPUSH
7012: CALL_OW 88
// DialogueOff ;
7016: CALL_OW 7
// end ;
7020: LD_VAR 0 1
7024: RET
// export function D_SpontTelep ; begin
7025: LD_INT 0
7027: PPUSH
// DialogueOn ;
7028: CALL_OW 6
// if IsOK ( Scholtze ) then
7032: LD_EXP 15
7036: PPUSH
7037: CALL_OW 302
7041: IFFALSE 7057
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
7043: LD_EXP 15
7047: PPUSH
7048: LD_STRING DSpontTelep-Sch-1
7050: PPUSH
7051: CALL_OW 88
7055: GO 7069
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
7057: LD_EXP 6
7061: PPUSH
7062: LD_STRING DSpontTelep-Kap-1
7064: PPUSH
7065: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
7069: LD_EXP 1
7073: PPUSH
7074: LD_STRING DSpontTelep-Bur-1
7076: PPUSH
7077: CALL_OW 88
// if IsOK ( Scholtze ) then
7081: LD_EXP 15
7085: PPUSH
7086: CALL_OW 302
7090: IFFALSE 7106
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
7092: LD_EXP 15
7096: PPUSH
7097: LD_STRING DSpontTelep-Sch-2
7099: PPUSH
7100: CALL_OW 88
7104: GO 7118
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
7106: LD_EXP 6
7110: PPUSH
7111: LD_STRING DSpontTelep-Kap-2
7113: PPUSH
7114: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
7118: LD_EXP 1
7122: PPUSH
7123: LD_STRING DSpontTelep-Bur-2
7125: PPUSH
7126: CALL_OW 88
// DialogueOff ;
7130: CALL_OW 7
// end ;
7134: LD_VAR 0 1
7138: RET
// export function D_AmAttackStart ; begin
7139: LD_INT 0
7141: PPUSH
// SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
7142: LD_EXP 2
7146: PPUSH
7147: LD_STRING DAmAttackStart-Pop-1
7149: PPUSH
7150: CALL_OW 94
// enable ( 50 ) ;
7154: LD_INT 50
7156: ENABLE_MARKED
// end ;
7157: LD_VAR 0 1
7161: RET
// every 0 0$1 marked 50 do
7162: GO 7164
7164: DISABLE
// begin Wait ( 0 0$10 ) ;
7165: LD_INT 350
7167: PPUSH
7168: CALL_OW 67
// if MercPaid then
7172: LD_EXP 39
7176: IFFALSE 7215
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
7178: LD_EXP 1
7182: PPUSH
7183: LD_STRING DAmAttackStart-Bur-1
7185: PPUSH
7186: CALL_OW 88
// if IsOK ( Gleb ) then
7190: LD_EXP 8
7194: PPUSH
7195: CALL_OW 302
7199: IFFALSE 7213
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
7201: LD_EXP 8
7205: PPUSH
7206: LD_STRING DAmAttackStart-Glb-1
7208: PPUSH
7209: CALL_OW 88
// end else
7213: GO 7227
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
7215: LD_EXP 1
7219: PPUSH
7220: LD_STRING DAmAttackStart-Bur-2
7222: PPUSH
7223: CALL_OW 88
// end ;
7227: END
// export function D_AmAttackFin ; var rnd , bool ; begin
7228: LD_INT 0
7230: PPUSH
7231: PPUSH
7232: PPUSH
// DialogueOn ;
7233: CALL_OW 6
// repeat rnd := Rand ( 1 , 7 ) ;
7237: LD_ADDR_VAR 0 2
7241: PUSH
7242: LD_INT 1
7244: PPUSH
7245: LD_INT 7
7247: PPUSH
7248: CALL_OW 12
7252: ST_TO_ADDR
// case rnd of 1 :
7253: LD_VAR 0 2
7257: PUSH
7258: LD_INT 1
7260: DOUBLE
7261: EQUAL
7262: IFTRUE 7266
7264: GO 7298
7266: POP
// if IsOK ( Belkov ) then
7267: LD_EXP 3
7271: PPUSH
7272: CALL_OW 302
7276: IFFALSE 7296
// bool := Say ( Belkov , DAmAttackFin-Bel-1 ) ; 2 :
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_EXP 3
7287: PPUSH
7288: LD_STRING DAmAttackFin-Bel-1
7290: PPUSH
7291: CALL_OW 88
7295: ST_TO_ADDR
7296: GO 7539
7298: LD_INT 2
7300: DOUBLE
7301: EQUAL
7302: IFTRUE 7306
7304: GO 7338
7306: POP
// if IsOK ( Gnyevko ) then
7307: LD_EXP 5
7311: PPUSH
7312: CALL_OW 302
7316: IFFALSE 7336
// bool := Say ( Gnyevko , DAmAttackFin-Gny-1 ) ; 3 :
7318: LD_ADDR_VAR 0 3
7322: PUSH
7323: LD_EXP 5
7327: PPUSH
7328: LD_STRING DAmAttackFin-Gny-1
7330: PPUSH
7331: CALL_OW 88
7335: ST_TO_ADDR
7336: GO 7539
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7378
7346: POP
// if IsOK ( Titov ) then
7347: LD_EXP 18
7351: PPUSH
7352: CALL_OW 302
7356: IFFALSE 7376
// bool := Say ( Titov , DAmAttackFin-Tit-1 ) ; 4 :
7358: LD_ADDR_VAR 0 3
7362: PUSH
7363: LD_EXP 18
7367: PPUSH
7368: LD_STRING DAmAttackFin-Tit-1
7370: PPUSH
7371: CALL_OW 88
7375: ST_TO_ADDR
7376: GO 7539
7378: LD_INT 4
7380: DOUBLE
7381: EQUAL
7382: IFTRUE 7386
7384: GO 7418
7386: POP
// if IsOK ( Lipshchin ) then
7387: LD_EXP 22
7391: PPUSH
7392: CALL_OW 302
7396: IFFALSE 7416
// bool := Say ( Lipshchin , DAmAttackFin-Lip-1 ) ; 5 :
7398: LD_ADDR_VAR 0 3
7402: PUSH
7403: LD_EXP 22
7407: PPUSH
7408: LD_STRING DAmAttackFin-Lip-1
7410: PPUSH
7411: CALL_OW 88
7415: ST_TO_ADDR
7416: GO 7539
7418: LD_INT 5
7420: DOUBLE
7421: EQUAL
7422: IFTRUE 7426
7424: GO 7458
7426: POP
// if IsOK ( Karamazov ) then
7427: LD_EXP 17
7431: PPUSH
7432: CALL_OW 302
7436: IFFALSE 7456
// bool := Say ( Karamazov , DAmAttackFin-Kar-1 ) ; 6 :
7438: LD_ADDR_VAR 0 3
7442: PUSH
7443: LD_EXP 17
7447: PPUSH
7448: LD_STRING DAmAttackFin-Kar-1
7450: PPUSH
7451: CALL_OW 88
7455: ST_TO_ADDR
7456: GO 7539
7458: LD_INT 6
7460: DOUBLE
7461: EQUAL
7462: IFTRUE 7466
7464: GO 7498
7466: POP
// if IsOK ( Oblukov ) then
7467: LD_EXP 19
7471: PPUSH
7472: CALL_OW 302
7476: IFFALSE 7496
// bool := Say ( Oblukov , DAmAttackFin-Obl-1 ) ; 7 :
7478: LD_ADDR_VAR 0 3
7482: PUSH
7483: LD_EXP 19
7487: PPUSH
7488: LD_STRING DAmAttackFin-Obl-1
7490: PPUSH
7491: CALL_OW 88
7495: ST_TO_ADDR
7496: GO 7539
7498: LD_INT 7
7500: DOUBLE
7501: EQUAL
7502: IFTRUE 7506
7504: GO 7538
7506: POP
// if IsOK ( Burlak ) then
7507: LD_EXP 1
7511: PPUSH
7512: CALL_OW 302
7516: IFFALSE 7536
// bool := Say ( Burlak , DAmAttackFin-Bur-1 ) ; end ;
7518: LD_ADDR_VAR 0 3
7522: PUSH
7523: LD_EXP 1
7527: PPUSH
7528: LD_STRING DAmAttackFin-Bur-1
7530: PPUSH
7531: CALL_OW 88
7535: ST_TO_ADDR
7536: GO 7539
7538: POP
// until bool ;
7539: LD_VAR 0 3
7543: IFFALSE 7237
// Say ( Popov , DAmAttackFin-Pop-1 ) ;
7545: LD_EXP 2
7549: PPUSH
7550: LD_STRING DAmAttackFin-Pop-1
7552: PPUSH
7553: CALL_OW 88
// DialogueOff ;
7557: CALL_OW 7
// end ; end_of_file
7561: LD_VAR 0 1
7565: RET
// export function merc_help ; var rnd ; begin
7566: LD_INT 0
7568: PPUSH
7569: PPUSH
// rnd := Rand ( 2 2$0 , 3 3$0 ) ;
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 4200
7577: PPUSH
7578: LD_INT 6300
7580: PPUSH
7581: CALL_OW 12
7585: ST_TO_ADDR
// Wait ( rnd ) ;
7586: LD_VAR 0 2
7590: PPUSH
7591: CALL_OW 67
// if not HeikeKilled then
7595: LD_EXP 38
7599: NOT
7600: IFFALSE 7762
// begin D_MercHelp ;
7602: CALL 5048 0 0
// case Query ( QMerc ) of 1 :
7606: LD_STRING QMerc
7608: PPUSH
7609: CALL_OW 97
7613: PUSH
7614: LD_INT 1
7616: DOUBLE
7617: EQUAL
7618: IFTRUE 7622
7620: GO 7645
7622: POP
// begin D_QrMerc1 ;
7623: CALL 5124 0 0
// create_kurt ;
7627: CALL 3155 0 0
// MercAccepted := true ;
7631: LD_ADDR_EXP 44
7635: PUSH
7636: LD_INT 1
7638: ST_TO_ADDR
// come_to_build_barracks ;
7639: CALL 8235 0 0
// end ; 2 :
7643: GO 7754
7645: LD_INT 2
7647: DOUBLE
7648: EQUAL
7649: IFTRUE 7653
7651: GO 7684
7653: POP
// begin D_QrMerc2 ;
7654: CALL 5164 0 0
// PopovAsked := true ;
7658: LD_ADDR_EXP 46
7662: PUSH
7663: LD_INT 1
7665: ST_TO_ADDR
// create_kurt ;
7666: CALL 3155 0 0
// MercAccepted := true ;
7670: LD_ADDR_EXP 44
7674: PUSH
7675: LD_INT 1
7677: ST_TO_ADDR
// come_to_build_barracks ;
7678: CALL 8235 0 0
// end ; 3 :
7682: GO 7754
7684: LD_INT 3
7686: DOUBLE
7687: EQUAL
7688: IFTRUE 7692
7690: GO 7753
7692: POP
// begin D_QrMerc3 ;
7693: CALL 5216 0 0
// PopovAsked := true ;
7697: LD_ADDR_EXP 46
7701: PUSH
7702: LD_INT 1
7704: ST_TO_ADDR
// Wait ( 0 0$13 ) ;
7705: LD_INT 455
7707: PPUSH
7708: CALL_OW 67
// create_kurt ;
7712: CALL 3155 0 0
// ComMoveToArea ( [ Kurt , Mercenary1 ] , WaitHeikeArea ) ;
7716: LD_EXP 13
7720: PUSH
7721: LD_EXP 14
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PPUSH
7730: LD_INT 8
7732: PPUSH
7733: CALL_OW 113
// enable ( 6 ) ;
7737: LD_INT 6
7739: ENABLE_MARKED
// enable ( 20 ) ;
7740: LD_INT 20
7742: ENABLE_MARKED
// D_MercAttack ;
7743: CALL 5389 0 0
// merc_attack ;
7747: CALL 7767 0 0
// end ; end ;
7751: GO 7754
7753: POP
// MortarAsked := true ;
7754: LD_ADDR_EXP 69
7758: PUSH
7759: LD_INT 1
7761: ST_TO_ADDR
// end ; end ;
7762: LD_VAR 0 1
7766: RET
// export function merc_attack ; var grp , celkemgrp , rnd , pocet , mercenaries , filter ; begin
7767: LD_INT 0
7769: PPUSH
7770: PPUSH
7771: PPUSH
7772: PPUSH
7773: PPUSH
7774: PPUSH
7775: PPUSH
// repeat SetAttitude ( you , merc , att_enemy , true ) ;
7776: LD_EXP 31
7780: PPUSH
7781: LD_EXP 34
7785: PPUSH
7786: LD_INT 2
7788: PPUSH
7789: LD_INT 1
7791: PPUSH
7792: CALL_OW 80
// mercenaries := [ ] ;
7796: LD_ADDR_VAR 0 6
7800: PUSH
7801: EMPTY
7802: ST_TO_ADDR
// grp := Rand ( 1 , 6 ) ;
7803: LD_ADDR_VAR 0 2
7807: PUSH
7808: LD_INT 1
7810: PPUSH
7811: LD_INT 6
7813: PPUSH
7814: CALL_OW 12
7818: ST_TO_ADDR
// for pocet := 1 to grp do
7819: LD_ADDR_VAR 0 5
7823: PUSH
7824: DOUBLE
7825: LD_INT 1
7827: DEC
7828: ST_TO_ADDR
7829: LD_VAR 0 2
7833: PUSH
7834: FOR_TO
7835: IFFALSE 7958
// begin uc_side = merc ;
7837: LD_ADDR_OWVAR 20
7841: PUSH
7842: LD_EXP 34
7846: ST_TO_ADDR
// uc_nation := nation_arabian ;
7847: LD_ADDR_OWVAR 21
7851: PUSH
7852: LD_INT 2
7854: ST_TO_ADDR
// rnd := Rand ( 1 , 2 ) ;
7855: LD_ADDR_VAR 0 4
7859: PUSH
7860: LD_INT 1
7862: PPUSH
7863: LD_INT 2
7865: PPUSH
7866: CALL_OW 12
7870: ST_TO_ADDR
// case rnd of 1 :
7871: LD_VAR 0 4
7875: PUSH
7876: LD_INT 1
7878: DOUBLE
7879: EQUAL
7880: IFTRUE 7884
7882: GO 7900
7884: POP
// PrepareHuman ( sex_male , class_soldier , 2 ) ; 2 :
7885: LD_INT 1
7887: PPUSH
7888: LD_INT 1
7890: PPUSH
7891: LD_INT 2
7893: PPUSH
7894: CALL_OW 380
7898: GO 7925
7900: LD_INT 2
7902: DOUBLE
7903: EQUAL
7904: IFTRUE 7908
7906: GO 7924
7908: POP
// PrepareHuman ( sex_male , class_mortar , 2 ) ; end ;
7909: LD_INT 1
7911: PPUSH
7912: LD_INT 8
7914: PPUSH
7915: LD_INT 2
7917: PPUSH
7918: CALL_OW 380
7922: GO 7925
7924: POP
// hc_name :=  ;
7925: LD_ADDR_OWVAR 26
7929: PUSH
7930: LD_STRING 
7932: ST_TO_ADDR
// mercenaries := mercenaries ^ CreateHuman ;
7933: LD_ADDR_VAR 0 6
7937: PUSH
7938: LD_VAR 0 6
7942: PUSH
7943: CALL_OW 44
7947: ADD
7948: ST_TO_ADDR
// Wait ( 2 ) ;
7949: LD_INT 2
7951: PPUSH
7952: CALL_OW 67
// end ;
7956: GO 7834
7958: POP
7959: POP
// for pocet := 1 to grp do
7960: LD_ADDR_VAR 0 5
7964: PUSH
7965: DOUBLE
7966: LD_INT 1
7968: DEC
7969: ST_TO_ADDR
7970: LD_VAR 0 2
7974: PUSH
7975: FOR_TO
7976: IFFALSE 8053
// begin if HeikeDismissed then
7978: LD_EXP 45
7982: IFFALSE 7988
// exit ;
7984: POP
7985: POP
7986: GO 8230
// PlaceUnitArea ( mercenaries [ pocet ] , AttackArea , false ) ;
7988: LD_VAR 0 6
7992: PUSH
7993: LD_VAR 0 5
7997: ARRAY
7998: PPUSH
7999: LD_INT 5
8001: PPUSH
8002: LD_INT 0
8004: PPUSH
8005: CALL_OW 49
// ComAgressiveMove ( mercenaries [ pocet ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8009: LD_VAR 0 6
8013: PUSH
8014: LD_VAR 0 5
8018: ARRAY
8019: PPUSH
8020: LD_EXP 1
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_EXP 1
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: CALL_OW 114
// Wait ( 1 ) ;
8044: LD_INT 1
8046: PPUSH
8047: CALL_OW 67
// end ;
8051: GO 7975
8053: POP
8054: POP
// celkemgrp := celkemgrp + grp ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PUSH
8065: LD_VAR 0 2
8069: PLUS
8070: ST_TO_ADDR
// Wait ( 1 1$0 ) ;
8071: LD_INT 2100
8073: PPUSH
8074: CALL_OW 67
// until HeikeSend or celkemgrp > pocetmercenaries ;
8078: LD_EXP 65
8082: PUSH
8083: LD_VAR 0 3
8087: PUSH
8088: LD_EXP 78
8092: GREATER
8093: OR
8094: IFFALSE 7776
// repeat Wait ( 0 0$1 ) ;
8096: LD_INT 35
8098: PPUSH
8099: CALL_OW 67
// until HeikeDismissed or celkemgrp > pocetmercenaries ;
8103: LD_EXP 45
8107: PUSH
8108: LD_VAR 0 3
8112: PUSH
8113: LD_EXP 78
8117: GREATER
8118: OR
8119: IFFALSE 8096
// if HeikeDismissed then
8121: LD_EXP 45
8125: IFFALSE 8230
// begin SetAttitude ( you , merc , att_friend , true ) ;
8127: LD_EXP 31
8131: PPUSH
8132: LD_EXP 34
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_INT 1
8142: PPUSH
8143: CALL_OW 80
// filter := FilterAllUnits ( [ f_side , merc ] ) ;
8147: LD_ADDR_VAR 0 7
8151: PUSH
8152: LD_INT 22
8154: PUSH
8155: LD_EXP 34
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PPUSH
8164: CALL_OW 69
8168: ST_TO_ADDR
// ComAgressiveMove ( filter , 29 , 57 ) ;
8169: LD_VAR 0 7
8173: PPUSH
8174: LD_INT 29
8176: PPUSH
8177: LD_INT 57
8179: PPUSH
8180: CALL_OW 114
// enable ( 5 ) ;
8184: LD_INT 5
8186: ENABLE_MARKED
// repeat Wait ( 0 0$3 ) ;
8187: LD_INT 105
8189: PPUSH
8190: CALL_OW 67
// ComAgressiveMove ( filter , 29 , 57 ) ;
8194: LD_VAR 0 7
8198: PPUSH
8199: LD_INT 29
8201: PPUSH
8202: LD_INT 57
8204: PPUSH
8205: CALL_OW 114
// until FilterAllUnits ( [ f_side , merc ] ) = [ ] ;
8209: LD_INT 22
8211: PUSH
8212: LD_EXP 34
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PPUSH
8221: CALL_OW 69
8225: PUSH
8226: EMPTY
8227: EQUAL
8228: IFFALSE 8187
// end ; end ;
8230: LD_VAR 0 1
8234: RET
// function come_to_build_barracks ; var x , y , d , filter ; begin
8235: LD_INT 0
8237: PPUSH
8238: PPUSH
8239: PPUSH
8240: PPUSH
8241: PPUSH
// SetAttitude ( you , merc , att_neutral , true ) ;
8242: LD_EXP 31
8246: PPUSH
8247: LD_EXP 34
8251: PPUSH
8252: LD_INT 0
8254: PPUSH
8255: LD_INT 1
8257: PPUSH
8258: CALL_OW 80
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8262: LD_ADDR_VAR 0 5
8266: PUSH
8267: LD_INT 22
8269: PUSH
8270: LD_EXP 31
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 2
8281: PUSH
8282: LD_INT 30
8284: PUSH
8285: LD_INT 0
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: PUSH
8292: LD_INT 30
8294: PUSH
8295: LD_INT 1
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: LIST
8306: PUSH
8307: EMPTY
8308: LIST
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: PPUSH
8314: CALL_OW 69
8318: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8319: LD_INT 0
8321: PUSH
8322: LD_VAR 0 5
8326: PLUS
8327: PUSH
8328: LD_INT 0
8330: NONEQUAL
8331: IFFALSE 8392
// begin x := GetX ( filter [ 1 ] ) ;
8333: LD_ADDR_VAR 0 2
8337: PUSH
8338: LD_VAR 0 5
8342: PUSH
8343: LD_INT 1
8345: ARRAY
8346: PPUSH
8347: CALL_OW 250
8351: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8352: LD_ADDR_VAR 0 3
8356: PUSH
8357: LD_VAR 0 5
8361: PUSH
8362: LD_INT 1
8364: ARRAY
8365: PPUSH
8366: CALL_OW 251
8370: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8371: LD_ADDR_VAR 0 4
8375: PUSH
8376: LD_VAR 0 5
8380: PUSH
8381: LD_INT 1
8383: ARRAY
8384: PPUSH
8385: CALL_OW 254
8389: ST_TO_ADDR
// end else
8390: GO 8430
// begin x := GetX ( Burlak ) ;
8392: LD_ADDR_VAR 0 2
8396: PUSH
8397: LD_EXP 1
8401: PPUSH
8402: CALL_OW 250
8406: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8407: LD_ADDR_VAR 0 3
8411: PUSH
8412: LD_EXP 1
8416: PPUSH
8417: CALL_OW 251
8421: ST_TO_ADDR
// d := 1 ;
8422: LD_ADDR_VAR 0 4
8426: PUSH
8427: LD_INT 1
8429: ST_TO_ADDR
// end ; ComMoveXY ( [ Kurt , Mercenary1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8430: LD_EXP 13
8434: PUSH
8435: LD_EXP 14
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: PPUSH
8444: LD_VAR 0 2
8448: PPUSH
8449: LD_VAR 0 4
8453: PPUSH
8454: LD_INT 5
8456: PPUSH
8457: CALL_OW 272
8461: PPUSH
8462: LD_VAR 0 3
8466: PPUSH
8467: LD_VAR 0 4
8471: PPUSH
8472: LD_INT 5
8474: PPUSH
8475: CALL_OW 273
8479: PPUSH
8480: CALL_OW 111
// enable ( 1 ) ;
8484: LD_INT 1
8486: ENABLE_MARKED
// end ;
8487: LD_VAR 0 1
8491: RET
// export function hand_over ; var i , filter , auto , x , y , d ; begin
8492: LD_INT 0
8494: PPUSH
8495: PPUSH
8496: PPUSH
8497: PPUSH
8498: PPUSH
8499: PPUSH
8500: PPUSH
// SetAttitude ( arab , merc , att_enemy , true ) ;
8501: LD_EXP 33
8505: PPUSH
8506: LD_EXP 34
8510: PPUSH
8511: LD_INT 2
8513: PPUSH
8514: LD_INT 1
8516: PPUSH
8517: CALL_OW 80
// SetAttitude ( arab , you , att_friend , true ) ;
8521: LD_EXP 33
8525: PPUSH
8526: LD_EXP 31
8530: PPUSH
8531: LD_INT 1
8533: PPUSH
8534: LD_INT 1
8536: PPUSH
8537: CALL_OW 80
// auto := [ ] ;
8541: LD_ADDR_VAR 0 4
8545: PUSH
8546: EMPTY
8547: ST_TO_ADDR
// ar_human := [ ] ;
8548: LD_ADDR_EXP 80
8552: PUSH
8553: EMPTY
8554: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8555: LD_ADDR_VAR 0 3
8559: PUSH
8560: LD_INT 22
8562: PUSH
8563: LD_EXP 31
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: PUSH
8572: LD_INT 2
8574: PUSH
8575: LD_INT 30
8577: PUSH
8578: LD_INT 0
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: PUSH
8585: LD_INT 30
8587: PUSH
8588: LD_INT 1
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PUSH
8595: EMPTY
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: EMPTY
8601: LIST
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PPUSH
8607: CALL_OW 69
8611: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8612: LD_INT 0
8614: PUSH
8615: LD_VAR 0 3
8619: PLUS
8620: PUSH
8621: LD_INT 0
8623: NONEQUAL
8624: IFFALSE 8685
// begin x := GetX ( filter [ 1 ] ) ;
8626: LD_ADDR_VAR 0 5
8630: PUSH
8631: LD_VAR 0 3
8635: PUSH
8636: LD_INT 1
8638: ARRAY
8639: PPUSH
8640: CALL_OW 250
8644: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8645: LD_ADDR_VAR 0 6
8649: PUSH
8650: LD_VAR 0 3
8654: PUSH
8655: LD_INT 1
8657: ARRAY
8658: PPUSH
8659: CALL_OW 251
8663: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8664: LD_ADDR_VAR 0 7
8668: PUSH
8669: LD_VAR 0 3
8673: PUSH
8674: LD_INT 1
8676: ARRAY
8677: PPUSH
8678: CALL_OW 254
8682: ST_TO_ADDR
// end else
8683: GO 8723
// begin x := GetX ( Burlak ) ;
8685: LD_ADDR_VAR 0 5
8689: PUSH
8690: LD_EXP 1
8694: PPUSH
8695: CALL_OW 250
8699: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8700: LD_ADDR_VAR 0 6
8704: PUSH
8705: LD_EXP 1
8709: PPUSH
8710: CALL_OW 251
8714: ST_TO_ADDR
// d := 1 ;
8715: LD_ADDR_VAR 0 7
8719: PUSH
8720: LD_INT 1
8722: ST_TO_ADDR
// end ; enable ( 7 ) ;
8723: LD_INT 7
8725: ENABLE_MARKED
// for i := 1 to 3 do
8726: LD_ADDR_VAR 0 2
8730: PUSH
8731: DOUBLE
8732: LD_INT 1
8734: DEC
8735: ST_TO_ADDR
8736: LD_INT 3
8738: PUSH
8739: FOR_TO
8740: IFFALSE 9305
// begin uc_side := arab ;
8742: LD_ADDR_OWVAR 20
8746: PUSH
8747: LD_EXP 33
8751: ST_TO_ADDR
// uc_nation := nation_arabian ;
8752: LD_ADDR_OWVAR 21
8756: PUSH
8757: LD_INT 2
8759: ST_TO_ADDR
// uc_direction := 3 ;
8760: LD_ADDR_OWVAR 24
8764: PUSH
8765: LD_INT 3
8767: ST_TO_ADDR
// if i <= 2 then
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 2
8775: LESSEQUAL
8776: IFFALSE 8793
// PrepareHuman ( sex_male , class_soldier , 7 ) else
8778: LD_INT 1
8780: PPUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 7
8786: PPUSH
8787: CALL_OW 380
8791: GO 8806
// PrepareHuman ( sex_male , class_scientistic , 7 ) ;
8793: LD_INT 1
8795: PPUSH
8796: LD_INT 4
8798: PPUSH
8799: LD_INT 7
8801: PPUSH
8802: CALL_OW 380
// Wait ( 1 ) ;
8806: LD_INT 1
8808: PPUSH
8809: CALL_OW 67
// hc_name :=  ;
8813: LD_ADDR_OWVAR 26
8817: PUSH
8818: LD_STRING 
8820: ST_TO_ADDR
// ar_human := ar_human ^ CreateHuman ;
8821: LD_ADDR_EXP 80
8825: PUSH
8826: LD_EXP 80
8830: PUSH
8831: CALL_OW 44
8835: ADD
8836: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
8837: LD_ADDR_OWVAR 37
8841: PUSH
8842: LD_INT 13
8844: ST_TO_ADDR
// vc_engine := engine_combustion ;
8845: LD_ADDR_OWVAR 39
8849: PUSH
8850: LD_INT 1
8852: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
8853: LD_ADDR_OWVAR 40
8857: PUSH
8858: LD_INT 32
8860: ST_TO_ADDR
// vc_control := control_manual ;
8861: LD_ADDR_OWVAR 38
8865: PUSH
8866: LD_INT 1
8868: ST_TO_ADDR
// auto := auto ^ CreateVehicle ;
8869: LD_ADDR_VAR 0 4
8873: PUSH
8874: LD_VAR 0 4
8878: PUSH
8879: CALL_OW 45
8883: ADD
8884: ST_TO_ADDR
// PlaceHumanInUnit ( ar_human [ i ] , auto [ i ] ) ;
8885: LD_EXP 80
8889: PUSH
8890: LD_VAR 0 2
8894: ARRAY
8895: PPUSH
8896: LD_VAR 0 4
8900: PUSH
8901: LD_VAR 0 2
8905: ARRAY
8906: PPUSH
8907: CALL_OW 52
// PlaceUnitArea ( auto [ i ] , HandOverEnterArea , false ) ;
8911: LD_VAR 0 4
8915: PUSH
8916: LD_VAR 0 2
8920: ARRAY
8921: PPUSH
8922: LD_INT 6
8924: PPUSH
8925: LD_INT 0
8927: PPUSH
8928: CALL_OW 49
// enable ( 6 ) ;
8932: LD_INT 6
8934: ENABLE_MARKED
// case i of 1 :
8935: LD_VAR 0 2
8939: PUSH
8940: LD_INT 1
8942: DOUBLE
8943: EQUAL
8944: IFTRUE 8948
8946: GO 9039
8948: POP
// begin SetCargo ( auto [ 1 ] , mat_cans , 100 ) ;
8949: LD_VAR 0 4
8953: PUSH
8954: LD_INT 1
8956: ARRAY
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: LD_INT 100
8963: PPUSH
8964: CALL_OW 290
// ComMoveXY ( auto [ 1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8968: LD_VAR 0 4
8972: PUSH
8973: LD_INT 1
8975: ARRAY
8976: PPUSH
8977: LD_VAR 0 5
8981: PPUSH
8982: LD_VAR 0 7
8986: PPUSH
8987: LD_INT 5
8989: PPUSH
8990: CALL_OW 272
8994: PPUSH
8995: LD_VAR 0 6
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: LD_INT 5
9007: PPUSH
9008: CALL_OW 273
9012: PPUSH
9013: CALL_OW 111
// Wait ( 1 ) ;
9017: LD_INT 1
9019: PPUSH
9020: CALL_OW 67
// AddComExitVehicle ( auto [ 1 ] ) ;
9024: LD_VAR 0 4
9028: PUSH
9029: LD_INT 1
9031: ARRAY
9032: PPUSH
9033: CALL_OW 181
// end ; 2 :
9037: GO 9296
9039: LD_INT 2
9041: DOUBLE
9042: EQUAL
9043: IFTRUE 9047
9045: GO 9167
9047: POP
// begin SetCargo ( auto [ 2 ] , mat_oil , 100 ) ;
9048: LD_VAR 0 4
9052: PUSH
9053: LD_INT 2
9055: ARRAY
9056: PPUSH
9057: LD_INT 2
9059: PPUSH
9060: LD_INT 100
9062: PPUSH
9063: CALL_OW 290
// ComMoveXY ( auto [ 2 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9067: LD_VAR 0 4
9071: PUSH
9072: LD_INT 2
9074: ARRAY
9075: PPUSH
9076: LD_VAR 0 5
9080: PPUSH
9081: LD_VAR 0 7
9085: PPUSH
9086: LD_INT 5
9088: PPUSH
9089: CALL_OW 272
9093: PPUSH
9094: LD_VAR 0 6
9098: PPUSH
9099: LD_VAR 0 7
9103: PPUSH
9104: LD_INT 5
9106: PPUSH
9107: CALL_OW 273
9111: PPUSH
9112: CALL_OW 111
// Wait ( 1 ) ;
9116: LD_INT 1
9118: PPUSH
9119: CALL_OW 67
// AddComExitVehicle ( auto [ 2 ] ) ;
9123: LD_VAR 0 4
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PPUSH
9132: CALL_OW 181
// Wait ( 1 ) ;
9136: LD_INT 1
9138: PPUSH
9139: CALL_OW 67
// AddComMoveUnit ( auto [ 2 ] , auto [ 1 ] ) ;
9143: LD_VAR 0 4
9147: PUSH
9148: LD_INT 2
9150: ARRAY
9151: PPUSH
9152: LD_VAR 0 4
9156: PUSH
9157: LD_INT 1
9159: ARRAY
9160: PPUSH
9161: CALL_OW 172
// end ; 3 :
9165: GO 9296
9167: LD_INT 3
9169: DOUBLE
9170: EQUAL
9171: IFTRUE 9175
9173: GO 9295
9175: POP
// begin SetCargo ( auto [ 3 ] , mat_siberit , 100 ) ;
9176: LD_VAR 0 4
9180: PUSH
9181: LD_INT 3
9183: ARRAY
9184: PPUSH
9185: LD_INT 3
9187: PPUSH
9188: LD_INT 100
9190: PPUSH
9191: CALL_OW 290
// ComMoveXY ( auto [ 3 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9195: LD_VAR 0 4
9199: PUSH
9200: LD_INT 3
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 5
9208: PPUSH
9209: LD_VAR 0 7
9213: PPUSH
9214: LD_INT 5
9216: PPUSH
9217: CALL_OW 272
9221: PPUSH
9222: LD_VAR 0 6
9226: PPUSH
9227: LD_VAR 0 7
9231: PPUSH
9232: LD_INT 5
9234: PPUSH
9235: CALL_OW 273
9239: PPUSH
9240: CALL_OW 111
// Wait ( 1 ) ;
9244: LD_INT 1
9246: PPUSH
9247: CALL_OW 67
// AddComExitVehicle ( auto [ 3 ] ) ;
9251: LD_VAR 0 4
9255: PUSH
9256: LD_INT 3
9258: ARRAY
9259: PPUSH
9260: CALL_OW 181
// Wait ( 1 ) ;
9264: LD_INT 1
9266: PPUSH
9267: CALL_OW 67
// AddComMoveUnit ( auto [ 3 ] , auto [ 1 ] ) ;
9271: LD_VAR 0 4
9275: PUSH
9276: LD_INT 3
9278: ARRAY
9279: PPUSH
9280: LD_VAR 0 4
9284: PUSH
9285: LD_INT 1
9287: ARRAY
9288: PPUSH
9289: CALL_OW 172
// end ; end ;
9293: GO 9296
9295: POP
// Wait ( 0 0$3 ) ;
9296: LD_INT 105
9298: PPUSH
9299: CALL_OW 67
// end ;
9303: GO 8739
9305: POP
9306: POP
// MercHandoverArabsSpawned = true ;
9307: LD_ADDR_EXP 43
9311: PUSH
9312: LD_INT 1
9314: ST_TO_ADDR
// enable ( 9 ) ;
9315: LD_INT 9
9317: ENABLE_MARKED
// end ;
9318: LD_VAR 0 1
9322: RET
// every 0 0$1 + 0 0$0.5 do var filter ;
9323: GO 9325
9325: DISABLE
9326: LD_INT 0
9328: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
9329: LD_ADDR_VAR 0 1
9333: PUSH
9334: LD_INT 22
9336: PUSH
9337: LD_EXP 31
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 2
9348: PUSH
9349: LD_INT 30
9351: PUSH
9352: LD_INT 0
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PUSH
9359: LD_INT 30
9361: PUSH
9362: LD_INT 1
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: LIST
9373: PUSH
9374: EMPTY
9375: LIST
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: PPUSH
9381: CALL_OW 69
9385: ST_TO_ADDR
// if filter then
9386: LD_VAR 0 1
9390: IFFALSE 9404
// SetBName ( filter , trockij ) ;
9392: LD_VAR 0 1
9396: PPUSH
9397: LD_STRING trockij
9399: PPUSH
9400: CALL_OW 500
// enable ;
9404: ENABLE
// end ;
9405: PPOPN 1
9407: END
// var crates_amount , crates_creating ; every 1 1$30 do
9408: GO 9410
9410: DISABLE
// begin crates_amount := GetResourceArea ( TreesArea , mat_cans ) ;
9411: LD_ADDR_LOC 1
9415: PUSH
9416: LD_INT 1
9418: PPUSH
9419: LD_INT 1
9421: PPUSH
9422: CALL_OW 287
9426: ST_TO_ADDR
// if crates_amount >= 80 then
9427: LD_LOC 1
9431: PUSH
9432: LD_INT 80
9434: GREATEREQUAL
9435: IFFALSE 9445
// crates_creating := false ;
9437: LD_ADDR_LOC 2
9441: PUSH
9442: LD_INT 0
9444: ST_TO_ADDR
// if crates_amount <= 30 then
9445: LD_LOC 1
9449: PUSH
9450: LD_INT 30
9452: LESSEQUAL
9453: IFFALSE 9463
// crates_creating := true ;
9455: LD_ADDR_LOC 2
9459: PUSH
9460: LD_INT 1
9462: ST_TO_ADDR
// if crates_creating then
9463: LD_LOC 2
9467: IFFALSE 9490
// CreateCratesArea ( Rand ( 3 , 5 ) , TreesArea , true ) ;
9469: LD_INT 3
9471: PPUSH
9472: LD_INT 5
9474: PPUSH
9475: CALL_OW 12
9479: PPUSH
9480: LD_INT 1
9482: PPUSH
9483: LD_INT 1
9485: PPUSH
9486: CALL_OW 55
// enable ;
9490: ENABLE
// end ;
9491: END
// var NonBuildBuildings , NonBuildWeapons ; every 0 0$3 do var filter , filter_tur , un , filter_weap , budova , NonBuild ;
9492: GO 9494
9494: DISABLE
9495: LD_INT 0
9497: PPUSH
9498: PPUSH
9499: PPUSH
9500: PPUSH
9501: PPUSH
9502: PPUSH
// begin NonBuild := AvailableBuildings ;
9503: LD_ADDR_VAR 0 6
9507: PUSH
9508: LD_EXP 55
9512: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] , [ f_ready ] ] ) ;
9513: LD_ADDR_VAR 0 1
9517: PUSH
9518: LD_INT 21
9520: PUSH
9521: LD_INT 3
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 22
9530: PUSH
9531: LD_EXP 31
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 53
9542: PUSH
9543: EMPTY
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: PPUSH
9551: CALL_OW 69
9555: ST_TO_ADDR
// TurretsDone := false ;
9556: LD_ADDR_EXP 49
9560: PUSH
9561: LD_INT 0
9563: ST_TO_ADDR
// filter_tur := FilterAllUnits ( [ [ f_btype , b_turret ] , [ f_side , you ] , [ f_ready ] ] ) ;
9564: LD_ADDR_VAR 0 2
9568: PUSH
9569: LD_INT 30
9571: PUSH
9572: LD_INT 33
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PUSH
9579: LD_INT 22
9581: PUSH
9582: LD_EXP 31
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: LD_INT 53
9593: PUSH
9594: EMPTY
9595: LIST
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: PPUSH
9602: CALL_OW 69
9606: ST_TO_ADDR
// filter_weap := [ ] ;
9607: LD_ADDR_VAR 0 4
9611: PUSH
9612: EMPTY
9613: ST_TO_ADDR
// for un in filter_tur do
9614: LD_ADDR_VAR 0 3
9618: PUSH
9619: LD_VAR 0 2
9623: PUSH
9624: FOR_IN
9625: IFFALSE 9657
// begin filter_weap := filter_weap union GetBWeapon ( un ) ;
9627: LD_ADDR_VAR 0 4
9631: PUSH
9632: LD_VAR 0 4
9636: PUSH
9637: LD_VAR 0 3
9641: PPUSH
9642: CALL_OW 269
9646: UNION
9647: ST_TO_ADDR
// Wait ( 2 ) ;
9648: LD_INT 2
9650: PPUSH
9651: CALL_OW 67
// end ;
9655: GO 9624
9657: POP
9658: POP
// if ( filter_weap diff 0 ) >= 3 then
9659: LD_VAR 0 4
9663: PUSH
9664: LD_INT 0
9666: DIFF
9667: PUSH
9668: LD_INT 3
9670: GREATEREQUAL
9671: IFFALSE 9681
// TurretsDone := true ;
9673: LD_ADDR_EXP 49
9677: PUSH
9678: LD_INT 1
9680: ST_TO_ADDR
// for budova in filter do
9681: LD_ADDR_VAR 0 5
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: FOR_IN
9692: IFFALSE 9724
// begin NonBuild := NonBuild diff GetBType ( budova ) ;
9694: LD_ADDR_VAR 0 6
9698: PUSH
9699: LD_VAR 0 6
9703: PUSH
9704: LD_VAR 0 5
9708: PPUSH
9709: CALL_OW 266
9713: DIFF
9714: ST_TO_ADDR
// Wait ( 1 ) ;
9715: LD_INT 1
9717: PPUSH
9718: CALL_OW 67
// end ;
9722: GO 9691
9724: POP
9725: POP
// if NonBuild = [ ] and TurretsDone and not BuildingsDone then
9726: LD_VAR 0 6
9730: PUSH
9731: EMPTY
9732: EQUAL
9733: PUSH
9734: LD_EXP 49
9738: AND
9739: PUSH
9740: LD_EXP 48
9744: NOT
9745: AND
9746: IFFALSE 9765
// begin ChangeMissionObjectives ( MBuildingsDone ) ;
9748: LD_STRING MBuildingsDone
9750: PPUSH
9751: CALL_OW 337
// BuildingsDone := true ;
9755: LD_ADDR_EXP 48
9759: PUSH
9760: LD_INT 1
9762: ST_TO_ADDR
// end else
9763: GO 9802
// if ( NonBuild <> [ ] or not TurretsDone ) and BuildingsDone then
9765: LD_VAR 0 6
9769: PUSH
9770: EMPTY
9771: NONEQUAL
9772: PUSH
9773: LD_EXP 49
9777: NOT
9778: OR
9779: PUSH
9780: LD_EXP 48
9784: AND
9785: IFFALSE 9802
// begin ChangeMissionObjectives ( MBuildings ) ;
9787: LD_STRING MBuildings
9789: PPUSH
9790: CALL_OW 337
// BuildingsDone := false ;
9794: LD_ADDR_EXP 48
9798: PUSH
9799: LD_INT 0
9801: ST_TO_ADDR
// end ; if not ( ( filter_weap diff 0 ) > 3 ) then
9802: LD_VAR 0 4
9806: PUSH
9807: LD_INT 0
9809: DIFF
9810: PUSH
9811: LD_INT 3
9813: GREATER
9814: NOT
9815: IFFALSE 9841
// NonBuild := NonBuild + 3 - ( filter_weap diff 0 ) ;
9817: LD_ADDR_VAR 0 6
9821: PUSH
9822: LD_VAR 0 6
9826: PUSH
9827: LD_INT 3
9829: PLUS
9830: PUSH
9831: LD_VAR 0 4
9835: PUSH
9836: LD_INT 0
9838: DIFF
9839: MINUS
9840: ST_TO_ADDR
// NonBuildBuildings := NonBuild ;
9841: LD_ADDR_LOC 3
9845: PUSH
9846: LD_VAR 0 6
9850: ST_TO_ADDR
// if HeikeCratesTime then
9851: LD_LOC 5
9855: IFFALSE 9918
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
9857: LD_ADDR_OWVAR 47
9861: PUSH
9862: LD_STRING #Ru08-1
9864: PUSH
9865: LD_INT 0
9867: PUSH
9868: LD_LOC 3
9872: PLUS
9873: PUSH
9874: LD_STRING #Ru08-2
9876: PUSH
9877: LD_INT 0
9879: PUSH
9880: LD_LOC 4
9884: PLUS
9885: PUSH
9886: LD_STRING #Ru08-3
9888: PUSH
9889: LD_INT 0
9891: PUSH
9892: LD_EXP 56
9896: PLUS
9897: PUSH
9898: LD_STRING #Ru08-4
9900: PUSH
9901: LD_LOC 5
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: ST_TO_ADDR
9916: GO 9967
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
9918: LD_ADDR_OWVAR 47
9922: PUSH
9923: LD_STRING #Ru08-1
9925: PUSH
9926: LD_INT 0
9928: PUSH
9929: LD_LOC 3
9933: PLUS
9934: PUSH
9935: LD_STRING #Ru08-2
9937: PUSH
9938: LD_INT 0
9940: PUSH
9941: LD_LOC 4
9945: PLUS
9946: PUSH
9947: LD_STRING #Ru08-3
9949: PUSH
9950: LD_INT 0
9952: PUSH
9953: LD_EXP 56
9957: PLUS
9958: PUSH
9959: EMPTY
9960: LIST
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: ST_TO_ADDR
// if NonBuild + 0 = 11 and not GalleryAsked then
9967: LD_VAR 0 6
9971: PUSH
9972: LD_INT 0
9974: PLUS
9975: PUSH
9976: LD_INT 11
9978: EQUAL
9979: PUSH
9980: LD_EXP 66
9984: NOT
9985: AND
9986: IFFALSE 9991
// enable ( 201 ) ;
9988: LD_INT 201
9990: ENABLE_MARKED
// if NonBuild + 0 = 7 and not HuntingAsked then
9991: LD_VAR 0 6
9995: PUSH
9996: LD_INT 0
9998: PLUS
9999: PUSH
10000: LD_INT 7
10002: EQUAL
10003: PUSH
10004: LD_EXP 67
10008: NOT
10009: AND
10010: IFFALSE 10015
// enable ( 101 ) ;
10012: LD_INT 101
10014: ENABLE_MARKED
// if NonBuild + 0 = 3 and not FreetimeAsked then
10015: LD_VAR 0 6
10019: PUSH
10020: LD_INT 0
10022: PLUS
10023: PUSH
10024: LD_INT 3
10026: EQUAL
10027: PUSH
10028: LD_EXP 68
10032: NOT
10033: AND
10034: IFFALSE 10039
// enable ( 301 ) ;
10036: LD_INT 301
10038: ENABLE_MARKED
// enable ;
10039: ENABLE
// end ;
10040: PPOPN 6
10042: END
// every 0 0$3 + 0 0$0.5 do var filter , veh , NonBuild ;
10043: GO 10045
10045: DISABLE
10046: LD_INT 0
10048: PPUSH
10049: PPUSH
10050: PPUSH
// begin NonBuild := AvailableWeapons ;
10051: LD_ADDR_VAR 0 3
10055: PUSH
10056: LD_EXP 54
10060: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10061: LD_ADDR_VAR 0 1
10065: PUSH
10066: LD_INT 21
10068: PUSH
10069: LD_INT 2
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PUSH
10076: LD_INT 22
10078: PUSH
10079: LD_EXP 31
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PPUSH
10092: CALL_OW 69
10096: ST_TO_ADDR
// for veh in filter do
10097: LD_ADDR_VAR 0 2
10101: PUSH
10102: LD_VAR 0 1
10106: PUSH
10107: FOR_IN
10108: IFFALSE 10140
// begin NonBuild := NonBuild diff GetWeapon ( veh ) ;
10110: LD_ADDR_VAR 0 3
10114: PUSH
10115: LD_VAR 0 3
10119: PUSH
10120: LD_VAR 0 2
10124: PPUSH
10125: CALL_OW 264
10129: DIFF
10130: ST_TO_ADDR
// Wait ( 1 ) ;
10131: LD_INT 1
10133: PPUSH
10134: CALL_OW 67
// end ;
10138: GO 10107
10140: POP
10141: POP
// if NonBuild = [ ] and not WeaponsDone then
10142: LD_VAR 0 3
10146: PUSH
10147: EMPTY
10148: EQUAL
10149: PUSH
10150: LD_EXP 50
10154: NOT
10155: AND
10156: IFFALSE 10175
// begin ChangeMissionObjectives ( MWeaponsDone ) ;
10158: LD_STRING MWeaponsDone
10160: PPUSH
10161: CALL_OW 337
// WeaponsDone := true ;
10165: LD_ADDR_EXP 50
10169: PUSH
10170: LD_INT 1
10172: ST_TO_ADDR
// end else
10173: GO 10205
// if NonBuild <> [ ] and WeaponsDone then
10175: LD_VAR 0 3
10179: PUSH
10180: EMPTY
10181: NONEQUAL
10182: PUSH
10183: LD_EXP 50
10187: AND
10188: IFFALSE 10205
// begin ChangeMissionObjectives ( Mweapons ) ;
10190: LD_STRING Mweapons
10192: PPUSH
10193: CALL_OW 337
// WeaponsDone := false ;
10197: LD_ADDR_EXP 50
10201: PUSH
10202: LD_INT 0
10204: ST_TO_ADDR
// end ; NonBuildWeapons := NonBuild ;
10205: LD_ADDR_LOC 4
10209: PUSH
10210: LD_VAR 0 3
10214: ST_TO_ADDR
// if HeikeCratesTime then
10215: LD_LOC 5
10219: IFFALSE 10282
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
10221: LD_ADDR_OWVAR 47
10225: PUSH
10226: LD_STRING #Ru08-1
10228: PUSH
10229: LD_INT 0
10231: PUSH
10232: LD_LOC 3
10236: PLUS
10237: PUSH
10238: LD_STRING #Ru08-2
10240: PUSH
10241: LD_INT 0
10243: PUSH
10244: LD_LOC 4
10248: PLUS
10249: PUSH
10250: LD_STRING #Ru08-3
10252: PUSH
10253: LD_INT 0
10255: PUSH
10256: LD_EXP 56
10260: PLUS
10261: PUSH
10262: LD_STRING #Ru08-4
10264: PUSH
10265: LD_LOC 5
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: ST_TO_ADDR
10280: GO 10331
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
10282: LD_ADDR_OWVAR 47
10286: PUSH
10287: LD_STRING #Ru08-1
10289: PUSH
10290: LD_INT 0
10292: PUSH
10293: LD_LOC 3
10297: PLUS
10298: PUSH
10299: LD_STRING #Ru08-2
10301: PUSH
10302: LD_INT 0
10304: PUSH
10305: LD_LOC 4
10309: PLUS
10310: PUSH
10311: LD_STRING #Ru08-3
10313: PUSH
10314: LD_INT 0
10316: PUSH
10317: LD_EXP 56
10321: PLUS
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: ST_TO_ADDR
// enable ;
10331: ENABLE
// end ;
10332: PPOPN 3
10334: END
// every 0 0$2 marked 1 do var filter ;
10335: GO 10337
10337: DISABLE
10338: LD_INT 0
10340: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
10341: LD_ADDR_VAR 0 1
10345: PUSH
10346: LD_INT 22
10348: PUSH
10349: LD_EXP 31
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: PUSH
10358: LD_INT 2
10360: PUSH
10361: LD_INT 30
10363: PUSH
10364: LD_INT 0
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PUSH
10371: LD_INT 30
10373: PUSH
10374: LD_INT 1
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: EMPTY
10387: LIST
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PPUSH
10393: CALL_OW 69
10397: ST_TO_ADDR
// if ( 0 + filter ) = 0 then
10398: LD_INT 0
10400: PUSH
10401: LD_VAR 0 1
10405: PLUS
10406: PUSH
10407: LD_INT 0
10409: EQUAL
10410: IFFALSE 10428
// filter := filter union Burlak ;
10412: LD_ADDR_VAR 0 1
10416: PUSH
10417: LD_VAR 0 1
10421: PUSH
10422: LD_EXP 1
10426: UNION
10427: ST_TO_ADDR
// if ( GetDistUnits ( Kurt , filter [ 1 ] ) < 8 ) or ( GetDistUnits ( Mercenary1 , filter [ 1 ] ) < 8 ) then
10428: LD_EXP 13
10432: PPUSH
10433: LD_VAR 0 1
10437: PUSH
10438: LD_INT 1
10440: ARRAY
10441: PPUSH
10442: CALL_OW 296
10446: PUSH
10447: LD_INT 8
10449: LESS
10450: PUSH
10451: LD_EXP 14
10455: PPUSH
10456: LD_VAR 0 1
10460: PUSH
10461: LD_INT 1
10463: ARRAY
10464: PPUSH
10465: CALL_OW 296
10469: PUSH
10470: LD_INT 8
10472: LESS
10473: OR
10474: IFFALSE 10505
// begin SetSide ( [ Kurt , Mercenary1 ] , you ) ;
10476: LD_EXP 13
10480: PUSH
10481: LD_EXP 14
10485: PUSH
10486: EMPTY
10487: LIST
10488: LIST
10489: PPUSH
10490: LD_EXP 31
10494: PPUSH
10495: CALL_OW 235
// enable ( 10 ) ;
10499: LD_INT 10
10501: ENABLE_MARKED
// enable ( 601 ) ;
10502: LD_INT 601
10504: ENABLE_MARKED
// end ; if GetSide ( Kurt ) = you and GetSide ( Mercenary1 ) = you then
10505: LD_EXP 13
10509: PPUSH
10510: CALL_OW 255
10514: PUSH
10515: LD_EXP 31
10519: EQUAL
10520: PUSH
10521: LD_EXP 14
10525: PPUSH
10526: CALL_OW 255
10530: PUSH
10531: LD_EXP 31
10535: EQUAL
10536: AND
10537: IFFALSE 10542
// disable else
10539: DISABLE
10540: GO 10543
// enable ;
10542: ENABLE
// end ;
10543: PPOPN 1
10545: END
// every 0 0$1 + 0 0$0.2 marked 2 do var list ;
10546: GO 10548
10548: DISABLE
10549: LD_INT 0
10551: PPUSH
// begin list = [ false , false ] ;
10552: LD_ADDR_VAR 0 1
10556: PUSH
10557: LD_INT 0
10559: PUSH
10560: LD_INT 0
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: ST_TO_ADDR
// if IsLive ( Kurt ) and UnitShoot ( Kurt ) > 0 then
10567: LD_EXP 13
10571: PPUSH
10572: CALL_OW 300
10576: PUSH
10577: LD_EXP 13
10581: PPUSH
10582: CALL_OW 504
10586: PUSH
10587: LD_INT 0
10589: GREATER
10590: AND
10591: IFFALSE 10636
// if GetSide ( UnitShoot ( Kurt ) ) = you then
10593: LD_EXP 13
10597: PPUSH
10598: CALL_OW 504
10602: PPUSH
10603: CALL_OW 255
10607: PUSH
10608: LD_EXP 31
10612: EQUAL
10613: IFFALSE 10636
// list = Replace ( list , 1 , true ) ;
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 1
10624: PPUSH
10625: LD_INT 1
10627: PPUSH
10628: LD_INT 1
10630: PPUSH
10631: CALL_OW 1
10635: ST_TO_ADDR
// if IsLive ( Mercenary1 ) and UnitShoot ( Mercenary1 ) > 0 then
10636: LD_EXP 14
10640: PPUSH
10641: CALL_OW 300
10645: PUSH
10646: LD_EXP 14
10650: PPUSH
10651: CALL_OW 504
10655: PUSH
10656: LD_INT 0
10658: GREATER
10659: AND
10660: IFFALSE 10705
// if GetSide ( UnitShoot ( Mercenary1 ) ) = you then
10662: LD_EXP 14
10666: PPUSH
10667: CALL_OW 504
10671: PPUSH
10672: CALL_OW 255
10676: PUSH
10677: LD_EXP 31
10681: EQUAL
10682: IFFALSE 10705
// list = Replace ( list , 2 , true ) ;
10684: LD_ADDR_VAR 0 1
10688: PUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 2
10696: PPUSH
10697: LD_INT 1
10699: PPUSH
10700: CALL_OW 1
10704: ST_TO_ADDR
// if true in list then
10705: LD_INT 1
10707: PUSH
10708: LD_VAR 0 1
10712: IN
10713: IFFALSE 10804
// begin disable ( 601 ) ;
10715: LD_INT 601
10717: DISABLE_MARKED
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
10718: LD_EXP 13
10722: PUSH
10723: LD_EXP 14
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PPUSH
10732: LD_EXP 34
10736: PPUSH
10737: CALL_OW 235
// SetAttitude ( you , merc , att_enemy , true ) ;
10741: LD_EXP 31
10745: PPUSH
10746: LD_EXP 34
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_INT 1
10756: PPUSH
10757: CALL_OW 80
// D_MercAmbush ;
10761: CALL 5336 0 0
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , 27 , 52 ) ;
10765: LD_EXP 13
10769: PUSH
10770: LD_EXP 14
10774: PUSH
10775: EMPTY
10776: LIST
10777: LIST
10778: PPUSH
10779: LD_INT 27
10781: PPUSH
10782: LD_INT 52
10784: PPUSH
10785: CALL_OW 114
// enable ( 23 ) ;
10789: LD_INT 23
10791: ENABLE_MARKED
// merc_attack ;
10792: CALL 7767 0 0
// disabled2 := true ;
10796: LD_ADDR_EXP 86
10800: PUSH
10801: LD_INT 1
10803: ST_TO_ADDR
// end ; if not disabled2 then
10804: LD_EXP 86
10808: NOT
10809: IFFALSE 10812
// enable ;
10811: ENABLE
// end ;
10812: PPOPN 1
10814: END
// every 0 0$10 marked 3 do
10815: GO 10817
10817: DISABLE
// begin countdown := countdown - 10 * 35 ;
10818: LD_ADDR_EXP 77
10822: PUSH
10823: LD_EXP 77
10827: PUSH
10828: LD_INT 10
10830: PUSH
10831: LD_INT 35
10833: MUL
10834: MINUS
10835: ST_TO_ADDR
// if countdown < 0 and not HeikeDismissed then
10836: LD_EXP 77
10840: PUSH
10841: LD_INT 0
10843: LESS
10844: PUSH
10845: LD_EXP 45
10849: NOT
10850: AND
10851: IFFALSE 10868
// begin disabled3 := true ;
10853: LD_ADDR_EXP 87
10857: PUSH
10858: LD_INT 1
10860: ST_TO_ADDR
// enable ( 24 ) ;
10861: LD_INT 24
10863: ENABLE_MARKED
// merc_attack ;
10864: CALL 7767 0 0
// end ; if not disabled3 then
10868: LD_EXP 87
10872: NOT
10873: IFFALSE 10876
// enable ;
10875: ENABLE
// end ;
10876: END
// every 0 0$1 marked 24 do
10877: GO 10879
10879: DISABLE
// begin Wait ( 0 0$20 ) ;
10880: LD_INT 700
10882: PPUSH
10883: CALL_OW 67
// D_MercAttack ;
10887: CALL 5389 0 0
// end ;
10891: END
// every 0 0$1 + 0 0$0.4 marked 4 do
10892: GO 10894
10894: DISABLE
// begin if IsInArea ( Heike , WaitHeikeArea ) and not HeikeDismissed then
10895: LD_EXP 11
10899: PPUSH
10900: LD_INT 8
10902: PPUSH
10903: CALL_OW 308
10907: PUSH
10908: LD_EXP 45
10912: NOT
10913: AND
10914: IFFALSE 11007
// begin SetSide ( Heike , merc ) ;
10916: LD_EXP 11
10920: PPUSH
10921: LD_EXP 34
10925: PPUSH
10926: CALL_OW 235
// ComMoveToArea ( [ Kurt , Mercenary1 , Heike ] , MercExitArea ) ;
10930: LD_EXP 13
10934: PUSH
10935: LD_EXP 14
10939: PUSH
10940: LD_EXP 11
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: LIST
10949: PPUSH
10950: LD_INT 7
10952: PPUSH
10953: CALL_OW 113
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
10957: LD_INT 8
10959: PPUSH
10960: LD_INT 0
10962: PPUSH
10963: CALL_OW 424
// HeikeDismissed := true ;
10967: LD_ADDR_EXP 45
10971: PUSH
10972: LD_INT 1
10974: ST_TO_ADDR
// if not PopovAsked then
10975: LD_EXP 46
10979: NOT
10980: IFFALSE 10986
// D_MercPopov ;
10982: CALL 5284 0 0
// enable ( 5 ) ;
10986: LD_INT 5
10988: ENABLE_MARKED
// disabled6 := true ;
10989: LD_ADDR_EXP 90
10993: PUSH
10994: LD_INT 1
10996: ST_TO_ADDR
// disabled3 := true ;
10997: LD_ADDR_EXP 87
11001: PUSH
11002: LD_INT 1
11004: ST_TO_ADDR
// end else
11005: GO 11008
// enable ;
11007: ENABLE
// end ;
11008: END
// every 0 0$1 + 0 0$0.5 marked 5 do var filter , un ;
11009: GO 11011
11011: DISABLE
11012: LD_INT 0
11014: PPUSH
11015: PPUSH
// begin filter := FilterUnitsInArea ( MercExitArea , [ f_or , [ f_side , merc ] , [ f_side , arab ] ] ) ;
11016: LD_ADDR_VAR 0 1
11020: PUSH
11021: LD_INT 7
11023: PPUSH
11024: LD_INT 2
11026: PUSH
11027: LD_INT 22
11029: PUSH
11030: LD_EXP 34
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: PUSH
11039: LD_INT 22
11041: PUSH
11042: LD_EXP 33
11046: PUSH
11047: EMPTY
11048: LIST
11049: LIST
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: LIST
11055: PPUSH
11056: CALL_OW 70
11060: ST_TO_ADDR
// for un in filter do
11061: LD_ADDR_VAR 0 2
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: FOR_IN
11072: IFFALSE 11092
// begin RemoveUnit ( un ) ;
11074: LD_VAR 0 2
11078: PPUSH
11079: CALL_OW 64
// Wait ( 1 ) ;
11083: LD_INT 1
11085: PPUSH
11086: CALL_OW 67
// end ;
11090: GO 11071
11092: POP
11093: POP
// if not disabled5 then
11094: LD_EXP 89
11098: NOT
11099: IFFALSE 11102
// enable ;
11101: ENABLE
// end ;
11102: PPOPN 2
11104: END
// every 0 0$1 + 0 0$0.6 marked 6 do
11105: GO 11107
11107: DISABLE
// begin if IsInArea ( Kurt , WaitHeikeArea ) then
11108: LD_EXP 13
11112: PPUSH
11113: LD_INT 8
11115: PPUSH
11116: CALL_OW 308
11120: IFFALSE 11127
// enable ( 4 ) else
11122: LD_INT 4
11124: ENABLE_MARKED
11125: GO 11128
// enable ;
11127: ENABLE
// end ;
11128: END
// every 0 0$1 + 0 0$0.7 marked 7 do var un , i , done ;
11129: GO 11131
11131: DISABLE
11132: LD_INT 0
11134: PPUSH
11135: PPUSH
11136: PPUSH
// begin for un in player_units do
11137: LD_ADDR_VAR 0 1
11141: PUSH
11142: LD_EXP 26
11146: PUSH
11147: FOR_IN
11148: IFFALSE 11379
// begin if GetSide ( Attacks ( un ) ) = arab and not disabled7 then
11150: LD_VAR 0 1
11154: PPUSH
11155: CALL_OW 320
11159: PPUSH
11160: CALL_OW 255
11164: PUSH
11165: LD_EXP 33
11169: EQUAL
11170: PUSH
11171: LD_EXP 91
11175: NOT
11176: AND
11177: IFFALSE 11377
// begin GenscherBetrayed := true ;
11179: LD_ADDR_EXP 36
11183: PUSH
11184: LD_INT 1
11186: ST_TO_ADDR
// disabled7 := true ;
11187: LD_ADDR_EXP 91
11191: PUSH
11192: LD_INT 1
11194: ST_TO_ADDR
// D_HandOverSpoiled ;
11195: CALL 5672 0 0
// SetAttitude ( you , arab , att_enemy , true ) ;
11199: LD_EXP 31
11203: PPUSH
11204: LD_EXP 33
11208: PPUSH
11209: LD_INT 2
11211: PPUSH
11212: LD_INT 1
11214: PPUSH
11215: CALL_OW 80
// repeat wait ( 0 0$0.5 ) ;
11219: LD_INT 18
11221: PPUSH
11222: CALL_OW 67
// done = true ;
11226: LD_ADDR_VAR 0 3
11230: PUSH
11231: LD_INT 1
11233: ST_TO_ADDR
// for i in ar_human do
11234: LD_ADDR_VAR 0 2
11238: PUSH
11239: LD_EXP 80
11243: PUSH
11244: FOR_IN
11245: IFFALSE 11363
// begin if not IsPlaced ( i ) and GetLives ( i ) > 0 then
11247: LD_VAR 0 2
11251: PPUSH
11252: CALL_OW 305
11256: NOT
11257: PUSH
11258: LD_VAR 0 2
11262: PPUSH
11263: CALL_OW 256
11267: PUSH
11268: LD_INT 0
11270: GREATER
11271: AND
11272: IFFALSE 11284
// begin done = false ;
11274: LD_ADDR_VAR 0 3
11278: PUSH
11279: LD_INT 0
11281: ST_TO_ADDR
// continue ;
11282: GO 11244
// end ; if not IsOk ( i ) then
11284: LD_VAR 0 2
11288: PPUSH
11289: CALL_OW 302
11293: NOT
11294: IFFALSE 11298
// continue ;
11296: GO 11244
// if IsInUnit ( i ) > 0 then
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 310
11307: PUSH
11308: LD_INT 0
11310: GREATER
11311: IFFALSE 11332
// begin ComExitVehicle ( i ) ;
11313: LD_VAR 0 2
11317: PPUSH
11318: CALL_OW 121
// done = false ;
11322: LD_ADDR_VAR 0 3
11326: PUSH
11327: LD_INT 0
11329: ST_TO_ADDR
// end else
11330: GO 11361
// ComAgressiveMove ( i , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11332: LD_VAR 0 2
11336: PPUSH
11337: LD_EXP 1
11341: PPUSH
11342: CALL_OW 250
11346: PPUSH
11347: LD_EXP 1
11351: PPUSH
11352: CALL_OW 251
11356: PPUSH
11357: CALL_OW 114
// end ;
11361: GO 11244
11363: POP
11364: POP
// until MercHandoverArabsSpawned and done ;
11365: LD_EXP 43
11369: PUSH
11370: LD_VAR 0 3
11374: AND
11375: IFFALSE 11219
// end ; end ;
11377: GO 11147
11379: POP
11380: POP
// if not disabled7 and not MercHandoverDone then
11381: LD_EXP 91
11385: NOT
11386: PUSH
11387: LD_EXP 42
11391: NOT
11392: AND
11393: IFFALSE 11396
// enable ;
11395: ENABLE
// end ;
11396: PPOPN 3
11398: END
// every 0 0$0.5 + 0 0$0.3 marked 8 do
11399: GO 11401
11401: DISABLE
// begin if disabled7 then
11402: LD_EXP 91
11406: IFFALSE 11411
// begin disable ;
11408: DISABLE
// exit ;
11409: GO 12001
// end ; if not MercHandedOver then
11411: LD_EXP 40
11415: NOT
11416: IFFALSE 11420
// exit ;
11418: GO 12001
// if not GetSide ( Kurt ) = arab then
11420: LD_EXP 13
11424: PPUSH
11425: CALL_OW 255
11429: PUSH
11430: LD_EXP 33
11434: EQUAL
11435: NOT
11436: IFFALSE 11456
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
11438: LD_EXP 80
11442: PUSH
11443: LD_INT 1
11445: ARRAY
11446: PPUSH
11447: LD_EXP 13
11451: PPUSH
11452: CALL_OW 115
// if not GetSide ( Mercenary1 ) = arab then
11456: LD_EXP 14
11460: PPUSH
11461: CALL_OW 255
11465: PUSH
11466: LD_EXP 33
11470: EQUAL
11471: NOT
11472: IFFALSE 11492
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11474: LD_EXP 80
11478: PUSH
11479: LD_INT 2
11481: ARRAY
11482: PPUSH
11483: LD_EXP 14
11487: PPUSH
11488: CALL_OW 115
// if not IsLive ( Kurt ) or not IsLive ( Mercenary1 ) then
11492: LD_EXP 13
11496: PPUSH
11497: CALL_OW 300
11501: NOT
11502: PUSH
11503: LD_EXP 14
11507: PPUSH
11508: CALL_OW 300
11512: NOT
11513: OR
11514: IFFALSE 11585
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] ] , [ [ 29 , 57 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11516: LD_INT 1
11518: PPUSH
11519: LD_EXP 80
11523: PUSH
11524: LD_INT 1
11526: ARRAY
11527: PUSH
11528: LD_EXP 80
11532: PUSH
11533: LD_INT 2
11535: ARRAY
11536: PUSH
11537: LD_EXP 80
11541: PUSH
11542: LD_INT 3
11544: ARRAY
11545: PUSH
11546: EMPTY
11547: LIST
11548: LIST
11549: LIST
11550: PPUSH
11551: LD_INT 29
11553: PUSH
11554: LD_INT 57
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: PUSH
11561: EMPTY
11562: LIST
11563: PPUSH
11564: LD_INT 1
11566: PUSH
11567: LD_INT 3
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 5
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PPUSH
11581: CALL_OW 398
// if Attacks ( ar_human [ 1 ] ) = Kurt then
11585: LD_EXP 80
11589: PUSH
11590: LD_INT 1
11592: ARRAY
11593: PPUSH
11594: CALL_OW 320
11598: PUSH
11599: LD_EXP 13
11603: EQUAL
11604: IFFALSE 11718
// begin ComStop ( [ Kurt , Mercenary1 ] ) ;
11606: LD_EXP 13
11610: PUSH
11611: LD_EXP 14
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: PPUSH
11620: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11624: LD_EXP 13
11628: PUSH
11629: LD_EXP 14
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PPUSH
11638: LD_EXP 33
11642: PPUSH
11643: CALL_OW 235
// ComStop ( ar_human [ 1 ] ) ;
11647: LD_EXP 80
11651: PUSH
11652: LD_INT 1
11654: ARRAY
11655: PPUSH
11656: CALL_OW 141
// Wait ( 2 ) ;
11660: LD_INT 2
11662: PPUSH
11663: CALL_OW 67
// AddComMoveUnit ( ar_human [ 1 ] , Kurt ) ;
11667: LD_EXP 80
11671: PUSH
11672: LD_INT 1
11674: ARRAY
11675: PPUSH
11676: LD_EXP 13
11680: PPUSH
11681: CALL_OW 172
// if GetLives ( Kurt ) < 300 then
11685: LD_EXP 13
11689: PPUSH
11690: CALL_OW 256
11694: PUSH
11695: LD_INT 300
11697: LESS
11698: IFFALSE 11718
// AddComHeal ( ar_human [ 3 ] , Kurt ) ;
11700: LD_EXP 80
11704: PUSH
11705: LD_INT 3
11707: ARRAY
11708: PPUSH
11709: LD_EXP 13
11713: PPUSH
11714: CALL_OW 188
// end ; if Attacks ( ar_human [ 2 ] ) = Mercenary1 then
11718: LD_EXP 80
11722: PUSH
11723: LD_INT 2
11725: ARRAY
11726: PPUSH
11727: CALL_OW 320
11731: PUSH
11732: LD_EXP 14
11736: EQUAL
11737: IFFALSE 11851
// begin ComStop ( ar_human [ 2 ] ) ;
11739: LD_EXP 80
11743: PUSH
11744: LD_INT 2
11746: ARRAY
11747: PPUSH
11748: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11752: LD_EXP 13
11756: PUSH
11757: LD_EXP 14
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PPUSH
11766: LD_EXP 33
11770: PPUSH
11771: CALL_OW 235
// ComStop ( [ Kurt , Mercenary1 ] ) ;
11775: LD_EXP 13
11779: PUSH
11780: LD_EXP 14
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: PPUSH
11789: CALL_OW 141
// Wait ( 2 ) ;
11793: LD_INT 2
11795: PPUSH
11796: CALL_OW 67
// AddComMoveUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11800: LD_EXP 80
11804: PUSH
11805: LD_INT 2
11807: ARRAY
11808: PPUSH
11809: LD_EXP 14
11813: PPUSH
11814: CALL_OW 172
// if GetLives ( Mercenary1 ) < 300 then
11818: LD_EXP 14
11822: PPUSH
11823: CALL_OW 256
11827: PUSH
11828: LD_INT 300
11830: LESS
11831: IFFALSE 11851
// AddComHeal ( ar_human [ 3 ] , Mercenary1 ) ;
11833: LD_EXP 80
11837: PUSH
11838: LD_INT 3
11840: ARRAY
11841: PPUSH
11842: LD_EXP 14
11846: PPUSH
11847: CALL_OW 188
// end ; if GetSide ( Kurt ) = arab and GetSide ( Mercenary1 ) = arab then
11851: LD_EXP 13
11855: PPUSH
11856: CALL_OW 255
11860: PUSH
11861: LD_EXP 33
11865: EQUAL
11866: PUSH
11867: LD_EXP 14
11871: PPUSH
11872: CALL_OW 255
11876: PUSH
11877: LD_EXP 33
11881: EQUAL
11882: AND
11883: IFFALSE 11993
// begin disabled8 := true ;
11885: LD_ADDR_EXP 92
11889: PUSH
11890: LD_INT 1
11892: ST_TO_ADDR
// disable ( 2 ) ;
11893: LD_INT 2
11895: DISABLE_MARKED
// disable ( 6 ) ;
11896: LD_INT 6
11898: DISABLE_MARKED
// disable ( 12 ) ;
11899: LD_INT 12
11901: DISABLE_MARKED
// Wait ( 0 0$5 ) ;
11902: LD_INT 175
11904: PPUSH
11905: CALL_OW 67
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] , Kurt , Mercenary1 ] , [ [ 115 , 32 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11909: LD_INT 1
11911: PPUSH
11912: LD_EXP 80
11916: PUSH
11917: LD_INT 1
11919: ARRAY
11920: PUSH
11921: LD_EXP 80
11925: PUSH
11926: LD_INT 2
11928: ARRAY
11929: PUSH
11930: LD_EXP 80
11934: PUSH
11935: LD_INT 3
11937: ARRAY
11938: PUSH
11939: LD_EXP 13
11943: PUSH
11944: LD_EXP 14
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: LIST
11953: LIST
11954: LIST
11955: PPUSH
11956: LD_INT 115
11958: PUSH
11959: LD_INT 32
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: EMPTY
11967: LIST
11968: PPUSH
11969: LD_INT 1
11971: PUSH
11972: LD_INT 3
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PPUSH
11986: CALL_OW 398
// enable ( 11 ) ;
11990: LD_INT 11
11992: ENABLE_MARKED
// end ; if not disabled8 then
11993: LD_EXP 92
11997: NOT
11998: IFFALSE 12001
// enable ;
12000: ENABLE
// end ;
12001: END
// every 0 0$1 + 0 0$0.1 marked 8 do
12002: GO 12004
12004: DISABLE
// begin repeat wait ( 0 0$1 ) ;
12005: LD_INT 35
12007: PPUSH
12008: CALL_OW 67
// if GenscherBetrayed then
12012: LD_EXP 36
12016: IFFALSE 12020
// exit ;
12018: GO 12059
// if UnitFilter ( ar_human , [ f_placed ] ) = 0 then
12020: LD_EXP 80
12024: PPUSH
12025: LD_INT 52
12027: PUSH
12028: EMPTY
12029: LIST
12030: PPUSH
12031: CALL_OW 72
12035: PUSH
12036: LD_INT 0
12038: EQUAL
12039: IFFALSE 12055
// begin SA_OnLegionHandoverToUPF ;
12041: CALL 19118 0 0
// MercHandoverDone = true ;
12045: LD_ADDR_EXP 42
12049: PUSH
12050: LD_INT 1
12052: ST_TO_ADDR
// exit ;
12053: GO 12059
// end ; until false ;
12055: LD_INT 0
12057: IFFALSE 12005
// end ;
12059: END
// every 0 0$1 + 0 0$0.9 marked 9 do var un1 , un2 ;
12060: GO 12062
12062: DISABLE
12063: LD_INT 0
12065: PPUSH
12066: PPUSH
// begin if disabled7 then
12067: LD_EXP 91
12071: IFFALSE 12076
// begin disable ;
12073: DISABLE
// exit ;
12074: GO 12302
// end ; if IsInUnit ( ar_human [ 1 ] ) = 0 and IsInUnit ( ar_human [ 2 ] ) = 0 then
12076: LD_EXP 80
12080: PUSH
12081: LD_INT 1
12083: ARRAY
12084: PPUSH
12085: CALL_OW 310
12089: PUSH
12090: LD_INT 0
12092: EQUAL
12093: PUSH
12094: LD_EXP 80
12098: PUSH
12099: LD_INT 2
12101: ARRAY
12102: PPUSH
12103: CALL_OW 310
12107: PUSH
12108: LD_INT 0
12110: EQUAL
12111: AND
12112: IFFALSE 12294
// begin disable ( 601 ) ;
12114: LD_INT 601
12116: DISABLE_MARKED
// D_HandOverCome ;
12117: CALL 5632 0 0
// MercHandedOver := true ;
12121: LD_ADDR_EXP 40
12125: PUSH
12126: LD_INT 1
12128: ST_TO_ADDR
// disable ( 20 ) ;
12129: LD_INT 20
12131: DISABLE_MARKED
// enable ( 23 ) ;
12132: LD_INT 23
12134: ENABLE_MARKED
// enable ( 8 ) ;
12135: LD_INT 8
12137: ENABLE_MARKED
// ComStop ( [ Kurt , Mercenary1 ] ) ;
12138: LD_EXP 13
12142: PUSH
12143: LD_EXP 14
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: PPUSH
12152: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
12156: LD_EXP 13
12160: PUSH
12161: LD_EXP 14
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: LD_EXP 34
12174: PPUSH
12175: CALL_OW 235
// SetAttitude ( you , merc , att_neutral , true ) ;
12179: LD_EXP 31
12183: PPUSH
12184: LD_EXP 34
12188: PPUSH
12189: LD_INT 0
12191: PPUSH
12192: LD_INT 1
12194: PPUSH
12195: CALL_OW 80
// SetAttitude ( merc , arab , att_friend , true ) ;
12199: LD_EXP 34
12203: PPUSH
12204: LD_EXP 33
12208: PPUSH
12209: LD_INT 1
12211: PPUSH
12212: LD_INT 1
12214: PPUSH
12215: CALL_OW 80
// Wait ( 2 ) ;
12219: LD_INT 2
12221: PPUSH
12222: CALL_OW 67
// enable ( 5 ) ;
12226: LD_INT 5
12228: ENABLE_MARKED
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
12229: LD_EXP 80
12233: PUSH
12234: LD_INT 1
12236: ARRAY
12237: PPUSH
12238: LD_EXP 13
12242: PPUSH
12243: CALL_OW 115
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
12247: LD_EXP 80
12251: PUSH
12252: LD_INT 2
12254: ARRAY
12255: PPUSH
12256: LD_EXP 14
12260: PPUSH
12261: CALL_OW 115
// ComMoveToArea ( [ Kurt , Mercenary1 ] , MercExitArea ) ;
12265: LD_EXP 13
12269: PUSH
12270: LD_EXP 14
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PPUSH
12279: LD_INT 7
12281: PPUSH
12282: CALL_OW 113
// disabled9 := true ;
12286: LD_ADDR_EXP 93
12290: PUSH
12291: LD_INT 1
12293: ST_TO_ADDR
// end ; if not disabled9 then
12294: LD_EXP 93
12298: NOT
12299: IFFALSE 12302
// enable ;
12301: ENABLE
// end ;
12302: PPOPN 2
12304: END
// every 0 0$1 marked 10 do var rnd ;
12305: GO 12307
12307: DISABLE
12308: LD_INT 0
12310: PPUSH
// begin rnd := Rand ( 0 0$30 , 0 0$45 ) ;
12311: LD_ADDR_VAR 0 1
12315: PUSH
12316: LD_INT 1050
12318: PPUSH
12319: LD_INT 1575
12321: PPUSH
12322: CALL_OW 12
12326: ST_TO_ADDR
// Wait ( rnd ) ;
12327: LD_VAR 0 1
12331: PPUSH
12332: CALL_OW 67
// if GetAttitude ( you , merc ) = att_neutral and GetSide ( Kurt ) = you then
12336: LD_EXP 31
12340: PPUSH
12341: LD_EXP 34
12345: PPUSH
12346: CALL_OW 81
12350: PUSH
12351: LD_INT 0
12353: EQUAL
12354: PUSH
12355: LD_EXP 13
12359: PPUSH
12360: CALL_OW 255
12364: PUSH
12365: LD_EXP 31
12369: EQUAL
12370: AND
12371: IFFALSE 12377
// D_ArabianRequest ;
12373: CALL 5429 0 0
// end ;
12377: PPOPN 1
12379: END
// every 0 0$1 + 0 0$0.2 marked 11 do var filter , un , disablefilter ;
12380: GO 12382
12382: DISABLE
12383: LD_INT 0
12385: PPUSH
12386: PPUSH
12387: PPUSH
// begin filter := FilterUnitsInArea ( HandOverEnterArea , [ [ f_side , arab ] , [ f_type , unit_human ] ] ) ;
12388: LD_ADDR_VAR 0 1
12392: PUSH
12393: LD_INT 6
12395: PPUSH
12396: LD_INT 22
12398: PUSH
12399: LD_EXP 33
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 21
12410: PUSH
12411: LD_INT 1
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PPUSH
12422: CALL_OW 70
12426: ST_TO_ADDR
// for un in filter do
12427: LD_ADDR_VAR 0 2
12431: PUSH
12432: LD_VAR 0 1
12436: PUSH
12437: FOR_IN
12438: IFFALSE 12458
// begin RemoveUnit ( un ) ;
12440: LD_VAR 0 2
12444: PPUSH
12445: CALL_OW 64
// Wait ( 1 ) ;
12449: LD_INT 1
12451: PPUSH
12452: CALL_OW 67
// end ;
12456: GO 12437
12458: POP
12459: POP
// disablefilter := FilterAllUnits ( [ f_side , arab ] ) ;
12460: LD_ADDR_VAR 0 3
12464: PUSH
12465: LD_INT 22
12467: PUSH
12468: LD_EXP 33
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: PPUSH
12477: CALL_OW 69
12481: ST_TO_ADDR
// if 0 + disablefilter > 0 then
12482: LD_INT 0
12484: PUSH
12485: LD_VAR 0 3
12489: PLUS
12490: PUSH
12491: LD_INT 0
12493: GREATER
12494: IFFALSE 12499
// enable else
12496: ENABLE
12497: GO 12503
// begin disable ;
12499: DISABLE
// disable ( 7 ) ;
12500: LD_INT 7
12502: DISABLE_MARKED
// end ; end ;
12503: PPOPN 3
12505: END
// var HeikeCratesTime , LegionDone ; every 0 0$1 marked 13 do var un , filter , amount ;
12506: GO 12508
12508: DISABLE
12509: LD_INT 0
12511: PPUSH
12512: PPUSH
12513: PPUSH
// begin if ( not HeikeKilled ) and HeikeDismissed then
12514: LD_EXP 38
12518: NOT
12519: PUSH
12520: LD_EXP 45
12524: AND
12525: IFFALSE 13305
// begin disabled5 := true ;
12527: LD_ADDR_EXP 89
12531: PUSH
12532: LD_INT 1
12534: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
12535: LD_INT 175
12537: PPUSH
12538: CALL_OW 67
// D_LegionFormed ;
12542: CALL 5700 0 0
// case Query ( QLegion ) of 1 :
12546: LD_STRING QLegion
12548: PPUSH
12549: CALL_OW 97
12553: PUSH
12554: LD_INT 1
12556: DOUBLE
12557: EQUAL
12558: IFTRUE 12562
12560: GO 13289
12562: POP
// begin amount := 0 ;
12563: LD_ADDR_VAR 0 3
12567: PUSH
12568: LD_INT 0
12570: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12571: LD_ADDR_VAR 0 2
12575: PUSH
12576: LD_INT 22
12578: PUSH
12579: LD_EXP 31
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: PUSH
12588: LD_INT 2
12590: PUSH
12591: LD_INT 30
12593: PUSH
12594: LD_INT 0
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 30
12603: PUSH
12604: LD_INT 1
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: PUSH
12616: EMPTY
12617: LIST
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: PPUSH
12623: CALL_OW 69
12627: ST_TO_ADDR
// if filter <> [ ] then
12628: LD_VAR 0 2
12632: PUSH
12633: EMPTY
12634: NONEQUAL
12635: IFFALSE 12683
// for un in filter do
12637: LD_ADDR_VAR 0 1
12641: PUSH
12642: LD_VAR 0 2
12646: PUSH
12647: FOR_IN
12648: IFFALSE 12681
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12650: LD_ADDR_VAR 0 3
12654: PUSH
12655: LD_VAR 0 3
12659: PUSH
12660: LD_VAR 0 1
12664: PPUSH
12665: CALL_OW 274
12669: PPUSH
12670: LD_INT 1
12672: PPUSH
12673: CALL_OW 275
12677: PLUS
12678: ST_TO_ADDR
12679: GO 12647
12681: POP
12682: POP
// if amount < 50 then
12683: LD_VAR 0 3
12687: PUSH
12688: LD_INT 50
12690: LESS
12691: IFFALSE 13115
// begin HeikeCratesTime := 0 0$60 ;
12693: LD_ADDR_LOC 5
12697: PUSH
12698: LD_INT 2100
12700: ST_TO_ADDR
// repeat display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] ;
12701: LD_ADDR_OWVAR 47
12705: PUSH
12706: LD_STRING #Ru08-1
12708: PUSH
12709: LD_INT 0
12711: PUSH
12712: LD_LOC 3
12716: PLUS
12717: PUSH
12718: LD_STRING #Ru08-2
12720: PUSH
12721: LD_INT 0
12723: PUSH
12724: LD_LOC 4
12728: PLUS
12729: PUSH
12730: LD_STRING #Ru08-3
12732: PUSH
12733: LD_INT 0
12735: PUSH
12736: LD_EXP 56
12740: PLUS
12741: PUSH
12742: LD_STRING #Ru08-4
12744: PUSH
12745: LD_LOC 5
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: ST_TO_ADDR
// amount := 0 ;
12760: LD_ADDR_VAR 0 3
12764: PUSH
12765: LD_INT 0
12767: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12768: LD_ADDR_VAR 0 2
12772: PUSH
12773: LD_INT 22
12775: PUSH
12776: LD_EXP 31
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 2
12787: PUSH
12788: LD_INT 30
12790: PUSH
12791: LD_INT 0
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: LD_INT 30
12800: PUSH
12801: LD_INT 1
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 69
12824: ST_TO_ADDR
// if filter <> [ ] then
12825: LD_VAR 0 2
12829: PUSH
12830: EMPTY
12831: NONEQUAL
12832: IFFALSE 12880
// for un in filter do
12834: LD_ADDR_VAR 0 1
12838: PUSH
12839: LD_VAR 0 2
12843: PUSH
12844: FOR_IN
12845: IFFALSE 12878
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12847: LD_ADDR_VAR 0 3
12851: PUSH
12852: LD_VAR 0 3
12856: PUSH
12857: LD_VAR 0 1
12861: PPUSH
12862: CALL_OW 274
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: CALL_OW 275
12874: PLUS
12875: ST_TO_ADDR
12876: GO 12844
12878: POP
12879: POP
// Wait ( 0 0$1 ) ;
12880: LD_INT 35
12882: PPUSH
12883: CALL_OW 67
// HeikeCratesTime := HeikeCratesTime - 0 0$1 ;
12887: LD_ADDR_LOC 5
12891: PUSH
12892: LD_LOC 5
12896: PUSH
12897: LD_INT 35
12899: MINUS
12900: ST_TO_ADDR
// until amount >= 50 or HeikeCratesTime <= 0 ;
12901: LD_VAR 0 3
12905: PUSH
12906: LD_INT 50
12908: GREATEREQUAL
12909: PUSH
12910: LD_LOC 5
12914: PUSH
12915: LD_INT 0
12917: LESSEQUAL
12918: OR
12919: IFFALSE 12701
// if amount >= 50 and HeikeCratesTime > 0 then
12921: LD_VAR 0 3
12925: PUSH
12926: LD_INT 50
12928: GREATEREQUAL
12929: PUSH
12930: LD_LOC 5
12934: PUSH
12935: LD_INT 0
12937: GREATER
12938: AND
12939: IFFALSE 13113
// begin D_QrLegion1 ;
12941: CALL 5776 0 0
// MercPaid := true ;
12945: LD_ADDR_EXP 39
12949: PUSH
12950: LD_INT 1
12952: ST_TO_ADDR
// amount := 50 ;
12953: LD_ADDR_VAR 0 3
12957: PUSH
12958: LD_INT 50
12960: ST_TO_ADDR
// for un in filter do
12961: LD_ADDR_VAR 0 1
12965: PUSH
12966: LD_VAR 0 2
12970: PUSH
12971: FOR_IN
12972: IFFALSE 13111
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
12974: LD_VAR 0 1
12978: PPUSH
12979: CALL_OW 274
12983: PPUSH
12984: LD_INT 1
12986: PPUSH
12987: CALL_OW 275
12991: PUSH
12992: LD_VAR 0 3
12996: LESS
12997: PUSH
12998: LD_VAR 0 3
13002: PUSH
13003: LD_INT 0
13005: NONEQUAL
13006: AND
13007: IFFALSE 13060
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13009: LD_ADDR_VAR 0 3
13013: PUSH
13014: LD_VAR 0 3
13018: PUSH
13019: LD_VAR 0 1
13023: PPUSH
13024: CALL_OW 274
13028: PPUSH
13029: LD_INT 1
13031: PPUSH
13032: CALL_OW 275
13036: MINUS
13037: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13038: LD_VAR 0 1
13042: PPUSH
13043: CALL_OW 274
13047: PPUSH
13048: LD_INT 1
13050: PPUSH
13051: LD_INT 0
13053: PPUSH
13054: CALL_OW 277
// end else
13058: GO 13109
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13060: LD_VAR 0 1
13064: PPUSH
13065: CALL_OW 274
13069: PPUSH
13070: LD_INT 1
13072: PPUSH
13073: LD_VAR 0 1
13077: PPUSH
13078: CALL_OW 274
13082: PPUSH
13083: LD_INT 1
13085: PPUSH
13086: CALL_OW 275
13090: PUSH
13091: LD_VAR 0 3
13095: MINUS
13096: PPUSH
13097: CALL_OW 277
// amount := 0 ;
13101: LD_ADDR_VAR 0 3
13105: PUSH
13106: LD_INT 0
13108: ST_TO_ADDR
// end ;
13109: GO 12971
13111: POP
13112: POP
// end ; end else
13113: GO 13287
// begin D_QrLegion1 ;
13115: CALL 5776 0 0
// MercPaid := true ;
13119: LD_ADDR_EXP 39
13123: PUSH
13124: LD_INT 1
13126: ST_TO_ADDR
// amount := 50 ;
13127: LD_ADDR_VAR 0 3
13131: PUSH
13132: LD_INT 50
13134: ST_TO_ADDR
// for un in filter do
13135: LD_ADDR_VAR 0 1
13139: PUSH
13140: LD_VAR 0 2
13144: PUSH
13145: FOR_IN
13146: IFFALSE 13285
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
13148: LD_VAR 0 1
13152: PPUSH
13153: CALL_OW 274
13157: PPUSH
13158: LD_INT 1
13160: PPUSH
13161: CALL_OW 275
13165: PUSH
13166: LD_VAR 0 3
13170: LESS
13171: PUSH
13172: LD_VAR 0 3
13176: PUSH
13177: LD_INT 0
13179: NONEQUAL
13180: AND
13181: IFFALSE 13234
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13183: LD_ADDR_VAR 0 3
13187: PUSH
13188: LD_VAR 0 3
13192: PUSH
13193: LD_VAR 0 1
13197: PPUSH
13198: CALL_OW 274
13202: PPUSH
13203: LD_INT 1
13205: PPUSH
13206: CALL_OW 275
13210: MINUS
13211: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13212: LD_VAR 0 1
13216: PPUSH
13217: CALL_OW 274
13221: PPUSH
13222: LD_INT 1
13224: PPUSH
13225: LD_INT 0
13227: PPUSH
13228: CALL_OW 277
// end else
13232: GO 13283
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13234: LD_VAR 0 1
13238: PPUSH
13239: CALL_OW 274
13243: PPUSH
13244: LD_INT 1
13246: PPUSH
13247: LD_VAR 0 1
13251: PPUSH
13252: CALL_OW 274
13256: PPUSH
13257: LD_INT 1
13259: PPUSH
13260: CALL_OW 275
13264: PUSH
13265: LD_VAR 0 3
13269: MINUS
13270: PPUSH
13271: CALL_OW 277
// amount := 0 ;
13275: LD_ADDR_VAR 0 3
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// end ;
13283: GO 13145
13285: POP
13286: POP
// end ; end ; 2 :
13287: GO 13305
13289: LD_INT 2
13291: DOUBLE
13292: EQUAL
13293: IFTRUE 13297
13295: GO 13304
13297: POP
// D_QrLegion2 ; end ;
13298: CALL 5804 0 0
13302: GO 13305
13304: POP
// end ; LegionDone := true ;
13305: LD_ADDR_LOC 6
13309: PUSH
13310: LD_INT 1
13312: ST_TO_ADDR
// end ;
13313: PPOPN 3
13315: END
// every 0 0$1 marked 20 do
13316: GO 13318
13318: DISABLE
// begin if IsSelected ( Heike ) = true then
13319: LD_EXP 11
13323: PPUSH
13324: CALL_OW 306
13328: PUSH
13329: LD_INT 1
13331: EQUAL
13332: IFFALSE 13392
// begin if WasSelected = false then
13334: LD_EXP 83
13338: PUSH
13339: LD_INT 0
13341: EQUAL
13342: IFFALSE 13390
// begin if Query ( QSendHeike ) = 1 then
13344: LD_STRING QSendHeike
13346: PPUSH
13347: CALL_OW 97
13351: PUSH
13352: LD_INT 1
13354: EQUAL
13355: IFFALSE 13382
// begin HeikeSend := true ;
13357: LD_ADDR_EXP 65
13361: PUSH
13362: LD_INT 1
13364: ST_TO_ADDR
// ComMoveXY ( Heike , 39 , 47 ) ;
13365: LD_EXP 11
13369: PPUSH
13370: LD_INT 39
13372: PPUSH
13373: LD_INT 47
13375: PPUSH
13376: CALL_OW 111
// exit ;
13380: GO 13401
// end ; WasSelected := true ;
13382: LD_ADDR_EXP 83
13386: PUSH
13387: LD_INT 1
13389: ST_TO_ADDR
// end ; end else
13390: GO 13400
// WasSelected := false ;
13392: LD_ADDR_EXP 83
13396: PUSH
13397: LD_INT 0
13399: ST_TO_ADDR
// enable ;
13400: ENABLE
// end ;
13401: END
// every 0 0$10 + 0 0$0.4 marked 21 do
13402: GO 13404
13404: DISABLE
// begin if TechnoDone and BuildingsDone and not AmAttackStarted then
13405: LD_EXP 51
13409: PUSH
13410: LD_EXP 48
13414: AND
13415: PUSH
13416: LD_EXP 71
13420: NOT
13421: AND
13422: IFFALSE 13475
// begin enable ( 13 ) ;
13424: LD_INT 13
13426: ENABLE_MARKED
// repeat Wait ( 0 0$1 ) ;
13427: LD_INT 35
13429: PPUSH
13430: CALL_OW 67
// until LegionDone ;
13434: LD_LOC 6
13438: IFFALSE 13427
// if ( not HeikeKilled ) and HeikeDismissed then
13440: LD_EXP 38
13444: NOT
13445: PUSH
13446: LD_EXP 45
13450: AND
13451: IFFALSE 13462
// Wait ( 0 0$35 ) else
13453: LD_INT 1225
13455: PPUSH
13456: CALL_OW 67
13460: GO 13469
// Wait ( 0 0$5 ) ;
13462: LD_INT 175
13464: PPUSH
13465: CALL_OW 67
// enable ( 999 ) ;
13469: LD_INT 999
13471: ENABLE_MARKED
// enable ( 501 ) ;
13472: LD_INT 501
13474: ENABLE_MARKED
// end ; if not AmAttackStarted then
13475: LD_EXP 71
13479: NOT
13480: IFFALSE 13483
// enable ;
13482: ENABLE
// end ;
13483: END
// var ApesRespawned ; every 0 0$1 + 0 0$0.8 marked 22 do var Ape ;
13484: GO 13486
13486: DISABLE
13487: LD_INT 0
13489: PPUSH
// begin Wait ( 350 * ApesRespawned ) ;
13490: LD_INT 350
13492: PUSH
13493: LD_LOC 7
13497: MUL
13498: PPUSH
13499: CALL_OW 67
// if FilterAllUnits ( [ f_class , class_apeman ] ) < 1 then
13503: LD_INT 25
13505: PUSH
13506: LD_INT 12
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PPUSH
13513: CALL_OW 69
13517: PUSH
13518: LD_INT 1
13520: LESS
13521: IFFALSE 13631
// begin ApesRespawned := ApesRespawned + 1 ;
13523: LD_ADDR_LOC 7
13527: PUSH
13528: LD_LOC 7
13532: PUSH
13533: LD_INT 1
13535: PLUS
13536: ST_TO_ADDR
// uc_side := 0 ;
13537: LD_ADDR_OWVAR 20
13541: PUSH
13542: LD_INT 0
13544: ST_TO_ADDR
// uc_nation := nation_nature ;
13545: LD_ADDR_OWVAR 21
13549: PUSH
13550: LD_INT 0
13552: ST_TO_ADDR
// PrepareHuman ( sex_male , class_apeman , 2 ) ;
13553: LD_INT 1
13555: PPUSH
13556: LD_INT 12
13558: PPUSH
13559: LD_INT 2
13561: PPUSH
13562: CALL_OW 380
// hc_name :=  ;
13566: LD_ADDR_OWVAR 26
13570: PUSH
13571: LD_STRING 
13573: ST_TO_ADDR
// Ape := CreateHuman ;
13574: LD_ADDR_VAR 0 1
13578: PUSH
13579: CALL_OW 44
13583: ST_TO_ADDR
// SetDir ( Ape , Rand ( 0 , 5 ) ) ;
13584: LD_VAR 0 1
13588: PPUSH
13589: LD_INT 0
13591: PPUSH
13592: LD_INT 5
13594: PPUSH
13595: CALL_OW 12
13599: PPUSH
13600: CALL_OW 233
// PlaceUnitArea ( Ape , AnimalsArea , false ) ;
13604: LD_VAR 0 1
13608: PPUSH
13609: LD_INT 22
13611: PPUSH
13612: LD_INT 0
13614: PPUSH
13615: CALL_OW 49
// ComMoveToArea ( Ape , ApeArea ) ;
13619: LD_VAR 0 1
13623: PPUSH
13624: LD_INT 23
13626: PPUSH
13627: CALL_OW 113
// end ; enable ;
13631: ENABLE
// end ;
13632: PPOPN 1
13634: END
// every 0 0$15 marked 23 do var filter , un ;
13635: GO 13637
13637: DISABLE
13638: LD_INT 0
13640: PPUSH
13641: PPUSH
// begin ComAttackUnit ( Heike , Burlak ) ;
13642: LD_EXP 11
13646: PPUSH
13647: LD_EXP 1
13651: PPUSH
13652: CALL_OW 115
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13656: LD_ADDR_VAR 0 1
13660: PUSH
13661: LD_INT 22
13663: PUSH
13664: LD_EXP 31
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: PUSH
13673: LD_INT 21
13675: PUSH
13676: LD_INT 1
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: PPUSH
13687: CALL_OW 69
13691: ST_TO_ADDR
// for un in filter do
13692: LD_ADDR_VAR 0 2
13696: PUSH
13697: LD_VAR 0 1
13701: PUSH
13702: FOR_IN
13703: IFFALSE 13728
// begin AddComAttackUnit ( Heike , un ) ;
13705: LD_EXP 11
13709: PPUSH
13710: LD_VAR 0 2
13714: PPUSH
13715: CALL_OW 175
// Wait ( 10 ) ;
13719: LD_INT 10
13721: PPUSH
13722: CALL_OW 67
// end ;
13726: GO 13702
13728: POP
13729: POP
// enable ;
13730: ENABLE
// end ;
13731: PPOPN 2
13733: END
// on BuildingComplete ( building ) do var rnd , distance , un1 , un2 , pole , budova1 , budova2 , i , filter ;
13734: LD_INT 0
13736: PPUSH
13737: PPUSH
13738: PPUSH
13739: PPUSH
13740: PPUSH
13741: PPUSH
13742: PPUSH
13743: PPUSH
13744: PPUSH
// begin if ( not depot_build ) and ( GetBType ( building ) = b_depot ) and HeikeCaptured then
13745: LD_EXP 28
13749: NOT
13750: PUSH
13751: LD_VAR 0 1
13755: PPUSH
13756: CALL_OW 266
13760: PUSH
13761: LD_INT 0
13763: EQUAL
13764: AND
13765: PUSH
13766: LD_EXP 37
13770: AND
13771: IFFALSE 13851
// begin depot_build = true ;
13773: LD_ADDR_EXP 28
13777: PUSH
13778: LD_INT 1
13780: ST_TO_ADDR
// depotX := GetX ( building ) ;
13781: LD_ADDR_EXP 29
13785: PUSH
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 250
13795: ST_TO_ADDR
// depotY := GetY ( building ) ;
13796: LD_ADDR_EXP 30
13800: PUSH
13801: LD_VAR 0 1
13805: PPUSH
13806: CALL_OW 251
13810: ST_TO_ADDR
// Wait ( 0 0$10 ) ;
13811: LD_INT 350
13813: PPUSH
13814: CALL_OW 67
// D_Heike ;
13818: CALL 4997 0 0
// rnd := Rand ( 1 1$15 , 2 2$0 ) ;
13822: LD_ADDR_VAR 0 2
13826: PUSH
13827: LD_INT 2625
13829: PPUSH
13830: LD_INT 4200
13832: PPUSH
13833: CALL_OW 12
13837: ST_TO_ADDR
// Wait ( rnd ) ;
13838: LD_VAR 0 2
13842: PPUSH
13843: CALL_OW 67
// merc_help ;
13847: CALL 7566 0 0
// end ; end ;
13851: PPOPN 10
13853: END
// on UpgradeComplete ( building ) do begin if ( GetBType ( building ) = b_barracks ) and ( GetNation ( building ) = nation_arabian ) then
13854: LD_VAR 0 1
13858: PPUSH
13859: CALL_OW 266
13863: PUSH
13864: LD_INT 5
13866: EQUAL
13867: PUSH
13868: LD_VAR 0 1
13872: PPUSH
13873: CALL_OW 248
13877: PUSH
13878: LD_INT 2
13880: EQUAL
13881: AND
13882: IFFALSE 13986
// begin MortarDone := true ;
13884: LD_ADDR_EXP 52
13888: PUSH
13889: LD_INT 1
13891: ST_TO_ADDR
// if not MercHandedOver or not MercWillBeHandedOver then
13892: LD_EXP 40
13896: NOT
13897: PUSH
13898: LD_EXP 41
13902: NOT
13903: OR
13904: IFFALSE 13986
// begin Wait ( 0 0$1 ) ;
13906: LD_INT 35
13908: PPUSH
13909: CALL_OW 67
// enable ( 3 ) ;
13913: LD_INT 3
13915: ENABLE_MARKED
// D_MercCompleted ;
13916: CALL 5264 0 0
// enable ( 20 ) ;
13920: LD_INT 20
13922: ENABLE_MARKED
// SetAreaMapShow ( WaitHeikeArea , 1 ) ;
13923: LD_INT 8
13925: PPUSH
13926: LD_INT 1
13928: PPUSH
13929: CALL_OW 424
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
13933: LD_EXP 13
13937: PUSH
13938: LD_EXP 14
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PPUSH
13947: LD_EXP 34
13951: PPUSH
13952: CALL_OW 235
// disable ( 601 ) ;
13956: LD_INT 601
13958: DISABLE_MARKED
// ComMoveXY ( [ Kurt , Mercenary1 ] , 39 , 48 ) ;
13959: LD_EXP 13
13963: PUSH
13964: LD_EXP 14
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PPUSH
13973: LD_INT 39
13975: PPUSH
13976: LD_INT 48
13978: PPUSH
13979: CALL_OW 111
// enable ( 6 ) ;
13983: LD_INT 6
13985: ENABLE_MARKED
// end ; end ; end ;
13986: PPOPN 1
13988: END
// on UnitGoesToRed ( un ) do begin if LimitTeleportResearched and GetType ( un ) = unit_vehicle then
13989: LD_EXP 62
13993: PUSH
13994: LD_VAR 0 1
13998: PPUSH
13999: CALL_OW 247
14003: PUSH
14004: LD_INT 2
14006: EQUAL
14007: AND
14008: IFFALSE 14025
// begin LimitTeleportTested := true ;
14010: LD_ADDR_EXP 63
14014: PUSH
14015: LD_INT 1
14017: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
14018: LD_STRING MTeleDone
14020: PPUSH
14021: CALL_OW 337
// end ; if GetSide ( un ) = usa then
14025: LD_VAR 0 1
14029: PPUSH
14030: CALL_OW 255
14034: PUSH
14035: LD_EXP 35
14039: EQUAL
14040: IFFALSE 14058
// amattack := amattack diff un ;
14042: LD_ADDR_EXP 27
14046: PUSH
14047: LD_EXP 27
14051: PUSH
14052: LD_VAR 0 1
14056: DIFF
14057: ST_TO_ADDR
// if un = Heike then
14058: LD_VAR 0 1
14062: PUSH
14063: LD_EXP 11
14067: EQUAL
14068: IFFALSE 14225
// begin if MortarAsked and not MercHandedOver then
14070: LD_EXP 69
14074: PUSH
14075: LD_EXP 40
14079: NOT
14080: AND
14081: IFFALSE 14181
// begin D_MercDeceived ;
14083: CALL 5409 0 0
// if not MortarDone then
14087: LD_EXP 52
14091: NOT
14092: IFFALSE 14155
// begin SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
14094: LD_EXP 13
14098: PUSH
14099: LD_EXP 14
14103: PUSH
14104: EMPTY
14105: LIST
14106: LIST
14107: PPUSH
14108: LD_EXP 34
14112: PPUSH
14113: CALL_OW 235
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
14117: LD_EXP 13
14121: PUSH
14122: LD_EXP 14
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: PPUSH
14131: LD_EXP 1
14135: PPUSH
14136: CALL_OW 250
14140: PPUSH
14141: LD_EXP 1
14145: PPUSH
14146: CALL_OW 251
14150: PPUSH
14151: CALL_OW 114
// end ; SetLives ( Heike , 0 ) ;
14155: LD_EXP 11
14159: PPUSH
14160: LD_INT 0
14162: PPUSH
14163: CALL_OW 234
// HeikeKilled := true ;
14167: LD_ADDR_EXP 38
14171: PUSH
14172: LD_INT 1
14174: ST_TO_ADDR
// merc_attack ;
14175: CALL 7767 0 0
// end else
14179: GO 14225
// begin D_HeikeKilled ;
14181: CALL 5028 0 0
// SetLives ( Heike , 0 ) ;
14185: LD_EXP 11
14189: PPUSH
14190: LD_INT 0
14192: PPUSH
14193: CALL_OW 234
// HeikeKilled := true ;
14197: LD_ADDR_EXP 38
14201: PUSH
14202: LD_INT 1
14204: ST_TO_ADDR
// SetAttitude ( you , merc , att_enemy , true ) ;
14205: LD_EXP 31
14209: PPUSH
14210: LD_EXP 34
14214: PPUSH
14215: LD_INT 2
14217: PPUSH
14218: LD_INT 1
14220: PPUSH
14221: CALL_OW 80
// end ; end ; end ;
14225: PPOPN 1
14227: END
// on UnitDestroyed ( human ) do begin if human = Burlak then
14228: LD_VAR 0 1
14232: PUSH
14233: LD_EXP 1
14237: EQUAL
14238: IFFALSE 14247
// YouLost ( Burlak ) ;
14240: LD_STRING Burlak
14242: PPUSH
14243: CALL_OW 104
// end ;
14247: PPOPN 1
14249: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_AdvAI then
14250: LD_VAR 0 1
14254: PUSH
14255: LD_INT 27
14257: EQUAL
14258: IFFALSE 14285
// begin Hint ( AI ) ;
14260: LD_STRING AI
14262: PPUSH
14263: CALL_OW 339
// Wait ( 0 0$10 ) ;
14267: LD_INT 350
14269: PPUSH
14270: CALL_OW 67
// D_AI ;
14274: CALL 6923 0 0
// ChangeMissionObjectives ( MAI ) ;
14278: LD_STRING MAI
14280: PPUSH
14281: CALL_OW 337
// end ; if tech = tech_LimTeleport then
14285: LD_VAR 0 1
14289: PUSH
14290: LD_INT 37
14292: EQUAL
14293: IFFALSE 14328
// begin Hint ( SpontTelep ) ;
14295: LD_STRING SpontTelep
14297: PPUSH
14298: CALL_OW 339
// Wait ( 0 0$10 ) ;
14302: LD_INT 350
14304: PPUSH
14305: CALL_OW 67
// D_SpontTelep ;
14309: CALL 7025 0 0
// ChangeMissionObjectives ( MTele ) ;
14313: LD_STRING MTele
14315: PPUSH
14316: CALL_OW 337
// LimitTeleportResearched := true ;
14320: LD_ADDR_EXP 62
14324: PUSH
14325: LD_INT 1
14327: ST_TO_ADDR
// end ; AvailableTechno := AvailableTechno diff tech ;
14328: LD_ADDR_EXP 56
14332: PUSH
14333: LD_EXP 56
14337: PUSH
14338: LD_VAR 0 1
14342: DIFF
14343: ST_TO_ADDR
// if HeikeCratesTime then
14344: LD_LOC 5
14348: IFFALSE 14411
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
14350: LD_ADDR_OWVAR 47
14354: PUSH
14355: LD_STRING #Ru08-1
14357: PUSH
14358: LD_INT 0
14360: PUSH
14361: LD_LOC 3
14365: PLUS
14366: PUSH
14367: LD_STRING #Ru08-2
14369: PUSH
14370: LD_INT 0
14372: PUSH
14373: LD_LOC 4
14377: PLUS
14378: PUSH
14379: LD_STRING #Ru08-3
14381: PUSH
14382: LD_INT 0
14384: PUSH
14385: LD_EXP 56
14389: PLUS
14390: PUSH
14391: LD_STRING #Ru08-4
14393: PUSH
14394: LD_LOC 5
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: ST_TO_ADDR
14409: GO 14460
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
14411: LD_ADDR_OWVAR 47
14415: PUSH
14416: LD_STRING #Ru08-1
14418: PUSH
14419: LD_INT 0
14421: PUSH
14422: LD_LOC 3
14426: PLUS
14427: PUSH
14428: LD_STRING #Ru08-2
14430: PUSH
14431: LD_INT 0
14433: PUSH
14434: LD_LOC 4
14438: PLUS
14439: PUSH
14440: LD_STRING #Ru08-3
14442: PUSH
14443: LD_INT 0
14445: PUSH
14446: LD_EXP 56
14450: PLUS
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: ST_TO_ADDR
// if AvailableTechno = [ ] and not TechnoDone then
14460: LD_EXP 56
14464: PUSH
14465: EMPTY
14466: EQUAL
14467: PUSH
14468: LD_EXP 51
14472: NOT
14473: AND
14474: IFFALSE 14491
// begin ChangeMissionObjectives ( MTechnoDone ) ;
14476: LD_STRING MTechnoDone
14478: PPUSH
14479: CALL_OW 337
// TechnoDone := true ;
14483: LD_ADDR_EXP 51
14487: PUSH
14488: LD_INT 1
14490: ST_TO_ADDR
// end ; end ;
14491: PPOPN 2
14493: END
// on VehicleConstructed ( veh , fact ) do begin AvailableWeapons := AvailableWeapons diff GetWeapon ( veh ) ;
14494: LD_ADDR_EXP 54
14498: PUSH
14499: LD_EXP 54
14503: PUSH
14504: LD_VAR 0 1
14508: PPUSH
14509: CALL_OW 264
14513: DIFF
14514: ST_TO_ADDR
// if ( AvailableWeapons + 0 ) = 2 and not MashaAsked then
14515: LD_EXP 54
14519: PUSH
14520: LD_INT 0
14522: PLUS
14523: PUSH
14524: LD_INT 2
14526: EQUAL
14527: PUSH
14528: LD_EXP 70
14532: NOT
14533: AND
14534: IFFALSE 14539
// enable ( 401 ) ;
14536: LD_INT 401
14538: ENABLE_MARKED
// if GetControl ( veh ) = control_computer then
14539: LD_VAR 0 1
14543: PPUSH
14544: CALL_OW 263
14548: PUSH
14549: LD_INT 3
14551: EQUAL
14552: IFFALSE 14569
// begin ChangeMissionObjectives ( MAIDone ) ;
14554: LD_STRING MAIDone
14556: PPUSH
14557: CALL_OW 337
// CompVehConstructed = true ;
14561: LD_ADDR_EXP 61
14565: PUSH
14566: LD_INT 1
14568: ST_TO_ADDR
// end ; end ;
14569: PPOPN 2
14571: END
// on Command ( comm ) marked 601 do var i ;
14572: LD_INT 0
14574: PPUSH
// begin if IsOK ( Kurt ) then
14575: LD_EXP 13
14579: PPUSH
14580: CALL_OW 302
14584: IFFALSE 14784
// if GetTaskList ( Kurt ) <> [ ] then
14586: LD_EXP 13
14590: PPUSH
14591: CALL_OW 437
14595: PUSH
14596: EMPTY
14597: NONEQUAL
14598: IFFALSE 14784
// begin for i := 1 to ( 0 + GetTaskList ( Kurt ) ) do
14600: LD_ADDR_VAR 0 2
14604: PUSH
14605: DOUBLE
14606: LD_INT 1
14608: DEC
14609: ST_TO_ADDR
14610: LD_INT 0
14612: PUSH
14613: LD_EXP 13
14617: PPUSH
14618: CALL_OW 437
14622: PLUS
14623: PUSH
14624: FOR_TO
14625: IFFALSE 14782
// begin if ( GetTaskList ( Kurt ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Kurt ) [ i ] [ 1 ] = B and GetTaskList ( Kurt ) [ i ] [ 5 ] = 36 ) then
14627: LD_EXP 13
14631: PPUSH
14632: CALL_OW 437
14636: PUSH
14637: LD_VAR 0 2
14641: ARRAY
14642: PUSH
14643: LD_INT 1
14645: ARRAY
14646: PUSH
14647: LD_STRING F
14649: PUSH
14650: LD_STRING H
14652: PUSH
14653: LD_STRING M
14655: PUSH
14656: LD_STRING U
14658: PUSH
14659: LD_STRING V
14661: PUSH
14662: LD_STRING a
14664: PUSH
14665: LD_STRING h
14667: PUSH
14668: LD_STRING u
14670: PUSH
14671: LD_STRING v
14673: PUSH
14674: LD_STRING ~
14676: PUSH
14677: LD_STRING ^
14679: PUSH
14680: LD_STRING >
14682: PUSH
14683: LD_STRING +
14685: PUSH
14686: LD_STRING ;
14688: PUSH
14689: LD_STRING 4
14691: PUSH
14692: LD_STRING {
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: IN
14713: PUSH
14714: LD_EXP 13
14718: PPUSH
14719: CALL_OW 437
14723: PUSH
14724: LD_VAR 0 2
14728: ARRAY
14729: PUSH
14730: LD_INT 1
14732: ARRAY
14733: PUSH
14734: LD_STRING B
14736: EQUAL
14737: PUSH
14738: LD_EXP 13
14742: PPUSH
14743: CALL_OW 437
14747: PUSH
14748: LD_VAR 0 2
14752: ARRAY
14753: PUSH
14754: LD_INT 5
14756: ARRAY
14757: PUSH
14758: LD_INT 36
14760: EQUAL
14761: AND
14762: OR
14763: IFFALSE 14767
// else
14765: GO 14780
// begin RemoveTasks ( Kurt ) ;
14767: LD_EXP 13
14771: PPUSH
14772: CALL_OW 493
// D_MercRefuseBuild ;
14776: CALL 5244 0 0
// end ; end ;
14780: GO 14624
14782: POP
14783: POP
// end ; if IsOK ( Mercenary1 ) then
14784: LD_EXP 14
14788: PPUSH
14789: CALL_OW 302
14793: IFFALSE 14993
// if GetTaskList ( Mercenary1 ) <> [ ] then
14795: LD_EXP 14
14799: PPUSH
14800: CALL_OW 437
14804: PUSH
14805: EMPTY
14806: NONEQUAL
14807: IFFALSE 14993
// begin for i := 1 to ( 0 + GetTaskList ( Mercenary1 ) ) do
14809: LD_ADDR_VAR 0 2
14813: PUSH
14814: DOUBLE
14815: LD_INT 1
14817: DEC
14818: ST_TO_ADDR
14819: LD_INT 0
14821: PUSH
14822: LD_EXP 14
14826: PPUSH
14827: CALL_OW 437
14831: PLUS
14832: PUSH
14833: FOR_TO
14834: IFFALSE 14991
// begin if ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] = B and GetTaskList ( Mercenary1 ) [ i ] [ 5 ] = 36 ) then
14836: LD_EXP 14
14840: PPUSH
14841: CALL_OW 437
14845: PUSH
14846: LD_VAR 0 2
14850: ARRAY
14851: PUSH
14852: LD_INT 1
14854: ARRAY
14855: PUSH
14856: LD_STRING F
14858: PUSH
14859: LD_STRING H
14861: PUSH
14862: LD_STRING M
14864: PUSH
14865: LD_STRING U
14867: PUSH
14868: LD_STRING V
14870: PUSH
14871: LD_STRING a
14873: PUSH
14874: LD_STRING h
14876: PUSH
14877: LD_STRING u
14879: PUSH
14880: LD_STRING v
14882: PUSH
14883: LD_STRING ~
14885: PUSH
14886: LD_STRING ^
14888: PUSH
14889: LD_STRING >
14891: PUSH
14892: LD_STRING +
14894: PUSH
14895: LD_STRING ;
14897: PUSH
14898: LD_STRING 4
14900: PUSH
14901: LD_STRING {
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: IN
14922: PUSH
14923: LD_EXP 14
14927: PPUSH
14928: CALL_OW 437
14932: PUSH
14933: LD_VAR 0 2
14937: ARRAY
14938: PUSH
14939: LD_INT 1
14941: ARRAY
14942: PUSH
14943: LD_STRING B
14945: EQUAL
14946: PUSH
14947: LD_EXP 14
14951: PPUSH
14952: CALL_OW 437
14956: PUSH
14957: LD_VAR 0 2
14961: ARRAY
14962: PUSH
14963: LD_INT 5
14965: ARRAY
14966: PUSH
14967: LD_INT 36
14969: EQUAL
14970: AND
14971: OR
14972: IFFALSE 14976
// else
14974: GO 14989
// begin RemoveTasks ( Mercenary1 ) ;
14976: LD_EXP 14
14980: PPUSH
14981: CALL_OW 493
// D_MercRefuseBuild ;
14985: CALL 5244 0 0
// end ; end ;
14989: GO 14833
14991: POP
14992: POP
// end ; end ;
14993: PPOPN 2
14995: END
// every 0 0$1 trigger IsOk ( Kurt ) and GetSide ( Kurt ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) >= 2 do
14996: LD_EXP 13
15000: PPUSH
15001: CALL_OW 302
15005: PUSH
15006: LD_EXP 13
15010: PPUSH
15011: CALL_OW 255
15015: PUSH
15016: LD_INT 3
15018: EQUAL
15019: AND
15020: PUSH
15021: LD_INT 22
15023: PUSH
15024: LD_INT 3
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 23
15033: PUSH
15034: LD_INT 2
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: LD_INT 30
15043: PUSH
15044: LD_INT 4
15046: PUSH
15047: EMPTY
15048: LIST
15049: LIST
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: LIST
15055: PPUSH
15056: CALL_OW 69
15060: PUSH
15061: LD_INT 2
15063: GREATEREQUAL
15064: AND
15065: IFFALSE 15132
15067: GO 15069
15069: DISABLE
// begin enable ;
15070: ENABLE
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) [ 2 ] ) ;
15071: LD_INT 22
15073: PUSH
15074: LD_INT 3
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: PUSH
15081: LD_INT 23
15083: PUSH
15084: LD_INT 2
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PUSH
15091: LD_INT 30
15093: PUSH
15094: LD_INT 4
15096: PUSH
15097: EMPTY
15098: LIST
15099: LIST
15100: PUSH
15101: EMPTY
15102: LIST
15103: LIST
15104: LIST
15105: PPUSH
15106: CALL_OW 69
15110: PUSH
15111: LD_INT 2
15113: ARRAY
15114: PPUSH
15115: CALL_OW 64
// RemoveTasks ( Mercenary1 ) ;
15119: LD_EXP 14
15123: PPUSH
15124: CALL_OW 493
// D_MercRefuseBuild ;
15128: CALL 5244 0 0
// end ; end_of_file
15132: END
// export function hunt ( hunter ) ; var un , animals , animal , kasarna , depot , i , x , y , d , rnd_animal , hunter_x_coordinate , hunter_y_coordinate , range , osoba , min , setridene_animals ; begin
15133: LD_INT 0
15135: PPUSH
15136: PPUSH
15137: PPUSH
15138: PPUSH
15139: PPUSH
15140: PPUSH
15141: PPUSH
15142: PPUSH
15143: PPUSH
15144: PPUSH
15145: PPUSH
15146: PPUSH
15147: PPUSH
15148: PPUSH
15149: PPUSH
15150: PPUSH
15151: PPUSH
// kasarna := FilterAllUnits ( [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ) ;
15152: LD_ADDR_VAR 0 6
15156: PUSH
15157: LD_INT 2
15159: PUSH
15160: LD_INT 30
15162: PUSH
15163: LD_INT 5
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 30
15172: PUSH
15173: LD_INT 4
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: ST_TO_ADDR
// SetSide ( hunter , ally ) ;
15190: LD_VAR 0 1
15194: PPUSH
15195: LD_EXP 32
15199: PPUSH
15200: CALL_OW 235
// if not ( GetClass ( hunter ) = class_soldier ) and ( kasarna > 0 ) then
15204: LD_VAR 0 1
15208: PPUSH
15209: CALL_OW 257
15213: PUSH
15214: LD_INT 1
15216: EQUAL
15217: NOT
15218: PUSH
15219: LD_VAR 0 6
15223: PUSH
15224: LD_INT 0
15226: GREATER
15227: AND
15228: IFFALSE 15416
// begin ComEnterUnit ( hunter , kasarna [ 1 ] ) ;
15230: LD_VAR 0 1
15234: PPUSH
15235: LD_VAR 0 6
15239: PUSH
15240: LD_INT 1
15242: ARRAY
15243: PPUSH
15244: CALL_OW 120
// Wait ( 10 ) ;
15248: LD_INT 10
15250: PPUSH
15251: CALL_OW 67
// while HasTask ( hunter ) do
15255: LD_VAR 0 1
15259: PPUSH
15260: CALL_OW 314
15264: IFFALSE 15275
// begin Wait ( 10 ) ;
15266: LD_INT 10
15268: PPUSH
15269: CALL_OW 67
// end ;
15273: GO 15255
// hunter_x_coordinate := GetX ( hunter ) ;
15275: LD_ADDR_VAR 0 13
15279: PUSH
15280: LD_VAR 0 1
15284: PPUSH
15285: CALL_OW 250
15289: ST_TO_ADDR
// hunter_y_coordinate := GetY ( hunter ) ;
15290: LD_ADDR_VAR 0 14
15294: PUSH
15295: LD_VAR 0 1
15299: PPUSH
15300: CALL_OW 251
15304: ST_TO_ADDR
// RemoveUnit ( hunter ) ;
15305: LD_VAR 0 1
15309: PPUSH
15310: CALL_OW 64
// SetClass ( hunter , class_soldier ) ;
15314: LD_VAR 0 1
15318: PPUSH
15319: LD_INT 1
15321: PPUSH
15322: CALL_OW 336
// Wait ( 0 0$2 ) ;
15326: LD_INT 70
15328: PPUSH
15329: CALL_OW 67
// if not PlaceUnitXY ( hunter , hunter_x_coordinate , hunter_y_coordinate , false ) then
15333: LD_VAR 0 1
15337: PPUSH
15338: LD_VAR 0 13
15342: PPUSH
15343: LD_VAR 0 14
15347: PPUSH
15348: LD_INT 0
15350: PPUSH
15351: CALL_OW 48
15355: NOT
15356: IFFALSE 15416
// begin range := 0 ;
15358: LD_ADDR_VAR 0 15
15362: PUSH
15363: LD_INT 0
15365: ST_TO_ADDR
// repeat Wait ( 2 ) ;
15366: LD_INT 2
15368: PPUSH
15369: CALL_OW 67
// range := range + 1 ;
15373: LD_ADDR_VAR 0 15
15377: PUSH
15378: LD_VAR 0 15
15382: PUSH
15383: LD_INT 1
15385: PLUS
15386: ST_TO_ADDR
// until PlaceUnitXYR ( hunter , hunter_x_coordinate , hunter_y_coordinate , range , false ) end ;
15387: LD_VAR 0 1
15391: PPUSH
15392: LD_VAR 0 13
15396: PPUSH
15397: LD_VAR 0 14
15401: PPUSH
15402: LD_VAR 0 15
15406: PPUSH
15407: LD_INT 0
15409: PPUSH
15410: CALL_OW 50
15414: IFFALSE 15366
// end ; animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15416: LD_ADDR_VAR 0 4
15420: PUSH
15421: LD_INT 2
15423: PUSH
15424: LD_INT 25
15426: PUSH
15427: LD_INT 18
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: PUSH
15434: LD_INT 25
15436: PUSH
15437: LD_INT 14
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: LIST
15448: PPUSH
15449: CALL_OW 69
15453: ST_TO_ADDR
// if animals = [ ] then
15454: LD_VAR 0 4
15458: PUSH
15459: EMPTY
15460: EQUAL
15461: IFFALSE 15645
// begin Randomize ;
15463: CALL_OW 10
// RandomizeAll ;
15467: CALL_OW 11
// for i := 1 to 6 do
15471: LD_ADDR_VAR 0 8
15475: PUSH
15476: DOUBLE
15477: LD_INT 1
15479: DEC
15480: ST_TO_ADDR
15481: LD_INT 6
15483: PUSH
15484: FOR_TO
15485: IFFALSE 15643
// begin uc_side = 0 ;
15487: LD_ADDR_OWVAR 20
15491: PUSH
15492: LD_INT 0
15494: ST_TO_ADDR
// uc_nation := nation_nature ;
15495: LD_ADDR_OWVAR 21
15499: PUSH
15500: LD_INT 0
15502: ST_TO_ADDR
// PrepareHuman ( 0 , class_phororhacos , 0 ) ;
15503: LD_INT 0
15505: PPUSH
15506: LD_INT 18
15508: PPUSH
15509: LD_INT 0
15511: PPUSH
15512: CALL_OW 380
// hc_name :=  ;
15516: LD_ADDR_OWVAR 26
15520: PUSH
15521: LD_STRING 
15523: ST_TO_ADDR
// Wait ( 1 ) ;
15524: LD_INT 1
15526: PPUSH
15527: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15531: CALL_OW 44
15535: PPUSH
15536: LD_INT 22
15538: PPUSH
15539: LD_INT 0
15541: PPUSH
15542: CALL_OW 49
// Wait ( 1 ) ;
15546: LD_INT 1
15548: PPUSH
15549: CALL_OW 67
// PrepareHuman ( 0 , class_tiger , 0 ) ;
15553: LD_INT 0
15555: PPUSH
15556: LD_INT 14
15558: PPUSH
15559: LD_INT 0
15561: PPUSH
15562: CALL_OW 380
// hc_name :=  ;
15566: LD_ADDR_OWVAR 26
15570: PUSH
15571: LD_STRING 
15573: ST_TO_ADDR
// Wait ( 1 ) ;
15574: LD_INT 1
15576: PPUSH
15577: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15581: CALL_OW 44
15585: PPUSH
15586: LD_INT 22
15588: PPUSH
15589: LD_INT 0
15591: PPUSH
15592: CALL_OW 49
// Wait ( 1 ) ;
15596: LD_INT 1
15598: PPUSH
15599: CALL_OW 67
// animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15603: LD_ADDR_VAR 0 4
15607: PUSH
15608: LD_INT 2
15610: PUSH
15611: LD_INT 25
15613: PUSH
15614: LD_INT 18
15616: PUSH
15617: EMPTY
15618: LIST
15619: LIST
15620: PUSH
15621: LD_INT 25
15623: PUSH
15624: LD_INT 14
15626: PUSH
15627: EMPTY
15628: LIST
15629: LIST
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: LIST
15635: PPUSH
15636: CALL_OW 69
15640: ST_TO_ADDR
// end ;
15641: GO 15484
15643: POP
15644: POP
// end ; if GetClass ( hunter ) = class_soldier then
15645: LD_VAR 0 1
15649: PPUSH
15650: CALL_OW 257
15654: PUSH
15655: LD_INT 1
15657: EQUAL
15658: IFFALSE 15678
// rnd_animal := Rand ( 4 , 6 ) else
15660: LD_ADDR_VAR 0 12
15664: PUSH
15665: LD_INT 4
15667: PPUSH
15668: LD_INT 6
15670: PPUSH
15671: CALL_OW 12
15675: ST_TO_ADDR
15676: GO 15694
// rnd_animal := Rand ( 1 , 2 ) ;
15678: LD_ADDR_VAR 0 12
15682: PUSH
15683: LD_INT 1
15685: PPUSH
15686: LD_INT 2
15688: PPUSH
15689: CALL_OW 12
15693: ST_TO_ADDR
// range := 999 ;
15694: LD_ADDR_VAR 0 15
15698: PUSH
15699: LD_INT 999
15701: ST_TO_ADDR
// osoba := hunter ;
15702: LD_ADDR_VAR 0 16
15706: PUSH
15707: LD_VAR 0 1
15711: ST_TO_ADDR
// setridene_animals := [ ] ;
15712: LD_ADDR_VAR 0 18
15716: PUSH
15717: EMPTY
15718: ST_TO_ADDR
// while animals <> [ ] do
15719: LD_VAR 0 4
15723: PUSH
15724: EMPTY
15725: NONEQUAL
15726: IFFALSE 15856
// begin for un in animals do
15728: LD_ADDR_VAR 0 3
15732: PUSH
15733: LD_VAR 0 4
15737: PUSH
15738: FOR_IN
15739: IFFALSE 15802
// begin if GetDistUnits ( osoba , un ) < range then
15741: LD_VAR 0 16
15745: PPUSH
15746: LD_VAR 0 3
15750: PPUSH
15751: CALL_OW 296
15755: PUSH
15756: LD_VAR 0 15
15760: LESS
15761: IFFALSE 15793
// begin range := GetDistUnits ( hunter , un ) ;
15763: LD_ADDR_VAR 0 15
15767: PUSH
15768: LD_VAR 0 1
15772: PPUSH
15773: LD_VAR 0 3
15777: PPUSH
15778: CALL_OW 296
15782: ST_TO_ADDR
// min := un ;
15783: LD_ADDR_VAR 0 17
15787: PUSH
15788: LD_VAR 0 3
15792: ST_TO_ADDR
// end ; Wait ( 1 ) ;
15793: LD_INT 1
15795: PPUSH
15796: CALL_OW 67
// end ;
15800: GO 15738
15802: POP
15803: POP
// setridene_animals := setridene_animals ^ min ;
15804: LD_ADDR_VAR 0 18
15808: PUSH
15809: LD_VAR 0 18
15813: PUSH
15814: LD_VAR 0 17
15818: ADD
15819: ST_TO_ADDR
// animals := animals diff min ;
15820: LD_ADDR_VAR 0 4
15824: PUSH
15825: LD_VAR 0 4
15829: PUSH
15830: LD_VAR 0 17
15834: DIFF
15835: ST_TO_ADDR
// osoba := min ;
15836: LD_ADDR_VAR 0 16
15840: PUSH
15841: LD_VAR 0 17
15845: ST_TO_ADDR
// range := 999 ;
15846: LD_ADDR_VAR 0 15
15850: PUSH
15851: LD_INT 999
15853: ST_TO_ADDR
// end ;
15854: GO 15719
// for i := 1 to rnd_animal do
15856: LD_ADDR_VAR 0 8
15860: PUSH
15861: DOUBLE
15862: LD_INT 1
15864: DEC
15865: ST_TO_ADDR
15866: LD_VAR 0 12
15870: PUSH
15871: FOR_TO
15872: IFFALSE 15903
// begin AddComAttackUnit ( hunter , setridene_animals [ i ] ) ;
15874: LD_VAR 0 1
15878: PPUSH
15879: LD_VAR 0 18
15883: PUSH
15884: LD_VAR 0 8
15888: ARRAY
15889: PPUSH
15890: CALL_OW 175
// Wait ( 10 ) ;
15894: LD_INT 10
15896: PPUSH
15897: CALL_OW 67
// end ;
15901: GO 15871
15903: POP
15904: POP
// if GetClass ( hunter ) = class_soldier then
15905: LD_VAR 0 1
15909: PPUSH
15910: CALL_OW 257
15914: PUSH
15915: LD_INT 1
15917: EQUAL
15918: IFFALSE 15923
// enable ( 102 ) ;
15920: LD_INT 102
15922: ENABLE_MARKED
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15923: LD_ADDR_VAR 0 7
15927: PUSH
15928: LD_INT 2
15930: PUSH
15931: LD_INT 30
15933: PUSH
15934: LD_INT 0
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: LD_INT 30
15943: PUSH
15944: LD_INT 1
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: LIST
15955: PPUSH
15956: CALL_OW 69
15960: ST_TO_ADDR
// if depot + 0 > 0 then
15961: LD_VAR 0 7
15965: PUSH
15966: LD_INT 0
15968: PLUS
15969: PUSH
15970: LD_INT 0
15972: GREATER
15973: IFFALSE 16079
// begin x := GetX ( depot [ 1 ] ) ;
15975: LD_ADDR_VAR 0 9
15979: PUSH
15980: LD_VAR 0 7
15984: PUSH
15985: LD_INT 1
15987: ARRAY
15988: PPUSH
15989: CALL_OW 250
15993: ST_TO_ADDR
// y := GetY ( depot [ 1 ] ) ;
15994: LD_ADDR_VAR 0 10
15998: PUSH
15999: LD_VAR 0 7
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PPUSH
16008: CALL_OW 251
16012: ST_TO_ADDR
// d := GetDir ( depot [ 1 ] ) ;
16013: LD_ADDR_VAR 0 11
16017: PUSH
16018: LD_VAR 0 7
16022: PUSH
16023: LD_INT 1
16025: ARRAY
16026: PPUSH
16027: CALL_OW 254
16031: ST_TO_ADDR
// AddComMoveXY ( hunter , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
16032: LD_VAR 0 1
16036: PPUSH
16037: LD_VAR 0 9
16041: PPUSH
16042: LD_VAR 0 11
16046: PPUSH
16047: LD_INT 7
16049: PPUSH
16050: CALL_OW 272
16054: PPUSH
16055: LD_VAR 0 10
16059: PPUSH
16060: LD_VAR 0 11
16064: PPUSH
16065: LD_INT 7
16067: PPUSH
16068: CALL_OW 273
16072: PPUSH
16073: CALL_OW 171
// end else
16077: GO 16094
// AddComMoveXY ( hunter , 83 , 40 ) ;
16079: LD_VAR 0 1
16083: PPUSH
16084: LD_INT 83
16086: PPUSH
16087: LD_INT 40
16089: PPUSH
16090: CALL_OW 171
// while HasTask ( hunter ) do
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 314
16103: IFFALSE 16114
// begin Wait ( 0 0$1 ) ;
16105: LD_INT 35
16107: PPUSH
16108: CALL_OW 67
// end ;
16112: GO 16094
// SetSide ( hunter , you ) ;
16114: LD_VAR 0 1
16118: PPUSH
16119: LD_EXP 31
16123: PPUSH
16124: CALL_OW 235
// end ;
16128: LD_VAR 0 2
16132: RET
// every 0 0$1 marked 101 do
16133: GO 16135
16135: DISABLE
// begin HuntingAsked := true ;
16136: LD_ADDR_EXP 67
16140: PUSH
16141: LD_INT 1
16143: ST_TO_ADDR
// Wait ( Rand ( 0 0$30 , 2 2$30 ) ) ;
16144: LD_INT 1050
16146: PPUSH
16147: LD_INT 5250
16149: PPUSH
16150: CALL_OW 12
16154: PPUSH
16155: CALL_OW 67
// if not ( HuntingAccepted ) and ( IsOK ( Belkov ) or IsOK ( Karamazov ) or IsOK ( Kozlov ) ) then
16159: LD_EXP 47
16163: NOT
16164: PUSH
16165: LD_EXP 3
16169: PPUSH
16170: CALL_OW 302
16174: PUSH
16175: LD_EXP 17
16179: PPUSH
16180: CALL_OW 302
16184: OR
16185: PUSH
16186: LD_EXP 20
16190: PPUSH
16191: CALL_OW 302
16195: OR
16196: AND
16197: IFFALSE 16259
// begin D_Hunting ;
16199: CALL 6013 0 0
// case Query ( QHunting ) of 1 :
16203: LD_STRING QHunting
16205: PPUSH
16206: CALL_OW 97
16210: PUSH
16211: LD_INT 1
16213: DOUBLE
16214: EQUAL
16215: IFTRUE 16219
16217: GO 16243
16219: POP
// begin HuntingAccepted := true ;
16220: LD_ADDR_EXP 47
16224: PUSH
16225: LD_INT 1
16227: ST_TO_ADDR
// D_QrHunting1 ;
16228: CALL 6328 0 0
// hunt ( hunter ) ;
16232: LD_EXP 72
16236: PPUSH
16237: CALL 15133 0 1
// end ; 2 :
16241: GO 16259
16243: LD_INT 2
16245: DOUBLE
16246: EQUAL
16247: IFTRUE 16251
16249: GO 16258
16251: POP
// D_QrHunting2 ; end ;
16252: CALL 6348 0 0
16256: GO 16259
16258: POP
// end ; end ;
16259: END
// every 0 0$1 + 0 0$0.3 marked 102 do
16260: GO 16262
16262: DISABLE
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
16263: LD_EXP 72
16267: PPUSH
16268: LD_EXP 72
16272: PPUSH
16273: CALL_OW 319
16277: PPUSH
16278: CALL_OW 296
16282: PUSH
16283: LD_INT 13
16285: LESS
16286: IFFALSE 16299
// ComCrawl ( hunter ) else
16288: LD_EXP 72
16292: PPUSH
16293: CALL_OW 137
16297: GO 16308
// ComWalk ( hunter ) ;
16299: LD_EXP 72
16303: PPUSH
16304: CALL_OW 138
// if not HasTask ( hunter ) then
16308: LD_EXP 72
16312: PPUSH
16313: CALL_OW 314
16317: NOT
16318: IFFALSE 16323
// disable else
16320: DISABLE
16321: GO 16324
// enable ;
16323: ENABLE
// end ; end_of_file
16324: END
// var ShootAreaNr , BarrelAreas , StandAreas ; every 0 0$1 marked 201 do
16325: GO 16327
16327: DISABLE
// begin GalleryAsked := true ;
16328: LD_ADDR_EXP 66
16332: PUSH
16333: LD_INT 1
16335: ST_TO_ADDR
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
16336: LD_INT 350
16338: PPUSH
16339: LD_INT 700
16341: PPUSH
16342: CALL_OW 12
16346: PPUSH
16347: CALL_OW 67
// D_FiringRange ;
16351: CALL 5832 0 0
// case Query ( QShootingGallery ) of 1 :
16355: LD_STRING QShootingGallery
16357: PPUSH
16358: CALL_OW 97
16362: PUSH
16363: LD_INT 1
16365: DOUBLE
16366: EQUAL
16367: IFTRUE 16371
16369: GO 16468
16371: POP
// begin GalleryBuild := true ;
16372: LD_ADDR_EXP 53
16376: PUSH
16377: LD_INT 1
16379: ST_TO_ADDR
// D_QrShootingGallery1 ;
16380: CALL 5973 0 0
// Wait ( 0 0$2 ) ;
16384: LD_INT 70
16386: PPUSH
16387: CALL_OW 67
// Hint ( ShootingGallery ) ;
16391: LD_STRING ShootingGallery
16393: PPUSH
16394: CALL_OW 339
// ShootAreaNr := 1 ;
16398: LD_ADDR_LOC 8
16402: PUSH
16403: LD_INT 1
16405: ST_TO_ADDR
// BarrelAreas := [ BarrelArea1 , BarrelArea2 , BarrelArea3 , BarrelArea4 , BarrelArea5 ] ;
16406: LD_ADDR_LOC 9
16410: PUSH
16411: LD_INT 12
16413: PUSH
16414: LD_INT 13
16416: PUSH
16417: LD_INT 14
16419: PUSH
16420: LD_INT 15
16422: PUSH
16423: LD_INT 16
16425: PUSH
16426: EMPTY
16427: LIST
16428: LIST
16429: LIST
16430: LIST
16431: LIST
16432: ST_TO_ADDR
// StandAreas := [ StandArea1 , StandArea2 , StandArea3 , StandArea4 , StandArea5 ] ;
16433: LD_ADDR_LOC 10
16437: PUSH
16438: LD_INT 17
16440: PUSH
16441: LD_INT 18
16443: PUSH
16444: LD_INT 19
16446: PUSH
16447: LD_INT 20
16449: PUSH
16450: LD_INT 21
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: LIST
16457: LIST
16458: LIST
16459: ST_TO_ADDR
// enable ( 202 ) ;
16460: LD_INT 202
16462: ENABLE_MARKED
// enable ( 203 ) ;
16463: LD_INT 203
16465: ENABLE_MARKED
// end ; 2 :
16466: GO 16494
16468: LD_INT 2
16470: DOUBLE
16471: EQUAL
16472: IFTRUE 16476
16474: GO 16493
16476: POP
// begin D_QrShootingGallery2 ;
16477: CALL 5993 0 0
// SetAreaMapShow ( ShootArea , 0 ) ;
16481: LD_INT 11
16483: PPUSH
16484: LD_INT 0
16486: PPUSH
16487: CALL_OW 424
// end ; end ;
16491: GO 16494
16493: POP
// end ;
16494: END
// every 0 0$0.5 marked 202 do var shooters , un , buildings ;
16495: GO 16497
16497: DISABLE
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
16502: PPUSH
// begin enable ;
16503: ENABLE
// shooters := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_not , [ f_hastask ] ] , [ f_nation , nation_russian ] ] ) ;
16504: LD_ADDR_VAR 0 1
16508: PUSH
16509: LD_INT 11
16511: PPUSH
16512: LD_INT 21
16514: PUSH
16515: LD_INT 1
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: LD_INT 3
16524: PUSH
16525: LD_INT 60
16527: PUSH
16528: EMPTY
16529: LIST
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 23
16537: PUSH
16538: LD_INT 3
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: LIST
16549: PPUSH
16550: CALL_OW 70
16554: ST_TO_ADDR
// if shooters <> [ ] then
16555: LD_VAR 0 1
16559: PUSH
16560: EMPTY
16561: NONEQUAL
16562: IFFALSE 17104
// begin for un in shooters do
16564: LD_ADDR_VAR 0 2
16568: PUSH
16569: LD_VAR 0 1
16573: PUSH
16574: FOR_IN
16575: IFFALSE 17102
// begin buildings := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
16577: LD_ADDR_VAR 0 3
16581: PUSH
16582: LD_INT 22
16584: PUSH
16585: LD_EXP 31
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 2
16596: PUSH
16597: LD_INT 30
16599: PUSH
16600: LD_INT 0
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: PUSH
16607: LD_INT 30
16609: PUSH
16610: LD_INT 1
16612: PUSH
16613: EMPTY
16614: LIST
16615: LIST
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: LIST
16621: PUSH
16622: EMPTY
16623: LIST
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL_OW 69
16633: ST_TO_ADDR
// if buildings <> [ ] then
16634: LD_VAR 0 3
16638: PUSH
16639: EMPTY
16640: NONEQUAL
16641: IFFALSE 17100
// begin if not ( GetClass ( un ) = class_engineer ) then
16643: LD_VAR 0 2
16647: PPUSH
16648: CALL_OW 257
16652: PUSH
16653: LD_INT 2
16655: EQUAL
16656: NOT
16657: IFFALSE 16901
// begin ComMoveXY ( un , ShiftX ( GetX ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) , ShiftY ( GetY ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) ) ;
16659: LD_VAR 0 2
16663: PPUSH
16664: LD_VAR 0 3
16668: PUSH
16669: LD_INT 1
16671: ARRAY
16672: PPUSH
16673: CALL_OW 250
16677: PPUSH
16678: LD_VAR 0 3
16682: PUSH
16683: LD_INT 1
16685: ARRAY
16686: PPUSH
16687: CALL_OW 254
16691: PPUSH
16692: LD_INT 3
16694: PPUSH
16695: CALL_OW 272
16699: PPUSH
16700: LD_VAR 0 3
16704: PUSH
16705: LD_INT 1
16707: ARRAY
16708: PPUSH
16709: CALL_OW 251
16713: PPUSH
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 1
16721: ARRAY
16722: PPUSH
16723: CALL_OW 254
16727: PPUSH
16728: LD_INT 3
16730: PPUSH
16731: CALL_OW 273
16735: PPUSH
16736: CALL_OW 111
// Wait ( 10 ) ;
16740: LD_INT 10
16742: PPUSH
16743: CALL_OW 67
// while HasTask ( un ) do
16747: LD_VAR 0 2
16751: PPUSH
16752: CALL_OW 314
16756: IFFALSE 16767
// begin Wait ( 10 ) ;
16758: LD_INT 10
16760: PPUSH
16761: CALL_OW 67
// end ;
16765: GO 16747
// if UnitsInside ( buildings [ 1 ] ) = 6 then
16767: LD_VAR 0 3
16771: PUSH
16772: LD_INT 1
16774: ARRAY
16775: PPUSH
16776: CALL_OW 313
16780: PUSH
16781: LD_INT 6
16783: EQUAL
16784: IFFALSE 16841
// begin ComExitBuilding ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) ;
16786: LD_VAR 0 3
16790: PUSH
16791: LD_INT 1
16793: ARRAY
16794: PPUSH
16795: CALL_OW 313
16799: PUSH
16800: LD_INT 1
16802: ARRAY
16803: PPUSH
16804: CALL_OW 122
// while HasTask ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) do
16808: LD_VAR 0 3
16812: PUSH
16813: LD_INT 1
16815: ARRAY
16816: PPUSH
16817: CALL_OW 313
16821: PUSH
16822: LD_INT 1
16824: ARRAY
16825: PPUSH
16826: CALL_OW 314
16830: IFFALSE 16841
// begin Wait ( 10 ) ;
16832: LD_INT 10
16834: PPUSH
16835: CALL_OW 67
// end ;
16839: GO 16808
// end ; ComEnterUnit ( un , buildings [ 1 ] ) ;
16841: LD_VAR 0 2
16845: PPUSH
16846: LD_VAR 0 3
16850: PUSH
16851: LD_INT 1
16853: ARRAY
16854: PPUSH
16855: CALL_OW 120
// Wait ( 1 ) ;
16859: LD_INT 1
16861: PPUSH
16862: CALL_OW 67
// AddComChangeProfession ( un , class_engineer ) ;
16866: LD_VAR 0 2
16870: PPUSH
16871: LD_INT 2
16873: PPUSH
16874: CALL_OW 183
// Wait ( 1 ) ;
16878: LD_INT 1
16880: PPUSH
16881: CALL_OW 67
// AddComExitBuilding ( un ) ;
16885: LD_VAR 0 2
16889: PPUSH
16890: CALL_OW 182
// Wait ( 1 ) ;
16894: LD_INT 1
16896: PPUSH
16897: CALL_OW 67
// end ; if GetCargo ( un , mat_oil ) = 0 then
16901: LD_VAR 0 2
16905: PPUSH
16906: LD_INT 2
16908: PPUSH
16909: CALL_OW 289
16913: PUSH
16914: LD_INT 0
16916: EQUAL
16917: IFFALSE 16940
// AddComTransport ( un , buildings [ 1 ] , mat_oil ) ;
16919: LD_VAR 0 2
16923: PPUSH
16924: LD_VAR 0 3
16928: PUSH
16929: LD_INT 1
16931: ARRAY
16932: PPUSH
16933: LD_INT 2
16935: PPUSH
16936: CALL_OW 211
// Wait ( 1 ) ;
16940: LD_INT 1
16942: PPUSH
16943: CALL_OW 67
// repeat Wait ( 0 0$1 ) until not HasTask ( un ) ;
16947: LD_INT 35
16949: PPUSH
16950: CALL_OW 67
16954: LD_VAR 0 2
16958: PPUSH
16959: CALL_OW 314
16963: NOT
16964: IFFALSE 16947
// if GetCargo ( un , mat_oil ) <> 0 then
16966: LD_VAR 0 2
16970: PPUSH
16971: LD_INT 2
16973: PPUSH
16974: CALL_OW 289
16978: PUSH
16979: LD_INT 0
16981: NONEQUAL
16982: IFFALSE 17100
// begin AddComMoveToArea ( un , BarrelAreas [ ShootAreaNr ] ) ;
16984: LD_VAR 0 2
16988: PPUSH
16989: LD_LOC 9
16993: PUSH
16994: LD_LOC 8
16998: ARRAY
16999: PPUSH
17000: CALL_OW 173
// Wait ( 1 ) ;
17004: LD_INT 1
17006: PPUSH
17007: CALL_OW 67
// AddComUnload ( un ) ;
17011: LD_VAR 0 2
17015: PPUSH
17016: CALL_OW 219
// Wait ( 1 ) ;
17020: LD_INT 1
17022: PPUSH
17023: CALL_OW 67
// AddComSailEvent ( un , un ) ;
17027: LD_VAR 0 2
17031: PPUSH
17032: LD_VAR 0 2
17036: PPUSH
17037: CALL_OW 224
// AddComMoveToArea ( un , StandAreas [ ShootAreaNr ] ) ;
17041: LD_VAR 0 2
17045: PPUSH
17046: LD_LOC 10
17050: PUSH
17051: LD_LOC 8
17055: ARRAY
17056: PPUSH
17057: CALL_OW 173
// Wait ( 1 ) ;
17061: LD_INT 1
17063: PPUSH
17064: CALL_OW 67
// ShootAreaNr := ShootAreaNr + 1 ;
17068: LD_ADDR_LOC 8
17072: PUSH
17073: LD_LOC 8
17077: PUSH
17078: LD_INT 1
17080: PLUS
17081: ST_TO_ADDR
// if ShootAreaNr = 6 then
17082: LD_LOC 8
17086: PUSH
17087: LD_INT 6
17089: EQUAL
17090: IFFALSE 17100
// ShootAreaNr := 1 ;
17092: LD_ADDR_LOC 8
17096: PUSH
17097: LD_INT 1
17099: ST_TO_ADDR
// end ; end ; end ;
17100: GO 16574
17102: POP
17103: POP
// end ; end ;
17104: PPOPN 3
17106: END
// every 0 0$0.1 + 0 0$0.05 marked 203 do var un , shoot_filter ;
17107: GO 17109
17109: DISABLE
17110: LD_INT 0
17112: PPUSH
17113: PPUSH
// begin shoot_filter := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_hastask ] , [ f_nation , nation_russian ] ] ) ;
17114: LD_ADDR_VAR 0 2
17118: PUSH
17119: LD_INT 11
17121: PPUSH
17122: LD_INT 21
17124: PUSH
17125: LD_INT 1
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PUSH
17132: LD_INT 25
17134: PUSH
17135: LD_INT 2
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: LD_INT 60
17144: PUSH
17145: EMPTY
17146: LIST
17147: PUSH
17148: LD_INT 23
17150: PUSH
17151: LD_INT 3
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: PPUSH
17164: CALL_OW 70
17168: ST_TO_ADDR
// if shoot_filter <> [ ] then
17169: LD_VAR 0 2
17173: PUSH
17174: EMPTY
17175: NONEQUAL
17176: IFFALSE 17292
// for un in shoot_filter do
17178: LD_ADDR_VAR 0 1
17182: PUSH
17183: LD_VAR 0 2
17187: PUSH
17188: FOR_IN
17189: IFFALSE 17290
// if GetTaskList ( un ) <> [ ] then
17191: LD_VAR 0 1
17195: PPUSH
17196: CALL_OW 437
17200: PUSH
17201: EMPTY
17202: NONEQUAL
17203: IFFALSE 17288
// if ( GetTaskList ( un ) [ 1 ] [ 1 ] = A ) and ( InArea ( GetTaskList ( un ) [ 1 ] [ 2 ] , GetTaskList ( un ) [ 1 ] [ 3 ] , ShootArea ) ) then
17205: LD_VAR 0 1
17209: PPUSH
17210: CALL_OW 437
17214: PUSH
17215: LD_INT 1
17217: ARRAY
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PUSH
17223: LD_STRING A
17225: EQUAL
17226: PUSH
17227: LD_VAR 0 1
17231: PPUSH
17232: CALL_OW 437
17236: PUSH
17237: LD_INT 1
17239: ARRAY
17240: PUSH
17241: LD_INT 2
17243: ARRAY
17244: PPUSH
17245: LD_VAR 0 1
17249: PPUSH
17250: CALL_OW 437
17254: PUSH
17255: LD_INT 1
17257: ARRAY
17258: PUSH
17259: LD_INT 3
17261: ARRAY
17262: PPUSH
17263: LD_INT 11
17265: PPUSH
17266: CALL_OW 309
17270: AND
17271: IFFALSE 17288
// AddExperience ( un , skill_combat , 1 ) ;
17273: LD_VAR 0 1
17277: PPUSH
17278: LD_INT 1
17280: PPUSH
17281: LD_INT 1
17283: PPUSH
17284: CALL_OW 492
17288: GO 17188
17290: POP
17291: POP
// enable ;
17292: ENABLE
// end ;
17293: PPOPN 2
17295: END
// on SailEvent ( un ) do var x , y , i ;
17296: LD_INT 0
17298: PPUSH
17299: PPUSH
17300: PPUSH
// begin x := GetX ( un ) ;
17301: LD_ADDR_VAR 0 2
17305: PUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 250
17315: ST_TO_ADDR
// y := GetY ( un ) ;
17316: LD_ADDR_VAR 0 3
17320: PUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 251
17330: ST_TO_ADDR
// for i := 0 to 5 do
17331: LD_ADDR_VAR 0 4
17335: PUSH
17336: DOUBLE
17337: LD_INT 0
17339: DEC
17340: ST_TO_ADDR
17341: LD_INT 5
17343: PUSH
17344: FOR_TO
17345: IFFALSE 17441
// if HexInfo ( ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) = - 1 then
17347: LD_VAR 0 2
17351: PPUSH
17352: LD_VAR 0 4
17356: PPUSH
17357: LD_INT 1
17359: PPUSH
17360: CALL_OW 272
17364: PPUSH
17365: LD_VAR 0 3
17369: PPUSH
17370: LD_VAR 0 4
17374: PPUSH
17375: LD_INT 1
17377: PPUSH
17378: CALL_OW 273
17382: PPUSH
17383: CALL_OW 428
17387: PUSH
17388: LD_INT 1
17390: NEG
17391: EQUAL
17392: IFFALSE 17439
// AddComAttackPlace ( un , ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) ;
17394: LD_VAR 0 1
17398: PPUSH
17399: LD_VAR 0 2
17403: PPUSH
17404: LD_VAR 0 4
17408: PPUSH
17409: LD_INT 1
17411: PPUSH
17412: CALL_OW 272
17416: PPUSH
17417: LD_VAR 0 3
17421: PPUSH
17422: LD_VAR 0 4
17426: PPUSH
17427: LD_INT 1
17429: PPUSH
17430: CALL_OW 273
17434: PPUSH
17435: CALL_OW 176
17439: GO 17344
17441: POP
17442: POP
// end ; end_of_file
17443: PPOPN 4
17445: END
// every 0 0$1 marked 301 do var filter , x , y , d , lidi ;
17446: GO 17448
17448: DISABLE
17449: LD_INT 0
17451: PPUSH
17452: PPUSH
17453: PPUSH
17454: PPUSH
17455: PPUSH
// begin FreetimeAsked := true ;
17456: LD_ADDR_EXP 68
17460: PUSH
17461: LD_INT 1
17463: ST_TO_ADDR
// if not FreeTimeGranted and ( IsOK ( Petrovova ) or IsOK ( Kirilenkova ) or IsOK ( Kapitsova ) ) and ( IsOK ( Kuzmov ) or IsOK ( Gnyevko ) or IsOK ( Titov ) or IsOK ( Oblukov ) ) then
17464: LD_EXP 59
17468: NOT
17469: PUSH
17470: LD_EXP 21
17474: PPUSH
17475: CALL_OW 302
17479: PUSH
17480: LD_EXP 4
17484: PPUSH
17485: CALL_OW 302
17489: OR
17490: PUSH
17491: LD_EXP 6
17495: PPUSH
17496: CALL_OW 302
17500: OR
17501: AND
17502: PUSH
17503: LD_EXP 10
17507: PPUSH
17508: CALL_OW 302
17512: PUSH
17513: LD_EXP 5
17517: PPUSH
17518: CALL_OW 302
17522: OR
17523: PUSH
17524: LD_EXP 18
17528: PPUSH
17529: CALL_OW 302
17533: OR
17534: PUSH
17535: LD_EXP 19
17539: PPUSH
17540: CALL_OW 302
17544: OR
17545: AND
17546: IFFALSE 18010
// begin D_FreeTime ;
17548: CALL 6368 0 0
// case Query ( QFreeTime ) of 1 :
17552: LD_STRING QFreeTime
17554: PPUSH
17555: CALL_OW 97
17559: PUSH
17560: LD_INT 1
17562: DOUBLE
17563: EQUAL
17564: IFTRUE 17568
17566: GO 17994
17568: POP
// begin FreeTimeGranted := true ;
17569: LD_ADDR_EXP 59
17573: PUSH
17574: LD_INT 1
17576: ST_TO_ADDR
// D_QrFreeTime1 ;
17577: CALL 6835 0 0
// ComExitVehicle ( [ FreeMan , FreeWoman ] ) ;
17581: LD_EXP 57
17585: PUSH
17586: LD_EXP 58
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 121
// SetSide ( [ FreeMan , FreeWoman ] , ally ) ;
17599: LD_EXP 57
17603: PUSH
17604: LD_EXP 58
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: PPUSH
17613: LD_EXP 32
17617: PPUSH
17618: CALL_OW 235
// ComMoveXY ( [ FreeMan , FreeWoman ] , 115 , 32 ) ;
17622: LD_EXP 57
17626: PUSH
17627: LD_EXP 58
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: PPUSH
17636: LD_INT 115
17638: PPUSH
17639: LD_INT 32
17641: PPUSH
17642: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
17646: LD_INT 35
17648: PPUSH
17649: CALL_OW 67
// lidi := FilterUnitsInArea ( HandOverEnterArea , [ f_side , ally ] ) ;
17653: LD_ADDR_VAR 0 5
17657: PUSH
17658: LD_INT 6
17660: PPUSH
17661: LD_INT 22
17663: PUSH
17664: LD_EXP 32
17668: PUSH
17669: EMPTY
17670: LIST
17671: LIST
17672: PPUSH
17673: CALL_OW 70
17677: ST_TO_ADDR
// until ( 0 + lidi ) = 2 ;
17678: LD_INT 0
17680: PUSH
17681: LD_VAR 0 5
17685: PLUS
17686: PUSH
17687: LD_INT 2
17689: EQUAL
17690: IFFALSE 17646
// RemoveUnit ( FreeMan ) ;
17692: LD_EXP 57
17696: PPUSH
17697: CALL_OW 64
// RemoveUnit ( FreeWoman ) ;
17701: LD_EXP 58
17705: PPUSH
17706: CALL_OW 64
// Wait ( 3 3$0 ) ;
17710: LD_INT 6300
17712: PPUSH
17713: CALL_OW 67
// PlaceUnitArea ( FreeMan , HandOverEnterArea , false ) ;
17717: LD_EXP 57
17721: PPUSH
17722: LD_INT 6
17724: PPUSH
17725: LD_INT 0
17727: PPUSH
17728: CALL_OW 49
// PlaceUnitArea ( FreeWoman , HandOverEnterArea , false ) ;
17732: LD_EXP 58
17736: PPUSH
17737: LD_INT 6
17739: PPUSH
17740: LD_INT 0
17742: PPUSH
17743: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
17747: LD_ADDR_VAR 0 1
17751: PUSH
17752: LD_INT 22
17754: PUSH
17755: LD_EXP 31
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: PUSH
17764: LD_INT 2
17766: PUSH
17767: LD_INT 30
17769: PUSH
17770: LD_INT 0
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: PUSH
17777: LD_INT 30
17779: PUSH
17780: LD_INT 1
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: LIST
17791: PUSH
17792: EMPTY
17793: LIST
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: PPUSH
17799: CALL_OW 69
17803: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
17804: LD_INT 0
17806: PUSH
17807: LD_VAR 0 1
17811: PLUS
17812: PUSH
17813: LD_INT 0
17815: NONEQUAL
17816: IFFALSE 17877
// begin x := GetX ( filter [ 1 ] ) ;
17818: LD_ADDR_VAR 0 2
17822: PUSH
17823: LD_VAR 0 1
17827: PUSH
17828: LD_INT 1
17830: ARRAY
17831: PPUSH
17832: CALL_OW 250
17836: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
17837: LD_ADDR_VAR 0 3
17841: PUSH
17842: LD_VAR 0 1
17846: PUSH
17847: LD_INT 1
17849: ARRAY
17850: PPUSH
17851: CALL_OW 251
17855: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
17856: LD_ADDR_VAR 0 4
17860: PUSH
17861: LD_VAR 0 1
17865: PUSH
17866: LD_INT 1
17868: ARRAY
17869: PPUSH
17870: CALL_OW 254
17874: ST_TO_ADDR
// end else
17875: GO 17915
// begin x := GetX ( Burlak ) ;
17877: LD_ADDR_VAR 0 2
17881: PUSH
17882: LD_EXP 1
17886: PPUSH
17887: CALL_OW 250
17891: ST_TO_ADDR
// y := GetY ( Burlak ) ;
17892: LD_ADDR_VAR 0 3
17896: PUSH
17897: LD_EXP 1
17901: PPUSH
17902: CALL_OW 251
17906: ST_TO_ADDR
// d := 1 ;
17907: LD_ADDR_VAR 0 4
17911: PUSH
17912: LD_INT 1
17914: ST_TO_ADDR
// end ; ComMoveXY ( [ FreeMan , FreeWoman ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
17915: LD_EXP 57
17919: PUSH
17920: LD_EXP 58
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PPUSH
17929: LD_VAR 0 2
17933: PPUSH
17934: LD_VAR 0 4
17938: PPUSH
17939: LD_INT 5
17941: PPUSH
17942: CALL_OW 272
17946: PPUSH
17947: LD_VAR 0 3
17951: PPUSH
17952: LD_VAR 0 4
17956: PPUSH
17957: LD_INT 5
17959: PPUSH
17960: CALL_OW 273
17964: PPUSH
17965: CALL_OW 111
// SetSide ( [ FreeMan , FreeWoman ] , you ) ;
17969: LD_EXP 57
17973: PUSH
17974: LD_EXP 58
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PPUSH
17983: LD_EXP 31
17987: PPUSH
17988: CALL_OW 235
// end ; 2 :
17992: GO 18010
17994: LD_INT 2
17996: DOUBLE
17997: EQUAL
17998: IFTRUE 18002
18000: GO 18009
18002: POP
// D_QrFreeTime2 ; end ;
18003: CALL 6855 0 0
18007: GO 18010
18009: POP
// end ; end ; end_of_file
18010: PPOPN 5
18012: END
// export firstQuery , secondQuery , dec , isShowingQuery ; every 0 0$1 marked 401 do
18013: GO 18015
18015: DISABLE
// begin MashaAsked := true ;
18016: LD_ADDR_EXP 70
18020: PUSH
18021: LD_INT 1
18023: ST_TO_ADDR
// D_Masha ;
18024: CALL 6875 0 0
// Query ( QMasha ) ;
18028: LD_STRING QMasha
18030: PPUSH
18031: CALL_OW 97
// D_Masha2 ;
18035: CALL 6903 0 0
// ChangeMissionObjectives ( MMasha ) ;
18039: LD_STRING MMasha
18041: PPUSH
18042: CALL_OW 337
// enable ( 402 ) ;
18046: LD_INT 402
18048: ENABLE_MARKED
// firstQuery = 1 ;
18049: LD_ADDR_EXP 96
18053: PUSH
18054: LD_INT 1
18056: ST_TO_ADDR
// secondQuery = 0 ;
18057: LD_ADDR_EXP 97
18061: PUSH
18062: LD_INT 0
18064: ST_TO_ADDR
// isShowingQuery = 0 ;
18065: LD_ADDR_EXP 99
18069: PUSH
18070: LD_INT 0
18072: ST_TO_ADDR
// end ;
18073: END
// var BurlakTimeInVehicle , QMashaQueryShown , QMashaQueryRefused , BurlakWasInVehicle , BurlakNewVehicle , BurlakOldVehicle ; every 0 0$3 marked 402 do
18074: GO 18076
18076: DISABLE
// begin if GetType ( IsInUnit ( Burlak ) ) = unit_vehicle and isShowingQuery = 0 then
18077: LD_EXP 1
18081: PPUSH
18082: CALL_OW 310
18086: PPUSH
18087: CALL_OW 247
18091: PUSH
18092: LD_INT 2
18094: EQUAL
18095: PUSH
18096: LD_EXP 99
18100: PUSH
18101: LD_INT 0
18103: EQUAL
18104: AND
18105: IFFALSE 18547
// if GetWeapon ( IsInUnit ( Burlak ) ) = 42 or GetWeapon ( IsInUnit ( Burlak ) ) = 43 or GetWeapon ( IsInUnit ( Burlak ) ) = 44 or GetWeapon ( IsInUnit ( Burlak ) ) = 45 or GetWeapon ( IsInUnit ( Burlak ) ) = 46 then
18107: LD_EXP 1
18111: PPUSH
18112: CALL_OW 310
18116: PPUSH
18117: CALL_OW 264
18121: PUSH
18122: LD_INT 42
18124: EQUAL
18125: PUSH
18126: LD_EXP 1
18130: PPUSH
18131: CALL_OW 310
18135: PPUSH
18136: CALL_OW 264
18140: PUSH
18141: LD_INT 43
18143: EQUAL
18144: OR
18145: PUSH
18146: LD_EXP 1
18150: PPUSH
18151: CALL_OW 310
18155: PPUSH
18156: CALL_OW 264
18160: PUSH
18161: LD_INT 44
18163: EQUAL
18164: OR
18165: PUSH
18166: LD_EXP 1
18170: PPUSH
18171: CALL_OW 310
18175: PPUSH
18176: CALL_OW 264
18180: PUSH
18181: LD_INT 45
18183: EQUAL
18184: OR
18185: PUSH
18186: LD_EXP 1
18190: PPUSH
18191: CALL_OW 310
18195: PPUSH
18196: CALL_OW 264
18200: PUSH
18201: LD_INT 46
18203: EQUAL
18204: OR
18205: IFFALSE 18547
// begin isShowingQuery = 1 ;
18207: LD_ADDR_EXP 99
18211: PUSH
18212: LD_INT 1
18214: ST_TO_ADDR
// if secondQuery = 1 and firstQuery = 0 then
18215: LD_EXP 97
18219: PUSH
18220: LD_INT 1
18222: EQUAL
18223: PUSH
18224: LD_EXP 96
18228: PUSH
18229: LD_INT 0
18231: EQUAL
18232: AND
18233: IFFALSE 18373
// begin dec = Query ( QMashaQuery2 ) ;
18235: LD_ADDR_EXP 98
18239: PUSH
18240: LD_STRING QMashaQuery2
18242: PPUSH
18243: CALL_OW 97
18247: ST_TO_ADDR
// if dec = 1 then
18248: LD_EXP 98
18252: PUSH
18253: LD_INT 1
18255: EQUAL
18256: IFFALSE 18346
// begin disable ;
18258: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18259: LD_ADDR_EXP 60
18263: PUSH
18264: LD_EXP 1
18268: PPUSH
18269: CALL_OW 310
18273: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18274: LD_EXP 60
18278: PPUSH
18279: LD_INT 1
18281: PPUSH
18282: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18286: LD_EXP 60
18290: PPUSH
18291: CALL_OW 265
18295: PUSH
18296: LD_EXP 60
18300: PPUSH
18301: CALL_OW 262
18305: PUSH
18306: LD_EXP 60
18310: PPUSH
18311: CALL_OW 263
18315: PUSH
18316: LD_EXP 60
18320: PPUSH
18321: CALL_OW 264
18325: PUSH
18326: EMPTY
18327: LIST
18328: LIST
18329: LIST
18330: LIST
18331: PPUSH
18332: LD_STRING Masha
18334: PPUSH
18335: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18339: LD_STRING MMashaDone
18341: PPUSH
18342: CALL_OW 337
// end ; if dec = 2 then
18346: LD_EXP 98
18350: PUSH
18351: LD_INT 2
18353: EQUAL
18354: IFFALSE 18373
// begin ComExitVehicle ( Burlak ) ;
18356: LD_EXP 1
18360: PPUSH
18361: CALL_OW 121
// isShowingQuery = 0 ;
18365: LD_ADDR_EXP 99
18369: PUSH
18370: LD_INT 0
18372: ST_TO_ADDR
// end ; end ; if firstQuery = 1 and secondQuery = 0 then
18373: LD_EXP 96
18377: PUSH
18378: LD_INT 1
18380: EQUAL
18381: PUSH
18382: LD_EXP 97
18386: PUSH
18387: LD_INT 0
18389: EQUAL
18390: AND
18391: IFFALSE 18547
// begin dec = Query ( QMashaQuery ) ;
18393: LD_ADDR_EXP 98
18397: PUSH
18398: LD_STRING QMashaQuery
18400: PPUSH
18401: CALL_OW 97
18405: ST_TO_ADDR
// if dec = 1 then
18406: LD_EXP 98
18410: PUSH
18411: LD_INT 1
18413: EQUAL
18414: IFFALSE 18504
// begin disable ;
18416: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18417: LD_ADDR_EXP 60
18421: PUSH
18422: LD_EXP 1
18426: PPUSH
18427: CALL_OW 310
18431: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18432: LD_EXP 60
18436: PPUSH
18437: LD_INT 1
18439: PPUSH
18440: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18444: LD_EXP 60
18448: PPUSH
18449: CALL_OW 265
18453: PUSH
18454: LD_EXP 60
18458: PPUSH
18459: CALL_OW 262
18463: PUSH
18464: LD_EXP 60
18468: PPUSH
18469: CALL_OW 263
18473: PUSH
18474: LD_EXP 60
18478: PPUSH
18479: CALL_OW 264
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: LIST
18488: LIST
18489: PPUSH
18490: LD_STRING Masha
18492: PPUSH
18493: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18497: LD_STRING MMashaDone
18499: PPUSH
18500: CALL_OW 337
// end ; if dec = 2 then
18504: LD_EXP 98
18508: PUSH
18509: LD_INT 2
18511: EQUAL
18512: IFFALSE 18547
// begin ComExitVehicle ( Burlak ) ;
18514: LD_EXP 1
18518: PPUSH
18519: CALL_OW 121
// firstQuery = 0 ;
18523: LD_ADDR_EXP 96
18527: PUSH
18528: LD_INT 0
18530: ST_TO_ADDR
// secondQuery = 1 ;
18531: LD_ADDR_EXP 97
18535: PUSH
18536: LD_INT 1
18538: ST_TO_ADDR
// isShowingQuery = 0 ;
18539: LD_ADDR_EXP 99
18543: PUSH
18544: LD_INT 0
18546: ST_TO_ADDR
// end ; end ; end ; enable ;
18547: ENABLE
// end ; end_of_file
18548: END
// var amcount ; export function prepare_am_attack ; var rndclass , rndlevel , i ; begin
18549: LD_INT 0
18551: PPUSH
18552: PPUSH
18553: PPUSH
18554: PPUSH
// if MercPaid then
18555: LD_EXP 39
18559: IFFALSE 18573
// amcount := weaker else
18561: LD_ADDR_LOC 17
18565: PUSH
18566: LD_EXP 75
18570: ST_TO_ADDR
18571: GO 18583
// amcount := stronger ;
18573: LD_ADDR_LOC 17
18577: PUSH
18578: LD_EXP 76
18582: ST_TO_ADDR
// for i := 1 to amcount do
18583: LD_ADDR_VAR 0 4
18587: PUSH
18588: DOUBLE
18589: LD_INT 1
18591: DEC
18592: ST_TO_ADDR
18593: LD_LOC 17
18597: PUSH
18598: FOR_TO
18599: IFFALSE 18752
// begin uc_side := usa ;
18601: LD_ADDR_OWVAR 20
18605: PUSH
18606: LD_EXP 35
18610: ST_TO_ADDR
// uc_nation := nation_american ;
18611: LD_ADDR_OWVAR 21
18615: PUSH
18616: LD_INT 1
18618: ST_TO_ADDR
// rndclass := Rand ( 1 , 3 ) ;
18619: LD_ADDR_VAR 0 2
18623: PUSH
18624: LD_INT 1
18626: PPUSH
18627: LD_INT 3
18629: PPUSH
18630: CALL_OW 12
18634: ST_TO_ADDR
// case rndclass of 1 :
18635: LD_VAR 0 2
18639: PUSH
18640: LD_INT 1
18642: DOUBLE
18643: EQUAL
18644: IFTRUE 18648
18646: GO 18666
18648: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; 2 :
18649: LD_INT 0
18651: PPUSH
18652: LD_INT 1
18654: PPUSH
18655: LD_EXP 74
18659: PPUSH
18660: CALL_OW 380
18664: GO 18719
18666: LD_INT 2
18668: DOUBLE
18669: EQUAL
18670: IFTRUE 18674
18672: GO 18692
18674: POP
// PrepareHuman ( 0 , class_sniper , am_attack_skill ) ; 3 :
18675: LD_INT 0
18677: PPUSH
18678: LD_INT 5
18680: PPUSH
18681: LD_EXP 74
18685: PPUSH
18686: CALL_OW 380
18690: GO 18719
18692: LD_INT 3
18694: DOUBLE
18695: EQUAL
18696: IFTRUE 18700
18698: GO 18718
18700: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; end ;
18701: LD_INT 0
18703: PPUSH
18704: LD_INT 1
18706: PPUSH
18707: LD_EXP 74
18711: PPUSH
18712: CALL_OW 380
18716: GO 18719
18718: POP
// hc_name :=  ;
18719: LD_ADDR_OWVAR 26
18723: PUSH
18724: LD_STRING 
18726: ST_TO_ADDR
// amattack := amattack ^ CreateHuman ;
18727: LD_ADDR_EXP 27
18731: PUSH
18732: LD_EXP 27
18736: PUSH
18737: CALL_OW 44
18741: ADD
18742: ST_TO_ADDR
// Wait ( 1 ) ;
18743: LD_INT 1
18745: PPUSH
18746: CALL_OW 67
// end ;
18750: GO 18598
18752: POP
18753: POP
// end ;
18754: LD_VAR 0 1
18758: RET
// function place_am_attack ; var i , reg_id ; begin
18759: LD_INT 0
18761: PPUSH
18762: PPUSH
18763: PPUSH
// for i := 1 to amcount do
18764: LD_ADDR_VAR 0 2
18768: PUSH
18769: DOUBLE
18770: LD_INT 1
18772: DEC
18773: ST_TO_ADDR
18774: LD_LOC 17
18778: PUSH
18779: FOR_TO
18780: IFFALSE 18812
// begin PlaceUnitArea ( amattack [ i ] , AmEnterArea , false ) ;
18782: LD_EXP 27
18786: PUSH
18787: LD_VAR 0 2
18791: ARRAY
18792: PPUSH
18793: LD_INT 9
18795: PPUSH
18796: LD_INT 0
18798: PPUSH
18799: CALL_OW 49
// Wait ( 1 ) ;
18803: LD_INT 1
18805: PPUSH
18806: CALL_OW 67
// end ;
18810: GO 18779
18812: POP
18813: POP
// reg_id := McRegistry ( usa , [ [ mc_reg_area_to_guard , WholeMapArea ] , - mc_reg_only_important , mc_reg_ignore_fog ] ) ;
18814: LD_ADDR_VAR 0 3
18818: PUSH
18819: LD_EXP 35
18823: PPUSH
18824: LD_INT 2
18826: PUSH
18827: LD_INT 10
18829: PUSH
18830: EMPTY
18831: LIST
18832: LIST
18833: PUSH
18834: LD_INT 8
18836: NEG
18837: PUSH
18838: LD_INT 7
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 399
18850: ST_TO_ADDR
// McAttack ( 100 , reg_id , amattack , [ mc_no_stop , mc_pat_aggresive , mc_murder ] ) ;
18851: LD_INT 100
18853: PPUSH
18854: LD_VAR 0 3
18858: PPUSH
18859: LD_EXP 27
18863: PPUSH
18864: LD_INT 10
18866: PUSH
18867: LD_INT 11
18869: PUSH
18870: LD_INT 12
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: LIST
18877: PPUSH
18878: CALL_OW 402
// end ;
18882: LD_VAR 0 1
18886: RET
// every 0 0$1 marked 501 do
18887: GO 18889
18889: DISABLE
// begin AmAttackStarted := true ;
18890: LD_ADDR_EXP 71
18894: PUSH
18895: LD_INT 1
18897: ST_TO_ADDR
// D_AmAttackStart ;
18898: CALL 7139 0 0
// Wait ( 0 0$15 ) ;
18902: LD_INT 525
18904: PPUSH
18905: CALL_OW 67
// place_am_attack ;
18909: CALL 18759 0 0
// enable ( 502 ) ;
18913: LD_INT 502
18915: ENABLE_MARKED
// end ;
18916: END
// every 0 0$10 marked 502 do
18917: GO 18919
18919: DISABLE
// begin if amattack = [ ] then
18920: LD_EXP 27
18924: PUSH
18925: EMPTY
18926: EQUAL
18927: IFFALSE 18944
// begin disable ;
18929: DISABLE
// AmAttackDone := true ;
18930: LD_ADDR_EXP 64
18934: PUSH
18935: LD_INT 1
18937: ST_TO_ADDR
// D_AmAttackFin ;
18938: CALL 7228 0 0
// end else
18942: GO 18945
// enable ;
18944: ENABLE
// end ; end_of_file
18945: END
// every 0 0$2 + 0 0$0.1 do
18946: GO 18948
18948: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
18949: LD_INT 22
18951: PUSH
18952: LD_INT 3
18954: PUSH
18955: EMPTY
18956: LIST
18957: LIST
18958: PUSH
18959: LD_INT 2
18961: PUSH
18962: LD_INT 25
18964: PUSH
18965: LD_INT 12
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: PUSH
18972: LD_INT 25
18974: PUSH
18975: LD_INT 16
18977: PUSH
18978: EMPTY
18979: LIST
18980: LIST
18981: PUSH
18982: LD_INT 25
18984: PUSH
18985: LD_INT 15
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 25
18994: PUSH
18995: LD_INT 17
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: LIST
19008: PUSH
19009: EMPTY
19010: LIST
19011: LIST
19012: PPUSH
19013: CALL_OW 69
19017: PUSH
19018: LD_INT 22
19020: PUSH
19021: LD_INT 3
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 21
19030: PUSH
19031: LD_INT 1
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: LD_INT 3
19040: PUSH
19041: LD_INT 2
19043: PUSH
19044: LD_INT 25
19046: PUSH
19047: LD_INT 12
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PUSH
19054: LD_INT 25
19056: PUSH
19057: LD_INT 16
19059: PUSH
19060: EMPTY
19061: LIST
19062: LIST
19063: PUSH
19064: LD_INT 25
19066: PUSH
19067: LD_INT 15
19069: PUSH
19070: EMPTY
19071: LIST
19072: LIST
19073: PUSH
19074: LD_INT 25
19076: PUSH
19077: LD_INT 17
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: LIST
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PUSH
19095: EMPTY
19096: LIST
19097: LIST
19098: LIST
19099: PPUSH
19100: CALL_OW 69
19104: GREATER
19105: IFFALSE 19116
// begin SetAchievement ( ACH_POTA ) ;
19107: LD_STRING ACH_POTA
19109: PPUSH
19110: CALL_OW 543
// exit ;
19114: GO 19117
// end ; enable ;
19116: ENABLE
// end ;
19117: END
// export function SA_OnLegionHandoverToUPF ; begin
19118: LD_INT 0
19120: PPUSH
// SetAchievement ( ACH_SC ) ;
19121: LD_STRING ACH_SC
19123: PPUSH
19124: CALL_OW 543
// end ;
19128: LD_VAR 0 1
19132: RET
// export function SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ; begin
19133: LD_INT 0
19135: PPUSH
// SetAchievement ( ACH_GAME ) ;
19136: LD_STRING ACH_GAME
19138: PPUSH
19139: CALL_OW 543
// end ; end_of_file
19143: LD_VAR 0 1
19147: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
19148: LD_INT 0
19150: PPUSH
19151: PPUSH
// if not missionNumber then
19152: LD_VAR 0 2
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 19291
// achiv := false ;
19161: LD_ADDR_VAR 0 7
19165: PUSH
19166: LD_INT 0
19168: ST_TO_ADDR
// case campaignNumber of 1 :
19169: LD_VAR 0 1
19173: PUSH
19174: LD_INT 1
19176: DOUBLE
19177: EQUAL
19178: IFTRUE 19182
19180: GO 19193
19182: POP
// achiv := ACH_GOTA ; 2 :
19183: LD_ADDR_VAR 0 7
19187: PUSH
19188: LD_STRING ACH_GOTA
19190: ST_TO_ADDR
19191: GO 19243
19193: LD_INT 2
19195: DOUBLE
19196: EQUAL
19197: IFTRUE 19201
19199: GO 19204
19201: POP
// ; 3 :
19202: GO 19243
19204: LD_INT 3
19206: DOUBLE
19207: EQUAL
19208: IFTRUE 19212
19210: GO 19223
19212: POP
// achiv := ACH_MOTSU ; 4 :
19213: LD_ADDR_VAR 0 7
19217: PUSH
19218: LD_STRING ACH_MOTSU
19220: ST_TO_ADDR
19221: GO 19243
19223: LD_INT 4
19225: DOUBLE
19226: EQUAL
19227: IFTRUE 19231
19229: GO 19242
19231: POP
// achiv := ACH_LOP ; end ;
19232: LD_ADDR_VAR 0 7
19236: PUSH
19237: LD_STRING ACH_LOP
19239: ST_TO_ADDR
19240: GO 19243
19242: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
19243: LD_OWVAR 67
19247: PUSH
19248: LD_INT 3
19250: EQUAL
19251: PUSH
19252: LD_VAR 0 7
19256: AND
19257: PUSH
19258: LD_VAR 0 3
19262: AND
19263: PUSH
19264: LD_VAR 0 4
19268: AND
19269: PUSH
19270: LD_VAR 0 5
19274: AND
19275: IFFALSE 19291
// SetAchievementEX ( achiv , missionNumber ) ;
19277: LD_VAR 0 7
19281: PPUSH
19282: LD_VAR 0 2
19286: PPUSH
19287: CALL_OW 564
// end ;
19291: LD_VAR 0 6
19295: RET

// export Burlak , Popov , Belkov , Kirilenkova , Gnyevko , Kapitsova , Dietrich , Gleb , Petrosyan , Kuzmov , Heike , Kovalyuk , Kurt , Mercenary1 , Scholtze , ASoldier1 , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Dolgov , Xavier , other , player_units , amattack , depot_build , depotX , depotY , you , ally , arab , merc , usa , GenscherBetrayed , HeikeCaptured , HeikeKilled , MercPaid , MercHandedOver , MercWillBeHandedOver , MercHandoverDone , MercHandoverArabsSpawned , MercAccepted , HeikeDismissed , PopovAsked , HuntingAccepted , BuildingsDone , TurretsDone , WeaponsDone , TechnoDone , MortarDone , GalleryBuild , AvailableWeapons , AvailableBuildings , AvailableTechno , FreeMan , FreeWoman , FreeTimeGranted , Masha , CompVehConstructed , LimitTeleportResearched , LimitTeleportTested , AmAttackDone , HeikeSend , GalleryAsked , HuntingAsked , FreetimeAsked , MortarAsked , MashaAsked , AmAttackStarted , hunter , speed , am_attack_skill , weaker , stronger , countdown , pocetmercenaries , snipers_positions , ar_human , MercenaryWillBeHealen , KurtWillBeHealen , WasSelected , CountTrees , GenCount , disabled2 , disabled3 , disabled4 , disabled5 , disabled6 , disabled7 , disabled8 , disabled9 , disabled102 ; export testing ; function read_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// you := 3 ;
   4: LD_ADDR_EXP 31
   8: PUSH
   9: LD_INT 3
  11: ST_TO_ADDR
// ally := 6 ;
  12: LD_ADDR_EXP 32
  16: PUSH
  17: LD_INT 6
  19: ST_TO_ADDR
// arab := 2 ;
  20: LD_ADDR_EXP 33
  24: PUSH
  25: LD_INT 2
  27: ST_TO_ADDR
// merc := 5 ;
  28: LD_ADDR_EXP 34
  32: PUSH
  33: LD_INT 5
  35: ST_TO_ADDR
// usa := 1 ;
  36: LD_ADDR_EXP 35
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// HeikeCaptured := LoadVariable ( HeikeCaptured , true ) ;
  44: LD_ADDR_EXP 37
  48: PUSH
  49: LD_STRING HeikeCaptured
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: CALL_OW 30
  59: ST_TO_ADDR
// SetAttitude ( you , ally , att_friend , true ) ;
  60: LD_EXP 31
  64: PPUSH
  65: LD_EXP 32
  69: PPUSH
  70: LD_INT 1
  72: PPUSH
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 80
// SetAttitude ( you , merc , att_neutral , true ) ;
  80: LD_EXP 31
  84: PPUSH
  85: LD_EXP 34
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: CALL_OW 80
// SetAttitude ( you , arab , att_neutral , true ) ;
 100: LD_EXP 31
 104: PPUSH
 105: LD_EXP 33
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: CALL_OW 80
// SetAttitude ( you , usa , att_enemy , true ) ;
 120: LD_EXP 31
 124: PPUSH
 125: LD_EXP 35
 129: PPUSH
 130: LD_INT 2
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 80
// SetAttitude ( ally , merc , att_friend , true ) ;
 140: LD_EXP 32
 144: PPUSH
 145: LD_EXP 34
 149: PPUSH
 150: LD_INT 1
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 80
// SetAttitude ( ally , arab , att_friend , true ) ;
 160: LD_EXP 32
 164: PPUSH
 165: LD_EXP 33
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 80
// SetAttitude ( ally , usa , att_friend , true ) ;
 180: LD_EXP 32
 184: PPUSH
 185: LD_EXP 35
 189: PPUSH
 190: LD_INT 1
 192: PPUSH
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 80
// SetAttitude ( merc , usa , att_neutral , true ) ;
 200: LD_EXP 34
 204: PPUSH
 205: LD_EXP 35
 209: PPUSH
 210: LD_INT 0
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: CALL_OW 80
// SetAttitude ( arab , usa , att_neutral , true ) ;
 220: LD_EXP 33
 224: PPUSH
 225: LD_EXP 35
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 1
 235: PPUSH
 236: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 240: LD_EXP 32
 244: PPUSH
 245: LD_EXP 31
 249: PPUSH
 250: CALL_OW 343
// HeikeDismissed := false ;
 254: LD_ADDR_EXP 45
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// MercAccepted := false ;
 262: LD_ADDR_EXP 44
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// MercPaid := false ;
 270: LD_ADDR_EXP 39
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// BuildingsDone := false ;
 278: LD_ADDR_EXP 48
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// WeaponsDone := false ;
 286: LD_ADDR_EXP 50
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// TechnoDone := false ;
 294: LD_ADDR_EXP 51
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// MortarDone := false ;
 302: LD_ADDR_EXP 52
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// TurretsDone := false ;
 310: LD_ADDR_EXP 49
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// GalleryBuild := false ;
 318: LD_ADDR_EXP 53
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// CompVehConstructed := false ;
 326: LD_ADDR_EXP 61
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// LimitTeleportResearched := false ;
 334: LD_ADDR_EXP 62
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// LimitTeleportTested := false ;
 342: LD_ADDR_EXP 63
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// AmAttackDone := false ;
 350: LD_ADDR_EXP 64
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// HeikeSend := false ;
 358: LD_ADDR_EXP 65
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// HeikeKilled := false ;
 366: LD_ADDR_EXP 38
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// Masha := 0 ;
 374: LD_ADDR_EXP 60
 378: PUSH
 379: LD_INT 0
 381: ST_TO_ADDR
// GalleryAsked := false ;
 382: LD_ADDR_EXP 66
 386: PUSH
 387: LD_INT 0
 389: ST_TO_ADDR
// HuntingAsked := false ;
 390: LD_ADDR_EXP 67
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// FreetimeAsked := false ;
 398: LD_ADDR_EXP 68
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// MashaAsked := false ;
 406: LD_ADDR_EXP 70
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// GenscherBetrayed := false ;
 414: LD_ADDR_EXP 36
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// AvailableWeapons := [ 42 , 43 , 44 , 45 , 46 ] ;
 422: LD_ADDR_EXP 54
 426: PUSH
 427: LD_INT 42
 429: PUSH
 430: LD_INT 43
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: LD_INT 45
 438: PUSH
 439: LD_INT 46
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// AvailableBuildings = [ ] ;
 449: LD_ADDR_EXP 55
 453: PUSH
 454: EMPTY
 455: ST_TO_ADDR
// for i := 0 to 50 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 0
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 50
 468: PUSH
 469: FOR_TO
 470: IFFALSE 510
// if GetRestrict ( i , you ) = 1 then
 472: LD_VAR 0 2
 476: PPUSH
 477: LD_EXP 31
 481: PPUSH
 482: CALL_OW 323
 486: PUSH
 487: LD_INT 1
 489: EQUAL
 490: IFFALSE 508
// AvailableBuildings := AvailableBuildings ^ i ;
 492: LD_ADDR_EXP 55
 496: PUSH
 497: LD_EXP 55
 501: PUSH
 502: LD_VAR 0 2
 506: ADD
 507: ST_TO_ADDR
 508: GO 469
 510: POP
 511: POP
// AvailableBuildings := AvailableBuildings diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
 512: LD_ADDR_EXP 55
 516: PUSH
 517: LD_EXP 55
 521: PUSH
 522: LD_INT 0
 524: PUSH
 525: LD_INT 2
 527: PUSH
 528: LD_INT 4
 530: PUSH
 531: LD_INT 6
 533: PUSH
 534: LD_INT 7
 536: PUSH
 537: LD_INT 8
 539: PUSH
 540: LD_INT 9
 542: PUSH
 543: LD_INT 10
 545: PUSH
 546: LD_INT 11
 548: PUSH
 549: LD_INT 12
 551: PUSH
 552: LD_INT 14
 554: PUSH
 555: LD_INT 22
 557: PUSH
 558: LD_INT 31
 560: PUSH
 561: LD_INT 32
 563: PUSH
 564: LD_INT 33
 566: PUSH
 567: LD_INT 39
 569: PUSH
 570: LD_INT 40
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: DIFF
 592: ST_TO_ADDR
// AvailableTechno = [ ] ;
 593: LD_ADDR_EXP 56
 597: PUSH
 598: EMPTY
 599: ST_TO_ADDR
// for i := 0 to 72 do
 600: LD_ADDR_VAR 0 2
 604: PUSH
 605: DOUBLE
 606: LD_INT 0
 608: DEC
 609: ST_TO_ADDR
 610: LD_INT 72
 612: PUSH
 613: FOR_TO
 614: IFFALSE 654
// if GetTech ( i , you ) = 1 then
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_EXP 31
 625: PPUSH
 626: CALL_OW 321
 630: PUSH
 631: LD_INT 1
 633: EQUAL
 634: IFFALSE 652
// AvailableTechno := AvailableTechno ^ i ;
 636: LD_ADDR_EXP 56
 640: PUSH
 641: LD_EXP 56
 645: PUSH
 646: LD_VAR 0 2
 650: ADD
 651: ST_TO_ADDR
 652: GO 613
 654: POP
 655: POP
// AvailableTechno := AvailableTechno diff 72 ;
 656: LD_ADDR_EXP 56
 660: PUSH
 661: LD_EXP 56
 665: PUSH
 666: LD_INT 72
 668: DIFF
 669: ST_TO_ADDR
// end ;
 670: LD_VAR 0 1
 674: RET
// function set_difficulty ; begin
 675: LD_INT 0
 677: PPUSH
// countdown := [ 2 2$0 , 1 1$30 , 1 1$0 ] [ difficulty ] ;
 678: LD_ADDR_EXP 77
 682: PUSH
 683: LD_INT 4200
 685: PUSH
 686: LD_INT 3150
 688: PUSH
 689: LD_INT 2100
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_OWVAR 67
 701: ARRAY
 702: ST_TO_ADDR
// pocetmercenaries := [ 20 , 40 , 60 ] [ difficulty ] ;
 703: LD_ADDR_EXP 78
 707: PUSH
 708: LD_INT 20
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 60
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: ST_TO_ADDR
// am_attack_skill := [ 4 , 6 , 8 ] [ difficulty ] ;
 728: LD_ADDR_EXP 74
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: LD_INT 6
 738: PUSH
 739: LD_INT 8
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_OWVAR 67
 751: ARRAY
 752: ST_TO_ADDR
// weaker := [ 10 , 15 , 20 ] [ difficulty ] ;
 753: LD_ADDR_EXP 75
 757: PUSH
 758: LD_INT 10
 760: PUSH
 761: LD_INT 15
 763: PUSH
 764: LD_INT 20
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_OWVAR 67
 776: ARRAY
 777: ST_TO_ADDR
// stronger := [ 20 , 25 , 30 ] [ difficulty ] ;
 778: LD_ADDR_EXP 76
 782: PUSH
 783: LD_INT 20
 785: PUSH
 786: LD_INT 25
 788: PUSH
 789: LD_INT 30
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: PUSH
 797: LD_OWVAR 67
 801: ARRAY
 802: ST_TO_ADDR
// speed := [ 60 60$0 , 45 45$0 , 38 38$0 ] [ difficulty ] ;
 803: LD_ADDR_EXP 73
 807: PUSH
 808: LD_INT 126000
 810: PUSH
 811: LD_INT 94500
 813: PUSH
 814: LD_INT 79800
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// snipers_positions := [ [ [ 115 , 77 ] , [ 127 , 67 ] , [ 15 , 2 ] , [ 71 , 1 ] ] , [ [ 120 , 70 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] , [ [ 115 , 77 ] , [ 127 , 67 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] ] [ difficulty ] ;
 828: LD_ADDR_EXP 79
 832: PUSH
 833: LD_INT 115
 835: PUSH
 836: LD_INT 77
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 127
 845: PUSH
 846: LD_INT 67
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 15
 855: PUSH
 856: LD_INT 2
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 71
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 120
 881: PUSH
 882: LD_INT 70
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 11
 891: PUSH
 892: LD_INT 20
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 50
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 71
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_INT 115
 938: PUSH
 939: LD_INT 77
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 127
 948: PUSH
 949: LD_INT 67
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 11
 958: PUSH
 959: LD_INT 20
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: PUSH
 966: LD_INT 15
 968: PUSH
 969: LD_INT 2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 50
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 71
 988: PUSH
 989: LD_INT 1
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: ST_TO_ADDR
// end ;
1015: LD_VAR 0 1
1019: RET
// function nacti_osobu ( ident ) ; begin
1020: LD_INT 0
1022: PPUSH
// if CheckCharacterSet ( ident ) then
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 29
1032: IFFALSE 1051
// result := CreateCharacter ( ident ) else
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: LD_VAR 0 1
1043: PPUSH
1044: CALL_OW 34
1048: ST_TO_ADDR
1049: GO 1059
// result := 0 ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// function create_people ; var def , i , x , y , un ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
1068: PPUSH
1069: PPUSH
1070: PPUSH
1071: PPUSH
// uc_side = you ;
1072: LD_ADDR_OWVAR 20
1076: PUSH
1077: LD_EXP 31
1081: ST_TO_ADDR
// uc_nation := nation_russian ;
1082: LD_ADDR_OWVAR 21
1086: PUSH
1087: LD_INT 3
1089: ST_TO_ADDR
// other := CreateCharacterSet ( survivors1 ) ;
1090: LD_ADDR_EXP 25
1094: PUSH
1095: LD_STRING survivors1
1097: PPUSH
1098: CALL_OW 31
1102: ST_TO_ADDR
// other := other union CreateCharacterSet ( survivors2 ) ;
1103: LD_ADDR_EXP 25
1107: PUSH
1108: LD_EXP 25
1112: PUSH
1113: LD_STRING survivors2
1115: PPUSH
1116: CALL_OW 31
1120: UNION
1121: ST_TO_ADDR
// other := other diff 0 ;
1122: LD_ADDR_EXP 25
1126: PUSH
1127: LD_EXP 25
1131: PUSH
1132: LD_INT 0
1134: DIFF
1135: ST_TO_ADDR
// if not testing then
1136: LD_EXP 95
1140: NOT
1141: IFFALSE 1158
// Burlak := nacti_osobu ( Burlak ) else
1143: LD_ADDR_EXP 1
1147: PUSH
1148: LD_STRING Burlak
1150: PPUSH
1151: CALL 1020 0 1
1155: ST_TO_ADDR
1156: GO 1186
// begin PrepareMechanic ( sex_male , 7 ) ;
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 383
// hc_name = Burlak ;
1168: LD_ADDR_OWVAR 26
1172: PUSH
1173: LD_STRING Burlak
1175: ST_TO_ADDR
// Burlak = CreateHuman ;
1176: LD_ADDR_EXP 1
1180: PUSH
1181: CALL_OW 44
1185: ST_TO_ADDR
// end ; Belkov := nacti_osobu ( Belkov ) ;
1186: LD_ADDR_EXP 3
1190: PUSH
1191: LD_STRING Belkov
1193: PPUSH
1194: CALL 1020 0 1
1198: ST_TO_ADDR
// Gnyevko := nacti_osobu ( Gnyevko ) ;
1199: LD_ADDR_EXP 5
1203: PUSH
1204: LD_STRING Gnyevko
1206: PPUSH
1207: CALL 1020 0 1
1211: ST_TO_ADDR
// Kirilenkova := nacti_osobu ( Kirilenkova ) ;
1212: LD_ADDR_EXP 4
1216: PUSH
1217: LD_STRING Kirilenkova
1219: PPUSH
1220: CALL 1020 0 1
1224: ST_TO_ADDR
// Kovalyuk := nacti_osobu ( Kovalyuk ) ;
1225: LD_ADDR_EXP 12
1229: PUSH
1230: LD_STRING Kovalyuk
1232: PPUSH
1233: CALL 1020 0 1
1237: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
1238: LD_ADDR_EXP 2
1242: PUSH
1243: LD_STRING Popov
1245: PPUSH
1246: CALL_OW 25
1250: ST_TO_ADDR
// Scholtze := nacti_osobu ( Scholtze ) ;
1251: LD_ADDR_EXP 15
1255: PUSH
1256: LD_STRING Scholtze
1258: PPUSH
1259: CALL 1020 0 1
1263: ST_TO_ADDR
// Kuzmov := nacti_osobu ( Kuzmov ) ;
1264: LD_ADDR_EXP 10
1268: PUSH
1269: LD_STRING Kuzmov
1271: PPUSH
1272: CALL 1020 0 1
1276: ST_TO_ADDR
// Karamazov := nacti_osobu ( Karamazov ) ;
1277: LD_ADDR_EXP 17
1281: PUSH
1282: LD_STRING Karamazov
1284: PPUSH
1285: CALL 1020 0 1
1289: ST_TO_ADDR
// Petrovova := nacti_osobu ( Petrovova ) ;
1290: LD_ADDR_EXP 21
1294: PUSH
1295: LD_STRING Petrovova
1297: PPUSH
1298: CALL 1020 0 1
1302: ST_TO_ADDR
// Gleb := nacti_osobu ( Gleb ) ;
1303: LD_ADDR_EXP 8
1307: PUSH
1308: LD_STRING Gleb
1310: PPUSH
1311: CALL 1020 0 1
1315: ST_TO_ADDR
// Petrosyan := nacti_osobu ( Petrosyan ) ;
1316: LD_ADDR_EXP 9
1320: PUSH
1321: LD_STRING Petrosyan
1323: PPUSH
1324: CALL 1020 0 1
1328: ST_TO_ADDR
// Lipshchin := nacti_osobu ( Lipshchin ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Lipshchin
1336: PPUSH
1337: CALL 1020 0 1
1341: ST_TO_ADDR
// Titov := nacti_osobu ( Titov ) ;
1342: LD_ADDR_EXP 18
1346: PUSH
1347: LD_STRING Titov
1349: PPUSH
1350: CALL 1020 0 1
1354: ST_TO_ADDR
// Dolgov := nacti_osobu ( Dolgov ) ;
1355: LD_ADDR_EXP 23
1359: PUSH
1360: LD_STRING Dolgov
1362: PPUSH
1363: CALL 1020 0 1
1367: ST_TO_ADDR
// Xavier := nacti_osobu ( Xavier ) ;
1368: LD_ADDR_EXP 24
1372: PUSH
1373: LD_STRING Xavier
1375: PPUSH
1376: CALL 1020 0 1
1380: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1381: LD_ADDR_EXP 19
1385: PUSH
1386: LD_STRING Oblukov
1388: PPUSH
1389: CALL_OW 25
1393: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
1394: LD_ADDR_EXP 20
1398: PUSH
1399: LD_STRING Kozlov
1401: PPUSH
1402: CALL_OW 25
1406: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1407: LD_ADDR_EXP 6
1411: PUSH
1412: LD_STRING Kapitsova
1414: PPUSH
1415: CALL_OW 25
1419: ST_TO_ADDR
// uc_side = ally ;
1420: LD_ADDR_OWVAR 20
1424: PUSH
1425: LD_EXP 32
1429: ST_TO_ADDR
// uc_nation := nation_arabian ;
1430: LD_ADDR_OWVAR 21
1434: PUSH
1435: LD_INT 2
1437: ST_TO_ADDR
// if not testing then
1438: LD_EXP 95
1442: NOT
1443: IFFALSE 1460
// Heike := nacti_osobu ( Heike ) else
1445: LD_ADDR_EXP 11
1449: PUSH
1450: LD_STRING Heike
1452: PPUSH
1453: CALL 1020 0 1
1457: ST_TO_ADDR
1458: GO 1488
// begin PrepareSoldier ( sex_female , 7 ) ;
1460: LD_INT 2
1462: PPUSH
1463: LD_INT 7
1465: PPUSH
1466: CALL_OW 381
// hc_name = Heike ;
1470: LD_ADDR_OWVAR 26
1474: PUSH
1475: LD_STRING Heike
1477: ST_TO_ADDR
// Heike = CreateHuman ;
1478: LD_ADDR_EXP 11
1482: PUSH
1483: CALL_OW 44
1487: ST_TO_ADDR
// end ; SetClass ( Heike , class_engineer ) ;
1488: LD_EXP 11
1492: PPUSH
1493: LD_INT 2
1495: PPUSH
1496: CALL_OW 336
// uc_side = arab ;
1500: LD_ADDR_OWVAR 20
1504: PUSH
1505: LD_EXP 33
1509: ST_TO_ADDR
// uc_nation := nation_arabian ;
1510: LD_ADDR_OWVAR 21
1514: PUSH
1515: LD_INT 2
1517: ST_TO_ADDR
// Dietrich := NewCharacter ( Dietrich ) ;
1518: LD_ADDR_EXP 7
1522: PUSH
1523: LD_STRING Dietrich
1525: PPUSH
1526: CALL_OW 25
1530: ST_TO_ADDR
// uc_side = merc ;
1531: LD_ADDR_OWVAR 20
1535: PUSH
1536: LD_EXP 34
1540: ST_TO_ADDR
// uc_nation := nation_arabian ;
1541: LD_ADDR_OWVAR 21
1545: PUSH
1546: LD_INT 2
1548: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
1549: LD_ADDR_EXP 13
1553: PUSH
1554: LD_STRING Kurt
1556: PPUSH
1557: CALL_OW 25
1561: ST_TO_ADDR
// PrepareHuman ( sex_male , class_engineer , 2 ) ;
1562: LD_INT 1
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: CALL_OW 380
// hc_name :=  ;
1575: LD_ADDR_OWVAR 26
1579: PUSH
1580: LD_STRING 
1582: ST_TO_ADDR
// Mercenary1 := CreateHuman ;
1583: LD_ADDR_EXP 14
1587: PUSH
1588: CALL_OW 44
1592: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 1 ) ;
1593: LD_INT 1
1595: PPUSH
1596: LD_INT 1
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 380
// hc_name :=  ;
1606: LD_ADDR_OWVAR 26
1610: PUSH
1611: LD_STRING 
1613: ST_TO_ADDR
// ASoldier1 := CreateHuman ;
1614: LD_ADDR_EXP 16
1618: PUSH
1619: CALL_OW 44
1623: ST_TO_ADDR
// player_units := ( [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) diff [ 0 ] ;
1624: LD_ADDR_EXP 26
1628: PUSH
1629: LD_EXP 1
1633: PUSH
1634: LD_EXP 3
1638: PUSH
1639: LD_EXP 4
1643: PUSH
1644: LD_EXP 5
1648: PUSH
1649: LD_EXP 6
1653: PUSH
1654: LD_EXP 8
1658: PUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_EXP 12
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 17
1678: PUSH
1679: LD_EXP 18
1683: PUSH
1684: LD_EXP 19
1688: PUSH
1689: LD_EXP 20
1693: PUSH
1694: LD_EXP 21
1698: PUSH
1699: LD_EXP 22
1703: PUSH
1704: LD_EXP 9
1708: PUSH
1709: LD_EXP 23
1713: PUSH
1714: LD_EXP 24
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_INT 0
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: ST_TO_ADDR
// for i = 1 to 2 do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: DOUBLE
1752: LD_INT 1
1754: DEC
1755: ST_TO_ADDR
1756: LD_INT 2
1758: PUSH
1759: FOR_TO
1760: IFFALSE 1814
// if other >= i and other [ i ] > 0 then
1762: LD_EXP 25
1766: PUSH
1767: LD_VAR 0 3
1771: GREATEREQUAL
1772: PUSH
1773: LD_EXP 25
1777: PUSH
1778: LD_VAR 0 3
1782: ARRAY
1783: PUSH
1784: LD_INT 0
1786: GREATER
1787: AND
1788: IFFALSE 1812
// player_units = player_units ^ other [ i ] ;
1790: LD_ADDR_EXP 26
1794: PUSH
1795: LD_EXP 26
1799: PUSH
1800: LD_EXP 25
1804: PUSH
1805: LD_VAR 0 3
1809: ARRAY
1810: ADD
1811: ST_TO_ADDR
1812: GO 1759
1814: POP
1815: POP
// uc_side = you ;
1816: LD_ADDR_OWVAR 20
1820: PUSH
1821: LD_EXP 31
1825: ST_TO_ADDR
// uc_nation := nation_russian ;
1826: LD_ADDR_OWVAR 21
1830: PUSH
1831: LD_INT 3
1833: ST_TO_ADDR
// if 0 + player_units < 15 then
1834: LD_INT 0
1836: PUSH
1837: LD_EXP 26
1841: PLUS
1842: PUSH
1843: LD_INT 15
1845: LESS
1846: IFFALSE 1910
// for i := 1 to 0 + other do
1848: LD_ADDR_VAR 0 3
1852: PUSH
1853: DOUBLE
1854: LD_INT 1
1856: DEC
1857: ST_TO_ADDR
1858: LD_INT 0
1860: PUSH
1861: LD_EXP 25
1865: PLUS
1866: PUSH
1867: FOR_TO
1868: IFFALSE 1908
// if 0 + player_units < 15 then
1870: LD_INT 0
1872: PUSH
1873: LD_EXP 26
1877: PLUS
1878: PUSH
1879: LD_INT 15
1881: LESS
1882: IFFALSE 1906
// player_units := player_units ^ other [ i ] ;
1884: LD_ADDR_EXP 26
1888: PUSH
1889: LD_EXP 26
1893: PUSH
1894: LD_EXP 25
1898: PUSH
1899: LD_VAR 0 3
1903: ARRAY
1904: ADD
1905: ST_TO_ADDR
1906: GO 1867
1908: POP
1909: POP
// if 0 + player_units < 15 then
1910: LD_INT 0
1912: PUSH
1913: LD_EXP 26
1917: PLUS
1918: PUSH
1919: LD_INT 15
1921: LESS
1922: IFFALSE 1987
// for i := 1 to 15 - player_units do
1924: LD_ADDR_VAR 0 3
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_INT 15
1936: PUSH
1937: LD_EXP 26
1941: MINUS
1942: PUSH
1943: FOR_TO
1944: IFFALSE 1985
// begin PrepareHuman ( 0 , 0 , 4 ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 0
1951: PPUSH
1952: LD_INT 4
1954: PPUSH
1955: CALL_OW 380
// hc_name :=  ;
1959: LD_ADDR_OWVAR 26
1963: PUSH
1964: LD_STRING 
1966: ST_TO_ADDR
// player_units := player_units ^ CreateHuman ;
1967: LD_ADDR_EXP 26
1971: PUSH
1972: LD_EXP 26
1976: PUSH
1977: CALL_OW 44
1981: ADD
1982: ST_TO_ADDR
// end ;
1983: GO 1943
1985: POP
1986: POP
// Randomize ;
1987: CALL_OW 10
// RandomizeAll ;
1991: CALL_OW 11
// for un in player_units do
1995: LD_ADDR_VAR 0 6
1999: PUSH
2000: LD_EXP 26
2004: PUSH
2005: FOR_IN
2006: IFFALSE 2025
// PlaceUnitArea ( un , EnterArea , false ) ;
2008: LD_VAR 0 6
2012: PPUSH
2013: LD_INT 3
2015: PPUSH
2016: LD_INT 0
2018: PPUSH
2019: CALL_OW 49
2023: GO 2005
2025: POP
2026: POP
// end ;
2027: LD_VAR 0 1
2031: RET
// function create_vehicles ; var i , auto ; begin
2032: LD_INT 0
2034: PPUSH
2035: PPUSH
2036: PPUSH
// for i := 1 to 5 do
2037: LD_ADDR_VAR 0 2
2041: PUSH
2042: DOUBLE
2043: LD_INT 1
2045: DEC
2046: ST_TO_ADDR
2047: LD_INT 5
2049: PUSH
2050: FOR_TO
2051: IFFALSE 2208
// begin uc_side := you ;
2053: LD_ADDR_OWVAR 20
2057: PUSH
2058: LD_EXP 31
2062: ST_TO_ADDR
// uc_nation := nation_russian ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 3
2070: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2071: LD_ADDR_OWVAR 24
2075: PUSH
2076: LD_INT 0
2078: PPUSH
2079: LD_INT 5
2081: PPUSH
2082: CALL_OW 12
2086: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2087: LD_ADDR_OWVAR 37
2091: PUSH
2092: LD_INT 21
2094: ST_TO_ADDR
// vc_engine := engine_combustion ;
2095: LD_ADDR_OWVAR 39
2099: PUSH
2100: LD_INT 1
2102: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2103: LD_ADDR_OWVAR 40
2107: PUSH
2108: LD_INT 51
2110: ST_TO_ADDR
// vc_control := control_manual ;
2111: LD_ADDR_OWVAR 38
2115: PUSH
2116: LD_INT 1
2118: ST_TO_ADDR
// auto := CreateVehicle ;
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: CALL_OW 45
2128: ST_TO_ADDR
// if i <= 4 then
2129: LD_VAR 0 2
2133: PUSH
2134: LD_INT 4
2136: LESSEQUAL
2137: IFFALSE 2156
// SetCargo ( auto , mat_cans , 100 ) else
2139: LD_VAR 0 3
2143: PPUSH
2144: LD_INT 1
2146: PPUSH
2147: LD_INT 100
2149: PPUSH
2150: CALL_OW 290
2154: GO 2171
// SetCargo ( auto , mat_oil , 100 ) ;
2156: LD_VAR 0 3
2160: PPUSH
2161: LD_INT 2
2163: PPUSH
2164: LD_INT 100
2166: PPUSH
2167: CALL_OW 290
// SetFuel ( auto , Rand ( 40 , 80 ) ) ;
2171: LD_VAR 0 3
2175: PPUSH
2176: LD_INT 40
2178: PPUSH
2179: LD_INT 80
2181: PPUSH
2182: CALL_OW 12
2186: PPUSH
2187: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2191: LD_VAR 0 3
2195: PPUSH
2196: LD_INT 3
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 49
// end ;
2206: GO 2050
2208: POP
2209: POP
// uc_side := you ;
2210: LD_ADDR_OWVAR 20
2214: PUSH
2215: LD_EXP 31
2219: ST_TO_ADDR
// uc_nation := nation_russian ;
2220: LD_ADDR_OWVAR 21
2224: PUSH
2225: LD_INT 3
2227: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2228: LD_ADDR_OWVAR 24
2232: PUSH
2233: LD_INT 0
2235: PPUSH
2236: LD_INT 5
2238: PPUSH
2239: CALL_OW 12
2243: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 22
2251: ST_TO_ADDR
// vc_engine := engine_combustion ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 1
2259: ST_TO_ADDR
// vc_weapon := ru_crane ;
2260: LD_ADDR_OWVAR 40
2264: PUSH
2265: LD_INT 52
2267: ST_TO_ADDR
// vc_control := control_manual ;
2268: LD_ADDR_OWVAR 38
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// auto := CreateVehicle ;
2276: LD_ADDR_VAR 0 3
2280: PUSH
2281: CALL_OW 45
2285: ST_TO_ADDR
// SetFuel ( auto , Rand ( 90 , 100 ) ) ;
2286: LD_VAR 0 3
2290: PPUSH
2291: LD_INT 90
2293: PPUSH
2294: LD_INT 100
2296: PPUSH
2297: CALL_OW 12
2301: PPUSH
2302: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2306: LD_VAR 0 3
2310: PPUSH
2311: LD_INT 3
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 49
// for i := 1 to 3 do
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 3
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2450
// begin uc_side := you ;
2337: LD_ADDR_OWVAR 20
2341: PUSH
2342: LD_EXP 31
2346: ST_TO_ADDR
// uc_nation := nation_russian ;
2347: LD_ADDR_OWVAR 21
2351: PUSH
2352: LD_INT 3
2354: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2355: LD_ADDR_OWVAR 24
2359: PUSH
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 5
2365: PPUSH
2366: CALL_OW 12
2370: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2371: LD_ADDR_OWVAR 37
2375: PUSH
2376: LD_INT 24
2378: ST_TO_ADDR
// vc_engine := engine_combustion ;
2379: LD_ADDR_OWVAR 39
2383: PUSH
2384: LD_INT 1
2386: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2387: LD_ADDR_OWVAR 40
2391: PUSH
2392: LD_INT 53
2394: ST_TO_ADDR
// vc_control := control_manual ;
2395: LD_ADDR_OWVAR 38
2399: PUSH
2400: LD_INT 1
2402: ST_TO_ADDR
// auto := CreateVehicle ;
2403: LD_ADDR_VAR 0 3
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetFuel ( auto , Rand ( 80 , 100 ) ) ;
2413: LD_VAR 0 3
2417: PPUSH
2418: LD_INT 80
2420: PPUSH
2421: LD_INT 100
2423: PPUSH
2424: CALL_OW 12
2428: PPUSH
2429: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2433: LD_VAR 0 3
2437: PPUSH
2438: LD_INT 3
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL_OW 49
// end ;
2448: GO 2334
2450: POP
2451: POP
// end ;
2452: LD_VAR 0 1
2456: RET
// export function create_snipers ; var xy ; begin
2457: LD_INT 0
2459: PPUSH
2460: PPUSH
// for xy in snipers_positions do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_EXP 79
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2616
// begin uc_side = usa ;
2474: LD_ADDR_OWVAR 20
2478: PUSH
2479: LD_EXP 35
2483: ST_TO_ADDR
// uc_nation := nation_american ;
2484: LD_ADDR_OWVAR 21
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
2492: LD_ADDR_OWVAR 30
2496: PUSH
2497: LD_INT 0
2499: PUSH
2500: LD_INT 0
2502: PUSH
2503: LD_INT 0
2505: PUSH
2506: LD_INT 0
2508: PUSH
2509: EMPTY
2510: LIST
2511: LIST
2512: LIST
2513: LIST
2514: ST_TO_ADDR
// hc_skills := [ difficulty - 1 , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2515: LD_ADDR_OWVAR 31
2519: PUSH
2520: LD_OWVAR 67
2524: PUSH
2525: LD_INT 1
2527: MINUS
2528: PUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: PUSH
2540: LD_INT 0
2542: PPUSH
2543: LD_INT 2
2545: PPUSH
2546: CALL_OW 12
2550: PUSH
2551: LD_INT 0
2553: PPUSH
2554: LD_INT 2
2556: PPUSH
2557: CALL_OW 12
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: LIST
2566: LIST
2567: ST_TO_ADDR
// hc_class := class_sniper ;
2568: LD_ADDR_OWVAR 28
2572: PUSH
2573: LD_INT 5
2575: ST_TO_ADDR
// hc_name :=  ;
2576: LD_ADDR_OWVAR 26
2580: PUSH
2581: LD_STRING 
2583: ST_TO_ADDR
// PlaceUnitXY ( CreateHuman , xy [ 1 ] , xy [ 2 ] , false ) ;
2584: CALL_OW 44
2588: PPUSH
2589: LD_VAR 0 2
2593: PUSH
2594: LD_INT 1
2596: ARRAY
2597: PPUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_INT 2
2605: ARRAY
2606: PPUSH
2607: LD_INT 0
2609: PPUSH
2610: CALL_OW 48
// end ;
2614: GO 2471
2616: POP
2617: POP
// end ;
2618: LD_VAR 0 1
2622: RET
// export function create_heike ; var auto , filter , x , y , d , Guard1 , Guard2 ; begin
2623: LD_INT 0
2625: PPUSH
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := ally ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_EXP 32
2642: ST_TO_ADDR
// uc_nation := nation_russian ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_INT 3
2650: ST_TO_ADDR
// uc_direction := Rand ( 3 , 5 ) ;
2651: LD_ADDR_OWVAR 24
2655: PUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 5
2661: PPUSH
2662: CALL_OW 12
2666: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2667: LD_INT 0
2669: PPUSH
2670: LD_INT 1
2672: PPUSH
2673: LD_INT 6
2675: PPUSH
2676: CALL_OW 380
// hc_name :=  ;
2680: LD_ADDR_OWVAR 26
2684: PUSH
2685: LD_STRING 
2687: ST_TO_ADDR
// Guard1 := CreateHuman ;
2688: LD_ADDR_VAR 0 7
2692: PUSH
2693: CALL_OW 44
2697: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2698: LD_INT 0
2700: PPUSH
2701: LD_INT 1
2703: PPUSH
2704: LD_INT 6
2706: PPUSH
2707: CALL_OW 380
// hc_name :=  ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING 
2718: ST_TO_ADDR
// Guard2 := CreateHuman ;
2719: LD_ADDR_VAR 0 8
2723: PUSH
2724: CALL_OW 44
2728: ST_TO_ADDR
// PlaceUnitArea ( Guard1 , EnterArea , false ) ;
2729: LD_VAR 0 7
2733: PPUSH
2734: LD_INT 3
2736: PPUSH
2737: LD_INT 0
2739: PPUSH
2740: CALL_OW 49
// PlaceUnitArea ( Guard2 , EnterArea , false ) ;
2744: LD_VAR 0 8
2748: PPUSH
2749: LD_INT 3
2751: PPUSH
2752: LD_INT 0
2754: PPUSH
2755: CALL_OW 49
// PlaceUnitArea ( Heike , EnterArea , false ) ;
2759: LD_EXP 11
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: LD_INT 0
2769: PPUSH
2770: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
2774: LD_ADDR_VAR 0 3
2778: PUSH
2779: LD_INT 22
2781: PUSH
2782: LD_EXP 31
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: LD_INT 30
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 1
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PUSH
2819: EMPTY
2820: LIST
2821: PUSH
2822: EMPTY
2823: LIST
2824: LIST
2825: PPUSH
2826: CALL_OW 69
2830: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
2831: LD_INT 0
2833: PUSH
2834: LD_VAR 0 3
2838: PLUS
2839: PUSH
2840: LD_INT 0
2842: NONEQUAL
2843: IFFALSE 2904
// begin x := GetX ( filter [ 1 ] ) ;
2845: LD_ADDR_VAR 0 4
2849: PUSH
2850: LD_VAR 0 3
2854: PUSH
2855: LD_INT 1
2857: ARRAY
2858: PPUSH
2859: CALL_OW 250
2863: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
2864: LD_ADDR_VAR 0 5
2868: PUSH
2869: LD_VAR 0 3
2873: PUSH
2874: LD_INT 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 251
2882: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
2883: LD_ADDR_VAR 0 6
2887: PUSH
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 1
2895: ARRAY
2896: PPUSH
2897: CALL_OW 254
2901: ST_TO_ADDR
// end else
2902: GO 2942
// begin x := GetX ( Burlak ) ;
2904: LD_ADDR_VAR 0 4
2908: PUSH
2909: LD_EXP 1
2913: PPUSH
2914: CALL_OW 250
2918: ST_TO_ADDR
// y := GetY ( Burlak ) ;
2919: LD_ADDR_VAR 0 5
2923: PUSH
2924: LD_EXP 1
2928: PPUSH
2929: CALL_OW 251
2933: ST_TO_ADDR
// d := 1 ;
2934: LD_ADDR_VAR 0 6
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// end ; repeat ComMoveXY ( Guard1 , x , y ) ;
2942: LD_VAR 0 7
2946: PPUSH
2947: LD_VAR 0 4
2951: PPUSH
2952: LD_VAR 0 5
2956: PPUSH
2957: CALL_OW 111
// ComMoveUnit ( Heike , Guard1 ) ;
2961: LD_EXP 11
2965: PPUSH
2966: LD_VAR 0 7
2970: PPUSH
2971: CALL_OW 112
// ComMoveUnit ( Guard2 , Heike ) ;
2975: LD_VAR 0 8
2979: PPUSH
2980: LD_EXP 11
2984: PPUSH
2985: CALL_OW 112
// Wait ( 0 0$1 ) ;
2989: LD_INT 35
2991: PPUSH
2992: CALL_OW 67
// until ( GetDistUnitXY ( Guard1 , x , y ) < 10 ) and ( GetDistUnitXY ( Guard2 , x , y ) < 10 ) ;
2996: LD_VAR 0 7
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_VAR 0 5
3010: PPUSH
3011: CALL_OW 297
3015: PUSH
3016: LD_INT 10
3018: LESS
3019: PUSH
3020: LD_VAR 0 8
3024: PPUSH
3025: LD_VAR 0 4
3029: PPUSH
3030: LD_VAR 0 5
3034: PPUSH
3035: CALL_OW 297
3039: PUSH
3040: LD_INT 10
3042: LESS
3043: AND
3044: IFFALSE 2942
// ComStop ( [ Guard1 , Guard2 , Heike ] ) ;
3046: LD_VAR 0 7
3050: PUSH
3051: LD_VAR 0 8
3055: PUSH
3056: LD_EXP 11
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 141
// Wait ( 10 ) ;
3070: LD_INT 10
3072: PPUSH
3073: CALL_OW 67
// ComMoveXY ( [ Guard1 , Guard2 ] , 113 , 29 ) ;
3077: LD_VAR 0 7
3081: PUSH
3082: LD_VAR 0 8
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PPUSH
3091: LD_INT 113
3093: PPUSH
3094: LD_INT 29
3096: PPUSH
3097: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
3101: LD_INT 35
3103: PPUSH
3104: CALL_OW 67
// until not HasTask ( Guard1 ) and not HasTask ( Guard2 ) ;
3108: LD_VAR 0 7
3112: PPUSH
3113: CALL_OW 314
3117: NOT
3118: PUSH
3119: LD_VAR 0 8
3123: PPUSH
3124: CALL_OW 314
3128: NOT
3129: AND
3130: IFFALSE 3101
// DestroyUnit ( Guard1 ) ;
3132: LD_VAR 0 7
3136: PPUSH
3137: CALL_OW 65
// DestroyUnit ( Guard2 ) ;
3141: LD_VAR 0 8
3145: PPUSH
3146: CALL_OW 65
// end ;
3150: LD_VAR 0 1
3154: RET
// export function create_kurt ; begin
3155: LD_INT 0
3157: PPUSH
// PlaceUnitArea ( Mercenary1 , MercEnterArea , false ) ;
3158: LD_EXP 14
3162: PPUSH
3163: LD_INT 4
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 49
// PlaceUnitArea ( Kurt , MercEnterArea , false ) ;
3173: LD_EXP 13
3177: PPUSH
3178: LD_INT 4
3180: PPUSH
3181: LD_INT 0
3183: PPUSH
3184: CALL_OW 49
// enable ( 2 ) ;
3188: LD_INT 2
3190: ENABLE_MARKED
// end ;
3191: LD_VAR 0 1
3195: RET
// starting begin FogOff ( false ) ;
3196: LD_INT 0
3198: PPUSH
3199: CALL_OW 344
// Randomize ;
3203: CALL_OW 10
// RandomizeAll ;
3207: CALL_OW 11
// testing = false ;
3211: LD_ADDR_EXP 95
3215: PUSH
3216: LD_INT 0
3218: ST_TO_ADDR
// InitBc ;
3219: CALL_OW 21
// InitHc ;
3223: CALL_OW 19
// InitUc ;
3227: CALL_OW 18
// InitVc ;
3231: CALL_OW 20
// disable ( 1 ) ;
3235: LD_INT 1
3237: DISABLE_MARKED
// disable ( 2 ) ;
3238: LD_INT 2
3240: DISABLE_MARKED
// disable ( 3 ) ;
3241: LD_INT 3
3243: DISABLE_MARKED
// disable ( 4 ) ;
3244: LD_INT 4
3246: DISABLE_MARKED
// disable ( 5 ) ;
3247: LD_INT 5
3249: DISABLE_MARKED
// disable ( 6 ) ;
3250: LD_INT 6
3252: DISABLE_MARKED
// disable ( 7 ) ;
3253: LD_INT 7
3255: DISABLE_MARKED
// disable ( 8 ) ;
3256: LD_INT 8
3258: DISABLE_MARKED
// disable ( 9 ) ;
3259: LD_INT 9
3261: DISABLE_MARKED
// disable ( 10 ) ;
3262: LD_INT 10
3264: DISABLE_MARKED
// disable ( 11 ) ;
3265: LD_INT 11
3267: DISABLE_MARKED
// disable ( 13 ) ;
3268: LD_INT 13
3270: DISABLE_MARKED
// disable ( 20 ) ;
3271: LD_INT 20
3273: DISABLE_MARKED
// disable ( 23 ) ;
3274: LD_INT 23
3276: DISABLE_MARKED
// disable ( 24 ) ;
3277: LD_INT 24
3279: DISABLE_MARKED
// disable ( 50 ) ;
3280: LD_INT 50
3282: DISABLE_MARKED
// disable ( 101 ) ;
3283: LD_INT 101
3285: DISABLE_MARKED
// disable ( 102 ) ;
3286: LD_INT 102
3288: DISABLE_MARKED
// disable ( 201 ) ;
3289: LD_INT 201
3291: DISABLE_MARKED
// disable ( 202 ) ;
3292: LD_INT 202
3294: DISABLE_MARKED
// disable ( 203 ) ;
3295: LD_INT 203
3297: DISABLE_MARKED
// disable ( 301 ) ;
3298: LD_INT 301
3300: DISABLE_MARKED
// disable ( 401 ) ;
3301: LD_INT 401
3303: DISABLE_MARKED
// disable ( 402 ) ;
3304: LD_INT 402
3306: DISABLE_MARKED
// disable ( 501 ) ;
3307: LD_INT 501
3309: DISABLE_MARKED
// disable ( 502 ) ;
3310: LD_INT 502
3312: DISABLE_MARKED
// disable ( 601 ) ;
3313: LD_INT 601
3315: DISABLE_MARKED
// disable ( 999 ) ;
3316: LD_INT 999
3318: DISABLE_MARKED
// PlaceTreesToArea ( TreeArea1 , [ 2 , 10 , 11 , 27 , 35 ] , 20 , 10 , 4 ) ;
3319: LD_INT 24
3321: PPUSH
3322: LD_INT 2
3324: PUSH
3325: LD_INT 10
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: LD_INT 35
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: LD_INT 20
3346: PPUSH
3347: LD_INT 10
3349: PPUSH
3350: LD_INT 4
3352: PPUSH
3353: CALL_OW 352
// PlaceTreesToArea ( TreeArea2 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3357: LD_INT 25
3359: PPUSH
3360: LD_INT 9
3362: PUSH
3363: LD_INT 10
3365: PUSH
3366: LD_INT 27
3368: PUSH
3369: LD_INT 35
3371: PUSH
3372: LD_INT 48
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: PPUSH
3382: LD_INT 20
3384: PPUSH
3385: LD_INT 10
3387: PPUSH
3388: LD_INT 4
3390: PPUSH
3391: CALL_OW 352
// PlaceTreesToArea ( TreeArea3 , [ 2 , 9 , 10 , 11 , 27 ] , 20 , 10 , 4 ) ;
3395: LD_INT 26
3397: PPUSH
3398: LD_INT 2
3400: PUSH
3401: LD_INT 9
3403: PUSH
3404: LD_INT 10
3406: PUSH
3407: LD_INT 11
3409: PUSH
3410: LD_INT 27
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PPUSH
3420: LD_INT 20
3422: PPUSH
3423: LD_INT 10
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL_OW 352
// PlaceTreesToArea ( TreeArea4 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3433: LD_INT 27
3435: PPUSH
3436: LD_INT 9
3438: PUSH
3439: LD_INT 10
3441: PUSH
3442: LD_INT 27
3444: PUSH
3445: LD_INT 35
3447: PUSH
3448: LD_INT 48
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PPUSH
3458: LD_INT 20
3460: PPUSH
3461: LD_INT 10
3463: PPUSH
3464: LD_INT 4
3466: PPUSH
3467: CALL_OW 352
// PlaceTreesToArea ( TreeArea5 , [ 2 , 9 , 10 , 11 , 48 ] , 20 , 10 , 4 ) ;
3471: LD_INT 28
3473: PPUSH
3474: LD_INT 2
3476: PUSH
3477: LD_INT 9
3479: PUSH
3480: LD_INT 10
3482: PUSH
3483: LD_INT 11
3485: PUSH
3486: LD_INT 48
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: PPUSH
3496: LD_INT 20
3498: PPUSH
3499: LD_INT 10
3501: PPUSH
3502: LD_INT 4
3504: PPUSH
3505: CALL_OW 352
// PlaceTreesToArea ( TreeArea6 , [ 2 , 11 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3509: LD_INT 29
3511: PPUSH
3512: LD_INT 2
3514: PUSH
3515: LD_INT 11
3517: PUSH
3518: LD_INT 27
3520: PUSH
3521: LD_INT 35
3523: PUSH
3524: LD_INT 48
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: PPUSH
3534: LD_INT 20
3536: PPUSH
3537: LD_INT 10
3539: PPUSH
3540: LD_INT 4
3542: PPUSH
3543: CALL_OW 352
// read_parameters ;
3547: CALL 0 0 0
// set_difficulty ;
3551: CALL 675 0 0
// create_people ;
3555: CALL 1064 0 0
// create_vehicles ;
3559: CALL 2032 0 0
// create_snipers ;
3563: CALL 2457 0 0
// prepare_am_attack ;
3567: CALL 18376 0 0
// CenterNowOnXY ( 112 , 32 ) ;
3571: LD_INT 112
3573: PPUSH
3574: LD_INT 32
3576: PPUSH
3577: CALL_OW 86
// D_Start ;
3581: CALL 4871 0 0
// SaveForQuickRestart ;
3585: CALL_OW 22
// end ;
3589: END
// every 0 0$10 marked 999 do var filter , prumer , un , un1 , un2 , distance , pole , budova1 , budova2 , i , trotskij ;
3590: GO 3592
3592: DISABLE
3593: LD_INT 0
3595: PPUSH
3596: PPUSH
3597: PPUSH
3598: PPUSH
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
3604: PPUSH
3605: PPUSH
// begin if BuildingsDone and WeaponsDone and TechnoDone and CompVehConstructed and LimitTeleportTested and Masha and AmAttackDone then
3606: LD_EXP 48
3610: PUSH
3611: LD_EXP 50
3615: AND
3616: PUSH
3617: LD_EXP 51
3621: AND
3622: PUSH
3623: LD_EXP 61
3627: AND
3628: PUSH
3629: LD_EXP 63
3633: AND
3634: PUSH
3635: LD_EXP 60
3639: AND
3640: PUSH
3641: LD_EXP 64
3645: AND
3646: IFFALSE 4867
// begin disable ;
3648: DISABLE
// gained_medals := [ ] ;
3649: LD_ADDR_OWVAR 61
3653: PUSH
3654: EMPTY
3655: ST_TO_ADDR
// missing_medals := [ ] ;
3656: LD_ADDR_OWVAR 62
3660: PUSH
3661: EMPTY
3662: ST_TO_ADDR
// if HeikeCaptured then
3663: LD_EXP 37
3667: IFFALSE 3700
// if MortarDone then
3669: LD_EXP 52
3673: IFFALSE 3687
// AddMedal ( ArabBarracks , 1 ) else
3675: LD_STRING ArabBarracks
3677: PPUSH
3678: LD_INT 1
3680: PPUSH
3681: CALL_OW 101
3685: GO 3698
// AddMedal ( ArabBarracks , - 1 ) else
3687: LD_STRING ArabBarracks
3689: PPUSH
3690: LD_INT 1
3692: NEG
3693: PPUSH
3694: CALL_OW 101
3698: GO 3735
// if tick < speed then
3700: LD_OWVAR 1
3704: PUSH
3705: LD_EXP 73
3709: LESS
3710: IFFALSE 3724
// AddMedal ( Speed , 1 ) else
3712: LD_STRING Speed
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 101
3722: GO 3735
// AddMedal ( Speed , - 1 ) ;
3724: LD_STRING Speed
3726: PPUSH
3727: LD_INT 1
3729: NEG
3730: PPUSH
3731: CALL_OW 101
// AddMedal ( ArtisticImpression , 1 ) ;
3735: LD_STRING ArtisticImpression
3737: PPUSH
3738: LD_INT 1
3740: PPUSH
3741: CALL_OW 101
// if ( 0 + player_units ) <= 11 then
3745: LD_INT 0
3747: PUSH
3748: LD_EXP 26
3752: PLUS
3753: PUSH
3754: LD_INT 11
3756: LESSEQUAL
3757: IFFALSE 3772
// AddMedal ( FavouriteCommander , - 1 ) else
3759: LD_STRING FavouriteCommander
3761: PPUSH
3762: LD_INT 1
3764: NEG
3765: PPUSH
3766: CALL_OW 101
3770: GO 3844
// if FreeTimeGranted and HuntingAccepted and GalleryBuild then
3772: LD_EXP 59
3776: PUSH
3777: LD_EXP 47
3781: AND
3782: PUSH
3783: LD_EXP 53
3787: AND
3788: IFFALSE 3802
// AddMedal ( FavouriteCommander , 1 ) else
3790: LD_STRING FavouriteCommander
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: CALL_OW 101
3800: GO 3844
// if FreeTimeGranted or HuntingAccepted or GalleryBuild then
3802: LD_EXP 59
3806: PUSH
3807: LD_EXP 47
3811: OR
3812: PUSH
3813: LD_EXP 53
3817: OR
3818: IFFALSE 3833
// AddMedal ( FavouriteCommander , - 3 ) else
3820: LD_STRING FavouriteCommander
3822: PPUSH
3823: LD_INT 3
3825: NEG
3826: PPUSH
3827: CALL_OW 101
3831: GO 3844
// AddMedal ( FavouriteCommander , - 2 ) ;
3833: LD_STRING FavouriteCommander
3835: PPUSH
3836: LD_INT 2
3838: NEG
3839: PPUSH
3840: CALL_OW 101
// if MortarDone and not HeikeDismissed then
3844: LD_EXP 52
3848: PUSH
3849: LD_EXP 45
3853: NOT
3854: AND
3855: IFFALSE 3861
// SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ;
3857: CALL 18960 0 0
// GiveMedals ( Main ) ;
3861: LD_STRING Main
3863: PPUSH
3864: CALL_OW 102
// for un1 in player_units do
3868: LD_ADDR_VAR 0 4
3872: PUSH
3873: LD_EXP 26
3877: PUSH
3878: FOR_IN
3879: IFFALSE 3910
// if IsDead ( un1 ) then
3881: LD_VAR 0 4
3885: PPUSH
3886: CALL_OW 301
3890: IFFALSE 3908
// player_units := player_units diff un1 ;
3892: LD_ADDR_EXP 26
3896: PUSH
3897: LD_EXP 26
3901: PUSH
3902: LD_VAR 0 4
3906: DIFF
3907: ST_TO_ADDR
3908: GO 3878
3910: POP
3911: POP
// RewardPeople ( player_units ) ;
3912: LD_EXP 26
3916: PPUSH
3917: CALL_OW 43
// trotskij := [ ] ;
3921: LD_ADDR_VAR 0 11
3925: PUSH
3926: EMPTY
3927: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
3928: LD_ADDR_VAR 0 1
3932: PUSH
3933: LD_INT 22
3935: PUSH
3936: LD_INT 3
3938: PUSH
3939: EMPTY
3940: LIST
3941: LIST
3942: PUSH
3943: LD_INT 30
3945: PUSH
3946: LD_INT 3
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PPUSH
3957: CALL_OW 69
3961: PUSH
3962: LD_INT 22
3964: PUSH
3965: LD_INT 3
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: PUSH
3972: LD_INT 21
3974: PUSH
3975: LD_INT 3
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: PUSH
3982: LD_INT 3
3984: PUSH
3985: LD_INT 30
3987: PUSH
3988: LD_INT 3
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PPUSH
4004: CALL_OW 69
4008: ADD
4009: ST_TO_ADDR
// for un in filter do
4010: LD_ADDR_VAR 0 3
4014: PUSH
4015: LD_VAR 0 1
4019: PUSH
4020: FOR_IN
4021: IFFALSE 4362
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
4023: LD_VAR 0 3
4027: PPUSH
4028: CALL_OW 266
4032: PUSH
4033: LD_INT 6
4035: PUSH
4036: LD_INT 7
4038: PUSH
4039: LD_INT 8
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: IN
4047: IFFALSE 4161
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4049: LD_ADDR_VAR 0 11
4053: PUSH
4054: LD_VAR 0 11
4058: PUSH
4059: LD_VAR 0 3
4063: PPUSH
4064: CALL_OW 266
4068: PUSH
4069: LD_VAR 0 3
4073: PPUSH
4074: CALL_OW 250
4078: PUSH
4079: LD_VAR 0 3
4083: PPUSH
4084: CALL_OW 251
4088: PUSH
4089: LD_VAR 0 3
4093: PPUSH
4094: CALL_OW 254
4098: PUSH
4099: LD_VAR 0 3
4103: PPUSH
4104: CALL_OW 267
4108: PUSH
4109: LD_VAR 0 3
4113: PPUSH
4114: CALL_OW 248
4118: PUSH
4119: LD_VAR 0 3
4123: PPUSH
4124: LD_INT 1
4126: PPUSH
4127: CALL_OW 268
4131: PUSH
4132: LD_VAR 0 3
4136: PPUSH
4137: LD_INT 2
4139: PPUSH
4140: CALL_OW 268
4144: PUSH
4145: EMPTY
4146: LIST
4147: LIST
4148: LIST
4149: LIST
4150: LIST
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: EMPTY
4156: LIST
4157: ADD
4158: ST_TO_ADDR
4159: GO 4360
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4161: LD_VAR 0 3
4165: PPUSH
4166: CALL_OW 266
4170: PUSH
4171: LD_INT 32
4173: PUSH
4174: LD_INT 33
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: IN
4181: IFFALSE 4278
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4183: LD_ADDR_VAR 0 11
4187: PUSH
4188: LD_VAR 0 11
4192: PUSH
4193: LD_VAR 0 3
4197: PPUSH
4198: CALL_OW 266
4202: PUSH
4203: LD_VAR 0 3
4207: PPUSH
4208: CALL_OW 250
4212: PUSH
4213: LD_VAR 0 3
4217: PPUSH
4218: CALL_OW 251
4222: PUSH
4223: LD_VAR 0 3
4227: PPUSH
4228: CALL_OW 254
4232: PUSH
4233: LD_VAR 0 3
4237: PPUSH
4238: CALL_OW 267
4242: PUSH
4243: LD_VAR 0 3
4247: PPUSH
4248: CALL_OW 248
4252: PUSH
4253: LD_VAR 0 3
4257: PPUSH
4258: CALL_OW 269
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: ADD
4275: ST_TO_ADDR
4276: GO 4360
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4278: LD_ADDR_VAR 0 11
4282: PUSH
4283: LD_VAR 0 11
4287: PUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 266
4297: PUSH
4298: LD_VAR 0 3
4302: PPUSH
4303: CALL_OW 250
4307: PUSH
4308: LD_VAR 0 3
4312: PPUSH
4313: CALL_OW 251
4317: PUSH
4318: LD_VAR 0 3
4322: PPUSH
4323: CALL_OW 254
4327: PUSH
4328: LD_VAR 0 3
4332: PPUSH
4333: CALL_OW 267
4337: PUSH
4338: LD_VAR 0 3
4342: PPUSH
4343: CALL_OW 248
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: PUSH
4356: EMPTY
4357: LIST
4358: ADD
4359: ST_TO_ADDR
// end ;
4360: GO 4020
4362: POP
4363: POP
// SaveVariable ( trotskij , Trotskij ) ;
4364: LD_VAR 0 11
4368: PPUSH
4369: LD_STRING Trotskij
4371: PPUSH
4372: CALL_OW 39
// SaveVariable ( ListEnvironmentArea ( WholeMapArea ) , Environment ) ;
4376: LD_INT 10
4378: PPUSH
4379: CALL_OW 353
4383: PPUSH
4384: LD_STRING Environment
4386: PPUSH
4387: CALL_OW 39
// SaveVariable ( HeikeKilled , HeikeKilled ) ;
4391: LD_EXP 38
4395: PPUSH
4396: LD_STRING HeikeKilled
4398: PPUSH
4399: CALL_OW 39
// SaveVariable ( MercPaid , MercPaid ) ;
4403: LD_EXP 39
4407: PPUSH
4408: LD_STRING MercPaid
4410: PPUSH
4411: CALL_OW 39
// SaveVariable ( MercHandedOver , MercHandedOver ) ;
4415: LD_EXP 40
4419: PPUSH
4420: LD_STRING MercHandedOver
4422: PPUSH
4423: CALL_OW 39
// SaveVariable ( MercAccepted , MercAccepted ) ;
4427: LD_EXP 44
4431: PPUSH
4432: LD_STRING MercAccepted
4434: PPUSH
4435: CALL_OW 39
// SaveVariable ( GenscherBetrayed , GenscherBetrayed ) ;
4439: LD_EXP 36
4443: PPUSH
4444: LD_STRING GenscherBetrayed
4446: PPUSH
4447: CALL_OW 39
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
4451: LD_EXP 60
4455: PPUSH
4456: CALL_OW 265
4460: PUSH
4461: LD_EXP 60
4465: PPUSH
4466: CALL_OW 262
4470: PUSH
4471: LD_EXP 60
4475: PPUSH
4476: CALL_OW 263
4480: PUSH
4481: LD_EXP 60
4485: PPUSH
4486: CALL_OW 264
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: LD_STRING Masha
4499: PPUSH
4500: CALL_OW 39
// SaveCharacters ( Heike , Heike ) ;
4504: LD_EXP 11
4508: PPUSH
4509: LD_STRING Heike
4511: PPUSH
4512: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
4516: LD_EXP 9
4520: PPUSH
4521: LD_STRING Petrosyan
4523: PPUSH
4524: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4528: LD_EXP 23
4532: PPUSH
4533: LD_STRING Dolgov
4535: PPUSH
4536: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4540: LD_EXP 24
4544: PPUSH
4545: LD_STRING Xavier
4547: PPUSH
4548: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
4552: LD_EXP 1
4556: PPUSH
4557: LD_STRING Burlak
4559: PPUSH
4560: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
4564: LD_EXP 3
4568: PPUSH
4569: LD_STRING Belkov
4571: PPUSH
4572: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
4576: LD_EXP 4
4580: PPUSH
4581: LD_STRING Kirilenkova
4583: PPUSH
4584: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
4588: LD_EXP 5
4592: PPUSH
4593: LD_STRING Gnyevko
4595: PPUSH
4596: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4600: LD_EXP 6
4604: PPUSH
4605: LD_STRING Kapitsova
4607: PPUSH
4608: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
4612: LD_EXP 8
4616: PPUSH
4617: LD_STRING Gleb
4619: PPUSH
4620: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
4624: LD_EXP 10
4628: PPUSH
4629: LD_STRING Kuzmov
4631: PPUSH
4632: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
4636: LD_EXP 12
4640: PPUSH
4641: LD_STRING Kovalyuk
4643: PPUSH
4644: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
4648: LD_EXP 15
4652: PPUSH
4653: LD_STRING Scholtze
4655: PPUSH
4656: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
4660: LD_EXP 17
4664: PPUSH
4665: LD_STRING Karamazov
4667: PPUSH
4668: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
4672: LD_EXP 18
4676: PPUSH
4677: LD_STRING Titov
4679: PPUSH
4680: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4684: LD_EXP 19
4688: PPUSH
4689: LD_STRING Oblukov
4691: PPUSH
4692: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4696: LD_EXP 20
4700: PPUSH
4701: LD_STRING Kozlov
4703: PPUSH
4704: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
4708: LD_EXP 21
4712: PPUSH
4713: LD_STRING Petrovova
4715: PPUSH
4716: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
4720: LD_EXP 22
4724: PPUSH
4725: LD_STRING Lipshchin
4727: PPUSH
4728: CALL_OW 38
// SaveCharacters ( ( ( player_units union other ) diff [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) , survivors3 ) ;
4732: LD_EXP 26
4736: PUSH
4737: LD_EXP 25
4741: UNION
4742: PUSH
4743: LD_EXP 1
4747: PUSH
4748: LD_EXP 3
4752: PUSH
4753: LD_EXP 4
4757: PUSH
4758: LD_EXP 5
4762: PUSH
4763: LD_EXP 6
4767: PUSH
4768: LD_EXP 8
4772: PUSH
4773: LD_EXP 10
4777: PUSH
4778: LD_EXP 12
4782: PUSH
4783: LD_EXP 15
4787: PUSH
4788: LD_EXP 17
4792: PUSH
4793: LD_EXP 18
4797: PUSH
4798: LD_EXP 19
4802: PUSH
4803: LD_EXP 20
4807: PUSH
4808: LD_EXP 21
4812: PUSH
4813: LD_EXP 22
4817: PUSH
4818: LD_EXP 9
4822: PUSH
4823: LD_EXP 23
4827: PUSH
4828: LD_EXP 24
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: DIFF
4853: PPUSH
4854: LD_STRING survivors3
4856: PPUSH
4857: CALL_OW 38
// YouWin ;
4861: CALL_OW 103
// exit ;
4865: GO 4868
// end ; enable ;
4867: ENABLE
// end ; end_of_file
4868: PPOPN 11
4870: END
// export function D_Start ; begin
4871: LD_INT 0
4873: PPUSH
// DialogueOn ;
4874: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
4878: LD_EXP 2
4882: PPUSH
4883: LD_STRING DStart-Pop-1
4885: PPUSH
4886: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
4890: LD_EXP 1
4894: PPUSH
4895: LD_STRING DStart-Bur-1
4897: PPUSH
4898: CALL_OW 88
// Wait ( 0 0$2 ) ;
4902: LD_INT 70
4904: PPUSH
4905: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
4909: LD_STRING MStart
4911: PPUSH
4912: CALL_OW 337
// display_strings := [ #Ru08-1 , ( 3 + AvailableBuildings ) , #Ru08-2 , ( 0 + AvailableWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
4916: LD_ADDR_OWVAR 47
4920: PUSH
4921: LD_STRING #Ru08-1
4923: PUSH
4924: LD_INT 3
4926: PUSH
4927: LD_EXP 55
4931: PLUS
4932: PUSH
4933: LD_STRING #Ru08-2
4935: PUSH
4936: LD_INT 0
4938: PUSH
4939: LD_EXP 54
4943: PLUS
4944: PUSH
4945: LD_STRING #Ru08-3
4947: PUSH
4948: LD_INT 0
4950: PUSH
4951: LD_EXP 56
4955: PLUS
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: LIST
4961: LIST
4962: LIST
4963: LIST
4964: ST_TO_ADDR
// DialogueOff ;
4965: CALL_OW 7
// end ;
4969: LD_VAR 0 1
4973: RET
// export function D_Heike ; begin
4974: LD_INT 0
4976: PPUSH
// Say ( Popov , DHeike-Pop-1 ) ;
4977: LD_EXP 2
4981: PPUSH
4982: LD_STRING DHeike-Pop-1
4984: PPUSH
4985: CALL_OW 88
// Wait ( 0 0$2 ) ;
4989: LD_INT 70
4991: PPUSH
4992: CALL_OW 67
// create_heike ;
4996: CALL 2623 0 0
// end ;
5000: LD_VAR 0 1
5004: RET
// export function D_HeikeKilled ; begin
5005: LD_INT 0
5007: PPUSH
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
5008: LD_EXP 11
5012: PPUSH
5013: LD_STRING DHeikeKilled-Hke-1
5015: PPUSH
5016: CALL_OW 91
// end ;
5020: LD_VAR 0 1
5024: RET
// export function D_MercHelp ; begin
5025: LD_INT 0
5027: PPUSH
// DialogueOn ;
5028: CALL_OW 6
// Say ( Kurt , DMercHelp-Kurt-1 ) ;
5032: LD_EXP 13
5036: PPUSH
5037: LD_STRING DMercHelp-Kurt-1
5039: PPUSH
5040: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-1 ) ;
5044: LD_EXP 1
5048: PPUSH
5049: LD_STRING DMercHelp-Bur-1
5051: PPUSH
5052: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-2 ) ;
5056: LD_EXP 13
5060: PPUSH
5061: LD_STRING DMercHelp-Kurt-2
5063: PPUSH
5064: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-2 ) ;
5068: LD_EXP 1
5072: PPUSH
5073: LD_STRING DMercHelp-Bur-2
5075: PPUSH
5076: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-3 ) ;
5080: LD_EXP 13
5084: PPUSH
5085: LD_STRING DMercHelp-Kurt-3
5087: PPUSH
5088: CALL_OW 88
// DialogueOff ;
5092: CALL_OW 7
// end ;
5096: LD_VAR 0 1
5100: RET
// export function D_QrMerc1 ; begin
5101: LD_INT 0
5103: PPUSH
// DialogueOn ;
5104: CALL_OW 6
// Say ( Burlak , DQrMerc#1-Bur-1 ) ;
5108: LD_EXP 1
5112: PPUSH
5113: LD_STRING DQrMerc#1-Bur-1
5115: PPUSH
5116: CALL_OW 88
// Say ( Kurt , DQrMerc#1-Kurt-1 ) ;
5120: LD_EXP 13
5124: PPUSH
5125: LD_STRING DQrMerc#1-Kurt-1
5127: PPUSH
5128: CALL_OW 88
// DialogueOff ;
5132: CALL_OW 7
// end ;
5136: LD_VAR 0 1
5140: RET
// export function D_QrMerc2 ; begin
5141: LD_INT 0
5143: PPUSH
// DialogueOn ;
5144: CALL_OW 6
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
5148: LD_EXP 1
5152: PPUSH
5153: LD_STRING DQrMerc#2-Bur-1
5155: PPUSH
5156: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
5160: LD_EXP 2
5164: PPUSH
5165: LD_STRING DQrMerc#2-Pop-1
5167: PPUSH
5168: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
5172: LD_EXP 1
5176: PPUSH
5177: LD_STRING DQrMerc#2-Bur-2
5179: PPUSH
5180: CALL_OW 88
// DialogueOff ;
5184: CALL_OW 7
// end ;
5188: LD_VAR 0 1
5192: RET
// export function D_QrMerc3 ; begin
5193: LD_INT 0
5195: PPUSH
// DialogueOn ;
5196: CALL_OW 6
// Say ( Burlak , DQrMerc#3-Bur-1 ) ;
5200: LD_EXP 1
5204: PPUSH
5205: LD_STRING DQrMerc#3-Bur-1
5207: PPUSH
5208: CALL_OW 88
// DialogueOff ;
5212: CALL_OW 7
// end ;
5216: LD_VAR 0 1
5220: RET
// export function D_MercRefuseBuild ; begin
5221: LD_INT 0
5223: PPUSH
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
5224: LD_EXP 13
5228: PPUSH
5229: LD_STRING DMercRefuseBuild-Kurt-1
5231: PPUSH
5232: CALL_OW 88
// end ;
5236: LD_VAR 0 1
5240: RET
// export function D_MercCompleted ; begin
5241: LD_INT 0
5243: PPUSH
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
5244: LD_EXP 13
5248: PPUSH
5249: LD_STRING DMercCompleted-Kurt-1
5251: PPUSH
5252: CALL_OW 88
// end ;
5256: LD_VAR 0 1
5260: RET
// export function D_MercPopov ; begin
5261: LD_INT 0
5263: PPUSH
// DialogueOn ;
5264: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
5268: LD_EXP 2
5272: PPUSH
5273: LD_STRING DMercPopov-Pop-1
5275: PPUSH
5276: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
5280: LD_EXP 1
5284: PPUSH
5285: LD_STRING DMercPopov-Bur-1
5287: PPUSH
5288: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
5292: LD_EXP 2
5296: PPUSH
5297: LD_STRING DMercPopov-Pop-2
5299: PPUSH
5300: CALL_OW 94
// DialogueOff ;
5304: CALL_OW 7
// end ;
5308: LD_VAR 0 1
5312: RET
// export function D_MercAmbush ; begin
5313: LD_INT 0
5315: PPUSH
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
5316: LD_EXP 13
5320: PPUSH
5321: LD_STRING DMercAmbush-Kurt-1
5323: PPUSH
5324: CALL_OW 88
// SetAttitude ( you , merc , att_enemy , true ) ;
5328: LD_EXP 31
5332: PPUSH
5333: LD_EXP 34
5337: PPUSH
5338: LD_INT 2
5340: PPUSH
5341: LD_INT 1
5343: PPUSH
5344: CALL_OW 80
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
5348: LD_INT 8
5350: PPUSH
5351: LD_INT 0
5353: PPUSH
5354: CALL_OW 424
// disable ( 20 ) ;
5358: LD_INT 20
5360: DISABLE_MARKED
// end ;
5361: LD_VAR 0 1
5365: RET
// export function D_MercAttack ; begin
5366: LD_INT 0
5368: PPUSH
// Say ( Kurt , DMercAttack-Kurt-1 ) ;
5369: LD_EXP 13
5373: PPUSH
5374: LD_STRING DMercAttack-Kurt-1
5376: PPUSH
5377: CALL_OW 88
// end ;
5381: LD_VAR 0 1
5385: RET
// export function D_MercDeceived ; begin
5386: LD_INT 0
5388: PPUSH
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
5389: LD_EXP 13
5393: PPUSH
5394: LD_STRING DMercDeceived-Kurt-1
5396: PPUSH
5397: CALL_OW 88
// end ;
5401: LD_VAR 0 1
5405: RET
// export function D_ArabianRequest ; begin
5406: LD_INT 0
5408: PPUSH
// DialogueOn ;
5409: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
5413: LD_EXP 7
5417: PPUSH
5418: LD_STRING DArabianRequest-Diet-1
5420: PPUSH
5421: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
5425: LD_EXP 1
5429: PPUSH
5430: LD_STRING DArabianRequest-Bur-1
5432: PPUSH
5433: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
5437: LD_EXP 7
5441: PPUSH
5442: LD_STRING DArabianRequest-Diet-2
5444: PPUSH
5445: CALL_OW 94
// case Query ( QHandOver ) of 1 :
5449: LD_STRING QHandOver
5451: PPUSH
5452: CALL_OW 97
5456: PUSH
5457: LD_INT 1
5459: DOUBLE
5460: EQUAL
5461: IFTRUE 5465
5463: GO 5480
5465: POP
// begin D_QrHandOver1 ;
5466: CALL 5513 0 0
// MercWillBeHandedOver := true ;
5470: LD_ADDR_EXP 41
5474: PUSH
5475: LD_INT 1
5477: ST_TO_ADDR
// end ; 2 :
5478: GO 5504
5480: LD_INT 2
5482: DOUBLE
5483: EQUAL
5484: IFTRUE 5488
5486: GO 5503
5488: POP
// begin MercHandedOver = false ;
5489: LD_ADDR_EXP 40
5493: PUSH
5494: LD_INT 0
5496: ST_TO_ADDR
// D_QrHandOver2 ;
5497: CALL 5557 0 0
// end ; end ;
5501: GO 5504
5503: POP
// DialogueOff ;
5504: CALL_OW 7
// end ;
5508: LD_VAR 0 1
5512: RET
// export function D_QrHandOver1 ; begin
5513: LD_INT 0
5515: PPUSH
// DialogueOn ;
5516: CALL_OW 6
// Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
5520: LD_EXP 1
5524: PPUSH
5525: LD_STRING DQrHandOver#1-Bur-1
5527: PPUSH
5528: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
5532: LD_EXP 7
5536: PPUSH
5537: LD_STRING DQrHandOver#1-Diet-1
5539: PPUSH
5540: CALL_OW 94
// DialogueOff ;
5544: CALL_OW 7
// hand_over ;
5548: CALL 8469 0 0
// end ;
5552: LD_VAR 0 1
5556: RET
// export function D_QrHandOver2 ; begin
5557: LD_INT 0
5559: PPUSH
// DialogueOn ;
5560: CALL_OW 6
// Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
5564: LD_EXP 1
5568: PPUSH
5569: LD_STRING DQrHandOver#2-Bur-1
5571: PPUSH
5572: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
5576: LD_EXP 7
5580: PPUSH
5581: LD_STRING DQrHandOver#2-Diet-1
5583: PPUSH
5584: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
5588: LD_EXP 1
5592: PPUSH
5593: LD_STRING DQrHandOver#2-Bur-2
5595: PPUSH
5596: CALL_OW 88
// DialogueOff ;
5600: CALL_OW 7
// end ;
5604: LD_VAR 0 1
5608: RET
// export function D_HandOverCome ; begin
5609: LD_INT 0
5611: PPUSH
// DialogueOn ;
5612: CALL_OW 6
// Say ( ASoldier1 , DHandOverCome-ASol1-1 ) ;
5616: LD_EXP 16
5620: PPUSH
5621: LD_STRING DHandOverCome-ASol1-1
5623: PPUSH
5624: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
5628: LD_EXP 13
5632: PPUSH
5633: LD_STRING DHandOverCome-Kurt-1
5635: PPUSH
5636: CALL_OW 88
// DialogueOff ;
5640: CALL_OW 7
// end ;
5644: LD_VAR 0 1
5648: RET
// export function D_HandOverSpoiled ; begin
5649: LD_INT 0
5651: PPUSH
// DialogueOn ;
5652: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
5656: LD_EXP 7
5660: PPUSH
5661: LD_STRING DHandOverSpoiled-Diet-1
5663: PPUSH
5664: CALL_OW 94
// DialogueOff ;
5668: CALL_OW 7
// end ;
5672: LD_VAR 0 1
5676: RET
// export function D_LegionFormed ; begin
5677: LD_INT 0
5679: PPUSH
// DialogueOn ;
5680: CALL_OW 6
// Say ( Heike , DLegionFormed-Hke-1 ) ;
5684: LD_EXP 11
5688: PPUSH
5689: LD_STRING DLegionFormed-Hke-1
5691: PPUSH
5692: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
5696: LD_EXP 1
5700: PPUSH
5701: LD_STRING DLegionFormed-Bur-1
5703: PPUSH
5704: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-2 ) ;
5708: LD_EXP 11
5712: PPUSH
5713: LD_STRING DLegionFormed-Hke-2
5715: PPUSH
5716: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
5720: LD_EXP 1
5724: PPUSH
5725: LD_STRING DLegionFormed-Bur-2
5727: PPUSH
5728: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-3 ) ;
5732: LD_EXP 11
5736: PPUSH
5737: LD_STRING DLegionFormed-Hke-3
5739: PPUSH
5740: CALL_OW 88
// DialogueOff ;
5744: CALL_OW 7
// end ;
5748: LD_VAR 0 1
5752: RET
// export function D_QrLegion1 ; begin
5753: LD_INT 0
5755: PPUSH
// DialogueOn ;
5756: CALL_OW 6
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
5760: LD_EXP 1
5764: PPUSH
5765: LD_STRING DQrLegion#1-Bur-1
5767: PPUSH
5768: CALL_OW 88
// DialogueOff ;
5772: CALL_OW 7
// end ;
5776: LD_VAR 0 1
5780: RET
// export function D_QrLegion2 ; begin
5781: LD_INT 0
5783: PPUSH
// DialogueOn ;
5784: CALL_OW 6
// Say ( Burlak , DQrLegion#2-Bur-1 ) ;
5788: LD_EXP 1
5792: PPUSH
5793: LD_STRING DQrLegion#2-Bur-1
5795: PPUSH
5796: CALL_OW 88
// DialogueOff ;
5800: CALL_OW 7
// end ;
5804: LD_VAR 0 1
5808: RET
// export function D_FiringRange ; begin
5809: LD_INT 0
5811: PPUSH
// DialogueOn ;
5812: CALL_OW 6
// if IsOK ( Kuzmov ) then
5816: LD_EXP 10
5820: PPUSH
5821: CALL_OW 302
5825: IFFALSE 5841
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
5827: LD_EXP 10
5831: PPUSH
5832: LD_STRING DFiringRange-Kuz-1
5834: PPUSH
5835: CALL_OW 88
5839: GO 5853
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
5841: LD_EXP 19
5845: PPUSH
5846: LD_STRING DFiringRange-Obl-1
5848: PPUSH
5849: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
5853: LD_EXP 1
5857: PPUSH
5858: LD_STRING DFiringRange-Bur-1
5860: PPUSH
5861: CALL_OW 88
// CenterOnXY ( 59 , 34 ) ;
5865: LD_INT 59
5867: PPUSH
5868: LD_INT 34
5870: PPUSH
5871: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
5875: LD_INT 18
5877: PPUSH
5878: CALL_OW 67
// RevealFogArea ( you , ShootArea ) ;
5882: LD_EXP 31
5886: PPUSH
5887: LD_INT 11
5889: PPUSH
5890: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
5894: LD_INT 11
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL_OW 424
// if IsOK ( Kuzmov ) then
5904: LD_EXP 10
5908: PPUSH
5909: CALL_OW 302
5913: IFFALSE 5929
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
5915: LD_EXP 10
5919: PPUSH
5920: LD_STRING DFiringRange-Kuz-2
5922: PPUSH
5923: CALL_OW 88
5927: GO 5941
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
5929: LD_EXP 19
5933: PPUSH
5934: LD_STRING DFiringRange-Obl-2
5936: PPUSH
5937: CALL_OW 88
// DialogueOff ;
5941: CALL_OW 7
// end ;
5945: LD_VAR 0 1
5949: RET
// export function D_QrShootingGallery1 ; begin
5950: LD_INT 0
5952: PPUSH
// Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
5953: LD_EXP 1
5957: PPUSH
5958: LD_STRING DQrShootingGallery#1-Bur-1
5960: PPUSH
5961: CALL_OW 88
// end ;
5965: LD_VAR 0 1
5969: RET
// export function D_QrShootingGallery2 ; begin
5970: LD_INT 0
5972: PPUSH
// Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
5973: LD_EXP 1
5977: PPUSH
5978: LD_STRING DQrShootingGallery#2-Bur-1
5980: PPUSH
5981: CALL_OW 88
// end ;
5985: LD_VAR 0 1
5989: RET
// export function D_Hunting ; var allhunters ; begin
5990: LD_INT 0
5992: PPUSH
5993: PPUSH
// DialogueOn ;
5994: CALL_OW 6
// allhunters := [ ] ;
5998: LD_ADDR_VAR 0 2
6002: PUSH
6003: EMPTY
6004: ST_TO_ADDR
// if IsOK ( Belkov ) then
6005: LD_EXP 3
6009: PPUSH
6010: CALL_OW 302
6014: IFFALSE 6032
// allhunters := allhunters ^ Belkov ;
6016: LD_ADDR_VAR 0 2
6020: PUSH
6021: LD_VAR 0 2
6025: PUSH
6026: LD_EXP 3
6030: ADD
6031: ST_TO_ADDR
// if IsOK ( Karamazov ) then
6032: LD_EXP 17
6036: PPUSH
6037: CALL_OW 302
6041: IFFALSE 6059
// allhunters := allhunters ^ Karamazov ;
6043: LD_ADDR_VAR 0 2
6047: PUSH
6048: LD_VAR 0 2
6052: PUSH
6053: LD_EXP 17
6057: ADD
6058: ST_TO_ADDR
// if IsOK ( Kozlov ) then
6059: LD_EXP 20
6063: PPUSH
6064: CALL_OW 302
6068: IFFALSE 6086
// allhunters := allhunters ^ Kozlov ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_VAR 0 2
6079: PUSH
6080: LD_EXP 20
6084: ADD
6085: ST_TO_ADDR
// Randomize ;
6086: CALL_OW 10
// RandomizeAll ;
6090: CALL_OW 11
// hunter := allhunters [ Rand ( 1 , ( allhunters + 0 ) ) ] ;
6094: LD_ADDR_EXP 72
6098: PUSH
6099: LD_VAR 0 2
6103: PUSH
6104: LD_INT 1
6106: PPUSH
6107: LD_VAR 0 2
6111: PUSH
6112: LD_INT 0
6114: PLUS
6115: PPUSH
6116: CALL_OW 12
6120: ARRAY
6121: ST_TO_ADDR
// case hunter of Belkov :
6122: LD_EXP 72
6126: PUSH
6127: LD_EXP 3
6131: DOUBLE
6132: EQUAL
6133: IFTRUE 6137
6135: GO 6152
6137: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
6138: LD_EXP 3
6142: PPUSH
6143: LD_STRING DHunting-Bel-1
6145: PPUSH
6146: CALL_OW 88
6150: GO 6203
6152: LD_EXP 17
6156: DOUBLE
6157: EQUAL
6158: IFTRUE 6162
6160: GO 6177
6162: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
6163: LD_EXP 17
6167: PPUSH
6168: LD_STRING DHunting-Kar-1
6170: PPUSH
6171: CALL_OW 88
6175: GO 6203
6177: LD_EXP 20
6181: DOUBLE
6182: EQUAL
6183: IFTRUE 6187
6185: GO 6202
6187: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
6188: LD_EXP 20
6192: PPUSH
6193: LD_STRING DHunting-Koz-1
6195: PPUSH
6196: CALL_OW 88
6200: GO 6203
6202: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
6203: LD_EXP 1
6207: PPUSH
6208: LD_STRING DHunting-Bur-1
6210: PPUSH
6211: CALL_OW 88
// case hunter of Belkov :
6215: LD_EXP 72
6219: PUSH
6220: LD_EXP 3
6224: DOUBLE
6225: EQUAL
6226: IFTRUE 6230
6228: GO 6245
6230: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
6231: LD_EXP 3
6235: PPUSH
6236: LD_STRING DHunting-Bel-2
6238: PPUSH
6239: CALL_OW 88
6243: GO 6296
6245: LD_EXP 17
6249: DOUBLE
6250: EQUAL
6251: IFTRUE 6255
6253: GO 6270
6255: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
6256: LD_EXP 17
6260: PPUSH
6261: LD_STRING DHunting-Kar-2
6263: PPUSH
6264: CALL_OW 88
6268: GO 6296
6270: LD_EXP 20
6274: DOUBLE
6275: EQUAL
6276: IFTRUE 6280
6278: GO 6295
6280: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
6281: LD_EXP 20
6285: PPUSH
6286: LD_STRING DHunting-Koz-2
6288: PPUSH
6289: CALL_OW 88
6293: GO 6296
6295: POP
// DialogueOff ;
6296: CALL_OW 7
// end ;
6300: LD_VAR 0 1
6304: RET
// export function D_QrHunting1 ; begin
6305: LD_INT 0
6307: PPUSH
// Say ( Burlak , DQrHunting#1-Bur-1 ) ;
6308: LD_EXP 1
6312: PPUSH
6313: LD_STRING DQrHunting#1-Bur-1
6315: PPUSH
6316: CALL_OW 88
// end ;
6320: LD_VAR 0 1
6324: RET
// export function D_QrHunting2 ; begin
6325: LD_INT 0
6327: PPUSH
// Say ( Burlak , DQrHunting#2-Bur-1 ) ;
6328: LD_EXP 1
6332: PPUSH
6333: LD_STRING DQrHunting#2-Bur-1
6335: PPUSH
6336: CALL_OW 88
// end ;
6340: LD_VAR 0 1
6344: RET
// export function D_FreeTime ; var pole ; begin
6345: LD_INT 0
6347: PPUSH
6348: PPUSH
// DialogueOn ;
6349: CALL_OW 6
// Randomize ;
6353: CALL_OW 10
// RandomizeAll ;
6357: CALL_OW 11
// pole := [ ] ;
6361: LD_ADDR_VAR 0 2
6365: PUSH
6366: EMPTY
6367: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
6368: LD_EXP 6
6372: PPUSH
6373: CALL_OW 302
6377: IFFALSE 6395
// pole := pole ^ Kapitsova ;
6379: LD_ADDR_VAR 0 2
6383: PUSH
6384: LD_VAR 0 2
6388: PUSH
6389: LD_EXP 6
6393: ADD
6394: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Petrovova :
6395: LD_VAR 0 2
6399: PUSH
6400: LD_INT 1
6402: PPUSH
6403: LD_INT 0
6405: PUSH
6406: LD_VAR 0 2
6410: PLUS
6411: PPUSH
6412: CALL_OW 12
6416: ARRAY
6417: PUSH
6418: LD_EXP 21
6422: DOUBLE
6423: EQUAL
6424: IFTRUE 6428
6426: GO 6453
6428: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
6429: LD_EXP 21
6433: PPUSH
6434: LD_STRING DFreeTime-Ptr-1
6436: PPUSH
6437: CALL_OW 88
// FreeWoman := Petrovova ;
6441: LD_ADDR_EXP 58
6445: PUSH
6446: LD_EXP 21
6450: ST_TO_ADDR
// end ; Kirilenkova :
6451: GO 6524
6453: LD_EXP 4
6457: DOUBLE
6458: EQUAL
6459: IFTRUE 6463
6461: GO 6488
6463: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
6464: LD_EXP 4
6468: PPUSH
6469: LD_STRING DFreeTime-Kir-1
6471: PPUSH
6472: CALL_OW 88
// FreeWoman := Kirilenkova ;
6476: LD_ADDR_EXP 58
6480: PUSH
6481: LD_EXP 4
6485: ST_TO_ADDR
// end ; Kapitsova :
6486: GO 6524
6488: LD_EXP 6
6492: DOUBLE
6493: EQUAL
6494: IFTRUE 6498
6496: GO 6523
6498: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
6499: LD_EXP 6
6503: PPUSH
6504: LD_STRING DFreeTime-Kap-1
6506: PPUSH
6507: CALL_OW 88
// FreeWoman := Kapitsova ;
6511: LD_ADDR_EXP 58
6515: PUSH
6516: LD_EXP 6
6520: ST_TO_ADDR
// end ; end ;
6521: GO 6524
6523: POP
// pole := [ ] ;
6524: LD_ADDR_VAR 0 2
6528: PUSH
6529: EMPTY
6530: ST_TO_ADDR
// if IsOK ( Kuzmov ) then
6531: LD_EXP 10
6535: PPUSH
6536: CALL_OW 302
6540: IFFALSE 6558
// pole := pole ^ Kuzmov ;
6542: LD_ADDR_VAR 0 2
6546: PUSH
6547: LD_VAR 0 2
6551: PUSH
6552: LD_EXP 10
6556: ADD
6557: ST_TO_ADDR
// if IsOK ( Titov ) then
6558: LD_EXP 18
6562: PPUSH
6563: CALL_OW 302
6567: IFFALSE 6585
// pole := pole ^ Titov ;
6569: LD_ADDR_VAR 0 2
6573: PUSH
6574: LD_VAR 0 2
6578: PUSH
6579: LD_EXP 18
6583: ADD
6584: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
6585: LD_EXP 5
6589: PPUSH
6590: CALL_OW 302
6594: IFFALSE 6612
// pole := pole ^ Gnyevko ;
6596: LD_ADDR_VAR 0 2
6600: PUSH
6601: LD_VAR 0 2
6605: PUSH
6606: LD_EXP 5
6610: ADD
6611: ST_TO_ADDR
// if IsOK ( Oblukov ) then
6612: LD_EXP 19
6616: PPUSH
6617: CALL_OW 302
6621: IFFALSE 6639
// pole := pole ^ Oblukov ;
6623: LD_ADDR_VAR 0 2
6627: PUSH
6628: LD_VAR 0 2
6632: PUSH
6633: LD_EXP 19
6637: ADD
6638: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Kuzmov :
6639: LD_VAR 0 2
6643: PUSH
6644: LD_INT 1
6646: PPUSH
6647: LD_INT 0
6649: PUSH
6650: LD_VAR 0 2
6654: PLUS
6655: PPUSH
6656: CALL_OW 12
6660: ARRAY
6661: PUSH
6662: LD_EXP 10
6666: DOUBLE
6667: EQUAL
6668: IFTRUE 6672
6670: GO 6697
6672: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
6673: LD_EXP 10
6677: PPUSH
6678: LD_STRING DFreeTime-Kuz-1
6680: PPUSH
6681: CALL_OW 88
// FreeMan := Kuzmov ;
6685: LD_ADDR_EXP 57
6689: PUSH
6690: LD_EXP 10
6694: ST_TO_ADDR
// end ; Titov :
6695: GO 6803
6697: LD_EXP 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6732
6707: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
6708: LD_EXP 18
6712: PPUSH
6713: LD_STRING DFreeTime-Tit-1
6715: PPUSH
6716: CALL_OW 88
// FreeMan := Titov ;
6720: LD_ADDR_EXP 57
6724: PUSH
6725: LD_EXP 18
6729: ST_TO_ADDR
// end ; Gnyevko :
6730: GO 6803
6732: LD_EXP 5
6736: DOUBLE
6737: EQUAL
6738: IFTRUE 6742
6740: GO 6767
6742: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
6743: LD_EXP 5
6747: PPUSH
6748: LD_STRING DFreeTime-Gny-1
6750: PPUSH
6751: CALL_OW 88
// FreeMan := Gnyevko ;
6755: LD_ADDR_EXP 57
6759: PUSH
6760: LD_EXP 5
6764: ST_TO_ADDR
// end ; Oblukov :
6765: GO 6803
6767: LD_EXP 19
6771: DOUBLE
6772: EQUAL
6773: IFTRUE 6777
6775: GO 6802
6777: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
6778: LD_EXP 19
6782: PPUSH
6783: LD_STRING DFreeTime-Obl-1
6785: PPUSH
6786: CALL_OW 88
// FreeMan := Oblukov ;
6790: LD_ADDR_EXP 57
6794: PUSH
6795: LD_EXP 19
6799: ST_TO_ADDR
// end ; end ;
6800: GO 6803
6802: POP
// DialogueOff ;
6803: CALL_OW 7
// end ;
6807: LD_VAR 0 1
6811: RET
// export function D_QrFreeTime1 ; begin
6812: LD_INT 0
6814: PPUSH
// Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
6815: LD_EXP 1
6819: PPUSH
6820: LD_STRING DQrFreeTime#1-Bur-1
6822: PPUSH
6823: CALL_OW 88
// end ;
6827: LD_VAR 0 1
6831: RET
// export function D_QrFreeTime2 ; begin
6832: LD_INT 0
6834: PPUSH
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ;
6835: LD_EXP 1
6839: PPUSH
6840: LD_STRING DQrFreeTime#2-Bur-1
6842: PPUSH
6843: CALL_OW 88
// end ;
6847: LD_VAR 0 1
6851: RET
// export function D_Masha ; begin
6852: LD_INT 0
6854: PPUSH
// DialogueOn ;
6855: CALL_OW 6
// Say ( Kozlov , DMasha-Koz-1 ) ;
6859: LD_EXP 20
6863: PPUSH
6864: LD_STRING DMasha-Koz-1
6866: PPUSH
6867: CALL_OW 88
// DialogueOff ;
6871: CALL_OW 7
// end ;
6875: LD_VAR 0 1
6879: RET
// export function D_Masha2 ; begin
6880: LD_INT 0
6882: PPUSH
// Say ( Burlak , DMasha2-Bur-1 ) ;
6883: LD_EXP 1
6887: PPUSH
6888: LD_STRING DMasha2-Bur-1
6890: PPUSH
6891: CALL_OW 88
// end ;
6895: LD_VAR 0 1
6899: RET
// export function D_AI ; begin
6900: LD_INT 0
6902: PPUSH
// DialogueOn ;
6903: CALL_OW 6
// if IsOK ( Scholtze ) then
6907: LD_EXP 15
6911: PPUSH
6912: CALL_OW 302
6916: IFFALSE 6932
// Say ( Scholtze , DAI-Sch-1 ) else
6918: LD_EXP 15
6922: PPUSH
6923: LD_STRING DAI-Sch-1
6925: PPUSH
6926: CALL_OW 88
6930: GO 6944
// Say ( Kapitsova , DAI-Kap-1 ) ;
6932: LD_EXP 6
6936: PPUSH
6937: LD_STRING DAI-Kap-1
6939: PPUSH
6940: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
6944: LD_EXP 1
6948: PPUSH
6949: LD_STRING DAI-Bur-1
6951: PPUSH
6952: CALL_OW 88
// if IsOK ( Scholtze ) then
6956: LD_EXP 15
6960: PPUSH
6961: CALL_OW 302
6965: IFFALSE 6981
// Say ( Scholtze , DAI-Sch-2 ) else
6967: LD_EXP 15
6971: PPUSH
6972: LD_STRING DAI-Sch-2
6974: PPUSH
6975: CALL_OW 88
6979: GO 6993
// Say ( Kapitsova , DAI-Kap-2 ) ;
6981: LD_EXP 6
6985: PPUSH
6986: LD_STRING DAI-Kap-2
6988: PPUSH
6989: CALL_OW 88
// DialogueOff ;
6993: CALL_OW 7
// end ;
6997: LD_VAR 0 1
7001: RET
// export function D_SpontTelep ; begin
7002: LD_INT 0
7004: PPUSH
// DialogueOn ;
7005: CALL_OW 6
// if IsOK ( Scholtze ) then
7009: LD_EXP 15
7013: PPUSH
7014: CALL_OW 302
7018: IFFALSE 7034
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
7020: LD_EXP 15
7024: PPUSH
7025: LD_STRING DSpontTelep-Sch-1
7027: PPUSH
7028: CALL_OW 88
7032: GO 7046
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
7034: LD_EXP 6
7038: PPUSH
7039: LD_STRING DSpontTelep-Kap-1
7041: PPUSH
7042: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
7046: LD_EXP 1
7050: PPUSH
7051: LD_STRING DSpontTelep-Bur-1
7053: PPUSH
7054: CALL_OW 88
// if IsOK ( Scholtze ) then
7058: LD_EXP 15
7062: PPUSH
7063: CALL_OW 302
7067: IFFALSE 7083
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
7069: LD_EXP 15
7073: PPUSH
7074: LD_STRING DSpontTelep-Sch-2
7076: PPUSH
7077: CALL_OW 88
7081: GO 7095
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
7083: LD_EXP 6
7087: PPUSH
7088: LD_STRING DSpontTelep-Kap-2
7090: PPUSH
7091: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
7095: LD_EXP 1
7099: PPUSH
7100: LD_STRING DSpontTelep-Bur-2
7102: PPUSH
7103: CALL_OW 88
// DialogueOff ;
7107: CALL_OW 7
// end ;
7111: LD_VAR 0 1
7115: RET
// export function D_AmAttackStart ; begin
7116: LD_INT 0
7118: PPUSH
// SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
7119: LD_EXP 2
7123: PPUSH
7124: LD_STRING DAmAttackStart-Pop-1
7126: PPUSH
7127: CALL_OW 94
// enable ( 50 ) ;
7131: LD_INT 50
7133: ENABLE_MARKED
// end ;
7134: LD_VAR 0 1
7138: RET
// every 0 0$1 marked 50 do
7139: GO 7141
7141: DISABLE
// begin Wait ( 0 0$10 ) ;
7142: LD_INT 350
7144: PPUSH
7145: CALL_OW 67
// if MercPaid then
7149: LD_EXP 39
7153: IFFALSE 7192
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
7155: LD_EXP 1
7159: PPUSH
7160: LD_STRING DAmAttackStart-Bur-1
7162: PPUSH
7163: CALL_OW 88
// if IsOK ( Gleb ) then
7167: LD_EXP 8
7171: PPUSH
7172: CALL_OW 302
7176: IFFALSE 7190
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
7178: LD_EXP 8
7182: PPUSH
7183: LD_STRING DAmAttackStart-Glb-1
7185: PPUSH
7186: CALL_OW 88
// end else
7190: GO 7204
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
7192: LD_EXP 1
7196: PPUSH
7197: LD_STRING DAmAttackStart-Bur-2
7199: PPUSH
7200: CALL_OW 88
// end ;
7204: END
// export function D_AmAttackFin ; var rnd , bool ; begin
7205: LD_INT 0
7207: PPUSH
7208: PPUSH
7209: PPUSH
// DialogueOn ;
7210: CALL_OW 6
// repeat rnd := Rand ( 1 , 7 ) ;
7214: LD_ADDR_VAR 0 2
7218: PUSH
7219: LD_INT 1
7221: PPUSH
7222: LD_INT 7
7224: PPUSH
7225: CALL_OW 12
7229: ST_TO_ADDR
// case rnd of 1 :
7230: LD_VAR 0 2
7234: PUSH
7235: LD_INT 1
7237: DOUBLE
7238: EQUAL
7239: IFTRUE 7243
7241: GO 7275
7243: POP
// if IsOK ( Belkov ) then
7244: LD_EXP 3
7248: PPUSH
7249: CALL_OW 302
7253: IFFALSE 7273
// bool := Say ( Belkov , DAmAttackFin-Bel-1 ) ; 2 :
7255: LD_ADDR_VAR 0 3
7259: PUSH
7260: LD_EXP 3
7264: PPUSH
7265: LD_STRING DAmAttackFin-Bel-1
7267: PPUSH
7268: CALL_OW 88
7272: ST_TO_ADDR
7273: GO 7516
7275: LD_INT 2
7277: DOUBLE
7278: EQUAL
7279: IFTRUE 7283
7281: GO 7315
7283: POP
// if IsOK ( Gnyevko ) then
7284: LD_EXP 5
7288: PPUSH
7289: CALL_OW 302
7293: IFFALSE 7313
// bool := Say ( Gnyevko , DAmAttackFin-Gny-1 ) ; 3 :
7295: LD_ADDR_VAR 0 3
7299: PUSH
7300: LD_EXP 5
7304: PPUSH
7305: LD_STRING DAmAttackFin-Gny-1
7307: PPUSH
7308: CALL_OW 88
7312: ST_TO_ADDR
7313: GO 7516
7315: LD_INT 3
7317: DOUBLE
7318: EQUAL
7319: IFTRUE 7323
7321: GO 7355
7323: POP
// if IsOK ( Titov ) then
7324: LD_EXP 18
7328: PPUSH
7329: CALL_OW 302
7333: IFFALSE 7353
// bool := Say ( Titov , DAmAttackFin-Tit-1 ) ; 4 :
7335: LD_ADDR_VAR 0 3
7339: PUSH
7340: LD_EXP 18
7344: PPUSH
7345: LD_STRING DAmAttackFin-Tit-1
7347: PPUSH
7348: CALL_OW 88
7352: ST_TO_ADDR
7353: GO 7516
7355: LD_INT 4
7357: DOUBLE
7358: EQUAL
7359: IFTRUE 7363
7361: GO 7395
7363: POP
// if IsOK ( Lipshchin ) then
7364: LD_EXP 22
7368: PPUSH
7369: CALL_OW 302
7373: IFFALSE 7393
// bool := Say ( Lipshchin , DAmAttackFin-Lip-1 ) ; 5 :
7375: LD_ADDR_VAR 0 3
7379: PUSH
7380: LD_EXP 22
7384: PPUSH
7385: LD_STRING DAmAttackFin-Lip-1
7387: PPUSH
7388: CALL_OW 88
7392: ST_TO_ADDR
7393: GO 7516
7395: LD_INT 5
7397: DOUBLE
7398: EQUAL
7399: IFTRUE 7403
7401: GO 7435
7403: POP
// if IsOK ( Karamazov ) then
7404: LD_EXP 17
7408: PPUSH
7409: CALL_OW 302
7413: IFFALSE 7433
// bool := Say ( Karamazov , DAmAttackFin-Kar-1 ) ; 6 :
7415: LD_ADDR_VAR 0 3
7419: PUSH
7420: LD_EXP 17
7424: PPUSH
7425: LD_STRING DAmAttackFin-Kar-1
7427: PPUSH
7428: CALL_OW 88
7432: ST_TO_ADDR
7433: GO 7516
7435: LD_INT 6
7437: DOUBLE
7438: EQUAL
7439: IFTRUE 7443
7441: GO 7475
7443: POP
// if IsOK ( Oblukov ) then
7444: LD_EXP 19
7448: PPUSH
7449: CALL_OW 302
7453: IFFALSE 7473
// bool := Say ( Oblukov , DAmAttackFin-Obl-1 ) ; 7 :
7455: LD_ADDR_VAR 0 3
7459: PUSH
7460: LD_EXP 19
7464: PPUSH
7465: LD_STRING DAmAttackFin-Obl-1
7467: PPUSH
7468: CALL_OW 88
7472: ST_TO_ADDR
7473: GO 7516
7475: LD_INT 7
7477: DOUBLE
7478: EQUAL
7479: IFTRUE 7483
7481: GO 7515
7483: POP
// if IsOK ( Burlak ) then
7484: LD_EXP 1
7488: PPUSH
7489: CALL_OW 302
7493: IFFALSE 7513
// bool := Say ( Burlak , DAmAttackFin-Bur-1 ) ; end ;
7495: LD_ADDR_VAR 0 3
7499: PUSH
7500: LD_EXP 1
7504: PPUSH
7505: LD_STRING DAmAttackFin-Bur-1
7507: PPUSH
7508: CALL_OW 88
7512: ST_TO_ADDR
7513: GO 7516
7515: POP
// until bool ;
7516: LD_VAR 0 3
7520: IFFALSE 7214
// Say ( Popov , DAmAttackFin-Pop-1 ) ;
7522: LD_EXP 2
7526: PPUSH
7527: LD_STRING DAmAttackFin-Pop-1
7529: PPUSH
7530: CALL_OW 88
// DialogueOff ;
7534: CALL_OW 7
// end ; end_of_file
7538: LD_VAR 0 1
7542: RET
// export function merc_help ; var rnd ; begin
7543: LD_INT 0
7545: PPUSH
7546: PPUSH
// rnd := Rand ( 2 2$0 , 3 3$0 ) ;
7547: LD_ADDR_VAR 0 2
7551: PUSH
7552: LD_INT 4200
7554: PPUSH
7555: LD_INT 6300
7557: PPUSH
7558: CALL_OW 12
7562: ST_TO_ADDR
// Wait ( rnd ) ;
7563: LD_VAR 0 2
7567: PPUSH
7568: CALL_OW 67
// if not HeikeKilled then
7572: LD_EXP 38
7576: NOT
7577: IFFALSE 7739
// begin D_MercHelp ;
7579: CALL 5025 0 0
// case Query ( QMerc ) of 1 :
7583: LD_STRING QMerc
7585: PPUSH
7586: CALL_OW 97
7590: PUSH
7591: LD_INT 1
7593: DOUBLE
7594: EQUAL
7595: IFTRUE 7599
7597: GO 7622
7599: POP
// begin D_QrMerc1 ;
7600: CALL 5101 0 0
// create_kurt ;
7604: CALL 3155 0 0
// MercAccepted := true ;
7608: LD_ADDR_EXP 44
7612: PUSH
7613: LD_INT 1
7615: ST_TO_ADDR
// come_to_build_barracks ;
7616: CALL 8212 0 0
// end ; 2 :
7620: GO 7731
7622: LD_INT 2
7624: DOUBLE
7625: EQUAL
7626: IFTRUE 7630
7628: GO 7661
7630: POP
// begin D_QrMerc2 ;
7631: CALL 5141 0 0
// PopovAsked := true ;
7635: LD_ADDR_EXP 46
7639: PUSH
7640: LD_INT 1
7642: ST_TO_ADDR
// create_kurt ;
7643: CALL 3155 0 0
// MercAccepted := true ;
7647: LD_ADDR_EXP 44
7651: PUSH
7652: LD_INT 1
7654: ST_TO_ADDR
// come_to_build_barracks ;
7655: CALL 8212 0 0
// end ; 3 :
7659: GO 7731
7661: LD_INT 3
7663: DOUBLE
7664: EQUAL
7665: IFTRUE 7669
7667: GO 7730
7669: POP
// begin D_QrMerc3 ;
7670: CALL 5193 0 0
// PopovAsked := true ;
7674: LD_ADDR_EXP 46
7678: PUSH
7679: LD_INT 1
7681: ST_TO_ADDR
// Wait ( 0 0$13 ) ;
7682: LD_INT 455
7684: PPUSH
7685: CALL_OW 67
// create_kurt ;
7689: CALL 3155 0 0
// ComMoveToArea ( [ Kurt , Mercenary1 ] , WaitHeikeArea ) ;
7693: LD_EXP 13
7697: PUSH
7698: LD_EXP 14
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: LD_INT 8
7709: PPUSH
7710: CALL_OW 113
// enable ( 6 ) ;
7714: LD_INT 6
7716: ENABLE_MARKED
// enable ( 20 ) ;
7717: LD_INT 20
7719: ENABLE_MARKED
// D_MercAttack ;
7720: CALL 5366 0 0
// merc_attack ;
7724: CALL 7744 0 0
// end ; end ;
7728: GO 7731
7730: POP
// MortarAsked := true ;
7731: LD_ADDR_EXP 69
7735: PUSH
7736: LD_INT 1
7738: ST_TO_ADDR
// end ; end ;
7739: LD_VAR 0 1
7743: RET
// export function merc_attack ; var grp , celkemgrp , rnd , pocet , mercenaries , filter ; begin
7744: LD_INT 0
7746: PPUSH
7747: PPUSH
7748: PPUSH
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
// repeat SetAttitude ( you , merc , att_enemy , true ) ;
7753: LD_EXP 31
7757: PPUSH
7758: LD_EXP 34
7762: PPUSH
7763: LD_INT 2
7765: PPUSH
7766: LD_INT 1
7768: PPUSH
7769: CALL_OW 80
// mercenaries := [ ] ;
7773: LD_ADDR_VAR 0 6
7777: PUSH
7778: EMPTY
7779: ST_TO_ADDR
// grp := Rand ( 1 , 6 ) ;
7780: LD_ADDR_VAR 0 2
7784: PUSH
7785: LD_INT 1
7787: PPUSH
7788: LD_INT 6
7790: PPUSH
7791: CALL_OW 12
7795: ST_TO_ADDR
// for pocet := 1 to grp do
7796: LD_ADDR_VAR 0 5
7800: PUSH
7801: DOUBLE
7802: LD_INT 1
7804: DEC
7805: ST_TO_ADDR
7806: LD_VAR 0 2
7810: PUSH
7811: FOR_TO
7812: IFFALSE 7935
// begin uc_side = merc ;
7814: LD_ADDR_OWVAR 20
7818: PUSH
7819: LD_EXP 34
7823: ST_TO_ADDR
// uc_nation := nation_arabian ;
7824: LD_ADDR_OWVAR 21
7828: PUSH
7829: LD_INT 2
7831: ST_TO_ADDR
// rnd := Rand ( 1 , 2 ) ;
7832: LD_ADDR_VAR 0 4
7836: PUSH
7837: LD_INT 1
7839: PPUSH
7840: LD_INT 2
7842: PPUSH
7843: CALL_OW 12
7847: ST_TO_ADDR
// case rnd of 1 :
7848: LD_VAR 0 4
7852: PUSH
7853: LD_INT 1
7855: DOUBLE
7856: EQUAL
7857: IFTRUE 7861
7859: GO 7877
7861: POP
// PrepareHuman ( sex_male , class_soldier , 2 ) ; 2 :
7862: LD_INT 1
7864: PPUSH
7865: LD_INT 1
7867: PPUSH
7868: LD_INT 2
7870: PPUSH
7871: CALL_OW 380
7875: GO 7902
7877: LD_INT 2
7879: DOUBLE
7880: EQUAL
7881: IFTRUE 7885
7883: GO 7901
7885: POP
// PrepareHuman ( sex_male , class_mortar , 2 ) ; end ;
7886: LD_INT 1
7888: PPUSH
7889: LD_INT 8
7891: PPUSH
7892: LD_INT 2
7894: PPUSH
7895: CALL_OW 380
7899: GO 7902
7901: POP
// hc_name :=  ;
7902: LD_ADDR_OWVAR 26
7906: PUSH
7907: LD_STRING 
7909: ST_TO_ADDR
// mercenaries := mercenaries ^ CreateHuman ;
7910: LD_ADDR_VAR 0 6
7914: PUSH
7915: LD_VAR 0 6
7919: PUSH
7920: CALL_OW 44
7924: ADD
7925: ST_TO_ADDR
// Wait ( 2 ) ;
7926: LD_INT 2
7928: PPUSH
7929: CALL_OW 67
// end ;
7933: GO 7811
7935: POP
7936: POP
// for pocet := 1 to grp do
7937: LD_ADDR_VAR 0 5
7941: PUSH
7942: DOUBLE
7943: LD_INT 1
7945: DEC
7946: ST_TO_ADDR
7947: LD_VAR 0 2
7951: PUSH
7952: FOR_TO
7953: IFFALSE 8030
// begin if HeikeDismissed then
7955: LD_EXP 45
7959: IFFALSE 7965
// exit ;
7961: POP
7962: POP
7963: GO 8207
// PlaceUnitArea ( mercenaries [ pocet ] , AttackArea , false ) ;
7965: LD_VAR 0 6
7969: PUSH
7970: LD_VAR 0 5
7974: ARRAY
7975: PPUSH
7976: LD_INT 5
7978: PPUSH
7979: LD_INT 0
7981: PPUSH
7982: CALL_OW 49
// ComAgressiveMove ( mercenaries [ pocet ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
7986: LD_VAR 0 6
7990: PUSH
7991: LD_VAR 0 5
7995: ARRAY
7996: PPUSH
7997: LD_EXP 1
8001: PPUSH
8002: CALL_OW 250
8006: PPUSH
8007: LD_EXP 1
8011: PPUSH
8012: CALL_OW 251
8016: PPUSH
8017: CALL_OW 114
// Wait ( 1 ) ;
8021: LD_INT 1
8023: PPUSH
8024: CALL_OW 67
// end ;
8028: GO 7952
8030: POP
8031: POP
// celkemgrp := celkemgrp + grp ;
8032: LD_ADDR_VAR 0 3
8036: PUSH
8037: LD_VAR 0 3
8041: PUSH
8042: LD_VAR 0 2
8046: PLUS
8047: ST_TO_ADDR
// Wait ( 1 1$0 ) ;
8048: LD_INT 2100
8050: PPUSH
8051: CALL_OW 67
// until HeikeSend or celkemgrp > pocetmercenaries ;
8055: LD_EXP 65
8059: PUSH
8060: LD_VAR 0 3
8064: PUSH
8065: LD_EXP 78
8069: GREATER
8070: OR
8071: IFFALSE 7753
// repeat Wait ( 0 0$1 ) ;
8073: LD_INT 35
8075: PPUSH
8076: CALL_OW 67
// until HeikeDismissed or celkemgrp > pocetmercenaries ;
8080: LD_EXP 45
8084: PUSH
8085: LD_VAR 0 3
8089: PUSH
8090: LD_EXP 78
8094: GREATER
8095: OR
8096: IFFALSE 8073
// if HeikeDismissed then
8098: LD_EXP 45
8102: IFFALSE 8207
// begin SetAttitude ( you , merc , att_friend , true ) ;
8104: LD_EXP 31
8108: PPUSH
8109: LD_EXP 34
8113: PPUSH
8114: LD_INT 1
8116: PPUSH
8117: LD_INT 1
8119: PPUSH
8120: CALL_OW 80
// filter := FilterAllUnits ( [ f_side , merc ] ) ;
8124: LD_ADDR_VAR 0 7
8128: PUSH
8129: LD_INT 22
8131: PUSH
8132: LD_EXP 34
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PPUSH
8141: CALL_OW 69
8145: ST_TO_ADDR
// ComAgressiveMove ( filter , 29 , 57 ) ;
8146: LD_VAR 0 7
8150: PPUSH
8151: LD_INT 29
8153: PPUSH
8154: LD_INT 57
8156: PPUSH
8157: CALL_OW 114
// enable ( 5 ) ;
8161: LD_INT 5
8163: ENABLE_MARKED
// repeat Wait ( 0 0$3 ) ;
8164: LD_INT 105
8166: PPUSH
8167: CALL_OW 67
// ComAgressiveMove ( filter , 29 , 57 ) ;
8171: LD_VAR 0 7
8175: PPUSH
8176: LD_INT 29
8178: PPUSH
8179: LD_INT 57
8181: PPUSH
8182: CALL_OW 114
// until FilterAllUnits ( [ f_side , merc ] ) = [ ] ;
8186: LD_INT 22
8188: PUSH
8189: LD_EXP 34
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PPUSH
8198: CALL_OW 69
8202: PUSH
8203: EMPTY
8204: EQUAL
8205: IFFALSE 8164
// end ; end ;
8207: LD_VAR 0 1
8211: RET
// function come_to_build_barracks ; var x , y , d , filter ; begin
8212: LD_INT 0
8214: PPUSH
8215: PPUSH
8216: PPUSH
8217: PPUSH
8218: PPUSH
// SetAttitude ( you , merc , att_neutral , true ) ;
8219: LD_EXP 31
8223: PPUSH
8224: LD_EXP 34
8228: PPUSH
8229: LD_INT 0
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 80
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8239: LD_ADDR_VAR 0 5
8243: PUSH
8244: LD_INT 22
8246: PUSH
8247: LD_EXP 31
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PUSH
8256: LD_INT 2
8258: PUSH
8259: LD_INT 30
8261: PUSH
8262: LD_INT 0
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 30
8271: PUSH
8272: LD_INT 1
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: LIST
8283: PUSH
8284: EMPTY
8285: LIST
8286: PUSH
8287: EMPTY
8288: LIST
8289: LIST
8290: PPUSH
8291: CALL_OW 69
8295: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8296: LD_INT 0
8298: PUSH
8299: LD_VAR 0 5
8303: PLUS
8304: PUSH
8305: LD_INT 0
8307: NONEQUAL
8308: IFFALSE 8369
// begin x := GetX ( filter [ 1 ] ) ;
8310: LD_ADDR_VAR 0 2
8314: PUSH
8315: LD_VAR 0 5
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: CALL_OW 250
8328: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8329: LD_ADDR_VAR 0 3
8333: PUSH
8334: LD_VAR 0 5
8338: PUSH
8339: LD_INT 1
8341: ARRAY
8342: PPUSH
8343: CALL_OW 251
8347: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8348: LD_ADDR_VAR 0 4
8352: PUSH
8353: LD_VAR 0 5
8357: PUSH
8358: LD_INT 1
8360: ARRAY
8361: PPUSH
8362: CALL_OW 254
8366: ST_TO_ADDR
// end else
8367: GO 8407
// begin x := GetX ( Burlak ) ;
8369: LD_ADDR_VAR 0 2
8373: PUSH
8374: LD_EXP 1
8378: PPUSH
8379: CALL_OW 250
8383: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8384: LD_ADDR_VAR 0 3
8388: PUSH
8389: LD_EXP 1
8393: PPUSH
8394: CALL_OW 251
8398: ST_TO_ADDR
// d := 1 ;
8399: LD_ADDR_VAR 0 4
8403: PUSH
8404: LD_INT 1
8406: ST_TO_ADDR
// end ; ComMoveXY ( [ Kurt , Mercenary1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8407: LD_EXP 13
8411: PUSH
8412: LD_EXP 14
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PPUSH
8421: LD_VAR 0 2
8425: PPUSH
8426: LD_VAR 0 4
8430: PPUSH
8431: LD_INT 5
8433: PPUSH
8434: CALL_OW 272
8438: PPUSH
8439: LD_VAR 0 3
8443: PPUSH
8444: LD_VAR 0 4
8448: PPUSH
8449: LD_INT 5
8451: PPUSH
8452: CALL_OW 273
8456: PPUSH
8457: CALL_OW 111
// enable ( 1 ) ;
8461: LD_INT 1
8463: ENABLE_MARKED
// end ;
8464: LD_VAR 0 1
8468: RET
// export function hand_over ; var i , filter , auto , x , y , d ; begin
8469: LD_INT 0
8471: PPUSH
8472: PPUSH
8473: PPUSH
8474: PPUSH
8475: PPUSH
8476: PPUSH
8477: PPUSH
// SetAttitude ( arab , merc , att_enemy , true ) ;
8478: LD_EXP 33
8482: PPUSH
8483: LD_EXP 34
8487: PPUSH
8488: LD_INT 2
8490: PPUSH
8491: LD_INT 1
8493: PPUSH
8494: CALL_OW 80
// SetAttitude ( arab , you , att_friend , true ) ;
8498: LD_EXP 33
8502: PPUSH
8503: LD_EXP 31
8507: PPUSH
8508: LD_INT 1
8510: PPUSH
8511: LD_INT 1
8513: PPUSH
8514: CALL_OW 80
// auto := [ ] ;
8518: LD_ADDR_VAR 0 4
8522: PUSH
8523: EMPTY
8524: ST_TO_ADDR
// ar_human := [ ] ;
8525: LD_ADDR_EXP 80
8529: PUSH
8530: EMPTY
8531: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8532: LD_ADDR_VAR 0 3
8536: PUSH
8537: LD_INT 22
8539: PUSH
8540: LD_EXP 31
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 2
8551: PUSH
8552: LD_INT 30
8554: PUSH
8555: LD_INT 0
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PUSH
8562: LD_INT 30
8564: PUSH
8565: LD_INT 1
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: LIST
8576: PUSH
8577: EMPTY
8578: LIST
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 69
8588: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8589: LD_INT 0
8591: PUSH
8592: LD_VAR 0 3
8596: PLUS
8597: PUSH
8598: LD_INT 0
8600: NONEQUAL
8601: IFFALSE 8662
// begin x := GetX ( filter [ 1 ] ) ;
8603: LD_ADDR_VAR 0 5
8607: PUSH
8608: LD_VAR 0 3
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PPUSH
8617: CALL_OW 250
8621: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8622: LD_ADDR_VAR 0 6
8626: PUSH
8627: LD_VAR 0 3
8631: PUSH
8632: LD_INT 1
8634: ARRAY
8635: PPUSH
8636: CALL_OW 251
8640: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8641: LD_ADDR_VAR 0 7
8645: PUSH
8646: LD_VAR 0 3
8650: PUSH
8651: LD_INT 1
8653: ARRAY
8654: PPUSH
8655: CALL_OW 254
8659: ST_TO_ADDR
// end else
8660: GO 8700
// begin x := GetX ( Burlak ) ;
8662: LD_ADDR_VAR 0 5
8666: PUSH
8667: LD_EXP 1
8671: PPUSH
8672: CALL_OW 250
8676: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8677: LD_ADDR_VAR 0 6
8681: PUSH
8682: LD_EXP 1
8686: PPUSH
8687: CALL_OW 251
8691: ST_TO_ADDR
// d := 1 ;
8692: LD_ADDR_VAR 0 7
8696: PUSH
8697: LD_INT 1
8699: ST_TO_ADDR
// end ; enable ( 7 ) ;
8700: LD_INT 7
8702: ENABLE_MARKED
// for i := 1 to 3 do
8703: LD_ADDR_VAR 0 2
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 9282
// begin uc_side := arab ;
8719: LD_ADDR_OWVAR 20
8723: PUSH
8724: LD_EXP 33
8728: ST_TO_ADDR
// uc_nation := nation_arabian ;
8729: LD_ADDR_OWVAR 21
8733: PUSH
8734: LD_INT 2
8736: ST_TO_ADDR
// uc_direction := 3 ;
8737: LD_ADDR_OWVAR 24
8741: PUSH
8742: LD_INT 3
8744: ST_TO_ADDR
// if i <= 2 then
8745: LD_VAR 0 2
8749: PUSH
8750: LD_INT 2
8752: LESSEQUAL
8753: IFFALSE 8770
// PrepareHuman ( sex_male , class_soldier , 7 ) else
8755: LD_INT 1
8757: PPUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 7
8763: PPUSH
8764: CALL_OW 380
8768: GO 8783
// PrepareHuman ( sex_male , class_scientistic , 7 ) ;
8770: LD_INT 1
8772: PPUSH
8773: LD_INT 4
8775: PPUSH
8776: LD_INT 7
8778: PPUSH
8779: CALL_OW 380
// Wait ( 1 ) ;
8783: LD_INT 1
8785: PPUSH
8786: CALL_OW 67
// hc_name :=  ;
8790: LD_ADDR_OWVAR 26
8794: PUSH
8795: LD_STRING 
8797: ST_TO_ADDR
// ar_human := ar_human ^ CreateHuman ;
8798: LD_ADDR_EXP 80
8802: PUSH
8803: LD_EXP 80
8807: PUSH
8808: CALL_OW 44
8812: ADD
8813: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
8814: LD_ADDR_OWVAR 37
8818: PUSH
8819: LD_INT 13
8821: ST_TO_ADDR
// vc_engine := engine_combustion ;
8822: LD_ADDR_OWVAR 39
8826: PUSH
8827: LD_INT 1
8829: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
8830: LD_ADDR_OWVAR 40
8834: PUSH
8835: LD_INT 32
8837: ST_TO_ADDR
// vc_control := control_manual ;
8838: LD_ADDR_OWVAR 38
8842: PUSH
8843: LD_INT 1
8845: ST_TO_ADDR
// auto := auto ^ CreateVehicle ;
8846: LD_ADDR_VAR 0 4
8850: PUSH
8851: LD_VAR 0 4
8855: PUSH
8856: CALL_OW 45
8860: ADD
8861: ST_TO_ADDR
// PlaceHumanInUnit ( ar_human [ i ] , auto [ i ] ) ;
8862: LD_EXP 80
8866: PUSH
8867: LD_VAR 0 2
8871: ARRAY
8872: PPUSH
8873: LD_VAR 0 4
8877: PUSH
8878: LD_VAR 0 2
8882: ARRAY
8883: PPUSH
8884: CALL_OW 52
// PlaceUnitArea ( auto [ i ] , HandOverEnterArea , false ) ;
8888: LD_VAR 0 4
8892: PUSH
8893: LD_VAR 0 2
8897: ARRAY
8898: PPUSH
8899: LD_INT 6
8901: PPUSH
8902: LD_INT 0
8904: PPUSH
8905: CALL_OW 49
// enable ( 6 ) ;
8909: LD_INT 6
8911: ENABLE_MARKED
// case i of 1 :
8912: LD_VAR 0 2
8916: PUSH
8917: LD_INT 1
8919: DOUBLE
8920: EQUAL
8921: IFTRUE 8925
8923: GO 9016
8925: POP
// begin SetCargo ( auto [ 1 ] , mat_cans , 100 ) ;
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: ARRAY
8934: PPUSH
8935: LD_INT 1
8937: PPUSH
8938: LD_INT 100
8940: PPUSH
8941: CALL_OW 290
// ComMoveXY ( auto [ 1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8945: LD_VAR 0 4
8949: PUSH
8950: LD_INT 1
8952: ARRAY
8953: PPUSH
8954: LD_VAR 0 5
8958: PPUSH
8959: LD_VAR 0 7
8963: PPUSH
8964: LD_INT 5
8966: PPUSH
8967: CALL_OW 272
8971: PPUSH
8972: LD_VAR 0 6
8976: PPUSH
8977: LD_VAR 0 7
8981: PPUSH
8982: LD_INT 5
8984: PPUSH
8985: CALL_OW 273
8989: PPUSH
8990: CALL_OW 111
// Wait ( 1 ) ;
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 67
// AddComExitVehicle ( auto [ 1 ] ) ;
9001: LD_VAR 0 4
9005: PUSH
9006: LD_INT 1
9008: ARRAY
9009: PPUSH
9010: CALL_OW 181
// end ; 2 :
9014: GO 9273
9016: LD_INT 2
9018: DOUBLE
9019: EQUAL
9020: IFTRUE 9024
9022: GO 9144
9024: POP
// begin SetCargo ( auto [ 2 ] , mat_oil , 100 ) ;
9025: LD_VAR 0 4
9029: PUSH
9030: LD_INT 2
9032: ARRAY
9033: PPUSH
9034: LD_INT 2
9036: PPUSH
9037: LD_INT 100
9039: PPUSH
9040: CALL_OW 290
// ComMoveXY ( auto [ 2 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9044: LD_VAR 0 4
9048: PUSH
9049: LD_INT 2
9051: ARRAY
9052: PPUSH
9053: LD_VAR 0 5
9057: PPUSH
9058: LD_VAR 0 7
9062: PPUSH
9063: LD_INT 5
9065: PPUSH
9066: CALL_OW 272
9070: PPUSH
9071: LD_VAR 0 6
9075: PPUSH
9076: LD_VAR 0 7
9080: PPUSH
9081: LD_INT 5
9083: PPUSH
9084: CALL_OW 273
9088: PPUSH
9089: CALL_OW 111
// Wait ( 1 ) ;
9093: LD_INT 1
9095: PPUSH
9096: CALL_OW 67
// AddComExitVehicle ( auto [ 2 ] ) ;
9100: LD_VAR 0 4
9104: PUSH
9105: LD_INT 2
9107: ARRAY
9108: PPUSH
9109: CALL_OW 181
// Wait ( 1 ) ;
9113: LD_INT 1
9115: PPUSH
9116: CALL_OW 67
// AddComMoveUnit ( auto [ 2 ] , auto [ 1 ] ) ;
9120: LD_VAR 0 4
9124: PUSH
9125: LD_INT 2
9127: ARRAY
9128: PPUSH
9129: LD_VAR 0 4
9133: PUSH
9134: LD_INT 1
9136: ARRAY
9137: PPUSH
9138: CALL_OW 172
// end ; 3 :
9142: GO 9273
9144: LD_INT 3
9146: DOUBLE
9147: EQUAL
9148: IFTRUE 9152
9150: GO 9272
9152: POP
// begin SetCargo ( auto [ 3 ] , mat_siberit , 100 ) ;
9153: LD_VAR 0 4
9157: PUSH
9158: LD_INT 3
9160: ARRAY
9161: PPUSH
9162: LD_INT 3
9164: PPUSH
9165: LD_INT 100
9167: PPUSH
9168: CALL_OW 290
// ComMoveXY ( auto [ 3 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9172: LD_VAR 0 4
9176: PUSH
9177: LD_INT 3
9179: ARRAY
9180: PPUSH
9181: LD_VAR 0 5
9185: PPUSH
9186: LD_VAR 0 7
9190: PPUSH
9191: LD_INT 5
9193: PPUSH
9194: CALL_OW 272
9198: PPUSH
9199: LD_VAR 0 6
9203: PPUSH
9204: LD_VAR 0 7
9208: PPUSH
9209: LD_INT 5
9211: PPUSH
9212: CALL_OW 273
9216: PPUSH
9217: CALL_OW 111
// Wait ( 1 ) ;
9221: LD_INT 1
9223: PPUSH
9224: CALL_OW 67
// AddComExitVehicle ( auto [ 3 ] ) ;
9228: LD_VAR 0 4
9232: PUSH
9233: LD_INT 3
9235: ARRAY
9236: PPUSH
9237: CALL_OW 181
// Wait ( 1 ) ;
9241: LD_INT 1
9243: PPUSH
9244: CALL_OW 67
// AddComMoveUnit ( auto [ 3 ] , auto [ 1 ] ) ;
9248: LD_VAR 0 4
9252: PUSH
9253: LD_INT 3
9255: ARRAY
9256: PPUSH
9257: LD_VAR 0 4
9261: PUSH
9262: LD_INT 1
9264: ARRAY
9265: PPUSH
9266: CALL_OW 172
// end ; end ;
9270: GO 9273
9272: POP
// Wait ( 0 0$3 ) ;
9273: LD_INT 105
9275: PPUSH
9276: CALL_OW 67
// end ;
9280: GO 8716
9282: POP
9283: POP
// MercHandoverArabsSpawned = true ;
9284: LD_ADDR_EXP 43
9288: PUSH
9289: LD_INT 1
9291: ST_TO_ADDR
// enable ( 9 ) ;
9292: LD_INT 9
9294: ENABLE_MARKED
// end ;
9295: LD_VAR 0 1
9299: RET
// every 0 0$1 + 0 0$0.5 do var filter ;
9300: GO 9302
9302: DISABLE
9303: LD_INT 0
9305: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
9306: LD_ADDR_VAR 0 1
9310: PUSH
9311: LD_INT 22
9313: PUSH
9314: LD_EXP 31
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PUSH
9323: LD_INT 2
9325: PUSH
9326: LD_INT 30
9328: PUSH
9329: LD_INT 0
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 30
9338: PUSH
9339: LD_INT 1
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: EMPTY
9352: LIST
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: PPUSH
9358: CALL_OW 69
9362: ST_TO_ADDR
// if filter then
9363: LD_VAR 0 1
9367: IFFALSE 9381
// SetBName ( filter , trockij ) ;
9369: LD_VAR 0 1
9373: PPUSH
9374: LD_STRING trockij
9376: PPUSH
9377: CALL_OW 500
// enable ;
9381: ENABLE
// end ;
9382: PPOPN 1
9384: END
// var crates_amount , crates_creating ; every 2 2$35 do
9385: GO 9387
9387: DISABLE
// begin crates_amount := GetResourceArea ( TreesArea , mat_cans ) ;
9388: LD_ADDR_LOC 1
9392: PUSH
9393: LD_INT 1
9395: PPUSH
9396: LD_INT 1
9398: PPUSH
9399: CALL_OW 287
9403: ST_TO_ADDR
// if crates_amount >= 30 then
9404: LD_LOC 1
9408: PUSH
9409: LD_INT 30
9411: GREATEREQUAL
9412: IFFALSE 9422
// crates_creating := false ;
9414: LD_ADDR_LOC 2
9418: PUSH
9419: LD_INT 0
9421: ST_TO_ADDR
// if crates_amount <= 1 then
9422: LD_LOC 1
9426: PUSH
9427: LD_INT 1
9429: LESSEQUAL
9430: IFFALSE 9440
// crates_creating := true ;
9432: LD_ADDR_LOC 2
9436: PUSH
9437: LD_INT 1
9439: ST_TO_ADDR
// if crates_creating then
9440: LD_LOC 2
9444: IFFALSE 9467
// CreateCratesArea ( Rand ( 1 , 5 ) , TreesArea , true ) ;
9446: LD_INT 1
9448: PPUSH
9449: LD_INT 5
9451: PPUSH
9452: CALL_OW 12
9456: PPUSH
9457: LD_INT 1
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: CALL_OW 55
// enable ;
9467: ENABLE
// end ;
9468: END
// var NonBuildBuildings , NonBuildWeapons ; every 0 0$3 do var filter , filter_tur , un , filter_weap , budova , NonBuild ;
9469: GO 9471
9471: DISABLE
9472: LD_INT 0
9474: PPUSH
9475: PPUSH
9476: PPUSH
9477: PPUSH
9478: PPUSH
9479: PPUSH
// begin NonBuild := AvailableBuildings ;
9480: LD_ADDR_VAR 0 6
9484: PUSH
9485: LD_EXP 55
9489: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] , [ f_ready ] ] ) ;
9490: LD_ADDR_VAR 0 1
9494: PUSH
9495: LD_INT 21
9497: PUSH
9498: LD_INT 3
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_EXP 31
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: LD_INT 53
9519: PUSH
9520: EMPTY
9521: LIST
9522: PUSH
9523: EMPTY
9524: LIST
9525: LIST
9526: LIST
9527: PPUSH
9528: CALL_OW 69
9532: ST_TO_ADDR
// TurretsDone := false ;
9533: LD_ADDR_EXP 49
9537: PUSH
9538: LD_INT 0
9540: ST_TO_ADDR
// filter_tur := FilterAllUnits ( [ [ f_btype , b_turret ] , [ f_side , you ] , [ f_ready ] ] ) ;
9541: LD_ADDR_VAR 0 2
9545: PUSH
9546: LD_INT 30
9548: PUSH
9549: LD_INT 33
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: PUSH
9556: LD_INT 22
9558: PUSH
9559: LD_EXP 31
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 53
9570: PUSH
9571: EMPTY
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: PPUSH
9579: CALL_OW 69
9583: ST_TO_ADDR
// filter_weap := [ ] ;
9584: LD_ADDR_VAR 0 4
9588: PUSH
9589: EMPTY
9590: ST_TO_ADDR
// for un in filter_tur do
9591: LD_ADDR_VAR 0 3
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9634
// begin filter_weap := filter_weap union GetBWeapon ( un ) ;
9604: LD_ADDR_VAR 0 4
9608: PUSH
9609: LD_VAR 0 4
9613: PUSH
9614: LD_VAR 0 3
9618: PPUSH
9619: CALL_OW 269
9623: UNION
9624: ST_TO_ADDR
// Wait ( 2 ) ;
9625: LD_INT 2
9627: PPUSH
9628: CALL_OW 67
// end ;
9632: GO 9601
9634: POP
9635: POP
// if ( filter_weap diff 0 ) >= 3 then
9636: LD_VAR 0 4
9640: PUSH
9641: LD_INT 0
9643: DIFF
9644: PUSH
9645: LD_INT 3
9647: GREATEREQUAL
9648: IFFALSE 9658
// TurretsDone := true ;
9650: LD_ADDR_EXP 49
9654: PUSH
9655: LD_INT 1
9657: ST_TO_ADDR
// for budova in filter do
9658: LD_ADDR_VAR 0 5
9662: PUSH
9663: LD_VAR 0 1
9667: PUSH
9668: FOR_IN
9669: IFFALSE 9701
// begin NonBuild := NonBuild diff GetBType ( budova ) ;
9671: LD_ADDR_VAR 0 6
9675: PUSH
9676: LD_VAR 0 6
9680: PUSH
9681: LD_VAR 0 5
9685: PPUSH
9686: CALL_OW 266
9690: DIFF
9691: ST_TO_ADDR
// Wait ( 1 ) ;
9692: LD_INT 1
9694: PPUSH
9695: CALL_OW 67
// end ;
9699: GO 9668
9701: POP
9702: POP
// if NonBuild = [ ] and TurretsDone and not BuildingsDone then
9703: LD_VAR 0 6
9707: PUSH
9708: EMPTY
9709: EQUAL
9710: PUSH
9711: LD_EXP 49
9715: AND
9716: PUSH
9717: LD_EXP 48
9721: NOT
9722: AND
9723: IFFALSE 9742
// begin ChangeMissionObjectives ( MBuildingsDone ) ;
9725: LD_STRING MBuildingsDone
9727: PPUSH
9728: CALL_OW 337
// BuildingsDone := true ;
9732: LD_ADDR_EXP 48
9736: PUSH
9737: LD_INT 1
9739: ST_TO_ADDR
// end else
9740: GO 9779
// if ( NonBuild <> [ ] or not TurretsDone ) and BuildingsDone then
9742: LD_VAR 0 6
9746: PUSH
9747: EMPTY
9748: NONEQUAL
9749: PUSH
9750: LD_EXP 49
9754: NOT
9755: OR
9756: PUSH
9757: LD_EXP 48
9761: AND
9762: IFFALSE 9779
// begin ChangeMissionObjectives ( MBuildings ) ;
9764: LD_STRING MBuildings
9766: PPUSH
9767: CALL_OW 337
// BuildingsDone := false ;
9771: LD_ADDR_EXP 48
9775: PUSH
9776: LD_INT 0
9778: ST_TO_ADDR
// end ; if not ( ( filter_weap diff 0 ) > 3 ) then
9779: LD_VAR 0 4
9783: PUSH
9784: LD_INT 0
9786: DIFF
9787: PUSH
9788: LD_INT 3
9790: GREATER
9791: NOT
9792: IFFALSE 9820
// NonBuild := NonBuild + 3 - ( filter_weap diff 0 ) else
9794: LD_ADDR_VAR 0 6
9798: PUSH
9799: LD_VAR 0 6
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 4
9812: PUSH
9813: LD_INT 0
9815: DIFF
9816: MINUS
9817: ST_TO_ADDR
9818: GO 9834
// NonBuild := NonBuild + 3 ;
9820: LD_ADDR_VAR 0 6
9824: PUSH
9825: LD_VAR 0 6
9829: PUSH
9830: LD_INT 3
9832: PLUS
9833: ST_TO_ADDR
// NonBuildBuildings := NonBuild ;
9834: LD_ADDR_LOC 3
9838: PUSH
9839: LD_VAR 0 6
9843: ST_TO_ADDR
// if HeikeCratesTime then
9844: LD_LOC 5
9848: IFFALSE 9911
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
9850: LD_ADDR_OWVAR 47
9854: PUSH
9855: LD_STRING #Ru08-1
9857: PUSH
9858: LD_INT 0
9860: PUSH
9861: LD_LOC 3
9865: PLUS
9866: PUSH
9867: LD_STRING #Ru08-2
9869: PUSH
9870: LD_INT 0
9872: PUSH
9873: LD_LOC 4
9877: PLUS
9878: PUSH
9879: LD_STRING #Ru08-3
9881: PUSH
9882: LD_INT 0
9884: PUSH
9885: LD_EXP 56
9889: PLUS
9890: PUSH
9891: LD_STRING #Ru08-4
9893: PUSH
9894: LD_LOC 5
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: ST_TO_ADDR
9909: GO 9960
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
9911: LD_ADDR_OWVAR 47
9915: PUSH
9916: LD_STRING #Ru08-1
9918: PUSH
9919: LD_INT 0
9921: PUSH
9922: LD_LOC 3
9926: PLUS
9927: PUSH
9928: LD_STRING #Ru08-2
9930: PUSH
9931: LD_INT 0
9933: PUSH
9934: LD_LOC 4
9938: PLUS
9939: PUSH
9940: LD_STRING #Ru08-3
9942: PUSH
9943: LD_INT 0
9945: PUSH
9946: LD_EXP 56
9950: PLUS
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: ST_TO_ADDR
// if NonBuild + 0 = 11 and not GalleryAsked then
9960: LD_VAR 0 6
9964: PUSH
9965: LD_INT 0
9967: PLUS
9968: PUSH
9969: LD_INT 11
9971: EQUAL
9972: PUSH
9973: LD_EXP 66
9977: NOT
9978: AND
9979: IFFALSE 9984
// enable ( 201 ) ;
9981: LD_INT 201
9983: ENABLE_MARKED
// if NonBuild + 0 = 7 and not HuntingAsked then
9984: LD_VAR 0 6
9988: PUSH
9989: LD_INT 0
9991: PLUS
9992: PUSH
9993: LD_INT 7
9995: EQUAL
9996: PUSH
9997: LD_EXP 67
10001: NOT
10002: AND
10003: IFFALSE 10008
// enable ( 101 ) ;
10005: LD_INT 101
10007: ENABLE_MARKED
// if NonBuild + 0 = 3 and not FreetimeAsked then
10008: LD_VAR 0 6
10012: PUSH
10013: LD_INT 0
10015: PLUS
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: PUSH
10021: LD_EXP 68
10025: NOT
10026: AND
10027: IFFALSE 10032
// enable ( 301 ) ;
10029: LD_INT 301
10031: ENABLE_MARKED
// enable ;
10032: ENABLE
// end ;
10033: PPOPN 6
10035: END
// every 0 0$3 + 0 0$0.5 do var filter , veh , NonBuild ;
10036: GO 10038
10038: DISABLE
10039: LD_INT 0
10041: PPUSH
10042: PPUSH
10043: PPUSH
// begin NonBuild := AvailableWeapons ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_EXP 54
10053: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10054: LD_ADDR_VAR 0 1
10058: PUSH
10059: LD_INT 21
10061: PUSH
10062: LD_INT 2
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PUSH
10069: LD_INT 22
10071: PUSH
10072: LD_EXP 31
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: PPUSH
10085: CALL_OW 69
10089: ST_TO_ADDR
// for veh in filter do
10090: LD_ADDR_VAR 0 2
10094: PUSH
10095: LD_VAR 0 1
10099: PUSH
10100: FOR_IN
10101: IFFALSE 10133
// begin NonBuild := NonBuild diff GetWeapon ( veh ) ;
10103: LD_ADDR_VAR 0 3
10107: PUSH
10108: LD_VAR 0 3
10112: PUSH
10113: LD_VAR 0 2
10117: PPUSH
10118: CALL_OW 264
10122: DIFF
10123: ST_TO_ADDR
// Wait ( 1 ) ;
10124: LD_INT 1
10126: PPUSH
10127: CALL_OW 67
// end ;
10131: GO 10100
10133: POP
10134: POP
// if NonBuild = [ ] and not WeaponsDone then
10135: LD_VAR 0 3
10139: PUSH
10140: EMPTY
10141: EQUAL
10142: PUSH
10143: LD_EXP 50
10147: NOT
10148: AND
10149: IFFALSE 10168
// begin ChangeMissionObjectives ( MWeaponsDone ) ;
10151: LD_STRING MWeaponsDone
10153: PPUSH
10154: CALL_OW 337
// WeaponsDone := true ;
10158: LD_ADDR_EXP 50
10162: PUSH
10163: LD_INT 1
10165: ST_TO_ADDR
// end else
10166: GO 10198
// if NonBuild <> [ ] and WeaponsDone then
10168: LD_VAR 0 3
10172: PUSH
10173: EMPTY
10174: NONEQUAL
10175: PUSH
10176: LD_EXP 50
10180: AND
10181: IFFALSE 10198
// begin ChangeMissionObjectives ( Mweapons ) ;
10183: LD_STRING Mweapons
10185: PPUSH
10186: CALL_OW 337
// WeaponsDone := false ;
10190: LD_ADDR_EXP 50
10194: PUSH
10195: LD_INT 0
10197: ST_TO_ADDR
// end ; NonBuildWeapons := NonBuild ;
10198: LD_ADDR_LOC 4
10202: PUSH
10203: LD_VAR 0 3
10207: ST_TO_ADDR
// if HeikeCratesTime then
10208: LD_LOC 5
10212: IFFALSE 10275
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
10214: LD_ADDR_OWVAR 47
10218: PUSH
10219: LD_STRING #Ru08-1
10221: PUSH
10222: LD_INT 0
10224: PUSH
10225: LD_LOC 3
10229: PLUS
10230: PUSH
10231: LD_STRING #Ru08-2
10233: PUSH
10234: LD_INT 0
10236: PUSH
10237: LD_LOC 4
10241: PLUS
10242: PUSH
10243: LD_STRING #Ru08-3
10245: PUSH
10246: LD_INT 0
10248: PUSH
10249: LD_EXP 56
10253: PLUS
10254: PUSH
10255: LD_STRING #Ru08-4
10257: PUSH
10258: LD_LOC 5
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: LIST
10272: ST_TO_ADDR
10273: GO 10324
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
10275: LD_ADDR_OWVAR 47
10279: PUSH
10280: LD_STRING #Ru08-1
10282: PUSH
10283: LD_INT 0
10285: PUSH
10286: LD_LOC 3
10290: PLUS
10291: PUSH
10292: LD_STRING #Ru08-2
10294: PUSH
10295: LD_INT 0
10297: PUSH
10298: LD_LOC 4
10302: PLUS
10303: PUSH
10304: LD_STRING #Ru08-3
10306: PUSH
10307: LD_INT 0
10309: PUSH
10310: LD_EXP 56
10314: PLUS
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: ST_TO_ADDR
// enable ;
10324: ENABLE
// end ;
10325: PPOPN 3
10327: END
// every 0 0$2 marked 1 do var filter ;
10328: GO 10330
10330: DISABLE
10331: LD_INT 0
10333: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
10334: LD_ADDR_VAR 0 1
10338: PUSH
10339: LD_INT 22
10341: PUSH
10342: LD_EXP 31
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 2
10353: PUSH
10354: LD_INT 30
10356: PUSH
10357: LD_INT 0
10359: PUSH
10360: EMPTY
10361: LIST
10362: LIST
10363: PUSH
10364: LD_INT 30
10366: PUSH
10367: LD_INT 1
10369: PUSH
10370: EMPTY
10371: LIST
10372: LIST
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: LIST
10378: PUSH
10379: EMPTY
10380: LIST
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PPUSH
10386: CALL_OW 69
10390: ST_TO_ADDR
// if ( 0 + filter ) = 0 then
10391: LD_INT 0
10393: PUSH
10394: LD_VAR 0 1
10398: PLUS
10399: PUSH
10400: LD_INT 0
10402: EQUAL
10403: IFFALSE 10421
// filter := filter union Burlak ;
10405: LD_ADDR_VAR 0 1
10409: PUSH
10410: LD_VAR 0 1
10414: PUSH
10415: LD_EXP 1
10419: UNION
10420: ST_TO_ADDR
// if ( GetDistUnits ( Kurt , filter [ 1 ] ) < 8 ) or ( GetDistUnits ( Mercenary1 , filter [ 1 ] ) < 8 ) then
10421: LD_EXP 13
10425: PPUSH
10426: LD_VAR 0 1
10430: PUSH
10431: LD_INT 1
10433: ARRAY
10434: PPUSH
10435: CALL_OW 296
10439: PUSH
10440: LD_INT 8
10442: LESS
10443: PUSH
10444: LD_EXP 14
10448: PPUSH
10449: LD_VAR 0 1
10453: PUSH
10454: LD_INT 1
10456: ARRAY
10457: PPUSH
10458: CALL_OW 296
10462: PUSH
10463: LD_INT 8
10465: LESS
10466: OR
10467: IFFALSE 10498
// begin SetSide ( [ Kurt , Mercenary1 ] , you ) ;
10469: LD_EXP 13
10473: PUSH
10474: LD_EXP 14
10478: PUSH
10479: EMPTY
10480: LIST
10481: LIST
10482: PPUSH
10483: LD_EXP 31
10487: PPUSH
10488: CALL_OW 235
// enable ( 10 ) ;
10492: LD_INT 10
10494: ENABLE_MARKED
// enable ( 601 ) ;
10495: LD_INT 601
10497: ENABLE_MARKED
// end ; if GetSide ( Kurt ) = you and GetSide ( Mercenary1 ) = you then
10498: LD_EXP 13
10502: PPUSH
10503: CALL_OW 255
10507: PUSH
10508: LD_EXP 31
10512: EQUAL
10513: PUSH
10514: LD_EXP 14
10518: PPUSH
10519: CALL_OW 255
10523: PUSH
10524: LD_EXP 31
10528: EQUAL
10529: AND
10530: IFFALSE 10535
// disable else
10532: DISABLE
10533: GO 10536
// enable ;
10535: ENABLE
// end ;
10536: PPOPN 1
10538: END
// every 0 0$1 + 0 0$0.2 marked 2 do var list ;
10539: GO 10541
10541: DISABLE
10542: LD_INT 0
10544: PPUSH
// begin list = [ false , false ] ;
10545: LD_ADDR_VAR 0 1
10549: PUSH
10550: LD_INT 0
10552: PUSH
10553: LD_INT 0
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: ST_TO_ADDR
// if IsLive ( Kurt ) and UnitShoot ( Kurt ) > 0 then
10560: LD_EXP 13
10564: PPUSH
10565: CALL_OW 300
10569: PUSH
10570: LD_EXP 13
10574: PPUSH
10575: CALL_OW 504
10579: PUSH
10580: LD_INT 0
10582: GREATER
10583: AND
10584: IFFALSE 10629
// if GetSide ( UnitShoot ( Kurt ) ) = you then
10586: LD_EXP 13
10590: PPUSH
10591: CALL_OW 504
10595: PPUSH
10596: CALL_OW 255
10600: PUSH
10601: LD_EXP 31
10605: EQUAL
10606: IFFALSE 10629
// list = Replace ( list , 1 , true ) ;
10608: LD_ADDR_VAR 0 1
10612: PUSH
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_INT 1
10620: PPUSH
10621: LD_INT 1
10623: PPUSH
10624: CALL_OW 1
10628: ST_TO_ADDR
// if IsLive ( Mercenary1 ) and UnitShoot ( Mercenary1 ) > 0 then
10629: LD_EXP 14
10633: PPUSH
10634: CALL_OW 300
10638: PUSH
10639: LD_EXP 14
10643: PPUSH
10644: CALL_OW 504
10648: PUSH
10649: LD_INT 0
10651: GREATER
10652: AND
10653: IFFALSE 10698
// if GetSide ( UnitShoot ( Mercenary1 ) ) = you then
10655: LD_EXP 14
10659: PPUSH
10660: CALL_OW 504
10664: PPUSH
10665: CALL_OW 255
10669: PUSH
10670: LD_EXP 31
10674: EQUAL
10675: IFFALSE 10698
// list = Replace ( list , 2 , true ) ;
10677: LD_ADDR_VAR 0 1
10681: PUSH
10682: LD_VAR 0 1
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_INT 1
10692: PPUSH
10693: CALL_OW 1
10697: ST_TO_ADDR
// if true in list then
10698: LD_INT 1
10700: PUSH
10701: LD_VAR 0 1
10705: IN
10706: IFFALSE 10797
// begin disable ( 601 ) ;
10708: LD_INT 601
10710: DISABLE_MARKED
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
10711: LD_EXP 13
10715: PUSH
10716: LD_EXP 14
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PPUSH
10725: LD_EXP 34
10729: PPUSH
10730: CALL_OW 235
// SetAttitude ( you , merc , att_enemy , true ) ;
10734: LD_EXP 31
10738: PPUSH
10739: LD_EXP 34
10743: PPUSH
10744: LD_INT 2
10746: PPUSH
10747: LD_INT 1
10749: PPUSH
10750: CALL_OW 80
// D_MercAmbush ;
10754: CALL 5313 0 0
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , 27 , 52 ) ;
10758: LD_EXP 13
10762: PUSH
10763: LD_EXP 14
10767: PUSH
10768: EMPTY
10769: LIST
10770: LIST
10771: PPUSH
10772: LD_INT 27
10774: PPUSH
10775: LD_INT 52
10777: PPUSH
10778: CALL_OW 114
// enable ( 23 ) ;
10782: LD_INT 23
10784: ENABLE_MARKED
// merc_attack ;
10785: CALL 7744 0 0
// disabled2 := true ;
10789: LD_ADDR_EXP 86
10793: PUSH
10794: LD_INT 1
10796: ST_TO_ADDR
// end ; if not disabled2 then
10797: LD_EXP 86
10801: NOT
10802: IFFALSE 10805
// enable ;
10804: ENABLE
// end ;
10805: PPOPN 1
10807: END
// every 0 0$10 marked 3 do
10808: GO 10810
10810: DISABLE
// begin countdown := countdown - 10 * 35 ;
10811: LD_ADDR_EXP 77
10815: PUSH
10816: LD_EXP 77
10820: PUSH
10821: LD_INT 10
10823: PUSH
10824: LD_INT 35
10826: MUL
10827: MINUS
10828: ST_TO_ADDR
// if countdown < 0 and not HeikeDismissed then
10829: LD_EXP 77
10833: PUSH
10834: LD_INT 0
10836: LESS
10837: PUSH
10838: LD_EXP 45
10842: NOT
10843: AND
10844: IFFALSE 10861
// begin disabled3 := true ;
10846: LD_ADDR_EXP 87
10850: PUSH
10851: LD_INT 1
10853: ST_TO_ADDR
// enable ( 24 ) ;
10854: LD_INT 24
10856: ENABLE_MARKED
// merc_attack ;
10857: CALL 7744 0 0
// end ; if not disabled3 then
10861: LD_EXP 87
10865: NOT
10866: IFFALSE 10869
// enable ;
10868: ENABLE
// end ;
10869: END
// every 0 0$1 marked 24 do
10870: GO 10872
10872: DISABLE
// begin Wait ( 0 0$20 ) ;
10873: LD_INT 700
10875: PPUSH
10876: CALL_OW 67
// D_MercAttack ;
10880: CALL 5366 0 0
// end ;
10884: END
// every 0 0$1 + 0 0$0.4 marked 4 do
10885: GO 10887
10887: DISABLE
// begin if IsInArea ( Heike , WaitHeikeArea ) and not HeikeDismissed then
10888: LD_EXP 11
10892: PPUSH
10893: LD_INT 8
10895: PPUSH
10896: CALL_OW 308
10900: PUSH
10901: LD_EXP 45
10905: NOT
10906: AND
10907: IFFALSE 11000
// begin SetSide ( Heike , merc ) ;
10909: LD_EXP 11
10913: PPUSH
10914: LD_EXP 34
10918: PPUSH
10919: CALL_OW 235
// ComMoveToArea ( [ Kurt , Mercenary1 , Heike ] , MercExitArea ) ;
10923: LD_EXP 13
10927: PUSH
10928: LD_EXP 14
10932: PUSH
10933: LD_EXP 11
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: PPUSH
10943: LD_INT 7
10945: PPUSH
10946: CALL_OW 113
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
10950: LD_INT 8
10952: PPUSH
10953: LD_INT 0
10955: PPUSH
10956: CALL_OW 424
// HeikeDismissed := true ;
10960: LD_ADDR_EXP 45
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// if not PopovAsked then
10968: LD_EXP 46
10972: NOT
10973: IFFALSE 10979
// D_MercPopov ;
10975: CALL 5261 0 0
// enable ( 5 ) ;
10979: LD_INT 5
10981: ENABLE_MARKED
// disabled6 := true ;
10982: LD_ADDR_EXP 90
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// disabled3 := true ;
10990: LD_ADDR_EXP 87
10994: PUSH
10995: LD_INT 1
10997: ST_TO_ADDR
// end else
10998: GO 11001
// enable ;
11000: ENABLE
// end ;
11001: END
// every 0 0$1 + 0 0$0.5 marked 5 do var filter , un ;
11002: GO 11004
11004: DISABLE
11005: LD_INT 0
11007: PPUSH
11008: PPUSH
// begin filter := FilterUnitsInArea ( MercExitArea , [ f_or , [ f_side , merc ] , [ f_side , arab ] ] ) ;
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 7
11016: PPUSH
11017: LD_INT 2
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_EXP 34
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: PUSH
11032: LD_INT 22
11034: PUSH
11035: LD_EXP 33
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: LIST
11048: PPUSH
11049: CALL_OW 70
11053: ST_TO_ADDR
// for un in filter do
11054: LD_ADDR_VAR 0 2
11058: PUSH
11059: LD_VAR 0 1
11063: PUSH
11064: FOR_IN
11065: IFFALSE 11085
// begin RemoveUnit ( un ) ;
11067: LD_VAR 0 2
11071: PPUSH
11072: CALL_OW 64
// Wait ( 1 ) ;
11076: LD_INT 1
11078: PPUSH
11079: CALL_OW 67
// end ;
11083: GO 11064
11085: POP
11086: POP
// if not disabled5 then
11087: LD_EXP 89
11091: NOT
11092: IFFALSE 11095
// enable ;
11094: ENABLE
// end ;
11095: PPOPN 2
11097: END
// every 0 0$1 + 0 0$0.6 marked 6 do
11098: GO 11100
11100: DISABLE
// begin if IsInArea ( Kurt , WaitHeikeArea ) then
11101: LD_EXP 13
11105: PPUSH
11106: LD_INT 8
11108: PPUSH
11109: CALL_OW 308
11113: IFFALSE 11120
// enable ( 4 ) else
11115: LD_INT 4
11117: ENABLE_MARKED
11118: GO 11121
// enable ;
11120: ENABLE
// end ;
11121: END
// every 0 0$1 + 0 0$0.7 marked 7 do var un , i , done ;
11122: GO 11124
11124: DISABLE
11125: LD_INT 0
11127: PPUSH
11128: PPUSH
11129: PPUSH
// begin for un in player_units do
11130: LD_ADDR_VAR 0 1
11134: PUSH
11135: LD_EXP 26
11139: PUSH
11140: FOR_IN
11141: IFFALSE 11372
// begin if GetSide ( Attacks ( un ) ) = arab and not disabled7 then
11143: LD_VAR 0 1
11147: PPUSH
11148: CALL_OW 320
11152: PPUSH
11153: CALL_OW 255
11157: PUSH
11158: LD_EXP 33
11162: EQUAL
11163: PUSH
11164: LD_EXP 91
11168: NOT
11169: AND
11170: IFFALSE 11370
// begin GenscherBetrayed := true ;
11172: LD_ADDR_EXP 36
11176: PUSH
11177: LD_INT 1
11179: ST_TO_ADDR
// disabled7 := true ;
11180: LD_ADDR_EXP 91
11184: PUSH
11185: LD_INT 1
11187: ST_TO_ADDR
// D_HandOverSpoiled ;
11188: CALL 5649 0 0
// SetAttitude ( you , arab , att_enemy , true ) ;
11192: LD_EXP 31
11196: PPUSH
11197: LD_EXP 33
11201: PPUSH
11202: LD_INT 2
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 80
// repeat wait ( 0 0$0.5 ) ;
11212: LD_INT 18
11214: PPUSH
11215: CALL_OW 67
// done = true ;
11219: LD_ADDR_VAR 0 3
11223: PUSH
11224: LD_INT 1
11226: ST_TO_ADDR
// for i in ar_human do
11227: LD_ADDR_VAR 0 2
11231: PUSH
11232: LD_EXP 80
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11356
// begin if not IsPlaced ( i ) and GetLives ( i ) > 0 then
11240: LD_VAR 0 2
11244: PPUSH
11245: CALL_OW 305
11249: NOT
11250: PUSH
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 256
11260: PUSH
11261: LD_INT 0
11263: GREATER
11264: AND
11265: IFFALSE 11277
// begin done = false ;
11267: LD_ADDR_VAR 0 3
11271: PUSH
11272: LD_INT 0
11274: ST_TO_ADDR
// continue ;
11275: GO 11237
// end ; if not IsOk ( i ) then
11277: LD_VAR 0 2
11281: PPUSH
11282: CALL_OW 302
11286: NOT
11287: IFFALSE 11291
// continue ;
11289: GO 11237
// if IsInUnit ( i ) > 0 then
11291: LD_VAR 0 2
11295: PPUSH
11296: CALL_OW 310
11300: PUSH
11301: LD_INT 0
11303: GREATER
11304: IFFALSE 11325
// begin ComExitVehicle ( i ) ;
11306: LD_VAR 0 2
11310: PPUSH
11311: CALL_OW 121
// done = false ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// end else
11323: GO 11354
// ComAgressiveMove ( i , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11325: LD_VAR 0 2
11329: PPUSH
11330: LD_EXP 1
11334: PPUSH
11335: CALL_OW 250
11339: PPUSH
11340: LD_EXP 1
11344: PPUSH
11345: CALL_OW 251
11349: PPUSH
11350: CALL_OW 114
// end ;
11354: GO 11237
11356: POP
11357: POP
// until MercHandoverArabsSpawned and done ;
11358: LD_EXP 43
11362: PUSH
11363: LD_VAR 0 3
11367: AND
11368: IFFALSE 11212
// end ; end ;
11370: GO 11140
11372: POP
11373: POP
// if not disabled7 and not MercHandoverDone then
11374: LD_EXP 91
11378: NOT
11379: PUSH
11380: LD_EXP 42
11384: NOT
11385: AND
11386: IFFALSE 11389
// enable ;
11388: ENABLE
// end ;
11389: PPOPN 3
11391: END
// every 0 0$0.5 + 0 0$0.3 marked 8 do
11392: GO 11394
11394: DISABLE
// begin if disabled7 then
11395: LD_EXP 91
11399: IFFALSE 11404
// begin disable ;
11401: DISABLE
// exit ;
11402: GO 11994
// end ; if not MercHandedOver then
11404: LD_EXP 40
11408: NOT
11409: IFFALSE 11413
// exit ;
11411: GO 11994
// if not GetSide ( Kurt ) = arab then
11413: LD_EXP 13
11417: PPUSH
11418: CALL_OW 255
11422: PUSH
11423: LD_EXP 33
11427: EQUAL
11428: NOT
11429: IFFALSE 11449
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
11431: LD_EXP 80
11435: PUSH
11436: LD_INT 1
11438: ARRAY
11439: PPUSH
11440: LD_EXP 13
11444: PPUSH
11445: CALL_OW 115
// if not GetSide ( Mercenary1 ) = arab then
11449: LD_EXP 14
11453: PPUSH
11454: CALL_OW 255
11458: PUSH
11459: LD_EXP 33
11463: EQUAL
11464: NOT
11465: IFFALSE 11485
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11467: LD_EXP 80
11471: PUSH
11472: LD_INT 2
11474: ARRAY
11475: PPUSH
11476: LD_EXP 14
11480: PPUSH
11481: CALL_OW 115
// if not IsLive ( Kurt ) or not IsLive ( Mercenary1 ) then
11485: LD_EXP 13
11489: PPUSH
11490: CALL_OW 300
11494: NOT
11495: PUSH
11496: LD_EXP 14
11500: PPUSH
11501: CALL_OW 300
11505: NOT
11506: OR
11507: IFFALSE 11578
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] ] , [ [ 29 , 57 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11509: LD_INT 1
11511: PPUSH
11512: LD_EXP 80
11516: PUSH
11517: LD_INT 1
11519: ARRAY
11520: PUSH
11521: LD_EXP 80
11525: PUSH
11526: LD_INT 2
11528: ARRAY
11529: PUSH
11530: LD_EXP 80
11534: PUSH
11535: LD_INT 3
11537: ARRAY
11538: PUSH
11539: EMPTY
11540: LIST
11541: LIST
11542: LIST
11543: PPUSH
11544: LD_INT 29
11546: PUSH
11547: LD_INT 57
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: EMPTY
11555: LIST
11556: PPUSH
11557: LD_INT 1
11559: PUSH
11560: LD_INT 3
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 5
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PPUSH
11574: CALL_OW 398
// if Attacks ( ar_human [ 1 ] ) = Kurt then
11578: LD_EXP 80
11582: PUSH
11583: LD_INT 1
11585: ARRAY
11586: PPUSH
11587: CALL_OW 320
11591: PUSH
11592: LD_EXP 13
11596: EQUAL
11597: IFFALSE 11711
// begin ComStop ( [ Kurt , Mercenary1 ] ) ;
11599: LD_EXP 13
11603: PUSH
11604: LD_EXP 14
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PPUSH
11613: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11617: LD_EXP 13
11621: PUSH
11622: LD_EXP 14
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PPUSH
11631: LD_EXP 33
11635: PPUSH
11636: CALL_OW 235
// ComStop ( ar_human [ 1 ] ) ;
11640: LD_EXP 80
11644: PUSH
11645: LD_INT 1
11647: ARRAY
11648: PPUSH
11649: CALL_OW 141
// Wait ( 2 ) ;
11653: LD_INT 2
11655: PPUSH
11656: CALL_OW 67
// AddComMoveUnit ( ar_human [ 1 ] , Kurt ) ;
11660: LD_EXP 80
11664: PUSH
11665: LD_INT 1
11667: ARRAY
11668: PPUSH
11669: LD_EXP 13
11673: PPUSH
11674: CALL_OW 172
// if GetLives ( Kurt ) < 300 then
11678: LD_EXP 13
11682: PPUSH
11683: CALL_OW 256
11687: PUSH
11688: LD_INT 300
11690: LESS
11691: IFFALSE 11711
// AddComHeal ( ar_human [ 3 ] , Kurt ) ;
11693: LD_EXP 80
11697: PUSH
11698: LD_INT 3
11700: ARRAY
11701: PPUSH
11702: LD_EXP 13
11706: PPUSH
11707: CALL_OW 188
// end ; if Attacks ( ar_human [ 2 ] ) = Mercenary1 then
11711: LD_EXP 80
11715: PUSH
11716: LD_INT 2
11718: ARRAY
11719: PPUSH
11720: CALL_OW 320
11724: PUSH
11725: LD_EXP 14
11729: EQUAL
11730: IFFALSE 11844
// begin ComStop ( ar_human [ 2 ] ) ;
11732: LD_EXP 80
11736: PUSH
11737: LD_INT 2
11739: ARRAY
11740: PPUSH
11741: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11745: LD_EXP 13
11749: PUSH
11750: LD_EXP 14
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: PPUSH
11759: LD_EXP 33
11763: PPUSH
11764: CALL_OW 235
// ComStop ( [ Kurt , Mercenary1 ] ) ;
11768: LD_EXP 13
11772: PUSH
11773: LD_EXP 14
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PPUSH
11782: CALL_OW 141
// Wait ( 2 ) ;
11786: LD_INT 2
11788: PPUSH
11789: CALL_OW 67
// AddComMoveUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11793: LD_EXP 80
11797: PUSH
11798: LD_INT 2
11800: ARRAY
11801: PPUSH
11802: LD_EXP 14
11806: PPUSH
11807: CALL_OW 172
// if GetLives ( Mercenary1 ) < 300 then
11811: LD_EXP 14
11815: PPUSH
11816: CALL_OW 256
11820: PUSH
11821: LD_INT 300
11823: LESS
11824: IFFALSE 11844
// AddComHeal ( ar_human [ 3 ] , Mercenary1 ) ;
11826: LD_EXP 80
11830: PUSH
11831: LD_INT 3
11833: ARRAY
11834: PPUSH
11835: LD_EXP 14
11839: PPUSH
11840: CALL_OW 188
// end ; if GetSide ( Kurt ) = arab and GetSide ( Mercenary1 ) = arab then
11844: LD_EXP 13
11848: PPUSH
11849: CALL_OW 255
11853: PUSH
11854: LD_EXP 33
11858: EQUAL
11859: PUSH
11860: LD_EXP 14
11864: PPUSH
11865: CALL_OW 255
11869: PUSH
11870: LD_EXP 33
11874: EQUAL
11875: AND
11876: IFFALSE 11986
// begin disabled8 := true ;
11878: LD_ADDR_EXP 92
11882: PUSH
11883: LD_INT 1
11885: ST_TO_ADDR
// disable ( 2 ) ;
11886: LD_INT 2
11888: DISABLE_MARKED
// disable ( 6 ) ;
11889: LD_INT 6
11891: DISABLE_MARKED
// disable ( 12 ) ;
11892: LD_INT 12
11894: DISABLE_MARKED
// Wait ( 0 0$5 ) ;
11895: LD_INT 175
11897: PPUSH
11898: CALL_OW 67
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] , Kurt , Mercenary1 ] , [ [ 115 , 32 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11902: LD_INT 1
11904: PPUSH
11905: LD_EXP 80
11909: PUSH
11910: LD_INT 1
11912: ARRAY
11913: PUSH
11914: LD_EXP 80
11918: PUSH
11919: LD_INT 2
11921: ARRAY
11922: PUSH
11923: LD_EXP 80
11927: PUSH
11928: LD_INT 3
11930: ARRAY
11931: PUSH
11932: LD_EXP 13
11936: PUSH
11937: LD_EXP 14
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: PPUSH
11949: LD_INT 115
11951: PUSH
11952: LD_INT 32
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: EMPTY
11960: LIST
11961: PPUSH
11962: LD_INT 1
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 5
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PPUSH
11979: CALL_OW 398
// enable ( 11 ) ;
11983: LD_INT 11
11985: ENABLE_MARKED
// end ; if not disabled8 then
11986: LD_EXP 92
11990: NOT
11991: IFFALSE 11994
// enable ;
11993: ENABLE
// end ;
11994: END
// every 0 0$1 + 0 0$0.1 marked 8 do
11995: GO 11997
11997: DISABLE
// begin repeat wait ( 0 0$1 ) ;
11998: LD_INT 35
12000: PPUSH
12001: CALL_OW 67
// if GenscherBetrayed then
12005: LD_EXP 36
12009: IFFALSE 12013
// exit ;
12011: GO 12052
// if UnitFilter ( ar_human , [ f_placed ] ) = 0 then
12013: LD_EXP 80
12017: PPUSH
12018: LD_INT 52
12020: PUSH
12021: EMPTY
12022: LIST
12023: PPUSH
12024: CALL_OW 72
12028: PUSH
12029: LD_INT 0
12031: EQUAL
12032: IFFALSE 12048
// begin SA_OnLegionHandoverToUPF ;
12034: CALL 18945 0 0
// MercHandoverDone = true ;
12038: LD_ADDR_EXP 42
12042: PUSH
12043: LD_INT 1
12045: ST_TO_ADDR
// exit ;
12046: GO 12052
// end ; until false ;
12048: LD_INT 0
12050: IFFALSE 11998
// end ;
12052: END
// every 0 0$1 + 0 0$0.9 marked 9 do var un1 , un2 ;
12053: GO 12055
12055: DISABLE
12056: LD_INT 0
12058: PPUSH
12059: PPUSH
// begin if disabled7 then
12060: LD_EXP 91
12064: IFFALSE 12069
// begin disable ;
12066: DISABLE
// exit ;
12067: GO 12295
// end ; if IsInUnit ( ar_human [ 1 ] ) = 0 and IsInUnit ( ar_human [ 2 ] ) = 0 then
12069: LD_EXP 80
12073: PUSH
12074: LD_INT 1
12076: ARRAY
12077: PPUSH
12078: CALL_OW 310
12082: PUSH
12083: LD_INT 0
12085: EQUAL
12086: PUSH
12087: LD_EXP 80
12091: PUSH
12092: LD_INT 2
12094: ARRAY
12095: PPUSH
12096: CALL_OW 310
12100: PUSH
12101: LD_INT 0
12103: EQUAL
12104: AND
12105: IFFALSE 12287
// begin disable ( 601 ) ;
12107: LD_INT 601
12109: DISABLE_MARKED
// D_HandOverCome ;
12110: CALL 5609 0 0
// MercHandedOver := true ;
12114: LD_ADDR_EXP 40
12118: PUSH
12119: LD_INT 1
12121: ST_TO_ADDR
// disable ( 20 ) ;
12122: LD_INT 20
12124: DISABLE_MARKED
// enable ( 23 ) ;
12125: LD_INT 23
12127: ENABLE_MARKED
// enable ( 8 ) ;
12128: LD_INT 8
12130: ENABLE_MARKED
// ComStop ( [ Kurt , Mercenary1 ] ) ;
12131: LD_EXP 13
12135: PUSH
12136: LD_EXP 14
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PPUSH
12145: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
12149: LD_EXP 13
12153: PUSH
12154: LD_EXP 14
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: PPUSH
12163: LD_EXP 34
12167: PPUSH
12168: CALL_OW 235
// SetAttitude ( you , merc , att_neutral , true ) ;
12172: LD_EXP 31
12176: PPUSH
12177: LD_EXP 34
12181: PPUSH
12182: LD_INT 0
12184: PPUSH
12185: LD_INT 1
12187: PPUSH
12188: CALL_OW 80
// SetAttitude ( merc , arab , att_friend , true ) ;
12192: LD_EXP 34
12196: PPUSH
12197: LD_EXP 33
12201: PPUSH
12202: LD_INT 1
12204: PPUSH
12205: LD_INT 1
12207: PPUSH
12208: CALL_OW 80
// Wait ( 2 ) ;
12212: LD_INT 2
12214: PPUSH
12215: CALL_OW 67
// enable ( 5 ) ;
12219: LD_INT 5
12221: ENABLE_MARKED
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
12222: LD_EXP 80
12226: PUSH
12227: LD_INT 1
12229: ARRAY
12230: PPUSH
12231: LD_EXP 13
12235: PPUSH
12236: CALL_OW 115
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
12240: LD_EXP 80
12244: PUSH
12245: LD_INT 2
12247: ARRAY
12248: PPUSH
12249: LD_EXP 14
12253: PPUSH
12254: CALL_OW 115
// ComMoveToArea ( [ Kurt , Mercenary1 ] , MercExitArea ) ;
12258: LD_EXP 13
12262: PUSH
12263: LD_EXP 14
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PPUSH
12272: LD_INT 7
12274: PPUSH
12275: CALL_OW 113
// disabled9 := true ;
12279: LD_ADDR_EXP 93
12283: PUSH
12284: LD_INT 1
12286: ST_TO_ADDR
// end ; if not disabled9 then
12287: LD_EXP 93
12291: NOT
12292: IFFALSE 12295
// enable ;
12294: ENABLE
// end ;
12295: PPOPN 2
12297: END
// every 0 0$1 marked 10 do var rnd ;
12298: GO 12300
12300: DISABLE
12301: LD_INT 0
12303: PPUSH
// begin rnd := Rand ( 0 0$30 , 0 0$45 ) ;
12304: LD_ADDR_VAR 0 1
12308: PUSH
12309: LD_INT 1050
12311: PPUSH
12312: LD_INT 1575
12314: PPUSH
12315: CALL_OW 12
12319: ST_TO_ADDR
// Wait ( rnd ) ;
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 67
// if GetAttitude ( you , merc ) = att_neutral and GetSide ( Kurt ) = you then
12329: LD_EXP 31
12333: PPUSH
12334: LD_EXP 34
12338: PPUSH
12339: CALL_OW 81
12343: PUSH
12344: LD_INT 0
12346: EQUAL
12347: PUSH
12348: LD_EXP 13
12352: PPUSH
12353: CALL_OW 255
12357: PUSH
12358: LD_EXP 31
12362: EQUAL
12363: AND
12364: IFFALSE 12370
// D_ArabianRequest ;
12366: CALL 5406 0 0
// end ;
12370: PPOPN 1
12372: END
// every 0 0$1 + 0 0$0.2 marked 11 do var filter , un , disablefilter ;
12373: GO 12375
12375: DISABLE
12376: LD_INT 0
12378: PPUSH
12379: PPUSH
12380: PPUSH
// begin filter := FilterUnitsInArea ( HandOverEnterArea , [ [ f_side , arab ] , [ f_type , unit_human ] ] ) ;
12381: LD_ADDR_VAR 0 1
12385: PUSH
12386: LD_INT 6
12388: PPUSH
12389: LD_INT 22
12391: PUSH
12392: LD_EXP 33
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: PUSH
12401: LD_INT 21
12403: PUSH
12404: LD_INT 1
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PPUSH
12415: CALL_OW 70
12419: ST_TO_ADDR
// for un in filter do
12420: LD_ADDR_VAR 0 2
12424: PUSH
12425: LD_VAR 0 1
12429: PUSH
12430: FOR_IN
12431: IFFALSE 12451
// begin RemoveUnit ( un ) ;
12433: LD_VAR 0 2
12437: PPUSH
12438: CALL_OW 64
// Wait ( 1 ) ;
12442: LD_INT 1
12444: PPUSH
12445: CALL_OW 67
// end ;
12449: GO 12430
12451: POP
12452: POP
// disablefilter := FilterAllUnits ( [ f_side , arab ] ) ;
12453: LD_ADDR_VAR 0 3
12457: PUSH
12458: LD_INT 22
12460: PUSH
12461: LD_EXP 33
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PPUSH
12470: CALL_OW 69
12474: ST_TO_ADDR
// if 0 + disablefilter > 0 then
12475: LD_INT 0
12477: PUSH
12478: LD_VAR 0 3
12482: PLUS
12483: PUSH
12484: LD_INT 0
12486: GREATER
12487: IFFALSE 12492
// enable else
12489: ENABLE
12490: GO 12496
// begin disable ;
12492: DISABLE
// disable ( 7 ) ;
12493: LD_INT 7
12495: DISABLE_MARKED
// end ; end ;
12496: PPOPN 3
12498: END
// var HeikeCratesTime , LegionDone ; every 0 0$1 marked 13 do var un , filter , amount ;
12499: GO 12501
12501: DISABLE
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// begin if ( not HeikeKilled ) and HeikeDismissed then
12507: LD_EXP 38
12511: NOT
12512: PUSH
12513: LD_EXP 45
12517: AND
12518: IFFALSE 13298
// begin disabled5 := true ;
12520: LD_ADDR_EXP 89
12524: PUSH
12525: LD_INT 1
12527: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
12528: LD_INT 175
12530: PPUSH
12531: CALL_OW 67
// D_LegionFormed ;
12535: CALL 5677 0 0
// case Query ( QLegion ) of 1 :
12539: LD_STRING QLegion
12541: PPUSH
12542: CALL_OW 97
12546: PUSH
12547: LD_INT 1
12549: DOUBLE
12550: EQUAL
12551: IFTRUE 12555
12553: GO 13282
12555: POP
// begin amount := 0 ;
12556: LD_ADDR_VAR 0 3
12560: PUSH
12561: LD_INT 0
12563: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12564: LD_ADDR_VAR 0 2
12568: PUSH
12569: LD_INT 22
12571: PUSH
12572: LD_EXP 31
12576: PUSH
12577: EMPTY
12578: LIST
12579: LIST
12580: PUSH
12581: LD_INT 2
12583: PUSH
12584: LD_INT 30
12586: PUSH
12587: LD_INT 0
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PUSH
12594: LD_INT 30
12596: PUSH
12597: LD_INT 1
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: LIST
12608: PUSH
12609: EMPTY
12610: LIST
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PPUSH
12616: CALL_OW 69
12620: ST_TO_ADDR
// if filter <> [ ] then
12621: LD_VAR 0 2
12625: PUSH
12626: EMPTY
12627: NONEQUAL
12628: IFFALSE 12676
// for un in filter do
12630: LD_ADDR_VAR 0 1
12634: PUSH
12635: LD_VAR 0 2
12639: PUSH
12640: FOR_IN
12641: IFFALSE 12674
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12643: LD_ADDR_VAR 0 3
12647: PUSH
12648: LD_VAR 0 3
12652: PUSH
12653: LD_VAR 0 1
12657: PPUSH
12658: CALL_OW 274
12662: PPUSH
12663: LD_INT 1
12665: PPUSH
12666: CALL_OW 275
12670: PLUS
12671: ST_TO_ADDR
12672: GO 12640
12674: POP
12675: POP
// if amount < 50 then
12676: LD_VAR 0 3
12680: PUSH
12681: LD_INT 50
12683: LESS
12684: IFFALSE 13108
// begin HeikeCratesTime := 0 0$60 ;
12686: LD_ADDR_LOC 5
12690: PUSH
12691: LD_INT 2100
12693: ST_TO_ADDR
// repeat display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] ;
12694: LD_ADDR_OWVAR 47
12698: PUSH
12699: LD_STRING #Ru08-1
12701: PUSH
12702: LD_INT 0
12704: PUSH
12705: LD_LOC 3
12709: PLUS
12710: PUSH
12711: LD_STRING #Ru08-2
12713: PUSH
12714: LD_INT 0
12716: PUSH
12717: LD_LOC 4
12721: PLUS
12722: PUSH
12723: LD_STRING #Ru08-3
12725: PUSH
12726: LD_INT 0
12728: PUSH
12729: LD_EXP 56
12733: PLUS
12734: PUSH
12735: LD_STRING #Ru08-4
12737: PUSH
12738: LD_LOC 5
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: ST_TO_ADDR
// amount := 0 ;
12753: LD_ADDR_VAR 0 3
12757: PUSH
12758: LD_INT 0
12760: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12761: LD_ADDR_VAR 0 2
12765: PUSH
12766: LD_INT 22
12768: PUSH
12769: LD_EXP 31
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: LD_INT 2
12780: PUSH
12781: LD_INT 30
12783: PUSH
12784: LD_INT 0
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 30
12793: PUSH
12794: LD_INT 1
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: LIST
12805: PUSH
12806: EMPTY
12807: LIST
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PPUSH
12813: CALL_OW 69
12817: ST_TO_ADDR
// if filter <> [ ] then
12818: LD_VAR 0 2
12822: PUSH
12823: EMPTY
12824: NONEQUAL
12825: IFFALSE 12873
// for un in filter do
12827: LD_ADDR_VAR 0 1
12831: PUSH
12832: LD_VAR 0 2
12836: PUSH
12837: FOR_IN
12838: IFFALSE 12871
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12840: LD_ADDR_VAR 0 3
12844: PUSH
12845: LD_VAR 0 3
12849: PUSH
12850: LD_VAR 0 1
12854: PPUSH
12855: CALL_OW 274
12859: PPUSH
12860: LD_INT 1
12862: PPUSH
12863: CALL_OW 275
12867: PLUS
12868: ST_TO_ADDR
12869: GO 12837
12871: POP
12872: POP
// Wait ( 0 0$1 ) ;
12873: LD_INT 35
12875: PPUSH
12876: CALL_OW 67
// HeikeCratesTime := HeikeCratesTime - 0 0$1 ;
12880: LD_ADDR_LOC 5
12884: PUSH
12885: LD_LOC 5
12889: PUSH
12890: LD_INT 35
12892: MINUS
12893: ST_TO_ADDR
// until amount >= 50 or HeikeCratesTime <= 0 ;
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 50
12901: GREATEREQUAL
12902: PUSH
12903: LD_LOC 5
12907: PUSH
12908: LD_INT 0
12910: LESSEQUAL
12911: OR
12912: IFFALSE 12694
// if amount >= 50 and HeikeCratesTime > 0 then
12914: LD_VAR 0 3
12918: PUSH
12919: LD_INT 50
12921: GREATEREQUAL
12922: PUSH
12923: LD_LOC 5
12927: PUSH
12928: LD_INT 0
12930: GREATER
12931: AND
12932: IFFALSE 13106
// begin D_QrLegion1 ;
12934: CALL 5753 0 0
// MercPaid := true ;
12938: LD_ADDR_EXP 39
12942: PUSH
12943: LD_INT 1
12945: ST_TO_ADDR
// amount := 50 ;
12946: LD_ADDR_VAR 0 3
12950: PUSH
12951: LD_INT 50
12953: ST_TO_ADDR
// for un in filter do
12954: LD_ADDR_VAR 0 1
12958: PUSH
12959: LD_VAR 0 2
12963: PUSH
12964: FOR_IN
12965: IFFALSE 13104
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
12967: LD_VAR 0 1
12971: PPUSH
12972: CALL_OW 274
12976: PPUSH
12977: LD_INT 1
12979: PPUSH
12980: CALL_OW 275
12984: PUSH
12985: LD_VAR 0 3
12989: LESS
12990: PUSH
12991: LD_VAR 0 3
12995: PUSH
12996: LD_INT 0
12998: NONEQUAL
12999: AND
13000: IFFALSE 13053
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13002: LD_ADDR_VAR 0 3
13006: PUSH
13007: LD_VAR 0 3
13011: PUSH
13012: LD_VAR 0 1
13016: PPUSH
13017: CALL_OW 274
13021: PPUSH
13022: LD_INT 1
13024: PPUSH
13025: CALL_OW 275
13029: MINUS
13030: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13031: LD_VAR 0 1
13035: PPUSH
13036: CALL_OW 274
13040: PPUSH
13041: LD_INT 1
13043: PPUSH
13044: LD_INT 0
13046: PPUSH
13047: CALL_OW 277
// end else
13051: GO 13102
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13053: LD_VAR 0 1
13057: PPUSH
13058: CALL_OW 274
13062: PPUSH
13063: LD_INT 1
13065: PPUSH
13066: LD_VAR 0 1
13070: PPUSH
13071: CALL_OW 274
13075: PPUSH
13076: LD_INT 1
13078: PPUSH
13079: CALL_OW 275
13083: PUSH
13084: LD_VAR 0 3
13088: MINUS
13089: PPUSH
13090: CALL_OW 277
// amount := 0 ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 0
13101: ST_TO_ADDR
// end ;
13102: GO 12964
13104: POP
13105: POP
// end ; end else
13106: GO 13280
// begin D_QrLegion1 ;
13108: CALL 5753 0 0
// MercPaid := true ;
13112: LD_ADDR_EXP 39
13116: PUSH
13117: LD_INT 1
13119: ST_TO_ADDR
// amount := 50 ;
13120: LD_ADDR_VAR 0 3
13124: PUSH
13125: LD_INT 50
13127: ST_TO_ADDR
// for un in filter do
13128: LD_ADDR_VAR 0 1
13132: PUSH
13133: LD_VAR 0 2
13137: PUSH
13138: FOR_IN
13139: IFFALSE 13278
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
13141: LD_VAR 0 1
13145: PPUSH
13146: CALL_OW 274
13150: PPUSH
13151: LD_INT 1
13153: PPUSH
13154: CALL_OW 275
13158: PUSH
13159: LD_VAR 0 3
13163: LESS
13164: PUSH
13165: LD_VAR 0 3
13169: PUSH
13170: LD_INT 0
13172: NONEQUAL
13173: AND
13174: IFFALSE 13227
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13176: LD_ADDR_VAR 0 3
13180: PUSH
13181: LD_VAR 0 3
13185: PUSH
13186: LD_VAR 0 1
13190: PPUSH
13191: CALL_OW 274
13195: PPUSH
13196: LD_INT 1
13198: PPUSH
13199: CALL_OW 275
13203: MINUS
13204: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13205: LD_VAR 0 1
13209: PPUSH
13210: CALL_OW 274
13214: PPUSH
13215: LD_INT 1
13217: PPUSH
13218: LD_INT 0
13220: PPUSH
13221: CALL_OW 277
// end else
13225: GO 13276
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13227: LD_VAR 0 1
13231: PPUSH
13232: CALL_OW 274
13236: PPUSH
13237: LD_INT 1
13239: PPUSH
13240: LD_VAR 0 1
13244: PPUSH
13245: CALL_OW 274
13249: PPUSH
13250: LD_INT 1
13252: PPUSH
13253: CALL_OW 275
13257: PUSH
13258: LD_VAR 0 3
13262: MINUS
13263: PPUSH
13264: CALL_OW 277
// amount := 0 ;
13268: LD_ADDR_VAR 0 3
13272: PUSH
13273: LD_INT 0
13275: ST_TO_ADDR
// end ;
13276: GO 13138
13278: POP
13279: POP
// end ; end ; 2 :
13280: GO 13298
13282: LD_INT 2
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13297
13290: POP
// D_QrLegion2 ; end ;
13291: CALL 5781 0 0
13295: GO 13298
13297: POP
// end ; LegionDone := true ;
13298: LD_ADDR_LOC 6
13302: PUSH
13303: LD_INT 1
13305: ST_TO_ADDR
// end ;
13306: PPOPN 3
13308: END
// every 0 0$1 marked 20 do
13309: GO 13311
13311: DISABLE
// begin if IsSelected ( Heike ) = true then
13312: LD_EXP 11
13316: PPUSH
13317: CALL_OW 306
13321: PUSH
13322: LD_INT 1
13324: EQUAL
13325: IFFALSE 13385
// begin if WasSelected = false then
13327: LD_EXP 83
13331: PUSH
13332: LD_INT 0
13334: EQUAL
13335: IFFALSE 13383
// begin if Query ( QSendHeike ) = 1 then
13337: LD_STRING QSendHeike
13339: PPUSH
13340: CALL_OW 97
13344: PUSH
13345: LD_INT 1
13347: EQUAL
13348: IFFALSE 13375
// begin HeikeSend := true ;
13350: LD_ADDR_EXP 65
13354: PUSH
13355: LD_INT 1
13357: ST_TO_ADDR
// ComMoveXY ( Heike , 39 , 47 ) ;
13358: LD_EXP 11
13362: PPUSH
13363: LD_INT 39
13365: PPUSH
13366: LD_INT 47
13368: PPUSH
13369: CALL_OW 111
// exit ;
13373: GO 13394
// end ; WasSelected := true ;
13375: LD_ADDR_EXP 83
13379: PUSH
13380: LD_INT 1
13382: ST_TO_ADDR
// end ; end else
13383: GO 13393
// WasSelected := false ;
13385: LD_ADDR_EXP 83
13389: PUSH
13390: LD_INT 0
13392: ST_TO_ADDR
// enable ;
13393: ENABLE
// end ;
13394: END
// every 0 0$10 + 0 0$0.4 marked 21 do
13395: GO 13397
13397: DISABLE
// begin if TechnoDone and BuildingsDone and not AmAttackStarted then
13398: LD_EXP 51
13402: PUSH
13403: LD_EXP 48
13407: AND
13408: PUSH
13409: LD_EXP 71
13413: NOT
13414: AND
13415: IFFALSE 13468
// begin enable ( 13 ) ;
13417: LD_INT 13
13419: ENABLE_MARKED
// repeat Wait ( 0 0$1 ) ;
13420: LD_INT 35
13422: PPUSH
13423: CALL_OW 67
// until LegionDone ;
13427: LD_LOC 6
13431: IFFALSE 13420
// if ( not HeikeKilled ) and HeikeDismissed then
13433: LD_EXP 38
13437: NOT
13438: PUSH
13439: LD_EXP 45
13443: AND
13444: IFFALSE 13455
// Wait ( 0 0$35 ) else
13446: LD_INT 1225
13448: PPUSH
13449: CALL_OW 67
13453: GO 13462
// Wait ( 0 0$5 ) ;
13455: LD_INT 175
13457: PPUSH
13458: CALL_OW 67
// enable ( 999 ) ;
13462: LD_INT 999
13464: ENABLE_MARKED
// enable ( 501 ) ;
13465: LD_INT 501
13467: ENABLE_MARKED
// end ; if not AmAttackStarted then
13468: LD_EXP 71
13472: NOT
13473: IFFALSE 13476
// enable ;
13475: ENABLE
// end ;
13476: END
// var ApesRespawned ; every 0 0$1 + 0 0$0.8 marked 22 do var Ape ;
13477: GO 13479
13479: DISABLE
13480: LD_INT 0
13482: PPUSH
// begin Wait ( 350 * ApesRespawned ) ;
13483: LD_INT 350
13485: PUSH
13486: LD_LOC 7
13490: MUL
13491: PPUSH
13492: CALL_OW 67
// if FilterAllUnits ( [ f_class , class_apeman ] ) < 1 then
13496: LD_INT 25
13498: PUSH
13499: LD_INT 12
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PPUSH
13506: CALL_OW 69
13510: PUSH
13511: LD_INT 1
13513: LESS
13514: IFFALSE 13624
// begin ApesRespawned := ApesRespawned + 1 ;
13516: LD_ADDR_LOC 7
13520: PUSH
13521: LD_LOC 7
13525: PUSH
13526: LD_INT 1
13528: PLUS
13529: ST_TO_ADDR
// uc_side := 0 ;
13530: LD_ADDR_OWVAR 20
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// uc_nation := nation_nature ;
13538: LD_ADDR_OWVAR 21
13542: PUSH
13543: LD_INT 0
13545: ST_TO_ADDR
// PrepareHuman ( sex_male , class_apeman , 2 ) ;
13546: LD_INT 1
13548: PPUSH
13549: LD_INT 12
13551: PPUSH
13552: LD_INT 2
13554: PPUSH
13555: CALL_OW 380
// hc_name :=  ;
13559: LD_ADDR_OWVAR 26
13563: PUSH
13564: LD_STRING 
13566: ST_TO_ADDR
// Ape := CreateHuman ;
13567: LD_ADDR_VAR 0 1
13571: PUSH
13572: CALL_OW 44
13576: ST_TO_ADDR
// SetDir ( Ape , Rand ( 0 , 5 ) ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 0
13584: PPUSH
13585: LD_INT 5
13587: PPUSH
13588: CALL_OW 12
13592: PPUSH
13593: CALL_OW 233
// PlaceUnitArea ( Ape , AnimalsArea , false ) ;
13597: LD_VAR 0 1
13601: PPUSH
13602: LD_INT 22
13604: PPUSH
13605: LD_INT 0
13607: PPUSH
13608: CALL_OW 49
// ComMoveToArea ( Ape , ApeArea ) ;
13612: LD_VAR 0 1
13616: PPUSH
13617: LD_INT 23
13619: PPUSH
13620: CALL_OW 113
// end ; enable ;
13624: ENABLE
// end ;
13625: PPOPN 1
13627: END
// every 0 0$15 marked 23 do var filter , un ;
13628: GO 13630
13630: DISABLE
13631: LD_INT 0
13633: PPUSH
13634: PPUSH
// begin ComAttackUnit ( Heike , Burlak ) ;
13635: LD_EXP 11
13639: PPUSH
13640: LD_EXP 1
13644: PPUSH
13645: CALL_OW 115
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13649: LD_ADDR_VAR 0 1
13653: PUSH
13654: LD_INT 22
13656: PUSH
13657: LD_EXP 31
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PUSH
13666: LD_INT 21
13668: PUSH
13669: LD_INT 1
13671: PUSH
13672: EMPTY
13673: LIST
13674: LIST
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PPUSH
13680: CALL_OW 69
13684: ST_TO_ADDR
// for un in filter do
13685: LD_ADDR_VAR 0 2
13689: PUSH
13690: LD_VAR 0 1
13694: PUSH
13695: FOR_IN
13696: IFFALSE 13721
// begin AddComAttackUnit ( Heike , un ) ;
13698: LD_EXP 11
13702: PPUSH
13703: LD_VAR 0 2
13707: PPUSH
13708: CALL_OW 175
// Wait ( 10 ) ;
13712: LD_INT 10
13714: PPUSH
13715: CALL_OW 67
// end ;
13719: GO 13695
13721: POP
13722: POP
// enable ;
13723: ENABLE
// end ;
13724: PPOPN 2
13726: END
// on BuildingComplete ( building ) do var rnd , distance , un1 , un2 , pole , budova1 , budova2 , i , filter ;
13727: LD_INT 0
13729: PPUSH
13730: PPUSH
13731: PPUSH
13732: PPUSH
13733: PPUSH
13734: PPUSH
13735: PPUSH
13736: PPUSH
13737: PPUSH
// begin if ( not depot_build ) and ( GetBType ( building ) = b_depot ) and HeikeCaptured then
13738: LD_EXP 28
13742: NOT
13743: PUSH
13744: LD_VAR 0 1
13748: PPUSH
13749: CALL_OW 266
13753: PUSH
13754: LD_INT 0
13756: EQUAL
13757: AND
13758: PUSH
13759: LD_EXP 37
13763: AND
13764: IFFALSE 13844
// begin depot_build = true ;
13766: LD_ADDR_EXP 28
13770: PUSH
13771: LD_INT 1
13773: ST_TO_ADDR
// depotX := GetX ( building ) ;
13774: LD_ADDR_EXP 29
13778: PUSH
13779: LD_VAR 0 1
13783: PPUSH
13784: CALL_OW 250
13788: ST_TO_ADDR
// depotY := GetY ( building ) ;
13789: LD_ADDR_EXP 30
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 251
13803: ST_TO_ADDR
// Wait ( 0 0$10 ) ;
13804: LD_INT 350
13806: PPUSH
13807: CALL_OW 67
// D_Heike ;
13811: CALL 4974 0 0
// rnd := Rand ( 1 1$15 , 2 2$0 ) ;
13815: LD_ADDR_VAR 0 2
13819: PUSH
13820: LD_INT 2625
13822: PPUSH
13823: LD_INT 4200
13825: PPUSH
13826: CALL_OW 12
13830: ST_TO_ADDR
// Wait ( rnd ) ;
13831: LD_VAR 0 2
13835: PPUSH
13836: CALL_OW 67
// merc_help ;
13840: CALL 7543 0 0
// end ; end ;
13844: PPOPN 10
13846: END
// on UpgradeComplete ( building ) do begin if ( GetBType ( building ) = b_barracks ) and ( GetNation ( building ) = nation_arabian ) then
13847: LD_VAR 0 1
13851: PPUSH
13852: CALL_OW 266
13856: PUSH
13857: LD_INT 5
13859: EQUAL
13860: PUSH
13861: LD_VAR 0 1
13865: PPUSH
13866: CALL_OW 248
13870: PUSH
13871: LD_INT 2
13873: EQUAL
13874: AND
13875: IFFALSE 13979
// begin MortarDone := true ;
13877: LD_ADDR_EXP 52
13881: PUSH
13882: LD_INT 1
13884: ST_TO_ADDR
// if not MercHandedOver or not MercWillBeHandedOver then
13885: LD_EXP 40
13889: NOT
13890: PUSH
13891: LD_EXP 41
13895: NOT
13896: OR
13897: IFFALSE 13979
// begin Wait ( 0 0$1 ) ;
13899: LD_INT 35
13901: PPUSH
13902: CALL_OW 67
// enable ( 3 ) ;
13906: LD_INT 3
13908: ENABLE_MARKED
// D_MercCompleted ;
13909: CALL 5241 0 0
// enable ( 20 ) ;
13913: LD_INT 20
13915: ENABLE_MARKED
// SetAreaMapShow ( WaitHeikeArea , 1 ) ;
13916: LD_INT 8
13918: PPUSH
13919: LD_INT 1
13921: PPUSH
13922: CALL_OW 424
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
13926: LD_EXP 13
13930: PUSH
13931: LD_EXP 14
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PPUSH
13940: LD_EXP 34
13944: PPUSH
13945: CALL_OW 235
// disable ( 601 ) ;
13949: LD_INT 601
13951: DISABLE_MARKED
// ComMoveXY ( [ Kurt , Mercenary1 ] , 39 , 48 ) ;
13952: LD_EXP 13
13956: PUSH
13957: LD_EXP 14
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: LD_INT 39
13968: PPUSH
13969: LD_INT 48
13971: PPUSH
13972: CALL_OW 111
// enable ( 6 ) ;
13976: LD_INT 6
13978: ENABLE_MARKED
// end ; end ; end ;
13979: PPOPN 1
13981: END
// on UnitGoesToRed ( un ) do begin if LimitTeleportResearched and GetType ( un ) = unit_vehicle then
13982: LD_EXP 62
13986: PUSH
13987: LD_VAR 0 1
13991: PPUSH
13992: CALL_OW 247
13996: PUSH
13997: LD_INT 2
13999: EQUAL
14000: AND
14001: IFFALSE 14018
// begin LimitTeleportTested := true ;
14003: LD_ADDR_EXP 63
14007: PUSH
14008: LD_INT 1
14010: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
14011: LD_STRING MTeleDone
14013: PPUSH
14014: CALL_OW 337
// end ; if GetSide ( un ) = usa then
14018: LD_VAR 0 1
14022: PPUSH
14023: CALL_OW 255
14027: PUSH
14028: LD_EXP 35
14032: EQUAL
14033: IFFALSE 14051
// amattack := amattack diff un ;
14035: LD_ADDR_EXP 27
14039: PUSH
14040: LD_EXP 27
14044: PUSH
14045: LD_VAR 0 1
14049: DIFF
14050: ST_TO_ADDR
// if un = Heike then
14051: LD_VAR 0 1
14055: PUSH
14056: LD_EXP 11
14060: EQUAL
14061: IFFALSE 14218
// begin if MortarAsked and not MercHandedOver then
14063: LD_EXP 69
14067: PUSH
14068: LD_EXP 40
14072: NOT
14073: AND
14074: IFFALSE 14174
// begin D_MercDeceived ;
14076: CALL 5386 0 0
// if not MortarDone then
14080: LD_EXP 52
14084: NOT
14085: IFFALSE 14148
// begin SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
14087: LD_EXP 13
14091: PUSH
14092: LD_EXP 14
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PPUSH
14101: LD_EXP 34
14105: PPUSH
14106: CALL_OW 235
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
14110: LD_EXP 13
14114: PUSH
14115: LD_EXP 14
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: PPUSH
14124: LD_EXP 1
14128: PPUSH
14129: CALL_OW 250
14133: PPUSH
14134: LD_EXP 1
14138: PPUSH
14139: CALL_OW 251
14143: PPUSH
14144: CALL_OW 114
// end ; SetLives ( Heike , 0 ) ;
14148: LD_EXP 11
14152: PPUSH
14153: LD_INT 0
14155: PPUSH
14156: CALL_OW 234
// HeikeKilled := true ;
14160: LD_ADDR_EXP 38
14164: PUSH
14165: LD_INT 1
14167: ST_TO_ADDR
// merc_attack ;
14168: CALL 7744 0 0
// end else
14172: GO 14218
// begin D_HeikeKilled ;
14174: CALL 5005 0 0
// SetLives ( Heike , 0 ) ;
14178: LD_EXP 11
14182: PPUSH
14183: LD_INT 0
14185: PPUSH
14186: CALL_OW 234
// HeikeKilled := true ;
14190: LD_ADDR_EXP 38
14194: PUSH
14195: LD_INT 1
14197: ST_TO_ADDR
// SetAttitude ( you , merc , att_enemy , true ) ;
14198: LD_EXP 31
14202: PPUSH
14203: LD_EXP 34
14207: PPUSH
14208: LD_INT 2
14210: PPUSH
14211: LD_INT 1
14213: PPUSH
14214: CALL_OW 80
// end ; end ; end ;
14218: PPOPN 1
14220: END
// on UnitDestroyed ( human ) do begin if human = Burlak then
14221: LD_VAR 0 1
14225: PUSH
14226: LD_EXP 1
14230: EQUAL
14231: IFFALSE 14240
// YouLost ( Burlak ) ;
14233: LD_STRING Burlak
14235: PPUSH
14236: CALL_OW 104
// end ;
14240: PPOPN 1
14242: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_AdvAI then
14243: LD_VAR 0 1
14247: PUSH
14248: LD_INT 27
14250: EQUAL
14251: IFFALSE 14278
// begin Hint ( AI ) ;
14253: LD_STRING AI
14255: PPUSH
14256: CALL_OW 339
// Wait ( 0 0$10 ) ;
14260: LD_INT 350
14262: PPUSH
14263: CALL_OW 67
// D_AI ;
14267: CALL 6900 0 0
// ChangeMissionObjectives ( MAI ) ;
14271: LD_STRING MAI
14273: PPUSH
14274: CALL_OW 337
// end ; if tech = tech_LimTeleport then
14278: LD_VAR 0 1
14282: PUSH
14283: LD_INT 37
14285: EQUAL
14286: IFFALSE 14321
// begin Hint ( SpontTelep ) ;
14288: LD_STRING SpontTelep
14290: PPUSH
14291: CALL_OW 339
// Wait ( 0 0$10 ) ;
14295: LD_INT 350
14297: PPUSH
14298: CALL_OW 67
// D_SpontTelep ;
14302: CALL 7002 0 0
// ChangeMissionObjectives ( MTele ) ;
14306: LD_STRING MTele
14308: PPUSH
14309: CALL_OW 337
// LimitTeleportResearched := true ;
14313: LD_ADDR_EXP 62
14317: PUSH
14318: LD_INT 1
14320: ST_TO_ADDR
// end ; AvailableTechno := AvailableTechno diff tech ;
14321: LD_ADDR_EXP 56
14325: PUSH
14326: LD_EXP 56
14330: PUSH
14331: LD_VAR 0 1
14335: DIFF
14336: ST_TO_ADDR
// if HeikeCratesTime then
14337: LD_LOC 5
14341: IFFALSE 14404
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
14343: LD_ADDR_OWVAR 47
14347: PUSH
14348: LD_STRING #Ru08-1
14350: PUSH
14351: LD_INT 0
14353: PUSH
14354: LD_LOC 3
14358: PLUS
14359: PUSH
14360: LD_STRING #Ru08-2
14362: PUSH
14363: LD_INT 0
14365: PUSH
14366: LD_LOC 4
14370: PLUS
14371: PUSH
14372: LD_STRING #Ru08-3
14374: PUSH
14375: LD_INT 0
14377: PUSH
14378: LD_EXP 56
14382: PLUS
14383: PUSH
14384: LD_STRING #Ru08-4
14386: PUSH
14387: LD_LOC 5
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: ST_TO_ADDR
14402: GO 14453
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
14404: LD_ADDR_OWVAR 47
14408: PUSH
14409: LD_STRING #Ru08-1
14411: PUSH
14412: LD_INT 0
14414: PUSH
14415: LD_LOC 3
14419: PLUS
14420: PUSH
14421: LD_STRING #Ru08-2
14423: PUSH
14424: LD_INT 0
14426: PUSH
14427: LD_LOC 4
14431: PLUS
14432: PUSH
14433: LD_STRING #Ru08-3
14435: PUSH
14436: LD_INT 0
14438: PUSH
14439: LD_EXP 56
14443: PLUS
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: ST_TO_ADDR
// if AvailableTechno = [ ] and not TechnoDone then
14453: LD_EXP 56
14457: PUSH
14458: EMPTY
14459: EQUAL
14460: PUSH
14461: LD_EXP 51
14465: NOT
14466: AND
14467: IFFALSE 14484
// begin ChangeMissionObjectives ( MTechnoDone ) ;
14469: LD_STRING MTechnoDone
14471: PPUSH
14472: CALL_OW 337
// TechnoDone := true ;
14476: LD_ADDR_EXP 51
14480: PUSH
14481: LD_INT 1
14483: ST_TO_ADDR
// end ; end ;
14484: PPOPN 2
14486: END
// on VehicleConstructed ( veh , fact ) do begin AvailableWeapons := AvailableWeapons diff GetWeapon ( veh ) ;
14487: LD_ADDR_EXP 54
14491: PUSH
14492: LD_EXP 54
14496: PUSH
14497: LD_VAR 0 1
14501: PPUSH
14502: CALL_OW 264
14506: DIFF
14507: ST_TO_ADDR
// if ( AvailableWeapons + 0 ) = 2 and not MashaAsked then
14508: LD_EXP 54
14512: PUSH
14513: LD_INT 0
14515: PLUS
14516: PUSH
14517: LD_INT 2
14519: EQUAL
14520: PUSH
14521: LD_EXP 70
14525: NOT
14526: AND
14527: IFFALSE 14532
// enable ( 401 ) ;
14529: LD_INT 401
14531: ENABLE_MARKED
// if GetControl ( veh ) = control_computer then
14532: LD_VAR 0 1
14536: PPUSH
14537: CALL_OW 263
14541: PUSH
14542: LD_INT 3
14544: EQUAL
14545: IFFALSE 14562
// begin ChangeMissionObjectives ( MAIDone ) ;
14547: LD_STRING MAIDone
14549: PPUSH
14550: CALL_OW 337
// CompVehConstructed = true ;
14554: LD_ADDR_EXP 61
14558: PUSH
14559: LD_INT 1
14561: ST_TO_ADDR
// end ; end ;
14562: PPOPN 2
14564: END
// on Command ( comm ) marked 601 do var i ;
14565: LD_INT 0
14567: PPUSH
// begin if IsOK ( Kurt ) then
14568: LD_EXP 13
14572: PPUSH
14573: CALL_OW 302
14577: IFFALSE 14777
// if GetTaskList ( Kurt ) <> [ ] then
14579: LD_EXP 13
14583: PPUSH
14584: CALL_OW 437
14588: PUSH
14589: EMPTY
14590: NONEQUAL
14591: IFFALSE 14777
// begin for i := 1 to ( 0 + GetTaskList ( Kurt ) ) do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 0
14605: PUSH
14606: LD_EXP 13
14610: PPUSH
14611: CALL_OW 437
14615: PLUS
14616: PUSH
14617: FOR_TO
14618: IFFALSE 14775
// begin if ( GetTaskList ( Kurt ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Kurt ) [ i ] [ 1 ] = B and GetTaskList ( Kurt ) [ i ] [ 5 ] = 36 ) then
14620: LD_EXP 13
14624: PPUSH
14625: CALL_OW 437
14629: PUSH
14630: LD_VAR 0 2
14634: ARRAY
14635: PUSH
14636: LD_INT 1
14638: ARRAY
14639: PUSH
14640: LD_STRING F
14642: PUSH
14643: LD_STRING H
14645: PUSH
14646: LD_STRING M
14648: PUSH
14649: LD_STRING U
14651: PUSH
14652: LD_STRING V
14654: PUSH
14655: LD_STRING a
14657: PUSH
14658: LD_STRING h
14660: PUSH
14661: LD_STRING u
14663: PUSH
14664: LD_STRING v
14666: PUSH
14667: LD_STRING ~
14669: PUSH
14670: LD_STRING ^
14672: PUSH
14673: LD_STRING >
14675: PUSH
14676: LD_STRING +
14678: PUSH
14679: LD_STRING ;
14681: PUSH
14682: LD_STRING 4
14684: PUSH
14685: LD_STRING {
14687: PUSH
14688: EMPTY
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: IN
14706: PUSH
14707: LD_EXP 13
14711: PPUSH
14712: CALL_OW 437
14716: PUSH
14717: LD_VAR 0 2
14721: ARRAY
14722: PUSH
14723: LD_INT 1
14725: ARRAY
14726: PUSH
14727: LD_STRING B
14729: EQUAL
14730: PUSH
14731: LD_EXP 13
14735: PPUSH
14736: CALL_OW 437
14740: PUSH
14741: LD_VAR 0 2
14745: ARRAY
14746: PUSH
14747: LD_INT 5
14749: ARRAY
14750: PUSH
14751: LD_INT 36
14753: EQUAL
14754: AND
14755: OR
14756: IFFALSE 14760
// else
14758: GO 14773
// begin RemoveTasks ( Kurt ) ;
14760: LD_EXP 13
14764: PPUSH
14765: CALL_OW 493
// D_MercRefuseBuild ;
14769: CALL 5221 0 0
// end ; end ;
14773: GO 14617
14775: POP
14776: POP
// end ; if IsOK ( Mercenary1 ) then
14777: LD_EXP 14
14781: PPUSH
14782: CALL_OW 302
14786: IFFALSE 14986
// if GetTaskList ( Mercenary1 ) <> [ ] then
14788: LD_EXP 14
14792: PPUSH
14793: CALL_OW 437
14797: PUSH
14798: EMPTY
14799: NONEQUAL
14800: IFFALSE 14986
// begin for i := 1 to ( 0 + GetTaskList ( Mercenary1 ) ) do
14802: LD_ADDR_VAR 0 2
14806: PUSH
14807: DOUBLE
14808: LD_INT 1
14810: DEC
14811: ST_TO_ADDR
14812: LD_INT 0
14814: PUSH
14815: LD_EXP 14
14819: PPUSH
14820: CALL_OW 437
14824: PLUS
14825: PUSH
14826: FOR_TO
14827: IFFALSE 14984
// begin if ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] = B and GetTaskList ( Mercenary1 ) [ i ] [ 5 ] = 36 ) then
14829: LD_EXP 14
14833: PPUSH
14834: CALL_OW 437
14838: PUSH
14839: LD_VAR 0 2
14843: ARRAY
14844: PUSH
14845: LD_INT 1
14847: ARRAY
14848: PUSH
14849: LD_STRING F
14851: PUSH
14852: LD_STRING H
14854: PUSH
14855: LD_STRING M
14857: PUSH
14858: LD_STRING U
14860: PUSH
14861: LD_STRING V
14863: PUSH
14864: LD_STRING a
14866: PUSH
14867: LD_STRING h
14869: PUSH
14870: LD_STRING u
14872: PUSH
14873: LD_STRING v
14875: PUSH
14876: LD_STRING ~
14878: PUSH
14879: LD_STRING ^
14881: PUSH
14882: LD_STRING >
14884: PUSH
14885: LD_STRING +
14887: PUSH
14888: LD_STRING ;
14890: PUSH
14891: LD_STRING 4
14893: PUSH
14894: LD_STRING {
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: IN
14915: PUSH
14916: LD_EXP 14
14920: PPUSH
14921: CALL_OW 437
14925: PUSH
14926: LD_VAR 0 2
14930: ARRAY
14931: PUSH
14932: LD_INT 1
14934: ARRAY
14935: PUSH
14936: LD_STRING B
14938: EQUAL
14939: PUSH
14940: LD_EXP 14
14944: PPUSH
14945: CALL_OW 437
14949: PUSH
14950: LD_VAR 0 2
14954: ARRAY
14955: PUSH
14956: LD_INT 5
14958: ARRAY
14959: PUSH
14960: LD_INT 36
14962: EQUAL
14963: AND
14964: OR
14965: IFFALSE 14969
// else
14967: GO 14982
// begin RemoveTasks ( Mercenary1 ) ;
14969: LD_EXP 14
14973: PPUSH
14974: CALL_OW 493
// D_MercRefuseBuild ;
14978: CALL 5221 0 0
// end ; end ;
14982: GO 14826
14984: POP
14985: POP
// end ; end ; end_of_file
14986: PPOPN 2
14988: END
// export function hunt ( hunter ) ; var un , animals , animal , kasarna , depot , i , x , y , d , rnd_animal , hunter_x_coordinate , hunter_y_coordinate , range , osoba , min , setridene_animals ; begin
14989: LD_INT 0
14991: PPUSH
14992: PPUSH
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
15002: PPUSH
15003: PPUSH
15004: PPUSH
15005: PPUSH
15006: PPUSH
15007: PPUSH
// kasarna := FilterAllUnits ( [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ) ;
15008: LD_ADDR_VAR 0 6
15012: PUSH
15013: LD_INT 2
15015: PUSH
15016: LD_INT 30
15018: PUSH
15019: LD_INT 5
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PUSH
15026: LD_INT 30
15028: PUSH
15029: LD_INT 4
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 69
15045: ST_TO_ADDR
// SetSide ( hunter , ally ) ;
15046: LD_VAR 0 1
15050: PPUSH
15051: LD_EXP 32
15055: PPUSH
15056: CALL_OW 235
// if not ( GetClass ( hunter ) = class_soldier ) and ( kasarna > 0 ) then
15060: LD_VAR 0 1
15064: PPUSH
15065: CALL_OW 257
15069: PUSH
15070: LD_INT 1
15072: EQUAL
15073: NOT
15074: PUSH
15075: LD_VAR 0 6
15079: PUSH
15080: LD_INT 0
15082: GREATER
15083: AND
15084: IFFALSE 15272
// begin ComEnterUnit ( hunter , kasarna [ 1 ] ) ;
15086: LD_VAR 0 1
15090: PPUSH
15091: LD_VAR 0 6
15095: PUSH
15096: LD_INT 1
15098: ARRAY
15099: PPUSH
15100: CALL_OW 120
// Wait ( 10 ) ;
15104: LD_INT 10
15106: PPUSH
15107: CALL_OW 67
// while HasTask ( hunter ) do
15111: LD_VAR 0 1
15115: PPUSH
15116: CALL_OW 314
15120: IFFALSE 15131
// begin Wait ( 10 ) ;
15122: LD_INT 10
15124: PPUSH
15125: CALL_OW 67
// end ;
15129: GO 15111
// hunter_x_coordinate := GetX ( hunter ) ;
15131: LD_ADDR_VAR 0 13
15135: PUSH
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 250
15145: ST_TO_ADDR
// hunter_y_coordinate := GetY ( hunter ) ;
15146: LD_ADDR_VAR 0 14
15150: PUSH
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 251
15160: ST_TO_ADDR
// RemoveUnit ( hunter ) ;
15161: LD_VAR 0 1
15165: PPUSH
15166: CALL_OW 64
// SetClass ( hunter , class_soldier ) ;
15170: LD_VAR 0 1
15174: PPUSH
15175: LD_INT 1
15177: PPUSH
15178: CALL_OW 336
// Wait ( 0 0$2 ) ;
15182: LD_INT 70
15184: PPUSH
15185: CALL_OW 67
// if not PlaceUnitXY ( hunter , hunter_x_coordinate , hunter_y_coordinate , false ) then
15189: LD_VAR 0 1
15193: PPUSH
15194: LD_VAR 0 13
15198: PPUSH
15199: LD_VAR 0 14
15203: PPUSH
15204: LD_INT 0
15206: PPUSH
15207: CALL_OW 48
15211: NOT
15212: IFFALSE 15272
// begin range := 0 ;
15214: LD_ADDR_VAR 0 15
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// repeat Wait ( 2 ) ;
15222: LD_INT 2
15224: PPUSH
15225: CALL_OW 67
// range := range + 1 ;
15229: LD_ADDR_VAR 0 15
15233: PUSH
15234: LD_VAR 0 15
15238: PUSH
15239: LD_INT 1
15241: PLUS
15242: ST_TO_ADDR
// until PlaceUnitXYR ( hunter , hunter_x_coordinate , hunter_y_coordinate , range , false ) end ;
15243: LD_VAR 0 1
15247: PPUSH
15248: LD_VAR 0 13
15252: PPUSH
15253: LD_VAR 0 14
15257: PPUSH
15258: LD_VAR 0 15
15262: PPUSH
15263: LD_INT 0
15265: PPUSH
15266: CALL_OW 50
15270: IFFALSE 15222
// end ; animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_INT 2
15279: PUSH
15280: LD_INT 25
15282: PUSH
15283: LD_INT 18
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PUSH
15290: LD_INT 25
15292: PUSH
15293: LD_INT 14
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: PPUSH
15305: CALL_OW 69
15309: ST_TO_ADDR
// if animals = [ ] then
15310: LD_VAR 0 4
15314: PUSH
15315: EMPTY
15316: EQUAL
15317: IFFALSE 15501
// begin Randomize ;
15319: CALL_OW 10
// RandomizeAll ;
15323: CALL_OW 11
// for i := 1 to 6 do
15327: LD_ADDR_VAR 0 8
15331: PUSH
15332: DOUBLE
15333: LD_INT 1
15335: DEC
15336: ST_TO_ADDR
15337: LD_INT 6
15339: PUSH
15340: FOR_TO
15341: IFFALSE 15499
// begin uc_side = 0 ;
15343: LD_ADDR_OWVAR 20
15347: PUSH
15348: LD_INT 0
15350: ST_TO_ADDR
// uc_nation := nation_nature ;
15351: LD_ADDR_OWVAR 21
15355: PUSH
15356: LD_INT 0
15358: ST_TO_ADDR
// PrepareHuman ( 0 , class_phororhacos , 0 ) ;
15359: LD_INT 0
15361: PPUSH
15362: LD_INT 18
15364: PPUSH
15365: LD_INT 0
15367: PPUSH
15368: CALL_OW 380
// hc_name :=  ;
15372: LD_ADDR_OWVAR 26
15376: PUSH
15377: LD_STRING 
15379: ST_TO_ADDR
// Wait ( 1 ) ;
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15387: CALL_OW 44
15391: PPUSH
15392: LD_INT 22
15394: PPUSH
15395: LD_INT 0
15397: PPUSH
15398: CALL_OW 49
// Wait ( 1 ) ;
15402: LD_INT 1
15404: PPUSH
15405: CALL_OW 67
// PrepareHuman ( 0 , class_tiger , 0 ) ;
15409: LD_INT 0
15411: PPUSH
15412: LD_INT 14
15414: PPUSH
15415: LD_INT 0
15417: PPUSH
15418: CALL_OW 380
// hc_name :=  ;
15422: LD_ADDR_OWVAR 26
15426: PUSH
15427: LD_STRING 
15429: ST_TO_ADDR
// Wait ( 1 ) ;
15430: LD_INT 1
15432: PPUSH
15433: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15437: CALL_OW 44
15441: PPUSH
15442: LD_INT 22
15444: PPUSH
15445: LD_INT 0
15447: PPUSH
15448: CALL_OW 49
// Wait ( 1 ) ;
15452: LD_INT 1
15454: PPUSH
15455: CALL_OW 67
// animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: LD_INT 2
15466: PUSH
15467: LD_INT 25
15469: PUSH
15470: LD_INT 18
15472: PUSH
15473: EMPTY
15474: LIST
15475: LIST
15476: PUSH
15477: LD_INT 25
15479: PUSH
15480: LD_INT 14
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: LIST
15491: PPUSH
15492: CALL_OW 69
15496: ST_TO_ADDR
// end ;
15497: GO 15340
15499: POP
15500: POP
// end ; if GetClass ( hunter ) = class_soldier then
15501: LD_VAR 0 1
15505: PPUSH
15506: CALL_OW 257
15510: PUSH
15511: LD_INT 1
15513: EQUAL
15514: IFFALSE 15534
// rnd_animal := Rand ( 4 , 6 ) else
15516: LD_ADDR_VAR 0 12
15520: PUSH
15521: LD_INT 4
15523: PPUSH
15524: LD_INT 6
15526: PPUSH
15527: CALL_OW 12
15531: ST_TO_ADDR
15532: GO 15550
// rnd_animal := Rand ( 1 , 2 ) ;
15534: LD_ADDR_VAR 0 12
15538: PUSH
15539: LD_INT 1
15541: PPUSH
15542: LD_INT 2
15544: PPUSH
15545: CALL_OW 12
15549: ST_TO_ADDR
// range := 999 ;
15550: LD_ADDR_VAR 0 15
15554: PUSH
15555: LD_INT 999
15557: ST_TO_ADDR
// osoba := hunter ;
15558: LD_ADDR_VAR 0 16
15562: PUSH
15563: LD_VAR 0 1
15567: ST_TO_ADDR
// setridene_animals := [ ] ;
15568: LD_ADDR_VAR 0 18
15572: PUSH
15573: EMPTY
15574: ST_TO_ADDR
// while animals <> [ ] do
15575: LD_VAR 0 4
15579: PUSH
15580: EMPTY
15581: NONEQUAL
15582: IFFALSE 15712
// begin for un in animals do
15584: LD_ADDR_VAR 0 3
15588: PUSH
15589: LD_VAR 0 4
15593: PUSH
15594: FOR_IN
15595: IFFALSE 15658
// begin if GetDistUnits ( osoba , un ) < range then
15597: LD_VAR 0 16
15601: PPUSH
15602: LD_VAR 0 3
15606: PPUSH
15607: CALL_OW 296
15611: PUSH
15612: LD_VAR 0 15
15616: LESS
15617: IFFALSE 15649
// begin range := GetDistUnits ( hunter , un ) ;
15619: LD_ADDR_VAR 0 15
15623: PUSH
15624: LD_VAR 0 1
15628: PPUSH
15629: LD_VAR 0 3
15633: PPUSH
15634: CALL_OW 296
15638: ST_TO_ADDR
// min := un ;
15639: LD_ADDR_VAR 0 17
15643: PUSH
15644: LD_VAR 0 3
15648: ST_TO_ADDR
// end ; Wait ( 1 ) ;
15649: LD_INT 1
15651: PPUSH
15652: CALL_OW 67
// end ;
15656: GO 15594
15658: POP
15659: POP
// setridene_animals := setridene_animals ^ min ;
15660: LD_ADDR_VAR 0 18
15664: PUSH
15665: LD_VAR 0 18
15669: PUSH
15670: LD_VAR 0 17
15674: ADD
15675: ST_TO_ADDR
// animals := animals diff min ;
15676: LD_ADDR_VAR 0 4
15680: PUSH
15681: LD_VAR 0 4
15685: PUSH
15686: LD_VAR 0 17
15690: DIFF
15691: ST_TO_ADDR
// osoba := min ;
15692: LD_ADDR_VAR 0 16
15696: PUSH
15697: LD_VAR 0 17
15701: ST_TO_ADDR
// range := 999 ;
15702: LD_ADDR_VAR 0 15
15706: PUSH
15707: LD_INT 999
15709: ST_TO_ADDR
// end ;
15710: GO 15575
// for i := 1 to rnd_animal do
15712: LD_ADDR_VAR 0 8
15716: PUSH
15717: DOUBLE
15718: LD_INT 1
15720: DEC
15721: ST_TO_ADDR
15722: LD_VAR 0 12
15726: PUSH
15727: FOR_TO
15728: IFFALSE 15759
// begin AddComAttackUnit ( hunter , setridene_animals [ i ] ) ;
15730: LD_VAR 0 1
15734: PPUSH
15735: LD_VAR 0 18
15739: PUSH
15740: LD_VAR 0 8
15744: ARRAY
15745: PPUSH
15746: CALL_OW 175
// Wait ( 10 ) ;
15750: LD_INT 10
15752: PPUSH
15753: CALL_OW 67
// end ;
15757: GO 15727
15759: POP
15760: POP
// if GetClass ( hunter ) = class_soldier then
15761: LD_VAR 0 1
15765: PPUSH
15766: CALL_OW 257
15770: PUSH
15771: LD_INT 1
15773: EQUAL
15774: IFFALSE 15779
// enable ( 102 ) ;
15776: LD_INT 102
15778: ENABLE_MARKED
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15779: LD_ADDR_VAR 0 7
15783: PUSH
15784: LD_INT 2
15786: PUSH
15787: LD_INT 30
15789: PUSH
15790: LD_INT 0
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 30
15799: PUSH
15800: LD_INT 1
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: LIST
15811: PPUSH
15812: CALL_OW 69
15816: ST_TO_ADDR
// if depot + 0 > 0 then
15817: LD_VAR 0 7
15821: PUSH
15822: LD_INT 0
15824: PLUS
15825: PUSH
15826: LD_INT 0
15828: GREATER
15829: IFFALSE 15935
// begin x := GetX ( depot [ 1 ] ) ;
15831: LD_ADDR_VAR 0 9
15835: PUSH
15836: LD_VAR 0 7
15840: PUSH
15841: LD_INT 1
15843: ARRAY
15844: PPUSH
15845: CALL_OW 250
15849: ST_TO_ADDR
// y := GetY ( depot [ 1 ] ) ;
15850: LD_ADDR_VAR 0 10
15854: PUSH
15855: LD_VAR 0 7
15859: PUSH
15860: LD_INT 1
15862: ARRAY
15863: PPUSH
15864: CALL_OW 251
15868: ST_TO_ADDR
// d := GetDir ( depot [ 1 ] ) ;
15869: LD_ADDR_VAR 0 11
15873: PUSH
15874: LD_VAR 0 7
15878: PUSH
15879: LD_INT 1
15881: ARRAY
15882: PPUSH
15883: CALL_OW 254
15887: ST_TO_ADDR
// AddComMoveXY ( hunter , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
15888: LD_VAR 0 1
15892: PPUSH
15893: LD_VAR 0 9
15897: PPUSH
15898: LD_VAR 0 11
15902: PPUSH
15903: LD_INT 7
15905: PPUSH
15906: CALL_OW 272
15910: PPUSH
15911: LD_VAR 0 10
15915: PPUSH
15916: LD_VAR 0 11
15920: PPUSH
15921: LD_INT 7
15923: PPUSH
15924: CALL_OW 273
15928: PPUSH
15929: CALL_OW 171
// end else
15933: GO 15950
// AddComMoveXY ( hunter , 83 , 40 ) ;
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_INT 83
15942: PPUSH
15943: LD_INT 40
15945: PPUSH
15946: CALL_OW 171
// while HasTask ( hunter ) do
15950: LD_VAR 0 1
15954: PPUSH
15955: CALL_OW 314
15959: IFFALSE 15970
// begin Wait ( 0 0$1 ) ;
15961: LD_INT 35
15963: PPUSH
15964: CALL_OW 67
// end ;
15968: GO 15950
// SetSide ( hunter , you ) ;
15970: LD_VAR 0 1
15974: PPUSH
15975: LD_EXP 31
15979: PPUSH
15980: CALL_OW 235
// end ;
15984: LD_VAR 0 2
15988: RET
// every 0 0$1 marked 101 do
15989: GO 15991
15991: DISABLE
// begin HuntingAsked := true ;
15992: LD_ADDR_EXP 67
15996: PUSH
15997: LD_INT 1
15999: ST_TO_ADDR
// Wait ( Rand ( 0 0$30 , 2 2$30 ) ) ;
16000: LD_INT 1050
16002: PPUSH
16003: LD_INT 5250
16005: PPUSH
16006: CALL_OW 12
16010: PPUSH
16011: CALL_OW 67
// if not ( HuntingAccepted ) and ( IsOK ( Belkov ) or IsOK ( Karamazov ) or IsOK ( Kozlov ) ) then
16015: LD_EXP 47
16019: NOT
16020: PUSH
16021: LD_EXP 3
16025: PPUSH
16026: CALL_OW 302
16030: PUSH
16031: LD_EXP 17
16035: PPUSH
16036: CALL_OW 302
16040: OR
16041: PUSH
16042: LD_EXP 20
16046: PPUSH
16047: CALL_OW 302
16051: OR
16052: AND
16053: IFFALSE 16115
// begin D_Hunting ;
16055: CALL 5990 0 0
// case Query ( QHunting ) of 1 :
16059: LD_STRING QHunting
16061: PPUSH
16062: CALL_OW 97
16066: PUSH
16067: LD_INT 1
16069: DOUBLE
16070: EQUAL
16071: IFTRUE 16075
16073: GO 16099
16075: POP
// begin HuntingAccepted := true ;
16076: LD_ADDR_EXP 47
16080: PUSH
16081: LD_INT 1
16083: ST_TO_ADDR
// D_QrHunting1 ;
16084: CALL 6305 0 0
// hunt ( hunter ) ;
16088: LD_EXP 72
16092: PPUSH
16093: CALL 14989 0 1
// end ; 2 :
16097: GO 16115
16099: LD_INT 2
16101: DOUBLE
16102: EQUAL
16103: IFTRUE 16107
16105: GO 16114
16107: POP
// D_QrHunting2 ; end ;
16108: CALL 6325 0 0
16112: GO 16115
16114: POP
// end ; end ;
16115: END
// every 0 0$1 + 0 0$0.3 marked 102 do
16116: GO 16118
16118: DISABLE
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
16119: LD_EXP 72
16123: PPUSH
16124: LD_EXP 72
16128: PPUSH
16129: CALL_OW 319
16133: PPUSH
16134: CALL_OW 296
16138: PUSH
16139: LD_INT 13
16141: LESS
16142: IFFALSE 16155
// ComCrawl ( hunter ) else
16144: LD_EXP 72
16148: PPUSH
16149: CALL_OW 137
16153: GO 16164
// ComWalk ( hunter ) ;
16155: LD_EXP 72
16159: PPUSH
16160: CALL_OW 138
// if not HasTask ( hunter ) then
16164: LD_EXP 72
16168: PPUSH
16169: CALL_OW 314
16173: NOT
16174: IFFALSE 16179
// disable else
16176: DISABLE
16177: GO 16180
// enable ;
16179: ENABLE
// end ; end_of_file
16180: END
// var ShootAreaNr , BarrelAreas , StandAreas ; every 0 0$1 marked 201 do
16181: GO 16183
16183: DISABLE
// begin GalleryAsked := true ;
16184: LD_ADDR_EXP 66
16188: PUSH
16189: LD_INT 1
16191: ST_TO_ADDR
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
16192: LD_INT 350
16194: PPUSH
16195: LD_INT 700
16197: PPUSH
16198: CALL_OW 12
16202: PPUSH
16203: CALL_OW 67
// D_FiringRange ;
16207: CALL 5809 0 0
// case Query ( QShootingGallery ) of 1 :
16211: LD_STRING QShootingGallery
16213: PPUSH
16214: CALL_OW 97
16218: PUSH
16219: LD_INT 1
16221: DOUBLE
16222: EQUAL
16223: IFTRUE 16227
16225: GO 16324
16227: POP
// begin GalleryBuild := true ;
16228: LD_ADDR_EXP 53
16232: PUSH
16233: LD_INT 1
16235: ST_TO_ADDR
// D_QrShootingGallery1 ;
16236: CALL 5950 0 0
// Wait ( 0 0$2 ) ;
16240: LD_INT 70
16242: PPUSH
16243: CALL_OW 67
// Hint ( ShootingGallery ) ;
16247: LD_STRING ShootingGallery
16249: PPUSH
16250: CALL_OW 339
// ShootAreaNr := 1 ;
16254: LD_ADDR_LOC 8
16258: PUSH
16259: LD_INT 1
16261: ST_TO_ADDR
// BarrelAreas := [ BarrelArea1 , BarrelArea2 , BarrelArea3 , BarrelArea4 , BarrelArea5 ] ;
16262: LD_ADDR_LOC 9
16266: PUSH
16267: LD_INT 12
16269: PUSH
16270: LD_INT 13
16272: PUSH
16273: LD_INT 14
16275: PUSH
16276: LD_INT 15
16278: PUSH
16279: LD_INT 16
16281: PUSH
16282: EMPTY
16283: LIST
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: ST_TO_ADDR
// StandAreas := [ StandArea1 , StandArea2 , StandArea3 , StandArea4 , StandArea5 ] ;
16289: LD_ADDR_LOC 10
16293: PUSH
16294: LD_INT 17
16296: PUSH
16297: LD_INT 18
16299: PUSH
16300: LD_INT 19
16302: PUSH
16303: LD_INT 20
16305: PUSH
16306: LD_INT 21
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: LIST
16313: LIST
16314: LIST
16315: ST_TO_ADDR
// enable ( 202 ) ;
16316: LD_INT 202
16318: ENABLE_MARKED
// enable ( 203 ) ;
16319: LD_INT 203
16321: ENABLE_MARKED
// end ; 2 :
16322: GO 16350
16324: LD_INT 2
16326: DOUBLE
16327: EQUAL
16328: IFTRUE 16332
16330: GO 16349
16332: POP
// begin D_QrShootingGallery2 ;
16333: CALL 5970 0 0
// SetAreaMapShow ( ShootArea , 0 ) ;
16337: LD_INT 11
16339: PPUSH
16340: LD_INT 0
16342: PPUSH
16343: CALL_OW 424
// end ; end ;
16347: GO 16350
16349: POP
// end ;
16350: END
// every 0 0$0.5 marked 202 do var shooters , un , buildings ;
16351: GO 16353
16353: DISABLE
16354: LD_INT 0
16356: PPUSH
16357: PPUSH
16358: PPUSH
// begin enable ;
16359: ENABLE
// shooters := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_not , [ f_hastask ] ] , [ f_nation , nation_russian ] ] ) ;
16360: LD_ADDR_VAR 0 1
16364: PUSH
16365: LD_INT 11
16367: PPUSH
16368: LD_INT 21
16370: PUSH
16371: LD_INT 1
16373: PUSH
16374: EMPTY
16375: LIST
16376: LIST
16377: PUSH
16378: LD_INT 3
16380: PUSH
16381: LD_INT 60
16383: PUSH
16384: EMPTY
16385: LIST
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: LD_INT 23
16393: PUSH
16394: LD_INT 3
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: LIST
16405: PPUSH
16406: CALL_OW 70
16410: ST_TO_ADDR
// if shooters <> [ ] then
16411: LD_VAR 0 1
16415: PUSH
16416: EMPTY
16417: NONEQUAL
16418: IFFALSE 16960
// begin for un in shooters do
16420: LD_ADDR_VAR 0 2
16424: PUSH
16425: LD_VAR 0 1
16429: PUSH
16430: FOR_IN
16431: IFFALSE 16958
// begin buildings := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
16433: LD_ADDR_VAR 0 3
16437: PUSH
16438: LD_INT 22
16440: PUSH
16441: LD_EXP 31
16445: PUSH
16446: EMPTY
16447: LIST
16448: LIST
16449: PUSH
16450: LD_INT 2
16452: PUSH
16453: LD_INT 30
16455: PUSH
16456: LD_INT 0
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PUSH
16463: LD_INT 30
16465: PUSH
16466: LD_INT 1
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: LIST
16477: PUSH
16478: EMPTY
16479: LIST
16480: PUSH
16481: EMPTY
16482: LIST
16483: LIST
16484: PPUSH
16485: CALL_OW 69
16489: ST_TO_ADDR
// if buildings <> [ ] then
16490: LD_VAR 0 3
16494: PUSH
16495: EMPTY
16496: NONEQUAL
16497: IFFALSE 16956
// begin if not ( GetClass ( un ) = class_engineer ) then
16499: LD_VAR 0 2
16503: PPUSH
16504: CALL_OW 257
16508: PUSH
16509: LD_INT 2
16511: EQUAL
16512: NOT
16513: IFFALSE 16757
// begin ComMoveXY ( un , ShiftX ( GetX ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) , ShiftY ( GetY ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) ) ;
16515: LD_VAR 0 2
16519: PPUSH
16520: LD_VAR 0 3
16524: PUSH
16525: LD_INT 1
16527: ARRAY
16528: PPUSH
16529: CALL_OW 250
16533: PPUSH
16534: LD_VAR 0 3
16538: PUSH
16539: LD_INT 1
16541: ARRAY
16542: PPUSH
16543: CALL_OW 254
16547: PPUSH
16548: LD_INT 3
16550: PPUSH
16551: CALL_OW 272
16555: PPUSH
16556: LD_VAR 0 3
16560: PUSH
16561: LD_INT 1
16563: ARRAY
16564: PPUSH
16565: CALL_OW 251
16569: PPUSH
16570: LD_VAR 0 3
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: PPUSH
16579: CALL_OW 254
16583: PPUSH
16584: LD_INT 3
16586: PPUSH
16587: CALL_OW 273
16591: PPUSH
16592: CALL_OW 111
// Wait ( 10 ) ;
16596: LD_INT 10
16598: PPUSH
16599: CALL_OW 67
// while HasTask ( un ) do
16603: LD_VAR 0 2
16607: PPUSH
16608: CALL_OW 314
16612: IFFALSE 16623
// begin Wait ( 10 ) ;
16614: LD_INT 10
16616: PPUSH
16617: CALL_OW 67
// end ;
16621: GO 16603
// if UnitsInside ( buildings [ 1 ] ) = 6 then
16623: LD_VAR 0 3
16627: PUSH
16628: LD_INT 1
16630: ARRAY
16631: PPUSH
16632: CALL_OW 313
16636: PUSH
16637: LD_INT 6
16639: EQUAL
16640: IFFALSE 16697
// begin ComExitBuilding ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) ;
16642: LD_VAR 0 3
16646: PUSH
16647: LD_INT 1
16649: ARRAY
16650: PPUSH
16651: CALL_OW 313
16655: PUSH
16656: LD_INT 1
16658: ARRAY
16659: PPUSH
16660: CALL_OW 122
// while HasTask ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) do
16664: LD_VAR 0 3
16668: PUSH
16669: LD_INT 1
16671: ARRAY
16672: PPUSH
16673: CALL_OW 313
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: PPUSH
16682: CALL_OW 314
16686: IFFALSE 16697
// begin Wait ( 10 ) ;
16688: LD_INT 10
16690: PPUSH
16691: CALL_OW 67
// end ;
16695: GO 16664
// end ; ComEnterUnit ( un , buildings [ 1 ] ) ;
16697: LD_VAR 0 2
16701: PPUSH
16702: LD_VAR 0 3
16706: PUSH
16707: LD_INT 1
16709: ARRAY
16710: PPUSH
16711: CALL_OW 120
// Wait ( 1 ) ;
16715: LD_INT 1
16717: PPUSH
16718: CALL_OW 67
// AddComChangeProfession ( un , class_engineer ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 2
16729: PPUSH
16730: CALL_OW 183
// Wait ( 1 ) ;
16734: LD_INT 1
16736: PPUSH
16737: CALL_OW 67
// AddComExitBuilding ( un ) ;
16741: LD_VAR 0 2
16745: PPUSH
16746: CALL_OW 182
// Wait ( 1 ) ;
16750: LD_INT 1
16752: PPUSH
16753: CALL_OW 67
// end ; if GetCargo ( un , mat_oil ) = 0 then
16757: LD_VAR 0 2
16761: PPUSH
16762: LD_INT 2
16764: PPUSH
16765: CALL_OW 289
16769: PUSH
16770: LD_INT 0
16772: EQUAL
16773: IFFALSE 16796
// AddComTransport ( un , buildings [ 1 ] , mat_oil ) ;
16775: LD_VAR 0 2
16779: PPUSH
16780: LD_VAR 0 3
16784: PUSH
16785: LD_INT 1
16787: ARRAY
16788: PPUSH
16789: LD_INT 2
16791: PPUSH
16792: CALL_OW 211
// Wait ( 1 ) ;
16796: LD_INT 1
16798: PPUSH
16799: CALL_OW 67
// repeat Wait ( 0 0$1 ) until not HasTask ( un ) ;
16803: LD_INT 35
16805: PPUSH
16806: CALL_OW 67
16810: LD_VAR 0 2
16814: PPUSH
16815: CALL_OW 314
16819: NOT
16820: IFFALSE 16803
// if GetCargo ( un , mat_oil ) <> 0 then
16822: LD_VAR 0 2
16826: PPUSH
16827: LD_INT 2
16829: PPUSH
16830: CALL_OW 289
16834: PUSH
16835: LD_INT 0
16837: NONEQUAL
16838: IFFALSE 16956
// begin AddComMoveToArea ( un , BarrelAreas [ ShootAreaNr ] ) ;
16840: LD_VAR 0 2
16844: PPUSH
16845: LD_LOC 9
16849: PUSH
16850: LD_LOC 8
16854: ARRAY
16855: PPUSH
16856: CALL_OW 173
// Wait ( 1 ) ;
16860: LD_INT 1
16862: PPUSH
16863: CALL_OW 67
// AddComUnload ( un ) ;
16867: LD_VAR 0 2
16871: PPUSH
16872: CALL_OW 219
// Wait ( 1 ) ;
16876: LD_INT 1
16878: PPUSH
16879: CALL_OW 67
// AddComSailEvent ( un , un ) ;
16883: LD_VAR 0 2
16887: PPUSH
16888: LD_VAR 0 2
16892: PPUSH
16893: CALL_OW 224
// AddComMoveToArea ( un , StandAreas [ ShootAreaNr ] ) ;
16897: LD_VAR 0 2
16901: PPUSH
16902: LD_LOC 10
16906: PUSH
16907: LD_LOC 8
16911: ARRAY
16912: PPUSH
16913: CALL_OW 173
// Wait ( 1 ) ;
16917: LD_INT 1
16919: PPUSH
16920: CALL_OW 67
// ShootAreaNr := ShootAreaNr + 1 ;
16924: LD_ADDR_LOC 8
16928: PUSH
16929: LD_LOC 8
16933: PUSH
16934: LD_INT 1
16936: PLUS
16937: ST_TO_ADDR
// if ShootAreaNr = 6 then
16938: LD_LOC 8
16942: PUSH
16943: LD_INT 6
16945: EQUAL
16946: IFFALSE 16956
// ShootAreaNr := 1 ;
16948: LD_ADDR_LOC 8
16952: PUSH
16953: LD_INT 1
16955: ST_TO_ADDR
// end ; end ; end ;
16956: GO 16430
16958: POP
16959: POP
// end ; end ;
16960: PPOPN 3
16962: END
// every 0 0$0.1 + 0 0$0.05 marked 203 do var un , shoot_filter ;
16963: GO 16965
16965: DISABLE
16966: LD_INT 0
16968: PPUSH
16969: PPUSH
// begin shoot_filter := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_hastask ] , [ f_nation , nation_russian ] ] ) ;
16970: LD_ADDR_VAR 0 2
16974: PUSH
16975: LD_INT 11
16977: PPUSH
16978: LD_INT 21
16980: PUSH
16981: LD_INT 1
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 25
16990: PUSH
16991: LD_INT 2
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 60
17000: PUSH
17001: EMPTY
17002: LIST
17003: PUSH
17004: LD_INT 23
17006: PUSH
17007: LD_INT 3
17009: PUSH
17010: EMPTY
17011: LIST
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 70
17024: ST_TO_ADDR
// if shoot_filter <> [ ] then
17025: LD_VAR 0 2
17029: PUSH
17030: EMPTY
17031: NONEQUAL
17032: IFFALSE 17148
// for un in shoot_filter do
17034: LD_ADDR_VAR 0 1
17038: PUSH
17039: LD_VAR 0 2
17043: PUSH
17044: FOR_IN
17045: IFFALSE 17146
// if GetTaskList ( un ) <> [ ] then
17047: LD_VAR 0 1
17051: PPUSH
17052: CALL_OW 437
17056: PUSH
17057: EMPTY
17058: NONEQUAL
17059: IFFALSE 17144
// if ( GetTaskList ( un ) [ 1 ] [ 1 ] = A ) and ( InArea ( GetTaskList ( un ) [ 1 ] [ 2 ] , GetTaskList ( un ) [ 1 ] [ 3 ] , ShootArea ) ) then
17061: LD_VAR 0 1
17065: PPUSH
17066: CALL_OW 437
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PUSH
17075: LD_INT 1
17077: ARRAY
17078: PUSH
17079: LD_STRING A
17081: EQUAL
17082: PUSH
17083: LD_VAR 0 1
17087: PPUSH
17088: CALL_OW 437
17092: PUSH
17093: LD_INT 1
17095: ARRAY
17096: PUSH
17097: LD_INT 2
17099: ARRAY
17100: PPUSH
17101: LD_VAR 0 1
17105: PPUSH
17106: CALL_OW 437
17110: PUSH
17111: LD_INT 1
17113: ARRAY
17114: PUSH
17115: LD_INT 3
17117: ARRAY
17118: PPUSH
17119: LD_INT 11
17121: PPUSH
17122: CALL_OW 309
17126: AND
17127: IFFALSE 17144
// AddExperience ( un , skill_combat , 1 ) ;
17129: LD_VAR 0 1
17133: PPUSH
17134: LD_INT 1
17136: PPUSH
17137: LD_INT 1
17139: PPUSH
17140: CALL_OW 492
17144: GO 17044
17146: POP
17147: POP
// enable ;
17148: ENABLE
// end ;
17149: PPOPN 2
17151: END
// on SailEvent ( un ) do var x , y , i ;
17152: LD_INT 0
17154: PPUSH
17155: PPUSH
17156: PPUSH
// begin x := GetX ( un ) ;
17157: LD_ADDR_VAR 0 2
17161: PUSH
17162: LD_VAR 0 1
17166: PPUSH
17167: CALL_OW 250
17171: ST_TO_ADDR
// y := GetY ( un ) ;
17172: LD_ADDR_VAR 0 3
17176: PUSH
17177: LD_VAR 0 1
17181: PPUSH
17182: CALL_OW 251
17186: ST_TO_ADDR
// for i := 0 to 5 do
17187: LD_ADDR_VAR 0 4
17191: PUSH
17192: DOUBLE
17193: LD_INT 0
17195: DEC
17196: ST_TO_ADDR
17197: LD_INT 5
17199: PUSH
17200: FOR_TO
17201: IFFALSE 17297
// if HexInfo ( ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) = - 1 then
17203: LD_VAR 0 2
17207: PPUSH
17208: LD_VAR 0 4
17212: PPUSH
17213: LD_INT 1
17215: PPUSH
17216: CALL_OW 272
17220: PPUSH
17221: LD_VAR 0 3
17225: PPUSH
17226: LD_VAR 0 4
17230: PPUSH
17231: LD_INT 1
17233: PPUSH
17234: CALL_OW 273
17238: PPUSH
17239: CALL_OW 428
17243: PUSH
17244: LD_INT 1
17246: NEG
17247: EQUAL
17248: IFFALSE 17295
// AddComAttackPlace ( un , ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) ;
17250: LD_VAR 0 1
17254: PPUSH
17255: LD_VAR 0 2
17259: PPUSH
17260: LD_VAR 0 4
17264: PPUSH
17265: LD_INT 1
17267: PPUSH
17268: CALL_OW 272
17272: PPUSH
17273: LD_VAR 0 3
17277: PPUSH
17278: LD_VAR 0 4
17282: PPUSH
17283: LD_INT 1
17285: PPUSH
17286: CALL_OW 273
17290: PPUSH
17291: CALL_OW 176
17295: GO 17200
17297: POP
17298: POP
// end ; end_of_file
17299: PPOPN 4
17301: END
// every 0 0$1 marked 301 do var filter , x , y , d , lidi ;
17302: GO 17304
17304: DISABLE
17305: LD_INT 0
17307: PPUSH
17308: PPUSH
17309: PPUSH
17310: PPUSH
17311: PPUSH
// begin FreetimeAsked := true ;
17312: LD_ADDR_EXP 68
17316: PUSH
17317: LD_INT 1
17319: ST_TO_ADDR
// if not FreeTimeGranted and ( IsOK ( Petrovova ) or IsOK ( Kirilenkova ) or IsOK ( Kapitsova ) ) and ( IsOK ( Kuzmov ) or IsOK ( Gnyevko ) or IsOK ( Titov ) or IsOK ( Oblukov ) ) then
17320: LD_EXP 59
17324: NOT
17325: PUSH
17326: LD_EXP 21
17330: PPUSH
17331: CALL_OW 302
17335: PUSH
17336: LD_EXP 4
17340: PPUSH
17341: CALL_OW 302
17345: OR
17346: PUSH
17347: LD_EXP 6
17351: PPUSH
17352: CALL_OW 302
17356: OR
17357: AND
17358: PUSH
17359: LD_EXP 10
17363: PPUSH
17364: CALL_OW 302
17368: PUSH
17369: LD_EXP 5
17373: PPUSH
17374: CALL_OW 302
17378: OR
17379: PUSH
17380: LD_EXP 18
17384: PPUSH
17385: CALL_OW 302
17389: OR
17390: PUSH
17391: LD_EXP 19
17395: PPUSH
17396: CALL_OW 302
17400: OR
17401: AND
17402: IFFALSE 17866
// begin D_FreeTime ;
17404: CALL 6345 0 0
// case Query ( QFreeTime ) of 1 :
17408: LD_STRING QFreeTime
17410: PPUSH
17411: CALL_OW 97
17415: PUSH
17416: LD_INT 1
17418: DOUBLE
17419: EQUAL
17420: IFTRUE 17424
17422: GO 17850
17424: POP
// begin FreeTimeGranted := true ;
17425: LD_ADDR_EXP 59
17429: PUSH
17430: LD_INT 1
17432: ST_TO_ADDR
// D_QrFreeTime1 ;
17433: CALL 6812 0 0
// ComExitVehicle ( [ FreeMan , FreeWoman ] ) ;
17437: LD_EXP 57
17441: PUSH
17442: LD_EXP 58
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: PPUSH
17451: CALL_OW 121
// SetSide ( [ FreeMan , FreeWoman ] , ally ) ;
17455: LD_EXP 57
17459: PUSH
17460: LD_EXP 58
17464: PUSH
17465: EMPTY
17466: LIST
17467: LIST
17468: PPUSH
17469: LD_EXP 32
17473: PPUSH
17474: CALL_OW 235
// ComMoveXY ( [ FreeMan , FreeWoman ] , 115 , 32 ) ;
17478: LD_EXP 57
17482: PUSH
17483: LD_EXP 58
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: LD_INT 115
17494: PPUSH
17495: LD_INT 32
17497: PPUSH
17498: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
17502: LD_INT 35
17504: PPUSH
17505: CALL_OW 67
// lidi := FilterUnitsInArea ( HandOverEnterArea , [ f_side , ally ] ) ;
17509: LD_ADDR_VAR 0 5
17513: PUSH
17514: LD_INT 6
17516: PPUSH
17517: LD_INT 22
17519: PUSH
17520: LD_EXP 32
17524: PUSH
17525: EMPTY
17526: LIST
17527: LIST
17528: PPUSH
17529: CALL_OW 70
17533: ST_TO_ADDR
// until ( 0 + lidi ) = 2 ;
17534: LD_INT 0
17536: PUSH
17537: LD_VAR 0 5
17541: PLUS
17542: PUSH
17543: LD_INT 2
17545: EQUAL
17546: IFFALSE 17502
// RemoveUnit ( FreeMan ) ;
17548: LD_EXP 57
17552: PPUSH
17553: CALL_OW 64
// RemoveUnit ( FreeWoman ) ;
17557: LD_EXP 58
17561: PPUSH
17562: CALL_OW 64
// Wait ( 3 3$0 ) ;
17566: LD_INT 6300
17568: PPUSH
17569: CALL_OW 67
// PlaceUnitArea ( FreeMan , HandOverEnterArea , false ) ;
17573: LD_EXP 57
17577: PPUSH
17578: LD_INT 6
17580: PPUSH
17581: LD_INT 0
17583: PPUSH
17584: CALL_OW 49
// PlaceUnitArea ( FreeWoman , HandOverEnterArea , false ) ;
17588: LD_EXP 58
17592: PPUSH
17593: LD_INT 6
17595: PPUSH
17596: LD_INT 0
17598: PPUSH
17599: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
17603: LD_ADDR_VAR 0 1
17607: PUSH
17608: LD_INT 22
17610: PUSH
17611: LD_EXP 31
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PUSH
17620: LD_INT 2
17622: PUSH
17623: LD_INT 30
17625: PUSH
17626: LD_INT 0
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: PUSH
17633: LD_INT 30
17635: PUSH
17636: LD_INT 1
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: PUSH
17643: EMPTY
17644: LIST
17645: LIST
17646: LIST
17647: PUSH
17648: EMPTY
17649: LIST
17650: PUSH
17651: EMPTY
17652: LIST
17653: LIST
17654: PPUSH
17655: CALL_OW 69
17659: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
17660: LD_INT 0
17662: PUSH
17663: LD_VAR 0 1
17667: PLUS
17668: PUSH
17669: LD_INT 0
17671: NONEQUAL
17672: IFFALSE 17733
// begin x := GetX ( filter [ 1 ] ) ;
17674: LD_ADDR_VAR 0 2
17678: PUSH
17679: LD_VAR 0 1
17683: PUSH
17684: LD_INT 1
17686: ARRAY
17687: PPUSH
17688: CALL_OW 250
17692: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
17693: LD_ADDR_VAR 0 3
17697: PUSH
17698: LD_VAR 0 1
17702: PUSH
17703: LD_INT 1
17705: ARRAY
17706: PPUSH
17707: CALL_OW 251
17711: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
17712: LD_ADDR_VAR 0 4
17716: PUSH
17717: LD_VAR 0 1
17721: PUSH
17722: LD_INT 1
17724: ARRAY
17725: PPUSH
17726: CALL_OW 254
17730: ST_TO_ADDR
// end else
17731: GO 17771
// begin x := GetX ( Burlak ) ;
17733: LD_ADDR_VAR 0 2
17737: PUSH
17738: LD_EXP 1
17742: PPUSH
17743: CALL_OW 250
17747: ST_TO_ADDR
// y := GetY ( Burlak ) ;
17748: LD_ADDR_VAR 0 3
17752: PUSH
17753: LD_EXP 1
17757: PPUSH
17758: CALL_OW 251
17762: ST_TO_ADDR
// d := 1 ;
17763: LD_ADDR_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ST_TO_ADDR
// end ; ComMoveXY ( [ FreeMan , FreeWoman ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
17771: LD_EXP 57
17775: PUSH
17776: LD_EXP 58
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: PPUSH
17785: LD_VAR 0 2
17789: PPUSH
17790: LD_VAR 0 4
17794: PPUSH
17795: LD_INT 5
17797: PPUSH
17798: CALL_OW 272
17802: PPUSH
17803: LD_VAR 0 3
17807: PPUSH
17808: LD_VAR 0 4
17812: PPUSH
17813: LD_INT 5
17815: PPUSH
17816: CALL_OW 273
17820: PPUSH
17821: CALL_OW 111
// SetSide ( [ FreeMan , FreeWoman ] , you ) ;
17825: LD_EXP 57
17829: PUSH
17830: LD_EXP 58
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: PPUSH
17839: LD_EXP 31
17843: PPUSH
17844: CALL_OW 235
// end ; 2 :
17848: GO 17866
17850: LD_INT 2
17852: DOUBLE
17853: EQUAL
17854: IFTRUE 17858
17856: GO 17865
17858: POP
// D_QrFreeTime2 ; end ;
17859: CALL 6832 0 0
17863: GO 17866
17865: POP
// end ; end ; end_of_file
17866: PPOPN 5
17868: END
// every 0 0$1 marked 401 do
17869: GO 17871
17871: DISABLE
// begin MashaAsked := true ;
17872: LD_ADDR_EXP 70
17876: PUSH
17877: LD_INT 1
17879: ST_TO_ADDR
// D_Masha ;
17880: CALL 6852 0 0
// Query ( QMasha ) ;
17884: LD_STRING QMasha
17886: PPUSH
17887: CALL_OW 97
// D_Masha2 ;
17891: CALL 6880 0 0
// ChangeMissionObjectives ( MMasha ) ;
17895: LD_STRING MMasha
17897: PPUSH
17898: CALL_OW 337
// enable ( 402 ) ;
17902: LD_INT 402
17904: ENABLE_MARKED
// end ;
17905: END
// var BurlakTimeInVehicle , QMashaQueryShown , QMashaQueryRefused , BurlakWasInVehicle , BurlakNewVehicle , BurlakOldVehicle ; every 0 0$0.2 marked 402 do
17906: GO 17908
17908: DISABLE
// begin if not GetType ( IsInUnit ( Burlak ) ) = unit_vehicle then
17909: LD_EXP 1
17913: PPUSH
17914: CALL_OW 310
17918: PPUSH
17919: CALL_OW 247
17923: PUSH
17924: LD_INT 2
17926: EQUAL
17927: NOT
17928: IFFALSE 18178
// begin BurlakOldVehicle := 0 ;
17930: LD_ADDR_LOC 16
17934: PUSH
17935: LD_INT 0
17937: ST_TO_ADDR
// if BurlakWasInVehicle and not Masha = BurlakNewVehicle and not QMashaQueryRefused then
17938: LD_LOC 14
17942: PUSH
17943: LD_EXP 60
17947: PUSH
17948: LD_LOC 15
17952: EQUAL
17953: NOT
17954: AND
17955: PUSH
17956: LD_LOC 13
17960: NOT
17961: AND
17962: IFFALSE 18160
// begin if QMashaQueryShown then
17964: LD_LOC 12
17968: IFFALSE 18062
// case Query ( QMashaQuery2 ) of 1 :
17970: LD_STRING QMashaQuery2
17972: PPUSH
17973: CALL_OW 97
17977: PUSH
17978: LD_INT 1
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18048
17986: POP
// begin if Masha <> 0 then
17987: LD_EXP 60
17991: PUSH
17992: LD_INT 0
17994: NONEQUAL
17995: IFFALSE 18009
// SetMark ( Masha , 0 ) ;
17997: LD_EXP 60
18001: PPUSH
18002: LD_INT 0
18004: PPUSH
18005: CALL_OW 242
// Masha := BurlakNewVehicle ;
18009: LD_ADDR_EXP 60
18013: PUSH
18014: LD_LOC 15
18018: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18019: LD_EXP 60
18023: PPUSH
18024: LD_INT 1
18026: PPUSH
18027: CALL_OW 242
// ChangeMissionObjectives ( MMashaDone ) ;
18031: LD_STRING MMashaDone
18033: PPUSH
18034: CALL_OW 337
// BurlakNewVehicle := 0 ;
18038: LD_ADDR_LOC 15
18042: PUSH
18043: LD_INT 0
18045: ST_TO_ADDR
// end ; 2 :
18046: GO 18060
18048: LD_INT 2
18050: DOUBLE
18051: EQUAL
18052: IFTRUE 18056
18054: GO 18059
18056: POP
// ; end else
18057: GO 18060
18059: POP
18060: GO 18160
// begin case Query ( QMashaQuery ) of 1 :
18062: LD_STRING QMashaQuery
18064: PPUSH
18065: CALL_OW 97
18069: PUSH
18070: LD_INT 1
18072: DOUBLE
18073: EQUAL
18074: IFTRUE 18078
18076: GO 18140
18078: POP
// begin if Masha <> 0 then
18079: LD_EXP 60
18083: PUSH
18084: LD_INT 0
18086: NONEQUAL
18087: IFFALSE 18101
// SetMark ( Masha , 0 ) ;
18089: LD_EXP 60
18093: PPUSH
18094: LD_INT 0
18096: PPUSH
18097: CALL_OW 242
// Masha := BurlakNewVehicle ;
18101: LD_ADDR_EXP 60
18105: PUSH
18106: LD_LOC 15
18110: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18111: LD_EXP 60
18115: PPUSH
18116: LD_INT 1
18118: PPUSH
18119: CALL_OW 242
// ChangeMissionObjectives ( MMashaDone ) ;
18123: LD_STRING MMashaDone
18125: PPUSH
18126: CALL_OW 337
// BurlakNewVehicle := 0 ;
18130: LD_ADDR_LOC 15
18134: PUSH
18135: LD_INT 0
18137: ST_TO_ADDR
// end ; 2 :
18138: GO 18152
18140: LD_INT 2
18142: DOUBLE
18143: EQUAL
18144: IFTRUE 18148
18146: GO 18151
18148: POP
// ; end ;
18149: GO 18152
18151: POP
// QMashaQueryShown := true ;
18152: LD_ADDR_LOC 12
18156: PUSH
18157: LD_INT 1
18159: ST_TO_ADDR
// end ; end ; QMashaQueryRefused := false ;
18160: LD_ADDR_LOC 13
18164: PUSH
18165: LD_INT 0
18167: ST_TO_ADDR
// BurlakWasInVehicle := false ;
18168: LD_ADDR_LOC 14
18172: PUSH
18173: LD_INT 0
18175: ST_TO_ADDR
// end else
18176: GO 18374
// begin BurlakNewVehicle := IsInUnit ( Burlak ) ;
18178: LD_ADDR_LOC 15
18182: PUSH
18183: LD_EXP 1
18187: PPUSH
18188: CALL_OW 310
18192: ST_TO_ADDR
// if not BurlakWasInVehicle then
18193: LD_LOC 14
18197: NOT
18198: IFFALSE 18212
// BurlakTimeInVehicle := tick else
18200: LD_ADDR_LOC 11
18204: PUSH
18205: LD_OWVAR 1
18209: ST_TO_ADDR
18210: GO 18366
// begin if tick - BurlakTimeInVehicle > 0 0$30 then
18212: LD_OWVAR 1
18216: PUSH
18217: LD_LOC 11
18221: MINUS
18222: PUSH
18223: LD_INT 1050
18225: GREATER
18226: IFFALSE 18366
// if BurlakNewVehicle <> BurlakOldVehicle and not Masha = BurlakNewVehicle then
18228: LD_LOC 15
18232: PUSH
18233: LD_LOC 16
18237: NONEQUAL
18238: PUSH
18239: LD_EXP 60
18243: PUSH
18244: LD_LOC 15
18248: EQUAL
18249: NOT
18250: AND
18251: IFFALSE 18366
// begin BurlakOldVehicle := BurlakNewVehicle ;
18253: LD_ADDR_LOC 16
18257: PUSH
18258: LD_LOC 15
18262: ST_TO_ADDR
// case Query ( QMashaQuery ) of 1 :
18263: LD_STRING QMashaQuery
18265: PPUSH
18266: CALL_OW 97
18270: PUSH
18271: LD_INT 1
18273: DOUBLE
18274: EQUAL
18275: IFTRUE 18279
18277: GO 18338
18279: POP
// begin if Masha <> 0 then
18280: LD_EXP 60
18284: PUSH
18285: LD_INT 0
18287: NONEQUAL
18288: IFFALSE 18302
// SetMark ( Masha , 0 ) ;
18290: LD_EXP 60
18294: PPUSH
18295: LD_INT 0
18297: PPUSH
18298: CALL_OW 242
// Masha := IsInUnit ( Burlak ) ;
18302: LD_ADDR_EXP 60
18306: PUSH
18307: LD_EXP 1
18311: PPUSH
18312: CALL_OW 310
18316: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18317: LD_EXP 60
18321: PPUSH
18322: LD_INT 1
18324: PPUSH
18325: CALL_OW 242
// ChangeMissionObjectives ( MMashaDone ) ;
18329: LD_STRING MMashaDone
18331: PPUSH
18332: CALL_OW 337
// end ; 2 :
18336: GO 18358
18338: LD_INT 2
18340: DOUBLE
18341: EQUAL
18342: IFTRUE 18346
18344: GO 18357
18346: POP
// QMashaQueryRefused := true ; end ;
18347: LD_ADDR_LOC 13
18351: PUSH
18352: LD_INT 1
18354: ST_TO_ADDR
18355: GO 18358
18357: POP
// QMashaQueryShown := true ;
18358: LD_ADDR_LOC 12
18362: PUSH
18363: LD_INT 1
18365: ST_TO_ADDR
// end ; end ; BurlakWasInVehicle := true ;
18366: LD_ADDR_LOC 14
18370: PUSH
18371: LD_INT 1
18373: ST_TO_ADDR
// end ; enable ;
18374: ENABLE
// end ; end_of_file
18375: END
// var amcount ; export function prepare_am_attack ; var rndclass , rndlevel , i ; begin
18376: LD_INT 0
18378: PPUSH
18379: PPUSH
18380: PPUSH
18381: PPUSH
// if MercPaid then
18382: LD_EXP 39
18386: IFFALSE 18400
// amcount := weaker else
18388: LD_ADDR_LOC 17
18392: PUSH
18393: LD_EXP 75
18397: ST_TO_ADDR
18398: GO 18410
// amcount := stronger ;
18400: LD_ADDR_LOC 17
18404: PUSH
18405: LD_EXP 76
18409: ST_TO_ADDR
// for i := 1 to amcount do
18410: LD_ADDR_VAR 0 4
18414: PUSH
18415: DOUBLE
18416: LD_INT 1
18418: DEC
18419: ST_TO_ADDR
18420: LD_LOC 17
18424: PUSH
18425: FOR_TO
18426: IFFALSE 18579
// begin uc_side := usa ;
18428: LD_ADDR_OWVAR 20
18432: PUSH
18433: LD_EXP 35
18437: ST_TO_ADDR
// uc_nation := nation_american ;
18438: LD_ADDR_OWVAR 21
18442: PUSH
18443: LD_INT 1
18445: ST_TO_ADDR
// rndclass := Rand ( 1 , 3 ) ;
18446: LD_ADDR_VAR 0 2
18450: PUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 3
18456: PPUSH
18457: CALL_OW 12
18461: ST_TO_ADDR
// case rndclass of 1 :
18462: LD_VAR 0 2
18466: PUSH
18467: LD_INT 1
18469: DOUBLE
18470: EQUAL
18471: IFTRUE 18475
18473: GO 18493
18475: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; 2 :
18476: LD_INT 0
18478: PPUSH
18479: LD_INT 1
18481: PPUSH
18482: LD_EXP 74
18486: PPUSH
18487: CALL_OW 380
18491: GO 18546
18493: LD_INT 2
18495: DOUBLE
18496: EQUAL
18497: IFTRUE 18501
18499: GO 18519
18501: POP
// PrepareHuman ( 0 , class_sniper , am_attack_skill ) ; 3 :
18502: LD_INT 0
18504: PPUSH
18505: LD_INT 5
18507: PPUSH
18508: LD_EXP 74
18512: PPUSH
18513: CALL_OW 380
18517: GO 18546
18519: LD_INT 3
18521: DOUBLE
18522: EQUAL
18523: IFTRUE 18527
18525: GO 18545
18527: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; end ;
18528: LD_INT 0
18530: PPUSH
18531: LD_INT 1
18533: PPUSH
18534: LD_EXP 74
18538: PPUSH
18539: CALL_OW 380
18543: GO 18546
18545: POP
// hc_name :=  ;
18546: LD_ADDR_OWVAR 26
18550: PUSH
18551: LD_STRING 
18553: ST_TO_ADDR
// amattack := amattack ^ CreateHuman ;
18554: LD_ADDR_EXP 27
18558: PUSH
18559: LD_EXP 27
18563: PUSH
18564: CALL_OW 44
18568: ADD
18569: ST_TO_ADDR
// Wait ( 1 ) ;
18570: LD_INT 1
18572: PPUSH
18573: CALL_OW 67
// end ;
18577: GO 18425
18579: POP
18580: POP
// end ;
18581: LD_VAR 0 1
18585: RET
// function place_am_attack ; var i , reg_id ; begin
18586: LD_INT 0
18588: PPUSH
18589: PPUSH
18590: PPUSH
// for i := 1 to amcount do
18591: LD_ADDR_VAR 0 2
18595: PUSH
18596: DOUBLE
18597: LD_INT 1
18599: DEC
18600: ST_TO_ADDR
18601: LD_LOC 17
18605: PUSH
18606: FOR_TO
18607: IFFALSE 18639
// begin PlaceUnitArea ( amattack [ i ] , AmEnterArea , false ) ;
18609: LD_EXP 27
18613: PUSH
18614: LD_VAR 0 2
18618: ARRAY
18619: PPUSH
18620: LD_INT 9
18622: PPUSH
18623: LD_INT 0
18625: PPUSH
18626: CALL_OW 49
// Wait ( 1 ) ;
18630: LD_INT 1
18632: PPUSH
18633: CALL_OW 67
// end ;
18637: GO 18606
18639: POP
18640: POP
// reg_id := McRegistry ( usa , [ [ mc_reg_area_to_guard , WholeMapArea ] , - mc_reg_only_important , mc_reg_ignore_fog ] ) ;
18641: LD_ADDR_VAR 0 3
18645: PUSH
18646: LD_EXP 35
18650: PPUSH
18651: LD_INT 2
18653: PUSH
18654: LD_INT 10
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: PUSH
18661: LD_INT 8
18663: NEG
18664: PUSH
18665: LD_INT 7
18667: PUSH
18668: EMPTY
18669: LIST
18670: LIST
18671: LIST
18672: PPUSH
18673: CALL_OW 399
18677: ST_TO_ADDR
// McAttack ( 100 , reg_id , amattack , [ mc_no_stop , mc_pat_aggresive , mc_murder ] ) ;
18678: LD_INT 100
18680: PPUSH
18681: LD_VAR 0 3
18685: PPUSH
18686: LD_EXP 27
18690: PPUSH
18691: LD_INT 10
18693: PUSH
18694: LD_INT 11
18696: PUSH
18697: LD_INT 12
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: LIST
18704: PPUSH
18705: CALL_OW 402
// end ;
18709: LD_VAR 0 1
18713: RET
// every 0 0$1 marked 501 do
18714: GO 18716
18716: DISABLE
// begin AmAttackStarted := true ;
18717: LD_ADDR_EXP 71
18721: PUSH
18722: LD_INT 1
18724: ST_TO_ADDR
// D_AmAttackStart ;
18725: CALL 7116 0 0
// Wait ( 0 0$15 ) ;
18729: LD_INT 525
18731: PPUSH
18732: CALL_OW 67
// place_am_attack ;
18736: CALL 18586 0 0
// enable ( 502 ) ;
18740: LD_INT 502
18742: ENABLE_MARKED
// end ;
18743: END
// every 0 0$10 marked 502 do
18744: GO 18746
18746: DISABLE
// begin if amattack = [ ] then
18747: LD_EXP 27
18751: PUSH
18752: EMPTY
18753: EQUAL
18754: IFFALSE 18771
// begin disable ;
18756: DISABLE
// AmAttackDone := true ;
18757: LD_ADDR_EXP 64
18761: PUSH
18762: LD_INT 1
18764: ST_TO_ADDR
// D_AmAttackFin ;
18765: CALL 7205 0 0
// end else
18769: GO 18772
// enable ;
18771: ENABLE
// end ; end_of_file
18772: END
// every 0 0$2 + 0 0$0.1 do
18773: GO 18775
18775: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
18776: LD_INT 22
18778: PUSH
18779: LD_INT 3
18781: PUSH
18782: EMPTY
18783: LIST
18784: LIST
18785: PUSH
18786: LD_INT 2
18788: PUSH
18789: LD_INT 25
18791: PUSH
18792: LD_INT 12
18794: PUSH
18795: EMPTY
18796: LIST
18797: LIST
18798: PUSH
18799: LD_INT 25
18801: PUSH
18802: LD_INT 16
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 25
18811: PUSH
18812: LD_INT 15
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: LD_INT 25
18821: PUSH
18822: LD_INT 17
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: LIST
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: PPUSH
18840: CALL_OW 69
18844: PUSH
18845: LD_INT 22
18847: PUSH
18848: LD_INT 3
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 1
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: LD_INT 3
18867: PUSH
18868: LD_INT 2
18870: PUSH
18871: LD_INT 25
18873: PUSH
18874: LD_INT 12
18876: PUSH
18877: EMPTY
18878: LIST
18879: LIST
18880: PUSH
18881: LD_INT 25
18883: PUSH
18884: LD_INT 16
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PUSH
18891: LD_INT 25
18893: PUSH
18894: LD_INT 15
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: PUSH
18901: LD_INT 25
18903: PUSH
18904: LD_INT 17
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: LIST
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: LIST
18926: PPUSH
18927: CALL_OW 69
18931: GREATER
18932: IFFALSE 18943
// begin SetAchievement ( ACH_POTA ) ;
18934: LD_STRING ACH_POTA
18936: PPUSH
18937: CALL_OW 543
// exit ;
18941: GO 18944
// end ; enable ;
18943: ENABLE
// end ;
18944: END
// export function SA_OnLegionHandoverToUPF ; begin
18945: LD_INT 0
18947: PPUSH
// SetAchievement ( ACH_SC ) ;
18948: LD_STRING ACH_SC
18950: PPUSH
18951: CALL_OW 543
// end ;
18955: LD_VAR 0 1
18959: RET
// export function SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ; begin
18960: LD_INT 0
18962: PPUSH
// SetAchievement ( ACH_GAME ) ;
18963: LD_STRING ACH_GAME
18965: PPUSH
18966: CALL_OW 543
// end ;
18970: LD_VAR 0 1
18974: RET

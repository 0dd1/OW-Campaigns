// export Burlak , Popov , Belkov , Kirilenkova , Gnyevko , Kapitsova , Dietrich , Gleb , Petrosyan , Kuzmov , Heike , Kovalyuk , Kurt , Mercenary1 , Scholtze , ASoldier1 , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Dolgov , Xavier , other , player_units , amattack , depot_build , depotX , depotY , you , ally , arab , merc , usa , GenscherBetrayed , HeikeCaptured , HeikeKilled , MercPaid , MercHandedOver , MercWillBeHandedOver , MercHandoverDone , MercHandoverArabsSpawned , MercAccepted , HeikeDismissed , PopovAsked , HuntingAccepted , BuildingsDone , TurretsDone , WeaponsDone , TechnoDone , MortarDone , GalleryBuild , AvailableWeapons , AvailableBuildings , AvailableTechno , FreeMan , FreeWoman , FreeTimeGranted , Masha , CompVehConstructed , LimitTeleportResearched , LimitTeleportTested , AmAttackDone , HeikeSend , GalleryAsked , HuntingAsked , FreetimeAsked , MortarAsked , MashaAsked , AmAttackStarted , hunter , speed , am_attack_skill , weaker , stronger , countdown , pocetmercenaries , snipers_positions , ar_human , MercenaryWillBeHealen , KurtWillBeHealen , WasSelected , CountTrees , GenCount , disabled2 , disabled3 , disabled4 , disabled5 , disabled6 , disabled7 , disabled8 , disabled9 , disabled102 ; export testing ; function read_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// you := 3 ;
   4: LD_ADDR_EXP 31
   8: PUSH
   9: LD_INT 3
  11: ST_TO_ADDR
// ally := 6 ;
  12: LD_ADDR_EXP 32
  16: PUSH
  17: LD_INT 6
  19: ST_TO_ADDR
// arab := 2 ;
  20: LD_ADDR_EXP 33
  24: PUSH
  25: LD_INT 2
  27: ST_TO_ADDR
// merc := 5 ;
  28: LD_ADDR_EXP 34
  32: PUSH
  33: LD_INT 5
  35: ST_TO_ADDR
// usa := 1 ;
  36: LD_ADDR_EXP 35
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// HeikeCaptured := LoadVariable ( HeikeCaptured , true ) ;
  44: LD_ADDR_EXP 37
  48: PUSH
  49: LD_STRING HeikeCaptured
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: CALL_OW 30
  59: ST_TO_ADDR
// SetAttitude ( you , ally , att_friend , true ) ;
  60: LD_EXP 31
  64: PPUSH
  65: LD_EXP 32
  69: PPUSH
  70: LD_INT 1
  72: PPUSH
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 80
// SetAttitude ( you , merc , att_neutral , true ) ;
  80: LD_EXP 31
  84: PPUSH
  85: LD_EXP 34
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: CALL_OW 80
// SetAttitude ( you , arab , att_neutral , true ) ;
 100: LD_EXP 31
 104: PPUSH
 105: LD_EXP 33
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: CALL_OW 80
// SetAttitude ( you , usa , att_enemy , true ) ;
 120: LD_EXP 31
 124: PPUSH
 125: LD_EXP 35
 129: PPUSH
 130: LD_INT 2
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 80
// SetAttitude ( ally , merc , att_friend , true ) ;
 140: LD_EXP 32
 144: PPUSH
 145: LD_EXP 34
 149: PPUSH
 150: LD_INT 1
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 80
// SetAttitude ( ally , arab , att_friend , true ) ;
 160: LD_EXP 32
 164: PPUSH
 165: LD_EXP 33
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 80
// SetAttitude ( ally , usa , att_friend , true ) ;
 180: LD_EXP 32
 184: PPUSH
 185: LD_EXP 35
 189: PPUSH
 190: LD_INT 1
 192: PPUSH
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 80
// SetAttitude ( merc , usa , att_neutral , true ) ;
 200: LD_EXP 34
 204: PPUSH
 205: LD_EXP 35
 209: PPUSH
 210: LD_INT 0
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: CALL_OW 80
// SetAttitude ( arab , usa , att_neutral , true ) ;
 220: LD_EXP 33
 224: PPUSH
 225: LD_EXP 35
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 1
 235: PPUSH
 236: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 240: LD_EXP 32
 244: PPUSH
 245: LD_EXP 31
 249: PPUSH
 250: CALL_OW 343
// HeikeDismissed := false ;
 254: LD_ADDR_EXP 45
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// MercAccepted := false ;
 262: LD_ADDR_EXP 44
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// MercPaid := false ;
 270: LD_ADDR_EXP 39
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// BuildingsDone := false ;
 278: LD_ADDR_EXP 48
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// WeaponsDone := false ;
 286: LD_ADDR_EXP 50
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// TechnoDone := false ;
 294: LD_ADDR_EXP 51
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// MortarDone := false ;
 302: LD_ADDR_EXP 52
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// TurretsDone := false ;
 310: LD_ADDR_EXP 49
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// GalleryBuild := false ;
 318: LD_ADDR_EXP 53
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// CompVehConstructed := false ;
 326: LD_ADDR_EXP 61
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// LimitTeleportResearched := false ;
 334: LD_ADDR_EXP 62
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// LimitTeleportTested := false ;
 342: LD_ADDR_EXP 63
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// AmAttackDone := false ;
 350: LD_ADDR_EXP 64
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// HeikeSend := false ;
 358: LD_ADDR_EXP 65
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// HeikeKilled := false ;
 366: LD_ADDR_EXP 38
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// Masha := 0 ;
 374: LD_ADDR_EXP 60
 378: PUSH
 379: LD_INT 0
 381: ST_TO_ADDR
// GalleryAsked := false ;
 382: LD_ADDR_EXP 66
 386: PUSH
 387: LD_INT 0
 389: ST_TO_ADDR
// HuntingAsked := false ;
 390: LD_ADDR_EXP 67
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// FreetimeAsked := false ;
 398: LD_ADDR_EXP 68
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// MashaAsked := false ;
 406: LD_ADDR_EXP 70
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// GenscherBetrayed := false ;
 414: LD_ADDR_EXP 36
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// AvailableWeapons := [ 42 , 43 , 44 , 45 , 46 ] ;
 422: LD_ADDR_EXP 54
 426: PUSH
 427: LD_INT 42
 429: PUSH
 430: LD_INT 43
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: LD_INT 45
 438: PUSH
 439: LD_INT 46
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// AvailableBuildings = [ ] ;
 449: LD_ADDR_EXP 55
 453: PUSH
 454: EMPTY
 455: ST_TO_ADDR
// for i := 0 to 50 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 0
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 50
 468: PUSH
 469: FOR_TO
 470: IFFALSE 510
// if GetRestrict ( i , you ) = 1 then
 472: LD_VAR 0 2
 476: PPUSH
 477: LD_EXP 31
 481: PPUSH
 482: CALL_OW 323
 486: PUSH
 487: LD_INT 1
 489: EQUAL
 490: IFFALSE 508
// AvailableBuildings := AvailableBuildings ^ i ;
 492: LD_ADDR_EXP 55
 496: PUSH
 497: LD_EXP 55
 501: PUSH
 502: LD_VAR 0 2
 506: ADD
 507: ST_TO_ADDR
 508: GO 469
 510: POP
 511: POP
// AvailableBuildings := AvailableBuildings diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
 512: LD_ADDR_EXP 55
 516: PUSH
 517: LD_EXP 55
 521: PUSH
 522: LD_INT 0
 524: PUSH
 525: LD_INT 2
 527: PUSH
 528: LD_INT 4
 530: PUSH
 531: LD_INT 6
 533: PUSH
 534: LD_INT 7
 536: PUSH
 537: LD_INT 8
 539: PUSH
 540: LD_INT 9
 542: PUSH
 543: LD_INT 10
 545: PUSH
 546: LD_INT 11
 548: PUSH
 549: LD_INT 12
 551: PUSH
 552: LD_INT 14
 554: PUSH
 555: LD_INT 22
 557: PUSH
 558: LD_INT 31
 560: PUSH
 561: LD_INT 32
 563: PUSH
 564: LD_INT 33
 566: PUSH
 567: LD_INT 39
 569: PUSH
 570: LD_INT 40
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: DIFF
 592: ST_TO_ADDR
// AvailableTechno = [ ] ;
 593: LD_ADDR_EXP 56
 597: PUSH
 598: EMPTY
 599: ST_TO_ADDR
// for i := 0 to 72 do
 600: LD_ADDR_VAR 0 2
 604: PUSH
 605: DOUBLE
 606: LD_INT 0
 608: DEC
 609: ST_TO_ADDR
 610: LD_INT 72
 612: PUSH
 613: FOR_TO
 614: IFFALSE 654
// if GetTech ( i , you ) = 1 then
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_EXP 31
 625: PPUSH
 626: CALL_OW 321
 630: PUSH
 631: LD_INT 1
 633: EQUAL
 634: IFFALSE 652
// AvailableTechno := AvailableTechno ^ i ;
 636: LD_ADDR_EXP 56
 640: PUSH
 641: LD_EXP 56
 645: PUSH
 646: LD_VAR 0 2
 650: ADD
 651: ST_TO_ADDR
 652: GO 613
 654: POP
 655: POP
// AvailableTechno := AvailableTechno diff 72 ;
 656: LD_ADDR_EXP 56
 660: PUSH
 661: LD_EXP 56
 665: PUSH
 666: LD_INT 72
 668: DIFF
 669: ST_TO_ADDR
// end ;
 670: LD_VAR 0 1
 674: RET
// function set_difficulty ; begin
 675: LD_INT 0
 677: PPUSH
// countdown := [ 2 2$0 , 1 1$30 , 1 1$0 ] [ difficulty ] ;
 678: LD_ADDR_EXP 77
 682: PUSH
 683: LD_INT 4200
 685: PUSH
 686: LD_INT 3150
 688: PUSH
 689: LD_INT 2100
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_OWVAR 67
 701: ARRAY
 702: ST_TO_ADDR
// pocetmercenaries := [ 20 , 40 , 60 ] [ difficulty ] ;
 703: LD_ADDR_EXP 78
 707: PUSH
 708: LD_INT 20
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 60
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: ST_TO_ADDR
// am_attack_skill := [ 4 , 6 , 8 ] [ difficulty ] ;
 728: LD_ADDR_EXP 74
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: LD_INT 6
 738: PUSH
 739: LD_INT 8
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_OWVAR 67
 751: ARRAY
 752: ST_TO_ADDR
// weaker := [ 10 , 15 , 20 ] [ difficulty ] ;
 753: LD_ADDR_EXP 75
 757: PUSH
 758: LD_INT 10
 760: PUSH
 761: LD_INT 15
 763: PUSH
 764: LD_INT 20
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_OWVAR 67
 776: ARRAY
 777: ST_TO_ADDR
// stronger := [ 20 , 25 , 30 ] [ difficulty ] ;
 778: LD_ADDR_EXP 76
 782: PUSH
 783: LD_INT 20
 785: PUSH
 786: LD_INT 25
 788: PUSH
 789: LD_INT 30
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: PUSH
 797: LD_OWVAR 67
 801: ARRAY
 802: ST_TO_ADDR
// speed := [ 60 60$0 , 45 45$0 , 38 38$0 ] [ difficulty ] ;
 803: LD_ADDR_EXP 73
 807: PUSH
 808: LD_INT 126000
 810: PUSH
 811: LD_INT 94500
 813: PUSH
 814: LD_INT 79800
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// snipers_positions := [ [ [ 115 , 77 ] , [ 127 , 67 ] , [ 15 , 2 ] , [ 71 , 1 ] ] , [ [ 120 , 70 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] , [ [ 115 , 77 ] , [ 127 , 67 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] ] [ difficulty ] ;
 828: LD_ADDR_EXP 79
 832: PUSH
 833: LD_INT 115
 835: PUSH
 836: LD_INT 77
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 127
 845: PUSH
 846: LD_INT 67
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 15
 855: PUSH
 856: LD_INT 2
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 71
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 120
 881: PUSH
 882: LD_INT 70
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 11
 891: PUSH
 892: LD_INT 20
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 50
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 71
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_INT 115
 938: PUSH
 939: LD_INT 77
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 127
 948: PUSH
 949: LD_INT 67
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 11
 958: PUSH
 959: LD_INT 20
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: PUSH
 966: LD_INT 15
 968: PUSH
 969: LD_INT 2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 50
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 71
 988: PUSH
 989: LD_INT 1
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: ST_TO_ADDR
// end ;
1015: LD_VAR 0 1
1019: RET
// function nacti_osobu ( ident ) ; begin
1020: LD_INT 0
1022: PPUSH
// if CheckCharacterSet ( ident ) then
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 29
1032: IFFALSE 1051
// result := CreateCharacter ( ident ) else
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: LD_VAR 0 1
1043: PPUSH
1044: CALL_OW 34
1048: ST_TO_ADDR
1049: GO 1059
// result := 0 ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// function create_people ; var def , i , x , y , un ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
1068: PPUSH
1069: PPUSH
1070: PPUSH
1071: PPUSH
// uc_side = you ;
1072: LD_ADDR_OWVAR 20
1076: PUSH
1077: LD_EXP 31
1081: ST_TO_ADDR
// uc_nation := nation_russian ;
1082: LD_ADDR_OWVAR 21
1086: PUSH
1087: LD_INT 3
1089: ST_TO_ADDR
// other := nacti_osobu ( survivors1 ) ;
1090: LD_ADDR_EXP 25
1094: PUSH
1095: LD_STRING survivors1
1097: PPUSH
1098: CALL 1020 0 1
1102: ST_TO_ADDR
// other := other union nacti_osobu ( survivors2 ) ;
1103: LD_ADDR_EXP 25
1107: PUSH
1108: LD_EXP 25
1112: PUSH
1113: LD_STRING survivors2
1115: PPUSH
1116: CALL 1020 0 1
1120: UNION
1121: ST_TO_ADDR
// other := other diff 0 ;
1122: LD_ADDR_EXP 25
1126: PUSH
1127: LD_EXP 25
1131: PUSH
1132: LD_INT 0
1134: DIFF
1135: ST_TO_ADDR
// if not testing then
1136: LD_EXP 95
1140: NOT
1141: IFFALSE 1158
// Burlak := nacti_osobu ( Burlak ) else
1143: LD_ADDR_EXP 1
1147: PUSH
1148: LD_STRING Burlak
1150: PPUSH
1151: CALL 1020 0 1
1155: ST_TO_ADDR
1156: GO 1186
// begin PrepareMechanic ( sex_male , 7 ) ;
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 383
// hc_name = Burlak ;
1168: LD_ADDR_OWVAR 26
1172: PUSH
1173: LD_STRING Burlak
1175: ST_TO_ADDR
// Burlak = CreateHuman ;
1176: LD_ADDR_EXP 1
1180: PUSH
1181: CALL_OW 44
1185: ST_TO_ADDR
// end ; Belkov := nacti_osobu ( Belkov ) ;
1186: LD_ADDR_EXP 3
1190: PUSH
1191: LD_STRING Belkov
1193: PPUSH
1194: CALL 1020 0 1
1198: ST_TO_ADDR
// Gnyevko := nacti_osobu ( Gnyevko ) ;
1199: LD_ADDR_EXP 5
1203: PUSH
1204: LD_STRING Gnyevko
1206: PPUSH
1207: CALL 1020 0 1
1211: ST_TO_ADDR
// Kirilenkova := nacti_osobu ( Kirilenkova ) ;
1212: LD_ADDR_EXP 4
1216: PUSH
1217: LD_STRING Kirilenkova
1219: PPUSH
1220: CALL 1020 0 1
1224: ST_TO_ADDR
// Kovalyuk := nacti_osobu ( Kovalyuk ) ;
1225: LD_ADDR_EXP 12
1229: PUSH
1230: LD_STRING Kovalyuk
1232: PPUSH
1233: CALL 1020 0 1
1237: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
1238: LD_ADDR_EXP 2
1242: PUSH
1243: LD_STRING Popov
1245: PPUSH
1246: CALL_OW 25
1250: ST_TO_ADDR
// Scholtze := nacti_osobu ( Scholtze ) ;
1251: LD_ADDR_EXP 15
1255: PUSH
1256: LD_STRING Scholtze
1258: PPUSH
1259: CALL 1020 0 1
1263: ST_TO_ADDR
// Kuzmov := nacti_osobu ( Kuzmov ) ;
1264: LD_ADDR_EXP 10
1268: PUSH
1269: LD_STRING Kuzmov
1271: PPUSH
1272: CALL 1020 0 1
1276: ST_TO_ADDR
// Karamazov := nacti_osobu ( Karamazov ) ;
1277: LD_ADDR_EXP 17
1281: PUSH
1282: LD_STRING Karamazov
1284: PPUSH
1285: CALL 1020 0 1
1289: ST_TO_ADDR
// Petrovova := nacti_osobu ( Petrovova ) ;
1290: LD_ADDR_EXP 21
1294: PUSH
1295: LD_STRING Petrovova
1297: PPUSH
1298: CALL 1020 0 1
1302: ST_TO_ADDR
// Gleb := nacti_osobu ( Gleb ) ;
1303: LD_ADDR_EXP 8
1307: PUSH
1308: LD_STRING Gleb
1310: PPUSH
1311: CALL 1020 0 1
1315: ST_TO_ADDR
// Petrosyan := nacti_osobu ( Petrosyan ) ;
1316: LD_ADDR_EXP 9
1320: PUSH
1321: LD_STRING Petrosyan
1323: PPUSH
1324: CALL 1020 0 1
1328: ST_TO_ADDR
// Lipshchin := nacti_osobu ( Lipshchin ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Lipshchin
1336: PPUSH
1337: CALL 1020 0 1
1341: ST_TO_ADDR
// Titov := nacti_osobu ( Titov ) ;
1342: LD_ADDR_EXP 18
1346: PUSH
1347: LD_STRING Titov
1349: PPUSH
1350: CALL 1020 0 1
1354: ST_TO_ADDR
// Dolgov := nacti_osobu ( Dolgov ) ;
1355: LD_ADDR_EXP 23
1359: PUSH
1360: LD_STRING Dolgov
1362: PPUSH
1363: CALL 1020 0 1
1367: ST_TO_ADDR
// Xavier := nacti_osobu ( Xavier ) ;
1368: LD_ADDR_EXP 24
1372: PUSH
1373: LD_STRING Xavier
1375: PPUSH
1376: CALL 1020 0 1
1380: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1381: LD_ADDR_EXP 19
1385: PUSH
1386: LD_STRING Oblukov
1388: PPUSH
1389: CALL_OW 25
1393: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
1394: LD_ADDR_EXP 20
1398: PUSH
1399: LD_STRING Kozlov
1401: PPUSH
1402: CALL_OW 25
1406: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1407: LD_ADDR_EXP 6
1411: PUSH
1412: LD_STRING Kapitsova
1414: PPUSH
1415: CALL_OW 25
1419: ST_TO_ADDR
// uc_side = ally ;
1420: LD_ADDR_OWVAR 20
1424: PUSH
1425: LD_EXP 32
1429: ST_TO_ADDR
// uc_nation := nation_arabian ;
1430: LD_ADDR_OWVAR 21
1434: PUSH
1435: LD_INT 2
1437: ST_TO_ADDR
// if not testing then
1438: LD_EXP 95
1442: NOT
1443: IFFALSE 1460
// Heike := nacti_osobu ( Heike ) else
1445: LD_ADDR_EXP 11
1449: PUSH
1450: LD_STRING Heike
1452: PPUSH
1453: CALL 1020 0 1
1457: ST_TO_ADDR
1458: GO 1488
// begin PrepareSoldier ( sex_female , 7 ) ;
1460: LD_INT 2
1462: PPUSH
1463: LD_INT 7
1465: PPUSH
1466: CALL_OW 381
// hc_name = Heike ;
1470: LD_ADDR_OWVAR 26
1474: PUSH
1475: LD_STRING Heike
1477: ST_TO_ADDR
// Heike = CreateHuman ;
1478: LD_ADDR_EXP 11
1482: PUSH
1483: CALL_OW 44
1487: ST_TO_ADDR
// end ; SetClass ( Heike , class_engineer ) ;
1488: LD_EXP 11
1492: PPUSH
1493: LD_INT 2
1495: PPUSH
1496: CALL_OW 336
// uc_side = arab ;
1500: LD_ADDR_OWVAR 20
1504: PUSH
1505: LD_EXP 33
1509: ST_TO_ADDR
// uc_nation := nation_arabian ;
1510: LD_ADDR_OWVAR 21
1514: PUSH
1515: LD_INT 2
1517: ST_TO_ADDR
// Dietrich := NewCharacter ( Dietrich ) ;
1518: LD_ADDR_EXP 7
1522: PUSH
1523: LD_STRING Dietrich
1525: PPUSH
1526: CALL_OW 25
1530: ST_TO_ADDR
// uc_side = merc ;
1531: LD_ADDR_OWVAR 20
1535: PUSH
1536: LD_EXP 34
1540: ST_TO_ADDR
// uc_nation := nation_arabian ;
1541: LD_ADDR_OWVAR 21
1545: PUSH
1546: LD_INT 2
1548: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
1549: LD_ADDR_EXP 13
1553: PUSH
1554: LD_STRING Kurt
1556: PPUSH
1557: CALL_OW 25
1561: ST_TO_ADDR
// PrepareHuman ( sex_male , class_engineer , 2 ) ;
1562: LD_INT 1
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: CALL_OW 380
// hc_name :=  ;
1575: LD_ADDR_OWVAR 26
1579: PUSH
1580: LD_STRING 
1582: ST_TO_ADDR
// Mercenary1 := CreateHuman ;
1583: LD_ADDR_EXP 14
1587: PUSH
1588: CALL_OW 44
1592: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 1 ) ;
1593: LD_INT 1
1595: PPUSH
1596: LD_INT 1
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 380
// hc_name :=  ;
1606: LD_ADDR_OWVAR 26
1610: PUSH
1611: LD_STRING 
1613: ST_TO_ADDR
// ASoldier1 := CreateHuman ;
1614: LD_ADDR_EXP 16
1618: PUSH
1619: CALL_OW 44
1623: ST_TO_ADDR
// player_units := ( [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] union other ) diff [ 0 ] ;
1624: LD_ADDR_EXP 26
1628: PUSH
1629: LD_EXP 1
1633: PUSH
1634: LD_EXP 3
1638: PUSH
1639: LD_EXP 4
1643: PUSH
1644: LD_EXP 5
1648: PUSH
1649: LD_EXP 6
1653: PUSH
1654: LD_EXP 8
1658: PUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_EXP 12
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 17
1678: PUSH
1679: LD_EXP 18
1683: PUSH
1684: LD_EXP 19
1688: PUSH
1689: LD_EXP 20
1693: PUSH
1694: LD_EXP 21
1698: PUSH
1699: LD_EXP 22
1703: PUSH
1704: LD_EXP 9
1708: PUSH
1709: LD_EXP 23
1713: PUSH
1714: LD_EXP 24
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_EXP 25
1743: UNION
1744: PUSH
1745: LD_INT 0
1747: PUSH
1748: EMPTY
1749: LIST
1750: DIFF
1751: ST_TO_ADDR
// other := other diff player_units ;
1752: LD_ADDR_EXP 25
1756: PUSH
1757: LD_EXP 25
1761: PUSH
1762: LD_EXP 26
1766: DIFF
1767: ST_TO_ADDR
// uc_side = you ;
1768: LD_ADDR_OWVAR 20
1772: PUSH
1773: LD_EXP 31
1777: ST_TO_ADDR
// uc_nation := nation_russian ;
1778: LD_ADDR_OWVAR 21
1782: PUSH
1783: LD_INT 3
1785: ST_TO_ADDR
// if 0 + player_units < 15 then
1786: LD_INT 0
1788: PUSH
1789: LD_EXP 26
1793: PLUS
1794: PUSH
1795: LD_INT 15
1797: LESS
1798: IFFALSE 1862
// for i := 1 to 0 + other do
1800: LD_ADDR_VAR 0 3
1804: PUSH
1805: DOUBLE
1806: LD_INT 1
1808: DEC
1809: ST_TO_ADDR
1810: LD_INT 0
1812: PUSH
1813: LD_EXP 25
1817: PLUS
1818: PUSH
1819: FOR_TO
1820: IFFALSE 1860
// if 0 + player_units < 15 then
1822: LD_INT 0
1824: PUSH
1825: LD_EXP 26
1829: PLUS
1830: PUSH
1831: LD_INT 15
1833: LESS
1834: IFFALSE 1858
// player_units := player_units ^ other [ i ] ;
1836: LD_ADDR_EXP 26
1840: PUSH
1841: LD_EXP 26
1845: PUSH
1846: LD_EXP 25
1850: PUSH
1851: LD_VAR 0 3
1855: ARRAY
1856: ADD
1857: ST_TO_ADDR
1858: GO 1819
1860: POP
1861: POP
// if 0 + player_units < 15 then
1862: LD_INT 0
1864: PUSH
1865: LD_EXP 26
1869: PLUS
1870: PUSH
1871: LD_INT 15
1873: LESS
1874: IFFALSE 1939
// for i := 1 to 15 - player_units do
1876: LD_ADDR_VAR 0 3
1880: PUSH
1881: DOUBLE
1882: LD_INT 1
1884: DEC
1885: ST_TO_ADDR
1886: LD_INT 15
1888: PUSH
1889: LD_EXP 26
1893: MINUS
1894: PUSH
1895: FOR_TO
1896: IFFALSE 1937
// begin PrepareHuman ( 0 , 0 , 4 ) ;
1898: LD_INT 0
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: LD_INT 4
1906: PPUSH
1907: CALL_OW 380
// hc_name :=  ;
1911: LD_ADDR_OWVAR 26
1915: PUSH
1916: LD_STRING 
1918: ST_TO_ADDR
// player_units := player_units ^ CreateHuman ;
1919: LD_ADDR_EXP 26
1923: PUSH
1924: LD_EXP 26
1928: PUSH
1929: CALL_OW 44
1933: ADD
1934: ST_TO_ADDR
// end ;
1935: GO 1895
1937: POP
1938: POP
// Randomize ;
1939: CALL_OW 10
// RandomizeAll ;
1943: CALL_OW 11
// for un in player_units do
1947: LD_ADDR_VAR 0 6
1951: PUSH
1952: LD_EXP 26
1956: PUSH
1957: FOR_IN
1958: IFFALSE 1977
// PlaceUnitArea ( un , EnterArea , false ) ;
1960: LD_VAR 0 6
1964: PPUSH
1965: LD_INT 3
1967: PPUSH
1968: LD_INT 0
1970: PPUSH
1971: CALL_OW 49
1975: GO 1957
1977: POP
1978: POP
// end ;
1979: LD_VAR 0 1
1983: RET
// function create_vehicles ; var i , auto ; begin
1984: LD_INT 0
1986: PPUSH
1987: PPUSH
1988: PPUSH
// for i := 1 to 5 do
1989: LD_ADDR_VAR 0 2
1993: PUSH
1994: DOUBLE
1995: LD_INT 1
1997: DEC
1998: ST_TO_ADDR
1999: LD_INT 5
2001: PUSH
2002: FOR_TO
2003: IFFALSE 2160
// begin uc_side := you ;
2005: LD_ADDR_OWVAR 20
2009: PUSH
2010: LD_EXP 31
2014: ST_TO_ADDR
// uc_nation := nation_russian ;
2015: LD_ADDR_OWVAR 21
2019: PUSH
2020: LD_INT 3
2022: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2023: LD_ADDR_OWVAR 24
2027: PUSH
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 5
2033: PPUSH
2034: CALL_OW 12
2038: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2039: LD_ADDR_OWVAR 37
2043: PUSH
2044: LD_INT 21
2046: ST_TO_ADDR
// vc_engine := engine_combustion ;
2047: LD_ADDR_OWVAR 39
2051: PUSH
2052: LD_INT 1
2054: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2055: LD_ADDR_OWVAR 40
2059: PUSH
2060: LD_INT 51
2062: ST_TO_ADDR
// vc_control := control_manual ;
2063: LD_ADDR_OWVAR 38
2067: PUSH
2068: LD_INT 1
2070: ST_TO_ADDR
// auto := CreateVehicle ;
2071: LD_ADDR_VAR 0 3
2075: PUSH
2076: CALL_OW 45
2080: ST_TO_ADDR
// if i <= 4 then
2081: LD_VAR 0 2
2085: PUSH
2086: LD_INT 4
2088: LESSEQUAL
2089: IFFALSE 2108
// SetCargo ( auto , mat_cans , 100 ) else
2091: LD_VAR 0 3
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: LD_INT 100
2101: PPUSH
2102: CALL_OW 290
2106: GO 2123
// SetCargo ( auto , mat_oil , 100 ) ;
2108: LD_VAR 0 3
2112: PPUSH
2113: LD_INT 2
2115: PPUSH
2116: LD_INT 100
2118: PPUSH
2119: CALL_OW 290
// SetFuel ( auto , Rand ( 40 , 80 ) ) ;
2123: LD_VAR 0 3
2127: PPUSH
2128: LD_INT 40
2130: PPUSH
2131: LD_INT 80
2133: PPUSH
2134: CALL_OW 12
2138: PPUSH
2139: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2143: LD_VAR 0 3
2147: PPUSH
2148: LD_INT 3
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: CALL_OW 49
// end ;
2158: GO 2002
2160: POP
2161: POP
// uc_side := you ;
2162: LD_ADDR_OWVAR 20
2166: PUSH
2167: LD_EXP 31
2171: ST_TO_ADDR
// uc_nation := nation_russian ;
2172: LD_ADDR_OWVAR 21
2176: PUSH
2177: LD_INT 3
2179: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2180: LD_ADDR_OWVAR 24
2184: PUSH
2185: LD_INT 0
2187: PPUSH
2188: LD_INT 5
2190: PPUSH
2191: CALL_OW 12
2195: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2196: LD_ADDR_OWVAR 37
2200: PUSH
2201: LD_INT 22
2203: ST_TO_ADDR
// vc_engine := engine_combustion ;
2204: LD_ADDR_OWVAR 39
2208: PUSH
2209: LD_INT 1
2211: ST_TO_ADDR
// vc_weapon := ru_crane ;
2212: LD_ADDR_OWVAR 40
2216: PUSH
2217: LD_INT 52
2219: ST_TO_ADDR
// vc_control := control_manual ;
2220: LD_ADDR_OWVAR 38
2224: PUSH
2225: LD_INT 1
2227: ST_TO_ADDR
// auto := CreateVehicle ;
2228: LD_ADDR_VAR 0 3
2232: PUSH
2233: CALL_OW 45
2237: ST_TO_ADDR
// SetFuel ( auto , Rand ( 90 , 100 ) ) ;
2238: LD_VAR 0 3
2242: PPUSH
2243: LD_INT 90
2245: PPUSH
2246: LD_INT 100
2248: PPUSH
2249: CALL_OW 12
2253: PPUSH
2254: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2258: LD_VAR 0 3
2262: PPUSH
2263: LD_INT 3
2265: PPUSH
2266: LD_INT 0
2268: PPUSH
2269: CALL_OW 49
// for i := 1 to 3 do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_INT 3
2285: PUSH
2286: FOR_TO
2287: IFFALSE 2402
// begin uc_side := you ;
2289: LD_ADDR_OWVAR 20
2293: PUSH
2294: LD_EXP 31
2298: ST_TO_ADDR
// uc_nation := nation_russian ;
2299: LD_ADDR_OWVAR 21
2303: PUSH
2304: LD_INT 3
2306: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2307: LD_ADDR_OWVAR 24
2311: PUSH
2312: LD_INT 0
2314: PPUSH
2315: LD_INT 5
2317: PPUSH
2318: CALL_OW 12
2322: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2323: LD_ADDR_OWVAR 37
2327: PUSH
2328: LD_INT 24
2330: ST_TO_ADDR
// vc_engine := engine_combustion ;
2331: LD_ADDR_OWVAR 39
2335: PUSH
2336: LD_INT 1
2338: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2339: LD_ADDR_OWVAR 40
2343: PUSH
2344: LD_INT 53
2346: ST_TO_ADDR
// vc_control := control_manual ;
2347: LD_ADDR_OWVAR 38
2351: PUSH
2352: LD_INT 1
2354: ST_TO_ADDR
// auto := CreateVehicle ;
2355: LD_ADDR_VAR 0 3
2359: PUSH
2360: CALL_OW 45
2364: ST_TO_ADDR
// SetFuel ( auto , Rand ( 80 , 100 ) ) ;
2365: LD_VAR 0 3
2369: PPUSH
2370: LD_INT 80
2372: PPUSH
2373: LD_INT 100
2375: PPUSH
2376: CALL_OW 12
2380: PPUSH
2381: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2385: LD_VAR 0 3
2389: PPUSH
2390: LD_INT 3
2392: PPUSH
2393: LD_INT 0
2395: PPUSH
2396: CALL_OW 49
// end ;
2400: GO 2286
2402: POP
2403: POP
// end ;
2404: LD_VAR 0 1
2408: RET
// export function create_snipers ; var xy ; begin
2409: LD_INT 0
2411: PPUSH
2412: PPUSH
// for xy in snipers_positions do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_EXP 79
2422: PUSH
2423: FOR_IN
2424: IFFALSE 2568
// begin uc_side = usa ;
2426: LD_ADDR_OWVAR 20
2430: PUSH
2431: LD_EXP 35
2435: ST_TO_ADDR
// uc_nation := nation_american ;
2436: LD_ADDR_OWVAR 21
2440: PUSH
2441: LD_INT 1
2443: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
2444: LD_ADDR_OWVAR 30
2448: PUSH
2449: LD_INT 0
2451: PUSH
2452: LD_INT 0
2454: PUSH
2455: LD_INT 0
2457: PUSH
2458: LD_INT 0
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: ST_TO_ADDR
// hc_skills := [ difficulty - 1 , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2467: LD_ADDR_OWVAR 31
2471: PUSH
2472: LD_OWVAR 67
2476: PUSH
2477: LD_INT 1
2479: MINUS
2480: PUSH
2481: LD_INT 0
2483: PPUSH
2484: LD_INT 2
2486: PPUSH
2487: CALL_OW 12
2491: PUSH
2492: LD_INT 0
2494: PPUSH
2495: LD_INT 2
2497: PPUSH
2498: CALL_OW 12
2502: PUSH
2503: LD_INT 0
2505: PPUSH
2506: LD_INT 2
2508: PPUSH
2509: CALL_OW 12
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: ST_TO_ADDR
// hc_class := class_sniper ;
2520: LD_ADDR_OWVAR 28
2524: PUSH
2525: LD_INT 5
2527: ST_TO_ADDR
// hc_name :=  ;
2528: LD_ADDR_OWVAR 26
2532: PUSH
2533: LD_STRING 
2535: ST_TO_ADDR
// PlaceUnitXY ( CreateHuman , xy [ 1 ] , xy [ 2 ] , false ) ;
2536: CALL_OW 44
2540: PPUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_INT 1
2548: ARRAY
2549: PPUSH
2550: LD_VAR 0 2
2554: PUSH
2555: LD_INT 2
2557: ARRAY
2558: PPUSH
2559: LD_INT 0
2561: PPUSH
2562: CALL_OW 48
// end ;
2566: GO 2423
2568: POP
2569: POP
// end ;
2570: LD_VAR 0 1
2574: RET
// export function create_heike ; var auto , filter , x , y , d , Guard1 , Guard2 ; begin
2575: LD_INT 0
2577: PPUSH
2578: PPUSH
2579: PPUSH
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
2584: PPUSH
// uc_side := ally ;
2585: LD_ADDR_OWVAR 20
2589: PUSH
2590: LD_EXP 32
2594: ST_TO_ADDR
// uc_nation := nation_russian ;
2595: LD_ADDR_OWVAR 21
2599: PUSH
2600: LD_INT 3
2602: ST_TO_ADDR
// uc_direction := Rand ( 3 , 5 ) ;
2603: LD_ADDR_OWVAR 24
2607: PUSH
2608: LD_INT 3
2610: PPUSH
2611: LD_INT 5
2613: PPUSH
2614: CALL_OW 12
2618: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2619: LD_INT 0
2621: PPUSH
2622: LD_INT 1
2624: PPUSH
2625: LD_INT 6
2627: PPUSH
2628: CALL_OW 380
// hc_name :=  ;
2632: LD_ADDR_OWVAR 26
2636: PUSH
2637: LD_STRING 
2639: ST_TO_ADDR
// Guard1 := CreateHuman ;
2640: LD_ADDR_VAR 0 7
2644: PUSH
2645: CALL_OW 44
2649: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2650: LD_INT 0
2652: PPUSH
2653: LD_INT 1
2655: PPUSH
2656: LD_INT 6
2658: PPUSH
2659: CALL_OW 380
// hc_name :=  ;
2663: LD_ADDR_OWVAR 26
2667: PUSH
2668: LD_STRING 
2670: ST_TO_ADDR
// Guard2 := CreateHuman ;
2671: LD_ADDR_VAR 0 8
2675: PUSH
2676: CALL_OW 44
2680: ST_TO_ADDR
// PlaceUnitArea ( Guard1 , EnterArea , false ) ;
2681: LD_VAR 0 7
2685: PPUSH
2686: LD_INT 3
2688: PPUSH
2689: LD_INT 0
2691: PPUSH
2692: CALL_OW 49
// PlaceUnitArea ( Guard2 , EnterArea , false ) ;
2696: LD_VAR 0 8
2700: PPUSH
2701: LD_INT 3
2703: PPUSH
2704: LD_INT 0
2706: PPUSH
2707: CALL_OW 49
// PlaceUnitArea ( Heike , EnterArea , false ) ;
2711: LD_EXP 11
2715: PPUSH
2716: LD_INT 3
2718: PPUSH
2719: LD_INT 0
2721: PPUSH
2722: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
2726: LD_ADDR_VAR 0 3
2730: PUSH
2731: LD_INT 22
2733: PUSH
2734: LD_EXP 31
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PUSH
2743: LD_INT 2
2745: PUSH
2746: LD_INT 30
2748: PUSH
2749: LD_INT 0
2751: PUSH
2752: EMPTY
2753: LIST
2754: LIST
2755: PUSH
2756: LD_INT 30
2758: PUSH
2759: LD_INT 1
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: PUSH
2766: EMPTY
2767: LIST
2768: LIST
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PPUSH
2778: CALL_OW 69
2782: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
2783: LD_INT 0
2785: PUSH
2786: LD_VAR 0 3
2790: PLUS
2791: PUSH
2792: LD_INT 0
2794: NONEQUAL
2795: IFFALSE 2856
// begin x := GetX ( filter [ 1 ] ) ;
2797: LD_ADDR_VAR 0 4
2801: PUSH
2802: LD_VAR 0 3
2806: PUSH
2807: LD_INT 1
2809: ARRAY
2810: PPUSH
2811: CALL_OW 250
2815: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
2816: LD_ADDR_VAR 0 5
2820: PUSH
2821: LD_VAR 0 3
2825: PUSH
2826: LD_INT 1
2828: ARRAY
2829: PPUSH
2830: CALL_OW 251
2834: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
2835: LD_ADDR_VAR 0 6
2839: PUSH
2840: LD_VAR 0 3
2844: PUSH
2845: LD_INT 1
2847: ARRAY
2848: PPUSH
2849: CALL_OW 254
2853: ST_TO_ADDR
// end else
2854: GO 2894
// begin x := GetX ( Burlak ) ;
2856: LD_ADDR_VAR 0 4
2860: PUSH
2861: LD_EXP 1
2865: PPUSH
2866: CALL_OW 250
2870: ST_TO_ADDR
// y := GetY ( Burlak ) ;
2871: LD_ADDR_VAR 0 5
2875: PUSH
2876: LD_EXP 1
2880: PPUSH
2881: CALL_OW 251
2885: ST_TO_ADDR
// d := 1 ;
2886: LD_ADDR_VAR 0 6
2890: PUSH
2891: LD_INT 1
2893: ST_TO_ADDR
// end ; repeat ComMoveXY ( Guard1 , x , y ) ;
2894: LD_VAR 0 7
2898: PPUSH
2899: LD_VAR 0 4
2903: PPUSH
2904: LD_VAR 0 5
2908: PPUSH
2909: CALL_OW 111
// ComMoveUnit ( Heike , Guard1 ) ;
2913: LD_EXP 11
2917: PPUSH
2918: LD_VAR 0 7
2922: PPUSH
2923: CALL_OW 112
// ComMoveUnit ( Guard2 , Heike ) ;
2927: LD_VAR 0 8
2931: PPUSH
2932: LD_EXP 11
2936: PPUSH
2937: CALL_OW 112
// Wait ( 0 0$1 ) ;
2941: LD_INT 35
2943: PPUSH
2944: CALL_OW 67
// until ( GetDistUnitXY ( Guard1 , x , y ) < 10 ) and ( GetDistUnitXY ( Guard2 , x , y ) < 10 ) ;
2948: LD_VAR 0 7
2952: PPUSH
2953: LD_VAR 0 4
2957: PPUSH
2958: LD_VAR 0 5
2962: PPUSH
2963: CALL_OW 297
2967: PUSH
2968: LD_INT 10
2970: LESS
2971: PUSH
2972: LD_VAR 0 8
2976: PPUSH
2977: LD_VAR 0 4
2981: PPUSH
2982: LD_VAR 0 5
2986: PPUSH
2987: CALL_OW 297
2991: PUSH
2992: LD_INT 10
2994: LESS
2995: AND
2996: IFFALSE 2894
// ComStop ( [ Guard1 , Guard2 , Heike ] ) ;
2998: LD_VAR 0 7
3002: PUSH
3003: LD_VAR 0 8
3007: PUSH
3008: LD_EXP 11
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: LIST
3017: PPUSH
3018: CALL_OW 141
// Wait ( 10 ) ;
3022: LD_INT 10
3024: PPUSH
3025: CALL_OW 67
// ComMoveXY ( [ Guard1 , Guard2 ] , 113 , 29 ) ;
3029: LD_VAR 0 7
3033: PUSH
3034: LD_VAR 0 8
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: PPUSH
3043: LD_INT 113
3045: PPUSH
3046: LD_INT 29
3048: PPUSH
3049: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
3053: LD_INT 35
3055: PPUSH
3056: CALL_OW 67
// until not HasTask ( Guard1 ) and not HasTask ( Guard2 ) ;
3060: LD_VAR 0 7
3064: PPUSH
3065: CALL_OW 314
3069: NOT
3070: PUSH
3071: LD_VAR 0 8
3075: PPUSH
3076: CALL_OW 314
3080: NOT
3081: AND
3082: IFFALSE 3053
// DestroyUnit ( Guard1 ) ;
3084: LD_VAR 0 7
3088: PPUSH
3089: CALL_OW 65
// DestroyUnit ( Guard2 ) ;
3093: LD_VAR 0 8
3097: PPUSH
3098: CALL_OW 65
// end ;
3102: LD_VAR 0 1
3106: RET
// export function create_kurt ; begin
3107: LD_INT 0
3109: PPUSH
// PlaceUnitArea ( Mercenary1 , MercEnterArea , false ) ;
3110: LD_EXP 14
3114: PPUSH
3115: LD_INT 4
3117: PPUSH
3118: LD_INT 0
3120: PPUSH
3121: CALL_OW 49
// PlaceUnitArea ( Kurt , MercEnterArea , false ) ;
3125: LD_EXP 13
3129: PPUSH
3130: LD_INT 4
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 49
// enable ( 2 ) ;
3140: LD_INT 2
3142: ENABLE_MARKED
// end ;
3143: LD_VAR 0 1
3147: RET
// starting begin FogOff ( false ) ;
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 344
// Randomize ;
3155: CALL_OW 10
// RandomizeAll ;
3159: CALL_OW 11
// testing = false ;
3163: LD_ADDR_EXP 95
3167: PUSH
3168: LD_INT 0
3170: ST_TO_ADDR
// InitBc ;
3171: CALL_OW 21
// InitHc ;
3175: CALL_OW 19
// InitUc ;
3179: CALL_OW 18
// InitVc ;
3183: CALL_OW 20
// disable ( 1 ) ;
3187: LD_INT 1
3189: DISABLE_MARKED
// disable ( 2 ) ;
3190: LD_INT 2
3192: DISABLE_MARKED
// disable ( 3 ) ;
3193: LD_INT 3
3195: DISABLE_MARKED
// disable ( 4 ) ;
3196: LD_INT 4
3198: DISABLE_MARKED
// disable ( 5 ) ;
3199: LD_INT 5
3201: DISABLE_MARKED
// disable ( 6 ) ;
3202: LD_INT 6
3204: DISABLE_MARKED
// disable ( 7 ) ;
3205: LD_INT 7
3207: DISABLE_MARKED
// disable ( 8 ) ;
3208: LD_INT 8
3210: DISABLE_MARKED
// disable ( 9 ) ;
3211: LD_INT 9
3213: DISABLE_MARKED
// disable ( 10 ) ;
3214: LD_INT 10
3216: DISABLE_MARKED
// disable ( 11 ) ;
3217: LD_INT 11
3219: DISABLE_MARKED
// disable ( 13 ) ;
3220: LD_INT 13
3222: DISABLE_MARKED
// disable ( 20 ) ;
3223: LD_INT 20
3225: DISABLE_MARKED
// disable ( 23 ) ;
3226: LD_INT 23
3228: DISABLE_MARKED
// disable ( 24 ) ;
3229: LD_INT 24
3231: DISABLE_MARKED
// disable ( 50 ) ;
3232: LD_INT 50
3234: DISABLE_MARKED
// disable ( 101 ) ;
3235: LD_INT 101
3237: DISABLE_MARKED
// disable ( 102 ) ;
3238: LD_INT 102
3240: DISABLE_MARKED
// disable ( 201 ) ;
3241: LD_INT 201
3243: DISABLE_MARKED
// disable ( 202 ) ;
3244: LD_INT 202
3246: DISABLE_MARKED
// disable ( 203 ) ;
3247: LD_INT 203
3249: DISABLE_MARKED
// disable ( 301 ) ;
3250: LD_INT 301
3252: DISABLE_MARKED
// disable ( 401 ) ;
3253: LD_INT 401
3255: DISABLE_MARKED
// disable ( 402 ) ;
3256: LD_INT 402
3258: DISABLE_MARKED
// disable ( 501 ) ;
3259: LD_INT 501
3261: DISABLE_MARKED
// disable ( 502 ) ;
3262: LD_INT 502
3264: DISABLE_MARKED
// disable ( 601 ) ;
3265: LD_INT 601
3267: DISABLE_MARKED
// disable ( 999 ) ;
3268: LD_INT 999
3270: DISABLE_MARKED
// PlaceTreesToArea ( TreeArea1 , [ 2 , 10 , 11 , 27 , 35 ] , 20 , 10 , 4 ) ;
3271: LD_INT 24
3273: PPUSH
3274: LD_INT 2
3276: PUSH
3277: LD_INT 10
3279: PUSH
3280: LD_INT 11
3282: PUSH
3283: LD_INT 27
3285: PUSH
3286: LD_INT 35
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: PPUSH
3296: LD_INT 20
3298: PPUSH
3299: LD_INT 10
3301: PPUSH
3302: LD_INT 4
3304: PPUSH
3305: CALL_OW 352
// PlaceTreesToArea ( TreeArea2 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3309: LD_INT 25
3311: PPUSH
3312: LD_INT 9
3314: PUSH
3315: LD_INT 10
3317: PUSH
3318: LD_INT 27
3320: PUSH
3321: LD_INT 35
3323: PUSH
3324: LD_INT 48
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: LIST
3333: PPUSH
3334: LD_INT 20
3336: PPUSH
3337: LD_INT 10
3339: PPUSH
3340: LD_INT 4
3342: PPUSH
3343: CALL_OW 352
// PlaceTreesToArea ( TreeArea3 , [ 2 , 9 , 10 , 11 , 27 ] , 20 , 10 , 4 ) ;
3347: LD_INT 26
3349: PPUSH
3350: LD_INT 2
3352: PUSH
3353: LD_INT 9
3355: PUSH
3356: LD_INT 10
3358: PUSH
3359: LD_INT 11
3361: PUSH
3362: LD_INT 27
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: PPUSH
3372: LD_INT 20
3374: PPUSH
3375: LD_INT 10
3377: PPUSH
3378: LD_INT 4
3380: PPUSH
3381: CALL_OW 352
// PlaceTreesToArea ( TreeArea4 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3385: LD_INT 27
3387: PPUSH
3388: LD_INT 9
3390: PUSH
3391: LD_INT 10
3393: PUSH
3394: LD_INT 27
3396: PUSH
3397: LD_INT 35
3399: PUSH
3400: LD_INT 48
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: PPUSH
3410: LD_INT 20
3412: PPUSH
3413: LD_INT 10
3415: PPUSH
3416: LD_INT 4
3418: PPUSH
3419: CALL_OW 352
// PlaceTreesToArea ( TreeArea5 , [ 2 , 9 , 10 , 11 , 48 ] , 20 , 10 , 4 ) ;
3423: LD_INT 28
3425: PPUSH
3426: LD_INT 2
3428: PUSH
3429: LD_INT 9
3431: PUSH
3432: LD_INT 10
3434: PUSH
3435: LD_INT 11
3437: PUSH
3438: LD_INT 48
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: PPUSH
3448: LD_INT 20
3450: PPUSH
3451: LD_INT 10
3453: PPUSH
3454: LD_INT 4
3456: PPUSH
3457: CALL_OW 352
// PlaceTreesToArea ( TreeArea6 , [ 2 , 11 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3461: LD_INT 29
3463: PPUSH
3464: LD_INT 2
3466: PUSH
3467: LD_INT 11
3469: PUSH
3470: LD_INT 27
3472: PUSH
3473: LD_INT 35
3475: PUSH
3476: LD_INT 48
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: PPUSH
3486: LD_INT 20
3488: PPUSH
3489: LD_INT 10
3491: PPUSH
3492: LD_INT 4
3494: PPUSH
3495: CALL_OW 352
// read_parameters ;
3499: CALL 0 0 0
// set_difficulty ;
3503: CALL 675 0 0
// create_people ;
3507: CALL 1064 0 0
// create_vehicles ;
3511: CALL 1984 0 0
// create_snipers ;
3515: CALL 2409 0 0
// prepare_am_attack ;
3519: CALL 18504 0 0
// CenterNowOnXY ( 112 , 32 ) ;
3523: LD_INT 112
3525: PPUSH
3526: LD_INT 32
3528: PPUSH
3529: CALL_OW 86
// D_Start ;
3533: CALL 4849 0 0
// SaveForQuickRestart ;
3537: CALL_OW 22
// end ;
3541: END
// every 0 0$10 marked 999 do var filter , prumer , un , un1 , un2 , distance , pole , budova1 , budova2 , i , trotskij ;
3542: GO 3544
3544: DISABLE
3545: LD_INT 0
3547: PPUSH
3548: PPUSH
3549: PPUSH
3550: PPUSH
3551: PPUSH
3552: PPUSH
3553: PPUSH
3554: PPUSH
3555: PPUSH
3556: PPUSH
3557: PPUSH
// begin if BuildingsDone and WeaponsDone and TechnoDone and CompVehConstructed and LimitTeleportTested and Masha and AmAttackDone then
3558: LD_EXP 48
3562: PUSH
3563: LD_EXP 50
3567: AND
3568: PUSH
3569: LD_EXP 51
3573: AND
3574: PUSH
3575: LD_EXP 61
3579: AND
3580: PUSH
3581: LD_EXP 63
3585: AND
3586: PUSH
3587: LD_EXP 60
3591: AND
3592: PUSH
3593: LD_EXP 64
3597: AND
3598: IFFALSE 4845
// begin disable ;
3600: DISABLE
// gained_medals := [ ] ;
3601: LD_ADDR_OWVAR 61
3605: PUSH
3606: EMPTY
3607: ST_TO_ADDR
// missing_medals := [ ] ;
3608: LD_ADDR_OWVAR 62
3612: PUSH
3613: EMPTY
3614: ST_TO_ADDR
// if HeikeCaptured then
3615: LD_EXP 37
3619: IFFALSE 3652
// if MortarDone then
3621: LD_EXP 52
3625: IFFALSE 3639
// AddMedal ( ArabBarracks , 1 ) else
3627: LD_STRING ArabBarracks
3629: PPUSH
3630: LD_INT 1
3632: PPUSH
3633: CALL_OW 101
3637: GO 3650
// AddMedal ( ArabBarracks , - 1 ) else
3639: LD_STRING ArabBarracks
3641: PPUSH
3642: LD_INT 1
3644: NEG
3645: PPUSH
3646: CALL_OW 101
3650: GO 3687
// if tick < speed then
3652: LD_OWVAR 1
3656: PUSH
3657: LD_EXP 73
3661: LESS
3662: IFFALSE 3676
// AddMedal ( Speed , 1 ) else
3664: LD_STRING Speed
3666: PPUSH
3667: LD_INT 1
3669: PPUSH
3670: CALL_OW 101
3674: GO 3687
// AddMedal ( Speed , - 1 ) ;
3676: LD_STRING Speed
3678: PPUSH
3679: LD_INT 1
3681: NEG
3682: PPUSH
3683: CALL_OW 101
// AddMedal ( ArtisticImpression , 1 ) ;
3687: LD_STRING ArtisticImpression
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL_OW 101
// if ( 0 + player_units ) <= 11 then
3697: LD_INT 0
3699: PUSH
3700: LD_EXP 26
3704: PLUS
3705: PUSH
3706: LD_INT 11
3708: LESSEQUAL
3709: IFFALSE 3724
// AddMedal ( FavouriteCommander , - 1 ) else
3711: LD_STRING FavouriteCommander
3713: PPUSH
3714: LD_INT 1
3716: NEG
3717: PPUSH
3718: CALL_OW 101
3722: GO 3796
// if FreeTimeGranted and HuntingAccepted and GalleryBuild then
3724: LD_EXP 59
3728: PUSH
3729: LD_EXP 47
3733: AND
3734: PUSH
3735: LD_EXP 53
3739: AND
3740: IFFALSE 3754
// AddMedal ( FavouriteCommander , 1 ) else
3742: LD_STRING FavouriteCommander
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 101
3752: GO 3796
// if FreeTimeGranted or HuntingAccepted or GalleryBuild then
3754: LD_EXP 59
3758: PUSH
3759: LD_EXP 47
3763: OR
3764: PUSH
3765: LD_EXP 53
3769: OR
3770: IFFALSE 3785
// AddMedal ( FavouriteCommander , - 3 ) else
3772: LD_STRING FavouriteCommander
3774: PPUSH
3775: LD_INT 3
3777: NEG
3778: PPUSH
3779: CALL_OW 101
3783: GO 3796
// AddMedal ( FavouriteCommander , - 2 ) ;
3785: LD_STRING FavouriteCommander
3787: PPUSH
3788: LD_INT 2
3790: NEG
3791: PPUSH
3792: CALL_OW 101
// if MortarDone and not HeikeDismissed then
3796: LD_EXP 52
3800: PUSH
3801: LD_EXP 45
3805: NOT
3806: AND
3807: IFFALSE 3813
// SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ;
3809: CALL 19088 0 0
// GiveMedals ( Main ) ;
3813: LD_STRING Main
3815: PPUSH
3816: CALL_OW 102
// for un1 in player_units do
3820: LD_ADDR_VAR 0 4
3824: PUSH
3825: LD_EXP 26
3829: PUSH
3830: FOR_IN
3831: IFFALSE 3862
// if IsDead ( un1 ) then
3833: LD_VAR 0 4
3837: PPUSH
3838: CALL_OW 301
3842: IFFALSE 3860
// player_units := player_units diff un1 ;
3844: LD_ADDR_EXP 26
3848: PUSH
3849: LD_EXP 26
3853: PUSH
3854: LD_VAR 0 4
3858: DIFF
3859: ST_TO_ADDR
3860: GO 3830
3862: POP
3863: POP
// RewardPeople ( player_units ) ;
3864: LD_EXP 26
3868: PPUSH
3869: CALL_OW 43
// trotskij := [ ] ;
3873: LD_ADDR_VAR 0 11
3877: PUSH
3878: EMPTY
3879: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
3880: LD_ADDR_VAR 0 1
3884: PUSH
3885: LD_INT 22
3887: PUSH
3888: LD_INT 3
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: LD_INT 30
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL_OW 69
3913: PUSH
3914: LD_INT 22
3916: PUSH
3917: LD_INT 3
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PUSH
3924: LD_INT 21
3926: PUSH
3927: LD_INT 3
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: LD_INT 30
3939: PUSH
3940: LD_INT 3
3942: PUSH
3943: EMPTY
3944: LIST
3945: LIST
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: PUSH
3951: EMPTY
3952: LIST
3953: LIST
3954: LIST
3955: PPUSH
3956: CALL_OW 69
3960: ADD
3961: ST_TO_ADDR
// for un in filter do
3962: LD_ADDR_VAR 0 3
3966: PUSH
3967: LD_VAR 0 1
3971: PUSH
3972: FOR_IN
3973: IFFALSE 4314
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
3975: LD_VAR 0 3
3979: PPUSH
3980: CALL_OW 266
3984: PUSH
3985: LD_INT 6
3987: PUSH
3988: LD_INT 7
3990: PUSH
3991: LD_INT 8
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: LIST
3998: IN
3999: IFFALSE 4113
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4001: LD_ADDR_VAR 0 11
4005: PUSH
4006: LD_VAR 0 11
4010: PUSH
4011: LD_VAR 0 3
4015: PPUSH
4016: CALL_OW 266
4020: PUSH
4021: LD_VAR 0 3
4025: PPUSH
4026: CALL_OW 250
4030: PUSH
4031: LD_VAR 0 3
4035: PPUSH
4036: CALL_OW 251
4040: PUSH
4041: LD_VAR 0 3
4045: PPUSH
4046: CALL_OW 254
4050: PUSH
4051: LD_VAR 0 3
4055: PPUSH
4056: CALL_OW 267
4060: PUSH
4061: LD_VAR 0 3
4065: PPUSH
4066: CALL_OW 248
4070: PUSH
4071: LD_VAR 0 3
4075: PPUSH
4076: LD_INT 1
4078: PPUSH
4079: CALL_OW 268
4083: PUSH
4084: LD_VAR 0 3
4088: PPUSH
4089: LD_INT 2
4091: PPUSH
4092: CALL_OW 268
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: PUSH
4107: EMPTY
4108: LIST
4109: ADD
4110: ST_TO_ADDR
4111: GO 4312
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4113: LD_VAR 0 3
4117: PPUSH
4118: CALL_OW 266
4122: PUSH
4123: LD_INT 32
4125: PUSH
4126: LD_INT 33
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: IN
4133: IFFALSE 4230
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4135: LD_ADDR_VAR 0 11
4139: PUSH
4140: LD_VAR 0 11
4144: PUSH
4145: LD_VAR 0 3
4149: PPUSH
4150: CALL_OW 266
4154: PUSH
4155: LD_VAR 0 3
4159: PPUSH
4160: CALL_OW 250
4164: PUSH
4165: LD_VAR 0 3
4169: PPUSH
4170: CALL_OW 251
4174: PUSH
4175: LD_VAR 0 3
4179: PPUSH
4180: CALL_OW 254
4184: PUSH
4185: LD_VAR 0 3
4189: PPUSH
4190: CALL_OW 267
4194: PUSH
4195: LD_VAR 0 3
4199: PPUSH
4200: CALL_OW 248
4204: PUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 269
4214: PUSH
4215: EMPTY
4216: LIST
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: ADD
4227: ST_TO_ADDR
4228: GO 4312
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4230: LD_ADDR_VAR 0 11
4234: PUSH
4235: LD_VAR 0 11
4239: PUSH
4240: LD_VAR 0 3
4244: PPUSH
4245: CALL_OW 266
4249: PUSH
4250: LD_VAR 0 3
4254: PPUSH
4255: CALL_OW 250
4259: PUSH
4260: LD_VAR 0 3
4264: PPUSH
4265: CALL_OW 251
4269: PUSH
4270: LD_VAR 0 3
4274: PPUSH
4275: CALL_OW 254
4279: PUSH
4280: LD_VAR 0 3
4284: PPUSH
4285: CALL_OW 267
4289: PUSH
4290: LD_VAR 0 3
4294: PPUSH
4295: CALL_OW 248
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: LIST
4304: LIST
4305: LIST
4306: LIST
4307: PUSH
4308: EMPTY
4309: LIST
4310: ADD
4311: ST_TO_ADDR
// end ;
4312: GO 3972
4314: POP
4315: POP
// if not Masha or not IsLive ( Masha ) then
4316: LD_EXP 60
4320: NOT
4321: PUSH
4322: LD_EXP 60
4326: PPUSH
4327: CALL_OW 300
4331: NOT
4332: OR
4333: IFFALSE 4342
// DeleteVariable ( Masha ) ;
4335: LD_STRING Masha
4337: PPUSH
4338: CALL_OW 41
// SaveVariable ( trotskij , Trotskij ) ;
4342: LD_VAR 0 11
4346: PPUSH
4347: LD_STRING Trotskij
4349: PPUSH
4350: CALL_OW 39
// SaveVariable ( ListEnvironmentArea ( WholeMapArea ) , Environment ) ;
4354: LD_INT 10
4356: PPUSH
4357: CALL_OW 353
4361: PPUSH
4362: LD_STRING Environment
4364: PPUSH
4365: CALL_OW 39
// SaveVariable ( HeikeKilled , HeikeKilled ) ;
4369: LD_EXP 38
4373: PPUSH
4374: LD_STRING HeikeKilled
4376: PPUSH
4377: CALL_OW 39
// SaveVariable ( MercPaid , MercPaid ) ;
4381: LD_EXP 39
4385: PPUSH
4386: LD_STRING MercPaid
4388: PPUSH
4389: CALL_OW 39
// SaveVariable ( MercHandedOver , MercHandedOver ) ;
4393: LD_EXP 40
4397: PPUSH
4398: LD_STRING MercHandedOver
4400: PPUSH
4401: CALL_OW 39
// SaveVariable ( MercAccepted , MercAccepted ) ;
4405: LD_EXP 44
4409: PPUSH
4410: LD_STRING MercAccepted
4412: PPUSH
4413: CALL_OW 39
// SaveVariable ( GenscherBetrayed , GenscherBetrayed ) ;
4417: LD_EXP 36
4421: PPUSH
4422: LD_STRING GenscherBetrayed
4424: PPUSH
4425: CALL_OW 39
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
4429: LD_EXP 60
4433: PPUSH
4434: CALL_OW 265
4438: PUSH
4439: LD_EXP 60
4443: PPUSH
4444: CALL_OW 262
4448: PUSH
4449: LD_EXP 60
4453: PPUSH
4454: CALL_OW 263
4458: PUSH
4459: LD_EXP 60
4463: PPUSH
4464: CALL_OW 264
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PPUSH
4475: LD_STRING Masha
4477: PPUSH
4478: CALL_OW 39
// SaveCharacters ( Heike , Heike ) ;
4482: LD_EXP 11
4486: PPUSH
4487: LD_STRING Heike
4489: PPUSH
4490: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
4494: LD_EXP 9
4498: PPUSH
4499: LD_STRING Petrosyan
4501: PPUSH
4502: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4506: LD_EXP 23
4510: PPUSH
4511: LD_STRING Dolgov
4513: PPUSH
4514: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4518: LD_EXP 24
4522: PPUSH
4523: LD_STRING Xavier
4525: PPUSH
4526: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
4530: LD_EXP 1
4534: PPUSH
4535: LD_STRING Burlak
4537: PPUSH
4538: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
4542: LD_EXP 3
4546: PPUSH
4547: LD_STRING Belkov
4549: PPUSH
4550: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
4554: LD_EXP 4
4558: PPUSH
4559: LD_STRING Kirilenkova
4561: PPUSH
4562: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
4566: LD_EXP 5
4570: PPUSH
4571: LD_STRING Gnyevko
4573: PPUSH
4574: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4578: LD_EXP 6
4582: PPUSH
4583: LD_STRING Kapitsova
4585: PPUSH
4586: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
4590: LD_EXP 8
4594: PPUSH
4595: LD_STRING Gleb
4597: PPUSH
4598: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
4602: LD_EXP 10
4606: PPUSH
4607: LD_STRING Kuzmov
4609: PPUSH
4610: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
4614: LD_EXP 12
4618: PPUSH
4619: LD_STRING Kovalyuk
4621: PPUSH
4622: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
4626: LD_EXP 15
4630: PPUSH
4631: LD_STRING Scholtze
4633: PPUSH
4634: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
4638: LD_EXP 17
4642: PPUSH
4643: LD_STRING Karamazov
4645: PPUSH
4646: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
4650: LD_EXP 18
4654: PPUSH
4655: LD_STRING Titov
4657: PPUSH
4658: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4662: LD_EXP 19
4666: PPUSH
4667: LD_STRING Oblukov
4669: PPUSH
4670: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4674: LD_EXP 20
4678: PPUSH
4679: LD_STRING Kozlov
4681: PPUSH
4682: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
4686: LD_EXP 21
4690: PPUSH
4691: LD_STRING Petrovova
4693: PPUSH
4694: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
4698: LD_EXP 22
4702: PPUSH
4703: LD_STRING Lipshchin
4705: PPUSH
4706: CALL_OW 38
// SaveCharacters ( ( ( player_units union other ) diff [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) , survivors3 ) ;
4710: LD_EXP 26
4714: PUSH
4715: LD_EXP 25
4719: UNION
4720: PUSH
4721: LD_EXP 1
4725: PUSH
4726: LD_EXP 3
4730: PUSH
4731: LD_EXP 4
4735: PUSH
4736: LD_EXP 5
4740: PUSH
4741: LD_EXP 6
4745: PUSH
4746: LD_EXP 8
4750: PUSH
4751: LD_EXP 10
4755: PUSH
4756: LD_EXP 12
4760: PUSH
4761: LD_EXP 15
4765: PUSH
4766: LD_EXP 17
4770: PUSH
4771: LD_EXP 18
4775: PUSH
4776: LD_EXP 19
4780: PUSH
4781: LD_EXP 20
4785: PUSH
4786: LD_EXP 21
4790: PUSH
4791: LD_EXP 22
4795: PUSH
4796: LD_EXP 9
4800: PUSH
4801: LD_EXP 23
4805: PUSH
4806: LD_EXP 24
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: DIFF
4831: PPUSH
4832: LD_STRING survivors3
4834: PPUSH
4835: CALL_OW 38
// YouWin ;
4839: CALL_OW 103
// exit ;
4843: GO 4846
// end ; enable ;
4845: ENABLE
// end ; end_of_file
4846: PPOPN 11
4848: END
// export function D_Start ; begin
4849: LD_INT 0
4851: PPUSH
// DialogueOn ;
4852: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
4856: LD_EXP 2
4860: PPUSH
4861: LD_STRING DStart-Pop-1
4863: PPUSH
4864: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
4868: LD_EXP 1
4872: PPUSH
4873: LD_STRING DStart-Bur-1
4875: PPUSH
4876: CALL_OW 88
// Wait ( 0 0$2 ) ;
4880: LD_INT 70
4882: PPUSH
4883: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
4887: LD_STRING MStart
4889: PPUSH
4890: CALL_OW 337
// display_strings := [ #Ru08-1 , ( 3 + AvailableBuildings ) , #Ru08-2 , ( 0 + AvailableWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
4894: LD_ADDR_OWVAR 47
4898: PUSH
4899: LD_STRING #Ru08-1
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: LD_EXP 55
4909: PLUS
4910: PUSH
4911: LD_STRING #Ru08-2
4913: PUSH
4914: LD_INT 0
4916: PUSH
4917: LD_EXP 54
4921: PLUS
4922: PUSH
4923: LD_STRING #Ru08-3
4925: PUSH
4926: LD_INT 0
4928: PUSH
4929: LD_EXP 56
4933: PLUS
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: LIST
4940: LIST
4941: LIST
4942: ST_TO_ADDR
// DialogueOff ;
4943: CALL_OW 7
// end ;
4947: LD_VAR 0 1
4951: RET
// export function D_Heike ; begin
4952: LD_INT 0
4954: PPUSH
// Say ( Popov , DHeike-Pop-1 ) ;
4955: LD_EXP 2
4959: PPUSH
4960: LD_STRING DHeike-Pop-1
4962: PPUSH
4963: CALL_OW 88
// Wait ( 0 0$2 ) ;
4967: LD_INT 70
4969: PPUSH
4970: CALL_OW 67
// create_heike ;
4974: CALL 2575 0 0
// end ;
4978: LD_VAR 0 1
4982: RET
// export function D_HeikeKilled ; begin
4983: LD_INT 0
4985: PPUSH
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
4986: LD_EXP 11
4990: PPUSH
4991: LD_STRING DHeikeKilled-Hke-1
4993: PPUSH
4994: CALL_OW 91
// end ;
4998: LD_VAR 0 1
5002: RET
// export function D_MercHelp ; begin
5003: LD_INT 0
5005: PPUSH
// DialogueOn ;
5006: CALL_OW 6
// Say ( Kurt , DMercHelp-Kurt-1 ) ;
5010: LD_EXP 13
5014: PPUSH
5015: LD_STRING DMercHelp-Kurt-1
5017: PPUSH
5018: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-1 ) ;
5022: LD_EXP 1
5026: PPUSH
5027: LD_STRING DMercHelp-Bur-1
5029: PPUSH
5030: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-2 ) ;
5034: LD_EXP 13
5038: PPUSH
5039: LD_STRING DMercHelp-Kurt-2
5041: PPUSH
5042: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-2 ) ;
5046: LD_EXP 1
5050: PPUSH
5051: LD_STRING DMercHelp-Bur-2
5053: PPUSH
5054: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-3 ) ;
5058: LD_EXP 13
5062: PPUSH
5063: LD_STRING DMercHelp-Kurt-3
5065: PPUSH
5066: CALL_OW 88
// DialogueOff ;
5070: CALL_OW 7
// end ;
5074: LD_VAR 0 1
5078: RET
// export function D_QrMerc1 ; begin
5079: LD_INT 0
5081: PPUSH
// DialogueOn ;
5082: CALL_OW 6
// Say ( Burlak , DQrMerc#1-Bur-1 ) ;
5086: LD_EXP 1
5090: PPUSH
5091: LD_STRING DQrMerc#1-Bur-1
5093: PPUSH
5094: CALL_OW 88
// Say ( Kurt , DQrMerc#1-Kurt-1 ) ;
5098: LD_EXP 13
5102: PPUSH
5103: LD_STRING DQrMerc#1-Kurt-1
5105: PPUSH
5106: CALL_OW 88
// DialogueOff ;
5110: CALL_OW 7
// end ;
5114: LD_VAR 0 1
5118: RET
// export function D_QrMerc2 ; begin
5119: LD_INT 0
5121: PPUSH
// DialogueOn ;
5122: CALL_OW 6
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
5126: LD_EXP 1
5130: PPUSH
5131: LD_STRING DQrMerc#2-Bur-1
5133: PPUSH
5134: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
5138: LD_EXP 2
5142: PPUSH
5143: LD_STRING DQrMerc#2-Pop-1
5145: PPUSH
5146: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
5150: LD_EXP 1
5154: PPUSH
5155: LD_STRING DQrMerc#2-Bur-2
5157: PPUSH
5158: CALL_OW 88
// DialogueOff ;
5162: CALL_OW 7
// end ;
5166: LD_VAR 0 1
5170: RET
// export function D_QrMerc3 ; begin
5171: LD_INT 0
5173: PPUSH
// DialogueOn ;
5174: CALL_OW 6
// Say ( Burlak , DQrMerc#3-Bur-1 ) ;
5178: LD_EXP 1
5182: PPUSH
5183: LD_STRING DQrMerc#3-Bur-1
5185: PPUSH
5186: CALL_OW 88
// DialogueOff ;
5190: CALL_OW 7
// end ;
5194: LD_VAR 0 1
5198: RET
// export function D_MercRefuseBuild ; begin
5199: LD_INT 0
5201: PPUSH
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
5202: LD_EXP 13
5206: PPUSH
5207: LD_STRING DMercRefuseBuild-Kurt-1
5209: PPUSH
5210: CALL_OW 88
// end ;
5214: LD_VAR 0 1
5218: RET
// export function D_MercCompleted ; begin
5219: LD_INT 0
5221: PPUSH
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
5222: LD_EXP 13
5226: PPUSH
5227: LD_STRING DMercCompleted-Kurt-1
5229: PPUSH
5230: CALL_OW 88
// end ;
5234: LD_VAR 0 1
5238: RET
// export function D_MercPopov ; begin
5239: LD_INT 0
5241: PPUSH
// DialogueOn ;
5242: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
5246: LD_EXP 2
5250: PPUSH
5251: LD_STRING DMercPopov-Pop-1
5253: PPUSH
5254: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
5258: LD_EXP 1
5262: PPUSH
5263: LD_STRING DMercPopov-Bur-1
5265: PPUSH
5266: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
5270: LD_EXP 2
5274: PPUSH
5275: LD_STRING DMercPopov-Pop-2
5277: PPUSH
5278: CALL_OW 94
// DialogueOff ;
5282: CALL_OW 7
// end ;
5286: LD_VAR 0 1
5290: RET
// export function D_MercAmbush ; begin
5291: LD_INT 0
5293: PPUSH
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
5294: LD_EXP 13
5298: PPUSH
5299: LD_STRING DMercAmbush-Kurt-1
5301: PPUSH
5302: CALL_OW 88
// SetAttitude ( you , merc , att_enemy , true ) ;
5306: LD_EXP 31
5310: PPUSH
5311: LD_EXP 34
5315: PPUSH
5316: LD_INT 2
5318: PPUSH
5319: LD_INT 1
5321: PPUSH
5322: CALL_OW 80
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
5326: LD_INT 8
5328: PPUSH
5329: LD_INT 0
5331: PPUSH
5332: CALL_OW 424
// disable ( 20 ) ;
5336: LD_INT 20
5338: DISABLE_MARKED
// end ;
5339: LD_VAR 0 1
5343: RET
// export function D_MercAttack ; begin
5344: LD_INT 0
5346: PPUSH
// Say ( Kurt , DMercAttack-Kurt-1 ) ;
5347: LD_EXP 13
5351: PPUSH
5352: LD_STRING DMercAttack-Kurt-1
5354: PPUSH
5355: CALL_OW 88
// end ;
5359: LD_VAR 0 1
5363: RET
// export function D_MercDeceived ; begin
5364: LD_INT 0
5366: PPUSH
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
5367: LD_EXP 13
5371: PPUSH
5372: LD_STRING DMercDeceived-Kurt-1
5374: PPUSH
5375: CALL_OW 88
// end ;
5379: LD_VAR 0 1
5383: RET
// export function D_ArabianRequest ; begin
5384: LD_INT 0
5386: PPUSH
// DialogueOn ;
5387: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
5391: LD_EXP 7
5395: PPUSH
5396: LD_STRING DArabianRequest-Diet-1
5398: PPUSH
5399: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
5403: LD_EXP 1
5407: PPUSH
5408: LD_STRING DArabianRequest-Bur-1
5410: PPUSH
5411: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
5415: LD_EXP 7
5419: PPUSH
5420: LD_STRING DArabianRequest-Diet-2
5422: PPUSH
5423: CALL_OW 94
// case Query ( QHandOver ) of 1 :
5427: LD_STRING QHandOver
5429: PPUSH
5430: CALL_OW 97
5434: PUSH
5435: LD_INT 1
5437: DOUBLE
5438: EQUAL
5439: IFTRUE 5443
5441: GO 5458
5443: POP
// begin D_QrHandOver1 ;
5444: CALL 5491 0 0
// MercWillBeHandedOver := true ;
5448: LD_ADDR_EXP 41
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// end ; 2 :
5456: GO 5482
5458: LD_INT 2
5460: DOUBLE
5461: EQUAL
5462: IFTRUE 5466
5464: GO 5481
5466: POP
// begin MercHandedOver = false ;
5467: LD_ADDR_EXP 40
5471: PUSH
5472: LD_INT 0
5474: ST_TO_ADDR
// D_QrHandOver2 ;
5475: CALL 5535 0 0
// end ; end ;
5479: GO 5482
5481: POP
// DialogueOff ;
5482: CALL_OW 7
// end ;
5486: LD_VAR 0 1
5490: RET
// export function D_QrHandOver1 ; begin
5491: LD_INT 0
5493: PPUSH
// DialogueOn ;
5494: CALL_OW 6
// Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
5498: LD_EXP 1
5502: PPUSH
5503: LD_STRING DQrHandOver#1-Bur-1
5505: PPUSH
5506: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
5510: LD_EXP 7
5514: PPUSH
5515: LD_STRING DQrHandOver#1-Diet-1
5517: PPUSH
5518: CALL_OW 94
// DialogueOff ;
5522: CALL_OW 7
// hand_over ;
5526: CALL 8447 0 0
// end ;
5530: LD_VAR 0 1
5534: RET
// export function D_QrHandOver2 ; begin
5535: LD_INT 0
5537: PPUSH
// DialogueOn ;
5538: CALL_OW 6
// Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
5542: LD_EXP 1
5546: PPUSH
5547: LD_STRING DQrHandOver#2-Bur-1
5549: PPUSH
5550: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
5554: LD_EXP 7
5558: PPUSH
5559: LD_STRING DQrHandOver#2-Diet-1
5561: PPUSH
5562: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
5566: LD_EXP 1
5570: PPUSH
5571: LD_STRING DQrHandOver#2-Bur-2
5573: PPUSH
5574: CALL_OW 88
// DialogueOff ;
5578: CALL_OW 7
// end ;
5582: LD_VAR 0 1
5586: RET
// export function D_HandOverCome ; begin
5587: LD_INT 0
5589: PPUSH
// DialogueOn ;
5590: CALL_OW 6
// Say ( ASoldier1 , DHandOverCome-ASol1-1 ) ;
5594: LD_EXP 16
5598: PPUSH
5599: LD_STRING DHandOverCome-ASol1-1
5601: PPUSH
5602: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
5606: LD_EXP 13
5610: PPUSH
5611: LD_STRING DHandOverCome-Kurt-1
5613: PPUSH
5614: CALL_OW 88
// DialogueOff ;
5618: CALL_OW 7
// end ;
5622: LD_VAR 0 1
5626: RET
// export function D_HandOverSpoiled ; begin
5627: LD_INT 0
5629: PPUSH
// DialogueOn ;
5630: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
5634: LD_EXP 7
5638: PPUSH
5639: LD_STRING DHandOverSpoiled-Diet-1
5641: PPUSH
5642: CALL_OW 94
// DialogueOff ;
5646: CALL_OW 7
// end ;
5650: LD_VAR 0 1
5654: RET
// export function D_LegionFormed ; begin
5655: LD_INT 0
5657: PPUSH
// DialogueOn ;
5658: CALL_OW 6
// Say ( Heike , DLegionFormed-Hke-1 ) ;
5662: LD_EXP 11
5666: PPUSH
5667: LD_STRING DLegionFormed-Hke-1
5669: PPUSH
5670: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
5674: LD_EXP 1
5678: PPUSH
5679: LD_STRING DLegionFormed-Bur-1
5681: PPUSH
5682: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-2 ) ;
5686: LD_EXP 11
5690: PPUSH
5691: LD_STRING DLegionFormed-Hke-2
5693: PPUSH
5694: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
5698: LD_EXP 1
5702: PPUSH
5703: LD_STRING DLegionFormed-Bur-2
5705: PPUSH
5706: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-3 ) ;
5710: LD_EXP 11
5714: PPUSH
5715: LD_STRING DLegionFormed-Hke-3
5717: PPUSH
5718: CALL_OW 88
// DialogueOff ;
5722: CALL_OW 7
// end ;
5726: LD_VAR 0 1
5730: RET
// export function D_QrLegion1 ; begin
5731: LD_INT 0
5733: PPUSH
// DialogueOn ;
5734: CALL_OW 6
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
5738: LD_EXP 1
5742: PPUSH
5743: LD_STRING DQrLegion#1-Bur-1
5745: PPUSH
5746: CALL_OW 88
// DialogueOff ;
5750: CALL_OW 7
// end ;
5754: LD_VAR 0 1
5758: RET
// export function D_QrLegion2 ; begin
5759: LD_INT 0
5761: PPUSH
// DialogueOn ;
5762: CALL_OW 6
// Say ( Burlak , DQrLegion#2-Bur-1 ) ;
5766: LD_EXP 1
5770: PPUSH
5771: LD_STRING DQrLegion#2-Bur-1
5773: PPUSH
5774: CALL_OW 88
// DialogueOff ;
5778: CALL_OW 7
// end ;
5782: LD_VAR 0 1
5786: RET
// export function D_FiringRange ; begin
5787: LD_INT 0
5789: PPUSH
// DialogueOn ;
5790: CALL_OW 6
// if IsOK ( Kuzmov ) then
5794: LD_EXP 10
5798: PPUSH
5799: CALL_OW 302
5803: IFFALSE 5819
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
5805: LD_EXP 10
5809: PPUSH
5810: LD_STRING DFiringRange-Kuz-1
5812: PPUSH
5813: CALL_OW 88
5817: GO 5831
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
5819: LD_EXP 19
5823: PPUSH
5824: LD_STRING DFiringRange-Obl-1
5826: PPUSH
5827: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
5831: LD_EXP 1
5835: PPUSH
5836: LD_STRING DFiringRange-Bur-1
5838: PPUSH
5839: CALL_OW 88
// CenterOnXY ( 59 , 34 ) ;
5843: LD_INT 59
5845: PPUSH
5846: LD_INT 34
5848: PPUSH
5849: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
5853: LD_INT 18
5855: PPUSH
5856: CALL_OW 67
// RevealFogArea ( you , ShootArea ) ;
5860: LD_EXP 31
5864: PPUSH
5865: LD_INT 11
5867: PPUSH
5868: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
5872: LD_INT 11
5874: PPUSH
5875: LD_INT 1
5877: PPUSH
5878: CALL_OW 424
// if IsOK ( Kuzmov ) then
5882: LD_EXP 10
5886: PPUSH
5887: CALL_OW 302
5891: IFFALSE 5907
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
5893: LD_EXP 10
5897: PPUSH
5898: LD_STRING DFiringRange-Kuz-2
5900: PPUSH
5901: CALL_OW 88
5905: GO 5919
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
5907: LD_EXP 19
5911: PPUSH
5912: LD_STRING DFiringRange-Obl-2
5914: PPUSH
5915: CALL_OW 88
// DialogueOff ;
5919: CALL_OW 7
// end ;
5923: LD_VAR 0 1
5927: RET
// export function D_QrShootingGallery1 ; begin
5928: LD_INT 0
5930: PPUSH
// Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
5931: LD_EXP 1
5935: PPUSH
5936: LD_STRING DQrShootingGallery#1-Bur-1
5938: PPUSH
5939: CALL_OW 88
// end ;
5943: LD_VAR 0 1
5947: RET
// export function D_QrShootingGallery2 ; begin
5948: LD_INT 0
5950: PPUSH
// Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
5951: LD_EXP 1
5955: PPUSH
5956: LD_STRING DQrShootingGallery#2-Bur-1
5958: PPUSH
5959: CALL_OW 88
// end ;
5963: LD_VAR 0 1
5967: RET
// export function D_Hunting ; var allhunters ; begin
5968: LD_INT 0
5970: PPUSH
5971: PPUSH
// DialogueOn ;
5972: CALL_OW 6
// allhunters := [ ] ;
5976: LD_ADDR_VAR 0 2
5980: PUSH
5981: EMPTY
5982: ST_TO_ADDR
// if IsOK ( Belkov ) then
5983: LD_EXP 3
5987: PPUSH
5988: CALL_OW 302
5992: IFFALSE 6010
// allhunters := allhunters ^ Belkov ;
5994: LD_ADDR_VAR 0 2
5998: PUSH
5999: LD_VAR 0 2
6003: PUSH
6004: LD_EXP 3
6008: ADD
6009: ST_TO_ADDR
// if IsOK ( Karamazov ) then
6010: LD_EXP 17
6014: PPUSH
6015: CALL_OW 302
6019: IFFALSE 6037
// allhunters := allhunters ^ Karamazov ;
6021: LD_ADDR_VAR 0 2
6025: PUSH
6026: LD_VAR 0 2
6030: PUSH
6031: LD_EXP 17
6035: ADD
6036: ST_TO_ADDR
// if IsOK ( Kozlov ) then
6037: LD_EXP 20
6041: PPUSH
6042: CALL_OW 302
6046: IFFALSE 6064
// allhunters := allhunters ^ Kozlov ;
6048: LD_ADDR_VAR 0 2
6052: PUSH
6053: LD_VAR 0 2
6057: PUSH
6058: LD_EXP 20
6062: ADD
6063: ST_TO_ADDR
// Randomize ;
6064: CALL_OW 10
// RandomizeAll ;
6068: CALL_OW 11
// hunter := allhunters [ Rand ( 1 , ( allhunters + 0 ) ) ] ;
6072: LD_ADDR_EXP 72
6076: PUSH
6077: LD_VAR 0 2
6081: PUSH
6082: LD_INT 1
6084: PPUSH
6085: LD_VAR 0 2
6089: PUSH
6090: LD_INT 0
6092: PLUS
6093: PPUSH
6094: CALL_OW 12
6098: ARRAY
6099: ST_TO_ADDR
// case hunter of Belkov :
6100: LD_EXP 72
6104: PUSH
6105: LD_EXP 3
6109: DOUBLE
6110: EQUAL
6111: IFTRUE 6115
6113: GO 6130
6115: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
6116: LD_EXP 3
6120: PPUSH
6121: LD_STRING DHunting-Bel-1
6123: PPUSH
6124: CALL_OW 88
6128: GO 6181
6130: LD_EXP 17
6134: DOUBLE
6135: EQUAL
6136: IFTRUE 6140
6138: GO 6155
6140: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
6141: LD_EXP 17
6145: PPUSH
6146: LD_STRING DHunting-Kar-1
6148: PPUSH
6149: CALL_OW 88
6153: GO 6181
6155: LD_EXP 20
6159: DOUBLE
6160: EQUAL
6161: IFTRUE 6165
6163: GO 6180
6165: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
6166: LD_EXP 20
6170: PPUSH
6171: LD_STRING DHunting-Koz-1
6173: PPUSH
6174: CALL_OW 88
6178: GO 6181
6180: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
6181: LD_EXP 1
6185: PPUSH
6186: LD_STRING DHunting-Bur-1
6188: PPUSH
6189: CALL_OW 88
// case hunter of Belkov :
6193: LD_EXP 72
6197: PUSH
6198: LD_EXP 3
6202: DOUBLE
6203: EQUAL
6204: IFTRUE 6208
6206: GO 6223
6208: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
6209: LD_EXP 3
6213: PPUSH
6214: LD_STRING DHunting-Bel-2
6216: PPUSH
6217: CALL_OW 88
6221: GO 6274
6223: LD_EXP 17
6227: DOUBLE
6228: EQUAL
6229: IFTRUE 6233
6231: GO 6248
6233: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
6234: LD_EXP 17
6238: PPUSH
6239: LD_STRING DHunting-Kar-2
6241: PPUSH
6242: CALL_OW 88
6246: GO 6274
6248: LD_EXP 20
6252: DOUBLE
6253: EQUAL
6254: IFTRUE 6258
6256: GO 6273
6258: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
6259: LD_EXP 20
6263: PPUSH
6264: LD_STRING DHunting-Koz-2
6266: PPUSH
6267: CALL_OW 88
6271: GO 6274
6273: POP
// DialogueOff ;
6274: CALL_OW 7
// end ;
6278: LD_VAR 0 1
6282: RET
// export function D_QrHunting1 ; begin
6283: LD_INT 0
6285: PPUSH
// Say ( Burlak , DQrHunting#1-Bur-1 ) ;
6286: LD_EXP 1
6290: PPUSH
6291: LD_STRING DQrHunting#1-Bur-1
6293: PPUSH
6294: CALL_OW 88
// end ;
6298: LD_VAR 0 1
6302: RET
// export function D_QrHunting2 ; begin
6303: LD_INT 0
6305: PPUSH
// Say ( Burlak , DQrHunting#2-Bur-1 ) ;
6306: LD_EXP 1
6310: PPUSH
6311: LD_STRING DQrHunting#2-Bur-1
6313: PPUSH
6314: CALL_OW 88
// end ;
6318: LD_VAR 0 1
6322: RET
// export function D_FreeTime ; var pole ; begin
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
// DialogueOn ;
6327: CALL_OW 6
// Randomize ;
6331: CALL_OW 10
// RandomizeAll ;
6335: CALL_OW 11
// pole := [ ] ;
6339: LD_ADDR_VAR 0 2
6343: PUSH
6344: EMPTY
6345: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
6346: LD_EXP 6
6350: PPUSH
6351: CALL_OW 302
6355: IFFALSE 6373
// pole := pole ^ Kapitsova ;
6357: LD_ADDR_VAR 0 2
6361: PUSH
6362: LD_VAR 0 2
6366: PUSH
6367: LD_EXP 6
6371: ADD
6372: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Petrovova :
6373: LD_VAR 0 2
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 0
6383: PUSH
6384: LD_VAR 0 2
6388: PLUS
6389: PPUSH
6390: CALL_OW 12
6394: ARRAY
6395: PUSH
6396: LD_EXP 21
6400: DOUBLE
6401: EQUAL
6402: IFTRUE 6406
6404: GO 6431
6406: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
6407: LD_EXP 21
6411: PPUSH
6412: LD_STRING DFreeTime-Ptr-1
6414: PPUSH
6415: CALL_OW 88
// FreeWoman := Petrovova ;
6419: LD_ADDR_EXP 58
6423: PUSH
6424: LD_EXP 21
6428: ST_TO_ADDR
// end ; Kirilenkova :
6429: GO 6502
6431: LD_EXP 4
6435: DOUBLE
6436: EQUAL
6437: IFTRUE 6441
6439: GO 6466
6441: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
6442: LD_EXP 4
6446: PPUSH
6447: LD_STRING DFreeTime-Kir-1
6449: PPUSH
6450: CALL_OW 88
// FreeWoman := Kirilenkova ;
6454: LD_ADDR_EXP 58
6458: PUSH
6459: LD_EXP 4
6463: ST_TO_ADDR
// end ; Kapitsova :
6464: GO 6502
6466: LD_EXP 6
6470: DOUBLE
6471: EQUAL
6472: IFTRUE 6476
6474: GO 6501
6476: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
6477: LD_EXP 6
6481: PPUSH
6482: LD_STRING DFreeTime-Kap-1
6484: PPUSH
6485: CALL_OW 88
// FreeWoman := Kapitsova ;
6489: LD_ADDR_EXP 58
6493: PUSH
6494: LD_EXP 6
6498: ST_TO_ADDR
// end ; end ;
6499: GO 6502
6501: POP
// pole := [ ] ;
6502: LD_ADDR_VAR 0 2
6506: PUSH
6507: EMPTY
6508: ST_TO_ADDR
// if IsOK ( Kuzmov ) then
6509: LD_EXP 10
6513: PPUSH
6514: CALL_OW 302
6518: IFFALSE 6536
// pole := pole ^ Kuzmov ;
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: LD_VAR 0 2
6529: PUSH
6530: LD_EXP 10
6534: ADD
6535: ST_TO_ADDR
// if IsOK ( Titov ) then
6536: LD_EXP 18
6540: PPUSH
6541: CALL_OW 302
6545: IFFALSE 6563
// pole := pole ^ Titov ;
6547: LD_ADDR_VAR 0 2
6551: PUSH
6552: LD_VAR 0 2
6556: PUSH
6557: LD_EXP 18
6561: ADD
6562: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
6563: LD_EXP 5
6567: PPUSH
6568: CALL_OW 302
6572: IFFALSE 6590
// pole := pole ^ Gnyevko ;
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_VAR 0 2
6583: PUSH
6584: LD_EXP 5
6588: ADD
6589: ST_TO_ADDR
// if IsOK ( Oblukov ) then
6590: LD_EXP 19
6594: PPUSH
6595: CALL_OW 302
6599: IFFALSE 6617
// pole := pole ^ Oblukov ;
6601: LD_ADDR_VAR 0 2
6605: PUSH
6606: LD_VAR 0 2
6610: PUSH
6611: LD_EXP 19
6615: ADD
6616: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Kuzmov :
6617: LD_VAR 0 2
6621: PUSH
6622: LD_INT 1
6624: PPUSH
6625: LD_INT 0
6627: PUSH
6628: LD_VAR 0 2
6632: PLUS
6633: PPUSH
6634: CALL_OW 12
6638: ARRAY
6639: PUSH
6640: LD_EXP 10
6644: DOUBLE
6645: EQUAL
6646: IFTRUE 6650
6648: GO 6675
6650: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
6651: LD_EXP 10
6655: PPUSH
6656: LD_STRING DFreeTime-Kuz-1
6658: PPUSH
6659: CALL_OW 88
// FreeMan := Kuzmov ;
6663: LD_ADDR_EXP 57
6667: PUSH
6668: LD_EXP 10
6672: ST_TO_ADDR
// end ; Titov :
6673: GO 6781
6675: LD_EXP 18
6679: DOUBLE
6680: EQUAL
6681: IFTRUE 6685
6683: GO 6710
6685: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
6686: LD_EXP 18
6690: PPUSH
6691: LD_STRING DFreeTime-Tit-1
6693: PPUSH
6694: CALL_OW 88
// FreeMan := Titov ;
6698: LD_ADDR_EXP 57
6702: PUSH
6703: LD_EXP 18
6707: ST_TO_ADDR
// end ; Gnyevko :
6708: GO 6781
6710: LD_EXP 5
6714: DOUBLE
6715: EQUAL
6716: IFTRUE 6720
6718: GO 6745
6720: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
6721: LD_EXP 5
6725: PPUSH
6726: LD_STRING DFreeTime-Gny-1
6728: PPUSH
6729: CALL_OW 88
// FreeMan := Gnyevko ;
6733: LD_ADDR_EXP 57
6737: PUSH
6738: LD_EXP 5
6742: ST_TO_ADDR
// end ; Oblukov :
6743: GO 6781
6745: LD_EXP 19
6749: DOUBLE
6750: EQUAL
6751: IFTRUE 6755
6753: GO 6780
6755: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
6756: LD_EXP 19
6760: PPUSH
6761: LD_STRING DFreeTime-Obl-1
6763: PPUSH
6764: CALL_OW 88
// FreeMan := Oblukov ;
6768: LD_ADDR_EXP 57
6772: PUSH
6773: LD_EXP 19
6777: ST_TO_ADDR
// end ; end ;
6778: GO 6781
6780: POP
// DialogueOff ;
6781: CALL_OW 7
// end ;
6785: LD_VAR 0 1
6789: RET
// export function D_QrFreeTime1 ; begin
6790: LD_INT 0
6792: PPUSH
// Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
6793: LD_EXP 1
6797: PPUSH
6798: LD_STRING DQrFreeTime#1-Bur-1
6800: PPUSH
6801: CALL_OW 88
// end ;
6805: LD_VAR 0 1
6809: RET
// export function D_QrFreeTime2 ; begin
6810: LD_INT 0
6812: PPUSH
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ;
6813: LD_EXP 1
6817: PPUSH
6818: LD_STRING DQrFreeTime#2-Bur-1
6820: PPUSH
6821: CALL_OW 88
// end ;
6825: LD_VAR 0 1
6829: RET
// export function D_Masha ; begin
6830: LD_INT 0
6832: PPUSH
// DialogueOn ;
6833: CALL_OW 6
// Say ( Kozlov , DMasha-Koz-1 ) ;
6837: LD_EXP 20
6841: PPUSH
6842: LD_STRING DMasha-Koz-1
6844: PPUSH
6845: CALL_OW 88
// DialogueOff ;
6849: CALL_OW 7
// end ;
6853: LD_VAR 0 1
6857: RET
// export function D_Masha2 ; begin
6858: LD_INT 0
6860: PPUSH
// Say ( Burlak , DMasha2-Bur-1 ) ;
6861: LD_EXP 1
6865: PPUSH
6866: LD_STRING DMasha2-Bur-1
6868: PPUSH
6869: CALL_OW 88
// end ;
6873: LD_VAR 0 1
6877: RET
// export function D_AI ; begin
6878: LD_INT 0
6880: PPUSH
// DialogueOn ;
6881: CALL_OW 6
// if IsOK ( Scholtze ) then
6885: LD_EXP 15
6889: PPUSH
6890: CALL_OW 302
6894: IFFALSE 6910
// Say ( Scholtze , DAI-Sch-1 ) else
6896: LD_EXP 15
6900: PPUSH
6901: LD_STRING DAI-Sch-1
6903: PPUSH
6904: CALL_OW 88
6908: GO 6922
// Say ( Kapitsova , DAI-Kap-1 ) ;
6910: LD_EXP 6
6914: PPUSH
6915: LD_STRING DAI-Kap-1
6917: PPUSH
6918: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
6922: LD_EXP 1
6926: PPUSH
6927: LD_STRING DAI-Bur-1
6929: PPUSH
6930: CALL_OW 88
// if IsOK ( Scholtze ) then
6934: LD_EXP 15
6938: PPUSH
6939: CALL_OW 302
6943: IFFALSE 6959
// Say ( Scholtze , DAI-Sch-2 ) else
6945: LD_EXP 15
6949: PPUSH
6950: LD_STRING DAI-Sch-2
6952: PPUSH
6953: CALL_OW 88
6957: GO 6971
// Say ( Kapitsova , DAI-Kap-2 ) ;
6959: LD_EXP 6
6963: PPUSH
6964: LD_STRING DAI-Kap-2
6966: PPUSH
6967: CALL_OW 88
// DialogueOff ;
6971: CALL_OW 7
// end ;
6975: LD_VAR 0 1
6979: RET
// export function D_SpontTelep ; begin
6980: LD_INT 0
6982: PPUSH
// DialogueOn ;
6983: CALL_OW 6
// if IsOK ( Scholtze ) then
6987: LD_EXP 15
6991: PPUSH
6992: CALL_OW 302
6996: IFFALSE 7012
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
6998: LD_EXP 15
7002: PPUSH
7003: LD_STRING DSpontTelep-Sch-1
7005: PPUSH
7006: CALL_OW 88
7010: GO 7024
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
7012: LD_EXP 6
7016: PPUSH
7017: LD_STRING DSpontTelep-Kap-1
7019: PPUSH
7020: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
7024: LD_EXP 1
7028: PPUSH
7029: LD_STRING DSpontTelep-Bur-1
7031: PPUSH
7032: CALL_OW 88
// if IsOK ( Scholtze ) then
7036: LD_EXP 15
7040: PPUSH
7041: CALL_OW 302
7045: IFFALSE 7061
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
7047: LD_EXP 15
7051: PPUSH
7052: LD_STRING DSpontTelep-Sch-2
7054: PPUSH
7055: CALL_OW 88
7059: GO 7073
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
7061: LD_EXP 6
7065: PPUSH
7066: LD_STRING DSpontTelep-Kap-2
7068: PPUSH
7069: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
7073: LD_EXP 1
7077: PPUSH
7078: LD_STRING DSpontTelep-Bur-2
7080: PPUSH
7081: CALL_OW 88
// DialogueOff ;
7085: CALL_OW 7
// end ;
7089: LD_VAR 0 1
7093: RET
// export function D_AmAttackStart ; begin
7094: LD_INT 0
7096: PPUSH
// SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
7097: LD_EXP 2
7101: PPUSH
7102: LD_STRING DAmAttackStart-Pop-1
7104: PPUSH
7105: CALL_OW 94
// enable ( 50 ) ;
7109: LD_INT 50
7111: ENABLE_MARKED
// end ;
7112: LD_VAR 0 1
7116: RET
// every 0 0$1 marked 50 do
7117: GO 7119
7119: DISABLE
// begin Wait ( 0 0$10 ) ;
7120: LD_INT 350
7122: PPUSH
7123: CALL_OW 67
// if MercPaid then
7127: LD_EXP 39
7131: IFFALSE 7170
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
7133: LD_EXP 1
7137: PPUSH
7138: LD_STRING DAmAttackStart-Bur-1
7140: PPUSH
7141: CALL_OW 88
// if IsOK ( Gleb ) then
7145: LD_EXP 8
7149: PPUSH
7150: CALL_OW 302
7154: IFFALSE 7168
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
7156: LD_EXP 8
7160: PPUSH
7161: LD_STRING DAmAttackStart-Glb-1
7163: PPUSH
7164: CALL_OW 88
// end else
7168: GO 7182
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
7170: LD_EXP 1
7174: PPUSH
7175: LD_STRING DAmAttackStart-Bur-2
7177: PPUSH
7178: CALL_OW 88
// end ;
7182: END
// export function D_AmAttackFin ; var rnd , bool ; begin
7183: LD_INT 0
7185: PPUSH
7186: PPUSH
7187: PPUSH
// DialogueOn ;
7188: CALL_OW 6
// repeat rnd := Rand ( 1 , 7 ) ;
7192: LD_ADDR_VAR 0 2
7196: PUSH
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 7
7202: PPUSH
7203: CALL_OW 12
7207: ST_TO_ADDR
// case rnd of 1 :
7208: LD_VAR 0 2
7212: PUSH
7213: LD_INT 1
7215: DOUBLE
7216: EQUAL
7217: IFTRUE 7221
7219: GO 7253
7221: POP
// if IsOK ( Belkov ) then
7222: LD_EXP 3
7226: PPUSH
7227: CALL_OW 302
7231: IFFALSE 7251
// bool := Say ( Belkov , DAmAttackFin-Bel-1 ) ; 2 :
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_EXP 3
7242: PPUSH
7243: LD_STRING DAmAttackFin-Bel-1
7245: PPUSH
7246: CALL_OW 88
7250: ST_TO_ADDR
7251: GO 7494
7253: LD_INT 2
7255: DOUBLE
7256: EQUAL
7257: IFTRUE 7261
7259: GO 7293
7261: POP
// if IsOK ( Gnyevko ) then
7262: LD_EXP 5
7266: PPUSH
7267: CALL_OW 302
7271: IFFALSE 7291
// bool := Say ( Gnyevko , DAmAttackFin-Gny-1 ) ; 3 :
7273: LD_ADDR_VAR 0 3
7277: PUSH
7278: LD_EXP 5
7282: PPUSH
7283: LD_STRING DAmAttackFin-Gny-1
7285: PPUSH
7286: CALL_OW 88
7290: ST_TO_ADDR
7291: GO 7494
7293: LD_INT 3
7295: DOUBLE
7296: EQUAL
7297: IFTRUE 7301
7299: GO 7333
7301: POP
// if IsOK ( Titov ) then
7302: LD_EXP 18
7306: PPUSH
7307: CALL_OW 302
7311: IFFALSE 7331
// bool := Say ( Titov , DAmAttackFin-Tit-1 ) ; 4 :
7313: LD_ADDR_VAR 0 3
7317: PUSH
7318: LD_EXP 18
7322: PPUSH
7323: LD_STRING DAmAttackFin-Tit-1
7325: PPUSH
7326: CALL_OW 88
7330: ST_TO_ADDR
7331: GO 7494
7333: LD_INT 4
7335: DOUBLE
7336: EQUAL
7337: IFTRUE 7341
7339: GO 7373
7341: POP
// if IsOK ( Lipshchin ) then
7342: LD_EXP 22
7346: PPUSH
7347: CALL_OW 302
7351: IFFALSE 7371
// bool := Say ( Lipshchin , DAmAttackFin-Lip-1 ) ; 5 :
7353: LD_ADDR_VAR 0 3
7357: PUSH
7358: LD_EXP 22
7362: PPUSH
7363: LD_STRING DAmAttackFin-Lip-1
7365: PPUSH
7366: CALL_OW 88
7370: ST_TO_ADDR
7371: GO 7494
7373: LD_INT 5
7375: DOUBLE
7376: EQUAL
7377: IFTRUE 7381
7379: GO 7413
7381: POP
// if IsOK ( Karamazov ) then
7382: LD_EXP 17
7386: PPUSH
7387: CALL_OW 302
7391: IFFALSE 7411
// bool := Say ( Karamazov , DAmAttackFin-Kar-1 ) ; 6 :
7393: LD_ADDR_VAR 0 3
7397: PUSH
7398: LD_EXP 17
7402: PPUSH
7403: LD_STRING DAmAttackFin-Kar-1
7405: PPUSH
7406: CALL_OW 88
7410: ST_TO_ADDR
7411: GO 7494
7413: LD_INT 6
7415: DOUBLE
7416: EQUAL
7417: IFTRUE 7421
7419: GO 7453
7421: POP
// if IsOK ( Oblukov ) then
7422: LD_EXP 19
7426: PPUSH
7427: CALL_OW 302
7431: IFFALSE 7451
// bool := Say ( Oblukov , DAmAttackFin-Obl-1 ) ; 7 :
7433: LD_ADDR_VAR 0 3
7437: PUSH
7438: LD_EXP 19
7442: PPUSH
7443: LD_STRING DAmAttackFin-Obl-1
7445: PPUSH
7446: CALL_OW 88
7450: ST_TO_ADDR
7451: GO 7494
7453: LD_INT 7
7455: DOUBLE
7456: EQUAL
7457: IFTRUE 7461
7459: GO 7493
7461: POP
// if IsOK ( Burlak ) then
7462: LD_EXP 1
7466: PPUSH
7467: CALL_OW 302
7471: IFFALSE 7491
// bool := Say ( Burlak , DAmAttackFin-Bur-1 ) ; end ;
7473: LD_ADDR_VAR 0 3
7477: PUSH
7478: LD_EXP 1
7482: PPUSH
7483: LD_STRING DAmAttackFin-Bur-1
7485: PPUSH
7486: CALL_OW 88
7490: ST_TO_ADDR
7491: GO 7494
7493: POP
// until bool ;
7494: LD_VAR 0 3
7498: IFFALSE 7192
// Say ( Popov , DAmAttackFin-Pop-1 ) ;
7500: LD_EXP 2
7504: PPUSH
7505: LD_STRING DAmAttackFin-Pop-1
7507: PPUSH
7508: CALL_OW 88
// DialogueOff ;
7512: CALL_OW 7
// end ; end_of_file
7516: LD_VAR 0 1
7520: RET
// export function merc_help ; var rnd ; begin
7521: LD_INT 0
7523: PPUSH
7524: PPUSH
// rnd := Rand ( 2 2$0 , 3 3$0 ) ;
7525: LD_ADDR_VAR 0 2
7529: PUSH
7530: LD_INT 4200
7532: PPUSH
7533: LD_INT 6300
7535: PPUSH
7536: CALL_OW 12
7540: ST_TO_ADDR
// Wait ( rnd ) ;
7541: LD_VAR 0 2
7545: PPUSH
7546: CALL_OW 67
// if not HeikeKilled then
7550: LD_EXP 38
7554: NOT
7555: IFFALSE 7717
// begin D_MercHelp ;
7557: CALL 5003 0 0
// case Query ( QMerc ) of 1 :
7561: LD_STRING QMerc
7563: PPUSH
7564: CALL_OW 97
7568: PUSH
7569: LD_INT 1
7571: DOUBLE
7572: EQUAL
7573: IFTRUE 7577
7575: GO 7600
7577: POP
// begin D_QrMerc1 ;
7578: CALL 5079 0 0
// create_kurt ;
7582: CALL 3107 0 0
// MercAccepted := true ;
7586: LD_ADDR_EXP 44
7590: PUSH
7591: LD_INT 1
7593: ST_TO_ADDR
// come_to_build_barracks ;
7594: CALL 8190 0 0
// end ; 2 :
7598: GO 7709
7600: LD_INT 2
7602: DOUBLE
7603: EQUAL
7604: IFTRUE 7608
7606: GO 7639
7608: POP
// begin D_QrMerc2 ;
7609: CALL 5119 0 0
// PopovAsked := true ;
7613: LD_ADDR_EXP 46
7617: PUSH
7618: LD_INT 1
7620: ST_TO_ADDR
// create_kurt ;
7621: CALL 3107 0 0
// MercAccepted := true ;
7625: LD_ADDR_EXP 44
7629: PUSH
7630: LD_INT 1
7632: ST_TO_ADDR
// come_to_build_barracks ;
7633: CALL 8190 0 0
// end ; 3 :
7637: GO 7709
7639: LD_INT 3
7641: DOUBLE
7642: EQUAL
7643: IFTRUE 7647
7645: GO 7708
7647: POP
// begin D_QrMerc3 ;
7648: CALL 5171 0 0
// PopovAsked := true ;
7652: LD_ADDR_EXP 46
7656: PUSH
7657: LD_INT 1
7659: ST_TO_ADDR
// Wait ( 0 0$13 ) ;
7660: LD_INT 455
7662: PPUSH
7663: CALL_OW 67
// create_kurt ;
7667: CALL 3107 0 0
// ComMoveToArea ( [ Kurt , Mercenary1 ] , WaitHeikeArea ) ;
7671: LD_EXP 13
7675: PUSH
7676: LD_EXP 14
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PPUSH
7685: LD_INT 8
7687: PPUSH
7688: CALL_OW 113
// enable ( 6 ) ;
7692: LD_INT 6
7694: ENABLE_MARKED
// enable ( 20 ) ;
7695: LD_INT 20
7697: ENABLE_MARKED
// D_MercAttack ;
7698: CALL 5344 0 0
// merc_attack ;
7702: CALL 7722 0 0
// end ; end ;
7706: GO 7709
7708: POP
// MortarAsked := true ;
7709: LD_ADDR_EXP 69
7713: PUSH
7714: LD_INT 1
7716: ST_TO_ADDR
// end ; end ;
7717: LD_VAR 0 1
7721: RET
// export function merc_attack ; var grp , celkemgrp , rnd , pocet , mercenaries , filter ; begin
7722: LD_INT 0
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
7728: PPUSH
7729: PPUSH
7730: PPUSH
// repeat SetAttitude ( you , merc , att_enemy , true ) ;
7731: LD_EXP 31
7735: PPUSH
7736: LD_EXP 34
7740: PPUSH
7741: LD_INT 2
7743: PPUSH
7744: LD_INT 1
7746: PPUSH
7747: CALL_OW 80
// mercenaries := [ ] ;
7751: LD_ADDR_VAR 0 6
7755: PUSH
7756: EMPTY
7757: ST_TO_ADDR
// grp := Rand ( 1 , 6 ) ;
7758: LD_ADDR_VAR 0 2
7762: PUSH
7763: LD_INT 1
7765: PPUSH
7766: LD_INT 6
7768: PPUSH
7769: CALL_OW 12
7773: ST_TO_ADDR
// for pocet := 1 to grp do
7774: LD_ADDR_VAR 0 5
7778: PUSH
7779: DOUBLE
7780: LD_INT 1
7782: DEC
7783: ST_TO_ADDR
7784: LD_VAR 0 2
7788: PUSH
7789: FOR_TO
7790: IFFALSE 7913
// begin uc_side = merc ;
7792: LD_ADDR_OWVAR 20
7796: PUSH
7797: LD_EXP 34
7801: ST_TO_ADDR
// uc_nation := nation_arabian ;
7802: LD_ADDR_OWVAR 21
7806: PUSH
7807: LD_INT 2
7809: ST_TO_ADDR
// rnd := Rand ( 1 , 2 ) ;
7810: LD_ADDR_VAR 0 4
7814: PUSH
7815: LD_INT 1
7817: PPUSH
7818: LD_INT 2
7820: PPUSH
7821: CALL_OW 12
7825: ST_TO_ADDR
// case rnd of 1 :
7826: LD_VAR 0 4
7830: PUSH
7831: LD_INT 1
7833: DOUBLE
7834: EQUAL
7835: IFTRUE 7839
7837: GO 7855
7839: POP
// PrepareHuman ( sex_male , class_soldier , 2 ) ; 2 :
7840: LD_INT 1
7842: PPUSH
7843: LD_INT 1
7845: PPUSH
7846: LD_INT 2
7848: PPUSH
7849: CALL_OW 380
7853: GO 7880
7855: LD_INT 2
7857: DOUBLE
7858: EQUAL
7859: IFTRUE 7863
7861: GO 7879
7863: POP
// PrepareHuman ( sex_male , class_mortar , 2 ) ; end ;
7864: LD_INT 1
7866: PPUSH
7867: LD_INT 8
7869: PPUSH
7870: LD_INT 2
7872: PPUSH
7873: CALL_OW 380
7877: GO 7880
7879: POP
// hc_name :=  ;
7880: LD_ADDR_OWVAR 26
7884: PUSH
7885: LD_STRING 
7887: ST_TO_ADDR
// mercenaries := mercenaries ^ CreateHuman ;
7888: LD_ADDR_VAR 0 6
7892: PUSH
7893: LD_VAR 0 6
7897: PUSH
7898: CALL_OW 44
7902: ADD
7903: ST_TO_ADDR
// Wait ( 2 ) ;
7904: LD_INT 2
7906: PPUSH
7907: CALL_OW 67
// end ;
7911: GO 7789
7913: POP
7914: POP
// for pocet := 1 to grp do
7915: LD_ADDR_VAR 0 5
7919: PUSH
7920: DOUBLE
7921: LD_INT 1
7923: DEC
7924: ST_TO_ADDR
7925: LD_VAR 0 2
7929: PUSH
7930: FOR_TO
7931: IFFALSE 8008
// begin if HeikeDismissed then
7933: LD_EXP 45
7937: IFFALSE 7943
// exit ;
7939: POP
7940: POP
7941: GO 8185
// PlaceUnitArea ( mercenaries [ pocet ] , AttackArea , false ) ;
7943: LD_VAR 0 6
7947: PUSH
7948: LD_VAR 0 5
7952: ARRAY
7953: PPUSH
7954: LD_INT 5
7956: PPUSH
7957: LD_INT 0
7959: PPUSH
7960: CALL_OW 49
// ComAgressiveMove ( mercenaries [ pocet ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
7964: LD_VAR 0 6
7968: PUSH
7969: LD_VAR 0 5
7973: ARRAY
7974: PPUSH
7975: LD_EXP 1
7979: PPUSH
7980: CALL_OW 250
7984: PPUSH
7985: LD_EXP 1
7989: PPUSH
7990: CALL_OW 251
7994: PPUSH
7995: CALL_OW 114
// Wait ( 1 ) ;
7999: LD_INT 1
8001: PPUSH
8002: CALL_OW 67
// end ;
8006: GO 7930
8008: POP
8009: POP
// celkemgrp := celkemgrp + grp ;
8010: LD_ADDR_VAR 0 3
8014: PUSH
8015: LD_VAR 0 3
8019: PUSH
8020: LD_VAR 0 2
8024: PLUS
8025: ST_TO_ADDR
// Wait ( 1 1$0 ) ;
8026: LD_INT 2100
8028: PPUSH
8029: CALL_OW 67
// until HeikeSend or celkemgrp > pocetmercenaries ;
8033: LD_EXP 65
8037: PUSH
8038: LD_VAR 0 3
8042: PUSH
8043: LD_EXP 78
8047: GREATER
8048: OR
8049: IFFALSE 7731
// repeat Wait ( 0 0$1 ) ;
8051: LD_INT 35
8053: PPUSH
8054: CALL_OW 67
// until HeikeDismissed or celkemgrp > pocetmercenaries ;
8058: LD_EXP 45
8062: PUSH
8063: LD_VAR 0 3
8067: PUSH
8068: LD_EXP 78
8072: GREATER
8073: OR
8074: IFFALSE 8051
// if HeikeDismissed then
8076: LD_EXP 45
8080: IFFALSE 8185
// begin SetAttitude ( you , merc , att_friend , true ) ;
8082: LD_EXP 31
8086: PPUSH
8087: LD_EXP 34
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: LD_INT 1
8097: PPUSH
8098: CALL_OW 80
// filter := FilterAllUnits ( [ f_side , merc ] ) ;
8102: LD_ADDR_VAR 0 7
8106: PUSH
8107: LD_INT 22
8109: PUSH
8110: LD_EXP 34
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 69
8123: ST_TO_ADDR
// ComAgressiveMove ( filter , 29 , 57 ) ;
8124: LD_VAR 0 7
8128: PPUSH
8129: LD_INT 29
8131: PPUSH
8132: LD_INT 57
8134: PPUSH
8135: CALL_OW 114
// enable ( 5 ) ;
8139: LD_INT 5
8141: ENABLE_MARKED
// repeat Wait ( 0 0$3 ) ;
8142: LD_INT 105
8144: PPUSH
8145: CALL_OW 67
// ComAgressiveMove ( filter , 29 , 57 ) ;
8149: LD_VAR 0 7
8153: PPUSH
8154: LD_INT 29
8156: PPUSH
8157: LD_INT 57
8159: PPUSH
8160: CALL_OW 114
// until FilterAllUnits ( [ f_side , merc ] ) = [ ] ;
8164: LD_INT 22
8166: PUSH
8167: LD_EXP 34
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: PPUSH
8176: CALL_OW 69
8180: PUSH
8181: EMPTY
8182: EQUAL
8183: IFFALSE 8142
// end ; end ;
8185: LD_VAR 0 1
8189: RET
// function come_to_build_barracks ; var x , y , d , filter ; begin
8190: LD_INT 0
8192: PPUSH
8193: PPUSH
8194: PPUSH
8195: PPUSH
8196: PPUSH
// SetAttitude ( you , merc , att_neutral , true ) ;
8197: LD_EXP 31
8201: PPUSH
8202: LD_EXP 34
8206: PPUSH
8207: LD_INT 0
8209: PPUSH
8210: LD_INT 1
8212: PPUSH
8213: CALL_OW 80
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8217: LD_ADDR_VAR 0 5
8221: PUSH
8222: LD_INT 22
8224: PUSH
8225: LD_EXP 31
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 2
8236: PUSH
8237: LD_INT 30
8239: PUSH
8240: LD_INT 0
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: PUSH
8247: LD_INT 30
8249: PUSH
8250: LD_INT 1
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: LIST
8261: PUSH
8262: EMPTY
8263: LIST
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PPUSH
8269: CALL_OW 69
8273: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8274: LD_INT 0
8276: PUSH
8277: LD_VAR 0 5
8281: PLUS
8282: PUSH
8283: LD_INT 0
8285: NONEQUAL
8286: IFFALSE 8347
// begin x := GetX ( filter [ 1 ] ) ;
8288: LD_ADDR_VAR 0 2
8292: PUSH
8293: LD_VAR 0 5
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 250
8306: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8307: LD_ADDR_VAR 0 3
8311: PUSH
8312: LD_VAR 0 5
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: CALL_OW 251
8325: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8326: LD_ADDR_VAR 0 4
8330: PUSH
8331: LD_VAR 0 5
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: CALL_OW 254
8344: ST_TO_ADDR
// end else
8345: GO 8385
// begin x := GetX ( Burlak ) ;
8347: LD_ADDR_VAR 0 2
8351: PUSH
8352: LD_EXP 1
8356: PPUSH
8357: CALL_OW 250
8361: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8362: LD_ADDR_VAR 0 3
8366: PUSH
8367: LD_EXP 1
8371: PPUSH
8372: CALL_OW 251
8376: ST_TO_ADDR
// d := 1 ;
8377: LD_ADDR_VAR 0 4
8381: PUSH
8382: LD_INT 1
8384: ST_TO_ADDR
// end ; ComMoveXY ( [ Kurt , Mercenary1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8385: LD_EXP 13
8389: PUSH
8390: LD_EXP 14
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: LD_VAR 0 2
8403: PPUSH
8404: LD_VAR 0 4
8408: PPUSH
8409: LD_INT 5
8411: PPUSH
8412: CALL_OW 272
8416: PPUSH
8417: LD_VAR 0 3
8421: PPUSH
8422: LD_VAR 0 4
8426: PPUSH
8427: LD_INT 5
8429: PPUSH
8430: CALL_OW 273
8434: PPUSH
8435: CALL_OW 111
// enable ( 1 ) ;
8439: LD_INT 1
8441: ENABLE_MARKED
// end ;
8442: LD_VAR 0 1
8446: RET
// export function hand_over ; var i , filter , auto , x , y , d ; begin
8447: LD_INT 0
8449: PPUSH
8450: PPUSH
8451: PPUSH
8452: PPUSH
8453: PPUSH
8454: PPUSH
8455: PPUSH
// SetAttitude ( arab , merc , att_enemy , true ) ;
8456: LD_EXP 33
8460: PPUSH
8461: LD_EXP 34
8465: PPUSH
8466: LD_INT 2
8468: PPUSH
8469: LD_INT 1
8471: PPUSH
8472: CALL_OW 80
// SetAttitude ( arab , you , att_friend , true ) ;
8476: LD_EXP 33
8480: PPUSH
8481: LD_EXP 31
8485: PPUSH
8486: LD_INT 1
8488: PPUSH
8489: LD_INT 1
8491: PPUSH
8492: CALL_OW 80
// auto := [ ] ;
8496: LD_ADDR_VAR 0 4
8500: PUSH
8501: EMPTY
8502: ST_TO_ADDR
// ar_human := [ ] ;
8503: LD_ADDR_EXP 80
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8510: LD_ADDR_VAR 0 3
8514: PUSH
8515: LD_INT 22
8517: PUSH
8518: LD_EXP 31
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: PUSH
8527: LD_INT 2
8529: PUSH
8530: LD_INT 30
8532: PUSH
8533: LD_INT 0
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: PUSH
8540: LD_INT 30
8542: PUSH
8543: LD_INT 1
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: PUSH
8555: EMPTY
8556: LIST
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 69
8566: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8567: LD_INT 0
8569: PUSH
8570: LD_VAR 0 3
8574: PLUS
8575: PUSH
8576: LD_INT 0
8578: NONEQUAL
8579: IFFALSE 8640
// begin x := GetX ( filter [ 1 ] ) ;
8581: LD_ADDR_VAR 0 5
8585: PUSH
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 1
8593: ARRAY
8594: PPUSH
8595: CALL_OW 250
8599: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8600: LD_ADDR_VAR 0 6
8604: PUSH
8605: LD_VAR 0 3
8609: PUSH
8610: LD_INT 1
8612: ARRAY
8613: PPUSH
8614: CALL_OW 251
8618: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8619: LD_ADDR_VAR 0 7
8623: PUSH
8624: LD_VAR 0 3
8628: PUSH
8629: LD_INT 1
8631: ARRAY
8632: PPUSH
8633: CALL_OW 254
8637: ST_TO_ADDR
// end else
8638: GO 8678
// begin x := GetX ( Burlak ) ;
8640: LD_ADDR_VAR 0 5
8644: PUSH
8645: LD_EXP 1
8649: PPUSH
8650: CALL_OW 250
8654: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: LD_EXP 1
8664: PPUSH
8665: CALL_OW 251
8669: ST_TO_ADDR
// d := 1 ;
8670: LD_ADDR_VAR 0 7
8674: PUSH
8675: LD_INT 1
8677: ST_TO_ADDR
// end ; enable ( 7 ) ;
8678: LD_INT 7
8680: ENABLE_MARKED
// for i := 1 to 3 do
8681: LD_ADDR_VAR 0 2
8685: PUSH
8686: DOUBLE
8687: LD_INT 1
8689: DEC
8690: ST_TO_ADDR
8691: LD_INT 3
8693: PUSH
8694: FOR_TO
8695: IFFALSE 9260
// begin uc_side := arab ;
8697: LD_ADDR_OWVAR 20
8701: PUSH
8702: LD_EXP 33
8706: ST_TO_ADDR
// uc_nation := nation_arabian ;
8707: LD_ADDR_OWVAR 21
8711: PUSH
8712: LD_INT 2
8714: ST_TO_ADDR
// uc_direction := 3 ;
8715: LD_ADDR_OWVAR 24
8719: PUSH
8720: LD_INT 3
8722: ST_TO_ADDR
// if i <= 2 then
8723: LD_VAR 0 2
8727: PUSH
8728: LD_INT 2
8730: LESSEQUAL
8731: IFFALSE 8748
// PrepareHuman ( sex_male , class_soldier , 7 ) else
8733: LD_INT 1
8735: PPUSH
8736: LD_INT 1
8738: PPUSH
8739: LD_INT 7
8741: PPUSH
8742: CALL_OW 380
8746: GO 8761
// PrepareHuman ( sex_male , class_scientistic , 7 ) ;
8748: LD_INT 1
8750: PPUSH
8751: LD_INT 4
8753: PPUSH
8754: LD_INT 7
8756: PPUSH
8757: CALL_OW 380
// Wait ( 1 ) ;
8761: LD_INT 1
8763: PPUSH
8764: CALL_OW 67
// hc_name :=  ;
8768: LD_ADDR_OWVAR 26
8772: PUSH
8773: LD_STRING 
8775: ST_TO_ADDR
// ar_human := ar_human ^ CreateHuman ;
8776: LD_ADDR_EXP 80
8780: PUSH
8781: LD_EXP 80
8785: PUSH
8786: CALL_OW 44
8790: ADD
8791: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
8792: LD_ADDR_OWVAR 37
8796: PUSH
8797: LD_INT 13
8799: ST_TO_ADDR
// vc_engine := engine_combustion ;
8800: LD_ADDR_OWVAR 39
8804: PUSH
8805: LD_INT 1
8807: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
8808: LD_ADDR_OWVAR 40
8812: PUSH
8813: LD_INT 32
8815: ST_TO_ADDR
// vc_control := control_manual ;
8816: LD_ADDR_OWVAR 38
8820: PUSH
8821: LD_INT 1
8823: ST_TO_ADDR
// auto := auto ^ CreateVehicle ;
8824: LD_ADDR_VAR 0 4
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: CALL_OW 45
8838: ADD
8839: ST_TO_ADDR
// PlaceHumanInUnit ( ar_human [ i ] , auto [ i ] ) ;
8840: LD_EXP 80
8844: PUSH
8845: LD_VAR 0 2
8849: ARRAY
8850: PPUSH
8851: LD_VAR 0 4
8855: PUSH
8856: LD_VAR 0 2
8860: ARRAY
8861: PPUSH
8862: CALL_OW 52
// PlaceUnitArea ( auto [ i ] , HandOverEnterArea , false ) ;
8866: LD_VAR 0 4
8870: PUSH
8871: LD_VAR 0 2
8875: ARRAY
8876: PPUSH
8877: LD_INT 6
8879: PPUSH
8880: LD_INT 0
8882: PPUSH
8883: CALL_OW 49
// enable ( 6 ) ;
8887: LD_INT 6
8889: ENABLE_MARKED
// case i of 1 :
8890: LD_VAR 0 2
8894: PUSH
8895: LD_INT 1
8897: DOUBLE
8898: EQUAL
8899: IFTRUE 8903
8901: GO 8994
8903: POP
// begin SetCargo ( auto [ 1 ] , mat_cans , 100 ) ;
8904: LD_VAR 0 4
8908: PUSH
8909: LD_INT 1
8911: ARRAY
8912: PPUSH
8913: LD_INT 1
8915: PPUSH
8916: LD_INT 100
8918: PPUSH
8919: CALL_OW 290
// ComMoveXY ( auto [ 1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8923: LD_VAR 0 4
8927: PUSH
8928: LD_INT 1
8930: ARRAY
8931: PPUSH
8932: LD_VAR 0 5
8936: PPUSH
8937: LD_VAR 0 7
8941: PPUSH
8942: LD_INT 5
8944: PPUSH
8945: CALL_OW 272
8949: PPUSH
8950: LD_VAR 0 6
8954: PPUSH
8955: LD_VAR 0 7
8959: PPUSH
8960: LD_INT 5
8962: PPUSH
8963: CALL_OW 273
8967: PPUSH
8968: CALL_OW 111
// Wait ( 1 ) ;
8972: LD_INT 1
8974: PPUSH
8975: CALL_OW 67
// AddComExitVehicle ( auto [ 1 ] ) ;
8979: LD_VAR 0 4
8983: PUSH
8984: LD_INT 1
8986: ARRAY
8987: PPUSH
8988: CALL_OW 181
// end ; 2 :
8992: GO 9251
8994: LD_INT 2
8996: DOUBLE
8997: EQUAL
8998: IFTRUE 9002
9000: GO 9122
9002: POP
// begin SetCargo ( auto [ 2 ] , mat_oil , 100 ) ;
9003: LD_VAR 0 4
9007: PUSH
9008: LD_INT 2
9010: ARRAY
9011: PPUSH
9012: LD_INT 2
9014: PPUSH
9015: LD_INT 100
9017: PPUSH
9018: CALL_OW 290
// ComMoveXY ( auto [ 2 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9022: LD_VAR 0 4
9026: PUSH
9027: LD_INT 2
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PPUSH
9036: LD_VAR 0 7
9040: PPUSH
9041: LD_INT 5
9043: PPUSH
9044: CALL_OW 272
9048: PPUSH
9049: LD_VAR 0 6
9053: PPUSH
9054: LD_VAR 0 7
9058: PPUSH
9059: LD_INT 5
9061: PPUSH
9062: CALL_OW 273
9066: PPUSH
9067: CALL_OW 111
// Wait ( 1 ) ;
9071: LD_INT 1
9073: PPUSH
9074: CALL_OW 67
// AddComExitVehicle ( auto [ 2 ] ) ;
9078: LD_VAR 0 4
9082: PUSH
9083: LD_INT 2
9085: ARRAY
9086: PPUSH
9087: CALL_OW 181
// Wait ( 1 ) ;
9091: LD_INT 1
9093: PPUSH
9094: CALL_OW 67
// AddComMoveUnit ( auto [ 2 ] , auto [ 1 ] ) ;
9098: LD_VAR 0 4
9102: PUSH
9103: LD_INT 2
9105: ARRAY
9106: PPUSH
9107: LD_VAR 0 4
9111: PUSH
9112: LD_INT 1
9114: ARRAY
9115: PPUSH
9116: CALL_OW 172
// end ; 3 :
9120: GO 9251
9122: LD_INT 3
9124: DOUBLE
9125: EQUAL
9126: IFTRUE 9130
9128: GO 9250
9130: POP
// begin SetCargo ( auto [ 3 ] , mat_siberit , 100 ) ;
9131: LD_VAR 0 4
9135: PUSH
9136: LD_INT 3
9138: ARRAY
9139: PPUSH
9140: LD_INT 3
9142: PPUSH
9143: LD_INT 100
9145: PPUSH
9146: CALL_OW 290
// ComMoveXY ( auto [ 3 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9150: LD_VAR 0 4
9154: PUSH
9155: LD_INT 3
9157: ARRAY
9158: PPUSH
9159: LD_VAR 0 5
9163: PPUSH
9164: LD_VAR 0 7
9168: PPUSH
9169: LD_INT 5
9171: PPUSH
9172: CALL_OW 272
9176: PPUSH
9177: LD_VAR 0 6
9181: PPUSH
9182: LD_VAR 0 7
9186: PPUSH
9187: LD_INT 5
9189: PPUSH
9190: CALL_OW 273
9194: PPUSH
9195: CALL_OW 111
// Wait ( 1 ) ;
9199: LD_INT 1
9201: PPUSH
9202: CALL_OW 67
// AddComExitVehicle ( auto [ 3 ] ) ;
9206: LD_VAR 0 4
9210: PUSH
9211: LD_INT 3
9213: ARRAY
9214: PPUSH
9215: CALL_OW 181
// Wait ( 1 ) ;
9219: LD_INT 1
9221: PPUSH
9222: CALL_OW 67
// AddComMoveUnit ( auto [ 3 ] , auto [ 1 ] ) ;
9226: LD_VAR 0 4
9230: PUSH
9231: LD_INT 3
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 4
9239: PUSH
9240: LD_INT 1
9242: ARRAY
9243: PPUSH
9244: CALL_OW 172
// end ; end ;
9248: GO 9251
9250: POP
// Wait ( 0 0$3 ) ;
9251: LD_INT 105
9253: PPUSH
9254: CALL_OW 67
// end ;
9258: GO 8694
9260: POP
9261: POP
// MercHandoverArabsSpawned = true ;
9262: LD_ADDR_EXP 43
9266: PUSH
9267: LD_INT 1
9269: ST_TO_ADDR
// enable ( 9 ) ;
9270: LD_INT 9
9272: ENABLE_MARKED
// end ;
9273: LD_VAR 0 1
9277: RET
// every 0 0$1 + 0 0$0.5 do var filter ;
9278: GO 9280
9280: DISABLE
9281: LD_INT 0
9283: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_INT 22
9291: PUSH
9292: LD_EXP 31
9296: PUSH
9297: EMPTY
9298: LIST
9299: LIST
9300: PUSH
9301: LD_INT 2
9303: PUSH
9304: LD_INT 30
9306: PUSH
9307: LD_INT 0
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 30
9316: PUSH
9317: LD_INT 1
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: LIST
9328: PUSH
9329: EMPTY
9330: LIST
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL_OW 69
9340: ST_TO_ADDR
// if filter then
9341: LD_VAR 0 1
9345: IFFALSE 9359
// SetBName ( filter , trockij ) ;
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_STRING trockij
9354: PPUSH
9355: CALL_OW 500
// enable ;
9359: ENABLE
// end ;
9360: PPOPN 1
9362: END
// var crates_amount , crates_creating ; every 1 1$30 do
9363: GO 9365
9365: DISABLE
// begin crates_amount := GetResourceArea ( TreesArea , mat_cans ) ;
9366: LD_ADDR_LOC 1
9370: PUSH
9371: LD_INT 1
9373: PPUSH
9374: LD_INT 1
9376: PPUSH
9377: CALL_OW 287
9381: ST_TO_ADDR
// if crates_amount >= 80 then
9382: LD_LOC 1
9386: PUSH
9387: LD_INT 80
9389: GREATEREQUAL
9390: IFFALSE 9400
// crates_creating := false ;
9392: LD_ADDR_LOC 2
9396: PUSH
9397: LD_INT 0
9399: ST_TO_ADDR
// if crates_amount <= 30 then
9400: LD_LOC 1
9404: PUSH
9405: LD_INT 30
9407: LESSEQUAL
9408: IFFALSE 9418
// crates_creating := true ;
9410: LD_ADDR_LOC 2
9414: PUSH
9415: LD_INT 1
9417: ST_TO_ADDR
// if crates_creating then
9418: LD_LOC 2
9422: IFFALSE 9445
// CreateCratesArea ( Rand ( 3 , 5 ) , TreesArea , true ) ;
9424: LD_INT 3
9426: PPUSH
9427: LD_INT 5
9429: PPUSH
9430: CALL_OW 12
9434: PPUSH
9435: LD_INT 1
9437: PPUSH
9438: LD_INT 1
9440: PPUSH
9441: CALL_OW 55
// enable ;
9445: ENABLE
// end ;
9446: END
// var NonBuildBuildings , NonBuildWeapons ; every 0 0$3 do var filter , filter_tur , un , filter_weap , budova , NonBuild ;
9447: GO 9449
9449: DISABLE
9450: LD_INT 0
9452: PPUSH
9453: PPUSH
9454: PPUSH
9455: PPUSH
9456: PPUSH
9457: PPUSH
// begin NonBuild := AvailableBuildings ;
9458: LD_ADDR_VAR 0 6
9462: PUSH
9463: LD_EXP 55
9467: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] , [ f_ready ] ] ) ;
9468: LD_ADDR_VAR 0 1
9472: PUSH
9473: LD_INT 21
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 22
9485: PUSH
9486: LD_EXP 31
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PUSH
9495: LD_INT 53
9497: PUSH
9498: EMPTY
9499: LIST
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: LIST
9505: PPUSH
9506: CALL_OW 69
9510: ST_TO_ADDR
// TurretsDone := false ;
9511: LD_ADDR_EXP 49
9515: PUSH
9516: LD_INT 0
9518: ST_TO_ADDR
// filter_tur := FilterAllUnits ( [ [ f_btype , b_turret ] , [ f_side , you ] , [ f_ready ] ] ) ;
9519: LD_ADDR_VAR 0 2
9523: PUSH
9524: LD_INT 30
9526: PUSH
9527: LD_INT 33
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 22
9536: PUSH
9537: LD_EXP 31
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: PUSH
9546: LD_INT 53
9548: PUSH
9549: EMPTY
9550: LIST
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: PPUSH
9557: CALL_OW 69
9561: ST_TO_ADDR
// filter_weap := [ ] ;
9562: LD_ADDR_VAR 0 4
9566: PUSH
9567: EMPTY
9568: ST_TO_ADDR
// for un in filter_tur do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: LD_VAR 0 2
9578: PUSH
9579: FOR_IN
9580: IFFALSE 9612
// begin filter_weap := filter_weap union GetBWeapon ( un ) ;
9582: LD_ADDR_VAR 0 4
9586: PUSH
9587: LD_VAR 0 4
9591: PUSH
9592: LD_VAR 0 3
9596: PPUSH
9597: CALL_OW 269
9601: UNION
9602: ST_TO_ADDR
// Wait ( 2 ) ;
9603: LD_INT 2
9605: PPUSH
9606: CALL_OW 67
// end ;
9610: GO 9579
9612: POP
9613: POP
// if ( filter_weap diff 0 ) >= 3 then
9614: LD_VAR 0 4
9618: PUSH
9619: LD_INT 0
9621: DIFF
9622: PUSH
9623: LD_INT 3
9625: GREATEREQUAL
9626: IFFALSE 9636
// TurretsDone := true ;
9628: LD_ADDR_EXP 49
9632: PUSH
9633: LD_INT 1
9635: ST_TO_ADDR
// for budova in filter do
9636: LD_ADDR_VAR 0 5
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: FOR_IN
9647: IFFALSE 9679
// begin NonBuild := NonBuild diff GetBType ( budova ) ;
9649: LD_ADDR_VAR 0 6
9653: PUSH
9654: LD_VAR 0 6
9658: PUSH
9659: LD_VAR 0 5
9663: PPUSH
9664: CALL_OW 266
9668: DIFF
9669: ST_TO_ADDR
// Wait ( 1 ) ;
9670: LD_INT 1
9672: PPUSH
9673: CALL_OW 67
// end ;
9677: GO 9646
9679: POP
9680: POP
// if NonBuild = [ ] and TurretsDone and not BuildingsDone then
9681: LD_VAR 0 6
9685: PUSH
9686: EMPTY
9687: EQUAL
9688: PUSH
9689: LD_EXP 49
9693: AND
9694: PUSH
9695: LD_EXP 48
9699: NOT
9700: AND
9701: IFFALSE 9720
// begin ChangeMissionObjectives ( MBuildingsDone ) ;
9703: LD_STRING MBuildingsDone
9705: PPUSH
9706: CALL_OW 337
// BuildingsDone := true ;
9710: LD_ADDR_EXP 48
9714: PUSH
9715: LD_INT 1
9717: ST_TO_ADDR
// end else
9718: GO 9757
// if ( NonBuild <> [ ] or not TurretsDone ) and BuildingsDone then
9720: LD_VAR 0 6
9724: PUSH
9725: EMPTY
9726: NONEQUAL
9727: PUSH
9728: LD_EXP 49
9732: NOT
9733: OR
9734: PUSH
9735: LD_EXP 48
9739: AND
9740: IFFALSE 9757
// begin ChangeMissionObjectives ( MBuildings ) ;
9742: LD_STRING MBuildings
9744: PPUSH
9745: CALL_OW 337
// BuildingsDone := false ;
9749: LD_ADDR_EXP 48
9753: PUSH
9754: LD_INT 0
9756: ST_TO_ADDR
// end ; if not ( ( filter_weap diff 0 ) > 3 ) then
9757: LD_VAR 0 4
9761: PUSH
9762: LD_INT 0
9764: DIFF
9765: PUSH
9766: LD_INT 3
9768: GREATER
9769: NOT
9770: IFFALSE 9796
// NonBuild := NonBuild + 3 - ( filter_weap diff 0 ) ;
9772: LD_ADDR_VAR 0 6
9776: PUSH
9777: LD_VAR 0 6
9781: PUSH
9782: LD_INT 3
9784: PLUS
9785: PUSH
9786: LD_VAR 0 4
9790: PUSH
9791: LD_INT 0
9793: DIFF
9794: MINUS
9795: ST_TO_ADDR
// NonBuildBuildings := NonBuild ;
9796: LD_ADDR_LOC 3
9800: PUSH
9801: LD_VAR 0 6
9805: ST_TO_ADDR
// if HeikeCratesTime then
9806: LD_LOC 5
9810: IFFALSE 9873
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
9812: LD_ADDR_OWVAR 47
9816: PUSH
9817: LD_STRING #Ru08-1
9819: PUSH
9820: LD_INT 0
9822: PUSH
9823: LD_LOC 3
9827: PLUS
9828: PUSH
9829: LD_STRING #Ru08-2
9831: PUSH
9832: LD_INT 0
9834: PUSH
9835: LD_LOC 4
9839: PLUS
9840: PUSH
9841: LD_STRING #Ru08-3
9843: PUSH
9844: LD_INT 0
9846: PUSH
9847: LD_EXP 56
9851: PLUS
9852: PUSH
9853: LD_STRING #Ru08-4
9855: PUSH
9856: LD_LOC 5
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: ST_TO_ADDR
9871: GO 9922
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
9873: LD_ADDR_OWVAR 47
9877: PUSH
9878: LD_STRING #Ru08-1
9880: PUSH
9881: LD_INT 0
9883: PUSH
9884: LD_LOC 3
9888: PLUS
9889: PUSH
9890: LD_STRING #Ru08-2
9892: PUSH
9893: LD_INT 0
9895: PUSH
9896: LD_LOC 4
9900: PLUS
9901: PUSH
9902: LD_STRING #Ru08-3
9904: PUSH
9905: LD_INT 0
9907: PUSH
9908: LD_EXP 56
9912: PLUS
9913: PUSH
9914: EMPTY
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: ST_TO_ADDR
// if NonBuild + 0 = 11 and not GalleryAsked then
9922: LD_VAR 0 6
9926: PUSH
9927: LD_INT 0
9929: PLUS
9930: PUSH
9931: LD_INT 11
9933: EQUAL
9934: PUSH
9935: LD_EXP 66
9939: NOT
9940: AND
9941: IFFALSE 9946
// enable ( 201 ) ;
9943: LD_INT 201
9945: ENABLE_MARKED
// if NonBuild + 0 = 7 and not HuntingAsked then
9946: LD_VAR 0 6
9950: PUSH
9951: LD_INT 0
9953: PLUS
9954: PUSH
9955: LD_INT 7
9957: EQUAL
9958: PUSH
9959: LD_EXP 67
9963: NOT
9964: AND
9965: IFFALSE 9970
// enable ( 101 ) ;
9967: LD_INT 101
9969: ENABLE_MARKED
// if NonBuild + 0 = 3 and not FreetimeAsked then
9970: LD_VAR 0 6
9974: PUSH
9975: LD_INT 0
9977: PLUS
9978: PUSH
9979: LD_INT 3
9981: EQUAL
9982: PUSH
9983: LD_EXP 68
9987: NOT
9988: AND
9989: IFFALSE 9994
// enable ( 301 ) ;
9991: LD_INT 301
9993: ENABLE_MARKED
// enable ;
9994: ENABLE
// end ;
9995: PPOPN 6
9997: END
// every 0 0$3 + 0 0$0.5 do var filter , veh , NonBuild ;
9998: GO 10000
10000: DISABLE
10001: LD_INT 0
10003: PPUSH
10004: PPUSH
10005: PPUSH
// begin NonBuild := AvailableWeapons ;
10006: LD_ADDR_VAR 0 3
10010: PUSH
10011: LD_EXP 54
10015: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10016: LD_ADDR_VAR 0 1
10020: PUSH
10021: LD_INT 21
10023: PUSH
10024: LD_INT 2
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_EXP 31
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 69
10051: ST_TO_ADDR
// for veh in filter do
10052: LD_ADDR_VAR 0 2
10056: PUSH
10057: LD_VAR 0 1
10061: PUSH
10062: FOR_IN
10063: IFFALSE 10095
// begin NonBuild := NonBuild diff GetWeapon ( veh ) ;
10065: LD_ADDR_VAR 0 3
10069: PUSH
10070: LD_VAR 0 3
10074: PUSH
10075: LD_VAR 0 2
10079: PPUSH
10080: CALL_OW 264
10084: DIFF
10085: ST_TO_ADDR
// Wait ( 1 ) ;
10086: LD_INT 1
10088: PPUSH
10089: CALL_OW 67
// end ;
10093: GO 10062
10095: POP
10096: POP
// if NonBuild = [ ] and not WeaponsDone then
10097: LD_VAR 0 3
10101: PUSH
10102: EMPTY
10103: EQUAL
10104: PUSH
10105: LD_EXP 50
10109: NOT
10110: AND
10111: IFFALSE 10130
// begin ChangeMissionObjectives ( MWeaponsDone ) ;
10113: LD_STRING MWeaponsDone
10115: PPUSH
10116: CALL_OW 337
// WeaponsDone := true ;
10120: LD_ADDR_EXP 50
10124: PUSH
10125: LD_INT 1
10127: ST_TO_ADDR
// end else
10128: GO 10160
// if NonBuild <> [ ] and WeaponsDone then
10130: LD_VAR 0 3
10134: PUSH
10135: EMPTY
10136: NONEQUAL
10137: PUSH
10138: LD_EXP 50
10142: AND
10143: IFFALSE 10160
// begin ChangeMissionObjectives ( Mweapons ) ;
10145: LD_STRING Mweapons
10147: PPUSH
10148: CALL_OW 337
// WeaponsDone := false ;
10152: LD_ADDR_EXP 50
10156: PUSH
10157: LD_INT 0
10159: ST_TO_ADDR
// end ; NonBuildWeapons := NonBuild ;
10160: LD_ADDR_LOC 4
10164: PUSH
10165: LD_VAR 0 3
10169: ST_TO_ADDR
// if HeikeCratesTime then
10170: LD_LOC 5
10174: IFFALSE 10237
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
10176: LD_ADDR_OWVAR 47
10180: PUSH
10181: LD_STRING #Ru08-1
10183: PUSH
10184: LD_INT 0
10186: PUSH
10187: LD_LOC 3
10191: PLUS
10192: PUSH
10193: LD_STRING #Ru08-2
10195: PUSH
10196: LD_INT 0
10198: PUSH
10199: LD_LOC 4
10203: PLUS
10204: PUSH
10205: LD_STRING #Ru08-3
10207: PUSH
10208: LD_INT 0
10210: PUSH
10211: LD_EXP 56
10215: PLUS
10216: PUSH
10217: LD_STRING #Ru08-4
10219: PUSH
10220: LD_LOC 5
10224: PUSH
10225: EMPTY
10226: LIST
10227: LIST
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: ST_TO_ADDR
10235: GO 10286
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
10237: LD_ADDR_OWVAR 47
10241: PUSH
10242: LD_STRING #Ru08-1
10244: PUSH
10245: LD_INT 0
10247: PUSH
10248: LD_LOC 3
10252: PLUS
10253: PUSH
10254: LD_STRING #Ru08-2
10256: PUSH
10257: LD_INT 0
10259: PUSH
10260: LD_LOC 4
10264: PLUS
10265: PUSH
10266: LD_STRING #Ru08-3
10268: PUSH
10269: LD_INT 0
10271: PUSH
10272: LD_EXP 56
10276: PLUS
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: ST_TO_ADDR
// enable ;
10286: ENABLE
// end ;
10287: PPOPN 3
10289: END
// every 0 0$2 marked 1 do var filter ;
10290: GO 10292
10292: DISABLE
10293: LD_INT 0
10295: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
10296: LD_ADDR_VAR 0 1
10300: PUSH
10301: LD_INT 22
10303: PUSH
10304: LD_EXP 31
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 2
10315: PUSH
10316: LD_INT 30
10318: PUSH
10319: LD_INT 0
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PUSH
10326: LD_INT 30
10328: PUSH
10329: LD_INT 1
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: PUSH
10341: EMPTY
10342: LIST
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: PPUSH
10348: CALL_OW 69
10352: ST_TO_ADDR
// if ( 0 + filter ) = 0 then
10353: LD_INT 0
10355: PUSH
10356: LD_VAR 0 1
10360: PLUS
10361: PUSH
10362: LD_INT 0
10364: EQUAL
10365: IFFALSE 10383
// filter := filter union Burlak ;
10367: LD_ADDR_VAR 0 1
10371: PUSH
10372: LD_VAR 0 1
10376: PUSH
10377: LD_EXP 1
10381: UNION
10382: ST_TO_ADDR
// if ( GetDistUnits ( Kurt , filter [ 1 ] ) < 8 ) or ( GetDistUnits ( Mercenary1 , filter [ 1 ] ) < 8 ) then
10383: LD_EXP 13
10387: PPUSH
10388: LD_VAR 0 1
10392: PUSH
10393: LD_INT 1
10395: ARRAY
10396: PPUSH
10397: CALL_OW 296
10401: PUSH
10402: LD_INT 8
10404: LESS
10405: PUSH
10406: LD_EXP 14
10410: PPUSH
10411: LD_VAR 0 1
10415: PUSH
10416: LD_INT 1
10418: ARRAY
10419: PPUSH
10420: CALL_OW 296
10424: PUSH
10425: LD_INT 8
10427: LESS
10428: OR
10429: IFFALSE 10460
// begin SetSide ( [ Kurt , Mercenary1 ] , you ) ;
10431: LD_EXP 13
10435: PUSH
10436: LD_EXP 14
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PPUSH
10445: LD_EXP 31
10449: PPUSH
10450: CALL_OW 235
// enable ( 10 ) ;
10454: LD_INT 10
10456: ENABLE_MARKED
// enable ( 601 ) ;
10457: LD_INT 601
10459: ENABLE_MARKED
// end ; if GetSide ( Kurt ) = you and GetSide ( Mercenary1 ) = you then
10460: LD_EXP 13
10464: PPUSH
10465: CALL_OW 255
10469: PUSH
10470: LD_EXP 31
10474: EQUAL
10475: PUSH
10476: LD_EXP 14
10480: PPUSH
10481: CALL_OW 255
10485: PUSH
10486: LD_EXP 31
10490: EQUAL
10491: AND
10492: IFFALSE 10497
// disable else
10494: DISABLE
10495: GO 10498
// enable ;
10497: ENABLE
// end ;
10498: PPOPN 1
10500: END
// every 0 0$1 + 0 0$0.2 marked 2 do var list ;
10501: GO 10503
10503: DISABLE
10504: LD_INT 0
10506: PPUSH
// begin list = [ false , false ] ;
10507: LD_ADDR_VAR 0 1
10511: PUSH
10512: LD_INT 0
10514: PUSH
10515: LD_INT 0
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: ST_TO_ADDR
// if IsLive ( Kurt ) and UnitShoot ( Kurt ) > 0 then
10522: LD_EXP 13
10526: PPUSH
10527: CALL_OW 300
10531: PUSH
10532: LD_EXP 13
10536: PPUSH
10537: CALL_OW 504
10541: PUSH
10542: LD_INT 0
10544: GREATER
10545: AND
10546: IFFALSE 10591
// if GetSide ( UnitShoot ( Kurt ) ) = you then
10548: LD_EXP 13
10552: PPUSH
10553: CALL_OW 504
10557: PPUSH
10558: CALL_OW 255
10562: PUSH
10563: LD_EXP 31
10567: EQUAL
10568: IFFALSE 10591
// list = Replace ( list , 1 , true ) ;
10570: LD_ADDR_VAR 0 1
10574: PUSH
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 1
10582: PPUSH
10583: LD_INT 1
10585: PPUSH
10586: CALL_OW 1
10590: ST_TO_ADDR
// if IsLive ( Mercenary1 ) and UnitShoot ( Mercenary1 ) > 0 then
10591: LD_EXP 14
10595: PPUSH
10596: CALL_OW 300
10600: PUSH
10601: LD_EXP 14
10605: PPUSH
10606: CALL_OW 504
10610: PUSH
10611: LD_INT 0
10613: GREATER
10614: AND
10615: IFFALSE 10660
// if GetSide ( UnitShoot ( Mercenary1 ) ) = you then
10617: LD_EXP 14
10621: PPUSH
10622: CALL_OW 504
10626: PPUSH
10627: CALL_OW 255
10631: PUSH
10632: LD_EXP 31
10636: EQUAL
10637: IFFALSE 10660
// list = Replace ( list , 2 , true ) ;
10639: LD_ADDR_VAR 0 1
10643: PUSH
10644: LD_VAR 0 1
10648: PPUSH
10649: LD_INT 2
10651: PPUSH
10652: LD_INT 1
10654: PPUSH
10655: CALL_OW 1
10659: ST_TO_ADDR
// if true in list then
10660: LD_INT 1
10662: PUSH
10663: LD_VAR 0 1
10667: IN
10668: IFFALSE 10759
// begin disable ( 601 ) ;
10670: LD_INT 601
10672: DISABLE_MARKED
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
10673: LD_EXP 13
10677: PUSH
10678: LD_EXP 14
10682: PUSH
10683: EMPTY
10684: LIST
10685: LIST
10686: PPUSH
10687: LD_EXP 34
10691: PPUSH
10692: CALL_OW 235
// SetAttitude ( you , merc , att_enemy , true ) ;
10696: LD_EXP 31
10700: PPUSH
10701: LD_EXP 34
10705: PPUSH
10706: LD_INT 2
10708: PPUSH
10709: LD_INT 1
10711: PPUSH
10712: CALL_OW 80
// D_MercAmbush ;
10716: CALL 5291 0 0
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , 27 , 52 ) ;
10720: LD_EXP 13
10724: PUSH
10725: LD_EXP 14
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: PPUSH
10734: LD_INT 27
10736: PPUSH
10737: LD_INT 52
10739: PPUSH
10740: CALL_OW 114
// enable ( 23 ) ;
10744: LD_INT 23
10746: ENABLE_MARKED
// merc_attack ;
10747: CALL 7722 0 0
// disabled2 := true ;
10751: LD_ADDR_EXP 86
10755: PUSH
10756: LD_INT 1
10758: ST_TO_ADDR
// end ; if not disabled2 then
10759: LD_EXP 86
10763: NOT
10764: IFFALSE 10767
// enable ;
10766: ENABLE
// end ;
10767: PPOPN 1
10769: END
// every 0 0$10 marked 3 do
10770: GO 10772
10772: DISABLE
// begin countdown := countdown - 10 * 35 ;
10773: LD_ADDR_EXP 77
10777: PUSH
10778: LD_EXP 77
10782: PUSH
10783: LD_INT 10
10785: PUSH
10786: LD_INT 35
10788: MUL
10789: MINUS
10790: ST_TO_ADDR
// if countdown < 0 and not HeikeDismissed then
10791: LD_EXP 77
10795: PUSH
10796: LD_INT 0
10798: LESS
10799: PUSH
10800: LD_EXP 45
10804: NOT
10805: AND
10806: IFFALSE 10823
// begin disabled3 := true ;
10808: LD_ADDR_EXP 87
10812: PUSH
10813: LD_INT 1
10815: ST_TO_ADDR
// enable ( 24 ) ;
10816: LD_INT 24
10818: ENABLE_MARKED
// merc_attack ;
10819: CALL 7722 0 0
// end ; if not disabled3 then
10823: LD_EXP 87
10827: NOT
10828: IFFALSE 10831
// enable ;
10830: ENABLE
// end ;
10831: END
// every 0 0$1 marked 24 do
10832: GO 10834
10834: DISABLE
// begin Wait ( 0 0$20 ) ;
10835: LD_INT 700
10837: PPUSH
10838: CALL_OW 67
// D_MercAttack ;
10842: CALL 5344 0 0
// end ;
10846: END
// every 0 0$1 + 0 0$0.4 marked 4 do
10847: GO 10849
10849: DISABLE
// begin if IsInArea ( Heike , WaitHeikeArea ) and not HeikeDismissed then
10850: LD_EXP 11
10854: PPUSH
10855: LD_INT 8
10857: PPUSH
10858: CALL_OW 308
10862: PUSH
10863: LD_EXP 45
10867: NOT
10868: AND
10869: IFFALSE 10962
// begin SetSide ( Heike , merc ) ;
10871: LD_EXP 11
10875: PPUSH
10876: LD_EXP 34
10880: PPUSH
10881: CALL_OW 235
// ComMoveToArea ( [ Kurt , Mercenary1 , Heike ] , MercExitArea ) ;
10885: LD_EXP 13
10889: PUSH
10890: LD_EXP 14
10894: PUSH
10895: LD_EXP 11
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: LIST
10904: PPUSH
10905: LD_INT 7
10907: PPUSH
10908: CALL_OW 113
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
10912: LD_INT 8
10914: PPUSH
10915: LD_INT 0
10917: PPUSH
10918: CALL_OW 424
// HeikeDismissed := true ;
10922: LD_ADDR_EXP 45
10926: PUSH
10927: LD_INT 1
10929: ST_TO_ADDR
// if not PopovAsked then
10930: LD_EXP 46
10934: NOT
10935: IFFALSE 10941
// D_MercPopov ;
10937: CALL 5239 0 0
// enable ( 5 ) ;
10941: LD_INT 5
10943: ENABLE_MARKED
// disabled6 := true ;
10944: LD_ADDR_EXP 90
10948: PUSH
10949: LD_INT 1
10951: ST_TO_ADDR
// disabled3 := true ;
10952: LD_ADDR_EXP 87
10956: PUSH
10957: LD_INT 1
10959: ST_TO_ADDR
// end else
10960: GO 10963
// enable ;
10962: ENABLE
// end ;
10963: END
// every 0 0$1 + 0 0$0.5 marked 5 do var filter , un ;
10964: GO 10966
10966: DISABLE
10967: LD_INT 0
10969: PPUSH
10970: PPUSH
// begin filter := FilterUnitsInArea ( MercExitArea , [ f_or , [ f_side , merc ] , [ f_side , arab ] ] ) ;
10971: LD_ADDR_VAR 0 1
10975: PUSH
10976: LD_INT 7
10978: PPUSH
10979: LD_INT 2
10981: PUSH
10982: LD_INT 22
10984: PUSH
10985: LD_EXP 34
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 22
10996: PUSH
10997: LD_EXP 33
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL_OW 70
11015: ST_TO_ADDR
// for un in filter do
11016: LD_ADDR_VAR 0 2
11020: PUSH
11021: LD_VAR 0 1
11025: PUSH
11026: FOR_IN
11027: IFFALSE 11047
// begin RemoveUnit ( un ) ;
11029: LD_VAR 0 2
11033: PPUSH
11034: CALL_OW 64
// Wait ( 1 ) ;
11038: LD_INT 1
11040: PPUSH
11041: CALL_OW 67
// end ;
11045: GO 11026
11047: POP
11048: POP
// if not disabled5 then
11049: LD_EXP 89
11053: NOT
11054: IFFALSE 11057
// enable ;
11056: ENABLE
// end ;
11057: PPOPN 2
11059: END
// every 0 0$1 + 0 0$0.6 marked 6 do
11060: GO 11062
11062: DISABLE
// begin if IsInArea ( Kurt , WaitHeikeArea ) then
11063: LD_EXP 13
11067: PPUSH
11068: LD_INT 8
11070: PPUSH
11071: CALL_OW 308
11075: IFFALSE 11082
// enable ( 4 ) else
11077: LD_INT 4
11079: ENABLE_MARKED
11080: GO 11083
// enable ;
11082: ENABLE
// end ;
11083: END
// every 0 0$1 + 0 0$0.7 marked 7 do var un , i , done ;
11084: GO 11086
11086: DISABLE
11087: LD_INT 0
11089: PPUSH
11090: PPUSH
11091: PPUSH
// begin for un in player_units do
11092: LD_ADDR_VAR 0 1
11096: PUSH
11097: LD_EXP 26
11101: PUSH
11102: FOR_IN
11103: IFFALSE 11334
// begin if GetSide ( Attacks ( un ) ) = arab and not disabled7 then
11105: LD_VAR 0 1
11109: PPUSH
11110: CALL_OW 320
11114: PPUSH
11115: CALL_OW 255
11119: PUSH
11120: LD_EXP 33
11124: EQUAL
11125: PUSH
11126: LD_EXP 91
11130: NOT
11131: AND
11132: IFFALSE 11332
// begin GenscherBetrayed := true ;
11134: LD_ADDR_EXP 36
11138: PUSH
11139: LD_INT 1
11141: ST_TO_ADDR
// disabled7 := true ;
11142: LD_ADDR_EXP 91
11146: PUSH
11147: LD_INT 1
11149: ST_TO_ADDR
// D_HandOverSpoiled ;
11150: CALL 5627 0 0
// SetAttitude ( you , arab , att_enemy , true ) ;
11154: LD_EXP 31
11158: PPUSH
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 2
11166: PPUSH
11167: LD_INT 1
11169: PPUSH
11170: CALL_OW 80
// repeat wait ( 0 0$0.5 ) ;
11174: LD_INT 18
11176: PPUSH
11177: CALL_OW 67
// done = true ;
11181: LD_ADDR_VAR 0 3
11185: PUSH
11186: LD_INT 1
11188: ST_TO_ADDR
// for i in ar_human do
11189: LD_ADDR_VAR 0 2
11193: PUSH
11194: LD_EXP 80
11198: PUSH
11199: FOR_IN
11200: IFFALSE 11318
// begin if not IsPlaced ( i ) and GetLives ( i ) > 0 then
11202: LD_VAR 0 2
11206: PPUSH
11207: CALL_OW 305
11211: NOT
11212: PUSH
11213: LD_VAR 0 2
11217: PPUSH
11218: CALL_OW 256
11222: PUSH
11223: LD_INT 0
11225: GREATER
11226: AND
11227: IFFALSE 11239
// begin done = false ;
11229: LD_ADDR_VAR 0 3
11233: PUSH
11234: LD_INT 0
11236: ST_TO_ADDR
// continue ;
11237: GO 11199
// end ; if not IsOk ( i ) then
11239: LD_VAR 0 2
11243: PPUSH
11244: CALL_OW 302
11248: NOT
11249: IFFALSE 11253
// continue ;
11251: GO 11199
// if IsInUnit ( i ) > 0 then
11253: LD_VAR 0 2
11257: PPUSH
11258: CALL_OW 310
11262: PUSH
11263: LD_INT 0
11265: GREATER
11266: IFFALSE 11287
// begin ComExitVehicle ( i ) ;
11268: LD_VAR 0 2
11272: PPUSH
11273: CALL_OW 121
// done = false ;
11277: LD_ADDR_VAR 0 3
11281: PUSH
11282: LD_INT 0
11284: ST_TO_ADDR
// end else
11285: GO 11316
// ComAgressiveMove ( i , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11287: LD_VAR 0 2
11291: PPUSH
11292: LD_EXP 1
11296: PPUSH
11297: CALL_OW 250
11301: PPUSH
11302: LD_EXP 1
11306: PPUSH
11307: CALL_OW 251
11311: PPUSH
11312: CALL_OW 114
// end ;
11316: GO 11199
11318: POP
11319: POP
// until MercHandoverArabsSpawned and done ;
11320: LD_EXP 43
11324: PUSH
11325: LD_VAR 0 3
11329: AND
11330: IFFALSE 11174
// end ; end ;
11332: GO 11102
11334: POP
11335: POP
// if not disabled7 and not MercHandoverDone then
11336: LD_EXP 91
11340: NOT
11341: PUSH
11342: LD_EXP 42
11346: NOT
11347: AND
11348: IFFALSE 11351
// enable ;
11350: ENABLE
// end ;
11351: PPOPN 3
11353: END
// every 0 0$0.5 + 0 0$0.3 marked 8 do
11354: GO 11356
11356: DISABLE
// begin if disabled7 then
11357: LD_EXP 91
11361: IFFALSE 11366
// begin disable ;
11363: DISABLE
// exit ;
11364: GO 11956
// end ; if not MercHandedOver then
11366: LD_EXP 40
11370: NOT
11371: IFFALSE 11375
// exit ;
11373: GO 11956
// if not GetSide ( Kurt ) = arab then
11375: LD_EXP 13
11379: PPUSH
11380: CALL_OW 255
11384: PUSH
11385: LD_EXP 33
11389: EQUAL
11390: NOT
11391: IFFALSE 11411
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
11393: LD_EXP 80
11397: PUSH
11398: LD_INT 1
11400: ARRAY
11401: PPUSH
11402: LD_EXP 13
11406: PPUSH
11407: CALL_OW 115
// if not GetSide ( Mercenary1 ) = arab then
11411: LD_EXP 14
11415: PPUSH
11416: CALL_OW 255
11420: PUSH
11421: LD_EXP 33
11425: EQUAL
11426: NOT
11427: IFFALSE 11447
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11429: LD_EXP 80
11433: PUSH
11434: LD_INT 2
11436: ARRAY
11437: PPUSH
11438: LD_EXP 14
11442: PPUSH
11443: CALL_OW 115
// if not IsLive ( Kurt ) or not IsLive ( Mercenary1 ) then
11447: LD_EXP 13
11451: PPUSH
11452: CALL_OW 300
11456: NOT
11457: PUSH
11458: LD_EXP 14
11462: PPUSH
11463: CALL_OW 300
11467: NOT
11468: OR
11469: IFFALSE 11540
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] ] , [ [ 29 , 57 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11471: LD_INT 1
11473: PPUSH
11474: LD_EXP 80
11478: PUSH
11479: LD_INT 1
11481: ARRAY
11482: PUSH
11483: LD_EXP 80
11487: PUSH
11488: LD_INT 2
11490: ARRAY
11491: PUSH
11492: LD_EXP 80
11496: PUSH
11497: LD_INT 3
11499: ARRAY
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: LIST
11505: PPUSH
11506: LD_INT 29
11508: PUSH
11509: LD_INT 57
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: EMPTY
11517: LIST
11518: PPUSH
11519: LD_INT 1
11521: PUSH
11522: LD_INT 3
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 5
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PPUSH
11536: CALL_OW 398
// if Attacks ( ar_human [ 1 ] ) = Kurt then
11540: LD_EXP 80
11544: PUSH
11545: LD_INT 1
11547: ARRAY
11548: PPUSH
11549: CALL_OW 320
11553: PUSH
11554: LD_EXP 13
11558: EQUAL
11559: IFFALSE 11673
// begin ComStop ( [ Kurt , Mercenary1 ] ) ;
11561: LD_EXP 13
11565: PUSH
11566: LD_EXP 14
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PPUSH
11575: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11579: LD_EXP 13
11583: PUSH
11584: LD_EXP 14
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PPUSH
11593: LD_EXP 33
11597: PPUSH
11598: CALL_OW 235
// ComStop ( ar_human [ 1 ] ) ;
11602: LD_EXP 80
11606: PUSH
11607: LD_INT 1
11609: ARRAY
11610: PPUSH
11611: CALL_OW 141
// Wait ( 2 ) ;
11615: LD_INT 2
11617: PPUSH
11618: CALL_OW 67
// AddComMoveUnit ( ar_human [ 1 ] , Kurt ) ;
11622: LD_EXP 80
11626: PUSH
11627: LD_INT 1
11629: ARRAY
11630: PPUSH
11631: LD_EXP 13
11635: PPUSH
11636: CALL_OW 172
// if GetLives ( Kurt ) < 300 then
11640: LD_EXP 13
11644: PPUSH
11645: CALL_OW 256
11649: PUSH
11650: LD_INT 300
11652: LESS
11653: IFFALSE 11673
// AddComHeal ( ar_human [ 3 ] , Kurt ) ;
11655: LD_EXP 80
11659: PUSH
11660: LD_INT 3
11662: ARRAY
11663: PPUSH
11664: LD_EXP 13
11668: PPUSH
11669: CALL_OW 188
// end ; if Attacks ( ar_human [ 2 ] ) = Mercenary1 then
11673: LD_EXP 80
11677: PUSH
11678: LD_INT 2
11680: ARRAY
11681: PPUSH
11682: CALL_OW 320
11686: PUSH
11687: LD_EXP 14
11691: EQUAL
11692: IFFALSE 11806
// begin ComStop ( ar_human [ 2 ] ) ;
11694: LD_EXP 80
11698: PUSH
11699: LD_INT 2
11701: ARRAY
11702: PPUSH
11703: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11707: LD_EXP 13
11711: PUSH
11712: LD_EXP 14
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: PPUSH
11721: LD_EXP 33
11725: PPUSH
11726: CALL_OW 235
// ComStop ( [ Kurt , Mercenary1 ] ) ;
11730: LD_EXP 13
11734: PUSH
11735: LD_EXP 14
11739: PUSH
11740: EMPTY
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 141
// Wait ( 2 ) ;
11748: LD_INT 2
11750: PPUSH
11751: CALL_OW 67
// AddComMoveUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11755: LD_EXP 80
11759: PUSH
11760: LD_INT 2
11762: ARRAY
11763: PPUSH
11764: LD_EXP 14
11768: PPUSH
11769: CALL_OW 172
// if GetLives ( Mercenary1 ) < 300 then
11773: LD_EXP 14
11777: PPUSH
11778: CALL_OW 256
11782: PUSH
11783: LD_INT 300
11785: LESS
11786: IFFALSE 11806
// AddComHeal ( ar_human [ 3 ] , Mercenary1 ) ;
11788: LD_EXP 80
11792: PUSH
11793: LD_INT 3
11795: ARRAY
11796: PPUSH
11797: LD_EXP 14
11801: PPUSH
11802: CALL_OW 188
// end ; if GetSide ( Kurt ) = arab and GetSide ( Mercenary1 ) = arab then
11806: LD_EXP 13
11810: PPUSH
11811: CALL_OW 255
11815: PUSH
11816: LD_EXP 33
11820: EQUAL
11821: PUSH
11822: LD_EXP 14
11826: PPUSH
11827: CALL_OW 255
11831: PUSH
11832: LD_EXP 33
11836: EQUAL
11837: AND
11838: IFFALSE 11948
// begin disabled8 := true ;
11840: LD_ADDR_EXP 92
11844: PUSH
11845: LD_INT 1
11847: ST_TO_ADDR
// disable ( 2 ) ;
11848: LD_INT 2
11850: DISABLE_MARKED
// disable ( 6 ) ;
11851: LD_INT 6
11853: DISABLE_MARKED
// disable ( 12 ) ;
11854: LD_INT 12
11856: DISABLE_MARKED
// Wait ( 0 0$5 ) ;
11857: LD_INT 175
11859: PPUSH
11860: CALL_OW 67
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] , Kurt , Mercenary1 ] , [ [ 115 , 32 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11864: LD_INT 1
11866: PPUSH
11867: LD_EXP 80
11871: PUSH
11872: LD_INT 1
11874: ARRAY
11875: PUSH
11876: LD_EXP 80
11880: PUSH
11881: LD_INT 2
11883: ARRAY
11884: PUSH
11885: LD_EXP 80
11889: PUSH
11890: LD_INT 3
11892: ARRAY
11893: PUSH
11894: LD_EXP 13
11898: PUSH
11899: LD_EXP 14
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: LIST
11908: LIST
11909: LIST
11910: PPUSH
11911: LD_INT 115
11913: PUSH
11914: LD_INT 32
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: PUSH
11921: EMPTY
11922: LIST
11923: PPUSH
11924: LD_INT 1
11926: PUSH
11927: LD_INT 3
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 5
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PPUSH
11941: CALL_OW 398
// enable ( 11 ) ;
11945: LD_INT 11
11947: ENABLE_MARKED
// end ; if not disabled8 then
11948: LD_EXP 92
11952: NOT
11953: IFFALSE 11956
// enable ;
11955: ENABLE
// end ;
11956: END
// every 0 0$1 + 0 0$0.1 marked 8 do
11957: GO 11959
11959: DISABLE
// begin repeat wait ( 0 0$1 ) ;
11960: LD_INT 35
11962: PPUSH
11963: CALL_OW 67
// if GenscherBetrayed then
11967: LD_EXP 36
11971: IFFALSE 11975
// exit ;
11973: GO 12014
// if UnitFilter ( ar_human , [ f_placed ] ) = 0 then
11975: LD_EXP 80
11979: PPUSH
11980: LD_INT 52
11982: PUSH
11983: EMPTY
11984: LIST
11985: PPUSH
11986: CALL_OW 72
11990: PUSH
11991: LD_INT 0
11993: EQUAL
11994: IFFALSE 12010
// begin SA_OnLegionHandoverToUPF ;
11996: CALL 19073 0 0
// MercHandoverDone = true ;
12000: LD_ADDR_EXP 42
12004: PUSH
12005: LD_INT 1
12007: ST_TO_ADDR
// exit ;
12008: GO 12014
// end ; until false ;
12010: LD_INT 0
12012: IFFALSE 11960
// end ;
12014: END
// every 0 0$1 + 0 0$0.9 marked 9 do var un1 , un2 ;
12015: GO 12017
12017: DISABLE
12018: LD_INT 0
12020: PPUSH
12021: PPUSH
// begin if disabled7 then
12022: LD_EXP 91
12026: IFFALSE 12031
// begin disable ;
12028: DISABLE
// exit ;
12029: GO 12257
// end ; if IsInUnit ( ar_human [ 1 ] ) = 0 and IsInUnit ( ar_human [ 2 ] ) = 0 then
12031: LD_EXP 80
12035: PUSH
12036: LD_INT 1
12038: ARRAY
12039: PPUSH
12040: CALL_OW 310
12044: PUSH
12045: LD_INT 0
12047: EQUAL
12048: PUSH
12049: LD_EXP 80
12053: PUSH
12054: LD_INT 2
12056: ARRAY
12057: PPUSH
12058: CALL_OW 310
12062: PUSH
12063: LD_INT 0
12065: EQUAL
12066: AND
12067: IFFALSE 12249
// begin disable ( 601 ) ;
12069: LD_INT 601
12071: DISABLE_MARKED
// D_HandOverCome ;
12072: CALL 5587 0 0
// MercHandedOver := true ;
12076: LD_ADDR_EXP 40
12080: PUSH
12081: LD_INT 1
12083: ST_TO_ADDR
// disable ( 20 ) ;
12084: LD_INT 20
12086: DISABLE_MARKED
// enable ( 23 ) ;
12087: LD_INT 23
12089: ENABLE_MARKED
// enable ( 8 ) ;
12090: LD_INT 8
12092: ENABLE_MARKED
// ComStop ( [ Kurt , Mercenary1 ] ) ;
12093: LD_EXP 13
12097: PUSH
12098: LD_EXP 14
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PPUSH
12107: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
12111: LD_EXP 13
12115: PUSH
12116: LD_EXP 14
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: PPUSH
12125: LD_EXP 34
12129: PPUSH
12130: CALL_OW 235
// SetAttitude ( you , merc , att_neutral , true ) ;
12134: LD_EXP 31
12138: PPUSH
12139: LD_EXP 34
12143: PPUSH
12144: LD_INT 0
12146: PPUSH
12147: LD_INT 1
12149: PPUSH
12150: CALL_OW 80
// SetAttitude ( merc , arab , att_friend , true ) ;
12154: LD_EXP 34
12158: PPUSH
12159: LD_EXP 33
12163: PPUSH
12164: LD_INT 1
12166: PPUSH
12167: LD_INT 1
12169: PPUSH
12170: CALL_OW 80
// Wait ( 2 ) ;
12174: LD_INT 2
12176: PPUSH
12177: CALL_OW 67
// enable ( 5 ) ;
12181: LD_INT 5
12183: ENABLE_MARKED
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
12184: LD_EXP 80
12188: PUSH
12189: LD_INT 1
12191: ARRAY
12192: PPUSH
12193: LD_EXP 13
12197: PPUSH
12198: CALL_OW 115
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
12202: LD_EXP 80
12206: PUSH
12207: LD_INT 2
12209: ARRAY
12210: PPUSH
12211: LD_EXP 14
12215: PPUSH
12216: CALL_OW 115
// ComMoveToArea ( [ Kurt , Mercenary1 ] , MercExitArea ) ;
12220: LD_EXP 13
12224: PUSH
12225: LD_EXP 14
12229: PUSH
12230: EMPTY
12231: LIST
12232: LIST
12233: PPUSH
12234: LD_INT 7
12236: PPUSH
12237: CALL_OW 113
// disabled9 := true ;
12241: LD_ADDR_EXP 93
12245: PUSH
12246: LD_INT 1
12248: ST_TO_ADDR
// end ; if not disabled9 then
12249: LD_EXP 93
12253: NOT
12254: IFFALSE 12257
// enable ;
12256: ENABLE
// end ;
12257: PPOPN 2
12259: END
// every 0 0$1 marked 10 do var rnd ;
12260: GO 12262
12262: DISABLE
12263: LD_INT 0
12265: PPUSH
// begin rnd := Rand ( 0 0$30 , 0 0$45 ) ;
12266: LD_ADDR_VAR 0 1
12270: PUSH
12271: LD_INT 1050
12273: PPUSH
12274: LD_INT 1575
12276: PPUSH
12277: CALL_OW 12
12281: ST_TO_ADDR
// Wait ( rnd ) ;
12282: LD_VAR 0 1
12286: PPUSH
12287: CALL_OW 67
// if GetAttitude ( you , merc ) = att_neutral and GetSide ( Kurt ) = you then
12291: LD_EXP 31
12295: PPUSH
12296: LD_EXP 34
12300: PPUSH
12301: CALL_OW 81
12305: PUSH
12306: LD_INT 0
12308: EQUAL
12309: PUSH
12310: LD_EXP 13
12314: PPUSH
12315: CALL_OW 255
12319: PUSH
12320: LD_EXP 31
12324: EQUAL
12325: AND
12326: IFFALSE 12332
// D_ArabianRequest ;
12328: CALL 5384 0 0
// end ;
12332: PPOPN 1
12334: END
// every 0 0$1 + 0 0$0.2 marked 11 do var filter , un , disablefilter ;
12335: GO 12337
12337: DISABLE
12338: LD_INT 0
12340: PPUSH
12341: PPUSH
12342: PPUSH
// begin filter := FilterUnitsInArea ( HandOverEnterArea , [ [ f_side , arab ] , [ f_type , unit_human ] ] ) ;
12343: LD_ADDR_VAR 0 1
12347: PUSH
12348: LD_INT 6
12350: PPUSH
12351: LD_INT 22
12353: PUSH
12354: LD_EXP 33
12358: PUSH
12359: EMPTY
12360: LIST
12361: LIST
12362: PUSH
12363: LD_INT 21
12365: PUSH
12366: LD_INT 1
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PPUSH
12377: CALL_OW 70
12381: ST_TO_ADDR
// for un in filter do
12382: LD_ADDR_VAR 0 2
12386: PUSH
12387: LD_VAR 0 1
12391: PUSH
12392: FOR_IN
12393: IFFALSE 12413
// begin RemoveUnit ( un ) ;
12395: LD_VAR 0 2
12399: PPUSH
12400: CALL_OW 64
// Wait ( 1 ) ;
12404: LD_INT 1
12406: PPUSH
12407: CALL_OW 67
// end ;
12411: GO 12392
12413: POP
12414: POP
// disablefilter := FilterAllUnits ( [ f_side , arab ] ) ;
12415: LD_ADDR_VAR 0 3
12419: PUSH
12420: LD_INT 22
12422: PUSH
12423: LD_EXP 33
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PPUSH
12432: CALL_OW 69
12436: ST_TO_ADDR
// if 0 + disablefilter > 0 then
12437: LD_INT 0
12439: PUSH
12440: LD_VAR 0 3
12444: PLUS
12445: PUSH
12446: LD_INT 0
12448: GREATER
12449: IFFALSE 12454
// enable else
12451: ENABLE
12452: GO 12458
// begin disable ;
12454: DISABLE
// disable ( 7 ) ;
12455: LD_INT 7
12457: DISABLE_MARKED
// end ; end ;
12458: PPOPN 3
12460: END
// var HeikeCratesTime , LegionDone ; every 0 0$1 marked 13 do var un , filter , amount ;
12461: GO 12463
12463: DISABLE
12464: LD_INT 0
12466: PPUSH
12467: PPUSH
12468: PPUSH
// begin if ( not HeikeKilled ) and HeikeDismissed then
12469: LD_EXP 38
12473: NOT
12474: PUSH
12475: LD_EXP 45
12479: AND
12480: IFFALSE 13260
// begin disabled5 := true ;
12482: LD_ADDR_EXP 89
12486: PUSH
12487: LD_INT 1
12489: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
12490: LD_INT 175
12492: PPUSH
12493: CALL_OW 67
// D_LegionFormed ;
12497: CALL 5655 0 0
// case Query ( QLegion ) of 1 :
12501: LD_STRING QLegion
12503: PPUSH
12504: CALL_OW 97
12508: PUSH
12509: LD_INT 1
12511: DOUBLE
12512: EQUAL
12513: IFTRUE 12517
12515: GO 13244
12517: POP
// begin amount := 0 ;
12518: LD_ADDR_VAR 0 3
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12526: LD_ADDR_VAR 0 2
12530: PUSH
12531: LD_INT 22
12533: PUSH
12534: LD_EXP 31
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: PUSH
12543: LD_INT 2
12545: PUSH
12546: LD_INT 30
12548: PUSH
12549: LD_INT 0
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 30
12558: PUSH
12559: LD_INT 1
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: LIST
12570: PUSH
12571: EMPTY
12572: LIST
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: PPUSH
12578: CALL_OW 69
12582: ST_TO_ADDR
// if filter <> [ ] then
12583: LD_VAR 0 2
12587: PUSH
12588: EMPTY
12589: NONEQUAL
12590: IFFALSE 12638
// for un in filter do
12592: LD_ADDR_VAR 0 1
12596: PUSH
12597: LD_VAR 0 2
12601: PUSH
12602: FOR_IN
12603: IFFALSE 12636
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_VAR 0 3
12614: PUSH
12615: LD_VAR 0 1
12619: PPUSH
12620: CALL_OW 274
12624: PPUSH
12625: LD_INT 1
12627: PPUSH
12628: CALL_OW 275
12632: PLUS
12633: ST_TO_ADDR
12634: GO 12602
12636: POP
12637: POP
// if amount < 50 then
12638: LD_VAR 0 3
12642: PUSH
12643: LD_INT 50
12645: LESS
12646: IFFALSE 13070
// begin HeikeCratesTime := 0 0$60 ;
12648: LD_ADDR_LOC 5
12652: PUSH
12653: LD_INT 2100
12655: ST_TO_ADDR
// repeat display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] ;
12656: LD_ADDR_OWVAR 47
12660: PUSH
12661: LD_STRING #Ru08-1
12663: PUSH
12664: LD_INT 0
12666: PUSH
12667: LD_LOC 3
12671: PLUS
12672: PUSH
12673: LD_STRING #Ru08-2
12675: PUSH
12676: LD_INT 0
12678: PUSH
12679: LD_LOC 4
12683: PLUS
12684: PUSH
12685: LD_STRING #Ru08-3
12687: PUSH
12688: LD_INT 0
12690: PUSH
12691: LD_EXP 56
12695: PLUS
12696: PUSH
12697: LD_STRING #Ru08-4
12699: PUSH
12700: LD_LOC 5
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: ST_TO_ADDR
// amount := 0 ;
12715: LD_ADDR_VAR 0 3
12719: PUSH
12720: LD_INT 0
12722: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12723: LD_ADDR_VAR 0 2
12727: PUSH
12728: LD_INT 22
12730: PUSH
12731: LD_EXP 31
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 2
12742: PUSH
12743: LD_INT 30
12745: PUSH
12746: LD_INT 0
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 30
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: LIST
12767: PUSH
12768: EMPTY
12769: LIST
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PPUSH
12775: CALL_OW 69
12779: ST_TO_ADDR
// if filter <> [ ] then
12780: LD_VAR 0 2
12784: PUSH
12785: EMPTY
12786: NONEQUAL
12787: IFFALSE 12835
// for un in filter do
12789: LD_ADDR_VAR 0 1
12793: PUSH
12794: LD_VAR 0 2
12798: PUSH
12799: FOR_IN
12800: IFFALSE 12833
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12802: LD_ADDR_VAR 0 3
12806: PUSH
12807: LD_VAR 0 3
12811: PUSH
12812: LD_VAR 0 1
12816: PPUSH
12817: CALL_OW 274
12821: PPUSH
12822: LD_INT 1
12824: PPUSH
12825: CALL_OW 275
12829: PLUS
12830: ST_TO_ADDR
12831: GO 12799
12833: POP
12834: POP
// Wait ( 0 0$1 ) ;
12835: LD_INT 35
12837: PPUSH
12838: CALL_OW 67
// HeikeCratesTime := HeikeCratesTime - 0 0$1 ;
12842: LD_ADDR_LOC 5
12846: PUSH
12847: LD_LOC 5
12851: PUSH
12852: LD_INT 35
12854: MINUS
12855: ST_TO_ADDR
// until amount >= 50 or HeikeCratesTime <= 0 ;
12856: LD_VAR 0 3
12860: PUSH
12861: LD_INT 50
12863: GREATEREQUAL
12864: PUSH
12865: LD_LOC 5
12869: PUSH
12870: LD_INT 0
12872: LESSEQUAL
12873: OR
12874: IFFALSE 12656
// if amount >= 50 and HeikeCratesTime > 0 then
12876: LD_VAR 0 3
12880: PUSH
12881: LD_INT 50
12883: GREATEREQUAL
12884: PUSH
12885: LD_LOC 5
12889: PUSH
12890: LD_INT 0
12892: GREATER
12893: AND
12894: IFFALSE 13068
// begin D_QrLegion1 ;
12896: CALL 5731 0 0
// MercPaid := true ;
12900: LD_ADDR_EXP 39
12904: PUSH
12905: LD_INT 1
12907: ST_TO_ADDR
// amount := 50 ;
12908: LD_ADDR_VAR 0 3
12912: PUSH
12913: LD_INT 50
12915: ST_TO_ADDR
// for un in filter do
12916: LD_ADDR_VAR 0 1
12920: PUSH
12921: LD_VAR 0 2
12925: PUSH
12926: FOR_IN
12927: IFFALSE 13066
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
12929: LD_VAR 0 1
12933: PPUSH
12934: CALL_OW 274
12938: PPUSH
12939: LD_INT 1
12941: PPUSH
12942: CALL_OW 275
12946: PUSH
12947: LD_VAR 0 3
12951: LESS
12952: PUSH
12953: LD_VAR 0 3
12957: PUSH
12958: LD_INT 0
12960: NONEQUAL
12961: AND
12962: IFFALSE 13015
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
12964: LD_ADDR_VAR 0 3
12968: PUSH
12969: LD_VAR 0 3
12973: PUSH
12974: LD_VAR 0 1
12978: PPUSH
12979: CALL_OW 274
12983: PPUSH
12984: LD_INT 1
12986: PPUSH
12987: CALL_OW 275
12991: MINUS
12992: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
12993: LD_VAR 0 1
12997: PPUSH
12998: CALL_OW 274
13002: PPUSH
13003: LD_INT 1
13005: PPUSH
13006: LD_INT 0
13008: PPUSH
13009: CALL_OW 277
// end else
13013: GO 13064
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13015: LD_VAR 0 1
13019: PPUSH
13020: CALL_OW 274
13024: PPUSH
13025: LD_INT 1
13027: PPUSH
13028: LD_VAR 0 1
13032: PPUSH
13033: CALL_OW 274
13037: PPUSH
13038: LD_INT 1
13040: PPUSH
13041: CALL_OW 275
13045: PUSH
13046: LD_VAR 0 3
13050: MINUS
13051: PPUSH
13052: CALL_OW 277
// amount := 0 ;
13056: LD_ADDR_VAR 0 3
13060: PUSH
13061: LD_INT 0
13063: ST_TO_ADDR
// end ;
13064: GO 12926
13066: POP
13067: POP
// end ; end else
13068: GO 13242
// begin D_QrLegion1 ;
13070: CALL 5731 0 0
// MercPaid := true ;
13074: LD_ADDR_EXP 39
13078: PUSH
13079: LD_INT 1
13081: ST_TO_ADDR
// amount := 50 ;
13082: LD_ADDR_VAR 0 3
13086: PUSH
13087: LD_INT 50
13089: ST_TO_ADDR
// for un in filter do
13090: LD_ADDR_VAR 0 1
13094: PUSH
13095: LD_VAR 0 2
13099: PUSH
13100: FOR_IN
13101: IFFALSE 13240
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
13103: LD_VAR 0 1
13107: PPUSH
13108: CALL_OW 274
13112: PPUSH
13113: LD_INT 1
13115: PPUSH
13116: CALL_OW 275
13120: PUSH
13121: LD_VAR 0 3
13125: LESS
13126: PUSH
13127: LD_VAR 0 3
13131: PUSH
13132: LD_INT 0
13134: NONEQUAL
13135: AND
13136: IFFALSE 13189
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13138: LD_ADDR_VAR 0 3
13142: PUSH
13143: LD_VAR 0 3
13147: PUSH
13148: LD_VAR 0 1
13152: PPUSH
13153: CALL_OW 274
13157: PPUSH
13158: LD_INT 1
13160: PPUSH
13161: CALL_OW 275
13165: MINUS
13166: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13167: LD_VAR 0 1
13171: PPUSH
13172: CALL_OW 274
13176: PPUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 0
13182: PPUSH
13183: CALL_OW 277
// end else
13187: GO 13238
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: CALL_OW 274
13198: PPUSH
13199: LD_INT 1
13201: PPUSH
13202: LD_VAR 0 1
13206: PPUSH
13207: CALL_OW 274
13211: PPUSH
13212: LD_INT 1
13214: PPUSH
13215: CALL_OW 275
13219: PUSH
13220: LD_VAR 0 3
13224: MINUS
13225: PPUSH
13226: CALL_OW 277
// amount := 0 ;
13230: LD_ADDR_VAR 0 3
13234: PUSH
13235: LD_INT 0
13237: ST_TO_ADDR
// end ;
13238: GO 13100
13240: POP
13241: POP
// end ; end ; 2 :
13242: GO 13260
13244: LD_INT 2
13246: DOUBLE
13247: EQUAL
13248: IFTRUE 13252
13250: GO 13259
13252: POP
// D_QrLegion2 ; end ;
13253: CALL 5759 0 0
13257: GO 13260
13259: POP
// end ; LegionDone := true ;
13260: LD_ADDR_LOC 6
13264: PUSH
13265: LD_INT 1
13267: ST_TO_ADDR
// end ;
13268: PPOPN 3
13270: END
// every 0 0$1 marked 20 do
13271: GO 13273
13273: DISABLE
// begin if IsSelected ( Heike ) = true then
13274: LD_EXP 11
13278: PPUSH
13279: CALL_OW 306
13283: PUSH
13284: LD_INT 1
13286: EQUAL
13287: IFFALSE 13347
// begin if WasSelected = false then
13289: LD_EXP 83
13293: PUSH
13294: LD_INT 0
13296: EQUAL
13297: IFFALSE 13345
// begin if Query ( QSendHeike ) = 1 then
13299: LD_STRING QSendHeike
13301: PPUSH
13302: CALL_OW 97
13306: PUSH
13307: LD_INT 1
13309: EQUAL
13310: IFFALSE 13337
// begin HeikeSend := true ;
13312: LD_ADDR_EXP 65
13316: PUSH
13317: LD_INT 1
13319: ST_TO_ADDR
// ComMoveXY ( Heike , 39 , 47 ) ;
13320: LD_EXP 11
13324: PPUSH
13325: LD_INT 39
13327: PPUSH
13328: LD_INT 47
13330: PPUSH
13331: CALL_OW 111
// exit ;
13335: GO 13356
// end ; WasSelected := true ;
13337: LD_ADDR_EXP 83
13341: PUSH
13342: LD_INT 1
13344: ST_TO_ADDR
// end ; end else
13345: GO 13355
// WasSelected := false ;
13347: LD_ADDR_EXP 83
13351: PUSH
13352: LD_INT 0
13354: ST_TO_ADDR
// enable ;
13355: ENABLE
// end ;
13356: END
// every 0 0$10 + 0 0$0.4 marked 21 do
13357: GO 13359
13359: DISABLE
// begin if TechnoDone and BuildingsDone and not AmAttackStarted then
13360: LD_EXP 51
13364: PUSH
13365: LD_EXP 48
13369: AND
13370: PUSH
13371: LD_EXP 71
13375: NOT
13376: AND
13377: IFFALSE 13430
// begin enable ( 13 ) ;
13379: LD_INT 13
13381: ENABLE_MARKED
// repeat Wait ( 0 0$1 ) ;
13382: LD_INT 35
13384: PPUSH
13385: CALL_OW 67
// until LegionDone ;
13389: LD_LOC 6
13393: IFFALSE 13382
// if ( not HeikeKilled ) and HeikeDismissed then
13395: LD_EXP 38
13399: NOT
13400: PUSH
13401: LD_EXP 45
13405: AND
13406: IFFALSE 13417
// Wait ( 0 0$35 ) else
13408: LD_INT 1225
13410: PPUSH
13411: CALL_OW 67
13415: GO 13424
// Wait ( 0 0$5 ) ;
13417: LD_INT 175
13419: PPUSH
13420: CALL_OW 67
// enable ( 999 ) ;
13424: LD_INT 999
13426: ENABLE_MARKED
// enable ( 501 ) ;
13427: LD_INT 501
13429: ENABLE_MARKED
// end ; if not AmAttackStarted then
13430: LD_EXP 71
13434: NOT
13435: IFFALSE 13438
// enable ;
13437: ENABLE
// end ;
13438: END
// var ApesRespawned ; every 0 0$1 + 0 0$0.8 marked 22 do var Ape ;
13439: GO 13441
13441: DISABLE
13442: LD_INT 0
13444: PPUSH
// begin Wait ( 350 * ApesRespawned ) ;
13445: LD_INT 350
13447: PUSH
13448: LD_LOC 7
13452: MUL
13453: PPUSH
13454: CALL_OW 67
// if FilterAllUnits ( [ f_class , class_apeman ] ) < 1 then
13458: LD_INT 25
13460: PUSH
13461: LD_INT 12
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PPUSH
13468: CALL_OW 69
13472: PUSH
13473: LD_INT 1
13475: LESS
13476: IFFALSE 13586
// begin ApesRespawned := ApesRespawned + 1 ;
13478: LD_ADDR_LOC 7
13482: PUSH
13483: LD_LOC 7
13487: PUSH
13488: LD_INT 1
13490: PLUS
13491: ST_TO_ADDR
// uc_side := 0 ;
13492: LD_ADDR_OWVAR 20
13496: PUSH
13497: LD_INT 0
13499: ST_TO_ADDR
// uc_nation := nation_nature ;
13500: LD_ADDR_OWVAR 21
13504: PUSH
13505: LD_INT 0
13507: ST_TO_ADDR
// PrepareHuman ( sex_male , class_apeman , 2 ) ;
13508: LD_INT 1
13510: PPUSH
13511: LD_INT 12
13513: PPUSH
13514: LD_INT 2
13516: PPUSH
13517: CALL_OW 380
// hc_name :=  ;
13521: LD_ADDR_OWVAR 26
13525: PUSH
13526: LD_STRING 
13528: ST_TO_ADDR
// Ape := CreateHuman ;
13529: LD_ADDR_VAR 0 1
13533: PUSH
13534: CALL_OW 44
13538: ST_TO_ADDR
// SetDir ( Ape , Rand ( 0 , 5 ) ) ;
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_INT 0
13546: PPUSH
13547: LD_INT 5
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: CALL_OW 233
// PlaceUnitArea ( Ape , AnimalsArea , false ) ;
13559: LD_VAR 0 1
13563: PPUSH
13564: LD_INT 22
13566: PPUSH
13567: LD_INT 0
13569: PPUSH
13570: CALL_OW 49
// ComMoveToArea ( Ape , ApeArea ) ;
13574: LD_VAR 0 1
13578: PPUSH
13579: LD_INT 23
13581: PPUSH
13582: CALL_OW 113
// end ; enable ;
13586: ENABLE
// end ;
13587: PPOPN 1
13589: END
// every 0 0$15 marked 23 do var filter , un ;
13590: GO 13592
13592: DISABLE
13593: LD_INT 0
13595: PPUSH
13596: PPUSH
// begin ComAttackUnit ( Heike , Burlak ) ;
13597: LD_EXP 11
13601: PPUSH
13602: LD_EXP 1
13606: PPUSH
13607: CALL_OW 115
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13611: LD_ADDR_VAR 0 1
13615: PUSH
13616: LD_INT 22
13618: PUSH
13619: LD_EXP 31
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 21
13630: PUSH
13631: LD_INT 1
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: EMPTY
13639: LIST
13640: LIST
13641: PPUSH
13642: CALL_OW 69
13646: ST_TO_ADDR
// for un in filter do
13647: LD_ADDR_VAR 0 2
13651: PUSH
13652: LD_VAR 0 1
13656: PUSH
13657: FOR_IN
13658: IFFALSE 13683
// begin AddComAttackUnit ( Heike , un ) ;
13660: LD_EXP 11
13664: PPUSH
13665: LD_VAR 0 2
13669: PPUSH
13670: CALL_OW 175
// Wait ( 10 ) ;
13674: LD_INT 10
13676: PPUSH
13677: CALL_OW 67
// end ;
13681: GO 13657
13683: POP
13684: POP
// enable ;
13685: ENABLE
// end ;
13686: PPOPN 2
13688: END
// on BuildingComplete ( building ) do var rnd , distance , un1 , un2 , pole , budova1 , budova2 , i , filter ;
13689: LD_INT 0
13691: PPUSH
13692: PPUSH
13693: PPUSH
13694: PPUSH
13695: PPUSH
13696: PPUSH
13697: PPUSH
13698: PPUSH
13699: PPUSH
// begin if ( not depot_build ) and ( GetBType ( building ) = b_depot ) and HeikeCaptured then
13700: LD_EXP 28
13704: NOT
13705: PUSH
13706: LD_VAR 0 1
13710: PPUSH
13711: CALL_OW 266
13715: PUSH
13716: LD_INT 0
13718: EQUAL
13719: AND
13720: PUSH
13721: LD_EXP 37
13725: AND
13726: IFFALSE 13806
// begin depot_build = true ;
13728: LD_ADDR_EXP 28
13732: PUSH
13733: LD_INT 1
13735: ST_TO_ADDR
// depotX := GetX ( building ) ;
13736: LD_ADDR_EXP 29
13740: PUSH
13741: LD_VAR 0 1
13745: PPUSH
13746: CALL_OW 250
13750: ST_TO_ADDR
// depotY := GetY ( building ) ;
13751: LD_ADDR_EXP 30
13755: PUSH
13756: LD_VAR 0 1
13760: PPUSH
13761: CALL_OW 251
13765: ST_TO_ADDR
// Wait ( 0 0$10 ) ;
13766: LD_INT 350
13768: PPUSH
13769: CALL_OW 67
// D_Heike ;
13773: CALL 4952 0 0
// rnd := Rand ( 1 1$15 , 2 2$0 ) ;
13777: LD_ADDR_VAR 0 2
13781: PUSH
13782: LD_INT 2625
13784: PPUSH
13785: LD_INT 4200
13787: PPUSH
13788: CALL_OW 12
13792: ST_TO_ADDR
// Wait ( rnd ) ;
13793: LD_VAR 0 2
13797: PPUSH
13798: CALL_OW 67
// merc_help ;
13802: CALL 7521 0 0
// end ; end ;
13806: PPOPN 10
13808: END
// on UpgradeComplete ( building ) do begin if ( GetBType ( building ) = b_barracks ) and ( GetNation ( building ) = nation_arabian ) then
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 266
13818: PUSH
13819: LD_INT 5
13821: EQUAL
13822: PUSH
13823: LD_VAR 0 1
13827: PPUSH
13828: CALL_OW 248
13832: PUSH
13833: LD_INT 2
13835: EQUAL
13836: AND
13837: IFFALSE 13941
// begin MortarDone := true ;
13839: LD_ADDR_EXP 52
13843: PUSH
13844: LD_INT 1
13846: ST_TO_ADDR
// if not MercHandedOver or not MercWillBeHandedOver then
13847: LD_EXP 40
13851: NOT
13852: PUSH
13853: LD_EXP 41
13857: NOT
13858: OR
13859: IFFALSE 13941
// begin Wait ( 0 0$1 ) ;
13861: LD_INT 35
13863: PPUSH
13864: CALL_OW 67
// enable ( 3 ) ;
13868: LD_INT 3
13870: ENABLE_MARKED
// D_MercCompleted ;
13871: CALL 5219 0 0
// enable ( 20 ) ;
13875: LD_INT 20
13877: ENABLE_MARKED
// SetAreaMapShow ( WaitHeikeArea , 1 ) ;
13878: LD_INT 8
13880: PPUSH
13881: LD_INT 1
13883: PPUSH
13884: CALL_OW 424
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
13888: LD_EXP 13
13892: PUSH
13893: LD_EXP 14
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PPUSH
13902: LD_EXP 34
13906: PPUSH
13907: CALL_OW 235
// disable ( 601 ) ;
13911: LD_INT 601
13913: DISABLE_MARKED
// ComMoveXY ( [ Kurt , Mercenary1 ] , 39 , 48 ) ;
13914: LD_EXP 13
13918: PUSH
13919: LD_EXP 14
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: PPUSH
13928: LD_INT 39
13930: PPUSH
13931: LD_INT 48
13933: PPUSH
13934: CALL_OW 111
// enable ( 6 ) ;
13938: LD_INT 6
13940: ENABLE_MARKED
// end ; end ; end ;
13941: PPOPN 1
13943: END
// on UnitGoesToRed ( un ) do begin if LimitTeleportResearched and GetType ( un ) = unit_vehicle then
13944: LD_EXP 62
13948: PUSH
13949: LD_VAR 0 1
13953: PPUSH
13954: CALL_OW 247
13958: PUSH
13959: LD_INT 2
13961: EQUAL
13962: AND
13963: IFFALSE 13980
// begin LimitTeleportTested := true ;
13965: LD_ADDR_EXP 63
13969: PUSH
13970: LD_INT 1
13972: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
13973: LD_STRING MTeleDone
13975: PPUSH
13976: CALL_OW 337
// end ; if GetSide ( un ) = usa then
13980: LD_VAR 0 1
13984: PPUSH
13985: CALL_OW 255
13989: PUSH
13990: LD_EXP 35
13994: EQUAL
13995: IFFALSE 14013
// amattack := amattack diff un ;
13997: LD_ADDR_EXP 27
14001: PUSH
14002: LD_EXP 27
14006: PUSH
14007: LD_VAR 0 1
14011: DIFF
14012: ST_TO_ADDR
// if un = Heike then
14013: LD_VAR 0 1
14017: PUSH
14018: LD_EXP 11
14022: EQUAL
14023: IFFALSE 14180
// begin if MortarAsked and not MercHandedOver then
14025: LD_EXP 69
14029: PUSH
14030: LD_EXP 40
14034: NOT
14035: AND
14036: IFFALSE 14136
// begin D_MercDeceived ;
14038: CALL 5364 0 0
// if not MortarDone then
14042: LD_EXP 52
14046: NOT
14047: IFFALSE 14110
// begin SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
14049: LD_EXP 13
14053: PUSH
14054: LD_EXP 14
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PPUSH
14063: LD_EXP 34
14067: PPUSH
14068: CALL_OW 235
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
14072: LD_EXP 13
14076: PUSH
14077: LD_EXP 14
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: PPUSH
14086: LD_EXP 1
14090: PPUSH
14091: CALL_OW 250
14095: PPUSH
14096: LD_EXP 1
14100: PPUSH
14101: CALL_OW 251
14105: PPUSH
14106: CALL_OW 114
// end ; SetLives ( Heike , 0 ) ;
14110: LD_EXP 11
14114: PPUSH
14115: LD_INT 0
14117: PPUSH
14118: CALL_OW 234
// HeikeKilled := true ;
14122: LD_ADDR_EXP 38
14126: PUSH
14127: LD_INT 1
14129: ST_TO_ADDR
// merc_attack ;
14130: CALL 7722 0 0
// end else
14134: GO 14180
// begin D_HeikeKilled ;
14136: CALL 4983 0 0
// SetLives ( Heike , 0 ) ;
14140: LD_EXP 11
14144: PPUSH
14145: LD_INT 0
14147: PPUSH
14148: CALL_OW 234
// HeikeKilled := true ;
14152: LD_ADDR_EXP 38
14156: PUSH
14157: LD_INT 1
14159: ST_TO_ADDR
// SetAttitude ( you , merc , att_enemy , true ) ;
14160: LD_EXP 31
14164: PPUSH
14165: LD_EXP 34
14169: PPUSH
14170: LD_INT 2
14172: PPUSH
14173: LD_INT 1
14175: PPUSH
14176: CALL_OW 80
// end ; end ; end ;
14180: PPOPN 1
14182: END
// on UnitDestroyed ( human ) do begin if human = Burlak then
14183: LD_VAR 0 1
14187: PUSH
14188: LD_EXP 1
14192: EQUAL
14193: IFFALSE 14202
// YouLost ( Burlak ) ;
14195: LD_STRING Burlak
14197: PPUSH
14198: CALL_OW 104
// end ;
14202: PPOPN 1
14204: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_AdvAI then
14205: LD_VAR 0 1
14209: PUSH
14210: LD_INT 27
14212: EQUAL
14213: IFFALSE 14240
// begin Hint ( AI ) ;
14215: LD_STRING AI
14217: PPUSH
14218: CALL_OW 339
// Wait ( 0 0$10 ) ;
14222: LD_INT 350
14224: PPUSH
14225: CALL_OW 67
// D_AI ;
14229: CALL 6878 0 0
// ChangeMissionObjectives ( MAI ) ;
14233: LD_STRING MAI
14235: PPUSH
14236: CALL_OW 337
// end ; if tech = tech_LimTeleport then
14240: LD_VAR 0 1
14244: PUSH
14245: LD_INT 37
14247: EQUAL
14248: IFFALSE 14283
// begin Hint ( SpontTelep ) ;
14250: LD_STRING SpontTelep
14252: PPUSH
14253: CALL_OW 339
// Wait ( 0 0$10 ) ;
14257: LD_INT 350
14259: PPUSH
14260: CALL_OW 67
// D_SpontTelep ;
14264: CALL 6980 0 0
// ChangeMissionObjectives ( MTele ) ;
14268: LD_STRING MTele
14270: PPUSH
14271: CALL_OW 337
// LimitTeleportResearched := true ;
14275: LD_ADDR_EXP 62
14279: PUSH
14280: LD_INT 1
14282: ST_TO_ADDR
// end ; AvailableTechno := AvailableTechno diff tech ;
14283: LD_ADDR_EXP 56
14287: PUSH
14288: LD_EXP 56
14292: PUSH
14293: LD_VAR 0 1
14297: DIFF
14298: ST_TO_ADDR
// if HeikeCratesTime then
14299: LD_LOC 5
14303: IFFALSE 14366
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
14305: LD_ADDR_OWVAR 47
14309: PUSH
14310: LD_STRING #Ru08-1
14312: PUSH
14313: LD_INT 0
14315: PUSH
14316: LD_LOC 3
14320: PLUS
14321: PUSH
14322: LD_STRING #Ru08-2
14324: PUSH
14325: LD_INT 0
14327: PUSH
14328: LD_LOC 4
14332: PLUS
14333: PUSH
14334: LD_STRING #Ru08-3
14336: PUSH
14337: LD_INT 0
14339: PUSH
14340: LD_EXP 56
14344: PLUS
14345: PUSH
14346: LD_STRING #Ru08-4
14348: PUSH
14349: LD_LOC 5
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: ST_TO_ADDR
14364: GO 14415
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
14366: LD_ADDR_OWVAR 47
14370: PUSH
14371: LD_STRING #Ru08-1
14373: PUSH
14374: LD_INT 0
14376: PUSH
14377: LD_LOC 3
14381: PLUS
14382: PUSH
14383: LD_STRING #Ru08-2
14385: PUSH
14386: LD_INT 0
14388: PUSH
14389: LD_LOC 4
14393: PLUS
14394: PUSH
14395: LD_STRING #Ru08-3
14397: PUSH
14398: LD_INT 0
14400: PUSH
14401: LD_EXP 56
14405: PLUS
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: ST_TO_ADDR
// if AvailableTechno = [ ] and not TechnoDone then
14415: LD_EXP 56
14419: PUSH
14420: EMPTY
14421: EQUAL
14422: PUSH
14423: LD_EXP 51
14427: NOT
14428: AND
14429: IFFALSE 14446
// begin ChangeMissionObjectives ( MTechnoDone ) ;
14431: LD_STRING MTechnoDone
14433: PPUSH
14434: CALL_OW 337
// TechnoDone := true ;
14438: LD_ADDR_EXP 51
14442: PUSH
14443: LD_INT 1
14445: ST_TO_ADDR
// end ; end ;
14446: PPOPN 2
14448: END
// on VehicleConstructed ( veh , fact ) do begin AvailableWeapons := AvailableWeapons diff GetWeapon ( veh ) ;
14449: LD_ADDR_EXP 54
14453: PUSH
14454: LD_EXP 54
14458: PUSH
14459: LD_VAR 0 1
14463: PPUSH
14464: CALL_OW 264
14468: DIFF
14469: ST_TO_ADDR
// if ( AvailableWeapons + 0 ) = 2 and not MashaAsked then
14470: LD_EXP 54
14474: PUSH
14475: LD_INT 0
14477: PLUS
14478: PUSH
14479: LD_INT 2
14481: EQUAL
14482: PUSH
14483: LD_EXP 70
14487: NOT
14488: AND
14489: IFFALSE 14494
// enable ( 401 ) ;
14491: LD_INT 401
14493: ENABLE_MARKED
// if GetControl ( veh ) = control_computer then
14494: LD_VAR 0 1
14498: PPUSH
14499: CALL_OW 263
14503: PUSH
14504: LD_INT 3
14506: EQUAL
14507: IFFALSE 14524
// begin ChangeMissionObjectives ( MAIDone ) ;
14509: LD_STRING MAIDone
14511: PPUSH
14512: CALL_OW 337
// CompVehConstructed = true ;
14516: LD_ADDR_EXP 61
14520: PUSH
14521: LD_INT 1
14523: ST_TO_ADDR
// end ; end ;
14524: PPOPN 2
14526: END
// on Command ( comm ) marked 601 do var i ;
14527: LD_INT 0
14529: PPUSH
// begin if IsOK ( Kurt ) then
14530: LD_EXP 13
14534: PPUSH
14535: CALL_OW 302
14539: IFFALSE 14739
// if GetTaskList ( Kurt ) <> [ ] then
14541: LD_EXP 13
14545: PPUSH
14546: CALL_OW 437
14550: PUSH
14551: EMPTY
14552: NONEQUAL
14553: IFFALSE 14739
// begin for i := 1 to ( 0 + GetTaskList ( Kurt ) ) do
14555: LD_ADDR_VAR 0 2
14559: PUSH
14560: DOUBLE
14561: LD_INT 1
14563: DEC
14564: ST_TO_ADDR
14565: LD_INT 0
14567: PUSH
14568: LD_EXP 13
14572: PPUSH
14573: CALL_OW 437
14577: PLUS
14578: PUSH
14579: FOR_TO
14580: IFFALSE 14737
// begin if ( GetTaskList ( Kurt ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Kurt ) [ i ] [ 1 ] = B and GetTaskList ( Kurt ) [ i ] [ 5 ] = 36 ) then
14582: LD_EXP 13
14586: PPUSH
14587: CALL_OW 437
14591: PUSH
14592: LD_VAR 0 2
14596: ARRAY
14597: PUSH
14598: LD_INT 1
14600: ARRAY
14601: PUSH
14602: LD_STRING F
14604: PUSH
14605: LD_STRING H
14607: PUSH
14608: LD_STRING M
14610: PUSH
14611: LD_STRING U
14613: PUSH
14614: LD_STRING V
14616: PUSH
14617: LD_STRING a
14619: PUSH
14620: LD_STRING h
14622: PUSH
14623: LD_STRING u
14625: PUSH
14626: LD_STRING v
14628: PUSH
14629: LD_STRING ~
14631: PUSH
14632: LD_STRING ^
14634: PUSH
14635: LD_STRING >
14637: PUSH
14638: LD_STRING +
14640: PUSH
14641: LD_STRING ;
14643: PUSH
14644: LD_STRING 4
14646: PUSH
14647: LD_STRING {
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: IN
14668: PUSH
14669: LD_EXP 13
14673: PPUSH
14674: CALL_OW 437
14678: PUSH
14679: LD_VAR 0 2
14683: ARRAY
14684: PUSH
14685: LD_INT 1
14687: ARRAY
14688: PUSH
14689: LD_STRING B
14691: EQUAL
14692: PUSH
14693: LD_EXP 13
14697: PPUSH
14698: CALL_OW 437
14702: PUSH
14703: LD_VAR 0 2
14707: ARRAY
14708: PUSH
14709: LD_INT 5
14711: ARRAY
14712: PUSH
14713: LD_INT 36
14715: EQUAL
14716: AND
14717: OR
14718: IFFALSE 14722
// else
14720: GO 14735
// begin RemoveTasks ( Kurt ) ;
14722: LD_EXP 13
14726: PPUSH
14727: CALL_OW 493
// D_MercRefuseBuild ;
14731: CALL 5199 0 0
// end ; end ;
14735: GO 14579
14737: POP
14738: POP
// end ; if IsOK ( Mercenary1 ) then
14739: LD_EXP 14
14743: PPUSH
14744: CALL_OW 302
14748: IFFALSE 14948
// if GetTaskList ( Mercenary1 ) <> [ ] then
14750: LD_EXP 14
14754: PPUSH
14755: CALL_OW 437
14759: PUSH
14760: EMPTY
14761: NONEQUAL
14762: IFFALSE 14948
// begin for i := 1 to ( 0 + GetTaskList ( Mercenary1 ) ) do
14764: LD_ADDR_VAR 0 2
14768: PUSH
14769: DOUBLE
14770: LD_INT 1
14772: DEC
14773: ST_TO_ADDR
14774: LD_INT 0
14776: PUSH
14777: LD_EXP 14
14781: PPUSH
14782: CALL_OW 437
14786: PLUS
14787: PUSH
14788: FOR_TO
14789: IFFALSE 14946
// begin if ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] = B and GetTaskList ( Mercenary1 ) [ i ] [ 5 ] = 36 ) then
14791: LD_EXP 14
14795: PPUSH
14796: CALL_OW 437
14800: PUSH
14801: LD_VAR 0 2
14805: ARRAY
14806: PUSH
14807: LD_INT 1
14809: ARRAY
14810: PUSH
14811: LD_STRING F
14813: PUSH
14814: LD_STRING H
14816: PUSH
14817: LD_STRING M
14819: PUSH
14820: LD_STRING U
14822: PUSH
14823: LD_STRING V
14825: PUSH
14826: LD_STRING a
14828: PUSH
14829: LD_STRING h
14831: PUSH
14832: LD_STRING u
14834: PUSH
14835: LD_STRING v
14837: PUSH
14838: LD_STRING ~
14840: PUSH
14841: LD_STRING ^
14843: PUSH
14844: LD_STRING >
14846: PUSH
14847: LD_STRING +
14849: PUSH
14850: LD_STRING ;
14852: PUSH
14853: LD_STRING 4
14855: PUSH
14856: LD_STRING {
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: LIST
14876: IN
14877: PUSH
14878: LD_EXP 14
14882: PPUSH
14883: CALL_OW 437
14887: PUSH
14888: LD_VAR 0 2
14892: ARRAY
14893: PUSH
14894: LD_INT 1
14896: ARRAY
14897: PUSH
14898: LD_STRING B
14900: EQUAL
14901: PUSH
14902: LD_EXP 14
14906: PPUSH
14907: CALL_OW 437
14911: PUSH
14912: LD_VAR 0 2
14916: ARRAY
14917: PUSH
14918: LD_INT 5
14920: ARRAY
14921: PUSH
14922: LD_INT 36
14924: EQUAL
14925: AND
14926: OR
14927: IFFALSE 14931
// else
14929: GO 14944
// begin RemoveTasks ( Mercenary1 ) ;
14931: LD_EXP 14
14935: PPUSH
14936: CALL_OW 493
// D_MercRefuseBuild ;
14940: CALL 5199 0 0
// end ; end ;
14944: GO 14788
14946: POP
14947: POP
// end ; end ;
14948: PPOPN 2
14950: END
// every 0 0$1 trigger IsOk ( Kurt ) and GetSide ( Kurt ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) >= 2 do
14951: LD_EXP 13
14955: PPUSH
14956: CALL_OW 302
14960: PUSH
14961: LD_EXP 13
14965: PPUSH
14966: CALL_OW 255
14970: PUSH
14971: LD_INT 3
14973: EQUAL
14974: AND
14975: PUSH
14976: LD_INT 22
14978: PUSH
14979: LD_INT 3
14981: PUSH
14982: EMPTY
14983: LIST
14984: LIST
14985: PUSH
14986: LD_INT 23
14988: PUSH
14989: LD_INT 2
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 30
14998: PUSH
14999: LD_INT 4
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: LIST
15010: PPUSH
15011: CALL_OW 69
15015: PUSH
15016: LD_INT 2
15018: GREATEREQUAL
15019: AND
15020: IFFALSE 15087
15022: GO 15024
15024: DISABLE
// begin enable ;
15025: ENABLE
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) [ 2 ] ) ;
15026: LD_INT 22
15028: PUSH
15029: LD_INT 3
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PUSH
15036: LD_INT 23
15038: PUSH
15039: LD_INT 2
15041: PUSH
15042: EMPTY
15043: LIST
15044: LIST
15045: PUSH
15046: LD_INT 30
15048: PUSH
15049: LD_INT 4
15051: PUSH
15052: EMPTY
15053: LIST
15054: LIST
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: LIST
15060: PPUSH
15061: CALL_OW 69
15065: PUSH
15066: LD_INT 2
15068: ARRAY
15069: PPUSH
15070: CALL_OW 64
// RemoveTasks ( Mercenary1 ) ;
15074: LD_EXP 14
15078: PPUSH
15079: CALL_OW 493
// D_MercRefuseBuild ;
15083: CALL 5199 0 0
// end ; end_of_file
15087: END
// export function hunt ( hunter ) ; var un , animals , animal , kasarna , depot , i , x , y , d , rnd_animal , hunter_x_coordinate , hunter_y_coordinate , range , osoba , min , setridene_animals ; begin
15088: LD_INT 0
15090: PPUSH
15091: PPUSH
15092: PPUSH
15093: PPUSH
15094: PPUSH
15095: PPUSH
15096: PPUSH
15097: PPUSH
15098: PPUSH
15099: PPUSH
15100: PPUSH
15101: PPUSH
15102: PPUSH
15103: PPUSH
15104: PPUSH
15105: PPUSH
15106: PPUSH
// kasarna := FilterAllUnits ( [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ) ;
15107: LD_ADDR_VAR 0 6
15111: PUSH
15112: LD_INT 2
15114: PUSH
15115: LD_INT 30
15117: PUSH
15118: LD_INT 5
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: PUSH
15125: LD_INT 30
15127: PUSH
15128: LD_INT 4
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL_OW 69
15144: ST_TO_ADDR
// SetSide ( hunter , ally ) ;
15145: LD_VAR 0 1
15149: PPUSH
15150: LD_EXP 32
15154: PPUSH
15155: CALL_OW 235
// if not ( GetClass ( hunter ) = class_soldier ) and ( kasarna > 0 ) then
15159: LD_VAR 0 1
15163: PPUSH
15164: CALL_OW 257
15168: PUSH
15169: LD_INT 1
15171: EQUAL
15172: NOT
15173: PUSH
15174: LD_VAR 0 6
15178: PUSH
15179: LD_INT 0
15181: GREATER
15182: AND
15183: IFFALSE 15371
// begin ComEnterUnit ( hunter , kasarna [ 1 ] ) ;
15185: LD_VAR 0 1
15189: PPUSH
15190: LD_VAR 0 6
15194: PUSH
15195: LD_INT 1
15197: ARRAY
15198: PPUSH
15199: CALL_OW 120
// Wait ( 10 ) ;
15203: LD_INT 10
15205: PPUSH
15206: CALL_OW 67
// while HasTask ( hunter ) do
15210: LD_VAR 0 1
15214: PPUSH
15215: CALL_OW 314
15219: IFFALSE 15230
// begin Wait ( 10 ) ;
15221: LD_INT 10
15223: PPUSH
15224: CALL_OW 67
// end ;
15228: GO 15210
// hunter_x_coordinate := GetX ( hunter ) ;
15230: LD_ADDR_VAR 0 13
15234: PUSH
15235: LD_VAR 0 1
15239: PPUSH
15240: CALL_OW 250
15244: ST_TO_ADDR
// hunter_y_coordinate := GetY ( hunter ) ;
15245: LD_ADDR_VAR 0 14
15249: PUSH
15250: LD_VAR 0 1
15254: PPUSH
15255: CALL_OW 251
15259: ST_TO_ADDR
// RemoveUnit ( hunter ) ;
15260: LD_VAR 0 1
15264: PPUSH
15265: CALL_OW 64
// SetClass ( hunter , class_soldier ) ;
15269: LD_VAR 0 1
15273: PPUSH
15274: LD_INT 1
15276: PPUSH
15277: CALL_OW 336
// Wait ( 0 0$2 ) ;
15281: LD_INT 70
15283: PPUSH
15284: CALL_OW 67
// if not PlaceUnitXY ( hunter , hunter_x_coordinate , hunter_y_coordinate , false ) then
15288: LD_VAR 0 1
15292: PPUSH
15293: LD_VAR 0 13
15297: PPUSH
15298: LD_VAR 0 14
15302: PPUSH
15303: LD_INT 0
15305: PPUSH
15306: CALL_OW 48
15310: NOT
15311: IFFALSE 15371
// begin range := 0 ;
15313: LD_ADDR_VAR 0 15
15317: PUSH
15318: LD_INT 0
15320: ST_TO_ADDR
// repeat Wait ( 2 ) ;
15321: LD_INT 2
15323: PPUSH
15324: CALL_OW 67
// range := range + 1 ;
15328: LD_ADDR_VAR 0 15
15332: PUSH
15333: LD_VAR 0 15
15337: PUSH
15338: LD_INT 1
15340: PLUS
15341: ST_TO_ADDR
// until PlaceUnitXYR ( hunter , hunter_x_coordinate , hunter_y_coordinate , range , false ) end ;
15342: LD_VAR 0 1
15346: PPUSH
15347: LD_VAR 0 13
15351: PPUSH
15352: LD_VAR 0 14
15356: PPUSH
15357: LD_VAR 0 15
15361: PPUSH
15362: LD_INT 0
15364: PPUSH
15365: CALL_OW 50
15369: IFFALSE 15321
// end ; animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15371: LD_ADDR_VAR 0 4
15375: PUSH
15376: LD_INT 2
15378: PUSH
15379: LD_INT 25
15381: PUSH
15382: LD_INT 18
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: PUSH
15389: LD_INT 25
15391: PUSH
15392: LD_INT 14
15394: PUSH
15395: EMPTY
15396: LIST
15397: LIST
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: LIST
15403: PPUSH
15404: CALL_OW 69
15408: ST_TO_ADDR
// if animals = [ ] then
15409: LD_VAR 0 4
15413: PUSH
15414: EMPTY
15415: EQUAL
15416: IFFALSE 15600
// begin Randomize ;
15418: CALL_OW 10
// RandomizeAll ;
15422: CALL_OW 11
// for i := 1 to 6 do
15426: LD_ADDR_VAR 0 8
15430: PUSH
15431: DOUBLE
15432: LD_INT 1
15434: DEC
15435: ST_TO_ADDR
15436: LD_INT 6
15438: PUSH
15439: FOR_TO
15440: IFFALSE 15598
// begin uc_side = 0 ;
15442: LD_ADDR_OWVAR 20
15446: PUSH
15447: LD_INT 0
15449: ST_TO_ADDR
// uc_nation := nation_nature ;
15450: LD_ADDR_OWVAR 21
15454: PUSH
15455: LD_INT 0
15457: ST_TO_ADDR
// PrepareHuman ( 0 , class_phororhacos , 0 ) ;
15458: LD_INT 0
15460: PPUSH
15461: LD_INT 18
15463: PPUSH
15464: LD_INT 0
15466: PPUSH
15467: CALL_OW 380
// hc_name :=  ;
15471: LD_ADDR_OWVAR 26
15475: PUSH
15476: LD_STRING 
15478: ST_TO_ADDR
// Wait ( 1 ) ;
15479: LD_INT 1
15481: PPUSH
15482: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15486: CALL_OW 44
15490: PPUSH
15491: LD_INT 22
15493: PPUSH
15494: LD_INT 0
15496: PPUSH
15497: CALL_OW 49
// Wait ( 1 ) ;
15501: LD_INT 1
15503: PPUSH
15504: CALL_OW 67
// PrepareHuman ( 0 , class_tiger , 0 ) ;
15508: LD_INT 0
15510: PPUSH
15511: LD_INT 14
15513: PPUSH
15514: LD_INT 0
15516: PPUSH
15517: CALL_OW 380
// hc_name :=  ;
15521: LD_ADDR_OWVAR 26
15525: PUSH
15526: LD_STRING 
15528: ST_TO_ADDR
// Wait ( 1 ) ;
15529: LD_INT 1
15531: PPUSH
15532: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15536: CALL_OW 44
15540: PPUSH
15541: LD_INT 22
15543: PPUSH
15544: LD_INT 0
15546: PPUSH
15547: CALL_OW 49
// Wait ( 1 ) ;
15551: LD_INT 1
15553: PPUSH
15554: CALL_OW 67
// animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15558: LD_ADDR_VAR 0 4
15562: PUSH
15563: LD_INT 2
15565: PUSH
15566: LD_INT 25
15568: PUSH
15569: LD_INT 18
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: LD_INT 25
15578: PUSH
15579: LD_INT 14
15581: PUSH
15582: EMPTY
15583: LIST
15584: LIST
15585: PUSH
15586: EMPTY
15587: LIST
15588: LIST
15589: LIST
15590: PPUSH
15591: CALL_OW 69
15595: ST_TO_ADDR
// end ;
15596: GO 15439
15598: POP
15599: POP
// end ; if GetClass ( hunter ) = class_soldier then
15600: LD_VAR 0 1
15604: PPUSH
15605: CALL_OW 257
15609: PUSH
15610: LD_INT 1
15612: EQUAL
15613: IFFALSE 15633
// rnd_animal := Rand ( 4 , 6 ) else
15615: LD_ADDR_VAR 0 12
15619: PUSH
15620: LD_INT 4
15622: PPUSH
15623: LD_INT 6
15625: PPUSH
15626: CALL_OW 12
15630: ST_TO_ADDR
15631: GO 15649
// rnd_animal := Rand ( 1 , 2 ) ;
15633: LD_ADDR_VAR 0 12
15637: PUSH
15638: LD_INT 1
15640: PPUSH
15641: LD_INT 2
15643: PPUSH
15644: CALL_OW 12
15648: ST_TO_ADDR
// range := 999 ;
15649: LD_ADDR_VAR 0 15
15653: PUSH
15654: LD_INT 999
15656: ST_TO_ADDR
// osoba := hunter ;
15657: LD_ADDR_VAR 0 16
15661: PUSH
15662: LD_VAR 0 1
15666: ST_TO_ADDR
// setridene_animals := [ ] ;
15667: LD_ADDR_VAR 0 18
15671: PUSH
15672: EMPTY
15673: ST_TO_ADDR
// while animals <> [ ] do
15674: LD_VAR 0 4
15678: PUSH
15679: EMPTY
15680: NONEQUAL
15681: IFFALSE 15811
// begin for un in animals do
15683: LD_ADDR_VAR 0 3
15687: PUSH
15688: LD_VAR 0 4
15692: PUSH
15693: FOR_IN
15694: IFFALSE 15757
// begin if GetDistUnits ( osoba , un ) < range then
15696: LD_VAR 0 16
15700: PPUSH
15701: LD_VAR 0 3
15705: PPUSH
15706: CALL_OW 296
15710: PUSH
15711: LD_VAR 0 15
15715: LESS
15716: IFFALSE 15748
// begin range := GetDistUnits ( hunter , un ) ;
15718: LD_ADDR_VAR 0 15
15722: PUSH
15723: LD_VAR 0 1
15727: PPUSH
15728: LD_VAR 0 3
15732: PPUSH
15733: CALL_OW 296
15737: ST_TO_ADDR
// min := un ;
15738: LD_ADDR_VAR 0 17
15742: PUSH
15743: LD_VAR 0 3
15747: ST_TO_ADDR
// end ; Wait ( 1 ) ;
15748: LD_INT 1
15750: PPUSH
15751: CALL_OW 67
// end ;
15755: GO 15693
15757: POP
15758: POP
// setridene_animals := setridene_animals ^ min ;
15759: LD_ADDR_VAR 0 18
15763: PUSH
15764: LD_VAR 0 18
15768: PUSH
15769: LD_VAR 0 17
15773: ADD
15774: ST_TO_ADDR
// animals := animals diff min ;
15775: LD_ADDR_VAR 0 4
15779: PUSH
15780: LD_VAR 0 4
15784: PUSH
15785: LD_VAR 0 17
15789: DIFF
15790: ST_TO_ADDR
// osoba := min ;
15791: LD_ADDR_VAR 0 16
15795: PUSH
15796: LD_VAR 0 17
15800: ST_TO_ADDR
// range := 999 ;
15801: LD_ADDR_VAR 0 15
15805: PUSH
15806: LD_INT 999
15808: ST_TO_ADDR
// end ;
15809: GO 15674
// for i := 1 to rnd_animal do
15811: LD_ADDR_VAR 0 8
15815: PUSH
15816: DOUBLE
15817: LD_INT 1
15819: DEC
15820: ST_TO_ADDR
15821: LD_VAR 0 12
15825: PUSH
15826: FOR_TO
15827: IFFALSE 15858
// begin AddComAttackUnit ( hunter , setridene_animals [ i ] ) ;
15829: LD_VAR 0 1
15833: PPUSH
15834: LD_VAR 0 18
15838: PUSH
15839: LD_VAR 0 8
15843: ARRAY
15844: PPUSH
15845: CALL_OW 175
// Wait ( 10 ) ;
15849: LD_INT 10
15851: PPUSH
15852: CALL_OW 67
// end ;
15856: GO 15826
15858: POP
15859: POP
// if GetClass ( hunter ) = class_soldier then
15860: LD_VAR 0 1
15864: PPUSH
15865: CALL_OW 257
15869: PUSH
15870: LD_INT 1
15872: EQUAL
15873: IFFALSE 15878
// enable ( 102 ) ;
15875: LD_INT 102
15877: ENABLE_MARKED
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15878: LD_ADDR_VAR 0 7
15882: PUSH
15883: LD_INT 2
15885: PUSH
15886: LD_INT 30
15888: PUSH
15889: LD_INT 0
15891: PUSH
15892: EMPTY
15893: LIST
15894: LIST
15895: PUSH
15896: LD_INT 30
15898: PUSH
15899: LD_INT 1
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: EMPTY
15907: LIST
15908: LIST
15909: LIST
15910: PPUSH
15911: CALL_OW 69
15915: ST_TO_ADDR
// if depot + 0 > 0 then
15916: LD_VAR 0 7
15920: PUSH
15921: LD_INT 0
15923: PLUS
15924: PUSH
15925: LD_INT 0
15927: GREATER
15928: IFFALSE 16034
// begin x := GetX ( depot [ 1 ] ) ;
15930: LD_ADDR_VAR 0 9
15934: PUSH
15935: LD_VAR 0 7
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PPUSH
15944: CALL_OW 250
15948: ST_TO_ADDR
// y := GetY ( depot [ 1 ] ) ;
15949: LD_ADDR_VAR 0 10
15953: PUSH
15954: LD_VAR 0 7
15958: PUSH
15959: LD_INT 1
15961: ARRAY
15962: PPUSH
15963: CALL_OW 251
15967: ST_TO_ADDR
// d := GetDir ( depot [ 1 ] ) ;
15968: LD_ADDR_VAR 0 11
15972: PUSH
15973: LD_VAR 0 7
15977: PUSH
15978: LD_INT 1
15980: ARRAY
15981: PPUSH
15982: CALL_OW 254
15986: ST_TO_ADDR
// AddComMoveXY ( hunter , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
15987: LD_VAR 0 1
15991: PPUSH
15992: LD_VAR 0 9
15996: PPUSH
15997: LD_VAR 0 11
16001: PPUSH
16002: LD_INT 7
16004: PPUSH
16005: CALL_OW 272
16009: PPUSH
16010: LD_VAR 0 10
16014: PPUSH
16015: LD_VAR 0 11
16019: PPUSH
16020: LD_INT 7
16022: PPUSH
16023: CALL_OW 273
16027: PPUSH
16028: CALL_OW 171
// end else
16032: GO 16049
// AddComMoveXY ( hunter , 83 , 40 ) ;
16034: LD_VAR 0 1
16038: PPUSH
16039: LD_INT 83
16041: PPUSH
16042: LD_INT 40
16044: PPUSH
16045: CALL_OW 171
// while HasTask ( hunter ) do
16049: LD_VAR 0 1
16053: PPUSH
16054: CALL_OW 314
16058: IFFALSE 16069
// begin Wait ( 0 0$1 ) ;
16060: LD_INT 35
16062: PPUSH
16063: CALL_OW 67
// end ;
16067: GO 16049
// SetSide ( hunter , you ) ;
16069: LD_VAR 0 1
16073: PPUSH
16074: LD_EXP 31
16078: PPUSH
16079: CALL_OW 235
// end ;
16083: LD_VAR 0 2
16087: RET
// every 0 0$1 marked 101 do
16088: GO 16090
16090: DISABLE
// begin HuntingAsked := true ;
16091: LD_ADDR_EXP 67
16095: PUSH
16096: LD_INT 1
16098: ST_TO_ADDR
// Wait ( Rand ( 0 0$30 , 2 2$30 ) ) ;
16099: LD_INT 1050
16101: PPUSH
16102: LD_INT 5250
16104: PPUSH
16105: CALL_OW 12
16109: PPUSH
16110: CALL_OW 67
// if not ( HuntingAccepted ) and ( IsOK ( Belkov ) or IsOK ( Karamazov ) or IsOK ( Kozlov ) ) then
16114: LD_EXP 47
16118: NOT
16119: PUSH
16120: LD_EXP 3
16124: PPUSH
16125: CALL_OW 302
16129: PUSH
16130: LD_EXP 17
16134: PPUSH
16135: CALL_OW 302
16139: OR
16140: PUSH
16141: LD_EXP 20
16145: PPUSH
16146: CALL_OW 302
16150: OR
16151: AND
16152: IFFALSE 16214
// begin D_Hunting ;
16154: CALL 5968 0 0
// case Query ( QHunting ) of 1 :
16158: LD_STRING QHunting
16160: PPUSH
16161: CALL_OW 97
16165: PUSH
16166: LD_INT 1
16168: DOUBLE
16169: EQUAL
16170: IFTRUE 16174
16172: GO 16198
16174: POP
// begin HuntingAccepted := true ;
16175: LD_ADDR_EXP 47
16179: PUSH
16180: LD_INT 1
16182: ST_TO_ADDR
// D_QrHunting1 ;
16183: CALL 6283 0 0
// hunt ( hunter ) ;
16187: LD_EXP 72
16191: PPUSH
16192: CALL 15088 0 1
// end ; 2 :
16196: GO 16214
16198: LD_INT 2
16200: DOUBLE
16201: EQUAL
16202: IFTRUE 16206
16204: GO 16213
16206: POP
// D_QrHunting2 ; end ;
16207: CALL 6303 0 0
16211: GO 16214
16213: POP
// end ; end ;
16214: END
// every 0 0$1 + 0 0$0.3 marked 102 do
16215: GO 16217
16217: DISABLE
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
16218: LD_EXP 72
16222: PPUSH
16223: LD_EXP 72
16227: PPUSH
16228: CALL_OW 319
16232: PPUSH
16233: CALL_OW 296
16237: PUSH
16238: LD_INT 13
16240: LESS
16241: IFFALSE 16254
// ComCrawl ( hunter ) else
16243: LD_EXP 72
16247: PPUSH
16248: CALL_OW 137
16252: GO 16263
// ComWalk ( hunter ) ;
16254: LD_EXP 72
16258: PPUSH
16259: CALL_OW 138
// if not HasTask ( hunter ) then
16263: LD_EXP 72
16267: PPUSH
16268: CALL_OW 314
16272: NOT
16273: IFFALSE 16278
// disable else
16275: DISABLE
16276: GO 16279
// enable ;
16278: ENABLE
// end ; end_of_file
16279: END
// var ShootAreaNr , BarrelAreas , StandAreas ; every 0 0$1 marked 201 do
16280: GO 16282
16282: DISABLE
// begin GalleryAsked := true ;
16283: LD_ADDR_EXP 66
16287: PUSH
16288: LD_INT 1
16290: ST_TO_ADDR
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
16291: LD_INT 350
16293: PPUSH
16294: LD_INT 700
16296: PPUSH
16297: CALL_OW 12
16301: PPUSH
16302: CALL_OW 67
// D_FiringRange ;
16306: CALL 5787 0 0
// case Query ( QShootingGallery ) of 1 :
16310: LD_STRING QShootingGallery
16312: PPUSH
16313: CALL_OW 97
16317: PUSH
16318: LD_INT 1
16320: DOUBLE
16321: EQUAL
16322: IFTRUE 16326
16324: GO 16423
16326: POP
// begin GalleryBuild := true ;
16327: LD_ADDR_EXP 53
16331: PUSH
16332: LD_INT 1
16334: ST_TO_ADDR
// D_QrShootingGallery1 ;
16335: CALL 5928 0 0
// Wait ( 0 0$2 ) ;
16339: LD_INT 70
16341: PPUSH
16342: CALL_OW 67
// Hint ( ShootingGallery ) ;
16346: LD_STRING ShootingGallery
16348: PPUSH
16349: CALL_OW 339
// ShootAreaNr := 1 ;
16353: LD_ADDR_LOC 8
16357: PUSH
16358: LD_INT 1
16360: ST_TO_ADDR
// BarrelAreas := [ BarrelArea1 , BarrelArea2 , BarrelArea3 , BarrelArea4 , BarrelArea5 ] ;
16361: LD_ADDR_LOC 9
16365: PUSH
16366: LD_INT 12
16368: PUSH
16369: LD_INT 13
16371: PUSH
16372: LD_INT 14
16374: PUSH
16375: LD_INT 15
16377: PUSH
16378: LD_INT 16
16380: PUSH
16381: EMPTY
16382: LIST
16383: LIST
16384: LIST
16385: LIST
16386: LIST
16387: ST_TO_ADDR
// StandAreas := [ StandArea1 , StandArea2 , StandArea3 , StandArea4 , StandArea5 ] ;
16388: LD_ADDR_LOC 10
16392: PUSH
16393: LD_INT 17
16395: PUSH
16396: LD_INT 18
16398: PUSH
16399: LD_INT 19
16401: PUSH
16402: LD_INT 20
16404: PUSH
16405: LD_INT 21
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: LIST
16412: LIST
16413: LIST
16414: ST_TO_ADDR
// enable ( 202 ) ;
16415: LD_INT 202
16417: ENABLE_MARKED
// enable ( 203 ) ;
16418: LD_INT 203
16420: ENABLE_MARKED
// end ; 2 :
16421: GO 16449
16423: LD_INT 2
16425: DOUBLE
16426: EQUAL
16427: IFTRUE 16431
16429: GO 16448
16431: POP
// begin D_QrShootingGallery2 ;
16432: CALL 5948 0 0
// SetAreaMapShow ( ShootArea , 0 ) ;
16436: LD_INT 11
16438: PPUSH
16439: LD_INT 0
16441: PPUSH
16442: CALL_OW 424
// end ; end ;
16446: GO 16449
16448: POP
// end ;
16449: END
// every 0 0$0.5 marked 202 do var shooters , un , buildings ;
16450: GO 16452
16452: DISABLE
16453: LD_INT 0
16455: PPUSH
16456: PPUSH
16457: PPUSH
// begin enable ;
16458: ENABLE
// shooters := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_not , [ f_hastask ] ] , [ f_nation , nation_russian ] ] ) ;
16459: LD_ADDR_VAR 0 1
16463: PUSH
16464: LD_INT 11
16466: PPUSH
16467: LD_INT 21
16469: PUSH
16470: LD_INT 1
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: PUSH
16477: LD_INT 3
16479: PUSH
16480: LD_INT 60
16482: PUSH
16483: EMPTY
16484: LIST
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: LD_INT 23
16492: PUSH
16493: LD_INT 3
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: LIST
16504: PPUSH
16505: CALL_OW 70
16509: ST_TO_ADDR
// if shooters <> [ ] then
16510: LD_VAR 0 1
16514: PUSH
16515: EMPTY
16516: NONEQUAL
16517: IFFALSE 17059
// begin for un in shooters do
16519: LD_ADDR_VAR 0 2
16523: PUSH
16524: LD_VAR 0 1
16528: PUSH
16529: FOR_IN
16530: IFFALSE 17057
// begin buildings := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
16532: LD_ADDR_VAR 0 3
16536: PUSH
16537: LD_INT 22
16539: PUSH
16540: LD_EXP 31
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 2
16551: PUSH
16552: LD_INT 30
16554: PUSH
16555: LD_INT 0
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: LD_INT 30
16564: PUSH
16565: LD_INT 1
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: LIST
16576: PUSH
16577: EMPTY
16578: LIST
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PPUSH
16584: CALL_OW 69
16588: ST_TO_ADDR
// if buildings <> [ ] then
16589: LD_VAR 0 3
16593: PUSH
16594: EMPTY
16595: NONEQUAL
16596: IFFALSE 17055
// begin if not ( GetClass ( un ) = class_engineer ) then
16598: LD_VAR 0 2
16602: PPUSH
16603: CALL_OW 257
16607: PUSH
16608: LD_INT 2
16610: EQUAL
16611: NOT
16612: IFFALSE 16856
// begin ComMoveXY ( un , ShiftX ( GetX ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) , ShiftY ( GetY ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) ) ;
16614: LD_VAR 0 2
16618: PPUSH
16619: LD_VAR 0 3
16623: PUSH
16624: LD_INT 1
16626: ARRAY
16627: PPUSH
16628: CALL_OW 250
16632: PPUSH
16633: LD_VAR 0 3
16637: PUSH
16638: LD_INT 1
16640: ARRAY
16641: PPUSH
16642: CALL_OW 254
16646: PPUSH
16647: LD_INT 3
16649: PPUSH
16650: CALL_OW 272
16654: PPUSH
16655: LD_VAR 0 3
16659: PUSH
16660: LD_INT 1
16662: ARRAY
16663: PPUSH
16664: CALL_OW 251
16668: PPUSH
16669: LD_VAR 0 3
16673: PUSH
16674: LD_INT 1
16676: ARRAY
16677: PPUSH
16678: CALL_OW 254
16682: PPUSH
16683: LD_INT 3
16685: PPUSH
16686: CALL_OW 273
16690: PPUSH
16691: CALL_OW 111
// Wait ( 10 ) ;
16695: LD_INT 10
16697: PPUSH
16698: CALL_OW 67
// while HasTask ( un ) do
16702: LD_VAR 0 2
16706: PPUSH
16707: CALL_OW 314
16711: IFFALSE 16722
// begin Wait ( 10 ) ;
16713: LD_INT 10
16715: PPUSH
16716: CALL_OW 67
// end ;
16720: GO 16702
// if UnitsInside ( buildings [ 1 ] ) = 6 then
16722: LD_VAR 0 3
16726: PUSH
16727: LD_INT 1
16729: ARRAY
16730: PPUSH
16731: CALL_OW 313
16735: PUSH
16736: LD_INT 6
16738: EQUAL
16739: IFFALSE 16796
// begin ComExitBuilding ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) ;
16741: LD_VAR 0 3
16745: PUSH
16746: LD_INT 1
16748: ARRAY
16749: PPUSH
16750: CALL_OW 313
16754: PUSH
16755: LD_INT 1
16757: ARRAY
16758: PPUSH
16759: CALL_OW 122
// while HasTask ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) do
16763: LD_VAR 0 3
16767: PUSH
16768: LD_INT 1
16770: ARRAY
16771: PPUSH
16772: CALL_OW 313
16776: PUSH
16777: LD_INT 1
16779: ARRAY
16780: PPUSH
16781: CALL_OW 314
16785: IFFALSE 16796
// begin Wait ( 10 ) ;
16787: LD_INT 10
16789: PPUSH
16790: CALL_OW 67
// end ;
16794: GO 16763
// end ; ComEnterUnit ( un , buildings [ 1 ] ) ;
16796: LD_VAR 0 2
16800: PPUSH
16801: LD_VAR 0 3
16805: PUSH
16806: LD_INT 1
16808: ARRAY
16809: PPUSH
16810: CALL_OW 120
// Wait ( 1 ) ;
16814: LD_INT 1
16816: PPUSH
16817: CALL_OW 67
// AddComChangeProfession ( un , class_engineer ) ;
16821: LD_VAR 0 2
16825: PPUSH
16826: LD_INT 2
16828: PPUSH
16829: CALL_OW 183
// Wait ( 1 ) ;
16833: LD_INT 1
16835: PPUSH
16836: CALL_OW 67
// AddComExitBuilding ( un ) ;
16840: LD_VAR 0 2
16844: PPUSH
16845: CALL_OW 182
// Wait ( 1 ) ;
16849: LD_INT 1
16851: PPUSH
16852: CALL_OW 67
// end ; if GetCargo ( un , mat_oil ) = 0 then
16856: LD_VAR 0 2
16860: PPUSH
16861: LD_INT 2
16863: PPUSH
16864: CALL_OW 289
16868: PUSH
16869: LD_INT 0
16871: EQUAL
16872: IFFALSE 16895
// AddComTransport ( un , buildings [ 1 ] , mat_oil ) ;
16874: LD_VAR 0 2
16878: PPUSH
16879: LD_VAR 0 3
16883: PUSH
16884: LD_INT 1
16886: ARRAY
16887: PPUSH
16888: LD_INT 2
16890: PPUSH
16891: CALL_OW 211
// Wait ( 1 ) ;
16895: LD_INT 1
16897: PPUSH
16898: CALL_OW 67
// repeat Wait ( 0 0$1 ) until not HasTask ( un ) ;
16902: LD_INT 35
16904: PPUSH
16905: CALL_OW 67
16909: LD_VAR 0 2
16913: PPUSH
16914: CALL_OW 314
16918: NOT
16919: IFFALSE 16902
// if GetCargo ( un , mat_oil ) <> 0 then
16921: LD_VAR 0 2
16925: PPUSH
16926: LD_INT 2
16928: PPUSH
16929: CALL_OW 289
16933: PUSH
16934: LD_INT 0
16936: NONEQUAL
16937: IFFALSE 17055
// begin AddComMoveToArea ( un , BarrelAreas [ ShootAreaNr ] ) ;
16939: LD_VAR 0 2
16943: PPUSH
16944: LD_LOC 9
16948: PUSH
16949: LD_LOC 8
16953: ARRAY
16954: PPUSH
16955: CALL_OW 173
// Wait ( 1 ) ;
16959: LD_INT 1
16961: PPUSH
16962: CALL_OW 67
// AddComUnload ( un ) ;
16966: LD_VAR 0 2
16970: PPUSH
16971: CALL_OW 219
// Wait ( 1 ) ;
16975: LD_INT 1
16977: PPUSH
16978: CALL_OW 67
// AddComSailEvent ( un , un ) ;
16982: LD_VAR 0 2
16986: PPUSH
16987: LD_VAR 0 2
16991: PPUSH
16992: CALL_OW 224
// AddComMoveToArea ( un , StandAreas [ ShootAreaNr ] ) ;
16996: LD_VAR 0 2
17000: PPUSH
17001: LD_LOC 10
17005: PUSH
17006: LD_LOC 8
17010: ARRAY
17011: PPUSH
17012: CALL_OW 173
// Wait ( 1 ) ;
17016: LD_INT 1
17018: PPUSH
17019: CALL_OW 67
// ShootAreaNr := ShootAreaNr + 1 ;
17023: LD_ADDR_LOC 8
17027: PUSH
17028: LD_LOC 8
17032: PUSH
17033: LD_INT 1
17035: PLUS
17036: ST_TO_ADDR
// if ShootAreaNr = 6 then
17037: LD_LOC 8
17041: PUSH
17042: LD_INT 6
17044: EQUAL
17045: IFFALSE 17055
// ShootAreaNr := 1 ;
17047: LD_ADDR_LOC 8
17051: PUSH
17052: LD_INT 1
17054: ST_TO_ADDR
// end ; end ; end ;
17055: GO 16529
17057: POP
17058: POP
// end ; end ;
17059: PPOPN 3
17061: END
// every 0 0$0.1 + 0 0$0.05 marked 203 do var un , shoot_filter ;
17062: GO 17064
17064: DISABLE
17065: LD_INT 0
17067: PPUSH
17068: PPUSH
// begin shoot_filter := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_hastask ] , [ f_nation , nation_russian ] ] ) ;
17069: LD_ADDR_VAR 0 2
17073: PUSH
17074: LD_INT 11
17076: PPUSH
17077: LD_INT 21
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: PUSH
17087: LD_INT 25
17089: PUSH
17090: LD_INT 2
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: PUSH
17097: LD_INT 60
17099: PUSH
17100: EMPTY
17101: LIST
17102: PUSH
17103: LD_INT 23
17105: PUSH
17106: LD_INT 3
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: PPUSH
17119: CALL_OW 70
17123: ST_TO_ADDR
// if shoot_filter <> [ ] then
17124: LD_VAR 0 2
17128: PUSH
17129: EMPTY
17130: NONEQUAL
17131: IFFALSE 17247
// for un in shoot_filter do
17133: LD_ADDR_VAR 0 1
17137: PUSH
17138: LD_VAR 0 2
17142: PUSH
17143: FOR_IN
17144: IFFALSE 17245
// if GetTaskList ( un ) <> [ ] then
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL_OW 437
17155: PUSH
17156: EMPTY
17157: NONEQUAL
17158: IFFALSE 17243
// if ( GetTaskList ( un ) [ 1 ] [ 1 ] = A ) and ( InArea ( GetTaskList ( un ) [ 1 ] [ 2 ] , GetTaskList ( un ) [ 1 ] [ 3 ] , ShootArea ) ) then
17160: LD_VAR 0 1
17164: PPUSH
17165: CALL_OW 437
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PUSH
17178: LD_STRING A
17180: EQUAL
17181: PUSH
17182: LD_VAR 0 1
17186: PPUSH
17187: CALL_OW 437
17191: PUSH
17192: LD_INT 1
17194: ARRAY
17195: PUSH
17196: LD_INT 2
17198: ARRAY
17199: PPUSH
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 437
17209: PUSH
17210: LD_INT 1
17212: ARRAY
17213: PUSH
17214: LD_INT 3
17216: ARRAY
17217: PPUSH
17218: LD_INT 11
17220: PPUSH
17221: CALL_OW 309
17225: AND
17226: IFFALSE 17243
// AddExperience ( un , skill_combat , 1 ) ;
17228: LD_VAR 0 1
17232: PPUSH
17233: LD_INT 1
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL_OW 492
17243: GO 17143
17245: POP
17246: POP
// enable ;
17247: ENABLE
// end ;
17248: PPOPN 2
17250: END
// on SailEvent ( un ) do var x , y , i ;
17251: LD_INT 0
17253: PPUSH
17254: PPUSH
17255: PPUSH
// begin x := GetX ( un ) ;
17256: LD_ADDR_VAR 0 2
17260: PUSH
17261: LD_VAR 0 1
17265: PPUSH
17266: CALL_OW 250
17270: ST_TO_ADDR
// y := GetY ( un ) ;
17271: LD_ADDR_VAR 0 3
17275: PUSH
17276: LD_VAR 0 1
17280: PPUSH
17281: CALL_OW 251
17285: ST_TO_ADDR
// for i := 0 to 5 do
17286: LD_ADDR_VAR 0 4
17290: PUSH
17291: DOUBLE
17292: LD_INT 0
17294: DEC
17295: ST_TO_ADDR
17296: LD_INT 5
17298: PUSH
17299: FOR_TO
17300: IFFALSE 17396
// if HexInfo ( ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) = - 1 then
17302: LD_VAR 0 2
17306: PPUSH
17307: LD_VAR 0 4
17311: PPUSH
17312: LD_INT 1
17314: PPUSH
17315: CALL_OW 272
17319: PPUSH
17320: LD_VAR 0 3
17324: PPUSH
17325: LD_VAR 0 4
17329: PPUSH
17330: LD_INT 1
17332: PPUSH
17333: CALL_OW 273
17337: PPUSH
17338: CALL_OW 428
17342: PUSH
17343: LD_INT 1
17345: NEG
17346: EQUAL
17347: IFFALSE 17394
// AddComAttackPlace ( un , ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) ;
17349: LD_VAR 0 1
17353: PPUSH
17354: LD_VAR 0 2
17358: PPUSH
17359: LD_VAR 0 4
17363: PPUSH
17364: LD_INT 1
17366: PPUSH
17367: CALL_OW 272
17371: PPUSH
17372: LD_VAR 0 3
17376: PPUSH
17377: LD_VAR 0 4
17381: PPUSH
17382: LD_INT 1
17384: PPUSH
17385: CALL_OW 273
17389: PPUSH
17390: CALL_OW 176
17394: GO 17299
17396: POP
17397: POP
// end ; end_of_file
17398: PPOPN 4
17400: END
// every 0 0$1 marked 301 do var filter , x , y , d , lidi ;
17401: GO 17403
17403: DISABLE
17404: LD_INT 0
17406: PPUSH
17407: PPUSH
17408: PPUSH
17409: PPUSH
17410: PPUSH
// begin FreetimeAsked := true ;
17411: LD_ADDR_EXP 68
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
// if not FreeTimeGranted and ( IsOK ( Petrovova ) or IsOK ( Kirilenkova ) or IsOK ( Kapitsova ) ) and ( IsOK ( Kuzmov ) or IsOK ( Gnyevko ) or IsOK ( Titov ) or IsOK ( Oblukov ) ) then
17419: LD_EXP 59
17423: NOT
17424: PUSH
17425: LD_EXP 21
17429: PPUSH
17430: CALL_OW 302
17434: PUSH
17435: LD_EXP 4
17439: PPUSH
17440: CALL_OW 302
17444: OR
17445: PUSH
17446: LD_EXP 6
17450: PPUSH
17451: CALL_OW 302
17455: OR
17456: AND
17457: PUSH
17458: LD_EXP 10
17462: PPUSH
17463: CALL_OW 302
17467: PUSH
17468: LD_EXP 5
17472: PPUSH
17473: CALL_OW 302
17477: OR
17478: PUSH
17479: LD_EXP 18
17483: PPUSH
17484: CALL_OW 302
17488: OR
17489: PUSH
17490: LD_EXP 19
17494: PPUSH
17495: CALL_OW 302
17499: OR
17500: AND
17501: IFFALSE 17965
// begin D_FreeTime ;
17503: CALL 6323 0 0
// case Query ( QFreeTime ) of 1 :
17507: LD_STRING QFreeTime
17509: PPUSH
17510: CALL_OW 97
17514: PUSH
17515: LD_INT 1
17517: DOUBLE
17518: EQUAL
17519: IFTRUE 17523
17521: GO 17949
17523: POP
// begin FreeTimeGranted := true ;
17524: LD_ADDR_EXP 59
17528: PUSH
17529: LD_INT 1
17531: ST_TO_ADDR
// D_QrFreeTime1 ;
17532: CALL 6790 0 0
// ComExitVehicle ( [ FreeMan , FreeWoman ] ) ;
17536: LD_EXP 57
17540: PUSH
17541: LD_EXP 58
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PPUSH
17550: CALL_OW 121
// SetSide ( [ FreeMan , FreeWoman ] , ally ) ;
17554: LD_EXP 57
17558: PUSH
17559: LD_EXP 58
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: PPUSH
17568: LD_EXP 32
17572: PPUSH
17573: CALL_OW 235
// ComMoveXY ( [ FreeMan , FreeWoman ] , 115 , 32 ) ;
17577: LD_EXP 57
17581: PUSH
17582: LD_EXP 58
17586: PUSH
17587: EMPTY
17588: LIST
17589: LIST
17590: PPUSH
17591: LD_INT 115
17593: PPUSH
17594: LD_INT 32
17596: PPUSH
17597: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
17601: LD_INT 35
17603: PPUSH
17604: CALL_OW 67
// lidi := FilterUnitsInArea ( HandOverEnterArea , [ f_side , ally ] ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 6
17615: PPUSH
17616: LD_INT 22
17618: PUSH
17619: LD_EXP 32
17623: PUSH
17624: EMPTY
17625: LIST
17626: LIST
17627: PPUSH
17628: CALL_OW 70
17632: ST_TO_ADDR
// until ( 0 + lidi ) = 2 ;
17633: LD_INT 0
17635: PUSH
17636: LD_VAR 0 5
17640: PLUS
17641: PUSH
17642: LD_INT 2
17644: EQUAL
17645: IFFALSE 17601
// RemoveUnit ( FreeMan ) ;
17647: LD_EXP 57
17651: PPUSH
17652: CALL_OW 64
// RemoveUnit ( FreeWoman ) ;
17656: LD_EXP 58
17660: PPUSH
17661: CALL_OW 64
// Wait ( 3 3$0 ) ;
17665: LD_INT 6300
17667: PPUSH
17668: CALL_OW 67
// PlaceUnitArea ( FreeMan , HandOverEnterArea , false ) ;
17672: LD_EXP 57
17676: PPUSH
17677: LD_INT 6
17679: PPUSH
17680: LD_INT 0
17682: PPUSH
17683: CALL_OW 49
// PlaceUnitArea ( FreeWoman , HandOverEnterArea , false ) ;
17687: LD_EXP 58
17691: PPUSH
17692: LD_INT 6
17694: PPUSH
17695: LD_INT 0
17697: PPUSH
17698: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
17702: LD_ADDR_VAR 0 1
17706: PUSH
17707: LD_INT 22
17709: PUSH
17710: LD_EXP 31
17714: PUSH
17715: EMPTY
17716: LIST
17717: LIST
17718: PUSH
17719: LD_INT 2
17721: PUSH
17722: LD_INT 30
17724: PUSH
17725: LD_INT 0
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: PUSH
17732: LD_INT 30
17734: PUSH
17735: LD_INT 1
17737: PUSH
17738: EMPTY
17739: LIST
17740: LIST
17741: PUSH
17742: EMPTY
17743: LIST
17744: LIST
17745: LIST
17746: PUSH
17747: EMPTY
17748: LIST
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: PPUSH
17754: CALL_OW 69
17758: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
17759: LD_INT 0
17761: PUSH
17762: LD_VAR 0 1
17766: PLUS
17767: PUSH
17768: LD_INT 0
17770: NONEQUAL
17771: IFFALSE 17832
// begin x := GetX ( filter [ 1 ] ) ;
17773: LD_ADDR_VAR 0 2
17777: PUSH
17778: LD_VAR 0 1
17782: PUSH
17783: LD_INT 1
17785: ARRAY
17786: PPUSH
17787: CALL_OW 250
17791: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
17792: LD_ADDR_VAR 0 3
17796: PUSH
17797: LD_VAR 0 1
17801: PUSH
17802: LD_INT 1
17804: ARRAY
17805: PPUSH
17806: CALL_OW 251
17810: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
17811: LD_ADDR_VAR 0 4
17815: PUSH
17816: LD_VAR 0 1
17820: PUSH
17821: LD_INT 1
17823: ARRAY
17824: PPUSH
17825: CALL_OW 254
17829: ST_TO_ADDR
// end else
17830: GO 17870
// begin x := GetX ( Burlak ) ;
17832: LD_ADDR_VAR 0 2
17836: PUSH
17837: LD_EXP 1
17841: PPUSH
17842: CALL_OW 250
17846: ST_TO_ADDR
// y := GetY ( Burlak ) ;
17847: LD_ADDR_VAR 0 3
17851: PUSH
17852: LD_EXP 1
17856: PPUSH
17857: CALL_OW 251
17861: ST_TO_ADDR
// d := 1 ;
17862: LD_ADDR_VAR 0 4
17866: PUSH
17867: LD_INT 1
17869: ST_TO_ADDR
// end ; ComMoveXY ( [ FreeMan , FreeWoman ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
17870: LD_EXP 57
17874: PUSH
17875: LD_EXP 58
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PPUSH
17884: LD_VAR 0 2
17888: PPUSH
17889: LD_VAR 0 4
17893: PPUSH
17894: LD_INT 5
17896: PPUSH
17897: CALL_OW 272
17901: PPUSH
17902: LD_VAR 0 3
17906: PPUSH
17907: LD_VAR 0 4
17911: PPUSH
17912: LD_INT 5
17914: PPUSH
17915: CALL_OW 273
17919: PPUSH
17920: CALL_OW 111
// SetSide ( [ FreeMan , FreeWoman ] , you ) ;
17924: LD_EXP 57
17928: PUSH
17929: LD_EXP 58
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PPUSH
17938: LD_EXP 31
17942: PPUSH
17943: CALL_OW 235
// end ; 2 :
17947: GO 17965
17949: LD_INT 2
17951: DOUBLE
17952: EQUAL
17953: IFTRUE 17957
17955: GO 17964
17957: POP
// D_QrFreeTime2 ; end ;
17958: CALL 6810 0 0
17962: GO 17965
17964: POP
// end ; end ; end_of_file
17965: PPOPN 5
17967: END
// export firstQuery , secondQuery , dec , isShowingQuery ; every 0 0$1 marked 401 do
17968: GO 17970
17970: DISABLE
// begin MashaAsked := true ;
17971: LD_ADDR_EXP 70
17975: PUSH
17976: LD_INT 1
17978: ST_TO_ADDR
// D_Masha ;
17979: CALL 6830 0 0
// Query ( QMasha ) ;
17983: LD_STRING QMasha
17985: PPUSH
17986: CALL_OW 97
// D_Masha2 ;
17990: CALL 6858 0 0
// ChangeMissionObjectives ( MMasha ) ;
17994: LD_STRING MMasha
17996: PPUSH
17997: CALL_OW 337
// enable ( 402 ) ;
18001: LD_INT 402
18003: ENABLE_MARKED
// firstQuery = 1 ;
18004: LD_ADDR_EXP 96
18008: PUSH
18009: LD_INT 1
18011: ST_TO_ADDR
// secondQuery = 0 ;
18012: LD_ADDR_EXP 97
18016: PUSH
18017: LD_INT 0
18019: ST_TO_ADDR
// isShowingQuery = 0 ;
18020: LD_ADDR_EXP 99
18024: PUSH
18025: LD_INT 0
18027: ST_TO_ADDR
// end ;
18028: END
// var BurlakTimeInVehicle , QMashaQueryShown , QMashaQueryRefused , BurlakWasInVehicle , BurlakNewVehicle , BurlakOldVehicle ; every 0 0$3 marked 402 do
18029: GO 18031
18031: DISABLE
// begin if GetType ( IsInUnit ( Burlak ) ) = unit_vehicle and isShowingQuery = 0 then
18032: LD_EXP 1
18036: PPUSH
18037: CALL_OW 310
18041: PPUSH
18042: CALL_OW 247
18046: PUSH
18047: LD_INT 2
18049: EQUAL
18050: PUSH
18051: LD_EXP 99
18055: PUSH
18056: LD_INT 0
18058: EQUAL
18059: AND
18060: IFFALSE 18502
// if GetWeapon ( IsInUnit ( Burlak ) ) = 42 or GetWeapon ( IsInUnit ( Burlak ) ) = 43 or GetWeapon ( IsInUnit ( Burlak ) ) = 44 or GetWeapon ( IsInUnit ( Burlak ) ) = 45 or GetWeapon ( IsInUnit ( Burlak ) ) = 46 then
18062: LD_EXP 1
18066: PPUSH
18067: CALL_OW 310
18071: PPUSH
18072: CALL_OW 264
18076: PUSH
18077: LD_INT 42
18079: EQUAL
18080: PUSH
18081: LD_EXP 1
18085: PPUSH
18086: CALL_OW 310
18090: PPUSH
18091: CALL_OW 264
18095: PUSH
18096: LD_INT 43
18098: EQUAL
18099: OR
18100: PUSH
18101: LD_EXP 1
18105: PPUSH
18106: CALL_OW 310
18110: PPUSH
18111: CALL_OW 264
18115: PUSH
18116: LD_INT 44
18118: EQUAL
18119: OR
18120: PUSH
18121: LD_EXP 1
18125: PPUSH
18126: CALL_OW 310
18130: PPUSH
18131: CALL_OW 264
18135: PUSH
18136: LD_INT 45
18138: EQUAL
18139: OR
18140: PUSH
18141: LD_EXP 1
18145: PPUSH
18146: CALL_OW 310
18150: PPUSH
18151: CALL_OW 264
18155: PUSH
18156: LD_INT 46
18158: EQUAL
18159: OR
18160: IFFALSE 18502
// begin isShowingQuery = 1 ;
18162: LD_ADDR_EXP 99
18166: PUSH
18167: LD_INT 1
18169: ST_TO_ADDR
// if secondQuery = 1 and firstQuery = 0 then
18170: LD_EXP 97
18174: PUSH
18175: LD_INT 1
18177: EQUAL
18178: PUSH
18179: LD_EXP 96
18183: PUSH
18184: LD_INT 0
18186: EQUAL
18187: AND
18188: IFFALSE 18328
// begin dec = Query ( QMashaQuery2 ) ;
18190: LD_ADDR_EXP 98
18194: PUSH
18195: LD_STRING QMashaQuery2
18197: PPUSH
18198: CALL_OW 97
18202: ST_TO_ADDR
// if dec = 1 then
18203: LD_EXP 98
18207: PUSH
18208: LD_INT 1
18210: EQUAL
18211: IFFALSE 18301
// begin disable ;
18213: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18214: LD_ADDR_EXP 60
18218: PUSH
18219: LD_EXP 1
18223: PPUSH
18224: CALL_OW 310
18228: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18229: LD_EXP 60
18233: PPUSH
18234: LD_INT 1
18236: PPUSH
18237: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18241: LD_EXP 60
18245: PPUSH
18246: CALL_OW 265
18250: PUSH
18251: LD_EXP 60
18255: PPUSH
18256: CALL_OW 262
18260: PUSH
18261: LD_EXP 60
18265: PPUSH
18266: CALL_OW 263
18270: PUSH
18271: LD_EXP 60
18275: PPUSH
18276: CALL_OW 264
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: PPUSH
18287: LD_STRING Masha
18289: PPUSH
18290: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18294: LD_STRING MMashaDone
18296: PPUSH
18297: CALL_OW 337
// end ; if dec = 2 then
18301: LD_EXP 98
18305: PUSH
18306: LD_INT 2
18308: EQUAL
18309: IFFALSE 18328
// begin ComExitVehicle ( Burlak ) ;
18311: LD_EXP 1
18315: PPUSH
18316: CALL_OW 121
// isShowingQuery = 0 ;
18320: LD_ADDR_EXP 99
18324: PUSH
18325: LD_INT 0
18327: ST_TO_ADDR
// end ; end ; if firstQuery = 1 and secondQuery = 0 then
18328: LD_EXP 96
18332: PUSH
18333: LD_INT 1
18335: EQUAL
18336: PUSH
18337: LD_EXP 97
18341: PUSH
18342: LD_INT 0
18344: EQUAL
18345: AND
18346: IFFALSE 18502
// begin dec = Query ( QMashaQuery ) ;
18348: LD_ADDR_EXP 98
18352: PUSH
18353: LD_STRING QMashaQuery
18355: PPUSH
18356: CALL_OW 97
18360: ST_TO_ADDR
// if dec = 1 then
18361: LD_EXP 98
18365: PUSH
18366: LD_INT 1
18368: EQUAL
18369: IFFALSE 18459
// begin disable ;
18371: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18372: LD_ADDR_EXP 60
18376: PUSH
18377: LD_EXP 1
18381: PPUSH
18382: CALL_OW 310
18386: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18387: LD_EXP 60
18391: PPUSH
18392: LD_INT 1
18394: PPUSH
18395: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18399: LD_EXP 60
18403: PPUSH
18404: CALL_OW 265
18408: PUSH
18409: LD_EXP 60
18413: PPUSH
18414: CALL_OW 262
18418: PUSH
18419: LD_EXP 60
18423: PPUSH
18424: CALL_OW 263
18428: PUSH
18429: LD_EXP 60
18433: PPUSH
18434: CALL_OW 264
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: LD_STRING Masha
18447: PPUSH
18448: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18452: LD_STRING MMashaDone
18454: PPUSH
18455: CALL_OW 337
// end ; if dec = 2 then
18459: LD_EXP 98
18463: PUSH
18464: LD_INT 2
18466: EQUAL
18467: IFFALSE 18502
// begin ComExitVehicle ( Burlak ) ;
18469: LD_EXP 1
18473: PPUSH
18474: CALL_OW 121
// firstQuery = 0 ;
18478: LD_ADDR_EXP 96
18482: PUSH
18483: LD_INT 0
18485: ST_TO_ADDR
// secondQuery = 1 ;
18486: LD_ADDR_EXP 97
18490: PUSH
18491: LD_INT 1
18493: ST_TO_ADDR
// isShowingQuery = 0 ;
18494: LD_ADDR_EXP 99
18498: PUSH
18499: LD_INT 0
18501: ST_TO_ADDR
// end ; end ; end ; enable ;
18502: ENABLE
// end ; end_of_file
18503: END
// var amcount ; export function prepare_am_attack ; var rndclass , rndlevel , i ; begin
18504: LD_INT 0
18506: PPUSH
18507: PPUSH
18508: PPUSH
18509: PPUSH
// if MercPaid then
18510: LD_EXP 39
18514: IFFALSE 18528
// amcount := weaker else
18516: LD_ADDR_LOC 17
18520: PUSH
18521: LD_EXP 75
18525: ST_TO_ADDR
18526: GO 18538
// amcount := stronger ;
18528: LD_ADDR_LOC 17
18532: PUSH
18533: LD_EXP 76
18537: ST_TO_ADDR
// for i := 1 to amcount do
18538: LD_ADDR_VAR 0 4
18542: PUSH
18543: DOUBLE
18544: LD_INT 1
18546: DEC
18547: ST_TO_ADDR
18548: LD_LOC 17
18552: PUSH
18553: FOR_TO
18554: IFFALSE 18707
// begin uc_side := usa ;
18556: LD_ADDR_OWVAR 20
18560: PUSH
18561: LD_EXP 35
18565: ST_TO_ADDR
// uc_nation := nation_american ;
18566: LD_ADDR_OWVAR 21
18570: PUSH
18571: LD_INT 1
18573: ST_TO_ADDR
// rndclass := Rand ( 1 , 3 ) ;
18574: LD_ADDR_VAR 0 2
18578: PUSH
18579: LD_INT 1
18581: PPUSH
18582: LD_INT 3
18584: PPUSH
18585: CALL_OW 12
18589: ST_TO_ADDR
// case rndclass of 1 :
18590: LD_VAR 0 2
18594: PUSH
18595: LD_INT 1
18597: DOUBLE
18598: EQUAL
18599: IFTRUE 18603
18601: GO 18621
18603: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; 2 :
18604: LD_INT 0
18606: PPUSH
18607: LD_INT 1
18609: PPUSH
18610: LD_EXP 74
18614: PPUSH
18615: CALL_OW 380
18619: GO 18674
18621: LD_INT 2
18623: DOUBLE
18624: EQUAL
18625: IFTRUE 18629
18627: GO 18647
18629: POP
// PrepareHuman ( 0 , class_sniper , am_attack_skill ) ; 3 :
18630: LD_INT 0
18632: PPUSH
18633: LD_INT 5
18635: PPUSH
18636: LD_EXP 74
18640: PPUSH
18641: CALL_OW 380
18645: GO 18674
18647: LD_INT 3
18649: DOUBLE
18650: EQUAL
18651: IFTRUE 18655
18653: GO 18673
18655: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; end ;
18656: LD_INT 0
18658: PPUSH
18659: LD_INT 1
18661: PPUSH
18662: LD_EXP 74
18666: PPUSH
18667: CALL_OW 380
18671: GO 18674
18673: POP
// hc_name :=  ;
18674: LD_ADDR_OWVAR 26
18678: PUSH
18679: LD_STRING 
18681: ST_TO_ADDR
// amattack := amattack ^ CreateHuman ;
18682: LD_ADDR_EXP 27
18686: PUSH
18687: LD_EXP 27
18691: PUSH
18692: CALL_OW 44
18696: ADD
18697: ST_TO_ADDR
// Wait ( 1 ) ;
18698: LD_INT 1
18700: PPUSH
18701: CALL_OW 67
// end ;
18705: GO 18553
18707: POP
18708: POP
// end ;
18709: LD_VAR 0 1
18713: RET
// function place_am_attack ; var i , reg_id ; begin
18714: LD_INT 0
18716: PPUSH
18717: PPUSH
18718: PPUSH
// for i := 1 to amcount do
18719: LD_ADDR_VAR 0 2
18723: PUSH
18724: DOUBLE
18725: LD_INT 1
18727: DEC
18728: ST_TO_ADDR
18729: LD_LOC 17
18733: PUSH
18734: FOR_TO
18735: IFFALSE 18767
// begin PlaceUnitArea ( amattack [ i ] , AmEnterArea , false ) ;
18737: LD_EXP 27
18741: PUSH
18742: LD_VAR 0 2
18746: ARRAY
18747: PPUSH
18748: LD_INT 9
18750: PPUSH
18751: LD_INT 0
18753: PPUSH
18754: CALL_OW 49
// Wait ( 1 ) ;
18758: LD_INT 1
18760: PPUSH
18761: CALL_OW 67
// end ;
18765: GO 18734
18767: POP
18768: POP
// reg_id := McRegistry ( usa , [ [ mc_reg_area_to_guard , WholeMapArea ] , - mc_reg_only_important , mc_reg_ignore_fog ] ) ;
18769: LD_ADDR_VAR 0 3
18773: PUSH
18774: LD_EXP 35
18778: PPUSH
18779: LD_INT 2
18781: PUSH
18782: LD_INT 10
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 8
18791: NEG
18792: PUSH
18793: LD_INT 7
18795: PUSH
18796: EMPTY
18797: LIST
18798: LIST
18799: LIST
18800: PPUSH
18801: CALL_OW 399
18805: ST_TO_ADDR
// McAttack ( 100 , reg_id , amattack , [ mc_no_stop , mc_pat_aggresive , mc_murder ] ) ;
18806: LD_INT 100
18808: PPUSH
18809: LD_VAR 0 3
18813: PPUSH
18814: LD_EXP 27
18818: PPUSH
18819: LD_INT 10
18821: PUSH
18822: LD_INT 11
18824: PUSH
18825: LD_INT 12
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: LIST
18832: PPUSH
18833: CALL_OW 402
// end ;
18837: LD_VAR 0 1
18841: RET
// every 0 0$1 marked 501 do
18842: GO 18844
18844: DISABLE
// begin AmAttackStarted := true ;
18845: LD_ADDR_EXP 71
18849: PUSH
18850: LD_INT 1
18852: ST_TO_ADDR
// D_AmAttackStart ;
18853: CALL 7094 0 0
// Wait ( 0 0$15 ) ;
18857: LD_INT 525
18859: PPUSH
18860: CALL_OW 67
// place_am_attack ;
18864: CALL 18714 0 0
// enable ( 502 ) ;
18868: LD_INT 502
18870: ENABLE_MARKED
// end ;
18871: END
// every 0 0$10 marked 502 do
18872: GO 18874
18874: DISABLE
// begin if amattack = [ ] then
18875: LD_EXP 27
18879: PUSH
18880: EMPTY
18881: EQUAL
18882: IFFALSE 18899
// begin disable ;
18884: DISABLE
// AmAttackDone := true ;
18885: LD_ADDR_EXP 64
18889: PUSH
18890: LD_INT 1
18892: ST_TO_ADDR
// D_AmAttackFin ;
18893: CALL 7183 0 0
// end else
18897: GO 18900
// enable ;
18899: ENABLE
// end ; end_of_file
18900: END
// every 0 0$2 + 0 0$0.1 do
18901: GO 18903
18903: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
18904: LD_INT 22
18906: PUSH
18907: LD_INT 3
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: LD_INT 2
18916: PUSH
18917: LD_INT 25
18919: PUSH
18920: LD_INT 12
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PUSH
18927: LD_INT 25
18929: PUSH
18930: LD_INT 16
18932: PUSH
18933: EMPTY
18934: LIST
18935: LIST
18936: PUSH
18937: LD_INT 25
18939: PUSH
18940: LD_INT 15
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: PUSH
18947: LD_INT 25
18949: PUSH
18950: LD_INT 17
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: PPUSH
18968: CALL_OW 69
18972: PUSH
18973: LD_INT 22
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: EMPTY
18980: LIST
18981: LIST
18982: PUSH
18983: LD_INT 21
18985: PUSH
18986: LD_INT 1
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: PUSH
18993: LD_INT 3
18995: PUSH
18996: LD_INT 2
18998: PUSH
18999: LD_INT 25
19001: PUSH
19002: LD_INT 12
19004: PUSH
19005: EMPTY
19006: LIST
19007: LIST
19008: PUSH
19009: LD_INT 25
19011: PUSH
19012: LD_INT 16
19014: PUSH
19015: EMPTY
19016: LIST
19017: LIST
19018: PUSH
19019: LD_INT 25
19021: PUSH
19022: LD_INT 15
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: PUSH
19029: LD_INT 25
19031: PUSH
19032: LD_INT 17
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: LIST
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: LIST
19054: PPUSH
19055: CALL_OW 69
19059: GREATER
19060: IFFALSE 19071
// begin SetAchievement ( ACH_POTA ) ;
19062: LD_STRING ACH_POTA
19064: PPUSH
19065: CALL_OW 543
// exit ;
19069: GO 19072
// end ; enable ;
19071: ENABLE
// end ;
19072: END
// export function SA_OnLegionHandoverToUPF ; begin
19073: LD_INT 0
19075: PPUSH
// SetAchievement ( ACH_SC ) ;
19076: LD_STRING ACH_SC
19078: PPUSH
19079: CALL_OW 543
// end ;
19083: LD_VAR 0 1
19087: RET
// export function SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ; begin
19088: LD_INT 0
19090: PPUSH
// SetAchievement ( ACH_GAME ) ;
19091: LD_STRING ACH_GAME
19093: PPUSH
19094: CALL_OW 543
// end ;
19098: LD_VAR 0 1
19102: RET

// export Burlak , Popov , Belkov , Kirilenkova , Gnyevko , Kapitsova , Dietrich , Gleb , Petrosyan , Kuzmov , Heike , Kovalyuk , Kurt , Mercenary1 , Scholtze , ASoldier1 , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Dolgov , Xavier , other , player_units , amattack , depot_build , depotX , depotY , you , ally , arab , merc , usa , GenscherBetrayed , HeikeCaptured , HeikeKilled , MercPaid , MercHandedOver , MercWillBeHandedOver , MercHandoverDone , MercHandoverArabsSpawned , MercAccepted , HeikeDismissed , PopovAsked , HuntingAccepted , BuildingsDone , TurretsDone , WeaponsDone , TechnoDone , MortarDone , GalleryBuild , AvailableWeapons , AvailableBuildings , AvailableTechno , FreeMan , FreeWoman , FreeTimeGranted , Masha , CompVehConstructed , LimitTeleportResearched , LimitTeleportTested , AmAttackDone , HeikeSend , GalleryAsked , HuntingAsked , FreetimeAsked , MortarAsked , MashaAsked , AmAttackStarted , hunter , speed , am_attack_skill , weaker , stronger , countdown , pocetmercenaries , snipers_positions , ar_human , MercenaryWillBeHealen , KurtWillBeHealen , WasSelected , CountTrees , GenCount , disabled2 , disabled3 , disabled4 , disabled5 , disabled6 , disabled7 , disabled8 , disabled9 , disabled102 ; export testing ; function read_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// you := 3 ;
   4: LD_ADDR_EXP 31
   8: PUSH
   9: LD_INT 3
  11: ST_TO_ADDR
// ally := 6 ;
  12: LD_ADDR_EXP 32
  16: PUSH
  17: LD_INT 6
  19: ST_TO_ADDR
// arab := 2 ;
  20: LD_ADDR_EXP 33
  24: PUSH
  25: LD_INT 2
  27: ST_TO_ADDR
// merc := 5 ;
  28: LD_ADDR_EXP 34
  32: PUSH
  33: LD_INT 5
  35: ST_TO_ADDR
// usa := 1 ;
  36: LD_ADDR_EXP 35
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// HeikeCaptured := LoadVariable ( HeikeCaptured , true ) ;
  44: LD_ADDR_EXP 37
  48: PUSH
  49: LD_STRING HeikeCaptured
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: CALL_OW 30
  59: ST_TO_ADDR
// SetAttitude ( you , ally , att_friend , true ) ;
  60: LD_EXP 31
  64: PPUSH
  65: LD_EXP 32
  69: PPUSH
  70: LD_INT 1
  72: PPUSH
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 80
// SetAttitude ( you , merc , att_neutral , true ) ;
  80: LD_EXP 31
  84: PPUSH
  85: LD_EXP 34
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: CALL_OW 80
// SetAttitude ( you , arab , att_neutral , true ) ;
 100: LD_EXP 31
 104: PPUSH
 105: LD_EXP 33
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: CALL_OW 80
// SetAttitude ( you , usa , att_enemy , true ) ;
 120: LD_EXP 31
 124: PPUSH
 125: LD_EXP 35
 129: PPUSH
 130: LD_INT 2
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 80
// SetAttitude ( ally , merc , att_friend , true ) ;
 140: LD_EXP 32
 144: PPUSH
 145: LD_EXP 34
 149: PPUSH
 150: LD_INT 1
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 80
// SetAttitude ( ally , arab , att_friend , true ) ;
 160: LD_EXP 32
 164: PPUSH
 165: LD_EXP 33
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 80
// SetAttitude ( ally , usa , att_friend , true ) ;
 180: LD_EXP 32
 184: PPUSH
 185: LD_EXP 35
 189: PPUSH
 190: LD_INT 1
 192: PPUSH
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 80
// SetAttitude ( merc , usa , att_neutral , true ) ;
 200: LD_EXP 34
 204: PPUSH
 205: LD_EXP 35
 209: PPUSH
 210: LD_INT 0
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: CALL_OW 80
// SetAttitude ( arab , usa , att_neutral , true ) ;
 220: LD_EXP 33
 224: PPUSH
 225: LD_EXP 35
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 1
 235: PPUSH
 236: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 240: LD_EXP 32
 244: PPUSH
 245: LD_EXP 31
 249: PPUSH
 250: CALL_OW 343
// HeikeDismissed := false ;
 254: LD_ADDR_EXP 45
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// MercAccepted := false ;
 262: LD_ADDR_EXP 44
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// MercPaid := false ;
 270: LD_ADDR_EXP 39
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// BuildingsDone := false ;
 278: LD_ADDR_EXP 48
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// WeaponsDone := false ;
 286: LD_ADDR_EXP 50
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// TechnoDone := false ;
 294: LD_ADDR_EXP 51
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// MortarDone := false ;
 302: LD_ADDR_EXP 52
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// TurretsDone := false ;
 310: LD_ADDR_EXP 49
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// GalleryBuild := false ;
 318: LD_ADDR_EXP 53
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// CompVehConstructed := false ;
 326: LD_ADDR_EXP 61
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// LimitTeleportResearched := false ;
 334: LD_ADDR_EXP 62
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// LimitTeleportTested := false ;
 342: LD_ADDR_EXP 63
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// AmAttackDone := false ;
 350: LD_ADDR_EXP 64
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// HeikeSend := false ;
 358: LD_ADDR_EXP 65
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// HeikeKilled := false ;
 366: LD_ADDR_EXP 38
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// Masha := 0 ;
 374: LD_ADDR_EXP 60
 378: PUSH
 379: LD_INT 0
 381: ST_TO_ADDR
// GalleryAsked := false ;
 382: LD_ADDR_EXP 66
 386: PUSH
 387: LD_INT 0
 389: ST_TO_ADDR
// HuntingAsked := false ;
 390: LD_ADDR_EXP 67
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// FreetimeAsked := false ;
 398: LD_ADDR_EXP 68
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// MashaAsked := false ;
 406: LD_ADDR_EXP 70
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// GenscherBetrayed := false ;
 414: LD_ADDR_EXP 36
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// AvailableWeapons := [ 42 , 43 , 44 , 45 , 46 ] ;
 422: LD_ADDR_EXP 54
 426: PUSH
 427: LD_INT 42
 429: PUSH
 430: LD_INT 43
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: LD_INT 45
 438: PUSH
 439: LD_INT 46
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// AvailableBuildings = [ ] ;
 449: LD_ADDR_EXP 55
 453: PUSH
 454: EMPTY
 455: ST_TO_ADDR
// for i := 0 to 50 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 0
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 50
 468: PUSH
 469: FOR_TO
 470: IFFALSE 510
// if GetRestrict ( i , you ) = 1 then
 472: LD_VAR 0 2
 476: PPUSH
 477: LD_EXP 31
 481: PPUSH
 482: CALL_OW 323
 486: PUSH
 487: LD_INT 1
 489: EQUAL
 490: IFFALSE 508
// AvailableBuildings := AvailableBuildings ^ i ;
 492: LD_ADDR_EXP 55
 496: PUSH
 497: LD_EXP 55
 501: PUSH
 502: LD_VAR 0 2
 506: ADD
 507: ST_TO_ADDR
 508: GO 469
 510: POP
 511: POP
// AvailableBuildings := AvailableBuildings diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
 512: LD_ADDR_EXP 55
 516: PUSH
 517: LD_EXP 55
 521: PUSH
 522: LD_INT 0
 524: PUSH
 525: LD_INT 2
 527: PUSH
 528: LD_INT 4
 530: PUSH
 531: LD_INT 6
 533: PUSH
 534: LD_INT 7
 536: PUSH
 537: LD_INT 8
 539: PUSH
 540: LD_INT 9
 542: PUSH
 543: LD_INT 10
 545: PUSH
 546: LD_INT 11
 548: PUSH
 549: LD_INT 12
 551: PUSH
 552: LD_INT 14
 554: PUSH
 555: LD_INT 22
 557: PUSH
 558: LD_INT 31
 560: PUSH
 561: LD_INT 32
 563: PUSH
 564: LD_INT 33
 566: PUSH
 567: LD_INT 39
 569: PUSH
 570: LD_INT 40
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: DIFF
 592: ST_TO_ADDR
// AvailableTechno = [ ] ;
 593: LD_ADDR_EXP 56
 597: PUSH
 598: EMPTY
 599: ST_TO_ADDR
// for i := 0 to 72 do
 600: LD_ADDR_VAR 0 2
 604: PUSH
 605: DOUBLE
 606: LD_INT 0
 608: DEC
 609: ST_TO_ADDR
 610: LD_INT 72
 612: PUSH
 613: FOR_TO
 614: IFFALSE 654
// if GetTech ( i , you ) = 1 then
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_EXP 31
 625: PPUSH
 626: CALL_OW 321
 630: PUSH
 631: LD_INT 1
 633: EQUAL
 634: IFFALSE 652
// AvailableTechno := AvailableTechno ^ i ;
 636: LD_ADDR_EXP 56
 640: PUSH
 641: LD_EXP 56
 645: PUSH
 646: LD_VAR 0 2
 650: ADD
 651: ST_TO_ADDR
 652: GO 613
 654: POP
 655: POP
// AvailableTechno := AvailableTechno diff 72 ;
 656: LD_ADDR_EXP 56
 660: PUSH
 661: LD_EXP 56
 665: PUSH
 666: LD_INT 72
 668: DIFF
 669: ST_TO_ADDR
// end ;
 670: LD_VAR 0 1
 674: RET
// function set_difficulty ; begin
 675: LD_INT 0
 677: PPUSH
// countdown := [ 2 2$0 , 1 1$30 , 1 1$0 ] [ difficulty ] ;
 678: LD_ADDR_EXP 77
 682: PUSH
 683: LD_INT 4200
 685: PUSH
 686: LD_INT 3150
 688: PUSH
 689: LD_INT 2100
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_OWVAR 67
 701: ARRAY
 702: ST_TO_ADDR
// pocetmercenaries := [ 20 , 40 , 60 ] [ difficulty ] ;
 703: LD_ADDR_EXP 78
 707: PUSH
 708: LD_INT 20
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 60
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: ST_TO_ADDR
// am_attack_skill := [ 4 , 6 , 8 ] [ difficulty ] ;
 728: LD_ADDR_EXP 74
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: LD_INT 6
 738: PUSH
 739: LD_INT 8
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_OWVAR 67
 751: ARRAY
 752: ST_TO_ADDR
// weaker := [ 10 , 15 , 20 ] [ difficulty ] ;
 753: LD_ADDR_EXP 75
 757: PUSH
 758: LD_INT 10
 760: PUSH
 761: LD_INT 15
 763: PUSH
 764: LD_INT 20
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_OWVAR 67
 776: ARRAY
 777: ST_TO_ADDR
// stronger := [ 20 , 25 , 30 ] [ difficulty ] ;
 778: LD_ADDR_EXP 76
 782: PUSH
 783: LD_INT 20
 785: PUSH
 786: LD_INT 25
 788: PUSH
 789: LD_INT 30
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: PUSH
 797: LD_OWVAR 67
 801: ARRAY
 802: ST_TO_ADDR
// speed := [ 60 60$0 , 45 45$0 , 38 38$0 ] [ difficulty ] ;
 803: LD_ADDR_EXP 73
 807: PUSH
 808: LD_INT 126000
 810: PUSH
 811: LD_INT 94500
 813: PUSH
 814: LD_INT 79800
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// snipers_positions := [ [ [ 115 , 77 ] , [ 127 , 67 ] , [ 15 , 2 ] , [ 71 , 1 ] ] , [ [ 120 , 70 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] , [ [ 115 , 77 ] , [ 127 , 67 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] ] [ difficulty ] ;
 828: LD_ADDR_EXP 79
 832: PUSH
 833: LD_INT 115
 835: PUSH
 836: LD_INT 77
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 127
 845: PUSH
 846: LD_INT 67
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 15
 855: PUSH
 856: LD_INT 2
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 71
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 120
 881: PUSH
 882: LD_INT 70
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 11
 891: PUSH
 892: LD_INT 20
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 50
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 71
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_INT 115
 938: PUSH
 939: LD_INT 77
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 127
 948: PUSH
 949: LD_INT 67
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 11
 958: PUSH
 959: LD_INT 20
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: PUSH
 966: LD_INT 15
 968: PUSH
 969: LD_INT 2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 50
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 71
 988: PUSH
 989: LD_INT 1
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: ST_TO_ADDR
// end ;
1015: LD_VAR 0 1
1019: RET
// function nacti_osobu ( ident ) ; begin
1020: LD_INT 0
1022: PPUSH
// if CheckCharacterSet ( ident ) then
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 29
1032: IFFALSE 1051
// result := CreateCharacter ( ident ) else
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: LD_VAR 0 1
1043: PPUSH
1044: CALL_OW 34
1048: ST_TO_ADDR
1049: GO 1059
// result := 0 ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// function create_people ; var def , i , x , y , un ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
1068: PPUSH
1069: PPUSH
1070: PPUSH
1071: PPUSH
// uc_side = you ;
1072: LD_ADDR_OWVAR 20
1076: PUSH
1077: LD_EXP 31
1081: ST_TO_ADDR
// uc_nation := nation_russian ;
1082: LD_ADDR_OWVAR 21
1086: PUSH
1087: LD_INT 3
1089: ST_TO_ADDR
// other := CreateCharacterSet ( survivors1 ) ;
1090: LD_ADDR_EXP 25
1094: PUSH
1095: LD_STRING survivors1
1097: PPUSH
1098: CALL_OW 31
1102: ST_TO_ADDR
// other := other union CreateCharacterSet ( survivors2 ) ;
1103: LD_ADDR_EXP 25
1107: PUSH
1108: LD_EXP 25
1112: PUSH
1113: LD_STRING survivors2
1115: PPUSH
1116: CALL_OW 31
1120: UNION
1121: ST_TO_ADDR
// other := other diff 0 ;
1122: LD_ADDR_EXP 25
1126: PUSH
1127: LD_EXP 25
1131: PUSH
1132: LD_INT 0
1134: DIFF
1135: ST_TO_ADDR
// if not testing then
1136: LD_EXP 95
1140: NOT
1141: IFFALSE 1158
// Burlak := nacti_osobu ( Burlak ) else
1143: LD_ADDR_EXP 1
1147: PUSH
1148: LD_STRING Burlak
1150: PPUSH
1151: CALL 1020 0 1
1155: ST_TO_ADDR
1156: GO 1186
// begin PrepareMechanic ( sex_male , 7 ) ;
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 383
// hc_name = Burlak ;
1168: LD_ADDR_OWVAR 26
1172: PUSH
1173: LD_STRING Burlak
1175: ST_TO_ADDR
// Burlak = CreateHuman ;
1176: LD_ADDR_EXP 1
1180: PUSH
1181: CALL_OW 44
1185: ST_TO_ADDR
// end ; Belkov := nacti_osobu ( Belkov ) ;
1186: LD_ADDR_EXP 3
1190: PUSH
1191: LD_STRING Belkov
1193: PPUSH
1194: CALL 1020 0 1
1198: ST_TO_ADDR
// Gnyevko := nacti_osobu ( Gnyevko ) ;
1199: LD_ADDR_EXP 5
1203: PUSH
1204: LD_STRING Gnyevko
1206: PPUSH
1207: CALL 1020 0 1
1211: ST_TO_ADDR
// Kirilenkova := nacti_osobu ( Kirilenkova ) ;
1212: LD_ADDR_EXP 4
1216: PUSH
1217: LD_STRING Kirilenkova
1219: PPUSH
1220: CALL 1020 0 1
1224: ST_TO_ADDR
// Kovalyuk := nacti_osobu ( Kovalyuk ) ;
1225: LD_ADDR_EXP 12
1229: PUSH
1230: LD_STRING Kovalyuk
1232: PPUSH
1233: CALL 1020 0 1
1237: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
1238: LD_ADDR_EXP 2
1242: PUSH
1243: LD_STRING Popov
1245: PPUSH
1246: CALL_OW 25
1250: ST_TO_ADDR
// Scholtze := nacti_osobu ( Scholtze ) ;
1251: LD_ADDR_EXP 15
1255: PUSH
1256: LD_STRING Scholtze
1258: PPUSH
1259: CALL 1020 0 1
1263: ST_TO_ADDR
// Kuzmov := nacti_osobu ( Kuzmov ) ;
1264: LD_ADDR_EXP 10
1268: PUSH
1269: LD_STRING Kuzmov
1271: PPUSH
1272: CALL 1020 0 1
1276: ST_TO_ADDR
// Karamazov := nacti_osobu ( Karamazov ) ;
1277: LD_ADDR_EXP 17
1281: PUSH
1282: LD_STRING Karamazov
1284: PPUSH
1285: CALL 1020 0 1
1289: ST_TO_ADDR
// Petrovova := nacti_osobu ( Petrovova ) ;
1290: LD_ADDR_EXP 21
1294: PUSH
1295: LD_STRING Petrovova
1297: PPUSH
1298: CALL 1020 0 1
1302: ST_TO_ADDR
// Gleb := nacti_osobu ( Gleb ) ;
1303: LD_ADDR_EXP 8
1307: PUSH
1308: LD_STRING Gleb
1310: PPUSH
1311: CALL 1020 0 1
1315: ST_TO_ADDR
// Petrosyan := nacti_osobu ( Petrosyan ) ;
1316: LD_ADDR_EXP 9
1320: PUSH
1321: LD_STRING Petrosyan
1323: PPUSH
1324: CALL 1020 0 1
1328: ST_TO_ADDR
// Lipshchin := nacti_osobu ( Lipshchin ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Lipshchin
1336: PPUSH
1337: CALL 1020 0 1
1341: ST_TO_ADDR
// Titov := nacti_osobu ( Titov ) ;
1342: LD_ADDR_EXP 18
1346: PUSH
1347: LD_STRING Titov
1349: PPUSH
1350: CALL 1020 0 1
1354: ST_TO_ADDR
// Dolgov := nacti_osobu ( Dolgov ) ;
1355: LD_ADDR_EXP 23
1359: PUSH
1360: LD_STRING Dolgov
1362: PPUSH
1363: CALL 1020 0 1
1367: ST_TO_ADDR
// Xavier := nacti_osobu ( Xavier ) ;
1368: LD_ADDR_EXP 24
1372: PUSH
1373: LD_STRING Xavier
1375: PPUSH
1376: CALL 1020 0 1
1380: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1381: LD_ADDR_EXP 19
1385: PUSH
1386: LD_STRING Oblukov
1388: PPUSH
1389: CALL_OW 25
1393: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
1394: LD_ADDR_EXP 20
1398: PUSH
1399: LD_STRING Kozlov
1401: PPUSH
1402: CALL_OW 25
1406: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1407: LD_ADDR_EXP 6
1411: PUSH
1412: LD_STRING Kapitsova
1414: PPUSH
1415: CALL_OW 25
1419: ST_TO_ADDR
// uc_side = ally ;
1420: LD_ADDR_OWVAR 20
1424: PUSH
1425: LD_EXP 32
1429: ST_TO_ADDR
// uc_nation := nation_arabian ;
1430: LD_ADDR_OWVAR 21
1434: PUSH
1435: LD_INT 2
1437: ST_TO_ADDR
// if not testing then
1438: LD_EXP 95
1442: NOT
1443: IFFALSE 1460
// Heike := nacti_osobu ( Heike ) else
1445: LD_ADDR_EXP 11
1449: PUSH
1450: LD_STRING Heike
1452: PPUSH
1453: CALL 1020 0 1
1457: ST_TO_ADDR
1458: GO 1488
// begin PrepareSoldier ( sex_female , 7 ) ;
1460: LD_INT 2
1462: PPUSH
1463: LD_INT 7
1465: PPUSH
1466: CALL_OW 381
// hc_name = Heike ;
1470: LD_ADDR_OWVAR 26
1474: PUSH
1475: LD_STRING Heike
1477: ST_TO_ADDR
// Heike = CreateHuman ;
1478: LD_ADDR_EXP 11
1482: PUSH
1483: CALL_OW 44
1487: ST_TO_ADDR
// end ; SetClass ( Heike , class_engineer ) ;
1488: LD_EXP 11
1492: PPUSH
1493: LD_INT 2
1495: PPUSH
1496: CALL_OW 336
// uc_side = arab ;
1500: LD_ADDR_OWVAR 20
1504: PUSH
1505: LD_EXP 33
1509: ST_TO_ADDR
// uc_nation := nation_arabian ;
1510: LD_ADDR_OWVAR 21
1514: PUSH
1515: LD_INT 2
1517: ST_TO_ADDR
// Dietrich := NewCharacter ( Dietrich ) ;
1518: LD_ADDR_EXP 7
1522: PUSH
1523: LD_STRING Dietrich
1525: PPUSH
1526: CALL_OW 25
1530: ST_TO_ADDR
// uc_side = merc ;
1531: LD_ADDR_OWVAR 20
1535: PUSH
1536: LD_EXP 34
1540: ST_TO_ADDR
// uc_nation := nation_arabian ;
1541: LD_ADDR_OWVAR 21
1545: PUSH
1546: LD_INT 2
1548: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
1549: LD_ADDR_EXP 13
1553: PUSH
1554: LD_STRING Kurt
1556: PPUSH
1557: CALL_OW 25
1561: ST_TO_ADDR
// PrepareHuman ( sex_male , class_engineer , 2 ) ;
1562: LD_INT 1
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: CALL_OW 380
// hc_name :=  ;
1575: LD_ADDR_OWVAR 26
1579: PUSH
1580: LD_STRING 
1582: ST_TO_ADDR
// Mercenary1 := CreateHuman ;
1583: LD_ADDR_EXP 14
1587: PUSH
1588: CALL_OW 44
1592: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 1 ) ;
1593: LD_INT 1
1595: PPUSH
1596: LD_INT 1
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 380
// hc_name :=  ;
1606: LD_ADDR_OWVAR 26
1610: PUSH
1611: LD_STRING 
1613: ST_TO_ADDR
// ASoldier1 := CreateHuman ;
1614: LD_ADDR_EXP 16
1618: PUSH
1619: CALL_OW 44
1623: ST_TO_ADDR
// player_units := ( [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) diff [ 0 ] ;
1624: LD_ADDR_EXP 26
1628: PUSH
1629: LD_EXP 1
1633: PUSH
1634: LD_EXP 3
1638: PUSH
1639: LD_EXP 4
1643: PUSH
1644: LD_EXP 5
1648: PUSH
1649: LD_EXP 6
1653: PUSH
1654: LD_EXP 8
1658: PUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_EXP 12
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 17
1678: PUSH
1679: LD_EXP 18
1683: PUSH
1684: LD_EXP 19
1688: PUSH
1689: LD_EXP 20
1693: PUSH
1694: LD_EXP 21
1698: PUSH
1699: LD_EXP 22
1703: PUSH
1704: LD_EXP 9
1708: PUSH
1709: LD_EXP 23
1713: PUSH
1714: LD_EXP 24
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_INT 0
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: ST_TO_ADDR
// for i = 1 to 2 do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: DOUBLE
1752: LD_INT 1
1754: DEC
1755: ST_TO_ADDR
1756: LD_INT 2
1758: PUSH
1759: FOR_TO
1760: IFFALSE 1814
// if other >= i and other [ i ] > 0 then
1762: LD_EXP 25
1766: PUSH
1767: LD_VAR 0 3
1771: GREATEREQUAL
1772: PUSH
1773: LD_EXP 25
1777: PUSH
1778: LD_VAR 0 3
1782: ARRAY
1783: PUSH
1784: LD_INT 0
1786: GREATER
1787: AND
1788: IFFALSE 1812
// player_units = player_units ^ other [ i ] ;
1790: LD_ADDR_EXP 26
1794: PUSH
1795: LD_EXP 26
1799: PUSH
1800: LD_EXP 25
1804: PUSH
1805: LD_VAR 0 3
1809: ARRAY
1810: ADD
1811: ST_TO_ADDR
1812: GO 1759
1814: POP
1815: POP
// uc_side = you ;
1816: LD_ADDR_OWVAR 20
1820: PUSH
1821: LD_EXP 31
1825: ST_TO_ADDR
// uc_nation := nation_russian ;
1826: LD_ADDR_OWVAR 21
1830: PUSH
1831: LD_INT 3
1833: ST_TO_ADDR
// if 0 + player_units < 15 then
1834: LD_INT 0
1836: PUSH
1837: LD_EXP 26
1841: PLUS
1842: PUSH
1843: LD_INT 15
1845: LESS
1846: IFFALSE 1910
// for i := 1 to 0 + other do
1848: LD_ADDR_VAR 0 3
1852: PUSH
1853: DOUBLE
1854: LD_INT 1
1856: DEC
1857: ST_TO_ADDR
1858: LD_INT 0
1860: PUSH
1861: LD_EXP 25
1865: PLUS
1866: PUSH
1867: FOR_TO
1868: IFFALSE 1908
// if 0 + player_units < 15 then
1870: LD_INT 0
1872: PUSH
1873: LD_EXP 26
1877: PLUS
1878: PUSH
1879: LD_INT 15
1881: LESS
1882: IFFALSE 1906
// player_units := player_units ^ other [ i ] ;
1884: LD_ADDR_EXP 26
1888: PUSH
1889: LD_EXP 26
1893: PUSH
1894: LD_EXP 25
1898: PUSH
1899: LD_VAR 0 3
1903: ARRAY
1904: ADD
1905: ST_TO_ADDR
1906: GO 1867
1908: POP
1909: POP
// if 0 + player_units < 15 then
1910: LD_INT 0
1912: PUSH
1913: LD_EXP 26
1917: PLUS
1918: PUSH
1919: LD_INT 15
1921: LESS
1922: IFFALSE 1987
// for i := 1 to 15 - player_units do
1924: LD_ADDR_VAR 0 3
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_INT 15
1936: PUSH
1937: LD_EXP 26
1941: MINUS
1942: PUSH
1943: FOR_TO
1944: IFFALSE 1985
// begin PrepareHuman ( 0 , 0 , 4 ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 0
1951: PPUSH
1952: LD_INT 4
1954: PPUSH
1955: CALL_OW 380
// hc_name :=  ;
1959: LD_ADDR_OWVAR 26
1963: PUSH
1964: LD_STRING 
1966: ST_TO_ADDR
// player_units := player_units ^ CreateHuman ;
1967: LD_ADDR_EXP 26
1971: PUSH
1972: LD_EXP 26
1976: PUSH
1977: CALL_OW 44
1981: ADD
1982: ST_TO_ADDR
// end ;
1983: GO 1943
1985: POP
1986: POP
// Randomize ;
1987: CALL_OW 10
// RandomizeAll ;
1991: CALL_OW 11
// for un in player_units do
1995: LD_ADDR_VAR 0 6
1999: PUSH
2000: LD_EXP 26
2004: PUSH
2005: FOR_IN
2006: IFFALSE 2025
// PlaceUnitArea ( un , EnterArea , false ) ;
2008: LD_VAR 0 6
2012: PPUSH
2013: LD_INT 3
2015: PPUSH
2016: LD_INT 0
2018: PPUSH
2019: CALL_OW 49
2023: GO 2005
2025: POP
2026: POP
// end ;
2027: LD_VAR 0 1
2031: RET
// function create_vehicles ; var i , auto ; begin
2032: LD_INT 0
2034: PPUSH
2035: PPUSH
2036: PPUSH
// for i := 1 to 5 do
2037: LD_ADDR_VAR 0 2
2041: PUSH
2042: DOUBLE
2043: LD_INT 1
2045: DEC
2046: ST_TO_ADDR
2047: LD_INT 5
2049: PUSH
2050: FOR_TO
2051: IFFALSE 2208
// begin uc_side := you ;
2053: LD_ADDR_OWVAR 20
2057: PUSH
2058: LD_EXP 31
2062: ST_TO_ADDR
// uc_nation := nation_russian ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 3
2070: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2071: LD_ADDR_OWVAR 24
2075: PUSH
2076: LD_INT 0
2078: PPUSH
2079: LD_INT 5
2081: PPUSH
2082: CALL_OW 12
2086: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2087: LD_ADDR_OWVAR 37
2091: PUSH
2092: LD_INT 21
2094: ST_TO_ADDR
// vc_engine := engine_combustion ;
2095: LD_ADDR_OWVAR 39
2099: PUSH
2100: LD_INT 1
2102: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2103: LD_ADDR_OWVAR 40
2107: PUSH
2108: LD_INT 51
2110: ST_TO_ADDR
// vc_control := control_manual ;
2111: LD_ADDR_OWVAR 38
2115: PUSH
2116: LD_INT 1
2118: ST_TO_ADDR
// auto := CreateVehicle ;
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: CALL_OW 45
2128: ST_TO_ADDR
// if i <= 4 then
2129: LD_VAR 0 2
2133: PUSH
2134: LD_INT 4
2136: LESSEQUAL
2137: IFFALSE 2156
// SetCargo ( auto , mat_cans , 100 ) else
2139: LD_VAR 0 3
2143: PPUSH
2144: LD_INT 1
2146: PPUSH
2147: LD_INT 100
2149: PPUSH
2150: CALL_OW 290
2154: GO 2171
// SetCargo ( auto , mat_oil , 100 ) ;
2156: LD_VAR 0 3
2160: PPUSH
2161: LD_INT 2
2163: PPUSH
2164: LD_INT 100
2166: PPUSH
2167: CALL_OW 290
// SetFuel ( auto , Rand ( 40 , 80 ) ) ;
2171: LD_VAR 0 3
2175: PPUSH
2176: LD_INT 40
2178: PPUSH
2179: LD_INT 80
2181: PPUSH
2182: CALL_OW 12
2186: PPUSH
2187: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2191: LD_VAR 0 3
2195: PPUSH
2196: LD_INT 3
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 49
// end ;
2206: GO 2050
2208: POP
2209: POP
// uc_side := you ;
2210: LD_ADDR_OWVAR 20
2214: PUSH
2215: LD_EXP 31
2219: ST_TO_ADDR
// uc_nation := nation_russian ;
2220: LD_ADDR_OWVAR 21
2224: PUSH
2225: LD_INT 3
2227: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2228: LD_ADDR_OWVAR 24
2232: PUSH
2233: LD_INT 0
2235: PPUSH
2236: LD_INT 5
2238: PPUSH
2239: CALL_OW 12
2243: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 22
2251: ST_TO_ADDR
// vc_engine := engine_combustion ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 1
2259: ST_TO_ADDR
// vc_weapon := ru_crane ;
2260: LD_ADDR_OWVAR 40
2264: PUSH
2265: LD_INT 52
2267: ST_TO_ADDR
// vc_control := control_manual ;
2268: LD_ADDR_OWVAR 38
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// auto := CreateVehicle ;
2276: LD_ADDR_VAR 0 3
2280: PUSH
2281: CALL_OW 45
2285: ST_TO_ADDR
// SetFuel ( auto , Rand ( 90 , 100 ) ) ;
2286: LD_VAR 0 3
2290: PPUSH
2291: LD_INT 90
2293: PPUSH
2294: LD_INT 100
2296: PPUSH
2297: CALL_OW 12
2301: PPUSH
2302: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2306: LD_VAR 0 3
2310: PPUSH
2311: LD_INT 3
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 49
// for i := 1 to 3 do
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 3
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2450
// begin uc_side := you ;
2337: LD_ADDR_OWVAR 20
2341: PUSH
2342: LD_EXP 31
2346: ST_TO_ADDR
// uc_nation := nation_russian ;
2347: LD_ADDR_OWVAR 21
2351: PUSH
2352: LD_INT 3
2354: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2355: LD_ADDR_OWVAR 24
2359: PUSH
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 5
2365: PPUSH
2366: CALL_OW 12
2370: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2371: LD_ADDR_OWVAR 37
2375: PUSH
2376: LD_INT 24
2378: ST_TO_ADDR
// vc_engine := engine_combustion ;
2379: LD_ADDR_OWVAR 39
2383: PUSH
2384: LD_INT 1
2386: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2387: LD_ADDR_OWVAR 40
2391: PUSH
2392: LD_INT 53
2394: ST_TO_ADDR
// vc_control := control_manual ;
2395: LD_ADDR_OWVAR 38
2399: PUSH
2400: LD_INT 1
2402: ST_TO_ADDR
// auto := CreateVehicle ;
2403: LD_ADDR_VAR 0 3
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetFuel ( auto , Rand ( 80 , 100 ) ) ;
2413: LD_VAR 0 3
2417: PPUSH
2418: LD_INT 80
2420: PPUSH
2421: LD_INT 100
2423: PPUSH
2424: CALL_OW 12
2428: PPUSH
2429: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2433: LD_VAR 0 3
2437: PPUSH
2438: LD_INT 3
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL_OW 49
// end ;
2448: GO 2334
2450: POP
2451: POP
// end ;
2452: LD_VAR 0 1
2456: RET
// export function create_snipers ; var xy ; begin
2457: LD_INT 0
2459: PPUSH
2460: PPUSH
// for xy in snipers_positions do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_EXP 79
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2616
// begin uc_side = usa ;
2474: LD_ADDR_OWVAR 20
2478: PUSH
2479: LD_EXP 35
2483: ST_TO_ADDR
// uc_nation := nation_american ;
2484: LD_ADDR_OWVAR 21
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
2492: LD_ADDR_OWVAR 30
2496: PUSH
2497: LD_INT 0
2499: PUSH
2500: LD_INT 0
2502: PUSH
2503: LD_INT 0
2505: PUSH
2506: LD_INT 0
2508: PUSH
2509: EMPTY
2510: LIST
2511: LIST
2512: LIST
2513: LIST
2514: ST_TO_ADDR
// hc_skills := [ difficulty - 1 , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2515: LD_ADDR_OWVAR 31
2519: PUSH
2520: LD_OWVAR 67
2524: PUSH
2525: LD_INT 1
2527: MINUS
2528: PUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: PUSH
2540: LD_INT 0
2542: PPUSH
2543: LD_INT 2
2545: PPUSH
2546: CALL_OW 12
2550: PUSH
2551: LD_INT 0
2553: PPUSH
2554: LD_INT 2
2556: PPUSH
2557: CALL_OW 12
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: LIST
2566: LIST
2567: ST_TO_ADDR
// hc_class := class_sniper ;
2568: LD_ADDR_OWVAR 28
2572: PUSH
2573: LD_INT 5
2575: ST_TO_ADDR
// hc_name :=  ;
2576: LD_ADDR_OWVAR 26
2580: PUSH
2581: LD_STRING 
2583: ST_TO_ADDR
// PlaceUnitXY ( CreateHuman , xy [ 1 ] , xy [ 2 ] , false ) ;
2584: CALL_OW 44
2588: PPUSH
2589: LD_VAR 0 2
2593: PUSH
2594: LD_INT 1
2596: ARRAY
2597: PPUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_INT 2
2605: ARRAY
2606: PPUSH
2607: LD_INT 0
2609: PPUSH
2610: CALL_OW 48
// end ;
2614: GO 2471
2616: POP
2617: POP
// end ;
2618: LD_VAR 0 1
2622: RET
// export function create_heike ; var auto , filter , x , y , d , Guard1 , Guard2 ; begin
2623: LD_INT 0
2625: PPUSH
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := ally ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_EXP 32
2642: ST_TO_ADDR
// uc_nation := nation_russian ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_INT 3
2650: ST_TO_ADDR
// uc_direction := Rand ( 3 , 5 ) ;
2651: LD_ADDR_OWVAR 24
2655: PUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 5
2661: PPUSH
2662: CALL_OW 12
2666: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2667: LD_INT 0
2669: PPUSH
2670: LD_INT 1
2672: PPUSH
2673: LD_INT 6
2675: PPUSH
2676: CALL_OW 380
// hc_name :=  ;
2680: LD_ADDR_OWVAR 26
2684: PUSH
2685: LD_STRING 
2687: ST_TO_ADDR
// Guard1 := CreateHuman ;
2688: LD_ADDR_VAR 0 7
2692: PUSH
2693: CALL_OW 44
2697: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2698: LD_INT 0
2700: PPUSH
2701: LD_INT 1
2703: PPUSH
2704: LD_INT 6
2706: PPUSH
2707: CALL_OW 380
// hc_name :=  ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING 
2718: ST_TO_ADDR
// Guard2 := CreateHuman ;
2719: LD_ADDR_VAR 0 8
2723: PUSH
2724: CALL_OW 44
2728: ST_TO_ADDR
// PlaceUnitArea ( Guard1 , EnterArea , false ) ;
2729: LD_VAR 0 7
2733: PPUSH
2734: LD_INT 3
2736: PPUSH
2737: LD_INT 0
2739: PPUSH
2740: CALL_OW 49
// PlaceUnitArea ( Guard2 , EnterArea , false ) ;
2744: LD_VAR 0 8
2748: PPUSH
2749: LD_INT 3
2751: PPUSH
2752: LD_INT 0
2754: PPUSH
2755: CALL_OW 49
// PlaceUnitArea ( Heike , EnterArea , false ) ;
2759: LD_EXP 11
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: LD_INT 0
2769: PPUSH
2770: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
2774: LD_ADDR_VAR 0 3
2778: PUSH
2779: LD_INT 22
2781: PUSH
2782: LD_EXP 31
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: LD_INT 30
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 1
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PUSH
2819: EMPTY
2820: LIST
2821: PUSH
2822: EMPTY
2823: LIST
2824: LIST
2825: PPUSH
2826: CALL_OW 69
2830: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
2831: LD_INT 0
2833: PUSH
2834: LD_VAR 0 3
2838: PLUS
2839: PUSH
2840: LD_INT 0
2842: NONEQUAL
2843: IFFALSE 2904
// begin x := GetX ( filter [ 1 ] ) ;
2845: LD_ADDR_VAR 0 4
2849: PUSH
2850: LD_VAR 0 3
2854: PUSH
2855: LD_INT 1
2857: ARRAY
2858: PPUSH
2859: CALL_OW 250
2863: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
2864: LD_ADDR_VAR 0 5
2868: PUSH
2869: LD_VAR 0 3
2873: PUSH
2874: LD_INT 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 251
2882: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
2883: LD_ADDR_VAR 0 6
2887: PUSH
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 1
2895: ARRAY
2896: PPUSH
2897: CALL_OW 254
2901: ST_TO_ADDR
// end else
2902: GO 2942
// begin x := GetX ( Burlak ) ;
2904: LD_ADDR_VAR 0 4
2908: PUSH
2909: LD_EXP 1
2913: PPUSH
2914: CALL_OW 250
2918: ST_TO_ADDR
// y := GetY ( Burlak ) ;
2919: LD_ADDR_VAR 0 5
2923: PUSH
2924: LD_EXP 1
2928: PPUSH
2929: CALL_OW 251
2933: ST_TO_ADDR
// d := 1 ;
2934: LD_ADDR_VAR 0 6
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// end ; repeat ComMoveXY ( Guard1 , x , y ) ;
2942: LD_VAR 0 7
2946: PPUSH
2947: LD_VAR 0 4
2951: PPUSH
2952: LD_VAR 0 5
2956: PPUSH
2957: CALL_OW 111
// ComMoveUnit ( Heike , Guard1 ) ;
2961: LD_EXP 11
2965: PPUSH
2966: LD_VAR 0 7
2970: PPUSH
2971: CALL_OW 112
// ComMoveUnit ( Guard2 , Heike ) ;
2975: LD_VAR 0 8
2979: PPUSH
2980: LD_EXP 11
2984: PPUSH
2985: CALL_OW 112
// Wait ( 0 0$1 ) ;
2989: LD_INT 35
2991: PPUSH
2992: CALL_OW 67
// until ( GetDistUnitXY ( Guard1 , x , y ) < 10 ) and ( GetDistUnitXY ( Guard2 , x , y ) < 10 ) ;
2996: LD_VAR 0 7
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_VAR 0 5
3010: PPUSH
3011: CALL_OW 297
3015: PUSH
3016: LD_INT 10
3018: LESS
3019: PUSH
3020: LD_VAR 0 8
3024: PPUSH
3025: LD_VAR 0 4
3029: PPUSH
3030: LD_VAR 0 5
3034: PPUSH
3035: CALL_OW 297
3039: PUSH
3040: LD_INT 10
3042: LESS
3043: AND
3044: IFFALSE 2942
// ComStop ( [ Guard1 , Guard2 , Heike ] ) ;
3046: LD_VAR 0 7
3050: PUSH
3051: LD_VAR 0 8
3055: PUSH
3056: LD_EXP 11
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 141
// Wait ( 10 ) ;
3070: LD_INT 10
3072: PPUSH
3073: CALL_OW 67
// ComMoveXY ( [ Guard1 , Guard2 ] , 113 , 29 ) ;
3077: LD_VAR 0 7
3081: PUSH
3082: LD_VAR 0 8
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PPUSH
3091: LD_INT 113
3093: PPUSH
3094: LD_INT 29
3096: PPUSH
3097: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
3101: LD_INT 35
3103: PPUSH
3104: CALL_OW 67
// until not HasTask ( Guard1 ) and not HasTask ( Guard2 ) ;
3108: LD_VAR 0 7
3112: PPUSH
3113: CALL_OW 314
3117: NOT
3118: PUSH
3119: LD_VAR 0 8
3123: PPUSH
3124: CALL_OW 314
3128: NOT
3129: AND
3130: IFFALSE 3101
// DestroyUnit ( Guard1 ) ;
3132: LD_VAR 0 7
3136: PPUSH
3137: CALL_OW 65
// DestroyUnit ( Guard2 ) ;
3141: LD_VAR 0 8
3145: PPUSH
3146: CALL_OW 65
// end ;
3150: LD_VAR 0 1
3154: RET
// export function create_kurt ; begin
3155: LD_INT 0
3157: PPUSH
// PlaceUnitArea ( Mercenary1 , MercEnterArea , false ) ;
3158: LD_EXP 14
3162: PPUSH
3163: LD_INT 4
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 49
// PlaceUnitArea ( Kurt , MercEnterArea , false ) ;
3173: LD_EXP 13
3177: PPUSH
3178: LD_INT 4
3180: PPUSH
3181: LD_INT 0
3183: PPUSH
3184: CALL_OW 49
// enable ( 2 ) ;
3188: LD_INT 2
3190: ENABLE_MARKED
// end ;
3191: LD_VAR 0 1
3195: RET
// starting begin FogOff ( false ) ;
3196: LD_INT 0
3198: PPUSH
3199: CALL_OW 344
// Randomize ;
3203: CALL_OW 10
// RandomizeAll ;
3207: CALL_OW 11
// testing = false ;
3211: LD_ADDR_EXP 95
3215: PUSH
3216: LD_INT 0
3218: ST_TO_ADDR
// InitBc ;
3219: CALL_OW 21
// InitHc ;
3223: CALL_OW 19
// InitUc ;
3227: CALL_OW 18
// InitVc ;
3231: CALL_OW 20
// disable ( 1 ) ;
3235: LD_INT 1
3237: DISABLE_MARKED
// disable ( 2 ) ;
3238: LD_INT 2
3240: DISABLE_MARKED
// disable ( 3 ) ;
3241: LD_INT 3
3243: DISABLE_MARKED
// disable ( 4 ) ;
3244: LD_INT 4
3246: DISABLE_MARKED
// disable ( 5 ) ;
3247: LD_INT 5
3249: DISABLE_MARKED
// disable ( 6 ) ;
3250: LD_INT 6
3252: DISABLE_MARKED
// disable ( 7 ) ;
3253: LD_INT 7
3255: DISABLE_MARKED
// disable ( 8 ) ;
3256: LD_INT 8
3258: DISABLE_MARKED
// disable ( 9 ) ;
3259: LD_INT 9
3261: DISABLE_MARKED
// disable ( 10 ) ;
3262: LD_INT 10
3264: DISABLE_MARKED
// disable ( 11 ) ;
3265: LD_INT 11
3267: DISABLE_MARKED
// disable ( 13 ) ;
3268: LD_INT 13
3270: DISABLE_MARKED
// disable ( 20 ) ;
3271: LD_INT 20
3273: DISABLE_MARKED
// disable ( 23 ) ;
3274: LD_INT 23
3276: DISABLE_MARKED
// disable ( 24 ) ;
3277: LD_INT 24
3279: DISABLE_MARKED
// disable ( 50 ) ;
3280: LD_INT 50
3282: DISABLE_MARKED
// disable ( 101 ) ;
3283: LD_INT 101
3285: DISABLE_MARKED
// disable ( 102 ) ;
3286: LD_INT 102
3288: DISABLE_MARKED
// disable ( 201 ) ;
3289: LD_INT 201
3291: DISABLE_MARKED
// disable ( 202 ) ;
3292: LD_INT 202
3294: DISABLE_MARKED
// disable ( 203 ) ;
3295: LD_INT 203
3297: DISABLE_MARKED
// disable ( 301 ) ;
3298: LD_INT 301
3300: DISABLE_MARKED
// disable ( 401 ) ;
3301: LD_INT 401
3303: DISABLE_MARKED
// disable ( 402 ) ;
3304: LD_INT 402
3306: DISABLE_MARKED
// disable ( 501 ) ;
3307: LD_INT 501
3309: DISABLE_MARKED
// disable ( 502 ) ;
3310: LD_INT 502
3312: DISABLE_MARKED
// disable ( 601 ) ;
3313: LD_INT 601
3315: DISABLE_MARKED
// disable ( 999 ) ;
3316: LD_INT 999
3318: DISABLE_MARKED
// PlaceTreesToArea ( TreeArea1 , [ 2 , 10 , 11 , 27 , 35 ] , 20 , 10 , 4 ) ;
3319: LD_INT 24
3321: PPUSH
3322: LD_INT 2
3324: PUSH
3325: LD_INT 10
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: LD_INT 35
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: LD_INT 20
3346: PPUSH
3347: LD_INT 10
3349: PPUSH
3350: LD_INT 4
3352: PPUSH
3353: CALL_OW 352
// PlaceTreesToArea ( TreeArea2 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3357: LD_INT 25
3359: PPUSH
3360: LD_INT 9
3362: PUSH
3363: LD_INT 10
3365: PUSH
3366: LD_INT 27
3368: PUSH
3369: LD_INT 35
3371: PUSH
3372: LD_INT 48
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: PPUSH
3382: LD_INT 20
3384: PPUSH
3385: LD_INT 10
3387: PPUSH
3388: LD_INT 4
3390: PPUSH
3391: CALL_OW 352
// PlaceTreesToArea ( TreeArea3 , [ 2 , 9 , 10 , 11 , 27 ] , 20 , 10 , 4 ) ;
3395: LD_INT 26
3397: PPUSH
3398: LD_INT 2
3400: PUSH
3401: LD_INT 9
3403: PUSH
3404: LD_INT 10
3406: PUSH
3407: LD_INT 11
3409: PUSH
3410: LD_INT 27
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PPUSH
3420: LD_INT 20
3422: PPUSH
3423: LD_INT 10
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL_OW 352
// PlaceTreesToArea ( TreeArea4 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3433: LD_INT 27
3435: PPUSH
3436: LD_INT 9
3438: PUSH
3439: LD_INT 10
3441: PUSH
3442: LD_INT 27
3444: PUSH
3445: LD_INT 35
3447: PUSH
3448: LD_INT 48
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PPUSH
3458: LD_INT 20
3460: PPUSH
3461: LD_INT 10
3463: PPUSH
3464: LD_INT 4
3466: PPUSH
3467: CALL_OW 352
// PlaceTreesToArea ( TreeArea5 , [ 2 , 9 , 10 , 11 , 48 ] , 20 , 10 , 4 ) ;
3471: LD_INT 28
3473: PPUSH
3474: LD_INT 2
3476: PUSH
3477: LD_INT 9
3479: PUSH
3480: LD_INT 10
3482: PUSH
3483: LD_INT 11
3485: PUSH
3486: LD_INT 48
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: PPUSH
3496: LD_INT 20
3498: PPUSH
3499: LD_INT 10
3501: PPUSH
3502: LD_INT 4
3504: PPUSH
3505: CALL_OW 352
// PlaceTreesToArea ( TreeArea6 , [ 2 , 11 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3509: LD_INT 29
3511: PPUSH
3512: LD_INT 2
3514: PUSH
3515: LD_INT 11
3517: PUSH
3518: LD_INT 27
3520: PUSH
3521: LD_INT 35
3523: PUSH
3524: LD_INT 48
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: PPUSH
3534: LD_INT 20
3536: PPUSH
3537: LD_INT 10
3539: PPUSH
3540: LD_INT 4
3542: PPUSH
3543: CALL_OW 352
// read_parameters ;
3547: CALL 0 0 0
// set_difficulty ;
3551: CALL 675 0 0
// create_people ;
3555: CALL 1064 0 0
// create_vehicles ;
3559: CALL 2032 0 0
// create_snipers ;
3563: CALL 2457 0 0
// prepare_am_attack ;
3567: CALL 18473 0 0
// CenterNowOnXY ( 112 , 32 ) ;
3571: LD_INT 112
3573: PPUSH
3574: LD_INT 32
3576: PPUSH
3577: CALL_OW 86
// D_Start ;
3581: CALL 4818 0 0
// SaveForQuickRestart ;
3585: CALL_OW 22
// end ;
3589: END
// every 0 0$10 marked 999 do var filter , prumer , un , un1 , un2 , distance , pole , budova1 , budova2 , i , trotskij ;
3590: GO 3592
3592: DISABLE
3593: LD_INT 0
3595: PPUSH
3596: PPUSH
3597: PPUSH
3598: PPUSH
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
3604: PPUSH
3605: PPUSH
// begin if BuildingsDone and WeaponsDone and TechnoDone and CompVehConstructed and LimitTeleportTested and Masha and AmAttackDone then
3606: LD_EXP 48
3610: PUSH
3611: LD_EXP 50
3615: AND
3616: PUSH
3617: LD_EXP 51
3621: AND
3622: PUSH
3623: LD_EXP 61
3627: AND
3628: PUSH
3629: LD_EXP 63
3633: AND
3634: PUSH
3635: LD_EXP 60
3639: AND
3640: PUSH
3641: LD_EXP 64
3645: AND
3646: IFFALSE 4814
// begin disable ;
3648: DISABLE
// gained_medals := [ ] ;
3649: LD_ADDR_OWVAR 61
3653: PUSH
3654: EMPTY
3655: ST_TO_ADDR
// missing_medals := [ ] ;
3656: LD_ADDR_OWVAR 62
3660: PUSH
3661: EMPTY
3662: ST_TO_ADDR
// if HeikeCaptured then
3663: LD_EXP 37
3667: IFFALSE 3700
// if MortarDone then
3669: LD_EXP 52
3673: IFFALSE 3687
// AddMedal ( ArabBarracks , 1 ) else
3675: LD_STRING ArabBarracks
3677: PPUSH
3678: LD_INT 1
3680: PPUSH
3681: CALL_OW 101
3685: GO 3698
// AddMedal ( ArabBarracks , - 1 ) else
3687: LD_STRING ArabBarracks
3689: PPUSH
3690: LD_INT 1
3692: NEG
3693: PPUSH
3694: CALL_OW 101
3698: GO 3735
// if tick < speed then
3700: LD_OWVAR 1
3704: PUSH
3705: LD_EXP 73
3709: LESS
3710: IFFALSE 3724
// AddMedal ( Speed , 1 ) else
3712: LD_STRING Speed
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 101
3722: GO 3735
// AddMedal ( Speed , - 1 ) ;
3724: LD_STRING Speed
3726: PPUSH
3727: LD_INT 1
3729: NEG
3730: PPUSH
3731: CALL_OW 101
// AddMedal ( ArtisticImpression , 1 ) ;
3735: LD_STRING ArtisticImpression
3737: PPUSH
3738: LD_INT 1
3740: PPUSH
3741: CALL_OW 101
// if ( 0 + player_units ) <= 11 then
3745: LD_INT 0
3747: PUSH
3748: LD_EXP 26
3752: PLUS
3753: PUSH
3754: LD_INT 11
3756: LESSEQUAL
3757: IFFALSE 3772
// AddMedal ( FavouriteCommander , - 1 ) else
3759: LD_STRING FavouriteCommander
3761: PPUSH
3762: LD_INT 1
3764: NEG
3765: PPUSH
3766: CALL_OW 101
3770: GO 3844
// if FreeTimeGranted and HuntingAccepted and GalleryBuild then
3772: LD_EXP 59
3776: PUSH
3777: LD_EXP 47
3781: AND
3782: PUSH
3783: LD_EXP 53
3787: AND
3788: IFFALSE 3802
// AddMedal ( FavouriteCommander , 1 ) else
3790: LD_STRING FavouriteCommander
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: CALL_OW 101
3800: GO 3844
// if FreeTimeGranted or HuntingAccepted or GalleryBuild then
3802: LD_EXP 59
3806: PUSH
3807: LD_EXP 47
3811: OR
3812: PUSH
3813: LD_EXP 53
3817: OR
3818: IFFALSE 3833
// AddMedal ( FavouriteCommander , - 3 ) else
3820: LD_STRING FavouriteCommander
3822: PPUSH
3823: LD_INT 3
3825: NEG
3826: PPUSH
3827: CALL_OW 101
3831: GO 3844
// AddMedal ( FavouriteCommander , - 2 ) ;
3833: LD_STRING FavouriteCommander
3835: PPUSH
3836: LD_INT 2
3838: NEG
3839: PPUSH
3840: CALL_OW 101
// if MortarDone and not HeikeDismissed then
3844: LD_EXP 52
3848: PUSH
3849: LD_EXP 45
3853: NOT
3854: AND
3855: IFFALSE 3861
// SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ;
3857: CALL 19057 0 0
// GiveMedals ( Main ) ;
3861: LD_STRING Main
3863: PPUSH
3864: CALL_OW 102
// for un1 in player_units do
3868: LD_ADDR_VAR 0 4
3872: PUSH
3873: LD_EXP 26
3877: PUSH
3878: FOR_IN
3879: IFFALSE 3910
// if IsDead ( un1 ) then
3881: LD_VAR 0 4
3885: PPUSH
3886: CALL_OW 301
3890: IFFALSE 3908
// player_units := player_units diff un1 ;
3892: LD_ADDR_EXP 26
3896: PUSH
3897: LD_EXP 26
3901: PUSH
3902: LD_VAR 0 4
3906: DIFF
3907: ST_TO_ADDR
3908: GO 3878
3910: POP
3911: POP
// RewardPeople ( player_units ) ;
3912: LD_EXP 26
3916: PPUSH
3917: CALL_OW 43
// trotskij := [ ] ;
3921: LD_ADDR_VAR 0 11
3925: PUSH
3926: EMPTY
3927: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
3928: LD_ADDR_VAR 0 1
3932: PUSH
3933: LD_INT 22
3935: PUSH
3936: LD_INT 3
3938: PUSH
3939: EMPTY
3940: LIST
3941: LIST
3942: PUSH
3943: LD_INT 30
3945: PUSH
3946: LD_INT 3
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PPUSH
3957: CALL_OW 69
3961: PUSH
3962: LD_INT 22
3964: PUSH
3965: LD_INT 3
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: PUSH
3972: LD_INT 21
3974: PUSH
3975: LD_INT 3
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: PUSH
3982: LD_INT 3
3984: PUSH
3985: LD_INT 30
3987: PUSH
3988: LD_INT 3
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PPUSH
4004: CALL_OW 69
4008: ADD
4009: ST_TO_ADDR
// for un in filter do
4010: LD_ADDR_VAR 0 3
4014: PUSH
4015: LD_VAR 0 1
4019: PUSH
4020: FOR_IN
4021: IFFALSE 4362
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
4023: LD_VAR 0 3
4027: PPUSH
4028: CALL_OW 266
4032: PUSH
4033: LD_INT 6
4035: PUSH
4036: LD_INT 7
4038: PUSH
4039: LD_INT 8
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: IN
4047: IFFALSE 4161
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4049: LD_ADDR_VAR 0 11
4053: PUSH
4054: LD_VAR 0 11
4058: PUSH
4059: LD_VAR 0 3
4063: PPUSH
4064: CALL_OW 266
4068: PUSH
4069: LD_VAR 0 3
4073: PPUSH
4074: CALL_OW 250
4078: PUSH
4079: LD_VAR 0 3
4083: PPUSH
4084: CALL_OW 251
4088: PUSH
4089: LD_VAR 0 3
4093: PPUSH
4094: CALL_OW 254
4098: PUSH
4099: LD_VAR 0 3
4103: PPUSH
4104: CALL_OW 267
4108: PUSH
4109: LD_VAR 0 3
4113: PPUSH
4114: CALL_OW 248
4118: PUSH
4119: LD_VAR 0 3
4123: PPUSH
4124: LD_INT 1
4126: PPUSH
4127: CALL_OW 268
4131: PUSH
4132: LD_VAR 0 3
4136: PPUSH
4137: LD_INT 2
4139: PPUSH
4140: CALL_OW 268
4144: PUSH
4145: EMPTY
4146: LIST
4147: LIST
4148: LIST
4149: LIST
4150: LIST
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: EMPTY
4156: LIST
4157: ADD
4158: ST_TO_ADDR
4159: GO 4360
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4161: LD_VAR 0 3
4165: PPUSH
4166: CALL_OW 266
4170: PUSH
4171: LD_INT 32
4173: PUSH
4174: LD_INT 33
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: IN
4181: IFFALSE 4278
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4183: LD_ADDR_VAR 0 11
4187: PUSH
4188: LD_VAR 0 11
4192: PUSH
4193: LD_VAR 0 3
4197: PPUSH
4198: CALL_OW 266
4202: PUSH
4203: LD_VAR 0 3
4207: PPUSH
4208: CALL_OW 250
4212: PUSH
4213: LD_VAR 0 3
4217: PPUSH
4218: CALL_OW 251
4222: PUSH
4223: LD_VAR 0 3
4227: PPUSH
4228: CALL_OW 254
4232: PUSH
4233: LD_VAR 0 3
4237: PPUSH
4238: CALL_OW 267
4242: PUSH
4243: LD_VAR 0 3
4247: PPUSH
4248: CALL_OW 248
4252: PUSH
4253: LD_VAR 0 3
4257: PPUSH
4258: CALL_OW 269
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: ADD
4275: ST_TO_ADDR
4276: GO 4360
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4278: LD_ADDR_VAR 0 11
4282: PUSH
4283: LD_VAR 0 11
4287: PUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 266
4297: PUSH
4298: LD_VAR 0 3
4302: PPUSH
4303: CALL_OW 250
4307: PUSH
4308: LD_VAR 0 3
4312: PPUSH
4313: CALL_OW 251
4317: PUSH
4318: LD_VAR 0 3
4322: PPUSH
4323: CALL_OW 254
4327: PUSH
4328: LD_VAR 0 3
4332: PPUSH
4333: CALL_OW 267
4337: PUSH
4338: LD_VAR 0 3
4342: PPUSH
4343: CALL_OW 248
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: PUSH
4356: EMPTY
4357: LIST
4358: ADD
4359: ST_TO_ADDR
// end ;
4360: GO 4020
4362: POP
4363: POP
// SaveVariable ( trotskij , Trotskij ) ;
4364: LD_VAR 0 11
4368: PPUSH
4369: LD_STRING Trotskij
4371: PPUSH
4372: CALL_OW 39
// SaveVariable ( ListEnvironmentArea ( WholeMapArea ) , Environment ) ;
4376: LD_INT 10
4378: PPUSH
4379: CALL_OW 353
4383: PPUSH
4384: LD_STRING Environment
4386: PPUSH
4387: CALL_OW 39
// SaveVariable ( HeikeKilled , HeikeKilled ) ;
4391: LD_EXP 38
4395: PPUSH
4396: LD_STRING HeikeKilled
4398: PPUSH
4399: CALL_OW 39
// SaveVariable ( MercPaid , MercPaid ) ;
4403: LD_EXP 39
4407: PPUSH
4408: LD_STRING MercPaid
4410: PPUSH
4411: CALL_OW 39
// SaveVariable ( MercHandedOver , MercHandedOver ) ;
4415: LD_EXP 40
4419: PPUSH
4420: LD_STRING MercHandedOver
4422: PPUSH
4423: CALL_OW 39
// SaveVariable ( MercAccepted , MercAccepted ) ;
4427: LD_EXP 44
4431: PPUSH
4432: LD_STRING MercAccepted
4434: PPUSH
4435: CALL_OW 39
// SaveVariable ( GenscherBetrayed , GenscherBetrayed ) ;
4439: LD_EXP 36
4443: PPUSH
4444: LD_STRING GenscherBetrayed
4446: PPUSH
4447: CALL_OW 39
// SaveCharacters ( Heike , Heike ) ;
4451: LD_EXP 11
4455: PPUSH
4456: LD_STRING Heike
4458: PPUSH
4459: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
4463: LD_EXP 9
4467: PPUSH
4468: LD_STRING Petrosyan
4470: PPUSH
4471: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4475: LD_EXP 23
4479: PPUSH
4480: LD_STRING Dolgov
4482: PPUSH
4483: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4487: LD_EXP 24
4491: PPUSH
4492: LD_STRING Xavier
4494: PPUSH
4495: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
4499: LD_EXP 1
4503: PPUSH
4504: LD_STRING Burlak
4506: PPUSH
4507: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
4511: LD_EXP 3
4515: PPUSH
4516: LD_STRING Belkov
4518: PPUSH
4519: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
4523: LD_EXP 4
4527: PPUSH
4528: LD_STRING Kirilenkova
4530: PPUSH
4531: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
4535: LD_EXP 5
4539: PPUSH
4540: LD_STRING Gnyevko
4542: PPUSH
4543: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4547: LD_EXP 6
4551: PPUSH
4552: LD_STRING Kapitsova
4554: PPUSH
4555: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
4559: LD_EXP 8
4563: PPUSH
4564: LD_STRING Gleb
4566: PPUSH
4567: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
4571: LD_EXP 10
4575: PPUSH
4576: LD_STRING Kuzmov
4578: PPUSH
4579: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
4583: LD_EXP 12
4587: PPUSH
4588: LD_STRING Kovalyuk
4590: PPUSH
4591: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
4595: LD_EXP 15
4599: PPUSH
4600: LD_STRING Scholtze
4602: PPUSH
4603: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
4607: LD_EXP 17
4611: PPUSH
4612: LD_STRING Karamazov
4614: PPUSH
4615: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
4619: LD_EXP 18
4623: PPUSH
4624: LD_STRING Titov
4626: PPUSH
4627: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4631: LD_EXP 19
4635: PPUSH
4636: LD_STRING Oblukov
4638: PPUSH
4639: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4643: LD_EXP 20
4647: PPUSH
4648: LD_STRING Kozlov
4650: PPUSH
4651: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
4655: LD_EXP 21
4659: PPUSH
4660: LD_STRING Petrovova
4662: PPUSH
4663: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
4667: LD_EXP 22
4671: PPUSH
4672: LD_STRING Lipshchin
4674: PPUSH
4675: CALL_OW 38
// SaveCharacters ( ( ( player_units union other ) diff [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) , survivors3 ) ;
4679: LD_EXP 26
4683: PUSH
4684: LD_EXP 25
4688: UNION
4689: PUSH
4690: LD_EXP 1
4694: PUSH
4695: LD_EXP 3
4699: PUSH
4700: LD_EXP 4
4704: PUSH
4705: LD_EXP 5
4709: PUSH
4710: LD_EXP 6
4714: PUSH
4715: LD_EXP 8
4719: PUSH
4720: LD_EXP 10
4724: PUSH
4725: LD_EXP 12
4729: PUSH
4730: LD_EXP 15
4734: PUSH
4735: LD_EXP 17
4739: PUSH
4740: LD_EXP 18
4744: PUSH
4745: LD_EXP 19
4749: PUSH
4750: LD_EXP 20
4754: PUSH
4755: LD_EXP 21
4759: PUSH
4760: LD_EXP 22
4764: PUSH
4765: LD_EXP 9
4769: PUSH
4770: LD_EXP 23
4774: PUSH
4775: LD_EXP 24
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: DIFF
4800: PPUSH
4801: LD_STRING survivors3
4803: PPUSH
4804: CALL_OW 38
// YouWin ;
4808: CALL_OW 103
// exit ;
4812: GO 4815
// end ; enable ;
4814: ENABLE
// end ; end_of_file
4815: PPOPN 11
4817: END
// export function D_Start ; begin
4818: LD_INT 0
4820: PPUSH
// DialogueOn ;
4821: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
4825: LD_EXP 2
4829: PPUSH
4830: LD_STRING DStart-Pop-1
4832: PPUSH
4833: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
4837: LD_EXP 1
4841: PPUSH
4842: LD_STRING DStart-Bur-1
4844: PPUSH
4845: CALL_OW 88
// Wait ( 0 0$2 ) ;
4849: LD_INT 70
4851: PPUSH
4852: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
4856: LD_STRING MStart
4858: PPUSH
4859: CALL_OW 337
// display_strings := [ #Ru08-1 , ( 3 + AvailableBuildings ) , #Ru08-2 , ( 0 + AvailableWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
4863: LD_ADDR_OWVAR 47
4867: PUSH
4868: LD_STRING #Ru08-1
4870: PUSH
4871: LD_INT 3
4873: PUSH
4874: LD_EXP 55
4878: PLUS
4879: PUSH
4880: LD_STRING #Ru08-2
4882: PUSH
4883: LD_INT 0
4885: PUSH
4886: LD_EXP 54
4890: PLUS
4891: PUSH
4892: LD_STRING #Ru08-3
4894: PUSH
4895: LD_INT 0
4897: PUSH
4898: LD_EXP 56
4902: PLUS
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: LIST
4908: LIST
4909: LIST
4910: LIST
4911: ST_TO_ADDR
// DialogueOff ;
4912: CALL_OW 7
// end ;
4916: LD_VAR 0 1
4920: RET
// export function D_Heike ; begin
4921: LD_INT 0
4923: PPUSH
// Say ( Popov , DHeike-Pop-1 ) ;
4924: LD_EXP 2
4928: PPUSH
4929: LD_STRING DHeike-Pop-1
4931: PPUSH
4932: CALL_OW 88
// Wait ( 0 0$2 ) ;
4936: LD_INT 70
4938: PPUSH
4939: CALL_OW 67
// create_heike ;
4943: CALL 2623 0 0
// end ;
4947: LD_VAR 0 1
4951: RET
// export function D_HeikeKilled ; begin
4952: LD_INT 0
4954: PPUSH
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
4955: LD_EXP 11
4959: PPUSH
4960: LD_STRING DHeikeKilled-Hke-1
4962: PPUSH
4963: CALL_OW 91
// end ;
4967: LD_VAR 0 1
4971: RET
// export function D_MercHelp ; begin
4972: LD_INT 0
4974: PPUSH
// DialogueOn ;
4975: CALL_OW 6
// Say ( Kurt , DMercHelp-Kurt-1 ) ;
4979: LD_EXP 13
4983: PPUSH
4984: LD_STRING DMercHelp-Kurt-1
4986: PPUSH
4987: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-1 ) ;
4991: LD_EXP 1
4995: PPUSH
4996: LD_STRING DMercHelp-Bur-1
4998: PPUSH
4999: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-2 ) ;
5003: LD_EXP 13
5007: PPUSH
5008: LD_STRING DMercHelp-Kurt-2
5010: PPUSH
5011: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-2 ) ;
5015: LD_EXP 1
5019: PPUSH
5020: LD_STRING DMercHelp-Bur-2
5022: PPUSH
5023: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-3 ) ;
5027: LD_EXP 13
5031: PPUSH
5032: LD_STRING DMercHelp-Kurt-3
5034: PPUSH
5035: CALL_OW 88
// DialogueOff ;
5039: CALL_OW 7
// end ;
5043: LD_VAR 0 1
5047: RET
// export function D_QrMerc1 ; begin
5048: LD_INT 0
5050: PPUSH
// DialogueOn ;
5051: CALL_OW 6
// Say ( Burlak , DQrMerc#1-Bur-1 ) ;
5055: LD_EXP 1
5059: PPUSH
5060: LD_STRING DQrMerc#1-Bur-1
5062: PPUSH
5063: CALL_OW 88
// Say ( Kurt , DQrMerc#1-Kurt-1 ) ;
5067: LD_EXP 13
5071: PPUSH
5072: LD_STRING DQrMerc#1-Kurt-1
5074: PPUSH
5075: CALL_OW 88
// DialogueOff ;
5079: CALL_OW 7
// end ;
5083: LD_VAR 0 1
5087: RET
// export function D_QrMerc2 ; begin
5088: LD_INT 0
5090: PPUSH
// DialogueOn ;
5091: CALL_OW 6
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
5095: LD_EXP 1
5099: PPUSH
5100: LD_STRING DQrMerc#2-Bur-1
5102: PPUSH
5103: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
5107: LD_EXP 2
5111: PPUSH
5112: LD_STRING DQrMerc#2-Pop-1
5114: PPUSH
5115: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
5119: LD_EXP 1
5123: PPUSH
5124: LD_STRING DQrMerc#2-Bur-2
5126: PPUSH
5127: CALL_OW 88
// DialogueOff ;
5131: CALL_OW 7
// end ;
5135: LD_VAR 0 1
5139: RET
// export function D_QrMerc3 ; begin
5140: LD_INT 0
5142: PPUSH
// DialogueOn ;
5143: CALL_OW 6
// Say ( Burlak , DQrMerc#3-Bur-1 ) ;
5147: LD_EXP 1
5151: PPUSH
5152: LD_STRING DQrMerc#3-Bur-1
5154: PPUSH
5155: CALL_OW 88
// DialogueOff ;
5159: CALL_OW 7
// end ;
5163: LD_VAR 0 1
5167: RET
// export function D_MercRefuseBuild ; begin
5168: LD_INT 0
5170: PPUSH
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
5171: LD_EXP 13
5175: PPUSH
5176: LD_STRING DMercRefuseBuild-Kurt-1
5178: PPUSH
5179: CALL_OW 88
// end ;
5183: LD_VAR 0 1
5187: RET
// export function D_MercCompleted ; begin
5188: LD_INT 0
5190: PPUSH
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
5191: LD_EXP 13
5195: PPUSH
5196: LD_STRING DMercCompleted-Kurt-1
5198: PPUSH
5199: CALL_OW 88
// end ;
5203: LD_VAR 0 1
5207: RET
// export function D_MercPopov ; begin
5208: LD_INT 0
5210: PPUSH
// DialogueOn ;
5211: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
5215: LD_EXP 2
5219: PPUSH
5220: LD_STRING DMercPopov-Pop-1
5222: PPUSH
5223: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
5227: LD_EXP 1
5231: PPUSH
5232: LD_STRING DMercPopov-Bur-1
5234: PPUSH
5235: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
5239: LD_EXP 2
5243: PPUSH
5244: LD_STRING DMercPopov-Pop-2
5246: PPUSH
5247: CALL_OW 94
// DialogueOff ;
5251: CALL_OW 7
// end ;
5255: LD_VAR 0 1
5259: RET
// export function D_MercAmbush ; begin
5260: LD_INT 0
5262: PPUSH
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
5263: LD_EXP 13
5267: PPUSH
5268: LD_STRING DMercAmbush-Kurt-1
5270: PPUSH
5271: CALL_OW 88
// SetAttitude ( you , merc , att_enemy , true ) ;
5275: LD_EXP 31
5279: PPUSH
5280: LD_EXP 34
5284: PPUSH
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 1
5290: PPUSH
5291: CALL_OW 80
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
5295: LD_INT 8
5297: PPUSH
5298: LD_INT 0
5300: PPUSH
5301: CALL_OW 424
// disable ( 20 ) ;
5305: LD_INT 20
5307: DISABLE_MARKED
// end ;
5308: LD_VAR 0 1
5312: RET
// export function D_MercAttack ; begin
5313: LD_INT 0
5315: PPUSH
// Say ( Kurt , DMercAttack-Kurt-1 ) ;
5316: LD_EXP 13
5320: PPUSH
5321: LD_STRING DMercAttack-Kurt-1
5323: PPUSH
5324: CALL_OW 88
// end ;
5328: LD_VAR 0 1
5332: RET
// export function D_MercDeceived ; begin
5333: LD_INT 0
5335: PPUSH
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
5336: LD_EXP 13
5340: PPUSH
5341: LD_STRING DMercDeceived-Kurt-1
5343: PPUSH
5344: CALL_OW 88
// end ;
5348: LD_VAR 0 1
5352: RET
// export function D_ArabianRequest ; begin
5353: LD_INT 0
5355: PPUSH
// DialogueOn ;
5356: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
5360: LD_EXP 7
5364: PPUSH
5365: LD_STRING DArabianRequest-Diet-1
5367: PPUSH
5368: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
5372: LD_EXP 1
5376: PPUSH
5377: LD_STRING DArabianRequest-Bur-1
5379: PPUSH
5380: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
5384: LD_EXP 7
5388: PPUSH
5389: LD_STRING DArabianRequest-Diet-2
5391: PPUSH
5392: CALL_OW 94
// case Query ( QHandOver ) of 1 :
5396: LD_STRING QHandOver
5398: PPUSH
5399: CALL_OW 97
5403: PUSH
5404: LD_INT 1
5406: DOUBLE
5407: EQUAL
5408: IFTRUE 5412
5410: GO 5427
5412: POP
// begin D_QrHandOver1 ;
5413: CALL 5460 0 0
// MercWillBeHandedOver := true ;
5417: LD_ADDR_EXP 41
5421: PUSH
5422: LD_INT 1
5424: ST_TO_ADDR
// end ; 2 :
5425: GO 5451
5427: LD_INT 2
5429: DOUBLE
5430: EQUAL
5431: IFTRUE 5435
5433: GO 5450
5435: POP
// begin MercHandedOver = false ;
5436: LD_ADDR_EXP 40
5440: PUSH
5441: LD_INT 0
5443: ST_TO_ADDR
// D_QrHandOver2 ;
5444: CALL 5504 0 0
// end ; end ;
5448: GO 5451
5450: POP
// DialogueOff ;
5451: CALL_OW 7
// end ;
5455: LD_VAR 0 1
5459: RET
// export function D_QrHandOver1 ; begin
5460: LD_INT 0
5462: PPUSH
// DialogueOn ;
5463: CALL_OW 6
// Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
5467: LD_EXP 1
5471: PPUSH
5472: LD_STRING DQrHandOver#1-Bur-1
5474: PPUSH
5475: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
5479: LD_EXP 7
5483: PPUSH
5484: LD_STRING DQrHandOver#1-Diet-1
5486: PPUSH
5487: CALL_OW 94
// DialogueOff ;
5491: CALL_OW 7
// hand_over ;
5495: CALL 8416 0 0
// end ;
5499: LD_VAR 0 1
5503: RET
// export function D_QrHandOver2 ; begin
5504: LD_INT 0
5506: PPUSH
// DialogueOn ;
5507: CALL_OW 6
// Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
5511: LD_EXP 1
5515: PPUSH
5516: LD_STRING DQrHandOver#2-Bur-1
5518: PPUSH
5519: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
5523: LD_EXP 7
5527: PPUSH
5528: LD_STRING DQrHandOver#2-Diet-1
5530: PPUSH
5531: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
5535: LD_EXP 1
5539: PPUSH
5540: LD_STRING DQrHandOver#2-Bur-2
5542: PPUSH
5543: CALL_OW 88
// DialogueOff ;
5547: CALL_OW 7
// end ;
5551: LD_VAR 0 1
5555: RET
// export function D_HandOverCome ; begin
5556: LD_INT 0
5558: PPUSH
// DialogueOn ;
5559: CALL_OW 6
// Say ( ASoldier1 , DHandOverCome-ASol1-1 ) ;
5563: LD_EXP 16
5567: PPUSH
5568: LD_STRING DHandOverCome-ASol1-1
5570: PPUSH
5571: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
5575: LD_EXP 13
5579: PPUSH
5580: LD_STRING DHandOverCome-Kurt-1
5582: PPUSH
5583: CALL_OW 88
// DialogueOff ;
5587: CALL_OW 7
// end ;
5591: LD_VAR 0 1
5595: RET
// export function D_HandOverSpoiled ; begin
5596: LD_INT 0
5598: PPUSH
// DialogueOn ;
5599: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
5603: LD_EXP 7
5607: PPUSH
5608: LD_STRING DHandOverSpoiled-Diet-1
5610: PPUSH
5611: CALL_OW 94
// DialogueOff ;
5615: CALL_OW 7
// end ;
5619: LD_VAR 0 1
5623: RET
// export function D_LegionFormed ; begin
5624: LD_INT 0
5626: PPUSH
// DialogueOn ;
5627: CALL_OW 6
// Say ( Heike , DLegionFormed-Hke-1 ) ;
5631: LD_EXP 11
5635: PPUSH
5636: LD_STRING DLegionFormed-Hke-1
5638: PPUSH
5639: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
5643: LD_EXP 1
5647: PPUSH
5648: LD_STRING DLegionFormed-Bur-1
5650: PPUSH
5651: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-2 ) ;
5655: LD_EXP 11
5659: PPUSH
5660: LD_STRING DLegionFormed-Hke-2
5662: PPUSH
5663: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
5667: LD_EXP 1
5671: PPUSH
5672: LD_STRING DLegionFormed-Bur-2
5674: PPUSH
5675: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-3 ) ;
5679: LD_EXP 11
5683: PPUSH
5684: LD_STRING DLegionFormed-Hke-3
5686: PPUSH
5687: CALL_OW 88
// DialogueOff ;
5691: CALL_OW 7
// end ;
5695: LD_VAR 0 1
5699: RET
// export function D_QrLegion1 ; begin
5700: LD_INT 0
5702: PPUSH
// DialogueOn ;
5703: CALL_OW 6
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
5707: LD_EXP 1
5711: PPUSH
5712: LD_STRING DQrLegion#1-Bur-1
5714: PPUSH
5715: CALL_OW 88
// DialogueOff ;
5719: CALL_OW 7
// end ;
5723: LD_VAR 0 1
5727: RET
// export function D_QrLegion2 ; begin
5728: LD_INT 0
5730: PPUSH
// DialogueOn ;
5731: CALL_OW 6
// Say ( Burlak , DQrLegion#2-Bur-1 ) ;
5735: LD_EXP 1
5739: PPUSH
5740: LD_STRING DQrLegion#2-Bur-1
5742: PPUSH
5743: CALL_OW 88
// DialogueOff ;
5747: CALL_OW 7
// end ;
5751: LD_VAR 0 1
5755: RET
// export function D_FiringRange ; begin
5756: LD_INT 0
5758: PPUSH
// DialogueOn ;
5759: CALL_OW 6
// if IsOK ( Kuzmov ) then
5763: LD_EXP 10
5767: PPUSH
5768: CALL_OW 302
5772: IFFALSE 5788
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
5774: LD_EXP 10
5778: PPUSH
5779: LD_STRING DFiringRange-Kuz-1
5781: PPUSH
5782: CALL_OW 88
5786: GO 5800
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
5788: LD_EXP 19
5792: PPUSH
5793: LD_STRING DFiringRange-Obl-1
5795: PPUSH
5796: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
5800: LD_EXP 1
5804: PPUSH
5805: LD_STRING DFiringRange-Bur-1
5807: PPUSH
5808: CALL_OW 88
// CenterOnXY ( 59 , 34 ) ;
5812: LD_INT 59
5814: PPUSH
5815: LD_INT 34
5817: PPUSH
5818: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
5822: LD_INT 18
5824: PPUSH
5825: CALL_OW 67
// RevealFogArea ( you , ShootArea ) ;
5829: LD_EXP 31
5833: PPUSH
5834: LD_INT 11
5836: PPUSH
5837: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
5841: LD_INT 11
5843: PPUSH
5844: LD_INT 1
5846: PPUSH
5847: CALL_OW 424
// if IsOK ( Kuzmov ) then
5851: LD_EXP 10
5855: PPUSH
5856: CALL_OW 302
5860: IFFALSE 5876
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
5862: LD_EXP 10
5866: PPUSH
5867: LD_STRING DFiringRange-Kuz-2
5869: PPUSH
5870: CALL_OW 88
5874: GO 5888
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
5876: LD_EXP 19
5880: PPUSH
5881: LD_STRING DFiringRange-Obl-2
5883: PPUSH
5884: CALL_OW 88
// DialogueOff ;
5888: CALL_OW 7
// end ;
5892: LD_VAR 0 1
5896: RET
// export function D_QrShootingGallery1 ; begin
5897: LD_INT 0
5899: PPUSH
// Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
5900: LD_EXP 1
5904: PPUSH
5905: LD_STRING DQrShootingGallery#1-Bur-1
5907: PPUSH
5908: CALL_OW 88
// end ;
5912: LD_VAR 0 1
5916: RET
// export function D_QrShootingGallery2 ; begin
5917: LD_INT 0
5919: PPUSH
// Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
5920: LD_EXP 1
5924: PPUSH
5925: LD_STRING DQrShootingGallery#2-Bur-1
5927: PPUSH
5928: CALL_OW 88
// end ;
5932: LD_VAR 0 1
5936: RET
// export function D_Hunting ; var allhunters ; begin
5937: LD_INT 0
5939: PPUSH
5940: PPUSH
// DialogueOn ;
5941: CALL_OW 6
// allhunters := [ ] ;
5945: LD_ADDR_VAR 0 2
5949: PUSH
5950: EMPTY
5951: ST_TO_ADDR
// if IsOK ( Belkov ) then
5952: LD_EXP 3
5956: PPUSH
5957: CALL_OW 302
5961: IFFALSE 5979
// allhunters := allhunters ^ Belkov ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_VAR 0 2
5972: PUSH
5973: LD_EXP 3
5977: ADD
5978: ST_TO_ADDR
// if IsOK ( Karamazov ) then
5979: LD_EXP 17
5983: PPUSH
5984: CALL_OW 302
5988: IFFALSE 6006
// allhunters := allhunters ^ Karamazov ;
5990: LD_ADDR_VAR 0 2
5994: PUSH
5995: LD_VAR 0 2
5999: PUSH
6000: LD_EXP 17
6004: ADD
6005: ST_TO_ADDR
// if IsOK ( Kozlov ) then
6006: LD_EXP 20
6010: PPUSH
6011: CALL_OW 302
6015: IFFALSE 6033
// allhunters := allhunters ^ Kozlov ;
6017: LD_ADDR_VAR 0 2
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_EXP 20
6031: ADD
6032: ST_TO_ADDR
// Randomize ;
6033: CALL_OW 10
// RandomizeAll ;
6037: CALL_OW 11
// hunter := allhunters [ Rand ( 1 , ( allhunters + 0 ) ) ] ;
6041: LD_ADDR_EXP 72
6045: PUSH
6046: LD_VAR 0 2
6050: PUSH
6051: LD_INT 1
6053: PPUSH
6054: LD_VAR 0 2
6058: PUSH
6059: LD_INT 0
6061: PLUS
6062: PPUSH
6063: CALL_OW 12
6067: ARRAY
6068: ST_TO_ADDR
// case hunter of Belkov :
6069: LD_EXP 72
6073: PUSH
6074: LD_EXP 3
6078: DOUBLE
6079: EQUAL
6080: IFTRUE 6084
6082: GO 6099
6084: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
6085: LD_EXP 3
6089: PPUSH
6090: LD_STRING DHunting-Bel-1
6092: PPUSH
6093: CALL_OW 88
6097: GO 6150
6099: LD_EXP 17
6103: DOUBLE
6104: EQUAL
6105: IFTRUE 6109
6107: GO 6124
6109: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
6110: LD_EXP 17
6114: PPUSH
6115: LD_STRING DHunting-Kar-1
6117: PPUSH
6118: CALL_OW 88
6122: GO 6150
6124: LD_EXP 20
6128: DOUBLE
6129: EQUAL
6130: IFTRUE 6134
6132: GO 6149
6134: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
6135: LD_EXP 20
6139: PPUSH
6140: LD_STRING DHunting-Koz-1
6142: PPUSH
6143: CALL_OW 88
6147: GO 6150
6149: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
6150: LD_EXP 1
6154: PPUSH
6155: LD_STRING DHunting-Bur-1
6157: PPUSH
6158: CALL_OW 88
// case hunter of Belkov :
6162: LD_EXP 72
6166: PUSH
6167: LD_EXP 3
6171: DOUBLE
6172: EQUAL
6173: IFTRUE 6177
6175: GO 6192
6177: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
6178: LD_EXP 3
6182: PPUSH
6183: LD_STRING DHunting-Bel-2
6185: PPUSH
6186: CALL_OW 88
6190: GO 6243
6192: LD_EXP 17
6196: DOUBLE
6197: EQUAL
6198: IFTRUE 6202
6200: GO 6217
6202: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
6203: LD_EXP 17
6207: PPUSH
6208: LD_STRING DHunting-Kar-2
6210: PPUSH
6211: CALL_OW 88
6215: GO 6243
6217: LD_EXP 20
6221: DOUBLE
6222: EQUAL
6223: IFTRUE 6227
6225: GO 6242
6227: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
6228: LD_EXP 20
6232: PPUSH
6233: LD_STRING DHunting-Koz-2
6235: PPUSH
6236: CALL_OW 88
6240: GO 6243
6242: POP
// DialogueOff ;
6243: CALL_OW 7
// end ;
6247: LD_VAR 0 1
6251: RET
// export function D_QrHunting1 ; begin
6252: LD_INT 0
6254: PPUSH
// Say ( Burlak , DQrHunting#1-Bur-1 ) ;
6255: LD_EXP 1
6259: PPUSH
6260: LD_STRING DQrHunting#1-Bur-1
6262: PPUSH
6263: CALL_OW 88
// end ;
6267: LD_VAR 0 1
6271: RET
// export function D_QrHunting2 ; begin
6272: LD_INT 0
6274: PPUSH
// Say ( Burlak , DQrHunting#2-Bur-1 ) ;
6275: LD_EXP 1
6279: PPUSH
6280: LD_STRING DQrHunting#2-Bur-1
6282: PPUSH
6283: CALL_OW 88
// end ;
6287: LD_VAR 0 1
6291: RET
// export function D_FreeTime ; var pole ; begin
6292: LD_INT 0
6294: PPUSH
6295: PPUSH
// DialogueOn ;
6296: CALL_OW 6
// Randomize ;
6300: CALL_OW 10
// RandomizeAll ;
6304: CALL_OW 11
// pole := [ ] ;
6308: LD_ADDR_VAR 0 2
6312: PUSH
6313: EMPTY
6314: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
6315: LD_EXP 6
6319: PPUSH
6320: CALL_OW 302
6324: IFFALSE 6342
// pole := pole ^ Kapitsova ;
6326: LD_ADDR_VAR 0 2
6330: PUSH
6331: LD_VAR 0 2
6335: PUSH
6336: LD_EXP 6
6340: ADD
6341: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Petrovova :
6342: LD_VAR 0 2
6346: PUSH
6347: LD_INT 1
6349: PPUSH
6350: LD_INT 0
6352: PUSH
6353: LD_VAR 0 2
6357: PLUS
6358: PPUSH
6359: CALL_OW 12
6363: ARRAY
6364: PUSH
6365: LD_EXP 21
6369: DOUBLE
6370: EQUAL
6371: IFTRUE 6375
6373: GO 6400
6375: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
6376: LD_EXP 21
6380: PPUSH
6381: LD_STRING DFreeTime-Ptr-1
6383: PPUSH
6384: CALL_OW 88
// FreeWoman := Petrovova ;
6388: LD_ADDR_EXP 58
6392: PUSH
6393: LD_EXP 21
6397: ST_TO_ADDR
// end ; Kirilenkova :
6398: GO 6471
6400: LD_EXP 4
6404: DOUBLE
6405: EQUAL
6406: IFTRUE 6410
6408: GO 6435
6410: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
6411: LD_EXP 4
6415: PPUSH
6416: LD_STRING DFreeTime-Kir-1
6418: PPUSH
6419: CALL_OW 88
// FreeWoman := Kirilenkova ;
6423: LD_ADDR_EXP 58
6427: PUSH
6428: LD_EXP 4
6432: ST_TO_ADDR
// end ; Kapitsova :
6433: GO 6471
6435: LD_EXP 6
6439: DOUBLE
6440: EQUAL
6441: IFTRUE 6445
6443: GO 6470
6445: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
6446: LD_EXP 6
6450: PPUSH
6451: LD_STRING DFreeTime-Kap-1
6453: PPUSH
6454: CALL_OW 88
// FreeWoman := Kapitsova ;
6458: LD_ADDR_EXP 58
6462: PUSH
6463: LD_EXP 6
6467: ST_TO_ADDR
// end ; end ;
6468: GO 6471
6470: POP
// pole := [ ] ;
6471: LD_ADDR_VAR 0 2
6475: PUSH
6476: EMPTY
6477: ST_TO_ADDR
// if IsOK ( Kuzmov ) then
6478: LD_EXP 10
6482: PPUSH
6483: CALL_OW 302
6487: IFFALSE 6505
// pole := pole ^ Kuzmov ;
6489: LD_ADDR_VAR 0 2
6493: PUSH
6494: LD_VAR 0 2
6498: PUSH
6499: LD_EXP 10
6503: ADD
6504: ST_TO_ADDR
// if IsOK ( Titov ) then
6505: LD_EXP 18
6509: PPUSH
6510: CALL_OW 302
6514: IFFALSE 6532
// pole := pole ^ Titov ;
6516: LD_ADDR_VAR 0 2
6520: PUSH
6521: LD_VAR 0 2
6525: PUSH
6526: LD_EXP 18
6530: ADD
6531: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
6532: LD_EXP 5
6536: PPUSH
6537: CALL_OW 302
6541: IFFALSE 6559
// pole := pole ^ Gnyevko ;
6543: LD_ADDR_VAR 0 2
6547: PUSH
6548: LD_VAR 0 2
6552: PUSH
6553: LD_EXP 5
6557: ADD
6558: ST_TO_ADDR
// if IsOK ( Oblukov ) then
6559: LD_EXP 19
6563: PPUSH
6564: CALL_OW 302
6568: IFFALSE 6586
// pole := pole ^ Oblukov ;
6570: LD_ADDR_VAR 0 2
6574: PUSH
6575: LD_VAR 0 2
6579: PUSH
6580: LD_EXP 19
6584: ADD
6585: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Kuzmov :
6586: LD_VAR 0 2
6590: PUSH
6591: LD_INT 1
6593: PPUSH
6594: LD_INT 0
6596: PUSH
6597: LD_VAR 0 2
6601: PLUS
6602: PPUSH
6603: CALL_OW 12
6607: ARRAY
6608: PUSH
6609: LD_EXP 10
6613: DOUBLE
6614: EQUAL
6615: IFTRUE 6619
6617: GO 6644
6619: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
6620: LD_EXP 10
6624: PPUSH
6625: LD_STRING DFreeTime-Kuz-1
6627: PPUSH
6628: CALL_OW 88
// FreeMan := Kuzmov ;
6632: LD_ADDR_EXP 57
6636: PUSH
6637: LD_EXP 10
6641: ST_TO_ADDR
// end ; Titov :
6642: GO 6750
6644: LD_EXP 18
6648: DOUBLE
6649: EQUAL
6650: IFTRUE 6654
6652: GO 6679
6654: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
6655: LD_EXP 18
6659: PPUSH
6660: LD_STRING DFreeTime-Tit-1
6662: PPUSH
6663: CALL_OW 88
// FreeMan := Titov ;
6667: LD_ADDR_EXP 57
6671: PUSH
6672: LD_EXP 18
6676: ST_TO_ADDR
// end ; Gnyevko :
6677: GO 6750
6679: LD_EXP 5
6683: DOUBLE
6684: EQUAL
6685: IFTRUE 6689
6687: GO 6714
6689: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
6690: LD_EXP 5
6694: PPUSH
6695: LD_STRING DFreeTime-Gny-1
6697: PPUSH
6698: CALL_OW 88
// FreeMan := Gnyevko ;
6702: LD_ADDR_EXP 57
6706: PUSH
6707: LD_EXP 5
6711: ST_TO_ADDR
// end ; Oblukov :
6712: GO 6750
6714: LD_EXP 19
6718: DOUBLE
6719: EQUAL
6720: IFTRUE 6724
6722: GO 6749
6724: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
6725: LD_EXP 19
6729: PPUSH
6730: LD_STRING DFreeTime-Obl-1
6732: PPUSH
6733: CALL_OW 88
// FreeMan := Oblukov ;
6737: LD_ADDR_EXP 57
6741: PUSH
6742: LD_EXP 19
6746: ST_TO_ADDR
// end ; end ;
6747: GO 6750
6749: POP
// DialogueOff ;
6750: CALL_OW 7
// end ;
6754: LD_VAR 0 1
6758: RET
// export function D_QrFreeTime1 ; begin
6759: LD_INT 0
6761: PPUSH
// Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
6762: LD_EXP 1
6766: PPUSH
6767: LD_STRING DQrFreeTime#1-Bur-1
6769: PPUSH
6770: CALL_OW 88
// end ;
6774: LD_VAR 0 1
6778: RET
// export function D_QrFreeTime2 ; begin
6779: LD_INT 0
6781: PPUSH
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ;
6782: LD_EXP 1
6786: PPUSH
6787: LD_STRING DQrFreeTime#2-Bur-1
6789: PPUSH
6790: CALL_OW 88
// end ;
6794: LD_VAR 0 1
6798: RET
// export function D_Masha ; begin
6799: LD_INT 0
6801: PPUSH
// DialogueOn ;
6802: CALL_OW 6
// Say ( Kozlov , DMasha-Koz-1 ) ;
6806: LD_EXP 20
6810: PPUSH
6811: LD_STRING DMasha-Koz-1
6813: PPUSH
6814: CALL_OW 88
// DialogueOff ;
6818: CALL_OW 7
// end ;
6822: LD_VAR 0 1
6826: RET
// export function D_Masha2 ; begin
6827: LD_INT 0
6829: PPUSH
// Say ( Burlak , DMasha2-Bur-1 ) ;
6830: LD_EXP 1
6834: PPUSH
6835: LD_STRING DMasha2-Bur-1
6837: PPUSH
6838: CALL_OW 88
// end ;
6842: LD_VAR 0 1
6846: RET
// export function D_AI ; begin
6847: LD_INT 0
6849: PPUSH
// DialogueOn ;
6850: CALL_OW 6
// if IsOK ( Scholtze ) then
6854: LD_EXP 15
6858: PPUSH
6859: CALL_OW 302
6863: IFFALSE 6879
// Say ( Scholtze , DAI-Sch-1 ) else
6865: LD_EXP 15
6869: PPUSH
6870: LD_STRING DAI-Sch-1
6872: PPUSH
6873: CALL_OW 88
6877: GO 6891
// Say ( Kapitsova , DAI-Kap-1 ) ;
6879: LD_EXP 6
6883: PPUSH
6884: LD_STRING DAI-Kap-1
6886: PPUSH
6887: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
6891: LD_EXP 1
6895: PPUSH
6896: LD_STRING DAI-Bur-1
6898: PPUSH
6899: CALL_OW 88
// if IsOK ( Scholtze ) then
6903: LD_EXP 15
6907: PPUSH
6908: CALL_OW 302
6912: IFFALSE 6928
// Say ( Scholtze , DAI-Sch-2 ) else
6914: LD_EXP 15
6918: PPUSH
6919: LD_STRING DAI-Sch-2
6921: PPUSH
6922: CALL_OW 88
6926: GO 6940
// Say ( Kapitsova , DAI-Kap-2 ) ;
6928: LD_EXP 6
6932: PPUSH
6933: LD_STRING DAI-Kap-2
6935: PPUSH
6936: CALL_OW 88
// DialogueOff ;
6940: CALL_OW 7
// end ;
6944: LD_VAR 0 1
6948: RET
// export function D_SpontTelep ; begin
6949: LD_INT 0
6951: PPUSH
// DialogueOn ;
6952: CALL_OW 6
// if IsOK ( Scholtze ) then
6956: LD_EXP 15
6960: PPUSH
6961: CALL_OW 302
6965: IFFALSE 6981
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
6967: LD_EXP 15
6971: PPUSH
6972: LD_STRING DSpontTelep-Sch-1
6974: PPUSH
6975: CALL_OW 88
6979: GO 6993
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
6981: LD_EXP 6
6985: PPUSH
6986: LD_STRING DSpontTelep-Kap-1
6988: PPUSH
6989: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
6993: LD_EXP 1
6997: PPUSH
6998: LD_STRING DSpontTelep-Bur-1
7000: PPUSH
7001: CALL_OW 88
// if IsOK ( Scholtze ) then
7005: LD_EXP 15
7009: PPUSH
7010: CALL_OW 302
7014: IFFALSE 7030
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
7016: LD_EXP 15
7020: PPUSH
7021: LD_STRING DSpontTelep-Sch-2
7023: PPUSH
7024: CALL_OW 88
7028: GO 7042
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
7030: LD_EXP 6
7034: PPUSH
7035: LD_STRING DSpontTelep-Kap-2
7037: PPUSH
7038: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
7042: LD_EXP 1
7046: PPUSH
7047: LD_STRING DSpontTelep-Bur-2
7049: PPUSH
7050: CALL_OW 88
// DialogueOff ;
7054: CALL_OW 7
// end ;
7058: LD_VAR 0 1
7062: RET
// export function D_AmAttackStart ; begin
7063: LD_INT 0
7065: PPUSH
// SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
7066: LD_EXP 2
7070: PPUSH
7071: LD_STRING DAmAttackStart-Pop-1
7073: PPUSH
7074: CALL_OW 94
// enable ( 50 ) ;
7078: LD_INT 50
7080: ENABLE_MARKED
// end ;
7081: LD_VAR 0 1
7085: RET
// every 0 0$1 marked 50 do
7086: GO 7088
7088: DISABLE
// begin Wait ( 0 0$10 ) ;
7089: LD_INT 350
7091: PPUSH
7092: CALL_OW 67
// if MercPaid then
7096: LD_EXP 39
7100: IFFALSE 7139
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
7102: LD_EXP 1
7106: PPUSH
7107: LD_STRING DAmAttackStart-Bur-1
7109: PPUSH
7110: CALL_OW 88
// if IsOK ( Gleb ) then
7114: LD_EXP 8
7118: PPUSH
7119: CALL_OW 302
7123: IFFALSE 7137
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
7125: LD_EXP 8
7129: PPUSH
7130: LD_STRING DAmAttackStart-Glb-1
7132: PPUSH
7133: CALL_OW 88
// end else
7137: GO 7151
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
7139: LD_EXP 1
7143: PPUSH
7144: LD_STRING DAmAttackStart-Bur-2
7146: PPUSH
7147: CALL_OW 88
// end ;
7151: END
// export function D_AmAttackFin ; var rnd , bool ; begin
7152: LD_INT 0
7154: PPUSH
7155: PPUSH
7156: PPUSH
// DialogueOn ;
7157: CALL_OW 6
// repeat rnd := Rand ( 1 , 7 ) ;
7161: LD_ADDR_VAR 0 2
7165: PUSH
7166: LD_INT 1
7168: PPUSH
7169: LD_INT 7
7171: PPUSH
7172: CALL_OW 12
7176: ST_TO_ADDR
// case rnd of 1 :
7177: LD_VAR 0 2
7181: PUSH
7182: LD_INT 1
7184: DOUBLE
7185: EQUAL
7186: IFTRUE 7190
7188: GO 7222
7190: POP
// if IsOK ( Belkov ) then
7191: LD_EXP 3
7195: PPUSH
7196: CALL_OW 302
7200: IFFALSE 7220
// bool := Say ( Belkov , DAmAttackFin-Bel-1 ) ; 2 :
7202: LD_ADDR_VAR 0 3
7206: PUSH
7207: LD_EXP 3
7211: PPUSH
7212: LD_STRING DAmAttackFin-Bel-1
7214: PPUSH
7215: CALL_OW 88
7219: ST_TO_ADDR
7220: GO 7463
7222: LD_INT 2
7224: DOUBLE
7225: EQUAL
7226: IFTRUE 7230
7228: GO 7262
7230: POP
// if IsOK ( Gnyevko ) then
7231: LD_EXP 5
7235: PPUSH
7236: CALL_OW 302
7240: IFFALSE 7260
// bool := Say ( Gnyevko , DAmAttackFin-Gny-1 ) ; 3 :
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: LD_EXP 5
7251: PPUSH
7252: LD_STRING DAmAttackFin-Gny-1
7254: PPUSH
7255: CALL_OW 88
7259: ST_TO_ADDR
7260: GO 7463
7262: LD_INT 3
7264: DOUBLE
7265: EQUAL
7266: IFTRUE 7270
7268: GO 7302
7270: POP
// if IsOK ( Titov ) then
7271: LD_EXP 18
7275: PPUSH
7276: CALL_OW 302
7280: IFFALSE 7300
// bool := Say ( Titov , DAmAttackFin-Tit-1 ) ; 4 :
7282: LD_ADDR_VAR 0 3
7286: PUSH
7287: LD_EXP 18
7291: PPUSH
7292: LD_STRING DAmAttackFin-Tit-1
7294: PPUSH
7295: CALL_OW 88
7299: ST_TO_ADDR
7300: GO 7463
7302: LD_INT 4
7304: DOUBLE
7305: EQUAL
7306: IFTRUE 7310
7308: GO 7342
7310: POP
// if IsOK ( Lipshchin ) then
7311: LD_EXP 22
7315: PPUSH
7316: CALL_OW 302
7320: IFFALSE 7340
// bool := Say ( Lipshchin , DAmAttackFin-Lip-1 ) ; 5 :
7322: LD_ADDR_VAR 0 3
7326: PUSH
7327: LD_EXP 22
7331: PPUSH
7332: LD_STRING DAmAttackFin-Lip-1
7334: PPUSH
7335: CALL_OW 88
7339: ST_TO_ADDR
7340: GO 7463
7342: LD_INT 5
7344: DOUBLE
7345: EQUAL
7346: IFTRUE 7350
7348: GO 7382
7350: POP
// if IsOK ( Karamazov ) then
7351: LD_EXP 17
7355: PPUSH
7356: CALL_OW 302
7360: IFFALSE 7380
// bool := Say ( Karamazov , DAmAttackFin-Kar-1 ) ; 6 :
7362: LD_ADDR_VAR 0 3
7366: PUSH
7367: LD_EXP 17
7371: PPUSH
7372: LD_STRING DAmAttackFin-Kar-1
7374: PPUSH
7375: CALL_OW 88
7379: ST_TO_ADDR
7380: GO 7463
7382: LD_INT 6
7384: DOUBLE
7385: EQUAL
7386: IFTRUE 7390
7388: GO 7422
7390: POP
// if IsOK ( Oblukov ) then
7391: LD_EXP 19
7395: PPUSH
7396: CALL_OW 302
7400: IFFALSE 7420
// bool := Say ( Oblukov , DAmAttackFin-Obl-1 ) ; 7 :
7402: LD_ADDR_VAR 0 3
7406: PUSH
7407: LD_EXP 19
7411: PPUSH
7412: LD_STRING DAmAttackFin-Obl-1
7414: PPUSH
7415: CALL_OW 88
7419: ST_TO_ADDR
7420: GO 7463
7422: LD_INT 7
7424: DOUBLE
7425: EQUAL
7426: IFTRUE 7430
7428: GO 7462
7430: POP
// if IsOK ( Burlak ) then
7431: LD_EXP 1
7435: PPUSH
7436: CALL_OW 302
7440: IFFALSE 7460
// bool := Say ( Burlak , DAmAttackFin-Bur-1 ) ; end ;
7442: LD_ADDR_VAR 0 3
7446: PUSH
7447: LD_EXP 1
7451: PPUSH
7452: LD_STRING DAmAttackFin-Bur-1
7454: PPUSH
7455: CALL_OW 88
7459: ST_TO_ADDR
7460: GO 7463
7462: POP
// until bool ;
7463: LD_VAR 0 3
7467: IFFALSE 7161
// Say ( Popov , DAmAttackFin-Pop-1 ) ;
7469: LD_EXP 2
7473: PPUSH
7474: LD_STRING DAmAttackFin-Pop-1
7476: PPUSH
7477: CALL_OW 88
// DialogueOff ;
7481: CALL_OW 7
// end ; end_of_file
7485: LD_VAR 0 1
7489: RET
// export function merc_help ; var rnd ; begin
7490: LD_INT 0
7492: PPUSH
7493: PPUSH
// rnd := Rand ( 2 2$0 , 3 3$0 ) ;
7494: LD_ADDR_VAR 0 2
7498: PUSH
7499: LD_INT 4200
7501: PPUSH
7502: LD_INT 6300
7504: PPUSH
7505: CALL_OW 12
7509: ST_TO_ADDR
// Wait ( rnd ) ;
7510: LD_VAR 0 2
7514: PPUSH
7515: CALL_OW 67
// if not HeikeKilled then
7519: LD_EXP 38
7523: NOT
7524: IFFALSE 7686
// begin D_MercHelp ;
7526: CALL 4972 0 0
// case Query ( QMerc ) of 1 :
7530: LD_STRING QMerc
7532: PPUSH
7533: CALL_OW 97
7537: PUSH
7538: LD_INT 1
7540: DOUBLE
7541: EQUAL
7542: IFTRUE 7546
7544: GO 7569
7546: POP
// begin D_QrMerc1 ;
7547: CALL 5048 0 0
// create_kurt ;
7551: CALL 3155 0 0
// MercAccepted := true ;
7555: LD_ADDR_EXP 44
7559: PUSH
7560: LD_INT 1
7562: ST_TO_ADDR
// come_to_build_barracks ;
7563: CALL 8159 0 0
// end ; 2 :
7567: GO 7678
7569: LD_INT 2
7571: DOUBLE
7572: EQUAL
7573: IFTRUE 7577
7575: GO 7608
7577: POP
// begin D_QrMerc2 ;
7578: CALL 5088 0 0
// PopovAsked := true ;
7582: LD_ADDR_EXP 46
7586: PUSH
7587: LD_INT 1
7589: ST_TO_ADDR
// create_kurt ;
7590: CALL 3155 0 0
// MercAccepted := true ;
7594: LD_ADDR_EXP 44
7598: PUSH
7599: LD_INT 1
7601: ST_TO_ADDR
// come_to_build_barracks ;
7602: CALL 8159 0 0
// end ; 3 :
7606: GO 7678
7608: LD_INT 3
7610: DOUBLE
7611: EQUAL
7612: IFTRUE 7616
7614: GO 7677
7616: POP
// begin D_QrMerc3 ;
7617: CALL 5140 0 0
// PopovAsked := true ;
7621: LD_ADDR_EXP 46
7625: PUSH
7626: LD_INT 1
7628: ST_TO_ADDR
// Wait ( 0 0$13 ) ;
7629: LD_INT 455
7631: PPUSH
7632: CALL_OW 67
// create_kurt ;
7636: CALL 3155 0 0
// ComMoveToArea ( [ Kurt , Mercenary1 ] , WaitHeikeArea ) ;
7640: LD_EXP 13
7644: PUSH
7645: LD_EXP 14
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: LD_INT 8
7656: PPUSH
7657: CALL_OW 113
// enable ( 6 ) ;
7661: LD_INT 6
7663: ENABLE_MARKED
// enable ( 20 ) ;
7664: LD_INT 20
7666: ENABLE_MARKED
// D_MercAttack ;
7667: CALL 5313 0 0
// merc_attack ;
7671: CALL 7691 0 0
// end ; end ;
7675: GO 7678
7677: POP
// MortarAsked := true ;
7678: LD_ADDR_EXP 69
7682: PUSH
7683: LD_INT 1
7685: ST_TO_ADDR
// end ; end ;
7686: LD_VAR 0 1
7690: RET
// export function merc_attack ; var grp , celkemgrp , rnd , pocet , mercenaries , filter ; begin
7691: LD_INT 0
7693: PPUSH
7694: PPUSH
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// repeat SetAttitude ( you , merc , att_enemy , true ) ;
7700: LD_EXP 31
7704: PPUSH
7705: LD_EXP 34
7709: PPUSH
7710: LD_INT 2
7712: PPUSH
7713: LD_INT 1
7715: PPUSH
7716: CALL_OW 80
// mercenaries := [ ] ;
7720: LD_ADDR_VAR 0 6
7724: PUSH
7725: EMPTY
7726: ST_TO_ADDR
// grp := Rand ( 1 , 6 ) ;
7727: LD_ADDR_VAR 0 2
7731: PUSH
7732: LD_INT 1
7734: PPUSH
7735: LD_INT 6
7737: PPUSH
7738: CALL_OW 12
7742: ST_TO_ADDR
// for pocet := 1 to grp do
7743: LD_ADDR_VAR 0 5
7747: PUSH
7748: DOUBLE
7749: LD_INT 1
7751: DEC
7752: ST_TO_ADDR
7753: LD_VAR 0 2
7757: PUSH
7758: FOR_TO
7759: IFFALSE 7882
// begin uc_side = merc ;
7761: LD_ADDR_OWVAR 20
7765: PUSH
7766: LD_EXP 34
7770: ST_TO_ADDR
// uc_nation := nation_arabian ;
7771: LD_ADDR_OWVAR 21
7775: PUSH
7776: LD_INT 2
7778: ST_TO_ADDR
// rnd := Rand ( 1 , 2 ) ;
7779: LD_ADDR_VAR 0 4
7783: PUSH
7784: LD_INT 1
7786: PPUSH
7787: LD_INT 2
7789: PPUSH
7790: CALL_OW 12
7794: ST_TO_ADDR
// case rnd of 1 :
7795: LD_VAR 0 4
7799: PUSH
7800: LD_INT 1
7802: DOUBLE
7803: EQUAL
7804: IFTRUE 7808
7806: GO 7824
7808: POP
// PrepareHuman ( sex_male , class_soldier , 2 ) ; 2 :
7809: LD_INT 1
7811: PPUSH
7812: LD_INT 1
7814: PPUSH
7815: LD_INT 2
7817: PPUSH
7818: CALL_OW 380
7822: GO 7849
7824: LD_INT 2
7826: DOUBLE
7827: EQUAL
7828: IFTRUE 7832
7830: GO 7848
7832: POP
// PrepareHuman ( sex_male , class_mortar , 2 ) ; end ;
7833: LD_INT 1
7835: PPUSH
7836: LD_INT 8
7838: PPUSH
7839: LD_INT 2
7841: PPUSH
7842: CALL_OW 380
7846: GO 7849
7848: POP
// hc_name :=  ;
7849: LD_ADDR_OWVAR 26
7853: PUSH
7854: LD_STRING 
7856: ST_TO_ADDR
// mercenaries := mercenaries ^ CreateHuman ;
7857: LD_ADDR_VAR 0 6
7861: PUSH
7862: LD_VAR 0 6
7866: PUSH
7867: CALL_OW 44
7871: ADD
7872: ST_TO_ADDR
// Wait ( 2 ) ;
7873: LD_INT 2
7875: PPUSH
7876: CALL_OW 67
// end ;
7880: GO 7758
7882: POP
7883: POP
// for pocet := 1 to grp do
7884: LD_ADDR_VAR 0 5
7888: PUSH
7889: DOUBLE
7890: LD_INT 1
7892: DEC
7893: ST_TO_ADDR
7894: LD_VAR 0 2
7898: PUSH
7899: FOR_TO
7900: IFFALSE 7977
// begin if HeikeDismissed then
7902: LD_EXP 45
7906: IFFALSE 7912
// exit ;
7908: POP
7909: POP
7910: GO 8154
// PlaceUnitArea ( mercenaries [ pocet ] , AttackArea , false ) ;
7912: LD_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: ARRAY
7922: PPUSH
7923: LD_INT 5
7925: PPUSH
7926: LD_INT 0
7928: PPUSH
7929: CALL_OW 49
// ComAgressiveMove ( mercenaries [ pocet ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
7933: LD_VAR 0 6
7937: PUSH
7938: LD_VAR 0 5
7942: ARRAY
7943: PPUSH
7944: LD_EXP 1
7948: PPUSH
7949: CALL_OW 250
7953: PPUSH
7954: LD_EXP 1
7958: PPUSH
7959: CALL_OW 251
7963: PPUSH
7964: CALL_OW 114
// Wait ( 1 ) ;
7968: LD_INT 1
7970: PPUSH
7971: CALL_OW 67
// end ;
7975: GO 7899
7977: POP
7978: POP
// celkemgrp := celkemgrp + grp ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 3
7988: PUSH
7989: LD_VAR 0 2
7993: PLUS
7994: ST_TO_ADDR
// Wait ( 1 1$0 ) ;
7995: LD_INT 2100
7997: PPUSH
7998: CALL_OW 67
// until HeikeSend or celkemgrp > pocetmercenaries ;
8002: LD_EXP 65
8006: PUSH
8007: LD_VAR 0 3
8011: PUSH
8012: LD_EXP 78
8016: GREATER
8017: OR
8018: IFFALSE 7700
// repeat Wait ( 0 0$1 ) ;
8020: LD_INT 35
8022: PPUSH
8023: CALL_OW 67
// until HeikeDismissed or celkemgrp > pocetmercenaries ;
8027: LD_EXP 45
8031: PUSH
8032: LD_VAR 0 3
8036: PUSH
8037: LD_EXP 78
8041: GREATER
8042: OR
8043: IFFALSE 8020
// if HeikeDismissed then
8045: LD_EXP 45
8049: IFFALSE 8154
// begin SetAttitude ( you , merc , att_friend , true ) ;
8051: LD_EXP 31
8055: PPUSH
8056: LD_EXP 34
8060: PPUSH
8061: LD_INT 1
8063: PPUSH
8064: LD_INT 1
8066: PPUSH
8067: CALL_OW 80
// filter := FilterAllUnits ( [ f_side , merc ] ) ;
8071: LD_ADDR_VAR 0 7
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_EXP 34
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PPUSH
8088: CALL_OW 69
8092: ST_TO_ADDR
// ComAgressiveMove ( filter , 29 , 57 ) ;
8093: LD_VAR 0 7
8097: PPUSH
8098: LD_INT 29
8100: PPUSH
8101: LD_INT 57
8103: PPUSH
8104: CALL_OW 114
// enable ( 5 ) ;
8108: LD_INT 5
8110: ENABLE_MARKED
// repeat Wait ( 0 0$3 ) ;
8111: LD_INT 105
8113: PPUSH
8114: CALL_OW 67
// ComAgressiveMove ( filter , 29 , 57 ) ;
8118: LD_VAR 0 7
8122: PPUSH
8123: LD_INT 29
8125: PPUSH
8126: LD_INT 57
8128: PPUSH
8129: CALL_OW 114
// until FilterAllUnits ( [ f_side , merc ] ) = [ ] ;
8133: LD_INT 22
8135: PUSH
8136: LD_EXP 34
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PPUSH
8145: CALL_OW 69
8149: PUSH
8150: EMPTY
8151: EQUAL
8152: IFFALSE 8111
// end ; end ;
8154: LD_VAR 0 1
8158: RET
// function come_to_build_barracks ; var x , y , d , filter ; begin
8159: LD_INT 0
8161: PPUSH
8162: PPUSH
8163: PPUSH
8164: PPUSH
8165: PPUSH
// SetAttitude ( you , merc , att_neutral , true ) ;
8166: LD_EXP 31
8170: PPUSH
8171: LD_EXP 34
8175: PPUSH
8176: LD_INT 0
8178: PPUSH
8179: LD_INT 1
8181: PPUSH
8182: CALL_OW 80
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8186: LD_ADDR_VAR 0 5
8190: PUSH
8191: LD_INT 22
8193: PUSH
8194: LD_EXP 31
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: PUSH
8203: LD_INT 2
8205: PUSH
8206: LD_INT 30
8208: PUSH
8209: LD_INT 0
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: PUSH
8216: LD_INT 30
8218: PUSH
8219: LD_INT 1
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: PUSH
8231: EMPTY
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 69
8242: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8243: LD_INT 0
8245: PUSH
8246: LD_VAR 0 5
8250: PLUS
8251: PUSH
8252: LD_INT 0
8254: NONEQUAL
8255: IFFALSE 8316
// begin x := GetX ( filter [ 1 ] ) ;
8257: LD_ADDR_VAR 0 2
8261: PUSH
8262: LD_VAR 0 5
8266: PUSH
8267: LD_INT 1
8269: ARRAY
8270: PPUSH
8271: CALL_OW 250
8275: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8276: LD_ADDR_VAR 0 3
8280: PUSH
8281: LD_VAR 0 5
8285: PUSH
8286: LD_INT 1
8288: ARRAY
8289: PPUSH
8290: CALL_OW 251
8294: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8295: LD_ADDR_VAR 0 4
8299: PUSH
8300: LD_VAR 0 5
8304: PUSH
8305: LD_INT 1
8307: ARRAY
8308: PPUSH
8309: CALL_OW 254
8313: ST_TO_ADDR
// end else
8314: GO 8354
// begin x := GetX ( Burlak ) ;
8316: LD_ADDR_VAR 0 2
8320: PUSH
8321: LD_EXP 1
8325: PPUSH
8326: CALL_OW 250
8330: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8331: LD_ADDR_VAR 0 3
8335: PUSH
8336: LD_EXP 1
8340: PPUSH
8341: CALL_OW 251
8345: ST_TO_ADDR
// d := 1 ;
8346: LD_ADDR_VAR 0 4
8350: PUSH
8351: LD_INT 1
8353: ST_TO_ADDR
// end ; ComMoveXY ( [ Kurt , Mercenary1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8354: LD_EXP 13
8358: PUSH
8359: LD_EXP 14
8363: PUSH
8364: EMPTY
8365: LIST
8366: LIST
8367: PPUSH
8368: LD_VAR 0 2
8372: PPUSH
8373: LD_VAR 0 4
8377: PPUSH
8378: LD_INT 5
8380: PPUSH
8381: CALL_OW 272
8385: PPUSH
8386: LD_VAR 0 3
8390: PPUSH
8391: LD_VAR 0 4
8395: PPUSH
8396: LD_INT 5
8398: PPUSH
8399: CALL_OW 273
8403: PPUSH
8404: CALL_OW 111
// enable ( 1 ) ;
8408: LD_INT 1
8410: ENABLE_MARKED
// end ;
8411: LD_VAR 0 1
8415: RET
// export function hand_over ; var i , filter , auto , x , y , d ; begin
8416: LD_INT 0
8418: PPUSH
8419: PPUSH
8420: PPUSH
8421: PPUSH
8422: PPUSH
8423: PPUSH
8424: PPUSH
// SetAttitude ( arab , merc , att_enemy , true ) ;
8425: LD_EXP 33
8429: PPUSH
8430: LD_EXP 34
8434: PPUSH
8435: LD_INT 2
8437: PPUSH
8438: LD_INT 1
8440: PPUSH
8441: CALL_OW 80
// SetAttitude ( arab , you , att_friend , true ) ;
8445: LD_EXP 33
8449: PPUSH
8450: LD_EXP 31
8454: PPUSH
8455: LD_INT 1
8457: PPUSH
8458: LD_INT 1
8460: PPUSH
8461: CALL_OW 80
// auto := [ ] ;
8465: LD_ADDR_VAR 0 4
8469: PUSH
8470: EMPTY
8471: ST_TO_ADDR
// ar_human := [ ] ;
8472: LD_ADDR_EXP 80
8476: PUSH
8477: EMPTY
8478: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: LD_INT 22
8486: PUSH
8487: LD_EXP 31
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: PUSH
8496: LD_INT 2
8498: PUSH
8499: LD_INT 30
8501: PUSH
8502: LD_INT 0
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 30
8511: PUSH
8512: LD_INT 1
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 69
8535: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8536: LD_INT 0
8538: PUSH
8539: LD_VAR 0 3
8543: PLUS
8544: PUSH
8545: LD_INT 0
8547: NONEQUAL
8548: IFFALSE 8609
// begin x := GetX ( filter [ 1 ] ) ;
8550: LD_ADDR_VAR 0 5
8554: PUSH
8555: LD_VAR 0 3
8559: PUSH
8560: LD_INT 1
8562: ARRAY
8563: PPUSH
8564: CALL_OW 250
8568: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8569: LD_ADDR_VAR 0 6
8573: PUSH
8574: LD_VAR 0 3
8578: PUSH
8579: LD_INT 1
8581: ARRAY
8582: PPUSH
8583: CALL_OW 251
8587: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8588: LD_ADDR_VAR 0 7
8592: PUSH
8593: LD_VAR 0 3
8597: PUSH
8598: LD_INT 1
8600: ARRAY
8601: PPUSH
8602: CALL_OW 254
8606: ST_TO_ADDR
// end else
8607: GO 8647
// begin x := GetX ( Burlak ) ;
8609: LD_ADDR_VAR 0 5
8613: PUSH
8614: LD_EXP 1
8618: PPUSH
8619: CALL_OW 250
8623: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8624: LD_ADDR_VAR 0 6
8628: PUSH
8629: LD_EXP 1
8633: PPUSH
8634: CALL_OW 251
8638: ST_TO_ADDR
// d := 1 ;
8639: LD_ADDR_VAR 0 7
8643: PUSH
8644: LD_INT 1
8646: ST_TO_ADDR
// end ; enable ( 7 ) ;
8647: LD_INT 7
8649: ENABLE_MARKED
// for i := 1 to 3 do
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: DOUBLE
8656: LD_INT 1
8658: DEC
8659: ST_TO_ADDR
8660: LD_INT 3
8662: PUSH
8663: FOR_TO
8664: IFFALSE 9229
// begin uc_side := arab ;
8666: LD_ADDR_OWVAR 20
8670: PUSH
8671: LD_EXP 33
8675: ST_TO_ADDR
// uc_nation := nation_arabian ;
8676: LD_ADDR_OWVAR 21
8680: PUSH
8681: LD_INT 2
8683: ST_TO_ADDR
// uc_direction := 3 ;
8684: LD_ADDR_OWVAR 24
8688: PUSH
8689: LD_INT 3
8691: ST_TO_ADDR
// if i <= 2 then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_INT 2
8699: LESSEQUAL
8700: IFFALSE 8717
// PrepareHuman ( sex_male , class_soldier , 7 ) else
8702: LD_INT 1
8704: PPUSH
8705: LD_INT 1
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 380
8715: GO 8730
// PrepareHuman ( sex_male , class_scientistic , 7 ) ;
8717: LD_INT 1
8719: PPUSH
8720: LD_INT 4
8722: PPUSH
8723: LD_INT 7
8725: PPUSH
8726: CALL_OW 380
// Wait ( 1 ) ;
8730: LD_INT 1
8732: PPUSH
8733: CALL_OW 67
// hc_name :=  ;
8737: LD_ADDR_OWVAR 26
8741: PUSH
8742: LD_STRING 
8744: ST_TO_ADDR
// ar_human := ar_human ^ CreateHuman ;
8745: LD_ADDR_EXP 80
8749: PUSH
8750: LD_EXP 80
8754: PUSH
8755: CALL_OW 44
8759: ADD
8760: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
8761: LD_ADDR_OWVAR 37
8765: PUSH
8766: LD_INT 13
8768: ST_TO_ADDR
// vc_engine := engine_combustion ;
8769: LD_ADDR_OWVAR 39
8773: PUSH
8774: LD_INT 1
8776: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
8777: LD_ADDR_OWVAR 40
8781: PUSH
8782: LD_INT 32
8784: ST_TO_ADDR
// vc_control := control_manual ;
8785: LD_ADDR_OWVAR 38
8789: PUSH
8790: LD_INT 1
8792: ST_TO_ADDR
// auto := auto ^ CreateVehicle ;
8793: LD_ADDR_VAR 0 4
8797: PUSH
8798: LD_VAR 0 4
8802: PUSH
8803: CALL_OW 45
8807: ADD
8808: ST_TO_ADDR
// PlaceHumanInUnit ( ar_human [ i ] , auto [ i ] ) ;
8809: LD_EXP 80
8813: PUSH
8814: LD_VAR 0 2
8818: ARRAY
8819: PPUSH
8820: LD_VAR 0 4
8824: PUSH
8825: LD_VAR 0 2
8829: ARRAY
8830: PPUSH
8831: CALL_OW 52
// PlaceUnitArea ( auto [ i ] , HandOverEnterArea , false ) ;
8835: LD_VAR 0 4
8839: PUSH
8840: LD_VAR 0 2
8844: ARRAY
8845: PPUSH
8846: LD_INT 6
8848: PPUSH
8849: LD_INT 0
8851: PPUSH
8852: CALL_OW 49
// enable ( 6 ) ;
8856: LD_INT 6
8858: ENABLE_MARKED
// case i of 1 :
8859: LD_VAR 0 2
8863: PUSH
8864: LD_INT 1
8866: DOUBLE
8867: EQUAL
8868: IFTRUE 8872
8870: GO 8963
8872: POP
// begin SetCargo ( auto [ 1 ] , mat_cans , 100 ) ;
8873: LD_VAR 0 4
8877: PUSH
8878: LD_INT 1
8880: ARRAY
8881: PPUSH
8882: LD_INT 1
8884: PPUSH
8885: LD_INT 100
8887: PPUSH
8888: CALL_OW 290
// ComMoveXY ( auto [ 1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8892: LD_VAR 0 4
8896: PUSH
8897: LD_INT 1
8899: ARRAY
8900: PPUSH
8901: LD_VAR 0 5
8905: PPUSH
8906: LD_VAR 0 7
8910: PPUSH
8911: LD_INT 5
8913: PPUSH
8914: CALL_OW 272
8918: PPUSH
8919: LD_VAR 0 6
8923: PPUSH
8924: LD_VAR 0 7
8928: PPUSH
8929: LD_INT 5
8931: PPUSH
8932: CALL_OW 273
8936: PPUSH
8937: CALL_OW 111
// Wait ( 1 ) ;
8941: LD_INT 1
8943: PPUSH
8944: CALL_OW 67
// AddComExitVehicle ( auto [ 1 ] ) ;
8948: LD_VAR 0 4
8952: PUSH
8953: LD_INT 1
8955: ARRAY
8956: PPUSH
8957: CALL_OW 181
// end ; 2 :
8961: GO 9220
8963: LD_INT 2
8965: DOUBLE
8966: EQUAL
8967: IFTRUE 8971
8969: GO 9091
8971: POP
// begin SetCargo ( auto [ 2 ] , mat_oil , 100 ) ;
8972: LD_VAR 0 4
8976: PUSH
8977: LD_INT 2
8979: ARRAY
8980: PPUSH
8981: LD_INT 2
8983: PPUSH
8984: LD_INT 100
8986: PPUSH
8987: CALL_OW 290
// ComMoveXY ( auto [ 2 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8991: LD_VAR 0 4
8995: PUSH
8996: LD_INT 2
8998: ARRAY
8999: PPUSH
9000: LD_VAR 0 5
9004: PPUSH
9005: LD_VAR 0 7
9009: PPUSH
9010: LD_INT 5
9012: PPUSH
9013: CALL_OW 272
9017: PPUSH
9018: LD_VAR 0 6
9022: PPUSH
9023: LD_VAR 0 7
9027: PPUSH
9028: LD_INT 5
9030: PPUSH
9031: CALL_OW 273
9035: PPUSH
9036: CALL_OW 111
// Wait ( 1 ) ;
9040: LD_INT 1
9042: PPUSH
9043: CALL_OW 67
// AddComExitVehicle ( auto [ 2 ] ) ;
9047: LD_VAR 0 4
9051: PUSH
9052: LD_INT 2
9054: ARRAY
9055: PPUSH
9056: CALL_OW 181
// Wait ( 1 ) ;
9060: LD_INT 1
9062: PPUSH
9063: CALL_OW 67
// AddComMoveUnit ( auto [ 2 ] , auto [ 1 ] ) ;
9067: LD_VAR 0 4
9071: PUSH
9072: LD_INT 2
9074: ARRAY
9075: PPUSH
9076: LD_VAR 0 4
9080: PUSH
9081: LD_INT 1
9083: ARRAY
9084: PPUSH
9085: CALL_OW 172
// end ; 3 :
9089: GO 9220
9091: LD_INT 3
9093: DOUBLE
9094: EQUAL
9095: IFTRUE 9099
9097: GO 9219
9099: POP
// begin SetCargo ( auto [ 3 ] , mat_siberit , 100 ) ;
9100: LD_VAR 0 4
9104: PUSH
9105: LD_INT 3
9107: ARRAY
9108: PPUSH
9109: LD_INT 3
9111: PPUSH
9112: LD_INT 100
9114: PPUSH
9115: CALL_OW 290
// ComMoveXY ( auto [ 3 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9119: LD_VAR 0 4
9123: PUSH
9124: LD_INT 3
9126: ARRAY
9127: PPUSH
9128: LD_VAR 0 5
9132: PPUSH
9133: LD_VAR 0 7
9137: PPUSH
9138: LD_INT 5
9140: PPUSH
9141: CALL_OW 272
9145: PPUSH
9146: LD_VAR 0 6
9150: PPUSH
9151: LD_VAR 0 7
9155: PPUSH
9156: LD_INT 5
9158: PPUSH
9159: CALL_OW 273
9163: PPUSH
9164: CALL_OW 111
// Wait ( 1 ) ;
9168: LD_INT 1
9170: PPUSH
9171: CALL_OW 67
// AddComExitVehicle ( auto [ 3 ] ) ;
9175: LD_VAR 0 4
9179: PUSH
9180: LD_INT 3
9182: ARRAY
9183: PPUSH
9184: CALL_OW 181
// Wait ( 1 ) ;
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 67
// AddComMoveUnit ( auto [ 3 ] , auto [ 1 ] ) ;
9195: LD_VAR 0 4
9199: PUSH
9200: LD_INT 3
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 4
9208: PUSH
9209: LD_INT 1
9211: ARRAY
9212: PPUSH
9213: CALL_OW 172
// end ; end ;
9217: GO 9220
9219: POP
// Wait ( 0 0$3 ) ;
9220: LD_INT 105
9222: PPUSH
9223: CALL_OW 67
// end ;
9227: GO 8663
9229: POP
9230: POP
// MercHandoverArabsSpawned = true ;
9231: LD_ADDR_EXP 43
9235: PUSH
9236: LD_INT 1
9238: ST_TO_ADDR
// enable ( 9 ) ;
9239: LD_INT 9
9241: ENABLE_MARKED
// end ;
9242: LD_VAR 0 1
9246: RET
// every 0 0$1 + 0 0$0.5 do var filter ;
9247: GO 9249
9249: DISABLE
9250: LD_INT 0
9252: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
9253: LD_ADDR_VAR 0 1
9257: PUSH
9258: LD_INT 22
9260: PUSH
9261: LD_EXP 31
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: PUSH
9270: LD_INT 2
9272: PUSH
9273: LD_INT 30
9275: PUSH
9276: LD_INT 0
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PUSH
9283: LD_INT 30
9285: PUSH
9286: LD_INT 1
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: LIST
9297: PUSH
9298: EMPTY
9299: LIST
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PPUSH
9305: CALL_OW 69
9309: ST_TO_ADDR
// if filter then
9310: LD_VAR 0 1
9314: IFFALSE 9328
// SetBName ( filter , trockij ) ;
9316: LD_VAR 0 1
9320: PPUSH
9321: LD_STRING trockij
9323: PPUSH
9324: CALL_OW 500
// enable ;
9328: ENABLE
// end ;
9329: PPOPN 1
9331: END
// var crates_amount , crates_creating ; every 1 1$30 do
9332: GO 9334
9334: DISABLE
// begin crates_amount := GetResourceArea ( TreesArea , mat_cans ) ;
9335: LD_ADDR_LOC 1
9339: PUSH
9340: LD_INT 1
9342: PPUSH
9343: LD_INT 1
9345: PPUSH
9346: CALL_OW 287
9350: ST_TO_ADDR
// if crates_amount >= 80 then
9351: LD_LOC 1
9355: PUSH
9356: LD_INT 80
9358: GREATEREQUAL
9359: IFFALSE 9369
// crates_creating := false ;
9361: LD_ADDR_LOC 2
9365: PUSH
9366: LD_INT 0
9368: ST_TO_ADDR
// if crates_amount <= 30 then
9369: LD_LOC 1
9373: PUSH
9374: LD_INT 30
9376: LESSEQUAL
9377: IFFALSE 9387
// crates_creating := true ;
9379: LD_ADDR_LOC 2
9383: PUSH
9384: LD_INT 1
9386: ST_TO_ADDR
// if crates_creating then
9387: LD_LOC 2
9391: IFFALSE 9414
// CreateCratesArea ( Rand ( 3 , 5 ) , TreesArea , true ) ;
9393: LD_INT 3
9395: PPUSH
9396: LD_INT 5
9398: PPUSH
9399: CALL_OW 12
9403: PPUSH
9404: LD_INT 1
9406: PPUSH
9407: LD_INT 1
9409: PPUSH
9410: CALL_OW 55
// enable ;
9414: ENABLE
// end ;
9415: END
// var NonBuildBuildings , NonBuildWeapons ; every 0 0$3 do var filter , filter_tur , un , filter_weap , budova , NonBuild ;
9416: GO 9418
9418: DISABLE
9419: LD_INT 0
9421: PPUSH
9422: PPUSH
9423: PPUSH
9424: PPUSH
9425: PPUSH
9426: PPUSH
// begin NonBuild := AvailableBuildings ;
9427: LD_ADDR_VAR 0 6
9431: PUSH
9432: LD_EXP 55
9436: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] , [ f_ready ] ] ) ;
9437: LD_ADDR_VAR 0 1
9441: PUSH
9442: LD_INT 21
9444: PUSH
9445: LD_INT 3
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 22
9454: PUSH
9455: LD_EXP 31
9459: PUSH
9460: EMPTY
9461: LIST
9462: LIST
9463: PUSH
9464: LD_INT 53
9466: PUSH
9467: EMPTY
9468: LIST
9469: PUSH
9470: EMPTY
9471: LIST
9472: LIST
9473: LIST
9474: PPUSH
9475: CALL_OW 69
9479: ST_TO_ADDR
// TurretsDone := false ;
9480: LD_ADDR_EXP 49
9484: PUSH
9485: LD_INT 0
9487: ST_TO_ADDR
// filter_tur := FilterAllUnits ( [ [ f_btype , b_turret ] , [ f_side , you ] , [ f_ready ] ] ) ;
9488: LD_ADDR_VAR 0 2
9492: PUSH
9493: LD_INT 30
9495: PUSH
9496: LD_INT 33
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: LD_INT 22
9505: PUSH
9506: LD_EXP 31
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 53
9517: PUSH
9518: EMPTY
9519: LIST
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 69
9530: ST_TO_ADDR
// filter_weap := [ ] ;
9531: LD_ADDR_VAR 0 4
9535: PUSH
9536: EMPTY
9537: ST_TO_ADDR
// for un in filter_tur do
9538: LD_ADDR_VAR 0 3
9542: PUSH
9543: LD_VAR 0 2
9547: PUSH
9548: FOR_IN
9549: IFFALSE 9581
// begin filter_weap := filter_weap union GetBWeapon ( un ) ;
9551: LD_ADDR_VAR 0 4
9555: PUSH
9556: LD_VAR 0 4
9560: PUSH
9561: LD_VAR 0 3
9565: PPUSH
9566: CALL_OW 269
9570: UNION
9571: ST_TO_ADDR
// Wait ( 2 ) ;
9572: LD_INT 2
9574: PPUSH
9575: CALL_OW 67
// end ;
9579: GO 9548
9581: POP
9582: POP
// if ( filter_weap diff 0 ) >= 3 then
9583: LD_VAR 0 4
9587: PUSH
9588: LD_INT 0
9590: DIFF
9591: PUSH
9592: LD_INT 3
9594: GREATEREQUAL
9595: IFFALSE 9605
// TurretsDone := true ;
9597: LD_ADDR_EXP 49
9601: PUSH
9602: LD_INT 1
9604: ST_TO_ADDR
// for budova in filter do
9605: LD_ADDR_VAR 0 5
9609: PUSH
9610: LD_VAR 0 1
9614: PUSH
9615: FOR_IN
9616: IFFALSE 9648
// begin NonBuild := NonBuild diff GetBType ( budova ) ;
9618: LD_ADDR_VAR 0 6
9622: PUSH
9623: LD_VAR 0 6
9627: PUSH
9628: LD_VAR 0 5
9632: PPUSH
9633: CALL_OW 266
9637: DIFF
9638: ST_TO_ADDR
// Wait ( 1 ) ;
9639: LD_INT 1
9641: PPUSH
9642: CALL_OW 67
// end ;
9646: GO 9615
9648: POP
9649: POP
// if NonBuild = [ ] and TurretsDone and not BuildingsDone then
9650: LD_VAR 0 6
9654: PUSH
9655: EMPTY
9656: EQUAL
9657: PUSH
9658: LD_EXP 49
9662: AND
9663: PUSH
9664: LD_EXP 48
9668: NOT
9669: AND
9670: IFFALSE 9689
// begin ChangeMissionObjectives ( MBuildingsDone ) ;
9672: LD_STRING MBuildingsDone
9674: PPUSH
9675: CALL_OW 337
// BuildingsDone := true ;
9679: LD_ADDR_EXP 48
9683: PUSH
9684: LD_INT 1
9686: ST_TO_ADDR
// end else
9687: GO 9726
// if ( NonBuild <> [ ] or not TurretsDone ) and BuildingsDone then
9689: LD_VAR 0 6
9693: PUSH
9694: EMPTY
9695: NONEQUAL
9696: PUSH
9697: LD_EXP 49
9701: NOT
9702: OR
9703: PUSH
9704: LD_EXP 48
9708: AND
9709: IFFALSE 9726
// begin ChangeMissionObjectives ( MBuildings ) ;
9711: LD_STRING MBuildings
9713: PPUSH
9714: CALL_OW 337
// BuildingsDone := false ;
9718: LD_ADDR_EXP 48
9722: PUSH
9723: LD_INT 0
9725: ST_TO_ADDR
// end ; if not ( ( filter_weap diff 0 ) > 3 ) then
9726: LD_VAR 0 4
9730: PUSH
9731: LD_INT 0
9733: DIFF
9734: PUSH
9735: LD_INT 3
9737: GREATER
9738: NOT
9739: IFFALSE 9765
// NonBuild := NonBuild + 3 - ( filter_weap diff 0 ) ;
9741: LD_ADDR_VAR 0 6
9745: PUSH
9746: LD_VAR 0 6
9750: PUSH
9751: LD_INT 3
9753: PLUS
9754: PUSH
9755: LD_VAR 0 4
9759: PUSH
9760: LD_INT 0
9762: DIFF
9763: MINUS
9764: ST_TO_ADDR
// NonBuildBuildings := NonBuild ;
9765: LD_ADDR_LOC 3
9769: PUSH
9770: LD_VAR 0 6
9774: ST_TO_ADDR
// if HeikeCratesTime then
9775: LD_LOC 5
9779: IFFALSE 9842
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
9781: LD_ADDR_OWVAR 47
9785: PUSH
9786: LD_STRING #Ru08-1
9788: PUSH
9789: LD_INT 0
9791: PUSH
9792: LD_LOC 3
9796: PLUS
9797: PUSH
9798: LD_STRING #Ru08-2
9800: PUSH
9801: LD_INT 0
9803: PUSH
9804: LD_LOC 4
9808: PLUS
9809: PUSH
9810: LD_STRING #Ru08-3
9812: PUSH
9813: LD_INT 0
9815: PUSH
9816: LD_EXP 56
9820: PLUS
9821: PUSH
9822: LD_STRING #Ru08-4
9824: PUSH
9825: LD_LOC 5
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: ST_TO_ADDR
9840: GO 9891
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
9842: LD_ADDR_OWVAR 47
9846: PUSH
9847: LD_STRING #Ru08-1
9849: PUSH
9850: LD_INT 0
9852: PUSH
9853: LD_LOC 3
9857: PLUS
9858: PUSH
9859: LD_STRING #Ru08-2
9861: PUSH
9862: LD_INT 0
9864: PUSH
9865: LD_LOC 4
9869: PLUS
9870: PUSH
9871: LD_STRING #Ru08-3
9873: PUSH
9874: LD_INT 0
9876: PUSH
9877: LD_EXP 56
9881: PLUS
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: ST_TO_ADDR
// if NonBuild + 0 = 11 and not GalleryAsked then
9891: LD_VAR 0 6
9895: PUSH
9896: LD_INT 0
9898: PLUS
9899: PUSH
9900: LD_INT 11
9902: EQUAL
9903: PUSH
9904: LD_EXP 66
9908: NOT
9909: AND
9910: IFFALSE 9915
// enable ( 201 ) ;
9912: LD_INT 201
9914: ENABLE_MARKED
// if NonBuild + 0 = 7 and not HuntingAsked then
9915: LD_VAR 0 6
9919: PUSH
9920: LD_INT 0
9922: PLUS
9923: PUSH
9924: LD_INT 7
9926: EQUAL
9927: PUSH
9928: LD_EXP 67
9932: NOT
9933: AND
9934: IFFALSE 9939
// enable ( 101 ) ;
9936: LD_INT 101
9938: ENABLE_MARKED
// if NonBuild + 0 = 3 and not FreetimeAsked then
9939: LD_VAR 0 6
9943: PUSH
9944: LD_INT 0
9946: PLUS
9947: PUSH
9948: LD_INT 3
9950: EQUAL
9951: PUSH
9952: LD_EXP 68
9956: NOT
9957: AND
9958: IFFALSE 9963
// enable ( 301 ) ;
9960: LD_INT 301
9962: ENABLE_MARKED
// enable ;
9963: ENABLE
// end ;
9964: PPOPN 6
9966: END
// every 0 0$3 + 0 0$0.5 do var filter , veh , NonBuild ;
9967: GO 9969
9969: DISABLE
9970: LD_INT 0
9972: PPUSH
9973: PPUSH
9974: PPUSH
// begin NonBuild := AvailableWeapons ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_EXP 54
9984: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
9985: LD_ADDR_VAR 0 1
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 2
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: LD_INT 22
10002: PUSH
10003: LD_EXP 31
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: PUSH
10012: EMPTY
10013: LIST
10014: LIST
10015: PPUSH
10016: CALL_OW 69
10020: ST_TO_ADDR
// for veh in filter do
10021: LD_ADDR_VAR 0 2
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: FOR_IN
10032: IFFALSE 10064
// begin NonBuild := NonBuild diff GetWeapon ( veh ) ;
10034: LD_ADDR_VAR 0 3
10038: PUSH
10039: LD_VAR 0 3
10043: PUSH
10044: LD_VAR 0 2
10048: PPUSH
10049: CALL_OW 264
10053: DIFF
10054: ST_TO_ADDR
// Wait ( 1 ) ;
10055: LD_INT 1
10057: PPUSH
10058: CALL_OW 67
// end ;
10062: GO 10031
10064: POP
10065: POP
// if NonBuild = [ ] and not WeaponsDone then
10066: LD_VAR 0 3
10070: PUSH
10071: EMPTY
10072: EQUAL
10073: PUSH
10074: LD_EXP 50
10078: NOT
10079: AND
10080: IFFALSE 10099
// begin ChangeMissionObjectives ( MWeaponsDone ) ;
10082: LD_STRING MWeaponsDone
10084: PPUSH
10085: CALL_OW 337
// WeaponsDone := true ;
10089: LD_ADDR_EXP 50
10093: PUSH
10094: LD_INT 1
10096: ST_TO_ADDR
// end else
10097: GO 10129
// if NonBuild <> [ ] and WeaponsDone then
10099: LD_VAR 0 3
10103: PUSH
10104: EMPTY
10105: NONEQUAL
10106: PUSH
10107: LD_EXP 50
10111: AND
10112: IFFALSE 10129
// begin ChangeMissionObjectives ( Mweapons ) ;
10114: LD_STRING Mweapons
10116: PPUSH
10117: CALL_OW 337
// WeaponsDone := false ;
10121: LD_ADDR_EXP 50
10125: PUSH
10126: LD_INT 0
10128: ST_TO_ADDR
// end ; NonBuildWeapons := NonBuild ;
10129: LD_ADDR_LOC 4
10133: PUSH
10134: LD_VAR 0 3
10138: ST_TO_ADDR
// if HeikeCratesTime then
10139: LD_LOC 5
10143: IFFALSE 10206
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
10145: LD_ADDR_OWVAR 47
10149: PUSH
10150: LD_STRING #Ru08-1
10152: PUSH
10153: LD_INT 0
10155: PUSH
10156: LD_LOC 3
10160: PLUS
10161: PUSH
10162: LD_STRING #Ru08-2
10164: PUSH
10165: LD_INT 0
10167: PUSH
10168: LD_LOC 4
10172: PLUS
10173: PUSH
10174: LD_STRING #Ru08-3
10176: PUSH
10177: LD_INT 0
10179: PUSH
10180: LD_EXP 56
10184: PLUS
10185: PUSH
10186: LD_STRING #Ru08-4
10188: PUSH
10189: LD_LOC 5
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: ST_TO_ADDR
10204: GO 10255
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
10206: LD_ADDR_OWVAR 47
10210: PUSH
10211: LD_STRING #Ru08-1
10213: PUSH
10214: LD_INT 0
10216: PUSH
10217: LD_LOC 3
10221: PLUS
10222: PUSH
10223: LD_STRING #Ru08-2
10225: PUSH
10226: LD_INT 0
10228: PUSH
10229: LD_LOC 4
10233: PLUS
10234: PUSH
10235: LD_STRING #Ru08-3
10237: PUSH
10238: LD_INT 0
10240: PUSH
10241: LD_EXP 56
10245: PLUS
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: LIST
10254: ST_TO_ADDR
// enable ;
10255: ENABLE
// end ;
10256: PPOPN 3
10258: END
// every 0 0$2 marked 1 do var filter ;
10259: GO 10261
10261: DISABLE
10262: LD_INT 0
10264: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
10265: LD_ADDR_VAR 0 1
10269: PUSH
10270: LD_INT 22
10272: PUSH
10273: LD_EXP 31
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 2
10284: PUSH
10285: LD_INT 30
10287: PUSH
10288: LD_INT 0
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PUSH
10295: LD_INT 30
10297: PUSH
10298: LD_INT 1
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: LIST
10309: PUSH
10310: EMPTY
10311: LIST
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PPUSH
10317: CALL_OW 69
10321: ST_TO_ADDR
// if ( 0 + filter ) = 0 then
10322: LD_INT 0
10324: PUSH
10325: LD_VAR 0 1
10329: PLUS
10330: PUSH
10331: LD_INT 0
10333: EQUAL
10334: IFFALSE 10352
// filter := filter union Burlak ;
10336: LD_ADDR_VAR 0 1
10340: PUSH
10341: LD_VAR 0 1
10345: PUSH
10346: LD_EXP 1
10350: UNION
10351: ST_TO_ADDR
// if ( GetDistUnits ( Kurt , filter [ 1 ] ) < 8 ) or ( GetDistUnits ( Mercenary1 , filter [ 1 ] ) < 8 ) then
10352: LD_EXP 13
10356: PPUSH
10357: LD_VAR 0 1
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PPUSH
10366: CALL_OW 296
10370: PUSH
10371: LD_INT 8
10373: LESS
10374: PUSH
10375: LD_EXP 14
10379: PPUSH
10380: LD_VAR 0 1
10384: PUSH
10385: LD_INT 1
10387: ARRAY
10388: PPUSH
10389: CALL_OW 296
10393: PUSH
10394: LD_INT 8
10396: LESS
10397: OR
10398: IFFALSE 10429
// begin SetSide ( [ Kurt , Mercenary1 ] , you ) ;
10400: LD_EXP 13
10404: PUSH
10405: LD_EXP 14
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PPUSH
10414: LD_EXP 31
10418: PPUSH
10419: CALL_OW 235
// enable ( 10 ) ;
10423: LD_INT 10
10425: ENABLE_MARKED
// enable ( 601 ) ;
10426: LD_INT 601
10428: ENABLE_MARKED
// end ; if GetSide ( Kurt ) = you and GetSide ( Mercenary1 ) = you then
10429: LD_EXP 13
10433: PPUSH
10434: CALL_OW 255
10438: PUSH
10439: LD_EXP 31
10443: EQUAL
10444: PUSH
10445: LD_EXP 14
10449: PPUSH
10450: CALL_OW 255
10454: PUSH
10455: LD_EXP 31
10459: EQUAL
10460: AND
10461: IFFALSE 10466
// disable else
10463: DISABLE
10464: GO 10467
// enable ;
10466: ENABLE
// end ;
10467: PPOPN 1
10469: END
// every 0 0$1 + 0 0$0.2 marked 2 do var list ;
10470: GO 10472
10472: DISABLE
10473: LD_INT 0
10475: PPUSH
// begin list = [ false , false ] ;
10476: LD_ADDR_VAR 0 1
10480: PUSH
10481: LD_INT 0
10483: PUSH
10484: LD_INT 0
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: ST_TO_ADDR
// if IsLive ( Kurt ) and UnitShoot ( Kurt ) > 0 then
10491: LD_EXP 13
10495: PPUSH
10496: CALL_OW 300
10500: PUSH
10501: LD_EXP 13
10505: PPUSH
10506: CALL_OW 504
10510: PUSH
10511: LD_INT 0
10513: GREATER
10514: AND
10515: IFFALSE 10560
// if GetSide ( UnitShoot ( Kurt ) ) = you then
10517: LD_EXP 13
10521: PPUSH
10522: CALL_OW 504
10526: PPUSH
10527: CALL_OW 255
10531: PUSH
10532: LD_EXP 31
10536: EQUAL
10537: IFFALSE 10560
// list = Replace ( list , 1 , true ) ;
10539: LD_ADDR_VAR 0 1
10543: PUSH
10544: LD_VAR 0 1
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: LD_INT 1
10554: PPUSH
10555: CALL_OW 1
10559: ST_TO_ADDR
// if IsLive ( Mercenary1 ) and UnitShoot ( Mercenary1 ) > 0 then
10560: LD_EXP 14
10564: PPUSH
10565: CALL_OW 300
10569: PUSH
10570: LD_EXP 14
10574: PPUSH
10575: CALL_OW 504
10579: PUSH
10580: LD_INT 0
10582: GREATER
10583: AND
10584: IFFALSE 10629
// if GetSide ( UnitShoot ( Mercenary1 ) ) = you then
10586: LD_EXP 14
10590: PPUSH
10591: CALL_OW 504
10595: PPUSH
10596: CALL_OW 255
10600: PUSH
10601: LD_EXP 31
10605: EQUAL
10606: IFFALSE 10629
// list = Replace ( list , 2 , true ) ;
10608: LD_ADDR_VAR 0 1
10612: PUSH
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_INT 2
10620: PPUSH
10621: LD_INT 1
10623: PPUSH
10624: CALL_OW 1
10628: ST_TO_ADDR
// if true in list then
10629: LD_INT 1
10631: PUSH
10632: LD_VAR 0 1
10636: IN
10637: IFFALSE 10728
// begin disable ( 601 ) ;
10639: LD_INT 601
10641: DISABLE_MARKED
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
10642: LD_EXP 13
10646: PUSH
10647: LD_EXP 14
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: PPUSH
10656: LD_EXP 34
10660: PPUSH
10661: CALL_OW 235
// SetAttitude ( you , merc , att_enemy , true ) ;
10665: LD_EXP 31
10669: PPUSH
10670: LD_EXP 34
10674: PPUSH
10675: LD_INT 2
10677: PPUSH
10678: LD_INT 1
10680: PPUSH
10681: CALL_OW 80
// D_MercAmbush ;
10685: CALL 5260 0 0
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , 27 , 52 ) ;
10689: LD_EXP 13
10693: PUSH
10694: LD_EXP 14
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PPUSH
10703: LD_INT 27
10705: PPUSH
10706: LD_INT 52
10708: PPUSH
10709: CALL_OW 114
// enable ( 23 ) ;
10713: LD_INT 23
10715: ENABLE_MARKED
// merc_attack ;
10716: CALL 7691 0 0
// disabled2 := true ;
10720: LD_ADDR_EXP 86
10724: PUSH
10725: LD_INT 1
10727: ST_TO_ADDR
// end ; if not disabled2 then
10728: LD_EXP 86
10732: NOT
10733: IFFALSE 10736
// enable ;
10735: ENABLE
// end ;
10736: PPOPN 1
10738: END
// every 0 0$10 marked 3 do
10739: GO 10741
10741: DISABLE
// begin countdown := countdown - 10 * 35 ;
10742: LD_ADDR_EXP 77
10746: PUSH
10747: LD_EXP 77
10751: PUSH
10752: LD_INT 10
10754: PUSH
10755: LD_INT 35
10757: MUL
10758: MINUS
10759: ST_TO_ADDR
// if countdown < 0 and not HeikeDismissed then
10760: LD_EXP 77
10764: PUSH
10765: LD_INT 0
10767: LESS
10768: PUSH
10769: LD_EXP 45
10773: NOT
10774: AND
10775: IFFALSE 10792
// begin disabled3 := true ;
10777: LD_ADDR_EXP 87
10781: PUSH
10782: LD_INT 1
10784: ST_TO_ADDR
// enable ( 24 ) ;
10785: LD_INT 24
10787: ENABLE_MARKED
// merc_attack ;
10788: CALL 7691 0 0
// end ; if not disabled3 then
10792: LD_EXP 87
10796: NOT
10797: IFFALSE 10800
// enable ;
10799: ENABLE
// end ;
10800: END
// every 0 0$1 marked 24 do
10801: GO 10803
10803: DISABLE
// begin Wait ( 0 0$20 ) ;
10804: LD_INT 700
10806: PPUSH
10807: CALL_OW 67
// D_MercAttack ;
10811: CALL 5313 0 0
// end ;
10815: END
// every 0 0$1 + 0 0$0.4 marked 4 do
10816: GO 10818
10818: DISABLE
// begin if IsInArea ( Heike , WaitHeikeArea ) and not HeikeDismissed then
10819: LD_EXP 11
10823: PPUSH
10824: LD_INT 8
10826: PPUSH
10827: CALL_OW 308
10831: PUSH
10832: LD_EXP 45
10836: NOT
10837: AND
10838: IFFALSE 10931
// begin SetSide ( Heike , merc ) ;
10840: LD_EXP 11
10844: PPUSH
10845: LD_EXP 34
10849: PPUSH
10850: CALL_OW 235
// ComMoveToArea ( [ Kurt , Mercenary1 , Heike ] , MercExitArea ) ;
10854: LD_EXP 13
10858: PUSH
10859: LD_EXP 14
10863: PUSH
10864: LD_EXP 11
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: LIST
10873: PPUSH
10874: LD_INT 7
10876: PPUSH
10877: CALL_OW 113
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
10881: LD_INT 8
10883: PPUSH
10884: LD_INT 0
10886: PPUSH
10887: CALL_OW 424
// HeikeDismissed := true ;
10891: LD_ADDR_EXP 45
10895: PUSH
10896: LD_INT 1
10898: ST_TO_ADDR
// if not PopovAsked then
10899: LD_EXP 46
10903: NOT
10904: IFFALSE 10910
// D_MercPopov ;
10906: CALL 5208 0 0
// enable ( 5 ) ;
10910: LD_INT 5
10912: ENABLE_MARKED
// disabled6 := true ;
10913: LD_ADDR_EXP 90
10917: PUSH
10918: LD_INT 1
10920: ST_TO_ADDR
// disabled3 := true ;
10921: LD_ADDR_EXP 87
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
// end else
10929: GO 10932
// enable ;
10931: ENABLE
// end ;
10932: END
// every 0 0$1 + 0 0$0.5 marked 5 do var filter , un ;
10933: GO 10935
10935: DISABLE
10936: LD_INT 0
10938: PPUSH
10939: PPUSH
// begin filter := FilterUnitsInArea ( MercExitArea , [ f_or , [ f_side , merc ] , [ f_side , arab ] ] ) ;
10940: LD_ADDR_VAR 0 1
10944: PUSH
10945: LD_INT 7
10947: PPUSH
10948: LD_INT 2
10950: PUSH
10951: LD_INT 22
10953: PUSH
10954: LD_EXP 34
10958: PUSH
10959: EMPTY
10960: LIST
10961: LIST
10962: PUSH
10963: LD_INT 22
10965: PUSH
10966: LD_EXP 33
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 70
10984: ST_TO_ADDR
// for un in filter do
10985: LD_ADDR_VAR 0 2
10989: PUSH
10990: LD_VAR 0 1
10994: PUSH
10995: FOR_IN
10996: IFFALSE 11016
// begin RemoveUnit ( un ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 64
// Wait ( 1 ) ;
11007: LD_INT 1
11009: PPUSH
11010: CALL_OW 67
// end ;
11014: GO 10995
11016: POP
11017: POP
// if not disabled5 then
11018: LD_EXP 89
11022: NOT
11023: IFFALSE 11026
// enable ;
11025: ENABLE
// end ;
11026: PPOPN 2
11028: END
// every 0 0$1 + 0 0$0.6 marked 6 do
11029: GO 11031
11031: DISABLE
// begin if IsInArea ( Kurt , WaitHeikeArea ) then
11032: LD_EXP 13
11036: PPUSH
11037: LD_INT 8
11039: PPUSH
11040: CALL_OW 308
11044: IFFALSE 11051
// enable ( 4 ) else
11046: LD_INT 4
11048: ENABLE_MARKED
11049: GO 11052
// enable ;
11051: ENABLE
// end ;
11052: END
// every 0 0$1 + 0 0$0.7 marked 7 do var un , i , done ;
11053: GO 11055
11055: DISABLE
11056: LD_INT 0
11058: PPUSH
11059: PPUSH
11060: PPUSH
// begin for un in player_units do
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_EXP 26
11070: PUSH
11071: FOR_IN
11072: IFFALSE 11303
// begin if GetSide ( Attacks ( un ) ) = arab and not disabled7 then
11074: LD_VAR 0 1
11078: PPUSH
11079: CALL_OW 320
11083: PPUSH
11084: CALL_OW 255
11088: PUSH
11089: LD_EXP 33
11093: EQUAL
11094: PUSH
11095: LD_EXP 91
11099: NOT
11100: AND
11101: IFFALSE 11301
// begin GenscherBetrayed := true ;
11103: LD_ADDR_EXP 36
11107: PUSH
11108: LD_INT 1
11110: ST_TO_ADDR
// disabled7 := true ;
11111: LD_ADDR_EXP 91
11115: PUSH
11116: LD_INT 1
11118: ST_TO_ADDR
// D_HandOverSpoiled ;
11119: CALL 5596 0 0
// SetAttitude ( you , arab , att_enemy , true ) ;
11123: LD_EXP 31
11127: PPUSH
11128: LD_EXP 33
11132: PPUSH
11133: LD_INT 2
11135: PPUSH
11136: LD_INT 1
11138: PPUSH
11139: CALL_OW 80
// repeat wait ( 0 0$0.5 ) ;
11143: LD_INT 18
11145: PPUSH
11146: CALL_OW 67
// done = true ;
11150: LD_ADDR_VAR 0 3
11154: PUSH
11155: LD_INT 1
11157: ST_TO_ADDR
// for i in ar_human do
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_EXP 80
11167: PUSH
11168: FOR_IN
11169: IFFALSE 11287
// begin if not IsPlaced ( i ) and GetLives ( i ) > 0 then
11171: LD_VAR 0 2
11175: PPUSH
11176: CALL_OW 305
11180: NOT
11181: PUSH
11182: LD_VAR 0 2
11186: PPUSH
11187: CALL_OW 256
11191: PUSH
11192: LD_INT 0
11194: GREATER
11195: AND
11196: IFFALSE 11208
// begin done = false ;
11198: LD_ADDR_VAR 0 3
11202: PUSH
11203: LD_INT 0
11205: ST_TO_ADDR
// continue ;
11206: GO 11168
// end ; if not IsOk ( i ) then
11208: LD_VAR 0 2
11212: PPUSH
11213: CALL_OW 302
11217: NOT
11218: IFFALSE 11222
// continue ;
11220: GO 11168
// if IsInUnit ( i ) > 0 then
11222: LD_VAR 0 2
11226: PPUSH
11227: CALL_OW 310
11231: PUSH
11232: LD_INT 0
11234: GREATER
11235: IFFALSE 11256
// begin ComExitVehicle ( i ) ;
11237: LD_VAR 0 2
11241: PPUSH
11242: CALL_OW 121
// done = false ;
11246: LD_ADDR_VAR 0 3
11250: PUSH
11251: LD_INT 0
11253: ST_TO_ADDR
// end else
11254: GO 11285
// ComAgressiveMove ( i , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11256: LD_VAR 0 2
11260: PPUSH
11261: LD_EXP 1
11265: PPUSH
11266: CALL_OW 250
11270: PPUSH
11271: LD_EXP 1
11275: PPUSH
11276: CALL_OW 251
11280: PPUSH
11281: CALL_OW 114
// end ;
11285: GO 11168
11287: POP
11288: POP
// until MercHandoverArabsSpawned and done ;
11289: LD_EXP 43
11293: PUSH
11294: LD_VAR 0 3
11298: AND
11299: IFFALSE 11143
// end ; end ;
11301: GO 11071
11303: POP
11304: POP
// if not disabled7 and not MercHandoverDone then
11305: LD_EXP 91
11309: NOT
11310: PUSH
11311: LD_EXP 42
11315: NOT
11316: AND
11317: IFFALSE 11320
// enable ;
11319: ENABLE
// end ;
11320: PPOPN 3
11322: END
// every 0 0$0.5 + 0 0$0.3 marked 8 do
11323: GO 11325
11325: DISABLE
// begin if disabled7 then
11326: LD_EXP 91
11330: IFFALSE 11335
// begin disable ;
11332: DISABLE
// exit ;
11333: GO 11925
// end ; if not MercHandedOver then
11335: LD_EXP 40
11339: NOT
11340: IFFALSE 11344
// exit ;
11342: GO 11925
// if not GetSide ( Kurt ) = arab then
11344: LD_EXP 13
11348: PPUSH
11349: CALL_OW 255
11353: PUSH
11354: LD_EXP 33
11358: EQUAL
11359: NOT
11360: IFFALSE 11380
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
11362: LD_EXP 80
11366: PUSH
11367: LD_INT 1
11369: ARRAY
11370: PPUSH
11371: LD_EXP 13
11375: PPUSH
11376: CALL_OW 115
// if not GetSide ( Mercenary1 ) = arab then
11380: LD_EXP 14
11384: PPUSH
11385: CALL_OW 255
11389: PUSH
11390: LD_EXP 33
11394: EQUAL
11395: NOT
11396: IFFALSE 11416
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11398: LD_EXP 80
11402: PUSH
11403: LD_INT 2
11405: ARRAY
11406: PPUSH
11407: LD_EXP 14
11411: PPUSH
11412: CALL_OW 115
// if not IsLive ( Kurt ) or not IsLive ( Mercenary1 ) then
11416: LD_EXP 13
11420: PPUSH
11421: CALL_OW 300
11425: NOT
11426: PUSH
11427: LD_EXP 14
11431: PPUSH
11432: CALL_OW 300
11436: NOT
11437: OR
11438: IFFALSE 11509
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] ] , [ [ 29 , 57 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11440: LD_INT 1
11442: PPUSH
11443: LD_EXP 80
11447: PUSH
11448: LD_INT 1
11450: ARRAY
11451: PUSH
11452: LD_EXP 80
11456: PUSH
11457: LD_INT 2
11459: ARRAY
11460: PUSH
11461: LD_EXP 80
11465: PUSH
11466: LD_INT 3
11468: ARRAY
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: LIST
11474: PPUSH
11475: LD_INT 29
11477: PUSH
11478: LD_INT 57
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: PUSH
11485: EMPTY
11486: LIST
11487: PPUSH
11488: LD_INT 1
11490: PUSH
11491: LD_INT 3
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 5
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PPUSH
11505: CALL_OW 398
// if Attacks ( ar_human [ 1 ] ) = Kurt then
11509: LD_EXP 80
11513: PUSH
11514: LD_INT 1
11516: ARRAY
11517: PPUSH
11518: CALL_OW 320
11522: PUSH
11523: LD_EXP 13
11527: EQUAL
11528: IFFALSE 11642
// begin ComStop ( [ Kurt , Mercenary1 ] ) ;
11530: LD_EXP 13
11534: PUSH
11535: LD_EXP 14
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PPUSH
11544: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11548: LD_EXP 13
11552: PUSH
11553: LD_EXP 14
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PPUSH
11562: LD_EXP 33
11566: PPUSH
11567: CALL_OW 235
// ComStop ( ar_human [ 1 ] ) ;
11571: LD_EXP 80
11575: PUSH
11576: LD_INT 1
11578: ARRAY
11579: PPUSH
11580: CALL_OW 141
// Wait ( 2 ) ;
11584: LD_INT 2
11586: PPUSH
11587: CALL_OW 67
// AddComMoveUnit ( ar_human [ 1 ] , Kurt ) ;
11591: LD_EXP 80
11595: PUSH
11596: LD_INT 1
11598: ARRAY
11599: PPUSH
11600: LD_EXP 13
11604: PPUSH
11605: CALL_OW 172
// if GetLives ( Kurt ) < 300 then
11609: LD_EXP 13
11613: PPUSH
11614: CALL_OW 256
11618: PUSH
11619: LD_INT 300
11621: LESS
11622: IFFALSE 11642
// AddComHeal ( ar_human [ 3 ] , Kurt ) ;
11624: LD_EXP 80
11628: PUSH
11629: LD_INT 3
11631: ARRAY
11632: PPUSH
11633: LD_EXP 13
11637: PPUSH
11638: CALL_OW 188
// end ; if Attacks ( ar_human [ 2 ] ) = Mercenary1 then
11642: LD_EXP 80
11646: PUSH
11647: LD_INT 2
11649: ARRAY
11650: PPUSH
11651: CALL_OW 320
11655: PUSH
11656: LD_EXP 14
11660: EQUAL
11661: IFFALSE 11775
// begin ComStop ( ar_human [ 2 ] ) ;
11663: LD_EXP 80
11667: PUSH
11668: LD_INT 2
11670: ARRAY
11671: PPUSH
11672: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11676: LD_EXP 13
11680: PUSH
11681: LD_EXP 14
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PPUSH
11690: LD_EXP 33
11694: PPUSH
11695: CALL_OW 235
// ComStop ( [ Kurt , Mercenary1 ] ) ;
11699: LD_EXP 13
11703: PUSH
11704: LD_EXP 14
11708: PUSH
11709: EMPTY
11710: LIST
11711: LIST
11712: PPUSH
11713: CALL_OW 141
// Wait ( 2 ) ;
11717: LD_INT 2
11719: PPUSH
11720: CALL_OW 67
// AddComMoveUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11724: LD_EXP 80
11728: PUSH
11729: LD_INT 2
11731: ARRAY
11732: PPUSH
11733: LD_EXP 14
11737: PPUSH
11738: CALL_OW 172
// if GetLives ( Mercenary1 ) < 300 then
11742: LD_EXP 14
11746: PPUSH
11747: CALL_OW 256
11751: PUSH
11752: LD_INT 300
11754: LESS
11755: IFFALSE 11775
// AddComHeal ( ar_human [ 3 ] , Mercenary1 ) ;
11757: LD_EXP 80
11761: PUSH
11762: LD_INT 3
11764: ARRAY
11765: PPUSH
11766: LD_EXP 14
11770: PPUSH
11771: CALL_OW 188
// end ; if GetSide ( Kurt ) = arab and GetSide ( Mercenary1 ) = arab then
11775: LD_EXP 13
11779: PPUSH
11780: CALL_OW 255
11784: PUSH
11785: LD_EXP 33
11789: EQUAL
11790: PUSH
11791: LD_EXP 14
11795: PPUSH
11796: CALL_OW 255
11800: PUSH
11801: LD_EXP 33
11805: EQUAL
11806: AND
11807: IFFALSE 11917
// begin disabled8 := true ;
11809: LD_ADDR_EXP 92
11813: PUSH
11814: LD_INT 1
11816: ST_TO_ADDR
// disable ( 2 ) ;
11817: LD_INT 2
11819: DISABLE_MARKED
// disable ( 6 ) ;
11820: LD_INT 6
11822: DISABLE_MARKED
// disable ( 12 ) ;
11823: LD_INT 12
11825: DISABLE_MARKED
// Wait ( 0 0$5 ) ;
11826: LD_INT 175
11828: PPUSH
11829: CALL_OW 67
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] , Kurt , Mercenary1 ] , [ [ 115 , 32 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11833: LD_INT 1
11835: PPUSH
11836: LD_EXP 80
11840: PUSH
11841: LD_INT 1
11843: ARRAY
11844: PUSH
11845: LD_EXP 80
11849: PUSH
11850: LD_INT 2
11852: ARRAY
11853: PUSH
11854: LD_EXP 80
11858: PUSH
11859: LD_INT 3
11861: ARRAY
11862: PUSH
11863: LD_EXP 13
11867: PUSH
11868: LD_EXP 14
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: PPUSH
11880: LD_INT 115
11882: PUSH
11883: LD_INT 32
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: EMPTY
11891: LIST
11892: PPUSH
11893: LD_INT 1
11895: PUSH
11896: LD_INT 3
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: PUSH
11903: LD_INT 5
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PPUSH
11910: CALL_OW 398
// enable ( 11 ) ;
11914: LD_INT 11
11916: ENABLE_MARKED
// end ; if not disabled8 then
11917: LD_EXP 92
11921: NOT
11922: IFFALSE 11925
// enable ;
11924: ENABLE
// end ;
11925: END
// every 0 0$1 + 0 0$0.1 marked 8 do
11926: GO 11928
11928: DISABLE
// begin repeat wait ( 0 0$1 ) ;
11929: LD_INT 35
11931: PPUSH
11932: CALL_OW 67
// if GenscherBetrayed then
11936: LD_EXP 36
11940: IFFALSE 11944
// exit ;
11942: GO 11983
// if UnitFilter ( ar_human , [ f_placed ] ) = 0 then
11944: LD_EXP 80
11948: PPUSH
11949: LD_INT 52
11951: PUSH
11952: EMPTY
11953: LIST
11954: PPUSH
11955: CALL_OW 72
11959: PUSH
11960: LD_INT 0
11962: EQUAL
11963: IFFALSE 11979
// begin SA_OnLegionHandoverToUPF ;
11965: CALL 19042 0 0
// MercHandoverDone = true ;
11969: LD_ADDR_EXP 42
11973: PUSH
11974: LD_INT 1
11976: ST_TO_ADDR
// exit ;
11977: GO 11983
// end ; until false ;
11979: LD_INT 0
11981: IFFALSE 11929
// end ;
11983: END
// every 0 0$1 + 0 0$0.9 marked 9 do var un1 , un2 ;
11984: GO 11986
11986: DISABLE
11987: LD_INT 0
11989: PPUSH
11990: PPUSH
// begin if disabled7 then
11991: LD_EXP 91
11995: IFFALSE 12000
// begin disable ;
11997: DISABLE
// exit ;
11998: GO 12226
// end ; if IsInUnit ( ar_human [ 1 ] ) = 0 and IsInUnit ( ar_human [ 2 ] ) = 0 then
12000: LD_EXP 80
12004: PUSH
12005: LD_INT 1
12007: ARRAY
12008: PPUSH
12009: CALL_OW 310
12013: PUSH
12014: LD_INT 0
12016: EQUAL
12017: PUSH
12018: LD_EXP 80
12022: PUSH
12023: LD_INT 2
12025: ARRAY
12026: PPUSH
12027: CALL_OW 310
12031: PUSH
12032: LD_INT 0
12034: EQUAL
12035: AND
12036: IFFALSE 12218
// begin disable ( 601 ) ;
12038: LD_INT 601
12040: DISABLE_MARKED
// D_HandOverCome ;
12041: CALL 5556 0 0
// MercHandedOver := true ;
12045: LD_ADDR_EXP 40
12049: PUSH
12050: LD_INT 1
12052: ST_TO_ADDR
// disable ( 20 ) ;
12053: LD_INT 20
12055: DISABLE_MARKED
// enable ( 23 ) ;
12056: LD_INT 23
12058: ENABLE_MARKED
// enable ( 8 ) ;
12059: LD_INT 8
12061: ENABLE_MARKED
// ComStop ( [ Kurt , Mercenary1 ] ) ;
12062: LD_EXP 13
12066: PUSH
12067: LD_EXP 14
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: PPUSH
12076: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
12080: LD_EXP 13
12084: PUSH
12085: LD_EXP 14
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PPUSH
12094: LD_EXP 34
12098: PPUSH
12099: CALL_OW 235
// SetAttitude ( you , merc , att_neutral , true ) ;
12103: LD_EXP 31
12107: PPUSH
12108: LD_EXP 34
12112: PPUSH
12113: LD_INT 0
12115: PPUSH
12116: LD_INT 1
12118: PPUSH
12119: CALL_OW 80
// SetAttitude ( merc , arab , att_friend , true ) ;
12123: LD_EXP 34
12127: PPUSH
12128: LD_EXP 33
12132: PPUSH
12133: LD_INT 1
12135: PPUSH
12136: LD_INT 1
12138: PPUSH
12139: CALL_OW 80
// Wait ( 2 ) ;
12143: LD_INT 2
12145: PPUSH
12146: CALL_OW 67
// enable ( 5 ) ;
12150: LD_INT 5
12152: ENABLE_MARKED
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
12153: LD_EXP 80
12157: PUSH
12158: LD_INT 1
12160: ARRAY
12161: PPUSH
12162: LD_EXP 13
12166: PPUSH
12167: CALL_OW 115
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
12171: LD_EXP 80
12175: PUSH
12176: LD_INT 2
12178: ARRAY
12179: PPUSH
12180: LD_EXP 14
12184: PPUSH
12185: CALL_OW 115
// ComMoveToArea ( [ Kurt , Mercenary1 ] , MercExitArea ) ;
12189: LD_EXP 13
12193: PUSH
12194: LD_EXP 14
12198: PUSH
12199: EMPTY
12200: LIST
12201: LIST
12202: PPUSH
12203: LD_INT 7
12205: PPUSH
12206: CALL_OW 113
// disabled9 := true ;
12210: LD_ADDR_EXP 93
12214: PUSH
12215: LD_INT 1
12217: ST_TO_ADDR
// end ; if not disabled9 then
12218: LD_EXP 93
12222: NOT
12223: IFFALSE 12226
// enable ;
12225: ENABLE
// end ;
12226: PPOPN 2
12228: END
// every 0 0$1 marked 10 do var rnd ;
12229: GO 12231
12231: DISABLE
12232: LD_INT 0
12234: PPUSH
// begin rnd := Rand ( 0 0$30 , 0 0$45 ) ;
12235: LD_ADDR_VAR 0 1
12239: PUSH
12240: LD_INT 1050
12242: PPUSH
12243: LD_INT 1575
12245: PPUSH
12246: CALL_OW 12
12250: ST_TO_ADDR
// Wait ( rnd ) ;
12251: LD_VAR 0 1
12255: PPUSH
12256: CALL_OW 67
// if GetAttitude ( you , merc ) = att_neutral and GetSide ( Kurt ) = you then
12260: LD_EXP 31
12264: PPUSH
12265: LD_EXP 34
12269: PPUSH
12270: CALL_OW 81
12274: PUSH
12275: LD_INT 0
12277: EQUAL
12278: PUSH
12279: LD_EXP 13
12283: PPUSH
12284: CALL_OW 255
12288: PUSH
12289: LD_EXP 31
12293: EQUAL
12294: AND
12295: IFFALSE 12301
// D_ArabianRequest ;
12297: CALL 5353 0 0
// end ;
12301: PPOPN 1
12303: END
// every 0 0$1 + 0 0$0.2 marked 11 do var filter , un , disablefilter ;
12304: GO 12306
12306: DISABLE
12307: LD_INT 0
12309: PPUSH
12310: PPUSH
12311: PPUSH
// begin filter := FilterUnitsInArea ( HandOverEnterArea , [ [ f_side , arab ] , [ f_type , unit_human ] ] ) ;
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: LD_INT 6
12319: PPUSH
12320: LD_INT 22
12322: PUSH
12323: LD_EXP 33
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 21
12334: PUSH
12335: LD_INT 1
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: EMPTY
12343: LIST
12344: LIST
12345: PPUSH
12346: CALL_OW 70
12350: ST_TO_ADDR
// for un in filter do
12351: LD_ADDR_VAR 0 2
12355: PUSH
12356: LD_VAR 0 1
12360: PUSH
12361: FOR_IN
12362: IFFALSE 12382
// begin RemoveUnit ( un ) ;
12364: LD_VAR 0 2
12368: PPUSH
12369: CALL_OW 64
// Wait ( 1 ) ;
12373: LD_INT 1
12375: PPUSH
12376: CALL_OW 67
// end ;
12380: GO 12361
12382: POP
12383: POP
// disablefilter := FilterAllUnits ( [ f_side , arab ] ) ;
12384: LD_ADDR_VAR 0 3
12388: PUSH
12389: LD_INT 22
12391: PUSH
12392: LD_EXP 33
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: PPUSH
12401: CALL_OW 69
12405: ST_TO_ADDR
// if 0 + disablefilter > 0 then
12406: LD_INT 0
12408: PUSH
12409: LD_VAR 0 3
12413: PLUS
12414: PUSH
12415: LD_INT 0
12417: GREATER
12418: IFFALSE 12423
// enable else
12420: ENABLE
12421: GO 12427
// begin disable ;
12423: DISABLE
// disable ( 7 ) ;
12424: LD_INT 7
12426: DISABLE_MARKED
// end ; end ;
12427: PPOPN 3
12429: END
// var HeikeCratesTime , LegionDone ; every 0 0$1 marked 13 do var un , filter , amount ;
12430: GO 12432
12432: DISABLE
12433: LD_INT 0
12435: PPUSH
12436: PPUSH
12437: PPUSH
// begin if ( not HeikeKilled ) and HeikeDismissed then
12438: LD_EXP 38
12442: NOT
12443: PUSH
12444: LD_EXP 45
12448: AND
12449: IFFALSE 13229
// begin disabled5 := true ;
12451: LD_ADDR_EXP 89
12455: PUSH
12456: LD_INT 1
12458: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
12459: LD_INT 175
12461: PPUSH
12462: CALL_OW 67
// D_LegionFormed ;
12466: CALL 5624 0 0
// case Query ( QLegion ) of 1 :
12470: LD_STRING QLegion
12472: PPUSH
12473: CALL_OW 97
12477: PUSH
12478: LD_INT 1
12480: DOUBLE
12481: EQUAL
12482: IFTRUE 12486
12484: GO 13213
12486: POP
// begin amount := 0 ;
12487: LD_ADDR_VAR 0 3
12491: PUSH
12492: LD_INT 0
12494: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12495: LD_ADDR_VAR 0 2
12499: PUSH
12500: LD_INT 22
12502: PUSH
12503: LD_EXP 31
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 2
12514: PUSH
12515: LD_INT 30
12517: PUSH
12518: LD_INT 0
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: LD_INT 30
12527: PUSH
12528: LD_INT 1
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: LIST
12539: PUSH
12540: EMPTY
12541: LIST
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: PPUSH
12547: CALL_OW 69
12551: ST_TO_ADDR
// if filter <> [ ] then
12552: LD_VAR 0 2
12556: PUSH
12557: EMPTY
12558: NONEQUAL
12559: IFFALSE 12607
// for un in filter do
12561: LD_ADDR_VAR 0 1
12565: PUSH
12566: LD_VAR 0 2
12570: PUSH
12571: FOR_IN
12572: IFFALSE 12605
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12574: LD_ADDR_VAR 0 3
12578: PUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: PPUSH
12589: CALL_OW 274
12593: PPUSH
12594: LD_INT 1
12596: PPUSH
12597: CALL_OW 275
12601: PLUS
12602: ST_TO_ADDR
12603: GO 12571
12605: POP
12606: POP
// if amount < 50 then
12607: LD_VAR 0 3
12611: PUSH
12612: LD_INT 50
12614: LESS
12615: IFFALSE 13039
// begin HeikeCratesTime := 0 0$60 ;
12617: LD_ADDR_LOC 5
12621: PUSH
12622: LD_INT 2100
12624: ST_TO_ADDR
// repeat display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] ;
12625: LD_ADDR_OWVAR 47
12629: PUSH
12630: LD_STRING #Ru08-1
12632: PUSH
12633: LD_INT 0
12635: PUSH
12636: LD_LOC 3
12640: PLUS
12641: PUSH
12642: LD_STRING #Ru08-2
12644: PUSH
12645: LD_INT 0
12647: PUSH
12648: LD_LOC 4
12652: PLUS
12653: PUSH
12654: LD_STRING #Ru08-3
12656: PUSH
12657: LD_INT 0
12659: PUSH
12660: LD_EXP 56
12664: PLUS
12665: PUSH
12666: LD_STRING #Ru08-4
12668: PUSH
12669: LD_LOC 5
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: ST_TO_ADDR
// amount := 0 ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 0
12691: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12692: LD_ADDR_VAR 0 2
12696: PUSH
12697: LD_INT 22
12699: PUSH
12700: LD_EXP 31
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: PUSH
12709: LD_INT 2
12711: PUSH
12712: LD_INT 30
12714: PUSH
12715: LD_INT 0
12717: PUSH
12718: EMPTY
12719: LIST
12720: LIST
12721: PUSH
12722: LD_INT 30
12724: PUSH
12725: LD_INT 1
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: LIST
12736: PUSH
12737: EMPTY
12738: LIST
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PPUSH
12744: CALL_OW 69
12748: ST_TO_ADDR
// if filter <> [ ] then
12749: LD_VAR 0 2
12753: PUSH
12754: EMPTY
12755: NONEQUAL
12756: IFFALSE 12804
// for un in filter do
12758: LD_ADDR_VAR 0 1
12762: PUSH
12763: LD_VAR 0 2
12767: PUSH
12768: FOR_IN
12769: IFFALSE 12802
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12771: LD_ADDR_VAR 0 3
12775: PUSH
12776: LD_VAR 0 3
12780: PUSH
12781: LD_VAR 0 1
12785: PPUSH
12786: CALL_OW 274
12790: PPUSH
12791: LD_INT 1
12793: PPUSH
12794: CALL_OW 275
12798: PLUS
12799: ST_TO_ADDR
12800: GO 12768
12802: POP
12803: POP
// Wait ( 0 0$1 ) ;
12804: LD_INT 35
12806: PPUSH
12807: CALL_OW 67
// HeikeCratesTime := HeikeCratesTime - 0 0$1 ;
12811: LD_ADDR_LOC 5
12815: PUSH
12816: LD_LOC 5
12820: PUSH
12821: LD_INT 35
12823: MINUS
12824: ST_TO_ADDR
// until amount >= 50 or HeikeCratesTime <= 0 ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 50
12832: GREATEREQUAL
12833: PUSH
12834: LD_LOC 5
12838: PUSH
12839: LD_INT 0
12841: LESSEQUAL
12842: OR
12843: IFFALSE 12625
// if amount >= 50 and HeikeCratesTime > 0 then
12845: LD_VAR 0 3
12849: PUSH
12850: LD_INT 50
12852: GREATEREQUAL
12853: PUSH
12854: LD_LOC 5
12858: PUSH
12859: LD_INT 0
12861: GREATER
12862: AND
12863: IFFALSE 13037
// begin D_QrLegion1 ;
12865: CALL 5700 0 0
// MercPaid := true ;
12869: LD_ADDR_EXP 39
12873: PUSH
12874: LD_INT 1
12876: ST_TO_ADDR
// amount := 50 ;
12877: LD_ADDR_VAR 0 3
12881: PUSH
12882: LD_INT 50
12884: ST_TO_ADDR
// for un in filter do
12885: LD_ADDR_VAR 0 1
12889: PUSH
12890: LD_VAR 0 2
12894: PUSH
12895: FOR_IN
12896: IFFALSE 13035
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
12898: LD_VAR 0 1
12902: PPUSH
12903: CALL_OW 274
12907: PPUSH
12908: LD_INT 1
12910: PPUSH
12911: CALL_OW 275
12915: PUSH
12916: LD_VAR 0 3
12920: LESS
12921: PUSH
12922: LD_VAR 0 3
12926: PUSH
12927: LD_INT 0
12929: NONEQUAL
12930: AND
12931: IFFALSE 12984
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
12933: LD_ADDR_VAR 0 3
12937: PUSH
12938: LD_VAR 0 3
12942: PUSH
12943: LD_VAR 0 1
12947: PPUSH
12948: CALL_OW 274
12952: PPUSH
12953: LD_INT 1
12955: PPUSH
12956: CALL_OW 275
12960: MINUS
12961: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
12962: LD_VAR 0 1
12966: PPUSH
12967: CALL_OW 274
12971: PPUSH
12972: LD_INT 1
12974: PPUSH
12975: LD_INT 0
12977: PPUSH
12978: CALL_OW 277
// end else
12982: GO 13033
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
12984: LD_VAR 0 1
12988: PPUSH
12989: CALL_OW 274
12993: PPUSH
12994: LD_INT 1
12996: PPUSH
12997: LD_VAR 0 1
13001: PPUSH
13002: CALL_OW 274
13006: PPUSH
13007: LD_INT 1
13009: PPUSH
13010: CALL_OW 275
13014: PUSH
13015: LD_VAR 0 3
13019: MINUS
13020: PPUSH
13021: CALL_OW 277
// amount := 0 ;
13025: LD_ADDR_VAR 0 3
13029: PUSH
13030: LD_INT 0
13032: ST_TO_ADDR
// end ;
13033: GO 12895
13035: POP
13036: POP
// end ; end else
13037: GO 13211
// begin D_QrLegion1 ;
13039: CALL 5700 0 0
// MercPaid := true ;
13043: LD_ADDR_EXP 39
13047: PUSH
13048: LD_INT 1
13050: ST_TO_ADDR
// amount := 50 ;
13051: LD_ADDR_VAR 0 3
13055: PUSH
13056: LD_INT 50
13058: ST_TO_ADDR
// for un in filter do
13059: LD_ADDR_VAR 0 1
13063: PUSH
13064: LD_VAR 0 2
13068: PUSH
13069: FOR_IN
13070: IFFALSE 13209
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
13072: LD_VAR 0 1
13076: PPUSH
13077: CALL_OW 274
13081: PPUSH
13082: LD_INT 1
13084: PPUSH
13085: CALL_OW 275
13089: PUSH
13090: LD_VAR 0 3
13094: LESS
13095: PUSH
13096: LD_VAR 0 3
13100: PUSH
13101: LD_INT 0
13103: NONEQUAL
13104: AND
13105: IFFALSE 13158
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13107: LD_ADDR_VAR 0 3
13111: PUSH
13112: LD_VAR 0 3
13116: PUSH
13117: LD_VAR 0 1
13121: PPUSH
13122: CALL_OW 274
13126: PPUSH
13127: LD_INT 1
13129: PPUSH
13130: CALL_OW 275
13134: MINUS
13135: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13136: LD_VAR 0 1
13140: PPUSH
13141: CALL_OW 274
13145: PPUSH
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 0
13151: PPUSH
13152: CALL_OW 277
// end else
13156: GO 13207
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13158: LD_VAR 0 1
13162: PPUSH
13163: CALL_OW 274
13167: PPUSH
13168: LD_INT 1
13170: PPUSH
13171: LD_VAR 0 1
13175: PPUSH
13176: CALL_OW 274
13180: PPUSH
13181: LD_INT 1
13183: PPUSH
13184: CALL_OW 275
13188: PUSH
13189: LD_VAR 0 3
13193: MINUS
13194: PPUSH
13195: CALL_OW 277
// amount := 0 ;
13199: LD_ADDR_VAR 0 3
13203: PUSH
13204: LD_INT 0
13206: ST_TO_ADDR
// end ;
13207: GO 13069
13209: POP
13210: POP
// end ; end ; 2 :
13211: GO 13229
13213: LD_INT 2
13215: DOUBLE
13216: EQUAL
13217: IFTRUE 13221
13219: GO 13228
13221: POP
// D_QrLegion2 ; end ;
13222: CALL 5728 0 0
13226: GO 13229
13228: POP
// end ; LegionDone := true ;
13229: LD_ADDR_LOC 6
13233: PUSH
13234: LD_INT 1
13236: ST_TO_ADDR
// end ;
13237: PPOPN 3
13239: END
// every 0 0$1 marked 20 do
13240: GO 13242
13242: DISABLE
// begin if IsSelected ( Heike ) = true then
13243: LD_EXP 11
13247: PPUSH
13248: CALL_OW 306
13252: PUSH
13253: LD_INT 1
13255: EQUAL
13256: IFFALSE 13316
// begin if WasSelected = false then
13258: LD_EXP 83
13262: PUSH
13263: LD_INT 0
13265: EQUAL
13266: IFFALSE 13314
// begin if Query ( QSendHeike ) = 1 then
13268: LD_STRING QSendHeike
13270: PPUSH
13271: CALL_OW 97
13275: PUSH
13276: LD_INT 1
13278: EQUAL
13279: IFFALSE 13306
// begin HeikeSend := true ;
13281: LD_ADDR_EXP 65
13285: PUSH
13286: LD_INT 1
13288: ST_TO_ADDR
// ComMoveXY ( Heike , 39 , 47 ) ;
13289: LD_EXP 11
13293: PPUSH
13294: LD_INT 39
13296: PPUSH
13297: LD_INT 47
13299: PPUSH
13300: CALL_OW 111
// exit ;
13304: GO 13325
// end ; WasSelected := true ;
13306: LD_ADDR_EXP 83
13310: PUSH
13311: LD_INT 1
13313: ST_TO_ADDR
// end ; end else
13314: GO 13324
// WasSelected := false ;
13316: LD_ADDR_EXP 83
13320: PUSH
13321: LD_INT 0
13323: ST_TO_ADDR
// enable ;
13324: ENABLE
// end ;
13325: END
// every 0 0$10 + 0 0$0.4 marked 21 do
13326: GO 13328
13328: DISABLE
// begin if TechnoDone and BuildingsDone and not AmAttackStarted then
13329: LD_EXP 51
13333: PUSH
13334: LD_EXP 48
13338: AND
13339: PUSH
13340: LD_EXP 71
13344: NOT
13345: AND
13346: IFFALSE 13399
// begin enable ( 13 ) ;
13348: LD_INT 13
13350: ENABLE_MARKED
// repeat Wait ( 0 0$1 ) ;
13351: LD_INT 35
13353: PPUSH
13354: CALL_OW 67
// until LegionDone ;
13358: LD_LOC 6
13362: IFFALSE 13351
// if ( not HeikeKilled ) and HeikeDismissed then
13364: LD_EXP 38
13368: NOT
13369: PUSH
13370: LD_EXP 45
13374: AND
13375: IFFALSE 13386
// Wait ( 0 0$35 ) else
13377: LD_INT 1225
13379: PPUSH
13380: CALL_OW 67
13384: GO 13393
// Wait ( 0 0$5 ) ;
13386: LD_INT 175
13388: PPUSH
13389: CALL_OW 67
// enable ( 999 ) ;
13393: LD_INT 999
13395: ENABLE_MARKED
// enable ( 501 ) ;
13396: LD_INT 501
13398: ENABLE_MARKED
// end ; if not AmAttackStarted then
13399: LD_EXP 71
13403: NOT
13404: IFFALSE 13407
// enable ;
13406: ENABLE
// end ;
13407: END
// var ApesRespawned ; every 0 0$1 + 0 0$0.8 marked 22 do var Ape ;
13408: GO 13410
13410: DISABLE
13411: LD_INT 0
13413: PPUSH
// begin Wait ( 350 * ApesRespawned ) ;
13414: LD_INT 350
13416: PUSH
13417: LD_LOC 7
13421: MUL
13422: PPUSH
13423: CALL_OW 67
// if FilterAllUnits ( [ f_class , class_apeman ] ) < 1 then
13427: LD_INT 25
13429: PUSH
13430: LD_INT 12
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PPUSH
13437: CALL_OW 69
13441: PUSH
13442: LD_INT 1
13444: LESS
13445: IFFALSE 13555
// begin ApesRespawned := ApesRespawned + 1 ;
13447: LD_ADDR_LOC 7
13451: PUSH
13452: LD_LOC 7
13456: PUSH
13457: LD_INT 1
13459: PLUS
13460: ST_TO_ADDR
// uc_side := 0 ;
13461: LD_ADDR_OWVAR 20
13465: PUSH
13466: LD_INT 0
13468: ST_TO_ADDR
// uc_nation := nation_nature ;
13469: LD_ADDR_OWVAR 21
13473: PUSH
13474: LD_INT 0
13476: ST_TO_ADDR
// PrepareHuman ( sex_male , class_apeman , 2 ) ;
13477: LD_INT 1
13479: PPUSH
13480: LD_INT 12
13482: PPUSH
13483: LD_INT 2
13485: PPUSH
13486: CALL_OW 380
// hc_name :=  ;
13490: LD_ADDR_OWVAR 26
13494: PUSH
13495: LD_STRING 
13497: ST_TO_ADDR
// Ape := CreateHuman ;
13498: LD_ADDR_VAR 0 1
13502: PUSH
13503: CALL_OW 44
13507: ST_TO_ADDR
// SetDir ( Ape , Rand ( 0 , 5 ) ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_INT 0
13515: PPUSH
13516: LD_INT 5
13518: PPUSH
13519: CALL_OW 12
13523: PPUSH
13524: CALL_OW 233
// PlaceUnitArea ( Ape , AnimalsArea , false ) ;
13528: LD_VAR 0 1
13532: PPUSH
13533: LD_INT 22
13535: PPUSH
13536: LD_INT 0
13538: PPUSH
13539: CALL_OW 49
// ComMoveToArea ( Ape , ApeArea ) ;
13543: LD_VAR 0 1
13547: PPUSH
13548: LD_INT 23
13550: PPUSH
13551: CALL_OW 113
// end ; enable ;
13555: ENABLE
// end ;
13556: PPOPN 1
13558: END
// every 0 0$15 marked 23 do var filter , un ;
13559: GO 13561
13561: DISABLE
13562: LD_INT 0
13564: PPUSH
13565: PPUSH
// begin ComAttackUnit ( Heike , Burlak ) ;
13566: LD_EXP 11
13570: PPUSH
13571: LD_EXP 1
13575: PPUSH
13576: CALL_OW 115
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13580: LD_ADDR_VAR 0 1
13584: PUSH
13585: LD_INT 22
13587: PUSH
13588: LD_EXP 31
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 21
13599: PUSH
13600: LD_INT 1
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: ST_TO_ADDR
// for un in filter do
13616: LD_ADDR_VAR 0 2
13620: PUSH
13621: LD_VAR 0 1
13625: PUSH
13626: FOR_IN
13627: IFFALSE 13652
// begin AddComAttackUnit ( Heike , un ) ;
13629: LD_EXP 11
13633: PPUSH
13634: LD_VAR 0 2
13638: PPUSH
13639: CALL_OW 175
// Wait ( 10 ) ;
13643: LD_INT 10
13645: PPUSH
13646: CALL_OW 67
// end ;
13650: GO 13626
13652: POP
13653: POP
// enable ;
13654: ENABLE
// end ;
13655: PPOPN 2
13657: END
// on BuildingComplete ( building ) do var rnd , distance , un1 , un2 , pole , budova1 , budova2 , i , filter ;
13658: LD_INT 0
13660: PPUSH
13661: PPUSH
13662: PPUSH
13663: PPUSH
13664: PPUSH
13665: PPUSH
13666: PPUSH
13667: PPUSH
13668: PPUSH
// begin if ( not depot_build ) and ( GetBType ( building ) = b_depot ) and HeikeCaptured then
13669: LD_EXP 28
13673: NOT
13674: PUSH
13675: LD_VAR 0 1
13679: PPUSH
13680: CALL_OW 266
13684: PUSH
13685: LD_INT 0
13687: EQUAL
13688: AND
13689: PUSH
13690: LD_EXP 37
13694: AND
13695: IFFALSE 13775
// begin depot_build = true ;
13697: LD_ADDR_EXP 28
13701: PUSH
13702: LD_INT 1
13704: ST_TO_ADDR
// depotX := GetX ( building ) ;
13705: LD_ADDR_EXP 29
13709: PUSH
13710: LD_VAR 0 1
13714: PPUSH
13715: CALL_OW 250
13719: ST_TO_ADDR
// depotY := GetY ( building ) ;
13720: LD_ADDR_EXP 30
13724: PUSH
13725: LD_VAR 0 1
13729: PPUSH
13730: CALL_OW 251
13734: ST_TO_ADDR
// Wait ( 0 0$10 ) ;
13735: LD_INT 350
13737: PPUSH
13738: CALL_OW 67
// D_Heike ;
13742: CALL 4921 0 0
// rnd := Rand ( 1 1$15 , 2 2$0 ) ;
13746: LD_ADDR_VAR 0 2
13750: PUSH
13751: LD_INT 2625
13753: PPUSH
13754: LD_INT 4200
13756: PPUSH
13757: CALL_OW 12
13761: ST_TO_ADDR
// Wait ( rnd ) ;
13762: LD_VAR 0 2
13766: PPUSH
13767: CALL_OW 67
// merc_help ;
13771: CALL 7490 0 0
// end ; end ;
13775: PPOPN 10
13777: END
// on UpgradeComplete ( building ) do begin if ( GetBType ( building ) = b_barracks ) and ( GetNation ( building ) = nation_arabian ) then
13778: LD_VAR 0 1
13782: PPUSH
13783: CALL_OW 266
13787: PUSH
13788: LD_INT 5
13790: EQUAL
13791: PUSH
13792: LD_VAR 0 1
13796: PPUSH
13797: CALL_OW 248
13801: PUSH
13802: LD_INT 2
13804: EQUAL
13805: AND
13806: IFFALSE 13910
// begin MortarDone := true ;
13808: LD_ADDR_EXP 52
13812: PUSH
13813: LD_INT 1
13815: ST_TO_ADDR
// if not MercHandedOver or not MercWillBeHandedOver then
13816: LD_EXP 40
13820: NOT
13821: PUSH
13822: LD_EXP 41
13826: NOT
13827: OR
13828: IFFALSE 13910
// begin Wait ( 0 0$1 ) ;
13830: LD_INT 35
13832: PPUSH
13833: CALL_OW 67
// enable ( 3 ) ;
13837: LD_INT 3
13839: ENABLE_MARKED
// D_MercCompleted ;
13840: CALL 5188 0 0
// enable ( 20 ) ;
13844: LD_INT 20
13846: ENABLE_MARKED
// SetAreaMapShow ( WaitHeikeArea , 1 ) ;
13847: LD_INT 8
13849: PPUSH
13850: LD_INT 1
13852: PPUSH
13853: CALL_OW 424
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
13857: LD_EXP 13
13861: PUSH
13862: LD_EXP 14
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: PPUSH
13871: LD_EXP 34
13875: PPUSH
13876: CALL_OW 235
// disable ( 601 ) ;
13880: LD_INT 601
13882: DISABLE_MARKED
// ComMoveXY ( [ Kurt , Mercenary1 ] , 39 , 48 ) ;
13883: LD_EXP 13
13887: PUSH
13888: LD_EXP 14
13892: PUSH
13893: EMPTY
13894: LIST
13895: LIST
13896: PPUSH
13897: LD_INT 39
13899: PPUSH
13900: LD_INT 48
13902: PPUSH
13903: CALL_OW 111
// enable ( 6 ) ;
13907: LD_INT 6
13909: ENABLE_MARKED
// end ; end ; end ;
13910: PPOPN 1
13912: END
// on UnitGoesToRed ( un ) do begin if LimitTeleportResearched and GetType ( un ) = unit_vehicle then
13913: LD_EXP 62
13917: PUSH
13918: LD_VAR 0 1
13922: PPUSH
13923: CALL_OW 247
13927: PUSH
13928: LD_INT 2
13930: EQUAL
13931: AND
13932: IFFALSE 13949
// begin LimitTeleportTested := true ;
13934: LD_ADDR_EXP 63
13938: PUSH
13939: LD_INT 1
13941: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
13942: LD_STRING MTeleDone
13944: PPUSH
13945: CALL_OW 337
// end ; if GetSide ( un ) = usa then
13949: LD_VAR 0 1
13953: PPUSH
13954: CALL_OW 255
13958: PUSH
13959: LD_EXP 35
13963: EQUAL
13964: IFFALSE 13982
// amattack := amattack diff un ;
13966: LD_ADDR_EXP 27
13970: PUSH
13971: LD_EXP 27
13975: PUSH
13976: LD_VAR 0 1
13980: DIFF
13981: ST_TO_ADDR
// if un = Heike then
13982: LD_VAR 0 1
13986: PUSH
13987: LD_EXP 11
13991: EQUAL
13992: IFFALSE 14149
// begin if MortarAsked and not MercHandedOver then
13994: LD_EXP 69
13998: PUSH
13999: LD_EXP 40
14003: NOT
14004: AND
14005: IFFALSE 14105
// begin D_MercDeceived ;
14007: CALL 5333 0 0
// if not MortarDone then
14011: LD_EXP 52
14015: NOT
14016: IFFALSE 14079
// begin SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
14018: LD_EXP 13
14022: PUSH
14023: LD_EXP 14
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PPUSH
14032: LD_EXP 34
14036: PPUSH
14037: CALL_OW 235
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
14041: LD_EXP 13
14045: PUSH
14046: LD_EXP 14
14050: PUSH
14051: EMPTY
14052: LIST
14053: LIST
14054: PPUSH
14055: LD_EXP 1
14059: PPUSH
14060: CALL_OW 250
14064: PPUSH
14065: LD_EXP 1
14069: PPUSH
14070: CALL_OW 251
14074: PPUSH
14075: CALL_OW 114
// end ; SetLives ( Heike , 0 ) ;
14079: LD_EXP 11
14083: PPUSH
14084: LD_INT 0
14086: PPUSH
14087: CALL_OW 234
// HeikeKilled := true ;
14091: LD_ADDR_EXP 38
14095: PUSH
14096: LD_INT 1
14098: ST_TO_ADDR
// merc_attack ;
14099: CALL 7691 0 0
// end else
14103: GO 14149
// begin D_HeikeKilled ;
14105: CALL 4952 0 0
// SetLives ( Heike , 0 ) ;
14109: LD_EXP 11
14113: PPUSH
14114: LD_INT 0
14116: PPUSH
14117: CALL_OW 234
// HeikeKilled := true ;
14121: LD_ADDR_EXP 38
14125: PUSH
14126: LD_INT 1
14128: ST_TO_ADDR
// SetAttitude ( you , merc , att_enemy , true ) ;
14129: LD_EXP 31
14133: PPUSH
14134: LD_EXP 34
14138: PPUSH
14139: LD_INT 2
14141: PPUSH
14142: LD_INT 1
14144: PPUSH
14145: CALL_OW 80
// end ; end ; end ;
14149: PPOPN 1
14151: END
// on UnitDestroyed ( human ) do begin if human = Burlak then
14152: LD_VAR 0 1
14156: PUSH
14157: LD_EXP 1
14161: EQUAL
14162: IFFALSE 14171
// YouLost ( Burlak ) ;
14164: LD_STRING Burlak
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: PPOPN 1
14173: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_AdvAI then
14174: LD_VAR 0 1
14178: PUSH
14179: LD_INT 27
14181: EQUAL
14182: IFFALSE 14209
// begin Hint ( AI ) ;
14184: LD_STRING AI
14186: PPUSH
14187: CALL_OW 339
// Wait ( 0 0$10 ) ;
14191: LD_INT 350
14193: PPUSH
14194: CALL_OW 67
// D_AI ;
14198: CALL 6847 0 0
// ChangeMissionObjectives ( MAI ) ;
14202: LD_STRING MAI
14204: PPUSH
14205: CALL_OW 337
// end ; if tech = tech_LimTeleport then
14209: LD_VAR 0 1
14213: PUSH
14214: LD_INT 37
14216: EQUAL
14217: IFFALSE 14252
// begin Hint ( SpontTelep ) ;
14219: LD_STRING SpontTelep
14221: PPUSH
14222: CALL_OW 339
// Wait ( 0 0$10 ) ;
14226: LD_INT 350
14228: PPUSH
14229: CALL_OW 67
// D_SpontTelep ;
14233: CALL 6949 0 0
// ChangeMissionObjectives ( MTele ) ;
14237: LD_STRING MTele
14239: PPUSH
14240: CALL_OW 337
// LimitTeleportResearched := true ;
14244: LD_ADDR_EXP 62
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// end ; AvailableTechno := AvailableTechno diff tech ;
14252: LD_ADDR_EXP 56
14256: PUSH
14257: LD_EXP 56
14261: PUSH
14262: LD_VAR 0 1
14266: DIFF
14267: ST_TO_ADDR
// if HeikeCratesTime then
14268: LD_LOC 5
14272: IFFALSE 14335
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
14274: LD_ADDR_OWVAR 47
14278: PUSH
14279: LD_STRING #Ru08-1
14281: PUSH
14282: LD_INT 0
14284: PUSH
14285: LD_LOC 3
14289: PLUS
14290: PUSH
14291: LD_STRING #Ru08-2
14293: PUSH
14294: LD_INT 0
14296: PUSH
14297: LD_LOC 4
14301: PLUS
14302: PUSH
14303: LD_STRING #Ru08-3
14305: PUSH
14306: LD_INT 0
14308: PUSH
14309: LD_EXP 56
14313: PLUS
14314: PUSH
14315: LD_STRING #Ru08-4
14317: PUSH
14318: LD_LOC 5
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: ST_TO_ADDR
14333: GO 14384
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
14335: LD_ADDR_OWVAR 47
14339: PUSH
14340: LD_STRING #Ru08-1
14342: PUSH
14343: LD_INT 0
14345: PUSH
14346: LD_LOC 3
14350: PLUS
14351: PUSH
14352: LD_STRING #Ru08-2
14354: PUSH
14355: LD_INT 0
14357: PUSH
14358: LD_LOC 4
14362: PLUS
14363: PUSH
14364: LD_STRING #Ru08-3
14366: PUSH
14367: LD_INT 0
14369: PUSH
14370: LD_EXP 56
14374: PLUS
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: ST_TO_ADDR
// if AvailableTechno = [ ] and not TechnoDone then
14384: LD_EXP 56
14388: PUSH
14389: EMPTY
14390: EQUAL
14391: PUSH
14392: LD_EXP 51
14396: NOT
14397: AND
14398: IFFALSE 14415
// begin ChangeMissionObjectives ( MTechnoDone ) ;
14400: LD_STRING MTechnoDone
14402: PPUSH
14403: CALL_OW 337
// TechnoDone := true ;
14407: LD_ADDR_EXP 51
14411: PUSH
14412: LD_INT 1
14414: ST_TO_ADDR
// end ; end ;
14415: PPOPN 2
14417: END
// on VehicleConstructed ( veh , fact ) do begin AvailableWeapons := AvailableWeapons diff GetWeapon ( veh ) ;
14418: LD_ADDR_EXP 54
14422: PUSH
14423: LD_EXP 54
14427: PUSH
14428: LD_VAR 0 1
14432: PPUSH
14433: CALL_OW 264
14437: DIFF
14438: ST_TO_ADDR
// if ( AvailableWeapons + 0 ) = 2 and not MashaAsked then
14439: LD_EXP 54
14443: PUSH
14444: LD_INT 0
14446: PLUS
14447: PUSH
14448: LD_INT 2
14450: EQUAL
14451: PUSH
14452: LD_EXP 70
14456: NOT
14457: AND
14458: IFFALSE 14463
// enable ( 401 ) ;
14460: LD_INT 401
14462: ENABLE_MARKED
// if GetControl ( veh ) = control_computer then
14463: LD_VAR 0 1
14467: PPUSH
14468: CALL_OW 263
14472: PUSH
14473: LD_INT 3
14475: EQUAL
14476: IFFALSE 14493
// begin ChangeMissionObjectives ( MAIDone ) ;
14478: LD_STRING MAIDone
14480: PPUSH
14481: CALL_OW 337
// CompVehConstructed = true ;
14485: LD_ADDR_EXP 61
14489: PUSH
14490: LD_INT 1
14492: ST_TO_ADDR
// end ; end ;
14493: PPOPN 2
14495: END
// on Command ( comm ) marked 601 do var i ;
14496: LD_INT 0
14498: PPUSH
// begin if IsOK ( Kurt ) then
14499: LD_EXP 13
14503: PPUSH
14504: CALL_OW 302
14508: IFFALSE 14708
// if GetTaskList ( Kurt ) <> [ ] then
14510: LD_EXP 13
14514: PPUSH
14515: CALL_OW 437
14519: PUSH
14520: EMPTY
14521: NONEQUAL
14522: IFFALSE 14708
// begin for i := 1 to ( 0 + GetTaskList ( Kurt ) ) do
14524: LD_ADDR_VAR 0 2
14528: PUSH
14529: DOUBLE
14530: LD_INT 1
14532: DEC
14533: ST_TO_ADDR
14534: LD_INT 0
14536: PUSH
14537: LD_EXP 13
14541: PPUSH
14542: CALL_OW 437
14546: PLUS
14547: PUSH
14548: FOR_TO
14549: IFFALSE 14706
// begin if ( GetTaskList ( Kurt ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Kurt ) [ i ] [ 1 ] = B and GetTaskList ( Kurt ) [ i ] [ 5 ] = 36 ) then
14551: LD_EXP 13
14555: PPUSH
14556: CALL_OW 437
14560: PUSH
14561: LD_VAR 0 2
14565: ARRAY
14566: PUSH
14567: LD_INT 1
14569: ARRAY
14570: PUSH
14571: LD_STRING F
14573: PUSH
14574: LD_STRING H
14576: PUSH
14577: LD_STRING M
14579: PUSH
14580: LD_STRING U
14582: PUSH
14583: LD_STRING V
14585: PUSH
14586: LD_STRING a
14588: PUSH
14589: LD_STRING h
14591: PUSH
14592: LD_STRING u
14594: PUSH
14595: LD_STRING v
14597: PUSH
14598: LD_STRING ~
14600: PUSH
14601: LD_STRING ^
14603: PUSH
14604: LD_STRING >
14606: PUSH
14607: LD_STRING +
14609: PUSH
14610: LD_STRING ;
14612: PUSH
14613: LD_STRING 4
14615: PUSH
14616: LD_STRING {
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: IN
14637: PUSH
14638: LD_EXP 13
14642: PPUSH
14643: CALL_OW 437
14647: PUSH
14648: LD_VAR 0 2
14652: ARRAY
14653: PUSH
14654: LD_INT 1
14656: ARRAY
14657: PUSH
14658: LD_STRING B
14660: EQUAL
14661: PUSH
14662: LD_EXP 13
14666: PPUSH
14667: CALL_OW 437
14671: PUSH
14672: LD_VAR 0 2
14676: ARRAY
14677: PUSH
14678: LD_INT 5
14680: ARRAY
14681: PUSH
14682: LD_INT 36
14684: EQUAL
14685: AND
14686: OR
14687: IFFALSE 14691
// else
14689: GO 14704
// begin RemoveTasks ( Kurt ) ;
14691: LD_EXP 13
14695: PPUSH
14696: CALL_OW 493
// D_MercRefuseBuild ;
14700: CALL 5168 0 0
// end ; end ;
14704: GO 14548
14706: POP
14707: POP
// end ; if IsOK ( Mercenary1 ) then
14708: LD_EXP 14
14712: PPUSH
14713: CALL_OW 302
14717: IFFALSE 14917
// if GetTaskList ( Mercenary1 ) <> [ ] then
14719: LD_EXP 14
14723: PPUSH
14724: CALL_OW 437
14728: PUSH
14729: EMPTY
14730: NONEQUAL
14731: IFFALSE 14917
// begin for i := 1 to ( 0 + GetTaskList ( Mercenary1 ) ) do
14733: LD_ADDR_VAR 0 2
14737: PUSH
14738: DOUBLE
14739: LD_INT 1
14741: DEC
14742: ST_TO_ADDR
14743: LD_INT 0
14745: PUSH
14746: LD_EXP 14
14750: PPUSH
14751: CALL_OW 437
14755: PLUS
14756: PUSH
14757: FOR_TO
14758: IFFALSE 14915
// begin if ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] = B and GetTaskList ( Mercenary1 ) [ i ] [ 5 ] = 36 ) then
14760: LD_EXP 14
14764: PPUSH
14765: CALL_OW 437
14769: PUSH
14770: LD_VAR 0 2
14774: ARRAY
14775: PUSH
14776: LD_INT 1
14778: ARRAY
14779: PUSH
14780: LD_STRING F
14782: PUSH
14783: LD_STRING H
14785: PUSH
14786: LD_STRING M
14788: PUSH
14789: LD_STRING U
14791: PUSH
14792: LD_STRING V
14794: PUSH
14795: LD_STRING a
14797: PUSH
14798: LD_STRING h
14800: PUSH
14801: LD_STRING u
14803: PUSH
14804: LD_STRING v
14806: PUSH
14807: LD_STRING ~
14809: PUSH
14810: LD_STRING ^
14812: PUSH
14813: LD_STRING >
14815: PUSH
14816: LD_STRING +
14818: PUSH
14819: LD_STRING ;
14821: PUSH
14822: LD_STRING 4
14824: PUSH
14825: LD_STRING {
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: IN
14846: PUSH
14847: LD_EXP 14
14851: PPUSH
14852: CALL_OW 437
14856: PUSH
14857: LD_VAR 0 2
14861: ARRAY
14862: PUSH
14863: LD_INT 1
14865: ARRAY
14866: PUSH
14867: LD_STRING B
14869: EQUAL
14870: PUSH
14871: LD_EXP 14
14875: PPUSH
14876: CALL_OW 437
14880: PUSH
14881: LD_VAR 0 2
14885: ARRAY
14886: PUSH
14887: LD_INT 5
14889: ARRAY
14890: PUSH
14891: LD_INT 36
14893: EQUAL
14894: AND
14895: OR
14896: IFFALSE 14900
// else
14898: GO 14913
// begin RemoveTasks ( Mercenary1 ) ;
14900: LD_EXP 14
14904: PPUSH
14905: CALL_OW 493
// D_MercRefuseBuild ;
14909: CALL 5168 0 0
// end ; end ;
14913: GO 14757
14915: POP
14916: POP
// end ; end ;
14917: PPOPN 2
14919: END
// every 0 0$1 trigger IsOk ( Kurt ) and GetSide ( Kurt ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) >= 2 do
14920: LD_EXP 13
14924: PPUSH
14925: CALL_OW 302
14929: PUSH
14930: LD_EXP 13
14934: PPUSH
14935: CALL_OW 255
14939: PUSH
14940: LD_INT 3
14942: EQUAL
14943: AND
14944: PUSH
14945: LD_INT 22
14947: PUSH
14948: LD_INT 3
14950: PUSH
14951: EMPTY
14952: LIST
14953: LIST
14954: PUSH
14955: LD_INT 23
14957: PUSH
14958: LD_INT 2
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PUSH
14965: LD_INT 30
14967: PUSH
14968: LD_INT 4
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PUSH
14975: EMPTY
14976: LIST
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL_OW 69
14984: PUSH
14985: LD_INT 2
14987: GREATEREQUAL
14988: AND
14989: IFFALSE 15056
14991: GO 14993
14993: DISABLE
// begin enable ;
14994: ENABLE
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) [ 2 ] ) ;
14995: LD_INT 22
14997: PUSH
14998: LD_INT 3
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: PUSH
15005: LD_INT 23
15007: PUSH
15008: LD_INT 2
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: PUSH
15015: LD_INT 30
15017: PUSH
15018: LD_INT 4
15020: PUSH
15021: EMPTY
15022: LIST
15023: LIST
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: LIST
15029: PPUSH
15030: CALL_OW 69
15034: PUSH
15035: LD_INT 2
15037: ARRAY
15038: PPUSH
15039: CALL_OW 64
// RemoveTasks ( Mercenary1 ) ;
15043: LD_EXP 14
15047: PPUSH
15048: CALL_OW 493
// D_MercRefuseBuild ;
15052: CALL 5168 0 0
// end ; end_of_file
15056: END
// export function hunt ( hunter ) ; var un , animals , animal , kasarna , depot , i , x , y , d , rnd_animal , hunter_x_coordinate , hunter_y_coordinate , range , osoba , min , setridene_animals ; begin
15057: LD_INT 0
15059: PPUSH
15060: PPUSH
15061: PPUSH
15062: PPUSH
15063: PPUSH
15064: PPUSH
15065: PPUSH
15066: PPUSH
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
15072: PPUSH
15073: PPUSH
15074: PPUSH
15075: PPUSH
// kasarna := FilterAllUnits ( [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ) ;
15076: LD_ADDR_VAR 0 6
15080: PUSH
15081: LD_INT 2
15083: PUSH
15084: LD_INT 30
15086: PUSH
15087: LD_INT 5
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 30
15096: PUSH
15097: LD_INT 4
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: LIST
15108: PPUSH
15109: CALL_OW 69
15113: ST_TO_ADDR
// SetSide ( hunter , ally ) ;
15114: LD_VAR 0 1
15118: PPUSH
15119: LD_EXP 32
15123: PPUSH
15124: CALL_OW 235
// if not ( GetClass ( hunter ) = class_soldier ) and ( kasarna > 0 ) then
15128: LD_VAR 0 1
15132: PPUSH
15133: CALL_OW 257
15137: PUSH
15138: LD_INT 1
15140: EQUAL
15141: NOT
15142: PUSH
15143: LD_VAR 0 6
15147: PUSH
15148: LD_INT 0
15150: GREATER
15151: AND
15152: IFFALSE 15340
// begin ComEnterUnit ( hunter , kasarna [ 1 ] ) ;
15154: LD_VAR 0 1
15158: PPUSH
15159: LD_VAR 0 6
15163: PUSH
15164: LD_INT 1
15166: ARRAY
15167: PPUSH
15168: CALL_OW 120
// Wait ( 10 ) ;
15172: LD_INT 10
15174: PPUSH
15175: CALL_OW 67
// while HasTask ( hunter ) do
15179: LD_VAR 0 1
15183: PPUSH
15184: CALL_OW 314
15188: IFFALSE 15199
// begin Wait ( 10 ) ;
15190: LD_INT 10
15192: PPUSH
15193: CALL_OW 67
// end ;
15197: GO 15179
// hunter_x_coordinate := GetX ( hunter ) ;
15199: LD_ADDR_VAR 0 13
15203: PUSH
15204: LD_VAR 0 1
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// hunter_y_coordinate := GetY ( hunter ) ;
15214: LD_ADDR_VAR 0 14
15218: PUSH
15219: LD_VAR 0 1
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// RemoveUnit ( hunter ) ;
15229: LD_VAR 0 1
15233: PPUSH
15234: CALL_OW 64
// SetClass ( hunter , class_soldier ) ;
15238: LD_VAR 0 1
15242: PPUSH
15243: LD_INT 1
15245: PPUSH
15246: CALL_OW 336
// Wait ( 0 0$2 ) ;
15250: LD_INT 70
15252: PPUSH
15253: CALL_OW 67
// if not PlaceUnitXY ( hunter , hunter_x_coordinate , hunter_y_coordinate , false ) then
15257: LD_VAR 0 1
15261: PPUSH
15262: LD_VAR 0 13
15266: PPUSH
15267: LD_VAR 0 14
15271: PPUSH
15272: LD_INT 0
15274: PPUSH
15275: CALL_OW 48
15279: NOT
15280: IFFALSE 15340
// begin range := 0 ;
15282: LD_ADDR_VAR 0 15
15286: PUSH
15287: LD_INT 0
15289: ST_TO_ADDR
// repeat Wait ( 2 ) ;
15290: LD_INT 2
15292: PPUSH
15293: CALL_OW 67
// range := range + 1 ;
15297: LD_ADDR_VAR 0 15
15301: PUSH
15302: LD_VAR 0 15
15306: PUSH
15307: LD_INT 1
15309: PLUS
15310: ST_TO_ADDR
// until PlaceUnitXYR ( hunter , hunter_x_coordinate , hunter_y_coordinate , range , false ) end ;
15311: LD_VAR 0 1
15315: PPUSH
15316: LD_VAR 0 13
15320: PPUSH
15321: LD_VAR 0 14
15325: PPUSH
15326: LD_VAR 0 15
15330: PPUSH
15331: LD_INT 0
15333: PPUSH
15334: CALL_OW 50
15338: IFFALSE 15290
// end ; animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15340: LD_ADDR_VAR 0 4
15344: PUSH
15345: LD_INT 2
15347: PUSH
15348: LD_INT 25
15350: PUSH
15351: LD_INT 18
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: PUSH
15358: LD_INT 25
15360: PUSH
15361: LD_INT 14
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: PUSH
15368: EMPTY
15369: LIST
15370: LIST
15371: LIST
15372: PPUSH
15373: CALL_OW 69
15377: ST_TO_ADDR
// if animals = [ ] then
15378: LD_VAR 0 4
15382: PUSH
15383: EMPTY
15384: EQUAL
15385: IFFALSE 15569
// begin Randomize ;
15387: CALL_OW 10
// RandomizeAll ;
15391: CALL_OW 11
// for i := 1 to 6 do
15395: LD_ADDR_VAR 0 8
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_INT 6
15407: PUSH
15408: FOR_TO
15409: IFFALSE 15567
// begin uc_side = 0 ;
15411: LD_ADDR_OWVAR 20
15415: PUSH
15416: LD_INT 0
15418: ST_TO_ADDR
// uc_nation := nation_nature ;
15419: LD_ADDR_OWVAR 21
15423: PUSH
15424: LD_INT 0
15426: ST_TO_ADDR
// PrepareHuman ( 0 , class_phororhacos , 0 ) ;
15427: LD_INT 0
15429: PPUSH
15430: LD_INT 18
15432: PPUSH
15433: LD_INT 0
15435: PPUSH
15436: CALL_OW 380
// hc_name :=  ;
15440: LD_ADDR_OWVAR 26
15444: PUSH
15445: LD_STRING 
15447: ST_TO_ADDR
// Wait ( 1 ) ;
15448: LD_INT 1
15450: PPUSH
15451: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15455: CALL_OW 44
15459: PPUSH
15460: LD_INT 22
15462: PPUSH
15463: LD_INT 0
15465: PPUSH
15466: CALL_OW 49
// Wait ( 1 ) ;
15470: LD_INT 1
15472: PPUSH
15473: CALL_OW 67
// PrepareHuman ( 0 , class_tiger , 0 ) ;
15477: LD_INT 0
15479: PPUSH
15480: LD_INT 14
15482: PPUSH
15483: LD_INT 0
15485: PPUSH
15486: CALL_OW 380
// hc_name :=  ;
15490: LD_ADDR_OWVAR 26
15494: PUSH
15495: LD_STRING 
15497: ST_TO_ADDR
// Wait ( 1 ) ;
15498: LD_INT 1
15500: PPUSH
15501: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15505: CALL_OW 44
15509: PPUSH
15510: LD_INT 22
15512: PPUSH
15513: LD_INT 0
15515: PPUSH
15516: CALL_OW 49
// Wait ( 1 ) ;
15520: LD_INT 1
15522: PPUSH
15523: CALL_OW 67
// animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15527: LD_ADDR_VAR 0 4
15531: PUSH
15532: LD_INT 2
15534: PUSH
15535: LD_INT 25
15537: PUSH
15538: LD_INT 18
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: LD_INT 25
15547: PUSH
15548: LD_INT 14
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: PPUSH
15560: CALL_OW 69
15564: ST_TO_ADDR
// end ;
15565: GO 15408
15567: POP
15568: POP
// end ; if GetClass ( hunter ) = class_soldier then
15569: LD_VAR 0 1
15573: PPUSH
15574: CALL_OW 257
15578: PUSH
15579: LD_INT 1
15581: EQUAL
15582: IFFALSE 15602
// rnd_animal := Rand ( 4 , 6 ) else
15584: LD_ADDR_VAR 0 12
15588: PUSH
15589: LD_INT 4
15591: PPUSH
15592: LD_INT 6
15594: PPUSH
15595: CALL_OW 12
15599: ST_TO_ADDR
15600: GO 15618
// rnd_animal := Rand ( 1 , 2 ) ;
15602: LD_ADDR_VAR 0 12
15606: PUSH
15607: LD_INT 1
15609: PPUSH
15610: LD_INT 2
15612: PPUSH
15613: CALL_OW 12
15617: ST_TO_ADDR
// range := 999 ;
15618: LD_ADDR_VAR 0 15
15622: PUSH
15623: LD_INT 999
15625: ST_TO_ADDR
// osoba := hunter ;
15626: LD_ADDR_VAR 0 16
15630: PUSH
15631: LD_VAR 0 1
15635: ST_TO_ADDR
// setridene_animals := [ ] ;
15636: LD_ADDR_VAR 0 18
15640: PUSH
15641: EMPTY
15642: ST_TO_ADDR
// while animals <> [ ] do
15643: LD_VAR 0 4
15647: PUSH
15648: EMPTY
15649: NONEQUAL
15650: IFFALSE 15780
// begin for un in animals do
15652: LD_ADDR_VAR 0 3
15656: PUSH
15657: LD_VAR 0 4
15661: PUSH
15662: FOR_IN
15663: IFFALSE 15726
// begin if GetDistUnits ( osoba , un ) < range then
15665: LD_VAR 0 16
15669: PPUSH
15670: LD_VAR 0 3
15674: PPUSH
15675: CALL_OW 296
15679: PUSH
15680: LD_VAR 0 15
15684: LESS
15685: IFFALSE 15717
// begin range := GetDistUnits ( hunter , un ) ;
15687: LD_ADDR_VAR 0 15
15691: PUSH
15692: LD_VAR 0 1
15696: PPUSH
15697: LD_VAR 0 3
15701: PPUSH
15702: CALL_OW 296
15706: ST_TO_ADDR
// min := un ;
15707: LD_ADDR_VAR 0 17
15711: PUSH
15712: LD_VAR 0 3
15716: ST_TO_ADDR
// end ; Wait ( 1 ) ;
15717: LD_INT 1
15719: PPUSH
15720: CALL_OW 67
// end ;
15724: GO 15662
15726: POP
15727: POP
// setridene_animals := setridene_animals ^ min ;
15728: LD_ADDR_VAR 0 18
15732: PUSH
15733: LD_VAR 0 18
15737: PUSH
15738: LD_VAR 0 17
15742: ADD
15743: ST_TO_ADDR
// animals := animals diff min ;
15744: LD_ADDR_VAR 0 4
15748: PUSH
15749: LD_VAR 0 4
15753: PUSH
15754: LD_VAR 0 17
15758: DIFF
15759: ST_TO_ADDR
// osoba := min ;
15760: LD_ADDR_VAR 0 16
15764: PUSH
15765: LD_VAR 0 17
15769: ST_TO_ADDR
// range := 999 ;
15770: LD_ADDR_VAR 0 15
15774: PUSH
15775: LD_INT 999
15777: ST_TO_ADDR
// end ;
15778: GO 15643
// for i := 1 to rnd_animal do
15780: LD_ADDR_VAR 0 8
15784: PUSH
15785: DOUBLE
15786: LD_INT 1
15788: DEC
15789: ST_TO_ADDR
15790: LD_VAR 0 12
15794: PUSH
15795: FOR_TO
15796: IFFALSE 15827
// begin AddComAttackUnit ( hunter , setridene_animals [ i ] ) ;
15798: LD_VAR 0 1
15802: PPUSH
15803: LD_VAR 0 18
15807: PUSH
15808: LD_VAR 0 8
15812: ARRAY
15813: PPUSH
15814: CALL_OW 175
// Wait ( 10 ) ;
15818: LD_INT 10
15820: PPUSH
15821: CALL_OW 67
// end ;
15825: GO 15795
15827: POP
15828: POP
// if GetClass ( hunter ) = class_soldier then
15829: LD_VAR 0 1
15833: PPUSH
15834: CALL_OW 257
15838: PUSH
15839: LD_INT 1
15841: EQUAL
15842: IFFALSE 15847
// enable ( 102 ) ;
15844: LD_INT 102
15846: ENABLE_MARKED
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15847: LD_ADDR_VAR 0 7
15851: PUSH
15852: LD_INT 2
15854: PUSH
15855: LD_INT 30
15857: PUSH
15858: LD_INT 0
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PUSH
15865: LD_INT 30
15867: PUSH
15868: LD_INT 1
15870: PUSH
15871: EMPTY
15872: LIST
15873: LIST
15874: PUSH
15875: EMPTY
15876: LIST
15877: LIST
15878: LIST
15879: PPUSH
15880: CALL_OW 69
15884: ST_TO_ADDR
// if depot + 0 > 0 then
15885: LD_VAR 0 7
15889: PUSH
15890: LD_INT 0
15892: PLUS
15893: PUSH
15894: LD_INT 0
15896: GREATER
15897: IFFALSE 16003
// begin x := GetX ( depot [ 1 ] ) ;
15899: LD_ADDR_VAR 0 9
15903: PUSH
15904: LD_VAR 0 7
15908: PUSH
15909: LD_INT 1
15911: ARRAY
15912: PPUSH
15913: CALL_OW 250
15917: ST_TO_ADDR
// y := GetY ( depot [ 1 ] ) ;
15918: LD_ADDR_VAR 0 10
15922: PUSH
15923: LD_VAR 0 7
15927: PUSH
15928: LD_INT 1
15930: ARRAY
15931: PPUSH
15932: CALL_OW 251
15936: ST_TO_ADDR
// d := GetDir ( depot [ 1 ] ) ;
15937: LD_ADDR_VAR 0 11
15941: PUSH
15942: LD_VAR 0 7
15946: PUSH
15947: LD_INT 1
15949: ARRAY
15950: PPUSH
15951: CALL_OW 254
15955: ST_TO_ADDR
// AddComMoveXY ( hunter , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
15956: LD_VAR 0 1
15960: PPUSH
15961: LD_VAR 0 9
15965: PPUSH
15966: LD_VAR 0 11
15970: PPUSH
15971: LD_INT 7
15973: PPUSH
15974: CALL_OW 272
15978: PPUSH
15979: LD_VAR 0 10
15983: PPUSH
15984: LD_VAR 0 11
15988: PPUSH
15989: LD_INT 7
15991: PPUSH
15992: CALL_OW 273
15996: PPUSH
15997: CALL_OW 171
// end else
16001: GO 16018
// AddComMoveXY ( hunter , 83 , 40 ) ;
16003: LD_VAR 0 1
16007: PPUSH
16008: LD_INT 83
16010: PPUSH
16011: LD_INT 40
16013: PPUSH
16014: CALL_OW 171
// while HasTask ( hunter ) do
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 314
16027: IFFALSE 16038
// begin Wait ( 0 0$1 ) ;
16029: LD_INT 35
16031: PPUSH
16032: CALL_OW 67
// end ;
16036: GO 16018
// SetSide ( hunter , you ) ;
16038: LD_VAR 0 1
16042: PPUSH
16043: LD_EXP 31
16047: PPUSH
16048: CALL_OW 235
// end ;
16052: LD_VAR 0 2
16056: RET
// every 0 0$1 marked 101 do
16057: GO 16059
16059: DISABLE
// begin HuntingAsked := true ;
16060: LD_ADDR_EXP 67
16064: PUSH
16065: LD_INT 1
16067: ST_TO_ADDR
// Wait ( Rand ( 0 0$30 , 2 2$30 ) ) ;
16068: LD_INT 1050
16070: PPUSH
16071: LD_INT 5250
16073: PPUSH
16074: CALL_OW 12
16078: PPUSH
16079: CALL_OW 67
// if not ( HuntingAccepted ) and ( IsOK ( Belkov ) or IsOK ( Karamazov ) or IsOK ( Kozlov ) ) then
16083: LD_EXP 47
16087: NOT
16088: PUSH
16089: LD_EXP 3
16093: PPUSH
16094: CALL_OW 302
16098: PUSH
16099: LD_EXP 17
16103: PPUSH
16104: CALL_OW 302
16108: OR
16109: PUSH
16110: LD_EXP 20
16114: PPUSH
16115: CALL_OW 302
16119: OR
16120: AND
16121: IFFALSE 16183
// begin D_Hunting ;
16123: CALL 5937 0 0
// case Query ( QHunting ) of 1 :
16127: LD_STRING QHunting
16129: PPUSH
16130: CALL_OW 97
16134: PUSH
16135: LD_INT 1
16137: DOUBLE
16138: EQUAL
16139: IFTRUE 16143
16141: GO 16167
16143: POP
// begin HuntingAccepted := true ;
16144: LD_ADDR_EXP 47
16148: PUSH
16149: LD_INT 1
16151: ST_TO_ADDR
// D_QrHunting1 ;
16152: CALL 6252 0 0
// hunt ( hunter ) ;
16156: LD_EXP 72
16160: PPUSH
16161: CALL 15057 0 1
// end ; 2 :
16165: GO 16183
16167: LD_INT 2
16169: DOUBLE
16170: EQUAL
16171: IFTRUE 16175
16173: GO 16182
16175: POP
// D_QrHunting2 ; end ;
16176: CALL 6272 0 0
16180: GO 16183
16182: POP
// end ; end ;
16183: END
// every 0 0$1 + 0 0$0.3 marked 102 do
16184: GO 16186
16186: DISABLE
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
16187: LD_EXP 72
16191: PPUSH
16192: LD_EXP 72
16196: PPUSH
16197: CALL_OW 319
16201: PPUSH
16202: CALL_OW 296
16206: PUSH
16207: LD_INT 13
16209: LESS
16210: IFFALSE 16223
// ComCrawl ( hunter ) else
16212: LD_EXP 72
16216: PPUSH
16217: CALL_OW 137
16221: GO 16232
// ComWalk ( hunter ) ;
16223: LD_EXP 72
16227: PPUSH
16228: CALL_OW 138
// if not HasTask ( hunter ) then
16232: LD_EXP 72
16236: PPUSH
16237: CALL_OW 314
16241: NOT
16242: IFFALSE 16247
// disable else
16244: DISABLE
16245: GO 16248
// enable ;
16247: ENABLE
// end ; end_of_file
16248: END
// var ShootAreaNr , BarrelAreas , StandAreas ; every 0 0$1 marked 201 do
16249: GO 16251
16251: DISABLE
// begin GalleryAsked := true ;
16252: LD_ADDR_EXP 66
16256: PUSH
16257: LD_INT 1
16259: ST_TO_ADDR
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
16260: LD_INT 350
16262: PPUSH
16263: LD_INT 700
16265: PPUSH
16266: CALL_OW 12
16270: PPUSH
16271: CALL_OW 67
// D_FiringRange ;
16275: CALL 5756 0 0
// case Query ( QShootingGallery ) of 1 :
16279: LD_STRING QShootingGallery
16281: PPUSH
16282: CALL_OW 97
16286: PUSH
16287: LD_INT 1
16289: DOUBLE
16290: EQUAL
16291: IFTRUE 16295
16293: GO 16392
16295: POP
// begin GalleryBuild := true ;
16296: LD_ADDR_EXP 53
16300: PUSH
16301: LD_INT 1
16303: ST_TO_ADDR
// D_QrShootingGallery1 ;
16304: CALL 5897 0 0
// Wait ( 0 0$2 ) ;
16308: LD_INT 70
16310: PPUSH
16311: CALL_OW 67
// Hint ( ShootingGallery ) ;
16315: LD_STRING ShootingGallery
16317: PPUSH
16318: CALL_OW 339
// ShootAreaNr := 1 ;
16322: LD_ADDR_LOC 8
16326: PUSH
16327: LD_INT 1
16329: ST_TO_ADDR
// BarrelAreas := [ BarrelArea1 , BarrelArea2 , BarrelArea3 , BarrelArea4 , BarrelArea5 ] ;
16330: LD_ADDR_LOC 9
16334: PUSH
16335: LD_INT 12
16337: PUSH
16338: LD_INT 13
16340: PUSH
16341: LD_INT 14
16343: PUSH
16344: LD_INT 15
16346: PUSH
16347: LD_INT 16
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: LIST
16354: LIST
16355: LIST
16356: ST_TO_ADDR
// StandAreas := [ StandArea1 , StandArea2 , StandArea3 , StandArea4 , StandArea5 ] ;
16357: LD_ADDR_LOC 10
16361: PUSH
16362: LD_INT 17
16364: PUSH
16365: LD_INT 18
16367: PUSH
16368: LD_INT 19
16370: PUSH
16371: LD_INT 20
16373: PUSH
16374: LD_INT 21
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: LIST
16381: LIST
16382: LIST
16383: ST_TO_ADDR
// enable ( 202 ) ;
16384: LD_INT 202
16386: ENABLE_MARKED
// enable ( 203 ) ;
16387: LD_INT 203
16389: ENABLE_MARKED
// end ; 2 :
16390: GO 16418
16392: LD_INT 2
16394: DOUBLE
16395: EQUAL
16396: IFTRUE 16400
16398: GO 16417
16400: POP
// begin D_QrShootingGallery2 ;
16401: CALL 5917 0 0
// SetAreaMapShow ( ShootArea , 0 ) ;
16405: LD_INT 11
16407: PPUSH
16408: LD_INT 0
16410: PPUSH
16411: CALL_OW 424
// end ; end ;
16415: GO 16418
16417: POP
// end ;
16418: END
// every 0 0$0.5 marked 202 do var shooters , un , buildings ;
16419: GO 16421
16421: DISABLE
16422: LD_INT 0
16424: PPUSH
16425: PPUSH
16426: PPUSH
// begin enable ;
16427: ENABLE
// shooters := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_not , [ f_hastask ] ] , [ f_nation , nation_russian ] ] ) ;
16428: LD_ADDR_VAR 0 1
16432: PUSH
16433: LD_INT 11
16435: PPUSH
16436: LD_INT 21
16438: PUSH
16439: LD_INT 1
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: LD_INT 3
16448: PUSH
16449: LD_INT 60
16451: PUSH
16452: EMPTY
16453: LIST
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: LD_INT 23
16461: PUSH
16462: LD_INT 3
16464: PUSH
16465: EMPTY
16466: LIST
16467: LIST
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 70
16478: ST_TO_ADDR
// if shooters <> [ ] then
16479: LD_VAR 0 1
16483: PUSH
16484: EMPTY
16485: NONEQUAL
16486: IFFALSE 17028
// begin for un in shooters do
16488: LD_ADDR_VAR 0 2
16492: PUSH
16493: LD_VAR 0 1
16497: PUSH
16498: FOR_IN
16499: IFFALSE 17026
// begin buildings := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
16501: LD_ADDR_VAR 0 3
16505: PUSH
16506: LD_INT 22
16508: PUSH
16509: LD_EXP 31
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PUSH
16518: LD_INT 2
16520: PUSH
16521: LD_INT 30
16523: PUSH
16524: LD_INT 0
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 30
16533: PUSH
16534: LD_INT 1
16536: PUSH
16537: EMPTY
16538: LIST
16539: LIST
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: LIST
16545: PUSH
16546: EMPTY
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PPUSH
16553: CALL_OW 69
16557: ST_TO_ADDR
// if buildings <> [ ] then
16558: LD_VAR 0 3
16562: PUSH
16563: EMPTY
16564: NONEQUAL
16565: IFFALSE 17024
// begin if not ( GetClass ( un ) = class_engineer ) then
16567: LD_VAR 0 2
16571: PPUSH
16572: CALL_OW 257
16576: PUSH
16577: LD_INT 2
16579: EQUAL
16580: NOT
16581: IFFALSE 16825
// begin ComMoveXY ( un , ShiftX ( GetX ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) , ShiftY ( GetY ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) ) ;
16583: LD_VAR 0 2
16587: PPUSH
16588: LD_VAR 0 3
16592: PUSH
16593: LD_INT 1
16595: ARRAY
16596: PPUSH
16597: CALL_OW 250
16601: PPUSH
16602: LD_VAR 0 3
16606: PUSH
16607: LD_INT 1
16609: ARRAY
16610: PPUSH
16611: CALL_OW 254
16615: PPUSH
16616: LD_INT 3
16618: PPUSH
16619: CALL_OW 272
16623: PPUSH
16624: LD_VAR 0 3
16628: PUSH
16629: LD_INT 1
16631: ARRAY
16632: PPUSH
16633: CALL_OW 251
16637: PPUSH
16638: LD_VAR 0 3
16642: PUSH
16643: LD_INT 1
16645: ARRAY
16646: PPUSH
16647: CALL_OW 254
16651: PPUSH
16652: LD_INT 3
16654: PPUSH
16655: CALL_OW 273
16659: PPUSH
16660: CALL_OW 111
// Wait ( 10 ) ;
16664: LD_INT 10
16666: PPUSH
16667: CALL_OW 67
// while HasTask ( un ) do
16671: LD_VAR 0 2
16675: PPUSH
16676: CALL_OW 314
16680: IFFALSE 16691
// begin Wait ( 10 ) ;
16682: LD_INT 10
16684: PPUSH
16685: CALL_OW 67
// end ;
16689: GO 16671
// if UnitsInside ( buildings [ 1 ] ) = 6 then
16691: LD_VAR 0 3
16695: PUSH
16696: LD_INT 1
16698: ARRAY
16699: PPUSH
16700: CALL_OW 313
16704: PUSH
16705: LD_INT 6
16707: EQUAL
16708: IFFALSE 16765
// begin ComExitBuilding ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) ;
16710: LD_VAR 0 3
16714: PUSH
16715: LD_INT 1
16717: ARRAY
16718: PPUSH
16719: CALL_OW 313
16723: PUSH
16724: LD_INT 1
16726: ARRAY
16727: PPUSH
16728: CALL_OW 122
// while HasTask ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) do
16732: LD_VAR 0 3
16736: PUSH
16737: LD_INT 1
16739: ARRAY
16740: PPUSH
16741: CALL_OW 313
16745: PUSH
16746: LD_INT 1
16748: ARRAY
16749: PPUSH
16750: CALL_OW 314
16754: IFFALSE 16765
// begin Wait ( 10 ) ;
16756: LD_INT 10
16758: PPUSH
16759: CALL_OW 67
// end ;
16763: GO 16732
// end ; ComEnterUnit ( un , buildings [ 1 ] ) ;
16765: LD_VAR 0 2
16769: PPUSH
16770: LD_VAR 0 3
16774: PUSH
16775: LD_INT 1
16777: ARRAY
16778: PPUSH
16779: CALL_OW 120
// Wait ( 1 ) ;
16783: LD_INT 1
16785: PPUSH
16786: CALL_OW 67
// AddComChangeProfession ( un , class_engineer ) ;
16790: LD_VAR 0 2
16794: PPUSH
16795: LD_INT 2
16797: PPUSH
16798: CALL_OW 183
// Wait ( 1 ) ;
16802: LD_INT 1
16804: PPUSH
16805: CALL_OW 67
// AddComExitBuilding ( un ) ;
16809: LD_VAR 0 2
16813: PPUSH
16814: CALL_OW 182
// Wait ( 1 ) ;
16818: LD_INT 1
16820: PPUSH
16821: CALL_OW 67
// end ; if GetCargo ( un , mat_oil ) = 0 then
16825: LD_VAR 0 2
16829: PPUSH
16830: LD_INT 2
16832: PPUSH
16833: CALL_OW 289
16837: PUSH
16838: LD_INT 0
16840: EQUAL
16841: IFFALSE 16864
// AddComTransport ( un , buildings [ 1 ] , mat_oil ) ;
16843: LD_VAR 0 2
16847: PPUSH
16848: LD_VAR 0 3
16852: PUSH
16853: LD_INT 1
16855: ARRAY
16856: PPUSH
16857: LD_INT 2
16859: PPUSH
16860: CALL_OW 211
// Wait ( 1 ) ;
16864: LD_INT 1
16866: PPUSH
16867: CALL_OW 67
// repeat Wait ( 0 0$1 ) until not HasTask ( un ) ;
16871: LD_INT 35
16873: PPUSH
16874: CALL_OW 67
16878: LD_VAR 0 2
16882: PPUSH
16883: CALL_OW 314
16887: NOT
16888: IFFALSE 16871
// if GetCargo ( un , mat_oil ) <> 0 then
16890: LD_VAR 0 2
16894: PPUSH
16895: LD_INT 2
16897: PPUSH
16898: CALL_OW 289
16902: PUSH
16903: LD_INT 0
16905: NONEQUAL
16906: IFFALSE 17024
// begin AddComMoveToArea ( un , BarrelAreas [ ShootAreaNr ] ) ;
16908: LD_VAR 0 2
16912: PPUSH
16913: LD_LOC 9
16917: PUSH
16918: LD_LOC 8
16922: ARRAY
16923: PPUSH
16924: CALL_OW 173
// Wait ( 1 ) ;
16928: LD_INT 1
16930: PPUSH
16931: CALL_OW 67
// AddComUnload ( un ) ;
16935: LD_VAR 0 2
16939: PPUSH
16940: CALL_OW 219
// Wait ( 1 ) ;
16944: LD_INT 1
16946: PPUSH
16947: CALL_OW 67
// AddComSailEvent ( un , un ) ;
16951: LD_VAR 0 2
16955: PPUSH
16956: LD_VAR 0 2
16960: PPUSH
16961: CALL_OW 224
// AddComMoveToArea ( un , StandAreas [ ShootAreaNr ] ) ;
16965: LD_VAR 0 2
16969: PPUSH
16970: LD_LOC 10
16974: PUSH
16975: LD_LOC 8
16979: ARRAY
16980: PPUSH
16981: CALL_OW 173
// Wait ( 1 ) ;
16985: LD_INT 1
16987: PPUSH
16988: CALL_OW 67
// ShootAreaNr := ShootAreaNr + 1 ;
16992: LD_ADDR_LOC 8
16996: PUSH
16997: LD_LOC 8
17001: PUSH
17002: LD_INT 1
17004: PLUS
17005: ST_TO_ADDR
// if ShootAreaNr = 6 then
17006: LD_LOC 8
17010: PUSH
17011: LD_INT 6
17013: EQUAL
17014: IFFALSE 17024
// ShootAreaNr := 1 ;
17016: LD_ADDR_LOC 8
17020: PUSH
17021: LD_INT 1
17023: ST_TO_ADDR
// end ; end ; end ;
17024: GO 16498
17026: POP
17027: POP
// end ; end ;
17028: PPOPN 3
17030: END
// every 0 0$0.1 + 0 0$0.05 marked 203 do var un , shoot_filter ;
17031: GO 17033
17033: DISABLE
17034: LD_INT 0
17036: PPUSH
17037: PPUSH
// begin shoot_filter := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_hastask ] , [ f_nation , nation_russian ] ] ) ;
17038: LD_ADDR_VAR 0 2
17042: PUSH
17043: LD_INT 11
17045: PPUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 1
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: LD_INT 25
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: PUSH
17066: LD_INT 60
17068: PUSH
17069: EMPTY
17070: LIST
17071: PUSH
17072: LD_INT 23
17074: PUSH
17075: LD_INT 3
17077: PUSH
17078: EMPTY
17079: LIST
17080: LIST
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: PPUSH
17088: CALL_OW 70
17092: ST_TO_ADDR
// if shoot_filter <> [ ] then
17093: LD_VAR 0 2
17097: PUSH
17098: EMPTY
17099: NONEQUAL
17100: IFFALSE 17216
// for un in shoot_filter do
17102: LD_ADDR_VAR 0 1
17106: PUSH
17107: LD_VAR 0 2
17111: PUSH
17112: FOR_IN
17113: IFFALSE 17214
// if GetTaskList ( un ) <> [ ] then
17115: LD_VAR 0 1
17119: PPUSH
17120: CALL_OW 437
17124: PUSH
17125: EMPTY
17126: NONEQUAL
17127: IFFALSE 17212
// if ( GetTaskList ( un ) [ 1 ] [ 1 ] = A ) and ( InArea ( GetTaskList ( un ) [ 1 ] [ 2 ] , GetTaskList ( un ) [ 1 ] [ 3 ] , ShootArea ) ) then
17129: LD_VAR 0 1
17133: PPUSH
17134: CALL_OW 437
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PUSH
17143: LD_INT 1
17145: ARRAY
17146: PUSH
17147: LD_STRING A
17149: EQUAL
17150: PUSH
17151: LD_VAR 0 1
17155: PPUSH
17156: CALL_OW 437
17160: PUSH
17161: LD_INT 1
17163: ARRAY
17164: PUSH
17165: LD_INT 2
17167: ARRAY
17168: PPUSH
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 437
17178: PUSH
17179: LD_INT 1
17181: ARRAY
17182: PUSH
17183: LD_INT 3
17185: ARRAY
17186: PPUSH
17187: LD_INT 11
17189: PPUSH
17190: CALL_OW 309
17194: AND
17195: IFFALSE 17212
// AddExperience ( un , skill_combat , 1 ) ;
17197: LD_VAR 0 1
17201: PPUSH
17202: LD_INT 1
17204: PPUSH
17205: LD_INT 1
17207: PPUSH
17208: CALL_OW 492
17212: GO 17112
17214: POP
17215: POP
// enable ;
17216: ENABLE
// end ;
17217: PPOPN 2
17219: END
// on SailEvent ( un ) do var x , y , i ;
17220: LD_INT 0
17222: PPUSH
17223: PPUSH
17224: PPUSH
// begin x := GetX ( un ) ;
17225: LD_ADDR_VAR 0 2
17229: PUSH
17230: LD_VAR 0 1
17234: PPUSH
17235: CALL_OW 250
17239: ST_TO_ADDR
// y := GetY ( un ) ;
17240: LD_ADDR_VAR 0 3
17244: PUSH
17245: LD_VAR 0 1
17249: PPUSH
17250: CALL_OW 251
17254: ST_TO_ADDR
// for i := 0 to 5 do
17255: LD_ADDR_VAR 0 4
17259: PUSH
17260: DOUBLE
17261: LD_INT 0
17263: DEC
17264: ST_TO_ADDR
17265: LD_INT 5
17267: PUSH
17268: FOR_TO
17269: IFFALSE 17365
// if HexInfo ( ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) = - 1 then
17271: LD_VAR 0 2
17275: PPUSH
17276: LD_VAR 0 4
17280: PPUSH
17281: LD_INT 1
17283: PPUSH
17284: CALL_OW 272
17288: PPUSH
17289: LD_VAR 0 3
17293: PPUSH
17294: LD_VAR 0 4
17298: PPUSH
17299: LD_INT 1
17301: PPUSH
17302: CALL_OW 273
17306: PPUSH
17307: CALL_OW 428
17311: PUSH
17312: LD_INT 1
17314: NEG
17315: EQUAL
17316: IFFALSE 17363
// AddComAttackPlace ( un , ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) ;
17318: LD_VAR 0 1
17322: PPUSH
17323: LD_VAR 0 2
17327: PPUSH
17328: LD_VAR 0 4
17332: PPUSH
17333: LD_INT 1
17335: PPUSH
17336: CALL_OW 272
17340: PPUSH
17341: LD_VAR 0 3
17345: PPUSH
17346: LD_VAR 0 4
17350: PPUSH
17351: LD_INT 1
17353: PPUSH
17354: CALL_OW 273
17358: PPUSH
17359: CALL_OW 176
17363: GO 17268
17365: POP
17366: POP
// end ; end_of_file
17367: PPOPN 4
17369: END
// every 0 0$1 marked 301 do var filter , x , y , d , lidi ;
17370: GO 17372
17372: DISABLE
17373: LD_INT 0
17375: PPUSH
17376: PPUSH
17377: PPUSH
17378: PPUSH
17379: PPUSH
// begin FreetimeAsked := true ;
17380: LD_ADDR_EXP 68
17384: PUSH
17385: LD_INT 1
17387: ST_TO_ADDR
// if not FreeTimeGranted and ( IsOK ( Petrovova ) or IsOK ( Kirilenkova ) or IsOK ( Kapitsova ) ) and ( IsOK ( Kuzmov ) or IsOK ( Gnyevko ) or IsOK ( Titov ) or IsOK ( Oblukov ) ) then
17388: LD_EXP 59
17392: NOT
17393: PUSH
17394: LD_EXP 21
17398: PPUSH
17399: CALL_OW 302
17403: PUSH
17404: LD_EXP 4
17408: PPUSH
17409: CALL_OW 302
17413: OR
17414: PUSH
17415: LD_EXP 6
17419: PPUSH
17420: CALL_OW 302
17424: OR
17425: AND
17426: PUSH
17427: LD_EXP 10
17431: PPUSH
17432: CALL_OW 302
17436: PUSH
17437: LD_EXP 5
17441: PPUSH
17442: CALL_OW 302
17446: OR
17447: PUSH
17448: LD_EXP 18
17452: PPUSH
17453: CALL_OW 302
17457: OR
17458: PUSH
17459: LD_EXP 19
17463: PPUSH
17464: CALL_OW 302
17468: OR
17469: AND
17470: IFFALSE 17934
// begin D_FreeTime ;
17472: CALL 6292 0 0
// case Query ( QFreeTime ) of 1 :
17476: LD_STRING QFreeTime
17478: PPUSH
17479: CALL_OW 97
17483: PUSH
17484: LD_INT 1
17486: DOUBLE
17487: EQUAL
17488: IFTRUE 17492
17490: GO 17918
17492: POP
// begin FreeTimeGranted := true ;
17493: LD_ADDR_EXP 59
17497: PUSH
17498: LD_INT 1
17500: ST_TO_ADDR
// D_QrFreeTime1 ;
17501: CALL 6759 0 0
// ComExitVehicle ( [ FreeMan , FreeWoman ] ) ;
17505: LD_EXP 57
17509: PUSH
17510: LD_EXP 58
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PPUSH
17519: CALL_OW 121
// SetSide ( [ FreeMan , FreeWoman ] , ally ) ;
17523: LD_EXP 57
17527: PUSH
17528: LD_EXP 58
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: PPUSH
17537: LD_EXP 32
17541: PPUSH
17542: CALL_OW 235
// ComMoveXY ( [ FreeMan , FreeWoman ] , 115 , 32 ) ;
17546: LD_EXP 57
17550: PUSH
17551: LD_EXP 58
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PPUSH
17560: LD_INT 115
17562: PPUSH
17563: LD_INT 32
17565: PPUSH
17566: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
17570: LD_INT 35
17572: PPUSH
17573: CALL_OW 67
// lidi := FilterUnitsInArea ( HandOverEnterArea , [ f_side , ally ] ) ;
17577: LD_ADDR_VAR 0 5
17581: PUSH
17582: LD_INT 6
17584: PPUSH
17585: LD_INT 22
17587: PUSH
17588: LD_EXP 32
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: PPUSH
17597: CALL_OW 70
17601: ST_TO_ADDR
// until ( 0 + lidi ) = 2 ;
17602: LD_INT 0
17604: PUSH
17605: LD_VAR 0 5
17609: PLUS
17610: PUSH
17611: LD_INT 2
17613: EQUAL
17614: IFFALSE 17570
// RemoveUnit ( FreeMan ) ;
17616: LD_EXP 57
17620: PPUSH
17621: CALL_OW 64
// RemoveUnit ( FreeWoman ) ;
17625: LD_EXP 58
17629: PPUSH
17630: CALL_OW 64
// Wait ( 3 3$0 ) ;
17634: LD_INT 6300
17636: PPUSH
17637: CALL_OW 67
// PlaceUnitArea ( FreeMan , HandOverEnterArea , false ) ;
17641: LD_EXP 57
17645: PPUSH
17646: LD_INT 6
17648: PPUSH
17649: LD_INT 0
17651: PPUSH
17652: CALL_OW 49
// PlaceUnitArea ( FreeWoman , HandOverEnterArea , false ) ;
17656: LD_EXP 58
17660: PPUSH
17661: LD_INT 6
17663: PPUSH
17664: LD_INT 0
17666: PPUSH
17667: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
17671: LD_ADDR_VAR 0 1
17675: PUSH
17676: LD_INT 22
17678: PUSH
17679: LD_EXP 31
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PUSH
17688: LD_INT 2
17690: PUSH
17691: LD_INT 30
17693: PUSH
17694: LD_INT 0
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: PUSH
17701: LD_INT 30
17703: PUSH
17704: LD_INT 1
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: LIST
17715: PUSH
17716: EMPTY
17717: LIST
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: PPUSH
17723: CALL_OW 69
17727: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
17728: LD_INT 0
17730: PUSH
17731: LD_VAR 0 1
17735: PLUS
17736: PUSH
17737: LD_INT 0
17739: NONEQUAL
17740: IFFALSE 17801
// begin x := GetX ( filter [ 1 ] ) ;
17742: LD_ADDR_VAR 0 2
17746: PUSH
17747: LD_VAR 0 1
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 250
17760: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
17761: LD_ADDR_VAR 0 3
17765: PUSH
17766: LD_VAR 0 1
17770: PUSH
17771: LD_INT 1
17773: ARRAY
17774: PPUSH
17775: CALL_OW 251
17779: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
17780: LD_ADDR_VAR 0 4
17784: PUSH
17785: LD_VAR 0 1
17789: PUSH
17790: LD_INT 1
17792: ARRAY
17793: PPUSH
17794: CALL_OW 254
17798: ST_TO_ADDR
// end else
17799: GO 17839
// begin x := GetX ( Burlak ) ;
17801: LD_ADDR_VAR 0 2
17805: PUSH
17806: LD_EXP 1
17810: PPUSH
17811: CALL_OW 250
17815: ST_TO_ADDR
// y := GetY ( Burlak ) ;
17816: LD_ADDR_VAR 0 3
17820: PUSH
17821: LD_EXP 1
17825: PPUSH
17826: CALL_OW 251
17830: ST_TO_ADDR
// d := 1 ;
17831: LD_ADDR_VAR 0 4
17835: PUSH
17836: LD_INT 1
17838: ST_TO_ADDR
// end ; ComMoveXY ( [ FreeMan , FreeWoman ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
17839: LD_EXP 57
17843: PUSH
17844: LD_EXP 58
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: PPUSH
17853: LD_VAR 0 2
17857: PPUSH
17858: LD_VAR 0 4
17862: PPUSH
17863: LD_INT 5
17865: PPUSH
17866: CALL_OW 272
17870: PPUSH
17871: LD_VAR 0 3
17875: PPUSH
17876: LD_VAR 0 4
17880: PPUSH
17881: LD_INT 5
17883: PPUSH
17884: CALL_OW 273
17888: PPUSH
17889: CALL_OW 111
// SetSide ( [ FreeMan , FreeWoman ] , you ) ;
17893: LD_EXP 57
17897: PUSH
17898: LD_EXP 58
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PPUSH
17907: LD_EXP 31
17911: PPUSH
17912: CALL_OW 235
// end ; 2 :
17916: GO 17934
17918: LD_INT 2
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17933
17926: POP
// D_QrFreeTime2 ; end ;
17927: CALL 6779 0 0
17931: GO 17934
17933: POP
// end ; end ; end_of_file
17934: PPOPN 5
17936: END
// export firstQuery , secondQuery , dec , isShowingQuery ; every 0 0$1 marked 401 do
17937: GO 17939
17939: DISABLE
// begin MashaAsked := true ;
17940: LD_ADDR_EXP 70
17944: PUSH
17945: LD_INT 1
17947: ST_TO_ADDR
// D_Masha ;
17948: CALL 6799 0 0
// Query ( QMasha ) ;
17952: LD_STRING QMasha
17954: PPUSH
17955: CALL_OW 97
// D_Masha2 ;
17959: CALL 6827 0 0
// ChangeMissionObjectives ( MMasha ) ;
17963: LD_STRING MMasha
17965: PPUSH
17966: CALL_OW 337
// enable ( 402 ) ;
17970: LD_INT 402
17972: ENABLE_MARKED
// firstQuery = 1 ;
17973: LD_ADDR_EXP 96
17977: PUSH
17978: LD_INT 1
17980: ST_TO_ADDR
// secondQuery = 0 ;
17981: LD_ADDR_EXP 97
17985: PUSH
17986: LD_INT 0
17988: ST_TO_ADDR
// isShowingQuery = 0 ;
17989: LD_ADDR_EXP 99
17993: PUSH
17994: LD_INT 0
17996: ST_TO_ADDR
// end ;
17997: END
// var BurlakTimeInVehicle , QMashaQueryShown , QMashaQueryRefused , BurlakWasInVehicle , BurlakNewVehicle , BurlakOldVehicle ; every 0 0$3 marked 402 do
17998: GO 18000
18000: DISABLE
// begin if GetType ( IsInUnit ( Burlak ) ) = unit_vehicle and isShowingQuery = 0 then
18001: LD_EXP 1
18005: PPUSH
18006: CALL_OW 310
18010: PPUSH
18011: CALL_OW 247
18015: PUSH
18016: LD_INT 2
18018: EQUAL
18019: PUSH
18020: LD_EXP 99
18024: PUSH
18025: LD_INT 0
18027: EQUAL
18028: AND
18029: IFFALSE 18471
// if GetWeapon ( IsInUnit ( Burlak ) ) = 42 or GetWeapon ( IsInUnit ( Burlak ) ) = 43 or GetWeapon ( IsInUnit ( Burlak ) ) = 44 or GetWeapon ( IsInUnit ( Burlak ) ) = 45 or GetWeapon ( IsInUnit ( Burlak ) ) = 46 then
18031: LD_EXP 1
18035: PPUSH
18036: CALL_OW 310
18040: PPUSH
18041: CALL_OW 264
18045: PUSH
18046: LD_INT 42
18048: EQUAL
18049: PUSH
18050: LD_EXP 1
18054: PPUSH
18055: CALL_OW 310
18059: PPUSH
18060: CALL_OW 264
18064: PUSH
18065: LD_INT 43
18067: EQUAL
18068: OR
18069: PUSH
18070: LD_EXP 1
18074: PPUSH
18075: CALL_OW 310
18079: PPUSH
18080: CALL_OW 264
18084: PUSH
18085: LD_INT 44
18087: EQUAL
18088: OR
18089: PUSH
18090: LD_EXP 1
18094: PPUSH
18095: CALL_OW 310
18099: PPUSH
18100: CALL_OW 264
18104: PUSH
18105: LD_INT 45
18107: EQUAL
18108: OR
18109: PUSH
18110: LD_EXP 1
18114: PPUSH
18115: CALL_OW 310
18119: PPUSH
18120: CALL_OW 264
18124: PUSH
18125: LD_INT 46
18127: EQUAL
18128: OR
18129: IFFALSE 18471
// begin isShowingQuery = 1 ;
18131: LD_ADDR_EXP 99
18135: PUSH
18136: LD_INT 1
18138: ST_TO_ADDR
// if secondQuery = 1 and firstQuery = 0 then
18139: LD_EXP 97
18143: PUSH
18144: LD_INT 1
18146: EQUAL
18147: PUSH
18148: LD_EXP 96
18152: PUSH
18153: LD_INT 0
18155: EQUAL
18156: AND
18157: IFFALSE 18297
// begin dec = Query ( QMashaQuery2 ) ;
18159: LD_ADDR_EXP 98
18163: PUSH
18164: LD_STRING QMashaQuery2
18166: PPUSH
18167: CALL_OW 97
18171: ST_TO_ADDR
// if dec = 1 then
18172: LD_EXP 98
18176: PUSH
18177: LD_INT 1
18179: EQUAL
18180: IFFALSE 18270
// begin disable ;
18182: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18183: LD_ADDR_EXP 60
18187: PUSH
18188: LD_EXP 1
18192: PPUSH
18193: CALL_OW 310
18197: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18198: LD_EXP 60
18202: PPUSH
18203: LD_INT 1
18205: PPUSH
18206: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18210: LD_EXP 60
18214: PPUSH
18215: CALL_OW 265
18219: PUSH
18220: LD_EXP 60
18224: PPUSH
18225: CALL_OW 262
18229: PUSH
18230: LD_EXP 60
18234: PPUSH
18235: CALL_OW 263
18239: PUSH
18240: LD_EXP 60
18244: PPUSH
18245: CALL_OW 264
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: PPUSH
18256: LD_STRING Masha
18258: PPUSH
18259: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18263: LD_STRING MMashaDone
18265: PPUSH
18266: CALL_OW 337
// end ; if dec = 2 then
18270: LD_EXP 98
18274: PUSH
18275: LD_INT 2
18277: EQUAL
18278: IFFALSE 18297
// begin ComExitVehicle ( Burlak ) ;
18280: LD_EXP 1
18284: PPUSH
18285: CALL_OW 121
// isShowingQuery = 0 ;
18289: LD_ADDR_EXP 99
18293: PUSH
18294: LD_INT 0
18296: ST_TO_ADDR
// end ; end ; if firstQuery = 1 and secondQuery = 0 then
18297: LD_EXP 96
18301: PUSH
18302: LD_INT 1
18304: EQUAL
18305: PUSH
18306: LD_EXP 97
18310: PUSH
18311: LD_INT 0
18313: EQUAL
18314: AND
18315: IFFALSE 18471
// begin dec = Query ( QMashaQuery ) ;
18317: LD_ADDR_EXP 98
18321: PUSH
18322: LD_STRING QMashaQuery
18324: PPUSH
18325: CALL_OW 97
18329: ST_TO_ADDR
// if dec = 1 then
18330: LD_EXP 98
18334: PUSH
18335: LD_INT 1
18337: EQUAL
18338: IFFALSE 18428
// begin disable ;
18340: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18341: LD_ADDR_EXP 60
18345: PUSH
18346: LD_EXP 1
18350: PPUSH
18351: CALL_OW 310
18355: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18356: LD_EXP 60
18360: PPUSH
18361: LD_INT 1
18363: PPUSH
18364: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18368: LD_EXP 60
18372: PPUSH
18373: CALL_OW 265
18377: PUSH
18378: LD_EXP 60
18382: PPUSH
18383: CALL_OW 262
18387: PUSH
18388: LD_EXP 60
18392: PPUSH
18393: CALL_OW 263
18397: PUSH
18398: LD_EXP 60
18402: PPUSH
18403: CALL_OW 264
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: PPUSH
18414: LD_STRING Masha
18416: PPUSH
18417: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18421: LD_STRING MMashaDone
18423: PPUSH
18424: CALL_OW 337
// end ; if dec = 2 then
18428: LD_EXP 98
18432: PUSH
18433: LD_INT 2
18435: EQUAL
18436: IFFALSE 18471
// begin ComExitVehicle ( Burlak ) ;
18438: LD_EXP 1
18442: PPUSH
18443: CALL_OW 121
// firstQuery = 0 ;
18447: LD_ADDR_EXP 96
18451: PUSH
18452: LD_INT 0
18454: ST_TO_ADDR
// secondQuery = 1 ;
18455: LD_ADDR_EXP 97
18459: PUSH
18460: LD_INT 1
18462: ST_TO_ADDR
// isShowingQuery = 0 ;
18463: LD_ADDR_EXP 99
18467: PUSH
18468: LD_INT 0
18470: ST_TO_ADDR
// end ; end ; end ; enable ;
18471: ENABLE
// end ; end_of_file
18472: END
// var amcount ; export function prepare_am_attack ; var rndclass , rndlevel , i ; begin
18473: LD_INT 0
18475: PPUSH
18476: PPUSH
18477: PPUSH
18478: PPUSH
// if MercPaid then
18479: LD_EXP 39
18483: IFFALSE 18497
// amcount := weaker else
18485: LD_ADDR_LOC 17
18489: PUSH
18490: LD_EXP 75
18494: ST_TO_ADDR
18495: GO 18507
// amcount := stronger ;
18497: LD_ADDR_LOC 17
18501: PUSH
18502: LD_EXP 76
18506: ST_TO_ADDR
// for i := 1 to amcount do
18507: LD_ADDR_VAR 0 4
18511: PUSH
18512: DOUBLE
18513: LD_INT 1
18515: DEC
18516: ST_TO_ADDR
18517: LD_LOC 17
18521: PUSH
18522: FOR_TO
18523: IFFALSE 18676
// begin uc_side := usa ;
18525: LD_ADDR_OWVAR 20
18529: PUSH
18530: LD_EXP 35
18534: ST_TO_ADDR
// uc_nation := nation_american ;
18535: LD_ADDR_OWVAR 21
18539: PUSH
18540: LD_INT 1
18542: ST_TO_ADDR
// rndclass := Rand ( 1 , 3 ) ;
18543: LD_ADDR_VAR 0 2
18547: PUSH
18548: LD_INT 1
18550: PPUSH
18551: LD_INT 3
18553: PPUSH
18554: CALL_OW 12
18558: ST_TO_ADDR
// case rndclass of 1 :
18559: LD_VAR 0 2
18563: PUSH
18564: LD_INT 1
18566: DOUBLE
18567: EQUAL
18568: IFTRUE 18572
18570: GO 18590
18572: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; 2 :
18573: LD_INT 0
18575: PPUSH
18576: LD_INT 1
18578: PPUSH
18579: LD_EXP 74
18583: PPUSH
18584: CALL_OW 380
18588: GO 18643
18590: LD_INT 2
18592: DOUBLE
18593: EQUAL
18594: IFTRUE 18598
18596: GO 18616
18598: POP
// PrepareHuman ( 0 , class_sniper , am_attack_skill ) ; 3 :
18599: LD_INT 0
18601: PPUSH
18602: LD_INT 5
18604: PPUSH
18605: LD_EXP 74
18609: PPUSH
18610: CALL_OW 380
18614: GO 18643
18616: LD_INT 3
18618: DOUBLE
18619: EQUAL
18620: IFTRUE 18624
18622: GO 18642
18624: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; end ;
18625: LD_INT 0
18627: PPUSH
18628: LD_INT 1
18630: PPUSH
18631: LD_EXP 74
18635: PPUSH
18636: CALL_OW 380
18640: GO 18643
18642: POP
// hc_name :=  ;
18643: LD_ADDR_OWVAR 26
18647: PUSH
18648: LD_STRING 
18650: ST_TO_ADDR
// amattack := amattack ^ CreateHuman ;
18651: LD_ADDR_EXP 27
18655: PUSH
18656: LD_EXP 27
18660: PUSH
18661: CALL_OW 44
18665: ADD
18666: ST_TO_ADDR
// Wait ( 1 ) ;
18667: LD_INT 1
18669: PPUSH
18670: CALL_OW 67
// end ;
18674: GO 18522
18676: POP
18677: POP
// end ;
18678: LD_VAR 0 1
18682: RET
// function place_am_attack ; var i , reg_id ; begin
18683: LD_INT 0
18685: PPUSH
18686: PPUSH
18687: PPUSH
// for i := 1 to amcount do
18688: LD_ADDR_VAR 0 2
18692: PUSH
18693: DOUBLE
18694: LD_INT 1
18696: DEC
18697: ST_TO_ADDR
18698: LD_LOC 17
18702: PUSH
18703: FOR_TO
18704: IFFALSE 18736
// begin PlaceUnitArea ( amattack [ i ] , AmEnterArea , false ) ;
18706: LD_EXP 27
18710: PUSH
18711: LD_VAR 0 2
18715: ARRAY
18716: PPUSH
18717: LD_INT 9
18719: PPUSH
18720: LD_INT 0
18722: PPUSH
18723: CALL_OW 49
// Wait ( 1 ) ;
18727: LD_INT 1
18729: PPUSH
18730: CALL_OW 67
// end ;
18734: GO 18703
18736: POP
18737: POP
// reg_id := McRegistry ( usa , [ [ mc_reg_area_to_guard , WholeMapArea ] , - mc_reg_only_important , mc_reg_ignore_fog ] ) ;
18738: LD_ADDR_VAR 0 3
18742: PUSH
18743: LD_EXP 35
18747: PPUSH
18748: LD_INT 2
18750: PUSH
18751: LD_INT 10
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 8
18760: NEG
18761: PUSH
18762: LD_INT 7
18764: PUSH
18765: EMPTY
18766: LIST
18767: LIST
18768: LIST
18769: PPUSH
18770: CALL_OW 399
18774: ST_TO_ADDR
// McAttack ( 100 , reg_id , amattack , [ mc_no_stop , mc_pat_aggresive , mc_murder ] ) ;
18775: LD_INT 100
18777: PPUSH
18778: LD_VAR 0 3
18782: PPUSH
18783: LD_EXP 27
18787: PPUSH
18788: LD_INT 10
18790: PUSH
18791: LD_INT 11
18793: PUSH
18794: LD_INT 12
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: PPUSH
18802: CALL_OW 402
// end ;
18806: LD_VAR 0 1
18810: RET
// every 0 0$1 marked 501 do
18811: GO 18813
18813: DISABLE
// begin AmAttackStarted := true ;
18814: LD_ADDR_EXP 71
18818: PUSH
18819: LD_INT 1
18821: ST_TO_ADDR
// D_AmAttackStart ;
18822: CALL 7063 0 0
// Wait ( 0 0$15 ) ;
18826: LD_INT 525
18828: PPUSH
18829: CALL_OW 67
// place_am_attack ;
18833: CALL 18683 0 0
// enable ( 502 ) ;
18837: LD_INT 502
18839: ENABLE_MARKED
// end ;
18840: END
// every 0 0$10 marked 502 do
18841: GO 18843
18843: DISABLE
// begin if amattack = [ ] then
18844: LD_EXP 27
18848: PUSH
18849: EMPTY
18850: EQUAL
18851: IFFALSE 18868
// begin disable ;
18853: DISABLE
// AmAttackDone := true ;
18854: LD_ADDR_EXP 64
18858: PUSH
18859: LD_INT 1
18861: ST_TO_ADDR
// D_AmAttackFin ;
18862: CALL 7152 0 0
// end else
18866: GO 18869
// enable ;
18868: ENABLE
// end ; end_of_file
18869: END
// every 0 0$2 + 0 0$0.1 do
18870: GO 18872
18872: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
18873: LD_INT 22
18875: PUSH
18876: LD_INT 3
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: PUSH
18883: LD_INT 2
18885: PUSH
18886: LD_INT 25
18888: PUSH
18889: LD_INT 12
18891: PUSH
18892: EMPTY
18893: LIST
18894: LIST
18895: PUSH
18896: LD_INT 25
18898: PUSH
18899: LD_INT 16
18901: PUSH
18902: EMPTY
18903: LIST
18904: LIST
18905: PUSH
18906: LD_INT 25
18908: PUSH
18909: LD_INT 15
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PUSH
18916: LD_INT 25
18918: PUSH
18919: LD_INT 17
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: PUSH
18933: EMPTY
18934: LIST
18935: LIST
18936: PPUSH
18937: CALL_OW 69
18941: PUSH
18942: LD_INT 22
18944: PUSH
18945: LD_INT 3
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: PUSH
18952: LD_INT 21
18954: PUSH
18955: LD_INT 1
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: PUSH
18962: LD_INT 3
18964: PUSH
18965: LD_INT 2
18967: PUSH
18968: LD_INT 25
18970: PUSH
18971: LD_INT 12
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: PUSH
18978: LD_INT 25
18980: PUSH
18981: LD_INT 16
18983: PUSH
18984: EMPTY
18985: LIST
18986: LIST
18987: PUSH
18988: LD_INT 25
18990: PUSH
18991: LD_INT 15
18993: PUSH
18994: EMPTY
18995: LIST
18996: LIST
18997: PUSH
18998: LD_INT 25
19000: PUSH
19001: LD_INT 17
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: EMPTY
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: PUSH
19015: EMPTY
19016: LIST
19017: LIST
19018: PUSH
19019: EMPTY
19020: LIST
19021: LIST
19022: LIST
19023: PPUSH
19024: CALL_OW 69
19028: GREATER
19029: IFFALSE 19040
// begin SetAchievement ( ACH_POTA ) ;
19031: LD_STRING ACH_POTA
19033: PPUSH
19034: CALL_OW 543
// exit ;
19038: GO 19041
// end ; enable ;
19040: ENABLE
// end ;
19041: END
// export function SA_OnLegionHandoverToUPF ; begin
19042: LD_INT 0
19044: PPUSH
// SetAchievement ( ACH_SC ) ;
19045: LD_STRING ACH_SC
19047: PPUSH
19048: CALL_OW 543
// end ;
19052: LD_VAR 0 1
19056: RET
// export function SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ; begin
19057: LD_INT 0
19059: PPUSH
// SetAchievement ( ACH_GAME ) ;
19060: LD_STRING ACH_GAME
19062: PPUSH
19063: CALL_OW 543
// end ;
19067: LD_VAR 0 1
19071: RET

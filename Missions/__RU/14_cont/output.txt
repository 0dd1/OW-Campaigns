// export side_Neutral , side_Ru , side_Ar , side_Le , side_Upr ; export Burlak ; export Belkov , Gnyevko , Kirilenkova ; export Kovalyuk , Scholtze ; export Kuzmov ; export Karamazov , Petrovova , Gleb , Petrosyan ; export Lipshchin , Titov , Dolgov , Xavier ; export Oblukov , Kozlov , Kapitsova ; export Ostatni ; export Masha ; export Gladkov , GladkovFake ; export Heike , Farmer , Bergkamp ; export Abdul , Omar ; export MercPaid , MercAccepted , MercHandedOver , BehemothSeen ; export HeikeKilled , OmarKilled ; export Rusove , Rusove2 ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 31
// Result = CreateCharacter ( Ident ) else
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
  29: GO 46
// Result = NewCharacter ( Ident ) ;
  31: LD_ADDR_VAR 0 2
  35: PUSH
  36: LD_VAR 0 1
  40: PPUSH
  41: CALL_OW 25
  45: ST_TO_ADDR
// end ;
  46: LD_VAR 0 2
  50: RET
// function load_set ( Ident ) ; begin
  51: LD_INT 0
  53: PPUSH
// if TestCharacters ( Ident ) then
  54: LD_VAR 0 1
  58: PPUSH
  59: CALL_OW 28
  63: IFFALSE 82
// Result = CreateCharacterSet ( Ident ) else
  65: LD_ADDR_VAR 0 2
  69: PUSH
  70: LD_VAR 0 1
  74: PPUSH
  75: CALL_OW 31
  79: ST_TO_ADDR
  80: GO 89
// Result = [ ] ;
  82: LD_ADDR_VAR 0 2
  86: PUSH
  87: EMPTY
  88: ST_TO_ADDR
// end ;
  89: LD_VAR 0 2
  93: RET
// function vytvor_gladkova ; begin
  94: LD_INT 0
  96: PPUSH
// UC_Nation = NATION_RUSSIAN ;
  97: LD_ADDR_OWVAR 21
 101: PUSH
 102: LD_INT 3
 104: ST_TO_ADDR
// UC_side = side_Ru ;
 105: LD_ADDR_OWVAR 20
 109: PUSH
 110: LD_EXP 2
 114: ST_TO_ADDR
// HC_name =  ;
 115: LD_ADDR_OWVAR 26
 119: PUSH
 120: LD_STRING 
 122: ST_TO_ADDR
// HC_sex = SEX_MALE ;
 123: LD_ADDR_OWVAR 27
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 131: LD_ADDR_OWVAR 28
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// PrepareSoldierSkills ( 7 ) ;
 139: LD_INT 7
 141: PPUSH
 142: CALL_OW 375
// Result = CreateHuman ;
 146: LD_ADDR_VAR 0 1
 150: PUSH
 151: CALL_OW 44
 155: ST_TO_ADDR
// end ;
 156: LD_VAR 0 1
 160: RET
// function load ; var MashaSpec ; begin
 161: LD_INT 0
 163: PPUSH
 164: PPUSH
// AutoEnemy = false ;
 165: LD_ADDR_OWVAR 74
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// MercPaid = LoadVariable ( MercPaid , false ) ;
 173: LD_ADDR_EXP 33
 177: PUSH
 178: LD_STRING MercPaid
 180: PPUSH
 181: LD_INT 0
 183: PPUSH
 184: CALL_OW 30
 188: ST_TO_ADDR
// MercAccepted = LoadVariable ( MercAccepted , false ) ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_STRING MercAccepted
 196: PPUSH
 197: LD_INT 0
 199: PPUSH
 200: CALL_OW 30
 204: ST_TO_ADDR
// MercHandedOver = LoadVariable ( MercHandedOver , false ) ;
 205: LD_ADDR_EXP 35
 209: PUSH
 210: LD_STRING MercHandedOver
 212: PPUSH
 213: LD_INT 0
 215: PPUSH
 216: CALL_OW 30
 220: ST_TO_ADDR
// BehemothSeen = LoadVariable ( BehemothSeen , false ) ;
 221: LD_ADDR_EXP 36
 225: PUSH
 226: LD_STRING BehemothSeen
 228: PPUSH
 229: LD_INT 0
 231: PPUSH
 232: CALL_OW 30
 236: ST_TO_ADDR
// HeikeKilled = LoadVariable ( HeikeKilled , false ) ;
 237: LD_ADDR_EXP 37
 241: PUSH
 242: LD_STRING HeikeKilled
 244: PPUSH
 245: LD_INT 0
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// OmarKilled = LoadVariable ( OmarKilled , false ) ;
 253: LD_ADDR_EXP 38
 257: PUSH
 258: LD_STRING OmarKilled
 260: PPUSH
 261: LD_INT 0
 263: PPUSH
 264: CALL_OW 30
 268: ST_TO_ADDR
// UC_Side = side_Le ;
 269: LD_ADDR_OWVAR 20
 273: PUSH
 274: LD_EXP 4
 278: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 2
 286: ST_TO_ADDR
// Heike = load_char ( Heike ) ;
 287: LD_ADDR_EXP 28
 291: PUSH
 292: LD_STRING Heike
 294: PPUSH
 295: CALL 0 0 1
 299: ST_TO_ADDR
// Farmer = load_char ( Farmer ) ;
 300: LD_ADDR_EXP 29
 304: PUSH
 305: LD_STRING Farmer
 307: PPUSH
 308: CALL 0 0 1
 312: ST_TO_ADDR
// Bergkamp = load_char ( Bergkamp ) ;
 313: LD_ADDR_EXP 30
 317: PUSH
 318: LD_STRING Bergkamp
 320: PPUSH
 321: CALL 0 0 1
 325: ST_TO_ADDR
// UC_Side = side_Ar ;
 326: LD_ADDR_OWVAR 20
 330: PUSH
 331: LD_EXP 3
 335: ST_TO_ADDR
// Abdul = load_char ( Abdul ) ;
 336: LD_ADDR_EXP 31
 340: PUSH
 341: LD_STRING Abdul
 343: PPUSH
 344: CALL 0 0 1
 348: ST_TO_ADDR
// if not OmarKilled then
 349: LD_EXP 38
 353: NOT
 354: IFFALSE 369
// Omar = load_char ( Omar ) ;
 356: LD_ADDR_EXP 32
 360: PUSH
 361: LD_STRING Omar
 363: PPUSH
 364: CALL 0 0 1
 368: ST_TO_ADDR
// UC_Side = side_Ru ;
 369: LD_ADDR_OWVAR 20
 373: PUSH
 374: LD_EXP 2
 378: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// Gladkov = load_char ( Gladkov ) ;
 387: LD_ADDR_EXP 26
 391: PUSH
 392: LD_STRING Gladkov
 394: PPUSH
 395: CALL 0 0 1
 399: ST_TO_ADDR
// if not Gladkov then
 400: LD_EXP 26
 404: NOT
 405: IFFALSE 417
// GladkovFake = vytvor_gladkova ;
 407: LD_ADDR_EXP 27
 411: PUSH
 412: CALL 94 0 0
 416: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 417: LD_ADDR_EXP 6
 421: PUSH
 422: LD_STRING Burlak
 424: PPUSH
 425: CALL 0 0 1
 429: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 430: LD_STRING GlebLoc
 432: PPUSH
 433: LD_INT 0
 435: PPUSH
 436: CALL_OW 30
 440: PUSH
 441: LD_INT 14
 443: EQUAL
 444: IFFALSE 459
// Gleb = load_char ( Gleb ) ;
 446: LD_ADDR_EXP 15
 450: PUSH
 451: LD_STRING Gleb
 453: PPUSH
 454: CALL 0 0 1
 458: ST_TO_ADDR
// if LoadVariable ( BelkovLoc , 0 ) = 14 then
 459: LD_STRING BelkovLoc
 461: PPUSH
 462: LD_INT 0
 464: PPUSH
 465: CALL_OW 30
 469: PUSH
 470: LD_INT 14
 472: EQUAL
 473: IFFALSE 488
// Belkov = load_char ( Belkov ) ;
 475: LD_ADDR_EXP 7
 479: PUSH
 480: LD_STRING Belkov
 482: PPUSH
 483: CALL 0 0 1
 487: ST_TO_ADDR
// if LoadVariable ( GnyevkoLoc , 0 ) = 14 then
 488: LD_STRING GnyevkoLoc
 490: PPUSH
 491: LD_INT 0
 493: PPUSH
 494: CALL_OW 30
 498: PUSH
 499: LD_INT 14
 501: EQUAL
 502: IFFALSE 517
// Gnyevko = load_char ( Gnyevko ) ;
 504: LD_ADDR_EXP 8
 508: PUSH
 509: LD_STRING Gnyevko
 511: PPUSH
 512: CALL 0 0 1
 516: ST_TO_ADDR
// if LoadVariable ( KirilenkovaLoc , 0 ) = 14 then
 517: LD_STRING KirilenkovaLoc
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL_OW 30
 527: PUSH
 528: LD_INT 14
 530: EQUAL
 531: IFFALSE 546
// Kirilenkova = load_char ( Kirilenkova ) ;
 533: LD_ADDR_EXP 9
 537: PUSH
 538: LD_STRING Kirilenkova
 540: PPUSH
 541: CALL 0 0 1
 545: ST_TO_ADDR
// if LoadVariable ( KovalyukLoc , 0 ) = 14 then
 546: LD_STRING KovalyukLoc
 548: PPUSH
 549: LD_INT 0
 551: PPUSH
 552: CALL_OW 30
 556: PUSH
 557: LD_INT 14
 559: EQUAL
 560: IFFALSE 575
// Kovalyuk = load_char ( Kovalyuk ) ;
 562: LD_ADDR_EXP 10
 566: PUSH
 567: LD_STRING Kovalyuk
 569: PPUSH
 570: CALL 0 0 1
 574: ST_TO_ADDR
// if LoadVariable ( ScholtzeLoc , 0 ) = 14 then
 575: LD_STRING ScholtzeLoc
 577: PPUSH
 578: LD_INT 0
 580: PPUSH
 581: CALL_OW 30
 585: PUSH
 586: LD_INT 14
 588: EQUAL
 589: IFFALSE 604
// Scholtze = load_char ( Scholtze ) ;
 591: LD_ADDR_EXP 11
 595: PUSH
 596: LD_STRING Scholtze
 598: PPUSH
 599: CALL 0 0 1
 603: ST_TO_ADDR
// if LoadVariable ( KuzmovLoc , 0 ) = 14 then
 604: LD_STRING KuzmovLoc
 606: PPUSH
 607: LD_INT 0
 609: PPUSH
 610: CALL_OW 30
 614: PUSH
 615: LD_INT 14
 617: EQUAL
 618: IFFALSE 633
// Kuzmov = load_char ( Kuzmov ) ;
 620: LD_ADDR_EXP 12
 624: PUSH
 625: LD_STRING Kuzmov
 627: PPUSH
 628: CALL 0 0 1
 632: ST_TO_ADDR
// if LoadVariable ( KaramazovLoc , 0 ) = 14 then
 633: LD_STRING KaramazovLoc
 635: PPUSH
 636: LD_INT 0
 638: PPUSH
 639: CALL_OW 30
 643: PUSH
 644: LD_INT 14
 646: EQUAL
 647: IFFALSE 662
// Karamazov = load_char ( Karamazov ) ;
 649: LD_ADDR_EXP 13
 653: PUSH
 654: LD_STRING Karamazov
 656: PPUSH
 657: CALL 0 0 1
 661: ST_TO_ADDR
// if LoadVariable ( PetrovovaLoc , 0 ) = 14 then
 662: LD_STRING PetrovovaLoc
 664: PPUSH
 665: LD_INT 0
 667: PPUSH
 668: CALL_OW 30
 672: PUSH
 673: LD_INT 14
 675: EQUAL
 676: IFFALSE 691
// Petrovova = load_char ( Petrovova ) ;
 678: LD_ADDR_EXP 14
 682: PUSH
 683: LD_STRING Petrovova
 685: PPUSH
 686: CALL 0 0 1
 690: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 691: LD_STRING GlebLoc
 693: PPUSH
 694: LD_INT 0
 696: PPUSH
 697: CALL_OW 30
 701: PUSH
 702: LD_INT 14
 704: EQUAL
 705: IFFALSE 720
// Gleb = load_char ( Gleb ) ;
 707: LD_ADDR_EXP 15
 711: PUSH
 712: LD_STRING Gleb
 714: PPUSH
 715: CALL 0 0 1
 719: ST_TO_ADDR
// if LoadVariable ( PetrosyanLoc , 0 ) = 14 then
 720: LD_STRING PetrosyanLoc
 722: PPUSH
 723: LD_INT 0
 725: PPUSH
 726: CALL_OW 30
 730: PUSH
 731: LD_INT 14
 733: EQUAL
 734: IFFALSE 749
// Petrosyan = load_char ( Petrosyan ) ;
 736: LD_ADDR_EXP 16
 740: PUSH
 741: LD_STRING Petrosyan
 743: PPUSH
 744: CALL 0 0 1
 748: ST_TO_ADDR
// if LoadVariable ( LipshchinLoc , 0 ) = 14 then
 749: LD_STRING LipshchinLoc
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 30
 759: PUSH
 760: LD_INT 14
 762: EQUAL
 763: IFFALSE 778
// Lipshchin = load_char ( Lipshchin ) ;
 765: LD_ADDR_EXP 17
 769: PUSH
 770: LD_STRING Lipshchin
 772: PPUSH
 773: CALL 0 0 1
 777: ST_TO_ADDR
// if LoadVariable ( TitovLoc , 0 ) = 14 then
 778: LD_STRING TitovLoc
 780: PPUSH
 781: LD_INT 0
 783: PPUSH
 784: CALL_OW 30
 788: PUSH
 789: LD_INT 14
 791: EQUAL
 792: IFFALSE 807
// Titov = load_char ( Titov ) ;
 794: LD_ADDR_EXP 18
 798: PUSH
 799: LD_STRING Titov
 801: PPUSH
 802: CALL 0 0 1
 806: ST_TO_ADDR
// if LoadVariable ( DolgovLoc , 0 ) = 14 then
 807: LD_STRING DolgovLoc
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: CALL_OW 30
 817: PUSH
 818: LD_INT 14
 820: EQUAL
 821: IFFALSE 836
// Dolgov = load_char ( Dolgov ) ;
 823: LD_ADDR_EXP 19
 827: PUSH
 828: LD_STRING Dolgov
 830: PPUSH
 831: CALL 0 0 1
 835: ST_TO_ADDR
// if LoadVariable ( XavierLoc , 0 ) = 14 then
 836: LD_STRING XavierLoc
 838: PPUSH
 839: LD_INT 0
 841: PPUSH
 842: CALL_OW 30
 846: PUSH
 847: LD_INT 14
 849: EQUAL
 850: IFFALSE 865
// Xavier = load_char ( Xavier ) ;
 852: LD_ADDR_EXP 20
 856: PUSH
 857: LD_STRING Xavier
 859: PPUSH
 860: CALL 0 0 1
 864: ST_TO_ADDR
// if LoadVariable ( OblukovLoc , 0 ) = 14 then
 865: LD_STRING OblukovLoc
 867: PPUSH
 868: LD_INT 0
 870: PPUSH
 871: CALL_OW 30
 875: PUSH
 876: LD_INT 14
 878: EQUAL
 879: IFFALSE 894
// Oblukov = load_char ( Oblukov ) ;
 881: LD_ADDR_EXP 21
 885: PUSH
 886: LD_STRING Oblukov
 888: PPUSH
 889: CALL 0 0 1
 893: ST_TO_ADDR
// if LoadVariable ( KozlovLoc , 0 ) = 14 then
 894: LD_STRING KozlovLoc
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL_OW 30
 904: PUSH
 905: LD_INT 14
 907: EQUAL
 908: IFFALSE 923
// Kozlov = load_char ( Kozlov ) ;
 910: LD_ADDR_EXP 22
 914: PUSH
 915: LD_STRING Kozlov
 917: PPUSH
 918: CALL 0 0 1
 922: ST_TO_ADDR
// if LoadVariable ( KapitsovaLoc , 0 ) = 14 then
 923: LD_STRING KapitsovaLoc
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: PUSH
 934: LD_INT 14
 936: EQUAL
 937: IFFALSE 952
// Kapitsova = load_char ( Kapitsova ) ;
 939: LD_ADDR_EXP 23
 943: PUSH
 944: LD_STRING Kapitsova
 946: PPUSH
 947: CALL 0 0 1
 951: ST_TO_ADDR
// Ostatni = load_set ( Others_Ru14 ) ;
 952: LD_ADDR_EXP 24
 956: PUSH
 957: LD_STRING Others_Ru14
 959: PPUSH
 960: CALL 51 0 1
 964: ST_TO_ADDR
// DeleteCharacters ( Others_Ru14 ) ;
 965: LD_STRING Others_Ru14
 967: PPUSH
 968: CALL_OW 40
// MashaSpec = LoadVariable ( Masha , [ ] ) ;
 972: LD_ADDR_VAR 0 2
 976: PUSH
 977: LD_STRING Masha
 979: PPUSH
 980: EMPTY
 981: PPUSH
 982: CALL_OW 30
 986: ST_TO_ADDR
// if MashaSpec = 0 then
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 0
 994: EQUAL
 995: IFFALSE 1007
// Masha = 0 else
 997: LD_ADDR_EXP 25
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
1005: GO 1153
// begin UC_Nation = NATION_RUSSIAN ;
1007: LD_ADDR_OWVAR 21
1011: PUSH
1012: LD_INT 3
1014: ST_TO_ADDR
// UC_Side = side_Ru ;
1015: LD_ADDR_OWVAR 20
1019: PUSH
1020: LD_EXP 2
1024: ST_TO_ADDR
// VC_Chassis = MashaSpec [ 1 ] ;
1025: LD_ADDR_OWVAR 37
1029: PUSH
1030: LD_VAR 0 2
1034: PUSH
1035: LD_INT 1
1037: ARRAY
1038: ST_TO_ADDR
// VC_Engine = MashaSpec [ 2 ] ;
1039: LD_ADDR_OWVAR 39
1043: PUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: ST_TO_ADDR
// VC_Control = MashaSpec [ 3 ] ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_VAR 0 2
1062: PUSH
1063: LD_INT 3
1065: ARRAY
1066: ST_TO_ADDR
// VC_Weapon = MashaSpec [ 4 ] ;
1067: LD_ADDR_OWVAR 40
1071: PUSH
1072: LD_VAR 0 2
1076: PUSH
1077: LD_INT 4
1079: ARRAY
1080: ST_TO_ADDR
// if ( VC_Weapon = 0 ) or ( VC_Control = 0 ) or ( VC_Engine = 0 ) or ( VC_Chassis = 0 ) then
1081: LD_OWVAR 40
1085: PUSH
1086: LD_INT 0
1088: EQUAL
1089: PUSH
1090: LD_OWVAR 38
1094: PUSH
1095: LD_INT 0
1097: EQUAL
1098: OR
1099: PUSH
1100: LD_OWVAR 39
1104: PUSH
1105: LD_INT 0
1107: EQUAL
1108: OR
1109: PUSH
1110: LD_OWVAR 37
1114: PUSH
1115: LD_INT 0
1117: EQUAL
1118: OR
1119: IFFALSE 1131
// Masha = 0 else
1121: LD_ADDR_EXP 25
1125: PUSH
1126: LD_INT 0
1128: ST_TO_ADDR
1129: GO 1153
// begin Masha = CreateVehicle ;
1131: LD_ADDR_EXP 25
1135: PUSH
1136: CALL_OW 45
1140: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
1141: LD_EXP 25
1145: PPUSH
1146: LD_INT 1
1148: PPUSH
1149: CALL_OW 242
// end ; end ; Rusove = ( [ Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Ostatni ) diff [ 0 ] ;
1153: LD_ADDR_EXP 39
1157: PUSH
1158: LD_EXP 15
1162: PUSH
1163: LD_EXP 7
1167: PUSH
1168: LD_EXP 8
1172: PUSH
1173: LD_EXP 9
1177: PUSH
1178: LD_EXP 10
1182: PUSH
1183: LD_EXP 11
1187: PUSH
1188: LD_EXP 12
1192: PUSH
1193: LD_EXP 13
1197: PUSH
1198: LD_EXP 14
1202: PUSH
1203: LD_EXP 15
1207: PUSH
1208: LD_EXP 16
1212: PUSH
1213: LD_EXP 17
1217: PUSH
1218: LD_EXP 18
1222: PUSH
1223: LD_EXP 19
1227: PUSH
1228: LD_EXP 20
1232: PUSH
1233: LD_EXP 21
1237: PUSH
1238: LD_EXP 22
1242: PUSH
1243: LD_EXP 23
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: PUSH
1268: LD_EXP 24
1272: UNION
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: EMPTY
1278: LIST
1279: DIFF
1280: ST_TO_ADDR
// Rusove2 = [ ] ;
1281: LD_ADDR_EXP 40
1285: PUSH
1286: EMPTY
1287: ST_TO_ADDR
// SetSide ( [ Burlak ] , side_Ru ) ;
1288: LD_EXP 6
1292: PUSH
1293: EMPTY
1294: LIST
1295: PPUSH
1296: LD_EXP 2
1300: PPUSH
1301: CALL_OW 235
// SetSide ( Rusove , side_Ru ) ;
1305: LD_EXP 39
1309: PPUSH
1310: LD_EXP 2
1314: PPUSH
1315: CALL_OW 235
// end ;
1319: LD_VAR 0 1
1323: RET
// function save_char ( Handle , Ident ) ; begin
1324: LD_INT 0
1326: PPUSH
// if Handle then
1327: LD_VAR 0 1
1331: IFFALSE 1350
// SaveCharacters ( [ Handle ] , Ident ) ;
1333: LD_VAR 0 1
1337: PUSH
1338: EMPTY
1339: LIST
1340: PPUSH
1341: LD_VAR 0 2
1345: PPUSH
1346: CALL_OW 38
// end ;
1350: LD_VAR 0 3
1354: RET
// function save ; var MashaSpec , Survivors4 , O , Opice ; begin
1355: LD_INT 0
1357: PPUSH
1358: PPUSH
1359: PPUSH
1360: PPUSH
1361: PPUSH
// SaveVariable ( LegieZnicena , LegionDestroyed ) ;
1362: LD_EXP 67
1366: PPUSH
1367: LD_STRING LegionDestroyed
1369: PPUSH
1370: CALL_OW 39
// if Masha and IsOk ( Masha ) and ( GetSide ( Masha ) = side_Ru ) then
1374: LD_EXP 25
1378: PUSH
1379: LD_EXP 25
1383: PPUSH
1384: CALL_OW 302
1388: AND
1389: PUSH
1390: LD_EXP 25
1394: PPUSH
1395: CALL_OW 255
1399: PUSH
1400: LD_EXP 2
1404: EQUAL
1405: AND
1406: IFFALSE 1410
// begin end else
1408: GO 1417
// DeleteVariable ( Masha ) ;
1410: LD_STRING Masha
1412: PPUSH
1413: CALL_OW 41
// save_char ( Burlak , Burlak ) ;
1417: LD_EXP 6
1421: PPUSH
1422: LD_STRING Burlak
1424: PPUSH
1425: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1429: LD_EXP 15
1433: PPUSH
1434: LD_STRING Gleb
1436: PPUSH
1437: CALL 1324 0 2
// save_char ( Belkov , Belkov ) ;
1441: LD_EXP 7
1445: PPUSH
1446: LD_STRING Belkov
1448: PPUSH
1449: CALL 1324 0 2
// save_char ( Gnyevko , Gnyevko ) ;
1453: LD_EXP 8
1457: PPUSH
1458: LD_STRING Gnyevko
1460: PPUSH
1461: CALL 1324 0 2
// save_char ( Kirilenkova , Kirilenkova ) ;
1465: LD_EXP 9
1469: PPUSH
1470: LD_STRING Kirilenkova
1472: PPUSH
1473: CALL 1324 0 2
// save_char ( Kovalyuk , Kovalyuk ) ;
1477: LD_EXP 10
1481: PPUSH
1482: LD_STRING Kovalyuk
1484: PPUSH
1485: CALL 1324 0 2
// save_char ( Scholtze , Scholtze ) ;
1489: LD_EXP 11
1493: PPUSH
1494: LD_STRING Scholtze
1496: PPUSH
1497: CALL 1324 0 2
// save_char ( Kuzmov , Kuzmov ) ;
1501: LD_EXP 12
1505: PPUSH
1506: LD_STRING Kuzmov
1508: PPUSH
1509: CALL 1324 0 2
// save_char ( Karamazov , Karamazov ) ;
1513: LD_EXP 13
1517: PPUSH
1518: LD_STRING Karamazov
1520: PPUSH
1521: CALL 1324 0 2
// save_char ( Petrovova , Petrovova ) ;
1525: LD_EXP 14
1529: PPUSH
1530: LD_STRING Petrovova
1532: PPUSH
1533: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1537: LD_EXP 15
1541: PPUSH
1542: LD_STRING Gleb
1544: PPUSH
1545: CALL 1324 0 2
// save_char ( Petrosyan , Petrosyan ) ;
1549: LD_EXP 16
1553: PPUSH
1554: LD_STRING Petrosyan
1556: PPUSH
1557: CALL 1324 0 2
// save_char ( Lipshchin , Lipshchin ) ;
1561: LD_EXP 17
1565: PPUSH
1566: LD_STRING Lipshchin
1568: PPUSH
1569: CALL 1324 0 2
// save_char ( Titov , Titov ) ;
1573: LD_EXP 18
1577: PPUSH
1578: LD_STRING Titov
1580: PPUSH
1581: CALL 1324 0 2
// save_char ( Dolgov , Dolgov ) ;
1585: LD_EXP 19
1589: PPUSH
1590: LD_STRING Dolgov
1592: PPUSH
1593: CALL 1324 0 2
// save_char ( Xavier , Xavier ) ;
1597: LD_EXP 20
1601: PPUSH
1602: LD_STRING Xavier
1604: PPUSH
1605: CALL 1324 0 2
// save_char ( Oblukov , Oblukov ) ;
1609: LD_EXP 21
1613: PPUSH
1614: LD_STRING Oblukov
1616: PPUSH
1617: CALL 1324 0 2
// save_char ( Kozlov , Kozlov ) ;
1621: LD_EXP 22
1625: PPUSH
1626: LD_STRING Kozlov
1628: PPUSH
1629: CALL 1324 0 2
// save_char ( Kapitsova , Kapitsova ) ;
1633: LD_EXP 23
1637: PPUSH
1638: LD_STRING Kapitsova
1640: PPUSH
1641: CALL 1324 0 2
// save_char ( Abdul , Abdul ) ;
1645: LD_EXP 31
1649: PPUSH
1650: LD_STRING Abdul
1652: PPUSH
1653: CALL 1324 0 2
// save_char ( Farmer , Farmer ) ;
1657: LD_EXP 29
1661: PPUSH
1662: LD_STRING Farmer
1664: PPUSH
1665: CALL 1324 0 2
// save_char ( Heike , Heike ) ;
1669: LD_EXP 28
1673: PPUSH
1674: LD_STRING Heike
1676: PPUSH
1677: CALL 1324 0 2
// Survivors4 = load_set ( Survivors4 ) ;
1681: LD_ADDR_VAR 0 3
1685: PUSH
1686: LD_STRING Survivors4
1688: PPUSH
1689: CALL 51 0 1
1693: ST_TO_ADDR
// O = Rusove diff [ 0 , Burlak , Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_EXP 39
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_EXP 6
1711: PUSH
1712: LD_EXP 15
1716: PUSH
1717: LD_EXP 7
1721: PUSH
1722: LD_EXP 8
1726: PUSH
1727: LD_EXP 9
1731: PUSH
1732: LD_EXP 10
1736: PUSH
1737: LD_EXP 11
1741: PUSH
1742: LD_EXP 12
1746: PUSH
1747: LD_EXP 13
1751: PUSH
1752: LD_EXP 14
1756: PUSH
1757: LD_EXP 15
1761: PUSH
1762: LD_EXP 16
1766: PUSH
1767: LD_EXP 17
1771: PUSH
1772: LD_EXP 18
1776: PUSH
1777: LD_EXP 19
1781: PUSH
1782: LD_EXP 20
1786: PUSH
1787: LD_EXP 21
1791: PUSH
1792: LD_EXP 22
1796: PUSH
1797: LD_EXP 23
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: DIFF
1824: ST_TO_ADDR
// Opice = UnitFilter ( Rusove , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
1825: LD_ADDR_VAR 0 5
1829: PUSH
1830: LD_EXP 39
1834: PPUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 25
1840: PUSH
1841: LD_INT 12
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 25
1850: PUSH
1851: LD_INT 15
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 16
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 25
1870: PUSH
1871: LD_INT 17
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: EMPTY
1886: LIST
1887: PPUSH
1888: CALL_OW 72
1892: ST_TO_ADDR
// O = O diff Opice ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_VAR 0 5
1907: DIFF
1908: ST_TO_ADDR
// SaveCharacters ( Survivors4 union O , Survivors4 ) ;
1909: LD_VAR 0 3
1913: PUSH
1914: LD_VAR 0 4
1918: UNION
1919: PPUSH
1920: LD_STRING Survivors4
1922: PPUSH
1923: CALL_OW 38
// end ;
1927: LD_VAR 0 1
1931: RET
// function dej_medaile ; begin
1932: LD_INT 0
1934: PPUSH
// if not RusMaOtraveno then
1935: LD_EXP 64
1939: NOT
1940: IFFALSE 1954
// AddMedal ( Siberite , 1 ) else
1942: LD_STRING Siberite
1944: PPUSH
1945: LD_INT 1
1947: PPUSH
1948: CALL_OW 101
1952: GO 1984
// if RusMaSiberit then
1954: LD_EXP 63
1958: IFFALSE 1973
// AddMedal ( Siberite , - 1 ) else
1960: LD_STRING Siberite
1962: PPUSH
1963: LD_INT 1
1965: NEG
1966: PPUSH
1967: CALL_OW 101
1971: GO 1984
// AddMedal ( Siberite , - 2 ) ;
1973: LD_STRING Siberite
1975: PPUSH
1976: LD_INT 2
1978: NEG
1979: PPUSH
1980: CALL_OW 101
// if BehemothBuilt then
1984: LD_EXP 68
1988: IFFALSE 2002
// AddMedal ( Behemoth , 1 ) else
1990: LD_STRING Behemoth
1992: PPUSH
1993: LD_INT 1
1995: PPUSH
1996: CALL_OW 101
2000: GO 2013
// AddMedal ( Behemoth , - 1 ) ;
2002: LD_STRING Behemoth
2004: PPUSH
2005: LD_INT 1
2007: NEG
2008: PPUSH
2009: CALL_OW 101
// if MenLost <= 2 then
2013: LD_EXP 69
2017: PUSH
2018: LD_INT 2
2020: LESSEQUAL
2021: IFFALSE 2035
// AddMedal ( LittleLosses , 1 ) else
2023: LD_STRING LittleLosses
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: CALL_OW 101
2033: GO 2046
// AddMedal ( LittleLosses , - 1 ) ;
2035: LD_STRING LittleLosses
2037: PPUSH
2038: LD_INT 1
2040: NEG
2041: PPUSH
2042: CALL_OW 101
// end ;
2046: LD_VAR 0 1
2050: RET
// export function vyhral ; var Lidi , Opice ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
2055: PPUSH
// dej_medaile ;
2056: CALL 1932 0 0
// GiveMedals ( Main ) ;
2060: LD_STRING Main
2062: PPUSH
2063: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2067: LD_ADDR_VAR 0 2
2071: PUSH
2072: LD_INT 22
2074: PUSH
2075: LD_EXP 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 21
2086: PUSH
2087: LD_INT 1
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: PUSH
2094: LD_INT 51
2096: PUSH
2097: EMPTY
2098: LIST
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: PPUSH
2105: CALL_OW 69
2109: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2110: LD_ADDR_VAR 0 3
2114: PUSH
2115: LD_VAR 0 2
2119: PPUSH
2120: LD_INT 2
2122: PUSH
2123: LD_INT 25
2125: PUSH
2126: LD_INT 12
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: PUSH
2133: LD_INT 25
2135: PUSH
2136: LD_INT 15
2138: PUSH
2139: EMPTY
2140: LIST
2141: LIST
2142: PUSH
2143: LD_INT 25
2145: PUSH
2146: LD_INT 16
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 25
2155: PUSH
2156: LD_INT 17
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: EMPTY
2171: LIST
2172: PPUSH
2173: CALL_OW 72
2177: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
2178: LD_VAR 0 2
2182: PUSH
2183: LD_VAR 0 3
2187: DIFF
2188: PPUSH
2189: CALL_OW 43
// save ;
2193: CALL 1355 0 0
// YouWin ;
2197: CALL_OW 103
// end ;
2201: LD_VAR 0 1
2205: RET
// function set_attitudes ; begin
2206: LD_INT 0
2208: PPUSH
// SetAttitude ( side_Ru , side_Upr , ATT_NEUTRAL , true ) ;
2209: LD_EXP 2
2213: PPUSH
2214: LD_EXP 5
2218: PPUSH
2219: LD_INT 0
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: CALL_OW 80
// SetAttitude ( side_Le , side_Upr , ATT_FRIEND , true ) ;
2229: LD_EXP 4
2233: PPUSH
2234: LD_EXP 5
2238: PPUSH
2239: LD_INT 1
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 80
// SetAttitude ( side_Ar , side_Upr , ATT_FRIEND , true ) ;
2249: LD_EXP 3
2253: PPUSH
2254: LD_EXP 5
2258: PPUSH
2259: LD_INT 1
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: CALL_OW 80
// SetAttitude ( side_Le , side_Ar , ATT_FRIEND , true ) ;
2269: LD_EXP 4
2273: PPUSH
2274: LD_EXP 3
2278: PPUSH
2279: LD_INT 1
2281: PPUSH
2282: LD_INT 1
2284: PPUSH
2285: CALL_OW 80
// end ;
2289: LD_VAR 0 1
2293: RET
// starting begin RandomizeAll ;
2294: CALL_OW 11
// InitUC ;
2298: CALL_OW 18
// InitBC ;
2302: CALL_OW 21
// InitVC ;
2306: CALL_OW 20
// InitHC ;
2310: CALL_OW 19
// side_Neutral = 0 ;
2314: LD_ADDR_EXP 1
2318: PUSH
2319: LD_INT 0
2321: ST_TO_ADDR
// side_Ru = 3 ;
2322: LD_ADDR_EXP 2
2326: PUSH
2327: LD_INT 3
2329: ST_TO_ADDR
// side_Ar = 2 ;
2330: LD_ADDR_EXP 3
2334: PUSH
2335: LD_INT 2
2337: ST_TO_ADDR
// side_Upr = 7 ;
2338: LD_ADDR_EXP 5
2342: PUSH
2343: LD_INT 7
2345: ST_TO_ADDR
// side_Le = 8 ;
2346: LD_ADDR_EXP 4
2350: PUSH
2351: LD_INT 8
2353: ST_TO_ADDR
// set_attitudes ;
2354: CALL 2206 0 0
// load ;
2358: CALL 161 0 0
// init_difficulty ;
2362: CALL 2391 0 0
// init_nature ;
2366: CALL 3014 0 0
// init_suroviny ;
2370: CALL 3091 0 0
// init_legion ;
2374: CALL 6095 0 0
// init_arabi ;
2378: CALL 11539 0 0
// init_rusove ;
2382: CALL 19026 0 0
// uvod ;
2386: CALL 19093 0 0
// end ; end_of_file
2390: END
// export dif_CekaniBednyRus , dif_PoctyBednyRus ; export dif_PoctyBednyStart , dif_PoctyBednyExtra ; export dif_LegionRidici , dif_AraboveRidici ; export dif_UtokSkupina , dif_CasovacUtoku , dif_PrvniUtok ; export dif_PstZbrane ; export dif_MaxOpice , dif_ZpozdeniOpice , dif_PstOpiceRus ; export dif_OpiceLimit , dif_OpiceNajednouPocet ; export dif_ArabiLidiVzdajSe ; export dif_LegionTimeout ; export function init_difficulty ; begin
2391: LD_INT 0
2393: PPUSH
// dif_CekaniBednyRus = [ [ 0 0$1 , 0 0$25 ] , [ 0 0$30 , 1 1$05 ] , [ 0 0$50 , 1 1$15 ] ] ;
2394: LD_ADDR_EXP 41
2398: PUSH
2399: LD_INT 35
2401: PUSH
2402: LD_INT 875
2404: PUSH
2405: EMPTY
2406: LIST
2407: LIST
2408: PUSH
2409: LD_INT 1050
2411: PUSH
2412: LD_INT 2275
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: LD_INT 1750
2421: PUSH
2422: LD_INT 2625
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: ST_TO_ADDR
// dif_PoctyBednyRus = [ [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 5 ] ] ;
2434: LD_ADDR_EXP 42
2438: PUSH
2439: LD_INT 5
2441: PUSH
2442: LD_INT 5
2444: PUSH
2445: EMPTY
2446: LIST
2447: LIST
2448: PUSH
2449: LD_INT 4
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 5
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: ST_TO_ADDR
// dif_PoctyBednyStart = [ 5 , 3 , 1 ] ;
2474: LD_ADDR_EXP 43
2478: PUSH
2479: LD_INT 5
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 1
2487: PUSH
2488: EMPTY
2489: LIST
2490: LIST
2491: LIST
2492: ST_TO_ADDR
// dif_PoctyBednyExtra = [ 10 , 5 , 0 ] ;
2493: LD_ADDR_EXP 44
2497: PUSH
2498: LD_INT 10
2500: PUSH
2501: LD_INT 5
2503: PUSH
2504: LD_INT 0
2506: PUSH
2507: EMPTY
2508: LIST
2509: LIST
2510: LIST
2511: ST_TO_ADDR
// dif_LegionRidici = [ 2 , 3 , 4 ] ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_INT 2
2519: PUSH
2520: LD_INT 3
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: EMPTY
2527: LIST
2528: LIST
2529: LIST
2530: ST_TO_ADDR
// dif_AraboveRidici = [ 3 , 5 , 7 ] ;
2531: LD_ADDR_EXP 46
2535: PUSH
2536: LD_INT 3
2538: PUSH
2539: LD_INT 5
2541: PUSH
2542: LD_INT 7
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: LIST
2549: ST_TO_ADDR
// dif_PrvniUtok = [ [ 6 , 10 ] , [ 4 , 6 ] , [ 4 , 6 ] ] ;
2550: LD_ADDR_EXP 49
2554: PUSH
2555: LD_INT 6
2557: PUSH
2558: LD_INT 10
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PUSH
2565: LD_INT 4
2567: PUSH
2568: LD_INT 6
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 4
2577: PUSH
2578: LD_INT 6
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: LIST
2589: ST_TO_ADDR
// dif_CasovacUtoku = [ [ 2 , 5 , 6 ] , [ 2 , 4 ] , [ 2 , 3 ] ] ;
2590: LD_ADDR_EXP 48
2594: PUSH
2595: LD_INT 2
2597: PUSH
2598: LD_INT 5
2600: PUSH
2601: LD_INT 6
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 2
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: PUSH
2619: LD_INT 2
2621: PUSH
2622: LD_INT 3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: LIST
2633: ST_TO_ADDR
// dif_UtokSkupina = [ 4 , 6 , 8 ] ;
2634: LD_ADDR_EXP 47
2638: PUSH
2639: LD_INT 4
2641: PUSH
2642: LD_INT 6
2644: PUSH
2645: LD_INT 8
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: LIST
2652: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 25 , 50 , 75 , 100 ] , [ 30 , 60 , 55 , 100 ] ] ;
2653: LD_ADDR_EXP 50
2657: PUSH
2658: LD_INT 20
2660: PUSH
2661: LD_INT 40
2663: PUSH
2664: LD_INT 80
2666: PUSH
2667: LD_INT 100
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: PUSH
2676: LD_INT 25
2678: PUSH
2679: LD_INT 50
2681: PUSH
2682: LD_INT 75
2684: PUSH
2685: LD_INT 100
2687: PUSH
2688: EMPTY
2689: LIST
2690: LIST
2691: LIST
2692: LIST
2693: PUSH
2694: LD_INT 30
2696: PUSH
2697: LD_INT 60
2699: PUSH
2700: LD_INT 55
2702: PUSH
2703: LD_INT 100
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: LIST
2716: ST_TO_ADDR
// dif_MaxOpice = [ 5 , 8 , 11 ] ;
2717: LD_ADDR_EXP 51
2721: PUSH
2722: LD_INT 5
2724: PUSH
2725: LD_INT 8
2727: PUSH
2728: LD_INT 11
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: LIST
2735: ST_TO_ADDR
// dif_ZpozdeniOpice = [ [ 2 2$0 , 3 3$4 ] , [ 1 1$0 , 2 2$0 ] , [ 0 , 1 1$0 ] ] ;
2736: LD_ADDR_EXP 52
2740: PUSH
2741: LD_INT 4200
2743: PUSH
2744: LD_INT 6440
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: PUSH
2751: LD_INT 2100
2753: PUSH
2754: LD_INT 4200
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 0
2763: PUSH
2764: LD_INT 2100
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: LIST
2775: ST_TO_ADDR
// dif_PstOpiceRus = [ 60 , 40 , 15 ] ;
2776: LD_ADDR_EXP 53
2780: PUSH
2781: LD_INT 60
2783: PUSH
2784: LD_INT 40
2786: PUSH
2787: LD_INT 15
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: ST_TO_ADDR
// dif_OpiceLimit = [ 10 , 25 , - 1 ] ;
2795: LD_ADDR_EXP 54
2799: PUSH
2800: LD_INT 10
2802: PUSH
2803: LD_INT 25
2805: PUSH
2806: LD_INT 1
2808: NEG
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// dif_OpiceNajednouPocet = [ 1 , 2 , 4 ] ;
2815: LD_ADDR_EXP 55
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 2
2825: PUSH
2826: LD_INT 4
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: ST_TO_ADDR
// dif_ArabiLidiVzdajSe = [ 6 , 4 , 2 ] ;
2834: LD_ADDR_EXP 56
2838: PUSH
2839: LD_INT 6
2841: PUSH
2842: LD_INT 4
2844: PUSH
2845: LD_INT 2
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: LIST
2852: ST_TO_ADDR
// dif_LegionTimeout = [ 30 30$0 , 25 25$0 , 15 15$0 ] ;
2853: LD_ADDR_EXP 57
2857: PUSH
2858: LD_INT 63000
2860: PUSH
2861: LD_INT 52500
2863: PUSH
2864: LD_INT 31500
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: LIST
2871: ST_TO_ADDR
// end ; end_of_file
2872: LD_VAR 0 1
2876: RET
// export function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
2877: LD_INT 0
2879: PPUSH
2880: PPUSH
2881: PPUSH
// Result = [ ] ;
2882: LD_ADDR_VAR 0 4
2886: PUSH
2887: EMPTY
2888: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
2889: LD_ADDR_OWVAR 21
2893: PUSH
2894: LD_INT 0
2896: ST_TO_ADDR
// UC_side = side_neutral ;
2897: LD_ADDR_OWVAR 20
2901: PUSH
2902: LD_EXP 1
2906: ST_TO_ADDR
// HC_Class = Cls ;
2907: LD_ADDR_OWVAR 28
2911: PUSH
2912: LD_VAR 0 1
2916: ST_TO_ADDR
// HC_Name =  ;
2917: LD_ADDR_OWVAR 26
2921: PUSH
2922: LD_STRING 
2924: ST_TO_ADDR
// hc_agressivity = rand ( 0 , 20 ) ;
2925: LD_ADDR_OWVAR 35
2929: PUSH
2930: LD_INT 0
2932: PPUSH
2933: LD_INT 20
2935: PPUSH
2936: CALL_OW 12
2940: ST_TO_ADDR
// for i = 1 to Cnt do
2941: LD_ADDR_VAR 0 5
2945: PUSH
2946: DOUBLE
2947: LD_INT 1
2949: DEC
2950: ST_TO_ADDR
2951: LD_VAR 0 2
2955: PUSH
2956: FOR_TO
2957: IFFALSE 3007
// begin h = CreateHuman ;
2959: LD_ADDR_VAR 0 6
2963: PUSH
2964: CALL_OW 44
2968: ST_TO_ADDR
// Result = Result union [ h ] ;
2969: LD_ADDR_VAR 0 4
2973: PUSH
2974: LD_VAR 0 4
2978: PUSH
2979: LD_VAR 0 6
2983: PUSH
2984: EMPTY
2985: LIST
2986: UNION
2987: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
2988: LD_VAR 0 6
2992: PPUSH
2993: LD_VAR 0 3
2997: PPUSH
2998: LD_INT 0
3000: PPUSH
3001: CALL_OW 49
// end ;
3005: GO 2956
3007: POP
3008: POP
// end ;
3009: LD_VAR 0 4
3013: RET
// export function init_nature ; begin
3014: LD_INT 0
3016: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 3 , 5 ) , Les ) ;
3017: LD_INT 14
3019: PPUSH
3020: LD_INT 3
3022: PPUSH
3023: LD_INT 5
3025: PPUSH
3026: CALL_OW 12
3030: PPUSH
3031: LD_INT 1
3033: PPUSH
3034: CALL 2877 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les ) ;
3038: LD_INT 12
3040: PPUSH
3041: LD_INT 5
3043: PPUSH
3044: LD_INT 7
3046: PPUSH
3047: CALL_OW 12
3051: PUSH
3052: LD_OWVAR 67
3056: MINUS
3057: PPUSH
3058: LD_INT 1
3060: PPUSH
3061: CALL 2877 0 3
// create_nature ( CLASS_BAGGIE , Rand ( 2 , 5 ) , Louka ) ;
3065: LD_INT 13
3067: PPUSH
3068: LD_INT 2
3070: PPUSH
3071: LD_INT 5
3073: PPUSH
3074: CALL_OW 12
3078: PPUSH
3079: LD_INT 2
3081: PPUSH
3082: CALL 2877 0 3
// end ; end_of_file
3086: LD_VAR 0 1
3090: RET
// var CekaniRus , PoctyRus , PoctyExtra , PoctyStart ; export function init_suroviny ; var I ; begin
3091: LD_INT 0
3093: PPUSH
3094: PPUSH
// CekaniRus = dif_CekaniBednyRus [ Difficulty ] ;
3095: LD_ADDR_LOC 1
3099: PUSH
3100: LD_EXP 41
3104: PUSH
3105: LD_OWVAR 67
3109: ARRAY
3110: ST_TO_ADDR
// PoctyRus = dif_PoctyBednyRus [ Difficulty ] ;
3111: LD_ADDR_LOC 2
3115: PUSH
3116: LD_EXP 42
3120: PUSH
3121: LD_OWVAR 67
3125: ARRAY
3126: ST_TO_ADDR
// PoctyExtra = dif_PoctyBednyExtra [ Difficulty ] ;
3127: LD_ADDR_LOC 3
3131: PUSH
3132: LD_EXP 44
3136: PUSH
3137: LD_OWVAR 67
3141: ARRAY
3142: ST_TO_ADDR
// PoctyStart = dif_PoctyBednyStart [ Difficulty ] ;
3143: LD_ADDR_LOC 4
3147: PUSH
3148: LD_EXP 43
3152: PUSH
3153: LD_OWVAR 67
3157: ARRAY
3158: ST_TO_ADDR
// end ;
3159: LD_VAR 0 1
3163: RET
// every 3 3$0 do
3164: GO 3166
3166: DISABLE
// begin Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3167: LD_LOC 1
3171: PUSH
3172: LD_INT 1
3174: ARRAY
3175: PPUSH
3176: LD_LOC 1
3180: PUSH
3181: LD_INT 2
3183: ARRAY
3184: PPUSH
3185: CALL_OW 12
3189: PPUSH
3190: CALL_OW 67
// CreateCratesArea ( Rand ( PoctyRus [ 1 ] , PoctyRus [ 2 ] ) , BednyRusove , true ) ;
3194: LD_LOC 2
3198: PUSH
3199: LD_INT 1
3201: ARRAY
3202: PPUSH
3203: LD_LOC 2
3207: PUSH
3208: LD_INT 2
3210: ARRAY
3211: PPUSH
3212: CALL_OW 12
3216: PPUSH
3217: LD_INT 6
3219: PPUSH
3220: LD_INT 1
3222: PPUSH
3223: CALL_OW 55
// enable ;
3227: ENABLE
// end ;
3228: END
// every 2 2$10 do
3229: GO 3231
3231: DISABLE
// begin if PoctyStart <= 0 then
3232: LD_LOC 4
3236: PUSH
3237: LD_INT 0
3239: LESSEQUAL
3240: IFFALSE 3244
// exit ;
3242: GO 3317
// Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3244: LD_LOC 1
3248: PUSH
3249: LD_INT 1
3251: ARRAY
3252: PPUSH
3253: LD_LOC 1
3257: PUSH
3258: LD_INT 2
3260: ARRAY
3261: PPUSH
3262: CALL_OW 12
3266: PPUSH
3267: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 3 ) , BednyStart , false ) ;
3271: LD_INT 1
3273: PPUSH
3274: LD_INT 3
3276: PPUSH
3277: CALL_OW 12
3281: PPUSH
3282: LD_INT 8
3284: PPUSH
3285: LD_INT 0
3287: PPUSH
3288: CALL_OW 55
// PoctyStart = PoctyStart - 1 ;
3292: LD_ADDR_LOC 4
3296: PUSH
3297: LD_LOC 4
3301: PUSH
3302: LD_INT 1
3304: MINUS
3305: ST_TO_ADDR
// if PoctyStart > 0 then
3306: LD_LOC 4
3310: PUSH
3311: LD_INT 0
3313: GREATER
3314: IFFALSE 3317
// enable ;
3316: ENABLE
// end ;
3317: END
// every 3 3$12 + 1 1$49 do
3318: GO 3320
3320: DISABLE
// begin if PoctyExtra <= 0 then
3321: LD_LOC 3
3325: PUSH
3326: LD_INT 0
3328: LESSEQUAL
3329: IFFALSE 3333
// exit ;
3331: GO 3418
// if Prob ( 40 ) then
3333: LD_INT 40
3335: PPUSH
3336: CALL_OW 13
3340: IFFALSE 3345
// begin enable ;
3342: ENABLE
// exit ;
3343: GO 3418
// end ; Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3345: LD_LOC 1
3349: PUSH
3350: LD_INT 1
3352: ARRAY
3353: PPUSH
3354: LD_LOC 1
3358: PUSH
3359: LD_INT 2
3361: ARRAY
3362: PPUSH
3363: CALL_OW 12
3367: PPUSH
3368: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , BednyExtra , true ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 5
3377: PPUSH
3378: CALL_OW 12
3382: PPUSH
3383: LD_INT 9
3385: PPUSH
3386: LD_INT 1
3388: PPUSH
3389: CALL_OW 55
// PoctyExtra = PoctyExtra - 1 ;
3393: LD_ADDR_LOC 3
3397: PUSH
3398: LD_LOC 3
3402: PUSH
3403: LD_INT 1
3405: MINUS
3406: ST_TO_ADDR
// if PoctyExtra > 0 then
3407: LD_LOC 3
3411: PUSH
3412: LD_INT 0
3414: GREATER
3415: IFFALSE 3418
// enable ;
3417: ENABLE
// end ;
3418: END
// every 3 3$13.7 + 2 2$9 do var Pocet ;
3419: GO 3421
3421: DISABLE
3422: LD_INT 0
3424: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
3425: LD_INT 35
3427: PPUSH
3428: LD_INT 2100
3430: PPUSH
3431: CALL_OW 12
3435: PPUSH
3436: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
3440: LD_ADDR_VAR 0 1
3444: PUSH
3445: LD_INT 0
3447: PPUSH
3448: LD_INT 5
3450: PPUSH
3451: CALL_OW 12
3455: ST_TO_ADDR
// if Pocet > 0 then
3456: LD_VAR 0 1
3460: PUSH
3461: LD_INT 0
3463: GREATER
3464: IFFALSE 3478
// CreateCratesAnywhere ( Pocet , true ) ;
3466: LD_VAR 0 1
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: CALL_OW 57
// enable ;
3478: ENABLE
// end ;
3479: PPOPN 1
3481: END
// every 0 0$57 do var Area , Pocet ;
3482: GO 3484
3484: DISABLE
3485: LD_INT 0
3487: PPUSH
3488: PPUSH
// begin if ArabiZniceni then
3489: LD_EXP 65
3493: IFFALSE 3512
// Wait ( Rand ( 2 2$0 , 3 3$30 ) ) else
3495: LD_INT 4200
3497: PPUSH
3498: LD_INT 7350
3500: PPUSH
3501: CALL_OW 12
3505: PPUSH
3506: CALL_OW 67
3510: GO 3533
// Wait ( Rand ( 0 0$1 , Difficulty * 1 1$0 ) ) ;
3512: LD_INT 35
3514: PPUSH
3515: LD_OWVAR 67
3519: PUSH
3520: LD_INT 2100
3522: MUL
3523: PPUSH
3524: CALL_OW 12
3528: PPUSH
3529: CALL_OW 67
// if ArabiZniceni then
3533: LD_EXP 65
3537: IFFALSE 3564
// begin Area = Arabove ;
3539: LD_ADDR_VAR 0 1
3543: PUSH
3544: LD_INT 5
3546: ST_TO_ADDR
// Pocet = [ 0 , 5 ] ;
3547: LD_ADDR_VAR 0 2
3551: PUSH
3552: LD_INT 0
3554: PUSH
3555: LD_INT 5
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: ST_TO_ADDR
// end else
3562: GO 3587
// begin Area = BednyArabove ;
3564: LD_ADDR_VAR 0 1
3568: PUSH
3569: LD_INT 7
3571: ST_TO_ADDR
// Pocet = [ 3 , 5 ] ;
3572: LD_ADDR_VAR 0 2
3576: PUSH
3577: LD_INT 3
3579: PUSH
3580: LD_INT 5
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: ST_TO_ADDR
// end ; Pocet = Rand ( Pocet [ 1 ] , Pocet [ 2 ] ) ;
3587: LD_ADDR_VAR 0 2
3591: PUSH
3592: LD_VAR 0 2
3596: PUSH
3597: LD_INT 1
3599: ARRAY
3600: PPUSH
3601: LD_VAR 0 2
3605: PUSH
3606: LD_INT 2
3608: ARRAY
3609: PPUSH
3610: CALL_OW 12
3614: ST_TO_ADDR
// if Pocet > 0 then
3615: LD_VAR 0 2
3619: PUSH
3620: LD_INT 0
3622: GREATER
3623: IFFALSE 3642
// CreateCratesArea ( Pocet , Area , true ) ;
3625: LD_VAR 0 2
3629: PPUSH
3630: LD_VAR 0 1
3634: PPUSH
3635: LD_INT 1
3637: PPUSH
3638: CALL_OW 55
// enable ;
3642: ENABLE
// end ; end_of_file
3643: PPOPN 2
3645: END
// function najdi_nekoho ; var Lidi ; begin
3646: LD_INT 0
3648: PPUSH
3649: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3650: LD_ADDR_VAR 0 2
3654: PUSH
3655: LD_INT 22
3657: PUSH
3658: LD_EXP 2
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 50
3669: PUSH
3670: EMPTY
3671: LIST
3672: PUSH
3673: LD_INT 52
3675: PUSH
3676: EMPTY
3677: LIST
3678: PUSH
3679: LD_INT 21
3681: PUSH
3682: LD_INT 1
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 23
3691: PUSH
3692: LD_INT 3
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 26
3701: PUSH
3702: LD_INT 1
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: PPUSH
3717: CALL_OW 69
3721: PUSH
3722: LD_EXP 6
3726: PUSH
3727: EMPTY
3728: LIST
3729: DIFF
3730: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3731: LD_ADDR_VAR 0 2
3735: PUSH
3736: LD_VAR 0 2
3740: PPUSH
3741: CALL 22460 0 1
3745: ST_TO_ADDR
// if Lidi then
3746: LD_VAR 0 2
3750: IFFALSE 3768
// Result = Lidi [ 1 ] else
3752: LD_ADDR_VAR 0 1
3756: PUSH
3757: LD_VAR 0 2
3761: PUSH
3762: LD_INT 1
3764: ARRAY
3765: ST_TO_ADDR
3766: GO 3778
// Result = Burlak ;
3768: LD_ADDR_VAR 0 1
3772: PUSH
3773: LD_EXP 6
3777: ST_TO_ADDR
// end ;
3778: LD_VAR 0 1
3782: RET
// function najdi_nekohoMF ; var Lidi ; begin
3783: LD_INT 0
3785: PPUSH
3786: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] ] ) diff [ Burlak ] ;
3787: LD_ADDR_VAR 0 2
3791: PUSH
3792: LD_INT 22
3794: PUSH
3795: LD_EXP 2
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: PUSH
3804: LD_INT 50
3806: PUSH
3807: EMPTY
3808: LIST
3809: PUSH
3810: LD_INT 52
3812: PUSH
3813: EMPTY
3814: LIST
3815: PUSH
3816: LD_INT 21
3818: PUSH
3819: LD_INT 1
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 23
3828: PUSH
3829: LD_INT 3
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: PPUSH
3843: CALL_OW 69
3847: PUSH
3848: LD_EXP 6
3852: PUSH
3853: EMPTY
3854: LIST
3855: DIFF
3856: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3857: LD_ADDR_VAR 0 2
3861: PUSH
3862: LD_VAR 0 2
3866: PPUSH
3867: CALL 22460 0 1
3871: ST_TO_ADDR
// if Lidi then
3872: LD_VAR 0 2
3876: IFFALSE 3894
// Result = Lidi [ 1 ] else
3878: LD_ADDR_VAR 0 1
3882: PUSH
3883: LD_VAR 0 2
3887: PUSH
3888: LD_INT 1
3890: ARRAY
3891: ST_TO_ADDR
3892: GO 3904
// Result = Burlak ;
3894: LD_ADDR_VAR 0 1
3898: PUSH
3899: LD_EXP 6
3903: ST_TO_ADDR
// end ;
3904: LD_VAR 0 1
3908: RET
// function najdi_vojaka ; var Vojaci ; begin
3909: LD_INT 0
3911: PPUSH
3912: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SOLDIER ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3913: LD_ADDR_VAR 0 2
3917: PUSH
3918: LD_INT 22
3920: PUSH
3921: LD_EXP 2
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PUSH
3930: LD_INT 50
3932: PUSH
3933: EMPTY
3934: LIST
3935: PUSH
3936: LD_INT 52
3938: PUSH
3939: EMPTY
3940: LIST
3941: PUSH
3942: LD_INT 21
3944: PUSH
3945: LD_INT 1
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 23
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: PUSH
3962: LD_INT 25
3964: PUSH
3965: LD_INT 1
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: PUSH
3972: LD_INT 26
3974: PUSH
3975: LD_INT 1
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: LIST
3986: LIST
3987: LIST
3988: LIST
3989: LIST
3990: PPUSH
3991: CALL_OW 69
3995: PUSH
3996: LD_EXP 6
4000: PUSH
4001: EMPTY
4002: LIST
4003: DIFF
4004: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4005: LD_ADDR_VAR 0 2
4009: PUSH
4010: LD_VAR 0 2
4014: PPUSH
4015: CALL 22460 0 1
4019: ST_TO_ADDR
// if Vojaci then
4020: LD_VAR 0 2
4024: IFFALSE 4042
// Result = Vojaci [ 1 ] else
4026: LD_ADDR_VAR 0 1
4030: PUSH
4031: LD_VAR 0 2
4035: PUSH
4036: LD_INT 1
4038: ARRAY
4039: ST_TO_ADDR
4040: GO 4052
// Result = najdi_nekoho ;
4042: LD_ADDR_VAR 0 1
4046: PUSH
4047: CALL 3646 0 0
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// function najdi_vedce ; var Vojaci ; begin
4057: LD_INT 0
4059: PPUSH
4060: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
4061: LD_ADDR_VAR 0 2
4065: PUSH
4066: LD_INT 22
4068: PUSH
4069: LD_EXP 2
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PUSH
4078: LD_INT 50
4080: PUSH
4081: EMPTY
4082: LIST
4083: PUSH
4084: LD_INT 52
4086: PUSH
4087: EMPTY
4088: LIST
4089: PUSH
4090: LD_INT 21
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 23
4102: PUSH
4103: LD_INT 3
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: LD_INT 25
4112: PUSH
4113: LD_INT 4
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: PUSH
4120: LD_INT 26
4122: PUSH
4123: LD_INT 1
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: LIST
4137: LIST
4138: PPUSH
4139: CALL_OW 69
4143: PUSH
4144: LD_EXP 6
4148: PUSH
4149: EMPTY
4150: LIST
4151: DIFF
4152: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4153: LD_ADDR_VAR 0 2
4157: PUSH
4158: LD_VAR 0 2
4162: PPUSH
4163: CALL 22460 0 1
4167: ST_TO_ADDR
// if Vojaci then
4168: LD_VAR 0 2
4172: IFFALSE 4190
// Result = Vojaci [ 1 ] else
4174: LD_ADDR_VAR 0 1
4178: PUSH
4179: LD_VAR 0 2
4183: PUSH
4184: LD_INT 1
4186: ARRAY
4187: ST_TO_ADDR
4188: GO 4198
// Result = 0 ;
4190: LD_ADDR_VAR 0 1
4194: PUSH
4195: LD_INT 0
4197: ST_TO_ADDR
// end ;
4198: LD_VAR 0 1
4202: RET
// function najdi_vedceMF ; var Vojaci ; begin
4203: LD_INT 0
4205: PPUSH
4206: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) diff [ Burlak ] ;
4207: LD_ADDR_VAR 0 2
4211: PUSH
4212: LD_INT 22
4214: PUSH
4215: LD_EXP 2
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: LD_INT 50
4226: PUSH
4227: EMPTY
4228: LIST
4229: PUSH
4230: LD_INT 52
4232: PUSH
4233: EMPTY
4234: LIST
4235: PUSH
4236: LD_INT 21
4238: PUSH
4239: LD_INT 1
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PUSH
4246: LD_INT 23
4248: PUSH
4249: LD_INT 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 25
4258: PUSH
4259: LD_INT 4
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: PPUSH
4274: CALL_OW 69
4278: PUSH
4279: LD_EXP 6
4283: PUSH
4284: EMPTY
4285: LIST
4286: DIFF
4287: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4288: LD_ADDR_VAR 0 2
4292: PUSH
4293: LD_VAR 0 2
4297: PPUSH
4298: CALL 22460 0 1
4302: ST_TO_ADDR
// if Vojaci then
4303: LD_VAR 0 2
4307: IFFALSE 4325
// Result = Vojaci [ 1 ] else
4309: LD_ADDR_VAR 0 1
4313: PUSH
4314: LD_VAR 0 2
4318: PUSH
4319: LD_INT 1
4321: ARRAY
4322: ST_TO_ADDR
4323: GO 4333
// Result = 0 ;
4325: LD_ADDR_VAR 0 1
4329: PUSH
4330: LD_INT 0
4332: ST_TO_ADDR
// end ;
4333: LD_VAR 0 1
4337: RET
// function najdi_sejka ; var Lidi , Sejkove ; begin
4338: LD_INT 0
4340: PPUSH
4341: PPUSH
4342: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4343: LD_ADDR_VAR 0 2
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_EXP 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 50
4362: PUSH
4363: EMPTY
4364: LIST
4365: PUSH
4366: LD_INT 52
4368: PUSH
4369: EMPTY
4370: LIST
4371: PUSH
4372: LD_INT 21
4374: PUSH
4375: LD_INT 1
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 26
4384: PUSH
4385: LD_INT 1
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: PPUSH
4399: CALL_OW 69
4403: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4404: LD_ADDR_VAR 0 2
4408: PUSH
4409: LD_VAR 0 2
4413: PPUSH
4414: CALL 22460 0 1
4418: ST_TO_ADDR
// Sejkove = UnitFilter ( Lidi , [ [ F_CLASS , CLASS_DESERT_WARIOR ] ] ) ;
4419: LD_ADDR_VAR 0 3
4423: PUSH
4424: LD_VAR 0 2
4428: PPUSH
4429: LD_INT 25
4431: PUSH
4432: LD_INT 11
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: PUSH
4439: EMPTY
4440: LIST
4441: PPUSH
4442: CALL_OW 72
4446: ST_TO_ADDR
// if Sejkove then
4447: LD_VAR 0 3
4451: IFFALSE 4469
// Result = Sejkove [ 1 ] else
4453: LD_ADDR_VAR 0 1
4457: PUSH
4458: LD_VAR 0 3
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: ST_TO_ADDR
4467: GO 4499
// if Lidi then
4469: LD_VAR 0 2
4473: IFFALSE 4491
// Result = Lidi [ 1 ] else
4475: LD_ADDR_VAR 0 1
4479: PUSH
4480: LD_VAR 0 2
4484: PUSH
4485: LD_INT 1
4487: ARRAY
4488: ST_TO_ADDR
4489: GO 4499
// Result = 0 ;
4491: LD_ADDR_VAR 0 1
4495: PUSH
4496: LD_INT 0
4498: ST_TO_ADDR
// end ;
4499: LD_VAR 0 1
4503: RET
// function najdi_araba ; var Lidi ; begin
4504: LD_INT 0
4506: PPUSH
4507: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4508: LD_ADDR_VAR 0 2
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_EXP 3
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: LD_INT 50
4527: PUSH
4528: EMPTY
4529: LIST
4530: PUSH
4531: LD_INT 52
4533: PUSH
4534: EMPTY
4535: LIST
4536: PUSH
4537: LD_INT 21
4539: PUSH
4540: LD_INT 1
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PUSH
4547: LD_INT 26
4549: PUSH
4550: LD_INT 1
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: LIST
4562: LIST
4563: PPUSH
4564: CALL_OW 69
4568: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4569: LD_ADDR_VAR 0 2
4573: PUSH
4574: LD_VAR 0 2
4578: PPUSH
4579: CALL 22460 0 1
4583: ST_TO_ADDR
// if Lidi then
4584: LD_VAR 0 2
4588: IFFALSE 4606
// Result = Lidi [ 1 ] else
4590: LD_ADDR_VAR 0 1
4594: PUSH
4595: LD_VAR 0 2
4599: PUSH
4600: LD_INT 1
4602: ARRAY
4603: ST_TO_ADDR
4604: GO 4614
// Result = 0 ;
4606: LD_ADDR_VAR 0 1
4610: PUSH
4611: LD_INT 0
4613: ST_TO_ADDR
// end ;
4614: LD_VAR 0 1
4618: RET
// export function dialog_Start ; var V ; begin
4619: LD_INT 0
4621: PPUSH
4622: PPUSH
// V = najdi_vojaka ;
4623: LD_ADDR_VAR 0 2
4627: PUSH
4628: CALL 3909 0 0
4632: ST_TO_ADDR
// if not V then
4633: LD_VAR 0 2
4637: NOT
4638: IFFALSE 4650
// V = najdi_nekoho ;
4640: LD_ADDR_VAR 0 2
4644: PUSH
4645: CALL 3646 0 0
4649: ST_TO_ADDR
// if V then
4650: LD_VAR 0 2
4654: IFFALSE 4668
// Say ( V , DStart-RSol1-1 ) ;
4656: LD_VAR 0 2
4660: PPUSH
4661: LD_STRING DStart-RSol1-1
4663: PPUSH
4664: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
4668: LD_EXP 6
4672: PPUSH
4673: LD_STRING DStart-Bur-1
4675: PPUSH
4676: CALL_OW 88
// end ;
4680: LD_VAR 0 1
4684: RET
// export function dialog_AmAttack ; var G ; begin
4685: LD_INT 0
4687: PPUSH
4688: PPUSH
// if Gladkov then
4689: LD_EXP 26
4693: IFFALSE 4707
// G = Gladkov else
4695: LD_ADDR_VAR 0 2
4699: PUSH
4700: LD_EXP 26
4704: ST_TO_ADDR
4705: GO 4717
// G = GladkovFake ;
4707: LD_ADDR_VAR 0 2
4711: PUSH
4712: LD_EXP 27
4716: ST_TO_ADDR
// SayRadio ( G , DAmAttack-Gla-1 ) ;
4717: LD_VAR 0 2
4721: PPUSH
4722: LD_STRING DAmAttack-Gla-1
4724: PPUSH
4725: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-1 ) ;
4729: LD_EXP 6
4733: PPUSH
4734: LD_STRING DAmAttack-Bur-1
4736: PPUSH
4737: CALL_OW 94
// SayRadio ( G , DAmAttack-Gla-2 ) ;
4741: LD_VAR 0 2
4745: PPUSH
4746: LD_STRING DAmAttack-Gla-2
4748: PPUSH
4749: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-2 ) ;
4753: LD_EXP 6
4757: PPUSH
4758: LD_STRING DAmAttack-Bur-2
4760: PPUSH
4761: CALL_OW 94
// Say ( Burlak , DAmAttack-Bur-2a ) ;
4765: LD_EXP 6
4769: PPUSH
4770: LD_STRING DAmAttack-Bur-2a
4772: PPUSH
4773: CALL_OW 88
// end ;
4777: LD_VAR 0 1
4781: RET
// export function dialog_LegionOfferHeike1 ; begin
4782: LD_INT 0
4784: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-1 ) ;
4785: LD_EXP 28
4789: PPUSH
4790: LD_STRING DLegionOfferHeike1-Hke-1
4792: PPUSH
4793: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-1 ) ;
4797: LD_EXP 6
4801: PPUSH
4802: LD_STRING DLegionOfferHeike1-Bur-1
4804: PPUSH
4805: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2 ) ;
4809: LD_EXP 28
4813: PPUSH
4814: LD_STRING DLegionOfferHeike1-Hke-2
4816: PPUSH
4817: CALL_OW 94
// end ;
4821: LD_VAR 0 1
4825: RET
// export function dialog_LegionOfferHeike2 ; begin
4826: LD_INT 0
4828: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2a ) ;
4829: LD_EXP 28
4833: PPUSH
4834: LD_STRING DLegionOfferHeike1-Hke-2a
4836: PPUSH
4837: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-2 ) ;
4841: LD_EXP 6
4845: PPUSH
4846: LD_STRING DLegionOfferHeike1-Bur-2
4848: PPUSH
4849: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-3 ) ;
4853: LD_EXP 28
4857: PPUSH
4858: LD_STRING DLegionOfferHeike1-Hke-3
4860: PPUSH
4861: CALL_OW 94
// end ;
4865: LD_VAR 0 1
4869: RET
// export function dialog_LegionOfferHeikeCont ; begin
4870: LD_INT 0
4872: PPUSH
// SayRadio ( Heike , DLegionOfferHeikeCont-Hke-1 ) ;
4873: LD_EXP 28
4877: PPUSH
4878: LD_STRING DLegionOfferHeikeCont-Hke-1
4880: PPUSH
4881: CALL_OW 94
// end ;
4885: LD_VAR 0 1
4889: RET
// export function query_LegionHeike ; begin
4890: LD_INT 0
4892: PPUSH
// Result = Query ( QLegionHeike ) ;
4893: LD_ADDR_VAR 0 1
4897: PUSH
4898: LD_STRING QLegionHeike
4900: PPUSH
4901: CALL_OW 97
4905: ST_TO_ADDR
// end ;
4906: LD_VAR 0 1
4910: RET
// export function dialog_QrLegionHeike13 ; begin
4911: LD_INT 0
4913: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#1-2-Bur-1 ) ;
4914: LD_EXP 6
4918: PPUSH
4919: LD_STRING DQrLegionHeike#1-2-Bur-1
4921: PPUSH
4922: CALL_OW 94
// end ;
4926: LD_VAR 0 1
4930: RET
// export function dialog_QrLegionHeike4 ; begin
4931: LD_INT 0
4933: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#3-Bur-1 ) ;
4934: LD_EXP 6
4938: PPUSH
4939: LD_STRING DQrLegionHeike#3-Bur-1
4941: PPUSH
4942: CALL_OW 94
// end ;
4946: LD_VAR 0 1
4950: RET
// export function dialog_LegionOfferFarmer ; begin
4951: LD_INT 0
4953: PPUSH
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-1 ) ;
4954: LD_EXP 29
4958: PPUSH
4959: LD_STRING DLegionOfferFarmer-Frm-1
4961: PPUSH
4962: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferFarmer-Bur-1 ) ;
4966: LD_EXP 6
4970: PPUSH
4971: LD_STRING DLegionOfferFarmer-Bur-1
4973: PPUSH
4974: CALL_OW 94
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-2 ) ;
4978: LD_EXP 29
4982: PPUSH
4983: LD_STRING DLegionOfferFarmer-Frm-2
4985: PPUSH
4986: CALL_OW 94
// end ;
4990: LD_VAR 0 1
4994: RET
// export function query_LegionFarmer ; begin
4995: LD_INT 0
4997: PPUSH
// Result = Query ( QLegionFarmer ) ;
4998: LD_ADDR_VAR 0 1
5002: PUSH
5003: LD_STRING QLegionFarmer
5005: PPUSH
5006: CALL_OW 97
5010: ST_TO_ADDR
// end ;
5011: LD_VAR 0 1
5015: RET
// export function dialog_QrLegionFarmer13 ; begin
5016: LD_INT 0
5018: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#1-3-Bur-1 ) ;
5019: LD_EXP 6
5023: PPUSH
5024: LD_STRING DQrLegionFarmer#1-3-Bur-1
5026: PPUSH
5027: CALL_OW 94
// end ;
5031: LD_VAR 0 1
5035: RET
// export function dialog_QrLegionFarmer4 ; begin
5036: LD_INT 0
5038: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#4-Bur-1 ) ;
5039: LD_EXP 6
5043: PPUSH
5044: LD_STRING DQrLegionFarmer#4-Bur-1
5046: PPUSH
5047: CALL_OW 94
// end ;
5051: LD_VAR 0 1
5055: RET
// export function dialog_LegionFugit ; begin
5056: LD_INT 0
5058: PPUSH
// Say ( Bergkamp , DLegionFugit-Brg-1 ) ;
5059: LD_EXP 30
5063: PPUSH
5064: LD_STRING DLegionFugit-Brg-1
5066: PPUSH
5067: CALL_OW 88
// Say ( Burlak , DLegionFugit-Bur-1 ) ;
5071: LD_EXP 6
5075: PPUSH
5076: LD_STRING DLegionFugit-Bur-1
5078: PPUSH
5079: CALL_OW 88
// Say ( Bergkamp , DLegionFugit-Brg-2 ) ;
5083: LD_EXP 30
5087: PPUSH
5088: LD_STRING DLegionFugit-Brg-2
5090: PPUSH
5091: CALL_OW 88
// end ;
5095: LD_VAR 0 1
5099: RET
// export function query_LegionBergkamp ; begin
5100: LD_INT 0
5102: PPUSH
// Result = Query ( QLegionBergkamp ) ;
5103: LD_ADDR_VAR 0 1
5107: PUSH
5108: LD_STRING QLegionBergkamp
5110: PPUSH
5111: CALL_OW 97
5115: ST_TO_ADDR
// end ;
5116: LD_VAR 0 1
5120: RET
// export function dialog_QrLegionBergkamp1 ; begin
5121: LD_INT 0
5123: PPUSH
// Say ( Burlak , DQrLegionBergkamp#1-Bur-1 ) ;
5124: LD_EXP 6
5128: PPUSH
5129: LD_STRING DQrLegionBergkamp#1-Bur-1
5131: PPUSH
5132: CALL_OW 88
// Say ( Bergkamp , DQrLegionBergkamp#1-Brg-1 ) ;
5136: LD_EXP 30
5140: PPUSH
5141: LD_STRING DQrLegionBergkamp#1-Brg-1
5143: PPUSH
5144: CALL_OW 88
// end ;
5148: LD_VAR 0 1
5152: RET
// export function dialog_QrLegionBergkamp2 ; begin
5153: LD_INT 0
5155: PPUSH
// Say ( Burlak , DQrLegionBergkamp#2-Bur-1 ) ;
5156: LD_EXP 6
5160: PPUSH
5161: LD_STRING DQrLegionBergkamp#2-Bur-1
5163: PPUSH
5164: CALL_OW 88
// end ;
5168: LD_VAR 0 1
5172: RET
// export function dialog_LegionLeave ; begin
5173: LD_INT 0
5175: PPUSH
// if not IsOk ( Bergkamp ) then
5176: LD_EXP 30
5180: PPUSH
5181: CALL_OW 302
5185: NOT
5186: IFFALSE 5190
// exit ;
5188: GO 5246
// if LegionOffer_Accepted then
5190: LD_EXP 59
5194: IFFALSE 5210
// Say ( Bergkamp , DLegionLeave-Brg-1 ) else
5196: LD_EXP 30
5200: PPUSH
5201: LD_STRING DLegionLeave-Brg-1
5203: PPUSH
5204: CALL_OW 88
5208: GO 5246
// begin Say ( Bergkamp , DLegionLeave-Brg-1a ) ;
5210: LD_EXP 30
5214: PPUSH
5215: LD_STRING DLegionLeave-Brg-1a
5217: PPUSH
5218: CALL_OW 88
// Say ( Burlak , DLegionLeave-Bur-1 ) ;
5222: LD_EXP 6
5226: PPUSH
5227: LD_STRING DLegionLeave-Bur-1
5229: PPUSH
5230: CALL_OW 88
// Say ( Bergkamp , DLegionLeave-Brg-2 ) ;
5234: LD_EXP 30
5238: PPUSH
5239: LD_STRING DLegionLeave-Brg-2
5241: PPUSH
5242: CALL_OW 88
// end ; end ;
5246: LD_VAR 0 1
5250: RET
// export function dialog_LegionSpy ; var V ; begin
5251: LD_INT 0
5253: PPUSH
5254: PPUSH
// V = najdi_vedce ;
5255: LD_ADDR_VAR 0 2
5259: PUSH
5260: CALL 4057 0 0
5264: ST_TO_ADDR
// if not V then
5265: LD_VAR 0 2
5269: NOT
5270: IFFALSE 5282
// V = najdi_nekoho ;
5272: LD_ADDR_VAR 0 2
5276: PUSH
5277: CALL 3646 0 0
5281: ST_TO_ADDR
// if V then
5282: LD_VAR 0 2
5286: IFFALSE 5300
// Say ( V , DLegionSpy-Sci1-1 ) ;
5288: LD_VAR 0 2
5292: PPUSH
5293: LD_STRING DLegionSpy-Sci1-1
5295: PPUSH
5296: CALL_OW 88
// Say ( Burlak , DLegionSpy-Bur-1 ) ;
5300: LD_EXP 6
5304: PPUSH
5305: LD_STRING DLegionSpy-Bur-1
5307: PPUSH
5308: CALL_OW 88
// end ;
5312: LD_VAR 0 1
5316: RET
// export function dialog_LegionChallengeHeike ; begin
5317: LD_INT 0
5319: PPUSH
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-1 ) ;
5320: LD_EXP 6
5324: PPUSH
5325: LD_STRING DLegionChallengeHeike-Bur-1
5327: PPUSH
5328: CALL_OW 94
// SayRadio ( Heike , DLegionChallengeHeike-Hke-1 ) ;
5332: LD_EXP 28
5336: PPUSH
5337: LD_STRING DLegionChallengeHeike-Hke-1
5339: PPUSH
5340: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-2 ) ;
5344: LD_EXP 6
5348: PPUSH
5349: LD_STRING DLegionChallengeHeike-Bur-2
5351: PPUSH
5352: CALL_OW 94
// if OmarKilled then
5356: LD_EXP 38
5360: IFFALSE 5374
// SayRadio ( Heike , DLegionChallengeHeike-Hke-2 ) ;
5362: LD_EXP 28
5366: PPUSH
5367: LD_STRING DLegionChallengeHeike-Hke-2
5369: PPUSH
5370: CALL_OW 94
// end ;
5374: LD_VAR 0 1
5378: RET
// export function dialog_LegionChallengeFarmer ; begin
5379: LD_INT 0
5381: PPUSH
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-1 ) ;
5382: LD_EXP 6
5386: PPUSH
5387: LD_STRING DLegionChallengeFarmer-Bur-1
5389: PPUSH
5390: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-1 ) ;
5394: LD_EXP 29
5398: PPUSH
5399: LD_STRING DLegionChallengeFarmer-Frm-1
5401: PPUSH
5402: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-2 ) ;
5406: LD_EXP 6
5410: PPUSH
5411: LD_STRING DLegionChallengeFarmer-Bur-2
5413: PPUSH
5414: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-2 ) ;
5418: LD_EXP 29
5422: PPUSH
5423: LD_STRING DLegionChallengeFarmer-Frm-2
5425: PPUSH
5426: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-3 ) ;
5430: LD_EXP 6
5434: PPUSH
5435: LD_STRING DLegionChallengeFarmer-Bur-3
5437: PPUSH
5438: CALL_OW 94
// end ;
5442: LD_VAR 0 1
5446: RET
// export function dialog_Contam ; var V ; begin
5447: LD_INT 0
5449: PPUSH
5450: PPUSH
// V = najdi_vedce ;
5451: LD_ADDR_VAR 0 2
5455: PUSH
5456: CALL 4057 0 0
5460: ST_TO_ADDR
// if not V then
5461: LD_VAR 0 2
5465: NOT
5466: IFFALSE 5478
// V = najdi_nekoho ;
5468: LD_ADDR_VAR 0 2
5472: PUSH
5473: CALL 3646 0 0
5477: ST_TO_ADDR
// if V and ( V <> Burlak ) then
5478: LD_VAR 0 2
5482: PUSH
5483: LD_VAR 0 2
5487: PUSH
5488: LD_EXP 6
5492: NONEQUAL
5493: AND
5494: IFFALSE 5544
// begin Say ( V , DContam-Sci1-1 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_STRING DContam-Sci1-1
5503: PPUSH
5504: CALL_OW 88
// Say ( Burlak , DContam-Bur-1 ) ;
5508: LD_EXP 6
5512: PPUSH
5513: LD_STRING DContam-Bur-1
5515: PPUSH
5516: CALL_OW 88
// Say ( V , DContam-Sci1-2 ) ;
5520: LD_VAR 0 2
5524: PPUSH
5525: LD_STRING DContam-Sci1-2
5527: PPUSH
5528: CALL_OW 88
// Say ( Burlak , DContam-Bur-2 ) ;
5532: LD_EXP 6
5536: PPUSH
5537: LD_STRING DContam-Bur-2
5539: PPUSH
5540: CALL_OW 88
// end ; end ;
5544: LD_VAR 0 1
5548: RET
// export function dialog_SurrenderArabians ; var V ; begin
5549: LD_INT 0
5551: PPUSH
5552: PPUSH
// if IsOK ( Abdul ) then
5553: LD_EXP 31
5557: PPUSH
5558: CALL_OW 302
5562: IFFALSE 5578
// Say ( Abdul , DSurrenderArabians-Abd-1 ) else
5564: LD_EXP 31
5568: PPUSH
5569: LD_STRING DSurrenderArabians-Abd-1
5571: PPUSH
5572: CALL_OW 88
5576: GO 5652
// begin if Omar and IsOk ( Omar ) then
5578: LD_EXP 32
5582: PUSH
5583: LD_EXP 32
5587: PPUSH
5588: CALL_OW 302
5592: AND
5593: IFFALSE 5607
// V = Omar else
5595: LD_ADDR_VAR 0 2
5599: PUSH
5600: LD_EXP 32
5604: ST_TO_ADDR
5605: GO 5617
// V = najdi_sejka ;
5607: LD_ADDR_VAR 0 2
5611: PUSH
5612: CALL 4338 0 0
5616: ST_TO_ADDR
// if not V then
5617: LD_VAR 0 2
5621: NOT
5622: IFFALSE 5634
// V = najdi_araba ;
5624: LD_ADDR_VAR 0 2
5628: PUSH
5629: CALL 4504 0 0
5633: ST_TO_ADDR
// if V then
5634: LD_VAR 0 2
5638: IFFALSE 5652
// Say ( V , DSurrenderArabians-ArSol1-1 ) ;
5640: LD_VAR 0 2
5644: PPUSH
5645: LD_STRING DSurrenderArabians-ArSol1-1
5647: PPUSH
5648: CALL_OW 88
// end ; end ;
5652: LD_VAR 0 1
5656: RET
// export function dialog_BehemothTechno1 ; var V ; begin
5657: LD_INT 0
5659: PPUSH
5660: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-1 ) ;
5661: LD_EXP 6
5665: PPUSH
5666: LD_STRING DBehemothTechno-Bur-1
5668: PPUSH
5669: CALL_OW 88
// if Petrosyan and IsOk ( Petrosyan ) then
5673: LD_EXP 16
5677: PUSH
5678: LD_EXP 16
5682: PPUSH
5683: CALL_OW 302
5687: AND
5688: IFFALSE 5704
// Say ( Petrosyan , DBehemothTechno-Pty-1 ) else
5690: LD_EXP 16
5694: PPUSH
5695: LD_STRING DBehemothTechno-Pty-1
5697: PPUSH
5698: CALL_OW 88
5702: GO 5787
// begin V = najdi_vedceMF ;
5704: LD_ADDR_VAR 0 2
5708: PUSH
5709: CALL 4203 0 0
5713: ST_TO_ADDR
// if not V then
5714: LD_VAR 0 2
5718: NOT
5719: IFFALSE 5731
// V = najdi_nekoho ;
5721: LD_ADDR_VAR 0 2
5725: PUSH
5726: CALL 3646 0 0
5730: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5731: LD_VAR 0 2
5735: PPUSH
5736: CALL_OW 258
5740: PUSH
5741: LD_INT 1
5743: EQUAL
5744: IFFALSE 5760
// Say ( V , DBehemothTechno-Sci-1 ) else
5746: LD_VAR 0 2
5750: PPUSH
5751: LD_STRING DBehemothTechno-Sci-1
5753: PPUSH
5754: CALL_OW 88
5758: GO 5787
// if GetSex ( V ) = SEX_FEMALE then
5760: LD_VAR 0 2
5764: PPUSH
5765: CALL_OW 258
5769: PUSH
5770: LD_INT 2
5772: EQUAL
5773: IFFALSE 5787
// Say ( V , DBehemothTechno-FSci1-1 ) ;
5775: LD_VAR 0 2
5779: PPUSH
5780: LD_STRING DBehemothTechno-FSci1-1
5782: PPUSH
5783: CALL_OW 88
// end ; end ;
5787: LD_VAR 0 1
5791: RET
// export function dialog_BehemothTechno2 ; var V ; begin
5792: LD_INT 0
5794: PPUSH
5795: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-2 ) ;
5796: LD_EXP 6
5800: PPUSH
5801: LD_STRING DBehemothTechno-Bur-2
5803: PPUSH
5804: CALL_OW 88
// V = najdi_vedceMF ;
5808: LD_ADDR_VAR 0 2
5812: PUSH
5813: CALL 4203 0 0
5817: ST_TO_ADDR
// if not V then
5818: LD_VAR 0 2
5822: NOT
5823: IFFALSE 5835
// V = najdi_nekoho ;
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: CALL 3646 0 0
5834: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5835: LD_VAR 0 2
5839: PPUSH
5840: CALL_OW 258
5844: PUSH
5845: LD_INT 1
5847: EQUAL
5848: IFFALSE 5864
// Say ( V , DBehemothTechno-Sci-2 ) else
5850: LD_VAR 0 2
5854: PPUSH
5855: LD_STRING DBehemothTechno-Sci-2
5857: PPUSH
5858: CALL_OW 88
5862: GO 5891
// if GetSex ( V ) = SEX_FEMALE then
5864: LD_VAR 0 2
5868: PPUSH
5869: CALL_OW 258
5873: PUSH
5874: LD_INT 2
5876: EQUAL
5877: IFFALSE 5891
// Say ( V , DBehemothTechno-FSci1-2 ) ;
5879: LD_VAR 0 2
5883: PPUSH
5884: LD_STRING DBehemothTechno-FSci1-2
5886: PPUSH
5887: CALL_OW 88
// end ;
5891: LD_VAR 0 1
5895: RET
// export function dialog_BehemothComplete ; var Vsichni , Seznam , Vedci , Kdo ; begin
5896: LD_INT 0
5898: PPUSH
5899: PPUSH
5900: PPUSH
5901: PPUSH
5902: PPUSH
// Seznam = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
5903: LD_ADDR_VAR 0 3
5907: PUSH
5908: LD_INT 22
5910: PUSH
5911: LD_EXP 2
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 50
5922: PUSH
5923: EMPTY
5924: LIST
5925: PUSH
5926: LD_INT 52
5928: PUSH
5929: EMPTY
5930: LIST
5931: PUSH
5932: LD_INT 21
5934: PUSH
5935: LD_INT 1
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 26
5944: PUSH
5945: LD_INT 1
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PPUSH
5959: CALL_OW 69
5963: PUSH
5964: LD_EXP 6
5968: PUSH
5969: EMPTY
5970: LIST
5971: DIFF
5972: ST_TO_ADDR
// Vedci = UnitFilter ( Vsichni , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
5973: LD_ADDR_VAR 0 4
5977: PUSH
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_INT 25
5985: PUSH
5986: LD_INT 4
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PUSH
5993: EMPTY
5994: LIST
5995: PPUSH
5996: CALL_OW 72
6000: ST_TO_ADDR
// Vsichni = Vedci ^ ( Seznam diff Vedci ) ;
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 4
6010: PUSH
6011: LD_VAR 0 3
6015: PUSH
6016: LD_VAR 0 4
6020: DIFF
6021: ADD
6022: ST_TO_ADDR
// if Vsichni >= 1 then
6023: LD_VAR 0 2
6027: PUSH
6028: LD_INT 1
6030: GREATEREQUAL
6031: IFFALSE 6083
// begin Kdo = Vsichni [ 1 ] ;
6033: LD_ADDR_VAR 0 5
6037: PUSH
6038: LD_VAR 0 2
6042: PUSH
6043: LD_INT 1
6045: ARRAY
6046: ST_TO_ADDR
// Say ( Kdo , DBehemothComplete-Sci-1 ) ;
6047: LD_VAR 0 5
6051: PPUSH
6052: LD_STRING DBehemothComplete-Sci-1
6054: PPUSH
6055: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1a ) ;
6059: LD_VAR 0 5
6063: PPUSH
6064: LD_STRING DBehemothComplete-Sci-1a
6066: PPUSH
6067: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1b ) ;
6071: LD_VAR 0 5
6075: PPUSH
6076: LD_STRING DBehemothComplete-Sci-1b
6078: PPUSH
6079: CALL_OW 88
// end ; Hint ( Behemoth ) ;
6083: LD_STRING Behemoth
6085: PPUSH
6086: CALL_OW 339
// end ; end_of_file
6090: LD_VAR 0 1
6094: RET
// export LegionOffer_Heike , LegionOffer_Accepted , LegionFugit_Accepted ; var LeSci1 , LeSci2 , LeMech1 , LeMech2 , LeEng ; var Obranci , Mechanici ; var Ridici ; export Uprchlici ; var Uprchlici_JsouTam ; var Uprchlici_X , Uprchlici_Y ; var KonvojPopojizdi ; var Nabidka_Nakladaky , Nabidka_Ridici , Nabidka_Cena , Nabidka_Lidi ; var Nabidka_Nalozeno , Nabidka_Vylozeno ; var Makro ; var KdoLeci , KdoOpravuje ; var ProbihaPredavaniSurovin ; var MamPrebarvit ; export function init_legion ; var Base , Reg ; begin
6095: LD_INT 0
6097: PPUSH
6098: PPUSH
6099: PPUSH
// disable ( 11 ) ;
6100: LD_INT 11
6102: DISABLE_MARKED
// disable ( 12 ) ;
6103: LD_INT 12
6105: DISABLE_MARKED
// disable ( 13 ) ;
6106: LD_INT 13
6108: DISABLE_MARKED
// disable ( 14 ) ;
6109: LD_INT 14
6111: DISABLE_MARKED
// disable ( 15 ) ;
6112: LD_INT 15
6114: DISABLE_MARKED
// disable ( 16 ) ;
6115: LD_INT 16
6117: DISABLE_MARKED
// if Difficulty = 1 then
6118: LD_OWVAR 67
6122: PUSH
6123: LD_INT 1
6125: EQUAL
6126: IFFALSE 6181
// begin DestroyUnit ( LeBunk2 ) ;
6128: LD_INT 28
6130: PPUSH
6131: CALL_OW 65
// DestroyUnit ( LeBunk4 ) ;
6135: LD_INT 40
6137: PPUSH
6138: CALL_OW 65
// DestroyUnit ( LeBunk6 ) ;
6142: LD_INT 31
6144: PPUSH
6145: CALL_OW 65
// PlaceWeaponTurret ( LeBunk1 , AR_FLAME_THROWER ) ;
6149: LD_INT 27
6151: PPUSH
6152: LD_INT 26
6154: PPUSH
6155: CALL_OW 431
// PlaceWeaponTurret ( LeBunk5 , AR_FLAME_THROWER ) ;
6159: LD_INT 30
6161: PPUSH
6162: LD_INT 26
6164: PPUSH
6165: CALL_OW 431
// PlaceWeaponTurret ( LeBunk7 , AR_GUN ) ;
6169: LD_INT 22
6171: PPUSH
6172: LD_INT 27
6174: PPUSH
6175: CALL_OW 431
// end else
6179: GO 6198
// if Difficulty = 2 then
6181: LD_OWVAR 67
6185: PUSH
6186: LD_INT 2
6188: EQUAL
6189: IFFALSE 6198
// begin DestroyUnit ( LeBunk2 ) ;
6191: LD_INT 28
6193: PPUSH
6194: CALL_OW 65
// end ; LegionOffer_Heike = false ;
6198: LD_ADDR_EXP 58
6202: PUSH
6203: LD_INT 0
6205: ST_TO_ADDR
// LegionOffer_Accepted = false ;
6206: LD_ADDR_EXP 59
6210: PUSH
6211: LD_INT 0
6213: ST_TO_ADDR
// LegionFugit_Accepted = false ;
6214: LD_ADDR_EXP 60
6218: PUSH
6219: LD_INT 0
6221: ST_TO_ADDR
// Uprchlici = [ ] ;
6222: LD_ADDR_EXP 61
6226: PUSH
6227: EMPTY
6228: ST_TO_ADDR
// Uprchlici_JsouTam = false ;
6229: LD_ADDR_LOC 13
6233: PUSH
6234: LD_INT 0
6236: ST_TO_ADDR
// Uprchlici_X = Uprchlici_Y = 0 ;
6237: LD_ADDR_LOC 14
6241: PUSH
6242: LD_LOC 15
6246: PUSH
6247: LD_INT 0
6249: EQUAL
6250: ST_TO_ADDR
// KonvojPopojizdi = false ;
6251: LD_ADDR_LOC 16
6255: PUSH
6256: LD_INT 0
6258: ST_TO_ADDR
// Nabidka_Nakladaky = [ ] ;
6259: LD_ADDR_LOC 17
6263: PUSH
6264: EMPTY
6265: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
6266: LD_ADDR_LOC 18
6270: PUSH
6271: EMPTY
6272: ST_TO_ADDR
// Nabidka_Cena = [ 0 , 0 ] ;
6273: LD_ADDR_LOC 19
6277: PUSH
6278: LD_INT 0
6280: PUSH
6281: LD_INT 0
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
6288: LD_ADDR_LOC 20
6292: PUSH
6293: LD_INT 0
6295: ST_TO_ADDR
// Nabidka_Nalozeno = false ;
6296: LD_ADDR_LOC 21
6300: PUSH
6301: LD_INT 0
6303: ST_TO_ADDR
// Nabidka_Vylozeno = false ;
6304: LD_ADDR_LOC 22
6308: PUSH
6309: LD_INT 0
6311: ST_TO_ADDR
// KdoLeci = [ ] ;
6312: LD_ADDR_LOC 24
6316: PUSH
6317: EMPTY
6318: ST_TO_ADDR
// KdoOpravuje = [ ] ;
6319: LD_ADDR_LOC 25
6323: PUSH
6324: EMPTY
6325: ST_TO_ADDR
// ProbihaPredavaniSurovin = false ;
6326: LD_ADDR_LOC 26
6330: PUSH
6331: LD_INT 0
6333: ST_TO_ADDR
// vytvor_postavy ;
6334: CALL 6532 0 0
// Base = GetBase ( LeDepot ) ;
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_INT 20
6345: PPUSH
6346: CALL_OW 274
6350: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 600 , 700 ) ) ;
6351: LD_VAR 0 2
6355: PPUSH
6356: LD_INT 1
6358: PPUSH
6359: LD_INT 600
6361: PPUSH
6362: LD_INT 700
6364: PPUSH
6365: CALL_OW 12
6369: PPUSH
6370: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 800 , 1200 ) ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_INT 2
6381: PPUSH
6382: LD_INT 800
6384: PPUSH
6385: LD_INT 1200
6387: PPUSH
6388: CALL_OW 12
6392: PPUSH
6393: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 200 , 300 ) ) ;
6397: LD_VAR 0 2
6401: PPUSH
6402: LD_INT 3
6404: PPUSH
6405: LD_INT 200
6407: PPUSH
6408: LD_INT 300
6410: PPUSH
6411: CALL_OW 12
6415: PPUSH
6416: CALL_OW 277
// Reg = McRegistry ( side_Le , [ [ MC_REG_AREA_TO_PROTECT , LegionObrana ] ] ) ;
6420: LD_ADDR_VAR 0 3
6424: PUSH
6425: LD_EXP 4
6429: PPUSH
6430: LD_INT 3
6432: PUSH
6433: LD_INT 16
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: EMPTY
6441: LIST
6442: PPUSH
6443: CALL_OW 399
6447: ST_TO_ADDR
// Makro = McDefend ( 0 , Reg , Obranci union Mechanici union Ridici union [ LeBunk1 , LeBunk2 , LeBunk3 , LeBunk4 , Lebunk5 , LeBunk6 , LeBunk7 ] , [ [ MC_AREA_DONT_LEAVE , Legion ] ] ) ;
6448: LD_ADDR_LOC 23
6452: PUSH
6453: LD_INT 0
6455: PPUSH
6456: LD_VAR 0 3
6460: PPUSH
6461: LD_LOC 10
6465: PUSH
6466: LD_LOC 11
6470: UNION
6471: PUSH
6472: LD_LOC 12
6476: UNION
6477: PUSH
6478: LD_INT 27
6480: PUSH
6481: LD_INT 28
6483: PUSH
6484: LD_INT 29
6486: PUSH
6487: LD_INT 40
6489: PUSH
6490: LD_INT 30
6492: PUSH
6493: LD_INT 31
6495: PUSH
6496: LD_INT 22
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: UNION
6508: PPUSH
6509: LD_INT 2
6511: PUSH
6512: LD_INT 4
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: PUSH
6519: EMPTY
6520: LIST
6521: PPUSH
6522: CALL_OW 401
6526: ST_TO_ADDR
// end ;
6527: LD_VAR 0 1
6531: RET
// function vytvor_postavy ; var Bunkry , B ; begin
6532: LD_INT 0
6534: PPUSH
6535: PPUSH
6536: PPUSH
// LeSci1 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6537: LD_ADDR_LOC 5
6541: PUSH
6542: LD_INT 25
6544: PPUSH
6545: LD_INT 4
6547: PPUSH
6548: CALL 6855 0 2
6552: ST_TO_ADDR
// LeSci2 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6553: LD_ADDR_LOC 6
6557: PUSH
6558: LD_INT 25
6560: PPUSH
6561: LD_INT 4
6563: PPUSH
6564: CALL 6855 0 2
6568: ST_TO_ADDR
// LeMech1 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6569: LD_ADDR_LOC 7
6573: PUSH
6574: LD_INT 26
6576: PPUSH
6577: LD_INT 3
6579: PPUSH
6580: CALL 6855 0 2
6584: ST_TO_ADDR
// LeMech2 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6585: LD_ADDR_LOC 8
6589: PUSH
6590: LD_INT 26
6592: PPUSH
6593: LD_INT 3
6595: PPUSH
6596: CALL 6855 0 2
6600: ST_TO_ADDR
// vytvor_postavu_B ( LeDepot , CLASS_ENGINEER ) ;
6601: LD_INT 20
6603: PPUSH
6604: LD_INT 2
6606: PPUSH
6607: CALL 6855 0 2
// LeEng = vytvor_postavu_A ( Legion , CLASS_ENGINEER ) ;
6611: LD_ADDR_LOC 9
6615: PUSH
6616: LD_INT 4
6618: PPUSH
6619: LD_INT 2
6621: PPUSH
6622: CALL 6892 0 2
6626: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 3 , Legion , CLASS_SOLDIER ) ;
6627: LD_ADDR_LOC 10
6631: PUSH
6632: LD_INT 3
6634: PPUSH
6635: LD_INT 4
6637: PPUSH
6638: LD_INT 1
6640: PPUSH
6641: CALL 6932 0 3
6645: ST_TO_ADDR
// Mechanici = vytvor_postavy_A ( 2 , Legion , CLASS_MECHANIC ) ;
6646: LD_ADDR_LOC 11
6650: PUSH
6651: LD_INT 2
6653: PPUSH
6654: LD_INT 4
6656: PPUSH
6657: LD_INT 3
6659: PPUSH
6660: CALL 6932 0 3
6664: ST_TO_ADDR
// Ridici = Mechanici union vytvor_postavy_A ( dif_LegionRidici [ Difficulty ] , Legion , CLASS_SOLDIER ) ;
6665: LD_ADDR_LOC 12
6669: PUSH
6670: LD_LOC 11
6674: PUSH
6675: LD_EXP 45
6679: PUSH
6680: LD_OWVAR 67
6684: ARRAY
6685: PPUSH
6686: LD_INT 4
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: CALL 6932 0 3
6696: UNION
6697: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: LD_INT 22
6705: PUSH
6706: LD_EXP 4
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PUSH
6715: LD_INT 21
6717: PUSH
6718: LD_INT 3
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: PUSH
6725: LD_INT 30
6727: PUSH
6728: LD_INT 32
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: PPUSH
6740: CALL_OW 69
6744: ST_TO_ADDR
// for B in Bunkry do
6745: LD_ADDR_VAR 0 3
6749: PUSH
6750: LD_VAR 0 2
6754: PUSH
6755: FOR_IN
6756: IFFALSE 6772
// vytvor_postavu_B ( B , CLASS_SOLDIER ) ;
6758: LD_VAR 0 3
6762: PPUSH
6763: LD_INT 1
6765: PPUSH
6766: CALL 6855 0 2
6770: GO 6755
6772: POP
6773: POP
// end ;
6774: LD_VAR 0 1
6778: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
6779: LD_INT 0
6781: PPUSH
6782: PPUSH
6783: PPUSH
// UC_Side = side_Le ;
6784: LD_ADDR_OWVAR 20
6788: PUSH
6789: LD_EXP 4
6793: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
6794: LD_ADDR_OWVAR 21
6798: PUSH
6799: LD_INT 2
6801: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
6802: LD_ADDR_OWVAR 27
6806: PUSH
6807: LD_INT 1
6809: PPUSH
6810: LD_INT 2
6812: PPUSH
6813: CALL_OW 12
6817: ST_TO_ADDR
// HC_Class = Cls ;
6818: LD_ADDR_OWVAR 28
6822: PUSH
6823: LD_VAR 0 1
6827: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
6828: LD_VAR 0 1
6832: PPUSH
6833: LD_INT 7
6835: PPUSH
6836: CALL_OW 374
// Result = CreateHuman ;
6840: LD_ADDR_VAR 0 2
6844: PUSH
6845: CALL_OW 44
6849: ST_TO_ADDR
// end ;
6850: LD_VAR 0 2
6854: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
6855: LD_INT 0
6857: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6858: LD_ADDR_VAR 0 3
6862: PUSH
6863: LD_VAR 0 2
6867: PPUSH
6868: CALL 6779 0 1
6872: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
6873: LD_VAR 0 3
6877: PPUSH
6878: LD_VAR 0 1
6882: PPUSH
6883: CALL_OW 52
// end ;
6887: LD_VAR 0 3
6891: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
6892: LD_INT 0
6894: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 2
6904: PPUSH
6905: CALL 6779 0 1
6909: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
6910: LD_VAR 0 3
6914: PPUSH
6915: LD_VAR 0 1
6919: PPUSH
6920: LD_INT 0
6922: PPUSH
6923: CALL_OW 49
// end ;
6927: LD_VAR 0 3
6931: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
6932: LD_INT 0
6934: PPUSH
6935: PPUSH
// Result = [ ] ;
6936: LD_ADDR_VAR 0 4
6940: PUSH
6941: EMPTY
6942: ST_TO_ADDR
// for I = 1 to Pocet do
6943: LD_ADDR_VAR 0 5
6947: PUSH
6948: DOUBLE
6949: LD_INT 1
6951: DEC
6952: ST_TO_ADDR
6953: LD_VAR 0 1
6957: PUSH
6958: FOR_TO
6959: IFFALSE 6992
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
6961: LD_ADDR_VAR 0 4
6965: PUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_VAR 0 2
6975: PPUSH
6976: LD_VAR 0 3
6980: PPUSH
6981: CALL 6892 0 2
6985: PUSH
6986: EMPTY
6987: LIST
6988: UNION
6989: ST_TO_ADDR
6990: GO 6958
6992: POP
6993: POP
// end ;
6994: LD_VAR 0 4
6998: RET
// function zacni_vynalezat ; begin
6999: LD_INT 0
7001: PPUSH
// AddComResearch ( LeLab , TECH_ROCKET ) ;
7002: LD_INT 25
7004: PPUSH
7005: LD_INT 40
7007: PPUSH
7008: CALL_OW 184
// AddComResearch ( LeLab , TECH_FLAME ) ;
7012: LD_INT 25
7014: PPUSH
7015: LD_INT 70
7017: PPUSH
7018: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIBCONTAM ) ;
7022: LD_INT 25
7024: PPUSH
7025: LD_INT 26
7027: PPUSH
7028: CALL_OW 184
// AddComResearch ( LeLab , TECH_MORTAR ) ;
7032: LD_INT 25
7034: PPUSH
7035: LD_INT 41
7037: PPUSH
7038: CALL_OW 184
// AddComResearch ( LeLab , TECH_EXPLOS ) ;
7042: LD_INT 25
7044: PPUSH
7045: LD_INT 42
7047: PPUSH
7048: CALL_OW 184
// AddComResearch ( LeLab , TECH_SELFDEST ) ;
7052: LD_INT 25
7054: PPUSH
7055: LD_INT 43
7057: PPUSH
7058: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH1 ) ;
7062: LD_INT 25
7064: PPUSH
7065: LD_INT 48
7067: PPUSH
7068: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP1 ) ;
7072: LD_INT 25
7074: PPUSH
7075: LD_INT 51
7077: PPUSH
7078: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB1 ) ;
7082: LD_INT 25
7084: PPUSH
7085: LD_INT 54
7087: PPUSH
7088: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH2 ) ;
7092: LD_INT 25
7094: PPUSH
7095: LD_INT 49
7097: PPUSH
7098: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP2 ) ;
7102: LD_INT 25
7104: PPUSH
7105: LD_INT 52
7107: PPUSH
7108: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB2 ) ;
7112: LD_INT 25
7114: PPUSH
7115: LD_INT 55
7117: PPUSH
7118: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH3 ) ;
7122: LD_INT 25
7124: PPUSH
7125: LD_INT 50
7127: PPUSH
7128: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP3 ) ;
7132: LD_INT 25
7134: PPUSH
7135: LD_INT 53
7137: PPUSH
7138: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB3 ) ;
7142: LD_INT 25
7144: PPUSH
7145: LD_INT 56
7147: PPUSH
7148: CALL_OW 184
// end ;
7152: LD_VAR 0 1
7156: RET
// every 0 0$2.3 do
7157: GO 7159
7159: DISABLE
// begin zacni_vynalezat ;
7160: CALL 6999 0 0
// end ;
7164: END
// every 1 1$28 do var Inz ;
7165: GO 7167
7167: DISABLE
7168: LD_INT 0
7170: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
7171: LD_ADDR_VAR 0 1
7175: PUSH
7176: LD_INT 22
7178: PUSH
7179: LD_EXP 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 21
7190: PUSH
7191: LD_INT 1
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 25
7200: PUSH
7201: LD_INT 2
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: PPUSH
7213: CALL_OW 69
7217: ST_TO_ADDR
// sbirej_bedny ( Inz , Legion ) ;
7218: LD_VAR 0 1
7222: PPUSH
7223: LD_INT 4
7225: PPUSH
7226: CALL 21122 0 2
// opravuj_budovy ( Inz , Legion , side_Le ) ;
7230: LD_VAR 0 1
7234: PPUSH
7235: LD_INT 4
7237: PPUSH
7238: LD_EXP 4
7242: PPUSH
7243: CALL 21352 0 3
// enable ;
7247: ENABLE
// end ;
7248: PPOPN 1
7250: END
// function opravuj ; begin
7251: LD_INT 0
7253: PPUSH
// if KdoOpravuje then
7254: LD_LOC 25
7258: IFFALSE 7262
// exit ;
7260: GO 7299
// KdoOpravuje = opravuj_auta ( [ LeMech1 , LeMech2 ] , 113 , Legion , side_Le , [ ] ) ;
7262: LD_ADDR_LOC 25
7266: PUSH
7267: LD_LOC 7
7271: PUSH
7272: LD_LOC 8
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PPUSH
7281: LD_INT 113
7283: PPUSH
7284: LD_INT 4
7286: PPUSH
7287: LD_EXP 4
7291: PPUSH
7292: EMPTY
7293: PPUSH
7294: CALL 21870 0 5
7298: ST_TO_ADDR
// end ;
7299: LD_VAR 0 1
7303: RET
// function kuryruj ; begin
7304: LD_INT 0
7306: PPUSH
// if KdoLeci then
7307: LD_LOC 24
7311: IFFALSE 7315
// exit ;
7313: GO 7350
// KdoLeci = kuryruj_lidi ( [ LeSci1 , LeSci2 ] , 114 , Legion , side_Le ) ;
7315: LD_ADDR_LOC 24
7319: PUSH
7320: LD_LOC 5
7324: PUSH
7325: LD_LOC 6
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PPUSH
7334: LD_INT 114
7336: PPUSH
7337: LD_INT 4
7339: PPUSH
7340: LD_EXP 4
7344: PPUSH
7345: CALL 22172 0 4
7349: ST_TO_ADDR
// end ;
7350: LD_VAR 0 1
7354: RET
// export function event_LegionOprava ( Event ) ; begin
7355: LD_INT 0
7357: PPUSH
// case Event of 113 :
7358: LD_VAR 0 1
7362: PUSH
7363: LD_INT 113
7365: DOUBLE
7366: EQUAL
7367: IFTRUE 7371
7369: GO 7393
7371: POP
// begin ComEnterUnit ( KdoOpravuje , LeFact ) ;
7372: LD_LOC 25
7376: PPUSH
7377: LD_INT 26
7379: PPUSH
7380: CALL_OW 120
// KdoOpravuje = [ ] ;
7384: LD_ADDR_LOC 25
7388: PUSH
7389: EMPTY
7390: ST_TO_ADDR
// end ; 114 :
7391: GO 7424
7393: LD_INT 114
7395: DOUBLE
7396: EQUAL
7397: IFTRUE 7401
7399: GO 7423
7401: POP
// begin ComEnterUnit ( KdoLeci , LeLab ) ;
7402: LD_LOC 24
7406: PPUSH
7407: LD_INT 25
7409: PPUSH
7410: CALL_OW 120
// KdoLeci = [ ] ;
7414: LD_ADDR_LOC 24
7418: PUSH
7419: EMPTY
7420: ST_TO_ADDR
// end ; end ;
7421: GO 7424
7423: POP
// end ;
7424: LD_VAR 0 2
7428: RET
// every 2 2$7 do
7429: GO 7431
7431: DISABLE
// begin opravuj ;
7432: CALL 7251 0 0
// kuryruj ;
7436: CALL 7304 0 0
// enable ;
7440: ENABLE
// end ;
7441: END
// function vyrob_autak ; var Chassis , Weapon , P ; begin
7442: LD_INT 0
7444: PPUSH
7445: PPUSH
7446: PPUSH
7447: PPUSH
// P = Rand ( 1 , 100 ) ;
7448: LD_ADDR_VAR 0 4
7452: PUSH
7453: LD_INT 1
7455: PPUSH
7456: LD_INT 100
7458: PPUSH
7459: CALL_OW 12
7463: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 75 ) then
7464: LD_OWVAR 67
7468: PUSH
7469: LD_INT 1
7471: EQUAL
7472: PUSH
7473: LD_VAR 0 4
7477: PUSH
7478: LD_INT 75
7480: GREATEREQUAL
7481: AND
7482: IFFALSE 7492
// P = 74 ;
7484: LD_ADDR_VAR 0 4
7488: PUSH
7489: LD_INT 74
7491: ST_TO_ADDR
// if P < 18 then
7492: LD_VAR 0 4
7496: PUSH
7497: LD_INT 18
7499: LESS
7500: IFFALSE 7520
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
7502: LD_ADDR_VAR 0 3
7506: PUSH
7507: LD_INT 22
7509: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7510: LD_ADDR_VAR 0 2
7514: PUSH
7515: LD_INT 11
7517: ST_TO_ADDR
// end else
7518: GO 7620
// if P < 25 then
7520: LD_VAR 0 4
7524: PUSH
7525: LD_INT 25
7527: LESS
7528: IFFALSE 7548
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
7530: LD_ADDR_VAR 0 3
7534: PUSH
7535: LD_INT 24
7537: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7538: LD_ADDR_VAR 0 2
7542: PUSH
7543: LD_INT 11
7545: ST_TO_ADDR
// end else
7546: GO 7620
// if P < 50 then
7548: LD_VAR 0 4
7552: PUSH
7553: LD_INT 50
7555: LESS
7556: IFFALSE 7576
// begin Weapon = AR_FLAME_THROWER ;
7558: LD_ADDR_VAR 0 3
7562: PUSH
7563: LD_INT 26
7565: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7566: LD_ADDR_VAR 0 2
7570: PUSH
7571: LD_INT 13
7573: ST_TO_ADDR
// end else
7574: GO 7620
// if P < 75 then
7576: LD_VAR 0 4
7580: PUSH
7581: LD_INT 75
7583: LESS
7584: IFFALSE 7604
// begin Weapon = AR_GUN ;
7586: LD_ADDR_VAR 0 3
7590: PUSH
7591: LD_INT 27
7593: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: LD_INT 13
7601: ST_TO_ADDR
// end else
7602: GO 7620
// begin Weapon = AR_ROCKET_LAUNCHER ;
7604: LD_ADDR_VAR 0 3
7608: PUSH
7609: LD_INT 28
7611: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7612: LD_ADDR_VAR 0 2
7616: PUSH
7617: LD_INT 13
7619: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
7620: LD_ADDR_VAR 0 2
7624: PUSH
7625: LD_VAR 0 2
7629: PPUSH
7630: LD_INT 14
7632: PPUSH
7633: CALL_OW 12
7637: ST_TO_ADDR
// AddComConstruct ( LeFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
7638: LD_INT 26
7640: PPUSH
7641: LD_VAR 0 2
7645: PPUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_VAR 0 3
7656: PPUSH
7657: CALL_OW 185
// end ;
7661: LD_VAR 0 1
7665: RET
// function vyrob_autaky ; var I ; begin
7666: LD_INT 0
7668: PPUSH
7669: PPUSH
// for I in Ridici do
7670: LD_ADDR_VAR 0 2
7674: PUSH
7675: LD_LOC 12
7679: PUSH
7680: FOR_IN
7681: IFFALSE 7689
// vyrob_autak ;
7683: CALL 7442 0 0
7687: GO 7680
7689: POP
7690: POP
// end ;
7691: LD_VAR 0 1
7695: RET
// every 0 0$25 do
7696: GO 7698
7698: DISABLE
// begin vyrob_autaky ;
7699: CALL 7666 0 0
// end ;
7703: END
// export function legion_VehicleConstructed ( Veh , Fact ) ; var Ridic ; begin
7704: LD_INT 0
7706: PPUSH
7707: PPUSH
// if GetSide ( Veh ) = side_Le then
7708: LD_VAR 0 1
7712: PPUSH
7713: CALL_OW 255
7717: PUSH
7718: LD_EXP 4
7722: EQUAL
7723: IFFALSE 7827
// begin Wait ( 0 0$2.5 ) ;
7725: LD_INT 88
7727: PPUSH
7728: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
7732: LD_ADDR_VAR 0 4
7736: PUSH
7737: LD_VAR 0 1
7741: PPUSH
7742: CALL_OW 311
7746: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
7747: LD_INT 105
7749: PPUSH
7750: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
7754: LD_VAR 0 4
7758: PPUSH
7759: CALL_OW 121
// Wait ( 0 0$1 ) ;
7763: LD_INT 35
7765: PPUSH
7766: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
7770: LD_VAR 0 1
7774: PPUSH
7775: CALL_OW 311
7779: PUSH
7780: LD_VAR 0 4
7784: EQUAL
7785: IFFALSE 7796
// Wait ( 0 0$1 ) ;
7787: LD_INT 35
7789: PPUSH
7790: CALL_OW 67
7794: GO 7770
// AddComEnterUnit ( Ridic , Fact ) ;
7796: LD_VAR 0 4
7800: PPUSH
7801: LD_VAR 0 2
7805: PPUSH
7806: CALL_OW 180
// AddMcUnits ( Makro , [ Veh ] ) ;
7810: LD_LOC 23
7814: PPUSH
7815: LD_VAR 0 1
7819: PUSH
7820: EMPTY
7821: LIST
7822: PPUSH
7823: CALL_OW 390
// end ; end ;
7827: LD_VAR 0 3
7831: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
7832: LD_INT 0
7834: PPUSH
7835: PPUSH
7836: PPUSH
// Lidi = UnitFilter ( Ridici , [ [ F_OUTSIDE ] ] ) ;
7837: LD_ADDR_VAR 0 3
7841: PUSH
7842: LD_LOC 12
7846: PPUSH
7847: LD_INT 56
7849: PUSH
7850: EMPTY
7851: LIST
7852: PUSH
7853: EMPTY
7854: LIST
7855: PPUSH
7856: CALL_OW 72
7860: ST_TO_ADDR
// for I in Lidi do
7861: LD_ADDR_VAR 0 4
7865: PUSH
7866: LD_VAR 0 3
7870: PUSH
7871: FOR_IN
7872: IFFALSE 7906
// if not HasTask ( I ) then
7874: LD_VAR 0 4
7878: PPUSH
7879: CALL_OW 314
7883: NOT
7884: IFFALSE 7904
// begin ComEnterUnit ( I , Veh ) ;
7886: LD_VAR 0 4
7890: PPUSH
7891: LD_VAR 0 1
7895: PPUSH
7896: CALL_OW 120
// exit ;
7900: POP
7901: POP
7902: GO 7908
// end ;
7904: GO 7871
7906: POP
7907: POP
// end ;
7908: LD_VAR 0 2
7912: RET
// function nastupuj_auta ; var Auta , I ; begin
7913: LD_INT 0
7915: PPUSH
7916: PPUSH
7917: PPUSH
// Auta = FilterUnitsInArea ( LegionObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
7918: LD_ADDR_VAR 0 2
7922: PUSH
7923: LD_INT 16
7925: PPUSH
7926: LD_INT 21
7928: PUSH
7929: LD_INT 2
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: LD_INT 33
7938: PUSH
7939: LD_INT 1
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: LD_INT 58
7948: PUSH
7949: EMPTY
7950: LIST
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: LIST
7956: PPUSH
7957: CALL_OW 70
7961: ST_TO_ADDR
// if not Auta then
7962: LD_VAR 0 2
7966: NOT
7967: IFFALSE 7971
// exit ;
7969: GO 7997
// for I in Auta do
7971: LD_ADDR_VAR 0 3
7975: PUSH
7976: LD_VAR 0 2
7980: PUSH
7981: FOR_IN
7982: IFFALSE 7995
// zarid_ridice ( I ) ;
7984: LD_VAR 0 3
7988: PPUSH
7989: CALL 7832 0 1
7993: GO 7981
7995: POP
7996: POP
// end ;
7997: LD_VAR 0 1
8001: RET
// every 0 0$18 do
8002: GO 8004
8004: DISABLE
// begin nastupuj_auta ;
8005: CALL 7913 0 0
// enable ;
8009: ENABLE
// end ;
8010: END
// function zavolej ; var V , R ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// DialogueOn ;
8016: CALL_OW 6
// Nabidka_Cena = [ 0 , 0 ] ;
8020: LD_ADDR_LOC 19
8024: PUSH
8025: LD_INT 0
8027: PUSH
8028: LD_INT 0
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
8035: LD_ADDR_LOC 20
8039: PUSH
8040: LD_INT 0
8042: ST_TO_ADDR
// if HeikeKilled or not MercAccepted then
8043: LD_EXP 37
8047: PUSH
8048: LD_EXP 34
8052: NOT
8053: OR
8054: IFFALSE 8187
// begin LegionOffer_Heike = false ;
8056: LD_ADDR_EXP 58
8060: PUSH
8061: LD_INT 0
8063: ST_TO_ADDR
// dialog_LegionOfferFarmer ;
8064: CALL 4951 0 0
// V = query_LegionFarmer ;
8068: LD_ADDR_VAR 0 2
8072: PUSH
8073: CALL 4995 0 0
8077: ST_TO_ADDR
// if V < 4 then
8078: LD_VAR 0 2
8082: PUSH
8083: LD_INT 4
8085: LESS
8086: IFFALSE 8173
// begin LegionOffer_Accepted = true ;
8088: LD_ADDR_EXP 59
8092: PUSH
8093: LD_INT 1
8095: ST_TO_ADDR
// dialog_QrLegionFarmer13 ;
8096: CALL 5016 0 0
// Nabidka_Cena = [ [ 60 , 15 ] , [ 90 , 25 ] , [ 120 , 30 ] ] [ V ] ;
8100: LD_ADDR_LOC 19
8104: PUSH
8105: LD_INT 60
8107: PUSH
8108: LD_INT 15
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PUSH
8115: LD_INT 90
8117: PUSH
8118: LD_INT 25
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PUSH
8125: LD_INT 120
8127: PUSH
8128: LD_INT 30
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: LIST
8139: PUSH
8140: LD_VAR 0 2
8144: ARRAY
8145: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8146: LD_ADDR_LOC 20
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: LD_INT 5
8156: PUSH
8157: LD_INT 7
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: LIST
8164: PUSH
8165: LD_VAR 0 2
8169: ARRAY
8170: ST_TO_ADDR
// end else
8171: GO 8185
// begin LegionOffer_Accepted = false ;
8173: LD_ADDR_EXP 59
8177: PUSH
8178: LD_INT 0
8180: ST_TO_ADDR
// dialog_QrLegionFarmer4 ;
8181: CALL 5036 0 0
// end ; end else
8185: GO 8338
// begin LegionOffer_Heike = true ;
8187: LD_ADDR_EXP 58
8191: PUSH
8192: LD_INT 1
8194: ST_TO_ADDR
// if MercPaid and OmarKilled then
8195: LD_EXP 33
8199: PUSH
8200: LD_EXP 38
8204: AND
8205: IFFALSE 8213
// dialog_LegionOfferHeike1 else
8207: CALL 4782 0 0
8211: GO 8217
// dialog_LegionOfferHeike2 ;
8213: CALL 4826 0 0
// dialog_LegionOfferHeikeCont ;
8217: CALL 4870 0 0
// V = query_LegionHeike ;
8221: LD_ADDR_VAR 0 2
8225: PUSH
8226: CALL 4890 0 0
8230: ST_TO_ADDR
// if V < 4 then
8231: LD_VAR 0 2
8235: PUSH
8236: LD_INT 4
8238: LESS
8239: IFFALSE 8326
// begin LegionOffer_Accepted = true ;
8241: LD_ADDR_EXP 59
8245: PUSH
8246: LD_INT 1
8248: ST_TO_ADDR
// dialog_QrLegionHeike13 ;
8249: CALL 4911 0 0
// Nabidka_Cena = [ [ 50 , 10 ] , [ 75 , 15 ] , [ 100 , 20 ] ] [ V ] ;
8253: LD_ADDR_LOC 19
8257: PUSH
8258: LD_INT 50
8260: PUSH
8261: LD_INT 10
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 75
8270: PUSH
8271: LD_INT 15
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: PUSH
8278: LD_INT 100
8280: PUSH
8281: LD_INT 20
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: LIST
8292: PUSH
8293: LD_VAR 0 2
8297: ARRAY
8298: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8299: LD_ADDR_LOC 20
8303: PUSH
8304: LD_INT 3
8306: PUSH
8307: LD_INT 5
8309: PUSH
8310: LD_INT 7
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_VAR 0 2
8322: ARRAY
8323: ST_TO_ADDR
// end else
8324: GO 8338
// begin LegionOffer_Accepted = false ;
8326: LD_ADDR_EXP 59
8330: PUSH
8331: LD_INT 0
8333: ST_TO_ADDR
// dialog_QrLegionHeike4 ;
8334: CALL 4931 0 0
// end ; end ; if LegionOffer_Accepted then
8338: LD_EXP 59
8342: IFFALSE 8453
// begin SA_OnLegionHired ;
8344: CALL 22725 0 0
// Nabidka_Nakladaky = [ vytvor_nakladak , vytvor_nakladak ] ;
8348: LD_ADDR_LOC 17
8352: PUSH
8353: CALL 10009 0 0
8357: PUSH
8358: CALL 10009 0 0
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
8367: LD_ADDR_LOC 18
8371: PUSH
8372: EMPTY
8373: ST_TO_ADDR
// for V in Nabidka_Nakladaky do
8374: LD_ADDR_VAR 0 2
8378: PUSH
8379: LD_LOC 17
8383: PUSH
8384: FOR_IN
8385: IFFALSE 8428
// begin PlaceUnitArea ( V , LegionVstup , false ) ;
8387: LD_VAR 0 2
8391: PPUSH
8392: LD_INT 10
8394: PPUSH
8395: LD_INT 0
8397: PPUSH
8398: CALL_OW 49
// Nabidka_Ridici = Nabidka_Ridici union [ IsDrivenBy ( V ) ] ;
8402: LD_ADDR_LOC 18
8406: PUSH
8407: LD_LOC 18
8411: PUSH
8412: LD_VAR 0 2
8416: PPUSH
8417: CALL_OW 311
8421: PUSH
8422: EMPTY
8423: LIST
8424: UNION
8425: ST_TO_ADDR
// end ;
8426: GO 8384
8428: POP
8429: POP
// Hint ( LegionHelp ) ;
8430: LD_STRING LegionHelp
8432: PPUSH
8433: CALL_OW 339
// enable ( 12 ) ;
8437: LD_INT 12
8439: ENABLE_MARKED
// enable ( 15 ) ;
8440: LD_INT 15
8442: ENABLE_MARKED
// ProbihaPredavaniSurovin = true ;
8443: LD_ADDR_LOC 26
8447: PUSH
8448: LD_INT 1
8450: ST_TO_ADDR
// end else
8451: GO 8456
// begin enable ( 11 ) ;
8453: LD_INT 11
8455: ENABLE_MARKED
// end ; DialogueOff ;
8456: CALL_OW 7
// end ;
8460: LD_VAR 0 1
8464: RET
// function ma_dost_materialu ( Bud ) ; var Base , Cans , Sib ; begin
8465: LD_INT 0
8467: PPUSH
8468: PPUSH
8469: PPUSH
8470: PPUSH
// Base = GetBase ( Bud ) ;
8471: LD_ADDR_VAR 0 3
8475: PUSH
8476: LD_VAR 0 1
8480: PPUSH
8481: CALL_OW 274
8485: ST_TO_ADDR
// Cans = Nabidka_Cena [ 1 ] ;
8486: LD_ADDR_VAR 0 4
8490: PUSH
8491: LD_LOC 19
8495: PUSH
8496: LD_INT 1
8498: ARRAY
8499: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
8500: LD_ADDR_VAR 0 5
8504: PUSH
8505: LD_LOC 19
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: ST_TO_ADDR
// Result = ( GetResourceType ( Base , MAT_CANS ) >= Cans ) and ( GetResourceType ( Base , MAT_SIBERIT ) >= Sib ) ;
8514: LD_ADDR_VAR 0 2
8518: PUSH
8519: LD_VAR 0 3
8523: PPUSH
8524: LD_INT 1
8526: PPUSH
8527: CALL_OW 275
8531: PUSH
8532: LD_VAR 0 4
8536: GREATEREQUAL
8537: PUSH
8538: LD_VAR 0 3
8542: PPUSH
8543: LD_INT 3
8545: PPUSH
8546: CALL_OW 275
8550: PUSH
8551: LD_VAR 0 5
8555: GREATEREQUAL
8556: AND
8557: ST_TO_ADDR
// end ;
8558: LD_VAR 0 2
8562: RET
// function naloz ( Veh , Bud , Mat , Amount ) ; var Base , Res ; begin
8563: LD_INT 0
8565: PPUSH
8566: PPUSH
8567: PPUSH
// Base = GetBase ( Bud ) ;
8568: LD_ADDR_VAR 0 6
8572: PUSH
8573: LD_VAR 0 2
8577: PPUSH
8578: CALL_OW 274
8582: ST_TO_ADDR
// Result = CanCarryHowMuch ( Veh ) ;
8583: LD_ADDR_VAR 0 5
8587: PUSH
8588: LD_VAR 0 1
8592: PPUSH
8593: CALL_OW 466
8597: ST_TO_ADDR
// if Result > Amount then
8598: LD_VAR 0 5
8602: PUSH
8603: LD_VAR 0 4
8607: GREATER
8608: IFFALSE 8620
// Result = Amount ;
8610: LD_ADDR_VAR 0 5
8614: PUSH
8615: LD_VAR 0 4
8619: ST_TO_ADDR
// Res = GetResourceType ( Base , Mat ) ;
8620: LD_ADDR_VAR 0 7
8624: PUSH
8625: LD_VAR 0 6
8629: PPUSH
8630: LD_VAR 0 3
8634: PPUSH
8635: CALL_OW 275
8639: ST_TO_ADDR
// if Result > Res then
8640: LD_VAR 0 5
8644: PUSH
8645: LD_VAR 0 7
8649: GREATER
8650: IFFALSE 8662
// Result = Res ;
8652: LD_ADDR_VAR 0 5
8656: PUSH
8657: LD_VAR 0 7
8661: ST_TO_ADDR
// SetResourceType ( Base , Mat , Res - Amount ) ;
8662: LD_VAR 0 6
8666: PPUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 7
8676: PUSH
8677: LD_VAR 0 4
8681: MINUS
8682: PPUSH
8683: CALL_OW 277
// AddCargo ( Veh , Mat , Result ) ;
8687: LD_VAR 0 1
8691: PPUSH
8692: LD_VAR 0 3
8696: PPUSH
8697: LD_VAR 0 5
8701: PPUSH
8702: CALL_OW 291
// end ;
8706: LD_VAR 0 5
8710: RET
// every 0 0$11 trigger KonvojPopojizdi and Nabidka_Nakladaky marked 16 do
8711: LD_LOC 16
8715: PUSH
8716: LD_LOC 17
8720: AND
8721: IFFALSE 8731
8723: GO 8725
8725: DISABLE
// begin popojizdej_konvoj ;
8726: CALL 8732 0 0
// enable ;
8730: ENABLE
// end ;
8731: END
// function popojizdej_konvoj ; var I , Hex ; begin
8732: LD_INT 0
8734: PPUSH
8735: PPUSH
8736: PPUSH
// for I in Nabidka_Nakladaky do
8737: LD_ADDR_VAR 0 2
8741: PUSH
8742: LD_LOC 17
8746: PUSH
8747: FOR_IN
8748: IFFALSE 8841
// begin if HasTask ( I ) then
8750: LD_VAR 0 2
8754: PPUSH
8755: CALL_OW 314
8759: IFFALSE 8763
// continue ;
8761: GO 8747
// if not IsDrivenBy ( I ) then
8763: LD_VAR 0 2
8767: PPUSH
8768: CALL_OW 311
8772: NOT
8773: IFFALSE 8777
// continue ;
8775: GO 8747
// Hex = RandHexXYR ( Uprchlici_X , Uprchlici_Y , 8 , false ) ;
8777: LD_ADDR_VAR 0 3
8781: PUSH
8782: LD_LOC 14
8786: PPUSH
8787: LD_LOC 15
8791: PPUSH
8792: LD_INT 8
8794: PPUSH
8795: LD_INT 0
8797: PPUSH
8798: CALL_OW 17
8802: ST_TO_ADDR
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
8803: LD_VAR 0 2
8807: PPUSH
8808: LD_VAR 0 3
8812: PUSH
8813: LD_INT 1
8815: ARRAY
8816: PPUSH
8817: LD_VAR 0 3
8821: PUSH
8822: LD_INT 2
8824: ARRAY
8825: PPUSH
8826: CALL_OW 111
// AddComHold ( I ) ;
8830: LD_VAR 0 2
8834: PPUSH
8835: CALL_OW 200
// end ;
8839: GO 8747
8841: POP
8842: POP
// end ;
8843: LD_VAR 0 1
8847: RET
// function zacni_popojizdet ; begin
8848: LD_INT 0
8850: PPUSH
// if not KonvojPopojizdi then
8851: LD_LOC 16
8855: NOT
8856: IFFALSE 8869
// begin enable ( 16 ) ;
8858: LD_INT 16
8860: ENABLE_MARKED
// KonvojPopojizdi = true ;
8861: LD_ADDR_LOC 16
8865: PUSH
8866: LD_INT 1
8868: ST_TO_ADDR
// end ; end ;
8869: LD_VAR 0 1
8873: RET
// function prestan_popojizdet ; begin
8874: LD_INT 0
8876: PPUSH
// if KonvojPopojizdi then
8877: LD_LOC 16
8881: IFFALSE 8894
// begin disable ( 16 ) ;
8883: LD_INT 16
8885: DISABLE_MARKED
// KonvojPopojizdi = false ;
8886: LD_ADDR_LOC 16
8890: PUSH
8891: LD_INT 0
8893: ST_TO_ADDR
// end ; end ;
8894: LD_VAR 0 1
8898: RET
// function ovladani_nakladaku ; var RuDepot , Bud , J , I , Cans , Sib , N1 , N2 , Ok , Ridic , Nakladak ; begin
8899: LD_INT 0
8901: PPUSH
8902: PPUSH
8903: PPUSH
8904: PPUSH
8905: PPUSH
8906: PPUSH
8907: PPUSH
8908: PPUSH
8909: PPUSH
8910: PPUSH
8911: PPUSH
8912: PPUSH
// if not Nabidka_Nalozeno then
8913: LD_LOC 21
8917: NOT
8918: IFFALSE 9509
// begin Ok = true ;
8920: LD_ADDR_VAR 0 10
8924: PUSH
8925: LD_INT 1
8927: ST_TO_ADDR
// for I = 1 to Nabidka_Nakladaky do
8928: LD_ADDR_VAR 0 5
8932: PUSH
8933: DOUBLE
8934: LD_INT 1
8936: DEC
8937: ST_TO_ADDR
8938: LD_LOC 17
8942: PUSH
8943: FOR_TO
8944: IFFALSE 9058
// begin Nakladak = Nabidka_Nakladaky [ I ] ;
8946: LD_ADDR_VAR 0 12
8950: PUSH
8951: LD_LOC 17
8955: PUSH
8956: LD_VAR 0 5
8960: ARRAY
8961: ST_TO_ADDR
// Ridic = Nabidka_Ridici [ I ] ;
8962: LD_ADDR_VAR 0 11
8966: PUSH
8967: LD_LOC 18
8971: PUSH
8972: LD_VAR 0 5
8976: ARRAY
8977: ST_TO_ADDR
// if GetLives ( Nakladak ) < HRANICE_ZDRAVI then
8978: LD_VAR 0 12
8982: PPUSH
8983: CALL_OW 256
8987: PUSH
8988: LD_INT 1000
8990: LESS
8991: IFFALSE 9017
// begin ComRepairVehicle ( Ridic , Nakladak ) ;
8993: LD_VAR 0 11
8997: PPUSH
8998: LD_VAR 0 12
9002: PPUSH
9003: CALL_OW 129
// Ok = false ;
9007: LD_ADDR_VAR 0 10
9011: PUSH
9012: LD_INT 0
9014: ST_TO_ADDR
// end else
9015: GO 9056
// begin if IsInUnit ( Ridic ) <> Nakladak then
9017: LD_VAR 0 11
9021: PPUSH
9022: CALL_OW 310
9026: PUSH
9027: LD_VAR 0 12
9031: NONEQUAL
9032: IFFALSE 9056
// begin ComEnterUnit ( Ridic , Nakladak ) ;
9034: LD_VAR 0 11
9038: PPUSH
9039: LD_VAR 0 12
9043: PPUSH
9044: CALL_OW 120
// Ok = false ;
9048: LD_ADDR_VAR 0 10
9052: PUSH
9053: LD_INT 0
9055: ST_TO_ADDR
// end ; end ; end ;
9056: GO 8943
9058: POP
9059: POP
// if not Ok then
9060: LD_VAR 0 10
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9855
// Bud = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_DEPOT ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_WAREHOUSE ] ] ) ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 22
9076: PUSH
9077: LD_EXP 2
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 52
9088: PUSH
9089: EMPTY
9090: LIST
9091: PUSH
9092: LD_INT 21
9094: PUSH
9095: LD_INT 3
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 30
9104: PUSH
9105: LD_INT 0
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: LIST
9117: PPUSH
9118: CALL_OW 69
9122: PUSH
9123: LD_INT 22
9125: PUSH
9126: LD_EXP 2
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: LD_INT 52
9137: PUSH
9138: EMPTY
9139: LIST
9140: PUSH
9141: LD_INT 21
9143: PUSH
9144: LD_INT 3
9146: PUSH
9147: EMPTY
9148: LIST
9149: LIST
9150: PUSH
9151: LD_INT 30
9153: PUSH
9154: LD_INT 1
9156: PUSH
9157: EMPTY
9158: LIST
9159: LIST
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 69
9171: UNION
9172: ST_TO_ADDR
// RuDepot = 0 ;
9173: LD_ADDR_VAR 0 2
9177: PUSH
9178: LD_INT 0
9180: ST_TO_ADDR
// for I in Bud do
9181: LD_ADDR_VAR 0 5
9185: PUSH
9186: LD_VAR 0 3
9190: PUSH
9191: FOR_IN
9192: IFFALSE 9219
// if ma_dost_materialu ( I ) then
9194: LD_VAR 0 5
9198: PPUSH
9199: CALL 8465 0 1
9203: IFFALSE 9217
// begin RuDepot = I ;
9205: LD_ADDR_VAR 0 2
9209: PUSH
9210: LD_VAR 0 5
9214: ST_TO_ADDR
// break ;
9215: GO 9219
// end ;
9217: GO 9191
9219: POP
9220: POP
// if not RuDepot then
9221: LD_VAR 0 2
9225: NOT
9226: IFFALSE 9252
// if Bud then
9228: LD_VAR 0 3
9232: IFFALSE 9250
// RuDepot = Bud [ 1 ] else
9234: LD_ADDR_VAR 0 2
9238: PUSH
9239: LD_VAR 0 3
9243: PUSH
9244: LD_INT 1
9246: ARRAY
9247: ST_TO_ADDR
9248: GO 9252
// exit ;
9250: GO 9855
// Uprchlici_X = GetX ( RuDepot ) ;
9252: LD_ADDR_LOC 14
9256: PUSH
9257: LD_VAR 0 2
9261: PPUSH
9262: CALL_OW 250
9266: ST_TO_ADDR
// Uprchlici_Y = GetY ( RuDepot ) ;
9267: LD_ADDR_LOC 15
9271: PUSH
9272: LD_VAR 0 2
9276: PPUSH
9277: CALL_OW 251
9281: ST_TO_ADDR
// zacni_popojizdet ;
9282: CALL 8848 0 0
// for I in Nabidka_Nakladaky do
9286: LD_ADDR_VAR 0 5
9290: PUSH
9291: LD_LOC 17
9295: PUSH
9296: FOR_IN
9297: IFFALSE 9325
// if GetDistUnits ( I , RuDepot ) > 8 then
9299: LD_VAR 0 5
9303: PPUSH
9304: LD_VAR 0 2
9308: PPUSH
9309: CALL_OW 296
9313: PUSH
9314: LD_INT 8
9316: GREATER
9317: IFFALSE 9323
// exit ;
9319: POP
9320: POP
9321: GO 9855
9323: GO 9296
9325: POP
9326: POP
// if not ma_dost_materialu ( RuDepot ) then
9327: LD_VAR 0 2
9331: PPUSH
9332: CALL 8465 0 1
9336: NOT
9337: IFFALSE 9341
// exit ;
9339: GO 9855
// prestan_popojizdet ;
9341: CALL 8874 0 0
// Cans = Nabidka_Cena [ 1 ] ;
9345: LD_ADDR_VAR 0 6
9349: PUSH
9350: LD_LOC 19
9354: PUSH
9355: LD_INT 1
9357: ARRAY
9358: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
9359: LD_ADDR_VAR 0 7
9363: PUSH
9364: LD_LOC 19
9368: PUSH
9369: LD_INT 2
9371: ARRAY
9372: ST_TO_ADDR
// N1 = Nabidka_Nakladaky [ 1 ] ;
9373: LD_ADDR_VAR 0 8
9377: PUSH
9378: LD_LOC 17
9382: PUSH
9383: LD_INT 1
9385: ARRAY
9386: ST_TO_ADDR
// N2 = Nabidka_Nakladaky [ 2 ] ;
9387: LD_ADDR_VAR 0 9
9391: PUSH
9392: LD_LOC 17
9396: PUSH
9397: LD_INT 2
9399: ARRAY
9400: ST_TO_ADDR
// naloz ( N1 , RuDepot , MAT_SIBERIT , Sib ) ;
9401: LD_VAR 0 8
9405: PPUSH
9406: LD_VAR 0 2
9410: PPUSH
9411: LD_INT 3
9413: PPUSH
9414: LD_VAR 0 7
9418: PPUSH
9419: CALL 8563 0 4
// I = naloz ( N1 , RuDepot , MAT_CANS , min ( Cans , CanCarryHowMuch ( N1 ) ) ) ;
9423: LD_ADDR_VAR 0 5
9427: PUSH
9428: LD_VAR 0 8
9432: PPUSH
9433: LD_VAR 0 2
9437: PPUSH
9438: LD_INT 1
9440: PPUSH
9441: LD_VAR 0 6
9445: PPUSH
9446: LD_VAR 0 8
9450: PPUSH
9451: CALL_OW 466
9455: PPUSH
9456: CALL 21494 0 2
9460: PPUSH
9461: CALL 8563 0 4
9465: ST_TO_ADDR
// naloz ( N2 , RuDepot , MAT_CANS , Cans - I ) ;
9466: LD_VAR 0 9
9470: PPUSH
9471: LD_VAR 0 2
9475: PPUSH
9476: LD_INT 1
9478: PPUSH
9479: LD_VAR 0 6
9483: PUSH
9484: LD_VAR 0 5
9488: MINUS
9489: PPUSH
9490: CALL 8563 0 4
// Nabidka_Nalozeno = true ;
9494: LD_ADDR_LOC 21
9498: PUSH
9499: LD_INT 1
9501: ST_TO_ADDR
// Wait ( 0 0$0.2 ) ;
9502: LD_INT 7
9504: PPUSH
9505: CALL_OW 67
// end ; prestan_popojizdet ;
9509: CALL 8874 0 0
// if not Nabidka_Vylozeno then
9513: LD_LOC 22
9517: NOT
9518: IFFALSE 9716
// begin MamPrebarvit = [ ] ;
9520: LD_ADDR_LOC 27
9524: PUSH
9525: EMPTY
9526: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9527: LD_ADDR_VAR 0 5
9531: PUSH
9532: LD_LOC 17
9536: PUSH
9537: FOR_IN
9538: IFFALSE 9601
// begin MamPrebarvit = MamPrebarvit union [ I ] ;
9540: LD_ADDR_LOC 27
9544: PUSH
9545: LD_LOC 27
9549: PUSH
9550: LD_VAR 0 5
9554: PUSH
9555: EMPTY
9556: LIST
9557: UNION
9558: ST_TO_ADDR
// J = IsDrivenBy ( I ) ;
9559: LD_ADDR_VAR 0 4
9563: PUSH
9564: LD_VAR 0 5
9568: PPUSH
9569: CALL_OW 311
9573: ST_TO_ADDR
// if J then
9574: LD_VAR 0 4
9578: IFFALSE 9599
// MamPrebarvit = MamPrebarvit union [ J ] ;
9580: LD_ADDR_LOC 27
9584: PUSH
9585: LD_LOC 27
9589: PUSH
9590: LD_VAR 0 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: UNION
9598: ST_TO_ADDR
// end ;
9599: GO 9537
9601: POP
9602: POP
// Ok = true ;
9603: LD_ADDR_VAR 0 10
9607: PUSH
9608: LD_INT 1
9610: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9611: LD_ADDR_VAR 0 5
9615: PUSH
9616: LD_LOC 17
9620: PUSH
9621: FOR_IN
9622: IFFALSE 9697
// begin if not IsInArea ( I , Legion ) then
9624: LD_VAR 0 5
9628: PPUSH
9629: LD_INT 4
9631: PPUSH
9632: CALL_OW 308
9636: NOT
9637: IFFALSE 9695
// begin if not HasTask ( I ) then
9639: LD_VAR 0 5
9643: PPUSH
9644: CALL_OW 314
9648: NOT
9649: IFFALSE 9687
// begin ComMoveUnit ( I , LeDepot ) ;
9651: LD_VAR 0 5
9655: PPUSH
9656: LD_INT 20
9658: PPUSH
9659: CALL_OW 112
// AddComSailEvent ( I , 115 ) ;
9663: LD_VAR 0 5
9667: PPUSH
9668: LD_INT 115
9670: PPUSH
9671: CALL_OW 224
// AddComGive ( I , LeDepot ) ;
9675: LD_VAR 0 5
9679: PPUSH
9680: LD_INT 20
9682: PPUSH
9683: CALL_OW 221
// end ; Ok = false ;
9687: LD_ADDR_VAR 0 10
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// end ; end ;
9695: GO 9621
9697: POP
9698: POP
// if not Ok then
9699: LD_VAR 0 10
9703: NOT
9704: IFFALSE 9708
// exit ;
9706: GO 9855
// Nabidka_Vylozeno = true ;
9708: LD_ADDR_LOC 22
9712: PUSH
9713: LD_INT 1
9715: ST_TO_ADDR
// end ; Uprchlici = [ ] ;
9716: LD_ADDR_EXP 61
9720: PUSH
9721: EMPTY
9722: ST_TO_ADDR
// for I = 1 to Nabidka_Lidi do
9723: LD_ADDR_VAR 0 5
9727: PUSH
9728: DOUBLE
9729: LD_INT 1
9731: DEC
9732: ST_TO_ADDR
9733: LD_LOC 20
9737: PUSH
9738: FOR_TO
9739: IFFALSE 9762
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
9741: LD_ADDR_EXP 61
9745: PUSH
9746: LD_EXP 61
9750: PUSH
9751: CALL 9942 0 0
9755: PUSH
9756: EMPTY
9757: LIST
9758: UNION
9759: ST_TO_ADDR
9760: GO 9738
9762: POP
9763: POP
// for I in Uprchlici do
9764: LD_ADDR_VAR 0 5
9768: PUSH
9769: LD_EXP 61
9773: PUSH
9774: FOR_IN
9775: IFFALSE 9794
// PlaceUnitArea ( I , LegionVstup , false ) ;
9777: LD_VAR 0 5
9781: PPUSH
9782: LD_INT 10
9784: PPUSH
9785: LD_INT 0
9787: PPUSH
9788: CALL_OW 49
9792: GO 9774
9794: POP
9795: POP
// ComMoveXY ( Uprchlici , Uprchlici_X , Uprchlici_Y ) ;
9796: LD_EXP 61
9800: PPUSH
9801: LD_LOC 14
9805: PPUSH
9806: LD_LOC 15
9810: PPUSH
9811: CALL_OW 111
// AddComSailEvent ( Uprchlici , 111 ) ;
9815: LD_EXP 61
9819: PPUSH
9820: LD_INT 111
9822: PPUSH
9823: CALL_OW 224
// Nabidka_Nakladaky = [ ] ;
9827: LD_ADDR_LOC 17
9831: PUSH
9832: EMPTY
9833: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
9834: LD_ADDR_LOC 18
9838: PUSH
9839: EMPTY
9840: ST_TO_ADDR
// disable ( 12 ) ;
9841: LD_INT 12
9843: DISABLE_MARKED
// disable ( 15 ) ;
9844: LD_INT 15
9846: DISABLE_MARKED
// ProbihaPredavaniSurovin = false ;
9847: LD_ADDR_LOC 26
9851: PUSH
9852: LD_INT 0
9854: ST_TO_ADDR
// end ;
9855: LD_VAR 0 1
9859: RET
// export function event_KoupeniPrisli ; begin
9860: LD_INT 0
9862: PPUSH
// if not Uprchlici_JsouTam then
9863: LD_LOC 13
9867: NOT
9868: IFFALSE 9937
// begin DialogueOn ;
9870: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
9874: LD_EXP 61
9878: PPUSH
9879: CALL_OW 85
// Uprchlici_JsouTam = true ;
9883: LD_ADDR_LOC 13
9887: PUSH
9888: LD_INT 1
9890: ST_TO_ADDR
// SetSide ( Uprchlici , side_Ru ) ;
9891: LD_EXP 61
9895: PPUSH
9896: LD_EXP 2
9900: PPUSH
9901: CALL_OW 235
// Rusove2 = Uprchlici ;
9905: LD_ADDR_EXP 40
9909: PUSH
9910: LD_EXP 61
9914: ST_TO_ADDR
// uprchlik_jdi_k_labu ;
9915: CALL 10265 0 0
// Wait ( 0 0$5 ) ;
9919: LD_INT 175
9921: PPUSH
9922: CALL_OW 67
// Hint ( Legion ) ;
9926: LD_STRING Legion
9928: PPUSH
9929: CALL_OW 339
// DialogueOff ;
9933: CALL_OW 7
// end ; end ;
9937: LD_VAR 0 1
9941: RET
// function vytvor_uprchlika ; begin
9942: LD_INT 0
9944: PPUSH
// UC_Side = side_Upr ;
9945: LD_ADDR_OWVAR 20
9949: PUSH
9950: LD_EXP 5
9954: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
9955: LD_ADDR_OWVAR 21
9959: PUSH
9960: LD_INT 2
9962: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
9963: LD_ADDR_OWVAR 27
9967: PUSH
9968: LD_INT 1
9970: PPUSH
9971: LD_INT 2
9973: PPUSH
9974: CALL_OW 12
9978: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
9979: LD_ADDR_OWVAR 28
9983: PUSH
9984: LD_INT 1
9986: ST_TO_ADDR
// PrepareSoldierSkills ( 6 ) ;
9987: LD_INT 6
9989: PPUSH
9990: CALL_OW 375
// Result = CreateHuman ;
9994: LD_ADDR_VAR 0 1
9998: PUSH
9999: CALL_OW 44
10003: ST_TO_ADDR
// end ;
10004: LD_VAR 0 1
10008: RET
// function vytvor_nakladak ; var Ridic ; begin
10009: LD_INT 0
10011: PPUSH
10012: PPUSH
// UC_Side = side_Upr ;
10013: LD_ADDR_OWVAR 20
10017: PUSH
10018: LD_EXP 5
10022: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
10023: LD_ADDR_OWVAR 21
10027: PUSH
10028: LD_INT 2
10030: ST_TO_ADDR
// VC_Chassis = AR_HALF_TRACKED ;
10031: LD_ADDR_OWVAR 37
10035: PUSH
10036: LD_INT 14
10038: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
10039: LD_ADDR_OWVAR 38
10043: PUSH
10044: LD_INT 1
10046: ST_TO_ADDR
// VC_Weapon = AR_CARGO_BAY ;
10047: LD_ADDR_OWVAR 40
10051: PUSH
10052: LD_INT 32
10054: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
10055: LD_ADDR_OWVAR 39
10059: PUSH
10060: LD_INT 3
10062: ST_TO_ADDR
// Result = CreateVehicle ;
10063: LD_ADDR_VAR 0 1
10067: PUSH
10068: CALL_OW 45
10072: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
10073: LD_ADDR_OWVAR 27
10077: PUSH
10078: LD_INT 1
10080: PPUSH
10081: LD_INT 2
10083: PPUSH
10084: CALL_OW 12
10088: ST_TO_ADDR
// HC_Class = CLASS_MECHANIC ;
10089: LD_ADDR_OWVAR 28
10093: PUSH
10094: LD_INT 3
10096: ST_TO_ADDR
// PrepareMechanicSkills ( 4 ) ;
10097: LD_INT 4
10099: PPUSH
10100: CALL_OW 377
// Ridic = CreateHuman ;
10104: LD_ADDR_VAR 0 2
10108: PUSH
10109: CALL_OW 44
10113: ST_TO_ADDR
// PlaceHumanInUnit ( Ridic , Result ) ;
10114: LD_VAR 0 2
10118: PPUSH
10119: LD_VAR 0 1
10123: PPUSH
10124: CALL_OW 52
// end ;
10128: LD_VAR 0 1
10132: RET
// function prchajici ; var I ; begin
10133: LD_INT 0
10135: PPUSH
10136: PPUSH
// Uprchlici = [ Bergkamp ] ;
10137: LD_ADDR_EXP 61
10141: PUSH
10142: LD_EXP 30
10146: PUSH
10147: EMPTY
10148: LIST
10149: ST_TO_ADDR
// for I = Difficulty to Rand ( 5 , 6 ) do
10150: LD_ADDR_VAR 0 2
10154: PUSH
10155: DOUBLE
10156: LD_OWVAR 67
10160: DEC
10161: ST_TO_ADDR
10162: LD_INT 5
10164: PPUSH
10165: LD_INT 6
10167: PPUSH
10168: CALL_OW 12
10172: PUSH
10173: FOR_TO
10174: IFFALSE 10197
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
10176: LD_ADDR_EXP 61
10180: PUSH
10181: LD_EXP 61
10185: PUSH
10186: CALL 9942 0 0
10190: PUSH
10191: EMPTY
10192: LIST
10193: UNION
10194: ST_TO_ADDR
10195: GO 10173
10197: POP
10198: POP
// for I in Uprchlici do
10199: LD_ADDR_VAR 0 2
10203: PUSH
10204: LD_EXP 61
10208: PUSH
10209: FOR_IN
10210: IFFALSE 10229
// PlaceUnitArea ( I , Legion , false ) ;
10212: LD_VAR 0 2
10216: PPUSH
10217: LD_INT 4
10219: PPUSH
10220: LD_INT 0
10222: PPUSH
10223: CALL_OW 49
10227: GO 10209
10229: POP
10230: POP
// ComMoveUnit ( Uprchlici , Burlak ) ;
10231: LD_EXP 61
10235: PPUSH
10236: LD_EXP 6
10240: PPUSH
10241: CALL_OW 112
// AddComSailEvent ( Uprchlici , 112 ) ;
10245: LD_EXP 61
10249: PPUSH
10250: LD_INT 112
10252: PPUSH
10253: CALL_OW 224
// enable ( 14 ) ;
10257: LD_INT 14
10259: ENABLE_MARKED
// end ;
10260: LD_VAR 0 1
10264: RET
// function uprchlik_jdi_k_labu ; var Laby , X , Y ; begin
10265: LD_INT 0
10267: PPUSH
10268: PPUSH
10269: PPUSH
10270: PPUSH
// Laby = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_HALF ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_FULL ] ] ) ;
10271: LD_ADDR_VAR 0 2
10275: PUSH
10276: LD_INT 22
10278: PUSH
10279: LD_EXP 2
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 52
10290: PUSH
10291: EMPTY
10292: LIST
10293: PUSH
10294: LD_INT 21
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PUSH
10304: LD_INT 30
10306: PUSH
10307: LD_INT 6
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL_OW 69
10324: PUSH
10325: LD_INT 22
10327: PUSH
10328: LD_EXP 2
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 52
10339: PUSH
10340: EMPTY
10341: LIST
10342: PUSH
10343: LD_INT 21
10345: PUSH
10346: LD_INT 3
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: PUSH
10353: LD_INT 30
10355: PUSH
10356: LD_INT 7
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PPUSH
10369: CALL_OW 69
10373: UNION
10374: PUSH
10375: LD_INT 22
10377: PUSH
10378: LD_EXP 2
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 52
10389: PUSH
10390: EMPTY
10391: LIST
10392: PUSH
10393: LD_INT 21
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: PUSH
10403: LD_INT 30
10405: PUSH
10406: LD_INT 8
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PPUSH
10419: CALL_OW 69
10423: UNION
10424: ST_TO_ADDR
// if Laby then
10425: LD_VAR 0 2
10429: IFFALSE 10532
// begin Laby = nahoda_seznam ( Laby ) ;
10431: LD_ADDR_VAR 0 2
10435: PUSH
10436: LD_VAR 0 2
10440: PPUSH
10441: CALL 21635 0 1
10445: ST_TO_ADDR
// X = GetX ( Laby ) ;
10446: LD_ADDR_VAR 0 3
10450: PUSH
10451: LD_VAR 0 2
10455: PPUSH
10456: CALL_OW 250
10460: ST_TO_ADDR
// Y = GetY ( Laby ) ;
10461: LD_ADDR_VAR 0 4
10465: PUSH
10466: LD_VAR 0 2
10470: PPUSH
10471: CALL_OW 251
10475: ST_TO_ADDR
// if Bergkamp in Uprchlici then
10476: LD_EXP 30
10480: PUSH
10481: LD_EXP 61
10485: IN
10486: IFFALSE 10509
// AddComMoveXY ( Bergkamp , X , Y ) else
10488: LD_EXP 30
10492: PPUSH
10493: LD_VAR 0 3
10497: PPUSH
10498: LD_VAR 0 4
10502: PPUSH
10503: CALL_OW 171
10507: GO 10532
// AddComMoveXY ( Uprchlici [ 1 ] , X , Y ) ;
10509: LD_EXP 61
10513: PUSH
10514: LD_INT 1
10516: ARRAY
10517: PPUSH
10518: LD_VAR 0 3
10522: PPUSH
10523: LD_VAR 0 4
10527: PPUSH
10528: CALL_OW 171
// end ; end ;
10532: LD_VAR 0 1
10536: RET
// function uprchlici_dotaz ; var Q ; begin
10537: LD_INT 0
10539: PPUSH
10540: PPUSH
// if Uprchlici_JsouTam then
10541: LD_LOC 13
10545: IFFALSE 10549
// exit ;
10547: GO 10673
// disable ( 14 ) ;
10549: LD_INT 14
10551: DISABLE_MARKED
// Uprchlici_JsouTam = true ;
10552: LD_ADDR_LOC 13
10556: PUSH
10557: LD_INT 1
10559: ST_TO_ADDR
// DialogueOn ;
10560: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
10564: LD_EXP 61
10568: PPUSH
10569: CALL_OW 85
// Wait ( 0 0$3 ) ;
10573: LD_INT 105
10575: PPUSH
10576: CALL_OW 67
// dialog_LegionFugit ;
10580: CALL 5056 0 0
// Q = query_LegionBergkamp ;
10584: LD_ADDR_VAR 0 2
10588: PUSH
10589: CALL 5100 0 0
10593: ST_TO_ADDR
// if Q = 1 then
10594: LD_VAR 0 2
10598: PUSH
10599: LD_INT 1
10601: EQUAL
10602: IFFALSE 10653
// begin LegionFugit_Accepted = true ;
10604: LD_ADDR_EXP 60
10608: PUSH
10609: LD_INT 1
10611: ST_TO_ADDR
// dialog_QrLegionBergkamp1 ;
10612: CALL 5121 0 0
// SetSide ( Uprchlici , side_Ru ) ;
10616: LD_EXP 61
10620: PPUSH
10621: LD_EXP 2
10625: PPUSH
10626: CALL_OW 235
// Rusove2 = Uprchlici ;
10630: LD_ADDR_EXP 40
10634: PUSH
10635: LD_EXP 61
10639: ST_TO_ADDR
// Hint ( Legion ) ;
10640: LD_STRING Legion
10642: PPUSH
10643: CALL_OW 339
// uprchlik_jdi_k_labu ;
10647: CALL 10265 0 0
// end else
10651: GO 10669
// begin LegionFugit_Accepted = false ;
10653: LD_ADDR_EXP 60
10657: PUSH
10658: LD_INT 0
10660: ST_TO_ADDR
// dialog_QrLegionBergkamp2 ;
10661: CALL 5153 0 0
// uprchlici_zacnete_odchazet ;
10665: CALL 10678 0 0
// end ; DialogueOff ;
10669: CALL_OW 7
// end ;
10673: LD_VAR 0 1
10677: RET
// export function uprchlici_zacnete_odchazet ; begin
10678: LD_INT 0
10680: PPUSH
// ComMoveToArea ( Uprchlici , Legion ) ;
10681: LD_EXP 61
10685: PPUSH
10686: LD_INT 4
10688: PPUSH
10689: CALL_OW 113
// enable ( 13 ) ;
10693: LD_INT 13
10695: ENABLE_MARKED
// end ;
10696: LD_VAR 0 1
10700: RET
// export function event_LegionPrebarvi ; begin
10701: LD_INT 0
10703: PPUSH
// SetSide ( MamPrebarvit , side_Le ) ;
10704: LD_LOC 27
10708: PPUSH
10709: LD_EXP 4
10713: PPUSH
10714: CALL_OW 235
// MamPrebarvit = [ ] ;
10718: LD_ADDR_LOC 27
10722: PUSH
10723: EMPTY
10724: ST_TO_ADDR
// end ;
10725: LD_VAR 0 1
10729: RET
// export function event_UprchliciPrisli ; begin
10730: LD_INT 0
10732: PPUSH
// uprchlici_dotaz ;
10733: CALL 10537 0 0
// end ;
10737: LD_VAR 0 1
10741: RET
// every 0 0$3.9 marked 13 do var Tam , Kdo ;
10742: GO 10744
10744: DISABLE
10745: LD_INT 0
10747: PPUSH
10748: PPUSH
// begin if not Uprchlici then
10749: LD_EXP 61
10753: NOT
10754: IFFALSE 10758
// exit ;
10756: GO 10857
// Tam = Uprchlici isect FilterUnitsInArea ( Legion , [ [ F_SIDE , side_Upr ] ] ) ;
10758: LD_ADDR_VAR 0 1
10762: PUSH
10763: LD_EXP 61
10767: PUSH
10768: LD_INT 4
10770: PPUSH
10771: LD_INT 22
10773: PUSH
10774: LD_EXP 5
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: PUSH
10783: EMPTY
10784: LIST
10785: PPUSH
10786: CALL_OW 70
10790: ISECT
10791: ST_TO_ADDR
// SetSide ( Tam , side_Le ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_EXP 4
10801: PPUSH
10802: CALL_OW 235
// Uprchlici = Uprchlici diff Tam ;
10806: LD_ADDR_EXP 61
10810: PUSH
10811: LD_EXP 61
10815: PUSH
10816: LD_VAR 0 1
10820: DIFF
10821: ST_TO_ADDR
// Rusove2 = Rusove2 diff Tam ;
10822: LD_ADDR_EXP 40
10826: PUSH
10827: LD_EXP 40
10831: PUSH
10832: LD_VAR 0 1
10836: DIFF
10837: ST_TO_ADDR
// if Uprchlici then
10838: LD_EXP 61
10842: IFFALSE 10857
// begin ComMoveToArea ( Uprchlici , Legion ) ;
10844: LD_EXP 61
10848: PPUSH
10849: LD_INT 4
10851: PPUSH
10852: CALL_OW 113
// enable ;
10856: ENABLE
// end ; end ;
10857: PPOPN 2
10859: END
// every 0 0$1.2 trigger vidi_strana_cloveka ( side_Upr , side_Ru ) marked 14 do
10860: LD_EXP 5
10864: PPUSH
10865: LD_EXP 2
10869: PPUSH
10870: CALL 21536 0 2
10874: IFFALSE 10901
10876: GO 10878
10878: DISABLE
// begin ComCancel ( Uprchlici ) ;
10879: LD_EXP 61
10883: PPUSH
10884: CALL_OW 127
// ComHold ( Uprchlici ) ;
10888: LD_EXP 61
10892: PPUSH
10893: CALL_OW 140
// uprchlici_dotaz ;
10897: CALL 10537 0 0
// end ;
10901: END
// every 13 13$0 do
10902: GO 10904
10904: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10905: LD_INT 35
10907: PPUSH
10908: LD_INT 4200
10910: PPUSH
10911: CALL_OW 12
10915: PPUSH
10916: CALL_OW 67
// while ProbihaUtok do
10920: LD_EXP 62
10924: IFFALSE 10935
// Wait ( 0 0$30 ) ;
10926: LD_INT 1050
10928: PPUSH
10929: CALL_OW 67
10933: GO 10920
// zavolej ;
10935: CALL 8011 0 0
// end ;
10939: END
// every 3 3$0 marked 11 do
10940: GO 10942
10942: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10943: LD_INT 35
10945: PPUSH
10946: LD_INT 4200
10948: PPUSH
10949: CALL_OW 12
10953: PPUSH
10954: CALL_OW 67
// prchajici ;
10958: CALL 10133 0 0
// end ;
10962: END
// every 0 0$4.9 marked 12 do
10963: GO 10965
10965: DISABLE
// begin enable ;
10966: ENABLE
// ovladani_nakladaku ;
10967: CALL 8899 0 0
// end ;
10971: END
// every 0 0$1 marked 15 do
10972: GO 10974
10974: DISABLE
// begin Wait ( dif_LegionTimeout [ Difficulty ] ) ;
10975: LD_EXP 57
10979: PUSH
10980: LD_OWVAR 67
10984: ARRAY
10985: PPUSH
10986: CALL_OW 67
// if not ProbihaPredavaniSurovin then
10990: LD_LOC 26
10994: NOT
10995: IFFALSE 10999
// exit ;
10997: GO 11003
// ukonci_nabidku ;
10999: CALL 11004 0 0
// end ;
11003: END
// function ukonci_nabidku ; var I ; begin
11004: LD_INT 0
11006: PPUSH
11007: PPUSH
// if Nabidka_Nalozeno then
11008: LD_LOC 21
11012: IFFALSE 11016
// exit ;
11014: GO 11149
// if Nabidka_Vylozeno then
11016: LD_LOC 22
11020: IFFALSE 11024
// exit ;
11022: GO 11149
// if not ProbihaPredavaniSurovin then
11024: LD_LOC 26
11028: NOT
11029: IFFALSE 11033
// exit ;
11031: GO 11149
// ProbihaPredavaniSurovin = false ;
11033: LD_ADDR_LOC 26
11037: PUSH
11038: LD_INT 0
11040: ST_TO_ADDR
// prestan_popojizdet ;
11041: CALL 8874 0 0
// disable ( 12 ) ;
11045: LD_INT 12
11047: DISABLE_MARKED
// disable ( 15 ) ;
11048: LD_INT 15
11050: DISABLE_MARKED
// for I in Nabidka_Nakladaky do
11051: LD_ADDR_VAR 0 2
11055: PUSH
11056: LD_LOC 17
11060: PUSH
11061: FOR_IN
11062: IFFALSE 11118
// begin if ( GetSide ( I ) = side_Ru ) then
11064: LD_VAR 0 2
11068: PPUSH
11069: CALL_OW 255
11073: PUSH
11074: LD_EXP 2
11078: EQUAL
11079: IFFALSE 11083
// continue ;
11081: GO 11061
// SetSide ( I , side_Le ) ;
11083: LD_VAR 0 2
11087: PPUSH
11088: LD_EXP 4
11092: PPUSH
11093: CALL_OW 235
// SetSide ( IsDrivenBy ( I ) , side_Le ) ;
11097: LD_VAR 0 2
11101: PPUSH
11102: CALL_OW 311
11106: PPUSH
11107: LD_EXP 4
11111: PPUSH
11112: CALL_OW 235
// end ;
11116: GO 11061
11118: POP
11119: POP
// ComMoveToArea ( Nabidka_Nakladaky , LeDepot ) ;
11120: LD_LOC 17
11124: PPUSH
11125: LD_INT 20
11127: PPUSH
11128: CALL_OW 113
// Nabidka_Nakladaky = [ ] ;
11132: LD_ADDR_LOC 17
11136: PUSH
11137: EMPTY
11138: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
11139: LD_ADDR_LOC 18
11143: PUSH
11144: EMPTY
11145: ST_TO_ADDR
// enable ( 11 ) ;
11146: LD_INT 11
11148: ENABLE_MARKED
// end ;
11149: LD_VAR 0 1
11153: RET
// function testuj_konec_nabidky ( Un ) ; begin
11154: LD_INT 0
11156: PPUSH
// if ( Un in Nabidka_Nakladaky ) or ( Un in Nabidka_Ridici ) then
11157: LD_VAR 0 1
11161: PUSH
11162: LD_LOC 17
11166: IN
11167: PUSH
11168: LD_VAR 0 1
11172: PUSH
11173: LD_LOC 18
11177: IN
11178: OR
11179: IFFALSE 11185
// ukonci_nabidku ;
11181: CALL 11004 0 0
// end ;
11185: LD_VAR 0 2
11189: RET
// export function legion_Contact ( Side1 , Side2 ) ; begin
11190: LD_INT 0
11192: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Le ) ) or ( ( Side1 = side_Le ) and ( Side1 = side_Ru ) ) then
11193: LD_VAR 0 1
11197: PUSH
11198: LD_EXP 2
11202: EQUAL
11203: PUSH
11204: LD_VAR 0 2
11208: PUSH
11209: LD_EXP 4
11213: EQUAL
11214: AND
11215: PUSH
11216: LD_VAR 0 1
11220: PUSH
11221: LD_EXP 4
11225: EQUAL
11226: PUSH
11227: LD_VAR 0 1
11231: PUSH
11232: LD_EXP 2
11236: EQUAL
11237: AND
11238: OR
11239: IFFALSE 11251
// if ProbihaPredavaniSurovin then
11241: LD_LOC 26
11245: IFFALSE 11251
// ukonci_nabidku ;
11247: CALL 11004 0 0
// end ;
11251: LD_VAR 0 3
11255: RET
// export function legion_VehicleCaptured ( VewNew , VehOld , OrigSide , Hum ) ; begin
11256: LD_INT 0
11258: PPUSH
// testuj_konec_nabidky ( VehOld ) ;
11259: LD_VAR 0 2
11263: PPUSH
11264: CALL 11154 0 1
// end ;
11268: LD_VAR 0 5
11272: RET
// export function legion_UnitDestroyed ( Un ) ; var Cancel ; begin
11273: LD_INT 0
11275: PPUSH
11276: PPUSH
// if Un in Obranci then
11277: LD_VAR 0 1
11281: PUSH
11282: LD_LOC 10
11286: IN
11287: IFFALSE 11308
// Obranci = Obranci diff [ Un ] ;
11289: LD_ADDR_LOC 10
11293: PUSH
11294: LD_LOC 10
11298: PUSH
11299: LD_VAR 0 1
11303: PUSH
11304: EMPTY
11305: LIST
11306: DIFF
11307: ST_TO_ADDR
// if Un in Mechanici then
11308: LD_VAR 0 1
11312: PUSH
11313: LD_LOC 11
11317: IN
11318: IFFALSE 11339
// Mechanici = Mechanici diff [ Un ] ;
11320: LD_ADDR_LOC 11
11324: PUSH
11325: LD_LOC 11
11329: PUSH
11330: LD_VAR 0 1
11334: PUSH
11335: EMPTY
11336: LIST
11337: DIFF
11338: ST_TO_ADDR
// if Un in Ridici then
11339: LD_VAR 0 1
11343: PUSH
11344: LD_LOC 12
11348: IN
11349: IFFALSE 11370
// Ridici = Ridici diff [ Un ] ;
11351: LD_ADDR_LOC 12
11355: PUSH
11356: LD_LOC 12
11360: PUSH
11361: LD_VAR 0 1
11365: PUSH
11366: EMPTY
11367: LIST
11368: DIFF
11369: ST_TO_ADDR
// if Un in Uprchlici then
11370: LD_VAR 0 1
11374: PUSH
11375: LD_EXP 61
11379: IN
11380: IFFALSE 11401
// Uprchlici = Uprchlici diff [ Un ] ;
11382: LD_ADDR_EXP 61
11386: PUSH
11387: LD_EXP 61
11391: PUSH
11392: LD_VAR 0 1
11396: PUSH
11397: EMPTY
11398: LIST
11399: DIFF
11400: ST_TO_ADDR
// if Un in KdoLeci then
11401: LD_VAR 0 1
11405: PUSH
11406: LD_LOC 24
11410: IN
11411: IFFALSE 11432
// KdoLeci = KdoLeci diff [ Un ] ;
11413: LD_ADDR_LOC 24
11417: PUSH
11418: LD_LOC 24
11422: PUSH
11423: LD_VAR 0 1
11427: PUSH
11428: EMPTY
11429: LIST
11430: DIFF
11431: ST_TO_ADDR
// if Un in KdoOpravuje then
11432: LD_VAR 0 1
11436: PUSH
11437: LD_LOC 25
11441: IN
11442: IFFALSE 11463
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
11444: LD_ADDR_LOC 25
11448: PUSH
11449: LD_LOC 25
11453: PUSH
11454: LD_VAR 0 1
11458: PUSH
11459: EMPTY
11460: LIST
11461: DIFF
11462: ST_TO_ADDR
// testuj_konec_nabidky ( Un ) ;
11463: LD_VAR 0 1
11467: PPUSH
11468: CALL 11154 0 1
// if Un in Nabidka_Nakladaky then
11472: LD_VAR 0 1
11476: PUSH
11477: LD_LOC 17
11481: IN
11482: IFFALSE 11503
// Nabidka_Nakladaky = Nabidka_Nakladaky diff [ Un ] ;
11484: LD_ADDR_LOC 17
11488: PUSH
11489: LD_LOC 17
11493: PUSH
11494: LD_VAR 0 1
11498: PUSH
11499: EMPTY
11500: LIST
11501: DIFF
11502: ST_TO_ADDR
// if Un in Nabidka_Ridici then
11503: LD_VAR 0 1
11507: PUSH
11508: LD_LOC 18
11512: IN
11513: IFFALSE 11534
// Nabidka_Ridici = Nabidka_Ridici diff [ Un ] ;
11515: LD_ADDR_LOC 18
11519: PUSH
11520: LD_LOC 18
11524: PUSH
11525: LD_VAR 0 1
11529: PUSH
11530: EMPTY
11531: LIST
11532: DIFF
11533: ST_TO_ADDR
// end ; end_of_file
11534: LD_VAR 0 2
11538: RET
// var ArSci1 , ArSci2 , ArSci3 , ArSci4 , ArMech1 , ArMech2 , ArEng1 , ArEng2 ; var ArMechDalkar ; var Obranci , Sejkove , VolnyLidi ; var Auta , Utok_Auta ; var KdoOtravuje ; var MakroObrana ; var Miny ; var ObranaBehemota ; var MakroKamikaze ; var RegUtok ; var VolnyRidiciOpicaci ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var MakroUtok ; export ProbihaUtok ; var CisloUtoku ; var PrvniUtok ; var Utok_ZbyvaMinut ; var CasyUtoku ; var PstZbrane ; var VidelRusa ; var MakroPresunZakladna ; var BeziStahovani ; var MaxOpice ; var ZpozdeniOpice ; var PstOpiceRus ; var OpiceLimit ; var OpiceNajednouPocet ; var KdoLeci ; var KdoOpravuje ; var KdoLakaOpice ; export function init_arabi ; var Reg , Base ; begin
11539: LD_INT 0
11541: PPUSH
11542: PPUSH
11543: PPUSH
// disable ( 31 ) ;
11544: LD_INT 31
11546: DISABLE_MARKED
// disable ( 32 ) ;
11547: LD_INT 32
11549: DISABLE_MARKED
// disable ( 33 ) ;
11550: LD_INT 33
11552: DISABLE_MARKED
// SetBName ( ArDepot , newsamark ) ;
11553: LD_INT 1
11555: PPUSH
11556: LD_STRING newsamark
11558: PPUSH
11559: CALL_OW 500
// KdoOtravuje = [ ] ;
11563: LD_ADDR_LOC 42
11567: PUSH
11568: EMPTY
11569: ST_TO_ADDR
// Auta = [ ] ;
11570: LD_ADDR_LOC 40
11574: PUSH
11575: EMPTY
11576: ST_TO_ADDR
// Utok_Auta = [ ] ;
11577: LD_ADDR_LOC 41
11581: PUSH
11582: EMPTY
11583: ST_TO_ADDR
// ObranaBehemota = [ ArProp1 , ArProp2 , ArProp3 ] ;
11584: LD_ADDR_LOC 45
11588: PUSH
11589: LD_INT 44
11591: PUSH
11592: LD_INT 45
11594: PUSH
11595: LD_INT 46
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: LIST
11602: ST_TO_ADDR
// VolnyRidiciOpicaci = 0 ;
11603: LD_ADDR_LOC 48
11607: PUSH
11608: LD_INT 0
11610: ST_TO_ADDR
// ArDalkar = 0 ;
11611: LD_ADDR_LOC 49
11615: PUSH
11616: LD_INT 0
11618: ST_TO_ADDR
// KolikDalkovych = 0 ;
11619: LD_ADDR_LOC 50
11623: PUSH
11624: LD_INT 0
11626: ST_TO_ADDR
// DelamDalkare = false ;
11627: LD_ADDR_LOC 51
11631: PUSH
11632: LD_INT 0
11634: ST_TO_ADDR
// ProbihaUtok = false ;
11635: LD_ADDR_EXP 62
11639: PUSH
11640: LD_INT 0
11642: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
11643: LD_ADDR_LOC 55
11647: PUSH
11648: LD_INT 1
11650: NEG
11651: ST_TO_ADDR
// CisloUtoku = 1 ;
11652: LD_ADDR_LOC 53
11656: PUSH
11657: LD_INT 1
11659: ST_TO_ADDR
// VidelRusa = false ;
11660: LD_ADDR_LOC 58
11664: PUSH
11665: LD_INT 0
11667: ST_TO_ADDR
// KdoLeci = [ ] ;
11668: LD_ADDR_LOC 66
11672: PUSH
11673: EMPTY
11674: ST_TO_ADDR
// KdoOpravuje = [ ] ;
11675: LD_ADDR_LOC 67
11679: PUSH
11680: EMPTY
11681: ST_TO_ADDR
// KdoLakaOpice = [ ] ;
11682: LD_ADDR_LOC 68
11686: PUSH
11687: EMPTY
11688: ST_TO_ADDR
// if Difficulty = 1 then
11689: LD_OWVAR 67
11693: PUSH
11694: LD_INT 1
11696: EQUAL
11697: IFFALSE 11713
// begin DestroyUnit ( ArBunk2 ) ;
11699: LD_INT 34
11701: PPUSH
11702: CALL_OW 65
// DestroyUnit ( ArBunk5 ) ;
11706: LD_INT 42
11708: PPUSH
11709: CALL_OW 65
// end ; PrvniUtok = dif_PrvniUtok [ Difficulty ] ;
11713: LD_ADDR_LOC 54
11717: PUSH
11718: LD_EXP 49
11722: PUSH
11723: LD_OWVAR 67
11727: ARRAY
11728: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
11729: LD_ADDR_LOC 56
11733: PUSH
11734: LD_EXP 48
11738: PUSH
11739: LD_OWVAR 67
11743: ARRAY
11744: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
11745: LD_ADDR_LOC 57
11749: PUSH
11750: LD_EXP 50
11754: PUSH
11755: LD_OWVAR 67
11759: ARRAY
11760: ST_TO_ADDR
// MaxOpice = dif_MaxOpice [ Difficulty ] ;
11761: LD_ADDR_LOC 61
11765: PUSH
11766: LD_EXP 51
11770: PUSH
11771: LD_OWVAR 67
11775: ARRAY
11776: ST_TO_ADDR
// ZpozdeniOpice = dif_ZpozdeniOpice [ Difficulty ] ;
11777: LD_ADDR_LOC 62
11781: PUSH
11782: LD_EXP 52
11786: PUSH
11787: LD_OWVAR 67
11791: ARRAY
11792: ST_TO_ADDR
// PstOpiceRus = dif_PstOpiceRus [ Difficulty ] ;
11793: LD_ADDR_LOC 63
11797: PUSH
11798: LD_EXP 53
11802: PUSH
11803: LD_OWVAR 67
11807: ARRAY
11808: ST_TO_ADDR
// OpiceLimit = dif_OpiceLimit [ Difficulty ] ;
11809: LD_ADDR_LOC 64
11813: PUSH
11814: LD_EXP 54
11818: PUSH
11819: LD_OWVAR 67
11823: ARRAY
11824: ST_TO_ADDR
// OpiceNajednouPocet = dif_OpiceNajednouPocet [ Difficulty ] ;
11825: LD_ADDR_LOC 65
11829: PUSH
11830: LD_EXP 55
11834: PUSH
11835: LD_OWVAR 67
11839: ARRAY
11840: ST_TO_ADDR
// vytvor_postavy ;
11841: CALL 12475 0 0
// Base = GetBase ( ArDepot ) ;
11845: LD_ADDR_VAR 0 3
11849: PUSH
11850: LD_INT 1
11852: PPUSH
11853: CALL_OW 274
11857: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 300 , 400 ) ) ;
11858: LD_VAR 0 3
11862: PPUSH
11863: LD_INT 1
11865: PPUSH
11866: LD_INT 300
11868: PPUSH
11869: LD_INT 400
11871: PPUSH
11872: CALL_OW 12
11876: PPUSH
11877: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 100 , 300 ) ) ;
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_INT 2
11888: PPUSH
11889: LD_INT 100
11891: PPUSH
11892: LD_INT 300
11894: PPUSH
11895: CALL_OW 12
11899: PPUSH
11900: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 40 , 80 ) ) ;
11904: LD_VAR 0 3
11908: PPUSH
11909: LD_INT 3
11911: PPUSH
11912: LD_INT 40
11914: PPUSH
11915: LD_INT 80
11917: PPUSH
11918: CALL_OW 12
11922: PPUSH
11923: CALL_OW 277
// Reg = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , AraboveObrana ] ] ) ;
11927: LD_ADDR_VAR 0 2
11931: PUSH
11932: LD_EXP 3
11936: PPUSH
11937: LD_INT 3
11939: PUSH
11940: LD_INT 12
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: EMPTY
11948: LIST
11949: PPUSH
11950: CALL_OW 399
11954: ST_TO_ADDR
// MakroObrana = McDefend ( 0 , Reg , Sejkove union Obranci union VolnyLidi union [ ArBarracks , ArBunk1 , ArBunk2 , ArBunk3 , ArBunk4 , ArBunk5 , ArBunk6 ] , [ [ MC_AREA_DONT_LEAVE , Arabove ] ] ) ;
11955: LD_ADDR_LOC 43
11959: PUSH
11960: LD_INT 0
11962: PPUSH
11963: LD_VAR 0 2
11967: PPUSH
11968: LD_LOC 38
11972: PUSH
11973: LD_LOC 37
11977: UNION
11978: PUSH
11979: LD_LOC 39
11983: UNION
11984: PUSH
11985: LD_INT 32
11987: PUSH
11988: LD_INT 33
11990: PUSH
11991: LD_INT 34
11993: PUSH
11994: LD_INT 19
11996: PUSH
11997: LD_INT 41
11999: PUSH
12000: LD_INT 42
12002: PUSH
12003: LD_INT 18
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: UNION
12015: PPUSH
12016: LD_INT 2
12018: PUSH
12019: LD_INT 5
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PUSH
12026: EMPTY
12027: LIST
12028: PPUSH
12029: CALL_OW 401
12033: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Sejkove union Obranci union VolnyLidi ) ;
12034: LD_ADDR_LOC 59
12038: PUSH
12039: LD_INT 1
12041: PPUSH
12042: LD_LOC 38
12046: PUSH
12047: LD_LOC 37
12051: UNION
12052: PUSH
12053: LD_LOC 39
12057: UNION
12058: PPUSH
12059: CALL_OW 416
12063: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , RusoveUtok ] , MC_REG_IGNORE_FOG ] ) ;
12064: LD_ADDR_LOC 47
12068: PUSH
12069: LD_EXP 3
12073: PPUSH
12074: LD_INT 2
12076: PUSH
12077: LD_INT 11
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 7
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 399
12095: ST_TO_ADDR
// MakroKamikaze = McAttack ( 20 , RegUtok , [ ] , [ MC_NO_STOP ] ) ;
12096: LD_ADDR_LOC 46
12100: PUSH
12101: LD_INT 20
12103: PPUSH
12104: LD_LOC 47
12108: PPUSH
12109: EMPTY
12110: PPUSH
12111: LD_INT 10
12113: PUSH
12114: EMPTY
12115: LIST
12116: PPUSH
12117: CALL_OW 402
12121: ST_TO_ADDR
// MakroUtok = 0 ;
12122: LD_ADDR_LOC 52
12126: PUSH
12127: LD_INT 0
12129: ST_TO_ADDR
// init_miny ;
12130: CALL 12139 0 0
// end ;
12134: LD_VAR 0 1
12138: RET
// function init_miny ; var M ; begin
12139: LD_INT 0
12141: PPUSH
12142: PPUSH
// if Difficulty = 1 then
12143: LD_OWVAR 67
12147: PUSH
12148: LD_INT 1
12150: EQUAL
12151: IFFALSE 12162
// Miny = [ ] else
12153: LD_ADDR_LOC 44
12157: PUSH
12158: EMPTY
12159: ST_TO_ADDR
12160: GO 12470
// begin Miny = [ [ 168 , 77 ] , [ 169 , 76 ] , [ 170 , 75 ] , [ 179 , 90 ] , [ 178 , 87 ] , [ 179 , 86 ] ] ;
12162: LD_ADDR_LOC 44
12166: PUSH
12167: LD_INT 168
12169: PUSH
12170: LD_INT 77
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 169
12179: PUSH
12180: LD_INT 76
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 170
12189: PUSH
12190: LD_INT 75
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 179
12199: PUSH
12200: LD_INT 90
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 178
12209: PUSH
12210: LD_INT 87
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: PUSH
12217: LD_INT 179
12219: PUSH
12220: LD_INT 86
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: LIST
12231: LIST
12232: LIST
12233: LIST
12234: ST_TO_ADDR
// if Difficulty = 3 then
12235: LD_OWVAR 67
12239: PUSH
12240: LD_INT 3
12242: EQUAL
12243: IFFALSE 12423
// Miny = Miny ^ [ [ 170 , 79 ] , [ 171 , 78 ] , [ 172 , 77 ] , [ 87 , 5 ] , [ 89 , 13 ] , [ 97 , 24 ] , [ 97 , 23 ] , [ 103 , 33 ] , [ 111 , 41 ] , [ 120 , 52 ] , [ 128 , 57 ] , [ 140 , 62 ] , [ 148 , 76 ] , [ 154 , 86 ] , [ 161 , 87 ] ] ;
12245: LD_ADDR_LOC 44
12249: PUSH
12250: LD_LOC 44
12254: PUSH
12255: LD_INT 170
12257: PUSH
12258: LD_INT 79
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 171
12267: PUSH
12268: LD_INT 78
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 172
12277: PUSH
12278: LD_INT 77
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 87
12287: PUSH
12288: LD_INT 5
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: LD_INT 89
12297: PUSH
12298: LD_INT 13
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 97
12307: PUSH
12308: LD_INT 24
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: PUSH
12315: LD_INT 97
12317: PUSH
12318: LD_INT 23
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: PUSH
12325: LD_INT 103
12327: PUSH
12328: LD_INT 33
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 111
12337: PUSH
12338: LD_INT 41
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: PUSH
12345: LD_INT 120
12347: PUSH
12348: LD_INT 52
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: PUSH
12355: LD_INT 128
12357: PUSH
12358: LD_INT 57
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: PUSH
12365: LD_INT 140
12367: PUSH
12368: LD_INT 62
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PUSH
12375: LD_INT 148
12377: PUSH
12378: LD_INT 76
12380: PUSH
12381: EMPTY
12382: LIST
12383: LIST
12384: PUSH
12385: LD_INT 154
12387: PUSH
12388: LD_INT 86
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: PUSH
12395: LD_INT 161
12397: PUSH
12398: LD_INT 87
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: ADD
12422: ST_TO_ADDR
// for M in Miny do
12423: LD_ADDR_VAR 0 2
12427: PUSH
12428: LD_LOC 44
12432: PUSH
12433: FOR_IN
12434: IFFALSE 12468
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
12436: LD_VAR 0 2
12440: PUSH
12441: LD_INT 1
12443: ARRAY
12444: PPUSH
12445: LD_VAR 0 2
12449: PUSH
12450: LD_INT 2
12452: ARRAY
12453: PPUSH
12454: LD_EXP 3
12458: PPUSH
12459: LD_INT 0
12461: PPUSH
12462: CALL_OW 454
12466: GO 12433
12468: POP
12469: POP
// end ; end ;
12470: LD_VAR 0 1
12474: RET
// function vytvor_postavy ; var Bunkry , B ; begin
12475: LD_INT 0
12477: PPUSH
12478: PPUSH
12479: PPUSH
// ArSci1 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12480: LD_ADDR_LOC 28
12484: PUSH
12485: LD_INT 11
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: CALL 12983 0 2
12495: ST_TO_ADDR
// ArSci2 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12496: LD_ADDR_LOC 29
12500: PUSH
12501: LD_INT 11
12503: PPUSH
12504: LD_INT 4
12506: PPUSH
12507: CALL 12983 0 2
12511: ST_TO_ADDR
// ArSci3 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12512: LD_ADDR_LOC 30
12516: PUSH
12517: LD_INT 12
12519: PPUSH
12520: LD_INT 4
12522: PPUSH
12523: CALL 12983 0 2
12527: ST_TO_ADDR
// ArSci4 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12528: LD_ADDR_LOC 31
12532: PUSH
12533: LD_INT 12
12535: PPUSH
12536: LD_INT 4
12538: PPUSH
12539: CALL 12983 0 2
12543: ST_TO_ADDR
// ArMech1 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12544: LD_ADDR_LOC 32
12548: PUSH
12549: LD_INT 5
12551: PPUSH
12552: LD_INT 3
12554: PPUSH
12555: CALL 12983 0 2
12559: ST_TO_ADDR
// ArMech2 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12560: LD_ADDR_LOC 33
12564: PUSH
12565: LD_INT 5
12567: PPUSH
12568: LD_INT 3
12570: PPUSH
12571: CALL 12983 0 2
12575: ST_TO_ADDR
// vytvor_postavu_B ( ArDepot , CLASS_ENGINEER ) ;
12576: LD_INT 1
12578: PPUSH
12579: LD_INT 2
12581: PPUSH
12582: CALL 12983 0 2
// ArEng1 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12586: LD_ADDR_LOC 34
12590: PUSH
12591: LD_INT 5
12593: PPUSH
12594: LD_INT 2
12596: PPUSH
12597: CALL 13020 0 2
12601: ST_TO_ADDR
// ArEng2 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12602: LD_ADDR_LOC 35
12606: PUSH
12607: LD_INT 5
12609: PPUSH
12610: LD_INT 2
12612: PPUSH
12613: CALL 13020 0 2
12617: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 2 + 2 * Difficulty , Arabove , CLASS_SOLDIER ) ;
12618: LD_ADDR_LOC 37
12622: PUSH
12623: LD_INT 2
12625: PUSH
12626: LD_INT 2
12628: PUSH
12629: LD_OWVAR 67
12633: MUL
12634: PLUS
12635: PPUSH
12636: LD_INT 5
12638: PPUSH
12639: LD_INT 1
12641: PPUSH
12642: CALL 13060 0 3
12646: ST_TO_ADDR
// VolnyLidi = vytvor_postavy_A ( 2 + dif_AraboveRidici [ Difficulty ] , Arabove , CLASS_SOLDIER ) ;
12647: LD_ADDR_LOC 39
12651: PUSH
12652: LD_INT 2
12654: PUSH
12655: LD_EXP 46
12659: PUSH
12660: LD_OWVAR 67
12664: ARRAY
12665: PLUS
12666: PPUSH
12667: LD_INT 5
12669: PPUSH
12670: LD_INT 1
12672: PPUSH
12673: CALL 13060 0 3
12677: ST_TO_ADDR
// ArMechDalkar = vytvor_postavu_A ( Arabove , CLASS_MECHANIC ) ;
12678: LD_ADDR_LOC 36
12682: PUSH
12683: LD_INT 5
12685: PPUSH
12686: LD_INT 3
12688: PPUSH
12689: CALL 13020 0 2
12693: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
12694: LD_ADDR_VAR 0 2
12698: PUSH
12699: LD_INT 22
12701: PUSH
12702: LD_EXP 3
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: LD_INT 21
12713: PUSH
12714: LD_INT 3
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: PUSH
12721: LD_INT 30
12723: PUSH
12724: LD_INT 32
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: LIST
12735: PPUSH
12736: CALL_OW 69
12740: ST_TO_ADDR
// for B in Bunkry do
12741: LD_ADDR_VAR 0 3
12745: PUSH
12746: LD_VAR 0 2
12750: PUSH
12751: FOR_IN
12752: IFFALSE 12783
// Obranci = Obranci union [ vytvor_postavu_B ( B , CLASS_SOLDIER ) ] ;
12754: LD_ADDR_LOC 37
12758: PUSH
12759: LD_LOC 37
12763: PUSH
12764: LD_VAR 0 3
12768: PPUSH
12769: LD_INT 1
12771: PPUSH
12772: CALL 12983 0 2
12776: PUSH
12777: EMPTY
12778: LIST
12779: UNION
12780: ST_TO_ADDR
12781: GO 12751
12783: POP
12784: POP
// if Abdul then
12785: LD_EXP 31
12789: IFFALSE 12806
// PlaceUnitArea ( Abdul , Arabove , false ) ;
12791: LD_EXP 31
12795: PPUSH
12796: LD_INT 5
12798: PPUSH
12799: LD_INT 0
12801: PPUSH
12802: CALL_OW 49
// if Omar then
12806: LD_EXP 32
12810: IFFALSE 12827
// PlaceUnitArea ( Omar , Arabove , false ) ;
12812: LD_EXP 32
12816: PPUSH
12817: LD_INT 5
12819: PPUSH
12820: LD_INT 0
12822: PPUSH
12823: CALL_OW 49
// Sejkove = vytvor_postavy_A ( 1 + Difficulty , Arabove , CLASS_DESERT_WARIOR ) ;
12827: LD_ADDR_LOC 38
12831: PUSH
12832: LD_INT 1
12834: PUSH
12835: LD_OWVAR 67
12839: PLUS
12840: PPUSH
12841: LD_INT 5
12843: PPUSH
12844: LD_INT 11
12846: PPUSH
12847: CALL 13060 0 3
12851: ST_TO_ADDR
// if Abdul then
12852: LD_EXP 31
12856: IFFALSE 12877
// Sejkove = Sejkove union [ Abdul ] ;
12858: LD_ADDR_LOC 38
12862: PUSH
12863: LD_LOC 38
12867: PUSH
12868: LD_EXP 31
12872: PUSH
12873: EMPTY
12874: LIST
12875: UNION
12876: ST_TO_ADDR
// if Omar then
12877: LD_EXP 32
12881: IFFALSE 12902
// Sejkove = Sejkove union [ Omar ] ;
12883: LD_ADDR_LOC 38
12887: PUSH
12888: LD_LOC 38
12892: PUSH
12893: LD_EXP 32
12897: PUSH
12898: EMPTY
12899: LIST
12900: UNION
12901: ST_TO_ADDR
// end ;
12902: LD_VAR 0 1
12906: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
12907: LD_INT 0
12909: PPUSH
12910: PPUSH
12911: PPUSH
// UC_Side = side_Ar ;
12912: LD_ADDR_OWVAR 20
12916: PUSH
12917: LD_EXP 3
12921: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
12922: LD_ADDR_OWVAR 21
12926: PUSH
12927: LD_INT 2
12929: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
12930: LD_ADDR_OWVAR 27
12934: PUSH
12935: LD_INT 1
12937: PPUSH
12938: LD_INT 2
12940: PPUSH
12941: CALL_OW 12
12945: ST_TO_ADDR
// HC_Class = Cls ;
12946: LD_ADDR_OWVAR 28
12950: PUSH
12951: LD_VAR 0 1
12955: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
12956: LD_VAR 0 1
12960: PPUSH
12961: LD_INT 7
12963: PPUSH
12964: CALL_OW 374
// Result = CreateHuman ;
12968: LD_ADDR_VAR 0 2
12972: PUSH
12973: CALL_OW 44
12977: ST_TO_ADDR
// end ;
12978: LD_VAR 0 2
12982: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
12983: LD_INT 0
12985: PPUSH
// Result = vytvor_postavu ( Cls ) ;
12986: LD_ADDR_VAR 0 3
12990: PUSH
12991: LD_VAR 0 2
12995: PPUSH
12996: CALL 12907 0 1
13000: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
13001: LD_VAR 0 3
13005: PPUSH
13006: LD_VAR 0 1
13010: PPUSH
13011: CALL_OW 52
// end ;
13015: LD_VAR 0 3
13019: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
13020: LD_INT 0
13022: PPUSH
// Result = vytvor_postavu ( Cls ) ;
13023: LD_ADDR_VAR 0 3
13027: PUSH
13028: LD_VAR 0 2
13032: PPUSH
13033: CALL 12907 0 1
13037: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
13038: LD_VAR 0 3
13042: PPUSH
13043: LD_VAR 0 1
13047: PPUSH
13048: LD_INT 0
13050: PPUSH
13051: CALL_OW 49
// end ;
13055: LD_VAR 0 3
13059: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
13060: LD_INT 0
13062: PPUSH
13063: PPUSH
// Result = [ ] ;
13064: LD_ADDR_VAR 0 4
13068: PUSH
13069: EMPTY
13070: ST_TO_ADDR
// for I = 1 to Pocet do
13071: LD_ADDR_VAR 0 5
13075: PUSH
13076: DOUBLE
13077: LD_INT 1
13079: DEC
13080: ST_TO_ADDR
13081: LD_VAR 0 1
13085: PUSH
13086: FOR_TO
13087: IFFALSE 13120
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
13089: LD_ADDR_VAR 0 4
13093: PUSH
13094: LD_VAR 0 4
13098: PUSH
13099: LD_VAR 0 2
13103: PPUSH
13104: LD_VAR 0 3
13108: PPUSH
13109: CALL 13020 0 2
13113: PUSH
13114: EMPTY
13115: LIST
13116: UNION
13117: ST_TO_ADDR
13118: GO 13086
13120: POP
13121: POP
// end ;
13122: LD_VAR 0 4
13126: RET
// function zpet_do_labu ( Kdo ) ; begin
13127: LD_INT 0
13129: PPUSH
// if Kdo = ArSci1 then
13130: LD_VAR 0 1
13134: PUSH
13135: LD_LOC 28
13139: EQUAL
13140: IFFALSE 13156
// AddComEnterUnit ( Kdo , ArLabWS ) else
13142: LD_VAR 0 1
13146: PPUSH
13147: LD_INT 11
13149: PPUSH
13150: CALL_OW 180
13154: GO 13232
// if Kdo = ArSci2 then
13156: LD_VAR 0 1
13160: PUSH
13161: LD_LOC 29
13165: EQUAL
13166: IFFALSE 13182
// AddComEnterUnit ( Kdo , ArLabWS ) else
13168: LD_VAR 0 1
13172: PPUSH
13173: LD_INT 11
13175: PPUSH
13176: CALL_OW 180
13180: GO 13232
// if Kdo = ArSci3 then
13182: LD_VAR 0 1
13186: PUSH
13187: LD_LOC 30
13191: EQUAL
13192: IFFALSE 13208
// AddComEnterUnit ( Kdo , ArLabBO ) else
13194: LD_VAR 0 1
13198: PPUSH
13199: LD_INT 12
13201: PPUSH
13202: CALL_OW 180
13206: GO 13232
// if Kdo = ArSci4 then
13208: LD_VAR 0 1
13212: PUSH
13213: LD_LOC 31
13217: EQUAL
13218: IFFALSE 13232
// AddComEnterUnit ( Kdo , ArLabBO ) ;
13220: LD_VAR 0 1
13224: PPUSH
13225: LD_INT 12
13227: PPUSH
13228: CALL_OW 180
// end ;
13232: LD_VAR 0 2
13236: RET
// function zacni_vynalezat ; begin
13237: LD_INT 0
13239: PPUSH
// AddComResearch ( ArLabWS , TECH_ROCKET ) ;
13240: LD_INT 11
13242: PPUSH
13243: LD_INT 40
13245: PPUSH
13246: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_FLAME ) ;
13250: LD_INT 11
13252: PPUSH
13253: LD_INT 70
13255: PPUSH
13256: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_MORTAR ) ;
13260: LD_INT 11
13262: PPUSH
13263: LD_INT 41
13265: PPUSH
13266: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_EXPLOS ) ;
13270: LD_INT 11
13272: PPUSH
13273: LD_INT 42
13275: PPUSH
13276: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SELFDEST ) ;
13280: LD_INT 11
13282: PPUSH
13283: LD_INT 43
13285: PPUSH
13286: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP1 ) ;
13290: LD_INT 11
13292: PPUSH
13293: LD_INT 51
13295: PPUSH
13296: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB1 ) ;
13300: LD_INT 11
13302: PPUSH
13303: LD_INT 54
13305: PPUSH
13306: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP2 ) ;
13310: LD_INT 11
13312: PPUSH
13313: LD_INT 52
13315: PPUSH
13316: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB2 ) ;
13320: LD_INT 11
13322: PPUSH
13323: LD_INT 55
13325: PPUSH
13326: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP3 ) ;
13330: LD_INT 11
13332: PPUSH
13333: LD_INT 53
13335: PPUSH
13336: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB3 ) ;
13340: LD_INT 11
13342: PPUSH
13343: LD_INT 56
13345: PPUSH
13346: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_RADAR ) ;
13350: LD_INT 12
13352: PPUSH
13353: LD_INT 6
13355: PPUSH
13356: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_REMCONT ) ;
13360: LD_INT 12
13362: PPUSH
13363: LD_INT 15
13365: PPUSH
13366: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_STIMDRUGS ) ;
13370: LD_INT 12
13372: PPUSH
13373: LD_INT 5
13375: PPUSH
13376: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIODET ) ;
13380: LD_INT 12
13382: PPUSH
13383: LD_INT 8
13385: PPUSH
13386: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_MATDET ) ;
13390: LD_INT 12
13392: PPUSH
13393: LD_INT 7
13395: PPUSH
13396: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_HIDCAM ) ;
13400: LD_INT 12
13402: PPUSH
13403: LD_INT 17
13405: PPUSH
13406: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH1 ) ;
13410: LD_INT 12
13412: PPUSH
13413: LD_INT 48
13415: PPUSH
13416: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO1 ) ;
13420: LD_INT 12
13422: PPUSH
13423: LD_INT 66
13425: PPUSH
13426: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO1 ) ;
13430: LD_INT 12
13432: PPUSH
13433: LD_INT 60
13435: PPUSH
13436: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH2 ) ;
13440: LD_INT 12
13442: PPUSH
13443: LD_INT 49
13445: PPUSH
13446: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO2 ) ;
13450: LD_INT 12
13452: PPUSH
13453: LD_INT 67
13455: PPUSH
13456: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO2 ) ;
13460: LD_INT 12
13462: PPUSH
13463: LD_INT 61
13465: PPUSH
13466: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH3 ) ;
13470: LD_INT 12
13472: PPUSH
13473: LD_INT 50
13475: PPUSH
13476: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO3 ) ;
13480: LD_INT 12
13482: PPUSH
13483: LD_INT 68
13485: PPUSH
13486: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO3 ) ;
13490: LD_INT 12
13492: PPUSH
13493: LD_INT 62
13495: PPUSH
13496: CALL_OW 184
// end ;
13500: LD_VAR 0 1
13504: RET
// every 0 0$2.3 do
13505: GO 13507
13507: DISABLE
// begin zacni_vynalezat ;
13508: CALL 13237 0 0
// end ;
13512: END
// function otravuj ; var Vedci , Doly , I , Dul , X , Y ; begin
13513: LD_INT 0
13515: PPUSH
13516: PPUSH
13517: PPUSH
13518: PPUSH
13519: PPUSH
13520: PPUSH
13521: PPUSH
// Result = false ;
13522: LD_ADDR_VAR 0 1
13526: PUSH
13527: LD_INT 0
13529: ST_TO_ADDR
// if ( RusMaOtraveno >= 2 ) then
13530: LD_EXP 64
13534: PUSH
13535: LD_INT 2
13537: GREATEREQUAL
13538: IFFALSE 13542
// exit ;
13540: GO 14044
// if KdoOtravuje then
13542: LD_LOC 42
13546: IFFALSE 13550
// exit ;
13548: GO 14044
// Vedci = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
13550: LD_ADDR_VAR 0 2
13554: PUSH
13555: LD_INT 22
13557: PUSH
13558: LD_EXP 3
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 21
13569: PUSH
13570: LD_INT 1
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 25
13579: PUSH
13580: LD_INT 4
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: PPUSH
13592: CALL_OW 69
13596: ST_TO_ADDR
// if not Vedci then
13597: LD_VAR 0 2
13601: NOT
13602: IFFALSE 13606
// exit ;
13604: GO 14044
// Doly = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_SIBERITE_MINE ] ] ) ;
13606: LD_ADDR_VAR 0 3
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_EXP 2
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: LD_INT 21
13625: PUSH
13626: LD_INT 3
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: PUSH
13633: LD_INT 30
13635: PUSH
13636: LD_INT 30
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: LIST
13647: PPUSH
13648: CALL_OW 69
13652: ST_TO_ADDR
// if ( not Doly ) and ( Tick < 30 30$0 ) then
13653: LD_VAR 0 3
13657: NOT
13658: PUSH
13659: LD_OWVAR 1
13663: PUSH
13664: LD_INT 63000
13666: LESS
13667: AND
13668: IFFALSE 13672
// exit ;
13670: GO 14044
// if Doly then
13672: LD_VAR 0 3
13676: IFFALSE 13787
// begin X = - 1 ;
13678: LD_ADDR_VAR 0 6
13682: PUSH
13683: LD_INT 1
13685: NEG
13686: ST_TO_ADDR
// Y = - 1 ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_INT 1
13694: NEG
13695: ST_TO_ADDR
// Dul = 0 ;
13696: LD_ADDR_VAR 0 5
13700: PUSH
13701: LD_INT 0
13703: ST_TO_ADDR
// for I in Doly do
13704: LD_ADDR_VAR 0 4
13708: PUSH
13709: LD_VAR 0 3
13713: PUSH
13714: FOR_IN
13715: IFFALSE 13783
// begin if not Dul or GetX ( Dul ) > X then
13717: LD_VAR 0 5
13721: NOT
13722: PUSH
13723: LD_VAR 0 5
13727: PPUSH
13728: CALL_OW 250
13732: PUSH
13733: LD_VAR 0 6
13737: GREATER
13738: OR
13739: IFFALSE 13781
// begin Dul = I ;
13741: LD_ADDR_VAR 0 5
13745: PUSH
13746: LD_VAR 0 4
13750: ST_TO_ADDR
// X = GetX ( Dul ) ;
13751: LD_ADDR_VAR 0 6
13755: PUSH
13756: LD_VAR 0 5
13760: PPUSH
13761: CALL_OW 250
13765: ST_TO_ADDR
// Y = GetY ( Dul ) ;
13766: LD_ADDR_VAR 0 7
13770: PUSH
13771: LD_VAR 0 5
13775: PPUSH
13776: CALL_OW 251
13780: ST_TO_ADDR
// end end end else
13781: GO 13714
13783: POP
13784: POP
13785: GO 13942
// begin Doly = GetResourceArea ( RusoveUtok , MAT_SIBERIT ) ;
13787: LD_ADDR_VAR 0 3
13791: PUSH
13792: LD_INT 11
13794: PPUSH
13795: LD_INT 3
13797: PPUSH
13798: CALL_OW 287
13802: ST_TO_ADDR
// Doly = [ [ 74 , 6 ] , [ 23 , 9 ] , [ 144 , 97 ] ] ;
13803: LD_ADDR_VAR 0 3
13807: PUSH
13808: LD_INT 74
13810: PUSH
13811: LD_INT 6
13813: PUSH
13814: EMPTY
13815: LIST
13816: LIST
13817: PUSH
13818: LD_INT 23
13820: PUSH
13821: LD_INT 9
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: PUSH
13828: LD_INT 144
13830: PUSH
13831: LD_INT 97
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: LIST
13842: ST_TO_ADDR
// if not Doly then
13843: LD_VAR 0 3
13847: NOT
13848: IFFALSE 13852
// exit ;
13850: GO 14044
// X = - 1 ;
13852: LD_ADDR_VAR 0 6
13856: PUSH
13857: LD_INT 1
13859: NEG
13860: ST_TO_ADDR
// Y = - 1 ;
13861: LD_ADDR_VAR 0 7
13865: PUSH
13866: LD_INT 1
13868: NEG
13869: ST_TO_ADDR
// for I in Doly do
13870: LD_ADDR_VAR 0 4
13874: PUSH
13875: LD_VAR 0 3
13879: PUSH
13880: FOR_IN
13881: IFFALSE 13940
// begin if ( X = - 1 ) or ( I [ 1 ] > X ) then
13883: LD_VAR 0 6
13887: PUSH
13888: LD_INT 1
13890: NEG
13891: EQUAL
13892: PUSH
13893: LD_VAR 0 4
13897: PUSH
13898: LD_INT 1
13900: ARRAY
13901: PUSH
13902: LD_VAR 0 6
13906: GREATER
13907: OR
13908: IFFALSE 13938
// begin X = I [ 1 ] ;
13910: LD_ADDR_VAR 0 6
13914: PUSH
13915: LD_VAR 0 4
13919: PUSH
13920: LD_INT 1
13922: ARRAY
13923: ST_TO_ADDR
// Y = I [ 2 ] ;
13924: LD_ADDR_VAR 0 7
13928: PUSH
13929: LD_VAR 0 4
13933: PUSH
13934: LD_INT 2
13936: ARRAY
13937: ST_TO_ADDR
// end ; end ;
13938: GO 13880
13940: POP
13941: POP
// end ; KdoOtravuje = [ nahoda_seznam ( Vedci ) ] ;
13942: LD_ADDR_LOC 42
13946: PUSH
13947: LD_VAR 0 2
13951: PPUSH
13952: CALL 21635 0 1
13956: PUSH
13957: EMPTY
13958: LIST
13959: ST_TO_ADDR
// ComExitBuilding ( KdoOtravuje ) ;
13960: LD_LOC 42
13964: PPUSH
13965: CALL_OW 122
// Wait ( 0 0$1 ) ;
13969: LD_INT 35
13971: PPUSH
13972: CALL_OW 67
// if ( Y <= 20 ) then
13976: LD_VAR 0 7
13980: PUSH
13981: LD_INT 20
13983: LESSEQUAL
13984: IFFALSE 14001
// AddComMoveXY ( KdoOtravuje , 95 , 5 ) ;
13986: LD_LOC 42
13990: PPUSH
13991: LD_INT 95
13993: PPUSH
13994: LD_INT 5
13996: PPUSH
13997: CALL_OW 171
// AddComContaminate ( KdoOtravuje , X , Y ) ;
14001: LD_LOC 42
14005: PPUSH
14006: LD_VAR 0 6
14010: PPUSH
14011: LD_VAR 0 7
14015: PPUSH
14016: CALL_OW 218
// AddComMoveToArea ( KdoOtravuje , Arabove ) ;
14020: LD_LOC 42
14024: PPUSH
14025: LD_INT 5
14027: PPUSH
14028: CALL_OW 173
// AddComSailEvent ( KdoOtravuje , 101 ) ;
14032: LD_LOC 42
14036: PPUSH
14037: LD_INT 101
14039: PPUSH
14040: CALL_OW 224
// end ;
14044: LD_VAR 0 1
14048: RET
// export function event_Kontaminovano ; var Kdo ; begin
14049: LD_INT 0
14051: PPUSH
14052: PPUSH
// for Kdo in KdoOtravuje do
14053: LD_ADDR_VAR 0 2
14057: PUSH
14058: LD_LOC 42
14062: PUSH
14063: FOR_IN
14064: IFFALSE 14077
// zpet_do_labu ( Kdo ) ;
14066: LD_VAR 0 2
14070: PPUSH
14071: CALL 13127 0 1
14075: GO 14063
14077: POP
14078: POP
// KdoOtravuje = [ ] ;
14079: LD_ADDR_LOC 42
14083: PUSH
14084: EMPTY
14085: ST_TO_ADDR
// end ;
14086: LD_VAR 0 1
14090: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
14091: LD_INT 0
14093: PPUSH
// if Un in KdoOtravuje then
14094: LD_VAR 0 1
14098: PUSH
14099: LD_LOC 42
14103: IN
14104: IFFALSE 14139
// begin KdoOtravuje = KdoOtravuje diff [ Un ] ;
14106: LD_ADDR_LOC 42
14110: PUSH
14111: LD_LOC 42
14115: PUSH
14116: LD_VAR 0 1
14120: PUSH
14121: EMPTY
14122: LIST
14123: DIFF
14124: ST_TO_ADDR
// if not KdoOtravuje then
14125: LD_LOC 42
14129: NOT
14130: IFFALSE 14139
// RaiseSailEvent ( 101 ) ;
14132: LD_INT 101
14134: PPUSH
14135: CALL_OW 427
// end ; if Un in Obranci then
14139: LD_VAR 0 1
14143: PUSH
14144: LD_LOC 37
14148: IN
14149: IFFALSE 14170
// Obranci = Obranci diff [ Un ] ;
14151: LD_ADDR_LOC 37
14155: PUSH
14156: LD_LOC 37
14160: PUSH
14161: LD_VAR 0 1
14165: PUSH
14166: EMPTY
14167: LIST
14168: DIFF
14169: ST_TO_ADDR
// if Un in VolnyLidi then
14170: LD_VAR 0 1
14174: PUSH
14175: LD_LOC 39
14179: IN
14180: IFFALSE 14201
// VolnyLidi = VolnyLidi diff [ Un ] ;
14182: LD_ADDR_LOC 39
14186: PUSH
14187: LD_LOC 39
14191: PUSH
14192: LD_VAR 0 1
14196: PUSH
14197: EMPTY
14198: LIST
14199: DIFF
14200: ST_TO_ADDR
// if Un in Auta then
14201: LD_VAR 0 1
14205: PUSH
14206: LD_LOC 40
14210: IN
14211: IFFALSE 14232
// Auta = Auta diff [ Un ] ;
14213: LD_ADDR_LOC 40
14217: PUSH
14218: LD_LOC 40
14222: PUSH
14223: LD_VAR 0 1
14227: PUSH
14228: EMPTY
14229: LIST
14230: DIFF
14231: ST_TO_ADDR
// if Un in Utok_Auta then
14232: LD_VAR 0 1
14236: PUSH
14237: LD_LOC 41
14241: IN
14242: IFFALSE 14263
// Utok_Auta = Utok_Auta diff [ Un ] ;
14244: LD_ADDR_LOC 41
14248: PUSH
14249: LD_LOC 41
14253: PUSH
14254: LD_VAR 0 1
14258: PUSH
14259: EMPTY
14260: LIST
14261: DIFF
14262: ST_TO_ADDR
// if Un in Sejkove then
14263: LD_VAR 0 1
14267: PUSH
14268: LD_LOC 38
14272: IN
14273: IFFALSE 14294
// Sejkove = Sejkove diff [ Un ] ;
14275: LD_ADDR_LOC 38
14279: PUSH
14280: LD_LOC 38
14284: PUSH
14285: LD_VAR 0 1
14289: PUSH
14290: EMPTY
14291: LIST
14292: DIFF
14293: ST_TO_ADDR
// if Un in ObranaBehemota then
14294: LD_VAR 0 1
14298: PUSH
14299: LD_LOC 45
14303: IN
14304: IFFALSE 14325
// ObranaBehemota = ObranaBehemota diff [ Un ] ;
14306: LD_ADDR_LOC 45
14310: PUSH
14311: LD_LOC 45
14315: PUSH
14316: LD_VAR 0 1
14320: PUSH
14321: EMPTY
14322: LIST
14323: DIFF
14324: ST_TO_ADDR
// if Un in KdoLakaOpice then
14325: LD_VAR 0 1
14329: PUSH
14330: LD_LOC 68
14334: IN
14335: IFFALSE 14356
// KdoLakaOpice = KdoLakaOpice diff [ Un ] ;
14337: LD_ADDR_LOC 68
14341: PUSH
14342: LD_LOC 68
14346: PUSH
14347: LD_VAR 0 1
14351: PUSH
14352: EMPTY
14353: LIST
14354: DIFF
14355: ST_TO_ADDR
// if Un in KdoLeci then
14356: LD_VAR 0 1
14360: PUSH
14361: LD_LOC 66
14365: IN
14366: IFFALSE 14387
// KdoLeci = KdoLeci diff [ Un ] ;
14368: LD_ADDR_LOC 66
14372: PUSH
14373: LD_LOC 66
14377: PUSH
14378: LD_VAR 0 1
14382: PUSH
14383: EMPTY
14384: LIST
14385: DIFF
14386: ST_TO_ADDR
// if Un in KdoOpravuje then
14387: LD_VAR 0 1
14391: PUSH
14392: LD_LOC 67
14396: IN
14397: IFFALSE 14418
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
14399: LD_ADDR_LOC 67
14403: PUSH
14404: LD_LOC 67
14408: PUSH
14409: LD_VAR 0 1
14413: PUSH
14414: EMPTY
14415: LIST
14416: DIFF
14417: ST_TO_ADDR
// end ;
14418: LD_VAR 0 2
14422: RET
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14423: LD_INT 0
14425: PPUSH
// if VehOld in Auta then
14426: LD_VAR 0 2
14430: PUSH
14431: LD_LOC 40
14435: IN
14436: IFFALSE 14457
// Auta = Auta diff [ VehOld ] ;
14438: LD_ADDR_LOC 40
14442: PUSH
14443: LD_LOC 40
14447: PUSH
14448: LD_VAR 0 2
14452: PUSH
14453: EMPTY
14454: LIST
14455: DIFF
14456: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
14457: LD_VAR 0 1
14461: PPUSH
14462: CALL_OW 255
14466: PUSH
14467: LD_EXP 3
14471: EQUAL
14472: IFFALSE 14493
// Auta = Auta union [ VehNew ] ;
14474: LD_ADDR_LOC 40
14478: PUSH
14479: LD_LOC 40
14483: PUSH
14484: LD_VAR 0 1
14488: PUSH
14489: EMPTY
14490: LIST
14491: UNION
14492: ST_TO_ADDR
// if VehOld in Utok_Auta then
14493: LD_VAR 0 2
14497: PUSH
14498: LD_LOC 41
14502: IN
14503: IFFALSE 14524
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
14505: LD_ADDR_LOC 41
14509: PUSH
14510: LD_LOC 41
14514: PUSH
14515: LD_VAR 0 2
14519: PUSH
14520: EMPTY
14521: LIST
14522: DIFF
14523: ST_TO_ADDR
// end ;
14524: LD_VAR 0 5
14528: RET
// function vyrob_autak ; var Chassis , Weapon , P ; begin
14529: LD_INT 0
14531: PPUSH
14532: PPUSH
14533: PPUSH
14534: PPUSH
// P = Rand ( 1 , 100 ) ;
14535: LD_ADDR_VAR 0 4
14539: PUSH
14540: LD_INT 1
14542: PPUSH
14543: LD_INT 100
14545: PPUSH
14546: CALL_OW 12
14550: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 65 ) then
14551: LD_OWVAR 67
14555: PUSH
14556: LD_INT 1
14558: EQUAL
14559: PUSH
14560: LD_VAR 0 4
14564: PUSH
14565: LD_INT 65
14567: GREATEREQUAL
14568: AND
14569: IFFALSE 14579
// P = 64 ;
14571: LD_ADDR_VAR 0 4
14575: PUSH
14576: LD_INT 64
14578: ST_TO_ADDR
// if P < 8 then
14579: LD_VAR 0 4
14583: PUSH
14584: LD_INT 8
14586: LESS
14587: IFFALSE 14607
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
14589: LD_ADDR_VAR 0 3
14593: PUSH
14594: LD_INT 22
14596: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14597: LD_ADDR_VAR 0 2
14601: PUSH
14602: LD_INT 11
14604: ST_TO_ADDR
// end else
14605: GO 14707
// if P < 15 then
14607: LD_VAR 0 4
14611: PUSH
14612: LD_INT 15
14614: LESS
14615: IFFALSE 14635
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
14617: LD_ADDR_VAR 0 3
14621: PUSH
14622: LD_INT 24
14624: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14625: LD_ADDR_VAR 0 2
14629: PUSH
14630: LD_INT 11
14632: ST_TO_ADDR
// end else
14633: GO 14707
// if P < 35 then
14635: LD_VAR 0 4
14639: PUSH
14640: LD_INT 35
14642: LESS
14643: IFFALSE 14663
// begin Weapon = AR_GATLING_GUN ;
14645: LD_ADDR_VAR 0 3
14649: PUSH
14650: LD_INT 25
14652: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14653: LD_ADDR_VAR 0 2
14657: PUSH
14658: LD_INT 13
14660: ST_TO_ADDR
// end else
14661: GO 14707
// if P < 65 then
14663: LD_VAR 0 4
14667: PUSH
14668: LD_INT 65
14670: LESS
14671: IFFALSE 14691
// begin Weapon = AR_GUN ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 27
14680: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14681: LD_ADDR_VAR 0 2
14685: PUSH
14686: LD_INT 13
14688: ST_TO_ADDR
// end else
14689: GO 14707
// begin Weapon = AR_ROCKET_LAUNCHER ;
14691: LD_ADDR_VAR 0 3
14695: PUSH
14696: LD_INT 28
14698: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14699: LD_ADDR_VAR 0 2
14703: PUSH
14704: LD_INT 13
14706: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
14707: LD_ADDR_VAR 0 2
14711: PUSH
14712: LD_VAR 0 2
14716: PPUSH
14717: LD_INT 14
14719: PPUSH
14720: CALL_OW 12
14724: ST_TO_ADDR
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
14725: LD_INT 5
14727: PPUSH
14728: LD_VAR 0 2
14732: PPUSH
14733: LD_INT 3
14735: PPUSH
14736: LD_INT 1
14738: PPUSH
14739: LD_VAR 0 3
14743: PPUSH
14744: CALL_OW 185
// end ;
14748: LD_VAR 0 1
14752: RET
// function vyrob_auto_opice ; begin
14753: LD_INT 0
14755: PPUSH
// AddComConstruct ( ArFact , AR_MEDIUM_TRIKE , ENGINE_SIBERITE , CONTROL_APEMAN , AR_SELFPROPELLED_BOMB ) ;
14756: LD_INT 5
14758: PPUSH
14759: LD_INT 13
14761: PPUSH
14762: LD_INT 3
14764: PPUSH
14765: LD_INT 5
14767: PPUSH
14768: LD_INT 29
14770: PPUSH
14771: CALL_OW 185
// end ;
14775: LD_VAR 0 1
14779: RET
// export function arabi_EnterBuilding ( Building , Un ) ; begin
14780: LD_INT 0
14782: PPUSH
// if ( Building = ArFact ) and ( GetSide ( Un ) = side_Ar ) and ( GetClass ( Un ) = CLASS_APEMAN ) then
14783: LD_VAR 0 1
14787: PUSH
14788: LD_INT 5
14790: EQUAL
14791: PUSH
14792: LD_VAR 0 2
14796: PPUSH
14797: CALL_OW 255
14801: PUSH
14802: LD_EXP 3
14806: EQUAL
14807: AND
14808: PUSH
14809: LD_VAR 0 2
14813: PPUSH
14814: CALL_OW 257
14818: PUSH
14819: LD_INT 12
14821: EQUAL
14822: AND
14823: IFFALSE 14843
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci + 1 ;
14825: LD_ADDR_LOC 48
14829: PUSH
14830: LD_LOC 48
14834: PUSH
14835: LD_INT 1
14837: PLUS
14838: ST_TO_ADDR
// vyrob_auto_opice ;
14839: CALL 14753 0 0
// end ; end ;
14843: LD_VAR 0 3
14847: RET
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , Volni , Control , Weapon , NovyRidic ; begin
14848: LD_INT 0
14850: PPUSH
14851: PPUSH
14852: PPUSH
14853: PPUSH
14854: PPUSH
14855: PPUSH
// if GetSide ( Veh ) = side_Ar then
14856: LD_VAR 0 1
14860: PPUSH
14861: CALL_OW 255
14865: PUSH
14866: LD_EXP 3
14870: EQUAL
14871: IFFALSE 15254
// begin Auta = Auta union [ Veh ] ;
14873: LD_ADDR_LOC 40
14877: PUSH
14878: LD_LOC 40
14882: PUSH
14883: LD_VAR 0 1
14887: PUSH
14888: EMPTY
14889: LIST
14890: UNION
14891: ST_TO_ADDR
// Control = GetControl ( Veh ) ;
14892: LD_ADDR_VAR 0 6
14896: PUSH
14897: LD_VAR 0 1
14901: PPUSH
14902: CALL_OW 263
14906: ST_TO_ADDR
// Weapon = GetWeapon ( Veh ) ;
14907: LD_ADDR_VAR 0 7
14911: PUSH
14912: LD_VAR 0 1
14916: PPUSH
14917: CALL_OW 264
14921: ST_TO_ADDR
// if ( Weapon = AR_CONTROL_TOWER ) then
14922: LD_VAR 0 7
14926: PUSH
14927: LD_INT 31
14929: EQUAL
14930: IFFALSE 14960
// begin ArDalkar = Veh ;
14932: LD_ADDR_LOC 49
14936: PUSH
14937: LD_VAR 0 1
14941: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
14942: LD_ADDR_VAR 0 8
14946: PUSH
14947: LD_LOC 36
14951: ST_TO_ADDR
// DelamDalkare = false ;
14952: LD_ADDR_LOC 51
14956: PUSH
14957: LD_INT 0
14959: ST_TO_ADDR
// end ; if ( Control = CONTROL_MANUAL ) then
14960: LD_VAR 0 6
14964: PUSH
14965: LD_INT 1
14967: EQUAL
14968: IFFALSE 15109
// begin Wait ( 0 0$2.5 ) ;
14970: LD_INT 88
14972: PPUSH
14973: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
14977: LD_ADDR_VAR 0 4
14981: PUSH
14982: LD_VAR 0 1
14986: PPUSH
14987: CALL_OW 311
14991: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
14992: LD_INT 105
14994: PPUSH
14995: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
14999: LD_VAR 0 4
15003: PPUSH
15004: CALL_OW 121
// Wait ( 0 0$1 ) ;
15008: LD_INT 35
15010: PPUSH
15011: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
15015: LD_VAR 0 1
15019: PPUSH
15020: CALL_OW 311
15024: PUSH
15025: LD_VAR 0 4
15029: EQUAL
15030: IFFALSE 15041
// Wait ( 0 0$1 ) ;
15032: LD_INT 35
15034: PPUSH
15035: CALL_OW 67
15039: GO 15015
// AddComEnterUnit ( Ridic , Fact ) ;
15041: LD_VAR 0 4
15045: PPUSH
15046: LD_VAR 0 2
15050: PPUSH
15051: CALL_OW 180
// if NovyRidic then
15055: LD_VAR 0 8
15059: IFFALSE 15075
// ComEnterUnit ( NovyRidic , Veh ) ;
15061: LD_VAR 0 8
15065: PPUSH
15066: LD_VAR 0 1
15070: PPUSH
15071: CALL_OW 120
// AddMcUnits ( MakroObrana , [ Veh ] ) ;
15075: LD_LOC 43
15079: PPUSH
15080: LD_VAR 0 1
15084: PUSH
15085: EMPTY
15086: LIST
15087: PPUSH
15088: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15092: LD_LOC 59
15096: PPUSH
15097: LD_VAR 0 1
15101: PUSH
15102: EMPTY
15103: LIST
15104: PPUSH
15105: CALL_OW 390
// end ; if ( Control = CONTROL_APEMAN ) and ( VolnyRidiciOpicaci > 0 ) then
15109: LD_VAR 0 6
15113: PUSH
15114: LD_INT 5
15116: EQUAL
15117: PUSH
15118: LD_LOC 48
15122: PUSH
15123: LD_INT 0
15125: GREATER
15126: AND
15127: IFFALSE 15143
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci - 1 ;
15129: LD_ADDR_LOC 48
15133: PUSH
15134: LD_LOC 48
15138: PUSH
15139: LD_INT 1
15141: MINUS
15142: ST_TO_ADDR
// end ; if ( Control = CONTROL_APEMAN ) and ( Weapon = AR_SELFPROPELLED_BOMB ) then
15143: LD_VAR 0 6
15147: PUSH
15148: LD_INT 5
15150: EQUAL
15151: PUSH
15152: LD_VAR 0 7
15156: PUSH
15157: LD_INT 29
15159: EQUAL
15160: AND
15161: IFFALSE 15187
// begin Wait ( 0 0$3.6 ) ;
15163: LD_INT 126
15165: PPUSH
15166: CALL_OW 67
// AddMcUnits ( MakroKamikaze , [ Veh ] ) ;
15170: LD_LOC 46
15174: PPUSH
15175: LD_VAR 0 1
15179: PUSH
15180: EMPTY
15181: LIST
15182: PPUSH
15183: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
15187: LD_VAR 0 1
15191: PPUSH
15192: CALL_OW 263
15196: PUSH
15197: LD_INT 2
15199: EQUAL
15200: IFFALSE 15254
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
15202: LD_VAR 0 1
15206: PPUSH
15207: LD_LOC 36
15211: PPUSH
15212: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
15216: LD_ADDR_LOC 50
15220: PUSH
15221: LD_LOC 50
15225: PUSH
15226: LD_INT 1
15228: PLUS
15229: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
15230: LD_INT 105
15232: PPUSH
15233: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15237: LD_LOC 59
15241: PPUSH
15242: LD_VAR 0 1
15246: PUSH
15247: EMPTY
15248: LIST
15249: PPUSH
15250: CALL_OW 390
// end ; end ; end ;
15254: LD_VAR 0 3
15258: RET
// function vyber_zbran ; var P ; begin
15259: LD_INT 0
15261: PPUSH
15262: PPUSH
// P = Rand ( 1 , 100 ) ;
15263: LD_ADDR_VAR 0 2
15267: PUSH
15268: LD_INT 1
15270: PPUSH
15271: LD_INT 100
15273: PPUSH
15274: CALL_OW 12
15278: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
15279: LD_VAR 0 2
15283: PUSH
15284: LD_LOC 57
15288: PUSH
15289: LD_INT 1
15291: ARRAY
15292: LESS
15293: IFFALSE 15305
// Result = AR_FLAME_THROWER else
15295: LD_ADDR_VAR 0 1
15299: PUSH
15300: LD_INT 26
15302: ST_TO_ADDR
15303: GO 15365
// if P < PstZbrane [ 2 ] then
15305: LD_VAR 0 2
15309: PUSH
15310: LD_LOC 57
15314: PUSH
15315: LD_INT 2
15317: ARRAY
15318: LESS
15319: IFFALSE 15331
// Result = AR_GUN else
15321: LD_ADDR_VAR 0 1
15325: PUSH
15326: LD_INT 27
15328: ST_TO_ADDR
15329: GO 15365
// if P < PstZbrane [ 3 ] then
15331: LD_VAR 0 2
15335: PUSH
15336: LD_LOC 57
15340: PUSH
15341: LD_INT 3
15343: ARRAY
15344: LESS
15345: IFFALSE 15357
// Result = AR_GATLING_GUN else
15347: LD_ADDR_VAR 0 1
15351: PUSH
15352: LD_INT 25
15354: ST_TO_ADDR
15355: GO 15365
// Result = AR_ROCKET_LAUNCHER ;
15357: LD_ADDR_VAR 0 1
15361: PUSH
15362: LD_INT 28
15364: ST_TO_ADDR
// end ;
15365: LD_VAR 0 1
15369: RET
// function vyber_ovladani ; begin
15370: LD_INT 0
15372: PPUSH
// Result = CONTROL_MANUAL ;
15373: LD_ADDR_VAR 0 1
15377: PUSH
15378: LD_INT 1
15380: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
15381: LD_LOC 49
15385: NOT
15386: PUSH
15387: LD_LOC 49
15391: PPUSH
15392: CALL_OW 302
15396: NOT
15397: OR
15398: IFFALSE 15402
// exit ;
15400: GO 15458
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
15402: LD_LOC 36
15406: NOT
15407: PUSH
15408: LD_LOC 36
15412: PPUSH
15413: CALL_OW 302
15417: NOT
15418: OR
15419: IFFALSE 15423
// exit ;
15421: GO 15458
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
15423: LD_LOC 36
15427: PPUSH
15428: CALL_OW 432
15432: PUSH
15433: LD_LOC 36
15437: PPUSH
15438: LD_INT 3
15440: PPUSH
15441: CALL_OW 259
15445: GREATEREQUAL
15446: IFFALSE 15450
// exit ;
15448: GO 15458
// Result = CONTROL_REMOTE ;
15450: LD_ADDR_VAR 0 1
15454: PUSH
15455: LD_INT 2
15457: ST_TO_ADDR
// end ;
15458: LD_VAR 0 1
15462: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
15463: LD_INT 0
15465: PPUSH
15466: PPUSH
15467: PPUSH
15468: PPUSH
15469: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
15470: LD_INT 5
15472: PPUSH
15473: CALL_OW 302
15477: NOT
15478: PUSH
15479: LD_INT 5
15481: PPUSH
15482: CALL_OW 314
15486: OR
15487: IFFALSE 15491
// exit ;
15489: GO 15803
// if GetSide ( ArFact ) <> side_Ar then
15491: LD_INT 5
15493: PPUSH
15494: CALL_OW 255
15498: PUSH
15499: LD_EXP 3
15503: NONEQUAL
15504: IFFALSE 15508
// exit ;
15506: GO 15803
// if not UnitsInside ( ArFact ) then
15508: LD_INT 5
15510: PPUSH
15511: CALL_OW 313
15515: NOT
15516: IFFALSE 15520
// exit ;
15518: GO 15803
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
15520: LD_INT 15
15522: PPUSH
15523: LD_EXP 3
15527: PPUSH
15528: CALL_OW 321
15532: PUSH
15533: LD_INT 2
15535: EQUAL
15536: PUSH
15537: LD_LOC 49
15541: NOT
15542: AND
15543: PUSH
15544: LD_LOC 51
15548: NOT
15549: AND
15550: PUSH
15551: LD_INT 75
15553: PPUSH
15554: CALL_OW 13
15558: AND
15559: IFFALSE 15587
// begin Chassis = AR_MEDIUM_TRIKE ;
15561: LD_ADDR_VAR 0 3
15565: PUSH
15566: LD_INT 13
15568: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
15569: LD_ADDR_VAR 0 4
15573: PUSH
15574: LD_INT 31
15576: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
15577: LD_ADDR_VAR 0 5
15581: PUSH
15582: LD_INT 1
15584: ST_TO_ADDR
// end else
15585: GO 15634
// begin if Prob ( 50 ) then
15587: LD_INT 50
15589: PPUSH
15590: CALL_OW 13
15594: IFFALSE 15606
// Chassis = AR_MEDIUM_TRIKE else
15596: LD_ADDR_VAR 0 3
15600: PUSH
15601: LD_INT 13
15603: ST_TO_ADDR
15604: GO 15614
// Chassis = AR_HALF_TRACKED ;
15606: LD_ADDR_VAR 0 3
15610: PUSH
15611: LD_INT 14
15613: ST_TO_ADDR
// Weapon = vyber_zbran ;
15614: LD_ADDR_VAR 0 4
15618: PUSH
15619: CALL 15259 0 0
15623: ST_TO_ADDR
// Control = vyber_ovladani ;
15624: LD_ADDR_VAR 0 5
15628: PUSH
15629: CALL 15370 0 0
15633: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) then
15634: LD_INT 5
15636: PPUSH
15637: LD_VAR 0 3
15641: PPUSH
15642: LD_INT 3
15644: PPUSH
15645: LD_VAR 0 5
15649: PPUSH
15650: LD_VAR 0 4
15654: PPUSH
15655: CALL_OW 448
15659: NOT
15660: IFFALSE 15704
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_SIBERITE , Control , AR_LIGHT_GUN ) then
15662: LD_INT 5
15664: PPUSH
15665: LD_INT 12
15667: PPUSH
15668: LD_INT 3
15670: PPUSH
15671: LD_VAR 0 5
15675: PPUSH
15676: LD_INT 23
15678: PPUSH
15679: CALL_OW 448
15683: NOT
15684: IFFALSE 15688
// exit ;
15686: GO 15803
// Chassis = AR_LIGHT_TRIKE ;
15688: LD_ADDR_VAR 0 3
15692: PUSH
15693: LD_INT 12
15695: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
15696: LD_ADDR_VAR 0 4
15700: PUSH
15701: LD_INT 23
15703: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 5
15711: PPUSH
15712: CALL_OW 274
15716: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
15717: LD_VAR 0 2
15721: PPUSH
15722: LD_INT 1
15724: PPUSH
15725: CALL_OW 275
15729: PUSH
15730: LD_INT 120
15732: LESS
15733: IFFALSE 15737
// exit ;
15735: GO 15803
// if GetResourceType ( Base , MAT_SIBERIT ) < 30 then
15737: LD_VAR 0 2
15741: PPUSH
15742: LD_INT 3
15744: PPUSH
15745: CALL_OW 275
15749: PUSH
15750: LD_INT 30
15752: LESS
15753: IFFALSE 15757
// exit ;
15755: GO 15803
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) ;
15757: LD_INT 5
15759: PPUSH
15760: LD_VAR 0 3
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: LD_VAR 0 5
15772: PPUSH
15773: LD_VAR 0 4
15777: PPUSH
15778: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
15782: LD_VAR 0 4
15786: PUSH
15787: LD_INT 31
15789: EQUAL
15790: IFFALSE 15803
// begin DelamDalkare = true ;
15792: LD_ADDR_LOC 51
15796: PUSH
15797: LD_INT 1
15799: ST_TO_ADDR
// enable ( 33 ) ;
15800: LD_INT 33
15802: ENABLE_MARKED
// end ; end ;
15803: LD_VAR 0 1
15807: RET
// every 5 5$1 marked 33 do
15808: GO 15810
15810: DISABLE
// begin if not ArDalkar then
15811: LD_LOC 49
15815: NOT
15816: IFFALSE 15826
// DelamDalkare = false ;
15818: LD_ADDR_LOC 51
15822: PUSH
15823: LD_INT 0
15825: ST_TO_ADDR
// end ;
15826: END
// every 0 0$19 do
15827: GO 15829
15829: DISABLE
// begin kontrola_vyroby ;
15830: CALL 15463 0 0
// enable ;
15834: ENABLE
// end ;
15835: END
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
15836: LD_INT 0
15838: PPUSH
15839: PPUSH
15840: PPUSH
15841: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
15842: LD_ADDR_VAR 0 2
15846: PUSH
15847: LD_EXP 47
15851: PUSH
15852: LD_OWVAR 67
15856: ARRAY
15857: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
15858: LD_ADDR_VAR 0 3
15862: PUSH
15863: LD_INT 1
15865: PPUSH
15866: LD_INT 100
15868: PPUSH
15869: CALL_OW 12
15873: ST_TO_ADDR
// if ( I < 25 ) then
15874: LD_VAR 0 3
15878: PUSH
15879: LD_INT 25
15881: LESS
15882: IFFALSE 15900
// KolikChci = KolikChci - 1 else
15884: LD_ADDR_VAR 0 2
15888: PUSH
15889: LD_VAR 0 2
15893: PUSH
15894: LD_INT 1
15896: MINUS
15897: ST_TO_ADDR
15898: GO 15934
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
15900: LD_VAR 0 3
15904: PUSH
15905: LD_INT 75
15907: GREATER
15908: PUSH
15909: LD_LOC 53
15913: PUSH
15914: LD_INT 1
15916: GREATER
15917: AND
15918: IFFALSE 15934
// KolikChci = KolikChci + 1 ;
15920: LD_ADDR_VAR 0 2
15924: PUSH
15925: LD_VAR 0 2
15929: PUSH
15930: LD_INT 1
15932: PLUS
15933: ST_TO_ADDR
// Riditelne = [ ] ;
15934: LD_ADDR_VAR 0 4
15938: PUSH
15939: EMPTY
15940: ST_TO_ADDR
// for I in Auta do
15941: LD_ADDR_VAR 0 3
15945: PUSH
15946: LD_LOC 40
15950: PUSH
15951: FOR_IN
15952: IFFALSE 16038
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
15954: LD_VAR 0 3
15958: PPUSH
15959: CALL_OW 263
15963: PUSH
15964: LD_INT 1
15966: EQUAL
15967: PUSH
15968: LD_VAR 0 3
15972: PPUSH
15973: CALL_OW 311
15977: NOT
15978: AND
15979: IFFALSE 15983
// continue ;
15981: GO 15951
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
15983: LD_VAR 0 3
15987: PPUSH
15988: CALL_OW 264
15992: PUSH
15993: LD_INT 31
15995: EQUAL
15996: IFFALSE 16000
// continue ;
15998: GO 15951
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
16000: LD_VAR 0 3
16004: PPUSH
16005: CALL_OW 256
16009: PUSH
16010: LD_INT 1000
16012: LESS
16013: IFFALSE 16017
// continue ;
16015: GO 15951
// Riditelne = Riditelne union [ I ] ;
16017: LD_ADDR_VAR 0 4
16021: PUSH
16022: LD_VAR 0 4
16026: PUSH
16027: LD_VAR 0 3
16031: PUSH
16032: EMPTY
16033: LIST
16034: UNION
16035: ST_TO_ADDR
// end ;
16036: GO 15951
16038: POP
16039: POP
// if Riditelne >= KolikChci then
16040: LD_VAR 0 4
16044: PUSH
16045: LD_VAR 0 2
16049: GREATEREQUAL
16050: IFFALSE 16190
// begin if ( Tick > 45 45$0 ) then
16052: LD_OWVAR 1
16056: PUSH
16057: LD_INT 94500
16059: GREATER
16060: IFFALSE 16074
// Result = Riditelne else
16062: LD_ADDR_VAR 0 1
16066: PUSH
16067: LD_VAR 0 4
16071: ST_TO_ADDR
16072: GO 16125
// begin Result = [ ] ;
16074: LD_ADDR_VAR 0 1
16078: PUSH
16079: EMPTY
16080: ST_TO_ADDR
// for I = 1 to KolikChci do
16081: LD_ADDR_VAR 0 3
16085: PUSH
16086: DOUBLE
16087: LD_INT 1
16089: DEC
16090: ST_TO_ADDR
16091: LD_VAR 0 2
16095: PUSH
16096: FOR_TO
16097: IFFALSE 16123
// Result = Result union Riditelne [ I ] ;
16099: LD_ADDR_VAR 0 1
16103: PUSH
16104: LD_VAR 0 1
16108: PUSH
16109: LD_VAR 0 4
16113: PUSH
16114: LD_VAR 0 3
16118: ARRAY
16119: UNION
16120: ST_TO_ADDR
16121: GO 16096
16123: POP
16124: POP
// end ; if Obranci > 4 then
16125: LD_LOC 37
16129: PUSH
16130: LD_INT 4
16132: GREATER
16133: IFFALSE 16188
// for I = 1 to Rand ( 1 , 2 ) do
16135: LD_ADDR_VAR 0 3
16139: PUSH
16140: DOUBLE
16141: LD_INT 1
16143: DEC
16144: ST_TO_ADDR
16145: LD_INT 1
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 12
16155: PUSH
16156: FOR_TO
16157: IFFALSE 16186
// Result = Result union [ Obranci [ I ] ] ;
16159: LD_ADDR_VAR 0 1
16163: PUSH
16164: LD_VAR 0 1
16168: PUSH
16169: LD_LOC 37
16173: PUSH
16174: LD_VAR 0 3
16178: ARRAY
16179: PUSH
16180: EMPTY
16181: LIST
16182: UNION
16183: ST_TO_ADDR
16184: GO 16156
16186: POP
16187: POP
// end else
16188: GO 16197
// Result = [ ] ;
16190: LD_ADDR_VAR 0 1
16194: PUSH
16195: EMPTY
16196: ST_TO_ADDR
// end ;
16197: LD_VAR 0 1
16201: RET
// function zacni_utok ; begin
16202: LD_INT 0
16204: PPUSH
// ProbihaUtok = true ;
16205: LD_ADDR_EXP 62
16209: PUSH
16210: LD_INT 1
16212: ST_TO_ADDR
// if ( RusMaOtraveno < 2 ) and not KdoOtravuje and RusMaSiberit then
16213: LD_EXP 64
16217: PUSH
16218: LD_INT 2
16220: LESS
16221: PUSH
16222: LD_LOC 42
16226: NOT
16227: AND
16228: PUSH
16229: LD_EXP 63
16233: AND
16234: IFFALSE 16255
// begin otravuj ;
16236: CALL 13513 0 0
// Wait ( Rand ( 0 0$10 , 0 0$15 ) ) ;
16240: LD_INT 350
16242: PPUSH
16243: LD_INT 525
16245: PPUSH
16246: CALL_OW 12
16250: PPUSH
16251: CALL_OW 67
// end ; MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
16255: LD_ADDR_LOC 52
16259: PUSH
16260: LD_INT 10
16262: PPUSH
16263: LD_LOC 47
16267: PPUSH
16268: LD_LOC 41
16272: PPUSH
16273: LD_INT 7
16275: PUSH
16276: LD_INT 15
16278: PUSH
16279: EMPTY
16280: LIST
16281: LIST
16282: PUSH
16283: LD_INT 8
16285: PUSH
16286: LD_INT 15
16288: PUSH
16289: EMPTY
16290: LIST
16291: LIST
16292: PUSH
16293: LD_INT 5
16295: PUSH
16296: LD_INT 10
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 6
16305: PUSH
16306: LD_INT 10
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: PPUSH
16319: CALL_OW 402
16323: ST_TO_ADDR
// end ;
16324: LD_VAR 0 1
16328: RET
// function vrat_utok ; var I ; begin
16329: LD_INT 0
16331: PPUSH
16332: PPUSH
// ProbihaUtok = false ;
16333: LD_ADDR_EXP 62
16337: PUSH
16338: LD_INT 0
16340: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
16341: LD_ADDR_LOC 53
16345: PUSH
16346: LD_LOC 53
16350: PUSH
16351: LD_INT 1
16353: PLUS
16354: ST_TO_ADDR
// MakroUtok = 0 ;
16355: LD_ADDR_LOC 52
16359: PUSH
16360: LD_INT 0
16362: ST_TO_ADDR
// AddComMoveToArea ( Utok_Auta , Arabove ) ;
16363: LD_LOC 41
16367: PPUSH
16368: LD_INT 5
16370: PPUSH
16371: CALL_OW 173
// end ;
16375: LD_VAR 0 1
16379: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
16380: LD_INT 0
16382: PPUSH
// vrat_utok ;
16383: CALL 16329 0 0
// end ;
16387: LD_VAR 0 3
16391: RET
// function zjisti_cas_utoku ; begin
16392: LD_INT 0
16394: PPUSH
// if CasyUtoku then
16395: LD_LOC 56
16399: IFFALSE 16445
// begin Result = CasyUtoku [ 1 ] ;
16401: LD_ADDR_VAR 0 1
16405: PUSH
16406: LD_LOC 56
16410: PUSH
16411: LD_INT 1
16413: ARRAY
16414: ST_TO_ADDR
// if CasyUtoku > 1 then
16415: LD_LOC 56
16419: PUSH
16420: LD_INT 1
16422: GREATER
16423: IFFALSE 16443
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
16425: LD_ADDR_LOC 56
16429: PUSH
16430: LD_LOC 56
16434: PPUSH
16435: LD_INT 1
16437: PPUSH
16438: CALL_OW 3
16442: ST_TO_ADDR
// end else
16443: GO 16453
// Result = 5 ;
16445: LD_ADDR_VAR 0 1
16449: PUSH
16450: LD_INT 5
16452: ST_TO_ADDR
// end ;
16453: LD_VAR 0 1
16457: RET
// function utoceni_splneny_predpoklady ; begin
16458: LD_INT 0
16460: PPUSH
// Result = VidelRusa or ( Tick > 12 12$0 ) ;
16461: LD_ADDR_VAR 0 1
16465: PUSH
16466: LD_LOC 58
16470: PUSH
16471: LD_OWVAR 1
16475: PUSH
16476: LD_INT 25200
16478: GREATER
16479: OR
16480: ST_TO_ADDR
// if Prob ( 25 ) then
16481: LD_INT 25
16483: PPUSH
16484: CALL_OW 13
16488: IFFALSE 16498
// Result = false ;
16490: LD_ADDR_VAR 0 1
16494: PUSH
16495: LD_INT 0
16497: ST_TO_ADDR
// end ;
16498: LD_VAR 0 1
16502: RET
// function casovac_utok ; begin
16503: LD_INT 0
16505: PPUSH
// if ProbihaUtok then
16506: LD_EXP 62
16510: IFFALSE 16514
// exit ;
16512: GO 16621
// if ArabiZniceni then
16514: LD_EXP 65
16518: IFFALSE 16522
// exit ;
16520: GO 16621
// if Utok_ZbyvaMinut = - 1 then
16522: LD_LOC 55
16526: PUSH
16527: LD_INT 1
16529: NEG
16530: EQUAL
16531: IFFALSE 16543
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16533: LD_ADDR_LOC 55
16537: PUSH
16538: CALL 16392 0 0
16542: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
16543: LD_LOC 55
16547: PUSH
16548: LD_INT 0
16550: GREATER
16551: IFFALSE 16567
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
16553: LD_ADDR_LOC 55
16557: PUSH
16558: LD_LOC 55
16562: PUSH
16563: LD_INT 1
16565: MINUS
16566: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
16567: CALL 16458 0 0
16571: NOT
16572: IFFALSE 16576
// exit ;
16574: GO 16621
// if Utok_ZbyvaMinut > 0 then
16576: LD_LOC 55
16580: PUSH
16581: LD_INT 0
16583: GREATER
16584: IFFALSE 16588
// exit ;
16586: GO 16621
// Utok_Auta = zjisti_auta_na_utok ;
16588: LD_ADDR_LOC 41
16592: PUSH
16593: CALL 15836 0 0
16597: ST_TO_ADDR
// if not Utok_Auta then
16598: LD_LOC 41
16602: NOT
16603: IFFALSE 16607
// exit ;
16605: GO 16621
// zacni_utok ;
16607: CALL 16202 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16611: LD_ADDR_LOC 55
16615: PUSH
16616: CALL 16392 0 0
16620: ST_TO_ADDR
// end ;
16621: LD_VAR 0 1
16625: RET
// every 0 0$45 marked 31 do
16626: GO 16628
16628: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
16629: LD_INT 0
16631: PPUSH
16632: LD_INT 1050
16634: PPUSH
16635: CALL_OW 12
16639: PPUSH
16640: CALL_OW 67
// casovac_utok ;
16644: CALL 16503 0 0
// enable ;
16648: ENABLE
// end ;
16649: END
// every 0 0$30 do
16650: GO 16652
16652: DISABLE
// begin Wait ( 1 1$0 * Rand ( PrvniUtok [ 1 ] , PrvniUtok [ 2 ] ) ) ;
16653: LD_INT 2100
16655: PUSH
16656: LD_LOC 54
16660: PUSH
16661: LD_INT 1
16663: ARRAY
16664: PPUSH
16665: LD_LOC 54
16669: PUSH
16670: LD_INT 2
16672: ARRAY
16673: PPUSH
16674: CALL_OW 12
16678: MUL
16679: PPUSH
16680: CALL_OW 67
// enable ( 31 ) ;
16684: LD_INT 31
16686: ENABLE_MARKED
// end ;
16687: END
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
16688: LD_INT 0
16690: PPUSH
16691: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
16692: LD_ADDR_VAR 0 4
16696: PUSH
16697: LD_INT 22
16699: PUSH
16700: LD_EXP 2
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 92
16711: PUSH
16712: LD_VAR 0 1
16716: PUSH
16717: LD_VAR 0 2
16721: PUSH
16722: LD_INT 2
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: PPUSH
16735: CALL_OW 69
16739: ST_TO_ADDR
// if Jednotky then
16740: LD_VAR 0 4
16744: IFFALSE 16775
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
16746: LD_VAR 0 1
16750: PPUSH
16751: LD_VAR 0 2
16755: PPUSH
16756: LD_EXP 3
16760: PPUSH
16761: CALL_OW 456
// Result = true ;
16765: LD_ADDR_VAR 0 3
16769: PUSH
16770: LD_INT 1
16772: ST_TO_ADDR
// end else
16773: GO 16783
// Result = false ;
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 0
16782: ST_TO_ADDR
// end ;
16783: LD_VAR 0 3
16787: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
16788: GO 16790
16790: DISABLE
16791: LD_INT 0
16793: PPUSH
16794: PPUSH
// begin if not Miny then
16795: LD_LOC 44
16799: NOT
16800: IFFALSE 16804
// exit ;
16802: GO 16900
// Bouchlo = [ ] ;
16804: LD_ADDR_VAR 0 2
16808: PUSH
16809: EMPTY
16810: ST_TO_ADDR
// for M in Miny do
16811: LD_ADDR_VAR 0 1
16815: PUSH
16816: LD_LOC 44
16820: PUSH
16821: FOR_IN
16822: IFFALSE 16869
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
16824: LD_VAR 0 1
16828: PUSH
16829: LD_INT 1
16831: ARRAY
16832: PPUSH
16833: LD_VAR 0 1
16837: PUSH
16838: LD_INT 2
16840: ARRAY
16841: PPUSH
16842: CALL 16688 0 2
16846: IFFALSE 16867
// Bouchlo = Bouchlo ^ [ M ] ;
16848: LD_ADDR_VAR 0 2
16852: PUSH
16853: LD_VAR 0 2
16857: PUSH
16858: LD_VAR 0 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: ADD
16866: ST_TO_ADDR
16867: GO 16821
16869: POP
16870: POP
// if Bouchlo then
16871: LD_VAR 0 2
16875: IFFALSE 16893
// Miny = Miny diff Bouchlo ;
16877: LD_ADDR_LOC 44
16881: PUSH
16882: LD_LOC 44
16886: PUSH
16887: LD_VAR 0 2
16891: DIFF
16892: ST_TO_ADDR
// if Miny then
16893: LD_LOC 44
16897: IFFALSE 16900
// enable ;
16899: ENABLE
// end ;
16900: PPOPN 2
16902: END
// function testuj_behemota ( Un ) ; begin
16903: LD_INT 0
16905: PPUSH
// if not IsInArea ( Un , AraboveObrana ) then
16906: LD_VAR 0 1
16910: PPUSH
16911: LD_INT 12
16913: PPUSH
16914: CALL_OW 308
16918: NOT
16919: IFFALSE 16923
// exit ;
16921: GO 16956
// if not See ( side_Ar , Un ) then
16923: LD_EXP 3
16927: PPUSH
16928: LD_VAR 0 1
16932: PPUSH
16933: CALL_OW 292
16937: NOT
16938: IFFALSE 16942
// exit ;
16940: GO 16956
// AddComAttackUnit ( ObranaBehemota , Un ) ;
16942: LD_LOC 45
16946: PPUSH
16947: LD_VAR 0 1
16951: PPUSH
16952: CALL_OW 175
// end ;
16956: LD_VAR 0 2
16960: RET
// every 0 0$5.1 do var Kdo , I ;
16961: GO 16963
16963: DISABLE
16964: LD_INT 0
16966: PPUSH
16967: PPUSH
// begin Kdo = FilterUnitsInArea ( AraboveObrana , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CHASSIS , 25 ] ] ) ;
16968: LD_ADDR_VAR 0 1
16972: PUSH
16973: LD_INT 12
16975: PPUSH
16976: LD_INT 22
16978: PUSH
16979: LD_EXP 2
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 21
16990: PUSH
16991: LD_INT 2
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 31
17000: PUSH
17001: LD_INT 25
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: LIST
17012: PPUSH
17013: CALL_OW 70
17017: ST_TO_ADDR
// for I in Kdo do
17018: LD_ADDR_VAR 0 2
17022: PUSH
17023: LD_VAR 0 1
17027: PUSH
17028: FOR_IN
17029: IFFALSE 17042
// testuj_behemota ( I ) ;
17031: LD_VAR 0 2
17035: PPUSH
17036: CALL 16903 0 1
17040: GO 17028
17042: POP
17043: POP
// if ObranaBehemota then
17044: LD_LOC 45
17048: IFFALSE 17051
// enable ;
17050: ENABLE
// end ;
17051: PPOPN 2
17053: END
// export function arabi_ApemanTamed ( Ape , Sci ) ; var tmp , tmp1 , tmp2 ; begin
17054: LD_INT 0
17056: PPUSH
17057: PPUSH
17058: PPUSH
17059: PPUSH
// if GetSide ( Sci ) <> side_Ar then
17060: LD_VAR 0 2
17064: PPUSH
17065: CALL_OW 255
17069: PUSH
17070: LD_EXP 3
17074: NONEQUAL
17075: IFFALSE 17079
// exit ;
17077: GO 17091
// ComMoveToArea ( Ape , Arabove ) ;
17079: LD_VAR 0 1
17083: PPUSH
17084: LD_INT 5
17086: PPUSH
17087: CALL_OW 113
// end ;
17091: LD_VAR 0 3
17095: RET
// function kamikazuj_opicaky ; var O ; begin
17096: LD_INT 0
17098: PPUSH
17099: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ) ;
17100: LD_ADDR_VAR 0 2
17104: PUSH
17105: LD_INT 22
17107: PUSH
17108: LD_EXP 3
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 21
17119: PUSH
17120: LD_INT 1
17122: PUSH
17123: EMPTY
17124: LIST
17125: LIST
17126: PUSH
17127: LD_INT 25
17129: PUSH
17130: LD_INT 17
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PUSH
17137: EMPTY
17138: LIST
17139: LIST
17140: LIST
17141: PPUSH
17142: CALL_OW 69
17146: ST_TO_ADDR
// AddMcUnits ( MakroKamikaze , O ) ;
17147: LD_LOC 46
17151: PPUSH
17152: LD_VAR 0 2
17156: PPUSH
17157: CALL_OW 390
// end ;
17161: LD_VAR 0 1
17165: RET
// function zmen_na_kamikaze ( Ape ) ; begin
17166: LD_INT 0
17168: PPUSH
// AddComEnterUnit ( Ape , ArLabWS ) ;
17169: LD_VAR 0 1
17173: PPUSH
17174: LD_INT 11
17176: PPUSH
17177: CALL_OW 180
// AddComChangeProfession ( Ape , CLASS_APEMAN_KAMIKAZE ) ;
17181: LD_VAR 0 1
17185: PPUSH
17186: LD_INT 17
17188: PPUSH
17189: CALL_OW 183
// AddComExitBuilding ( Ape ) ;
17193: LD_VAR 0 1
17197: PPUSH
17198: CALL_OW 182
// end ;
17202: LD_VAR 0 2
17206: RET
// function chci_ridice_opicaka ; begin
17207: LD_INT 0
17209: PPUSH
// Result = false ;
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_INT 0
17217: ST_TO_ADDR
// if VolnyRidiciOpicaci >= 2 then
17218: LD_LOC 48
17222: PUSH
17223: LD_INT 2
17225: GREATEREQUAL
17226: IFFALSE 17230
// exit ;
17228: GO 17264
// if UnitsInside ( ArFact ) > 4 then
17230: LD_INT 5
17232: PPUSH
17233: CALL_OW 313
17237: PUSH
17238: LD_INT 4
17240: GREATER
17241: IFFALSE 17245
// exit ;
17243: GO 17264
// if Prob ( 50 ) then
17245: LD_INT 50
17247: PPUSH
17248: CALL_OW 13
17252: IFFALSE 17256
// exit ;
17254: GO 17264
// Result = true ;
17256: LD_ADDR_VAR 0 1
17260: PUSH
17261: LD_INT 1
17263: ST_TO_ADDR
// end ;
17264: LD_VAR 0 1
17268: RET
// function men_na_kamikaze ; var O , I ; begin
17269: LD_INT 0
17271: PPUSH
17272: PPUSH
17273: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN ] , [ F_OUTSIDE ] ] ) ;
17274: LD_ADDR_VAR 0 2
17278: PUSH
17279: LD_INT 22
17281: PUSH
17282: LD_EXP 3
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 21
17293: PUSH
17294: LD_INT 1
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 12
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 56
17313: PUSH
17314: EMPTY
17315: LIST
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: ST_TO_ADDR
// for I in O do
17328: LD_ADDR_VAR 0 3
17332: PUSH
17333: LD_VAR 0 2
17337: PUSH
17338: FOR_IN
17339: IFFALSE 17411
// begin if IsBusy ( I ) then
17341: LD_VAR 0 3
17345: PPUSH
17346: CALL_OW 315
17350: IFFALSE 17354
// continue ;
17352: GO 17338
// if HasTask ( I ) then
17354: LD_VAR 0 3
17358: PPUSH
17359: CALL_OW 314
17363: IFFALSE 17367
// continue ;
17365: GO 17338
// if IsInUnit ( I ) then
17367: LD_VAR 0 3
17371: PPUSH
17372: CALL_OW 310
17376: IFFALSE 17380
// continue ;
17378: GO 17338
// if chci_ridice_opicaka then
17380: CALL 17207 0 0
17384: IFFALSE 17400
// begin ComEnterUnit ( I , ArFact ) ;
17386: LD_VAR 0 3
17390: PPUSH
17391: LD_INT 5
17393: PPUSH
17394: CALL_OW 120
// end else
17398: GO 17409
// zmen_na_kamikaze ( I ) ;
17400: LD_VAR 0 3
17404: PPUSH
17405: CALL 17166 0 1
// end ;
17409: GO 17338
17411: POP
17412: POP
// end ;
17413: LD_VAR 0 1
17417: RET
// function vedec_volny ( List ) ; var I , OK ; begin
17418: LD_INT 0
17420: PPUSH
17421: PPUSH
17422: PPUSH
// OK = [ ] ;
17423: LD_ADDR_VAR 0 4
17427: PUSH
17428: EMPTY
17429: ST_TO_ADDR
// for I in List do
17430: LD_ADDR_VAR 0 3
17434: PUSH
17435: LD_VAR 0 1
17439: PUSH
17440: FOR_IN
17441: IFFALSE 17487
// if IsInUnit ( I ) or not HasTask ( I ) then
17443: LD_VAR 0 3
17447: PPUSH
17448: CALL_OW 310
17452: PUSH
17453: LD_VAR 0 3
17457: PPUSH
17458: CALL_OW 314
17462: NOT
17463: OR
17464: IFFALSE 17485
// OK = OK union [ I ] ;
17466: LD_ADDR_VAR 0 4
17470: PUSH
17471: LD_VAR 0 4
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: EMPTY
17482: LIST
17483: UNION
17484: ST_TO_ADDR
17485: GO 17440
17487: POP
17488: POP
// Result = nahoda_seznam ( OK ) ;
17489: LD_ADDR_VAR 0 2
17493: PUSH
17494: LD_VAR 0 4
17498: PPUSH
17499: CALL 21635 0 1
17503: ST_TO_ADDR
// end ;
17504: LD_VAR 0 2
17508: RET
// function lakej_opice ; var Opice , Kdo , I ; begin
17509: LD_INT 0
17511: PPUSH
17512: PPUSH
17513: PPUSH
17514: PPUSH
// if KdoLakaOpice then
17515: LD_LOC 68
17519: IFFALSE 17523
// exit ;
17521: GO 17715
// Kdo = vedec_volny ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLeci ) ;
17523: LD_ADDR_VAR 0 3
17527: PUSH
17528: LD_LOC 28
17532: PUSH
17533: LD_LOC 29
17537: PUSH
17538: LD_LOC 30
17542: PUSH
17543: LD_LOC 31
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: LIST
17552: LIST
17553: PUSH
17554: LD_LOC 66
17558: DIFF
17559: PPUSH
17560: CALL 17418 0 1
17564: ST_TO_ADDR
// if not Kdo then
17565: LD_VAR 0 3
17569: NOT
17570: IFFALSE 17574
// exit ;
17572: GO 17715
// if HasTask ( Kdo ) then
17574: LD_VAR 0 3
17578: PPUSH
17579: CALL_OW 314
17583: IFFALSE 17587
// exit ;
17585: GO 17715
// Opice = FilterUnitsInArea ( AraboveOpice , [ [ F_SIDE , side_Neutral ] , [ F_CLASS , CLASS_APEMAN ] ] ) ;
17587: LD_ADDR_VAR 0 2
17591: PUSH
17592: LD_INT 13
17594: PPUSH
17595: LD_INT 22
17597: PUSH
17598: LD_EXP 1
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 25
17609: PUSH
17610: LD_INT 12
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: PPUSH
17621: CALL_OW 70
17625: ST_TO_ADDR
// if not Opice then
17626: LD_VAR 0 2
17630: NOT
17631: IFFALSE 17635
// exit ;
17633: GO 17715
// KdoLakaOpice = [ Kdo ] ;
17635: LD_ADDR_LOC 68
17639: PUSH
17640: LD_VAR 0 3
17644: PUSH
17645: EMPTY
17646: LIST
17647: ST_TO_ADDR
// ComExitBuilding ( KdoLakaOpice ) ;
17648: LD_LOC 68
17652: PPUSH
17653: CALL_OW 122
// for I in Opice do
17657: LD_ADDR_VAR 0 4
17661: PUSH
17662: LD_VAR 0 2
17666: PUSH
17667: FOR_IN
17668: IFFALSE 17701
// AddComTameXY ( KdoLakaOpice , GetX ( I ) , GetY ( I ) ) ;
17670: LD_LOC 68
17674: PPUSH
17675: LD_VAR 0 4
17679: PPUSH
17680: CALL_OW 250
17684: PPUSH
17685: LD_VAR 0 4
17689: PPUSH
17690: CALL_OW 251
17694: PPUSH
17695: CALL_OW 191
17699: GO 17667
17701: POP
17702: POP
// AddComSailEvent ( KdoLakaOpice , 103 ) ;
17703: LD_LOC 68
17707: PPUSH
17708: LD_INT 103
17710: PPUSH
17711: CALL_OW 224
// end ;
17715: LD_VAR 0 1
17719: RET
// export function event_DolakanaOpice ; var Kdo ; begin
17720: LD_INT 0
17722: PPUSH
17723: PPUSH
// for Kdo in KdoLakaOpice do
17724: LD_ADDR_VAR 0 2
17728: PUSH
17729: LD_LOC 68
17733: PUSH
17734: FOR_IN
17735: IFFALSE 17748
// zpet_do_labu ( Kdo ) ;
17737: LD_VAR 0 2
17741: PPUSH
17742: CALL 13127 0 1
17746: GO 17734
17748: POP
17749: POP
// KdoLakaOpice = [ ] ;
17750: LD_ADDR_LOC 68
17754: PUSH
17755: EMPTY
17756: ST_TO_ADDR
// end ;
17757: LD_VAR 0 1
17761: RET
// function vytvor_nove_opice ; var Opice , I , Hex , Pocet ; begin
17762: LD_INT 0
17764: PPUSH
17765: PPUSH
17766: PPUSH
17767: PPUSH
17768: PPUSH
// Result = true ;
17769: LD_ADDR_VAR 0 1
17773: PUSH
17774: LD_INT 1
17776: ST_TO_ADDR
// Opice = FilterAllUnits ( [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
17777: LD_ADDR_VAR 0 2
17781: PUSH
17782: LD_INT 2
17784: PUSH
17785: LD_INT 25
17787: PUSH
17788: LD_INT 12
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: PUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 15
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PUSH
17805: LD_INT 25
17807: PUSH
17808: LD_INT 16
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: PUSH
17815: LD_INT 25
17817: PUSH
17818: LD_INT 17
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: LIST
17831: PUSH
17832: EMPTY
17833: LIST
17834: PPUSH
17835: CALL_OW 69
17839: ST_TO_ADDR
// if Opice > MaxOpice then
17840: LD_VAR 0 2
17844: PUSH
17845: LD_LOC 61
17849: GREATER
17850: IFFALSE 17854
// exit ;
17852: GO 18048
// Pocet = Rand ( 1 , OpiceNajednouPocet ) ;
17854: LD_ADDR_VAR 0 5
17858: PUSH
17859: LD_INT 1
17861: PPUSH
17862: LD_LOC 65
17866: PPUSH
17867: CALL_OW 12
17871: ST_TO_ADDR
// if ( OpiceLimit <> - 1 ) and ( Pocet > OpiceLimit ) then
17872: LD_LOC 64
17876: PUSH
17877: LD_INT 1
17879: NEG
17880: NONEQUAL
17881: PUSH
17882: LD_VAR 0 5
17886: PUSH
17887: LD_LOC 64
17891: GREATER
17892: AND
17893: IFFALSE 17905
// Pocet = OpiceLimit ;
17895: LD_ADDR_VAR 0 5
17899: PUSH
17900: LD_LOC 64
17904: ST_TO_ADDR
// Opice = create_nature ( CLASS_APEMAN , Pocet , CreateOpice ) ;
17905: LD_ADDR_VAR 0 2
17909: PUSH
17910: LD_INT 12
17912: PPUSH
17913: LD_VAR 0 5
17917: PPUSH
17918: LD_INT 14
17920: PPUSH
17921: CALL 2877 0 3
17925: ST_TO_ADDR
// for I in Opice do
17926: LD_ADDR_VAR 0 3
17930: PUSH
17931: LD_VAR 0 2
17935: PUSH
17936: FOR_IN
17937: IFFALSE 18001
// if Prob ( PstOpiceRus ) then
17939: LD_LOC 63
17943: PPUSH
17944: CALL_OW 13
17948: IFFALSE 17999
// begin Hex = RandHexArea ( Les , true ) ;
17950: LD_ADDR_VAR 0 4
17954: PUSH
17955: LD_INT 1
17957: PPUSH
17958: LD_INT 1
17960: PPUSH
17961: CALL_OW 16
17965: ST_TO_ADDR
// if Hex then
17966: LD_VAR 0 4
17970: IFFALSE 17999
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
17972: LD_VAR 0 3
17976: PPUSH
17977: LD_VAR 0 4
17981: PUSH
17982: LD_INT 1
17984: ARRAY
17985: PPUSH
17986: LD_VAR 0 4
17990: PUSH
17991: LD_INT 2
17993: ARRAY
17994: PPUSH
17995: CALL_OW 111
// end ;
17999: GO 17936
18001: POP
18002: POP
// if OpiceLimit <> - 1 then
18003: LD_LOC 64
18007: PUSH
18008: LD_INT 1
18010: NEG
18011: NONEQUAL
18012: IFFALSE 18048
// begin OpiceLimit = OpiceLimit - Pocet ;
18014: LD_ADDR_LOC 64
18018: PUSH
18019: LD_LOC 64
18023: PUSH
18024: LD_VAR 0 5
18028: MINUS
18029: ST_TO_ADDR
// if OpiceLimit = 0 then
18030: LD_LOC 64
18034: PUSH
18035: LD_INT 0
18037: EQUAL
18038: IFFALSE 18048
// Result = false ;
18040: LD_ADDR_VAR 0 1
18044: PUSH
18045: LD_INT 0
18047: ST_TO_ADDR
// end ; end ;
18048: LD_VAR 0 1
18052: RET
// every 0 0$15.3 do
18053: GO 18055
18055: DISABLE
// begin men_na_kamikaze ;
18056: CALL 17269 0 0
// enable ;
18060: ENABLE
// end ;
18061: END
// every 0 0$7.1 do
18062: GO 18064
18064: DISABLE
// begin kamikazuj_opicaky ;
18065: CALL 17096 0 0
// enable ;
18069: ENABLE
// end ;
18070: END
// every 1 1$13 do
18071: GO 18073
18073: DISABLE
// begin lakej_opice ;
18074: CALL 17509 0 0
// enable ;
18078: ENABLE
// end ;
18079: END
// every 2 2$25 do
18080: GO 18082
18082: DISABLE
// begin Wait ( Rand ( ZpozdeniOpice [ 1 ] , ZpozdeniOpice [ 2 ] ) ) ;
18083: LD_LOC 62
18087: PUSH
18088: LD_INT 1
18090: ARRAY
18091: PPUSH
18092: LD_LOC 62
18096: PUSH
18097: LD_INT 2
18099: ARRAY
18100: PPUSH
18101: CALL_OW 12
18105: PPUSH
18106: CALL_OW 67
// if vytvor_nove_opice then
18110: CALL 17762 0 0
18114: IFFALSE 18117
// enable ;
18116: ENABLE
// end ;
18117: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
18118: LD_EXP 3
18122: PPUSH
18123: LD_EXP 2
18127: PPUSH
18128: CALL 21683 0 2
18132: IFFALSE 18145
18134: GO 18136
18136: DISABLE
// begin VidelRusa = true ;
18137: LD_ADDR_LOC 58
18141: PUSH
18142: LD_INT 1
18144: ST_TO_ADDR
// end ;
18145: END
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
18146: LD_INT 0
18148: PPUSH
18149: PPUSH
18150: PPUSH
// if Veh = ArDalkar then
18151: LD_VAR 0 1
18155: PUSH
18156: LD_LOC 49
18160: EQUAL
18161: IFFALSE 18202
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
18163: LD_LOC 36
18167: PPUSH
18168: CALL_OW 302
18172: PUSH
18173: LD_LOC 36
18177: PPUSH
18178: CALL_OW 310
18182: NOT
18183: AND
18184: IFFALSE 18202
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
18186: LD_LOC 36
18190: PPUSH
18191: LD_VAR 0 1
18195: PPUSH
18196: CALL_OW 120
// exit ;
18200: GO 18273
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
18202: LD_ADDR_VAR 0 3
18206: PUSH
18207: LD_LOC 39
18211: PPUSH
18212: LD_INT 56
18214: PUSH
18215: EMPTY
18216: LIST
18217: PUSH
18218: EMPTY
18219: LIST
18220: PPUSH
18221: CALL_OW 72
18225: ST_TO_ADDR
// for I in Lidi do
18226: LD_ADDR_VAR 0 4
18230: PUSH
18231: LD_VAR 0 3
18235: PUSH
18236: FOR_IN
18237: IFFALSE 18271
// if not HasTask ( I ) then
18239: LD_VAR 0 4
18243: PPUSH
18244: CALL_OW 314
18248: NOT
18249: IFFALSE 18269
// begin ComEnterUnit ( I , Veh ) ;
18251: LD_VAR 0 4
18255: PPUSH
18256: LD_VAR 0 1
18260: PPUSH
18261: CALL_OW 120
// exit ;
18265: POP
18266: POP
18267: GO 18273
// end ;
18269: GO 18236
18271: POP
18272: POP
// end ;
18273: LD_VAR 0 2
18277: RET
// function nastupuj_auta ; var Auta , I ; begin
18278: LD_INT 0
18280: PPUSH
18281: PPUSH
18282: PPUSH
// Auta = FilterUnitsInArea ( AraboveObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
18283: LD_ADDR_VAR 0 2
18287: PUSH
18288: LD_INT 12
18290: PPUSH
18291: LD_INT 21
18293: PUSH
18294: LD_INT 2
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: PUSH
18301: LD_INT 33
18303: PUSH
18304: LD_INT 1
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: PUSH
18311: LD_INT 58
18313: PUSH
18314: EMPTY
18315: LIST
18316: PUSH
18317: EMPTY
18318: LIST
18319: LIST
18320: LIST
18321: PPUSH
18322: CALL_OW 70
18326: ST_TO_ADDR
// if not Auta then
18327: LD_VAR 0 2
18331: NOT
18332: IFFALSE 18336
// exit ;
18334: GO 18362
// for I in Auta do
18336: LD_ADDR_VAR 0 3
18340: PUSH
18341: LD_VAR 0 2
18345: PUSH
18346: FOR_IN
18347: IFFALSE 18360
// zarid_ridice ( I ) ;
18349: LD_VAR 0 3
18353: PPUSH
18354: CALL 18146 0 1
18358: GO 18346
18360: POP
18361: POP
// end ;
18362: LD_VAR 0 1
18366: RET
// every 0 0$17 do
18367: GO 18369
18369: DISABLE
// begin nastupuj_auta ;
18370: CALL 18278 0 0
// enable ;
18374: ENABLE
// end ;
18375: END
// every 0 0$5.1 do var I , Stahnout ;
18376: GO 18378
18378: DISABLE
18379: LD_INT 0
18381: PPUSH
18382: PPUSH
// begin Stahnout = true ;
18383: LD_ADDR_VAR 0 2
18387: PUSH
18388: LD_INT 1
18390: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
18391: LD_ADDR_VAR 0 1
18395: PUSH
18396: LD_LOC 43
18400: PPUSH
18401: CALL_OW 389
18405: PUSH
18406: FOR_IN
18407: IFFALSE 18438
// if ( GetUnitMc ( I ) = MakroObrana ) then
18409: LD_VAR 0 1
18413: PPUSH
18414: CALL_OW 388
18418: PUSH
18419: LD_LOC 43
18423: EQUAL
18424: IFFALSE 18436
// begin Stahnout = false ;
18426: LD_ADDR_VAR 0 2
18430: PUSH
18431: LD_INT 0
18433: ST_TO_ADDR
// break ;
18434: GO 18438
// end ;
18436: GO 18406
18438: POP
18439: POP
// enable ;
18440: ENABLE
// if Stahnout <> BeziStahovani then
18441: LD_VAR 0 2
18445: PUSH
18446: LD_LOC 60
18450: NONEQUAL
18451: IFFALSE 18477
// begin if Stahnout then
18453: LD_VAR 0 2
18457: IFFALSE 18464
// enable ( 46 ) else
18459: LD_INT 46
18461: ENABLE_MARKED
18462: GO 18467
// disable ( 46 ) ;
18464: LD_INT 46
18466: DISABLE_MARKED
// BeziStahovani = Stahnout ;
18467: LD_ADDR_LOC 60
18471: PUSH
18472: LD_VAR 0 2
18476: ST_TO_ADDR
// end ; end ;
18477: PPOPN 2
18479: END
// every 0 0$30 marked 32 do var I ;
18480: GO 18482
18482: DISABLE
18483: LD_INT 0
18485: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
18486: LD_ADDR_VAR 0 1
18490: PUSH
18491: LD_LOC 59
18495: PPUSH
18496: CALL_OW 389
18500: PUSH
18501: FOR_IN
18502: IFFALSE 18577
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , Arabove ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
18504: LD_VAR 0 1
18508: PPUSH
18509: CALL_OW 388
18513: PUSH
18514: LD_LOC 59
18518: EQUAL
18519: PUSH
18520: LD_VAR 0 1
18524: PPUSH
18525: LD_INT 5
18527: PPUSH
18528: CALL_OW 299
18532: PUSH
18533: LD_INT 0
18535: GREATER
18536: AND
18537: PUSH
18538: LD_VAR 0 1
18542: PPUSH
18543: CALL_OW 310
18547: NOT
18548: AND
18549: PUSH
18550: LD_VAR 0 1
18554: PPUSH
18555: CALL_OW 314
18559: NOT
18560: AND
18561: IFFALSE 18575
// ComMoveToArea ( I , Arabove ) ;
18563: LD_VAR 0 1
18567: PPUSH
18568: LD_INT 5
18570: PPUSH
18571: CALL_OW 113
18575: GO 18501
18577: POP
18578: POP
// BeziStahovani = false ;
18579: LD_ADDR_LOC 60
18583: PUSH
18584: LD_INT 0
18586: ST_TO_ADDR
// end ;
18587: PPOPN 1
18589: END
// every 1 1$16 do var Inz ;
18590: GO 18592
18592: DISABLE
18593: LD_INT 0
18595: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] , [ F_OK ] ] ) ;
18596: LD_ADDR_VAR 0 1
18600: PUSH
18601: LD_INT 22
18603: PUSH
18604: LD_EXP 3
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: LD_INT 21
18615: PUSH
18616: LD_INT 1
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 25
18625: PUSH
18626: LD_INT 2
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 50
18635: PUSH
18636: EMPTY
18637: LIST
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: PPUSH
18645: CALL_OW 69
18649: ST_TO_ADDR
// sbirej_bedny ( Inz , Arabove ) ;
18650: LD_VAR 0 1
18654: PPUSH
18655: LD_INT 5
18657: PPUSH
18658: CALL 21122 0 2
// opravuj_budovy ( Inz , Arabove , side_Ar ) ;
18662: LD_VAR 0 1
18666: PPUSH
18667: LD_INT 5
18669: PPUSH
18670: LD_EXP 3
18674: PPUSH
18675: CALL 21352 0 3
// enable ;
18679: ENABLE
// end ;
18680: PPOPN 1
18682: END
// function opravuj ; begin
18683: LD_INT 0
18685: PPUSH
// if KdoOpravuje then
18686: LD_LOC 67
18690: IFFALSE 18694
// exit ;
18692: GO 18734
// KdoOpravuje = opravuj_auta ( [ ArMech1 , ArMech2 ] , 104 , Arabove , side_Ar , Utok_Auta ) ;
18694: LD_ADDR_LOC 67
18698: PUSH
18699: LD_LOC 32
18703: PUSH
18704: LD_LOC 33
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: PPUSH
18713: LD_INT 104
18715: PPUSH
18716: LD_INT 5
18718: PPUSH
18719: LD_EXP 3
18723: PPUSH
18724: LD_LOC 41
18728: PPUSH
18729: CALL 21870 0 5
18733: ST_TO_ADDR
// end ;
18734: LD_VAR 0 1
18738: RET
// function kuryruj ; begin
18739: LD_INT 0
18741: PPUSH
// if KdoLeci then
18742: LD_LOC 66
18746: IFFALSE 18750
// exit ;
18748: GO 18803
// KdoLeci = kuryruj_lidi ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLakaOpice , 105 , Arabove , side_Ar ) ;
18750: LD_ADDR_LOC 66
18754: PUSH
18755: LD_LOC 28
18759: PUSH
18760: LD_LOC 29
18764: PUSH
18765: LD_LOC 30
18769: PUSH
18770: LD_LOC 31
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: LIST
18779: LIST
18780: PUSH
18781: LD_LOC 68
18785: DIFF
18786: PPUSH
18787: LD_INT 105
18789: PPUSH
18790: LD_INT 5
18792: PPUSH
18793: LD_EXP 3
18797: PPUSH
18798: CALL 22172 0 4
18802: ST_TO_ADDR
// end ;
18803: LD_VAR 0 1
18807: RET
// export function event_ArabiOprava ( Event ) ; var Kdo ; begin
18808: LD_INT 0
18810: PPUSH
18811: PPUSH
// case Event of 104 :
18812: LD_VAR 0 1
18816: PUSH
18817: LD_INT 104
18819: DOUBLE
18820: EQUAL
18821: IFTRUE 18825
18823: GO 18847
18825: POP
// begin ComEnterUnit ( KdoOpravuje , ArFact ) ;
18826: LD_LOC 67
18830: PPUSH
18831: LD_INT 5
18833: PPUSH
18834: CALL_OW 120
// KdoOpravuje = [ ] ;
18838: LD_ADDR_LOC 67
18842: PUSH
18843: EMPTY
18844: ST_TO_ADDR
// end ; 105 :
18845: GO 18892
18847: LD_INT 105
18849: DOUBLE
18850: EQUAL
18851: IFTRUE 18855
18853: GO 18891
18855: POP
// begin for Kdo in KdoLeci do
18856: LD_ADDR_VAR 0 3
18860: PUSH
18861: LD_LOC 66
18865: PUSH
18866: FOR_IN
18867: IFFALSE 18880
// zpet_do_labu ( Kdo ) ;
18869: LD_VAR 0 3
18873: PPUSH
18874: CALL 13127 0 1
18878: GO 18866
18880: POP
18881: POP
// KdoLeci = [ ] ;
18882: LD_ADDR_LOC 66
18886: PUSH
18887: EMPTY
18888: ST_TO_ADDR
// end ; end ;
18889: GO 18892
18891: POP
// end ;
18892: LD_VAR 0 2
18896: RET
// every 0 0$57 do
18897: GO 18899
18899: DISABLE
// begin opravuj ;
18900: CALL 18683 0 0
// kuryruj ;
18904: CALL 18739 0 0
// enable ;
18908: ENABLE
// end ;
18909: END
// every 10 10$0 trigger difficulty = 3 do var i ;
18910: LD_OWVAR 67
18914: PUSH
18915: LD_INT 3
18917: EQUAL
18918: IFFALSE 19023
18920: GO 18922
18922: DISABLE
18923: LD_INT 0
18925: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , ar_gun ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ar_gatling_gun ] ] ] ) do
18926: LD_ADDR_VAR 0 1
18930: PUSH
18931: LD_INT 22
18933: PUSH
18934: LD_INT 2
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PUSH
18941: LD_INT 21
18943: PUSH
18944: LD_INT 2
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: LD_INT 2
18953: PUSH
18954: LD_INT 34
18956: PUSH
18957: LD_INT 27
18959: PUSH
18960: EMPTY
18961: LIST
18962: LIST
18963: PUSH
18964: LD_INT 34
18966: PUSH
18967: LD_INT 28
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PUSH
18974: LD_INT 34
18976: PUSH
18977: LD_INT 25
18979: PUSH
18980: EMPTY
18981: LIST
18982: LIST
18983: PUSH
18984: EMPTY
18985: LIST
18986: LIST
18987: LIST
18988: LIST
18989: PUSH
18990: EMPTY
18991: LIST
18992: LIST
18993: LIST
18994: PPUSH
18995: CALL_OW 69
18999: PUSH
19000: FOR_IN
19001: IFFALSE 19020
// begin ComAgressiveMove ( i , 26 , 25 ) ;
19003: LD_VAR 0 1
19007: PPUSH
19008: LD_INT 26
19010: PPUSH
19011: LD_INT 25
19013: PPUSH
19014: CALL_OW 114
// end ;
19018: GO 19000
19020: POP
19021: POP
// enable ;
19022: ENABLE
// end ; end_of_file
19023: PPOPN 1
19025: END
// export RusMaSiberit , RusMaOtraveno ; export ArabiZniceni , LegieMamZnicit , LegieZnicena ; export BehemothBuilt , MenLost ; export function init_rusove ; begin
19026: LD_INT 0
19028: PPUSH
// disable ( 21 ) ;
19029: LD_INT 21
19031: DISABLE_MARKED
// RusMaSiberit = false ;
19032: LD_ADDR_EXP 63
19036: PUSH
19037: LD_INT 0
19039: ST_TO_ADDR
// RusMaOtraveno = 0 ;
19040: LD_ADDR_EXP 64
19044: PUSH
19045: LD_INT 0
19047: ST_TO_ADDR
// ArabiZniceni = false ;
19048: LD_ADDR_EXP 65
19052: PUSH
19053: LD_INT 0
19055: ST_TO_ADDR
// LegieMamZnicit = false ;
19056: LD_ADDR_EXP 66
19060: PUSH
19061: LD_INT 0
19063: ST_TO_ADDR
// LegieZnicena = false ;
19064: LD_ADDR_EXP 67
19068: PUSH
19069: LD_INT 0
19071: ST_TO_ADDR
// BehemothBuilt = false ;
19072: LD_ADDR_EXP 68
19076: PUSH
19077: LD_INT 0
19079: ST_TO_ADDR
// MenLost = 0 ;
19080: LD_ADDR_EXP 69
19084: PUSH
19085: LD_INT 0
19087: ST_TO_ADDR
// end ;
19088: LD_VAR 0 1
19092: RET
// export function uvod ; var I , Auto ; begin
19093: LD_INT 0
19095: PPUSH
19096: PPUSH
19097: PPUSH
// InGameOn ;
19098: CALL_OW 8
// if Masha then
19102: LD_EXP 25
19106: IFFALSE 19139
// begin PlaceHumanInUnit ( Burlak , Masha ) ;
19108: LD_EXP 6
19112: PPUSH
19113: LD_EXP 25
19117: PPUSH
19118: CALL_OW 52
// PlaceUnitArea ( Masha , Start , false ) ;
19122: LD_EXP 25
19126: PPUSH
19127: LD_INT 3
19129: PPUSH
19130: LD_INT 0
19132: PPUSH
19133: CALL_OW 49
// end else
19137: GO 19181
// begin Auto = vytvor_tank ( RU_GUN ) ;
19139: LD_ADDR_VAR 0 3
19143: PUSH
19144: LD_INT 44
19146: PPUSH
19147: CALL 19502 0 1
19151: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , Auto ) ;
19152: LD_EXP 6
19156: PPUSH
19157: LD_VAR 0 3
19161: PPUSH
19162: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19166: LD_VAR 0 3
19170: PPUSH
19171: LD_INT 3
19173: PPUSH
19174: LD_INT 0
19176: PPUSH
19177: CALL_OW 49
// end ; PlaceUnitArea ( vytvor_nakladak ( MAT_OIL , 100 ) , Start , false ) ;
19181: LD_INT 2
19183: PPUSH
19184: LD_INT 100
19186: PPUSH
19187: CALL 19405 0 2
19191: PPUSH
19192: LD_INT 3
19194: PPUSH
19195: LD_INT 0
19197: PPUSH
19198: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19202: LD_INT 1
19204: PPUSH
19205: LD_INT 100
19207: PPUSH
19208: CALL 19405 0 2
19212: PPUSH
19213: LD_INT 3
19215: PPUSH
19216: LD_INT 0
19218: PPUSH
19219: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19223: LD_INT 1
19225: PPUSH
19226: LD_INT 100
19228: PPUSH
19229: CALL 19405 0 2
19233: PPUSH
19234: LD_INT 3
19236: PPUSH
19237: LD_INT 0
19239: PPUSH
19240: CALL_OW 49
// if Rusove then
19244: LD_EXP 39
19248: IFFALSE 19340
// begin Auto = 0 ;
19250: LD_ADDR_VAR 0 3
19254: PUSH
19255: LD_INT 0
19257: ST_TO_ADDR
// for I in Rusove do
19258: LD_ADDR_VAR 0 2
19262: PUSH
19263: LD_EXP 39
19267: PUSH
19268: FOR_IN
19269: IFFALSE 19338
// begin if Auto then
19271: LD_VAR 0 3
19275: IFFALSE 19294
// PlaceUnitArea ( I , Start , false ) else
19277: LD_VAR 0 2
19281: PPUSH
19282: LD_INT 3
19284: PPUSH
19285: LD_INT 0
19287: PPUSH
19288: CALL_OW 49
19292: GO 19336
// begin Auto = vytvor_tank ( RU_GATLING_GUN ) ;
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 43
19301: PPUSH
19302: CALL 19502 0 1
19306: ST_TO_ADDR
// PlaceHumanInUnit ( I , Auto ) ;
19307: LD_VAR 0 2
19311: PPUSH
19312: LD_VAR 0 3
19316: PPUSH
19317: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19321: LD_VAR 0 3
19325: PPUSH
19326: LD_INT 3
19328: PPUSH
19329: LD_INT 0
19331: PPUSH
19332: CALL_OW 49
// end ; end ;
19336: GO 19268
19338: POP
19339: POP
// end ; I = IsInUnit ( Burlak ) ;
19340: LD_ADDR_VAR 0 2
19344: PUSH
19345: LD_EXP 6
19349: PPUSH
19350: CALL_OW 310
19354: ST_TO_ADDR
// if I then
19355: LD_VAR 0 2
19359: IFFALSE 19372
// CenterNowOnUnits ( I ) else
19361: LD_VAR 0 2
19365: PPUSH
19366: CALL_OW 87
19370: GO 19381
// CenterNowOnUnits ( Burlak ) ;
19372: LD_EXP 6
19376: PPUSH
19377: CALL_OW 87
// dialog_Start ;
19381: CALL 4619 0 0
// ChangeMissionObjectives ( MStart ) ;
19385: LD_STRING MStart
19387: PPUSH
19388: CALL_OW 337
// SaveForQuickRestart ;
19392: CALL_OW 22
// InGameOff ;
19396: CALL_OW 9
// end ;
19400: LD_VAR 0 1
19404: RET
// function vytvor_nakladak ( Material , Amount ) ; begin
19405: LD_INT 0
19407: PPUSH
// UC_Side = side_Ru ;
19408: LD_ADDR_OWVAR 20
19412: PUSH
19413: LD_EXP 2
19417: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19418: LD_ADDR_OWVAR 21
19422: PUSH
19423: LD_INT 3
19425: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19426: LD_ADDR_OWVAR 37
19430: PUSH
19431: LD_INT 21
19433: ST_TO_ADDR
// VC_Control = CONTROL_COMPUTER ;
19434: LD_ADDR_OWVAR 38
19438: PUSH
19439: LD_INT 3
19441: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
19442: LD_ADDR_OWVAR 39
19446: PUSH
19447: LD_INT 3
19449: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
19450: LD_ADDR_OWVAR 40
19454: PUSH
19455: LD_INT 51
19457: ST_TO_ADDR
// Result = CreateVehicle ;
19458: LD_ADDR_VAR 0 3
19462: PUSH
19463: CALL_OW 45
19467: ST_TO_ADDR
// if Amount > 0 then
19468: LD_VAR 0 2
19472: PUSH
19473: LD_INT 0
19475: GREATER
19476: IFFALSE 19497
// SetCargo ( Result , Material , Amount ) ;
19478: LD_VAR 0 3
19482: PPUSH
19483: LD_VAR 0 1
19487: PPUSH
19488: LD_VAR 0 2
19492: PPUSH
19493: CALL_OW 290
// end ;
19497: LD_VAR 0 3
19501: RET
// function vytvor_tank ( Zbran ) ; begin
19502: LD_INT 0
19504: PPUSH
// UC_Side = side_Ru ;
19505: LD_ADDR_OWVAR 20
19509: PUSH
19510: LD_EXP 2
19514: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19515: LD_ADDR_OWVAR 21
19519: PUSH
19520: LD_INT 3
19522: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19523: LD_ADDR_OWVAR 37
19527: PUSH
19528: LD_INT 21
19530: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
19531: LD_ADDR_OWVAR 38
19535: PUSH
19536: LD_INT 1
19538: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
19539: LD_ADDR_OWVAR 39
19543: PUSH
19544: LD_INT 1
19546: ST_TO_ADDR
// VC_Weapon = Zbran ;
19547: LD_ADDR_OWVAR 40
19551: PUSH
19552: LD_VAR 0 1
19556: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 70 , 90 ) ;
19557: LD_ADDR_OWVAR 41
19561: PUSH
19562: LD_INT 70
19564: PPUSH
19565: LD_INT 90
19567: PPUSH
19568: CALL_OW 12
19572: ST_TO_ADDR
// Result = CreateVehicle ;
19573: LD_ADDR_VAR 0 2
19577: PUSH
19578: CALL_OW 45
19582: ST_TO_ADDR
// end ;
19583: LD_VAR 0 2
19587: RET
// function arabska_zakladna_kaput ; begin
19588: LD_INT 0
19590: PPUSH
// Wait ( 0 0$3.5 ) ;
19591: LD_INT 122
19593: PPUSH
19594: CALL_OW 67
// SetAttitude ( side_Ru , side_Ar , ATT_NEUTRAL , true ) ;
19598: LD_EXP 2
19602: PPUSH
19603: LD_EXP 3
19607: PPUSH
19608: LD_INT 0
19610: PPUSH
19611: LD_INT 1
19613: PPUSH
19614: CALL_OW 80
// disable ( 31 ) ;
19618: LD_INT 31
19620: DISABLE_MARKED
// DialogueOn ;
19621: CALL_OW 6
// dialog_SurrenderArabians ;
19625: CALL 5549 0 0
// DialogueOff ;
19629: CALL_OW 7
// ChangeMissionObjectives ( MAttOut ) ;
19633: LD_STRING MAttOut
19635: PPUSH
19636: CALL_OW 337
// if LegionOffer_Accepted or LegionFugit_Accepted then
19640: LD_EXP 59
19644: PUSH
19645: LD_EXP 60
19649: OR
19650: IFFALSE 19727
// begin if LegieZnicena then
19652: LD_EXP 67
19656: IFFALSE 19664
// begin vyhral ;
19658: CALL 2051 0 0
// exit ;
19662: GO 19731
// end ; LegieMamZnicit = true ;
19664: LD_ADDR_EXP 66
19668: PUSH
19669: LD_INT 1
19671: ST_TO_ADDR
// if UnitFilter ( Uprchlici , [ [ F_ALIVE ] ] ) then
19672: LD_EXP 61
19676: PPUSH
19677: LD_INT 51
19679: PUSH
19680: EMPTY
19681: LIST
19682: PUSH
19683: EMPTY
19684: LIST
19685: PPUSH
19686: CALL_OW 72
19690: IFFALSE 19722
// begin DialogueOn ;
19692: CALL_OW 6
// dialog_LegionLeave ;
19696: CALL 5173 0 0
// DialogueOff ;
19700: CALL_OW 7
// SetSide ( Uprchlici , side_Upr ) ;
19704: LD_EXP 61
19708: PPUSH
19709: LD_EXP 5
19713: PPUSH
19714: CALL_OW 235
// uprchlici_zacnete_odchazet ;
19718: CALL 10678 0 0
// end ; enable ( 21 ) ;
19722: LD_INT 21
19724: ENABLE_MARKED
// end else
19725: GO 19731
// begin vyhral ;
19727: CALL 2051 0 0
// end ; end ;
19731: LD_VAR 0 1
19735: RET
// function legie_zakladna_kaput ; begin
19736: LD_INT 0
19738: PPUSH
// SetAttitude ( side_Le , side_Ru , ATT_NEUTRAL , true ) ;
19739: LD_EXP 4
19743: PPUSH
19744: LD_EXP 2
19748: PPUSH
19749: LD_INT 0
19751: PPUSH
19752: LD_INT 1
19754: PPUSH
19755: CALL_OW 80
// SetAttitude ( side_Upr , side_Ru , ATT_NEUTRAL , true ) ;
19759: LD_EXP 5
19763: PPUSH
19764: LD_EXP 2
19768: PPUSH
19769: LD_INT 0
19771: PPUSH
19772: LD_INT 1
19774: PPUSH
19775: CALL_OW 80
// ChangeMissionObjectives ( MLegOut ) ;
19779: LD_STRING MLegOut
19781: PPUSH
19782: CALL_OW 337
// if ArabiZniceni then
19786: LD_EXP 65
19790: IFFALSE 19796
// vyhral ;
19792: CALL 2051 0 0
// end ;
19796: LD_VAR 0 1
19800: RET
// function kontrola_arabska_zakladna ; var Domy , Lidi ; begin
19801: LD_INT 0
19803: PPUSH
19804: PPUSH
19805: PPUSH
// if ArabiZniceni then
19806: LD_EXP 65
19810: IFFALSE 19814
// exit ;
19812: GO 19956
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
19814: LD_ADDR_VAR 0 2
19818: PUSH
19819: LD_INT 22
19821: PUSH
19822: LD_EXP 3
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: PUSH
19831: LD_INT 52
19833: PUSH
19834: EMPTY
19835: LIST
19836: PUSH
19837: LD_INT 50
19839: PUSH
19840: EMPTY
19841: LIST
19842: PUSH
19843: LD_INT 21
19845: PUSH
19846: LD_INT 3
19848: PUSH
19849: EMPTY
19850: LIST
19851: LIST
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: PPUSH
19859: CALL_OW 69
19863: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
19864: LD_ADDR_VAR 0 3
19868: PUSH
19869: LD_INT 22
19871: PUSH
19872: LD_EXP 3
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: PUSH
19881: LD_INT 52
19883: PUSH
19884: EMPTY
19885: LIST
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: EMPTY
19891: LIST
19892: PUSH
19893: LD_INT 21
19895: PUSH
19896: LD_INT 1
19898: PUSH
19899: EMPTY
19900: LIST
19901: LIST
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: PPUSH
19909: CALL_OW 69
19913: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and ( Lidi < dif_ArabiLidiVzdajSe [ Difficulty ] ) then
19914: LD_VAR 0 2
19918: PPUSH
19919: CALL 21771 0 1
19923: NOT
19924: PUSH
19925: LD_VAR 0 3
19929: PUSH
19930: LD_EXP 56
19934: PUSH
19935: LD_OWVAR 67
19939: ARRAY
19940: LESS
19941: AND
19942: IFFALSE 19956
// begin ArabiZniceni = true ;
19944: LD_ADDR_EXP 65
19948: PUSH
19949: LD_INT 1
19951: ST_TO_ADDR
// arabska_zakladna_kaput ;
19952: CALL 19588 0 0
// end ; end ;
19956: LD_VAR 0 1
19960: RET
// function kontrola_legie_zakladna ; var Domy , Lidi ; begin
19961: LD_INT 0
19963: PPUSH
19964: PPUSH
19965: PPUSH
// if LegieZnicena then
19966: LD_EXP 67
19970: IFFALSE 19974
// exit ;
19972: GO 20197
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
19974: LD_ADDR_VAR 0 2
19978: PUSH
19979: LD_INT 22
19981: PUSH
19982: LD_EXP 4
19986: PUSH
19987: EMPTY
19988: LIST
19989: LIST
19990: PUSH
19991: LD_INT 50
19993: PUSH
19994: EMPTY
19995: LIST
19996: PUSH
19997: LD_INT 52
19999: PUSH
20000: EMPTY
20001: LIST
20002: PUSH
20003: LD_INT 21
20005: PUSH
20006: LD_INT 3
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: LIST
20017: LIST
20018: PPUSH
20019: CALL_OW 69
20023: PUSH
20024: LD_INT 22
20026: PUSH
20027: LD_EXP 5
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PUSH
20036: LD_INT 50
20038: PUSH
20039: EMPTY
20040: LIST
20041: PUSH
20042: LD_INT 52
20044: PUSH
20045: EMPTY
20046: LIST
20047: PUSH
20048: LD_INT 21
20050: PUSH
20051: LD_INT 3
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: LIST
20062: LIST
20063: PPUSH
20064: CALL_OW 69
20068: UNION
20069: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
20070: LD_ADDR_VAR 0 3
20074: PUSH
20075: LD_INT 22
20077: PUSH
20078: LD_EXP 4
20082: PUSH
20083: EMPTY
20084: LIST
20085: LIST
20086: PUSH
20087: LD_INT 50
20089: PUSH
20090: EMPTY
20091: LIST
20092: PUSH
20093: LD_INT 52
20095: PUSH
20096: EMPTY
20097: LIST
20098: PUSH
20099: LD_INT 21
20101: PUSH
20102: LD_INT 1
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: PPUSH
20115: CALL_OW 69
20119: PUSH
20120: LD_INT 22
20122: PUSH
20123: LD_EXP 5
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: PUSH
20132: LD_INT 50
20134: PUSH
20135: EMPTY
20136: LIST
20137: PUSH
20138: LD_INT 52
20140: PUSH
20141: EMPTY
20142: LIST
20143: PUSH
20144: LD_INT 21
20146: PUSH
20147: LD_INT 1
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: PPUSH
20160: CALL_OW 69
20164: UNION
20165: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and not Lidi then
20166: LD_VAR 0 2
20170: PPUSH
20171: CALL 21771 0 1
20175: NOT
20176: PUSH
20177: LD_VAR 0 3
20181: NOT
20182: AND
20183: IFFALSE 20197
// begin LegieZnicena = true ;
20185: LD_ADDR_EXP 67
20189: PUSH
20190: LD_INT 1
20192: ST_TO_ADDR
// legie_zakladna_kaput ;
20193: CALL 19736 0 0
// end ; end ;
20197: LD_VAR 0 1
20201: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
20202: LD_INT 0
20204: PPUSH
// if Un = Burlak then
20205: LD_VAR 0 1
20209: PUSH
20210: LD_EXP 6
20214: EQUAL
20215: IFFALSE 20226
// begin YouLost ( Burlak ) ;
20217: LD_STRING Burlak
20219: PPUSH
20220: CALL_OW 104
// exit ;
20224: GO 20260
// end ; if Un in Rusove then
20226: LD_VAR 0 1
20230: PUSH
20231: LD_EXP 39
20235: IN
20236: IFFALSE 20252
// MenLost = MenLost + 1 ;
20238: LD_ADDR_EXP 69
20242: PUSH
20243: LD_EXP 69
20247: PUSH
20248: LD_INT 1
20250: PLUS
20251: ST_TO_ADDR
// kontrola_arabska_zakladna ;
20252: CALL 19801 0 0
// kontrola_legie_zakladna ;
20256: CALL 19961 0 0
// end ;
20260: LD_VAR 0 2
20264: RET
// export function rusove_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
20265: LD_INT 0
20267: PPUSH
// if OrigSide = side_Ar then
20268: LD_VAR 0 2
20272: PUSH
20273: LD_EXP 3
20277: EQUAL
20278: IFFALSE 20284
// kontrola_arabska_zakladna ;
20280: CALL 19801 0 0
// if OrigSide = side_Le then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_EXP 4
20293: EQUAL
20294: IFFALSE 20300
// kontrola_legie_zakladna ;
20296: CALL 19961 0 0
// end ;
20300: LD_VAR 0 4
20304: RET
// export function rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
20305: LD_INT 0
20307: PPUSH
// if OrigSide = side_Ru then
20308: LD_VAR 0 3
20312: PUSH
20313: LD_EXP 2
20317: EQUAL
20318: IFFALSE 20324
// kontrola_arabska_zakladna ;
20320: CALL 19801 0 0
// if Masha = VehOld then
20324: LD_EXP 25
20328: PUSH
20329: LD_VAR 0 2
20333: EQUAL
20334: IFFALSE 20346
// Masha = VehNew ;
20336: LD_ADDR_EXP 25
20340: PUSH
20341: LD_VAR 0 1
20345: ST_TO_ADDR
// end ;
20346: LD_VAR 0 5
20350: RET
// every 0 0$10 marked 21 do
20351: GO 20353
20353: DISABLE
// begin Wait ( Rand ( 0 0$15 , 0 0$35 ) ) ;
20354: LD_INT 525
20356: PPUSH
20357: LD_INT 1225
20359: PPUSH
20360: CALL_OW 12
20364: PPUSH
20365: CALL_OW 67
// DialogueOn ;
20369: CALL_OW 6
// dialog_LegionSpy ;
20373: CALL 5251 0 0
// if LegionOffer_Heike then
20377: LD_EXP 58
20381: IFFALSE 20389
// dialog_LegionChallengeHeike else
20383: CALL 5317 0 0
20387: GO 20393
// dialog_LegionChallengeFarmer ;
20389: CALL 5379 0 0
// ChangeMissionObjectives ( MLeg ) ;
20393: LD_STRING MLeg
20395: PPUSH
20396: CALL_OW 337
// SetAttitude ( side_Ru , side_Le , ATT_ENEMY , true ) ;
20400: LD_EXP 2
20404: PPUSH
20405: LD_EXP 4
20409: PPUSH
20410: LD_INT 2
20412: PPUSH
20413: LD_INT 1
20415: PPUSH
20416: CALL_OW 80
// SetAttitude ( side_Ru , side_Upr , ATT_ENEMY , true ) ;
20420: LD_EXP 2
20424: PPUSH
20425: LD_EXP 5
20429: PPUSH
20430: LD_INT 2
20432: PPUSH
20433: LD_INT 1
20435: PPUSH
20436: CALL_OW 80
// DialogueOff ;
20440: CALL_OW 7
// end ;
20444: END
// every 4 4$30 do
20445: GO 20447
20447: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
20448: LD_INT 35
20450: PPUSH
20451: LD_INT 4200
20453: PPUSH
20454: CALL_OW 12
20458: PPUSH
20459: CALL_OW 67
// DialogueOn ;
20463: CALL_OW 6
// dialog_AmAttack ;
20467: CALL 4685 0 0
// ChangeMissionObjectives ( MAttack ) ;
20471: LD_STRING MAttack
20473: PPUSH
20474: CALL_OW 337
// DialogueOff ;
20478: CALL_OW 7
// end ;
20482: END
// every 9 9$0 do
20483: GO 20485
20485: DISABLE
// begin Wait ( Rand ( 0 0$1 , 4 4$0 ) ) ;
20486: LD_INT 35
20488: PPUSH
20489: LD_INT 8400
20491: PPUSH
20492: CALL_OW 12
20496: PPUSH
20497: CALL_OW 67
// if not BehemothBuilt then
20501: LD_EXP 68
20505: NOT
20506: IFFALSE 20539
// begin DialogueOn ;
20508: CALL_OW 6
// if BehemothSeen then
20512: LD_EXP 36
20516: IFFALSE 20524
// dialog_BehemothTechno1 else
20518: CALL 5657 0 0
20522: GO 20528
// dialog_BehemothTechno2 ;
20524: CALL 5792 0 0
// ChangeMissionObjectives ( MBeh ) ;
20528: LD_STRING MBeh
20530: PPUSH
20531: CALL_OW 337
// DialogueOff ;
20535: CALL_OW 7
// end ; end ;
20539: END
// export function rusove_BuildingComplete ( Build ) ; begin
20540: LD_INT 0
20542: PPUSH
// if GetSide ( Build ) = side_Ru then
20543: LD_VAR 0 1
20547: PPUSH
20548: CALL_OW 255
20552: PUSH
20553: LD_EXP 2
20557: EQUAL
20558: IFFALSE 20583
// begin if GetBType ( Build ) = B_SIBERITE_MINE then
20560: LD_VAR 0 1
20564: PPUSH
20565: CALL_OW 266
20569: PUSH
20570: LD_INT 30
20572: EQUAL
20573: IFFALSE 20583
// RusMaSiberit = true ;
20575: LD_ADDR_EXP 63
20579: PUSH
20580: LD_INT 1
20582: ST_TO_ADDR
// end ; end ;
20583: LD_VAR 0 2
20587: RET
// export function rusove_BehemothConstructed ( Un ) ; begin
20588: LD_INT 0
20590: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and not BehemothBuilt then
20591: LD_VAR 0 1
20595: PPUSH
20596: CALL_OW 255
20600: PUSH
20601: LD_EXP 2
20605: EQUAL
20606: PUSH
20607: LD_EXP 68
20611: NOT
20612: AND
20613: IFFALSE 20642
// begin BehemothBuilt = true ;
20615: LD_ADDR_EXP 68
20619: PUSH
20620: LD_INT 1
20622: ST_TO_ADDR
// DialogueOn ;
20623: CALL_OW 6
// dialog_BehemothComplete ;
20627: CALL 5896 0 0
// ChangeMissionObjectives ( MBehOut ) ;
20631: LD_STRING MBehOut
20633: PPUSH
20634: CALL_OW 337
// DialogueOff ;
20638: CALL_OW 7
// end ; end ;
20642: LD_VAR 0 2
20646: RET
// export function rusove_SibDepositContaminated ( Un , X , Y ) ; begin
20647: LD_INT 0
20649: PPUSH
// RusMaOtraveno = RusMaOtraveno + 1 ;
20650: LD_ADDR_EXP 64
20654: PUSH
20655: LD_EXP 64
20659: PUSH
20660: LD_INT 1
20662: PLUS
20663: ST_TO_ADDR
// if RusMaOtraveno = 1 then
20664: LD_EXP 64
20668: PUSH
20669: LD_INT 1
20671: EQUAL
20672: IFFALSE 20701
// begin Wait ( Rand ( 0 0$1 , 0 0$10 ) ) ;
20674: LD_INT 35
20676: PPUSH
20677: LD_INT 350
20679: PPUSH
20680: CALL_OW 12
20684: PPUSH
20685: CALL_OW 67
// DialogueOn ;
20689: CALL_OW 6
// dialog_Contam ;
20693: CALL 5447 0 0
// DialogueOff ;
20697: CALL_OW 7
// end ; end ; end_of_file
20701: LD_VAR 0 4
20705: RET
// on Contact ( Side1 , Side2 ) do begin legion_Contact ( Side1 , Side2 ) ;
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 2
20715: PPUSH
20716: CALL 11190 0 2
// end ;
20720: PPOPN 2
20722: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
20723: LD_VAR 0 1
20727: PPUSH
20728: CALL 20202 0 1
// arabi_UnitDestroyed ( Un ) ;
20732: LD_VAR 0 1
20736: PPUSH
20737: CALL 14091 0 1
// legion_UnitDestroyed ( Un ) ;
20741: LD_VAR 0 1
20745: PPUSH
20746: CALL 11273 0 1
// end ;
20750: PPOPN 1
20752: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
20753: LD_VAR 0 1
20757: PPUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL 14848 0 2
// legion_VehicleConstructed ( Veh , Fact ) ;
20767: LD_VAR 0 1
20771: PPUSH
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL 7704 0 2
// end ;
20781: PPOPN 2
20783: END
// on BuildingComplete ( Build ) do begin rusove_BuildingComplete ( Build ) ;
20784: LD_VAR 0 1
20788: PPUSH
20789: CALL 20540 0 1
// end ;
20793: PPOPN 1
20795: END
// on SibDepositContaminated ( Un , X , Y ) do begin rusove_SibDepositContaminated ( Un , X , Y ) ;
20796: LD_VAR 0 1
20800: PPUSH
20801: LD_VAR 0 2
20805: PPUSH
20806: LD_VAR 0 3
20810: PPUSH
20811: CALL 20647 0 3
// end ;
20815: PPOPN 3
20817: END
// on SailEvent ( Event ) do begin case Event of 101 :
20818: LD_VAR 0 1
20822: PUSH
20823: LD_INT 101
20825: DOUBLE
20826: EQUAL
20827: IFTRUE 20831
20829: GO 20838
20831: POP
// event_Kontaminovano ; 103 :
20832: CALL 14049 0 0
20836: GO 20951
20838: LD_INT 103
20840: DOUBLE
20841: EQUAL
20842: IFTRUE 20846
20844: GO 20853
20846: POP
// event_DolakanaOpice ; 104 , 105 :
20847: CALL 17720 0 0
20851: GO 20951
20853: LD_INT 104
20855: DOUBLE
20856: EQUAL
20857: IFTRUE 20867
20859: LD_INT 105
20861: DOUBLE
20862: EQUAL
20863: IFTRUE 20867
20865: GO 20879
20867: POP
// event_ArabiOprava ( Event ) ; 111 :
20868: LD_VAR 0 1
20872: PPUSH
20873: CALL 18808 0 1
20877: GO 20951
20879: LD_INT 111
20881: DOUBLE
20882: EQUAL
20883: IFTRUE 20887
20885: GO 20894
20887: POP
// event_KoupeniPrisli ; 112 :
20888: CALL 9860 0 0
20892: GO 20951
20894: LD_INT 112
20896: DOUBLE
20897: EQUAL
20898: IFTRUE 20902
20900: GO 20909
20902: POP
// event_UprchliciPrisli ; 113 , 114 :
20903: CALL 10730 0 0
20907: GO 20951
20909: LD_INT 113
20911: DOUBLE
20912: EQUAL
20913: IFTRUE 20923
20915: LD_INT 114
20917: DOUBLE
20918: EQUAL
20919: IFTRUE 20923
20921: GO 20935
20923: POP
// event_LegionOprava ( Event ) ; 115 :
20924: LD_VAR 0 1
20928: PPUSH
20929: CALL 7355 0 1
20933: GO 20951
20935: LD_INT 115
20937: DOUBLE
20938: EQUAL
20939: IFTRUE 20943
20941: GO 20950
20943: POP
// event_LegionPrebarvi ; end ;
20944: CALL 10701 0 0
20948: GO 20951
20950: POP
// end ;
20951: PPOPN 1
20953: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin rusove_BuildingCaptured ( Build , OrigSide , Eng ) ;
20954: LD_VAR 0 1
20958: PPUSH
20959: LD_VAR 0 2
20963: PPUSH
20964: LD_VAR 0 3
20968: PPUSH
20969: CALL 20265 0 3
// end ;
20973: PPOPN 3
20975: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20976: LD_VAR 0 1
20980: PPUSH
20981: LD_VAR 0 2
20985: PPUSH
20986: LD_VAR 0 3
20990: PPUSH
20991: LD_VAR 0 4
20995: PPUSH
20996: CALL 20305 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
21000: LD_VAR 0 1
21004: PPUSH
21005: LD_VAR 0 2
21009: PPUSH
21010: LD_VAR 0 3
21014: PPUSH
21015: LD_VAR 0 4
21019: PPUSH
21020: CALL 14423 0 4
// legion_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
21024: LD_VAR 0 1
21028: PPUSH
21029: LD_VAR 0 2
21033: PPUSH
21034: LD_VAR 0 3
21038: PPUSH
21039: LD_VAR 0 4
21043: PPUSH
21044: CALL 11256 0 4
// end ;
21048: PPOPN 4
21050: END
// on BehemothConstructed ( Un ) do begin rusove_BehemothConstructed ( Un ) ;
21051: LD_VAR 0 1
21055: PPUSH
21056: CALL 20588 0 1
// end ;
21060: PPOPN 1
21062: END
// on ApemanTamed ( Ape , Sci ) do begin arabi_ApemanTamed ( Ape , Sci ) ;
21063: LD_VAR 0 1
21067: PPUSH
21068: LD_VAR 0 2
21072: PPUSH
21073: CALL 17054 0 2
// end ;
21077: PPOPN 2
21079: END
// on EnterBuilding ( Building , Un ) do begin arabi_EnterBuilding ( Building , Un ) ;
21080: LD_VAR 0 1
21084: PPUSH
21085: LD_VAR 0 2
21089: PPUSH
21090: CALL 14780 0 2
// end ;
21094: PPOPN 2
21096: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
21097: LD_VAR 0 1
21101: PPUSH
21102: LD_VAR 0 2
21106: PPUSH
21107: CALL 16380 0 2
// end ;
21111: PPOPN 2
21113: END
// every 1 1$59 do
21114: GO 21116
21116: DISABLE
// begin RandomizeAll ;
21117: CALL_OW 11
// end ; end_of_file
21121: END
// export function sbirej_bedny ( Jednotky , Area ) ; var I , Ok , Kdo , Bedny , Delka , X , Y ; begin
21122: LD_INT 0
21124: PPUSH
21125: PPUSH
21126: PPUSH
21127: PPUSH
21128: PPUSH
21129: PPUSH
21130: PPUSH
21131: PPUSH
// Ok = false ;
21132: LD_ADDR_VAR 0 5
21136: PUSH
21137: LD_INT 0
21139: ST_TO_ADDR
// for Kdo in Jednotky do
21140: LD_ADDR_VAR 0 6
21144: PUSH
21145: LD_VAR 0 1
21149: PUSH
21150: FOR_IN
21151: IFFALSE 21176
// if IsOk ( Kdo ) then
21153: LD_VAR 0 6
21157: PPUSH
21158: CALL_OW 302
21162: IFFALSE 21174
// begin Ok = true ;
21164: LD_ADDR_VAR 0 5
21168: PUSH
21169: LD_INT 1
21171: ST_TO_ADDR
// break ;
21172: GO 21176
// end ;
21174: GO 21150
21176: POP
21177: POP
// if not Ok then
21178: LD_VAR 0 5
21182: NOT
21183: IFFALSE 21187
// exit ;
21185: GO 21347
// Bedny = GetListOfCratesInArea ( Area ) ;
21187: LD_ADDR_VAR 0 7
21191: PUSH
21192: LD_VAR 0 2
21196: PPUSH
21197: CALL_OW 435
21201: ST_TO_ADDR
// if not Bedny then
21202: LD_VAR 0 7
21206: NOT
21207: IFFALSE 21211
// exit ;
21209: GO 21347
// Delka = Bedny div 2 ;
21211: LD_ADDR_VAR 0 8
21215: PUSH
21216: LD_VAR 0 7
21220: PUSH
21221: LD_INT 2
21223: DIV
21224: ST_TO_ADDR
// for I = 1 to Delka do
21225: LD_ADDR_VAR 0 4
21229: PUSH
21230: DOUBLE
21231: LD_INT 1
21233: DEC
21234: ST_TO_ADDR
21235: LD_VAR 0 8
21239: PUSH
21240: FOR_TO
21241: IFFALSE 21345
// begin X = Bedny [ 2 * I - 1 ] ;
21243: LD_ADDR_VAR 0 9
21247: PUSH
21248: LD_VAR 0 7
21252: PUSH
21253: LD_INT 2
21255: PUSH
21256: LD_VAR 0 4
21260: MUL
21261: PUSH
21262: LD_INT 1
21264: MINUS
21265: ARRAY
21266: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
21267: LD_ADDR_VAR 0 10
21271: PUSH
21272: LD_VAR 0 7
21276: PUSH
21277: LD_INT 2
21279: PUSH
21280: LD_VAR 0 4
21284: MUL
21285: ARRAY
21286: ST_TO_ADDR
// for Kdo in Jednotky do
21287: LD_ADDR_VAR 0 6
21291: PUSH
21292: LD_VAR 0 1
21296: PUSH
21297: FOR_IN
21298: IFFALSE 21341
// if IsOk ( Kdo ) and Prob ( 50 ) then
21300: LD_VAR 0 6
21304: PPUSH
21305: CALL_OW 302
21309: PUSH
21310: LD_INT 50
21312: PPUSH
21313: CALL_OW 13
21317: AND
21318: IFFALSE 21339
// AddComCollect ( Kdo , X , Y ) ;
21320: LD_VAR 0 6
21324: PPUSH
21325: LD_VAR 0 9
21329: PPUSH
21330: LD_VAR 0 10
21334: PPUSH
21335: CALL_OW 177
21339: GO 21297
21341: POP
21342: POP
// end ;
21343: GO 21240
21345: POP
21346: POP
// end ;
21347: LD_VAR 0 3
21351: RET
// export function opravuj_budovy ( Jednotky , Area , Side ) ; var Budovy , Opravit , I , Kde ; begin
21352: LD_INT 0
21354: PPUSH
21355: PPUSH
21356: PPUSH
21357: PPUSH
21358: PPUSH
// Budovy = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , Side ] ] ) ;
21359: LD_ADDR_VAR 0 5
21363: PUSH
21364: LD_VAR 0 2
21368: PPUSH
21369: LD_INT 21
21371: PUSH
21372: LD_INT 3
21374: PUSH
21375: EMPTY
21376: LIST
21377: LIST
21378: PUSH
21379: LD_INT 22
21381: PUSH
21382: LD_VAR 0 3
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PPUSH
21395: CALL_OW 70
21399: ST_TO_ADDR
// Opravit = [ ] ;
21400: LD_ADDR_VAR 0 6
21404: PUSH
21405: EMPTY
21406: ST_TO_ADDR
// for I in Budovy do
21407: LD_ADDR_VAR 0 7
21411: PUSH
21412: LD_VAR 0 5
21416: PUSH
21417: FOR_IN
21418: IFFALSE 21456
// if GetLives ( I ) < HRANICE_ZDRAVI then
21420: LD_VAR 0 7
21424: PPUSH
21425: CALL_OW 256
21429: PUSH
21430: LD_INT 1000
21432: LESS
21433: IFFALSE 21454
// Opravit = Opravit union [ I ] ;
21435: LD_ADDR_VAR 0 6
21439: PUSH
21440: LD_VAR 0 6
21444: PUSH
21445: LD_VAR 0 7
21449: PUSH
21450: EMPTY
21451: LIST
21452: UNION
21453: ST_TO_ADDR
21454: GO 21417
21456: POP
21457: POP
// for I in Opravit do
21458: LD_ADDR_VAR 0 7
21462: PUSH
21463: LD_VAR 0 6
21467: PUSH
21468: FOR_IN
21469: IFFALSE 21487
// AddComRepairBuilding ( Jednotky , I ) ;
21471: LD_VAR 0 1
21475: PPUSH
21476: LD_VAR 0 7
21480: PPUSH
21481: CALL_OW 190
21485: GO 21468
21487: POP
21488: POP
// end ;
21489: LD_VAR 0 4
21493: RET
// export function min ( A , B ) ; begin
21494: LD_INT 0
21496: PPUSH
// if A < B then
21497: LD_VAR 0 1
21501: PUSH
21502: LD_VAR 0 2
21506: LESS
21507: IFFALSE 21521
// Result = A else
21509: LD_ADDR_VAR 0 3
21513: PUSH
21514: LD_VAR 0 1
21518: ST_TO_ADDR
21519: GO 21531
// Result = B ;
21521: LD_ADDR_VAR 0 3
21525: PUSH
21526: LD_VAR 0 2
21530: ST_TO_ADDR
// end ;
21531: LD_VAR 0 3
21535: RET
// export function vidi_strana_cloveka ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21536: LD_INT 0
21538: PPUSH
21539: PPUSH
21540: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
21541: LD_ADDR_VAR 0 4
21545: PUSH
21546: LD_INT 22
21548: PUSH
21549: LD_VAR 0 2
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: PUSH
21558: LD_INT 21
21560: PUSH
21561: LD_INT 1
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PUSH
21568: EMPTY
21569: LIST
21570: LIST
21571: PPUSH
21572: CALL_OW 69
21576: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21577: LD_ADDR_VAR 0 5
21581: PUSH
21582: LD_VAR 0 4
21586: PUSH
21587: FOR_IN
21588: IFFALSE 21620
// if See ( Kdo , Jednotka ) then
21590: LD_VAR 0 1
21594: PPUSH
21595: LD_VAR 0 5
21599: PPUSH
21600: CALL_OW 292
21604: IFFALSE 21618
// begin Result = true ;
21606: LD_ADDR_VAR 0 3
21610: PUSH
21611: LD_INT 1
21613: ST_TO_ADDR
// exit ;
21614: POP
21615: POP
21616: GO 21630
// end ;
21618: GO 21587
21620: POP
21621: POP
// Result = false ;
21622: LD_ADDR_VAR 0 3
21626: PUSH
21627: LD_INT 0
21629: ST_TO_ADDR
// end ;
21630: LD_VAR 0 3
21634: RET
// export function nahoda_seznam ( Seznam ) ; begin
21635: LD_INT 0
21637: PPUSH
// if Seznam then
21638: LD_VAR 0 1
21642: IFFALSE 21670
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21644: LD_ADDR_VAR 0 2
21648: PUSH
21649: LD_VAR 0 1
21653: PUSH
21654: LD_INT 1
21656: PPUSH
21657: LD_VAR 0 1
21661: PPUSH
21662: CALL_OW 12
21666: ARRAY
21667: ST_TO_ADDR
21668: GO 21678
// Result = 0 ;
21670: LD_ADDR_VAR 0 2
21674: PUSH
21675: LD_INT 0
21677: ST_TO_ADDR
// end ;
21678: LD_VAR 0 2
21682: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21683: LD_INT 0
21685: PPUSH
21686: PPUSH
21687: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21688: LD_ADDR_VAR 0 4
21692: PUSH
21693: LD_INT 22
21695: PUSH
21696: LD_VAR 0 2
21700: PUSH
21701: EMPTY
21702: LIST
21703: LIST
21704: PUSH
21705: EMPTY
21706: LIST
21707: PPUSH
21708: CALL_OW 69
21712: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21713: LD_ADDR_VAR 0 5
21717: PUSH
21718: LD_VAR 0 4
21722: PUSH
21723: FOR_IN
21724: IFFALSE 21756
// if See ( Kdo , Jednotka ) then
21726: LD_VAR 0 1
21730: PPUSH
21731: LD_VAR 0 5
21735: PPUSH
21736: CALL_OW 292
21740: IFFALSE 21754
// begin Result = true ;
21742: LD_ADDR_VAR 0 3
21746: PUSH
21747: LD_INT 1
21749: ST_TO_ADDR
// exit ;
21750: POP
21751: POP
21752: GO 21766
// end ;
21754: GO 21723
21756: POP
21757: POP
// Result = false ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_INT 0
21765: ST_TO_ADDR
// end ;
21766: LD_VAR 0 3
21770: RET
// export function obsahuje_dulezitou_budovu ( List ) ; var Dulezite , I ; begin
21771: LD_INT 0
21773: PPUSH
21774: PPUSH
21775: PPUSH
// Dulezite = [ B_DEPOT , B_WAREHOUSE ] ;
21776: LD_ADDR_VAR 0 3
21780: PUSH
21781: LD_INT 0
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: ST_TO_ADDR
// Result = true ;
21791: LD_ADDR_VAR 0 2
21795: PUSH
21796: LD_INT 1
21798: ST_TO_ADDR
// for I in Dulezite do
21799: LD_ADDR_VAR 0 4
21803: PUSH
21804: LD_VAR 0 3
21808: PUSH
21809: FOR_IN
21810: IFFALSE 21855
// if UnitFilter ( List , [ [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , I ] ] ) then
21812: LD_VAR 0 1
21816: PPUSH
21817: LD_INT 21
21819: PUSH
21820: LD_INT 3
21822: PUSH
21823: EMPTY
21824: LIST
21825: LIST
21826: PUSH
21827: LD_INT 30
21829: PUSH
21830: LD_VAR 0 4
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: EMPTY
21840: LIST
21841: LIST
21842: PPUSH
21843: CALL_OW 72
21847: IFFALSE 21853
// exit ;
21849: POP
21850: POP
21851: GO 21865
21853: GO 21809
21855: POP
21856: POP
// Result = false ;
21857: LD_ADDR_VAR 0 2
21861: PUSH
21862: LD_INT 0
21864: ST_TO_ADDR
// end ;
21865: LD_VAR 0 2
21869: RET
// export function opravuj_auta ( List , Event , Area , Side , Ignore ) ; var Auta , Opravit , I , Kde , Mech ; begin
21870: LD_INT 0
21872: PPUSH
21873: PPUSH
21874: PPUSH
21875: PPUSH
21876: PPUSH
21877: PPUSH
// Result = [ ] ;
21878: LD_ADDR_VAR 0 6
21882: PUSH
21883: EMPTY
21884: ST_TO_ADDR
// Mech = 0 ;
21885: LD_ADDR_VAR 0 11
21889: PUSH
21890: LD_INT 0
21892: ST_TO_ADDR
// for I in List do
21893: LD_ADDR_VAR 0 9
21897: PUSH
21898: LD_VAR 0 1
21902: PUSH
21903: FOR_IN
21904: IFFALSE 21931
// if IsOk ( I ) then
21906: LD_VAR 0 9
21910: PPUSH
21911: CALL_OW 302
21915: IFFALSE 21929
// begin Mech = I ;
21917: LD_ADDR_VAR 0 11
21921: PUSH
21922: LD_VAR 0 9
21926: ST_TO_ADDR
// break ;
21927: GO 21931
// end ;
21929: GO 21903
21931: POP
21932: POP
// if not Mech then
21933: LD_VAR 0 11
21937: NOT
21938: IFFALSE 21942
// exit ;
21940: GO 22167
// Auta = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , Side ] ] ) diff Ignore ;
21942: LD_ADDR_VAR 0 7
21946: PUSH
21947: LD_VAR 0 3
21951: PPUSH
21952: LD_INT 21
21954: PUSH
21955: LD_INT 2
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 22
21964: PUSH
21965: LD_VAR 0 4
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PPUSH
21978: CALL_OW 70
21982: PUSH
21983: LD_VAR 0 5
21987: DIFF
21988: ST_TO_ADDR
// Opravit = [ ] ;
21989: LD_ADDR_VAR 0 8
21993: PUSH
21994: EMPTY
21995: ST_TO_ADDR
// for I in Auta do
21996: LD_ADDR_VAR 0 9
22000: PUSH
22001: LD_VAR 0 7
22005: PUSH
22006: FOR_IN
22007: IFFALSE 22045
// if GetLives ( I ) < HRANICE_ZDRAVI then
22009: LD_VAR 0 9
22013: PPUSH
22014: CALL_OW 256
22018: PUSH
22019: LD_INT 1000
22021: LESS
22022: IFFALSE 22043
// Opravit = Opravit union [ I ] ;
22024: LD_ADDR_VAR 0 8
22028: PUSH
22029: LD_VAR 0 8
22033: PUSH
22034: LD_VAR 0 9
22038: PUSH
22039: EMPTY
22040: LIST
22041: UNION
22042: ST_TO_ADDR
22043: GO 22006
22045: POP
22046: POP
// if Opravit then
22047: LD_VAR 0 8
22051: IFFALSE 22167
// begin Kde = IsInUnit ( Mech ) ;
22053: LD_ADDR_VAR 0 10
22057: PUSH
22058: LD_VAR 0 11
22062: PPUSH
22063: CALL_OW 310
22067: ST_TO_ADDR
// if Kde then
22068: LD_VAR 0 10
22072: IFFALSE 22109
// if GetType ( Kde ) = UNIT_BUILDING then
22074: LD_VAR 0 10
22078: PPUSH
22079: CALL_OW 247
22083: PUSH
22084: LD_INT 3
22086: EQUAL
22087: IFFALSE 22100
// ComExitBuilding ( Mech ) else
22089: LD_VAR 0 11
22093: PPUSH
22094: CALL_OW 122
22098: GO 22109
// ComExitVehicle ( Mech ) ;
22100: LD_VAR 0 11
22104: PPUSH
22105: CALL_OW 121
// for I in Opravit do
22109: LD_ADDR_VAR 0 9
22113: PUSH
22114: LD_VAR 0 8
22118: PUSH
22119: FOR_IN
22120: IFFALSE 22138
// AddComRepairVehicle ( Mech , I ) ;
22122: LD_VAR 0 11
22126: PPUSH
22127: LD_VAR 0 9
22131: PPUSH
22132: CALL_OW 189
22136: GO 22119
22138: POP
22139: POP
// AddComSailEvent ( Mech , Event ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_VAR 0 2
22149: PPUSH
22150: CALL_OW 224
// Result = [ Mech ] ;
22154: LD_ADDR_VAR 0 6
22158: PUSH
22159: LD_VAR 0 11
22163: PUSH
22164: EMPTY
22165: LIST
22166: ST_TO_ADDR
// end ; end ;
22167: LD_VAR 0 6
22171: RET
// export function kuryruj_lidi ( List , Event , Area , Side ) ; var Lidi , Opravit , I , Kde , Felcar , Budova ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
22179: PPUSH
22180: PPUSH
// Result = [ ] ;
22181: LD_ADDR_VAR 0 5
22185: PUSH
22186: EMPTY
22187: ST_TO_ADDR
// Felcar = 0 ;
22188: LD_ADDR_VAR 0 10
22192: PUSH
22193: LD_INT 0
22195: ST_TO_ADDR
// for I in List do
22196: LD_ADDR_VAR 0 8
22200: PUSH
22201: LD_VAR 0 1
22205: PUSH
22206: FOR_IN
22207: IFFALSE 22234
// if IsOk ( I ) then
22209: LD_VAR 0 8
22213: PPUSH
22214: CALL_OW 302
22218: IFFALSE 22232
// begin Felcar = I ;
22220: LD_ADDR_VAR 0 10
22224: PUSH
22225: LD_VAR 0 8
22229: ST_TO_ADDR
// break ;
22230: GO 22234
// end ;
22232: GO 22206
22234: POP
22235: POP
// Lidi = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , Side ] ] ) ;
22236: LD_ADDR_VAR 0 6
22240: PUSH
22241: LD_VAR 0 3
22245: PPUSH
22246: LD_INT 21
22248: PUSH
22249: LD_INT 1
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: LD_INT 22
22258: PUSH
22259: LD_VAR 0 4
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: PPUSH
22272: CALL_OW 70
22276: ST_TO_ADDR
// Opravit = [ ] ;
22277: LD_ADDR_VAR 0 7
22281: PUSH
22282: EMPTY
22283: ST_TO_ADDR
// for I in Lidi do
22284: LD_ADDR_VAR 0 8
22288: PUSH
22289: LD_VAR 0 6
22293: PUSH
22294: FOR_IN
22295: IFFALSE 22333
// if GetLives ( I ) < HRANICE_ZDRAVI then
22297: LD_VAR 0 8
22301: PPUSH
22302: CALL_OW 256
22306: PUSH
22307: LD_INT 1000
22309: LESS
22310: IFFALSE 22331
// Opravit = Opravit union [ I ] ;
22312: LD_ADDR_VAR 0 7
22316: PUSH
22317: LD_VAR 0 7
22321: PUSH
22322: LD_VAR 0 8
22326: PUSH
22327: EMPTY
22328: LIST
22329: UNION
22330: ST_TO_ADDR
22331: GO 22294
22333: POP
22334: POP
// if Opravit then
22335: LD_VAR 0 7
22339: IFFALSE 22455
// begin Kde = IsInUnit ( Felcar ) ;
22341: LD_ADDR_VAR 0 9
22345: PUSH
22346: LD_VAR 0 10
22350: PPUSH
22351: CALL_OW 310
22355: ST_TO_ADDR
// if Kde then
22356: LD_VAR 0 9
22360: IFFALSE 22397
// if GetType ( Kde ) = UNIT_BUILDING then
22362: LD_VAR 0 9
22366: PPUSH
22367: CALL_OW 247
22371: PUSH
22372: LD_INT 3
22374: EQUAL
22375: IFFALSE 22388
// ComExitBuilding ( Felcar ) else
22377: LD_VAR 0 10
22381: PPUSH
22382: CALL_OW 122
22386: GO 22397
// ComExitVehicle ( Felcar ) ;
22388: LD_VAR 0 10
22392: PPUSH
22393: CALL_OW 121
// for I in Opravit do
22397: LD_ADDR_VAR 0 8
22401: PUSH
22402: LD_VAR 0 7
22406: PUSH
22407: FOR_IN
22408: IFFALSE 22426
// AddComHeal ( Felcar , I ) ;
22410: LD_VAR 0 10
22414: PPUSH
22415: LD_VAR 0 8
22419: PPUSH
22420: CALL_OW 188
22424: GO 22407
22426: POP
22427: POP
// AddComSailEvent ( Felcar , Event ) ;
22428: LD_VAR 0 10
22432: PPUSH
22433: LD_VAR 0 2
22437: PPUSH
22438: CALL_OW 224
// Result = [ Felcar ] ;
22442: LD_ADDR_VAR 0 5
22446: PUSH
22447: LD_VAR 0 10
22451: PUSH
22452: EMPTY
22453: LIST
22454: ST_TO_ADDR
// end ; end ;
22455: LD_VAR 0 5
22459: RET
// export function bez_opic ( List ) ; var Opice ; begin
22460: LD_INT 0
22462: PPUSH
22463: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
22464: LD_ADDR_VAR 0 3
22468: PUSH
22469: LD_VAR 0 1
22473: PPUSH
22474: LD_INT 2
22476: PUSH
22477: LD_INT 25
22479: PUSH
22480: LD_INT 12
22482: PUSH
22483: EMPTY
22484: LIST
22485: LIST
22486: PUSH
22487: LD_INT 25
22489: PUSH
22490: LD_INT 15
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: PUSH
22497: LD_INT 25
22499: PUSH
22500: LD_INT 16
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: LD_INT 25
22509: PUSH
22510: LD_INT 17
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: LIST
22523: PUSH
22524: EMPTY
22525: LIST
22526: PPUSH
22527: CALL_OW 72
22531: ST_TO_ADDR
// Result = List diff Opice ;
22532: LD_ADDR_VAR 0 2
22536: PUSH
22537: LD_VAR 0 1
22541: PUSH
22542: LD_VAR 0 3
22546: DIFF
22547: ST_TO_ADDR
// end ; end_of_file
22548: LD_VAR 0 2
22552: RET
// every 0 0$2 + 0 0$0.1 do
22553: GO 22555
22555: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
22556: LD_INT 22
22558: PUSH
22559: LD_INT 3
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: LD_INT 25
22571: PUSH
22572: LD_INT 12
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PUSH
22579: LD_INT 25
22581: PUSH
22582: LD_INT 16
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 25
22591: PUSH
22592: LD_INT 15
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 25
22601: PUSH
22602: LD_INT 17
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: EMPTY
22610: LIST
22611: LIST
22612: LIST
22613: LIST
22614: LIST
22615: PUSH
22616: EMPTY
22617: LIST
22618: LIST
22619: PPUSH
22620: CALL_OW 69
22624: PUSH
22625: LD_INT 22
22627: PUSH
22628: LD_INT 3
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: PUSH
22635: LD_INT 21
22637: PUSH
22638: LD_INT 1
22640: PUSH
22641: EMPTY
22642: LIST
22643: LIST
22644: PUSH
22645: LD_INT 3
22647: PUSH
22648: LD_INT 2
22650: PUSH
22651: LD_INT 25
22653: PUSH
22654: LD_INT 12
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: PUSH
22661: LD_INT 25
22663: PUSH
22664: LD_INT 16
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: PUSH
22671: LD_INT 25
22673: PUSH
22674: LD_INT 15
22676: PUSH
22677: EMPTY
22678: LIST
22679: LIST
22680: PUSH
22681: LD_INT 25
22683: PUSH
22684: LD_INT 17
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: EMPTY
22692: LIST
22693: LIST
22694: LIST
22695: LIST
22696: LIST
22697: PUSH
22698: EMPTY
22699: LIST
22700: LIST
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: LIST
22706: PPUSH
22707: CALL_OW 69
22711: GREATER
22712: IFFALSE 22723
// begin SetAchievement ( ACH_POTA ) ;
22714: LD_STRING ACH_POTA
22716: PPUSH
22717: CALL_OW 543
// exit ;
22721: GO 22724
// end ; enable ;
22723: ENABLE
// end ;
22724: END
// export function SA_OnLegionHired ; begin
22725: LD_INT 0
22727: PPUSH
// SetAchievement ( ACH_EMP ) ;
22728: LD_STRING ACH_EMP
22730: PPUSH
22731: CALL_OW 543
// end ;
22735: LD_VAR 0 1
22739: RET

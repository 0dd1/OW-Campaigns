// export side_Neutral , side_Ru , side_Ar , side_Le , side_Upr ; export Burlak ; export Belkov , Gnyevko , Kirilenkova ; export Kovalyuk , Scholtze ; export Kuzmov ; export Karamazov , Petrovova , Gleb , Petrosyan ; export Lipshchin , Titov , Dolgov , Xavier ; export Oblukov , Kozlov , Kapitsova ; export Ostatni ; export Masha ; export Gladkov , GladkovFake ; export Heike , Farmer , Bergkamp ; export Abdul , Omar ; export MercPaid , MercAccepted , MercHandedOver , BehemothSeen ; export HeikeKilled , OmarKilled ; export Rusove , Rusove2 ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 31
// Result = CreateCharacter ( Ident ) else
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
  29: GO 46
// Result = NewCharacter ( Ident ) ;
  31: LD_ADDR_VAR 0 2
  35: PUSH
  36: LD_VAR 0 1
  40: PPUSH
  41: CALL_OW 25
  45: ST_TO_ADDR
// end ;
  46: LD_VAR 0 2
  50: RET
// function load_set ( Ident ) ; begin
  51: LD_INT 0
  53: PPUSH
// if TestCharacters ( Ident ) then
  54: LD_VAR 0 1
  58: PPUSH
  59: CALL_OW 28
  63: IFFALSE 82
// Result = CreateCharacterSet ( Ident ) else
  65: LD_ADDR_VAR 0 2
  69: PUSH
  70: LD_VAR 0 1
  74: PPUSH
  75: CALL_OW 31
  79: ST_TO_ADDR
  80: GO 89
// Result = [ ] ;
  82: LD_ADDR_VAR 0 2
  86: PUSH
  87: EMPTY
  88: ST_TO_ADDR
// end ;
  89: LD_VAR 0 2
  93: RET
// function vytvor_gladkova ; begin
  94: LD_INT 0
  96: PPUSH
// UC_Nation = NATION_RUSSIAN ;
  97: LD_ADDR_OWVAR 21
 101: PUSH
 102: LD_INT 3
 104: ST_TO_ADDR
// UC_side = side_Ru ;
 105: LD_ADDR_OWVAR 20
 109: PUSH
 110: LD_EXP 2
 114: ST_TO_ADDR
// HC_name =  ;
 115: LD_ADDR_OWVAR 26
 119: PUSH
 120: LD_STRING 
 122: ST_TO_ADDR
// HC_sex = SEX_MALE ;
 123: LD_ADDR_OWVAR 27
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 131: LD_ADDR_OWVAR 28
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// PrepareSoldierSkills ( 7 ) ;
 139: LD_INT 7
 141: PPUSH
 142: CALL_OW 375
// Result = CreateHuman ;
 146: LD_ADDR_VAR 0 1
 150: PUSH
 151: CALL_OW 44
 155: ST_TO_ADDR
// end ;
 156: LD_VAR 0 1
 160: RET
// function load ; var MashaSpec ; begin
 161: LD_INT 0
 163: PPUSH
 164: PPUSH
// AutoEnemy = false ;
 165: LD_ADDR_OWVAR 74
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// MercPaid = LoadVariable ( MercPaid , false ) ;
 173: LD_ADDR_EXP 33
 177: PUSH
 178: LD_STRING MercPaid
 180: PPUSH
 181: LD_INT 0
 183: PPUSH
 184: CALL_OW 30
 188: ST_TO_ADDR
// MercAccepted = LoadVariable ( MercAccepted , false ) ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_STRING MercAccepted
 196: PPUSH
 197: LD_INT 0
 199: PPUSH
 200: CALL_OW 30
 204: ST_TO_ADDR
// MercHandedOver = LoadVariable ( MercHandedOver , false ) ;
 205: LD_ADDR_EXP 35
 209: PUSH
 210: LD_STRING MercHandedOver
 212: PPUSH
 213: LD_INT 0
 215: PPUSH
 216: CALL_OW 30
 220: ST_TO_ADDR
// BehemothSeen = LoadVariable ( BehemothSeen , false ) ;
 221: LD_ADDR_EXP 36
 225: PUSH
 226: LD_STRING BehemothSeen
 228: PPUSH
 229: LD_INT 0
 231: PPUSH
 232: CALL_OW 30
 236: ST_TO_ADDR
// HeikeKilled = LoadVariable ( HeikeKilled , false ) ;
 237: LD_ADDR_EXP 37
 241: PUSH
 242: LD_STRING HeikeKilled
 244: PPUSH
 245: LD_INT 0
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// OmarKilled = LoadVariable ( OmarKilled , false ) ;
 253: LD_ADDR_EXP 38
 257: PUSH
 258: LD_STRING OmarKilled
 260: PPUSH
 261: LD_INT 0
 263: PPUSH
 264: CALL_OW 30
 268: ST_TO_ADDR
// UC_Side = side_Le ;
 269: LD_ADDR_OWVAR 20
 273: PUSH
 274: LD_EXP 4
 278: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 2
 286: ST_TO_ADDR
// Heike = load_char ( Heike ) ;
 287: LD_ADDR_EXP 28
 291: PUSH
 292: LD_STRING Heike
 294: PPUSH
 295: CALL 0 0 1
 299: ST_TO_ADDR
// Farmer = load_char ( Farmer ) ;
 300: LD_ADDR_EXP 29
 304: PUSH
 305: LD_STRING Farmer
 307: PPUSH
 308: CALL 0 0 1
 312: ST_TO_ADDR
// Bergkamp = load_char ( Bergkamp ) ;
 313: LD_ADDR_EXP 30
 317: PUSH
 318: LD_STRING Bergkamp
 320: PPUSH
 321: CALL 0 0 1
 325: ST_TO_ADDR
// UC_Side = side_Ar ;
 326: LD_ADDR_OWVAR 20
 330: PUSH
 331: LD_EXP 3
 335: ST_TO_ADDR
// Abdul = load_char ( Abdul ) ;
 336: LD_ADDR_EXP 31
 340: PUSH
 341: LD_STRING Abdul
 343: PPUSH
 344: CALL 0 0 1
 348: ST_TO_ADDR
// if not OmarKilled then
 349: LD_EXP 38
 353: NOT
 354: IFFALSE 369
// Omar = load_char ( Omar ) ;
 356: LD_ADDR_EXP 32
 360: PUSH
 361: LD_STRING Omar
 363: PPUSH
 364: CALL 0 0 1
 368: ST_TO_ADDR
// UC_Side = side_Ru ;
 369: LD_ADDR_OWVAR 20
 373: PUSH
 374: LD_EXP 2
 378: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// Gladkov = load_char ( Gladkov ) ;
 387: LD_ADDR_EXP 26
 391: PUSH
 392: LD_STRING Gladkov
 394: PPUSH
 395: CALL 0 0 1
 399: ST_TO_ADDR
// if not Gladkov then
 400: LD_EXP 26
 404: NOT
 405: IFFALSE 417
// GladkovFake = vytvor_gladkova ;
 407: LD_ADDR_EXP 27
 411: PUSH
 412: CALL 94 0 0
 416: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 417: LD_ADDR_EXP 6
 421: PUSH
 422: LD_STRING Burlak
 424: PPUSH
 425: CALL 0 0 1
 429: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 430: LD_STRING GlebLoc
 432: PPUSH
 433: LD_INT 0
 435: PPUSH
 436: CALL_OW 30
 440: PUSH
 441: LD_INT 14
 443: EQUAL
 444: IFFALSE 459
// Gleb = load_char ( Gleb ) ;
 446: LD_ADDR_EXP 15
 450: PUSH
 451: LD_STRING Gleb
 453: PPUSH
 454: CALL 0 0 1
 458: ST_TO_ADDR
// if LoadVariable ( BelkovLoc , 0 ) = 14 then
 459: LD_STRING BelkovLoc
 461: PPUSH
 462: LD_INT 0
 464: PPUSH
 465: CALL_OW 30
 469: PUSH
 470: LD_INT 14
 472: EQUAL
 473: IFFALSE 488
// Belkov = load_char ( Belkov ) ;
 475: LD_ADDR_EXP 7
 479: PUSH
 480: LD_STRING Belkov
 482: PPUSH
 483: CALL 0 0 1
 487: ST_TO_ADDR
// if LoadVariable ( GnyevkoLoc , 0 ) = 14 then
 488: LD_STRING GnyevkoLoc
 490: PPUSH
 491: LD_INT 0
 493: PPUSH
 494: CALL_OW 30
 498: PUSH
 499: LD_INT 14
 501: EQUAL
 502: IFFALSE 517
// Gnyevko = load_char ( Gnyevko ) ;
 504: LD_ADDR_EXP 8
 508: PUSH
 509: LD_STRING Gnyevko
 511: PPUSH
 512: CALL 0 0 1
 516: ST_TO_ADDR
// if LoadVariable ( KirilenkovaLoc , 0 ) = 14 then
 517: LD_STRING KirilenkovaLoc
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL_OW 30
 527: PUSH
 528: LD_INT 14
 530: EQUAL
 531: IFFALSE 546
// Kirilenkova = load_char ( Kirilenkova ) ;
 533: LD_ADDR_EXP 9
 537: PUSH
 538: LD_STRING Kirilenkova
 540: PPUSH
 541: CALL 0 0 1
 545: ST_TO_ADDR
// if LoadVariable ( KovalyukLoc , 0 ) = 14 then
 546: LD_STRING KovalyukLoc
 548: PPUSH
 549: LD_INT 0
 551: PPUSH
 552: CALL_OW 30
 556: PUSH
 557: LD_INT 14
 559: EQUAL
 560: IFFALSE 575
// Kovalyuk = load_char ( Kovalyuk ) ;
 562: LD_ADDR_EXP 10
 566: PUSH
 567: LD_STRING Kovalyuk
 569: PPUSH
 570: CALL 0 0 1
 574: ST_TO_ADDR
// if LoadVariable ( ScholtzeLoc , 0 ) = 14 then
 575: LD_STRING ScholtzeLoc
 577: PPUSH
 578: LD_INT 0
 580: PPUSH
 581: CALL_OW 30
 585: PUSH
 586: LD_INT 14
 588: EQUAL
 589: IFFALSE 604
// Scholtze = load_char ( Scholtze ) ;
 591: LD_ADDR_EXP 11
 595: PUSH
 596: LD_STRING Scholtze
 598: PPUSH
 599: CALL 0 0 1
 603: ST_TO_ADDR
// if LoadVariable ( KuzmovLoc , 0 ) = 14 then
 604: LD_STRING KuzmovLoc
 606: PPUSH
 607: LD_INT 0
 609: PPUSH
 610: CALL_OW 30
 614: PUSH
 615: LD_INT 14
 617: EQUAL
 618: IFFALSE 633
// Kuzmov = load_char ( Kuzmov ) ;
 620: LD_ADDR_EXP 12
 624: PUSH
 625: LD_STRING Kuzmov
 627: PPUSH
 628: CALL 0 0 1
 632: ST_TO_ADDR
// if LoadVariable ( KaramazovLoc , 0 ) = 14 then
 633: LD_STRING KaramazovLoc
 635: PPUSH
 636: LD_INT 0
 638: PPUSH
 639: CALL_OW 30
 643: PUSH
 644: LD_INT 14
 646: EQUAL
 647: IFFALSE 662
// Karamazov = load_char ( Karamazov ) ;
 649: LD_ADDR_EXP 13
 653: PUSH
 654: LD_STRING Karamazov
 656: PPUSH
 657: CALL 0 0 1
 661: ST_TO_ADDR
// if LoadVariable ( PetrovovaLoc , 0 ) = 14 then
 662: LD_STRING PetrovovaLoc
 664: PPUSH
 665: LD_INT 0
 667: PPUSH
 668: CALL_OW 30
 672: PUSH
 673: LD_INT 14
 675: EQUAL
 676: IFFALSE 691
// Petrovova = load_char ( Petrovova ) ;
 678: LD_ADDR_EXP 14
 682: PUSH
 683: LD_STRING Petrovova
 685: PPUSH
 686: CALL 0 0 1
 690: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 691: LD_STRING GlebLoc
 693: PPUSH
 694: LD_INT 0
 696: PPUSH
 697: CALL_OW 30
 701: PUSH
 702: LD_INT 14
 704: EQUAL
 705: IFFALSE 720
// Gleb = load_char ( Gleb ) ;
 707: LD_ADDR_EXP 15
 711: PUSH
 712: LD_STRING Gleb
 714: PPUSH
 715: CALL 0 0 1
 719: ST_TO_ADDR
// if LoadVariable ( PetrosyanLoc , 0 ) = 14 then
 720: LD_STRING PetrosyanLoc
 722: PPUSH
 723: LD_INT 0
 725: PPUSH
 726: CALL_OW 30
 730: PUSH
 731: LD_INT 14
 733: EQUAL
 734: IFFALSE 749
// Petrosyan = load_char ( Petrosyan ) ;
 736: LD_ADDR_EXP 16
 740: PUSH
 741: LD_STRING Petrosyan
 743: PPUSH
 744: CALL 0 0 1
 748: ST_TO_ADDR
// if LoadVariable ( LipshchinLoc , 0 ) = 14 then
 749: LD_STRING LipshchinLoc
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 30
 759: PUSH
 760: LD_INT 14
 762: EQUAL
 763: IFFALSE 778
// Lipshchin = load_char ( Lipshchin ) ;
 765: LD_ADDR_EXP 17
 769: PUSH
 770: LD_STRING Lipshchin
 772: PPUSH
 773: CALL 0 0 1
 777: ST_TO_ADDR
// if LoadVariable ( TitovLoc , 0 ) = 14 then
 778: LD_STRING TitovLoc
 780: PPUSH
 781: LD_INT 0
 783: PPUSH
 784: CALL_OW 30
 788: PUSH
 789: LD_INT 14
 791: EQUAL
 792: IFFALSE 807
// Titov = load_char ( Titov ) ;
 794: LD_ADDR_EXP 18
 798: PUSH
 799: LD_STRING Titov
 801: PPUSH
 802: CALL 0 0 1
 806: ST_TO_ADDR
// if LoadVariable ( DolgovLoc , 0 ) = 14 then
 807: LD_STRING DolgovLoc
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: CALL_OW 30
 817: PUSH
 818: LD_INT 14
 820: EQUAL
 821: IFFALSE 836
// Dolgov = load_char ( Dolgov ) ;
 823: LD_ADDR_EXP 19
 827: PUSH
 828: LD_STRING Dolgov
 830: PPUSH
 831: CALL 0 0 1
 835: ST_TO_ADDR
// if LoadVariable ( XavierLoc , 0 ) = 14 then
 836: LD_STRING XavierLoc
 838: PPUSH
 839: LD_INT 0
 841: PPUSH
 842: CALL_OW 30
 846: PUSH
 847: LD_INT 14
 849: EQUAL
 850: IFFALSE 865
// Xavier = load_char ( Xavier ) ;
 852: LD_ADDR_EXP 20
 856: PUSH
 857: LD_STRING Xavier
 859: PPUSH
 860: CALL 0 0 1
 864: ST_TO_ADDR
// if LoadVariable ( OblukovLoc , 0 ) = 14 then
 865: LD_STRING OblukovLoc
 867: PPUSH
 868: LD_INT 0
 870: PPUSH
 871: CALL_OW 30
 875: PUSH
 876: LD_INT 14
 878: EQUAL
 879: IFFALSE 894
// Oblukov = load_char ( Oblukov ) ;
 881: LD_ADDR_EXP 21
 885: PUSH
 886: LD_STRING Oblukov
 888: PPUSH
 889: CALL 0 0 1
 893: ST_TO_ADDR
// if LoadVariable ( KozlovLoc , 0 ) = 14 then
 894: LD_STRING KozlovLoc
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL_OW 30
 904: PUSH
 905: LD_INT 14
 907: EQUAL
 908: IFFALSE 923
// Kozlov = load_char ( Kozlov ) ;
 910: LD_ADDR_EXP 22
 914: PUSH
 915: LD_STRING Kozlov
 917: PPUSH
 918: CALL 0 0 1
 922: ST_TO_ADDR
// if LoadVariable ( KapitsovaLoc , 0 ) = 14 then
 923: LD_STRING KapitsovaLoc
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: PUSH
 934: LD_INT 14
 936: EQUAL
 937: IFFALSE 952
// Kapitsova = load_char ( Kapitsova ) ;
 939: LD_ADDR_EXP 23
 943: PUSH
 944: LD_STRING Kapitsova
 946: PPUSH
 947: CALL 0 0 1
 951: ST_TO_ADDR
// Ostatni = load_set ( Others_Ru14 ) ;
 952: LD_ADDR_EXP 24
 956: PUSH
 957: LD_STRING Others_Ru14
 959: PPUSH
 960: CALL 51 0 1
 964: ST_TO_ADDR
// DeleteCharacters ( Others_Ru14 ) ;
 965: LD_STRING Others_Ru14
 967: PPUSH
 968: CALL_OW 40
// MashaSpec = LoadVariable ( Masha , [ ] ) ;
 972: LD_ADDR_VAR 0 2
 976: PUSH
 977: LD_STRING Masha
 979: PPUSH
 980: EMPTY
 981: PPUSH
 982: CALL_OW 30
 986: ST_TO_ADDR
// if MashaSpec = 0 then
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 0
 994: EQUAL
 995: IFFALSE 1007
// Masha = 0 else
 997: LD_ADDR_EXP 25
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
1005: GO 1153
// begin UC_Nation = NATION_RUSSIAN ;
1007: LD_ADDR_OWVAR 21
1011: PUSH
1012: LD_INT 3
1014: ST_TO_ADDR
// UC_Side = side_Ru ;
1015: LD_ADDR_OWVAR 20
1019: PUSH
1020: LD_EXP 2
1024: ST_TO_ADDR
// VC_Chassis = MashaSpec [ 1 ] ;
1025: LD_ADDR_OWVAR 37
1029: PUSH
1030: LD_VAR 0 2
1034: PUSH
1035: LD_INT 1
1037: ARRAY
1038: ST_TO_ADDR
// VC_Engine = MashaSpec [ 2 ] ;
1039: LD_ADDR_OWVAR 39
1043: PUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: ST_TO_ADDR
// VC_Control = MashaSpec [ 3 ] ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_VAR 0 2
1062: PUSH
1063: LD_INT 3
1065: ARRAY
1066: ST_TO_ADDR
// VC_Weapon = MashaSpec [ 4 ] ;
1067: LD_ADDR_OWVAR 40
1071: PUSH
1072: LD_VAR 0 2
1076: PUSH
1077: LD_INT 4
1079: ARRAY
1080: ST_TO_ADDR
// if ( VC_Weapon = 0 ) or ( VC_Control = 0 ) or ( VC_Engine = 0 ) or ( VC_Chassis = 0 ) then
1081: LD_OWVAR 40
1085: PUSH
1086: LD_INT 0
1088: EQUAL
1089: PUSH
1090: LD_OWVAR 38
1094: PUSH
1095: LD_INT 0
1097: EQUAL
1098: OR
1099: PUSH
1100: LD_OWVAR 39
1104: PUSH
1105: LD_INT 0
1107: EQUAL
1108: OR
1109: PUSH
1110: LD_OWVAR 37
1114: PUSH
1115: LD_INT 0
1117: EQUAL
1118: OR
1119: IFFALSE 1131
// Masha = 0 else
1121: LD_ADDR_EXP 25
1125: PUSH
1126: LD_INT 0
1128: ST_TO_ADDR
1129: GO 1153
// begin Masha = CreateVehicle ;
1131: LD_ADDR_EXP 25
1135: PUSH
1136: CALL_OW 45
1140: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
1141: LD_EXP 25
1145: PPUSH
1146: LD_INT 1
1148: PPUSH
1149: CALL_OW 242
// end ; end ; Rusove = ( [ Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Ostatni ) diff [ 0 ] ;
1153: LD_ADDR_EXP 39
1157: PUSH
1158: LD_EXP 15
1162: PUSH
1163: LD_EXP 7
1167: PUSH
1168: LD_EXP 8
1172: PUSH
1173: LD_EXP 9
1177: PUSH
1178: LD_EXP 10
1182: PUSH
1183: LD_EXP 11
1187: PUSH
1188: LD_EXP 12
1192: PUSH
1193: LD_EXP 13
1197: PUSH
1198: LD_EXP 14
1202: PUSH
1203: LD_EXP 15
1207: PUSH
1208: LD_EXP 16
1212: PUSH
1213: LD_EXP 17
1217: PUSH
1218: LD_EXP 18
1222: PUSH
1223: LD_EXP 19
1227: PUSH
1228: LD_EXP 20
1232: PUSH
1233: LD_EXP 21
1237: PUSH
1238: LD_EXP 22
1242: PUSH
1243: LD_EXP 23
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: PUSH
1268: LD_EXP 24
1272: UNION
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: EMPTY
1278: LIST
1279: DIFF
1280: ST_TO_ADDR
// Rusove2 = [ ] ;
1281: LD_ADDR_EXP 40
1285: PUSH
1286: EMPTY
1287: ST_TO_ADDR
// SetSide ( [ Burlak ] , side_Ru ) ;
1288: LD_EXP 6
1292: PUSH
1293: EMPTY
1294: LIST
1295: PPUSH
1296: LD_EXP 2
1300: PPUSH
1301: CALL_OW 235
// SetSide ( Rusove , side_Ru ) ;
1305: LD_EXP 39
1309: PPUSH
1310: LD_EXP 2
1314: PPUSH
1315: CALL_OW 235
// end ;
1319: LD_VAR 0 1
1323: RET
// function save_char ( Handle , Ident ) ; begin
1324: LD_INT 0
1326: PPUSH
// if Handle then
1327: LD_VAR 0 1
1331: IFFALSE 1350
// SaveCharacters ( [ Handle ] , Ident ) ;
1333: LD_VAR 0 1
1337: PUSH
1338: EMPTY
1339: LIST
1340: PPUSH
1341: LD_VAR 0 2
1345: PPUSH
1346: CALL_OW 38
// end ;
1350: LD_VAR 0 3
1354: RET
// function save ; var MashaSpec , Survivors4 , O , Opice ; begin
1355: LD_INT 0
1357: PPUSH
1358: PPUSH
1359: PPUSH
1360: PPUSH
1361: PPUSH
// SaveVariable ( LegieZnicena , LegionDestroyed ) ;
1362: LD_EXP 67
1366: PPUSH
1367: LD_STRING LegionDestroyed
1369: PPUSH
1370: CALL_OW 39
// if Masha and IsOk ( Masha ) and ( GetSide ( Masha ) = side_Ru ) then
1374: LD_EXP 25
1378: PUSH
1379: LD_EXP 25
1383: PPUSH
1384: CALL_OW 302
1388: AND
1389: PUSH
1390: LD_EXP 25
1394: PPUSH
1395: CALL_OW 255
1399: PUSH
1400: LD_EXP 2
1404: EQUAL
1405: AND
1406: IFFALSE 1410
// begin end else
1408: GO 1417
// DeleteVariable ( Masha ) ;
1410: LD_STRING Masha
1412: PPUSH
1413: CALL_OW 41
// save_char ( Burlak , Burlak ) ;
1417: LD_EXP 6
1421: PPUSH
1422: LD_STRING Burlak
1424: PPUSH
1425: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1429: LD_EXP 15
1433: PPUSH
1434: LD_STRING Gleb
1436: PPUSH
1437: CALL 1324 0 2
// save_char ( Belkov , Belkov ) ;
1441: LD_EXP 7
1445: PPUSH
1446: LD_STRING Belkov
1448: PPUSH
1449: CALL 1324 0 2
// save_char ( Gnyevko , Gnyevko ) ;
1453: LD_EXP 8
1457: PPUSH
1458: LD_STRING Gnyevko
1460: PPUSH
1461: CALL 1324 0 2
// save_char ( Kirilenkova , Kirilenkova ) ;
1465: LD_EXP 9
1469: PPUSH
1470: LD_STRING Kirilenkova
1472: PPUSH
1473: CALL 1324 0 2
// save_char ( Kovalyuk , Kovalyuk ) ;
1477: LD_EXP 10
1481: PPUSH
1482: LD_STRING Kovalyuk
1484: PPUSH
1485: CALL 1324 0 2
// save_char ( Scholtze , Scholtze ) ;
1489: LD_EXP 11
1493: PPUSH
1494: LD_STRING Scholtze
1496: PPUSH
1497: CALL 1324 0 2
// save_char ( Kuzmov , Kuzmov ) ;
1501: LD_EXP 12
1505: PPUSH
1506: LD_STRING Kuzmov
1508: PPUSH
1509: CALL 1324 0 2
// save_char ( Karamazov , Karamazov ) ;
1513: LD_EXP 13
1517: PPUSH
1518: LD_STRING Karamazov
1520: PPUSH
1521: CALL 1324 0 2
// save_char ( Petrovova , Petrovova ) ;
1525: LD_EXP 14
1529: PPUSH
1530: LD_STRING Petrovova
1532: PPUSH
1533: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1537: LD_EXP 15
1541: PPUSH
1542: LD_STRING Gleb
1544: PPUSH
1545: CALL 1324 0 2
// save_char ( Petrosyan , Petrosyan ) ;
1549: LD_EXP 16
1553: PPUSH
1554: LD_STRING Petrosyan
1556: PPUSH
1557: CALL 1324 0 2
// save_char ( Lipshchin , Lipshchin ) ;
1561: LD_EXP 17
1565: PPUSH
1566: LD_STRING Lipshchin
1568: PPUSH
1569: CALL 1324 0 2
// save_char ( Titov , Titov ) ;
1573: LD_EXP 18
1577: PPUSH
1578: LD_STRING Titov
1580: PPUSH
1581: CALL 1324 0 2
// save_char ( Dolgov , Dolgov ) ;
1585: LD_EXP 19
1589: PPUSH
1590: LD_STRING Dolgov
1592: PPUSH
1593: CALL 1324 0 2
// save_char ( Xavier , Xavier ) ;
1597: LD_EXP 20
1601: PPUSH
1602: LD_STRING Xavier
1604: PPUSH
1605: CALL 1324 0 2
// save_char ( Oblukov , Oblukov ) ;
1609: LD_EXP 21
1613: PPUSH
1614: LD_STRING Oblukov
1616: PPUSH
1617: CALL 1324 0 2
// save_char ( Kozlov , Kozlov ) ;
1621: LD_EXP 22
1625: PPUSH
1626: LD_STRING Kozlov
1628: PPUSH
1629: CALL 1324 0 2
// save_char ( Kapitsova , Kapitsova ) ;
1633: LD_EXP 23
1637: PPUSH
1638: LD_STRING Kapitsova
1640: PPUSH
1641: CALL 1324 0 2
// save_char ( Abdul , Abdul ) ;
1645: LD_EXP 31
1649: PPUSH
1650: LD_STRING Abdul
1652: PPUSH
1653: CALL 1324 0 2
// save_char ( Farmer , Farmer ) ;
1657: LD_EXP 29
1661: PPUSH
1662: LD_STRING Farmer
1664: PPUSH
1665: CALL 1324 0 2
// save_char ( Heike , Heike ) ;
1669: LD_EXP 28
1673: PPUSH
1674: LD_STRING Heike
1676: PPUSH
1677: CALL 1324 0 2
// Survivors4 = load_set ( Survivors4 ) ;
1681: LD_ADDR_VAR 0 3
1685: PUSH
1686: LD_STRING Survivors4
1688: PPUSH
1689: CALL 51 0 1
1693: ST_TO_ADDR
// O = Rusove diff [ 0 , Burlak , Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_EXP 39
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_EXP 6
1711: PUSH
1712: LD_EXP 15
1716: PUSH
1717: LD_EXP 7
1721: PUSH
1722: LD_EXP 8
1726: PUSH
1727: LD_EXP 9
1731: PUSH
1732: LD_EXP 10
1736: PUSH
1737: LD_EXP 11
1741: PUSH
1742: LD_EXP 12
1746: PUSH
1747: LD_EXP 13
1751: PUSH
1752: LD_EXP 14
1756: PUSH
1757: LD_EXP 15
1761: PUSH
1762: LD_EXP 16
1766: PUSH
1767: LD_EXP 17
1771: PUSH
1772: LD_EXP 18
1776: PUSH
1777: LD_EXP 19
1781: PUSH
1782: LD_EXP 20
1786: PUSH
1787: LD_EXP 21
1791: PUSH
1792: LD_EXP 22
1796: PUSH
1797: LD_EXP 23
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: DIFF
1824: ST_TO_ADDR
// Opice = UnitFilter ( Rusove , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
1825: LD_ADDR_VAR 0 5
1829: PUSH
1830: LD_EXP 39
1834: PPUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 25
1840: PUSH
1841: LD_INT 12
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 25
1850: PUSH
1851: LD_INT 15
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 16
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 25
1870: PUSH
1871: LD_INT 17
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: EMPTY
1886: LIST
1887: PPUSH
1888: CALL_OW 72
1892: ST_TO_ADDR
// O = O diff Opice ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_VAR 0 5
1907: DIFF
1908: ST_TO_ADDR
// SaveCharacters ( O union Survivors4 , Survivors4 ) ;
1909: LD_VAR 0 4
1913: PUSH
1914: LD_VAR 0 3
1918: UNION
1919: PPUSH
1920: LD_STRING Survivors4
1922: PPUSH
1923: CALL_OW 38
// end ;
1927: LD_VAR 0 1
1931: RET
// function dej_medaile ; begin
1932: LD_INT 0
1934: PPUSH
// SA_EndMission ( 3 , 14 , not RusMaOtraveno , BehemothBuilt > 0 , MenLost <= 2 ) ;
1935: LD_INT 3
1937: PPUSH
1938: LD_INT 14
1940: PPUSH
1941: LD_EXP 64
1945: NOT
1946: PPUSH
1947: LD_EXP 68
1951: PUSH
1952: LD_INT 0
1954: GREATER
1955: PPUSH
1956: LD_EXP 69
1960: PUSH
1961: LD_INT 2
1963: LESSEQUAL
1964: PPUSH
1965: CALL 22778 0 5
// if not RusMaOtraveno then
1969: LD_EXP 64
1973: NOT
1974: IFFALSE 1988
// AddMedal ( Siberite , 1 ) else
1976: LD_STRING Siberite
1978: PPUSH
1979: LD_INT 1
1981: PPUSH
1982: CALL_OW 101
1986: GO 2018
// if RusMaSiberit then
1988: LD_EXP 63
1992: IFFALSE 2007
// AddMedal ( Siberite , - 1 ) else
1994: LD_STRING Siberite
1996: PPUSH
1997: LD_INT 1
1999: NEG
2000: PPUSH
2001: CALL_OW 101
2005: GO 2018
// AddMedal ( Siberite , - 2 ) ;
2007: LD_STRING Siberite
2009: PPUSH
2010: LD_INT 2
2012: NEG
2013: PPUSH
2014: CALL_OW 101
// if BehemothBuilt then
2018: LD_EXP 68
2022: IFFALSE 2036
// AddMedal ( Behemoth , 1 ) else
2024: LD_STRING Behemoth
2026: PPUSH
2027: LD_INT 1
2029: PPUSH
2030: CALL_OW 101
2034: GO 2047
// AddMedal ( Behemoth , - 1 ) ;
2036: LD_STRING Behemoth
2038: PPUSH
2039: LD_INT 1
2041: NEG
2042: PPUSH
2043: CALL_OW 101
// if MenLost <= 2 then
2047: LD_EXP 69
2051: PUSH
2052: LD_INT 2
2054: LESSEQUAL
2055: IFFALSE 2069
// AddMedal ( LittleLosses , 1 ) else
2057: LD_STRING LittleLosses
2059: PPUSH
2060: LD_INT 1
2062: PPUSH
2063: CALL_OW 101
2067: GO 2080
// AddMedal ( LittleLosses , - 1 ) ;
2069: LD_STRING LittleLosses
2071: PPUSH
2072: LD_INT 1
2074: NEG
2075: PPUSH
2076: CALL_OW 101
// end ;
2080: LD_VAR 0 1
2084: RET
// export function vyhral ; var Lidi , Opice ; begin
2085: LD_INT 0
2087: PPUSH
2088: PPUSH
2089: PPUSH
// dej_medaile ;
2090: CALL 1932 0 0
// GiveMedals ( Main ) ;
2094: LD_STRING Main
2096: PPUSH
2097: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2101: LD_ADDR_VAR 0 2
2105: PUSH
2106: LD_INT 22
2108: PUSH
2109: LD_EXP 2
2113: PUSH
2114: EMPTY
2115: LIST
2116: LIST
2117: PUSH
2118: LD_INT 21
2120: PUSH
2121: LD_INT 1
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: PUSH
2128: LD_INT 51
2130: PUSH
2131: EMPTY
2132: LIST
2133: PUSH
2134: EMPTY
2135: LIST
2136: LIST
2137: LIST
2138: PPUSH
2139: CALL_OW 69
2143: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2144: LD_ADDR_VAR 0 3
2148: PUSH
2149: LD_VAR 0 2
2153: PPUSH
2154: LD_INT 2
2156: PUSH
2157: LD_INT 25
2159: PUSH
2160: LD_INT 12
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: PUSH
2167: LD_INT 25
2169: PUSH
2170: LD_INT 15
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PUSH
2177: LD_INT 25
2179: PUSH
2180: LD_INT 16
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 25
2189: PUSH
2190: LD_INT 17
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: LIST
2202: LIST
2203: PUSH
2204: EMPTY
2205: LIST
2206: PPUSH
2207: CALL_OW 72
2211: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
2212: LD_VAR 0 2
2216: PUSH
2217: LD_VAR 0 3
2221: DIFF
2222: PPUSH
2223: CALL_OW 43
// save ;
2227: CALL 1355 0 0
// YouWin ;
2231: CALL_OW 103
// end ;
2235: LD_VAR 0 1
2239: RET
// function set_attitudes ; begin
2240: LD_INT 0
2242: PPUSH
// SetAttitude ( side_Ru , side_Upr , ATT_NEUTRAL , true ) ;
2243: LD_EXP 2
2247: PPUSH
2248: LD_EXP 5
2252: PPUSH
2253: LD_INT 0
2255: PPUSH
2256: LD_INT 1
2258: PPUSH
2259: CALL_OW 80
// SetAttitude ( side_Le , side_Upr , ATT_FRIEND , true ) ;
2263: LD_EXP 4
2267: PPUSH
2268: LD_EXP 5
2272: PPUSH
2273: LD_INT 1
2275: PPUSH
2276: LD_INT 1
2278: PPUSH
2279: CALL_OW 80
// SetAttitude ( side_Ar , side_Upr , ATT_FRIEND , true ) ;
2283: LD_EXP 3
2287: PPUSH
2288: LD_EXP 5
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_INT 1
2298: PPUSH
2299: CALL_OW 80
// SetAttitude ( side_Le , side_Ar , ATT_FRIEND , true ) ;
2303: LD_EXP 4
2307: PPUSH
2308: LD_EXP 3
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 1
2318: PPUSH
2319: CALL_OW 80
// end ;
2323: LD_VAR 0 1
2327: RET
// starting begin RandomizeAll ;
2328: CALL_OW 11
// InitUC ;
2332: CALL_OW 18
// InitBC ;
2336: CALL_OW 21
// InitVC ;
2340: CALL_OW 20
// InitHC ;
2344: CALL_OW 19
// side_Neutral = 0 ;
2348: LD_ADDR_EXP 1
2352: PUSH
2353: LD_INT 0
2355: ST_TO_ADDR
// side_Ru = 3 ;
2356: LD_ADDR_EXP 2
2360: PUSH
2361: LD_INT 3
2363: ST_TO_ADDR
// side_Ar = 2 ;
2364: LD_ADDR_EXP 3
2368: PUSH
2369: LD_INT 2
2371: ST_TO_ADDR
// side_Upr = 7 ;
2372: LD_ADDR_EXP 5
2376: PUSH
2377: LD_INT 7
2379: ST_TO_ADDR
// side_Le = 8 ;
2380: LD_ADDR_EXP 4
2384: PUSH
2385: LD_INT 8
2387: ST_TO_ADDR
// set_attitudes ;
2388: CALL 2240 0 0
// load ;
2392: CALL 161 0 0
// init_difficulty ;
2396: CALL 2425 0 0
// init_nature ;
2400: CALL 3048 0 0
// init_suroviny ;
2404: CALL 3125 0 0
// init_legion ;
2408: CALL 6129 0 0
// init_arabi ;
2412: CALL 11573 0 0
// init_rusove ;
2416: CALL 19060 0 0
// uvod ;
2420: CALL 19127 0 0
// end ; end_of_file
2424: END
// export dif_CekaniBednyRus , dif_PoctyBednyRus ; export dif_PoctyBednyStart , dif_PoctyBednyExtra ; export dif_LegionRidici , dif_AraboveRidici ; export dif_UtokSkupina , dif_CasovacUtoku , dif_PrvniUtok ; export dif_PstZbrane ; export dif_MaxOpice , dif_ZpozdeniOpice , dif_PstOpiceRus ; export dif_OpiceLimit , dif_OpiceNajednouPocet ; export dif_ArabiLidiVzdajSe ; export dif_LegionTimeout ; export function init_difficulty ; begin
2425: LD_INT 0
2427: PPUSH
// dif_CekaniBednyRus = [ [ 0 0$1 , 0 0$25 ] , [ 0 0$30 , 1 1$05 ] , [ 0 0$50 , 1 1$15 ] ] ;
2428: LD_ADDR_EXP 41
2432: PUSH
2433: LD_INT 35
2435: PUSH
2436: LD_INT 875
2438: PUSH
2439: EMPTY
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 1050
2445: PUSH
2446: LD_INT 2275
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 1750
2455: PUSH
2456: LD_INT 2625
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: LIST
2467: ST_TO_ADDR
// dif_PoctyBednyRus = [ [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 5 ] ] ;
2468: LD_ADDR_EXP 42
2472: PUSH
2473: LD_INT 5
2475: PUSH
2476: LD_INT 5
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PUSH
2483: LD_INT 4
2485: PUSH
2486: LD_INT 5
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: PUSH
2493: LD_INT 3
2495: PUSH
2496: LD_INT 5
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: LIST
2507: ST_TO_ADDR
// dif_PoctyBednyStart = [ 5 , 3 , 1 ] ;
2508: LD_ADDR_EXP 43
2512: PUSH
2513: LD_INT 5
2515: PUSH
2516: LD_INT 3
2518: PUSH
2519: LD_INT 1
2521: PUSH
2522: EMPTY
2523: LIST
2524: LIST
2525: LIST
2526: ST_TO_ADDR
// dif_PoctyBednyExtra = [ 10 , 5 , 0 ] ;
2527: LD_ADDR_EXP 44
2531: PUSH
2532: LD_INT 10
2534: PUSH
2535: LD_INT 5
2537: PUSH
2538: LD_INT 0
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: LIST
2545: ST_TO_ADDR
// dif_LegionRidici = [ 2 , 3 , 4 ] ;
2546: LD_ADDR_EXP 45
2550: PUSH
2551: LD_INT 2
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_INT 4
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: LIST
2564: ST_TO_ADDR
// dif_AraboveRidici = [ 3 , 5 , 7 ] ;
2565: LD_ADDR_EXP 46
2569: PUSH
2570: LD_INT 3
2572: PUSH
2573: LD_INT 5
2575: PUSH
2576: LD_INT 7
2578: PUSH
2579: EMPTY
2580: LIST
2581: LIST
2582: LIST
2583: ST_TO_ADDR
// dif_PrvniUtok = [ [ 6 , 10 ] , [ 4 , 6 ] , [ 4 , 6 ] ] ;
2584: LD_ADDR_EXP 49
2588: PUSH
2589: LD_INT 6
2591: PUSH
2592: LD_INT 10
2594: PUSH
2595: EMPTY
2596: LIST
2597: LIST
2598: PUSH
2599: LD_INT 4
2601: PUSH
2602: LD_INT 6
2604: PUSH
2605: EMPTY
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 4
2611: PUSH
2612: LD_INT 6
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: ST_TO_ADDR
// dif_CasovacUtoku = [ [ 2 , 5 , 6 ] , [ 2 , 4 ] , [ 2 , 3 ] ] ;
2624: LD_ADDR_EXP 48
2628: PUSH
2629: LD_INT 2
2631: PUSH
2632: LD_INT 5
2634: PUSH
2635: LD_INT 6
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: LIST
2642: PUSH
2643: LD_INT 2
2645: PUSH
2646: LD_INT 4
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: PUSH
2653: LD_INT 2
2655: PUSH
2656: LD_INT 3
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: ST_TO_ADDR
// dif_UtokSkupina = [ 4 , 6 , 8 ] ;
2668: LD_ADDR_EXP 47
2672: PUSH
2673: LD_INT 4
2675: PUSH
2676: LD_INT 6
2678: PUSH
2679: LD_INT 8
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: LIST
2686: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 25 , 50 , 75 , 100 ] , [ 30 , 60 , 55 , 100 ] ] ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_INT 20
2694: PUSH
2695: LD_INT 40
2697: PUSH
2698: LD_INT 80
2700: PUSH
2701: LD_INT 100
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: LIST
2708: LIST
2709: PUSH
2710: LD_INT 25
2712: PUSH
2713: LD_INT 50
2715: PUSH
2716: LD_INT 75
2718: PUSH
2719: LD_INT 100
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: LIST
2727: PUSH
2728: LD_INT 30
2730: PUSH
2731: LD_INT 60
2733: PUSH
2734: LD_INT 55
2736: PUSH
2737: LD_INT 100
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: ST_TO_ADDR
// dif_MaxOpice = [ 5 , 8 , 11 ] ;
2751: LD_ADDR_EXP 51
2755: PUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 8
2761: PUSH
2762: LD_INT 11
2764: PUSH
2765: EMPTY
2766: LIST
2767: LIST
2768: LIST
2769: ST_TO_ADDR
// dif_ZpozdeniOpice = [ [ 2 2$0 , 3 3$4 ] , [ 1 1$0 , 2 2$0 ] , [ 0 , 1 1$0 ] ] ;
2770: LD_ADDR_EXP 52
2774: PUSH
2775: LD_INT 4200
2777: PUSH
2778: LD_INT 6440
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 2100
2787: PUSH
2788: LD_INT 4200
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: LD_INT 0
2797: PUSH
2798: LD_INT 2100
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: ST_TO_ADDR
// dif_PstOpiceRus = [ 60 , 40 , 15 ] ;
2810: LD_ADDR_EXP 53
2814: PUSH
2815: LD_INT 60
2817: PUSH
2818: LD_INT 40
2820: PUSH
2821: LD_INT 15
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: ST_TO_ADDR
// dif_OpiceLimit = [ 10 , 25 , - 1 ] ;
2829: LD_ADDR_EXP 54
2833: PUSH
2834: LD_INT 10
2836: PUSH
2837: LD_INT 25
2839: PUSH
2840: LD_INT 1
2842: NEG
2843: PUSH
2844: EMPTY
2845: LIST
2846: LIST
2847: LIST
2848: ST_TO_ADDR
// dif_OpiceNajednouPocet = [ 1 , 2 , 4 ] ;
2849: LD_ADDR_EXP 55
2853: PUSH
2854: LD_INT 1
2856: PUSH
2857: LD_INT 2
2859: PUSH
2860: LD_INT 4
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: LIST
2867: ST_TO_ADDR
// dif_ArabiLidiVzdajSe = [ 6 , 4 , 2 ] ;
2868: LD_ADDR_EXP 56
2872: PUSH
2873: LD_INT 6
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 2
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: LIST
2886: ST_TO_ADDR
// dif_LegionTimeout = [ 30 30$0 , 25 25$0 , 15 15$0 ] ;
2887: LD_ADDR_EXP 57
2891: PUSH
2892: LD_INT 63000
2894: PUSH
2895: LD_INT 52500
2897: PUSH
2898: LD_INT 31500
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: LIST
2905: ST_TO_ADDR
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
// Result = [ ] ;
2916: LD_ADDR_VAR 0 4
2920: PUSH
2921: EMPTY
2922: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
2923: LD_ADDR_OWVAR 21
2927: PUSH
2928: LD_INT 0
2930: ST_TO_ADDR
// UC_side = side_neutral ;
2931: LD_ADDR_OWVAR 20
2935: PUSH
2936: LD_EXP 1
2940: ST_TO_ADDR
// HC_Class = Cls ;
2941: LD_ADDR_OWVAR 28
2945: PUSH
2946: LD_VAR 0 1
2950: ST_TO_ADDR
// HC_Name =  ;
2951: LD_ADDR_OWVAR 26
2955: PUSH
2956: LD_STRING 
2958: ST_TO_ADDR
// hc_agressivity = rand ( 0 , 20 ) ;
2959: LD_ADDR_OWVAR 35
2963: PUSH
2964: LD_INT 0
2966: PPUSH
2967: LD_INT 20
2969: PPUSH
2970: CALL_OW 12
2974: ST_TO_ADDR
// for i = 1 to Cnt do
2975: LD_ADDR_VAR 0 5
2979: PUSH
2980: DOUBLE
2981: LD_INT 1
2983: DEC
2984: ST_TO_ADDR
2985: LD_VAR 0 2
2989: PUSH
2990: FOR_TO
2991: IFFALSE 3041
// begin h = CreateHuman ;
2993: LD_ADDR_VAR 0 6
2997: PUSH
2998: CALL_OW 44
3002: ST_TO_ADDR
// Result = Result union [ h ] ;
3003: LD_ADDR_VAR 0 4
3007: PUSH
3008: LD_VAR 0 4
3012: PUSH
3013: LD_VAR 0 6
3017: PUSH
3018: EMPTY
3019: LIST
3020: UNION
3021: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
3022: LD_VAR 0 6
3026: PPUSH
3027: LD_VAR 0 3
3031: PPUSH
3032: LD_INT 0
3034: PPUSH
3035: CALL_OW 49
// end ;
3039: GO 2990
3041: POP
3042: POP
// end ;
3043: LD_VAR 0 4
3047: RET
// export function init_nature ; begin
3048: LD_INT 0
3050: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 3 , 5 ) , Les ) ;
3051: LD_INT 14
3053: PPUSH
3054: LD_INT 3
3056: PPUSH
3057: LD_INT 5
3059: PPUSH
3060: CALL_OW 12
3064: PPUSH
3065: LD_INT 1
3067: PPUSH
3068: CALL 2911 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les ) ;
3072: LD_INT 12
3074: PPUSH
3075: LD_INT 5
3077: PPUSH
3078: LD_INT 7
3080: PPUSH
3081: CALL_OW 12
3085: PUSH
3086: LD_OWVAR 67
3090: MINUS
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: CALL 2911 0 3
// create_nature ( CLASS_BAGGIE , Rand ( 2 , 5 ) , Louka ) ;
3099: LD_INT 13
3101: PPUSH
3102: LD_INT 2
3104: PPUSH
3105: LD_INT 5
3107: PPUSH
3108: CALL_OW 12
3112: PPUSH
3113: LD_INT 2
3115: PPUSH
3116: CALL 2911 0 3
// end ; end_of_file
3120: LD_VAR 0 1
3124: RET
// var CekaniRus , PoctyRus , PoctyExtra , PoctyStart ; export function init_suroviny ; var I ; begin
3125: LD_INT 0
3127: PPUSH
3128: PPUSH
// CekaniRus = dif_CekaniBednyRus [ Difficulty ] ;
3129: LD_ADDR_LOC 1
3133: PUSH
3134: LD_EXP 41
3138: PUSH
3139: LD_OWVAR 67
3143: ARRAY
3144: ST_TO_ADDR
// PoctyRus = dif_PoctyBednyRus [ Difficulty ] ;
3145: LD_ADDR_LOC 2
3149: PUSH
3150: LD_EXP 42
3154: PUSH
3155: LD_OWVAR 67
3159: ARRAY
3160: ST_TO_ADDR
// PoctyExtra = dif_PoctyBednyExtra [ Difficulty ] ;
3161: LD_ADDR_LOC 3
3165: PUSH
3166: LD_EXP 44
3170: PUSH
3171: LD_OWVAR 67
3175: ARRAY
3176: ST_TO_ADDR
// PoctyStart = dif_PoctyBednyStart [ Difficulty ] ;
3177: LD_ADDR_LOC 4
3181: PUSH
3182: LD_EXP 43
3186: PUSH
3187: LD_OWVAR 67
3191: ARRAY
3192: ST_TO_ADDR
// end ;
3193: LD_VAR 0 1
3197: RET
// every 3 3$0 do
3198: GO 3200
3200: DISABLE
// begin Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3201: LD_LOC 1
3205: PUSH
3206: LD_INT 1
3208: ARRAY
3209: PPUSH
3210: LD_LOC 1
3214: PUSH
3215: LD_INT 2
3217: ARRAY
3218: PPUSH
3219: CALL_OW 12
3223: PPUSH
3224: CALL_OW 67
// CreateCratesArea ( Rand ( PoctyRus [ 1 ] , PoctyRus [ 2 ] ) , BednyRusove , true ) ;
3228: LD_LOC 2
3232: PUSH
3233: LD_INT 1
3235: ARRAY
3236: PPUSH
3237: LD_LOC 2
3241: PUSH
3242: LD_INT 2
3244: ARRAY
3245: PPUSH
3246: CALL_OW 12
3250: PPUSH
3251: LD_INT 6
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: CALL_OW 55
// enable ;
3261: ENABLE
// end ;
3262: END
// every 2 2$10 do
3263: GO 3265
3265: DISABLE
// begin if PoctyStart <= 0 then
3266: LD_LOC 4
3270: PUSH
3271: LD_INT 0
3273: LESSEQUAL
3274: IFFALSE 3278
// exit ;
3276: GO 3351
// Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3278: LD_LOC 1
3282: PUSH
3283: LD_INT 1
3285: ARRAY
3286: PPUSH
3287: LD_LOC 1
3291: PUSH
3292: LD_INT 2
3294: ARRAY
3295: PPUSH
3296: CALL_OW 12
3300: PPUSH
3301: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 3 ) , BednyStart , false ) ;
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: CALL_OW 12
3315: PPUSH
3316: LD_INT 8
3318: PPUSH
3319: LD_INT 0
3321: PPUSH
3322: CALL_OW 55
// PoctyStart = PoctyStart - 1 ;
3326: LD_ADDR_LOC 4
3330: PUSH
3331: LD_LOC 4
3335: PUSH
3336: LD_INT 1
3338: MINUS
3339: ST_TO_ADDR
// if PoctyStart > 0 then
3340: LD_LOC 4
3344: PUSH
3345: LD_INT 0
3347: GREATER
3348: IFFALSE 3351
// enable ;
3350: ENABLE
// end ;
3351: END
// every 3 3$12 + 1 1$49 do
3352: GO 3354
3354: DISABLE
// begin if PoctyExtra <= 0 then
3355: LD_LOC 3
3359: PUSH
3360: LD_INT 0
3362: LESSEQUAL
3363: IFFALSE 3367
// exit ;
3365: GO 3452
// if Prob ( 40 ) then
3367: LD_INT 40
3369: PPUSH
3370: CALL_OW 13
3374: IFFALSE 3379
// begin enable ;
3376: ENABLE
// exit ;
3377: GO 3452
// end ; Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3379: LD_LOC 1
3383: PUSH
3384: LD_INT 1
3386: ARRAY
3387: PPUSH
3388: LD_LOC 1
3392: PUSH
3393: LD_INT 2
3395: ARRAY
3396: PPUSH
3397: CALL_OW 12
3401: PPUSH
3402: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , BednyExtra , true ) ;
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 5
3411: PPUSH
3412: CALL_OW 12
3416: PPUSH
3417: LD_INT 9
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: CALL_OW 55
// PoctyExtra = PoctyExtra - 1 ;
3427: LD_ADDR_LOC 3
3431: PUSH
3432: LD_LOC 3
3436: PUSH
3437: LD_INT 1
3439: MINUS
3440: ST_TO_ADDR
// if PoctyExtra > 0 then
3441: LD_LOC 3
3445: PUSH
3446: LD_INT 0
3448: GREATER
3449: IFFALSE 3452
// enable ;
3451: ENABLE
// end ;
3452: END
// every 3 3$13.7 + 2 2$9 do var Pocet ;
3453: GO 3455
3455: DISABLE
3456: LD_INT 0
3458: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
3459: LD_INT 35
3461: PPUSH
3462: LD_INT 2100
3464: PPUSH
3465: CALL_OW 12
3469: PPUSH
3470: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 0
3481: PPUSH
3482: LD_INT 5
3484: PPUSH
3485: CALL_OW 12
3489: ST_TO_ADDR
// if Pocet > 0 then
3490: LD_VAR 0 1
3494: PUSH
3495: LD_INT 0
3497: GREATER
3498: IFFALSE 3512
// CreateCratesAnywhere ( Pocet , true ) ;
3500: LD_VAR 0 1
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 57
// enable ;
3512: ENABLE
// end ;
3513: PPOPN 1
3515: END
// every 0 0$57 do var Area , Pocet ;
3516: GO 3518
3518: DISABLE
3519: LD_INT 0
3521: PPUSH
3522: PPUSH
// begin if ArabiZniceni then
3523: LD_EXP 65
3527: IFFALSE 3546
// Wait ( Rand ( 2 2$0 , 3 3$30 ) ) else
3529: LD_INT 4200
3531: PPUSH
3532: LD_INT 7350
3534: PPUSH
3535: CALL_OW 12
3539: PPUSH
3540: CALL_OW 67
3544: GO 3567
// Wait ( Rand ( 0 0$1 , Difficulty * 1 1$0 ) ) ;
3546: LD_INT 35
3548: PPUSH
3549: LD_OWVAR 67
3553: PUSH
3554: LD_INT 2100
3556: MUL
3557: PPUSH
3558: CALL_OW 12
3562: PPUSH
3563: CALL_OW 67
// if ArabiZniceni then
3567: LD_EXP 65
3571: IFFALSE 3598
// begin Area = Arabove ;
3573: LD_ADDR_VAR 0 1
3577: PUSH
3578: LD_INT 5
3580: ST_TO_ADDR
// Pocet = [ 0 , 5 ] ;
3581: LD_ADDR_VAR 0 2
3585: PUSH
3586: LD_INT 0
3588: PUSH
3589: LD_INT 5
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: ST_TO_ADDR
// end else
3596: GO 3621
// begin Area = BednyArabove ;
3598: LD_ADDR_VAR 0 1
3602: PUSH
3603: LD_INT 7
3605: ST_TO_ADDR
// Pocet = [ 3 , 5 ] ;
3606: LD_ADDR_VAR 0 2
3610: PUSH
3611: LD_INT 3
3613: PUSH
3614: LD_INT 5
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: ST_TO_ADDR
// end ; Pocet = Rand ( Pocet [ 1 ] , Pocet [ 2 ] ) ;
3621: LD_ADDR_VAR 0 2
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 1
3633: ARRAY
3634: PPUSH
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 2
3642: ARRAY
3643: PPUSH
3644: CALL_OW 12
3648: ST_TO_ADDR
// if Pocet > 0 then
3649: LD_VAR 0 2
3653: PUSH
3654: LD_INT 0
3656: GREATER
3657: IFFALSE 3676
// CreateCratesArea ( Pocet , Area , true ) ;
3659: LD_VAR 0 2
3663: PPUSH
3664: LD_VAR 0 1
3668: PPUSH
3669: LD_INT 1
3671: PPUSH
3672: CALL_OW 55
// enable ;
3676: ENABLE
// end ; end_of_file
3677: PPOPN 2
3679: END
// function najdi_nekoho ; var Lidi ; begin
3680: LD_INT 0
3682: PPUSH
3683: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3684: LD_ADDR_VAR 0 2
3688: PUSH
3689: LD_INT 22
3691: PUSH
3692: LD_EXP 2
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: PUSH
3701: LD_INT 50
3703: PUSH
3704: EMPTY
3705: LIST
3706: PUSH
3707: LD_INT 52
3709: PUSH
3710: EMPTY
3711: LIST
3712: PUSH
3713: LD_INT 21
3715: PUSH
3716: LD_INT 1
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 23
3725: PUSH
3726: LD_INT 3
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: LD_INT 26
3735: PUSH
3736: LD_INT 1
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: LIST
3747: LIST
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: PUSH
3756: LD_EXP 6
3760: PUSH
3761: EMPTY
3762: LIST
3763: DIFF
3764: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3765: LD_ADDR_VAR 0 2
3769: PUSH
3770: LD_VAR 0 2
3774: PPUSH
3775: CALL 22498 0 1
3779: ST_TO_ADDR
// if Lidi then
3780: LD_VAR 0 2
3784: IFFALSE 3802
// Result = Lidi [ 1 ] else
3786: LD_ADDR_VAR 0 1
3790: PUSH
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 1
3798: ARRAY
3799: ST_TO_ADDR
3800: GO 3812
// Result = Burlak ;
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: LD_EXP 6
3811: ST_TO_ADDR
// end ;
3812: LD_VAR 0 1
3816: RET
// function najdi_nekohoMF ; var Lidi ; begin
3817: LD_INT 0
3819: PPUSH
3820: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] ] ) diff [ Burlak ] ;
3821: LD_ADDR_VAR 0 2
3825: PUSH
3826: LD_INT 22
3828: PUSH
3829: LD_EXP 2
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PUSH
3838: LD_INT 50
3840: PUSH
3841: EMPTY
3842: LIST
3843: PUSH
3844: LD_INT 52
3846: PUSH
3847: EMPTY
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 1
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 23
3862: PUSH
3863: LD_INT 3
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL_OW 69
3881: PUSH
3882: LD_EXP 6
3886: PUSH
3887: EMPTY
3888: LIST
3889: DIFF
3890: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: LD_VAR 0 2
3900: PPUSH
3901: CALL 22498 0 1
3905: ST_TO_ADDR
// if Lidi then
3906: LD_VAR 0 2
3910: IFFALSE 3928
// Result = Lidi [ 1 ] else
3912: LD_ADDR_VAR 0 1
3916: PUSH
3917: LD_VAR 0 2
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: ST_TO_ADDR
3926: GO 3938
// Result = Burlak ;
3928: LD_ADDR_VAR 0 1
3932: PUSH
3933: LD_EXP 6
3937: ST_TO_ADDR
// end ;
3938: LD_VAR 0 1
3942: RET
// function najdi_vojaka ; var Vojaci ; begin
3943: LD_INT 0
3945: PPUSH
3946: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SOLDIER ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: LD_INT 22
3954: PUSH
3955: LD_EXP 2
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 50
3966: PUSH
3967: EMPTY
3968: LIST
3969: PUSH
3970: LD_INT 52
3972: PUSH
3973: EMPTY
3974: LIST
3975: PUSH
3976: LD_INT 21
3978: PUSH
3979: LD_INT 1
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: LD_INT 23
3988: PUSH
3989: LD_INT 3
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: LD_INT 25
3998: PUSH
3999: LD_INT 1
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: PUSH
4006: LD_INT 26
4008: PUSH
4009: LD_INT 1
4011: PUSH
4012: EMPTY
4013: LIST
4014: LIST
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: PPUSH
4025: CALL_OW 69
4029: PUSH
4030: LD_EXP 6
4034: PUSH
4035: EMPTY
4036: LIST
4037: DIFF
4038: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4039: LD_ADDR_VAR 0 2
4043: PUSH
4044: LD_VAR 0 2
4048: PPUSH
4049: CALL 22498 0 1
4053: ST_TO_ADDR
// if Vojaci then
4054: LD_VAR 0 2
4058: IFFALSE 4076
// Result = Vojaci [ 1 ] else
4060: LD_ADDR_VAR 0 1
4064: PUSH
4065: LD_VAR 0 2
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
4074: GO 4086
// Result = najdi_nekoho ;
4076: LD_ADDR_VAR 0 1
4080: PUSH
4081: CALL 3680 0 0
4085: ST_TO_ADDR
// end ;
4086: LD_VAR 0 1
4090: RET
// function najdi_vedce ; var Vojaci ; begin
4091: LD_INT 0
4093: PPUSH
4094: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
4095: LD_ADDR_VAR 0 2
4099: PUSH
4100: LD_INT 22
4102: PUSH
4103: LD_EXP 2
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PUSH
4112: LD_INT 50
4114: PUSH
4115: EMPTY
4116: LIST
4117: PUSH
4118: LD_INT 52
4120: PUSH
4121: EMPTY
4122: LIST
4123: PUSH
4124: LD_INT 21
4126: PUSH
4127: LD_INT 1
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 23
4136: PUSH
4137: LD_INT 3
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 25
4146: PUSH
4147: LD_INT 4
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: LD_INT 26
4156: PUSH
4157: LD_INT 1
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: PPUSH
4173: CALL_OW 69
4177: PUSH
4178: LD_EXP 6
4182: PUSH
4183: EMPTY
4184: LIST
4185: DIFF
4186: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4187: LD_ADDR_VAR 0 2
4191: PUSH
4192: LD_VAR 0 2
4196: PPUSH
4197: CALL 22498 0 1
4201: ST_TO_ADDR
// if Vojaci then
4202: LD_VAR 0 2
4206: IFFALSE 4224
// Result = Vojaci [ 1 ] else
4208: LD_ADDR_VAR 0 1
4212: PUSH
4213: LD_VAR 0 2
4217: PUSH
4218: LD_INT 1
4220: ARRAY
4221: ST_TO_ADDR
4222: GO 4232
// Result = 0 ;
4224: LD_ADDR_VAR 0 1
4228: PUSH
4229: LD_INT 0
4231: ST_TO_ADDR
// end ;
4232: LD_VAR 0 1
4236: RET
// function najdi_vedceMF ; var Vojaci ; begin
4237: LD_INT 0
4239: PPUSH
4240: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) diff [ Burlak ] ;
4241: LD_ADDR_VAR 0 2
4245: PUSH
4246: LD_INT 22
4248: PUSH
4249: LD_EXP 2
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: PUSH
4258: LD_INT 50
4260: PUSH
4261: EMPTY
4262: LIST
4263: PUSH
4264: LD_INT 52
4266: PUSH
4267: EMPTY
4268: LIST
4269: PUSH
4270: LD_INT 21
4272: PUSH
4273: LD_INT 1
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: PUSH
4280: LD_INT 23
4282: PUSH
4283: LD_INT 3
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 25
4292: PUSH
4293: LD_INT 4
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: LIST
4304: LIST
4305: LIST
4306: LIST
4307: PPUSH
4308: CALL_OW 69
4312: PUSH
4313: LD_EXP 6
4317: PUSH
4318: EMPTY
4319: LIST
4320: DIFF
4321: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4322: LD_ADDR_VAR 0 2
4326: PUSH
4327: LD_VAR 0 2
4331: PPUSH
4332: CALL 22498 0 1
4336: ST_TO_ADDR
// if Vojaci then
4337: LD_VAR 0 2
4341: IFFALSE 4359
// Result = Vojaci [ 1 ] else
4343: LD_ADDR_VAR 0 1
4347: PUSH
4348: LD_VAR 0 2
4352: PUSH
4353: LD_INT 1
4355: ARRAY
4356: ST_TO_ADDR
4357: GO 4367
// Result = 0 ;
4359: LD_ADDR_VAR 0 1
4363: PUSH
4364: LD_INT 0
4366: ST_TO_ADDR
// end ;
4367: LD_VAR 0 1
4371: RET
// function najdi_sejka ; var Lidi , Sejkove ; begin
4372: LD_INT 0
4374: PPUSH
4375: PPUSH
4376: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4377: LD_ADDR_VAR 0 2
4381: PUSH
4382: LD_INT 22
4384: PUSH
4385: LD_EXP 3
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 50
4396: PUSH
4397: EMPTY
4398: LIST
4399: PUSH
4400: LD_INT 52
4402: PUSH
4403: EMPTY
4404: LIST
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 26
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4438: LD_ADDR_VAR 0 2
4442: PUSH
4443: LD_VAR 0 2
4447: PPUSH
4448: CALL 22498 0 1
4452: ST_TO_ADDR
// Sejkove = UnitFilter ( Lidi , [ [ F_CLASS , CLASS_DESERT_WARIOR ] ] ) ;
4453: LD_ADDR_VAR 0 3
4457: PUSH
4458: LD_VAR 0 2
4462: PPUSH
4463: LD_INT 25
4465: PUSH
4466: LD_INT 11
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: PPUSH
4476: CALL_OW 72
4480: ST_TO_ADDR
// if Sejkove then
4481: LD_VAR 0 3
4485: IFFALSE 4503
// Result = Sejkove [ 1 ] else
4487: LD_ADDR_VAR 0 1
4491: PUSH
4492: LD_VAR 0 3
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: ST_TO_ADDR
4501: GO 4533
// if Lidi then
4503: LD_VAR 0 2
4507: IFFALSE 4525
// Result = Lidi [ 1 ] else
4509: LD_ADDR_VAR 0 1
4513: PUSH
4514: LD_VAR 0 2
4518: PUSH
4519: LD_INT 1
4521: ARRAY
4522: ST_TO_ADDR
4523: GO 4533
// Result = 0 ;
4525: LD_ADDR_VAR 0 1
4529: PUSH
4530: LD_INT 0
4532: ST_TO_ADDR
// end ;
4533: LD_VAR 0 1
4537: RET
// function najdi_araba ; var Lidi ; begin
4538: LD_INT 0
4540: PPUSH
4541: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4542: LD_ADDR_VAR 0 2
4546: PUSH
4547: LD_INT 22
4549: PUSH
4550: LD_EXP 3
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PUSH
4559: LD_INT 50
4561: PUSH
4562: EMPTY
4563: LIST
4564: PUSH
4565: LD_INT 52
4567: PUSH
4568: EMPTY
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 26
4583: PUSH
4584: LD_INT 1
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: LIST
4596: LIST
4597: PPUSH
4598: CALL_OW 69
4602: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: LD_VAR 0 2
4612: PPUSH
4613: CALL 22498 0 1
4617: ST_TO_ADDR
// if Lidi then
4618: LD_VAR 0 2
4622: IFFALSE 4640
// Result = Lidi [ 1 ] else
4624: LD_ADDR_VAR 0 1
4628: PUSH
4629: LD_VAR 0 2
4633: PUSH
4634: LD_INT 1
4636: ARRAY
4637: ST_TO_ADDR
4638: GO 4648
// Result = 0 ;
4640: LD_ADDR_VAR 0 1
4644: PUSH
4645: LD_INT 0
4647: ST_TO_ADDR
// end ;
4648: LD_VAR 0 1
4652: RET
// export function dialog_Start ; var V ; begin
4653: LD_INT 0
4655: PPUSH
4656: PPUSH
// V = najdi_vojaka ;
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: CALL 3943 0 0
4666: ST_TO_ADDR
// if not V then
4667: LD_VAR 0 2
4671: NOT
4672: IFFALSE 4684
// V = najdi_nekoho ;
4674: LD_ADDR_VAR 0 2
4678: PUSH
4679: CALL 3680 0 0
4683: ST_TO_ADDR
// if V then
4684: LD_VAR 0 2
4688: IFFALSE 4702
// Say ( V , DStart-RSol1-1 ) ;
4690: LD_VAR 0 2
4694: PPUSH
4695: LD_STRING DStart-RSol1-1
4697: PPUSH
4698: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
4702: LD_EXP 6
4706: PPUSH
4707: LD_STRING DStart-Bur-1
4709: PPUSH
4710: CALL_OW 88
// end ;
4714: LD_VAR 0 1
4718: RET
// export function dialog_AmAttack ; var G ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
// if Gladkov then
4723: LD_EXP 26
4727: IFFALSE 4741
// G = Gladkov else
4729: LD_ADDR_VAR 0 2
4733: PUSH
4734: LD_EXP 26
4738: ST_TO_ADDR
4739: GO 4751
// G = GladkovFake ;
4741: LD_ADDR_VAR 0 2
4745: PUSH
4746: LD_EXP 27
4750: ST_TO_ADDR
// SayRadio ( G , DAmAttack-Gla-1 ) ;
4751: LD_VAR 0 2
4755: PPUSH
4756: LD_STRING DAmAttack-Gla-1
4758: PPUSH
4759: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-1 ) ;
4763: LD_EXP 6
4767: PPUSH
4768: LD_STRING DAmAttack-Bur-1
4770: PPUSH
4771: CALL_OW 94
// SayRadio ( G , DAmAttack-Gla-2 ) ;
4775: LD_VAR 0 2
4779: PPUSH
4780: LD_STRING DAmAttack-Gla-2
4782: PPUSH
4783: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-2 ) ;
4787: LD_EXP 6
4791: PPUSH
4792: LD_STRING DAmAttack-Bur-2
4794: PPUSH
4795: CALL_OW 94
// Say ( Burlak , DAmAttack-Bur-2a ) ;
4799: LD_EXP 6
4803: PPUSH
4804: LD_STRING DAmAttack-Bur-2a
4806: PPUSH
4807: CALL_OW 88
// end ;
4811: LD_VAR 0 1
4815: RET
// export function dialog_LegionOfferHeike1 ; begin
4816: LD_INT 0
4818: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-1 ) ;
4819: LD_EXP 28
4823: PPUSH
4824: LD_STRING DLegionOfferHeike1-Hke-1
4826: PPUSH
4827: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-1 ) ;
4831: LD_EXP 6
4835: PPUSH
4836: LD_STRING DLegionOfferHeike1-Bur-1
4838: PPUSH
4839: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2 ) ;
4843: LD_EXP 28
4847: PPUSH
4848: LD_STRING DLegionOfferHeike1-Hke-2
4850: PPUSH
4851: CALL_OW 94
// end ;
4855: LD_VAR 0 1
4859: RET
// export function dialog_LegionOfferHeike2 ; begin
4860: LD_INT 0
4862: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2a ) ;
4863: LD_EXP 28
4867: PPUSH
4868: LD_STRING DLegionOfferHeike1-Hke-2a
4870: PPUSH
4871: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-2 ) ;
4875: LD_EXP 6
4879: PPUSH
4880: LD_STRING DLegionOfferHeike1-Bur-2
4882: PPUSH
4883: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-3 ) ;
4887: LD_EXP 28
4891: PPUSH
4892: LD_STRING DLegionOfferHeike1-Hke-3
4894: PPUSH
4895: CALL_OW 94
// end ;
4899: LD_VAR 0 1
4903: RET
// export function dialog_LegionOfferHeikeCont ; begin
4904: LD_INT 0
4906: PPUSH
// SayRadio ( Heike , DLegionOfferHeikeCont-Hke-1 ) ;
4907: LD_EXP 28
4911: PPUSH
4912: LD_STRING DLegionOfferHeikeCont-Hke-1
4914: PPUSH
4915: CALL_OW 94
// end ;
4919: LD_VAR 0 1
4923: RET
// export function query_LegionHeike ; begin
4924: LD_INT 0
4926: PPUSH
// Result = Query ( QLegionHeike ) ;
4927: LD_ADDR_VAR 0 1
4931: PUSH
4932: LD_STRING QLegionHeike
4934: PPUSH
4935: CALL_OW 97
4939: ST_TO_ADDR
// end ;
4940: LD_VAR 0 1
4944: RET
// export function dialog_QrLegionHeike13 ; begin
4945: LD_INT 0
4947: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#1-2-Bur-1 ) ;
4948: LD_EXP 6
4952: PPUSH
4953: LD_STRING DQrLegionHeike#1-2-Bur-1
4955: PPUSH
4956: CALL_OW 94
// end ;
4960: LD_VAR 0 1
4964: RET
// export function dialog_QrLegionHeike4 ; begin
4965: LD_INT 0
4967: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#3-Bur-1 ) ;
4968: LD_EXP 6
4972: PPUSH
4973: LD_STRING DQrLegionHeike#3-Bur-1
4975: PPUSH
4976: CALL_OW 94
// end ;
4980: LD_VAR 0 1
4984: RET
// export function dialog_LegionOfferFarmer ; begin
4985: LD_INT 0
4987: PPUSH
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-1 ) ;
4988: LD_EXP 29
4992: PPUSH
4993: LD_STRING DLegionOfferFarmer-Frm-1
4995: PPUSH
4996: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferFarmer-Bur-1 ) ;
5000: LD_EXP 6
5004: PPUSH
5005: LD_STRING DLegionOfferFarmer-Bur-1
5007: PPUSH
5008: CALL_OW 94
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-2 ) ;
5012: LD_EXP 29
5016: PPUSH
5017: LD_STRING DLegionOfferFarmer-Frm-2
5019: PPUSH
5020: CALL_OW 94
// end ;
5024: LD_VAR 0 1
5028: RET
// export function query_LegionFarmer ; begin
5029: LD_INT 0
5031: PPUSH
// Result = Query ( QLegionFarmer ) ;
5032: LD_ADDR_VAR 0 1
5036: PUSH
5037: LD_STRING QLegionFarmer
5039: PPUSH
5040: CALL_OW 97
5044: ST_TO_ADDR
// end ;
5045: LD_VAR 0 1
5049: RET
// export function dialog_QrLegionFarmer13 ; begin
5050: LD_INT 0
5052: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#1-3-Bur-1 ) ;
5053: LD_EXP 6
5057: PPUSH
5058: LD_STRING DQrLegionFarmer#1-3-Bur-1
5060: PPUSH
5061: CALL_OW 94
// end ;
5065: LD_VAR 0 1
5069: RET
// export function dialog_QrLegionFarmer4 ; begin
5070: LD_INT 0
5072: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#4-Bur-1 ) ;
5073: LD_EXP 6
5077: PPUSH
5078: LD_STRING DQrLegionFarmer#4-Bur-1
5080: PPUSH
5081: CALL_OW 94
// end ;
5085: LD_VAR 0 1
5089: RET
// export function dialog_LegionFugit ; begin
5090: LD_INT 0
5092: PPUSH
// Say ( Bergkamp , DLegionFugit-Brg-1 ) ;
5093: LD_EXP 30
5097: PPUSH
5098: LD_STRING DLegionFugit-Brg-1
5100: PPUSH
5101: CALL_OW 88
// Say ( Burlak , DLegionFugit-Bur-1 ) ;
5105: LD_EXP 6
5109: PPUSH
5110: LD_STRING DLegionFugit-Bur-1
5112: PPUSH
5113: CALL_OW 88
// Say ( Bergkamp , DLegionFugit-Brg-2 ) ;
5117: LD_EXP 30
5121: PPUSH
5122: LD_STRING DLegionFugit-Brg-2
5124: PPUSH
5125: CALL_OW 88
// end ;
5129: LD_VAR 0 1
5133: RET
// export function query_LegionBergkamp ; begin
5134: LD_INT 0
5136: PPUSH
// Result = Query ( QLegionBergkamp ) ;
5137: LD_ADDR_VAR 0 1
5141: PUSH
5142: LD_STRING QLegionBergkamp
5144: PPUSH
5145: CALL_OW 97
5149: ST_TO_ADDR
// end ;
5150: LD_VAR 0 1
5154: RET
// export function dialog_QrLegionBergkamp1 ; begin
5155: LD_INT 0
5157: PPUSH
// Say ( Burlak , DQrLegionBergkamp#1-Bur-1 ) ;
5158: LD_EXP 6
5162: PPUSH
5163: LD_STRING DQrLegionBergkamp#1-Bur-1
5165: PPUSH
5166: CALL_OW 88
// Say ( Bergkamp , DQrLegionBergkamp#1-Brg-1 ) ;
5170: LD_EXP 30
5174: PPUSH
5175: LD_STRING DQrLegionBergkamp#1-Brg-1
5177: PPUSH
5178: CALL_OW 88
// end ;
5182: LD_VAR 0 1
5186: RET
// export function dialog_QrLegionBergkamp2 ; begin
5187: LD_INT 0
5189: PPUSH
// Say ( Burlak , DQrLegionBergkamp#2-Bur-1 ) ;
5190: LD_EXP 6
5194: PPUSH
5195: LD_STRING DQrLegionBergkamp#2-Bur-1
5197: PPUSH
5198: CALL_OW 88
// end ;
5202: LD_VAR 0 1
5206: RET
// export function dialog_LegionLeave ; begin
5207: LD_INT 0
5209: PPUSH
// if not IsOk ( Bergkamp ) then
5210: LD_EXP 30
5214: PPUSH
5215: CALL_OW 302
5219: NOT
5220: IFFALSE 5224
// exit ;
5222: GO 5280
// if LegionOffer_Accepted then
5224: LD_EXP 59
5228: IFFALSE 5244
// Say ( Bergkamp , DLegionLeave-Brg-1 ) else
5230: LD_EXP 30
5234: PPUSH
5235: LD_STRING DLegionLeave-Brg-1
5237: PPUSH
5238: CALL_OW 88
5242: GO 5280
// begin Say ( Bergkamp , DLegionLeave-Brg-1a ) ;
5244: LD_EXP 30
5248: PPUSH
5249: LD_STRING DLegionLeave-Brg-1a
5251: PPUSH
5252: CALL_OW 88
// Say ( Burlak , DLegionLeave-Bur-1 ) ;
5256: LD_EXP 6
5260: PPUSH
5261: LD_STRING DLegionLeave-Bur-1
5263: PPUSH
5264: CALL_OW 88
// Say ( Bergkamp , DLegionLeave-Brg-2 ) ;
5268: LD_EXP 30
5272: PPUSH
5273: LD_STRING DLegionLeave-Brg-2
5275: PPUSH
5276: CALL_OW 88
// end ; end ;
5280: LD_VAR 0 1
5284: RET
// export function dialog_LegionSpy ; var V ; begin
5285: LD_INT 0
5287: PPUSH
5288: PPUSH
// V = najdi_vedce ;
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: CALL 4091 0 0
5298: ST_TO_ADDR
// if not V then
5299: LD_VAR 0 2
5303: NOT
5304: IFFALSE 5316
// V = najdi_nekoho ;
5306: LD_ADDR_VAR 0 2
5310: PUSH
5311: CALL 3680 0 0
5315: ST_TO_ADDR
// if V then
5316: LD_VAR 0 2
5320: IFFALSE 5334
// Say ( V , DLegionSpy-Sci1-1 ) ;
5322: LD_VAR 0 2
5326: PPUSH
5327: LD_STRING DLegionSpy-Sci1-1
5329: PPUSH
5330: CALL_OW 88
// Say ( Burlak , DLegionSpy-Bur-1 ) ;
5334: LD_EXP 6
5338: PPUSH
5339: LD_STRING DLegionSpy-Bur-1
5341: PPUSH
5342: CALL_OW 88
// end ;
5346: LD_VAR 0 1
5350: RET
// export function dialog_LegionChallengeHeike ; begin
5351: LD_INT 0
5353: PPUSH
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-1 ) ;
5354: LD_EXP 6
5358: PPUSH
5359: LD_STRING DLegionChallengeHeike-Bur-1
5361: PPUSH
5362: CALL_OW 94
// SayRadio ( Heike , DLegionChallengeHeike-Hke-1 ) ;
5366: LD_EXP 28
5370: PPUSH
5371: LD_STRING DLegionChallengeHeike-Hke-1
5373: PPUSH
5374: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-2 ) ;
5378: LD_EXP 6
5382: PPUSH
5383: LD_STRING DLegionChallengeHeike-Bur-2
5385: PPUSH
5386: CALL_OW 94
// if OmarKilled then
5390: LD_EXP 38
5394: IFFALSE 5408
// SayRadio ( Heike , DLegionChallengeHeike-Hke-2 ) ;
5396: LD_EXP 28
5400: PPUSH
5401: LD_STRING DLegionChallengeHeike-Hke-2
5403: PPUSH
5404: CALL_OW 94
// end ;
5408: LD_VAR 0 1
5412: RET
// export function dialog_LegionChallengeFarmer ; begin
5413: LD_INT 0
5415: PPUSH
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-1 ) ;
5416: LD_EXP 6
5420: PPUSH
5421: LD_STRING DLegionChallengeFarmer-Bur-1
5423: PPUSH
5424: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-1 ) ;
5428: LD_EXP 29
5432: PPUSH
5433: LD_STRING DLegionChallengeFarmer-Frm-1
5435: PPUSH
5436: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-2 ) ;
5440: LD_EXP 6
5444: PPUSH
5445: LD_STRING DLegionChallengeFarmer-Bur-2
5447: PPUSH
5448: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-2 ) ;
5452: LD_EXP 29
5456: PPUSH
5457: LD_STRING DLegionChallengeFarmer-Frm-2
5459: PPUSH
5460: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-3 ) ;
5464: LD_EXP 6
5468: PPUSH
5469: LD_STRING DLegionChallengeFarmer-Bur-3
5471: PPUSH
5472: CALL_OW 94
// end ;
5476: LD_VAR 0 1
5480: RET
// export function dialog_Contam ; var V ; begin
5481: LD_INT 0
5483: PPUSH
5484: PPUSH
// V = najdi_vedce ;
5485: LD_ADDR_VAR 0 2
5489: PUSH
5490: CALL 4091 0 0
5494: ST_TO_ADDR
// if not V then
5495: LD_VAR 0 2
5499: NOT
5500: IFFALSE 5512
// V = najdi_nekoho ;
5502: LD_ADDR_VAR 0 2
5506: PUSH
5507: CALL 3680 0 0
5511: ST_TO_ADDR
// if V and ( V <> Burlak ) then
5512: LD_VAR 0 2
5516: PUSH
5517: LD_VAR 0 2
5521: PUSH
5522: LD_EXP 6
5526: NONEQUAL
5527: AND
5528: IFFALSE 5578
// begin Say ( V , DContam-Sci1-1 ) ;
5530: LD_VAR 0 2
5534: PPUSH
5535: LD_STRING DContam-Sci1-1
5537: PPUSH
5538: CALL_OW 88
// Say ( Burlak , DContam-Bur-1 ) ;
5542: LD_EXP 6
5546: PPUSH
5547: LD_STRING DContam-Bur-1
5549: PPUSH
5550: CALL_OW 88
// Say ( V , DContam-Sci1-2 ) ;
5554: LD_VAR 0 2
5558: PPUSH
5559: LD_STRING DContam-Sci1-2
5561: PPUSH
5562: CALL_OW 88
// Say ( Burlak , DContam-Bur-2 ) ;
5566: LD_EXP 6
5570: PPUSH
5571: LD_STRING DContam-Bur-2
5573: PPUSH
5574: CALL_OW 88
// end ; end ;
5578: LD_VAR 0 1
5582: RET
// export function dialog_SurrenderArabians ; var V ; begin
5583: LD_INT 0
5585: PPUSH
5586: PPUSH
// if IsOK ( Abdul ) then
5587: LD_EXP 31
5591: PPUSH
5592: CALL_OW 302
5596: IFFALSE 5612
// Say ( Abdul , DSurrenderArabians-Abd-1 ) else
5598: LD_EXP 31
5602: PPUSH
5603: LD_STRING DSurrenderArabians-Abd-1
5605: PPUSH
5606: CALL_OW 88
5610: GO 5686
// begin if Omar and IsOk ( Omar ) then
5612: LD_EXP 32
5616: PUSH
5617: LD_EXP 32
5621: PPUSH
5622: CALL_OW 302
5626: AND
5627: IFFALSE 5641
// V = Omar else
5629: LD_ADDR_VAR 0 2
5633: PUSH
5634: LD_EXP 32
5638: ST_TO_ADDR
5639: GO 5651
// V = najdi_sejka ;
5641: LD_ADDR_VAR 0 2
5645: PUSH
5646: CALL 4372 0 0
5650: ST_TO_ADDR
// if not V then
5651: LD_VAR 0 2
5655: NOT
5656: IFFALSE 5668
// V = najdi_araba ;
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: CALL 4538 0 0
5667: ST_TO_ADDR
// if V then
5668: LD_VAR 0 2
5672: IFFALSE 5686
// Say ( V , DSurrenderArabians-ArSol1-1 ) ;
5674: LD_VAR 0 2
5678: PPUSH
5679: LD_STRING DSurrenderArabians-ArSol1-1
5681: PPUSH
5682: CALL_OW 88
// end ; end ;
5686: LD_VAR 0 1
5690: RET
// export function dialog_BehemothTechno1 ; var V ; begin
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-1 ) ;
5695: LD_EXP 6
5699: PPUSH
5700: LD_STRING DBehemothTechno-Bur-1
5702: PPUSH
5703: CALL_OW 88
// if Petrosyan and IsOk ( Petrosyan ) then
5707: LD_EXP 16
5711: PUSH
5712: LD_EXP 16
5716: PPUSH
5717: CALL_OW 302
5721: AND
5722: IFFALSE 5738
// Say ( Petrosyan , DBehemothTechno-Pty-1 ) else
5724: LD_EXP 16
5728: PPUSH
5729: LD_STRING DBehemothTechno-Pty-1
5731: PPUSH
5732: CALL_OW 88
5736: GO 5821
// begin V = najdi_vedceMF ;
5738: LD_ADDR_VAR 0 2
5742: PUSH
5743: CALL 4237 0 0
5747: ST_TO_ADDR
// if not V then
5748: LD_VAR 0 2
5752: NOT
5753: IFFALSE 5765
// V = najdi_nekoho ;
5755: LD_ADDR_VAR 0 2
5759: PUSH
5760: CALL 3680 0 0
5764: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5765: LD_VAR 0 2
5769: PPUSH
5770: CALL_OW 258
5774: PUSH
5775: LD_INT 1
5777: EQUAL
5778: IFFALSE 5794
// Say ( V , DBehemothTechno-Sci-1 ) else
5780: LD_VAR 0 2
5784: PPUSH
5785: LD_STRING DBehemothTechno-Sci-1
5787: PPUSH
5788: CALL_OW 88
5792: GO 5821
// if GetSex ( V ) = SEX_FEMALE then
5794: LD_VAR 0 2
5798: PPUSH
5799: CALL_OW 258
5803: PUSH
5804: LD_INT 2
5806: EQUAL
5807: IFFALSE 5821
// Say ( V , DBehemothTechno-FSci1-1 ) ;
5809: LD_VAR 0 2
5813: PPUSH
5814: LD_STRING DBehemothTechno-FSci1-1
5816: PPUSH
5817: CALL_OW 88
// end ; end ;
5821: LD_VAR 0 1
5825: RET
// export function dialog_BehemothTechno2 ; var V ; begin
5826: LD_INT 0
5828: PPUSH
5829: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-2 ) ;
5830: LD_EXP 6
5834: PPUSH
5835: LD_STRING DBehemothTechno-Bur-2
5837: PPUSH
5838: CALL_OW 88
// V = najdi_vedceMF ;
5842: LD_ADDR_VAR 0 2
5846: PUSH
5847: CALL 4237 0 0
5851: ST_TO_ADDR
// if not V then
5852: LD_VAR 0 2
5856: NOT
5857: IFFALSE 5869
// V = najdi_nekoho ;
5859: LD_ADDR_VAR 0 2
5863: PUSH
5864: CALL 3680 0 0
5868: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5869: LD_VAR 0 2
5873: PPUSH
5874: CALL_OW 258
5878: PUSH
5879: LD_INT 1
5881: EQUAL
5882: IFFALSE 5898
// Say ( V , DBehemothTechno-Sci-2 ) else
5884: LD_VAR 0 2
5888: PPUSH
5889: LD_STRING DBehemothTechno-Sci-2
5891: PPUSH
5892: CALL_OW 88
5896: GO 5925
// if GetSex ( V ) = SEX_FEMALE then
5898: LD_VAR 0 2
5902: PPUSH
5903: CALL_OW 258
5907: PUSH
5908: LD_INT 2
5910: EQUAL
5911: IFFALSE 5925
// Say ( V , DBehemothTechno-FSci1-2 ) ;
5913: LD_VAR 0 2
5917: PPUSH
5918: LD_STRING DBehemothTechno-FSci1-2
5920: PPUSH
5921: CALL_OW 88
// end ;
5925: LD_VAR 0 1
5929: RET
// export function dialog_BehemothComplete ; var Vsichni , Seznam , Vedci , Kdo ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
5934: PPUSH
5935: PPUSH
5936: PPUSH
// Seznam = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
5937: LD_ADDR_VAR 0 3
5941: PUSH
5942: LD_INT 22
5944: PUSH
5945: LD_EXP 2
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: PUSH
5954: LD_INT 50
5956: PUSH
5957: EMPTY
5958: LIST
5959: PUSH
5960: LD_INT 52
5962: PUSH
5963: EMPTY
5964: LIST
5965: PUSH
5966: LD_INT 21
5968: PUSH
5969: LD_INT 1
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: LD_INT 26
5978: PUSH
5979: LD_INT 1
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: PUSH
5986: EMPTY
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL_OW 69
5997: PUSH
5998: LD_EXP 6
6002: PUSH
6003: EMPTY
6004: LIST
6005: DIFF
6006: ST_TO_ADDR
// Vedci = UnitFilter ( Vsichni , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
6007: LD_ADDR_VAR 0 4
6011: PUSH
6012: LD_VAR 0 2
6016: PPUSH
6017: LD_INT 25
6019: PUSH
6020: LD_INT 4
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: PUSH
6027: EMPTY
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// Vsichni = Vedci ^ ( Seznam diff Vedci ) ;
6035: LD_ADDR_VAR 0 2
6039: PUSH
6040: LD_VAR 0 4
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_VAR 0 4
6054: DIFF
6055: ADD
6056: ST_TO_ADDR
// if Vsichni >= 1 then
6057: LD_VAR 0 2
6061: PUSH
6062: LD_INT 1
6064: GREATEREQUAL
6065: IFFALSE 6117
// begin Kdo = Vsichni [ 1 ] ;
6067: LD_ADDR_VAR 0 5
6071: PUSH
6072: LD_VAR 0 2
6076: PUSH
6077: LD_INT 1
6079: ARRAY
6080: ST_TO_ADDR
// Say ( Kdo , DBehemothComplete-Sci-1 ) ;
6081: LD_VAR 0 5
6085: PPUSH
6086: LD_STRING DBehemothComplete-Sci-1
6088: PPUSH
6089: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1a ) ;
6093: LD_VAR 0 5
6097: PPUSH
6098: LD_STRING DBehemothComplete-Sci-1a
6100: PPUSH
6101: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1b ) ;
6105: LD_VAR 0 5
6109: PPUSH
6110: LD_STRING DBehemothComplete-Sci-1b
6112: PPUSH
6113: CALL_OW 88
// end ; Hint ( Behemoth ) ;
6117: LD_STRING Behemoth
6119: PPUSH
6120: CALL_OW 339
// end ; end_of_file
6124: LD_VAR 0 1
6128: RET
// export LegionOffer_Heike , LegionOffer_Accepted , LegionFugit_Accepted ; var LeSci1 , LeSci2 , LeMech1 , LeMech2 , LeEng ; var Obranci , Mechanici ; var Ridici ; export Uprchlici ; var Uprchlici_JsouTam ; var Uprchlici_X , Uprchlici_Y ; var KonvojPopojizdi ; var Nabidka_Nakladaky , Nabidka_Ridici , Nabidka_Cena , Nabidka_Lidi ; var Nabidka_Nalozeno , Nabidka_Vylozeno ; var Makro ; var KdoLeci , KdoOpravuje ; var ProbihaPredavaniSurovin ; var MamPrebarvit ; export function init_legion ; var Base , Reg ; begin
6129: LD_INT 0
6131: PPUSH
6132: PPUSH
6133: PPUSH
// disable ( 11 ) ;
6134: LD_INT 11
6136: DISABLE_MARKED
// disable ( 12 ) ;
6137: LD_INT 12
6139: DISABLE_MARKED
// disable ( 13 ) ;
6140: LD_INT 13
6142: DISABLE_MARKED
// disable ( 14 ) ;
6143: LD_INT 14
6145: DISABLE_MARKED
// disable ( 15 ) ;
6146: LD_INT 15
6148: DISABLE_MARKED
// disable ( 16 ) ;
6149: LD_INT 16
6151: DISABLE_MARKED
// if Difficulty = 1 then
6152: LD_OWVAR 67
6156: PUSH
6157: LD_INT 1
6159: EQUAL
6160: IFFALSE 6215
// begin DestroyUnit ( LeBunk2 ) ;
6162: LD_INT 28
6164: PPUSH
6165: CALL_OW 65
// DestroyUnit ( LeBunk4 ) ;
6169: LD_INT 40
6171: PPUSH
6172: CALL_OW 65
// DestroyUnit ( LeBunk6 ) ;
6176: LD_INT 31
6178: PPUSH
6179: CALL_OW 65
// PlaceWeaponTurret ( LeBunk1 , AR_FLAME_THROWER ) ;
6183: LD_INT 27
6185: PPUSH
6186: LD_INT 26
6188: PPUSH
6189: CALL_OW 431
// PlaceWeaponTurret ( LeBunk5 , AR_FLAME_THROWER ) ;
6193: LD_INT 30
6195: PPUSH
6196: LD_INT 26
6198: PPUSH
6199: CALL_OW 431
// PlaceWeaponTurret ( LeBunk7 , AR_GUN ) ;
6203: LD_INT 22
6205: PPUSH
6206: LD_INT 27
6208: PPUSH
6209: CALL_OW 431
// end else
6213: GO 6232
// if Difficulty = 2 then
6215: LD_OWVAR 67
6219: PUSH
6220: LD_INT 2
6222: EQUAL
6223: IFFALSE 6232
// begin DestroyUnit ( LeBunk2 ) ;
6225: LD_INT 28
6227: PPUSH
6228: CALL_OW 65
// end ; LegionOffer_Heike = false ;
6232: LD_ADDR_EXP 58
6236: PUSH
6237: LD_INT 0
6239: ST_TO_ADDR
// LegionOffer_Accepted = false ;
6240: LD_ADDR_EXP 59
6244: PUSH
6245: LD_INT 0
6247: ST_TO_ADDR
// LegionFugit_Accepted = false ;
6248: LD_ADDR_EXP 60
6252: PUSH
6253: LD_INT 0
6255: ST_TO_ADDR
// Uprchlici = [ ] ;
6256: LD_ADDR_EXP 61
6260: PUSH
6261: EMPTY
6262: ST_TO_ADDR
// Uprchlici_JsouTam = false ;
6263: LD_ADDR_LOC 13
6267: PUSH
6268: LD_INT 0
6270: ST_TO_ADDR
// Uprchlici_X = Uprchlici_Y = 0 ;
6271: LD_ADDR_LOC 14
6275: PUSH
6276: LD_LOC 15
6280: PUSH
6281: LD_INT 0
6283: EQUAL
6284: ST_TO_ADDR
// KonvojPopojizdi = false ;
6285: LD_ADDR_LOC 16
6289: PUSH
6290: LD_INT 0
6292: ST_TO_ADDR
// Nabidka_Nakladaky = [ ] ;
6293: LD_ADDR_LOC 17
6297: PUSH
6298: EMPTY
6299: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
6300: LD_ADDR_LOC 18
6304: PUSH
6305: EMPTY
6306: ST_TO_ADDR
// Nabidka_Cena = [ 0 , 0 ] ;
6307: LD_ADDR_LOC 19
6311: PUSH
6312: LD_INT 0
6314: PUSH
6315: LD_INT 0
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
6322: LD_ADDR_LOC 20
6326: PUSH
6327: LD_INT 0
6329: ST_TO_ADDR
// Nabidka_Nalozeno = false ;
6330: LD_ADDR_LOC 21
6334: PUSH
6335: LD_INT 0
6337: ST_TO_ADDR
// Nabidka_Vylozeno = false ;
6338: LD_ADDR_LOC 22
6342: PUSH
6343: LD_INT 0
6345: ST_TO_ADDR
// KdoLeci = [ ] ;
6346: LD_ADDR_LOC 24
6350: PUSH
6351: EMPTY
6352: ST_TO_ADDR
// KdoOpravuje = [ ] ;
6353: LD_ADDR_LOC 25
6357: PUSH
6358: EMPTY
6359: ST_TO_ADDR
// ProbihaPredavaniSurovin = false ;
6360: LD_ADDR_LOC 26
6364: PUSH
6365: LD_INT 0
6367: ST_TO_ADDR
// vytvor_postavy ;
6368: CALL 6566 0 0
// Base = GetBase ( LeDepot ) ;
6372: LD_ADDR_VAR 0 2
6376: PUSH
6377: LD_INT 20
6379: PPUSH
6380: CALL_OW 274
6384: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 600 , 700 ) ) ;
6385: LD_VAR 0 2
6389: PPUSH
6390: LD_INT 1
6392: PPUSH
6393: LD_INT 600
6395: PPUSH
6396: LD_INT 700
6398: PPUSH
6399: CALL_OW 12
6403: PPUSH
6404: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 800 , 1200 ) ) ;
6408: LD_VAR 0 2
6412: PPUSH
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 800
6418: PPUSH
6419: LD_INT 1200
6421: PPUSH
6422: CALL_OW 12
6426: PPUSH
6427: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 200 , 300 ) ) ;
6431: LD_VAR 0 2
6435: PPUSH
6436: LD_INT 3
6438: PPUSH
6439: LD_INT 200
6441: PPUSH
6442: LD_INT 300
6444: PPUSH
6445: CALL_OW 12
6449: PPUSH
6450: CALL_OW 277
// Reg = McRegistry ( side_Le , [ [ MC_REG_AREA_TO_PROTECT , LegionObrana ] ] ) ;
6454: LD_ADDR_VAR 0 3
6458: PUSH
6459: LD_EXP 4
6463: PPUSH
6464: LD_INT 3
6466: PUSH
6467: LD_INT 16
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: EMPTY
6475: LIST
6476: PPUSH
6477: CALL_OW 399
6481: ST_TO_ADDR
// Makro = McDefend ( 0 , Reg , Obranci union Mechanici union Ridici union [ LeBunk1 , LeBunk2 , LeBunk3 , LeBunk4 , Lebunk5 , LeBunk6 , LeBunk7 ] , [ [ MC_AREA_DONT_LEAVE , Legion ] ] ) ;
6482: LD_ADDR_LOC 23
6486: PUSH
6487: LD_INT 0
6489: PPUSH
6490: LD_VAR 0 3
6494: PPUSH
6495: LD_LOC 10
6499: PUSH
6500: LD_LOC 11
6504: UNION
6505: PUSH
6506: LD_LOC 12
6510: UNION
6511: PUSH
6512: LD_INT 27
6514: PUSH
6515: LD_INT 28
6517: PUSH
6518: LD_INT 29
6520: PUSH
6521: LD_INT 40
6523: PUSH
6524: LD_INT 30
6526: PUSH
6527: LD_INT 31
6529: PUSH
6530: LD_INT 22
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: LIST
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: UNION
6542: PPUSH
6543: LD_INT 2
6545: PUSH
6546: LD_INT 4
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: PUSH
6553: EMPTY
6554: LIST
6555: PPUSH
6556: CALL_OW 401
6560: ST_TO_ADDR
// end ;
6561: LD_VAR 0 1
6565: RET
// function vytvor_postavy ; var Bunkry , B ; begin
6566: LD_INT 0
6568: PPUSH
6569: PPUSH
6570: PPUSH
// LeSci1 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6571: LD_ADDR_LOC 5
6575: PUSH
6576: LD_INT 25
6578: PPUSH
6579: LD_INT 4
6581: PPUSH
6582: CALL 6889 0 2
6586: ST_TO_ADDR
// LeSci2 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6587: LD_ADDR_LOC 6
6591: PUSH
6592: LD_INT 25
6594: PPUSH
6595: LD_INT 4
6597: PPUSH
6598: CALL 6889 0 2
6602: ST_TO_ADDR
// LeMech1 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6603: LD_ADDR_LOC 7
6607: PUSH
6608: LD_INT 26
6610: PPUSH
6611: LD_INT 3
6613: PPUSH
6614: CALL 6889 0 2
6618: ST_TO_ADDR
// LeMech2 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6619: LD_ADDR_LOC 8
6623: PUSH
6624: LD_INT 26
6626: PPUSH
6627: LD_INT 3
6629: PPUSH
6630: CALL 6889 0 2
6634: ST_TO_ADDR
// vytvor_postavu_B ( LeDepot , CLASS_ENGINEER ) ;
6635: LD_INT 20
6637: PPUSH
6638: LD_INT 2
6640: PPUSH
6641: CALL 6889 0 2
// LeEng = vytvor_postavu_A ( Legion , CLASS_ENGINEER ) ;
6645: LD_ADDR_LOC 9
6649: PUSH
6650: LD_INT 4
6652: PPUSH
6653: LD_INT 2
6655: PPUSH
6656: CALL 6926 0 2
6660: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 3 , Legion , CLASS_SOLDIER ) ;
6661: LD_ADDR_LOC 10
6665: PUSH
6666: LD_INT 3
6668: PPUSH
6669: LD_INT 4
6671: PPUSH
6672: LD_INT 1
6674: PPUSH
6675: CALL 6966 0 3
6679: ST_TO_ADDR
// Mechanici = vytvor_postavy_A ( 2 , Legion , CLASS_MECHANIC ) ;
6680: LD_ADDR_LOC 11
6684: PUSH
6685: LD_INT 2
6687: PPUSH
6688: LD_INT 4
6690: PPUSH
6691: LD_INT 3
6693: PPUSH
6694: CALL 6966 0 3
6698: ST_TO_ADDR
// Ridici = Mechanici union vytvor_postavy_A ( dif_LegionRidici [ Difficulty ] , Legion , CLASS_SOLDIER ) ;
6699: LD_ADDR_LOC 12
6703: PUSH
6704: LD_LOC 11
6708: PUSH
6709: LD_EXP 45
6713: PUSH
6714: LD_OWVAR 67
6718: ARRAY
6719: PPUSH
6720: LD_INT 4
6722: PPUSH
6723: LD_INT 1
6725: PPUSH
6726: CALL 6966 0 3
6730: UNION
6731: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
6732: LD_ADDR_VAR 0 2
6736: PUSH
6737: LD_INT 22
6739: PUSH
6740: LD_EXP 4
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 21
6751: PUSH
6752: LD_INT 3
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 30
6761: PUSH
6762: LD_INT 32
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: LIST
6773: PPUSH
6774: CALL_OW 69
6778: ST_TO_ADDR
// for B in Bunkry do
6779: LD_ADDR_VAR 0 3
6783: PUSH
6784: LD_VAR 0 2
6788: PUSH
6789: FOR_IN
6790: IFFALSE 6806
// vytvor_postavu_B ( B , CLASS_SOLDIER ) ;
6792: LD_VAR 0 3
6796: PPUSH
6797: LD_INT 1
6799: PPUSH
6800: CALL 6889 0 2
6804: GO 6789
6806: POP
6807: POP
// end ;
6808: LD_VAR 0 1
6812: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
6813: LD_INT 0
6815: PPUSH
6816: PPUSH
6817: PPUSH
// UC_Side = side_Le ;
6818: LD_ADDR_OWVAR 20
6822: PUSH
6823: LD_EXP 4
6827: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
6828: LD_ADDR_OWVAR 21
6832: PUSH
6833: LD_INT 2
6835: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
6836: LD_ADDR_OWVAR 27
6840: PUSH
6841: LD_INT 1
6843: PPUSH
6844: LD_INT 2
6846: PPUSH
6847: CALL_OW 12
6851: ST_TO_ADDR
// HC_Class = Cls ;
6852: LD_ADDR_OWVAR 28
6856: PUSH
6857: LD_VAR 0 1
6861: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 7
6869: PPUSH
6870: CALL_OW 374
// Result = CreateHuman ;
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: CALL_OW 44
6883: ST_TO_ADDR
// end ;
6884: LD_VAR 0 2
6888: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
6889: LD_INT 0
6891: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6892: LD_ADDR_VAR 0 3
6896: PUSH
6897: LD_VAR 0 2
6901: PPUSH
6902: CALL 6813 0 1
6906: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_VAR 0 1
6916: PPUSH
6917: CALL_OW 52
// end ;
6921: LD_VAR 0 3
6925: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
6926: LD_INT 0
6928: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6929: LD_ADDR_VAR 0 3
6933: PUSH
6934: LD_VAR 0 2
6938: PPUSH
6939: CALL 6813 0 1
6943: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
6944: LD_VAR 0 3
6948: PPUSH
6949: LD_VAR 0 1
6953: PPUSH
6954: LD_INT 0
6956: PPUSH
6957: CALL_OW 49
// end ;
6961: LD_VAR 0 3
6965: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
6966: LD_INT 0
6968: PPUSH
6969: PPUSH
// Result = [ ] ;
6970: LD_ADDR_VAR 0 4
6974: PUSH
6975: EMPTY
6976: ST_TO_ADDR
// for I = 1 to Pocet do
6977: LD_ADDR_VAR 0 5
6981: PUSH
6982: DOUBLE
6983: LD_INT 1
6985: DEC
6986: ST_TO_ADDR
6987: LD_VAR 0 1
6991: PUSH
6992: FOR_TO
6993: IFFALSE 7026
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
6995: LD_ADDR_VAR 0 4
6999: PUSH
7000: LD_VAR 0 4
7004: PUSH
7005: LD_VAR 0 2
7009: PPUSH
7010: LD_VAR 0 3
7014: PPUSH
7015: CALL 6926 0 2
7019: PUSH
7020: EMPTY
7021: LIST
7022: UNION
7023: ST_TO_ADDR
7024: GO 6992
7026: POP
7027: POP
// end ;
7028: LD_VAR 0 4
7032: RET
// function zacni_vynalezat ; begin
7033: LD_INT 0
7035: PPUSH
// AddComResearch ( LeLab , TECH_ROCKET ) ;
7036: LD_INT 25
7038: PPUSH
7039: LD_INT 40
7041: PPUSH
7042: CALL_OW 184
// AddComResearch ( LeLab , TECH_FLAME ) ;
7046: LD_INT 25
7048: PPUSH
7049: LD_INT 70
7051: PPUSH
7052: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIBCONTAM ) ;
7056: LD_INT 25
7058: PPUSH
7059: LD_INT 26
7061: PPUSH
7062: CALL_OW 184
// AddComResearch ( LeLab , TECH_MORTAR ) ;
7066: LD_INT 25
7068: PPUSH
7069: LD_INT 41
7071: PPUSH
7072: CALL_OW 184
// AddComResearch ( LeLab , TECH_EXPLOS ) ;
7076: LD_INT 25
7078: PPUSH
7079: LD_INT 42
7081: PPUSH
7082: CALL_OW 184
// AddComResearch ( LeLab , TECH_SELFDEST ) ;
7086: LD_INT 25
7088: PPUSH
7089: LD_INT 43
7091: PPUSH
7092: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH1 ) ;
7096: LD_INT 25
7098: PPUSH
7099: LD_INT 48
7101: PPUSH
7102: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP1 ) ;
7106: LD_INT 25
7108: PPUSH
7109: LD_INT 51
7111: PPUSH
7112: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB1 ) ;
7116: LD_INT 25
7118: PPUSH
7119: LD_INT 54
7121: PPUSH
7122: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH2 ) ;
7126: LD_INT 25
7128: PPUSH
7129: LD_INT 49
7131: PPUSH
7132: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP2 ) ;
7136: LD_INT 25
7138: PPUSH
7139: LD_INT 52
7141: PPUSH
7142: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB2 ) ;
7146: LD_INT 25
7148: PPUSH
7149: LD_INT 55
7151: PPUSH
7152: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH3 ) ;
7156: LD_INT 25
7158: PPUSH
7159: LD_INT 50
7161: PPUSH
7162: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP3 ) ;
7166: LD_INT 25
7168: PPUSH
7169: LD_INT 53
7171: PPUSH
7172: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB3 ) ;
7176: LD_INT 25
7178: PPUSH
7179: LD_INT 56
7181: PPUSH
7182: CALL_OW 184
// end ;
7186: LD_VAR 0 1
7190: RET
// every 0 0$2.3 do
7191: GO 7193
7193: DISABLE
// begin zacni_vynalezat ;
7194: CALL 7033 0 0
// end ;
7198: END
// every 1 1$28 do var Inz ;
7199: GO 7201
7201: DISABLE
7202: LD_INT 0
7204: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
7205: LD_ADDR_VAR 0 1
7209: PUSH
7210: LD_INT 22
7212: PUSH
7213: LD_EXP 4
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 21
7224: PUSH
7225: LD_INT 1
7227: PUSH
7228: EMPTY
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 25
7234: PUSH
7235: LD_INT 2
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: LIST
7246: PPUSH
7247: CALL_OW 69
7251: ST_TO_ADDR
// sbirej_bedny ( Inz , Legion ) ;
7252: LD_VAR 0 1
7256: PPUSH
7257: LD_INT 4
7259: PPUSH
7260: CALL 21160 0 2
// opravuj_budovy ( Inz , Legion , side_Le ) ;
7264: LD_VAR 0 1
7268: PPUSH
7269: LD_INT 4
7271: PPUSH
7272: LD_EXP 4
7276: PPUSH
7277: CALL 21390 0 3
// enable ;
7281: ENABLE
// end ;
7282: PPOPN 1
7284: END
// function opravuj ; begin
7285: LD_INT 0
7287: PPUSH
// if KdoOpravuje then
7288: LD_LOC 25
7292: IFFALSE 7296
// exit ;
7294: GO 7333
// KdoOpravuje = opravuj_auta ( [ LeMech1 , LeMech2 ] , 113 , Legion , side_Le , [ ] ) ;
7296: LD_ADDR_LOC 25
7300: PUSH
7301: LD_LOC 7
7305: PUSH
7306: LD_LOC 8
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: LD_INT 113
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_EXP 4
7325: PPUSH
7326: EMPTY
7327: PPUSH
7328: CALL 21908 0 5
7332: ST_TO_ADDR
// end ;
7333: LD_VAR 0 1
7337: RET
// function kuryruj ; begin
7338: LD_INT 0
7340: PPUSH
// if KdoLeci then
7341: LD_LOC 24
7345: IFFALSE 7349
// exit ;
7347: GO 7384
// KdoLeci = kuryruj_lidi ( [ LeSci1 , LeSci2 ] , 114 , Legion , side_Le ) ;
7349: LD_ADDR_LOC 24
7353: PUSH
7354: LD_LOC 5
7358: PUSH
7359: LD_LOC 6
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PPUSH
7368: LD_INT 114
7370: PPUSH
7371: LD_INT 4
7373: PPUSH
7374: LD_EXP 4
7378: PPUSH
7379: CALL 22210 0 4
7383: ST_TO_ADDR
// end ;
7384: LD_VAR 0 1
7388: RET
// export function event_LegionOprava ( Event ) ; begin
7389: LD_INT 0
7391: PPUSH
// case Event of 113 :
7392: LD_VAR 0 1
7396: PUSH
7397: LD_INT 113
7399: DOUBLE
7400: EQUAL
7401: IFTRUE 7405
7403: GO 7427
7405: POP
// begin ComEnterUnit ( KdoOpravuje , LeFact ) ;
7406: LD_LOC 25
7410: PPUSH
7411: LD_INT 26
7413: PPUSH
7414: CALL_OW 120
// KdoOpravuje = [ ] ;
7418: LD_ADDR_LOC 25
7422: PUSH
7423: EMPTY
7424: ST_TO_ADDR
// end ; 114 :
7425: GO 7458
7427: LD_INT 114
7429: DOUBLE
7430: EQUAL
7431: IFTRUE 7435
7433: GO 7457
7435: POP
// begin ComEnterUnit ( KdoLeci , LeLab ) ;
7436: LD_LOC 24
7440: PPUSH
7441: LD_INT 25
7443: PPUSH
7444: CALL_OW 120
// KdoLeci = [ ] ;
7448: LD_ADDR_LOC 24
7452: PUSH
7453: EMPTY
7454: ST_TO_ADDR
// end ; end ;
7455: GO 7458
7457: POP
// end ;
7458: LD_VAR 0 2
7462: RET
// every 2 2$7 do
7463: GO 7465
7465: DISABLE
// begin opravuj ;
7466: CALL 7285 0 0
// kuryruj ;
7470: CALL 7338 0 0
// enable ;
7474: ENABLE
// end ;
7475: END
// function vyrob_autak ; var Chassis , Weapon , P ; begin
7476: LD_INT 0
7478: PPUSH
7479: PPUSH
7480: PPUSH
7481: PPUSH
// P = Rand ( 1 , 100 ) ;
7482: LD_ADDR_VAR 0 4
7486: PUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 100
7492: PPUSH
7493: CALL_OW 12
7497: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 75 ) then
7498: LD_OWVAR 67
7502: PUSH
7503: LD_INT 1
7505: EQUAL
7506: PUSH
7507: LD_VAR 0 4
7511: PUSH
7512: LD_INT 75
7514: GREATEREQUAL
7515: AND
7516: IFFALSE 7526
// P = 74 ;
7518: LD_ADDR_VAR 0 4
7522: PUSH
7523: LD_INT 74
7525: ST_TO_ADDR
// if P < 18 then
7526: LD_VAR 0 4
7530: PUSH
7531: LD_INT 18
7533: LESS
7534: IFFALSE 7554
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
7536: LD_ADDR_VAR 0 3
7540: PUSH
7541: LD_INT 22
7543: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7544: LD_ADDR_VAR 0 2
7548: PUSH
7549: LD_INT 11
7551: ST_TO_ADDR
// end else
7552: GO 7654
// if P < 25 then
7554: LD_VAR 0 4
7558: PUSH
7559: LD_INT 25
7561: LESS
7562: IFFALSE 7582
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
7564: LD_ADDR_VAR 0 3
7568: PUSH
7569: LD_INT 24
7571: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_INT 11
7579: ST_TO_ADDR
// end else
7580: GO 7654
// if P < 50 then
7582: LD_VAR 0 4
7586: PUSH
7587: LD_INT 50
7589: LESS
7590: IFFALSE 7610
// begin Weapon = AR_FLAME_THROWER ;
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_INT 26
7599: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7600: LD_ADDR_VAR 0 2
7604: PUSH
7605: LD_INT 13
7607: ST_TO_ADDR
// end else
7608: GO 7654
// if P < 75 then
7610: LD_VAR 0 4
7614: PUSH
7615: LD_INT 75
7617: LESS
7618: IFFALSE 7638
// begin Weapon = AR_GUN ;
7620: LD_ADDR_VAR 0 3
7624: PUSH
7625: LD_INT 27
7627: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7628: LD_ADDR_VAR 0 2
7632: PUSH
7633: LD_INT 13
7635: ST_TO_ADDR
// end else
7636: GO 7654
// begin Weapon = AR_ROCKET_LAUNCHER ;
7638: LD_ADDR_VAR 0 3
7642: PUSH
7643: LD_INT 28
7645: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7646: LD_ADDR_VAR 0 2
7650: PUSH
7651: LD_INT 13
7653: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
7654: LD_ADDR_VAR 0 2
7658: PUSH
7659: LD_VAR 0 2
7663: PPUSH
7664: LD_INT 14
7666: PPUSH
7667: CALL_OW 12
7671: ST_TO_ADDR
// AddComConstruct ( LeFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
7672: LD_INT 26
7674: PPUSH
7675: LD_VAR 0 2
7679: PPUSH
7680: LD_INT 3
7682: PPUSH
7683: LD_INT 1
7685: PPUSH
7686: LD_VAR 0 3
7690: PPUSH
7691: CALL_OW 185
// end ;
7695: LD_VAR 0 1
7699: RET
// function vyrob_autaky ; var I ; begin
7700: LD_INT 0
7702: PPUSH
7703: PPUSH
// for I in Ridici do
7704: LD_ADDR_VAR 0 2
7708: PUSH
7709: LD_LOC 12
7713: PUSH
7714: FOR_IN
7715: IFFALSE 7723
// vyrob_autak ;
7717: CALL 7476 0 0
7721: GO 7714
7723: POP
7724: POP
// end ;
7725: LD_VAR 0 1
7729: RET
// every 0 0$25 do
7730: GO 7732
7732: DISABLE
// begin vyrob_autaky ;
7733: CALL 7700 0 0
// end ;
7737: END
// export function legion_VehicleConstructed ( Veh , Fact ) ; var Ridic ; begin
7738: LD_INT 0
7740: PPUSH
7741: PPUSH
// if GetSide ( Veh ) = side_Le then
7742: LD_VAR 0 1
7746: PPUSH
7747: CALL_OW 255
7751: PUSH
7752: LD_EXP 4
7756: EQUAL
7757: IFFALSE 7861
// begin Wait ( 0 0$2.5 ) ;
7759: LD_INT 88
7761: PPUSH
7762: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
7766: LD_ADDR_VAR 0 4
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL_OW 311
7780: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
7781: LD_INT 105
7783: PPUSH
7784: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
7788: LD_VAR 0 4
7792: PPUSH
7793: CALL_OW 121
// Wait ( 0 0$1 ) ;
7797: LD_INT 35
7799: PPUSH
7800: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
7804: LD_VAR 0 1
7808: PPUSH
7809: CALL_OW 311
7813: PUSH
7814: LD_VAR 0 4
7818: EQUAL
7819: IFFALSE 7830
// Wait ( 0 0$1 ) ;
7821: LD_INT 35
7823: PPUSH
7824: CALL_OW 67
7828: GO 7804
// AddComEnterUnit ( Ridic , Fact ) ;
7830: LD_VAR 0 4
7834: PPUSH
7835: LD_VAR 0 2
7839: PPUSH
7840: CALL_OW 180
// AddMcUnits ( Makro , [ Veh ] ) ;
7844: LD_LOC 23
7848: PPUSH
7849: LD_VAR 0 1
7853: PUSH
7854: EMPTY
7855: LIST
7856: PPUSH
7857: CALL_OW 390
// end ; end ;
7861: LD_VAR 0 3
7865: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
7866: LD_INT 0
7868: PPUSH
7869: PPUSH
7870: PPUSH
// Lidi = UnitFilter ( Ridici , [ [ F_OUTSIDE ] ] ) ;
7871: LD_ADDR_VAR 0 3
7875: PUSH
7876: LD_LOC 12
7880: PPUSH
7881: LD_INT 56
7883: PUSH
7884: EMPTY
7885: LIST
7886: PUSH
7887: EMPTY
7888: LIST
7889: PPUSH
7890: CALL_OW 72
7894: ST_TO_ADDR
// for I in Lidi do
7895: LD_ADDR_VAR 0 4
7899: PUSH
7900: LD_VAR 0 3
7904: PUSH
7905: FOR_IN
7906: IFFALSE 7940
// if not HasTask ( I ) then
7908: LD_VAR 0 4
7912: PPUSH
7913: CALL_OW 314
7917: NOT
7918: IFFALSE 7938
// begin ComEnterUnit ( I , Veh ) ;
7920: LD_VAR 0 4
7924: PPUSH
7925: LD_VAR 0 1
7929: PPUSH
7930: CALL_OW 120
// exit ;
7934: POP
7935: POP
7936: GO 7942
// end ;
7938: GO 7905
7940: POP
7941: POP
// end ;
7942: LD_VAR 0 2
7946: RET
// function nastupuj_auta ; var Auta , I ; begin
7947: LD_INT 0
7949: PPUSH
7950: PPUSH
7951: PPUSH
// Auta = FilterUnitsInArea ( LegionObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: LD_INT 16
7959: PPUSH
7960: LD_INT 21
7962: PUSH
7963: LD_INT 2
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 33
7972: PUSH
7973: LD_INT 1
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 58
7982: PUSH
7983: EMPTY
7984: LIST
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: LIST
7990: PPUSH
7991: CALL_OW 70
7995: ST_TO_ADDR
// if not Auta then
7996: LD_VAR 0 2
8000: NOT
8001: IFFALSE 8005
// exit ;
8003: GO 8031
// for I in Auta do
8005: LD_ADDR_VAR 0 3
8009: PUSH
8010: LD_VAR 0 2
8014: PUSH
8015: FOR_IN
8016: IFFALSE 8029
// zarid_ridice ( I ) ;
8018: LD_VAR 0 3
8022: PPUSH
8023: CALL 7866 0 1
8027: GO 8015
8029: POP
8030: POP
// end ;
8031: LD_VAR 0 1
8035: RET
// every 0 0$18 do
8036: GO 8038
8038: DISABLE
// begin nastupuj_auta ;
8039: CALL 7947 0 0
// enable ;
8043: ENABLE
// end ;
8044: END
// function zavolej ; var V , R ; begin
8045: LD_INT 0
8047: PPUSH
8048: PPUSH
8049: PPUSH
// DialogueOn ;
8050: CALL_OW 6
// Nabidka_Cena = [ 0 , 0 ] ;
8054: LD_ADDR_LOC 19
8058: PUSH
8059: LD_INT 0
8061: PUSH
8062: LD_INT 0
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
8069: LD_ADDR_LOC 20
8073: PUSH
8074: LD_INT 0
8076: ST_TO_ADDR
// if HeikeKilled or not MercAccepted then
8077: LD_EXP 37
8081: PUSH
8082: LD_EXP 34
8086: NOT
8087: OR
8088: IFFALSE 8221
// begin LegionOffer_Heike = false ;
8090: LD_ADDR_EXP 58
8094: PUSH
8095: LD_INT 0
8097: ST_TO_ADDR
// dialog_LegionOfferFarmer ;
8098: CALL 4985 0 0
// V = query_LegionFarmer ;
8102: LD_ADDR_VAR 0 2
8106: PUSH
8107: CALL 5029 0 0
8111: ST_TO_ADDR
// if V < 4 then
8112: LD_VAR 0 2
8116: PUSH
8117: LD_INT 4
8119: LESS
8120: IFFALSE 8207
// begin LegionOffer_Accepted = true ;
8122: LD_ADDR_EXP 59
8126: PUSH
8127: LD_INT 1
8129: ST_TO_ADDR
// dialog_QrLegionFarmer13 ;
8130: CALL 5050 0 0
// Nabidka_Cena = [ [ 60 , 15 ] , [ 90 , 25 ] , [ 120 , 30 ] ] [ V ] ;
8134: LD_ADDR_LOC 19
8138: PUSH
8139: LD_INT 60
8141: PUSH
8142: LD_INT 15
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 90
8151: PUSH
8152: LD_INT 25
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: LD_INT 120
8161: PUSH
8162: LD_INT 30
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: LIST
8173: PUSH
8174: LD_VAR 0 2
8178: ARRAY
8179: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8180: LD_ADDR_LOC 20
8184: PUSH
8185: LD_INT 3
8187: PUSH
8188: LD_INT 5
8190: PUSH
8191: LD_INT 7
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: PUSH
8199: LD_VAR 0 2
8203: ARRAY
8204: ST_TO_ADDR
// end else
8205: GO 8219
// begin LegionOffer_Accepted = false ;
8207: LD_ADDR_EXP 59
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// dialog_QrLegionFarmer4 ;
8215: CALL 5070 0 0
// end ; end else
8219: GO 8372
// begin LegionOffer_Heike = true ;
8221: LD_ADDR_EXP 58
8225: PUSH
8226: LD_INT 1
8228: ST_TO_ADDR
// if MercPaid and OmarKilled then
8229: LD_EXP 33
8233: PUSH
8234: LD_EXP 38
8238: AND
8239: IFFALSE 8247
// dialog_LegionOfferHeike1 else
8241: CALL 4816 0 0
8245: GO 8251
// dialog_LegionOfferHeike2 ;
8247: CALL 4860 0 0
// dialog_LegionOfferHeikeCont ;
8251: CALL 4904 0 0
// V = query_LegionHeike ;
8255: LD_ADDR_VAR 0 2
8259: PUSH
8260: CALL 4924 0 0
8264: ST_TO_ADDR
// if V < 4 then
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 4
8272: LESS
8273: IFFALSE 8360
// begin LegionOffer_Accepted = true ;
8275: LD_ADDR_EXP 59
8279: PUSH
8280: LD_INT 1
8282: ST_TO_ADDR
// dialog_QrLegionHeike13 ;
8283: CALL 4945 0 0
// Nabidka_Cena = [ [ 50 , 10 ] , [ 75 , 15 ] , [ 100 , 20 ] ] [ V ] ;
8287: LD_ADDR_LOC 19
8291: PUSH
8292: LD_INT 50
8294: PUSH
8295: LD_INT 10
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PUSH
8302: LD_INT 75
8304: PUSH
8305: LD_INT 15
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PUSH
8312: LD_INT 100
8314: PUSH
8315: LD_INT 20
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: LIST
8326: PUSH
8327: LD_VAR 0 2
8331: ARRAY
8332: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8333: LD_ADDR_LOC 20
8337: PUSH
8338: LD_INT 3
8340: PUSH
8341: LD_INT 5
8343: PUSH
8344: LD_INT 7
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_VAR 0 2
8356: ARRAY
8357: ST_TO_ADDR
// end else
8358: GO 8372
// begin LegionOffer_Accepted = false ;
8360: LD_ADDR_EXP 59
8364: PUSH
8365: LD_INT 0
8367: ST_TO_ADDR
// dialog_QrLegionHeike4 ;
8368: CALL 4965 0 0
// end ; end ; if LegionOffer_Accepted then
8372: LD_EXP 59
8376: IFFALSE 8487
// begin SA_OnLegionHired ;
8378: CALL 22763 0 0
// Nabidka_Nakladaky = [ vytvor_nakladak , vytvor_nakladak ] ;
8382: LD_ADDR_LOC 17
8386: PUSH
8387: CALL 10043 0 0
8391: PUSH
8392: CALL 10043 0 0
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
8401: LD_ADDR_LOC 18
8405: PUSH
8406: EMPTY
8407: ST_TO_ADDR
// for V in Nabidka_Nakladaky do
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_LOC 17
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8462
// begin PlaceUnitArea ( V , LegionVstup , false ) ;
8421: LD_VAR 0 2
8425: PPUSH
8426: LD_INT 10
8428: PPUSH
8429: LD_INT 0
8431: PPUSH
8432: CALL_OW 49
// Nabidka_Ridici = Nabidka_Ridici union [ IsDrivenBy ( V ) ] ;
8436: LD_ADDR_LOC 18
8440: PUSH
8441: LD_LOC 18
8445: PUSH
8446: LD_VAR 0 2
8450: PPUSH
8451: CALL_OW 311
8455: PUSH
8456: EMPTY
8457: LIST
8458: UNION
8459: ST_TO_ADDR
// end ;
8460: GO 8418
8462: POP
8463: POP
// Hint ( LegionHelp ) ;
8464: LD_STRING LegionHelp
8466: PPUSH
8467: CALL_OW 339
// enable ( 12 ) ;
8471: LD_INT 12
8473: ENABLE_MARKED
// enable ( 15 ) ;
8474: LD_INT 15
8476: ENABLE_MARKED
// ProbihaPredavaniSurovin = true ;
8477: LD_ADDR_LOC 26
8481: PUSH
8482: LD_INT 1
8484: ST_TO_ADDR
// end else
8485: GO 8490
// begin enable ( 11 ) ;
8487: LD_INT 11
8489: ENABLE_MARKED
// end ; DialogueOff ;
8490: CALL_OW 7
// end ;
8494: LD_VAR 0 1
8498: RET
// function ma_dost_materialu ( Bud ) ; var Base , Cans , Sib ; begin
8499: LD_INT 0
8501: PPUSH
8502: PPUSH
8503: PPUSH
8504: PPUSH
// Base = GetBase ( Bud ) ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_VAR 0 1
8514: PPUSH
8515: CALL_OW 274
8519: ST_TO_ADDR
// Cans = Nabidka_Cena [ 1 ] ;
8520: LD_ADDR_VAR 0 4
8524: PUSH
8525: LD_LOC 19
8529: PUSH
8530: LD_INT 1
8532: ARRAY
8533: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
8534: LD_ADDR_VAR 0 5
8538: PUSH
8539: LD_LOC 19
8543: PUSH
8544: LD_INT 2
8546: ARRAY
8547: ST_TO_ADDR
// Result = ( GetResourceType ( Base , MAT_CANS ) >= Cans ) and ( GetResourceType ( Base , MAT_SIBERIT ) >= Sib ) ;
8548: LD_ADDR_VAR 0 2
8552: PUSH
8553: LD_VAR 0 3
8557: PPUSH
8558: LD_INT 1
8560: PPUSH
8561: CALL_OW 275
8565: PUSH
8566: LD_VAR 0 4
8570: GREATEREQUAL
8571: PUSH
8572: LD_VAR 0 3
8576: PPUSH
8577: LD_INT 3
8579: PPUSH
8580: CALL_OW 275
8584: PUSH
8585: LD_VAR 0 5
8589: GREATEREQUAL
8590: AND
8591: ST_TO_ADDR
// end ;
8592: LD_VAR 0 2
8596: RET
// function naloz ( Veh , Bud , Mat , Amount ) ; var Base , Res ; begin
8597: LD_INT 0
8599: PPUSH
8600: PPUSH
8601: PPUSH
// Base = GetBase ( Bud ) ;
8602: LD_ADDR_VAR 0 6
8606: PUSH
8607: LD_VAR 0 2
8611: PPUSH
8612: CALL_OW 274
8616: ST_TO_ADDR
// Result = CanCarryHowMuch ( Veh ) ;
8617: LD_ADDR_VAR 0 5
8621: PUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 466
8631: ST_TO_ADDR
// if Result > Amount then
8632: LD_VAR 0 5
8636: PUSH
8637: LD_VAR 0 4
8641: GREATER
8642: IFFALSE 8654
// Result = Amount ;
8644: LD_ADDR_VAR 0 5
8648: PUSH
8649: LD_VAR 0 4
8653: ST_TO_ADDR
// Res = GetResourceType ( Base , Mat ) ;
8654: LD_ADDR_VAR 0 7
8658: PUSH
8659: LD_VAR 0 6
8663: PPUSH
8664: LD_VAR 0 3
8668: PPUSH
8669: CALL_OW 275
8673: ST_TO_ADDR
// if Result > Res then
8674: LD_VAR 0 5
8678: PUSH
8679: LD_VAR 0 7
8683: GREATER
8684: IFFALSE 8696
// Result = Res ;
8686: LD_ADDR_VAR 0 5
8690: PUSH
8691: LD_VAR 0 7
8695: ST_TO_ADDR
// SetResourceType ( Base , Mat , Res - Amount ) ;
8696: LD_VAR 0 6
8700: PPUSH
8701: LD_VAR 0 3
8705: PPUSH
8706: LD_VAR 0 7
8710: PUSH
8711: LD_VAR 0 4
8715: MINUS
8716: PPUSH
8717: CALL_OW 277
// AddCargo ( Veh , Mat , Result ) ;
8721: LD_VAR 0 1
8725: PPUSH
8726: LD_VAR 0 3
8730: PPUSH
8731: LD_VAR 0 5
8735: PPUSH
8736: CALL_OW 291
// end ;
8740: LD_VAR 0 5
8744: RET
// every 0 0$11 trigger KonvojPopojizdi and Nabidka_Nakladaky marked 16 do
8745: LD_LOC 16
8749: PUSH
8750: LD_LOC 17
8754: AND
8755: IFFALSE 8765
8757: GO 8759
8759: DISABLE
// begin popojizdej_konvoj ;
8760: CALL 8766 0 0
// enable ;
8764: ENABLE
// end ;
8765: END
// function popojizdej_konvoj ; var I , Hex ; begin
8766: LD_INT 0
8768: PPUSH
8769: PPUSH
8770: PPUSH
// for I in Nabidka_Nakladaky do
8771: LD_ADDR_VAR 0 2
8775: PUSH
8776: LD_LOC 17
8780: PUSH
8781: FOR_IN
8782: IFFALSE 8875
// begin if HasTask ( I ) then
8784: LD_VAR 0 2
8788: PPUSH
8789: CALL_OW 314
8793: IFFALSE 8797
// continue ;
8795: GO 8781
// if not IsDrivenBy ( I ) then
8797: LD_VAR 0 2
8801: PPUSH
8802: CALL_OW 311
8806: NOT
8807: IFFALSE 8811
// continue ;
8809: GO 8781
// Hex = RandHexXYR ( Uprchlici_X , Uprchlici_Y , 8 , false ) ;
8811: LD_ADDR_VAR 0 3
8815: PUSH
8816: LD_LOC 14
8820: PPUSH
8821: LD_LOC 15
8825: PPUSH
8826: LD_INT 8
8828: PPUSH
8829: LD_INT 0
8831: PPUSH
8832: CALL_OW 17
8836: ST_TO_ADDR
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
8837: LD_VAR 0 2
8841: PPUSH
8842: LD_VAR 0 3
8846: PUSH
8847: LD_INT 1
8849: ARRAY
8850: PPUSH
8851: LD_VAR 0 3
8855: PUSH
8856: LD_INT 2
8858: ARRAY
8859: PPUSH
8860: CALL_OW 111
// AddComHold ( I ) ;
8864: LD_VAR 0 2
8868: PPUSH
8869: CALL_OW 200
// end ;
8873: GO 8781
8875: POP
8876: POP
// end ;
8877: LD_VAR 0 1
8881: RET
// function zacni_popojizdet ; begin
8882: LD_INT 0
8884: PPUSH
// if not KonvojPopojizdi then
8885: LD_LOC 16
8889: NOT
8890: IFFALSE 8903
// begin enable ( 16 ) ;
8892: LD_INT 16
8894: ENABLE_MARKED
// KonvojPopojizdi = true ;
8895: LD_ADDR_LOC 16
8899: PUSH
8900: LD_INT 1
8902: ST_TO_ADDR
// end ; end ;
8903: LD_VAR 0 1
8907: RET
// function prestan_popojizdet ; begin
8908: LD_INT 0
8910: PPUSH
// if KonvojPopojizdi then
8911: LD_LOC 16
8915: IFFALSE 8928
// begin disable ( 16 ) ;
8917: LD_INT 16
8919: DISABLE_MARKED
// KonvojPopojizdi = false ;
8920: LD_ADDR_LOC 16
8924: PUSH
8925: LD_INT 0
8927: ST_TO_ADDR
// end ; end ;
8928: LD_VAR 0 1
8932: RET
// function ovladani_nakladaku ; var RuDepot , Bud , J , I , Cans , Sib , N1 , N2 , Ok , Ridic , Nakladak ; begin
8933: LD_INT 0
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
8939: PPUSH
8940: PPUSH
8941: PPUSH
8942: PPUSH
8943: PPUSH
8944: PPUSH
8945: PPUSH
8946: PPUSH
// if not Nabidka_Nalozeno then
8947: LD_LOC 21
8951: NOT
8952: IFFALSE 9543
// begin Ok = true ;
8954: LD_ADDR_VAR 0 10
8958: PUSH
8959: LD_INT 1
8961: ST_TO_ADDR
// for I = 1 to Nabidka_Nakladaky do
8962: LD_ADDR_VAR 0 5
8966: PUSH
8967: DOUBLE
8968: LD_INT 1
8970: DEC
8971: ST_TO_ADDR
8972: LD_LOC 17
8976: PUSH
8977: FOR_TO
8978: IFFALSE 9092
// begin Nakladak = Nabidka_Nakladaky [ I ] ;
8980: LD_ADDR_VAR 0 12
8984: PUSH
8985: LD_LOC 17
8989: PUSH
8990: LD_VAR 0 5
8994: ARRAY
8995: ST_TO_ADDR
// Ridic = Nabidka_Ridici [ I ] ;
8996: LD_ADDR_VAR 0 11
9000: PUSH
9001: LD_LOC 18
9005: PUSH
9006: LD_VAR 0 5
9010: ARRAY
9011: ST_TO_ADDR
// if GetLives ( Nakladak ) < HRANICE_ZDRAVI then
9012: LD_VAR 0 12
9016: PPUSH
9017: CALL_OW 256
9021: PUSH
9022: LD_INT 1000
9024: LESS
9025: IFFALSE 9051
// begin ComRepairVehicle ( Ridic , Nakladak ) ;
9027: LD_VAR 0 11
9031: PPUSH
9032: LD_VAR 0 12
9036: PPUSH
9037: CALL_OW 129
// Ok = false ;
9041: LD_ADDR_VAR 0 10
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// end else
9049: GO 9090
// begin if IsInUnit ( Ridic ) <> Nakladak then
9051: LD_VAR 0 11
9055: PPUSH
9056: CALL_OW 310
9060: PUSH
9061: LD_VAR 0 12
9065: NONEQUAL
9066: IFFALSE 9090
// begin ComEnterUnit ( Ridic , Nakladak ) ;
9068: LD_VAR 0 11
9072: PPUSH
9073: LD_VAR 0 12
9077: PPUSH
9078: CALL_OW 120
// Ok = false ;
9082: LD_ADDR_VAR 0 10
9086: PUSH
9087: LD_INT 0
9089: ST_TO_ADDR
// end ; end ; end ;
9090: GO 8977
9092: POP
9093: POP
// if not Ok then
9094: LD_VAR 0 10
9098: NOT
9099: IFFALSE 9103
// exit ;
9101: GO 9889
// Bud = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_DEPOT ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_WAREHOUSE ] ] ) ;
9103: LD_ADDR_VAR 0 3
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_EXP 2
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 52
9122: PUSH
9123: EMPTY
9124: LIST
9125: PUSH
9126: LD_INT 21
9128: PUSH
9129: LD_INT 3
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PUSH
9136: LD_INT 30
9138: PUSH
9139: LD_INT 0
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: PPUSH
9152: CALL_OW 69
9156: PUSH
9157: LD_INT 22
9159: PUSH
9160: LD_EXP 2
9164: PUSH
9165: EMPTY
9166: LIST
9167: LIST
9168: PUSH
9169: LD_INT 52
9171: PUSH
9172: EMPTY
9173: LIST
9174: PUSH
9175: LD_INT 21
9177: PUSH
9178: LD_INT 3
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: LD_INT 30
9187: PUSH
9188: LD_INT 1
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PUSH
9195: EMPTY
9196: LIST
9197: LIST
9198: LIST
9199: LIST
9200: PPUSH
9201: CALL_OW 69
9205: UNION
9206: ST_TO_ADDR
// RuDepot = 0 ;
9207: LD_ADDR_VAR 0 2
9211: PUSH
9212: LD_INT 0
9214: ST_TO_ADDR
// for I in Bud do
9215: LD_ADDR_VAR 0 5
9219: PUSH
9220: LD_VAR 0 3
9224: PUSH
9225: FOR_IN
9226: IFFALSE 9253
// if ma_dost_materialu ( I ) then
9228: LD_VAR 0 5
9232: PPUSH
9233: CALL 8499 0 1
9237: IFFALSE 9251
// begin RuDepot = I ;
9239: LD_ADDR_VAR 0 2
9243: PUSH
9244: LD_VAR 0 5
9248: ST_TO_ADDR
// break ;
9249: GO 9253
// end ;
9251: GO 9225
9253: POP
9254: POP
// if not RuDepot then
9255: LD_VAR 0 2
9259: NOT
9260: IFFALSE 9286
// if Bud then
9262: LD_VAR 0 3
9266: IFFALSE 9284
// RuDepot = Bud [ 1 ] else
9268: LD_ADDR_VAR 0 2
9272: PUSH
9273: LD_VAR 0 3
9277: PUSH
9278: LD_INT 1
9280: ARRAY
9281: ST_TO_ADDR
9282: GO 9286
// exit ;
9284: GO 9889
// Uprchlici_X = GetX ( RuDepot ) ;
9286: LD_ADDR_LOC 14
9290: PUSH
9291: LD_VAR 0 2
9295: PPUSH
9296: CALL_OW 250
9300: ST_TO_ADDR
// Uprchlici_Y = GetY ( RuDepot ) ;
9301: LD_ADDR_LOC 15
9305: PUSH
9306: LD_VAR 0 2
9310: PPUSH
9311: CALL_OW 251
9315: ST_TO_ADDR
// zacni_popojizdet ;
9316: CALL 8882 0 0
// for I in Nabidka_Nakladaky do
9320: LD_ADDR_VAR 0 5
9324: PUSH
9325: LD_LOC 17
9329: PUSH
9330: FOR_IN
9331: IFFALSE 9359
// if GetDistUnits ( I , RuDepot ) > 8 then
9333: LD_VAR 0 5
9337: PPUSH
9338: LD_VAR 0 2
9342: PPUSH
9343: CALL_OW 296
9347: PUSH
9348: LD_INT 8
9350: GREATER
9351: IFFALSE 9357
// exit ;
9353: POP
9354: POP
9355: GO 9889
9357: GO 9330
9359: POP
9360: POP
// if not ma_dost_materialu ( RuDepot ) then
9361: LD_VAR 0 2
9365: PPUSH
9366: CALL 8499 0 1
9370: NOT
9371: IFFALSE 9375
// exit ;
9373: GO 9889
// prestan_popojizdet ;
9375: CALL 8908 0 0
// Cans = Nabidka_Cena [ 1 ] ;
9379: LD_ADDR_VAR 0 6
9383: PUSH
9384: LD_LOC 19
9388: PUSH
9389: LD_INT 1
9391: ARRAY
9392: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
9393: LD_ADDR_VAR 0 7
9397: PUSH
9398: LD_LOC 19
9402: PUSH
9403: LD_INT 2
9405: ARRAY
9406: ST_TO_ADDR
// N1 = Nabidka_Nakladaky [ 1 ] ;
9407: LD_ADDR_VAR 0 8
9411: PUSH
9412: LD_LOC 17
9416: PUSH
9417: LD_INT 1
9419: ARRAY
9420: ST_TO_ADDR
// N2 = Nabidka_Nakladaky [ 2 ] ;
9421: LD_ADDR_VAR 0 9
9425: PUSH
9426: LD_LOC 17
9430: PUSH
9431: LD_INT 2
9433: ARRAY
9434: ST_TO_ADDR
// naloz ( N1 , RuDepot , MAT_SIBERIT , Sib ) ;
9435: LD_VAR 0 8
9439: PPUSH
9440: LD_VAR 0 2
9444: PPUSH
9445: LD_INT 3
9447: PPUSH
9448: LD_VAR 0 7
9452: PPUSH
9453: CALL 8597 0 4
// I = naloz ( N1 , RuDepot , MAT_CANS , min ( Cans , CanCarryHowMuch ( N1 ) ) ) ;
9457: LD_ADDR_VAR 0 5
9461: PUSH
9462: LD_VAR 0 8
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: LD_INT 1
9474: PPUSH
9475: LD_VAR 0 6
9479: PPUSH
9480: LD_VAR 0 8
9484: PPUSH
9485: CALL_OW 466
9489: PPUSH
9490: CALL 21532 0 2
9494: PPUSH
9495: CALL 8597 0 4
9499: ST_TO_ADDR
// naloz ( N2 , RuDepot , MAT_CANS , Cans - I ) ;
9500: LD_VAR 0 9
9504: PPUSH
9505: LD_VAR 0 2
9509: PPUSH
9510: LD_INT 1
9512: PPUSH
9513: LD_VAR 0 6
9517: PUSH
9518: LD_VAR 0 5
9522: MINUS
9523: PPUSH
9524: CALL 8597 0 4
// Nabidka_Nalozeno = true ;
9528: LD_ADDR_LOC 21
9532: PUSH
9533: LD_INT 1
9535: ST_TO_ADDR
// Wait ( 0 0$0.2 ) ;
9536: LD_INT 7
9538: PPUSH
9539: CALL_OW 67
// end ; prestan_popojizdet ;
9543: CALL 8908 0 0
// if not Nabidka_Vylozeno then
9547: LD_LOC 22
9551: NOT
9552: IFFALSE 9750
// begin MamPrebarvit = [ ] ;
9554: LD_ADDR_LOC 27
9558: PUSH
9559: EMPTY
9560: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9561: LD_ADDR_VAR 0 5
9565: PUSH
9566: LD_LOC 17
9570: PUSH
9571: FOR_IN
9572: IFFALSE 9635
// begin MamPrebarvit = MamPrebarvit union [ I ] ;
9574: LD_ADDR_LOC 27
9578: PUSH
9579: LD_LOC 27
9583: PUSH
9584: LD_VAR 0 5
9588: PUSH
9589: EMPTY
9590: LIST
9591: UNION
9592: ST_TO_ADDR
// J = IsDrivenBy ( I ) ;
9593: LD_ADDR_VAR 0 4
9597: PUSH
9598: LD_VAR 0 5
9602: PPUSH
9603: CALL_OW 311
9607: ST_TO_ADDR
// if J then
9608: LD_VAR 0 4
9612: IFFALSE 9633
// MamPrebarvit = MamPrebarvit union [ J ] ;
9614: LD_ADDR_LOC 27
9618: PUSH
9619: LD_LOC 27
9623: PUSH
9624: LD_VAR 0 4
9628: PUSH
9629: EMPTY
9630: LIST
9631: UNION
9632: ST_TO_ADDR
// end ;
9633: GO 9571
9635: POP
9636: POP
// Ok = true ;
9637: LD_ADDR_VAR 0 10
9641: PUSH
9642: LD_INT 1
9644: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9645: LD_ADDR_VAR 0 5
9649: PUSH
9650: LD_LOC 17
9654: PUSH
9655: FOR_IN
9656: IFFALSE 9731
// begin if not IsInArea ( I , Legion ) then
9658: LD_VAR 0 5
9662: PPUSH
9663: LD_INT 4
9665: PPUSH
9666: CALL_OW 308
9670: NOT
9671: IFFALSE 9729
// begin if not HasTask ( I ) then
9673: LD_VAR 0 5
9677: PPUSH
9678: CALL_OW 314
9682: NOT
9683: IFFALSE 9721
// begin ComMoveUnit ( I , LeDepot ) ;
9685: LD_VAR 0 5
9689: PPUSH
9690: LD_INT 20
9692: PPUSH
9693: CALL_OW 112
// AddComSailEvent ( I , 115 ) ;
9697: LD_VAR 0 5
9701: PPUSH
9702: LD_INT 115
9704: PPUSH
9705: CALL_OW 224
// AddComGive ( I , LeDepot ) ;
9709: LD_VAR 0 5
9713: PPUSH
9714: LD_INT 20
9716: PPUSH
9717: CALL_OW 221
// end ; Ok = false ;
9721: LD_ADDR_VAR 0 10
9725: PUSH
9726: LD_INT 0
9728: ST_TO_ADDR
// end ; end ;
9729: GO 9655
9731: POP
9732: POP
// if not Ok then
9733: LD_VAR 0 10
9737: NOT
9738: IFFALSE 9742
// exit ;
9740: GO 9889
// Nabidka_Vylozeno = true ;
9742: LD_ADDR_LOC 22
9746: PUSH
9747: LD_INT 1
9749: ST_TO_ADDR
// end ; Uprchlici = [ ] ;
9750: LD_ADDR_EXP 61
9754: PUSH
9755: EMPTY
9756: ST_TO_ADDR
// for I = 1 to Nabidka_Lidi do
9757: LD_ADDR_VAR 0 5
9761: PUSH
9762: DOUBLE
9763: LD_INT 1
9765: DEC
9766: ST_TO_ADDR
9767: LD_LOC 20
9771: PUSH
9772: FOR_TO
9773: IFFALSE 9796
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
9775: LD_ADDR_EXP 61
9779: PUSH
9780: LD_EXP 61
9784: PUSH
9785: CALL 9976 0 0
9789: PUSH
9790: EMPTY
9791: LIST
9792: UNION
9793: ST_TO_ADDR
9794: GO 9772
9796: POP
9797: POP
// for I in Uprchlici do
9798: LD_ADDR_VAR 0 5
9802: PUSH
9803: LD_EXP 61
9807: PUSH
9808: FOR_IN
9809: IFFALSE 9828
// PlaceUnitArea ( I , LegionVstup , false ) ;
9811: LD_VAR 0 5
9815: PPUSH
9816: LD_INT 10
9818: PPUSH
9819: LD_INT 0
9821: PPUSH
9822: CALL_OW 49
9826: GO 9808
9828: POP
9829: POP
// ComMoveXY ( Uprchlici , Uprchlici_X , Uprchlici_Y ) ;
9830: LD_EXP 61
9834: PPUSH
9835: LD_LOC 14
9839: PPUSH
9840: LD_LOC 15
9844: PPUSH
9845: CALL_OW 111
// AddComSailEvent ( Uprchlici , 111 ) ;
9849: LD_EXP 61
9853: PPUSH
9854: LD_INT 111
9856: PPUSH
9857: CALL_OW 224
// Nabidka_Nakladaky = [ ] ;
9861: LD_ADDR_LOC 17
9865: PUSH
9866: EMPTY
9867: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
9868: LD_ADDR_LOC 18
9872: PUSH
9873: EMPTY
9874: ST_TO_ADDR
// disable ( 12 ) ;
9875: LD_INT 12
9877: DISABLE_MARKED
// disable ( 15 ) ;
9878: LD_INT 15
9880: DISABLE_MARKED
// ProbihaPredavaniSurovin = false ;
9881: LD_ADDR_LOC 26
9885: PUSH
9886: LD_INT 0
9888: ST_TO_ADDR
// end ;
9889: LD_VAR 0 1
9893: RET
// export function event_KoupeniPrisli ; begin
9894: LD_INT 0
9896: PPUSH
// if not Uprchlici_JsouTam then
9897: LD_LOC 13
9901: NOT
9902: IFFALSE 9971
// begin DialogueOn ;
9904: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
9908: LD_EXP 61
9912: PPUSH
9913: CALL_OW 85
// Uprchlici_JsouTam = true ;
9917: LD_ADDR_LOC 13
9921: PUSH
9922: LD_INT 1
9924: ST_TO_ADDR
// SetSide ( Uprchlici , side_Ru ) ;
9925: LD_EXP 61
9929: PPUSH
9930: LD_EXP 2
9934: PPUSH
9935: CALL_OW 235
// Rusove2 = Uprchlici ;
9939: LD_ADDR_EXP 40
9943: PUSH
9944: LD_EXP 61
9948: ST_TO_ADDR
// uprchlik_jdi_k_labu ;
9949: CALL 10299 0 0
// Wait ( 0 0$5 ) ;
9953: LD_INT 175
9955: PPUSH
9956: CALL_OW 67
// Hint ( Legion ) ;
9960: LD_STRING Legion
9962: PPUSH
9963: CALL_OW 339
// DialogueOff ;
9967: CALL_OW 7
// end ; end ;
9971: LD_VAR 0 1
9975: RET
// function vytvor_uprchlika ; begin
9976: LD_INT 0
9978: PPUSH
// UC_Side = side_Upr ;
9979: LD_ADDR_OWVAR 20
9983: PUSH
9984: LD_EXP 5
9988: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
9989: LD_ADDR_OWVAR 21
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
9997: LD_ADDR_OWVAR 27
10001: PUSH
10002: LD_INT 1
10004: PPUSH
10005: LD_INT 2
10007: PPUSH
10008: CALL_OW 12
10012: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
10013: LD_ADDR_OWVAR 28
10017: PUSH
10018: LD_INT 1
10020: ST_TO_ADDR
// PrepareSoldierSkills ( 6 ) ;
10021: LD_INT 6
10023: PPUSH
10024: CALL_OW 375
// Result = CreateHuman ;
10028: LD_ADDR_VAR 0 1
10032: PUSH
10033: CALL_OW 44
10037: ST_TO_ADDR
// end ;
10038: LD_VAR 0 1
10042: RET
// function vytvor_nakladak ; var Ridic ; begin
10043: LD_INT 0
10045: PPUSH
10046: PPUSH
// UC_Side = side_Upr ;
10047: LD_ADDR_OWVAR 20
10051: PUSH
10052: LD_EXP 5
10056: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
10057: LD_ADDR_OWVAR 21
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
// VC_Chassis = AR_HALF_TRACKED ;
10065: LD_ADDR_OWVAR 37
10069: PUSH
10070: LD_INT 14
10072: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
10073: LD_ADDR_OWVAR 38
10077: PUSH
10078: LD_INT 1
10080: ST_TO_ADDR
// VC_Weapon = AR_CARGO_BAY ;
10081: LD_ADDR_OWVAR 40
10085: PUSH
10086: LD_INT 32
10088: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
10089: LD_ADDR_OWVAR 39
10093: PUSH
10094: LD_INT 3
10096: ST_TO_ADDR
// Result = CreateVehicle ;
10097: LD_ADDR_VAR 0 1
10101: PUSH
10102: CALL_OW 45
10106: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
10107: LD_ADDR_OWVAR 27
10111: PUSH
10112: LD_INT 1
10114: PPUSH
10115: LD_INT 2
10117: PPUSH
10118: CALL_OW 12
10122: ST_TO_ADDR
// HC_Class = CLASS_MECHANIC ;
10123: LD_ADDR_OWVAR 28
10127: PUSH
10128: LD_INT 3
10130: ST_TO_ADDR
// PrepareMechanicSkills ( 4 ) ;
10131: LD_INT 4
10133: PPUSH
10134: CALL_OW 377
// Ridic = CreateHuman ;
10138: LD_ADDR_VAR 0 2
10142: PUSH
10143: CALL_OW 44
10147: ST_TO_ADDR
// PlaceHumanInUnit ( Ridic , Result ) ;
10148: LD_VAR 0 2
10152: PPUSH
10153: LD_VAR 0 1
10157: PPUSH
10158: CALL_OW 52
// end ;
10162: LD_VAR 0 1
10166: RET
// function prchajici ; var I ; begin
10167: LD_INT 0
10169: PPUSH
10170: PPUSH
// Uprchlici = [ Bergkamp ] ;
10171: LD_ADDR_EXP 61
10175: PUSH
10176: LD_EXP 30
10180: PUSH
10181: EMPTY
10182: LIST
10183: ST_TO_ADDR
// for I = Difficulty to Rand ( 5 , 6 ) do
10184: LD_ADDR_VAR 0 2
10188: PUSH
10189: DOUBLE
10190: LD_OWVAR 67
10194: DEC
10195: ST_TO_ADDR
10196: LD_INT 5
10198: PPUSH
10199: LD_INT 6
10201: PPUSH
10202: CALL_OW 12
10206: PUSH
10207: FOR_TO
10208: IFFALSE 10231
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
10210: LD_ADDR_EXP 61
10214: PUSH
10215: LD_EXP 61
10219: PUSH
10220: CALL 9976 0 0
10224: PUSH
10225: EMPTY
10226: LIST
10227: UNION
10228: ST_TO_ADDR
10229: GO 10207
10231: POP
10232: POP
// for I in Uprchlici do
10233: LD_ADDR_VAR 0 2
10237: PUSH
10238: LD_EXP 61
10242: PUSH
10243: FOR_IN
10244: IFFALSE 10263
// PlaceUnitArea ( I , Legion , false ) ;
10246: LD_VAR 0 2
10250: PPUSH
10251: LD_INT 4
10253: PPUSH
10254: LD_INT 0
10256: PPUSH
10257: CALL_OW 49
10261: GO 10243
10263: POP
10264: POP
// ComMoveUnit ( Uprchlici , Burlak ) ;
10265: LD_EXP 61
10269: PPUSH
10270: LD_EXP 6
10274: PPUSH
10275: CALL_OW 112
// AddComSailEvent ( Uprchlici , 112 ) ;
10279: LD_EXP 61
10283: PPUSH
10284: LD_INT 112
10286: PPUSH
10287: CALL_OW 224
// enable ( 14 ) ;
10291: LD_INT 14
10293: ENABLE_MARKED
// end ;
10294: LD_VAR 0 1
10298: RET
// function uprchlik_jdi_k_labu ; var Laby , X , Y ; begin
10299: LD_INT 0
10301: PPUSH
10302: PPUSH
10303: PPUSH
10304: PPUSH
// Laby = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_HALF ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_FULL ] ] ) ;
10305: LD_ADDR_VAR 0 2
10309: PUSH
10310: LD_INT 22
10312: PUSH
10313: LD_EXP 2
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PUSH
10322: LD_INT 52
10324: PUSH
10325: EMPTY
10326: LIST
10327: PUSH
10328: LD_INT 21
10330: PUSH
10331: LD_INT 3
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PUSH
10338: LD_INT 30
10340: PUSH
10341: LD_INT 6
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PPUSH
10354: CALL_OW 69
10358: PUSH
10359: LD_INT 22
10361: PUSH
10362: LD_EXP 2
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PUSH
10371: LD_INT 52
10373: PUSH
10374: EMPTY
10375: LIST
10376: PUSH
10377: LD_INT 21
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 30
10389: PUSH
10390: LD_INT 7
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: PPUSH
10403: CALL_OW 69
10407: UNION
10408: PUSH
10409: LD_INT 22
10411: PUSH
10412: LD_EXP 2
10416: PUSH
10417: EMPTY
10418: LIST
10419: LIST
10420: PUSH
10421: LD_INT 52
10423: PUSH
10424: EMPTY
10425: LIST
10426: PUSH
10427: LD_INT 21
10429: PUSH
10430: LD_INT 3
10432: PUSH
10433: EMPTY
10434: LIST
10435: LIST
10436: PUSH
10437: LD_INT 30
10439: PUSH
10440: LD_INT 8
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: PUSH
10447: EMPTY
10448: LIST
10449: LIST
10450: LIST
10451: LIST
10452: PPUSH
10453: CALL_OW 69
10457: UNION
10458: ST_TO_ADDR
// if Laby then
10459: LD_VAR 0 2
10463: IFFALSE 10566
// begin Laby = nahoda_seznam ( Laby ) ;
10465: LD_ADDR_VAR 0 2
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: CALL 21673 0 1
10479: ST_TO_ADDR
// X = GetX ( Laby ) ;
10480: LD_ADDR_VAR 0 3
10484: PUSH
10485: LD_VAR 0 2
10489: PPUSH
10490: CALL_OW 250
10494: ST_TO_ADDR
// Y = GetY ( Laby ) ;
10495: LD_ADDR_VAR 0 4
10499: PUSH
10500: LD_VAR 0 2
10504: PPUSH
10505: CALL_OW 251
10509: ST_TO_ADDR
// if Bergkamp in Uprchlici then
10510: LD_EXP 30
10514: PUSH
10515: LD_EXP 61
10519: IN
10520: IFFALSE 10543
// AddComMoveXY ( Bergkamp , X , Y ) else
10522: LD_EXP 30
10526: PPUSH
10527: LD_VAR 0 3
10531: PPUSH
10532: LD_VAR 0 4
10536: PPUSH
10537: CALL_OW 171
10541: GO 10566
// AddComMoveXY ( Uprchlici [ 1 ] , X , Y ) ;
10543: LD_EXP 61
10547: PUSH
10548: LD_INT 1
10550: ARRAY
10551: PPUSH
10552: LD_VAR 0 3
10556: PPUSH
10557: LD_VAR 0 4
10561: PPUSH
10562: CALL_OW 171
// end ; end ;
10566: LD_VAR 0 1
10570: RET
// function uprchlici_dotaz ; var Q ; begin
10571: LD_INT 0
10573: PPUSH
10574: PPUSH
// if Uprchlici_JsouTam then
10575: LD_LOC 13
10579: IFFALSE 10583
// exit ;
10581: GO 10707
// disable ( 14 ) ;
10583: LD_INT 14
10585: DISABLE_MARKED
// Uprchlici_JsouTam = true ;
10586: LD_ADDR_LOC 13
10590: PUSH
10591: LD_INT 1
10593: ST_TO_ADDR
// DialogueOn ;
10594: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
10598: LD_EXP 61
10602: PPUSH
10603: CALL_OW 85
// Wait ( 0 0$3 ) ;
10607: LD_INT 105
10609: PPUSH
10610: CALL_OW 67
// dialog_LegionFugit ;
10614: CALL 5090 0 0
// Q = query_LegionBergkamp ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: CALL 5134 0 0
10627: ST_TO_ADDR
// if Q = 1 then
10628: LD_VAR 0 2
10632: PUSH
10633: LD_INT 1
10635: EQUAL
10636: IFFALSE 10687
// begin LegionFugit_Accepted = true ;
10638: LD_ADDR_EXP 60
10642: PUSH
10643: LD_INT 1
10645: ST_TO_ADDR
// dialog_QrLegionBergkamp1 ;
10646: CALL 5155 0 0
// SetSide ( Uprchlici , side_Ru ) ;
10650: LD_EXP 61
10654: PPUSH
10655: LD_EXP 2
10659: PPUSH
10660: CALL_OW 235
// Rusove2 = Uprchlici ;
10664: LD_ADDR_EXP 40
10668: PUSH
10669: LD_EXP 61
10673: ST_TO_ADDR
// Hint ( Legion ) ;
10674: LD_STRING Legion
10676: PPUSH
10677: CALL_OW 339
// uprchlik_jdi_k_labu ;
10681: CALL 10299 0 0
// end else
10685: GO 10703
// begin LegionFugit_Accepted = false ;
10687: LD_ADDR_EXP 60
10691: PUSH
10692: LD_INT 0
10694: ST_TO_ADDR
// dialog_QrLegionBergkamp2 ;
10695: CALL 5187 0 0
// uprchlici_zacnete_odchazet ;
10699: CALL 10712 0 0
// end ; DialogueOff ;
10703: CALL_OW 7
// end ;
10707: LD_VAR 0 1
10711: RET
// export function uprchlici_zacnete_odchazet ; begin
10712: LD_INT 0
10714: PPUSH
// ComMoveToArea ( Uprchlici , Legion ) ;
10715: LD_EXP 61
10719: PPUSH
10720: LD_INT 4
10722: PPUSH
10723: CALL_OW 113
// enable ( 13 ) ;
10727: LD_INT 13
10729: ENABLE_MARKED
// end ;
10730: LD_VAR 0 1
10734: RET
// export function event_LegionPrebarvi ; begin
10735: LD_INT 0
10737: PPUSH
// SetSide ( MamPrebarvit , side_Le ) ;
10738: LD_LOC 27
10742: PPUSH
10743: LD_EXP 4
10747: PPUSH
10748: CALL_OW 235
// MamPrebarvit = [ ] ;
10752: LD_ADDR_LOC 27
10756: PUSH
10757: EMPTY
10758: ST_TO_ADDR
// end ;
10759: LD_VAR 0 1
10763: RET
// export function event_UprchliciPrisli ; begin
10764: LD_INT 0
10766: PPUSH
// uprchlici_dotaz ;
10767: CALL 10571 0 0
// end ;
10771: LD_VAR 0 1
10775: RET
// every 0 0$3.9 marked 13 do var Tam , Kdo ;
10776: GO 10778
10778: DISABLE
10779: LD_INT 0
10781: PPUSH
10782: PPUSH
// begin if not Uprchlici then
10783: LD_EXP 61
10787: NOT
10788: IFFALSE 10792
// exit ;
10790: GO 10891
// Tam = Uprchlici isect FilterUnitsInArea ( Legion , [ [ F_SIDE , side_Upr ] ] ) ;
10792: LD_ADDR_VAR 0 1
10796: PUSH
10797: LD_EXP 61
10801: PUSH
10802: LD_INT 4
10804: PPUSH
10805: LD_INT 22
10807: PUSH
10808: LD_EXP 5
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: EMPTY
10818: LIST
10819: PPUSH
10820: CALL_OW 70
10824: ISECT
10825: ST_TO_ADDR
// SetSide ( Tam , side_Le ) ;
10826: LD_VAR 0 1
10830: PPUSH
10831: LD_EXP 4
10835: PPUSH
10836: CALL_OW 235
// Uprchlici = Uprchlici diff Tam ;
10840: LD_ADDR_EXP 61
10844: PUSH
10845: LD_EXP 61
10849: PUSH
10850: LD_VAR 0 1
10854: DIFF
10855: ST_TO_ADDR
// Rusove2 = Rusove2 diff Tam ;
10856: LD_ADDR_EXP 40
10860: PUSH
10861: LD_EXP 40
10865: PUSH
10866: LD_VAR 0 1
10870: DIFF
10871: ST_TO_ADDR
// if Uprchlici then
10872: LD_EXP 61
10876: IFFALSE 10891
// begin ComMoveToArea ( Uprchlici , Legion ) ;
10878: LD_EXP 61
10882: PPUSH
10883: LD_INT 4
10885: PPUSH
10886: CALL_OW 113
// enable ;
10890: ENABLE
// end ; end ;
10891: PPOPN 2
10893: END
// every 0 0$1.2 trigger vidi_strana_cloveka ( side_Upr , side_Ru ) marked 14 do
10894: LD_EXP 5
10898: PPUSH
10899: LD_EXP 2
10903: PPUSH
10904: CALL 21574 0 2
10908: IFFALSE 10935
10910: GO 10912
10912: DISABLE
// begin ComCancel ( Uprchlici ) ;
10913: LD_EXP 61
10917: PPUSH
10918: CALL_OW 127
// ComHold ( Uprchlici ) ;
10922: LD_EXP 61
10926: PPUSH
10927: CALL_OW 140
// uprchlici_dotaz ;
10931: CALL 10571 0 0
// end ;
10935: END
// every 13 13$0 do
10936: GO 10938
10938: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10939: LD_INT 35
10941: PPUSH
10942: LD_INT 4200
10944: PPUSH
10945: CALL_OW 12
10949: PPUSH
10950: CALL_OW 67
// while ProbihaUtok do
10954: LD_EXP 62
10958: IFFALSE 10969
// Wait ( 0 0$30 ) ;
10960: LD_INT 1050
10962: PPUSH
10963: CALL_OW 67
10967: GO 10954
// zavolej ;
10969: CALL 8045 0 0
// end ;
10973: END
// every 3 3$0 marked 11 do
10974: GO 10976
10976: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10977: LD_INT 35
10979: PPUSH
10980: LD_INT 4200
10982: PPUSH
10983: CALL_OW 12
10987: PPUSH
10988: CALL_OW 67
// prchajici ;
10992: CALL 10167 0 0
// end ;
10996: END
// every 0 0$4.9 marked 12 do
10997: GO 10999
10999: DISABLE
// begin enable ;
11000: ENABLE
// ovladani_nakladaku ;
11001: CALL 8933 0 0
// end ;
11005: END
// every 0 0$1 marked 15 do
11006: GO 11008
11008: DISABLE
// begin Wait ( dif_LegionTimeout [ Difficulty ] ) ;
11009: LD_EXP 57
11013: PUSH
11014: LD_OWVAR 67
11018: ARRAY
11019: PPUSH
11020: CALL_OW 67
// if not ProbihaPredavaniSurovin then
11024: LD_LOC 26
11028: NOT
11029: IFFALSE 11033
// exit ;
11031: GO 11037
// ukonci_nabidku ;
11033: CALL 11038 0 0
// end ;
11037: END
// function ukonci_nabidku ; var I ; begin
11038: LD_INT 0
11040: PPUSH
11041: PPUSH
// if Nabidka_Nalozeno then
11042: LD_LOC 21
11046: IFFALSE 11050
// exit ;
11048: GO 11183
// if Nabidka_Vylozeno then
11050: LD_LOC 22
11054: IFFALSE 11058
// exit ;
11056: GO 11183
// if not ProbihaPredavaniSurovin then
11058: LD_LOC 26
11062: NOT
11063: IFFALSE 11067
// exit ;
11065: GO 11183
// ProbihaPredavaniSurovin = false ;
11067: LD_ADDR_LOC 26
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
// prestan_popojizdet ;
11075: CALL 8908 0 0
// disable ( 12 ) ;
11079: LD_INT 12
11081: DISABLE_MARKED
// disable ( 15 ) ;
11082: LD_INT 15
11084: DISABLE_MARKED
// for I in Nabidka_Nakladaky do
11085: LD_ADDR_VAR 0 2
11089: PUSH
11090: LD_LOC 17
11094: PUSH
11095: FOR_IN
11096: IFFALSE 11152
// begin if ( GetSide ( I ) = side_Ru ) then
11098: LD_VAR 0 2
11102: PPUSH
11103: CALL_OW 255
11107: PUSH
11108: LD_EXP 2
11112: EQUAL
11113: IFFALSE 11117
// continue ;
11115: GO 11095
// SetSide ( I , side_Le ) ;
11117: LD_VAR 0 2
11121: PPUSH
11122: LD_EXP 4
11126: PPUSH
11127: CALL_OW 235
// SetSide ( IsDrivenBy ( I ) , side_Le ) ;
11131: LD_VAR 0 2
11135: PPUSH
11136: CALL_OW 311
11140: PPUSH
11141: LD_EXP 4
11145: PPUSH
11146: CALL_OW 235
// end ;
11150: GO 11095
11152: POP
11153: POP
// ComMoveToArea ( Nabidka_Nakladaky , LeDepot ) ;
11154: LD_LOC 17
11158: PPUSH
11159: LD_INT 20
11161: PPUSH
11162: CALL_OW 113
// Nabidka_Nakladaky = [ ] ;
11166: LD_ADDR_LOC 17
11170: PUSH
11171: EMPTY
11172: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
11173: LD_ADDR_LOC 18
11177: PUSH
11178: EMPTY
11179: ST_TO_ADDR
// enable ( 11 ) ;
11180: LD_INT 11
11182: ENABLE_MARKED
// end ;
11183: LD_VAR 0 1
11187: RET
// function testuj_konec_nabidky ( Un ) ; begin
11188: LD_INT 0
11190: PPUSH
// if ( Un in Nabidka_Nakladaky ) or ( Un in Nabidka_Ridici ) then
11191: LD_VAR 0 1
11195: PUSH
11196: LD_LOC 17
11200: IN
11201: PUSH
11202: LD_VAR 0 1
11206: PUSH
11207: LD_LOC 18
11211: IN
11212: OR
11213: IFFALSE 11219
// ukonci_nabidku ;
11215: CALL 11038 0 0
// end ;
11219: LD_VAR 0 2
11223: RET
// export function legion_Contact ( Side1 , Side2 ) ; begin
11224: LD_INT 0
11226: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Le ) ) or ( ( Side1 = side_Le ) and ( Side1 = side_Ru ) ) then
11227: LD_VAR 0 1
11231: PUSH
11232: LD_EXP 2
11236: EQUAL
11237: PUSH
11238: LD_VAR 0 2
11242: PUSH
11243: LD_EXP 4
11247: EQUAL
11248: AND
11249: PUSH
11250: LD_VAR 0 1
11254: PUSH
11255: LD_EXP 4
11259: EQUAL
11260: PUSH
11261: LD_VAR 0 1
11265: PUSH
11266: LD_EXP 2
11270: EQUAL
11271: AND
11272: OR
11273: IFFALSE 11285
// if ProbihaPredavaniSurovin then
11275: LD_LOC 26
11279: IFFALSE 11285
// ukonci_nabidku ;
11281: CALL 11038 0 0
// end ;
11285: LD_VAR 0 3
11289: RET
// export function legion_VehicleCaptured ( VewNew , VehOld , OrigSide , Hum ) ; begin
11290: LD_INT 0
11292: PPUSH
// testuj_konec_nabidky ( VehOld ) ;
11293: LD_VAR 0 2
11297: PPUSH
11298: CALL 11188 0 1
// end ;
11302: LD_VAR 0 5
11306: RET
// export function legion_UnitDestroyed ( Un ) ; var Cancel ; begin
11307: LD_INT 0
11309: PPUSH
11310: PPUSH
// if Un in Obranci then
11311: LD_VAR 0 1
11315: PUSH
11316: LD_LOC 10
11320: IN
11321: IFFALSE 11342
// Obranci = Obranci diff [ Un ] ;
11323: LD_ADDR_LOC 10
11327: PUSH
11328: LD_LOC 10
11332: PUSH
11333: LD_VAR 0 1
11337: PUSH
11338: EMPTY
11339: LIST
11340: DIFF
11341: ST_TO_ADDR
// if Un in Mechanici then
11342: LD_VAR 0 1
11346: PUSH
11347: LD_LOC 11
11351: IN
11352: IFFALSE 11373
// Mechanici = Mechanici diff [ Un ] ;
11354: LD_ADDR_LOC 11
11358: PUSH
11359: LD_LOC 11
11363: PUSH
11364: LD_VAR 0 1
11368: PUSH
11369: EMPTY
11370: LIST
11371: DIFF
11372: ST_TO_ADDR
// if Un in Ridici then
11373: LD_VAR 0 1
11377: PUSH
11378: LD_LOC 12
11382: IN
11383: IFFALSE 11404
// Ridici = Ridici diff [ Un ] ;
11385: LD_ADDR_LOC 12
11389: PUSH
11390: LD_LOC 12
11394: PUSH
11395: LD_VAR 0 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: DIFF
11403: ST_TO_ADDR
// if Un in Uprchlici then
11404: LD_VAR 0 1
11408: PUSH
11409: LD_EXP 61
11413: IN
11414: IFFALSE 11435
// Uprchlici = Uprchlici diff [ Un ] ;
11416: LD_ADDR_EXP 61
11420: PUSH
11421: LD_EXP 61
11425: PUSH
11426: LD_VAR 0 1
11430: PUSH
11431: EMPTY
11432: LIST
11433: DIFF
11434: ST_TO_ADDR
// if Un in KdoLeci then
11435: LD_VAR 0 1
11439: PUSH
11440: LD_LOC 24
11444: IN
11445: IFFALSE 11466
// KdoLeci = KdoLeci diff [ Un ] ;
11447: LD_ADDR_LOC 24
11451: PUSH
11452: LD_LOC 24
11456: PUSH
11457: LD_VAR 0 1
11461: PUSH
11462: EMPTY
11463: LIST
11464: DIFF
11465: ST_TO_ADDR
// if Un in KdoOpravuje then
11466: LD_VAR 0 1
11470: PUSH
11471: LD_LOC 25
11475: IN
11476: IFFALSE 11497
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
11478: LD_ADDR_LOC 25
11482: PUSH
11483: LD_LOC 25
11487: PUSH
11488: LD_VAR 0 1
11492: PUSH
11493: EMPTY
11494: LIST
11495: DIFF
11496: ST_TO_ADDR
// testuj_konec_nabidky ( Un ) ;
11497: LD_VAR 0 1
11501: PPUSH
11502: CALL 11188 0 1
// if Un in Nabidka_Nakladaky then
11506: LD_VAR 0 1
11510: PUSH
11511: LD_LOC 17
11515: IN
11516: IFFALSE 11537
// Nabidka_Nakladaky = Nabidka_Nakladaky diff [ Un ] ;
11518: LD_ADDR_LOC 17
11522: PUSH
11523: LD_LOC 17
11527: PUSH
11528: LD_VAR 0 1
11532: PUSH
11533: EMPTY
11534: LIST
11535: DIFF
11536: ST_TO_ADDR
// if Un in Nabidka_Ridici then
11537: LD_VAR 0 1
11541: PUSH
11542: LD_LOC 18
11546: IN
11547: IFFALSE 11568
// Nabidka_Ridici = Nabidka_Ridici diff [ Un ] ;
11549: LD_ADDR_LOC 18
11553: PUSH
11554: LD_LOC 18
11558: PUSH
11559: LD_VAR 0 1
11563: PUSH
11564: EMPTY
11565: LIST
11566: DIFF
11567: ST_TO_ADDR
// end ; end_of_file
11568: LD_VAR 0 2
11572: RET
// var ArSci1 , ArSci2 , ArSci3 , ArSci4 , ArMech1 , ArMech2 , ArEng1 , ArEng2 ; var ArMechDalkar ; var Obranci , Sejkove , VolnyLidi ; var Auta , Utok_Auta ; var KdoOtravuje ; var MakroObrana ; var Miny ; var ObranaBehemota ; var MakroKamikaze ; var RegUtok ; var VolnyRidiciOpicaci ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var MakroUtok ; export ProbihaUtok ; var CisloUtoku ; var PrvniUtok ; var Utok_ZbyvaMinut ; var CasyUtoku ; var PstZbrane ; var VidelRusa ; var MakroPresunZakladna ; var BeziStahovani ; var MaxOpice ; var ZpozdeniOpice ; var PstOpiceRus ; var OpiceLimit ; var OpiceNajednouPocet ; var KdoLeci ; var KdoOpravuje ; var KdoLakaOpice ; export function init_arabi ; var Reg , Base ; begin
11573: LD_INT 0
11575: PPUSH
11576: PPUSH
11577: PPUSH
// disable ( 31 ) ;
11578: LD_INT 31
11580: DISABLE_MARKED
// disable ( 32 ) ;
11581: LD_INT 32
11583: DISABLE_MARKED
// disable ( 33 ) ;
11584: LD_INT 33
11586: DISABLE_MARKED
// SetBName ( ArDepot , newsamark ) ;
11587: LD_INT 1
11589: PPUSH
11590: LD_STRING newsamark
11592: PPUSH
11593: CALL_OW 500
// KdoOtravuje = [ ] ;
11597: LD_ADDR_LOC 42
11601: PUSH
11602: EMPTY
11603: ST_TO_ADDR
// Auta = [ ] ;
11604: LD_ADDR_LOC 40
11608: PUSH
11609: EMPTY
11610: ST_TO_ADDR
// Utok_Auta = [ ] ;
11611: LD_ADDR_LOC 41
11615: PUSH
11616: EMPTY
11617: ST_TO_ADDR
// ObranaBehemota = [ ArProp1 , ArProp2 , ArProp3 ] ;
11618: LD_ADDR_LOC 45
11622: PUSH
11623: LD_INT 44
11625: PUSH
11626: LD_INT 45
11628: PUSH
11629: LD_INT 46
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: LIST
11636: ST_TO_ADDR
// VolnyRidiciOpicaci = 0 ;
11637: LD_ADDR_LOC 48
11641: PUSH
11642: LD_INT 0
11644: ST_TO_ADDR
// ArDalkar = 0 ;
11645: LD_ADDR_LOC 49
11649: PUSH
11650: LD_INT 0
11652: ST_TO_ADDR
// KolikDalkovych = 0 ;
11653: LD_ADDR_LOC 50
11657: PUSH
11658: LD_INT 0
11660: ST_TO_ADDR
// DelamDalkare = false ;
11661: LD_ADDR_LOC 51
11665: PUSH
11666: LD_INT 0
11668: ST_TO_ADDR
// ProbihaUtok = false ;
11669: LD_ADDR_EXP 62
11673: PUSH
11674: LD_INT 0
11676: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
11677: LD_ADDR_LOC 55
11681: PUSH
11682: LD_INT 1
11684: NEG
11685: ST_TO_ADDR
// CisloUtoku = 1 ;
11686: LD_ADDR_LOC 53
11690: PUSH
11691: LD_INT 1
11693: ST_TO_ADDR
// VidelRusa = false ;
11694: LD_ADDR_LOC 58
11698: PUSH
11699: LD_INT 0
11701: ST_TO_ADDR
// KdoLeci = [ ] ;
11702: LD_ADDR_LOC 66
11706: PUSH
11707: EMPTY
11708: ST_TO_ADDR
// KdoOpravuje = [ ] ;
11709: LD_ADDR_LOC 67
11713: PUSH
11714: EMPTY
11715: ST_TO_ADDR
// KdoLakaOpice = [ ] ;
11716: LD_ADDR_LOC 68
11720: PUSH
11721: EMPTY
11722: ST_TO_ADDR
// if Difficulty = 1 then
11723: LD_OWVAR 67
11727: PUSH
11728: LD_INT 1
11730: EQUAL
11731: IFFALSE 11747
// begin DestroyUnit ( ArBunk2 ) ;
11733: LD_INT 34
11735: PPUSH
11736: CALL_OW 65
// DestroyUnit ( ArBunk5 ) ;
11740: LD_INT 42
11742: PPUSH
11743: CALL_OW 65
// end ; PrvniUtok = dif_PrvniUtok [ Difficulty ] ;
11747: LD_ADDR_LOC 54
11751: PUSH
11752: LD_EXP 49
11756: PUSH
11757: LD_OWVAR 67
11761: ARRAY
11762: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
11763: LD_ADDR_LOC 56
11767: PUSH
11768: LD_EXP 48
11772: PUSH
11773: LD_OWVAR 67
11777: ARRAY
11778: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
11779: LD_ADDR_LOC 57
11783: PUSH
11784: LD_EXP 50
11788: PUSH
11789: LD_OWVAR 67
11793: ARRAY
11794: ST_TO_ADDR
// MaxOpice = dif_MaxOpice [ Difficulty ] ;
11795: LD_ADDR_LOC 61
11799: PUSH
11800: LD_EXP 51
11804: PUSH
11805: LD_OWVAR 67
11809: ARRAY
11810: ST_TO_ADDR
// ZpozdeniOpice = dif_ZpozdeniOpice [ Difficulty ] ;
11811: LD_ADDR_LOC 62
11815: PUSH
11816: LD_EXP 52
11820: PUSH
11821: LD_OWVAR 67
11825: ARRAY
11826: ST_TO_ADDR
// PstOpiceRus = dif_PstOpiceRus [ Difficulty ] ;
11827: LD_ADDR_LOC 63
11831: PUSH
11832: LD_EXP 53
11836: PUSH
11837: LD_OWVAR 67
11841: ARRAY
11842: ST_TO_ADDR
// OpiceLimit = dif_OpiceLimit [ Difficulty ] ;
11843: LD_ADDR_LOC 64
11847: PUSH
11848: LD_EXP 54
11852: PUSH
11853: LD_OWVAR 67
11857: ARRAY
11858: ST_TO_ADDR
// OpiceNajednouPocet = dif_OpiceNajednouPocet [ Difficulty ] ;
11859: LD_ADDR_LOC 65
11863: PUSH
11864: LD_EXP 55
11868: PUSH
11869: LD_OWVAR 67
11873: ARRAY
11874: ST_TO_ADDR
// vytvor_postavy ;
11875: CALL 12509 0 0
// Base = GetBase ( ArDepot ) ;
11879: LD_ADDR_VAR 0 3
11883: PUSH
11884: LD_INT 1
11886: PPUSH
11887: CALL_OW 274
11891: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 300 , 400 ) ) ;
11892: LD_VAR 0 3
11896: PPUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 300
11902: PPUSH
11903: LD_INT 400
11905: PPUSH
11906: CALL_OW 12
11910: PPUSH
11911: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 100 , 300 ) ) ;
11915: LD_VAR 0 3
11919: PPUSH
11920: LD_INT 2
11922: PPUSH
11923: LD_INT 100
11925: PPUSH
11926: LD_INT 300
11928: PPUSH
11929: CALL_OW 12
11933: PPUSH
11934: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 40 , 80 ) ) ;
11938: LD_VAR 0 3
11942: PPUSH
11943: LD_INT 3
11945: PPUSH
11946: LD_INT 40
11948: PPUSH
11949: LD_INT 80
11951: PPUSH
11952: CALL_OW 12
11956: PPUSH
11957: CALL_OW 277
// Reg = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , AraboveObrana ] ] ) ;
11961: LD_ADDR_VAR 0 2
11965: PUSH
11966: LD_EXP 3
11970: PPUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 12
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PUSH
11981: EMPTY
11982: LIST
11983: PPUSH
11984: CALL_OW 399
11988: ST_TO_ADDR
// MakroObrana = McDefend ( 0 , Reg , Sejkove union Obranci union VolnyLidi union [ ArBarracks , ArBunk1 , ArBunk2 , ArBunk3 , ArBunk4 , ArBunk5 , ArBunk6 ] , [ [ MC_AREA_DONT_LEAVE , Arabove ] ] ) ;
11989: LD_ADDR_LOC 43
11993: PUSH
11994: LD_INT 0
11996: PPUSH
11997: LD_VAR 0 2
12001: PPUSH
12002: LD_LOC 38
12006: PUSH
12007: LD_LOC 37
12011: UNION
12012: PUSH
12013: LD_LOC 39
12017: UNION
12018: PUSH
12019: LD_INT 32
12021: PUSH
12022: LD_INT 33
12024: PUSH
12025: LD_INT 34
12027: PUSH
12028: LD_INT 19
12030: PUSH
12031: LD_INT 41
12033: PUSH
12034: LD_INT 42
12036: PUSH
12037: LD_INT 18
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: UNION
12049: PPUSH
12050: LD_INT 2
12052: PUSH
12053: LD_INT 5
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: PPUSH
12063: CALL_OW 401
12067: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Sejkove union Obranci union VolnyLidi ) ;
12068: LD_ADDR_LOC 59
12072: PUSH
12073: LD_INT 1
12075: PPUSH
12076: LD_LOC 38
12080: PUSH
12081: LD_LOC 37
12085: UNION
12086: PUSH
12087: LD_LOC 39
12091: UNION
12092: PPUSH
12093: CALL_OW 416
12097: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , RusoveUtok ] , MC_REG_IGNORE_FOG ] ) ;
12098: LD_ADDR_LOC 47
12102: PUSH
12103: LD_EXP 3
12107: PPUSH
12108: LD_INT 2
12110: PUSH
12111: LD_INT 11
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: PUSH
12118: LD_INT 7
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: PPUSH
12125: CALL_OW 399
12129: ST_TO_ADDR
// MakroKamikaze = McAttack ( 20 , RegUtok , [ ] , [ MC_NO_STOP ] ) ;
12130: LD_ADDR_LOC 46
12134: PUSH
12135: LD_INT 20
12137: PPUSH
12138: LD_LOC 47
12142: PPUSH
12143: EMPTY
12144: PPUSH
12145: LD_INT 10
12147: PUSH
12148: EMPTY
12149: LIST
12150: PPUSH
12151: CALL_OW 402
12155: ST_TO_ADDR
// MakroUtok = 0 ;
12156: LD_ADDR_LOC 52
12160: PUSH
12161: LD_INT 0
12163: ST_TO_ADDR
// init_miny ;
12164: CALL 12173 0 0
// end ;
12168: LD_VAR 0 1
12172: RET
// function init_miny ; var M ; begin
12173: LD_INT 0
12175: PPUSH
12176: PPUSH
// if Difficulty = 1 then
12177: LD_OWVAR 67
12181: PUSH
12182: LD_INT 1
12184: EQUAL
12185: IFFALSE 12196
// Miny = [ ] else
12187: LD_ADDR_LOC 44
12191: PUSH
12192: EMPTY
12193: ST_TO_ADDR
12194: GO 12504
// begin Miny = [ [ 168 , 77 ] , [ 169 , 76 ] , [ 170 , 75 ] , [ 179 , 90 ] , [ 178 , 87 ] , [ 179 , 86 ] ] ;
12196: LD_ADDR_LOC 44
12200: PUSH
12201: LD_INT 168
12203: PUSH
12204: LD_INT 77
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: PUSH
12211: LD_INT 169
12213: PUSH
12214: LD_INT 76
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 170
12223: PUSH
12224: LD_INT 75
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 179
12233: PUSH
12234: LD_INT 90
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 178
12243: PUSH
12244: LD_INT 87
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 179
12253: PUSH
12254: LD_INT 86
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: ST_TO_ADDR
// if Difficulty = 3 then
12269: LD_OWVAR 67
12273: PUSH
12274: LD_INT 3
12276: EQUAL
12277: IFFALSE 12457
// Miny = Miny ^ [ [ 170 , 79 ] , [ 171 , 78 ] , [ 172 , 77 ] , [ 87 , 5 ] , [ 89 , 13 ] , [ 97 , 24 ] , [ 97 , 23 ] , [ 103 , 33 ] , [ 111 , 41 ] , [ 120 , 52 ] , [ 128 , 57 ] , [ 140 , 62 ] , [ 148 , 76 ] , [ 154 , 86 ] , [ 161 , 87 ] ] ;
12279: LD_ADDR_LOC 44
12283: PUSH
12284: LD_LOC 44
12288: PUSH
12289: LD_INT 170
12291: PUSH
12292: LD_INT 79
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 171
12301: PUSH
12302: LD_INT 78
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: LD_INT 172
12311: PUSH
12312: LD_INT 77
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 87
12321: PUSH
12322: LD_INT 5
12324: PUSH
12325: EMPTY
12326: LIST
12327: LIST
12328: PUSH
12329: LD_INT 89
12331: PUSH
12332: LD_INT 13
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: PUSH
12339: LD_INT 97
12341: PUSH
12342: LD_INT 24
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PUSH
12349: LD_INT 97
12351: PUSH
12352: LD_INT 23
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: PUSH
12359: LD_INT 103
12361: PUSH
12362: LD_INT 33
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PUSH
12369: LD_INT 111
12371: PUSH
12372: LD_INT 41
12374: PUSH
12375: EMPTY
12376: LIST
12377: LIST
12378: PUSH
12379: LD_INT 120
12381: PUSH
12382: LD_INT 52
12384: PUSH
12385: EMPTY
12386: LIST
12387: LIST
12388: PUSH
12389: LD_INT 128
12391: PUSH
12392: LD_INT 57
12394: PUSH
12395: EMPTY
12396: LIST
12397: LIST
12398: PUSH
12399: LD_INT 140
12401: PUSH
12402: LD_INT 62
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: PUSH
12409: LD_INT 148
12411: PUSH
12412: LD_INT 76
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PUSH
12419: LD_INT 154
12421: PUSH
12422: LD_INT 86
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: PUSH
12429: LD_INT 161
12431: PUSH
12432: LD_INT 87
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: ADD
12456: ST_TO_ADDR
// for M in Miny do
12457: LD_ADDR_VAR 0 2
12461: PUSH
12462: LD_LOC 44
12466: PUSH
12467: FOR_IN
12468: IFFALSE 12502
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
12470: LD_VAR 0 2
12474: PUSH
12475: LD_INT 1
12477: ARRAY
12478: PPUSH
12479: LD_VAR 0 2
12483: PUSH
12484: LD_INT 2
12486: ARRAY
12487: PPUSH
12488: LD_EXP 3
12492: PPUSH
12493: LD_INT 0
12495: PPUSH
12496: CALL_OW 454
12500: GO 12467
12502: POP
12503: POP
// end ; end ;
12504: LD_VAR 0 1
12508: RET
// function vytvor_postavy ; var Bunkry , B ; begin
12509: LD_INT 0
12511: PPUSH
12512: PPUSH
12513: PPUSH
// ArSci1 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12514: LD_ADDR_LOC 28
12518: PUSH
12519: LD_INT 11
12521: PPUSH
12522: LD_INT 4
12524: PPUSH
12525: CALL 13017 0 2
12529: ST_TO_ADDR
// ArSci2 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12530: LD_ADDR_LOC 29
12534: PUSH
12535: LD_INT 11
12537: PPUSH
12538: LD_INT 4
12540: PPUSH
12541: CALL 13017 0 2
12545: ST_TO_ADDR
// ArSci3 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12546: LD_ADDR_LOC 30
12550: PUSH
12551: LD_INT 12
12553: PPUSH
12554: LD_INT 4
12556: PPUSH
12557: CALL 13017 0 2
12561: ST_TO_ADDR
// ArSci4 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12562: LD_ADDR_LOC 31
12566: PUSH
12567: LD_INT 12
12569: PPUSH
12570: LD_INT 4
12572: PPUSH
12573: CALL 13017 0 2
12577: ST_TO_ADDR
// ArMech1 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12578: LD_ADDR_LOC 32
12582: PUSH
12583: LD_INT 5
12585: PPUSH
12586: LD_INT 3
12588: PPUSH
12589: CALL 13017 0 2
12593: ST_TO_ADDR
// ArMech2 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12594: LD_ADDR_LOC 33
12598: PUSH
12599: LD_INT 5
12601: PPUSH
12602: LD_INT 3
12604: PPUSH
12605: CALL 13017 0 2
12609: ST_TO_ADDR
// vytvor_postavu_B ( ArDepot , CLASS_ENGINEER ) ;
12610: LD_INT 1
12612: PPUSH
12613: LD_INT 2
12615: PPUSH
12616: CALL 13017 0 2
// ArEng1 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12620: LD_ADDR_LOC 34
12624: PUSH
12625: LD_INT 5
12627: PPUSH
12628: LD_INT 2
12630: PPUSH
12631: CALL 13054 0 2
12635: ST_TO_ADDR
// ArEng2 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12636: LD_ADDR_LOC 35
12640: PUSH
12641: LD_INT 5
12643: PPUSH
12644: LD_INT 2
12646: PPUSH
12647: CALL 13054 0 2
12651: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 2 + 2 * Difficulty , Arabove , CLASS_SOLDIER ) ;
12652: LD_ADDR_LOC 37
12656: PUSH
12657: LD_INT 2
12659: PUSH
12660: LD_INT 2
12662: PUSH
12663: LD_OWVAR 67
12667: MUL
12668: PLUS
12669: PPUSH
12670: LD_INT 5
12672: PPUSH
12673: LD_INT 1
12675: PPUSH
12676: CALL 13094 0 3
12680: ST_TO_ADDR
// VolnyLidi = vytvor_postavy_A ( 2 + dif_AraboveRidici [ Difficulty ] , Arabove , CLASS_SOLDIER ) ;
12681: LD_ADDR_LOC 39
12685: PUSH
12686: LD_INT 2
12688: PUSH
12689: LD_EXP 46
12693: PUSH
12694: LD_OWVAR 67
12698: ARRAY
12699: PLUS
12700: PPUSH
12701: LD_INT 5
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL 13094 0 3
12711: ST_TO_ADDR
// ArMechDalkar = vytvor_postavu_A ( Arabove , CLASS_MECHANIC ) ;
12712: LD_ADDR_LOC 36
12716: PUSH
12717: LD_INT 5
12719: PPUSH
12720: LD_INT 3
12722: PPUSH
12723: CALL 13054 0 2
12727: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
12728: LD_ADDR_VAR 0 2
12732: PUSH
12733: LD_INT 22
12735: PUSH
12736: LD_EXP 3
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 21
12747: PUSH
12748: LD_INT 3
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 30
12757: PUSH
12758: LD_INT 32
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: PPUSH
12770: CALL_OW 69
12774: ST_TO_ADDR
// for B in Bunkry do
12775: LD_ADDR_VAR 0 3
12779: PUSH
12780: LD_VAR 0 2
12784: PUSH
12785: FOR_IN
12786: IFFALSE 12817
// Obranci = Obranci union [ vytvor_postavu_B ( B , CLASS_SOLDIER ) ] ;
12788: LD_ADDR_LOC 37
12792: PUSH
12793: LD_LOC 37
12797: PUSH
12798: LD_VAR 0 3
12802: PPUSH
12803: LD_INT 1
12805: PPUSH
12806: CALL 13017 0 2
12810: PUSH
12811: EMPTY
12812: LIST
12813: UNION
12814: ST_TO_ADDR
12815: GO 12785
12817: POP
12818: POP
// if Abdul then
12819: LD_EXP 31
12823: IFFALSE 12840
// PlaceUnitArea ( Abdul , Arabove , false ) ;
12825: LD_EXP 31
12829: PPUSH
12830: LD_INT 5
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 49
// if Omar then
12840: LD_EXP 32
12844: IFFALSE 12861
// PlaceUnitArea ( Omar , Arabove , false ) ;
12846: LD_EXP 32
12850: PPUSH
12851: LD_INT 5
12853: PPUSH
12854: LD_INT 0
12856: PPUSH
12857: CALL_OW 49
// Sejkove = vytvor_postavy_A ( 1 + Difficulty , Arabove , CLASS_DESERT_WARIOR ) ;
12861: LD_ADDR_LOC 38
12865: PUSH
12866: LD_INT 1
12868: PUSH
12869: LD_OWVAR 67
12873: PLUS
12874: PPUSH
12875: LD_INT 5
12877: PPUSH
12878: LD_INT 11
12880: PPUSH
12881: CALL 13094 0 3
12885: ST_TO_ADDR
// if Abdul then
12886: LD_EXP 31
12890: IFFALSE 12911
// Sejkove = Sejkove union [ Abdul ] ;
12892: LD_ADDR_LOC 38
12896: PUSH
12897: LD_LOC 38
12901: PUSH
12902: LD_EXP 31
12906: PUSH
12907: EMPTY
12908: LIST
12909: UNION
12910: ST_TO_ADDR
// if Omar then
12911: LD_EXP 32
12915: IFFALSE 12936
// Sejkove = Sejkove union [ Omar ] ;
12917: LD_ADDR_LOC 38
12921: PUSH
12922: LD_LOC 38
12926: PUSH
12927: LD_EXP 32
12931: PUSH
12932: EMPTY
12933: LIST
12934: UNION
12935: ST_TO_ADDR
// end ;
12936: LD_VAR 0 1
12940: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
12941: LD_INT 0
12943: PPUSH
12944: PPUSH
12945: PPUSH
// UC_Side = side_Ar ;
12946: LD_ADDR_OWVAR 20
12950: PUSH
12951: LD_EXP 3
12955: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
12956: LD_ADDR_OWVAR 21
12960: PUSH
12961: LD_INT 2
12963: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
12964: LD_ADDR_OWVAR 27
12968: PUSH
12969: LD_INT 1
12971: PPUSH
12972: LD_INT 2
12974: PPUSH
12975: CALL_OW 12
12979: ST_TO_ADDR
// HC_Class = Cls ;
12980: LD_ADDR_OWVAR 28
12984: PUSH
12985: LD_VAR 0 1
12989: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
12990: LD_VAR 0 1
12994: PPUSH
12995: LD_INT 7
12997: PPUSH
12998: CALL_OW 374
// Result = CreateHuman ;
13002: LD_ADDR_VAR 0 2
13006: PUSH
13007: CALL_OW 44
13011: ST_TO_ADDR
// end ;
13012: LD_VAR 0 2
13016: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
13017: LD_INT 0
13019: PPUSH
// Result = vytvor_postavu ( Cls ) ;
13020: LD_ADDR_VAR 0 3
13024: PUSH
13025: LD_VAR 0 2
13029: PPUSH
13030: CALL 12941 0 1
13034: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
13035: LD_VAR 0 3
13039: PPUSH
13040: LD_VAR 0 1
13044: PPUSH
13045: CALL_OW 52
// end ;
13049: LD_VAR 0 3
13053: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
13054: LD_INT 0
13056: PPUSH
// Result = vytvor_postavu ( Cls ) ;
13057: LD_ADDR_VAR 0 3
13061: PUSH
13062: LD_VAR 0 2
13066: PPUSH
13067: CALL 12941 0 1
13071: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
13072: LD_VAR 0 3
13076: PPUSH
13077: LD_VAR 0 1
13081: PPUSH
13082: LD_INT 0
13084: PPUSH
13085: CALL_OW 49
// end ;
13089: LD_VAR 0 3
13093: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
13094: LD_INT 0
13096: PPUSH
13097: PPUSH
// Result = [ ] ;
13098: LD_ADDR_VAR 0 4
13102: PUSH
13103: EMPTY
13104: ST_TO_ADDR
// for I = 1 to Pocet do
13105: LD_ADDR_VAR 0 5
13109: PUSH
13110: DOUBLE
13111: LD_INT 1
13113: DEC
13114: ST_TO_ADDR
13115: LD_VAR 0 1
13119: PUSH
13120: FOR_TO
13121: IFFALSE 13154
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
13123: LD_ADDR_VAR 0 4
13127: PUSH
13128: LD_VAR 0 4
13132: PUSH
13133: LD_VAR 0 2
13137: PPUSH
13138: LD_VAR 0 3
13142: PPUSH
13143: CALL 13054 0 2
13147: PUSH
13148: EMPTY
13149: LIST
13150: UNION
13151: ST_TO_ADDR
13152: GO 13120
13154: POP
13155: POP
// end ;
13156: LD_VAR 0 4
13160: RET
// function zpet_do_labu ( Kdo ) ; begin
13161: LD_INT 0
13163: PPUSH
// if Kdo = ArSci1 then
13164: LD_VAR 0 1
13168: PUSH
13169: LD_LOC 28
13173: EQUAL
13174: IFFALSE 13190
// AddComEnterUnit ( Kdo , ArLabWS ) else
13176: LD_VAR 0 1
13180: PPUSH
13181: LD_INT 11
13183: PPUSH
13184: CALL_OW 180
13188: GO 13266
// if Kdo = ArSci2 then
13190: LD_VAR 0 1
13194: PUSH
13195: LD_LOC 29
13199: EQUAL
13200: IFFALSE 13216
// AddComEnterUnit ( Kdo , ArLabWS ) else
13202: LD_VAR 0 1
13206: PPUSH
13207: LD_INT 11
13209: PPUSH
13210: CALL_OW 180
13214: GO 13266
// if Kdo = ArSci3 then
13216: LD_VAR 0 1
13220: PUSH
13221: LD_LOC 30
13225: EQUAL
13226: IFFALSE 13242
// AddComEnterUnit ( Kdo , ArLabBO ) else
13228: LD_VAR 0 1
13232: PPUSH
13233: LD_INT 12
13235: PPUSH
13236: CALL_OW 180
13240: GO 13266
// if Kdo = ArSci4 then
13242: LD_VAR 0 1
13246: PUSH
13247: LD_LOC 31
13251: EQUAL
13252: IFFALSE 13266
// AddComEnterUnit ( Kdo , ArLabBO ) ;
13254: LD_VAR 0 1
13258: PPUSH
13259: LD_INT 12
13261: PPUSH
13262: CALL_OW 180
// end ;
13266: LD_VAR 0 2
13270: RET
// function zacni_vynalezat ; begin
13271: LD_INT 0
13273: PPUSH
// AddComResearch ( ArLabWS , TECH_ROCKET ) ;
13274: LD_INT 11
13276: PPUSH
13277: LD_INT 40
13279: PPUSH
13280: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_FLAME ) ;
13284: LD_INT 11
13286: PPUSH
13287: LD_INT 70
13289: PPUSH
13290: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_MORTAR ) ;
13294: LD_INT 11
13296: PPUSH
13297: LD_INT 41
13299: PPUSH
13300: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_EXPLOS ) ;
13304: LD_INT 11
13306: PPUSH
13307: LD_INT 42
13309: PPUSH
13310: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SELFDEST ) ;
13314: LD_INT 11
13316: PPUSH
13317: LD_INT 43
13319: PPUSH
13320: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP1 ) ;
13324: LD_INT 11
13326: PPUSH
13327: LD_INT 51
13329: PPUSH
13330: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB1 ) ;
13334: LD_INT 11
13336: PPUSH
13337: LD_INT 54
13339: PPUSH
13340: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP2 ) ;
13344: LD_INT 11
13346: PPUSH
13347: LD_INT 52
13349: PPUSH
13350: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB2 ) ;
13354: LD_INT 11
13356: PPUSH
13357: LD_INT 55
13359: PPUSH
13360: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP3 ) ;
13364: LD_INT 11
13366: PPUSH
13367: LD_INT 53
13369: PPUSH
13370: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB3 ) ;
13374: LD_INT 11
13376: PPUSH
13377: LD_INT 56
13379: PPUSH
13380: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_RADAR ) ;
13384: LD_INT 12
13386: PPUSH
13387: LD_INT 6
13389: PPUSH
13390: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_REMCONT ) ;
13394: LD_INT 12
13396: PPUSH
13397: LD_INT 15
13399: PPUSH
13400: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_STIMDRUGS ) ;
13404: LD_INT 12
13406: PPUSH
13407: LD_INT 5
13409: PPUSH
13410: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIODET ) ;
13414: LD_INT 12
13416: PPUSH
13417: LD_INT 8
13419: PPUSH
13420: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_MATDET ) ;
13424: LD_INT 12
13426: PPUSH
13427: LD_INT 7
13429: PPUSH
13430: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_HIDCAM ) ;
13434: LD_INT 12
13436: PPUSH
13437: LD_INT 17
13439: PPUSH
13440: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH1 ) ;
13444: LD_INT 12
13446: PPUSH
13447: LD_INT 48
13449: PPUSH
13450: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO1 ) ;
13454: LD_INT 12
13456: PPUSH
13457: LD_INT 66
13459: PPUSH
13460: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO1 ) ;
13464: LD_INT 12
13466: PPUSH
13467: LD_INT 60
13469: PPUSH
13470: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH2 ) ;
13474: LD_INT 12
13476: PPUSH
13477: LD_INT 49
13479: PPUSH
13480: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO2 ) ;
13484: LD_INT 12
13486: PPUSH
13487: LD_INT 67
13489: PPUSH
13490: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO2 ) ;
13494: LD_INT 12
13496: PPUSH
13497: LD_INT 61
13499: PPUSH
13500: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH3 ) ;
13504: LD_INT 12
13506: PPUSH
13507: LD_INT 50
13509: PPUSH
13510: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO3 ) ;
13514: LD_INT 12
13516: PPUSH
13517: LD_INT 68
13519: PPUSH
13520: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO3 ) ;
13524: LD_INT 12
13526: PPUSH
13527: LD_INT 62
13529: PPUSH
13530: CALL_OW 184
// end ;
13534: LD_VAR 0 1
13538: RET
// every 0 0$2.3 do
13539: GO 13541
13541: DISABLE
// begin zacni_vynalezat ;
13542: CALL 13271 0 0
// end ;
13546: END
// function otravuj ; var Vedci , Doly , I , Dul , X , Y ; begin
13547: LD_INT 0
13549: PPUSH
13550: PPUSH
13551: PPUSH
13552: PPUSH
13553: PPUSH
13554: PPUSH
13555: PPUSH
// Result = false ;
13556: LD_ADDR_VAR 0 1
13560: PUSH
13561: LD_INT 0
13563: ST_TO_ADDR
// if ( RusMaOtraveno >= 2 ) then
13564: LD_EXP 64
13568: PUSH
13569: LD_INT 2
13571: GREATEREQUAL
13572: IFFALSE 13576
// exit ;
13574: GO 14078
// if KdoOtravuje then
13576: LD_LOC 42
13580: IFFALSE 13584
// exit ;
13582: GO 14078
// Vedci = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
13584: LD_ADDR_VAR 0 2
13588: PUSH
13589: LD_INT 22
13591: PUSH
13592: LD_EXP 3
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 21
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 25
13613: PUSH
13614: LD_INT 4
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: LIST
13625: PPUSH
13626: CALL_OW 69
13630: ST_TO_ADDR
// if not Vedci then
13631: LD_VAR 0 2
13635: NOT
13636: IFFALSE 13640
// exit ;
13638: GO 14078
// Doly = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_SIBERITE_MINE ] ] ) ;
13640: LD_ADDR_VAR 0 3
13644: PUSH
13645: LD_INT 22
13647: PUSH
13648: LD_EXP 2
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PUSH
13657: LD_INT 21
13659: PUSH
13660: LD_INT 3
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: PUSH
13667: LD_INT 30
13669: PUSH
13670: LD_INT 30
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: PPUSH
13682: CALL_OW 69
13686: ST_TO_ADDR
// if ( not Doly ) and ( Tick < 30 30$0 ) then
13687: LD_VAR 0 3
13691: NOT
13692: PUSH
13693: LD_OWVAR 1
13697: PUSH
13698: LD_INT 63000
13700: LESS
13701: AND
13702: IFFALSE 13706
// exit ;
13704: GO 14078
// if Doly then
13706: LD_VAR 0 3
13710: IFFALSE 13821
// begin X = - 1 ;
13712: LD_ADDR_VAR 0 6
13716: PUSH
13717: LD_INT 1
13719: NEG
13720: ST_TO_ADDR
// Y = - 1 ;
13721: LD_ADDR_VAR 0 7
13725: PUSH
13726: LD_INT 1
13728: NEG
13729: ST_TO_ADDR
// Dul = 0 ;
13730: LD_ADDR_VAR 0 5
13734: PUSH
13735: LD_INT 0
13737: ST_TO_ADDR
// for I in Doly do
13738: LD_ADDR_VAR 0 4
13742: PUSH
13743: LD_VAR 0 3
13747: PUSH
13748: FOR_IN
13749: IFFALSE 13817
// begin if not Dul or GetX ( Dul ) > X then
13751: LD_VAR 0 5
13755: NOT
13756: PUSH
13757: LD_VAR 0 5
13761: PPUSH
13762: CALL_OW 250
13766: PUSH
13767: LD_VAR 0 6
13771: GREATER
13772: OR
13773: IFFALSE 13815
// begin Dul = I ;
13775: LD_ADDR_VAR 0 5
13779: PUSH
13780: LD_VAR 0 4
13784: ST_TO_ADDR
// X = GetX ( Dul ) ;
13785: LD_ADDR_VAR 0 6
13789: PUSH
13790: LD_VAR 0 5
13794: PPUSH
13795: CALL_OW 250
13799: ST_TO_ADDR
// Y = GetY ( Dul ) ;
13800: LD_ADDR_VAR 0 7
13804: PUSH
13805: LD_VAR 0 5
13809: PPUSH
13810: CALL_OW 251
13814: ST_TO_ADDR
// end end end else
13815: GO 13748
13817: POP
13818: POP
13819: GO 13976
// begin Doly = GetResourceArea ( RusoveUtok , MAT_SIBERIT ) ;
13821: LD_ADDR_VAR 0 3
13825: PUSH
13826: LD_INT 11
13828: PPUSH
13829: LD_INT 3
13831: PPUSH
13832: CALL_OW 287
13836: ST_TO_ADDR
// Doly = [ [ 74 , 6 ] , [ 23 , 9 ] , [ 144 , 97 ] ] ;
13837: LD_ADDR_VAR 0 3
13841: PUSH
13842: LD_INT 74
13844: PUSH
13845: LD_INT 6
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PUSH
13852: LD_INT 23
13854: PUSH
13855: LD_INT 9
13857: PUSH
13858: EMPTY
13859: LIST
13860: LIST
13861: PUSH
13862: LD_INT 144
13864: PUSH
13865: LD_INT 97
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: LIST
13876: ST_TO_ADDR
// if not Doly then
13877: LD_VAR 0 3
13881: NOT
13882: IFFALSE 13886
// exit ;
13884: GO 14078
// X = - 1 ;
13886: LD_ADDR_VAR 0 6
13890: PUSH
13891: LD_INT 1
13893: NEG
13894: ST_TO_ADDR
// Y = - 1 ;
13895: LD_ADDR_VAR 0 7
13899: PUSH
13900: LD_INT 1
13902: NEG
13903: ST_TO_ADDR
// for I in Doly do
13904: LD_ADDR_VAR 0 4
13908: PUSH
13909: LD_VAR 0 3
13913: PUSH
13914: FOR_IN
13915: IFFALSE 13974
// begin if ( X = - 1 ) or ( I [ 1 ] > X ) then
13917: LD_VAR 0 6
13921: PUSH
13922: LD_INT 1
13924: NEG
13925: EQUAL
13926: PUSH
13927: LD_VAR 0 4
13931: PUSH
13932: LD_INT 1
13934: ARRAY
13935: PUSH
13936: LD_VAR 0 6
13940: GREATER
13941: OR
13942: IFFALSE 13972
// begin X = I [ 1 ] ;
13944: LD_ADDR_VAR 0 6
13948: PUSH
13949: LD_VAR 0 4
13953: PUSH
13954: LD_INT 1
13956: ARRAY
13957: ST_TO_ADDR
// Y = I [ 2 ] ;
13958: LD_ADDR_VAR 0 7
13962: PUSH
13963: LD_VAR 0 4
13967: PUSH
13968: LD_INT 2
13970: ARRAY
13971: ST_TO_ADDR
// end ; end ;
13972: GO 13914
13974: POP
13975: POP
// end ; KdoOtravuje = [ nahoda_seznam ( Vedci ) ] ;
13976: LD_ADDR_LOC 42
13980: PUSH
13981: LD_VAR 0 2
13985: PPUSH
13986: CALL 21673 0 1
13990: PUSH
13991: EMPTY
13992: LIST
13993: ST_TO_ADDR
// ComExitBuilding ( KdoOtravuje ) ;
13994: LD_LOC 42
13998: PPUSH
13999: CALL_OW 122
// Wait ( 0 0$1 ) ;
14003: LD_INT 35
14005: PPUSH
14006: CALL_OW 67
// if ( Y <= 20 ) then
14010: LD_VAR 0 7
14014: PUSH
14015: LD_INT 20
14017: LESSEQUAL
14018: IFFALSE 14035
// AddComMoveXY ( KdoOtravuje , 95 , 5 ) ;
14020: LD_LOC 42
14024: PPUSH
14025: LD_INT 95
14027: PPUSH
14028: LD_INT 5
14030: PPUSH
14031: CALL_OW 171
// AddComContaminate ( KdoOtravuje , X , Y ) ;
14035: LD_LOC 42
14039: PPUSH
14040: LD_VAR 0 6
14044: PPUSH
14045: LD_VAR 0 7
14049: PPUSH
14050: CALL_OW 218
// AddComMoveToArea ( KdoOtravuje , Arabove ) ;
14054: LD_LOC 42
14058: PPUSH
14059: LD_INT 5
14061: PPUSH
14062: CALL_OW 173
// AddComSailEvent ( KdoOtravuje , 101 ) ;
14066: LD_LOC 42
14070: PPUSH
14071: LD_INT 101
14073: PPUSH
14074: CALL_OW 224
// end ;
14078: LD_VAR 0 1
14082: RET
// export function event_Kontaminovano ; var Kdo ; begin
14083: LD_INT 0
14085: PPUSH
14086: PPUSH
// for Kdo in KdoOtravuje do
14087: LD_ADDR_VAR 0 2
14091: PUSH
14092: LD_LOC 42
14096: PUSH
14097: FOR_IN
14098: IFFALSE 14111
// zpet_do_labu ( Kdo ) ;
14100: LD_VAR 0 2
14104: PPUSH
14105: CALL 13161 0 1
14109: GO 14097
14111: POP
14112: POP
// KdoOtravuje = [ ] ;
14113: LD_ADDR_LOC 42
14117: PUSH
14118: EMPTY
14119: ST_TO_ADDR
// end ;
14120: LD_VAR 0 1
14124: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
14125: LD_INT 0
14127: PPUSH
// if Un in KdoOtravuje then
14128: LD_VAR 0 1
14132: PUSH
14133: LD_LOC 42
14137: IN
14138: IFFALSE 14173
// begin KdoOtravuje = KdoOtravuje diff [ Un ] ;
14140: LD_ADDR_LOC 42
14144: PUSH
14145: LD_LOC 42
14149: PUSH
14150: LD_VAR 0 1
14154: PUSH
14155: EMPTY
14156: LIST
14157: DIFF
14158: ST_TO_ADDR
// if not KdoOtravuje then
14159: LD_LOC 42
14163: NOT
14164: IFFALSE 14173
// RaiseSailEvent ( 101 ) ;
14166: LD_INT 101
14168: PPUSH
14169: CALL_OW 427
// end ; if Un in Obranci then
14173: LD_VAR 0 1
14177: PUSH
14178: LD_LOC 37
14182: IN
14183: IFFALSE 14204
// Obranci = Obranci diff [ Un ] ;
14185: LD_ADDR_LOC 37
14189: PUSH
14190: LD_LOC 37
14194: PUSH
14195: LD_VAR 0 1
14199: PUSH
14200: EMPTY
14201: LIST
14202: DIFF
14203: ST_TO_ADDR
// if Un in VolnyLidi then
14204: LD_VAR 0 1
14208: PUSH
14209: LD_LOC 39
14213: IN
14214: IFFALSE 14235
// VolnyLidi = VolnyLidi diff [ Un ] ;
14216: LD_ADDR_LOC 39
14220: PUSH
14221: LD_LOC 39
14225: PUSH
14226: LD_VAR 0 1
14230: PUSH
14231: EMPTY
14232: LIST
14233: DIFF
14234: ST_TO_ADDR
// if Un in Auta then
14235: LD_VAR 0 1
14239: PUSH
14240: LD_LOC 40
14244: IN
14245: IFFALSE 14266
// Auta = Auta diff [ Un ] ;
14247: LD_ADDR_LOC 40
14251: PUSH
14252: LD_LOC 40
14256: PUSH
14257: LD_VAR 0 1
14261: PUSH
14262: EMPTY
14263: LIST
14264: DIFF
14265: ST_TO_ADDR
// if Un in Utok_Auta then
14266: LD_VAR 0 1
14270: PUSH
14271: LD_LOC 41
14275: IN
14276: IFFALSE 14297
// Utok_Auta = Utok_Auta diff [ Un ] ;
14278: LD_ADDR_LOC 41
14282: PUSH
14283: LD_LOC 41
14287: PUSH
14288: LD_VAR 0 1
14292: PUSH
14293: EMPTY
14294: LIST
14295: DIFF
14296: ST_TO_ADDR
// if Un in Sejkove then
14297: LD_VAR 0 1
14301: PUSH
14302: LD_LOC 38
14306: IN
14307: IFFALSE 14328
// Sejkove = Sejkove diff [ Un ] ;
14309: LD_ADDR_LOC 38
14313: PUSH
14314: LD_LOC 38
14318: PUSH
14319: LD_VAR 0 1
14323: PUSH
14324: EMPTY
14325: LIST
14326: DIFF
14327: ST_TO_ADDR
// if Un in ObranaBehemota then
14328: LD_VAR 0 1
14332: PUSH
14333: LD_LOC 45
14337: IN
14338: IFFALSE 14359
// ObranaBehemota = ObranaBehemota diff [ Un ] ;
14340: LD_ADDR_LOC 45
14344: PUSH
14345: LD_LOC 45
14349: PUSH
14350: LD_VAR 0 1
14354: PUSH
14355: EMPTY
14356: LIST
14357: DIFF
14358: ST_TO_ADDR
// if Un in KdoLakaOpice then
14359: LD_VAR 0 1
14363: PUSH
14364: LD_LOC 68
14368: IN
14369: IFFALSE 14390
// KdoLakaOpice = KdoLakaOpice diff [ Un ] ;
14371: LD_ADDR_LOC 68
14375: PUSH
14376: LD_LOC 68
14380: PUSH
14381: LD_VAR 0 1
14385: PUSH
14386: EMPTY
14387: LIST
14388: DIFF
14389: ST_TO_ADDR
// if Un in KdoLeci then
14390: LD_VAR 0 1
14394: PUSH
14395: LD_LOC 66
14399: IN
14400: IFFALSE 14421
// KdoLeci = KdoLeci diff [ Un ] ;
14402: LD_ADDR_LOC 66
14406: PUSH
14407: LD_LOC 66
14411: PUSH
14412: LD_VAR 0 1
14416: PUSH
14417: EMPTY
14418: LIST
14419: DIFF
14420: ST_TO_ADDR
// if Un in KdoOpravuje then
14421: LD_VAR 0 1
14425: PUSH
14426: LD_LOC 67
14430: IN
14431: IFFALSE 14452
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
14433: LD_ADDR_LOC 67
14437: PUSH
14438: LD_LOC 67
14442: PUSH
14443: LD_VAR 0 1
14447: PUSH
14448: EMPTY
14449: LIST
14450: DIFF
14451: ST_TO_ADDR
// end ;
14452: LD_VAR 0 2
14456: RET
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14457: LD_INT 0
14459: PPUSH
// if VehOld in Auta then
14460: LD_VAR 0 2
14464: PUSH
14465: LD_LOC 40
14469: IN
14470: IFFALSE 14491
// Auta = Auta diff [ VehOld ] ;
14472: LD_ADDR_LOC 40
14476: PUSH
14477: LD_LOC 40
14481: PUSH
14482: LD_VAR 0 2
14486: PUSH
14487: EMPTY
14488: LIST
14489: DIFF
14490: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
14491: LD_VAR 0 1
14495: PPUSH
14496: CALL_OW 255
14500: PUSH
14501: LD_EXP 3
14505: EQUAL
14506: IFFALSE 14527
// Auta = Auta union [ VehNew ] ;
14508: LD_ADDR_LOC 40
14512: PUSH
14513: LD_LOC 40
14517: PUSH
14518: LD_VAR 0 1
14522: PUSH
14523: EMPTY
14524: LIST
14525: UNION
14526: ST_TO_ADDR
// if VehOld in Utok_Auta then
14527: LD_VAR 0 2
14531: PUSH
14532: LD_LOC 41
14536: IN
14537: IFFALSE 14558
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
14539: LD_ADDR_LOC 41
14543: PUSH
14544: LD_LOC 41
14548: PUSH
14549: LD_VAR 0 2
14553: PUSH
14554: EMPTY
14555: LIST
14556: DIFF
14557: ST_TO_ADDR
// end ;
14558: LD_VAR 0 5
14562: RET
// function vyrob_autak ; var Chassis , Weapon , P ; begin
14563: LD_INT 0
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
// P = Rand ( 1 , 100 ) ;
14569: LD_ADDR_VAR 0 4
14573: PUSH
14574: LD_INT 1
14576: PPUSH
14577: LD_INT 100
14579: PPUSH
14580: CALL_OW 12
14584: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 65 ) then
14585: LD_OWVAR 67
14589: PUSH
14590: LD_INT 1
14592: EQUAL
14593: PUSH
14594: LD_VAR 0 4
14598: PUSH
14599: LD_INT 65
14601: GREATEREQUAL
14602: AND
14603: IFFALSE 14613
// P = 64 ;
14605: LD_ADDR_VAR 0 4
14609: PUSH
14610: LD_INT 64
14612: ST_TO_ADDR
// if P < 8 then
14613: LD_VAR 0 4
14617: PUSH
14618: LD_INT 8
14620: LESS
14621: IFFALSE 14641
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
14623: LD_ADDR_VAR 0 3
14627: PUSH
14628: LD_INT 22
14630: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14631: LD_ADDR_VAR 0 2
14635: PUSH
14636: LD_INT 11
14638: ST_TO_ADDR
// end else
14639: GO 14741
// if P < 15 then
14641: LD_VAR 0 4
14645: PUSH
14646: LD_INT 15
14648: LESS
14649: IFFALSE 14669
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
14651: LD_ADDR_VAR 0 3
14655: PUSH
14656: LD_INT 24
14658: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14659: LD_ADDR_VAR 0 2
14663: PUSH
14664: LD_INT 11
14666: ST_TO_ADDR
// end else
14667: GO 14741
// if P < 35 then
14669: LD_VAR 0 4
14673: PUSH
14674: LD_INT 35
14676: LESS
14677: IFFALSE 14697
// begin Weapon = AR_GATLING_GUN ;
14679: LD_ADDR_VAR 0 3
14683: PUSH
14684: LD_INT 25
14686: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14687: LD_ADDR_VAR 0 2
14691: PUSH
14692: LD_INT 13
14694: ST_TO_ADDR
// end else
14695: GO 14741
// if P < 65 then
14697: LD_VAR 0 4
14701: PUSH
14702: LD_INT 65
14704: LESS
14705: IFFALSE 14725
// begin Weapon = AR_GUN ;
14707: LD_ADDR_VAR 0 3
14711: PUSH
14712: LD_INT 27
14714: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14715: LD_ADDR_VAR 0 2
14719: PUSH
14720: LD_INT 13
14722: ST_TO_ADDR
// end else
14723: GO 14741
// begin Weapon = AR_ROCKET_LAUNCHER ;
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 28
14732: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14733: LD_ADDR_VAR 0 2
14737: PUSH
14738: LD_INT 13
14740: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
14741: LD_ADDR_VAR 0 2
14745: PUSH
14746: LD_VAR 0 2
14750: PPUSH
14751: LD_INT 14
14753: PPUSH
14754: CALL_OW 12
14758: ST_TO_ADDR
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
14759: LD_INT 5
14761: PPUSH
14762: LD_VAR 0 2
14766: PPUSH
14767: LD_INT 3
14769: PPUSH
14770: LD_INT 1
14772: PPUSH
14773: LD_VAR 0 3
14777: PPUSH
14778: CALL_OW 185
// end ;
14782: LD_VAR 0 1
14786: RET
// function vyrob_auto_opice ; begin
14787: LD_INT 0
14789: PPUSH
// AddComConstruct ( ArFact , AR_MEDIUM_TRIKE , ENGINE_SIBERITE , CONTROL_APEMAN , AR_SELFPROPELLED_BOMB ) ;
14790: LD_INT 5
14792: PPUSH
14793: LD_INT 13
14795: PPUSH
14796: LD_INT 3
14798: PPUSH
14799: LD_INT 5
14801: PPUSH
14802: LD_INT 29
14804: PPUSH
14805: CALL_OW 185
// end ;
14809: LD_VAR 0 1
14813: RET
// export function arabi_EnterBuilding ( Building , Un ) ; begin
14814: LD_INT 0
14816: PPUSH
// if ( Building = ArFact ) and ( GetSide ( Un ) = side_Ar ) and ( GetClass ( Un ) = CLASS_APEMAN ) then
14817: LD_VAR 0 1
14821: PUSH
14822: LD_INT 5
14824: EQUAL
14825: PUSH
14826: LD_VAR 0 2
14830: PPUSH
14831: CALL_OW 255
14835: PUSH
14836: LD_EXP 3
14840: EQUAL
14841: AND
14842: PUSH
14843: LD_VAR 0 2
14847: PPUSH
14848: CALL_OW 257
14852: PUSH
14853: LD_INT 12
14855: EQUAL
14856: AND
14857: IFFALSE 14877
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci + 1 ;
14859: LD_ADDR_LOC 48
14863: PUSH
14864: LD_LOC 48
14868: PUSH
14869: LD_INT 1
14871: PLUS
14872: ST_TO_ADDR
// vyrob_auto_opice ;
14873: CALL 14787 0 0
// end ; end ;
14877: LD_VAR 0 3
14881: RET
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , Volni , Control , Weapon , NovyRidic ; begin
14882: LD_INT 0
14884: PPUSH
14885: PPUSH
14886: PPUSH
14887: PPUSH
14888: PPUSH
14889: PPUSH
// if GetSide ( Veh ) = side_Ar then
14890: LD_VAR 0 1
14894: PPUSH
14895: CALL_OW 255
14899: PUSH
14900: LD_EXP 3
14904: EQUAL
14905: IFFALSE 15288
// begin Auta = Auta union [ Veh ] ;
14907: LD_ADDR_LOC 40
14911: PUSH
14912: LD_LOC 40
14916: PUSH
14917: LD_VAR 0 1
14921: PUSH
14922: EMPTY
14923: LIST
14924: UNION
14925: ST_TO_ADDR
// Control = GetControl ( Veh ) ;
14926: LD_ADDR_VAR 0 6
14930: PUSH
14931: LD_VAR 0 1
14935: PPUSH
14936: CALL_OW 263
14940: ST_TO_ADDR
// Weapon = GetWeapon ( Veh ) ;
14941: LD_ADDR_VAR 0 7
14945: PUSH
14946: LD_VAR 0 1
14950: PPUSH
14951: CALL_OW 264
14955: ST_TO_ADDR
// if ( Weapon = AR_CONTROL_TOWER ) then
14956: LD_VAR 0 7
14960: PUSH
14961: LD_INT 31
14963: EQUAL
14964: IFFALSE 14994
// begin ArDalkar = Veh ;
14966: LD_ADDR_LOC 49
14970: PUSH
14971: LD_VAR 0 1
14975: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
14976: LD_ADDR_VAR 0 8
14980: PUSH
14981: LD_LOC 36
14985: ST_TO_ADDR
// DelamDalkare = false ;
14986: LD_ADDR_LOC 51
14990: PUSH
14991: LD_INT 0
14993: ST_TO_ADDR
// end ; if ( Control = CONTROL_MANUAL ) then
14994: LD_VAR 0 6
14998: PUSH
14999: LD_INT 1
15001: EQUAL
15002: IFFALSE 15143
// begin Wait ( 0 0$2.5 ) ;
15004: LD_INT 88
15006: PPUSH
15007: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
15011: LD_ADDR_VAR 0 4
15015: PUSH
15016: LD_VAR 0 1
15020: PPUSH
15021: CALL_OW 311
15025: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
15026: LD_INT 105
15028: PPUSH
15029: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
15033: LD_VAR 0 4
15037: PPUSH
15038: CALL_OW 121
// Wait ( 0 0$1 ) ;
15042: LD_INT 35
15044: PPUSH
15045: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
15049: LD_VAR 0 1
15053: PPUSH
15054: CALL_OW 311
15058: PUSH
15059: LD_VAR 0 4
15063: EQUAL
15064: IFFALSE 15075
// Wait ( 0 0$1 ) ;
15066: LD_INT 35
15068: PPUSH
15069: CALL_OW 67
15073: GO 15049
// AddComEnterUnit ( Ridic , Fact ) ;
15075: LD_VAR 0 4
15079: PPUSH
15080: LD_VAR 0 2
15084: PPUSH
15085: CALL_OW 180
// if NovyRidic then
15089: LD_VAR 0 8
15093: IFFALSE 15109
// ComEnterUnit ( NovyRidic , Veh ) ;
15095: LD_VAR 0 8
15099: PPUSH
15100: LD_VAR 0 1
15104: PPUSH
15105: CALL_OW 120
// AddMcUnits ( MakroObrana , [ Veh ] ) ;
15109: LD_LOC 43
15113: PPUSH
15114: LD_VAR 0 1
15118: PUSH
15119: EMPTY
15120: LIST
15121: PPUSH
15122: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15126: LD_LOC 59
15130: PPUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: PPUSH
15139: CALL_OW 390
// end ; if ( Control = CONTROL_APEMAN ) and ( VolnyRidiciOpicaci > 0 ) then
15143: LD_VAR 0 6
15147: PUSH
15148: LD_INT 5
15150: EQUAL
15151: PUSH
15152: LD_LOC 48
15156: PUSH
15157: LD_INT 0
15159: GREATER
15160: AND
15161: IFFALSE 15177
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci - 1 ;
15163: LD_ADDR_LOC 48
15167: PUSH
15168: LD_LOC 48
15172: PUSH
15173: LD_INT 1
15175: MINUS
15176: ST_TO_ADDR
// end ; if ( Control = CONTROL_APEMAN ) and ( Weapon = AR_SELFPROPELLED_BOMB ) then
15177: LD_VAR 0 6
15181: PUSH
15182: LD_INT 5
15184: EQUAL
15185: PUSH
15186: LD_VAR 0 7
15190: PUSH
15191: LD_INT 29
15193: EQUAL
15194: AND
15195: IFFALSE 15221
// begin Wait ( 0 0$3.6 ) ;
15197: LD_INT 126
15199: PPUSH
15200: CALL_OW 67
// AddMcUnits ( MakroKamikaze , [ Veh ] ) ;
15204: LD_LOC 46
15208: PPUSH
15209: LD_VAR 0 1
15213: PUSH
15214: EMPTY
15215: LIST
15216: PPUSH
15217: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
15221: LD_VAR 0 1
15225: PPUSH
15226: CALL_OW 263
15230: PUSH
15231: LD_INT 2
15233: EQUAL
15234: IFFALSE 15288
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
15236: LD_VAR 0 1
15240: PPUSH
15241: LD_LOC 36
15245: PPUSH
15246: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
15250: LD_ADDR_LOC 50
15254: PUSH
15255: LD_LOC 50
15259: PUSH
15260: LD_INT 1
15262: PLUS
15263: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
15264: LD_INT 105
15266: PPUSH
15267: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15271: LD_LOC 59
15275: PPUSH
15276: LD_VAR 0 1
15280: PUSH
15281: EMPTY
15282: LIST
15283: PPUSH
15284: CALL_OW 390
// end ; end ; end ;
15288: LD_VAR 0 3
15292: RET
// function vyber_zbran ; var P ; begin
15293: LD_INT 0
15295: PPUSH
15296: PPUSH
// P = Rand ( 1 , 100 ) ;
15297: LD_ADDR_VAR 0 2
15301: PUSH
15302: LD_INT 1
15304: PPUSH
15305: LD_INT 100
15307: PPUSH
15308: CALL_OW 12
15312: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
15313: LD_VAR 0 2
15317: PUSH
15318: LD_LOC 57
15322: PUSH
15323: LD_INT 1
15325: ARRAY
15326: LESS
15327: IFFALSE 15339
// Result = AR_FLAME_THROWER else
15329: LD_ADDR_VAR 0 1
15333: PUSH
15334: LD_INT 26
15336: ST_TO_ADDR
15337: GO 15399
// if P < PstZbrane [ 2 ] then
15339: LD_VAR 0 2
15343: PUSH
15344: LD_LOC 57
15348: PUSH
15349: LD_INT 2
15351: ARRAY
15352: LESS
15353: IFFALSE 15365
// Result = AR_GUN else
15355: LD_ADDR_VAR 0 1
15359: PUSH
15360: LD_INT 27
15362: ST_TO_ADDR
15363: GO 15399
// if P < PstZbrane [ 3 ] then
15365: LD_VAR 0 2
15369: PUSH
15370: LD_LOC 57
15374: PUSH
15375: LD_INT 3
15377: ARRAY
15378: LESS
15379: IFFALSE 15391
// Result = AR_GATLING_GUN else
15381: LD_ADDR_VAR 0 1
15385: PUSH
15386: LD_INT 25
15388: ST_TO_ADDR
15389: GO 15399
// Result = AR_ROCKET_LAUNCHER ;
15391: LD_ADDR_VAR 0 1
15395: PUSH
15396: LD_INT 28
15398: ST_TO_ADDR
// end ;
15399: LD_VAR 0 1
15403: RET
// function vyber_ovladani ; begin
15404: LD_INT 0
15406: PPUSH
// Result = CONTROL_MANUAL ;
15407: LD_ADDR_VAR 0 1
15411: PUSH
15412: LD_INT 1
15414: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
15415: LD_LOC 49
15419: NOT
15420: PUSH
15421: LD_LOC 49
15425: PPUSH
15426: CALL_OW 302
15430: NOT
15431: OR
15432: IFFALSE 15436
// exit ;
15434: GO 15492
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
15436: LD_LOC 36
15440: NOT
15441: PUSH
15442: LD_LOC 36
15446: PPUSH
15447: CALL_OW 302
15451: NOT
15452: OR
15453: IFFALSE 15457
// exit ;
15455: GO 15492
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
15457: LD_LOC 36
15461: PPUSH
15462: CALL_OW 432
15466: PUSH
15467: LD_LOC 36
15471: PPUSH
15472: LD_INT 3
15474: PPUSH
15475: CALL_OW 259
15479: GREATEREQUAL
15480: IFFALSE 15484
// exit ;
15482: GO 15492
// Result = CONTROL_REMOTE ;
15484: LD_ADDR_VAR 0 1
15488: PUSH
15489: LD_INT 2
15491: ST_TO_ADDR
// end ;
15492: LD_VAR 0 1
15496: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
15497: LD_INT 0
15499: PPUSH
15500: PPUSH
15501: PPUSH
15502: PPUSH
15503: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
15504: LD_INT 5
15506: PPUSH
15507: CALL_OW 302
15511: NOT
15512: PUSH
15513: LD_INT 5
15515: PPUSH
15516: CALL_OW 314
15520: OR
15521: IFFALSE 15525
// exit ;
15523: GO 15837
// if GetSide ( ArFact ) <> side_Ar then
15525: LD_INT 5
15527: PPUSH
15528: CALL_OW 255
15532: PUSH
15533: LD_EXP 3
15537: NONEQUAL
15538: IFFALSE 15542
// exit ;
15540: GO 15837
// if not UnitsInside ( ArFact ) then
15542: LD_INT 5
15544: PPUSH
15545: CALL_OW 313
15549: NOT
15550: IFFALSE 15554
// exit ;
15552: GO 15837
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
15554: LD_INT 15
15556: PPUSH
15557: LD_EXP 3
15561: PPUSH
15562: CALL_OW 321
15566: PUSH
15567: LD_INT 2
15569: EQUAL
15570: PUSH
15571: LD_LOC 49
15575: NOT
15576: AND
15577: PUSH
15578: LD_LOC 51
15582: NOT
15583: AND
15584: PUSH
15585: LD_INT 75
15587: PPUSH
15588: CALL_OW 13
15592: AND
15593: IFFALSE 15621
// begin Chassis = AR_MEDIUM_TRIKE ;
15595: LD_ADDR_VAR 0 3
15599: PUSH
15600: LD_INT 13
15602: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
15603: LD_ADDR_VAR 0 4
15607: PUSH
15608: LD_INT 31
15610: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
15611: LD_ADDR_VAR 0 5
15615: PUSH
15616: LD_INT 1
15618: ST_TO_ADDR
// end else
15619: GO 15668
// begin if Prob ( 50 ) then
15621: LD_INT 50
15623: PPUSH
15624: CALL_OW 13
15628: IFFALSE 15640
// Chassis = AR_MEDIUM_TRIKE else
15630: LD_ADDR_VAR 0 3
15634: PUSH
15635: LD_INT 13
15637: ST_TO_ADDR
15638: GO 15648
// Chassis = AR_HALF_TRACKED ;
15640: LD_ADDR_VAR 0 3
15644: PUSH
15645: LD_INT 14
15647: ST_TO_ADDR
// Weapon = vyber_zbran ;
15648: LD_ADDR_VAR 0 4
15652: PUSH
15653: CALL 15293 0 0
15657: ST_TO_ADDR
// Control = vyber_ovladani ;
15658: LD_ADDR_VAR 0 5
15662: PUSH
15663: CALL 15404 0 0
15667: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) then
15668: LD_INT 5
15670: PPUSH
15671: LD_VAR 0 3
15675: PPUSH
15676: LD_INT 3
15678: PPUSH
15679: LD_VAR 0 5
15683: PPUSH
15684: LD_VAR 0 4
15688: PPUSH
15689: CALL_OW 448
15693: NOT
15694: IFFALSE 15738
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_SIBERITE , Control , AR_LIGHT_GUN ) then
15696: LD_INT 5
15698: PPUSH
15699: LD_INT 12
15701: PPUSH
15702: LD_INT 3
15704: PPUSH
15705: LD_VAR 0 5
15709: PPUSH
15710: LD_INT 23
15712: PPUSH
15713: CALL_OW 448
15717: NOT
15718: IFFALSE 15722
// exit ;
15720: GO 15837
// Chassis = AR_LIGHT_TRIKE ;
15722: LD_ADDR_VAR 0 3
15726: PUSH
15727: LD_INT 12
15729: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
15730: LD_ADDR_VAR 0 4
15734: PUSH
15735: LD_INT 23
15737: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
15738: LD_ADDR_VAR 0 2
15742: PUSH
15743: LD_INT 5
15745: PPUSH
15746: CALL_OW 274
15750: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
15751: LD_VAR 0 2
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: CALL_OW 275
15763: PUSH
15764: LD_INT 120
15766: LESS
15767: IFFALSE 15771
// exit ;
15769: GO 15837
// if GetResourceType ( Base , MAT_SIBERIT ) < 30 then
15771: LD_VAR 0 2
15775: PPUSH
15776: LD_INT 3
15778: PPUSH
15779: CALL_OW 275
15783: PUSH
15784: LD_INT 30
15786: LESS
15787: IFFALSE 15791
// exit ;
15789: GO 15837
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) ;
15791: LD_INT 5
15793: PPUSH
15794: LD_VAR 0 3
15798: PPUSH
15799: LD_INT 3
15801: PPUSH
15802: LD_VAR 0 5
15806: PPUSH
15807: LD_VAR 0 4
15811: PPUSH
15812: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
15816: LD_VAR 0 4
15820: PUSH
15821: LD_INT 31
15823: EQUAL
15824: IFFALSE 15837
// begin DelamDalkare = true ;
15826: LD_ADDR_LOC 51
15830: PUSH
15831: LD_INT 1
15833: ST_TO_ADDR
// enable ( 33 ) ;
15834: LD_INT 33
15836: ENABLE_MARKED
// end ; end ;
15837: LD_VAR 0 1
15841: RET
// every 5 5$1 marked 33 do
15842: GO 15844
15844: DISABLE
// begin if not ArDalkar then
15845: LD_LOC 49
15849: NOT
15850: IFFALSE 15860
// DelamDalkare = false ;
15852: LD_ADDR_LOC 51
15856: PUSH
15857: LD_INT 0
15859: ST_TO_ADDR
// end ;
15860: END
// every 0 0$19 do
15861: GO 15863
15863: DISABLE
// begin kontrola_vyroby ;
15864: CALL 15497 0 0
// enable ;
15868: ENABLE
// end ;
15869: END
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
15870: LD_INT 0
15872: PPUSH
15873: PPUSH
15874: PPUSH
15875: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
15876: LD_ADDR_VAR 0 2
15880: PUSH
15881: LD_EXP 47
15885: PUSH
15886: LD_OWVAR 67
15890: ARRAY
15891: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
15892: LD_ADDR_VAR 0 3
15896: PUSH
15897: LD_INT 1
15899: PPUSH
15900: LD_INT 100
15902: PPUSH
15903: CALL_OW 12
15907: ST_TO_ADDR
// if ( I < 25 ) then
15908: LD_VAR 0 3
15912: PUSH
15913: LD_INT 25
15915: LESS
15916: IFFALSE 15934
// KolikChci = KolikChci - 1 else
15918: LD_ADDR_VAR 0 2
15922: PUSH
15923: LD_VAR 0 2
15927: PUSH
15928: LD_INT 1
15930: MINUS
15931: ST_TO_ADDR
15932: GO 15968
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
15934: LD_VAR 0 3
15938: PUSH
15939: LD_INT 75
15941: GREATER
15942: PUSH
15943: LD_LOC 53
15947: PUSH
15948: LD_INT 1
15950: GREATER
15951: AND
15952: IFFALSE 15968
// KolikChci = KolikChci + 1 ;
15954: LD_ADDR_VAR 0 2
15958: PUSH
15959: LD_VAR 0 2
15963: PUSH
15964: LD_INT 1
15966: PLUS
15967: ST_TO_ADDR
// Riditelne = [ ] ;
15968: LD_ADDR_VAR 0 4
15972: PUSH
15973: EMPTY
15974: ST_TO_ADDR
// for I in Auta do
15975: LD_ADDR_VAR 0 3
15979: PUSH
15980: LD_LOC 40
15984: PUSH
15985: FOR_IN
15986: IFFALSE 16072
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
15988: LD_VAR 0 3
15992: PPUSH
15993: CALL_OW 263
15997: PUSH
15998: LD_INT 1
16000: EQUAL
16001: PUSH
16002: LD_VAR 0 3
16006: PPUSH
16007: CALL_OW 311
16011: NOT
16012: AND
16013: IFFALSE 16017
// continue ;
16015: GO 15985
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
16017: LD_VAR 0 3
16021: PPUSH
16022: CALL_OW 264
16026: PUSH
16027: LD_INT 31
16029: EQUAL
16030: IFFALSE 16034
// continue ;
16032: GO 15985
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
16034: LD_VAR 0 3
16038: PPUSH
16039: CALL_OW 256
16043: PUSH
16044: LD_INT 1000
16046: LESS
16047: IFFALSE 16051
// continue ;
16049: GO 15985
// Riditelne = Riditelne union [ I ] ;
16051: LD_ADDR_VAR 0 4
16055: PUSH
16056: LD_VAR 0 4
16060: PUSH
16061: LD_VAR 0 3
16065: PUSH
16066: EMPTY
16067: LIST
16068: UNION
16069: ST_TO_ADDR
// end ;
16070: GO 15985
16072: POP
16073: POP
// if Riditelne >= KolikChci then
16074: LD_VAR 0 4
16078: PUSH
16079: LD_VAR 0 2
16083: GREATEREQUAL
16084: IFFALSE 16224
// begin if ( Tick > 45 45$0 ) then
16086: LD_OWVAR 1
16090: PUSH
16091: LD_INT 94500
16093: GREATER
16094: IFFALSE 16108
// Result = Riditelne else
16096: LD_ADDR_VAR 0 1
16100: PUSH
16101: LD_VAR 0 4
16105: ST_TO_ADDR
16106: GO 16159
// begin Result = [ ] ;
16108: LD_ADDR_VAR 0 1
16112: PUSH
16113: EMPTY
16114: ST_TO_ADDR
// for I = 1 to KolikChci do
16115: LD_ADDR_VAR 0 3
16119: PUSH
16120: DOUBLE
16121: LD_INT 1
16123: DEC
16124: ST_TO_ADDR
16125: LD_VAR 0 2
16129: PUSH
16130: FOR_TO
16131: IFFALSE 16157
// Result = Result union Riditelne [ I ] ;
16133: LD_ADDR_VAR 0 1
16137: PUSH
16138: LD_VAR 0 1
16142: PUSH
16143: LD_VAR 0 4
16147: PUSH
16148: LD_VAR 0 3
16152: ARRAY
16153: UNION
16154: ST_TO_ADDR
16155: GO 16130
16157: POP
16158: POP
// end ; if Obranci > 4 then
16159: LD_LOC 37
16163: PUSH
16164: LD_INT 4
16166: GREATER
16167: IFFALSE 16222
// for I = 1 to Rand ( 1 , 2 ) do
16169: LD_ADDR_VAR 0 3
16173: PUSH
16174: DOUBLE
16175: LD_INT 1
16177: DEC
16178: ST_TO_ADDR
16179: LD_INT 1
16181: PPUSH
16182: LD_INT 2
16184: PPUSH
16185: CALL_OW 12
16189: PUSH
16190: FOR_TO
16191: IFFALSE 16220
// Result = Result union [ Obranci [ I ] ] ;
16193: LD_ADDR_VAR 0 1
16197: PUSH
16198: LD_VAR 0 1
16202: PUSH
16203: LD_LOC 37
16207: PUSH
16208: LD_VAR 0 3
16212: ARRAY
16213: PUSH
16214: EMPTY
16215: LIST
16216: UNION
16217: ST_TO_ADDR
16218: GO 16190
16220: POP
16221: POP
// end else
16222: GO 16231
// Result = [ ] ;
16224: LD_ADDR_VAR 0 1
16228: PUSH
16229: EMPTY
16230: ST_TO_ADDR
// end ;
16231: LD_VAR 0 1
16235: RET
// function zacni_utok ; begin
16236: LD_INT 0
16238: PPUSH
// ProbihaUtok = true ;
16239: LD_ADDR_EXP 62
16243: PUSH
16244: LD_INT 1
16246: ST_TO_ADDR
// if ( RusMaOtraveno < 2 ) and not KdoOtravuje and RusMaSiberit then
16247: LD_EXP 64
16251: PUSH
16252: LD_INT 2
16254: LESS
16255: PUSH
16256: LD_LOC 42
16260: NOT
16261: AND
16262: PUSH
16263: LD_EXP 63
16267: AND
16268: IFFALSE 16289
// begin otravuj ;
16270: CALL 13547 0 0
// Wait ( Rand ( 0 0$10 , 0 0$15 ) ) ;
16274: LD_INT 350
16276: PPUSH
16277: LD_INT 525
16279: PPUSH
16280: CALL_OW 12
16284: PPUSH
16285: CALL_OW 67
// end ; MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
16289: LD_ADDR_LOC 52
16293: PUSH
16294: LD_INT 10
16296: PPUSH
16297: LD_LOC 47
16301: PPUSH
16302: LD_LOC 41
16306: PPUSH
16307: LD_INT 7
16309: PUSH
16310: LD_INT 15
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PUSH
16317: LD_INT 8
16319: PUSH
16320: LD_INT 15
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: LD_INT 5
16329: PUSH
16330: LD_INT 10
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: LD_INT 6
16339: PUSH
16340: LD_INT 10
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: LIST
16351: LIST
16352: PPUSH
16353: CALL_OW 402
16357: ST_TO_ADDR
// end ;
16358: LD_VAR 0 1
16362: RET
// function vrat_utok ; var I ; begin
16363: LD_INT 0
16365: PPUSH
16366: PPUSH
// ProbihaUtok = false ;
16367: LD_ADDR_EXP 62
16371: PUSH
16372: LD_INT 0
16374: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
16375: LD_ADDR_LOC 53
16379: PUSH
16380: LD_LOC 53
16384: PUSH
16385: LD_INT 1
16387: PLUS
16388: ST_TO_ADDR
// MakroUtok = 0 ;
16389: LD_ADDR_LOC 52
16393: PUSH
16394: LD_INT 0
16396: ST_TO_ADDR
// AddComMoveToArea ( Utok_Auta , Arabove ) ;
16397: LD_LOC 41
16401: PPUSH
16402: LD_INT 5
16404: PPUSH
16405: CALL_OW 173
// end ;
16409: LD_VAR 0 1
16413: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
16414: LD_INT 0
16416: PPUSH
// vrat_utok ;
16417: CALL 16363 0 0
// end ;
16421: LD_VAR 0 3
16425: RET
// function zjisti_cas_utoku ; begin
16426: LD_INT 0
16428: PPUSH
// if CasyUtoku then
16429: LD_LOC 56
16433: IFFALSE 16479
// begin Result = CasyUtoku [ 1 ] ;
16435: LD_ADDR_VAR 0 1
16439: PUSH
16440: LD_LOC 56
16444: PUSH
16445: LD_INT 1
16447: ARRAY
16448: ST_TO_ADDR
// if CasyUtoku > 1 then
16449: LD_LOC 56
16453: PUSH
16454: LD_INT 1
16456: GREATER
16457: IFFALSE 16477
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
16459: LD_ADDR_LOC 56
16463: PUSH
16464: LD_LOC 56
16468: PPUSH
16469: LD_INT 1
16471: PPUSH
16472: CALL_OW 3
16476: ST_TO_ADDR
// end else
16477: GO 16487
// Result = 5 ;
16479: LD_ADDR_VAR 0 1
16483: PUSH
16484: LD_INT 5
16486: ST_TO_ADDR
// end ;
16487: LD_VAR 0 1
16491: RET
// function utoceni_splneny_predpoklady ; begin
16492: LD_INT 0
16494: PPUSH
// Result = VidelRusa or ( Tick > 12 12$0 ) ;
16495: LD_ADDR_VAR 0 1
16499: PUSH
16500: LD_LOC 58
16504: PUSH
16505: LD_OWVAR 1
16509: PUSH
16510: LD_INT 25200
16512: GREATER
16513: OR
16514: ST_TO_ADDR
// if Prob ( 25 ) then
16515: LD_INT 25
16517: PPUSH
16518: CALL_OW 13
16522: IFFALSE 16532
// Result = false ;
16524: LD_ADDR_VAR 0 1
16528: PUSH
16529: LD_INT 0
16531: ST_TO_ADDR
// end ;
16532: LD_VAR 0 1
16536: RET
// function casovac_utok ; begin
16537: LD_INT 0
16539: PPUSH
// if ProbihaUtok then
16540: LD_EXP 62
16544: IFFALSE 16548
// exit ;
16546: GO 16655
// if ArabiZniceni then
16548: LD_EXP 65
16552: IFFALSE 16556
// exit ;
16554: GO 16655
// if Utok_ZbyvaMinut = - 1 then
16556: LD_LOC 55
16560: PUSH
16561: LD_INT 1
16563: NEG
16564: EQUAL
16565: IFFALSE 16577
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16567: LD_ADDR_LOC 55
16571: PUSH
16572: CALL 16426 0 0
16576: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
16577: LD_LOC 55
16581: PUSH
16582: LD_INT 0
16584: GREATER
16585: IFFALSE 16601
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
16587: LD_ADDR_LOC 55
16591: PUSH
16592: LD_LOC 55
16596: PUSH
16597: LD_INT 1
16599: MINUS
16600: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
16601: CALL 16492 0 0
16605: NOT
16606: IFFALSE 16610
// exit ;
16608: GO 16655
// if Utok_ZbyvaMinut > 0 then
16610: LD_LOC 55
16614: PUSH
16615: LD_INT 0
16617: GREATER
16618: IFFALSE 16622
// exit ;
16620: GO 16655
// Utok_Auta = zjisti_auta_na_utok ;
16622: LD_ADDR_LOC 41
16626: PUSH
16627: CALL 15870 0 0
16631: ST_TO_ADDR
// if not Utok_Auta then
16632: LD_LOC 41
16636: NOT
16637: IFFALSE 16641
// exit ;
16639: GO 16655
// zacni_utok ;
16641: CALL 16236 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16645: LD_ADDR_LOC 55
16649: PUSH
16650: CALL 16426 0 0
16654: ST_TO_ADDR
// end ;
16655: LD_VAR 0 1
16659: RET
// every 0 0$45 marked 31 do
16660: GO 16662
16662: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
16663: LD_INT 0
16665: PPUSH
16666: LD_INT 1050
16668: PPUSH
16669: CALL_OW 12
16673: PPUSH
16674: CALL_OW 67
// casovac_utok ;
16678: CALL 16537 0 0
// enable ;
16682: ENABLE
// end ;
16683: END
// every 0 0$30 do
16684: GO 16686
16686: DISABLE
// begin Wait ( 1 1$0 * Rand ( PrvniUtok [ 1 ] , PrvniUtok [ 2 ] ) ) ;
16687: LD_INT 2100
16689: PUSH
16690: LD_LOC 54
16694: PUSH
16695: LD_INT 1
16697: ARRAY
16698: PPUSH
16699: LD_LOC 54
16703: PUSH
16704: LD_INT 2
16706: ARRAY
16707: PPUSH
16708: CALL_OW 12
16712: MUL
16713: PPUSH
16714: CALL_OW 67
// enable ( 31 ) ;
16718: LD_INT 31
16720: ENABLE_MARKED
// end ;
16721: END
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
16722: LD_INT 0
16724: PPUSH
16725: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
16726: LD_ADDR_VAR 0 4
16730: PUSH
16731: LD_INT 22
16733: PUSH
16734: LD_EXP 2
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: PUSH
16743: LD_INT 92
16745: PUSH
16746: LD_VAR 0 1
16750: PUSH
16751: LD_VAR 0 2
16755: PUSH
16756: LD_INT 2
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL_OW 69
16773: ST_TO_ADDR
// if Jednotky then
16774: LD_VAR 0 4
16778: IFFALSE 16809
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
16780: LD_VAR 0 1
16784: PPUSH
16785: LD_VAR 0 2
16789: PPUSH
16790: LD_EXP 3
16794: PPUSH
16795: CALL_OW 456
// Result = true ;
16799: LD_ADDR_VAR 0 3
16803: PUSH
16804: LD_INT 1
16806: ST_TO_ADDR
// end else
16807: GO 16817
// Result = false ;
16809: LD_ADDR_VAR 0 3
16813: PUSH
16814: LD_INT 0
16816: ST_TO_ADDR
// end ;
16817: LD_VAR 0 3
16821: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
16822: GO 16824
16824: DISABLE
16825: LD_INT 0
16827: PPUSH
16828: PPUSH
// begin if not Miny then
16829: LD_LOC 44
16833: NOT
16834: IFFALSE 16838
// exit ;
16836: GO 16934
// Bouchlo = [ ] ;
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: EMPTY
16844: ST_TO_ADDR
// for M in Miny do
16845: LD_ADDR_VAR 0 1
16849: PUSH
16850: LD_LOC 44
16854: PUSH
16855: FOR_IN
16856: IFFALSE 16903
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
16858: LD_VAR 0 1
16862: PUSH
16863: LD_INT 1
16865: ARRAY
16866: PPUSH
16867: LD_VAR 0 1
16871: PUSH
16872: LD_INT 2
16874: ARRAY
16875: PPUSH
16876: CALL 16722 0 2
16880: IFFALSE 16901
// Bouchlo = Bouchlo ^ [ M ] ;
16882: LD_ADDR_VAR 0 2
16886: PUSH
16887: LD_VAR 0 2
16891: PUSH
16892: LD_VAR 0 1
16896: PUSH
16897: EMPTY
16898: LIST
16899: ADD
16900: ST_TO_ADDR
16901: GO 16855
16903: POP
16904: POP
// if Bouchlo then
16905: LD_VAR 0 2
16909: IFFALSE 16927
// Miny = Miny diff Bouchlo ;
16911: LD_ADDR_LOC 44
16915: PUSH
16916: LD_LOC 44
16920: PUSH
16921: LD_VAR 0 2
16925: DIFF
16926: ST_TO_ADDR
// if Miny then
16927: LD_LOC 44
16931: IFFALSE 16934
// enable ;
16933: ENABLE
// end ;
16934: PPOPN 2
16936: END
// function testuj_behemota ( Un ) ; begin
16937: LD_INT 0
16939: PPUSH
// if not IsInArea ( Un , AraboveObrana ) then
16940: LD_VAR 0 1
16944: PPUSH
16945: LD_INT 12
16947: PPUSH
16948: CALL_OW 308
16952: NOT
16953: IFFALSE 16957
// exit ;
16955: GO 16990
// if not See ( side_Ar , Un ) then
16957: LD_EXP 3
16961: PPUSH
16962: LD_VAR 0 1
16966: PPUSH
16967: CALL_OW 292
16971: NOT
16972: IFFALSE 16976
// exit ;
16974: GO 16990
// AddComAttackUnit ( ObranaBehemota , Un ) ;
16976: LD_LOC 45
16980: PPUSH
16981: LD_VAR 0 1
16985: PPUSH
16986: CALL_OW 175
// end ;
16990: LD_VAR 0 2
16994: RET
// every 0 0$5.1 do var Kdo , I ;
16995: GO 16997
16997: DISABLE
16998: LD_INT 0
17000: PPUSH
17001: PPUSH
// begin Kdo = FilterUnitsInArea ( AraboveObrana , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CHASSIS , 25 ] ] ) ;
17002: LD_ADDR_VAR 0 1
17006: PUSH
17007: LD_INT 12
17009: PPUSH
17010: LD_INT 22
17012: PUSH
17013: LD_EXP 2
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: PUSH
17022: LD_INT 21
17024: PUSH
17025: LD_INT 2
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: PUSH
17032: LD_INT 31
17034: PUSH
17035: LD_INT 25
17037: PUSH
17038: EMPTY
17039: LIST
17040: LIST
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: PPUSH
17047: CALL_OW 70
17051: ST_TO_ADDR
// for I in Kdo do
17052: LD_ADDR_VAR 0 2
17056: PUSH
17057: LD_VAR 0 1
17061: PUSH
17062: FOR_IN
17063: IFFALSE 17076
// testuj_behemota ( I ) ;
17065: LD_VAR 0 2
17069: PPUSH
17070: CALL 16937 0 1
17074: GO 17062
17076: POP
17077: POP
// if ObranaBehemota then
17078: LD_LOC 45
17082: IFFALSE 17085
// enable ;
17084: ENABLE
// end ;
17085: PPOPN 2
17087: END
// export function arabi_ApemanTamed ( Ape , Sci ) ; var tmp , tmp1 , tmp2 ; begin
17088: LD_INT 0
17090: PPUSH
17091: PPUSH
17092: PPUSH
17093: PPUSH
// if GetSide ( Sci ) <> side_Ar then
17094: LD_VAR 0 2
17098: PPUSH
17099: CALL_OW 255
17103: PUSH
17104: LD_EXP 3
17108: NONEQUAL
17109: IFFALSE 17113
// exit ;
17111: GO 17125
// ComMoveToArea ( Ape , Arabove ) ;
17113: LD_VAR 0 1
17117: PPUSH
17118: LD_INT 5
17120: PPUSH
17121: CALL_OW 113
// end ;
17125: LD_VAR 0 3
17129: RET
// function kamikazuj_opicaky ; var O ; begin
17130: LD_INT 0
17132: PPUSH
17133: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ) ;
17134: LD_ADDR_VAR 0 2
17138: PUSH
17139: LD_INT 22
17141: PUSH
17142: LD_EXP 3
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: PUSH
17151: LD_INT 21
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: LD_INT 25
17163: PUSH
17164: LD_INT 17
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: LIST
17175: PPUSH
17176: CALL_OW 69
17180: ST_TO_ADDR
// AddMcUnits ( MakroKamikaze , O ) ;
17181: LD_LOC 46
17185: PPUSH
17186: LD_VAR 0 2
17190: PPUSH
17191: CALL_OW 390
// end ;
17195: LD_VAR 0 1
17199: RET
// function zmen_na_kamikaze ( Ape ) ; begin
17200: LD_INT 0
17202: PPUSH
// AddComEnterUnit ( Ape , ArLabWS ) ;
17203: LD_VAR 0 1
17207: PPUSH
17208: LD_INT 11
17210: PPUSH
17211: CALL_OW 180
// AddComChangeProfession ( Ape , CLASS_APEMAN_KAMIKAZE ) ;
17215: LD_VAR 0 1
17219: PPUSH
17220: LD_INT 17
17222: PPUSH
17223: CALL_OW 183
// AddComExitBuilding ( Ape ) ;
17227: LD_VAR 0 1
17231: PPUSH
17232: CALL_OW 182
// end ;
17236: LD_VAR 0 2
17240: RET
// function chci_ridice_opicaka ; begin
17241: LD_INT 0
17243: PPUSH
// Result = false ;
17244: LD_ADDR_VAR 0 1
17248: PUSH
17249: LD_INT 0
17251: ST_TO_ADDR
// if VolnyRidiciOpicaci >= 2 then
17252: LD_LOC 48
17256: PUSH
17257: LD_INT 2
17259: GREATEREQUAL
17260: IFFALSE 17264
// exit ;
17262: GO 17298
// if UnitsInside ( ArFact ) > 4 then
17264: LD_INT 5
17266: PPUSH
17267: CALL_OW 313
17271: PUSH
17272: LD_INT 4
17274: GREATER
17275: IFFALSE 17279
// exit ;
17277: GO 17298
// if Prob ( 50 ) then
17279: LD_INT 50
17281: PPUSH
17282: CALL_OW 13
17286: IFFALSE 17290
// exit ;
17288: GO 17298
// Result = true ;
17290: LD_ADDR_VAR 0 1
17294: PUSH
17295: LD_INT 1
17297: ST_TO_ADDR
// end ;
17298: LD_VAR 0 1
17302: RET
// function men_na_kamikaze ; var O , I ; begin
17303: LD_INT 0
17305: PPUSH
17306: PPUSH
17307: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN ] , [ F_OUTSIDE ] ] ) ;
17308: LD_ADDR_VAR 0 2
17312: PUSH
17313: LD_INT 22
17315: PUSH
17316: LD_EXP 3
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: PUSH
17325: LD_INT 21
17327: PUSH
17328: LD_INT 1
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: PUSH
17335: LD_INT 25
17337: PUSH
17338: LD_INT 12
17340: PUSH
17341: EMPTY
17342: LIST
17343: LIST
17344: PUSH
17345: LD_INT 56
17347: PUSH
17348: EMPTY
17349: LIST
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: LIST
17355: LIST
17356: PPUSH
17357: CALL_OW 69
17361: ST_TO_ADDR
// for I in O do
17362: LD_ADDR_VAR 0 3
17366: PUSH
17367: LD_VAR 0 2
17371: PUSH
17372: FOR_IN
17373: IFFALSE 17445
// begin if IsBusy ( I ) then
17375: LD_VAR 0 3
17379: PPUSH
17380: CALL_OW 315
17384: IFFALSE 17388
// continue ;
17386: GO 17372
// if HasTask ( I ) then
17388: LD_VAR 0 3
17392: PPUSH
17393: CALL_OW 314
17397: IFFALSE 17401
// continue ;
17399: GO 17372
// if IsInUnit ( I ) then
17401: LD_VAR 0 3
17405: PPUSH
17406: CALL_OW 310
17410: IFFALSE 17414
// continue ;
17412: GO 17372
// if chci_ridice_opicaka then
17414: CALL 17241 0 0
17418: IFFALSE 17434
// begin ComEnterUnit ( I , ArFact ) ;
17420: LD_VAR 0 3
17424: PPUSH
17425: LD_INT 5
17427: PPUSH
17428: CALL_OW 120
// end else
17432: GO 17443
// zmen_na_kamikaze ( I ) ;
17434: LD_VAR 0 3
17438: PPUSH
17439: CALL 17200 0 1
// end ;
17443: GO 17372
17445: POP
17446: POP
// end ;
17447: LD_VAR 0 1
17451: RET
// function vedec_volny ( List ) ; var I , OK ; begin
17452: LD_INT 0
17454: PPUSH
17455: PPUSH
17456: PPUSH
// OK = [ ] ;
17457: LD_ADDR_VAR 0 4
17461: PUSH
17462: EMPTY
17463: ST_TO_ADDR
// for I in List do
17464: LD_ADDR_VAR 0 3
17468: PUSH
17469: LD_VAR 0 1
17473: PUSH
17474: FOR_IN
17475: IFFALSE 17521
// if IsInUnit ( I ) or not HasTask ( I ) then
17477: LD_VAR 0 3
17481: PPUSH
17482: CALL_OW 310
17486: PUSH
17487: LD_VAR 0 3
17491: PPUSH
17492: CALL_OW 314
17496: NOT
17497: OR
17498: IFFALSE 17519
// OK = OK union [ I ] ;
17500: LD_ADDR_VAR 0 4
17504: PUSH
17505: LD_VAR 0 4
17509: PUSH
17510: LD_VAR 0 3
17514: PUSH
17515: EMPTY
17516: LIST
17517: UNION
17518: ST_TO_ADDR
17519: GO 17474
17521: POP
17522: POP
// Result = nahoda_seznam ( OK ) ;
17523: LD_ADDR_VAR 0 2
17527: PUSH
17528: LD_VAR 0 4
17532: PPUSH
17533: CALL 21673 0 1
17537: ST_TO_ADDR
// end ;
17538: LD_VAR 0 2
17542: RET
// function lakej_opice ; var Opice , Kdo , I ; begin
17543: LD_INT 0
17545: PPUSH
17546: PPUSH
17547: PPUSH
17548: PPUSH
// if KdoLakaOpice then
17549: LD_LOC 68
17553: IFFALSE 17557
// exit ;
17555: GO 17749
// Kdo = vedec_volny ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLeci ) ;
17557: LD_ADDR_VAR 0 3
17561: PUSH
17562: LD_LOC 28
17566: PUSH
17567: LD_LOC 29
17571: PUSH
17572: LD_LOC 30
17576: PUSH
17577: LD_LOC 31
17581: PUSH
17582: EMPTY
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: PUSH
17588: LD_LOC 66
17592: DIFF
17593: PPUSH
17594: CALL 17452 0 1
17598: ST_TO_ADDR
// if not Kdo then
17599: LD_VAR 0 3
17603: NOT
17604: IFFALSE 17608
// exit ;
17606: GO 17749
// if HasTask ( Kdo ) then
17608: LD_VAR 0 3
17612: PPUSH
17613: CALL_OW 314
17617: IFFALSE 17621
// exit ;
17619: GO 17749
// Opice = FilterUnitsInArea ( AraboveOpice , [ [ F_SIDE , side_Neutral ] , [ F_CLASS , CLASS_APEMAN ] ] ) ;
17621: LD_ADDR_VAR 0 2
17625: PUSH
17626: LD_INT 13
17628: PPUSH
17629: LD_INT 22
17631: PUSH
17632: LD_EXP 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: LD_INT 25
17643: PUSH
17644: LD_INT 12
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PUSH
17651: EMPTY
17652: LIST
17653: LIST
17654: PPUSH
17655: CALL_OW 70
17659: ST_TO_ADDR
// if not Opice then
17660: LD_VAR 0 2
17664: NOT
17665: IFFALSE 17669
// exit ;
17667: GO 17749
// KdoLakaOpice = [ Kdo ] ;
17669: LD_ADDR_LOC 68
17673: PUSH
17674: LD_VAR 0 3
17678: PUSH
17679: EMPTY
17680: LIST
17681: ST_TO_ADDR
// ComExitBuilding ( KdoLakaOpice ) ;
17682: LD_LOC 68
17686: PPUSH
17687: CALL_OW 122
// for I in Opice do
17691: LD_ADDR_VAR 0 4
17695: PUSH
17696: LD_VAR 0 2
17700: PUSH
17701: FOR_IN
17702: IFFALSE 17735
// AddComTameXY ( KdoLakaOpice , GetX ( I ) , GetY ( I ) ) ;
17704: LD_LOC 68
17708: PPUSH
17709: LD_VAR 0 4
17713: PPUSH
17714: CALL_OW 250
17718: PPUSH
17719: LD_VAR 0 4
17723: PPUSH
17724: CALL_OW 251
17728: PPUSH
17729: CALL_OW 191
17733: GO 17701
17735: POP
17736: POP
// AddComSailEvent ( KdoLakaOpice , 103 ) ;
17737: LD_LOC 68
17741: PPUSH
17742: LD_INT 103
17744: PPUSH
17745: CALL_OW 224
// end ;
17749: LD_VAR 0 1
17753: RET
// export function event_DolakanaOpice ; var Kdo ; begin
17754: LD_INT 0
17756: PPUSH
17757: PPUSH
// for Kdo in KdoLakaOpice do
17758: LD_ADDR_VAR 0 2
17762: PUSH
17763: LD_LOC 68
17767: PUSH
17768: FOR_IN
17769: IFFALSE 17782
// zpet_do_labu ( Kdo ) ;
17771: LD_VAR 0 2
17775: PPUSH
17776: CALL 13161 0 1
17780: GO 17768
17782: POP
17783: POP
// KdoLakaOpice = [ ] ;
17784: LD_ADDR_LOC 68
17788: PUSH
17789: EMPTY
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// function vytvor_nove_opice ; var Opice , I , Hex , Pocet ; begin
17796: LD_INT 0
17798: PPUSH
17799: PPUSH
17800: PPUSH
17801: PPUSH
17802: PPUSH
// Result = true ;
17803: LD_ADDR_VAR 0 1
17807: PUSH
17808: LD_INT 1
17810: ST_TO_ADDR
// Opice = FilterAllUnits ( [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
17811: LD_ADDR_VAR 0 2
17815: PUSH
17816: LD_INT 2
17818: PUSH
17819: LD_INT 25
17821: PUSH
17822: LD_INT 12
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PUSH
17829: LD_INT 25
17831: PUSH
17832: LD_INT 15
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: PUSH
17839: LD_INT 25
17841: PUSH
17842: LD_INT 16
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: PUSH
17849: LD_INT 25
17851: PUSH
17852: LD_INT 17
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: PUSH
17866: EMPTY
17867: LIST
17868: PPUSH
17869: CALL_OW 69
17873: ST_TO_ADDR
// if Opice > MaxOpice then
17874: LD_VAR 0 2
17878: PUSH
17879: LD_LOC 61
17883: GREATER
17884: IFFALSE 17888
// exit ;
17886: GO 18082
// Pocet = Rand ( 1 , OpiceNajednouPocet ) ;
17888: LD_ADDR_VAR 0 5
17892: PUSH
17893: LD_INT 1
17895: PPUSH
17896: LD_LOC 65
17900: PPUSH
17901: CALL_OW 12
17905: ST_TO_ADDR
// if ( OpiceLimit <> - 1 ) and ( Pocet > OpiceLimit ) then
17906: LD_LOC 64
17910: PUSH
17911: LD_INT 1
17913: NEG
17914: NONEQUAL
17915: PUSH
17916: LD_VAR 0 5
17920: PUSH
17921: LD_LOC 64
17925: GREATER
17926: AND
17927: IFFALSE 17939
// Pocet = OpiceLimit ;
17929: LD_ADDR_VAR 0 5
17933: PUSH
17934: LD_LOC 64
17938: ST_TO_ADDR
// Opice = create_nature ( CLASS_APEMAN , Pocet , CreateOpice ) ;
17939: LD_ADDR_VAR 0 2
17943: PUSH
17944: LD_INT 12
17946: PPUSH
17947: LD_VAR 0 5
17951: PPUSH
17952: LD_INT 14
17954: PPUSH
17955: CALL 2911 0 3
17959: ST_TO_ADDR
// for I in Opice do
17960: LD_ADDR_VAR 0 3
17964: PUSH
17965: LD_VAR 0 2
17969: PUSH
17970: FOR_IN
17971: IFFALSE 18035
// if Prob ( PstOpiceRus ) then
17973: LD_LOC 63
17977: PPUSH
17978: CALL_OW 13
17982: IFFALSE 18033
// begin Hex = RandHexArea ( Les , true ) ;
17984: LD_ADDR_VAR 0 4
17988: PUSH
17989: LD_INT 1
17991: PPUSH
17992: LD_INT 1
17994: PPUSH
17995: CALL_OW 16
17999: ST_TO_ADDR
// if Hex then
18000: LD_VAR 0 4
18004: IFFALSE 18033
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
18006: LD_VAR 0 3
18010: PPUSH
18011: LD_VAR 0 4
18015: PUSH
18016: LD_INT 1
18018: ARRAY
18019: PPUSH
18020: LD_VAR 0 4
18024: PUSH
18025: LD_INT 2
18027: ARRAY
18028: PPUSH
18029: CALL_OW 111
// end ;
18033: GO 17970
18035: POP
18036: POP
// if OpiceLimit <> - 1 then
18037: LD_LOC 64
18041: PUSH
18042: LD_INT 1
18044: NEG
18045: NONEQUAL
18046: IFFALSE 18082
// begin OpiceLimit = OpiceLimit - Pocet ;
18048: LD_ADDR_LOC 64
18052: PUSH
18053: LD_LOC 64
18057: PUSH
18058: LD_VAR 0 5
18062: MINUS
18063: ST_TO_ADDR
// if OpiceLimit = 0 then
18064: LD_LOC 64
18068: PUSH
18069: LD_INT 0
18071: EQUAL
18072: IFFALSE 18082
// Result = false ;
18074: LD_ADDR_VAR 0 1
18078: PUSH
18079: LD_INT 0
18081: ST_TO_ADDR
// end ; end ;
18082: LD_VAR 0 1
18086: RET
// every 0 0$15.3 do
18087: GO 18089
18089: DISABLE
// begin men_na_kamikaze ;
18090: CALL 17303 0 0
// enable ;
18094: ENABLE
// end ;
18095: END
// every 0 0$7.1 do
18096: GO 18098
18098: DISABLE
// begin kamikazuj_opicaky ;
18099: CALL 17130 0 0
// enable ;
18103: ENABLE
// end ;
18104: END
// every 1 1$13 do
18105: GO 18107
18107: DISABLE
// begin lakej_opice ;
18108: CALL 17543 0 0
// enable ;
18112: ENABLE
// end ;
18113: END
// every 2 2$25 do
18114: GO 18116
18116: DISABLE
// begin Wait ( Rand ( ZpozdeniOpice [ 1 ] , ZpozdeniOpice [ 2 ] ) ) ;
18117: LD_LOC 62
18121: PUSH
18122: LD_INT 1
18124: ARRAY
18125: PPUSH
18126: LD_LOC 62
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 12
18139: PPUSH
18140: CALL_OW 67
// if vytvor_nove_opice then
18144: CALL 17796 0 0
18148: IFFALSE 18151
// enable ;
18150: ENABLE
// end ;
18151: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
18152: LD_EXP 3
18156: PPUSH
18157: LD_EXP 2
18161: PPUSH
18162: CALL 21721 0 2
18166: IFFALSE 18179
18168: GO 18170
18170: DISABLE
// begin VidelRusa = true ;
18171: LD_ADDR_LOC 58
18175: PUSH
18176: LD_INT 1
18178: ST_TO_ADDR
// end ;
18179: END
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
18180: LD_INT 0
18182: PPUSH
18183: PPUSH
18184: PPUSH
// if Veh = ArDalkar then
18185: LD_VAR 0 1
18189: PUSH
18190: LD_LOC 49
18194: EQUAL
18195: IFFALSE 18236
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
18197: LD_LOC 36
18201: PPUSH
18202: CALL_OW 302
18206: PUSH
18207: LD_LOC 36
18211: PPUSH
18212: CALL_OW 310
18216: NOT
18217: AND
18218: IFFALSE 18236
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
18220: LD_LOC 36
18224: PPUSH
18225: LD_VAR 0 1
18229: PPUSH
18230: CALL_OW 120
// exit ;
18234: GO 18307
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: LD_LOC 39
18245: PPUSH
18246: LD_INT 56
18248: PUSH
18249: EMPTY
18250: LIST
18251: PUSH
18252: EMPTY
18253: LIST
18254: PPUSH
18255: CALL_OW 72
18259: ST_TO_ADDR
// for I in Lidi do
18260: LD_ADDR_VAR 0 4
18264: PUSH
18265: LD_VAR 0 3
18269: PUSH
18270: FOR_IN
18271: IFFALSE 18305
// if not HasTask ( I ) then
18273: LD_VAR 0 4
18277: PPUSH
18278: CALL_OW 314
18282: NOT
18283: IFFALSE 18303
// begin ComEnterUnit ( I , Veh ) ;
18285: LD_VAR 0 4
18289: PPUSH
18290: LD_VAR 0 1
18294: PPUSH
18295: CALL_OW 120
// exit ;
18299: POP
18300: POP
18301: GO 18307
// end ;
18303: GO 18270
18305: POP
18306: POP
// end ;
18307: LD_VAR 0 2
18311: RET
// function nastupuj_auta ; var Auta , I ; begin
18312: LD_INT 0
18314: PPUSH
18315: PPUSH
18316: PPUSH
// Auta = FilterUnitsInArea ( AraboveObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
18317: LD_ADDR_VAR 0 2
18321: PUSH
18322: LD_INT 12
18324: PPUSH
18325: LD_INT 21
18327: PUSH
18328: LD_INT 2
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: PUSH
18335: LD_INT 33
18337: PUSH
18338: LD_INT 1
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PUSH
18345: LD_INT 58
18347: PUSH
18348: EMPTY
18349: LIST
18350: PUSH
18351: EMPTY
18352: LIST
18353: LIST
18354: LIST
18355: PPUSH
18356: CALL_OW 70
18360: ST_TO_ADDR
// if not Auta then
18361: LD_VAR 0 2
18365: NOT
18366: IFFALSE 18370
// exit ;
18368: GO 18396
// for I in Auta do
18370: LD_ADDR_VAR 0 3
18374: PUSH
18375: LD_VAR 0 2
18379: PUSH
18380: FOR_IN
18381: IFFALSE 18394
// zarid_ridice ( I ) ;
18383: LD_VAR 0 3
18387: PPUSH
18388: CALL 18180 0 1
18392: GO 18380
18394: POP
18395: POP
// end ;
18396: LD_VAR 0 1
18400: RET
// every 0 0$17 do
18401: GO 18403
18403: DISABLE
// begin nastupuj_auta ;
18404: CALL 18312 0 0
// enable ;
18408: ENABLE
// end ;
18409: END
// every 0 0$5.1 do var I , Stahnout ;
18410: GO 18412
18412: DISABLE
18413: LD_INT 0
18415: PPUSH
18416: PPUSH
// begin Stahnout = true ;
18417: LD_ADDR_VAR 0 2
18421: PUSH
18422: LD_INT 1
18424: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
18425: LD_ADDR_VAR 0 1
18429: PUSH
18430: LD_LOC 43
18434: PPUSH
18435: CALL_OW 389
18439: PUSH
18440: FOR_IN
18441: IFFALSE 18472
// if ( GetUnitMc ( I ) = MakroObrana ) then
18443: LD_VAR 0 1
18447: PPUSH
18448: CALL_OW 388
18452: PUSH
18453: LD_LOC 43
18457: EQUAL
18458: IFFALSE 18470
// begin Stahnout = false ;
18460: LD_ADDR_VAR 0 2
18464: PUSH
18465: LD_INT 0
18467: ST_TO_ADDR
// break ;
18468: GO 18472
// end ;
18470: GO 18440
18472: POP
18473: POP
// enable ;
18474: ENABLE
// if Stahnout <> BeziStahovani then
18475: LD_VAR 0 2
18479: PUSH
18480: LD_LOC 60
18484: NONEQUAL
18485: IFFALSE 18511
// begin if Stahnout then
18487: LD_VAR 0 2
18491: IFFALSE 18498
// enable ( 46 ) else
18493: LD_INT 46
18495: ENABLE_MARKED
18496: GO 18501
// disable ( 46 ) ;
18498: LD_INT 46
18500: DISABLE_MARKED
// BeziStahovani = Stahnout ;
18501: LD_ADDR_LOC 60
18505: PUSH
18506: LD_VAR 0 2
18510: ST_TO_ADDR
// end ; end ;
18511: PPOPN 2
18513: END
// every 0 0$30 marked 32 do var I ;
18514: GO 18516
18516: DISABLE
18517: LD_INT 0
18519: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
18520: LD_ADDR_VAR 0 1
18524: PUSH
18525: LD_LOC 59
18529: PPUSH
18530: CALL_OW 389
18534: PUSH
18535: FOR_IN
18536: IFFALSE 18611
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , Arabove ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
18538: LD_VAR 0 1
18542: PPUSH
18543: CALL_OW 388
18547: PUSH
18548: LD_LOC 59
18552: EQUAL
18553: PUSH
18554: LD_VAR 0 1
18558: PPUSH
18559: LD_INT 5
18561: PPUSH
18562: CALL_OW 299
18566: PUSH
18567: LD_INT 0
18569: GREATER
18570: AND
18571: PUSH
18572: LD_VAR 0 1
18576: PPUSH
18577: CALL_OW 310
18581: NOT
18582: AND
18583: PUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 314
18593: NOT
18594: AND
18595: IFFALSE 18609
// ComMoveToArea ( I , Arabove ) ;
18597: LD_VAR 0 1
18601: PPUSH
18602: LD_INT 5
18604: PPUSH
18605: CALL_OW 113
18609: GO 18535
18611: POP
18612: POP
// BeziStahovani = false ;
18613: LD_ADDR_LOC 60
18617: PUSH
18618: LD_INT 0
18620: ST_TO_ADDR
// end ;
18621: PPOPN 1
18623: END
// every 1 1$16 do var Inz ;
18624: GO 18626
18626: DISABLE
18627: LD_INT 0
18629: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] , [ F_OK ] ] ) ;
18630: LD_ADDR_VAR 0 1
18634: PUSH
18635: LD_INT 22
18637: PUSH
18638: LD_EXP 3
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 21
18649: PUSH
18650: LD_INT 1
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: LD_INT 25
18659: PUSH
18660: LD_INT 2
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 50
18669: PUSH
18670: EMPTY
18671: LIST
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL_OW 69
18683: ST_TO_ADDR
// sbirej_bedny ( Inz , Arabove ) ;
18684: LD_VAR 0 1
18688: PPUSH
18689: LD_INT 5
18691: PPUSH
18692: CALL 21160 0 2
// opravuj_budovy ( Inz , Arabove , side_Ar ) ;
18696: LD_VAR 0 1
18700: PPUSH
18701: LD_INT 5
18703: PPUSH
18704: LD_EXP 3
18708: PPUSH
18709: CALL 21390 0 3
// enable ;
18713: ENABLE
// end ;
18714: PPOPN 1
18716: END
// function opravuj ; begin
18717: LD_INT 0
18719: PPUSH
// if KdoOpravuje then
18720: LD_LOC 67
18724: IFFALSE 18728
// exit ;
18726: GO 18768
// KdoOpravuje = opravuj_auta ( [ ArMech1 , ArMech2 ] , 104 , Arabove , side_Ar , Utok_Auta ) ;
18728: LD_ADDR_LOC 67
18732: PUSH
18733: LD_LOC 32
18737: PUSH
18738: LD_LOC 33
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: PPUSH
18747: LD_INT 104
18749: PPUSH
18750: LD_INT 5
18752: PPUSH
18753: LD_EXP 3
18757: PPUSH
18758: LD_LOC 41
18762: PPUSH
18763: CALL 21908 0 5
18767: ST_TO_ADDR
// end ;
18768: LD_VAR 0 1
18772: RET
// function kuryruj ; begin
18773: LD_INT 0
18775: PPUSH
// if KdoLeci then
18776: LD_LOC 66
18780: IFFALSE 18784
// exit ;
18782: GO 18837
// KdoLeci = kuryruj_lidi ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLakaOpice , 105 , Arabove , side_Ar ) ;
18784: LD_ADDR_LOC 66
18788: PUSH
18789: LD_LOC 28
18793: PUSH
18794: LD_LOC 29
18798: PUSH
18799: LD_LOC 30
18803: PUSH
18804: LD_LOC 31
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_LOC 68
18819: DIFF
18820: PPUSH
18821: LD_INT 105
18823: PPUSH
18824: LD_INT 5
18826: PPUSH
18827: LD_EXP 3
18831: PPUSH
18832: CALL 22210 0 4
18836: ST_TO_ADDR
// end ;
18837: LD_VAR 0 1
18841: RET
// export function event_ArabiOprava ( Event ) ; var Kdo ; begin
18842: LD_INT 0
18844: PPUSH
18845: PPUSH
// case Event of 104 :
18846: LD_VAR 0 1
18850: PUSH
18851: LD_INT 104
18853: DOUBLE
18854: EQUAL
18855: IFTRUE 18859
18857: GO 18881
18859: POP
// begin ComEnterUnit ( KdoOpravuje , ArFact ) ;
18860: LD_LOC 67
18864: PPUSH
18865: LD_INT 5
18867: PPUSH
18868: CALL_OW 120
// KdoOpravuje = [ ] ;
18872: LD_ADDR_LOC 67
18876: PUSH
18877: EMPTY
18878: ST_TO_ADDR
// end ; 105 :
18879: GO 18926
18881: LD_INT 105
18883: DOUBLE
18884: EQUAL
18885: IFTRUE 18889
18887: GO 18925
18889: POP
// begin for Kdo in KdoLeci do
18890: LD_ADDR_VAR 0 3
18894: PUSH
18895: LD_LOC 66
18899: PUSH
18900: FOR_IN
18901: IFFALSE 18914
// zpet_do_labu ( Kdo ) ;
18903: LD_VAR 0 3
18907: PPUSH
18908: CALL 13161 0 1
18912: GO 18900
18914: POP
18915: POP
// KdoLeci = [ ] ;
18916: LD_ADDR_LOC 66
18920: PUSH
18921: EMPTY
18922: ST_TO_ADDR
// end ; end ;
18923: GO 18926
18925: POP
// end ;
18926: LD_VAR 0 2
18930: RET
// every 0 0$57 do
18931: GO 18933
18933: DISABLE
// begin opravuj ;
18934: CALL 18717 0 0
// kuryruj ;
18938: CALL 18773 0 0
// enable ;
18942: ENABLE
// end ;
18943: END
// every 10 10$0 trigger difficulty = 3 do var i ;
18944: LD_OWVAR 67
18948: PUSH
18949: LD_INT 3
18951: EQUAL
18952: IFFALSE 19057
18954: GO 18956
18956: DISABLE
18957: LD_INT 0
18959: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , ar_gun ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ar_gatling_gun ] ] ] ) do
18960: LD_ADDR_VAR 0 1
18964: PUSH
18965: LD_INT 22
18967: PUSH
18968: LD_INT 2
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: PUSH
18975: LD_INT 21
18977: PUSH
18978: LD_INT 2
18980: PUSH
18981: EMPTY
18982: LIST
18983: LIST
18984: PUSH
18985: LD_INT 2
18987: PUSH
18988: LD_INT 34
18990: PUSH
18991: LD_INT 27
18993: PUSH
18994: EMPTY
18995: LIST
18996: LIST
18997: PUSH
18998: LD_INT 34
19000: PUSH
19001: LD_INT 28
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: LD_INT 34
19010: PUSH
19011: LD_INT 25
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: LIST
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: PPUSH
19029: CALL_OW 69
19033: PUSH
19034: FOR_IN
19035: IFFALSE 19054
// begin ComAgressiveMove ( i , 26 , 25 ) ;
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_INT 26
19044: PPUSH
19045: LD_INT 25
19047: PPUSH
19048: CALL_OW 114
// end ;
19052: GO 19034
19054: POP
19055: POP
// enable ;
19056: ENABLE
// end ; end_of_file
19057: PPOPN 1
19059: END
// export RusMaSiberit , RusMaOtraveno ; export ArabiZniceni , LegieMamZnicit , LegieZnicena ; export BehemothBuilt , MenLost ; export function init_rusove ; begin
19060: LD_INT 0
19062: PPUSH
// disable ( 21 ) ;
19063: LD_INT 21
19065: DISABLE_MARKED
// RusMaSiberit = false ;
19066: LD_ADDR_EXP 63
19070: PUSH
19071: LD_INT 0
19073: ST_TO_ADDR
// RusMaOtraveno = 0 ;
19074: LD_ADDR_EXP 64
19078: PUSH
19079: LD_INT 0
19081: ST_TO_ADDR
// ArabiZniceni = false ;
19082: LD_ADDR_EXP 65
19086: PUSH
19087: LD_INT 0
19089: ST_TO_ADDR
// LegieMamZnicit = false ;
19090: LD_ADDR_EXP 66
19094: PUSH
19095: LD_INT 0
19097: ST_TO_ADDR
// LegieZnicena = false ;
19098: LD_ADDR_EXP 67
19102: PUSH
19103: LD_INT 0
19105: ST_TO_ADDR
// BehemothBuilt = false ;
19106: LD_ADDR_EXP 68
19110: PUSH
19111: LD_INT 0
19113: ST_TO_ADDR
// MenLost = 0 ;
19114: LD_ADDR_EXP 69
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// end ;
19122: LD_VAR 0 1
19126: RET
// export function uvod ; var I , Auto ; begin
19127: LD_INT 0
19129: PPUSH
19130: PPUSH
19131: PPUSH
// InGameOn ;
19132: CALL_OW 8
// if Masha then
19136: LD_EXP 25
19140: IFFALSE 19173
// begin PlaceHumanInUnit ( Burlak , Masha ) ;
19142: LD_EXP 6
19146: PPUSH
19147: LD_EXP 25
19151: PPUSH
19152: CALL_OW 52
// PlaceUnitArea ( Masha , Start , false ) ;
19156: LD_EXP 25
19160: PPUSH
19161: LD_INT 3
19163: PPUSH
19164: LD_INT 0
19166: PPUSH
19167: CALL_OW 49
// end else
19171: GO 19215
// begin Auto = vytvor_tank ( RU_GUN ) ;
19173: LD_ADDR_VAR 0 3
19177: PUSH
19178: LD_INT 44
19180: PPUSH
19181: CALL 19536 0 1
19185: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , Auto ) ;
19186: LD_EXP 6
19190: PPUSH
19191: LD_VAR 0 3
19195: PPUSH
19196: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19200: LD_VAR 0 3
19204: PPUSH
19205: LD_INT 3
19207: PPUSH
19208: LD_INT 0
19210: PPUSH
19211: CALL_OW 49
// end ; PlaceUnitArea ( vytvor_nakladak ( MAT_OIL , 100 ) , Start , false ) ;
19215: LD_INT 2
19217: PPUSH
19218: LD_INT 100
19220: PPUSH
19221: CALL 19439 0 2
19225: PPUSH
19226: LD_INT 3
19228: PPUSH
19229: LD_INT 0
19231: PPUSH
19232: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19236: LD_INT 1
19238: PPUSH
19239: LD_INT 100
19241: PPUSH
19242: CALL 19439 0 2
19246: PPUSH
19247: LD_INT 3
19249: PPUSH
19250: LD_INT 0
19252: PPUSH
19253: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19257: LD_INT 1
19259: PPUSH
19260: LD_INT 100
19262: PPUSH
19263: CALL 19439 0 2
19267: PPUSH
19268: LD_INT 3
19270: PPUSH
19271: LD_INT 0
19273: PPUSH
19274: CALL_OW 49
// if Rusove then
19278: LD_EXP 39
19282: IFFALSE 19374
// begin Auto = 0 ;
19284: LD_ADDR_VAR 0 3
19288: PUSH
19289: LD_INT 0
19291: ST_TO_ADDR
// for I in Rusove do
19292: LD_ADDR_VAR 0 2
19296: PUSH
19297: LD_EXP 39
19301: PUSH
19302: FOR_IN
19303: IFFALSE 19372
// begin if Auto then
19305: LD_VAR 0 3
19309: IFFALSE 19328
// PlaceUnitArea ( I , Start , false ) else
19311: LD_VAR 0 2
19315: PPUSH
19316: LD_INT 3
19318: PPUSH
19319: LD_INT 0
19321: PPUSH
19322: CALL_OW 49
19326: GO 19370
// begin Auto = vytvor_tank ( RU_GATLING_GUN ) ;
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_INT 43
19335: PPUSH
19336: CALL 19536 0 1
19340: ST_TO_ADDR
// PlaceHumanInUnit ( I , Auto ) ;
19341: LD_VAR 0 2
19345: PPUSH
19346: LD_VAR 0 3
19350: PPUSH
19351: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19355: LD_VAR 0 3
19359: PPUSH
19360: LD_INT 3
19362: PPUSH
19363: LD_INT 0
19365: PPUSH
19366: CALL_OW 49
// end ; end ;
19370: GO 19302
19372: POP
19373: POP
// end ; I = IsInUnit ( Burlak ) ;
19374: LD_ADDR_VAR 0 2
19378: PUSH
19379: LD_EXP 6
19383: PPUSH
19384: CALL_OW 310
19388: ST_TO_ADDR
// if I then
19389: LD_VAR 0 2
19393: IFFALSE 19406
// CenterNowOnUnits ( I ) else
19395: LD_VAR 0 2
19399: PPUSH
19400: CALL_OW 87
19404: GO 19415
// CenterNowOnUnits ( Burlak ) ;
19406: LD_EXP 6
19410: PPUSH
19411: CALL_OW 87
// dialog_Start ;
19415: CALL 4653 0 0
// ChangeMissionObjectives ( MStart ) ;
19419: LD_STRING MStart
19421: PPUSH
19422: CALL_OW 337
// SaveForQuickRestart ;
19426: CALL_OW 22
// InGameOff ;
19430: CALL_OW 9
// end ;
19434: LD_VAR 0 1
19438: RET
// function vytvor_nakladak ( Material , Amount ) ; begin
19439: LD_INT 0
19441: PPUSH
// UC_Side = side_Ru ;
19442: LD_ADDR_OWVAR 20
19446: PUSH
19447: LD_EXP 2
19451: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19452: LD_ADDR_OWVAR 21
19456: PUSH
19457: LD_INT 3
19459: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19460: LD_ADDR_OWVAR 37
19464: PUSH
19465: LD_INT 21
19467: ST_TO_ADDR
// VC_Control = CONTROL_COMPUTER ;
19468: LD_ADDR_OWVAR 38
19472: PUSH
19473: LD_INT 3
19475: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
19476: LD_ADDR_OWVAR 39
19480: PUSH
19481: LD_INT 3
19483: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
19484: LD_ADDR_OWVAR 40
19488: PUSH
19489: LD_INT 51
19491: ST_TO_ADDR
// Result = CreateVehicle ;
19492: LD_ADDR_VAR 0 3
19496: PUSH
19497: CALL_OW 45
19501: ST_TO_ADDR
// if Amount > 0 then
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 0
19509: GREATER
19510: IFFALSE 19531
// SetCargo ( Result , Material , Amount ) ;
19512: LD_VAR 0 3
19516: PPUSH
19517: LD_VAR 0 1
19521: PPUSH
19522: LD_VAR 0 2
19526: PPUSH
19527: CALL_OW 290
// end ;
19531: LD_VAR 0 3
19535: RET
// function vytvor_tank ( Zbran ) ; begin
19536: LD_INT 0
19538: PPUSH
// UC_Side = side_Ru ;
19539: LD_ADDR_OWVAR 20
19543: PUSH
19544: LD_EXP 2
19548: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19549: LD_ADDR_OWVAR 21
19553: PUSH
19554: LD_INT 3
19556: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19557: LD_ADDR_OWVAR 37
19561: PUSH
19562: LD_INT 21
19564: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
19565: LD_ADDR_OWVAR 38
19569: PUSH
19570: LD_INT 1
19572: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
19573: LD_ADDR_OWVAR 39
19577: PUSH
19578: LD_INT 1
19580: ST_TO_ADDR
// VC_Weapon = Zbran ;
19581: LD_ADDR_OWVAR 40
19585: PUSH
19586: LD_VAR 0 1
19590: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 70 , 90 ) ;
19591: LD_ADDR_OWVAR 41
19595: PUSH
19596: LD_INT 70
19598: PPUSH
19599: LD_INT 90
19601: PPUSH
19602: CALL_OW 12
19606: ST_TO_ADDR
// Result = CreateVehicle ;
19607: LD_ADDR_VAR 0 2
19611: PUSH
19612: CALL_OW 45
19616: ST_TO_ADDR
// end ;
19617: LD_VAR 0 2
19621: RET
// function arabska_zakladna_kaput ; begin
19622: LD_INT 0
19624: PPUSH
// Wait ( 0 0$3.5 ) ;
19625: LD_INT 122
19627: PPUSH
19628: CALL_OW 67
// SetAttitude ( side_Ru , side_Ar , ATT_NEUTRAL , true ) ;
19632: LD_EXP 2
19636: PPUSH
19637: LD_EXP 3
19641: PPUSH
19642: LD_INT 0
19644: PPUSH
19645: LD_INT 1
19647: PPUSH
19648: CALL_OW 80
// disable ( 31 ) ;
19652: LD_INT 31
19654: DISABLE_MARKED
// DialogueOn ;
19655: CALL_OW 6
// dialog_SurrenderArabians ;
19659: CALL 5583 0 0
// DialogueOff ;
19663: CALL_OW 7
// ChangeMissionObjectives ( MAttOut ) ;
19667: LD_STRING MAttOut
19669: PPUSH
19670: CALL_OW 337
// if LegionOffer_Accepted or LegionFugit_Accepted then
19674: LD_EXP 59
19678: PUSH
19679: LD_EXP 60
19683: OR
19684: IFFALSE 19761
// begin if LegieZnicena then
19686: LD_EXP 67
19690: IFFALSE 19698
// begin vyhral ;
19692: CALL 2085 0 0
// exit ;
19696: GO 19765
// end ; LegieMamZnicit = true ;
19698: LD_ADDR_EXP 66
19702: PUSH
19703: LD_INT 1
19705: ST_TO_ADDR
// if UnitFilter ( Uprchlici , [ [ F_ALIVE ] ] ) then
19706: LD_EXP 61
19710: PPUSH
19711: LD_INT 51
19713: PUSH
19714: EMPTY
19715: LIST
19716: PUSH
19717: EMPTY
19718: LIST
19719: PPUSH
19720: CALL_OW 72
19724: IFFALSE 19756
// begin DialogueOn ;
19726: CALL_OW 6
// dialog_LegionLeave ;
19730: CALL 5207 0 0
// DialogueOff ;
19734: CALL_OW 7
// SetSide ( Uprchlici , side_Upr ) ;
19738: LD_EXP 61
19742: PPUSH
19743: LD_EXP 5
19747: PPUSH
19748: CALL_OW 235
// uprchlici_zacnete_odchazet ;
19752: CALL 10712 0 0
// end ; enable ( 21 ) ;
19756: LD_INT 21
19758: ENABLE_MARKED
// end else
19759: GO 19765
// begin vyhral ;
19761: CALL 2085 0 0
// end ; end ;
19765: LD_VAR 0 1
19769: RET
// function legie_zakladna_kaput ; begin
19770: LD_INT 0
19772: PPUSH
// SetAttitude ( side_Le , side_Ru , ATT_NEUTRAL , true ) ;
19773: LD_EXP 4
19777: PPUSH
19778: LD_EXP 2
19782: PPUSH
19783: LD_INT 0
19785: PPUSH
19786: LD_INT 1
19788: PPUSH
19789: CALL_OW 80
// SetAttitude ( side_Upr , side_Ru , ATT_NEUTRAL , true ) ;
19793: LD_EXP 5
19797: PPUSH
19798: LD_EXP 2
19802: PPUSH
19803: LD_INT 0
19805: PPUSH
19806: LD_INT 1
19808: PPUSH
19809: CALL_OW 80
// ChangeMissionObjectives ( MLegOut ) ;
19813: LD_STRING MLegOut
19815: PPUSH
19816: CALL_OW 337
// if ArabiZniceni then
19820: LD_EXP 65
19824: IFFALSE 19830
// vyhral ;
19826: CALL 2085 0 0
// end ;
19830: LD_VAR 0 1
19834: RET
// function kontrola_arabska_zakladna ; var Domy , Lidi ; begin
19835: LD_INT 0
19837: PPUSH
19838: PPUSH
19839: PPUSH
// if ArabiZniceni then
19840: LD_EXP 65
19844: IFFALSE 19848
// exit ;
19846: GO 19990
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
19848: LD_ADDR_VAR 0 2
19852: PUSH
19853: LD_INT 22
19855: PUSH
19856: LD_EXP 3
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: LD_INT 52
19867: PUSH
19868: EMPTY
19869: LIST
19870: PUSH
19871: LD_INT 50
19873: PUSH
19874: EMPTY
19875: LIST
19876: PUSH
19877: LD_INT 21
19879: PUSH
19880: LD_INT 3
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: LIST
19891: LIST
19892: PPUSH
19893: CALL_OW 69
19897: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
19898: LD_ADDR_VAR 0 3
19902: PUSH
19903: LD_INT 22
19905: PUSH
19906: LD_EXP 3
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PUSH
19915: LD_INT 52
19917: PUSH
19918: EMPTY
19919: LIST
19920: PUSH
19921: LD_INT 50
19923: PUSH
19924: EMPTY
19925: LIST
19926: PUSH
19927: LD_INT 21
19929: PUSH
19930: LD_INT 1
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: PPUSH
19943: CALL_OW 69
19947: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and ( Lidi < dif_ArabiLidiVzdajSe [ Difficulty ] ) then
19948: LD_VAR 0 2
19952: PPUSH
19953: CALL 21809 0 1
19957: NOT
19958: PUSH
19959: LD_VAR 0 3
19963: PUSH
19964: LD_EXP 56
19968: PUSH
19969: LD_OWVAR 67
19973: ARRAY
19974: LESS
19975: AND
19976: IFFALSE 19990
// begin ArabiZniceni = true ;
19978: LD_ADDR_EXP 65
19982: PUSH
19983: LD_INT 1
19985: ST_TO_ADDR
// arabska_zakladna_kaput ;
19986: CALL 19622 0 0
// end ; end ;
19990: LD_VAR 0 1
19994: RET
// function kontrola_legie_zakladna ; var Domy , Lidi ; begin
19995: LD_INT 0
19997: PPUSH
19998: PPUSH
19999: PPUSH
// if LegieZnicena then
20000: LD_EXP 67
20004: IFFALSE 20008
// exit ;
20006: GO 20231
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
20008: LD_ADDR_VAR 0 2
20012: PUSH
20013: LD_INT 22
20015: PUSH
20016: LD_EXP 4
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: LD_INT 50
20027: PUSH
20028: EMPTY
20029: LIST
20030: PUSH
20031: LD_INT 52
20033: PUSH
20034: EMPTY
20035: LIST
20036: PUSH
20037: LD_INT 21
20039: PUSH
20040: LD_INT 3
20042: PUSH
20043: EMPTY
20044: LIST
20045: LIST
20046: PUSH
20047: EMPTY
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: PPUSH
20053: CALL_OW 69
20057: PUSH
20058: LD_INT 22
20060: PUSH
20061: LD_EXP 5
20065: PUSH
20066: EMPTY
20067: LIST
20068: LIST
20069: PUSH
20070: LD_INT 50
20072: PUSH
20073: EMPTY
20074: LIST
20075: PUSH
20076: LD_INT 52
20078: PUSH
20079: EMPTY
20080: LIST
20081: PUSH
20082: LD_INT 21
20084: PUSH
20085: LD_INT 3
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: PPUSH
20098: CALL_OW 69
20102: UNION
20103: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_INT 22
20111: PUSH
20112: LD_EXP 4
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: LD_INT 50
20123: PUSH
20124: EMPTY
20125: LIST
20126: PUSH
20127: LD_INT 52
20129: PUSH
20130: EMPTY
20131: LIST
20132: PUSH
20133: LD_INT 21
20135: PUSH
20136: LD_INT 1
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: PUSH
20143: EMPTY
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: PPUSH
20149: CALL_OW 69
20153: PUSH
20154: LD_INT 22
20156: PUSH
20157: LD_EXP 5
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: LD_INT 50
20168: PUSH
20169: EMPTY
20170: LIST
20171: PUSH
20172: LD_INT 52
20174: PUSH
20175: EMPTY
20176: LIST
20177: PUSH
20178: LD_INT 21
20180: PUSH
20181: LD_INT 1
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: PUSH
20188: EMPTY
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: PPUSH
20194: CALL_OW 69
20198: UNION
20199: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and not Lidi then
20200: LD_VAR 0 2
20204: PPUSH
20205: CALL 21809 0 1
20209: NOT
20210: PUSH
20211: LD_VAR 0 3
20215: NOT
20216: AND
20217: IFFALSE 20231
// begin LegieZnicena = true ;
20219: LD_ADDR_EXP 67
20223: PUSH
20224: LD_INT 1
20226: ST_TO_ADDR
// legie_zakladna_kaput ;
20227: CALL 19770 0 0
// end ; end ;
20231: LD_VAR 0 1
20235: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
20236: LD_INT 0
20238: PPUSH
// if Un = Burlak then
20239: LD_VAR 0 1
20243: PUSH
20244: LD_EXP 6
20248: EQUAL
20249: IFFALSE 20260
// begin YouLost ( Burlak ) ;
20251: LD_STRING Burlak
20253: PPUSH
20254: CALL_OW 104
// exit ;
20258: GO 20294
// end ; if Un in Rusove then
20260: LD_VAR 0 1
20264: PUSH
20265: LD_EXP 39
20269: IN
20270: IFFALSE 20286
// MenLost = MenLost + 1 ;
20272: LD_ADDR_EXP 69
20276: PUSH
20277: LD_EXP 69
20281: PUSH
20282: LD_INT 1
20284: PLUS
20285: ST_TO_ADDR
// kontrola_arabska_zakladna ;
20286: CALL 19835 0 0
// kontrola_legie_zakladna ;
20290: CALL 19995 0 0
// end ;
20294: LD_VAR 0 2
20298: RET
// export function rusove_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
20299: LD_INT 0
20301: PPUSH
// if OrigSide = side_Ar then
20302: LD_VAR 0 2
20306: PUSH
20307: LD_EXP 3
20311: EQUAL
20312: IFFALSE 20318
// kontrola_arabska_zakladna ;
20314: CALL 19835 0 0
// if OrigSide = side_Le then
20318: LD_VAR 0 2
20322: PUSH
20323: LD_EXP 4
20327: EQUAL
20328: IFFALSE 20334
// kontrola_legie_zakladna ;
20330: CALL 19995 0 0
// end ;
20334: LD_VAR 0 4
20338: RET
// export function rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
20339: LD_INT 0
20341: PPUSH
// if OrigSide = side_Ru then
20342: LD_VAR 0 3
20346: PUSH
20347: LD_EXP 2
20351: EQUAL
20352: IFFALSE 20358
// kontrola_arabska_zakladna ;
20354: CALL 19835 0 0
// if Masha = VehOld then
20358: LD_EXP 25
20362: PUSH
20363: LD_VAR 0 2
20367: EQUAL
20368: IFFALSE 20380
// Masha = VehNew ;
20370: LD_ADDR_EXP 25
20374: PUSH
20375: LD_VAR 0 1
20379: ST_TO_ADDR
// end ;
20380: LD_VAR 0 5
20384: RET
// every 0 0$10 marked 21 do
20385: GO 20387
20387: DISABLE
// begin Wait ( Rand ( 0 0$15 , 0 0$35 ) ) ;
20388: LD_INT 525
20390: PPUSH
20391: LD_INT 1225
20393: PPUSH
20394: CALL_OW 12
20398: PPUSH
20399: CALL_OW 67
// DialogueOn ;
20403: CALL_OW 6
// dialog_LegionSpy ;
20407: CALL 5285 0 0
// if LegionOffer_Heike then
20411: LD_EXP 58
20415: IFFALSE 20423
// dialog_LegionChallengeHeike else
20417: CALL 5351 0 0
20421: GO 20427
// dialog_LegionChallengeFarmer ;
20423: CALL 5413 0 0
// ChangeMissionObjectives ( MLeg ) ;
20427: LD_STRING MLeg
20429: PPUSH
20430: CALL_OW 337
// SetAttitude ( side_Ru , side_Le , ATT_ENEMY , true ) ;
20434: LD_EXP 2
20438: PPUSH
20439: LD_EXP 4
20443: PPUSH
20444: LD_INT 2
20446: PPUSH
20447: LD_INT 1
20449: PPUSH
20450: CALL_OW 80
// SetAttitude ( side_Ru , side_Upr , ATT_ENEMY , true ) ;
20454: LD_EXP 2
20458: PPUSH
20459: LD_EXP 5
20463: PPUSH
20464: LD_INT 2
20466: PPUSH
20467: LD_INT 1
20469: PPUSH
20470: CALL_OW 80
// DialogueOff ;
20474: CALL_OW 7
// end ;
20478: END
// every 4 4$30 do
20479: GO 20481
20481: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
20482: LD_INT 35
20484: PPUSH
20485: LD_INT 4200
20487: PPUSH
20488: CALL_OW 12
20492: PPUSH
20493: CALL_OW 67
// DialogueOn ;
20497: CALL_OW 6
// dialog_AmAttack ;
20501: CALL 4719 0 0
// ChangeMissionObjectives ( MAttack ) ;
20505: LD_STRING MAttack
20507: PPUSH
20508: CALL_OW 337
// DialogueOff ;
20512: CALL_OW 7
// end ;
20516: END
// every 9 9$0 do
20517: GO 20519
20519: DISABLE
// begin Wait ( Rand ( 0 0$1 , 4 4$0 ) ) ;
20520: LD_INT 35
20522: PPUSH
20523: LD_INT 8400
20525: PPUSH
20526: CALL_OW 12
20530: PPUSH
20531: CALL_OW 67
// if not BehemothBuilt then
20535: LD_EXP 68
20539: NOT
20540: IFFALSE 20573
// begin DialogueOn ;
20542: CALL_OW 6
// if BehemothSeen then
20546: LD_EXP 36
20550: IFFALSE 20558
// dialog_BehemothTechno1 else
20552: CALL 5691 0 0
20556: GO 20562
// dialog_BehemothTechno2 ;
20558: CALL 5826 0 0
// ChangeMissionObjectives ( MBeh ) ;
20562: LD_STRING MBeh
20564: PPUSH
20565: CALL_OW 337
// DialogueOff ;
20569: CALL_OW 7
// end ; end ;
20573: END
// export function rusove_BuildingComplete ( Build ) ; begin
20574: LD_INT 0
20576: PPUSH
// if GetSide ( Build ) = side_Ru then
20577: LD_VAR 0 1
20581: PPUSH
20582: CALL_OW 255
20586: PUSH
20587: LD_EXP 2
20591: EQUAL
20592: IFFALSE 20617
// begin if GetBType ( Build ) = B_SIBERITE_MINE then
20594: LD_VAR 0 1
20598: PPUSH
20599: CALL_OW 266
20603: PUSH
20604: LD_INT 30
20606: EQUAL
20607: IFFALSE 20617
// RusMaSiberit = true ;
20609: LD_ADDR_EXP 63
20613: PUSH
20614: LD_INT 1
20616: ST_TO_ADDR
// end ; end ;
20617: LD_VAR 0 2
20621: RET
// export function rusove_BehemothConstructed ( Un ) ; begin
20622: LD_INT 0
20624: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and not BehemothBuilt then
20625: LD_VAR 0 1
20629: PPUSH
20630: CALL_OW 255
20634: PUSH
20635: LD_EXP 2
20639: EQUAL
20640: PUSH
20641: LD_EXP 68
20645: NOT
20646: AND
20647: IFFALSE 20676
// begin BehemothBuilt = true ;
20649: LD_ADDR_EXP 68
20653: PUSH
20654: LD_INT 1
20656: ST_TO_ADDR
// DialogueOn ;
20657: CALL_OW 6
// dialog_BehemothComplete ;
20661: CALL 5930 0 0
// ChangeMissionObjectives ( MBehOut ) ;
20665: LD_STRING MBehOut
20667: PPUSH
20668: CALL_OW 337
// DialogueOff ;
20672: CALL_OW 7
// end ; end ;
20676: LD_VAR 0 2
20680: RET
// export function rusove_SibDepositContaminated ( Un , X , Y ) ; begin
20681: LD_INT 0
20683: PPUSH
// RusMaOtraveno = RusMaOtraveno + 1 ;
20684: LD_ADDR_EXP 64
20688: PUSH
20689: LD_EXP 64
20693: PUSH
20694: LD_INT 1
20696: PLUS
20697: ST_TO_ADDR
// if RusMaOtraveno = 1 then
20698: LD_EXP 64
20702: PUSH
20703: LD_INT 1
20705: EQUAL
20706: IFFALSE 20735
// begin Wait ( Rand ( 0 0$1 , 0 0$10 ) ) ;
20708: LD_INT 35
20710: PPUSH
20711: LD_INT 350
20713: PPUSH
20714: CALL_OW 12
20718: PPUSH
20719: CALL_OW 67
// DialogueOn ;
20723: CALL_OW 6
// dialog_Contam ;
20727: CALL 5481 0 0
// DialogueOff ;
20731: CALL_OW 7
// end ; end ; end_of_file
20735: LD_VAR 0 4
20739: RET
// on Contact ( Side1 , Side2 ) do begin legion_Contact ( Side1 , Side2 ) ;
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 2
20749: PPUSH
20750: CALL 11224 0 2
// end ;
20754: PPOPN 2
20756: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
20757: LD_VAR 0 1
20761: PPUSH
20762: CALL 20236 0 1
// arabi_UnitDestroyed ( Un ) ;
20766: LD_VAR 0 1
20770: PPUSH
20771: CALL 14125 0 1
// legion_UnitDestroyed ( Un ) ;
20775: LD_VAR 0 1
20779: PPUSH
20780: CALL 11307 0 1
// end ;
20784: PPOPN 1
20786: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
20787: LD_VAR 0 1
20791: PPUSH
20792: LD_VAR 0 2
20796: PPUSH
20797: CALL 14882 0 2
// legion_VehicleConstructed ( Veh , Fact ) ;
20801: LD_VAR 0 1
20805: PPUSH
20806: LD_VAR 0 2
20810: PPUSH
20811: CALL 7738 0 2
// end ;
20815: PPOPN 2
20817: END
// on BuildingComplete ( Build ) do begin rusove_BuildingComplete ( Build ) ;
20818: LD_VAR 0 1
20822: PPUSH
20823: CALL 20574 0 1
// end ;
20827: PPOPN 1
20829: END
// on SibDepositContaminated ( Un , X , Y ) do begin rusove_SibDepositContaminated ( Un , X , Y ) ;
20830: LD_VAR 0 1
20834: PPUSH
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 3
20844: PPUSH
20845: CALL 20681 0 3
// end ;
20849: PPOPN 3
20851: END
// on SailEvent ( Event ) do begin case Event of 101 :
20852: LD_VAR 0 1
20856: PUSH
20857: LD_INT 101
20859: DOUBLE
20860: EQUAL
20861: IFTRUE 20865
20863: GO 20872
20865: POP
// event_Kontaminovano ; 103 :
20866: CALL 14083 0 0
20870: GO 20985
20872: LD_INT 103
20874: DOUBLE
20875: EQUAL
20876: IFTRUE 20880
20878: GO 20887
20880: POP
// event_DolakanaOpice ; 104 , 105 :
20881: CALL 17754 0 0
20885: GO 20985
20887: LD_INT 104
20889: DOUBLE
20890: EQUAL
20891: IFTRUE 20901
20893: LD_INT 105
20895: DOUBLE
20896: EQUAL
20897: IFTRUE 20901
20899: GO 20913
20901: POP
// event_ArabiOprava ( Event ) ; 111 :
20902: LD_VAR 0 1
20906: PPUSH
20907: CALL 18842 0 1
20911: GO 20985
20913: LD_INT 111
20915: DOUBLE
20916: EQUAL
20917: IFTRUE 20921
20919: GO 20928
20921: POP
// event_KoupeniPrisli ; 112 :
20922: CALL 9894 0 0
20926: GO 20985
20928: LD_INT 112
20930: DOUBLE
20931: EQUAL
20932: IFTRUE 20936
20934: GO 20943
20936: POP
// event_UprchliciPrisli ; 113 , 114 :
20937: CALL 10764 0 0
20941: GO 20985
20943: LD_INT 113
20945: DOUBLE
20946: EQUAL
20947: IFTRUE 20957
20949: LD_INT 114
20951: DOUBLE
20952: EQUAL
20953: IFTRUE 20957
20955: GO 20969
20957: POP
// event_LegionOprava ( Event ) ; 115 :
20958: LD_VAR 0 1
20962: PPUSH
20963: CALL 7389 0 1
20967: GO 20985
20969: LD_INT 115
20971: DOUBLE
20972: EQUAL
20973: IFTRUE 20977
20975: GO 20984
20977: POP
// event_LegionPrebarvi ; end ;
20978: CALL 10735 0 0
20982: GO 20985
20984: POP
// end ;
20985: PPOPN 1
20987: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin rusove_BuildingCaptured ( Build , OrigSide , Eng ) ;
20988: LD_VAR 0 1
20992: PPUSH
20993: LD_VAR 0 2
20997: PPUSH
20998: LD_VAR 0 3
21002: PPUSH
21003: CALL 20299 0 3
// end ;
21007: PPOPN 3
21009: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
21010: LD_VAR 0 1
21014: PPUSH
21015: LD_VAR 0 2
21019: PPUSH
21020: LD_VAR 0 3
21024: PPUSH
21025: LD_VAR 0 4
21029: PPUSH
21030: CALL 20339 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
21034: LD_VAR 0 1
21038: PPUSH
21039: LD_VAR 0 2
21043: PPUSH
21044: LD_VAR 0 3
21048: PPUSH
21049: LD_VAR 0 4
21053: PPUSH
21054: CALL 14457 0 4
// legion_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
21058: LD_VAR 0 1
21062: PPUSH
21063: LD_VAR 0 2
21067: PPUSH
21068: LD_VAR 0 3
21072: PPUSH
21073: LD_VAR 0 4
21077: PPUSH
21078: CALL 11290 0 4
// end ;
21082: PPOPN 4
21084: END
// on BehemothConstructed ( Un ) do begin SA_BehemothConstructed ;
21085: CALL 22926 0 0
// rusove_BehemothConstructed ( Un ) ;
21089: LD_VAR 0 1
21093: PPUSH
21094: CALL 20622 0 1
// end ;
21098: PPOPN 1
21100: END
// on ApemanTamed ( Ape , Sci ) do begin arabi_ApemanTamed ( Ape , Sci ) ;
21101: LD_VAR 0 1
21105: PPUSH
21106: LD_VAR 0 2
21110: PPUSH
21111: CALL 17088 0 2
// end ;
21115: PPOPN 2
21117: END
// on EnterBuilding ( Building , Un ) do begin arabi_EnterBuilding ( Building , Un ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_VAR 0 2
21127: PPUSH
21128: CALL 14814 0 2
// end ;
21132: PPOPN 2
21134: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
21135: LD_VAR 0 1
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: CALL 16414 0 2
// end ;
21149: PPOPN 2
21151: END
// every 1 1$59 do
21152: GO 21154
21154: DISABLE
// begin RandomizeAll ;
21155: CALL_OW 11
// end ; end_of_file
21159: END
// export function sbirej_bedny ( Jednotky , Area ) ; var I , Ok , Kdo , Bedny , Delka , X , Y ; begin
21160: LD_INT 0
21162: PPUSH
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
21167: PPUSH
21168: PPUSH
21169: PPUSH
// Ok = false ;
21170: LD_ADDR_VAR 0 5
21174: PUSH
21175: LD_INT 0
21177: ST_TO_ADDR
// for Kdo in Jednotky do
21178: LD_ADDR_VAR 0 6
21182: PUSH
21183: LD_VAR 0 1
21187: PUSH
21188: FOR_IN
21189: IFFALSE 21214
// if IsOk ( Kdo ) then
21191: LD_VAR 0 6
21195: PPUSH
21196: CALL_OW 302
21200: IFFALSE 21212
// begin Ok = true ;
21202: LD_ADDR_VAR 0 5
21206: PUSH
21207: LD_INT 1
21209: ST_TO_ADDR
// break ;
21210: GO 21214
// end ;
21212: GO 21188
21214: POP
21215: POP
// if not Ok then
21216: LD_VAR 0 5
21220: NOT
21221: IFFALSE 21225
// exit ;
21223: GO 21385
// Bedny = GetListOfCratesInArea ( Area ) ;
21225: LD_ADDR_VAR 0 7
21229: PUSH
21230: LD_VAR 0 2
21234: PPUSH
21235: CALL_OW 435
21239: ST_TO_ADDR
// if not Bedny then
21240: LD_VAR 0 7
21244: NOT
21245: IFFALSE 21249
// exit ;
21247: GO 21385
// Delka = Bedny div 2 ;
21249: LD_ADDR_VAR 0 8
21253: PUSH
21254: LD_VAR 0 7
21258: PUSH
21259: LD_INT 2
21261: DIV
21262: ST_TO_ADDR
// for I = 1 to Delka do
21263: LD_ADDR_VAR 0 4
21267: PUSH
21268: DOUBLE
21269: LD_INT 1
21271: DEC
21272: ST_TO_ADDR
21273: LD_VAR 0 8
21277: PUSH
21278: FOR_TO
21279: IFFALSE 21383
// begin X = Bedny [ 2 * I - 1 ] ;
21281: LD_ADDR_VAR 0 9
21285: PUSH
21286: LD_VAR 0 7
21290: PUSH
21291: LD_INT 2
21293: PUSH
21294: LD_VAR 0 4
21298: MUL
21299: PUSH
21300: LD_INT 1
21302: MINUS
21303: ARRAY
21304: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
21305: LD_ADDR_VAR 0 10
21309: PUSH
21310: LD_VAR 0 7
21314: PUSH
21315: LD_INT 2
21317: PUSH
21318: LD_VAR 0 4
21322: MUL
21323: ARRAY
21324: ST_TO_ADDR
// for Kdo in Jednotky do
21325: LD_ADDR_VAR 0 6
21329: PUSH
21330: LD_VAR 0 1
21334: PUSH
21335: FOR_IN
21336: IFFALSE 21379
// if IsOk ( Kdo ) and Prob ( 50 ) then
21338: LD_VAR 0 6
21342: PPUSH
21343: CALL_OW 302
21347: PUSH
21348: LD_INT 50
21350: PPUSH
21351: CALL_OW 13
21355: AND
21356: IFFALSE 21377
// AddComCollect ( Kdo , X , Y ) ;
21358: LD_VAR 0 6
21362: PPUSH
21363: LD_VAR 0 9
21367: PPUSH
21368: LD_VAR 0 10
21372: PPUSH
21373: CALL_OW 177
21377: GO 21335
21379: POP
21380: POP
// end ;
21381: GO 21278
21383: POP
21384: POP
// end ;
21385: LD_VAR 0 3
21389: RET
// export function opravuj_budovy ( Jednotky , Area , Side ) ; var Budovy , Opravit , I , Kde ; begin
21390: LD_INT 0
21392: PPUSH
21393: PPUSH
21394: PPUSH
21395: PPUSH
21396: PPUSH
// Budovy = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , Side ] ] ) ;
21397: LD_ADDR_VAR 0 5
21401: PUSH
21402: LD_VAR 0 2
21406: PPUSH
21407: LD_INT 21
21409: PUSH
21410: LD_INT 3
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: PUSH
21417: LD_INT 22
21419: PUSH
21420: LD_VAR 0 3
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: PPUSH
21433: CALL_OW 70
21437: ST_TO_ADDR
// Opravit = [ ] ;
21438: LD_ADDR_VAR 0 6
21442: PUSH
21443: EMPTY
21444: ST_TO_ADDR
// for I in Budovy do
21445: LD_ADDR_VAR 0 7
21449: PUSH
21450: LD_VAR 0 5
21454: PUSH
21455: FOR_IN
21456: IFFALSE 21494
// if GetLives ( I ) < HRANICE_ZDRAVI then
21458: LD_VAR 0 7
21462: PPUSH
21463: CALL_OW 256
21467: PUSH
21468: LD_INT 1000
21470: LESS
21471: IFFALSE 21492
// Opravit = Opravit union [ I ] ;
21473: LD_ADDR_VAR 0 6
21477: PUSH
21478: LD_VAR 0 6
21482: PUSH
21483: LD_VAR 0 7
21487: PUSH
21488: EMPTY
21489: LIST
21490: UNION
21491: ST_TO_ADDR
21492: GO 21455
21494: POP
21495: POP
// for I in Opravit do
21496: LD_ADDR_VAR 0 7
21500: PUSH
21501: LD_VAR 0 6
21505: PUSH
21506: FOR_IN
21507: IFFALSE 21525
// AddComRepairBuilding ( Jednotky , I ) ;
21509: LD_VAR 0 1
21513: PPUSH
21514: LD_VAR 0 7
21518: PPUSH
21519: CALL_OW 190
21523: GO 21506
21525: POP
21526: POP
// end ;
21527: LD_VAR 0 4
21531: RET
// export function min ( A , B ) ; begin
21532: LD_INT 0
21534: PPUSH
// if A < B then
21535: LD_VAR 0 1
21539: PUSH
21540: LD_VAR 0 2
21544: LESS
21545: IFFALSE 21559
// Result = A else
21547: LD_ADDR_VAR 0 3
21551: PUSH
21552: LD_VAR 0 1
21556: ST_TO_ADDR
21557: GO 21569
// Result = B ;
21559: LD_ADDR_VAR 0 3
21563: PUSH
21564: LD_VAR 0 2
21568: ST_TO_ADDR
// end ;
21569: LD_VAR 0 3
21573: RET
// export function vidi_strana_cloveka ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21574: LD_INT 0
21576: PPUSH
21577: PPUSH
21578: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
21579: LD_ADDR_VAR 0 4
21583: PUSH
21584: LD_INT 22
21586: PUSH
21587: LD_VAR 0 2
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PUSH
21596: LD_INT 21
21598: PUSH
21599: LD_INT 1
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: PPUSH
21610: CALL_OW 69
21614: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21615: LD_ADDR_VAR 0 5
21619: PUSH
21620: LD_VAR 0 4
21624: PUSH
21625: FOR_IN
21626: IFFALSE 21658
// if See ( Kdo , Jednotka ) then
21628: LD_VAR 0 1
21632: PPUSH
21633: LD_VAR 0 5
21637: PPUSH
21638: CALL_OW 292
21642: IFFALSE 21656
// begin Result = true ;
21644: LD_ADDR_VAR 0 3
21648: PUSH
21649: LD_INT 1
21651: ST_TO_ADDR
// exit ;
21652: POP
21653: POP
21654: GO 21668
// end ;
21656: GO 21625
21658: POP
21659: POP
// Result = false ;
21660: LD_ADDR_VAR 0 3
21664: PUSH
21665: LD_INT 0
21667: ST_TO_ADDR
// end ;
21668: LD_VAR 0 3
21672: RET
// export function nahoda_seznam ( Seznam ) ; begin
21673: LD_INT 0
21675: PPUSH
// if Seznam then
21676: LD_VAR 0 1
21680: IFFALSE 21708
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21682: LD_ADDR_VAR 0 2
21686: PUSH
21687: LD_VAR 0 1
21691: PUSH
21692: LD_INT 1
21694: PPUSH
21695: LD_VAR 0 1
21699: PPUSH
21700: CALL_OW 12
21704: ARRAY
21705: ST_TO_ADDR
21706: GO 21716
// Result = 0 ;
21708: LD_ADDR_VAR 0 2
21712: PUSH
21713: LD_INT 0
21715: ST_TO_ADDR
// end ;
21716: LD_VAR 0 2
21720: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21721: LD_INT 0
21723: PPUSH
21724: PPUSH
21725: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21726: LD_ADDR_VAR 0 4
21730: PUSH
21731: LD_INT 22
21733: PUSH
21734: LD_VAR 0 2
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PUSH
21743: EMPTY
21744: LIST
21745: PPUSH
21746: CALL_OW 69
21750: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21751: LD_ADDR_VAR 0 5
21755: PUSH
21756: LD_VAR 0 4
21760: PUSH
21761: FOR_IN
21762: IFFALSE 21794
// if See ( Kdo , Jednotka ) then
21764: LD_VAR 0 1
21768: PPUSH
21769: LD_VAR 0 5
21773: PPUSH
21774: CALL_OW 292
21778: IFFALSE 21792
// begin Result = true ;
21780: LD_ADDR_VAR 0 3
21784: PUSH
21785: LD_INT 1
21787: ST_TO_ADDR
// exit ;
21788: POP
21789: POP
21790: GO 21804
// end ;
21792: GO 21761
21794: POP
21795: POP
// Result = false ;
21796: LD_ADDR_VAR 0 3
21800: PUSH
21801: LD_INT 0
21803: ST_TO_ADDR
// end ;
21804: LD_VAR 0 3
21808: RET
// export function obsahuje_dulezitou_budovu ( List ) ; var Dulezite , I ; begin
21809: LD_INT 0
21811: PPUSH
21812: PPUSH
21813: PPUSH
// Dulezite = [ B_DEPOT , B_WAREHOUSE ] ;
21814: LD_ADDR_VAR 0 3
21818: PUSH
21819: LD_INT 0
21821: PUSH
21822: LD_INT 1
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: ST_TO_ADDR
// Result = true ;
21829: LD_ADDR_VAR 0 2
21833: PUSH
21834: LD_INT 1
21836: ST_TO_ADDR
// for I in Dulezite do
21837: LD_ADDR_VAR 0 4
21841: PUSH
21842: LD_VAR 0 3
21846: PUSH
21847: FOR_IN
21848: IFFALSE 21893
// if UnitFilter ( List , [ [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , I ] ] ) then
21850: LD_VAR 0 1
21854: PPUSH
21855: LD_INT 21
21857: PUSH
21858: LD_INT 3
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: PUSH
21865: LD_INT 30
21867: PUSH
21868: LD_VAR 0 4
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 72
21885: IFFALSE 21891
// exit ;
21887: POP
21888: POP
21889: GO 21903
21891: GO 21847
21893: POP
21894: POP
// Result = false ;
21895: LD_ADDR_VAR 0 2
21899: PUSH
21900: LD_INT 0
21902: ST_TO_ADDR
// end ;
21903: LD_VAR 0 2
21907: RET
// export function opravuj_auta ( List , Event , Area , Side , Ignore ) ; var Auta , Opravit , I , Kde , Mech ; begin
21908: LD_INT 0
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
// Result = [ ] ;
21916: LD_ADDR_VAR 0 6
21920: PUSH
21921: EMPTY
21922: ST_TO_ADDR
// Mech = 0 ;
21923: LD_ADDR_VAR 0 11
21927: PUSH
21928: LD_INT 0
21930: ST_TO_ADDR
// for I in List do
21931: LD_ADDR_VAR 0 9
21935: PUSH
21936: LD_VAR 0 1
21940: PUSH
21941: FOR_IN
21942: IFFALSE 21969
// if IsOk ( I ) then
21944: LD_VAR 0 9
21948: PPUSH
21949: CALL_OW 302
21953: IFFALSE 21967
// begin Mech = I ;
21955: LD_ADDR_VAR 0 11
21959: PUSH
21960: LD_VAR 0 9
21964: ST_TO_ADDR
// break ;
21965: GO 21969
// end ;
21967: GO 21941
21969: POP
21970: POP
// if not Mech then
21971: LD_VAR 0 11
21975: NOT
21976: IFFALSE 21980
// exit ;
21978: GO 22205
// Auta = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , Side ] ] ) diff Ignore ;
21980: LD_ADDR_VAR 0 7
21984: PUSH
21985: LD_VAR 0 3
21989: PPUSH
21990: LD_INT 21
21992: PUSH
21993: LD_INT 2
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: PUSH
22000: LD_INT 22
22002: PUSH
22003: LD_VAR 0 4
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PPUSH
22016: CALL_OW 70
22020: PUSH
22021: LD_VAR 0 5
22025: DIFF
22026: ST_TO_ADDR
// Opravit = [ ] ;
22027: LD_ADDR_VAR 0 8
22031: PUSH
22032: EMPTY
22033: ST_TO_ADDR
// for I in Auta do
22034: LD_ADDR_VAR 0 9
22038: PUSH
22039: LD_VAR 0 7
22043: PUSH
22044: FOR_IN
22045: IFFALSE 22083
// if GetLives ( I ) < HRANICE_ZDRAVI then
22047: LD_VAR 0 9
22051: PPUSH
22052: CALL_OW 256
22056: PUSH
22057: LD_INT 1000
22059: LESS
22060: IFFALSE 22081
// Opravit = Opravit union [ I ] ;
22062: LD_ADDR_VAR 0 8
22066: PUSH
22067: LD_VAR 0 8
22071: PUSH
22072: LD_VAR 0 9
22076: PUSH
22077: EMPTY
22078: LIST
22079: UNION
22080: ST_TO_ADDR
22081: GO 22044
22083: POP
22084: POP
// if Opravit then
22085: LD_VAR 0 8
22089: IFFALSE 22205
// begin Kde = IsInUnit ( Mech ) ;
22091: LD_ADDR_VAR 0 10
22095: PUSH
22096: LD_VAR 0 11
22100: PPUSH
22101: CALL_OW 310
22105: ST_TO_ADDR
// if Kde then
22106: LD_VAR 0 10
22110: IFFALSE 22147
// if GetType ( Kde ) = UNIT_BUILDING then
22112: LD_VAR 0 10
22116: PPUSH
22117: CALL_OW 247
22121: PUSH
22122: LD_INT 3
22124: EQUAL
22125: IFFALSE 22138
// ComExitBuilding ( Mech ) else
22127: LD_VAR 0 11
22131: PPUSH
22132: CALL_OW 122
22136: GO 22147
// ComExitVehicle ( Mech ) ;
22138: LD_VAR 0 11
22142: PPUSH
22143: CALL_OW 121
// for I in Opravit do
22147: LD_ADDR_VAR 0 9
22151: PUSH
22152: LD_VAR 0 8
22156: PUSH
22157: FOR_IN
22158: IFFALSE 22176
// AddComRepairVehicle ( Mech , I ) ;
22160: LD_VAR 0 11
22164: PPUSH
22165: LD_VAR 0 9
22169: PPUSH
22170: CALL_OW 189
22174: GO 22157
22176: POP
22177: POP
// AddComSailEvent ( Mech , Event ) ;
22178: LD_VAR 0 11
22182: PPUSH
22183: LD_VAR 0 2
22187: PPUSH
22188: CALL_OW 224
// Result = [ Mech ] ;
22192: LD_ADDR_VAR 0 6
22196: PUSH
22197: LD_VAR 0 11
22201: PUSH
22202: EMPTY
22203: LIST
22204: ST_TO_ADDR
// end ; end ;
22205: LD_VAR 0 6
22209: RET
// export function kuryruj_lidi ( List , Event , Area , Side ) ; var Lidi , Opravit , I , Kde , Felcar , Budova ; begin
22210: LD_INT 0
22212: PPUSH
22213: PPUSH
22214: PPUSH
22215: PPUSH
22216: PPUSH
22217: PPUSH
22218: PPUSH
// Result = [ ] ;
22219: LD_ADDR_VAR 0 5
22223: PUSH
22224: EMPTY
22225: ST_TO_ADDR
// Felcar = 0 ;
22226: LD_ADDR_VAR 0 10
22230: PUSH
22231: LD_INT 0
22233: ST_TO_ADDR
// for I in List do
22234: LD_ADDR_VAR 0 8
22238: PUSH
22239: LD_VAR 0 1
22243: PUSH
22244: FOR_IN
22245: IFFALSE 22272
// if IsOk ( I ) then
22247: LD_VAR 0 8
22251: PPUSH
22252: CALL_OW 302
22256: IFFALSE 22270
// begin Felcar = I ;
22258: LD_ADDR_VAR 0 10
22262: PUSH
22263: LD_VAR 0 8
22267: ST_TO_ADDR
// break ;
22268: GO 22272
// end ;
22270: GO 22244
22272: POP
22273: POP
// Lidi = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , Side ] ] ) ;
22274: LD_ADDR_VAR 0 6
22278: PUSH
22279: LD_VAR 0 3
22283: PPUSH
22284: LD_INT 21
22286: PUSH
22287: LD_INT 1
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 22
22296: PUSH
22297: LD_VAR 0 4
22301: PUSH
22302: EMPTY
22303: LIST
22304: LIST
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PPUSH
22310: CALL_OW 70
22314: ST_TO_ADDR
// Opravit = [ ] ;
22315: LD_ADDR_VAR 0 7
22319: PUSH
22320: EMPTY
22321: ST_TO_ADDR
// for I in Lidi do
22322: LD_ADDR_VAR 0 8
22326: PUSH
22327: LD_VAR 0 6
22331: PUSH
22332: FOR_IN
22333: IFFALSE 22371
// if GetLives ( I ) < HRANICE_ZDRAVI then
22335: LD_VAR 0 8
22339: PPUSH
22340: CALL_OW 256
22344: PUSH
22345: LD_INT 1000
22347: LESS
22348: IFFALSE 22369
// Opravit = Opravit union [ I ] ;
22350: LD_ADDR_VAR 0 7
22354: PUSH
22355: LD_VAR 0 7
22359: PUSH
22360: LD_VAR 0 8
22364: PUSH
22365: EMPTY
22366: LIST
22367: UNION
22368: ST_TO_ADDR
22369: GO 22332
22371: POP
22372: POP
// if Opravit then
22373: LD_VAR 0 7
22377: IFFALSE 22493
// begin Kde = IsInUnit ( Felcar ) ;
22379: LD_ADDR_VAR 0 9
22383: PUSH
22384: LD_VAR 0 10
22388: PPUSH
22389: CALL_OW 310
22393: ST_TO_ADDR
// if Kde then
22394: LD_VAR 0 9
22398: IFFALSE 22435
// if GetType ( Kde ) = UNIT_BUILDING then
22400: LD_VAR 0 9
22404: PPUSH
22405: CALL_OW 247
22409: PUSH
22410: LD_INT 3
22412: EQUAL
22413: IFFALSE 22426
// ComExitBuilding ( Felcar ) else
22415: LD_VAR 0 10
22419: PPUSH
22420: CALL_OW 122
22424: GO 22435
// ComExitVehicle ( Felcar ) ;
22426: LD_VAR 0 10
22430: PPUSH
22431: CALL_OW 121
// for I in Opravit do
22435: LD_ADDR_VAR 0 8
22439: PUSH
22440: LD_VAR 0 7
22444: PUSH
22445: FOR_IN
22446: IFFALSE 22464
// AddComHeal ( Felcar , I ) ;
22448: LD_VAR 0 10
22452: PPUSH
22453: LD_VAR 0 8
22457: PPUSH
22458: CALL_OW 188
22462: GO 22445
22464: POP
22465: POP
// AddComSailEvent ( Felcar , Event ) ;
22466: LD_VAR 0 10
22470: PPUSH
22471: LD_VAR 0 2
22475: PPUSH
22476: CALL_OW 224
// Result = [ Felcar ] ;
22480: LD_ADDR_VAR 0 5
22484: PUSH
22485: LD_VAR 0 10
22489: PUSH
22490: EMPTY
22491: LIST
22492: ST_TO_ADDR
// end ; end ;
22493: LD_VAR 0 5
22497: RET
// export function bez_opic ( List ) ; var Opice ; begin
22498: LD_INT 0
22500: PPUSH
22501: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
22502: LD_ADDR_VAR 0 3
22506: PUSH
22507: LD_VAR 0 1
22511: PPUSH
22512: LD_INT 2
22514: PUSH
22515: LD_INT 25
22517: PUSH
22518: LD_INT 12
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: PUSH
22525: LD_INT 25
22527: PUSH
22528: LD_INT 15
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: PUSH
22535: LD_INT 25
22537: PUSH
22538: LD_INT 16
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: PUSH
22545: LD_INT 25
22547: PUSH
22548: LD_INT 17
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: PUSH
22562: EMPTY
22563: LIST
22564: PPUSH
22565: CALL_OW 72
22569: ST_TO_ADDR
// Result = List diff Opice ;
22570: LD_ADDR_VAR 0 2
22574: PUSH
22575: LD_VAR 0 1
22579: PUSH
22580: LD_VAR 0 3
22584: DIFF
22585: ST_TO_ADDR
// end ; end_of_file
22586: LD_VAR 0 2
22590: RET
// every 0 0$2 + 0 0$0.1 do
22591: GO 22593
22593: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
22594: LD_INT 22
22596: PUSH
22597: LD_INT 3
22599: PUSH
22600: EMPTY
22601: LIST
22602: LIST
22603: PUSH
22604: LD_INT 2
22606: PUSH
22607: LD_INT 25
22609: PUSH
22610: LD_INT 12
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: PUSH
22617: LD_INT 25
22619: PUSH
22620: LD_INT 16
22622: PUSH
22623: EMPTY
22624: LIST
22625: LIST
22626: PUSH
22627: LD_INT 25
22629: PUSH
22630: LD_INT 15
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: PUSH
22637: LD_INT 25
22639: PUSH
22640: LD_INT 17
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: LIST
22651: LIST
22652: LIST
22653: PUSH
22654: EMPTY
22655: LIST
22656: LIST
22657: PPUSH
22658: CALL_OW 69
22662: PUSH
22663: LD_INT 22
22665: PUSH
22666: LD_INT 3
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: PUSH
22673: LD_INT 21
22675: PUSH
22676: LD_INT 1
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: PUSH
22683: LD_INT 3
22685: PUSH
22686: LD_INT 2
22688: PUSH
22689: LD_INT 25
22691: PUSH
22692: LD_INT 12
22694: PUSH
22695: EMPTY
22696: LIST
22697: LIST
22698: PUSH
22699: LD_INT 25
22701: PUSH
22702: LD_INT 16
22704: PUSH
22705: EMPTY
22706: LIST
22707: LIST
22708: PUSH
22709: LD_INT 25
22711: PUSH
22712: LD_INT 15
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PUSH
22719: LD_INT 25
22721: PUSH
22722: LD_INT 17
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: EMPTY
22730: LIST
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: PUSH
22740: EMPTY
22741: LIST
22742: LIST
22743: LIST
22744: PPUSH
22745: CALL_OW 69
22749: GREATER
22750: IFFALSE 22761
// begin SetAchievement ( ACH_POTA ) ;
22752: LD_STRING ACH_POTA
22754: PPUSH
22755: CALL_OW 543
// exit ;
22759: GO 22762
// end ; enable ;
22761: ENABLE
// end ;
22762: END
// export function SA_OnLegionHired ; begin
22763: LD_INT 0
22765: PPUSH
// SetAchievement ( ACH_EMP ) ;
22766: LD_STRING ACH_EMP
22768: PPUSH
22769: CALL_OW 543
// end ; end_of_file
22773: LD_VAR 0 1
22777: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
22778: LD_INT 0
22780: PPUSH
22781: PPUSH
// if not missionNumber then
22782: LD_VAR 0 2
22786: NOT
22787: IFFALSE 22791
// exit ;
22789: GO 22921
// achiv := false ;
22791: LD_ADDR_VAR 0 7
22795: PUSH
22796: LD_INT 0
22798: ST_TO_ADDR
// case campaignNumber of 1 :
22799: LD_VAR 0 1
22803: PUSH
22804: LD_INT 1
22806: DOUBLE
22807: EQUAL
22808: IFTRUE 22812
22810: GO 22823
22812: POP
// achiv := ACH_GOTA ; 2 :
22813: LD_ADDR_VAR 0 7
22817: PUSH
22818: LD_STRING ACH_GOTA
22820: ST_TO_ADDR
22821: GO 22873
22823: LD_INT 2
22825: DOUBLE
22826: EQUAL
22827: IFTRUE 22831
22829: GO 22834
22831: POP
// ; 3 :
22832: GO 22873
22834: LD_INT 3
22836: DOUBLE
22837: EQUAL
22838: IFTRUE 22842
22840: GO 22853
22842: POP
// achiv := ACH_MOTSU ; 4 :
22843: LD_ADDR_VAR 0 7
22847: PUSH
22848: LD_STRING ACH_MOTSU
22850: ST_TO_ADDR
22851: GO 22873
22853: LD_INT 4
22855: DOUBLE
22856: EQUAL
22857: IFTRUE 22861
22859: GO 22872
22861: POP
// achiv := ACH_LOP ; end ;
22862: LD_ADDR_VAR 0 7
22866: PUSH
22867: LD_STRING ACH_LOP
22869: ST_TO_ADDR
22870: GO 22873
22872: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
22873: LD_OWVAR 67
22877: PUSH
22878: LD_INT 3
22880: EQUAL
22881: PUSH
22882: LD_VAR 0 7
22886: AND
22887: PUSH
22888: LD_VAR 0 3
22892: AND
22893: PUSH
22894: LD_VAR 0 4
22898: AND
22899: PUSH
22900: LD_VAR 0 5
22904: AND
22905: IFFALSE 22921
// SetAchievementEX ( achiv , missionNumber ) ;
22907: LD_VAR 0 7
22911: PPUSH
22912: LD_VAR 0 2
22916: PPUSH
22917: CALL_OW 564
// end ;
22921: LD_VAR 0 6
22925: RET
// export function SA_BehemothConstructed ; begin
22926: LD_INT 0
22928: PPUSH
// SetAchievement ( ACH_SMC ) ;
22929: LD_STRING ACH_SMC
22931: PPUSH
22932: CALL_OW 543
// end ;
22936: LD_VAR 0 1
22940: RET

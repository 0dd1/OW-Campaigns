// export side_Neutral , side_Ru , side_Ru2 , side_Ar , side_Xavier , side_Heike , side_Strazci ; export VsevSaved , HeikeCaptured ; export Burlak , Vsevolod , Popov , Yelena , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin ; export Rusaci , WithVsevolod ; export Konvoj ; export Xavier , Heike , Heikeovci ; export ContactIn5Min , PropaslQuickly ; export Minuty ; var FalesnaYelena ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// end ;
  74: LD_VAR 0 2
  78: RET
// function load_set ( Ident ) ; begin
  79: LD_INT 0
  81: PPUSH
// if TestCharacters ( Ident ) then
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL_OW 28
  91: IFFALSE 110
// Result = CreateCharacterSet ( Ident ) else
  93: LD_ADDR_VAR 0 2
  97: PUSH
  98: LD_VAR 0 1
 102: PPUSH
 103: CALL_OW 31
 107: ST_TO_ADDR
 108: GO 117
// Result = [ ] ;
 110: LD_ADDR_VAR 0 2
 114: PUSH
 115: EMPTY
 116: ST_TO_ADDR
// end ;
 117: LD_VAR 0 2
 121: RET
// function save_char ( Handle , Ident ) ; begin
 122: LD_INT 0
 124: PPUSH
// if Handle then
 125: LD_VAR 0 1
 129: IFFALSE 148
// SaveCharacters ( [ Handle ] , Ident ) ;
 131: LD_VAR 0 1
 135: PUSH
 136: EMPTY
 137: LIST
 138: PPUSH
 139: LD_VAR 0 2
 143: PPUSH
 144: CALL_OW 38
// end ;
 148: LD_VAR 0 3
 152: RET
// function vytvor_yelenu ; begin
 153: LD_INT 0
 155: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 156: LD_ADDR_OWVAR 21
 160: PUSH
 161: LD_INT 3
 163: ST_TO_ADDR
// UC_Side = side_Ru2 ;
 164: LD_ADDR_OWVAR 20
 168: PUSH
 169: LD_EXP 3
 173: ST_TO_ADDR
// HC_name = Yelena Trajkov ;
 174: LD_ADDR_OWVAR 26
 178: PUSH
 179: LD_STRING Yelena Trajkov
 181: ST_TO_ADDR
// HC_sex = SEX_FEMALE ;
 182: LD_ADDR_OWVAR 27
 186: PUSH
 187: LD_INT 2
 189: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 190: LD_ADDR_OWVAR 28
 194: PUSH
 195: LD_INT 1
 197: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
 198: LD_INT 5
 200: PPUSH
 201: CALL_OW 375
// Result = CreateHuman ;
 205: LD_ADDR_VAR 0 1
 209: PUSH
 210: CALL_OW 44
 214: ST_TO_ADDR
// end ;
 215: LD_VAR 0 1
 219: RET
// function load_konvoj ; var Convoy_06 , Spec , Tmp ; var MaxCnt , MaxCans , MaxOil , MaxSib , Cans , Oil , Sib ; var TedCans , TedOil , TedSib ; begin
 220: LD_INT 0
 222: PPUSH
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
 235: PPUSH
// Convoy_06 = LoadVariable ( Convoy_06 , [ ] ) ;
 236: LD_ADDR_VAR 0 2
 240: PUSH
 241: LD_STRING Convoy_06
 243: PPUSH
 244: EMPTY
 245: PPUSH
 246: CALL_OW 30
 250: ST_TO_ADDR
// DeleteVariable ( Convoy_06 ) ;
 251: LD_STRING Convoy_06
 253: PPUSH
 254: CALL_OW 41
// if not Convoy_06 then
 258: LD_VAR 0 2
 262: NOT
 263: IFFALSE 377
// Convoy_06 = [ [ NATION_RUSSIAN , RU_HEAVY_MACHINE_GUN , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 0 , 0 , 0 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 30 , 50 , 20 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 40 , 50 , 10 ] ] ;
 265: LD_ADDR_VAR 0 2
 269: PUSH
 270: LD_INT 3
 272: PUSH
 273: LD_INT 42
 275: PUSH
 276: LD_INT 1
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 21
 284: PUSH
 285: LD_INT 0
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: EMPTY
 295: LIST
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_INT 3
 306: PUSH
 307: LD_INT 51
 309: PUSH
 310: LD_INT 1
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 30
 321: PUSH
 322: LD_INT 50
 324: PUSH
 325: LD_INT 20
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: LIST
 336: LIST
 337: PUSH
 338: LD_INT 3
 340: PUSH
 341: LD_INT 51
 343: PUSH
 344: LD_INT 1
 346: PUSH
 347: LD_INT 1
 349: PUSH
 350: LD_INT 21
 352: PUSH
 353: LD_INT 40
 355: PUSH
 356: LD_INT 50
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: LIST
 376: ST_TO_ADDR
// UC_Side = side_Ru ;
 377: LD_ADDR_OWVAR 20
 381: PUSH
 382: LD_EXP 2
 386: ST_TO_ADDR
// Konvoj = [ ] ;
 387: LD_ADDR_EXP 24
 391: PUSH
 392: EMPTY
 393: ST_TO_ADDR
// Tmp = dif_MaxKonvojCargo [ Difficulty ] ;
 394: LD_ADDR_VAR 0 4
 398: PUSH
 399: LD_EXP 53
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// MaxCnt = Tmp [ 1 ] ;
 410: LD_ADDR_VAR 0 5
 414: PUSH
 415: LD_VAR 0 4
 419: PUSH
 420: LD_INT 1
 422: ARRAY
 423: ST_TO_ADDR
// MaxCans = Tmp [ 2 ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 4
 433: PUSH
 434: LD_INT 2
 436: ARRAY
 437: ST_TO_ADDR
// MaxOil = Tmp [ 3 ] ;
 438: LD_ADDR_VAR 0 7
 442: PUSH
 443: LD_VAR 0 4
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: ST_TO_ADDR
// MaxSib = Tmp [ 4 ] ;
 452: LD_ADDR_VAR 0 8
 456: PUSH
 457: LD_VAR 0 4
 461: PUSH
 462: LD_INT 4
 464: ARRAY
 465: ST_TO_ADDR
// for Spec in Convoy_06 do
 466: LD_ADDR_VAR 0 3
 470: PUSH
 471: LD_VAR 0 2
 475: PUSH
 476: FOR_IN
 477: IFFALSE 657
// begin UC_Nation = Spec [ 1 ] ;
 479: LD_ADDR_OWVAR 21
 483: PUSH
 484: LD_VAR 0 3
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: ST_TO_ADDR
// VC_Weapon = Spec [ 2 ] ;
 493: LD_ADDR_OWVAR 40
 497: PUSH
 498: LD_VAR 0 3
 502: PUSH
 503: LD_INT 2
 505: ARRAY
 506: ST_TO_ADDR
// VC_Control = Spec [ 3 ] ;
 507: LD_ADDR_OWVAR 38
 511: PUSH
 512: LD_VAR 0 3
 516: PUSH
 517: LD_INT 3
 519: ARRAY
 520: ST_TO_ADDR
// VC_Engine = Spec [ 4 ] ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: LD_VAR 0 3
 530: PUSH
 531: LD_INT 4
 533: ARRAY
 534: ST_TO_ADDR
// VC_Chassis = Spec [ 5 ] ;
 535: LD_ADDR_OWVAR 37
 539: PUSH
 540: LD_VAR 0 3
 544: PUSH
 545: LD_INT 5
 547: ARRAY
 548: ST_TO_ADDR
// Tmp = CreateVehicle ;
 549: LD_ADDR_VAR 0 4
 553: PUSH
 554: CALL_OW 45
 558: ST_TO_ADDR
// AddCargo ( Tmp , MAT_CANS , Spec [ 6 ] ) ;
 559: LD_VAR 0 4
 563: PPUSH
 564: LD_INT 1
 566: PPUSH
 567: LD_VAR 0 3
 571: PUSH
 572: LD_INT 6
 574: ARRAY
 575: PPUSH
 576: CALL_OW 291
// AddCargo ( Tmp , MAT_OIL , Spec [ 7 ] ) ;
 580: LD_VAR 0 4
 584: PPUSH
 585: LD_INT 2
 587: PPUSH
 588: LD_VAR 0 3
 592: PUSH
 593: LD_INT 7
 595: ARRAY
 596: PPUSH
 597: CALL_OW 291
// AddCargo ( Tmp , MAT_SIBERIT , Spec [ 8 ] ) ;
 601: LD_VAR 0 4
 605: PPUSH
 606: LD_INT 3
 608: PPUSH
 609: LD_VAR 0 3
 613: PUSH
 614: LD_INT 8
 616: ARRAY
 617: PPUSH
 618: CALL_OW 291
// Konvoj = Konvoj union [ Tmp ] ;
 622: LD_ADDR_EXP 24
 626: PUSH
 627: LD_EXP 24
 631: PUSH
 632: LD_VAR 0 4
 636: PUSH
 637: EMPTY
 638: LIST
 639: UNION
 640: ST_TO_ADDR
// if Konvoj >= MaxCnt then
 641: LD_EXP 24
 645: PUSH
 646: LD_VAR 0 5
 650: GREATEREQUAL
 651: IFFALSE 655
// break ;
 653: GO 657
// end ;
 655: GO 476
 657: POP
 658: POP
// Cans = 0 ;
 659: LD_ADDR_VAR 0 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// Oil = 0 ;
 667: LD_ADDR_VAR 0 10
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// Sib = 0 ;
 675: LD_ADDR_VAR 0 11
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for Spec in Konvoj do
 683: LD_ADDR_VAR 0 3
 687: PUSH
 688: LD_EXP 24
 692: PUSH
 693: FOR_IN
 694: IFFALSE 998
// begin TedCans = GetCargo ( Spec , MAT_CANS ) ;
 696: LD_ADDR_VAR 0 12
 700: PUSH
 701: LD_VAR 0 3
 705: PPUSH
 706: LD_INT 1
 708: PPUSH
 709: CALL_OW 289
 713: ST_TO_ADDR
// TedOil = GetCargo ( Spec , MAT_OIL ) ;
 714: LD_ADDR_VAR 0 13
 718: PUSH
 719: LD_VAR 0 3
 723: PPUSH
 724: LD_INT 2
 726: PPUSH
 727: CALL_OW 289
 731: ST_TO_ADDR
// TedSib = GetCargo ( Spec , MAT_SIBERIT ) ;
 732: LD_ADDR_VAR 0 14
 736: PUSH
 737: LD_VAR 0 3
 741: PPUSH
 742: LD_INT 3
 744: PPUSH
 745: CALL_OW 289
 749: ST_TO_ADDR
// if Cans + TedCans > MaxCans then
 750: LD_VAR 0 9
 754: PUSH
 755: LD_VAR 0 12
 759: PLUS
 760: PUSH
 761: LD_VAR 0 6
 765: GREATER
 766: IFFALSE 784
// TedCans = MaxCans - Cans ;
 768: LD_ADDR_VAR 0 12
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_VAR 0 9
 782: MINUS
 783: ST_TO_ADDR
// if Oil + TedOil > MaxOil then
 784: LD_VAR 0 10
 788: PUSH
 789: LD_VAR 0 13
 793: PLUS
 794: PUSH
 795: LD_VAR 0 7
 799: GREATER
 800: IFFALSE 818
// TedOil = MaxOil - Oil ;
 802: LD_ADDR_VAR 0 13
 806: PUSH
 807: LD_VAR 0 7
 811: PUSH
 812: LD_VAR 0 10
 816: MINUS
 817: ST_TO_ADDR
// if Sib + TedSib > MaxSib then
 818: LD_VAR 0 11
 822: PUSH
 823: LD_VAR 0 14
 827: PLUS
 828: PUSH
 829: LD_VAR 0 8
 833: GREATER
 834: IFFALSE 852
// TedSib = MaxSib - Sib ;
 836: LD_ADDR_VAR 0 14
 840: PUSH
 841: LD_VAR 0 8
 845: PUSH
 846: LD_VAR 0 11
 850: MINUS
 851: ST_TO_ADDR
// SetCargo ( Spec , MAT_CANS , 0 ) ;
 852: LD_VAR 0 3
 856: PPUSH
 857: LD_INT 1
 859: PPUSH
 860: LD_INT 0
 862: PPUSH
 863: CALL_OW 290
// SetCargo ( Spec , MAT_OIL , 0 ) ;
 867: LD_VAR 0 3
 871: PPUSH
 872: LD_INT 2
 874: PPUSH
 875: LD_INT 0
 877: PPUSH
 878: CALL_OW 290
// SetCargo ( Spec , MAT_SIBERIT , 0 ) ;
 882: LD_VAR 0 3
 886: PPUSH
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 290
// AddCargo ( Spec , MAT_CANS , TedCans ) ;
 897: LD_VAR 0 3
 901: PPUSH
 902: LD_INT 1
 904: PPUSH
 905: LD_VAR 0 12
 909: PPUSH
 910: CALL_OW 291
// AddCargo ( Spec , MAT_SIBERIT , TedSib ) ;
 914: LD_VAR 0 3
 918: PPUSH
 919: LD_INT 3
 921: PPUSH
 922: LD_VAR 0 14
 926: PPUSH
 927: CALL_OW 291
// AddCargo ( Spec , MAT_OIL , TedOil ) ;
 931: LD_VAR 0 3
 935: PPUSH
 936: LD_INT 2
 938: PPUSH
 939: LD_VAR 0 13
 943: PPUSH
 944: CALL_OW 291
// Cans = Cans + TedCans ;
 948: LD_ADDR_VAR 0 9
 952: PUSH
 953: LD_VAR 0 9
 957: PUSH
 958: LD_VAR 0 12
 962: PLUS
 963: ST_TO_ADDR
// Oil = Oil + TedOil ;
 964: LD_ADDR_VAR 0 10
 968: PUSH
 969: LD_VAR 0 10
 973: PUSH
 974: LD_VAR 0 13
 978: PLUS
 979: ST_TO_ADDR
// Sib = Sib + TedSib ;
 980: LD_ADDR_VAR 0 11
 984: PUSH
 985: LD_VAR 0 11
 989: PUSH
 990: LD_VAR 0 14
 994: PLUS
 995: ST_TO_ADDR
// end ;
 996: GO 693
 998: POP
 999: POP
// end ;
1000: LD_VAR 0 1
1004: RET
// function load ; begin
1005: LD_INT 0
1007: PPUSH
// UC_Nation = NATION_RUSSIAN ;
1008: LD_ADDR_OWVAR 21
1012: PUSH
1013: LD_INT 3
1015: ST_TO_ADDR
// UC_Side = side_Ru ;
1016: LD_ADDR_OWVAR 20
1020: PUSH
1021: LD_EXP 2
1025: ST_TO_ADDR
// VsevSaved = LoadVariable ( VsevSaved , false ) ;
1026: LD_ADDR_EXP 8
1030: PUSH
1031: LD_STRING VsevSaved
1033: PPUSH
1034: LD_INT 0
1036: PPUSH
1037: CALL_OW 30
1041: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
1042: LD_ADDR_EXP 10
1046: PUSH
1047: LD_STRING Burlak
1049: PPUSH
1050: CALL 0 0 1
1054: ST_TO_ADDR
// Vsevolod = load_char ( Vsevolod ) ;
1055: LD_ADDR_EXP 11
1059: PUSH
1060: LD_STRING Vsevolod
1062: PPUSH
1063: CALL 0 0 1
1067: ST_TO_ADDR
// if IsDead ( Vsevolod ) then
1068: LD_EXP 11
1072: PPUSH
1073: CALL_OW 301
1077: IFFALSE 1087
// VsevSaved = false ;
1079: LD_ADDR_EXP 8
1083: PUSH
1084: LD_INT 0
1086: ST_TO_ADDR
// Yelena = load_char ( Kirilenkova ) ;
1087: LD_ADDR_EXP 13
1091: PUSH
1092: LD_STRING Kirilenkova
1094: PPUSH
1095: CALL 0 0 1
1099: ST_TO_ADDR
// if not Yelena or IsDead ( Yelena ) then
1100: LD_EXP 13
1104: NOT
1105: PUSH
1106: LD_EXP 13
1110: PPUSH
1111: CALL_OW 301
1115: OR
1116: IFFALSE 1138
// begin Yelena = vytvor_yelenu ;
1118: LD_ADDR_EXP 13
1122: PUSH
1123: CALL 153 0 0
1127: ST_TO_ADDR
// FalesnaYelena = true ;
1128: LD_ADDR_LOC 1
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// end else
1136: GO 1146
// FalesnaYelena = false ;
1138: LD_ADDR_LOC 1
1142: PUSH
1143: LD_INT 0
1145: ST_TO_ADDR
// if VsevSaved then
1146: LD_EXP 8
1150: IFFALSE 1158
// load_vs else
1152: CALL 1382 0 0
1156: GO 1162
// load_nv ;
1158: CALL 1167 0 0
// end ;
1162: LD_VAR 0 1
1166: RET
// function load_nv ; var Ostatni ; begin
1167: LD_INT 0
1169: PPUSH
1170: PPUSH
// Karamazov = load_char ( Karamazov ) ;
1171: LD_ADDR_EXP 16
1175: PUSH
1176: LD_STRING Karamazov
1178: PPUSH
1179: CALL 0 0 1
1183: ST_TO_ADDR
// Petrovova = load_char ( Petrovova ) ;
1184: LD_ADDR_EXP 17
1188: PUSH
1189: LD_STRING Petrovova
1191: PPUSH
1192: CALL 0 0 1
1196: ST_TO_ADDR
// Gleb = load_char ( Gleb ) ;
1197: LD_ADDR_EXP 14
1201: PUSH
1202: LD_STRING Gleb
1204: PPUSH
1205: CALL 0 0 1
1209: ST_TO_ADDR
// Petrosyan = load_char ( Petrosyan ) ;
1210: LD_ADDR_EXP 15
1214: PUSH
1215: LD_STRING Petrosyan
1217: PPUSH
1218: CALL 0 0 1
1222: ST_TO_ADDR
// Lipshchin = load_char ( Lipshchin ) ;
1223: LD_ADDR_EXP 21
1227: PUSH
1228: LD_STRING Lipshchin
1230: PPUSH
1231: CALL 0 0 1
1235: ST_TO_ADDR
// Titov = load_char ( Titov ) ;
1236: LD_ADDR_EXP 19
1240: PUSH
1241: LD_STRING Titov
1243: PPUSH
1244: CALL 0 0 1
1248: ST_TO_ADDR
// Dolgov = load_char ( Dolgov ) ;
1249: LD_ADDR_EXP 18
1253: PUSH
1254: LD_STRING Dolgov
1256: PPUSH
1257: CALL 0 0 1
1261: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1262: LD_ADDR_EXP 12
1266: PUSH
1267: LD_STRING Popov
1269: PPUSH
1270: CALL_OW 25
1274: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1275: LD_ADDR_EXP 20
1279: PUSH
1280: LD_STRING Platonov
1282: PPUSH
1283: CALL_OW 25
1287: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1288: LD_ADDR_VAR 0 2
1292: PUSH
1293: LD_STRING Survivors2
1295: PPUSH
1296: CALL 79 0 1
1300: ST_TO_ADDR
// Rusaci = Ostatni union [ Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov ] diff [ 0 ] ;
1301: LD_ADDR_EXP 22
1305: PUSH
1306: LD_VAR 0 2
1310: PUSH
1311: LD_EXP 16
1315: PUSH
1316: LD_EXP 17
1320: PUSH
1321: LD_EXP 14
1325: PUSH
1326: LD_EXP 15
1330: PUSH
1331: LD_EXP 21
1335: PUSH
1336: LD_EXP 19
1340: PUSH
1341: LD_EXP 18
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: UNION
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: DIFF
1362: ST_TO_ADDR
// SetSide ( Rusaci , side_Ru ) ;
1363: LD_EXP 22
1367: PPUSH
1368: LD_EXP 2
1372: PPUSH
1373: CALL_OW 235
// end ;
1377: LD_VAR 0 1
1381: RET
// function load_vs ; var Ostatni ; var KaramazovLoc , PetrovovaLoc , GlebLoc , PetrosyanLoc ; var LipshchinLoc , TitovLoc , DolgovLoc ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
1391: PPUSH
1392: PPUSH
// KaramazovLoc = LoadVariable ( KaramazovLoc , 0 ) ;
1393: LD_ADDR_VAR 0 3
1397: PUSH
1398: LD_STRING KaramazovLoc
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 30
1408: ST_TO_ADDR
// PetrovovaLoc = LoadVariable ( PetrovovaLoc , 0 ) ;
1409: LD_ADDR_VAR 0 4
1413: PUSH
1414: LD_STRING PetrovovaLoc
1416: PPUSH
1417: LD_INT 0
1419: PPUSH
1420: CALL_OW 30
1424: ST_TO_ADDR
// GlebLoc = LoadVariable ( GlebLoc , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_STRING GlebLoc
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 30
1440: ST_TO_ADDR
// PetrosyanLoc = LoadVariable ( PetrosyanLoc , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_STRING PetrosyanLoc
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 30
1456: ST_TO_ADDR
// LipshchinLoc = LoadVariable ( LipshchinLoc , 0 ) ;
1457: LD_ADDR_VAR 0 7
1461: PUSH
1462: LD_STRING LipshchinLoc
1464: PPUSH
1465: LD_INT 0
1467: PPUSH
1468: CALL_OW 30
1472: ST_TO_ADDR
// TitovLoc = LoadVariable ( TitovLoc , 0 ) ;
1473: LD_ADDR_VAR 0 8
1477: PUSH
1478: LD_STRING TitovLoc
1480: PPUSH
1481: LD_INT 0
1483: PPUSH
1484: CALL_OW 30
1488: ST_TO_ADDR
// DolgovLoc = LoadVariable ( DolgovLoc , 0 ) ;
1489: LD_ADDR_VAR 0 9
1493: PUSH
1494: LD_STRING DolgovLoc
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 30
1504: ST_TO_ADDR
// if KaramazovLoc in [ 7 , - 7 ] then
1505: LD_VAR 0 3
1509: PUSH
1510: LD_INT 7
1512: PUSH
1513: LD_INT 7
1515: NEG
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: IN
1521: IFFALSE 1536
// Karamazov = load_char ( Karamazov ) ;
1523: LD_ADDR_EXP 16
1527: PUSH
1528: LD_STRING Karamazov
1530: PPUSH
1531: CALL 0 0 1
1535: ST_TO_ADDR
// if PetrovovaLoc in [ 7 , - 7 ] then
1536: LD_VAR 0 4
1540: PUSH
1541: LD_INT 7
1543: PUSH
1544: LD_INT 7
1546: NEG
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: IN
1552: IFFALSE 1567
// Petrovova = load_char ( Petrovova ) ;
1554: LD_ADDR_EXP 17
1558: PUSH
1559: LD_STRING Petrovova
1561: PPUSH
1562: CALL 0 0 1
1566: ST_TO_ADDR
// if GlebLoc in [ 7 , - 7 ] then
1567: LD_VAR 0 5
1571: PUSH
1572: LD_INT 7
1574: PUSH
1575: LD_INT 7
1577: NEG
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: IN
1583: IFFALSE 1598
// Gleb = load_char ( Gleb ) ;
1585: LD_ADDR_EXP 14
1589: PUSH
1590: LD_STRING Gleb
1592: PPUSH
1593: CALL 0 0 1
1597: ST_TO_ADDR
// if PetrosyanLoc in [ 7 , - 7 ] then
1598: LD_VAR 0 6
1602: PUSH
1603: LD_INT 7
1605: PUSH
1606: LD_INT 7
1608: NEG
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: IN
1614: IFFALSE 1629
// Petrosyan = load_char ( Petrosyan ) ;
1616: LD_ADDR_EXP 15
1620: PUSH
1621: LD_STRING Petrosyan
1623: PPUSH
1624: CALL 0 0 1
1628: ST_TO_ADDR
// if LipshchinLoc in [ 7 , - 7 ] then
1629: LD_VAR 0 7
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_INT 7
1639: NEG
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: IN
1645: IFFALSE 1660
// Lipshchin = load_char ( Lipshchin ) ;
1647: LD_ADDR_EXP 21
1651: PUSH
1652: LD_STRING Lipshchin
1654: PPUSH
1655: CALL 0 0 1
1659: ST_TO_ADDR
// if TitovLoc in [ 7 , - 7 ] then
1660: LD_VAR 0 8
1664: PUSH
1665: LD_INT 7
1667: PUSH
1668: LD_INT 7
1670: NEG
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: IN
1676: IFFALSE 1691
// Titov = load_char ( Titov ) ;
1678: LD_ADDR_EXP 19
1682: PUSH
1683: LD_STRING Titov
1685: PPUSH
1686: CALL 0 0 1
1690: ST_TO_ADDR
// if DolgovLoc in [ 7 , - 7 ] then
1691: LD_VAR 0 9
1695: PUSH
1696: LD_INT 7
1698: PUSH
1699: LD_INT 7
1701: NEG
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: IN
1707: IFFALSE 1722
// Dolgov = load_char ( Dolgov ) ;
1709: LD_ADDR_EXP 18
1713: PUSH
1714: LD_STRING Dolgov
1716: PPUSH
1717: CALL 0 0 1
1721: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1722: LD_ADDR_VAR 0 2
1726: PUSH
1727: LD_STRING Survivors2
1729: PPUSH
1730: CALL 79 0 1
1734: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1735: LD_ADDR_EXP 12
1739: PUSH
1740: LD_STRING Popov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1748: LD_ADDR_EXP 20
1752: PUSH
1753: LD_STRING Platonov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// WithVsevolod = [ Yelena ] union load_set ( WithVsevolod ) ;
1761: LD_ADDR_EXP 23
1765: PUSH
1766: LD_EXP 13
1770: PUSH
1771: EMPTY
1772: LIST
1773: PUSH
1774: LD_STRING WithVsevolod
1776: PPUSH
1777: CALL 79 0 1
1781: UNION
1782: ST_TO_ADDR
// Rusaci = Ostatni ;
1783: LD_ADDR_EXP 22
1787: PUSH
1788: LD_VAR 0 2
1792: ST_TO_ADDR
// if KaramazovLoc = 7 then
1793: LD_VAR 0 3
1797: PUSH
1798: LD_INT 7
1800: EQUAL
1801: IFFALSE 1824
// Rusaci = Rusaci union [ Karamazov ] else
1803: LD_ADDR_EXP 22
1807: PUSH
1808: LD_EXP 22
1812: PUSH
1813: LD_EXP 16
1817: PUSH
1818: EMPTY
1819: LIST
1820: UNION
1821: ST_TO_ADDR
1822: GO 1854
// if KaramazovLoc = - 7 then
1824: LD_VAR 0 3
1828: PUSH
1829: LD_INT 7
1831: NEG
1832: EQUAL
1833: IFFALSE 1854
// WithVsevolod = WithVsevolod union [ Karamazov ] ;
1835: LD_ADDR_EXP 23
1839: PUSH
1840: LD_EXP 23
1844: PUSH
1845: LD_EXP 16
1849: PUSH
1850: EMPTY
1851: LIST
1852: UNION
1853: ST_TO_ADDR
// if PetrovovaLoc = 7 then
1854: LD_VAR 0 4
1858: PUSH
1859: LD_INT 7
1861: EQUAL
1862: IFFALSE 1885
// Rusaci = Rusaci union [ Petrovova ] else
1864: LD_ADDR_EXP 22
1868: PUSH
1869: LD_EXP 22
1873: PUSH
1874: LD_EXP 17
1878: PUSH
1879: EMPTY
1880: LIST
1881: UNION
1882: ST_TO_ADDR
1883: GO 1915
// if PetrovovaLoc = - 7 then
1885: LD_VAR 0 4
1889: PUSH
1890: LD_INT 7
1892: NEG
1893: EQUAL
1894: IFFALSE 1915
// WithVsevolod = WithVsevolod union [ Petrovova ] ;
1896: LD_ADDR_EXP 23
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_EXP 17
1910: PUSH
1911: EMPTY
1912: LIST
1913: UNION
1914: ST_TO_ADDR
// if GlebLoc = 7 then
1915: LD_VAR 0 5
1919: PUSH
1920: LD_INT 7
1922: EQUAL
1923: IFFALSE 1946
// Rusaci = Rusaci union [ Gleb ] else
1925: LD_ADDR_EXP 22
1929: PUSH
1930: LD_EXP 22
1934: PUSH
1935: LD_EXP 14
1939: PUSH
1940: EMPTY
1941: LIST
1942: UNION
1943: ST_TO_ADDR
1944: GO 1976
// if GlebLoc = - 7 then
1946: LD_VAR 0 5
1950: PUSH
1951: LD_INT 7
1953: NEG
1954: EQUAL
1955: IFFALSE 1976
// WithVsevolod = WithVsevolod union [ Gleb ] ;
1957: LD_ADDR_EXP 23
1961: PUSH
1962: LD_EXP 23
1966: PUSH
1967: LD_EXP 14
1971: PUSH
1972: EMPTY
1973: LIST
1974: UNION
1975: ST_TO_ADDR
// if PetrosyanLoc = 7 then
1976: LD_VAR 0 6
1980: PUSH
1981: LD_INT 7
1983: EQUAL
1984: IFFALSE 2007
// Rusaci = Rusaci union [ Petrosyan ] else
1986: LD_ADDR_EXP 22
1990: PUSH
1991: LD_EXP 22
1995: PUSH
1996: LD_EXP 15
2000: PUSH
2001: EMPTY
2002: LIST
2003: UNION
2004: ST_TO_ADDR
2005: GO 2037
// if PetrosyanLoc = - 7 then
2007: LD_VAR 0 6
2011: PUSH
2012: LD_INT 7
2014: NEG
2015: EQUAL
2016: IFFALSE 2037
// WithVsevolod = WithVsevolod union [ Petrosyan ] ;
2018: LD_ADDR_EXP 23
2022: PUSH
2023: LD_EXP 23
2027: PUSH
2028: LD_EXP 15
2032: PUSH
2033: EMPTY
2034: LIST
2035: UNION
2036: ST_TO_ADDR
// if LipshchinLoc = 7 then
2037: LD_VAR 0 7
2041: PUSH
2042: LD_INT 7
2044: EQUAL
2045: IFFALSE 2068
// Rusaci = Rusaci union [ Lipshchin ] else
2047: LD_ADDR_EXP 22
2051: PUSH
2052: LD_EXP 22
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: EMPTY
2063: LIST
2064: UNION
2065: ST_TO_ADDR
2066: GO 2098
// if LipshchinLoc = - 7 then
2068: LD_VAR 0 7
2072: PUSH
2073: LD_INT 7
2075: NEG
2076: EQUAL
2077: IFFALSE 2098
// WithVsevolod = WithVsevolod union [ Lipshchin ] ;
2079: LD_ADDR_EXP 23
2083: PUSH
2084: LD_EXP 23
2088: PUSH
2089: LD_EXP 21
2093: PUSH
2094: EMPTY
2095: LIST
2096: UNION
2097: ST_TO_ADDR
// if TitovLoc = 7 then
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 7
2105: EQUAL
2106: IFFALSE 2129
// Rusaci = Rusaci union [ Titov ] else
2108: LD_ADDR_EXP 22
2112: PUSH
2113: LD_EXP 22
2117: PUSH
2118: LD_EXP 19
2122: PUSH
2123: EMPTY
2124: LIST
2125: UNION
2126: ST_TO_ADDR
2127: GO 2159
// if TitovLoc = - 7 then
2129: LD_VAR 0 8
2133: PUSH
2134: LD_INT 7
2136: NEG
2137: EQUAL
2138: IFFALSE 2159
// WithVsevolod = WithVsevolod union [ Titov ] ;
2140: LD_ADDR_EXP 23
2144: PUSH
2145: LD_EXP 23
2149: PUSH
2150: LD_EXP 19
2154: PUSH
2155: EMPTY
2156: LIST
2157: UNION
2158: ST_TO_ADDR
// if DolgovLoc = 7 then
2159: LD_VAR 0 9
2163: PUSH
2164: LD_INT 7
2166: EQUAL
2167: IFFALSE 2190
// Rusaci = Rusaci union [ Dolgov ] else
2169: LD_ADDR_EXP 22
2173: PUSH
2174: LD_EXP 22
2178: PUSH
2179: LD_EXP 18
2183: PUSH
2184: EMPTY
2185: LIST
2186: UNION
2187: ST_TO_ADDR
2188: GO 2220
// if DolgovLoc = - 7 then
2190: LD_VAR 0 9
2194: PUSH
2195: LD_INT 7
2197: NEG
2198: EQUAL
2199: IFFALSE 2220
// WithVsevolod = WithVsevolod union [ Dolgov ] ;
2201: LD_ADDR_EXP 23
2205: PUSH
2206: LD_EXP 23
2210: PUSH
2211: LD_EXP 18
2215: PUSH
2216: EMPTY
2217: LIST
2218: UNION
2219: ST_TO_ADDR
// while ( Rusaci union WithVsevolod ) < 6 do
2220: LD_EXP 22
2224: PUSH
2225: LD_EXP 23
2229: UNION
2230: PUSH
2231: LD_INT 6
2233: LESS
2234: IFFALSE 2257
// WithVsevolod = WithVsevolod union [ vytvor_rusaka ] ;
2236: LD_ADDR_EXP 23
2240: PUSH
2241: LD_EXP 23
2245: PUSH
2246: CALL 4089 0 0
2250: PUSH
2251: EMPTY
2252: LIST
2253: UNION
2254: ST_TO_ADDR
2255: GO 2220
// load_konvoj ;
2257: CALL 220 0 0
// SetSide ( Rusaci , side_Ru ) ;
2261: LD_EXP 22
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL_OW 235
// SetSide ( Konvoj , side_Ru ) ;
2275: LD_EXP 24
2279: PPUSH
2280: LD_EXP 2
2284: PPUSH
2285: CALL_OW 235
// SetSide ( Vsevolod , side_Ru2 ) ;
2289: LD_EXP 11
2293: PPUSH
2294: LD_EXP 3
2298: PPUSH
2299: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru2 ) ;
2303: LD_EXP 23
2307: PPUSH
2308: LD_EXP 3
2312: PPUSH
2313: CALL_OW 235
// end ;
2317: LD_VAR 0 1
2321: RET
// function save ; var Lidi , Ostatni , Opice ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
2326: PPUSH
2327: PPUSH
// DeleteVariable ( Convoy_06 ) ;
2328: LD_STRING Convoy_06
2330: PPUSH
2331: CALL_OW 41
// HeikeCaptured = Heike and IsOK ( Heike ) ;
2335: LD_ADDR_EXP 9
2339: PUSH
2340: LD_EXP 26
2344: PUSH
2345: LD_EXP 26
2349: PPUSH
2350: CALL_OW 302
2354: AND
2355: ST_TO_ADDR
// SaveVariable ( HeikeCaptured , HeikeCaptured ) ;
2356: LD_EXP 9
2360: PPUSH
2361: LD_STRING HeikeCaptured
2363: PPUSH
2364: CALL_OW 39
// SaveVariable ( not HeikeCaptured , HeikeKilled ) ;
2368: LD_EXP 9
2372: NOT
2373: PPUSH
2374: LD_STRING HeikeKilled
2376: PPUSH
2377: CALL_OW 39
// save_char ( Burlak , Burlak ) ;
2381: LD_EXP 10
2385: PPUSH
2386: LD_STRING Burlak
2388: PPUSH
2389: CALL 122 0 2
// if not FalesnaYelena then
2393: LD_LOC 1
2397: NOT
2398: IFFALSE 2412
// save_char ( Yelena , Kirilenkova ) ;
2400: LD_EXP 13
2404: PPUSH
2405: LD_STRING Kirilenkova
2407: PPUSH
2408: CALL 122 0 2
// save_char ( Karamazov , Karamazov ) ;
2412: LD_EXP 16
2416: PPUSH
2417: LD_STRING Karamazov
2419: PPUSH
2420: CALL 122 0 2
// save_char ( Petrovova , Petrovova ) ;
2424: LD_EXP 17
2428: PPUSH
2429: LD_STRING Petrovova
2431: PPUSH
2432: CALL 122 0 2
// save_char ( Gleb , Gleb ) ;
2436: LD_EXP 14
2440: PPUSH
2441: LD_STRING Gleb
2443: PPUSH
2444: CALL 122 0 2
// save_char ( Petrosyan , Petrosyan ) ;
2448: LD_EXP 15
2452: PPUSH
2453: LD_STRING Petrosyan
2455: PPUSH
2456: CALL 122 0 2
// save_char ( Lipshchin , Lipshchin ) ;
2460: LD_EXP 21
2464: PPUSH
2465: LD_STRING Lipshchin
2467: PPUSH
2468: CALL 122 0 2
// save_char ( Titov , Titov ) ;
2472: LD_EXP 19
2476: PPUSH
2477: LD_STRING Titov
2479: PPUSH
2480: CALL 122 0 2
// save_char ( Dolgov , Dolgov ) ;
2484: LD_EXP 18
2488: PPUSH
2489: LD_STRING Dolgov
2491: PPUSH
2492: CALL 122 0 2
// save_char ( Vsevolod , Vsevolod ) ;
2496: LD_EXP 11
2500: PPUSH
2501: LD_STRING Vsevolod
2503: PPUSH
2504: CALL 122 0 2
// SaveCharacters ( [ Xavier ] , Xavier ) ;
2508: LD_EXP 25
2512: PUSH
2513: EMPTY
2514: LIST
2515: PPUSH
2516: LD_STRING Xavier
2518: PPUSH
2519: CALL_OW 38
// SaveCharacters ( [ Heike ] , Heike ) ;
2523: LD_EXP 26
2527: PUSH
2528: EMPTY
2529: LIST
2530: PPUSH
2531: LD_STRING Heike
2533: PPUSH
2534: CALL_OW 38
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_ALIVE ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_INT 22
2545: PUSH
2546: LD_EXP 2
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_INT 51
2557: PUSH
2558: EMPTY
2559: LIST
2560: PUSH
2561: LD_INT 21
2563: PUSH
2564: LD_INT 1
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: LD_VAR 0 2
2590: PPUSH
2591: LD_INT 2
2593: PUSH
2594: LD_INT 25
2596: PUSH
2597: LD_INT 12
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: PUSH
2604: LD_INT 25
2606: PUSH
2607: LD_INT 15
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: PUSH
2614: LD_INT 25
2616: PUSH
2617: LD_INT 16
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 25
2626: PUSH
2627: LD_INT 17
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: PPUSH
2644: CALL_OW 72
2648: ST_TO_ADDR
// Ostatni = Lidi diff [ 0 , Burlak , Vsevolod , Heike , Yelena , Popov , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin , Yashin , Xavier ] ;
2649: LD_ADDR_VAR 0 3
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_INT 0
2661: PUSH
2662: LD_EXP 10
2666: PUSH
2667: LD_EXP 11
2671: PUSH
2672: LD_EXP 26
2676: PUSH
2677: LD_EXP 13
2681: PUSH
2682: LD_EXP 12
2686: PUSH
2687: LD_EXP 14
2691: PUSH
2692: LD_EXP 15
2696: PUSH
2697: LD_EXP 16
2701: PUSH
2702: LD_EXP 17
2706: PUSH
2707: LD_EXP 18
2711: PUSH
2712: LD_EXP 19
2716: PUSH
2717: LD_EXP 20
2721: PUSH
2722: LD_EXP 21
2726: PUSH
2727: LD_EXP 34
2731: PUSH
2732: LD_EXP 25
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: DIFF
2755: ST_TO_ADDR
// Ostatni = Ostatni diff Opice ;
2756: LD_ADDR_VAR 0 3
2760: PUSH
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 4
2770: DIFF
2771: ST_TO_ADDR
// if FalesnaYelena and IsOk ( Yelena ) then
2772: LD_LOC 1
2776: PUSH
2777: LD_EXP 13
2781: PPUSH
2782: CALL_OW 302
2786: AND
2787: IFFALSE 2808
// Ostatni = Ostatni union [ Yelena ] ;
2789: LD_ADDR_VAR 0 3
2793: PUSH
2794: LD_VAR 0 3
2798: PUSH
2799: LD_EXP 13
2803: PUSH
2804: EMPTY
2805: LIST
2806: UNION
2807: ST_TO_ADDR
// SaveCharacters ( Ostatni , Survivors2 ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: LD_STRING Survivors2
2815: PPUSH
2816: CALL_OW 38
// end ;
2820: LD_VAR 0 1
2824: RET
// function dej_medaile ; var medal1 , medal2 , medal3 ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// medal1 := false ;
2831: LD_ADDR_VAR 0 2
2835: PUSH
2836: LD_INT 0
2838: ST_TO_ADDR
// medal2 := false ;
2839: LD_ADDR_VAR 0 3
2843: PUSH
2844: LD_INT 0
2846: ST_TO_ADDR
// medal3 := false ;
2847: LD_ADDR_VAR 0 4
2851: PUSH
2852: LD_INT 0
2854: ST_TO_ADDR
// if Xavier and IsLive ( Xavier ) then
2855: LD_EXP 25
2859: PUSH
2860: LD_EXP 25
2864: PPUSH
2865: CALL_OW 300
2869: AND
2870: IFFALSE 2892
// begin medal1 := true ;
2872: LD_ADDR_VAR 0 2
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// AddMedal ( Xavier , 1 ) ;
2880: LD_STRING Xavier
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: CALL_OW 101
// end else
2890: GO 2903
// AddMedal ( Xavier , - 1 ) ;
2892: LD_STRING Xavier
2894: PPUSH
2895: LD_INT 1
2897: NEG
2898: PPUSH
2899: CALL_OW 101
// if VsevSaved then
2903: LD_EXP 8
2907: IFFALSE 2948
// if PropaslQuickly then
2909: LD_EXP 29
2913: IFFALSE 2928
// AddMedal ( TimeVS , - 1 ) else
2915: LD_STRING TimeVS
2917: PPUSH
2918: LD_INT 1
2920: NEG
2921: PPUSH
2922: CALL_OW 101
2926: GO 2946
// begin medal2 := true ;
2928: LD_ADDR_VAR 0 3
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// AddMedal ( TimeVS , 1 ) ;
2936: LD_STRING TimeVS
2938: PPUSH
2939: LD_INT 1
2941: PPUSH
2942: CALL_OW 101
// end else
2946: GO 2977
// if ContactIn5Min then
2948: LD_EXP 28
2952: IFFALSE 2966
// AddMedal ( TimeNV , 1 ) else
2954: LD_STRING TimeNV
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: CALL_OW 101
2964: GO 2977
// AddMedal ( TimeNV , - 1 ) ;
2966: LD_STRING TimeNV
2968: PPUSH
2969: LD_INT 1
2971: NEG
2972: PPUSH
2973: CALL_OW 101
// if IsOK ( Heike ) then
2977: LD_EXP 26
2981: PPUSH
2982: CALL_OW 302
2986: IFFALSE 3008
// begin medal3 := true ;
2988: LD_ADDR_VAR 0 4
2992: PUSH
2993: LD_INT 1
2995: ST_TO_ADDR
// AddMedal ( Heike , 1 ) ;
2996: LD_STRING Heike
2998: PPUSH
2999: LD_INT 1
3001: PPUSH
3002: CALL_OW 101
// end else
3006: GO 3019
// AddMedal ( Heike , - 1 ) ;
3008: LD_STRING Heike
3010: PPUSH
3011: LD_INT 1
3013: NEG
3014: PPUSH
3015: CALL_OW 101
// SA_EndMission ( 3 , 7 , medal1 , medal2 , medal3 ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 7
3024: PPUSH
3025: LD_VAR 0 2
3029: PPUSH
3030: LD_VAR 0 3
3034: PPUSH
3035: LD_VAR 0 4
3039: PPUSH
3040: CALL 22917 0 5
// end ;
3044: LD_VAR 0 1
3048: RET
// export function vyhral ( Ident ) ; var Lidi , Opice ; begin
3049: LD_INT 0
3051: PPUSH
3052: PPUSH
3053: PPUSH
// dej_medaile ;
3054: CALL 2825 0 0
// GiveMedals ( Ident ) ;
3058: LD_VAR 0 1
3062: PPUSH
3063: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
3067: LD_ADDR_VAR 0 3
3071: PUSH
3072: LD_INT 22
3074: PUSH
3075: LD_EXP 2
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 21
3086: PUSH
3087: LD_INT 1
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 51
3096: PUSH
3097: EMPTY
3098: LIST
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: LD_VAR 0 3
3119: PPUSH
3120: LD_INT 2
3122: PUSH
3123: LD_INT 25
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 25
3135: PUSH
3136: LD_INT 15
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: LD_INT 25
3145: PUSH
3146: LD_INT 16
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PUSH
3153: LD_INT 25
3155: PUSH
3156: LD_INT 17
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: PPUSH
3173: CALL_OW 72
3177: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
3178: LD_VAR 0 3
3182: PUSH
3183: LD_VAR 0 4
3187: DIFF
3188: PPUSH
3189: CALL_OW 43
// save ;
3193: CALL 2322 0 0
// YouWin ;
3197: CALL_OW 103
// end ;
3201: LD_VAR 0 2
3205: RET
// function set_attitudes ; begin
3206: LD_INT 0
3208: PPUSH
// ChangeSideFog ( side_Xavier , GetSideFog ( side_Ru ) ) ;
3209: LD_EXP 5
3213: PPUSH
3214: LD_EXP 2
3218: PPUSH
3219: CALL_OW 342
3223: PPUSH
3224: CALL_OW 343
// ChangeSideFog ( side_Ru2 , GetSideFog ( side_Ru ) ) ;
3228: LD_EXP 3
3232: PPUSH
3233: LD_EXP 2
3237: PPUSH
3238: CALL_OW 342
3242: PPUSH
3243: CALL_OW 343
// SetAttitude ( side_Ru2 , side_Ru , ATT_FRIEND , true ) ;
3247: LD_EXP 3
3251: PPUSH
3252: LD_EXP 2
3256: PPUSH
3257: LD_INT 1
3259: PPUSH
3260: LD_INT 1
3262: PPUSH
3263: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Ar , ATT_ENEMY , false ) ;
3267: LD_EXP 3
3271: PPUSH
3272: LD_EXP 4
3276: PPUSH
3277: LD_INT 2
3279: PPUSH
3280: LD_INT 0
3282: PPUSH
3283: CALL_OW 80
// SetAttitude ( side_Ar , side_Ru2 , ATT_FRIEND , false ) ;
3287: LD_EXP 4
3291: PPUSH
3292: LD_EXP 3
3296: PPUSH
3297: LD_INT 1
3299: PPUSH
3300: LD_INT 0
3302: PPUSH
3303: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Strazci , ATT_ENEMY , false ) ;
3307: LD_EXP 3
3311: PPUSH
3312: LD_EXP 7
3316: PPUSH
3317: LD_INT 2
3319: PPUSH
3320: LD_INT 0
3322: PPUSH
3323: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Heike , ATT_NEUTRAL , false ) ;
3327: LD_EXP 3
3331: PPUSH
3332: LD_EXP 6
3336: PPUSH
3337: LD_INT 0
3339: PPUSH
3340: LD_INT 0
3342: PPUSH
3343: CALL_OW 80
// SetAttitude ( side_Strazci , side_Ru2 , ATT_NEUTRAL , false ) ;
3347: LD_EXP 7
3351: PPUSH
3352: LD_EXP 3
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: LD_INT 0
3362: PPUSH
3363: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru2 , ATT_NEUTRAL , false ) ;
3367: LD_EXP 6
3371: PPUSH
3372: LD_EXP 3
3376: PPUSH
3377: LD_INT 0
3379: PPUSH
3380: LD_INT 0
3382: PPUSH
3383: CALL_OW 80
// SetAttitude ( side_Ru , side_Xavier , ATT_FRIEND , true ) ;
3387: LD_EXP 2
3391: PPUSH
3392: LD_EXP 5
3396: PPUSH
3397: LD_INT 1
3399: PPUSH
3400: LD_INT 1
3402: PPUSH
3403: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Xavier , ATT_FRIEND , true ) ;
3407: LD_EXP 3
3411: PPUSH
3412: LD_EXP 5
3416: PPUSH
3417: LD_INT 1
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: CALL_OW 80
// SetAttitude ( side_Ar , side_Xavier , ATT_FRIEND , true ) ;
3427: LD_EXP 4
3431: PPUSH
3432: LD_EXP 5
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: LD_INT 1
3442: PPUSH
3443: CALL_OW 80
// SetAttitude ( side_Heike , side_Xavier , ATT_NEUTRAL , true ) ;
3447: LD_EXP 6
3451: PPUSH
3452: LD_EXP 5
3456: PPUSH
3457: LD_INT 0
3459: PPUSH
3460: LD_INT 1
3462: PPUSH
3463: CALL_OW 80
// SetAttitude ( side_Strazci , side_Xavier , ATT_NEUTRAL , true ) ;
3467: LD_EXP 7
3471: PPUSH
3472: LD_EXP 5
3476: PPUSH
3477: LD_INT 0
3479: PPUSH
3480: LD_INT 1
3482: PPUSH
3483: CALL_OW 80
// SetAttitude ( side_Ru , side_Heike , ATT_NEUTRAL , false ) ;
3487: LD_EXP 2
3491: PPUSH
3492: LD_EXP 6
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: LD_INT 0
3502: PPUSH
3503: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru , ATT_ENEMY , false ) ;
3507: LD_EXP 6
3511: PPUSH
3512: LD_EXP 2
3516: PPUSH
3517: LD_INT 2
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 80
// SetAttitude ( side_Heike , side_Ar , ATT_FRIEND , true ) ;
3527: LD_EXP 6
3531: PPUSH
3532: LD_EXP 4
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_INT 1
3542: PPUSH
3543: CALL_OW 80
// SetAttitude ( side_Heike , side_Strazci , ATT_FRIEND , true ) ;
3547: LD_EXP 6
3551: PPUSH
3552: LD_EXP 7
3556: PPUSH
3557: LD_INT 1
3559: PPUSH
3560: LD_INT 1
3562: PPUSH
3563: CALL_OW 80
// SetAttitude ( side_Ar , side_Strazci , ATT_FRIEND , true ) ;
3567: LD_EXP 4
3571: PPUSH
3572: LD_EXP 7
3576: PPUSH
3577: LD_INT 1
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL_OW 80
// end ;
3587: LD_VAR 0 1
3591: RET
// starting begin RandomizeAll ;
3592: CALL_OW 11
// AutoEnemy = false ;
3596: LD_ADDR_OWVAR 74
3600: PUSH
3601: LD_INT 0
3603: ST_TO_ADDR
// side_Neutral = 0 ;
3604: LD_ADDR_EXP 1
3608: PUSH
3609: LD_INT 0
3611: ST_TO_ADDR
// side_Ar = 2 ;
3612: LD_ADDR_EXP 4
3616: PUSH
3617: LD_INT 2
3619: ST_TO_ADDR
// side_Ru = 3 ;
3620: LD_ADDR_EXP 2
3624: PUSH
3625: LD_INT 3
3627: ST_TO_ADDR
// side_Ru2 = 6 ;
3628: LD_ADDR_EXP 3
3632: PUSH
3633: LD_INT 6
3635: ST_TO_ADDR
// side_Xavier = 5 ;
3636: LD_ADDR_EXP 5
3640: PUSH
3641: LD_INT 5
3643: ST_TO_ADDR
// side_Heike = 7 ;
3644: LD_ADDR_EXP 6
3648: PUSH
3649: LD_INT 7
3651: ST_TO_ADDR
// side_Strazci = 8 ;
3652: LD_ADDR_EXP 7
3656: PUSH
3657: LD_INT 8
3659: ST_TO_ADDR
// set_attitudes ;
3660: CALL 3206 0 0
// ContactIn5Min = 0 ;
3664: LD_ADDR_EXP 28
3668: PUSH
3669: LD_INT 0
3671: ST_TO_ADDR
// PropaslQuickly = 0 ;
3672: LD_ADDR_EXP 29
3676: PUSH
3677: LD_INT 0
3679: ST_TO_ADDR
// Minuty = 0 ;
3680: LD_ADDR_EXP 30
3684: PUSH
3685: LD_INT 0
3687: ST_TO_ADDR
// InitUc ;
3688: CALL_OW 18
// InitBc ;
3692: CALL_OW 21
// InitHc ;
3696: CALL_OW 19
// InitVc ;
3700: CALL_OW 20
// init_difficulty ;
3704: CALL 20078 0 0
// load ;
3708: CALL 1005 0 0
// init_nature ;
3712: CALL 21261 0 0
// init_suroviny ;
3716: CALL 19287 0 0
// init_arabi ;
3720: CALL 6402 0 0
// init_rusove ;
3724: CALL 3764 0 0
// init_xavier ;
3728: CALL 15127 0 0
// init_heike ;
3732: CALL 17077 0 0
// init_yashin ;
3736: CALL 13097 0 0
// uvod ;
3740: CALL 3827 0 0
// end ;
3744: END
// every 1 1$0 do
3745: GO 3747
3747: DISABLE
// begin Minuty = Minuty + 1 ;
3748: LD_ADDR_EXP 30
3752: PUSH
3753: LD_EXP 30
3757: PUSH
3758: LD_INT 1
3760: PLUS
3761: ST_TO_ADDR
// enable ;
3762: ENABLE
// end ; end_of_file
3763: END
// export RuDepot , RuLab , RuOil ; var VidelAraby ; var YashinZacal ; var KdoSlaplNaMinu ; export function init_rusove ; begin
3764: LD_INT 0
3766: PPUSH
// disable ( 1 ) ;
3767: LD_INT 1
3769: DISABLE_MARKED
// disable ( 2 ) ;
3770: LD_INT 2
3772: DISABLE_MARKED
// disable ( 3 ) ;
3773: LD_INT 3
3775: DISABLE_MARKED
// disable ( 4 ) ;
3776: LD_INT 4
3778: DISABLE_MARKED
// disable ( 5 ) ;
3779: LD_INT 5
3781: DISABLE_MARKED
// RuDepot = 0 ;
3782: LD_ADDR_EXP 31
3786: PUSH
3787: LD_INT 0
3789: ST_TO_ADDR
// RuLab = 0 ;
3790: LD_ADDR_EXP 32
3794: PUSH
3795: LD_INT 0
3797: ST_TO_ADDR
// RuOil = 0 ;
3798: LD_ADDR_EXP 33
3802: PUSH
3803: LD_INT 0
3805: ST_TO_ADDR
// VidelAraby = false ;
3806: LD_ADDR_LOC 2
3810: PUSH
3811: LD_INT 0
3813: ST_TO_ADDR
// YashinZacal = false ;
3814: LD_ADDR_LOC 3
3818: PUSH
3819: LD_INT 0
3821: ST_TO_ADDR
// end ;
3822: LD_VAR 0 1
3826: RET
// export function uvod ; begin
3827: LD_INT 0
3829: PPUSH
// SetResourceVisibility ( 47 , 75 , side_Ru ) ;
3830: LD_INT 47
3832: PPUSH
3833: LD_INT 75
3835: PPUSH
3836: LD_EXP 2
3840: PPUSH
3841: CALL_OW 441
// if VsevSaved then
3845: LD_EXP 8
3849: IFFALSE 3857
// uvod_vsevolod else
3851: CALL 4164 0 0
3855: GO 3861
// uvod_sam ;
3857: CALL 5578 0 0
// Hint ( NonCombat ) ;
3861: LD_STRING NonCombat
3863: PPUSH
3864: CALL_OW 339
// end ;
3868: LD_VAR 0 1
3872: RET
// function priprav_zakladnu ; var Base ; begin
3873: LD_INT 0
3875: PPUSH
3876: PPUSH
// UC_Nation = NATION_RUSSIAN ;
3877: LD_ADDR_OWVAR 21
3881: PUSH
3882: LD_INT 3
3884: ST_TO_ADDR
// UC_side = side_Ru ;
3885: LD_ADDR_OWVAR 20
3889: PUSH
3890: LD_EXP 2
3894: ST_TO_ADDR
// BC_Level = 4 ;
3895: LD_ADDR_OWVAR 43
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// BC_Type = B_DEPOT ;
3903: LD_ADDR_OWVAR 42
3907: PUSH
3908: LD_INT 0
3910: ST_TO_ADDR
// RuDepot = CreateAndPlaceBuildingXYD ( 35 , 58 , 1 ) ;
3911: LD_ADDR_EXP 31
3915: PUSH
3916: LD_INT 35
3918: PPUSH
3919: LD_INT 58
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 47
3929: ST_TO_ADDR
// BC_Type = B_OIL_POWER ;
3930: LD_ADDR_OWVAR 42
3934: PUSH
3935: LD_INT 26
3937: ST_TO_ADDR
// RuOil = CreateAndPlaceBuildingXYD ( 31 , 45 , 1 ) ;
3938: LD_ADDR_EXP 33
3942: PUSH
3943: LD_INT 31
3945: PPUSH
3946: LD_INT 45
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: CALL_OW 47
3956: ST_TO_ADDR
// BC_Type = B_LAB_HALF ;
3957: LD_ADDR_OWVAR 42
3961: PUSH
3962: LD_INT 7
3964: ST_TO_ADDR
// BC_Kind1 = B_LAB_SPACETIME ;
3965: LD_ADDR_OWVAR 44
3969: PUSH
3970: LD_INT 14
3972: ST_TO_ADDR
// BC_Kind2 = B_LAB_BASIC ;
3973: LD_ADDR_OWVAR 45
3977: PUSH
3978: LD_INT 9
3980: ST_TO_ADDR
// RuLab = CreateAndPlaceBuildingXYD ( 37 , 52 , 2 ) ;
3981: LD_ADDR_EXP 32
3985: PUSH
3986: LD_INT 37
3988: PPUSH
3989: LD_INT 52
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 47
3999: ST_TO_ADDR
// Base = GetBase ( RuDepot ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_EXP 31
4009: PPUSH
4010: CALL_OW 274
4014: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , dif_Cans [ Difficulty ] ) ;
4015: LD_VAR 0 2
4019: PPUSH
4020: LD_INT 1
4022: PPUSH
4023: LD_EXP 44
4027: PUSH
4028: LD_OWVAR 67
4032: ARRAY
4033: PPUSH
4034: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , dif_Oil [ Difficulty ] ) ;
4038: LD_VAR 0 2
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: LD_EXP 45
4050: PUSH
4051: LD_OWVAR 67
4055: ARRAY
4056: PPUSH
4057: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , dif_Siberit [ Difficulty ] ) ;
4061: LD_VAR 0 2
4065: PPUSH
4066: LD_INT 3
4068: PPUSH
4069: LD_EXP 46
4073: PUSH
4074: LD_OWVAR 67
4078: ARRAY
4079: PPUSH
4080: CALL_OW 277
// end ;
4084: LD_VAR 0 1
4088: RET
// export function vytvor_rusaka ; begin
4089: LD_INT 0
4091: PPUSH
// UC_Nation = NATION_RUSSIAN ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// UC_side = side_Ru ;
4100: LD_ADDR_OWVAR 20
4104: PUSH
4105: LD_EXP 2
4109: ST_TO_ADDR
// HC_name =  ;
4110: LD_ADDR_OWVAR 26
4114: PUSH
4115: LD_STRING 
4117: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
4118: LD_ADDR_OWVAR 27
4122: PUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_INT 2
4128: PPUSH
4129: CALL_OW 12
4133: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
4134: LD_ADDR_OWVAR 28
4138: PUSH
4139: LD_INT 1
4141: ST_TO_ADDR
// PrepareSoldierSkills ( 4 ) ;
4142: LD_INT 4
4144: PPUSH
4145: CALL_OW 375
// Result = CreateHuman ;
4149: LD_ADDR_VAR 0 1
4153: PUSH
4154: CALL_OW 44
4158: ST_TO_ADDR
// end ;
4159: LD_VAR 0 1
4163: RET
// function uvod_vsevolod ; var I , Counter , X , Y , Seznam , Ridici ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
// priprav_zakladnu ;
4173: CALL 3873 0 0
// if GetClass ( Yelena ) = CLASS_SCIENTISTIC then
4177: LD_EXP 13
4181: PPUSH
4182: CALL_OW 257
4186: PUSH
4187: LD_INT 4
4189: EQUAL
4190: IFFALSE 4204
// SetClass ( Yelena , CLASS_ENGINEER ) ;
4192: LD_EXP 13
4196: PPUSH
4197: LD_INT 2
4199: PPUSH
4200: CALL_OW 336
// if GetClass ( Burlak ) = CLASS_SCIENTISTIC then
4204: LD_EXP 10
4208: PPUSH
4209: CALL_OW 257
4213: PUSH
4214: LD_INT 4
4216: EQUAL
4217: IFFALSE 4231
// SetClass ( Burlak , CLASS_ENGINEER ) ;
4219: LD_EXP 10
4223: PPUSH
4224: LD_INT 2
4226: PPUSH
4227: CALL_OW 336
// Seznam = UnitFilter ( Rusaci union WithVsevolod , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
4231: LD_ADDR_VAR 0 6
4235: PUSH
4236: LD_EXP 22
4240: PUSH
4241: LD_EXP 23
4245: UNION
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: EMPTY
4258: LIST
4259: PPUSH
4260: CALL_OW 72
4264: ST_TO_ADDR
// for I in Seznam do
4265: LD_ADDR_VAR 0 2
4269: PUSH
4270: LD_VAR 0 6
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetClass ( I , CLASS_SOLDIER ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 1
4285: PPUSH
4286: CALL_OW 336
4290: GO 4275
4292: POP
4293: POP
// SetTech ( TECH_TAUFIELD , side_Ru , STATE_RESEARCHED ) ;
4294: LD_INT 30
4296: PPUSH
4297: LD_EXP 2
4301: PPUSH
4302: LD_INT 2
4304: PPUSH
4305: CALL_OW 322
// SetTech ( TECH_TAUFIELD , side_Ru2 , STATE_RESEARCHED ) ;
4309: LD_INT 30
4311: PPUSH
4312: LD_EXP 3
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 322
// PlaceUnitArea ( Vsevolod , Start1Vsevolod , false ) ;
4324: LD_EXP 11
4328: PPUSH
4329: LD_INT 16
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 49
// X = GetX ( Vsevolod ) ;
4339: LD_ADDR_VAR 0 4
4343: PUSH
4344: LD_EXP 11
4348: PPUSH
4349: CALL_OW 250
4353: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4354: LD_ADDR_VAR 0 5
4358: PUSH
4359: LD_EXP 11
4363: PPUSH
4364: CALL_OW 251
4368: ST_TO_ADDR
// PlaceUnitXYR ( Burlak , X , Y , 6 , false ) ;
4369: LD_EXP 10
4373: PPUSH
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_VAR 0 5
4383: PPUSH
4384: LD_INT 6
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 50
// Seznam = UnitFilter ( Konvoj , [ [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
4394: LD_ADDR_VAR 0 6
4398: PUSH
4399: LD_EXP 24
4403: PPUSH
4404: LD_INT 33
4406: PUSH
4407: LD_INT 1
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: PPUSH
4417: CALL_OW 72
4421: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , Seznam ) ;
4422: LD_ADDR_VAR 0 7
4426: PUSH
4427: LD_EXP 22
4431: PPUSH
4432: LD_VAR 0 6
4436: PPUSH
4437: CALL 5484 0 2
4441: ST_TO_ADDR
// for I = 1 to Seznam do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: DOUBLE
4448: LD_INT 1
4450: DEC
4451: ST_TO_ADDR
4452: LD_VAR 0 6
4456: PUSH
4457: FOR_TO
4458: IFFALSE 4500
// if Ridici >= I then
4460: LD_VAR 0 7
4464: PUSH
4465: LD_VAR 0 2
4469: GREATEREQUAL
4470: IFFALSE 4498
// PlaceHumanInUnit ( Ridici [ I ] , Seznam [ I ] ) ;
4472: LD_VAR 0 7
4476: PUSH
4477: LD_VAR 0 2
4481: ARRAY
4482: PPUSH
4483: LD_VAR 0 6
4487: PUSH
4488: LD_VAR 0 2
4492: ARRAY
4493: PPUSH
4494: CALL_OW 52
4498: GO 4457
4500: POP
4501: POP
// place_list ( Konvoj , Start1 ) ;
4502: LD_EXP 24
4506: PPUSH
4507: LD_INT 12
4509: PPUSH
4510: CALL 20674 0 2
// place_list ( Rusaci diff Ridici , Start1 ) ;
4514: LD_EXP 22
4518: PUSH
4519: LD_VAR 0 7
4523: DIFF
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: CALL 20674 0 2
// place_list ( Yelena , Start1Vsevolod ) ;
4532: LD_EXP 13
4536: PPUSH
4537: LD_INT 16
4539: PPUSH
4540: CALL 20674 0 2
// place_list ( WithVsevolod , Start1Vsevolod ) ;
4544: LD_EXP 23
4548: PPUSH
4549: LD_INT 16
4551: PPUSH
4552: CALL 20674 0 2
// InGameOn ;
4556: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
4560: LD_EXP 10
4564: PPUSH
4565: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
4569: LD_EXP 10
4573: PUSH
4574: EMPTY
4575: LIST
4576: PPUSH
4577: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
4581: LD_EXP 10
4585: PUSH
4586: EMPTY
4587: LIST
4588: PPUSH
4589: CALL_OW 85
// dialog_Start ;
4593: CALL 21317 0 0
// dialog_StartVS ;
4597: CALL 21337 0 0
// dialog_Start2 ;
4601: CALL 21377 0 0
// ChangeMissionObjectives ( MStart ) ;
4605: LD_STRING MStart
4607: PPUSH
4608: CALL_OW 337
// jdete_k_sobe ( Burlak , Vsevolod ) ;
4612: LD_EXP 10
4616: PPUSH
4617: LD_EXP 11
4621: PPUSH
4622: CALL 20595 0 2
// AddComHold ( [ Burlak , Vsevolod ] ) ;
4626: LD_EXP 10
4630: PUSH
4631: LD_EXP 11
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 200
// CenterOnUnits ( [ Burlak , Vsevolod ] ) ;
4644: LD_EXP 10
4648: PUSH
4649: LD_EXP 11
4653: PUSH
4654: EMPTY
4655: LIST
4656: LIST
4657: PPUSH
4658: CALL_OW 85
// RevealFogArea ( side_Ru , RuDepotFog ) ;
4662: LD_EXP 2
4666: PPUSH
4667: LD_INT 15
4669: PPUSH
4670: CALL_OW 332
// dialog_MeetVsevolodVS ;
4674: CALL 21409 0 0
// CenterOnUnits ( [ RuDepot , RuLab , RuOil ] ) ;
4678: LD_EXP 31
4682: PUSH
4683: LD_EXP 32
4687: PUSH
4688: LD_EXP 33
4692: PUSH
4693: EMPTY
4694: LIST
4695: LIST
4696: LIST
4697: PPUSH
4698: CALL_OW 85
// Wait ( 0 0$2 ) ;
4702: LD_INT 70
4704: PPUSH
4705: CALL_OW 67
// CenterOnUnits ( Burlak ) ;
4709: LD_EXP 10
4713: PPUSH
4714: CALL_OW 85
// ComMoveToArea ( Vsevolod , Mina ) ;
4718: LD_EXP 11
4722: PPUSH
4723: LD_INT 17
4725: PPUSH
4726: CALL_OW 113
// ComWait ( WithVsevolod , 0 0$5 ) ;
4730: LD_EXP 23
4734: PPUSH
4735: LD_INT 175
4737: PPUSH
4738: CALL_OW 142
// AddComMoveToArea ( WithVsevolod , Mina ) ;
4742: LD_EXP 23
4746: PPUSH
4747: LD_INT 17
4749: PPUSH
4750: CALL_OW 173
// AddComMoveToArea ( Vsevolod , RuDepotFog ) ;
4754: LD_EXP 11
4758: PPUSH
4759: LD_INT 15
4761: PPUSH
4762: CALL_OW 173
// AddComMoveToArea ( WithVsevolod , RuDepotFog ) ;
4766: LD_EXP 23
4770: PPUSH
4771: LD_INT 15
4773: PPUSH
4774: CALL_OW 173
// Counter = 0 ;
4778: LD_ADDR_VAR 0 3
4782: PUSH
4783: LD_INT 0
4785: ST_TO_ADDR
// while not IsInArea ( Vsevolod , Mina ) do
4786: LD_EXP 11
4790: PPUSH
4791: LD_INT 17
4793: PPUSH
4794: CALL_OW 308
4798: NOT
4799: IFFALSE 4847
// begin Wait ( 0 0$0.5 ) ;
4801: LD_INT 18
4803: PPUSH
4804: CALL_OW 67
// Counter = Counter + 1 ;
4808: LD_ADDR_VAR 0 3
4812: PUSH
4813: LD_VAR 0 3
4817: PUSH
4818: LD_INT 1
4820: PLUS
4821: ST_TO_ADDR
// if Counter mod 10 = 0 then
4822: LD_VAR 0 3
4826: PUSH
4827: LD_INT 10
4829: MOD
4830: PUSH
4831: LD_INT 0
4833: EQUAL
4834: IFFALSE 4845
// CenterOnUnits ( Vsevolod ) ;
4836: LD_EXP 11
4840: PPUSH
4841: CALL_OW 85
// end ;
4845: GO 4786
// CenterOnUnits ( Vsevolod ) ;
4847: LD_EXP 11
4851: PPUSH
4852: CALL_OW 85
// Wait ( 0 0$1 ) ;
4856: LD_INT 35
4858: PPUSH
4859: CALL_OW 67
// ComHold ( Vsevolod ) ;
4863: LD_EXP 11
4867: PPUSH
4868: CALL_OW 140
// X = GetX ( Vsevolod ) ;
4872: LD_ADDR_VAR 0 4
4876: PUSH
4877: LD_EXP 11
4881: PPUSH
4882: CALL_OW 250
4886: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4887: LD_ADDR_VAR 0 5
4891: PUSH
4892: LD_EXP 11
4896: PPUSH
4897: CALL_OW 251
4901: ST_TO_ADDR
// MineExplosion ( X , Y , false ) ;
4902: LD_VAR 0 4
4906: PPUSH
4907: LD_VAR 0 5
4911: PPUSH
4912: LD_INT 0
4914: PPUSH
4915: CALL_OW 453
// SetLives ( [ RuLab , RuOil ] , 25 ) ;
4919: LD_EXP 32
4923: PUSH
4924: LD_EXP 33
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PPUSH
4933: LD_INT 25
4935: PPUSH
4936: CALL_OW 234
// MineExplosion ( GetX ( RuLab ) , GetY ( RuLab ) , true ) ;
4940: LD_EXP 32
4944: PPUSH
4945: CALL_OW 250
4949: PPUSH
4950: LD_EXP 32
4954: PPUSH
4955: CALL_OW 251
4959: PPUSH
4960: LD_INT 1
4962: PPUSH
4963: CALL_OW 453
// MineExplosion ( GetX ( RuOil ) , GetY ( RuOil ) , true ) ;
4967: LD_EXP 33
4971: PPUSH
4972: CALL_OW 250
4976: PPUSH
4977: LD_EXP 33
4981: PPUSH
4982: CALL_OW 251
4986: PPUSH
4987: LD_INT 1
4989: PPUSH
4990: CALL_OW 453
// Wait ( 0 0$0.5 ) ;
4994: LD_INT 18
4996: PPUSH
4997: CALL_OW 67
// SetLives ( Vsevolod , HRANICE_UMIRANI ) ;
5001: LD_EXP 11
5005: PPUSH
5006: LD_INT 250
5008: PPUSH
5009: CALL_OW 234
// KdoSlaplNaMinu = [ Vsevolod ] ;
5013: LD_ADDR_LOC 4
5017: PUSH
5018: LD_EXP 11
5022: PUSH
5023: EMPTY
5024: LIST
5025: ST_TO_ADDR
// for I in FilterAllUnits ( [ [ F_PLACED ] ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 52
5033: PUSH
5034: EMPTY
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: PUSH
5045: FOR_IN
5046: IFFALSE 5128
// begin if I = Vsevolod then
5048: LD_VAR 0 2
5052: PUSH
5053: LD_EXP 11
5057: EQUAL
5058: IFFALSE 5062
// continue ;
5060: GO 5045
// if IsInUnit ( I ) then
5062: LD_VAR 0 2
5066: PPUSH
5067: CALL_OW 310
5071: IFFALSE 5075
// continue ;
5073: GO 5045
// if GetDistUnits ( Vsevolod , I ) <= 3 then
5075: LD_EXP 11
5079: PPUSH
5080: LD_VAR 0 2
5084: PPUSH
5085: CALL_OW 296
5089: PUSH
5090: LD_INT 3
5092: LESSEQUAL
5093: IFFALSE 5126
// begin SetLives ( I , HRANICE_UMIRANI ) ;
5095: LD_VAR 0 2
5099: PPUSH
5100: LD_INT 250
5102: PPUSH
5103: CALL_OW 234
// KdoSlaplNaMinu = KdoSlaplNaMinu union [ I ] ;
5107: LD_ADDR_LOC 4
5111: PUSH
5112: LD_LOC 4
5116: PUSH
5117: LD_VAR 0 2
5121: PUSH
5122: EMPTY
5123: LIST
5124: UNION
5125: ST_TO_ADDR
// end ; end ;
5126: GO 5045
5128: POP
5129: POP
// ComCancel ( WithVsevolod ) ;
5130: LD_EXP 23
5134: PPUSH
5135: CALL_OW 127
// ComHold ( WithVsevolod ) ;
5139: LD_EXP 23
5143: PPUSH
5144: CALL_OW 140
// dialog_StasisVS ;
5148: CALL 21465 0 0
// Wait ( 0 0$2 ) ;
5152: LD_INT 70
5154: PPUSH
5155: CALL_OW 67
// ChangeMissionObjectives ( MVsevolod ) ;
5159: LD_STRING MVsevolod
5161: PPUSH
5162: CALL_OW 337
// enable ( 1 ) ;
5166: LD_INT 1
5168: ENABLE_MARKED
// enable ( 2 ) ;
5169: LD_INT 2
5171: ENABLE_MARKED
// SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5172: LD_LOC 4
5176: PPUSH
5177: LD_INT 250
5179: PPUSH
5180: CALL_OW 234
// SetSide ( Vsevolod , side_Ru ) ;
5184: LD_EXP 11
5188: PPUSH
5189: LD_EXP 2
5193: PPUSH
5194: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
5198: LD_EXP 23
5202: PPUSH
5203: LD_EXP 2
5207: PPUSH
5208: CALL_OW 235
// ComFree ( [ Burlak , Vsevolod ] ) ;
5212: LD_EXP 10
5216: PUSH
5217: LD_EXP 11
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PPUSH
5226: CALL_OW 139
// SaveForQuickRestart ;
5230: CALL_OW 22
// InGameOff ;
5234: CALL_OW 9
// enable ( 5 ) ;
5238: LD_INT 5
5240: ENABLE_MARKED
// end ;
5241: LD_VAR 0 1
5245: RET
// every 0 0$5 marked 5 do var Kolik , I ;
5246: GO 5248
5248: DISABLE
5249: LD_INT 0
5251: PPUSH
5252: PPUSH
// begin if Difficulty = 1 then
5253: LD_OWVAR 67
5257: PUSH
5258: LD_INT 1
5260: EQUAL
5261: IFFALSE 5273
// Kolik = 20 else
5263: LD_ADDR_VAR 0 1
5267: PUSH
5268: LD_INT 20
5270: ST_TO_ADDR
5271: GO 5295
// if Difficulty = 2 then
5273: LD_OWVAR 67
5277: PUSH
5278: LD_INT 2
5280: EQUAL
5281: IFFALSE 5293
// Kolik = 10 else
5283: LD_ADDR_VAR 0 1
5287: PUSH
5288: LD_INT 10
5290: ST_TO_ADDR
5291: GO 5295
// exit ;
5293: GO 5336
// for I = 1 to Kolik do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: DOUBLE
5301: LD_INT 1
5303: DEC
5304: ST_TO_ADDR
5305: LD_VAR 0 1
5309: PUSH
5310: FOR_TO
5311: IFFALSE 5334
// begin SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5313: LD_LOC 4
5317: PPUSH
5318: LD_INT 250
5320: PPUSH
5321: CALL_OW 234
// Wait ( 0 0$1 ) ;
5325: LD_INT 35
5327: PPUSH
5328: CALL_OW 67
// end ;
5332: GO 5310
5334: POP
5335: POP
// end ;
5336: PPOPN 2
5338: END
// function vytvor_nakladaky ; var N1 , N2 ; begin
5339: LD_INT 0
5341: PPUSH
5342: PPUSH
5343: PPUSH
// UC_side = side_Ru ;
5344: LD_ADDR_OWVAR 20
5348: PUSH
5349: LD_EXP 2
5353: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
5354: LD_ADDR_OWVAR 21
5358: PUSH
5359: LD_INT 3
5361: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
5362: LD_ADDR_OWVAR 37
5366: PUSH
5367: LD_INT 21
5369: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
5370: LD_ADDR_OWVAR 38
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
5378: LD_ADDR_OWVAR 39
5382: PUSH
5383: LD_INT 1
5385: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
5386: LD_ADDR_OWVAR 40
5390: PUSH
5391: LD_INT 51
5393: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 75 , 100 ) ;
5394: LD_ADDR_OWVAR 41
5398: PUSH
5399: LD_INT 75
5401: PPUSH
5402: LD_INT 100
5404: PPUSH
5405: CALL_OW 12
5409: ST_TO_ADDR
// N1 = CreateVehicle ;
5410: LD_ADDR_VAR 0 2
5414: PUSH
5415: CALL_OW 45
5419: ST_TO_ADDR
// N2 = CreateVehicle ;
5420: LD_ADDR_VAR 0 3
5424: PUSH
5425: CALL_OW 45
5429: ST_TO_ADDR
// SetCargo ( N1 , MAT_CANS , 100 ) ;
5430: LD_VAR 0 2
5434: PPUSH
5435: LD_INT 1
5437: PPUSH
5438: LD_INT 100
5440: PPUSH
5441: CALL_OW 290
// SetCargo ( N2 , MAT_SIBERIT , 100 ) ;
5445: LD_VAR 0 3
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 100
5455: PPUSH
5456: CALL_OW 290
// Result = [ N1 , N2 ] ;
5460: LD_ADDR_VAR 0 1
5464: PUSH
5465: LD_VAR 0 2
5469: PUSH
5470: LD_VAR 0 3
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: ST_TO_ADDR
// end ;
5479: LD_VAR 0 1
5483: RET
// function zjisti_ridice ( Seznam , Pocet ) ; var I , Ted ; begin
5484: LD_INT 0
5486: PPUSH
5487: PPUSH
5488: PPUSH
// Result = [ ] ;
5489: LD_ADDR_VAR 0 3
5493: PUSH
5494: EMPTY
5495: ST_TO_ADDR
// while ( Result < Pocet ) and Seznam do
5496: LD_VAR 0 3
5500: PUSH
5501: LD_VAR 0 2
5505: LESS
5506: PUSH
5507: LD_VAR 0 1
5511: AND
5512: IFFALSE 5573
// begin Ted = Seznam [ 1 ] ;
5514: LD_ADDR_VAR 0 5
5518: PUSH
5519: LD_VAR 0 1
5523: PUSH
5524: LD_INT 1
5526: ARRAY
5527: ST_TO_ADDR
// Seznam = Delete ( Seznam , 1 ) ;
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: LD_VAR 0 1
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL_OW 3
5545: ST_TO_ADDR
// if Ted then
5546: LD_VAR 0 5
5550: IFFALSE 5571
// Result = Result union [ Ted ] ;
5552: LD_ADDR_VAR 0 3
5556: PUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_VAR 0 5
5566: PUSH
5567: EMPTY
5568: LIST
5569: UNION
5570: ST_TO_ADDR
// end ;
5571: GO 5496
// end ;
5573: LD_VAR 0 3
5577: RET
// function uvod_sam ; var I , Seznam , Ridici ; begin
5578: LD_INT 0
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
// SetSide ( Rusaci , side_Ru ) ;
5584: LD_EXP 22
5588: PPUSH
5589: LD_EXP 2
5593: PPUSH
5594: CALL_OW 235
// SetSide ( Yelena , side_Ru ) ;
5598: LD_EXP 13
5602: PPUSH
5603: LD_EXP 2
5607: PPUSH
5608: CALL_OW 235
// while Rusaci <= 7 do
5612: LD_EXP 22
5616: PUSH
5617: LD_INT 7
5619: LESSEQUAL
5620: IFFALSE 5643
// Rusaci = Rusaci union [ vytvor_rusaka ] ;
5622: LD_ADDR_EXP 22
5626: PUSH
5627: LD_EXP 22
5631: PUSH
5632: CALL 4089 0 0
5636: PUSH
5637: EMPTY
5638: LIST
5639: UNION
5640: ST_TO_ADDR
5641: GO 5612
// Rusaci = Rusaci union [ Yelena ] ;
5643: LD_ADDR_EXP 22
5647: PUSH
5648: LD_EXP 22
5652: PUSH
5653: LD_EXP 13
5657: PUSH
5658: EMPTY
5659: LIST
5660: UNION
5661: ST_TO_ADDR
// SetTech ( TECH_SIBDET , side_Ru , STATE_RESEARCHED ) ;
5662: LD_INT 20
5664: PPUSH
5665: LD_EXP 2
5669: PPUSH
5670: LD_INT 2
5672: PPUSH
5673: CALL_OW 322
// Seznam = UnitFilter ( Rusaci union [ Burlak ] , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
5677: LD_ADDR_VAR 0 3
5681: PUSH
5682: LD_EXP 22
5686: PUSH
5687: LD_EXP 10
5691: PUSH
5692: EMPTY
5693: LIST
5694: UNION
5695: PPUSH
5696: LD_INT 22
5698: PUSH
5699: LD_EXP 2
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 21
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 2
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: PPUSH
5733: CALL_OW 72
5737: ST_TO_ADDR
// if not Seznam then
5738: LD_VAR 0 3
5742: NOT
5743: IFFALSE 5757
// SetClass ( Burlak , CLASS_ENGINEER ) ;
5745: LD_EXP 10
5749: PPUSH
5750: LD_INT 2
5752: PPUSH
5753: CALL_OW 336
// Seznam = vytvor_nakladaky ;
5757: LD_ADDR_VAR 0 3
5761: PUSH
5762: CALL 5339 0 0
5766: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , 2 ) ;
5767: LD_ADDR_VAR 0 4
5771: PUSH
5772: LD_EXP 22
5776: PPUSH
5777: LD_INT 2
5779: PPUSH
5780: CALL 5484 0 2
5784: ST_TO_ADDR
// if Ridici >= 1 then
5785: LD_VAR 0 4
5789: PUSH
5790: LD_INT 1
5792: GREATEREQUAL
5793: IFFALSE 5817
// PlaceHumanInUnit ( Ridici [ 1 ] , Seznam [ 1 ] ) ;
5795: LD_VAR 0 4
5799: PUSH
5800: LD_INT 1
5802: ARRAY
5803: PPUSH
5804: LD_VAR 0 3
5808: PUSH
5809: LD_INT 1
5811: ARRAY
5812: PPUSH
5813: CALL_OW 52
// if Ridici >= 2 then
5817: LD_VAR 0 4
5821: PUSH
5822: LD_INT 2
5824: GREATEREQUAL
5825: IFFALSE 5849
// PlaceHumanInUnit ( Ridici [ 2 ] , Seznam [ 2 ] ) ;
5827: LD_VAR 0 4
5831: PUSH
5832: LD_INT 2
5834: ARRAY
5835: PPUSH
5836: LD_VAR 0 3
5840: PUSH
5841: LD_INT 2
5843: ARRAY
5844: PPUSH
5845: CALL_OW 52
// PlaceUnitArea ( Burlak , Start1a , false ) ;
5849: LD_EXP 10
5853: PPUSH
5854: LD_INT 13
5856: PPUSH
5857: LD_INT 0
5859: PPUSH
5860: CALL_OW 49
// Place_list ( Seznam , Start1a ) ;
5864: LD_VAR 0 3
5868: PPUSH
5869: LD_INT 13
5871: PPUSH
5872: CALL 20674 0 2
// place_list ( Rusaci diff Ridici , Start1a ) ;
5876: LD_EXP 22
5880: PUSH
5881: LD_VAR 0 4
5885: DIFF
5886: PPUSH
5887: LD_INT 13
5889: PPUSH
5890: CALL 20674 0 2
// for I = 1 to Rand ( 2 , 4 ) do
5894: LD_ADDR_VAR 0 2
5898: PUSH
5899: DOUBLE
5900: LD_INT 1
5902: DEC
5903: ST_TO_ADDR
5904: LD_INT 2
5906: PPUSH
5907: LD_INT 4
5909: PPUSH
5910: CALL_OW 12
5914: PUSH
5915: FOR_TO
5916: IFFALSE 5941
// CreateCratesArea ( Rand ( 1 , 5 ) , BednyRusoveV , false ) ;
5918: LD_INT 1
5920: PPUSH
5921: LD_INT 5
5923: PPUSH
5924: CALL_OW 12
5928: PPUSH
5929: LD_INT 29
5931: PPUSH
5932: LD_INT 0
5934: PPUSH
5935: CALL_OW 55
5939: GO 5915
5941: POP
5942: POP
// InGameOn ;
5943: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
5947: LD_EXP 10
5951: PPUSH
5952: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
5956: LD_EXP 10
5960: PUSH
5961: EMPTY
5962: LIST
5963: PPUSH
5964: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
5968: LD_EXP 10
5972: PUSH
5973: EMPTY
5974: LIST
5975: PPUSH
5976: CALL_OW 85
// dialog_Start ;
5980: CALL 21317 0 0
// dialog_StartNV ;
5984: CALL 21357 0 0
// dialog_Start2 ;
5988: CALL 21377 0 0
// ChangeMissionObjectives ( MStart ) ;
5992: LD_STRING MStart
5994: PPUSH
5995: CALL_OW 337
// enable ( 4 ) ;
5999: LD_INT 4
6001: ENABLE_MARKED
// AddComFree ( Burlak ) ;
6002: LD_EXP 10
6006: PPUSH
6007: CALL_OW 199
// SaveForQuickRestart ;
6011: CALL_OW 22
// InGameOff ;
6015: CALL_OW 9
// arabi_muzete_utocit ;
6019: CALL 10502 0 0
// end ;
6023: LD_VAR 0 1
6027: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
6028: LD_INT 0
6030: PPUSH
// if Un = Burlak then
6031: LD_VAR 0 1
6035: PUSH
6036: LD_EXP 10
6040: EQUAL
6041: IFFALSE 6052
// begin YouLost ( Burlak ) ;
6043: LD_STRING Burlak
6045: PPUSH
6046: CALL_OW 104
// exit ;
6050: GO 6073
// end ; if Un = Vsevolod then
6052: LD_VAR 0 1
6056: PUSH
6057: LD_EXP 11
6061: EQUAL
6062: IFFALSE 6073
// begin YouLost ( Sevi ) ;
6064: LD_STRING Sevi
6066: PPUSH
6067: CALL_OW 104
// exit ;
6071: GO 6073
// end ; end ;
6073: LD_VAR 0 2
6077: RET
// function mozny_prichod_yashina ; begin
6078: LD_INT 0
6080: PPUSH
// if not YashinZacal then
6081: LD_LOC 3
6085: NOT
6086: IFFALSE 6100
// begin YashinZacal = true ;
6088: LD_ADDR_LOC 3
6092: PUSH
6093: LD_INT 1
6095: ST_TO_ADDR
// yashin_start_timer ;
6096: CALL 13213 0 0
// end ; end ;
6100: LD_VAR 0 1
6104: RET
// export function rusove_BuildingComplete ( Un ) ; begin
6105: LD_INT 0
6107: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and ( GetBType ( Un ) in [ B_WORKSHOP , B_FACTORY ] ) then
6108: LD_VAR 0 1
6112: PPUSH
6113: CALL_OW 255
6117: PUSH
6118: LD_EXP 2
6122: EQUAL
6123: PUSH
6124: LD_VAR 0 1
6128: PPUSH
6129: CALL_OW 266
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 3
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: IN
6144: AND
6145: IFFALSE 6151
// begin mozny_prichod_yashina ;
6147: CALL 6078 0 0
// end ; end ;
6151: LD_VAR 0 2
6155: RET
// every 25 25$0 do
6156: GO 6158
6158: DISABLE
// begin mozny_prichod_yashina ;
6159: CALL 6078 0 0
// end ;
6163: END
// every 0 0$3 + 0 0$1.2 marked 2 do
6164: GO 6166
6166: DISABLE
// begin if not IsOK ( Vsevolod ) then
6167: LD_EXP 11
6171: PPUSH
6172: CALL_OW 302
6176: NOT
6177: IFFALSE 6182
// enable else
6179: ENABLE
6180: GO 6229
// begin DialogueOn ;
6182: CALL_OW 6
// dialog_SeviSaved ;
6186: CALL 21631 0 0
// SetSide ( Vsevolod , side_Ru ) ;
6190: LD_EXP 11
6194: PPUSH
6195: LD_EXP 2
6199: PPUSH
6200: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
6204: LD_EXP 23
6208: PPUSH
6209: LD_EXP 2
6213: PPUSH
6214: CALL_OW 235
// DialogueOff ;
6218: CALL_OW 7
// enable ( 3 ) ;
6222: LD_INT 3
6224: ENABLE_MARKED
// arabi_muzete_utocit ;
6225: CALL 10502 0 0
// end ; end ;
6229: END
// export function rusove_Contact ( Side1 , Side2 ) ; begin
6230: LD_INT 0
6232: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Ar ) ) or ( ( Side1 = side_Ar ) and ( Side2 = side_Ru ) ) then
6233: LD_VAR 0 1
6237: PUSH
6238: LD_EXP 2
6242: EQUAL
6243: PUSH
6244: LD_VAR 0 2
6248: PUSH
6249: LD_EXP 4
6253: EQUAL
6254: AND
6255: PUSH
6256: LD_VAR 0 1
6260: PUSH
6261: LD_EXP 4
6265: EQUAL
6266: PUSH
6267: LD_VAR 0 2
6271: PUSH
6272: LD_EXP 2
6276: EQUAL
6277: AND
6278: OR
6279: IFFALSE 6289
// VidelAraby = true ;
6281: LD_ADDR_LOC 2
6285: PUSH
6286: LD_INT 1
6288: ST_TO_ADDR
// end ;
6289: LD_VAR 0 3
6293: RET
// every 5 5$0 do
6294: GO 6296
6296: DISABLE
// begin ContactIn5Min = VidelAraby ;
6297: LD_ADDR_EXP 28
6301: PUSH
6302: LD_LOC 2
6306: ST_TO_ADDR
// end ;
6307: END
// every 30 30$0 do
6308: GO 6310
6310: DISABLE
// begin if Difficulty = 1 then
6311: LD_OWVAR 67
6315: PUSH
6316: LD_INT 1
6318: EQUAL
6319: IFFALSE 6330
// wait ( 15 15$0 ) else
6321: LD_INT 31500
6323: PPUSH
6324: CALL_OW 67
6328: GO 6347
// if Difficulty = 2 then
6330: LD_OWVAR 67
6334: PUSH
6335: LD_INT 2
6337: EQUAL
6338: IFFALSE 6347
// Wait ( 5 5$0 ) ;
6340: LD_INT 10500
6342: PPUSH
6343: CALL_OW 67
// PropaslQuickly = true ;
6347: LD_ADDR_EXP 29
6351: PUSH
6352: LD_INT 1
6354: ST_TO_ADDR
// end ;
6355: END
// every 2 2$35 marked 3 do
6356: GO 6358
6358: DISABLE
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
6359: LD_INT 35
6361: PPUSH
6362: LD_INT 1050
6364: PPUSH
6365: CALL_OW 12
6369: PPUSH
6370: CALL_OW 67
// xavier_start ;
6374: CALL 15217 0 0
// end ;
6378: END
// every 4 4$45 marked 4 do
6379: GO 6381
6381: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
6382: LD_INT 35
6384: PPUSH
6385: LD_INT 2100
6387: PPUSH
6388: CALL_OW 12
6392: PPUSH
6393: CALL_OW 67
// xavier_start ;
6397: CALL 15217 0 0
// end ; end_of_file
6401: END
// var Zniceno ; var Autaky ; var Obranci ; var VolnyLidi ; var Utok_Auta ; var Utok_ZbyvaMinut ; var CasyUtoku ; var VidelRusa ; var PstZbrane ; var ProbihaUtok ; var CisloUtoku ; var Patrola ; var PatrolaZrusena ; var Registry ; var RegUtok ; var MakroObrana ; var MakroUtok ; var MakroBunkry ; var MakroPresunZakladna ; var BeziStahovani ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var Miny ; var ProbihaOprava ; var ProbihaLeceni ; export function init_arabi ; var Kdo , Budovy ; begin
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
// disable ( 43 ) ;
6407: LD_INT 43
6409: DISABLE_MARKED
// disable ( 44 ) ;
6410: LD_INT 44
6412: DISABLE_MARKED
// disable ( 45 ) ;
6413: LD_INT 45
6415: DISABLE_MARKED
// disable ( 46 ) ;
6416: LD_INT 46
6418: DISABLE_MARKED
// disable ( 47 ) ;
6419: LD_INT 47
6421: DISABLE_MARKED
// SetBName ( ArDepot , newkabul ) ;
6422: LD_INT 3
6424: PPUSH
6425: LD_STRING newkabul
6427: PPUSH
6428: CALL_OW 500
// Autaky = [ ArTank1 , ArTank2 ] ;
6432: LD_ADDR_LOC 6
6436: PUSH
6437: LD_INT 12
6439: PUSH
6440: LD_INT 13
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: ST_TO_ADDR
// Patrola = [ ArTank1 ] ;
6447: LD_ADDR_LOC 16
6451: PUSH
6452: LD_INT 12
6454: PUSH
6455: EMPTY
6456: LIST
6457: ST_TO_ADDR
// Obranci = vytvor_obrance ;
6458: LD_ADDR_LOC 7
6462: PUSH
6463: CALL 7326 0 0
6467: ST_TO_ADDR
// place_list ( Obranci , AraboveParkoviste ) ;
6468: LD_LOC 7
6472: PPUSH
6473: LD_INT 18
6475: PPUSH
6476: CALL 20674 0 2
// Obranci = Obranci union [ ArSolBunk1 , ArSolBunk4 , ArSolBunk6 ] ;
6480: LD_ADDR_LOC 7
6484: PUSH
6485: LD_LOC 7
6489: PUSH
6490: LD_INT 39
6492: PUSH
6493: LD_INT 28
6495: PUSH
6496: LD_INT 31
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: LIST
6503: UNION
6504: ST_TO_ADDR
// VolnyLidi = vytvor_volny ;
6505: LD_ADDR_LOC 8
6509: PUSH
6510: CALL 7392 0 0
6514: ST_TO_ADDR
// place_list ( VolnyLidi , AraboveVolni ) ;
6515: LD_LOC 8
6519: PPUSH
6520: LD_INT 36
6522: PPUSH
6523: CALL 20674 0 2
// VolnyLidi = VolnyLidi union [ ArMech1 , ArMech2 ] ;
6527: LD_ADDR_LOC 8
6531: PUSH
6532: LD_LOC 8
6536: PUSH
6537: LD_INT 19
6539: PUSH
6540: LD_INT 20
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: UNION
6547: ST_TO_ADDR
// Utok_Auta = [ ] ;
6548: LD_ADDR_LOC 9
6552: PUSH
6553: EMPTY
6554: ST_TO_ADDR
// ArDalkar = 0 ;
6555: LD_ADDR_LOC 25
6559: PUSH
6560: LD_INT 0
6562: ST_TO_ADDR
// KolikDalkovych = 0 ;
6563: LD_ADDR_LOC 26
6567: PUSH
6568: LD_INT 0
6570: ST_TO_ADDR
// DelamDalkare = false ;
6571: LD_ADDR_LOC 27
6575: PUSH
6576: LD_INT 0
6578: ST_TO_ADDR
// Zniceno = false ;
6579: LD_ADDR_LOC 5
6583: PUSH
6584: LD_INT 0
6586: ST_TO_ADDR
// VidelRusa = false ;
6587: LD_ADDR_LOC 12
6591: PUSH
6592: LD_INT 0
6594: ST_TO_ADDR
// ProbihaUtok = false ;
6595: LD_ADDR_LOC 14
6599: PUSH
6600: LD_INT 0
6602: ST_TO_ADDR
// PatrolaZrusena = false ;
6603: LD_ADDR_LOC 17
6607: PUSH
6608: LD_INT 0
6610: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
6611: LD_ADDR_LOC 11
6615: PUSH
6616: LD_EXP 52
6620: PUSH
6621: LD_OWVAR 67
6625: ARRAY
6626: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
6627: LD_ADDR_LOC 13
6631: PUSH
6632: LD_EXP 51
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
6643: LD_ADDR_LOC 10
6647: PUSH
6648: LD_INT 1
6650: NEG
6651: ST_TO_ADDR
// CisloUtoku = 1 ;
6652: LD_ADDR_LOC 15
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// BeziStahovani = false ;
6660: LD_ADDR_LOC 24
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// ProbihaOprava = false ;
6668: LD_ADDR_LOC 29
6672: PUSH
6673: LD_INT 0
6675: ST_TO_ADDR
// ProbihaLeceni = false ;
6676: LD_ADDR_LOC 30
6680: PUSH
6681: LD_INT 0
6683: ST_TO_ADDR
// if Difficulty = 1 then
6684: LD_OWVAR 67
6688: PUSH
6689: LD_INT 1
6691: EQUAL
6692: IFFALSE 6722
// begin DestroyUnit ( ArObr2 ) ;
6694: LD_INT 46
6696: PPUSH
6697: CALL_OW 65
// DestroyUnit ( ArObrM1 ) ;
6701: LD_INT 47
6703: PPUSH
6704: CALL_OW 65
// DestroyUnit ( ArObr1 ) ;
6708: LD_INT 45
6710: PPUSH
6711: CALL_OW 65
// DestroyUnit ( ArObrM2 ) ;
6715: LD_INT 48
6717: PPUSH
6718: CALL_OW 65
// end ; lidi_do_budov ;
6722: CALL 7491 0 0
// Kdo = Obranci union [ ArMech1 , ArMech2 , ArTank1 , ArTank2 ] union [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ;
6726: LD_ADDR_VAR 0 2
6730: PUSH
6731: LD_LOC 7
6735: PUSH
6736: LD_INT 19
6738: PUSH
6739: LD_INT 20
6741: PUSH
6742: LD_INT 12
6744: PUSH
6745: LD_INT 13
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: UNION
6754: PUSH
6755: LD_INT 15
6757: PUSH
6758: LD_INT 25
6760: PUSH
6761: LD_INT 33
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: UNION
6769: ST_TO_ADDR
// if Difficulty > 1 then
6770: LD_OWVAR 67
6774: PUSH
6775: LD_INT 1
6777: GREATER
6778: IFFALSE 6809
// Kdo = Kdo union [ ArObr1 , ArObr2 , ArObrM1 , ArObrM2 ] ;
6780: LD_ADDR_VAR 0 2
6784: PUSH
6785: LD_VAR 0 2
6789: PUSH
6790: LD_INT 45
6792: PUSH
6793: LD_INT 46
6795: PUSH
6796: LD_INT 47
6798: PUSH
6799: LD_INT 48
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: UNION
6808: ST_TO_ADDR
// Kdo = Kdo diff [ Obranci [ 1 ] , Obranci [ 2 ] ] ;
6809: LD_ADDR_VAR 0 2
6813: PUSH
6814: LD_VAR 0 2
6818: PUSH
6819: LD_LOC 7
6823: PUSH
6824: LD_INT 1
6826: ARRAY
6827: PUSH
6828: LD_LOC 7
6832: PUSH
6833: LD_INT 2
6835: ARRAY
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: DIFF
6841: ST_TO_ADDR
// Registry = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , Obrana ] ] ) ;
6842: LD_ADDR_LOC 18
6846: PUSH
6847: LD_EXP 4
6851: PPUSH
6852: LD_INT 3
6854: PUSH
6855: LD_INT 37
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: PPUSH
6865: CALL_OW 399
6869: ST_TO_ADDR
// MakroBunkry = McCustom ( 20 , [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ) ;
6870: LD_ADDR_LOC 22
6874: PUSH
6875: LD_INT 20
6877: PPUSH
6878: LD_INT 15
6880: PUSH
6881: LD_INT 25
6883: PUSH
6884: LD_INT 33
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL_OW 416
6896: ST_TO_ADDR
// MakroObrana = McDefend ( 5 , Registry , Kdo union [ ArBunk1 , ArBunk3 , ArBunk4 , ArBunk5 ] , [ ] ) ;
6897: LD_ADDR_LOC 20
6901: PUSH
6902: LD_INT 5
6904: PPUSH
6905: LD_LOC 18
6909: PPUSH
6910: LD_VAR 0 2
6914: PUSH
6915: LD_INT 36
6917: PUSH
6918: LD_INT 26
6920: PUSH
6921: LD_INT 29
6923: PUSH
6924: LD_INT 40
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: UNION
6933: PPUSH
6934: EMPTY
6935: PPUSH
6936: CALL_OW 401
6940: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Kdo ) ;
6941: LD_ADDR_LOC 23
6945: PUSH
6946: LD_INT 1
6948: PPUSH
6949: LD_VAR 0 2
6953: PPUSH
6954: CALL_OW 416
6958: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , Rusove ] , MC_REG_IGNORE_FOG ] ) ;
6959: LD_ADDR_LOC 19
6963: PUSH
6964: LD_EXP 4
6968: PPUSH
6969: LD_INT 2
6971: PUSH
6972: LD_INT 40
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PUSH
6979: LD_INT 7
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: PPUSH
6986: CALL_OW 399
6990: ST_TO_ADDR
// init_miny ;
6991: CALL 7000 0 0
// end ;
6995: LD_VAR 0 1
6999: RET
// function init_miny ; var M ; begin
7000: LD_INT 0
7002: PPUSH
7003: PPUSH
// if Difficulty = 1 then
7004: LD_OWVAR 67
7008: PUSH
7009: LD_INT 1
7011: EQUAL
7012: IFFALSE 7023
// Miny = [ ] else
7014: LD_ADDR_LOC 28
7018: PUSH
7019: EMPTY
7020: ST_TO_ADDR
7021: GO 7231
// begin Miny = [ [ 62 , 14 ] , [ 64 , 17 ] , [ 66 , 17 ] , [ 65 , 12 ] , [ 68 , 15 ] , [ 64 , 14 ] , [ 60 , 5 ] , [ 60 , 15 ] , [ 59 , 18 ] , [ 56 , 16 ] , [ 49 , 15 ] , [ 33 , 18 ] , [ 42 , 42 ] , [ 112 , 42 ] ] ;
7023: LD_ADDR_LOC 28
7027: PUSH
7028: LD_INT 62
7030: PUSH
7031: LD_INT 14
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 64
7040: PUSH
7041: LD_INT 17
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 66
7050: PUSH
7051: LD_INT 17
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 65
7060: PUSH
7061: LD_INT 12
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PUSH
7068: LD_INT 68
7070: PUSH
7071: LD_INT 15
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PUSH
7078: LD_INT 64
7080: PUSH
7081: LD_INT 14
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 60
7090: PUSH
7091: LD_INT 5
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 60
7100: PUSH
7101: LD_INT 15
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PUSH
7108: LD_INT 59
7110: PUSH
7111: LD_INT 18
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: PUSH
7118: LD_INT 56
7120: PUSH
7121: LD_INT 16
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 49
7130: PUSH
7131: LD_INT 15
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 18
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 42
7150: PUSH
7151: LD_INT 42
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: LD_INT 112
7160: PUSH
7161: LD_INT 42
7163: PUSH
7164: EMPTY
7165: LIST
7166: LIST
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: ST_TO_ADDR
// for M in Miny do
7184: LD_ADDR_VAR 0 2
7188: PUSH
7189: LD_LOC 28
7193: PUSH
7194: FOR_IN
7195: IFFALSE 7229
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
7197: LD_VAR 0 2
7201: PUSH
7202: LD_INT 1
7204: ARRAY
7205: PPUSH
7206: LD_VAR 0 2
7210: PUSH
7211: LD_INT 2
7213: ARRAY
7214: PPUSH
7215: LD_EXP 4
7219: PPUSH
7220: LD_INT 0
7222: PPUSH
7223: CALL_OW 454
7227: GO 7194
7229: POP
7230: POP
// end ; end ;
7231: LD_VAR 0 1
7235: RET
// function vytvor_cloveka ( Cls ) ; begin
7236: LD_INT 0
7238: PPUSH
// UC_Side = side_Ar ;
7239: LD_ADDR_OWVAR 20
7243: PUSH
7244: LD_EXP 4
7248: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
7249: LD_ADDR_OWVAR 21
7253: PUSH
7254: LD_INT 2
7256: ST_TO_ADDR
// HC_Sex = Rand ( 1 , 2 ) ;
7257: LD_ADDR_OWVAR 27
7261: PUSH
7262: LD_INT 1
7264: PPUSH
7265: LD_INT 2
7267: PPUSH
7268: CALL_OW 12
7272: ST_TO_ADDR
// HC_Class = Cls ;
7273: LD_ADDR_OWVAR 28
7277: PUSH
7278: LD_VAR 0 1
7282: ST_TO_ADDR
// HC_Name =  ;
7283: LD_ADDR_OWVAR 26
7287: PUSH
7288: LD_STRING 
7290: ST_TO_ADDR
// PrepareClassSkills ( Cls , dif_ArabiLevel [ Difficulty ] ) ;
7291: LD_VAR 0 1
7295: PPUSH
7296: LD_EXP 47
7300: PUSH
7301: LD_OWVAR 67
7305: ARRAY
7306: PPUSH
7307: CALL_OW 374
// Result = CreateHuman ;
7311: LD_ADDR_VAR 0 2
7315: PUSH
7316: CALL_OW 44
7320: ST_TO_ADDR
// end ;
7321: LD_VAR 0 2
7325: RET
// function vytvor_obrance ; var I ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
// Result = [ ] ;
7330: LD_ADDR_VAR 0 1
7334: PUSH
7335: EMPTY
7336: ST_TO_ADDR
// for I = 1 to dif_ObranciArabi [ Difficulty ] do
7337: LD_ADDR_VAR 0 2
7341: PUSH
7342: DOUBLE
7343: LD_INT 1
7345: DEC
7346: ST_TO_ADDR
7347: LD_EXP 49
7351: PUSH
7352: LD_OWVAR 67
7356: ARRAY
7357: PUSH
7358: FOR_TO
7359: IFFALSE 7385
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] ;
7361: LD_ADDR_VAR 0 1
7365: PUSH
7366: LD_VAR 0 1
7370: PUSH
7371: LD_INT 1
7373: PPUSH
7374: CALL 7236 0 1
7378: PUSH
7379: EMPTY
7380: LIST
7381: UNION
7382: ST_TO_ADDR
7383: GO 7358
7385: POP
7386: POP
// end ;
7387: LD_VAR 0 1
7391: RET
// function vytvor_volny ; var I ; begin
7392: LD_INT 0
7394: PPUSH
7395: PPUSH
// Result = [ ] ;
7396: LD_ADDR_VAR 0 1
7400: PUSH
7401: EMPTY
7402: ST_TO_ADDR
// for I = 1 to dif_VolnyArabi [ Difficulty ] do
7403: LD_ADDR_VAR 0 2
7407: PUSH
7408: DOUBLE
7409: LD_INT 1
7411: DEC
7412: ST_TO_ADDR
7413: LD_EXP 48
7417: PUSH
7418: LD_OWVAR 67
7422: ARRAY
7423: PUSH
7424: FOR_TO
7425: IFFALSE 7484
// if Prob ( 25 ) then
7427: LD_INT 25
7429: PPUSH
7430: CALL_OW 13
7434: IFFALSE 7460
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] else
7436: LD_ADDR_VAR 0 1
7440: PUSH
7441: LD_VAR 0 1
7445: PUSH
7446: LD_INT 1
7448: PPUSH
7449: CALL 7236 0 1
7453: PUSH
7454: EMPTY
7455: LIST
7456: UNION
7457: ST_TO_ADDR
7458: GO 7482
// Result = Result union [ vytvor_cloveka ( CLASS_MECHANIC ) ] ;
7460: LD_ADDR_VAR 0 1
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: PPUSH
7473: CALL 7236 0 1
7477: PUSH
7478: EMPTY
7479: LIST
7480: UNION
7481: ST_TO_ADDR
7482: GO 7424
7484: POP
7485: POP
// end ;
7486: LD_VAR 0 1
7490: RET
// function lidi_do_budov ; begin
7491: LD_INT 0
7493: PPUSH
// ComEnterUnit ( ArMech1 , ArTank1 ) ;
7494: LD_INT 19
7496: PPUSH
7497: LD_INT 12
7499: PPUSH
7500: CALL_OW 120
// ComEnterUnit ( ArMech , ArFact ) ;
7504: LD_INT 21
7506: PPUSH
7507: LD_INT 4
7509: PPUSH
7510: CALL_OW 120
// ComEnterUnit ( ArSolPBunk1 , ArPBunk1 ) ;
7514: LD_INT 15
7516: PPUSH
7517: LD_INT 2
7519: PPUSH
7520: CALL_OW 120
// ComEnterUnit ( ArSolPBunk2 , ArPBunk2 ) ;
7524: LD_INT 25
7526: PPUSH
7527: LD_INT 1
7529: PPUSH
7530: CALL_OW 120
// if Difficulty < 3 then
7534: LD_OWVAR 67
7538: PUSH
7539: LD_INT 3
7541: LESS
7542: IFFALSE 7554
// SetClass ( ArSolPBunk3 , CLASS_SOLDIER ) ;
7544: LD_INT 33
7546: PPUSH
7547: LD_INT 1
7549: PPUSH
7550: CALL_OW 336
// if Difficulty > 1 then
7554: LD_OWVAR 67
7558: PUSH
7559: LD_INT 1
7561: GREATER
7562: IFFALSE 7584
// begin ComEnterUnit ( ArObrM1 , ArObr1 ) ;
7564: LD_INT 47
7566: PPUSH
7567: LD_INT 45
7569: PPUSH
7570: CALL_OW 120
// ComEnterUnit ( ArObrM2 , ArObr2 ) ;
7574: LD_INT 48
7576: PPUSH
7577: LD_INT 46
7579: PPUSH
7580: CALL_OW 120
// end ; ComEnterUnit ( ArSolPBunk3 , ArPBunk3 ) ;
7584: LD_INT 33
7586: PPUSH
7587: LD_INT 32
7589: PPUSH
7590: CALL_OW 120
// ComEnterUnit ( ArSolRadar , ArRadar ) ;
7594: LD_INT 38
7596: PPUSH
7597: LD_INT 37
7599: PPUSH
7600: CALL_OW 120
// ComEnterUnit ( ArSolBunk1 , ArBunk1 ) ;
7604: LD_INT 39
7606: PPUSH
7607: LD_INT 36
7609: PPUSH
7610: CALL_OW 120
// ComEnterUnit ( ArSolBunk4 , ArBunk4 ) ;
7614: LD_INT 28
7616: PPUSH
7617: LD_INT 29
7619: PPUSH
7620: CALL_OW 120
// ComEnterUnit ( ArSolBunk6 , ArBunk6 ) ;
7624: LD_INT 31
7626: PPUSH
7627: LD_INT 41
7629: PPUSH
7630: CALL_OW 120
// ComEnterUnit ( ArSci1 , ArLab1 ) ;
7634: LD_INT 17
7636: PPUSH
7637: LD_INT 6
7639: PPUSH
7640: CALL_OW 120
// ComEnterUnit ( ArSci2 , ArLab2 ) ;
7644: LD_INT 18
7646: PPUSH
7647: LD_INT 24
7649: PPUSH
7650: CALL_OW 120
// end ;
7654: LD_VAR 0 1
7658: RET
// function kontrola_zniceno ; var Jednotky ; begin
7659: LD_INT 0
7661: PPUSH
7662: PPUSH
// if not Zniceno then
7663: LD_LOC 5
7667: NOT
7668: IFFALSE 7727
// begin Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] ] ) ;
7670: LD_ADDR_VAR 0 2
7674: PUSH
7675: LD_INT 22
7677: PUSH
7678: LD_EXP 4
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 50
7689: PUSH
7690: EMPTY
7691: LIST
7692: PUSH
7693: LD_INT 52
7695: PUSH
7696: EMPTY
7697: LIST
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: PPUSH
7704: CALL_OW 69
7708: ST_TO_ADDR
// if not Jednotky then
7709: LD_VAR 0 2
7713: NOT
7714: IFFALSE 7727
// begin Zniceno = true ;
7716: LD_ADDR_LOC 5
7720: PUSH
7721: LD_INT 1
7723: ST_TO_ADDR
// disable ( 43 ) ;
7724: LD_INT 43
7726: DISABLE_MARKED
// end ; end ; end ;
7727: LD_VAR 0 1
7731: RET
// function vyber_zbran ; var P ; begin
7732: LD_INT 0
7734: PPUSH
7735: PPUSH
// P = Rand ( 1 , 100 ) ;
7736: LD_ADDR_VAR 0 2
7740: PUSH
7741: LD_INT 1
7743: PPUSH
7744: LD_INT 100
7746: PPUSH
7747: CALL_OW 12
7751: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
7752: LD_VAR 0 2
7756: PUSH
7757: LD_LOC 13
7761: PUSH
7762: LD_INT 1
7764: ARRAY
7765: LESS
7766: IFFALSE 7778
// Result = AR_FLAME_THROWER else
7768: LD_ADDR_VAR 0 1
7772: PUSH
7773: LD_INT 26
7775: ST_TO_ADDR
7776: GO 7838
// if P < PstZbrane [ 2 ] then
7778: LD_VAR 0 2
7782: PUSH
7783: LD_LOC 13
7787: PUSH
7788: LD_INT 2
7790: ARRAY
7791: LESS
7792: IFFALSE 7804
// Result = AR_GUN else
7794: LD_ADDR_VAR 0 1
7798: PUSH
7799: LD_INT 27
7801: ST_TO_ADDR
7802: GO 7838
// if P < PstZbrane [ 3 ] then
7804: LD_VAR 0 2
7808: PUSH
7809: LD_LOC 13
7813: PUSH
7814: LD_INT 3
7816: ARRAY
7817: LESS
7818: IFFALSE 7830
// Result = AR_DOUBLE_MACHINE_GUN else
7820: LD_ADDR_VAR 0 1
7824: PUSH
7825: LD_INT 24
7827: ST_TO_ADDR
7828: GO 7838
// Result = AR_ROCKET_LAUNCHER ;
7830: LD_ADDR_VAR 0 1
7834: PUSH
7835: LD_INT 28
7837: ST_TO_ADDR
// end ;
7838: LD_VAR 0 1
7842: RET
// function vyber_ovladani ; begin
7843: LD_INT 0
7845: PPUSH
// Result = CONTROL_MANUAL ;
7846: LD_ADDR_VAR 0 1
7850: PUSH
7851: LD_INT 1
7853: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
7854: LD_LOC 25
7858: NOT
7859: PUSH
7860: LD_LOC 25
7864: PPUSH
7865: CALL_OW 302
7869: NOT
7870: OR
7871: IFFALSE 7875
// exit ;
7873: GO 7923
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
7875: LD_INT 42
7877: NOT
7878: PUSH
7879: LD_INT 42
7881: PPUSH
7882: CALL_OW 302
7886: NOT
7887: OR
7888: IFFALSE 7892
// exit ;
7890: GO 7923
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
7892: LD_INT 42
7894: PPUSH
7895: CALL_OW 432
7899: PUSH
7900: LD_INT 42
7902: PPUSH
7903: LD_INT 3
7905: PPUSH
7906: CALL_OW 259
7910: GREATEREQUAL
7911: IFFALSE 7915
// exit ;
7913: GO 7923
// Result = CONTROL_REMOTE ;
7915: LD_ADDR_VAR 0 1
7919: PUSH
7920: LD_INT 2
7922: ST_TO_ADDR
// end ;
7923: LD_VAR 0 1
7927: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
7928: LD_INT 0
7930: PPUSH
7931: PPUSH
7932: PPUSH
7933: PPUSH
7934: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
7935: LD_INT 4
7937: PPUSH
7938: CALL_OW 302
7942: NOT
7943: PUSH
7944: LD_INT 4
7946: PPUSH
7947: CALL_OW 314
7951: OR
7952: IFFALSE 7956
// exit ;
7954: GO 8268
// if GetSide ( ArFact ) <> side_Ar then
7956: LD_INT 4
7958: PPUSH
7959: CALL_OW 255
7963: PUSH
7964: LD_EXP 4
7968: NONEQUAL
7969: IFFALSE 7973
// exit ;
7971: GO 8268
// if not UnitsInside ( ArFact ) then
7973: LD_INT 4
7975: PPUSH
7976: CALL_OW 313
7980: NOT
7981: IFFALSE 7985
// exit ;
7983: GO 8268
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
7985: LD_INT 15
7987: PPUSH
7988: LD_EXP 4
7992: PPUSH
7993: CALL_OW 321
7997: PUSH
7998: LD_INT 2
8000: EQUAL
8001: PUSH
8002: LD_LOC 25
8006: NOT
8007: AND
8008: PUSH
8009: LD_LOC 27
8013: NOT
8014: AND
8015: PUSH
8016: LD_INT 75
8018: PPUSH
8019: CALL_OW 13
8023: AND
8024: IFFALSE 8052
// begin Chassis = AR_MEDIUM_TRIKE ;
8026: LD_ADDR_VAR 0 3
8030: PUSH
8031: LD_INT 13
8033: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
8034: LD_ADDR_VAR 0 4
8038: PUSH
8039: LD_INT 31
8041: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
8042: LD_ADDR_VAR 0 5
8046: PUSH
8047: LD_INT 1
8049: ST_TO_ADDR
// end else
8050: GO 8099
// begin if Prob ( 50 ) then
8052: LD_INT 50
8054: PPUSH
8055: CALL_OW 13
8059: IFFALSE 8071
// Chassis = AR_MEDIUM_TRIKE else
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: LD_INT 13
8068: ST_TO_ADDR
8069: GO 8079
// Chassis = AR_HALF_TRACKED ;
8071: LD_ADDR_VAR 0 3
8075: PUSH
8076: LD_INT 14
8078: ST_TO_ADDR
// Weapon = vyber_zbran ;
8079: LD_ADDR_VAR 0 4
8083: PUSH
8084: CALL 7732 0 0
8088: ST_TO_ADDR
// Control = vyber_ovladani ;
8089: LD_ADDR_VAR 0 5
8093: PUSH
8094: CALL 7843 0 0
8098: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) then
8099: LD_INT 4
8101: PPUSH
8102: LD_VAR 0 3
8106: PPUSH
8107: LD_INT 1
8109: PPUSH
8110: LD_VAR 0 5
8114: PPUSH
8115: LD_VAR 0 4
8119: PPUSH
8120: CALL_OW 448
8124: NOT
8125: IFFALSE 8169
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_COMBUSTION , Control , AR_LIGHT_GUN ) then
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 12
8132: PPUSH
8133: LD_INT 1
8135: PPUSH
8136: LD_VAR 0 5
8140: PPUSH
8141: LD_INT 23
8143: PPUSH
8144: CALL_OW 448
8148: NOT
8149: IFFALSE 8153
// exit ;
8151: GO 8268
// Chassis = AR_LIGHT_TRIKE ;
8153: LD_ADDR_VAR 0 3
8157: PUSH
8158: LD_INT 12
8160: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
8161: LD_ADDR_VAR 0 4
8165: PUSH
8166: LD_INT 23
8168: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
8169: LD_ADDR_VAR 0 2
8173: PUSH
8174: LD_INT 4
8176: PPUSH
8177: CALL_OW 274
8181: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
8182: LD_VAR 0 2
8186: PPUSH
8187: LD_INT 1
8189: PPUSH
8190: CALL_OW 275
8194: PUSH
8195: LD_INT 120
8197: LESS
8198: IFFALSE 8202
// exit ;
8200: GO 8268
// if GetResourceType ( Base , MAT_OIL ) < 50 then
8202: LD_VAR 0 2
8206: PPUSH
8207: LD_INT 2
8209: PPUSH
8210: CALL_OW 275
8214: PUSH
8215: LD_INT 50
8217: LESS
8218: IFFALSE 8222
// exit ;
8220: GO 8268
// AddComConstruct ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) ;
8222: LD_INT 4
8224: PPUSH
8225: LD_VAR 0 3
8229: PPUSH
8230: LD_INT 1
8232: PPUSH
8233: LD_VAR 0 5
8237: PPUSH
8238: LD_VAR 0 4
8242: PPUSH
8243: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
8247: LD_VAR 0 4
8251: PUSH
8252: LD_INT 31
8254: EQUAL
8255: IFFALSE 8268
// begin DelamDalkare = true ;
8257: LD_ADDR_LOC 27
8261: PUSH
8262: LD_INT 1
8264: ST_TO_ADDR
// enable ( 47 ) ;
8265: LD_INT 47
8267: ENABLE_MARKED
// end ; end ;
8268: LD_VAR 0 1
8272: RET
// every 5 5$1 marked 47 do
8273: GO 8275
8275: DISABLE
// begin if not ArDalkar then
8276: LD_LOC 25
8280: NOT
8281: IFFALSE 8291
// DelamDalkare = false ;
8283: LD_ADDR_LOC 27
8287: PUSH
8288: LD_INT 0
8290: ST_TO_ADDR
// end ;
8291: END
// function zacni_vynalezat ; begin
8292: LD_INT 0
8294: PPUSH
// AddComResearch ( ArLab1 , TECH_GUN ) ;
8295: LD_INT 6
8297: PPUSH
8298: LD_INT 39
8300: PPUSH
8301: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_FLAME ) ;
8305: LD_INT 6
8307: PPUSH
8308: LD_INT 70
8310: PPUSH
8311: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_ROCKET ) ;
8315: LD_INT 6
8317: PPUSH
8318: LD_INT 40
8320: PPUSH
8321: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_GATLING ) ;
8325: LD_INT 6
8327: PPUSH
8328: LD_INT 69
8330: PPUSH
8331: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_STIMDRUGS ) ;
8335: LD_INT 6
8337: PPUSH
8338: LD_INT 5
8340: PPUSH
8341: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_EXPLOS ) ;
8345: LD_INT 6
8347: PPUSH
8348: LD_INT 42
8350: PPUSH
8351: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_SELFDEST ) ;
8355: LD_INT 6
8357: PPUSH
8358: LD_INT 43
8360: PPUSH
8361: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP1 ) ;
8365: LD_INT 6
8367: PPUSH
8368: LD_INT 51
8370: PPUSH
8371: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP2 ) ;
8375: LD_INT 6
8377: PPUSH
8378: LD_INT 52
8380: PPUSH
8381: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8385: LD_INT 6
8387: PPUSH
8388: LD_INT 67
8390: PPUSH
8391: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8395: LD_INT 6
8397: PPUSH
8398: LD_INT 67
8400: PPUSH
8401: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_RADAR ) ;
8405: LD_INT 24
8407: PPUSH
8408: LD_INT 6
8410: PPUSH
8411: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_REMCONT ) ;
8415: LD_INT 24
8417: PPUSH
8418: LD_INT 15
8420: PPUSH
8421: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_MATDET ) ;
8425: LD_INT 24
8427: PPUSH
8428: LD_INT 7
8430: PPUSH
8431: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH1 ) ;
8435: LD_INT 24
8437: PPUSH
8438: LD_INT 48
8440: PPUSH
8441: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH2 ) ;
8445: LD_INT 24
8447: PPUSH
8448: LD_INT 49
8450: PPUSH
8451: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_SIBDET ) ;
8455: LD_INT 24
8457: PPUSH
8458: LD_INT 20
8460: PPUSH
8461: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO1 ) ;
8465: LD_INT 24
8467: PPUSH
8468: LD_INT 60
8470: PPUSH
8471: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO2 ) ;
8475: LD_INT 24
8477: PPUSH
8478: LD_INT 61
8480: PPUSH
8481: CALL_OW 184
// end ;
8485: LD_VAR 0 1
8489: RET
// function zacni_utok ; begin
8490: LD_INT 0
8492: PPUSH
// ProbihaUtok = true ;
8493: LD_ADDR_LOC 14
8497: PUSH
8498: LD_INT 1
8500: ST_TO_ADDR
// MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8501: LD_ADDR_LOC 21
8505: PUSH
8506: LD_INT 10
8508: PPUSH
8509: LD_LOC 19
8513: PPUSH
8514: LD_LOC 9
8518: PPUSH
8519: LD_INT 7
8521: PUSH
8522: LD_INT 18
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 8
8531: PUSH
8532: LD_INT 18
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: LD_INT 5
8541: PUSH
8542: LD_INT 10
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 6
8551: PUSH
8552: LD_INT 10
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: PPUSH
8565: CALL_OW 402
8569: ST_TO_ADDR
// end ;
8570: LD_VAR 0 1
8574: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
8575: LD_INT 0
8577: PPUSH
8578: PPUSH
8579: PPUSH
8580: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_EXP 50
8590: PUSH
8591: LD_OWVAR 67
8595: ARRAY
8596: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
8597: LD_ADDR_VAR 0 3
8601: PUSH
8602: LD_INT 1
8604: PPUSH
8605: LD_INT 100
8607: PPUSH
8608: CALL_OW 12
8612: ST_TO_ADDR
// if ( I < 25 ) then
8613: LD_VAR 0 3
8617: PUSH
8618: LD_INT 25
8620: LESS
8621: IFFALSE 8639
// KolikChci = KolikChci - 1 else
8623: LD_ADDR_VAR 0 2
8627: PUSH
8628: LD_VAR 0 2
8632: PUSH
8633: LD_INT 1
8635: MINUS
8636: ST_TO_ADDR
8637: GO 8673
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
8639: LD_VAR 0 3
8643: PUSH
8644: LD_INT 75
8646: GREATER
8647: PUSH
8648: LD_LOC 15
8652: PUSH
8653: LD_INT 1
8655: GREATER
8656: AND
8657: IFFALSE 8673
// KolikChci = KolikChci + 1 ;
8659: LD_ADDR_VAR 0 2
8663: PUSH
8664: LD_VAR 0 2
8668: PUSH
8669: LD_INT 1
8671: PLUS
8672: ST_TO_ADDR
// Riditelne = [ ] ;
8673: LD_ADDR_VAR 0 4
8677: PUSH
8678: EMPTY
8679: ST_TO_ADDR
// for I in Autaky diff Patrola do
8680: LD_ADDR_VAR 0 3
8684: PUSH
8685: LD_LOC 6
8689: PUSH
8690: LD_LOC 16
8694: DIFF
8695: PUSH
8696: FOR_IN
8697: IFFALSE 8783
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
8699: LD_VAR 0 3
8703: PPUSH
8704: CALL_OW 263
8708: PUSH
8709: LD_INT 1
8711: EQUAL
8712: PUSH
8713: LD_VAR 0 3
8717: PPUSH
8718: CALL_OW 311
8722: NOT
8723: AND
8724: IFFALSE 8728
// continue ;
8726: GO 8696
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
8728: LD_VAR 0 3
8732: PPUSH
8733: CALL_OW 264
8737: PUSH
8738: LD_INT 31
8740: EQUAL
8741: IFFALSE 8745
// continue ;
8743: GO 8696
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
8745: LD_VAR 0 3
8749: PPUSH
8750: CALL_OW 256
8754: PUSH
8755: LD_INT 1000
8757: LESS
8758: IFFALSE 8762
// continue ;
8760: GO 8696
// Riditelne = Riditelne union [ I ] ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_VAR 0 4
8771: PUSH
8772: LD_VAR 0 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: UNION
8780: ST_TO_ADDR
// end ;
8781: GO 8696
8783: POP
8784: POP
// if Riditelne >= KolikChci then
8785: LD_VAR 0 4
8789: PUSH
8790: LD_VAR 0 2
8794: GREATEREQUAL
8795: IFFALSE 8850
// begin Result = [ ] ;
8797: LD_ADDR_VAR 0 1
8801: PUSH
8802: EMPTY
8803: ST_TO_ADDR
// for I = 1 to KolikChci do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_VAR 0 2
8818: PUSH
8819: FOR_TO
8820: IFFALSE 8846
// Result = Result union Riditelne [ I ] ;
8822: LD_ADDR_VAR 0 1
8826: PUSH
8827: LD_VAR 0 1
8831: PUSH
8832: LD_VAR 0 4
8836: PUSH
8837: LD_VAR 0 3
8841: ARRAY
8842: UNION
8843: ST_TO_ADDR
8844: GO 8819
8846: POP
8847: POP
// end else
8848: GO 8857
// Result = [ ] ;
8850: LD_ADDR_VAR 0 1
8854: PUSH
8855: EMPTY
8856: ST_TO_ADDR
// end ;
8857: LD_VAR 0 1
8861: RET
// function vrat_utok ; var I ; begin
8862: LD_INT 0
8864: PPUSH
8865: PPUSH
// ProbihaUtok = false ;
8866: LD_ADDR_LOC 14
8870: PUSH
8871: LD_INT 0
8873: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
8874: LD_ADDR_LOC 15
8878: PUSH
8879: LD_LOC 15
8883: PUSH
8884: LD_INT 1
8886: PLUS
8887: ST_TO_ADDR
// MakroUtok = 0 ;
8888: LD_ADDR_LOC 21
8892: PUSH
8893: LD_INT 0
8895: ST_TO_ADDR
// AddComMoveUnit ( Utok_Auta , ArDepot ) ;
8896: LD_LOC 9
8900: PPUSH
8901: LD_INT 3
8903: PPUSH
8904: CALL_OW 172
// AddComMoveToArea ( Utok_Auta , AraboveParkoviste ) ;
8908: LD_LOC 9
8912: PPUSH
8913: LD_INT 18
8915: PPUSH
8916: CALL_OW 173
// end ;
8920: LD_VAR 0 1
8924: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
8925: LD_INT 0
8927: PPUSH
// vrat_utok ;
8928: CALL 8862 0 0
// end ;
8932: LD_VAR 0 3
8936: RET
// function oprava_utok ; var JsouOK , JsouTam , Auto , Task , Budova ; begin
8937: LD_INT 0
8939: PPUSH
8940: PPUSH
8941: PPUSH
8942: PPUSH
8943: PPUSH
8944: PPUSH
// JsouOK = false ;
8945: LD_ADDR_VAR 0 2
8949: PUSH
8950: LD_INT 0
8952: ST_TO_ADDR
// JsouTam = true ;
8953: LD_ADDR_VAR 0 3
8957: PUSH
8958: LD_INT 1
8960: ST_TO_ADDR
// Task = false ;
8961: LD_ADDR_VAR 0 5
8965: PUSH
8966: LD_INT 0
8968: ST_TO_ADDR
// for Auto in Utok_Auta do
8969: LD_ADDR_VAR 0 4
8973: PUSH
8974: LD_LOC 9
8978: PUSH
8979: FOR_IN
8980: IFFALSE 9045
// begin if IsOK ( Auto ) then
8982: LD_VAR 0 4
8986: PPUSH
8987: CALL_OW 302
8991: IFFALSE 9043
// begin JsouOK = true ;
8993: LD_ADDR_VAR 0 2
8997: PUSH
8998: LD_INT 1
9000: ST_TO_ADDR
// if not IsInArea ( Auto , ArabskaBaze ) then
9001: LD_VAR 0 4
9005: PPUSH
9006: LD_INT 14
9008: PPUSH
9009: CALL_OW 308
9013: NOT
9014: IFFALSE 9024
// JsouTam = false ;
9016: LD_ADDR_VAR 0 3
9020: PUSH
9021: LD_INT 0
9023: ST_TO_ADDR
// if HasTask ( Auto ) then
9024: LD_VAR 0 4
9028: PPUSH
9029: CALL_OW 314
9033: IFFALSE 9043
// Task = true ;
9035: LD_ADDR_VAR 0 5
9039: PUSH
9040: LD_INT 1
9042: ST_TO_ADDR
// end ; end ;
9043: GO 8979
9045: POP
9046: POP
// if not Utok_Auta or not JsouOK then
9047: LD_LOC 9
9051: NOT
9052: PUSH
9053: LD_VAR 0 2
9057: NOT
9058: OR
9059: IFFALSE 9071
// begin Result = true ;
9061: LD_ADDR_VAR 0 1
9065: PUSH
9066: LD_INT 1
9068: ST_TO_ADDR
// exit ;
9069: GO 9216
// end ; if ( not JsouTam ) or Task then
9071: LD_VAR 0 3
9075: NOT
9076: PUSH
9077: LD_VAR 0 5
9081: OR
9082: IFFALSE 9094
// begin Result = false ;
9084: LD_ADDR_VAR 0 1
9088: PUSH
9089: LD_INT 0
9091: ST_TO_ADDR
// exit ;
9092: GO 9216
// end ; Result = true ;
9094: LD_ADDR_VAR 0 1
9098: PUSH
9099: LD_INT 1
9101: ST_TO_ADDR
// if not IsOK ( ArMech ) then
9102: LD_INT 21
9104: PPUSH
9105: CALL_OW 302
9109: NOT
9110: IFFALSE 9114
// exit ;
9112: GO 9216
// Budova = IsInUnit ( ArMech ) ;
9114: LD_ADDR_VAR 0 6
9118: PUSH
9119: LD_INT 21
9121: PPUSH
9122: CALL_OW 310
9126: ST_TO_ADDR
// if ( Budova <> ArFact ) and ( Budova <> 0 ) then
9127: LD_VAR 0 6
9131: PUSH
9132: LD_INT 4
9134: NONEQUAL
9135: PUSH
9136: LD_VAR 0 6
9140: PUSH
9141: LD_INT 0
9143: NONEQUAL
9144: AND
9145: IFFALSE 9149
// exit ;
9147: GO 9216
// ComExitBuilding ( ArMech ) ;
9149: LD_INT 21
9151: PPUSH
9152: CALL_OW 122
// Wait ( 0 0$1.3 ) ;
9156: LD_INT 46
9158: PPUSH
9159: CALL_OW 67
// for Auto in Utok_Auta do
9163: LD_ADDR_VAR 0 4
9167: PUSH
9168: LD_LOC 9
9172: PUSH
9173: FOR_IN
9174: IFFALSE 9204
// begin if IsInArea ( Auto , ArabskaBaze ) then
9176: LD_VAR 0 4
9180: PPUSH
9181: LD_INT 14
9183: PPUSH
9184: CALL_OW 308
9188: IFFALSE 9202
// AddComRepairVehicle ( ArMech , Auto ) ;
9190: LD_INT 21
9192: PPUSH
9193: LD_VAR 0 4
9197: PPUSH
9198: CALL_OW 189
// end ;
9202: GO 9173
9204: POP
9205: POP
// AddComEnterUnit ( ArMech , ArFact ) ;
9206: LD_INT 21
9208: PPUSH
9209: LD_INT 4
9211: PPUSH
9212: CALL_OW 180
// end ;
9216: LD_VAR 0 1
9220: RET
// function zjisti_cas_utoku ; begin
9221: LD_INT 0
9223: PPUSH
// if CasyUtoku then
9224: LD_LOC 11
9228: IFFALSE 9274
// begin Result = CasyUtoku [ 1 ] ;
9230: LD_ADDR_VAR 0 1
9234: PUSH
9235: LD_LOC 11
9239: PUSH
9240: LD_INT 1
9242: ARRAY
9243: ST_TO_ADDR
// if CasyUtoku > 1 then
9244: LD_LOC 11
9248: PUSH
9249: LD_INT 1
9251: GREATER
9252: IFFALSE 9272
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
9254: LD_ADDR_LOC 11
9258: PUSH
9259: LD_LOC 11
9263: PPUSH
9264: LD_INT 1
9266: PPUSH
9267: CALL_OW 3
9271: ST_TO_ADDR
// end else
9272: GO 9282
// Result = 5 ;
9274: LD_ADDR_VAR 0 1
9278: PUSH
9279: LD_INT 5
9281: ST_TO_ADDR
// end ;
9282: LD_VAR 0 1
9286: RET
// function utoceni_splneny_predpoklady ; begin
9287: LD_INT 0
9289: PPUSH
// Result = VidelRusa or ( Minuty > 15 ) ;
9290: LD_ADDR_VAR 0 1
9294: PUSH
9295: LD_LOC 12
9299: PUSH
9300: LD_EXP 30
9304: PUSH
9305: LD_INT 15
9307: GREATER
9308: OR
9309: ST_TO_ADDR
// if Prob ( 25 ) then
9310: LD_INT 25
9312: PPUSH
9313: CALL_OW 13
9317: IFFALSE 9327
// Result = false ;
9319: LD_ADDR_VAR 0 1
9323: PUSH
9324: LD_INT 0
9326: ST_TO_ADDR
// end ;
9327: LD_VAR 0 1
9331: RET
// function casovac_utok ; begin
9332: LD_INT 0
9334: PPUSH
// if ProbihaUtok then
9335: LD_LOC 14
9339: IFFALSE 9343
// exit ;
9341: GO 9442
// if Utok_ZbyvaMinut = - 1 then
9343: LD_LOC 10
9347: PUSH
9348: LD_INT 1
9350: NEG
9351: EQUAL
9352: IFFALSE 9364
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9354: LD_ADDR_LOC 10
9358: PUSH
9359: CALL 9221 0 0
9363: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
9364: LD_LOC 10
9368: PUSH
9369: LD_INT 0
9371: GREATER
9372: IFFALSE 9388
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
9374: LD_ADDR_LOC 10
9378: PUSH
9379: LD_LOC 10
9383: PUSH
9384: LD_INT 1
9386: MINUS
9387: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
9388: CALL 9287 0 0
9392: NOT
9393: IFFALSE 9397
// exit ;
9395: GO 9442
// if Utok_ZbyvaMinut > 0 then
9397: LD_LOC 10
9401: PUSH
9402: LD_INT 0
9404: GREATER
9405: IFFALSE 9409
// exit ;
9407: GO 9442
// Utok_Auta = zjisti_auta_na_utok ;
9409: LD_ADDR_LOC 9
9413: PUSH
9414: CALL 8575 0 0
9418: ST_TO_ADDR
// if not Utok_Auta then
9419: LD_LOC 9
9423: NOT
9424: IFFALSE 9428
// exit ;
9426: GO 9442
// zacni_utok ;
9428: CALL 8490 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9432: LD_ADDR_LOC 10
9436: PUSH
9437: CALL 9221 0 0
9441: ST_TO_ADDR
// end ;
9442: LD_VAR 0 1
9446: RET
// every 0 0$6 do
9447: GO 9449
9449: DISABLE
// begin zacni_vynalezat ;
9450: CALL 8292 0 0
// patrola_kolecko ;
9454: CALL 10634 0 0
// end ;
9458: END
// every 0 0$19 do
9459: GO 9461
9461: DISABLE
// begin kontrola_vyroby ;
9462: CALL 7928 0 0
// enable ;
9466: ENABLE
// end ;
9467: END
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , NovyRidic ; begin
9468: LD_INT 0
9470: PPUSH
9471: PPUSH
9472: PPUSH
// if GetSide ( Veh ) = side_Ar then
9473: LD_VAR 0 1
9477: PPUSH
9478: CALL_OW 255
9482: PUSH
9483: LD_EXP 4
9487: EQUAL
9488: IFFALSE 9766
// begin NovyRidic = 0 ;
9490: LD_ADDR_VAR 0 5
9494: PUSH
9495: LD_INT 0
9497: ST_TO_ADDR
// Autaky = Autaky union [ Veh ] ;
9498: LD_ADDR_LOC 6
9502: PUSH
9503: LD_LOC 6
9507: PUSH
9508: LD_VAR 0 1
9512: PUSH
9513: EMPTY
9514: LIST
9515: UNION
9516: ST_TO_ADDR
// if ( GetWeapon ( Veh ) = AR_CONTROL_TOWER ) then
9517: LD_VAR 0 1
9521: PPUSH
9522: CALL_OW 264
9526: PUSH
9527: LD_INT 31
9529: EQUAL
9530: IFFALSE 9558
// begin ArDalkar = Veh ;
9532: LD_ADDR_LOC 25
9536: PUSH
9537: LD_VAR 0 1
9541: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
9542: LD_ADDR_VAR 0 5
9546: PUSH
9547: LD_INT 42
9549: ST_TO_ADDR
// DelamDalkare = false ;
9550: LD_ADDR_LOC 27
9554: PUSH
9555: LD_INT 0
9557: ST_TO_ADDR
// end ; if ( GetControl ( Veh ) = CONTROL_MANUAL ) and VolnyLidi then
9558: LD_VAR 0 1
9562: PPUSH
9563: CALL_OW 263
9567: PUSH
9568: LD_INT 1
9570: EQUAL
9571: PUSH
9572: LD_LOC 8
9576: AND
9577: IFFALSE 9701
// begin Ridic = IsDrivenBy ( Veh ) ;
9579: LD_ADDR_VAR 0 4
9583: PUSH
9584: LD_VAR 0 1
9588: PPUSH
9589: CALL_OW 311
9593: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9594: LD_INT 105
9596: PPUSH
9597: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
9601: LD_VAR 0 4
9605: PPUSH
9606: CALL_OW 121
// Wait ( 0 0$1 ) ;
9610: LD_INT 35
9612: PPUSH
9613: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
9617: LD_VAR 0 1
9621: PPUSH
9622: CALL_OW 311
9626: PUSH
9627: LD_VAR 0 4
9631: EQUAL
9632: IFFALSE 9643
// Wait ( 0 0$1 ) ;
9634: LD_INT 35
9636: PPUSH
9637: CALL_OW 67
9641: GO 9617
// AddComEnterUnit ( Ridic , Fact ) ;
9643: LD_VAR 0 4
9647: PPUSH
9648: LD_VAR 0 2
9652: PPUSH
9653: CALL_OW 180
// if NovyRidic then
9657: LD_VAR 0 5
9661: IFFALSE 9677
// ComEnterUnit ( NovyRidic , Veh ) ;
9663: LD_VAR 0 5
9667: PPUSH
9668: LD_VAR 0 1
9672: PPUSH
9673: CALL_OW 120
// Wait ( 0 0$3 ) ;
9677: LD_INT 105
9679: PPUSH
9680: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9684: LD_LOC 23
9688: PPUSH
9689: LD_VAR 0 1
9693: PUSH
9694: EMPTY
9695: LIST
9696: PPUSH
9697: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 263
9710: PUSH
9711: LD_INT 2
9713: EQUAL
9714: IFFALSE 9766
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
9716: LD_VAR 0 1
9720: PPUSH
9721: LD_INT 42
9723: PPUSH
9724: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
9728: LD_ADDR_LOC 26
9732: PUSH
9733: LD_LOC 26
9737: PUSH
9738: LD_INT 1
9740: PLUS
9741: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9742: LD_INT 105
9744: PPUSH
9745: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9749: LD_LOC 23
9753: PPUSH
9754: LD_VAR 0 1
9758: PUSH
9759: EMPTY
9760: LIST
9761: PPUSH
9762: CALL_OW 390
// end ; end ; end ;
9766: LD_VAR 0 3
9770: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
9771: LD_INT 0
9773: PPUSH
9774: PPUSH
9775: PPUSH
// if Veh = ArDalkar then
9776: LD_VAR 0 1
9780: PUSH
9781: LD_LOC 25
9785: EQUAL
9786: IFFALSE 9821
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
9788: LD_INT 42
9790: PPUSH
9791: CALL_OW 302
9795: PUSH
9796: LD_INT 42
9798: PPUSH
9799: CALL_OW 310
9803: NOT
9804: AND
9805: IFFALSE 9821
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
9807: LD_INT 42
9809: PPUSH
9810: LD_VAR 0 1
9814: PPUSH
9815: CALL_OW 120
// exit ;
9819: GO 9892
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
9821: LD_ADDR_VAR 0 3
9825: PUSH
9826: LD_LOC 8
9830: PPUSH
9831: LD_INT 56
9833: PUSH
9834: EMPTY
9835: LIST
9836: PUSH
9837: EMPTY
9838: LIST
9839: PPUSH
9840: CALL_OW 72
9844: ST_TO_ADDR
// for I in Lidi do
9845: LD_ADDR_VAR 0 4
9849: PUSH
9850: LD_VAR 0 3
9854: PUSH
9855: FOR_IN
9856: IFFALSE 9890
// if not HasTask ( I ) then
9858: LD_VAR 0 4
9862: PPUSH
9863: CALL_OW 314
9867: NOT
9868: IFFALSE 9888
// begin ComEnterUnit ( I , Veh ) ;
9870: LD_VAR 0 4
9874: PPUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: CALL_OW 120
// exit ;
9884: POP
9885: POP
9886: GO 9892
// end ;
9888: GO 9855
9890: POP
9891: POP
// end ;
9892: LD_VAR 0 2
9896: RET
// function nastupuj_auta ; var Auta , I ; begin
9897: LD_INT 0
9899: PPUSH
9900: PPUSH
9901: PPUSH
// Auta = FilterUnitsInArea ( Obrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
9902: LD_ADDR_VAR 0 2
9906: PUSH
9907: LD_INT 37
9909: PPUSH
9910: LD_INT 21
9912: PUSH
9913: LD_INT 2
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PUSH
9920: LD_INT 33
9922: PUSH
9923: LD_INT 1
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: PUSH
9930: LD_INT 58
9932: PUSH
9933: EMPTY
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: PPUSH
9941: CALL_OW 70
9945: ST_TO_ADDR
// if not Auta then
9946: LD_VAR 0 2
9950: NOT
9951: IFFALSE 9955
// exit ;
9953: GO 9981
// for I in Auta do
9955: LD_ADDR_VAR 0 3
9959: PUSH
9960: LD_VAR 0 2
9964: PUSH
9965: FOR_IN
9966: IFFALSE 9979
// zarid_ridice ( I ) ;
9968: LD_VAR 0 3
9972: PPUSH
9973: CALL 9771 0 1
9977: GO 9965
9979: POP
9980: POP
// end ;
9981: LD_VAR 0 1
9985: RET
// every 0 0$17 do
9986: GO 9988
9988: DISABLE
// begin nastupuj_auta ;
9989: CALL 9897 0 0
// enable ;
9993: ENABLE
// end ;
9994: END
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
9995: LD_INT 0
9997: PPUSH
// if VehOld in Patrola then
9998: LD_VAR 0 2
10002: PUSH
10003: LD_LOC 16
10007: IN
10008: IFFALSE 10029
// Patrola = Patrola diff [ VehOld ] ;
10010: LD_ADDR_LOC 16
10014: PUSH
10015: LD_LOC 16
10019: PUSH
10020: LD_VAR 0 2
10024: PUSH
10025: EMPTY
10026: LIST
10027: DIFF
10028: ST_TO_ADDR
// if VehOld in Autaky then
10029: LD_VAR 0 2
10033: PUSH
10034: LD_LOC 6
10038: IN
10039: IFFALSE 10060
// Autaky = Autaky diff [ VehOld ] ;
10041: LD_ADDR_LOC 6
10045: PUSH
10046: LD_LOC 6
10050: PUSH
10051: LD_VAR 0 2
10055: PUSH
10056: EMPTY
10057: LIST
10058: DIFF
10059: ST_TO_ADDR
// if VehOld in Utok_Auta then
10060: LD_VAR 0 2
10064: PUSH
10065: LD_LOC 9
10069: IN
10070: IFFALSE 10091
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
10072: LD_ADDR_LOC 9
10076: PUSH
10077: LD_LOC 9
10081: PUSH
10082: LD_VAR 0 2
10086: PUSH
10087: EMPTY
10088: LIST
10089: DIFF
10090: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
10091: LD_VAR 0 1
10095: PPUSH
10096: CALL_OW 255
10100: PUSH
10101: LD_EXP 4
10105: EQUAL
10106: IFFALSE 10155
// begin Autaky = Autaky union [ VehNew ] ;
10108: LD_ADDR_LOC 6
10112: PUSH
10113: LD_LOC 6
10117: PUSH
10118: LD_VAR 0 1
10122: PUSH
10123: EMPTY
10124: LIST
10125: UNION
10126: ST_TO_ADDR
// AddMcUnits ( MakroObrana , VehNew ) ;
10127: LD_LOC 20
10131: PPUSH
10132: LD_VAR 0 1
10136: PPUSH
10137: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , VehNew ) ;
10141: LD_LOC 23
10145: PPUSH
10146: LD_VAR 0 1
10150: PPUSH
10151: CALL_OW 390
// end ; if GetSide ( VehOld ) = side_Ar then
10155: LD_VAR 0 2
10159: PPUSH
10160: CALL_OW 255
10164: PUSH
10165: LD_EXP 4
10169: EQUAL
10170: IFFALSE 10220
// begin RemoveMcUnits ( MakroObrana , VehOld ) ;
10172: LD_LOC 20
10176: PPUSH
10177: LD_VAR 0 2
10181: PPUSH
10182: CALL_OW 391
// RemoveMcUnits ( MakroPresunZakladna , VehOld ) ;
10186: LD_LOC 23
10190: PPUSH
10191: LD_VAR 0 2
10195: PPUSH
10196: CALL_OW 391
// if MakroUtok then
10200: LD_LOC 21
10204: IFFALSE 10220
// RemoveMcUnits ( MakroUtok , VehOld ) ;
10206: LD_LOC 21
10210: PPUSH
10211: LD_VAR 0 2
10215: PPUSH
10216: CALL_OW 391
// end ; kontrola_zniceno ;
10220: CALL 7659 0 0
// end ;
10224: LD_VAR 0 5
10228: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
10229: LD_INT 0
10231: PPUSH
// if Un in Patrola then
10232: LD_VAR 0 1
10236: PUSH
10237: LD_LOC 16
10241: IN
10242: IFFALSE 10263
// Patrola = Patrola diff [ Un ] ;
10244: LD_ADDR_LOC 16
10248: PUSH
10249: LD_LOC 16
10253: PUSH
10254: LD_VAR 0 1
10258: PUSH
10259: EMPTY
10260: LIST
10261: DIFF
10262: ST_TO_ADDR
// if Un in Autaky then
10263: LD_VAR 0 1
10267: PUSH
10268: LD_LOC 6
10272: IN
10273: IFFALSE 10294
// Autaky = Autaky diff [ Un ] ;
10275: LD_ADDR_LOC 6
10279: PUSH
10280: LD_LOC 6
10284: PUSH
10285: LD_VAR 0 1
10289: PUSH
10290: EMPTY
10291: LIST
10292: DIFF
10293: ST_TO_ADDR
// if Un in Utok_Auta then
10294: LD_VAR 0 1
10298: PUSH
10299: LD_LOC 9
10303: IN
10304: IFFALSE 10325
// Utok_Auta = Utok_Auta diff [ Un ] ;
10306: LD_ADDR_LOC 9
10310: PUSH
10311: LD_LOC 9
10315: PUSH
10316: LD_VAR 0 1
10320: PUSH
10321: EMPTY
10322: LIST
10323: DIFF
10324: ST_TO_ADDR
// if Un in VolnyLidi then
10325: LD_VAR 0 1
10329: PUSH
10330: LD_LOC 8
10334: IN
10335: IFFALSE 10356
// VolnyLidi = VolnyLidi diff [ Un ] ;
10337: LD_ADDR_LOC 8
10341: PUSH
10342: LD_LOC 8
10346: PUSH
10347: LD_VAR 0 1
10351: PUSH
10352: EMPTY
10353: LIST
10354: DIFF
10355: ST_TO_ADDR
// kontrola_zniceno ;
10356: CALL 7659 0 0
// end ;
10360: LD_VAR 0 2
10364: RET
// export function arabi_UnitGoesToRed ( Un ) ; begin
10365: LD_INT 0
10367: PPUSH
// if ( Un = ArPBunk1 ) then
10368: LD_VAR 0 1
10372: PUSH
10373: LD_INT 2
10375: EQUAL
10376: IFFALSE 10407
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk1 ] ;
10378: LD_ADDR_LOC 8
10382: PUSH
10383: LD_LOC 8
10387: PUSH
10388: LD_INT 15
10390: PUSH
10391: EMPTY
10392: LIST
10393: UNION
10394: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk1 ) ;
10395: LD_LOC 22
10399: PPUSH
10400: LD_INT 15
10402: PPUSH
10403: CALL_OW 391
// end ; if ( Un = ArPBunk2 ) then
10407: LD_VAR 0 1
10411: PUSH
10412: LD_INT 1
10414: EQUAL
10415: IFFALSE 10446
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk2 ] ;
10417: LD_ADDR_LOC 8
10421: PUSH
10422: LD_LOC 8
10426: PUSH
10427: LD_INT 25
10429: PUSH
10430: EMPTY
10431: LIST
10432: UNION
10433: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk2 ) ;
10434: LD_LOC 22
10438: PPUSH
10439: LD_INT 25
10441: PPUSH
10442: CALL_OW 391
// end ; if ( Un = ArPBunk3 ) then
10446: LD_VAR 0 1
10450: PUSH
10451: LD_INT 32
10453: EQUAL
10454: IFFALSE 10485
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk3 ] ;
10456: LD_ADDR_LOC 8
10460: PUSH
10461: LD_LOC 8
10465: PUSH
10466: LD_INT 33
10468: PUSH
10469: EMPTY
10470: LIST
10471: UNION
10472: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk3 ) ;
10473: LD_LOC 22
10477: PPUSH
10478: LD_INT 33
10480: PPUSH
10481: CALL_OW 391
// end ; end ;
10485: LD_VAR 0 2
10489: RET
// export function arabi_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
10490: LD_INT 0
10492: PPUSH
// kontrola_zniceno ;
10493: CALL 7659 0 0
// end ;
10497: LD_VAR 0 4
10501: RET
// export function arabi_muzete_utocit ; begin
10502: LD_INT 0
10504: PPUSH
// enable ( 43 ) ;
10505: LD_INT 43
10507: ENABLE_MARKED
// end ;
10508: LD_VAR 0 1
10512: RET
// every 0 0$45 marked 43 do
10513: GO 10515
10515: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
10516: LD_INT 0
10518: PPUSH
10519: LD_INT 1050
10521: PPUSH
10522: CALL_OW 12
10526: PPUSH
10527: CALL_OW 67
// casovac_utok ;
10531: CALL 9332 0 0
// enable ;
10535: ENABLE
// end ;
10536: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
10537: LD_EXP 4
10541: PPUSH
10542: LD_EXP 2
10546: PPUSH
10547: CALL 20717 0 2
10551: IFFALSE 10568
10553: GO 10555
10555: DISABLE
// begin VidelRusa = true ;
10556: LD_ADDR_LOC 12
10560: PUSH
10561: LD_INT 1
10563: ST_TO_ADDR
// zrus_patrolu ;
10564: CALL 10569 0 0
// end ;
10568: END
// function zrus_patrolu ; begin
10569: LD_INT 0
10571: PPUSH
// ComAgressiveMove ( Patrola , 73 , 13 ) ;
10572: LD_LOC 16
10576: PPUSH
10577: LD_INT 73
10579: PPUSH
10580: LD_INT 13
10582: PPUSH
10583: CALL_OW 114
// AddComMoveUnit ( Patrola , ArDepot ) ;
10587: LD_LOC 16
10591: PPUSH
10592: LD_INT 3
10594: PPUSH
10595: CALL_OW 172
// AddComMoveToArea ( Patrola , AraboveParkoviste ) ;
10599: LD_LOC 16
10603: PPUSH
10604: LD_INT 18
10606: PPUSH
10607: CALL_OW 173
// Patrola = [ ] ;
10611: LD_ADDR_LOC 16
10615: PUSH
10616: EMPTY
10617: ST_TO_ADDR
// PatrolaZrusena = true ;
10618: LD_ADDR_LOC 17
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
// disable ( 45 ) ;
10626: LD_INT 45
10628: DISABLE_MARKED
// end ;
10629: LD_VAR 0 1
10633: RET
// function patrola_kolecko ; begin
10634: LD_INT 0
10636: PPUSH
// ComMoveUnit ( Patrola , ArDepot ) ;
10637: LD_LOC 16
10641: PPUSH
10642: LD_INT 3
10644: PPUSH
10645: CALL_OW 112
// AddComMoveXY ( Patrola , 83 , 12 ) ;
10649: LD_LOC 16
10653: PPUSH
10654: LD_INT 83
10656: PPUSH
10657: LD_INT 12
10659: PPUSH
10660: CALL_OW 171
// AddComMoveXY ( Patrola , 68 , 13 ) ;
10664: LD_LOC 16
10668: PPUSH
10669: LD_INT 68
10671: PPUSH
10672: LD_INT 13
10674: PPUSH
10675: CALL_OW 171
// AddComMoveXY ( Patrola , 62 , 15 ) ;
10679: LD_LOC 16
10683: PPUSH
10684: LD_INT 62
10686: PPUSH
10687: LD_INT 15
10689: PPUSH
10690: CALL_OW 171
// AddComMoveXY ( Patrola , 54 , 15 ) ;
10694: LD_LOC 16
10698: PPUSH
10699: LD_INT 54
10701: PPUSH
10702: LD_INT 15
10704: PPUSH
10705: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 13 ) ;
10709: LD_LOC 16
10713: PPUSH
10714: LD_INT 46
10716: PPUSH
10717: LD_INT 13
10719: PPUSH
10720: CALL_OW 171
// AddComMoveXY ( Patrola , 36 , 13 ) ;
10724: LD_LOC 16
10728: PPUSH
10729: LD_INT 36
10731: PPUSH
10732: LD_INT 13
10734: PPUSH
10735: CALL_OW 171
// AddComMoveXY ( Patrola , 31 , 17 ) ;
10739: LD_LOC 16
10743: PPUSH
10744: LD_INT 31
10746: PPUSH
10747: LD_INT 17
10749: PPUSH
10750: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.7 ) ;
10754: LD_LOC 16
10758: PPUSH
10759: LD_INT 165
10761: PPUSH
10762: CALL_OW 202
// AddComMoveXY ( Patrola , 20 , 16 ) ;
10766: LD_LOC 16
10770: PPUSH
10771: LD_INT 20
10773: PPUSH
10774: LD_INT 16
10776: PPUSH
10777: CALL_OW 171
// AddComMoveXY ( Patrola , 4 , 3 ) ;
10781: LD_LOC 16
10785: PPUSH
10786: LD_INT 4
10788: PPUSH
10789: LD_INT 3
10791: PPUSH
10792: CALL_OW 171
// AddComWait ( Patrola , 0 0$4 ) ;
10796: LD_LOC 16
10800: PPUSH
10801: LD_INT 140
10803: PPUSH
10804: CALL_OW 202
// AddComMoveXY ( Patrola , 6 , 7 ) ;
10808: LD_LOC 16
10812: PPUSH
10813: LD_INT 6
10815: PPUSH
10816: LD_INT 7
10818: PPUSH
10819: CALL_OW 171
// AddComMoveXY ( Patrola , 20 , 17 ) ;
10823: LD_LOC 16
10827: PPUSH
10828: LD_INT 20
10830: PPUSH
10831: LD_INT 17
10833: PPUSH
10834: CALL_OW 171
// AddComMoveXY ( Patrola , 28 , 18 ) ;
10838: LD_LOC 16
10842: PPUSH
10843: LD_INT 28
10845: PPUSH
10846: LD_INT 18
10848: PPUSH
10849: CALL_OW 171
// AddComWait ( Patrola , 0 0$5.2 ) ;
10853: LD_LOC 16
10857: PPUSH
10858: LD_INT 182
10860: PPUSH
10861: CALL_OW 202
// if not VsevSaved then
10865: LD_EXP 8
10869: NOT
10870: IFFALSE 11190
// begin AddComMoveXY ( Patrola , 33 , 21 ) ;
10872: LD_LOC 16
10876: PPUSH
10877: LD_INT 33
10879: PPUSH
10880: LD_INT 21
10882: PPUSH
10883: CALL_OW 171
// AddComMoveXY ( Patrola , 37 , 34 ) ;
10887: LD_LOC 16
10891: PPUSH
10892: LD_INT 37
10894: PPUSH
10895: LD_INT 34
10897: PPUSH
10898: CALL_OW 171
// AddComMoveXY ( Patrola , 43 , 45 ) ;
10902: LD_LOC 16
10906: PPUSH
10907: LD_INT 43
10909: PPUSH
10910: LD_INT 45
10912: PPUSH
10913: CALL_OW 171
// AddComMoveXY ( Patrola , 55 , 59 ) ;
10917: LD_LOC 16
10921: PPUSH
10922: LD_INT 55
10924: PPUSH
10925: LD_INT 59
10927: PPUSH
10928: CALL_OW 171
// AddComMoveXY ( Patrola , 66 , 80 ) ;
10932: LD_LOC 16
10936: PPUSH
10937: LD_INT 66
10939: PPUSH
10940: LD_INT 80
10942: PPUSH
10943: CALL_OW 171
// AddComWait ( Patrola , 0 0$1.2 ) ;
10947: LD_LOC 16
10951: PPUSH
10952: LD_INT 42
10954: PPUSH
10955: CALL_OW 202
// AddComMoveXY ( Patrola , 73 , 95 ) ;
10959: LD_LOC 16
10963: PPUSH
10964: LD_INT 73
10966: PPUSH
10967: LD_INT 95
10969: PPUSH
10970: CALL_OW 171
// AddComMoveXY ( Patrola , 74 , 100 ) ;
10974: LD_LOC 16
10978: PPUSH
10979: LD_INT 74
10981: PPUSH
10982: LD_INT 100
10984: PPUSH
10985: CALL_OW 171
// AddComMoveXY ( Patrola , 82 , 116 ) ;
10989: LD_LOC 16
10993: PPUSH
10994: LD_INT 82
10996: PPUSH
10997: LD_INT 116
10999: PPUSH
11000: CALL_OW 171
// AddComMoveXY ( Patrola , 92 , 131 ) ;
11004: LD_LOC 16
11008: PPUSH
11009: LD_INT 92
11011: PPUSH
11012: LD_INT 131
11014: PPUSH
11015: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.4 ) ;
11019: LD_LOC 16
11023: PPUSH
11024: LD_INT 119
11026: PPUSH
11027: CALL_OW 202
// AddComMoveXY ( Patrola , 93 , 129 ) ;
11031: LD_LOC 16
11035: PPUSH
11036: LD_INT 93
11038: PPUSH
11039: LD_INT 129
11041: PPUSH
11042: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.1 ) ;
11046: LD_LOC 16
11050: PPUSH
11051: LD_INT 143
11053: PPUSH
11054: CALL_OW 202
// AddComMoveXY ( Patrola , 87 , 119 ) ;
11058: LD_LOC 16
11062: PPUSH
11063: LD_INT 87
11065: PPUSH
11066: LD_INT 119
11068: PPUSH
11069: CALL_OW 171
// AddComMoveXY ( Patrola , 77 , 100 ) ;
11073: LD_LOC 16
11077: PPUSH
11078: LD_INT 77
11080: PPUSH
11081: LD_INT 100
11083: PPUSH
11084: CALL_OW 171
// AddComMoveXY ( Patrola , 73 , 91 ) ;
11088: LD_LOC 16
11092: PPUSH
11093: LD_INT 73
11095: PPUSH
11096: LD_INT 91
11098: PPUSH
11099: CALL_OW 171
// AddComMoveXY ( Patrola , 65 , 73 ) ;
11103: LD_LOC 16
11107: PPUSH
11108: LD_INT 65
11110: PPUSH
11111: LD_INT 73
11113: PPUSH
11114: CALL_OW 171
// AddComMoveXY ( Patrola , 56 , 58 ) ;
11118: LD_LOC 16
11122: PPUSH
11123: LD_INT 56
11125: PPUSH
11126: LD_INT 58
11128: PPUSH
11129: CALL_OW 171
// AddComMoveXY ( Patrola , 47 , 47 ) ;
11133: LD_LOC 16
11137: PPUSH
11138: LD_INT 47
11140: PPUSH
11141: LD_INT 47
11143: PPUSH
11144: CALL_OW 171
// AddComMoveXY ( Patrola , 40 , 36 ) ;
11148: LD_LOC 16
11152: PPUSH
11153: LD_INT 40
11155: PPUSH
11156: LD_INT 36
11158: PPUSH
11159: CALL_OW 171
// AddComMoveXY ( Patrola , 35 , 25 ) ;
11163: LD_LOC 16
11167: PPUSH
11168: LD_INT 35
11170: PPUSH
11171: LD_INT 25
11173: PPUSH
11174: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.3 ) ;
11178: LD_LOC 16
11182: PPUSH
11183: LD_INT 115
11185: PPUSH
11186: CALL_OW 202
// end ; AddComMoveXY ( Patrola , 34 , 18 ) ;
11190: LD_LOC 16
11194: PPUSH
11195: LD_INT 34
11197: PPUSH
11198: LD_INT 18
11200: PPUSH
11201: CALL_OW 171
// AddComMoveXY ( Patrola , 38 , 14 ) ;
11205: LD_LOC 16
11209: PPUSH
11210: LD_INT 38
11212: PPUSH
11213: LD_INT 14
11215: PPUSH
11216: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 14 ) ;
11220: LD_LOC 16
11224: PPUSH
11225: LD_INT 46
11227: PPUSH
11228: LD_INT 14
11230: PPUSH
11231: CALL_OW 171
// AddComMoveXY ( Patrola , 51 , 16 ) ;
11235: LD_LOC 16
11239: PPUSH
11240: LD_INT 51
11242: PPUSH
11243: LD_INT 16
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Patrola , 61 , 16 ) ;
11250: LD_LOC 16
11254: PPUSH
11255: LD_INT 61
11257: PPUSH
11258: LD_INT 16
11260: PPUSH
11261: CALL_OW 171
// AddComMoveXY ( Patrola , 75 , 14 ) ;
11265: LD_LOC 16
11269: PPUSH
11270: LD_INT 75
11272: PPUSH
11273: LD_INT 14
11275: PPUSH
11276: CALL_OW 171
// AddComMoveXY ( Patrola , 86 , 18 ) ;
11280: LD_LOC 16
11284: PPUSH
11285: LD_INT 86
11287: PPUSH
11288: LD_INT 18
11290: PPUSH
11291: CALL_OW 171
// AddComWait ( Patrola , 0 0$2.9 ) ;
11295: LD_LOC 16
11299: PPUSH
11300: LD_INT 101
11302: PPUSH
11303: CALL_OW 202
// AddComSailEvent ( Patrola , 101 ) ;
11307: LD_LOC 16
11311: PPUSH
11312: LD_INT 101
11314: PPUSH
11315: CALL_OW 224
// end ;
11319: LD_VAR 0 1
11323: RET
// export function event_Patrola ; begin
11324: LD_INT 0
11326: PPUSH
// if Patrola and not PatrolaZrusena then
11327: LD_LOC 16
11331: PUSH
11332: LD_LOC 17
11336: NOT
11337: AND
11338: IFFALSE 11344
// patrola_kolecko ;
11340: CALL 10634 0 0
// end ;
11344: LD_VAR 0 1
11348: RET
// every 0 0$27.1 marked 45 do var Kdo ;
11349: GO 11351
11351: DISABLE
11352: LD_INT 0
11354: PPUSH
// begin if not Patrola then
11355: LD_LOC 16
11359: NOT
11360: IFFALSE 11364
// exit ;
11362: GO 11405
// for Kdo in Patrola do
11364: LD_ADDR_VAR 0 1
11368: PUSH
11369: LD_LOC 16
11373: PUSH
11374: FOR_IN
11375: IFFALSE 11402
// if GetFuel ( Kdo ) < 25 then
11377: LD_VAR 0 1
11381: PPUSH
11382: CALL_OW 261
11386: PUSH
11387: LD_INT 25
11389: LESS
11390: IFFALSE 11400
// begin zrus_patrolu ;
11392: CALL 10569 0 0
// exit ;
11396: POP
11397: POP
11398: GO 11405
// end ;
11400: GO 11374
11402: POP
11403: POP
// enable ;
11404: ENABLE
// end ;
11405: PPOPN 1
11407: END
// every 0 0$5.1 do var I , Stahnout ;
11408: GO 11410
11410: DISABLE
11411: LD_INT 0
11413: PPUSH
11414: PPUSH
// begin Stahnout = true ;
11415: LD_ADDR_VAR 0 2
11419: PUSH
11420: LD_INT 1
11422: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
11423: LD_ADDR_VAR 0 1
11427: PUSH
11428: LD_LOC 20
11432: PPUSH
11433: CALL_OW 389
11437: PUSH
11438: FOR_IN
11439: IFFALSE 11470
// if ( GetUnitMc ( I ) = MakroObrana ) then
11441: LD_VAR 0 1
11445: PPUSH
11446: CALL_OW 388
11450: PUSH
11451: LD_LOC 20
11455: EQUAL
11456: IFFALSE 11468
// begin Stahnout = false ;
11458: LD_ADDR_VAR 0 2
11462: PUSH
11463: LD_INT 0
11465: ST_TO_ADDR
// break ;
11466: GO 11470
// end ;
11468: GO 11438
11470: POP
11471: POP
// enable ;
11472: ENABLE
// if Stahnout <> BeziStahovani then
11473: LD_VAR 0 2
11477: PUSH
11478: LD_LOC 24
11482: NONEQUAL
11483: IFFALSE 11509
// begin if Stahnout then
11485: LD_VAR 0 2
11489: IFFALSE 11496
// enable ( 46 ) else
11491: LD_INT 46
11493: ENABLE_MARKED
11494: GO 11499
// disable ( 46 ) ;
11496: LD_INT 46
11498: DISABLE_MARKED
// BeziStahovani = Stahnout ;
11499: LD_ADDR_LOC 24
11503: PUSH
11504: LD_VAR 0 2
11508: ST_TO_ADDR
// end ; end ;
11509: PPOPN 2
11511: END
// every 0 0$30 marked 46 do var I ;
11512: GO 11514
11514: DISABLE
11515: LD_INT 0
11517: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
11518: LD_ADDR_VAR 0 1
11522: PUSH
11523: LD_LOC 23
11527: PPUSH
11528: CALL_OW 389
11532: PUSH
11533: FOR_IN
11534: IFFALSE 11609
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , ArabskaBaze ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
11536: LD_VAR 0 1
11540: PPUSH
11541: CALL_OW 388
11545: PUSH
11546: LD_LOC 23
11550: EQUAL
11551: PUSH
11552: LD_VAR 0 1
11556: PPUSH
11557: LD_INT 14
11559: PPUSH
11560: CALL_OW 299
11564: PUSH
11565: LD_INT 0
11567: GREATER
11568: AND
11569: PUSH
11570: LD_VAR 0 1
11574: PPUSH
11575: CALL_OW 310
11579: NOT
11580: AND
11581: PUSH
11582: LD_VAR 0 1
11586: PPUSH
11587: CALL_OW 314
11591: NOT
11592: AND
11593: IFFALSE 11607
// ComMoveToArea ( I , ArabskaBaze ) ;
11595: LD_VAR 0 1
11599: PPUSH
11600: LD_INT 14
11602: PPUSH
11603: CALL_OW 113
11607: GO 11533
11609: POP
11610: POP
// BeziStahovani = false ;
11611: LD_ADDR_LOC 24
11615: PUSH
11616: LD_INT 0
11618: ST_TO_ADDR
// end ;
11619: PPOPN 1
11621: END
// function posila_tank ; begin
11622: LD_INT 0
11624: PPUSH
// UC_Side = side_Ar ;
11625: LD_ADDR_OWVAR 20
11629: PUSH
11630: LD_EXP 4
11634: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
11635: LD_ADDR_OWVAR 21
11639: PUSH
11640: LD_INT 2
11642: ST_TO_ADDR
// VC_Chassis = AR_MEDIUM_TRIKE ;
11643: LD_ADDR_OWVAR 37
11647: PUSH
11648: LD_INT 13
11650: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
11651: LD_ADDR_OWVAR 38
11655: PUSH
11656: LD_INT 1
11658: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
11659: LD_ADDR_OWVAR 39
11663: PUSH
11664: LD_INT 1
11666: ST_TO_ADDR
// VC_Weapon = nahoda_seznam ( [ AR_FLAME_THROWER , AR_ROCKET_LAUNCHER , AR_MULTIMISSILE_BALLISTA ] ) ;
11667: LD_ADDR_OWVAR 40
11671: PUSH
11672: LD_INT 26
11674: PUSH
11675: LD_INT 28
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL 20999 0 1
11690: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 85 , 100 ) ;
11691: LD_ADDR_OWVAR 41
11695: PUSH
11696: LD_INT 85
11698: PPUSH
11699: LD_INT 100
11701: PPUSH
11702: CALL_OW 12
11706: ST_TO_ADDR
// Result = CreateVehicle ;
11707: LD_ADDR_VAR 0 1
11711: PUSH
11712: CALL_OW 45
11716: ST_TO_ADDR
// PlaceHumanInUnit ( vytvor_cloveka ( CLASS_MECHANIC ) , Result ) ;
11717: LD_INT 3
11719: PPUSH
11720: CALL 7236 0 1
11724: PPUSH
11725: LD_VAR 0 1
11729: PPUSH
11730: CALL_OW 52
// end ;
11734: LD_VAR 0 1
11738: RET
// function vytvor_posily ; begin
11739: LD_INT 0
11741: PPUSH
// Result = [ ] ;
11742: LD_ADDR_VAR 0 1
11746: PUSH
11747: EMPTY
11748: ST_TO_ADDR
// if Difficulty = 1 then
11749: LD_OWVAR 67
11753: PUSH
11754: LD_INT 1
11756: EQUAL
11757: IFFALSE 11761
// exit ;
11759: GO 11849
// Result = Result union [ posila_tank ] ;
11761: LD_ADDR_VAR 0 1
11765: PUSH
11766: LD_VAR 0 1
11770: PUSH
11771: CALL 11622 0 0
11775: PUSH
11776: EMPTY
11777: LIST
11778: UNION
11779: ST_TO_ADDR
// if Difficulty = 2 then
11780: LD_OWVAR 67
11784: PUSH
11785: LD_INT 2
11787: EQUAL
11788: IFFALSE 11792
// exit ;
11790: GO 11849
// Result = Result union [ posila_tank ] ;
11792: LD_ADDR_VAR 0 1
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: CALL 11622 0 0
11806: PUSH
11807: EMPTY
11808: LIST
11809: UNION
11810: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11811: LD_ADDR_VAR 0 1
11815: PUSH
11816: LD_VAR 0 1
11820: PUSH
11821: CALL 11622 0 0
11825: PUSH
11826: EMPTY
11827: LIST
11828: UNION
11829: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11830: LD_ADDR_VAR 0 1
11834: PUSH
11835: LD_VAR 0 1
11839: PUSH
11840: CALL 11622 0 0
11844: PUSH
11845: EMPTY
11846: LIST
11847: UNION
11848: ST_TO_ADDR
// end ;
11849: LD_VAR 0 1
11853: RET
// every 13 13$1 do var Posily , Lidi , I , J ;
11854: GO 11856
11856: DISABLE
11857: LD_INT 0
11859: PPUSH
11860: PPUSH
11861: PPUSH
11862: PPUSH
// begin Posily = vytvor_posily ;
11863: LD_ADDR_VAR 0 1
11867: PUSH
11868: CALL 11739 0 0
11872: ST_TO_ADDR
// place_list ( Posily , ArabovePosily ) ;
11873: LD_VAR 0 1
11877: PPUSH
11878: LD_INT 41
11880: PPUSH
11881: CALL 20674 0 2
// Lidi = [ ] ;
11885: LD_ADDR_VAR 0 2
11889: PUSH
11890: EMPTY
11891: ST_TO_ADDR
// for I in Posily do
11892: LD_ADDR_VAR 0 3
11896: PUSH
11897: LD_VAR 0 1
11901: PUSH
11902: FOR_IN
11903: IFFALSE 11947
// begin J = IsDrivenBy ( I ) ;
11905: LD_ADDR_VAR 0 4
11909: PUSH
11910: LD_VAR 0 3
11914: PPUSH
11915: CALL_OW 311
11919: ST_TO_ADDR
// if J then
11920: LD_VAR 0 4
11924: IFFALSE 11945
// Lidi = Lidi union [ J ] ;
11926: LD_ADDR_VAR 0 2
11930: PUSH
11931: LD_VAR 0 2
11935: PUSH
11936: LD_VAR 0 4
11940: PUSH
11941: EMPTY
11942: LIST
11943: UNION
11944: ST_TO_ADDR
// end ;
11945: GO 11902
11947: POP
11948: POP
// Autaky = Autaky union Posily ;
11949: LD_ADDR_LOC 6
11953: PUSH
11954: LD_LOC 6
11958: PUSH
11959: LD_VAR 0 1
11963: UNION
11964: ST_TO_ADDR
// AddMcUnits ( MakroObrana , Lidi union Posily ) ;
11965: LD_LOC 20
11969: PPUSH
11970: LD_VAR 0 2
11974: PUSH
11975: LD_VAR 0 1
11979: UNION
11980: PPUSH
11981: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , Lidi union Posily ) ;
11985: LD_LOC 23
11989: PPUSH
11990: LD_VAR 0 2
11994: PUSH
11995: LD_VAR 0 1
11999: UNION
12000: PPUSH
12001: CALL_OW 390
// end ;
12005: PPOPN 4
12007: END
// every 2 2$7 do
12008: GO 12010
12010: DISABLE
// begin opravuj_budovy ;
12011: CALL 12029 0 0
// kuryruj_lidi ;
12015: CALL 12474 0 0
// opravuj_auta ;
12019: CALL 12236 0 0
// sbirej_bedny ;
12023: CALL 12202 0 0
// enable ;
12027: ENABLE
// end ;
12028: END
// function opravuj_budovy ; var Budovy , Opravit , I , Kde ; begin
12029: LD_INT 0
12031: PPUSH
12032: PPUSH
12033: PPUSH
12034: PPUSH
12035: PPUSH
// if not IsOk ( ArEng ) then
12036: LD_INT 16
12038: PPUSH
12039: CALL_OW 302
12043: NOT
12044: IFFALSE 12048
// exit ;
12046: GO 12197
// Budovy = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , side_Ar ] ] ) ;
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: LD_INT 14
12055: PPUSH
12056: LD_INT 21
12058: PUSH
12059: LD_INT 3
12061: PUSH
12062: EMPTY
12063: LIST
12064: LIST
12065: PUSH
12066: LD_INT 22
12068: PUSH
12069: LD_EXP 4
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PPUSH
12082: CALL_OW 70
12086: ST_TO_ADDR
// Opravit = [ ] ;
12087: LD_ADDR_VAR 0 3
12091: PUSH
12092: EMPTY
12093: ST_TO_ADDR
// for I in Budovy do
12094: LD_ADDR_VAR 0 4
12098: PUSH
12099: LD_VAR 0 2
12103: PUSH
12104: FOR_IN
12105: IFFALSE 12143
// if GetLives ( I ) < HRANICE_ZDRAVI then
12107: LD_VAR 0 4
12111: PPUSH
12112: CALL_OW 256
12116: PUSH
12117: LD_INT 1000
12119: LESS
12120: IFFALSE 12141
// Opravit = Opravit union [ I ] ;
12122: LD_ADDR_VAR 0 3
12126: PUSH
12127: LD_VAR 0 3
12131: PUSH
12132: LD_VAR 0 4
12136: PUSH
12137: EMPTY
12138: LIST
12139: UNION
12140: ST_TO_ADDR
12141: GO 12104
12143: POP
12144: POP
// ComCancel ( ArEng ) ;
12145: LD_INT 16
12147: PPUSH
12148: CALL_OW 127
// if Opravit then
12152: LD_VAR 0 3
12156: IFFALSE 12197
// begin for I in Opravit do
12158: LD_ADDR_VAR 0 4
12162: PUSH
12163: LD_VAR 0 3
12167: PUSH
12168: FOR_IN
12169: IFFALSE 12185
// AddComRepairBuilding ( ArEng , I ) ;
12171: LD_INT 16
12173: PPUSH
12174: LD_VAR 0 4
12178: PPUSH
12179: CALL_OW 190
12183: GO 12168
12185: POP
12186: POP
// AddComMoveToArea ( ArEng , BednyArabi ) ;
12187: LD_INT 16
12189: PPUSH
12190: LD_INT 30
12192: PPUSH
12193: CALL_OW 173
// end ; end ;
12197: LD_VAR 0 1
12201: RET
// function sbirej_bedny ; begin
12202: LD_INT 0
12204: PPUSH
// if ArEng and IsOk ( ArEng ) then
12205: LD_INT 16
12207: PUSH
12208: LD_INT 16
12210: PPUSH
12211: CALL_OW 302
12215: AND
12216: IFFALSE 12231
// AddComCollect ( ArEng , 85 , 10 ) ;
12218: LD_INT 16
12220: PPUSH
12221: LD_INT 85
12223: PPUSH
12224: LD_INT 10
12226: PPUSH
12227: CALL_OW 177
// end ;
12231: LD_VAR 0 1
12235: RET
// function opravuj_auta ; var Auta , Opravit , I , Kde ; begin
12236: LD_INT 0
12238: PPUSH
12239: PPUSH
12240: PPUSH
12241: PPUSH
12242: PPUSH
// if ProbihaOprava then
12243: LD_LOC 29
12247: IFFALSE 12251
// exit ;
12249: GO 12469
// if not IsOk ( ArMech ) then
12251: LD_INT 21
12253: PPUSH
12254: CALL_OW 302
12258: NOT
12259: IFFALSE 12263
// exit ;
12261: GO 12469
// Auta = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , side_Ar ] ] ) diff Utok_Auta ;
12263: LD_ADDR_VAR 0 2
12267: PUSH
12268: LD_INT 14
12270: PPUSH
12271: LD_INT 21
12273: PUSH
12274: LD_INT 2
12276: PUSH
12277: EMPTY
12278: LIST
12279: LIST
12280: PUSH
12281: LD_INT 22
12283: PUSH
12284: LD_EXP 4
12288: PUSH
12289: EMPTY
12290: LIST
12291: LIST
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PPUSH
12297: CALL_OW 70
12301: PUSH
12302: LD_LOC 9
12306: DIFF
12307: ST_TO_ADDR
// Opravit = [ ] ;
12308: LD_ADDR_VAR 0 3
12312: PUSH
12313: EMPTY
12314: ST_TO_ADDR
// for I in Auta do
12315: LD_ADDR_VAR 0 4
12319: PUSH
12320: LD_VAR 0 2
12324: PUSH
12325: FOR_IN
12326: IFFALSE 12364
// if GetLives ( I ) < HRANICE_ZDRAVI then
12328: LD_VAR 0 4
12332: PPUSH
12333: CALL_OW 256
12337: PUSH
12338: LD_INT 1000
12340: LESS
12341: IFFALSE 12362
// Opravit = Opravit union [ I ] ;
12343: LD_ADDR_VAR 0 3
12347: PUSH
12348: LD_VAR 0 3
12352: PUSH
12353: LD_VAR 0 4
12357: PUSH
12358: EMPTY
12359: LIST
12360: UNION
12361: ST_TO_ADDR
12362: GO 12325
12364: POP
12365: POP
// if Opravit then
12366: LD_VAR 0 3
12370: IFFALSE 12469
// begin Kde = IsInUnit ( ArMech ) ;
12372: LD_ADDR_VAR 0 5
12376: PUSH
12377: LD_INT 21
12379: PPUSH
12380: CALL_OW 310
12384: ST_TO_ADDR
// if Kde then
12385: LD_VAR 0 5
12389: IFFALSE 12422
// if GetType ( Kde ) = UNIT_BUILDING then
12391: LD_VAR 0 5
12395: PPUSH
12396: CALL_OW 247
12400: PUSH
12401: LD_INT 3
12403: EQUAL
12404: IFFALSE 12415
// ComExitBuilding ( ArMech ) else
12406: LD_INT 21
12408: PPUSH
12409: CALL_OW 122
12413: GO 12422
// ComExitVehicle ( ArMech ) ;
12415: LD_INT 21
12417: PPUSH
12418: CALL_OW 121
// for I in Opravit do
12422: LD_ADDR_VAR 0 4
12426: PUSH
12427: LD_VAR 0 3
12431: PUSH
12432: FOR_IN
12433: IFFALSE 12449
// AddComRepairVehicle ( ArMech , I ) ;
12435: LD_INT 21
12437: PPUSH
12438: LD_VAR 0 4
12442: PPUSH
12443: CALL_OW 189
12447: GO 12432
12449: POP
12450: POP
// AddComSailEvent ( ArMech , 102 ) ;
12451: LD_INT 21
12453: PPUSH
12454: LD_INT 102
12456: PPUSH
12457: CALL_OW 224
// ProbihaOprava = true ;
12461: LD_ADDR_LOC 29
12465: PUSH
12466: LD_INT 1
12468: ST_TO_ADDR
// end ; end ;
12469: LD_VAR 0 1
12473: RET
// function kuryruj_lidi ; var Lidi , Opravit , I , Kde , Felcar , Budova , Event ; begin
12474: LD_INT 0
12476: PPUSH
12477: PPUSH
12478: PPUSH
12479: PPUSH
12480: PPUSH
12481: PPUSH
12482: PPUSH
12483: PPUSH
// if ProbihaLeceni then
12484: LD_LOC 30
12488: IFFALSE 12492
// exit ;
12490: GO 12776
// if IsOk ( ArSci1 ) then
12492: LD_INT 17
12494: PPUSH
12495: CALL_OW 302
12499: IFFALSE 12527
// begin Felcar = ArSci1 ;
12501: LD_ADDR_VAR 0 6
12505: PUSH
12506: LD_INT 17
12508: ST_TO_ADDR
// Budova = ArLab1 ;
12509: LD_ADDR_VAR 0 7
12513: PUSH
12514: LD_INT 6
12516: ST_TO_ADDR
// Event = 103 ;
12517: LD_ADDR_VAR 0 8
12521: PUSH
12522: LD_INT 103
12524: ST_TO_ADDR
// end else
12525: GO 12564
// if IsOk ( ArSci2 ) then
12527: LD_INT 18
12529: PPUSH
12530: CALL_OW 302
12534: IFFALSE 12562
// begin Felcar = ArSci2 ;
12536: LD_ADDR_VAR 0 6
12540: PUSH
12541: LD_INT 18
12543: ST_TO_ADDR
// Budova = ArLab2 ;
12544: LD_ADDR_VAR 0 7
12548: PUSH
12549: LD_INT 24
12551: ST_TO_ADDR
// Event = 104 ;
12552: LD_ADDR_VAR 0 8
12556: PUSH
12557: LD_INT 104
12559: ST_TO_ADDR
// end else
12560: GO 12564
// exit ;
12562: GO 12776
// Lidi = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , side_Ar ] ] ) ;
12564: LD_ADDR_VAR 0 2
12568: PUSH
12569: LD_INT 14
12571: PPUSH
12572: LD_INT 21
12574: PUSH
12575: LD_INT 1
12577: PUSH
12578: EMPTY
12579: LIST
12580: LIST
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_EXP 4
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PPUSH
12598: CALL_OW 70
12602: ST_TO_ADDR
// Opravit = [ ] ;
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: EMPTY
12609: ST_TO_ADDR
// for I in Lidi do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: LD_VAR 0 2
12619: PUSH
12620: FOR_IN
12621: IFFALSE 12659
// if GetLives ( I ) < HRANICE_ZDRAVI then
12623: LD_VAR 0 4
12627: PPUSH
12628: CALL_OW 256
12632: PUSH
12633: LD_INT 1000
12635: LESS
12636: IFFALSE 12657
// Opravit = Opravit union [ I ] ;
12638: LD_ADDR_VAR 0 3
12642: PUSH
12643: LD_VAR 0 3
12647: PUSH
12648: LD_VAR 0 4
12652: PUSH
12653: EMPTY
12654: LIST
12655: UNION
12656: ST_TO_ADDR
12657: GO 12620
12659: POP
12660: POP
// if Opravit then
12661: LD_VAR 0 3
12665: IFFALSE 12776
// begin Kde = IsInUnit ( Felcar ) ;
12667: LD_ADDR_VAR 0 5
12671: PUSH
12672: LD_VAR 0 6
12676: PPUSH
12677: CALL_OW 310
12681: ST_TO_ADDR
// if Kde then
12682: LD_VAR 0 5
12686: IFFALSE 12723
// if GetType ( Kde ) = UNIT_BUILDING then
12688: LD_VAR 0 5
12692: PPUSH
12693: CALL_OW 247
12697: PUSH
12698: LD_INT 3
12700: EQUAL
12701: IFFALSE 12714
// ComExitBuilding ( Felcar ) else
12703: LD_VAR 0 6
12707: PPUSH
12708: CALL_OW 122
12712: GO 12723
// ComExitVehicle ( Felcar ) ;
12714: LD_VAR 0 6
12718: PPUSH
12719: CALL_OW 121
// for I in Opravit do
12723: LD_ADDR_VAR 0 4
12727: PUSH
12728: LD_VAR 0 3
12732: PUSH
12733: FOR_IN
12734: IFFALSE 12752
// AddComHeal ( Felcar , I ) ;
12736: LD_VAR 0 6
12740: PPUSH
12741: LD_VAR 0 4
12745: PPUSH
12746: CALL_OW 188
12750: GO 12733
12752: POP
12753: POP
// AddComSailEvent ( Felcar , Event ) ;
12754: LD_VAR 0 6
12758: PPUSH
12759: LD_VAR 0 8
12763: PPUSH
12764: CALL_OW 224
// ProbihaLeceni = true ;
12768: LD_ADDR_LOC 30
12772: PUSH
12773: LD_INT 1
12775: ST_TO_ADDR
// end ; end ;
12776: LD_VAR 0 1
12780: RET
// export function event_OpravaHotova ( Num ) ; begin
12781: LD_INT 0
12783: PPUSH
// case Num of 102 :
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 102
12791: DOUBLE
12792: EQUAL
12793: IFTRUE 12797
12795: GO 12818
12797: POP
// begin ComEnterUnit ( ArMech , ArFact ) ;
12798: LD_INT 21
12800: PPUSH
12801: LD_INT 4
12803: PPUSH
12804: CALL_OW 120
// ProbihaOprava = false ;
12808: LD_ADDR_LOC 29
12812: PUSH
12813: LD_INT 0
12815: ST_TO_ADDR
// end ; 103 :
12816: GO 12877
12818: LD_INT 103
12820: DOUBLE
12821: EQUAL
12822: IFTRUE 12826
12824: GO 12847
12826: POP
// begin ComEnterUnit ( ArSci1 , ArLab1 ) ;
12827: LD_INT 17
12829: PPUSH
12830: LD_INT 6
12832: PPUSH
12833: CALL_OW 120
// ProbihaLeceni = false ;
12837: LD_ADDR_LOC 30
12841: PUSH
12842: LD_INT 0
12844: ST_TO_ADDR
// end ; 104 :
12845: GO 12877
12847: LD_INT 104
12849: DOUBLE
12850: EQUAL
12851: IFTRUE 12855
12853: GO 12876
12855: POP
// begin ComEnterUnit ( ArSci2 , ArLab2 ) ;
12856: LD_INT 18
12858: PPUSH
12859: LD_INT 24
12861: PPUSH
12862: CALL_OW 120
// ProbihaLeceni = false ;
12866: LD_ADDR_LOC 30
12870: PUSH
12871: LD_INT 0
12873: ST_TO_ADDR
// end ; end ;
12874: GO 12877
12876: POP
// end ;
12877: LD_VAR 0 2
12881: RET
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
12882: LD_INT 0
12884: PPUSH
12885: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
12886: LD_ADDR_VAR 0 4
12890: PUSH
12891: LD_INT 22
12893: PUSH
12894: LD_EXP 2
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 92
12905: PUSH
12906: LD_VAR 0 1
12910: PUSH
12911: LD_VAR 0 2
12915: PUSH
12916: LD_INT 2
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: ST_TO_ADDR
// if Jednotky then
12934: LD_VAR 0 4
12938: IFFALSE 12969
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
12940: LD_VAR 0 1
12944: PPUSH
12945: LD_VAR 0 2
12949: PPUSH
12950: LD_EXP 4
12954: PPUSH
12955: CALL_OW 456
// Result = true ;
12959: LD_ADDR_VAR 0 3
12963: PUSH
12964: LD_INT 1
12966: ST_TO_ADDR
// end else
12967: GO 12977
// Result = false ;
12969: LD_ADDR_VAR 0 3
12973: PUSH
12974: LD_INT 0
12976: ST_TO_ADDR
// end ;
12977: LD_VAR 0 3
12981: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
12982: GO 12984
12984: DISABLE
12985: LD_INT 0
12987: PPUSH
12988: PPUSH
// begin if not Miny then
12989: LD_LOC 28
12993: NOT
12994: IFFALSE 12998
// exit ;
12996: GO 13094
// Bouchlo = [ ] ;
12998: LD_ADDR_VAR 0 2
13002: PUSH
13003: EMPTY
13004: ST_TO_ADDR
// for M in Miny do
13005: LD_ADDR_VAR 0 1
13009: PUSH
13010: LD_LOC 28
13014: PUSH
13015: FOR_IN
13016: IFFALSE 13063
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
13018: LD_VAR 0 1
13022: PUSH
13023: LD_INT 1
13025: ARRAY
13026: PPUSH
13027: LD_VAR 0 1
13031: PUSH
13032: LD_INT 2
13034: ARRAY
13035: PPUSH
13036: CALL 12882 0 2
13040: IFFALSE 13061
// Bouchlo = Bouchlo ^ [ M ] ;
13042: LD_ADDR_VAR 0 2
13046: PUSH
13047: LD_VAR 0 2
13051: PUSH
13052: LD_VAR 0 1
13056: PUSH
13057: EMPTY
13058: LIST
13059: ADD
13060: ST_TO_ADDR
13061: GO 13015
13063: POP
13064: POP
// if Bouchlo then
13065: LD_VAR 0 2
13069: IFFALSE 13087
// Miny = Miny diff Bouchlo ;
13071: LD_ADDR_LOC 28
13075: PUSH
13076: LD_LOC 28
13080: PUSH
13081: LD_VAR 0 2
13085: DIFF
13086: ST_TO_ADDR
// if Miny then
13087: LD_LOC 28
13091: IFFALSE 13094
// enable ;
13093: ENABLE
// end ; end_of_file
13094: PPOPN 2
13096: END
// export Yashin , YashinAutak ; var Zacal , Nastupuje , Nastoupil , Odjizdi ; var Bunkr ; var YashinPovoleneZbrane ; export function init_yashin ; begin
13097: LD_INT 0
13099: PPUSH
// disable ( 51 ) ;
13100: LD_INT 51
13102: DISABLE_MARKED
// disable ( 52 ) ;
13103: LD_INT 52
13105: DISABLE_MARKED
// disable ( 53 ) ;
13106: LD_INT 53
13108: DISABLE_MARKED
// disable ( 54 ) ;
13109: LD_INT 54
13111: DISABLE_MARKED
// disable ( 55 ) ;
13112: LD_INT 55
13114: DISABLE_MARKED
// disable ( 56 ) ;
13115: LD_INT 56
13117: DISABLE_MARKED
// disable ( 57 ) ;
13118: LD_INT 57
13120: DISABLE_MARKED
// Yashin = 0 ;
13121: LD_ADDR_EXP 34
13125: PUSH
13126: LD_INT 0
13128: ST_TO_ADDR
// YashinAutak = 0 ;
13129: LD_ADDR_EXP 35
13133: PUSH
13134: LD_INT 0
13136: ST_TO_ADDR
// Zacal = false ;
13137: LD_ADDR_LOC 31
13141: PUSH
13142: LD_INT 0
13144: ST_TO_ADDR
// Nastupuje = false ;
13145: LD_ADDR_LOC 32
13149: PUSH
13150: LD_INT 0
13152: ST_TO_ADDR
// Nastoupil = false ;
13153: LD_ADDR_LOC 33
13157: PUSH
13158: LD_INT 0
13160: ST_TO_ADDR
// Odjizdi = false ;
13161: LD_ADDR_LOC 34
13165: PUSH
13166: LD_INT 0
13168: ST_TO_ADDR
// Bunkr = 0 ;
13169: LD_ADDR_LOC 35
13173: PUSH
13174: LD_INT 0
13176: ST_TO_ADDR
// YashinPovoleneZbrane = [ RU_HEAVY_MACHINE_GUN , RU_GATLING_GUN , RU_GUN , RU_ROCKET_LAUNCHER , RU_HEAVY_GUN , RU_ROCKET ] ;
13177: LD_ADDR_LOC 36
13181: PUSH
13182: LD_INT 42
13184: PUSH
13185: LD_INT 43
13187: PUSH
13188: LD_INT 44
13190: PUSH
13191: LD_INT 45
13193: PUSH
13194: LD_INT 46
13196: PUSH
13197: LD_INT 47
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: ST_TO_ADDR
// end ;
13208: LD_VAR 0 1
13212: RET
// export function yashin_start_timer ; begin
13213: LD_INT 0
13215: PPUSH
// if not Zacal then
13216: LD_LOC 31
13220: NOT
13221: IFFALSE 13234
// begin enable ( 51 ) ;
13223: LD_INT 51
13225: ENABLE_MARKED
// Zacal = true ;
13226: LD_ADDR_LOC 31
13230: PUSH
13231: LD_INT 1
13233: ST_TO_ADDR
// end ; end ;
13234: LD_VAR 0 1
13238: RET
// function vytvor_yashina ; begin
13239: LD_INT 0
13241: PPUSH
// Yashin = NewCharacter ( Yashin ) ;
13242: LD_ADDR_EXP 34
13246: PUSH
13247: LD_STRING Yashin
13249: PPUSH
13250: CALL_OW 25
13254: ST_TO_ADDR
// SetClass ( Yashin , CLASS_BAZOOKER ) ;
13255: LD_EXP 34
13259: PPUSH
13260: LD_INT 9
13262: PPUSH
13263: CALL_OW 336
// SetSide ( Yashin , side_Ru2 ) ;
13267: LD_EXP 34
13271: PPUSH
13272: LD_EXP 3
13276: PPUSH
13277: CALL_OW 235
// DoNotAttack ( side_Ar , Yashin ) ;
13281: LD_EXP 4
13285: PPUSH
13286: LD_EXP 34
13290: PPUSH
13291: CALL_OW 471
// end ;
13295: LD_VAR 0 1
13299: RET
// function yashin_start ; var Vysledek , Area , Bunkry ; begin
13300: LD_INT 0
13302: PPUSH
13303: PPUSH
13304: PPUSH
13305: PPUSH
// vytvor_yashina ;
13306: CALL 13239 0 0
// if VsevSaved then
13310: LD_EXP 8
13314: IFFALSE 13341
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13316: LD_EXP 34
13320: PPUSH
13321: LD_INT 39
13323: PPUSH
13324: LD_INT 0
13326: PPUSH
13327: CALL_OW 49
// Area = YashinCil1 ;
13331: LD_ADDR_VAR 0 3
13335: PUSH
13336: LD_INT 31
13338: ST_TO_ADDR
// end else
13339: GO 13364
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13341: LD_EXP 34
13345: PPUSH
13346: LD_INT 39
13348: PPUSH
13349: LD_INT 0
13351: PPUSH
13352: CALL_OW 49
// Area = YashinCil1a ;
13356: LD_ADDR_VAR 0 3
13360: PUSH
13361: LD_INT 32
13363: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Area ) then
13364: LD_EXP 10
13368: PPUSH
13369: LD_VAR 0 3
13373: PPUSH
13374: CALL_OW 308
13378: IFFALSE 13411
// ComMoveXY ( Yashin , GetX ( Burlak ) , GetY ( Burlak ) ) else
13380: LD_EXP 34
13384: PPUSH
13385: LD_EXP 10
13389: PPUSH
13390: CALL_OW 250
13394: PPUSH
13395: LD_EXP 10
13399: PPUSH
13400: CALL_OW 251
13404: PPUSH
13405: CALL_OW 111
13409: GO 13425
// ComMoveToArea ( Yashin , Area ) ;
13411: LD_EXP 34
13415: PPUSH
13416: LD_VAR 0 3
13420: PPUSH
13421: CALL_OW 113
// CenterOnUnits ( Yashin ) ;
13425: LD_EXP 34
13429: PPUSH
13430: CALL_OW 85
// Wait ( 0 0$4 ) ;
13434: LD_INT 140
13436: PPUSH
13437: CALL_OW 67
// DialogueOn ;
13441: CALL_OW 6
// dialog_YashinArrives ;
13445: CALL 22158 0 0
// Bunkry = yashin_zjisti_bunkry ;
13449: LD_ADDR_VAR 0 4
13453: PUSH
13454: CALL 14352 0 0
13458: ST_TO_ADDR
// if Bunkry then
13459: LD_VAR 0 4
13463: IFFALSE 13477
// Vysledek = query_YashinHelp else
13465: LD_ADDR_VAR 0 2
13469: PUSH
13470: CALL 22384 0 0
13474: ST_TO_ADDR
13475: GO 13487
// Vysledek = query_YashinHelpNB ;
13477: LD_ADDR_VAR 0 2
13481: PUSH
13482: CALL 22405 0 0
13486: ST_TO_ADDR
// if Vysledek = 1 then
13487: LD_VAR 0 2
13491: PUSH
13492: LD_INT 1
13494: EQUAL
13495: IFFALSE 13540
// begin dialog_QrYashinHelp1 ;
13497: CALL 22436 0 0
// DialogueOff ;
13501: CALL_OW 7
// Bunkr = Bunkry [ Rand ( 1 , Bunkry ) ] ;
13505: LD_ADDR_LOC 35
13509: PUSH
13510: LD_VAR 0 4
13514: PUSH
13515: LD_INT 1
13517: PPUSH
13518: LD_VAR 0 4
13522: PPUSH
13523: CALL_OW 12
13527: ARRAY
13528: ST_TO_ADDR
// yashin_znic_bunkr ( Area ) ;
13529: LD_VAR 0 3
13533: PPUSH
13534: CALL 14483 0 1
// end else
13538: GO 13572
// begin if Vysledek = 2 then
13540: LD_VAR 0 2
13544: PUSH
13545: LD_INT 2
13547: EQUAL
13548: IFFALSE 13556
// dialog_QrYashinHelp2 else
13550: CALL 22492 0 0
13554: GO 13560
// dialog_QrYashinHelp3 ;
13556: CALL 22524 0 0
// dialog_YashinLeave ;
13560: CALL 22556 0 0
// DialogueOff ;
13564: CALL_OW 7
// yashin_vyzadej_autak ;
13568: CALL 14202 0 0
// end ; enable ( 53 ) ;
13572: LD_INT 53
13574: ENABLE_MARKED
// enable ( 57 ) ;
13575: LD_INT 57
13577: ENABLE_MARKED
// end ;
13578: LD_VAR 0 1
13582: RET
// function yashin_chci_autak ; var I , Temp , Kde , Volne , Dalka , Ridic ; begin
13583: LD_INT 0
13585: PPUSH
13586: PPUSH
13587: PPUSH
13588: PPUSH
13589: PPUSH
13590: PPUSH
13591: PPUSH
// if YashinAutak then
13592: LD_EXP 35
13596: IFFALSE 13748
// begin if not IsOK ( YashinAutak ) or ( GetSide ( YashinAutak ) <> side_Ru2 ) then
13598: LD_EXP 35
13602: PPUSH
13603: CALL_OW 302
13607: NOT
13608: PUSH
13609: LD_EXP 35
13613: PPUSH
13614: CALL_OW 255
13618: PUSH
13619: LD_EXP 3
13623: NONEQUAL
13624: OR
13625: IFFALSE 13637
// begin YashinAutak = 0 ;
13627: LD_ADDR_EXP 35
13631: PUSH
13632: LD_INT 0
13634: ST_TO_ADDR
// end else
13635: GO 13748
// begin Ridic = IsDrivenBy ( YashinAutak ) ;
13637: LD_ADDR_VAR 0 7
13641: PUSH
13642: LD_EXP 35
13646: PPUSH
13647: CALL_OW 311
13651: ST_TO_ADDR
// if Ridic = Yashin then
13652: LD_VAR 0 7
13656: PUSH
13657: LD_EXP 34
13661: EQUAL
13662: IFFALSE 13697
// begin Nastupuje = false ;
13664: LD_ADDR_LOC 32
13668: PUSH
13669: LD_INT 0
13671: ST_TO_ADDR
// Nastoupil = true ;
13672: LD_ADDR_LOC 33
13676: PUSH
13677: LD_INT 1
13679: ST_TO_ADDR
// disable ( 55 ) ;
13680: LD_INT 55
13682: DISABLE_MARKED
// yashin_zacni_odjizdet ;
13683: CALL 14240 0 0
// Result = true ;
13687: LD_ADDR_VAR 0 1
13691: PUSH
13692: LD_INT 1
13694: ST_TO_ADDR
// exit ;
13695: GO 14197
// end ; if Ridic then
13697: LD_VAR 0 7
13701: IFFALSE 13722
// begin ComCancel ( Yashin ) ;
13703: LD_EXP 34
13707: PPUSH
13708: CALL_OW 127
// YashinAutak = 0 ;
13712: LD_ADDR_EXP 35
13716: PUSH
13717: LD_INT 0
13719: ST_TO_ADDR
// end else
13720: GO 13748
// begin if not HasTask ( Yashin ) then
13722: LD_EXP 34
13726: PPUSH
13727: CALL_OW 314
13731: NOT
13732: IFFALSE 13748
// ComEnterUnit ( Yashin , YashinAutak ) ;
13734: LD_EXP 34
13738: PPUSH
13739: LD_EXP 35
13743: PPUSH
13744: CALL_OW 120
// end ; end ; end ; Kde = IsInUnit ( Yashin ) ;
13748: LD_ADDR_VAR 0 4
13752: PUSH
13753: LD_EXP 34
13757: PPUSH
13758: CALL_OW 310
13762: ST_TO_ADDR
// if ( Kde <> 0 ) then
13763: LD_VAR 0 4
13767: PUSH
13768: LD_INT 0
13770: NONEQUAL
13771: IFFALSE 13862
// begin if GetType ( Kde ) = UNIT_VEHICLE then
13773: LD_VAR 0 4
13777: PPUSH
13778: CALL_OW 247
13782: PUSH
13783: LD_INT 2
13785: EQUAL
13786: IFFALSE 13831
// begin Nastupuje = false ;
13788: LD_ADDR_LOC 32
13792: PUSH
13793: LD_INT 0
13795: ST_TO_ADDR
// Nastoupil = true ;
13796: LD_ADDR_LOC 33
13800: PUSH
13801: LD_INT 1
13803: ST_TO_ADDR
// disable ( 55 ) ;
13804: LD_INT 55
13806: DISABLE_MARKED
// YashinAutak = Kde ;
13807: LD_ADDR_EXP 35
13811: PUSH
13812: LD_VAR 0 4
13816: ST_TO_ADDR
// yashin_zacni_odjizdet ;
13817: CALL 14240 0 0
// Result = true ;
13821: LD_ADDR_VAR 0 1
13825: PUSH
13826: LD_INT 1
13828: ST_TO_ADDR
// exit ;
13829: GO 14197
// end ; if GetType ( Kde ) = UNIT_BUILDING then
13831: LD_VAR 0 4
13835: PPUSH
13836: CALL_OW 247
13840: PUSH
13841: LD_INT 3
13843: EQUAL
13844: IFFALSE 13862
// begin ComExitBuilding ( Yashin ) ;
13846: LD_EXP 34
13850: PPUSH
13851: CALL_OW 122
// Wait ( 0 0$0.25 ) ;
13855: LD_INT 9
13857: PPUSH
13858: CALL_OW 67
// end ; end ; Result = false ;
13862: LD_ADDR_VAR 0 1
13866: PUSH
13867: LD_INT 0
13869: ST_TO_ADDR
// if HasTask ( Yashin ) then
13870: LD_EXP 34
13874: PPUSH
13875: CALL_OW 314
13879: IFFALSE 13883
// exit ;
13881: GO 14197
// Volne = [ ] ;
13883: LD_ADDR_VAR 0 5
13887: PUSH
13888: EMPTY
13889: ST_TO_ADDR
// Temp = FilterUnitsExceptArea ( Nebezpeci , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
13890: LD_ADDR_VAR 0 3
13894: PUSH
13895: LD_INT 34
13897: PPUSH
13898: LD_INT 22
13900: PUSH
13901: LD_EXP 2
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: LD_INT 21
13912: PUSH
13913: LD_INT 2
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: PUSH
13920: LD_INT 50
13922: PUSH
13923: EMPTY
13924: LIST
13925: PUSH
13926: LD_INT 33
13928: PUSH
13929: LD_INT 1
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: PPUSH
13942: CALL_OW 71
13946: ST_TO_ADDR
// for I in Temp do
13947: LD_ADDR_VAR 0 2
13951: PUSH
13952: LD_VAR 0 3
13956: PUSH
13957: FOR_IN
13958: IFFALSE 14046
// begin if IsDrivenBy ( I ) then
13960: LD_VAR 0 2
13964: PPUSH
13965: CALL_OW 311
13969: IFFALSE 13973
// continue ;
13971: GO 13957
// if ( GetEngine ( I ) = ENGINE_COMBUSTION ) and ( GetFuel ( I ) < 50 ) then
13973: LD_VAR 0 2
13977: PPUSH
13978: CALL_OW 262
13982: PUSH
13983: LD_INT 1
13985: EQUAL
13986: PUSH
13987: LD_VAR 0 2
13991: PPUSH
13992: CALL_OW 261
13996: PUSH
13997: LD_INT 50
13999: LESS
14000: AND
14001: IFFALSE 14005
// continue ;
14003: GO 13957
// if not GetWeapon ( I ) in YashinPovoleneZbrane then
14005: LD_VAR 0 2
14009: PPUSH
14010: CALL_OW 264
14014: PUSH
14015: LD_LOC 36
14019: IN
14020: NOT
14021: IFFALSE 14025
// continue ;
14023: GO 13957
// Volne = Volne union [ I ] ;
14025: LD_ADDR_VAR 0 5
14029: PUSH
14030: LD_VAR 0 5
14034: PUSH
14035: LD_VAR 0 2
14039: PUSH
14040: EMPTY
14041: LIST
14042: UNION
14043: ST_TO_ADDR
// end ;
14044: GO 13957
14046: POP
14047: POP
// if not Volne then
14048: LD_VAR 0 5
14052: NOT
14053: IFFALSE 14057
// exit ;
14055: GO 14197
// YashinAutak = Volne [ 1 ] ;
14057: LD_ADDR_EXP 35
14061: PUSH
14062: LD_VAR 0 5
14066: PUSH
14067: LD_INT 1
14069: ARRAY
14070: ST_TO_ADDR
// Dalka = GetDistUnits ( Yashin , YashinAutak ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_EXP 34
14080: PPUSH
14081: LD_EXP 35
14085: PPUSH
14086: CALL_OW 296
14090: ST_TO_ADDR
// for I in ( Volne diff [ YashinAutak ] ) do
14091: LD_ADDR_VAR 0 2
14095: PUSH
14096: LD_VAR 0 5
14100: PUSH
14101: LD_EXP 35
14105: PUSH
14106: EMPTY
14107: LIST
14108: DIFF
14109: PUSH
14110: FOR_IN
14111: IFFALSE 14167
// begin Temp = GetDistUnits ( Yashin , I ) ;
14113: LD_ADDR_VAR 0 3
14117: PUSH
14118: LD_EXP 34
14122: PPUSH
14123: LD_VAR 0 2
14127: PPUSH
14128: CALL_OW 296
14132: ST_TO_ADDR
// if Temp < Dalka then
14133: LD_VAR 0 3
14137: PUSH
14138: LD_VAR 0 6
14142: LESS
14143: IFFALSE 14165
// begin Dalka = Temp ;
14145: LD_ADDR_VAR 0 6
14149: PUSH
14150: LD_VAR 0 3
14154: ST_TO_ADDR
// YashinAutak = I ;
14155: LD_ADDR_EXP 35
14159: PUSH
14160: LD_VAR 0 2
14164: ST_TO_ADDR
// end ; end ;
14165: GO 14110
14167: POP
14168: POP
// ComEnterUnit ( Yashin , YashinAutak ) ;
14169: LD_EXP 34
14173: PPUSH
14174: LD_EXP 35
14178: PPUSH
14179: CALL_OW 120
// SetSide ( YashinAutak , side_Ru2 ) ;
14183: LD_EXP 35
14187: PPUSH
14188: LD_EXP 3
14192: PPUSH
14193: CALL_OW 235
// end ;
14197: LD_VAR 0 1
14201: RET
// function yashin_vyzadej_autak ; begin
14202: LD_INT 0
14204: PPUSH
// Nastupuje = true ;
14205: LD_ADDR_LOC 32
14209: PUSH
14210: LD_INT 1
14212: ST_TO_ADDR
// ComCancel ( Yashin ) ;
14213: LD_EXP 34
14217: PPUSH
14218: CALL_OW 127
// if not yashin_chci_autak then
14222: CALL 13583 0 0
14226: NOT
14227: IFFALSE 14235
// begin enable ( 54 ) ;
14229: LD_INT 54
14231: ENABLE_MARKED
// enable ( 55 ) ;
14232: LD_INT 55
14234: ENABLE_MARKED
// end ; end ;
14235: LD_VAR 0 1
14239: RET
// function yashin_zacni_odjizdet ; begin
14240: LD_INT 0
14242: PPUSH
// Odjizdi = true ;
14243: LD_ADDR_LOC 34
14247: PUSH
14248: LD_INT 1
14250: ST_TO_ADDR
// disable ( 54 ) ;
14251: LD_INT 54
14253: DISABLE_MARKED
// disable ( 55 ) ;
14254: LD_INT 55
14256: DISABLE_MARKED
// disable ( 56 ) ;
14257: LD_INT 56
14259: DISABLE_MARKED
// if not yashin_odjizdi then
14260: CALL 14275 0 0
14264: NOT
14265: IFFALSE 14270
// enable ( 52 ) ;
14267: LD_INT 52
14269: ENABLE_MARKED
// end ;
14270: LD_VAR 0 1
14274: RET
// function yashin_odjizdi ; var Jednotka ; begin
14275: LD_INT 0
14277: PPUSH
14278: PPUSH
// if YashinAutak then
14279: LD_EXP 35
14283: IFFALSE 14297
// Jednotka = YashinAutak else
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: LD_EXP 35
14294: ST_TO_ADDR
14295: GO 14307
// Jednotka = Yashin ;
14297: LD_ADDR_VAR 0 2
14301: PUSH
14302: LD_EXP 34
14306: ST_TO_ADDR
// if IsInArea ( Jednotka , YashinExit ) then
14307: LD_VAR 0 2
14311: PPUSH
14312: LD_INT 33
14314: PPUSH
14315: CALL_OW 308
14319: IFFALSE 14335
// begin yashin_odstran ;
14321: CALL 15092 0 0
// Result = true ;
14325: LD_ADDR_VAR 0 1
14329: PUSH
14330: LD_INT 1
14332: ST_TO_ADDR
// end else
14333: GO 14347
// begin ComMoveToArea ( Jednotka , YashinExit ) ;
14335: LD_VAR 0 2
14339: PPUSH
14340: LD_INT 33
14342: PPUSH
14343: CALL_OW 113
// end ; end ;
14347: LD_VAR 0 1
14351: RET
// function yashin_zjisti_bunkry ; var Domy ; begin
14352: LD_INT 0
14354: PPUSH
14355: PPUSH
// Domy = FilterUnitsInArea ( AraboveBunkry , [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
14356: LD_ADDR_VAR 0 2
14360: PUSH
14361: LD_INT 35
14363: PPUSH
14364: LD_INT 22
14366: PUSH
14367: LD_EXP 4
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: LD_INT 50
14378: PUSH
14379: EMPTY
14380: LIST
14381: PUSH
14382: LD_INT 21
14384: PUSH
14385: LD_INT 3
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: PPUSH
14397: CALL_OW 70
14401: ST_TO_ADDR
// Result = UnitFilter ( Domy , [ [ F_BTYPE , B_BREASTWORK ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_BUNKER ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_TURRET ] ] ) ;
14402: LD_ADDR_VAR 0 1
14406: PUSH
14407: LD_VAR 0 2
14411: PPUSH
14412: LD_INT 30
14414: PUSH
14415: LD_INT 31
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: EMPTY
14423: LIST
14424: PPUSH
14425: CALL_OW 72
14429: PUSH
14430: LD_VAR 0 2
14434: PPUSH
14435: LD_INT 30
14437: PUSH
14438: LD_INT 32
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: EMPTY
14446: LIST
14447: PPUSH
14448: CALL_OW 72
14452: UNION
14453: PUSH
14454: LD_VAR 0 2
14458: PPUSH
14459: LD_INT 30
14461: PUSH
14462: LD_INT 33
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: EMPTY
14470: LIST
14471: PPUSH
14472: CALL_OW 72
14476: UNION
14477: ST_TO_ADDR
// end ;
14478: LD_VAR 0 1
14482: RET
// function yashin_znic_bunkr ( Zpatky ) ; begin
14483: LD_INT 0
14485: PPUSH
// ComAgressiveMove ( Yashin , 32 , 29 ) ;
14486: LD_EXP 34
14490: PPUSH
14491: LD_INT 32
14493: PPUSH
14494: LD_INT 29
14496: PPUSH
14497: CALL_OW 114
// AddComSailEvent ( Yashin , 111 ) ;
14501: LD_EXP 34
14505: PPUSH
14506: LD_INT 111
14508: PPUSH
14509: CALL_OW 224
// AddComAttackUnit ( Yashin , Bunkr ) ;
14513: LD_EXP 34
14517: PPUSH
14518: LD_LOC 35
14522: PPUSH
14523: CALL_OW 175
// AddComAgressiveMove ( Yashin , 33 , 35 ) ;
14527: LD_EXP 34
14531: PPUSH
14532: LD_INT 33
14534: PPUSH
14535: LD_INT 35
14537: PPUSH
14538: CALL_OW 174
// AddComMoveToArea ( Yashin , Zpatky ) ;
14542: LD_EXP 34
14546: PPUSH
14547: LD_VAR 0 1
14551: PPUSH
14552: CALL_OW 173
// enable ( 56 ) ;
14556: LD_INT 56
14558: ENABLE_MARKED
// end ;
14559: LD_VAR 0 2
14563: RET
// export function event_YashinUtoci ; begin
14564: LD_INT 0
14566: PPUSH
// RevealFogArea ( side_Ru , AraboveBunkry ) ;
14567: LD_EXP 2
14571: PPUSH
14572: LD_INT 35
14574: PPUSH
14575: CALL_OW 332
// end ;
14579: LD_VAR 0 1
14583: RET
// export function yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14584: LD_INT 0
14586: PPUSH
// if Nastupuje and ( VehOld = YashinAutak ) then
14587: LD_LOC 32
14591: PUSH
14592: LD_VAR 0 2
14596: PUSH
14597: LD_EXP 35
14601: EQUAL
14602: AND
14603: IFFALSE 14615
// YashinAutak = VehNew ;
14605: LD_ADDR_EXP 35
14609: PUSH
14610: LD_VAR 0 1
14614: ST_TO_ADDR
// end ;
14615: LD_VAR 0 5
14619: RET
// every 0 0$1.3 marked 52 do
14620: GO 14622
14622: DISABLE
// begin if not yashin_odjizdi then
14623: CALL 14275 0 0
14627: NOT
14628: IFFALSE 14631
// enable ;
14630: ENABLE
// end ;
14631: END
// every 0 0$2.7 marked 54 do
14632: GO 14634
14634: DISABLE
// begin if not yashin_chci_autak then
14635: CALL 13583 0 0
14639: NOT
14640: IFFALSE 14643
// enable ;
14642: ENABLE
// end ;
14643: END
// every 5 5$3 marked 55 do
14644: GO 14646
14646: DISABLE
// begin if Nastoupil then
14647: LD_LOC 33
14651: IFFALSE 14655
// exit ;
14653: GO 14677
// DialogueOn ;
14655: CALL_OW 6
// CenterOnUnits ( Yashin ) ;
14659: LD_EXP 34
14663: PPUSH
14664: CALL_OW 85
// dialog_YashinLeave ;
14668: CALL 22556 0 0
// DialogueOff ;
14672: CALL_OW 7
// enable ;
14676: ENABLE
// end ;
14677: END
// every 0 0$7.1 trigger ( not IsOK ( Bunkr ) ) or ( GetSide ( Bunkr ) <> side_Ar ) marked 56 do
14678: LD_LOC 35
14682: PPUSH
14683: CALL_OW 302
14687: NOT
14688: PUSH
14689: LD_LOC 35
14693: PPUSH
14694: CALL_OW 255
14698: PUSH
14699: LD_EXP 4
14703: NONEQUAL
14704: OR
14705: IFFALSE 14738
14707: GO 14709
14709: DISABLE
// begin RevealFogArea ( side_Ru , AraboveBunkry ) ;
14710: LD_EXP 2
14714: PPUSH
14715: LD_INT 35
14717: PPUSH
14718: CALL_OW 332
// DialogueOn ;
14722: CALL_OW 6
// dialog_YashinLeave ;
14726: CALL 22556 0 0
// dialogueOff ;
14730: CALL_OW 7
// yashin_vyzadej_autak ;
14734: CALL 14202 0 0
// end ;
14738: END
// every 2 2$55 marked 51 do
14739: GO 14741
14741: DISABLE
// begin Wait ( MultiRand ( 0 0$1 , 2 2$0 , 2 ) ) ;
14742: LD_INT 35
14744: PPUSH
14745: LD_INT 4200
14747: PPUSH
14748: LD_INT 2
14750: PPUSH
14751: CALL_OW 14
14755: PPUSH
14756: CALL_OW 67
// yashin_start ;
14760: CALL 13300 0 0
// end ;
14764: END
// every 0 0$0.7 marked 53 do var Jednotky , Kdo , Cile , Utoci ;
14765: GO 14767
14767: DISABLE
14768: LD_INT 0
14770: PPUSH
14771: PPUSH
14772: PPUSH
14773: PPUSH
// begin Kdo = IsInUnit ( Yashin ) ;
14774: LD_ADDR_VAR 0 2
14778: PUSH
14779: LD_EXP 34
14783: PPUSH
14784: CALL_OW 310
14788: ST_TO_ADDR
// if Kdo then
14789: LD_VAR 0 2
14793: IFFALSE 14816
// Cile = [ Yashin , Kdo ] else
14795: LD_ADDR_VAR 0 3
14799: PUSH
14800: LD_EXP 34
14804: PUSH
14805: LD_VAR 0 2
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: ST_TO_ADDR
14814: GO 14829
// Cile = [ Yashin ] ;
14816: LD_ADDR_VAR 0 3
14820: PUSH
14821: LD_EXP 34
14825: PUSH
14826: EMPTY
14827: LIST
14828: ST_TO_ADDR
// Utoci = false ;
14829: LD_ADDR_VAR 0 4
14833: PUSH
14834: LD_INT 0
14836: ST_TO_ADDR
// Jednotky = FilterAllUnits ( [ [ F_OK ] , [ F_SIDE , side_Ru ] ] ) ;
14837: LD_ADDR_VAR 0 1
14841: PUSH
14842: LD_INT 50
14844: PUSH
14845: EMPTY
14846: LIST
14847: PUSH
14848: LD_INT 22
14850: PUSH
14851: LD_EXP 2
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PPUSH
14864: CALL_OW 69
14868: ST_TO_ADDR
// for Kdo in Jednotky do
14869: LD_ADDR_VAR 0 2
14873: PUSH
14874: LD_VAR 0 1
14878: PUSH
14879: FOR_IN
14880: IFFALSE 14944
// begin if ( WantsToAttack ( Kdo ) in Cile ) or ( Attacks ( Kdo ) in Cile ) then
14882: LD_VAR 0 2
14886: PPUSH
14887: CALL_OW 319
14891: PUSH
14892: LD_VAR 0 3
14896: IN
14897: PUSH
14898: LD_VAR 0 2
14902: PPUSH
14903: CALL_OW 320
14907: PUSH
14908: LD_VAR 0 3
14912: IN
14913: OR
14914: IFFALSE 14942
// begin ComCancel ( Kdo ) ;
14916: LD_VAR 0 2
14920: PPUSH
14921: CALL_OW 127
// ComHold ( Kdo ) ;
14925: LD_VAR 0 2
14929: PPUSH
14930: CALL_OW 140
// Utoci = true ;
14934: LD_ADDR_VAR 0 4
14938: PUSH
14939: LD_INT 1
14941: ST_TO_ADDR
// end ; end ;
14942: GO 14879
14944: POP
14945: POP
// if Utoci then
14946: LD_VAR 0 4
14950: IFFALSE 14975
// begin DialogueOn ;
14952: CALL_OW 6
// dialog_YashinAttack ;
14956: CALL 22610 0 0
// DialogueOff ;
14960: CALL_OW 7
// if not Odjizdi then
14964: LD_LOC 34
14968: NOT
14969: IFFALSE 14975
// yashin_zacni_odjizdet ;
14971: CALL 14240 0 0
// end ; enable ;
14975: ENABLE
// end ;
14976: PPOPN 4
14978: END
// every 0 0$0.6 marked 57 do var L ;
14979: GO 14981
14981: DISABLE
14982: LD_INT 0
14984: PPUSH
// begin L = GetLives ( Yashin ) ;
14985: LD_ADDR_VAR 0 1
14989: PUSH
14990: LD_EXP 34
14994: PPUSH
14995: CALL_OW 256
14999: ST_TO_ADDR
// if L < 1000 then
15000: LD_VAR 0 1
15004: PUSH
15005: LD_INT 1000
15007: LESS
15008: IFFALSE 15056
// begin L = L + 20 ;
15010: LD_ADDR_VAR 0 1
15014: PUSH
15015: LD_VAR 0 1
15019: PUSH
15020: LD_INT 20
15022: PLUS
15023: ST_TO_ADDR
// if L > 1000 then
15024: LD_VAR 0 1
15028: PUSH
15029: LD_INT 1000
15031: GREATER
15032: IFFALSE 15042
// L = 1000 ;
15034: LD_ADDR_VAR 0 1
15038: PUSH
15039: LD_INT 1000
15041: ST_TO_ADDR
// SetLives ( Yashin , L ) ;
15042: LD_EXP 34
15046: PPUSH
15047: LD_VAR 0 1
15051: PPUSH
15052: CALL_OW 234
// end ; enable ;
15056: ENABLE
// end ;
15057: PPOPN 1
15059: END
// export function yashin_UnitGoesToRed ( Un ) ; begin
15060: LD_INT 0
15062: PPUSH
// if Un = Yashin then
15063: LD_VAR 0 1
15067: PUSH
15068: LD_EXP 34
15072: EQUAL
15073: IFFALSE 15087
// SetLives ( Yashin , 300 ) ;
15075: LD_EXP 34
15079: PPUSH
15080: LD_INT 300
15082: PPUSH
15083: CALL_OW 234
// end ;
15087: LD_VAR 0 2
15091: RET
// function yashin_odstran ; begin
15092: LD_INT 0
15094: PPUSH
// if YashinAutak then
15095: LD_EXP 35
15099: IFFALSE 15110
// RemoveUnit ( YashinAutak ) ;
15101: LD_EXP 35
15105: PPUSH
15106: CALL_OW 64
// RemoveUnit ( Yashin ) ;
15110: LD_EXP 34
15114: PPUSH
15115: CALL_OW 64
// disable ( 53 ) ;
15119: LD_INT 53
15121: DISABLE_MARKED
// end ; end_of_file
15122: LD_VAR 0 1
15126: RET
// var KamArea , VraciSe ; var Krade , Nastupuje , KradenyVuz ; export function init_xavier ; begin
15127: LD_INT 0
15129: PPUSH
// KamArea = 0 ;
15130: LD_ADDR_LOC 37
15134: PUSH
15135: LD_INT 0
15137: ST_TO_ADDR
// VraciSe = false ;
15138: LD_ADDR_LOC 38
15142: PUSH
15143: LD_INT 0
15145: ST_TO_ADDR
// Krade = false ;
15146: LD_ADDR_LOC 39
15150: PUSH
15151: LD_INT 0
15153: ST_TO_ADDR
// KradenyVuz = 0 ;
15154: LD_ADDR_LOC 41
15158: PUSH
15159: LD_INT 0
15161: ST_TO_ADDR
// disable ( 21 ) ;
15162: LD_INT 21
15164: DISABLE_MARKED
// disable ( 22 ) ;
15165: LD_INT 22
15167: DISABLE_MARKED
// disable ( 23 ) ;
15168: LD_INT 23
15170: DISABLE_MARKED
// disable ( 24 ) ;
15171: LD_INT 24
15173: DISABLE_MARKED
// disable ( 26 ) ;
15174: LD_INT 26
15176: DISABLE_MARKED
// end ;
15177: LD_VAR 0 1
15181: RET
// function vytvor_xaviera ; begin
15182: LD_INT 0
15184: PPUSH
// Xavier = NewCharacter ( Xavier ) ;
15185: LD_ADDR_EXP 25
15189: PUSH
15190: LD_STRING Xavier
15192: PPUSH
15193: CALL_OW 25
15197: ST_TO_ADDR
// SetSide ( Xavier , side_Xavier ) ;
15198: LD_EXP 25
15202: PPUSH
15203: LD_EXP 5
15207: PPUSH
15208: CALL_OW 235
// end ;
15212: LD_VAR 0 1
15216: RET
// export function xavier_start ; var Vysledek ; begin
15217: LD_INT 0
15219: PPUSH
15220: PPUSH
// vytvor_xaviera ;
15221: CALL 15182 0 0
// if not Yelena or not IsOk ( Yelena ) then
15225: LD_EXP 13
15229: NOT
15230: PUSH
15231: LD_EXP 13
15235: PPUSH
15236: CALL_OW 302
15240: NOT
15241: OR
15242: IFFALSE 15340
// begin SetSide ( Xavier , side_Ar ) ;
15244: LD_EXP 25
15248: PPUSH
15249: LD_EXP 4
15253: PPUSH
15254: CALL_OW 235
// PlaceUnitXYR ( Xavier , GetX ( Burlak ) , GetY ( Burlak ) , 6 , true ) ;
15258: LD_EXP 25
15262: PPUSH
15263: LD_EXP 10
15267: PPUSH
15268: CALL_OW 250
15272: PPUSH
15273: LD_EXP 10
15277: PPUSH
15278: CALL_OW 251
15282: PPUSH
15283: LD_INT 6
15285: PPUSH
15286: LD_INT 1
15288: PPUSH
15289: CALL_OW 50
// Wait ( 0 0$4 ) ;
15293: LD_INT 140
15295: PPUSH
15296: CALL_OW 67
// ComAttackUnit ( Xavier , Burlak ) ;
15300: LD_EXP 25
15304: PPUSH
15305: LD_EXP 10
15309: PPUSH
15310: CALL_OW 115
// if Difficulty = 3 then
15314: LD_OWVAR 67
15318: PUSH
15319: LD_INT 3
15321: EQUAL
15322: IFFALSE 15338
// PriorityAttack ( side_Ar , Burlak ) ;
15324: LD_EXP 4
15328: PPUSH
15329: LD_EXP 10
15333: PPUSH
15334: CALL_OW 470
// exit ;
15338: GO 15580
// end ; PlaceUnitXYR ( Xavier , GetX ( Yelena ) , GetY ( Yelena ) , 6 , true ) ;
15340: LD_EXP 25
15344: PPUSH
15345: LD_EXP 13
15349: PPUSH
15350: CALL_OW 250
15354: PPUSH
15355: LD_EXP 13
15359: PPUSH
15360: CALL_OW 251
15364: PPUSH
15365: LD_INT 6
15367: PPUSH
15368: LD_INT 1
15370: PPUSH
15371: CALL_OW 50
// ComHold ( Xavier ) ;
15375: LD_EXP 25
15379: PPUSH
15380: CALL_OW 140
// Wait ( 0 0$4 ) ;
15384: LD_INT 140
15386: PPUSH
15387: CALL_OW 67
// if not IsInUnit ( Yelena ) then
15391: LD_EXP 13
15395: PPUSH
15396: CALL_OW 310
15400: NOT
15401: IFFALSE 15417
// ComTurnUnit ( Yelena , Xavier ) ;
15403: LD_EXP 13
15407: PPUSH
15408: LD_EXP 25
15412: PPUSH
15413: CALL_OW 119
// ComTurnUnit ( Xavier , Yelena ) ;
15417: LD_EXP 25
15421: PPUSH
15422: LD_EXP 13
15426: PPUSH
15427: CALL_OW 119
// DialogueOn ;
15431: CALL_OW 6
// CenterOnUnits ( Yelena ) ;
15435: LD_EXP 13
15439: PPUSH
15440: CALL_OW 85
// dialog_MeetXavier ;
15444: CALL 21687 0 0
// Vysledek = query_Xavier ;
15448: LD_ADDR_VAR 0 2
15452: PUSH
15453: CALL 21731 0 0
15457: ST_TO_ADDR
// if Vysledek = 1 then
15458: LD_VAR 0 2
15462: PUSH
15463: LD_INT 1
15465: EQUAL
15466: IFFALSE 15492
// begin dialog_QrXavier1 ;
15468: CALL 21752 0 0
// SetSide ( Xavier , side_Ru ) ;
15472: LD_EXP 25
15476: PPUSH
15477: LD_EXP 2
15481: PPUSH
15482: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
15486: CALL 16856 0 0
// end else
15490: GO 15576
// begin SA_LieXavier ;
15492: CALL 22902 0 0
// dialog_QrXavier2 ;
15496: CALL 21885 0 0
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15500: LD_EXP 25
15504: PPUSH
15505: LD_INT 35
15507: PPUSH
15508: LD_INT 350
15510: PPUSH
15511: CALL_OW 12
15515: PPUSH
15516: CALL_OW 142
// if Prob ( 50 ) then
15520: LD_INT 50
15522: PPUSH
15523: CALL_OW 13
15527: IFFALSE 15561
// begin AddComMoveToArea ( Xavier , DropBox ) ;
15529: LD_EXP 25
15533: PPUSH
15534: LD_INT 11
15536: PPUSH
15537: CALL_OW 173
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$15 ) ) ;
15541: LD_EXP 25
15545: PPUSH
15546: LD_INT 175
15548: PPUSH
15549: LD_INT 525
15551: PPUSH
15552: CALL_OW 12
15556: PPUSH
15557: CALL_OW 202
// end ; AddComMoveToArea ( Xavier , AraboveParkoviste ) ;
15561: LD_EXP 25
15565: PPUSH
15566: LD_INT 18
15568: PPUSH
15569: CALL_OW 173
// enable ( 21 ) ;
15573: LD_INT 21
15575: ENABLE_MARKED
// end ; DialogueOff ;
15576: CALL_OW 7
// end ;
15580: LD_VAR 0 1
15584: RET
// function xavier_kolecko ; begin
15585: LD_INT 0
15587: PPUSH
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15588: LD_EXP 25
15592: PPUSH
15593: LD_INT 82
15595: PPUSH
15596: LD_INT 1
15598: PPUSH
15599: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15603: LD_EXP 25
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: LD_INT 175
15613: PPUSH
15614: CALL_OW 12
15618: PPUSH
15619: CALL_OW 202
// AddComMoveXY ( Xavier , 72 , 7 ) ;
15623: LD_EXP 25
15627: PPUSH
15628: LD_INT 72
15630: PPUSH
15631: LD_INT 7
15633: PPUSH
15634: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15638: LD_EXP 25
15642: PPUSH
15643: LD_INT 35
15645: PPUSH
15646: LD_INT 175
15648: PPUSH
15649: CALL_OW 12
15653: PPUSH
15654: CALL_OW 202
// AddComMoveXY ( Xavier , 76 , 17 ) ;
15658: LD_EXP 25
15662: PPUSH
15663: LD_INT 76
15665: PPUSH
15666: LD_INT 17
15668: PPUSH
15669: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15673: LD_EXP 25
15677: PPUSH
15678: LD_INT 35
15680: PPUSH
15681: LD_INT 175
15683: PPUSH
15684: CALL_OW 12
15688: PPUSH
15689: CALL_OW 202
// AddComMoveXY ( Xavier , 85 , 17 ) ;
15693: LD_EXP 25
15697: PPUSH
15698: LD_INT 85
15700: PPUSH
15701: LD_INT 17
15703: PPUSH
15704: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15708: LD_EXP 25
15712: PPUSH
15713: LD_INT 35
15715: PPUSH
15716: LD_INT 175
15718: PPUSH
15719: CALL_OW 12
15723: PPUSH
15724: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 14 ) ;
15728: LD_EXP 25
15732: PPUSH
15733: LD_INT 91
15735: PPUSH
15736: LD_INT 14
15738: PPUSH
15739: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$10 ) ) ;
15743: LD_EXP 25
15747: PPUSH
15748: LD_INT 175
15750: PPUSH
15751: LD_INT 350
15753: PPUSH
15754: CALL_OW 12
15758: PPUSH
15759: CALL_OW 202
// AddComMoveXY ( Xavier , 89 , 24 ) ;
15763: LD_EXP 25
15767: PPUSH
15768: LD_INT 89
15770: PPUSH
15771: LD_INT 24
15773: PPUSH
15774: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15778: LD_EXP 25
15782: PPUSH
15783: LD_INT 35
15785: PPUSH
15786: LD_INT 175
15788: PPUSH
15789: CALL_OW 12
15793: PPUSH
15794: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 21 ) ;
15798: LD_EXP 25
15802: PPUSH
15803: LD_INT 102
15805: PPUSH
15806: LD_INT 21
15808: PPUSH
15809: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15813: LD_EXP 25
15817: PPUSH
15818: LD_INT 35
15820: PPUSH
15821: LD_INT 175
15823: PPUSH
15824: CALL_OW 12
15828: PPUSH
15829: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 8 ) ;
15833: LD_EXP 25
15837: PPUSH
15838: LD_INT 102
15840: PPUSH
15841: LD_INT 8
15843: PPUSH
15844: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$0.1 , 0 0$2 ) ) ;
15848: LD_EXP 25
15852: PPUSH
15853: LD_INT 4
15855: PPUSH
15856: LD_INT 70
15858: PPUSH
15859: CALL_OW 12
15863: PPUSH
15864: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 5 ) ;
15868: LD_EXP 25
15872: PPUSH
15873: LD_INT 91
15875: PPUSH
15876: LD_INT 5
15878: PPUSH
15879: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15883: LD_EXP 25
15887: PPUSH
15888: LD_INT 35
15890: PPUSH
15891: LD_INT 175
15893: PPUSH
15894: CALL_OW 12
15898: PPUSH
15899: CALL_OW 202
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15903: LD_EXP 25
15907: PPUSH
15908: LD_INT 82
15910: PPUSH
15911: LD_INT 1
15913: PPUSH
15914: CALL_OW 171
// end ;
15918: LD_VAR 0 1
15922: RET
// function xavier_u_arabu ; begin
15923: LD_INT 0
15925: PPUSH
// xavier_kolecko ;
15926: CALL 15585 0 0
// enable ( 22 ) ;
15930: LD_INT 22
15932: ENABLE_MARKED
// end ;
15933: LD_VAR 0 1
15937: RET
// function xavier_timeout ; begin
15938: LD_INT 0
15940: PPUSH
// ComMoveToArea ( Xavier , DropBox ) ;
15941: LD_EXP 25
15945: PPUSH
15946: LD_INT 11
15948: PPUSH
15949: CALL_OW 113
// enable ( 23 ) ;
15953: LD_INT 23
15955: ENABLE_MARKED
// end ;
15956: LD_VAR 0 1
15960: RET
// function xavier_dropbox ; begin
15961: LD_INT 0
15963: PPUSH
// InGameOn ;
15964: CALL_OW 8
// CenterOnUnits ( Xavier ) ;
15968: LD_EXP 25
15972: PPUSH
15973: CALL_OW 85
// dialog_PointXavier ;
15977: CALL 22042 0 0
// SetAreaMapShow ( DropBoxShow , 1 ) ;
15981: LD_INT 42
15983: PPUSH
15984: LD_INT 1
15986: PPUSH
15987: CALL_OW 424
// Hint ( Xavier ) ;
15991: LD_STRING Xavier
15993: PPUSH
15994: CALL_OW 339
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15998: LD_EXP 25
16002: PPUSH
16003: LD_INT 35
16005: PPUSH
16006: LD_INT 350
16008: PPUSH
16009: CALL_OW 12
16013: PPUSH
16014: CALL_OW 142
// xavier_kolecko ;
16018: CALL 15585 0 0
// enable ( 24 ) ;
16022: LD_INT 24
16024: ENABLE_MARKED
// InGameOff ;
16025: CALL_OW 9
// end ;
16029: LD_VAR 0 1
16033: RET
// function xavier_zpatky ; var Depoty , Kdo ; begin
16034: LD_INT 0
16036: PPUSH
16037: PPUSH
16038: PPUSH
// Kdo = IsInUnit ( Xavier ) ;
16039: LD_ADDR_VAR 0 3
16043: PUSH
16044: LD_EXP 25
16048: PPUSH
16049: CALL_OW 310
16053: ST_TO_ADDR
// if not Kdo then
16054: LD_VAR 0 3
16058: NOT
16059: IFFALSE 16071
// Kdo = Xavier ;
16061: LD_ADDR_VAR 0 3
16065: PUSH
16066: LD_EXP 25
16070: ST_TO_ADDR
// ComAgressiveMove ( Kdo , 32 , 19 ) ;
16071: LD_VAR 0 3
16075: PPUSH
16076: LD_INT 32
16078: PPUSH
16079: LD_INT 19
16081: PPUSH
16082: CALL_OW 114
// if VsevSaved then
16086: LD_EXP 8
16090: IFFALSE 16102
// KamArea = YashinCil1 else
16092: LD_ADDR_LOC 37
16096: PUSH
16097: LD_INT 31
16099: ST_TO_ADDR
16100: GO 16110
// KamArea = YashinCil1a ;
16102: LD_ADDR_LOC 37
16106: PUSH
16107: LD_INT 32
16109: ST_TO_ADDR
// AddComMoveToArea ( Kdo , KamArea ) ;
16110: LD_VAR 0 3
16114: PPUSH
16115: LD_LOC 37
16119: PPUSH
16120: CALL_OW 173
// AddComSailEvent ( Kdo , 121 ) ;
16124: LD_VAR 0 3
16128: PPUSH
16129: LD_INT 121
16131: PPUSH
16132: CALL_OW 224
// VraciSe = true ;
16136: LD_ADDR_LOC 38
16140: PUSH
16141: LD_INT 1
16143: ST_TO_ADDR
// end ;
16144: LD_VAR 0 1
16148: RET
// function xavier_autak ; begin
16149: LD_INT 0
16151: PPUSH
// Krade = true ;
16152: LD_ADDR_LOC 39
16156: PUSH
16157: LD_INT 1
16159: ST_TO_ADDR
// Nastupuje = false ;
16160: LD_ADDR_LOC 40
16164: PUSH
16165: LD_INT 0
16167: ST_TO_ADDR
// enable ( 26 ) ;
16168: LD_INT 26
16170: ENABLE_MARKED
// end ;
16171: LD_VAR 0 1
16175: RET
// function xavier_zkus_krast ; var Volne , Ridic ; begin
16176: LD_INT 0
16178: PPUSH
16179: PPUSH
16180: PPUSH
// Volne = FilterUnitsInArea ( AraboveParkoviste , [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_OK ] ] ) ;
16181: LD_ADDR_VAR 0 2
16185: PUSH
16186: LD_INT 18
16188: PPUSH
16189: LD_INT 22
16191: PUSH
16192: LD_EXP 4
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: LD_INT 21
16203: PUSH
16204: LD_INT 2
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: PUSH
16211: LD_INT 33
16213: PUSH
16214: LD_INT 1
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: PUSH
16221: LD_INT 50
16223: PUSH
16224: EMPTY
16225: LIST
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: PPUSH
16233: CALL_OW 70
16237: ST_TO_ADDR
// Volne = Volne diff UnitFilter ( Volne , [ [ F_WEAPON , AR_CONTROL_TOWER ] ] ) ;
16238: LD_ADDR_VAR 0 2
16242: PUSH
16243: LD_VAR 0 2
16247: PUSH
16248: LD_VAR 0 2
16252: PPUSH
16253: LD_INT 34
16255: PUSH
16256: LD_INT 31
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PUSH
16263: EMPTY
16264: LIST
16265: PPUSH
16266: CALL_OW 72
16270: DIFF
16271: ST_TO_ADDR
// if not Volne then
16272: LD_VAR 0 2
16276: NOT
16277: IFFALSE 16284
// begin enable ( 26 ) ;
16279: LD_INT 26
16281: ENABLE_MARKED
// exit ;
16282: GO 16493
// end ; Nastupuje = true ;
16284: LD_ADDR_LOC 40
16288: PUSH
16289: LD_INT 1
16291: ST_TO_ADDR
// KradenyVuz = Volne [ 1 ] ;
16292: LD_ADDR_LOC 41
16296: PUSH
16297: LD_VAR 0 2
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: ST_TO_ADDR
// Ridic = IsDrivenBy ( KradenyVuz ) ;
16306: LD_ADDR_VAR 0 3
16310: PUSH
16311: LD_LOC 41
16315: PPUSH
16316: CALL_OW 311
16320: ST_TO_ADDR
// if Ridic then
16321: LD_VAR 0 3
16325: IFFALSE 16348
// begin ComExitVehicle ( Ridic ) ;
16327: LD_VAR 0 3
16331: PPUSH
16332: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16336: LD_VAR 0 3
16340: PPUSH
16341: LD_INT 175
16343: PPUSH
16344: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16348: LD_EXP 25
16352: PPUSH
16353: LD_LOC 41
16357: PPUSH
16358: CALL_OW 120
// Wait ( 0 0$3.2 ) ;
16362: LD_INT 112
16364: PPUSH
16365: CALL_OW 67
// while Xavier <> IsDrivenBy ( KradenyVuz ) do
16369: LD_EXP 25
16373: PUSH
16374: LD_LOC 41
16378: PPUSH
16379: CALL_OW 311
16383: NONEQUAL
16384: IFFALSE 16465
// begin Ridic = IsDrivenBy ( KradenyVuz ) ;
16386: LD_ADDR_VAR 0 3
16390: PUSH
16391: LD_LOC 41
16395: PPUSH
16396: CALL_OW 311
16400: ST_TO_ADDR
// if Ridic = Xavier then
16401: LD_VAR 0 3
16405: PUSH
16406: LD_EXP 25
16410: EQUAL
16411: IFFALSE 16415
// break ;
16413: GO 16465
// if Ridic then
16415: LD_VAR 0 3
16419: IFFALSE 16442
// begin ComExitVehicle ( Ridic ) ;
16421: LD_VAR 0 3
16425: PPUSH
16426: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16430: LD_VAR 0 3
16434: PPUSH
16435: LD_INT 175
16437: PPUSH
16438: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16442: LD_EXP 25
16446: PPUSH
16447: LD_LOC 41
16451: PPUSH
16452: CALL_OW 120
// Wait ( 0 0$7.1 ) ;
16456: LD_INT 248
16458: PPUSH
16459: CALL_OW 67
// end ;
16463: GO 16369
// Krade = false ;
16465: LD_ADDR_LOC 39
16469: PUSH
16470: LD_INT 0
16472: ST_TO_ADDR
// Nastupuje = false ;
16473: LD_ADDR_LOC 40
16477: PUSH
16478: LD_INT 0
16480: ST_TO_ADDR
// xavier_zpatky ;
16481: CALL 16034 0 0
// KradenyVuz = 0 ;
16485: LD_ADDR_LOC 41
16489: PUSH
16490: LD_INT 0
16492: ST_TO_ADDR
// end ;
16493: LD_VAR 0 1
16497: RET
// every 0 0$11.7 marked 26 do
16498: GO 16500
16500: DISABLE
// begin xavier_zkus_krast ;
16501: CALL 16176 0 0
// end ;
16505: END
// function xavier_zprava ; var Vysledek ; begin
16506: LD_INT 0
16508: PPUSH
16509: PPUSH
// DialogueOn ;
16510: CALL_OW 6
// Vysledek = query_QActivateXavier ;
16514: LD_ADDR_VAR 0 2
16518: PUSH
16519: CALL 22097 0 0
16523: ST_TO_ADDR
// case Vysledek of 1 :
16524: LD_VAR 0 2
16528: PUSH
16529: LD_INT 1
16531: DOUBLE
16532: EQUAL
16533: IFTRUE 16537
16535: GO 16566
16537: POP
// begin dialog_QrActivateXavier1 ;
16538: CALL 22118 0 0
// xavier_zpatky ;
16542: CALL 16034 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16546: LD_INT 42
16548: PPUSH
16549: LD_INT 0
16551: PPUSH
16552: CALL_OW 424
// Result = true ;
16556: LD_ADDR_VAR 0 1
16560: PUSH
16561: LD_INT 1
16563: ST_TO_ADDR
// end ; 2 :
16564: GO 16612
16566: LD_INT 2
16568: DOUBLE
16569: EQUAL
16570: IFTRUE 16574
16572: GO 16603
16574: POP
// begin dialog_QrActivateXavier2 ;
16575: CALL 22138 0 0
// xavier_autak ;
16579: CALL 16149 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16583: LD_INT 42
16585: PPUSH
16586: LD_INT 0
16588: PPUSH
16589: CALL_OW 424
// Result = true ;
16593: LD_ADDR_VAR 0 1
16597: PUSH
16598: LD_INT 1
16600: ST_TO_ADDR
// end ; else
16601: GO 16612
16603: POP
// Result = false ; end ;
16604: LD_ADDR_VAR 0 1
16608: PUSH
16609: LD_INT 0
16611: ST_TO_ADDR
// DialogueOff ;
16612: CALL_OW 7
// end ;
16616: LD_VAR 0 1
16620: RET
// export function xavier_prisel ; var Autak ; begin
16621: LD_INT 0
16623: PPUSH
16624: PPUSH
// VraciSe = false ;
16625: LD_ADDR_LOC 38
16629: PUSH
16630: LD_INT 0
16632: ST_TO_ADDR
// Autak = IsInUnit ( Xavier ) ;
16633: LD_ADDR_VAR 0 2
16637: PUSH
16638: LD_EXP 25
16642: PPUSH
16643: CALL_OW 310
16647: ST_TO_ADDR
// if Autak then
16648: LD_VAR 0 2
16652: IFFALSE 16668
// SetSide ( Autak , side_Ru ) ;
16654: LD_VAR 0 2
16658: PPUSH
16659: LD_EXP 2
16663: PPUSH
16664: CALL_OW 235
// SetSide ( Xavier , side_Ru ) ;
16668: LD_EXP 25
16672: PPUSH
16673: LD_EXP 2
16677: PPUSH
16678: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
16682: CALL 16856 0 0
// end ;
16686: LD_VAR 0 1
16690: RET
// every 0 0$2.7 trigger IsInArea ( Xavier , AraboveParkoviste ) marked 21 do
16691: LD_EXP 25
16695: PPUSH
16696: LD_INT 18
16698: PPUSH
16699: CALL_OW 308
16703: IFFALSE 16712
16705: GO 16707
16707: DISABLE
// begin xavier_u_arabu ;
16708: CALL 15923 0 0
// end ;
16712: END
// every 1 1$0 marked 22 do
16713: GO 16715
16715: DISABLE
// begin Wait ( Rand ( 0 0$1 , 6 6$0 ) ) ;
16716: LD_INT 35
16718: PPUSH
16719: LD_INT 12600
16721: PPUSH
16722: CALL_OW 12
16726: PPUSH
16727: CALL_OW 67
// xavier_timeout ;
16731: CALL 15938 0 0
// end ;
16735: END
// every 0 0$4.2 trigger IsInArea ( Xavier , DropBox ) marked 23 do
16736: LD_EXP 25
16740: PPUSH
16741: LD_INT 11
16743: PPUSH
16744: CALL_OW 308
16748: IFFALSE 16757
16750: GO 16752
16752: DISABLE
// begin ; xavier_dropbox ;
16753: CALL 15961 0 0
// end ;
16757: END
// every 0 0$3.7 trigger FilterUnitsInArea ( DropBox , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) marked 24 do
16758: LD_INT 11
16760: PPUSH
16761: LD_INT 22
16763: PUSH
16764: LD_EXP 2
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PUSH
16773: LD_INT 50
16775: PUSH
16776: EMPTY
16777: LIST
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL_OW 70
16787: IFFALSE 16807
16789: GO 16791
16791: DISABLE
// begin if not xavier_zprava then
16792: CALL 16506 0 0
16796: NOT
16797: IFFALSE 16807
// begin Wait ( 1 1$0 ) ;
16799: LD_INT 2100
16801: PPUSH
16802: CALL_OW 67
// enable ;
16806: ENABLE
// end ; end ;
16807: END
// export function event_XavierPrisel ; begin
16808: LD_INT 0
16810: PPUSH
// xavier_prisel ;
16811: CALL 16621 0 0
// end ;
16815: LD_VAR 0 1
16819: RET
// export function xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
16820: LD_INT 0
16822: PPUSH
// if Nastupuje and ( VehOld = KradenyVuz ) then
16823: LD_LOC 40
16827: PUSH
16828: LD_VAR 0 2
16832: PUSH
16833: LD_LOC 41
16837: EQUAL
16838: AND
16839: IFFALSE 16851
// KradenyVuz = VehNew ;
16841: LD_ADDR_LOC 41
16845: PUSH
16846: LD_VAR 0 1
16850: ST_TO_ADDR
// end ;
16851: LD_VAR 0 5
16855: RET
// function zkopiruj_xaviera_jako_rus ; var Xav , X , Y , Dir , InUnit ; begin
16856: LD_INT 0
16858: PPUSH
16859: PPUSH
16860: PPUSH
16861: PPUSH
16862: PPUSH
16863: PPUSH
// X = GetX ( Xavier ) ;
16864: LD_ADDR_VAR 0 3
16868: PUSH
16869: LD_EXP 25
16873: PPUSH
16874: CALL_OW 250
16878: ST_TO_ADDR
// Y = GetY ( Xavier ) ;
16879: LD_ADDR_VAR 0 4
16883: PUSH
16884: LD_EXP 25
16888: PPUSH
16889: CALL_OW 251
16893: ST_TO_ADDR
// Dir = GetDir ( Xavier ) ;
16894: LD_ADDR_VAR 0 5
16898: PUSH
16899: LD_EXP 25
16903: PPUSH
16904: CALL_OW 254
16908: ST_TO_ADDR
// InUnit = IsInUnit ( Xavier ) ;
16909: LD_ADDR_VAR 0 6
16913: PUSH
16914: LD_EXP 25
16918: PPUSH
16919: CALL_OW 310
16923: ST_TO_ADDR
// RemoveUnit ( Xavier ) ;
16924: LD_EXP 25
16928: PPUSH
16929: CALL_OW 64
// PrepareNewCharacter ( Xavier ) ;
16933: LD_STRING Xavier
16935: PPUSH
16936: CALL_OW 26
// UC_Side = side_Ru ;
16940: LD_ADDR_OWVAR 20
16944: PUSH
16945: LD_EXP 2
16949: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
16950: LD_ADDR_OWVAR 21
16954: PUSH
16955: LD_INT 3
16957: ST_TO_ADDR
// UC_Placed = false ;
16958: LD_ADDR_OWVAR 25
16962: PUSH
16963: LD_INT 0
16965: ST_TO_ADDR
// Xav = CreateHuman ;
16966: LD_ADDR_VAR 0 2
16970: PUSH
16971: CALL_OW 44
16975: ST_TO_ADDR
// SetLives ( Xav , GetLives ( Xavier ) ) ;
16976: LD_VAR 0 2
16980: PPUSH
16981: LD_EXP 25
16985: PPUSH
16986: CALL_OW 256
16990: PPUSH
16991: CALL_OW 234
// DestroyUnit ( Xavier ) ;
16995: LD_EXP 25
16999: PPUSH
17000: CALL_OW 65
// Xavier = Xav ;
17004: LD_ADDR_EXP 25
17008: PUSH
17009: LD_VAR 0 2
17013: ST_TO_ADDR
// if InUnit then
17014: LD_VAR 0 6
17018: IFFALSE 17036
// PlaceHumanInUnit ( Xavier , InUnit ) else
17020: LD_EXP 25
17024: PPUSH
17025: LD_VAR 0 6
17029: PPUSH
17030: CALL_OW 52
17034: GO 17072
// begin PlaceUnitXY ( Xavier , X , Y , false ) ;
17036: LD_EXP 25
17040: PPUSH
17041: LD_VAR 0 3
17045: PPUSH
17046: LD_VAR 0 4
17050: PPUSH
17051: LD_INT 0
17053: PPUSH
17054: CALL_OW 48
// SetDir ( Xavier , Dir ) ;
17058: LD_EXP 25
17062: PPUSH
17063: LD_VAR 0 5
17067: PPUSH
17068: CALL_OW 233
// end ; end ; end_of_file
17072: LD_VAR 0 1
17076: RET
// var Uniky ; var HeikeVytvorena ; var HeikeUtika ; var HeikeJdeKam ; var Start_Budovy , Start_Auta , Start_Lidi ; var Registry , Makro ; var HeikeVCervenem ; var Zajmuta ; export function init_heike ; begin
17077: LD_INT 0
17079: PPUSH
// disable ( 31 ) ;
17080: LD_INT 31
17082: DISABLE_MARKED
// disable ( 32 ) ;
17083: LD_INT 32
17085: DISABLE_MARKED
// Uniky = [ [ Unik1 , HeikeCil1 ] , [ Unik2 , HeikeCil2 ] , [ Unik3 , HeikeCil3 ] , [ Unik4 , HeikeCil4 ] , [ Unik5 , HeikeCil5 ] , [ Unik6 , HeikeCil6 ] , [ Unik7 , HeikeCil7 ] ] ;
17086: LD_ADDR_LOC 42
17090: PUSH
17091: LD_INT 3
17093: PUSH
17094: LD_INT 20
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: PUSH
17101: LD_INT 4
17103: PUSH
17104: LD_INT 21
17106: PUSH
17107: EMPTY
17108: LIST
17109: LIST
17110: PUSH
17111: LD_INT 5
17113: PUSH
17114: LD_INT 22
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 6
17123: PUSH
17124: LD_INT 23
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 7
17133: PUSH
17134: LD_INT 24
17136: PUSH
17137: EMPTY
17138: LIST
17139: LIST
17140: PUSH
17141: LD_INT 8
17143: PUSH
17144: LD_INT 25
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: PUSH
17151: LD_INT 9
17153: PUSH
17154: LD_INT 26
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: ST_TO_ADDR
// HeikeVytvorena = false ;
17170: LD_ADDR_LOC 43
17174: PUSH
17175: LD_INT 0
17177: ST_TO_ADDR
// HeikeUtika = false ;
17178: LD_ADDR_LOC 44
17182: PUSH
17183: LD_INT 0
17185: ST_TO_ADDR
// HeikeVCervenem = false ;
17186: LD_ADDR_LOC 51
17190: PUSH
17191: LD_INT 0
17193: ST_TO_ADDR
// Zajmuta = false ;
17194: LD_ADDR_LOC 52
17198: PUSH
17199: LD_INT 0
17201: ST_TO_ADDR
// Start_Budovy = dif_HeikeBudovy [ Difficulty ] ;
17202: LD_ADDR_LOC 46
17206: PUSH
17207: LD_EXP 39
17211: PUSH
17212: LD_OWVAR 67
17216: ARRAY
17217: ST_TO_ADDR
// Start_Auta = dif_HeikeAuta [ Difficulty ] ;
17218: LD_ADDR_LOC 47
17222: PUSH
17223: LD_EXP 40
17227: PUSH
17228: LD_OWVAR 67
17232: ARRAY
17233: ST_TO_ADDR
// Start_Lidi = dif_HeikeLidi [ Difficulty ] ;
17234: LD_ADDR_LOC 48
17238: PUSH
17239: LD_EXP 41
17243: PUSH
17244: LD_OWVAR 67
17248: ARRAY
17249: ST_TO_ADDR
// end ;
17250: LD_VAR 0 1
17254: RET
// function vytvor_heike ; var I ; begin
17255: LD_INT 0
17257: PPUSH
17258: PPUSH
// Heike = NewCharacter ( Heike ) ;
17259: LD_ADDR_EXP 26
17263: PUSH
17264: LD_STRING Heike
17266: PPUSH
17267: CALL_OW 25
17271: ST_TO_ADDR
// SetSide ( Heike , side_Heike ) ;
17272: LD_EXP 26
17276: PPUSH
17277: LD_EXP 6
17281: PPUSH
17282: CALL_OW 235
// Heikeovci = [ ] ;
17286: LD_ADDR_EXP 27
17290: PUSH
17291: EMPTY
17292: ST_TO_ADDR
// InitHC ;
17293: CALL_OW 19
// InitUC ;
17297: CALL_OW 18
// UC_Side = side_Strazci ;
17301: LD_ADDR_OWVAR 20
17305: PUSH
17306: LD_EXP 7
17310: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
17311: LD_ADDR_OWVAR 21
17315: PUSH
17316: LD_INT 2
17318: ST_TO_ADDR
// HC_Name =  ;
17319: LD_ADDR_OWVAR 26
17323: PUSH
17324: LD_STRING 
17326: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
17327: LD_ADDR_OWVAR 28
17331: PUSH
17332: LD_INT 1
17334: ST_TO_ADDR
// UC_Placed = false ;
17335: LD_ADDR_OWVAR 25
17339: PUSH
17340: LD_INT 0
17342: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
17343: LD_INT 5
17345: PPUSH
17346: CALL_OW 375
// for I = 1 to dif_HeikeovciPocet [ Difficulty ] do
17350: LD_ADDR_VAR 0 2
17354: PUSH
17355: DOUBLE
17356: LD_INT 1
17358: DEC
17359: ST_TO_ADDR
17360: LD_EXP 43
17364: PUSH
17365: LD_OWVAR 67
17369: ARRAY
17370: PUSH
17371: FOR_TO
17372: IFFALSE 17411
// begin HC_Sex = Rand ( 1 , 2 ) ;
17374: LD_ADDR_OWVAR 27
17378: PUSH
17379: LD_INT 1
17381: PPUSH
17382: LD_INT 2
17384: PPUSH
17385: CALL_OW 12
17389: ST_TO_ADDR
// Heikeovci = Heikeovci union [ CreateHuman ] ;
17390: LD_ADDR_EXP 27
17394: PUSH
17395: LD_EXP 27
17399: PUSH
17400: CALL_OW 44
17404: PUSH
17405: EMPTY
17406: LIST
17407: UNION
17408: ST_TO_ADDR
// end ;
17409: GO 17371
17411: POP
17412: POP
// Heikeovci = Heikeovci diff [ 0 ] ;
17413: LD_ADDR_EXP 27
17417: PUSH
17418: LD_EXP 27
17422: PUSH
17423: LD_INT 0
17425: PUSH
17426: EMPTY
17427: LIST
17428: DIFF
17429: ST_TO_ADDR
// SetLives ( Heikeovci , dif_HeikeovciLives [ Difficulty ] ) ;
17430: LD_EXP 27
17434: PPUSH
17435: LD_EXP 42
17439: PUSH
17440: LD_OWVAR 67
17444: ARRAY
17445: PPUSH
17446: CALL_OW 234
// end ;
17450: LD_VAR 0 1
17454: RET
// function heike_do_zakladny ; begin
17455: LD_INT 0
17457: PPUSH
// AddComMoveXY ( Heike , 87 , 120 ) ;
17458: LD_EXP 26
17462: PPUSH
17463: LD_INT 87
17465: PPUSH
17466: LD_INT 120
17468: PPUSH
17469: CALL_OW 171
// AddComMoveXY ( Heike , 83 , 114 ) ;
17473: LD_EXP 26
17477: PPUSH
17478: LD_INT 83
17480: PPUSH
17481: LD_INT 114
17483: PPUSH
17484: CALL_OW 171
// AddComMoveXY ( Heike , 74 , 97 ) ;
17488: LD_EXP 26
17492: PPUSH
17493: LD_INT 74
17495: PPUSH
17496: LD_INT 97
17498: PPUSH
17499: CALL_OW 171
// AddComMoveXY ( Heike , 66 , 78 ) ;
17503: LD_EXP 26
17507: PPUSH
17508: LD_INT 66
17510: PPUSH
17511: LD_INT 78
17513: PPUSH
17514: CALL_OW 171
// if VsevSaved then
17518: LD_EXP 8
17522: IFFALSE 17571
// begin AddComMoveXY ( Heike , 61 , 70 ) ;
17524: LD_EXP 26
17528: PPUSH
17529: LD_INT 61
17531: PPUSH
17532: LD_INT 70
17534: PPUSH
17535: CALL_OW 171
// AddComMoveXY ( Heike , 56 , 59 ) ;
17539: LD_EXP 26
17543: PPUSH
17544: LD_INT 56
17546: PPUSH
17547: LD_INT 59
17549: PPUSH
17550: CALL_OW 171
// AddComMoveXY ( Heike , 44 , 44 ) ;
17554: LD_EXP 26
17558: PPUSH
17559: LD_INT 44
17561: PPUSH
17562: LD_INT 44
17564: PPUSH
17565: CALL_OW 171
// end else
17569: GO 17646
// begin AddComMoveXY ( Heike , 44 , 73 ) ;
17571: LD_EXP 26
17575: PPUSH
17576: LD_INT 44
17578: PPUSH
17579: LD_INT 73
17581: PPUSH
17582: CALL_OW 171
// AddComMoveXY ( Heike , 36 , 65 ) ;
17586: LD_EXP 26
17590: PPUSH
17591: LD_INT 36
17593: PPUSH
17594: LD_INT 65
17596: PPUSH
17597: CALL_OW 171
// AddComMoveXY ( Heike , 47 , 59 ) ;
17601: LD_EXP 26
17605: PPUSH
17606: LD_INT 47
17608: PPUSH
17609: LD_INT 59
17611: PPUSH
17612: CALL_OW 171
// AddComMoveXY ( Heike , 28 , 51 ) ;
17616: LD_EXP 26
17620: PPUSH
17621: LD_INT 28
17623: PPUSH
17624: LD_INT 51
17626: PPUSH
17627: CALL_OW 171
// AddComMoveXY ( Heike , 29 , 42 ) ;
17631: LD_EXP 26
17635: PPUSH
17636: LD_INT 29
17638: PPUSH
17639: LD_INT 42
17641: PPUSH
17642: CALL_OW 171
// end ; AddComMoveXY ( Heike , 40 , 37 ) ;
17646: LD_EXP 26
17650: PPUSH
17651: LD_INT 40
17653: PPUSH
17654: LD_INT 37
17656: PPUSH
17657: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 22 ) ;
17661: LD_EXP 26
17665: PPUSH
17666: LD_INT 33
17668: PPUSH
17669: LD_INT 22
17671: PPUSH
17672: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 16 ) ;
17676: LD_EXP 26
17680: PPUSH
17681: LD_INT 33
17683: PPUSH
17684: LD_INT 16
17686: PPUSH
17687: CALL_OW 171
// AddComMoveXY ( Heike , 38 , 13 ) ;
17691: LD_EXP 26
17695: PPUSH
17696: LD_INT 38
17698: PPUSH
17699: LD_INT 13
17701: PPUSH
17702: CALL_OW 171
// AddComMoveXY ( Heike , 46 , 13 ) ;
17706: LD_EXP 26
17710: PPUSH
17711: LD_INT 46
17713: PPUSH
17714: LD_INT 13
17716: PPUSH
17717: CALL_OW 171
// AddComMoveXY ( Heike , 54 , 16 ) ;
17721: LD_EXP 26
17725: PPUSH
17726: LD_INT 54
17728: PPUSH
17729: LD_INT 16
17731: PPUSH
17732: CALL_OW 171
// AddComMoveXY ( Heike , 62 , 15 ) ;
17736: LD_EXP 26
17740: PPUSH
17741: LD_INT 62
17743: PPUSH
17744: LD_INT 15
17746: PPUSH
17747: CALL_OW 171
// AddComMoveXY ( Heike , 73 , 14 ) ;
17751: LD_EXP 26
17755: PPUSH
17756: LD_INT 73
17758: PPUSH
17759: LD_INT 14
17761: PPUSH
17762: CALL_OW 171
// AddComMoveXY ( Heike , 91 , 13 ) ;
17766: LD_EXP 26
17770: PPUSH
17771: LD_INT 91
17773: PPUSH
17774: LD_INT 13
17776: PPUSH
17777: CALL_OW 171
// AddComMoveToArea ( Heike , HeikeCil ) ;
17781: LD_EXP 26
17785: PPUSH
17786: LD_INT 27
17788: PPUSH
17789: CALL_OW 173
// end ;
17793: LD_VAR 0 1
17797: RET
// function heike_start ; var Auto ; begin
17798: LD_INT 0
17800: PPUSH
17801: PPUSH
// if GetSide ( Xavier ) <> side_Ru then
17802: LD_EXP 25
17806: PPUSH
17807: CALL_OW 255
17811: PUSH
17812: LD_EXP 2
17816: NONEQUAL
17817: IFFALSE 17823
// xavier_prisel ;
17819: CALL 16621 0 0
// vytvor_heike ;
17823: CALL 17255 0 0
// PlaceUnitArea ( Heike , HeikeStart , false ) ;
17827: LD_EXP 26
17831: PPUSH
17832: LD_INT 19
17834: PPUSH
17835: LD_INT 0
17837: PPUSH
17838: CALL_OW 49
// place_list ( Heikeovci , HeikeStart ) ;
17842: LD_EXP 27
17846: PPUSH
17847: LD_INT 19
17849: PPUSH
17850: CALL 20674 0 2
// Wait ( Rand ( 0 0$1 , 0 0$5 ) ) ;
17854: LD_INT 35
17856: PPUSH
17857: LD_INT 175
17859: PPUSH
17860: CALL_OW 12
17864: PPUSH
17865: CALL_OW 67
// Registry = McRegistry ( side_Heike , [ [ MC_REG_UNITS_TO_PROTECT , [ Heike ] ] ] ) ;
17869: LD_ADDR_LOC 49
17873: PUSH
17874: LD_EXP 6
17878: PPUSH
17879: LD_INT 4
17881: PUSH
17882: LD_EXP 26
17886: PUSH
17887: EMPTY
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: PUSH
17894: EMPTY
17895: LIST
17896: PPUSH
17897: CALL_OW 399
17901: ST_TO_ADDR
// Makro = McDefend ( 0 , Registry , Heikeovci , [ ] ) ;
17902: LD_ADDR_LOC 50
17906: PUSH
17907: LD_INT 0
17909: PPUSH
17910: LD_LOC 49
17914: PPUSH
17915: LD_EXP 27
17919: PPUSH
17920: EMPTY
17921: PPUSH
17922: CALL_OW 401
17926: ST_TO_ADDR
// DialogueOn ;
17927: CALL_OW 6
// dialog_HeikeObj ;
17931: CALL 22630 0 0
// ChangeMissionObjectives ( MHeike ) ;
17935: LD_STRING MHeike
17937: PPUSH
17938: CALL_OW 337
// Query ( QHeike ) ;
17942: LD_STRING QHeike
17944: PPUSH
17945: CALL_OW 97
// DialogueOff ;
17949: CALL_OW 7
// RevealFogArea ( side_Ru , HeikeStart ) ;
17953: LD_EXP 2
17957: PPUSH
17958: LD_INT 19
17960: PPUSH
17961: CALL_OW 332
// CenterOnUnits ( Heike ) ;
17965: LD_EXP 26
17969: PPUSH
17970: CALL_OW 85
// heike_do_zakladny ;
17974: CALL 17455 0 0
// ComMoveUnit ( Heikeovci , Heike ) ;
17978: LD_EXP 27
17982: PPUSH
17983: LD_EXP 26
17987: PPUSH
17988: CALL_OW 112
// enable ( 32 ) ;
17992: LD_INT 32
17994: ENABLE_MARKED
// end ;
17995: LD_VAR 0 1
17999: RET
// function heike_kontrola_start ; var Budovy , Auta , Lidi ; begin
18000: LD_INT 0
18002: PPUSH
18003: PPUSH
18004: PPUSH
18005: PPUSH
// if HeikeVytvorena then
18006: LD_LOC 43
18010: IFFALSE 18014
// exit ;
18012: GO 18227
// Budovy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18014: LD_ADDR_VAR 0 2
18018: PUSH
18019: LD_INT 22
18021: PUSH
18022: LD_EXP 4
18026: PUSH
18027: EMPTY
18028: LIST
18029: LIST
18030: PUSH
18031: LD_INT 21
18033: PUSH
18034: LD_INT 3
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: PUSH
18041: LD_INT 50
18043: PUSH
18044: EMPTY
18045: LIST
18046: PUSH
18047: LD_INT 52
18049: PUSH
18050: EMPTY
18051: LIST
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: LIST
18057: LIST
18058: PPUSH
18059: CALL_OW 69
18063: ST_TO_ADDR
// Auta = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18064: LD_ADDR_VAR 0 3
18068: PUSH
18069: LD_INT 22
18071: PUSH
18072: LD_EXP 4
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: PUSH
18081: LD_INT 21
18083: PUSH
18084: LD_INT 2
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 50
18093: PUSH
18094: EMPTY
18095: LIST
18096: PUSH
18097: LD_INT 52
18099: PUSH
18100: EMPTY
18101: LIST
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: PPUSH
18109: CALL_OW 69
18113: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18114: LD_ADDR_VAR 0 4
18118: PUSH
18119: LD_INT 22
18121: PUSH
18122: LD_EXP 4
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: PUSH
18131: LD_INT 21
18133: PUSH
18134: LD_INT 1
18136: PUSH
18137: EMPTY
18138: LIST
18139: LIST
18140: PUSH
18141: LD_INT 50
18143: PUSH
18144: EMPTY
18145: LIST
18146: PUSH
18147: LD_INT 52
18149: PUSH
18150: EMPTY
18151: LIST
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: LIST
18157: LIST
18158: PPUSH
18159: CALL_OW 69
18163: ST_TO_ADDR
// if ( ( Budovy <= Start_Budovy ) and ( Auta <= Start_Auta ) ) or ( Lidi <= Start_Lidi ) then
18164: LD_VAR 0 2
18168: PUSH
18169: LD_LOC 46
18173: LESSEQUAL
18174: PUSH
18175: LD_VAR 0 3
18179: PUSH
18180: LD_LOC 47
18184: LESSEQUAL
18185: AND
18186: PUSH
18187: LD_VAR 0 4
18191: PUSH
18192: LD_LOC 48
18196: LESSEQUAL
18197: OR
18198: IFFALSE 18227
// begin HeikeVytvorena = true ;
18200: LD_ADDR_LOC 43
18204: PUSH
18205: LD_INT 1
18207: ST_TO_ADDR
// Wait ( Rand ( 0 0$3 , 0 0$20 ) ) ;
18208: LD_INT 105
18210: PPUSH
18211: LD_INT 700
18213: PPUSH
18214: CALL_OW 12
18218: PPUSH
18219: CALL_OW 67
// heike_start ;
18223: CALL 17798 0 0
// end ; end ;
18227: LD_VAR 0 1
18231: RET
// function je_volny_unik ( Area ) ; var KdoTam ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// KdoTam = FilterUnitsInArea ( Area , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) ;
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: LD_VAR 0 1
18245: PPUSH
18246: LD_INT 22
18248: PUSH
18249: LD_EXP 2
18253: PUSH
18254: EMPTY
18255: LIST
18256: LIST
18257: PUSH
18258: LD_INT 50
18260: PUSH
18261: EMPTY
18262: LIST
18263: PUSH
18264: EMPTY
18265: LIST
18266: LIST
18267: PPUSH
18268: CALL_OW 70
18272: ST_TO_ADDR
// if KdoTam then
18273: LD_VAR 0 3
18277: IFFALSE 18289
// Result = false else
18279: LD_ADDR_VAR 0 2
18283: PUSH
18284: LD_INT 0
18286: ST_TO_ADDR
18287: GO 18297
// Result = true ;
18289: LD_ADDR_VAR 0 2
18293: PUSH
18294: LD_INT 1
18296: ST_TO_ADDR
// end ;
18297: LD_VAR 0 2
18301: RET
// function zjisti_volne ; var Akt , Jednotky ; begin
18302: LD_INT 0
18304: PPUSH
18305: PPUSH
18306: PPUSH
// Result = [ ] ;
18307: LD_ADDR_VAR 0 1
18311: PUSH
18312: EMPTY
18313: ST_TO_ADDR
// for Akt in Uniky do
18314: LD_ADDR_VAR 0 2
18318: PUSH
18319: LD_LOC 42
18323: PUSH
18324: FOR_IN
18325: IFFALSE 18363
// begin if je_volny_unik ( Akt [ 1 ] ) then
18327: LD_VAR 0 2
18331: PUSH
18332: LD_INT 1
18334: ARRAY
18335: PPUSH
18336: CALL 18232 0 1
18340: IFFALSE 18361
// Result = Result union [ Akt ] ;
18342: LD_ADDR_VAR 0 1
18346: PUSH
18347: LD_VAR 0 1
18351: PUSH
18352: LD_VAR 0 2
18356: PUSH
18357: EMPTY
18358: LIST
18359: UNION
18360: ST_TO_ADDR
// end ;
18361: GO 18324
18363: POP
18364: POP
// end ;
18365: LD_VAR 0 1
18369: RET
// function zjisti_heike_utekla ; var Akt ; begin
18370: LD_INT 0
18372: PPUSH
18373: PPUSH
// Result = false ;
18374: LD_ADDR_VAR 0 1
18378: PUSH
18379: LD_INT 0
18381: ST_TO_ADDR
// if not IsOk ( Heike ) then
18382: LD_EXP 26
18386: PPUSH
18387: CALL_OW 302
18391: NOT
18392: IFFALSE 18396
// exit ;
18394: GO 18475
// Result = true ;
18396: LD_ADDR_VAR 0 1
18400: PUSH
18401: LD_INT 1
18403: ST_TO_ADDR
// if IsInArea ( Heike , HeikeCil ) then
18404: LD_EXP 26
18408: PPUSH
18409: LD_INT 27
18411: PPUSH
18412: CALL_OW 308
18416: IFFALSE 18420
// exit ;
18418: GO 18475
// if HeikeUtika then
18420: LD_LOC 44
18424: IFFALSE 18467
// begin for Akt in Uniky do
18426: LD_ADDR_VAR 0 2
18430: PUSH
18431: LD_LOC 42
18435: PUSH
18436: FOR_IN
18437: IFFALSE 18465
// if IsInArea ( Heike , Akt [ 2 ] ) then
18439: LD_EXP 26
18443: PPUSH
18444: LD_VAR 0 2
18448: PUSH
18449: LD_INT 2
18451: ARRAY
18452: PPUSH
18453: CALL_OW 308
18457: IFFALSE 18463
// exit ;
18459: POP
18460: POP
18461: GO 18475
18463: GO 18436
18465: POP
18466: POP
// end ; Result = false ;
18467: LD_ADDR_VAR 0 1
18471: PUSH
18472: LD_INT 0
18474: ST_TO_ADDR
// end ;
18475: LD_VAR 0 1
18479: RET
// function GetDistUnitArea2 ( Un , Area ) ; var Hex ; begin
18480: LD_INT 0
18482: PPUSH
18483: PPUSH
// Hex = RandHexArea ( Area , false ) ;
18484: LD_ADDR_VAR 0 4
18488: PUSH
18489: LD_VAR 0 2
18493: PPUSH
18494: LD_INT 0
18496: PPUSH
18497: CALL_OW 16
18501: ST_TO_ADDR
// Result = GetDistUnitXY ( Un , Hex [ 1 ] , Hex [ 2 ] ) ;
18502: LD_ADDR_VAR 0 3
18506: PUSH
18507: LD_VAR 0 1
18511: PPUSH
18512: LD_VAR 0 4
18516: PUSH
18517: LD_INT 1
18519: ARRAY
18520: PPUSH
18521: LD_VAR 0 4
18525: PUSH
18526: LD_INT 2
18528: ARRAY
18529: PPUSH
18530: CALL_OW 297
18534: ST_TO_ADDR
// end ;
18535: LD_VAR 0 3
18539: RET
// function zjisti_nejlepsi_unik ( Seznam ) ; var Min , Akt , AktDal ; begin
18540: LD_INT 0
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
// Result = [ ] ;
18546: LD_ADDR_VAR 0 2
18550: PUSH
18551: EMPTY
18552: ST_TO_ADDR
// Min = 99999 ;
18553: LD_ADDR_VAR 0 3
18557: PUSH
18558: LD_INT 99999
18560: ST_TO_ADDR
// for Akt in Seznam do
18561: LD_ADDR_VAR 0 4
18565: PUSH
18566: LD_VAR 0 1
18570: PUSH
18571: FOR_IN
18572: IFFALSE 18632
// begin AktDal = GetDistUnitArea2 ( Heike , Akt [ 1 ] ) ;
18574: LD_ADDR_VAR 0 5
18578: PUSH
18579: LD_EXP 26
18583: PPUSH
18584: LD_VAR 0 4
18588: PUSH
18589: LD_INT 1
18591: ARRAY
18592: PPUSH
18593: CALL 18480 0 2
18597: ST_TO_ADDR
// if AktDal < Min then
18598: LD_VAR 0 5
18602: PUSH
18603: LD_VAR 0 3
18607: LESS
18608: IFFALSE 18630
// begin Result = Akt ;
18610: LD_ADDR_VAR 0 2
18614: PUSH
18615: LD_VAR 0 4
18619: ST_TO_ADDR
// Min = AktDal ;
18620: LD_ADDR_VAR 0 3
18624: PUSH
18625: LD_VAR 0 5
18629: ST_TO_ADDR
// end ; end ;
18630: GO 18571
18632: POP
18633: POP
// end ;
18634: LD_VAR 0 2
18638: RET
// function heike_utika ; var Volno , Hex ; begin
18639: LD_INT 0
18641: PPUSH
18642: PPUSH
18643: PPUSH
// if zjisti_heike_utekla then
18644: CALL 18370 0 0
18648: IFFALSE 18656
// begin heike_utekla ;
18650: CALL 18836 0 0
// exit ;
18654: GO 18748
// end ; Volno = zjisti_volne ;
18656: LD_ADDR_VAR 0 2
18660: PUSH
18661: CALL 18302 0 0
18665: ST_TO_ADDR
// if HeikeUtika then
18666: LD_LOC 44
18670: IFFALSE 18689
// begin if je_volny_unik ( HeikeJdeKam [ 1 ] ) then
18672: LD_LOC 45
18676: PUSH
18677: LD_INT 1
18679: ARRAY
18680: PPUSH
18681: CALL 18232 0 1
18685: IFFALSE 18689
// exit ;
18687: GO 18748
// end ; HeikeJdeKam = zjisti_nejlepsi_unik ( Volno ) ;
18689: LD_ADDR_LOC 45
18693: PUSH
18694: LD_VAR 0 2
18698: PPUSH
18699: CALL 18540 0 1
18703: ST_TO_ADDR
// ComMoveToArea ( Heike , HeikeJdeKam [ 1 ] ) ;
18704: LD_EXP 26
18708: PPUSH
18709: LD_LOC 45
18713: PUSH
18714: LD_INT 1
18716: ARRAY
18717: PPUSH
18718: CALL_OW 113
// AddComMoveToArea ( Heike , HeikeJdeKam [ 2 ] ) ;
18722: LD_EXP 26
18726: PPUSH
18727: LD_LOC 45
18731: PUSH
18732: LD_INT 2
18734: ARRAY
18735: PPUSH
18736: CALL_OW 173
// HeikeUtika = true ;
18740: LD_ADDR_LOC 44
18744: PUSH
18745: LD_INT 1
18747: ST_TO_ADDR
// end ;
18748: LD_VAR 0 1
18752: RET
// function strazci_mrtvi ; begin
18753: LD_INT 0
18755: PPUSH
// heike_utec ;
18756: CALL 18790 0 0
// end ;
18760: LD_VAR 0 1
18764: RET
// every 0 0$1.3 marked 32 do
18765: GO 18767
18767: DISABLE
// begin if zjisti_heike_utekla then
18768: CALL 18370 0 0
18772: IFFALSE 18780
// begin heike_utekla ;
18774: CALL 18836 0 0
// exit ;
18778: GO 18780
// end ; end ;
18780: END
// every 0 0$1.1 marked 31 do
18781: GO 18783
18783: DISABLE
// begin heike_utika ;
18784: CALL 18639 0 0
// enable ;
18788: ENABLE
// end ;
18789: END
// function heike_utec ; begin
18790: LD_INT 0
18792: PPUSH
// if IsInArea ( Heike , Obkliceni ) then
18793: LD_EXP 26
18797: PPUSH
18798: LD_INT 38
18800: PPUSH
18801: CALL_OW 308
18805: IFFALSE 18816
// begin enable ( 31 ) ;
18807: LD_INT 31
18809: ENABLE_MARKED
// heike_utika ;
18810: CALL 18639 0 0
// end else
18814: GO 18831
// begin enable ( 32 ) ;
18816: LD_INT 32
18818: ENABLE_MARKED
// ComMoveToArea ( Heike , HeikeCil ) ;
18819: LD_EXP 26
18823: PPUSH
18824: LD_INT 27
18826: PPUSH
18827: CALL_OW 113
// end ; end ;
18831: LD_VAR 0 1
18835: RET
// function heike_utekla ; begin
18836: LD_INT 0
18838: PPUSH
// InGameOn ;
18839: CALL_OW 8
// CenterOnUnits ( Heike ) ;
18843: LD_EXP 26
18847: PPUSH
18848: CALL_OW 85
// Wait ( 0 0$2 ) ;
18852: LD_INT 70
18854: PPUSH
18855: CALL_OW 67
// if not IsOk ( Heike ) then
18859: LD_EXP 26
18863: PPUSH
18864: CALL_OW 302
18868: NOT
18869: IFFALSE 18881
// begin InGameOff ;
18871: CALL_OW 9
// heike_mrtva ;
18875: CALL 19041 0 0
// exit ;
18879: GO 18908
// end ; RemoveUnit ( Heike ) ;
18881: LD_EXP 26
18885: PPUSH
18886: CALL_OW 64
// Wait ( 0 0$2 ) ;
18890: LD_INT 70
18892: PPUSH
18893: CALL_OW 67
// YouLost ( Heike ) ;
18897: LD_STRING Heike
18899: PPUSH
18900: CALL_OW 104
// InGameOff ;
18904: CALL_OW 9
// end ;
18908: LD_VAR 0 1
18912: RET
// function heike_zajata ; begin
18913: LD_INT 0
18915: PPUSH
// if Zajmuta then
18916: LD_LOC 52
18920: IFFALSE 18924
// exit ;
18922: GO 19036
// Zajmuta = true ;
18924: LD_ADDR_LOC 52
18928: PUSH
18929: LD_INT 1
18931: ST_TO_ADDR
// SetAttitude ( side_Ru , side_Heike , ATT_FRIEND , true ) ;
18932: LD_EXP 2
18936: PPUSH
18937: LD_EXP 6
18941: PPUSH
18942: LD_INT 1
18944: PPUSH
18945: LD_INT 1
18947: PPUSH
18948: CALL_OW 80
// ComHold ( Heike ) ;
18952: LD_EXP 26
18956: PPUSH
18957: CALL_OW 140
// if ( GetLives ( Heike ) <= HRANICE_UMIRANI ) then
18961: LD_EXP 26
18965: PPUSH
18966: CALL_OW 256
18970: PUSH
18971: LD_INT 250
18973: LESSEQUAL
18974: IFFALSE 18992
// SetLives ( Heike , HRANICE_UMIRANI + 1 ) ;
18976: LD_EXP 26
18980: PPUSH
18981: LD_INT 250
18983: PUSH
18984: LD_INT 1
18986: PLUS
18987: PPUSH
18988: CALL_OW 234
// ComCancel ( Heike ) ;
18992: LD_EXP 26
18996: PPUSH
18997: CALL_OW 127
// ComHold ( Heike ) ;
19001: LD_EXP 26
19005: PPUSH
19006: CALL_OW 140
// DialogueOn ;
19010: CALL_OW 6
// dialog_HeikeCapt ;
19014: CALL 22686 0 0
// DialogueOff ;
19018: CALL_OW 7
// Wait ( 0 0$2 ) ;
19022: LD_INT 70
19024: PPUSH
19025: CALL_OW 67
// vyhral ( Main2 ) ;
19029: LD_STRING Main2
19031: PPUSH
19032: CALL 3049 0 1
// end ;
19036: LD_VAR 0 1
19040: RET
// function heike_mrtva ; begin
19041: LD_INT 0
19043: PPUSH
// DialogueOn ;
19044: CALL_OW 6
// Wait ( 0 0$3 ) ;
19048: LD_INT 105
19050: PPUSH
19051: CALL_OW 67
// vyhral ( Main1 ) ;
19055: LD_STRING Main1
19057: PPUSH
19058: CALL 3049 0 1
// DialogueOff ;
19062: CALL_OW 7
// end ;
19066: LD_VAR 0 1
19070: RET
// function straz_umrela ( Un ) ; begin
19071: LD_INT 0
19073: PPUSH
// if Un in Heikeovci then
19074: LD_VAR 0 1
19078: PUSH
19079: LD_EXP 27
19083: IN
19084: IFFALSE 19116
// begin Heikeovci = Heikeovci diff [ Un ] ;
19086: LD_ADDR_EXP 27
19090: PUSH
19091: LD_EXP 27
19095: PUSH
19096: LD_VAR 0 1
19100: PUSH
19101: EMPTY
19102: LIST
19103: DIFF
19104: ST_TO_ADDR
// if not Heikeovci then
19105: LD_EXP 27
19109: NOT
19110: IFFALSE 19116
// strazci_mrtvi ;
19112: CALL 18753 0 0
// end ; end ;
19116: LD_VAR 0 2
19120: RET
// export function heike_UnitDestroyed ( Un ) ; begin
19121: LD_INT 0
19123: PPUSH
// if Un = Heike then
19124: LD_VAR 0 1
19128: PUSH
19129: LD_EXP 26
19133: EQUAL
19134: IFFALSE 19142
// begin heike_mrtva ;
19136: CALL 19041 0 0
// exit ;
19140: GO 19155
// end ; straz_umrela ( Un ) ;
19142: LD_VAR 0 1
19146: PPUSH
19147: CALL 19071 0 1
// heike_kontrola_start ;
19151: CALL 18000 0 0
// end ;
19155: LD_VAR 0 2
19159: RET
// export function heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
19160: LD_INT 0
19162: PPUSH
// heike_kontrola_start ;
19163: CALL 18000 0 0
// end ;
19167: LD_VAR 0 5
19171: RET
// export function heike_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
19172: LD_INT 0
19174: PPUSH
// heike_kontrola_start ;
19175: CALL 18000 0 0
// end ;
19179: LD_VAR 0 4
19183: RET
// export function heike_UnitGoesToRed ( Un ) ; begin
19184: LD_INT 0
19186: PPUSH
// if Un = Heike then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 26
19196: EQUAL
19197: IFFALSE 19207
// HeikeVCervenem = true ;
19199: LD_ADDR_LOC 51
19203: PUSH
19204: LD_INT 1
19206: ST_TO_ADDR
// straz_umrela ( Un ) ;
19207: LD_VAR 0 1
19211: PPUSH
19212: CALL 19071 0 1
// heike_kontrola_start ;
19216: CALL 18000 0 0
// end ;
19220: LD_VAR 0 2
19224: RET
// export function heike_StartHeal ( Un , Medic ) ; begin
19225: LD_INT 0
19227: PPUSH
// if Un <> Heike then
19228: LD_VAR 0 1
19232: PUSH
19233: LD_EXP 26
19237: NONEQUAL
19238: IFFALSE 19242
// exit ;
19240: GO 19282
// if not HeikeVCervenem then
19242: LD_LOC 51
19246: NOT
19247: IFFALSE 19251
// exit ;
19249: GO 19282
// if Heikeovci then
19251: LD_EXP 27
19255: IFFALSE 19259
// exit ;
19257: GO 19282
// if GetSide ( Medic ) <> side_Ru then
19259: LD_VAR 0 2
19263: PPUSH
19264: CALL_OW 255
19268: PUSH
19269: LD_EXP 2
19273: NONEQUAL
19274: IFFALSE 19278
// exit ;
19276: GO 19282
// heike_zajata ;
19278: CALL 18913 0 0
// end ; end_of_file
19282: LD_VAR 0 3
19286: RET
// var BednyA ; var BednyRZ , BednyRV ; export function init_Suroviny ; begin
19287: LD_INT 0
19289: PPUSH
// BednyA = dif_BednyA [ Difficulty ] ;
19290: LD_ADDR_LOC 53
19294: PUSH
19295: LD_EXP 36
19299: PUSH
19300: LD_OWVAR 67
19304: ARRAY
19305: ST_TO_ADDR
// if VsevSaved then
19306: LD_EXP 8
19310: IFFALSE 19346
// begin BednyRZ = dif_BednyR1 [ Difficulty ] ;
19312: LD_ADDR_LOC 54
19316: PUSH
19317: LD_EXP 37
19321: PUSH
19322: LD_OWVAR 67
19326: ARRAY
19327: ST_TO_ADDR
// BednyRV = dif_BednyR2 [ Difficulty ] ;
19328: LD_ADDR_LOC 55
19332: PUSH
19333: LD_EXP 38
19337: PUSH
19338: LD_OWVAR 67
19342: ARRAY
19343: ST_TO_ADDR
// end else
19344: GO 19378
// begin BednyRZ = dif_BednyR2 [ Difficulty ] ;
19346: LD_ADDR_LOC 54
19350: PUSH
19351: LD_EXP 38
19355: PUSH
19356: LD_OWVAR 67
19360: ARRAY
19361: ST_TO_ADDR
// BednyRV = dif_BednyR1 [ Difficulty ] ;
19362: LD_ADDR_LOC 55
19366: PUSH
19367: LD_EXP 37
19371: PUSH
19372: LD_OWVAR 67
19376: ARRAY
19377: ST_TO_ADDR
// end ; end ;
19378: LD_VAR 0 1
19382: RET
// every 5 5$13.7 + 5 5$9 do var Pocet ;
19383: GO 19385
19385: DISABLE
19386: LD_INT 0
19388: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19389: LD_INT 35
19391: PPUSH
19392: LD_INT 3150
19394: PPUSH
19395: CALL_OW 12
19399: PPUSH
19400: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
19404: LD_ADDR_VAR 0 1
19408: PUSH
19409: LD_INT 0
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 12
19419: ST_TO_ADDR
// if Pocet > 0 then
19420: LD_VAR 0 1
19424: PUSH
19425: LD_INT 0
19427: GREATER
19428: IFFALSE 19442
// CreateCratesAnywhere ( Pocet , true ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 1
19437: PPUSH
19438: CALL_OW 57
// enable ;
19442: ENABLE
// end ;
19443: PPOPN 1
19445: END
// every 1 1$49 do
19446: GO 19448
19448: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19449: LD_INT 35
19451: PPUSH
19452: LD_INT 3150
19454: PPUSH
19455: CALL_OW 12
19459: PPUSH
19460: CALL_OW 67
// if ( BednyA <> 0 ) then
19464: LD_LOC 53
19468: PUSH
19469: LD_INT 0
19471: NONEQUAL
19472: IFFALSE 19531
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyArabi , true ) ;
19474: LD_INT 3
19476: PPUSH
19477: LD_INT 5
19479: PPUSH
19480: CALL_OW 12
19484: PPUSH
19485: LD_INT 30
19487: PPUSH
19488: LD_INT 1
19490: PPUSH
19491: CALL_OW 55
// if ( BednyA <> - 1 ) then
19495: LD_LOC 53
19499: PUSH
19500: LD_INT 1
19502: NEG
19503: NONEQUAL
19504: IFFALSE 19520
// BednyA = BednyA - 1 ;
19506: LD_ADDR_LOC 53
19510: PUSH
19511: LD_LOC 53
19515: PUSH
19516: LD_INT 1
19518: MINUS
19519: ST_TO_ADDR
// if ( BednyA <> 0 ) then
19520: LD_LOC 53
19524: PUSH
19525: LD_INT 0
19527: NONEQUAL
19528: IFFALSE 19531
// enable ;
19530: ENABLE
// end ; end ;
19531: END
// every 2 2$5 + 1 1$39 do
19532: GO 19534
19534: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19535: LD_INT 35
19537: PPUSH
19538: LD_INT 4200
19540: PPUSH
19541: CALL_OW 12
19545: PPUSH
19546: CALL_OW 67
// if ( BednyRZ <> 0 ) then
19550: LD_LOC 54
19554: PUSH
19555: LD_INT 0
19557: NONEQUAL
19558: IFFALSE 19617
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
19560: LD_INT 3
19562: PPUSH
19563: LD_INT 5
19565: PPUSH
19566: CALL_OW 12
19570: PPUSH
19571: LD_INT 28
19573: PPUSH
19574: LD_INT 1
19576: PPUSH
19577: CALL_OW 55
// if ( BednyRZ <> - 1 ) then
19581: LD_LOC 54
19585: PUSH
19586: LD_INT 1
19588: NEG
19589: NONEQUAL
19590: IFFALSE 19606
// BednyRZ = BednyRZ - 1 ;
19592: LD_ADDR_LOC 54
19596: PUSH
19597: LD_LOC 54
19601: PUSH
19602: LD_INT 1
19604: MINUS
19605: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
19606: LD_LOC 54
19610: PUSH
19611: LD_INT 0
19613: NONEQUAL
19614: IFFALSE 19617
// enable ;
19616: ENABLE
// end ; end ;
19617: END
// every 2 2$23 + 0 0$53 do
19618: GO 19620
19620: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19621: LD_INT 35
19623: PPUSH
19624: LD_INT 4200
19626: PPUSH
19627: CALL_OW 12
19631: PPUSH
19632: CALL_OW 67
// if ( BednyRV <> 0 ) then
19636: LD_LOC 55
19640: PUSH
19641: LD_INT 0
19643: NONEQUAL
19644: IFFALSE 19703
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
19646: LD_INT 3
19648: PPUSH
19649: LD_INT 5
19651: PPUSH
19652: CALL_OW 12
19656: PPUSH
19657: LD_INT 29
19659: PPUSH
19660: LD_INT 1
19662: PPUSH
19663: CALL_OW 55
// if ( BednyRV <> - 1 ) then
19667: LD_LOC 55
19671: PUSH
19672: LD_INT 1
19674: NEG
19675: NONEQUAL
19676: IFFALSE 19692
// BednyRV = BednyRV - 1 ;
19678: LD_ADDR_LOC 55
19682: PUSH
19683: LD_LOC 55
19687: PUSH
19688: LD_INT 1
19690: MINUS
19691: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
19692: LD_LOC 55
19696: PUSH
19697: LD_INT 0
19699: NONEQUAL
19700: IFFALSE 19703
// enable ;
19702: ENABLE
// end ; end ; end_of_file
19703: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19704: LD_VAR 0 1
19708: PPUSH
19709: LD_VAR 0 2
19713: PPUSH
19714: LD_VAR 0 3
19718: PPUSH
19719: LD_VAR 0 4
19723: PPUSH
19724: CALL 16820 0 4
// yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: LD_VAR 0 3
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: CALL 14584 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19752: LD_VAR 0 1
19756: PPUSH
19757: LD_VAR 0 2
19761: PPUSH
19762: LD_VAR 0 3
19766: PPUSH
19767: LD_VAR 0 4
19771: PPUSH
19772: CALL 9995 0 4
// heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19776: LD_VAR 0 1
19780: PPUSH
19781: LD_VAR 0 2
19785: PPUSH
19786: LD_VAR 0 3
19790: PPUSH
19791: LD_VAR 0 4
19795: PPUSH
19796: CALL 19160 0 4
// end ;
19800: PPOPN 4
19802: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin heike_BuildingCaptured ( Build , OrigSide , Eng ) ;
19803: LD_VAR 0 1
19807: PPUSH
19808: LD_VAR 0 2
19812: PPUSH
19813: LD_VAR 0 3
19817: PPUSH
19818: CALL 19172 0 3
// arabi_BuildingCaptured ( Build , OrigSide , Eng ) ;
19822: LD_VAR 0 1
19826: PPUSH
19827: LD_VAR 0 2
19831: PPUSH
19832: LD_VAR 0 3
19836: PPUSH
19837: CALL 10490 0 3
// end ;
19841: PPOPN 3
19843: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
19844: LD_VAR 0 1
19848: PPUSH
19849: CALL 6028 0 1
// heike_UnitDestroyed ( Un ) ;
19853: LD_VAR 0 1
19857: PPUSH
19858: CALL 19121 0 1
// arabi_UnitDestroyed ( Un ) ;
19862: LD_VAR 0 1
19866: PPUSH
19867: CALL 10229 0 1
// end ;
19871: PPOPN 1
19873: END
// on UnitGoesToRed ( Un ) do begin yashin_UnitGoesToRed ( Un ) ;
19874: LD_VAR 0 1
19878: PPUSH
19879: CALL 15060 0 1
// arabi_UnitGoesToRed ( Un ) ;
19883: LD_VAR 0 1
19887: PPUSH
19888: CALL 10365 0 1
// heike_UnitGoesToRed ( Un ) ;
19892: LD_VAR 0 1
19896: PPUSH
19897: CALL 19184 0 1
// end ;
19901: PPOPN 1
19903: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
19904: LD_VAR 0 1
19908: PPUSH
19909: LD_VAR 0 2
19913: PPUSH
19914: CALL 9468 0 2
// end ;
19918: PPOPN 2
19920: END
// on BuildingComplete ( Un ) do begin rusove_BuildingComplete ( Un ) ;
19921: LD_VAR 0 1
19925: PPUSH
19926: CALL 6105 0 1
// end ;
19930: PPOPN 1
19932: END
// on SailEvent ( Num ) do begin case Num of 101 :
19933: LD_VAR 0 1
19937: PUSH
19938: LD_INT 101
19940: DOUBLE
19941: EQUAL
19942: IFTRUE 19946
19944: GO 19953
19946: POP
// event_Patrola ; 102 , 103 , 103 :
19947: CALL 11324 0 0
19951: GO 20016
19953: LD_INT 102
19955: DOUBLE
19956: EQUAL
19957: IFTRUE 19973
19959: LD_INT 103
19961: DOUBLE
19962: EQUAL
19963: IFTRUE 19973
19965: LD_INT 103
19967: DOUBLE
19968: EQUAL
19969: IFTRUE 19973
19971: GO 19985
19973: POP
// event_OpravaHotova ( Num ) ; 111 :
19974: LD_VAR 0 1
19978: PPUSH
19979: CALL 12781 0 1
19983: GO 20016
19985: LD_INT 111
19987: DOUBLE
19988: EQUAL
19989: IFTRUE 19993
19991: GO 20000
19993: POP
// event_YashinUtoci ; 121 :
19994: CALL 14564 0 0
19998: GO 20016
20000: LD_INT 121
20002: DOUBLE
20003: EQUAL
20004: IFTRUE 20008
20006: GO 20015
20008: POP
// event_XavierPrisel ; end ;
20009: CALL 16808 0 0
20013: GO 20016
20015: POP
// end ;
20016: PPOPN 1
20018: END
// on Contact ( Side1 , Side2 ) do begin rusove_Contact ( Side1 , Side2 ) ;
20019: LD_VAR 0 1
20023: PPUSH
20024: LD_VAR 0 2
20028: PPUSH
20029: CALL 6230 0 2
// end ;
20033: PPOPN 2
20035: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
20036: LD_VAR 0 1
20040: PPUSH
20041: LD_VAR 0 2
20045: PPUSH
20046: CALL 8925 0 2
// end ;
20050: PPOPN 2
20052: END
// on StartHeal ( Un , Medic ) do begin heike_StartHeal ( Un , Medic ) ;
20053: LD_VAR 0 1
20057: PPUSH
20058: LD_VAR 0 2
20062: PPUSH
20063: CALL 19225 0 2
// end ;
20067: PPOPN 2
20069: END
// every 1 1$59 do
20070: GO 20072
20072: DISABLE
// begin RandomizeAll ;
20073: CALL_OW 11
// end ; end_of_file
20077: END
// export dif_BednyA , dif_BednyR1 , dif_BednyR2 ; export dif_HeikeBudovy , dif_HeikeAuta , dif_HeikeLidi ; export dif_HeikeovciLives , dif_HeikeovciPocet ; export dif_Cans , dif_Oil , dif_Siberit ; export dif_ArabiLevel , dif_VolnyArabi , dif_ObranciArabi ; export dif_UtokSkupina , dif_PstZbrane ; export dif_CasovacUtoku ; export dif_MaxKonvojCargo ; export function init_difficulty ; begin
20078: LD_INT 0
20080: PPUSH
// dif_BednyR1 = [ 25 , 20 , 15 ] ;
20081: LD_ADDR_EXP 37
20085: PUSH
20086: LD_INT 25
20088: PUSH
20089: LD_INT 20
20091: PUSH
20092: LD_INT 15
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: ST_TO_ADDR
// dif_BednyR2 = [ 30 , 25 , 20 ] ;
20100: LD_ADDR_EXP 38
20104: PUSH
20105: LD_INT 30
20107: PUSH
20108: LD_INT 25
20110: PUSH
20111: LD_INT 20
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: ST_TO_ADDR
// dif_BednyA = [ 25 , 35 , 60 ] ;
20119: LD_ADDR_EXP 36
20123: PUSH
20124: LD_INT 25
20126: PUSH
20127: LD_INT 35
20129: PUSH
20130: LD_INT 60
20132: PUSH
20133: EMPTY
20134: LIST
20135: LIST
20136: LIST
20137: ST_TO_ADDR
// dif_HeikeBudovy = [ 8 , 5 , 2 ] ;
20138: LD_ADDR_EXP 39
20142: PUSH
20143: LD_INT 8
20145: PUSH
20146: LD_INT 5
20148: PUSH
20149: LD_INT 2
20151: PUSH
20152: EMPTY
20153: LIST
20154: LIST
20155: LIST
20156: ST_TO_ADDR
// dif_HeikeAuta = [ 2 , 1 , 0 ] ;
20157: LD_ADDR_EXP 40
20161: PUSH
20162: LD_INT 2
20164: PUSH
20165: LD_INT 1
20167: PUSH
20168: LD_INT 0
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: LIST
20175: ST_TO_ADDR
// dif_HeikeLidi = [ 2 , 1 , 0 ] ;
20176: LD_ADDR_EXP 41
20180: PUSH
20181: LD_INT 2
20183: PUSH
20184: LD_INT 1
20186: PUSH
20187: LD_INT 0
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: LIST
20194: ST_TO_ADDR
// dif_HeikeovciLives = [ 750 , 900 , 1000 ] ;
20195: LD_ADDR_EXP 42
20199: PUSH
20200: LD_INT 750
20202: PUSH
20203: LD_INT 900
20205: PUSH
20206: LD_INT 1000
20208: PUSH
20209: EMPTY
20210: LIST
20211: LIST
20212: LIST
20213: ST_TO_ADDR
// dif_HeikeovciPocet = [ 2 , 4 , 7 ] ;
20214: LD_ADDR_EXP 43
20218: PUSH
20219: LD_INT 2
20221: PUSH
20222: LD_INT 4
20224: PUSH
20225: LD_INT 7
20227: PUSH
20228: EMPTY
20229: LIST
20230: LIST
20231: LIST
20232: ST_TO_ADDR
// dif_ArabiLevel = [ 3 , 5 , 7 ] ;
20233: LD_ADDR_EXP 47
20237: PUSH
20238: LD_INT 3
20240: PUSH
20241: LD_INT 5
20243: PUSH
20244: LD_INT 7
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: LIST
20251: ST_TO_ADDR
// dif_VolnyArabi = [ 2 , 5 , 10 ] ;
20252: LD_ADDR_EXP 48
20256: PUSH
20257: LD_INT 2
20259: PUSH
20260: LD_INT 5
20262: PUSH
20263: LD_INT 10
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: LIST
20270: ST_TO_ADDR
// dif_ObranciArabi = [ 1 , 3 , 5 ] ;
20271: LD_ADDR_EXP 49
20275: PUSH
20276: LD_INT 1
20278: PUSH
20279: LD_INT 3
20281: PUSH
20282: LD_INT 5
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: LIST
20289: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
20290: LD_ADDR_EXP 50
20294: PUSH
20295: LD_INT 3
20297: PUSH
20298: LD_INT 4
20300: PUSH
20301: LD_INT 6
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: LIST
20308: ST_TO_ADDR
// dif_Cans = [ 200 , 170 , 130 ] ;
20309: LD_ADDR_EXP 44
20313: PUSH
20314: LD_INT 200
20316: PUSH
20317: LD_INT 170
20319: PUSH
20320: LD_INT 130
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: LIST
20327: ST_TO_ADDR
// dif_Oil = [ 100 , 50 , 0 ] ;
20328: LD_ADDR_EXP 45
20332: PUSH
20333: LD_INT 100
20335: PUSH
20336: LD_INT 50
20338: PUSH
20339: LD_INT 0
20341: PUSH
20342: EMPTY
20343: LIST
20344: LIST
20345: LIST
20346: ST_TO_ADDR
// dif_Siberit = [ 100 , 100 , 100 ] ;
20347: LD_ADDR_EXP 46
20351: PUSH
20352: LD_INT 100
20354: PUSH
20355: LD_INT 100
20357: PUSH
20358: LD_INT 100
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: ST_TO_ADDR
// if VsevSaved then
20366: LD_EXP 8
20370: IFFALSE 20414
// dif_CasovacUtoku = [ [ 8 , 10 ] , [ 7 , 9 ] , [ 6 , 8 ] ] else
20372: LD_ADDR_EXP 52
20376: PUSH
20377: LD_INT 8
20379: PUSH
20380: LD_INT 10
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 7
20389: PUSH
20390: LD_INT 9
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 6
20399: PUSH
20400: LD_INT 8
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: LIST
20411: ST_TO_ADDR
20412: GO 20462
// dif_CasovacUtoku = [ [ 8 , 8 , 7 ] , [ 8 , 7 , 6 ] , [ 4 , 5 ] ] ;
20414: LD_ADDR_EXP 52
20418: PUSH
20419: LD_INT 8
20421: PUSH
20422: LD_INT 8
20424: PUSH
20425: LD_INT 7
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: LIST
20432: PUSH
20433: LD_INT 8
20435: PUSH
20436: LD_INT 7
20438: PUSH
20439: LD_INT 6
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: LIST
20446: PUSH
20447: LD_INT 4
20449: PUSH
20450: LD_INT 5
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: LIST
20461: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 30 , 50 , 80 , 100 ] , [ 30 , 60 , 75 , 100 ] ] ;
20462: LD_ADDR_EXP 51
20466: PUSH
20467: LD_INT 20
20469: PUSH
20470: LD_INT 40
20472: PUSH
20473: LD_INT 80
20475: PUSH
20476: LD_INT 100
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: PUSH
20485: LD_INT 30
20487: PUSH
20488: LD_INT 50
20490: PUSH
20491: LD_INT 80
20493: PUSH
20494: LD_INT 100
20496: PUSH
20497: EMPTY
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: PUSH
20503: LD_INT 30
20505: PUSH
20506: LD_INT 60
20508: PUSH
20509: LD_INT 75
20511: PUSH
20512: LD_INT 100
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: LIST
20519: LIST
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: ST_TO_ADDR
// dif_MaxKonvojCargo = [ [ 5 , 200 , 100 , 0 ] , [ 5 , 160 , 60 , 0 ] , [ 5 , 50 , 50 , 0 ] ] ;
20526: LD_ADDR_EXP 53
20530: PUSH
20531: LD_INT 5
20533: PUSH
20534: LD_INT 200
20536: PUSH
20537: LD_INT 100
20539: PUSH
20540: LD_INT 0
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: PUSH
20549: LD_INT 5
20551: PUSH
20552: LD_INT 160
20554: PUSH
20555: LD_INT 60
20557: PUSH
20558: LD_INT 0
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: PUSH
20567: LD_INT 5
20569: PUSH
20570: LD_INT 50
20572: PUSH
20573: LD_INT 50
20575: PUSH
20576: LD_INT 0
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: LIST
20589: ST_TO_ADDR
// end ; end_of_file
20590: LD_VAR 0 1
20594: RET
// export function jdete_k_sobe ( Kdo , Kam ) ; begin
20595: LD_INT 0
20597: PPUSH
// ComMoveUnit ( Kdo , Kam ) ;
20598: LD_VAR 0 1
20602: PPUSH
20603: LD_VAR 0 2
20607: PPUSH
20608: CALL_OW 112
// while GetDistUnits ( Kdo , Kam ) > 3 do
20612: LD_VAR 0 1
20616: PPUSH
20617: LD_VAR 0 2
20621: PPUSH
20622: CALL_OW 296
20626: PUSH
20627: LD_INT 3
20629: GREATER
20630: IFFALSE 20641
// Wait ( 0 0$0.5 ) ;
20632: LD_INT 18
20634: PPUSH
20635: CALL_OW 67
20639: GO 20612
// AddComTurnUnit ( Kdo , Kam ) ;
20641: LD_VAR 0 1
20645: PPUSH
20646: LD_VAR 0 2
20650: PPUSH
20651: CALL_OW 179
// AddComTurnUnit ( Kam , Kdo ) ;
20655: LD_VAR 0 2
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: CALL_OW 179
// end ;
20669: LD_VAR 0 3
20673: RET
// export function place_list ( List , Area ) ; var I ; begin
20674: LD_INT 0
20676: PPUSH
20677: PPUSH
// for I in List do
20678: LD_ADDR_VAR 0 4
20682: PUSH
20683: LD_VAR 0 1
20687: PUSH
20688: FOR_IN
20689: IFFALSE 20710
// PlaceUnitArea ( I , Area , false ) ;
20691: LD_VAR 0 4
20695: PPUSH
20696: LD_VAR 0 2
20700: PPUSH
20701: LD_INT 0
20703: PPUSH
20704: CALL_OW 49
20708: GO 20688
20710: POP
20711: POP
// end ;
20712: LD_VAR 0 3
20716: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20717: LD_INT 0
20719: PPUSH
20720: PPUSH
20721: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20722: LD_ADDR_VAR 0 4
20726: PUSH
20727: LD_INT 22
20729: PUSH
20730: LD_VAR 0 2
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: PUSH
20739: EMPTY
20740: LIST
20741: PPUSH
20742: CALL_OW 69
20746: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20747: LD_ADDR_VAR 0 5
20751: PUSH
20752: LD_VAR 0 4
20756: PUSH
20757: FOR_IN
20758: IFFALSE 20790
// if See ( Kdo , Jednotka ) then
20760: LD_VAR 0 1
20764: PPUSH
20765: LD_VAR 0 5
20769: PPUSH
20770: CALL_OW 292
20774: IFFALSE 20788
// begin Result = true ;
20776: LD_ADDR_VAR 0 3
20780: PUSH
20781: LD_INT 1
20783: ST_TO_ADDR
// exit ;
20784: POP
20785: POP
20786: GO 20800
// end ;
20788: GO 20757
20790: POP
20791: POP
// Result = false ;
20792: LD_ADDR_VAR 0 3
20796: PUSH
20797: LD_INT 0
20799: ST_TO_ADDR
// end ;
20800: LD_VAR 0 3
20804: RET
// export function vidi_strana_jednotky ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20805: LD_INT 0
20807: PPUSH
20808: PPUSH
20809: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20810: LD_ADDR_VAR 0 4
20814: PUSH
20815: LD_INT 22
20817: PUSH
20818: LD_VAR 0 2
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PUSH
20827: EMPTY
20828: LIST
20829: PPUSH
20830: CALL_OW 69
20834: ST_TO_ADDR
// Result = [ ] ;
20835: LD_ADDR_VAR 0 3
20839: PUSH
20840: EMPTY
20841: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20842: LD_ADDR_VAR 0 5
20846: PUSH
20847: LD_VAR 0 4
20851: PUSH
20852: FOR_IN
20853: IFFALSE 20892
// if See ( Kdo , Jednotka ) then
20855: LD_VAR 0 1
20859: PPUSH
20860: LD_VAR 0 5
20864: PPUSH
20865: CALL_OW 292
20869: IFFALSE 20890
// Result = Result union [ Jednotka ] ;
20871: LD_ADDR_VAR 0 3
20875: PUSH
20876: LD_VAR 0 3
20880: PUSH
20881: LD_VAR 0 5
20885: PUSH
20886: EMPTY
20887: LIST
20888: UNION
20889: ST_TO_ADDR
20890: GO 20852
20892: POP
20893: POP
// end ;
20894: LD_VAR 0 3
20898: RET
// export function jednotky_blizko ( Kdo , Koho , Dalka ) ; var KohoJednotky , Jednotka ; begin
20899: LD_INT 0
20901: PPUSH
20902: PPUSH
20903: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20904: LD_ADDR_VAR 0 5
20908: PUSH
20909: LD_INT 22
20911: PUSH
20912: LD_VAR 0 2
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: EMPTY
20922: LIST
20923: PPUSH
20924: CALL_OW 69
20928: ST_TO_ADDR
// Result = [ ] ;
20929: LD_ADDR_VAR 0 4
20933: PUSH
20934: EMPTY
20935: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20936: LD_ADDR_VAR 0 6
20940: PUSH
20941: LD_VAR 0 5
20945: PUSH
20946: FOR_IN
20947: IFFALSE 20992
// if GetDistUnits ( Kdo , Jednotka ) <= Dalka then
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 6
20958: PPUSH
20959: CALL_OW 296
20963: PUSH
20964: LD_VAR 0 3
20968: LESSEQUAL
20969: IFFALSE 20990
// Result = Result union [ Jednotka ] ;
20971: LD_ADDR_VAR 0 4
20975: PUSH
20976: LD_VAR 0 4
20980: PUSH
20981: LD_VAR 0 6
20985: PUSH
20986: EMPTY
20987: LIST
20988: UNION
20989: ST_TO_ADDR
20990: GO 20946
20992: POP
20993: POP
// end ;
20994: LD_VAR 0 4
20998: RET
// export function nahoda_seznam ( Seznam ) ; begin
20999: LD_INT 0
21001: PPUSH
// if Seznam then
21002: LD_VAR 0 1
21006: IFFALSE 21034
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21008: LD_ADDR_VAR 0 2
21012: PUSH
21013: LD_VAR 0 1
21017: PUSH
21018: LD_INT 1
21020: PPUSH
21021: LD_VAR 0 1
21025: PPUSH
21026: CALL_OW 12
21030: ARRAY
21031: ST_TO_ADDR
21032: GO 21042
// Result = 0 ;
21034: LD_ADDR_VAR 0 2
21038: PUSH
21039: LD_INT 0
21041: ST_TO_ADDR
// end ;
21042: LD_VAR 0 2
21046: RET
// export function bez_opic ( List ) ; var Opice ; begin
21047: LD_INT 0
21049: PPUSH
21050: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
21051: LD_ADDR_VAR 0 3
21055: PUSH
21056: LD_VAR 0 1
21060: PPUSH
21061: LD_INT 2
21063: PUSH
21064: LD_INT 25
21066: PUSH
21067: LD_INT 12
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: PUSH
21074: LD_INT 25
21076: PUSH
21077: LD_INT 15
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: PUSH
21084: LD_INT 25
21086: PUSH
21087: LD_INT 16
21089: PUSH
21090: EMPTY
21091: LIST
21092: LIST
21093: PUSH
21094: LD_INT 25
21096: PUSH
21097: LD_INT 17
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: LIST
21108: LIST
21109: LIST
21110: PUSH
21111: EMPTY
21112: LIST
21113: PPUSH
21114: CALL_OW 72
21118: ST_TO_ADDR
// Result = List diff Opice ;
21119: LD_ADDR_VAR 0 2
21123: PUSH
21124: LD_VAR 0 1
21128: PUSH
21129: LD_VAR 0 3
21133: DIFF
21134: ST_TO_ADDR
// end ; end_of_file
21135: LD_VAR 0 2
21139: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
21140: LD_INT 0
21142: PPUSH
21143: PPUSH
21144: PPUSH
// Result = [ ] ;
21145: LD_ADDR_VAR 0 4
21149: PUSH
21150: EMPTY
21151: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
21152: LD_ADDR_OWVAR 21
21156: PUSH
21157: LD_INT 0
21159: ST_TO_ADDR
// UC_side = side_neutral ;
21160: LD_ADDR_OWVAR 20
21164: PUSH
21165: LD_EXP 1
21169: ST_TO_ADDR
// HC_Class = Cls ;
21170: LD_ADDR_OWVAR 28
21174: PUSH
21175: LD_VAR 0 1
21179: ST_TO_ADDR
// HC_Name =  ;
21180: LD_ADDR_OWVAR 26
21184: PUSH
21185: LD_STRING 
21187: ST_TO_ADDR
// for i = 1 to Cnt do
21188: LD_ADDR_VAR 0 5
21192: PUSH
21193: DOUBLE
21194: LD_INT 1
21196: DEC
21197: ST_TO_ADDR
21198: LD_VAR 0 2
21202: PUSH
21203: FOR_TO
21204: IFFALSE 21254
// begin h = CreateHuman ;
21206: LD_ADDR_VAR 0 6
21210: PUSH
21211: CALL_OW 44
21215: ST_TO_ADDR
// Result = Result union [ h ] ;
21216: LD_ADDR_VAR 0 4
21220: PUSH
21221: LD_VAR 0 4
21225: PUSH
21226: LD_VAR 0 6
21230: PUSH
21231: EMPTY
21232: LIST
21233: UNION
21234: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
21235: LD_VAR 0 6
21239: PPUSH
21240: LD_VAR 0 3
21244: PPUSH
21245: LD_INT 0
21247: PPUSH
21248: CALL_OW 49
// end ;
21252: GO 21203
21254: POP
21255: POP
// end ;
21256: LD_VAR 0 4
21260: RET
// export function init_nature ; begin
21261: LD_INT 0
21263: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 1 , 3 ) , Les ) ;
21264: LD_INT 14
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: LD_INT 3
21272: PPUSH
21273: CALL_OW 12
21277: PPUSH
21278: LD_INT 10
21280: PPUSH
21281: CALL 21140 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 10 ) - Difficulty , Les ) ;
21285: LD_INT 12
21287: PPUSH
21288: LD_INT 5
21290: PPUSH
21291: LD_INT 10
21293: PPUSH
21294: CALL_OW 12
21298: PUSH
21299: LD_OWVAR 67
21303: MINUS
21304: PPUSH
21305: LD_INT 10
21307: PPUSH
21308: CALL 21140 0 3
// end ; end_of_file
21312: LD_VAR 0 1
21316: RET
// export function dialog_Start ; begin
21317: LD_INT 0
21319: PPUSH
// SayRadio ( Platonov , DStart-Pla-1 ) ;
21320: LD_EXP 20
21324: PPUSH
21325: LD_STRING DStart-Pla-1
21327: PPUSH
21328: CALL_OW 94
// end ;
21332: LD_VAR 0 1
21336: RET
// export function dialog_StartVS ; begin
21337: LD_INT 0
21339: PPUSH
// SayRadio ( Platonov , DStartVS-Pla-1 ) ;
21340: LD_EXP 20
21344: PPUSH
21345: LD_STRING DStartVS-Pla-1
21347: PPUSH
21348: CALL_OW 94
// end ;
21352: LD_VAR 0 1
21356: RET
// export function dialog_StartNV ; begin
21357: LD_INT 0
21359: PPUSH
// SayRadio ( Platonov , DStartNV-Pla-1 ) ;
21360: LD_EXP 20
21364: PPUSH
21365: LD_STRING DStartNV-Pla-1
21367: PPUSH
21368: CALL_OW 94
// end ;
21372: LD_VAR 0 1
21376: RET
// export function dialog_Start2 ; begin
21377: LD_INT 0
21379: PPUSH
// SayRadio ( Platonov , DStart2-Pla-1 ) ;
21380: LD_EXP 20
21384: PPUSH
21385: LD_STRING DStart2-Pla-1
21387: PPUSH
21388: CALL_OW 94
// Say ( Burlak , DStart2-Bur-1 ) ;
21392: LD_EXP 10
21396: PPUSH
21397: LD_STRING DStart2-Bur-1
21399: PPUSH
21400: CALL_OW 88
// end ;
21404: LD_VAR 0 1
21408: RET
// export function dialog_MeetVsevolodVS ; begin
21409: LD_INT 0
21411: PPUSH
// Say ( Burlak , DMeetVsevolodVS-Bur-1 ) ;
21412: LD_EXP 10
21416: PPUSH
21417: LD_STRING DMeetVsevolodVS-Bur-1
21419: PPUSH
21420: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-1 ) ;
21424: LD_EXP 11
21428: PPUSH
21429: LD_STRING DMeetVsevolodVS-Vse-1
21431: PPUSH
21432: CALL_OW 88
// Say ( Burlak , DMeetVsevolodVS-Bur-2 ) ;
21436: LD_EXP 10
21440: PPUSH
21441: LD_STRING DMeetVsevolodVS-Bur-2
21443: PPUSH
21444: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-2 ) ;
21448: LD_EXP 11
21452: PPUSH
21453: LD_STRING DMeetVsevolodVS-Vse-2
21455: PPUSH
21456: CALL_OW 88
// end ;
21460: LD_VAR 0 1
21464: RET
// export function dialog_StasisVS ; begin
21465: LD_INT 0
21467: PPUSH
// if Titov and IsOK ( Titov ) then
21468: LD_EXP 19
21472: PUSH
21473: LD_EXP 19
21477: PPUSH
21478: CALL_OW 302
21482: AND
21483: IFFALSE 21499
// Say ( Titov , DStasisVS-Tit-1 ) else
21485: LD_EXP 19
21489: PPUSH
21490: LD_STRING DStasisVS-Tit-1
21492: PPUSH
21493: CALL_OW 88
21497: GO 21511
// Say ( Yelena , DStasisVS-Kir-1 ) ;
21499: LD_EXP 13
21503: PPUSH
21504: LD_STRING DStasisVS-Kir-1
21506: PPUSH
21507: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-1 ) ;
21511: LD_EXP 10
21515: PPUSH
21516: LD_STRING DStasisVS-Bur-1
21518: PPUSH
21519: CALL_OW 88
// if Titov and IsOK ( Titov ) then
21523: LD_EXP 19
21527: PUSH
21528: LD_EXP 19
21532: PPUSH
21533: CALL_OW 302
21537: AND
21538: IFFALSE 21554
// Say ( Titov , DStasisVS-Tit-2 ) else
21540: LD_EXP 19
21544: PPUSH
21545: LD_STRING DStasisVS-Tit-2
21547: PPUSH
21548: CALL_OW 88
21552: GO 21566
// Say ( Yelena , DStasisVS-Kir-2 ) ;
21554: LD_EXP 13
21558: PPUSH
21559: LD_STRING DStasisVS-Kir-2
21561: PPUSH
21562: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-2 ) ;
21566: LD_EXP 10
21570: PPUSH
21571: LD_STRING DStasisVS-Bur-2
21573: PPUSH
21574: CALL_OW 88
// wait ( 0 0$3 ) ;
21578: LD_INT 105
21580: PPUSH
21581: CALL_OW 67
// SayRadio ( Popov , DStasisVS-Pop-2 ) ;
21585: LD_EXP 12
21589: PPUSH
21590: LD_STRING DStasisVS-Pop-2
21592: PPUSH
21593: CALL_OW 94
// if Gleb and IsOK ( Gleb ) then
21597: LD_EXP 14
21601: PUSH
21602: LD_EXP 14
21606: PPUSH
21607: CALL_OW 302
21611: AND
21612: IFFALSE 21626
// Say ( Gleb , DStasisVS-Glb-2 ) ;
21614: LD_EXP 14
21618: PPUSH
21619: LD_STRING DStasisVS-Glb-2
21621: PPUSH
21622: CALL_OW 88
// end ;
21626: LD_VAR 0 1
21630: RET
// export function dialog_SeviSaved ; begin
21631: LD_INT 0
21633: PPUSH
// Say ( Burlak , DSeviSaved-Bur-1 ) ;
21634: LD_EXP 10
21638: PPUSH
21639: LD_STRING DSeviSaved-Bur-1
21641: PPUSH
21642: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-1 ) ;
21646: LD_EXP 11
21650: PPUSH
21651: LD_STRING DSeviSaved-Vse-1
21653: PPUSH
21654: CALL_OW 88
// Say ( Burlak , DSeviSaved-Bur-2 ) ;
21658: LD_EXP 10
21662: PPUSH
21663: LD_STRING DSeviSaved-Bur-2
21665: PPUSH
21666: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-2 ) ;
21670: LD_EXP 11
21674: PPUSH
21675: LD_STRING DSeviSaved-Vse-2
21677: PPUSH
21678: CALL_OW 88
// end ;
21682: LD_VAR 0 1
21686: RET
// export function dialog_MeetXavier ; begin
21687: LD_INT 0
21689: PPUSH
// Say ( Xavier , DMeetXavier-Xav-1 ) ;
21690: LD_EXP 25
21694: PPUSH
21695: LD_STRING DMeetXavier-Xav-1
21697: PPUSH
21698: CALL_OW 88
// Say ( Yelena , DMeetXavier-Kir-1 ) ;
21702: LD_EXP 13
21706: PPUSH
21707: LD_STRING DMeetXavier-Kir-1
21709: PPUSH
21710: CALL_OW 88
// Say ( Xavier , DMeetXavier-Xav-2 ) ;
21714: LD_EXP 25
21718: PPUSH
21719: LD_STRING DMeetXavier-Xav-2
21721: PPUSH
21722: CALL_OW 88
// end ;
21726: LD_VAR 0 1
21730: RET
// export function query_Xavier ; begin
21731: LD_INT 0
21733: PPUSH
// Result = Query ( QXavier ) ;
21734: LD_ADDR_VAR 0 1
21738: PUSH
21739: LD_STRING QXavier
21741: PPUSH
21742: CALL_OW 97
21746: ST_TO_ADDR
// end ;
21747: LD_VAR 0 1
21751: RET
// export function dialog_QrXavier1 ; begin
21752: LD_INT 0
21754: PPUSH
// Say ( Burlak , DQrXavier#1-Bur-1 ) ;
21755: LD_EXP 10
21759: PPUSH
21760: LD_STRING DQrXavier#1-Bur-1
21762: PPUSH
21763: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-1 ) ;
21767: LD_EXP 13
21771: PPUSH
21772: LD_STRING DQrXavier#1-Kir-1
21774: PPUSH
21775: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-1 ) ;
21779: LD_EXP 25
21783: PPUSH
21784: LD_STRING DQrXavier#1-Xav-1
21786: PPUSH
21787: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-2 ) ;
21791: LD_EXP 13
21795: PPUSH
21796: LD_STRING DQrXavier#1-Kir-2
21798: PPUSH
21799: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-2 ) ;
21803: LD_EXP 25
21807: PPUSH
21808: LD_STRING DQrXavier#1-Xav-2
21810: PPUSH
21811: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-3 ) ;
21815: LD_EXP 13
21819: PPUSH
21820: LD_STRING DQrXavier#1-Kir-3
21822: PPUSH
21823: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-3 ) ;
21827: LD_EXP 25
21831: PPUSH
21832: LD_STRING DQrXavier#1-Xav-3
21834: PPUSH
21835: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-4 ) ;
21839: LD_EXP 13
21843: PPUSH
21844: LD_STRING DQrXavier#1-Kir-4
21846: PPUSH
21847: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
21851: LD_EXP 14
21855: PUSH
21856: LD_EXP 14
21860: PPUSH
21861: CALL_OW 302
21865: AND
21866: IFFALSE 21880
// Say ( Gleb , DQrXavier#1-Glb-4 ) ;
21868: LD_EXP 14
21872: PPUSH
21873: LD_STRING DQrXavier#1-Glb-4
21875: PPUSH
21876: CALL_OW 88
// end ;
21880: LD_VAR 0 1
21884: RET
// export function dialog_QrXavier2 ; begin
21885: LD_INT 0
21887: PPUSH
// Say ( Burlak , DQrXavier#2-Bur-1 ) ;
21888: LD_EXP 10
21892: PPUSH
21893: LD_STRING DQrXavier#2-Bur-1
21895: PPUSH
21896: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-1 ) ;
21900: LD_EXP 13
21904: PPUSH
21905: LD_STRING DQrXavier#2-Kir-1
21907: PPUSH
21908: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-1 ) ;
21912: LD_EXP 25
21916: PPUSH
21917: LD_STRING DQrXavier#2-Xav-1
21919: PPUSH
21920: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-2 ) ;
21924: LD_EXP 13
21928: PPUSH
21929: LD_STRING DQrXavier#2-Kir-2
21931: PPUSH
21932: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-2 ) ;
21936: LD_EXP 25
21940: PPUSH
21941: LD_STRING DQrXavier#2-Xav-2
21943: PPUSH
21944: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-3 ) ;
21948: LD_EXP 13
21952: PPUSH
21953: LD_STRING DQrXavier#2-Kir-3
21955: PPUSH
21956: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-3 ) ;
21960: LD_EXP 25
21964: PPUSH
21965: LD_STRING DQrXavier#2-Xav-3
21967: PPUSH
21968: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-4 ) ;
21972: LD_EXP 13
21976: PPUSH
21977: LD_STRING DQrXavier#2-Kir-4
21979: PPUSH
21980: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-4 ) ;
21984: LD_EXP 25
21988: PPUSH
21989: LD_STRING DQrXavier#2-Xav-4
21991: PPUSH
21992: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-5 ) ;
21996: LD_EXP 13
22000: PPUSH
22001: LD_STRING DQrXavier#2-Kir-5
22003: PPUSH
22004: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
22008: LD_EXP 14
22012: PUSH
22013: LD_EXP 14
22017: PPUSH
22018: CALL_OW 302
22022: AND
22023: IFFALSE 22037
// Say ( Gleb , DQrXavier#2-Glb-5 ) ;
22025: LD_EXP 14
22029: PPUSH
22030: LD_STRING DQrXavier#2-Glb-5
22032: PPUSH
22033: CALL_OW 88
// end ;
22037: LD_VAR 0 1
22041: RET
// export function dialog_PointXavier ; begin
22042: LD_INT 0
22044: PPUSH
// if IsOk ( Yelena ) then
22045: LD_EXP 13
22049: PPUSH
22050: CALL_OW 302
22054: IFFALSE 22080
// begin Say ( Xavier , DPointXavier-Xav-1 ) ;
22056: LD_EXP 25
22060: PPUSH
22061: LD_STRING DPointXavier-Xav-1
22063: PPUSH
22064: CALL_OW 88
// Say ( Yelena , DPointXavier-Kir-1 ) ;
22068: LD_EXP 13
22072: PPUSH
22073: LD_STRING DPointXavier-Kir-1
22075: PPUSH
22076: CALL_OW 88
// end ; Say ( Xavier , DPointXavier-Xav-2 ) ;
22080: LD_EXP 25
22084: PPUSH
22085: LD_STRING DPointXavier-Xav-2
22087: PPUSH
22088: CALL_OW 88
// end ;
22092: LD_VAR 0 1
22096: RET
// export function query_QActivateXavier ; begin
22097: LD_INT 0
22099: PPUSH
// Result = Query ( QActivateXavier ) ;
22100: LD_ADDR_VAR 0 1
22104: PUSH
22105: LD_STRING QActivateXavier
22107: PPUSH
22108: CALL_OW 97
22112: ST_TO_ADDR
// end ;
22113: LD_VAR 0 1
22117: RET
// export function dialog_QrActivateXavier1 ; begin
22118: LD_INT 0
22120: PPUSH
// Say ( Burlak , DQrActivateXavier#1-Bur-1 ) ;
22121: LD_EXP 10
22125: PPUSH
22126: LD_STRING DQrActivateXavier#1-Bur-1
22128: PPUSH
22129: CALL_OW 88
// end ;
22133: LD_VAR 0 1
22137: RET
// export function dialog_QrActivateXavier2 ; begin
22138: LD_INT 0
22140: PPUSH
// Say ( Burlak , DQrActivateXavier#2-Bur-1 ) ;
22141: LD_EXP 10
22145: PPUSH
22146: LD_STRING DQrActivateXavier#2-Bur-1
22148: PPUSH
22149: CALL_OW 88
// end ;
22153: LD_VAR 0 1
22157: RET
// export function dialog_YashinArrives ; begin
22158: LD_INT 0
22160: PPUSH
// Say ( Yashin , DYashinArrives-Yas-1 ) ;
22161: LD_EXP 34
22165: PPUSH
22166: LD_STRING DYashinArrives-Yas-1
22168: PPUSH
22169: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22173: LD_EXP 8
22177: PUSH
22178: LD_EXP 11
22182: PPUSH
22183: CALL_OW 302
22187: AND
22188: IFFALSE 22204
// Say ( Vsevolod , DYashinArrives-Vse-1 ) else
22190: LD_EXP 11
22194: PPUSH
22195: LD_STRING DYashinArrives-Vse-1
22197: PPUSH
22198: CALL_OW 88
22202: GO 22216
// Say ( Burlak , DYashinArrives-Bur-1 ) ;
22204: LD_EXP 10
22208: PPUSH
22209: LD_STRING DYashinArrives-Bur-1
22211: PPUSH
22212: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-2 ) ;
22216: LD_EXP 34
22220: PPUSH
22221: LD_STRING DYashinArrives-Yas-2
22223: PPUSH
22224: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22228: LD_EXP 8
22232: PUSH
22233: LD_EXP 11
22237: PPUSH
22238: CALL_OW 302
22242: AND
22243: IFFALSE 22283
// begin Say ( Vsevolod , DYashinArrives-Vse-2 ) ;
22245: LD_EXP 11
22249: PPUSH
22250: LD_STRING DYashinArrives-Vse-2
22252: PPUSH
22253: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-3 ) ;
22257: LD_EXP 34
22261: PPUSH
22262: LD_STRING DYashinArrives-Yas-3
22264: PPUSH
22265: CALL_OW 88
// Say ( Vsevolod , DYashinArrives-Vse-3 ) ;
22269: LD_EXP 11
22273: PPUSH
22274: LD_STRING DYashinArrives-Vse-3
22276: PPUSH
22277: CALL_OW 88
// end else
22281: GO 22331
// begin Say ( Burlak , DYashinArrives-Bur-3 ) ;
22283: LD_EXP 10
22287: PPUSH
22288: LD_STRING DYashinArrives-Bur-3
22290: PPUSH
22291: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-4 ) ;
22295: LD_EXP 34
22299: PPUSH
22300: LD_STRING DYashinArrives-Yas-4
22302: PPUSH
22303: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-4 ) ;
22307: LD_EXP 10
22311: PPUSH
22312: LD_STRING DYashinArrives-Bur-4
22314: PPUSH
22315: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-5 ) ;
22319: LD_EXP 34
22323: PPUSH
22324: LD_STRING DYashinArrives-Yas-5
22326: PPUSH
22327: CALL_OW 88
// end ; Say ( Burlak , DYashinArrives-Bur-5 ) ;
22331: LD_EXP 10
22335: PPUSH
22336: LD_STRING DYashinArrives-Bur-5
22338: PPUSH
22339: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-6 ) ;
22343: LD_EXP 34
22347: PPUSH
22348: LD_STRING DYashinArrives-Yas-6
22350: PPUSH
22351: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-6 ) ;
22355: LD_EXP 10
22359: PPUSH
22360: LD_STRING DYashinArrives-Bur-6
22362: PPUSH
22363: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-7 ) ;
22367: LD_EXP 34
22371: PPUSH
22372: LD_STRING DYashinArrives-Yas-7
22374: PPUSH
22375: CALL_OW 88
// end ;
22379: LD_VAR 0 1
22383: RET
// export function query_YashinHelp ; begin
22384: LD_INT 0
22386: PPUSH
// Result = Query ( QYashinHelp ) ;
22387: LD_ADDR_VAR 0 1
22391: PUSH
22392: LD_STRING QYashinHelp
22394: PPUSH
22395: CALL_OW 97
22399: ST_TO_ADDR
// end ;
22400: LD_VAR 0 1
22404: RET
// export function query_YashinHelpNB ; begin
22405: LD_INT 0
22407: PPUSH
// Result = SelectiveQuery ( QYashinHelp , [ 2 , 3 ] ) ;
22408: LD_ADDR_VAR 0 1
22412: PUSH
22413: LD_STRING QYashinHelp
22415: PPUSH
22416: LD_INT 2
22418: PUSH
22419: LD_INT 3
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PPUSH
22426: CALL_OW 98
22430: ST_TO_ADDR
// end ;
22431: LD_VAR 0 1
22435: RET
// export function dialog_QrYashinHelp1 ; begin
22436: LD_INT 0
22438: PPUSH
// Say ( Burlak , DQrYashinHelp#1-Bur-1 ) ;
22439: LD_EXP 10
22443: PPUSH
22444: LD_STRING DQrYashinHelp#1-Bur-1
22446: PPUSH
22447: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-1 ) ;
22451: LD_EXP 34
22455: PPUSH
22456: LD_STRING DQrYashinHelp#1-Yas-1
22458: PPUSH
22459: CALL_OW 88
// Say ( Burlak , DQrYashinHelp#1-Bur-2 ) ;
22463: LD_EXP 10
22467: PPUSH
22468: LD_STRING DQrYashinHelp#1-Bur-2
22470: PPUSH
22471: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-2 ) ;
22475: LD_EXP 34
22479: PPUSH
22480: LD_STRING DQrYashinHelp#1-Yas-2
22482: PPUSH
22483: CALL_OW 88
// end ;
22487: LD_VAR 0 1
22491: RET
// export function dialog_QrYashinHelp2 ; begin
22492: LD_INT 0
22494: PPUSH
// Say ( Burlak , DQrYashinHelp#2-Bur-1 ) ;
22495: LD_EXP 10
22499: PPUSH
22500: LD_STRING DQrYashinHelp#2-Bur-1
22502: PPUSH
22503: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#2-Yas-1 ) ;
22507: LD_EXP 34
22511: PPUSH
22512: LD_STRING DQrYashinHelp#2-Yas-1
22514: PPUSH
22515: CALL_OW 88
// end ;
22519: LD_VAR 0 1
22523: RET
// export function dialog_QrYashinHelp3 ; begin
22524: LD_INT 0
22526: PPUSH
// Say ( Burlak , DQrYashinHelp#3-Bur-1 ) ;
22527: LD_EXP 10
22531: PPUSH
22532: LD_STRING DQrYashinHelp#3-Bur-1
22534: PPUSH
22535: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#3-Yas-1 ) ;
22539: LD_EXP 34
22543: PPUSH
22544: LD_STRING DQrYashinHelp#3-Yas-1
22546: PPUSH
22547: CALL_OW 88
// end ;
22551: LD_VAR 0 1
22555: RET
// var BylHint ; export function dialog_YashinLeave ; begin
22556: LD_INT 0
22558: PPUSH
// Say ( Yashin , DYashinLeave-Yas-1 ) ;
22559: LD_EXP 34
22563: PPUSH
22564: LD_STRING DYashinLeave-Yas-1
22566: PPUSH
22567: CALL_OW 88
// Say ( Burlak , DYashinLeave-Bur-1 ) ;
22571: LD_EXP 10
22575: PPUSH
22576: LD_STRING DYashinLeave-Bur-1
22578: PPUSH
22579: CALL_OW 88
// if not BylHint then
22583: LD_LOC 56
22587: NOT
22588: IFFALSE 22605
// begin Hint ( YashinVeh ) ;
22590: LD_STRING YashinVeh
22592: PPUSH
22593: CALL_OW 339
// BylHint = true ;
22597: LD_ADDR_LOC 56
22601: PUSH
22602: LD_INT 1
22604: ST_TO_ADDR
// end ; end ;
22605: LD_VAR 0 1
22609: RET
// export function dialog_YashinAttack ; begin
22610: LD_INT 0
22612: PPUSH
// Say ( Burlak , DYashinAttack-Bur-1 ) ;
22613: LD_EXP 10
22617: PPUSH
22618: LD_STRING DYashinAttack-Bur-1
22620: PPUSH
22621: CALL_OW 88
// end ;
22625: LD_VAR 0 1
22629: RET
// export function dialog_HeikeObj ; begin
22630: LD_INT 0
22632: PPUSH
// SayRadio ( Popov , DHeikeObj-Pop-1 ) ;
22633: LD_EXP 12
22637: PPUSH
22638: LD_STRING DHeikeObj-Pop-1
22640: PPUSH
22641: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-1 ) ;
22645: LD_EXP 10
22649: PPUSH
22650: LD_STRING DHeikeObj-Bur-1
22652: PPUSH
22653: CALL_OW 88
// SayRadio ( Popov , DHeikeObj-Pop-2 ) ;
22657: LD_EXP 12
22661: PPUSH
22662: LD_STRING DHeikeObj-Pop-2
22664: PPUSH
22665: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-2 ) ;
22669: LD_EXP 10
22673: PPUSH
22674: LD_STRING DHeikeObj-Bur-2
22676: PPUSH
22677: CALL_OW 88
// end ;
22681: LD_VAR 0 1
22685: RET
// export function dialog_HeikeCapt ; begin
22686: LD_INT 0
22688: PPUSH
// Say ( Heike , DHeikeCapt-Hke-1 ) ;
22689: LD_EXP 26
22693: PPUSH
22694: LD_STRING DHeikeCapt-Hke-1
22696: PPUSH
22697: CALL_OW 88
// Say ( Burlak , DHeikeCapt-Bur-1 ) ;
22701: LD_EXP 10
22705: PPUSH
22706: LD_STRING DHeikeCapt-Bur-1
22708: PPUSH
22709: CALL_OW 88
// Say ( Heike , DHeikeCapt-Hke-2 ) ;
22713: LD_EXP 26
22717: PPUSH
22718: LD_STRING DHeikeCapt-Hke-2
22720: PPUSH
22721: CALL_OW 88
// end ; end_of_file
22725: LD_VAR 0 1
22729: RET
// every 0 0$2 + 0 0$0.1 do
22730: GO 22732
22732: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
22733: LD_INT 22
22735: PUSH
22736: LD_INT 3
22738: PUSH
22739: EMPTY
22740: LIST
22741: LIST
22742: PUSH
22743: LD_INT 2
22745: PUSH
22746: LD_INT 25
22748: PUSH
22749: LD_INT 12
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: PUSH
22756: LD_INT 25
22758: PUSH
22759: LD_INT 16
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: PUSH
22766: LD_INT 25
22768: PUSH
22769: LD_INT 15
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 25
22778: PUSH
22779: LD_INT 17
22781: PUSH
22782: EMPTY
22783: LIST
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: PUSH
22793: EMPTY
22794: LIST
22795: LIST
22796: PPUSH
22797: CALL_OW 69
22801: PUSH
22802: LD_INT 22
22804: PUSH
22805: LD_INT 3
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: PUSH
22812: LD_INT 21
22814: PUSH
22815: LD_INT 1
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: PUSH
22822: LD_INT 3
22824: PUSH
22825: LD_INT 2
22827: PUSH
22828: LD_INT 25
22830: PUSH
22831: LD_INT 12
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: PUSH
22838: LD_INT 25
22840: PUSH
22841: LD_INT 16
22843: PUSH
22844: EMPTY
22845: LIST
22846: LIST
22847: PUSH
22848: LD_INT 25
22850: PUSH
22851: LD_INT 15
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: PUSH
22858: LD_INT 25
22860: PUSH
22861: LD_INT 17
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: LIST
22883: PPUSH
22884: CALL_OW 69
22888: GREATER
22889: IFFALSE 22900
// begin SetAchievement ( ACH_POTA ) ;
22891: LD_STRING ACH_POTA
22893: PPUSH
22894: CALL_OW 543
// exit ;
22898: GO 22901
// end ; enable ;
22900: ENABLE
// end ;
22901: END
// export function SA_LieXavier ; begin
22902: LD_INT 0
22904: PPUSH
// SetAchievement ( ACH_LIA ) ;
22905: LD_STRING ACH_LIA
22907: PPUSH
22908: CALL_OW 543
// end ; end_of_file
22912: LD_VAR 0 1
22916: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
22917: LD_INT 0
22919: PPUSH
22920: PPUSH
// if not missionNumber then
22921: LD_VAR 0 2
22925: NOT
22926: IFFALSE 22930
// exit ;
22928: GO 23060
// achiv := false ;
22930: LD_ADDR_VAR 0 7
22934: PUSH
22935: LD_INT 0
22937: ST_TO_ADDR
// case campaignNumber of 1 :
22938: LD_VAR 0 1
22942: PUSH
22943: LD_INT 1
22945: DOUBLE
22946: EQUAL
22947: IFTRUE 22951
22949: GO 22962
22951: POP
// achiv := ACH_GOTA ; 2 :
22952: LD_ADDR_VAR 0 7
22956: PUSH
22957: LD_STRING ACH_GOTA
22959: ST_TO_ADDR
22960: GO 23012
22962: LD_INT 2
22964: DOUBLE
22965: EQUAL
22966: IFTRUE 22970
22968: GO 22973
22970: POP
// ; 3 :
22971: GO 23012
22973: LD_INT 3
22975: DOUBLE
22976: EQUAL
22977: IFTRUE 22981
22979: GO 22992
22981: POP
// achiv := ACH_MOTSU ; 4 :
22982: LD_ADDR_VAR 0 7
22986: PUSH
22987: LD_STRING ACH_MOTSU
22989: ST_TO_ADDR
22990: GO 23012
22992: LD_INT 4
22994: DOUBLE
22995: EQUAL
22996: IFTRUE 23000
22998: GO 23011
23000: POP
// achiv := ACH_LOP ; end ;
23001: LD_ADDR_VAR 0 7
23005: PUSH
23006: LD_STRING ACH_LOP
23008: ST_TO_ADDR
23009: GO 23012
23011: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
23012: LD_OWVAR 67
23016: PUSH
23017: LD_INT 3
23019: EQUAL
23020: PUSH
23021: LD_VAR 0 7
23025: AND
23026: PUSH
23027: LD_VAR 0 3
23031: AND
23032: PUSH
23033: LD_VAR 0 4
23037: AND
23038: PUSH
23039: LD_VAR 0 5
23043: AND
23044: IFFALSE 23060
// SetAchievementEX ( achiv , missionNumber ) ;
23046: LD_VAR 0 7
23050: PPUSH
23051: LD_VAR 0 2
23055: PPUSH
23056: CALL_OW 564
// end ;
23060: LD_VAR 0 6
23064: RET

// export side_Neutral , side_Ru , side_Ru2 , side_Ar , side_Xavier , side_Heike , side_Strazci ; export VsevSaved , HeikeCaptured ; export Burlak , Vsevolod , Popov , Yelena , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin ; export Rusaci , WithVsevolod ; export Konvoj ; export Xavier , Heike , Heikeovci ; export ContactIn5Min , PropaslQuickly ; export Minuty ; var FalesnaYelena ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// end ;
  74: LD_VAR 0 2
  78: RET
// function load_set ( Ident ) ; begin
  79: LD_INT 0
  81: PPUSH
// if TestCharacters ( Ident ) then
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL_OW 28
  91: IFFALSE 110
// Result = CreateCharacterSet ( Ident ) else
  93: LD_ADDR_VAR 0 2
  97: PUSH
  98: LD_VAR 0 1
 102: PPUSH
 103: CALL_OW 31
 107: ST_TO_ADDR
 108: GO 117
// Result = [ ] ;
 110: LD_ADDR_VAR 0 2
 114: PUSH
 115: EMPTY
 116: ST_TO_ADDR
// end ;
 117: LD_VAR 0 2
 121: RET
// function save_char ( Handle , Ident ) ; begin
 122: LD_INT 0
 124: PPUSH
// if Handle then
 125: LD_VAR 0 1
 129: IFFALSE 148
// SaveCharacters ( [ Handle ] , Ident ) ;
 131: LD_VAR 0 1
 135: PUSH
 136: EMPTY
 137: LIST
 138: PPUSH
 139: LD_VAR 0 2
 143: PPUSH
 144: CALL_OW 38
// end ;
 148: LD_VAR 0 3
 152: RET
// function vytvor_yelenu ; begin
 153: LD_INT 0
 155: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 156: LD_ADDR_OWVAR 21
 160: PUSH
 161: LD_INT 3
 163: ST_TO_ADDR
// UC_Side = side_Ru2 ;
 164: LD_ADDR_OWVAR 20
 168: PUSH
 169: LD_EXP 3
 173: ST_TO_ADDR
// HC_name = Yelena Trajkov ;
 174: LD_ADDR_OWVAR 26
 178: PUSH
 179: LD_STRING Yelena Trajkov
 181: ST_TO_ADDR
// HC_sex = SEX_FEMALE ;
 182: LD_ADDR_OWVAR 27
 186: PUSH
 187: LD_INT 2
 189: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 190: LD_ADDR_OWVAR 28
 194: PUSH
 195: LD_INT 1
 197: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
 198: LD_INT 5
 200: PPUSH
 201: CALL_OW 375
// Result = CreateHuman ;
 205: LD_ADDR_VAR 0 1
 209: PUSH
 210: CALL_OW 44
 214: ST_TO_ADDR
// end ;
 215: LD_VAR 0 1
 219: RET
// function load_konvoj ; var Convoy_06 , Spec , Tmp ; var MaxCnt , MaxCans , MaxOil , MaxSib , Cans , Oil , Sib ; var TedCans , TedOil , TedSib ; begin
 220: LD_INT 0
 222: PPUSH
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
 235: PPUSH
// Convoy_06 = LoadVariable ( Convoy_06 , [ ] ) ;
 236: LD_ADDR_VAR 0 2
 240: PUSH
 241: LD_STRING Convoy_06
 243: PPUSH
 244: EMPTY
 245: PPUSH
 246: CALL_OW 30
 250: ST_TO_ADDR
// DeleteVariable ( Convoy_06 ) ;
 251: LD_STRING Convoy_06
 253: PPUSH
 254: CALL_OW 41
// if not Convoy_06 then
 258: LD_VAR 0 2
 262: NOT
 263: IFFALSE 377
// Convoy_06 = [ [ NATION_RUSSIAN , RU_HEAVY_MACHINE_GUN , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 0 , 0 , 0 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 30 , 50 , 20 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 40 , 50 , 10 ] ] ;
 265: LD_ADDR_VAR 0 2
 269: PUSH
 270: LD_INT 3
 272: PUSH
 273: LD_INT 42
 275: PUSH
 276: LD_INT 1
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 21
 284: PUSH
 285: LD_INT 0
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: EMPTY
 295: LIST
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_INT 3
 306: PUSH
 307: LD_INT 51
 309: PUSH
 310: LD_INT 1
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 30
 321: PUSH
 322: LD_INT 50
 324: PUSH
 325: LD_INT 20
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: LIST
 336: LIST
 337: PUSH
 338: LD_INT 3
 340: PUSH
 341: LD_INT 51
 343: PUSH
 344: LD_INT 1
 346: PUSH
 347: LD_INT 1
 349: PUSH
 350: LD_INT 21
 352: PUSH
 353: LD_INT 40
 355: PUSH
 356: LD_INT 50
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: LIST
 376: ST_TO_ADDR
// UC_Side = side_Ru ;
 377: LD_ADDR_OWVAR 20
 381: PUSH
 382: LD_EXP 2
 386: ST_TO_ADDR
// Konvoj = [ ] ;
 387: LD_ADDR_EXP 24
 391: PUSH
 392: EMPTY
 393: ST_TO_ADDR
// Tmp = dif_MaxKonvojCargo [ Difficulty ] ;
 394: LD_ADDR_VAR 0 4
 398: PUSH
 399: LD_EXP 53
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// MaxCnt = Tmp [ 1 ] ;
 410: LD_ADDR_VAR 0 5
 414: PUSH
 415: LD_VAR 0 4
 419: PUSH
 420: LD_INT 1
 422: ARRAY
 423: ST_TO_ADDR
// MaxCans = Tmp [ 2 ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 4
 433: PUSH
 434: LD_INT 2
 436: ARRAY
 437: ST_TO_ADDR
// MaxOil = Tmp [ 3 ] ;
 438: LD_ADDR_VAR 0 7
 442: PUSH
 443: LD_VAR 0 4
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: ST_TO_ADDR
// MaxSib = Tmp [ 4 ] ;
 452: LD_ADDR_VAR 0 8
 456: PUSH
 457: LD_VAR 0 4
 461: PUSH
 462: LD_INT 4
 464: ARRAY
 465: ST_TO_ADDR
// for Spec in Convoy_06 do
 466: LD_ADDR_VAR 0 3
 470: PUSH
 471: LD_VAR 0 2
 475: PUSH
 476: FOR_IN
 477: IFFALSE 657
// begin UC_Nation = Spec [ 1 ] ;
 479: LD_ADDR_OWVAR 21
 483: PUSH
 484: LD_VAR 0 3
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: ST_TO_ADDR
// VC_Weapon = Spec [ 2 ] ;
 493: LD_ADDR_OWVAR 40
 497: PUSH
 498: LD_VAR 0 3
 502: PUSH
 503: LD_INT 2
 505: ARRAY
 506: ST_TO_ADDR
// VC_Control = Spec [ 3 ] ;
 507: LD_ADDR_OWVAR 38
 511: PUSH
 512: LD_VAR 0 3
 516: PUSH
 517: LD_INT 3
 519: ARRAY
 520: ST_TO_ADDR
// VC_Engine = Spec [ 4 ] ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: LD_VAR 0 3
 530: PUSH
 531: LD_INT 4
 533: ARRAY
 534: ST_TO_ADDR
// VC_Chassis = Spec [ 5 ] ;
 535: LD_ADDR_OWVAR 37
 539: PUSH
 540: LD_VAR 0 3
 544: PUSH
 545: LD_INT 5
 547: ARRAY
 548: ST_TO_ADDR
// Tmp = CreateVehicle ;
 549: LD_ADDR_VAR 0 4
 553: PUSH
 554: CALL_OW 45
 558: ST_TO_ADDR
// AddCargo ( Tmp , MAT_CANS , Spec [ 6 ] ) ;
 559: LD_VAR 0 4
 563: PPUSH
 564: LD_INT 1
 566: PPUSH
 567: LD_VAR 0 3
 571: PUSH
 572: LD_INT 6
 574: ARRAY
 575: PPUSH
 576: CALL_OW 291
// AddCargo ( Tmp , MAT_OIL , Spec [ 7 ] ) ;
 580: LD_VAR 0 4
 584: PPUSH
 585: LD_INT 2
 587: PPUSH
 588: LD_VAR 0 3
 592: PUSH
 593: LD_INT 7
 595: ARRAY
 596: PPUSH
 597: CALL_OW 291
// AddCargo ( Tmp , MAT_SIBERIT , Spec [ 8 ] ) ;
 601: LD_VAR 0 4
 605: PPUSH
 606: LD_INT 3
 608: PPUSH
 609: LD_VAR 0 3
 613: PUSH
 614: LD_INT 8
 616: ARRAY
 617: PPUSH
 618: CALL_OW 291
// Konvoj = Konvoj union [ Tmp ] ;
 622: LD_ADDR_EXP 24
 626: PUSH
 627: LD_EXP 24
 631: PUSH
 632: LD_VAR 0 4
 636: PUSH
 637: EMPTY
 638: LIST
 639: UNION
 640: ST_TO_ADDR
// if Konvoj >= MaxCnt then
 641: LD_EXP 24
 645: PUSH
 646: LD_VAR 0 5
 650: GREATEREQUAL
 651: IFFALSE 655
// break ;
 653: GO 657
// end ;
 655: GO 476
 657: POP
 658: POP
// Cans = 0 ;
 659: LD_ADDR_VAR 0 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// Oil = 0 ;
 667: LD_ADDR_VAR 0 10
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// Sib = 0 ;
 675: LD_ADDR_VAR 0 11
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for Spec in Konvoj do
 683: LD_ADDR_VAR 0 3
 687: PUSH
 688: LD_EXP 24
 692: PUSH
 693: FOR_IN
 694: IFFALSE 998
// begin TedCans = GetCargo ( Spec , MAT_CANS ) ;
 696: LD_ADDR_VAR 0 12
 700: PUSH
 701: LD_VAR 0 3
 705: PPUSH
 706: LD_INT 1
 708: PPUSH
 709: CALL_OW 289
 713: ST_TO_ADDR
// TedOil = GetCargo ( Spec , MAT_OIL ) ;
 714: LD_ADDR_VAR 0 13
 718: PUSH
 719: LD_VAR 0 3
 723: PPUSH
 724: LD_INT 2
 726: PPUSH
 727: CALL_OW 289
 731: ST_TO_ADDR
// TedSib = GetCargo ( Spec , MAT_SIBERIT ) ;
 732: LD_ADDR_VAR 0 14
 736: PUSH
 737: LD_VAR 0 3
 741: PPUSH
 742: LD_INT 3
 744: PPUSH
 745: CALL_OW 289
 749: ST_TO_ADDR
// if Cans + TedCans > MaxCans then
 750: LD_VAR 0 9
 754: PUSH
 755: LD_VAR 0 12
 759: PLUS
 760: PUSH
 761: LD_VAR 0 6
 765: GREATER
 766: IFFALSE 784
// TedCans = MaxCans - Cans ;
 768: LD_ADDR_VAR 0 12
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_VAR 0 9
 782: MINUS
 783: ST_TO_ADDR
// if Oil + TedOil > MaxOil then
 784: LD_VAR 0 10
 788: PUSH
 789: LD_VAR 0 13
 793: PLUS
 794: PUSH
 795: LD_VAR 0 7
 799: GREATER
 800: IFFALSE 818
// TedOil = MaxOil - Oil ;
 802: LD_ADDR_VAR 0 13
 806: PUSH
 807: LD_VAR 0 7
 811: PUSH
 812: LD_VAR 0 10
 816: MINUS
 817: ST_TO_ADDR
// if Sib + TedSib > MaxSib then
 818: LD_VAR 0 11
 822: PUSH
 823: LD_VAR 0 14
 827: PLUS
 828: PUSH
 829: LD_VAR 0 8
 833: GREATER
 834: IFFALSE 852
// TedSib = MaxSib - Sib ;
 836: LD_ADDR_VAR 0 14
 840: PUSH
 841: LD_VAR 0 8
 845: PUSH
 846: LD_VAR 0 11
 850: MINUS
 851: ST_TO_ADDR
// SetCargo ( Spec , MAT_CANS , 0 ) ;
 852: LD_VAR 0 3
 856: PPUSH
 857: LD_INT 1
 859: PPUSH
 860: LD_INT 0
 862: PPUSH
 863: CALL_OW 290
// SetCargo ( Spec , MAT_OIL , 0 ) ;
 867: LD_VAR 0 3
 871: PPUSH
 872: LD_INT 2
 874: PPUSH
 875: LD_INT 0
 877: PPUSH
 878: CALL_OW 290
// SetCargo ( Spec , MAT_SIBERIT , 0 ) ;
 882: LD_VAR 0 3
 886: PPUSH
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 290
// AddCargo ( Spec , MAT_CANS , TedCans ) ;
 897: LD_VAR 0 3
 901: PPUSH
 902: LD_INT 1
 904: PPUSH
 905: LD_VAR 0 12
 909: PPUSH
 910: CALL_OW 291
// AddCargo ( Spec , MAT_SIBERIT , TedSib ) ;
 914: LD_VAR 0 3
 918: PPUSH
 919: LD_INT 3
 921: PPUSH
 922: LD_VAR 0 14
 926: PPUSH
 927: CALL_OW 291
// AddCargo ( Spec , MAT_OIL , TedOil ) ;
 931: LD_VAR 0 3
 935: PPUSH
 936: LD_INT 2
 938: PPUSH
 939: LD_VAR 0 13
 943: PPUSH
 944: CALL_OW 291
// Cans = Cans + TedCans ;
 948: LD_ADDR_VAR 0 9
 952: PUSH
 953: LD_VAR 0 9
 957: PUSH
 958: LD_VAR 0 12
 962: PLUS
 963: ST_TO_ADDR
// Oil = Oil + TedOil ;
 964: LD_ADDR_VAR 0 10
 968: PUSH
 969: LD_VAR 0 10
 973: PUSH
 974: LD_VAR 0 13
 978: PLUS
 979: ST_TO_ADDR
// Sib = Sib + TedSib ;
 980: LD_ADDR_VAR 0 11
 984: PUSH
 985: LD_VAR 0 11
 989: PUSH
 990: LD_VAR 0 14
 994: PLUS
 995: ST_TO_ADDR
// end ;
 996: GO 693
 998: POP
 999: POP
// end ;
1000: LD_VAR 0 1
1004: RET
// function load ; begin
1005: LD_INT 0
1007: PPUSH
// UC_Nation = NATION_RUSSIAN ;
1008: LD_ADDR_OWVAR 21
1012: PUSH
1013: LD_INT 3
1015: ST_TO_ADDR
// UC_Side = side_Ru ;
1016: LD_ADDR_OWVAR 20
1020: PUSH
1021: LD_EXP 2
1025: ST_TO_ADDR
// VsevSaved = LoadVariable ( VsevSaved , false ) ;
1026: LD_ADDR_EXP 8
1030: PUSH
1031: LD_STRING VsevSaved
1033: PPUSH
1034: LD_INT 0
1036: PPUSH
1037: CALL_OW 30
1041: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
1042: LD_ADDR_EXP 10
1046: PUSH
1047: LD_STRING Burlak
1049: PPUSH
1050: CALL 0 0 1
1054: ST_TO_ADDR
// Vsevolod = load_char ( Vsevolod ) ;
1055: LD_ADDR_EXP 11
1059: PUSH
1060: LD_STRING Vsevolod
1062: PPUSH
1063: CALL 0 0 1
1067: ST_TO_ADDR
// if IsDead ( Vsevolod ) then
1068: LD_EXP 11
1072: PPUSH
1073: CALL_OW 301
1077: IFFALSE 1087
// VsevSaved = false ;
1079: LD_ADDR_EXP 8
1083: PUSH
1084: LD_INT 0
1086: ST_TO_ADDR
// Yelena = load_char ( Kirilenkova ) ;
1087: LD_ADDR_EXP 13
1091: PUSH
1092: LD_STRING Kirilenkova
1094: PPUSH
1095: CALL 0 0 1
1099: ST_TO_ADDR
// if not Yelena or IsDead ( Yelena ) then
1100: LD_EXP 13
1104: NOT
1105: PUSH
1106: LD_EXP 13
1110: PPUSH
1111: CALL_OW 301
1115: OR
1116: IFFALSE 1138
// begin Yelena = vytvor_yelenu ;
1118: LD_ADDR_EXP 13
1122: PUSH
1123: CALL 153 0 0
1127: ST_TO_ADDR
// FalesnaYelena = true ;
1128: LD_ADDR_LOC 1
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// end else
1136: GO 1146
// FalesnaYelena = false ;
1138: LD_ADDR_LOC 1
1142: PUSH
1143: LD_INT 0
1145: ST_TO_ADDR
// if VsevSaved then
1146: LD_EXP 8
1150: IFFALSE 1158
// load_vs else
1152: CALL 1382 0 0
1156: GO 1162
// load_nv ;
1158: CALL 1167 0 0
// end ;
1162: LD_VAR 0 1
1166: RET
// function load_nv ; var Ostatni ; begin
1167: LD_INT 0
1169: PPUSH
1170: PPUSH
// Karamazov = load_char ( Karamazov ) ;
1171: LD_ADDR_EXP 16
1175: PUSH
1176: LD_STRING Karamazov
1178: PPUSH
1179: CALL 0 0 1
1183: ST_TO_ADDR
// Petrovova = load_char ( Petrovova ) ;
1184: LD_ADDR_EXP 17
1188: PUSH
1189: LD_STRING Petrovova
1191: PPUSH
1192: CALL 0 0 1
1196: ST_TO_ADDR
// Gleb = load_char ( Gleb ) ;
1197: LD_ADDR_EXP 14
1201: PUSH
1202: LD_STRING Gleb
1204: PPUSH
1205: CALL 0 0 1
1209: ST_TO_ADDR
// Petrosyan = load_char ( Petrosyan ) ;
1210: LD_ADDR_EXP 15
1214: PUSH
1215: LD_STRING Petrosyan
1217: PPUSH
1218: CALL 0 0 1
1222: ST_TO_ADDR
// Lipshchin = load_char ( Lipshchin ) ;
1223: LD_ADDR_EXP 21
1227: PUSH
1228: LD_STRING Lipshchin
1230: PPUSH
1231: CALL 0 0 1
1235: ST_TO_ADDR
// Titov = load_char ( Titov ) ;
1236: LD_ADDR_EXP 19
1240: PUSH
1241: LD_STRING Titov
1243: PPUSH
1244: CALL 0 0 1
1248: ST_TO_ADDR
// Dolgov = load_char ( Dolgov ) ;
1249: LD_ADDR_EXP 18
1253: PUSH
1254: LD_STRING Dolgov
1256: PPUSH
1257: CALL 0 0 1
1261: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1262: LD_ADDR_EXP 12
1266: PUSH
1267: LD_STRING Popov
1269: PPUSH
1270: CALL_OW 25
1274: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1275: LD_ADDR_EXP 20
1279: PUSH
1280: LD_STRING Platonov
1282: PPUSH
1283: CALL_OW 25
1287: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1288: LD_ADDR_VAR 0 2
1292: PUSH
1293: LD_STRING Survivors2
1295: PPUSH
1296: CALL 79 0 1
1300: ST_TO_ADDR
// Rusaci = Ostatni union [ Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov ] diff [ 0 ] ;
1301: LD_ADDR_EXP 22
1305: PUSH
1306: LD_VAR 0 2
1310: PUSH
1311: LD_EXP 16
1315: PUSH
1316: LD_EXP 17
1320: PUSH
1321: LD_EXP 14
1325: PUSH
1326: LD_EXP 15
1330: PUSH
1331: LD_EXP 21
1335: PUSH
1336: LD_EXP 19
1340: PUSH
1341: LD_EXP 18
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: UNION
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: DIFF
1362: ST_TO_ADDR
// SetSide ( Rusaci , side_Ru ) ;
1363: LD_EXP 22
1367: PPUSH
1368: LD_EXP 2
1372: PPUSH
1373: CALL_OW 235
// end ;
1377: LD_VAR 0 1
1381: RET
// function load_vs ; var Ostatni ; var KaramazovLoc , PetrovovaLoc , GlebLoc , PetrosyanLoc ; var LipshchinLoc , TitovLoc , DolgovLoc ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
1391: PPUSH
1392: PPUSH
// KaramazovLoc = LoadVariable ( KaramazovLoc , 0 ) ;
1393: LD_ADDR_VAR 0 3
1397: PUSH
1398: LD_STRING KaramazovLoc
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 30
1408: ST_TO_ADDR
// PetrovovaLoc = LoadVariable ( PetrovovaLoc , 0 ) ;
1409: LD_ADDR_VAR 0 4
1413: PUSH
1414: LD_STRING PetrovovaLoc
1416: PPUSH
1417: LD_INT 0
1419: PPUSH
1420: CALL_OW 30
1424: ST_TO_ADDR
// GlebLoc = LoadVariable ( GlebLoc , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_STRING GlebLoc
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 30
1440: ST_TO_ADDR
// PetrosyanLoc = LoadVariable ( PetrosyanLoc , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_STRING PetrosyanLoc
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 30
1456: ST_TO_ADDR
// LipshchinLoc = LoadVariable ( LipshchinLoc , 0 ) ;
1457: LD_ADDR_VAR 0 7
1461: PUSH
1462: LD_STRING LipshchinLoc
1464: PPUSH
1465: LD_INT 0
1467: PPUSH
1468: CALL_OW 30
1472: ST_TO_ADDR
// TitovLoc = LoadVariable ( TitovLoc , 0 ) ;
1473: LD_ADDR_VAR 0 8
1477: PUSH
1478: LD_STRING TitovLoc
1480: PPUSH
1481: LD_INT 0
1483: PPUSH
1484: CALL_OW 30
1488: ST_TO_ADDR
// DolgovLoc = LoadVariable ( DolgovLoc , 0 ) ;
1489: LD_ADDR_VAR 0 9
1493: PUSH
1494: LD_STRING DolgovLoc
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 30
1504: ST_TO_ADDR
// if KaramazovLoc in [ 7 , - 7 ] then
1505: LD_VAR 0 3
1509: PUSH
1510: LD_INT 7
1512: PUSH
1513: LD_INT 7
1515: NEG
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: IN
1521: IFFALSE 1536
// Karamazov = load_char ( Karamazov ) ;
1523: LD_ADDR_EXP 16
1527: PUSH
1528: LD_STRING Karamazov
1530: PPUSH
1531: CALL 0 0 1
1535: ST_TO_ADDR
// if PetrovovaLoc in [ 7 , - 7 ] then
1536: LD_VAR 0 4
1540: PUSH
1541: LD_INT 7
1543: PUSH
1544: LD_INT 7
1546: NEG
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: IN
1552: IFFALSE 1567
// Petrovova = load_char ( Petrovova ) ;
1554: LD_ADDR_EXP 17
1558: PUSH
1559: LD_STRING Petrovova
1561: PPUSH
1562: CALL 0 0 1
1566: ST_TO_ADDR
// if GlebLoc in [ 7 , - 7 ] then
1567: LD_VAR 0 5
1571: PUSH
1572: LD_INT 7
1574: PUSH
1575: LD_INT 7
1577: NEG
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: IN
1583: IFFALSE 1598
// Gleb = load_char ( Gleb ) ;
1585: LD_ADDR_EXP 14
1589: PUSH
1590: LD_STRING Gleb
1592: PPUSH
1593: CALL 0 0 1
1597: ST_TO_ADDR
// if PetrosyanLoc in [ 7 , - 7 ] then
1598: LD_VAR 0 6
1602: PUSH
1603: LD_INT 7
1605: PUSH
1606: LD_INT 7
1608: NEG
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: IN
1614: IFFALSE 1629
// Petrosyan = load_char ( Petrosyan ) ;
1616: LD_ADDR_EXP 15
1620: PUSH
1621: LD_STRING Petrosyan
1623: PPUSH
1624: CALL 0 0 1
1628: ST_TO_ADDR
// if LipshchinLoc in [ 7 , - 7 ] then
1629: LD_VAR 0 7
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_INT 7
1639: NEG
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: IN
1645: IFFALSE 1660
// Lipshchin = load_char ( Lipshchin ) ;
1647: LD_ADDR_EXP 21
1651: PUSH
1652: LD_STRING Lipshchin
1654: PPUSH
1655: CALL 0 0 1
1659: ST_TO_ADDR
// if TitovLoc in [ 7 , - 7 ] then
1660: LD_VAR 0 8
1664: PUSH
1665: LD_INT 7
1667: PUSH
1668: LD_INT 7
1670: NEG
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: IN
1676: IFFALSE 1691
// Titov = load_char ( Titov ) ;
1678: LD_ADDR_EXP 19
1682: PUSH
1683: LD_STRING Titov
1685: PPUSH
1686: CALL 0 0 1
1690: ST_TO_ADDR
// if DolgovLoc in [ 7 , - 7 ] then
1691: LD_VAR 0 9
1695: PUSH
1696: LD_INT 7
1698: PUSH
1699: LD_INT 7
1701: NEG
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: IN
1707: IFFALSE 1722
// Dolgov = load_char ( Dolgov ) ;
1709: LD_ADDR_EXP 18
1713: PUSH
1714: LD_STRING Dolgov
1716: PPUSH
1717: CALL 0 0 1
1721: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1722: LD_ADDR_VAR 0 2
1726: PUSH
1727: LD_STRING Survivors2
1729: PPUSH
1730: CALL 79 0 1
1734: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1735: LD_ADDR_EXP 12
1739: PUSH
1740: LD_STRING Popov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1748: LD_ADDR_EXP 20
1752: PUSH
1753: LD_STRING Platonov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// WithVsevolod = [ Yelena ] union load_set ( WithVsevolod ) ;
1761: LD_ADDR_EXP 23
1765: PUSH
1766: LD_EXP 13
1770: PUSH
1771: EMPTY
1772: LIST
1773: PUSH
1774: LD_STRING WithVsevolod
1776: PPUSH
1777: CALL 79 0 1
1781: UNION
1782: ST_TO_ADDR
// Rusaci = Ostatni ;
1783: LD_ADDR_EXP 22
1787: PUSH
1788: LD_VAR 0 2
1792: ST_TO_ADDR
// if KaramazovLoc = 7 then
1793: LD_VAR 0 3
1797: PUSH
1798: LD_INT 7
1800: EQUAL
1801: IFFALSE 1824
// Rusaci = Rusaci union [ Karamazov ] else
1803: LD_ADDR_EXP 22
1807: PUSH
1808: LD_EXP 22
1812: PUSH
1813: LD_EXP 16
1817: PUSH
1818: EMPTY
1819: LIST
1820: UNION
1821: ST_TO_ADDR
1822: GO 1854
// if KaramazovLoc = - 7 then
1824: LD_VAR 0 3
1828: PUSH
1829: LD_INT 7
1831: NEG
1832: EQUAL
1833: IFFALSE 1854
// WithVsevolod = WithVsevolod union [ Karamazov ] ;
1835: LD_ADDR_EXP 23
1839: PUSH
1840: LD_EXP 23
1844: PUSH
1845: LD_EXP 16
1849: PUSH
1850: EMPTY
1851: LIST
1852: UNION
1853: ST_TO_ADDR
// if PetrovovaLoc = 7 then
1854: LD_VAR 0 4
1858: PUSH
1859: LD_INT 7
1861: EQUAL
1862: IFFALSE 1885
// Rusaci = Rusaci union [ Petrovova ] else
1864: LD_ADDR_EXP 22
1868: PUSH
1869: LD_EXP 22
1873: PUSH
1874: LD_EXP 17
1878: PUSH
1879: EMPTY
1880: LIST
1881: UNION
1882: ST_TO_ADDR
1883: GO 1915
// if PetrovovaLoc = - 7 then
1885: LD_VAR 0 4
1889: PUSH
1890: LD_INT 7
1892: NEG
1893: EQUAL
1894: IFFALSE 1915
// WithVsevolod = WithVsevolod union [ Petrovova ] ;
1896: LD_ADDR_EXP 23
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_EXP 17
1910: PUSH
1911: EMPTY
1912: LIST
1913: UNION
1914: ST_TO_ADDR
// if GlebLoc = 7 then
1915: LD_VAR 0 5
1919: PUSH
1920: LD_INT 7
1922: EQUAL
1923: IFFALSE 1946
// Rusaci = Rusaci union [ Gleb ] else
1925: LD_ADDR_EXP 22
1929: PUSH
1930: LD_EXP 22
1934: PUSH
1935: LD_EXP 14
1939: PUSH
1940: EMPTY
1941: LIST
1942: UNION
1943: ST_TO_ADDR
1944: GO 1976
// if GlebLoc = - 7 then
1946: LD_VAR 0 5
1950: PUSH
1951: LD_INT 7
1953: NEG
1954: EQUAL
1955: IFFALSE 1976
// WithVsevolod = WithVsevolod union [ Gleb ] ;
1957: LD_ADDR_EXP 23
1961: PUSH
1962: LD_EXP 23
1966: PUSH
1967: LD_EXP 14
1971: PUSH
1972: EMPTY
1973: LIST
1974: UNION
1975: ST_TO_ADDR
// if PetrosyanLoc = 7 then
1976: LD_VAR 0 6
1980: PUSH
1981: LD_INT 7
1983: EQUAL
1984: IFFALSE 2007
// Rusaci = Rusaci union [ Petrosyan ] else
1986: LD_ADDR_EXP 22
1990: PUSH
1991: LD_EXP 22
1995: PUSH
1996: LD_EXP 15
2000: PUSH
2001: EMPTY
2002: LIST
2003: UNION
2004: ST_TO_ADDR
2005: GO 2037
// if PetrosyanLoc = - 7 then
2007: LD_VAR 0 6
2011: PUSH
2012: LD_INT 7
2014: NEG
2015: EQUAL
2016: IFFALSE 2037
// WithVsevolod = WithVsevolod union [ Petrosyan ] ;
2018: LD_ADDR_EXP 23
2022: PUSH
2023: LD_EXP 23
2027: PUSH
2028: LD_EXP 15
2032: PUSH
2033: EMPTY
2034: LIST
2035: UNION
2036: ST_TO_ADDR
// if LipshchinLoc = 7 then
2037: LD_VAR 0 7
2041: PUSH
2042: LD_INT 7
2044: EQUAL
2045: IFFALSE 2068
// Rusaci = Rusaci union [ Lipshchin ] else
2047: LD_ADDR_EXP 22
2051: PUSH
2052: LD_EXP 22
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: EMPTY
2063: LIST
2064: UNION
2065: ST_TO_ADDR
2066: GO 2098
// if LipshchinLoc = - 7 then
2068: LD_VAR 0 7
2072: PUSH
2073: LD_INT 7
2075: NEG
2076: EQUAL
2077: IFFALSE 2098
// WithVsevolod = WithVsevolod union [ Lipshchin ] ;
2079: LD_ADDR_EXP 23
2083: PUSH
2084: LD_EXP 23
2088: PUSH
2089: LD_EXP 21
2093: PUSH
2094: EMPTY
2095: LIST
2096: UNION
2097: ST_TO_ADDR
// if TitovLoc = 7 then
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 7
2105: EQUAL
2106: IFFALSE 2129
// Rusaci = Rusaci union [ Titov ] else
2108: LD_ADDR_EXP 22
2112: PUSH
2113: LD_EXP 22
2117: PUSH
2118: LD_EXP 19
2122: PUSH
2123: EMPTY
2124: LIST
2125: UNION
2126: ST_TO_ADDR
2127: GO 2159
// if TitovLoc = - 7 then
2129: LD_VAR 0 8
2133: PUSH
2134: LD_INT 7
2136: NEG
2137: EQUAL
2138: IFFALSE 2159
// WithVsevolod = WithVsevolod union [ Titov ] ;
2140: LD_ADDR_EXP 23
2144: PUSH
2145: LD_EXP 23
2149: PUSH
2150: LD_EXP 19
2154: PUSH
2155: EMPTY
2156: LIST
2157: UNION
2158: ST_TO_ADDR
// if DolgovLoc = 7 then
2159: LD_VAR 0 9
2163: PUSH
2164: LD_INT 7
2166: EQUAL
2167: IFFALSE 2190
// Rusaci = Rusaci union [ Dolgov ] else
2169: LD_ADDR_EXP 22
2173: PUSH
2174: LD_EXP 22
2178: PUSH
2179: LD_EXP 18
2183: PUSH
2184: EMPTY
2185: LIST
2186: UNION
2187: ST_TO_ADDR
2188: GO 2220
// if DolgovLoc = - 7 then
2190: LD_VAR 0 9
2194: PUSH
2195: LD_INT 7
2197: NEG
2198: EQUAL
2199: IFFALSE 2220
// WithVsevolod = WithVsevolod union [ Dolgov ] ;
2201: LD_ADDR_EXP 23
2205: PUSH
2206: LD_EXP 23
2210: PUSH
2211: LD_EXP 18
2215: PUSH
2216: EMPTY
2217: LIST
2218: UNION
2219: ST_TO_ADDR
// while ( Rusaci union WithVsevolod ) < 6 do
2220: LD_EXP 22
2224: PUSH
2225: LD_EXP 23
2229: UNION
2230: PUSH
2231: LD_INT 6
2233: LESS
2234: IFFALSE 2257
// WithVsevolod = WithVsevolod union [ vytvor_rusaka ] ;
2236: LD_ADDR_EXP 23
2240: PUSH
2241: LD_EXP 23
2245: PUSH
2246: CALL 4013 0 0
2250: PUSH
2251: EMPTY
2252: LIST
2253: UNION
2254: ST_TO_ADDR
2255: GO 2220
// load_konvoj ;
2257: CALL 220 0 0
// SetSide ( Rusaci , side_Ru ) ;
2261: LD_EXP 22
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL_OW 235
// SetSide ( Konvoj , side_Ru ) ;
2275: LD_EXP 24
2279: PPUSH
2280: LD_EXP 2
2284: PPUSH
2285: CALL_OW 235
// SetSide ( Vsevolod , side_Ru2 ) ;
2289: LD_EXP 11
2293: PPUSH
2294: LD_EXP 3
2298: PPUSH
2299: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru2 ) ;
2303: LD_EXP 23
2307: PPUSH
2308: LD_EXP 3
2312: PPUSH
2313: CALL_OW 235
// end ;
2317: LD_VAR 0 1
2321: RET
// function save ; var Lidi , Ostatni , Opice ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
2326: PPUSH
2327: PPUSH
// DeleteVariable ( Convoy_06 ) ;
2328: LD_STRING Convoy_06
2330: PPUSH
2331: CALL_OW 41
// HeikeCaptured = Heike and IsOK ( Heike ) ;
2335: LD_ADDR_EXP 9
2339: PUSH
2340: LD_EXP 26
2344: PUSH
2345: LD_EXP 26
2349: PPUSH
2350: CALL_OW 302
2354: AND
2355: ST_TO_ADDR
// SaveVariable ( HeikeCaptured , HeikeCaptured ) ;
2356: LD_EXP 9
2360: PPUSH
2361: LD_STRING HeikeCaptured
2363: PPUSH
2364: CALL_OW 39
// SaveVariable ( not HeikeCaptured , HeikeKilled ) ;
2368: LD_EXP 9
2372: NOT
2373: PPUSH
2374: LD_STRING HeikeKilled
2376: PPUSH
2377: CALL_OW 39
// save_char ( Burlak , Burlak ) ;
2381: LD_EXP 10
2385: PPUSH
2386: LD_STRING Burlak
2388: PPUSH
2389: CALL 122 0 2
// if not FalesnaYelena then
2393: LD_LOC 1
2397: NOT
2398: IFFALSE 2412
// save_char ( Yelena , Kirilenkova ) ;
2400: LD_EXP 13
2404: PPUSH
2405: LD_STRING Kirilenkova
2407: PPUSH
2408: CALL 122 0 2
// save_char ( Karamazov , Karamazov ) ;
2412: LD_EXP 16
2416: PPUSH
2417: LD_STRING Karamazov
2419: PPUSH
2420: CALL 122 0 2
// save_char ( Petrovova , Petrovova ) ;
2424: LD_EXP 17
2428: PPUSH
2429: LD_STRING Petrovova
2431: PPUSH
2432: CALL 122 0 2
// save_char ( Gleb , Gleb ) ;
2436: LD_EXP 14
2440: PPUSH
2441: LD_STRING Gleb
2443: PPUSH
2444: CALL 122 0 2
// save_char ( Petrosyan , Petrosyan ) ;
2448: LD_EXP 15
2452: PPUSH
2453: LD_STRING Petrosyan
2455: PPUSH
2456: CALL 122 0 2
// save_char ( Lipshchin , Lipshchin ) ;
2460: LD_EXP 21
2464: PPUSH
2465: LD_STRING Lipshchin
2467: PPUSH
2468: CALL 122 0 2
// save_char ( Titov , Titov ) ;
2472: LD_EXP 19
2476: PPUSH
2477: LD_STRING Titov
2479: PPUSH
2480: CALL 122 0 2
// save_char ( Dolgov , Dolgov ) ;
2484: LD_EXP 18
2488: PPUSH
2489: LD_STRING Dolgov
2491: PPUSH
2492: CALL 122 0 2
// save_char ( Vsevolod , Vsevolod ) ;
2496: LD_EXP 11
2500: PPUSH
2501: LD_STRING Vsevolod
2503: PPUSH
2504: CALL 122 0 2
// SaveCharacters ( [ Xavier ] , Xavier ) ;
2508: LD_EXP 25
2512: PUSH
2513: EMPTY
2514: LIST
2515: PPUSH
2516: LD_STRING Xavier
2518: PPUSH
2519: CALL_OW 38
// SaveCharacters ( [ Heike ] , Heike ) ;
2523: LD_EXP 26
2527: PUSH
2528: EMPTY
2529: LIST
2530: PPUSH
2531: LD_STRING Heike
2533: PPUSH
2534: CALL_OW 38
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_ALIVE ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_INT 22
2545: PUSH
2546: LD_EXP 2
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_INT 51
2557: PUSH
2558: EMPTY
2559: LIST
2560: PUSH
2561: LD_INT 21
2563: PUSH
2564: LD_INT 1
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: LD_VAR 0 2
2590: PPUSH
2591: LD_INT 2
2593: PUSH
2594: LD_INT 25
2596: PUSH
2597: LD_INT 12
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: PUSH
2604: LD_INT 25
2606: PUSH
2607: LD_INT 15
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: PUSH
2614: LD_INT 25
2616: PUSH
2617: LD_INT 16
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 25
2626: PUSH
2627: LD_INT 17
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: PPUSH
2644: CALL_OW 72
2648: ST_TO_ADDR
// Ostatni = Lidi diff [ 0 , Burlak , Vsevolod , Heike , Yelena , Popov , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin , Yashin , Xavier ] ;
2649: LD_ADDR_VAR 0 3
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_INT 0
2661: PUSH
2662: LD_EXP 10
2666: PUSH
2667: LD_EXP 11
2671: PUSH
2672: LD_EXP 26
2676: PUSH
2677: LD_EXP 13
2681: PUSH
2682: LD_EXP 12
2686: PUSH
2687: LD_EXP 14
2691: PUSH
2692: LD_EXP 15
2696: PUSH
2697: LD_EXP 16
2701: PUSH
2702: LD_EXP 17
2706: PUSH
2707: LD_EXP 18
2711: PUSH
2712: LD_EXP 19
2716: PUSH
2717: LD_EXP 20
2721: PUSH
2722: LD_EXP 21
2726: PUSH
2727: LD_EXP 34
2731: PUSH
2732: LD_EXP 25
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: DIFF
2755: ST_TO_ADDR
// Ostatni = Ostatni diff Opice ;
2756: LD_ADDR_VAR 0 3
2760: PUSH
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 4
2770: DIFF
2771: ST_TO_ADDR
// if FalesnaYelena and IsOk ( Yelena ) then
2772: LD_LOC 1
2776: PUSH
2777: LD_EXP 13
2781: PPUSH
2782: CALL_OW 302
2786: AND
2787: IFFALSE 2808
// Ostatni = Ostatni union [ Yelena ] ;
2789: LD_ADDR_VAR 0 3
2793: PUSH
2794: LD_VAR 0 3
2798: PUSH
2799: LD_EXP 13
2803: PUSH
2804: EMPTY
2805: LIST
2806: UNION
2807: ST_TO_ADDR
// SaveCharacters ( Ostatni , Survivors2 ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: LD_STRING Survivors2
2815: PPUSH
2816: CALL_OW 38
// end ;
2820: LD_VAR 0 1
2824: RET
// function dej_medaile ; begin
2825: LD_INT 0
2827: PPUSH
// if Xavier and IsLive ( Xavier ) then
2828: LD_EXP 25
2832: PUSH
2833: LD_EXP 25
2837: PPUSH
2838: CALL_OW 300
2842: AND
2843: IFFALSE 2857
// AddMedal ( Xavier , 1 ) else
2845: LD_STRING Xavier
2847: PPUSH
2848: LD_INT 1
2850: PPUSH
2851: CALL_OW 101
2855: GO 2868
// AddMedal ( Xavier , - 1 ) ;
2857: LD_STRING Xavier
2859: PPUSH
2860: LD_INT 1
2862: NEG
2863: PPUSH
2864: CALL_OW 101
// if VsevSaved then
2868: LD_EXP 8
2872: IFFALSE 2905
// if PropaslQuickly then
2874: LD_EXP 29
2878: IFFALSE 2893
// AddMedal ( TimeVS , - 1 ) else
2880: LD_STRING TimeVS
2882: PPUSH
2883: LD_INT 1
2885: NEG
2886: PPUSH
2887: CALL_OW 101
2891: GO 2903
// AddMedal ( TimeVS , 1 ) else
2893: LD_STRING TimeVS
2895: PPUSH
2896: LD_INT 1
2898: PPUSH
2899: CALL_OW 101
2903: GO 2934
// if ContactIn5Min then
2905: LD_EXP 28
2909: IFFALSE 2923
// AddMedal ( TimeNV , 1 ) else
2911: LD_STRING TimeNV
2913: PPUSH
2914: LD_INT 1
2916: PPUSH
2917: CALL_OW 101
2921: GO 2934
// AddMedal ( TimeNV , - 1 ) ;
2923: LD_STRING TimeNV
2925: PPUSH
2926: LD_INT 1
2928: NEG
2929: PPUSH
2930: CALL_OW 101
// if IsOK ( Heike ) then
2934: LD_EXP 26
2938: PPUSH
2939: CALL_OW 302
2943: IFFALSE 2957
// AddMedal ( Heike , 1 ) else
2945: LD_STRING Heike
2947: PPUSH
2948: LD_INT 1
2950: PPUSH
2951: CALL_OW 101
2955: GO 2968
// AddMedal ( Heike , - 1 ) ;
2957: LD_STRING Heike
2959: PPUSH
2960: LD_INT 1
2962: NEG
2963: PPUSH
2964: CALL_OW 101
// end ;
2968: LD_VAR 0 1
2972: RET
// export function vyhral ( Ident ) ; var Lidi , Opice ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
2977: PPUSH
// dej_medaile ;
2978: CALL 2825 0 0
// GiveMedals ( Ident ) ;
2982: LD_VAR 0 1
2986: PPUSH
2987: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2991: LD_ADDR_VAR 0 3
2995: PUSH
2996: LD_INT 22
2998: PUSH
2999: LD_EXP 2
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 21
3010: PUSH
3011: LD_INT 1
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: PUSH
3018: LD_INT 51
3020: PUSH
3021: EMPTY
3022: LIST
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: LIST
3028: PPUSH
3029: CALL_OW 69
3033: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
3034: LD_ADDR_VAR 0 4
3038: PUSH
3039: LD_VAR 0 3
3043: PPUSH
3044: LD_INT 2
3046: PUSH
3047: LD_INT 25
3049: PUSH
3050: LD_INT 12
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 25
3059: PUSH
3060: LD_INT 15
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 25
3069: PUSH
3070: LD_INT 16
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: LD_INT 25
3079: PUSH
3080: LD_INT 17
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: PPUSH
3097: CALL_OW 72
3101: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
3102: LD_VAR 0 3
3106: PUSH
3107: LD_VAR 0 4
3111: DIFF
3112: PPUSH
3113: CALL_OW 43
// save ;
3117: CALL 2322 0 0
// YouWin ;
3121: CALL_OW 103
// end ;
3125: LD_VAR 0 2
3129: RET
// function set_attitudes ; begin
3130: LD_INT 0
3132: PPUSH
// ChangeSideFog ( side_Xavier , GetSideFog ( side_Ru ) ) ;
3133: LD_EXP 5
3137: PPUSH
3138: LD_EXP 2
3142: PPUSH
3143: CALL_OW 342
3147: PPUSH
3148: CALL_OW 343
// ChangeSideFog ( side_Ru2 , GetSideFog ( side_Ru ) ) ;
3152: LD_EXP 3
3156: PPUSH
3157: LD_EXP 2
3161: PPUSH
3162: CALL_OW 342
3166: PPUSH
3167: CALL_OW 343
// SetAttitude ( side_Ru2 , side_Ru , ATT_FRIEND , true ) ;
3171: LD_EXP 3
3175: PPUSH
3176: LD_EXP 2
3180: PPUSH
3181: LD_INT 1
3183: PPUSH
3184: LD_INT 1
3186: PPUSH
3187: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Ar , ATT_ENEMY , false ) ;
3191: LD_EXP 3
3195: PPUSH
3196: LD_EXP 4
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: LD_INT 0
3206: PPUSH
3207: CALL_OW 80
// SetAttitude ( side_Ar , side_Ru2 , ATT_FRIEND , false ) ;
3211: LD_EXP 4
3215: PPUSH
3216: LD_EXP 3
3220: PPUSH
3221: LD_INT 1
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Strazci , ATT_ENEMY , false ) ;
3231: LD_EXP 3
3235: PPUSH
3236: LD_EXP 7
3240: PPUSH
3241: LD_INT 2
3243: PPUSH
3244: LD_INT 0
3246: PPUSH
3247: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Heike , ATT_NEUTRAL , false ) ;
3251: LD_EXP 3
3255: PPUSH
3256: LD_EXP 6
3260: PPUSH
3261: LD_INT 0
3263: PPUSH
3264: LD_INT 0
3266: PPUSH
3267: CALL_OW 80
// SetAttitude ( side_Strazci , side_Ru2 , ATT_NEUTRAL , false ) ;
3271: LD_EXP 7
3275: PPUSH
3276: LD_EXP 3
3280: PPUSH
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 0
3286: PPUSH
3287: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru2 , ATT_NEUTRAL , false ) ;
3291: LD_EXP 6
3295: PPUSH
3296: LD_EXP 3
3300: PPUSH
3301: LD_INT 0
3303: PPUSH
3304: LD_INT 0
3306: PPUSH
3307: CALL_OW 80
// SetAttitude ( side_Ru , side_Xavier , ATT_FRIEND , true ) ;
3311: LD_EXP 2
3315: PPUSH
3316: LD_EXP 5
3320: PPUSH
3321: LD_INT 1
3323: PPUSH
3324: LD_INT 1
3326: PPUSH
3327: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Xavier , ATT_FRIEND , true ) ;
3331: LD_EXP 3
3335: PPUSH
3336: LD_EXP 5
3340: PPUSH
3341: LD_INT 1
3343: PPUSH
3344: LD_INT 1
3346: PPUSH
3347: CALL_OW 80
// SetAttitude ( side_Ar , side_Xavier , ATT_FRIEND , true ) ;
3351: LD_EXP 4
3355: PPUSH
3356: LD_EXP 5
3360: PPUSH
3361: LD_INT 1
3363: PPUSH
3364: LD_INT 1
3366: PPUSH
3367: CALL_OW 80
// SetAttitude ( side_Heike , side_Xavier , ATT_NEUTRAL , true ) ;
3371: LD_EXP 6
3375: PPUSH
3376: LD_EXP 5
3380: PPUSH
3381: LD_INT 0
3383: PPUSH
3384: LD_INT 1
3386: PPUSH
3387: CALL_OW 80
// SetAttitude ( side_Strazci , side_Xavier , ATT_NEUTRAL , true ) ;
3391: LD_EXP 7
3395: PPUSH
3396: LD_EXP 5
3400: PPUSH
3401: LD_INT 0
3403: PPUSH
3404: LD_INT 1
3406: PPUSH
3407: CALL_OW 80
// SetAttitude ( side_Ru , side_Heike , ATT_NEUTRAL , false ) ;
3411: LD_EXP 2
3415: PPUSH
3416: LD_EXP 6
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 0
3426: PPUSH
3427: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru , ATT_ENEMY , false ) ;
3431: LD_EXP 6
3435: PPUSH
3436: LD_EXP 2
3440: PPUSH
3441: LD_INT 2
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 80
// SetAttitude ( side_Heike , side_Ar , ATT_FRIEND , true ) ;
3451: LD_EXP 6
3455: PPUSH
3456: LD_EXP 4
3460: PPUSH
3461: LD_INT 1
3463: PPUSH
3464: LD_INT 1
3466: PPUSH
3467: CALL_OW 80
// SetAttitude ( side_Heike , side_Strazci , ATT_FRIEND , true ) ;
3471: LD_EXP 6
3475: PPUSH
3476: LD_EXP 7
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: CALL_OW 80
// SetAttitude ( side_Ar , side_Strazci , ATT_FRIEND , true ) ;
3491: LD_EXP 4
3495: PPUSH
3496: LD_EXP 7
3500: PPUSH
3501: LD_INT 1
3503: PPUSH
3504: LD_INT 1
3506: PPUSH
3507: CALL_OW 80
// end ;
3511: LD_VAR 0 1
3515: RET
// starting begin RandomizeAll ;
3516: CALL_OW 11
// AutoEnemy = false ;
3520: LD_ADDR_OWVAR 74
3524: PUSH
3525: LD_INT 0
3527: ST_TO_ADDR
// side_Neutral = 0 ;
3528: LD_ADDR_EXP 1
3532: PUSH
3533: LD_INT 0
3535: ST_TO_ADDR
// side_Ar = 2 ;
3536: LD_ADDR_EXP 4
3540: PUSH
3541: LD_INT 2
3543: ST_TO_ADDR
// side_Ru = 3 ;
3544: LD_ADDR_EXP 2
3548: PUSH
3549: LD_INT 3
3551: ST_TO_ADDR
// side_Ru2 = 6 ;
3552: LD_ADDR_EXP 3
3556: PUSH
3557: LD_INT 6
3559: ST_TO_ADDR
// side_Xavier = 5 ;
3560: LD_ADDR_EXP 5
3564: PUSH
3565: LD_INT 5
3567: ST_TO_ADDR
// side_Heike = 7 ;
3568: LD_ADDR_EXP 6
3572: PUSH
3573: LD_INT 7
3575: ST_TO_ADDR
// side_Strazci = 8 ;
3576: LD_ADDR_EXP 7
3580: PUSH
3581: LD_INT 8
3583: ST_TO_ADDR
// set_attitudes ;
3584: CALL 3130 0 0
// ContactIn5Min = 0 ;
3588: LD_ADDR_EXP 28
3592: PUSH
3593: LD_INT 0
3595: ST_TO_ADDR
// PropaslQuickly = 0 ;
3596: LD_ADDR_EXP 29
3600: PUSH
3601: LD_INT 0
3603: ST_TO_ADDR
// Minuty = 0 ;
3604: LD_ADDR_EXP 30
3608: PUSH
3609: LD_INT 0
3611: ST_TO_ADDR
// InitUc ;
3612: CALL_OW 18
// InitBc ;
3616: CALL_OW 21
// InitHc ;
3620: CALL_OW 19
// InitVc ;
3624: CALL_OW 20
// init_difficulty ;
3628: CALL 19998 0 0
// load ;
3632: CALL 1005 0 0
// init_nature ;
3636: CALL 21181 0 0
// init_suroviny ;
3640: CALL 19207 0 0
// init_arabi ;
3644: CALL 6326 0 0
// init_rusove ;
3648: CALL 3688 0 0
// init_xavier ;
3652: CALL 15051 0 0
// init_heike ;
3656: CALL 16997 0 0
// init_yashin ;
3660: CALL 13021 0 0
// uvod ;
3664: CALL 3751 0 0
// end ;
3668: END
// every 1 1$0 do
3669: GO 3671
3671: DISABLE
// begin Minuty = Minuty + 1 ;
3672: LD_ADDR_EXP 30
3676: PUSH
3677: LD_EXP 30
3681: PUSH
3682: LD_INT 1
3684: PLUS
3685: ST_TO_ADDR
// enable ;
3686: ENABLE
// end ; end_of_file
3687: END
// export RuDepot , RuLab , RuOil ; var VidelAraby ; var YashinZacal ; var KdoSlaplNaMinu ; export function init_rusove ; begin
3688: LD_INT 0
3690: PPUSH
// disable ( 1 ) ;
3691: LD_INT 1
3693: DISABLE_MARKED
// disable ( 2 ) ;
3694: LD_INT 2
3696: DISABLE_MARKED
// disable ( 3 ) ;
3697: LD_INT 3
3699: DISABLE_MARKED
// disable ( 4 ) ;
3700: LD_INT 4
3702: DISABLE_MARKED
// disable ( 5 ) ;
3703: LD_INT 5
3705: DISABLE_MARKED
// RuDepot = 0 ;
3706: LD_ADDR_EXP 31
3710: PUSH
3711: LD_INT 0
3713: ST_TO_ADDR
// RuLab = 0 ;
3714: LD_ADDR_EXP 32
3718: PUSH
3719: LD_INT 0
3721: ST_TO_ADDR
// RuOil = 0 ;
3722: LD_ADDR_EXP 33
3726: PUSH
3727: LD_INT 0
3729: ST_TO_ADDR
// VidelAraby = false ;
3730: LD_ADDR_LOC 2
3734: PUSH
3735: LD_INT 0
3737: ST_TO_ADDR
// YashinZacal = false ;
3738: LD_ADDR_LOC 3
3742: PUSH
3743: LD_INT 0
3745: ST_TO_ADDR
// end ;
3746: LD_VAR 0 1
3750: RET
// export function uvod ; begin
3751: LD_INT 0
3753: PPUSH
// SetResourceVisibility ( 47 , 75 , side_Ru ) ;
3754: LD_INT 47
3756: PPUSH
3757: LD_INT 75
3759: PPUSH
3760: LD_EXP 2
3764: PPUSH
3765: CALL_OW 441
// if VsevSaved then
3769: LD_EXP 8
3773: IFFALSE 3781
// uvod_vsevolod else
3775: CALL 4088 0 0
3779: GO 3785
// uvod_sam ;
3781: CALL 5502 0 0
// Hint ( NonCombat ) ;
3785: LD_STRING NonCombat
3787: PPUSH
3788: CALL_OW 339
// end ;
3792: LD_VAR 0 1
3796: RET
// function priprav_zakladnu ; var Base ; begin
3797: LD_INT 0
3799: PPUSH
3800: PPUSH
// UC_Nation = NATION_RUSSIAN ;
3801: LD_ADDR_OWVAR 21
3805: PUSH
3806: LD_INT 3
3808: ST_TO_ADDR
// UC_side = side_Ru ;
3809: LD_ADDR_OWVAR 20
3813: PUSH
3814: LD_EXP 2
3818: ST_TO_ADDR
// BC_Level = 4 ;
3819: LD_ADDR_OWVAR 43
3823: PUSH
3824: LD_INT 4
3826: ST_TO_ADDR
// BC_Type = B_DEPOT ;
3827: LD_ADDR_OWVAR 42
3831: PUSH
3832: LD_INT 0
3834: ST_TO_ADDR
// RuDepot = CreateAndPlaceBuildingXYD ( 35 , 58 , 1 ) ;
3835: LD_ADDR_EXP 31
3839: PUSH
3840: LD_INT 35
3842: PPUSH
3843: LD_INT 58
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: CALL_OW 47
3853: ST_TO_ADDR
// BC_Type = B_OIL_POWER ;
3854: LD_ADDR_OWVAR 42
3858: PUSH
3859: LD_INT 26
3861: ST_TO_ADDR
// RuOil = CreateAndPlaceBuildingXYD ( 31 , 45 , 1 ) ;
3862: LD_ADDR_EXP 33
3866: PUSH
3867: LD_INT 31
3869: PPUSH
3870: LD_INT 45
3872: PPUSH
3873: LD_INT 1
3875: PPUSH
3876: CALL_OW 47
3880: ST_TO_ADDR
// BC_Type = B_LAB_HALF ;
3881: LD_ADDR_OWVAR 42
3885: PUSH
3886: LD_INT 7
3888: ST_TO_ADDR
// BC_Kind1 = B_LAB_SPACETIME ;
3889: LD_ADDR_OWVAR 44
3893: PUSH
3894: LD_INT 14
3896: ST_TO_ADDR
// BC_Kind2 = B_LAB_BASIC ;
3897: LD_ADDR_OWVAR 45
3901: PUSH
3902: LD_INT 9
3904: ST_TO_ADDR
// RuLab = CreateAndPlaceBuildingXYD ( 37 , 52 , 2 ) ;
3905: LD_ADDR_EXP 32
3909: PUSH
3910: LD_INT 37
3912: PPUSH
3913: LD_INT 52
3915: PPUSH
3916: LD_INT 2
3918: PPUSH
3919: CALL_OW 47
3923: ST_TO_ADDR
// Base = GetBase ( RuDepot ) ;
3924: LD_ADDR_VAR 0 2
3928: PUSH
3929: LD_EXP 31
3933: PPUSH
3934: CALL_OW 274
3938: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , dif_Cans [ Difficulty ] ) ;
3939: LD_VAR 0 2
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: LD_EXP 44
3951: PUSH
3952: LD_OWVAR 67
3956: ARRAY
3957: PPUSH
3958: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , dif_Oil [ Difficulty ] ) ;
3962: LD_VAR 0 2
3966: PPUSH
3967: LD_INT 2
3969: PPUSH
3970: LD_EXP 45
3974: PUSH
3975: LD_OWVAR 67
3979: ARRAY
3980: PPUSH
3981: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , dif_Siberit [ Difficulty ] ) ;
3985: LD_VAR 0 2
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: LD_EXP 46
3997: PUSH
3998: LD_OWVAR 67
4002: ARRAY
4003: PPUSH
4004: CALL_OW 277
// end ;
4008: LD_VAR 0 1
4012: RET
// export function vytvor_rusaka ; begin
4013: LD_INT 0
4015: PPUSH
// UC_Nation = NATION_RUSSIAN ;
4016: LD_ADDR_OWVAR 21
4020: PUSH
4021: LD_INT 3
4023: ST_TO_ADDR
// UC_side = side_Ru ;
4024: LD_ADDR_OWVAR 20
4028: PUSH
4029: LD_EXP 2
4033: ST_TO_ADDR
// HC_name =  ;
4034: LD_ADDR_OWVAR 26
4038: PUSH
4039: LD_STRING 
4041: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
4042: LD_ADDR_OWVAR 27
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 2
4052: PPUSH
4053: CALL_OW 12
4057: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
4058: LD_ADDR_OWVAR 28
4062: PUSH
4063: LD_INT 1
4065: ST_TO_ADDR
// PrepareSoldierSkills ( 4 ) ;
4066: LD_INT 4
4068: PPUSH
4069: CALL_OW 375
// Result = CreateHuman ;
4073: LD_ADDR_VAR 0 1
4077: PUSH
4078: CALL_OW 44
4082: ST_TO_ADDR
// end ;
4083: LD_VAR 0 1
4087: RET
// function uvod_vsevolod ; var I , Counter , X , Y , Seznam , Ridici ; begin
4088: LD_INT 0
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
// priprav_zakladnu ;
4097: CALL 3797 0 0
// if GetClass ( Yelena ) = CLASS_SCIENTISTIC then
4101: LD_EXP 13
4105: PPUSH
4106: CALL_OW 257
4110: PUSH
4111: LD_INT 4
4113: EQUAL
4114: IFFALSE 4128
// SetClass ( Yelena , CLASS_ENGINEER ) ;
4116: LD_EXP 13
4120: PPUSH
4121: LD_INT 2
4123: PPUSH
4124: CALL_OW 336
// if GetClass ( Burlak ) = CLASS_SCIENTISTIC then
4128: LD_EXP 10
4132: PPUSH
4133: CALL_OW 257
4137: PUSH
4138: LD_INT 4
4140: EQUAL
4141: IFFALSE 4155
// SetClass ( Burlak , CLASS_ENGINEER ) ;
4143: LD_EXP 10
4147: PPUSH
4148: LD_INT 2
4150: PPUSH
4151: CALL_OW 336
// Seznam = UnitFilter ( Rusaci union WithVsevolod , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
4155: LD_ADDR_VAR 0 6
4159: PUSH
4160: LD_EXP 22
4164: PUSH
4165: LD_EXP 23
4169: UNION
4170: PPUSH
4171: LD_INT 25
4173: PUSH
4174: LD_INT 4
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: EMPTY
4182: LIST
4183: PPUSH
4184: CALL_OW 72
4188: ST_TO_ADDR
// for I in Seznam do
4189: LD_ADDR_VAR 0 2
4193: PUSH
4194: LD_VAR 0 6
4198: PUSH
4199: FOR_IN
4200: IFFALSE 4216
// SetClass ( I , CLASS_SOLDIER ) ;
4202: LD_VAR 0 2
4206: PPUSH
4207: LD_INT 1
4209: PPUSH
4210: CALL_OW 336
4214: GO 4199
4216: POP
4217: POP
// SetTech ( TECH_TAUFIELD , side_Ru , STATE_RESEARCHED ) ;
4218: LD_INT 30
4220: PPUSH
4221: LD_EXP 2
4225: PPUSH
4226: LD_INT 2
4228: PPUSH
4229: CALL_OW 322
// SetTech ( TECH_TAUFIELD , side_Ru2 , STATE_RESEARCHED ) ;
4233: LD_INT 30
4235: PPUSH
4236: LD_EXP 3
4240: PPUSH
4241: LD_INT 2
4243: PPUSH
4244: CALL_OW 322
// PlaceUnitArea ( Vsevolod , Start1Vsevolod , false ) ;
4248: LD_EXP 11
4252: PPUSH
4253: LD_INT 16
4255: PPUSH
4256: LD_INT 0
4258: PPUSH
4259: CALL_OW 49
// X = GetX ( Vsevolod ) ;
4263: LD_ADDR_VAR 0 4
4267: PUSH
4268: LD_EXP 11
4272: PPUSH
4273: CALL_OW 250
4277: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4278: LD_ADDR_VAR 0 5
4282: PUSH
4283: LD_EXP 11
4287: PPUSH
4288: CALL_OW 251
4292: ST_TO_ADDR
// PlaceUnitXYR ( Burlak , X , Y , 6 , false ) ;
4293: LD_EXP 10
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: LD_VAR 0 5
4307: PPUSH
4308: LD_INT 6
4310: PPUSH
4311: LD_INT 0
4313: PPUSH
4314: CALL_OW 50
// Seznam = UnitFilter ( Konvoj , [ [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
4318: LD_ADDR_VAR 0 6
4322: PUSH
4323: LD_EXP 24
4327: PPUSH
4328: LD_INT 33
4330: PUSH
4331: LD_INT 1
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: EMPTY
4339: LIST
4340: PPUSH
4341: CALL_OW 72
4345: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , Seznam ) ;
4346: LD_ADDR_VAR 0 7
4350: PUSH
4351: LD_EXP 22
4355: PPUSH
4356: LD_VAR 0 6
4360: PPUSH
4361: CALL 5408 0 2
4365: ST_TO_ADDR
// for I = 1 to Seznam do
4366: LD_ADDR_VAR 0 2
4370: PUSH
4371: DOUBLE
4372: LD_INT 1
4374: DEC
4375: ST_TO_ADDR
4376: LD_VAR 0 6
4380: PUSH
4381: FOR_TO
4382: IFFALSE 4424
// if Ridici >= I then
4384: LD_VAR 0 7
4388: PUSH
4389: LD_VAR 0 2
4393: GREATEREQUAL
4394: IFFALSE 4422
// PlaceHumanInUnit ( Ridici [ I ] , Seznam [ I ] ) ;
4396: LD_VAR 0 7
4400: PUSH
4401: LD_VAR 0 2
4405: ARRAY
4406: PPUSH
4407: LD_VAR 0 6
4411: PUSH
4412: LD_VAR 0 2
4416: ARRAY
4417: PPUSH
4418: CALL_OW 52
4422: GO 4381
4424: POP
4425: POP
// place_list ( Konvoj , Start1 ) ;
4426: LD_EXP 24
4430: PPUSH
4431: LD_INT 12
4433: PPUSH
4434: CALL 20594 0 2
// place_list ( Rusaci diff Ridici , Start1 ) ;
4438: LD_EXP 22
4442: PUSH
4443: LD_VAR 0 7
4447: DIFF
4448: PPUSH
4449: LD_INT 12
4451: PPUSH
4452: CALL 20594 0 2
// place_list ( Yelena , Start1Vsevolod ) ;
4456: LD_EXP 13
4460: PPUSH
4461: LD_INT 16
4463: PPUSH
4464: CALL 20594 0 2
// place_list ( WithVsevolod , Start1Vsevolod ) ;
4468: LD_EXP 23
4472: PPUSH
4473: LD_INT 16
4475: PPUSH
4476: CALL 20594 0 2
// InGameOn ;
4480: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
4484: LD_EXP 10
4488: PPUSH
4489: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
4493: LD_EXP 10
4497: PUSH
4498: EMPTY
4499: LIST
4500: PPUSH
4501: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
4505: LD_EXP 10
4509: PUSH
4510: EMPTY
4511: LIST
4512: PPUSH
4513: CALL_OW 85
// dialog_Start ;
4517: CALL 21237 0 0
// dialog_StartVS ;
4521: CALL 21257 0 0
// dialog_Start2 ;
4525: CALL 21297 0 0
// ChangeMissionObjectives ( MStart ) ;
4529: LD_STRING MStart
4531: PPUSH
4532: CALL_OW 337
// jdete_k_sobe ( Burlak , Vsevolod ) ;
4536: LD_EXP 10
4540: PPUSH
4541: LD_EXP 11
4545: PPUSH
4546: CALL 20515 0 2
// AddComHold ( [ Burlak , Vsevolod ] ) ;
4550: LD_EXP 10
4554: PUSH
4555: LD_EXP 11
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PPUSH
4564: CALL_OW 200
// CenterOnUnits ( [ Burlak , Vsevolod ] ) ;
4568: LD_EXP 10
4572: PUSH
4573: LD_EXP 11
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL_OW 85
// RevealFogArea ( side_Ru , RuDepotFog ) ;
4586: LD_EXP 2
4590: PPUSH
4591: LD_INT 15
4593: PPUSH
4594: CALL_OW 332
// dialog_MeetVsevolodVS ;
4598: CALL 21329 0 0
// CenterOnUnits ( [ RuDepot , RuLab , RuOil ] ) ;
4602: LD_EXP 31
4606: PUSH
4607: LD_EXP 32
4611: PUSH
4612: LD_EXP 33
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: LIST
4621: PPUSH
4622: CALL_OW 85
// Wait ( 0 0$2 ) ;
4626: LD_INT 70
4628: PPUSH
4629: CALL_OW 67
// CenterOnUnits ( Burlak ) ;
4633: LD_EXP 10
4637: PPUSH
4638: CALL_OW 85
// ComMoveToArea ( Vsevolod , Mina ) ;
4642: LD_EXP 11
4646: PPUSH
4647: LD_INT 17
4649: PPUSH
4650: CALL_OW 113
// ComWait ( WithVsevolod , 0 0$5 ) ;
4654: LD_EXP 23
4658: PPUSH
4659: LD_INT 175
4661: PPUSH
4662: CALL_OW 142
// AddComMoveToArea ( WithVsevolod , Mina ) ;
4666: LD_EXP 23
4670: PPUSH
4671: LD_INT 17
4673: PPUSH
4674: CALL_OW 173
// AddComMoveToArea ( Vsevolod , RuDepotFog ) ;
4678: LD_EXP 11
4682: PPUSH
4683: LD_INT 15
4685: PPUSH
4686: CALL_OW 173
// AddComMoveToArea ( WithVsevolod , RuDepotFog ) ;
4690: LD_EXP 23
4694: PPUSH
4695: LD_INT 15
4697: PPUSH
4698: CALL_OW 173
// Counter = 0 ;
4702: LD_ADDR_VAR 0 3
4706: PUSH
4707: LD_INT 0
4709: ST_TO_ADDR
// while not IsInArea ( Vsevolod , Mina ) do
4710: LD_EXP 11
4714: PPUSH
4715: LD_INT 17
4717: PPUSH
4718: CALL_OW 308
4722: NOT
4723: IFFALSE 4771
// begin Wait ( 0 0$0.5 ) ;
4725: LD_INT 18
4727: PPUSH
4728: CALL_OW 67
// Counter = Counter + 1 ;
4732: LD_ADDR_VAR 0 3
4736: PUSH
4737: LD_VAR 0 3
4741: PUSH
4742: LD_INT 1
4744: PLUS
4745: ST_TO_ADDR
// if Counter mod 10 = 0 then
4746: LD_VAR 0 3
4750: PUSH
4751: LD_INT 10
4753: MOD
4754: PUSH
4755: LD_INT 0
4757: EQUAL
4758: IFFALSE 4769
// CenterOnUnits ( Vsevolod ) ;
4760: LD_EXP 11
4764: PPUSH
4765: CALL_OW 85
// end ;
4769: GO 4710
// CenterOnUnits ( Vsevolod ) ;
4771: LD_EXP 11
4775: PPUSH
4776: CALL_OW 85
// Wait ( 0 0$1 ) ;
4780: LD_INT 35
4782: PPUSH
4783: CALL_OW 67
// ComHold ( Vsevolod ) ;
4787: LD_EXP 11
4791: PPUSH
4792: CALL_OW 140
// X = GetX ( Vsevolod ) ;
4796: LD_ADDR_VAR 0 4
4800: PUSH
4801: LD_EXP 11
4805: PPUSH
4806: CALL_OW 250
4810: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4811: LD_ADDR_VAR 0 5
4815: PUSH
4816: LD_EXP 11
4820: PPUSH
4821: CALL_OW 251
4825: ST_TO_ADDR
// MineExplosion ( X , Y , false ) ;
4826: LD_VAR 0 4
4830: PPUSH
4831: LD_VAR 0 5
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 453
// SetLives ( [ RuLab , RuOil ] , 25 ) ;
4843: LD_EXP 32
4847: PUSH
4848: LD_EXP 33
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PPUSH
4857: LD_INT 25
4859: PPUSH
4860: CALL_OW 234
// MineExplosion ( GetX ( RuLab ) , GetY ( RuLab ) , true ) ;
4864: LD_EXP 32
4868: PPUSH
4869: CALL_OW 250
4873: PPUSH
4874: LD_EXP 32
4878: PPUSH
4879: CALL_OW 251
4883: PPUSH
4884: LD_INT 1
4886: PPUSH
4887: CALL_OW 453
// MineExplosion ( GetX ( RuOil ) , GetY ( RuOil ) , true ) ;
4891: LD_EXP 33
4895: PPUSH
4896: CALL_OW 250
4900: PPUSH
4901: LD_EXP 33
4905: PPUSH
4906: CALL_OW 251
4910: PPUSH
4911: LD_INT 1
4913: PPUSH
4914: CALL_OW 453
// Wait ( 0 0$0.5 ) ;
4918: LD_INT 18
4920: PPUSH
4921: CALL_OW 67
// SetLives ( Vsevolod , HRANICE_UMIRANI ) ;
4925: LD_EXP 11
4929: PPUSH
4930: LD_INT 250
4932: PPUSH
4933: CALL_OW 234
// KdoSlaplNaMinu = [ Vsevolod ] ;
4937: LD_ADDR_LOC 4
4941: PUSH
4942: LD_EXP 11
4946: PUSH
4947: EMPTY
4948: LIST
4949: ST_TO_ADDR
// for I in FilterAllUnits ( [ [ F_PLACED ] ] ) do
4950: LD_ADDR_VAR 0 2
4954: PUSH
4955: LD_INT 52
4957: PUSH
4958: EMPTY
4959: LIST
4960: PUSH
4961: EMPTY
4962: LIST
4963: PPUSH
4964: CALL_OW 69
4968: PUSH
4969: FOR_IN
4970: IFFALSE 5052
// begin if I = Vsevolod then
4972: LD_VAR 0 2
4976: PUSH
4977: LD_EXP 11
4981: EQUAL
4982: IFFALSE 4986
// continue ;
4984: GO 4969
// if IsInUnit ( I ) then
4986: LD_VAR 0 2
4990: PPUSH
4991: CALL_OW 310
4995: IFFALSE 4999
// continue ;
4997: GO 4969
// if GetDistUnits ( Vsevolod , I ) <= 3 then
4999: LD_EXP 11
5003: PPUSH
5004: LD_VAR 0 2
5008: PPUSH
5009: CALL_OW 296
5013: PUSH
5014: LD_INT 3
5016: LESSEQUAL
5017: IFFALSE 5050
// begin SetLives ( I , HRANICE_UMIRANI ) ;
5019: LD_VAR 0 2
5023: PPUSH
5024: LD_INT 250
5026: PPUSH
5027: CALL_OW 234
// KdoSlaplNaMinu = KdoSlaplNaMinu union [ I ] ;
5031: LD_ADDR_LOC 4
5035: PUSH
5036: LD_LOC 4
5040: PUSH
5041: LD_VAR 0 2
5045: PUSH
5046: EMPTY
5047: LIST
5048: UNION
5049: ST_TO_ADDR
// end ; end ;
5050: GO 4969
5052: POP
5053: POP
// ComCancel ( WithVsevolod ) ;
5054: LD_EXP 23
5058: PPUSH
5059: CALL_OW 127
// ComHold ( WithVsevolod ) ;
5063: LD_EXP 23
5067: PPUSH
5068: CALL_OW 140
// dialog_StasisVS ;
5072: CALL 21385 0 0
// Wait ( 0 0$2 ) ;
5076: LD_INT 70
5078: PPUSH
5079: CALL_OW 67
// ChangeMissionObjectives ( MVsevolod ) ;
5083: LD_STRING MVsevolod
5085: PPUSH
5086: CALL_OW 337
// enable ( 1 ) ;
5090: LD_INT 1
5092: ENABLE_MARKED
// enable ( 2 ) ;
5093: LD_INT 2
5095: ENABLE_MARKED
// SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5096: LD_LOC 4
5100: PPUSH
5101: LD_INT 250
5103: PPUSH
5104: CALL_OW 234
// SetSide ( Vsevolod , side_Ru ) ;
5108: LD_EXP 11
5112: PPUSH
5113: LD_EXP 2
5117: PPUSH
5118: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
5122: LD_EXP 23
5126: PPUSH
5127: LD_EXP 2
5131: PPUSH
5132: CALL_OW 235
// ComFree ( [ Burlak , Vsevolod ] ) ;
5136: LD_EXP 10
5140: PUSH
5141: LD_EXP 11
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PPUSH
5150: CALL_OW 139
// SaveForQuickRestart ;
5154: CALL_OW 22
// InGameOff ;
5158: CALL_OW 9
// enable ( 5 ) ;
5162: LD_INT 5
5164: ENABLE_MARKED
// end ;
5165: LD_VAR 0 1
5169: RET
// every 0 0$5 marked 5 do var Kolik , I ;
5170: GO 5172
5172: DISABLE
5173: LD_INT 0
5175: PPUSH
5176: PPUSH
// begin if Difficulty = 1 then
5177: LD_OWVAR 67
5181: PUSH
5182: LD_INT 1
5184: EQUAL
5185: IFFALSE 5197
// Kolik = 20 else
5187: LD_ADDR_VAR 0 1
5191: PUSH
5192: LD_INT 20
5194: ST_TO_ADDR
5195: GO 5219
// if Difficulty = 2 then
5197: LD_OWVAR 67
5201: PUSH
5202: LD_INT 2
5204: EQUAL
5205: IFFALSE 5217
// Kolik = 10 else
5207: LD_ADDR_VAR 0 1
5211: PUSH
5212: LD_INT 10
5214: ST_TO_ADDR
5215: GO 5219
// exit ;
5217: GO 5260
// for I = 1 to Kolik do
5219: LD_ADDR_VAR 0 2
5223: PUSH
5224: DOUBLE
5225: LD_INT 1
5227: DEC
5228: ST_TO_ADDR
5229: LD_VAR 0 1
5233: PUSH
5234: FOR_TO
5235: IFFALSE 5258
// begin SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5237: LD_LOC 4
5241: PPUSH
5242: LD_INT 250
5244: PPUSH
5245: CALL_OW 234
// Wait ( 0 0$1 ) ;
5249: LD_INT 35
5251: PPUSH
5252: CALL_OW 67
// end ;
5256: GO 5234
5258: POP
5259: POP
// end ;
5260: PPOPN 2
5262: END
// function vytvor_nakladaky ; var N1 , N2 ; begin
5263: LD_INT 0
5265: PPUSH
5266: PPUSH
5267: PPUSH
// UC_side = side_Ru ;
5268: LD_ADDR_OWVAR 20
5272: PUSH
5273: LD_EXP 2
5277: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
5278: LD_ADDR_OWVAR 21
5282: PUSH
5283: LD_INT 3
5285: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
5286: LD_ADDR_OWVAR 37
5290: PUSH
5291: LD_INT 21
5293: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
5294: LD_ADDR_OWVAR 38
5298: PUSH
5299: LD_INT 1
5301: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
5302: LD_ADDR_OWVAR 39
5306: PUSH
5307: LD_INT 1
5309: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
5310: LD_ADDR_OWVAR 40
5314: PUSH
5315: LD_INT 51
5317: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 75 , 100 ) ;
5318: LD_ADDR_OWVAR 41
5322: PUSH
5323: LD_INT 75
5325: PPUSH
5326: LD_INT 100
5328: PPUSH
5329: CALL_OW 12
5333: ST_TO_ADDR
// N1 = CreateVehicle ;
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: CALL_OW 45
5343: ST_TO_ADDR
// N2 = CreateVehicle ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// SetCargo ( N1 , MAT_CANS , 100 ) ;
5354: LD_VAR 0 2
5358: PPUSH
5359: LD_INT 1
5361: PPUSH
5362: LD_INT 100
5364: PPUSH
5365: CALL_OW 290
// SetCargo ( N2 , MAT_SIBERIT , 100 ) ;
5369: LD_VAR 0 3
5373: PPUSH
5374: LD_INT 3
5376: PPUSH
5377: LD_INT 100
5379: PPUSH
5380: CALL_OW 290
// Result = [ N1 , N2 ] ;
5384: LD_ADDR_VAR 0 1
5388: PUSH
5389: LD_VAR 0 2
5393: PUSH
5394: LD_VAR 0 3
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: ST_TO_ADDR
// end ;
5403: LD_VAR 0 1
5407: RET
// function zjisti_ridice ( Seznam , Pocet ) ; var I , Ted ; begin
5408: LD_INT 0
5410: PPUSH
5411: PPUSH
5412: PPUSH
// Result = [ ] ;
5413: LD_ADDR_VAR 0 3
5417: PUSH
5418: EMPTY
5419: ST_TO_ADDR
// while ( Result < Pocet ) and Seznam do
5420: LD_VAR 0 3
5424: PUSH
5425: LD_VAR 0 2
5429: LESS
5430: PUSH
5431: LD_VAR 0 1
5435: AND
5436: IFFALSE 5497
// begin Ted = Seznam [ 1 ] ;
5438: LD_ADDR_VAR 0 5
5442: PUSH
5443: LD_VAR 0 1
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: ST_TO_ADDR
// Seznam = Delete ( Seznam , 1 ) ;
5452: LD_ADDR_VAR 0 1
5456: PUSH
5457: LD_VAR 0 1
5461: PPUSH
5462: LD_INT 1
5464: PPUSH
5465: CALL_OW 3
5469: ST_TO_ADDR
// if Ted then
5470: LD_VAR 0 5
5474: IFFALSE 5495
// Result = Result union [ Ted ] ;
5476: LD_ADDR_VAR 0 3
5480: PUSH
5481: LD_VAR 0 3
5485: PUSH
5486: LD_VAR 0 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: UNION
5494: ST_TO_ADDR
// end ;
5495: GO 5420
// end ;
5497: LD_VAR 0 3
5501: RET
// function uvod_sam ; var I , Seznam , Ridici ; begin
5502: LD_INT 0
5504: PPUSH
5505: PPUSH
5506: PPUSH
5507: PPUSH
// SetSide ( Rusaci , side_Ru ) ;
5508: LD_EXP 22
5512: PPUSH
5513: LD_EXP 2
5517: PPUSH
5518: CALL_OW 235
// SetSide ( Yelena , side_Ru ) ;
5522: LD_EXP 13
5526: PPUSH
5527: LD_EXP 2
5531: PPUSH
5532: CALL_OW 235
// while Rusaci <= 7 do
5536: LD_EXP 22
5540: PUSH
5541: LD_INT 7
5543: LESSEQUAL
5544: IFFALSE 5567
// Rusaci = Rusaci union [ vytvor_rusaka ] ;
5546: LD_ADDR_EXP 22
5550: PUSH
5551: LD_EXP 22
5555: PUSH
5556: CALL 4013 0 0
5560: PUSH
5561: EMPTY
5562: LIST
5563: UNION
5564: ST_TO_ADDR
5565: GO 5536
// Rusaci = Rusaci union [ Yelena ] ;
5567: LD_ADDR_EXP 22
5571: PUSH
5572: LD_EXP 22
5576: PUSH
5577: LD_EXP 13
5581: PUSH
5582: EMPTY
5583: LIST
5584: UNION
5585: ST_TO_ADDR
// SetTech ( TECH_SIBDET , side_Ru , STATE_RESEARCHED ) ;
5586: LD_INT 20
5588: PPUSH
5589: LD_EXP 2
5593: PPUSH
5594: LD_INT 2
5596: PPUSH
5597: CALL_OW 322
// Seznam = UnitFilter ( Rusaci union [ Burlak ] , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
5601: LD_ADDR_VAR 0 3
5605: PUSH
5606: LD_EXP 22
5610: PUSH
5611: LD_EXP 10
5615: PUSH
5616: EMPTY
5617: LIST
5618: UNION
5619: PPUSH
5620: LD_INT 22
5622: PUSH
5623: LD_EXP 2
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 21
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 25
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: PPUSH
5657: CALL_OW 72
5661: ST_TO_ADDR
// if not Seznam then
5662: LD_VAR 0 3
5666: NOT
5667: IFFALSE 5681
// SetClass ( Burlak , CLASS_ENGINEER ) ;
5669: LD_EXP 10
5673: PPUSH
5674: LD_INT 2
5676: PPUSH
5677: CALL_OW 336
// Seznam = vytvor_nakladaky ;
5681: LD_ADDR_VAR 0 3
5685: PUSH
5686: CALL 5263 0 0
5690: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , 2 ) ;
5691: LD_ADDR_VAR 0 4
5695: PUSH
5696: LD_EXP 22
5700: PPUSH
5701: LD_INT 2
5703: PPUSH
5704: CALL 5408 0 2
5708: ST_TO_ADDR
// if Ridici >= 1 then
5709: LD_VAR 0 4
5713: PUSH
5714: LD_INT 1
5716: GREATEREQUAL
5717: IFFALSE 5741
// PlaceHumanInUnit ( Ridici [ 1 ] , Seznam [ 1 ] ) ;
5719: LD_VAR 0 4
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: LD_VAR 0 3
5732: PUSH
5733: LD_INT 1
5735: ARRAY
5736: PPUSH
5737: CALL_OW 52
// if Ridici >= 2 then
5741: LD_VAR 0 4
5745: PUSH
5746: LD_INT 2
5748: GREATEREQUAL
5749: IFFALSE 5773
// PlaceHumanInUnit ( Ridici [ 2 ] , Seznam [ 2 ] ) ;
5751: LD_VAR 0 4
5755: PUSH
5756: LD_INT 2
5758: ARRAY
5759: PPUSH
5760: LD_VAR 0 3
5764: PUSH
5765: LD_INT 2
5767: ARRAY
5768: PPUSH
5769: CALL_OW 52
// PlaceUnitArea ( Burlak , Start1a , false ) ;
5773: LD_EXP 10
5777: PPUSH
5778: LD_INT 13
5780: PPUSH
5781: LD_INT 0
5783: PPUSH
5784: CALL_OW 49
// Place_list ( Seznam , Start1a ) ;
5788: LD_VAR 0 3
5792: PPUSH
5793: LD_INT 13
5795: PPUSH
5796: CALL 20594 0 2
// place_list ( Rusaci diff Ridici , Start1a ) ;
5800: LD_EXP 22
5804: PUSH
5805: LD_VAR 0 4
5809: DIFF
5810: PPUSH
5811: LD_INT 13
5813: PPUSH
5814: CALL 20594 0 2
// for I = 1 to Rand ( 2 , 4 ) do
5818: LD_ADDR_VAR 0 2
5822: PUSH
5823: DOUBLE
5824: LD_INT 1
5826: DEC
5827: ST_TO_ADDR
5828: LD_INT 2
5830: PPUSH
5831: LD_INT 4
5833: PPUSH
5834: CALL_OW 12
5838: PUSH
5839: FOR_TO
5840: IFFALSE 5865
// CreateCratesArea ( Rand ( 1 , 5 ) , BednyRusoveV , false ) ;
5842: LD_INT 1
5844: PPUSH
5845: LD_INT 5
5847: PPUSH
5848: CALL_OW 12
5852: PPUSH
5853: LD_INT 29
5855: PPUSH
5856: LD_INT 0
5858: PPUSH
5859: CALL_OW 55
5863: GO 5839
5865: POP
5866: POP
// InGameOn ;
5867: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
5871: LD_EXP 10
5875: PPUSH
5876: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
5880: LD_EXP 10
5884: PUSH
5885: EMPTY
5886: LIST
5887: PPUSH
5888: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
5892: LD_EXP 10
5896: PUSH
5897: EMPTY
5898: LIST
5899: PPUSH
5900: CALL_OW 85
// dialog_Start ;
5904: CALL 21237 0 0
// dialog_StartNV ;
5908: CALL 21277 0 0
// dialog_Start2 ;
5912: CALL 21297 0 0
// ChangeMissionObjectives ( MStart ) ;
5916: LD_STRING MStart
5918: PPUSH
5919: CALL_OW 337
// enable ( 4 ) ;
5923: LD_INT 4
5925: ENABLE_MARKED
// AddComFree ( Burlak ) ;
5926: LD_EXP 10
5930: PPUSH
5931: CALL_OW 199
// SaveForQuickRestart ;
5935: CALL_OW 22
// InGameOff ;
5939: CALL_OW 9
// arabi_muzete_utocit ;
5943: CALL 10426 0 0
// end ;
5947: LD_VAR 0 1
5951: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
5952: LD_INT 0
5954: PPUSH
// if Un = Burlak then
5955: LD_VAR 0 1
5959: PUSH
5960: LD_EXP 10
5964: EQUAL
5965: IFFALSE 5976
// begin YouLost ( Burlak ) ;
5967: LD_STRING Burlak
5969: PPUSH
5970: CALL_OW 104
// exit ;
5974: GO 5997
// end ; if Un = Vsevolod then
5976: LD_VAR 0 1
5980: PUSH
5981: LD_EXP 11
5985: EQUAL
5986: IFFALSE 5997
// begin YouLost ( Sevi ) ;
5988: LD_STRING Sevi
5990: PPUSH
5991: CALL_OW 104
// exit ;
5995: GO 5997
// end ; end ;
5997: LD_VAR 0 2
6001: RET
// function mozny_prichod_yashina ; begin
6002: LD_INT 0
6004: PPUSH
// if not YashinZacal then
6005: LD_LOC 3
6009: NOT
6010: IFFALSE 6024
// begin YashinZacal = true ;
6012: LD_ADDR_LOC 3
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// yashin_start_timer ;
6020: CALL 13137 0 0
// end ; end ;
6024: LD_VAR 0 1
6028: RET
// export function rusove_BuildingComplete ( Un ) ; begin
6029: LD_INT 0
6031: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and ( GetBType ( Un ) in [ B_WORKSHOP , B_FACTORY ] ) then
6032: LD_VAR 0 1
6036: PPUSH
6037: CALL_OW 255
6041: PUSH
6042: LD_EXP 2
6046: EQUAL
6047: PUSH
6048: LD_VAR 0 1
6052: PPUSH
6053: CALL_OW 266
6057: PUSH
6058: LD_INT 2
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: IN
6068: AND
6069: IFFALSE 6075
// begin mozny_prichod_yashina ;
6071: CALL 6002 0 0
// end ; end ;
6075: LD_VAR 0 2
6079: RET
// every 25 25$0 do
6080: GO 6082
6082: DISABLE
// begin mozny_prichod_yashina ;
6083: CALL 6002 0 0
// end ;
6087: END
// every 0 0$3 + 0 0$1.2 marked 2 do
6088: GO 6090
6090: DISABLE
// begin if not IsOK ( Vsevolod ) then
6091: LD_EXP 11
6095: PPUSH
6096: CALL_OW 302
6100: NOT
6101: IFFALSE 6106
// enable else
6103: ENABLE
6104: GO 6153
// begin DialogueOn ;
6106: CALL_OW 6
// dialog_SeviSaved ;
6110: CALL 21551 0 0
// SetSide ( Vsevolod , side_Ru ) ;
6114: LD_EXP 11
6118: PPUSH
6119: LD_EXP 2
6123: PPUSH
6124: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
6128: LD_EXP 23
6132: PPUSH
6133: LD_EXP 2
6137: PPUSH
6138: CALL_OW 235
// DialogueOff ;
6142: CALL_OW 7
// enable ( 3 ) ;
6146: LD_INT 3
6148: ENABLE_MARKED
// arabi_muzete_utocit ;
6149: CALL 10426 0 0
// end ; end ;
6153: END
// export function rusove_Contact ( Side1 , Side2 ) ; begin
6154: LD_INT 0
6156: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Ar ) ) or ( ( Side1 = side_Ar ) and ( Side2 = side_Ru ) ) then
6157: LD_VAR 0 1
6161: PUSH
6162: LD_EXP 2
6166: EQUAL
6167: PUSH
6168: LD_VAR 0 2
6172: PUSH
6173: LD_EXP 4
6177: EQUAL
6178: AND
6179: PUSH
6180: LD_VAR 0 1
6184: PUSH
6185: LD_EXP 4
6189: EQUAL
6190: PUSH
6191: LD_VAR 0 2
6195: PUSH
6196: LD_EXP 2
6200: EQUAL
6201: AND
6202: OR
6203: IFFALSE 6213
// VidelAraby = true ;
6205: LD_ADDR_LOC 2
6209: PUSH
6210: LD_INT 1
6212: ST_TO_ADDR
// end ;
6213: LD_VAR 0 3
6217: RET
// every 5 5$0 do
6218: GO 6220
6220: DISABLE
// begin ContactIn5Min = VidelAraby ;
6221: LD_ADDR_EXP 28
6225: PUSH
6226: LD_LOC 2
6230: ST_TO_ADDR
// end ;
6231: END
// every 30 30$0 do
6232: GO 6234
6234: DISABLE
// begin if Difficulty = 1 then
6235: LD_OWVAR 67
6239: PUSH
6240: LD_INT 1
6242: EQUAL
6243: IFFALSE 6254
// wait ( 15 15$0 ) else
6245: LD_INT 31500
6247: PPUSH
6248: CALL_OW 67
6252: GO 6271
// if Difficulty = 2 then
6254: LD_OWVAR 67
6258: PUSH
6259: LD_INT 2
6261: EQUAL
6262: IFFALSE 6271
// Wait ( 5 5$0 ) ;
6264: LD_INT 10500
6266: PPUSH
6267: CALL_OW 67
// PropaslQuickly = true ;
6271: LD_ADDR_EXP 29
6275: PUSH
6276: LD_INT 1
6278: ST_TO_ADDR
// end ;
6279: END
// every 2 2$35 marked 3 do
6280: GO 6282
6282: DISABLE
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
6283: LD_INT 35
6285: PPUSH
6286: LD_INT 1050
6288: PPUSH
6289: CALL_OW 12
6293: PPUSH
6294: CALL_OW 67
// xavier_start ;
6298: CALL 15141 0 0
// end ;
6302: END
// every 4 4$45 marked 4 do
6303: GO 6305
6305: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
6306: LD_INT 35
6308: PPUSH
6309: LD_INT 2100
6311: PPUSH
6312: CALL_OW 12
6316: PPUSH
6317: CALL_OW 67
// xavier_start ;
6321: CALL 15141 0 0
// end ; end_of_file
6325: END
// var Zniceno ; var Autaky ; var Obranci ; var VolnyLidi ; var Utok_Auta ; var Utok_ZbyvaMinut ; var CasyUtoku ; var VidelRusa ; var PstZbrane ; var ProbihaUtok ; var CisloUtoku ; var Patrola ; var PatrolaZrusena ; var Registry ; var RegUtok ; var MakroObrana ; var MakroUtok ; var MakroBunkry ; var MakroPresunZakladna ; var BeziStahovani ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var Miny ; var ProbihaOprava ; var ProbihaLeceni ; export function init_arabi ; var Kdo , Budovy ; begin
6326: LD_INT 0
6328: PPUSH
6329: PPUSH
6330: PPUSH
// disable ( 43 ) ;
6331: LD_INT 43
6333: DISABLE_MARKED
// disable ( 44 ) ;
6334: LD_INT 44
6336: DISABLE_MARKED
// disable ( 45 ) ;
6337: LD_INT 45
6339: DISABLE_MARKED
// disable ( 46 ) ;
6340: LD_INT 46
6342: DISABLE_MARKED
// disable ( 47 ) ;
6343: LD_INT 47
6345: DISABLE_MARKED
// SetBName ( ArDepot , newkabul ) ;
6346: LD_INT 3
6348: PPUSH
6349: LD_STRING newkabul
6351: PPUSH
6352: CALL_OW 500
// Autaky = [ ArTank1 , ArTank2 ] ;
6356: LD_ADDR_LOC 6
6360: PUSH
6361: LD_INT 12
6363: PUSH
6364: LD_INT 13
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: ST_TO_ADDR
// Patrola = [ ArTank1 ] ;
6371: LD_ADDR_LOC 16
6375: PUSH
6376: LD_INT 12
6378: PUSH
6379: EMPTY
6380: LIST
6381: ST_TO_ADDR
// Obranci = vytvor_obrance ;
6382: LD_ADDR_LOC 7
6386: PUSH
6387: CALL 7250 0 0
6391: ST_TO_ADDR
// place_list ( Obranci , AraboveParkoviste ) ;
6392: LD_LOC 7
6396: PPUSH
6397: LD_INT 18
6399: PPUSH
6400: CALL 20594 0 2
// Obranci = Obranci union [ ArSolBunk1 , ArSolBunk4 , ArSolBunk6 ] ;
6404: LD_ADDR_LOC 7
6408: PUSH
6409: LD_LOC 7
6413: PUSH
6414: LD_INT 39
6416: PUSH
6417: LD_INT 28
6419: PUSH
6420: LD_INT 31
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: LIST
6427: UNION
6428: ST_TO_ADDR
// VolnyLidi = vytvor_volny ;
6429: LD_ADDR_LOC 8
6433: PUSH
6434: CALL 7316 0 0
6438: ST_TO_ADDR
// place_list ( VolnyLidi , AraboveVolni ) ;
6439: LD_LOC 8
6443: PPUSH
6444: LD_INT 36
6446: PPUSH
6447: CALL 20594 0 2
// VolnyLidi = VolnyLidi union [ ArMech1 , ArMech2 ] ;
6451: LD_ADDR_LOC 8
6455: PUSH
6456: LD_LOC 8
6460: PUSH
6461: LD_INT 19
6463: PUSH
6464: LD_INT 20
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: UNION
6471: ST_TO_ADDR
// Utok_Auta = [ ] ;
6472: LD_ADDR_LOC 9
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// ArDalkar = 0 ;
6479: LD_ADDR_LOC 25
6483: PUSH
6484: LD_INT 0
6486: ST_TO_ADDR
// KolikDalkovych = 0 ;
6487: LD_ADDR_LOC 26
6491: PUSH
6492: LD_INT 0
6494: ST_TO_ADDR
// DelamDalkare = false ;
6495: LD_ADDR_LOC 27
6499: PUSH
6500: LD_INT 0
6502: ST_TO_ADDR
// Zniceno = false ;
6503: LD_ADDR_LOC 5
6507: PUSH
6508: LD_INT 0
6510: ST_TO_ADDR
// VidelRusa = false ;
6511: LD_ADDR_LOC 12
6515: PUSH
6516: LD_INT 0
6518: ST_TO_ADDR
// ProbihaUtok = false ;
6519: LD_ADDR_LOC 14
6523: PUSH
6524: LD_INT 0
6526: ST_TO_ADDR
// PatrolaZrusena = false ;
6527: LD_ADDR_LOC 17
6531: PUSH
6532: LD_INT 0
6534: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
6535: LD_ADDR_LOC 11
6539: PUSH
6540: LD_EXP 52
6544: PUSH
6545: LD_OWVAR 67
6549: ARRAY
6550: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
6551: LD_ADDR_LOC 13
6555: PUSH
6556: LD_EXP 51
6560: PUSH
6561: LD_OWVAR 67
6565: ARRAY
6566: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
6567: LD_ADDR_LOC 10
6571: PUSH
6572: LD_INT 1
6574: NEG
6575: ST_TO_ADDR
// CisloUtoku = 1 ;
6576: LD_ADDR_LOC 15
6580: PUSH
6581: LD_INT 1
6583: ST_TO_ADDR
// BeziStahovani = false ;
6584: LD_ADDR_LOC 24
6588: PUSH
6589: LD_INT 0
6591: ST_TO_ADDR
// ProbihaOprava = false ;
6592: LD_ADDR_LOC 29
6596: PUSH
6597: LD_INT 0
6599: ST_TO_ADDR
// ProbihaLeceni = false ;
6600: LD_ADDR_LOC 30
6604: PUSH
6605: LD_INT 0
6607: ST_TO_ADDR
// if Difficulty = 1 then
6608: LD_OWVAR 67
6612: PUSH
6613: LD_INT 1
6615: EQUAL
6616: IFFALSE 6646
// begin DestroyUnit ( ArObr2 ) ;
6618: LD_INT 46
6620: PPUSH
6621: CALL_OW 65
// DestroyUnit ( ArObrM1 ) ;
6625: LD_INT 47
6627: PPUSH
6628: CALL_OW 65
// DestroyUnit ( ArObr1 ) ;
6632: LD_INT 45
6634: PPUSH
6635: CALL_OW 65
// DestroyUnit ( ArObrM2 ) ;
6639: LD_INT 48
6641: PPUSH
6642: CALL_OW 65
// end ; lidi_do_budov ;
6646: CALL 7415 0 0
// Kdo = Obranci union [ ArMech1 , ArMech2 , ArTank1 , ArTank2 ] union [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_LOC 7
6659: PUSH
6660: LD_INT 19
6662: PUSH
6663: LD_INT 20
6665: PUSH
6666: LD_INT 12
6668: PUSH
6669: LD_INT 13
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: UNION
6678: PUSH
6679: LD_INT 15
6681: PUSH
6682: LD_INT 25
6684: PUSH
6685: LD_INT 33
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: LIST
6692: UNION
6693: ST_TO_ADDR
// if Difficulty > 1 then
6694: LD_OWVAR 67
6698: PUSH
6699: LD_INT 1
6701: GREATER
6702: IFFALSE 6733
// Kdo = Kdo union [ ArObr1 , ArObr2 , ArObrM1 , ArObrM2 ] ;
6704: LD_ADDR_VAR 0 2
6708: PUSH
6709: LD_VAR 0 2
6713: PUSH
6714: LD_INT 45
6716: PUSH
6717: LD_INT 46
6719: PUSH
6720: LD_INT 47
6722: PUSH
6723: LD_INT 48
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: UNION
6732: ST_TO_ADDR
// Kdo = Kdo diff [ Obranci [ 1 ] , Obranci [ 2 ] ] ;
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 2
6742: PUSH
6743: LD_LOC 7
6747: PUSH
6748: LD_INT 1
6750: ARRAY
6751: PUSH
6752: LD_LOC 7
6756: PUSH
6757: LD_INT 2
6759: ARRAY
6760: PUSH
6761: EMPTY
6762: LIST
6763: LIST
6764: DIFF
6765: ST_TO_ADDR
// Registry = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , Obrana ] ] ) ;
6766: LD_ADDR_LOC 18
6770: PUSH
6771: LD_EXP 4
6775: PPUSH
6776: LD_INT 3
6778: PUSH
6779: LD_INT 37
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: PPUSH
6789: CALL_OW 399
6793: ST_TO_ADDR
// MakroBunkry = McCustom ( 20 , [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ) ;
6794: LD_ADDR_LOC 22
6798: PUSH
6799: LD_INT 20
6801: PPUSH
6802: LD_INT 15
6804: PUSH
6805: LD_INT 25
6807: PUSH
6808: LD_INT 33
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 416
6820: ST_TO_ADDR
// MakroObrana = McDefend ( 5 , Registry , Kdo union [ ArBunk1 , ArBunk3 , ArBunk4 , ArBunk5 ] , [ ] ) ;
6821: LD_ADDR_LOC 20
6825: PUSH
6826: LD_INT 5
6828: PPUSH
6829: LD_LOC 18
6833: PPUSH
6834: LD_VAR 0 2
6838: PUSH
6839: LD_INT 36
6841: PUSH
6842: LD_INT 26
6844: PUSH
6845: LD_INT 29
6847: PUSH
6848: LD_INT 40
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: UNION
6857: PPUSH
6858: EMPTY
6859: PPUSH
6860: CALL_OW 401
6864: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Kdo ) ;
6865: LD_ADDR_LOC 23
6869: PUSH
6870: LD_INT 1
6872: PPUSH
6873: LD_VAR 0 2
6877: PPUSH
6878: CALL_OW 416
6882: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , Rusove ] , MC_REG_IGNORE_FOG ] ) ;
6883: LD_ADDR_LOC 19
6887: PUSH
6888: LD_EXP 4
6892: PPUSH
6893: LD_INT 2
6895: PUSH
6896: LD_INT 40
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PUSH
6903: LD_INT 7
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: PPUSH
6910: CALL_OW 399
6914: ST_TO_ADDR
// init_miny ;
6915: CALL 6924 0 0
// end ;
6919: LD_VAR 0 1
6923: RET
// function init_miny ; var M ; begin
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
// if Difficulty = 1 then
6928: LD_OWVAR 67
6932: PUSH
6933: LD_INT 1
6935: EQUAL
6936: IFFALSE 6947
// Miny = [ ] else
6938: LD_ADDR_LOC 28
6942: PUSH
6943: EMPTY
6944: ST_TO_ADDR
6945: GO 7155
// begin Miny = [ [ 62 , 14 ] , [ 64 , 17 ] , [ 66 , 17 ] , [ 65 , 12 ] , [ 68 , 15 ] , [ 64 , 14 ] , [ 60 , 5 ] , [ 60 , 15 ] , [ 59 , 18 ] , [ 56 , 16 ] , [ 49 , 15 ] , [ 33 , 18 ] , [ 42 , 42 ] , [ 112 , 42 ] ] ;
6947: LD_ADDR_LOC 28
6951: PUSH
6952: LD_INT 62
6954: PUSH
6955: LD_INT 14
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: PUSH
6962: LD_INT 64
6964: PUSH
6965: LD_INT 17
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 66
6974: PUSH
6975: LD_INT 17
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: PUSH
6982: LD_INT 65
6984: PUSH
6985: LD_INT 12
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PUSH
6992: LD_INT 68
6994: PUSH
6995: LD_INT 15
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PUSH
7002: LD_INT 64
7004: PUSH
7005: LD_INT 14
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 60
7014: PUSH
7015: LD_INT 5
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PUSH
7022: LD_INT 60
7024: PUSH
7025: LD_INT 15
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PUSH
7032: LD_INT 59
7034: PUSH
7035: LD_INT 18
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PUSH
7042: LD_INT 56
7044: PUSH
7045: LD_INT 16
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 49
7054: PUSH
7055: LD_INT 15
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 33
7064: PUSH
7065: LD_INT 18
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 42
7074: PUSH
7075: LD_INT 42
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 112
7084: PUSH
7085: LD_INT 42
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: LIST
7099: LIST
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: LIST
7105: LIST
7106: LIST
7107: ST_TO_ADDR
// for M in Miny do
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: LD_LOC 28
7117: PUSH
7118: FOR_IN
7119: IFFALSE 7153
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
7121: LD_VAR 0 2
7125: PUSH
7126: LD_INT 1
7128: ARRAY
7129: PPUSH
7130: LD_VAR 0 2
7134: PUSH
7135: LD_INT 2
7137: ARRAY
7138: PPUSH
7139: LD_EXP 4
7143: PPUSH
7144: LD_INT 0
7146: PPUSH
7147: CALL_OW 454
7151: GO 7118
7153: POP
7154: POP
// end ; end ;
7155: LD_VAR 0 1
7159: RET
// function vytvor_cloveka ( Cls ) ; begin
7160: LD_INT 0
7162: PPUSH
// UC_Side = side_Ar ;
7163: LD_ADDR_OWVAR 20
7167: PUSH
7168: LD_EXP 4
7172: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
7173: LD_ADDR_OWVAR 21
7177: PUSH
7178: LD_INT 2
7180: ST_TO_ADDR
// HC_Sex = Rand ( 1 , 2 ) ;
7181: LD_ADDR_OWVAR 27
7185: PUSH
7186: LD_INT 1
7188: PPUSH
7189: LD_INT 2
7191: PPUSH
7192: CALL_OW 12
7196: ST_TO_ADDR
// HC_Class = Cls ;
7197: LD_ADDR_OWVAR 28
7201: PUSH
7202: LD_VAR 0 1
7206: ST_TO_ADDR
// HC_Name =  ;
7207: LD_ADDR_OWVAR 26
7211: PUSH
7212: LD_STRING 
7214: ST_TO_ADDR
// PrepareClassSkills ( Cls , dif_ArabiLevel [ Difficulty ] ) ;
7215: LD_VAR 0 1
7219: PPUSH
7220: LD_EXP 47
7224: PUSH
7225: LD_OWVAR 67
7229: ARRAY
7230: PPUSH
7231: CALL_OW 374
// Result = CreateHuman ;
7235: LD_ADDR_VAR 0 2
7239: PUSH
7240: CALL_OW 44
7244: ST_TO_ADDR
// end ;
7245: LD_VAR 0 2
7249: RET
// function vytvor_obrance ; var I ; begin
7250: LD_INT 0
7252: PPUSH
7253: PPUSH
// Result = [ ] ;
7254: LD_ADDR_VAR 0 1
7258: PUSH
7259: EMPTY
7260: ST_TO_ADDR
// for I = 1 to dif_ObranciArabi [ Difficulty ] do
7261: LD_ADDR_VAR 0 2
7265: PUSH
7266: DOUBLE
7267: LD_INT 1
7269: DEC
7270: ST_TO_ADDR
7271: LD_EXP 49
7275: PUSH
7276: LD_OWVAR 67
7280: ARRAY
7281: PUSH
7282: FOR_TO
7283: IFFALSE 7309
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] ;
7285: LD_ADDR_VAR 0 1
7289: PUSH
7290: LD_VAR 0 1
7294: PUSH
7295: LD_INT 1
7297: PPUSH
7298: CALL 7160 0 1
7302: PUSH
7303: EMPTY
7304: LIST
7305: UNION
7306: ST_TO_ADDR
7307: GO 7282
7309: POP
7310: POP
// end ;
7311: LD_VAR 0 1
7315: RET
// function vytvor_volny ; var I ; begin
7316: LD_INT 0
7318: PPUSH
7319: PPUSH
// Result = [ ] ;
7320: LD_ADDR_VAR 0 1
7324: PUSH
7325: EMPTY
7326: ST_TO_ADDR
// for I = 1 to dif_VolnyArabi [ Difficulty ] do
7327: LD_ADDR_VAR 0 2
7331: PUSH
7332: DOUBLE
7333: LD_INT 1
7335: DEC
7336: ST_TO_ADDR
7337: LD_EXP 48
7341: PUSH
7342: LD_OWVAR 67
7346: ARRAY
7347: PUSH
7348: FOR_TO
7349: IFFALSE 7408
// if Prob ( 25 ) then
7351: LD_INT 25
7353: PPUSH
7354: CALL_OW 13
7358: IFFALSE 7384
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] else
7360: LD_ADDR_VAR 0 1
7364: PUSH
7365: LD_VAR 0 1
7369: PUSH
7370: LD_INT 1
7372: PPUSH
7373: CALL 7160 0 1
7377: PUSH
7378: EMPTY
7379: LIST
7380: UNION
7381: ST_TO_ADDR
7382: GO 7406
// Result = Result union [ vytvor_cloveka ( CLASS_MECHANIC ) ] ;
7384: LD_ADDR_VAR 0 1
7388: PUSH
7389: LD_VAR 0 1
7393: PUSH
7394: LD_INT 3
7396: PPUSH
7397: CALL 7160 0 1
7401: PUSH
7402: EMPTY
7403: LIST
7404: UNION
7405: ST_TO_ADDR
7406: GO 7348
7408: POP
7409: POP
// end ;
7410: LD_VAR 0 1
7414: RET
// function lidi_do_budov ; begin
7415: LD_INT 0
7417: PPUSH
// ComEnterUnit ( ArMech1 , ArTank1 ) ;
7418: LD_INT 19
7420: PPUSH
7421: LD_INT 12
7423: PPUSH
7424: CALL_OW 120
// ComEnterUnit ( ArMech , ArFact ) ;
7428: LD_INT 21
7430: PPUSH
7431: LD_INT 4
7433: PPUSH
7434: CALL_OW 120
// ComEnterUnit ( ArSolPBunk1 , ArPBunk1 ) ;
7438: LD_INT 15
7440: PPUSH
7441: LD_INT 2
7443: PPUSH
7444: CALL_OW 120
// ComEnterUnit ( ArSolPBunk2 , ArPBunk2 ) ;
7448: LD_INT 25
7450: PPUSH
7451: LD_INT 1
7453: PPUSH
7454: CALL_OW 120
// if Difficulty < 3 then
7458: LD_OWVAR 67
7462: PUSH
7463: LD_INT 3
7465: LESS
7466: IFFALSE 7478
// SetClass ( ArSolPBunk3 , CLASS_SOLDIER ) ;
7468: LD_INT 33
7470: PPUSH
7471: LD_INT 1
7473: PPUSH
7474: CALL_OW 336
// if Difficulty > 1 then
7478: LD_OWVAR 67
7482: PUSH
7483: LD_INT 1
7485: GREATER
7486: IFFALSE 7508
// begin ComEnterUnit ( ArObrM1 , ArObr1 ) ;
7488: LD_INT 47
7490: PPUSH
7491: LD_INT 45
7493: PPUSH
7494: CALL_OW 120
// ComEnterUnit ( ArObrM2 , ArObr2 ) ;
7498: LD_INT 48
7500: PPUSH
7501: LD_INT 46
7503: PPUSH
7504: CALL_OW 120
// end ; ComEnterUnit ( ArSolPBunk3 , ArPBunk3 ) ;
7508: LD_INT 33
7510: PPUSH
7511: LD_INT 32
7513: PPUSH
7514: CALL_OW 120
// ComEnterUnit ( ArSolRadar , ArRadar ) ;
7518: LD_INT 38
7520: PPUSH
7521: LD_INT 37
7523: PPUSH
7524: CALL_OW 120
// ComEnterUnit ( ArSolBunk1 , ArBunk1 ) ;
7528: LD_INT 39
7530: PPUSH
7531: LD_INT 36
7533: PPUSH
7534: CALL_OW 120
// ComEnterUnit ( ArSolBunk4 , ArBunk4 ) ;
7538: LD_INT 28
7540: PPUSH
7541: LD_INT 29
7543: PPUSH
7544: CALL_OW 120
// ComEnterUnit ( ArSolBunk6 , ArBunk6 ) ;
7548: LD_INT 31
7550: PPUSH
7551: LD_INT 41
7553: PPUSH
7554: CALL_OW 120
// ComEnterUnit ( ArSci1 , ArLab1 ) ;
7558: LD_INT 17
7560: PPUSH
7561: LD_INT 6
7563: PPUSH
7564: CALL_OW 120
// ComEnterUnit ( ArSci2 , ArLab2 ) ;
7568: LD_INT 18
7570: PPUSH
7571: LD_INT 24
7573: PPUSH
7574: CALL_OW 120
// end ;
7578: LD_VAR 0 1
7582: RET
// function kontrola_zniceno ; var Jednotky ; begin
7583: LD_INT 0
7585: PPUSH
7586: PPUSH
// if not Zniceno then
7587: LD_LOC 5
7591: NOT
7592: IFFALSE 7651
// begin Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] ] ) ;
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: LD_INT 22
7601: PUSH
7602: LD_EXP 4
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 50
7613: PUSH
7614: EMPTY
7615: LIST
7616: PUSH
7617: LD_INT 52
7619: PUSH
7620: EMPTY
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: LIST
7627: PPUSH
7628: CALL_OW 69
7632: ST_TO_ADDR
// if not Jednotky then
7633: LD_VAR 0 2
7637: NOT
7638: IFFALSE 7651
// begin Zniceno = true ;
7640: LD_ADDR_LOC 5
7644: PUSH
7645: LD_INT 1
7647: ST_TO_ADDR
// disable ( 43 ) ;
7648: LD_INT 43
7650: DISABLE_MARKED
// end ; end ; end ;
7651: LD_VAR 0 1
7655: RET
// function vyber_zbran ; var P ; begin
7656: LD_INT 0
7658: PPUSH
7659: PPUSH
// P = Rand ( 1 , 100 ) ;
7660: LD_ADDR_VAR 0 2
7664: PUSH
7665: LD_INT 1
7667: PPUSH
7668: LD_INT 100
7670: PPUSH
7671: CALL_OW 12
7675: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
7676: LD_VAR 0 2
7680: PUSH
7681: LD_LOC 13
7685: PUSH
7686: LD_INT 1
7688: ARRAY
7689: LESS
7690: IFFALSE 7702
// Result = AR_FLAME_THROWER else
7692: LD_ADDR_VAR 0 1
7696: PUSH
7697: LD_INT 26
7699: ST_TO_ADDR
7700: GO 7762
// if P < PstZbrane [ 2 ] then
7702: LD_VAR 0 2
7706: PUSH
7707: LD_LOC 13
7711: PUSH
7712: LD_INT 2
7714: ARRAY
7715: LESS
7716: IFFALSE 7728
// Result = AR_GUN else
7718: LD_ADDR_VAR 0 1
7722: PUSH
7723: LD_INT 27
7725: ST_TO_ADDR
7726: GO 7762
// if P < PstZbrane [ 3 ] then
7728: LD_VAR 0 2
7732: PUSH
7733: LD_LOC 13
7737: PUSH
7738: LD_INT 3
7740: ARRAY
7741: LESS
7742: IFFALSE 7754
// Result = AR_DOUBLE_MACHINE_GUN else
7744: LD_ADDR_VAR 0 1
7748: PUSH
7749: LD_INT 24
7751: ST_TO_ADDR
7752: GO 7762
// Result = AR_ROCKET_LAUNCHER ;
7754: LD_ADDR_VAR 0 1
7758: PUSH
7759: LD_INT 28
7761: ST_TO_ADDR
// end ;
7762: LD_VAR 0 1
7766: RET
// function vyber_ovladani ; begin
7767: LD_INT 0
7769: PPUSH
// Result = CONTROL_MANUAL ;
7770: LD_ADDR_VAR 0 1
7774: PUSH
7775: LD_INT 1
7777: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
7778: LD_LOC 25
7782: NOT
7783: PUSH
7784: LD_LOC 25
7788: PPUSH
7789: CALL_OW 302
7793: NOT
7794: OR
7795: IFFALSE 7799
// exit ;
7797: GO 7847
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
7799: LD_INT 42
7801: NOT
7802: PUSH
7803: LD_INT 42
7805: PPUSH
7806: CALL_OW 302
7810: NOT
7811: OR
7812: IFFALSE 7816
// exit ;
7814: GO 7847
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
7816: LD_INT 42
7818: PPUSH
7819: CALL_OW 432
7823: PUSH
7824: LD_INT 42
7826: PPUSH
7827: LD_INT 3
7829: PPUSH
7830: CALL_OW 259
7834: GREATEREQUAL
7835: IFFALSE 7839
// exit ;
7837: GO 7847
// Result = CONTROL_REMOTE ;
7839: LD_ADDR_VAR 0 1
7843: PUSH
7844: LD_INT 2
7846: ST_TO_ADDR
// end ;
7847: LD_VAR 0 1
7851: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
7852: LD_INT 0
7854: PPUSH
7855: PPUSH
7856: PPUSH
7857: PPUSH
7858: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
7859: LD_INT 4
7861: PPUSH
7862: CALL_OW 302
7866: NOT
7867: PUSH
7868: LD_INT 4
7870: PPUSH
7871: CALL_OW 314
7875: OR
7876: IFFALSE 7880
// exit ;
7878: GO 8192
// if GetSide ( ArFact ) <> side_Ar then
7880: LD_INT 4
7882: PPUSH
7883: CALL_OW 255
7887: PUSH
7888: LD_EXP 4
7892: NONEQUAL
7893: IFFALSE 7897
// exit ;
7895: GO 8192
// if not UnitsInside ( ArFact ) then
7897: LD_INT 4
7899: PPUSH
7900: CALL_OW 313
7904: NOT
7905: IFFALSE 7909
// exit ;
7907: GO 8192
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
7909: LD_INT 15
7911: PPUSH
7912: LD_EXP 4
7916: PPUSH
7917: CALL_OW 321
7921: PUSH
7922: LD_INT 2
7924: EQUAL
7925: PUSH
7926: LD_LOC 25
7930: NOT
7931: AND
7932: PUSH
7933: LD_LOC 27
7937: NOT
7938: AND
7939: PUSH
7940: LD_INT 75
7942: PPUSH
7943: CALL_OW 13
7947: AND
7948: IFFALSE 7976
// begin Chassis = AR_MEDIUM_TRIKE ;
7950: LD_ADDR_VAR 0 3
7954: PUSH
7955: LD_INT 13
7957: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
7958: LD_ADDR_VAR 0 4
7962: PUSH
7963: LD_INT 31
7965: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
7966: LD_ADDR_VAR 0 5
7970: PUSH
7971: LD_INT 1
7973: ST_TO_ADDR
// end else
7974: GO 8023
// begin if Prob ( 50 ) then
7976: LD_INT 50
7978: PPUSH
7979: CALL_OW 13
7983: IFFALSE 7995
// Chassis = AR_MEDIUM_TRIKE else
7985: LD_ADDR_VAR 0 3
7989: PUSH
7990: LD_INT 13
7992: ST_TO_ADDR
7993: GO 8003
// Chassis = AR_HALF_TRACKED ;
7995: LD_ADDR_VAR 0 3
7999: PUSH
8000: LD_INT 14
8002: ST_TO_ADDR
// Weapon = vyber_zbran ;
8003: LD_ADDR_VAR 0 4
8007: PUSH
8008: CALL 7656 0 0
8012: ST_TO_ADDR
// Control = vyber_ovladani ;
8013: LD_ADDR_VAR 0 5
8017: PUSH
8018: CALL 7767 0 0
8022: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) then
8023: LD_INT 4
8025: PPUSH
8026: LD_VAR 0 3
8030: PPUSH
8031: LD_INT 1
8033: PPUSH
8034: LD_VAR 0 5
8038: PPUSH
8039: LD_VAR 0 4
8043: PPUSH
8044: CALL_OW 448
8048: NOT
8049: IFFALSE 8093
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_COMBUSTION , Control , AR_LIGHT_GUN ) then
8051: LD_INT 4
8053: PPUSH
8054: LD_INT 12
8056: PPUSH
8057: LD_INT 1
8059: PPUSH
8060: LD_VAR 0 5
8064: PPUSH
8065: LD_INT 23
8067: PPUSH
8068: CALL_OW 448
8072: NOT
8073: IFFALSE 8077
// exit ;
8075: GO 8192
// Chassis = AR_LIGHT_TRIKE ;
8077: LD_ADDR_VAR 0 3
8081: PUSH
8082: LD_INT 12
8084: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
8085: LD_ADDR_VAR 0 4
8089: PUSH
8090: LD_INT 23
8092: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
8093: LD_ADDR_VAR 0 2
8097: PUSH
8098: LD_INT 4
8100: PPUSH
8101: CALL_OW 274
8105: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
8106: LD_VAR 0 2
8110: PPUSH
8111: LD_INT 1
8113: PPUSH
8114: CALL_OW 275
8118: PUSH
8119: LD_INT 120
8121: LESS
8122: IFFALSE 8126
// exit ;
8124: GO 8192
// if GetResourceType ( Base , MAT_OIL ) < 50 then
8126: LD_VAR 0 2
8130: PPUSH
8131: LD_INT 2
8133: PPUSH
8134: CALL_OW 275
8138: PUSH
8139: LD_INT 50
8141: LESS
8142: IFFALSE 8146
// exit ;
8144: GO 8192
// AddComConstruct ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) ;
8146: LD_INT 4
8148: PPUSH
8149: LD_VAR 0 3
8153: PPUSH
8154: LD_INT 1
8156: PPUSH
8157: LD_VAR 0 5
8161: PPUSH
8162: LD_VAR 0 4
8166: PPUSH
8167: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
8171: LD_VAR 0 4
8175: PUSH
8176: LD_INT 31
8178: EQUAL
8179: IFFALSE 8192
// begin DelamDalkare = true ;
8181: LD_ADDR_LOC 27
8185: PUSH
8186: LD_INT 1
8188: ST_TO_ADDR
// enable ( 47 ) ;
8189: LD_INT 47
8191: ENABLE_MARKED
// end ; end ;
8192: LD_VAR 0 1
8196: RET
// every 5 5$1 marked 47 do
8197: GO 8199
8199: DISABLE
// begin if not ArDalkar then
8200: LD_LOC 25
8204: NOT
8205: IFFALSE 8215
// DelamDalkare = false ;
8207: LD_ADDR_LOC 27
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// end ;
8215: END
// function zacni_vynalezat ; begin
8216: LD_INT 0
8218: PPUSH
// AddComResearch ( ArLab1 , TECH_GUN ) ;
8219: LD_INT 6
8221: PPUSH
8222: LD_INT 39
8224: PPUSH
8225: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_FLAME ) ;
8229: LD_INT 6
8231: PPUSH
8232: LD_INT 70
8234: PPUSH
8235: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_ROCKET ) ;
8239: LD_INT 6
8241: PPUSH
8242: LD_INT 40
8244: PPUSH
8245: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_GATLING ) ;
8249: LD_INT 6
8251: PPUSH
8252: LD_INT 69
8254: PPUSH
8255: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_STIMDRUGS ) ;
8259: LD_INT 6
8261: PPUSH
8262: LD_INT 5
8264: PPUSH
8265: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_EXPLOS ) ;
8269: LD_INT 6
8271: PPUSH
8272: LD_INT 42
8274: PPUSH
8275: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_SELFDEST ) ;
8279: LD_INT 6
8281: PPUSH
8282: LD_INT 43
8284: PPUSH
8285: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP1 ) ;
8289: LD_INT 6
8291: PPUSH
8292: LD_INT 51
8294: PPUSH
8295: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP2 ) ;
8299: LD_INT 6
8301: PPUSH
8302: LD_INT 52
8304: PPUSH
8305: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8309: LD_INT 6
8311: PPUSH
8312: LD_INT 67
8314: PPUSH
8315: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8319: LD_INT 6
8321: PPUSH
8322: LD_INT 67
8324: PPUSH
8325: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_RADAR ) ;
8329: LD_INT 24
8331: PPUSH
8332: LD_INT 6
8334: PPUSH
8335: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_REMCONT ) ;
8339: LD_INT 24
8341: PPUSH
8342: LD_INT 15
8344: PPUSH
8345: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_MATDET ) ;
8349: LD_INT 24
8351: PPUSH
8352: LD_INT 7
8354: PPUSH
8355: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH1 ) ;
8359: LD_INT 24
8361: PPUSH
8362: LD_INT 48
8364: PPUSH
8365: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH2 ) ;
8369: LD_INT 24
8371: PPUSH
8372: LD_INT 49
8374: PPUSH
8375: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_SIBDET ) ;
8379: LD_INT 24
8381: PPUSH
8382: LD_INT 20
8384: PPUSH
8385: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO1 ) ;
8389: LD_INT 24
8391: PPUSH
8392: LD_INT 60
8394: PPUSH
8395: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO2 ) ;
8399: LD_INT 24
8401: PPUSH
8402: LD_INT 61
8404: PPUSH
8405: CALL_OW 184
// end ;
8409: LD_VAR 0 1
8413: RET
// function zacni_utok ; begin
8414: LD_INT 0
8416: PPUSH
// ProbihaUtok = true ;
8417: LD_ADDR_LOC 14
8421: PUSH
8422: LD_INT 1
8424: ST_TO_ADDR
// MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8425: LD_ADDR_LOC 21
8429: PUSH
8430: LD_INT 10
8432: PPUSH
8433: LD_LOC 19
8437: PPUSH
8438: LD_LOC 9
8442: PPUSH
8443: LD_INT 7
8445: PUSH
8446: LD_INT 18
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 8
8455: PUSH
8456: LD_INT 18
8458: PUSH
8459: EMPTY
8460: LIST
8461: LIST
8462: PUSH
8463: LD_INT 5
8465: PUSH
8466: LD_INT 10
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 6
8475: PUSH
8476: LD_INT 10
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: LIST
8487: LIST
8488: PPUSH
8489: CALL_OW 402
8493: ST_TO_ADDR
// end ;
8494: LD_VAR 0 1
8498: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
8499: LD_INT 0
8501: PPUSH
8502: PPUSH
8503: PPUSH
8504: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
8505: LD_ADDR_VAR 0 2
8509: PUSH
8510: LD_EXP 50
8514: PUSH
8515: LD_OWVAR 67
8519: ARRAY
8520: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
8521: LD_ADDR_VAR 0 3
8525: PUSH
8526: LD_INT 1
8528: PPUSH
8529: LD_INT 100
8531: PPUSH
8532: CALL_OW 12
8536: ST_TO_ADDR
// if ( I < 25 ) then
8537: LD_VAR 0 3
8541: PUSH
8542: LD_INT 25
8544: LESS
8545: IFFALSE 8563
// KolikChci = KolikChci - 1 else
8547: LD_ADDR_VAR 0 2
8551: PUSH
8552: LD_VAR 0 2
8556: PUSH
8557: LD_INT 1
8559: MINUS
8560: ST_TO_ADDR
8561: GO 8597
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_INT 75
8570: GREATER
8571: PUSH
8572: LD_LOC 15
8576: PUSH
8577: LD_INT 1
8579: GREATER
8580: AND
8581: IFFALSE 8597
// KolikChci = KolikChci + 1 ;
8583: LD_ADDR_VAR 0 2
8587: PUSH
8588: LD_VAR 0 2
8592: PUSH
8593: LD_INT 1
8595: PLUS
8596: ST_TO_ADDR
// Riditelne = [ ] ;
8597: LD_ADDR_VAR 0 4
8601: PUSH
8602: EMPTY
8603: ST_TO_ADDR
// for I in Autaky diff Patrola do
8604: LD_ADDR_VAR 0 3
8608: PUSH
8609: LD_LOC 6
8613: PUSH
8614: LD_LOC 16
8618: DIFF
8619: PUSH
8620: FOR_IN
8621: IFFALSE 8707
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 263
8632: PUSH
8633: LD_INT 1
8635: EQUAL
8636: PUSH
8637: LD_VAR 0 3
8641: PPUSH
8642: CALL_OW 311
8646: NOT
8647: AND
8648: IFFALSE 8652
// continue ;
8650: GO 8620
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
8652: LD_VAR 0 3
8656: PPUSH
8657: CALL_OW 264
8661: PUSH
8662: LD_INT 31
8664: EQUAL
8665: IFFALSE 8669
// continue ;
8667: GO 8620
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
8669: LD_VAR 0 3
8673: PPUSH
8674: CALL_OW 256
8678: PUSH
8679: LD_INT 1000
8681: LESS
8682: IFFALSE 8686
// continue ;
8684: GO 8620
// Riditelne = Riditelne union [ I ] ;
8686: LD_ADDR_VAR 0 4
8690: PUSH
8691: LD_VAR 0 4
8695: PUSH
8696: LD_VAR 0 3
8700: PUSH
8701: EMPTY
8702: LIST
8703: UNION
8704: ST_TO_ADDR
// end ;
8705: GO 8620
8707: POP
8708: POP
// if Riditelne >= KolikChci then
8709: LD_VAR 0 4
8713: PUSH
8714: LD_VAR 0 2
8718: GREATEREQUAL
8719: IFFALSE 8774
// begin Result = [ ] ;
8721: LD_ADDR_VAR 0 1
8725: PUSH
8726: EMPTY
8727: ST_TO_ADDR
// for I = 1 to KolikChci do
8728: LD_ADDR_VAR 0 3
8732: PUSH
8733: DOUBLE
8734: LD_INT 1
8736: DEC
8737: ST_TO_ADDR
8738: LD_VAR 0 2
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8770
// Result = Result union Riditelne [ I ] ;
8746: LD_ADDR_VAR 0 1
8750: PUSH
8751: LD_VAR 0 1
8755: PUSH
8756: LD_VAR 0 4
8760: PUSH
8761: LD_VAR 0 3
8765: ARRAY
8766: UNION
8767: ST_TO_ADDR
8768: GO 8743
8770: POP
8771: POP
// end else
8772: GO 8781
// Result = [ ] ;
8774: LD_ADDR_VAR 0 1
8778: PUSH
8779: EMPTY
8780: ST_TO_ADDR
// end ;
8781: LD_VAR 0 1
8785: RET
// function vrat_utok ; var I ; begin
8786: LD_INT 0
8788: PPUSH
8789: PPUSH
// ProbihaUtok = false ;
8790: LD_ADDR_LOC 14
8794: PUSH
8795: LD_INT 0
8797: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
8798: LD_ADDR_LOC 15
8802: PUSH
8803: LD_LOC 15
8807: PUSH
8808: LD_INT 1
8810: PLUS
8811: ST_TO_ADDR
// MakroUtok = 0 ;
8812: LD_ADDR_LOC 21
8816: PUSH
8817: LD_INT 0
8819: ST_TO_ADDR
// AddComMoveUnit ( Utok_Auta , ArDepot ) ;
8820: LD_LOC 9
8824: PPUSH
8825: LD_INT 3
8827: PPUSH
8828: CALL_OW 172
// AddComMoveToArea ( Utok_Auta , AraboveParkoviste ) ;
8832: LD_LOC 9
8836: PPUSH
8837: LD_INT 18
8839: PPUSH
8840: CALL_OW 173
// end ;
8844: LD_VAR 0 1
8848: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
8849: LD_INT 0
8851: PPUSH
// vrat_utok ;
8852: CALL 8786 0 0
// end ;
8856: LD_VAR 0 3
8860: RET
// function oprava_utok ; var JsouOK , JsouTam , Auto , Task , Budova ; begin
8861: LD_INT 0
8863: PPUSH
8864: PPUSH
8865: PPUSH
8866: PPUSH
8867: PPUSH
8868: PPUSH
// JsouOK = false ;
8869: LD_ADDR_VAR 0 2
8873: PUSH
8874: LD_INT 0
8876: ST_TO_ADDR
// JsouTam = true ;
8877: LD_ADDR_VAR 0 3
8881: PUSH
8882: LD_INT 1
8884: ST_TO_ADDR
// Task = false ;
8885: LD_ADDR_VAR 0 5
8889: PUSH
8890: LD_INT 0
8892: ST_TO_ADDR
// for Auto in Utok_Auta do
8893: LD_ADDR_VAR 0 4
8897: PUSH
8898: LD_LOC 9
8902: PUSH
8903: FOR_IN
8904: IFFALSE 8969
// begin if IsOK ( Auto ) then
8906: LD_VAR 0 4
8910: PPUSH
8911: CALL_OW 302
8915: IFFALSE 8967
// begin JsouOK = true ;
8917: LD_ADDR_VAR 0 2
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// if not IsInArea ( Auto , ArabskaBaze ) then
8925: LD_VAR 0 4
8929: PPUSH
8930: LD_INT 14
8932: PPUSH
8933: CALL_OW 308
8937: NOT
8938: IFFALSE 8948
// JsouTam = false ;
8940: LD_ADDR_VAR 0 3
8944: PUSH
8945: LD_INT 0
8947: ST_TO_ADDR
// if HasTask ( Auto ) then
8948: LD_VAR 0 4
8952: PPUSH
8953: CALL_OW 314
8957: IFFALSE 8967
// Task = true ;
8959: LD_ADDR_VAR 0 5
8963: PUSH
8964: LD_INT 1
8966: ST_TO_ADDR
// end ; end ;
8967: GO 8903
8969: POP
8970: POP
// if not Utok_Auta or not JsouOK then
8971: LD_LOC 9
8975: NOT
8976: PUSH
8977: LD_VAR 0 2
8981: NOT
8982: OR
8983: IFFALSE 8995
// begin Result = true ;
8985: LD_ADDR_VAR 0 1
8989: PUSH
8990: LD_INT 1
8992: ST_TO_ADDR
// exit ;
8993: GO 9140
// end ; if ( not JsouTam ) or Task then
8995: LD_VAR 0 3
8999: NOT
9000: PUSH
9001: LD_VAR 0 5
9005: OR
9006: IFFALSE 9018
// begin Result = false ;
9008: LD_ADDR_VAR 0 1
9012: PUSH
9013: LD_INT 0
9015: ST_TO_ADDR
// exit ;
9016: GO 9140
// end ; Result = true ;
9018: LD_ADDR_VAR 0 1
9022: PUSH
9023: LD_INT 1
9025: ST_TO_ADDR
// if not IsOK ( ArMech ) then
9026: LD_INT 21
9028: PPUSH
9029: CALL_OW 302
9033: NOT
9034: IFFALSE 9038
// exit ;
9036: GO 9140
// Budova = IsInUnit ( ArMech ) ;
9038: LD_ADDR_VAR 0 6
9042: PUSH
9043: LD_INT 21
9045: PPUSH
9046: CALL_OW 310
9050: ST_TO_ADDR
// if ( Budova <> ArFact ) and ( Budova <> 0 ) then
9051: LD_VAR 0 6
9055: PUSH
9056: LD_INT 4
9058: NONEQUAL
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 0
9067: NONEQUAL
9068: AND
9069: IFFALSE 9073
// exit ;
9071: GO 9140
// ComExitBuilding ( ArMech ) ;
9073: LD_INT 21
9075: PPUSH
9076: CALL_OW 122
// Wait ( 0 0$1.3 ) ;
9080: LD_INT 46
9082: PPUSH
9083: CALL_OW 67
// for Auto in Utok_Auta do
9087: LD_ADDR_VAR 0 4
9091: PUSH
9092: LD_LOC 9
9096: PUSH
9097: FOR_IN
9098: IFFALSE 9128
// begin if IsInArea ( Auto , ArabskaBaze ) then
9100: LD_VAR 0 4
9104: PPUSH
9105: LD_INT 14
9107: PPUSH
9108: CALL_OW 308
9112: IFFALSE 9126
// AddComRepairVehicle ( ArMech , Auto ) ;
9114: LD_INT 21
9116: PPUSH
9117: LD_VAR 0 4
9121: PPUSH
9122: CALL_OW 189
// end ;
9126: GO 9097
9128: POP
9129: POP
// AddComEnterUnit ( ArMech , ArFact ) ;
9130: LD_INT 21
9132: PPUSH
9133: LD_INT 4
9135: PPUSH
9136: CALL_OW 180
// end ;
9140: LD_VAR 0 1
9144: RET
// function zjisti_cas_utoku ; begin
9145: LD_INT 0
9147: PPUSH
// if CasyUtoku then
9148: LD_LOC 11
9152: IFFALSE 9198
// begin Result = CasyUtoku [ 1 ] ;
9154: LD_ADDR_VAR 0 1
9158: PUSH
9159: LD_LOC 11
9163: PUSH
9164: LD_INT 1
9166: ARRAY
9167: ST_TO_ADDR
// if CasyUtoku > 1 then
9168: LD_LOC 11
9172: PUSH
9173: LD_INT 1
9175: GREATER
9176: IFFALSE 9196
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
9178: LD_ADDR_LOC 11
9182: PUSH
9183: LD_LOC 11
9187: PPUSH
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 3
9195: ST_TO_ADDR
// end else
9196: GO 9206
// Result = 5 ;
9198: LD_ADDR_VAR 0 1
9202: PUSH
9203: LD_INT 5
9205: ST_TO_ADDR
// end ;
9206: LD_VAR 0 1
9210: RET
// function utoceni_splneny_predpoklady ; begin
9211: LD_INT 0
9213: PPUSH
// Result = VidelRusa or ( Minuty > 15 ) ;
9214: LD_ADDR_VAR 0 1
9218: PUSH
9219: LD_LOC 12
9223: PUSH
9224: LD_EXP 30
9228: PUSH
9229: LD_INT 15
9231: GREATER
9232: OR
9233: ST_TO_ADDR
// if Prob ( 25 ) then
9234: LD_INT 25
9236: PPUSH
9237: CALL_OW 13
9241: IFFALSE 9251
// Result = false ;
9243: LD_ADDR_VAR 0 1
9247: PUSH
9248: LD_INT 0
9250: ST_TO_ADDR
// end ;
9251: LD_VAR 0 1
9255: RET
// function casovac_utok ; begin
9256: LD_INT 0
9258: PPUSH
// if ProbihaUtok then
9259: LD_LOC 14
9263: IFFALSE 9267
// exit ;
9265: GO 9366
// if Utok_ZbyvaMinut = - 1 then
9267: LD_LOC 10
9271: PUSH
9272: LD_INT 1
9274: NEG
9275: EQUAL
9276: IFFALSE 9288
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9278: LD_ADDR_LOC 10
9282: PUSH
9283: CALL 9145 0 0
9287: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
9288: LD_LOC 10
9292: PUSH
9293: LD_INT 0
9295: GREATER
9296: IFFALSE 9312
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
9298: LD_ADDR_LOC 10
9302: PUSH
9303: LD_LOC 10
9307: PUSH
9308: LD_INT 1
9310: MINUS
9311: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
9312: CALL 9211 0 0
9316: NOT
9317: IFFALSE 9321
// exit ;
9319: GO 9366
// if Utok_ZbyvaMinut > 0 then
9321: LD_LOC 10
9325: PUSH
9326: LD_INT 0
9328: GREATER
9329: IFFALSE 9333
// exit ;
9331: GO 9366
// Utok_Auta = zjisti_auta_na_utok ;
9333: LD_ADDR_LOC 9
9337: PUSH
9338: CALL 8499 0 0
9342: ST_TO_ADDR
// if not Utok_Auta then
9343: LD_LOC 9
9347: NOT
9348: IFFALSE 9352
// exit ;
9350: GO 9366
// zacni_utok ;
9352: CALL 8414 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9356: LD_ADDR_LOC 10
9360: PUSH
9361: CALL 9145 0 0
9365: ST_TO_ADDR
// end ;
9366: LD_VAR 0 1
9370: RET
// every 0 0$6 do
9371: GO 9373
9373: DISABLE
// begin zacni_vynalezat ;
9374: CALL 8216 0 0
// patrola_kolecko ;
9378: CALL 10558 0 0
// end ;
9382: END
// every 0 0$19 do
9383: GO 9385
9385: DISABLE
// begin kontrola_vyroby ;
9386: CALL 7852 0 0
// enable ;
9390: ENABLE
// end ;
9391: END
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , NovyRidic ; begin
9392: LD_INT 0
9394: PPUSH
9395: PPUSH
9396: PPUSH
// if GetSide ( Veh ) = side_Ar then
9397: LD_VAR 0 1
9401: PPUSH
9402: CALL_OW 255
9406: PUSH
9407: LD_EXP 4
9411: EQUAL
9412: IFFALSE 9690
// begin NovyRidic = 0 ;
9414: LD_ADDR_VAR 0 5
9418: PUSH
9419: LD_INT 0
9421: ST_TO_ADDR
// Autaky = Autaky union [ Veh ] ;
9422: LD_ADDR_LOC 6
9426: PUSH
9427: LD_LOC 6
9431: PUSH
9432: LD_VAR 0 1
9436: PUSH
9437: EMPTY
9438: LIST
9439: UNION
9440: ST_TO_ADDR
// if ( GetWeapon ( Veh ) = AR_CONTROL_TOWER ) then
9441: LD_VAR 0 1
9445: PPUSH
9446: CALL_OW 264
9450: PUSH
9451: LD_INT 31
9453: EQUAL
9454: IFFALSE 9482
// begin ArDalkar = Veh ;
9456: LD_ADDR_LOC 25
9460: PUSH
9461: LD_VAR 0 1
9465: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 42
9473: ST_TO_ADDR
// DelamDalkare = false ;
9474: LD_ADDR_LOC 27
9478: PUSH
9479: LD_INT 0
9481: ST_TO_ADDR
// end ; if ( GetControl ( Veh ) = CONTROL_MANUAL ) and VolnyLidi then
9482: LD_VAR 0 1
9486: PPUSH
9487: CALL_OW 263
9491: PUSH
9492: LD_INT 1
9494: EQUAL
9495: PUSH
9496: LD_LOC 8
9500: AND
9501: IFFALSE 9625
// begin Ridic = IsDrivenBy ( Veh ) ;
9503: LD_ADDR_VAR 0 4
9507: PUSH
9508: LD_VAR 0 1
9512: PPUSH
9513: CALL_OW 311
9517: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9518: LD_INT 105
9520: PPUSH
9521: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
9525: LD_VAR 0 4
9529: PPUSH
9530: CALL_OW 121
// Wait ( 0 0$1 ) ;
9534: LD_INT 35
9536: PPUSH
9537: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
9541: LD_VAR 0 1
9545: PPUSH
9546: CALL_OW 311
9550: PUSH
9551: LD_VAR 0 4
9555: EQUAL
9556: IFFALSE 9567
// Wait ( 0 0$1 ) ;
9558: LD_INT 35
9560: PPUSH
9561: CALL_OW 67
9565: GO 9541
// AddComEnterUnit ( Ridic , Fact ) ;
9567: LD_VAR 0 4
9571: PPUSH
9572: LD_VAR 0 2
9576: PPUSH
9577: CALL_OW 180
// if NovyRidic then
9581: LD_VAR 0 5
9585: IFFALSE 9601
// ComEnterUnit ( NovyRidic , Veh ) ;
9587: LD_VAR 0 5
9591: PPUSH
9592: LD_VAR 0 1
9596: PPUSH
9597: CALL_OW 120
// Wait ( 0 0$3 ) ;
9601: LD_INT 105
9603: PPUSH
9604: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9608: LD_LOC 23
9612: PPUSH
9613: LD_VAR 0 1
9617: PUSH
9618: EMPTY
9619: LIST
9620: PPUSH
9621: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 263
9634: PUSH
9635: LD_INT 2
9637: EQUAL
9638: IFFALSE 9690
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
9640: LD_VAR 0 1
9644: PPUSH
9645: LD_INT 42
9647: PPUSH
9648: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
9652: LD_ADDR_LOC 26
9656: PUSH
9657: LD_LOC 26
9661: PUSH
9662: LD_INT 1
9664: PLUS
9665: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9666: LD_INT 105
9668: PPUSH
9669: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9673: LD_LOC 23
9677: PPUSH
9678: LD_VAR 0 1
9682: PUSH
9683: EMPTY
9684: LIST
9685: PPUSH
9686: CALL_OW 390
// end ; end ; end ;
9690: LD_VAR 0 3
9694: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
9699: PPUSH
// if Veh = ArDalkar then
9700: LD_VAR 0 1
9704: PUSH
9705: LD_LOC 25
9709: EQUAL
9710: IFFALSE 9745
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
9712: LD_INT 42
9714: PPUSH
9715: CALL_OW 302
9719: PUSH
9720: LD_INT 42
9722: PPUSH
9723: CALL_OW 310
9727: NOT
9728: AND
9729: IFFALSE 9745
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
9731: LD_INT 42
9733: PPUSH
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 120
// exit ;
9743: GO 9816
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
9745: LD_ADDR_VAR 0 3
9749: PUSH
9750: LD_LOC 8
9754: PPUSH
9755: LD_INT 56
9757: PUSH
9758: EMPTY
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: PPUSH
9764: CALL_OW 72
9768: ST_TO_ADDR
// for I in Lidi do
9769: LD_ADDR_VAR 0 4
9773: PUSH
9774: LD_VAR 0 3
9778: PUSH
9779: FOR_IN
9780: IFFALSE 9814
// if not HasTask ( I ) then
9782: LD_VAR 0 4
9786: PPUSH
9787: CALL_OW 314
9791: NOT
9792: IFFALSE 9812
// begin ComEnterUnit ( I , Veh ) ;
9794: LD_VAR 0 4
9798: PPUSH
9799: LD_VAR 0 1
9803: PPUSH
9804: CALL_OW 120
// exit ;
9808: POP
9809: POP
9810: GO 9816
// end ;
9812: GO 9779
9814: POP
9815: POP
// end ;
9816: LD_VAR 0 2
9820: RET
// function nastupuj_auta ; var Auta , I ; begin
9821: LD_INT 0
9823: PPUSH
9824: PPUSH
9825: PPUSH
// Auta = FilterUnitsInArea ( Obrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
9826: LD_ADDR_VAR 0 2
9830: PUSH
9831: LD_INT 37
9833: PPUSH
9834: LD_INT 21
9836: PUSH
9837: LD_INT 2
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: PUSH
9844: LD_INT 33
9846: PUSH
9847: LD_INT 1
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 58
9856: PUSH
9857: EMPTY
9858: LIST
9859: PUSH
9860: EMPTY
9861: LIST
9862: LIST
9863: LIST
9864: PPUSH
9865: CALL_OW 70
9869: ST_TO_ADDR
// if not Auta then
9870: LD_VAR 0 2
9874: NOT
9875: IFFALSE 9879
// exit ;
9877: GO 9905
// for I in Auta do
9879: LD_ADDR_VAR 0 3
9883: PUSH
9884: LD_VAR 0 2
9888: PUSH
9889: FOR_IN
9890: IFFALSE 9903
// zarid_ridice ( I ) ;
9892: LD_VAR 0 3
9896: PPUSH
9897: CALL 9695 0 1
9901: GO 9889
9903: POP
9904: POP
// end ;
9905: LD_VAR 0 1
9909: RET
// every 0 0$17 do
9910: GO 9912
9912: DISABLE
// begin nastupuj_auta ;
9913: CALL 9821 0 0
// enable ;
9917: ENABLE
// end ;
9918: END
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
9919: LD_INT 0
9921: PPUSH
// if VehOld in Patrola then
9922: LD_VAR 0 2
9926: PUSH
9927: LD_LOC 16
9931: IN
9932: IFFALSE 9953
// Patrola = Patrola diff [ VehOld ] ;
9934: LD_ADDR_LOC 16
9938: PUSH
9939: LD_LOC 16
9943: PUSH
9944: LD_VAR 0 2
9948: PUSH
9949: EMPTY
9950: LIST
9951: DIFF
9952: ST_TO_ADDR
// if VehOld in Autaky then
9953: LD_VAR 0 2
9957: PUSH
9958: LD_LOC 6
9962: IN
9963: IFFALSE 9984
// Autaky = Autaky diff [ VehOld ] ;
9965: LD_ADDR_LOC 6
9969: PUSH
9970: LD_LOC 6
9974: PUSH
9975: LD_VAR 0 2
9979: PUSH
9980: EMPTY
9981: LIST
9982: DIFF
9983: ST_TO_ADDR
// if VehOld in Utok_Auta then
9984: LD_VAR 0 2
9988: PUSH
9989: LD_LOC 9
9993: IN
9994: IFFALSE 10015
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
9996: LD_ADDR_LOC 9
10000: PUSH
10001: LD_LOC 9
10005: PUSH
10006: LD_VAR 0 2
10010: PUSH
10011: EMPTY
10012: LIST
10013: DIFF
10014: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
10015: LD_VAR 0 1
10019: PPUSH
10020: CALL_OW 255
10024: PUSH
10025: LD_EXP 4
10029: EQUAL
10030: IFFALSE 10079
// begin Autaky = Autaky union [ VehNew ] ;
10032: LD_ADDR_LOC 6
10036: PUSH
10037: LD_LOC 6
10041: PUSH
10042: LD_VAR 0 1
10046: PUSH
10047: EMPTY
10048: LIST
10049: UNION
10050: ST_TO_ADDR
// AddMcUnits ( MakroObrana , VehNew ) ;
10051: LD_LOC 20
10055: PPUSH
10056: LD_VAR 0 1
10060: PPUSH
10061: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , VehNew ) ;
10065: LD_LOC 23
10069: PPUSH
10070: LD_VAR 0 1
10074: PPUSH
10075: CALL_OW 390
// end ; if GetSide ( VehOld ) = side_Ar then
10079: LD_VAR 0 2
10083: PPUSH
10084: CALL_OW 255
10088: PUSH
10089: LD_EXP 4
10093: EQUAL
10094: IFFALSE 10144
// begin RemoveMcUnits ( MakroObrana , VehOld ) ;
10096: LD_LOC 20
10100: PPUSH
10101: LD_VAR 0 2
10105: PPUSH
10106: CALL_OW 391
// RemoveMcUnits ( MakroPresunZakladna , VehOld ) ;
10110: LD_LOC 23
10114: PPUSH
10115: LD_VAR 0 2
10119: PPUSH
10120: CALL_OW 391
// if MakroUtok then
10124: LD_LOC 21
10128: IFFALSE 10144
// RemoveMcUnits ( MakroUtok , VehOld ) ;
10130: LD_LOC 21
10134: PPUSH
10135: LD_VAR 0 2
10139: PPUSH
10140: CALL_OW 391
// end ; kontrola_zniceno ;
10144: CALL 7583 0 0
// end ;
10148: LD_VAR 0 5
10152: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
10153: LD_INT 0
10155: PPUSH
// if Un in Patrola then
10156: LD_VAR 0 1
10160: PUSH
10161: LD_LOC 16
10165: IN
10166: IFFALSE 10187
// Patrola = Patrola diff [ Un ] ;
10168: LD_ADDR_LOC 16
10172: PUSH
10173: LD_LOC 16
10177: PUSH
10178: LD_VAR 0 1
10182: PUSH
10183: EMPTY
10184: LIST
10185: DIFF
10186: ST_TO_ADDR
// if Un in Autaky then
10187: LD_VAR 0 1
10191: PUSH
10192: LD_LOC 6
10196: IN
10197: IFFALSE 10218
// Autaky = Autaky diff [ Un ] ;
10199: LD_ADDR_LOC 6
10203: PUSH
10204: LD_LOC 6
10208: PUSH
10209: LD_VAR 0 1
10213: PUSH
10214: EMPTY
10215: LIST
10216: DIFF
10217: ST_TO_ADDR
// if Un in Utok_Auta then
10218: LD_VAR 0 1
10222: PUSH
10223: LD_LOC 9
10227: IN
10228: IFFALSE 10249
// Utok_Auta = Utok_Auta diff [ Un ] ;
10230: LD_ADDR_LOC 9
10234: PUSH
10235: LD_LOC 9
10239: PUSH
10240: LD_VAR 0 1
10244: PUSH
10245: EMPTY
10246: LIST
10247: DIFF
10248: ST_TO_ADDR
// if Un in VolnyLidi then
10249: LD_VAR 0 1
10253: PUSH
10254: LD_LOC 8
10258: IN
10259: IFFALSE 10280
// VolnyLidi = VolnyLidi diff [ Un ] ;
10261: LD_ADDR_LOC 8
10265: PUSH
10266: LD_LOC 8
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: DIFF
10279: ST_TO_ADDR
// kontrola_zniceno ;
10280: CALL 7583 0 0
// end ;
10284: LD_VAR 0 2
10288: RET
// export function arabi_UnitGoesToRed ( Un ) ; begin
10289: LD_INT 0
10291: PPUSH
// if ( Un = ArPBunk1 ) then
10292: LD_VAR 0 1
10296: PUSH
10297: LD_INT 2
10299: EQUAL
10300: IFFALSE 10331
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk1 ] ;
10302: LD_ADDR_LOC 8
10306: PUSH
10307: LD_LOC 8
10311: PUSH
10312: LD_INT 15
10314: PUSH
10315: EMPTY
10316: LIST
10317: UNION
10318: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk1 ) ;
10319: LD_LOC 22
10323: PPUSH
10324: LD_INT 15
10326: PPUSH
10327: CALL_OW 391
// end ; if ( Un = ArPBunk2 ) then
10331: LD_VAR 0 1
10335: PUSH
10336: LD_INT 1
10338: EQUAL
10339: IFFALSE 10370
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk2 ] ;
10341: LD_ADDR_LOC 8
10345: PUSH
10346: LD_LOC 8
10350: PUSH
10351: LD_INT 25
10353: PUSH
10354: EMPTY
10355: LIST
10356: UNION
10357: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk2 ) ;
10358: LD_LOC 22
10362: PPUSH
10363: LD_INT 25
10365: PPUSH
10366: CALL_OW 391
// end ; if ( Un = ArPBunk3 ) then
10370: LD_VAR 0 1
10374: PUSH
10375: LD_INT 32
10377: EQUAL
10378: IFFALSE 10409
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk3 ] ;
10380: LD_ADDR_LOC 8
10384: PUSH
10385: LD_LOC 8
10389: PUSH
10390: LD_INT 33
10392: PUSH
10393: EMPTY
10394: LIST
10395: UNION
10396: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk3 ) ;
10397: LD_LOC 22
10401: PPUSH
10402: LD_INT 33
10404: PPUSH
10405: CALL_OW 391
// end ; end ;
10409: LD_VAR 0 2
10413: RET
// export function arabi_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
10414: LD_INT 0
10416: PPUSH
// kontrola_zniceno ;
10417: CALL 7583 0 0
// end ;
10421: LD_VAR 0 4
10425: RET
// export function arabi_muzete_utocit ; begin
10426: LD_INT 0
10428: PPUSH
// enable ( 43 ) ;
10429: LD_INT 43
10431: ENABLE_MARKED
// end ;
10432: LD_VAR 0 1
10436: RET
// every 0 0$45 marked 43 do
10437: GO 10439
10439: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
10440: LD_INT 0
10442: PPUSH
10443: LD_INT 1050
10445: PPUSH
10446: CALL_OW 12
10450: PPUSH
10451: CALL_OW 67
// casovac_utok ;
10455: CALL 9256 0 0
// enable ;
10459: ENABLE
// end ;
10460: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
10461: LD_EXP 4
10465: PPUSH
10466: LD_EXP 2
10470: PPUSH
10471: CALL 20637 0 2
10475: IFFALSE 10492
10477: GO 10479
10479: DISABLE
// begin VidelRusa = true ;
10480: LD_ADDR_LOC 12
10484: PUSH
10485: LD_INT 1
10487: ST_TO_ADDR
// zrus_patrolu ;
10488: CALL 10493 0 0
// end ;
10492: END
// function zrus_patrolu ; begin
10493: LD_INT 0
10495: PPUSH
// ComAgressiveMove ( Patrola , 73 , 13 ) ;
10496: LD_LOC 16
10500: PPUSH
10501: LD_INT 73
10503: PPUSH
10504: LD_INT 13
10506: PPUSH
10507: CALL_OW 114
// AddComMoveUnit ( Patrola , ArDepot ) ;
10511: LD_LOC 16
10515: PPUSH
10516: LD_INT 3
10518: PPUSH
10519: CALL_OW 172
// AddComMoveToArea ( Patrola , AraboveParkoviste ) ;
10523: LD_LOC 16
10527: PPUSH
10528: LD_INT 18
10530: PPUSH
10531: CALL_OW 173
// Patrola = [ ] ;
10535: LD_ADDR_LOC 16
10539: PUSH
10540: EMPTY
10541: ST_TO_ADDR
// PatrolaZrusena = true ;
10542: LD_ADDR_LOC 17
10546: PUSH
10547: LD_INT 1
10549: ST_TO_ADDR
// disable ( 45 ) ;
10550: LD_INT 45
10552: DISABLE_MARKED
// end ;
10553: LD_VAR 0 1
10557: RET
// function patrola_kolecko ; begin
10558: LD_INT 0
10560: PPUSH
// ComMoveUnit ( Patrola , ArDepot ) ;
10561: LD_LOC 16
10565: PPUSH
10566: LD_INT 3
10568: PPUSH
10569: CALL_OW 112
// AddComMoveXY ( Patrola , 83 , 12 ) ;
10573: LD_LOC 16
10577: PPUSH
10578: LD_INT 83
10580: PPUSH
10581: LD_INT 12
10583: PPUSH
10584: CALL_OW 171
// AddComMoveXY ( Patrola , 68 , 13 ) ;
10588: LD_LOC 16
10592: PPUSH
10593: LD_INT 68
10595: PPUSH
10596: LD_INT 13
10598: PPUSH
10599: CALL_OW 171
// AddComMoveXY ( Patrola , 62 , 15 ) ;
10603: LD_LOC 16
10607: PPUSH
10608: LD_INT 62
10610: PPUSH
10611: LD_INT 15
10613: PPUSH
10614: CALL_OW 171
// AddComMoveXY ( Patrola , 54 , 15 ) ;
10618: LD_LOC 16
10622: PPUSH
10623: LD_INT 54
10625: PPUSH
10626: LD_INT 15
10628: PPUSH
10629: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 13 ) ;
10633: LD_LOC 16
10637: PPUSH
10638: LD_INT 46
10640: PPUSH
10641: LD_INT 13
10643: PPUSH
10644: CALL_OW 171
// AddComMoveXY ( Patrola , 36 , 13 ) ;
10648: LD_LOC 16
10652: PPUSH
10653: LD_INT 36
10655: PPUSH
10656: LD_INT 13
10658: PPUSH
10659: CALL_OW 171
// AddComMoveXY ( Patrola , 31 , 17 ) ;
10663: LD_LOC 16
10667: PPUSH
10668: LD_INT 31
10670: PPUSH
10671: LD_INT 17
10673: PPUSH
10674: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.7 ) ;
10678: LD_LOC 16
10682: PPUSH
10683: LD_INT 165
10685: PPUSH
10686: CALL_OW 202
// AddComMoveXY ( Patrola , 20 , 16 ) ;
10690: LD_LOC 16
10694: PPUSH
10695: LD_INT 20
10697: PPUSH
10698: LD_INT 16
10700: PPUSH
10701: CALL_OW 171
// AddComMoveXY ( Patrola , 4 , 3 ) ;
10705: LD_LOC 16
10709: PPUSH
10710: LD_INT 4
10712: PPUSH
10713: LD_INT 3
10715: PPUSH
10716: CALL_OW 171
// AddComWait ( Patrola , 0 0$4 ) ;
10720: LD_LOC 16
10724: PPUSH
10725: LD_INT 140
10727: PPUSH
10728: CALL_OW 202
// AddComMoveXY ( Patrola , 6 , 7 ) ;
10732: LD_LOC 16
10736: PPUSH
10737: LD_INT 6
10739: PPUSH
10740: LD_INT 7
10742: PPUSH
10743: CALL_OW 171
// AddComMoveXY ( Patrola , 20 , 17 ) ;
10747: LD_LOC 16
10751: PPUSH
10752: LD_INT 20
10754: PPUSH
10755: LD_INT 17
10757: PPUSH
10758: CALL_OW 171
// AddComMoveXY ( Patrola , 28 , 18 ) ;
10762: LD_LOC 16
10766: PPUSH
10767: LD_INT 28
10769: PPUSH
10770: LD_INT 18
10772: PPUSH
10773: CALL_OW 171
// AddComWait ( Patrola , 0 0$5.2 ) ;
10777: LD_LOC 16
10781: PPUSH
10782: LD_INT 182
10784: PPUSH
10785: CALL_OW 202
// if not VsevSaved then
10789: LD_EXP 8
10793: NOT
10794: IFFALSE 11114
// begin AddComMoveXY ( Patrola , 33 , 21 ) ;
10796: LD_LOC 16
10800: PPUSH
10801: LD_INT 33
10803: PPUSH
10804: LD_INT 21
10806: PPUSH
10807: CALL_OW 171
// AddComMoveXY ( Patrola , 37 , 34 ) ;
10811: LD_LOC 16
10815: PPUSH
10816: LD_INT 37
10818: PPUSH
10819: LD_INT 34
10821: PPUSH
10822: CALL_OW 171
// AddComMoveXY ( Patrola , 43 , 45 ) ;
10826: LD_LOC 16
10830: PPUSH
10831: LD_INT 43
10833: PPUSH
10834: LD_INT 45
10836: PPUSH
10837: CALL_OW 171
// AddComMoveXY ( Patrola , 55 , 59 ) ;
10841: LD_LOC 16
10845: PPUSH
10846: LD_INT 55
10848: PPUSH
10849: LD_INT 59
10851: PPUSH
10852: CALL_OW 171
// AddComMoveXY ( Patrola , 66 , 80 ) ;
10856: LD_LOC 16
10860: PPUSH
10861: LD_INT 66
10863: PPUSH
10864: LD_INT 80
10866: PPUSH
10867: CALL_OW 171
// AddComWait ( Patrola , 0 0$1.2 ) ;
10871: LD_LOC 16
10875: PPUSH
10876: LD_INT 42
10878: PPUSH
10879: CALL_OW 202
// AddComMoveXY ( Patrola , 73 , 95 ) ;
10883: LD_LOC 16
10887: PPUSH
10888: LD_INT 73
10890: PPUSH
10891: LD_INT 95
10893: PPUSH
10894: CALL_OW 171
// AddComMoveXY ( Patrola , 74 , 100 ) ;
10898: LD_LOC 16
10902: PPUSH
10903: LD_INT 74
10905: PPUSH
10906: LD_INT 100
10908: PPUSH
10909: CALL_OW 171
// AddComMoveXY ( Patrola , 82 , 116 ) ;
10913: LD_LOC 16
10917: PPUSH
10918: LD_INT 82
10920: PPUSH
10921: LD_INT 116
10923: PPUSH
10924: CALL_OW 171
// AddComMoveXY ( Patrola , 92 , 131 ) ;
10928: LD_LOC 16
10932: PPUSH
10933: LD_INT 92
10935: PPUSH
10936: LD_INT 131
10938: PPUSH
10939: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.4 ) ;
10943: LD_LOC 16
10947: PPUSH
10948: LD_INT 119
10950: PPUSH
10951: CALL_OW 202
// AddComMoveXY ( Patrola , 93 , 129 ) ;
10955: LD_LOC 16
10959: PPUSH
10960: LD_INT 93
10962: PPUSH
10963: LD_INT 129
10965: PPUSH
10966: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.1 ) ;
10970: LD_LOC 16
10974: PPUSH
10975: LD_INT 143
10977: PPUSH
10978: CALL_OW 202
// AddComMoveXY ( Patrola , 87 , 119 ) ;
10982: LD_LOC 16
10986: PPUSH
10987: LD_INT 87
10989: PPUSH
10990: LD_INT 119
10992: PPUSH
10993: CALL_OW 171
// AddComMoveXY ( Patrola , 77 , 100 ) ;
10997: LD_LOC 16
11001: PPUSH
11002: LD_INT 77
11004: PPUSH
11005: LD_INT 100
11007: PPUSH
11008: CALL_OW 171
// AddComMoveXY ( Patrola , 73 , 91 ) ;
11012: LD_LOC 16
11016: PPUSH
11017: LD_INT 73
11019: PPUSH
11020: LD_INT 91
11022: PPUSH
11023: CALL_OW 171
// AddComMoveXY ( Patrola , 65 , 73 ) ;
11027: LD_LOC 16
11031: PPUSH
11032: LD_INT 65
11034: PPUSH
11035: LD_INT 73
11037: PPUSH
11038: CALL_OW 171
// AddComMoveXY ( Patrola , 56 , 58 ) ;
11042: LD_LOC 16
11046: PPUSH
11047: LD_INT 56
11049: PPUSH
11050: LD_INT 58
11052: PPUSH
11053: CALL_OW 171
// AddComMoveXY ( Patrola , 47 , 47 ) ;
11057: LD_LOC 16
11061: PPUSH
11062: LD_INT 47
11064: PPUSH
11065: LD_INT 47
11067: PPUSH
11068: CALL_OW 171
// AddComMoveXY ( Patrola , 40 , 36 ) ;
11072: LD_LOC 16
11076: PPUSH
11077: LD_INT 40
11079: PPUSH
11080: LD_INT 36
11082: PPUSH
11083: CALL_OW 171
// AddComMoveXY ( Patrola , 35 , 25 ) ;
11087: LD_LOC 16
11091: PPUSH
11092: LD_INT 35
11094: PPUSH
11095: LD_INT 25
11097: PPUSH
11098: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.3 ) ;
11102: LD_LOC 16
11106: PPUSH
11107: LD_INT 115
11109: PPUSH
11110: CALL_OW 202
// end ; AddComMoveXY ( Patrola , 34 , 18 ) ;
11114: LD_LOC 16
11118: PPUSH
11119: LD_INT 34
11121: PPUSH
11122: LD_INT 18
11124: PPUSH
11125: CALL_OW 171
// AddComMoveXY ( Patrola , 38 , 14 ) ;
11129: LD_LOC 16
11133: PPUSH
11134: LD_INT 38
11136: PPUSH
11137: LD_INT 14
11139: PPUSH
11140: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 14 ) ;
11144: LD_LOC 16
11148: PPUSH
11149: LD_INT 46
11151: PPUSH
11152: LD_INT 14
11154: PPUSH
11155: CALL_OW 171
// AddComMoveXY ( Patrola , 51 , 16 ) ;
11159: LD_LOC 16
11163: PPUSH
11164: LD_INT 51
11166: PPUSH
11167: LD_INT 16
11169: PPUSH
11170: CALL_OW 171
// AddComMoveXY ( Patrola , 61 , 16 ) ;
11174: LD_LOC 16
11178: PPUSH
11179: LD_INT 61
11181: PPUSH
11182: LD_INT 16
11184: PPUSH
11185: CALL_OW 171
// AddComMoveXY ( Patrola , 75 , 14 ) ;
11189: LD_LOC 16
11193: PPUSH
11194: LD_INT 75
11196: PPUSH
11197: LD_INT 14
11199: PPUSH
11200: CALL_OW 171
// AddComMoveXY ( Patrola , 86 , 18 ) ;
11204: LD_LOC 16
11208: PPUSH
11209: LD_INT 86
11211: PPUSH
11212: LD_INT 18
11214: PPUSH
11215: CALL_OW 171
// AddComWait ( Patrola , 0 0$2.9 ) ;
11219: LD_LOC 16
11223: PPUSH
11224: LD_INT 101
11226: PPUSH
11227: CALL_OW 202
// AddComSailEvent ( Patrola , 101 ) ;
11231: LD_LOC 16
11235: PPUSH
11236: LD_INT 101
11238: PPUSH
11239: CALL_OW 224
// end ;
11243: LD_VAR 0 1
11247: RET
// export function event_Patrola ; begin
11248: LD_INT 0
11250: PPUSH
// if Patrola and not PatrolaZrusena then
11251: LD_LOC 16
11255: PUSH
11256: LD_LOC 17
11260: NOT
11261: AND
11262: IFFALSE 11268
// patrola_kolecko ;
11264: CALL 10558 0 0
// end ;
11268: LD_VAR 0 1
11272: RET
// every 0 0$27.1 marked 45 do var Kdo ;
11273: GO 11275
11275: DISABLE
11276: LD_INT 0
11278: PPUSH
// begin if not Patrola then
11279: LD_LOC 16
11283: NOT
11284: IFFALSE 11288
// exit ;
11286: GO 11329
// for Kdo in Patrola do
11288: LD_ADDR_VAR 0 1
11292: PUSH
11293: LD_LOC 16
11297: PUSH
11298: FOR_IN
11299: IFFALSE 11326
// if GetFuel ( Kdo ) < 25 then
11301: LD_VAR 0 1
11305: PPUSH
11306: CALL_OW 261
11310: PUSH
11311: LD_INT 25
11313: LESS
11314: IFFALSE 11324
// begin zrus_patrolu ;
11316: CALL 10493 0 0
// exit ;
11320: POP
11321: POP
11322: GO 11329
// end ;
11324: GO 11298
11326: POP
11327: POP
// enable ;
11328: ENABLE
// end ;
11329: PPOPN 1
11331: END
// every 0 0$5.1 do var I , Stahnout ;
11332: GO 11334
11334: DISABLE
11335: LD_INT 0
11337: PPUSH
11338: PPUSH
// begin Stahnout = true ;
11339: LD_ADDR_VAR 0 2
11343: PUSH
11344: LD_INT 1
11346: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
11347: LD_ADDR_VAR 0 1
11351: PUSH
11352: LD_LOC 20
11356: PPUSH
11357: CALL_OW 389
11361: PUSH
11362: FOR_IN
11363: IFFALSE 11394
// if ( GetUnitMc ( I ) = MakroObrana ) then
11365: LD_VAR 0 1
11369: PPUSH
11370: CALL_OW 388
11374: PUSH
11375: LD_LOC 20
11379: EQUAL
11380: IFFALSE 11392
// begin Stahnout = false ;
11382: LD_ADDR_VAR 0 2
11386: PUSH
11387: LD_INT 0
11389: ST_TO_ADDR
// break ;
11390: GO 11394
// end ;
11392: GO 11362
11394: POP
11395: POP
// enable ;
11396: ENABLE
// if Stahnout <> BeziStahovani then
11397: LD_VAR 0 2
11401: PUSH
11402: LD_LOC 24
11406: NONEQUAL
11407: IFFALSE 11433
// begin if Stahnout then
11409: LD_VAR 0 2
11413: IFFALSE 11420
// enable ( 46 ) else
11415: LD_INT 46
11417: ENABLE_MARKED
11418: GO 11423
// disable ( 46 ) ;
11420: LD_INT 46
11422: DISABLE_MARKED
// BeziStahovani = Stahnout ;
11423: LD_ADDR_LOC 24
11427: PUSH
11428: LD_VAR 0 2
11432: ST_TO_ADDR
// end ; end ;
11433: PPOPN 2
11435: END
// every 0 0$30 marked 46 do var I ;
11436: GO 11438
11438: DISABLE
11439: LD_INT 0
11441: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
11442: LD_ADDR_VAR 0 1
11446: PUSH
11447: LD_LOC 23
11451: PPUSH
11452: CALL_OW 389
11456: PUSH
11457: FOR_IN
11458: IFFALSE 11533
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , ArabskaBaze ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
11460: LD_VAR 0 1
11464: PPUSH
11465: CALL_OW 388
11469: PUSH
11470: LD_LOC 23
11474: EQUAL
11475: PUSH
11476: LD_VAR 0 1
11480: PPUSH
11481: LD_INT 14
11483: PPUSH
11484: CALL_OW 299
11488: PUSH
11489: LD_INT 0
11491: GREATER
11492: AND
11493: PUSH
11494: LD_VAR 0 1
11498: PPUSH
11499: CALL_OW 310
11503: NOT
11504: AND
11505: PUSH
11506: LD_VAR 0 1
11510: PPUSH
11511: CALL_OW 314
11515: NOT
11516: AND
11517: IFFALSE 11531
// ComMoveToArea ( I , ArabskaBaze ) ;
11519: LD_VAR 0 1
11523: PPUSH
11524: LD_INT 14
11526: PPUSH
11527: CALL_OW 113
11531: GO 11457
11533: POP
11534: POP
// BeziStahovani = false ;
11535: LD_ADDR_LOC 24
11539: PUSH
11540: LD_INT 0
11542: ST_TO_ADDR
// end ;
11543: PPOPN 1
11545: END
// function posila_tank ; begin
11546: LD_INT 0
11548: PPUSH
// UC_Side = side_Ar ;
11549: LD_ADDR_OWVAR 20
11553: PUSH
11554: LD_EXP 4
11558: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
11559: LD_ADDR_OWVAR 21
11563: PUSH
11564: LD_INT 2
11566: ST_TO_ADDR
// VC_Chassis = AR_MEDIUM_TRIKE ;
11567: LD_ADDR_OWVAR 37
11571: PUSH
11572: LD_INT 13
11574: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
11575: LD_ADDR_OWVAR 38
11579: PUSH
11580: LD_INT 1
11582: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
11583: LD_ADDR_OWVAR 39
11587: PUSH
11588: LD_INT 1
11590: ST_TO_ADDR
// VC_Weapon = nahoda_seznam ( [ AR_FLAME_THROWER , AR_ROCKET_LAUNCHER , AR_MULTIMISSILE_BALLISTA ] ) ;
11591: LD_ADDR_OWVAR 40
11595: PUSH
11596: LD_INT 26
11598: PUSH
11599: LD_INT 28
11601: PUSH
11602: LD_INT 22
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: LIST
11609: PPUSH
11610: CALL 20919 0 1
11614: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 85 , 100 ) ;
11615: LD_ADDR_OWVAR 41
11619: PUSH
11620: LD_INT 85
11622: PPUSH
11623: LD_INT 100
11625: PPUSH
11626: CALL_OW 12
11630: ST_TO_ADDR
// Result = CreateVehicle ;
11631: LD_ADDR_VAR 0 1
11635: PUSH
11636: CALL_OW 45
11640: ST_TO_ADDR
// PlaceHumanInUnit ( vytvor_cloveka ( CLASS_MECHANIC ) , Result ) ;
11641: LD_INT 3
11643: PPUSH
11644: CALL 7160 0 1
11648: PPUSH
11649: LD_VAR 0 1
11653: PPUSH
11654: CALL_OW 52
// end ;
11658: LD_VAR 0 1
11662: RET
// function vytvor_posily ; begin
11663: LD_INT 0
11665: PPUSH
// Result = [ ] ;
11666: LD_ADDR_VAR 0 1
11670: PUSH
11671: EMPTY
11672: ST_TO_ADDR
// if Difficulty = 1 then
11673: LD_OWVAR 67
11677: PUSH
11678: LD_INT 1
11680: EQUAL
11681: IFFALSE 11685
// exit ;
11683: GO 11773
// Result = Result union [ posila_tank ] ;
11685: LD_ADDR_VAR 0 1
11689: PUSH
11690: LD_VAR 0 1
11694: PUSH
11695: CALL 11546 0 0
11699: PUSH
11700: EMPTY
11701: LIST
11702: UNION
11703: ST_TO_ADDR
// if Difficulty = 2 then
11704: LD_OWVAR 67
11708: PUSH
11709: LD_INT 2
11711: EQUAL
11712: IFFALSE 11716
// exit ;
11714: GO 11773
// Result = Result union [ posila_tank ] ;
11716: LD_ADDR_VAR 0 1
11720: PUSH
11721: LD_VAR 0 1
11725: PUSH
11726: CALL 11546 0 0
11730: PUSH
11731: EMPTY
11732: LIST
11733: UNION
11734: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11735: LD_ADDR_VAR 0 1
11739: PUSH
11740: LD_VAR 0 1
11744: PUSH
11745: CALL 11546 0 0
11749: PUSH
11750: EMPTY
11751: LIST
11752: UNION
11753: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11754: LD_ADDR_VAR 0 1
11758: PUSH
11759: LD_VAR 0 1
11763: PUSH
11764: CALL 11546 0 0
11768: PUSH
11769: EMPTY
11770: LIST
11771: UNION
11772: ST_TO_ADDR
// end ;
11773: LD_VAR 0 1
11777: RET
// every 13 13$1 do var Posily , Lidi , I , J ;
11778: GO 11780
11780: DISABLE
11781: LD_INT 0
11783: PPUSH
11784: PPUSH
11785: PPUSH
11786: PPUSH
// begin Posily = vytvor_posily ;
11787: LD_ADDR_VAR 0 1
11791: PUSH
11792: CALL 11663 0 0
11796: ST_TO_ADDR
// place_list ( Posily , ArabovePosily ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: LD_INT 41
11804: PPUSH
11805: CALL 20594 0 2
// Lidi = [ ] ;
11809: LD_ADDR_VAR 0 2
11813: PUSH
11814: EMPTY
11815: ST_TO_ADDR
// for I in Posily do
11816: LD_ADDR_VAR 0 3
11820: PUSH
11821: LD_VAR 0 1
11825: PUSH
11826: FOR_IN
11827: IFFALSE 11871
// begin J = IsDrivenBy ( I ) ;
11829: LD_ADDR_VAR 0 4
11833: PUSH
11834: LD_VAR 0 3
11838: PPUSH
11839: CALL_OW 311
11843: ST_TO_ADDR
// if J then
11844: LD_VAR 0 4
11848: IFFALSE 11869
// Lidi = Lidi union [ J ] ;
11850: LD_ADDR_VAR 0 2
11854: PUSH
11855: LD_VAR 0 2
11859: PUSH
11860: LD_VAR 0 4
11864: PUSH
11865: EMPTY
11866: LIST
11867: UNION
11868: ST_TO_ADDR
// end ;
11869: GO 11826
11871: POP
11872: POP
// Autaky = Autaky union Posily ;
11873: LD_ADDR_LOC 6
11877: PUSH
11878: LD_LOC 6
11882: PUSH
11883: LD_VAR 0 1
11887: UNION
11888: ST_TO_ADDR
// AddMcUnits ( MakroObrana , Lidi union Posily ) ;
11889: LD_LOC 20
11893: PPUSH
11894: LD_VAR 0 2
11898: PUSH
11899: LD_VAR 0 1
11903: UNION
11904: PPUSH
11905: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , Lidi union Posily ) ;
11909: LD_LOC 23
11913: PPUSH
11914: LD_VAR 0 2
11918: PUSH
11919: LD_VAR 0 1
11923: UNION
11924: PPUSH
11925: CALL_OW 390
// end ;
11929: PPOPN 4
11931: END
// every 2 2$7 do
11932: GO 11934
11934: DISABLE
// begin opravuj_budovy ;
11935: CALL 11953 0 0
// kuryruj_lidi ;
11939: CALL 12398 0 0
// opravuj_auta ;
11943: CALL 12160 0 0
// sbirej_bedny ;
11947: CALL 12126 0 0
// enable ;
11951: ENABLE
// end ;
11952: END
// function opravuj_budovy ; var Budovy , Opravit , I , Kde ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
11959: PPUSH
// if not IsOk ( ArEng ) then
11960: LD_INT 16
11962: PPUSH
11963: CALL_OW 302
11967: NOT
11968: IFFALSE 11972
// exit ;
11970: GO 12121
// Budovy = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , side_Ar ] ] ) ;
11972: LD_ADDR_VAR 0 2
11976: PUSH
11977: LD_INT 14
11979: PPUSH
11980: LD_INT 21
11982: PUSH
11983: LD_INT 3
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 22
11992: PUSH
11993: LD_EXP 4
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: PPUSH
12006: CALL_OW 70
12010: ST_TO_ADDR
// Opravit = [ ] ;
12011: LD_ADDR_VAR 0 3
12015: PUSH
12016: EMPTY
12017: ST_TO_ADDR
// for I in Budovy do
12018: LD_ADDR_VAR 0 4
12022: PUSH
12023: LD_VAR 0 2
12027: PUSH
12028: FOR_IN
12029: IFFALSE 12067
// if GetLives ( I ) < HRANICE_ZDRAVI then
12031: LD_VAR 0 4
12035: PPUSH
12036: CALL_OW 256
12040: PUSH
12041: LD_INT 1000
12043: LESS
12044: IFFALSE 12065
// Opravit = Opravit union [ I ] ;
12046: LD_ADDR_VAR 0 3
12050: PUSH
12051: LD_VAR 0 3
12055: PUSH
12056: LD_VAR 0 4
12060: PUSH
12061: EMPTY
12062: LIST
12063: UNION
12064: ST_TO_ADDR
12065: GO 12028
12067: POP
12068: POP
// ComCancel ( ArEng ) ;
12069: LD_INT 16
12071: PPUSH
12072: CALL_OW 127
// if Opravit then
12076: LD_VAR 0 3
12080: IFFALSE 12121
// begin for I in Opravit do
12082: LD_ADDR_VAR 0 4
12086: PUSH
12087: LD_VAR 0 3
12091: PUSH
12092: FOR_IN
12093: IFFALSE 12109
// AddComRepairBuilding ( ArEng , I ) ;
12095: LD_INT 16
12097: PPUSH
12098: LD_VAR 0 4
12102: PPUSH
12103: CALL_OW 190
12107: GO 12092
12109: POP
12110: POP
// AddComMoveToArea ( ArEng , BednyArabi ) ;
12111: LD_INT 16
12113: PPUSH
12114: LD_INT 30
12116: PPUSH
12117: CALL_OW 173
// end ; end ;
12121: LD_VAR 0 1
12125: RET
// function sbirej_bedny ; begin
12126: LD_INT 0
12128: PPUSH
// if ArEng and IsOk ( ArEng ) then
12129: LD_INT 16
12131: PUSH
12132: LD_INT 16
12134: PPUSH
12135: CALL_OW 302
12139: AND
12140: IFFALSE 12155
// AddComCollect ( ArEng , 85 , 10 ) ;
12142: LD_INT 16
12144: PPUSH
12145: LD_INT 85
12147: PPUSH
12148: LD_INT 10
12150: PPUSH
12151: CALL_OW 177
// end ;
12155: LD_VAR 0 1
12159: RET
// function opravuj_auta ; var Auta , Opravit , I , Kde ; begin
12160: LD_INT 0
12162: PPUSH
12163: PPUSH
12164: PPUSH
12165: PPUSH
12166: PPUSH
// if ProbihaOprava then
12167: LD_LOC 29
12171: IFFALSE 12175
// exit ;
12173: GO 12393
// if not IsOk ( ArMech ) then
12175: LD_INT 21
12177: PPUSH
12178: CALL_OW 302
12182: NOT
12183: IFFALSE 12187
// exit ;
12185: GO 12393
// Auta = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , side_Ar ] ] ) diff Utok_Auta ;
12187: LD_ADDR_VAR 0 2
12191: PUSH
12192: LD_INT 14
12194: PPUSH
12195: LD_INT 21
12197: PUSH
12198: LD_INT 2
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_EXP 4
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PPUSH
12221: CALL_OW 70
12225: PUSH
12226: LD_LOC 9
12230: DIFF
12231: ST_TO_ADDR
// Opravit = [ ] ;
12232: LD_ADDR_VAR 0 3
12236: PUSH
12237: EMPTY
12238: ST_TO_ADDR
// for I in Auta do
12239: LD_ADDR_VAR 0 4
12243: PUSH
12244: LD_VAR 0 2
12248: PUSH
12249: FOR_IN
12250: IFFALSE 12288
// if GetLives ( I ) < HRANICE_ZDRAVI then
12252: LD_VAR 0 4
12256: PPUSH
12257: CALL_OW 256
12261: PUSH
12262: LD_INT 1000
12264: LESS
12265: IFFALSE 12286
// Opravit = Opravit union [ I ] ;
12267: LD_ADDR_VAR 0 3
12271: PUSH
12272: LD_VAR 0 3
12276: PUSH
12277: LD_VAR 0 4
12281: PUSH
12282: EMPTY
12283: LIST
12284: UNION
12285: ST_TO_ADDR
12286: GO 12249
12288: POP
12289: POP
// if Opravit then
12290: LD_VAR 0 3
12294: IFFALSE 12393
// begin Kde = IsInUnit ( ArMech ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 21
12303: PPUSH
12304: CALL_OW 310
12308: ST_TO_ADDR
// if Kde then
12309: LD_VAR 0 5
12313: IFFALSE 12346
// if GetType ( Kde ) = UNIT_BUILDING then
12315: LD_VAR 0 5
12319: PPUSH
12320: CALL_OW 247
12324: PUSH
12325: LD_INT 3
12327: EQUAL
12328: IFFALSE 12339
// ComExitBuilding ( ArMech ) else
12330: LD_INT 21
12332: PPUSH
12333: CALL_OW 122
12337: GO 12346
// ComExitVehicle ( ArMech ) ;
12339: LD_INT 21
12341: PPUSH
12342: CALL_OW 121
// for I in Opravit do
12346: LD_ADDR_VAR 0 4
12350: PUSH
12351: LD_VAR 0 3
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12373
// AddComRepairVehicle ( ArMech , I ) ;
12359: LD_INT 21
12361: PPUSH
12362: LD_VAR 0 4
12366: PPUSH
12367: CALL_OW 189
12371: GO 12356
12373: POP
12374: POP
// AddComSailEvent ( ArMech , 102 ) ;
12375: LD_INT 21
12377: PPUSH
12378: LD_INT 102
12380: PPUSH
12381: CALL_OW 224
// ProbihaOprava = true ;
12385: LD_ADDR_LOC 29
12389: PUSH
12390: LD_INT 1
12392: ST_TO_ADDR
// end ; end ;
12393: LD_VAR 0 1
12397: RET
// function kuryruj_lidi ; var Lidi , Opravit , I , Kde , Felcar , Budova , Event ; begin
12398: LD_INT 0
12400: PPUSH
12401: PPUSH
12402: PPUSH
12403: PPUSH
12404: PPUSH
12405: PPUSH
12406: PPUSH
12407: PPUSH
// if ProbihaLeceni then
12408: LD_LOC 30
12412: IFFALSE 12416
// exit ;
12414: GO 12700
// if IsOk ( ArSci1 ) then
12416: LD_INT 17
12418: PPUSH
12419: CALL_OW 302
12423: IFFALSE 12451
// begin Felcar = ArSci1 ;
12425: LD_ADDR_VAR 0 6
12429: PUSH
12430: LD_INT 17
12432: ST_TO_ADDR
// Budova = ArLab1 ;
12433: LD_ADDR_VAR 0 7
12437: PUSH
12438: LD_INT 6
12440: ST_TO_ADDR
// Event = 103 ;
12441: LD_ADDR_VAR 0 8
12445: PUSH
12446: LD_INT 103
12448: ST_TO_ADDR
// end else
12449: GO 12488
// if IsOk ( ArSci2 ) then
12451: LD_INT 18
12453: PPUSH
12454: CALL_OW 302
12458: IFFALSE 12486
// begin Felcar = ArSci2 ;
12460: LD_ADDR_VAR 0 6
12464: PUSH
12465: LD_INT 18
12467: ST_TO_ADDR
// Budova = ArLab2 ;
12468: LD_ADDR_VAR 0 7
12472: PUSH
12473: LD_INT 24
12475: ST_TO_ADDR
// Event = 104 ;
12476: LD_ADDR_VAR 0 8
12480: PUSH
12481: LD_INT 104
12483: ST_TO_ADDR
// end else
12484: GO 12488
// exit ;
12486: GO 12700
// Lidi = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , side_Ar ] ] ) ;
12488: LD_ADDR_VAR 0 2
12492: PUSH
12493: LD_INT 14
12495: PPUSH
12496: LD_INT 21
12498: PUSH
12499: LD_INT 1
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 22
12508: PUSH
12509: LD_EXP 4
12513: PUSH
12514: EMPTY
12515: LIST
12516: LIST
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// Opravit = [ ] ;
12527: LD_ADDR_VAR 0 3
12531: PUSH
12532: EMPTY
12533: ST_TO_ADDR
// for I in Lidi do
12534: LD_ADDR_VAR 0 4
12538: PUSH
12539: LD_VAR 0 2
12543: PUSH
12544: FOR_IN
12545: IFFALSE 12583
// if GetLives ( I ) < HRANICE_ZDRAVI then
12547: LD_VAR 0 4
12551: PPUSH
12552: CALL_OW 256
12556: PUSH
12557: LD_INT 1000
12559: LESS
12560: IFFALSE 12581
// Opravit = Opravit union [ I ] ;
12562: LD_ADDR_VAR 0 3
12566: PUSH
12567: LD_VAR 0 3
12571: PUSH
12572: LD_VAR 0 4
12576: PUSH
12577: EMPTY
12578: LIST
12579: UNION
12580: ST_TO_ADDR
12581: GO 12544
12583: POP
12584: POP
// if Opravit then
12585: LD_VAR 0 3
12589: IFFALSE 12700
// begin Kde = IsInUnit ( Felcar ) ;
12591: LD_ADDR_VAR 0 5
12595: PUSH
12596: LD_VAR 0 6
12600: PPUSH
12601: CALL_OW 310
12605: ST_TO_ADDR
// if Kde then
12606: LD_VAR 0 5
12610: IFFALSE 12647
// if GetType ( Kde ) = UNIT_BUILDING then
12612: LD_VAR 0 5
12616: PPUSH
12617: CALL_OW 247
12621: PUSH
12622: LD_INT 3
12624: EQUAL
12625: IFFALSE 12638
// ComExitBuilding ( Felcar ) else
12627: LD_VAR 0 6
12631: PPUSH
12632: CALL_OW 122
12636: GO 12647
// ComExitVehicle ( Felcar ) ;
12638: LD_VAR 0 6
12642: PPUSH
12643: CALL_OW 121
// for I in Opravit do
12647: LD_ADDR_VAR 0 4
12651: PUSH
12652: LD_VAR 0 3
12656: PUSH
12657: FOR_IN
12658: IFFALSE 12676
// AddComHeal ( Felcar , I ) ;
12660: LD_VAR 0 6
12664: PPUSH
12665: LD_VAR 0 4
12669: PPUSH
12670: CALL_OW 188
12674: GO 12657
12676: POP
12677: POP
// AddComSailEvent ( Felcar , Event ) ;
12678: LD_VAR 0 6
12682: PPUSH
12683: LD_VAR 0 8
12687: PPUSH
12688: CALL_OW 224
// ProbihaLeceni = true ;
12692: LD_ADDR_LOC 30
12696: PUSH
12697: LD_INT 1
12699: ST_TO_ADDR
// end ; end ;
12700: LD_VAR 0 1
12704: RET
// export function event_OpravaHotova ( Num ) ; begin
12705: LD_INT 0
12707: PPUSH
// case Num of 102 :
12708: LD_VAR 0 1
12712: PUSH
12713: LD_INT 102
12715: DOUBLE
12716: EQUAL
12717: IFTRUE 12721
12719: GO 12742
12721: POP
// begin ComEnterUnit ( ArMech , ArFact ) ;
12722: LD_INT 21
12724: PPUSH
12725: LD_INT 4
12727: PPUSH
12728: CALL_OW 120
// ProbihaOprava = false ;
12732: LD_ADDR_LOC 29
12736: PUSH
12737: LD_INT 0
12739: ST_TO_ADDR
// end ; 103 :
12740: GO 12801
12742: LD_INT 103
12744: DOUBLE
12745: EQUAL
12746: IFTRUE 12750
12748: GO 12771
12750: POP
// begin ComEnterUnit ( ArSci1 , ArLab1 ) ;
12751: LD_INT 17
12753: PPUSH
12754: LD_INT 6
12756: PPUSH
12757: CALL_OW 120
// ProbihaLeceni = false ;
12761: LD_ADDR_LOC 30
12765: PUSH
12766: LD_INT 0
12768: ST_TO_ADDR
// end ; 104 :
12769: GO 12801
12771: LD_INT 104
12773: DOUBLE
12774: EQUAL
12775: IFTRUE 12779
12777: GO 12800
12779: POP
// begin ComEnterUnit ( ArSci2 , ArLab2 ) ;
12780: LD_INT 18
12782: PPUSH
12783: LD_INT 24
12785: PPUSH
12786: CALL_OW 120
// ProbihaLeceni = false ;
12790: LD_ADDR_LOC 30
12794: PUSH
12795: LD_INT 0
12797: ST_TO_ADDR
// end ; end ;
12798: GO 12801
12800: POP
// end ;
12801: LD_VAR 0 2
12805: RET
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
12806: LD_INT 0
12808: PPUSH
12809: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
12810: LD_ADDR_VAR 0 4
12814: PUSH
12815: LD_INT 22
12817: PUSH
12818: LD_EXP 2
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: LD_INT 92
12829: PUSH
12830: LD_VAR 0 1
12834: PUSH
12835: LD_VAR 0 2
12839: PUSH
12840: LD_INT 2
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PPUSH
12853: CALL_OW 69
12857: ST_TO_ADDR
// if Jednotky then
12858: LD_VAR 0 4
12862: IFFALSE 12893
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
12864: LD_VAR 0 1
12868: PPUSH
12869: LD_VAR 0 2
12873: PPUSH
12874: LD_EXP 4
12878: PPUSH
12879: CALL_OW 456
// Result = true ;
12883: LD_ADDR_VAR 0 3
12887: PUSH
12888: LD_INT 1
12890: ST_TO_ADDR
// end else
12891: GO 12901
// Result = false ;
12893: LD_ADDR_VAR 0 3
12897: PUSH
12898: LD_INT 0
12900: ST_TO_ADDR
// end ;
12901: LD_VAR 0 3
12905: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
12906: GO 12908
12908: DISABLE
12909: LD_INT 0
12911: PPUSH
12912: PPUSH
// begin if not Miny then
12913: LD_LOC 28
12917: NOT
12918: IFFALSE 12922
// exit ;
12920: GO 13018
// Bouchlo = [ ] ;
12922: LD_ADDR_VAR 0 2
12926: PUSH
12927: EMPTY
12928: ST_TO_ADDR
// for M in Miny do
12929: LD_ADDR_VAR 0 1
12933: PUSH
12934: LD_LOC 28
12938: PUSH
12939: FOR_IN
12940: IFFALSE 12987
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
12942: LD_VAR 0 1
12946: PUSH
12947: LD_INT 1
12949: ARRAY
12950: PPUSH
12951: LD_VAR 0 1
12955: PUSH
12956: LD_INT 2
12958: ARRAY
12959: PPUSH
12960: CALL 12806 0 2
12964: IFFALSE 12985
// Bouchlo = Bouchlo ^ [ M ] ;
12966: LD_ADDR_VAR 0 2
12970: PUSH
12971: LD_VAR 0 2
12975: PUSH
12976: LD_VAR 0 1
12980: PUSH
12981: EMPTY
12982: LIST
12983: ADD
12984: ST_TO_ADDR
12985: GO 12939
12987: POP
12988: POP
// if Bouchlo then
12989: LD_VAR 0 2
12993: IFFALSE 13011
// Miny = Miny diff Bouchlo ;
12995: LD_ADDR_LOC 28
12999: PUSH
13000: LD_LOC 28
13004: PUSH
13005: LD_VAR 0 2
13009: DIFF
13010: ST_TO_ADDR
// if Miny then
13011: LD_LOC 28
13015: IFFALSE 13018
// enable ;
13017: ENABLE
// end ; end_of_file
13018: PPOPN 2
13020: END
// export Yashin , YashinAutak ; var Zacal , Nastupuje , Nastoupil , Odjizdi ; var Bunkr ; var YashinPovoleneZbrane ; export function init_yashin ; begin
13021: LD_INT 0
13023: PPUSH
// disable ( 51 ) ;
13024: LD_INT 51
13026: DISABLE_MARKED
// disable ( 52 ) ;
13027: LD_INT 52
13029: DISABLE_MARKED
// disable ( 53 ) ;
13030: LD_INT 53
13032: DISABLE_MARKED
// disable ( 54 ) ;
13033: LD_INT 54
13035: DISABLE_MARKED
// disable ( 55 ) ;
13036: LD_INT 55
13038: DISABLE_MARKED
// disable ( 56 ) ;
13039: LD_INT 56
13041: DISABLE_MARKED
// disable ( 57 ) ;
13042: LD_INT 57
13044: DISABLE_MARKED
// Yashin = 0 ;
13045: LD_ADDR_EXP 34
13049: PUSH
13050: LD_INT 0
13052: ST_TO_ADDR
// YashinAutak = 0 ;
13053: LD_ADDR_EXP 35
13057: PUSH
13058: LD_INT 0
13060: ST_TO_ADDR
// Zacal = false ;
13061: LD_ADDR_LOC 31
13065: PUSH
13066: LD_INT 0
13068: ST_TO_ADDR
// Nastupuje = false ;
13069: LD_ADDR_LOC 32
13073: PUSH
13074: LD_INT 0
13076: ST_TO_ADDR
// Nastoupil = false ;
13077: LD_ADDR_LOC 33
13081: PUSH
13082: LD_INT 0
13084: ST_TO_ADDR
// Odjizdi = false ;
13085: LD_ADDR_LOC 34
13089: PUSH
13090: LD_INT 0
13092: ST_TO_ADDR
// Bunkr = 0 ;
13093: LD_ADDR_LOC 35
13097: PUSH
13098: LD_INT 0
13100: ST_TO_ADDR
// YashinPovoleneZbrane = [ RU_HEAVY_MACHINE_GUN , RU_GATLING_GUN , RU_GUN , RU_ROCKET_LAUNCHER , RU_HEAVY_GUN , RU_ROCKET ] ;
13101: LD_ADDR_LOC 36
13105: PUSH
13106: LD_INT 42
13108: PUSH
13109: LD_INT 43
13111: PUSH
13112: LD_INT 44
13114: PUSH
13115: LD_INT 45
13117: PUSH
13118: LD_INT 46
13120: PUSH
13121: LD_INT 47
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: ST_TO_ADDR
// end ;
13132: LD_VAR 0 1
13136: RET
// export function yashin_start_timer ; begin
13137: LD_INT 0
13139: PPUSH
// if not Zacal then
13140: LD_LOC 31
13144: NOT
13145: IFFALSE 13158
// begin enable ( 51 ) ;
13147: LD_INT 51
13149: ENABLE_MARKED
// Zacal = true ;
13150: LD_ADDR_LOC 31
13154: PUSH
13155: LD_INT 1
13157: ST_TO_ADDR
// end ; end ;
13158: LD_VAR 0 1
13162: RET
// function vytvor_yashina ; begin
13163: LD_INT 0
13165: PPUSH
// Yashin = NewCharacter ( Yashin ) ;
13166: LD_ADDR_EXP 34
13170: PUSH
13171: LD_STRING Yashin
13173: PPUSH
13174: CALL_OW 25
13178: ST_TO_ADDR
// SetClass ( Yashin , CLASS_BAZOOKER ) ;
13179: LD_EXP 34
13183: PPUSH
13184: LD_INT 9
13186: PPUSH
13187: CALL_OW 336
// SetSide ( Yashin , side_Ru2 ) ;
13191: LD_EXP 34
13195: PPUSH
13196: LD_EXP 3
13200: PPUSH
13201: CALL_OW 235
// DoNotAttack ( side_Ar , Yashin ) ;
13205: LD_EXP 4
13209: PPUSH
13210: LD_EXP 34
13214: PPUSH
13215: CALL_OW 471
// end ;
13219: LD_VAR 0 1
13223: RET
// function yashin_start ; var Vysledek , Area , Bunkry ; begin
13224: LD_INT 0
13226: PPUSH
13227: PPUSH
13228: PPUSH
13229: PPUSH
// vytvor_yashina ;
13230: CALL 13163 0 0
// if VsevSaved then
13234: LD_EXP 8
13238: IFFALSE 13265
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13240: LD_EXP 34
13244: PPUSH
13245: LD_INT 39
13247: PPUSH
13248: LD_INT 0
13250: PPUSH
13251: CALL_OW 49
// Area = YashinCil1 ;
13255: LD_ADDR_VAR 0 3
13259: PUSH
13260: LD_INT 31
13262: ST_TO_ADDR
// end else
13263: GO 13288
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13265: LD_EXP 34
13269: PPUSH
13270: LD_INT 39
13272: PPUSH
13273: LD_INT 0
13275: PPUSH
13276: CALL_OW 49
// Area = YashinCil1a ;
13280: LD_ADDR_VAR 0 3
13284: PUSH
13285: LD_INT 32
13287: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Area ) then
13288: LD_EXP 10
13292: PPUSH
13293: LD_VAR 0 3
13297: PPUSH
13298: CALL_OW 308
13302: IFFALSE 13335
// ComMoveXY ( Yashin , GetX ( Burlak ) , GetY ( Burlak ) ) else
13304: LD_EXP 34
13308: PPUSH
13309: LD_EXP 10
13313: PPUSH
13314: CALL_OW 250
13318: PPUSH
13319: LD_EXP 10
13323: PPUSH
13324: CALL_OW 251
13328: PPUSH
13329: CALL_OW 111
13333: GO 13349
// ComMoveToArea ( Yashin , Area ) ;
13335: LD_EXP 34
13339: PPUSH
13340: LD_VAR 0 3
13344: PPUSH
13345: CALL_OW 113
// CenterOnUnits ( Yashin ) ;
13349: LD_EXP 34
13353: PPUSH
13354: CALL_OW 85
// Wait ( 0 0$4 ) ;
13358: LD_INT 140
13360: PPUSH
13361: CALL_OW 67
// DialogueOn ;
13365: CALL_OW 6
// dialog_YashinArrives ;
13369: CALL 22078 0 0
// Bunkry = yashin_zjisti_bunkry ;
13373: LD_ADDR_VAR 0 4
13377: PUSH
13378: CALL 14276 0 0
13382: ST_TO_ADDR
// if Bunkry then
13383: LD_VAR 0 4
13387: IFFALSE 13401
// Vysledek = query_YashinHelp else
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: CALL 22304 0 0
13398: ST_TO_ADDR
13399: GO 13411
// Vysledek = query_YashinHelpNB ;
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: CALL 22325 0 0
13410: ST_TO_ADDR
// if Vysledek = 1 then
13411: LD_VAR 0 2
13415: PUSH
13416: LD_INT 1
13418: EQUAL
13419: IFFALSE 13464
// begin dialog_QrYashinHelp1 ;
13421: CALL 22356 0 0
// DialogueOff ;
13425: CALL_OW 7
// Bunkr = Bunkry [ Rand ( 1 , Bunkry ) ] ;
13429: LD_ADDR_LOC 35
13433: PUSH
13434: LD_VAR 0 4
13438: PUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_VAR 0 4
13446: PPUSH
13447: CALL_OW 12
13451: ARRAY
13452: ST_TO_ADDR
// yashin_znic_bunkr ( Area ) ;
13453: LD_VAR 0 3
13457: PPUSH
13458: CALL 14407 0 1
// end else
13462: GO 13496
// begin if Vysledek = 2 then
13464: LD_VAR 0 2
13468: PUSH
13469: LD_INT 2
13471: EQUAL
13472: IFFALSE 13480
// dialog_QrYashinHelp2 else
13474: CALL 22412 0 0
13478: GO 13484
// dialog_QrYashinHelp3 ;
13480: CALL 22444 0 0
// dialog_YashinLeave ;
13484: CALL 22476 0 0
// DialogueOff ;
13488: CALL_OW 7
// yashin_vyzadej_autak ;
13492: CALL 14126 0 0
// end ; enable ( 53 ) ;
13496: LD_INT 53
13498: ENABLE_MARKED
// enable ( 57 ) ;
13499: LD_INT 57
13501: ENABLE_MARKED
// end ;
13502: LD_VAR 0 1
13506: RET
// function yashin_chci_autak ; var I , Temp , Kde , Volne , Dalka , Ridic ; begin
13507: LD_INT 0
13509: PPUSH
13510: PPUSH
13511: PPUSH
13512: PPUSH
13513: PPUSH
13514: PPUSH
13515: PPUSH
// if YashinAutak then
13516: LD_EXP 35
13520: IFFALSE 13672
// begin if not IsOK ( YashinAutak ) or ( GetSide ( YashinAutak ) <> side_Ru2 ) then
13522: LD_EXP 35
13526: PPUSH
13527: CALL_OW 302
13531: NOT
13532: PUSH
13533: LD_EXP 35
13537: PPUSH
13538: CALL_OW 255
13542: PUSH
13543: LD_EXP 3
13547: NONEQUAL
13548: OR
13549: IFFALSE 13561
// begin YashinAutak = 0 ;
13551: LD_ADDR_EXP 35
13555: PUSH
13556: LD_INT 0
13558: ST_TO_ADDR
// end else
13559: GO 13672
// begin Ridic = IsDrivenBy ( YashinAutak ) ;
13561: LD_ADDR_VAR 0 7
13565: PUSH
13566: LD_EXP 35
13570: PPUSH
13571: CALL_OW 311
13575: ST_TO_ADDR
// if Ridic = Yashin then
13576: LD_VAR 0 7
13580: PUSH
13581: LD_EXP 34
13585: EQUAL
13586: IFFALSE 13621
// begin Nastupuje = false ;
13588: LD_ADDR_LOC 32
13592: PUSH
13593: LD_INT 0
13595: ST_TO_ADDR
// Nastoupil = true ;
13596: LD_ADDR_LOC 33
13600: PUSH
13601: LD_INT 1
13603: ST_TO_ADDR
// disable ( 55 ) ;
13604: LD_INT 55
13606: DISABLE_MARKED
// yashin_zacni_odjizdet ;
13607: CALL 14164 0 0
// Result = true ;
13611: LD_ADDR_VAR 0 1
13615: PUSH
13616: LD_INT 1
13618: ST_TO_ADDR
// exit ;
13619: GO 14121
// end ; if Ridic then
13621: LD_VAR 0 7
13625: IFFALSE 13646
// begin ComCancel ( Yashin ) ;
13627: LD_EXP 34
13631: PPUSH
13632: CALL_OW 127
// YashinAutak = 0 ;
13636: LD_ADDR_EXP 35
13640: PUSH
13641: LD_INT 0
13643: ST_TO_ADDR
// end else
13644: GO 13672
// begin if not HasTask ( Yashin ) then
13646: LD_EXP 34
13650: PPUSH
13651: CALL_OW 314
13655: NOT
13656: IFFALSE 13672
// ComEnterUnit ( Yashin , YashinAutak ) ;
13658: LD_EXP 34
13662: PPUSH
13663: LD_EXP 35
13667: PPUSH
13668: CALL_OW 120
// end ; end ; end ; Kde = IsInUnit ( Yashin ) ;
13672: LD_ADDR_VAR 0 4
13676: PUSH
13677: LD_EXP 34
13681: PPUSH
13682: CALL_OW 310
13686: ST_TO_ADDR
// if ( Kde <> 0 ) then
13687: LD_VAR 0 4
13691: PUSH
13692: LD_INT 0
13694: NONEQUAL
13695: IFFALSE 13786
// begin if GetType ( Kde ) = UNIT_VEHICLE then
13697: LD_VAR 0 4
13701: PPUSH
13702: CALL_OW 247
13706: PUSH
13707: LD_INT 2
13709: EQUAL
13710: IFFALSE 13755
// begin Nastupuje = false ;
13712: LD_ADDR_LOC 32
13716: PUSH
13717: LD_INT 0
13719: ST_TO_ADDR
// Nastoupil = true ;
13720: LD_ADDR_LOC 33
13724: PUSH
13725: LD_INT 1
13727: ST_TO_ADDR
// disable ( 55 ) ;
13728: LD_INT 55
13730: DISABLE_MARKED
// YashinAutak = Kde ;
13731: LD_ADDR_EXP 35
13735: PUSH
13736: LD_VAR 0 4
13740: ST_TO_ADDR
// yashin_zacni_odjizdet ;
13741: CALL 14164 0 0
// Result = true ;
13745: LD_ADDR_VAR 0 1
13749: PUSH
13750: LD_INT 1
13752: ST_TO_ADDR
// exit ;
13753: GO 14121
// end ; if GetType ( Kde ) = UNIT_BUILDING then
13755: LD_VAR 0 4
13759: PPUSH
13760: CALL_OW 247
13764: PUSH
13765: LD_INT 3
13767: EQUAL
13768: IFFALSE 13786
// begin ComExitBuilding ( Yashin ) ;
13770: LD_EXP 34
13774: PPUSH
13775: CALL_OW 122
// Wait ( 0 0$0.25 ) ;
13779: LD_INT 9
13781: PPUSH
13782: CALL_OW 67
// end ; end ; Result = false ;
13786: LD_ADDR_VAR 0 1
13790: PUSH
13791: LD_INT 0
13793: ST_TO_ADDR
// if HasTask ( Yashin ) then
13794: LD_EXP 34
13798: PPUSH
13799: CALL_OW 314
13803: IFFALSE 13807
// exit ;
13805: GO 14121
// Volne = [ ] ;
13807: LD_ADDR_VAR 0 5
13811: PUSH
13812: EMPTY
13813: ST_TO_ADDR
// Temp = FilterUnitsExceptArea ( Nebezpeci , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
13814: LD_ADDR_VAR 0 3
13818: PUSH
13819: LD_INT 34
13821: PPUSH
13822: LD_INT 22
13824: PUSH
13825: LD_EXP 2
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PUSH
13834: LD_INT 21
13836: PUSH
13837: LD_INT 2
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: PUSH
13844: LD_INT 50
13846: PUSH
13847: EMPTY
13848: LIST
13849: PUSH
13850: LD_INT 33
13852: PUSH
13853: LD_INT 1
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: PPUSH
13866: CALL_OW 71
13870: ST_TO_ADDR
// for I in Temp do
13871: LD_ADDR_VAR 0 2
13875: PUSH
13876: LD_VAR 0 3
13880: PUSH
13881: FOR_IN
13882: IFFALSE 13970
// begin if IsDrivenBy ( I ) then
13884: LD_VAR 0 2
13888: PPUSH
13889: CALL_OW 311
13893: IFFALSE 13897
// continue ;
13895: GO 13881
// if ( GetEngine ( I ) = ENGINE_COMBUSTION ) and ( GetFuel ( I ) < 50 ) then
13897: LD_VAR 0 2
13901: PPUSH
13902: CALL_OW 262
13906: PUSH
13907: LD_INT 1
13909: EQUAL
13910: PUSH
13911: LD_VAR 0 2
13915: PPUSH
13916: CALL_OW 261
13920: PUSH
13921: LD_INT 50
13923: LESS
13924: AND
13925: IFFALSE 13929
// continue ;
13927: GO 13881
// if not GetWeapon ( I ) in YashinPovoleneZbrane then
13929: LD_VAR 0 2
13933: PPUSH
13934: CALL_OW 264
13938: PUSH
13939: LD_LOC 36
13943: IN
13944: NOT
13945: IFFALSE 13949
// continue ;
13947: GO 13881
// Volne = Volne union [ I ] ;
13949: LD_ADDR_VAR 0 5
13953: PUSH
13954: LD_VAR 0 5
13958: PUSH
13959: LD_VAR 0 2
13963: PUSH
13964: EMPTY
13965: LIST
13966: UNION
13967: ST_TO_ADDR
// end ;
13968: GO 13881
13970: POP
13971: POP
// if not Volne then
13972: LD_VAR 0 5
13976: NOT
13977: IFFALSE 13981
// exit ;
13979: GO 14121
// YashinAutak = Volne [ 1 ] ;
13981: LD_ADDR_EXP 35
13985: PUSH
13986: LD_VAR 0 5
13990: PUSH
13991: LD_INT 1
13993: ARRAY
13994: ST_TO_ADDR
// Dalka = GetDistUnits ( Yashin , YashinAutak ) ;
13995: LD_ADDR_VAR 0 6
13999: PUSH
14000: LD_EXP 34
14004: PPUSH
14005: LD_EXP 35
14009: PPUSH
14010: CALL_OW 296
14014: ST_TO_ADDR
// for I in ( Volne diff [ YashinAutak ] ) do
14015: LD_ADDR_VAR 0 2
14019: PUSH
14020: LD_VAR 0 5
14024: PUSH
14025: LD_EXP 35
14029: PUSH
14030: EMPTY
14031: LIST
14032: DIFF
14033: PUSH
14034: FOR_IN
14035: IFFALSE 14091
// begin Temp = GetDistUnits ( Yashin , I ) ;
14037: LD_ADDR_VAR 0 3
14041: PUSH
14042: LD_EXP 34
14046: PPUSH
14047: LD_VAR 0 2
14051: PPUSH
14052: CALL_OW 296
14056: ST_TO_ADDR
// if Temp < Dalka then
14057: LD_VAR 0 3
14061: PUSH
14062: LD_VAR 0 6
14066: LESS
14067: IFFALSE 14089
// begin Dalka = Temp ;
14069: LD_ADDR_VAR 0 6
14073: PUSH
14074: LD_VAR 0 3
14078: ST_TO_ADDR
// YashinAutak = I ;
14079: LD_ADDR_EXP 35
14083: PUSH
14084: LD_VAR 0 2
14088: ST_TO_ADDR
// end ; end ;
14089: GO 14034
14091: POP
14092: POP
// ComEnterUnit ( Yashin , YashinAutak ) ;
14093: LD_EXP 34
14097: PPUSH
14098: LD_EXP 35
14102: PPUSH
14103: CALL_OW 120
// SetSide ( YashinAutak , side_Ru2 ) ;
14107: LD_EXP 35
14111: PPUSH
14112: LD_EXP 3
14116: PPUSH
14117: CALL_OW 235
// end ;
14121: LD_VAR 0 1
14125: RET
// function yashin_vyzadej_autak ; begin
14126: LD_INT 0
14128: PPUSH
// Nastupuje = true ;
14129: LD_ADDR_LOC 32
14133: PUSH
14134: LD_INT 1
14136: ST_TO_ADDR
// ComCancel ( Yashin ) ;
14137: LD_EXP 34
14141: PPUSH
14142: CALL_OW 127
// if not yashin_chci_autak then
14146: CALL 13507 0 0
14150: NOT
14151: IFFALSE 14159
// begin enable ( 54 ) ;
14153: LD_INT 54
14155: ENABLE_MARKED
// enable ( 55 ) ;
14156: LD_INT 55
14158: ENABLE_MARKED
// end ; end ;
14159: LD_VAR 0 1
14163: RET
// function yashin_zacni_odjizdet ; begin
14164: LD_INT 0
14166: PPUSH
// Odjizdi = true ;
14167: LD_ADDR_LOC 34
14171: PUSH
14172: LD_INT 1
14174: ST_TO_ADDR
// disable ( 54 ) ;
14175: LD_INT 54
14177: DISABLE_MARKED
// disable ( 55 ) ;
14178: LD_INT 55
14180: DISABLE_MARKED
// disable ( 56 ) ;
14181: LD_INT 56
14183: DISABLE_MARKED
// if not yashin_odjizdi then
14184: CALL 14199 0 0
14188: NOT
14189: IFFALSE 14194
// enable ( 52 ) ;
14191: LD_INT 52
14193: ENABLE_MARKED
// end ;
14194: LD_VAR 0 1
14198: RET
// function yashin_odjizdi ; var Jednotka ; begin
14199: LD_INT 0
14201: PPUSH
14202: PPUSH
// if YashinAutak then
14203: LD_EXP 35
14207: IFFALSE 14221
// Jednotka = YashinAutak else
14209: LD_ADDR_VAR 0 2
14213: PUSH
14214: LD_EXP 35
14218: ST_TO_ADDR
14219: GO 14231
// Jednotka = Yashin ;
14221: LD_ADDR_VAR 0 2
14225: PUSH
14226: LD_EXP 34
14230: ST_TO_ADDR
// if IsInArea ( Jednotka , YashinExit ) then
14231: LD_VAR 0 2
14235: PPUSH
14236: LD_INT 33
14238: PPUSH
14239: CALL_OW 308
14243: IFFALSE 14259
// begin yashin_odstran ;
14245: CALL 15016 0 0
// Result = true ;
14249: LD_ADDR_VAR 0 1
14253: PUSH
14254: LD_INT 1
14256: ST_TO_ADDR
// end else
14257: GO 14271
// begin ComMoveToArea ( Jednotka , YashinExit ) ;
14259: LD_VAR 0 2
14263: PPUSH
14264: LD_INT 33
14266: PPUSH
14267: CALL_OW 113
// end ; end ;
14271: LD_VAR 0 1
14275: RET
// function yashin_zjisti_bunkry ; var Domy ; begin
14276: LD_INT 0
14278: PPUSH
14279: PPUSH
// Domy = FilterUnitsInArea ( AraboveBunkry , [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
14280: LD_ADDR_VAR 0 2
14284: PUSH
14285: LD_INT 35
14287: PPUSH
14288: LD_INT 22
14290: PUSH
14291: LD_EXP 4
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: LD_INT 50
14302: PUSH
14303: EMPTY
14304: LIST
14305: PUSH
14306: LD_INT 21
14308: PUSH
14309: LD_INT 3
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: PPUSH
14321: CALL_OW 70
14325: ST_TO_ADDR
// Result = UnitFilter ( Domy , [ [ F_BTYPE , B_BREASTWORK ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_BUNKER ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_TURRET ] ] ) ;
14326: LD_ADDR_VAR 0 1
14330: PUSH
14331: LD_VAR 0 2
14335: PPUSH
14336: LD_INT 30
14338: PUSH
14339: LD_INT 31
14341: PUSH
14342: EMPTY
14343: LIST
14344: LIST
14345: PUSH
14346: EMPTY
14347: LIST
14348: PPUSH
14349: CALL_OW 72
14353: PUSH
14354: LD_VAR 0 2
14358: PPUSH
14359: LD_INT 30
14361: PUSH
14362: LD_INT 32
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: PUSH
14369: EMPTY
14370: LIST
14371: PPUSH
14372: CALL_OW 72
14376: UNION
14377: PUSH
14378: LD_VAR 0 2
14382: PPUSH
14383: LD_INT 30
14385: PUSH
14386: LD_INT 33
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: EMPTY
14394: LIST
14395: PPUSH
14396: CALL_OW 72
14400: UNION
14401: ST_TO_ADDR
// end ;
14402: LD_VAR 0 1
14406: RET
// function yashin_znic_bunkr ( Zpatky ) ; begin
14407: LD_INT 0
14409: PPUSH
// ComAgressiveMove ( Yashin , 32 , 29 ) ;
14410: LD_EXP 34
14414: PPUSH
14415: LD_INT 32
14417: PPUSH
14418: LD_INT 29
14420: PPUSH
14421: CALL_OW 114
// AddComSailEvent ( Yashin , 111 ) ;
14425: LD_EXP 34
14429: PPUSH
14430: LD_INT 111
14432: PPUSH
14433: CALL_OW 224
// AddComAttackUnit ( Yashin , Bunkr ) ;
14437: LD_EXP 34
14441: PPUSH
14442: LD_LOC 35
14446: PPUSH
14447: CALL_OW 175
// AddComAgressiveMove ( Yashin , 33 , 35 ) ;
14451: LD_EXP 34
14455: PPUSH
14456: LD_INT 33
14458: PPUSH
14459: LD_INT 35
14461: PPUSH
14462: CALL_OW 174
// AddComMoveToArea ( Yashin , Zpatky ) ;
14466: LD_EXP 34
14470: PPUSH
14471: LD_VAR 0 1
14475: PPUSH
14476: CALL_OW 173
// enable ( 56 ) ;
14480: LD_INT 56
14482: ENABLE_MARKED
// end ;
14483: LD_VAR 0 2
14487: RET
// export function event_YashinUtoci ; begin
14488: LD_INT 0
14490: PPUSH
// RevealFogArea ( side_Ru , AraboveBunkry ) ;
14491: LD_EXP 2
14495: PPUSH
14496: LD_INT 35
14498: PPUSH
14499: CALL_OW 332
// end ;
14503: LD_VAR 0 1
14507: RET
// export function yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14508: LD_INT 0
14510: PPUSH
// if Nastupuje and ( VehOld = YashinAutak ) then
14511: LD_LOC 32
14515: PUSH
14516: LD_VAR 0 2
14520: PUSH
14521: LD_EXP 35
14525: EQUAL
14526: AND
14527: IFFALSE 14539
// YashinAutak = VehNew ;
14529: LD_ADDR_EXP 35
14533: PUSH
14534: LD_VAR 0 1
14538: ST_TO_ADDR
// end ;
14539: LD_VAR 0 5
14543: RET
// every 0 0$1.3 marked 52 do
14544: GO 14546
14546: DISABLE
// begin if not yashin_odjizdi then
14547: CALL 14199 0 0
14551: NOT
14552: IFFALSE 14555
// enable ;
14554: ENABLE
// end ;
14555: END
// every 0 0$2.7 marked 54 do
14556: GO 14558
14558: DISABLE
// begin if not yashin_chci_autak then
14559: CALL 13507 0 0
14563: NOT
14564: IFFALSE 14567
// enable ;
14566: ENABLE
// end ;
14567: END
// every 5 5$3 marked 55 do
14568: GO 14570
14570: DISABLE
// begin if Nastoupil then
14571: LD_LOC 33
14575: IFFALSE 14579
// exit ;
14577: GO 14601
// DialogueOn ;
14579: CALL_OW 6
// CenterOnUnits ( Yashin ) ;
14583: LD_EXP 34
14587: PPUSH
14588: CALL_OW 85
// dialog_YashinLeave ;
14592: CALL 22476 0 0
// DialogueOff ;
14596: CALL_OW 7
// enable ;
14600: ENABLE
// end ;
14601: END
// every 0 0$7.1 trigger ( not IsOK ( Bunkr ) ) or ( GetSide ( Bunkr ) <> side_Ar ) marked 56 do
14602: LD_LOC 35
14606: PPUSH
14607: CALL_OW 302
14611: NOT
14612: PUSH
14613: LD_LOC 35
14617: PPUSH
14618: CALL_OW 255
14622: PUSH
14623: LD_EXP 4
14627: NONEQUAL
14628: OR
14629: IFFALSE 14662
14631: GO 14633
14633: DISABLE
// begin RevealFogArea ( side_Ru , AraboveBunkry ) ;
14634: LD_EXP 2
14638: PPUSH
14639: LD_INT 35
14641: PPUSH
14642: CALL_OW 332
// DialogueOn ;
14646: CALL_OW 6
// dialog_YashinLeave ;
14650: CALL 22476 0 0
// dialogueOff ;
14654: CALL_OW 7
// yashin_vyzadej_autak ;
14658: CALL 14126 0 0
// end ;
14662: END
// every 2 2$55 marked 51 do
14663: GO 14665
14665: DISABLE
// begin Wait ( MultiRand ( 0 0$1 , 2 2$0 , 2 ) ) ;
14666: LD_INT 35
14668: PPUSH
14669: LD_INT 4200
14671: PPUSH
14672: LD_INT 2
14674: PPUSH
14675: CALL_OW 14
14679: PPUSH
14680: CALL_OW 67
// yashin_start ;
14684: CALL 13224 0 0
// end ;
14688: END
// every 0 0$0.7 marked 53 do var Jednotky , Kdo , Cile , Utoci ;
14689: GO 14691
14691: DISABLE
14692: LD_INT 0
14694: PPUSH
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin Kdo = IsInUnit ( Yashin ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_EXP 34
14707: PPUSH
14708: CALL_OW 310
14712: ST_TO_ADDR
// if Kdo then
14713: LD_VAR 0 2
14717: IFFALSE 14740
// Cile = [ Yashin , Kdo ] else
14719: LD_ADDR_VAR 0 3
14723: PUSH
14724: LD_EXP 34
14728: PUSH
14729: LD_VAR 0 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: ST_TO_ADDR
14738: GO 14753
// Cile = [ Yashin ] ;
14740: LD_ADDR_VAR 0 3
14744: PUSH
14745: LD_EXP 34
14749: PUSH
14750: EMPTY
14751: LIST
14752: ST_TO_ADDR
// Utoci = false ;
14753: LD_ADDR_VAR 0 4
14757: PUSH
14758: LD_INT 0
14760: ST_TO_ADDR
// Jednotky = FilterAllUnits ( [ [ F_OK ] , [ F_SIDE , side_Ru ] ] ) ;
14761: LD_ADDR_VAR 0 1
14765: PUSH
14766: LD_INT 50
14768: PUSH
14769: EMPTY
14770: LIST
14771: PUSH
14772: LD_INT 22
14774: PUSH
14775: LD_EXP 2
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 69
14792: ST_TO_ADDR
// for Kdo in Jednotky do
14793: LD_ADDR_VAR 0 2
14797: PUSH
14798: LD_VAR 0 1
14802: PUSH
14803: FOR_IN
14804: IFFALSE 14868
// begin if ( WantsToAttack ( Kdo ) in Cile ) or ( Attacks ( Kdo ) in Cile ) then
14806: LD_VAR 0 2
14810: PPUSH
14811: CALL_OW 319
14815: PUSH
14816: LD_VAR 0 3
14820: IN
14821: PUSH
14822: LD_VAR 0 2
14826: PPUSH
14827: CALL_OW 320
14831: PUSH
14832: LD_VAR 0 3
14836: IN
14837: OR
14838: IFFALSE 14866
// begin ComCancel ( Kdo ) ;
14840: LD_VAR 0 2
14844: PPUSH
14845: CALL_OW 127
// ComHold ( Kdo ) ;
14849: LD_VAR 0 2
14853: PPUSH
14854: CALL_OW 140
// Utoci = true ;
14858: LD_ADDR_VAR 0 4
14862: PUSH
14863: LD_INT 1
14865: ST_TO_ADDR
// end ; end ;
14866: GO 14803
14868: POP
14869: POP
// if Utoci then
14870: LD_VAR 0 4
14874: IFFALSE 14899
// begin DialogueOn ;
14876: CALL_OW 6
// dialog_YashinAttack ;
14880: CALL 22530 0 0
// DialogueOff ;
14884: CALL_OW 7
// if not Odjizdi then
14888: LD_LOC 34
14892: NOT
14893: IFFALSE 14899
// yashin_zacni_odjizdet ;
14895: CALL 14164 0 0
// end ; enable ;
14899: ENABLE
// end ;
14900: PPOPN 4
14902: END
// every 0 0$0.6 marked 57 do var L ;
14903: GO 14905
14905: DISABLE
14906: LD_INT 0
14908: PPUSH
// begin L = GetLives ( Yashin ) ;
14909: LD_ADDR_VAR 0 1
14913: PUSH
14914: LD_EXP 34
14918: PPUSH
14919: CALL_OW 256
14923: ST_TO_ADDR
// if L < 1000 then
14924: LD_VAR 0 1
14928: PUSH
14929: LD_INT 1000
14931: LESS
14932: IFFALSE 14980
// begin L = L + 20 ;
14934: LD_ADDR_VAR 0 1
14938: PUSH
14939: LD_VAR 0 1
14943: PUSH
14944: LD_INT 20
14946: PLUS
14947: ST_TO_ADDR
// if L > 1000 then
14948: LD_VAR 0 1
14952: PUSH
14953: LD_INT 1000
14955: GREATER
14956: IFFALSE 14966
// L = 1000 ;
14958: LD_ADDR_VAR 0 1
14962: PUSH
14963: LD_INT 1000
14965: ST_TO_ADDR
// SetLives ( Yashin , L ) ;
14966: LD_EXP 34
14970: PPUSH
14971: LD_VAR 0 1
14975: PPUSH
14976: CALL_OW 234
// end ; enable ;
14980: ENABLE
// end ;
14981: PPOPN 1
14983: END
// export function yashin_UnitGoesToRed ( Un ) ; begin
14984: LD_INT 0
14986: PPUSH
// if Un = Yashin then
14987: LD_VAR 0 1
14991: PUSH
14992: LD_EXP 34
14996: EQUAL
14997: IFFALSE 15011
// SetLives ( Yashin , 300 ) ;
14999: LD_EXP 34
15003: PPUSH
15004: LD_INT 300
15006: PPUSH
15007: CALL_OW 234
// end ;
15011: LD_VAR 0 2
15015: RET
// function yashin_odstran ; begin
15016: LD_INT 0
15018: PPUSH
// if YashinAutak then
15019: LD_EXP 35
15023: IFFALSE 15034
// RemoveUnit ( YashinAutak ) ;
15025: LD_EXP 35
15029: PPUSH
15030: CALL_OW 64
// RemoveUnit ( Yashin ) ;
15034: LD_EXP 34
15038: PPUSH
15039: CALL_OW 64
// disable ( 53 ) ;
15043: LD_INT 53
15045: DISABLE_MARKED
// end ; end_of_file
15046: LD_VAR 0 1
15050: RET
// var KamArea , VraciSe ; var Krade , Nastupuje , KradenyVuz ; export function init_xavier ; begin
15051: LD_INT 0
15053: PPUSH
// KamArea = 0 ;
15054: LD_ADDR_LOC 37
15058: PUSH
15059: LD_INT 0
15061: ST_TO_ADDR
// VraciSe = false ;
15062: LD_ADDR_LOC 38
15066: PUSH
15067: LD_INT 0
15069: ST_TO_ADDR
// Krade = false ;
15070: LD_ADDR_LOC 39
15074: PUSH
15075: LD_INT 0
15077: ST_TO_ADDR
// KradenyVuz = 0 ;
15078: LD_ADDR_LOC 41
15082: PUSH
15083: LD_INT 0
15085: ST_TO_ADDR
// disable ( 21 ) ;
15086: LD_INT 21
15088: DISABLE_MARKED
// disable ( 22 ) ;
15089: LD_INT 22
15091: DISABLE_MARKED
// disable ( 23 ) ;
15092: LD_INT 23
15094: DISABLE_MARKED
// disable ( 24 ) ;
15095: LD_INT 24
15097: DISABLE_MARKED
// disable ( 26 ) ;
15098: LD_INT 26
15100: DISABLE_MARKED
// end ;
15101: LD_VAR 0 1
15105: RET
// function vytvor_xaviera ; begin
15106: LD_INT 0
15108: PPUSH
// Xavier = NewCharacter ( Xavier ) ;
15109: LD_ADDR_EXP 25
15113: PUSH
15114: LD_STRING Xavier
15116: PPUSH
15117: CALL_OW 25
15121: ST_TO_ADDR
// SetSide ( Xavier , side_Xavier ) ;
15122: LD_EXP 25
15126: PPUSH
15127: LD_EXP 5
15131: PPUSH
15132: CALL_OW 235
// end ;
15136: LD_VAR 0 1
15140: RET
// export function xavier_start ; var Vysledek ; begin
15141: LD_INT 0
15143: PPUSH
15144: PPUSH
// vytvor_xaviera ;
15145: CALL 15106 0 0
// if not Yelena or not IsOk ( Yelena ) then
15149: LD_EXP 13
15153: NOT
15154: PUSH
15155: LD_EXP 13
15159: PPUSH
15160: CALL_OW 302
15164: NOT
15165: OR
15166: IFFALSE 15264
// begin SetSide ( Xavier , side_Ar ) ;
15168: LD_EXP 25
15172: PPUSH
15173: LD_EXP 4
15177: PPUSH
15178: CALL_OW 235
// PlaceUnitXYR ( Xavier , GetX ( Burlak ) , GetY ( Burlak ) , 6 , true ) ;
15182: LD_EXP 25
15186: PPUSH
15187: LD_EXP 10
15191: PPUSH
15192: CALL_OW 250
15196: PPUSH
15197: LD_EXP 10
15201: PPUSH
15202: CALL_OW 251
15206: PPUSH
15207: LD_INT 6
15209: PPUSH
15210: LD_INT 1
15212: PPUSH
15213: CALL_OW 50
// Wait ( 0 0$4 ) ;
15217: LD_INT 140
15219: PPUSH
15220: CALL_OW 67
// ComAttackUnit ( Xavier , Burlak ) ;
15224: LD_EXP 25
15228: PPUSH
15229: LD_EXP 10
15233: PPUSH
15234: CALL_OW 115
// if Difficulty = 3 then
15238: LD_OWVAR 67
15242: PUSH
15243: LD_INT 3
15245: EQUAL
15246: IFFALSE 15262
// PriorityAttack ( side_Ar , Burlak ) ;
15248: LD_EXP 4
15252: PPUSH
15253: LD_EXP 10
15257: PPUSH
15258: CALL_OW 470
// exit ;
15262: GO 15500
// end ; PlaceUnitXYR ( Xavier , GetX ( Yelena ) , GetY ( Yelena ) , 6 , true ) ;
15264: LD_EXP 25
15268: PPUSH
15269: LD_EXP 13
15273: PPUSH
15274: CALL_OW 250
15278: PPUSH
15279: LD_EXP 13
15283: PPUSH
15284: CALL_OW 251
15288: PPUSH
15289: LD_INT 6
15291: PPUSH
15292: LD_INT 1
15294: PPUSH
15295: CALL_OW 50
// ComHold ( Xavier ) ;
15299: LD_EXP 25
15303: PPUSH
15304: CALL_OW 140
// Wait ( 0 0$4 ) ;
15308: LD_INT 140
15310: PPUSH
15311: CALL_OW 67
// if not IsInUnit ( Yelena ) then
15315: LD_EXP 13
15319: PPUSH
15320: CALL_OW 310
15324: NOT
15325: IFFALSE 15341
// ComTurnUnit ( Yelena , Xavier ) ;
15327: LD_EXP 13
15331: PPUSH
15332: LD_EXP 25
15336: PPUSH
15337: CALL_OW 119
// ComTurnUnit ( Xavier , Yelena ) ;
15341: LD_EXP 25
15345: PPUSH
15346: LD_EXP 13
15350: PPUSH
15351: CALL_OW 119
// DialogueOn ;
15355: CALL_OW 6
// CenterOnUnits ( Yelena ) ;
15359: LD_EXP 13
15363: PPUSH
15364: CALL_OW 85
// dialog_MeetXavier ;
15368: CALL 21607 0 0
// Vysledek = query_Xavier ;
15372: LD_ADDR_VAR 0 2
15376: PUSH
15377: CALL 21651 0 0
15381: ST_TO_ADDR
// if Vysledek = 1 then
15382: LD_VAR 0 2
15386: PUSH
15387: LD_INT 1
15389: EQUAL
15390: IFFALSE 15416
// begin dialog_QrXavier1 ;
15392: CALL 21672 0 0
// SetSide ( Xavier , side_Ru ) ;
15396: LD_EXP 25
15400: PPUSH
15401: LD_EXP 2
15405: PPUSH
15406: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
15410: CALL 16776 0 0
// end else
15414: GO 15496
// begin dialog_QrXavier2 ;
15416: CALL 21805 0 0
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15420: LD_EXP 25
15424: PPUSH
15425: LD_INT 35
15427: PPUSH
15428: LD_INT 350
15430: PPUSH
15431: CALL_OW 12
15435: PPUSH
15436: CALL_OW 142
// if Prob ( 50 ) then
15440: LD_INT 50
15442: PPUSH
15443: CALL_OW 13
15447: IFFALSE 15481
// begin AddComMoveToArea ( Xavier , DropBox ) ;
15449: LD_EXP 25
15453: PPUSH
15454: LD_INT 11
15456: PPUSH
15457: CALL_OW 173
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$15 ) ) ;
15461: LD_EXP 25
15465: PPUSH
15466: LD_INT 175
15468: PPUSH
15469: LD_INT 525
15471: PPUSH
15472: CALL_OW 12
15476: PPUSH
15477: CALL_OW 202
// end ; AddComMoveToArea ( Xavier , AraboveParkoviste ) ;
15481: LD_EXP 25
15485: PPUSH
15486: LD_INT 18
15488: PPUSH
15489: CALL_OW 173
// enable ( 21 ) ;
15493: LD_INT 21
15495: ENABLE_MARKED
// end ; DialogueOff ;
15496: CALL_OW 7
// end ;
15500: LD_VAR 0 1
15504: RET
// function xavier_kolecko ; begin
15505: LD_INT 0
15507: PPUSH
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15508: LD_EXP 25
15512: PPUSH
15513: LD_INT 82
15515: PPUSH
15516: LD_INT 1
15518: PPUSH
15519: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15523: LD_EXP 25
15527: PPUSH
15528: LD_INT 35
15530: PPUSH
15531: LD_INT 175
15533: PPUSH
15534: CALL_OW 12
15538: PPUSH
15539: CALL_OW 202
// AddComMoveXY ( Xavier , 72 , 7 ) ;
15543: LD_EXP 25
15547: PPUSH
15548: LD_INT 72
15550: PPUSH
15551: LD_INT 7
15553: PPUSH
15554: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15558: LD_EXP 25
15562: PPUSH
15563: LD_INT 35
15565: PPUSH
15566: LD_INT 175
15568: PPUSH
15569: CALL_OW 12
15573: PPUSH
15574: CALL_OW 202
// AddComMoveXY ( Xavier , 76 , 17 ) ;
15578: LD_EXP 25
15582: PPUSH
15583: LD_INT 76
15585: PPUSH
15586: LD_INT 17
15588: PPUSH
15589: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15593: LD_EXP 25
15597: PPUSH
15598: LD_INT 35
15600: PPUSH
15601: LD_INT 175
15603: PPUSH
15604: CALL_OW 12
15608: PPUSH
15609: CALL_OW 202
// AddComMoveXY ( Xavier , 85 , 17 ) ;
15613: LD_EXP 25
15617: PPUSH
15618: LD_INT 85
15620: PPUSH
15621: LD_INT 17
15623: PPUSH
15624: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15628: LD_EXP 25
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: LD_INT 175
15638: PPUSH
15639: CALL_OW 12
15643: PPUSH
15644: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 14 ) ;
15648: LD_EXP 25
15652: PPUSH
15653: LD_INT 91
15655: PPUSH
15656: LD_INT 14
15658: PPUSH
15659: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$10 ) ) ;
15663: LD_EXP 25
15667: PPUSH
15668: LD_INT 175
15670: PPUSH
15671: LD_INT 350
15673: PPUSH
15674: CALL_OW 12
15678: PPUSH
15679: CALL_OW 202
// AddComMoveXY ( Xavier , 89 , 24 ) ;
15683: LD_EXP 25
15687: PPUSH
15688: LD_INT 89
15690: PPUSH
15691: LD_INT 24
15693: PPUSH
15694: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15698: LD_EXP 25
15702: PPUSH
15703: LD_INT 35
15705: PPUSH
15706: LD_INT 175
15708: PPUSH
15709: CALL_OW 12
15713: PPUSH
15714: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 21 ) ;
15718: LD_EXP 25
15722: PPUSH
15723: LD_INT 102
15725: PPUSH
15726: LD_INT 21
15728: PPUSH
15729: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15733: LD_EXP 25
15737: PPUSH
15738: LD_INT 35
15740: PPUSH
15741: LD_INT 175
15743: PPUSH
15744: CALL_OW 12
15748: PPUSH
15749: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 8 ) ;
15753: LD_EXP 25
15757: PPUSH
15758: LD_INT 102
15760: PPUSH
15761: LD_INT 8
15763: PPUSH
15764: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$0.1 , 0 0$2 ) ) ;
15768: LD_EXP 25
15772: PPUSH
15773: LD_INT 4
15775: PPUSH
15776: LD_INT 70
15778: PPUSH
15779: CALL_OW 12
15783: PPUSH
15784: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 5 ) ;
15788: LD_EXP 25
15792: PPUSH
15793: LD_INT 91
15795: PPUSH
15796: LD_INT 5
15798: PPUSH
15799: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15803: LD_EXP 25
15807: PPUSH
15808: LD_INT 35
15810: PPUSH
15811: LD_INT 175
15813: PPUSH
15814: CALL_OW 12
15818: PPUSH
15819: CALL_OW 202
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15823: LD_EXP 25
15827: PPUSH
15828: LD_INT 82
15830: PPUSH
15831: LD_INT 1
15833: PPUSH
15834: CALL_OW 171
// end ;
15838: LD_VAR 0 1
15842: RET
// function xavier_u_arabu ; begin
15843: LD_INT 0
15845: PPUSH
// xavier_kolecko ;
15846: CALL 15505 0 0
// enable ( 22 ) ;
15850: LD_INT 22
15852: ENABLE_MARKED
// end ;
15853: LD_VAR 0 1
15857: RET
// function xavier_timeout ; begin
15858: LD_INT 0
15860: PPUSH
// ComMoveToArea ( Xavier , DropBox ) ;
15861: LD_EXP 25
15865: PPUSH
15866: LD_INT 11
15868: PPUSH
15869: CALL_OW 113
// enable ( 23 ) ;
15873: LD_INT 23
15875: ENABLE_MARKED
// end ;
15876: LD_VAR 0 1
15880: RET
// function xavier_dropbox ; begin
15881: LD_INT 0
15883: PPUSH
// InGameOn ;
15884: CALL_OW 8
// CenterOnUnits ( Xavier ) ;
15888: LD_EXP 25
15892: PPUSH
15893: CALL_OW 85
// dialog_PointXavier ;
15897: CALL 21962 0 0
// SetAreaMapShow ( DropBoxShow , 1 ) ;
15901: LD_INT 42
15903: PPUSH
15904: LD_INT 1
15906: PPUSH
15907: CALL_OW 424
// Hint ( Xavier ) ;
15911: LD_STRING Xavier
15913: PPUSH
15914: CALL_OW 339
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15918: LD_EXP 25
15922: PPUSH
15923: LD_INT 35
15925: PPUSH
15926: LD_INT 350
15928: PPUSH
15929: CALL_OW 12
15933: PPUSH
15934: CALL_OW 142
// xavier_kolecko ;
15938: CALL 15505 0 0
// enable ( 24 ) ;
15942: LD_INT 24
15944: ENABLE_MARKED
// InGameOff ;
15945: CALL_OW 9
// end ;
15949: LD_VAR 0 1
15953: RET
// function xavier_zpatky ; var Depoty , Kdo ; begin
15954: LD_INT 0
15956: PPUSH
15957: PPUSH
15958: PPUSH
// Kdo = IsInUnit ( Xavier ) ;
15959: LD_ADDR_VAR 0 3
15963: PUSH
15964: LD_EXP 25
15968: PPUSH
15969: CALL_OW 310
15973: ST_TO_ADDR
// if not Kdo then
15974: LD_VAR 0 3
15978: NOT
15979: IFFALSE 15991
// Kdo = Xavier ;
15981: LD_ADDR_VAR 0 3
15985: PUSH
15986: LD_EXP 25
15990: ST_TO_ADDR
// ComAgressiveMove ( Kdo , 32 , 19 ) ;
15991: LD_VAR 0 3
15995: PPUSH
15996: LD_INT 32
15998: PPUSH
15999: LD_INT 19
16001: PPUSH
16002: CALL_OW 114
// if VsevSaved then
16006: LD_EXP 8
16010: IFFALSE 16022
// KamArea = YashinCil1 else
16012: LD_ADDR_LOC 37
16016: PUSH
16017: LD_INT 31
16019: ST_TO_ADDR
16020: GO 16030
// KamArea = YashinCil1a ;
16022: LD_ADDR_LOC 37
16026: PUSH
16027: LD_INT 32
16029: ST_TO_ADDR
// AddComMoveToArea ( Kdo , KamArea ) ;
16030: LD_VAR 0 3
16034: PPUSH
16035: LD_LOC 37
16039: PPUSH
16040: CALL_OW 173
// AddComSailEvent ( Kdo , 121 ) ;
16044: LD_VAR 0 3
16048: PPUSH
16049: LD_INT 121
16051: PPUSH
16052: CALL_OW 224
// VraciSe = true ;
16056: LD_ADDR_LOC 38
16060: PUSH
16061: LD_INT 1
16063: ST_TO_ADDR
// end ;
16064: LD_VAR 0 1
16068: RET
// function xavier_autak ; begin
16069: LD_INT 0
16071: PPUSH
// Krade = true ;
16072: LD_ADDR_LOC 39
16076: PUSH
16077: LD_INT 1
16079: ST_TO_ADDR
// Nastupuje = false ;
16080: LD_ADDR_LOC 40
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// enable ( 26 ) ;
16088: LD_INT 26
16090: ENABLE_MARKED
// end ;
16091: LD_VAR 0 1
16095: RET
// function xavier_zkus_krast ; var Volne , Ridic ; begin
16096: LD_INT 0
16098: PPUSH
16099: PPUSH
16100: PPUSH
// Volne = FilterUnitsInArea ( AraboveParkoviste , [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_OK ] ] ) ;
16101: LD_ADDR_VAR 0 2
16105: PUSH
16106: LD_INT 18
16108: PPUSH
16109: LD_INT 22
16111: PUSH
16112: LD_EXP 4
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: PUSH
16121: LD_INT 21
16123: PUSH
16124: LD_INT 2
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: PUSH
16131: LD_INT 33
16133: PUSH
16134: LD_INT 1
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: PUSH
16141: LD_INT 50
16143: PUSH
16144: EMPTY
16145: LIST
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: LIST
16151: LIST
16152: PPUSH
16153: CALL_OW 70
16157: ST_TO_ADDR
// Volne = Volne diff UnitFilter ( Volne , [ [ F_WEAPON , AR_CONTROL_TOWER ] ] ) ;
16158: LD_ADDR_VAR 0 2
16162: PUSH
16163: LD_VAR 0 2
16167: PUSH
16168: LD_VAR 0 2
16172: PPUSH
16173: LD_INT 34
16175: PUSH
16176: LD_INT 31
16178: PUSH
16179: EMPTY
16180: LIST
16181: LIST
16182: PUSH
16183: EMPTY
16184: LIST
16185: PPUSH
16186: CALL_OW 72
16190: DIFF
16191: ST_TO_ADDR
// if not Volne then
16192: LD_VAR 0 2
16196: NOT
16197: IFFALSE 16204
// begin enable ( 26 ) ;
16199: LD_INT 26
16201: ENABLE_MARKED
// exit ;
16202: GO 16413
// end ; Nastupuje = true ;
16204: LD_ADDR_LOC 40
16208: PUSH
16209: LD_INT 1
16211: ST_TO_ADDR
// KradenyVuz = Volne [ 1 ] ;
16212: LD_ADDR_LOC 41
16216: PUSH
16217: LD_VAR 0 2
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: ST_TO_ADDR
// Ridic = IsDrivenBy ( KradenyVuz ) ;
16226: LD_ADDR_VAR 0 3
16230: PUSH
16231: LD_LOC 41
16235: PPUSH
16236: CALL_OW 311
16240: ST_TO_ADDR
// if Ridic then
16241: LD_VAR 0 3
16245: IFFALSE 16268
// begin ComExitVehicle ( Ridic ) ;
16247: LD_VAR 0 3
16251: PPUSH
16252: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16256: LD_VAR 0 3
16260: PPUSH
16261: LD_INT 175
16263: PPUSH
16264: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16268: LD_EXP 25
16272: PPUSH
16273: LD_LOC 41
16277: PPUSH
16278: CALL_OW 120
// Wait ( 0 0$3.2 ) ;
16282: LD_INT 112
16284: PPUSH
16285: CALL_OW 67
// while Xavier <> IsDrivenBy ( KradenyVuz ) do
16289: LD_EXP 25
16293: PUSH
16294: LD_LOC 41
16298: PPUSH
16299: CALL_OW 311
16303: NONEQUAL
16304: IFFALSE 16385
// begin Ridic = IsDrivenBy ( KradenyVuz ) ;
16306: LD_ADDR_VAR 0 3
16310: PUSH
16311: LD_LOC 41
16315: PPUSH
16316: CALL_OW 311
16320: ST_TO_ADDR
// if Ridic = Xavier then
16321: LD_VAR 0 3
16325: PUSH
16326: LD_EXP 25
16330: EQUAL
16331: IFFALSE 16335
// break ;
16333: GO 16385
// if Ridic then
16335: LD_VAR 0 3
16339: IFFALSE 16362
// begin ComExitVehicle ( Ridic ) ;
16341: LD_VAR 0 3
16345: PPUSH
16346: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16350: LD_VAR 0 3
16354: PPUSH
16355: LD_INT 175
16357: PPUSH
16358: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16362: LD_EXP 25
16366: PPUSH
16367: LD_LOC 41
16371: PPUSH
16372: CALL_OW 120
// Wait ( 0 0$7.1 ) ;
16376: LD_INT 248
16378: PPUSH
16379: CALL_OW 67
// end ;
16383: GO 16289
// Krade = false ;
16385: LD_ADDR_LOC 39
16389: PUSH
16390: LD_INT 0
16392: ST_TO_ADDR
// Nastupuje = false ;
16393: LD_ADDR_LOC 40
16397: PUSH
16398: LD_INT 0
16400: ST_TO_ADDR
// xavier_zpatky ;
16401: CALL 15954 0 0
// KradenyVuz = 0 ;
16405: LD_ADDR_LOC 41
16409: PUSH
16410: LD_INT 0
16412: ST_TO_ADDR
// end ;
16413: LD_VAR 0 1
16417: RET
// every 0 0$11.7 marked 26 do
16418: GO 16420
16420: DISABLE
// begin xavier_zkus_krast ;
16421: CALL 16096 0 0
// end ;
16425: END
// function xavier_zprava ; var Vysledek ; begin
16426: LD_INT 0
16428: PPUSH
16429: PPUSH
// DialogueOn ;
16430: CALL_OW 6
// Vysledek = query_QActivateXavier ;
16434: LD_ADDR_VAR 0 2
16438: PUSH
16439: CALL 22017 0 0
16443: ST_TO_ADDR
// case Vysledek of 1 :
16444: LD_VAR 0 2
16448: PUSH
16449: LD_INT 1
16451: DOUBLE
16452: EQUAL
16453: IFTRUE 16457
16455: GO 16486
16457: POP
// begin dialog_QrActivateXavier1 ;
16458: CALL 22038 0 0
// xavier_zpatky ;
16462: CALL 15954 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16466: LD_INT 42
16468: PPUSH
16469: LD_INT 0
16471: PPUSH
16472: CALL_OW 424
// Result = true ;
16476: LD_ADDR_VAR 0 1
16480: PUSH
16481: LD_INT 1
16483: ST_TO_ADDR
// end ; 2 :
16484: GO 16532
16486: LD_INT 2
16488: DOUBLE
16489: EQUAL
16490: IFTRUE 16494
16492: GO 16523
16494: POP
// begin dialog_QrActivateXavier2 ;
16495: CALL 22058 0 0
// xavier_autak ;
16499: CALL 16069 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16503: LD_INT 42
16505: PPUSH
16506: LD_INT 0
16508: PPUSH
16509: CALL_OW 424
// Result = true ;
16513: LD_ADDR_VAR 0 1
16517: PUSH
16518: LD_INT 1
16520: ST_TO_ADDR
// end ; else
16521: GO 16532
16523: POP
// Result = false ; end ;
16524: LD_ADDR_VAR 0 1
16528: PUSH
16529: LD_INT 0
16531: ST_TO_ADDR
// DialogueOff ;
16532: CALL_OW 7
// end ;
16536: LD_VAR 0 1
16540: RET
// export function xavier_prisel ; var Autak ; begin
16541: LD_INT 0
16543: PPUSH
16544: PPUSH
// VraciSe = false ;
16545: LD_ADDR_LOC 38
16549: PUSH
16550: LD_INT 0
16552: ST_TO_ADDR
// Autak = IsInUnit ( Xavier ) ;
16553: LD_ADDR_VAR 0 2
16557: PUSH
16558: LD_EXP 25
16562: PPUSH
16563: CALL_OW 310
16567: ST_TO_ADDR
// if Autak then
16568: LD_VAR 0 2
16572: IFFALSE 16588
// SetSide ( Autak , side_Ru ) ;
16574: LD_VAR 0 2
16578: PPUSH
16579: LD_EXP 2
16583: PPUSH
16584: CALL_OW 235
// SetSide ( Xavier , side_Ru ) ;
16588: LD_EXP 25
16592: PPUSH
16593: LD_EXP 2
16597: PPUSH
16598: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
16602: CALL 16776 0 0
// end ;
16606: LD_VAR 0 1
16610: RET
// every 0 0$2.7 trigger IsInArea ( Xavier , AraboveParkoviste ) marked 21 do
16611: LD_EXP 25
16615: PPUSH
16616: LD_INT 18
16618: PPUSH
16619: CALL_OW 308
16623: IFFALSE 16632
16625: GO 16627
16627: DISABLE
// begin xavier_u_arabu ;
16628: CALL 15843 0 0
// end ;
16632: END
// every 1 1$0 marked 22 do
16633: GO 16635
16635: DISABLE
// begin Wait ( Rand ( 0 0$1 , 6 6$0 ) ) ;
16636: LD_INT 35
16638: PPUSH
16639: LD_INT 12600
16641: PPUSH
16642: CALL_OW 12
16646: PPUSH
16647: CALL_OW 67
// xavier_timeout ;
16651: CALL 15858 0 0
// end ;
16655: END
// every 0 0$4.2 trigger IsInArea ( Xavier , DropBox ) marked 23 do
16656: LD_EXP 25
16660: PPUSH
16661: LD_INT 11
16663: PPUSH
16664: CALL_OW 308
16668: IFFALSE 16677
16670: GO 16672
16672: DISABLE
// begin ; xavier_dropbox ;
16673: CALL 15881 0 0
// end ;
16677: END
// every 0 0$3.7 trigger FilterUnitsInArea ( DropBox , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) marked 24 do
16678: LD_INT 11
16680: PPUSH
16681: LD_INT 22
16683: PUSH
16684: LD_EXP 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 50
16695: PUSH
16696: EMPTY
16697: LIST
16698: PUSH
16699: EMPTY
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 70
16707: IFFALSE 16727
16709: GO 16711
16711: DISABLE
// begin if not xavier_zprava then
16712: CALL 16426 0 0
16716: NOT
16717: IFFALSE 16727
// begin Wait ( 1 1$0 ) ;
16719: LD_INT 2100
16721: PPUSH
16722: CALL_OW 67
// enable ;
16726: ENABLE
// end ; end ;
16727: END
// export function event_XavierPrisel ; begin
16728: LD_INT 0
16730: PPUSH
// xavier_prisel ;
16731: CALL 16541 0 0
// end ;
16735: LD_VAR 0 1
16739: RET
// export function xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
16740: LD_INT 0
16742: PPUSH
// if Nastupuje and ( VehOld = KradenyVuz ) then
16743: LD_LOC 40
16747: PUSH
16748: LD_VAR 0 2
16752: PUSH
16753: LD_LOC 41
16757: EQUAL
16758: AND
16759: IFFALSE 16771
// KradenyVuz = VehNew ;
16761: LD_ADDR_LOC 41
16765: PUSH
16766: LD_VAR 0 1
16770: ST_TO_ADDR
// end ;
16771: LD_VAR 0 5
16775: RET
// function zkopiruj_xaviera_jako_rus ; var Xav , X , Y , Dir , InUnit ; begin
16776: LD_INT 0
16778: PPUSH
16779: PPUSH
16780: PPUSH
16781: PPUSH
16782: PPUSH
16783: PPUSH
// X = GetX ( Xavier ) ;
16784: LD_ADDR_VAR 0 3
16788: PUSH
16789: LD_EXP 25
16793: PPUSH
16794: CALL_OW 250
16798: ST_TO_ADDR
// Y = GetY ( Xavier ) ;
16799: LD_ADDR_VAR 0 4
16803: PUSH
16804: LD_EXP 25
16808: PPUSH
16809: CALL_OW 251
16813: ST_TO_ADDR
// Dir = GetDir ( Xavier ) ;
16814: LD_ADDR_VAR 0 5
16818: PUSH
16819: LD_EXP 25
16823: PPUSH
16824: CALL_OW 254
16828: ST_TO_ADDR
// InUnit = IsInUnit ( Xavier ) ;
16829: LD_ADDR_VAR 0 6
16833: PUSH
16834: LD_EXP 25
16838: PPUSH
16839: CALL_OW 310
16843: ST_TO_ADDR
// RemoveUnit ( Xavier ) ;
16844: LD_EXP 25
16848: PPUSH
16849: CALL_OW 64
// PrepareNewCharacter ( Xavier ) ;
16853: LD_STRING Xavier
16855: PPUSH
16856: CALL_OW 26
// UC_Side = side_Ru ;
16860: LD_ADDR_OWVAR 20
16864: PUSH
16865: LD_EXP 2
16869: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
16870: LD_ADDR_OWVAR 21
16874: PUSH
16875: LD_INT 3
16877: ST_TO_ADDR
// UC_Placed = false ;
16878: LD_ADDR_OWVAR 25
16882: PUSH
16883: LD_INT 0
16885: ST_TO_ADDR
// Xav = CreateHuman ;
16886: LD_ADDR_VAR 0 2
16890: PUSH
16891: CALL_OW 44
16895: ST_TO_ADDR
// SetLives ( Xav , GetLives ( Xavier ) ) ;
16896: LD_VAR 0 2
16900: PPUSH
16901: LD_EXP 25
16905: PPUSH
16906: CALL_OW 256
16910: PPUSH
16911: CALL_OW 234
// DestroyUnit ( Xavier ) ;
16915: LD_EXP 25
16919: PPUSH
16920: CALL_OW 65
// Xavier = Xav ;
16924: LD_ADDR_EXP 25
16928: PUSH
16929: LD_VAR 0 2
16933: ST_TO_ADDR
// if InUnit then
16934: LD_VAR 0 6
16938: IFFALSE 16956
// PlaceHumanInUnit ( Xavier , InUnit ) else
16940: LD_EXP 25
16944: PPUSH
16945: LD_VAR 0 6
16949: PPUSH
16950: CALL_OW 52
16954: GO 16992
// begin PlaceUnitXY ( Xavier , X , Y , false ) ;
16956: LD_EXP 25
16960: PPUSH
16961: LD_VAR 0 3
16965: PPUSH
16966: LD_VAR 0 4
16970: PPUSH
16971: LD_INT 0
16973: PPUSH
16974: CALL_OW 48
// SetDir ( Xavier , Dir ) ;
16978: LD_EXP 25
16982: PPUSH
16983: LD_VAR 0 5
16987: PPUSH
16988: CALL_OW 233
// end ; end ; end_of_file
16992: LD_VAR 0 1
16996: RET
// var Uniky ; var HeikeVytvorena ; var HeikeUtika ; var HeikeJdeKam ; var Start_Budovy , Start_Auta , Start_Lidi ; var Registry , Makro ; var HeikeVCervenem ; var Zajmuta ; export function init_heike ; begin
16997: LD_INT 0
16999: PPUSH
// disable ( 31 ) ;
17000: LD_INT 31
17002: DISABLE_MARKED
// disable ( 32 ) ;
17003: LD_INT 32
17005: DISABLE_MARKED
// Uniky = [ [ Unik1 , HeikeCil1 ] , [ Unik2 , HeikeCil2 ] , [ Unik3 , HeikeCil3 ] , [ Unik4 , HeikeCil4 ] , [ Unik5 , HeikeCil5 ] , [ Unik6 , HeikeCil6 ] , [ Unik7 , HeikeCil7 ] ] ;
17006: LD_ADDR_LOC 42
17010: PUSH
17011: LD_INT 3
17013: PUSH
17014: LD_INT 20
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 4
17023: PUSH
17024: LD_INT 21
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: PUSH
17031: LD_INT 5
17033: PUSH
17034: LD_INT 22
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: LD_INT 6
17043: PUSH
17044: LD_INT 23
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 7
17053: PUSH
17054: LD_INT 24
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: PUSH
17061: LD_INT 8
17063: PUSH
17064: LD_INT 25
17066: PUSH
17067: EMPTY
17068: LIST
17069: LIST
17070: PUSH
17071: LD_INT 9
17073: PUSH
17074: LD_INT 26
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: ST_TO_ADDR
// HeikeVytvorena = false ;
17090: LD_ADDR_LOC 43
17094: PUSH
17095: LD_INT 0
17097: ST_TO_ADDR
// HeikeUtika = false ;
17098: LD_ADDR_LOC 44
17102: PUSH
17103: LD_INT 0
17105: ST_TO_ADDR
// HeikeVCervenem = false ;
17106: LD_ADDR_LOC 51
17110: PUSH
17111: LD_INT 0
17113: ST_TO_ADDR
// Zajmuta = false ;
17114: LD_ADDR_LOC 52
17118: PUSH
17119: LD_INT 0
17121: ST_TO_ADDR
// Start_Budovy = dif_HeikeBudovy [ Difficulty ] ;
17122: LD_ADDR_LOC 46
17126: PUSH
17127: LD_EXP 39
17131: PUSH
17132: LD_OWVAR 67
17136: ARRAY
17137: ST_TO_ADDR
// Start_Auta = dif_HeikeAuta [ Difficulty ] ;
17138: LD_ADDR_LOC 47
17142: PUSH
17143: LD_EXP 40
17147: PUSH
17148: LD_OWVAR 67
17152: ARRAY
17153: ST_TO_ADDR
// Start_Lidi = dif_HeikeLidi [ Difficulty ] ;
17154: LD_ADDR_LOC 48
17158: PUSH
17159: LD_EXP 41
17163: PUSH
17164: LD_OWVAR 67
17168: ARRAY
17169: ST_TO_ADDR
// end ;
17170: LD_VAR 0 1
17174: RET
// function vytvor_heike ; var I ; begin
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
// Heike = NewCharacter ( Heike ) ;
17179: LD_ADDR_EXP 26
17183: PUSH
17184: LD_STRING Heike
17186: PPUSH
17187: CALL_OW 25
17191: ST_TO_ADDR
// SetSide ( Heike , side_Heike ) ;
17192: LD_EXP 26
17196: PPUSH
17197: LD_EXP 6
17201: PPUSH
17202: CALL_OW 235
// Heikeovci = [ ] ;
17206: LD_ADDR_EXP 27
17210: PUSH
17211: EMPTY
17212: ST_TO_ADDR
// InitHC ;
17213: CALL_OW 19
// InitUC ;
17217: CALL_OW 18
// UC_Side = side_Strazci ;
17221: LD_ADDR_OWVAR 20
17225: PUSH
17226: LD_EXP 7
17230: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
17231: LD_ADDR_OWVAR 21
17235: PUSH
17236: LD_INT 2
17238: ST_TO_ADDR
// HC_Name =  ;
17239: LD_ADDR_OWVAR 26
17243: PUSH
17244: LD_STRING 
17246: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
17247: LD_ADDR_OWVAR 28
17251: PUSH
17252: LD_INT 1
17254: ST_TO_ADDR
// UC_Placed = false ;
17255: LD_ADDR_OWVAR 25
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
17263: LD_INT 5
17265: PPUSH
17266: CALL_OW 375
// for I = 1 to dif_HeikeovciPocet [ Difficulty ] do
17270: LD_ADDR_VAR 0 2
17274: PUSH
17275: DOUBLE
17276: LD_INT 1
17278: DEC
17279: ST_TO_ADDR
17280: LD_EXP 43
17284: PUSH
17285: LD_OWVAR 67
17289: ARRAY
17290: PUSH
17291: FOR_TO
17292: IFFALSE 17331
// begin HC_Sex = Rand ( 1 , 2 ) ;
17294: LD_ADDR_OWVAR 27
17298: PUSH
17299: LD_INT 1
17301: PPUSH
17302: LD_INT 2
17304: PPUSH
17305: CALL_OW 12
17309: ST_TO_ADDR
// Heikeovci = Heikeovci union [ CreateHuman ] ;
17310: LD_ADDR_EXP 27
17314: PUSH
17315: LD_EXP 27
17319: PUSH
17320: CALL_OW 44
17324: PUSH
17325: EMPTY
17326: LIST
17327: UNION
17328: ST_TO_ADDR
// end ;
17329: GO 17291
17331: POP
17332: POP
// Heikeovci = Heikeovci diff [ 0 ] ;
17333: LD_ADDR_EXP 27
17337: PUSH
17338: LD_EXP 27
17342: PUSH
17343: LD_INT 0
17345: PUSH
17346: EMPTY
17347: LIST
17348: DIFF
17349: ST_TO_ADDR
// SetLives ( Heikeovci , dif_HeikeovciLives [ Difficulty ] ) ;
17350: LD_EXP 27
17354: PPUSH
17355: LD_EXP 42
17359: PUSH
17360: LD_OWVAR 67
17364: ARRAY
17365: PPUSH
17366: CALL_OW 234
// end ;
17370: LD_VAR 0 1
17374: RET
// function heike_do_zakladny ; begin
17375: LD_INT 0
17377: PPUSH
// AddComMoveXY ( Heike , 87 , 120 ) ;
17378: LD_EXP 26
17382: PPUSH
17383: LD_INT 87
17385: PPUSH
17386: LD_INT 120
17388: PPUSH
17389: CALL_OW 171
// AddComMoveXY ( Heike , 83 , 114 ) ;
17393: LD_EXP 26
17397: PPUSH
17398: LD_INT 83
17400: PPUSH
17401: LD_INT 114
17403: PPUSH
17404: CALL_OW 171
// AddComMoveXY ( Heike , 74 , 97 ) ;
17408: LD_EXP 26
17412: PPUSH
17413: LD_INT 74
17415: PPUSH
17416: LD_INT 97
17418: PPUSH
17419: CALL_OW 171
// AddComMoveXY ( Heike , 66 , 78 ) ;
17423: LD_EXP 26
17427: PPUSH
17428: LD_INT 66
17430: PPUSH
17431: LD_INT 78
17433: PPUSH
17434: CALL_OW 171
// if VsevSaved then
17438: LD_EXP 8
17442: IFFALSE 17491
// begin AddComMoveXY ( Heike , 61 , 70 ) ;
17444: LD_EXP 26
17448: PPUSH
17449: LD_INT 61
17451: PPUSH
17452: LD_INT 70
17454: PPUSH
17455: CALL_OW 171
// AddComMoveXY ( Heike , 56 , 59 ) ;
17459: LD_EXP 26
17463: PPUSH
17464: LD_INT 56
17466: PPUSH
17467: LD_INT 59
17469: PPUSH
17470: CALL_OW 171
// AddComMoveXY ( Heike , 44 , 44 ) ;
17474: LD_EXP 26
17478: PPUSH
17479: LD_INT 44
17481: PPUSH
17482: LD_INT 44
17484: PPUSH
17485: CALL_OW 171
// end else
17489: GO 17566
// begin AddComMoveXY ( Heike , 44 , 73 ) ;
17491: LD_EXP 26
17495: PPUSH
17496: LD_INT 44
17498: PPUSH
17499: LD_INT 73
17501: PPUSH
17502: CALL_OW 171
// AddComMoveXY ( Heike , 36 , 65 ) ;
17506: LD_EXP 26
17510: PPUSH
17511: LD_INT 36
17513: PPUSH
17514: LD_INT 65
17516: PPUSH
17517: CALL_OW 171
// AddComMoveXY ( Heike , 47 , 59 ) ;
17521: LD_EXP 26
17525: PPUSH
17526: LD_INT 47
17528: PPUSH
17529: LD_INT 59
17531: PPUSH
17532: CALL_OW 171
// AddComMoveXY ( Heike , 28 , 51 ) ;
17536: LD_EXP 26
17540: PPUSH
17541: LD_INT 28
17543: PPUSH
17544: LD_INT 51
17546: PPUSH
17547: CALL_OW 171
// AddComMoveXY ( Heike , 29 , 42 ) ;
17551: LD_EXP 26
17555: PPUSH
17556: LD_INT 29
17558: PPUSH
17559: LD_INT 42
17561: PPUSH
17562: CALL_OW 171
// end ; AddComMoveXY ( Heike , 40 , 37 ) ;
17566: LD_EXP 26
17570: PPUSH
17571: LD_INT 40
17573: PPUSH
17574: LD_INT 37
17576: PPUSH
17577: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 22 ) ;
17581: LD_EXP 26
17585: PPUSH
17586: LD_INT 33
17588: PPUSH
17589: LD_INT 22
17591: PPUSH
17592: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 16 ) ;
17596: LD_EXP 26
17600: PPUSH
17601: LD_INT 33
17603: PPUSH
17604: LD_INT 16
17606: PPUSH
17607: CALL_OW 171
// AddComMoveXY ( Heike , 38 , 13 ) ;
17611: LD_EXP 26
17615: PPUSH
17616: LD_INT 38
17618: PPUSH
17619: LD_INT 13
17621: PPUSH
17622: CALL_OW 171
// AddComMoveXY ( Heike , 46 , 13 ) ;
17626: LD_EXP 26
17630: PPUSH
17631: LD_INT 46
17633: PPUSH
17634: LD_INT 13
17636: PPUSH
17637: CALL_OW 171
// AddComMoveXY ( Heike , 54 , 16 ) ;
17641: LD_EXP 26
17645: PPUSH
17646: LD_INT 54
17648: PPUSH
17649: LD_INT 16
17651: PPUSH
17652: CALL_OW 171
// AddComMoveXY ( Heike , 62 , 15 ) ;
17656: LD_EXP 26
17660: PPUSH
17661: LD_INT 62
17663: PPUSH
17664: LD_INT 15
17666: PPUSH
17667: CALL_OW 171
// AddComMoveXY ( Heike , 73 , 14 ) ;
17671: LD_EXP 26
17675: PPUSH
17676: LD_INT 73
17678: PPUSH
17679: LD_INT 14
17681: PPUSH
17682: CALL_OW 171
// AddComMoveXY ( Heike , 91 , 13 ) ;
17686: LD_EXP 26
17690: PPUSH
17691: LD_INT 91
17693: PPUSH
17694: LD_INT 13
17696: PPUSH
17697: CALL_OW 171
// AddComMoveToArea ( Heike , HeikeCil ) ;
17701: LD_EXP 26
17705: PPUSH
17706: LD_INT 27
17708: PPUSH
17709: CALL_OW 173
// end ;
17713: LD_VAR 0 1
17717: RET
// function heike_start ; var Auto ; begin
17718: LD_INT 0
17720: PPUSH
17721: PPUSH
// if GetSide ( Xavier ) <> side_Ru then
17722: LD_EXP 25
17726: PPUSH
17727: CALL_OW 255
17731: PUSH
17732: LD_EXP 2
17736: NONEQUAL
17737: IFFALSE 17743
// xavier_prisel ;
17739: CALL 16541 0 0
// vytvor_heike ;
17743: CALL 17175 0 0
// PlaceUnitArea ( Heike , HeikeStart , false ) ;
17747: LD_EXP 26
17751: PPUSH
17752: LD_INT 19
17754: PPUSH
17755: LD_INT 0
17757: PPUSH
17758: CALL_OW 49
// place_list ( Heikeovci , HeikeStart ) ;
17762: LD_EXP 27
17766: PPUSH
17767: LD_INT 19
17769: PPUSH
17770: CALL 20594 0 2
// Wait ( Rand ( 0 0$1 , 0 0$5 ) ) ;
17774: LD_INT 35
17776: PPUSH
17777: LD_INT 175
17779: PPUSH
17780: CALL_OW 12
17784: PPUSH
17785: CALL_OW 67
// Registry = McRegistry ( side_Heike , [ [ MC_REG_UNITS_TO_PROTECT , [ Heike ] ] ] ) ;
17789: LD_ADDR_LOC 49
17793: PUSH
17794: LD_EXP 6
17798: PPUSH
17799: LD_INT 4
17801: PUSH
17802: LD_EXP 26
17806: PUSH
17807: EMPTY
17808: LIST
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: PUSH
17814: EMPTY
17815: LIST
17816: PPUSH
17817: CALL_OW 399
17821: ST_TO_ADDR
// Makro = McDefend ( 0 , Registry , Heikeovci , [ ] ) ;
17822: LD_ADDR_LOC 50
17826: PUSH
17827: LD_INT 0
17829: PPUSH
17830: LD_LOC 49
17834: PPUSH
17835: LD_EXP 27
17839: PPUSH
17840: EMPTY
17841: PPUSH
17842: CALL_OW 401
17846: ST_TO_ADDR
// DialogueOn ;
17847: CALL_OW 6
// dialog_HeikeObj ;
17851: CALL 22550 0 0
// ChangeMissionObjectives ( MHeike ) ;
17855: LD_STRING MHeike
17857: PPUSH
17858: CALL_OW 337
// Query ( QHeike ) ;
17862: LD_STRING QHeike
17864: PPUSH
17865: CALL_OW 97
// DialogueOff ;
17869: CALL_OW 7
// RevealFogArea ( side_Ru , HeikeStart ) ;
17873: LD_EXP 2
17877: PPUSH
17878: LD_INT 19
17880: PPUSH
17881: CALL_OW 332
// CenterOnUnits ( Heike ) ;
17885: LD_EXP 26
17889: PPUSH
17890: CALL_OW 85
// heike_do_zakladny ;
17894: CALL 17375 0 0
// ComMoveUnit ( Heikeovci , Heike ) ;
17898: LD_EXP 27
17902: PPUSH
17903: LD_EXP 26
17907: PPUSH
17908: CALL_OW 112
// enable ( 32 ) ;
17912: LD_INT 32
17914: ENABLE_MARKED
// end ;
17915: LD_VAR 0 1
17919: RET
// function heike_kontrola_start ; var Budovy , Auta , Lidi ; begin
17920: LD_INT 0
17922: PPUSH
17923: PPUSH
17924: PPUSH
17925: PPUSH
// if HeikeVytvorena then
17926: LD_LOC 43
17930: IFFALSE 17934
// exit ;
17932: GO 18147
// Budovy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_PLACED ] ] ) ;
17934: LD_ADDR_VAR 0 2
17938: PUSH
17939: LD_INT 22
17941: PUSH
17942: LD_EXP 4
17946: PUSH
17947: EMPTY
17948: LIST
17949: LIST
17950: PUSH
17951: LD_INT 21
17953: PUSH
17954: LD_INT 3
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 50
17963: PUSH
17964: EMPTY
17965: LIST
17966: PUSH
17967: LD_INT 52
17969: PUSH
17970: EMPTY
17971: LIST
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: LIST
17978: PPUSH
17979: CALL_OW 69
17983: ST_TO_ADDR
// Auta = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_PLACED ] ] ) ;
17984: LD_ADDR_VAR 0 3
17988: PUSH
17989: LD_INT 22
17991: PUSH
17992: LD_EXP 4
17996: PUSH
17997: EMPTY
17998: LIST
17999: LIST
18000: PUSH
18001: LD_INT 21
18003: PUSH
18004: LD_INT 2
18006: PUSH
18007: EMPTY
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 50
18013: PUSH
18014: EMPTY
18015: LIST
18016: PUSH
18017: LD_INT 52
18019: PUSH
18020: EMPTY
18021: LIST
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: PPUSH
18029: CALL_OW 69
18033: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18034: LD_ADDR_VAR 0 4
18038: PUSH
18039: LD_INT 22
18041: PUSH
18042: LD_EXP 4
18046: PUSH
18047: EMPTY
18048: LIST
18049: LIST
18050: PUSH
18051: LD_INT 21
18053: PUSH
18054: LD_INT 1
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PUSH
18061: LD_INT 50
18063: PUSH
18064: EMPTY
18065: LIST
18066: PUSH
18067: LD_INT 52
18069: PUSH
18070: EMPTY
18071: LIST
18072: PUSH
18073: EMPTY
18074: LIST
18075: LIST
18076: LIST
18077: LIST
18078: PPUSH
18079: CALL_OW 69
18083: ST_TO_ADDR
// if ( ( Budovy <= Start_Budovy ) and ( Auta <= Start_Auta ) ) or ( Lidi <= Start_Lidi ) then
18084: LD_VAR 0 2
18088: PUSH
18089: LD_LOC 46
18093: LESSEQUAL
18094: PUSH
18095: LD_VAR 0 3
18099: PUSH
18100: LD_LOC 47
18104: LESSEQUAL
18105: AND
18106: PUSH
18107: LD_VAR 0 4
18111: PUSH
18112: LD_LOC 48
18116: LESSEQUAL
18117: OR
18118: IFFALSE 18147
// begin HeikeVytvorena = true ;
18120: LD_ADDR_LOC 43
18124: PUSH
18125: LD_INT 1
18127: ST_TO_ADDR
// Wait ( Rand ( 0 0$3 , 0 0$20 ) ) ;
18128: LD_INT 105
18130: PPUSH
18131: LD_INT 700
18133: PPUSH
18134: CALL_OW 12
18138: PPUSH
18139: CALL_OW 67
// heike_start ;
18143: CALL 17718 0 0
// end ; end ;
18147: LD_VAR 0 1
18151: RET
// function je_volny_unik ( Area ) ; var KdoTam ; begin
18152: LD_INT 0
18154: PPUSH
18155: PPUSH
// KdoTam = FilterUnitsInArea ( Area , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) ;
18156: LD_ADDR_VAR 0 3
18160: PUSH
18161: LD_VAR 0 1
18165: PPUSH
18166: LD_INT 22
18168: PUSH
18169: LD_EXP 2
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 50
18180: PUSH
18181: EMPTY
18182: LIST
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: PPUSH
18188: CALL_OW 70
18192: ST_TO_ADDR
// if KdoTam then
18193: LD_VAR 0 3
18197: IFFALSE 18209
// Result = false else
18199: LD_ADDR_VAR 0 2
18203: PUSH
18204: LD_INT 0
18206: ST_TO_ADDR
18207: GO 18217
// Result = true ;
18209: LD_ADDR_VAR 0 2
18213: PUSH
18214: LD_INT 1
18216: ST_TO_ADDR
// end ;
18217: LD_VAR 0 2
18221: RET
// function zjisti_volne ; var Akt , Jednotky ; begin
18222: LD_INT 0
18224: PPUSH
18225: PPUSH
18226: PPUSH
// Result = [ ] ;
18227: LD_ADDR_VAR 0 1
18231: PUSH
18232: EMPTY
18233: ST_TO_ADDR
// for Akt in Uniky do
18234: LD_ADDR_VAR 0 2
18238: PUSH
18239: LD_LOC 42
18243: PUSH
18244: FOR_IN
18245: IFFALSE 18283
// begin if je_volny_unik ( Akt [ 1 ] ) then
18247: LD_VAR 0 2
18251: PUSH
18252: LD_INT 1
18254: ARRAY
18255: PPUSH
18256: CALL 18152 0 1
18260: IFFALSE 18281
// Result = Result union [ Akt ] ;
18262: LD_ADDR_VAR 0 1
18266: PUSH
18267: LD_VAR 0 1
18271: PUSH
18272: LD_VAR 0 2
18276: PUSH
18277: EMPTY
18278: LIST
18279: UNION
18280: ST_TO_ADDR
// end ;
18281: GO 18244
18283: POP
18284: POP
// end ;
18285: LD_VAR 0 1
18289: RET
// function zjisti_heike_utekla ; var Akt ; begin
18290: LD_INT 0
18292: PPUSH
18293: PPUSH
// Result = false ;
18294: LD_ADDR_VAR 0 1
18298: PUSH
18299: LD_INT 0
18301: ST_TO_ADDR
// if not IsOk ( Heike ) then
18302: LD_EXP 26
18306: PPUSH
18307: CALL_OW 302
18311: NOT
18312: IFFALSE 18316
// exit ;
18314: GO 18395
// Result = true ;
18316: LD_ADDR_VAR 0 1
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// if IsInArea ( Heike , HeikeCil ) then
18324: LD_EXP 26
18328: PPUSH
18329: LD_INT 27
18331: PPUSH
18332: CALL_OW 308
18336: IFFALSE 18340
// exit ;
18338: GO 18395
// if HeikeUtika then
18340: LD_LOC 44
18344: IFFALSE 18387
// begin for Akt in Uniky do
18346: LD_ADDR_VAR 0 2
18350: PUSH
18351: LD_LOC 42
18355: PUSH
18356: FOR_IN
18357: IFFALSE 18385
// if IsInArea ( Heike , Akt [ 2 ] ) then
18359: LD_EXP 26
18363: PPUSH
18364: LD_VAR 0 2
18368: PUSH
18369: LD_INT 2
18371: ARRAY
18372: PPUSH
18373: CALL_OW 308
18377: IFFALSE 18383
// exit ;
18379: POP
18380: POP
18381: GO 18395
18383: GO 18356
18385: POP
18386: POP
// end ; Result = false ;
18387: LD_ADDR_VAR 0 1
18391: PUSH
18392: LD_INT 0
18394: ST_TO_ADDR
// end ;
18395: LD_VAR 0 1
18399: RET
// function GetDistUnitArea2 ( Un , Area ) ; var Hex ; begin
18400: LD_INT 0
18402: PPUSH
18403: PPUSH
// Hex = RandHexArea ( Area , false ) ;
18404: LD_ADDR_VAR 0 4
18408: PUSH
18409: LD_VAR 0 2
18413: PPUSH
18414: LD_INT 0
18416: PPUSH
18417: CALL_OW 16
18421: ST_TO_ADDR
// Result = GetDistUnitXY ( Un , Hex [ 1 ] , Hex [ 2 ] ) ;
18422: LD_ADDR_VAR 0 3
18426: PUSH
18427: LD_VAR 0 1
18431: PPUSH
18432: LD_VAR 0 4
18436: PUSH
18437: LD_INT 1
18439: ARRAY
18440: PPUSH
18441: LD_VAR 0 4
18445: PUSH
18446: LD_INT 2
18448: ARRAY
18449: PPUSH
18450: CALL_OW 297
18454: ST_TO_ADDR
// end ;
18455: LD_VAR 0 3
18459: RET
// function zjisti_nejlepsi_unik ( Seznam ) ; var Min , Akt , AktDal ; begin
18460: LD_INT 0
18462: PPUSH
18463: PPUSH
18464: PPUSH
18465: PPUSH
// Result = [ ] ;
18466: LD_ADDR_VAR 0 2
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// Min = 99999 ;
18473: LD_ADDR_VAR 0 3
18477: PUSH
18478: LD_INT 99999
18480: ST_TO_ADDR
// for Akt in Seznam do
18481: LD_ADDR_VAR 0 4
18485: PUSH
18486: LD_VAR 0 1
18490: PUSH
18491: FOR_IN
18492: IFFALSE 18552
// begin AktDal = GetDistUnitArea2 ( Heike , Akt [ 1 ] ) ;
18494: LD_ADDR_VAR 0 5
18498: PUSH
18499: LD_EXP 26
18503: PPUSH
18504: LD_VAR 0 4
18508: PUSH
18509: LD_INT 1
18511: ARRAY
18512: PPUSH
18513: CALL 18400 0 2
18517: ST_TO_ADDR
// if AktDal < Min then
18518: LD_VAR 0 5
18522: PUSH
18523: LD_VAR 0 3
18527: LESS
18528: IFFALSE 18550
// begin Result = Akt ;
18530: LD_ADDR_VAR 0 2
18534: PUSH
18535: LD_VAR 0 4
18539: ST_TO_ADDR
// Min = AktDal ;
18540: LD_ADDR_VAR 0 3
18544: PUSH
18545: LD_VAR 0 5
18549: ST_TO_ADDR
// end ; end ;
18550: GO 18491
18552: POP
18553: POP
// end ;
18554: LD_VAR 0 2
18558: RET
// function heike_utika ; var Volno , Hex ; begin
18559: LD_INT 0
18561: PPUSH
18562: PPUSH
18563: PPUSH
// if zjisti_heike_utekla then
18564: CALL 18290 0 0
18568: IFFALSE 18576
// begin heike_utekla ;
18570: CALL 18756 0 0
// exit ;
18574: GO 18668
// end ; Volno = zjisti_volne ;
18576: LD_ADDR_VAR 0 2
18580: PUSH
18581: CALL 18222 0 0
18585: ST_TO_ADDR
// if HeikeUtika then
18586: LD_LOC 44
18590: IFFALSE 18609
// begin if je_volny_unik ( HeikeJdeKam [ 1 ] ) then
18592: LD_LOC 45
18596: PUSH
18597: LD_INT 1
18599: ARRAY
18600: PPUSH
18601: CALL 18152 0 1
18605: IFFALSE 18609
// exit ;
18607: GO 18668
// end ; HeikeJdeKam = zjisti_nejlepsi_unik ( Volno ) ;
18609: LD_ADDR_LOC 45
18613: PUSH
18614: LD_VAR 0 2
18618: PPUSH
18619: CALL 18460 0 1
18623: ST_TO_ADDR
// ComMoveToArea ( Heike , HeikeJdeKam [ 1 ] ) ;
18624: LD_EXP 26
18628: PPUSH
18629: LD_LOC 45
18633: PUSH
18634: LD_INT 1
18636: ARRAY
18637: PPUSH
18638: CALL_OW 113
// AddComMoveToArea ( Heike , HeikeJdeKam [ 2 ] ) ;
18642: LD_EXP 26
18646: PPUSH
18647: LD_LOC 45
18651: PUSH
18652: LD_INT 2
18654: ARRAY
18655: PPUSH
18656: CALL_OW 173
// HeikeUtika = true ;
18660: LD_ADDR_LOC 44
18664: PUSH
18665: LD_INT 1
18667: ST_TO_ADDR
// end ;
18668: LD_VAR 0 1
18672: RET
// function strazci_mrtvi ; begin
18673: LD_INT 0
18675: PPUSH
// heike_utec ;
18676: CALL 18710 0 0
// end ;
18680: LD_VAR 0 1
18684: RET
// every 0 0$1.3 marked 32 do
18685: GO 18687
18687: DISABLE
// begin if zjisti_heike_utekla then
18688: CALL 18290 0 0
18692: IFFALSE 18700
// begin heike_utekla ;
18694: CALL 18756 0 0
// exit ;
18698: GO 18700
// end ; end ;
18700: END
// every 0 0$1.1 marked 31 do
18701: GO 18703
18703: DISABLE
// begin heike_utika ;
18704: CALL 18559 0 0
// enable ;
18708: ENABLE
// end ;
18709: END
// function heike_utec ; begin
18710: LD_INT 0
18712: PPUSH
// if IsInArea ( Heike , Obkliceni ) then
18713: LD_EXP 26
18717: PPUSH
18718: LD_INT 38
18720: PPUSH
18721: CALL_OW 308
18725: IFFALSE 18736
// begin enable ( 31 ) ;
18727: LD_INT 31
18729: ENABLE_MARKED
// heike_utika ;
18730: CALL 18559 0 0
// end else
18734: GO 18751
// begin enable ( 32 ) ;
18736: LD_INT 32
18738: ENABLE_MARKED
// ComMoveToArea ( Heike , HeikeCil ) ;
18739: LD_EXP 26
18743: PPUSH
18744: LD_INT 27
18746: PPUSH
18747: CALL_OW 113
// end ; end ;
18751: LD_VAR 0 1
18755: RET
// function heike_utekla ; begin
18756: LD_INT 0
18758: PPUSH
// InGameOn ;
18759: CALL_OW 8
// CenterOnUnits ( Heike ) ;
18763: LD_EXP 26
18767: PPUSH
18768: CALL_OW 85
// Wait ( 0 0$2 ) ;
18772: LD_INT 70
18774: PPUSH
18775: CALL_OW 67
// if not IsOk ( Heike ) then
18779: LD_EXP 26
18783: PPUSH
18784: CALL_OW 302
18788: NOT
18789: IFFALSE 18801
// begin InGameOff ;
18791: CALL_OW 9
// heike_mrtva ;
18795: CALL 18961 0 0
// exit ;
18799: GO 18828
// end ; RemoveUnit ( Heike ) ;
18801: LD_EXP 26
18805: PPUSH
18806: CALL_OW 64
// Wait ( 0 0$2 ) ;
18810: LD_INT 70
18812: PPUSH
18813: CALL_OW 67
// YouLost ( Heike ) ;
18817: LD_STRING Heike
18819: PPUSH
18820: CALL_OW 104
// InGameOff ;
18824: CALL_OW 9
// end ;
18828: LD_VAR 0 1
18832: RET
// function heike_zajata ; begin
18833: LD_INT 0
18835: PPUSH
// if Zajmuta then
18836: LD_LOC 52
18840: IFFALSE 18844
// exit ;
18842: GO 18956
// Zajmuta = true ;
18844: LD_ADDR_LOC 52
18848: PUSH
18849: LD_INT 1
18851: ST_TO_ADDR
// SetAttitude ( side_Ru , side_Heike , ATT_FRIEND , true ) ;
18852: LD_EXP 2
18856: PPUSH
18857: LD_EXP 6
18861: PPUSH
18862: LD_INT 1
18864: PPUSH
18865: LD_INT 1
18867: PPUSH
18868: CALL_OW 80
// ComHold ( Heike ) ;
18872: LD_EXP 26
18876: PPUSH
18877: CALL_OW 140
// if ( GetLives ( Heike ) <= HRANICE_UMIRANI ) then
18881: LD_EXP 26
18885: PPUSH
18886: CALL_OW 256
18890: PUSH
18891: LD_INT 250
18893: LESSEQUAL
18894: IFFALSE 18912
// SetLives ( Heike , HRANICE_UMIRANI + 1 ) ;
18896: LD_EXP 26
18900: PPUSH
18901: LD_INT 250
18903: PUSH
18904: LD_INT 1
18906: PLUS
18907: PPUSH
18908: CALL_OW 234
// ComCancel ( Heike ) ;
18912: LD_EXP 26
18916: PPUSH
18917: CALL_OW 127
// ComHold ( Heike ) ;
18921: LD_EXP 26
18925: PPUSH
18926: CALL_OW 140
// DialogueOn ;
18930: CALL_OW 6
// dialog_HeikeCapt ;
18934: CALL 22606 0 0
// DialogueOff ;
18938: CALL_OW 7
// Wait ( 0 0$2 ) ;
18942: LD_INT 70
18944: PPUSH
18945: CALL_OW 67
// vyhral ( Main2 ) ;
18949: LD_STRING Main2
18951: PPUSH
18952: CALL 2973 0 1
// end ;
18956: LD_VAR 0 1
18960: RET
// function heike_mrtva ; begin
18961: LD_INT 0
18963: PPUSH
// DialogueOn ;
18964: CALL_OW 6
// Wait ( 0 0$3 ) ;
18968: LD_INT 105
18970: PPUSH
18971: CALL_OW 67
// vyhral ( Main1 ) ;
18975: LD_STRING Main1
18977: PPUSH
18978: CALL 2973 0 1
// DialogueOff ;
18982: CALL_OW 7
// end ;
18986: LD_VAR 0 1
18990: RET
// function straz_umrela ( Un ) ; begin
18991: LD_INT 0
18993: PPUSH
// if Un in Heikeovci then
18994: LD_VAR 0 1
18998: PUSH
18999: LD_EXP 27
19003: IN
19004: IFFALSE 19036
// begin Heikeovci = Heikeovci diff [ Un ] ;
19006: LD_ADDR_EXP 27
19010: PUSH
19011: LD_EXP 27
19015: PUSH
19016: LD_VAR 0 1
19020: PUSH
19021: EMPTY
19022: LIST
19023: DIFF
19024: ST_TO_ADDR
// if not Heikeovci then
19025: LD_EXP 27
19029: NOT
19030: IFFALSE 19036
// strazci_mrtvi ;
19032: CALL 18673 0 0
// end ; end ;
19036: LD_VAR 0 2
19040: RET
// export function heike_UnitDestroyed ( Un ) ; begin
19041: LD_INT 0
19043: PPUSH
// if Un = Heike then
19044: LD_VAR 0 1
19048: PUSH
19049: LD_EXP 26
19053: EQUAL
19054: IFFALSE 19062
// begin heike_mrtva ;
19056: CALL 18961 0 0
// exit ;
19060: GO 19075
// end ; straz_umrela ( Un ) ;
19062: LD_VAR 0 1
19066: PPUSH
19067: CALL 18991 0 1
// heike_kontrola_start ;
19071: CALL 17920 0 0
// end ;
19075: LD_VAR 0 2
19079: RET
// export function heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
19080: LD_INT 0
19082: PPUSH
// heike_kontrola_start ;
19083: CALL 17920 0 0
// end ;
19087: LD_VAR 0 5
19091: RET
// export function heike_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
19092: LD_INT 0
19094: PPUSH
// heike_kontrola_start ;
19095: CALL 17920 0 0
// end ;
19099: LD_VAR 0 4
19103: RET
// export function heike_UnitGoesToRed ( Un ) ; begin
19104: LD_INT 0
19106: PPUSH
// if Un = Heike then
19107: LD_VAR 0 1
19111: PUSH
19112: LD_EXP 26
19116: EQUAL
19117: IFFALSE 19127
// HeikeVCervenem = true ;
19119: LD_ADDR_LOC 51
19123: PUSH
19124: LD_INT 1
19126: ST_TO_ADDR
// straz_umrela ( Un ) ;
19127: LD_VAR 0 1
19131: PPUSH
19132: CALL 18991 0 1
// heike_kontrola_start ;
19136: CALL 17920 0 0
// end ;
19140: LD_VAR 0 2
19144: RET
// export function heike_StartHeal ( Un , Medic ) ; begin
19145: LD_INT 0
19147: PPUSH
// if Un <> Heike then
19148: LD_VAR 0 1
19152: PUSH
19153: LD_EXP 26
19157: NONEQUAL
19158: IFFALSE 19162
// exit ;
19160: GO 19202
// if not HeikeVCervenem then
19162: LD_LOC 51
19166: NOT
19167: IFFALSE 19171
// exit ;
19169: GO 19202
// if Heikeovci then
19171: LD_EXP 27
19175: IFFALSE 19179
// exit ;
19177: GO 19202
// if GetSide ( Medic ) <> side_Ru then
19179: LD_VAR 0 2
19183: PPUSH
19184: CALL_OW 255
19188: PUSH
19189: LD_EXP 2
19193: NONEQUAL
19194: IFFALSE 19198
// exit ;
19196: GO 19202
// heike_zajata ;
19198: CALL 18833 0 0
// end ; end_of_file
19202: LD_VAR 0 3
19206: RET
// var BednyA ; var BednyRZ , BednyRV ; export function init_Suroviny ; begin
19207: LD_INT 0
19209: PPUSH
// BednyA = dif_BednyA [ Difficulty ] ;
19210: LD_ADDR_LOC 53
19214: PUSH
19215: LD_EXP 36
19219: PUSH
19220: LD_OWVAR 67
19224: ARRAY
19225: ST_TO_ADDR
// if VsevSaved then
19226: LD_EXP 8
19230: IFFALSE 19266
// begin BednyRZ = dif_BednyR1 [ Difficulty ] ;
19232: LD_ADDR_LOC 54
19236: PUSH
19237: LD_EXP 37
19241: PUSH
19242: LD_OWVAR 67
19246: ARRAY
19247: ST_TO_ADDR
// BednyRV = dif_BednyR2 [ Difficulty ] ;
19248: LD_ADDR_LOC 55
19252: PUSH
19253: LD_EXP 38
19257: PUSH
19258: LD_OWVAR 67
19262: ARRAY
19263: ST_TO_ADDR
// end else
19264: GO 19298
// begin BednyRZ = dif_BednyR2 [ Difficulty ] ;
19266: LD_ADDR_LOC 54
19270: PUSH
19271: LD_EXP 38
19275: PUSH
19276: LD_OWVAR 67
19280: ARRAY
19281: ST_TO_ADDR
// BednyRV = dif_BednyR1 [ Difficulty ] ;
19282: LD_ADDR_LOC 55
19286: PUSH
19287: LD_EXP 37
19291: PUSH
19292: LD_OWVAR 67
19296: ARRAY
19297: ST_TO_ADDR
// end ; end ;
19298: LD_VAR 0 1
19302: RET
// every 5 5$13.7 + 5 5$9 do var Pocet ;
19303: GO 19305
19305: DISABLE
19306: LD_INT 0
19308: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19309: LD_INT 35
19311: PPUSH
19312: LD_INT 3150
19314: PPUSH
19315: CALL_OW 12
19319: PPUSH
19320: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_INT 0
19331: PPUSH
19332: LD_INT 5
19334: PPUSH
19335: CALL_OW 12
19339: ST_TO_ADDR
// if Pocet > 0 then
19340: LD_VAR 0 1
19344: PUSH
19345: LD_INT 0
19347: GREATER
19348: IFFALSE 19362
// CreateCratesAnywhere ( Pocet , true ) ;
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 1
19357: PPUSH
19358: CALL_OW 57
// enable ;
19362: ENABLE
// end ;
19363: PPOPN 1
19365: END
// every 1 1$49 do
19366: GO 19368
19368: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19369: LD_INT 35
19371: PPUSH
19372: LD_INT 3150
19374: PPUSH
19375: CALL_OW 12
19379: PPUSH
19380: CALL_OW 67
// if ( BednyA <> 0 ) then
19384: LD_LOC 53
19388: PUSH
19389: LD_INT 0
19391: NONEQUAL
19392: IFFALSE 19451
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyArabi , true ) ;
19394: LD_INT 3
19396: PPUSH
19397: LD_INT 5
19399: PPUSH
19400: CALL_OW 12
19404: PPUSH
19405: LD_INT 30
19407: PPUSH
19408: LD_INT 1
19410: PPUSH
19411: CALL_OW 55
// if ( BednyA <> - 1 ) then
19415: LD_LOC 53
19419: PUSH
19420: LD_INT 1
19422: NEG
19423: NONEQUAL
19424: IFFALSE 19440
// BednyA = BednyA - 1 ;
19426: LD_ADDR_LOC 53
19430: PUSH
19431: LD_LOC 53
19435: PUSH
19436: LD_INT 1
19438: MINUS
19439: ST_TO_ADDR
// if ( BednyA <> 0 ) then
19440: LD_LOC 53
19444: PUSH
19445: LD_INT 0
19447: NONEQUAL
19448: IFFALSE 19451
// enable ;
19450: ENABLE
// end ; end ;
19451: END
// every 2 2$5 + 1 1$39 do
19452: GO 19454
19454: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19455: LD_INT 35
19457: PPUSH
19458: LD_INT 4200
19460: PPUSH
19461: CALL_OW 12
19465: PPUSH
19466: CALL_OW 67
// if ( BednyRZ <> 0 ) then
19470: LD_LOC 54
19474: PUSH
19475: LD_INT 0
19477: NONEQUAL
19478: IFFALSE 19537
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
19480: LD_INT 3
19482: PPUSH
19483: LD_INT 5
19485: PPUSH
19486: CALL_OW 12
19490: PPUSH
19491: LD_INT 28
19493: PPUSH
19494: LD_INT 1
19496: PPUSH
19497: CALL_OW 55
// if ( BednyRZ <> - 1 ) then
19501: LD_LOC 54
19505: PUSH
19506: LD_INT 1
19508: NEG
19509: NONEQUAL
19510: IFFALSE 19526
// BednyRZ = BednyRZ - 1 ;
19512: LD_ADDR_LOC 54
19516: PUSH
19517: LD_LOC 54
19521: PUSH
19522: LD_INT 1
19524: MINUS
19525: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
19526: LD_LOC 54
19530: PUSH
19531: LD_INT 0
19533: NONEQUAL
19534: IFFALSE 19537
// enable ;
19536: ENABLE
// end ; end ;
19537: END
// every 2 2$23 + 0 0$53 do
19538: GO 19540
19540: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19541: LD_INT 35
19543: PPUSH
19544: LD_INT 4200
19546: PPUSH
19547: CALL_OW 12
19551: PPUSH
19552: CALL_OW 67
// if ( BednyRV <> 0 ) then
19556: LD_LOC 55
19560: PUSH
19561: LD_INT 0
19563: NONEQUAL
19564: IFFALSE 19623
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
19566: LD_INT 3
19568: PPUSH
19569: LD_INT 5
19571: PPUSH
19572: CALL_OW 12
19576: PPUSH
19577: LD_INT 29
19579: PPUSH
19580: LD_INT 1
19582: PPUSH
19583: CALL_OW 55
// if ( BednyRV <> - 1 ) then
19587: LD_LOC 55
19591: PUSH
19592: LD_INT 1
19594: NEG
19595: NONEQUAL
19596: IFFALSE 19612
// BednyRV = BednyRV - 1 ;
19598: LD_ADDR_LOC 55
19602: PUSH
19603: LD_LOC 55
19607: PUSH
19608: LD_INT 1
19610: MINUS
19611: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
19612: LD_LOC 55
19616: PUSH
19617: LD_INT 0
19619: NONEQUAL
19620: IFFALSE 19623
// enable ;
19622: ENABLE
// end ; end ; end_of_file
19623: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19624: LD_VAR 0 1
19628: PPUSH
19629: LD_VAR 0 2
19633: PPUSH
19634: LD_VAR 0 3
19638: PPUSH
19639: LD_VAR 0 4
19643: PPUSH
19644: CALL 16740 0 4
// yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19648: LD_VAR 0 1
19652: PPUSH
19653: LD_VAR 0 2
19657: PPUSH
19658: LD_VAR 0 3
19662: PPUSH
19663: LD_VAR 0 4
19667: PPUSH
19668: CALL 14508 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19672: LD_VAR 0 1
19676: PPUSH
19677: LD_VAR 0 2
19681: PPUSH
19682: LD_VAR 0 3
19686: PPUSH
19687: LD_VAR 0 4
19691: PPUSH
19692: CALL 9919 0 4
// heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19696: LD_VAR 0 1
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 3
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: CALL 19080 0 4
// end ;
19720: PPOPN 4
19722: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin heike_BuildingCaptured ( Build , OrigSide , Eng ) ;
19723: LD_VAR 0 1
19727: PPUSH
19728: LD_VAR 0 2
19732: PPUSH
19733: LD_VAR 0 3
19737: PPUSH
19738: CALL 19092 0 3
// arabi_BuildingCaptured ( Build , OrigSide , Eng ) ;
19742: LD_VAR 0 1
19746: PPUSH
19747: LD_VAR 0 2
19751: PPUSH
19752: LD_VAR 0 3
19756: PPUSH
19757: CALL 10414 0 3
// end ;
19761: PPOPN 3
19763: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
19764: LD_VAR 0 1
19768: PPUSH
19769: CALL 5952 0 1
// heike_UnitDestroyed ( Un ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: CALL 19041 0 1
// arabi_UnitDestroyed ( Un ) ;
19782: LD_VAR 0 1
19786: PPUSH
19787: CALL 10153 0 1
// end ;
19791: PPOPN 1
19793: END
// on UnitGoesToRed ( Un ) do begin yashin_UnitGoesToRed ( Un ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: CALL 14984 0 1
// arabi_UnitGoesToRed ( Un ) ;
19803: LD_VAR 0 1
19807: PPUSH
19808: CALL 10289 0 1
// heike_UnitGoesToRed ( Un ) ;
19812: LD_VAR 0 1
19816: PPUSH
19817: CALL 19104 0 1
// end ;
19821: PPOPN 1
19823: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
19824: LD_VAR 0 1
19828: PPUSH
19829: LD_VAR 0 2
19833: PPUSH
19834: CALL 9392 0 2
// end ;
19838: PPOPN 2
19840: END
// on BuildingComplete ( Un ) do begin rusove_BuildingComplete ( Un ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: CALL 6029 0 1
// end ;
19850: PPOPN 1
19852: END
// on SailEvent ( Num ) do begin case Num of 101 :
19853: LD_VAR 0 1
19857: PUSH
19858: LD_INT 101
19860: DOUBLE
19861: EQUAL
19862: IFTRUE 19866
19864: GO 19873
19866: POP
// event_Patrola ; 102 , 103 , 103 :
19867: CALL 11248 0 0
19871: GO 19936
19873: LD_INT 102
19875: DOUBLE
19876: EQUAL
19877: IFTRUE 19893
19879: LD_INT 103
19881: DOUBLE
19882: EQUAL
19883: IFTRUE 19893
19885: LD_INT 103
19887: DOUBLE
19888: EQUAL
19889: IFTRUE 19893
19891: GO 19905
19893: POP
// event_OpravaHotova ( Num ) ; 111 :
19894: LD_VAR 0 1
19898: PPUSH
19899: CALL 12705 0 1
19903: GO 19936
19905: LD_INT 111
19907: DOUBLE
19908: EQUAL
19909: IFTRUE 19913
19911: GO 19920
19913: POP
// event_YashinUtoci ; 121 :
19914: CALL 14488 0 0
19918: GO 19936
19920: LD_INT 121
19922: DOUBLE
19923: EQUAL
19924: IFTRUE 19928
19926: GO 19935
19928: POP
// event_XavierPrisel ; end ;
19929: CALL 16728 0 0
19933: GO 19936
19935: POP
// end ;
19936: PPOPN 1
19938: END
// on Contact ( Side1 , Side2 ) do begin rusove_Contact ( Side1 , Side2 ) ;
19939: LD_VAR 0 1
19943: PPUSH
19944: LD_VAR 0 2
19948: PPUSH
19949: CALL 6154 0 2
// end ;
19953: PPOPN 2
19955: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
19956: LD_VAR 0 1
19960: PPUSH
19961: LD_VAR 0 2
19965: PPUSH
19966: CALL 8849 0 2
// end ;
19970: PPOPN 2
19972: END
// on StartHeal ( Un , Medic ) do begin heike_StartHeal ( Un , Medic ) ;
19973: LD_VAR 0 1
19977: PPUSH
19978: LD_VAR 0 2
19982: PPUSH
19983: CALL 19145 0 2
// end ;
19987: PPOPN 2
19989: END
// every 1 1$59 do
19990: GO 19992
19992: DISABLE
// begin RandomizeAll ;
19993: CALL_OW 11
// end ; end_of_file
19997: END
// export dif_BednyA , dif_BednyR1 , dif_BednyR2 ; export dif_HeikeBudovy , dif_HeikeAuta , dif_HeikeLidi ; export dif_HeikeovciLives , dif_HeikeovciPocet ; export dif_Cans , dif_Oil , dif_Siberit ; export dif_ArabiLevel , dif_VolnyArabi , dif_ObranciArabi ; export dif_UtokSkupina , dif_PstZbrane ; export dif_CasovacUtoku ; export dif_MaxKonvojCargo ; export function init_difficulty ; begin
19998: LD_INT 0
20000: PPUSH
// dif_BednyR1 = [ 25 , 20 , 15 ] ;
20001: LD_ADDR_EXP 37
20005: PUSH
20006: LD_INT 25
20008: PUSH
20009: LD_INT 20
20011: PUSH
20012: LD_INT 15
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: LIST
20019: ST_TO_ADDR
// dif_BednyR2 = [ 30 , 25 , 20 ] ;
20020: LD_ADDR_EXP 38
20024: PUSH
20025: LD_INT 30
20027: PUSH
20028: LD_INT 25
20030: PUSH
20031: LD_INT 20
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: ST_TO_ADDR
// dif_BednyA = [ 25 , 35 , 60 ] ;
20039: LD_ADDR_EXP 36
20043: PUSH
20044: LD_INT 25
20046: PUSH
20047: LD_INT 35
20049: PUSH
20050: LD_INT 60
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: LIST
20057: ST_TO_ADDR
// dif_HeikeBudovy = [ 8 , 5 , 2 ] ;
20058: LD_ADDR_EXP 39
20062: PUSH
20063: LD_INT 8
20065: PUSH
20066: LD_INT 5
20068: PUSH
20069: LD_INT 2
20071: PUSH
20072: EMPTY
20073: LIST
20074: LIST
20075: LIST
20076: ST_TO_ADDR
// dif_HeikeAuta = [ 2 , 1 , 0 ] ;
20077: LD_ADDR_EXP 40
20081: PUSH
20082: LD_INT 2
20084: PUSH
20085: LD_INT 1
20087: PUSH
20088: LD_INT 0
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: ST_TO_ADDR
// dif_HeikeLidi = [ 2 , 1 , 0 ] ;
20096: LD_ADDR_EXP 41
20100: PUSH
20101: LD_INT 2
20103: PUSH
20104: LD_INT 1
20106: PUSH
20107: LD_INT 0
20109: PUSH
20110: EMPTY
20111: LIST
20112: LIST
20113: LIST
20114: ST_TO_ADDR
// dif_HeikeovciLives = [ 750 , 900 , 1000 ] ;
20115: LD_ADDR_EXP 42
20119: PUSH
20120: LD_INT 750
20122: PUSH
20123: LD_INT 900
20125: PUSH
20126: LD_INT 1000
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: LIST
20133: ST_TO_ADDR
// dif_HeikeovciPocet = [ 2 , 4 , 7 ] ;
20134: LD_ADDR_EXP 43
20138: PUSH
20139: LD_INT 2
20141: PUSH
20142: LD_INT 4
20144: PUSH
20145: LD_INT 7
20147: PUSH
20148: EMPTY
20149: LIST
20150: LIST
20151: LIST
20152: ST_TO_ADDR
// dif_ArabiLevel = [ 3 , 5 , 7 ] ;
20153: LD_ADDR_EXP 47
20157: PUSH
20158: LD_INT 3
20160: PUSH
20161: LD_INT 5
20163: PUSH
20164: LD_INT 7
20166: PUSH
20167: EMPTY
20168: LIST
20169: LIST
20170: LIST
20171: ST_TO_ADDR
// dif_VolnyArabi = [ 2 , 5 , 10 ] ;
20172: LD_ADDR_EXP 48
20176: PUSH
20177: LD_INT 2
20179: PUSH
20180: LD_INT 5
20182: PUSH
20183: LD_INT 10
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: LIST
20190: ST_TO_ADDR
// dif_ObranciArabi = [ 1 , 3 , 5 ] ;
20191: LD_ADDR_EXP 49
20195: PUSH
20196: LD_INT 1
20198: PUSH
20199: LD_INT 3
20201: PUSH
20202: LD_INT 5
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: LIST
20209: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
20210: LD_ADDR_EXP 50
20214: PUSH
20215: LD_INT 3
20217: PUSH
20218: LD_INT 4
20220: PUSH
20221: LD_INT 6
20223: PUSH
20224: EMPTY
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
// dif_Cans = [ 200 , 170 , 130 ] ;
20229: LD_ADDR_EXP 44
20233: PUSH
20234: LD_INT 200
20236: PUSH
20237: LD_INT 170
20239: PUSH
20240: LD_INT 130
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: ST_TO_ADDR
// dif_Oil = [ 100 , 50 , 0 ] ;
20248: LD_ADDR_EXP 45
20252: PUSH
20253: LD_INT 100
20255: PUSH
20256: LD_INT 50
20258: PUSH
20259: LD_INT 0
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: LIST
20266: ST_TO_ADDR
// dif_Siberit = [ 100 , 100 , 100 ] ;
20267: LD_ADDR_EXP 46
20271: PUSH
20272: LD_INT 100
20274: PUSH
20275: LD_INT 100
20277: PUSH
20278: LD_INT 100
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: ST_TO_ADDR
// if VsevSaved then
20286: LD_EXP 8
20290: IFFALSE 20334
// dif_CasovacUtoku = [ [ 8 , 10 ] , [ 7 , 9 ] , [ 6 , 8 ] ] else
20292: LD_ADDR_EXP 52
20296: PUSH
20297: LD_INT 8
20299: PUSH
20300: LD_INT 10
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 7
20309: PUSH
20310: LD_INT 9
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 6
20319: PUSH
20320: LD_INT 8
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: ST_TO_ADDR
20332: GO 20382
// dif_CasovacUtoku = [ [ 8 , 8 , 7 ] , [ 8 , 7 , 6 ] , [ 4 , 5 ] ] ;
20334: LD_ADDR_EXP 52
20338: PUSH
20339: LD_INT 8
20341: PUSH
20342: LD_INT 8
20344: PUSH
20345: LD_INT 7
20347: PUSH
20348: EMPTY
20349: LIST
20350: LIST
20351: LIST
20352: PUSH
20353: LD_INT 8
20355: PUSH
20356: LD_INT 7
20358: PUSH
20359: LD_INT 6
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: LIST
20366: PUSH
20367: LD_INT 4
20369: PUSH
20370: LD_INT 5
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 30 , 50 , 80 , 100 ] , [ 30 , 60 , 75 , 100 ] ] ;
20382: LD_ADDR_EXP 51
20386: PUSH
20387: LD_INT 20
20389: PUSH
20390: LD_INT 40
20392: PUSH
20393: LD_INT 80
20395: PUSH
20396: LD_INT 100
20398: PUSH
20399: EMPTY
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: PUSH
20405: LD_INT 30
20407: PUSH
20408: LD_INT 50
20410: PUSH
20411: LD_INT 80
20413: PUSH
20414: LD_INT 100
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 30
20425: PUSH
20426: LD_INT 60
20428: PUSH
20429: LD_INT 75
20431: PUSH
20432: LD_INT 100
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: ST_TO_ADDR
// dif_MaxKonvojCargo = [ [ 5 , 200 , 100 , 0 ] , [ 5 , 160 , 60 , 0 ] , [ 5 , 50 , 50 , 0 ] ] ;
20446: LD_ADDR_EXP 53
20450: PUSH
20451: LD_INT 5
20453: PUSH
20454: LD_INT 200
20456: PUSH
20457: LD_INT 100
20459: PUSH
20460: LD_INT 0
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: LIST
20468: PUSH
20469: LD_INT 5
20471: PUSH
20472: LD_INT 160
20474: PUSH
20475: LD_INT 60
20477: PUSH
20478: LD_INT 0
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: LIST
20485: LIST
20486: PUSH
20487: LD_INT 5
20489: PUSH
20490: LD_INT 50
20492: PUSH
20493: LD_INT 50
20495: PUSH
20496: LD_INT 0
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: LIST
20503: LIST
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: LIST
20509: ST_TO_ADDR
// end ; end_of_file
20510: LD_VAR 0 1
20514: RET
// export function jdete_k_sobe ( Kdo , Kam ) ; begin
20515: LD_INT 0
20517: PPUSH
// ComMoveUnit ( Kdo , Kam ) ;
20518: LD_VAR 0 1
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL_OW 112
// while GetDistUnits ( Kdo , Kam ) > 3 do
20532: LD_VAR 0 1
20536: PPUSH
20537: LD_VAR 0 2
20541: PPUSH
20542: CALL_OW 296
20546: PUSH
20547: LD_INT 3
20549: GREATER
20550: IFFALSE 20561
// Wait ( 0 0$0.5 ) ;
20552: LD_INT 18
20554: PPUSH
20555: CALL_OW 67
20559: GO 20532
// AddComTurnUnit ( Kdo , Kam ) ;
20561: LD_VAR 0 1
20565: PPUSH
20566: LD_VAR 0 2
20570: PPUSH
20571: CALL_OW 179
// AddComTurnUnit ( Kam , Kdo ) ;
20575: LD_VAR 0 2
20579: PPUSH
20580: LD_VAR 0 1
20584: PPUSH
20585: CALL_OW 179
// end ;
20589: LD_VAR 0 3
20593: RET
// export function place_list ( List , Area ) ; var I ; begin
20594: LD_INT 0
20596: PPUSH
20597: PPUSH
// for I in List do
20598: LD_ADDR_VAR 0 4
20602: PUSH
20603: LD_VAR 0 1
20607: PUSH
20608: FOR_IN
20609: IFFALSE 20630
// PlaceUnitArea ( I , Area , false ) ;
20611: LD_VAR 0 4
20615: PPUSH
20616: LD_VAR 0 2
20620: PPUSH
20621: LD_INT 0
20623: PPUSH
20624: CALL_OW 49
20628: GO 20608
20630: POP
20631: POP
// end ;
20632: LD_VAR 0 3
20636: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20637: LD_INT 0
20639: PPUSH
20640: PPUSH
20641: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20642: LD_ADDR_VAR 0 4
20646: PUSH
20647: LD_INT 22
20649: PUSH
20650: LD_VAR 0 2
20654: PUSH
20655: EMPTY
20656: LIST
20657: LIST
20658: PUSH
20659: EMPTY
20660: LIST
20661: PPUSH
20662: CALL_OW 69
20666: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20667: LD_ADDR_VAR 0 5
20671: PUSH
20672: LD_VAR 0 4
20676: PUSH
20677: FOR_IN
20678: IFFALSE 20710
// if See ( Kdo , Jednotka ) then
20680: LD_VAR 0 1
20684: PPUSH
20685: LD_VAR 0 5
20689: PPUSH
20690: CALL_OW 292
20694: IFFALSE 20708
// begin Result = true ;
20696: LD_ADDR_VAR 0 3
20700: PUSH
20701: LD_INT 1
20703: ST_TO_ADDR
// exit ;
20704: POP
20705: POP
20706: GO 20720
// end ;
20708: GO 20677
20710: POP
20711: POP
// Result = false ;
20712: LD_ADDR_VAR 0 3
20716: PUSH
20717: LD_INT 0
20719: ST_TO_ADDR
// end ;
20720: LD_VAR 0 3
20724: RET
// export function vidi_strana_jednotky ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20725: LD_INT 0
20727: PPUSH
20728: PPUSH
20729: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20730: LD_ADDR_VAR 0 4
20734: PUSH
20735: LD_INT 22
20737: PUSH
20738: LD_VAR 0 2
20742: PUSH
20743: EMPTY
20744: LIST
20745: LIST
20746: PUSH
20747: EMPTY
20748: LIST
20749: PPUSH
20750: CALL_OW 69
20754: ST_TO_ADDR
// Result = [ ] ;
20755: LD_ADDR_VAR 0 3
20759: PUSH
20760: EMPTY
20761: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20762: LD_ADDR_VAR 0 5
20766: PUSH
20767: LD_VAR 0 4
20771: PUSH
20772: FOR_IN
20773: IFFALSE 20812
// if See ( Kdo , Jednotka ) then
20775: LD_VAR 0 1
20779: PPUSH
20780: LD_VAR 0 5
20784: PPUSH
20785: CALL_OW 292
20789: IFFALSE 20810
// Result = Result union [ Jednotka ] ;
20791: LD_ADDR_VAR 0 3
20795: PUSH
20796: LD_VAR 0 3
20800: PUSH
20801: LD_VAR 0 5
20805: PUSH
20806: EMPTY
20807: LIST
20808: UNION
20809: ST_TO_ADDR
20810: GO 20772
20812: POP
20813: POP
// end ;
20814: LD_VAR 0 3
20818: RET
// export function jednotky_blizko ( Kdo , Koho , Dalka ) ; var KohoJednotky , Jednotka ; begin
20819: LD_INT 0
20821: PPUSH
20822: PPUSH
20823: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20824: LD_ADDR_VAR 0 5
20828: PUSH
20829: LD_INT 22
20831: PUSH
20832: LD_VAR 0 2
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: PUSH
20841: EMPTY
20842: LIST
20843: PPUSH
20844: CALL_OW 69
20848: ST_TO_ADDR
// Result = [ ] ;
20849: LD_ADDR_VAR 0 4
20853: PUSH
20854: EMPTY
20855: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20856: LD_ADDR_VAR 0 6
20860: PUSH
20861: LD_VAR 0 5
20865: PUSH
20866: FOR_IN
20867: IFFALSE 20912
// if GetDistUnits ( Kdo , Jednotka ) <= Dalka then
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 6
20878: PPUSH
20879: CALL_OW 296
20883: PUSH
20884: LD_VAR 0 3
20888: LESSEQUAL
20889: IFFALSE 20910
// Result = Result union [ Jednotka ] ;
20891: LD_ADDR_VAR 0 4
20895: PUSH
20896: LD_VAR 0 4
20900: PUSH
20901: LD_VAR 0 6
20905: PUSH
20906: EMPTY
20907: LIST
20908: UNION
20909: ST_TO_ADDR
20910: GO 20866
20912: POP
20913: POP
// end ;
20914: LD_VAR 0 4
20918: RET
// export function nahoda_seznam ( Seznam ) ; begin
20919: LD_INT 0
20921: PPUSH
// if Seznam then
20922: LD_VAR 0 1
20926: IFFALSE 20954
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
20928: LD_ADDR_VAR 0 2
20932: PUSH
20933: LD_VAR 0 1
20937: PUSH
20938: LD_INT 1
20940: PPUSH
20941: LD_VAR 0 1
20945: PPUSH
20946: CALL_OW 12
20950: ARRAY
20951: ST_TO_ADDR
20952: GO 20962
// Result = 0 ;
20954: LD_ADDR_VAR 0 2
20958: PUSH
20959: LD_INT 0
20961: ST_TO_ADDR
// end ;
20962: LD_VAR 0 2
20966: RET
// export function bez_opic ( List ) ; var Opice ; begin
20967: LD_INT 0
20969: PPUSH
20970: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
20971: LD_ADDR_VAR 0 3
20975: PUSH
20976: LD_VAR 0 1
20980: PPUSH
20981: LD_INT 2
20983: PUSH
20984: LD_INT 25
20986: PUSH
20987: LD_INT 12
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: PUSH
20994: LD_INT 25
20996: PUSH
20997: LD_INT 15
20999: PUSH
21000: EMPTY
21001: LIST
21002: LIST
21003: PUSH
21004: LD_INT 25
21006: PUSH
21007: LD_INT 16
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: PUSH
21014: LD_INT 25
21016: PUSH
21017: LD_INT 17
21019: PUSH
21020: EMPTY
21021: LIST
21022: LIST
21023: PUSH
21024: EMPTY
21025: LIST
21026: LIST
21027: LIST
21028: LIST
21029: LIST
21030: PUSH
21031: EMPTY
21032: LIST
21033: PPUSH
21034: CALL_OW 72
21038: ST_TO_ADDR
// Result = List diff Opice ;
21039: LD_ADDR_VAR 0 2
21043: PUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 3
21053: DIFF
21054: ST_TO_ADDR
// end ; end_of_file
21055: LD_VAR 0 2
21059: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
21060: LD_INT 0
21062: PPUSH
21063: PPUSH
21064: PPUSH
// Result = [ ] ;
21065: LD_ADDR_VAR 0 4
21069: PUSH
21070: EMPTY
21071: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
21072: LD_ADDR_OWVAR 21
21076: PUSH
21077: LD_INT 0
21079: ST_TO_ADDR
// UC_side = side_neutral ;
21080: LD_ADDR_OWVAR 20
21084: PUSH
21085: LD_EXP 1
21089: ST_TO_ADDR
// HC_Class = Cls ;
21090: LD_ADDR_OWVAR 28
21094: PUSH
21095: LD_VAR 0 1
21099: ST_TO_ADDR
// HC_Name =  ;
21100: LD_ADDR_OWVAR 26
21104: PUSH
21105: LD_STRING 
21107: ST_TO_ADDR
// for i = 1 to Cnt do
21108: LD_ADDR_VAR 0 5
21112: PUSH
21113: DOUBLE
21114: LD_INT 1
21116: DEC
21117: ST_TO_ADDR
21118: LD_VAR 0 2
21122: PUSH
21123: FOR_TO
21124: IFFALSE 21174
// begin h = CreateHuman ;
21126: LD_ADDR_VAR 0 6
21130: PUSH
21131: CALL_OW 44
21135: ST_TO_ADDR
// Result = Result union [ h ] ;
21136: LD_ADDR_VAR 0 4
21140: PUSH
21141: LD_VAR 0 4
21145: PUSH
21146: LD_VAR 0 6
21150: PUSH
21151: EMPTY
21152: LIST
21153: UNION
21154: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
21155: LD_VAR 0 6
21159: PPUSH
21160: LD_VAR 0 3
21164: PPUSH
21165: LD_INT 0
21167: PPUSH
21168: CALL_OW 49
// end ;
21172: GO 21123
21174: POP
21175: POP
// end ;
21176: LD_VAR 0 4
21180: RET
// export function init_nature ; begin
21181: LD_INT 0
21183: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 1 , 3 ) , Les ) ;
21184: LD_INT 14
21186: PPUSH
21187: LD_INT 1
21189: PPUSH
21190: LD_INT 3
21192: PPUSH
21193: CALL_OW 12
21197: PPUSH
21198: LD_INT 10
21200: PPUSH
21201: CALL 21060 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 10 ) - Difficulty , Les ) ;
21205: LD_INT 12
21207: PPUSH
21208: LD_INT 5
21210: PPUSH
21211: LD_INT 10
21213: PPUSH
21214: CALL_OW 12
21218: PUSH
21219: LD_OWVAR 67
21223: MINUS
21224: PPUSH
21225: LD_INT 10
21227: PPUSH
21228: CALL 21060 0 3
// end ; end_of_file
21232: LD_VAR 0 1
21236: RET
// export function dialog_Start ; begin
21237: LD_INT 0
21239: PPUSH
// SayRadio ( Platonov , DStart-Pla-1 ) ;
21240: LD_EXP 20
21244: PPUSH
21245: LD_STRING DStart-Pla-1
21247: PPUSH
21248: CALL_OW 94
// end ;
21252: LD_VAR 0 1
21256: RET
// export function dialog_StartVS ; begin
21257: LD_INT 0
21259: PPUSH
// SayRadio ( Platonov , DStartVS-Pla-1 ) ;
21260: LD_EXP 20
21264: PPUSH
21265: LD_STRING DStartVS-Pla-1
21267: PPUSH
21268: CALL_OW 94
// end ;
21272: LD_VAR 0 1
21276: RET
// export function dialog_StartNV ; begin
21277: LD_INT 0
21279: PPUSH
// SayRadio ( Platonov , DStartNV-Pla-1 ) ;
21280: LD_EXP 20
21284: PPUSH
21285: LD_STRING DStartNV-Pla-1
21287: PPUSH
21288: CALL_OW 94
// end ;
21292: LD_VAR 0 1
21296: RET
// export function dialog_Start2 ; begin
21297: LD_INT 0
21299: PPUSH
// SayRadio ( Platonov , DStart2-Pla-1 ) ;
21300: LD_EXP 20
21304: PPUSH
21305: LD_STRING DStart2-Pla-1
21307: PPUSH
21308: CALL_OW 94
// Say ( Burlak , DStart2-Bur-1 ) ;
21312: LD_EXP 10
21316: PPUSH
21317: LD_STRING DStart2-Bur-1
21319: PPUSH
21320: CALL_OW 88
// end ;
21324: LD_VAR 0 1
21328: RET
// export function dialog_MeetVsevolodVS ; begin
21329: LD_INT 0
21331: PPUSH
// Say ( Burlak , DMeetVsevolodVS-Bur-1 ) ;
21332: LD_EXP 10
21336: PPUSH
21337: LD_STRING DMeetVsevolodVS-Bur-1
21339: PPUSH
21340: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-1 ) ;
21344: LD_EXP 11
21348: PPUSH
21349: LD_STRING DMeetVsevolodVS-Vse-1
21351: PPUSH
21352: CALL_OW 88
// Say ( Burlak , DMeetVsevolodVS-Bur-2 ) ;
21356: LD_EXP 10
21360: PPUSH
21361: LD_STRING DMeetVsevolodVS-Bur-2
21363: PPUSH
21364: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-2 ) ;
21368: LD_EXP 11
21372: PPUSH
21373: LD_STRING DMeetVsevolodVS-Vse-2
21375: PPUSH
21376: CALL_OW 88
// end ;
21380: LD_VAR 0 1
21384: RET
// export function dialog_StasisVS ; begin
21385: LD_INT 0
21387: PPUSH
// if Titov and IsOK ( Titov ) then
21388: LD_EXP 19
21392: PUSH
21393: LD_EXP 19
21397: PPUSH
21398: CALL_OW 302
21402: AND
21403: IFFALSE 21419
// Say ( Titov , DStasisVS-Tit-1 ) else
21405: LD_EXP 19
21409: PPUSH
21410: LD_STRING DStasisVS-Tit-1
21412: PPUSH
21413: CALL_OW 88
21417: GO 21431
// Say ( Yelena , DStasisVS-Kir-1 ) ;
21419: LD_EXP 13
21423: PPUSH
21424: LD_STRING DStasisVS-Kir-1
21426: PPUSH
21427: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-1 ) ;
21431: LD_EXP 10
21435: PPUSH
21436: LD_STRING DStasisVS-Bur-1
21438: PPUSH
21439: CALL_OW 88
// if Titov and IsOK ( Titov ) then
21443: LD_EXP 19
21447: PUSH
21448: LD_EXP 19
21452: PPUSH
21453: CALL_OW 302
21457: AND
21458: IFFALSE 21474
// Say ( Titov , DStasisVS-Tit-2 ) else
21460: LD_EXP 19
21464: PPUSH
21465: LD_STRING DStasisVS-Tit-2
21467: PPUSH
21468: CALL_OW 88
21472: GO 21486
// Say ( Yelena , DStasisVS-Kir-2 ) ;
21474: LD_EXP 13
21478: PPUSH
21479: LD_STRING DStasisVS-Kir-2
21481: PPUSH
21482: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-2 ) ;
21486: LD_EXP 10
21490: PPUSH
21491: LD_STRING DStasisVS-Bur-2
21493: PPUSH
21494: CALL_OW 88
// wait ( 0 0$3 ) ;
21498: LD_INT 105
21500: PPUSH
21501: CALL_OW 67
// SayRadio ( Popov , DStasisVS-Pop-2 ) ;
21505: LD_EXP 12
21509: PPUSH
21510: LD_STRING DStasisVS-Pop-2
21512: PPUSH
21513: CALL_OW 94
// if Gleb and IsOK ( Gleb ) then
21517: LD_EXP 14
21521: PUSH
21522: LD_EXP 14
21526: PPUSH
21527: CALL_OW 302
21531: AND
21532: IFFALSE 21546
// Say ( Gleb , DStasisVS-Glb-2 ) ;
21534: LD_EXP 14
21538: PPUSH
21539: LD_STRING DStasisVS-Glb-2
21541: PPUSH
21542: CALL_OW 88
// end ;
21546: LD_VAR 0 1
21550: RET
// export function dialog_SeviSaved ; begin
21551: LD_INT 0
21553: PPUSH
// Say ( Burlak , DSeviSaved-Bur-1 ) ;
21554: LD_EXP 10
21558: PPUSH
21559: LD_STRING DSeviSaved-Bur-1
21561: PPUSH
21562: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-1 ) ;
21566: LD_EXP 11
21570: PPUSH
21571: LD_STRING DSeviSaved-Vse-1
21573: PPUSH
21574: CALL_OW 88
// Say ( Burlak , DSeviSaved-Bur-2 ) ;
21578: LD_EXP 10
21582: PPUSH
21583: LD_STRING DSeviSaved-Bur-2
21585: PPUSH
21586: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-2 ) ;
21590: LD_EXP 11
21594: PPUSH
21595: LD_STRING DSeviSaved-Vse-2
21597: PPUSH
21598: CALL_OW 88
// end ;
21602: LD_VAR 0 1
21606: RET
// export function dialog_MeetXavier ; begin
21607: LD_INT 0
21609: PPUSH
// Say ( Xavier , DMeetXavier-Xav-1 ) ;
21610: LD_EXP 25
21614: PPUSH
21615: LD_STRING DMeetXavier-Xav-1
21617: PPUSH
21618: CALL_OW 88
// Say ( Yelena , DMeetXavier-Kir-1 ) ;
21622: LD_EXP 13
21626: PPUSH
21627: LD_STRING DMeetXavier-Kir-1
21629: PPUSH
21630: CALL_OW 88
// Say ( Xavier , DMeetXavier-Xav-2 ) ;
21634: LD_EXP 25
21638: PPUSH
21639: LD_STRING DMeetXavier-Xav-2
21641: PPUSH
21642: CALL_OW 88
// end ;
21646: LD_VAR 0 1
21650: RET
// export function query_Xavier ; begin
21651: LD_INT 0
21653: PPUSH
// Result = Query ( QXavier ) ;
21654: LD_ADDR_VAR 0 1
21658: PUSH
21659: LD_STRING QXavier
21661: PPUSH
21662: CALL_OW 97
21666: ST_TO_ADDR
// end ;
21667: LD_VAR 0 1
21671: RET
// export function dialog_QrXavier1 ; begin
21672: LD_INT 0
21674: PPUSH
// Say ( Burlak , DQrXavier#1-Bur-1 ) ;
21675: LD_EXP 10
21679: PPUSH
21680: LD_STRING DQrXavier#1-Bur-1
21682: PPUSH
21683: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-1 ) ;
21687: LD_EXP 13
21691: PPUSH
21692: LD_STRING DQrXavier#1-Kir-1
21694: PPUSH
21695: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-1 ) ;
21699: LD_EXP 25
21703: PPUSH
21704: LD_STRING DQrXavier#1-Xav-1
21706: PPUSH
21707: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-2 ) ;
21711: LD_EXP 13
21715: PPUSH
21716: LD_STRING DQrXavier#1-Kir-2
21718: PPUSH
21719: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-2 ) ;
21723: LD_EXP 25
21727: PPUSH
21728: LD_STRING DQrXavier#1-Xav-2
21730: PPUSH
21731: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-3 ) ;
21735: LD_EXP 13
21739: PPUSH
21740: LD_STRING DQrXavier#1-Kir-3
21742: PPUSH
21743: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-3 ) ;
21747: LD_EXP 25
21751: PPUSH
21752: LD_STRING DQrXavier#1-Xav-3
21754: PPUSH
21755: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-4 ) ;
21759: LD_EXP 13
21763: PPUSH
21764: LD_STRING DQrXavier#1-Kir-4
21766: PPUSH
21767: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
21771: LD_EXP 14
21775: PUSH
21776: LD_EXP 14
21780: PPUSH
21781: CALL_OW 302
21785: AND
21786: IFFALSE 21800
// Say ( Gleb , DQrXavier#1-Glb-4 ) ;
21788: LD_EXP 14
21792: PPUSH
21793: LD_STRING DQrXavier#1-Glb-4
21795: PPUSH
21796: CALL_OW 88
// end ;
21800: LD_VAR 0 1
21804: RET
// export function dialog_QrXavier2 ; begin
21805: LD_INT 0
21807: PPUSH
// Say ( Burlak , DQrXavier#2-Bur-1 ) ;
21808: LD_EXP 10
21812: PPUSH
21813: LD_STRING DQrXavier#2-Bur-1
21815: PPUSH
21816: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-1 ) ;
21820: LD_EXP 13
21824: PPUSH
21825: LD_STRING DQrXavier#2-Kir-1
21827: PPUSH
21828: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-1 ) ;
21832: LD_EXP 25
21836: PPUSH
21837: LD_STRING DQrXavier#2-Xav-1
21839: PPUSH
21840: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-2 ) ;
21844: LD_EXP 13
21848: PPUSH
21849: LD_STRING DQrXavier#2-Kir-2
21851: PPUSH
21852: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-2 ) ;
21856: LD_EXP 25
21860: PPUSH
21861: LD_STRING DQrXavier#2-Xav-2
21863: PPUSH
21864: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-3 ) ;
21868: LD_EXP 13
21872: PPUSH
21873: LD_STRING DQrXavier#2-Kir-3
21875: PPUSH
21876: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-3 ) ;
21880: LD_EXP 25
21884: PPUSH
21885: LD_STRING DQrXavier#2-Xav-3
21887: PPUSH
21888: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-4 ) ;
21892: LD_EXP 13
21896: PPUSH
21897: LD_STRING DQrXavier#2-Kir-4
21899: PPUSH
21900: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-4 ) ;
21904: LD_EXP 25
21908: PPUSH
21909: LD_STRING DQrXavier#2-Xav-4
21911: PPUSH
21912: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-5 ) ;
21916: LD_EXP 13
21920: PPUSH
21921: LD_STRING DQrXavier#2-Kir-5
21923: PPUSH
21924: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
21928: LD_EXP 14
21932: PUSH
21933: LD_EXP 14
21937: PPUSH
21938: CALL_OW 302
21942: AND
21943: IFFALSE 21957
// Say ( Gleb , DQrXavier#2-Glb-5 ) ;
21945: LD_EXP 14
21949: PPUSH
21950: LD_STRING DQrXavier#2-Glb-5
21952: PPUSH
21953: CALL_OW 88
// end ;
21957: LD_VAR 0 1
21961: RET
// export function dialog_PointXavier ; begin
21962: LD_INT 0
21964: PPUSH
// if IsOk ( Yelena ) then
21965: LD_EXP 13
21969: PPUSH
21970: CALL_OW 302
21974: IFFALSE 22000
// begin Say ( Xavier , DPointXavier-Xav-1 ) ;
21976: LD_EXP 25
21980: PPUSH
21981: LD_STRING DPointXavier-Xav-1
21983: PPUSH
21984: CALL_OW 88
// Say ( Yelena , DPointXavier-Kir-1 ) ;
21988: LD_EXP 13
21992: PPUSH
21993: LD_STRING DPointXavier-Kir-1
21995: PPUSH
21996: CALL_OW 88
// end ; Say ( Xavier , DPointXavier-Xav-2 ) ;
22000: LD_EXP 25
22004: PPUSH
22005: LD_STRING DPointXavier-Xav-2
22007: PPUSH
22008: CALL_OW 88
// end ;
22012: LD_VAR 0 1
22016: RET
// export function query_QActivateXavier ; begin
22017: LD_INT 0
22019: PPUSH
// Result = Query ( QActivateXavier ) ;
22020: LD_ADDR_VAR 0 1
22024: PUSH
22025: LD_STRING QActivateXavier
22027: PPUSH
22028: CALL_OW 97
22032: ST_TO_ADDR
// end ;
22033: LD_VAR 0 1
22037: RET
// export function dialog_QrActivateXavier1 ; begin
22038: LD_INT 0
22040: PPUSH
// Say ( Burlak , DQrActivateXavier#1-Bur-1 ) ;
22041: LD_EXP 10
22045: PPUSH
22046: LD_STRING DQrActivateXavier#1-Bur-1
22048: PPUSH
22049: CALL_OW 88
// end ;
22053: LD_VAR 0 1
22057: RET
// export function dialog_QrActivateXavier2 ; begin
22058: LD_INT 0
22060: PPUSH
// Say ( Burlak , DQrActivateXavier#2-Bur-1 ) ;
22061: LD_EXP 10
22065: PPUSH
22066: LD_STRING DQrActivateXavier#2-Bur-1
22068: PPUSH
22069: CALL_OW 88
// end ;
22073: LD_VAR 0 1
22077: RET
// export function dialog_YashinArrives ; begin
22078: LD_INT 0
22080: PPUSH
// Say ( Yashin , DYashinArrives-Yas-1 ) ;
22081: LD_EXP 34
22085: PPUSH
22086: LD_STRING DYashinArrives-Yas-1
22088: PPUSH
22089: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22093: LD_EXP 8
22097: PUSH
22098: LD_EXP 11
22102: PPUSH
22103: CALL_OW 302
22107: AND
22108: IFFALSE 22124
// Say ( Vsevolod , DYashinArrives-Vse-1 ) else
22110: LD_EXP 11
22114: PPUSH
22115: LD_STRING DYashinArrives-Vse-1
22117: PPUSH
22118: CALL_OW 88
22122: GO 22136
// Say ( Burlak , DYashinArrives-Bur-1 ) ;
22124: LD_EXP 10
22128: PPUSH
22129: LD_STRING DYashinArrives-Bur-1
22131: PPUSH
22132: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-2 ) ;
22136: LD_EXP 34
22140: PPUSH
22141: LD_STRING DYashinArrives-Yas-2
22143: PPUSH
22144: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22148: LD_EXP 8
22152: PUSH
22153: LD_EXP 11
22157: PPUSH
22158: CALL_OW 302
22162: AND
22163: IFFALSE 22203
// begin Say ( Vsevolod , DYashinArrives-Vse-2 ) ;
22165: LD_EXP 11
22169: PPUSH
22170: LD_STRING DYashinArrives-Vse-2
22172: PPUSH
22173: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-3 ) ;
22177: LD_EXP 34
22181: PPUSH
22182: LD_STRING DYashinArrives-Yas-3
22184: PPUSH
22185: CALL_OW 88
// Say ( Vsevolod , DYashinArrives-Vse-3 ) ;
22189: LD_EXP 11
22193: PPUSH
22194: LD_STRING DYashinArrives-Vse-3
22196: PPUSH
22197: CALL_OW 88
// end else
22201: GO 22251
// begin Say ( Burlak , DYashinArrives-Bur-3 ) ;
22203: LD_EXP 10
22207: PPUSH
22208: LD_STRING DYashinArrives-Bur-3
22210: PPUSH
22211: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-4 ) ;
22215: LD_EXP 34
22219: PPUSH
22220: LD_STRING DYashinArrives-Yas-4
22222: PPUSH
22223: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-4 ) ;
22227: LD_EXP 10
22231: PPUSH
22232: LD_STRING DYashinArrives-Bur-4
22234: PPUSH
22235: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-5 ) ;
22239: LD_EXP 34
22243: PPUSH
22244: LD_STRING DYashinArrives-Yas-5
22246: PPUSH
22247: CALL_OW 88
// end ; Say ( Burlak , DYashinArrives-Bur-5 ) ;
22251: LD_EXP 10
22255: PPUSH
22256: LD_STRING DYashinArrives-Bur-5
22258: PPUSH
22259: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-6 ) ;
22263: LD_EXP 34
22267: PPUSH
22268: LD_STRING DYashinArrives-Yas-6
22270: PPUSH
22271: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-6 ) ;
22275: LD_EXP 10
22279: PPUSH
22280: LD_STRING DYashinArrives-Bur-6
22282: PPUSH
22283: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-7 ) ;
22287: LD_EXP 34
22291: PPUSH
22292: LD_STRING DYashinArrives-Yas-7
22294: PPUSH
22295: CALL_OW 88
// end ;
22299: LD_VAR 0 1
22303: RET
// export function query_YashinHelp ; begin
22304: LD_INT 0
22306: PPUSH
// Result = Query ( QYashinHelp ) ;
22307: LD_ADDR_VAR 0 1
22311: PUSH
22312: LD_STRING QYashinHelp
22314: PPUSH
22315: CALL_OW 97
22319: ST_TO_ADDR
// end ;
22320: LD_VAR 0 1
22324: RET
// export function query_YashinHelpNB ; begin
22325: LD_INT 0
22327: PPUSH
// Result = SelectiveQuery ( QYashinHelp , [ 2 , 3 ] ) ;
22328: LD_ADDR_VAR 0 1
22332: PUSH
22333: LD_STRING QYashinHelp
22335: PPUSH
22336: LD_INT 2
22338: PUSH
22339: LD_INT 3
22341: PUSH
22342: EMPTY
22343: LIST
22344: LIST
22345: PPUSH
22346: CALL_OW 98
22350: ST_TO_ADDR
// end ;
22351: LD_VAR 0 1
22355: RET
// export function dialog_QrYashinHelp1 ; begin
22356: LD_INT 0
22358: PPUSH
// Say ( Burlak , DQrYashinHelp#1-Bur-1 ) ;
22359: LD_EXP 10
22363: PPUSH
22364: LD_STRING DQrYashinHelp#1-Bur-1
22366: PPUSH
22367: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-1 ) ;
22371: LD_EXP 34
22375: PPUSH
22376: LD_STRING DQrYashinHelp#1-Yas-1
22378: PPUSH
22379: CALL_OW 88
// Say ( Burlak , DQrYashinHelp#1-Bur-2 ) ;
22383: LD_EXP 10
22387: PPUSH
22388: LD_STRING DQrYashinHelp#1-Bur-2
22390: PPUSH
22391: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-2 ) ;
22395: LD_EXP 34
22399: PPUSH
22400: LD_STRING DQrYashinHelp#1-Yas-2
22402: PPUSH
22403: CALL_OW 88
// end ;
22407: LD_VAR 0 1
22411: RET
// export function dialog_QrYashinHelp2 ; begin
22412: LD_INT 0
22414: PPUSH
// Say ( Burlak , DQrYashinHelp#2-Bur-1 ) ;
22415: LD_EXP 10
22419: PPUSH
22420: LD_STRING DQrYashinHelp#2-Bur-1
22422: PPUSH
22423: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#2-Yas-1 ) ;
22427: LD_EXP 34
22431: PPUSH
22432: LD_STRING DQrYashinHelp#2-Yas-1
22434: PPUSH
22435: CALL_OW 88
// end ;
22439: LD_VAR 0 1
22443: RET
// export function dialog_QrYashinHelp3 ; begin
22444: LD_INT 0
22446: PPUSH
// Say ( Burlak , DQrYashinHelp#3-Bur-1 ) ;
22447: LD_EXP 10
22451: PPUSH
22452: LD_STRING DQrYashinHelp#3-Bur-1
22454: PPUSH
22455: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#3-Yas-1 ) ;
22459: LD_EXP 34
22463: PPUSH
22464: LD_STRING DQrYashinHelp#3-Yas-1
22466: PPUSH
22467: CALL_OW 88
// end ;
22471: LD_VAR 0 1
22475: RET
// var BylHint ; export function dialog_YashinLeave ; begin
22476: LD_INT 0
22478: PPUSH
// Say ( Yashin , DYashinLeave-Yas-1 ) ;
22479: LD_EXP 34
22483: PPUSH
22484: LD_STRING DYashinLeave-Yas-1
22486: PPUSH
22487: CALL_OW 88
// Say ( Burlak , DYashinLeave-Bur-1 ) ;
22491: LD_EXP 10
22495: PPUSH
22496: LD_STRING DYashinLeave-Bur-1
22498: PPUSH
22499: CALL_OW 88
// if not BylHint then
22503: LD_LOC 56
22507: NOT
22508: IFFALSE 22525
// begin Hint ( YashinVeh ) ;
22510: LD_STRING YashinVeh
22512: PPUSH
22513: CALL_OW 339
// BylHint = true ;
22517: LD_ADDR_LOC 56
22521: PUSH
22522: LD_INT 1
22524: ST_TO_ADDR
// end ; end ;
22525: LD_VAR 0 1
22529: RET
// export function dialog_YashinAttack ; begin
22530: LD_INT 0
22532: PPUSH
// Say ( Burlak , DYashinAttack-Bur-1 ) ;
22533: LD_EXP 10
22537: PPUSH
22538: LD_STRING DYashinAttack-Bur-1
22540: PPUSH
22541: CALL_OW 88
// end ;
22545: LD_VAR 0 1
22549: RET
// export function dialog_HeikeObj ; begin
22550: LD_INT 0
22552: PPUSH
// SayRadio ( Popov , DHeikeObj-Pop-1 ) ;
22553: LD_EXP 12
22557: PPUSH
22558: LD_STRING DHeikeObj-Pop-1
22560: PPUSH
22561: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-1 ) ;
22565: LD_EXP 10
22569: PPUSH
22570: LD_STRING DHeikeObj-Bur-1
22572: PPUSH
22573: CALL_OW 88
// SayRadio ( Popov , DHeikeObj-Pop-2 ) ;
22577: LD_EXP 12
22581: PPUSH
22582: LD_STRING DHeikeObj-Pop-2
22584: PPUSH
22585: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-2 ) ;
22589: LD_EXP 10
22593: PPUSH
22594: LD_STRING DHeikeObj-Bur-2
22596: PPUSH
22597: CALL_OW 88
// end ;
22601: LD_VAR 0 1
22605: RET
// export function dialog_HeikeCapt ; begin
22606: LD_INT 0
22608: PPUSH
// Say ( Heike , DHeikeCapt-Hke-1 ) ;
22609: LD_EXP 26
22613: PPUSH
22614: LD_STRING DHeikeCapt-Hke-1
22616: PPUSH
22617: CALL_OW 88
// Say ( Burlak , DHeikeCapt-Bur-1 ) ;
22621: LD_EXP 10
22625: PPUSH
22626: LD_STRING DHeikeCapt-Bur-1
22628: PPUSH
22629: CALL_OW 88
// Say ( Heike , DHeikeCapt-Hke-2 ) ;
22633: LD_EXP 26
22637: PPUSH
22638: LD_STRING DHeikeCapt-Hke-2
22640: PPUSH
22641: CALL_OW 88
// end ; end_of_file
22645: LD_VAR 0 1
22649: RET
// every 0 0$2 + 0 0$0.1 do
22650: GO 22652
22652: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
22653: LD_INT 22
22655: PUSH
22656: LD_INT 3
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 2
22665: PUSH
22666: LD_INT 25
22668: PUSH
22669: LD_INT 12
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PUSH
22676: LD_INT 25
22678: PUSH
22679: LD_INT 16
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: PUSH
22686: LD_INT 25
22688: PUSH
22689: LD_INT 15
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PUSH
22696: LD_INT 25
22698: PUSH
22699: LD_INT 17
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: PUSH
22713: EMPTY
22714: LIST
22715: LIST
22716: PPUSH
22717: CALL_OW 69
22721: PUSH
22722: LD_INT 22
22724: PUSH
22725: LD_INT 3
22727: PUSH
22728: EMPTY
22729: LIST
22730: LIST
22731: PUSH
22732: LD_INT 21
22734: PUSH
22735: LD_INT 1
22737: PUSH
22738: EMPTY
22739: LIST
22740: LIST
22741: PUSH
22742: LD_INT 3
22744: PUSH
22745: LD_INT 2
22747: PUSH
22748: LD_INT 25
22750: PUSH
22751: LD_INT 12
22753: PUSH
22754: EMPTY
22755: LIST
22756: LIST
22757: PUSH
22758: LD_INT 25
22760: PUSH
22761: LD_INT 16
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: PUSH
22768: LD_INT 25
22770: PUSH
22771: LD_INT 15
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: PUSH
22778: LD_INT 25
22780: PUSH
22781: LD_INT 17
22783: PUSH
22784: EMPTY
22785: LIST
22786: LIST
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: LIST
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: LIST
22803: PPUSH
22804: CALL_OW 69
22808: GREATER
22809: IFFALSE 22820
// begin SetAchievement ( ACH_POTA ) ;
22811: LD_STRING ACH_POTA
22813: PPUSH
22814: CALL_OW 543
// exit ;
22818: GO 22821
// end ; enable ;
22820: ENABLE
// end ;
22821: END

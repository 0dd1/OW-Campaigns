// export side_Neutral , side_Ru , side_Ru2 , side_Ar , side_Xavier , side_Heike , side_Strazci ; export VsevSaved , HeikeCaptured ; export Burlak , Vsevolod , Popov , Yelena , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin ; export Rusaci , WithVsevolod ; export Konvoj ; export Xavier , Heike , Heikeovci ; export ContactIn5Min , PropaslQuickly ; export Minuty ; var FalesnaYelena ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// end ;
  74: LD_VAR 0 2
  78: RET
// function load_set ( Ident ) ; begin
  79: LD_INT 0
  81: PPUSH
// if TestCharacters ( Ident ) then
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL_OW 28
  91: IFFALSE 110
// Result = CreateCharacterSet ( Ident ) else
  93: LD_ADDR_VAR 0 2
  97: PUSH
  98: LD_VAR 0 1
 102: PPUSH
 103: CALL_OW 31
 107: ST_TO_ADDR
 108: GO 117
// Result = [ ] ;
 110: LD_ADDR_VAR 0 2
 114: PUSH
 115: EMPTY
 116: ST_TO_ADDR
// end ;
 117: LD_VAR 0 2
 121: RET
// function save_char ( Handle , Ident ) ; begin
 122: LD_INT 0
 124: PPUSH
// if Handle then
 125: LD_VAR 0 1
 129: IFFALSE 148
// SaveCharacters ( [ Handle ] , Ident ) ;
 131: LD_VAR 0 1
 135: PUSH
 136: EMPTY
 137: LIST
 138: PPUSH
 139: LD_VAR 0 2
 143: PPUSH
 144: CALL_OW 38
// end ;
 148: LD_VAR 0 3
 152: RET
// function vytvor_yelenu ; begin
 153: LD_INT 0
 155: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 156: LD_ADDR_OWVAR 21
 160: PUSH
 161: LD_INT 3
 163: ST_TO_ADDR
// UC_Side = side_Ru2 ;
 164: LD_ADDR_OWVAR 20
 168: PUSH
 169: LD_EXP 3
 173: ST_TO_ADDR
// HC_name = Yelena Trajkov ;
 174: LD_ADDR_OWVAR 26
 178: PUSH
 179: LD_STRING Yelena Trajkov
 181: ST_TO_ADDR
// HC_sex = SEX_FEMALE ;
 182: LD_ADDR_OWVAR 27
 186: PUSH
 187: LD_INT 2
 189: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 190: LD_ADDR_OWVAR 28
 194: PUSH
 195: LD_INT 1
 197: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
 198: LD_INT 5
 200: PPUSH
 201: CALL_OW 375
// Result = CreateHuman ;
 205: LD_ADDR_VAR 0 1
 209: PUSH
 210: CALL_OW 44
 214: ST_TO_ADDR
// end ;
 215: LD_VAR 0 1
 219: RET
// function load_konvoj ; var Convoy_06 , Spec , Tmp ; var MaxCnt , MaxCans , MaxOil , MaxSib , Cans , Oil , Sib ; var TedCans , TedOil , TedSib ; begin
 220: LD_INT 0
 222: PPUSH
 223: PPUSH
 224: PPUSH
 225: PPUSH
 226: PPUSH
 227: PPUSH
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
 235: PPUSH
// Convoy_06 = LoadVariable ( Convoy_06 , [ ] ) ;
 236: LD_ADDR_VAR 0 2
 240: PUSH
 241: LD_STRING Convoy_06
 243: PPUSH
 244: EMPTY
 245: PPUSH
 246: CALL_OW 30
 250: ST_TO_ADDR
// DeleteVariable ( Convoy_06 ) ;
 251: LD_STRING Convoy_06
 253: PPUSH
 254: CALL_OW 41
// if not Convoy_06 then
 258: LD_VAR 0 2
 262: NOT
 263: IFFALSE 377
// Convoy_06 = [ [ NATION_RUSSIAN , RU_HEAVY_MACHINE_GUN , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 0 , 0 , 0 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 30 , 50 , 20 ] , [ NATION_RUSSIAN , RU_CARGO_BAY , CONTROL_MANUAL , ENGINE_COMBUSTION , RU_MEDIUM_WHEELED , 40 , 50 , 10 ] ] ;
 265: LD_ADDR_VAR 0 2
 269: PUSH
 270: LD_INT 3
 272: PUSH
 273: LD_INT 42
 275: PUSH
 276: LD_INT 1
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 21
 284: PUSH
 285: LD_INT 0
 287: PUSH
 288: LD_INT 0
 290: PUSH
 291: LD_INT 0
 293: PUSH
 294: EMPTY
 295: LIST
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_INT 3
 306: PUSH
 307: LD_INT 51
 309: PUSH
 310: LD_INT 1
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 30
 321: PUSH
 322: LD_INT 50
 324: PUSH
 325: LD_INT 20
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: LIST
 336: LIST
 337: PUSH
 338: LD_INT 3
 340: PUSH
 341: LD_INT 51
 343: PUSH
 344: LD_INT 1
 346: PUSH
 347: LD_INT 1
 349: PUSH
 350: LD_INT 21
 352: PUSH
 353: LD_INT 40
 355: PUSH
 356: LD_INT 50
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: EMPTY
 363: LIST
 364: LIST
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: LIST
 376: ST_TO_ADDR
// UC_Side = side_Ru ;
 377: LD_ADDR_OWVAR 20
 381: PUSH
 382: LD_EXP 2
 386: ST_TO_ADDR
// Konvoj = [ ] ;
 387: LD_ADDR_EXP 24
 391: PUSH
 392: EMPTY
 393: ST_TO_ADDR
// Tmp = dif_MaxKonvojCargo [ Difficulty ] ;
 394: LD_ADDR_VAR 0 4
 398: PUSH
 399: LD_EXP 53
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// MaxCnt = Tmp [ 1 ] ;
 410: LD_ADDR_VAR 0 5
 414: PUSH
 415: LD_VAR 0 4
 419: PUSH
 420: LD_INT 1
 422: ARRAY
 423: ST_TO_ADDR
// MaxCans = Tmp [ 2 ] ;
 424: LD_ADDR_VAR 0 6
 428: PUSH
 429: LD_VAR 0 4
 433: PUSH
 434: LD_INT 2
 436: ARRAY
 437: ST_TO_ADDR
// MaxOil = Tmp [ 3 ] ;
 438: LD_ADDR_VAR 0 7
 442: PUSH
 443: LD_VAR 0 4
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: ST_TO_ADDR
// MaxSib = Tmp [ 4 ] ;
 452: LD_ADDR_VAR 0 8
 456: PUSH
 457: LD_VAR 0 4
 461: PUSH
 462: LD_INT 4
 464: ARRAY
 465: ST_TO_ADDR
// for Spec in Convoy_06 do
 466: LD_ADDR_VAR 0 3
 470: PUSH
 471: LD_VAR 0 2
 475: PUSH
 476: FOR_IN
 477: IFFALSE 657
// begin UC_Nation = Spec [ 1 ] ;
 479: LD_ADDR_OWVAR 21
 483: PUSH
 484: LD_VAR 0 3
 488: PUSH
 489: LD_INT 1
 491: ARRAY
 492: ST_TO_ADDR
// VC_Weapon = Spec [ 2 ] ;
 493: LD_ADDR_OWVAR 40
 497: PUSH
 498: LD_VAR 0 3
 502: PUSH
 503: LD_INT 2
 505: ARRAY
 506: ST_TO_ADDR
// VC_Control = Spec [ 3 ] ;
 507: LD_ADDR_OWVAR 38
 511: PUSH
 512: LD_VAR 0 3
 516: PUSH
 517: LD_INT 3
 519: ARRAY
 520: ST_TO_ADDR
// VC_Engine = Spec [ 4 ] ;
 521: LD_ADDR_OWVAR 39
 525: PUSH
 526: LD_VAR 0 3
 530: PUSH
 531: LD_INT 4
 533: ARRAY
 534: ST_TO_ADDR
// VC_Chassis = Spec [ 5 ] ;
 535: LD_ADDR_OWVAR 37
 539: PUSH
 540: LD_VAR 0 3
 544: PUSH
 545: LD_INT 5
 547: ARRAY
 548: ST_TO_ADDR
// Tmp = CreateVehicle ;
 549: LD_ADDR_VAR 0 4
 553: PUSH
 554: CALL_OW 45
 558: ST_TO_ADDR
// AddCargo ( Tmp , MAT_CANS , Spec [ 6 ] ) ;
 559: LD_VAR 0 4
 563: PPUSH
 564: LD_INT 1
 566: PPUSH
 567: LD_VAR 0 3
 571: PUSH
 572: LD_INT 6
 574: ARRAY
 575: PPUSH
 576: CALL_OW 291
// AddCargo ( Tmp , MAT_OIL , Spec [ 7 ] ) ;
 580: LD_VAR 0 4
 584: PPUSH
 585: LD_INT 2
 587: PPUSH
 588: LD_VAR 0 3
 592: PUSH
 593: LD_INT 7
 595: ARRAY
 596: PPUSH
 597: CALL_OW 291
// AddCargo ( Tmp , MAT_SIBERIT , Spec [ 8 ] ) ;
 601: LD_VAR 0 4
 605: PPUSH
 606: LD_INT 3
 608: PPUSH
 609: LD_VAR 0 3
 613: PUSH
 614: LD_INT 8
 616: ARRAY
 617: PPUSH
 618: CALL_OW 291
// Konvoj = Konvoj union [ Tmp ] ;
 622: LD_ADDR_EXP 24
 626: PUSH
 627: LD_EXP 24
 631: PUSH
 632: LD_VAR 0 4
 636: PUSH
 637: EMPTY
 638: LIST
 639: UNION
 640: ST_TO_ADDR
// if Konvoj >= MaxCnt then
 641: LD_EXP 24
 645: PUSH
 646: LD_VAR 0 5
 650: GREATEREQUAL
 651: IFFALSE 655
// break ;
 653: GO 657
// end ;
 655: GO 476
 657: POP
 658: POP
// Cans = 0 ;
 659: LD_ADDR_VAR 0 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// Oil = 0 ;
 667: LD_ADDR_VAR 0 10
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// Sib = 0 ;
 675: LD_ADDR_VAR 0 11
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// for Spec in Konvoj do
 683: LD_ADDR_VAR 0 3
 687: PUSH
 688: LD_EXP 24
 692: PUSH
 693: FOR_IN
 694: IFFALSE 998
// begin TedCans = GetCargo ( Spec , MAT_CANS ) ;
 696: LD_ADDR_VAR 0 12
 700: PUSH
 701: LD_VAR 0 3
 705: PPUSH
 706: LD_INT 1
 708: PPUSH
 709: CALL_OW 289
 713: ST_TO_ADDR
// TedOil = GetCargo ( Spec , MAT_OIL ) ;
 714: LD_ADDR_VAR 0 13
 718: PUSH
 719: LD_VAR 0 3
 723: PPUSH
 724: LD_INT 2
 726: PPUSH
 727: CALL_OW 289
 731: ST_TO_ADDR
// TedSib = GetCargo ( Spec , MAT_SIBERIT ) ;
 732: LD_ADDR_VAR 0 14
 736: PUSH
 737: LD_VAR 0 3
 741: PPUSH
 742: LD_INT 3
 744: PPUSH
 745: CALL_OW 289
 749: ST_TO_ADDR
// if Cans + TedCans > MaxCans then
 750: LD_VAR 0 9
 754: PUSH
 755: LD_VAR 0 12
 759: PLUS
 760: PUSH
 761: LD_VAR 0 6
 765: GREATER
 766: IFFALSE 784
// TedCans = MaxCans - Cans ;
 768: LD_ADDR_VAR 0 12
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_VAR 0 9
 782: MINUS
 783: ST_TO_ADDR
// if Oil + TedOil > MaxOil then
 784: LD_VAR 0 10
 788: PUSH
 789: LD_VAR 0 13
 793: PLUS
 794: PUSH
 795: LD_VAR 0 7
 799: GREATER
 800: IFFALSE 818
// TedOil = MaxOil - Oil ;
 802: LD_ADDR_VAR 0 13
 806: PUSH
 807: LD_VAR 0 7
 811: PUSH
 812: LD_VAR 0 10
 816: MINUS
 817: ST_TO_ADDR
// if Sib + TedSib > MaxSib then
 818: LD_VAR 0 11
 822: PUSH
 823: LD_VAR 0 14
 827: PLUS
 828: PUSH
 829: LD_VAR 0 8
 833: GREATER
 834: IFFALSE 852
// TedSib = MaxSib - Sib ;
 836: LD_ADDR_VAR 0 14
 840: PUSH
 841: LD_VAR 0 8
 845: PUSH
 846: LD_VAR 0 11
 850: MINUS
 851: ST_TO_ADDR
// SetCargo ( Spec , MAT_CANS , 0 ) ;
 852: LD_VAR 0 3
 856: PPUSH
 857: LD_INT 1
 859: PPUSH
 860: LD_INT 0
 862: PPUSH
 863: CALL_OW 290
// SetCargo ( Spec , MAT_OIL , 0 ) ;
 867: LD_VAR 0 3
 871: PPUSH
 872: LD_INT 2
 874: PPUSH
 875: LD_INT 0
 877: PPUSH
 878: CALL_OW 290
// SetCargo ( Spec , MAT_SIBERIT , 0 ) ;
 882: LD_VAR 0 3
 886: PPUSH
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 0
 892: PPUSH
 893: CALL_OW 290
// AddCargo ( Spec , MAT_CANS , TedCans ) ;
 897: LD_VAR 0 3
 901: PPUSH
 902: LD_INT 1
 904: PPUSH
 905: LD_VAR 0 12
 909: PPUSH
 910: CALL_OW 291
// AddCargo ( Spec , MAT_SIBERIT , TedSib ) ;
 914: LD_VAR 0 3
 918: PPUSH
 919: LD_INT 3
 921: PPUSH
 922: LD_VAR 0 14
 926: PPUSH
 927: CALL_OW 291
// AddCargo ( Spec , MAT_OIL , TedOil ) ;
 931: LD_VAR 0 3
 935: PPUSH
 936: LD_INT 2
 938: PPUSH
 939: LD_VAR 0 13
 943: PPUSH
 944: CALL_OW 291
// Cans = Cans + TedCans ;
 948: LD_ADDR_VAR 0 9
 952: PUSH
 953: LD_VAR 0 9
 957: PUSH
 958: LD_VAR 0 12
 962: PLUS
 963: ST_TO_ADDR
// Oil = Oil + TedOil ;
 964: LD_ADDR_VAR 0 10
 968: PUSH
 969: LD_VAR 0 10
 973: PUSH
 974: LD_VAR 0 13
 978: PLUS
 979: ST_TO_ADDR
// Sib = Sib + TedSib ;
 980: LD_ADDR_VAR 0 11
 984: PUSH
 985: LD_VAR 0 11
 989: PUSH
 990: LD_VAR 0 14
 994: PLUS
 995: ST_TO_ADDR
// end ;
 996: GO 693
 998: POP
 999: POP
// end ;
1000: LD_VAR 0 1
1004: RET
// function load ; begin
1005: LD_INT 0
1007: PPUSH
// UC_Nation = NATION_RUSSIAN ;
1008: LD_ADDR_OWVAR 21
1012: PUSH
1013: LD_INT 3
1015: ST_TO_ADDR
// UC_Side = side_Ru ;
1016: LD_ADDR_OWVAR 20
1020: PUSH
1021: LD_EXP 2
1025: ST_TO_ADDR
// VsevSaved = LoadVariable ( VsevSaved , false ) ;
1026: LD_ADDR_EXP 8
1030: PUSH
1031: LD_STRING VsevSaved
1033: PPUSH
1034: LD_INT 0
1036: PPUSH
1037: CALL_OW 30
1041: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
1042: LD_ADDR_EXP 10
1046: PUSH
1047: LD_STRING Burlak
1049: PPUSH
1050: CALL 0 0 1
1054: ST_TO_ADDR
// Vsevolod = load_char ( Vsevolod ) ;
1055: LD_ADDR_EXP 11
1059: PUSH
1060: LD_STRING Vsevolod
1062: PPUSH
1063: CALL 0 0 1
1067: ST_TO_ADDR
// if IsDead ( Vsevolod ) then
1068: LD_EXP 11
1072: PPUSH
1073: CALL_OW 301
1077: IFFALSE 1087
// VsevSaved = false ;
1079: LD_ADDR_EXP 8
1083: PUSH
1084: LD_INT 0
1086: ST_TO_ADDR
// Yelena = load_char ( Kirilenkova ) ;
1087: LD_ADDR_EXP 13
1091: PUSH
1092: LD_STRING Kirilenkova
1094: PPUSH
1095: CALL 0 0 1
1099: ST_TO_ADDR
// if not Yelena or IsDead ( Yelena ) then
1100: LD_EXP 13
1104: NOT
1105: PUSH
1106: LD_EXP 13
1110: PPUSH
1111: CALL_OW 301
1115: OR
1116: IFFALSE 1138
// begin Yelena = vytvor_yelenu ;
1118: LD_ADDR_EXP 13
1122: PUSH
1123: CALL 153 0 0
1127: ST_TO_ADDR
// FalesnaYelena = true ;
1128: LD_ADDR_LOC 1
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// end else
1136: GO 1146
// FalesnaYelena = false ;
1138: LD_ADDR_LOC 1
1142: PUSH
1143: LD_INT 0
1145: ST_TO_ADDR
// if VsevSaved then
1146: LD_EXP 8
1150: IFFALSE 1158
// load_vs else
1152: CALL 1382 0 0
1156: GO 1162
// load_nv ;
1158: CALL 1167 0 0
// end ;
1162: LD_VAR 0 1
1166: RET
// function load_nv ; var Ostatni ; begin
1167: LD_INT 0
1169: PPUSH
1170: PPUSH
// Karamazov = load_char ( Karamazov ) ;
1171: LD_ADDR_EXP 16
1175: PUSH
1176: LD_STRING Karamazov
1178: PPUSH
1179: CALL 0 0 1
1183: ST_TO_ADDR
// Petrovova = load_char ( Petrovova ) ;
1184: LD_ADDR_EXP 17
1188: PUSH
1189: LD_STRING Petrovova
1191: PPUSH
1192: CALL 0 0 1
1196: ST_TO_ADDR
// Gleb = load_char ( Gleb ) ;
1197: LD_ADDR_EXP 14
1201: PUSH
1202: LD_STRING Gleb
1204: PPUSH
1205: CALL 0 0 1
1209: ST_TO_ADDR
// Petrosyan = load_char ( Petrosyan ) ;
1210: LD_ADDR_EXP 15
1214: PUSH
1215: LD_STRING Petrosyan
1217: PPUSH
1218: CALL 0 0 1
1222: ST_TO_ADDR
// Lipshchin = load_char ( Lipshchin ) ;
1223: LD_ADDR_EXP 21
1227: PUSH
1228: LD_STRING Lipshchin
1230: PPUSH
1231: CALL 0 0 1
1235: ST_TO_ADDR
// Titov = load_char ( Titov ) ;
1236: LD_ADDR_EXP 19
1240: PUSH
1241: LD_STRING Titov
1243: PPUSH
1244: CALL 0 0 1
1248: ST_TO_ADDR
// Dolgov = load_char ( Dolgov ) ;
1249: LD_ADDR_EXP 18
1253: PUSH
1254: LD_STRING Dolgov
1256: PPUSH
1257: CALL 0 0 1
1261: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1262: LD_ADDR_EXP 12
1266: PUSH
1267: LD_STRING Popov
1269: PPUSH
1270: CALL_OW 25
1274: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1275: LD_ADDR_EXP 20
1279: PUSH
1280: LD_STRING Platonov
1282: PPUSH
1283: CALL_OW 25
1287: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1288: LD_ADDR_VAR 0 2
1292: PUSH
1293: LD_STRING Survivors2
1295: PPUSH
1296: CALL 79 0 1
1300: ST_TO_ADDR
// Rusaci = Ostatni union [ Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov ] diff [ 0 ] ;
1301: LD_ADDR_EXP 22
1305: PUSH
1306: LD_VAR 0 2
1310: PUSH
1311: LD_EXP 16
1315: PUSH
1316: LD_EXP 17
1320: PUSH
1321: LD_EXP 14
1325: PUSH
1326: LD_EXP 15
1330: PUSH
1331: LD_EXP 21
1335: PUSH
1336: LD_EXP 19
1340: PUSH
1341: LD_EXP 18
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: UNION
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: DIFF
1362: ST_TO_ADDR
// SetSide ( Rusaci , side_Ru ) ;
1363: LD_EXP 22
1367: PPUSH
1368: LD_EXP 2
1372: PPUSH
1373: CALL_OW 235
// end ;
1377: LD_VAR 0 1
1381: RET
// function load_vs ; var Ostatni ; var KaramazovLoc , PetrovovaLoc , GlebLoc , PetrosyanLoc ; var LipshchinLoc , TitovLoc , DolgovLoc ; begin
1382: LD_INT 0
1384: PPUSH
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
1391: PPUSH
1392: PPUSH
// KaramazovLoc = LoadVariable ( KaramazovLoc , 0 ) ;
1393: LD_ADDR_VAR 0 3
1397: PUSH
1398: LD_STRING KaramazovLoc
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 30
1408: ST_TO_ADDR
// PetrovovaLoc = LoadVariable ( PetrovovaLoc , 0 ) ;
1409: LD_ADDR_VAR 0 4
1413: PUSH
1414: LD_STRING PetrovovaLoc
1416: PPUSH
1417: LD_INT 0
1419: PPUSH
1420: CALL_OW 30
1424: ST_TO_ADDR
// GlebLoc = LoadVariable ( GlebLoc , 0 ) ;
1425: LD_ADDR_VAR 0 5
1429: PUSH
1430: LD_STRING GlebLoc
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 30
1440: ST_TO_ADDR
// PetrosyanLoc = LoadVariable ( PetrosyanLoc , 0 ) ;
1441: LD_ADDR_VAR 0 6
1445: PUSH
1446: LD_STRING PetrosyanLoc
1448: PPUSH
1449: LD_INT 0
1451: PPUSH
1452: CALL_OW 30
1456: ST_TO_ADDR
// LipshchinLoc = LoadVariable ( LipshchinLoc , 0 ) ;
1457: LD_ADDR_VAR 0 7
1461: PUSH
1462: LD_STRING LipshchinLoc
1464: PPUSH
1465: LD_INT 0
1467: PPUSH
1468: CALL_OW 30
1472: ST_TO_ADDR
// TitovLoc = LoadVariable ( TitovLoc , 0 ) ;
1473: LD_ADDR_VAR 0 8
1477: PUSH
1478: LD_STRING TitovLoc
1480: PPUSH
1481: LD_INT 0
1483: PPUSH
1484: CALL_OW 30
1488: ST_TO_ADDR
// DolgovLoc = LoadVariable ( DolgovLoc , 0 ) ;
1489: LD_ADDR_VAR 0 9
1493: PUSH
1494: LD_STRING DolgovLoc
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 30
1504: ST_TO_ADDR
// if KaramazovLoc in [ 7 , - 7 ] then
1505: LD_VAR 0 3
1509: PUSH
1510: LD_INT 7
1512: PUSH
1513: LD_INT 7
1515: NEG
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: IN
1521: IFFALSE 1536
// Karamazov = load_char ( Karamazov ) ;
1523: LD_ADDR_EXP 16
1527: PUSH
1528: LD_STRING Karamazov
1530: PPUSH
1531: CALL 0 0 1
1535: ST_TO_ADDR
// if PetrovovaLoc in [ 7 , - 7 ] then
1536: LD_VAR 0 4
1540: PUSH
1541: LD_INT 7
1543: PUSH
1544: LD_INT 7
1546: NEG
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: IN
1552: IFFALSE 1567
// Petrovova = load_char ( Petrovova ) ;
1554: LD_ADDR_EXP 17
1558: PUSH
1559: LD_STRING Petrovova
1561: PPUSH
1562: CALL 0 0 1
1566: ST_TO_ADDR
// if GlebLoc in [ 7 , - 7 ] then
1567: LD_VAR 0 5
1571: PUSH
1572: LD_INT 7
1574: PUSH
1575: LD_INT 7
1577: NEG
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: IN
1583: IFFALSE 1598
// Gleb = load_char ( Gleb ) ;
1585: LD_ADDR_EXP 14
1589: PUSH
1590: LD_STRING Gleb
1592: PPUSH
1593: CALL 0 0 1
1597: ST_TO_ADDR
// if PetrosyanLoc in [ 7 , - 7 ] then
1598: LD_VAR 0 6
1602: PUSH
1603: LD_INT 7
1605: PUSH
1606: LD_INT 7
1608: NEG
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: IN
1614: IFFALSE 1629
// Petrosyan = load_char ( Petrosyan ) ;
1616: LD_ADDR_EXP 15
1620: PUSH
1621: LD_STRING Petrosyan
1623: PPUSH
1624: CALL 0 0 1
1628: ST_TO_ADDR
// if LipshchinLoc in [ 7 , - 7 ] then
1629: LD_VAR 0 7
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_INT 7
1639: NEG
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: IN
1645: IFFALSE 1660
// Lipshchin = load_char ( Lipshchin ) ;
1647: LD_ADDR_EXP 21
1651: PUSH
1652: LD_STRING Lipshchin
1654: PPUSH
1655: CALL 0 0 1
1659: ST_TO_ADDR
// if TitovLoc in [ 7 , - 7 ] then
1660: LD_VAR 0 8
1664: PUSH
1665: LD_INT 7
1667: PUSH
1668: LD_INT 7
1670: NEG
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: IN
1676: IFFALSE 1691
// Titov = load_char ( Titov ) ;
1678: LD_ADDR_EXP 19
1682: PUSH
1683: LD_STRING Titov
1685: PPUSH
1686: CALL 0 0 1
1690: ST_TO_ADDR
// if DolgovLoc in [ 7 , - 7 ] then
1691: LD_VAR 0 9
1695: PUSH
1696: LD_INT 7
1698: PUSH
1699: LD_INT 7
1701: NEG
1702: PUSH
1703: EMPTY
1704: LIST
1705: LIST
1706: IN
1707: IFFALSE 1722
// Dolgov = load_char ( Dolgov ) ;
1709: LD_ADDR_EXP 18
1713: PUSH
1714: LD_STRING Dolgov
1716: PPUSH
1717: CALL 0 0 1
1721: ST_TO_ADDR
// Ostatni = load_set ( Survivors2 ) ;
1722: LD_ADDR_VAR 0 2
1726: PUSH
1727: LD_STRING Survivors2
1729: PPUSH
1730: CALL 79 0 1
1734: ST_TO_ADDR
// Popov = NewCharacter ( Popov ) ;
1735: LD_ADDR_EXP 12
1739: PUSH
1740: LD_STRING Popov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Platonov = NewCharacter ( Platonov ) ;
1748: LD_ADDR_EXP 20
1752: PUSH
1753: LD_STRING Platonov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// WithVsevolod = [ Yelena ] union load_set ( WithVsevolod ) ;
1761: LD_ADDR_EXP 23
1765: PUSH
1766: LD_EXP 13
1770: PUSH
1771: EMPTY
1772: LIST
1773: PUSH
1774: LD_STRING WithVsevolod
1776: PPUSH
1777: CALL 79 0 1
1781: UNION
1782: ST_TO_ADDR
// Rusaci = Ostatni ;
1783: LD_ADDR_EXP 22
1787: PUSH
1788: LD_VAR 0 2
1792: ST_TO_ADDR
// if KaramazovLoc = 7 then
1793: LD_VAR 0 3
1797: PUSH
1798: LD_INT 7
1800: EQUAL
1801: IFFALSE 1824
// Rusaci = Rusaci union [ Karamazov ] else
1803: LD_ADDR_EXP 22
1807: PUSH
1808: LD_EXP 22
1812: PUSH
1813: LD_EXP 16
1817: PUSH
1818: EMPTY
1819: LIST
1820: UNION
1821: ST_TO_ADDR
1822: GO 1854
// if KaramazovLoc = - 7 then
1824: LD_VAR 0 3
1828: PUSH
1829: LD_INT 7
1831: NEG
1832: EQUAL
1833: IFFALSE 1854
// WithVsevolod = WithVsevolod union [ Karamazov ] ;
1835: LD_ADDR_EXP 23
1839: PUSH
1840: LD_EXP 23
1844: PUSH
1845: LD_EXP 16
1849: PUSH
1850: EMPTY
1851: LIST
1852: UNION
1853: ST_TO_ADDR
// if PetrovovaLoc = 7 then
1854: LD_VAR 0 4
1858: PUSH
1859: LD_INT 7
1861: EQUAL
1862: IFFALSE 1885
// Rusaci = Rusaci union [ Petrovova ] else
1864: LD_ADDR_EXP 22
1868: PUSH
1869: LD_EXP 22
1873: PUSH
1874: LD_EXP 17
1878: PUSH
1879: EMPTY
1880: LIST
1881: UNION
1882: ST_TO_ADDR
1883: GO 1915
// if PetrovovaLoc = - 7 then
1885: LD_VAR 0 4
1889: PUSH
1890: LD_INT 7
1892: NEG
1893: EQUAL
1894: IFFALSE 1915
// WithVsevolod = WithVsevolod union [ Petrovova ] ;
1896: LD_ADDR_EXP 23
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_EXP 17
1910: PUSH
1911: EMPTY
1912: LIST
1913: UNION
1914: ST_TO_ADDR
// if GlebLoc = 7 then
1915: LD_VAR 0 5
1919: PUSH
1920: LD_INT 7
1922: EQUAL
1923: IFFALSE 1946
// Rusaci = Rusaci union [ Gleb ] else
1925: LD_ADDR_EXP 22
1929: PUSH
1930: LD_EXP 22
1934: PUSH
1935: LD_EXP 14
1939: PUSH
1940: EMPTY
1941: LIST
1942: UNION
1943: ST_TO_ADDR
1944: GO 1976
// if GlebLoc = - 7 then
1946: LD_VAR 0 5
1950: PUSH
1951: LD_INT 7
1953: NEG
1954: EQUAL
1955: IFFALSE 1976
// WithVsevolod = WithVsevolod union [ Gleb ] ;
1957: LD_ADDR_EXP 23
1961: PUSH
1962: LD_EXP 23
1966: PUSH
1967: LD_EXP 14
1971: PUSH
1972: EMPTY
1973: LIST
1974: UNION
1975: ST_TO_ADDR
// if PetrosyanLoc = 7 then
1976: LD_VAR 0 6
1980: PUSH
1981: LD_INT 7
1983: EQUAL
1984: IFFALSE 2007
// Rusaci = Rusaci union [ Petrosyan ] else
1986: LD_ADDR_EXP 22
1990: PUSH
1991: LD_EXP 22
1995: PUSH
1996: LD_EXP 15
2000: PUSH
2001: EMPTY
2002: LIST
2003: UNION
2004: ST_TO_ADDR
2005: GO 2037
// if PetrosyanLoc = - 7 then
2007: LD_VAR 0 6
2011: PUSH
2012: LD_INT 7
2014: NEG
2015: EQUAL
2016: IFFALSE 2037
// WithVsevolod = WithVsevolod union [ Petrosyan ] ;
2018: LD_ADDR_EXP 23
2022: PUSH
2023: LD_EXP 23
2027: PUSH
2028: LD_EXP 15
2032: PUSH
2033: EMPTY
2034: LIST
2035: UNION
2036: ST_TO_ADDR
// if LipshchinLoc = 7 then
2037: LD_VAR 0 7
2041: PUSH
2042: LD_INT 7
2044: EQUAL
2045: IFFALSE 2068
// Rusaci = Rusaci union [ Lipshchin ] else
2047: LD_ADDR_EXP 22
2051: PUSH
2052: LD_EXP 22
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: EMPTY
2063: LIST
2064: UNION
2065: ST_TO_ADDR
2066: GO 2098
// if LipshchinLoc = - 7 then
2068: LD_VAR 0 7
2072: PUSH
2073: LD_INT 7
2075: NEG
2076: EQUAL
2077: IFFALSE 2098
// WithVsevolod = WithVsevolod union [ Lipshchin ] ;
2079: LD_ADDR_EXP 23
2083: PUSH
2084: LD_EXP 23
2088: PUSH
2089: LD_EXP 21
2093: PUSH
2094: EMPTY
2095: LIST
2096: UNION
2097: ST_TO_ADDR
// if TitovLoc = 7 then
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 7
2105: EQUAL
2106: IFFALSE 2129
// Rusaci = Rusaci union [ Titov ] else
2108: LD_ADDR_EXP 22
2112: PUSH
2113: LD_EXP 22
2117: PUSH
2118: LD_EXP 19
2122: PUSH
2123: EMPTY
2124: LIST
2125: UNION
2126: ST_TO_ADDR
2127: GO 2159
// if TitovLoc = - 7 then
2129: LD_VAR 0 8
2133: PUSH
2134: LD_INT 7
2136: NEG
2137: EQUAL
2138: IFFALSE 2159
// WithVsevolod = WithVsevolod union [ Titov ] ;
2140: LD_ADDR_EXP 23
2144: PUSH
2145: LD_EXP 23
2149: PUSH
2150: LD_EXP 19
2154: PUSH
2155: EMPTY
2156: LIST
2157: UNION
2158: ST_TO_ADDR
// if DolgovLoc = 7 then
2159: LD_VAR 0 9
2163: PUSH
2164: LD_INT 7
2166: EQUAL
2167: IFFALSE 2190
// Rusaci = Rusaci union [ Dolgov ] else
2169: LD_ADDR_EXP 22
2173: PUSH
2174: LD_EXP 22
2178: PUSH
2179: LD_EXP 18
2183: PUSH
2184: EMPTY
2185: LIST
2186: UNION
2187: ST_TO_ADDR
2188: GO 2220
// if DolgovLoc = - 7 then
2190: LD_VAR 0 9
2194: PUSH
2195: LD_INT 7
2197: NEG
2198: EQUAL
2199: IFFALSE 2220
// WithVsevolod = WithVsevolod union [ Dolgov ] ;
2201: LD_ADDR_EXP 23
2205: PUSH
2206: LD_EXP 23
2210: PUSH
2211: LD_EXP 18
2215: PUSH
2216: EMPTY
2217: LIST
2218: UNION
2219: ST_TO_ADDR
// while ( Rusaci union WithVsevolod ) < 6 do
2220: LD_EXP 22
2224: PUSH
2225: LD_EXP 23
2229: UNION
2230: PUSH
2231: LD_INT 6
2233: LESS
2234: IFFALSE 2257
// WithVsevolod = WithVsevolod union [ vytvor_rusaka ] ;
2236: LD_ADDR_EXP 23
2240: PUSH
2241: LD_EXP 23
2245: PUSH
2246: CALL 4089 0 0
2250: PUSH
2251: EMPTY
2252: LIST
2253: UNION
2254: ST_TO_ADDR
2255: GO 2220
// load_konvoj ;
2257: CALL 220 0 0
// SetSide ( Rusaci , side_Ru ) ;
2261: LD_EXP 22
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL_OW 235
// SetSide ( Konvoj , side_Ru ) ;
2275: LD_EXP 24
2279: PPUSH
2280: LD_EXP 2
2284: PPUSH
2285: CALL_OW 235
// SetSide ( Vsevolod , side_Ru2 ) ;
2289: LD_EXP 11
2293: PPUSH
2294: LD_EXP 3
2298: PPUSH
2299: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru2 ) ;
2303: LD_EXP 23
2307: PPUSH
2308: LD_EXP 3
2312: PPUSH
2313: CALL_OW 235
// end ;
2317: LD_VAR 0 1
2321: RET
// function save ; var Lidi , Ostatni , Opice ; begin
2322: LD_INT 0
2324: PPUSH
2325: PPUSH
2326: PPUSH
2327: PPUSH
// DeleteVariable ( Convoy_06 ) ;
2328: LD_STRING Convoy_06
2330: PPUSH
2331: CALL_OW 41
// HeikeCaptured = Heike and IsOK ( Heike ) ;
2335: LD_ADDR_EXP 9
2339: PUSH
2340: LD_EXP 26
2344: PUSH
2345: LD_EXP 26
2349: PPUSH
2350: CALL_OW 302
2354: AND
2355: ST_TO_ADDR
// SaveVariable ( HeikeCaptured , HeikeCaptured ) ;
2356: LD_EXP 9
2360: PPUSH
2361: LD_STRING HeikeCaptured
2363: PPUSH
2364: CALL_OW 39
// SaveVariable ( not HeikeCaptured , HeikeKilled ) ;
2368: LD_EXP 9
2372: NOT
2373: PPUSH
2374: LD_STRING HeikeKilled
2376: PPUSH
2377: CALL_OW 39
// save_char ( Burlak , Burlak ) ;
2381: LD_EXP 10
2385: PPUSH
2386: LD_STRING Burlak
2388: PPUSH
2389: CALL 122 0 2
// if not FalesnaYelena then
2393: LD_LOC 1
2397: NOT
2398: IFFALSE 2412
// save_char ( Yelena , Kirilenkova ) ;
2400: LD_EXP 13
2404: PPUSH
2405: LD_STRING Kirilenkova
2407: PPUSH
2408: CALL 122 0 2
// save_char ( Karamazov , Karamazov ) ;
2412: LD_EXP 16
2416: PPUSH
2417: LD_STRING Karamazov
2419: PPUSH
2420: CALL 122 0 2
// save_char ( Petrovova , Petrovova ) ;
2424: LD_EXP 17
2428: PPUSH
2429: LD_STRING Petrovova
2431: PPUSH
2432: CALL 122 0 2
// save_char ( Gleb , Gleb ) ;
2436: LD_EXP 14
2440: PPUSH
2441: LD_STRING Gleb
2443: PPUSH
2444: CALL 122 0 2
// save_char ( Petrosyan , Petrosyan ) ;
2448: LD_EXP 15
2452: PPUSH
2453: LD_STRING Petrosyan
2455: PPUSH
2456: CALL 122 0 2
// save_char ( Lipshchin , Lipshchin ) ;
2460: LD_EXP 21
2464: PPUSH
2465: LD_STRING Lipshchin
2467: PPUSH
2468: CALL 122 0 2
// save_char ( Titov , Titov ) ;
2472: LD_EXP 19
2476: PPUSH
2477: LD_STRING Titov
2479: PPUSH
2480: CALL 122 0 2
// save_char ( Dolgov , Dolgov ) ;
2484: LD_EXP 18
2488: PPUSH
2489: LD_STRING Dolgov
2491: PPUSH
2492: CALL 122 0 2
// save_char ( Vsevolod , Vsevolod ) ;
2496: LD_EXP 11
2500: PPUSH
2501: LD_STRING Vsevolod
2503: PPUSH
2504: CALL 122 0 2
// SaveCharacters ( [ Xavier ] , Xavier ) ;
2508: LD_EXP 25
2512: PUSH
2513: EMPTY
2514: LIST
2515: PPUSH
2516: LD_STRING Xavier
2518: PPUSH
2519: CALL_OW 38
// SaveCharacters ( [ Heike ] , Heike ) ;
2523: LD_EXP 26
2527: PUSH
2528: EMPTY
2529: LIST
2530: PPUSH
2531: LD_STRING Heike
2533: PPUSH
2534: CALL_OW 38
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_ALIVE ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_INT 22
2545: PUSH
2546: LD_EXP 2
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_INT 51
2557: PUSH
2558: EMPTY
2559: LIST
2560: PUSH
2561: LD_INT 21
2563: PUSH
2564: LD_INT 1
2566: PUSH
2567: EMPTY
2568: LIST
2569: LIST
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: LD_VAR 0 2
2590: PPUSH
2591: LD_INT 2
2593: PUSH
2594: LD_INT 25
2596: PUSH
2597: LD_INT 12
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: PUSH
2604: LD_INT 25
2606: PUSH
2607: LD_INT 15
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: PUSH
2614: LD_INT 25
2616: PUSH
2617: LD_INT 16
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 25
2626: PUSH
2627: LD_INT 17
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: EMPTY
2642: LIST
2643: PPUSH
2644: CALL_OW 72
2648: ST_TO_ADDR
// Ostatni = Lidi diff [ 0 , Burlak , Vsevolod , Heike , Yelena , Popov , Gleb , Petrosyan , Karamazov , Petrovova , Dolgov , Titov , Platonov , Lipshchin , Yashin , Xavier ] ;
2649: LD_ADDR_VAR 0 3
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_INT 0
2661: PUSH
2662: LD_EXP 10
2666: PUSH
2667: LD_EXP 11
2671: PUSH
2672: LD_EXP 26
2676: PUSH
2677: LD_EXP 13
2681: PUSH
2682: LD_EXP 12
2686: PUSH
2687: LD_EXP 14
2691: PUSH
2692: LD_EXP 15
2696: PUSH
2697: LD_EXP 16
2701: PUSH
2702: LD_EXP 17
2706: PUSH
2707: LD_EXP 18
2711: PUSH
2712: LD_EXP 19
2716: PUSH
2717: LD_EXP 20
2721: PUSH
2722: LD_EXP 21
2726: PUSH
2727: LD_EXP 34
2731: PUSH
2732: LD_EXP 25
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: DIFF
2755: ST_TO_ADDR
// Ostatni = Ostatni diff Opice ;
2756: LD_ADDR_VAR 0 3
2760: PUSH
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 4
2770: DIFF
2771: ST_TO_ADDR
// if FalesnaYelena and IsOk ( Yelena ) then
2772: LD_LOC 1
2776: PUSH
2777: LD_EXP 13
2781: PPUSH
2782: CALL_OW 302
2786: AND
2787: IFFALSE 2808
// Ostatni = Ostatni union [ Yelena ] ;
2789: LD_ADDR_VAR 0 3
2793: PUSH
2794: LD_VAR 0 3
2798: PUSH
2799: LD_EXP 13
2803: PUSH
2804: EMPTY
2805: LIST
2806: UNION
2807: ST_TO_ADDR
// SaveCharacters ( Ostatni , Survivors2 ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: LD_STRING Survivors2
2815: PPUSH
2816: CALL_OW 38
// end ;
2820: LD_VAR 0 1
2824: RET
// function dej_medaile ; var medal1 , medal2 , medal3 ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// medal1 := false ;
2831: LD_ADDR_VAR 0 2
2835: PUSH
2836: LD_INT 0
2838: ST_TO_ADDR
// medal2 := false ;
2839: LD_ADDR_VAR 0 3
2843: PUSH
2844: LD_INT 0
2846: ST_TO_ADDR
// medal3 := false ;
2847: LD_ADDR_VAR 0 4
2851: PUSH
2852: LD_INT 0
2854: ST_TO_ADDR
// if Xavier and IsLive ( Xavier ) then
2855: LD_EXP 25
2859: PUSH
2860: LD_EXP 25
2864: PPUSH
2865: CALL_OW 300
2869: AND
2870: IFFALSE 2892
// begin medal1 := true ;
2872: LD_ADDR_VAR 0 2
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// AddMedal ( Xavier , 1 ) ;
2880: LD_STRING Xavier
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: CALL_OW 101
// end else
2890: GO 2903
// AddMedal ( Xavier , - 1 ) ;
2892: LD_STRING Xavier
2894: PPUSH
2895: LD_INT 1
2897: NEG
2898: PPUSH
2899: CALL_OW 101
// if VsevSaved then
2903: LD_EXP 8
2907: IFFALSE 2948
// if PropaslQuickly then
2909: LD_EXP 29
2913: IFFALSE 2928
// AddMedal ( TimeVS , - 1 ) else
2915: LD_STRING TimeVS
2917: PPUSH
2918: LD_INT 1
2920: NEG
2921: PPUSH
2922: CALL_OW 101
2926: GO 2946
// begin medal2 := true ;
2928: LD_ADDR_VAR 0 3
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// AddMedal ( TimeVS , 1 ) ;
2936: LD_STRING TimeVS
2938: PPUSH
2939: LD_INT 1
2941: PPUSH
2942: CALL_OW 101
// end else
2946: GO 2977
// if ContactIn5Min then
2948: LD_EXP 28
2952: IFFALSE 2966
// AddMedal ( TimeNV , 1 ) else
2954: LD_STRING TimeNV
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: CALL_OW 101
2964: GO 2977
// AddMedal ( TimeNV , - 1 ) ;
2966: LD_STRING TimeNV
2968: PPUSH
2969: LD_INT 1
2971: NEG
2972: PPUSH
2973: CALL_OW 101
// if IsOK ( Heike ) then
2977: LD_EXP 26
2981: PPUSH
2982: CALL_OW 302
2986: IFFALSE 3008
// begin medal3 := true ;
2988: LD_ADDR_VAR 0 4
2992: PUSH
2993: LD_INT 1
2995: ST_TO_ADDR
// AddMedal ( Heike , 1 ) ;
2996: LD_STRING Heike
2998: PPUSH
2999: LD_INT 1
3001: PPUSH
3002: CALL_OW 101
// end else
3006: GO 3019
// AddMedal ( Heike , - 1 ) ;
3008: LD_STRING Heike
3010: PPUSH
3011: LD_INT 1
3013: NEG
3014: PPUSH
3015: CALL_OW 101
// SA_EndMission ( 3 , 7 , medal1 , medal2 , medal3 ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 7
3024: PPUSH
3025: LD_VAR 0 2
3029: PPUSH
3030: LD_VAR 0 3
3034: PPUSH
3035: LD_VAR 0 4
3039: PPUSH
3040: CALL 22921 0 5
// end ;
3044: LD_VAR 0 1
3048: RET
// export function vyhral ( Ident ) ; var Lidi , Opice ; begin
3049: LD_INT 0
3051: PPUSH
3052: PPUSH
3053: PPUSH
// dej_medaile ;
3054: CALL 2825 0 0
// GiveMedals ( Ident ) ;
3058: LD_VAR 0 1
3062: PPUSH
3063: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
3067: LD_ADDR_VAR 0 3
3071: PUSH
3072: LD_INT 22
3074: PUSH
3075: LD_EXP 2
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: LD_INT 21
3086: PUSH
3087: LD_INT 1
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 51
3096: PUSH
3097: EMPTY
3098: LIST
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: LD_VAR 0 3
3119: PPUSH
3120: LD_INT 2
3122: PUSH
3123: LD_INT 25
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 25
3135: PUSH
3136: LD_INT 15
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: LD_INT 25
3145: PUSH
3146: LD_INT 16
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PUSH
3153: LD_INT 25
3155: PUSH
3156: LD_INT 17
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: PPUSH
3173: CALL_OW 72
3177: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
3178: LD_VAR 0 3
3182: PUSH
3183: LD_VAR 0 4
3187: DIFF
3188: PPUSH
3189: CALL_OW 43
// save ;
3193: CALL 2322 0 0
// YouWin ;
3197: CALL_OW 103
// end ;
3201: LD_VAR 0 2
3205: RET
// function set_attitudes ; begin
3206: LD_INT 0
3208: PPUSH
// ChangeSideFog ( side_Xavier , GetSideFog ( side_Ru ) ) ;
3209: LD_EXP 5
3213: PPUSH
3214: LD_EXP 2
3218: PPUSH
3219: CALL_OW 342
3223: PPUSH
3224: CALL_OW 343
// ChangeSideFog ( side_Ru2 , GetSideFog ( side_Ru ) ) ;
3228: LD_EXP 3
3232: PPUSH
3233: LD_EXP 2
3237: PPUSH
3238: CALL_OW 342
3242: PPUSH
3243: CALL_OW 343
// SetAttitude ( side_Ru2 , side_Ru , ATT_FRIEND , true ) ;
3247: LD_EXP 3
3251: PPUSH
3252: LD_EXP 2
3256: PPUSH
3257: LD_INT 1
3259: PPUSH
3260: LD_INT 1
3262: PPUSH
3263: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Ar , ATT_ENEMY , false ) ;
3267: LD_EXP 3
3271: PPUSH
3272: LD_EXP 4
3276: PPUSH
3277: LD_INT 2
3279: PPUSH
3280: LD_INT 0
3282: PPUSH
3283: CALL_OW 80
// SetAttitude ( side_Ar , side_Ru2 , ATT_FRIEND , false ) ;
3287: LD_EXP 4
3291: PPUSH
3292: LD_EXP 3
3296: PPUSH
3297: LD_INT 1
3299: PPUSH
3300: LD_INT 0
3302: PPUSH
3303: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Strazci , ATT_ENEMY , false ) ;
3307: LD_EXP 3
3311: PPUSH
3312: LD_EXP 7
3316: PPUSH
3317: LD_INT 2
3319: PPUSH
3320: LD_INT 0
3322: PPUSH
3323: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Heike , ATT_NEUTRAL , false ) ;
3327: LD_EXP 3
3331: PPUSH
3332: LD_EXP 6
3336: PPUSH
3337: LD_INT 0
3339: PPUSH
3340: LD_INT 0
3342: PPUSH
3343: CALL_OW 80
// SetAttitude ( side_Strazci , side_Ru2 , ATT_NEUTRAL , false ) ;
3347: LD_EXP 7
3351: PPUSH
3352: LD_EXP 3
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: LD_INT 0
3362: PPUSH
3363: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru2 , ATT_NEUTRAL , false ) ;
3367: LD_EXP 6
3371: PPUSH
3372: LD_EXP 3
3376: PPUSH
3377: LD_INT 0
3379: PPUSH
3380: LD_INT 0
3382: PPUSH
3383: CALL_OW 80
// SetAttitude ( side_Ru , side_Xavier , ATT_FRIEND , true ) ;
3387: LD_EXP 2
3391: PPUSH
3392: LD_EXP 5
3396: PPUSH
3397: LD_INT 1
3399: PPUSH
3400: LD_INT 1
3402: PPUSH
3403: CALL_OW 80
// SetAttitude ( side_Ru2 , side_Xavier , ATT_FRIEND , true ) ;
3407: LD_EXP 3
3411: PPUSH
3412: LD_EXP 5
3416: PPUSH
3417: LD_INT 1
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: CALL_OW 80
// SetAttitude ( side_Ar , side_Xavier , ATT_FRIEND , true ) ;
3427: LD_EXP 4
3431: PPUSH
3432: LD_EXP 5
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: LD_INT 1
3442: PPUSH
3443: CALL_OW 80
// SetAttitude ( side_Heike , side_Xavier , ATT_NEUTRAL , true ) ;
3447: LD_EXP 6
3451: PPUSH
3452: LD_EXP 5
3456: PPUSH
3457: LD_INT 0
3459: PPUSH
3460: LD_INT 1
3462: PPUSH
3463: CALL_OW 80
// SetAttitude ( side_Strazci , side_Xavier , ATT_NEUTRAL , true ) ;
3467: LD_EXP 7
3471: PPUSH
3472: LD_EXP 5
3476: PPUSH
3477: LD_INT 0
3479: PPUSH
3480: LD_INT 1
3482: PPUSH
3483: CALL_OW 80
// SetAttitude ( side_Ru , side_Heike , ATT_NEUTRAL , false ) ;
3487: LD_EXP 2
3491: PPUSH
3492: LD_EXP 6
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: LD_INT 0
3502: PPUSH
3503: CALL_OW 80
// SetAttitude ( side_Heike , side_Ru , ATT_ENEMY , false ) ;
3507: LD_EXP 6
3511: PPUSH
3512: LD_EXP 2
3516: PPUSH
3517: LD_INT 2
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 80
// SetAttitude ( side_Heike , side_Ar , ATT_FRIEND , true ) ;
3527: LD_EXP 6
3531: PPUSH
3532: LD_EXP 4
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_INT 1
3542: PPUSH
3543: CALL_OW 80
// SetAttitude ( side_Heike , side_Strazci , ATT_FRIEND , true ) ;
3547: LD_EXP 6
3551: PPUSH
3552: LD_EXP 7
3556: PPUSH
3557: LD_INT 1
3559: PPUSH
3560: LD_INT 1
3562: PPUSH
3563: CALL_OW 80
// SetAttitude ( side_Ar , side_Strazci , ATT_FRIEND , true ) ;
3567: LD_EXP 4
3571: PPUSH
3572: LD_EXP 7
3576: PPUSH
3577: LD_INT 1
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL_OW 80
// end ;
3587: LD_VAR 0 1
3591: RET
// starting begin RandomizeAll ;
3592: CALL_OW 11
// AutoEnemy = false ;
3596: LD_ADDR_OWVAR 74
3600: PUSH
3601: LD_INT 0
3603: ST_TO_ADDR
// side_Neutral = 0 ;
3604: LD_ADDR_EXP 1
3608: PUSH
3609: LD_INT 0
3611: ST_TO_ADDR
// side_Ar = 2 ;
3612: LD_ADDR_EXP 4
3616: PUSH
3617: LD_INT 2
3619: ST_TO_ADDR
// side_Ru = 3 ;
3620: LD_ADDR_EXP 2
3624: PUSH
3625: LD_INT 3
3627: ST_TO_ADDR
// side_Ru2 = 6 ;
3628: LD_ADDR_EXP 3
3632: PUSH
3633: LD_INT 6
3635: ST_TO_ADDR
// side_Xavier = 5 ;
3636: LD_ADDR_EXP 5
3640: PUSH
3641: LD_INT 5
3643: ST_TO_ADDR
// side_Heike = 7 ;
3644: LD_ADDR_EXP 6
3648: PUSH
3649: LD_INT 7
3651: ST_TO_ADDR
// side_Strazci = 8 ;
3652: LD_ADDR_EXP 7
3656: PUSH
3657: LD_INT 8
3659: ST_TO_ADDR
// set_attitudes ;
3660: CALL 3206 0 0
// ContactIn5Min = 0 ;
3664: LD_ADDR_EXP 28
3668: PUSH
3669: LD_INT 0
3671: ST_TO_ADDR
// PropaslQuickly = 0 ;
3672: LD_ADDR_EXP 29
3676: PUSH
3677: LD_INT 0
3679: ST_TO_ADDR
// Minuty = 0 ;
3680: LD_ADDR_EXP 30
3684: PUSH
3685: LD_INT 0
3687: ST_TO_ADDR
// InitUc ;
3688: CALL_OW 18
// InitBc ;
3692: CALL_OW 21
// InitHc ;
3696: CALL_OW 19
// InitVc ;
3700: CALL_OW 20
// init_difficulty ;
3704: CALL 20082 0 0
// load ;
3708: CALL 1005 0 0
// init_nature ;
3712: CALL 21265 0 0
// init_suroviny ;
3716: CALL 19291 0 0
// init_arabi ;
3720: CALL 6406 0 0
// init_rusove ;
3724: CALL 3764 0 0
// init_xavier ;
3728: CALL 15131 0 0
// init_heike ;
3732: CALL 17081 0 0
// init_yashin ;
3736: CALL 13101 0 0
// uvod ;
3740: CALL 3827 0 0
// end ;
3744: END
// every 1 1$0 do
3745: GO 3747
3747: DISABLE
// begin Minuty = Minuty + 1 ;
3748: LD_ADDR_EXP 30
3752: PUSH
3753: LD_EXP 30
3757: PUSH
3758: LD_INT 1
3760: PLUS
3761: ST_TO_ADDR
// enable ;
3762: ENABLE
// end ; end_of_file
3763: END
// export RuDepot , RuLab , RuOil ; var VidelAraby ; var YashinZacal ; var KdoSlaplNaMinu ; export function init_rusove ; begin
3764: LD_INT 0
3766: PPUSH
// disable ( 1 ) ;
3767: LD_INT 1
3769: DISABLE_MARKED
// disable ( 2 ) ;
3770: LD_INT 2
3772: DISABLE_MARKED
// disable ( 3 ) ;
3773: LD_INT 3
3775: DISABLE_MARKED
// disable ( 4 ) ;
3776: LD_INT 4
3778: DISABLE_MARKED
// disable ( 5 ) ;
3779: LD_INT 5
3781: DISABLE_MARKED
// RuDepot = 0 ;
3782: LD_ADDR_EXP 31
3786: PUSH
3787: LD_INT 0
3789: ST_TO_ADDR
// RuLab = 0 ;
3790: LD_ADDR_EXP 32
3794: PUSH
3795: LD_INT 0
3797: ST_TO_ADDR
// RuOil = 0 ;
3798: LD_ADDR_EXP 33
3802: PUSH
3803: LD_INT 0
3805: ST_TO_ADDR
// VidelAraby = false ;
3806: LD_ADDR_LOC 2
3810: PUSH
3811: LD_INT 0
3813: ST_TO_ADDR
// YashinZacal = false ;
3814: LD_ADDR_LOC 3
3818: PUSH
3819: LD_INT 0
3821: ST_TO_ADDR
// end ;
3822: LD_VAR 0 1
3826: RET
// export function uvod ; begin
3827: LD_INT 0
3829: PPUSH
// SetResourceVisibility ( 47 , 75 , side_Ru ) ;
3830: LD_INT 47
3832: PPUSH
3833: LD_INT 75
3835: PPUSH
3836: LD_EXP 2
3840: PPUSH
3841: CALL_OW 441
// if VsevSaved then
3845: LD_EXP 8
3849: IFFALSE 3857
// uvod_vsevolod else
3851: CALL 4164 0 0
3855: GO 3861
// uvod_sam ;
3857: CALL 5582 0 0
// Hint ( NonCombat ) ;
3861: LD_STRING NonCombat
3863: PPUSH
3864: CALL_OW 339
// end ;
3868: LD_VAR 0 1
3872: RET
// function priprav_zakladnu ; var Base ; begin
3873: LD_INT 0
3875: PPUSH
3876: PPUSH
// UC_Nation = NATION_RUSSIAN ;
3877: LD_ADDR_OWVAR 21
3881: PUSH
3882: LD_INT 3
3884: ST_TO_ADDR
// UC_side = side_Ru ;
3885: LD_ADDR_OWVAR 20
3889: PUSH
3890: LD_EXP 2
3894: ST_TO_ADDR
// BC_Level = 4 ;
3895: LD_ADDR_OWVAR 43
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// BC_Type = B_DEPOT ;
3903: LD_ADDR_OWVAR 42
3907: PUSH
3908: LD_INT 0
3910: ST_TO_ADDR
// RuDepot = CreateAndPlaceBuildingXYD ( 35 , 58 , 1 ) ;
3911: LD_ADDR_EXP 31
3915: PUSH
3916: LD_INT 35
3918: PPUSH
3919: LD_INT 58
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 47
3929: ST_TO_ADDR
// BC_Type = B_OIL_POWER ;
3930: LD_ADDR_OWVAR 42
3934: PUSH
3935: LD_INT 26
3937: ST_TO_ADDR
// RuOil = CreateAndPlaceBuildingXYD ( 31 , 45 , 1 ) ;
3938: LD_ADDR_EXP 33
3942: PUSH
3943: LD_INT 31
3945: PPUSH
3946: LD_INT 45
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: CALL_OW 47
3956: ST_TO_ADDR
// BC_Type = B_LAB_HALF ;
3957: LD_ADDR_OWVAR 42
3961: PUSH
3962: LD_INT 7
3964: ST_TO_ADDR
// BC_Kind1 = B_LAB_SPACETIME ;
3965: LD_ADDR_OWVAR 44
3969: PUSH
3970: LD_INT 14
3972: ST_TO_ADDR
// BC_Kind2 = B_LAB_BASIC ;
3973: LD_ADDR_OWVAR 45
3977: PUSH
3978: LD_INT 9
3980: ST_TO_ADDR
// RuLab = CreateAndPlaceBuildingXYD ( 37 , 52 , 2 ) ;
3981: LD_ADDR_EXP 32
3985: PUSH
3986: LD_INT 37
3988: PPUSH
3989: LD_INT 52
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 47
3999: ST_TO_ADDR
// Base = GetBase ( RuDepot ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_EXP 31
4009: PPUSH
4010: CALL_OW 274
4014: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , dif_Cans [ Difficulty ] ) ;
4015: LD_VAR 0 2
4019: PPUSH
4020: LD_INT 1
4022: PPUSH
4023: LD_EXP 44
4027: PUSH
4028: LD_OWVAR 67
4032: ARRAY
4033: PPUSH
4034: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , dif_Oil [ Difficulty ] ) ;
4038: LD_VAR 0 2
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: LD_EXP 45
4050: PUSH
4051: LD_OWVAR 67
4055: ARRAY
4056: PPUSH
4057: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , dif_Siberit [ Difficulty ] ) ;
4061: LD_VAR 0 2
4065: PPUSH
4066: LD_INT 3
4068: PPUSH
4069: LD_EXP 46
4073: PUSH
4074: LD_OWVAR 67
4078: ARRAY
4079: PPUSH
4080: CALL_OW 277
// end ;
4084: LD_VAR 0 1
4088: RET
// export function vytvor_rusaka ; begin
4089: LD_INT 0
4091: PPUSH
// UC_Nation = NATION_RUSSIAN ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// UC_side = side_Ru ;
4100: LD_ADDR_OWVAR 20
4104: PUSH
4105: LD_EXP 2
4109: ST_TO_ADDR
// HC_name =  ;
4110: LD_ADDR_OWVAR 26
4114: PUSH
4115: LD_STRING 
4117: ST_TO_ADDR
// HC_sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
4118: LD_ADDR_OWVAR 27
4122: PUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_INT 2
4128: PPUSH
4129: CALL_OW 12
4133: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
4134: LD_ADDR_OWVAR 28
4138: PUSH
4139: LD_INT 1
4141: ST_TO_ADDR
// PrepareSoldierSkills ( 4 ) ;
4142: LD_INT 4
4144: PPUSH
4145: CALL_OW 375
// Result = CreateHuman ;
4149: LD_ADDR_VAR 0 1
4153: PUSH
4154: CALL_OW 44
4158: ST_TO_ADDR
// end ;
4159: LD_VAR 0 1
4163: RET
// function uvod_vsevolod ; var I , Counter , X , Y , Seznam , Ridici ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
4171: PPUSH
4172: PPUSH
// priprav_zakladnu ;
4173: CALL 3873 0 0
// if GetClass ( Yelena ) = CLASS_SCIENTISTIC then
4177: LD_EXP 13
4181: PPUSH
4182: CALL_OW 257
4186: PUSH
4187: LD_INT 4
4189: EQUAL
4190: IFFALSE 4204
// SetClass ( Yelena , CLASS_ENGINEER ) ;
4192: LD_EXP 13
4196: PPUSH
4197: LD_INT 2
4199: PPUSH
4200: CALL_OW 336
// if GetClass ( Burlak ) = CLASS_SCIENTISTIC then
4204: LD_EXP 10
4208: PPUSH
4209: CALL_OW 257
4213: PUSH
4214: LD_INT 4
4216: EQUAL
4217: IFFALSE 4231
// SetClass ( Burlak , CLASS_ENGINEER ) ;
4219: LD_EXP 10
4223: PPUSH
4224: LD_INT 2
4226: PPUSH
4227: CALL_OW 336
// Seznam = UnitFilter ( Rusaci union WithVsevolod , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
4231: LD_ADDR_VAR 0 6
4235: PUSH
4236: LD_EXP 22
4240: PUSH
4241: LD_EXP 23
4245: UNION
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: EMPTY
4258: LIST
4259: PPUSH
4260: CALL_OW 72
4264: ST_TO_ADDR
// for I in Seznam do
4265: LD_ADDR_VAR 0 2
4269: PUSH
4270: LD_VAR 0 6
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetClass ( I , CLASS_SOLDIER ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 1
4285: PPUSH
4286: CALL_OW 336
4290: GO 4275
4292: POP
4293: POP
// SetTech ( TECH_TAUFIELD , side_Ru , STATE_RESEARCHED ) ;
4294: LD_INT 30
4296: PPUSH
4297: LD_EXP 2
4301: PPUSH
4302: LD_INT 2
4304: PPUSH
4305: CALL_OW 322
// SetTech ( TECH_TAUFIELD , side_Ru2 , STATE_RESEARCHED ) ;
4309: LD_INT 30
4311: PPUSH
4312: LD_EXP 3
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 322
// PlaceUnitArea ( Vsevolod , Start1Vsevolod , false ) ;
4324: LD_EXP 11
4328: PPUSH
4329: LD_INT 16
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 49
// X = GetX ( Vsevolod ) ;
4339: LD_ADDR_VAR 0 4
4343: PUSH
4344: LD_EXP 11
4348: PPUSH
4349: CALL_OW 250
4353: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4354: LD_ADDR_VAR 0 5
4358: PUSH
4359: LD_EXP 11
4363: PPUSH
4364: CALL_OW 251
4368: ST_TO_ADDR
// PlaceUnitXYR ( Burlak , X , Y , 6 , false ) ;
4369: LD_EXP 10
4373: PPUSH
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_VAR 0 5
4383: PPUSH
4384: LD_INT 6
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 50
// Seznam = UnitFilter ( Konvoj , [ [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
4394: LD_ADDR_VAR 0 6
4398: PUSH
4399: LD_EXP 24
4403: PPUSH
4404: LD_INT 33
4406: PUSH
4407: LD_INT 1
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: PPUSH
4417: CALL_OW 72
4421: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , Seznam ) ;
4422: LD_ADDR_VAR 0 7
4426: PUSH
4427: LD_EXP 22
4431: PPUSH
4432: LD_VAR 0 6
4436: PPUSH
4437: CALL 5484 0 2
4441: ST_TO_ADDR
// for I = 1 to Seznam do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: DOUBLE
4448: LD_INT 1
4450: DEC
4451: ST_TO_ADDR
4452: LD_VAR 0 6
4456: PUSH
4457: FOR_TO
4458: IFFALSE 4500
// if Ridici >= I then
4460: LD_VAR 0 7
4464: PUSH
4465: LD_VAR 0 2
4469: GREATEREQUAL
4470: IFFALSE 4498
// PlaceHumanInUnit ( Ridici [ I ] , Seznam [ I ] ) ;
4472: LD_VAR 0 7
4476: PUSH
4477: LD_VAR 0 2
4481: ARRAY
4482: PPUSH
4483: LD_VAR 0 6
4487: PUSH
4488: LD_VAR 0 2
4492: ARRAY
4493: PPUSH
4494: CALL_OW 52
4498: GO 4457
4500: POP
4501: POP
// place_list ( Konvoj , Start1 ) ;
4502: LD_EXP 24
4506: PPUSH
4507: LD_INT 12
4509: PPUSH
4510: CALL 20678 0 2
// place_list ( Rusaci diff Ridici , Start1 ) ;
4514: LD_EXP 22
4518: PUSH
4519: LD_VAR 0 7
4523: DIFF
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: CALL 20678 0 2
// place_list ( Yelena , Start1Vsevolod ) ;
4532: LD_EXP 13
4536: PPUSH
4537: LD_INT 16
4539: PPUSH
4540: CALL 20678 0 2
// place_list ( WithVsevolod , Start1Vsevolod ) ;
4544: LD_EXP 23
4548: PPUSH
4549: LD_INT 16
4551: PPUSH
4552: CALL 20678 0 2
// InGameOn ;
4556: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
4560: LD_EXP 10
4564: PPUSH
4565: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
4569: LD_EXP 10
4573: PUSH
4574: EMPTY
4575: LIST
4576: PPUSH
4577: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
4581: LD_EXP 10
4585: PUSH
4586: EMPTY
4587: LIST
4588: PPUSH
4589: CALL_OW 85
// dialog_Start ;
4593: CALL 21321 0 0
// dialog_StartVS ;
4597: CALL 21341 0 0
// dialog_Start2 ;
4601: CALL 21381 0 0
// ChangeMissionObjectives ( MStart ) ;
4605: LD_STRING MStart
4607: PPUSH
4608: CALL_OW 337
// jdete_k_sobe ( Burlak , Vsevolod ) ;
4612: LD_EXP 10
4616: PPUSH
4617: LD_EXP 11
4621: PPUSH
4622: CALL 20599 0 2
// AddComHold ( [ Burlak , Vsevolod ] ) ;
4626: LD_EXP 10
4630: PUSH
4631: LD_EXP 11
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 200
// CenterOnUnits ( [ Burlak , Vsevolod ] ) ;
4644: LD_EXP 10
4648: PUSH
4649: LD_EXP 11
4653: PUSH
4654: EMPTY
4655: LIST
4656: LIST
4657: PPUSH
4658: CALL_OW 85
// RevealFogArea ( side_Ru , RuDepotFog ) ;
4662: LD_EXP 2
4666: PPUSH
4667: LD_INT 15
4669: PPUSH
4670: CALL_OW 332
// dialog_MeetVsevolodVS ;
4674: CALL 21413 0 0
// CenterOnUnits ( [ RuDepot , RuLab , RuOil ] ) ;
4678: LD_EXP 31
4682: PUSH
4683: LD_EXP 32
4687: PUSH
4688: LD_EXP 33
4692: PUSH
4693: EMPTY
4694: LIST
4695: LIST
4696: LIST
4697: PPUSH
4698: CALL_OW 85
// Wait ( 0 0$2 ) ;
4702: LD_INT 70
4704: PPUSH
4705: CALL_OW 67
// CenterOnUnits ( Burlak ) ;
4709: LD_EXP 10
4713: PPUSH
4714: CALL_OW 85
// ComMoveToArea ( Vsevolod , Mina ) ;
4718: LD_EXP 11
4722: PPUSH
4723: LD_INT 17
4725: PPUSH
4726: CALL_OW 113
// ComWait ( WithVsevolod , 0 0$5 ) ;
4730: LD_EXP 23
4734: PPUSH
4735: LD_INT 175
4737: PPUSH
4738: CALL_OW 142
// AddComMoveToArea ( WithVsevolod , Mina ) ;
4742: LD_EXP 23
4746: PPUSH
4747: LD_INT 17
4749: PPUSH
4750: CALL_OW 173
// AddComMoveToArea ( Vsevolod , RuDepotFog ) ;
4754: LD_EXP 11
4758: PPUSH
4759: LD_INT 15
4761: PPUSH
4762: CALL_OW 173
// AddComMoveToArea ( WithVsevolod , RuDepotFog ) ;
4766: LD_EXP 23
4770: PPUSH
4771: LD_INT 15
4773: PPUSH
4774: CALL_OW 173
// Counter = 0 ;
4778: LD_ADDR_VAR 0 3
4782: PUSH
4783: LD_INT 0
4785: ST_TO_ADDR
// while not IsInArea ( Vsevolod , Mina ) do
4786: LD_EXP 11
4790: PPUSH
4791: LD_INT 17
4793: PPUSH
4794: CALL_OW 308
4798: NOT
4799: IFFALSE 4847
// begin Wait ( 0 0$0.5 ) ;
4801: LD_INT 18
4803: PPUSH
4804: CALL_OW 67
// Counter = Counter + 1 ;
4808: LD_ADDR_VAR 0 3
4812: PUSH
4813: LD_VAR 0 3
4817: PUSH
4818: LD_INT 1
4820: PLUS
4821: ST_TO_ADDR
// if Counter mod 10 = 0 then
4822: LD_VAR 0 3
4826: PUSH
4827: LD_INT 10
4829: MOD
4830: PUSH
4831: LD_INT 0
4833: EQUAL
4834: IFFALSE 4845
// CenterOnUnits ( Vsevolod ) ;
4836: LD_EXP 11
4840: PPUSH
4841: CALL_OW 85
// end ;
4845: GO 4786
// CenterOnUnits ( Vsevolod ) ;
4847: LD_EXP 11
4851: PPUSH
4852: CALL_OW 85
// Wait ( 0 0$1 ) ;
4856: LD_INT 35
4858: PPUSH
4859: CALL_OW 67
// ComHold ( Vsevolod ) ;
4863: LD_EXP 11
4867: PPUSH
4868: CALL_OW 140
// X = GetX ( Vsevolod ) ;
4872: LD_ADDR_VAR 0 4
4876: PUSH
4877: LD_EXP 11
4881: PPUSH
4882: CALL_OW 250
4886: ST_TO_ADDR
// Y = GetY ( Vsevolod ) ;
4887: LD_ADDR_VAR 0 5
4891: PUSH
4892: LD_EXP 11
4896: PPUSH
4897: CALL_OW 251
4901: ST_TO_ADDR
// MineExplosion ( X , Y , false ) ;
4902: LD_VAR 0 4
4906: PPUSH
4907: LD_VAR 0 5
4911: PPUSH
4912: LD_INT 0
4914: PPUSH
4915: CALL_OW 453
// SetLives ( [ RuLab , RuOil ] , 25 ) ;
4919: LD_EXP 32
4923: PUSH
4924: LD_EXP 33
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PPUSH
4933: LD_INT 25
4935: PPUSH
4936: CALL_OW 234
// MineExplosion ( GetX ( RuLab ) , GetY ( RuLab ) , true ) ;
4940: LD_EXP 32
4944: PPUSH
4945: CALL_OW 250
4949: PPUSH
4950: LD_EXP 32
4954: PPUSH
4955: CALL_OW 251
4959: PPUSH
4960: LD_INT 1
4962: PPUSH
4963: CALL_OW 453
// MineExplosion ( GetX ( RuOil ) , GetY ( RuOil ) , true ) ;
4967: LD_EXP 33
4971: PPUSH
4972: CALL_OW 250
4976: PPUSH
4977: LD_EXP 33
4981: PPUSH
4982: CALL_OW 251
4986: PPUSH
4987: LD_INT 1
4989: PPUSH
4990: CALL_OW 453
// Wait ( 0 0$0.5 ) ;
4994: LD_INT 18
4996: PPUSH
4997: CALL_OW 67
// SetLives ( Vsevolod , HRANICE_UMIRANI ) ;
5001: LD_EXP 11
5005: PPUSH
5006: LD_INT 250
5008: PPUSH
5009: CALL_OW 234
// KdoSlaplNaMinu = [ Vsevolod ] ;
5013: LD_ADDR_LOC 4
5017: PUSH
5018: LD_EXP 11
5022: PUSH
5023: EMPTY
5024: LIST
5025: ST_TO_ADDR
// for I in FilterAllUnits ( [ [ F_PLACED ] ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 52
5033: PUSH
5034: EMPTY
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: PUSH
5045: FOR_IN
5046: IFFALSE 5128
// begin if I = Vsevolod then
5048: LD_VAR 0 2
5052: PUSH
5053: LD_EXP 11
5057: EQUAL
5058: IFFALSE 5062
// continue ;
5060: GO 5045
// if IsInUnit ( I ) then
5062: LD_VAR 0 2
5066: PPUSH
5067: CALL_OW 310
5071: IFFALSE 5075
// continue ;
5073: GO 5045
// if GetDistUnits ( Vsevolod , I ) <= 3 then
5075: LD_EXP 11
5079: PPUSH
5080: LD_VAR 0 2
5084: PPUSH
5085: CALL_OW 296
5089: PUSH
5090: LD_INT 3
5092: LESSEQUAL
5093: IFFALSE 5126
// begin SetLives ( I , HRANICE_UMIRANI ) ;
5095: LD_VAR 0 2
5099: PPUSH
5100: LD_INT 250
5102: PPUSH
5103: CALL_OW 234
// KdoSlaplNaMinu = KdoSlaplNaMinu union [ I ] ;
5107: LD_ADDR_LOC 4
5111: PUSH
5112: LD_LOC 4
5116: PUSH
5117: LD_VAR 0 2
5121: PUSH
5122: EMPTY
5123: LIST
5124: UNION
5125: ST_TO_ADDR
// end ; end ;
5126: GO 5045
5128: POP
5129: POP
// ComCancel ( WithVsevolod ) ;
5130: LD_EXP 23
5134: PPUSH
5135: CALL_OW 127
// ComHold ( WithVsevolod ) ;
5139: LD_EXP 23
5143: PPUSH
5144: CALL_OW 140
// dialog_StasisVS ;
5148: CALL 21469 0 0
// Wait ( 0 0$2 ) ;
5152: LD_INT 70
5154: PPUSH
5155: CALL_OW 67
// ChangeMissionObjectives ( MVsevolod ) ;
5159: LD_STRING MVsevolod
5161: PPUSH
5162: CALL_OW 337
// enable ( 1 ) ;
5166: LD_INT 1
5168: ENABLE_MARKED
// enable ( 2 ) ;
5169: LD_INT 2
5171: ENABLE_MARKED
// SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5172: LD_LOC 4
5176: PPUSH
5177: LD_INT 250
5179: PPUSH
5180: CALL_OW 234
// SetSide ( Vsevolod , side_Ru ) ;
5184: LD_EXP 11
5188: PPUSH
5189: LD_EXP 2
5193: PPUSH
5194: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
5198: LD_EXP 23
5202: PPUSH
5203: LD_EXP 2
5207: PPUSH
5208: CALL_OW 235
// ComFree ( [ Burlak , Vsevolod ] ) ;
5212: LD_EXP 10
5216: PUSH
5217: LD_EXP 11
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PPUSH
5226: CALL_OW 139
// SaveForQuickRestart ;
5230: CALL_OW 22
// InGameOff ;
5234: CALL_OW 9
// enable ( 5 ) ;
5238: LD_INT 5
5240: ENABLE_MARKED
// end ;
5241: LD_VAR 0 1
5245: RET
// every 0 0$5 marked 5 do var Kolik , I ;
5246: GO 5248
5248: DISABLE
5249: LD_INT 0
5251: PPUSH
5252: PPUSH
// begin if Difficulty = 1 then
5253: LD_OWVAR 67
5257: PUSH
5258: LD_INT 1
5260: EQUAL
5261: IFFALSE 5273
// Kolik = 20 else
5263: LD_ADDR_VAR 0 1
5267: PUSH
5268: LD_INT 20
5270: ST_TO_ADDR
5271: GO 5295
// if Difficulty = 2 then
5273: LD_OWVAR 67
5277: PUSH
5278: LD_INT 2
5280: EQUAL
5281: IFFALSE 5293
// Kolik = 10 else
5283: LD_ADDR_VAR 0 1
5287: PUSH
5288: LD_INT 10
5290: ST_TO_ADDR
5291: GO 5295
// exit ;
5293: GO 5336
// for I = 1 to Kolik do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: DOUBLE
5301: LD_INT 1
5303: DEC
5304: ST_TO_ADDR
5305: LD_VAR 0 1
5309: PUSH
5310: FOR_TO
5311: IFFALSE 5334
// begin SetLives ( KdoSlaplNaMinu , HRANICE_UMIRANI ) ;
5313: LD_LOC 4
5317: PPUSH
5318: LD_INT 250
5320: PPUSH
5321: CALL_OW 234
// Wait ( 0 0$1 ) ;
5325: LD_INT 35
5327: PPUSH
5328: CALL_OW 67
// end ;
5332: GO 5310
5334: POP
5335: POP
// end ;
5336: PPOPN 2
5338: END
// function vytvor_nakladaky ; var N1 , N2 ; begin
5339: LD_INT 0
5341: PPUSH
5342: PPUSH
5343: PPUSH
// UC_side = side_Ru ;
5344: LD_ADDR_OWVAR 20
5348: PUSH
5349: LD_EXP 2
5353: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
5354: LD_ADDR_OWVAR 21
5358: PUSH
5359: LD_INT 3
5361: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
5362: LD_ADDR_OWVAR 37
5366: PUSH
5367: LD_INT 21
5369: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
5370: LD_ADDR_OWVAR 38
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
5378: LD_ADDR_OWVAR 39
5382: PUSH
5383: LD_INT 1
5385: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
5386: LD_ADDR_OWVAR 40
5390: PUSH
5391: LD_INT 51
5393: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 75 , 100 ) ;
5394: LD_ADDR_OWVAR 41
5398: PUSH
5399: LD_INT 75
5401: PPUSH
5402: LD_INT 100
5404: PPUSH
5405: CALL_OW 12
5409: ST_TO_ADDR
// N1 = CreateVehicle ;
5410: LD_ADDR_VAR 0 2
5414: PUSH
5415: CALL_OW 45
5419: ST_TO_ADDR
// N2 = CreateVehicle ;
5420: LD_ADDR_VAR 0 3
5424: PUSH
5425: CALL_OW 45
5429: ST_TO_ADDR
// SetCargo ( N1 , MAT_CANS , 100 ) ;
5430: LD_VAR 0 2
5434: PPUSH
5435: LD_INT 1
5437: PPUSH
5438: LD_INT 100
5440: PPUSH
5441: CALL_OW 290
// SetCargo ( N2 , MAT_SIBERIT , 100 ) ;
5445: LD_VAR 0 3
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 100
5455: PPUSH
5456: CALL_OW 290
// Result = [ N1 , N2 ] ;
5460: LD_ADDR_VAR 0 1
5464: PUSH
5465: LD_VAR 0 2
5469: PUSH
5470: LD_VAR 0 3
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: ST_TO_ADDR
// end ;
5479: LD_VAR 0 1
5483: RET
// function zjisti_ridice ( Seznam , Pocet ) ; var I , Ted ; begin
5484: LD_INT 0
5486: PPUSH
5487: PPUSH
5488: PPUSH
// Result = [ ] ;
5489: LD_ADDR_VAR 0 3
5493: PUSH
5494: EMPTY
5495: ST_TO_ADDR
// while ( Result < Pocet + 0 ) and Seznam do
5496: LD_VAR 0 3
5500: PUSH
5501: LD_VAR 0 2
5505: PUSH
5506: LD_INT 0
5508: PLUS
5509: LESS
5510: PUSH
5511: LD_VAR 0 1
5515: AND
5516: IFFALSE 5577
// begin Ted = Seznam [ 1 ] ;
5518: LD_ADDR_VAR 0 5
5522: PUSH
5523: LD_VAR 0 1
5527: PUSH
5528: LD_INT 1
5530: ARRAY
5531: ST_TO_ADDR
// Seznam = Delete ( Seznam , 1 ) ;
5532: LD_ADDR_VAR 0 1
5536: PUSH
5537: LD_VAR 0 1
5541: PPUSH
5542: LD_INT 1
5544: PPUSH
5545: CALL_OW 3
5549: ST_TO_ADDR
// if Ted then
5550: LD_VAR 0 5
5554: IFFALSE 5575
// Result = Result union [ Ted ] ;
5556: LD_ADDR_VAR 0 3
5560: PUSH
5561: LD_VAR 0 3
5565: PUSH
5566: LD_VAR 0 5
5570: PUSH
5571: EMPTY
5572: LIST
5573: UNION
5574: ST_TO_ADDR
// end ;
5575: GO 5496
// end ;
5577: LD_VAR 0 3
5581: RET
// function uvod_sam ; var I , Seznam , Ridici ; begin
5582: LD_INT 0
5584: PPUSH
5585: PPUSH
5586: PPUSH
5587: PPUSH
// SetSide ( Rusaci , side_Ru ) ;
5588: LD_EXP 22
5592: PPUSH
5593: LD_EXP 2
5597: PPUSH
5598: CALL_OW 235
// SetSide ( Yelena , side_Ru ) ;
5602: LD_EXP 13
5606: PPUSH
5607: LD_EXP 2
5611: PPUSH
5612: CALL_OW 235
// while Rusaci <= 7 do
5616: LD_EXP 22
5620: PUSH
5621: LD_INT 7
5623: LESSEQUAL
5624: IFFALSE 5647
// Rusaci = Rusaci union [ vytvor_rusaka ] ;
5626: LD_ADDR_EXP 22
5630: PUSH
5631: LD_EXP 22
5635: PUSH
5636: CALL 4089 0 0
5640: PUSH
5641: EMPTY
5642: LIST
5643: UNION
5644: ST_TO_ADDR
5645: GO 5616
// Rusaci = Rusaci union [ Yelena ] ;
5647: LD_ADDR_EXP 22
5651: PUSH
5652: LD_EXP 22
5656: PUSH
5657: LD_EXP 13
5661: PUSH
5662: EMPTY
5663: LIST
5664: UNION
5665: ST_TO_ADDR
// SetTech ( TECH_SIBDET , side_Ru , STATE_RESEARCHED ) ;
5666: LD_INT 20
5668: PPUSH
5669: LD_EXP 2
5673: PPUSH
5674: LD_INT 2
5676: PPUSH
5677: CALL_OW 322
// Seznam = UnitFilter ( Rusaci union [ Burlak ] , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
5681: LD_ADDR_VAR 0 3
5685: PUSH
5686: LD_EXP 22
5690: PUSH
5691: LD_EXP 10
5695: PUSH
5696: EMPTY
5697: LIST
5698: UNION
5699: PPUSH
5700: LD_INT 22
5702: PUSH
5703: LD_EXP 2
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PUSH
5712: LD_INT 21
5714: PUSH
5715: LD_INT 1
5717: PUSH
5718: EMPTY
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 25
5724: PUSH
5725: LD_INT 2
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: PPUSH
5737: CALL_OW 72
5741: ST_TO_ADDR
// if not Seznam then
5742: LD_VAR 0 3
5746: NOT
5747: IFFALSE 5761
// SetClass ( Burlak , CLASS_ENGINEER ) ;
5749: LD_EXP 10
5753: PPUSH
5754: LD_INT 2
5756: PPUSH
5757: CALL_OW 336
// Seznam = vytvor_nakladaky ;
5761: LD_ADDR_VAR 0 3
5765: PUSH
5766: CALL 5339 0 0
5770: ST_TO_ADDR
// Ridici = zjisti_ridice ( Rusaci , 2 ) ;
5771: LD_ADDR_VAR 0 4
5775: PUSH
5776: LD_EXP 22
5780: PPUSH
5781: LD_INT 2
5783: PPUSH
5784: CALL 5484 0 2
5788: ST_TO_ADDR
// if Ridici >= 1 then
5789: LD_VAR 0 4
5793: PUSH
5794: LD_INT 1
5796: GREATEREQUAL
5797: IFFALSE 5821
// PlaceHumanInUnit ( Ridici [ 1 ] , Seznam [ 1 ] ) ;
5799: LD_VAR 0 4
5803: PUSH
5804: LD_INT 1
5806: ARRAY
5807: PPUSH
5808: LD_VAR 0 3
5812: PUSH
5813: LD_INT 1
5815: ARRAY
5816: PPUSH
5817: CALL_OW 52
// if Ridici >= 2 then
5821: LD_VAR 0 4
5825: PUSH
5826: LD_INT 2
5828: GREATEREQUAL
5829: IFFALSE 5853
// PlaceHumanInUnit ( Ridici [ 2 ] , Seznam [ 2 ] ) ;
5831: LD_VAR 0 4
5835: PUSH
5836: LD_INT 2
5838: ARRAY
5839: PPUSH
5840: LD_VAR 0 3
5844: PUSH
5845: LD_INT 2
5847: ARRAY
5848: PPUSH
5849: CALL_OW 52
// PlaceUnitArea ( Burlak , Start1a , false ) ;
5853: LD_EXP 10
5857: PPUSH
5858: LD_INT 13
5860: PPUSH
5861: LD_INT 0
5863: PPUSH
5864: CALL_OW 49
// Place_list ( Seznam , Start1a ) ;
5868: LD_VAR 0 3
5872: PPUSH
5873: LD_INT 13
5875: PPUSH
5876: CALL 20678 0 2
// place_list ( Rusaci diff Ridici , Start1a ) ;
5880: LD_EXP 22
5884: PUSH
5885: LD_VAR 0 4
5889: DIFF
5890: PPUSH
5891: LD_INT 13
5893: PPUSH
5894: CALL 20678 0 2
// for I = 1 to Rand ( 2 , 4 ) do
5898: LD_ADDR_VAR 0 2
5902: PUSH
5903: DOUBLE
5904: LD_INT 1
5906: DEC
5907: ST_TO_ADDR
5908: LD_INT 2
5910: PPUSH
5911: LD_INT 4
5913: PPUSH
5914: CALL_OW 12
5918: PUSH
5919: FOR_TO
5920: IFFALSE 5945
// CreateCratesArea ( Rand ( 1 , 5 ) , BednyRusoveV , false ) ;
5922: LD_INT 1
5924: PPUSH
5925: LD_INT 5
5927: PPUSH
5928: CALL_OW 12
5932: PPUSH
5933: LD_INT 29
5935: PPUSH
5936: LD_INT 0
5938: PPUSH
5939: CALL_OW 55
5943: GO 5919
5945: POP
5946: POP
// InGameOn ;
5947: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
5951: LD_EXP 10
5955: PPUSH
5956: CALL_OW 87
// AddComHold ( [ Burlak ] ) ;
5960: LD_EXP 10
5964: PUSH
5965: EMPTY
5966: LIST
5967: PPUSH
5968: CALL_OW 200
// CenterOnUnits ( [ Burlak ] ) ;
5972: LD_EXP 10
5976: PUSH
5977: EMPTY
5978: LIST
5979: PPUSH
5980: CALL_OW 85
// dialog_Start ;
5984: CALL 21321 0 0
// dialog_StartNV ;
5988: CALL 21361 0 0
// dialog_Start2 ;
5992: CALL 21381 0 0
// ChangeMissionObjectives ( MStart ) ;
5996: LD_STRING MStart
5998: PPUSH
5999: CALL_OW 337
// enable ( 4 ) ;
6003: LD_INT 4
6005: ENABLE_MARKED
// AddComFree ( Burlak ) ;
6006: LD_EXP 10
6010: PPUSH
6011: CALL_OW 199
// SaveForQuickRestart ;
6015: CALL_OW 22
// InGameOff ;
6019: CALL_OW 9
// arabi_muzete_utocit ;
6023: CALL 10506 0 0
// end ;
6027: LD_VAR 0 1
6031: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
6032: LD_INT 0
6034: PPUSH
// if Un = Burlak then
6035: LD_VAR 0 1
6039: PUSH
6040: LD_EXP 10
6044: EQUAL
6045: IFFALSE 6056
// begin YouLost ( Burlak ) ;
6047: LD_STRING Burlak
6049: PPUSH
6050: CALL_OW 104
// exit ;
6054: GO 6077
// end ; if Un = Vsevolod then
6056: LD_VAR 0 1
6060: PUSH
6061: LD_EXP 11
6065: EQUAL
6066: IFFALSE 6077
// begin YouLost ( Sevi ) ;
6068: LD_STRING Sevi
6070: PPUSH
6071: CALL_OW 104
// exit ;
6075: GO 6077
// end ; end ;
6077: LD_VAR 0 2
6081: RET
// function mozny_prichod_yashina ; begin
6082: LD_INT 0
6084: PPUSH
// if not YashinZacal then
6085: LD_LOC 3
6089: NOT
6090: IFFALSE 6104
// begin YashinZacal = true ;
6092: LD_ADDR_LOC 3
6096: PUSH
6097: LD_INT 1
6099: ST_TO_ADDR
// yashin_start_timer ;
6100: CALL 13217 0 0
// end ; end ;
6104: LD_VAR 0 1
6108: RET
// export function rusove_BuildingComplete ( Un ) ; begin
6109: LD_INT 0
6111: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and ( GetBType ( Un ) in [ B_WORKSHOP , B_FACTORY ] ) then
6112: LD_VAR 0 1
6116: PPUSH
6117: CALL_OW 255
6121: PUSH
6122: LD_EXP 2
6126: EQUAL
6127: PUSH
6128: LD_VAR 0 1
6132: PPUSH
6133: CALL_OW 266
6137: PUSH
6138: LD_INT 2
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: IN
6148: AND
6149: IFFALSE 6155
// begin mozny_prichod_yashina ;
6151: CALL 6082 0 0
// end ; end ;
6155: LD_VAR 0 2
6159: RET
// every 25 25$0 do
6160: GO 6162
6162: DISABLE
// begin mozny_prichod_yashina ;
6163: CALL 6082 0 0
// end ;
6167: END
// every 0 0$3 + 0 0$1.2 marked 2 do
6168: GO 6170
6170: DISABLE
// begin if not IsOK ( Vsevolod ) then
6171: LD_EXP 11
6175: PPUSH
6176: CALL_OW 302
6180: NOT
6181: IFFALSE 6186
// enable else
6183: ENABLE
6184: GO 6233
// begin DialogueOn ;
6186: CALL_OW 6
// dialog_SeviSaved ;
6190: CALL 21635 0 0
// SetSide ( Vsevolod , side_Ru ) ;
6194: LD_EXP 11
6198: PPUSH
6199: LD_EXP 2
6203: PPUSH
6204: CALL_OW 235
// SetSide ( WithVsevolod , side_Ru ) ;
6208: LD_EXP 23
6212: PPUSH
6213: LD_EXP 2
6217: PPUSH
6218: CALL_OW 235
// DialogueOff ;
6222: CALL_OW 7
// enable ( 3 ) ;
6226: LD_INT 3
6228: ENABLE_MARKED
// arabi_muzete_utocit ;
6229: CALL 10506 0 0
// end ; end ;
6233: END
// export function rusove_Contact ( Side1 , Side2 ) ; begin
6234: LD_INT 0
6236: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Ar ) ) or ( ( Side1 = side_Ar ) and ( Side2 = side_Ru ) ) then
6237: LD_VAR 0 1
6241: PUSH
6242: LD_EXP 2
6246: EQUAL
6247: PUSH
6248: LD_VAR 0 2
6252: PUSH
6253: LD_EXP 4
6257: EQUAL
6258: AND
6259: PUSH
6260: LD_VAR 0 1
6264: PUSH
6265: LD_EXP 4
6269: EQUAL
6270: PUSH
6271: LD_VAR 0 2
6275: PUSH
6276: LD_EXP 2
6280: EQUAL
6281: AND
6282: OR
6283: IFFALSE 6293
// VidelAraby = true ;
6285: LD_ADDR_LOC 2
6289: PUSH
6290: LD_INT 1
6292: ST_TO_ADDR
// end ;
6293: LD_VAR 0 3
6297: RET
// every 5 5$0 do
6298: GO 6300
6300: DISABLE
// begin ContactIn5Min = VidelAraby ;
6301: LD_ADDR_EXP 28
6305: PUSH
6306: LD_LOC 2
6310: ST_TO_ADDR
// end ;
6311: END
// every 30 30$0 do
6312: GO 6314
6314: DISABLE
// begin if Difficulty = 1 then
6315: LD_OWVAR 67
6319: PUSH
6320: LD_INT 1
6322: EQUAL
6323: IFFALSE 6334
// wait ( 15 15$0 ) else
6325: LD_INT 31500
6327: PPUSH
6328: CALL_OW 67
6332: GO 6351
// if Difficulty = 2 then
6334: LD_OWVAR 67
6338: PUSH
6339: LD_INT 2
6341: EQUAL
6342: IFFALSE 6351
// Wait ( 5 5$0 ) ;
6344: LD_INT 10500
6346: PPUSH
6347: CALL_OW 67
// PropaslQuickly = true ;
6351: LD_ADDR_EXP 29
6355: PUSH
6356: LD_INT 1
6358: ST_TO_ADDR
// end ;
6359: END
// every 2 2$35 marked 3 do
6360: GO 6362
6362: DISABLE
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
6363: LD_INT 35
6365: PPUSH
6366: LD_INT 1050
6368: PPUSH
6369: CALL_OW 12
6373: PPUSH
6374: CALL_OW 67
// xavier_start ;
6378: CALL 15221 0 0
// end ;
6382: END
// every 4 4$45 marked 4 do
6383: GO 6385
6385: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
6386: LD_INT 35
6388: PPUSH
6389: LD_INT 2100
6391: PPUSH
6392: CALL_OW 12
6396: PPUSH
6397: CALL_OW 67
// xavier_start ;
6401: CALL 15221 0 0
// end ; end_of_file
6405: END
// var Zniceno ; var Autaky ; var Obranci ; var VolnyLidi ; var Utok_Auta ; var Utok_ZbyvaMinut ; var CasyUtoku ; var VidelRusa ; var PstZbrane ; var ProbihaUtok ; var CisloUtoku ; var Patrola ; var PatrolaZrusena ; var Registry ; var RegUtok ; var MakroObrana ; var MakroUtok ; var MakroBunkry ; var MakroPresunZakladna ; var BeziStahovani ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var Miny ; var ProbihaOprava ; var ProbihaLeceni ; export function init_arabi ; var Kdo , Budovy ; begin
6406: LD_INT 0
6408: PPUSH
6409: PPUSH
6410: PPUSH
// disable ( 43 ) ;
6411: LD_INT 43
6413: DISABLE_MARKED
// disable ( 44 ) ;
6414: LD_INT 44
6416: DISABLE_MARKED
// disable ( 45 ) ;
6417: LD_INT 45
6419: DISABLE_MARKED
// disable ( 46 ) ;
6420: LD_INT 46
6422: DISABLE_MARKED
// disable ( 47 ) ;
6423: LD_INT 47
6425: DISABLE_MARKED
// SetBName ( ArDepot , newkabul ) ;
6426: LD_INT 3
6428: PPUSH
6429: LD_STRING newkabul
6431: PPUSH
6432: CALL_OW 500
// Autaky = [ ArTank1 , ArTank2 ] ;
6436: LD_ADDR_LOC 6
6440: PUSH
6441: LD_INT 12
6443: PUSH
6444: LD_INT 13
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: ST_TO_ADDR
// Patrola = [ ArTank1 ] ;
6451: LD_ADDR_LOC 16
6455: PUSH
6456: LD_INT 12
6458: PUSH
6459: EMPTY
6460: LIST
6461: ST_TO_ADDR
// Obranci = vytvor_obrance ;
6462: LD_ADDR_LOC 7
6466: PUSH
6467: CALL 7330 0 0
6471: ST_TO_ADDR
// place_list ( Obranci , AraboveParkoviste ) ;
6472: LD_LOC 7
6476: PPUSH
6477: LD_INT 18
6479: PPUSH
6480: CALL 20678 0 2
// Obranci = Obranci union [ ArSolBunk1 , ArSolBunk4 , ArSolBunk6 ] ;
6484: LD_ADDR_LOC 7
6488: PUSH
6489: LD_LOC 7
6493: PUSH
6494: LD_INT 39
6496: PUSH
6497: LD_INT 28
6499: PUSH
6500: LD_INT 31
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: UNION
6508: ST_TO_ADDR
// VolnyLidi = vytvor_volny ;
6509: LD_ADDR_LOC 8
6513: PUSH
6514: CALL 7396 0 0
6518: ST_TO_ADDR
// place_list ( VolnyLidi , AraboveVolni ) ;
6519: LD_LOC 8
6523: PPUSH
6524: LD_INT 36
6526: PPUSH
6527: CALL 20678 0 2
// VolnyLidi = VolnyLidi union [ ArMech1 , ArMech2 ] ;
6531: LD_ADDR_LOC 8
6535: PUSH
6536: LD_LOC 8
6540: PUSH
6541: LD_INT 19
6543: PUSH
6544: LD_INT 20
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: UNION
6551: ST_TO_ADDR
// Utok_Auta = [ ] ;
6552: LD_ADDR_LOC 9
6556: PUSH
6557: EMPTY
6558: ST_TO_ADDR
// ArDalkar = 0 ;
6559: LD_ADDR_LOC 25
6563: PUSH
6564: LD_INT 0
6566: ST_TO_ADDR
// KolikDalkovych = 0 ;
6567: LD_ADDR_LOC 26
6571: PUSH
6572: LD_INT 0
6574: ST_TO_ADDR
// DelamDalkare = false ;
6575: LD_ADDR_LOC 27
6579: PUSH
6580: LD_INT 0
6582: ST_TO_ADDR
// Zniceno = false ;
6583: LD_ADDR_LOC 5
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// VidelRusa = false ;
6591: LD_ADDR_LOC 12
6595: PUSH
6596: LD_INT 0
6598: ST_TO_ADDR
// ProbihaUtok = false ;
6599: LD_ADDR_LOC 14
6603: PUSH
6604: LD_INT 0
6606: ST_TO_ADDR
// PatrolaZrusena = false ;
6607: LD_ADDR_LOC 17
6611: PUSH
6612: LD_INT 0
6614: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
6615: LD_ADDR_LOC 11
6619: PUSH
6620: LD_EXP 52
6624: PUSH
6625: LD_OWVAR 67
6629: ARRAY
6630: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
6631: LD_ADDR_LOC 13
6635: PUSH
6636: LD_EXP 51
6640: PUSH
6641: LD_OWVAR 67
6645: ARRAY
6646: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
6647: LD_ADDR_LOC 10
6651: PUSH
6652: LD_INT 1
6654: NEG
6655: ST_TO_ADDR
// CisloUtoku = 1 ;
6656: LD_ADDR_LOC 15
6660: PUSH
6661: LD_INT 1
6663: ST_TO_ADDR
// BeziStahovani = false ;
6664: LD_ADDR_LOC 24
6668: PUSH
6669: LD_INT 0
6671: ST_TO_ADDR
// ProbihaOprava = false ;
6672: LD_ADDR_LOC 29
6676: PUSH
6677: LD_INT 0
6679: ST_TO_ADDR
// ProbihaLeceni = false ;
6680: LD_ADDR_LOC 30
6684: PUSH
6685: LD_INT 0
6687: ST_TO_ADDR
// if Difficulty = 1 then
6688: LD_OWVAR 67
6692: PUSH
6693: LD_INT 1
6695: EQUAL
6696: IFFALSE 6726
// begin DestroyUnit ( ArObr2 ) ;
6698: LD_INT 46
6700: PPUSH
6701: CALL_OW 65
// DestroyUnit ( ArObrM1 ) ;
6705: LD_INT 47
6707: PPUSH
6708: CALL_OW 65
// DestroyUnit ( ArObr1 ) ;
6712: LD_INT 45
6714: PPUSH
6715: CALL_OW 65
// DestroyUnit ( ArObrM2 ) ;
6719: LD_INT 48
6721: PPUSH
6722: CALL_OW 65
// end ; lidi_do_budov ;
6726: CALL 7495 0 0
// Kdo = Obranci union [ ArMech1 , ArMech2 , ArTank1 , ArTank2 ] union [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ;
6730: LD_ADDR_VAR 0 2
6734: PUSH
6735: LD_LOC 7
6739: PUSH
6740: LD_INT 19
6742: PUSH
6743: LD_INT 20
6745: PUSH
6746: LD_INT 12
6748: PUSH
6749: LD_INT 13
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: UNION
6758: PUSH
6759: LD_INT 15
6761: PUSH
6762: LD_INT 25
6764: PUSH
6765: LD_INT 33
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: LIST
6772: UNION
6773: ST_TO_ADDR
// if Difficulty > 1 then
6774: LD_OWVAR 67
6778: PUSH
6779: LD_INT 1
6781: GREATER
6782: IFFALSE 6813
// Kdo = Kdo union [ ArObr1 , ArObr2 , ArObrM1 , ArObrM2 ] ;
6784: LD_ADDR_VAR 0 2
6788: PUSH
6789: LD_VAR 0 2
6793: PUSH
6794: LD_INT 45
6796: PUSH
6797: LD_INT 46
6799: PUSH
6800: LD_INT 47
6802: PUSH
6803: LD_INT 48
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: LIST
6810: LIST
6811: UNION
6812: ST_TO_ADDR
// Kdo = Kdo diff [ Obranci [ 1 ] , Obranci [ 2 ] ] ;
6813: LD_ADDR_VAR 0 2
6817: PUSH
6818: LD_VAR 0 2
6822: PUSH
6823: LD_LOC 7
6827: PUSH
6828: LD_INT 1
6830: ARRAY
6831: PUSH
6832: LD_LOC 7
6836: PUSH
6837: LD_INT 2
6839: ARRAY
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: DIFF
6845: ST_TO_ADDR
// Registry = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , Obrana ] ] ) ;
6846: LD_ADDR_LOC 18
6850: PUSH
6851: LD_EXP 4
6855: PPUSH
6856: LD_INT 3
6858: PUSH
6859: LD_INT 37
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: PPUSH
6869: CALL_OW 399
6873: ST_TO_ADDR
// MakroBunkry = McCustom ( 20 , [ ArSolPBunk1 , ArSolPBunk2 , ArSolPBunk3 ] ) ;
6874: LD_ADDR_LOC 22
6878: PUSH
6879: LD_INT 20
6881: PPUSH
6882: LD_INT 15
6884: PUSH
6885: LD_INT 25
6887: PUSH
6888: LD_INT 33
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: PPUSH
6896: CALL_OW 416
6900: ST_TO_ADDR
// MakroObrana = McDefend ( 5 , Registry , Kdo union [ ArBunk1 , ArBunk3 , ArBunk4 , ArBunk5 ] , [ ] ) ;
6901: LD_ADDR_LOC 20
6905: PUSH
6906: LD_INT 5
6908: PPUSH
6909: LD_LOC 18
6913: PPUSH
6914: LD_VAR 0 2
6918: PUSH
6919: LD_INT 36
6921: PUSH
6922: LD_INT 26
6924: PUSH
6925: LD_INT 29
6927: PUSH
6928: LD_INT 40
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: UNION
6937: PPUSH
6938: EMPTY
6939: PPUSH
6940: CALL_OW 401
6944: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Kdo ) ;
6945: LD_ADDR_LOC 23
6949: PUSH
6950: LD_INT 1
6952: PPUSH
6953: LD_VAR 0 2
6957: PPUSH
6958: CALL_OW 416
6962: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , Rusove ] , MC_REG_IGNORE_FOG ] ) ;
6963: LD_ADDR_LOC 19
6967: PUSH
6968: LD_EXP 4
6972: PPUSH
6973: LD_INT 2
6975: PUSH
6976: LD_INT 40
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 7
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PPUSH
6990: CALL_OW 399
6994: ST_TO_ADDR
// init_miny ;
6995: CALL 7004 0 0
// end ;
6999: LD_VAR 0 1
7003: RET
// function init_miny ; var M ; begin
7004: LD_INT 0
7006: PPUSH
7007: PPUSH
// if Difficulty = 1 then
7008: LD_OWVAR 67
7012: PUSH
7013: LD_INT 1
7015: EQUAL
7016: IFFALSE 7027
// Miny = [ ] else
7018: LD_ADDR_LOC 28
7022: PUSH
7023: EMPTY
7024: ST_TO_ADDR
7025: GO 7235
// begin Miny = [ [ 62 , 14 ] , [ 64 , 17 ] , [ 66 , 17 ] , [ 65 , 12 ] , [ 68 , 15 ] , [ 64 , 14 ] , [ 60 , 5 ] , [ 60 , 15 ] , [ 59 , 18 ] , [ 56 , 16 ] , [ 49 , 15 ] , [ 33 , 18 ] , [ 42 , 42 ] , [ 112 , 42 ] ] ;
7027: LD_ADDR_LOC 28
7031: PUSH
7032: LD_INT 62
7034: PUSH
7035: LD_INT 14
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PUSH
7042: LD_INT 64
7044: PUSH
7045: LD_INT 17
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 66
7054: PUSH
7055: LD_INT 17
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 65
7064: PUSH
7065: LD_INT 12
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 68
7074: PUSH
7075: LD_INT 15
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 64
7084: PUSH
7085: LD_INT 14
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 60
7094: PUSH
7095: LD_INT 5
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: PUSH
7102: LD_INT 60
7104: PUSH
7105: LD_INT 15
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 59
7114: PUSH
7115: LD_INT 18
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 56
7124: PUSH
7125: LD_INT 16
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 49
7134: PUSH
7135: LD_INT 15
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 33
7144: PUSH
7145: LD_INT 18
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 42
7154: PUSH
7155: LD_INT 42
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: PUSH
7162: LD_INT 112
7164: PUSH
7165: LD_INT 42
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: LIST
7184: LIST
7185: LIST
7186: LIST
7187: ST_TO_ADDR
// for M in Miny do
7188: LD_ADDR_VAR 0 2
7192: PUSH
7193: LD_LOC 28
7197: PUSH
7198: FOR_IN
7199: IFFALSE 7233
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
7201: LD_VAR 0 2
7205: PUSH
7206: LD_INT 1
7208: ARRAY
7209: PPUSH
7210: LD_VAR 0 2
7214: PUSH
7215: LD_INT 2
7217: ARRAY
7218: PPUSH
7219: LD_EXP 4
7223: PPUSH
7224: LD_INT 0
7226: PPUSH
7227: CALL_OW 454
7231: GO 7198
7233: POP
7234: POP
// end ; end ;
7235: LD_VAR 0 1
7239: RET
// function vytvor_cloveka ( Cls ) ; begin
7240: LD_INT 0
7242: PPUSH
// UC_Side = side_Ar ;
7243: LD_ADDR_OWVAR 20
7247: PUSH
7248: LD_EXP 4
7252: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
7253: LD_ADDR_OWVAR 21
7257: PUSH
7258: LD_INT 2
7260: ST_TO_ADDR
// HC_Sex = Rand ( 1 , 2 ) ;
7261: LD_ADDR_OWVAR 27
7265: PUSH
7266: LD_INT 1
7268: PPUSH
7269: LD_INT 2
7271: PPUSH
7272: CALL_OW 12
7276: ST_TO_ADDR
// HC_Class = Cls ;
7277: LD_ADDR_OWVAR 28
7281: PUSH
7282: LD_VAR 0 1
7286: ST_TO_ADDR
// HC_Name =  ;
7287: LD_ADDR_OWVAR 26
7291: PUSH
7292: LD_STRING 
7294: ST_TO_ADDR
// PrepareClassSkills ( Cls , dif_ArabiLevel [ Difficulty ] ) ;
7295: LD_VAR 0 1
7299: PPUSH
7300: LD_EXP 47
7304: PUSH
7305: LD_OWVAR 67
7309: ARRAY
7310: PPUSH
7311: CALL_OW 374
// Result = CreateHuman ;
7315: LD_ADDR_VAR 0 2
7319: PUSH
7320: CALL_OW 44
7324: ST_TO_ADDR
// end ;
7325: LD_VAR 0 2
7329: RET
// function vytvor_obrance ; var I ; begin
7330: LD_INT 0
7332: PPUSH
7333: PPUSH
// Result = [ ] ;
7334: LD_ADDR_VAR 0 1
7338: PUSH
7339: EMPTY
7340: ST_TO_ADDR
// for I = 1 to dif_ObranciArabi [ Difficulty ] do
7341: LD_ADDR_VAR 0 2
7345: PUSH
7346: DOUBLE
7347: LD_INT 1
7349: DEC
7350: ST_TO_ADDR
7351: LD_EXP 49
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PUSH
7362: FOR_TO
7363: IFFALSE 7389
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] ;
7365: LD_ADDR_VAR 0 1
7369: PUSH
7370: LD_VAR 0 1
7374: PUSH
7375: LD_INT 1
7377: PPUSH
7378: CALL 7240 0 1
7382: PUSH
7383: EMPTY
7384: LIST
7385: UNION
7386: ST_TO_ADDR
7387: GO 7362
7389: POP
7390: POP
// end ;
7391: LD_VAR 0 1
7395: RET
// function vytvor_volny ; var I ; begin
7396: LD_INT 0
7398: PPUSH
7399: PPUSH
// Result = [ ] ;
7400: LD_ADDR_VAR 0 1
7404: PUSH
7405: EMPTY
7406: ST_TO_ADDR
// for I = 1 to dif_VolnyArabi [ Difficulty ] do
7407: LD_ADDR_VAR 0 2
7411: PUSH
7412: DOUBLE
7413: LD_INT 1
7415: DEC
7416: ST_TO_ADDR
7417: LD_EXP 48
7421: PUSH
7422: LD_OWVAR 67
7426: ARRAY
7427: PUSH
7428: FOR_TO
7429: IFFALSE 7488
// if Prob ( 25 ) then
7431: LD_INT 25
7433: PPUSH
7434: CALL_OW 13
7438: IFFALSE 7464
// Result = Result union [ vytvor_cloveka ( CLASS_SOLDIER ) ] else
7440: LD_ADDR_VAR 0 1
7444: PUSH
7445: LD_VAR 0 1
7449: PUSH
7450: LD_INT 1
7452: PPUSH
7453: CALL 7240 0 1
7457: PUSH
7458: EMPTY
7459: LIST
7460: UNION
7461: ST_TO_ADDR
7462: GO 7486
// Result = Result union [ vytvor_cloveka ( CLASS_MECHANIC ) ] ;
7464: LD_ADDR_VAR 0 1
7468: PUSH
7469: LD_VAR 0 1
7473: PUSH
7474: LD_INT 3
7476: PPUSH
7477: CALL 7240 0 1
7481: PUSH
7482: EMPTY
7483: LIST
7484: UNION
7485: ST_TO_ADDR
7486: GO 7428
7488: POP
7489: POP
// end ;
7490: LD_VAR 0 1
7494: RET
// function lidi_do_budov ; begin
7495: LD_INT 0
7497: PPUSH
// ComEnterUnit ( ArMech1 , ArTank1 ) ;
7498: LD_INT 19
7500: PPUSH
7501: LD_INT 12
7503: PPUSH
7504: CALL_OW 120
// ComEnterUnit ( ArMech , ArFact ) ;
7508: LD_INT 21
7510: PPUSH
7511: LD_INT 4
7513: PPUSH
7514: CALL_OW 120
// ComEnterUnit ( ArSolPBunk1 , ArPBunk1 ) ;
7518: LD_INT 15
7520: PPUSH
7521: LD_INT 2
7523: PPUSH
7524: CALL_OW 120
// ComEnterUnit ( ArSolPBunk2 , ArPBunk2 ) ;
7528: LD_INT 25
7530: PPUSH
7531: LD_INT 1
7533: PPUSH
7534: CALL_OW 120
// if Difficulty < 3 then
7538: LD_OWVAR 67
7542: PUSH
7543: LD_INT 3
7545: LESS
7546: IFFALSE 7558
// SetClass ( ArSolPBunk3 , CLASS_SOLDIER ) ;
7548: LD_INT 33
7550: PPUSH
7551: LD_INT 1
7553: PPUSH
7554: CALL_OW 336
// if Difficulty > 1 then
7558: LD_OWVAR 67
7562: PUSH
7563: LD_INT 1
7565: GREATER
7566: IFFALSE 7588
// begin ComEnterUnit ( ArObrM1 , ArObr1 ) ;
7568: LD_INT 47
7570: PPUSH
7571: LD_INT 45
7573: PPUSH
7574: CALL_OW 120
// ComEnterUnit ( ArObrM2 , ArObr2 ) ;
7578: LD_INT 48
7580: PPUSH
7581: LD_INT 46
7583: PPUSH
7584: CALL_OW 120
// end ; ComEnterUnit ( ArSolPBunk3 , ArPBunk3 ) ;
7588: LD_INT 33
7590: PPUSH
7591: LD_INT 32
7593: PPUSH
7594: CALL_OW 120
// ComEnterUnit ( ArSolRadar , ArRadar ) ;
7598: LD_INT 38
7600: PPUSH
7601: LD_INT 37
7603: PPUSH
7604: CALL_OW 120
// ComEnterUnit ( ArSolBunk1 , ArBunk1 ) ;
7608: LD_INT 39
7610: PPUSH
7611: LD_INT 36
7613: PPUSH
7614: CALL_OW 120
// ComEnterUnit ( ArSolBunk4 , ArBunk4 ) ;
7618: LD_INT 28
7620: PPUSH
7621: LD_INT 29
7623: PPUSH
7624: CALL_OW 120
// ComEnterUnit ( ArSolBunk6 , ArBunk6 ) ;
7628: LD_INT 31
7630: PPUSH
7631: LD_INT 41
7633: PPUSH
7634: CALL_OW 120
// ComEnterUnit ( ArSci1 , ArLab1 ) ;
7638: LD_INT 17
7640: PPUSH
7641: LD_INT 6
7643: PPUSH
7644: CALL_OW 120
// ComEnterUnit ( ArSci2 , ArLab2 ) ;
7648: LD_INT 18
7650: PPUSH
7651: LD_INT 24
7653: PPUSH
7654: CALL_OW 120
// end ;
7658: LD_VAR 0 1
7662: RET
// function kontrola_zniceno ; var Jednotky ; begin
7663: LD_INT 0
7665: PPUSH
7666: PPUSH
// if not Zniceno then
7667: LD_LOC 5
7671: NOT
7672: IFFALSE 7731
// begin Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] ] ) ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 22
7681: PUSH
7682: LD_EXP 4
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 50
7693: PUSH
7694: EMPTY
7695: LIST
7696: PUSH
7697: LD_INT 52
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: ST_TO_ADDR
// if not Jednotky then
7713: LD_VAR 0 2
7717: NOT
7718: IFFALSE 7731
// begin Zniceno = true ;
7720: LD_ADDR_LOC 5
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// disable ( 43 ) ;
7728: LD_INT 43
7730: DISABLE_MARKED
// end ; end ; end ;
7731: LD_VAR 0 1
7735: RET
// function vyber_zbran ; var P ; begin
7736: LD_INT 0
7738: PPUSH
7739: PPUSH
// P = Rand ( 1 , 100 ) ;
7740: LD_ADDR_VAR 0 2
7744: PUSH
7745: LD_INT 1
7747: PPUSH
7748: LD_INT 100
7750: PPUSH
7751: CALL_OW 12
7755: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
7756: LD_VAR 0 2
7760: PUSH
7761: LD_LOC 13
7765: PUSH
7766: LD_INT 1
7768: ARRAY
7769: LESS
7770: IFFALSE 7782
// Result = AR_FLAME_THROWER else
7772: LD_ADDR_VAR 0 1
7776: PUSH
7777: LD_INT 26
7779: ST_TO_ADDR
7780: GO 7842
// if P < PstZbrane [ 2 ] then
7782: LD_VAR 0 2
7786: PUSH
7787: LD_LOC 13
7791: PUSH
7792: LD_INT 2
7794: ARRAY
7795: LESS
7796: IFFALSE 7808
// Result = AR_GUN else
7798: LD_ADDR_VAR 0 1
7802: PUSH
7803: LD_INT 27
7805: ST_TO_ADDR
7806: GO 7842
// if P < PstZbrane [ 3 ] then
7808: LD_VAR 0 2
7812: PUSH
7813: LD_LOC 13
7817: PUSH
7818: LD_INT 3
7820: ARRAY
7821: LESS
7822: IFFALSE 7834
// Result = AR_DOUBLE_MACHINE_GUN else
7824: LD_ADDR_VAR 0 1
7828: PUSH
7829: LD_INT 24
7831: ST_TO_ADDR
7832: GO 7842
// Result = AR_ROCKET_LAUNCHER ;
7834: LD_ADDR_VAR 0 1
7838: PUSH
7839: LD_INT 28
7841: ST_TO_ADDR
// end ;
7842: LD_VAR 0 1
7846: RET
// function vyber_ovladani ; begin
7847: LD_INT 0
7849: PPUSH
// Result = CONTROL_MANUAL ;
7850: LD_ADDR_VAR 0 1
7854: PUSH
7855: LD_INT 1
7857: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
7858: LD_LOC 25
7862: NOT
7863: PUSH
7864: LD_LOC 25
7868: PPUSH
7869: CALL_OW 302
7873: NOT
7874: OR
7875: IFFALSE 7879
// exit ;
7877: GO 7927
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
7879: LD_INT 42
7881: NOT
7882: PUSH
7883: LD_INT 42
7885: PPUSH
7886: CALL_OW 302
7890: NOT
7891: OR
7892: IFFALSE 7896
// exit ;
7894: GO 7927
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
7896: LD_INT 42
7898: PPUSH
7899: CALL_OW 432
7903: PUSH
7904: LD_INT 42
7906: PPUSH
7907: LD_INT 3
7909: PPUSH
7910: CALL_OW 259
7914: GREATEREQUAL
7915: IFFALSE 7919
// exit ;
7917: GO 7927
// Result = CONTROL_REMOTE ;
7919: LD_ADDR_VAR 0 1
7923: PUSH
7924: LD_INT 2
7926: ST_TO_ADDR
// end ;
7927: LD_VAR 0 1
7931: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
7932: LD_INT 0
7934: PPUSH
7935: PPUSH
7936: PPUSH
7937: PPUSH
7938: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
7939: LD_INT 4
7941: PPUSH
7942: CALL_OW 302
7946: NOT
7947: PUSH
7948: LD_INT 4
7950: PPUSH
7951: CALL_OW 314
7955: OR
7956: IFFALSE 7960
// exit ;
7958: GO 8272
// if GetSide ( ArFact ) <> side_Ar then
7960: LD_INT 4
7962: PPUSH
7963: CALL_OW 255
7967: PUSH
7968: LD_EXP 4
7972: NONEQUAL
7973: IFFALSE 7977
// exit ;
7975: GO 8272
// if not UnitsInside ( ArFact ) then
7977: LD_INT 4
7979: PPUSH
7980: CALL_OW 313
7984: NOT
7985: IFFALSE 7989
// exit ;
7987: GO 8272
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
7989: LD_INT 15
7991: PPUSH
7992: LD_EXP 4
7996: PPUSH
7997: CALL_OW 321
8001: PUSH
8002: LD_INT 2
8004: EQUAL
8005: PUSH
8006: LD_LOC 25
8010: NOT
8011: AND
8012: PUSH
8013: LD_LOC 27
8017: NOT
8018: AND
8019: PUSH
8020: LD_INT 75
8022: PPUSH
8023: CALL_OW 13
8027: AND
8028: IFFALSE 8056
// begin Chassis = AR_MEDIUM_TRIKE ;
8030: LD_ADDR_VAR 0 3
8034: PUSH
8035: LD_INT 13
8037: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
8038: LD_ADDR_VAR 0 4
8042: PUSH
8043: LD_INT 31
8045: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
8046: LD_ADDR_VAR 0 5
8050: PUSH
8051: LD_INT 1
8053: ST_TO_ADDR
// end else
8054: GO 8103
// begin if Prob ( 50 ) then
8056: LD_INT 50
8058: PPUSH
8059: CALL_OW 13
8063: IFFALSE 8075
// Chassis = AR_MEDIUM_TRIKE else
8065: LD_ADDR_VAR 0 3
8069: PUSH
8070: LD_INT 13
8072: ST_TO_ADDR
8073: GO 8083
// Chassis = AR_HALF_TRACKED ;
8075: LD_ADDR_VAR 0 3
8079: PUSH
8080: LD_INT 14
8082: ST_TO_ADDR
// Weapon = vyber_zbran ;
8083: LD_ADDR_VAR 0 4
8087: PUSH
8088: CALL 7736 0 0
8092: ST_TO_ADDR
// Control = vyber_ovladani ;
8093: LD_ADDR_VAR 0 5
8097: PUSH
8098: CALL 7847 0 0
8102: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) then
8103: LD_INT 4
8105: PPUSH
8106: LD_VAR 0 3
8110: PPUSH
8111: LD_INT 1
8113: PPUSH
8114: LD_VAR 0 5
8118: PPUSH
8119: LD_VAR 0 4
8123: PPUSH
8124: CALL_OW 448
8128: NOT
8129: IFFALSE 8173
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_COMBUSTION , Control , AR_LIGHT_GUN ) then
8131: LD_INT 4
8133: PPUSH
8134: LD_INT 12
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_VAR 0 5
8144: PPUSH
8145: LD_INT 23
8147: PPUSH
8148: CALL_OW 448
8152: NOT
8153: IFFALSE 8157
// exit ;
8155: GO 8272
// Chassis = AR_LIGHT_TRIKE ;
8157: LD_ADDR_VAR 0 3
8161: PUSH
8162: LD_INT 12
8164: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
8165: LD_ADDR_VAR 0 4
8169: PUSH
8170: LD_INT 23
8172: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
8173: LD_ADDR_VAR 0 2
8177: PUSH
8178: LD_INT 4
8180: PPUSH
8181: CALL_OW 274
8185: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
8186: LD_VAR 0 2
8190: PPUSH
8191: LD_INT 1
8193: PPUSH
8194: CALL_OW 275
8198: PUSH
8199: LD_INT 120
8201: LESS
8202: IFFALSE 8206
// exit ;
8204: GO 8272
// if GetResourceType ( Base , MAT_OIL ) < 50 then
8206: LD_VAR 0 2
8210: PPUSH
8211: LD_INT 2
8213: PPUSH
8214: CALL_OW 275
8218: PUSH
8219: LD_INT 50
8221: LESS
8222: IFFALSE 8226
// exit ;
8224: GO 8272
// AddComConstruct ( ArFact , Chassis , ENGINE_COMBUSTION , Control , Weapon ) ;
8226: LD_INT 4
8228: PPUSH
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: LD_VAR 0 5
8241: PPUSH
8242: LD_VAR 0 4
8246: PPUSH
8247: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
8251: LD_VAR 0 4
8255: PUSH
8256: LD_INT 31
8258: EQUAL
8259: IFFALSE 8272
// begin DelamDalkare = true ;
8261: LD_ADDR_LOC 27
8265: PUSH
8266: LD_INT 1
8268: ST_TO_ADDR
// enable ( 47 ) ;
8269: LD_INT 47
8271: ENABLE_MARKED
// end ; end ;
8272: LD_VAR 0 1
8276: RET
// every 5 5$1 marked 47 do
8277: GO 8279
8279: DISABLE
// begin if not ArDalkar then
8280: LD_LOC 25
8284: NOT
8285: IFFALSE 8295
// DelamDalkare = false ;
8287: LD_ADDR_LOC 27
8291: PUSH
8292: LD_INT 0
8294: ST_TO_ADDR
// end ;
8295: END
// function zacni_vynalezat ; begin
8296: LD_INT 0
8298: PPUSH
// AddComResearch ( ArLab1 , TECH_GUN ) ;
8299: LD_INT 6
8301: PPUSH
8302: LD_INT 39
8304: PPUSH
8305: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_FLAME ) ;
8309: LD_INT 6
8311: PPUSH
8312: LD_INT 70
8314: PPUSH
8315: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_ROCKET ) ;
8319: LD_INT 6
8321: PPUSH
8322: LD_INT 40
8324: PPUSH
8325: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_GATLING ) ;
8329: LD_INT 6
8331: PPUSH
8332: LD_INT 69
8334: PPUSH
8335: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_STIMDRUGS ) ;
8339: LD_INT 6
8341: PPUSH
8342: LD_INT 5
8344: PPUSH
8345: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_EXPLOS ) ;
8349: LD_INT 6
8351: PPUSH
8352: LD_INT 42
8354: PPUSH
8355: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_SELFDEST ) ;
8359: LD_INT 6
8361: PPUSH
8362: LD_INT 43
8364: PPUSH
8365: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP1 ) ;
8369: LD_INT 6
8371: PPUSH
8372: LD_INT 51
8374: PPUSH
8375: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_WEAP2 ) ;
8379: LD_INT 6
8381: PPUSH
8382: LD_INT 52
8384: PPUSH
8385: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8389: LD_INT 6
8391: PPUSH
8392: LD_INT 67
8394: PPUSH
8395: CALL_OW 184
// AddComResearch ( ArLab1 , TECH_BIO2 ) ;
8399: LD_INT 6
8401: PPUSH
8402: LD_INT 67
8404: PPUSH
8405: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_RADAR ) ;
8409: LD_INT 24
8411: PPUSH
8412: LD_INT 6
8414: PPUSH
8415: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_REMCONT ) ;
8419: LD_INT 24
8421: PPUSH
8422: LD_INT 15
8424: PPUSH
8425: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_MATDET ) ;
8429: LD_INT 24
8431: PPUSH
8432: LD_INT 7
8434: PPUSH
8435: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH1 ) ;
8439: LD_INT 24
8441: PPUSH
8442: LD_INT 48
8444: PPUSH
8445: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_TECH2 ) ;
8449: LD_INT 24
8451: PPUSH
8452: LD_INT 49
8454: PPUSH
8455: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_SIBDET ) ;
8459: LD_INT 24
8461: PPUSH
8462: LD_INT 20
8464: PPUSH
8465: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO1 ) ;
8469: LD_INT 24
8471: PPUSH
8472: LD_INT 60
8474: PPUSH
8475: CALL_OW 184
// AddComResearch ( ArLab2 , TECH_OPTO2 ) ;
8479: LD_INT 24
8481: PPUSH
8482: LD_INT 61
8484: PPUSH
8485: CALL_OW 184
// end ;
8489: LD_VAR 0 1
8493: RET
// function zacni_utok ; begin
8494: LD_INT 0
8496: PPUSH
// ProbihaUtok = true ;
8497: LD_ADDR_LOC 14
8501: PUSH
8502: LD_INT 1
8504: ST_TO_ADDR
// MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8505: LD_ADDR_LOC 21
8509: PUSH
8510: LD_INT 10
8512: PPUSH
8513: LD_LOC 19
8517: PPUSH
8518: LD_LOC 9
8522: PPUSH
8523: LD_INT 7
8525: PUSH
8526: LD_INT 18
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: PUSH
8533: LD_INT 8
8535: PUSH
8536: LD_INT 18
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PUSH
8543: LD_INT 5
8545: PUSH
8546: LD_INT 10
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: PUSH
8553: LD_INT 6
8555: PUSH
8556: LD_INT 10
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: EMPTY
8564: LIST
8565: LIST
8566: LIST
8567: LIST
8568: PPUSH
8569: CALL_OW 402
8573: ST_TO_ADDR
// end ;
8574: LD_VAR 0 1
8578: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
8579: LD_INT 0
8581: PPUSH
8582: PPUSH
8583: PPUSH
8584: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_EXP 50
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
8601: LD_ADDR_VAR 0 3
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 100
8611: PPUSH
8612: CALL_OW 12
8616: ST_TO_ADDR
// if ( I < 25 ) then
8617: LD_VAR 0 3
8621: PUSH
8622: LD_INT 25
8624: LESS
8625: IFFALSE 8643
// KolikChci = KolikChci - 1 else
8627: LD_ADDR_VAR 0 2
8631: PUSH
8632: LD_VAR 0 2
8636: PUSH
8637: LD_INT 1
8639: MINUS
8640: ST_TO_ADDR
8641: GO 8677
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
8643: LD_VAR 0 3
8647: PUSH
8648: LD_INT 75
8650: GREATER
8651: PUSH
8652: LD_LOC 15
8656: PUSH
8657: LD_INT 1
8659: GREATER
8660: AND
8661: IFFALSE 8677
// KolikChci = KolikChci + 1 ;
8663: LD_ADDR_VAR 0 2
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: LD_INT 1
8675: PLUS
8676: ST_TO_ADDR
// Riditelne = [ ] ;
8677: LD_ADDR_VAR 0 4
8681: PUSH
8682: EMPTY
8683: ST_TO_ADDR
// for I in Autaky diff Patrola do
8684: LD_ADDR_VAR 0 3
8688: PUSH
8689: LD_LOC 6
8693: PUSH
8694: LD_LOC 16
8698: DIFF
8699: PUSH
8700: FOR_IN
8701: IFFALSE 8787
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
8703: LD_VAR 0 3
8707: PPUSH
8708: CALL_OW 263
8712: PUSH
8713: LD_INT 1
8715: EQUAL
8716: PUSH
8717: LD_VAR 0 3
8721: PPUSH
8722: CALL_OW 311
8726: NOT
8727: AND
8728: IFFALSE 8732
// continue ;
8730: GO 8700
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
8732: LD_VAR 0 3
8736: PPUSH
8737: CALL_OW 264
8741: PUSH
8742: LD_INT 31
8744: EQUAL
8745: IFFALSE 8749
// continue ;
8747: GO 8700
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
8749: LD_VAR 0 3
8753: PPUSH
8754: CALL_OW 256
8758: PUSH
8759: LD_INT 1000
8761: LESS
8762: IFFALSE 8766
// continue ;
8764: GO 8700
// Riditelne = Riditelne union [ I ] ;
8766: LD_ADDR_VAR 0 4
8770: PUSH
8771: LD_VAR 0 4
8775: PUSH
8776: LD_VAR 0 3
8780: PUSH
8781: EMPTY
8782: LIST
8783: UNION
8784: ST_TO_ADDR
// end ;
8785: GO 8700
8787: POP
8788: POP
// if Riditelne >= KolikChci then
8789: LD_VAR 0 4
8793: PUSH
8794: LD_VAR 0 2
8798: GREATEREQUAL
8799: IFFALSE 8854
// begin Result = [ ] ;
8801: LD_ADDR_VAR 0 1
8805: PUSH
8806: EMPTY
8807: ST_TO_ADDR
// for I = 1 to KolikChci do
8808: LD_ADDR_VAR 0 3
8812: PUSH
8813: DOUBLE
8814: LD_INT 1
8816: DEC
8817: ST_TO_ADDR
8818: LD_VAR 0 2
8822: PUSH
8823: FOR_TO
8824: IFFALSE 8850
// Result = Result union Riditelne [ I ] ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PUSH
8836: LD_VAR 0 4
8840: PUSH
8841: LD_VAR 0 3
8845: ARRAY
8846: UNION
8847: ST_TO_ADDR
8848: GO 8823
8850: POP
8851: POP
// end else
8852: GO 8861
// Result = [ ] ;
8854: LD_ADDR_VAR 0 1
8858: PUSH
8859: EMPTY
8860: ST_TO_ADDR
// end ;
8861: LD_VAR 0 1
8865: RET
// function vrat_utok ; var I ; begin
8866: LD_INT 0
8868: PPUSH
8869: PPUSH
// ProbihaUtok = false ;
8870: LD_ADDR_LOC 14
8874: PUSH
8875: LD_INT 0
8877: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
8878: LD_ADDR_LOC 15
8882: PUSH
8883: LD_LOC 15
8887: PUSH
8888: LD_INT 1
8890: PLUS
8891: ST_TO_ADDR
// MakroUtok = 0 ;
8892: LD_ADDR_LOC 21
8896: PUSH
8897: LD_INT 0
8899: ST_TO_ADDR
// AddComMoveUnit ( Utok_Auta , ArDepot ) ;
8900: LD_LOC 9
8904: PPUSH
8905: LD_INT 3
8907: PPUSH
8908: CALL_OW 172
// AddComMoveToArea ( Utok_Auta , AraboveParkoviste ) ;
8912: LD_LOC 9
8916: PPUSH
8917: LD_INT 18
8919: PPUSH
8920: CALL_OW 173
// end ;
8924: LD_VAR 0 1
8928: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
8929: LD_INT 0
8931: PPUSH
// vrat_utok ;
8932: CALL 8866 0 0
// end ;
8936: LD_VAR 0 3
8940: RET
// function oprava_utok ; var JsouOK , JsouTam , Auto , Task , Budova ; begin
8941: LD_INT 0
8943: PPUSH
8944: PPUSH
8945: PPUSH
8946: PPUSH
8947: PPUSH
8948: PPUSH
// JsouOK = false ;
8949: LD_ADDR_VAR 0 2
8953: PUSH
8954: LD_INT 0
8956: ST_TO_ADDR
// JsouTam = true ;
8957: LD_ADDR_VAR 0 3
8961: PUSH
8962: LD_INT 1
8964: ST_TO_ADDR
// Task = false ;
8965: LD_ADDR_VAR 0 5
8969: PUSH
8970: LD_INT 0
8972: ST_TO_ADDR
// for Auto in Utok_Auta do
8973: LD_ADDR_VAR 0 4
8977: PUSH
8978: LD_LOC 9
8982: PUSH
8983: FOR_IN
8984: IFFALSE 9049
// begin if IsOK ( Auto ) then
8986: LD_VAR 0 4
8990: PPUSH
8991: CALL_OW 302
8995: IFFALSE 9047
// begin JsouOK = true ;
8997: LD_ADDR_VAR 0 2
9001: PUSH
9002: LD_INT 1
9004: ST_TO_ADDR
// if not IsInArea ( Auto , ArabskaBaze ) then
9005: LD_VAR 0 4
9009: PPUSH
9010: LD_INT 14
9012: PPUSH
9013: CALL_OW 308
9017: NOT
9018: IFFALSE 9028
// JsouTam = false ;
9020: LD_ADDR_VAR 0 3
9024: PUSH
9025: LD_INT 0
9027: ST_TO_ADDR
// if HasTask ( Auto ) then
9028: LD_VAR 0 4
9032: PPUSH
9033: CALL_OW 314
9037: IFFALSE 9047
// Task = true ;
9039: LD_ADDR_VAR 0 5
9043: PUSH
9044: LD_INT 1
9046: ST_TO_ADDR
// end ; end ;
9047: GO 8983
9049: POP
9050: POP
// if not Utok_Auta or not JsouOK then
9051: LD_LOC 9
9055: NOT
9056: PUSH
9057: LD_VAR 0 2
9061: NOT
9062: OR
9063: IFFALSE 9075
// begin Result = true ;
9065: LD_ADDR_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// exit ;
9073: GO 9220
// end ; if ( not JsouTam ) or Task then
9075: LD_VAR 0 3
9079: NOT
9080: PUSH
9081: LD_VAR 0 5
9085: OR
9086: IFFALSE 9098
// begin Result = false ;
9088: LD_ADDR_VAR 0 1
9092: PUSH
9093: LD_INT 0
9095: ST_TO_ADDR
// exit ;
9096: GO 9220
// end ; Result = true ;
9098: LD_ADDR_VAR 0 1
9102: PUSH
9103: LD_INT 1
9105: ST_TO_ADDR
// if not IsOK ( ArMech ) then
9106: LD_INT 21
9108: PPUSH
9109: CALL_OW 302
9113: NOT
9114: IFFALSE 9118
// exit ;
9116: GO 9220
// Budova = IsInUnit ( ArMech ) ;
9118: LD_ADDR_VAR 0 6
9122: PUSH
9123: LD_INT 21
9125: PPUSH
9126: CALL_OW 310
9130: ST_TO_ADDR
// if ( Budova <> ArFact ) and ( Budova <> 0 ) then
9131: LD_VAR 0 6
9135: PUSH
9136: LD_INT 4
9138: NONEQUAL
9139: PUSH
9140: LD_VAR 0 6
9144: PUSH
9145: LD_INT 0
9147: NONEQUAL
9148: AND
9149: IFFALSE 9153
// exit ;
9151: GO 9220
// ComExitBuilding ( ArMech ) ;
9153: LD_INT 21
9155: PPUSH
9156: CALL_OW 122
// Wait ( 0 0$1.3 ) ;
9160: LD_INT 46
9162: PPUSH
9163: CALL_OW 67
// for Auto in Utok_Auta do
9167: LD_ADDR_VAR 0 4
9171: PUSH
9172: LD_LOC 9
9176: PUSH
9177: FOR_IN
9178: IFFALSE 9208
// begin if IsInArea ( Auto , ArabskaBaze ) then
9180: LD_VAR 0 4
9184: PPUSH
9185: LD_INT 14
9187: PPUSH
9188: CALL_OW 308
9192: IFFALSE 9206
// AddComRepairVehicle ( ArMech , Auto ) ;
9194: LD_INT 21
9196: PPUSH
9197: LD_VAR 0 4
9201: PPUSH
9202: CALL_OW 189
// end ;
9206: GO 9177
9208: POP
9209: POP
// AddComEnterUnit ( ArMech , ArFact ) ;
9210: LD_INT 21
9212: PPUSH
9213: LD_INT 4
9215: PPUSH
9216: CALL_OW 180
// end ;
9220: LD_VAR 0 1
9224: RET
// function zjisti_cas_utoku ; begin
9225: LD_INT 0
9227: PPUSH
// if CasyUtoku then
9228: LD_LOC 11
9232: IFFALSE 9278
// begin Result = CasyUtoku [ 1 ] ;
9234: LD_ADDR_VAR 0 1
9238: PUSH
9239: LD_LOC 11
9243: PUSH
9244: LD_INT 1
9246: ARRAY
9247: ST_TO_ADDR
// if CasyUtoku > 1 then
9248: LD_LOC 11
9252: PUSH
9253: LD_INT 1
9255: GREATER
9256: IFFALSE 9276
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
9258: LD_ADDR_LOC 11
9262: PUSH
9263: LD_LOC 11
9267: PPUSH
9268: LD_INT 1
9270: PPUSH
9271: CALL_OW 3
9275: ST_TO_ADDR
// end else
9276: GO 9286
// Result = 5 ;
9278: LD_ADDR_VAR 0 1
9282: PUSH
9283: LD_INT 5
9285: ST_TO_ADDR
// end ;
9286: LD_VAR 0 1
9290: RET
// function utoceni_splneny_predpoklady ; begin
9291: LD_INT 0
9293: PPUSH
// Result = VidelRusa or ( Minuty > 15 ) ;
9294: LD_ADDR_VAR 0 1
9298: PUSH
9299: LD_LOC 12
9303: PUSH
9304: LD_EXP 30
9308: PUSH
9309: LD_INT 15
9311: GREATER
9312: OR
9313: ST_TO_ADDR
// if Prob ( 25 ) then
9314: LD_INT 25
9316: PPUSH
9317: CALL_OW 13
9321: IFFALSE 9331
// Result = false ;
9323: LD_ADDR_VAR 0 1
9327: PUSH
9328: LD_INT 0
9330: ST_TO_ADDR
// end ;
9331: LD_VAR 0 1
9335: RET
// function casovac_utok ; begin
9336: LD_INT 0
9338: PPUSH
// if ProbihaUtok then
9339: LD_LOC 14
9343: IFFALSE 9347
// exit ;
9345: GO 9446
// if Utok_ZbyvaMinut = - 1 then
9347: LD_LOC 10
9351: PUSH
9352: LD_INT 1
9354: NEG
9355: EQUAL
9356: IFFALSE 9368
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9358: LD_ADDR_LOC 10
9362: PUSH
9363: CALL 9225 0 0
9367: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
9368: LD_LOC 10
9372: PUSH
9373: LD_INT 0
9375: GREATER
9376: IFFALSE 9392
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
9378: LD_ADDR_LOC 10
9382: PUSH
9383: LD_LOC 10
9387: PUSH
9388: LD_INT 1
9390: MINUS
9391: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
9392: CALL 9291 0 0
9396: NOT
9397: IFFALSE 9401
// exit ;
9399: GO 9446
// if Utok_ZbyvaMinut > 0 then
9401: LD_LOC 10
9405: PUSH
9406: LD_INT 0
9408: GREATER
9409: IFFALSE 9413
// exit ;
9411: GO 9446
// Utok_Auta = zjisti_auta_na_utok ;
9413: LD_ADDR_LOC 9
9417: PUSH
9418: CALL 8579 0 0
9422: ST_TO_ADDR
// if not Utok_Auta then
9423: LD_LOC 9
9427: NOT
9428: IFFALSE 9432
// exit ;
9430: GO 9446
// zacni_utok ;
9432: CALL 8494 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
9436: LD_ADDR_LOC 10
9440: PUSH
9441: CALL 9225 0 0
9445: ST_TO_ADDR
// end ;
9446: LD_VAR 0 1
9450: RET
// every 0 0$6 do
9451: GO 9453
9453: DISABLE
// begin zacni_vynalezat ;
9454: CALL 8296 0 0
// patrola_kolecko ;
9458: CALL 10638 0 0
// end ;
9462: END
// every 0 0$19 do
9463: GO 9465
9465: DISABLE
// begin kontrola_vyroby ;
9466: CALL 7932 0 0
// enable ;
9470: ENABLE
// end ;
9471: END
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , NovyRidic ; begin
9472: LD_INT 0
9474: PPUSH
9475: PPUSH
9476: PPUSH
// if GetSide ( Veh ) = side_Ar then
9477: LD_VAR 0 1
9481: PPUSH
9482: CALL_OW 255
9486: PUSH
9487: LD_EXP 4
9491: EQUAL
9492: IFFALSE 9770
// begin NovyRidic = 0 ;
9494: LD_ADDR_VAR 0 5
9498: PUSH
9499: LD_INT 0
9501: ST_TO_ADDR
// Autaky = Autaky union [ Veh ] ;
9502: LD_ADDR_LOC 6
9506: PUSH
9507: LD_LOC 6
9511: PUSH
9512: LD_VAR 0 1
9516: PUSH
9517: EMPTY
9518: LIST
9519: UNION
9520: ST_TO_ADDR
// if ( GetWeapon ( Veh ) = AR_CONTROL_TOWER ) then
9521: LD_VAR 0 1
9525: PPUSH
9526: CALL_OW 264
9530: PUSH
9531: LD_INT 31
9533: EQUAL
9534: IFFALSE 9562
// begin ArDalkar = Veh ;
9536: LD_ADDR_LOC 25
9540: PUSH
9541: LD_VAR 0 1
9545: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 42
9553: ST_TO_ADDR
// DelamDalkare = false ;
9554: LD_ADDR_LOC 27
9558: PUSH
9559: LD_INT 0
9561: ST_TO_ADDR
// end ; if ( GetControl ( Veh ) = CONTROL_MANUAL ) and VolnyLidi then
9562: LD_VAR 0 1
9566: PPUSH
9567: CALL_OW 263
9571: PUSH
9572: LD_INT 1
9574: EQUAL
9575: PUSH
9576: LD_LOC 8
9580: AND
9581: IFFALSE 9705
// begin Ridic = IsDrivenBy ( Veh ) ;
9583: LD_ADDR_VAR 0 4
9587: PUSH
9588: LD_VAR 0 1
9592: PPUSH
9593: CALL_OW 311
9597: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9598: LD_INT 105
9600: PPUSH
9601: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
9605: LD_VAR 0 4
9609: PPUSH
9610: CALL_OW 121
// Wait ( 0 0$1 ) ;
9614: LD_INT 35
9616: PPUSH
9617: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
9621: LD_VAR 0 1
9625: PPUSH
9626: CALL_OW 311
9630: PUSH
9631: LD_VAR 0 4
9635: EQUAL
9636: IFFALSE 9647
// Wait ( 0 0$1 ) ;
9638: LD_INT 35
9640: PPUSH
9641: CALL_OW 67
9645: GO 9621
// AddComEnterUnit ( Ridic , Fact ) ;
9647: LD_VAR 0 4
9651: PPUSH
9652: LD_VAR 0 2
9656: PPUSH
9657: CALL_OW 180
// if NovyRidic then
9661: LD_VAR 0 5
9665: IFFALSE 9681
// ComEnterUnit ( NovyRidic , Veh ) ;
9667: LD_VAR 0 5
9671: PPUSH
9672: LD_VAR 0 1
9676: PPUSH
9677: CALL_OW 120
// Wait ( 0 0$3 ) ;
9681: LD_INT 105
9683: PPUSH
9684: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9688: LD_LOC 23
9692: PPUSH
9693: LD_VAR 0 1
9697: PUSH
9698: EMPTY
9699: LIST
9700: PPUSH
9701: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
9705: LD_VAR 0 1
9709: PPUSH
9710: CALL_OW 263
9714: PUSH
9715: LD_INT 2
9717: EQUAL
9718: IFFALSE 9770
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
9720: LD_VAR 0 1
9724: PPUSH
9725: LD_INT 42
9727: PPUSH
9728: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
9732: LD_ADDR_LOC 26
9736: PUSH
9737: LD_LOC 26
9741: PUSH
9742: LD_INT 1
9744: PLUS
9745: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
9746: LD_INT 105
9748: PPUSH
9749: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
9753: LD_LOC 23
9757: PPUSH
9758: LD_VAR 0 1
9762: PUSH
9763: EMPTY
9764: LIST
9765: PPUSH
9766: CALL_OW 390
// end ; end ; end ;
9770: LD_VAR 0 3
9774: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
9775: LD_INT 0
9777: PPUSH
9778: PPUSH
9779: PPUSH
// if Veh = ArDalkar then
9780: LD_VAR 0 1
9784: PUSH
9785: LD_LOC 25
9789: EQUAL
9790: IFFALSE 9825
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
9792: LD_INT 42
9794: PPUSH
9795: CALL_OW 302
9799: PUSH
9800: LD_INT 42
9802: PPUSH
9803: CALL_OW 310
9807: NOT
9808: AND
9809: IFFALSE 9825
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
9811: LD_INT 42
9813: PPUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: CALL_OW 120
// exit ;
9823: GO 9896
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
9825: LD_ADDR_VAR 0 3
9829: PUSH
9830: LD_LOC 8
9834: PPUSH
9835: LD_INT 56
9837: PUSH
9838: EMPTY
9839: LIST
9840: PUSH
9841: EMPTY
9842: LIST
9843: PPUSH
9844: CALL_OW 72
9848: ST_TO_ADDR
// for I in Lidi do
9849: LD_ADDR_VAR 0 4
9853: PUSH
9854: LD_VAR 0 3
9858: PUSH
9859: FOR_IN
9860: IFFALSE 9894
// if not HasTask ( I ) then
9862: LD_VAR 0 4
9866: PPUSH
9867: CALL_OW 314
9871: NOT
9872: IFFALSE 9892
// begin ComEnterUnit ( I , Veh ) ;
9874: LD_VAR 0 4
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 120
// exit ;
9888: POP
9889: POP
9890: GO 9896
// end ;
9892: GO 9859
9894: POP
9895: POP
// end ;
9896: LD_VAR 0 2
9900: RET
// function nastupuj_auta ; var Auta , I ; begin
9901: LD_INT 0
9903: PPUSH
9904: PPUSH
9905: PPUSH
// Auta = FilterUnitsInArea ( Obrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
9906: LD_ADDR_VAR 0 2
9910: PUSH
9911: LD_INT 37
9913: PPUSH
9914: LD_INT 21
9916: PUSH
9917: LD_INT 2
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 33
9926: PUSH
9927: LD_INT 1
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 58
9936: PUSH
9937: EMPTY
9938: LIST
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 70
9949: ST_TO_ADDR
// if not Auta then
9950: LD_VAR 0 2
9954: NOT
9955: IFFALSE 9959
// exit ;
9957: GO 9985
// for I in Auta do
9959: LD_ADDR_VAR 0 3
9963: PUSH
9964: LD_VAR 0 2
9968: PUSH
9969: FOR_IN
9970: IFFALSE 9983
// zarid_ridice ( I ) ;
9972: LD_VAR 0 3
9976: PPUSH
9977: CALL 9775 0 1
9981: GO 9969
9983: POP
9984: POP
// end ;
9985: LD_VAR 0 1
9989: RET
// every 0 0$17 do
9990: GO 9992
9992: DISABLE
// begin nastupuj_auta ;
9993: CALL 9901 0 0
// enable ;
9997: ENABLE
// end ;
9998: END
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
9999: LD_INT 0
10001: PPUSH
// if VehOld in Patrola then
10002: LD_VAR 0 2
10006: PUSH
10007: LD_LOC 16
10011: IN
10012: IFFALSE 10033
// Patrola = Patrola diff [ VehOld ] ;
10014: LD_ADDR_LOC 16
10018: PUSH
10019: LD_LOC 16
10023: PUSH
10024: LD_VAR 0 2
10028: PUSH
10029: EMPTY
10030: LIST
10031: DIFF
10032: ST_TO_ADDR
// if VehOld in Autaky then
10033: LD_VAR 0 2
10037: PUSH
10038: LD_LOC 6
10042: IN
10043: IFFALSE 10064
// Autaky = Autaky diff [ VehOld ] ;
10045: LD_ADDR_LOC 6
10049: PUSH
10050: LD_LOC 6
10054: PUSH
10055: LD_VAR 0 2
10059: PUSH
10060: EMPTY
10061: LIST
10062: DIFF
10063: ST_TO_ADDR
// if VehOld in Utok_Auta then
10064: LD_VAR 0 2
10068: PUSH
10069: LD_LOC 9
10073: IN
10074: IFFALSE 10095
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
10076: LD_ADDR_LOC 9
10080: PUSH
10081: LD_LOC 9
10085: PUSH
10086: LD_VAR 0 2
10090: PUSH
10091: EMPTY
10092: LIST
10093: DIFF
10094: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
10095: LD_VAR 0 1
10099: PPUSH
10100: CALL_OW 255
10104: PUSH
10105: LD_EXP 4
10109: EQUAL
10110: IFFALSE 10159
// begin Autaky = Autaky union [ VehNew ] ;
10112: LD_ADDR_LOC 6
10116: PUSH
10117: LD_LOC 6
10121: PUSH
10122: LD_VAR 0 1
10126: PUSH
10127: EMPTY
10128: LIST
10129: UNION
10130: ST_TO_ADDR
// AddMcUnits ( MakroObrana , VehNew ) ;
10131: LD_LOC 20
10135: PPUSH
10136: LD_VAR 0 1
10140: PPUSH
10141: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , VehNew ) ;
10145: LD_LOC 23
10149: PPUSH
10150: LD_VAR 0 1
10154: PPUSH
10155: CALL_OW 390
// end ; if GetSide ( VehOld ) = side_Ar then
10159: LD_VAR 0 2
10163: PPUSH
10164: CALL_OW 255
10168: PUSH
10169: LD_EXP 4
10173: EQUAL
10174: IFFALSE 10224
// begin RemoveMcUnits ( MakroObrana , VehOld ) ;
10176: LD_LOC 20
10180: PPUSH
10181: LD_VAR 0 2
10185: PPUSH
10186: CALL_OW 391
// RemoveMcUnits ( MakroPresunZakladna , VehOld ) ;
10190: LD_LOC 23
10194: PPUSH
10195: LD_VAR 0 2
10199: PPUSH
10200: CALL_OW 391
// if MakroUtok then
10204: LD_LOC 21
10208: IFFALSE 10224
// RemoveMcUnits ( MakroUtok , VehOld ) ;
10210: LD_LOC 21
10214: PPUSH
10215: LD_VAR 0 2
10219: PPUSH
10220: CALL_OW 391
// end ; kontrola_zniceno ;
10224: CALL 7663 0 0
// end ;
10228: LD_VAR 0 5
10232: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
10233: LD_INT 0
10235: PPUSH
// if Un in Patrola then
10236: LD_VAR 0 1
10240: PUSH
10241: LD_LOC 16
10245: IN
10246: IFFALSE 10267
// Patrola = Patrola diff [ Un ] ;
10248: LD_ADDR_LOC 16
10252: PUSH
10253: LD_LOC 16
10257: PUSH
10258: LD_VAR 0 1
10262: PUSH
10263: EMPTY
10264: LIST
10265: DIFF
10266: ST_TO_ADDR
// if Un in Autaky then
10267: LD_VAR 0 1
10271: PUSH
10272: LD_LOC 6
10276: IN
10277: IFFALSE 10298
// Autaky = Autaky diff [ Un ] ;
10279: LD_ADDR_LOC 6
10283: PUSH
10284: LD_LOC 6
10288: PUSH
10289: LD_VAR 0 1
10293: PUSH
10294: EMPTY
10295: LIST
10296: DIFF
10297: ST_TO_ADDR
// if Un in Utok_Auta then
10298: LD_VAR 0 1
10302: PUSH
10303: LD_LOC 9
10307: IN
10308: IFFALSE 10329
// Utok_Auta = Utok_Auta diff [ Un ] ;
10310: LD_ADDR_LOC 9
10314: PUSH
10315: LD_LOC 9
10319: PUSH
10320: LD_VAR 0 1
10324: PUSH
10325: EMPTY
10326: LIST
10327: DIFF
10328: ST_TO_ADDR
// if Un in VolnyLidi then
10329: LD_VAR 0 1
10333: PUSH
10334: LD_LOC 8
10338: IN
10339: IFFALSE 10360
// VolnyLidi = VolnyLidi diff [ Un ] ;
10341: LD_ADDR_LOC 8
10345: PUSH
10346: LD_LOC 8
10350: PUSH
10351: LD_VAR 0 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: DIFF
10359: ST_TO_ADDR
// kontrola_zniceno ;
10360: CALL 7663 0 0
// end ;
10364: LD_VAR 0 2
10368: RET
// export function arabi_UnitGoesToRed ( Un ) ; begin
10369: LD_INT 0
10371: PPUSH
// if ( Un = ArPBunk1 ) then
10372: LD_VAR 0 1
10376: PUSH
10377: LD_INT 2
10379: EQUAL
10380: IFFALSE 10411
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk1 ] ;
10382: LD_ADDR_LOC 8
10386: PUSH
10387: LD_LOC 8
10391: PUSH
10392: LD_INT 15
10394: PUSH
10395: EMPTY
10396: LIST
10397: UNION
10398: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk1 ) ;
10399: LD_LOC 22
10403: PPUSH
10404: LD_INT 15
10406: PPUSH
10407: CALL_OW 391
// end ; if ( Un = ArPBunk2 ) then
10411: LD_VAR 0 1
10415: PUSH
10416: LD_INT 1
10418: EQUAL
10419: IFFALSE 10450
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk2 ] ;
10421: LD_ADDR_LOC 8
10425: PUSH
10426: LD_LOC 8
10430: PUSH
10431: LD_INT 25
10433: PUSH
10434: EMPTY
10435: LIST
10436: UNION
10437: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk2 ) ;
10438: LD_LOC 22
10442: PPUSH
10443: LD_INT 25
10445: PPUSH
10446: CALL_OW 391
// end ; if ( Un = ArPBunk3 ) then
10450: LD_VAR 0 1
10454: PUSH
10455: LD_INT 32
10457: EQUAL
10458: IFFALSE 10489
// begin VolnyLidi = VolnyLidi union [ ArSolPBunk3 ] ;
10460: LD_ADDR_LOC 8
10464: PUSH
10465: LD_LOC 8
10469: PUSH
10470: LD_INT 33
10472: PUSH
10473: EMPTY
10474: LIST
10475: UNION
10476: ST_TO_ADDR
// RemoveMcUnits ( MakroBunkry , ArSolPBunk3 ) ;
10477: LD_LOC 22
10481: PPUSH
10482: LD_INT 33
10484: PPUSH
10485: CALL_OW 391
// end ; end ;
10489: LD_VAR 0 2
10493: RET
// export function arabi_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
10494: LD_INT 0
10496: PPUSH
// kontrola_zniceno ;
10497: CALL 7663 0 0
// end ;
10501: LD_VAR 0 4
10505: RET
// export function arabi_muzete_utocit ; begin
10506: LD_INT 0
10508: PPUSH
// enable ( 43 ) ;
10509: LD_INT 43
10511: ENABLE_MARKED
// end ;
10512: LD_VAR 0 1
10516: RET
// every 0 0$45 marked 43 do
10517: GO 10519
10519: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
10520: LD_INT 0
10522: PPUSH
10523: LD_INT 1050
10525: PPUSH
10526: CALL_OW 12
10530: PPUSH
10531: CALL_OW 67
// casovac_utok ;
10535: CALL 9336 0 0
// enable ;
10539: ENABLE
// end ;
10540: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
10541: LD_EXP 4
10545: PPUSH
10546: LD_EXP 2
10550: PPUSH
10551: CALL 20721 0 2
10555: IFFALSE 10572
10557: GO 10559
10559: DISABLE
// begin VidelRusa = true ;
10560: LD_ADDR_LOC 12
10564: PUSH
10565: LD_INT 1
10567: ST_TO_ADDR
// zrus_patrolu ;
10568: CALL 10573 0 0
// end ;
10572: END
// function zrus_patrolu ; begin
10573: LD_INT 0
10575: PPUSH
// ComAgressiveMove ( Patrola , 73 , 13 ) ;
10576: LD_LOC 16
10580: PPUSH
10581: LD_INT 73
10583: PPUSH
10584: LD_INT 13
10586: PPUSH
10587: CALL_OW 114
// AddComMoveUnit ( Patrola , ArDepot ) ;
10591: LD_LOC 16
10595: PPUSH
10596: LD_INT 3
10598: PPUSH
10599: CALL_OW 172
// AddComMoveToArea ( Patrola , AraboveParkoviste ) ;
10603: LD_LOC 16
10607: PPUSH
10608: LD_INT 18
10610: PPUSH
10611: CALL_OW 173
// Patrola = [ ] ;
10615: LD_ADDR_LOC 16
10619: PUSH
10620: EMPTY
10621: ST_TO_ADDR
// PatrolaZrusena = true ;
10622: LD_ADDR_LOC 17
10626: PUSH
10627: LD_INT 1
10629: ST_TO_ADDR
// disable ( 45 ) ;
10630: LD_INT 45
10632: DISABLE_MARKED
// end ;
10633: LD_VAR 0 1
10637: RET
// function patrola_kolecko ; begin
10638: LD_INT 0
10640: PPUSH
// ComMoveUnit ( Patrola , ArDepot ) ;
10641: LD_LOC 16
10645: PPUSH
10646: LD_INT 3
10648: PPUSH
10649: CALL_OW 112
// AddComMoveXY ( Patrola , 83 , 12 ) ;
10653: LD_LOC 16
10657: PPUSH
10658: LD_INT 83
10660: PPUSH
10661: LD_INT 12
10663: PPUSH
10664: CALL_OW 171
// AddComMoveXY ( Patrola , 68 , 13 ) ;
10668: LD_LOC 16
10672: PPUSH
10673: LD_INT 68
10675: PPUSH
10676: LD_INT 13
10678: PPUSH
10679: CALL_OW 171
// AddComMoveXY ( Patrola , 62 , 15 ) ;
10683: LD_LOC 16
10687: PPUSH
10688: LD_INT 62
10690: PPUSH
10691: LD_INT 15
10693: PPUSH
10694: CALL_OW 171
// AddComMoveXY ( Patrola , 54 , 15 ) ;
10698: LD_LOC 16
10702: PPUSH
10703: LD_INT 54
10705: PPUSH
10706: LD_INT 15
10708: PPUSH
10709: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 13 ) ;
10713: LD_LOC 16
10717: PPUSH
10718: LD_INT 46
10720: PPUSH
10721: LD_INT 13
10723: PPUSH
10724: CALL_OW 171
// AddComMoveXY ( Patrola , 36 , 13 ) ;
10728: LD_LOC 16
10732: PPUSH
10733: LD_INT 36
10735: PPUSH
10736: LD_INT 13
10738: PPUSH
10739: CALL_OW 171
// AddComMoveXY ( Patrola , 31 , 17 ) ;
10743: LD_LOC 16
10747: PPUSH
10748: LD_INT 31
10750: PPUSH
10751: LD_INT 17
10753: PPUSH
10754: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.7 ) ;
10758: LD_LOC 16
10762: PPUSH
10763: LD_INT 165
10765: PPUSH
10766: CALL_OW 202
// AddComMoveXY ( Patrola , 20 , 16 ) ;
10770: LD_LOC 16
10774: PPUSH
10775: LD_INT 20
10777: PPUSH
10778: LD_INT 16
10780: PPUSH
10781: CALL_OW 171
// AddComMoveXY ( Patrola , 4 , 3 ) ;
10785: LD_LOC 16
10789: PPUSH
10790: LD_INT 4
10792: PPUSH
10793: LD_INT 3
10795: PPUSH
10796: CALL_OW 171
// AddComWait ( Patrola , 0 0$4 ) ;
10800: LD_LOC 16
10804: PPUSH
10805: LD_INT 140
10807: PPUSH
10808: CALL_OW 202
// AddComMoveXY ( Patrola , 6 , 7 ) ;
10812: LD_LOC 16
10816: PPUSH
10817: LD_INT 6
10819: PPUSH
10820: LD_INT 7
10822: PPUSH
10823: CALL_OW 171
// AddComMoveXY ( Patrola , 20 , 17 ) ;
10827: LD_LOC 16
10831: PPUSH
10832: LD_INT 20
10834: PPUSH
10835: LD_INT 17
10837: PPUSH
10838: CALL_OW 171
// AddComMoveXY ( Patrola , 28 , 18 ) ;
10842: LD_LOC 16
10846: PPUSH
10847: LD_INT 28
10849: PPUSH
10850: LD_INT 18
10852: PPUSH
10853: CALL_OW 171
// AddComWait ( Patrola , 0 0$5.2 ) ;
10857: LD_LOC 16
10861: PPUSH
10862: LD_INT 182
10864: PPUSH
10865: CALL_OW 202
// if not VsevSaved then
10869: LD_EXP 8
10873: NOT
10874: IFFALSE 11194
// begin AddComMoveXY ( Patrola , 33 , 21 ) ;
10876: LD_LOC 16
10880: PPUSH
10881: LD_INT 33
10883: PPUSH
10884: LD_INT 21
10886: PPUSH
10887: CALL_OW 171
// AddComMoveXY ( Patrola , 37 , 34 ) ;
10891: LD_LOC 16
10895: PPUSH
10896: LD_INT 37
10898: PPUSH
10899: LD_INT 34
10901: PPUSH
10902: CALL_OW 171
// AddComMoveXY ( Patrola , 43 , 45 ) ;
10906: LD_LOC 16
10910: PPUSH
10911: LD_INT 43
10913: PPUSH
10914: LD_INT 45
10916: PPUSH
10917: CALL_OW 171
// AddComMoveXY ( Patrola , 55 , 59 ) ;
10921: LD_LOC 16
10925: PPUSH
10926: LD_INT 55
10928: PPUSH
10929: LD_INT 59
10931: PPUSH
10932: CALL_OW 171
// AddComMoveXY ( Patrola , 66 , 80 ) ;
10936: LD_LOC 16
10940: PPUSH
10941: LD_INT 66
10943: PPUSH
10944: LD_INT 80
10946: PPUSH
10947: CALL_OW 171
// AddComWait ( Patrola , 0 0$1.2 ) ;
10951: LD_LOC 16
10955: PPUSH
10956: LD_INT 42
10958: PPUSH
10959: CALL_OW 202
// AddComMoveXY ( Patrola , 73 , 95 ) ;
10963: LD_LOC 16
10967: PPUSH
10968: LD_INT 73
10970: PPUSH
10971: LD_INT 95
10973: PPUSH
10974: CALL_OW 171
// AddComMoveXY ( Patrola , 74 , 100 ) ;
10978: LD_LOC 16
10982: PPUSH
10983: LD_INT 74
10985: PPUSH
10986: LD_INT 100
10988: PPUSH
10989: CALL_OW 171
// AddComMoveXY ( Patrola , 82 , 116 ) ;
10993: LD_LOC 16
10997: PPUSH
10998: LD_INT 82
11000: PPUSH
11001: LD_INT 116
11003: PPUSH
11004: CALL_OW 171
// AddComMoveXY ( Patrola , 92 , 131 ) ;
11008: LD_LOC 16
11012: PPUSH
11013: LD_INT 92
11015: PPUSH
11016: LD_INT 131
11018: PPUSH
11019: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.4 ) ;
11023: LD_LOC 16
11027: PPUSH
11028: LD_INT 119
11030: PPUSH
11031: CALL_OW 202
// AddComMoveXY ( Patrola , 93 , 129 ) ;
11035: LD_LOC 16
11039: PPUSH
11040: LD_INT 93
11042: PPUSH
11043: LD_INT 129
11045: PPUSH
11046: CALL_OW 171
// AddComWait ( Patrola , 0 0$4.1 ) ;
11050: LD_LOC 16
11054: PPUSH
11055: LD_INT 143
11057: PPUSH
11058: CALL_OW 202
// AddComMoveXY ( Patrola , 87 , 119 ) ;
11062: LD_LOC 16
11066: PPUSH
11067: LD_INT 87
11069: PPUSH
11070: LD_INT 119
11072: PPUSH
11073: CALL_OW 171
// AddComMoveXY ( Patrola , 77 , 100 ) ;
11077: LD_LOC 16
11081: PPUSH
11082: LD_INT 77
11084: PPUSH
11085: LD_INT 100
11087: PPUSH
11088: CALL_OW 171
// AddComMoveXY ( Patrola , 73 , 91 ) ;
11092: LD_LOC 16
11096: PPUSH
11097: LD_INT 73
11099: PPUSH
11100: LD_INT 91
11102: PPUSH
11103: CALL_OW 171
// AddComMoveXY ( Patrola , 65 , 73 ) ;
11107: LD_LOC 16
11111: PPUSH
11112: LD_INT 65
11114: PPUSH
11115: LD_INT 73
11117: PPUSH
11118: CALL_OW 171
// AddComMoveXY ( Patrola , 56 , 58 ) ;
11122: LD_LOC 16
11126: PPUSH
11127: LD_INT 56
11129: PPUSH
11130: LD_INT 58
11132: PPUSH
11133: CALL_OW 171
// AddComMoveXY ( Patrola , 47 , 47 ) ;
11137: LD_LOC 16
11141: PPUSH
11142: LD_INT 47
11144: PPUSH
11145: LD_INT 47
11147: PPUSH
11148: CALL_OW 171
// AddComMoveXY ( Patrola , 40 , 36 ) ;
11152: LD_LOC 16
11156: PPUSH
11157: LD_INT 40
11159: PPUSH
11160: LD_INT 36
11162: PPUSH
11163: CALL_OW 171
// AddComMoveXY ( Patrola , 35 , 25 ) ;
11167: LD_LOC 16
11171: PPUSH
11172: LD_INT 35
11174: PPUSH
11175: LD_INT 25
11177: PPUSH
11178: CALL_OW 171
// AddComWait ( Patrola , 0 0$3.3 ) ;
11182: LD_LOC 16
11186: PPUSH
11187: LD_INT 115
11189: PPUSH
11190: CALL_OW 202
// end ; AddComMoveXY ( Patrola , 34 , 18 ) ;
11194: LD_LOC 16
11198: PPUSH
11199: LD_INT 34
11201: PPUSH
11202: LD_INT 18
11204: PPUSH
11205: CALL_OW 171
// AddComMoveXY ( Patrola , 38 , 14 ) ;
11209: LD_LOC 16
11213: PPUSH
11214: LD_INT 38
11216: PPUSH
11217: LD_INT 14
11219: PPUSH
11220: CALL_OW 171
// AddComMoveXY ( Patrola , 46 , 14 ) ;
11224: LD_LOC 16
11228: PPUSH
11229: LD_INT 46
11231: PPUSH
11232: LD_INT 14
11234: PPUSH
11235: CALL_OW 171
// AddComMoveXY ( Patrola , 51 , 16 ) ;
11239: LD_LOC 16
11243: PPUSH
11244: LD_INT 51
11246: PPUSH
11247: LD_INT 16
11249: PPUSH
11250: CALL_OW 171
// AddComMoveXY ( Patrola , 61 , 16 ) ;
11254: LD_LOC 16
11258: PPUSH
11259: LD_INT 61
11261: PPUSH
11262: LD_INT 16
11264: PPUSH
11265: CALL_OW 171
// AddComMoveXY ( Patrola , 75 , 14 ) ;
11269: LD_LOC 16
11273: PPUSH
11274: LD_INT 75
11276: PPUSH
11277: LD_INT 14
11279: PPUSH
11280: CALL_OW 171
// AddComMoveXY ( Patrola , 86 , 18 ) ;
11284: LD_LOC 16
11288: PPUSH
11289: LD_INT 86
11291: PPUSH
11292: LD_INT 18
11294: PPUSH
11295: CALL_OW 171
// AddComWait ( Patrola , 0 0$2.9 ) ;
11299: LD_LOC 16
11303: PPUSH
11304: LD_INT 101
11306: PPUSH
11307: CALL_OW 202
// AddComSailEvent ( Patrola , 101 ) ;
11311: LD_LOC 16
11315: PPUSH
11316: LD_INT 101
11318: PPUSH
11319: CALL_OW 224
// end ;
11323: LD_VAR 0 1
11327: RET
// export function event_Patrola ; begin
11328: LD_INT 0
11330: PPUSH
// if Patrola and not PatrolaZrusena then
11331: LD_LOC 16
11335: PUSH
11336: LD_LOC 17
11340: NOT
11341: AND
11342: IFFALSE 11348
// patrola_kolecko ;
11344: CALL 10638 0 0
// end ;
11348: LD_VAR 0 1
11352: RET
// every 0 0$27.1 marked 45 do var Kdo ;
11353: GO 11355
11355: DISABLE
11356: LD_INT 0
11358: PPUSH
// begin if not Patrola then
11359: LD_LOC 16
11363: NOT
11364: IFFALSE 11368
// exit ;
11366: GO 11409
// for Kdo in Patrola do
11368: LD_ADDR_VAR 0 1
11372: PUSH
11373: LD_LOC 16
11377: PUSH
11378: FOR_IN
11379: IFFALSE 11406
// if GetFuel ( Kdo ) < 25 then
11381: LD_VAR 0 1
11385: PPUSH
11386: CALL_OW 261
11390: PUSH
11391: LD_INT 25
11393: LESS
11394: IFFALSE 11404
// begin zrus_patrolu ;
11396: CALL 10573 0 0
// exit ;
11400: POP
11401: POP
11402: GO 11409
// end ;
11404: GO 11378
11406: POP
11407: POP
// enable ;
11408: ENABLE
// end ;
11409: PPOPN 1
11411: END
// every 0 0$5.1 do var I , Stahnout ;
11412: GO 11414
11414: DISABLE
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
// begin Stahnout = true ;
11419: LD_ADDR_VAR 0 2
11423: PUSH
11424: LD_INT 1
11426: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
11427: LD_ADDR_VAR 0 1
11431: PUSH
11432: LD_LOC 20
11436: PPUSH
11437: CALL_OW 389
11441: PUSH
11442: FOR_IN
11443: IFFALSE 11474
// if ( GetUnitMc ( I ) = MakroObrana ) then
11445: LD_VAR 0 1
11449: PPUSH
11450: CALL_OW 388
11454: PUSH
11455: LD_LOC 20
11459: EQUAL
11460: IFFALSE 11472
// begin Stahnout = false ;
11462: LD_ADDR_VAR 0 2
11466: PUSH
11467: LD_INT 0
11469: ST_TO_ADDR
// break ;
11470: GO 11474
// end ;
11472: GO 11442
11474: POP
11475: POP
// enable ;
11476: ENABLE
// if Stahnout <> BeziStahovani then
11477: LD_VAR 0 2
11481: PUSH
11482: LD_LOC 24
11486: NONEQUAL
11487: IFFALSE 11513
// begin if Stahnout then
11489: LD_VAR 0 2
11493: IFFALSE 11500
// enable ( 46 ) else
11495: LD_INT 46
11497: ENABLE_MARKED
11498: GO 11503
// disable ( 46 ) ;
11500: LD_INT 46
11502: DISABLE_MARKED
// BeziStahovani = Stahnout ;
11503: LD_ADDR_LOC 24
11507: PUSH
11508: LD_VAR 0 2
11512: ST_TO_ADDR
// end ; end ;
11513: PPOPN 2
11515: END
// every 0 0$30 marked 46 do var I ;
11516: GO 11518
11518: DISABLE
11519: LD_INT 0
11521: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
11522: LD_ADDR_VAR 0 1
11526: PUSH
11527: LD_LOC 23
11531: PPUSH
11532: CALL_OW 389
11536: PUSH
11537: FOR_IN
11538: IFFALSE 11613
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , ArabskaBaze ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
11540: LD_VAR 0 1
11544: PPUSH
11545: CALL_OW 388
11549: PUSH
11550: LD_LOC 23
11554: EQUAL
11555: PUSH
11556: LD_VAR 0 1
11560: PPUSH
11561: LD_INT 14
11563: PPUSH
11564: CALL_OW 299
11568: PUSH
11569: LD_INT 0
11571: GREATER
11572: AND
11573: PUSH
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL_OW 310
11583: NOT
11584: AND
11585: PUSH
11586: LD_VAR 0 1
11590: PPUSH
11591: CALL_OW 314
11595: NOT
11596: AND
11597: IFFALSE 11611
// ComMoveToArea ( I , ArabskaBaze ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_INT 14
11606: PPUSH
11607: CALL_OW 113
11611: GO 11537
11613: POP
11614: POP
// BeziStahovani = false ;
11615: LD_ADDR_LOC 24
11619: PUSH
11620: LD_INT 0
11622: ST_TO_ADDR
// end ;
11623: PPOPN 1
11625: END
// function posila_tank ; begin
11626: LD_INT 0
11628: PPUSH
// UC_Side = side_Ar ;
11629: LD_ADDR_OWVAR 20
11633: PUSH
11634: LD_EXP 4
11638: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
11639: LD_ADDR_OWVAR 21
11643: PUSH
11644: LD_INT 2
11646: ST_TO_ADDR
// VC_Chassis = AR_MEDIUM_TRIKE ;
11647: LD_ADDR_OWVAR 37
11651: PUSH
11652: LD_INT 13
11654: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
11655: LD_ADDR_OWVAR 38
11659: PUSH
11660: LD_INT 1
11662: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
11663: LD_ADDR_OWVAR 39
11667: PUSH
11668: LD_INT 1
11670: ST_TO_ADDR
// VC_Weapon = nahoda_seznam ( [ AR_FLAME_THROWER , AR_ROCKET_LAUNCHER , AR_MULTIMISSILE_BALLISTA ] ) ;
11671: LD_ADDR_OWVAR 40
11675: PUSH
11676: LD_INT 26
11678: PUSH
11679: LD_INT 28
11681: PUSH
11682: LD_INT 22
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: LIST
11689: PPUSH
11690: CALL 21003 0 1
11694: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 85 , 100 ) ;
11695: LD_ADDR_OWVAR 41
11699: PUSH
11700: LD_INT 85
11702: PPUSH
11703: LD_INT 100
11705: PPUSH
11706: CALL_OW 12
11710: ST_TO_ADDR
// Result = CreateVehicle ;
11711: LD_ADDR_VAR 0 1
11715: PUSH
11716: CALL_OW 45
11720: ST_TO_ADDR
// PlaceHumanInUnit ( vytvor_cloveka ( CLASS_MECHANIC ) , Result ) ;
11721: LD_INT 3
11723: PPUSH
11724: CALL 7240 0 1
11728: PPUSH
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 52
// end ;
11738: LD_VAR 0 1
11742: RET
// function vytvor_posily ; begin
11743: LD_INT 0
11745: PPUSH
// Result = [ ] ;
11746: LD_ADDR_VAR 0 1
11750: PUSH
11751: EMPTY
11752: ST_TO_ADDR
// if Difficulty = 1 then
11753: LD_OWVAR 67
11757: PUSH
11758: LD_INT 1
11760: EQUAL
11761: IFFALSE 11765
// exit ;
11763: GO 11853
// Result = Result union [ posila_tank ] ;
11765: LD_ADDR_VAR 0 1
11769: PUSH
11770: LD_VAR 0 1
11774: PUSH
11775: CALL 11626 0 0
11779: PUSH
11780: EMPTY
11781: LIST
11782: UNION
11783: ST_TO_ADDR
// if Difficulty = 2 then
11784: LD_OWVAR 67
11788: PUSH
11789: LD_INT 2
11791: EQUAL
11792: IFFALSE 11796
// exit ;
11794: GO 11853
// Result = Result union [ posila_tank ] ;
11796: LD_ADDR_VAR 0 1
11800: PUSH
11801: LD_VAR 0 1
11805: PUSH
11806: CALL 11626 0 0
11810: PUSH
11811: EMPTY
11812: LIST
11813: UNION
11814: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_VAR 0 1
11824: PUSH
11825: CALL 11626 0 0
11829: PUSH
11830: EMPTY
11831: LIST
11832: UNION
11833: ST_TO_ADDR
// Result = Result union [ posila_tank ] ;
11834: LD_ADDR_VAR 0 1
11838: PUSH
11839: LD_VAR 0 1
11843: PUSH
11844: CALL 11626 0 0
11848: PUSH
11849: EMPTY
11850: LIST
11851: UNION
11852: ST_TO_ADDR
// end ;
11853: LD_VAR 0 1
11857: RET
// every 13 13$1 do var Posily , Lidi , I , J ;
11858: GO 11860
11860: DISABLE
11861: LD_INT 0
11863: PPUSH
11864: PPUSH
11865: PPUSH
11866: PPUSH
// begin Posily = vytvor_posily ;
11867: LD_ADDR_VAR 0 1
11871: PUSH
11872: CALL 11743 0 0
11876: ST_TO_ADDR
// place_list ( Posily , ArabovePosily ) ;
11877: LD_VAR 0 1
11881: PPUSH
11882: LD_INT 41
11884: PPUSH
11885: CALL 20678 0 2
// Lidi = [ ] ;
11889: LD_ADDR_VAR 0 2
11893: PUSH
11894: EMPTY
11895: ST_TO_ADDR
// for I in Posily do
11896: LD_ADDR_VAR 0 3
11900: PUSH
11901: LD_VAR 0 1
11905: PUSH
11906: FOR_IN
11907: IFFALSE 11951
// begin J = IsDrivenBy ( I ) ;
11909: LD_ADDR_VAR 0 4
11913: PUSH
11914: LD_VAR 0 3
11918: PPUSH
11919: CALL_OW 311
11923: ST_TO_ADDR
// if J then
11924: LD_VAR 0 4
11928: IFFALSE 11949
// Lidi = Lidi union [ J ] ;
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: LD_VAR 0 2
11939: PUSH
11940: LD_VAR 0 4
11944: PUSH
11945: EMPTY
11946: LIST
11947: UNION
11948: ST_TO_ADDR
// end ;
11949: GO 11906
11951: POP
11952: POP
// Autaky = Autaky union Posily ;
11953: LD_ADDR_LOC 6
11957: PUSH
11958: LD_LOC 6
11962: PUSH
11963: LD_VAR 0 1
11967: UNION
11968: ST_TO_ADDR
// AddMcUnits ( MakroObrana , Lidi union Posily ) ;
11969: LD_LOC 20
11973: PPUSH
11974: LD_VAR 0 2
11978: PUSH
11979: LD_VAR 0 1
11983: UNION
11984: PPUSH
11985: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , Lidi union Posily ) ;
11989: LD_LOC 23
11993: PPUSH
11994: LD_VAR 0 2
11998: PUSH
11999: LD_VAR 0 1
12003: UNION
12004: PPUSH
12005: CALL_OW 390
// end ;
12009: PPOPN 4
12011: END
// every 2 2$7 do
12012: GO 12014
12014: DISABLE
// begin opravuj_budovy ;
12015: CALL 12033 0 0
// kuryruj_lidi ;
12019: CALL 12478 0 0
// opravuj_auta ;
12023: CALL 12240 0 0
// sbirej_bedny ;
12027: CALL 12206 0 0
// enable ;
12031: ENABLE
// end ;
12032: END
// function opravuj_budovy ; var Budovy , Opravit , I , Kde ; begin
12033: LD_INT 0
12035: PPUSH
12036: PPUSH
12037: PPUSH
12038: PPUSH
12039: PPUSH
// if not IsOk ( ArEng ) then
12040: LD_INT 16
12042: PPUSH
12043: CALL_OW 302
12047: NOT
12048: IFFALSE 12052
// exit ;
12050: GO 12201
// Budovy = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , side_Ar ] ] ) ;
12052: LD_ADDR_VAR 0 2
12056: PUSH
12057: LD_INT 14
12059: PPUSH
12060: LD_INT 21
12062: PUSH
12063: LD_INT 3
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 22
12072: PUSH
12073: LD_EXP 4
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PPUSH
12086: CALL_OW 70
12090: ST_TO_ADDR
// Opravit = [ ] ;
12091: LD_ADDR_VAR 0 3
12095: PUSH
12096: EMPTY
12097: ST_TO_ADDR
// for I in Budovy do
12098: LD_ADDR_VAR 0 4
12102: PUSH
12103: LD_VAR 0 2
12107: PUSH
12108: FOR_IN
12109: IFFALSE 12147
// if GetLives ( I ) < HRANICE_ZDRAVI then
12111: LD_VAR 0 4
12115: PPUSH
12116: CALL_OW 256
12120: PUSH
12121: LD_INT 1000
12123: LESS
12124: IFFALSE 12145
// Opravit = Opravit union [ I ] ;
12126: LD_ADDR_VAR 0 3
12130: PUSH
12131: LD_VAR 0 3
12135: PUSH
12136: LD_VAR 0 4
12140: PUSH
12141: EMPTY
12142: LIST
12143: UNION
12144: ST_TO_ADDR
12145: GO 12108
12147: POP
12148: POP
// ComCancel ( ArEng ) ;
12149: LD_INT 16
12151: PPUSH
12152: CALL_OW 127
// if Opravit then
12156: LD_VAR 0 3
12160: IFFALSE 12201
// begin for I in Opravit do
12162: LD_ADDR_VAR 0 4
12166: PUSH
12167: LD_VAR 0 3
12171: PUSH
12172: FOR_IN
12173: IFFALSE 12189
// AddComRepairBuilding ( ArEng , I ) ;
12175: LD_INT 16
12177: PPUSH
12178: LD_VAR 0 4
12182: PPUSH
12183: CALL_OW 190
12187: GO 12172
12189: POP
12190: POP
// AddComMoveToArea ( ArEng , BednyArabi ) ;
12191: LD_INT 16
12193: PPUSH
12194: LD_INT 30
12196: PPUSH
12197: CALL_OW 173
// end ; end ;
12201: LD_VAR 0 1
12205: RET
// function sbirej_bedny ; begin
12206: LD_INT 0
12208: PPUSH
// if ArEng and IsOk ( ArEng ) then
12209: LD_INT 16
12211: PUSH
12212: LD_INT 16
12214: PPUSH
12215: CALL_OW 302
12219: AND
12220: IFFALSE 12235
// AddComCollect ( ArEng , 85 , 10 ) ;
12222: LD_INT 16
12224: PPUSH
12225: LD_INT 85
12227: PPUSH
12228: LD_INT 10
12230: PPUSH
12231: CALL_OW 177
// end ;
12235: LD_VAR 0 1
12239: RET
// function opravuj_auta ; var Auta , Opravit , I , Kde ; begin
12240: LD_INT 0
12242: PPUSH
12243: PPUSH
12244: PPUSH
12245: PPUSH
12246: PPUSH
// if ProbihaOprava then
12247: LD_LOC 29
12251: IFFALSE 12255
// exit ;
12253: GO 12473
// if not IsOk ( ArMech ) then
12255: LD_INT 21
12257: PPUSH
12258: CALL_OW 302
12262: NOT
12263: IFFALSE 12267
// exit ;
12265: GO 12473
// Auta = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , side_Ar ] ] ) diff Utok_Auta ;
12267: LD_ADDR_VAR 0 2
12271: PUSH
12272: LD_INT 14
12274: PPUSH
12275: LD_INT 21
12277: PUSH
12278: LD_INT 2
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 22
12287: PUSH
12288: LD_EXP 4
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PPUSH
12301: CALL_OW 70
12305: PUSH
12306: LD_LOC 9
12310: DIFF
12311: ST_TO_ADDR
// Opravit = [ ] ;
12312: LD_ADDR_VAR 0 3
12316: PUSH
12317: EMPTY
12318: ST_TO_ADDR
// for I in Auta do
12319: LD_ADDR_VAR 0 4
12323: PUSH
12324: LD_VAR 0 2
12328: PUSH
12329: FOR_IN
12330: IFFALSE 12368
// if GetLives ( I ) < HRANICE_ZDRAVI then
12332: LD_VAR 0 4
12336: PPUSH
12337: CALL_OW 256
12341: PUSH
12342: LD_INT 1000
12344: LESS
12345: IFFALSE 12366
// Opravit = Opravit union [ I ] ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: LD_VAR 0 3
12356: PUSH
12357: LD_VAR 0 4
12361: PUSH
12362: EMPTY
12363: LIST
12364: UNION
12365: ST_TO_ADDR
12366: GO 12329
12368: POP
12369: POP
// if Opravit then
12370: LD_VAR 0 3
12374: IFFALSE 12473
// begin Kde = IsInUnit ( ArMech ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 21
12383: PPUSH
12384: CALL_OW 310
12388: ST_TO_ADDR
// if Kde then
12389: LD_VAR 0 5
12393: IFFALSE 12426
// if GetType ( Kde ) = UNIT_BUILDING then
12395: LD_VAR 0 5
12399: PPUSH
12400: CALL_OW 247
12404: PUSH
12405: LD_INT 3
12407: EQUAL
12408: IFFALSE 12419
// ComExitBuilding ( ArMech ) else
12410: LD_INT 21
12412: PPUSH
12413: CALL_OW 122
12417: GO 12426
// ComExitVehicle ( ArMech ) ;
12419: LD_INT 21
12421: PPUSH
12422: CALL_OW 121
// for I in Opravit do
12426: LD_ADDR_VAR 0 4
12430: PUSH
12431: LD_VAR 0 3
12435: PUSH
12436: FOR_IN
12437: IFFALSE 12453
// AddComRepairVehicle ( ArMech , I ) ;
12439: LD_INT 21
12441: PPUSH
12442: LD_VAR 0 4
12446: PPUSH
12447: CALL_OW 189
12451: GO 12436
12453: POP
12454: POP
// AddComSailEvent ( ArMech , 102 ) ;
12455: LD_INT 21
12457: PPUSH
12458: LD_INT 102
12460: PPUSH
12461: CALL_OW 224
// ProbihaOprava = true ;
12465: LD_ADDR_LOC 29
12469: PUSH
12470: LD_INT 1
12472: ST_TO_ADDR
// end ; end ;
12473: LD_VAR 0 1
12477: RET
// function kuryruj_lidi ; var Lidi , Opravit , I , Kde , Felcar , Budova , Event ; begin
12478: LD_INT 0
12480: PPUSH
12481: PPUSH
12482: PPUSH
12483: PPUSH
12484: PPUSH
12485: PPUSH
12486: PPUSH
12487: PPUSH
// if ProbihaLeceni then
12488: LD_LOC 30
12492: IFFALSE 12496
// exit ;
12494: GO 12780
// if IsOk ( ArSci1 ) then
12496: LD_INT 17
12498: PPUSH
12499: CALL_OW 302
12503: IFFALSE 12531
// begin Felcar = ArSci1 ;
12505: LD_ADDR_VAR 0 6
12509: PUSH
12510: LD_INT 17
12512: ST_TO_ADDR
// Budova = ArLab1 ;
12513: LD_ADDR_VAR 0 7
12517: PUSH
12518: LD_INT 6
12520: ST_TO_ADDR
// Event = 103 ;
12521: LD_ADDR_VAR 0 8
12525: PUSH
12526: LD_INT 103
12528: ST_TO_ADDR
// end else
12529: GO 12568
// if IsOk ( ArSci2 ) then
12531: LD_INT 18
12533: PPUSH
12534: CALL_OW 302
12538: IFFALSE 12566
// begin Felcar = ArSci2 ;
12540: LD_ADDR_VAR 0 6
12544: PUSH
12545: LD_INT 18
12547: ST_TO_ADDR
// Budova = ArLab2 ;
12548: LD_ADDR_VAR 0 7
12552: PUSH
12553: LD_INT 24
12555: ST_TO_ADDR
// Event = 104 ;
12556: LD_ADDR_VAR 0 8
12560: PUSH
12561: LD_INT 104
12563: ST_TO_ADDR
// end else
12564: GO 12568
// exit ;
12566: GO 12780
// Lidi = FilterUnitsInArea ( ArabskaBaze , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , side_Ar ] ] ) ;
12568: LD_ADDR_VAR 0 2
12572: PUSH
12573: LD_INT 14
12575: PPUSH
12576: LD_INT 21
12578: PUSH
12579: LD_INT 1
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: LD_INT 22
12588: PUSH
12589: LD_EXP 4
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PPUSH
12602: CALL_OW 70
12606: ST_TO_ADDR
// Opravit = [ ] ;
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: EMPTY
12613: ST_TO_ADDR
// for I in Lidi do
12614: LD_ADDR_VAR 0 4
12618: PUSH
12619: LD_VAR 0 2
12623: PUSH
12624: FOR_IN
12625: IFFALSE 12663
// if GetLives ( I ) < HRANICE_ZDRAVI then
12627: LD_VAR 0 4
12631: PPUSH
12632: CALL_OW 256
12636: PUSH
12637: LD_INT 1000
12639: LESS
12640: IFFALSE 12661
// Opravit = Opravit union [ I ] ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_VAR 0 3
12651: PUSH
12652: LD_VAR 0 4
12656: PUSH
12657: EMPTY
12658: LIST
12659: UNION
12660: ST_TO_ADDR
12661: GO 12624
12663: POP
12664: POP
// if Opravit then
12665: LD_VAR 0 3
12669: IFFALSE 12780
// begin Kde = IsInUnit ( Felcar ) ;
12671: LD_ADDR_VAR 0 5
12675: PUSH
12676: LD_VAR 0 6
12680: PPUSH
12681: CALL_OW 310
12685: ST_TO_ADDR
// if Kde then
12686: LD_VAR 0 5
12690: IFFALSE 12727
// if GetType ( Kde ) = UNIT_BUILDING then
12692: LD_VAR 0 5
12696: PPUSH
12697: CALL_OW 247
12701: PUSH
12702: LD_INT 3
12704: EQUAL
12705: IFFALSE 12718
// ComExitBuilding ( Felcar ) else
12707: LD_VAR 0 6
12711: PPUSH
12712: CALL_OW 122
12716: GO 12727
// ComExitVehicle ( Felcar ) ;
12718: LD_VAR 0 6
12722: PPUSH
12723: CALL_OW 121
// for I in Opravit do
12727: LD_ADDR_VAR 0 4
12731: PUSH
12732: LD_VAR 0 3
12736: PUSH
12737: FOR_IN
12738: IFFALSE 12756
// AddComHeal ( Felcar , I ) ;
12740: LD_VAR 0 6
12744: PPUSH
12745: LD_VAR 0 4
12749: PPUSH
12750: CALL_OW 188
12754: GO 12737
12756: POP
12757: POP
// AddComSailEvent ( Felcar , Event ) ;
12758: LD_VAR 0 6
12762: PPUSH
12763: LD_VAR 0 8
12767: PPUSH
12768: CALL_OW 224
// ProbihaLeceni = true ;
12772: LD_ADDR_LOC 30
12776: PUSH
12777: LD_INT 1
12779: ST_TO_ADDR
// end ; end ;
12780: LD_VAR 0 1
12784: RET
// export function event_OpravaHotova ( Num ) ; begin
12785: LD_INT 0
12787: PPUSH
// case Num of 102 :
12788: LD_VAR 0 1
12792: PUSH
12793: LD_INT 102
12795: DOUBLE
12796: EQUAL
12797: IFTRUE 12801
12799: GO 12822
12801: POP
// begin ComEnterUnit ( ArMech , ArFact ) ;
12802: LD_INT 21
12804: PPUSH
12805: LD_INT 4
12807: PPUSH
12808: CALL_OW 120
// ProbihaOprava = false ;
12812: LD_ADDR_LOC 29
12816: PUSH
12817: LD_INT 0
12819: ST_TO_ADDR
// end ; 103 :
12820: GO 12881
12822: LD_INT 103
12824: DOUBLE
12825: EQUAL
12826: IFTRUE 12830
12828: GO 12851
12830: POP
// begin ComEnterUnit ( ArSci1 , ArLab1 ) ;
12831: LD_INT 17
12833: PPUSH
12834: LD_INT 6
12836: PPUSH
12837: CALL_OW 120
// ProbihaLeceni = false ;
12841: LD_ADDR_LOC 30
12845: PUSH
12846: LD_INT 0
12848: ST_TO_ADDR
// end ; 104 :
12849: GO 12881
12851: LD_INT 104
12853: DOUBLE
12854: EQUAL
12855: IFTRUE 12859
12857: GO 12880
12859: POP
// begin ComEnterUnit ( ArSci2 , ArLab2 ) ;
12860: LD_INT 18
12862: PPUSH
12863: LD_INT 24
12865: PPUSH
12866: CALL_OW 120
// ProbihaLeceni = false ;
12870: LD_ADDR_LOC 30
12874: PUSH
12875: LD_INT 0
12877: ST_TO_ADDR
// end ; end ;
12878: GO 12881
12880: POP
// end ;
12881: LD_VAR 0 2
12885: RET
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
12886: LD_INT 0
12888: PPUSH
12889: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
12890: LD_ADDR_VAR 0 4
12894: PUSH
12895: LD_INT 22
12897: PUSH
12898: LD_EXP 2
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: PUSH
12907: LD_INT 92
12909: PUSH
12910: LD_VAR 0 1
12914: PUSH
12915: LD_VAR 0 2
12919: PUSH
12920: LD_INT 2
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PPUSH
12933: CALL_OW 69
12937: ST_TO_ADDR
// if Jednotky then
12938: LD_VAR 0 4
12942: IFFALSE 12973
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
12944: LD_VAR 0 1
12948: PPUSH
12949: LD_VAR 0 2
12953: PPUSH
12954: LD_EXP 4
12958: PPUSH
12959: CALL_OW 456
// Result = true ;
12963: LD_ADDR_VAR 0 3
12967: PUSH
12968: LD_INT 1
12970: ST_TO_ADDR
// end else
12971: GO 12981
// Result = false ;
12973: LD_ADDR_VAR 0 3
12977: PUSH
12978: LD_INT 0
12980: ST_TO_ADDR
// end ;
12981: LD_VAR 0 3
12985: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
12986: GO 12988
12988: DISABLE
12989: LD_INT 0
12991: PPUSH
12992: PPUSH
// begin if not Miny then
12993: LD_LOC 28
12997: NOT
12998: IFFALSE 13002
// exit ;
13000: GO 13098
// Bouchlo = [ ] ;
13002: LD_ADDR_VAR 0 2
13006: PUSH
13007: EMPTY
13008: ST_TO_ADDR
// for M in Miny do
13009: LD_ADDR_VAR 0 1
13013: PUSH
13014: LD_LOC 28
13018: PUSH
13019: FOR_IN
13020: IFFALSE 13067
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
13022: LD_VAR 0 1
13026: PUSH
13027: LD_INT 1
13029: ARRAY
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_INT 2
13038: ARRAY
13039: PPUSH
13040: CALL 12886 0 2
13044: IFFALSE 13065
// Bouchlo = Bouchlo ^ [ M ] ;
13046: LD_ADDR_VAR 0 2
13050: PUSH
13051: LD_VAR 0 2
13055: PUSH
13056: LD_VAR 0 1
13060: PUSH
13061: EMPTY
13062: LIST
13063: ADD
13064: ST_TO_ADDR
13065: GO 13019
13067: POP
13068: POP
// if Bouchlo then
13069: LD_VAR 0 2
13073: IFFALSE 13091
// Miny = Miny diff Bouchlo ;
13075: LD_ADDR_LOC 28
13079: PUSH
13080: LD_LOC 28
13084: PUSH
13085: LD_VAR 0 2
13089: DIFF
13090: ST_TO_ADDR
// if Miny then
13091: LD_LOC 28
13095: IFFALSE 13098
// enable ;
13097: ENABLE
// end ; end_of_file
13098: PPOPN 2
13100: END
// export Yashin , YashinAutak ; var Zacal , Nastupuje , Nastoupil , Odjizdi ; var Bunkr ; var YashinPovoleneZbrane ; export function init_yashin ; begin
13101: LD_INT 0
13103: PPUSH
// disable ( 51 ) ;
13104: LD_INT 51
13106: DISABLE_MARKED
// disable ( 52 ) ;
13107: LD_INT 52
13109: DISABLE_MARKED
// disable ( 53 ) ;
13110: LD_INT 53
13112: DISABLE_MARKED
// disable ( 54 ) ;
13113: LD_INT 54
13115: DISABLE_MARKED
// disable ( 55 ) ;
13116: LD_INT 55
13118: DISABLE_MARKED
// disable ( 56 ) ;
13119: LD_INT 56
13121: DISABLE_MARKED
// disable ( 57 ) ;
13122: LD_INT 57
13124: DISABLE_MARKED
// Yashin = 0 ;
13125: LD_ADDR_EXP 34
13129: PUSH
13130: LD_INT 0
13132: ST_TO_ADDR
// YashinAutak = 0 ;
13133: LD_ADDR_EXP 35
13137: PUSH
13138: LD_INT 0
13140: ST_TO_ADDR
// Zacal = false ;
13141: LD_ADDR_LOC 31
13145: PUSH
13146: LD_INT 0
13148: ST_TO_ADDR
// Nastupuje = false ;
13149: LD_ADDR_LOC 32
13153: PUSH
13154: LD_INT 0
13156: ST_TO_ADDR
// Nastoupil = false ;
13157: LD_ADDR_LOC 33
13161: PUSH
13162: LD_INT 0
13164: ST_TO_ADDR
// Odjizdi = false ;
13165: LD_ADDR_LOC 34
13169: PUSH
13170: LD_INT 0
13172: ST_TO_ADDR
// Bunkr = 0 ;
13173: LD_ADDR_LOC 35
13177: PUSH
13178: LD_INT 0
13180: ST_TO_ADDR
// YashinPovoleneZbrane = [ RU_HEAVY_MACHINE_GUN , RU_GATLING_GUN , RU_GUN , RU_ROCKET_LAUNCHER , RU_HEAVY_GUN , RU_ROCKET ] ;
13181: LD_ADDR_LOC 36
13185: PUSH
13186: LD_INT 42
13188: PUSH
13189: LD_INT 43
13191: PUSH
13192: LD_INT 44
13194: PUSH
13195: LD_INT 45
13197: PUSH
13198: LD_INT 46
13200: PUSH
13201: LD_INT 47
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: ST_TO_ADDR
// end ;
13212: LD_VAR 0 1
13216: RET
// export function yashin_start_timer ; begin
13217: LD_INT 0
13219: PPUSH
// if not Zacal then
13220: LD_LOC 31
13224: NOT
13225: IFFALSE 13238
// begin enable ( 51 ) ;
13227: LD_INT 51
13229: ENABLE_MARKED
// Zacal = true ;
13230: LD_ADDR_LOC 31
13234: PUSH
13235: LD_INT 1
13237: ST_TO_ADDR
// end ; end ;
13238: LD_VAR 0 1
13242: RET
// function vytvor_yashina ; begin
13243: LD_INT 0
13245: PPUSH
// Yashin = NewCharacter ( Yashin ) ;
13246: LD_ADDR_EXP 34
13250: PUSH
13251: LD_STRING Yashin
13253: PPUSH
13254: CALL_OW 25
13258: ST_TO_ADDR
// SetClass ( Yashin , CLASS_BAZOOKER ) ;
13259: LD_EXP 34
13263: PPUSH
13264: LD_INT 9
13266: PPUSH
13267: CALL_OW 336
// SetSide ( Yashin , side_Ru2 ) ;
13271: LD_EXP 34
13275: PPUSH
13276: LD_EXP 3
13280: PPUSH
13281: CALL_OW 235
// DoNotAttack ( side_Ar , Yashin ) ;
13285: LD_EXP 4
13289: PPUSH
13290: LD_EXP 34
13294: PPUSH
13295: CALL_OW 471
// end ;
13299: LD_VAR 0 1
13303: RET
// function yashin_start ; var Vysledek , Area , Bunkry ; begin
13304: LD_INT 0
13306: PPUSH
13307: PPUSH
13308: PPUSH
13309: PPUSH
// vytvor_yashina ;
13310: CALL 13243 0 0
// if VsevSaved then
13314: LD_EXP 8
13318: IFFALSE 13345
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13320: LD_EXP 34
13324: PPUSH
13325: LD_INT 39
13327: PPUSH
13328: LD_INT 0
13330: PPUSH
13331: CALL_OW 49
// Area = YashinCil1 ;
13335: LD_ADDR_VAR 0 3
13339: PUSH
13340: LD_INT 31
13342: ST_TO_ADDR
// end else
13343: GO 13368
// begin PlaceUnitArea ( Yashin , YashinStart , false ) ;
13345: LD_EXP 34
13349: PPUSH
13350: LD_INT 39
13352: PPUSH
13353: LD_INT 0
13355: PPUSH
13356: CALL_OW 49
// Area = YashinCil1a ;
13360: LD_ADDR_VAR 0 3
13364: PUSH
13365: LD_INT 32
13367: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Area ) then
13368: LD_EXP 10
13372: PPUSH
13373: LD_VAR 0 3
13377: PPUSH
13378: CALL_OW 308
13382: IFFALSE 13415
// ComMoveXY ( Yashin , GetX ( Burlak ) , GetY ( Burlak ) ) else
13384: LD_EXP 34
13388: PPUSH
13389: LD_EXP 10
13393: PPUSH
13394: CALL_OW 250
13398: PPUSH
13399: LD_EXP 10
13403: PPUSH
13404: CALL_OW 251
13408: PPUSH
13409: CALL_OW 111
13413: GO 13429
// ComMoveToArea ( Yashin , Area ) ;
13415: LD_EXP 34
13419: PPUSH
13420: LD_VAR 0 3
13424: PPUSH
13425: CALL_OW 113
// CenterOnUnits ( Yashin ) ;
13429: LD_EXP 34
13433: PPUSH
13434: CALL_OW 85
// Wait ( 0 0$4 ) ;
13438: LD_INT 140
13440: PPUSH
13441: CALL_OW 67
// DialogueOn ;
13445: CALL_OW 6
// dialog_YashinArrives ;
13449: CALL 22162 0 0
// Bunkry = yashin_zjisti_bunkry ;
13453: LD_ADDR_VAR 0 4
13457: PUSH
13458: CALL 14356 0 0
13462: ST_TO_ADDR
// if Bunkry then
13463: LD_VAR 0 4
13467: IFFALSE 13481
// Vysledek = query_YashinHelp else
13469: LD_ADDR_VAR 0 2
13473: PUSH
13474: CALL 22388 0 0
13478: ST_TO_ADDR
13479: GO 13491
// Vysledek = query_YashinHelpNB ;
13481: LD_ADDR_VAR 0 2
13485: PUSH
13486: CALL 22409 0 0
13490: ST_TO_ADDR
// if Vysledek = 1 then
13491: LD_VAR 0 2
13495: PUSH
13496: LD_INT 1
13498: EQUAL
13499: IFFALSE 13544
// begin dialog_QrYashinHelp1 ;
13501: CALL 22440 0 0
// DialogueOff ;
13505: CALL_OW 7
// Bunkr = Bunkry [ Rand ( 1 , Bunkry ) ] ;
13509: LD_ADDR_LOC 35
13513: PUSH
13514: LD_VAR 0 4
13518: PUSH
13519: LD_INT 1
13521: PPUSH
13522: LD_VAR 0 4
13526: PPUSH
13527: CALL_OW 12
13531: ARRAY
13532: ST_TO_ADDR
// yashin_znic_bunkr ( Area ) ;
13533: LD_VAR 0 3
13537: PPUSH
13538: CALL 14487 0 1
// end else
13542: GO 13576
// begin if Vysledek = 2 then
13544: LD_VAR 0 2
13548: PUSH
13549: LD_INT 2
13551: EQUAL
13552: IFFALSE 13560
// dialog_QrYashinHelp2 else
13554: CALL 22496 0 0
13558: GO 13564
// dialog_QrYashinHelp3 ;
13560: CALL 22528 0 0
// dialog_YashinLeave ;
13564: CALL 22560 0 0
// DialogueOff ;
13568: CALL_OW 7
// yashin_vyzadej_autak ;
13572: CALL 14206 0 0
// end ; enable ( 53 ) ;
13576: LD_INT 53
13578: ENABLE_MARKED
// enable ( 57 ) ;
13579: LD_INT 57
13581: ENABLE_MARKED
// end ;
13582: LD_VAR 0 1
13586: RET
// function yashin_chci_autak ; var I , Temp , Kde , Volne , Dalka , Ridic ; begin
13587: LD_INT 0
13589: PPUSH
13590: PPUSH
13591: PPUSH
13592: PPUSH
13593: PPUSH
13594: PPUSH
13595: PPUSH
// if YashinAutak then
13596: LD_EXP 35
13600: IFFALSE 13752
// begin if not IsOK ( YashinAutak ) or ( GetSide ( YashinAutak ) <> side_Ru2 ) then
13602: LD_EXP 35
13606: PPUSH
13607: CALL_OW 302
13611: NOT
13612: PUSH
13613: LD_EXP 35
13617: PPUSH
13618: CALL_OW 255
13622: PUSH
13623: LD_EXP 3
13627: NONEQUAL
13628: OR
13629: IFFALSE 13641
// begin YashinAutak = 0 ;
13631: LD_ADDR_EXP 35
13635: PUSH
13636: LD_INT 0
13638: ST_TO_ADDR
// end else
13639: GO 13752
// begin Ridic = IsDrivenBy ( YashinAutak ) ;
13641: LD_ADDR_VAR 0 7
13645: PUSH
13646: LD_EXP 35
13650: PPUSH
13651: CALL_OW 311
13655: ST_TO_ADDR
// if Ridic = Yashin then
13656: LD_VAR 0 7
13660: PUSH
13661: LD_EXP 34
13665: EQUAL
13666: IFFALSE 13701
// begin Nastupuje = false ;
13668: LD_ADDR_LOC 32
13672: PUSH
13673: LD_INT 0
13675: ST_TO_ADDR
// Nastoupil = true ;
13676: LD_ADDR_LOC 33
13680: PUSH
13681: LD_INT 1
13683: ST_TO_ADDR
// disable ( 55 ) ;
13684: LD_INT 55
13686: DISABLE_MARKED
// yashin_zacni_odjizdet ;
13687: CALL 14244 0 0
// Result = true ;
13691: LD_ADDR_VAR 0 1
13695: PUSH
13696: LD_INT 1
13698: ST_TO_ADDR
// exit ;
13699: GO 14201
// end ; if Ridic then
13701: LD_VAR 0 7
13705: IFFALSE 13726
// begin ComCancel ( Yashin ) ;
13707: LD_EXP 34
13711: PPUSH
13712: CALL_OW 127
// YashinAutak = 0 ;
13716: LD_ADDR_EXP 35
13720: PUSH
13721: LD_INT 0
13723: ST_TO_ADDR
// end else
13724: GO 13752
// begin if not HasTask ( Yashin ) then
13726: LD_EXP 34
13730: PPUSH
13731: CALL_OW 314
13735: NOT
13736: IFFALSE 13752
// ComEnterUnit ( Yashin , YashinAutak ) ;
13738: LD_EXP 34
13742: PPUSH
13743: LD_EXP 35
13747: PPUSH
13748: CALL_OW 120
// end ; end ; end ; Kde = IsInUnit ( Yashin ) ;
13752: LD_ADDR_VAR 0 4
13756: PUSH
13757: LD_EXP 34
13761: PPUSH
13762: CALL_OW 310
13766: ST_TO_ADDR
// if ( Kde <> 0 ) then
13767: LD_VAR 0 4
13771: PUSH
13772: LD_INT 0
13774: NONEQUAL
13775: IFFALSE 13866
// begin if GetType ( Kde ) = UNIT_VEHICLE then
13777: LD_VAR 0 4
13781: PPUSH
13782: CALL_OW 247
13786: PUSH
13787: LD_INT 2
13789: EQUAL
13790: IFFALSE 13835
// begin Nastupuje = false ;
13792: LD_ADDR_LOC 32
13796: PUSH
13797: LD_INT 0
13799: ST_TO_ADDR
// Nastoupil = true ;
13800: LD_ADDR_LOC 33
13804: PUSH
13805: LD_INT 1
13807: ST_TO_ADDR
// disable ( 55 ) ;
13808: LD_INT 55
13810: DISABLE_MARKED
// YashinAutak = Kde ;
13811: LD_ADDR_EXP 35
13815: PUSH
13816: LD_VAR 0 4
13820: ST_TO_ADDR
// yashin_zacni_odjizdet ;
13821: CALL 14244 0 0
// Result = true ;
13825: LD_ADDR_VAR 0 1
13829: PUSH
13830: LD_INT 1
13832: ST_TO_ADDR
// exit ;
13833: GO 14201
// end ; if GetType ( Kde ) = UNIT_BUILDING then
13835: LD_VAR 0 4
13839: PPUSH
13840: CALL_OW 247
13844: PUSH
13845: LD_INT 3
13847: EQUAL
13848: IFFALSE 13866
// begin ComExitBuilding ( Yashin ) ;
13850: LD_EXP 34
13854: PPUSH
13855: CALL_OW 122
// Wait ( 0 0$0.25 ) ;
13859: LD_INT 9
13861: PPUSH
13862: CALL_OW 67
// end ; end ; Result = false ;
13866: LD_ADDR_VAR 0 1
13870: PUSH
13871: LD_INT 0
13873: ST_TO_ADDR
// if HasTask ( Yashin ) then
13874: LD_EXP 34
13878: PPUSH
13879: CALL_OW 314
13883: IFFALSE 13887
// exit ;
13885: GO 14201
// Volne = [ ] ;
13887: LD_ADDR_VAR 0 5
13891: PUSH
13892: EMPTY
13893: ST_TO_ADDR
// Temp = FilterUnitsExceptArea ( Nebezpeci , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_CONTROL , CONTROL_MANUAL ] ] ) ;
13894: LD_ADDR_VAR 0 3
13898: PUSH
13899: LD_INT 34
13901: PPUSH
13902: LD_INT 22
13904: PUSH
13905: LD_EXP 2
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PUSH
13914: LD_INT 21
13916: PUSH
13917: LD_INT 2
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PUSH
13924: LD_INT 50
13926: PUSH
13927: EMPTY
13928: LIST
13929: PUSH
13930: LD_INT 33
13932: PUSH
13933: LD_INT 1
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: PPUSH
13946: CALL_OW 71
13950: ST_TO_ADDR
// for I in Temp do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_VAR 0 3
13960: PUSH
13961: FOR_IN
13962: IFFALSE 14050
// begin if IsDrivenBy ( I ) then
13964: LD_VAR 0 2
13968: PPUSH
13969: CALL_OW 311
13973: IFFALSE 13977
// continue ;
13975: GO 13961
// if ( GetEngine ( I ) = ENGINE_COMBUSTION ) and ( GetFuel ( I ) < 50 ) then
13977: LD_VAR 0 2
13981: PPUSH
13982: CALL_OW 262
13986: PUSH
13987: LD_INT 1
13989: EQUAL
13990: PUSH
13991: LD_VAR 0 2
13995: PPUSH
13996: CALL_OW 261
14000: PUSH
14001: LD_INT 50
14003: LESS
14004: AND
14005: IFFALSE 14009
// continue ;
14007: GO 13961
// if not GetWeapon ( I ) in YashinPovoleneZbrane then
14009: LD_VAR 0 2
14013: PPUSH
14014: CALL_OW 264
14018: PUSH
14019: LD_LOC 36
14023: IN
14024: NOT
14025: IFFALSE 14029
// continue ;
14027: GO 13961
// Volne = Volne union [ I ] ;
14029: LD_ADDR_VAR 0 5
14033: PUSH
14034: LD_VAR 0 5
14038: PUSH
14039: LD_VAR 0 2
14043: PUSH
14044: EMPTY
14045: LIST
14046: UNION
14047: ST_TO_ADDR
// end ;
14048: GO 13961
14050: POP
14051: POP
// if not Volne then
14052: LD_VAR 0 5
14056: NOT
14057: IFFALSE 14061
// exit ;
14059: GO 14201
// YashinAutak = Volne [ 1 ] ;
14061: LD_ADDR_EXP 35
14065: PUSH
14066: LD_VAR 0 5
14070: PUSH
14071: LD_INT 1
14073: ARRAY
14074: ST_TO_ADDR
// Dalka = GetDistUnits ( Yashin , YashinAutak ) ;
14075: LD_ADDR_VAR 0 6
14079: PUSH
14080: LD_EXP 34
14084: PPUSH
14085: LD_EXP 35
14089: PPUSH
14090: CALL_OW 296
14094: ST_TO_ADDR
// for I in ( Volne diff [ YashinAutak ] ) do
14095: LD_ADDR_VAR 0 2
14099: PUSH
14100: LD_VAR 0 5
14104: PUSH
14105: LD_EXP 35
14109: PUSH
14110: EMPTY
14111: LIST
14112: DIFF
14113: PUSH
14114: FOR_IN
14115: IFFALSE 14171
// begin Temp = GetDistUnits ( Yashin , I ) ;
14117: LD_ADDR_VAR 0 3
14121: PUSH
14122: LD_EXP 34
14126: PPUSH
14127: LD_VAR 0 2
14131: PPUSH
14132: CALL_OW 296
14136: ST_TO_ADDR
// if Temp < Dalka then
14137: LD_VAR 0 3
14141: PUSH
14142: LD_VAR 0 6
14146: LESS
14147: IFFALSE 14169
// begin Dalka = Temp ;
14149: LD_ADDR_VAR 0 6
14153: PUSH
14154: LD_VAR 0 3
14158: ST_TO_ADDR
// YashinAutak = I ;
14159: LD_ADDR_EXP 35
14163: PUSH
14164: LD_VAR 0 2
14168: ST_TO_ADDR
// end ; end ;
14169: GO 14114
14171: POP
14172: POP
// ComEnterUnit ( Yashin , YashinAutak ) ;
14173: LD_EXP 34
14177: PPUSH
14178: LD_EXP 35
14182: PPUSH
14183: CALL_OW 120
// SetSide ( YashinAutak , side_Ru2 ) ;
14187: LD_EXP 35
14191: PPUSH
14192: LD_EXP 3
14196: PPUSH
14197: CALL_OW 235
// end ;
14201: LD_VAR 0 1
14205: RET
// function yashin_vyzadej_autak ; begin
14206: LD_INT 0
14208: PPUSH
// Nastupuje = true ;
14209: LD_ADDR_LOC 32
14213: PUSH
14214: LD_INT 1
14216: ST_TO_ADDR
// ComCancel ( Yashin ) ;
14217: LD_EXP 34
14221: PPUSH
14222: CALL_OW 127
// if not yashin_chci_autak then
14226: CALL 13587 0 0
14230: NOT
14231: IFFALSE 14239
// begin enable ( 54 ) ;
14233: LD_INT 54
14235: ENABLE_MARKED
// enable ( 55 ) ;
14236: LD_INT 55
14238: ENABLE_MARKED
// end ; end ;
14239: LD_VAR 0 1
14243: RET
// function yashin_zacni_odjizdet ; begin
14244: LD_INT 0
14246: PPUSH
// Odjizdi = true ;
14247: LD_ADDR_LOC 34
14251: PUSH
14252: LD_INT 1
14254: ST_TO_ADDR
// disable ( 54 ) ;
14255: LD_INT 54
14257: DISABLE_MARKED
// disable ( 55 ) ;
14258: LD_INT 55
14260: DISABLE_MARKED
// disable ( 56 ) ;
14261: LD_INT 56
14263: DISABLE_MARKED
// if not yashin_odjizdi then
14264: CALL 14279 0 0
14268: NOT
14269: IFFALSE 14274
// enable ( 52 ) ;
14271: LD_INT 52
14273: ENABLE_MARKED
// end ;
14274: LD_VAR 0 1
14278: RET
// function yashin_odjizdi ; var Jednotka ; begin
14279: LD_INT 0
14281: PPUSH
14282: PPUSH
// if YashinAutak then
14283: LD_EXP 35
14287: IFFALSE 14301
// Jednotka = YashinAutak else
14289: LD_ADDR_VAR 0 2
14293: PUSH
14294: LD_EXP 35
14298: ST_TO_ADDR
14299: GO 14311
// Jednotka = Yashin ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: LD_EXP 34
14310: ST_TO_ADDR
// if IsInArea ( Jednotka , YashinExit ) then
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 33
14318: PPUSH
14319: CALL_OW 308
14323: IFFALSE 14339
// begin yashin_odstran ;
14325: CALL 15096 0 0
// Result = true ;
14329: LD_ADDR_VAR 0 1
14333: PUSH
14334: LD_INT 1
14336: ST_TO_ADDR
// end else
14337: GO 14351
// begin ComMoveToArea ( Jednotka , YashinExit ) ;
14339: LD_VAR 0 2
14343: PPUSH
14344: LD_INT 33
14346: PPUSH
14347: CALL_OW 113
// end ; end ;
14351: LD_VAR 0 1
14355: RET
// function yashin_zjisti_bunkry ; var Domy ; begin
14356: LD_INT 0
14358: PPUSH
14359: PPUSH
// Domy = FilterUnitsInArea ( AraboveBunkry , [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
14360: LD_ADDR_VAR 0 2
14364: PUSH
14365: LD_INT 35
14367: PPUSH
14368: LD_INT 22
14370: PUSH
14371: LD_EXP 4
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: PUSH
14380: LD_INT 50
14382: PUSH
14383: EMPTY
14384: LIST
14385: PUSH
14386: LD_INT 21
14388: PUSH
14389: LD_INT 3
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: LIST
14400: PPUSH
14401: CALL_OW 70
14405: ST_TO_ADDR
// Result = UnitFilter ( Domy , [ [ F_BTYPE , B_BREASTWORK ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_BUNKER ] ] ) union UnitFilter ( Domy , [ [ F_BTYPE , B_TURRET ] ] ) ;
14406: LD_ADDR_VAR 0 1
14410: PUSH
14411: LD_VAR 0 2
14415: PPUSH
14416: LD_INT 30
14418: PUSH
14419: LD_INT 31
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: PUSH
14426: EMPTY
14427: LIST
14428: PPUSH
14429: CALL_OW 72
14433: PUSH
14434: LD_VAR 0 2
14438: PPUSH
14439: LD_INT 30
14441: PUSH
14442: LD_INT 32
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: EMPTY
14450: LIST
14451: PPUSH
14452: CALL_OW 72
14456: UNION
14457: PUSH
14458: LD_VAR 0 2
14462: PPUSH
14463: LD_INT 30
14465: PUSH
14466: LD_INT 33
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: PUSH
14473: EMPTY
14474: LIST
14475: PPUSH
14476: CALL_OW 72
14480: UNION
14481: ST_TO_ADDR
// end ;
14482: LD_VAR 0 1
14486: RET
// function yashin_znic_bunkr ( Zpatky ) ; begin
14487: LD_INT 0
14489: PPUSH
// ComAgressiveMove ( Yashin , 32 , 29 ) ;
14490: LD_EXP 34
14494: PPUSH
14495: LD_INT 32
14497: PPUSH
14498: LD_INT 29
14500: PPUSH
14501: CALL_OW 114
// AddComSailEvent ( Yashin , 111 ) ;
14505: LD_EXP 34
14509: PPUSH
14510: LD_INT 111
14512: PPUSH
14513: CALL_OW 224
// AddComAttackUnit ( Yashin , Bunkr ) ;
14517: LD_EXP 34
14521: PPUSH
14522: LD_LOC 35
14526: PPUSH
14527: CALL_OW 175
// AddComAgressiveMove ( Yashin , 33 , 35 ) ;
14531: LD_EXP 34
14535: PPUSH
14536: LD_INT 33
14538: PPUSH
14539: LD_INT 35
14541: PPUSH
14542: CALL_OW 174
// AddComMoveToArea ( Yashin , Zpatky ) ;
14546: LD_EXP 34
14550: PPUSH
14551: LD_VAR 0 1
14555: PPUSH
14556: CALL_OW 173
// enable ( 56 ) ;
14560: LD_INT 56
14562: ENABLE_MARKED
// end ;
14563: LD_VAR 0 2
14567: RET
// export function event_YashinUtoci ; begin
14568: LD_INT 0
14570: PPUSH
// RevealFogArea ( side_Ru , AraboveBunkry ) ;
14571: LD_EXP 2
14575: PPUSH
14576: LD_INT 35
14578: PPUSH
14579: CALL_OW 332
// end ;
14583: LD_VAR 0 1
14587: RET
// export function yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14588: LD_INT 0
14590: PPUSH
// if Nastupuje and ( VehOld = YashinAutak ) then
14591: LD_LOC 32
14595: PUSH
14596: LD_VAR 0 2
14600: PUSH
14601: LD_EXP 35
14605: EQUAL
14606: AND
14607: IFFALSE 14619
// YashinAutak = VehNew ;
14609: LD_ADDR_EXP 35
14613: PUSH
14614: LD_VAR 0 1
14618: ST_TO_ADDR
// end ;
14619: LD_VAR 0 5
14623: RET
// every 0 0$1.3 marked 52 do
14624: GO 14626
14626: DISABLE
// begin if not yashin_odjizdi then
14627: CALL 14279 0 0
14631: NOT
14632: IFFALSE 14635
// enable ;
14634: ENABLE
// end ;
14635: END
// every 0 0$2.7 marked 54 do
14636: GO 14638
14638: DISABLE
// begin if not yashin_chci_autak then
14639: CALL 13587 0 0
14643: NOT
14644: IFFALSE 14647
// enable ;
14646: ENABLE
// end ;
14647: END
// every 5 5$3 marked 55 do
14648: GO 14650
14650: DISABLE
// begin if Nastoupil then
14651: LD_LOC 33
14655: IFFALSE 14659
// exit ;
14657: GO 14681
// DialogueOn ;
14659: CALL_OW 6
// CenterOnUnits ( Yashin ) ;
14663: LD_EXP 34
14667: PPUSH
14668: CALL_OW 85
// dialog_YashinLeave ;
14672: CALL 22560 0 0
// DialogueOff ;
14676: CALL_OW 7
// enable ;
14680: ENABLE
// end ;
14681: END
// every 0 0$7.1 trigger ( not IsOK ( Bunkr ) ) or ( GetSide ( Bunkr ) <> side_Ar ) marked 56 do
14682: LD_LOC 35
14686: PPUSH
14687: CALL_OW 302
14691: NOT
14692: PUSH
14693: LD_LOC 35
14697: PPUSH
14698: CALL_OW 255
14702: PUSH
14703: LD_EXP 4
14707: NONEQUAL
14708: OR
14709: IFFALSE 14742
14711: GO 14713
14713: DISABLE
// begin RevealFogArea ( side_Ru , AraboveBunkry ) ;
14714: LD_EXP 2
14718: PPUSH
14719: LD_INT 35
14721: PPUSH
14722: CALL_OW 332
// DialogueOn ;
14726: CALL_OW 6
// dialog_YashinLeave ;
14730: CALL 22560 0 0
// dialogueOff ;
14734: CALL_OW 7
// yashin_vyzadej_autak ;
14738: CALL 14206 0 0
// end ;
14742: END
// every 2 2$55 marked 51 do
14743: GO 14745
14745: DISABLE
// begin Wait ( MultiRand ( 0 0$1 , 2 2$0 , 2 ) ) ;
14746: LD_INT 35
14748: PPUSH
14749: LD_INT 4200
14751: PPUSH
14752: LD_INT 2
14754: PPUSH
14755: CALL_OW 14
14759: PPUSH
14760: CALL_OW 67
// yashin_start ;
14764: CALL 13304 0 0
// end ;
14768: END
// every 0 0$0.7 marked 53 do var Jednotky , Kdo , Cile , Utoci ;
14769: GO 14771
14771: DISABLE
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
// begin Kdo = IsInUnit ( Yashin ) ;
14778: LD_ADDR_VAR 0 2
14782: PUSH
14783: LD_EXP 34
14787: PPUSH
14788: CALL_OW 310
14792: ST_TO_ADDR
// if Kdo then
14793: LD_VAR 0 2
14797: IFFALSE 14820
// Cile = [ Yashin , Kdo ] else
14799: LD_ADDR_VAR 0 3
14803: PUSH
14804: LD_EXP 34
14808: PUSH
14809: LD_VAR 0 2
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: ST_TO_ADDR
14818: GO 14833
// Cile = [ Yashin ] ;
14820: LD_ADDR_VAR 0 3
14824: PUSH
14825: LD_EXP 34
14829: PUSH
14830: EMPTY
14831: LIST
14832: ST_TO_ADDR
// Utoci = false ;
14833: LD_ADDR_VAR 0 4
14837: PUSH
14838: LD_INT 0
14840: ST_TO_ADDR
// Jednotky = FilterAllUnits ( [ [ F_OK ] , [ F_SIDE , side_Ru ] ] ) ;
14841: LD_ADDR_VAR 0 1
14845: PUSH
14846: LD_INT 50
14848: PUSH
14849: EMPTY
14850: LIST
14851: PUSH
14852: LD_INT 22
14854: PUSH
14855: LD_EXP 2
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PPUSH
14868: CALL_OW 69
14872: ST_TO_ADDR
// for Kdo in Jednotky do
14873: LD_ADDR_VAR 0 2
14877: PUSH
14878: LD_VAR 0 1
14882: PUSH
14883: FOR_IN
14884: IFFALSE 14948
// begin if ( WantsToAttack ( Kdo ) in Cile ) or ( Attacks ( Kdo ) in Cile ) then
14886: LD_VAR 0 2
14890: PPUSH
14891: CALL_OW 319
14895: PUSH
14896: LD_VAR 0 3
14900: IN
14901: PUSH
14902: LD_VAR 0 2
14906: PPUSH
14907: CALL_OW 320
14911: PUSH
14912: LD_VAR 0 3
14916: IN
14917: OR
14918: IFFALSE 14946
// begin ComCancel ( Kdo ) ;
14920: LD_VAR 0 2
14924: PPUSH
14925: CALL_OW 127
// ComHold ( Kdo ) ;
14929: LD_VAR 0 2
14933: PPUSH
14934: CALL_OW 140
// Utoci = true ;
14938: LD_ADDR_VAR 0 4
14942: PUSH
14943: LD_INT 1
14945: ST_TO_ADDR
// end ; end ;
14946: GO 14883
14948: POP
14949: POP
// if Utoci then
14950: LD_VAR 0 4
14954: IFFALSE 14979
// begin DialogueOn ;
14956: CALL_OW 6
// dialog_YashinAttack ;
14960: CALL 22614 0 0
// DialogueOff ;
14964: CALL_OW 7
// if not Odjizdi then
14968: LD_LOC 34
14972: NOT
14973: IFFALSE 14979
// yashin_zacni_odjizdet ;
14975: CALL 14244 0 0
// end ; enable ;
14979: ENABLE
// end ;
14980: PPOPN 4
14982: END
// every 0 0$0.6 marked 57 do var L ;
14983: GO 14985
14985: DISABLE
14986: LD_INT 0
14988: PPUSH
// begin L = GetLives ( Yashin ) ;
14989: LD_ADDR_VAR 0 1
14993: PUSH
14994: LD_EXP 34
14998: PPUSH
14999: CALL_OW 256
15003: ST_TO_ADDR
// if L < 1000 then
15004: LD_VAR 0 1
15008: PUSH
15009: LD_INT 1000
15011: LESS
15012: IFFALSE 15060
// begin L = L + 20 ;
15014: LD_ADDR_VAR 0 1
15018: PUSH
15019: LD_VAR 0 1
15023: PUSH
15024: LD_INT 20
15026: PLUS
15027: ST_TO_ADDR
// if L > 1000 then
15028: LD_VAR 0 1
15032: PUSH
15033: LD_INT 1000
15035: GREATER
15036: IFFALSE 15046
// L = 1000 ;
15038: LD_ADDR_VAR 0 1
15042: PUSH
15043: LD_INT 1000
15045: ST_TO_ADDR
// SetLives ( Yashin , L ) ;
15046: LD_EXP 34
15050: PPUSH
15051: LD_VAR 0 1
15055: PPUSH
15056: CALL_OW 234
// end ; enable ;
15060: ENABLE
// end ;
15061: PPOPN 1
15063: END
// export function yashin_UnitGoesToRed ( Un ) ; begin
15064: LD_INT 0
15066: PPUSH
// if Un = Yashin then
15067: LD_VAR 0 1
15071: PUSH
15072: LD_EXP 34
15076: EQUAL
15077: IFFALSE 15091
// SetLives ( Yashin , 300 ) ;
15079: LD_EXP 34
15083: PPUSH
15084: LD_INT 300
15086: PPUSH
15087: CALL_OW 234
// end ;
15091: LD_VAR 0 2
15095: RET
// function yashin_odstran ; begin
15096: LD_INT 0
15098: PPUSH
// if YashinAutak then
15099: LD_EXP 35
15103: IFFALSE 15114
// RemoveUnit ( YashinAutak ) ;
15105: LD_EXP 35
15109: PPUSH
15110: CALL_OW 64
// RemoveUnit ( Yashin ) ;
15114: LD_EXP 34
15118: PPUSH
15119: CALL_OW 64
// disable ( 53 ) ;
15123: LD_INT 53
15125: DISABLE_MARKED
// end ; end_of_file
15126: LD_VAR 0 1
15130: RET
// var KamArea , VraciSe ; var Krade , Nastupuje , KradenyVuz ; export function init_xavier ; begin
15131: LD_INT 0
15133: PPUSH
// KamArea = 0 ;
15134: LD_ADDR_LOC 37
15138: PUSH
15139: LD_INT 0
15141: ST_TO_ADDR
// VraciSe = false ;
15142: LD_ADDR_LOC 38
15146: PUSH
15147: LD_INT 0
15149: ST_TO_ADDR
// Krade = false ;
15150: LD_ADDR_LOC 39
15154: PUSH
15155: LD_INT 0
15157: ST_TO_ADDR
// KradenyVuz = 0 ;
15158: LD_ADDR_LOC 41
15162: PUSH
15163: LD_INT 0
15165: ST_TO_ADDR
// disable ( 21 ) ;
15166: LD_INT 21
15168: DISABLE_MARKED
// disable ( 22 ) ;
15169: LD_INT 22
15171: DISABLE_MARKED
// disable ( 23 ) ;
15172: LD_INT 23
15174: DISABLE_MARKED
// disable ( 24 ) ;
15175: LD_INT 24
15177: DISABLE_MARKED
// disable ( 26 ) ;
15178: LD_INT 26
15180: DISABLE_MARKED
// end ;
15181: LD_VAR 0 1
15185: RET
// function vytvor_xaviera ; begin
15186: LD_INT 0
15188: PPUSH
// Xavier = NewCharacter ( Xavier ) ;
15189: LD_ADDR_EXP 25
15193: PUSH
15194: LD_STRING Xavier
15196: PPUSH
15197: CALL_OW 25
15201: ST_TO_ADDR
// SetSide ( Xavier , side_Xavier ) ;
15202: LD_EXP 25
15206: PPUSH
15207: LD_EXP 5
15211: PPUSH
15212: CALL_OW 235
// end ;
15216: LD_VAR 0 1
15220: RET
// export function xavier_start ; var Vysledek ; begin
15221: LD_INT 0
15223: PPUSH
15224: PPUSH
// vytvor_xaviera ;
15225: CALL 15186 0 0
// if not Yelena or not IsOk ( Yelena ) then
15229: LD_EXP 13
15233: NOT
15234: PUSH
15235: LD_EXP 13
15239: PPUSH
15240: CALL_OW 302
15244: NOT
15245: OR
15246: IFFALSE 15344
// begin SetSide ( Xavier , side_Ar ) ;
15248: LD_EXP 25
15252: PPUSH
15253: LD_EXP 4
15257: PPUSH
15258: CALL_OW 235
// PlaceUnitXYR ( Xavier , GetX ( Burlak ) , GetY ( Burlak ) , 6 , true ) ;
15262: LD_EXP 25
15266: PPUSH
15267: LD_EXP 10
15271: PPUSH
15272: CALL_OW 250
15276: PPUSH
15277: LD_EXP 10
15281: PPUSH
15282: CALL_OW 251
15286: PPUSH
15287: LD_INT 6
15289: PPUSH
15290: LD_INT 1
15292: PPUSH
15293: CALL_OW 50
// Wait ( 0 0$4 ) ;
15297: LD_INT 140
15299: PPUSH
15300: CALL_OW 67
// ComAttackUnit ( Xavier , Burlak ) ;
15304: LD_EXP 25
15308: PPUSH
15309: LD_EXP 10
15313: PPUSH
15314: CALL_OW 115
// if Difficulty = 3 then
15318: LD_OWVAR 67
15322: PUSH
15323: LD_INT 3
15325: EQUAL
15326: IFFALSE 15342
// PriorityAttack ( side_Ar , Burlak ) ;
15328: LD_EXP 4
15332: PPUSH
15333: LD_EXP 10
15337: PPUSH
15338: CALL_OW 470
// exit ;
15342: GO 15584
// end ; PlaceUnitXYR ( Xavier , GetX ( Yelena ) , GetY ( Yelena ) , 6 , true ) ;
15344: LD_EXP 25
15348: PPUSH
15349: LD_EXP 13
15353: PPUSH
15354: CALL_OW 250
15358: PPUSH
15359: LD_EXP 13
15363: PPUSH
15364: CALL_OW 251
15368: PPUSH
15369: LD_INT 6
15371: PPUSH
15372: LD_INT 1
15374: PPUSH
15375: CALL_OW 50
// ComHold ( Xavier ) ;
15379: LD_EXP 25
15383: PPUSH
15384: CALL_OW 140
// Wait ( 0 0$4 ) ;
15388: LD_INT 140
15390: PPUSH
15391: CALL_OW 67
// if not IsInUnit ( Yelena ) then
15395: LD_EXP 13
15399: PPUSH
15400: CALL_OW 310
15404: NOT
15405: IFFALSE 15421
// ComTurnUnit ( Yelena , Xavier ) ;
15407: LD_EXP 13
15411: PPUSH
15412: LD_EXP 25
15416: PPUSH
15417: CALL_OW 119
// ComTurnUnit ( Xavier , Yelena ) ;
15421: LD_EXP 25
15425: PPUSH
15426: LD_EXP 13
15430: PPUSH
15431: CALL_OW 119
// DialogueOn ;
15435: CALL_OW 6
// CenterOnUnits ( Yelena ) ;
15439: LD_EXP 13
15443: PPUSH
15444: CALL_OW 85
// dialog_MeetXavier ;
15448: CALL 21691 0 0
// Vysledek = query_Xavier ;
15452: LD_ADDR_VAR 0 2
15456: PUSH
15457: CALL 21735 0 0
15461: ST_TO_ADDR
// if Vysledek = 1 then
15462: LD_VAR 0 2
15466: PUSH
15467: LD_INT 1
15469: EQUAL
15470: IFFALSE 15496
// begin dialog_QrXavier1 ;
15472: CALL 21756 0 0
// SetSide ( Xavier , side_Ru ) ;
15476: LD_EXP 25
15480: PPUSH
15481: LD_EXP 2
15485: PPUSH
15486: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
15490: CALL 16860 0 0
// end else
15494: GO 15580
// begin SA_LieXavier ;
15496: CALL 22906 0 0
// dialog_QrXavier2 ;
15500: CALL 21889 0 0
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
15504: LD_EXP 25
15508: PPUSH
15509: LD_INT 35
15511: PPUSH
15512: LD_INT 350
15514: PPUSH
15515: CALL_OW 12
15519: PPUSH
15520: CALL_OW 142
// if Prob ( 50 ) then
15524: LD_INT 50
15526: PPUSH
15527: CALL_OW 13
15531: IFFALSE 15565
// begin AddComMoveToArea ( Xavier , DropBox ) ;
15533: LD_EXP 25
15537: PPUSH
15538: LD_INT 11
15540: PPUSH
15541: CALL_OW 173
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$15 ) ) ;
15545: LD_EXP 25
15549: PPUSH
15550: LD_INT 175
15552: PPUSH
15553: LD_INT 525
15555: PPUSH
15556: CALL_OW 12
15560: PPUSH
15561: CALL_OW 202
// end ; AddComMoveToArea ( Xavier , AraboveParkoviste ) ;
15565: LD_EXP 25
15569: PPUSH
15570: LD_INT 18
15572: PPUSH
15573: CALL_OW 173
// enable ( 21 ) ;
15577: LD_INT 21
15579: ENABLE_MARKED
// end ; DialogueOff ;
15580: CALL_OW 7
// end ;
15584: LD_VAR 0 1
15588: RET
// function xavier_kolecko ; begin
15589: LD_INT 0
15591: PPUSH
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15592: LD_EXP 25
15596: PPUSH
15597: LD_INT 82
15599: PPUSH
15600: LD_INT 1
15602: PPUSH
15603: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15607: LD_EXP 25
15611: PPUSH
15612: LD_INT 35
15614: PPUSH
15615: LD_INT 175
15617: PPUSH
15618: CALL_OW 12
15622: PPUSH
15623: CALL_OW 202
// AddComMoveXY ( Xavier , 72 , 7 ) ;
15627: LD_EXP 25
15631: PPUSH
15632: LD_INT 72
15634: PPUSH
15635: LD_INT 7
15637: PPUSH
15638: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15642: LD_EXP 25
15646: PPUSH
15647: LD_INT 35
15649: PPUSH
15650: LD_INT 175
15652: PPUSH
15653: CALL_OW 12
15657: PPUSH
15658: CALL_OW 202
// AddComMoveXY ( Xavier , 76 , 17 ) ;
15662: LD_EXP 25
15666: PPUSH
15667: LD_INT 76
15669: PPUSH
15670: LD_INT 17
15672: PPUSH
15673: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15677: LD_EXP 25
15681: PPUSH
15682: LD_INT 35
15684: PPUSH
15685: LD_INT 175
15687: PPUSH
15688: CALL_OW 12
15692: PPUSH
15693: CALL_OW 202
// AddComMoveXY ( Xavier , 85 , 17 ) ;
15697: LD_EXP 25
15701: PPUSH
15702: LD_INT 85
15704: PPUSH
15705: LD_INT 17
15707: PPUSH
15708: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15712: LD_EXP 25
15716: PPUSH
15717: LD_INT 35
15719: PPUSH
15720: LD_INT 175
15722: PPUSH
15723: CALL_OW 12
15727: PPUSH
15728: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 14 ) ;
15732: LD_EXP 25
15736: PPUSH
15737: LD_INT 91
15739: PPUSH
15740: LD_INT 14
15742: PPUSH
15743: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$5 , 0 0$10 ) ) ;
15747: LD_EXP 25
15751: PPUSH
15752: LD_INT 175
15754: PPUSH
15755: LD_INT 350
15757: PPUSH
15758: CALL_OW 12
15762: PPUSH
15763: CALL_OW 202
// AddComMoveXY ( Xavier , 89 , 24 ) ;
15767: LD_EXP 25
15771: PPUSH
15772: LD_INT 89
15774: PPUSH
15775: LD_INT 24
15777: PPUSH
15778: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15782: LD_EXP 25
15786: PPUSH
15787: LD_INT 35
15789: PPUSH
15790: LD_INT 175
15792: PPUSH
15793: CALL_OW 12
15797: PPUSH
15798: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 21 ) ;
15802: LD_EXP 25
15806: PPUSH
15807: LD_INT 102
15809: PPUSH
15810: LD_INT 21
15812: PPUSH
15813: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15817: LD_EXP 25
15821: PPUSH
15822: LD_INT 35
15824: PPUSH
15825: LD_INT 175
15827: PPUSH
15828: CALL_OW 12
15832: PPUSH
15833: CALL_OW 202
// AddComMoveXY ( Xavier , 102 , 8 ) ;
15837: LD_EXP 25
15841: PPUSH
15842: LD_INT 102
15844: PPUSH
15845: LD_INT 8
15847: PPUSH
15848: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$0.1 , 0 0$2 ) ) ;
15852: LD_EXP 25
15856: PPUSH
15857: LD_INT 4
15859: PPUSH
15860: LD_INT 70
15862: PPUSH
15863: CALL_OW 12
15867: PPUSH
15868: CALL_OW 202
// AddComMoveXY ( Xavier , 91 , 5 ) ;
15872: LD_EXP 25
15876: PPUSH
15877: LD_INT 91
15879: PPUSH
15880: LD_INT 5
15882: PPUSH
15883: CALL_OW 171
// AddComWait ( Xavier , Rand ( 0 0$1 , 0 0$5 ) ) ;
15887: LD_EXP 25
15891: PPUSH
15892: LD_INT 35
15894: PPUSH
15895: LD_INT 175
15897: PPUSH
15898: CALL_OW 12
15902: PPUSH
15903: CALL_OW 202
// AddComMoveXY ( Xavier , 82 , 1 ) ;
15907: LD_EXP 25
15911: PPUSH
15912: LD_INT 82
15914: PPUSH
15915: LD_INT 1
15917: PPUSH
15918: CALL_OW 171
// end ;
15922: LD_VAR 0 1
15926: RET
// function xavier_u_arabu ; begin
15927: LD_INT 0
15929: PPUSH
// xavier_kolecko ;
15930: CALL 15589 0 0
// enable ( 22 ) ;
15934: LD_INT 22
15936: ENABLE_MARKED
// end ;
15937: LD_VAR 0 1
15941: RET
// function xavier_timeout ; begin
15942: LD_INT 0
15944: PPUSH
// ComMoveToArea ( Xavier , DropBox ) ;
15945: LD_EXP 25
15949: PPUSH
15950: LD_INT 11
15952: PPUSH
15953: CALL_OW 113
// enable ( 23 ) ;
15957: LD_INT 23
15959: ENABLE_MARKED
// end ;
15960: LD_VAR 0 1
15964: RET
// function xavier_dropbox ; begin
15965: LD_INT 0
15967: PPUSH
// InGameOn ;
15968: CALL_OW 8
// CenterOnUnits ( Xavier ) ;
15972: LD_EXP 25
15976: PPUSH
15977: CALL_OW 85
// dialog_PointXavier ;
15981: CALL 22046 0 0
// SetAreaMapShow ( DropBoxShow , 1 ) ;
15985: LD_INT 42
15987: PPUSH
15988: LD_INT 1
15990: PPUSH
15991: CALL_OW 424
// Hint ( Xavier ) ;
15995: LD_STRING Xavier
15997: PPUSH
15998: CALL_OW 339
// ComWait ( Xavier , Rand ( 0 0$1 , 0 0$10 ) ) ;
16002: LD_EXP 25
16006: PPUSH
16007: LD_INT 35
16009: PPUSH
16010: LD_INT 350
16012: PPUSH
16013: CALL_OW 12
16017: PPUSH
16018: CALL_OW 142
// xavier_kolecko ;
16022: CALL 15589 0 0
// enable ( 24 ) ;
16026: LD_INT 24
16028: ENABLE_MARKED
// InGameOff ;
16029: CALL_OW 9
// end ;
16033: LD_VAR 0 1
16037: RET
// function xavier_zpatky ; var Depoty , Kdo ; begin
16038: LD_INT 0
16040: PPUSH
16041: PPUSH
16042: PPUSH
// Kdo = IsInUnit ( Xavier ) ;
16043: LD_ADDR_VAR 0 3
16047: PUSH
16048: LD_EXP 25
16052: PPUSH
16053: CALL_OW 310
16057: ST_TO_ADDR
// if not Kdo then
16058: LD_VAR 0 3
16062: NOT
16063: IFFALSE 16075
// Kdo = Xavier ;
16065: LD_ADDR_VAR 0 3
16069: PUSH
16070: LD_EXP 25
16074: ST_TO_ADDR
// ComAgressiveMove ( Kdo , 32 , 19 ) ;
16075: LD_VAR 0 3
16079: PPUSH
16080: LD_INT 32
16082: PPUSH
16083: LD_INT 19
16085: PPUSH
16086: CALL_OW 114
// if VsevSaved then
16090: LD_EXP 8
16094: IFFALSE 16106
// KamArea = YashinCil1 else
16096: LD_ADDR_LOC 37
16100: PUSH
16101: LD_INT 31
16103: ST_TO_ADDR
16104: GO 16114
// KamArea = YashinCil1a ;
16106: LD_ADDR_LOC 37
16110: PUSH
16111: LD_INT 32
16113: ST_TO_ADDR
// AddComMoveToArea ( Kdo , KamArea ) ;
16114: LD_VAR 0 3
16118: PPUSH
16119: LD_LOC 37
16123: PPUSH
16124: CALL_OW 173
// AddComSailEvent ( Kdo , 121 ) ;
16128: LD_VAR 0 3
16132: PPUSH
16133: LD_INT 121
16135: PPUSH
16136: CALL_OW 224
// VraciSe = true ;
16140: LD_ADDR_LOC 38
16144: PUSH
16145: LD_INT 1
16147: ST_TO_ADDR
// end ;
16148: LD_VAR 0 1
16152: RET
// function xavier_autak ; begin
16153: LD_INT 0
16155: PPUSH
// Krade = true ;
16156: LD_ADDR_LOC 39
16160: PUSH
16161: LD_INT 1
16163: ST_TO_ADDR
// Nastupuje = false ;
16164: LD_ADDR_LOC 40
16168: PUSH
16169: LD_INT 0
16171: ST_TO_ADDR
// enable ( 26 ) ;
16172: LD_INT 26
16174: ENABLE_MARKED
// end ;
16175: LD_VAR 0 1
16179: RET
// function xavier_zkus_krast ; var Volne , Ridic ; begin
16180: LD_INT 0
16182: PPUSH
16183: PPUSH
16184: PPUSH
// Volne = FilterUnitsInArea ( AraboveParkoviste , [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_OK ] ] ) ;
16185: LD_ADDR_VAR 0 2
16189: PUSH
16190: LD_INT 18
16192: PPUSH
16193: LD_INT 22
16195: PUSH
16196: LD_EXP 4
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: PUSH
16205: LD_INT 21
16207: PUSH
16208: LD_INT 2
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PUSH
16215: LD_INT 33
16217: PUSH
16218: LD_INT 1
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: PUSH
16225: LD_INT 50
16227: PUSH
16228: EMPTY
16229: LIST
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: PPUSH
16237: CALL_OW 70
16241: ST_TO_ADDR
// Volne = Volne diff UnitFilter ( Volne , [ [ F_WEAPON , AR_CONTROL_TOWER ] ] ) ;
16242: LD_ADDR_VAR 0 2
16246: PUSH
16247: LD_VAR 0 2
16251: PUSH
16252: LD_VAR 0 2
16256: PPUSH
16257: LD_INT 34
16259: PUSH
16260: LD_INT 31
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: PUSH
16267: EMPTY
16268: LIST
16269: PPUSH
16270: CALL_OW 72
16274: DIFF
16275: ST_TO_ADDR
// if not Volne then
16276: LD_VAR 0 2
16280: NOT
16281: IFFALSE 16288
// begin enable ( 26 ) ;
16283: LD_INT 26
16285: ENABLE_MARKED
// exit ;
16286: GO 16497
// end ; Nastupuje = true ;
16288: LD_ADDR_LOC 40
16292: PUSH
16293: LD_INT 1
16295: ST_TO_ADDR
// KradenyVuz = Volne [ 1 ] ;
16296: LD_ADDR_LOC 41
16300: PUSH
16301: LD_VAR 0 2
16305: PUSH
16306: LD_INT 1
16308: ARRAY
16309: ST_TO_ADDR
// Ridic = IsDrivenBy ( KradenyVuz ) ;
16310: LD_ADDR_VAR 0 3
16314: PUSH
16315: LD_LOC 41
16319: PPUSH
16320: CALL_OW 311
16324: ST_TO_ADDR
// if Ridic then
16325: LD_VAR 0 3
16329: IFFALSE 16352
// begin ComExitVehicle ( Ridic ) ;
16331: LD_VAR 0 3
16335: PPUSH
16336: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16340: LD_VAR 0 3
16344: PPUSH
16345: LD_INT 175
16347: PPUSH
16348: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16352: LD_EXP 25
16356: PPUSH
16357: LD_LOC 41
16361: PPUSH
16362: CALL_OW 120
// Wait ( 0 0$3.2 ) ;
16366: LD_INT 112
16368: PPUSH
16369: CALL_OW 67
// while Xavier <> IsDrivenBy ( KradenyVuz ) do
16373: LD_EXP 25
16377: PUSH
16378: LD_LOC 41
16382: PPUSH
16383: CALL_OW 311
16387: NONEQUAL
16388: IFFALSE 16469
// begin Ridic = IsDrivenBy ( KradenyVuz ) ;
16390: LD_ADDR_VAR 0 3
16394: PUSH
16395: LD_LOC 41
16399: PPUSH
16400: CALL_OW 311
16404: ST_TO_ADDR
// if Ridic = Xavier then
16405: LD_VAR 0 3
16409: PUSH
16410: LD_EXP 25
16414: EQUAL
16415: IFFALSE 16419
// break ;
16417: GO 16469
// if Ridic then
16419: LD_VAR 0 3
16423: IFFALSE 16446
// begin ComExitVehicle ( Ridic ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: CALL_OW 121
// AddComWait ( Ridic , 0 0$5 ) ;
16434: LD_VAR 0 3
16438: PPUSH
16439: LD_INT 175
16441: PPUSH
16442: CALL_OW 202
// end ; ComEnterUnit ( Xavier , KradenyVuz ) ;
16446: LD_EXP 25
16450: PPUSH
16451: LD_LOC 41
16455: PPUSH
16456: CALL_OW 120
// Wait ( 0 0$7.1 ) ;
16460: LD_INT 248
16462: PPUSH
16463: CALL_OW 67
// end ;
16467: GO 16373
// Krade = false ;
16469: LD_ADDR_LOC 39
16473: PUSH
16474: LD_INT 0
16476: ST_TO_ADDR
// Nastupuje = false ;
16477: LD_ADDR_LOC 40
16481: PUSH
16482: LD_INT 0
16484: ST_TO_ADDR
// xavier_zpatky ;
16485: CALL 16038 0 0
// KradenyVuz = 0 ;
16489: LD_ADDR_LOC 41
16493: PUSH
16494: LD_INT 0
16496: ST_TO_ADDR
// end ;
16497: LD_VAR 0 1
16501: RET
// every 0 0$11.7 marked 26 do
16502: GO 16504
16504: DISABLE
// begin xavier_zkus_krast ;
16505: CALL 16180 0 0
// end ;
16509: END
// function xavier_zprava ; var Vysledek ; begin
16510: LD_INT 0
16512: PPUSH
16513: PPUSH
// DialogueOn ;
16514: CALL_OW 6
// Vysledek = query_QActivateXavier ;
16518: LD_ADDR_VAR 0 2
16522: PUSH
16523: CALL 22101 0 0
16527: ST_TO_ADDR
// case Vysledek of 1 :
16528: LD_VAR 0 2
16532: PUSH
16533: LD_INT 1
16535: DOUBLE
16536: EQUAL
16537: IFTRUE 16541
16539: GO 16570
16541: POP
// begin dialog_QrActivateXavier1 ;
16542: CALL 22122 0 0
// xavier_zpatky ;
16546: CALL 16038 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16550: LD_INT 42
16552: PPUSH
16553: LD_INT 0
16555: PPUSH
16556: CALL_OW 424
// Result = true ;
16560: LD_ADDR_VAR 0 1
16564: PUSH
16565: LD_INT 1
16567: ST_TO_ADDR
// end ; 2 :
16568: GO 16616
16570: LD_INT 2
16572: DOUBLE
16573: EQUAL
16574: IFTRUE 16578
16576: GO 16607
16578: POP
// begin dialog_QrActivateXavier2 ;
16579: CALL 22142 0 0
// xavier_autak ;
16583: CALL 16153 0 0
// SetAreaMapShow ( DropBoxShow , 0 ) ;
16587: LD_INT 42
16589: PPUSH
16590: LD_INT 0
16592: PPUSH
16593: CALL_OW 424
// Result = true ;
16597: LD_ADDR_VAR 0 1
16601: PUSH
16602: LD_INT 1
16604: ST_TO_ADDR
// end ; else
16605: GO 16616
16607: POP
// Result = false ; end ;
16608: LD_ADDR_VAR 0 1
16612: PUSH
16613: LD_INT 0
16615: ST_TO_ADDR
// DialogueOff ;
16616: CALL_OW 7
// end ;
16620: LD_VAR 0 1
16624: RET
// export function xavier_prisel ; var Autak ; begin
16625: LD_INT 0
16627: PPUSH
16628: PPUSH
// VraciSe = false ;
16629: LD_ADDR_LOC 38
16633: PUSH
16634: LD_INT 0
16636: ST_TO_ADDR
// Autak = IsInUnit ( Xavier ) ;
16637: LD_ADDR_VAR 0 2
16641: PUSH
16642: LD_EXP 25
16646: PPUSH
16647: CALL_OW 310
16651: ST_TO_ADDR
// if Autak then
16652: LD_VAR 0 2
16656: IFFALSE 16672
// SetSide ( Autak , side_Ru ) ;
16658: LD_VAR 0 2
16662: PPUSH
16663: LD_EXP 2
16667: PPUSH
16668: CALL_OW 235
// SetSide ( Xavier , side_Ru ) ;
16672: LD_EXP 25
16676: PPUSH
16677: LD_EXP 2
16681: PPUSH
16682: CALL_OW 235
// zkopiruj_xaviera_jako_rus ;
16686: CALL 16860 0 0
// end ;
16690: LD_VAR 0 1
16694: RET
// every 0 0$2.7 trigger IsInArea ( Xavier , AraboveParkoviste ) marked 21 do
16695: LD_EXP 25
16699: PPUSH
16700: LD_INT 18
16702: PPUSH
16703: CALL_OW 308
16707: IFFALSE 16716
16709: GO 16711
16711: DISABLE
// begin xavier_u_arabu ;
16712: CALL 15927 0 0
// end ;
16716: END
// every 1 1$0 marked 22 do
16717: GO 16719
16719: DISABLE
// begin Wait ( Rand ( 0 0$1 , 6 6$0 ) ) ;
16720: LD_INT 35
16722: PPUSH
16723: LD_INT 12600
16725: PPUSH
16726: CALL_OW 12
16730: PPUSH
16731: CALL_OW 67
// xavier_timeout ;
16735: CALL 15942 0 0
// end ;
16739: END
// every 0 0$4.2 trigger IsInArea ( Xavier , DropBox ) marked 23 do
16740: LD_EXP 25
16744: PPUSH
16745: LD_INT 11
16747: PPUSH
16748: CALL_OW 308
16752: IFFALSE 16761
16754: GO 16756
16756: DISABLE
// begin ; xavier_dropbox ;
16757: CALL 15965 0 0
// end ;
16761: END
// every 0 0$3.7 trigger FilterUnitsInArea ( DropBox , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) marked 24 do
16762: LD_INT 11
16764: PPUSH
16765: LD_INT 22
16767: PUSH
16768: LD_EXP 2
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PUSH
16777: LD_INT 50
16779: PUSH
16780: EMPTY
16781: LIST
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PPUSH
16787: CALL_OW 70
16791: IFFALSE 16811
16793: GO 16795
16795: DISABLE
// begin if not xavier_zprava then
16796: CALL 16510 0 0
16800: NOT
16801: IFFALSE 16811
// begin Wait ( 1 1$0 ) ;
16803: LD_INT 2100
16805: PPUSH
16806: CALL_OW 67
// enable ;
16810: ENABLE
// end ; end ;
16811: END
// export function event_XavierPrisel ; begin
16812: LD_INT 0
16814: PPUSH
// xavier_prisel ;
16815: CALL 16625 0 0
// end ;
16819: LD_VAR 0 1
16823: RET
// export function xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
16824: LD_INT 0
16826: PPUSH
// if Nastupuje and ( VehOld = KradenyVuz ) then
16827: LD_LOC 40
16831: PUSH
16832: LD_VAR 0 2
16836: PUSH
16837: LD_LOC 41
16841: EQUAL
16842: AND
16843: IFFALSE 16855
// KradenyVuz = VehNew ;
16845: LD_ADDR_LOC 41
16849: PUSH
16850: LD_VAR 0 1
16854: ST_TO_ADDR
// end ;
16855: LD_VAR 0 5
16859: RET
// function zkopiruj_xaviera_jako_rus ; var Xav , X , Y , Dir , InUnit ; begin
16860: LD_INT 0
16862: PPUSH
16863: PPUSH
16864: PPUSH
16865: PPUSH
16866: PPUSH
16867: PPUSH
// X = GetX ( Xavier ) ;
16868: LD_ADDR_VAR 0 3
16872: PUSH
16873: LD_EXP 25
16877: PPUSH
16878: CALL_OW 250
16882: ST_TO_ADDR
// Y = GetY ( Xavier ) ;
16883: LD_ADDR_VAR 0 4
16887: PUSH
16888: LD_EXP 25
16892: PPUSH
16893: CALL_OW 251
16897: ST_TO_ADDR
// Dir = GetDir ( Xavier ) ;
16898: LD_ADDR_VAR 0 5
16902: PUSH
16903: LD_EXP 25
16907: PPUSH
16908: CALL_OW 254
16912: ST_TO_ADDR
// InUnit = IsInUnit ( Xavier ) ;
16913: LD_ADDR_VAR 0 6
16917: PUSH
16918: LD_EXP 25
16922: PPUSH
16923: CALL_OW 310
16927: ST_TO_ADDR
// RemoveUnit ( Xavier ) ;
16928: LD_EXP 25
16932: PPUSH
16933: CALL_OW 64
// PrepareNewCharacter ( Xavier ) ;
16937: LD_STRING Xavier
16939: PPUSH
16940: CALL_OW 26
// UC_Side = side_Ru ;
16944: LD_ADDR_OWVAR 20
16948: PUSH
16949: LD_EXP 2
16953: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
16954: LD_ADDR_OWVAR 21
16958: PUSH
16959: LD_INT 3
16961: ST_TO_ADDR
// UC_Placed = false ;
16962: LD_ADDR_OWVAR 25
16966: PUSH
16967: LD_INT 0
16969: ST_TO_ADDR
// Xav = CreateHuman ;
16970: LD_ADDR_VAR 0 2
16974: PUSH
16975: CALL_OW 44
16979: ST_TO_ADDR
// SetLives ( Xav , GetLives ( Xavier ) ) ;
16980: LD_VAR 0 2
16984: PPUSH
16985: LD_EXP 25
16989: PPUSH
16990: CALL_OW 256
16994: PPUSH
16995: CALL_OW 234
// DestroyUnit ( Xavier ) ;
16999: LD_EXP 25
17003: PPUSH
17004: CALL_OW 65
// Xavier = Xav ;
17008: LD_ADDR_EXP 25
17012: PUSH
17013: LD_VAR 0 2
17017: ST_TO_ADDR
// if InUnit then
17018: LD_VAR 0 6
17022: IFFALSE 17040
// PlaceHumanInUnit ( Xavier , InUnit ) else
17024: LD_EXP 25
17028: PPUSH
17029: LD_VAR 0 6
17033: PPUSH
17034: CALL_OW 52
17038: GO 17076
// begin PlaceUnitXY ( Xavier , X , Y , false ) ;
17040: LD_EXP 25
17044: PPUSH
17045: LD_VAR 0 3
17049: PPUSH
17050: LD_VAR 0 4
17054: PPUSH
17055: LD_INT 0
17057: PPUSH
17058: CALL_OW 48
// SetDir ( Xavier , Dir ) ;
17062: LD_EXP 25
17066: PPUSH
17067: LD_VAR 0 5
17071: PPUSH
17072: CALL_OW 233
// end ; end ; end_of_file
17076: LD_VAR 0 1
17080: RET
// var Uniky ; var HeikeVytvorena ; var HeikeUtika ; var HeikeJdeKam ; var Start_Budovy , Start_Auta , Start_Lidi ; var Registry , Makro ; var HeikeVCervenem ; var Zajmuta ; export function init_heike ; begin
17081: LD_INT 0
17083: PPUSH
// disable ( 31 ) ;
17084: LD_INT 31
17086: DISABLE_MARKED
// disable ( 32 ) ;
17087: LD_INT 32
17089: DISABLE_MARKED
// Uniky = [ [ Unik1 , HeikeCil1 ] , [ Unik2 , HeikeCil2 ] , [ Unik3 , HeikeCil3 ] , [ Unik4 , HeikeCil4 ] , [ Unik5 , HeikeCil5 ] , [ Unik6 , HeikeCil6 ] , [ Unik7 , HeikeCil7 ] ] ;
17090: LD_ADDR_LOC 42
17094: PUSH
17095: LD_INT 3
17097: PUSH
17098: LD_INT 20
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: PUSH
17105: LD_INT 4
17107: PUSH
17108: LD_INT 21
17110: PUSH
17111: EMPTY
17112: LIST
17113: LIST
17114: PUSH
17115: LD_INT 5
17117: PUSH
17118: LD_INT 22
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: PUSH
17125: LD_INT 6
17127: PUSH
17128: LD_INT 23
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 7
17137: PUSH
17138: LD_INT 24
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 8
17147: PUSH
17148: LD_INT 25
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PUSH
17155: LD_INT 9
17157: PUSH
17158: LD_INT 26
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// HeikeVytvorena = false ;
17174: LD_ADDR_LOC 43
17178: PUSH
17179: LD_INT 0
17181: ST_TO_ADDR
// HeikeUtika = false ;
17182: LD_ADDR_LOC 44
17186: PUSH
17187: LD_INT 0
17189: ST_TO_ADDR
// HeikeVCervenem = false ;
17190: LD_ADDR_LOC 51
17194: PUSH
17195: LD_INT 0
17197: ST_TO_ADDR
// Zajmuta = false ;
17198: LD_ADDR_LOC 52
17202: PUSH
17203: LD_INT 0
17205: ST_TO_ADDR
// Start_Budovy = dif_HeikeBudovy [ Difficulty ] ;
17206: LD_ADDR_LOC 46
17210: PUSH
17211: LD_EXP 39
17215: PUSH
17216: LD_OWVAR 67
17220: ARRAY
17221: ST_TO_ADDR
// Start_Auta = dif_HeikeAuta [ Difficulty ] ;
17222: LD_ADDR_LOC 47
17226: PUSH
17227: LD_EXP 40
17231: PUSH
17232: LD_OWVAR 67
17236: ARRAY
17237: ST_TO_ADDR
// Start_Lidi = dif_HeikeLidi [ Difficulty ] ;
17238: LD_ADDR_LOC 48
17242: PUSH
17243: LD_EXP 41
17247: PUSH
17248: LD_OWVAR 67
17252: ARRAY
17253: ST_TO_ADDR
// end ;
17254: LD_VAR 0 1
17258: RET
// function vytvor_heike ; var I ; begin
17259: LD_INT 0
17261: PPUSH
17262: PPUSH
// Heike = NewCharacter ( Heike ) ;
17263: LD_ADDR_EXP 26
17267: PUSH
17268: LD_STRING Heike
17270: PPUSH
17271: CALL_OW 25
17275: ST_TO_ADDR
// SetSide ( Heike , side_Heike ) ;
17276: LD_EXP 26
17280: PPUSH
17281: LD_EXP 6
17285: PPUSH
17286: CALL_OW 235
// Heikeovci = [ ] ;
17290: LD_ADDR_EXP 27
17294: PUSH
17295: EMPTY
17296: ST_TO_ADDR
// InitHC ;
17297: CALL_OW 19
// InitUC ;
17301: CALL_OW 18
// UC_Side = side_Strazci ;
17305: LD_ADDR_OWVAR 20
17309: PUSH
17310: LD_EXP 7
17314: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
17315: LD_ADDR_OWVAR 21
17319: PUSH
17320: LD_INT 2
17322: ST_TO_ADDR
// HC_Name =  ;
17323: LD_ADDR_OWVAR 26
17327: PUSH
17328: LD_STRING 
17330: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
17331: LD_ADDR_OWVAR 28
17335: PUSH
17336: LD_INT 1
17338: ST_TO_ADDR
// UC_Placed = false ;
17339: LD_ADDR_OWVAR 25
17343: PUSH
17344: LD_INT 0
17346: ST_TO_ADDR
// PrepareSoldierSkills ( 5 ) ;
17347: LD_INT 5
17349: PPUSH
17350: CALL_OW 375
// for I = 1 to dif_HeikeovciPocet [ Difficulty ] do
17354: LD_ADDR_VAR 0 2
17358: PUSH
17359: DOUBLE
17360: LD_INT 1
17362: DEC
17363: ST_TO_ADDR
17364: LD_EXP 43
17368: PUSH
17369: LD_OWVAR 67
17373: ARRAY
17374: PUSH
17375: FOR_TO
17376: IFFALSE 17415
// begin HC_Sex = Rand ( 1 , 2 ) ;
17378: LD_ADDR_OWVAR 27
17382: PUSH
17383: LD_INT 1
17385: PPUSH
17386: LD_INT 2
17388: PPUSH
17389: CALL_OW 12
17393: ST_TO_ADDR
// Heikeovci = Heikeovci union [ CreateHuman ] ;
17394: LD_ADDR_EXP 27
17398: PUSH
17399: LD_EXP 27
17403: PUSH
17404: CALL_OW 44
17408: PUSH
17409: EMPTY
17410: LIST
17411: UNION
17412: ST_TO_ADDR
// end ;
17413: GO 17375
17415: POP
17416: POP
// Heikeovci = Heikeovci diff [ 0 ] ;
17417: LD_ADDR_EXP 27
17421: PUSH
17422: LD_EXP 27
17426: PUSH
17427: LD_INT 0
17429: PUSH
17430: EMPTY
17431: LIST
17432: DIFF
17433: ST_TO_ADDR
// SetLives ( Heikeovci , dif_HeikeovciLives [ Difficulty ] ) ;
17434: LD_EXP 27
17438: PPUSH
17439: LD_EXP 42
17443: PUSH
17444: LD_OWVAR 67
17448: ARRAY
17449: PPUSH
17450: CALL_OW 234
// end ;
17454: LD_VAR 0 1
17458: RET
// function heike_do_zakladny ; begin
17459: LD_INT 0
17461: PPUSH
// AddComMoveXY ( Heike , 87 , 120 ) ;
17462: LD_EXP 26
17466: PPUSH
17467: LD_INT 87
17469: PPUSH
17470: LD_INT 120
17472: PPUSH
17473: CALL_OW 171
// AddComMoveXY ( Heike , 83 , 114 ) ;
17477: LD_EXP 26
17481: PPUSH
17482: LD_INT 83
17484: PPUSH
17485: LD_INT 114
17487: PPUSH
17488: CALL_OW 171
// AddComMoveXY ( Heike , 74 , 97 ) ;
17492: LD_EXP 26
17496: PPUSH
17497: LD_INT 74
17499: PPUSH
17500: LD_INT 97
17502: PPUSH
17503: CALL_OW 171
// AddComMoveXY ( Heike , 66 , 78 ) ;
17507: LD_EXP 26
17511: PPUSH
17512: LD_INT 66
17514: PPUSH
17515: LD_INT 78
17517: PPUSH
17518: CALL_OW 171
// if VsevSaved then
17522: LD_EXP 8
17526: IFFALSE 17575
// begin AddComMoveXY ( Heike , 61 , 70 ) ;
17528: LD_EXP 26
17532: PPUSH
17533: LD_INT 61
17535: PPUSH
17536: LD_INT 70
17538: PPUSH
17539: CALL_OW 171
// AddComMoveXY ( Heike , 56 , 59 ) ;
17543: LD_EXP 26
17547: PPUSH
17548: LD_INT 56
17550: PPUSH
17551: LD_INT 59
17553: PPUSH
17554: CALL_OW 171
// AddComMoveXY ( Heike , 44 , 44 ) ;
17558: LD_EXP 26
17562: PPUSH
17563: LD_INT 44
17565: PPUSH
17566: LD_INT 44
17568: PPUSH
17569: CALL_OW 171
// end else
17573: GO 17650
// begin AddComMoveXY ( Heike , 44 , 73 ) ;
17575: LD_EXP 26
17579: PPUSH
17580: LD_INT 44
17582: PPUSH
17583: LD_INT 73
17585: PPUSH
17586: CALL_OW 171
// AddComMoveXY ( Heike , 36 , 65 ) ;
17590: LD_EXP 26
17594: PPUSH
17595: LD_INT 36
17597: PPUSH
17598: LD_INT 65
17600: PPUSH
17601: CALL_OW 171
// AddComMoveXY ( Heike , 47 , 59 ) ;
17605: LD_EXP 26
17609: PPUSH
17610: LD_INT 47
17612: PPUSH
17613: LD_INT 59
17615: PPUSH
17616: CALL_OW 171
// AddComMoveXY ( Heike , 28 , 51 ) ;
17620: LD_EXP 26
17624: PPUSH
17625: LD_INT 28
17627: PPUSH
17628: LD_INT 51
17630: PPUSH
17631: CALL_OW 171
// AddComMoveXY ( Heike , 29 , 42 ) ;
17635: LD_EXP 26
17639: PPUSH
17640: LD_INT 29
17642: PPUSH
17643: LD_INT 42
17645: PPUSH
17646: CALL_OW 171
// end ; AddComMoveXY ( Heike , 40 , 37 ) ;
17650: LD_EXP 26
17654: PPUSH
17655: LD_INT 40
17657: PPUSH
17658: LD_INT 37
17660: PPUSH
17661: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 22 ) ;
17665: LD_EXP 26
17669: PPUSH
17670: LD_INT 33
17672: PPUSH
17673: LD_INT 22
17675: PPUSH
17676: CALL_OW 171
// AddComMoveXY ( Heike , 33 , 16 ) ;
17680: LD_EXP 26
17684: PPUSH
17685: LD_INT 33
17687: PPUSH
17688: LD_INT 16
17690: PPUSH
17691: CALL_OW 171
// AddComMoveXY ( Heike , 38 , 13 ) ;
17695: LD_EXP 26
17699: PPUSH
17700: LD_INT 38
17702: PPUSH
17703: LD_INT 13
17705: PPUSH
17706: CALL_OW 171
// AddComMoveXY ( Heike , 46 , 13 ) ;
17710: LD_EXP 26
17714: PPUSH
17715: LD_INT 46
17717: PPUSH
17718: LD_INT 13
17720: PPUSH
17721: CALL_OW 171
// AddComMoveXY ( Heike , 54 , 16 ) ;
17725: LD_EXP 26
17729: PPUSH
17730: LD_INT 54
17732: PPUSH
17733: LD_INT 16
17735: PPUSH
17736: CALL_OW 171
// AddComMoveXY ( Heike , 62 , 15 ) ;
17740: LD_EXP 26
17744: PPUSH
17745: LD_INT 62
17747: PPUSH
17748: LD_INT 15
17750: PPUSH
17751: CALL_OW 171
// AddComMoveXY ( Heike , 73 , 14 ) ;
17755: LD_EXP 26
17759: PPUSH
17760: LD_INT 73
17762: PPUSH
17763: LD_INT 14
17765: PPUSH
17766: CALL_OW 171
// AddComMoveXY ( Heike , 91 , 13 ) ;
17770: LD_EXP 26
17774: PPUSH
17775: LD_INT 91
17777: PPUSH
17778: LD_INT 13
17780: PPUSH
17781: CALL_OW 171
// AddComMoveToArea ( Heike , HeikeCil ) ;
17785: LD_EXP 26
17789: PPUSH
17790: LD_INT 27
17792: PPUSH
17793: CALL_OW 173
// end ;
17797: LD_VAR 0 1
17801: RET
// function heike_start ; var Auto ; begin
17802: LD_INT 0
17804: PPUSH
17805: PPUSH
// if GetSide ( Xavier ) <> side_Ru then
17806: LD_EXP 25
17810: PPUSH
17811: CALL_OW 255
17815: PUSH
17816: LD_EXP 2
17820: NONEQUAL
17821: IFFALSE 17827
// xavier_prisel ;
17823: CALL 16625 0 0
// vytvor_heike ;
17827: CALL 17259 0 0
// PlaceUnitArea ( Heike , HeikeStart , false ) ;
17831: LD_EXP 26
17835: PPUSH
17836: LD_INT 19
17838: PPUSH
17839: LD_INT 0
17841: PPUSH
17842: CALL_OW 49
// place_list ( Heikeovci , HeikeStart ) ;
17846: LD_EXP 27
17850: PPUSH
17851: LD_INT 19
17853: PPUSH
17854: CALL 20678 0 2
// Wait ( Rand ( 0 0$1 , 0 0$5 ) ) ;
17858: LD_INT 35
17860: PPUSH
17861: LD_INT 175
17863: PPUSH
17864: CALL_OW 12
17868: PPUSH
17869: CALL_OW 67
// Registry = McRegistry ( side_Heike , [ [ MC_REG_UNITS_TO_PROTECT , [ Heike ] ] ] ) ;
17873: LD_ADDR_LOC 49
17877: PUSH
17878: LD_EXP 6
17882: PPUSH
17883: LD_INT 4
17885: PUSH
17886: LD_EXP 26
17890: PUSH
17891: EMPTY
17892: LIST
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: PUSH
17898: EMPTY
17899: LIST
17900: PPUSH
17901: CALL_OW 399
17905: ST_TO_ADDR
// Makro = McDefend ( 0 , Registry , Heikeovci , [ ] ) ;
17906: LD_ADDR_LOC 50
17910: PUSH
17911: LD_INT 0
17913: PPUSH
17914: LD_LOC 49
17918: PPUSH
17919: LD_EXP 27
17923: PPUSH
17924: EMPTY
17925: PPUSH
17926: CALL_OW 401
17930: ST_TO_ADDR
// DialogueOn ;
17931: CALL_OW 6
// dialog_HeikeObj ;
17935: CALL 22634 0 0
// ChangeMissionObjectives ( MHeike ) ;
17939: LD_STRING MHeike
17941: PPUSH
17942: CALL_OW 337
// Query ( QHeike ) ;
17946: LD_STRING QHeike
17948: PPUSH
17949: CALL_OW 97
// DialogueOff ;
17953: CALL_OW 7
// RevealFogArea ( side_Ru , HeikeStart ) ;
17957: LD_EXP 2
17961: PPUSH
17962: LD_INT 19
17964: PPUSH
17965: CALL_OW 332
// CenterOnUnits ( Heike ) ;
17969: LD_EXP 26
17973: PPUSH
17974: CALL_OW 85
// heike_do_zakladny ;
17978: CALL 17459 0 0
// ComMoveUnit ( Heikeovci , Heike ) ;
17982: LD_EXP 27
17986: PPUSH
17987: LD_EXP 26
17991: PPUSH
17992: CALL_OW 112
// enable ( 32 ) ;
17996: LD_INT 32
17998: ENABLE_MARKED
// end ;
17999: LD_VAR 0 1
18003: RET
// function heike_kontrola_start ; var Budovy , Auta , Lidi ; begin
18004: LD_INT 0
18006: PPUSH
18007: PPUSH
18008: PPUSH
18009: PPUSH
// if HeikeVytvorena then
18010: LD_LOC 43
18014: IFFALSE 18018
// exit ;
18016: GO 18231
// Budovy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18018: LD_ADDR_VAR 0 2
18022: PUSH
18023: LD_INT 22
18025: PUSH
18026: LD_EXP 4
18030: PUSH
18031: EMPTY
18032: LIST
18033: LIST
18034: PUSH
18035: LD_INT 21
18037: PUSH
18038: LD_INT 3
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 50
18047: PUSH
18048: EMPTY
18049: LIST
18050: PUSH
18051: LD_INT 52
18053: PUSH
18054: EMPTY
18055: LIST
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PPUSH
18063: CALL_OW 69
18067: ST_TO_ADDR
// Auta = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18068: LD_ADDR_VAR 0 3
18072: PUSH
18073: LD_INT 22
18075: PUSH
18076: LD_EXP 4
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PUSH
18085: LD_INT 21
18087: PUSH
18088: LD_INT 2
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PUSH
18095: LD_INT 50
18097: PUSH
18098: EMPTY
18099: LIST
18100: PUSH
18101: LD_INT 52
18103: PUSH
18104: EMPTY
18105: LIST
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: PPUSH
18113: CALL_OW 69
18117: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_OK ] , [ F_PLACED ] ] ) ;
18118: LD_ADDR_VAR 0 4
18122: PUSH
18123: LD_INT 22
18125: PUSH
18126: LD_EXP 4
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 21
18137: PUSH
18138: LD_INT 1
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: LD_INT 50
18147: PUSH
18148: EMPTY
18149: LIST
18150: PUSH
18151: LD_INT 52
18153: PUSH
18154: EMPTY
18155: LIST
18156: PUSH
18157: EMPTY
18158: LIST
18159: LIST
18160: LIST
18161: LIST
18162: PPUSH
18163: CALL_OW 69
18167: ST_TO_ADDR
// if ( ( Budovy <= Start_Budovy ) and ( Auta <= Start_Auta ) ) or ( Lidi <= Start_Lidi ) then
18168: LD_VAR 0 2
18172: PUSH
18173: LD_LOC 46
18177: LESSEQUAL
18178: PUSH
18179: LD_VAR 0 3
18183: PUSH
18184: LD_LOC 47
18188: LESSEQUAL
18189: AND
18190: PUSH
18191: LD_VAR 0 4
18195: PUSH
18196: LD_LOC 48
18200: LESSEQUAL
18201: OR
18202: IFFALSE 18231
// begin HeikeVytvorena = true ;
18204: LD_ADDR_LOC 43
18208: PUSH
18209: LD_INT 1
18211: ST_TO_ADDR
// Wait ( Rand ( 0 0$3 , 0 0$20 ) ) ;
18212: LD_INT 105
18214: PPUSH
18215: LD_INT 700
18217: PPUSH
18218: CALL_OW 12
18222: PPUSH
18223: CALL_OW 67
// heike_start ;
18227: CALL 17802 0 0
// end ; end ;
18231: LD_VAR 0 1
18235: RET
// function je_volny_unik ( Area ) ; var KdoTam ; begin
18236: LD_INT 0
18238: PPUSH
18239: PPUSH
// KdoTam = FilterUnitsInArea ( Area , [ [ F_SIDE , side_Ru ] , [ F_OK ] ] ) ;
18240: LD_ADDR_VAR 0 3
18244: PUSH
18245: LD_VAR 0 1
18249: PPUSH
18250: LD_INT 22
18252: PUSH
18253: LD_EXP 2
18257: PUSH
18258: EMPTY
18259: LIST
18260: LIST
18261: PUSH
18262: LD_INT 50
18264: PUSH
18265: EMPTY
18266: LIST
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PPUSH
18272: CALL_OW 70
18276: ST_TO_ADDR
// if KdoTam then
18277: LD_VAR 0 3
18281: IFFALSE 18293
// Result = false else
18283: LD_ADDR_VAR 0 2
18287: PUSH
18288: LD_INT 0
18290: ST_TO_ADDR
18291: GO 18301
// Result = true ;
18293: LD_ADDR_VAR 0 2
18297: PUSH
18298: LD_INT 1
18300: ST_TO_ADDR
// end ;
18301: LD_VAR 0 2
18305: RET
// function zjisti_volne ; var Akt , Jednotky ; begin
18306: LD_INT 0
18308: PPUSH
18309: PPUSH
18310: PPUSH
// Result = [ ] ;
18311: LD_ADDR_VAR 0 1
18315: PUSH
18316: EMPTY
18317: ST_TO_ADDR
// for Akt in Uniky do
18318: LD_ADDR_VAR 0 2
18322: PUSH
18323: LD_LOC 42
18327: PUSH
18328: FOR_IN
18329: IFFALSE 18367
// begin if je_volny_unik ( Akt [ 1 ] ) then
18331: LD_VAR 0 2
18335: PUSH
18336: LD_INT 1
18338: ARRAY
18339: PPUSH
18340: CALL 18236 0 1
18344: IFFALSE 18365
// Result = Result union [ Akt ] ;
18346: LD_ADDR_VAR 0 1
18350: PUSH
18351: LD_VAR 0 1
18355: PUSH
18356: LD_VAR 0 2
18360: PUSH
18361: EMPTY
18362: LIST
18363: UNION
18364: ST_TO_ADDR
// end ;
18365: GO 18328
18367: POP
18368: POP
// end ;
18369: LD_VAR 0 1
18373: RET
// function zjisti_heike_utekla ; var Akt ; begin
18374: LD_INT 0
18376: PPUSH
18377: PPUSH
// Result = false ;
18378: LD_ADDR_VAR 0 1
18382: PUSH
18383: LD_INT 0
18385: ST_TO_ADDR
// if not IsOk ( Heike ) then
18386: LD_EXP 26
18390: PPUSH
18391: CALL_OW 302
18395: NOT
18396: IFFALSE 18400
// exit ;
18398: GO 18479
// Result = true ;
18400: LD_ADDR_VAR 0 1
18404: PUSH
18405: LD_INT 1
18407: ST_TO_ADDR
// if IsInArea ( Heike , HeikeCil ) then
18408: LD_EXP 26
18412: PPUSH
18413: LD_INT 27
18415: PPUSH
18416: CALL_OW 308
18420: IFFALSE 18424
// exit ;
18422: GO 18479
// if HeikeUtika then
18424: LD_LOC 44
18428: IFFALSE 18471
// begin for Akt in Uniky do
18430: LD_ADDR_VAR 0 2
18434: PUSH
18435: LD_LOC 42
18439: PUSH
18440: FOR_IN
18441: IFFALSE 18469
// if IsInArea ( Heike , Akt [ 2 ] ) then
18443: LD_EXP 26
18447: PPUSH
18448: LD_VAR 0 2
18452: PUSH
18453: LD_INT 2
18455: ARRAY
18456: PPUSH
18457: CALL_OW 308
18461: IFFALSE 18467
// exit ;
18463: POP
18464: POP
18465: GO 18479
18467: GO 18440
18469: POP
18470: POP
// end ; Result = false ;
18471: LD_ADDR_VAR 0 1
18475: PUSH
18476: LD_INT 0
18478: ST_TO_ADDR
// end ;
18479: LD_VAR 0 1
18483: RET
// function GetDistUnitArea2 ( Un , Area ) ; var Hex ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// Hex = RandHexArea ( Area , false ) ;
18488: LD_ADDR_VAR 0 4
18492: PUSH
18493: LD_VAR 0 2
18497: PPUSH
18498: LD_INT 0
18500: PPUSH
18501: CALL_OW 16
18505: ST_TO_ADDR
// Result = GetDistUnitXY ( Un , Hex [ 1 ] , Hex [ 2 ] ) ;
18506: LD_ADDR_VAR 0 3
18510: PUSH
18511: LD_VAR 0 1
18515: PPUSH
18516: LD_VAR 0 4
18520: PUSH
18521: LD_INT 1
18523: ARRAY
18524: PPUSH
18525: LD_VAR 0 4
18529: PUSH
18530: LD_INT 2
18532: ARRAY
18533: PPUSH
18534: CALL_OW 297
18538: ST_TO_ADDR
// end ;
18539: LD_VAR 0 3
18543: RET
// function zjisti_nejlepsi_unik ( Seznam ) ; var Min , Akt , AktDal ; begin
18544: LD_INT 0
18546: PPUSH
18547: PPUSH
18548: PPUSH
18549: PPUSH
// Result = [ ] ;
18550: LD_ADDR_VAR 0 2
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// Min = 99999 ;
18557: LD_ADDR_VAR 0 3
18561: PUSH
18562: LD_INT 99999
18564: ST_TO_ADDR
// for Akt in Seznam do
18565: LD_ADDR_VAR 0 4
18569: PUSH
18570: LD_VAR 0 1
18574: PUSH
18575: FOR_IN
18576: IFFALSE 18636
// begin AktDal = GetDistUnitArea2 ( Heike , Akt [ 1 ] ) ;
18578: LD_ADDR_VAR 0 5
18582: PUSH
18583: LD_EXP 26
18587: PPUSH
18588: LD_VAR 0 4
18592: PUSH
18593: LD_INT 1
18595: ARRAY
18596: PPUSH
18597: CALL 18484 0 2
18601: ST_TO_ADDR
// if AktDal < Min then
18602: LD_VAR 0 5
18606: PUSH
18607: LD_VAR 0 3
18611: LESS
18612: IFFALSE 18634
// begin Result = Akt ;
18614: LD_ADDR_VAR 0 2
18618: PUSH
18619: LD_VAR 0 4
18623: ST_TO_ADDR
// Min = AktDal ;
18624: LD_ADDR_VAR 0 3
18628: PUSH
18629: LD_VAR 0 5
18633: ST_TO_ADDR
// end ; end ;
18634: GO 18575
18636: POP
18637: POP
// end ;
18638: LD_VAR 0 2
18642: RET
// function heike_utika ; var Volno , Hex ; begin
18643: LD_INT 0
18645: PPUSH
18646: PPUSH
18647: PPUSH
// if zjisti_heike_utekla then
18648: CALL 18374 0 0
18652: IFFALSE 18660
// begin heike_utekla ;
18654: CALL 18840 0 0
// exit ;
18658: GO 18752
// end ; Volno = zjisti_volne ;
18660: LD_ADDR_VAR 0 2
18664: PUSH
18665: CALL 18306 0 0
18669: ST_TO_ADDR
// if HeikeUtika then
18670: LD_LOC 44
18674: IFFALSE 18693
// begin if je_volny_unik ( HeikeJdeKam [ 1 ] ) then
18676: LD_LOC 45
18680: PUSH
18681: LD_INT 1
18683: ARRAY
18684: PPUSH
18685: CALL 18236 0 1
18689: IFFALSE 18693
// exit ;
18691: GO 18752
// end ; HeikeJdeKam = zjisti_nejlepsi_unik ( Volno ) ;
18693: LD_ADDR_LOC 45
18697: PUSH
18698: LD_VAR 0 2
18702: PPUSH
18703: CALL 18544 0 1
18707: ST_TO_ADDR
// ComMoveToArea ( Heike , HeikeJdeKam [ 1 ] ) ;
18708: LD_EXP 26
18712: PPUSH
18713: LD_LOC 45
18717: PUSH
18718: LD_INT 1
18720: ARRAY
18721: PPUSH
18722: CALL_OW 113
// AddComMoveToArea ( Heike , HeikeJdeKam [ 2 ] ) ;
18726: LD_EXP 26
18730: PPUSH
18731: LD_LOC 45
18735: PUSH
18736: LD_INT 2
18738: ARRAY
18739: PPUSH
18740: CALL_OW 173
// HeikeUtika = true ;
18744: LD_ADDR_LOC 44
18748: PUSH
18749: LD_INT 1
18751: ST_TO_ADDR
// end ;
18752: LD_VAR 0 1
18756: RET
// function strazci_mrtvi ; begin
18757: LD_INT 0
18759: PPUSH
// heike_utec ;
18760: CALL 18794 0 0
// end ;
18764: LD_VAR 0 1
18768: RET
// every 0 0$1.3 marked 32 do
18769: GO 18771
18771: DISABLE
// begin if zjisti_heike_utekla then
18772: CALL 18374 0 0
18776: IFFALSE 18784
// begin heike_utekla ;
18778: CALL 18840 0 0
// exit ;
18782: GO 18784
// end ; end ;
18784: END
// every 0 0$1.1 marked 31 do
18785: GO 18787
18787: DISABLE
// begin heike_utika ;
18788: CALL 18643 0 0
// enable ;
18792: ENABLE
// end ;
18793: END
// function heike_utec ; begin
18794: LD_INT 0
18796: PPUSH
// if IsInArea ( Heike , Obkliceni ) then
18797: LD_EXP 26
18801: PPUSH
18802: LD_INT 38
18804: PPUSH
18805: CALL_OW 308
18809: IFFALSE 18820
// begin enable ( 31 ) ;
18811: LD_INT 31
18813: ENABLE_MARKED
// heike_utika ;
18814: CALL 18643 0 0
// end else
18818: GO 18835
// begin enable ( 32 ) ;
18820: LD_INT 32
18822: ENABLE_MARKED
// ComMoveToArea ( Heike , HeikeCil ) ;
18823: LD_EXP 26
18827: PPUSH
18828: LD_INT 27
18830: PPUSH
18831: CALL_OW 113
// end ; end ;
18835: LD_VAR 0 1
18839: RET
// function heike_utekla ; begin
18840: LD_INT 0
18842: PPUSH
// InGameOn ;
18843: CALL_OW 8
// CenterOnUnits ( Heike ) ;
18847: LD_EXP 26
18851: PPUSH
18852: CALL_OW 85
// Wait ( 0 0$2 ) ;
18856: LD_INT 70
18858: PPUSH
18859: CALL_OW 67
// if not IsOk ( Heike ) then
18863: LD_EXP 26
18867: PPUSH
18868: CALL_OW 302
18872: NOT
18873: IFFALSE 18885
// begin InGameOff ;
18875: CALL_OW 9
// heike_mrtva ;
18879: CALL 19045 0 0
// exit ;
18883: GO 18912
// end ; RemoveUnit ( Heike ) ;
18885: LD_EXP 26
18889: PPUSH
18890: CALL_OW 64
// Wait ( 0 0$2 ) ;
18894: LD_INT 70
18896: PPUSH
18897: CALL_OW 67
// YouLost ( Heike ) ;
18901: LD_STRING Heike
18903: PPUSH
18904: CALL_OW 104
// InGameOff ;
18908: CALL_OW 9
// end ;
18912: LD_VAR 0 1
18916: RET
// function heike_zajata ; begin
18917: LD_INT 0
18919: PPUSH
// if Zajmuta then
18920: LD_LOC 52
18924: IFFALSE 18928
// exit ;
18926: GO 19040
// Zajmuta = true ;
18928: LD_ADDR_LOC 52
18932: PUSH
18933: LD_INT 1
18935: ST_TO_ADDR
// SetAttitude ( side_Ru , side_Heike , ATT_FRIEND , true ) ;
18936: LD_EXP 2
18940: PPUSH
18941: LD_EXP 6
18945: PPUSH
18946: LD_INT 1
18948: PPUSH
18949: LD_INT 1
18951: PPUSH
18952: CALL_OW 80
// ComHold ( Heike ) ;
18956: LD_EXP 26
18960: PPUSH
18961: CALL_OW 140
// if ( GetLives ( Heike ) <= HRANICE_UMIRANI ) then
18965: LD_EXP 26
18969: PPUSH
18970: CALL_OW 256
18974: PUSH
18975: LD_INT 250
18977: LESSEQUAL
18978: IFFALSE 18996
// SetLives ( Heike , HRANICE_UMIRANI + 1 ) ;
18980: LD_EXP 26
18984: PPUSH
18985: LD_INT 250
18987: PUSH
18988: LD_INT 1
18990: PLUS
18991: PPUSH
18992: CALL_OW 234
// ComCancel ( Heike ) ;
18996: LD_EXP 26
19000: PPUSH
19001: CALL_OW 127
// ComHold ( Heike ) ;
19005: LD_EXP 26
19009: PPUSH
19010: CALL_OW 140
// DialogueOn ;
19014: CALL_OW 6
// dialog_HeikeCapt ;
19018: CALL 22690 0 0
// DialogueOff ;
19022: CALL_OW 7
// Wait ( 0 0$2 ) ;
19026: LD_INT 70
19028: PPUSH
19029: CALL_OW 67
// vyhral ( Main2 ) ;
19033: LD_STRING Main2
19035: PPUSH
19036: CALL 3049 0 1
// end ;
19040: LD_VAR 0 1
19044: RET
// function heike_mrtva ; begin
19045: LD_INT 0
19047: PPUSH
// DialogueOn ;
19048: CALL_OW 6
// Wait ( 0 0$3 ) ;
19052: LD_INT 105
19054: PPUSH
19055: CALL_OW 67
// vyhral ( Main1 ) ;
19059: LD_STRING Main1
19061: PPUSH
19062: CALL 3049 0 1
// DialogueOff ;
19066: CALL_OW 7
// end ;
19070: LD_VAR 0 1
19074: RET
// function straz_umrela ( Un ) ; begin
19075: LD_INT 0
19077: PPUSH
// if Un in Heikeovci then
19078: LD_VAR 0 1
19082: PUSH
19083: LD_EXP 27
19087: IN
19088: IFFALSE 19120
// begin Heikeovci = Heikeovci diff [ Un ] ;
19090: LD_ADDR_EXP 27
19094: PUSH
19095: LD_EXP 27
19099: PUSH
19100: LD_VAR 0 1
19104: PUSH
19105: EMPTY
19106: LIST
19107: DIFF
19108: ST_TO_ADDR
// if not Heikeovci then
19109: LD_EXP 27
19113: NOT
19114: IFFALSE 19120
// strazci_mrtvi ;
19116: CALL 18757 0 0
// end ; end ;
19120: LD_VAR 0 2
19124: RET
// export function heike_UnitDestroyed ( Un ) ; begin
19125: LD_INT 0
19127: PPUSH
// if Un = Heike then
19128: LD_VAR 0 1
19132: PUSH
19133: LD_EXP 26
19137: EQUAL
19138: IFFALSE 19146
// begin heike_mrtva ;
19140: CALL 19045 0 0
// exit ;
19144: GO 19159
// end ; straz_umrela ( Un ) ;
19146: LD_VAR 0 1
19150: PPUSH
19151: CALL 19075 0 1
// heike_kontrola_start ;
19155: CALL 18004 0 0
// end ;
19159: LD_VAR 0 2
19163: RET
// export function heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
19164: LD_INT 0
19166: PPUSH
// heike_kontrola_start ;
19167: CALL 18004 0 0
// end ;
19171: LD_VAR 0 5
19175: RET
// export function heike_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
19176: LD_INT 0
19178: PPUSH
// heike_kontrola_start ;
19179: CALL 18004 0 0
// end ;
19183: LD_VAR 0 4
19187: RET
// export function heike_UnitGoesToRed ( Un ) ; begin
19188: LD_INT 0
19190: PPUSH
// if Un = Heike then
19191: LD_VAR 0 1
19195: PUSH
19196: LD_EXP 26
19200: EQUAL
19201: IFFALSE 19211
// HeikeVCervenem = true ;
19203: LD_ADDR_LOC 51
19207: PUSH
19208: LD_INT 1
19210: ST_TO_ADDR
// straz_umrela ( Un ) ;
19211: LD_VAR 0 1
19215: PPUSH
19216: CALL 19075 0 1
// heike_kontrola_start ;
19220: CALL 18004 0 0
// end ;
19224: LD_VAR 0 2
19228: RET
// export function heike_StartHeal ( Un , Medic ) ; begin
19229: LD_INT 0
19231: PPUSH
// if Un <> Heike then
19232: LD_VAR 0 1
19236: PUSH
19237: LD_EXP 26
19241: NONEQUAL
19242: IFFALSE 19246
// exit ;
19244: GO 19286
// if not HeikeVCervenem then
19246: LD_LOC 51
19250: NOT
19251: IFFALSE 19255
// exit ;
19253: GO 19286
// if Heikeovci then
19255: LD_EXP 27
19259: IFFALSE 19263
// exit ;
19261: GO 19286
// if GetSide ( Medic ) <> side_Ru then
19263: LD_VAR 0 2
19267: PPUSH
19268: CALL_OW 255
19272: PUSH
19273: LD_EXP 2
19277: NONEQUAL
19278: IFFALSE 19282
// exit ;
19280: GO 19286
// heike_zajata ;
19282: CALL 18917 0 0
// end ; end_of_file
19286: LD_VAR 0 3
19290: RET
// var BednyA ; var BednyRZ , BednyRV ; export function init_Suroviny ; begin
19291: LD_INT 0
19293: PPUSH
// BednyA = dif_BednyA [ Difficulty ] ;
19294: LD_ADDR_LOC 53
19298: PUSH
19299: LD_EXP 36
19303: PUSH
19304: LD_OWVAR 67
19308: ARRAY
19309: ST_TO_ADDR
// if VsevSaved then
19310: LD_EXP 8
19314: IFFALSE 19350
// begin BednyRZ = dif_BednyR1 [ Difficulty ] ;
19316: LD_ADDR_LOC 54
19320: PUSH
19321: LD_EXP 37
19325: PUSH
19326: LD_OWVAR 67
19330: ARRAY
19331: ST_TO_ADDR
// BednyRV = dif_BednyR2 [ Difficulty ] ;
19332: LD_ADDR_LOC 55
19336: PUSH
19337: LD_EXP 38
19341: PUSH
19342: LD_OWVAR 67
19346: ARRAY
19347: ST_TO_ADDR
// end else
19348: GO 19382
// begin BednyRZ = dif_BednyR2 [ Difficulty ] ;
19350: LD_ADDR_LOC 54
19354: PUSH
19355: LD_EXP 38
19359: PUSH
19360: LD_OWVAR 67
19364: ARRAY
19365: ST_TO_ADDR
// BednyRV = dif_BednyR1 [ Difficulty ] ;
19366: LD_ADDR_LOC 55
19370: PUSH
19371: LD_EXP 37
19375: PUSH
19376: LD_OWVAR 67
19380: ARRAY
19381: ST_TO_ADDR
// end ; end ;
19382: LD_VAR 0 1
19386: RET
// every 5 5$13.7 + 5 5$9 do var Pocet ;
19387: GO 19389
19389: DISABLE
19390: LD_INT 0
19392: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19393: LD_INT 35
19395: PPUSH
19396: LD_INT 3150
19398: PPUSH
19399: CALL_OW 12
19403: PPUSH
19404: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
19408: LD_ADDR_VAR 0 1
19412: PUSH
19413: LD_INT 0
19415: PPUSH
19416: LD_INT 5
19418: PPUSH
19419: CALL_OW 12
19423: ST_TO_ADDR
// if Pocet > 0 then
19424: LD_VAR 0 1
19428: PUSH
19429: LD_INT 0
19431: GREATER
19432: IFFALSE 19446
// CreateCratesAnywhere ( Pocet , true ) ;
19434: LD_VAR 0 1
19438: PPUSH
19439: LD_INT 1
19441: PPUSH
19442: CALL_OW 57
// enable ;
19446: ENABLE
// end ;
19447: PPOPN 1
19449: END
// every 1 1$49 do
19450: GO 19452
19452: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$30 ) ) ;
19453: LD_INT 35
19455: PPUSH
19456: LD_INT 3150
19458: PPUSH
19459: CALL_OW 12
19463: PPUSH
19464: CALL_OW 67
// if ( BednyA <> 0 ) then
19468: LD_LOC 53
19472: PUSH
19473: LD_INT 0
19475: NONEQUAL
19476: IFFALSE 19535
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyArabi , true ) ;
19478: LD_INT 3
19480: PPUSH
19481: LD_INT 5
19483: PPUSH
19484: CALL_OW 12
19488: PPUSH
19489: LD_INT 30
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL_OW 55
// if ( BednyA <> - 1 ) then
19499: LD_LOC 53
19503: PUSH
19504: LD_INT 1
19506: NEG
19507: NONEQUAL
19508: IFFALSE 19524
// BednyA = BednyA - 1 ;
19510: LD_ADDR_LOC 53
19514: PUSH
19515: LD_LOC 53
19519: PUSH
19520: LD_INT 1
19522: MINUS
19523: ST_TO_ADDR
// if ( BednyA <> 0 ) then
19524: LD_LOC 53
19528: PUSH
19529: LD_INT 0
19531: NONEQUAL
19532: IFFALSE 19535
// enable ;
19534: ENABLE
// end ; end ;
19535: END
// every 2 2$5 + 1 1$39 do
19536: GO 19538
19538: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19539: LD_INT 35
19541: PPUSH
19542: LD_INT 4200
19544: PPUSH
19545: CALL_OW 12
19549: PPUSH
19550: CALL_OW 67
// if ( BednyRZ <> 0 ) then
19554: LD_LOC 54
19558: PUSH
19559: LD_INT 0
19561: NONEQUAL
19562: IFFALSE 19621
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
19564: LD_INT 3
19566: PPUSH
19567: LD_INT 5
19569: PPUSH
19570: CALL_OW 12
19574: PPUSH
19575: LD_INT 28
19577: PPUSH
19578: LD_INT 1
19580: PPUSH
19581: CALL_OW 55
// if ( BednyRZ <> - 1 ) then
19585: LD_LOC 54
19589: PUSH
19590: LD_INT 1
19592: NEG
19593: NONEQUAL
19594: IFFALSE 19610
// BednyRZ = BednyRZ - 1 ;
19596: LD_ADDR_LOC 54
19600: PUSH
19601: LD_LOC 54
19605: PUSH
19606: LD_INT 1
19608: MINUS
19609: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
19610: LD_LOC 54
19614: PUSH
19615: LD_INT 0
19617: NONEQUAL
19618: IFFALSE 19621
// enable ;
19620: ENABLE
// end ; end ;
19621: END
// every 2 2$23 + 0 0$53 do
19622: GO 19624
19624: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
19625: LD_INT 35
19627: PPUSH
19628: LD_INT 4200
19630: PPUSH
19631: CALL_OW 12
19635: PPUSH
19636: CALL_OW 67
// if ( BednyRV <> 0 ) then
19640: LD_LOC 55
19644: PUSH
19645: LD_INT 0
19647: NONEQUAL
19648: IFFALSE 19707
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
19650: LD_INT 3
19652: PPUSH
19653: LD_INT 5
19655: PPUSH
19656: CALL_OW 12
19660: PPUSH
19661: LD_INT 29
19663: PPUSH
19664: LD_INT 1
19666: PPUSH
19667: CALL_OW 55
// if ( BednyRV <> - 1 ) then
19671: LD_LOC 55
19675: PUSH
19676: LD_INT 1
19678: NEG
19679: NONEQUAL
19680: IFFALSE 19696
// BednyRV = BednyRV - 1 ;
19682: LD_ADDR_LOC 55
19686: PUSH
19687: LD_LOC 55
19691: PUSH
19692: LD_INT 1
19694: MINUS
19695: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
19696: LD_LOC 55
19700: PUSH
19701: LD_INT 0
19703: NONEQUAL
19704: IFFALSE 19707
// enable ;
19706: ENABLE
// end ; end ; end_of_file
19707: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin xavier_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19708: LD_VAR 0 1
19712: PPUSH
19713: LD_VAR 0 2
19717: PPUSH
19718: LD_VAR 0 3
19722: PPUSH
19723: LD_VAR 0 4
19727: PPUSH
19728: CALL 16824 0 4
// yashin_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19732: LD_VAR 0 1
19736: PPUSH
19737: LD_VAR 0 2
19741: PPUSH
19742: LD_VAR 0 3
19746: PPUSH
19747: LD_VAR 0 4
19751: PPUSH
19752: CALL 14588 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19756: LD_VAR 0 1
19760: PPUSH
19761: LD_VAR 0 2
19765: PPUSH
19766: LD_VAR 0 3
19770: PPUSH
19771: LD_VAR 0 4
19775: PPUSH
19776: CALL 9999 0 4
// heike_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
19780: LD_VAR 0 1
19784: PPUSH
19785: LD_VAR 0 2
19789: PPUSH
19790: LD_VAR 0 3
19794: PPUSH
19795: LD_VAR 0 4
19799: PPUSH
19800: CALL 19164 0 4
// end ;
19804: PPOPN 4
19806: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin heike_BuildingCaptured ( Build , OrigSide , Eng ) ;
19807: LD_VAR 0 1
19811: PPUSH
19812: LD_VAR 0 2
19816: PPUSH
19817: LD_VAR 0 3
19821: PPUSH
19822: CALL 19176 0 3
// arabi_BuildingCaptured ( Build , OrigSide , Eng ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_VAR 0 2
19835: PPUSH
19836: LD_VAR 0 3
19840: PPUSH
19841: CALL 10494 0 3
// end ;
19845: PPOPN 3
19847: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
19848: LD_VAR 0 1
19852: PPUSH
19853: CALL 6032 0 1
// heike_UnitDestroyed ( Un ) ;
19857: LD_VAR 0 1
19861: PPUSH
19862: CALL 19125 0 1
// arabi_UnitDestroyed ( Un ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: CALL 10233 0 1
// end ;
19875: PPOPN 1
19877: END
// on UnitGoesToRed ( Un ) do begin yashin_UnitGoesToRed ( Un ) ;
19878: LD_VAR 0 1
19882: PPUSH
19883: CALL 15064 0 1
// arabi_UnitGoesToRed ( Un ) ;
19887: LD_VAR 0 1
19891: PPUSH
19892: CALL 10369 0 1
// heike_UnitGoesToRed ( Un ) ;
19896: LD_VAR 0 1
19900: PPUSH
19901: CALL 19188 0 1
// end ;
19905: PPOPN 1
19907: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
19908: LD_VAR 0 1
19912: PPUSH
19913: LD_VAR 0 2
19917: PPUSH
19918: CALL 9472 0 2
// end ;
19922: PPOPN 2
19924: END
// on BuildingComplete ( Un ) do begin rusove_BuildingComplete ( Un ) ;
19925: LD_VAR 0 1
19929: PPUSH
19930: CALL 6109 0 1
// end ;
19934: PPOPN 1
19936: END
// on SailEvent ( Num ) do begin case Num of 101 :
19937: LD_VAR 0 1
19941: PUSH
19942: LD_INT 101
19944: DOUBLE
19945: EQUAL
19946: IFTRUE 19950
19948: GO 19957
19950: POP
// event_Patrola ; 102 , 103 , 103 :
19951: CALL 11328 0 0
19955: GO 20020
19957: LD_INT 102
19959: DOUBLE
19960: EQUAL
19961: IFTRUE 19977
19963: LD_INT 103
19965: DOUBLE
19966: EQUAL
19967: IFTRUE 19977
19969: LD_INT 103
19971: DOUBLE
19972: EQUAL
19973: IFTRUE 19977
19975: GO 19989
19977: POP
// event_OpravaHotova ( Num ) ; 111 :
19978: LD_VAR 0 1
19982: PPUSH
19983: CALL 12785 0 1
19987: GO 20020
19989: LD_INT 111
19991: DOUBLE
19992: EQUAL
19993: IFTRUE 19997
19995: GO 20004
19997: POP
// event_YashinUtoci ; 121 :
19998: CALL 14568 0 0
20002: GO 20020
20004: LD_INT 121
20006: DOUBLE
20007: EQUAL
20008: IFTRUE 20012
20010: GO 20019
20012: POP
// event_XavierPrisel ; end ;
20013: CALL 16812 0 0
20017: GO 20020
20019: POP
// end ;
20020: PPOPN 1
20022: END
// on Contact ( Side1 , Side2 ) do begin rusove_Contact ( Side1 , Side2 ) ;
20023: LD_VAR 0 1
20027: PPUSH
20028: LD_VAR 0 2
20032: PPUSH
20033: CALL 6234 0 2
// end ;
20037: PPOPN 2
20039: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
20040: LD_VAR 0 1
20044: PPUSH
20045: LD_VAR 0 2
20049: PPUSH
20050: CALL 8929 0 2
// end ;
20054: PPOPN 2
20056: END
// on StartHeal ( Un , Medic ) do begin heike_StartHeal ( Un , Medic ) ;
20057: LD_VAR 0 1
20061: PPUSH
20062: LD_VAR 0 2
20066: PPUSH
20067: CALL 19229 0 2
// end ;
20071: PPOPN 2
20073: END
// every 1 1$59 do
20074: GO 20076
20076: DISABLE
// begin RandomizeAll ;
20077: CALL_OW 11
// end ; end_of_file
20081: END
// export dif_BednyA , dif_BednyR1 , dif_BednyR2 ; export dif_HeikeBudovy , dif_HeikeAuta , dif_HeikeLidi ; export dif_HeikeovciLives , dif_HeikeovciPocet ; export dif_Cans , dif_Oil , dif_Siberit ; export dif_ArabiLevel , dif_VolnyArabi , dif_ObranciArabi ; export dif_UtokSkupina , dif_PstZbrane ; export dif_CasovacUtoku ; export dif_MaxKonvojCargo ; export function init_difficulty ; begin
20082: LD_INT 0
20084: PPUSH
// dif_BednyR1 = [ 25 , 20 , 15 ] ;
20085: LD_ADDR_EXP 37
20089: PUSH
20090: LD_INT 25
20092: PUSH
20093: LD_INT 20
20095: PUSH
20096: LD_INT 15
20098: PUSH
20099: EMPTY
20100: LIST
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// dif_BednyR2 = [ 30 , 25 , 20 ] ;
20104: LD_ADDR_EXP 38
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 25
20114: PUSH
20115: LD_INT 20
20117: PUSH
20118: EMPTY
20119: LIST
20120: LIST
20121: LIST
20122: ST_TO_ADDR
// dif_BednyA = [ 25 , 35 , 60 ] ;
20123: LD_ADDR_EXP 36
20127: PUSH
20128: LD_INT 25
20130: PUSH
20131: LD_INT 35
20133: PUSH
20134: LD_INT 60
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: LIST
20141: ST_TO_ADDR
// dif_HeikeBudovy = [ 8 , 5 , 2 ] ;
20142: LD_ADDR_EXP 39
20146: PUSH
20147: LD_INT 8
20149: PUSH
20150: LD_INT 5
20152: PUSH
20153: LD_INT 2
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: LIST
20160: ST_TO_ADDR
// dif_HeikeAuta = [ 2 , 1 , 0 ] ;
20161: LD_ADDR_EXP 40
20165: PUSH
20166: LD_INT 2
20168: PUSH
20169: LD_INT 1
20171: PUSH
20172: LD_INT 0
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: LIST
20179: ST_TO_ADDR
// dif_HeikeLidi = [ 2 , 1 , 0 ] ;
20180: LD_ADDR_EXP 41
20184: PUSH
20185: LD_INT 2
20187: PUSH
20188: LD_INT 1
20190: PUSH
20191: LD_INT 0
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: ST_TO_ADDR
// dif_HeikeovciLives = [ 750 , 900 , 1000 ] ;
20199: LD_ADDR_EXP 42
20203: PUSH
20204: LD_INT 750
20206: PUSH
20207: LD_INT 900
20209: PUSH
20210: LD_INT 1000
20212: PUSH
20213: EMPTY
20214: LIST
20215: LIST
20216: LIST
20217: ST_TO_ADDR
// dif_HeikeovciPocet = [ 2 , 4 , 7 ] ;
20218: LD_ADDR_EXP 43
20222: PUSH
20223: LD_INT 2
20225: PUSH
20226: LD_INT 4
20228: PUSH
20229: LD_INT 7
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: LIST
20236: ST_TO_ADDR
// dif_ArabiLevel = [ 3 , 5 , 7 ] ;
20237: LD_ADDR_EXP 47
20241: PUSH
20242: LD_INT 3
20244: PUSH
20245: LD_INT 5
20247: PUSH
20248: LD_INT 7
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: LIST
20255: ST_TO_ADDR
// dif_VolnyArabi = [ 2 , 5 , 10 ] ;
20256: LD_ADDR_EXP 48
20260: PUSH
20261: LD_INT 2
20263: PUSH
20264: LD_INT 5
20266: PUSH
20267: LD_INT 10
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: LIST
20274: ST_TO_ADDR
// dif_ObranciArabi = [ 1 , 3 , 5 ] ;
20275: LD_ADDR_EXP 49
20279: PUSH
20280: LD_INT 1
20282: PUSH
20283: LD_INT 3
20285: PUSH
20286: LD_INT 5
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: LIST
20293: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
20294: LD_ADDR_EXP 50
20298: PUSH
20299: LD_INT 3
20301: PUSH
20302: LD_INT 4
20304: PUSH
20305: LD_INT 6
20307: PUSH
20308: EMPTY
20309: LIST
20310: LIST
20311: LIST
20312: ST_TO_ADDR
// dif_Cans = [ 200 , 170 , 130 ] ;
20313: LD_ADDR_EXP 44
20317: PUSH
20318: LD_INT 200
20320: PUSH
20321: LD_INT 170
20323: PUSH
20324: LD_INT 130
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: ST_TO_ADDR
// dif_Oil = [ 100 , 50 , 0 ] ;
20332: LD_ADDR_EXP 45
20336: PUSH
20337: LD_INT 100
20339: PUSH
20340: LD_INT 50
20342: PUSH
20343: LD_INT 0
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: LIST
20350: ST_TO_ADDR
// dif_Siberit = [ 100 , 100 , 100 ] ;
20351: LD_ADDR_EXP 46
20355: PUSH
20356: LD_INT 100
20358: PUSH
20359: LD_INT 100
20361: PUSH
20362: LD_INT 100
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: ST_TO_ADDR
// if VsevSaved then
20370: LD_EXP 8
20374: IFFALSE 20418
// dif_CasovacUtoku = [ [ 8 , 10 ] , [ 7 , 9 ] , [ 6 , 8 ] ] else
20376: LD_ADDR_EXP 52
20380: PUSH
20381: LD_INT 8
20383: PUSH
20384: LD_INT 10
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PUSH
20391: LD_INT 7
20393: PUSH
20394: LD_INT 9
20396: PUSH
20397: EMPTY
20398: LIST
20399: LIST
20400: PUSH
20401: LD_INT 6
20403: PUSH
20404: LD_INT 8
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: PUSH
20411: EMPTY
20412: LIST
20413: LIST
20414: LIST
20415: ST_TO_ADDR
20416: GO 20466
// dif_CasovacUtoku = [ [ 8 , 8 , 7 ] , [ 8 , 7 , 6 ] , [ 4 , 5 ] ] ;
20418: LD_ADDR_EXP 52
20422: PUSH
20423: LD_INT 8
20425: PUSH
20426: LD_INT 8
20428: PUSH
20429: LD_INT 7
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: PUSH
20437: LD_INT 8
20439: PUSH
20440: LD_INT 7
20442: PUSH
20443: LD_INT 6
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: LIST
20450: PUSH
20451: LD_INT 4
20453: PUSH
20454: LD_INT 5
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: LIST
20465: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 30 , 50 , 80 , 100 ] , [ 30 , 60 , 75 , 100 ] ] ;
20466: LD_ADDR_EXP 51
20470: PUSH
20471: LD_INT 20
20473: PUSH
20474: LD_INT 40
20476: PUSH
20477: LD_INT 80
20479: PUSH
20480: LD_INT 100
20482: PUSH
20483: EMPTY
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: PUSH
20489: LD_INT 30
20491: PUSH
20492: LD_INT 50
20494: PUSH
20495: LD_INT 80
20497: PUSH
20498: LD_INT 100
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 30
20509: PUSH
20510: LD_INT 60
20512: PUSH
20513: LD_INT 75
20515: PUSH
20516: LD_INT 100
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: LIST
20523: LIST
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: LIST
20529: ST_TO_ADDR
// dif_MaxKonvojCargo = [ [ 5 , 200 , 100 , 0 ] , [ 5 , 160 , 60 , 0 ] , [ 5 , 50 , 50 , 0 ] ] ;
20530: LD_ADDR_EXP 53
20534: PUSH
20535: LD_INT 5
20537: PUSH
20538: LD_INT 200
20540: PUSH
20541: LD_INT 100
20543: PUSH
20544: LD_INT 0
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 5
20555: PUSH
20556: LD_INT 160
20558: PUSH
20559: LD_INT 60
20561: PUSH
20562: LD_INT 0
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 5
20573: PUSH
20574: LD_INT 50
20576: PUSH
20577: LD_INT 50
20579: PUSH
20580: LD_INT 0
20582: PUSH
20583: EMPTY
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: ST_TO_ADDR
// end ; end_of_file
20594: LD_VAR 0 1
20598: RET
// export function jdete_k_sobe ( Kdo , Kam ) ; begin
20599: LD_INT 0
20601: PPUSH
// ComMoveUnit ( Kdo , Kam ) ;
20602: LD_VAR 0 1
20606: PPUSH
20607: LD_VAR 0 2
20611: PPUSH
20612: CALL_OW 112
// while GetDistUnits ( Kdo , Kam ) > 3 do
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: CALL_OW 296
20630: PUSH
20631: LD_INT 3
20633: GREATER
20634: IFFALSE 20645
// Wait ( 0 0$0.5 ) ;
20636: LD_INT 18
20638: PPUSH
20639: CALL_OW 67
20643: GO 20616
// AddComTurnUnit ( Kdo , Kam ) ;
20645: LD_VAR 0 1
20649: PPUSH
20650: LD_VAR 0 2
20654: PPUSH
20655: CALL_OW 179
// AddComTurnUnit ( Kam , Kdo ) ;
20659: LD_VAR 0 2
20663: PPUSH
20664: LD_VAR 0 1
20668: PPUSH
20669: CALL_OW 179
// end ;
20673: LD_VAR 0 3
20677: RET
// export function place_list ( List , Area ) ; var I ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
// for I in List do
20682: LD_ADDR_VAR 0 4
20686: PUSH
20687: LD_VAR 0 1
20691: PUSH
20692: FOR_IN
20693: IFFALSE 20714
// PlaceUnitArea ( I , Area , false ) ;
20695: LD_VAR 0 4
20699: PPUSH
20700: LD_VAR 0 2
20704: PPUSH
20705: LD_INT 0
20707: PPUSH
20708: CALL_OW 49
20712: GO 20692
20714: POP
20715: POP
// end ;
20716: LD_VAR 0 3
20720: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20721: LD_INT 0
20723: PPUSH
20724: PPUSH
20725: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20726: LD_ADDR_VAR 0 4
20730: PUSH
20731: LD_INT 22
20733: PUSH
20734: LD_VAR 0 2
20738: PUSH
20739: EMPTY
20740: LIST
20741: LIST
20742: PUSH
20743: EMPTY
20744: LIST
20745: PPUSH
20746: CALL_OW 69
20750: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20751: LD_ADDR_VAR 0 5
20755: PUSH
20756: LD_VAR 0 4
20760: PUSH
20761: FOR_IN
20762: IFFALSE 20794
// if See ( Kdo , Jednotka ) then
20764: LD_VAR 0 1
20768: PPUSH
20769: LD_VAR 0 5
20773: PPUSH
20774: CALL_OW 292
20778: IFFALSE 20792
// begin Result = true ;
20780: LD_ADDR_VAR 0 3
20784: PUSH
20785: LD_INT 1
20787: ST_TO_ADDR
// exit ;
20788: POP
20789: POP
20790: GO 20804
// end ;
20792: GO 20761
20794: POP
20795: POP
// Result = false ;
20796: LD_ADDR_VAR 0 3
20800: PUSH
20801: LD_INT 0
20803: ST_TO_ADDR
// end ;
20804: LD_VAR 0 3
20808: RET
// export function vidi_strana_jednotky ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
20809: LD_INT 0
20811: PPUSH
20812: PPUSH
20813: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20814: LD_ADDR_VAR 0 4
20818: PUSH
20819: LD_INT 22
20821: PUSH
20822: LD_VAR 0 2
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: PUSH
20831: EMPTY
20832: LIST
20833: PPUSH
20834: CALL_OW 69
20838: ST_TO_ADDR
// Result = [ ] ;
20839: LD_ADDR_VAR 0 3
20843: PUSH
20844: EMPTY
20845: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20846: LD_ADDR_VAR 0 5
20850: PUSH
20851: LD_VAR 0 4
20855: PUSH
20856: FOR_IN
20857: IFFALSE 20896
// if See ( Kdo , Jednotka ) then
20859: LD_VAR 0 1
20863: PPUSH
20864: LD_VAR 0 5
20868: PPUSH
20869: CALL_OW 292
20873: IFFALSE 20894
// Result = Result union [ Jednotka ] ;
20875: LD_ADDR_VAR 0 3
20879: PUSH
20880: LD_VAR 0 3
20884: PUSH
20885: LD_VAR 0 5
20889: PUSH
20890: EMPTY
20891: LIST
20892: UNION
20893: ST_TO_ADDR
20894: GO 20856
20896: POP
20897: POP
// end ;
20898: LD_VAR 0 3
20902: RET
// export function jednotky_blizko ( Kdo , Koho , Dalka ) ; var KohoJednotky , Jednotka ; begin
20903: LD_INT 0
20905: PPUSH
20906: PPUSH
20907: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
20908: LD_ADDR_VAR 0 5
20912: PUSH
20913: LD_INT 22
20915: PUSH
20916: LD_VAR 0 2
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: PUSH
20925: EMPTY
20926: LIST
20927: PPUSH
20928: CALL_OW 69
20932: ST_TO_ADDR
// Result = [ ] ;
20933: LD_ADDR_VAR 0 4
20937: PUSH
20938: EMPTY
20939: ST_TO_ADDR
// for Jednotka in KohoJednotky do
20940: LD_ADDR_VAR 0 6
20944: PUSH
20945: LD_VAR 0 5
20949: PUSH
20950: FOR_IN
20951: IFFALSE 20996
// if GetDistUnits ( Kdo , Jednotka ) <= Dalka then
20953: LD_VAR 0 1
20957: PPUSH
20958: LD_VAR 0 6
20962: PPUSH
20963: CALL_OW 296
20967: PUSH
20968: LD_VAR 0 3
20972: LESSEQUAL
20973: IFFALSE 20994
// Result = Result union [ Jednotka ] ;
20975: LD_ADDR_VAR 0 4
20979: PUSH
20980: LD_VAR 0 4
20984: PUSH
20985: LD_VAR 0 6
20989: PUSH
20990: EMPTY
20991: LIST
20992: UNION
20993: ST_TO_ADDR
20994: GO 20950
20996: POP
20997: POP
// end ;
20998: LD_VAR 0 4
21002: RET
// export function nahoda_seznam ( Seznam ) ; begin
21003: LD_INT 0
21005: PPUSH
// if Seznam then
21006: LD_VAR 0 1
21010: IFFALSE 21038
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21012: LD_ADDR_VAR 0 2
21016: PUSH
21017: LD_VAR 0 1
21021: PUSH
21022: LD_INT 1
21024: PPUSH
21025: LD_VAR 0 1
21029: PPUSH
21030: CALL_OW 12
21034: ARRAY
21035: ST_TO_ADDR
21036: GO 21046
// Result = 0 ;
21038: LD_ADDR_VAR 0 2
21042: PUSH
21043: LD_INT 0
21045: ST_TO_ADDR
// end ;
21046: LD_VAR 0 2
21050: RET
// export function bez_opic ( List ) ; var Opice ; begin
21051: LD_INT 0
21053: PPUSH
21054: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
21055: LD_ADDR_VAR 0 3
21059: PUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: LD_INT 2
21067: PUSH
21068: LD_INT 25
21070: PUSH
21071: LD_INT 12
21073: PUSH
21074: EMPTY
21075: LIST
21076: LIST
21077: PUSH
21078: LD_INT 25
21080: PUSH
21081: LD_INT 15
21083: PUSH
21084: EMPTY
21085: LIST
21086: LIST
21087: PUSH
21088: LD_INT 25
21090: PUSH
21091: LD_INT 16
21093: PUSH
21094: EMPTY
21095: LIST
21096: LIST
21097: PUSH
21098: LD_INT 25
21100: PUSH
21101: LD_INT 17
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: PUSH
21108: EMPTY
21109: LIST
21110: LIST
21111: LIST
21112: LIST
21113: LIST
21114: PUSH
21115: EMPTY
21116: LIST
21117: PPUSH
21118: CALL_OW 72
21122: ST_TO_ADDR
// Result = List diff Opice ;
21123: LD_ADDR_VAR 0 2
21127: PUSH
21128: LD_VAR 0 1
21132: PUSH
21133: LD_VAR 0 3
21137: DIFF
21138: ST_TO_ADDR
// end ; end_of_file
21139: LD_VAR 0 2
21143: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
21144: LD_INT 0
21146: PPUSH
21147: PPUSH
21148: PPUSH
// Result = [ ] ;
21149: LD_ADDR_VAR 0 4
21153: PUSH
21154: EMPTY
21155: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
21156: LD_ADDR_OWVAR 21
21160: PUSH
21161: LD_INT 0
21163: ST_TO_ADDR
// UC_side = side_neutral ;
21164: LD_ADDR_OWVAR 20
21168: PUSH
21169: LD_EXP 1
21173: ST_TO_ADDR
// HC_Class = Cls ;
21174: LD_ADDR_OWVAR 28
21178: PUSH
21179: LD_VAR 0 1
21183: ST_TO_ADDR
// HC_Name =  ;
21184: LD_ADDR_OWVAR 26
21188: PUSH
21189: LD_STRING 
21191: ST_TO_ADDR
// for i = 1 to Cnt do
21192: LD_ADDR_VAR 0 5
21196: PUSH
21197: DOUBLE
21198: LD_INT 1
21200: DEC
21201: ST_TO_ADDR
21202: LD_VAR 0 2
21206: PUSH
21207: FOR_TO
21208: IFFALSE 21258
// begin h = CreateHuman ;
21210: LD_ADDR_VAR 0 6
21214: PUSH
21215: CALL_OW 44
21219: ST_TO_ADDR
// Result = Result union [ h ] ;
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 4
21229: PUSH
21230: LD_VAR 0 6
21234: PUSH
21235: EMPTY
21236: LIST
21237: UNION
21238: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
21239: LD_VAR 0 6
21243: PPUSH
21244: LD_VAR 0 3
21248: PPUSH
21249: LD_INT 0
21251: PPUSH
21252: CALL_OW 49
// end ;
21256: GO 21207
21258: POP
21259: POP
// end ;
21260: LD_VAR 0 4
21264: RET
// export function init_nature ; begin
21265: LD_INT 0
21267: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 1 , 3 ) , Les ) ;
21268: LD_INT 14
21270: PPUSH
21271: LD_INT 1
21273: PPUSH
21274: LD_INT 3
21276: PPUSH
21277: CALL_OW 12
21281: PPUSH
21282: LD_INT 10
21284: PPUSH
21285: CALL 21144 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 10 ) - Difficulty , Les ) ;
21289: LD_INT 12
21291: PPUSH
21292: LD_INT 5
21294: PPUSH
21295: LD_INT 10
21297: PPUSH
21298: CALL_OW 12
21302: PUSH
21303: LD_OWVAR 67
21307: MINUS
21308: PPUSH
21309: LD_INT 10
21311: PPUSH
21312: CALL 21144 0 3
// end ; end_of_file
21316: LD_VAR 0 1
21320: RET
// export function dialog_Start ; begin
21321: LD_INT 0
21323: PPUSH
// SayRadio ( Platonov , DStart-Pla-1 ) ;
21324: LD_EXP 20
21328: PPUSH
21329: LD_STRING DStart-Pla-1
21331: PPUSH
21332: CALL_OW 94
// end ;
21336: LD_VAR 0 1
21340: RET
// export function dialog_StartVS ; begin
21341: LD_INT 0
21343: PPUSH
// SayRadio ( Platonov , DStartVS-Pla-1 ) ;
21344: LD_EXP 20
21348: PPUSH
21349: LD_STRING DStartVS-Pla-1
21351: PPUSH
21352: CALL_OW 94
// end ;
21356: LD_VAR 0 1
21360: RET
// export function dialog_StartNV ; begin
21361: LD_INT 0
21363: PPUSH
// SayRadio ( Platonov , DStartNV-Pla-1 ) ;
21364: LD_EXP 20
21368: PPUSH
21369: LD_STRING DStartNV-Pla-1
21371: PPUSH
21372: CALL_OW 94
// end ;
21376: LD_VAR 0 1
21380: RET
// export function dialog_Start2 ; begin
21381: LD_INT 0
21383: PPUSH
// SayRadio ( Platonov , DStart2-Pla-1 ) ;
21384: LD_EXP 20
21388: PPUSH
21389: LD_STRING DStart2-Pla-1
21391: PPUSH
21392: CALL_OW 94
// Say ( Burlak , DStart2-Bur-1 ) ;
21396: LD_EXP 10
21400: PPUSH
21401: LD_STRING DStart2-Bur-1
21403: PPUSH
21404: CALL_OW 88
// end ;
21408: LD_VAR 0 1
21412: RET
// export function dialog_MeetVsevolodVS ; begin
21413: LD_INT 0
21415: PPUSH
// Say ( Burlak , DMeetVsevolodVS-Bur-1 ) ;
21416: LD_EXP 10
21420: PPUSH
21421: LD_STRING DMeetVsevolodVS-Bur-1
21423: PPUSH
21424: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-1 ) ;
21428: LD_EXP 11
21432: PPUSH
21433: LD_STRING DMeetVsevolodVS-Vse-1
21435: PPUSH
21436: CALL_OW 88
// Say ( Burlak , DMeetVsevolodVS-Bur-2 ) ;
21440: LD_EXP 10
21444: PPUSH
21445: LD_STRING DMeetVsevolodVS-Bur-2
21447: PPUSH
21448: CALL_OW 88
// Say ( Vsevolod , DMeetVsevolodVS-Vse-2 ) ;
21452: LD_EXP 11
21456: PPUSH
21457: LD_STRING DMeetVsevolodVS-Vse-2
21459: PPUSH
21460: CALL_OW 88
// end ;
21464: LD_VAR 0 1
21468: RET
// export function dialog_StasisVS ; begin
21469: LD_INT 0
21471: PPUSH
// if Titov and IsOK ( Titov ) then
21472: LD_EXP 19
21476: PUSH
21477: LD_EXP 19
21481: PPUSH
21482: CALL_OW 302
21486: AND
21487: IFFALSE 21503
// Say ( Titov , DStasisVS-Tit-1 ) else
21489: LD_EXP 19
21493: PPUSH
21494: LD_STRING DStasisVS-Tit-1
21496: PPUSH
21497: CALL_OW 88
21501: GO 21515
// Say ( Yelena , DStasisVS-Kir-1 ) ;
21503: LD_EXP 13
21507: PPUSH
21508: LD_STRING DStasisVS-Kir-1
21510: PPUSH
21511: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-1 ) ;
21515: LD_EXP 10
21519: PPUSH
21520: LD_STRING DStasisVS-Bur-1
21522: PPUSH
21523: CALL_OW 88
// if Titov and IsOK ( Titov ) then
21527: LD_EXP 19
21531: PUSH
21532: LD_EXP 19
21536: PPUSH
21537: CALL_OW 302
21541: AND
21542: IFFALSE 21558
// Say ( Titov , DStasisVS-Tit-2 ) else
21544: LD_EXP 19
21548: PPUSH
21549: LD_STRING DStasisVS-Tit-2
21551: PPUSH
21552: CALL_OW 88
21556: GO 21570
// Say ( Yelena , DStasisVS-Kir-2 ) ;
21558: LD_EXP 13
21562: PPUSH
21563: LD_STRING DStasisVS-Kir-2
21565: PPUSH
21566: CALL_OW 88
// Say ( Burlak , DStasisVS-Bur-2 ) ;
21570: LD_EXP 10
21574: PPUSH
21575: LD_STRING DStasisVS-Bur-2
21577: PPUSH
21578: CALL_OW 88
// wait ( 0 0$3 ) ;
21582: LD_INT 105
21584: PPUSH
21585: CALL_OW 67
// SayRadio ( Popov , DStasisVS-Pop-2 ) ;
21589: LD_EXP 12
21593: PPUSH
21594: LD_STRING DStasisVS-Pop-2
21596: PPUSH
21597: CALL_OW 94
// if Gleb and IsOK ( Gleb ) then
21601: LD_EXP 14
21605: PUSH
21606: LD_EXP 14
21610: PPUSH
21611: CALL_OW 302
21615: AND
21616: IFFALSE 21630
// Say ( Gleb , DStasisVS-Glb-2 ) ;
21618: LD_EXP 14
21622: PPUSH
21623: LD_STRING DStasisVS-Glb-2
21625: PPUSH
21626: CALL_OW 88
// end ;
21630: LD_VAR 0 1
21634: RET
// export function dialog_SeviSaved ; begin
21635: LD_INT 0
21637: PPUSH
// Say ( Burlak , DSeviSaved-Bur-1 ) ;
21638: LD_EXP 10
21642: PPUSH
21643: LD_STRING DSeviSaved-Bur-1
21645: PPUSH
21646: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-1 ) ;
21650: LD_EXP 11
21654: PPUSH
21655: LD_STRING DSeviSaved-Vse-1
21657: PPUSH
21658: CALL_OW 88
// Say ( Burlak , DSeviSaved-Bur-2 ) ;
21662: LD_EXP 10
21666: PPUSH
21667: LD_STRING DSeviSaved-Bur-2
21669: PPUSH
21670: CALL_OW 88
// Say ( Vsevolod , DSeviSaved-Vse-2 ) ;
21674: LD_EXP 11
21678: PPUSH
21679: LD_STRING DSeviSaved-Vse-2
21681: PPUSH
21682: CALL_OW 88
// end ;
21686: LD_VAR 0 1
21690: RET
// export function dialog_MeetXavier ; begin
21691: LD_INT 0
21693: PPUSH
// Say ( Xavier , DMeetXavier-Xav-1 ) ;
21694: LD_EXP 25
21698: PPUSH
21699: LD_STRING DMeetXavier-Xav-1
21701: PPUSH
21702: CALL_OW 88
// Say ( Yelena , DMeetXavier-Kir-1 ) ;
21706: LD_EXP 13
21710: PPUSH
21711: LD_STRING DMeetXavier-Kir-1
21713: PPUSH
21714: CALL_OW 88
// Say ( Xavier , DMeetXavier-Xav-2 ) ;
21718: LD_EXP 25
21722: PPUSH
21723: LD_STRING DMeetXavier-Xav-2
21725: PPUSH
21726: CALL_OW 88
// end ;
21730: LD_VAR 0 1
21734: RET
// export function query_Xavier ; begin
21735: LD_INT 0
21737: PPUSH
// Result = Query ( QXavier ) ;
21738: LD_ADDR_VAR 0 1
21742: PUSH
21743: LD_STRING QXavier
21745: PPUSH
21746: CALL_OW 97
21750: ST_TO_ADDR
// end ;
21751: LD_VAR 0 1
21755: RET
// export function dialog_QrXavier1 ; begin
21756: LD_INT 0
21758: PPUSH
// Say ( Burlak , DQrXavier#1-Bur-1 ) ;
21759: LD_EXP 10
21763: PPUSH
21764: LD_STRING DQrXavier#1-Bur-1
21766: PPUSH
21767: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-1 ) ;
21771: LD_EXP 13
21775: PPUSH
21776: LD_STRING DQrXavier#1-Kir-1
21778: PPUSH
21779: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-1 ) ;
21783: LD_EXP 25
21787: PPUSH
21788: LD_STRING DQrXavier#1-Xav-1
21790: PPUSH
21791: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-2 ) ;
21795: LD_EXP 13
21799: PPUSH
21800: LD_STRING DQrXavier#1-Kir-2
21802: PPUSH
21803: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-2 ) ;
21807: LD_EXP 25
21811: PPUSH
21812: LD_STRING DQrXavier#1-Xav-2
21814: PPUSH
21815: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-3 ) ;
21819: LD_EXP 13
21823: PPUSH
21824: LD_STRING DQrXavier#1-Kir-3
21826: PPUSH
21827: CALL_OW 88
// Say ( Xavier , DQrXavier#1-Xav-3 ) ;
21831: LD_EXP 25
21835: PPUSH
21836: LD_STRING DQrXavier#1-Xav-3
21838: PPUSH
21839: CALL_OW 88
// Say ( Yelena , DQrXavier#1-Kir-4 ) ;
21843: LD_EXP 13
21847: PPUSH
21848: LD_STRING DQrXavier#1-Kir-4
21850: PPUSH
21851: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
21855: LD_EXP 14
21859: PUSH
21860: LD_EXP 14
21864: PPUSH
21865: CALL_OW 302
21869: AND
21870: IFFALSE 21884
// Say ( Gleb , DQrXavier#1-Glb-4 ) ;
21872: LD_EXP 14
21876: PPUSH
21877: LD_STRING DQrXavier#1-Glb-4
21879: PPUSH
21880: CALL_OW 88
// end ;
21884: LD_VAR 0 1
21888: RET
// export function dialog_QrXavier2 ; begin
21889: LD_INT 0
21891: PPUSH
// Say ( Burlak , DQrXavier#2-Bur-1 ) ;
21892: LD_EXP 10
21896: PPUSH
21897: LD_STRING DQrXavier#2-Bur-1
21899: PPUSH
21900: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-1 ) ;
21904: LD_EXP 13
21908: PPUSH
21909: LD_STRING DQrXavier#2-Kir-1
21911: PPUSH
21912: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-1 ) ;
21916: LD_EXP 25
21920: PPUSH
21921: LD_STRING DQrXavier#2-Xav-1
21923: PPUSH
21924: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-2 ) ;
21928: LD_EXP 13
21932: PPUSH
21933: LD_STRING DQrXavier#2-Kir-2
21935: PPUSH
21936: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-2 ) ;
21940: LD_EXP 25
21944: PPUSH
21945: LD_STRING DQrXavier#2-Xav-2
21947: PPUSH
21948: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-3 ) ;
21952: LD_EXP 13
21956: PPUSH
21957: LD_STRING DQrXavier#2-Kir-3
21959: PPUSH
21960: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-3 ) ;
21964: LD_EXP 25
21968: PPUSH
21969: LD_STRING DQrXavier#2-Xav-3
21971: PPUSH
21972: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-4 ) ;
21976: LD_EXP 13
21980: PPUSH
21981: LD_STRING DQrXavier#2-Kir-4
21983: PPUSH
21984: CALL_OW 88
// Say ( Xavier , DQrXavier#2-Xav-4 ) ;
21988: LD_EXP 25
21992: PPUSH
21993: LD_STRING DQrXavier#2-Xav-4
21995: PPUSH
21996: CALL_OW 88
// Say ( Yelena , DQrXavier#2-Kir-5 ) ;
22000: LD_EXP 13
22004: PPUSH
22005: LD_STRING DQrXavier#2-Kir-5
22007: PPUSH
22008: CALL_OW 88
// if Gleb and IsOK ( Gleb ) then
22012: LD_EXP 14
22016: PUSH
22017: LD_EXP 14
22021: PPUSH
22022: CALL_OW 302
22026: AND
22027: IFFALSE 22041
// Say ( Gleb , DQrXavier#2-Glb-5 ) ;
22029: LD_EXP 14
22033: PPUSH
22034: LD_STRING DQrXavier#2-Glb-5
22036: PPUSH
22037: CALL_OW 88
// end ;
22041: LD_VAR 0 1
22045: RET
// export function dialog_PointXavier ; begin
22046: LD_INT 0
22048: PPUSH
// if IsOk ( Yelena ) then
22049: LD_EXP 13
22053: PPUSH
22054: CALL_OW 302
22058: IFFALSE 22084
// begin Say ( Xavier , DPointXavier-Xav-1 ) ;
22060: LD_EXP 25
22064: PPUSH
22065: LD_STRING DPointXavier-Xav-1
22067: PPUSH
22068: CALL_OW 88
// Say ( Yelena , DPointXavier-Kir-1 ) ;
22072: LD_EXP 13
22076: PPUSH
22077: LD_STRING DPointXavier-Kir-1
22079: PPUSH
22080: CALL_OW 88
// end ; Say ( Xavier , DPointXavier-Xav-2 ) ;
22084: LD_EXP 25
22088: PPUSH
22089: LD_STRING DPointXavier-Xav-2
22091: PPUSH
22092: CALL_OW 88
// end ;
22096: LD_VAR 0 1
22100: RET
// export function query_QActivateXavier ; begin
22101: LD_INT 0
22103: PPUSH
// Result = Query ( QActivateXavier ) ;
22104: LD_ADDR_VAR 0 1
22108: PUSH
22109: LD_STRING QActivateXavier
22111: PPUSH
22112: CALL_OW 97
22116: ST_TO_ADDR
// end ;
22117: LD_VAR 0 1
22121: RET
// export function dialog_QrActivateXavier1 ; begin
22122: LD_INT 0
22124: PPUSH
// Say ( Burlak , DQrActivateXavier#1-Bur-1 ) ;
22125: LD_EXP 10
22129: PPUSH
22130: LD_STRING DQrActivateXavier#1-Bur-1
22132: PPUSH
22133: CALL_OW 88
// end ;
22137: LD_VAR 0 1
22141: RET
// export function dialog_QrActivateXavier2 ; begin
22142: LD_INT 0
22144: PPUSH
// Say ( Burlak , DQrActivateXavier#2-Bur-1 ) ;
22145: LD_EXP 10
22149: PPUSH
22150: LD_STRING DQrActivateXavier#2-Bur-1
22152: PPUSH
22153: CALL_OW 88
// end ;
22157: LD_VAR 0 1
22161: RET
// export function dialog_YashinArrives ; begin
22162: LD_INT 0
22164: PPUSH
// Say ( Yashin , DYashinArrives-Yas-1 ) ;
22165: LD_EXP 34
22169: PPUSH
22170: LD_STRING DYashinArrives-Yas-1
22172: PPUSH
22173: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22177: LD_EXP 8
22181: PUSH
22182: LD_EXP 11
22186: PPUSH
22187: CALL_OW 302
22191: AND
22192: IFFALSE 22208
// Say ( Vsevolod , DYashinArrives-Vse-1 ) else
22194: LD_EXP 11
22198: PPUSH
22199: LD_STRING DYashinArrives-Vse-1
22201: PPUSH
22202: CALL_OW 88
22206: GO 22220
// Say ( Burlak , DYashinArrives-Bur-1 ) ;
22208: LD_EXP 10
22212: PPUSH
22213: LD_STRING DYashinArrives-Bur-1
22215: PPUSH
22216: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-2 ) ;
22220: LD_EXP 34
22224: PPUSH
22225: LD_STRING DYashinArrives-Yas-2
22227: PPUSH
22228: CALL_OW 88
// if VsevSaved and IsOk ( Vsevolod ) then
22232: LD_EXP 8
22236: PUSH
22237: LD_EXP 11
22241: PPUSH
22242: CALL_OW 302
22246: AND
22247: IFFALSE 22287
// begin Say ( Vsevolod , DYashinArrives-Vse-2 ) ;
22249: LD_EXP 11
22253: PPUSH
22254: LD_STRING DYashinArrives-Vse-2
22256: PPUSH
22257: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-3 ) ;
22261: LD_EXP 34
22265: PPUSH
22266: LD_STRING DYashinArrives-Yas-3
22268: PPUSH
22269: CALL_OW 88
// Say ( Vsevolod , DYashinArrives-Vse-3 ) ;
22273: LD_EXP 11
22277: PPUSH
22278: LD_STRING DYashinArrives-Vse-3
22280: PPUSH
22281: CALL_OW 88
// end else
22285: GO 22335
// begin Say ( Burlak , DYashinArrives-Bur-3 ) ;
22287: LD_EXP 10
22291: PPUSH
22292: LD_STRING DYashinArrives-Bur-3
22294: PPUSH
22295: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-4 ) ;
22299: LD_EXP 34
22303: PPUSH
22304: LD_STRING DYashinArrives-Yas-4
22306: PPUSH
22307: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-4 ) ;
22311: LD_EXP 10
22315: PPUSH
22316: LD_STRING DYashinArrives-Bur-4
22318: PPUSH
22319: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-5 ) ;
22323: LD_EXP 34
22327: PPUSH
22328: LD_STRING DYashinArrives-Yas-5
22330: PPUSH
22331: CALL_OW 88
// end ; Say ( Burlak , DYashinArrives-Bur-5 ) ;
22335: LD_EXP 10
22339: PPUSH
22340: LD_STRING DYashinArrives-Bur-5
22342: PPUSH
22343: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-6 ) ;
22347: LD_EXP 34
22351: PPUSH
22352: LD_STRING DYashinArrives-Yas-6
22354: PPUSH
22355: CALL_OW 88
// Say ( Burlak , DYashinArrives-Bur-6 ) ;
22359: LD_EXP 10
22363: PPUSH
22364: LD_STRING DYashinArrives-Bur-6
22366: PPUSH
22367: CALL_OW 88
// Say ( Yashin , DYashinArrives-Yas-7 ) ;
22371: LD_EXP 34
22375: PPUSH
22376: LD_STRING DYashinArrives-Yas-7
22378: PPUSH
22379: CALL_OW 88
// end ;
22383: LD_VAR 0 1
22387: RET
// export function query_YashinHelp ; begin
22388: LD_INT 0
22390: PPUSH
// Result = Query ( QYashinHelp ) ;
22391: LD_ADDR_VAR 0 1
22395: PUSH
22396: LD_STRING QYashinHelp
22398: PPUSH
22399: CALL_OW 97
22403: ST_TO_ADDR
// end ;
22404: LD_VAR 0 1
22408: RET
// export function query_YashinHelpNB ; begin
22409: LD_INT 0
22411: PPUSH
// Result = SelectiveQuery ( QYashinHelp , [ 2 , 3 ] ) ;
22412: LD_ADDR_VAR 0 1
22416: PUSH
22417: LD_STRING QYashinHelp
22419: PPUSH
22420: LD_INT 2
22422: PUSH
22423: LD_INT 3
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PPUSH
22430: CALL_OW 98
22434: ST_TO_ADDR
// end ;
22435: LD_VAR 0 1
22439: RET
// export function dialog_QrYashinHelp1 ; begin
22440: LD_INT 0
22442: PPUSH
// Say ( Burlak , DQrYashinHelp#1-Bur-1 ) ;
22443: LD_EXP 10
22447: PPUSH
22448: LD_STRING DQrYashinHelp#1-Bur-1
22450: PPUSH
22451: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-1 ) ;
22455: LD_EXP 34
22459: PPUSH
22460: LD_STRING DQrYashinHelp#1-Yas-1
22462: PPUSH
22463: CALL_OW 88
// Say ( Burlak , DQrYashinHelp#1-Bur-2 ) ;
22467: LD_EXP 10
22471: PPUSH
22472: LD_STRING DQrYashinHelp#1-Bur-2
22474: PPUSH
22475: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#1-Yas-2 ) ;
22479: LD_EXP 34
22483: PPUSH
22484: LD_STRING DQrYashinHelp#1-Yas-2
22486: PPUSH
22487: CALL_OW 88
// end ;
22491: LD_VAR 0 1
22495: RET
// export function dialog_QrYashinHelp2 ; begin
22496: LD_INT 0
22498: PPUSH
// Say ( Burlak , DQrYashinHelp#2-Bur-1 ) ;
22499: LD_EXP 10
22503: PPUSH
22504: LD_STRING DQrYashinHelp#2-Bur-1
22506: PPUSH
22507: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#2-Yas-1 ) ;
22511: LD_EXP 34
22515: PPUSH
22516: LD_STRING DQrYashinHelp#2-Yas-1
22518: PPUSH
22519: CALL_OW 88
// end ;
22523: LD_VAR 0 1
22527: RET
// export function dialog_QrYashinHelp3 ; begin
22528: LD_INT 0
22530: PPUSH
// Say ( Burlak , DQrYashinHelp#3-Bur-1 ) ;
22531: LD_EXP 10
22535: PPUSH
22536: LD_STRING DQrYashinHelp#3-Bur-1
22538: PPUSH
22539: CALL_OW 88
// Say ( Yashin , DQrYashinHelp#3-Yas-1 ) ;
22543: LD_EXP 34
22547: PPUSH
22548: LD_STRING DQrYashinHelp#3-Yas-1
22550: PPUSH
22551: CALL_OW 88
// end ;
22555: LD_VAR 0 1
22559: RET
// var BylHint ; export function dialog_YashinLeave ; begin
22560: LD_INT 0
22562: PPUSH
// Say ( Yashin , DYashinLeave-Yas-1 ) ;
22563: LD_EXP 34
22567: PPUSH
22568: LD_STRING DYashinLeave-Yas-1
22570: PPUSH
22571: CALL_OW 88
// Say ( Burlak , DYashinLeave-Bur-1 ) ;
22575: LD_EXP 10
22579: PPUSH
22580: LD_STRING DYashinLeave-Bur-1
22582: PPUSH
22583: CALL_OW 88
// if not BylHint then
22587: LD_LOC 56
22591: NOT
22592: IFFALSE 22609
// begin Hint ( YashinVeh ) ;
22594: LD_STRING YashinVeh
22596: PPUSH
22597: CALL_OW 339
// BylHint = true ;
22601: LD_ADDR_LOC 56
22605: PUSH
22606: LD_INT 1
22608: ST_TO_ADDR
// end ; end ;
22609: LD_VAR 0 1
22613: RET
// export function dialog_YashinAttack ; begin
22614: LD_INT 0
22616: PPUSH
// Say ( Burlak , DYashinAttack-Bur-1 ) ;
22617: LD_EXP 10
22621: PPUSH
22622: LD_STRING DYashinAttack-Bur-1
22624: PPUSH
22625: CALL_OW 88
// end ;
22629: LD_VAR 0 1
22633: RET
// export function dialog_HeikeObj ; begin
22634: LD_INT 0
22636: PPUSH
// SayRadio ( Popov , DHeikeObj-Pop-1 ) ;
22637: LD_EXP 12
22641: PPUSH
22642: LD_STRING DHeikeObj-Pop-1
22644: PPUSH
22645: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-1 ) ;
22649: LD_EXP 10
22653: PPUSH
22654: LD_STRING DHeikeObj-Bur-1
22656: PPUSH
22657: CALL_OW 88
// SayRadio ( Popov , DHeikeObj-Pop-2 ) ;
22661: LD_EXP 12
22665: PPUSH
22666: LD_STRING DHeikeObj-Pop-2
22668: PPUSH
22669: CALL_OW 94
// Say ( Burlak , DHeikeObj-Bur-2 ) ;
22673: LD_EXP 10
22677: PPUSH
22678: LD_STRING DHeikeObj-Bur-2
22680: PPUSH
22681: CALL_OW 88
// end ;
22685: LD_VAR 0 1
22689: RET
// export function dialog_HeikeCapt ; begin
22690: LD_INT 0
22692: PPUSH
// Say ( Heike , DHeikeCapt-Hke-1 ) ;
22693: LD_EXP 26
22697: PPUSH
22698: LD_STRING DHeikeCapt-Hke-1
22700: PPUSH
22701: CALL_OW 88
// Say ( Burlak , DHeikeCapt-Bur-1 ) ;
22705: LD_EXP 10
22709: PPUSH
22710: LD_STRING DHeikeCapt-Bur-1
22712: PPUSH
22713: CALL_OW 88
// Say ( Heike , DHeikeCapt-Hke-2 ) ;
22717: LD_EXP 26
22721: PPUSH
22722: LD_STRING DHeikeCapt-Hke-2
22724: PPUSH
22725: CALL_OW 88
// end ; end_of_file
22729: LD_VAR 0 1
22733: RET
// every 0 0$2 + 0 0$0.1 do
22734: GO 22736
22736: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
22737: LD_INT 22
22739: PUSH
22740: LD_INT 3
22742: PUSH
22743: EMPTY
22744: LIST
22745: LIST
22746: PUSH
22747: LD_INT 2
22749: PUSH
22750: LD_INT 25
22752: PUSH
22753: LD_INT 12
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PUSH
22760: LD_INT 25
22762: PUSH
22763: LD_INT 16
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: LD_INT 25
22772: PUSH
22773: LD_INT 15
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 25
22782: PUSH
22783: LD_INT 17
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: LIST
22795: LIST
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PPUSH
22801: CALL_OW 69
22805: PUSH
22806: LD_INT 22
22808: PUSH
22809: LD_INT 3
22811: PUSH
22812: EMPTY
22813: LIST
22814: LIST
22815: PUSH
22816: LD_INT 21
22818: PUSH
22819: LD_INT 1
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: PUSH
22826: LD_INT 3
22828: PUSH
22829: LD_INT 2
22831: PUSH
22832: LD_INT 25
22834: PUSH
22835: LD_INT 12
22837: PUSH
22838: EMPTY
22839: LIST
22840: LIST
22841: PUSH
22842: LD_INT 25
22844: PUSH
22845: LD_INT 16
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PUSH
22852: LD_INT 25
22854: PUSH
22855: LD_INT 15
22857: PUSH
22858: EMPTY
22859: LIST
22860: LIST
22861: PUSH
22862: LD_INT 25
22864: PUSH
22865: LD_INT 17
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: LIST
22887: PPUSH
22888: CALL_OW 69
22892: GREATER
22893: IFFALSE 22904
// begin SetAchievement ( ACH_POTA ) ;
22895: LD_STRING ACH_POTA
22897: PPUSH
22898: CALL_OW 543
// exit ;
22902: GO 22905
// end ; enable ;
22904: ENABLE
// end ;
22905: END
// export function SA_LieXavier ; begin
22906: LD_INT 0
22908: PPUSH
// SetAchievement ( ACH_LIA ) ;
22909: LD_STRING ACH_LIA
22911: PPUSH
22912: CALL_OW 543
// end ; end_of_file
22916: LD_VAR 0 1
22920: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
22921: LD_INT 0
22923: PPUSH
22924: PPUSH
// if not missionNumber then
22925: LD_VAR 0 2
22929: NOT
22930: IFFALSE 22934
// exit ;
22932: GO 23064
// achiv := false ;
22934: LD_ADDR_VAR 0 7
22938: PUSH
22939: LD_INT 0
22941: ST_TO_ADDR
// case campaignNumber of 1 :
22942: LD_VAR 0 1
22946: PUSH
22947: LD_INT 1
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22966
22955: POP
// achiv := ACH_GOTA ; 2 :
22956: LD_ADDR_VAR 0 7
22960: PUSH
22961: LD_STRING ACH_GOTA
22963: ST_TO_ADDR
22964: GO 23016
22966: LD_INT 2
22968: DOUBLE
22969: EQUAL
22970: IFTRUE 22974
22972: GO 22977
22974: POP
// ; 3 :
22975: GO 23016
22977: LD_INT 3
22979: DOUBLE
22980: EQUAL
22981: IFTRUE 22985
22983: GO 22996
22985: POP
// achiv := ACH_MOTSU ; 4 :
22986: LD_ADDR_VAR 0 7
22990: PUSH
22991: LD_STRING ACH_MOTSU
22993: ST_TO_ADDR
22994: GO 23016
22996: LD_INT 4
22998: DOUBLE
22999: EQUAL
23000: IFTRUE 23004
23002: GO 23015
23004: POP
// achiv := ACH_LOP ; end ;
23005: LD_ADDR_VAR 0 7
23009: PUSH
23010: LD_STRING ACH_LOP
23012: ST_TO_ADDR
23013: GO 23016
23015: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
23016: LD_OWVAR 67
23020: PUSH
23021: LD_INT 3
23023: EQUAL
23024: PUSH
23025: LD_VAR 0 7
23029: AND
23030: PUSH
23031: LD_VAR 0 3
23035: AND
23036: PUSH
23037: LD_VAR 0 4
23041: AND
23042: PUSH
23043: LD_VAR 0 5
23047: AND
23048: IFFALSE 23064
// SetAchievementEX ( achiv , missionNumber ) ;
23050: LD_VAR 0 7
23054: PPUSH
23055: LD_VAR 0 2
23059: PPUSH
23060: CALL_OW 564
// end ;
23064: LD_VAR 0 6
23068: RET
// export function SA_BehemothConstructed ; begin
23069: LD_INT 0
23071: PPUSH
// SetAchievement ( ACH_SMC ) ;
23072: LD_STRING ACH_SMC
23074: PPUSH
23075: CALL_OW 543
// end ;
23079: LD_VAR 0 1
23083: RET

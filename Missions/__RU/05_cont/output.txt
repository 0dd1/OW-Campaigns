// export you , americans , arabians , neutral , you2 ; export rulive , apemans ; export DefendLast ; export action_was_fast , breaked_trough ; export Stevens_killed ; export wait_while ; export mcdef_difficulty ; export depot ; export mezera_mezi_minami ; export pocet_min ; export breaketrough_time ; export first_attack ; export sol , mor , sci , mec , eng , rmec ; export cargo , scout , attack , defence , remote ; export to_defence , to_attack , to_scout , to_cargo , to_remote ; export vodni_utok , normal1_utok , normal2_utok , normal3_utok , normal4_utok ; export fact1 , dep1 , lab1 ; export fort ; export ape_agress ; export first_apeman_tamed ; export dialogy , canlost , debug ; export StevensStayInBase ; starting begin dialogy := true ;
   0: LD_ADDR_EXP 46
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// canlost := true ;
   8: LD_ADDR_EXP 47
  12: PUSH
  13: LD_INT 1
  15: ST_TO_ADDR
// debug := false ;
  16: LD_ADDR_EXP 48
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// disable ( 99 ) ;
  24: LD_INT 99
  26: DISABLE_MARKED
// stevens_killed := false ;
  27: LD_ADDR_EXP 11
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// StevensStayInBase = 0 ;
  35: LD_ADDR_EXP 49
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// RemoveUnit ( Mastodon ) ;
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 64
// set_sides ;
  50: CALL 253 0 0
// set_difficulty ;
  54: CALL 96 0 0
// load_chars ;
  58: CALL 757 0 0
// place_apes ;
  62: CALL 1454 0 0
// place_in_ru_cars ;
  66: CALL 1115 0 0
// place_ru_cars ( ru_place2 ) ;
  70: LD_INT 18
  72: PPUSH
  73: CALL 1734 0 1
// create_arabs_scout ;
  77: CALL 19715 0 0
// if dialogy then
  81: LD_EXP 46
  85: IFFALSE 91
// DIntro ;
  87: CALL 2633 0 0
// place_arabs_base ;
  91: CALL 10095 0 0
// end ;
  95: END
// function set_difficulty ; begin
  96: LD_INT 0
  98: PPUSH
// mcdef_difficulty := [ 170 , 200 , 130 ] [ difficulty ] ;
  99: LD_ADDR_EXP 13
 103: PUSH
 104: LD_INT 170
 106: PUSH
 107: LD_INT 200
 109: PUSH
 110: LD_INT 130
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: ST_TO_ADDR
// breaketrough_time := [ 72 72$0 , 55 55$0 , 35 35$0 ] [ difficulty ] ;
 124: LD_ADDR_EXP 17
 128: PUSH
 129: LD_INT 151200
 131: PUSH
 132: LD_INT 115500
 134: PUSH
 135: LD_INT 73500
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: PUSH
 143: LD_OWVAR 67
 147: ARRAY
 148: ST_TO_ADDR
// mezera_mezi_minami := [ 4 4$0 , 2 2$0 , 1 1$0 ] [ difficulty ] ;
 149: LD_ADDR_EXP 15
 153: PUSH
 154: LD_INT 8400
 156: PUSH
 157: LD_INT 4200
 159: PUSH
 160: LD_INT 2100
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: ST_TO_ADDR
// pocet_min := [ 1 , 2 , 3 ] [ difficulty ] ;
 174: LD_ADDR_EXP 16
 178: PUSH
 179: LD_INT 1
 181: PUSH
 182: LD_INT 2
 184: PUSH
 185: LD_INT 3
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// ape_agress := [ [ - 15 , - 10 ] , [ - 2 , 2 ] , [ 2 , 15 ] ] [ difficulty ] ;
 199: LD_ADDR_EXP 44
 203: PUSH
 204: LD_INT 15
 206: NEG
 207: PUSH
 208: LD_INT 10
 210: NEG
 211: PUSH
 212: EMPTY
 213: LIST
 214: LIST
 215: PUSH
 216: LD_INT 2
 218: NEG
 219: PUSH
 220: LD_INT 2
 222: PUSH
 223: EMPTY
 224: LIST
 225: LIST
 226: PUSH
 227: LD_INT 2
 229: PUSH
 230: LD_INT 15
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: PUSH
 242: LD_OWVAR 67
 246: ARRAY
 247: ST_TO_ADDR
// end ;
 248: LD_VAR 0 1
 252: RET
// function set_sides ; begin
 253: LD_INT 0
 255: PPUSH
// you := 3 ;
 256: LD_ADDR_EXP 1
 260: PUSH
 261: LD_INT 3
 263: ST_TO_ADDR
// you2 := 6 ;
 264: LD_ADDR_EXP 5
 268: PUSH
 269: LD_INT 6
 271: ST_TO_ADDR
// americans := 1 ;
 272: LD_ADDR_EXP 2
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// arabians := 2 ;
 280: LD_ADDR_EXP 3
 284: PUSH
 285: LD_INT 2
 287: ST_TO_ADDR
// neutral := 0 ;
 288: LD_ADDR_EXP 4
 292: PUSH
 293: LD_INT 0
 295: ST_TO_ADDR
// end ;
 296: LD_VAR 0 1
 300: RET
// export function Vyhra ; begin
 301: LD_INT 0
 303: PPUSH
// set_medals ;
 304: CALL 374 0 0
// GiveMedals ( Main ) ;
 308: LD_STRING Main
 310: PPUSH
 311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ) ;
 315: LD_INT 22
 317: PUSH
 318: LD_EXP 1
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PUSH
 327: LD_INT 21
 329: PUSH
 330: LD_INT 1
 332: PUSH
 333: EMPTY
 334: LIST
 335: LIST
 336: PUSH
 337: LD_INT 23
 339: PUSH
 340: LD_INT 3
 342: PUSH
 343: EMPTY
 344: LIST
 345: LIST
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: PPUSH
 352: CALL_OW 69
 356: PPUSH
 357: CALL_OW 43
// Save ;
 361: CALL 1949 0 0
// YouWin ;
 365: CALL_OW 103
// end ;
 369: LD_VAR 0 1
 373: RET
// export function set_medals ; begin
 374: LD_INT 0
 376: PPUSH
// AddMedal ( Time , action_was_fast ) ;
 377: LD_STRING Time
 379: PPUSH
 380: LD_EXP 9
 384: PPUSH
 385: CALL_OW 101
// if first_apeman_tamed then
 389: LD_EXP 45
 393: IFFALSE 407
// AddMedal ( Apemen , 1 ) else
 395: LD_STRING Apemen
 397: PPUSH
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 101
 405: GO 449
// begin if GetTech ( tech_ApeLang , you ) = state_researched then
 407: LD_INT 1
 409: PPUSH
 410: LD_EXP 1
 414: PPUSH
 415: CALL_OW 321
 419: PUSH
 420: LD_INT 2
 422: EQUAL
 423: IFFALSE 438
// AddMedal ( Apemen , - 1 ) else
 425: LD_STRING Apemen
 427: PPUSH
 428: LD_INT 1
 430: NEG
 431: PPUSH
 432: CALL_OW 101
 436: GO 449
// AddMedal ( Apemen , - 2 ) ;
 438: LD_STRING Apemen
 440: PPUSH
 441: LD_INT 2
 443: NEG
 444: PPUSH
 445: CALL_OW 101
// end ; AddMedal ( Abdul , IsDead ( Omar ) ) ;
 449: LD_STRING Abdul
 451: PPUSH
 452: LD_EXP 61
 456: PPUSH
 457: CALL_OW 301
 461: PPUSH
 462: CALL_OW 101
// end ;
 466: LD_VAR 0 1
 470: RET
// every 0 0$7 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) < 6 do
 471: LD_INT 22
 473: PUSH
 474: LD_EXP 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: LD_INT 21
 485: PUSH
 486: LD_INT 1
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 23
 495: PUSH
 496: LD_INT 3
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: PPUSH
 508: CALL_OW 69
 512: PUSH
 513: LD_INT 6
 515: LESS
 516: IFFALSE 534
 518: GO 520
 520: DISABLE
// begin if canlost then
 521: LD_EXP 47
 525: IFFALSE 534
// YouLost ( Survive ) ;
 527: LD_STRING Survive
 529: PPUSH
 530: CALL_OW 104
// end ;
 534: END
// every 0 0$1 do
 535: GO 537
 537: DISABLE
// begin if debug then
 538: LD_EXP 48
 542: IFFALSE 755
// display_strings := [ [ cas:  & ( tick div 1 1$0 ) & : & ( ( tick mod 1 1$0 ) div 0 0$1 ) ] , [ mines , mines ] , [ crates , crates ] , [ attack , attack ] , [ defence , defence ] , [ sol , sol ] , [ mor , mor ] , [ eng , eng ] , [ mec , mec ] , [ sci , sci ] , [ brk_cars , brk_cars ] , [ opravit , opravit ] , [ stavi , stavi ] , [ todef1 , todef1 ] ] ;
 544: LD_ADDR_OWVAR 47
 548: PUSH
 549: LD_STRING cas: 
 551: PUSH
 552: LD_OWVAR 1
 556: PUSH
 557: LD_INT 2100
 559: DIV
 560: STR
 561: PUSH
 562: LD_STRING :
 564: STR
 565: PUSH
 566: LD_OWVAR 1
 570: PUSH
 571: LD_INT 2100
 573: MOD
 574: PUSH
 575: LD_INT 35
 577: DIV
 578: STR
 579: PUSH
 580: EMPTY
 581: LIST
 582: PUSH
 583: LD_STRING mines
 585: PUSH
 586: LD_EXP 72
 590: PUSH
 591: EMPTY
 592: LIST
 593: LIST
 594: PUSH
 595: LD_STRING crates
 597: PUSH
 598: LD_EXP 85
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: PUSH
 607: LD_STRING attack
 609: PUSH
 610: LD_EXP 27
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: PUSH
 619: LD_STRING defence
 621: PUSH
 622: LD_EXP 28
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: PUSH
 631: LD_STRING sol
 633: PUSH
 634: LD_EXP 19
 638: PUSH
 639: EMPTY
 640: LIST
 641: LIST
 642: PUSH
 643: LD_STRING mor
 645: PUSH
 646: LD_EXP 20
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: PUSH
 655: LD_STRING eng
 657: PUSH
 658: LD_EXP 23
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: PUSH
 667: LD_STRING mec
 669: PUSH
 670: LD_EXP 22
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: PUSH
 679: LD_STRING sci
 681: PUSH
 682: LD_EXP 21
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: PUSH
 691: LD_STRING brk_cars
 693: PUSH
 694: LD_EXP 74
 698: PUSH
 699: EMPTY
 700: LIST
 701: LIST
 702: PUSH
 703: LD_STRING opravit
 705: PUSH
 706: LD_EXP 73
 710: PUSH
 711: EMPTY
 712: LIST
 713: LIST
 714: PUSH
 715: LD_STRING stavi
 717: PUSH
 718: LD_EXP 68
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: PUSH
 727: LD_STRING todef1
 729: PUSH
 730: LD_EXP 83
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: ST_TO_ADDR
// enable ;
 755: ENABLE
// end ; end_of_file
 756: END
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Stevens , Heike , Omar ; export used , ru_cars ; export function load_chars ; var i ; begin
 757: LD_INT 0
 759: PPUSH
 760: PPUSH
// InitUc ;
 761: CALL_OW 18
// InitHc ;
 765: CALL_OW 19
// uc_side := you ;
 769: LD_ADDR_OWVAR 20
 773: PUSH
 774: LD_EXP 1
 778: ST_TO_ADDR
// uc_nation := nation_russian ;
 779: LD_ADDR_OWVAR 21
 783: PUSH
 784: LD_INT 3
 786: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
 787: LD_ADDR_EXP 51
 791: PUSH
 792: LD_STRING Platonov
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 1
 800: PPUSH
 801: CALL 1777 0 3
 805: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
 806: LD_ADDR_EXP 50
 810: PUSH
 811: LD_STRING Burlak
 813: PPUSH
 814: LD_INT 3
 816: PPUSH
 817: LD_INT 0
 819: PPUSH
 820: CALL 1777 0 3
 824: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , class_soldier , true ) ;
 825: LD_ADDR_EXP 56
 829: PUSH
 830: LD_STRING Titov
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL 1777 0 3
 843: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , class_scientistic , true ) ;
 844: LD_ADDR_EXP 57
 848: PUSH
 849: LD_STRING Dolgov
 851: PPUSH
 852: LD_INT 4
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: CALL 1777 0 3
 862: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , class_soldier , true ) ;
 863: LD_ADDR_EXP 58
 867: PUSH
 868: LD_STRING Lipshchin
 870: PPUSH
 871: LD_INT 1
 873: PPUSH
 874: LD_INT 1
 876: PPUSH
 877: CALL 1777 0 3
 881: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , class_engineer , true ) ;
 882: LD_ADDR_EXP 52
 886: PUSH
 887: LD_STRING Karamazov
 889: PPUSH
 890: LD_INT 2
 892: PPUSH
 893: LD_INT 1
 895: PPUSH
 896: CALL 1777 0 3
 900: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , class_soldier , true ) ;
 901: LD_ADDR_EXP 53
 905: PUSH
 906: LD_STRING Petrovova
 908: PPUSH
 909: LD_INT 1
 911: PPUSH
 912: LD_INT 1
 914: PPUSH
 915: CALL 1777 0 3
 919: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , true ) ;
 920: LD_ADDR_EXP 54
 924: PUSH
 925: LD_STRING Gleb
 927: PPUSH
 928: LD_INT 1
 930: PPUSH
 931: LD_INT 1
 933: PPUSH
 934: CALL 1777 0 3
 938: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , class_scientistic , true ) ;
 939: LD_ADDR_EXP 55
 943: PUSH
 944: LD_STRING Petrosyan
 946: PPUSH
 947: LD_INT 4
 949: PPUSH
 950: LD_INT 1
 952: PPUSH
 953: CALL 1777 0 3
 957: ST_TO_ADDR
// used := [ Burlak , Lipshchin , Titov , Dolgov , Karamazov , Petrovova , Gleb , Petrosyan ] diff 0 ;
 958: LD_ADDR_EXP 62
 962: PUSH
 963: LD_EXP 50
 967: PUSH
 968: LD_EXP 58
 972: PUSH
 973: LD_EXP 56
 977: PUSH
 978: LD_EXP 57
 982: PUSH
 983: LD_EXP 52
 987: PUSH
 988: LD_EXP 53
 992: PUSH
 993: LD_EXP 54
 997: PUSH
 998: LD_EXP 55
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: PUSH
1013: LD_INT 0
1015: DIFF
1016: ST_TO_ADDR
// uc_side := americans ;
1017: LD_ADDR_OWVAR 20
1021: PUSH
1022: LD_EXP 2
1026: ST_TO_ADDR
// uc_nation := nation_american ;
1027: LD_ADDR_OWVAR 21
1031: PUSH
1032: LD_INT 1
1034: ST_TO_ADDR
// Stevens := MyCreateCharacter ( Stevens , class_scientistic , true ) ;
1035: LD_ADDR_EXP 59
1039: PUSH
1040: LD_STRING Stevens
1042: PPUSH
1043: LD_INT 4
1045: PPUSH
1046: LD_INT 1
1048: PPUSH
1049: CALL 1777 0 3
1053: ST_TO_ADDR
// uc_side := arabians ;
1054: LD_ADDR_OWVAR 20
1058: PUSH
1059: LD_EXP 3
1063: ST_TO_ADDR
// uc_nation := nation_arabian ;
1064: LD_ADDR_OWVAR 21
1068: PUSH
1069: LD_INT 2
1071: ST_TO_ADDR
// Heike := MyCreateCharacter ( Heike , class_soldier , true ) ;
1072: LD_ADDR_EXP 60
1076: PUSH
1077: LD_STRING Heike
1079: PPUSH
1080: LD_INT 1
1082: PPUSH
1083: LD_INT 1
1085: PPUSH
1086: CALL 1777 0 3
1090: ST_TO_ADDR
// Omar := MyCreateCharacter ( Omar , class_desert_warior , true ) ;
1091: LD_ADDR_EXP 61
1095: PUSH
1096: LD_STRING Omar
1098: PPUSH
1099: LD_INT 11
1101: PPUSH
1102: LD_INT 1
1104: PPUSH
1105: CALL 1777 0 3
1109: ST_TO_ADDR
// end ;
1110: LD_VAR 0 1
1114: RET
// export function place_in_ru_cars ; var cars , car , i ; begin
1115: LD_INT 0
1117: PPUSH
1118: PPUSH
1119: PPUSH
1120: PPUSH
// cars := [ [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] ] ;
1121: LD_ADDR_VAR 0 2
1125: PUSH
1126: LD_INT 22
1128: PUSH
1129: LD_INT 42
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 22
1138: PUSH
1139: LD_INT 42
1141: PUSH
1142: EMPTY
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 22
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: LD_INT 42
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: PUSH
1166: LD_INT 22
1168: PUSH
1169: LD_INT 42
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 22
1178: PUSH
1179: LD_INT 42
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 22
1188: PUSH
1189: LD_INT 42
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: PUSH
1196: LD_INT 22
1198: PUSH
1199: LD_INT 42
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: ST_TO_ADDR
// InitUc ;
1216: CALL_OW 18
// InitVc ;
1220: CALL_OW 20
// vc_control := control_manual ;
1224: LD_ADDR_OWVAR 38
1228: PUSH
1229: LD_INT 1
1231: ST_TO_ADDR
// vc_engine := engine_combustion ;
1232: LD_ADDR_OWVAR 39
1236: PUSH
1237: LD_INT 1
1239: ST_TO_ADDR
// uc_side := you ;
1240: LD_ADDR_OWVAR 20
1244: PUSH
1245: LD_EXP 1
1249: ST_TO_ADDR
// uc_nation := nation_russian ;
1250: LD_ADDR_OWVAR 21
1254: PUSH
1255: LD_INT 3
1257: ST_TO_ADDR
// ru_cars := [ ] ;
1258: LD_ADDR_EXP 63
1262: PUSH
1263: EMPTY
1264: ST_TO_ADDR
// for i := 1 to 8 do
1265: LD_ADDR_VAR 0 4
1269: PUSH
1270: DOUBLE
1271: LD_INT 1
1273: DEC
1274: ST_TO_ADDR
1275: LD_INT 8
1277: PUSH
1278: FOR_TO
1279: IFFALSE 1447
// begin vc_chassis := cars [ i ] [ 1 ] ;
1281: LD_ADDR_OWVAR 37
1285: PUSH
1286: LD_VAR 0 2
1290: PUSH
1291: LD_VAR 0 4
1295: ARRAY
1296: PUSH
1297: LD_INT 1
1299: ARRAY
1300: ST_TO_ADDR
// vc_weapon := cars [ i ] [ 2 ] ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_VAR 0 2
1310: PUSH
1311: LD_VAR 0 4
1315: ARRAY
1316: PUSH
1317: LD_INT 2
1319: ARRAY
1320: ST_TO_ADDR
// uc_direction := Rand ( 3 , 4 ) ;
1321: LD_ADDR_OWVAR 24
1325: PUSH
1326: LD_INT 3
1328: PPUSH
1329: LD_INT 4
1331: PPUSH
1332: CALL_OW 12
1336: ST_TO_ADDR
// vc_fuel_battery := Rand ( 25 , 40 ) ;
1337: LD_ADDR_OWVAR 41
1341: PUSH
1342: LD_INT 25
1344: PPUSH
1345: LD_INT 40
1347: PPUSH
1348: CALL_OW 12
1352: ST_TO_ADDR
// car := CreateVehicle ;
1353: LD_ADDR_VAR 0 3
1357: PUSH
1358: CALL_OW 45
1362: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1363: LD_ADDR_EXP 63
1367: PUSH
1368: LD_EXP 63
1372: PUSH
1373: LD_VAR 0 3
1377: ADD
1378: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1379: LD_EXP 62
1383: PUSH
1384: LD_VAR 0 4
1388: ARRAY
1389: PPUSH
1390: LD_VAR 0 3
1394: PPUSH
1395: CALL_OW 52
// SetLives ( car , Rand ( 251 , 800 ) ) ;
1399: LD_VAR 0 3
1403: PPUSH
1404: LD_INT 251
1406: PPUSH
1407: LD_INT 800
1409: PPUSH
1410: CALL_OW 12
1414: PPUSH
1415: CALL_OW 234
// SetLives ( used [ i ] , Rand ( 900 , 1000 ) ) ;
1419: LD_EXP 62
1423: PUSH
1424: LD_VAR 0 4
1428: ARRAY
1429: PPUSH
1430: LD_INT 900
1432: PPUSH
1433: LD_INT 1000
1435: PPUSH
1436: CALL_OW 12
1440: PPUSH
1441: CALL_OW 234
// end ;
1445: GO 1278
1447: POP
1448: POP
// end ;
1449: LD_VAR 0 1
1453: RET
// export function place_apes ; var o1 , o2 , o3 , o4 ; begin
1454: LD_INT 0
1456: PPUSH
1457: PPUSH
1458: PPUSH
1459: PPUSH
1460: PPUSH
// InitHc ;
1461: CALL_OW 19
// InitUc ;
1465: CALL_OW 18
// uc_side := 0 ;
1469: LD_ADDR_OWVAR 20
1473: PUSH
1474: LD_INT 0
1476: ST_TO_ADDR
// uc_nation := nation_nature ;
1477: LD_ADDR_OWVAR 21
1481: PUSH
1482: LD_INT 0
1484: ST_TO_ADDR
// hc_class := class_apeman ;
1485: LD_ADDR_OWVAR 28
1489: PUSH
1490: LD_INT 12
1492: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1493: LD_ADDR_OWVAR 35
1497: PUSH
1498: LD_EXP 44
1502: PUSH
1503: LD_INT 1
1505: ARRAY
1506: PPUSH
1507: LD_EXP 44
1511: PUSH
1512: LD_INT 2
1514: ARRAY
1515: PPUSH
1516: CALL_OW 12
1520: ST_TO_ADDR
// o1 := CreateHuman ;
1521: LD_ADDR_VAR 0 2
1525: PUSH
1526: CALL_OW 44
1530: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1531: LD_ADDR_OWVAR 35
1535: PUSH
1536: LD_EXP 44
1540: PUSH
1541: LD_INT 1
1543: ARRAY
1544: PPUSH
1545: LD_EXP 44
1549: PUSH
1550: LD_INT 2
1552: ARRAY
1553: PPUSH
1554: CALL_OW 12
1558: ST_TO_ADDR
// o2 := CreateHuman ;
1559: LD_ADDR_VAR 0 3
1563: PUSH
1564: CALL_OW 44
1568: ST_TO_ADDR
// hc_agressivity := - 5 ;
1569: LD_ADDR_OWVAR 35
1573: PUSH
1574: LD_INT 5
1576: NEG
1577: ST_TO_ADDR
// o3 := CreateHuman ;
1578: LD_ADDR_VAR 0 4
1582: PUSH
1583: CALL_OW 44
1587: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1588: LD_ADDR_OWVAR 35
1592: PUSH
1593: LD_EXP 44
1597: PUSH
1598: LD_INT 1
1600: ARRAY
1601: PPUSH
1602: LD_EXP 44
1606: PUSH
1607: LD_INT 2
1609: ARRAY
1610: PPUSH
1611: CALL_OW 12
1615: ST_TO_ADDR
// o4 := CreateHuman ;
1616: LD_ADDR_VAR 0 5
1620: PUSH
1621: CALL_OW 44
1625: ST_TO_ADDR
// PlaceUnitXY ( o1 , 10 , 14 , false ) ;
1626: LD_VAR 0 2
1630: PPUSH
1631: LD_INT 10
1633: PPUSH
1634: LD_INT 14
1636: PPUSH
1637: LD_INT 0
1639: PPUSH
1640: CALL_OW 48
// PlaceUnitXY ( o2 , 17 , 22 , false ) ;
1644: LD_VAR 0 3
1648: PPUSH
1649: LD_INT 17
1651: PPUSH
1652: LD_INT 22
1654: PPUSH
1655: LD_INT 0
1657: PPUSH
1658: CALL_OW 48
// PlaceUnitXY ( o3 , 16 , 11 , false ) ;
1662: LD_VAR 0 4
1666: PPUSH
1667: LD_INT 16
1669: PPUSH
1670: LD_INT 11
1672: PPUSH
1673: LD_INT 0
1675: PPUSH
1676: CALL_OW 48
// PlaceUnitXY ( o4 , 84 , 7 , false ) ;
1680: LD_VAR 0 5
1684: PPUSH
1685: LD_INT 84
1687: PPUSH
1688: LD_INT 7
1690: PPUSH
1691: LD_INT 0
1693: PPUSH
1694: CALL_OW 48
// apemans := [ o1 , o2 , o3 , o4 ] ;
1698: LD_ADDR_EXP 7
1702: PUSH
1703: LD_VAR 0 2
1707: PUSH
1708: LD_VAR 0 3
1712: PUSH
1713: LD_VAR 0 4
1717: PUSH
1718: LD_VAR 0 5
1722: PUSH
1723: EMPTY
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: ST_TO_ADDR
// end ;
1729: LD_VAR 0 1
1733: RET
// export function place_ru_cars ( area ) ; var i ; begin
1734: LD_INT 0
1736: PPUSH
1737: PPUSH
// for i in ru_cars do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_EXP 63
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1770
// PlaceUnitArea ( i , area , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_VAR 0 1
1760: PPUSH
1761: LD_INT 0
1763: PPUSH
1764: CALL_OW 49
1768: GO 1748
1770: POP
1771: POP
// end ;
1772: LD_VAR 0 2
1776: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
1777: LD_INT 0
1779: PPUSH
// if new or TestCharacters ( name ) then
1780: LD_VAR 0 3
1784: PUSH
1785: LD_VAR 0 1
1789: PPUSH
1790: CALL_OW 28
1794: OR
1795: IFFALSE 1878
// begin if new then
1797: LD_VAR 0 3
1801: IFFALSE 1820
// result := NewCharacter ( name ) else
1803: LD_ADDR_VAR 0 4
1807: PUSH
1808: LD_VAR 0 1
1812: PPUSH
1813: CALL_OW 25
1817: ST_TO_ADDR
1818: GO 1856
// begin if CheckCharacterSet ( name ) then
1820: LD_VAR 0 1
1824: PPUSH
1825: CALL_OW 29
1829: IFFALSE 1848
// result := CreateCharacter ( name ) else
1831: LD_ADDR_VAR 0 4
1835: PUSH
1836: LD_VAR 0 1
1840: PPUSH
1841: CALL_OW 34
1845: ST_TO_ADDR
1846: GO 1856
// result := 0 ;
1848: LD_ADDR_VAR 0 4
1852: PUSH
1853: LD_INT 0
1855: ST_TO_ADDR
// end ; if unclass then
1856: LD_VAR 0 2
1860: IFFALSE 1876
// SetClass ( result , unclass ) ;
1862: LD_VAR 0 4
1866: PPUSH
1867: LD_VAR 0 2
1871: PPUSH
1872: CALL_OW 336
// end else
1876: GO 1944
// begin Msg ( Chybi  & name & ! ) ;
1878: LD_STRING Chybi 
1880: PUSH
1881: LD_VAR 0 1
1885: STR
1886: PUSH
1887: LD_STRING !
1889: STR
1890: PPUSH
1891: CALL_OW 100
// hc_name := name ;
1895: LD_ADDR_OWVAR 26
1899: PUSH
1900: LD_VAR 0 1
1904: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: LD_INT 3
1913: PPUSH
1914: CALL_OW 380
// if unclass then
1918: LD_VAR 0 2
1922: IFFALSE 1934
// hc_class := unclass ;
1924: LD_ADDR_OWVAR 28
1928: PUSH
1929: LD_VAR 0 2
1933: ST_TO_ADDR
// result := CreateHuman ;
1934: LD_ADDR_VAR 0 4
1938: PUSH
1939: CALL_OW 44
1943: ST_TO_ADDR
// end ; end ;
1944: LD_VAR 0 4
1948: RET
// export function Save ; var cars , i , cargotype ; begin
1949: LD_INT 0
1951: PPUSH
1952: PPUSH
1953: PPUSH
1954: PPUSH
// if not IsDead ( Omar ) then
1955: LD_EXP 61
1959: PPUSH
1960: CALL_OW 301
1964: NOT
1965: IFFALSE 1979
// SaveCharacters ( Omar , Omar ) ;
1967: LD_EXP 61
1971: PPUSH
1972: LD_STRING Omar
1974: PPUSH
1975: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
1979: LD_EXP 50
1983: PPUSH
1984: LD_STRING Burlak
1986: PPUSH
1987: CALL_OW 38
// if not IsInUnit ( Titov ) then
1991: LD_EXP 56
1995: PPUSH
1996: CALL_OW 310
2000: NOT
2001: IFFALSE 2015
// SetLives ( Titov , 0 ) ;
2003: LD_EXP 56
2007: PPUSH
2008: LD_INT 0
2010: PPUSH
2011: CALL_OW 234
// if not IsInUnit ( Dolgov ) then
2015: LD_EXP 57
2019: PPUSH
2020: CALL_OW 310
2024: NOT
2025: IFFALSE 2039
// SetLives ( Dolgov , 0 ) ;
2027: LD_EXP 57
2031: PPUSH
2032: LD_INT 0
2034: PPUSH
2035: CALL_OW 234
// if not IsInUnit ( Lipshchin ) then
2039: LD_EXP 58
2043: PPUSH
2044: CALL_OW 310
2048: NOT
2049: IFFALSE 2063
// SetLives ( Lipshchin , 0 ) ;
2051: LD_EXP 58
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 234
// if not IsInUnit ( Karamazov ) then
2063: LD_EXP 52
2067: PPUSH
2068: CALL_OW 310
2072: NOT
2073: IFFALSE 2087
// SetLives ( Karamazov , 0 ) ;
2075: LD_EXP 52
2079: PPUSH
2080: LD_INT 0
2082: PPUSH
2083: CALL_OW 234
// if not IsInUnit ( Petrovova ) then
2087: LD_EXP 53
2091: PPUSH
2092: CALL_OW 310
2096: NOT
2097: IFFALSE 2111
// SetLives ( Petrovova , 0 ) ;
2099: LD_EXP 53
2103: PPUSH
2104: LD_INT 0
2106: PPUSH
2107: CALL_OW 234
// if not IsInUnit ( Gleb ) then
2111: LD_EXP 54
2115: PPUSH
2116: CALL_OW 310
2120: NOT
2121: IFFALSE 2135
// SetLives ( Gleb , 0 ) ;
2123: LD_EXP 54
2127: PPUSH
2128: LD_INT 0
2130: PPUSH
2131: CALL_OW 234
// if not IsInUnit ( Petrosyan ) then
2135: LD_EXP 55
2139: PPUSH
2140: CALL_OW 310
2144: NOT
2145: IFFALSE 2159
// SetLives ( Petrosyan , 0 ) ;
2147: LD_EXP 55
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL_OW 234
// if Titov then
2159: LD_EXP 56
2163: IFFALSE 2177
// SaveCharacters ( Titov , Titov ) ;
2165: LD_EXP 56
2169: PPUSH
2170: LD_STRING Titov
2172: PPUSH
2173: CALL_OW 38
// if Dolgov then
2177: LD_EXP 57
2181: IFFALSE 2195
// SaveCharacters ( Dolgov , Dolgov ) ;
2183: LD_EXP 57
2187: PPUSH
2188: LD_STRING Dolgov
2190: PPUSH
2191: CALL_OW 38
// if Lipshchin then
2195: LD_EXP 58
2199: IFFALSE 2213
// SaveCharacters ( Lipshchin , Lipshchin ) ;
2201: LD_EXP 58
2205: PPUSH
2206: LD_STRING Lipshchin
2208: PPUSH
2209: CALL_OW 38
// if Karamazov then
2213: LD_EXP 52
2217: IFFALSE 2231
// SaveCharacters ( Karamazov , Karamazov ) ;
2219: LD_EXP 52
2223: PPUSH
2224: LD_STRING Karamazov
2226: PPUSH
2227: CALL_OW 38
// if Petrovova then
2231: LD_EXP 53
2235: IFFALSE 2249
// SaveCharacters ( Petrovova , Petrovova ) ;
2237: LD_EXP 53
2241: PPUSH
2242: LD_STRING Petrovova
2244: PPUSH
2245: CALL_OW 38
// if Gleb then
2249: LD_EXP 54
2253: IFFALSE 2267
// SaveCharacters ( Gleb , Gleb ) ;
2255: LD_EXP 54
2259: PPUSH
2260: LD_STRING Gleb
2262: PPUSH
2263: CALL_OW 38
// if Petrosyan then
2267: LD_EXP 55
2271: IFFALSE 2285
// SaveCharacters ( Petrosyan , Petrosyan ) ;
2273: LD_EXP 55
2277: PPUSH
2278: LD_STRING Petrosyan
2280: PPUSH
2281: CALL_OW 38
// SaveVariable ( Stevens_killed , StevensKilled ) ;
2285: LD_EXP 11
2289: PPUSH
2290: LD_STRING StevensKilled
2292: PPUSH
2293: CALL_OW 39
// SaveVariable ( action_was_fast , OvesyenkoTime ) ;
2297: LD_EXP 9
2301: PPUSH
2302: LD_STRING OvesyenkoTime
2304: PPUSH
2305: CALL_OW 39
// SaveVariable ( IsDead ( Omar ) , OmarKilled ) ;
2309: LD_EXP 61
2313: PPUSH
2314: CALL_OW 301
2318: PPUSH
2319: LD_STRING OmarKilled
2321: PPUSH
2322: CALL_OW 39
// cars := [ ] ;
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: EMPTY
2332: ST_TO_ADDR
// for i in FilterUnitsInArea ( exit_rus , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) do
2333: LD_ADDR_VAR 0 3
2337: PUSH
2338: LD_INT 22
2340: PPUSH
2341: LD_INT 22
2343: PUSH
2344: LD_EXP 1
2348: PUSH
2349: EMPTY
2350: LIST
2351: LIST
2352: PUSH
2353: LD_INT 21
2355: PUSH
2356: LD_INT 2
2358: PUSH
2359: EMPTY
2360: LIST
2361: LIST
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: PPUSH
2367: CALL_OW 70
2371: PUSH
2372: FOR_IN
2373: IFFALSE 2463
// begin cargotype := GetCargoType ( i ) ;
2375: LD_ADDR_VAR 0 4
2379: PUSH
2380: LD_VAR 0 3
2384: PPUSH
2385: CALL_OW 288
2389: ST_TO_ADDR
// cars := cars ^ [ [ GetChassis ( i ) , GetWeapon ( i ) , GetNation ( i ) , cargotype , GetCargo ( i , cargotype ) ] ] ;
2390: LD_ADDR_VAR 0 2
2394: PUSH
2395: LD_VAR 0 2
2399: PUSH
2400: LD_VAR 0 3
2404: PPUSH
2405: CALL_OW 265
2409: PUSH
2410: LD_VAR 0 3
2414: PPUSH
2415: CALL_OW 264
2419: PUSH
2420: LD_VAR 0 3
2424: PPUSH
2425: CALL_OW 248
2429: PUSH
2430: LD_VAR 0 4
2434: PUSH
2435: LD_VAR 0 3
2439: PPUSH
2440: LD_VAR 0 4
2444: PPUSH
2445: CALL_OW 289
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: LIST
2454: LIST
2455: LIST
2456: PUSH
2457: EMPTY
2458: LIST
2459: ADD
2460: ST_TO_ADDR
// end ;
2461: GO 2372
2463: POP
2464: POP
// SaveVariable ( cars , cars_ru_6 ) ;
2465: LD_VAR 0 2
2469: PPUSH
2470: LD_STRING cars_ru_6
2472: PPUSH
2473: CALL_OW 39
// end ; end_of_file
2477: LD_VAR 0 1
2481: RET
// var Bur , Pla , Kar , Ptr , Glb , Pty , Huck , Tit , Lip , Dol ; var donttalk ; function set_shorts ; begin
2482: LD_INT 0
2484: PPUSH
// Bur := Burlak ;
2485: LD_ADDR_LOC 1
2489: PUSH
2490: LD_EXP 50
2494: ST_TO_ADDR
// Dol := Dolgov ;
2495: LD_ADDR_LOC 10
2499: PUSH
2500: LD_EXP 57
2504: ST_TO_ADDR
// Lip := Lipshchin ;
2505: LD_ADDR_LOC 9
2509: PUSH
2510: LD_EXP 58
2514: ST_TO_ADDR
// Tit := Titov ;
2515: LD_ADDR_LOC 8
2519: PUSH
2520: LD_EXP 56
2524: ST_TO_ADDR
// Pla := Platonov ;
2525: LD_ADDR_LOC 2
2529: PUSH
2530: LD_EXP 51
2534: ST_TO_ADDR
// Kar := Karamazov ;
2535: LD_ADDR_LOC 3
2539: PUSH
2540: LD_EXP 52
2544: ST_TO_ADDR
// Ptr := Petrovova ;
2545: LD_ADDR_LOC 4
2549: PUSH
2550: LD_EXP 53
2554: ST_TO_ADDR
// Glb := Gleb ;
2555: LD_ADDR_LOC 5
2559: PUSH
2560: LD_EXP 54
2564: ST_TO_ADDR
// Pty := Petrosyan ;
2565: LD_ADDR_LOC 6
2569: PUSH
2570: LD_EXP 55
2574: ST_TO_ADDR
// Huck := Stevens ;
2575: LD_ADDR_LOC 7
2579: PUSH
2580: LD_EXP 59
2584: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
2585: LD_ADDR_LOC 11
2589: PUSH
2590: LD_EXP 62
2594: PUSH
2595: LD_EXP 50
2599: PUSH
2600: LD_EXP 52
2604: PUSH
2605: LD_EXP 53
2609: PUSH
2610: LD_EXP 54
2614: PUSH
2615: LD_EXP 55
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: DIFF
2627: ST_TO_ADDR
// end ;
2628: LD_VAR 0 1
2632: RET
// export function DIntro ; var pos , auta , i , hex , rcars ; begin
2633: LD_INT 0
2635: PPUSH
2636: PPUSH
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// pos := [ [ 50 , 39 ] , [ 46 , 42 ] , [ 40 , 50 ] , [ 48 , 57 ] , [ 49 , 59 ] , [ 55 , 70 ] , [ 55 , 73 ] , [ 70 , 86 ] , [ 69 , 83 ] ] ;
2641: LD_ADDR_VAR 0 2
2645: PUSH
2646: LD_INT 50
2648: PUSH
2649: LD_INT 39
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PUSH
2656: LD_INT 46
2658: PUSH
2659: LD_INT 42
2661: PUSH
2662: EMPTY
2663: LIST
2664: LIST
2665: PUSH
2666: LD_INT 40
2668: PUSH
2669: LD_INT 50
2671: PUSH
2672: EMPTY
2673: LIST
2674: LIST
2675: PUSH
2676: LD_INT 48
2678: PUSH
2679: LD_INT 57
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: PUSH
2686: LD_INT 49
2688: PUSH
2689: LD_INT 59
2691: PUSH
2692: EMPTY
2693: LIST
2694: LIST
2695: PUSH
2696: LD_INT 55
2698: PUSH
2699: LD_INT 70
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: PUSH
2706: LD_INT 55
2708: PUSH
2709: LD_INT 73
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 70
2718: PUSH
2719: LD_INT 86
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PUSH
2726: LD_INT 69
2728: PUSH
2729: LD_INT 83
2731: PUSH
2732: EMPTY
2733: LIST
2734: LIST
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: ST_TO_ADDR
// set_shorts ;
2747: CALL 2482 0 0
// InGameOn ;
2751: CALL_OW 8
// place_ru_cars ( ru_place2 ) ;
2755: LD_INT 18
2757: PPUSH
2758: CALL 1734 0 1
// RevealFogArea ( you , co_vidi ) ;
2762: LD_EXP 1
2766: PPUSH
2767: LD_INT 19
2769: PPUSH
2770: CALL_OW 332
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
2774: LD_ADDR_VAR 0 3
2778: PUSH
2779: LD_INT 22
2781: PUSH
2782: LD_EXP 1
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: LD_INT 21
2793: PUSH
2794: LD_INT 2
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PPUSH
2805: CALL_OW 69
2809: ST_TO_ADDR
// ComMoveToArea ( auta , ru_dojezd ) ;
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_INT 3
2817: PPUSH
2818: CALL_OW 113
// wait ( 0 0$0.1 ) ;
2822: LD_INT 4
2824: PPUSH
2825: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
2829: LD_LOC 1
2833: PPUSH
2834: CALL_OW 310
2838: PPUSH
2839: CALL_OW 87
// while FilterUnitsInArea ( ru_dojezd , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) < 5 do
2843: LD_INT 3
2845: PPUSH
2846: LD_INT 22
2848: PUSH
2849: LD_EXP 1
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: PUSH
2858: LD_INT 21
2860: PUSH
2861: LD_INT 2
2863: PUSH
2864: EMPTY
2865: LIST
2866: LIST
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: PPUSH
2872: CALL_OW 70
2876: PUSH
2877: LD_INT 5
2879: LESS
2880: IFFALSE 2905
// begin wait ( 0 0$1 ) ;
2882: LD_INT 35
2884: PPUSH
2885: CALL_OW 67
// CenterOnUnits ( IsInUnit ( Bur ) ) ;
2889: LD_LOC 1
2893: PPUSH
2894: CALL_OW 310
2898: PPUSH
2899: CALL_OW 85
// end ;
2903: GO 2843
// DStart ;
2905: CALL 2918 0 0
// InGameOff ;
2909: CALL_OW 9
// end ;
2913: LD_VAR 0 1
2917: RET
// export function DStart ; begin
2918: LD_INT 0
2920: PPUSH
// DialogueOn ;
2921: CALL_OW 6
// ComStop ( FilterAllUnits ( [ [ f_side , you ] ] ) ) ;
2925: LD_INT 22
2927: PUSH
2928: LD_EXP 1
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: PPUSH
2940: CALL_OW 69
2944: PPUSH
2945: CALL_OW 141
// wait ( 0 0$0.5 ) ;
2949: LD_INT 18
2951: PPUSH
2952: CALL_OW 67
// Say ( Bur , DStart-Bur-1 ) ;
2956: LD_LOC 1
2960: PPUSH
2961: LD_STRING DStart-Bur-1
2963: PPUSH
2964: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-1 ) ;
2968: LD_LOC 2
2972: PPUSH
2973: LD_STRING DStart-Pla-1
2975: PPUSH
2976: CALL_OW 94
// Say ( Bur , DStart-Bur-2 ) ;
2980: LD_LOC 1
2984: PPUSH
2985: LD_STRING DStart-Bur-2
2987: PPUSH
2988: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-2 ) ;
2992: LD_LOC 2
2996: PPUSH
2997: LD_STRING DStart-Pla-2
2999: PPUSH
3000: CALL_OW 94
// SaveForQuickRestart ;
3004: CALL_OW 22
// DialogueOff ;
3008: CALL_OW 7
// ChangeMissionObjectives ( MBegin ) ;
3012: LD_STRING MBegin
3014: PPUSH
3015: CALL_OW 337
// SetAreaMapShow ( exit_rus , 1 ) ;
3019: LD_INT 22
3021: PPUSH
3022: LD_INT 1
3024: PPUSH
3025: CALL_OW 424
// end ;
3029: LD_VAR 0 1
3033: RET
// every 0 0$0.1 trigger dialogy do
3034: LD_EXP 46
3038: IFFALSE 3047
3040: GO 3042
3042: DISABLE
// begin DDoubts ;
3043: CALL 3048 0 0
// end ;
3047: END
// function DDoubts ; var who ; begin
3048: LD_INT 0
3050: PPUSH
3051: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3052: LD_ADDR_VAR 0 2
3056: PUSH
3057: LD_LOC 11
3061: PPUSH
3062: LD_EXP 1
3066: PPUSH
3067: LD_INT 1
3069: PPUSH
3070: LD_INT 0
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL 23510 0 5
3080: ST_TO_ADDR
// if not who then
3081: LD_VAR 0 2
3085: NOT
3086: IFFALSE 3098
// who := Bur ;
3088: LD_ADDR_VAR 0 2
3092: PUSH
3093: LD_LOC 1
3097: ST_TO_ADDR
// if IsLive ( Kar ) or IsLive ( Ptr ) then
3098: LD_LOC 3
3102: PPUSH
3103: CALL_OW 300
3107: PUSH
3108: LD_LOC 4
3112: PPUSH
3113: CALL_OW 300
3117: OR
3118: IFFALSE 3204
// begin DialogueOn ;
3120: CALL_OW 6
// Say ( Kar , DDoubts-Kar-1 ) ;
3124: LD_LOC 3
3128: PPUSH
3129: LD_STRING DDoubts-Kar-1
3131: PPUSH
3132: CALL_OW 88
// Say ( Ptr , DDoubts-Ptr-1 ) ;
3136: LD_LOC 4
3140: PPUSH
3141: LD_STRING DDoubts-Ptr-1
3143: PPUSH
3144: CALL_OW 88
// Say ( who , DDoubts-Bur-1 ) ;
3148: LD_VAR 0 2
3152: PPUSH
3153: LD_STRING DDoubts-Bur-1
3155: PPUSH
3156: CALL_OW 88
// if Say ( Kar , DDoubts-Kar-2 ) then
3160: LD_LOC 3
3164: PPUSH
3165: LD_STRING DDoubts-Kar-2
3167: PPUSH
3168: CALL_OW 88
3172: IFFALSE 3200
// if Say ( Glb , DDoubts-Glb-2 ) then
3174: LD_LOC 5
3178: PPUSH
3179: LD_STRING DDoubts-Glb-2
3181: PPUSH
3182: CALL_OW 88
3186: IFFALSE 3200
// Say ( Bur , DDoubts-Bur-2 ) ;
3188: LD_LOC 1
3192: PPUSH
3193: LD_STRING DDoubts-Bur-2
3195: PPUSH
3196: CALL_OW 88
// DialogueOff ;
3200: CALL_OW 7
// end ; end ;
3204: LD_VAR 0 1
3208: RET
// every 0 0$5 trigger dialogy and ( SeeArea ( you , vidi_je ) or See_any ( you , fort ) ) do
3209: LD_EXP 46
3213: PUSH
3214: LD_EXP 1
3218: PPUSH
3219: LD_INT 24
3221: PPUSH
3222: CALL_OW 294
3226: PUSH
3227: LD_EXP 1
3231: PPUSH
3232: LD_EXP 43
3236: PPUSH
3237: CALL 23711 0 2
3241: OR
3242: AND
3243: IFFALSE 3256
3245: GO 3247
3247: DISABLE
// begin DArabs ;
3248: CALL 3257 0 0
// DSurrender ;
3252: CALL 3379 0 0
// end ;
3256: END
// export function DArabs ; var who ; begin
3257: LD_INT 0
3259: PPUSH
3260: PPUSH
// SetAttitude ( you , arabians , att_enemy , true ) ;
3261: LD_EXP 1
3265: PPUSH
3266: LD_EXP 3
3270: PPUSH
3271: LD_INT 2
3273: PPUSH
3274: LD_INT 1
3276: PPUSH
3277: CALL_OW 80
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3281: LD_ADDR_VAR 0 2
3285: PUSH
3286: LD_LOC 11
3290: PPUSH
3291: LD_EXP 1
3295: PPUSH
3296: LD_INT 1
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: LD_INT 0
3304: PPUSH
3305: CALL 23510 0 5
3309: ST_TO_ADDR
// DialogueOn ;
3310: CALL_OW 6
// Say ( who , DArabs-RSol1-1 ) ;
3314: LD_VAR 0 2
3318: PPUSH
3319: LD_STRING DArabs-RSol1-1
3321: PPUSH
3322: CALL_OW 88
// Say ( Kar , DArabs-Kar-1 ) ;
3326: LD_LOC 3
3330: PPUSH
3331: LD_STRING DArabs-Kar-1
3333: PPUSH
3334: CALL_OW 88
// Say ( Bur , DArabs-Bur-1 ) ;
3338: LD_LOC 1
3342: PPUSH
3343: LD_STRING DArabs-Bur-1
3345: PPUSH
3346: CALL_OW 88
// SayRadio ( Pla , DArabs-Pla-1 ) ;
3350: LD_LOC 2
3354: PPUSH
3355: LD_STRING DArabs-Pla-1
3357: PPUSH
3358: CALL_OW 94
// DialogueOff ;
3362: CALL_OW 7
// DefendLast := true ;
3366: LD_ADDR_EXP 8
3370: PUSH
3371: LD_INT 1
3373: ST_TO_ADDR
// end ;
3374: LD_VAR 0 1
3378: RET
// function DSurrender ; var qr ; begin
3379: LD_INT 0
3381: PPUSH
3382: PPUSH
// DialogueOn ;
3383: CALL_OW 6
// Say ( Omar , DSurrender-Omar-1 ) ;
3387: LD_EXP 61
3391: PPUSH
3392: LD_STRING DSurrender-Omar-1
3394: PPUSH
3395: CALL_OW 88
// qr := Query ( QSurrender ) ;
3399: LD_ADDR_VAR 0 2
3403: PUSH
3404: LD_STRING QSurrender
3406: PPUSH
3407: CALL_OW 97
3411: ST_TO_ADDR
// case qr of 1 :
3412: LD_VAR 0 2
3416: PUSH
3417: LD_INT 1
3419: DOUBLE
3420: EQUAL
3421: IFTRUE 3425
3423: GO 3432
3425: POP
// DQrSurrender_1 ; 2 :
3426: CALL 3472 0 0
3430: GO 3463
3432: LD_INT 2
3434: DOUBLE
3435: EQUAL
3436: IFTRUE 3440
3438: GO 3447
3440: POP
// DQrSurrender_2 ; 3 :
3441: CALL 3499 0 0
3445: GO 3463
3447: LD_INT 3
3449: DOUBLE
3450: EQUAL
3451: IFTRUE 3455
3453: GO 3462
3455: POP
// DQrSurrender_3 ; end ;
3456: CALL 3527 0 0
3460: GO 3463
3462: POP
// DialogueOff ;
3463: CALL_OW 7
// end ;
3467: LD_VAR 0 1
3471: RET
// function DQrSurrender_1 ; begin
3472: LD_INT 0
3474: PPUSH
// Say ( Bur , DQrSurrender#1-Bur-1 ) ;
3475: LD_LOC 1
3479: PPUSH
3480: LD_STRING DQrSurrender#1-Bur-1
3482: PPUSH
3483: CALL_OW 88
// YouLost ( Surrender ) ;
3487: LD_STRING Surrender
3489: PPUSH
3490: CALL_OW 104
// end ;
3494: LD_VAR 0 1
3498: RET
// function DQrSurrender_2 ; begin
3499: LD_INT 0
3501: PPUSH
// Say ( Bur , DQrSurrender#2-Bur-1 ) ;
3502: LD_LOC 1
3506: PPUSH
3507: LD_STRING DQrSurrender#2-Bur-1
3509: PPUSH
3510: CALL_OW 88
// wait_while := true ;
3514: LD_ADDR_EXP 12
3518: PUSH
3519: LD_INT 1
3521: ST_TO_ADDR
// end ;
3522: LD_VAR 0 1
3526: RET
// function DQrSurrender_3 ; begin
3527: LD_INT 0
3529: PPUSH
// Say ( Bur , DQrSurrender#3-Bur-1 ) ;
3530: LD_LOC 1
3534: PPUSH
3535: LD_STRING DQrSurrender#3-Bur-1
3537: PPUSH
3538: CALL_OW 88
// end ;
3542: LD_VAR 0 1
3546: RET
// every 0 0$1 trigger dialogy and ( FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3547: LD_EXP 46
3551: PUSH
3552: LD_INT 8
3554: PPUSH
3555: LD_INT 26
3557: PUSH
3558: LD_INT 1
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 22
3567: PUSH
3568: LD_EXP 1
3572: PUSH
3573: EMPTY
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 23
3579: PUSH
3580: LD_INT 3
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 70
3596: AND
3597: IFFALSE 3683
3599: GO 3601
3601: DISABLE
3602: LD_INT 0
3604: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3605: LD_ADDR_VAR 0 1
3609: PUSH
3610: LD_LOC 11
3614: PUSH
3615: LD_INT 8
3617: PPUSH
3618: LD_INT 26
3620: PUSH
3621: LD_INT 1
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PUSH
3628: LD_INT 22
3630: PUSH
3631: LD_EXP 1
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 23
3642: PUSH
3643: LD_INT 3
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: LIST
3654: PPUSH
3655: CALL_OW 70
3659: ISECT
3660: ST_TO_ADDR
// if b then
3661: LD_VAR 0 1
3665: IFFALSE 3682
// DShipments ( b [ 1 ] ) else
3667: LD_VAR 0 1
3671: PUSH
3672: LD_INT 1
3674: ARRAY
3675: PPUSH
3676: CALL 3686 0 1
3680: GO 3683
// enable ;
3682: ENABLE
// end ;
3683: PPOPN 1
3685: END
// function DShipments ( who ) ; begin
3686: LD_INT 0
3688: PPUSH
// CreateCratesArea ( 5 , second_crate , true ) ;
3689: LD_INT 5
3691: PPUSH
3692: LD_INT 7
3694: PPUSH
3695: LD_INT 1
3697: PPUSH
3698: CALL_OW 55
// wait ( 0 0$6 ) ;
3702: LD_INT 210
3704: PPUSH
3705: CALL_OW 67
// DialogueOn ;
3709: CALL_OW 6
// if Say ( who , DShipments-RSol1-1 ) then
3713: LD_VAR 0 1
3717: PPUSH
3718: LD_STRING DShipments-RSol1-1
3720: PPUSH
3721: CALL_OW 88
3725: IFFALSE 3753
// if Say ( Bur , DShipments-Bur-1 ) then
3727: LD_LOC 1
3731: PPUSH
3732: LD_STRING DShipments-Bur-1
3734: PPUSH
3735: CALL_OW 88
3739: IFFALSE 3753
// Say ( who , DShipments-RSol1-2 ) ;
3741: LD_VAR 0 1
3745: PPUSH
3746: LD_STRING DShipments-RSol1-2
3748: PPUSH
3749: CALL_OW 88
// DialogueOff ;
3753: CALL_OW 7
// end ;
3757: LD_VAR 0 2
3761: RET
// every 0 0$3 + 0 0$2 trigger dialogy and ( FilterUnitsInArea ( enter_near_road , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3762: LD_EXP 46
3766: PUSH
3767: LD_INT 9
3769: PPUSH
3770: LD_INT 26
3772: PUSH
3773: LD_INT 1
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 22
3782: PUSH
3783: LD_EXP 1
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: PUSH
3792: LD_INT 23
3794: PUSH
3795: LD_INT 3
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: PPUSH
3807: CALL_OW 70
3811: AND
3812: IFFALSE 3898
3814: GO 3816
3816: DISABLE
3817: LD_INT 0
3819: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3820: LD_ADDR_VAR 0 1
3824: PUSH
3825: LD_LOC 11
3829: PUSH
3830: LD_INT 8
3832: PPUSH
3833: LD_INT 26
3835: PUSH
3836: LD_INT 1
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_EXP 1
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: PUSH
3855: LD_INT 23
3857: PUSH
3858: LD_INT 3
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: LIST
3869: PPUSH
3870: CALL_OW 70
3874: ISECT
3875: ST_TO_ADDR
// if b then
3876: LD_VAR 0 1
3880: IFFALSE 3897
// DRoad ( b [ 1 ] ) else
3882: LD_VAR 0 1
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: CALL 3901 0 1
3895: GO 3898
// enable ;
3897: ENABLE
// end ;
3898: PPOPN 1
3900: END
// function DRoad ( who ) ; begin
3901: LD_INT 0
3903: PPUSH
// if who <> Burlak then
3904: LD_VAR 0 1
3908: PUSH
3909: LD_EXP 50
3913: NONEQUAL
3914: IFFALSE 3955
// begin DialogueOn ;
3916: CALL_OW 6
// Say ( who , DRoad-RSol1-1 ) ;
3920: LD_VAR 0 1
3924: PPUSH
3925: LD_STRING DRoad-RSol1-1
3927: PPUSH
3928: CALL_OW 88
// if not breaked_trough then
3932: LD_EXP 10
3936: NOT
3937: IFFALSE 3951
// Say ( who , DRoad-RSol1-1a ) ;
3939: LD_VAR 0 1
3943: PPUSH
3944: LD_STRING DRoad-RSol1-1a
3946: PPUSH
3947: CALL_OW 88
// DialogueOff ;
3951: CALL_OW 7
// end ; end ;
3955: LD_VAR 0 2
3959: RET
// every 0 0$3 + 0 0$2 trigger dialogy and see_any ( you , UnitFilter ( apemans , [ [ f_side , neutral ] ] ) ) do var a ;
3960: LD_EXP 46
3964: PUSH
3965: LD_EXP 1
3969: PPUSH
3970: LD_EXP 7
3974: PPUSH
3975: LD_INT 22
3977: PUSH
3978: LD_EXP 4
3982: PUSH
3983: EMPTY
3984: LIST
3985: LIST
3986: PUSH
3987: EMPTY
3988: LIST
3989: PPUSH
3990: CALL_OW 72
3994: PPUSH
3995: CALL 23711 0 2
3999: AND
4000: IFFALSE 4182
4002: GO 4004
4004: DISABLE
4005: LD_INT 0
4007: PPUSH
// begin a := ( FilterAllUnits ( [ [ f_side , you ] , [ f_see , neutral ] ] ) isect donttalk ) ^ Burlak ;
4008: LD_ADDR_VAR 0 1
4012: PUSH
4013: LD_INT 22
4015: PUSH
4016: LD_EXP 1
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: PUSH
4025: LD_INT 101
4027: PUSH
4028: LD_EXP 4
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: PPUSH
4041: CALL_OW 69
4045: PUSH
4046: LD_LOC 11
4050: ISECT
4051: PUSH
4052: LD_EXP 50
4056: ADD
4057: ST_TO_ADDR
// if a then
4058: LD_VAR 0 1
4062: IFFALSE 4181
// begin if not GetTech ( tech_ApeLang , you ) = state_researched then
4064: LD_INT 1
4066: PPUSH
4067: LD_EXP 1
4071: PPUSH
4072: CALL_OW 321
4076: PUSH
4077: LD_INT 2
4079: EQUAL
4080: NOT
4081: IFFALSE 4179
// begin DApeSpot ( a [ Rand ( 1 , a ) ] ) ;
4083: LD_VAR 0 1
4087: PUSH
4088: LD_INT 1
4090: PPUSH
4091: LD_VAR 0 1
4095: PPUSH
4096: CALL_OW 12
4100: ARRAY
4101: PPUSH
4102: CALL 4185 0 1
// wait ( 2 2$0 ) ;
4106: LD_INT 4200
4108: PPUSH
4109: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4113: LD_INT 22
4115: PUSH
4116: LD_EXP 1
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: PUSH
4125: LD_INT 2
4127: PUSH
4128: LD_INT 30
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: LD_INT 30
4140: PUSH
4141: LD_INT 7
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PUSH
4148: LD_INT 30
4150: PUSH
4151: LD_INT 8
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: LIST
4162: LIST
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PPUSH
4168: CALL_OW 69
4172: NOT
4173: IFFALSE 4179
// DApeLab ;
4175: CALL 4408 0 0
// end ; end else
4179: GO 4182
// enable ;
4181: ENABLE
// end ;
4182: PPOPN 1
4184: END
// function DApeSpot ( who ) ; var Sci1 ; begin
4185: LD_INT 0
4187: PPUSH
4188: PPUSH
// Sci1 := Pty ;
4189: LD_ADDR_VAR 0 3
4193: PUSH
4194: LD_LOC 6
4198: ST_TO_ADDR
// if not IsLive ( Pty ) then
4199: LD_LOC 6
4203: PPUSH
4204: CALL_OW 300
4208: NOT
4209: IFFALSE 4240
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4211: LD_ADDR_VAR 0 3
4215: PUSH
4216: LD_LOC 11
4220: PPUSH
4221: LD_EXP 1
4225: PPUSH
4226: LD_INT 1
4228: PPUSH
4229: LD_INT 4
4231: PPUSH
4232: LD_INT 0
4234: PPUSH
4235: CALL 23510 0 5
4239: ST_TO_ADDR
// DialogueOn ;
4240: CALL_OW 6
// if who = Bur then
4244: LD_VAR 0 1
4248: PUSH
4249: LD_LOC 1
4253: EQUAL
4254: IFFALSE 4270
// Say ( Bur , DApeSpot-Bur-1a ) else
4256: LD_LOC 1
4260: PPUSH
4261: LD_STRING DApeSpot-Bur-1a
4263: PPUSH
4264: CALL_OW 88
4268: GO 4294
// begin Say ( Bur , DApeSpot-Bur-1 ) ;
4270: LD_LOC 1
4274: PPUSH
4275: LD_STRING DApeSpot-Bur-1
4277: PPUSH
4278: CALL_OW 88
// Say ( who , DApeSpot-RSol1-1 ) ;
4282: LD_VAR 0 1
4286: PPUSH
4287: LD_STRING DApeSpot-RSol1-1
4289: PPUSH
4290: CALL_OW 88
// end ; if Sci1 then
4294: LD_VAR 0 3
4298: IFFALSE 4399
// begin Say ( Sci1 , DApeSpot-Pty-1 ) ;
4300: LD_VAR 0 3
4304: PPUSH
4305: LD_STRING DApeSpot-Pty-1
4307: PPUSH
4308: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4312: LD_INT 22
4314: PUSH
4315: LD_EXP 1
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: LD_INT 2
4326: PUSH
4327: LD_INT 30
4329: PUSH
4330: LD_INT 6
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PUSH
4337: LD_INT 30
4339: PUSH
4340: LD_INT 7
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 30
4349: PUSH
4350: LD_INT 8
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: LIST
4361: LIST
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PPUSH
4367: CALL_OW 69
4371: IFFALSE 4387
// Say ( Sci1 , DApeSpot-Pty-1a ) else
4373: LD_VAR 0 3
4377: PPUSH
4378: LD_STRING DApeSpot-Pty-1a
4380: PPUSH
4381: CALL_OW 88
4385: GO 4399
// Say ( Sci1 , DApeSpot-Pty-1b ) ;
4387: LD_VAR 0 3
4391: PPUSH
4392: LD_STRING DApeSpot-Pty-1b
4394: PPUSH
4395: CALL_OW 88
// end ; DialogueOff ;
4399: CALL_OW 7
// end ;
4403: LD_VAR 0 2
4407: RET
// function DApeLab ; var Sci1 ; begin
4408: LD_INT 0
4410: PPUSH
4411: PPUSH
// Sci1 := Pty ;
4412: LD_ADDR_VAR 0 2
4416: PUSH
4417: LD_LOC 6
4421: ST_TO_ADDR
// if not IsLive ( Pty ) then
4422: LD_LOC 6
4426: PPUSH
4427: CALL_OW 300
4431: NOT
4432: IFFALSE 4463
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4434: LD_ADDR_VAR 0 2
4438: PUSH
4439: LD_LOC 11
4443: PPUSH
4444: LD_EXP 1
4448: PPUSH
4449: LD_INT 1
4451: PPUSH
4452: LD_INT 4
4454: PPUSH
4455: LD_INT 0
4457: PPUSH
4458: CALL 23510 0 5
4462: ST_TO_ADDR
// if Sci1 then
4463: LD_VAR 0 2
4467: IFFALSE 4489
// begin DialogueOn ;
4469: CALL_OW 6
// Say ( Sci1 , DApeLab-Pty-1 ) ;
4473: LD_VAR 0 2
4477: PPUSH
4478: LD_STRING DApeLab-Pty-1
4480: PPUSH
4481: CALL_OW 88
// DialogueOff ;
4485: CALL_OW 7
// end ; end ;
4489: LD_VAR 0 1
4493: RET
// export function DApeLangCompl ; var Sci1 ; begin
4494: LD_INT 0
4496: PPUSH
4497: PPUSH
// Sci1 := Pty ;
4498: LD_ADDR_VAR 0 2
4502: PUSH
4503: LD_LOC 6
4507: ST_TO_ADDR
// if not IsLive ( Pty ) then
4508: LD_LOC 6
4512: PPUSH
4513: CALL_OW 300
4517: NOT
4518: IFFALSE 4549
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: LD_LOC 11
4529: PPUSH
4530: LD_EXP 1
4534: PPUSH
4535: LD_INT 1
4537: PPUSH
4538: LD_INT 4
4540: PPUSH
4541: LD_INT 0
4543: PPUSH
4544: CALL 23510 0 5
4548: ST_TO_ADDR
// if Sci1 then
4549: LD_VAR 0 2
4553: IFFALSE 4647
// begin DialogueOn ;
4555: CALL_OW 6
// Say ( Sci1 , DApeLangCompl-Pty-1 ) ;
4559: LD_VAR 0 2
4563: PPUSH
4564: LD_STRING DApeLangCompl-Pty-1
4566: PPUSH
4567: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-1 ) ;
4571: LD_LOC 1
4575: PPUSH
4576: LD_STRING DApeLangCompl-Bur-1
4578: PPUSH
4579: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-2 ) ;
4583: LD_VAR 0 2
4587: PPUSH
4588: LD_STRING DApeLangCompl-Pty-2
4590: PPUSH
4591: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-2 ) ;
4595: LD_LOC 1
4599: PPUSH
4600: LD_STRING DApeLangCompl-Bur-2
4602: PPUSH
4603: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-3 ) ;
4607: LD_VAR 0 2
4611: PPUSH
4612: LD_STRING DApeLangCompl-Pty-3
4614: PPUSH
4615: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-3 ) ;
4619: LD_LOC 1
4623: PPUSH
4624: LD_STRING DApeLangCompl-Bur-3
4626: PPUSH
4627: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-4 ) ;
4631: LD_VAR 0 2
4635: PPUSH
4636: LD_STRING DApeLangCompl-Pty-4
4638: PPUSH
4639: CALL_OW 88
// DialogueOff ;
4643: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4647: LD_STRING ApemenTaming
4649: PPUSH
4650: CALL 25431 0 1
// end ;
4654: LD_VAR 0 1
4658: RET
// export function DApeTame ; var Sci1 ; begin
4659: LD_INT 0
4661: PPUSH
4662: PPUSH
// first_apeman_tamed := true ;
4663: LD_ADDR_EXP 45
4667: PUSH
4668: LD_INT 1
4670: ST_TO_ADDR
// Sci1 := Pty ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_LOC 6
4680: ST_TO_ADDR
// if not IsLive ( Pty ) then
4681: LD_LOC 6
4685: PPUSH
4686: CALL_OW 300
4690: NOT
4691: IFFALSE 4722
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4693: LD_ADDR_VAR 0 2
4697: PUSH
4698: LD_LOC 11
4702: PPUSH
4703: LD_EXP 1
4707: PPUSH
4708: LD_INT 1
4710: PPUSH
4711: LD_INT 4
4713: PPUSH
4714: LD_INT 0
4716: PPUSH
4717: CALL 23510 0 5
4721: ST_TO_ADDR
// if Sci1 then
4722: LD_VAR 0 2
4726: IFFALSE 4760
// begin DialogueOn ;
4728: CALL_OW 6
// Say ( Sci1 , DApeTame-Sci1-1 ) ;
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_STRING DApeTame-Sci1-1
4739: PPUSH
4740: CALL_OW 88
// Say ( Bur , DApeTame-Bur-1 ) ;
4744: LD_LOC 1
4748: PPUSH
4749: LD_STRING DApeTame-Bur-1
4751: PPUSH
4752: CALL_OW 88
// DialogueOff ;
4756: CALL_OW 7
// end ; end ;
4760: LD_VAR 0 1
4764: RET
// function ApemansInLabs ; var labs , i , inlabs ; begin
4765: LD_INT 0
4767: PPUSH
4768: PPUSH
4769: PPUSH
4770: PPUSH
// inlabs := [ ] ;
4771: LD_ADDR_VAR 0 4
4775: PUSH
4776: EMPTY
4777: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4778: LD_ADDR_VAR 0 2
4782: PUSH
4783: LD_INT 22
4785: PUSH
4786: LD_EXP 1
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 2
4797: PUSH
4798: LD_INT 30
4800: PUSH
4801: LD_INT 6
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 30
4810: PUSH
4811: LD_INT 7
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 30
4820: PUSH
4821: LD_INT 8
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PPUSH
4838: CALL_OW 69
4842: ST_TO_ADDR
// for i in labs do
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_VAR 0 2
4852: PUSH
4853: FOR_IN
4854: IFFALSE 4879
// inlabs := inlabs ^ UnitsInside ( i ) ;
4856: LD_ADDR_VAR 0 4
4860: PUSH
4861: LD_VAR 0 4
4865: PUSH
4866: LD_VAR 0 3
4870: PPUSH
4871: CALL_OW 313
4875: ADD
4876: ST_TO_ADDR
4877: GO 4853
4879: POP
4880: POP
// result := UnitFilter ( inlabs , [ [ f_nation , nation_nature ] ] ) ;
4881: LD_ADDR_VAR 0 1
4885: PUSH
4886: LD_VAR 0 4
4890: PPUSH
4891: LD_INT 23
4893: PUSH
4894: LD_INT 0
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: EMPTY
4902: LIST
4903: PPUSH
4904: CALL_OW 72
4908: ST_TO_ADDR
// end ;
4909: LD_VAR 0 1
4913: RET
// every 0 0$3 trigger dialogy and ApemansInLabs do
4914: LD_EXP 46
4918: PUSH
4919: CALL 4765 0 0
4923: AND
4924: IFFALSE 4933
4926: GO 4928
4928: DISABLE
// begin DApeWorkSol ;
4929: CALL 4934 0 0
// end ;
4933: END
// function DApeWorkSol ; var Sci1 ; begin
4934: LD_INT 0
4936: PPUSH
4937: PPUSH
// Sci1 := Pty ;
4938: LD_ADDR_VAR 0 2
4942: PUSH
4943: LD_LOC 6
4947: ST_TO_ADDR
// if not IsLive ( Pty ) then
4948: LD_LOC 6
4952: PPUSH
4953: CALL_OW 300
4957: NOT
4958: IFFALSE 4989
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4960: LD_ADDR_VAR 0 2
4964: PUSH
4965: LD_LOC 11
4969: PPUSH
4970: LD_EXP 1
4974: PPUSH
4975: LD_INT 1
4977: PPUSH
4978: LD_INT 4
4980: PPUSH
4981: LD_INT 0
4983: PPUSH
4984: CALL 23510 0 5
4988: ST_TO_ADDR
// if Sci1 then
4989: LD_VAR 0 2
4993: IFFALSE 5048
// begin DialogueOn ;
4995: CALL_OW 6
// Say ( Bur , DApeWorkSol-Bur-1 ) ;
4999: LD_LOC 1
5003: PPUSH
5004: LD_STRING DApeWorkSol-Bur-1
5006: PPUSH
5007: CALL_OW 88
// if Say ( Sci1 , DApeWorkSol-Pty-1 ) then
5011: LD_VAR 0 2
5015: PPUSH
5016: LD_STRING DApeWorkSol-Pty-1
5018: PPUSH
5019: CALL_OW 88
5023: IFFALSE 5037
// Say ( Bur , DApeWorkSol-Bur-2 ) ;
5025: LD_LOC 1
5029: PPUSH
5030: LD_STRING DApeWorkSol-Bur-2
5032: PPUSH
5033: CALL_OW 88
// MyHint ( ApemenUsing ) ;
5037: LD_STRING ApemenUsing
5039: PPUSH
5040: CALL 25431 0 1
// DialogueOff ;
5044: CALL_OW 7
// end ; end ;
5048: LD_VAR 0 1
5052: RET
// export function DApeWorkCompl ; var Sci1 ; begin
5053: LD_INT 0
5055: PPUSH
5056: PPUSH
// first_apeman_tamed := true ;
5057: LD_ADDR_EXP 45
5061: PUSH
5062: LD_INT 1
5064: ST_TO_ADDR
// Sci1 := Pty ;
5065: LD_ADDR_VAR 0 2
5069: PUSH
5070: LD_LOC 6
5074: ST_TO_ADDR
// if not IsLive ( Pty ) then
5075: LD_LOC 6
5079: PPUSH
5080: CALL_OW 300
5084: NOT
5085: IFFALSE 5116
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: LD_LOC 11
5096: PPUSH
5097: LD_EXP 1
5101: PPUSH
5102: LD_INT 1
5104: PPUSH
5105: LD_INT 4
5107: PPUSH
5108: LD_INT 0
5110: PPUSH
5111: CALL 23510 0 5
5115: ST_TO_ADDR
// if Sci1 then
5116: LD_VAR 0 2
5120: IFFALSE 5156
// begin DialogueOn ;
5122: CALL_OW 6
// if Say ( Sci1 , DApeWorkCompl-Pty-1 ) then
5126: LD_VAR 0 2
5130: PPUSH
5131: LD_STRING DApeWorkCompl-Pty-1
5133: PPUSH
5134: CALL_OW 88
5138: IFFALSE 5152
// Say ( Bur , DApeWorkCompl-Bur-1 ) ;
5140: LD_LOC 1
5144: PPUSH
5145: LD_STRING DApeWorkCompl-Bur-1
5147: PPUSH
5148: CALL_OW 88
// DialogueOff ;
5152: CALL_OW 7
// end ; end ;
5156: LD_VAR 0 1
5160: RET
// export function DApeSolCompl ; var Sci1 ; begin
5161: LD_INT 0
5163: PPUSH
5164: PPUSH
// Sci1 := Pty ;
5165: LD_ADDR_VAR 0 2
5169: PUSH
5170: LD_LOC 6
5174: ST_TO_ADDR
// if not IsLive ( Pty ) then
5175: LD_LOC 6
5179: PPUSH
5180: CALL_OW 300
5184: NOT
5185: IFFALSE 5216
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5187: LD_ADDR_VAR 0 2
5191: PUSH
5192: LD_LOC 11
5196: PPUSH
5197: LD_EXP 1
5201: PPUSH
5202: LD_INT 1
5204: PPUSH
5205: LD_INT 4
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: CALL 23510 0 5
5215: ST_TO_ADDR
// if Sci1 then
5216: LD_VAR 0 2
5220: IFFALSE 5256
// begin DialogueOn ;
5222: CALL_OW 6
// if Say ( Sci1 , DApeSolCompl-Pty-1 ) then
5226: LD_VAR 0 2
5230: PPUSH
5231: LD_STRING DApeSolCompl-Pty-1
5233: PPUSH
5234: CALL_OW 88
5238: IFFALSE 5252
// Say ( Bur , DApeSolCompl-Bur-1 ) ;
5240: LD_LOC 1
5244: PPUSH
5245: LD_STRING DApeSolCompl-Bur-1
5247: PPUSH
5248: CALL_OW 88
// DialogueOff ;
5252: CALL_OW 7
// end ; end ;
5256: LD_VAR 0 1
5260: RET
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and depot and ( FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Petrovova , Gleb ] ) do
5261: LD_EXP 46
5265: PUSH
5266: LD_EXP 66
5270: NOT
5271: AND
5272: PUSH
5273: LD_EXP 14
5277: AND
5278: PUSH
5279: LD_INT 10
5281: PPUSH
5282: LD_INT 22
5284: PUSH
5285: LD_EXP 1
5289: PUSH
5290: EMPTY
5291: LIST
5292: LIST
5293: PUSH
5294: LD_INT 23
5296: PUSH
5297: LD_INT 3
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: PPUSH
5308: CALL_OW 70
5312: PUSH
5313: LD_EXP 50
5317: PUSH
5318: LD_EXP 53
5322: PUSH
5323: LD_EXP 54
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: LIST
5332: DIFF
5333: AND
5334: IFFALSE 5475
5336: GO 5338
5338: DISABLE
// begin if IsDead ( Pty ) then
5339: LD_LOC 6
5343: PPUSH
5344: CALL_OW 301
5348: IFFALSE 5360
// Pty := Dol ;
5350: LD_ADDR_LOC 6
5354: PUSH
5355: LD_LOC 10
5359: ST_TO_ADDR
// if IsDead ( Pty ) then
5360: LD_LOC 6
5364: PPUSH
5365: CALL_OW 301
5369: IFFALSE 5381
// Pty := Kar ;
5371: LD_ADDR_LOC 6
5375: PUSH
5376: LD_LOC 3
5380: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5381: LD_LOC 6
5385: PUSH
5386: LD_INT 10
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_EXP 1
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 23
5403: PUSH
5404: LD_INT 3
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL_OW 70
5419: IN
5420: IFFALSE 5433
// DStevens ( Pty ) else
5422: LD_LOC 6
5426: PPUSH
5427: CALL 5676 0 1
5431: GO 5475
// DStevens ( FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) [ 1 ] ) ;
5433: LD_INT 10
5435: PPUSH
5436: LD_INT 22
5438: PUSH
5439: LD_EXP 1
5443: PUSH
5444: EMPTY
5445: LIST
5446: LIST
5447: PUSH
5448: LD_INT 23
5450: PUSH
5451: LD_INT 3
5453: PUSH
5454: EMPTY
5455: LIST
5456: LIST
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PPUSH
5462: CALL_OW 70
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PPUSH
5471: CALL 5676 0 1
// end ;
5475: END
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) > 3 ) do
5476: LD_EXP 46
5480: PUSH
5481: LD_EXP 66
5485: NOT
5486: AND
5487: PUSH
5488: LD_INT 28
5490: PPUSH
5491: LD_INT 22
5493: PUSH
5494: LD_EXP 1
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 2
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 70
5521: PUSH
5522: LD_INT 3
5524: GREATER
5525: AND
5526: IFFALSE 5675
5528: GO 5530
5530: DISABLE
// begin if IsDead ( Pty ) then
5531: LD_LOC 6
5535: PPUSH
5536: CALL_OW 301
5540: IFFALSE 5552
// Pty := Dol ;
5542: LD_ADDR_LOC 6
5546: PUSH
5547: LD_LOC 10
5551: ST_TO_ADDR
// if IsDead ( Pty ) then
5552: LD_LOC 6
5556: PPUSH
5557: CALL_OW 301
5561: IFFALSE 5573
// Pty := Kar ;
5563: LD_ADDR_LOC 6
5567: PUSH
5568: LD_LOC 3
5572: ST_TO_ADDR
// vespod := true ;
5573: LD_ADDR_EXP 64
5577: PUSH
5578: LD_INT 1
5580: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5581: LD_LOC 6
5585: PUSH
5586: LD_INT 28
5588: PPUSH
5589: LD_INT 22
5591: PUSH
5592: LD_EXP 1
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: PUSH
5601: LD_INT 23
5603: PUSH
5604: LD_INT 3
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PPUSH
5615: CALL_OW 70
5619: IN
5620: IFFALSE 5633
// DStevens ( Pty ) else
5622: LD_LOC 6
5626: PPUSH
5627: CALL 5676 0 1
5631: GO 5675
// DStevens ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) [ 1 ] ) ;
5633: LD_INT 28
5635: PPUSH
5636: LD_INT 22
5638: PUSH
5639: LD_EXP 1
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: PUSH
5648: LD_INT 23
5650: PUSH
5651: LD_INT 3
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: PPUSH
5662: CALL_OW 70
5666: PUSH
5667: LD_INT 1
5669: ARRAY
5670: PPUSH
5671: CALL 5676 0 1
// end ;
5675: END
// export vespod , vespod2 , byl_stevens ; function DStevens ( who ) ; begin
5676: LD_INT 0
5678: PPUSH
// if not vespod then
5679: LD_EXP 64
5683: NOT
5684: IFFALSE 5703
// PlaceUnitArea ( Huck , stv_site , true ) else
5686: LD_LOC 7
5690: PPUSH
5691: LD_INT 12
5693: PPUSH
5694: LD_INT 1
5696: PPUSH
5697: CALL_OW 49
5701: GO 5718
// PlaceUnitArea ( Huck , stv_site2 , true ) ;
5703: LD_LOC 7
5707: PPUSH
5708: LD_INT 29
5710: PPUSH
5711: LD_INT 1
5713: PPUSH
5714: CALL_OW 49
// wait ( 0 0$4 ) ;
5718: LD_INT 140
5720: PPUSH
5721: CALL_OW 67
// ComStop ( who ) ;
5725: LD_VAR 0 1
5729: PPUSH
5730: CALL_OW 141
// ComTurnUnit ( who , huck ) ;
5734: LD_VAR 0 1
5738: PPUSH
5739: LD_LOC 7
5743: PPUSH
5744: CALL_OW 119
// ComTurnUnit ( huck , who ) ;
5748: LD_LOC 7
5752: PPUSH
5753: LD_VAR 0 1
5757: PPUSH
5758: CALL_OW 119
// CenterNowOnUnits ( huck ) ;
5762: LD_LOC 7
5766: PPUSH
5767: CALL_OW 87
// Stevens_killed := true ;
5771: LD_ADDR_EXP 11
5775: PUSH
5776: LD_INT 1
5778: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5779: LD_INT 35
5781: PPUSH
5782: CALL_OW 67
// DialogueOn ;
5786: CALL_OW 6
// if IsDead ( Pty ) then
5790: LD_LOC 6
5794: PPUSH
5795: CALL_OW 301
5799: IFFALSE 5811
// Pty := Dol ;
5801: LD_ADDR_LOC 6
5805: PUSH
5806: LD_LOC 10
5810: ST_TO_ADDR
// if IsDead ( Pty ) then
5811: LD_LOC 6
5815: PPUSH
5816: CALL_OW 301
5820: IFFALSE 5832
// Pty := Kar ;
5822: LD_ADDR_LOC 6
5826: PUSH
5827: LD_LOC 3
5831: ST_TO_ADDR
// if IsOk ( Pty ) then
5832: LD_LOC 6
5836: PPUSH
5837: CALL_OW 302
5841: IFFALSE 6222
// begin if who = Pty then
5843: LD_VAR 0 1
5847: PUSH
5848: LD_LOC 6
5852: EQUAL
5853: IFFALSE 5957
// begin SetAttitude ( you , americans , att_enemy , false ) ;
5855: LD_EXP 1
5859: PPUSH
5860: LD_EXP 2
5864: PPUSH
5865: LD_INT 2
5867: PPUSH
5868: LD_INT 0
5870: PPUSH
5871: CALL_OW 80
// DialogueOff ;
5875: CALL_OW 7
// while GetLives ( huck ) > 940 do
5879: LD_LOC 7
5883: PPUSH
5884: CALL_OW 256
5888: PUSH
5889: LD_INT 940
5891: GREATER
5892: IFFALSE 5903
// Wait ( 0 0$0.5 ) ;
5894: LD_INT 18
5896: PPUSH
5897: CALL_OW 67
5901: GO 5879
// SetAttitude ( you , americans , att_neutral , true ) ;
5903: LD_EXP 1
5907: PPUSH
5908: LD_EXP 2
5912: PPUSH
5913: LD_INT 0
5915: PPUSH
5916: LD_INT 1
5918: PPUSH
5919: CALL_OW 80
// ComStop ( who ) ;
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
5932: LD_INT 4
5934: PPUSH
5935: CALL_OW 67
// DialogueOn ;
5939: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
5943: LD_LOC 7
5947: PPUSH
5948: LD_STRING DStevens-Huck-1
5950: PPUSH
5951: CALL_OW 88
// end else
5955: GO 6088
// begin Say ( who , DStevens-RSol1-1 ) ;
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_STRING DStevens-RSol1-1
5964: PPUSH
5965: CALL_OW 88
// DialogueOff ;
5969: CALL_OW 7
// Wait ( 0 0$0.7 ) ;
5973: LD_INT 24
5975: PPUSH
5976: CALL_OW 67
// SetAttitude ( you , americans , att_enemy , false ) ;
5980: LD_EXP 1
5984: PPUSH
5985: LD_EXP 2
5989: PPUSH
5990: LD_INT 2
5992: PPUSH
5993: LD_INT 0
5995: PPUSH
5996: CALL_OW 80
// while GetLives ( huck ) > 940 do
6000: LD_LOC 7
6004: PPUSH
6005: CALL_OW 256
6009: PUSH
6010: LD_INT 940
6012: GREATER
6013: IFFALSE 6024
// Wait ( 0 0$0.5 ) ;
6015: LD_INT 18
6017: PPUSH
6018: CALL_OW 67
6022: GO 6000
// SetAttitude ( you , americans , att_neutral , true ) ;
6024: LD_EXP 1
6028: PPUSH
6029: LD_EXP 2
6033: PPUSH
6034: LD_INT 0
6036: PPUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL_OW 80
// ComStop ( who ) ;
6044: LD_VAR 0 1
6048: PPUSH
6049: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
6053: LD_INT 4
6055: PPUSH
6056: CALL_OW 67
// DialogueOn ;
6060: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
6064: LD_LOC 7
6068: PPUSH
6069: LD_STRING DStevens-Huck-1
6071: PPUSH
6072: CALL_OW 88
// Say ( Pty , DStevens-Pty-1 ) ;
6076: LD_LOC 6
6080: PPUSH
6081: LD_STRING DStevens-Pty-1
6083: PPUSH
6084: CALL_OW 88
// end ; Say ( Pty , DStevens-Pty-1a ) ;
6088: LD_LOC 6
6092: PPUSH
6093: LD_STRING DStevens-Pty-1a
6095: PPUSH
6096: CALL_OW 88
// Say ( Huck , DStevens-Huck-2 ) ;
6100: LD_LOC 7
6104: PPUSH
6105: LD_STRING DStevens-Huck-2
6107: PPUSH
6108: CALL_OW 88
// Say ( Pty , DStevens-Pty-2 ) ;
6112: LD_LOC 6
6116: PPUSH
6117: LD_STRING DStevens-Pty-2
6119: PPUSH
6120: CALL_OW 88
// Say ( Huck , DStevens-Huck-3 ) ;
6124: LD_LOC 7
6128: PPUSH
6129: LD_STRING DStevens-Huck-3
6131: PPUSH
6132: CALL_OW 88
// Say ( Pty , DStevens-Pty-3 ) ;
6136: LD_LOC 6
6140: PPUSH
6141: LD_STRING DStevens-Pty-3
6143: PPUSH
6144: CALL_OW 88
// Say ( Huck , DStevens-Huck-4 ) ;
6148: LD_LOC 7
6152: PPUSH
6153: LD_STRING DStevens-Huck-4
6155: PPUSH
6156: CALL_OW 88
// Say ( Pty , DStevens-Pty-4 ) ;
6160: LD_LOC 6
6164: PPUSH
6165: LD_STRING DStevens-Pty-4
6167: PPUSH
6168: CALL_OW 88
// SetAttitude ( you , americans , att_friend , true ) ;
6172: LD_EXP 1
6176: PPUSH
6177: LD_EXP 2
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 1
6187: PPUSH
6188: CALL_OW 80
// SetSide ( huck , you2 ) ;
6192: LD_LOC 7
6196: PPUSH
6197: LD_EXP 5
6201: PPUSH
6202: CALL_OW 235
// ComMoveUnit ( huck , who ) ;
6206: LD_LOC 7
6210: PPUSH
6211: LD_VAR 0 1
6215: PPUSH
6216: CALL_OW 112
// end else
6220: GO 6254
// begin Say ( who , DStevens-RSol1-1 ) ;
6222: LD_VAR 0 1
6226: PPUSH
6227: LD_STRING DStevens-RSol1-1
6229: PPUSH
6230: CALL_OW 88
// SetAttitude ( you , americans , att_enemy , true ) ;
6234: LD_EXP 1
6238: PPUSH
6239: LD_EXP 2
6243: PPUSH
6244: LD_INT 2
6246: PPUSH
6247: LD_INT 1
6249: PPUSH
6250: CALL_OW 80
// end ; byl_stevens := true ;
6254: LD_ADDR_EXP 66
6258: PUSH
6259: LD_INT 1
6261: ST_TO_ADDR
// DialogueOff ;
6262: CALL_OW 7
// end ;
6266: LD_VAR 0 2
6270: RET
// var stv_depot ; every 1 trigger GetSide ( Huck ) = 3 or GetSide ( Huck ) = 6 do
6271: LD_LOC 7
6275: PPUSH
6276: CALL_OW 255
6280: PUSH
6281: LD_INT 3
6283: EQUAL
6284: PUSH
6285: LD_LOC 7
6289: PPUSH
6290: CALL_OW 255
6294: PUSH
6295: LD_INT 6
6297: EQUAL
6298: OR
6299: IFFALSE 6333
6301: GO 6303
6303: DISABLE
// begin if not GetClass ( Huck ) = 4 then
6304: LD_LOC 7
6308: PPUSH
6309: CALL_OW 257
6313: PUSH
6314: LD_INT 4
6316: EQUAL
6317: NOT
6318: IFFALSE 6332
// SetClass ( Huck , 4 ) ;
6320: LD_LOC 7
6324: PPUSH
6325: LD_INT 4
6327: PPUSH
6328: CALL_OW 336
// enable ;
6332: ENABLE
// end ;
6333: END
// function HumansInDepots ; var labs , i , inlabs ; begin
6334: LD_INT 0
6336: PPUSH
6337: PPUSH
6338: PPUSH
6339: PPUSH
// inlabs := [ ] ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: EMPTY
6346: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6347: LD_ADDR_VAR 0 2
6351: PUSH
6352: LD_INT 22
6354: PUSH
6355: LD_EXP 1
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 2
6366: PUSH
6367: LD_INT 30
6369: PUSH
6370: LD_INT 0
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: LD_INT 30
6379: PUSH
6380: LD_INT 1
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PPUSH
6396: CALL_OW 69
6400: ST_TO_ADDR
// for i in labs do
6401: LD_ADDR_VAR 0 3
6405: PUSH
6406: LD_VAR 0 2
6410: PUSH
6411: FOR_IN
6412: IFFALSE 6437
// inlabs := inlabs ^ UnitsInside ( i ) ;
6414: LD_ADDR_VAR 0 4
6418: PUSH
6419: LD_VAR 0 4
6423: PUSH
6424: LD_VAR 0 3
6428: PPUSH
6429: CALL_OW 313
6433: ADD
6434: ST_TO_ADDR
6435: GO 6411
6437: POP
6438: POP
// result := inlabs ;
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: LD_VAR 0 4
6448: ST_TO_ADDR
// end ;
6449: LD_VAR 0 1
6453: RET
// every 0 0$5 + 0 0$3 trigger dialogy and byl_stevens and ( not vespod and ( IsInArea ( Huck , stred ) ) or GetDistUnits ( Burlak , Huck ) < 13 ) do
6454: LD_EXP 46
6458: PUSH
6459: LD_EXP 66
6463: AND
6464: PUSH
6465: LD_EXP 64
6469: NOT
6470: PUSH
6471: LD_LOC 7
6475: PPUSH
6476: LD_INT 11
6478: PPUSH
6479: CALL_OW 308
6483: AND
6484: PUSH
6485: LD_EXP 50
6489: PPUSH
6490: LD_LOC 7
6494: PPUSH
6495: CALL_OW 296
6499: PUSH
6500: LD_INT 13
6502: LESS
6503: OR
6504: AND
6505: IFFALSE 6578
6507: GO 6509
6509: DISABLE
// begin if IsDead ( Pty ) then
6510: LD_LOC 6
6514: PPUSH
6515: CALL_OW 301
6519: IFFALSE 6531
// Pty := Dol ;
6521: LD_ADDR_LOC 6
6525: PUSH
6526: LD_LOC 10
6530: ST_TO_ADDR
// if IsDead ( Pty ) then
6531: LD_LOC 6
6535: PPUSH
6536: CALL_OW 301
6540: IFFALSE 6552
// Pty := Kar ;
6542: LD_ADDR_LOC 6
6546: PUSH
6547: LD_LOC 3
6551: ST_TO_ADDR
// if IsLive ( Pty ) and IsLive ( Huck ) then
6552: LD_LOC 6
6556: PPUSH
6557: CALL_OW 300
6561: PUSH
6562: LD_LOC 7
6566: PPUSH
6567: CALL_OW 300
6571: AND
6572: IFFALSE 6578
// DStevensBurlak ;
6574: CALL 6579 0 0
// end ;
6578: END
// function DStevensBurlak ; var qr , tmp_depot ; begin
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
6583: PPUSH
// DialogueOn ;
6584: CALL_OW 6
// Say ( Pty , DStevensBurlak-Pty-1 ) ;
6588: LD_LOC 6
6592: PPUSH
6593: LD_STRING DStevensBurlak-Pty-1
6595: PPUSH
6596: CALL_OW 88
// Say ( Bur , DStevensBurlak-Bur-1 ) ;
6600: LD_LOC 1
6604: PPUSH
6605: LD_STRING DStevensBurlak-Bur-1
6607: PPUSH
6608: CALL_OW 88
// Say ( Pty , DStevensBurlak-Pty-2 ) ;
6612: LD_LOC 6
6616: PPUSH
6617: LD_STRING DStevensBurlak-Pty-2
6619: PPUSH
6620: CALL_OW 88
// qr := Query ( QKill ) ;
6624: LD_ADDR_VAR 0 2
6628: PUSH
6629: LD_STRING QKill
6631: PPUSH
6632: CALL_OW 97
6636: ST_TO_ADDR
// if qr = 1 then
6637: LD_VAR 0 2
6641: PUSH
6642: LD_INT 1
6644: EQUAL
6645: IFFALSE 6716
// begin Say ( Bur , DKill-1-Bur-1 ) ;
6647: LD_LOC 1
6651: PPUSH
6652: LD_STRING DKill-1-Bur-1
6654: PPUSH
6655: CALL_OW 88
// SetSide ( Huck , americans ) ;
6659: LD_LOC 7
6663: PPUSH
6664: LD_EXP 2
6668: PPUSH
6669: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
6673: LD_EXP 1
6677: PPUSH
6678: LD_EXP 2
6682: PPUSH
6683: LD_INT 2
6685: PPUSH
6686: LD_INT 1
6688: PPUSH
6689: CALL_OW 80
// if IsLive ( Glb ) then
6693: LD_LOC 5
6697: PPUSH
6698: CALL_OW 300
6702: IFFALSE 6716
// Say ( Glb , DKill-1-Glb-1 ) ;
6704: LD_LOC 5
6708: PPUSH
6709: LD_STRING DKill-1-Glb-1
6711: PPUSH
6712: CALL_OW 88
// end ; if qr = 2 then
6716: LD_VAR 0 2
6720: PUSH
6721: LD_INT 2
6723: EQUAL
6724: IFFALSE 6777
// begin Say ( Bur , DKill-2-Bur-1 ) ;
6726: LD_LOC 1
6730: PPUSH
6731: LD_STRING DKill-2-Bur-1
6733: PPUSH
6734: CALL_OW 88
// Say ( Pty , DKill-2-Pty-1 ) ;
6738: LD_LOC 6
6742: PPUSH
6743: LD_STRING DKill-2-Pty-1
6745: PPUSH
6746: CALL_OW 88
// if not vespod then
6750: LD_EXP 64
6754: NOT
6755: IFFALSE 6769
// Say ( Bur , DKill-2-Bur-2 ) ;
6757: LD_LOC 1
6761: PPUSH
6762: LD_STRING DKill-2-Bur-2
6764: PPUSH
6765: CALL_OW 88
// StevensStayInBase = 1 ;
6769: LD_ADDR_EXP 49
6773: PUSH
6774: LD_INT 1
6776: ST_TO_ADDR
// end ; DialogueOff ;
6777: CALL_OW 7
// if not vespod and qr = 2 then
6781: LD_EXP 64
6785: NOT
6786: PUSH
6787: LD_VAR 0 2
6791: PUSH
6792: LD_INT 2
6794: EQUAL
6795: AND
6796: IFFALSE 6982
// begin while not tmp_depot do
6798: LD_VAR 0 3
6802: NOT
6803: IFFALSE 6879
// begin tmp_depot := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
6805: LD_ADDR_VAR 0 3
6809: PUSH
6810: LD_INT 22
6812: PUSH
6813: LD_EXP 1
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: PUSH
6822: LD_INT 50
6824: PUSH
6825: EMPTY
6826: LIST
6827: PUSH
6828: LD_INT 2
6830: PUSH
6831: LD_INT 30
6833: PUSH
6834: LD_INT 1
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: PUSH
6841: LD_INT 30
6843: PUSH
6844: LD_INT 0
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 69
6865: PUSH
6866: LD_INT 1
6868: ARRAY
6869: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
6870: LD_INT 35
6872: PPUSH
6873: CALL_OW 67
// end ;
6877: GO 6798
// while GetDistUnits ( Huck , tmp_depot ) > 5 do
6879: LD_LOC 7
6883: PPUSH
6884: LD_VAR 0 3
6888: PPUSH
6889: CALL_OW 296
6893: PUSH
6894: LD_INT 5
6896: GREATER
6897: IFFALSE 6922
// begin ComMoveUnit ( Huck , tmp_depot ) ;
6899: LD_LOC 7
6903: PPUSH
6904: LD_VAR 0 3
6908: PPUSH
6909: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
6913: LD_INT 4
6915: PPUSH
6916: CALL_OW 67
// end ;
6920: GO 6879
// SetSide ( Huck , you ) ;
6922: LD_LOC 7
6926: PPUSH
6927: LD_EXP 1
6931: PPUSH
6932: CALL_OW 235
// while not ( huck in HumansInDepots ) do
6936: LD_LOC 7
6940: PUSH
6941: CALL 6334 0 0
6945: IN
6946: NOT
6947: IFFALSE 6972
// begin ComMoveUnit ( Huck , tmp_depot ) ;
6949: LD_LOC 7
6953: PPUSH
6954: LD_VAR 0 3
6958: PPUSH
6959: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
6963: LD_INT 4
6965: PPUSH
6966: CALL_OW 67
// end ;
6970: GO 6936
// stv_depot := tmp_depot ;
6972: LD_ADDR_LOC 12
6976: PUSH
6977: LD_VAR 0 3
6981: ST_TO_ADDR
// end ; if vespod and qr = 2 then
6982: LD_EXP 64
6986: PUSH
6987: LD_VAR 0 2
6991: PUSH
6992: LD_INT 2
6994: EQUAL
6995: AND
6996: IFFALSE 7021
// begin DialogueOn ;
6998: CALL_OW 6
// DWait ( 0 0$4.5 ) ;
7002: LD_INT 158
7004: PPUSH
7005: CALL_OW 68
// DialogueOff ;
7009: CALL_OW 7
// vespod2 := true ;
7013: LD_ADDR_EXP 65
7017: PUSH
7018: LD_INT 1
7020: ST_TO_ADDR
// end ; if qr = 1 then
7021: LD_VAR 0 2
7025: PUSH
7026: LD_INT 1
7028: EQUAL
7029: IFFALSE 7078
// begin while not IsInArea ( huck , stv_exit ) do
7031: LD_LOC 7
7035: PPUSH
7036: LD_INT 21
7038: PPUSH
7039: CALL_OW 308
7043: NOT
7044: IFFALSE 7069
// begin ComMoveToArea ( Huck , stv_exit ) ;
7046: LD_LOC 7
7050: PPUSH
7051: LD_INT 21
7053: PPUSH
7054: CALL_OW 113
// DU_wait ( Huck ) ;
7058: LD_LOC 7
7062: PPUSH
7063: CALL 21968 0 1
// end ;
7067: GO 7031
// RemoveUnit ( Huck ) ;
7069: LD_LOC 7
7073: PPUSH
7074: CALL_OW 64
// end ; end ;
7078: LD_VAR 0 1
7082: RET
// function DQrKillAgain_1 ; begin
7083: LD_INT 0
7085: PPUSH
// DialogueOn ;
7086: CALL_OW 6
// Say ( Bur , DQrKillAgain#1-Bur-1 ) ;
7090: LD_LOC 1
7094: PPUSH
7095: LD_STRING DQrKillAgain#1-Bur-1
7097: PPUSH
7098: CALL_OW 88
// DialogueOff ;
7102: CALL_OW 7
// SetSide ( Huck , americans ) ;
7106: LD_LOC 7
7110: PPUSH
7111: LD_EXP 2
7115: PPUSH
7116: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
7120: LD_EXP 1
7124: PPUSH
7125: LD_EXP 2
7129: PPUSH
7130: LD_INT 2
7132: PPUSH
7133: LD_INT 1
7135: PPUSH
7136: CALL_OW 80
// Stevens_Killed := true ;
7140: LD_ADDR_EXP 11
7144: PUSH
7145: LD_INT 1
7147: ST_TO_ADDR
// stv_depot := 0 ;
7148: LD_ADDR_LOC 12
7152: PUSH
7153: LD_INT 0
7155: ST_TO_ADDR
// end ;
7156: LD_VAR 0 1
7160: RET
// function DQrKillAgain_2 ; begin
7161: LD_INT 0
7163: PPUSH
// DialogueOn ;
7164: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1 ) ;
7168: LD_LOC 1
7172: PPUSH
7173: LD_STRING DQrKillAgain#2-Bur-1
7175: PPUSH
7176: CALL_OW 88
// DialogueOff ;
7180: CALL_OW 7
// stv_depot := 0 ;
7184: LD_ADDR_LOC 12
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// SetSide ( Huck , americans ) ;
7192: LD_LOC 7
7196: PPUSH
7197: LD_EXP 2
7201: PPUSH
7202: CALL_OW 235
// ComMoveToArea ( Huck , Stv_exit ) ;
7206: LD_LOC 7
7210: PPUSH
7211: LD_INT 21
7213: PPUSH
7214: CALL_OW 113
// while not ( IsInArea ( Huck , stv_exit ) ) do
7218: LD_LOC 7
7222: PPUSH
7223: LD_INT 21
7225: PPUSH
7226: CALL_OW 308
7230: NOT
7231: IFFALSE 7242
// wait ( 0 0$1 ) ;
7233: LD_INT 35
7235: PPUSH
7236: CALL_OW 67
7240: GO 7218
// RemoveUnit ( Huck ) ;
7242: LD_LOC 7
7246: PPUSH
7247: CALL_OW 64
// end ;
7251: LD_VAR 0 1
7255: RET
// function DQrKillAgain_3 ; var tmp_depot ; begin
7256: LD_INT 0
7258: PPUSH
7259: PPUSH
// DialogueOn ;
7260: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1a ) ;
7264: LD_LOC 1
7268: PPUSH
7269: LD_STRING DQrKillAgain#2-Bur-1a
7271: PPUSH
7272: CALL_OW 88
// DialogueOff ;
7276: CALL_OW 7
// SetSide ( Huck , you2 ) ;
7280: LD_LOC 7
7284: PPUSH
7285: LD_EXP 5
7289: PPUSH
7290: CALL_OW 235
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7294: LD_ADDR_VAR 0 2
7298: PUSH
7299: LD_INT 22
7301: PUSH
7302: LD_EXP 1
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PUSH
7311: LD_INT 50
7313: PUSH
7314: EMPTY
7315: LIST
7316: PUSH
7317: LD_INT 2
7319: PUSH
7320: LD_INT 30
7322: PUSH
7323: LD_INT 1
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PUSH
7330: LD_INT 30
7332: PUSH
7333: LD_INT 0
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: LIST
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: LIST
7349: PPUSH
7350: CALL_OW 69
7354: ST_TO_ADDR
// if tmp_depot = 0 then
7355: LD_VAR 0 2
7359: PUSH
7360: LD_INT 0
7362: EQUAL
7363: IFFALSE 7489
// repeat wait ( 0 0$1 ) ;
7365: LD_INT 35
7367: PPUSH
7368: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7372: LD_ADDR_VAR 0 2
7376: PUSH
7377: LD_INT 22
7379: PUSH
7380: LD_EXP 1
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: PUSH
7389: LD_INT 50
7391: PUSH
7392: EMPTY
7393: LIST
7394: PUSH
7395: LD_INT 2
7397: PUSH
7398: LD_INT 30
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 30
7410: PUSH
7411: LD_INT 0
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: PPUSH
7428: CALL_OW 69
7432: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7433: LD_LOC 1
7437: PPUSH
7438: CALL_OW 310
7442: IFFALSE 7465
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7444: LD_LOC 7
7448: PPUSH
7449: LD_LOC 1
7453: PPUSH
7454: CALL_OW 310
7458: PPUSH
7459: CALL_OW 112
7463: GO 7479
// ComMoveUnit ( Huck , Bur ) ;
7465: LD_LOC 7
7469: PPUSH
7470: LD_LOC 1
7474: PPUSH
7475: CALL_OW 112
// until tmp_depot > 0 ;
7479: LD_VAR 0 2
7483: PUSH
7484: LD_INT 0
7486: GREATER
7487: IFFALSE 7365
// if tmp_depot > 0 then
7489: LD_VAR 0 2
7493: PUSH
7494: LD_INT 0
7496: GREATER
7497: IFFALSE 7803
// begin repeat tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7499: LD_ADDR_VAR 0 2
7503: PUSH
7504: LD_INT 22
7506: PUSH
7507: LD_EXP 1
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 50
7518: PUSH
7519: EMPTY
7520: LIST
7521: PUSH
7522: LD_INT 2
7524: PUSH
7525: LD_INT 30
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 30
7537: PUSH
7538: LD_INT 0
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: LIST
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: LIST
7554: PPUSH
7555: CALL_OW 69
7559: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7560: LD_INT 35
7562: PPUSH
7563: CALL_OW 67
// ComMoveUnit ( Huck , tmp_depot [ 1 ] ) ;
7567: LD_LOC 7
7571: PPUSH
7572: LD_VAR 0 2
7576: PUSH
7577: LD_INT 1
7579: ARRAY
7580: PPUSH
7581: CALL_OW 112
// until GetDistUnits ( Huck , tmp_depot [ 1 ] ) < 5 or tmp_depot = 0 ;
7585: LD_LOC 7
7589: PPUSH
7590: LD_VAR 0 2
7594: PUSH
7595: LD_INT 1
7597: ARRAY
7598: PPUSH
7599: CALL_OW 296
7603: PUSH
7604: LD_INT 5
7606: LESS
7607: PUSH
7608: LD_VAR 0 2
7612: PUSH
7613: LD_INT 0
7615: EQUAL
7616: OR
7617: IFFALSE 7499
// if tmp_depot = 0 then
7619: LD_VAR 0 2
7623: PUSH
7624: LD_INT 0
7626: EQUAL
7627: IFFALSE 7753
// repeat wait ( 0 0$1 ) ;
7629: LD_INT 35
7631: PPUSH
7632: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7636: LD_ADDR_VAR 0 2
7640: PUSH
7641: LD_INT 22
7643: PUSH
7644: LD_EXP 1
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 50
7655: PUSH
7656: EMPTY
7657: LIST
7658: PUSH
7659: LD_INT 2
7661: PUSH
7662: LD_INT 30
7664: PUSH
7665: LD_INT 1
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 30
7674: PUSH
7675: LD_INT 0
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: LIST
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: LIST
7691: PPUSH
7692: CALL_OW 69
7696: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7697: LD_LOC 1
7701: PPUSH
7702: CALL_OW 310
7706: IFFALSE 7729
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7708: LD_LOC 7
7712: PPUSH
7713: LD_LOC 1
7717: PPUSH
7718: CALL_OW 310
7722: PPUSH
7723: CALL_OW 112
7727: GO 7743
// ComMoveUnit ( Huck , Bur ) ;
7729: LD_LOC 7
7733: PPUSH
7734: LD_LOC 1
7738: PPUSH
7739: CALL_OW 112
// until tmp_depot > 0 ;
7743: LD_VAR 0 2
7747: PUSH
7748: LD_INT 0
7750: GREATER
7751: IFFALSE 7629
// SetSide ( Huck , you ) ;
7753: LD_LOC 7
7757: PPUSH
7758: LD_EXP 1
7762: PPUSH
7763: CALL_OW 235
// repeat wait ( 0 0$0.1 ) ;
7767: LD_INT 4
7769: PPUSH
7770: CALL_OW 67
// ComEnterUnit ( Huck , tmp_depot [ 1 ] ) ;
7774: LD_LOC 7
7778: PPUSH
7779: LD_VAR 0 2
7783: PUSH
7784: LD_INT 1
7786: ARRAY
7787: PPUSH
7788: CALL_OW 120
// until IsInUnit ( Huck ) ;
7792: LD_LOC 7
7796: PPUSH
7797: CALL_OW 310
7801: IFFALSE 7767
// end ; end ;
7803: LD_VAR 0 1
7807: RET
// every 0 0$3 trigger dialogy and byl_stevens and IsOK ( Huck ) and StevensStayInBase = 1 and not IsInUnit ( Huck ) do var qr ;
7808: LD_EXP 46
7812: PUSH
7813: LD_EXP 66
7817: AND
7818: PUSH
7819: LD_LOC 7
7823: PPUSH
7824: CALL_OW 302
7828: AND
7829: PUSH
7830: LD_EXP 49
7834: PUSH
7835: LD_INT 1
7837: EQUAL
7838: AND
7839: PUSH
7840: LD_LOC 7
7844: PPUSH
7845: CALL_OW 310
7849: NOT
7850: AND
7851: IFFALSE 8007
7853: GO 7855
7855: DISABLE
7856: LD_INT 0
7858: PPUSH
// begin DialogueOn ;
7859: CALL_OW 6
// Stevens_killed := false ;
7863: LD_ADDR_EXP 11
7867: PUSH
7868: LD_INT 0
7870: ST_TO_ADDR
// Say ( Bur , DRelease-Bur-1 ) ;
7871: LD_LOC 1
7875: PPUSH
7876: LD_STRING DRelease-Bur-1
7878: PPUSH
7879: CALL_OW 88
// DialogueOff ;
7883: CALL_OW 7
// if vespod then
7887: LD_EXP 64
7891: IFFALSE 7918
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 ] ) else
7893: LD_ADDR_VAR 0 1
7897: PUSH
7898: LD_STRING QKillAgain
7900: PPUSH
7901: LD_INT 1
7903: PUSH
7904: LD_INT 2
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: PPUSH
7911: CALL_OW 98
7915: ST_TO_ADDR
7916: GO 7945
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 , 3 ] ) ;
7918: LD_ADDR_VAR 0 1
7922: PUSH
7923: LD_STRING QKillAgain
7925: PPUSH
7926: LD_INT 1
7928: PUSH
7929: LD_INT 2
7931: PUSH
7932: LD_INT 3
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: LIST
7939: PPUSH
7940: CALL_OW 98
7944: ST_TO_ADDR
// case qr of 1 :
7945: LD_VAR 0 1
7949: PUSH
7950: LD_INT 1
7952: DOUBLE
7953: EQUAL
7954: IFTRUE 7958
7956: GO 7965
7958: POP
// DQrKillAgain_1 ; 2 :
7959: CALL 7083 0 0
7963: GO 7996
7965: LD_INT 2
7967: DOUBLE
7968: EQUAL
7969: IFTRUE 7973
7971: GO 7980
7973: POP
// DQrKillAgain_2 ; 3 :
7974: CALL 7161 0 0
7978: GO 7996
7980: LD_INT 3
7982: DOUBLE
7983: EQUAL
7984: IFTRUE 7988
7986: GO 7995
7988: POP
// DQrKillAgain_3 ; end ;
7989: CALL 7256 0 0
7993: GO 7996
7995: POP
// if qr = 3 then
7996: LD_VAR 0 1
8000: PUSH
8001: LD_INT 3
8003: EQUAL
8004: IFFALSE 8007
// enable ;
8006: ENABLE
// end ;
8007: PPOPN 1
8009: END
// function DStevensLeftBehind ; var r , Sol1 ; begin
8010: LD_INT 0
8012: PPUSH
8013: PPUSH
8014: PPUSH
// DialogueOn ;
8015: CALL_OW 6
// Sol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
8019: LD_ADDR_VAR 0 3
8023: PUSH
8024: LD_LOC 11
8028: PPUSH
8029: LD_EXP 1
8033: PPUSH
8034: LD_INT 1
8036: PPUSH
8037: LD_INT 0
8039: PPUSH
8040: LD_INT 0
8042: PPUSH
8043: CALL 23510 0 5
8047: ST_TO_ADDR
// if IsOk ( Pty ) then
8048: LD_LOC 6
8052: PPUSH
8053: CALL_OW 302
8057: IFFALSE 8079
// r := Say ( Pty , DStevensLeftBehind-Pty-1 ) else
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: LD_LOC 6
8068: PPUSH
8069: LD_STRING DStevensLeftBehind-Pty-1
8071: PPUSH
8072: CALL_OW 88
8076: ST_TO_ADDR
8077: GO 8097
// r := Say ( Sol1 , DStevensLeftBehind-RSol1-1 ) ;
8079: LD_ADDR_VAR 0 2
8083: PUSH
8084: LD_VAR 0 3
8088: PPUSH
8089: LD_STRING DStevensLeftBehind-RSol1-1
8091: PPUSH
8092: CALL_OW 88
8096: ST_TO_ADDR
// if r then
8097: LD_VAR 0 2
8101: IFFALSE 8115
// Say ( Bur , DStevensLeftBehind-Bur-1 ) ;
8103: LD_LOC 1
8107: PPUSH
8108: LD_STRING DStevensLeftBehind-Bur-1
8110: PPUSH
8111: CALL_OW 88
// Stevens_Killed := true ;
8115: LD_ADDR_EXP 11
8119: PUSH
8120: LD_INT 1
8122: ST_TO_ADDR
// DialogueOff ;
8123: CALL_OW 7
// end ;
8127: LD_VAR 0 1
8131: RET
// var was_sheikh_obj ; every 0 0$1 trigger dialogy and See ( you , Mastodon ) do var a ;
8132: LD_EXP 46
8136: PUSH
8137: LD_EXP 1
8141: PPUSH
8142: LD_INT 1
8144: PPUSH
8145: CALL_OW 292
8149: AND
8150: IFFALSE 8237
8152: GO 8154
8154: DISABLE
8155: LD_INT 0
8157: PPUSH
// begin if not was_sheikh_obj then
8158: LD_LOC 13
8162: NOT
8163: IFFALSE 8180
// begin ChangeMissionObjectives ( MAddSheikh ) ;
8165: LD_STRING MAddSheikh
8167: PPUSH
8168: CALL_OW 337
// was_sheikh_obj := true ;
8172: LD_ADDR_LOC 13
8176: PUSH
8177: LD_INT 1
8179: ST_TO_ADDR
// end ; a := NearestUnitToUnit ( UnitFilter ( donttalk , [ f_sex , sex_male ] ) ^ Burlak , Mastodon ) ;
8180: LD_ADDR_VAR 0 1
8184: PUSH
8185: LD_LOC 11
8189: PPUSH
8190: LD_INT 26
8192: PUSH
8193: LD_INT 1
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PPUSH
8200: CALL_OW 72
8204: PUSH
8205: LD_EXP 50
8209: ADD
8210: PPUSH
8211: LD_INT 1
8213: PPUSH
8214: CALL_OW 74
8218: ST_TO_ADDR
// if a then
8219: LD_VAR 0 1
8223: IFFALSE 8236
// DMastodon ( a ) else
8225: LD_VAR 0 1
8229: PPUSH
8230: CALL 8240 0 1
8234: GO 8237
// enable ;
8236: ENABLE
// end ;
8237: PPOPN 1
8239: END
// function DMastodon ( who ) ; begin
8240: LD_INT 0
8242: PPUSH
// DialogueOn ;
8243: CALL_OW 6
// if who = Bur then
8247: LD_VAR 0 1
8251: PUSH
8252: LD_LOC 1
8256: EQUAL
8257: IFFALSE 8273
// Say ( who , DMastodon-Bur-1 ) else
8259: LD_VAR 0 1
8263: PPUSH
8264: LD_STRING DMastodon-Bur-1
8266: PPUSH
8267: CALL_OW 88
8271: GO 8285
// Say ( who , DMastodon-RSol1-1 ) ;
8273: LD_VAR 0 1
8277: PPUSH
8278: LD_STRING DMastodon-RSol1-1
8280: PPUSH
8281: CALL_OW 88
// Say ( Glb , DMastodon-Glb-1 ) ;
8285: LD_LOC 5
8289: PPUSH
8290: LD_STRING DMastodon-Glb-1
8292: PPUSH
8293: CALL_OW 88
// DialogueOff ;
8297: CALL_OW 7
// end ;
8301: LD_VAR 0 2
8305: RET
// every 0 0$1 trigger dialogy and IsDead ( Omar ) do
8306: LD_EXP 46
8310: PUSH
8311: LD_EXP 61
8315: PPUSH
8316: CALL_OW 301
8320: AND
8321: IFFALSE 8337
8323: GO 8325
8325: DISABLE
// begin DOmar ;
8326: CALL 8338 0 0
// ChangeMissionObjectives ( MOutSheikh ) ;
8330: LD_STRING MOutSheikh
8332: PPUSH
8333: CALL_OW 337
// end ;
8337: END
// function DOmar ; var who , mytick ; begin
8338: LD_INT 0
8340: PPUSH
8341: PPUSH
8342: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , class_soldier , 0 ) ;
8343: LD_ADDR_VAR 0 2
8347: PUSH
8348: LD_LOC 11
8352: PPUSH
8353: LD_EXP 1
8357: PPUSH
8358: LD_INT 1
8360: PPUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 0
8366: PPUSH
8367: CALL 23510 0 5
8371: ST_TO_ADDR
// DialogueOn ;
8372: CALL_OW 6
// if IsLive ( Kar ) then
8376: LD_LOC 3
8380: PPUSH
8381: CALL_OW 300
8385: IFFALSE 8399
// Say ( Kar , DOmar-Kar-1 ) ;
8387: LD_LOC 3
8391: PPUSH
8392: LD_STRING DOmar-Kar-1
8394: PPUSH
8395: CALL_OW 88
// if IsLive ( Ptr ) then
8399: LD_LOC 4
8403: PPUSH
8404: CALL_OW 300
8408: IFFALSE 8422
// Say ( Ptr , DOmar-Ptr-1 ) ;
8410: LD_LOC 4
8414: PPUSH
8415: LD_STRING DOmar-Ptr-1
8417: PPUSH
8418: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
8422: LD_LOC 3
8426: PPUSH
8427: CALL_OW 300
8431: NOT
8432: PUSH
8433: LD_LOC 4
8437: PPUSH
8438: CALL_OW 300
8442: NOT
8443: AND
8444: IFFALSE 8458
// Say ( who , DOmar-RSol1-1 ) ;
8446: LD_VAR 0 2
8450: PPUSH
8451: LD_STRING DOmar-RSol1-1
8453: PPUSH
8454: CALL_OW 88
// if SayRadio ( Heike , DOmar-Hke-1 ) then
8458: LD_EXP 60
8462: PPUSH
8463: LD_STRING DOmar-Hke-1
8465: PPUSH
8466: CALL_OW 94
8470: IFFALSE 8484
// Say ( Bur , DOmar-Bur-1 ) ;
8472: LD_LOC 1
8476: PPUSH
8477: LD_STRING DOmar-Bur-1
8479: PPUSH
8480: CALL_OW 88
// DialogueOff ;
8484: CALL_OW 7
// end ;
8488: LD_VAR 0 1
8492: RET
// every 0 0$1 + 0 0$3.5 trigger dialogy do var i , arForces ;
8493: LD_EXP 46
8497: IFFALSE 8644
8499: GO 8501
8501: DISABLE
8502: LD_INT 0
8504: PPUSH
8505: PPUSH
// begin enable ;
8506: ENABLE
// arForces = FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
8507: LD_ADDR_VAR 0 2
8511: PUSH
8512: LD_INT 22
8514: PUSH
8515: LD_INT 2
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 21
8524: PUSH
8525: LD_INT 1
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PUSH
8532: EMPTY
8533: LIST
8534: LIST
8535: PPUSH
8536: CALL_OW 69
8540: ST_TO_ADDR
// for i in UnitsInside ( FilterUnitsInArea ( RoadArea , [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ) do
8541: LD_ADDR_VAR 0 1
8545: PUSH
8546: LD_INT 32
8548: PPUSH
8549: LD_INT 22
8551: PUSH
8552: LD_INT 2
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: LD_INT 21
8561: PUSH
8562: LD_INT 2
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PPUSH
8573: CALL_OW 70
8577: PPUSH
8578: CALL_OW 313
8582: PUSH
8583: FOR_IN
8584: IFFALSE 8604
// arForces = arForces diff i ;
8586: LD_ADDR_VAR 0 2
8590: PUSH
8591: LD_VAR 0 2
8595: PUSH
8596: LD_VAR 0 1
8600: DIFF
8601: ST_TO_ADDR
8602: GO 8583
8604: POP
8605: POP
// if arForces <= 4 and ( IsDead ( Omar ) or not IsPlaced ( Omar ) ) then
8606: LD_VAR 0 2
8610: PUSH
8611: LD_INT 4
8613: LESSEQUAL
8614: PUSH
8615: LD_EXP 61
8619: PPUSH
8620: CALL_OW 301
8624: PUSH
8625: LD_EXP 61
8629: PPUSH
8630: CALL_OW 305
8634: NOT
8635: OR
8636: AND
8637: IFFALSE 8644
// begin disable ;
8639: DISABLE
// DBreaktrough ;
8640: CALL 8647 0 0
// end ; end ;
8644: PPOPN 2
8646: END
// function DBreaktrough ; begin
8647: LD_INT 0
8649: PPUSH
// if tick <= breaketrough_time then
8650: LD_OWVAR 1
8654: PUSH
8655: LD_EXP 17
8659: LESSEQUAL
8660: IFFALSE 8670
// action_was_fast := true ;
8662: LD_ADDR_EXP 9
8666: PUSH
8667: LD_INT 1
8669: ST_TO_ADDR
// breaked_trough := true ;
8670: LD_ADDR_EXP 10
8674: PUSH
8675: LD_INT 1
8677: ST_TO_ADDR
// DialogueOn ;
8678: CALL_OW 6
// Say ( Ptr , DBreakthrough-Ptr-1 ) ;
8682: LD_LOC 4
8686: PPUSH
8687: LD_STRING DBreakthrough-Ptr-1
8689: PPUSH
8690: CALL_OW 88
// Say ( Bur , DBreakthrough-Bur-1 ) ;
8694: LD_LOC 1
8698: PPUSH
8699: LD_STRING DBreakthrough-Bur-1
8701: PPUSH
8702: CALL_OW 88
// SayRadio ( Pla , DBreakthrough-Pla-1 ) ;
8706: LD_LOC 2
8710: PPUSH
8711: LD_STRING DBreakthrough-Pla-1
8713: PPUSH
8714: CALL_OW 94
// if action_was_fast then
8718: LD_EXP 9
8722: IFFALSE 8738
// SayRadio ( Pla , DBreakthrough-Pla-1a ) else
8724: LD_LOC 2
8728: PPUSH
8729: LD_STRING DBreakthrough-Pla-1a
8731: PPUSH
8732: CALL_OW 94
8736: GO 8750
// SayRadio ( Pla , DBreakthrough-Pla-1b ) ;
8738: LD_LOC 2
8742: PPUSH
8743: LD_STRING DBreakthrough-Pla-1b
8745: PPUSH
8746: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
8750: LD_INT 22
8752: PUSH
8753: LD_EXP 1
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PUSH
8762: LD_INT 23
8764: PUSH
8765: LD_INT 3
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 6
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 7
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: LD_INT 30
8797: PUSH
8798: LD_INT 8
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PPUSH
8816: CALL_OW 69
8820: IFFALSE 8849
// begin SayRadio ( Pla , DBreakthrough-Pla-1c ) ;
8822: LD_LOC 2
8826: PPUSH
8827: LD_STRING DBreakthrough-Pla-1c
8829: PPUSH
8830: CALL_OW 94
// ChangeMissionObjectives ( MAddLab ) ;
8834: LD_STRING MAddLab
8836: PPUSH
8837: CALL_OW 337
// znicit_lab := true ;
8841: LD_ADDR_EXP 67
8845: PUSH
8846: LD_INT 1
8848: ST_TO_ADDR
// end ; if byl_stevens and IsLive ( Huck ) and stv_depot then
8849: LD_EXP 66
8853: PUSH
8854: LD_LOC 7
8858: PPUSH
8859: CALL_OW 300
8863: AND
8864: PUSH
8865: LD_LOC 12
8869: AND
8870: IFFALSE 8876
// DStevensLeftBehind ;
8872: CALL 8010 0 0
// DialogueOff ;
8876: CALL_OW 7
// end ;
8880: LD_VAR 0 1
8884: RET
// export znicit_lab ; every 0 0$3 trigger znicit_lab and not FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
8885: LD_EXP 67
8889: PUSH
8890: LD_INT 22
8892: PUSH
8893: LD_EXP 1
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 23
8904: PUSH
8905: LD_INT 3
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PUSH
8912: LD_INT 2
8914: PUSH
8915: LD_INT 30
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 30
8927: PUSH
8928: LD_INT 7
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 30
8937: PUSH
8938: LD_INT 8
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: PPUSH
8956: CALL_OW 69
8960: NOT
8961: AND
8962: IFFALSE 8974
8964: GO 8966
8966: DISABLE
// begin ChangeMissionObjectives ( MOutLab ) ;
8967: LD_STRING MOutLab
8969: PPUSH
8970: CALL_OW 337
// end ;
8974: END
// every 0 0$5 + 0 0$0.5 trigger dialogy and breaked_trough and FilterUnitsInArea ( enter_near_road , [ [ f_side , you ] ] ) and See_any ( you , [ ArScout1 , ArScout2 , ArScout3 ] ) do
8975: LD_EXP 46
8979: PUSH
8980: LD_EXP 10
8984: AND
8985: PUSH
8986: LD_INT 9
8988: PPUSH
8989: LD_INT 22
8991: PUSH
8992: LD_EXP 1
8996: PUSH
8997: EMPTY
8998: LIST
8999: LIST
9000: PUSH
9001: EMPTY
9002: LIST
9003: PPUSH
9004: CALL_OW 70
9008: AND
9009: PUSH
9010: LD_EXP 1
9014: PPUSH
9015: LD_EXP 76
9019: PUSH
9020: LD_EXP 77
9024: PUSH
9025: LD_EXP 78
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL 23711 0 2
9039: AND
9040: IFFALSE 9049
9042: GO 9044
9044: DISABLE
// begin DPatrol ;
9045: CALL 9050 0 0
// end ;
9049: END
// function DPatrol ; var RSol1 ; begin
9050: LD_INT 0
9052: PPUSH
9053: PPUSH
// RSol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_LOC 11
9063: PPUSH
9064: LD_EXP 1
9068: PPUSH
9069: LD_INT 1
9071: PPUSH
9072: LD_INT 0
9074: PPUSH
9075: LD_INT 0
9077: PPUSH
9078: CALL 23510 0 5
9082: ST_TO_ADDR
// DialogueOn ;
9083: CALL_OW 6
// if IsLive ( Kar ) then
9087: LD_LOC 3
9091: PPUSH
9092: CALL_OW 300
9096: IFFALSE 9110
// Say ( Kar , DPatrol-Kar-1 ) ;
9098: LD_LOC 3
9102: PPUSH
9103: LD_STRING DPatrol-Kar-1
9105: PPUSH
9106: CALL_OW 88
// if IsLive ( Ptr ) then
9110: LD_LOC 4
9114: PPUSH
9115: CALL_OW 300
9119: IFFALSE 9133
// Say ( Ptr , DPatrol-Ptr-1 ) ;
9121: LD_LOC 4
9125: PPUSH
9126: LD_STRING DPatrol-Ptr-1
9128: PPUSH
9129: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
9133: LD_LOC 3
9137: PPUSH
9138: CALL_OW 300
9142: NOT
9143: PUSH
9144: LD_LOC 4
9148: PPUSH
9149: CALL_OW 300
9153: NOT
9154: AND
9155: IFFALSE 9169
// Say ( RSol1 , DPatrol-RSol1-1 ) ;
9157: LD_VAR 0 2
9161: PPUSH
9162: LD_STRING DPatrol-RSol1-1
9164: PPUSH
9165: CALL_OW 88
// Say ( Bur , DPatrol-Bur-1 ) ;
9169: LD_LOC 1
9173: PPUSH
9174: LD_STRING DPatrol-Bur-1
9176: PPUSH
9177: CALL_OW 88
// DialogueOff ;
9181: CALL_OW 7
// end ;
9185: LD_VAR 0 1
9189: RET
// var used1 , used2 ; function TestEnd ; var lidi_in , lidi_in_cars , lidi_all , i ; begin
9190: LD_INT 0
9192: PPUSH
9193: PPUSH
9194: PPUSH
9195: PPUSH
9196: PPUSH
// lidi_in_cars = [ ] ;
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: EMPTY
9203: ST_TO_ADDR
// lidi_in := FilterHumansInArea ( exit_rus , [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9204: LD_ADDR_VAR 0 2
9208: PUSH
9209: LD_INT 22
9211: PPUSH
9212: LD_INT 22
9214: PUSH
9215: LD_EXP 1
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: PUSH
9224: LD_INT 23
9226: PUSH
9227: LD_INT 3
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: PUSH
9234: LD_INT 21
9236: PUSH
9237: LD_INT 1
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: EMPTY
9245: LIST
9246: LIST
9247: LIST
9248: PPUSH
9249: CALL 23795 0 2
9253: ST_TO_ADDR
// for i in lidi_in do
9254: LD_ADDR_VAR 0 5
9258: PUSH
9259: LD_VAR 0 2
9263: PUSH
9264: FOR_IN
9265: IFFALSE 9308
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
9267: LD_VAR 0 5
9271: PPUSH
9272: CALL_OW 310
9276: PPUSH
9277: CALL_OW 247
9281: PUSH
9282: LD_INT 2
9284: EQUAL
9285: IFFALSE 9306
// begin lidi_in_cars := lidi_in_cars ^ [ i ] ;
9287: LD_ADDR_VAR 0 3
9291: PUSH
9292: LD_VAR 0 3
9296: PUSH
9297: LD_VAR 0 5
9301: PUSH
9302: EMPTY
9303: LIST
9304: ADD
9305: ST_TO_ADDR
// end ;
9306: GO 9264
9308: POP
9309: POP
// result := 0 ;
9310: LD_ADDR_VAR 0 1
9314: PUSH
9315: LD_INT 0
9317: ST_TO_ADDR
// if ( lidi_in >= 6 ) and ( IsInArea ( IsInUnit ( Bur ) , exit_rus ) ) then
9318: LD_VAR 0 2
9322: PUSH
9323: LD_INT 6
9325: GREATEREQUAL
9326: PUSH
9327: LD_LOC 1
9331: PPUSH
9332: CALL_OW 310
9336: PPUSH
9337: LD_INT 22
9339: PPUSH
9340: CALL_OW 308
9344: AND
9345: IFFALSE 9497
// begin lidi_all := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9347: LD_ADDR_VAR 0 4
9351: PUSH
9352: LD_INT 22
9354: PUSH
9355: LD_EXP 1
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PUSH
9364: LD_INT 23
9366: PUSH
9367: LD_INT 3
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PUSH
9374: LD_INT 21
9376: PUSH
9377: LD_INT 1
9379: PUSH
9380: EMPTY
9381: LIST
9382: LIST
9383: PUSH
9384: EMPTY
9385: LIST
9386: LIST
9387: LIST
9388: PPUSH
9389: CALL_OW 69
9393: ST_TO_ADDR
// if lidi_in_cars >= 6 then
9394: LD_VAR 0 3
9398: PUSH
9399: LD_INT 6
9401: GREATEREQUAL
9402: IFFALSE 9462
// begin if ( lidi_all + 0 ) > ( lidi_in_cars + 0 ) then
9404: LD_VAR 0 4
9408: PUSH
9409: LD_INT 0
9411: PLUS
9412: PUSH
9413: LD_VAR 0 3
9417: PUSH
9418: LD_INT 0
9420: PLUS
9421: GREATER
9422: IFFALSE 9432
// begin result := 2 ;
9424: LD_ADDR_VAR 0 1
9428: PUSH
9429: LD_INT 2
9431: ST_TO_ADDR
// end ; if ( lidi_all + 0 ) <= ( lidi_in_cars + 0 ) then
9432: LD_VAR 0 4
9436: PUSH
9437: LD_INT 0
9439: PLUS
9440: PUSH
9441: LD_VAR 0 3
9445: PUSH
9446: LD_INT 0
9448: PLUS
9449: LESSEQUAL
9450: IFFALSE 9460
// result := 3 ;
9452: LD_ADDR_VAR 0 1
9456: PUSH
9457: LD_INT 3
9459: ST_TO_ADDR
// end else
9460: GO 9497
// begin if not used1 and ( lidi_in + 0 ) > ( lidi_in_cars + 0 ) then
9462: LD_LOC 14
9466: NOT
9467: PUSH
9468: LD_VAR 0 2
9472: PUSH
9473: LD_INT 0
9475: PLUS
9476: PUSH
9477: LD_VAR 0 3
9481: PUSH
9482: LD_INT 0
9484: PLUS
9485: GREATER
9486: AND
9487: IFFALSE 9497
// begin result := 1 ;
9489: LD_ADDR_VAR 0 1
9493: PUSH
9494: LD_INT 1
9496: ST_TO_ADDR
// end ; end ; end ; end ;
9497: LD_VAR 0 1
9501: RET
// every 0 0$2 do var qr ;
9502: GO 9504
9504: DISABLE
9505: LD_INT 0
9507: PPUSH
// begin case TestEnd of 0 :
9508: CALL 9190 0 0
9512: PUSH
9513: LD_INT 0
9515: DOUBLE
9516: EQUAL
9517: IFTRUE 9521
9519: GO 9532
9521: POP
// begin end_the_mission_allowed := false ;
9522: LD_ADDR_OWVAR 57
9526: PUSH
9527: LD_INT 0
9529: ST_TO_ADDR
// end ; 1 :
9530: GO 9663
9532: LD_INT 1
9534: DOUBLE
9535: EQUAL
9536: IFTRUE 9540
9538: GO 9579
9540: POP
// begin end_the_mission_allowed := false ;
9541: LD_ADDR_OWVAR 57
9545: PUSH
9546: LD_INT 0
9548: ST_TO_ADDR
// if not used1 then
9549: LD_LOC 14
9553: NOT
9554: IFFALSE 9577
// begin qr := Query ( Qvehicles ) ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_STRING Qvehicles
9563: PPUSH
9564: CALL_OW 97
9568: ST_TO_ADDR
// used1 := true ;
9569: LD_ADDR_LOC 14
9573: PUSH
9574: LD_INT 1
9576: ST_TO_ADDR
// end ; end ; 2 :
9577: GO 9663
9579: LD_INT 2
9581: DOUBLE
9582: EQUAL
9583: IFTRUE 9587
9585: GO 9647
9587: POP
// begin end_the_mission_allowed := true ;
9588: LD_ADDR_OWVAR 57
9592: PUSH
9593: LD_INT 1
9595: ST_TO_ADDR
// if not used2 then
9596: LD_LOC 15
9600: NOT
9601: IFFALSE 9645
// begin ChangeMissionObjectives ( MOutDefend ) ;
9603: LD_STRING MOutDefend
9605: PPUSH
9606: CALL_OW 337
// qr := Query ( QEndMission ) ;
9610: LD_ADDR_VAR 0 1
9614: PUSH
9615: LD_STRING QEndMission
9617: PPUSH
9618: CALL_OW 97
9622: ST_TO_ADDR
// used2 := true ;
9623: LD_ADDR_LOC 15
9627: PUSH
9628: LD_INT 1
9630: ST_TO_ADDR
// if qr = 1 then
9631: LD_VAR 0 1
9635: PUSH
9636: LD_INT 1
9638: EQUAL
9639: IFFALSE 9645
// Vyhra ;
9641: CALL 301 0 0
// end ; end ; 3 :
9645: GO 9663
9647: LD_INT 3
9649: DOUBLE
9650: EQUAL
9651: IFTRUE 9655
9653: GO 9662
9655: POP
// begin Vyhra ;
9656: CALL 301 0 0
// end ; end ;
9660: GO 9663
9662: POP
// enable ;
9663: ENABLE
// end ;
9664: PPOPN 1
9666: END
// every 0 0$2 trigger IsInUnit ( Omar ) = mastodon do
9667: LD_EXP 61
9671: PPUSH
9672: CALL_OW 310
9676: PUSH
9677: LD_INT 1
9679: EQUAL
9680: IFFALSE 9697
9682: GO 9684
9684: DISABLE
// begin ComCarabine ( Omar ) ;
9685: LD_EXP 61
9689: PPUSH
9690: CALL_OW 162
// enable ( 99 ) ;
9694: LD_INT 99
9696: ENABLE_MARKED
// end ;
9697: END
// every 0 0$2 trigger not IsInUnit ( Omar ) = mastodon marked 99 do var mytick ;
9698: LD_EXP 61
9702: PPUSH
9703: CALL_OW 310
9707: PUSH
9708: LD_INT 1
9710: EQUAL
9711: NOT
9712: IFFALSE 9892
9714: GO 9716
9716: DISABLE
9717: LD_INT 0
9719: PPUSH
// begin ComSabre ( Omar ) ;
9720: LD_EXP 61
9724: PPUSH
9725: CALL_OW 163
// wait ( 0 0$1 ) ;
9729: LD_INT 35
9731: PPUSH
9732: CALL_OW 67
// mytick := tick + 0 0$5 ;
9736: LD_ADDR_VAR 0 1
9740: PUSH
9741: LD_OWVAR 1
9745: PUSH
9746: LD_INT 175
9748: PLUS
9749: ST_TO_ADDR
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
9750: LD_EXP 61
9754: PPUSH
9755: LD_INT 26
9757: PPUSH
9758: CALL_OW 308
9762: NOT
9763: PUSH
9764: LD_OWVAR 1
9768: PUSH
9769: LD_VAR 0 1
9773: LESS
9774: AND
9775: IFFALSE 9800
// begin ComMoveToArea ( Omar , omar_exit ) ;
9777: LD_EXP 61
9781: PPUSH
9782: LD_INT 26
9784: PPUSH
9785: CALL_OW 113
// DU_wait ( Omar ) ;
9789: LD_EXP 61
9793: PPUSH
9794: CALL 21968 0 1
// end ;
9798: GO 9750
// ComStop ( Omar ) ;
9800: LD_EXP 61
9804: PPUSH
9805: CALL_OW 141
// wait ( [ 4 4$30 , 2 2$15 , 0 0$30 ] [ difficulty ] ) ;
9809: LD_INT 9450
9811: PUSH
9812: LD_INT 4725
9814: PUSH
9815: LD_INT 1050
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: LIST
9822: PUSH
9823: LD_OWVAR 67
9827: ARRAY
9828: PPUSH
9829: CALL_OW 67
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
9833: LD_EXP 61
9837: PPUSH
9838: LD_INT 26
9840: PPUSH
9841: CALL_OW 308
9845: NOT
9846: PUSH
9847: LD_OWVAR 1
9851: PUSH
9852: LD_VAR 0 1
9856: LESS
9857: AND
9858: IFFALSE 9883
// begin ComMoveToArea ( Omar , omar_exit ) ;
9860: LD_EXP 61
9864: PPUSH
9865: LD_INT 26
9867: PPUSH
9868: CALL_OW 113
// DU_wait ( Omar ) ;
9872: LD_EXP 61
9876: PPUSH
9877: CALL 21968 0 1
// end ;
9881: GO 9833
// RemoveUnit ( Omar ) ;
9883: LD_EXP 61
9887: PPUSH
9888: CALL_OW 64
// end ; end_of_file
9892: PPOPN 1
9894: END
// var builds1 , builds2 , builds3 , builds4 , builds5 , builds6 , builds7 , builds8 ; export stavi ; var arabs_init ; var arabs ; var upgrade ; every 0 0$5 do var a ;
9895: GO 9897
9897: DISABLE
9898: LD_INT 0
9900: PPUSH
// begin a := sol ;
9901: LD_ADDR_VAR 0 1
9905: PUSH
9906: LD_EXP 19
9910: ST_TO_ADDR
// sol := UnitFilter ( a , [ [ f_class , class_soldier ] ] ) ;
9911: LD_ADDR_EXP 19
9915: PUSH
9916: LD_VAR 0 1
9920: PPUSH
9921: LD_INT 25
9923: PUSH
9924: LD_INT 1
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PUSH
9931: EMPTY
9932: LIST
9933: PPUSH
9934: CALL_OW 72
9938: ST_TO_ADDR
// mor := UnitFilter ( a , [ [ f_class , class_mortar ] ] ) ;
9939: LD_ADDR_EXP 20
9943: PUSH
9944: LD_VAR 0 1
9948: PPUSH
9949: LD_INT 25
9951: PUSH
9952: LD_INT 8
9954: PUSH
9955: EMPTY
9956: LIST
9957: LIST
9958: PUSH
9959: EMPTY
9960: LIST
9961: PPUSH
9962: CALL_OW 72
9966: ST_TO_ADDR
// enable ;
9967: ENABLE
// end ;
9968: PPOPN 1
9970: END
// every 30 30$0 do var a , i ;
9971: GO 9973
9973: DISABLE
9974: LD_INT 0
9976: PPUSH
9977: PPUSH
// begin InitUc ;
9978: CALL_OW 18
// InitHc ;
9982: CALL_OW 19
// uc_nation := nation_arabian ;
9986: LD_ADDR_OWVAR 21
9990: PUSH
9991: LD_INT 2
9993: ST_TO_ADDR
// uc_side := arabians ;
9994: LD_ADDR_OWVAR 20
9998: PUSH
9999: LD_EXP 3
10003: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
10004: LD_ADDR_VAR 0 2
10008: PUSH
10009: DOUBLE
10010: LD_INT 1
10012: DEC
10013: ST_TO_ADDR
10014: LD_INT 2
10016: PUSH
10017: LD_OWVAR 67
10021: PLUS
10022: PUSH
10023: FOR_TO
10024: IFFALSE 10090
// begin a := CreateHuman ;
10026: LD_ADDR_VAR 0 1
10030: PUSH
10031: CALL_OW 44
10035: ST_TO_ADDR
// PlaceUnitXYR ( a , 148 , 58 , 5 , false ) ;
10036: LD_VAR 0 1
10040: PPUSH
10041: LD_INT 148
10043: PPUSH
10044: LD_INT 58
10046: PPUSH
10047: LD_INT 5
10049: PPUSH
10050: LD_INT 0
10052: PPUSH
10053: CALL_OW 50
// ComMoveXY ( a , 134 , 68 ) ;
10057: LD_VAR 0 1
10061: PPUSH
10062: LD_INT 134
10064: PPUSH
10065: LD_INT 68
10067: PPUSH
10068: CALL_OW 111
// sol := sol ^ a ;
10072: LD_ADDR_EXP 19
10076: PUSH
10077: LD_EXP 19
10081: PUSH
10082: LD_VAR 0 1
10086: ADD
10087: ST_TO_ADDR
// end ;
10088: GO 10023
10090: POP
10091: POP
// end ;
10092: PPOPN 2
10094: END
// export function place_arabs_base ; begin
10095: LD_INT 0
10097: PPUSH
// upgrade := 10 ;
10098: LD_ADDR_LOC 26
10102: PUSH
10103: LD_INT 10
10105: ST_TO_ADDR
// arabs_init := [ [ [ 2 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 3 ] , [ 0 , class_mortar , 2 ] , [ 3 , class_mechanic , 3 ] ] , [ [ 2 , class_engineer , 5 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 1 , class_mortar , 3 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 2 , class_engineer , 6 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 6 ] , [ 2 , class_mortar , 5 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ;
10106: LD_ADDR_LOC 24
10110: PUSH
10111: LD_INT 2
10113: PUSH
10114: LD_INT 2
10116: PUSH
10117: LD_INT 4
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_INT 1
10127: PUSH
10128: LD_INT 4
10130: PUSH
10131: LD_INT 4
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 8
10141: PUSH
10142: LD_INT 1
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: PUSH
10153: LD_INT 0
10155: PUSH
10156: LD_INT 8
10158: PUSH
10159: LD_INT 2
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 3
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: EMPTY
10177: LIST
10178: LIST
10179: LIST
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: LD_INT 2
10193: PUSH
10194: LD_INT 5
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 1
10204: PUSH
10205: LD_INT 4
10207: PUSH
10208: LD_INT 4
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: PUSH
10216: LD_INT 8
10218: PUSH
10219: LD_INT 1
10221: PUSH
10222: LD_INT 4
10224: PUSH
10225: EMPTY
10226: LIST
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 1
10232: PUSH
10233: LD_INT 8
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 3
10249: PUSH
10250: LD_INT 4
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 2
10267: PUSH
10268: LD_INT 2
10270: PUSH
10271: LD_INT 6
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 1
10281: PUSH
10282: LD_INT 4
10284: PUSH
10285: LD_INT 4
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 8
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: LD_INT 6
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 2
10309: PUSH
10310: LD_INT 8
10312: PUSH
10313: LD_INT 5
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: LIST
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 6
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_OWVAR 67
10351: ARRAY
10352: ST_TO_ADDR
// builds1 := [ [ 124 , 60 , 2 , b_depot ] , [ 118 , 63 , 1 , b_breastwork ] , [ 120 , 66 , 1 , b_breastwork ] , [ 123 , 73 , 1 , b_breastwork ] ] ;
10353: LD_ADDR_LOC 16
10357: PUSH
10358: LD_INT 124
10360: PUSH
10361: LD_INT 60
10363: PUSH
10364: LD_INT 2
10366: PUSH
10367: LD_INT 0
10369: PUSH
10370: EMPTY
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: PUSH
10376: LD_INT 118
10378: PUSH
10379: LD_INT 63
10381: PUSH
10382: LD_INT 1
10384: PUSH
10385: LD_INT 31
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: PUSH
10394: LD_INT 120
10396: PUSH
10397: LD_INT 66
10399: PUSH
10400: LD_INT 1
10402: PUSH
10403: LD_INT 31
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: PUSH
10412: LD_INT 123
10414: PUSH
10415: LD_INT 73
10417: PUSH
10418: LD_INT 1
10420: PUSH
10421: LD_INT 31
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: LIST
10434: LIST
10435: ST_TO_ADDR
// builds2 := [ [ 129 , 74 , 2 , b_armoury ] , [ 131 , 51 , 2 , b_oil_mine ] , [ 138 , 78 , 5 , b_lab ] ] ;
10436: LD_ADDR_LOC 17
10440: PUSH
10441: LD_INT 129
10443: PUSH
10444: LD_INT 74
10446: PUSH
10447: LD_INT 2
10449: PUSH
10450: LD_INT 4
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 131
10461: PUSH
10462: LD_INT 51
10464: PUSH
10465: LD_INT 2
10467: PUSH
10468: LD_INT 29
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: PUSH
10477: LD_INT 138
10479: PUSH
10480: LD_INT 78
10482: PUSH
10483: LD_INT 5
10485: PUSH
10486: LD_INT 6
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: ST_TO_ADDR
// builds3 := [ [ 137 , 63 , 4 , b_workshop ] , [ 137 , 63 , upgrade , b_workshop ] , [ 137 , 60 , 3 , b_ext_stitch ] , [ 128 , 53 , 1 , b_oil_power ] , [ 140 , 66 , 5 , b_ext_track ] ] ;
10500: LD_ADDR_LOC 18
10504: PUSH
10505: LD_INT 137
10507: PUSH
10508: LD_INT 63
10510: PUSH
10511: LD_INT 4
10513: PUSH
10514: LD_INT 2
10516: PUSH
10517: EMPTY
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: PUSH
10523: LD_INT 137
10525: PUSH
10526: LD_INT 63
10528: PUSH
10529: LD_LOC 26
10533: PUSH
10534: LD_INT 2
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: PUSH
10543: LD_INT 137
10545: PUSH
10546: LD_INT 60
10548: PUSH
10549: LD_INT 3
10551: PUSH
10552: LD_INT 23
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: PUSH
10561: LD_INT 128
10563: PUSH
10564: LD_INT 53
10566: PUSH
10567: LD_INT 1
10569: PUSH
10570: LD_INT 26
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: PUSH
10579: LD_INT 140
10581: PUSH
10582: LD_INT 66
10584: PUSH
10585: LD_INT 5
10587: PUSH
10588: LD_INT 16
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: PUSH
10597: EMPTY
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: ST_TO_ADDR
// builds4 := [ [ 128 , 56 , 1 , b_oil_power ] , [ 138 , 78 , upgrade , b_lab , b_lab_weapon ] ] ;
10604: LD_ADDR_LOC 19
10608: PUSH
10609: LD_INT 128
10611: PUSH
10612: LD_INT 56
10614: PUSH
10615: LD_INT 1
10617: PUSH
10618: LD_INT 26
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 138
10629: PUSH
10630: LD_INT 78
10632: PUSH
10633: LD_LOC 26
10637: PUSH
10638: LD_INT 6
10640: PUSH
10641: LD_INT 10
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: LIST
10648: LIST
10649: LIST
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: ST_TO_ADDR
// builds5 := [ [ 141 , 63 , 4 , b_ext_gun ] ] ;
10655: LD_ADDR_LOC 20
10659: PUSH
10660: LD_INT 141
10662: PUSH
10663: LD_INT 63
10665: PUSH
10666: LD_INT 4
10668: PUSH
10669: LD_INT 17
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: LIST
10676: LIST
10677: PUSH
10678: EMPTY
10679: LIST
10680: ST_TO_ADDR
// builds6 := [ [ 129 , 74 , upgrade , b_armoury ] ] ;
10681: LD_ADDR_LOC 21
10685: PUSH
10686: LD_INT 129
10688: PUSH
10689: LD_INT 74
10691: PUSH
10692: LD_LOC 26
10696: PUSH
10697: LD_INT 4
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: PUSH
10706: EMPTY
10707: LIST
10708: ST_TO_ADDR
// builds7 := [ [ 138 , 78 , upgrade , b_lab , b_lab_opto ] , [ 118 , 61 , upgrade , b_breastwork , ar_gun ] , [ 120 , 66 , upgrade , b_breastwork , ar_gun ] , [ 123 , 73 , upgrade , b_breastwork , ar_gun ] , [ 124 , 60 , upgrade , b_depot ] ] ;
10709: LD_ADDR_LOC 22
10713: PUSH
10714: LD_INT 138
10716: PUSH
10717: LD_INT 78
10719: PUSH
10720: LD_LOC 26
10724: PUSH
10725: LD_INT 6
10727: PUSH
10728: LD_INT 15
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PUSH
10738: LD_INT 118
10740: PUSH
10741: LD_INT 61
10743: PUSH
10744: LD_LOC 26
10748: PUSH
10749: LD_INT 31
10751: PUSH
10752: LD_INT 27
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: LIST
10759: LIST
10760: LIST
10761: PUSH
10762: LD_INT 120
10764: PUSH
10765: LD_INT 66
10767: PUSH
10768: LD_LOC 26
10772: PUSH
10773: LD_INT 31
10775: PUSH
10776: LD_INT 27
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: LIST
10783: LIST
10784: LIST
10785: PUSH
10786: LD_INT 123
10788: PUSH
10789: LD_INT 73
10791: PUSH
10792: LD_LOC 26
10796: PUSH
10797: LD_INT 31
10799: PUSH
10800: LD_INT 27
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PUSH
10810: LD_INT 124
10812: PUSH
10813: LD_INT 60
10815: PUSH
10816: LD_LOC 26
10820: PUSH
10821: LD_INT 0
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: LIST
10828: LIST
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: ST_TO_ADDR
// builds8 := [ [ 137 , 67 , 0 , b_ext_radar ] ] ;
10837: LD_ADDR_LOC 23
10841: PUSH
10842: LD_INT 137
10844: PUSH
10845: LD_INT 67
10847: PUSH
10848: LD_INT 0
10850: PUSH
10851: LD_INT 20
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: PUSH
10860: EMPTY
10861: LIST
10862: ST_TO_ADDR
// place_base ( builds1 ) ;
10863: LD_LOC 16
10867: PPUSH
10868: CALL 10990 0 1
// place_arabs ;
10872: CALL 11196 0 0
// end ;
10876: LD_VAR 0 1
10880: RET
// every 0 0$5 do
10881: GO 10883
10883: DISABLE
// begin build_base ( builds2 ) ;
10884: LD_LOC 17
10888: PPUSH
10889: CALL 11416 0 1
// wait ( 0 0$40 ) ;
10893: LD_INT 1400
10895: PPUSH
10896: CALL_OW 67
// build_base ( builds3 ) ;
10900: LD_LOC 18
10904: PPUSH
10905: CALL 11416 0 1
// wait ( 2 2$0 ) ;
10909: LD_INT 4200
10911: PPUSH
10912: CALL_OW 67
// build_base ( builds4 ) ;
10916: LD_LOC 19
10920: PPUSH
10921: CALL 11416 0 1
// wait ( 3 3$0 ) ;
10925: LD_INT 6300
10927: PPUSH
10928: CALL_OW 67
// build_base ( builds5 ) ;
10932: LD_LOC 20
10936: PPUSH
10937: CALL 11416 0 1
// wait ( 10 10$0 ) ;
10941: LD_INT 21000
10943: PPUSH
10944: CALL_OW 67
// build_base ( builds6 ) ;
10948: LD_LOC 21
10952: PPUSH
10953: CALL 11416 0 1
// wait ( 10 10$0 ) ;
10957: LD_INT 21000
10959: PPUSH
10960: CALL_OW 67
// build_base ( builds7 ) ;
10964: LD_LOC 22
10968: PPUSH
10969: CALL 11416 0 1
// wait ( 5 5$0 ) ;
10973: LD_INT 10500
10975: PPUSH
10976: CALL_OW 67
// build_base ( builds8 ) ;
10980: LD_LOC 23
10984: PPUSH
10985: CALL 11416 0 1
// end ;
10989: END
// function place_base ( builds ) ; var i , base ; begin
10990: LD_INT 0
10992: PPUSH
10993: PPUSH
10994: PPUSH
// InitUc ;
10995: CALL_OW 18
// InitBc ;
10999: CALL_OW 21
// uc_side := arabians ;
11003: LD_ADDR_OWVAR 20
11007: PUSH
11008: LD_EXP 3
11012: ST_TO_ADDR
// uc_nation := nation_arabian ;
11013: LD_ADDR_OWVAR 21
11017: PUSH
11018: LD_INT 2
11020: ST_TO_ADDR
// for i in builds do
11021: LD_ADDR_VAR 0 3
11025: PUSH
11026: LD_VAR 0 1
11030: PUSH
11031: FOR_IN
11032: IFFALSE 11130
// begin bc_type := i [ 4 ] ;
11034: LD_ADDR_OWVAR 42
11038: PUSH
11039: LD_VAR 0 3
11043: PUSH
11044: LD_INT 4
11046: ARRAY
11047: ST_TO_ADDR
// if bc_type in [ b_lab , b_lab_half , b_lab_full ] then
11048: LD_OWVAR 42
11052: PUSH
11053: LD_INT 6
11055: PUSH
11056: LD_INT 7
11058: PUSH
11059: LD_INT 8
11061: PUSH
11062: EMPTY
11063: LIST
11064: LIST
11065: LIST
11066: IN
11067: IFFALSE 11097
// begin bc_kind1 := i [ 5 ] ;
11069: LD_ADDR_OWVAR 44
11073: PUSH
11074: LD_VAR 0 3
11078: PUSH
11079: LD_INT 5
11081: ARRAY
11082: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
11083: LD_ADDR_OWVAR 45
11087: PUSH
11088: LD_VAR 0 3
11092: PUSH
11093: LD_INT 6
11095: ARRAY
11096: ST_TO_ADDR
// end ; CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11097: LD_VAR 0 3
11101: PUSH
11102: LD_INT 1
11104: ARRAY
11105: PPUSH
11106: LD_VAR 0 3
11110: PUSH
11111: LD_INT 2
11113: ARRAY
11114: PPUSH
11115: LD_VAR 0 3
11119: PUSH
11120: LD_INT 3
11122: ARRAY
11123: PPUSH
11124: CALL_OW 47
// end ;
11128: GO 11031
11130: POP
11131: POP
// base := GetBase ( FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
11132: LD_ADDR_VAR 0 4
11136: PUSH
11137: LD_INT 30
11139: PUSH
11140: LD_INT 0
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PPUSH
11147: CALL_OW 69
11151: PUSH
11152: LD_INT 1
11154: ARRAY
11155: PPUSH
11156: CALL_OW 274
11160: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 450 ) ;
11161: LD_VAR 0 4
11165: PPUSH
11166: LD_INT 1
11168: PPUSH
11169: LD_INT 450
11171: PPUSH
11172: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11176: LD_VAR 0 4
11180: PPUSH
11181: LD_INT 2
11183: PPUSH
11184: LD_INT 200
11186: PPUSH
11187: CALL_OW 277
// end ;
11191: LD_VAR 0 2
11195: RET
// function place_arabs ; var i , j ; begin
11196: LD_INT 0
11198: PPUSH
11199: PPUSH
11200: PPUSH
// InitUc ;
11201: CALL_OW 18
// InitHc ;
11205: CALL_OW 19
// uc_side := arabians ;
11209: LD_ADDR_OWVAR 20
11213: PUSH
11214: LD_EXP 3
11218: ST_TO_ADDR
// uc_nation := nation_arabian ;
11219: LD_ADDR_OWVAR 21
11223: PUSH
11224: LD_INT 2
11226: ST_TO_ADDR
// PlaceUnitXY ( Mastodon , 130 , 67 , false ) ;
11227: LD_INT 1
11229: PPUSH
11230: LD_INT 130
11232: PPUSH
11233: LD_INT 67
11235: PPUSH
11236: LD_INT 0
11238: PPUSH
11239: CALL_OW 48
// PlaceUnitXYR ( Omar , GetX ( Mastodon ) , GetY ( Mastodon ) , 5 , false ) ;
11243: LD_EXP 61
11247: PPUSH
11248: LD_INT 1
11250: PPUSH
11251: CALL_OW 250
11255: PPUSH
11256: LD_INT 1
11258: PPUSH
11259: CALL_OW 251
11263: PPUSH
11264: LD_INT 5
11266: PPUSH
11267: LD_INT 0
11269: PPUSH
11270: CALL_OW 50
// ComCarabine ( Omar ) ;
11274: LD_EXP 61
11278: PPUSH
11279: CALL_OW 162
// AddComEnterUnit ( Omar , Mastodon ) ;
11283: LD_EXP 61
11287: PPUSH
11288: LD_INT 1
11290: PPUSH
11291: CALL_OW 180
// for i in arabs_init do
11295: LD_ADDR_VAR 0 2
11299: PUSH
11300: LD_LOC 24
11304: PUSH
11305: FOR_IN
11306: IFFALSE 11377
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
11308: LD_INT 0
11310: PPUSH
11311: LD_VAR 0 2
11315: PUSH
11316: LD_INT 2
11318: ARRAY
11319: PPUSH
11320: LD_VAR 0 2
11324: PUSH
11325: LD_INT 3
11327: ARRAY
11328: PPUSH
11329: CALL_OW 380
// for j := 1 to i [ 1 ] do
11333: LD_ADDR_VAR 0 3
11337: PUSH
11338: DOUBLE
11339: LD_INT 1
11341: DEC
11342: ST_TO_ADDR
11343: LD_VAR 0 2
11347: PUSH
11348: LD_INT 1
11350: ARRAY
11351: PUSH
11352: FOR_TO
11353: IFFALSE 11373
// begin arabs := arabs ^ CreateHuman ;
11355: LD_ADDR_LOC 25
11359: PUSH
11360: LD_LOC 25
11364: PUSH
11365: CALL_OW 44
11369: ADD
11370: ST_TO_ADDR
// end ;
11371: GO 11352
11373: POP
11374: POP
// end ;
11375: GO 11305
11377: POP
11378: POP
// for i in arabs do
11379: LD_ADDR_VAR 0 2
11383: PUSH
11384: LD_LOC 25
11388: PUSH
11389: FOR_IN
11390: IFFALSE 11409
// PlaceUnitArea ( i , ar_place , false ) ;
11392: LD_VAR 0 2
11396: PPUSH
11397: LD_INT 4
11399: PPUSH
11400: LD_INT 0
11402: PPUSH
11403: CALL_OW 49
11407: GO 11389
11409: POP
11410: POP
// end ;
11411: LD_VAR 0 1
11415: RET
// function build_base ( builds ) ; var i , a , tmp_eng , eng2 ; begin
11416: LD_INT 0
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// while not eng do
11423: LD_EXP 23
11427: NOT
11428: IFFALSE 11439
// wait ( 0 0$5 ) ;
11430: LD_INT 175
11432: PPUSH
11433: CALL_OW 67
11437: GO 11423
// eng2 := eng ;
11439: LD_ADDR_VAR 0 6
11443: PUSH
11444: LD_EXP 23
11448: ST_TO_ADDR
// tmp_eng := eng2 ;
11449: LD_ADDR_VAR 0 5
11453: PUSH
11454: LD_VAR 0 6
11458: ST_TO_ADDR
// eng := [ ] ;
11459: LD_ADDR_EXP 23
11463: PUSH
11464: EMPTY
11465: ST_TO_ADDR
// for i in builds do
11466: LD_ADDR_VAR 0 3
11470: PUSH
11471: LD_VAR 0 1
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11878
// begin ComExitBuilding ( tmp_eng ) ;
11479: LD_VAR 0 5
11483: PPUSH
11484: CALL_OW 122
// while not BuildingsInProgress ( arabians ) do
11488: LD_EXP 3
11492: PPUSH
11493: CALL_OW 345
11497: NOT
11498: IFFALSE 11823
// begin tmp_eng := eng2 diff DU_units ;
11500: LD_ADDR_VAR 0 5
11504: PUSH
11505: LD_VAR 0 6
11509: PUSH
11510: LD_EXP 82
11514: DIFF
11515: ST_TO_ADDR
// if i [ 3 ] = upgrade then
11516: LD_VAR 0 3
11520: PUSH
11521: LD_INT 3
11523: ARRAY
11524: PUSH
11525: LD_LOC 26
11529: EQUAL
11530: IFFALSE 11751
// begin if i [ 4 ] in [ b_lab , b_lab_half ] then
11532: LD_VAR 0 3
11536: PUSH
11537: LD_INT 4
11539: ARRAY
11540: PUSH
11541: LD_INT 6
11543: PUSH
11544: LD_INT 7
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: IN
11551: IFFALSE 11627
// begin AddComUpgradeLab ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11553: LD_VAR 0 3
11557: PUSH
11558: LD_INT 1
11560: ARRAY
11561: PPUSH
11562: LD_VAR 0 3
11566: PUSH
11567: LD_INT 2
11569: ARRAY
11570: PPUSH
11571: LD_VAR 0 3
11575: PUSH
11576: LD_INT 4
11578: ARRAY
11579: PPUSH
11580: CALL 11901 0 3
11584: PPUSH
11585: LD_VAR 0 3
11589: PUSH
11590: LD_INT 5
11592: ARRAY
11593: PPUSH
11594: CALL_OW 207
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11598: LD_VAR 0 5
11602: PPUSH
11603: LD_VAR 0 3
11607: PUSH
11608: LD_INT 1
11610: ARRAY
11611: PPUSH
11612: LD_VAR 0 3
11616: PUSH
11617: LD_INT 2
11619: ARRAY
11620: PPUSH
11621: CALL_OW 171
// end else
11625: GO 11749
// begin AddComUpgrade ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) ) ;
11627: LD_VAR 0 3
11631: PUSH
11632: LD_INT 1
11634: ARRAY
11635: PPUSH
11636: LD_VAR 0 3
11640: PUSH
11641: LD_INT 2
11643: ARRAY
11644: PPUSH
11645: LD_VAR 0 3
11649: PUSH
11650: LD_INT 4
11652: ARRAY
11653: PPUSH
11654: CALL 11901 0 3
11658: PPUSH
11659: CALL_OW 206
// if i [ 4 ] = b_breastwork then
11663: LD_VAR 0 3
11667: PUSH
11668: LD_INT 4
11670: ARRAY
11671: PUSH
11672: LD_INT 31
11674: EQUAL
11675: IFFALSE 11722
// AddComPlaceWeapon ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11677: LD_VAR 0 3
11681: PUSH
11682: LD_INT 1
11684: ARRAY
11685: PPUSH
11686: LD_VAR 0 3
11690: PUSH
11691: LD_INT 2
11693: ARRAY
11694: PPUSH
11695: LD_VAR 0 3
11699: PUSH
11700: LD_INT 4
11702: ARRAY
11703: PPUSH
11704: CALL 11901 0 3
11708: PPUSH
11709: LD_VAR 0 3
11713: PUSH
11714: LD_INT 5
11716: ARRAY
11717: PPUSH
11718: CALL_OW 208
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11722: LD_VAR 0 5
11726: PPUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_INT 1
11734: ARRAY
11735: PPUSH
11736: LD_VAR 0 3
11740: PUSH
11741: LD_INT 2
11743: ARRAY
11744: PPUSH
11745: CALL_OW 171
// end ; end else
11749: GO 11814
// begin AddComBuild ( UnitFilter ( tmp_eng , [ f_not , [ f_hastask ] ] ) , i [ 4 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11751: LD_VAR 0 5
11755: PPUSH
11756: LD_INT 3
11758: PUSH
11759: LD_INT 60
11761: PUSH
11762: EMPTY
11763: LIST
11764: PUSH
11765: EMPTY
11766: LIST
11767: LIST
11768: PPUSH
11769: CALL_OW 72
11773: PPUSH
11774: LD_VAR 0 3
11778: PUSH
11779: LD_INT 4
11781: ARRAY
11782: PPUSH
11783: LD_VAR 0 3
11787: PUSH
11788: LD_INT 1
11790: ARRAY
11791: PPUSH
11792: LD_VAR 0 3
11796: PUSH
11797: LD_INT 2
11799: ARRAY
11800: PPUSH
11801: LD_VAR 0 3
11805: PUSH
11806: LD_INT 3
11808: ARRAY
11809: PPUSH
11810: CALL_OW 205
// end ; wait ( 0 0$5 ) ;
11814: LD_INT 175
11816: PPUSH
11817: CALL_OW 67
// end ;
11821: GO 11488
// stavi := i ;
11823: LD_ADDR_EXP 68
11827: PUSH
11828: LD_VAR 0 3
11832: ST_TO_ADDR
// while BuildingsInProgress ( arabians ) do
11833: LD_EXP 3
11837: PPUSH
11838: CALL_OW 345
11842: IFFALSE 11853
// wait ( 0 0$1 ) ;
11844: LD_INT 35
11846: PPUSH
11847: CALL_OW 67
11851: GO 11833
// stavi := [ ] ;
11853: LD_ADDR_EXP 68
11857: PUSH
11858: EMPTY
11859: ST_TO_ADDR
// ComStop ( tmp_eng ) ;
11860: LD_VAR 0 5
11864: PPUSH
11865: CALL_OW 141
// wait ( 0 0$1 ) ;
11869: LD_INT 35
11871: PPUSH
11872: CALL_OW 67
// end ;
11876: GO 11476
11878: POP
11879: POP
// eng := eng union eng2 ;
11880: LD_ADDR_EXP 23
11884: PUSH
11885: LD_EXP 23
11889: PUSH
11890: LD_VAR 0 6
11894: UNION
11895: ST_TO_ADDR
// end ;
11896: LD_VAR 0 2
11900: RET
// function get_build ( x , y , btype ) ; var blds , i ; begin
11901: LD_INT 0
11903: PPUSH
11904: PPUSH
11905: PPUSH
// blds := FilterAllUnits ( [ f_btype , btype ] ) ;
11906: LD_ADDR_VAR 0 5
11910: PUSH
11911: LD_INT 30
11913: PUSH
11914: LD_VAR 0 3
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PPUSH
11923: CALL_OW 69
11927: ST_TO_ADDR
// for i in blds do
11928: LD_ADDR_VAR 0 6
11932: PUSH
11933: LD_VAR 0 5
11937: PUSH
11938: FOR_IN
11939: IFFALSE 11979
// if GetX ( i ) = x and GetY ( i ) = y then
11941: LD_VAR 0 6
11945: PPUSH
11946: CALL_OW 250
11950: PUSH
11951: LD_VAR 0 1
11955: EQUAL
11956: PUSH
11957: LD_VAR 0 6
11961: PPUSH
11962: CALL_OW 251
11966: PUSH
11967: LD_VAR 0 2
11971: EQUAL
11972: AND
11973: IFFALSE 11977
// break ;
11975: GO 11979
11977: GO 11938
11979: POP
11980: POP
// if GetX ( i ) = x and GetY ( i ) = y then
11981: LD_VAR 0 6
11985: PPUSH
11986: CALL_OW 250
11990: PUSH
11991: LD_VAR 0 1
11995: EQUAL
11996: PUSH
11997: LD_VAR 0 6
12001: PPUSH
12002: CALL_OW 251
12006: PUSH
12007: LD_VAR 0 2
12011: EQUAL
12012: AND
12013: IFFALSE 12027
// result := i else
12015: LD_ADDR_VAR 0 4
12019: PUSH
12020: LD_VAR 0 6
12024: ST_TO_ADDR
12025: GO 12035
// result := 0 ;
12027: LD_ADDR_VAR 0 4
12031: PUSH
12032: LD_INT 0
12034: ST_TO_ADDR
// end ;
12035: LD_VAR 0 4
12039: RET
// export function get_stavari ; begin
12040: LD_INT 0
12042: PPUSH
// result := get_x_best ( arabs_init [ 1 ] [ 1 ] , skill_engineering , class_engineer ) diff Omar ;
12043: LD_ADDR_VAR 0 1
12047: PUSH
12048: LD_LOC 24
12052: PUSH
12053: LD_INT 1
12055: ARRAY
12056: PUSH
12057: LD_INT 1
12059: ARRAY
12060: PPUSH
12061: LD_INT 2
12063: PPUSH
12064: LD_INT 2
12066: PPUSH
12067: CALL 23241 0 3
12071: PUSH
12072: LD_EXP 61
12076: DIFF
12077: ST_TO_ADDR
// end ; end_of_file
12078: LD_VAR 0 1
12082: RET
// export under_attack ; function full_forts ; var kdo , empty , i , a , uz_in ; begin
12083: LD_INT 0
12085: PPUSH
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
12090: PPUSH
// empty := [ ] ;
12091: LD_ADDR_VAR 0 3
12095: PUSH
12096: EMPTY
12097: ST_TO_ADDR
// uz_in := [ ] ;
12098: LD_ADDR_VAR 0 6
12102: PUSH
12103: EMPTY
12104: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_combat , class_mortar ) ^ get_x_best ( 0 , skill_combat , class_soldier ) ;
12105: LD_ADDR_VAR 0 2
12109: PUSH
12110: LD_INT 0
12112: PPUSH
12113: LD_INT 1
12115: PPUSH
12116: LD_INT 8
12118: PPUSH
12119: CALL 23241 0 3
12123: PUSH
12124: LD_INT 0
12126: PPUSH
12127: LD_INT 1
12129: PPUSH
12130: LD_INT 1
12132: PPUSH
12133: CALL 23241 0 3
12137: ADD
12138: ST_TO_ADDR
// for i in fort do
12139: LD_ADDR_VAR 0 4
12143: PUSH
12144: LD_EXP 43
12148: PUSH
12149: FOR_IN
12150: IFFALSE 12226
// begin if not UnitsInside ( i ) then
12152: LD_VAR 0 4
12156: PPUSH
12157: CALL_OW 313
12161: NOT
12162: IFFALSE 12182
// begin empty := empty ^ i ;
12164: LD_ADDR_VAR 0 3
12168: PUSH
12169: LD_VAR 0 3
12173: PUSH
12174: LD_VAR 0 4
12178: ADD
12179: ST_TO_ADDR
// end else
12180: GO 12224
// begin kdo := kdo diff UnitsInside ( i ) ;
12182: LD_ADDR_VAR 0 2
12186: PUSH
12187: LD_VAR 0 2
12191: PUSH
12192: LD_VAR 0 4
12196: PPUSH
12197: CALL_OW 313
12201: DIFF
12202: ST_TO_ADDR
// uz_in := uz_in ^ UnitsInside ( i ) ;
12203: LD_ADDR_VAR 0 6
12207: PUSH
12208: LD_VAR 0 6
12212: PUSH
12213: LD_VAR 0 4
12217: PPUSH
12218: CALL_OW 313
12222: ADD
12223: ST_TO_ADDR
// end ; end ;
12224: GO 12149
12226: POP
12227: POP
// if kdo < empty then
12228: LD_VAR 0 2
12232: PUSH
12233: LD_VAR 0 3
12237: LESS
12238: IFFALSE 12250
// kdo := kdo ;
12240: LD_ADDR_VAR 0 2
12244: PUSH
12245: LD_VAR 0 2
12249: ST_TO_ADDR
// if kdo < empty then
12250: LD_VAR 0 2
12254: PUSH
12255: LD_VAR 0 3
12259: LESS
12260: IFFALSE 12278
// a := ( kdo + 0 ) else
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_VAR 0 2
12271: PUSH
12272: LD_INT 0
12274: PLUS
12275: ST_TO_ADDR
12276: GO 12292
// a := ( empty + 0 ) ;
12278: LD_ADDR_VAR 0 5
12282: PUSH
12283: LD_VAR 0 3
12287: PUSH
12288: LD_INT 0
12290: PLUS
12291: ST_TO_ADDR
// for i := 1 to a do
12292: LD_ADDR_VAR 0 4
12296: PUSH
12297: DOUBLE
12298: LD_INT 1
12300: DEC
12301: ST_TO_ADDR
12302: LD_VAR 0 5
12306: PUSH
12307: FOR_TO
12308: IFFALSE 12422
// begin ComStop ( kdo [ i ] ) ;
12310: LD_VAR 0 2
12314: PUSH
12315: LD_VAR 0 4
12319: ARRAY
12320: PPUSH
12321: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12325: LD_VAR 0 2
12329: PUSH
12330: LD_VAR 0 4
12334: ARRAY
12335: PPUSH
12336: CALL_OW 310
12340: IFFALSE 12372
// begin AddComExitBuilding ( kdo [ i ] ) ;
12342: LD_VAR 0 2
12346: PUSH
12347: LD_VAR 0 4
12351: ARRAY
12352: PPUSH
12353: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12357: LD_VAR 0 2
12361: PUSH
12362: LD_VAR 0 4
12366: ARRAY
12367: PPUSH
12368: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12372: LD_VAR 0 2
12376: PUSH
12377: LD_VAR 0 4
12381: ARRAY
12382: PPUSH
12383: LD_VAR 0 3
12387: PUSH
12388: LD_VAR 0 4
12392: ARRAY
12393: PPUSH
12394: CALL_OW 180
// uz_in := uz_in ^ kdo [ i ] ;
12398: LD_ADDR_VAR 0 6
12402: PUSH
12403: LD_VAR 0 6
12407: PUSH
12408: LD_VAR 0 2
12412: PUSH
12413: LD_VAR 0 4
12417: ARRAY
12418: ADD
12419: ST_TO_ADDR
// end ;
12420: GO 12307
12422: POP
12423: POP
// empty := [ ] ;
12424: LD_ADDR_VAR 0 3
12428: PUSH
12429: EMPTY
12430: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_mechanical , class_soldier ) diff uz_in ;
12431: LD_ADDR_VAR 0 2
12435: PUSH
12436: LD_INT 0
12438: PPUSH
12439: LD_INT 3
12441: PPUSH
12442: LD_INT 1
12444: PPUSH
12445: CALL 23241 0 3
12449: PUSH
12450: LD_VAR 0 6
12454: DIFF
12455: ST_TO_ADDR
// for i in defence diff Mastodon do
12456: LD_ADDR_VAR 0 4
12460: PUSH
12461: LD_EXP 28
12465: PUSH
12466: LD_INT 1
12468: DIFF
12469: PUSH
12470: FOR_IN
12471: IFFALSE 12526
// begin if not UnitsInside ( i ) then
12473: LD_VAR 0 4
12477: PPUSH
12478: CALL_OW 313
12482: NOT
12483: IFFALSE 12503
// begin empty := empty ^ i ;
12485: LD_ADDR_VAR 0 3
12489: PUSH
12490: LD_VAR 0 3
12494: PUSH
12495: LD_VAR 0 4
12499: ADD
12500: ST_TO_ADDR
// end else
12501: GO 12524
// kdo := kdo diff UnitsInside ( i ) ;
12503: LD_ADDR_VAR 0 2
12507: PUSH
12508: LD_VAR 0 2
12512: PUSH
12513: LD_VAR 0 4
12517: PPUSH
12518: CALL_OW 313
12522: DIFF
12523: ST_TO_ADDR
// end ;
12524: GO 12470
12526: POP
12527: POP
// if kdo < empty then
12528: LD_VAR 0 2
12532: PUSH
12533: LD_VAR 0 3
12537: LESS
12538: IFFALSE 12550
// kdo := kdo ;
12540: LD_ADDR_VAR 0 2
12544: PUSH
12545: LD_VAR 0 2
12549: ST_TO_ADDR
// if kdo < empty then
12550: LD_VAR 0 2
12554: PUSH
12555: LD_VAR 0 3
12559: LESS
12560: IFFALSE 12578
// a := ( kdo + 0 ) else
12562: LD_ADDR_VAR 0 5
12566: PUSH
12567: LD_VAR 0 2
12571: PUSH
12572: LD_INT 0
12574: PLUS
12575: ST_TO_ADDR
12576: GO 12592
// a := ( empty + 0 ) ;
12578: LD_ADDR_VAR 0 5
12582: PUSH
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 0
12590: PLUS
12591: ST_TO_ADDR
// for i := 1 to a do
12592: LD_ADDR_VAR 0 4
12596: PUSH
12597: DOUBLE
12598: LD_INT 1
12600: DEC
12601: ST_TO_ADDR
12602: LD_VAR 0 5
12606: PUSH
12607: FOR_TO
12608: IFFALSE 12700
// begin ComStop ( kdo [ i ] ) ;
12610: LD_VAR 0 2
12614: PUSH
12615: LD_VAR 0 4
12619: ARRAY
12620: PPUSH
12621: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12625: LD_VAR 0 2
12629: PUSH
12630: LD_VAR 0 4
12634: ARRAY
12635: PPUSH
12636: CALL_OW 310
12640: IFFALSE 12672
// begin AddComExitBuilding ( kdo [ i ] ) ;
12642: LD_VAR 0 2
12646: PUSH
12647: LD_VAR 0 4
12651: ARRAY
12652: PPUSH
12653: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12657: LD_VAR 0 2
12661: PUSH
12662: LD_VAR 0 4
12666: ARRAY
12667: PPUSH
12668: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PPUSH
12683: LD_VAR 0 3
12687: PUSH
12688: LD_VAR 0 4
12692: ARRAY
12693: PPUSH
12694: CALL_OW 180
// end ;
12698: GO 12607
12700: POP
12701: POP
// enable ;
12702: ENABLE
// end ;
12703: LD_VAR 0 1
12707: RET
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var uns , a ;
12708: LD_INT 13
12710: PPUSH
12711: LD_INT 22
12713: PUSH
12714: LD_EXP 1
12718: PUSH
12719: EMPTY
12720: LIST
12721: LIST
12722: PPUSH
12723: CALL_OW 70
12727: IFFALSE 12745
12729: GO 12731
12731: DISABLE
12732: LD_INT 0
12734: PPUSH
12735: PPUSH
// begin under_attack := true ;
12736: LD_ADDR_EXP 69
12740: PUSH
12741: LD_INT 1
12743: ST_TO_ADDR
// enable ;
12744: ENABLE
// end ;
12745: PPOPN 2
12747: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do
12748: LD_INT 13
12750: PPUSH
12751: LD_INT 22
12753: PUSH
12754: LD_EXP 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PPUSH
12763: CALL_OW 70
12767: NOT
12768: IFFALSE 12782
12770: GO 12772
12772: DISABLE
// begin under_attack := false ;
12773: LD_ADDR_EXP 69
12777: PUSH
12778: LD_INT 0
12780: ST_TO_ADDR
// enable ;
12781: ENABLE
// end ;
12782: END
// every 0 0$10 trigger defence do
12783: LD_EXP 28
12787: IFFALSE 12825
12789: GO 12791
12791: DISABLE
// begin ComMoveXY ( defence [ 1 ] , 121 , 69 ) ;
12792: LD_EXP 28
12796: PUSH
12797: LD_INT 1
12799: ARRAY
12800: PPUSH
12801: LD_INT 121
12803: PPUSH
12804: LD_INT 69
12806: PPUSH
12807: CALL_OW 111
// AddComStand ( defence [ 1 ] ) ;
12811: LD_EXP 28
12815: PUSH
12816: LD_INT 1
12818: ARRAY
12819: PPUSH
12820: CALL_OW 225
// enable ;
12824: ENABLE
// end ;
12825: END
// every 0 0$5 + 0 0$2 marked 50 do
12826: GO 12828
12828: DISABLE
// begin full_forts ;
12829: CALL 12083 0 0
// enable ;
12833: ENABLE
// end ;
12834: END
// every 0 0$5.0 do var i ;
12835: GO 12837
12837: DISABLE
12838: LD_INT 0
12840: PPUSH
// begin if fact1 then
12841: LD_EXP 40
12845: IFFALSE 12904
// for i in mec do
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_EXP 22
12856: PUSH
12857: FOR_IN
12858: IFFALSE 12902
// begin if IsIdle ( i ) or not IsInArea ( i , near_base ) then
12860: LD_VAR 0 1
12864: PPUSH
12865: CALL_OW 316
12869: PUSH
12870: LD_VAR 0 1
12874: PPUSH
12875: LD_INT 13
12877: PPUSH
12878: CALL_OW 308
12882: NOT
12883: OR
12884: IFFALSE 12900
// ComEnterUnit ( i , fact1 ) ;
12886: LD_VAR 0 1
12890: PPUSH
12891: LD_EXP 40
12895: PPUSH
12896: CALL_OW 120
// end ;
12900: GO 12857
12902: POP
12903: POP
// enable ;
12904: ENABLE
// end ;
12905: PPOPN 1
12907: END
// every 0 0$5.0 do var i ;
12908: GO 12910
12910: DISABLE
12911: LD_INT 0
12913: PPUSH
// begin if dep1 then
12914: LD_EXP 41
12918: IFFALSE 13006
// if under_attack then
12920: LD_EXP 69
12924: IFFALSE 12997
// for i in eng do
12926: LD_ADDR_VAR 0 1
12930: PUSH
12931: LD_EXP 23
12935: PUSH
12936: FOR_IN
12937: IFFALSE 12993
// begin if IsIdle ( i ) or ( not IsInArea ( i , near_base ) and not IsInUnit ( i ) ) then
12939: LD_VAR 0 1
12943: PPUSH
12944: CALL_OW 316
12948: PUSH
12949: LD_VAR 0 1
12953: PPUSH
12954: LD_INT 13
12956: PPUSH
12957: CALL_OW 308
12961: NOT
12962: PUSH
12963: LD_VAR 0 1
12967: PPUSH
12968: CALL_OW 310
12972: NOT
12973: AND
12974: OR
12975: IFFALSE 12991
// ComEnterUnit ( i , dep1 ) ;
12977: LD_VAR 0 1
12981: PPUSH
12982: LD_EXP 41
12986: PPUSH
12987: CALL_OW 120
// end else
12991: GO 12936
12993: POP
12994: POP
12995: GO 13006
// ComExitBuilding ( dep1 ) ;
12997: LD_EXP 41
13001: PPUSH
13002: CALL_OW 122
// enable ;
13006: ENABLE
// end ;
13007: PPOPN 1
13009: END
// every 0 0$5.0 do var i ;
13010: GO 13012
13012: DISABLE
13013: LD_INT 0
13015: PPUSH
// begin if lab1 then
13016: LD_EXP 42
13020: IFFALSE 13064
// for i in sci do
13022: LD_ADDR_VAR 0 1
13026: PUSH
13027: LD_EXP 21
13031: PUSH
13032: FOR_IN
13033: IFFALSE 13062
// begin if IsIdle ( i ) then
13035: LD_VAR 0 1
13039: PPUSH
13040: CALL_OW 316
13044: IFFALSE 13060
// ComEnterUnit ( i , lab1 ) ;
13046: LD_VAR 0 1
13050: PPUSH
13051: LD_EXP 42
13055: PPUSH
13056: CALL_OW 120
// end ;
13060: GO 13032
13062: POP
13063: POP
// enable ;
13064: ENABLE
// end ;
13065: PPOPN 1
13067: END
// every 0 0$1 do var a ;
13068: GO 13070
13070: DISABLE
13071: LD_INT 0
13073: PPUSH
// begin enable ;
13074: ENABLE
// end ; end_of_file
13075: PPOPN 1
13077: END
// every 0 0$2 do var temp1 , people , cars ;
13078: GO 13080
13080: DISABLE
13081: LD_INT 0
13083: PPUSH
13084: PPUSH
13085: PPUSH
// begin vodni_utok := 6000 ;
13086: LD_ADDR_EXP 35
13090: PUSH
13091: LD_INT 6000
13093: ST_TO_ADDR
// normal1_utok := 6001 ;
13094: LD_ADDR_EXP 36
13098: PUSH
13099: LD_INT 6001
13101: ST_TO_ADDR
// normal2_utok := 6002 ;
13102: LD_ADDR_EXP 37
13106: PUSH
13107: LD_INT 6002
13109: ST_TO_ADDR
// normal3_utok := 6003 ;
13110: LD_ADDR_EXP 38
13114: PUSH
13115: LD_INT 6003
13117: ST_TO_ADDR
// normal4_utok := 6004 ;
13118: LD_ADDR_EXP 39
13122: PUSH
13123: LD_INT 6004
13125: ST_TO_ADDR
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
13126: LD_ADDR_EXP 7
13130: PUSH
13131: LD_INT 23
13133: PUSH
13134: LD_INT 0
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: PUSH
13141: EMPTY
13142: LIST
13143: PPUSH
13144: CALL_OW 69
13148: ST_TO_ADDR
// to_defence := false ;
13149: LD_ADDR_EXP 30
13153: PUSH
13154: LD_INT 0
13156: ST_TO_ADDR
// to_remote := false ;
13157: LD_ADDR_EXP 34
13161: PUSH
13162: LD_INT 0
13164: ST_TO_ADDR
// to_attack := false ;
13165: LD_ADDR_EXP 31
13169: PUSH
13170: LD_INT 0
13172: ST_TO_ADDR
// to_cargo := false ;
13173: LD_ADDR_EXP 33
13177: PUSH
13178: LD_INT 0
13180: ST_TO_ADDR
// to_scout := false ;
13181: LD_ADDR_EXP 32
13185: PUSH
13186: LD_INT 0
13188: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ [ f_side , arabians ] ] ) ;
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_INT 22
13196: PUSH
13197: LD_EXP 3
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: ST_TO_ADDR
// ComRemember ( temp1 ) ;
13214: LD_VAR 0 1
13218: PPUSH
13219: CALL_OW 143
// people := UnitFilter ( temp1 , [ [ f_type , unit_human ] ] ) ;
13223: LD_ADDR_VAR 0 2
13227: PUSH
13228: LD_VAR 0 1
13232: PPUSH
13233: LD_INT 21
13235: PUSH
13236: LD_INT 1
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PUSH
13243: EMPTY
13244: LIST
13245: PPUSH
13246: CALL_OW 72
13250: ST_TO_ADDR
// sol := UnitFilter ( people , [ [ f_class , class_soldier ] ] ) ;
13251: LD_ADDR_EXP 19
13255: PUSH
13256: LD_VAR 0 2
13260: PPUSH
13261: LD_INT 25
13263: PUSH
13264: LD_INT 1
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PUSH
13271: EMPTY
13272: LIST
13273: PPUSH
13274: CALL_OW 72
13278: ST_TO_ADDR
// sci := UnitFilter ( people , [ [ f_class , class_scientistic ] ] ) ;
13279: LD_ADDR_EXP 21
13283: PUSH
13284: LD_VAR 0 2
13288: PPUSH
13289: LD_INT 25
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PUSH
13299: EMPTY
13300: LIST
13301: PPUSH
13302: CALL_OW 72
13306: ST_TO_ADDR
// mor := UnitFilter ( people , [ [ f_class , class_mortar ] ] ) ;
13307: LD_ADDR_EXP 20
13311: PUSH
13312: LD_VAR 0 2
13316: PPUSH
13317: LD_INT 25
13319: PUSH
13320: LD_INT 8
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: PPUSH
13330: CALL_OW 72
13334: ST_TO_ADDR
// mec := UnitFilter ( people , [ [ f_class , class_mechanic ] ] ) ;
13335: LD_ADDR_EXP 22
13339: PUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: LD_INT 25
13347: PUSH
13348: LD_INT 3
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PUSH
13355: EMPTY
13356: LIST
13357: PPUSH
13358: CALL_OW 72
13362: ST_TO_ADDR
// eng := UnitFilter ( people , [ [ f_class , class_engineer ] ] ) ;
13363: LD_ADDR_EXP 23
13367: PUSH
13368: LD_VAR 0 2
13372: PPUSH
13373: LD_INT 25
13375: PUSH
13376: LD_INT 2
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: EMPTY
13384: LIST
13385: PPUSH
13386: CALL_OW 72
13390: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ [ f_type , unit_vehicle ] ] ) ;
13391: LD_ADDR_VAR 0 3
13395: PUSH
13396: LD_VAR 0 1
13400: PPUSH
13401: LD_INT 21
13403: PUSH
13404: LD_INT 2
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PUSH
13411: EMPTY
13412: LIST
13413: PPUSH
13414: CALL_OW 72
13418: ST_TO_ADDR
// cargo := [ ] ;
13419: LD_ADDR_EXP 25
13423: PUSH
13424: EMPTY
13425: ST_TO_ADDR
// scout := [ ] ;
13426: LD_ADDR_EXP 26
13430: PUSH
13431: EMPTY
13432: ST_TO_ADDR
// defence := [ Mastodon ] ;
13433: LD_ADDR_EXP 28
13437: PUSH
13438: LD_INT 1
13440: PUSH
13441: EMPTY
13442: LIST
13443: ST_TO_ADDR
// attack := [ ] ;
13444: LD_ADDR_EXP 27
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// fort := UnitFilter ( temp1 , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
13451: LD_ADDR_EXP 43
13455: PUSH
13456: LD_VAR 0 1
13460: PPUSH
13461: LD_INT 2
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 32
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 30
13476: PUSH
13477: LD_INT 31
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: LIST
13488: PUSH
13489: EMPTY
13490: LIST
13491: PPUSH
13492: CALL_OW 72
13496: ST_TO_ADDR
// dep1 := UnitFilter ( temp1 , [ [ f_btype , b_depot ] ] ) [ 1 ] + 0 ;
13497: LD_ADDR_EXP 41
13501: PUSH
13502: LD_VAR 0 1
13506: PPUSH
13507: LD_INT 30
13509: PUSH
13510: LD_INT 0
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PUSH
13517: EMPTY
13518: LIST
13519: PPUSH
13520: CALL_OW 72
13524: PUSH
13525: LD_INT 1
13527: ARRAY
13528: PUSH
13529: LD_INT 0
13531: PLUS
13532: ST_TO_ADDR
// end ;
13533: PPOPN 3
13535: END
// var zasek_cargo ; every 0 0$50 trigger cargo do var j , pojedou , new ;
13536: LD_EXP 25
13540: IFFALSE 13913
13542: GO 13544
13544: DISABLE
13545: LD_INT 0
13547: PPUSH
13548: PPUSH
13549: PPUSH
// begin uc_side := arabians ;
13550: LD_ADDR_OWVAR 20
13554: PUSH
13555: LD_EXP 3
13559: ST_TO_ADDR
// uc_nation := nation_arabian ;
13560: LD_ADDR_OWVAR 21
13564: PUSH
13565: LD_INT 2
13567: ST_TO_ADDR
// PrepareEngineer ( 0 , 2 ) ;
13568: LD_INT 0
13570: PPUSH
13571: LD_INT 2
13573: PPUSH
13574: CALL_OW 382
// SetFuel ( cargo , 100 ) ;
13578: LD_EXP 25
13582: PPUSH
13583: LD_INT 100
13585: PPUSH
13586: CALL_OW 240
// if not HasTask ( Cargo [ 1 ] ) and GetLives ( Cargo [ 1 ] ) >= 900 and crates >= 2 then
13590: LD_EXP 25
13594: PUSH
13595: LD_INT 1
13597: ARRAY
13598: PPUSH
13599: CALL_OW 314
13603: NOT
13604: PUSH
13605: LD_EXP 25
13609: PUSH
13610: LD_INT 1
13612: ARRAY
13613: PPUSH
13614: CALL_OW 256
13618: PUSH
13619: LD_INT 900
13621: GREATEREQUAL
13622: AND
13623: PUSH
13624: LD_EXP 85
13628: PUSH
13629: LD_INT 2
13631: GREATEREQUAL
13632: AND
13633: IFFALSE 13912
// begin new := [ ] ;
13635: LD_ADDR_VAR 0 3
13639: PUSH
13640: EMPTY
13641: ST_TO_ADDR
// pojedou := find_drivers ( cargo [ 1 ] , eng ^ sol ^ sci ^ mec , false ) ;
13642: LD_ADDR_VAR 0 2
13646: PUSH
13647: LD_EXP 25
13651: PUSH
13652: LD_INT 1
13654: ARRAY
13655: PPUSH
13656: LD_EXP 23
13660: PUSH
13661: LD_EXP 19
13665: ADD
13666: PUSH
13667: LD_EXP 21
13671: ADD
13672: PUSH
13673: LD_EXP 22
13677: ADD
13678: PPUSH
13679: LD_INT 0
13681: PPUSH
13682: CALL 23939 0 3
13686: ST_TO_ADDR
// wait_for_drivers ( pojedou , 0 0$25 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 875
13694: PPUSH
13695: CALL 24271 0 2
// if IsDrivenBy ( cargo [ 1 ] ) then
13699: LD_EXP 25
13703: PUSH
13704: LD_INT 1
13706: ARRAY
13707: PPUSH
13708: CALL_OW 311
13712: IFFALSE 13724
// zasek_cargo := 1 else
13714: LD_ADDR_LOC 27
13718: PUSH
13719: LD_INT 1
13721: ST_TO_ADDR
13722: GO 13738
// zasek_cargo := zasek_cargo + 1 ;
13724: LD_ADDR_LOC 27
13728: PUSH
13729: LD_LOC 27
13733: PUSH
13734: LD_INT 1
13736: PLUS
13737: ST_TO_ADDR
// if zasek_cargo > 5 then
13738: LD_LOC 27
13742: PUSH
13743: LD_INT 5
13745: GREATER
13746: IFFALSE 13766
// PlaceHumanInUnit ( CreateHuman , cargo [ 1 ] ) ;
13748: CALL_OW 44
13752: PPUSH
13753: LD_EXP 25
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PPUSH
13762: CALL_OW 52
// for j := 1 to 2 do
13766: LD_ADDR_VAR 0 1
13770: PUSH
13771: DOUBLE
13772: LD_INT 1
13774: DEC
13775: ST_TO_ADDR
13776: LD_INT 2
13778: PUSH
13779: FOR_TO
13780: IFFALSE 13823
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
13782: LD_VAR 0 2
13786: PPUSH
13787: LD_EXP 85
13791: PUSH
13792: LD_VAR 0 1
13796: ARRAY
13797: PUSH
13798: LD_INT 1
13800: ARRAY
13801: PPUSH
13802: LD_EXP 85
13806: PUSH
13807: LD_VAR 0 1
13811: ARRAY
13812: PUSH
13813: LD_INT 2
13815: ARRAY
13816: PPUSH
13817: CALL_OW 177
// end ;
13821: GO 13779
13823: POP
13824: POP
// if crates >= 3 then
13825: LD_EXP 85
13829: PUSH
13830: LD_INT 3
13832: GREATEREQUAL
13833: IFFALSE 13882
// for j := 3 to crates do
13835: LD_ADDR_VAR 0 1
13839: PUSH
13840: DOUBLE
13841: LD_INT 3
13843: DEC
13844: ST_TO_ADDR
13845: LD_EXP 85
13849: PUSH
13850: FOR_TO
13851: IFFALSE 13880
// begin new := new ^ [ crates [ j ] ] ;
13853: LD_ADDR_VAR 0 3
13857: PUSH
13858: LD_VAR 0 3
13862: PUSH
13863: LD_EXP 85
13867: PUSH
13868: LD_VAR 0 1
13872: ARRAY
13873: PUSH
13874: EMPTY
13875: LIST
13876: ADD
13877: ST_TO_ADDR
// end ;
13878: GO 13850
13880: POP
13881: POP
// crates := new ;
13882: LD_ADDR_EXP 85
13886: PUSH
13887: LD_VAR 0 3
13891: ST_TO_ADDR
// if dep1 then
13892: LD_EXP 41
13896: IFFALSE 13912
// AddComMoveUnit ( pojedou , dep1 ) ;
13898: LD_VAR 0 2
13902: PPUSH
13903: LD_EXP 41
13907: PPUSH
13908: CALL_OW 172
// end ; enable ;
13912: ENABLE
// end ;
13913: PPOPN 3
13915: END
// every 0 0$30 do var a ;
13916: GO 13918
13918: DISABLE
13919: LD_INT 0
13921: PPUSH
// begin a := GetResourceType ( Getbase ( dep1 ) , mat_cans ) ;
13922: LD_ADDR_VAR 0 1
13926: PUSH
13927: LD_EXP 41
13931: PPUSH
13932: CALL_OW 274
13936: PPUSH
13937: LD_INT 1
13939: PPUSH
13940: CALL_OW 275
13944: ST_TO_ADDR
// if a < 100 then
13945: LD_VAR 0 1
13949: PUSH
13950: LD_INT 100
13952: LESS
13953: IFFALSE 13981
// SetResourceType ( Getbase ( dep1 ) , mat_cans , a + 100 ) ;
13955: LD_EXP 41
13959: PPUSH
13960: CALL_OW 274
13964: PPUSH
13965: LD_INT 1
13967: PPUSH
13968: LD_VAR 0 1
13972: PUSH
13973: LD_INT 100
13975: PLUS
13976: PPUSH
13977: CALL_OW 277
// a := GetResourceType ( Getbase ( dep1 ) , mat_oil ) ;
13981: LD_ADDR_VAR 0 1
13985: PUSH
13986: LD_EXP 41
13990: PPUSH
13991: CALL_OW 274
13995: PPUSH
13996: LD_INT 2
13998: PPUSH
13999: CALL_OW 275
14003: ST_TO_ADDR
// if a < 100 then
14004: LD_VAR 0 1
14008: PUSH
14009: LD_INT 100
14011: LESS
14012: IFFALSE 14040
// SetResourceType ( Getbase ( dep1 ) , mat_oil , a + 100 ) ;
14014: LD_EXP 41
14018: PPUSH
14019: CALL_OW 274
14023: PPUSH
14024: LD_INT 2
14026: PPUSH
14027: LD_VAR 0 1
14031: PUSH
14032: LD_INT 100
14034: PLUS
14035: PPUSH
14036: CALL_OW 277
// enable ;
14040: ENABLE
// end ;
14041: PPOPN 1
14043: END
// every 0 0$15 trigger IsOk ( fact1 ) and IsIdle ( fact1 ) and ( ( defence + attack ) < ( 5 + difficulty * 2 ) ) do var a , ec , cm , ac , podvozky , ovladani , def_pod , att_pod , tmec ;
14044: LD_EXP 40
14048: PPUSH
14049: CALL_OW 302
14053: PUSH
14054: LD_EXP 40
14058: PPUSH
14059: CALL_OW 316
14063: AND
14064: PUSH
14065: LD_EXP 28
14069: PUSH
14070: LD_EXP 27
14074: PLUS
14075: PUSH
14076: LD_INT 5
14078: PUSH
14079: LD_OWVAR 67
14083: PUSH
14084: LD_INT 2
14086: MUL
14087: PLUS
14088: LESS
14089: AND
14090: IFFALSE 15401
14092: GO 14094
14094: DISABLE
14095: LD_INT 0
14097: PPUSH
14098: PPUSH
14099: PPUSH
14100: PPUSH
14101: PPUSH
14102: PPUSH
14103: PPUSH
14104: PPUSH
14105: PPUSH
// begin ec := engine_combustion ;
14106: LD_ADDR_VAR 0 2
14110: PUSH
14111: LD_INT 1
14113: ST_TO_ADDR
// cm := control_manual ;
14114: LD_ADDR_VAR 0 3
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// podvozky := AvailableChassisList ( fact1 ) ;
14122: LD_ADDR_VAR 0 5
14126: PUSH
14127: LD_EXP 40
14131: PPUSH
14132: CALL_OW 475
14136: ST_TO_ADDR
// ovladani := AvailableControlList ( fact1 ) ;
14137: LD_ADDR_VAR 0 6
14141: PUSH
14142: LD_EXP 40
14146: PPUSH
14147: CALL_OW 477
14151: ST_TO_ADDR
// if control_remote in ovladani then
14152: LD_INT 2
14154: PUSH
14155: LD_VAR 0 6
14159: IN
14160: IFFALSE 14172
// ac := control_remote else
14162: LD_ADDR_VAR 0 4
14166: PUSH
14167: LD_INT 2
14169: ST_TO_ADDR
14170: GO 14182
// ac := cm ;
14172: LD_ADDR_VAR 0 4
14176: PUSH
14177: LD_VAR 0 3
14181: ST_TO_ADDR
// att_pod := ar_half_tracked ;
14182: LD_ADDR_VAR 0 8
14186: PUSH
14187: LD_INT 14
14189: ST_TO_ADDR
// case true of ar_half_tracked in podvozky :
14190: LD_INT 1
14192: PUSH
14193: LD_INT 14
14195: PUSH
14196: LD_VAR 0 5
14200: IN
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14218
14207: POP
// def_pod := ar_half_tracked ; ar_medium_trike in podvozky :
14208: LD_ADDR_VAR 0 7
14212: PUSH
14213: LD_INT 14
14215: ST_TO_ADDR
14216: GO 14244
14218: LD_INT 13
14220: PUSH
14221: LD_VAR 0 5
14225: IN
14226: DOUBLE
14227: EQUAL
14228: IFTRUE 14232
14230: GO 14243
14232: POP
// def_pod := ar_medium_trike ; end ;
14233: LD_ADDR_VAR 0 7
14237: PUSH
14238: LD_INT 13
14240: ST_TO_ADDR
14241: GO 14244
14243: POP
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14244: LD_ADDR_VAR 0 9
14248: PUSH
14249: LD_EXP 22
14253: PPUSH
14254: LD_INT 56
14256: PUSH
14257: EMPTY
14258: LIST
14259: PUSH
14260: EMPTY
14261: LIST
14262: PPUSH
14263: CALL_OW 72
14267: ST_TO_ADDR
// while tmec do
14268: LD_VAR 0 9
14272: IFFALSE 14332
// begin ComExitVehicle ( tmec ) ;
14274: LD_VAR 0 9
14278: PPUSH
14279: CALL_OW 121
// AddComEnterUnit ( tmec , fact1 ) ;
14283: LD_VAR 0 9
14287: PPUSH
14288: LD_EXP 40
14292: PPUSH
14293: CALL_OW 180
// DU_wait ( tmec ) ;
14297: LD_VAR 0 9
14301: PPUSH
14302: CALL 21968 0 1
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14306: LD_ADDR_VAR 0 9
14310: PUSH
14311: LD_EXP 22
14315: PPUSH
14316: LD_INT 56
14318: PUSH
14319: EMPTY
14320: LIST
14321: PUSH
14322: EMPTY
14323: LIST
14324: PPUSH
14325: CALL_OW 72
14329: ST_TO_ADDR
// end ;
14330: GO 14268
// case true of cargo < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_cargo_bay ) :
14332: LD_INT 1
14334: PUSH
14335: LD_EXP 25
14339: PUSH
14340: LD_INT 1
14342: LESS
14343: PUSH
14344: LD_EXP 40
14348: PPUSH
14349: LD_INT 13
14351: PPUSH
14352: LD_VAR 0 2
14356: PPUSH
14357: LD_VAR 0 3
14361: PPUSH
14362: LD_INT 32
14364: PPUSH
14365: CALL_OW 448
14369: AND
14370: DOUBLE
14371: EQUAL
14372: IFTRUE 14376
14374: GO 14414
14376: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_cargo_bay ) ;
14377: LD_EXP 40
14381: PPUSH
14382: LD_VAR 0 7
14386: PPUSH
14387: LD_VAR 0 2
14391: PPUSH
14392: LD_VAR 0 3
14396: PPUSH
14397: LD_INT 32
14399: PPUSH
14400: CALL_OW 125
// to_cargo := true ;
14404: LD_ADDR_EXP 33
14408: PUSH
14409: LD_INT 1
14411: ST_TO_ADDR
// end ; defence >= 1 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gun ) :
14412: GO 15400
14414: LD_EXP 28
14418: PUSH
14419: LD_INT 1
14421: GREATEREQUAL
14422: PUSH
14423: LD_EXP 28
14427: PUSH
14428: LD_INT 3
14430: LESS
14431: AND
14432: PUSH
14433: LD_EXP 40
14437: PPUSH
14438: LD_VAR 0 7
14442: PPUSH
14443: LD_VAR 0 2
14447: PPUSH
14448: LD_VAR 0 3
14452: PPUSH
14453: LD_INT 27
14455: PPUSH
14456: CALL_OW 448
14460: AND
14461: DOUBLE
14462: EQUAL
14463: IFTRUE 14467
14465: GO 14505
14467: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gun ) ;
14468: LD_EXP 40
14472: PPUSH
14473: LD_VAR 0 7
14477: PPUSH
14478: LD_VAR 0 2
14482: PPUSH
14483: LD_VAR 0 3
14487: PPUSH
14488: LD_INT 27
14490: PPUSH
14491: CALL_OW 125
// to_defence := true ;
14495: LD_ADDR_EXP 30
14499: PUSH
14500: LD_INT 1
14502: ST_TO_ADDR
// end ; defence >= 2 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gatling_gun ) :
14503: GO 15400
14505: LD_EXP 28
14509: PUSH
14510: LD_INT 2
14512: GREATEREQUAL
14513: PUSH
14514: LD_EXP 28
14518: PUSH
14519: LD_INT 3
14521: LESS
14522: AND
14523: PUSH
14524: LD_EXP 40
14528: PPUSH
14529: LD_VAR 0 7
14533: PPUSH
14534: LD_VAR 0 2
14538: PPUSH
14539: LD_VAR 0 3
14543: PPUSH
14544: LD_INT 25
14546: PPUSH
14547: CALL_OW 448
14551: AND
14552: DOUBLE
14553: EQUAL
14554: IFTRUE 14558
14556: GO 14596
14558: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gatling_gun ) ;
14559: LD_EXP 40
14563: PPUSH
14564: LD_VAR 0 7
14568: PPUSH
14569: LD_VAR 0 2
14573: PPUSH
14574: LD_VAR 0 3
14578: PPUSH
14579: LD_INT 25
14581: PPUSH
14582: CALL_OW 125
// to_defence := true ;
14586: LD_ADDR_EXP 30
14590: PUSH
14591: LD_INT 1
14593: ST_TO_ADDR
// end ; defence < 2 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_flame_thrower ) :
14594: GO 15400
14596: LD_EXP 28
14600: PUSH
14601: LD_INT 2
14603: LESS
14604: PUSH
14605: LD_EXP 40
14609: PPUSH
14610: LD_VAR 0 7
14614: PPUSH
14615: LD_VAR 0 2
14619: PPUSH
14620: LD_VAR 0 3
14624: PPUSH
14625: LD_INT 26
14627: PPUSH
14628: CALL_OW 448
14632: AND
14633: DOUBLE
14634: EQUAL
14635: IFTRUE 14639
14637: GO 14677
14639: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_flame_thrower ) ;
14640: LD_EXP 40
14644: PPUSH
14645: LD_VAR 0 7
14649: PPUSH
14650: LD_VAR 0 2
14654: PPUSH
14655: LD_VAR 0 3
14659: PPUSH
14660: LD_INT 26
14662: PPUSH
14663: CALL_OW 125
// to_defence := true ;
14667: LD_ADDR_EXP 30
14671: PUSH
14672: LD_INT 1
14674: ST_TO_ADDR
// end ; remote < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) :
14675: GO 15400
14677: LD_EXP 29
14681: PUSH
14682: LD_INT 1
14684: LESS
14685: PUSH
14686: LD_EXP 40
14690: PPUSH
14691: LD_INT 13
14693: PPUSH
14694: LD_VAR 0 2
14698: PPUSH
14699: LD_VAR 0 3
14703: PPUSH
14704: LD_INT 31
14706: PPUSH
14707: CALL_OW 448
14711: AND
14712: DOUBLE
14713: EQUAL
14714: IFTRUE 14718
14716: GO 14754
14718: POP
// begin ComConstruct ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) ;
14719: LD_EXP 40
14723: PPUSH
14724: LD_INT 13
14726: PPUSH
14727: LD_VAR 0 2
14731: PPUSH
14732: LD_VAR 0 3
14736: PPUSH
14737: LD_INT 31
14739: PPUSH
14740: CALL_OW 125
// to_remote := true ;
14744: LD_ADDR_EXP 34
14748: PUSH
14749: LD_INT 1
14751: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
14752: GO 15400
14754: LD_OWVAR 1
14758: PUSH
14759: LD_INT 42000
14761: LESS
14762: PUSH
14763: LD_EXP 27
14767: PUSH
14768: LD_INT 3
14770: LESS
14771: AND
14772: PUSH
14773: LD_EXP 40
14777: PPUSH
14778: LD_INT 11
14780: PPUSH
14781: LD_VAR 0 2
14785: PPUSH
14786: LD_VAR 0 4
14790: PPUSH
14791: LD_INT 23
14793: PPUSH
14794: CALL_OW 448
14798: AND
14799: DOUBLE
14800: EQUAL
14801: IFTRUE 14805
14803: GO 14841
14805: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
14806: LD_EXP 40
14810: PPUSH
14811: LD_INT 11
14813: PPUSH
14814: LD_VAR 0 2
14818: PPUSH
14819: LD_VAR 0 4
14823: PPUSH
14824: LD_INT 23
14826: PPUSH
14827: CALL_OW 125
// to_attack := true ;
14831: LD_ADDR_EXP 31
14835: PUSH
14836: LD_INT 1
14838: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
14839: GO 15400
14841: LD_OWVAR 1
14845: PUSH
14846: LD_INT 42000
14848: LESS
14849: PUSH
14850: LD_EXP 27
14854: PUSH
14855: LD_INT 3
14857: LESS
14858: AND
14859: PUSH
14860: LD_EXP 40
14864: PPUSH
14865: LD_VAR 0 8
14869: PPUSH
14870: LD_VAR 0 2
14874: PPUSH
14875: LD_VAR 0 4
14879: PPUSH
14880: LD_INT 25
14882: PPUSH
14883: CALL_OW 448
14887: AND
14888: DOUBLE
14889: EQUAL
14890: IFTRUE 14894
14892: GO 14932
14894: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
14895: LD_EXP 40
14899: PPUSH
14900: LD_VAR 0 8
14904: PPUSH
14905: LD_VAR 0 2
14909: PPUSH
14910: LD_VAR 0 4
14914: PPUSH
14915: LD_INT 25
14917: PPUSH
14918: CALL_OW 125
// to_attack := true ;
14922: LD_ADDR_EXP 31
14926: PUSH
14927: LD_INT 1
14929: ST_TO_ADDR
// end ; tick < 10 10$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) :
14930: GO 15400
14932: LD_OWVAR 1
14936: PUSH
14937: LD_INT 21000
14939: LESS
14940: PUSH
14941: LD_EXP 27
14945: PUSH
14946: LD_INT 3
14948: LESS
14949: AND
14950: PUSH
14951: LD_EXP 40
14955: PPUSH
14956: LD_INT 11
14958: PPUSH
14959: LD_VAR 0 2
14963: PPUSH
14964: LD_VAR 0 4
14968: PPUSH
14969: LD_INT 24
14971: PPUSH
14972: CALL_OW 448
14976: AND
14977: DOUBLE
14978: EQUAL
14979: IFTRUE 14983
14981: GO 15019
14983: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) ;
14984: LD_EXP 40
14988: PPUSH
14989: LD_INT 11
14991: PPUSH
14992: LD_VAR 0 2
14996: PPUSH
14997: LD_VAR 0 4
15001: PPUSH
15002: LD_INT 24
15004: PPUSH
15005: CALL_OW 125
// to_attack := true ;
15009: LD_ADDR_EXP 31
15013: PUSH
15014: LD_INT 1
15016: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15017: GO 15400
15019: LD_OWVAR 1
15023: PUSH
15024: LD_INT 42000
15026: GREATER
15027: PUSH
15028: LD_OWVAR 1
15032: PUSH
15033: LD_INT 84000
15035: LESS
15036: AND
15037: PUSH
15038: LD_EXP 27
15042: PUSH
15043: LD_INT 2
15045: LESS
15046: AND
15047: PUSH
15048: LD_EXP 40
15052: PPUSH
15053: LD_VAR 0 8
15057: PPUSH
15058: LD_VAR 0 2
15062: PPUSH
15063: LD_VAR 0 4
15067: PPUSH
15068: LD_INT 27
15070: PPUSH
15071: CALL_OW 448
15075: AND
15076: DOUBLE
15077: EQUAL
15078: IFTRUE 15082
15080: GO 15120
15082: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15083: LD_EXP 40
15087: PPUSH
15088: LD_VAR 0 8
15092: PPUSH
15093: LD_VAR 0 2
15097: PPUSH
15098: LD_VAR 0 4
15102: PPUSH
15103: LD_INT 27
15105: PPUSH
15106: CALL_OW 125
// to_attack := true ;
15110: LD_ADDR_EXP 31
15114: PUSH
15115: LD_INT 1
15117: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
15118: GO 15400
15120: LD_OWVAR 1
15124: PUSH
15125: LD_INT 42000
15127: GREATER
15128: PUSH
15129: LD_OWVAR 1
15133: PUSH
15134: LD_INT 84000
15136: LESS
15137: AND
15138: PUSH
15139: LD_EXP 27
15143: PUSH
15144: LD_INT 3
15146: LESS
15147: AND
15148: PUSH
15149: LD_EXP 40
15153: PPUSH
15154: LD_VAR 0 8
15158: PPUSH
15159: LD_VAR 0 2
15163: PPUSH
15164: LD_VAR 0 4
15168: PPUSH
15169: LD_INT 25
15171: PPUSH
15172: CALL_OW 448
15176: AND
15177: DOUBLE
15178: EQUAL
15179: IFTRUE 15183
15181: GO 15221
15183: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
15184: LD_EXP 40
15188: PPUSH
15189: LD_VAR 0 8
15193: PPUSH
15194: LD_VAR 0 2
15198: PPUSH
15199: LD_VAR 0 4
15203: PPUSH
15204: LD_INT 25
15206: PPUSH
15207: CALL_OW 125
// to_attack := true ;
15211: LD_ADDR_EXP 31
15215: PUSH
15216: LD_INT 1
15218: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
15219: GO 15400
15221: LD_OWVAR 1
15225: PUSH
15226: LD_INT 84000
15228: GREATER
15229: PUSH
15230: LD_EXP 27
15234: PUSH
15235: LD_INT 2
15237: LESS
15238: AND
15239: PUSH
15240: LD_EXP 40
15244: PPUSH
15245: LD_INT 11
15247: PPUSH
15248: LD_VAR 0 2
15252: PPUSH
15253: LD_VAR 0 4
15257: PPUSH
15258: LD_INT 23
15260: PPUSH
15261: CALL_OW 448
15265: AND
15266: DOUBLE
15267: EQUAL
15268: IFTRUE 15272
15270: GO 15308
15272: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
15273: LD_EXP 40
15277: PPUSH
15278: LD_INT 11
15280: PPUSH
15281: LD_VAR 0 2
15285: PPUSH
15286: LD_VAR 0 4
15290: PPUSH
15291: LD_INT 23
15293: PPUSH
15294: CALL_OW 125
// to_attack := true ;
15298: LD_ADDR_EXP 31
15302: PUSH
15303: LD_INT 1
15305: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 4 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15306: GO 15400
15308: LD_OWVAR 1
15312: PUSH
15313: LD_INT 84000
15315: GREATER
15316: PUSH
15317: LD_EXP 27
15321: PUSH
15322: LD_INT 4
15324: LESS
15325: AND
15326: PUSH
15327: LD_EXP 40
15331: PPUSH
15332: LD_VAR 0 8
15336: PPUSH
15337: LD_VAR 0 2
15341: PPUSH
15342: LD_VAR 0 4
15346: PPUSH
15347: LD_INT 27
15349: PPUSH
15350: CALL_OW 448
15354: AND
15355: DOUBLE
15356: EQUAL
15357: IFTRUE 15361
15359: GO 15399
15361: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15362: LD_EXP 40
15366: PPUSH
15367: LD_VAR 0 8
15371: PPUSH
15372: LD_VAR 0 2
15376: PPUSH
15377: LD_VAR 0 4
15381: PPUSH
15382: LD_INT 27
15384: PPUSH
15385: CALL_OW 125
// to_attack := true ;
15389: LD_ADDR_EXP 31
15393: PUSH
15394: LD_INT 1
15396: ST_TO_ADDR
// end ; end ;
15397: GO 15400
15399: POP
// enable ;
15400: ENABLE
// end ;
15401: PPOPN 9
15403: END
// export hover , zbytek ; every 0 0$10 trigger ( ( attack diff brk_cars ) >= 2 ) do var pouzit ;
15404: LD_EXP 27
15408: PUSH
15409: LD_EXP 74
15413: DIFF
15414: PUSH
15415: LD_INT 2
15417: GREATEREQUAL
15418: IFFALSE 15667
15420: GO 15422
15422: DISABLE
15423: LD_INT 0
15425: PPUSH
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
15426: LD_EXP 1
15430: PPUSH
15431: LD_EXP 3
15435: PPUSH
15436: LD_INT 2
15438: PPUSH
15439: LD_INT 1
15441: PPUSH
15442: CALL_OW 80
// first_attack := true ;
15446: LD_ADDR_EXP 18
15450: PUSH
15451: LD_INT 1
15453: ST_TO_ADDR
// pouzit := UnitFilter ( attack diff brk_cars , [ f_not , [ f_hastask ] ] ) ;
15454: LD_ADDR_VAR 0 1
15458: PUSH
15459: LD_EXP 27
15463: PUSH
15464: LD_EXP 74
15468: DIFF
15469: PPUSH
15470: LD_INT 3
15472: PUSH
15473: LD_INT 60
15475: PUSH
15476: EMPTY
15477: LIST
15478: PUSH
15479: EMPTY
15480: LIST
15481: LIST
15482: PPUSH
15483: CALL_OW 72
15487: ST_TO_ADDR
// hover := UnitFilter ( pouzit , [ [ f_chassis , ar_hovercraft ] ] ) ;
15488: LD_ADDR_EXP 70
15492: PUSH
15493: LD_VAR 0 1
15497: PPUSH
15498: LD_INT 31
15500: PUSH
15501: LD_INT 11
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: PPUSH
15511: CALL_OW 72
15515: ST_TO_ADDR
// zbytek := pouzit diff hover ;
15516: LD_ADDR_EXP 71
15520: PUSH
15521: LD_VAR 0 1
15525: PUSH
15526: LD_EXP 70
15530: DIFF
15531: ST_TO_ADDR
// if wait_while then
15532: LD_EXP 12
15536: IFFALSE 15553
// begin wait ( 3 3$0 ) ;
15538: LD_INT 6300
15540: PPUSH
15541: CALL_OW 67
// wait_while := false ;
15545: LD_ADDR_EXP 12
15549: PUSH
15550: LD_INT 0
15552: ST_TO_ADDR
// end ; if hover then
15553: LD_EXP 70
15557: IFFALSE 15568
// RaiseSailEvent ( vodni_utok ) ;
15559: LD_EXP 35
15563: PPUSH
15564: CALL_OW 427
// if zbytek then
15568: LD_EXP 71
15572: IFFALSE 15666
// case Rand ( 1 , 2 ) of 1 :
15574: LD_INT 1
15576: PPUSH
15577: LD_INT 2
15579: PPUSH
15580: CALL_OW 12
15584: PUSH
15585: LD_INT 1
15587: DOUBLE
15588: EQUAL
15589: IFTRUE 15593
15591: GO 15605
15593: POP
// RaiseSailEvent ( normal1_utok ) ; 2 :
15594: LD_EXP 36
15598: PPUSH
15599: CALL_OW 427
15603: GO 15666
15605: LD_INT 2
15607: DOUBLE
15608: EQUAL
15609: IFTRUE 15613
15611: GO 15625
15613: POP
// RaiseSailEvent ( normal2_utok ) ; 1 :
15614: LD_EXP 37
15618: PPUSH
15619: CALL_OW 427
15623: GO 15666
15625: LD_INT 1
15627: DOUBLE
15628: EQUAL
15629: IFTRUE 15633
15631: GO 15645
15633: POP
// RaiseSailEvent ( normal3_utok ) ; 2 :
15634: LD_EXP 38
15638: PPUSH
15639: CALL_OW 427
15643: GO 15666
15645: LD_INT 2
15647: DOUBLE
15648: EQUAL
15649: IFTRUE 15653
15651: GO 15665
15653: POP
// RaiseSailEvent ( normal4_utok ) ; end ;
15654: LD_EXP 39
15658: PPUSH
15659: CALL_OW 427
15663: GO 15666
15665: POP
// enable ;
15666: ENABLE
// end ;
15667: PPOPN 1
15669: END
// every 0 0$3 trigger remote do var i ;
15670: LD_EXP 29
15674: IFFALSE 15778
15676: GO 15678
15678: DISABLE
15679: LD_INT 0
15681: PPUSH
// begin if mec then
15682: LD_EXP 22
15686: IFFALSE 15777
// for i in remote do
15688: LD_ADDR_VAR 0 1
15692: PUSH
15693: LD_EXP 29
15697: PUSH
15698: FOR_IN
15699: IFFALSE 15775
// if not UnitsInside ( i ) then
15701: LD_VAR 0 1
15705: PPUSH
15706: CALL_OW 313
15710: NOT
15711: IFFALSE 15773
// begin if not rmec then
15713: LD_EXP 24
15717: NOT
15718: IFFALSE 15734
// rmec := mec [ 1 ] ;
15720: LD_ADDR_EXP 24
15724: PUSH
15725: LD_EXP 22
15729: PUSH
15730: LD_INT 1
15732: ARRAY
15733: ST_TO_ADDR
// ComExitVehicle ( rmec ) ;
15734: LD_EXP 24
15738: PPUSH
15739: CALL_OW 121
// AddComEnterUnit ( rmec , i ) ;
15743: LD_EXP 24
15747: PPUSH
15748: LD_VAR 0 1
15752: PPUSH
15753: CALL_OW 180
// mec := mec diff rmec ;
15757: LD_ADDR_EXP 22
15761: PUSH
15762: LD_EXP 22
15766: PUSH
15767: LD_EXP 24
15771: DIFF
15772: ST_TO_ADDR
// end ;
15773: GO 15698
15775: POP
15776: POP
// enable ;
15777: ENABLE
// end ;
15778: PPOPN 1
15780: END
// every 0 0$3 trigger not remote do
15781: LD_EXP 29
15785: NOT
15786: IFFALSE 15808
15788: GO 15790
15790: DISABLE
// begin mec := mec union rmec ;
15791: LD_ADDR_EXP 22
15795: PUSH
15796: LD_EXP 22
15800: PUSH
15801: LD_EXP 24
15805: UNION
15806: ST_TO_ADDR
// enable ;
15807: ENABLE
// end ;
15808: END
// every 0 0$3 trigger UnitFilter ( attack , [ f_not , [ f_linked ] ] ) do var i ;
15809: LD_EXP 27
15813: PPUSH
15814: LD_INT 3
15816: PUSH
15817: LD_INT 61
15819: PUSH
15820: EMPTY
15821: LIST
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PPUSH
15827: CALL_OW 72
15831: IFFALSE 15872
15833: GO 15835
15835: DISABLE
15836: LD_INT 0
15838: PPUSH
// begin ComLinkTo ( UnitFilter ( attack , [ f_not , [ f_linked ] ] ) , rmec ) ;
15839: LD_EXP 27
15843: PPUSH
15844: LD_INT 3
15846: PUSH
15847: LD_INT 61
15849: PUSH
15850: EMPTY
15851: LIST
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PPUSH
15857: CALL_OW 72
15861: PPUSH
15862: LD_EXP 24
15866: PPUSH
15867: CALL_OW 135
// enable ;
15871: ENABLE
// end ;
15872: PPOPN 1
15874: END
// export function f_vodni_utok ; var path , i ; begin
15875: LD_INT 0
15877: PPUSH
15878: PPUSH
15879: PPUSH
// path := [ [ 177 , 126 ] , [ 149 , 114 ] , [ 117 , 87 ] , [ 107 , 99 ] , [ 81 , 98 ] , [ 60 , 86 ] , [ 49 , 72 ] , [ 37 , 43 ] , [ 54 , 29 ] , [ 62 , 27 ] , [ 54 , 29 ] , [ 37 , 43 ] , [ 49 , 72 ] , [ 60 , 86 ] , [ 81 , 98 ] , [ 107 , 99 ] , [ 117 , 87 ] , [ 149 , 114 ] , [ 177 , 126 ] ] ;
15880: LD_ADDR_VAR 0 2
15884: PUSH
15885: LD_INT 177
15887: PUSH
15888: LD_INT 126
15890: PUSH
15891: EMPTY
15892: LIST
15893: LIST
15894: PUSH
15895: LD_INT 149
15897: PUSH
15898: LD_INT 114
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: PUSH
15905: LD_INT 117
15907: PUSH
15908: LD_INT 87
15910: PUSH
15911: EMPTY
15912: LIST
15913: LIST
15914: PUSH
15915: LD_INT 107
15917: PUSH
15918: LD_INT 99
15920: PUSH
15921: EMPTY
15922: LIST
15923: LIST
15924: PUSH
15925: LD_INT 81
15927: PUSH
15928: LD_INT 98
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: PUSH
15935: LD_INT 60
15937: PUSH
15938: LD_INT 86
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: LD_INT 49
15947: PUSH
15948: LD_INT 72
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: PUSH
15955: LD_INT 37
15957: PUSH
15958: LD_INT 43
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: PUSH
15965: LD_INT 54
15967: PUSH
15968: LD_INT 29
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: PUSH
15975: LD_INT 62
15977: PUSH
15978: LD_INT 27
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PUSH
15985: LD_INT 54
15987: PUSH
15988: LD_INT 29
15990: PUSH
15991: EMPTY
15992: LIST
15993: LIST
15994: PUSH
15995: LD_INT 37
15997: PUSH
15998: LD_INT 43
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: PUSH
16005: LD_INT 49
16007: PUSH
16008: LD_INT 72
16010: PUSH
16011: EMPTY
16012: LIST
16013: LIST
16014: PUSH
16015: LD_INT 60
16017: PUSH
16018: LD_INT 86
16020: PUSH
16021: EMPTY
16022: LIST
16023: LIST
16024: PUSH
16025: LD_INT 81
16027: PUSH
16028: LD_INT 98
16030: PUSH
16031: EMPTY
16032: LIST
16033: LIST
16034: PUSH
16035: LD_INT 107
16037: PUSH
16038: LD_INT 99
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: PUSH
16045: LD_INT 117
16047: PUSH
16048: LD_INT 87
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: PUSH
16055: LD_INT 149
16057: PUSH
16058: LD_INT 114
16060: PUSH
16061: EMPTY
16062: LIST
16063: LIST
16064: PUSH
16065: LD_INT 177
16067: PUSH
16068: LD_INT 126
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: LIST
16081: LIST
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: LIST
16088: LIST
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: LIST
16095: ST_TO_ADDR
// find_and_wait ( UnitFilter ( hover , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16096: LD_EXP 70
16100: PPUSH
16101: LD_INT 33
16103: PUSH
16104: LD_INT 1
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: PUSH
16111: EMPTY
16112: LIST
16113: PPUSH
16114: CALL_OW 72
16118: PPUSH
16119: LD_EXP 19
16123: PPUSH
16124: LD_INT 0
16126: PPUSH
16127: LD_INT 0
16129: PPUSH
16130: LD_INT 1750
16132: PPUSH
16133: CALL 24371 0 5
// find_and_wait_r ( UnitFilter ( hover , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16137: LD_EXP 70
16141: PPUSH
16142: LD_INT 33
16144: PUSH
16145: LD_INT 2
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PUSH
16152: EMPTY
16153: LIST
16154: PPUSH
16155: CALL_OW 72
16159: PPUSH
16160: LD_EXP 29
16164: PPUSH
16165: LD_INT 1750
16167: PPUSH
16168: CALL 25071 0 3
// for i in path do
16172: LD_ADDR_VAR 0 3
16176: PUSH
16177: LD_VAR 0 2
16181: PUSH
16182: FOR_IN
16183: IFFALSE 16258
// AddComAgressiveMove ( hover , Rand ( i [ 1 ] - 1 , i [ 1 ] + 1 ) , Rand ( i [ 2 ] - 1 , i [ 2 ] + 1 ) ) ;
16185: LD_EXP 70
16189: PPUSH
16190: LD_VAR 0 3
16194: PUSH
16195: LD_INT 1
16197: ARRAY
16198: PUSH
16199: LD_INT 1
16201: MINUS
16202: PPUSH
16203: LD_VAR 0 3
16207: PUSH
16208: LD_INT 1
16210: ARRAY
16211: PUSH
16212: LD_INT 1
16214: PLUS
16215: PPUSH
16216: CALL_OW 12
16220: PPUSH
16221: LD_VAR 0 3
16225: PUSH
16226: LD_INT 2
16228: ARRAY
16229: PUSH
16230: LD_INT 1
16232: MINUS
16233: PPUSH
16234: LD_VAR 0 3
16238: PUSH
16239: LD_INT 2
16241: ARRAY
16242: PUSH
16243: LD_INT 1
16245: PLUS
16246: PPUSH
16247: CALL_OW 12
16251: PPUSH
16252: CALL_OW 174
16256: GO 16182
16258: POP
16259: POP
// end ;
16260: LD_VAR 0 1
16264: RET
// export function f_normal1_utok ; var path , i ; begin
16265: LD_INT 0
16267: PPUSH
16268: PPUSH
16269: PPUSH
// path := [ [ 102 , 68 ] , [ 96 , 67 ] , [ 73 , 55 ] , [ 69 , 77 ] , [ 59 , 54 ] ] ;
16270: LD_ADDR_VAR 0 2
16274: PUSH
16275: LD_INT 102
16277: PUSH
16278: LD_INT 68
16280: PUSH
16281: EMPTY
16282: LIST
16283: LIST
16284: PUSH
16285: LD_INT 96
16287: PUSH
16288: LD_INT 67
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: PUSH
16295: LD_INT 73
16297: PUSH
16298: LD_INT 55
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PUSH
16305: LD_INT 69
16307: PUSH
16308: LD_INT 77
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: PUSH
16315: LD_INT 59
16317: PUSH
16318: LD_INT 54
16320: PUSH
16321: EMPTY
16322: LIST
16323: LIST
16324: PUSH
16325: EMPTY
16326: LIST
16327: LIST
16328: LIST
16329: LIST
16330: LIST
16331: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16332: LD_EXP 71
16336: PPUSH
16337: LD_INT 33
16339: PUSH
16340: LD_INT 1
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PUSH
16347: EMPTY
16348: LIST
16349: PPUSH
16350: CALL_OW 72
16354: PPUSH
16355: LD_EXP 19
16359: PPUSH
16360: LD_INT 0
16362: PPUSH
16363: LD_INT 0
16365: PPUSH
16366: LD_INT 1750
16368: PPUSH
16369: CALL 24371 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16373: LD_EXP 71
16377: PPUSH
16378: LD_INT 33
16380: PUSH
16381: LD_INT 2
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PUSH
16388: EMPTY
16389: LIST
16390: PPUSH
16391: CALL_OW 72
16395: PPUSH
16396: LD_EXP 29
16400: PPUSH
16401: LD_INT 1750
16403: PPUSH
16404: CALL 25071 0 3
// for i in path do
16408: LD_ADDR_VAR 0 3
16412: PUSH
16413: LD_VAR 0 2
16417: PUSH
16418: FOR_IN
16419: IFFALSE 16494
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16421: LD_EXP 71
16425: PPUSH
16426: LD_VAR 0 3
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PUSH
16435: LD_INT 4
16437: MINUS
16438: PPUSH
16439: LD_VAR 0 3
16443: PUSH
16444: LD_INT 1
16446: ARRAY
16447: PUSH
16448: LD_INT 4
16450: PLUS
16451: PPUSH
16452: CALL_OW 12
16456: PPUSH
16457: LD_VAR 0 3
16461: PUSH
16462: LD_INT 2
16464: ARRAY
16465: PUSH
16466: LD_INT 4
16468: MINUS
16469: PPUSH
16470: LD_VAR 0 3
16474: PUSH
16475: LD_INT 2
16477: ARRAY
16478: PUSH
16479: LD_INT 4
16481: PLUS
16482: PPUSH
16483: CALL_OW 12
16487: PPUSH
16488: CALL_OW 174
16492: GO 16418
16494: POP
16495: POP
// end ;
16496: LD_VAR 0 1
16500: RET
// export function f_normal2_utok ; var path , i ; begin
16501: LD_INT 0
16503: PPUSH
16504: PPUSH
16505: PPUSH
// path := [ [ 91 , 61 ] , [ 79 , 79 ] , [ 57 , 61 ] , [ 68 , 48 ] , [ 64 , 94 ] ] ;
16506: LD_ADDR_VAR 0 2
16510: PUSH
16511: LD_INT 91
16513: PUSH
16514: LD_INT 61
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: PUSH
16521: LD_INT 79
16523: PUSH
16524: LD_INT 79
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 57
16533: PUSH
16534: LD_INT 61
16536: PUSH
16537: EMPTY
16538: LIST
16539: LIST
16540: PUSH
16541: LD_INT 68
16543: PUSH
16544: LD_INT 48
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PUSH
16551: LD_INT 64
16553: PUSH
16554: LD_INT 94
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: LIST
16566: LIST
16567: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16568: LD_EXP 71
16572: PPUSH
16573: LD_INT 33
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: PUSH
16583: EMPTY
16584: LIST
16585: PPUSH
16586: CALL_OW 72
16590: PPUSH
16591: LD_EXP 19
16595: PPUSH
16596: LD_INT 0
16598: PPUSH
16599: LD_INT 0
16601: PPUSH
16602: LD_INT 1750
16604: PPUSH
16605: CALL 24371 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16609: LD_EXP 71
16613: PPUSH
16614: LD_INT 33
16616: PUSH
16617: LD_INT 2
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: PPUSH
16627: CALL_OW 72
16631: PPUSH
16632: LD_EXP 29
16636: PPUSH
16637: LD_INT 1750
16639: PPUSH
16640: CALL 25071 0 3
// for i in path do
16644: LD_ADDR_VAR 0 3
16648: PUSH
16649: LD_VAR 0 2
16653: PUSH
16654: FOR_IN
16655: IFFALSE 16730
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16657: LD_EXP 71
16661: PPUSH
16662: LD_VAR 0 3
16666: PUSH
16667: LD_INT 1
16669: ARRAY
16670: PUSH
16671: LD_INT 4
16673: MINUS
16674: PPUSH
16675: LD_VAR 0 3
16679: PUSH
16680: LD_INT 1
16682: ARRAY
16683: PUSH
16684: LD_INT 4
16686: PLUS
16687: PPUSH
16688: CALL_OW 12
16692: PPUSH
16693: LD_VAR 0 3
16697: PUSH
16698: LD_INT 2
16700: ARRAY
16701: PUSH
16702: LD_INT 4
16704: MINUS
16705: PPUSH
16706: LD_VAR 0 3
16710: PUSH
16711: LD_INT 2
16713: ARRAY
16714: PUSH
16715: LD_INT 4
16717: PLUS
16718: PPUSH
16719: CALL_OW 12
16723: PPUSH
16724: CALL_OW 174
16728: GO 16654
16730: POP
16731: POP
// end ;
16732: LD_VAR 0 1
16736: RET
// export function f_normal3_utok ; var path , i ; begin
16737: LD_INT 0
16739: PPUSH
16740: PPUSH
16741: PPUSH
// path := [ [ 114 , 67 ] , [ 108 , 67 ] , [ 102 , 66 ] , [ 94 , 65 ] , [ 95 , 79 ] , [ 91 , 89 ] , [ 81 , 93 ] , [ 71 , 83 ] , [ 61 , 75 ] , [ 52 , 58 ] , [ 67 , 71 ] , [ 70 , 59 ] , [ 65 , 49 ] , [ 51 , 45 ] , [ 65 , 40 ] , [ 92 , 67 ] ] ;
16742: LD_ADDR_VAR 0 2
16746: PUSH
16747: LD_INT 114
16749: PUSH
16750: LD_INT 67
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: PUSH
16757: LD_INT 108
16759: PUSH
16760: LD_INT 67
16762: PUSH
16763: EMPTY
16764: LIST
16765: LIST
16766: PUSH
16767: LD_INT 102
16769: PUSH
16770: LD_INT 66
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PUSH
16777: LD_INT 94
16779: PUSH
16780: LD_INT 65
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: LD_INT 95
16789: PUSH
16790: LD_INT 79
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 91
16799: PUSH
16800: LD_INT 89
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: LD_INT 81
16809: PUSH
16810: LD_INT 93
16812: PUSH
16813: EMPTY
16814: LIST
16815: LIST
16816: PUSH
16817: LD_INT 71
16819: PUSH
16820: LD_INT 83
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: PUSH
16827: LD_INT 61
16829: PUSH
16830: LD_INT 75
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 52
16839: PUSH
16840: LD_INT 58
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 67
16849: PUSH
16850: LD_INT 71
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: LD_INT 70
16859: PUSH
16860: LD_INT 59
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 65
16869: PUSH
16870: LD_INT 49
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: PUSH
16877: LD_INT 51
16879: PUSH
16880: LD_INT 45
16882: PUSH
16883: EMPTY
16884: LIST
16885: LIST
16886: PUSH
16887: LD_INT 65
16889: PUSH
16890: LD_INT 40
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PUSH
16897: LD_INT 92
16899: PUSH
16900: LD_INT 67
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: LIST
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: LIST
16923: LIST
16924: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16925: LD_EXP 71
16929: PPUSH
16930: LD_INT 33
16932: PUSH
16933: LD_INT 1
16935: PUSH
16936: EMPTY
16937: LIST
16938: LIST
16939: PUSH
16940: EMPTY
16941: LIST
16942: PPUSH
16943: CALL_OW 72
16947: PPUSH
16948: LD_EXP 19
16952: PPUSH
16953: LD_INT 0
16955: PPUSH
16956: LD_INT 0
16958: PPUSH
16959: LD_INT 1750
16961: PPUSH
16962: CALL 24371 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16966: LD_EXP 71
16970: PPUSH
16971: LD_INT 33
16973: PUSH
16974: LD_INT 2
16976: PUSH
16977: EMPTY
16978: LIST
16979: LIST
16980: PUSH
16981: EMPTY
16982: LIST
16983: PPUSH
16984: CALL_OW 72
16988: PPUSH
16989: LD_EXP 29
16993: PPUSH
16994: LD_INT 1750
16996: PPUSH
16997: CALL 25071 0 3
// for i in path do
17001: LD_ADDR_VAR 0 3
17005: PUSH
17006: LD_VAR 0 2
17010: PUSH
17011: FOR_IN
17012: IFFALSE 17087
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17014: LD_EXP 71
17018: PPUSH
17019: LD_VAR 0 3
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PUSH
17028: LD_INT 4
17030: MINUS
17031: PPUSH
17032: LD_VAR 0 3
17036: PUSH
17037: LD_INT 1
17039: ARRAY
17040: PUSH
17041: LD_INT 4
17043: PLUS
17044: PPUSH
17045: CALL_OW 12
17049: PPUSH
17050: LD_VAR 0 3
17054: PUSH
17055: LD_INT 2
17057: ARRAY
17058: PUSH
17059: LD_INT 4
17061: MINUS
17062: PPUSH
17063: LD_VAR 0 3
17067: PUSH
17068: LD_INT 2
17070: ARRAY
17071: PUSH
17072: LD_INT 4
17074: PLUS
17075: PPUSH
17076: CALL_OW 12
17080: PPUSH
17081: CALL_OW 174
17085: GO 17011
17087: POP
17088: POP
// end ;
17089: LD_VAR 0 1
17093: RET
// export function f_normal4_utok ; var path , i ; begin
17094: LD_INT 0
17096: PPUSH
17097: PPUSH
17098: PPUSH
// path := [ [ 112 , 68 ] , [ 98 , 67 ] , [ 80 , 61 ] , [ 72 , 61 ] , [ 62 , 60 ] , [ 61 , 50 ] , [ 49 , 38 ] , [ 52 , 48 ] , [ 62 , 62 ] , [ 66 , 78 ] , [ 74 , 80 ] ] ;
17099: LD_ADDR_VAR 0 2
17103: PUSH
17104: LD_INT 112
17106: PUSH
17107: LD_INT 68
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: LD_INT 98
17116: PUSH
17117: LD_INT 67
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: PUSH
17124: LD_INT 80
17126: PUSH
17127: LD_INT 61
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: PUSH
17134: LD_INT 72
17136: PUSH
17137: LD_INT 61
17139: PUSH
17140: EMPTY
17141: LIST
17142: LIST
17143: PUSH
17144: LD_INT 62
17146: PUSH
17147: LD_INT 60
17149: PUSH
17150: EMPTY
17151: LIST
17152: LIST
17153: PUSH
17154: LD_INT 61
17156: PUSH
17157: LD_INT 50
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: PUSH
17164: LD_INT 49
17166: PUSH
17167: LD_INT 38
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: PUSH
17174: LD_INT 52
17176: PUSH
17177: LD_INT 48
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 62
17186: PUSH
17187: LD_INT 62
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 66
17196: PUSH
17197: LD_INT 78
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 74
17206: PUSH
17207: LD_INT 80
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
17227: LD_EXP 71
17231: PPUSH
17232: LD_INT 33
17234: PUSH
17235: LD_INT 1
17237: PUSH
17238: EMPTY
17239: LIST
17240: LIST
17241: PUSH
17242: EMPTY
17243: LIST
17244: PPUSH
17245: CALL_OW 72
17249: PPUSH
17250: LD_EXP 19
17254: PPUSH
17255: LD_INT 0
17257: PPUSH
17258: LD_INT 0
17260: PPUSH
17261: LD_INT 1750
17263: PPUSH
17264: CALL 24371 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
17268: LD_EXP 71
17272: PPUSH
17273: LD_INT 33
17275: PUSH
17276: LD_INT 2
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: EMPTY
17284: LIST
17285: PPUSH
17286: CALL_OW 72
17290: PPUSH
17291: LD_EXP 29
17295: PPUSH
17296: LD_INT 1750
17298: PPUSH
17299: CALL 25071 0 3
// for i in path do
17303: LD_ADDR_VAR 0 3
17307: PUSH
17308: LD_VAR 0 2
17312: PUSH
17313: FOR_IN
17314: IFFALSE 17389
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17316: LD_EXP 71
17320: PPUSH
17321: LD_VAR 0 3
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PUSH
17330: LD_INT 4
17332: MINUS
17333: PPUSH
17334: LD_VAR 0 3
17338: PUSH
17339: LD_INT 1
17341: ARRAY
17342: PUSH
17343: LD_INT 4
17345: PLUS
17346: PPUSH
17347: CALL_OW 12
17351: PPUSH
17352: LD_VAR 0 3
17356: PUSH
17357: LD_INT 2
17359: ARRAY
17360: PUSH
17361: LD_INT 4
17363: MINUS
17364: PPUSH
17365: LD_VAR 0 3
17369: PUSH
17370: LD_INT 2
17372: ARRAY
17373: PUSH
17374: LD_INT 4
17376: PLUS
17377: PPUSH
17378: CALL_OW 12
17382: PPUSH
17383: CALL_OW 174
17387: GO 17313
17389: POP
17390: POP
// end ;
17391: LD_VAR 0 1
17395: RET
// export mines ; every 0 0$1 do var i ;
17396: GO 17398
17398: DISABLE
17399: LD_INT 0
17401: PPUSH
// begin mines := [ ] ;
17402: LD_ADDR_EXP 72
17406: PUSH
17407: EMPTY
17408: ST_TO_ADDR
// sol := UnitFilter ( sol , [ [ f_alive ] ] ) ;
17409: LD_ADDR_EXP 19
17413: PUSH
17414: LD_EXP 19
17418: PPUSH
17419: LD_INT 51
17421: PUSH
17422: EMPTY
17423: LIST
17424: PUSH
17425: EMPTY
17426: LIST
17427: PPUSH
17428: CALL_OW 72
17432: ST_TO_ADDR
// for i in sol do
17433: LD_ADDR_VAR 0 1
17437: PUSH
17438: LD_EXP 19
17442: PUSH
17443: FOR_IN
17444: IFFALSE 17478
// if MineOfUnit ( i ) then
17446: LD_VAR 0 1
17450: PPUSH
17451: CALL_OW 459
17455: IFFALSE 17476
// mines := mines ^ [ i ] ;
17457: LD_ADDR_EXP 72
17461: PUSH
17462: LD_EXP 72
17466: PUSH
17467: LD_VAR 0 1
17471: PUSH
17472: EMPTY
17473: LIST
17474: ADD
17475: ST_TO_ADDR
17476: GO 17443
17478: POP
17479: POP
// enable ;
17480: ENABLE
// end ;
17481: PPOPN 1
17483: END
// every 0 0$30 trigger mines < pocet_min do var i , a , s ;
17484: LD_EXP 72
17488: PUSH
17489: LD_EXP 16
17493: LESS
17494: IFFALSE 17635
17496: GO 17498
17498: DISABLE
17499: LD_INT 0
17501: PPUSH
17502: PPUSH
17503: PPUSH
// begin s := UnitFilter ( sol , [ [ f_outside ] ] ) ;
17504: LD_ADDR_VAR 0 3
17508: PUSH
17509: LD_EXP 19
17513: PPUSH
17514: LD_INT 56
17516: PUSH
17517: EMPTY
17518: LIST
17519: PUSH
17520: EMPTY
17521: LIST
17522: PPUSH
17523: CALL_OW 72
17527: ST_TO_ADDR
// if s then
17528: LD_VAR 0 3
17532: IFFALSE 17634
// begin i := s [ Rand ( 1 , s ) ] ;
17534: LD_ADDR_VAR 0 1
17538: PUSH
17539: LD_VAR 0 3
17543: PUSH
17544: LD_INT 1
17546: PPUSH
17547: LD_VAR 0 3
17551: PPUSH
17552: CALL_OW 12
17556: ARRAY
17557: ST_TO_ADDR
// if not MineOfUnit ( i ) then
17558: LD_VAR 0 1
17562: PPUSH
17563: CALL_OW 459
17567: NOT
17568: IFFALSE 17634
// begin ComRemember ( i ) ;
17570: LD_VAR 0 1
17574: PPUSH
17575: CALL_OW 143
// a := RandHexArea ( miny , false ) ;
17579: LD_ADDR_VAR 0 2
17583: PUSH
17584: LD_INT 25
17586: PPUSH
17587: LD_INT 0
17589: PPUSH
17590: CALL_OW 16
17594: ST_TO_ADDR
// AddComPlaceRemoteCharge ( i , a [ 1 ] , a [ 2 ] , 0 ) ;
17595: LD_VAR 0 1
17599: PPUSH
17600: LD_VAR 0 2
17604: PUSH
17605: LD_INT 1
17607: ARRAY
17608: PPUSH
17609: LD_VAR 0 2
17613: PUSH
17614: LD_INT 2
17616: ARRAY
17617: PPUSH
17618: LD_INT 0
17620: PPUSH
17621: CALL_OW 193
// AddComReturn ( i ) ;
17625: LD_VAR 0 1
17629: PPUSH
17630: CALL_OW 204
// end ; end ; enable ;
17634: ENABLE
// end ;
17635: PPOPN 3
17637: END
// every 0 0$2 trigger mines and FilterUnitsInArea ( miny , [ [ f_side , you ] ] ) and ( FilterUnitsInArea ( miny , [ [ f_side , arabians ] ] ) < 2 ) do
17638: LD_EXP 72
17642: PUSH
17643: LD_INT 25
17645: PPUSH
17646: LD_INT 22
17648: PUSH
17649: LD_EXP 1
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: PUSH
17658: EMPTY
17659: LIST
17660: PPUSH
17661: CALL_OW 70
17665: AND
17666: PUSH
17667: LD_INT 25
17669: PPUSH
17670: LD_INT 22
17672: PUSH
17673: LD_EXP 3
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: PUSH
17682: EMPTY
17683: LIST
17684: PPUSH
17685: CALL_OW 70
17689: PUSH
17690: LD_INT 2
17692: LESS
17693: AND
17694: IFFALSE 17745
17696: GO 17698
17698: DISABLE
// begin ComFireExplosives ( mines [ 1 ] ) ;
17699: LD_EXP 72
17703: PUSH
17704: LD_INT 1
17706: ARRAY
17707: PPUSH
17708: CALL_OW 134
// mines := mines diff [ mines [ 1 ] ] ;
17712: LD_ADDR_EXP 72
17716: PUSH
17717: LD_EXP 72
17721: PUSH
17722: LD_EXP 72
17726: PUSH
17727: LD_INT 1
17729: ARRAY
17730: PUSH
17731: EMPTY
17732: LIST
17733: DIFF
17734: ST_TO_ADDR
// wait ( mezera_mezi_minami ) ;
17735: LD_EXP 15
17739: PPUSH
17740: CALL_OW 67
// enable ;
17744: ENABLE
// end ; end_of_file
17745: END
// export opravit ; every 0 0$1 do var set_fuel , fuel ;
17746: GO 17748
17748: DISABLE
17749: LD_INT 0
17751: PPUSH
17752: PPUSH
// begin for set_fuel in FilterUnitsInArea ( near_base , [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) do
17753: LD_ADDR_VAR 0 1
17757: PUSH
17758: LD_INT 13
17760: PPUSH
17761: LD_INT 21
17763: PUSH
17764: LD_INT 2
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: PUSH
17771: LD_INT 22
17773: PUSH
17774: LD_EXP 3
17778: PUSH
17779: EMPTY
17780: LIST
17781: LIST
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: PPUSH
17787: CALL_OW 70
17791: PUSH
17792: FOR_IN
17793: IFFALSE 17834
// begin fuel := GetFuel ( set_fuel ) ;
17795: LD_ADDR_VAR 0 2
17799: PUSH
17800: LD_VAR 0 1
17804: PPUSH
17805: CALL_OW 261
17809: ST_TO_ADDR
// if fuel < 100 then
17810: LD_VAR 0 2
17814: PUSH
17815: LD_INT 100
17817: LESS
17818: IFFALSE 17832
// SetFuel ( set_fuel , 100 ) ;
17820: LD_VAR 0 1
17824: PPUSH
17825: LD_INT 100
17827: PPUSH
17828: CALL_OW 240
// end ;
17832: GO 17792
17834: POP
17835: POP
// enable ;
17836: ENABLE
// end ;
17837: PPOPN 2
17839: END
// every 0 0$10 + 0 0$8 do var zivoty , i ;
17840: GO 17842
17842: DISABLE
17843: LD_INT 0
17845: PPUSH
17846: PPUSH
// begin opravit := [ ] ;
17847: LD_ADDR_EXP 73
17851: PUSH
17852: EMPTY
17853: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
17854: LD_ADDR_VAR 0 2
17858: PUSH
17859: LD_INT 22
17861: PUSH
17862: LD_EXP 3
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PUSH
17871: LD_INT 21
17873: PUSH
17874: LD_INT 3
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PPUSH
17885: CALL_OW 69
17889: PUSH
17890: FOR_IN
17891: IFFALSE 17947
// begin if GetLives ( i ) < 950 then
17893: LD_VAR 0 2
17897: PPUSH
17898: CALL_OW 256
17902: PUSH
17903: LD_INT 950
17905: LESS
17906: IFFALSE 17945
// begin opravit := opravit ^ i ;
17908: LD_ADDR_EXP 73
17912: PUSH
17913: LD_EXP 73
17917: PUSH
17918: LD_VAR 0 2
17922: ADD
17923: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
17924: LD_ADDR_VAR 0 1
17928: PUSH
17929: LD_VAR 0 1
17933: PUSH
17934: LD_VAR 0 2
17938: PPUSH
17939: CALL_OW 256
17943: ADD
17944: ST_TO_ADDR
// end ; end ;
17945: GO 17890
17947: POP
17948: POP
// opravit := SortListByListAsc ( opravit , zivoty ) ;
17949: LD_ADDR_EXP 73
17953: PUSH
17954: LD_EXP 73
17958: PPUSH
17959: LD_VAR 0 1
17963: PPUSH
17964: CALL_OW 76
17968: ST_TO_ADDR
// enable ;
17969: ENABLE
// end ;
17970: PPOPN 2
17972: END
// every 0 0$20 trigger opravit do var tmp_eng ;
17973: LD_EXP 73
17977: IFFALSE 18069
17979: GO 17981
17981: DISABLE
17982: LD_INT 0
17984: PPUSH
// begin while not eng do
17985: LD_EXP 23
17989: NOT
17990: IFFALSE 18001
// wait ( 0 0$5 ) ;
17992: LD_INT 175
17994: PPUSH
17995: CALL_OW 67
17999: GO 17985
// tmp_eng := eng ;
18001: LD_ADDR_VAR 0 1
18005: PUSH
18006: LD_EXP 23
18010: ST_TO_ADDR
// eng := [ ] ;
18011: LD_ADDR_EXP 23
18015: PUSH
18016: EMPTY
18017: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ) ;
18018: LD_VAR 0 1
18022: PPUSH
18023: CALL_OW 122
// AddComRepairBuilding ( tmp_eng , opravit [ 1 ] ) ;
18027: LD_VAR 0 1
18031: PPUSH
18032: LD_EXP 73
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL_OW 190
// wait ( 0 0$19.9 ) ;
18045: LD_INT 696
18047: PPUSH
18048: CALL_OW 67
// eng := eng union tmp_eng ;
18052: LD_ADDR_EXP 23
18056: PUSH
18057: LD_EXP 23
18061: PUSH
18062: LD_VAR 0 1
18066: UNION
18067: ST_TO_ADDR
// enable ;
18068: ENABLE
// end ;
18069: PPOPN 1
18071: END
// every 0 0$10 trigger stavi do var tmp_eng , tmp_sci ;
18072: LD_EXP 68
18076: IFFALSE 18200
18078: GO 18080
18080: DISABLE
18081: LD_INT 0
18083: PPUSH
18084: PPUSH
// begin tmp_eng := eng ;
18085: LD_ADDR_VAR 0 1
18089: PUSH
18090: LD_EXP 23
18094: ST_TO_ADDR
// eng := [ ] ;
18095: LD_ADDR_EXP 23
18099: PUSH
18100: EMPTY
18101: ST_TO_ADDR
// tmp_sci := sci ;
18102: LD_ADDR_VAR 0 2
18106: PUSH
18107: LD_EXP 21
18111: ST_TO_ADDR
// sci := [ ] ;
18112: LD_ADDR_EXP 21
18116: PUSH
18117: EMPTY
18118: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ^ tmp_sci ) ;
18119: LD_VAR 0 1
18123: PUSH
18124: LD_VAR 0 2
18128: ADD
18129: PPUSH
18130: CALL_OW 122
// AddComMoveXY ( tmp_eng ^ tmp_sci , stavi [ 1 ] , stavi [ 2 ] ) ;
18134: LD_VAR 0 1
18138: PUSH
18139: LD_VAR 0 2
18143: ADD
18144: PPUSH
18145: LD_EXP 68
18149: PUSH
18150: LD_INT 1
18152: ARRAY
18153: PPUSH
18154: LD_EXP 68
18158: PUSH
18159: LD_INT 2
18161: ARRAY
18162: PPUSH
18163: CALL_OW 171
// eng := eng union tmp_eng ;
18167: LD_ADDR_EXP 23
18171: PUSH
18172: LD_EXP 23
18176: PUSH
18177: LD_VAR 0 1
18181: UNION
18182: ST_TO_ADDR
// sci := sci union tmp_sci ;
18183: LD_ADDR_EXP 21
18187: PUSH
18188: LD_EXP 21
18192: PUSH
18193: LD_VAR 0 2
18197: UNION
18198: ST_TO_ADDR
// enable ;
18199: ENABLE
// end ;
18200: PPOPN 2
18202: END
// export brk_cars ; every 0 0$1 do var zivoty , i ;
18203: GO 18205
18205: DISABLE
18206: LD_INT 0
18208: PPUSH
18209: PPUSH
// begin for i in attack do
18210: LD_ADDR_VAR 0 2
18214: PUSH
18215: LD_EXP 27
18219: PUSH
18220: FOR_IN
18221: IFFALSE 18334
// begin if GetLives ( i ) < 600 or GetFuel ( i ) < 30 then
18223: LD_VAR 0 2
18227: PPUSH
18228: CALL_OW 256
18232: PUSH
18233: LD_INT 600
18235: LESS
18236: PUSH
18237: LD_VAR 0 2
18241: PPUSH
18242: CALL_OW 261
18246: PUSH
18247: LD_INT 30
18249: LESS
18250: OR
18251: IFFALSE 18286
// begin ComMoveXY ( i , 141 , 72 ) ;
18253: LD_VAR 0 2
18257: PPUSH
18258: LD_INT 141
18260: PPUSH
18261: LD_INT 72
18263: PPUSH
18264: CALL_OW 111
// brk_cars := brk_cars union i ;
18268: LD_ADDR_EXP 74
18272: PUSH
18273: LD_EXP 74
18277: PUSH
18278: LD_VAR 0 2
18282: UNION
18283: ST_TO_ADDR
// end else
18284: GO 18332
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18286: LD_VAR 0 2
18290: PPUSH
18291: CALL_OW 256
18295: PUSH
18296: LD_INT 995
18298: GREATER
18299: PUSH
18300: LD_VAR 0 2
18304: PPUSH
18305: CALL_OW 261
18309: PUSH
18310: LD_INT 99
18312: GREATER
18313: AND
18314: IFFALSE 18332
// brk_cars := brk_cars diff i ;
18316: LD_ADDR_EXP 74
18320: PUSH
18321: LD_EXP 74
18325: PUSH
18326: LD_VAR 0 2
18330: DIFF
18331: ST_TO_ADDR
// end ;
18332: GO 18220
18334: POP
18335: POP
// enable ;
18336: ENABLE
// end ;
18337: PPOPN 2
18339: END
// every 0 0$10 do var zivoty , i ;
18340: GO 18342
18342: DISABLE
18343: LD_INT 0
18345: PPUSH
18346: PPUSH
// begin for i in ( defence diff mastodon ) do
18347: LD_ADDR_VAR 0 2
18351: PUSH
18352: LD_EXP 28
18356: PUSH
18357: LD_INT 1
18359: DIFF
18360: PUSH
18361: FOR_IN
18362: IFFALSE 18475
// begin if GetLives ( i ) < 400 and GetFuel ( i ) < 15 then
18364: LD_VAR 0 2
18368: PPUSH
18369: CALL_OW 256
18373: PUSH
18374: LD_INT 400
18376: LESS
18377: PUSH
18378: LD_VAR 0 2
18382: PPUSH
18383: CALL_OW 261
18387: PUSH
18388: LD_INT 15
18390: LESS
18391: AND
18392: IFFALSE 18427
// begin ComMoveXY ( i , 141 , 72 ) ;
18394: LD_VAR 0 2
18398: PPUSH
18399: LD_INT 141
18401: PPUSH
18402: LD_INT 72
18404: PPUSH
18405: CALL_OW 111
// brk_cars := brk_cars union i ;
18409: LD_ADDR_EXP 74
18413: PUSH
18414: LD_EXP 74
18418: PUSH
18419: LD_VAR 0 2
18423: UNION
18424: ST_TO_ADDR
// end else
18425: GO 18473
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18427: LD_VAR 0 2
18431: PPUSH
18432: CALL_OW 256
18436: PUSH
18437: LD_INT 995
18439: GREATER
18440: PUSH
18441: LD_VAR 0 2
18445: PPUSH
18446: CALL_OW 261
18450: PUSH
18451: LD_INT 99
18453: GREATER
18454: AND
18455: IFFALSE 18473
// brk_cars := brk_cars diff i ;
18457: LD_ADDR_EXP 74
18461: PUSH
18462: LD_EXP 74
18466: PUSH
18467: LD_VAR 0 2
18471: DIFF
18472: ST_TO_ADDR
// end ;
18473: GO 18361
18475: POP
18476: POP
// enable ;
18477: ENABLE
// end ;
18478: PPOPN 2
18480: END
// every 0 0$5 do var zivoty , i ;
18481: GO 18483
18483: DISABLE
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// begin for i in cargo do
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_EXP 25
18497: PUSH
18498: FOR_IN
18499: IFFALSE 18582
// begin if GetLives ( i ) < 800 then
18501: LD_VAR 0 2
18505: PPUSH
18506: CALL_OW 256
18510: PUSH
18511: LD_INT 800
18513: LESS
18514: IFFALSE 18549
// begin ComMoveXY ( i , 141 , 72 ) ;
18516: LD_VAR 0 2
18520: PPUSH
18521: LD_INT 141
18523: PPUSH
18524: LD_INT 72
18526: PPUSH
18527: CALL_OW 111
// brk_cars := brk_cars union i ;
18531: LD_ADDR_EXP 74
18535: PUSH
18536: LD_EXP 74
18540: PUSH
18541: LD_VAR 0 2
18545: UNION
18546: ST_TO_ADDR
// end else
18547: GO 18580
// if GetLives ( i ) > 995 then
18549: LD_VAR 0 2
18553: PPUSH
18554: CALL_OW 256
18558: PUSH
18559: LD_INT 995
18561: GREATER
18562: IFFALSE 18580
// brk_cars := brk_cars diff i ;
18564: LD_ADDR_EXP 74
18568: PUSH
18569: LD_EXP 74
18573: PUSH
18574: LD_VAR 0 2
18578: DIFF
18579: ST_TO_ADDR
// end ;
18580: GO 18498
18582: POP
18583: POP
// enable ;
18584: ENABLE
// end ;
18585: PPOPN 2
18587: END
// export rep_cars ; every 0 0$10 do var zivoty , i , tmp_mec , nejhorsi , mytick ;
18588: GO 18590
18590: DISABLE
18591: LD_INT 0
18593: PPUSH
18594: PPUSH
18595: PPUSH
18596: PPUSH
18597: PPUSH
// begin rep_cars := [ ] ;
18598: LD_ADDR_EXP 75
18602: PUSH
18603: EMPTY
18604: ST_TO_ADDR
// zivoty := [ ] ;
18605: LD_ADDR_VAR 0 1
18609: PUSH
18610: EMPTY
18611: ST_TO_ADDR
// for i in UnitFilter ( attack ^ ( defence diff mastodon ) ^ cargo , [ [ f_distxy , 141 , 72 , 20 ] ] ) do
18612: LD_ADDR_VAR 0 2
18616: PUSH
18617: LD_EXP 27
18621: PUSH
18622: LD_EXP 28
18626: PUSH
18627: LD_INT 1
18629: DIFF
18630: ADD
18631: PUSH
18632: LD_EXP 25
18636: ADD
18637: PPUSH
18638: LD_INT 92
18640: PUSH
18641: LD_INT 141
18643: PUSH
18644: LD_INT 72
18646: PUSH
18647: LD_INT 20
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: PUSH
18656: EMPTY
18657: LIST
18658: PPUSH
18659: CALL_OW 72
18663: PUSH
18664: FOR_IN
18665: IFFALSE 18721
// begin if GetLives ( i ) < 1000 then
18667: LD_VAR 0 2
18671: PPUSH
18672: CALL_OW 256
18676: PUSH
18677: LD_INT 1000
18679: LESS
18680: IFFALSE 18719
// begin rep_cars := rep_cars ^ i ;
18682: LD_ADDR_EXP 75
18686: PUSH
18687: LD_EXP 75
18691: PUSH
18692: LD_VAR 0 2
18696: ADD
18697: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
18698: LD_ADDR_VAR 0 1
18702: PUSH
18703: LD_VAR 0 1
18707: PUSH
18708: LD_VAR 0 2
18712: PPUSH
18713: CALL_OW 256
18717: ADD
18718: ST_TO_ADDR
// end ; end ;
18719: GO 18664
18721: POP
18722: POP
// if rep_cars then
18723: LD_EXP 75
18727: IFFALSE 18855
// begin nejhorsi := WorstFromListByList ( rep_cars , zivoty ) ;
18729: LD_ADDR_VAR 0 4
18733: PUSH
18734: LD_EXP 75
18738: PPUSH
18739: LD_VAR 0 1
18743: PPUSH
18744: CALL_OW 78
18748: ST_TO_ADDR
// tmp_mec := mec ;
18749: LD_ADDR_VAR 0 3
18753: PUSH
18754: LD_EXP 22
18758: ST_TO_ADDR
// mec := [ ] ;
18759: LD_ADDR_EXP 22
18763: PUSH
18764: EMPTY
18765: ST_TO_ADDR
// ComExitBuilding ( tmp_mec ) ;
18766: LD_VAR 0 3
18770: PPUSH
18771: CALL_OW 122
// AddComRepairVehicle ( tmp_mec , nejhorsi ) ;
18775: LD_VAR 0 3
18779: PPUSH
18780: LD_VAR 0 4
18784: PPUSH
18785: CALL_OW 189
// mytick := tick + 0 0$9.9 ;
18789: LD_ADDR_VAR 0 5
18793: PUSH
18794: LD_OWVAR 1
18798: PUSH
18799: LD_INT 347
18801: PLUS
18802: ST_TO_ADDR
// while mytick > tick and GetLives ( nejhorsi ) < 1000 do
18803: LD_VAR 0 5
18807: PUSH
18808: LD_OWVAR 1
18812: GREATER
18813: PUSH
18814: LD_VAR 0 4
18818: PPUSH
18819: CALL_OW 256
18823: PUSH
18824: LD_INT 1000
18826: LESS
18827: AND
18828: IFFALSE 18839
// wait ( 0 0$1 ) ;
18830: LD_INT 35
18832: PPUSH
18833: CALL_OW 67
18837: GO 18803
// mec := mec union tmp_mec ;
18839: LD_ADDR_EXP 22
18843: PUSH
18844: LD_EXP 22
18848: PUSH
18849: LD_VAR 0 3
18853: UNION
18854: ST_TO_ADDR
// end ; enable ;
18855: ENABLE
// end ; end_of_file
18856: PPOPN 5
18858: END
// every 3 3$12 trigger vsichni_gone do
18859: CALL 19151 0 0
18863: IFFALSE 19006
18865: GO 18867
18867: DISABLE
// begin create_arabs_scout ;
18868: CALL 19715 0 0
// SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
18872: LD_EXP 76
18876: PUSH
18877: LD_EXP 77
18881: PUSH
18882: LD_EXP 78
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: PPUSH
18892: LD_INT 100
18894: PPUSH
18895: CALL_OW 240
// PlaceUnitArea ( ArScout1 , ar_in_area , false ) ;
18899: LD_EXP 76
18903: PPUSH
18904: LD_INT 2
18906: PPUSH
18907: LD_INT 0
18909: PPUSH
18910: CALL_OW 49
// if difficulty >= 2 then
18914: LD_OWVAR 67
18918: PUSH
18919: LD_INT 2
18921: GREATEREQUAL
18922: IFFALSE 18939
// PlaceUnitArea ( ArScout2 , ar_in_area , false ) ;
18924: LD_EXP 77
18928: PPUSH
18929: LD_INT 2
18931: PPUSH
18932: LD_INT 0
18934: PPUSH
18935: CALL_OW 49
// if difficulty >= 3 then
18939: LD_OWVAR 67
18943: PUSH
18944: LD_INT 3
18946: GREATEREQUAL
18947: IFFALSE 18964
// PlaceUnitArea ( ArScout3 , ar_in_area , false ) ;
18949: LD_EXP 78
18953: PPUSH
18954: LD_INT 2
18956: PPUSH
18957: LD_INT 0
18959: PPUSH
18960: CALL_OW 49
// RaiseSailEvent ( 5001 ) ;
18964: LD_INT 5001
18966: PPUSH
18967: CALL_OW 427
// if difficulty >= 2 then
18971: LD_OWVAR 67
18975: PUSH
18976: LD_INT 2
18978: GREATEREQUAL
18979: IFFALSE 18988
// RaiseSailEvent ( 5002 ) ;
18981: LD_INT 5002
18983: PPUSH
18984: CALL_OW 427
// if difficulty >= 3 then
18988: LD_OWVAR 67
18992: PUSH
18993: LD_INT 3
18995: GREATEREQUAL
18996: IFFALSE 19005
// RaiseSailEvent ( 5003 ) ;
18998: LD_INT 5003
19000: PPUSH
19001: CALL_OW 427
// enable ;
19005: ENABLE
// end ;
19006: END
// every 3 3$12 + 1 1$0 trigger vsichni_gone do
19007: CALL 19151 0 0
19011: IFFALSE 19150
19013: GO 19015
19015: DISABLE
// begin SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
19016: LD_EXP 76
19020: PUSH
19021: LD_EXP 77
19025: PUSH
19026: LD_EXP 78
19030: PUSH
19031: EMPTY
19032: LIST
19033: LIST
19034: LIST
19035: PPUSH
19036: LD_INT 100
19038: PPUSH
19039: CALL_OW 240
// PlaceUnitArea ( ArScout1 , exit_area , false ) ;
19043: LD_EXP 76
19047: PPUSH
19048: LD_INT 1
19050: PPUSH
19051: LD_INT 0
19053: PPUSH
19054: CALL_OW 49
// if difficulty >= 2 then
19058: LD_OWVAR 67
19062: PUSH
19063: LD_INT 2
19065: GREATEREQUAL
19066: IFFALSE 19083
// PlaceUnitArea ( ArScout2 , exit_area , false ) ;
19068: LD_EXP 77
19072: PPUSH
19073: LD_INT 1
19075: PPUSH
19076: LD_INT 0
19078: PPUSH
19079: CALL_OW 49
// if difficulty >= 3 then
19083: LD_OWVAR 67
19087: PUSH
19088: LD_INT 3
19090: GREATEREQUAL
19091: IFFALSE 19108
// PlaceUnitArea ( ArScout3 , exit_area , false ) ;
19093: LD_EXP 78
19097: PPUSH
19098: LD_INT 1
19100: PPUSH
19101: LD_INT 0
19103: PPUSH
19104: CALL_OW 49
// RaiseSailEvent ( 5051 ) ;
19108: LD_INT 5051
19110: PPUSH
19111: CALL_OW 427
// if difficulty >= 2 then
19115: LD_OWVAR 67
19119: PUSH
19120: LD_INT 2
19122: GREATEREQUAL
19123: IFFALSE 19132
// RaiseSailEvent ( 5052 ) ;
19125: LD_INT 5052
19127: PPUSH
19128: CALL_OW 427
// if difficulty >= 3 then
19132: LD_OWVAR 67
19136: PUSH
19137: LD_INT 3
19139: GREATEREQUAL
19140: IFFALSE 19149
// RaiseSailEvent ( 5053 ) ;
19142: LD_INT 5053
19144: PPUSH
19145: CALL_OW 427
// enable ;
19149: ENABLE
// end ;
19150: END
// export function vsichni_gone ; begin
19151: LD_INT 0
19153: PPUSH
// result := false ;
19154: LD_ADDR_VAR 0 1
19158: PUSH
19159: LD_INT 0
19161: ST_TO_ADDR
// if not UnitFilter ( [ ArScout1 , ArScout2 , ArScout3 ] , [ [ f_ok ] ] ) then
19162: LD_EXP 76
19166: PUSH
19167: LD_EXP 77
19171: PUSH
19172: LD_EXP 78
19176: PUSH
19177: EMPTY
19178: LIST
19179: LIST
19180: LIST
19181: PPUSH
19182: LD_INT 50
19184: PUSH
19185: EMPTY
19186: LIST
19187: PUSH
19188: EMPTY
19189: LIST
19190: PPUSH
19191: CALL_OW 72
19195: NOT
19196: IFFALSE 19206
// result := true ;
19198: LD_ADDR_VAR 0 1
19202: PUSH
19203: LD_INT 1
19205: ST_TO_ADDR
// end ;
19206: LD_VAR 0 1
19210: RET
// export function f_arcar1_in ; begin
19211: LD_INT 0
19213: PPUSH
// while not IsInArea ( ArScout1 , exit_area ) do
19214: LD_EXP 76
19218: PPUSH
19219: LD_INT 1
19221: PPUSH
19222: CALL_OW 308
19226: NOT
19227: IFFALSE 19281
// begin if IsIdle ( arscout1 ) then
19229: LD_EXP 76
19233: PPUSH
19234: CALL_OW 316
19238: IFFALSE 19270
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19240: LD_EXP 76
19244: PPUSH
19245: LD_INT 127
19247: PPUSH
19248: LD_INT 135
19250: PPUSH
19251: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 70 , 134 ) ;
19255: LD_EXP 76
19259: PPUSH
19260: LD_INT 70
19262: PPUSH
19263: LD_INT 134
19265: PPUSH
19266: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19270: LD_EXP 76
19274: PPUSH
19275: CALL 21968 0 1
// end ;
19279: GO 19214
// RemoveUnit ( ArScout1 ) ;
19281: LD_EXP 76
19285: PPUSH
19286: CALL_OW 64
// end ;
19290: LD_VAR 0 1
19294: RET
// export function f_arcar2_in ; begin
19295: LD_INT 0
19297: PPUSH
// while not IsInArea ( ArScout2 , exit_area ) do
19298: LD_EXP 77
19302: PPUSH
19303: LD_INT 1
19305: PPUSH
19306: CALL_OW 308
19310: NOT
19311: IFFALSE 19365
// begin if IsIdle ( arscout2 ) then
19313: LD_EXP 77
19317: PPUSH
19318: CALL_OW 316
19322: IFFALSE 19354
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19324: LD_EXP 77
19328: PPUSH
19329: LD_INT 127
19331: PPUSH
19332: LD_INT 135
19334: PPUSH
19335: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 70 , 134 ) ;
19339: LD_EXP 77
19343: PPUSH
19344: LD_INT 70
19346: PPUSH
19347: LD_INT 134
19349: PPUSH
19350: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19354: LD_EXP 77
19358: PPUSH
19359: CALL 21968 0 1
// end ;
19363: GO 19298
// RemoveUnit ( ArScout2 ) ;
19365: LD_EXP 77
19369: PPUSH
19370: CALL_OW 64
// end ;
19374: LD_VAR 0 1
19378: RET
// export function f_arcar3_in ; begin
19379: LD_INT 0
19381: PPUSH
// while not IsInArea ( ArScout3 , exit_area ) do
19382: LD_EXP 78
19386: PPUSH
19387: LD_INT 1
19389: PPUSH
19390: CALL_OW 308
19394: NOT
19395: IFFALSE 19449
// begin if IsIdle ( arscout3 ) then
19397: LD_EXP 78
19401: PPUSH
19402: CALL_OW 316
19406: IFFALSE 19438
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19408: LD_EXP 78
19412: PPUSH
19413: LD_INT 127
19415: PPUSH
19416: LD_INT 135
19418: PPUSH
19419: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 70 , 134 ) ;
19423: LD_EXP 78
19427: PPUSH
19428: LD_INT 70
19430: PPUSH
19431: LD_INT 134
19433: PPUSH
19434: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19438: LD_EXP 78
19442: PPUSH
19443: CALL 21968 0 1
// end ;
19447: GO 19382
// RemoveUnit ( ArScout3 ) ;
19449: LD_EXP 78
19453: PPUSH
19454: CALL_OW 64
// end ;
19458: LD_VAR 0 1
19462: RET
// export function f_arcar1_exit ; begin
19463: LD_INT 0
19465: PPUSH
// while not IsInArea ( ArScout1 , ar_in_area ) do
19466: LD_EXP 76
19470: PPUSH
19471: LD_INT 2
19473: PPUSH
19474: CALL_OW 308
19478: NOT
19479: IFFALSE 19533
// begin if IsIdle ( arscout1 ) then
19481: LD_EXP 76
19485: PPUSH
19486: CALL_OW 316
19490: IFFALSE 19522
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19492: LD_EXP 76
19496: PPUSH
19497: LD_INT 127
19499: PPUSH
19500: LD_INT 135
19502: PPUSH
19503: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 185 , 134 ) ;
19507: LD_EXP 76
19511: PPUSH
19512: LD_INT 185
19514: PPUSH
19515: LD_INT 134
19517: PPUSH
19518: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19522: LD_EXP 76
19526: PPUSH
19527: CALL 21968 0 1
// end ;
19531: GO 19466
// RemoveUnit ( ArScout1 ) ;
19533: LD_EXP 76
19537: PPUSH
19538: CALL_OW 64
// end ;
19542: LD_VAR 0 1
19546: RET
// export function f_arcar2_exit ; begin
19547: LD_INT 0
19549: PPUSH
// while not IsInArea ( ArScout2 , ar_in_area ) do
19550: LD_EXP 77
19554: PPUSH
19555: LD_INT 2
19557: PPUSH
19558: CALL_OW 308
19562: NOT
19563: IFFALSE 19617
// begin if IsIdle ( arscout2 ) then
19565: LD_EXP 77
19569: PPUSH
19570: CALL_OW 316
19574: IFFALSE 19606
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19576: LD_EXP 77
19580: PPUSH
19581: LD_INT 127
19583: PPUSH
19584: LD_INT 135
19586: PPUSH
19587: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 185 , 134 ) ;
19591: LD_EXP 77
19595: PPUSH
19596: LD_INT 185
19598: PPUSH
19599: LD_INT 134
19601: PPUSH
19602: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19606: LD_EXP 77
19610: PPUSH
19611: CALL 21968 0 1
// end ;
19615: GO 19550
// RemoveUnit ( ArScout2 ) ;
19617: LD_EXP 77
19621: PPUSH
19622: CALL_OW 64
// end ;
19626: LD_VAR 0 1
19630: RET
// export function f_arcar3_exit ; begin
19631: LD_INT 0
19633: PPUSH
// while not IsInArea ( ArScout3 , ar_in_area ) do
19634: LD_EXP 78
19638: PPUSH
19639: LD_INT 2
19641: PPUSH
19642: CALL_OW 308
19646: NOT
19647: IFFALSE 19701
// begin if IsIdle ( arscout3 ) then
19649: LD_EXP 78
19653: PPUSH
19654: CALL_OW 316
19658: IFFALSE 19690
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19660: LD_EXP 78
19664: PPUSH
19665: LD_INT 127
19667: PPUSH
19668: LD_INT 135
19670: PPUSH
19671: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 185 , 134 ) ;
19675: LD_EXP 78
19679: PPUSH
19680: LD_INT 185
19682: PPUSH
19683: LD_INT 134
19685: PPUSH
19686: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19690: LD_EXP 78
19694: PPUSH
19695: CALL 21968 0 1
// end ;
19699: GO 19634
// RemoveUnit ( ArScout3 ) ;
19701: LD_EXP 78
19705: PPUSH
19706: CALL_OW 64
// end ;
19710: LD_VAR 0 1
19714: RET
// export ArScout1 , ArScout2 , ArScout3 , ArSc1 , ArSc2 , ArSc3 ; export function create_arabs_scout ; begin
19715: LD_INT 0
19717: PPUSH
// InitUc ;
19718: CALL_OW 18
// InitVc ;
19722: CALL_OW 20
// uc_side := arabians ;
19726: LD_ADDR_OWVAR 20
19730: PUSH
19731: LD_EXP 3
19735: ST_TO_ADDR
// uc_nation := nation_arabian ;
19736: LD_ADDR_OWVAR 21
19740: PUSH
19741: LD_INT 2
19743: ST_TO_ADDR
// uc_direction := 4 ;
19744: LD_ADDR_OWVAR 24
19748: PUSH
19749: LD_INT 4
19751: ST_TO_ADDR
// vc_control := control_manual ;
19752: LD_ADDR_OWVAR 38
19756: PUSH
19757: LD_INT 1
19759: ST_TO_ADDR
// vc_engine := engine_combustion ;
19760: LD_ADDR_OWVAR 39
19764: PUSH
19765: LD_INT 1
19767: ST_TO_ADDR
// vc_fuel_battery := 100 ;
19768: LD_ADDR_OWVAR 41
19772: PUSH
19773: LD_INT 100
19775: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19776: LD_ADDR_OWVAR 37
19780: PUSH
19781: LD_INT 14
19783: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
19784: LD_ADDR_OWVAR 40
19788: PUSH
19789: LD_INT 26
19791: ST_TO_ADDR
// if not ArScout1 or IsDead ( ArScout1 ) then
19792: LD_EXP 76
19796: NOT
19797: PUSH
19798: LD_EXP 76
19802: PPUSH
19803: CALL_OW 301
19807: OR
19808: IFFALSE 19820
// ArScout1 := CreateVehicle ;
19810: LD_ADDR_EXP 76
19814: PUSH
19815: CALL_OW 45
19819: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19820: LD_ADDR_OWVAR 37
19824: PUSH
19825: LD_INT 14
19827: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
19828: LD_ADDR_OWVAR 40
19832: PUSH
19833: LD_INT 25
19835: ST_TO_ADDR
// if not ArScout2 or IsDead ( ArScout2 ) then
19836: LD_EXP 77
19840: NOT
19841: PUSH
19842: LD_EXP 77
19846: PPUSH
19847: CALL_OW 301
19851: OR
19852: IFFALSE 19864
// ArScout2 := CreateVehicle ;
19854: LD_ADDR_EXP 77
19858: PUSH
19859: CALL_OW 45
19863: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19864: LD_ADDR_OWVAR 37
19868: PUSH
19869: LD_INT 14
19871: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
19872: LD_ADDR_OWVAR 40
19876: PUSH
19877: LD_INT 25
19879: ST_TO_ADDR
// if not ArScout3 or IsDead ( ArScout3 ) then
19880: LD_EXP 78
19884: NOT
19885: PUSH
19886: LD_EXP 78
19890: PPUSH
19891: CALL_OW 301
19895: OR
19896: IFFALSE 19908
// ArScout3 := CreateVehicle ;
19898: LD_ADDR_EXP 78
19902: PUSH
19903: CALL_OW 45
19907: ST_TO_ADDR
// InitHc ;
19908: CALL_OW 19
// PrepareMechanic ( 0 , 5 ) ;
19912: LD_INT 0
19914: PPUSH
19915: LD_INT 5
19917: PPUSH
19918: CALL_OW 383
// if not ArSc1 or IsDead ( ArSc1 ) then
19922: LD_EXP 79
19926: NOT
19927: PUSH
19928: LD_EXP 79
19932: PPUSH
19933: CALL_OW 301
19937: OR
19938: IFFALSE 19950
// ArSc1 := CreateHuman ;
19940: LD_ADDR_EXP 79
19944: PUSH
19945: CALL_OW 44
19949: ST_TO_ADDR
// if not ArSc2 or IsDead ( ArSc2 ) then
19950: LD_EXP 80
19954: NOT
19955: PUSH
19956: LD_EXP 80
19960: PPUSH
19961: CALL_OW 301
19965: OR
19966: IFFALSE 19978
// ArSc2 := CreateHuman ;
19968: LD_ADDR_EXP 80
19972: PUSH
19973: CALL_OW 44
19977: ST_TO_ADDR
// if not ArSc3 or IsDead ( ArSc3 ) then
19978: LD_EXP 81
19982: NOT
19983: PUSH
19984: LD_EXP 81
19988: PPUSH
19989: CALL_OW 301
19993: OR
19994: IFFALSE 20006
// ArSc3 := CreateHuman ;
19996: LD_ADDR_EXP 81
20000: PUSH
20001: CALL_OW 44
20005: ST_TO_ADDR
// PlaceHumanInUnit ( ArSc1 , ArScout1 ) ;
20006: LD_EXP 79
20010: PPUSH
20011: LD_EXP 76
20015: PPUSH
20016: CALL_OW 52
// PlaceHumanInUnit ( ArSc2 , ArScout2 ) ;
20020: LD_EXP 80
20024: PPUSH
20025: LD_EXP 77
20029: PPUSH
20030: CALL_OW 52
// PlaceHumanInUnit ( ArSc3 , ArScout3 ) ;
20034: LD_EXP 81
20038: PPUSH
20039: LD_EXP 78
20043: PPUSH
20044: CALL_OW 52
// end ; end_of_file
20048: LD_VAR 0 1
20052: RET
// on UnitDestroyed ( un ) do begin if un in rulive then
20053: LD_VAR 0 1
20057: PUSH
20058: LD_EXP 6
20062: IN
20063: IFFALSE 20081
// rulive := rulive diff un ;
20065: LD_ADDR_EXP 6
20069: PUSH
20070: LD_EXP 6
20074: PUSH
20075: LD_VAR 0 1
20079: DIFF
20080: ST_TO_ADDR
// if un in apemans then
20081: LD_VAR 0 1
20085: PUSH
20086: LD_EXP 7
20090: IN
20091: IFFALSE 20109
// apemans := apemans diff un ;
20093: LD_ADDR_EXP 7
20097: PUSH
20098: LD_EXP 7
20102: PUSH
20103: LD_VAR 0 1
20107: DIFF
20108: ST_TO_ADDR
// if un = Burlak then
20109: LD_VAR 0 1
20113: PUSH
20114: LD_EXP 50
20118: EQUAL
20119: IFFALSE 20134
// if canlost then
20121: LD_EXP 47
20125: IFFALSE 20134
// YouLost ( Burlak ) ;
20127: LD_STRING Burlak
20129: PPUSH
20130: CALL_OW 104
// if un = depot then
20134: LD_VAR 0 1
20138: PUSH
20139: LD_EXP 14
20143: EQUAL
20144: IFFALSE 20154
// depot := 0 ;
20146: LD_ADDR_EXP 14
20150: PUSH
20151: LD_INT 0
20153: ST_TO_ADDR
// defence := defence diff un ;
20154: LD_ADDR_EXP 28
20158: PUSH
20159: LD_EXP 28
20163: PUSH
20164: LD_VAR 0 1
20168: DIFF
20169: ST_TO_ADDR
// cargo := cargo diff un ;
20170: LD_ADDR_EXP 25
20174: PUSH
20175: LD_EXP 25
20179: PUSH
20180: LD_VAR 0 1
20184: DIFF
20185: ST_TO_ADDR
// attack := attack diff un ;
20186: LD_ADDR_EXP 27
20190: PUSH
20191: LD_EXP 27
20195: PUSH
20196: LD_VAR 0 1
20200: DIFF
20201: ST_TO_ADDR
// scout := scout diff un ;
20202: LD_ADDR_EXP 26
20206: PUSH
20207: LD_EXP 26
20211: PUSH
20212: LD_VAR 0 1
20216: DIFF
20217: ST_TO_ADDR
// remote := remote diff un ;
20218: LD_ADDR_EXP 29
20222: PUSH
20223: LD_EXP 29
20227: PUSH
20228: LD_VAR 0 1
20232: DIFF
20233: ST_TO_ADDR
// brk_cars := brk_cars diff un ;
20234: LD_ADDR_EXP 74
20238: PUSH
20239: LD_EXP 74
20243: PUSH
20244: LD_VAR 0 1
20248: DIFF
20249: ST_TO_ADDR
// rep_cars := rep_cars diff un ;
20250: LD_ADDR_EXP 75
20254: PUSH
20255: LD_EXP 75
20259: PUSH
20260: LD_VAR 0 1
20264: DIFF
20265: ST_TO_ADDR
// opravit := opravit diff un ;
20266: LD_ADDR_EXP 73
20270: PUSH
20271: LD_EXP 73
20275: PUSH
20276: LD_VAR 0 1
20280: DIFF
20281: ST_TO_ADDR
// sol := sol diff un ;
20282: LD_ADDR_EXP 19
20286: PUSH
20287: LD_EXP 19
20291: PUSH
20292: LD_VAR 0 1
20296: DIFF
20297: ST_TO_ADDR
// eng := eng diff un ;
20298: LD_ADDR_EXP 23
20302: PUSH
20303: LD_EXP 23
20307: PUSH
20308: LD_VAR 0 1
20312: DIFF
20313: ST_TO_ADDR
// mec := mec diff un ;
20314: LD_ADDR_EXP 22
20318: PUSH
20319: LD_EXP 22
20323: PUSH
20324: LD_VAR 0 1
20328: DIFF
20329: ST_TO_ADDR
// sci := sci diff un ;
20330: LD_ADDR_EXP 21
20334: PUSH
20335: LD_EXP 21
20339: PUSH
20340: LD_VAR 0 1
20344: DIFF
20345: ST_TO_ADDR
// mor := mor diff un ;
20346: LD_ADDR_EXP 20
20350: PUSH
20351: LD_EXP 20
20355: PUSH
20356: LD_VAR 0 1
20360: DIFF
20361: ST_TO_ADDR
// case un of dep1 :
20362: LD_VAR 0 1
20366: PUSH
20367: LD_EXP 41
20371: DOUBLE
20372: EQUAL
20373: IFTRUE 20377
20375: GO 20388
20377: POP
// dep1 := 0 ; lab1 :
20378: LD_ADDR_EXP 41
20382: PUSH
20383: LD_INT 0
20385: ST_TO_ADDR
20386: GO 20431
20388: LD_EXP 42
20392: DOUBLE
20393: EQUAL
20394: IFTRUE 20398
20396: GO 20409
20398: POP
// lab1 := 0 ; fact1 :
20399: LD_ADDR_EXP 42
20403: PUSH
20404: LD_INT 0
20406: ST_TO_ADDR
20407: GO 20431
20409: LD_EXP 40
20413: DOUBLE
20414: EQUAL
20415: IFTRUE 20419
20417: GO 20430
20419: POP
// fact1 := 0 ; end ;
20420: LD_ADDR_EXP 40
20424: PUSH
20425: LD_INT 0
20427: ST_TO_ADDR
20428: GO 20431
20430: POP
// fort := fort diff un ;
20431: LD_ADDR_EXP 43
20435: PUSH
20436: LD_EXP 43
20440: PUSH
20441: LD_VAR 0 1
20445: DIFF
20446: ST_TO_ADDR
// end ;
20447: PPOPN 1
20449: END
// on ApemanTamed ( ape , sci ) do begin MyHint ( ApemenUsing ) ;
20450: LD_STRING ApemenUsing
20452: PPUSH
20453: CALL 25431 0 1
// apemans := apemans diff ape ;
20457: LD_ADDR_EXP 7
20461: PUSH
20462: LD_EXP 7
20466: PUSH
20467: LD_VAR 0 1
20471: DIFF
20472: ST_TO_ADDR
// if not first_apeman_tamed then
20473: LD_EXP 45
20477: NOT
20478: IFFALSE 20484
// DApeTame ;
20480: CALL 4659 0 0
// end ;
20484: PPOPN 2
20486: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = you then
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL_OW 255
20496: PUSH
20497: LD_EXP 1
20501: EQUAL
20502: IFFALSE 20571
// begin if tech = tech_ApeLang then
20504: LD_VAR 0 1
20508: PUSH
20509: LD_INT 1
20511: EQUAL
20512: IFFALSE 20531
// begin MyHint ( ApemenTaming ) ;
20514: LD_STRING ApemenTaming
20516: PPUSH
20517: CALL 25431 0 1
// if dialogy then
20521: LD_EXP 46
20525: IFFALSE 20531
// DApeLangCompl ;
20527: CALL 4494 0 0
// end ; if tech = tech_ApePsych then
20531: LD_VAR 0 1
20535: PUSH
20536: LD_INT 2
20538: EQUAL
20539: IFFALSE 20551
// begin if dialogy then
20541: LD_EXP 46
20545: IFFALSE 20551
// DApeWorkCompl ;
20547: CALL 5053 0 0
// end ; if tech = tech_ApeAgres then
20551: LD_VAR 0 1
20555: PUSH
20556: LD_INT 11
20558: EQUAL
20559: IFFALSE 20571
// begin if dialogy then
20561: LD_EXP 46
20565: IFFALSE 20571
// DApeSolCompl ;
20567: CALL 5161 0 0
// end ; end ; end ;
20571: PPOPN 2
20573: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
20574: LD_VAR 0 1
20578: PPUSH
20579: CALL_OW 255
20583: PUSH
20584: LD_EXP 1
20588: EQUAL
20589: IFFALSE 20625
// begin if not depot and GetBType ( build ) = b_depot then
20591: LD_EXP 14
20595: NOT
20596: PUSH
20597: LD_VAR 0 1
20601: PPUSH
20602: CALL_OW 266
20606: PUSH
20607: LD_INT 0
20609: EQUAL
20610: AND
20611: IFFALSE 20623
// depot := build ;
20613: LD_ADDR_EXP 14
20617: PUSH
20618: LD_VAR 0 1
20622: ST_TO_ADDR
// end else
20623: GO 20786
// begin if GetBType ( build ) in [ b_depot , b_warehouse ] then
20625: LD_VAR 0 1
20629: PPUSH
20630: CALL_OW 266
20634: PUSH
20635: LD_INT 0
20637: PUSH
20638: LD_INT 1
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: IN
20645: IFFALSE 20661
// dep1 := build + 0 ;
20647: LD_ADDR_EXP 41
20651: PUSH
20652: LD_VAR 0 1
20656: PUSH
20657: LD_INT 0
20659: PLUS
20660: ST_TO_ADDR
// if GetBType ( build ) in [ b_workshop , b_factory ] then
20661: LD_VAR 0 1
20665: PPUSH
20666: CALL_OW 266
20670: PUSH
20671: LD_INT 2
20673: PUSH
20674: LD_INT 3
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: IN
20681: IFFALSE 20697
// fact1 := build + 0 ;
20683: LD_ADDR_EXP 40
20687: PUSH
20688: LD_VAR 0 1
20692: PUSH
20693: LD_INT 0
20695: PLUS
20696: ST_TO_ADDR
// if GetBType ( build ) in [ b_lab , b_lab_half , b_lab_full ] then
20697: LD_VAR 0 1
20701: PPUSH
20702: CALL_OW 266
20706: PUSH
20707: LD_INT 6
20709: PUSH
20710: LD_INT 7
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: EMPTY
20717: LIST
20718: LIST
20719: LIST
20720: IN
20721: IFFALSE 20737
// lab1 := build + 0 ;
20723: LD_ADDR_EXP 42
20727: PUSH
20728: LD_VAR 0 1
20732: PUSH
20733: LD_INT 0
20735: PLUS
20736: ST_TO_ADDR
// if GetBType ( build ) in [ b_breastwork , b_bunker , b_armoury , b_barracks ] then
20737: LD_VAR 0 1
20741: PPUSH
20742: CALL_OW 266
20746: PUSH
20747: LD_INT 31
20749: PUSH
20750: LD_INT 32
20752: PUSH
20753: LD_INT 4
20755: PUSH
20756: LD_INT 5
20758: PUSH
20759: EMPTY
20760: LIST
20761: LIST
20762: LIST
20763: LIST
20764: IN
20765: IFFALSE 20786
// fort := fort ^ [ build ] ;
20767: LD_ADDR_EXP 43
20771: PUSH
20772: LD_EXP 43
20776: PUSH
20777: LD_VAR 0 1
20781: PUSH
20782: EMPTY
20783: LIST
20784: ADD
20785: ST_TO_ADDR
// end ; end ;
20786: PPOPN 1
20788: END
// on UpgradeComplete ( build ) do var ar , i ;
20789: LD_INT 0
20791: PPUSH
20792: PPUSH
// begin if GetSide ( build ) = arabians then
20793: LD_VAR 0 1
20797: PPUSH
20798: CALL_OW 255
20802: PUSH
20803: LD_EXP 3
20807: EQUAL
20808: IFFALSE 20946
// begin if GetBType ( build ) = b_barracks then
20810: LD_VAR 0 1
20814: PPUSH
20815: CALL_OW 266
20819: PUSH
20820: LD_INT 5
20822: EQUAL
20823: IFFALSE 20946
// begin sol := sol diff ar ;
20825: LD_ADDR_EXP 19
20829: PUSH
20830: LD_EXP 19
20834: PUSH
20835: LD_VAR 0 2
20839: DIFF
20840: ST_TO_ADDR
// mor := mor diff ar ;
20841: LD_ADDR_EXP 20
20845: PUSH
20846: LD_EXP 20
20850: PUSH
20851: LD_VAR 0 2
20855: DIFF
20856: ST_TO_ADDR
// for i in fort do
20857: LD_ADDR_VAR 0 3
20861: PUSH
20862: LD_EXP 43
20866: PUSH
20867: FOR_IN
20868: IFFALSE 20893
// ar := ar ^ UnitsInside ( i ) ;
20870: LD_ADDR_VAR 0 2
20874: PUSH
20875: LD_VAR 0 2
20879: PUSH
20880: LD_VAR 0 3
20884: PPUSH
20885: CALL_OW 313
20889: ADD
20890: ST_TO_ADDR
20891: GO 20867
20893: POP
20894: POP
// ComEnterUnit ( ar , build ) ;
20895: LD_VAR 0 2
20899: PPUSH
20900: LD_VAR 0 1
20904: PPUSH
20905: CALL_OW 120
// AddComChangeProfession ( ar , class_mortar ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_INT 8
20916: PPUSH
20917: CALL_OW 183
// AddComExitBuilding ( ar ) ;
20921: LD_VAR 0 2
20925: PPUSH
20926: CALL_OW 182
// sol := sol union ar ;
20930: LD_ADDR_EXP 19
20934: PUSH
20935: LD_EXP 19
20939: PUSH
20940: LD_VAR 0 2
20944: UNION
20945: ST_TO_ADDR
// end ; end ; if Getside ( build ) = you then
20946: LD_VAR 0 1
20950: PPUSH
20951: CALL_OW 255
20955: PUSH
20956: LD_EXP 1
20960: EQUAL
20961: IFFALSE 20985
// begin if GetBType ( build ) = b_factory then
20963: LD_VAR 0 1
20967: PPUSH
20968: CALL_OW 266
20972: PUSH
20973: LD_INT 3
20975: EQUAL
20976: IFFALSE 20985
// begin MyHint ( Tracks ) ;
20978: LD_STRING Tracks
20980: PPUSH
20981: CALL 25431 0 1
// end ; end ; end ;
20985: PPOPN 3
20987: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = arabians then
20988: LD_VAR 0 3
20992: PUSH
20993: LD_EXP 3
20997: EQUAL
20998: IFFALSE 21112
// begin defence := defence diff vehold ;
21000: LD_ADDR_EXP 28
21004: PUSH
21005: LD_EXP 28
21009: PUSH
21010: LD_VAR 0 2
21014: DIFF
21015: ST_TO_ADDR
// cargo := cargo diff vehold ;
21016: LD_ADDR_EXP 25
21020: PUSH
21021: LD_EXP 25
21025: PUSH
21026: LD_VAR 0 2
21030: DIFF
21031: ST_TO_ADDR
// attack := attack diff vehold ;
21032: LD_ADDR_EXP 27
21036: PUSH
21037: LD_EXP 27
21041: PUSH
21042: LD_VAR 0 2
21046: DIFF
21047: ST_TO_ADDR
// scout := scout diff vehold ;
21048: LD_ADDR_EXP 26
21052: PUSH
21053: LD_EXP 26
21057: PUSH
21058: LD_VAR 0 2
21062: DIFF
21063: ST_TO_ADDR
// remote := remote diff vehold ;
21064: LD_ADDR_EXP 29
21068: PUSH
21069: LD_EXP 29
21073: PUSH
21074: LD_VAR 0 2
21078: DIFF
21079: ST_TO_ADDR
// brk_cars := brk_cars diff vehold ;
21080: LD_ADDR_EXP 74
21084: PUSH
21085: LD_EXP 74
21089: PUSH
21090: LD_VAR 0 2
21094: DIFF
21095: ST_TO_ADDR
// rep_cars := rep_cars diff vehold ;
21096: LD_ADDR_EXP 75
21100: PUSH
21101: LD_EXP 75
21105: PUSH
21106: LD_VAR 0 2
21110: DIFF
21111: ST_TO_ADDR
// end ; end ;
21112: PPOPN 4
21114: END
// on BuildingCaptured ( build , origside , eng ) do begin opravit := opravit diff build ;
21115: LD_ADDR_EXP 73
21119: PUSH
21120: LD_EXP 73
21124: PUSH
21125: LD_VAR 0 1
21129: DIFF
21130: ST_TO_ADDR
// case build of dep1 :
21131: LD_VAR 0 1
21135: PUSH
21136: LD_EXP 41
21140: DOUBLE
21141: EQUAL
21142: IFTRUE 21146
21144: GO 21157
21146: POP
// dep1 := 0 ; lab1 :
21147: LD_ADDR_EXP 41
21151: PUSH
21152: LD_INT 0
21154: ST_TO_ADDR
21155: GO 21200
21157: LD_EXP 42
21161: DOUBLE
21162: EQUAL
21163: IFTRUE 21167
21165: GO 21178
21167: POP
// lab1 := 0 ; fact1 :
21168: LD_ADDR_EXP 42
21172: PUSH
21173: LD_INT 0
21175: ST_TO_ADDR
21176: GO 21200
21178: LD_EXP 40
21182: DOUBLE
21183: EQUAL
21184: IFTRUE 21188
21186: GO 21199
21188: POP
// fact1 := 0 ; end ;
21189: LD_ADDR_EXP 40
21193: PUSH
21194: LD_INT 0
21196: ST_TO_ADDR
21197: GO 21200
21199: POP
// fort := fort diff build ;
21200: LD_ADDR_EXP 43
21204: PUSH
21205: LD_EXP 43
21209: PUSH
21210: LD_VAR 0 1
21214: DIFF
21215: ST_TO_ADDR
// end ;
21216: PPOPN 3
21218: END
// on VehicleConstructed ( veh , fact ) do var i , sc , a , mt ;
21219: LD_INT 0
21221: PPUSH
21222: PPUSH
21223: PPUSH
21224: PPUSH
// begin if GetSide ( fact ) = arabians then
21225: LD_VAR 0 2
21229: PPUSH
21230: CALL_OW 255
21234: PUSH
21235: LD_EXP 3
21239: EQUAL
21240: IFFALSE 21643
// begin if to_defence then
21242: LD_EXP 30
21246: IFFALSE 21264
// begin defence := defence union veh ;
21248: LD_ADDR_EXP 28
21252: PUSH
21253: LD_EXP 28
21257: PUSH
21258: LD_VAR 0 1
21262: UNION
21263: ST_TO_ADDR
// end ; if to_remote then
21264: LD_EXP 34
21268: IFFALSE 21286
// begin remote := remote union veh ;
21270: LD_ADDR_EXP 29
21274: PUSH
21275: LD_EXP 29
21279: PUSH
21280: LD_VAR 0 1
21284: UNION
21285: ST_TO_ADDR
// end ; if to_cargo then
21286: LD_EXP 33
21290: IFFALSE 21308
// begin cargo := cargo union veh ;
21292: LD_ADDR_EXP 25
21296: PUSH
21297: LD_EXP 25
21301: PUSH
21302: LD_VAR 0 1
21306: UNION
21307: ST_TO_ADDR
// end ; if to_attack then
21308: LD_EXP 31
21312: IFFALSE 21330
// begin attack := attack union veh ;
21314: LD_ADDR_EXP 27
21318: PUSH
21319: LD_EXP 27
21323: PUSH
21324: LD_VAR 0 1
21328: UNION
21329: ST_TO_ADDR
// end ; if to_scout then
21330: LD_EXP 32
21334: IFFALSE 21352
// begin scout := scout union veh ;
21336: LD_ADDR_EXP 26
21340: PUSH
21341: LD_EXP 26
21345: PUSH
21346: LD_VAR 0 1
21350: UNION
21351: ST_TO_ADDR
// end ; to_remote := false ;
21352: LD_ADDR_EXP 34
21356: PUSH
21357: LD_INT 0
21359: ST_TO_ADDR
// to_cargo := false ;
21360: LD_ADDR_EXP 33
21364: PUSH
21365: LD_INT 0
21367: ST_TO_ADDR
// to_scout := false ;
21368: LD_ADDR_EXP 32
21372: PUSH
21373: LD_INT 0
21375: ST_TO_ADDR
// to_attack := false ;
21376: LD_ADDR_EXP 31
21380: PUSH
21381: LD_INT 0
21383: ST_TO_ADDR
// to_defence := false ;
21384: LD_ADDR_EXP 30
21388: PUSH
21389: LD_INT 0
21391: ST_TO_ADDR
// if GetControl ( veh ) = control_remote then
21392: LD_VAR 0 1
21396: PPUSH
21397: CALL_OW 263
21401: PUSH
21402: LD_INT 2
21404: EQUAL
21405: IFFALSE 21421
// ComLinkTo ( veh , rmec ) ;
21407: LD_VAR 0 1
21411: PPUSH
21412: LD_EXP 24
21416: PPUSH
21417: CALL_OW 135
// mt := tick + 0 0$7 ;
21421: LD_ADDR_VAR 0 6
21425: PUSH
21426: LD_OWVAR 1
21430: PUSH
21431: LD_INT 245
21433: PLUS
21434: ST_TO_ADDR
// if veh in defence then
21435: LD_VAR 0 1
21439: PUSH
21440: LD_EXP 28
21444: IN
21445: IFFALSE 21497
// begin ComMoveToArea ( veh , for_cars_defence ) ;
21447: LD_VAR 0 1
21451: PPUSH
21452: LD_INT 17
21454: PPUSH
21455: CALL_OW 113
// while not IsInArea ( veh , for_cars_defence ) and mt > tick do
21459: LD_VAR 0 1
21463: PPUSH
21464: LD_INT 17
21466: PPUSH
21467: CALL_OW 308
21471: NOT
21472: PUSH
21473: LD_VAR 0 6
21477: PUSH
21478: LD_OWVAR 1
21482: GREATER
21483: AND
21484: IFFALSE 21495
// wait ( 0 0$1 ) ;
21486: LD_INT 35
21488: PPUSH
21489: CALL_OW 67
21493: GO 21459
// end else
21495: GO 21545
// begin ComMoveToArea ( veh , for_cars ) ;
21497: LD_VAR 0 1
21501: PPUSH
21502: LD_INT 14
21504: PPUSH
21505: CALL_OW 113
// while not IsInArea ( veh , for_cars ) and mt > tick do
21509: LD_VAR 0 1
21513: PPUSH
21514: LD_INT 14
21516: PPUSH
21517: CALL_OW 308
21521: NOT
21522: PUSH
21523: LD_VAR 0 6
21527: PUSH
21528: LD_OWVAR 1
21532: GREATER
21533: AND
21534: IFFALSE 21545
// wait ( 0 0$1 ) ;
21536: LD_INT 35
21538: PPUSH
21539: CALL_OW 67
21543: GO 21509
// end ; a := UnitsInside ( veh ) ;
21545: LD_ADDR_VAR 0 5
21549: PUSH
21550: LD_VAR 0 1
21554: PPUSH
21555: CALL_OW 313
21559: ST_TO_ADDR
// ComRemember ( veh ) ;
21560: LD_VAR 0 1
21564: PPUSH
21565: CALL_OW 143
// ComExitVehicle ( a ) ;
21569: LD_VAR 0 5
21573: PPUSH
21574: CALL_OW 121
// AddComEnterUnit ( a , fact1 ) ;
21578: LD_VAR 0 5
21582: PPUSH
21583: LD_EXP 40
21587: PPUSH
21588: CALL_OW 180
// if GetWeapon ( veh ) <> ar_radar then
21592: LD_VAR 0 1
21596: PPUSH
21597: CALL_OW 264
21601: PUSH
21602: LD_INT 30
21604: NONEQUAL
21605: IFFALSE 21626
// find_drivers ( veh , sol , false ) else
21607: LD_VAR 0 1
21611: PPUSH
21612: LD_EXP 19
21616: PPUSH
21617: LD_INT 0
21619: PPUSH
21620: CALL 23939 0 3
21624: GO 21643
// find_drivers ( veh , mec , true ) ;
21626: LD_VAR 0 1
21630: PPUSH
21631: LD_EXP 22
21635: PPUSH
21636: LD_INT 1
21638: PPUSH
21639: CALL 23939 0 3
// end ; end ;
21643: PPOPN 6
21645: END
// on SailEvent ( num ) do begin case num of vodni_utok :
21646: LD_VAR 0 1
21650: PUSH
21651: LD_EXP 35
21655: DOUBLE
21656: EQUAL
21657: IFTRUE 21661
21659: GO 21668
21661: POP
// begin f_vodni_utok ;
21662: CALL 15875 0 0
// end ; normal1_utok :
21666: GO 21827
21668: LD_EXP 36
21672: DOUBLE
21673: EQUAL
21674: IFTRUE 21678
21676: GO 21685
21678: POP
// begin f_normal1_utok ;
21679: CALL 16265 0 0
// end ; normal2_utok :
21683: GO 21827
21685: LD_EXP 37
21689: DOUBLE
21690: EQUAL
21691: IFTRUE 21695
21693: GO 21702
21695: POP
// begin f_normal2_utok ;
21696: CALL 16501 0 0
// end ; normal3_utok :
21700: GO 21827
21702: LD_EXP 38
21706: DOUBLE
21707: EQUAL
21708: IFTRUE 21712
21710: GO 21719
21712: POP
// begin f_normal3_utok ;
21713: CALL 16737 0 0
// end ; normal4_utok :
21717: GO 21827
21719: LD_EXP 39
21723: DOUBLE
21724: EQUAL
21725: IFTRUE 21729
21727: GO 21736
21729: POP
// begin f_normal4_utok ;
21730: CALL 17094 0 0
// end ; 5001 :
21734: GO 21827
21736: LD_INT 5001
21738: DOUBLE
21739: EQUAL
21740: IFTRUE 21744
21742: GO 21751
21744: POP
// begin f_arcar1_in ;
21745: CALL 19211 0 0
// end ; 5002 :
21749: GO 21827
21751: LD_INT 5002
21753: DOUBLE
21754: EQUAL
21755: IFTRUE 21759
21757: GO 21766
21759: POP
// begin f_arcar2_in ;
21760: CALL 19295 0 0
// end ; 5003 :
21764: GO 21827
21766: LD_INT 5003
21768: DOUBLE
21769: EQUAL
21770: IFTRUE 21774
21772: GO 21781
21774: POP
// begin f_arcar3_in ;
21775: CALL 19379 0 0
// end ; 5051 :
21779: GO 21827
21781: LD_INT 5051
21783: DOUBLE
21784: EQUAL
21785: IFTRUE 21789
21787: GO 21796
21789: POP
// begin f_arcar1_exit ;
21790: CALL 19463 0 0
// end ; 5052 :
21794: GO 21827
21796: LD_INT 5052
21798: DOUBLE
21799: EQUAL
21800: IFTRUE 21804
21802: GO 21811
21804: POP
// begin f_arcar2_exit ;
21805: CALL 19547 0 0
// end ; 5053 :
21809: GO 21827
21811: LD_INT 5053
21813: DOUBLE
21814: EQUAL
21815: IFTRUE 21819
21817: GO 21826
21819: POP
// begin f_arcar3_exit ;
21820: CALL 19631 0 0
// end ; end ;
21824: GO 21827
21826: POP
// end ;
21827: PPOPN 1
21829: END
// export DU_units ; on DestinationUnreachable ( un ) do begin DU_units := DU_units union un ;
21830: LD_ADDR_EXP 82
21834: PUSH
21835: LD_EXP 82
21839: PUSH
21840: LD_VAR 0 1
21844: UNION
21845: ST_TO_ADDR
// SetTag ( un + 10000 , 2 ) ;
21846: LD_VAR 0 1
21850: PUSH
21851: LD_INT 10000
21853: PLUS
21854: PPUSH
21855: LD_INT 2
21857: PPUSH
21858: CALL_OW 109
// end ;
21862: PPOPN 1
21864: END
// every 0 0$2 trigger DU_units do var i , a ;
21865: LD_EXP 82
21869: IFFALSE 21965
21871: GO 21873
21873: DISABLE
21874: LD_INT 0
21876: PPUSH
21877: PPUSH
// begin for i in DU_units do
21878: LD_ADDR_VAR 0 1
21882: PUSH
21883: LD_EXP 82
21887: PUSH
21888: FOR_IN
21889: IFFALSE 21962
// begin a := GetTag ( i + 10000 ) ;
21891: LD_ADDR_VAR 0 2
21895: PUSH
21896: LD_VAR 0 1
21900: PUSH
21901: LD_INT 10000
21903: PLUS
21904: PPUSH
21905: CALL_OW 110
21909: ST_TO_ADDR
// if a = 0 then
21910: LD_VAR 0 2
21914: PUSH
21915: LD_INT 0
21917: EQUAL
21918: IFFALSE 21938
// DU_units := DU_units diff i else
21920: LD_ADDR_EXP 82
21924: PUSH
21925: LD_EXP 82
21929: PUSH
21930: LD_VAR 0 1
21934: DIFF
21935: ST_TO_ADDR
21936: GO 21960
// SetTag ( i + 10000 , a - 1 ) ;
21938: LD_VAR 0 1
21942: PUSH
21943: LD_INT 10000
21945: PLUS
21946: PPUSH
21947: LD_VAR 0 2
21951: PUSH
21952: LD_INT 1
21954: MINUS
21955: PPUSH
21956: CALL_OW 109
// end ;
21960: GO 21888
21962: POP
21963: POP
// enable ;
21964: ENABLE
// end ;
21965: PPOPN 2
21967: END
// export function DU_wait ( un ) ; begin
21968: LD_INT 0
21970: PPUSH
// wait ( 0 0$1 ) ;
21971: LD_INT 35
21973: PPUSH
21974: CALL_OW 67
// while un in DU_units do
21978: LD_VAR 0 1
21982: PUSH
21983: LD_EXP 82
21987: IN
21988: IFFALSE 21999
// wait ( 0 0$1 ) ;
21990: LD_INT 35
21992: PPUSH
21993: CALL_OW 67
21997: GO 21978
// end ; end_of_file
21999: LD_VAR 0 2
22003: RET
// var rDef1 , rDef2 ; var idDef1 , idDef2 ; export toDef1 , toDef2 ; every 0 0$1 do
22004: GO 22006
22006: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ^ sci ^ mec ^ eng ;
22007: LD_ADDR_EXP 83
22011: PUSH
22012: LD_EXP 43
22016: PUSH
22017: LD_EXP 27
22021: ADD
22022: PUSH
22023: LD_EXP 28
22027: ADD
22028: PUSH
22029: LD_EXP 20
22033: ADD
22034: PUSH
22035: LD_EXP 19
22039: ADD
22040: PUSH
22041: LD_EXP 21
22045: ADD
22046: PUSH
22047: LD_EXP 22
22051: ADD
22052: PUSH
22053: LD_EXP 23
22057: ADD
22058: ST_TO_ADDR
// rDef1 := McRegistry ( arabians , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , def_base ] , [ mc_reg_area_to_protect , def_base ] ] ) ;
22059: LD_ADDR_LOC 28
22063: PUSH
22064: LD_EXP 3
22068: PPUSH
22069: LD_INT 1
22071: PUSH
22072: LD_INT 70
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 2
22081: PUSH
22082: LD_INT 23
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PUSH
22089: LD_INT 3
22091: PUSH
22092: LD_INT 23
22094: PUSH
22095: EMPTY
22096: LIST
22097: LIST
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: PPUSH
22104: CALL_OW 399
22108: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef_difficulty ] ) ;
22109: LD_ADDR_LOC 30
22113: PUSH
22114: LD_INT 10
22116: PPUSH
22117: LD_LOC 28
22121: PPUSH
22122: LD_EXP 83
22126: PPUSH
22127: LD_INT 1
22129: PUSH
22130: LD_EXP 13
22134: PUSH
22135: EMPTY
22136: LIST
22137: LIST
22138: PPUSH
22139: CALL_OW 401
22143: ST_TO_ADDR
// end ;
22144: END
// every 0 0$2 do
22145: GO 22147
22147: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ;
22148: LD_ADDR_EXP 83
22152: PUSH
22153: LD_EXP 43
22157: PUSH
22158: LD_EXP 27
22162: ADD
22163: PUSH
22164: LD_EXP 28
22168: ADD
22169: PUSH
22170: LD_EXP 20
22174: ADD
22175: PUSH
22176: LD_EXP 19
22180: ADD
22181: ST_TO_ADDR
// AddMcUnits ( idDef1 , todef1 diff GetMcUnits ( idDef1 ) ) ;
22182: LD_LOC 30
22186: PPUSH
22187: LD_EXP 83
22191: PUSH
22192: LD_LOC 30
22196: PPUSH
22197: CALL_OW 389
22201: DIFF
22202: PPUSH
22203: CALL_OW 390
// RemoveMcUnits ( idDef1 , GetMcUnits ( idDef1 ) diff todef1 ) ;
22207: LD_LOC 30
22211: PPUSH
22212: LD_LOC 30
22216: PPUSH
22217: CALL_OW 389
22221: PUSH
22222: LD_EXP 83
22226: DIFF
22227: PPUSH
22228: CALL_OW 391
// enable ;
22232: ENABLE
// end ; end_of_file
22233: END
// var objevovani_zasilek ; var ar_objevovani_zasilek ; export crates ; every 0 0$0.1 do
22234: GO 22236
22236: DISABLE
// begin SetResourceVisibility ( 131 , 51 , arabians ) ;
22237: LD_INT 131
22239: PPUSH
22240: LD_INT 51
22242: PPUSH
22243: LD_EXP 3
22247: PPUSH
22248: CALL_OW 441
// case difficulty of 1 :
22252: LD_OWVAR 67
22256: PUSH
22257: LD_INT 1
22259: DOUBLE
22260: EQUAL
22261: IFTRUE 22265
22263: GO 22363
22265: POP
// objevovani_zasilek := [ 3 , 6 , 4 , 4 , 1 , 4 , 2 , 2 , 3 , 5 , 0 , 2 , 3 , 5 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ] ; 2 :
22266: LD_ADDR_LOC 32
22270: PUSH
22271: LD_INT 3
22273: PUSH
22274: LD_INT 6
22276: PUSH
22277: LD_INT 4
22279: PUSH
22280: LD_INT 4
22282: PUSH
22283: LD_INT 1
22285: PUSH
22286: LD_INT 4
22288: PUSH
22289: LD_INT 2
22291: PUSH
22292: LD_INT 2
22294: PUSH
22295: LD_INT 3
22297: PUSH
22298: LD_INT 5
22300: PUSH
22301: LD_INT 0
22303: PUSH
22304: LD_INT 2
22306: PUSH
22307: LD_INT 3
22309: PUSH
22310: LD_INT 5
22312: PUSH
22313: LD_INT 1
22315: PUSH
22316: LD_INT 2
22318: PUSH
22319: LD_INT 1
22321: PUSH
22322: LD_INT 2
22324: PUSH
22325: LD_INT 1
22327: PUSH
22328: LD_INT 2
22330: PUSH
22331: LD_INT 1
22333: PUSH
22334: LD_INT 2
22336: PUSH
22337: EMPTY
22338: LIST
22339: LIST
22340: LIST
22341: LIST
22342: LIST
22343: LIST
22344: LIST
22345: LIST
22346: LIST
22347: LIST
22348: LIST
22349: LIST
22350: LIST
22351: LIST
22352: LIST
22353: LIST
22354: LIST
22355: LIST
22356: LIST
22357: LIST
22358: LIST
22359: LIST
22360: ST_TO_ADDR
22361: GO 22576
22363: LD_INT 2
22365: DOUBLE
22366: EQUAL
22367: IFTRUE 22371
22369: GO 22469
22371: POP
// objevovani_zasilek := [ 2 , 5 , 3 , 2 , 1 , 3 , 2 , 2 , 3 , 4 , 0 , 2 , 3 , 4 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; 3 :
22372: LD_ADDR_LOC 32
22376: PUSH
22377: LD_INT 2
22379: PUSH
22380: LD_INT 5
22382: PUSH
22383: LD_INT 3
22385: PUSH
22386: LD_INT 2
22388: PUSH
22389: LD_INT 1
22391: PUSH
22392: LD_INT 3
22394: PUSH
22395: LD_INT 2
22397: PUSH
22398: LD_INT 2
22400: PUSH
22401: LD_INT 3
22403: PUSH
22404: LD_INT 4
22406: PUSH
22407: LD_INT 0
22409: PUSH
22410: LD_INT 2
22412: PUSH
22413: LD_INT 3
22415: PUSH
22416: LD_INT 4
22418: PUSH
22419: LD_INT 0
22421: PUSH
22422: LD_INT 2
22424: PUSH
22425: LD_INT 0
22427: PUSH
22428: LD_INT 2
22430: PUSH
22431: LD_INT 0
22433: PUSH
22434: LD_INT 2
22436: PUSH
22437: LD_INT 0
22439: PUSH
22440: LD_INT 2
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: ST_TO_ADDR
22467: GO 22576
22469: LD_INT 3
22471: DOUBLE
22472: EQUAL
22473: IFTRUE 22477
22475: GO 22575
22477: POP
// objevovani_zasilek := [ 2 , 4 , 2 , 2 , 0 , 3 , 1 , 2 , 3 , 3 , 0 , 2 , 3 , 2 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; end ;
22478: LD_ADDR_LOC 32
22482: PUSH
22483: LD_INT 2
22485: PUSH
22486: LD_INT 4
22488: PUSH
22489: LD_INT 2
22491: PUSH
22492: LD_INT 2
22494: PUSH
22495: LD_INT 0
22497: PUSH
22498: LD_INT 3
22500: PUSH
22501: LD_INT 1
22503: PUSH
22504: LD_INT 2
22506: PUSH
22507: LD_INT 3
22509: PUSH
22510: LD_INT 3
22512: PUSH
22513: LD_INT 0
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: LD_INT 3
22521: PUSH
22522: LD_INT 2
22524: PUSH
22525: LD_INT 0
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 0
22533: PUSH
22534: LD_INT 2
22536: PUSH
22537: LD_INT 0
22539: PUSH
22540: LD_INT 2
22542: PUSH
22543: LD_INT 0
22545: PUSH
22546: LD_INT 2
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: LIST
22562: LIST
22563: LIST
22564: LIST
22565: LIST
22566: LIST
22567: LIST
22568: LIST
22569: LIST
22570: LIST
22571: LIST
22572: ST_TO_ADDR
22573: GO 22576
22575: POP
// ar_objevovani_zasilek := [ 5 , 6 , 4 , 4 , 2 , 5 , 2 , 4 , 6 , 5 , 2 , 4 , 6 , 5 , 5 , 4 , 5 , 2 , 9 , 8 , 6 , 5 ] ;
22576: LD_ADDR_LOC 33
22580: PUSH
22581: LD_INT 5
22583: PUSH
22584: LD_INT 6
22586: PUSH
22587: LD_INT 4
22589: PUSH
22590: LD_INT 4
22592: PUSH
22593: LD_INT 2
22595: PUSH
22596: LD_INT 5
22598: PUSH
22599: LD_INT 2
22601: PUSH
22602: LD_INT 4
22604: PUSH
22605: LD_INT 6
22607: PUSH
22608: LD_INT 5
22610: PUSH
22611: LD_INT 2
22613: PUSH
22614: LD_INT 4
22616: PUSH
22617: LD_INT 6
22619: PUSH
22620: LD_INT 5
22622: PUSH
22623: LD_INT 5
22625: PUSH
22626: LD_INT 4
22628: PUSH
22629: LD_INT 5
22631: PUSH
22632: LD_INT 2
22634: PUSH
22635: LD_INT 9
22637: PUSH
22638: LD_INT 8
22640: PUSH
22641: LD_INT 6
22643: PUSH
22644: LD_INT 5
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: LIST
22651: LIST
22652: LIST
22653: LIST
22654: LIST
22655: LIST
22656: LIST
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
// Randomize ;
22671: CALL_OW 10
// end ;
22675: END
// every 0 0$10 do
22676: GO 22678
22678: DISABLE
// begin Randomize ;
22679: CALL_OW 10
// enable ;
22683: ENABLE
// end ;
22684: END
// every 15 15$0 do
22685: GO 22687
22687: DISABLE
// begin CreateCratesArea ( 4 , other_crates , true ) ;
22688: LD_INT 4
22690: PPUSH
22691: LD_INT 27
22693: PPUSH
22694: LD_INT 1
22696: PPUSH
22697: CALL_OW 55
// end ;
22701: END
// every 23 23$0 do
22702: GO 22704
22704: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22705: LD_INT 5
22707: PPUSH
22708: LD_INT 27
22710: PPUSH
22711: LD_INT 1
22713: PPUSH
22714: CALL_OW 55
// end ;
22718: END
// every 37 37$0 do
22719: GO 22721
22721: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22722: LD_INT 5
22724: PPUSH
22725: LD_INT 27
22727: PPUSH
22728: LD_INT 1
22730: PPUSH
22731: CALL_OW 55
// end ;
22735: END
// every 47 47$0 do
22736: GO 22738
22738: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22739: LD_INT 5
22741: PPUSH
22742: LD_INT 27
22744: PPUSH
22745: LD_INT 1
22747: PPUSH
22748: CALL_OW 55
// end ;
22752: END
// every 0 0$5 do var a , i ;
22753: GO 22755
22755: DISABLE
22756: LD_INT 0
22758: PPUSH
22759: PPUSH
// begin crates := [ ] ;
22760: LD_ADDR_EXP 85
22764: PUSH
22765: EMPTY
22766: ST_TO_ADDR
// a := GetListOfCratesInArea ( ar_crates_site ) ;
22767: LD_ADDR_VAR 0 1
22771: PUSH
22772: LD_INT 16
22774: PPUSH
22775: CALL_OW 435
22779: ST_TO_ADDR
// for i := 1 to ( a div 2 ) do
22780: LD_ADDR_VAR 0 2
22784: PUSH
22785: DOUBLE
22786: LD_INT 1
22788: DEC
22789: ST_TO_ADDR
22790: LD_VAR 0 1
22794: PUSH
22795: LD_INT 2
22797: DIV
22798: PUSH
22799: FOR_TO
22800: IFFALSE 22856
// crates := crates ^ [ [ a [ i * 2 - 1 ] , a [ i * 2 ] ] ] ;
22802: LD_ADDR_EXP 85
22806: PUSH
22807: LD_EXP 85
22811: PUSH
22812: LD_VAR 0 1
22816: PUSH
22817: LD_VAR 0 2
22821: PUSH
22822: LD_INT 2
22824: MUL
22825: PUSH
22826: LD_INT 1
22828: MINUS
22829: ARRAY
22830: PUSH
22831: LD_VAR 0 1
22835: PUSH
22836: LD_VAR 0 2
22840: PUSH
22841: LD_INT 2
22843: MUL
22844: ARRAY
22845: PUSH
22846: EMPTY
22847: LIST
22848: LIST
22849: PUSH
22850: EMPTY
22851: LIST
22852: ADD
22853: ST_TO_ADDR
22854: GO 22799
22856: POP
22857: POP
// enable ;
22858: ENABLE
// end ;
22859: PPOPN 2
22861: END
// every 0 0$1 do
22862: GO 22864
22864: DISABLE
// begin Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
22865: LD_INT 3
22867: PPUSH
22868: LD_INT 7
22870: PPUSH
22871: CALL_OW 12
22875: PUSH
22876: LD_INT 35
22878: MUL
22879: PPUSH
22880: CALL_OW 67
// CreateCratesArea ( 2 , first_crate , true ) ;
22884: LD_INT 2
22886: PPUSH
22887: LD_INT 6
22889: PPUSH
22890: LD_INT 1
22892: PPUSH
22893: CALL_OW 55
// Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
22897: LD_INT 3
22899: PPUSH
22900: LD_INT 7
22902: PPUSH
22903: CALL_OW 12
22907: PUSH
22908: LD_INT 35
22910: MUL
22911: PPUSH
22912: CALL_OW 67
// CreateCratesArea ( 2 , second_crate , true ) ;
22916: LD_INT 2
22918: PPUSH
22919: LD_INT 7
22921: PPUSH
22922: LD_INT 1
22924: PPUSH
22925: CALL_OW 55
// end ;
22929: END
// every 0 0$5 do
22930: GO 22932
22932: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
22933: LD_LOC 32
22937: PPUSH
22938: LD_INT 5
22940: PPUSH
22941: CALL 22996 0 2
// end ;
22945: END
// every 0 0$5 do
22946: GO 22948
22948: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
22949: LD_LOC 33
22953: PPUSH
22954: LD_INT 16
22956: PPUSH
22957: CALL 22996 0 2
// end ;
22961: END
// every 5 5$0 + 0 0$5 do
22962: GO 22964
22964: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
22965: LD_LOC 32
22969: PPUSH
22970: LD_INT 5
22972: PPUSH
22973: CALL 22996 0 2
// enable ;
22977: ENABLE
// end ;
22978: END
// every 5 5$0 + 0 0$5 do
22979: GO 22981
22981: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
22982: LD_LOC 33
22986: PPUSH
22987: LD_INT 16
22989: PPUSH
22990: CALL 22996 0 2
// enable ;
22994: ENABLE
// end ;
22995: END
// function objev ( zasilky , area ) ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
22996: LD_INT 0
22998: PPUSH
22999: PPUSH
23000: PPUSH
23001: PPUSH
23002: PPUSH
23003: PPUSH
23004: PPUSH
23005: PPUSH
23006: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
23007: LD_ADDR_VAR 0 11
23011: PUSH
23012: LD_OWVAR 1
23016: PUSH
23017: LD_INT 10500
23019: DIV
23020: PUSH
23021: LD_INT 1
23023: PLUS
23024: ST_TO_ADDR
// cek := [ ] ;
23025: LD_ADDR_VAR 0 8
23029: PUSH
23030: EMPTY
23031: ST_TO_ADDR
// cek2 := [ ] ;
23032: LD_ADDR_VAR 0 9
23036: PUSH
23037: EMPTY
23038: ST_TO_ADDR
// last := 0 ;
23039: LD_ADDR_VAR 0 10
23043: PUSH
23044: LD_INT 0
23046: ST_TO_ADDR
// x := zasilky [ min5 ] ;
23047: LD_ADDR_VAR 0 4
23051: PUSH
23052: LD_VAR 0 1
23056: PUSH
23057: LD_VAR 0 11
23061: ARRAY
23062: ST_TO_ADDR
// for i := 1 to x do
23063: LD_ADDR_VAR 0 6
23067: PUSH
23068: DOUBLE
23069: LD_INT 1
23071: DEC
23072: ST_TO_ADDR
23073: LD_VAR 0 4
23077: PUSH
23078: FOR_TO
23079: IFFALSE 23105
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
23081: LD_ADDR_VAR 0 8
23085: PUSH
23086: LD_VAR 0 8
23090: PUSH
23091: LD_INT 525
23093: PPUSH
23094: LD_INT 10500
23096: PPUSH
23097: CALL_OW 12
23101: ADD
23102: ST_TO_ADDR
23103: GO 23078
23105: POP
23106: POP
// cek := SortListByListAsc ( cek , cek ) ;
23107: LD_ADDR_VAR 0 8
23111: PUSH
23112: LD_VAR 0 8
23116: PPUSH
23117: LD_VAR 0 8
23121: PPUSH
23122: CALL_OW 76
23126: ST_TO_ADDR
// for i in cek do
23127: LD_ADDR_VAR 0 6
23131: PUSH
23132: LD_VAR 0 8
23136: PUSH
23137: FOR_IN
23138: IFFALSE 23174
// begin cek2 := cek2 ^ i - last ;
23140: LD_ADDR_VAR 0 9
23144: PUSH
23145: LD_VAR 0 9
23149: PUSH
23150: LD_VAR 0 6
23154: PUSH
23155: LD_VAR 0 10
23159: MINUS
23160: ADD
23161: ST_TO_ADDR
// last := i ;
23162: LD_ADDR_VAR 0 10
23166: PUSH
23167: LD_VAR 0 6
23171: ST_TO_ADDR
// end ;
23172: GO 23137
23174: POP
23175: POP
// for i := 1 to x do
23176: LD_ADDR_VAR 0 6
23180: PUSH
23181: DOUBLE
23182: LD_INT 1
23184: DEC
23185: ST_TO_ADDR
23186: LD_VAR 0 4
23190: PUSH
23191: FOR_TO
23192: IFFALSE 23234
// begin CreateCratesArea ( Rand ( 4 , 5 ) , area , true ) ;
23194: LD_INT 4
23196: PPUSH
23197: LD_INT 5
23199: PPUSH
23200: CALL_OW 12
23204: PPUSH
23205: LD_VAR 0 2
23209: PPUSH
23210: LD_INT 1
23212: PPUSH
23213: CALL_OW 55
// Wait ( cek2 [ i ] ) ;
23217: LD_VAR 0 9
23221: PUSH
23222: LD_VAR 0 6
23226: ARRAY
23227: PPUSH
23228: CALL_OW 67
// end ;
23232: GO 23191
23234: POP
23235: POP
// end ; end_of_file
23236: LD_VAR 0 3
23240: RET
// export function get_x_best ( num , skill , mclass ) ; var i , lidi , skills ; begin
23241: LD_INT 0
23243: PPUSH
23244: PPUSH
23245: PPUSH
23246: PPUSH
// if mclass then
23247: LD_VAR 0 3
23251: IFFALSE 23304
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] , [ f_class , mclass ] ] ) else
23253: LD_ADDR_VAR 0 6
23257: PUSH
23258: LD_INT 22
23260: PUSH
23261: LD_EXP 3
23265: PUSH
23266: EMPTY
23267: LIST
23268: LIST
23269: PUSH
23270: LD_INT 21
23272: PUSH
23273: LD_INT 1
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: LD_INT 25
23282: PUSH
23283: LD_VAR 0 3
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: PUSH
23292: EMPTY
23293: LIST
23294: LIST
23295: LIST
23296: PPUSH
23297: CALL_OW 69
23301: ST_TO_ADDR
23302: GO 23340
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
23304: LD_ADDR_VAR 0 6
23308: PUSH
23309: LD_INT 22
23311: PUSH
23312: LD_EXP 3
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: PUSH
23321: LD_INT 21
23323: PUSH
23324: LD_INT 1
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: PPUSH
23335: CALL_OW 69
23339: ST_TO_ADDR
// skills := [ ] ;
23340: LD_ADDR_VAR 0 7
23344: PUSH
23345: EMPTY
23346: ST_TO_ADDR
// result := [ ] ;
23347: LD_ADDR_VAR 0 4
23351: PUSH
23352: EMPTY
23353: ST_TO_ADDR
// for i in lidi do
23354: LD_ADDR_VAR 0 5
23358: PUSH
23359: LD_VAR 0 6
23363: PUSH
23364: FOR_IN
23365: IFFALSE 23395
// skills := skills ^ GetSkill ( i , skill ) ;
23367: LD_ADDR_VAR 0 7
23371: PUSH
23372: LD_VAR 0 7
23376: PUSH
23377: LD_VAR 0 5
23381: PPUSH
23382: LD_VAR 0 2
23386: PPUSH
23387: CALL_OW 259
23391: ADD
23392: ST_TO_ADDR
23393: GO 23364
23395: POP
23396: POP
// SortListByListDesc ( lidi , skills ) ;
23397: LD_VAR 0 6
23401: PPUSH
23402: LD_VAR 0 7
23406: PPUSH
23407: CALL_OW 77
// if num = 0 then
23411: LD_VAR 0 1
23415: PUSH
23416: LD_INT 0
23418: EQUAL
23419: IFFALSE 23435
// num := ( lidi + 0 ) ;
23421: LD_ADDR_VAR 0 1
23425: PUSH
23426: LD_VAR 0 6
23430: PUSH
23431: LD_INT 0
23433: PLUS
23434: ST_TO_ADDR
// if num > lidi then
23435: LD_VAR 0 1
23439: PUSH
23440: LD_VAR 0 6
23444: GREATER
23445: IFFALSE 23461
// num := lidi + 0 ;
23447: LD_ADDR_VAR 0 1
23451: PUSH
23452: LD_VAR 0 6
23456: PUSH
23457: LD_INT 0
23459: PLUS
23460: ST_TO_ADDR
// for i := 1 to num do
23461: LD_ADDR_VAR 0 5
23465: PUSH
23466: DOUBLE
23467: LD_INT 1
23469: DEC
23470: ST_TO_ADDR
23471: LD_VAR 0 1
23475: PUSH
23476: FOR_TO
23477: IFFALSE 23503
// result := result ^ lidi [ i ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_VAR 0 4
23488: PUSH
23489: LD_VAR 0 6
23493: PUSH
23494: LD_VAR 0 5
23498: ARRAY
23499: ADD
23500: ST_TO_ADDR
23501: GO 23476
23503: POP
23504: POP
// end ;
23505: LD_VAR 0 4
23509: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
23510: LD_INT 0
23512: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_alive ] , [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
23513: LD_ADDR_VAR 0 1
23517: PUSH
23518: LD_VAR 0 1
23522: PPUSH
23523: LD_INT 51
23525: PUSH
23526: EMPTY
23527: LIST
23528: PUSH
23529: LD_INT 21
23531: PUSH
23532: LD_INT 1
23534: PUSH
23535: EMPTY
23536: LIST
23537: LIST
23538: PUSH
23539: LD_INT 22
23541: PUSH
23542: LD_VAR 0 2
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: PUSH
23551: LD_INT 3
23553: PUSH
23554: LD_INT 23
23556: PUSH
23557: LD_INT 0
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: LIST
23568: LIST
23569: LIST
23570: PPUSH
23571: CALL_OW 72
23575: ST_TO_ADDR
// if sex <> 0 then
23576: LD_VAR 0 3
23580: PUSH
23581: LD_INT 0
23583: NONEQUAL
23584: IFFALSE 23613
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
23586: LD_ADDR_VAR 0 1
23590: PUSH
23591: LD_VAR 0 1
23595: PPUSH
23596: LD_INT 26
23598: PUSH
23599: LD_VAR 0 3
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PPUSH
23608: CALL_OW 72
23612: ST_TO_ADDR
// if Hclass <> 0 then
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 0
23620: NONEQUAL
23621: IFFALSE 23650
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
23623: LD_ADDR_VAR 0 1
23627: PUSH
23628: LD_VAR 0 1
23632: PPUSH
23633: LD_INT 25
23635: PUSH
23636: LD_VAR 0 4
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PPUSH
23645: CALL_OW 72
23649: ST_TO_ADDR
// if index <= 0 then
23650: LD_VAR 0 5
23654: PUSH
23655: LD_INT 0
23657: LESSEQUAL
23658: IFFALSE 23668
// index := 1 ;
23660: LD_ADDR_VAR 0 5
23664: PUSH
23665: LD_INT 1
23667: ST_TO_ADDR
// if lidi >= index then
23668: LD_VAR 0 1
23672: PUSH
23673: LD_VAR 0 5
23677: GREATEREQUAL
23678: IFFALSE 23698
// result := lidi [ index ] else
23680: LD_ADDR_VAR 0 6
23684: PUSH
23685: LD_VAR 0 1
23689: PUSH
23690: LD_VAR 0 5
23694: ARRAY
23695: ST_TO_ADDR
23696: GO 23706
// result := 0 ;
23698: LD_ADDR_VAR 0 6
23702: PUSH
23703: LD_INT 0
23705: ST_TO_ADDR
// end ;
23706: LD_VAR 0 6
23710: RET
// export function see_any ( strana , sez ) ; var i ; begin
23711: LD_INT 0
23713: PPUSH
23714: PPUSH
// result := [ ] ;
23715: LD_ADDR_VAR 0 3
23719: PUSH
23720: EMPTY
23721: ST_TO_ADDR
// for i in sez do
23722: LD_ADDR_VAR 0 4
23726: PUSH
23727: LD_VAR 0 2
23731: PUSH
23732: FOR_IN
23733: IFFALSE 23772
// if See ( strana , i ) then
23735: LD_VAR 0 1
23739: PPUSH
23740: LD_VAR 0 4
23744: PPUSH
23745: CALL_OW 292
23749: IFFALSE 23770
// begin result := result ^ [ i ] ;
23751: LD_ADDR_VAR 0 3
23755: PUSH
23756: LD_VAR 0 3
23760: PUSH
23761: LD_VAR 0 4
23765: PUSH
23766: EMPTY
23767: LIST
23768: ADD
23769: ST_TO_ADDR
// end ;
23770: GO 23732
23772: POP
23773: POP
// ; end ;
23774: LD_VAR 0 3
23778: RET
// export function TalkOn ; begin
23779: LD_INT 0
23781: PPUSH
// end ;
23782: LD_VAR 0 1
23786: RET
// export function TalkOff ; begin
23787: LD_INT 0
23789: PPUSH
// end ;
23790: LD_VAR 0 1
23794: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
23795: LD_INT 0
23797: PPUSH
23798: PPUSH
23799: PPUSH
// result := [ ] ;
23800: LD_ADDR_VAR 0 3
23804: PUSH
23805: EMPTY
23806: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
23807: LD_ADDR_VAR 0 4
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: EMPTY
23818: PPUSH
23819: CALL_OW 70
23823: ST_TO_ADDR
// for i in inbase do
23824: LD_ADDR_VAR 0 5
23828: PUSH
23829: LD_VAR 0 4
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23908
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
23837: LD_VAR 0 5
23841: PPUSH
23842: CALL_OW 247
23846: PUSH
23847: LD_INT 3
23849: EQUAL
23850: PUSH
23851: LD_VAR 0 5
23855: PPUSH
23856: CALL_OW 247
23860: PUSH
23861: LD_INT 2
23863: EQUAL
23864: OR
23865: IFFALSE 23890
// begin result := result ^ UnitsInside ( i ) ;
23867: LD_ADDR_VAR 0 3
23871: PUSH
23872: LD_VAR 0 3
23876: PUSH
23877: LD_VAR 0 5
23881: PPUSH
23882: CALL_OW 313
23886: ADD
23887: ST_TO_ADDR
// end else
23888: GO 23906
// begin result := result ^ i ;
23890: LD_ADDR_VAR 0 3
23894: PUSH
23895: LD_VAR 0 3
23899: PUSH
23900: LD_VAR 0 5
23904: ADD
23905: ST_TO_ADDR
// end ; end ;
23906: GO 23834
23908: POP
23909: POP
// result := UnitFilter ( result diff 0 , filter ) ;
23910: LD_ADDR_VAR 0 3
23914: PUSH
23915: LD_VAR 0 3
23919: PUSH
23920: LD_INT 0
23922: DIFF
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 72
23933: ST_TO_ADDR
// end ;
23934: LD_VAR 0 3
23938: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
23939: LD_INT 0
23941: PPUSH
23942: PPUSH
23943: PPUSH
23944: PPUSH
23945: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) ;
23946: LD_ADDR_VAR 0 1
23950: PUSH
23951: LD_VAR 0 1
23955: PPUSH
23956: LD_INT 51
23958: PUSH
23959: EMPTY
23960: LIST
23961: PPUSH
23962: CALL_OW 72
23966: ST_TO_ADDR
// if take_out then
23967: LD_VAR 0 3
23971: IFFALSE 23999
// drivers := UnitFilter ( drivers , [ [ f_alive ] ] ) else
23973: LD_ADDR_VAR 0 2
23977: PUSH
23978: LD_VAR 0 2
23982: PPUSH
23983: LD_INT 51
23985: PUSH
23986: EMPTY
23987: LIST
23988: PUSH
23989: EMPTY
23990: LIST
23991: PPUSH
23992: CALL_OW 72
23996: ST_TO_ADDR
23997: GO 24030
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_VAR 0 2
24008: PPUSH
24009: LD_INT 51
24011: PUSH
24012: EMPTY
24013: LIST
24014: PUSH
24015: LD_INT 56
24017: PUSH
24018: EMPTY
24019: LIST
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: PPUSH
24025: CALL_OW 72
24029: ST_TO_ADDR
// empty := [ ] ;
24030: LD_ADDR_VAR 0 5
24034: PUSH
24035: EMPTY
24036: ST_TO_ADDR
// free := [ ] ;
24037: LD_ADDR_VAR 0 6
24041: PUSH
24042: EMPTY
24043: ST_TO_ADDR
// for i in cars do
24044: LD_ADDR_VAR 0 7
24048: PUSH
24049: LD_VAR 0 1
24053: PUSH
24054: FOR_IN
24055: IFFALSE 24090
// if not IsDrivenBy ( i ) then
24057: LD_VAR 0 7
24061: PPUSH
24062: CALL_OW 311
24066: NOT
24067: IFFALSE 24088
// empty := empty ^ [ i ] ;
24069: LD_ADDR_VAR 0 5
24073: PUSH
24074: LD_VAR 0 5
24078: PUSH
24079: LD_VAR 0 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: ADD
24087: ST_TO_ADDR
24088: GO 24054
24090: POP
24091: POP
// for i in drivers do
24092: LD_ADDR_VAR 0 7
24096: PUSH
24097: LD_VAR 0 2
24101: PUSH
24102: FOR_IN
24103: IFFALSE 24144
// if not ( IsInUnit ( i ) in cars ) then
24105: LD_VAR 0 7
24109: PPUSH
24110: CALL_OW 310
24114: PUSH
24115: LD_VAR 0 1
24119: IN
24120: NOT
24121: IFFALSE 24142
// free := free ^ [ i ] ;
24123: LD_ADDR_VAR 0 6
24127: PUSH
24128: LD_VAR 0 6
24132: PUSH
24133: LD_VAR 0 7
24137: PUSH
24138: EMPTY
24139: LIST
24140: ADD
24141: ST_TO_ADDR
24142: GO 24102
24144: POP
24145: POP
// if empty <= free then
24146: LD_VAR 0 5
24150: PUSH
24151: LD_VAR 0 6
24155: LESSEQUAL
24156: IFFALSE 24170
// konec := empty else
24158: LD_ADDR_VAR 0 8
24162: PUSH
24163: LD_VAR 0 5
24167: ST_TO_ADDR
24168: GO 24180
// konec := free ;
24170: LD_ADDR_VAR 0 8
24174: PUSH
24175: LD_VAR 0 6
24179: ST_TO_ADDR
// result := cars diff empty ;
24180: LD_ADDR_VAR 0 4
24184: PUSH
24185: LD_VAR 0 1
24189: PUSH
24190: LD_VAR 0 5
24194: DIFF
24195: ST_TO_ADDR
// for i := 1 to konec do
24196: LD_ADDR_VAR 0 7
24200: PUSH
24201: DOUBLE
24202: LD_INT 1
24204: DEC
24205: ST_TO_ADDR
24206: LD_VAR 0 8
24210: PUSH
24211: FOR_TO
24212: IFFALSE 24264
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
24214: LD_VAR 0 6
24218: PUSH
24219: LD_VAR 0 7
24223: ARRAY
24224: PPUSH
24225: LD_VAR 0 5
24229: PUSH
24230: LD_VAR 0 7
24234: ARRAY
24235: PPUSH
24236: CALL_OW 120
// result := result ^ empty [ i ] ;
24240: LD_ADDR_VAR 0 4
24244: PUSH
24245: LD_VAR 0 4
24249: PUSH
24250: LD_VAR 0 5
24254: PUSH
24255: LD_VAR 0 7
24259: ARRAY
24260: ADD
24261: ST_TO_ADDR
// end ;
24262: GO 24211
24264: POP
24265: POP
// end ;
24266: LD_VAR 0 4
24270: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , pockat ; begin
24271: LD_INT 0
24273: PPUSH
24274: PPUSH
24275: PPUSH
24276: PPUSH
// pockat := tick + cas ;
24277: LD_ADDR_VAR 0 6
24281: PUSH
24282: LD_OWVAR 1
24286: PUSH
24287: LD_VAR 0 2
24291: PLUS
24292: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
24293: LD_VAR 0 5
24297: NOT
24298: PUSH
24299: LD_OWVAR 1
24303: PUSH
24304: LD_VAR 0 6
24308: LESS
24309: AND
24310: IFFALSE 24366
// begin vsichni_ready := true ;
24312: LD_ADDR_VAR 0 5
24316: PUSH
24317: LD_INT 1
24319: ST_TO_ADDR
// for i in cars do
24320: LD_ADDR_VAR 0 4
24324: PUSH
24325: LD_VAR 0 1
24329: PUSH
24330: FOR_IN
24331: IFFALSE 24355
// if not IsDrivenBy ( i ) then
24333: LD_VAR 0 4
24337: PPUSH
24338: CALL_OW 311
24342: NOT
24343: IFFALSE 24353
// vsichni_ready := false ;
24345: LD_ADDR_VAR 0 5
24349: PUSH
24350: LD_INT 0
24352: ST_TO_ADDR
24353: GO 24330
24355: POP
24356: POP
// wait ( 0 0$1.0 ) ;
24357: LD_INT 35
24359: PPUSH
24360: CALL_OW 67
// end ;
24364: GO 24293
// end ;
24366: LD_VAR 0 3
24370: RET
// export function find_and_wait ( cars , drivers , take_out , change , cas ) ; var empty , full , free , i , konec , mytick ; begin
24371: LD_INT 0
24373: PPUSH
24374: PPUSH
24375: PPUSH
24376: PPUSH
24377: PPUSH
24378: PPUSH
24379: PPUSH
// mytick := tick + cas ;
24380: LD_ADDR_VAR 0 12
24384: PUSH
24385: LD_OWVAR 1
24389: PUSH
24390: LD_VAR 0 5
24394: PLUS
24395: ST_TO_ADDR
// cars := UnitFilter ( cars , [ [ f_alive ] ] ) ;
24396: LD_ADDR_VAR 0 1
24400: PUSH
24401: LD_VAR 0 1
24405: PPUSH
24406: LD_INT 51
24408: PUSH
24409: EMPTY
24410: LIST
24411: PUSH
24412: EMPTY
24413: LIST
24414: PPUSH
24415: CALL_OW 72
24419: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
24420: LD_ADDR_VAR 0 2
24424: PUSH
24425: LD_VAR 0 2
24429: PPUSH
24430: LD_INT 51
24432: PUSH
24433: EMPTY
24434: LIST
24435: PUSH
24436: LD_INT 56
24438: PUSH
24439: EMPTY
24440: LIST
24441: PUSH
24442: EMPTY
24443: LIST
24444: LIST
24445: PPUSH
24446: CALL_OW 72
24450: ST_TO_ADDR
// if take_out then
24451: LD_VAR 0 3
24455: IFFALSE 24496
// drivers := drivers ^ UnitFilter ( drivers , [ [ f_alive ] , [ f_inside ] ] ) else
24457: LD_ADDR_VAR 0 2
24461: PUSH
24462: LD_VAR 0 2
24466: PUSH
24467: LD_VAR 0 2
24471: PPUSH
24472: LD_INT 51
24474: PUSH
24475: EMPTY
24476: LIST
24477: PUSH
24478: LD_INT 54
24480: PUSH
24481: EMPTY
24482: LIST
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PPUSH
24488: CALL_OW 72
24492: ADD
24493: ST_TO_ADDR
24494: GO 24527
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
24496: LD_ADDR_VAR 0 7
24500: PUSH
24501: LD_VAR 0 1
24505: PPUSH
24506: LD_INT 58
24508: PUSH
24509: EMPTY
24510: LIST
24511: PUSH
24512: LD_INT 51
24514: PUSH
24515: EMPTY
24516: LIST
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PPUSH
24522: CALL_OW 72
24526: ST_TO_ADDR
// repeat full := UnitFilter ( cars , [ [ f_occupied ] , [ f_alive ] ] ) ;
24527: LD_ADDR_VAR 0 8
24531: PUSH
24532: LD_VAR 0 1
24536: PPUSH
24537: LD_INT 59
24539: PUSH
24540: EMPTY
24541: LIST
24542: PUSH
24543: LD_INT 51
24545: PUSH
24546: EMPTY
24547: LIST
24548: PUSH
24549: EMPTY
24550: LIST
24551: LIST
24552: PPUSH
24553: CALL_OW 72
24557: ST_TO_ADDR
// if change then
24558: LD_VAR 0 4
24562: IFFALSE 24584
// ComExitVehicle ( inside_units ( full ) diff drivers ) ;
24564: LD_VAR 0 8
24568: PPUSH
24569: CALL 25319 0 1
24573: PUSH
24574: LD_VAR 0 2
24578: DIFF
24579: PPUSH
24580: CALL_OW 121
// for i in drivers do
24584: LD_ADDR_VAR 0 10
24588: PUSH
24589: LD_VAR 0 2
24593: PUSH
24594: FOR_IN
24595: IFFALSE 24657
// if not ( IsInUnit ( i ) in cars ) then
24597: LD_VAR 0 10
24601: PPUSH
24602: CALL_OW 310
24606: PUSH
24607: LD_VAR 0 1
24611: IN
24612: NOT
24613: IFFALSE 24655
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
24615: LD_VAR 0 10
24619: PPUSH
24620: CALL_OW 310
24624: PPUSH
24625: CALL_OW 247
24629: PUSH
24630: LD_INT 2
24632: EQUAL
24633: IFFALSE 24646
// ComExitVehicle ( i ) else
24635: LD_VAR 0 10
24639: PPUSH
24640: CALL_OW 121
24644: GO 24655
// ComExitBuilding ( i ) ;
24646: LD_VAR 0 10
24650: PPUSH
24651: CALL_OW 122
24655: GO 24594
24657: POP
24658: POP
// free := UnitFilter ( drivers , [ [ f_outside ] , [ f_alive ] ] ) ;
24659: LD_ADDR_VAR 0 9
24663: PUSH
24664: LD_VAR 0 2
24668: PPUSH
24669: LD_INT 56
24671: PUSH
24672: EMPTY
24673: LIST
24674: PUSH
24675: LD_INT 51
24677: PUSH
24678: EMPTY
24679: LIST
24680: PUSH
24681: EMPTY
24682: LIST
24683: LIST
24684: PPUSH
24685: CALL_OW 72
24689: ST_TO_ADDR
// i := 1 ;
24690: LD_ADDR_VAR 0 10
24694: PUSH
24695: LD_INT 1
24697: ST_TO_ADDR
// while i <= free and i <= empty do
24698: LD_VAR 0 10
24702: PUSH
24703: LD_VAR 0 9
24707: LESSEQUAL
24708: PUSH
24709: LD_VAR 0 10
24713: PUSH
24714: LD_VAR 0 7
24718: LESSEQUAL
24719: AND
24720: IFFALSE 24783
// begin if not free [ i ] in DU_units then
24722: LD_VAR 0 9
24726: PUSH
24727: LD_VAR 0 10
24731: ARRAY
24732: PUSH
24733: LD_EXP 82
24737: IN
24738: NOT
24739: IFFALSE 24767
// ComEnterUnit ( free [ i ] , empty [ i ] ) ;
24741: LD_VAR 0 9
24745: PUSH
24746: LD_VAR 0 10
24750: ARRAY
24751: PPUSH
24752: LD_VAR 0 7
24756: PUSH
24757: LD_VAR 0 10
24761: ARRAY
24762: PPUSH
24763: CALL_OW 120
// i := i + 1 ;
24767: LD_ADDR_VAR 0 10
24771: PUSH
24772: LD_VAR 0 10
24776: PUSH
24777: LD_INT 1
24779: PLUS
24780: ST_TO_ADDR
// end ;
24781: GO 24698
// wait ( 0 0$1 ) ;
24783: LD_INT 35
24785: PPUSH
24786: CALL_OW 67
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
24790: LD_ADDR_VAR 0 7
24794: PUSH
24795: LD_VAR 0 1
24799: PPUSH
24800: LD_INT 58
24802: PUSH
24803: EMPTY
24804: LIST
24805: PUSH
24806: LD_INT 51
24808: PUSH
24809: EMPTY
24810: LIST
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PPUSH
24816: CALL_OW 72
24820: ST_TO_ADDR
// until not empty or tick > mytick ;
24821: LD_VAR 0 7
24825: NOT
24826: PUSH
24827: LD_OWVAR 1
24831: PUSH
24832: LD_VAR 0 12
24836: GREATER
24837: OR
24838: IFFALSE 24527
// end ;
24840: LD_VAR 0 6
24844: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
24845: LD_INT 0
24847: PPUSH
24848: PPUSH
24849: PPUSH
// while remotes > mechs do
24850: LD_VAR 0 3
24854: PUSH
24855: LD_VAR 0 2
24859: GREATER
24860: IFFALSE 24876
// delete ( remotes , 1 ) ;
24862: LD_VAR 0 3
24866: PPUSH
24867: LD_INT 1
24869: PPUSH
24870: CALL_OW 3
24874: GO 24850
// for i := 1 to remotes do
24876: LD_ADDR_VAR 0 6
24880: PUSH
24881: DOUBLE
24882: LD_INT 1
24884: DEC
24885: ST_TO_ADDR
24886: LD_VAR 0 3
24890: PUSH
24891: FOR_TO
24892: IFFALSE 24922
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
24894: LD_VAR 0 2
24898: PUSH
24899: LD_VAR 0 6
24903: ARRAY
24904: PPUSH
24905: LD_VAR 0 3
24909: PUSH
24910: LD_VAR 0 6
24914: ARRAY
24915: PPUSH
24916: CALL_OW 120
24920: GO 24891
24922: POP
24923: POP
// end ;
24924: LD_VAR 0 4
24928: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
24929: LD_INT 0
24931: PPUSH
24932: PPUSH
24933: PPUSH
24934: PPUSH
// c := tick + cas ;
24935: LD_ADDR_VAR 0 5
24939: PUSH
24940: LD_OWVAR 1
24944: PUSH
24945: LD_VAR 0 3
24949: PLUS
24950: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
24951: LD_OWVAR 1
24955: PUSH
24956: LD_VAR 0 5
24960: LESS
24961: PUSH
24962: LD_VAR 0 2
24966: PPUSH
24967: CALL 25319 0 1
24971: PUSH
24972: LD_INT 0
24974: PLUS
24975: PUSH
24976: LD_VAR 0 2
24980: EQUAL
24981: NOT
24982: AND
24983: IFFALSE 24994
// wait ( 0 0$1 ) ;
24985: LD_INT 35
24987: PPUSH
24988: CALL_OW 67
24992: GO 24951
// unlinked := cars ;
24994: LD_ADDR_VAR 0 6
24998: PUSH
24999: LD_VAR 0 1
25003: ST_TO_ADDR
// for i in remotes do
25004: LD_ADDR_VAR 0 7
25008: PUSH
25009: LD_VAR 0 2
25013: PUSH
25014: FOR_IN
25015: IFFALSE 25064
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
25017: LD_VAR 0 6
25021: PPUSH
25022: LD_VAR 0 7
25026: PPUSH
25027: CALL_OW 313
25031: PPUSH
25032: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
25036: LD_ADDR_VAR 0 6
25040: PUSH
25041: LD_VAR 0 6
25045: PUSH
25046: LD_VAR 0 7
25050: PPUSH
25051: CALL_OW 313
25055: PPUSH
25056: CALL_OW 432
25060: DIFF
25061: ST_TO_ADDR
// end ;
25062: GO 25014
25064: POP
25065: POP
// end ;
25066: LD_VAR 0 4
25070: RET
// export function find_and_wait_r ( cars , remote , cas ) ; var linked , unlinked , i , konec , mytick , rmecs , max ; begin
25071: LD_INT 0
25073: PPUSH
25074: PPUSH
25075: PPUSH
25076: PPUSH
25077: PPUSH
25078: PPUSH
25079: PPUSH
25080: PPUSH
// mytick := tick + cas ;
25081: LD_ADDR_VAR 0 9
25085: PUSH
25086: LD_OWVAR 1
25090: PUSH
25091: LD_VAR 0 3
25095: PLUS
25096: ST_TO_ADDR
// rmecs := inside_units ( remote ) ;
25097: LD_ADDR_VAR 0 10
25101: PUSH
25102: LD_VAR 0 2
25106: PPUSH
25107: CALL 25319 0 1
25111: ST_TO_ADDR
// max := 0 ;
25112: LD_ADDR_VAR 0 11
25116: PUSH
25117: LD_INT 0
25119: ST_TO_ADDR
// for i in rmecs do
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 10
25129: PUSH
25130: FOR_IN
25131: IFFALSE 25159
// max := max + GetSkill ( i , skill_mechanical ) ;
25133: LD_ADDR_VAR 0 11
25137: PUSH
25138: LD_VAR 0 11
25142: PUSH
25143: LD_VAR 0 7
25147: PPUSH
25148: LD_INT 3
25150: PPUSH
25151: CALL_OW 259
25155: PLUS
25156: ST_TO_ADDR
25157: GO 25130
25159: POP
25160: POP
// while mytick < tick and ( unlinked or linked < max or max = 0 ) do
25161: LD_VAR 0 9
25165: PUSH
25166: LD_OWVAR 1
25170: LESS
25171: PUSH
25172: LD_VAR 0 6
25176: PUSH
25177: LD_VAR 0 5
25181: PUSH
25182: LD_VAR 0 11
25186: LESS
25187: OR
25188: PUSH
25189: LD_VAR 0 11
25193: PUSH
25194: LD_INT 0
25196: EQUAL
25197: OR
25198: AND
25199: IFFALSE 25314
// begin rmecs := inside_units ( remote ) ;
25201: LD_ADDR_VAR 0 10
25205: PUSH
25206: LD_VAR 0 2
25210: PPUSH
25211: CALL 25319 0 1
25215: ST_TO_ADDR
// max := 0 ;
25216: LD_ADDR_VAR 0 11
25220: PUSH
25221: LD_INT 0
25223: ST_TO_ADDR
// for i in rmecs do
25224: LD_ADDR_VAR 0 7
25228: PUSH
25229: LD_VAR 0 10
25233: PUSH
25234: FOR_IN
25235: IFFALSE 25263
// max := max + GetSkill ( i , skill_mechanical ) ;
25237: LD_ADDR_VAR 0 11
25241: PUSH
25242: LD_VAR 0 11
25246: PUSH
25247: LD_VAR 0 7
25251: PPUSH
25252: LD_INT 3
25254: PPUSH
25255: CALL_OW 259
25259: PLUS
25260: ST_TO_ADDR
25261: GO 25234
25263: POP
25264: POP
// linked := UnitFilter ( cars , [ [ f_linked ] ] ) ;
25265: LD_ADDR_VAR 0 5
25269: PUSH
25270: LD_VAR 0 1
25274: PPUSH
25275: LD_INT 61
25277: PUSH
25278: EMPTY
25279: LIST
25280: PUSH
25281: EMPTY
25282: LIST
25283: PPUSH
25284: CALL_OW 72
25288: ST_TO_ADDR
// unlinked := linked diff unlinked ;
25289: LD_ADDR_VAR 0 6
25293: PUSH
25294: LD_VAR 0 5
25298: PUSH
25299: LD_VAR 0 6
25303: DIFF
25304: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25305: LD_INT 35
25307: PPUSH
25308: CALL_OW 67
// end ;
25312: GO 25161
// end ;
25314: LD_VAR 0 4
25318: RET
// export function inside_units ( uns ) ; var i ; begin
25319: LD_INT 0
25321: PPUSH
25322: PPUSH
// result := [ ] ;
25323: LD_ADDR_VAR 0 2
25327: PUSH
25328: EMPTY
25329: ST_TO_ADDR
// for i in uns do
25330: LD_ADDR_VAR 0 3
25334: PUSH
25335: LD_VAR 0 1
25339: PUSH
25340: FOR_IN
25341: IFFALSE 25366
// result := result ^ UnitsInside ( i ) ;
25343: LD_ADDR_VAR 0 2
25347: PUSH
25348: LD_VAR 0 2
25352: PUSH
25353: LD_VAR 0 3
25357: PPUSH
25358: CALL_OW 313
25362: ADD
25363: ST_TO_ADDR
25364: GO 25340
25366: POP
25367: POP
// end ;
25368: LD_VAR 0 2
25372: RET
// export function add ( list , list1 ) ; begin
25373: LD_INT 0
25375: PPUSH
// if list = 0 then
25376: LD_VAR 0 1
25380: PUSH
25381: LD_INT 0
25383: EQUAL
25384: IFFALSE 25393
// list := [ ] ;
25386: LD_ADDR_VAR 0 1
25390: PUSH
25391: EMPTY
25392: ST_TO_ADDR
// if list1 = 0 then
25393: LD_VAR 0 2
25397: PUSH
25398: LD_INT 0
25400: EQUAL
25401: IFFALSE 25410
// list1 := [ ] ;
25403: LD_ADDR_VAR 0 2
25407: PUSH
25408: EMPTY
25409: ST_TO_ADDR
// result := list ^ list1 ;
25410: LD_ADDR_VAR 0 3
25414: PUSH
25415: LD_VAR 0 1
25419: PUSH
25420: LD_VAR 0 2
25424: ADD
25425: ST_TO_ADDR
// end ;
25426: LD_VAR 0 3
25430: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
25431: LD_INT 0
25433: PPUSH
// if not hinty_co_byli then
25434: LD_EXP 86
25438: NOT
25439: IFFALSE 25448
// hinty_co_byli := [ ] ;
25441: LD_ADDR_EXP 86
25445: PUSH
25446: EMPTY
25447: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
25448: LD_VAR 0 1
25452: PUSH
25453: LD_EXP 86
25457: IN
25458: NOT
25459: IFFALSE 25486
// begin hinty_co_byli := hinty_co_byli ^ ident ;
25461: LD_ADDR_EXP 86
25465: PUSH
25466: LD_EXP 86
25470: PUSH
25471: LD_VAR 0 1
25475: ADD
25476: ST_TO_ADDR
// Hint ( ident ) ;
25477: LD_VAR 0 1
25481: PPUSH
25482: CALL_OW 339
// end ; end ; end_of_file
25486: LD_VAR 0 2
25490: RET
// every 0 0$2 + 0 0$0.1 do
25491: GO 25493
25493: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25494: LD_INT 22
25496: PUSH
25497: LD_INT 3
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: PUSH
25504: LD_INT 2
25506: PUSH
25507: LD_INT 25
25509: PUSH
25510: LD_INT 12
25512: PUSH
25513: EMPTY
25514: LIST
25515: LIST
25516: PUSH
25517: LD_INT 25
25519: PUSH
25520: LD_INT 16
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PUSH
25527: LD_INT 25
25529: PUSH
25530: LD_INT 15
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: PUSH
25537: LD_INT 25
25539: PUSH
25540: LD_INT 17
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: LIST
25551: LIST
25552: LIST
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PPUSH
25558: CALL_OW 69
25562: PUSH
25563: LD_INT 22
25565: PUSH
25566: LD_INT 3
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 21
25575: PUSH
25576: LD_INT 1
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: LD_INT 3
25585: PUSH
25586: LD_INT 2
25588: PUSH
25589: LD_INT 25
25591: PUSH
25592: LD_INT 12
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: LD_INT 25
25601: PUSH
25602: LD_INT 16
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 25
25611: PUSH
25612: LD_INT 15
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 25
25621: PUSH
25622: LD_INT 17
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: LIST
25644: PPUSH
25645: CALL_OW 69
25649: GREATER
25650: IFFALSE 25661
// begin SetAchievement ( ACH_POTA ) ;
25652: LD_STRING ACH_POTA
25654: PPUSH
25655: CALL_OW 543
// exit ;
25659: GO 25662
// end ; enable ;
25661: ENABLE
// end ;
25662: END

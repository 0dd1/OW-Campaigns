// export you , americans , arabians , neutral , you2 ; export rulive , apemans ; export DefendLast ; export action_was_fast , breaked_trough ; export Stevens_killed ; export wait_while ; export mcdef_difficulty ; export depot ; export mezera_mezi_minami ; export pocet_min ; export breaketrough_time ; export first_attack ; export sol , mor , sci , mec , eng , rmec ; export cargo , scout , attack , defence , remote ; export to_defence , to_attack , to_scout , to_cargo , to_remote ; export vodni_utok , normal1_utok , normal2_utok , normal3_utok , normal4_utok ; export fact1 , dep1 , lab1 ; export fort ; export ape_agress ; export first_apeman_tamed ; export dialogy , canlost , debug ; export StevensStayInBase ; starting begin dialogy := true ;
   0: LD_ADDR_EXP 46
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// canlost := true ;
   8: LD_ADDR_EXP 47
  12: PUSH
  13: LD_INT 1
  15: ST_TO_ADDR
// debug := false ;
  16: LD_ADDR_EXP 48
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// disable ( 99 ) ;
  24: LD_INT 99
  26: DISABLE_MARKED
// stevens_killed := false ;
  27: LD_ADDR_EXP 11
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// StevensStayInBase = 0 ;
  35: LD_ADDR_EXP 49
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// RemoveUnit ( Mastodon ) ;
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 64
// set_sides ;
  50: CALL 253 0 0
// set_difficulty ;
  54: CALL 96 0 0
// load_chars ;
  58: CALL 828 0 0
// place_apes ;
  62: CALL 1525 0 0
// place_in_ru_cars ;
  66: CALL 1186 0 0
// place_ru_cars ( ru_place2 ) ;
  70: LD_INT 18
  72: PPUSH
  73: CALL 1805 0 1
// create_arabs_scout ;
  77: CALL 19786 0 0
// if dialogy then
  81: LD_EXP 46
  85: IFFALSE 91
// DIntro ;
  87: CALL 2704 0 0
// place_arabs_base ;
  91: CALL 10166 0 0
// end ;
  95: END
// function set_difficulty ; begin
  96: LD_INT 0
  98: PPUSH
// mcdef_difficulty := [ 170 , 200 , 130 ] [ difficulty ] ;
  99: LD_ADDR_EXP 13
 103: PUSH
 104: LD_INT 170
 106: PUSH
 107: LD_INT 200
 109: PUSH
 110: LD_INT 130
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: ST_TO_ADDR
// breaketrough_time := [ 72 72$0 , 55 55$0 , 35 35$0 ] [ difficulty ] ;
 124: LD_ADDR_EXP 17
 128: PUSH
 129: LD_INT 151200
 131: PUSH
 132: LD_INT 115500
 134: PUSH
 135: LD_INT 73500
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: PUSH
 143: LD_OWVAR 67
 147: ARRAY
 148: ST_TO_ADDR
// mezera_mezi_minami := [ 4 4$0 , 2 2$0 , 1 1$0 ] [ difficulty ] ;
 149: LD_ADDR_EXP 15
 153: PUSH
 154: LD_INT 8400
 156: PUSH
 157: LD_INT 4200
 159: PUSH
 160: LD_INT 2100
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: ST_TO_ADDR
// pocet_min := [ 1 , 2 , 3 ] [ difficulty ] ;
 174: LD_ADDR_EXP 16
 178: PUSH
 179: LD_INT 1
 181: PUSH
 182: LD_INT 2
 184: PUSH
 185: LD_INT 3
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// ape_agress := [ [ - 15 , - 10 ] , [ - 2 , 2 ] , [ 2 , 15 ] ] [ difficulty ] ;
 199: LD_ADDR_EXP 44
 203: PUSH
 204: LD_INT 15
 206: NEG
 207: PUSH
 208: LD_INT 10
 210: NEG
 211: PUSH
 212: EMPTY
 213: LIST
 214: LIST
 215: PUSH
 216: LD_INT 2
 218: NEG
 219: PUSH
 220: LD_INT 2
 222: PUSH
 223: EMPTY
 224: LIST
 225: LIST
 226: PUSH
 227: LD_INT 2
 229: PUSH
 230: LD_INT 15
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: PUSH
 242: LD_OWVAR 67
 246: ARRAY
 247: ST_TO_ADDR
// end ;
 248: LD_VAR 0 1
 252: RET
// function set_sides ; begin
 253: LD_INT 0
 255: PPUSH
// you := 3 ;
 256: LD_ADDR_EXP 1
 260: PUSH
 261: LD_INT 3
 263: ST_TO_ADDR
// you2 := 6 ;
 264: LD_ADDR_EXP 5
 268: PUSH
 269: LD_INT 6
 271: ST_TO_ADDR
// americans := 1 ;
 272: LD_ADDR_EXP 2
 276: PUSH
 277: LD_INT 1
 279: ST_TO_ADDR
// arabians := 2 ;
 280: LD_ADDR_EXP 3
 284: PUSH
 285: LD_INT 2
 287: ST_TO_ADDR
// neutral := 0 ;
 288: LD_ADDR_EXP 4
 292: PUSH
 293: LD_INT 0
 295: ST_TO_ADDR
// end ;
 296: LD_VAR 0 1
 300: RET
// export function Vyhra ; begin
 301: LD_INT 0
 303: PPUSH
// set_medals ;
 304: CALL 374 0 0
// GiveMedals ( Main ) ;
 308: LD_STRING Main
 310: PPUSH
 311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ) ;
 315: LD_INT 22
 317: PUSH
 318: LD_EXP 1
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PUSH
 327: LD_INT 21
 329: PUSH
 330: LD_INT 1
 332: PUSH
 333: EMPTY
 334: LIST
 335: LIST
 336: PUSH
 337: LD_INT 23
 339: PUSH
 340: LD_INT 3
 342: PUSH
 343: EMPTY
 344: LIST
 345: LIST
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: PPUSH
 352: CALL_OW 69
 356: PPUSH
 357: CALL_OW 43
// Save ;
 361: CALL 2020 0 0
// YouWin ;
 365: CALL_OW 103
// end ;
 369: LD_VAR 0 1
 373: RET
// export function set_medals ; var medal1 , medal2 , medal3 ; begin
 374: LD_INT 0
 376: PPUSH
 377: PPUSH
 378: PPUSH
 379: PPUSH
// medal1 := action_was_fast > 0 ;
 380: LD_ADDR_VAR 0 2
 384: PUSH
 385: LD_EXP 9
 389: PUSH
 390: LD_INT 0
 392: GREATER
 393: ST_TO_ADDR
// medal2 := first_apeman_tamed > 0 ;
 394: LD_ADDR_VAR 0 3
 398: PUSH
 399: LD_EXP 45
 403: PUSH
 404: LD_INT 0
 406: GREATER
 407: ST_TO_ADDR
// medal3 := IsDead ( Omar ) ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_EXP 61
 417: PPUSH
 418: CALL_OW 301
 422: ST_TO_ADDR
// SA_EndMission ( 3 , 5 , medal1 , medal2 , medal3 ) ;
 423: LD_INT 3
 425: PPUSH
 426: LD_INT 5
 428: PPUSH
 429: LD_VAR 0 2
 433: PPUSH
 434: LD_VAR 0 3
 438: PPUSH
 439: LD_VAR 0 4
 443: PPUSH
 444: CALL 25765 0 5
// AddMedal ( Time , action_was_fast ) ;
 448: LD_STRING Time
 450: PPUSH
 451: LD_EXP 9
 455: PPUSH
 456: CALL_OW 101
// if first_apeman_tamed then
 460: LD_EXP 45
 464: IFFALSE 478
// AddMedal ( Apemen , 1 ) else
 466: LD_STRING Apemen
 468: PPUSH
 469: LD_INT 1
 471: PPUSH
 472: CALL_OW 101
 476: GO 520
// begin if GetTech ( tech_ApeLang , you ) = state_researched then
 478: LD_INT 1
 480: PPUSH
 481: LD_EXP 1
 485: PPUSH
 486: CALL_OW 321
 490: PUSH
 491: LD_INT 2
 493: EQUAL
 494: IFFALSE 509
// AddMedal ( Apemen , - 1 ) else
 496: LD_STRING Apemen
 498: PPUSH
 499: LD_INT 1
 501: NEG
 502: PPUSH
 503: CALL_OW 101
 507: GO 520
// AddMedal ( Apemen , - 2 ) ;
 509: LD_STRING Apemen
 511: PPUSH
 512: LD_INT 2
 514: NEG
 515: PPUSH
 516: CALL_OW 101
// end ; AddMedal ( Abdul , IsDead ( Omar ) ) ;
 520: LD_STRING Abdul
 522: PPUSH
 523: LD_EXP 61
 527: PPUSH
 528: CALL_OW 301
 532: PPUSH
 533: CALL_OW 101
// end ;
 537: LD_VAR 0 1
 541: RET
// every 0 0$7 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) < 6 do
 542: LD_INT 22
 544: PUSH
 545: LD_EXP 1
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: PUSH
 554: LD_INT 21
 556: PUSH
 557: LD_INT 1
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: PUSH
 564: LD_INT 23
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: PUSH
 574: EMPTY
 575: LIST
 576: LIST
 577: LIST
 578: PPUSH
 579: CALL_OW 69
 583: PUSH
 584: LD_INT 6
 586: LESS
 587: IFFALSE 605
 589: GO 591
 591: DISABLE
// begin if canlost then
 592: LD_EXP 47
 596: IFFALSE 605
// YouLost ( Survive ) ;
 598: LD_STRING Survive
 600: PPUSH
 601: CALL_OW 104
// end ;
 605: END
// every 0 0$1 do
 606: GO 608
 608: DISABLE
// begin if debug then
 609: LD_EXP 48
 613: IFFALSE 826
// display_strings := [ [ cas:  & ( tick div 1 1$0 ) & : & ( ( tick mod 1 1$0 ) div 0 0$1 ) ] , [ mines , mines ] , [ crates , crates ] , [ attack , attack ] , [ defence , defence ] , [ sol , sol ] , [ mor , mor ] , [ eng , eng ] , [ mec , mec ] , [ sci , sci ] , [ brk_cars , brk_cars ] , [ opravit , opravit ] , [ stavi , stavi ] , [ todef1 , todef1 ] ] ;
 615: LD_ADDR_OWVAR 47
 619: PUSH
 620: LD_STRING cas: 
 622: PUSH
 623: LD_OWVAR 1
 627: PUSH
 628: LD_INT 2100
 630: DIV
 631: STR
 632: PUSH
 633: LD_STRING :
 635: STR
 636: PUSH
 637: LD_OWVAR 1
 641: PUSH
 642: LD_INT 2100
 644: MOD
 645: PUSH
 646: LD_INT 35
 648: DIV
 649: STR
 650: PUSH
 651: EMPTY
 652: LIST
 653: PUSH
 654: LD_STRING mines
 656: PUSH
 657: LD_EXP 72
 661: PUSH
 662: EMPTY
 663: LIST
 664: LIST
 665: PUSH
 666: LD_STRING crates
 668: PUSH
 669: LD_EXP 85
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: PUSH
 678: LD_STRING attack
 680: PUSH
 681: LD_EXP 27
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: PUSH
 690: LD_STRING defence
 692: PUSH
 693: LD_EXP 28
 697: PUSH
 698: EMPTY
 699: LIST
 700: LIST
 701: PUSH
 702: LD_STRING sol
 704: PUSH
 705: LD_EXP 19
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: PUSH
 714: LD_STRING mor
 716: PUSH
 717: LD_EXP 20
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_STRING eng
 728: PUSH
 729: LD_EXP 23
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: PUSH
 738: LD_STRING mec
 740: PUSH
 741: LD_EXP 22
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: PUSH
 750: LD_STRING sci
 752: PUSH
 753: LD_EXP 21
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: PUSH
 762: LD_STRING brk_cars
 764: PUSH
 765: LD_EXP 74
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: PUSH
 774: LD_STRING opravit
 776: PUSH
 777: LD_EXP 73
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: PUSH
 786: LD_STRING stavi
 788: PUSH
 789: LD_EXP 68
 793: PUSH
 794: EMPTY
 795: LIST
 796: LIST
 797: PUSH
 798: LD_STRING todef1
 800: PUSH
 801: LD_EXP 83
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: LIST
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: ST_TO_ADDR
// enable ;
 826: ENABLE
// end ; end_of_file
 827: END
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Stevens , Heike , Omar ; export used , ru_cars ; export function load_chars ; var i ; begin
 828: LD_INT 0
 830: PPUSH
 831: PPUSH
// InitUc ;
 832: CALL_OW 18
// InitHc ;
 836: CALL_OW 19
// uc_side := you ;
 840: LD_ADDR_OWVAR 20
 844: PUSH
 845: LD_EXP 1
 849: ST_TO_ADDR
// uc_nation := nation_russian ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_INT 3
 857: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
 858: LD_ADDR_EXP 51
 862: PUSH
 863: LD_STRING Platonov
 865: PPUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_INT 1
 871: PPUSH
 872: CALL 1848 0 3
 876: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
 877: LD_ADDR_EXP 50
 881: PUSH
 882: LD_STRING Burlak
 884: PPUSH
 885: LD_INT 3
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 1848 0 3
 895: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , class_soldier , true ) ;
 896: LD_ADDR_EXP 56
 900: PUSH
 901: LD_STRING Titov
 903: PPUSH
 904: LD_INT 1
 906: PPUSH
 907: LD_INT 1
 909: PPUSH
 910: CALL 1848 0 3
 914: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , class_scientistic , true ) ;
 915: LD_ADDR_EXP 57
 919: PUSH
 920: LD_STRING Dolgov
 922: PPUSH
 923: LD_INT 4
 925: PPUSH
 926: LD_INT 1
 928: PPUSH
 929: CALL 1848 0 3
 933: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , class_soldier , true ) ;
 934: LD_ADDR_EXP 58
 938: PUSH
 939: LD_STRING Lipshchin
 941: PPUSH
 942: LD_INT 1
 944: PPUSH
 945: LD_INT 1
 947: PPUSH
 948: CALL 1848 0 3
 952: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , class_engineer , true ) ;
 953: LD_ADDR_EXP 52
 957: PUSH
 958: LD_STRING Karamazov
 960: PPUSH
 961: LD_INT 2
 963: PPUSH
 964: LD_INT 1
 966: PPUSH
 967: CALL 1848 0 3
 971: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , class_soldier , true ) ;
 972: LD_ADDR_EXP 53
 976: PUSH
 977: LD_STRING Petrovova
 979: PPUSH
 980: LD_INT 1
 982: PPUSH
 983: LD_INT 1
 985: PPUSH
 986: CALL 1848 0 3
 990: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , true ) ;
 991: LD_ADDR_EXP 54
 995: PUSH
 996: LD_STRING Gleb
 998: PPUSH
 999: LD_INT 1
1001: PPUSH
1002: LD_INT 1
1004: PPUSH
1005: CALL 1848 0 3
1009: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , class_scientistic , true ) ;
1010: LD_ADDR_EXP 55
1014: PUSH
1015: LD_STRING Petrosyan
1017: PPUSH
1018: LD_INT 4
1020: PPUSH
1021: LD_INT 1
1023: PPUSH
1024: CALL 1848 0 3
1028: ST_TO_ADDR
// used := [ Burlak , Lipshchin , Titov , Dolgov , Karamazov , Petrovova , Gleb , Petrosyan ] diff 0 ;
1029: LD_ADDR_EXP 62
1033: PUSH
1034: LD_EXP 50
1038: PUSH
1039: LD_EXP 58
1043: PUSH
1044: LD_EXP 56
1048: PUSH
1049: LD_EXP 57
1053: PUSH
1054: LD_EXP 52
1058: PUSH
1059: LD_EXP 53
1063: PUSH
1064: LD_EXP 54
1068: PUSH
1069: LD_EXP 55
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 0
1086: DIFF
1087: ST_TO_ADDR
// uc_side := americans ;
1088: LD_ADDR_OWVAR 20
1092: PUSH
1093: LD_EXP 2
1097: ST_TO_ADDR
// uc_nation := nation_american ;
1098: LD_ADDR_OWVAR 21
1102: PUSH
1103: LD_INT 1
1105: ST_TO_ADDR
// Stevens := MyCreateCharacter ( Stevens , class_scientistic , true ) ;
1106: LD_ADDR_EXP 59
1110: PUSH
1111: LD_STRING Stevens
1113: PPUSH
1114: LD_INT 4
1116: PPUSH
1117: LD_INT 1
1119: PPUSH
1120: CALL 1848 0 3
1124: ST_TO_ADDR
// uc_side := arabians ;
1125: LD_ADDR_OWVAR 20
1129: PUSH
1130: LD_EXP 3
1134: ST_TO_ADDR
// uc_nation := nation_arabian ;
1135: LD_ADDR_OWVAR 21
1139: PUSH
1140: LD_INT 2
1142: ST_TO_ADDR
// Heike := MyCreateCharacter ( Heike , class_soldier , true ) ;
1143: LD_ADDR_EXP 60
1147: PUSH
1148: LD_STRING Heike
1150: PPUSH
1151: LD_INT 1
1153: PPUSH
1154: LD_INT 1
1156: PPUSH
1157: CALL 1848 0 3
1161: ST_TO_ADDR
// Omar := MyCreateCharacter ( Omar , class_desert_warior , true ) ;
1162: LD_ADDR_EXP 61
1166: PUSH
1167: LD_STRING Omar
1169: PPUSH
1170: LD_INT 11
1172: PPUSH
1173: LD_INT 1
1175: PPUSH
1176: CALL 1848 0 3
1180: ST_TO_ADDR
// end ;
1181: LD_VAR 0 1
1185: RET
// export function place_in_ru_cars ; var cars , car , i ; begin
1186: LD_INT 0
1188: PPUSH
1189: PPUSH
1190: PPUSH
1191: PPUSH
// cars := [ [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] ] ;
1192: LD_ADDR_VAR 0 2
1196: PUSH
1197: LD_INT 22
1199: PUSH
1200: LD_INT 42
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 22
1209: PUSH
1210: LD_INT 42
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PUSH
1217: LD_INT 22
1219: PUSH
1220: LD_INT 42
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 42
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 22
1239: PUSH
1240: LD_INT 42
1242: PUSH
1243: EMPTY
1244: LIST
1245: LIST
1246: PUSH
1247: LD_INT 22
1249: PUSH
1250: LD_INT 42
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: PUSH
1257: LD_INT 22
1259: PUSH
1260: LD_INT 42
1262: PUSH
1263: EMPTY
1264: LIST
1265: LIST
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 42
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: EMPTY
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: ST_TO_ADDR
// InitUc ;
1287: CALL_OW 18
// InitVc ;
1291: CALL_OW 20
// vc_control := control_manual ;
1295: LD_ADDR_OWVAR 38
1299: PUSH
1300: LD_INT 1
1302: ST_TO_ADDR
// vc_engine := engine_combustion ;
1303: LD_ADDR_OWVAR 39
1307: PUSH
1308: LD_INT 1
1310: ST_TO_ADDR
// uc_side := you ;
1311: LD_ADDR_OWVAR 20
1315: PUSH
1316: LD_EXP 1
1320: ST_TO_ADDR
// uc_nation := nation_russian ;
1321: LD_ADDR_OWVAR 21
1325: PUSH
1326: LD_INT 3
1328: ST_TO_ADDR
// ru_cars := [ ] ;
1329: LD_ADDR_EXP 63
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// for i := 1 to 8 do
1336: LD_ADDR_VAR 0 4
1340: PUSH
1341: DOUBLE
1342: LD_INT 1
1344: DEC
1345: ST_TO_ADDR
1346: LD_INT 8
1348: PUSH
1349: FOR_TO
1350: IFFALSE 1518
// begin vc_chassis := cars [ i ] [ 1 ] ;
1352: LD_ADDR_OWVAR 37
1356: PUSH
1357: LD_VAR 0 2
1361: PUSH
1362: LD_VAR 0 4
1366: ARRAY
1367: PUSH
1368: LD_INT 1
1370: ARRAY
1371: ST_TO_ADDR
// vc_weapon := cars [ i ] [ 2 ] ;
1372: LD_ADDR_OWVAR 40
1376: PUSH
1377: LD_VAR 0 2
1381: PUSH
1382: LD_VAR 0 4
1386: ARRAY
1387: PUSH
1388: LD_INT 2
1390: ARRAY
1391: ST_TO_ADDR
// uc_direction := Rand ( 3 , 4 ) ;
1392: LD_ADDR_OWVAR 24
1396: PUSH
1397: LD_INT 3
1399: PPUSH
1400: LD_INT 4
1402: PPUSH
1403: CALL_OW 12
1407: ST_TO_ADDR
// vc_fuel_battery := Rand ( 25 , 40 ) ;
1408: LD_ADDR_OWVAR 41
1412: PUSH
1413: LD_INT 25
1415: PPUSH
1416: LD_INT 40
1418: PPUSH
1419: CALL_OW 12
1423: ST_TO_ADDR
// car := CreateVehicle ;
1424: LD_ADDR_VAR 0 3
1428: PUSH
1429: CALL_OW 45
1433: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1434: LD_ADDR_EXP 63
1438: PUSH
1439: LD_EXP 63
1443: PUSH
1444: LD_VAR 0 3
1448: ADD
1449: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1450: LD_EXP 62
1454: PUSH
1455: LD_VAR 0 4
1459: ARRAY
1460: PPUSH
1461: LD_VAR 0 3
1465: PPUSH
1466: CALL_OW 52
// SetLives ( car , Rand ( 251 , 800 ) ) ;
1470: LD_VAR 0 3
1474: PPUSH
1475: LD_INT 251
1477: PPUSH
1478: LD_INT 800
1480: PPUSH
1481: CALL_OW 12
1485: PPUSH
1486: CALL_OW 234
// SetLives ( used [ i ] , Rand ( 900 , 1000 ) ) ;
1490: LD_EXP 62
1494: PUSH
1495: LD_VAR 0 4
1499: ARRAY
1500: PPUSH
1501: LD_INT 900
1503: PPUSH
1504: LD_INT 1000
1506: PPUSH
1507: CALL_OW 12
1511: PPUSH
1512: CALL_OW 234
// end ;
1516: GO 1349
1518: POP
1519: POP
// end ;
1520: LD_VAR 0 1
1524: RET
// export function place_apes ; var o1 , o2 , o3 , o4 ; begin
1525: LD_INT 0
1527: PPUSH
1528: PPUSH
1529: PPUSH
1530: PPUSH
1531: PPUSH
// InitHc ;
1532: CALL_OW 19
// InitUc ;
1536: CALL_OW 18
// uc_side := 0 ;
1540: LD_ADDR_OWVAR 20
1544: PUSH
1545: LD_INT 0
1547: ST_TO_ADDR
// uc_nation := nation_nature ;
1548: LD_ADDR_OWVAR 21
1552: PUSH
1553: LD_INT 0
1555: ST_TO_ADDR
// hc_class := class_apeman ;
1556: LD_ADDR_OWVAR 28
1560: PUSH
1561: LD_INT 12
1563: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1564: LD_ADDR_OWVAR 35
1568: PUSH
1569: LD_EXP 44
1573: PUSH
1574: LD_INT 1
1576: ARRAY
1577: PPUSH
1578: LD_EXP 44
1582: PUSH
1583: LD_INT 2
1585: ARRAY
1586: PPUSH
1587: CALL_OW 12
1591: ST_TO_ADDR
// o1 := CreateHuman ;
1592: LD_ADDR_VAR 0 2
1596: PUSH
1597: CALL_OW 44
1601: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1602: LD_ADDR_OWVAR 35
1606: PUSH
1607: LD_EXP 44
1611: PUSH
1612: LD_INT 1
1614: ARRAY
1615: PPUSH
1616: LD_EXP 44
1620: PUSH
1621: LD_INT 2
1623: ARRAY
1624: PPUSH
1625: CALL_OW 12
1629: ST_TO_ADDR
// o2 := CreateHuman ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: CALL_OW 44
1639: ST_TO_ADDR
// hc_agressivity := - 5 ;
1640: LD_ADDR_OWVAR 35
1644: PUSH
1645: LD_INT 5
1647: NEG
1648: ST_TO_ADDR
// o3 := CreateHuman ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: CALL_OW 44
1658: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1659: LD_ADDR_OWVAR 35
1663: PUSH
1664: LD_EXP 44
1668: PUSH
1669: LD_INT 1
1671: ARRAY
1672: PPUSH
1673: LD_EXP 44
1677: PUSH
1678: LD_INT 2
1680: ARRAY
1681: PPUSH
1682: CALL_OW 12
1686: ST_TO_ADDR
// o4 := CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: CALL_OW 44
1696: ST_TO_ADDR
// PlaceUnitXY ( o1 , 10 , 14 , false ) ;
1697: LD_VAR 0 2
1701: PPUSH
1702: LD_INT 10
1704: PPUSH
1705: LD_INT 14
1707: PPUSH
1708: LD_INT 0
1710: PPUSH
1711: CALL_OW 48
// PlaceUnitXY ( o2 , 17 , 22 , false ) ;
1715: LD_VAR 0 3
1719: PPUSH
1720: LD_INT 17
1722: PPUSH
1723: LD_INT 22
1725: PPUSH
1726: LD_INT 0
1728: PPUSH
1729: CALL_OW 48
// PlaceUnitXY ( o3 , 16 , 11 , false ) ;
1733: LD_VAR 0 4
1737: PPUSH
1738: LD_INT 16
1740: PPUSH
1741: LD_INT 11
1743: PPUSH
1744: LD_INT 0
1746: PPUSH
1747: CALL_OW 48
// PlaceUnitXY ( o4 , 84 , 7 , false ) ;
1751: LD_VAR 0 5
1755: PPUSH
1756: LD_INT 84
1758: PPUSH
1759: LD_INT 7
1761: PPUSH
1762: LD_INT 0
1764: PPUSH
1765: CALL_OW 48
// apemans := [ o1 , o2 , o3 , o4 ] ;
1769: LD_ADDR_EXP 7
1773: PUSH
1774: LD_VAR 0 2
1778: PUSH
1779: LD_VAR 0 3
1783: PUSH
1784: LD_VAR 0 4
1788: PUSH
1789: LD_VAR 0 5
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: ST_TO_ADDR
// end ;
1800: LD_VAR 0 1
1804: RET
// export function place_ru_cars ( area ) ; var i ; begin
1805: LD_INT 0
1807: PPUSH
1808: PPUSH
// for i in ru_cars do
1809: LD_ADDR_VAR 0 3
1813: PUSH
1814: LD_EXP 63
1818: PUSH
1819: FOR_IN
1820: IFFALSE 1841
// PlaceUnitArea ( i , area , false ) ;
1822: LD_VAR 0 3
1826: PPUSH
1827: LD_VAR 0 1
1831: PPUSH
1832: LD_INT 0
1834: PPUSH
1835: CALL_OW 49
1839: GO 1819
1841: POP
1842: POP
// end ;
1843: LD_VAR 0 2
1847: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
1848: LD_INT 0
1850: PPUSH
// if new or TestCharacters ( name ) then
1851: LD_VAR 0 3
1855: PUSH
1856: LD_VAR 0 1
1860: PPUSH
1861: CALL_OW 28
1865: OR
1866: IFFALSE 1949
// begin if new then
1868: LD_VAR 0 3
1872: IFFALSE 1891
// result := NewCharacter ( name ) else
1874: LD_ADDR_VAR 0 4
1878: PUSH
1879: LD_VAR 0 1
1883: PPUSH
1884: CALL_OW 25
1888: ST_TO_ADDR
1889: GO 1927
// begin if CheckCharacterSet ( name ) then
1891: LD_VAR 0 1
1895: PPUSH
1896: CALL_OW 29
1900: IFFALSE 1919
// result := CreateCharacter ( name ) else
1902: LD_ADDR_VAR 0 4
1906: PUSH
1907: LD_VAR 0 1
1911: PPUSH
1912: CALL_OW 34
1916: ST_TO_ADDR
1917: GO 1927
// result := 0 ;
1919: LD_ADDR_VAR 0 4
1923: PUSH
1924: LD_INT 0
1926: ST_TO_ADDR
// end ; if unclass then
1927: LD_VAR 0 2
1931: IFFALSE 1947
// SetClass ( result , unclass ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_VAR 0 2
1942: PPUSH
1943: CALL_OW 336
// end else
1947: GO 2015
// begin Msg ( Chybi  & name & ! ) ;
1949: LD_STRING Chybi 
1951: PUSH
1952: LD_VAR 0 1
1956: STR
1957: PUSH
1958: LD_STRING !
1960: STR
1961: PPUSH
1962: CALL_OW 100
// hc_name := name ;
1966: LD_ADDR_OWVAR 26
1970: PUSH
1971: LD_VAR 0 1
1975: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
1976: LD_INT 1
1978: PPUSH
1979: LD_INT 0
1981: PPUSH
1982: LD_INT 3
1984: PPUSH
1985: CALL_OW 380
// if unclass then
1989: LD_VAR 0 2
1993: IFFALSE 2005
// hc_class := unclass ;
1995: LD_ADDR_OWVAR 28
1999: PUSH
2000: LD_VAR 0 2
2004: ST_TO_ADDR
// result := CreateHuman ;
2005: LD_ADDR_VAR 0 4
2009: PUSH
2010: CALL_OW 44
2014: ST_TO_ADDR
// end ; end ;
2015: LD_VAR 0 4
2019: RET
// export function Save ; var cars , i , cargotype ; begin
2020: LD_INT 0
2022: PPUSH
2023: PPUSH
2024: PPUSH
2025: PPUSH
// if not IsDead ( Omar ) then
2026: LD_EXP 61
2030: PPUSH
2031: CALL_OW 301
2035: NOT
2036: IFFALSE 2050
// SaveCharacters ( Omar , Omar ) ;
2038: LD_EXP 61
2042: PPUSH
2043: LD_STRING Omar
2045: PPUSH
2046: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
2050: LD_EXP 50
2054: PPUSH
2055: LD_STRING Burlak
2057: PPUSH
2058: CALL_OW 38
// if not IsInUnit ( Titov ) then
2062: LD_EXP 56
2066: PPUSH
2067: CALL_OW 310
2071: NOT
2072: IFFALSE 2086
// SetLives ( Titov , 0 ) ;
2074: LD_EXP 56
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 234
// if not IsInUnit ( Dolgov ) then
2086: LD_EXP 57
2090: PPUSH
2091: CALL_OW 310
2095: NOT
2096: IFFALSE 2110
// SetLives ( Dolgov , 0 ) ;
2098: LD_EXP 57
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 234
// if not IsInUnit ( Lipshchin ) then
2110: LD_EXP 58
2114: PPUSH
2115: CALL_OW 310
2119: NOT
2120: IFFALSE 2134
// SetLives ( Lipshchin , 0 ) ;
2122: LD_EXP 58
2126: PPUSH
2127: LD_INT 0
2129: PPUSH
2130: CALL_OW 234
// if not IsInUnit ( Karamazov ) then
2134: LD_EXP 52
2138: PPUSH
2139: CALL_OW 310
2143: NOT
2144: IFFALSE 2158
// SetLives ( Karamazov , 0 ) ;
2146: LD_EXP 52
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: CALL_OW 234
// if not IsInUnit ( Petrovova ) then
2158: LD_EXP 53
2162: PPUSH
2163: CALL_OW 310
2167: NOT
2168: IFFALSE 2182
// SetLives ( Petrovova , 0 ) ;
2170: LD_EXP 53
2174: PPUSH
2175: LD_INT 0
2177: PPUSH
2178: CALL_OW 234
// if not IsInUnit ( Gleb ) then
2182: LD_EXP 54
2186: PPUSH
2187: CALL_OW 310
2191: NOT
2192: IFFALSE 2206
// SetLives ( Gleb , 0 ) ;
2194: LD_EXP 54
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 234
// if not IsInUnit ( Petrosyan ) then
2206: LD_EXP 55
2210: PPUSH
2211: CALL_OW 310
2215: NOT
2216: IFFALSE 2230
// SetLives ( Petrosyan , 0 ) ;
2218: LD_EXP 55
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL_OW 234
// if Titov then
2230: LD_EXP 56
2234: IFFALSE 2248
// SaveCharacters ( Titov , Titov ) ;
2236: LD_EXP 56
2240: PPUSH
2241: LD_STRING Titov
2243: PPUSH
2244: CALL_OW 38
// if Dolgov then
2248: LD_EXP 57
2252: IFFALSE 2266
// SaveCharacters ( Dolgov , Dolgov ) ;
2254: LD_EXP 57
2258: PPUSH
2259: LD_STRING Dolgov
2261: PPUSH
2262: CALL_OW 38
// if Lipshchin then
2266: LD_EXP 58
2270: IFFALSE 2284
// SaveCharacters ( Lipshchin , Lipshchin ) ;
2272: LD_EXP 58
2276: PPUSH
2277: LD_STRING Lipshchin
2279: PPUSH
2280: CALL_OW 38
// if Karamazov then
2284: LD_EXP 52
2288: IFFALSE 2302
// SaveCharacters ( Karamazov , Karamazov ) ;
2290: LD_EXP 52
2294: PPUSH
2295: LD_STRING Karamazov
2297: PPUSH
2298: CALL_OW 38
// if Petrovova then
2302: LD_EXP 53
2306: IFFALSE 2320
// SaveCharacters ( Petrovova , Petrovova ) ;
2308: LD_EXP 53
2312: PPUSH
2313: LD_STRING Petrovova
2315: PPUSH
2316: CALL_OW 38
// if Gleb then
2320: LD_EXP 54
2324: IFFALSE 2338
// SaveCharacters ( Gleb , Gleb ) ;
2326: LD_EXP 54
2330: PPUSH
2331: LD_STRING Gleb
2333: PPUSH
2334: CALL_OW 38
// if Petrosyan then
2338: LD_EXP 55
2342: IFFALSE 2356
// SaveCharacters ( Petrosyan , Petrosyan ) ;
2344: LD_EXP 55
2348: PPUSH
2349: LD_STRING Petrosyan
2351: PPUSH
2352: CALL_OW 38
// SaveVariable ( Stevens_killed , StevensKilled ) ;
2356: LD_EXP 11
2360: PPUSH
2361: LD_STRING StevensKilled
2363: PPUSH
2364: CALL_OW 39
// SaveVariable ( action_was_fast , OvesyenkoTime ) ;
2368: LD_EXP 9
2372: PPUSH
2373: LD_STRING OvesyenkoTime
2375: PPUSH
2376: CALL_OW 39
// SaveVariable ( IsDead ( Omar ) , OmarKilled ) ;
2380: LD_EXP 61
2384: PPUSH
2385: CALL_OW 301
2389: PPUSH
2390: LD_STRING OmarKilled
2392: PPUSH
2393: CALL_OW 39
// cars := [ ] ;
2397: LD_ADDR_VAR 0 2
2401: PUSH
2402: EMPTY
2403: ST_TO_ADDR
// for i in FilterUnitsInArea ( exit_rus , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) do
2404: LD_ADDR_VAR 0 3
2408: PUSH
2409: LD_INT 22
2411: PPUSH
2412: LD_INT 22
2414: PUSH
2415: LD_EXP 1
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: PUSH
2424: LD_INT 21
2426: PUSH
2427: LD_INT 2
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 70
2442: PUSH
2443: FOR_IN
2444: IFFALSE 2534
// begin cargotype := GetCargoType ( i ) ;
2446: LD_ADDR_VAR 0 4
2450: PUSH
2451: LD_VAR 0 3
2455: PPUSH
2456: CALL_OW 288
2460: ST_TO_ADDR
// cars := cars ^ [ [ GetChassis ( i ) , GetWeapon ( i ) , GetNation ( i ) , cargotype , GetCargo ( i , cargotype ) ] ] ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_VAR 0 3
2475: PPUSH
2476: CALL_OW 265
2480: PUSH
2481: LD_VAR 0 3
2485: PPUSH
2486: CALL_OW 264
2490: PUSH
2491: LD_VAR 0 3
2495: PPUSH
2496: CALL_OW 248
2500: PUSH
2501: LD_VAR 0 4
2505: PUSH
2506: LD_VAR 0 3
2510: PPUSH
2511: LD_VAR 0 4
2515: PPUSH
2516: CALL_OW 289
2520: PUSH
2521: EMPTY
2522: LIST
2523: LIST
2524: LIST
2525: LIST
2526: LIST
2527: PUSH
2528: EMPTY
2529: LIST
2530: ADD
2531: ST_TO_ADDR
// end ;
2532: GO 2443
2534: POP
2535: POP
// SaveVariable ( cars , cars_ru_6 ) ;
2536: LD_VAR 0 2
2540: PPUSH
2541: LD_STRING cars_ru_6
2543: PPUSH
2544: CALL_OW 39
// end ; end_of_file
2548: LD_VAR 0 1
2552: RET
// var Bur , Pla , Kar , Ptr , Glb , Pty , Huck , Tit , Lip , Dol ; var donttalk ; function set_shorts ; begin
2553: LD_INT 0
2555: PPUSH
// Bur := Burlak ;
2556: LD_ADDR_LOC 1
2560: PUSH
2561: LD_EXP 50
2565: ST_TO_ADDR
// Dol := Dolgov ;
2566: LD_ADDR_LOC 10
2570: PUSH
2571: LD_EXP 57
2575: ST_TO_ADDR
// Lip := Lipshchin ;
2576: LD_ADDR_LOC 9
2580: PUSH
2581: LD_EXP 58
2585: ST_TO_ADDR
// Tit := Titov ;
2586: LD_ADDR_LOC 8
2590: PUSH
2591: LD_EXP 56
2595: ST_TO_ADDR
// Pla := Platonov ;
2596: LD_ADDR_LOC 2
2600: PUSH
2601: LD_EXP 51
2605: ST_TO_ADDR
// Kar := Karamazov ;
2606: LD_ADDR_LOC 3
2610: PUSH
2611: LD_EXP 52
2615: ST_TO_ADDR
// Ptr := Petrovova ;
2616: LD_ADDR_LOC 4
2620: PUSH
2621: LD_EXP 53
2625: ST_TO_ADDR
// Glb := Gleb ;
2626: LD_ADDR_LOC 5
2630: PUSH
2631: LD_EXP 54
2635: ST_TO_ADDR
// Pty := Petrosyan ;
2636: LD_ADDR_LOC 6
2640: PUSH
2641: LD_EXP 55
2645: ST_TO_ADDR
// Huck := Stevens ;
2646: LD_ADDR_LOC 7
2650: PUSH
2651: LD_EXP 59
2655: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
2656: LD_ADDR_LOC 11
2660: PUSH
2661: LD_EXP 62
2665: PUSH
2666: LD_EXP 50
2670: PUSH
2671: LD_EXP 52
2675: PUSH
2676: LD_EXP 53
2680: PUSH
2681: LD_EXP 54
2685: PUSH
2686: LD_EXP 55
2690: PUSH
2691: EMPTY
2692: LIST
2693: LIST
2694: LIST
2695: LIST
2696: LIST
2697: DIFF
2698: ST_TO_ADDR
// end ;
2699: LD_VAR 0 1
2703: RET
// export function DIntro ; var pos , auta , i , hex , rcars ; begin
2704: LD_INT 0
2706: PPUSH
2707: PPUSH
2708: PPUSH
2709: PPUSH
2710: PPUSH
2711: PPUSH
// pos := [ [ 50 , 39 ] , [ 46 , 42 ] , [ 40 , 50 ] , [ 48 , 57 ] , [ 49 , 59 ] , [ 55 , 70 ] , [ 55 , 73 ] , [ 70 , 86 ] , [ 69 , 83 ] ] ;
2712: LD_ADDR_VAR 0 2
2716: PUSH
2717: LD_INT 50
2719: PUSH
2720: LD_INT 39
2722: PUSH
2723: EMPTY
2724: LIST
2725: LIST
2726: PUSH
2727: LD_INT 46
2729: PUSH
2730: LD_INT 42
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: PUSH
2737: LD_INT 40
2739: PUSH
2740: LD_INT 50
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PUSH
2747: LD_INT 48
2749: PUSH
2750: LD_INT 57
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: PUSH
2757: LD_INT 49
2759: PUSH
2760: LD_INT 59
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PUSH
2767: LD_INT 55
2769: PUSH
2770: LD_INT 70
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 55
2779: PUSH
2780: LD_INT 73
2782: PUSH
2783: EMPTY
2784: LIST
2785: LIST
2786: PUSH
2787: LD_INT 70
2789: PUSH
2790: LD_INT 86
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: LD_INT 69
2799: PUSH
2800: LD_INT 83
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: LIST
2817: ST_TO_ADDR
// set_shorts ;
2818: CALL 2553 0 0
// InGameOn ;
2822: CALL_OW 8
// place_ru_cars ( ru_place2 ) ;
2826: LD_INT 18
2828: PPUSH
2829: CALL 1805 0 1
// RevealFogArea ( you , co_vidi ) ;
2833: LD_EXP 1
2837: PPUSH
2838: LD_INT 19
2840: PPUSH
2841: CALL_OW 332
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
2845: LD_ADDR_VAR 0 3
2849: PUSH
2850: LD_INT 22
2852: PUSH
2853: LD_EXP 1
2857: PUSH
2858: EMPTY
2859: LIST
2860: LIST
2861: PUSH
2862: LD_INT 21
2864: PUSH
2865: LD_INT 2
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: PPUSH
2876: CALL_OW 69
2880: ST_TO_ADDR
// ComMoveToArea ( auta , ru_dojezd ) ;
2881: LD_VAR 0 3
2885: PPUSH
2886: LD_INT 3
2888: PPUSH
2889: CALL_OW 113
// wait ( 0 0$0.1 ) ;
2893: LD_INT 4
2895: PPUSH
2896: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
2900: LD_LOC 1
2904: PPUSH
2905: CALL_OW 310
2909: PPUSH
2910: CALL_OW 87
// while FilterUnitsInArea ( ru_dojezd , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) < 5 do
2914: LD_INT 3
2916: PPUSH
2917: LD_INT 22
2919: PUSH
2920: LD_EXP 1
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 21
2931: PUSH
2932: LD_INT 2
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: PUSH
2939: EMPTY
2940: LIST
2941: LIST
2942: PPUSH
2943: CALL_OW 70
2947: PUSH
2948: LD_INT 5
2950: LESS
2951: IFFALSE 2976
// begin wait ( 0 0$1 ) ;
2953: LD_INT 35
2955: PPUSH
2956: CALL_OW 67
// CenterOnUnits ( IsInUnit ( Bur ) ) ;
2960: LD_LOC 1
2964: PPUSH
2965: CALL_OW 310
2969: PPUSH
2970: CALL_OW 85
// end ;
2974: GO 2914
// DStart ;
2976: CALL 2989 0 0
// InGameOff ;
2980: CALL_OW 9
// end ;
2984: LD_VAR 0 1
2988: RET
// export function DStart ; begin
2989: LD_INT 0
2991: PPUSH
// DialogueOn ;
2992: CALL_OW 6
// ComStop ( FilterAllUnits ( [ [ f_side , you ] ] ) ) ;
2996: LD_INT 22
2998: PUSH
2999: LD_EXP 1
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: EMPTY
3009: LIST
3010: PPUSH
3011: CALL_OW 69
3015: PPUSH
3016: CALL_OW 141
// wait ( 0 0$0.5 ) ;
3020: LD_INT 18
3022: PPUSH
3023: CALL_OW 67
// Say ( Bur , DStart-Bur-1 ) ;
3027: LD_LOC 1
3031: PPUSH
3032: LD_STRING DStart-Bur-1
3034: PPUSH
3035: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-1 ) ;
3039: LD_LOC 2
3043: PPUSH
3044: LD_STRING DStart-Pla-1
3046: PPUSH
3047: CALL_OW 94
// Say ( Bur , DStart-Bur-2 ) ;
3051: LD_LOC 1
3055: PPUSH
3056: LD_STRING DStart-Bur-2
3058: PPUSH
3059: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-2 ) ;
3063: LD_LOC 2
3067: PPUSH
3068: LD_STRING DStart-Pla-2
3070: PPUSH
3071: CALL_OW 94
// SaveForQuickRestart ;
3075: CALL_OW 22
// DialogueOff ;
3079: CALL_OW 7
// ChangeMissionObjectives ( MBegin ) ;
3083: LD_STRING MBegin
3085: PPUSH
3086: CALL_OW 337
// SetAreaMapShow ( exit_rus , 1 ) ;
3090: LD_INT 22
3092: PPUSH
3093: LD_INT 1
3095: PPUSH
3096: CALL_OW 424
// end ;
3100: LD_VAR 0 1
3104: RET
// every 0 0$0.1 trigger dialogy do
3105: LD_EXP 46
3109: IFFALSE 3118
3111: GO 3113
3113: DISABLE
// begin DDoubts ;
3114: CALL 3119 0 0
// end ;
3118: END
// function DDoubts ; var who ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3123: LD_ADDR_VAR 0 2
3127: PUSH
3128: LD_LOC 11
3132: PPUSH
3133: LD_EXP 1
3137: PPUSH
3138: LD_INT 1
3140: PPUSH
3141: LD_INT 0
3143: PPUSH
3144: LD_INT 0
3146: PPUSH
3147: CALL 23597 0 5
3151: ST_TO_ADDR
// if not who then
3152: LD_VAR 0 2
3156: NOT
3157: IFFALSE 3169
// who := Bur ;
3159: LD_ADDR_VAR 0 2
3163: PUSH
3164: LD_LOC 1
3168: ST_TO_ADDR
// if IsLive ( Kar ) or IsLive ( Ptr ) then
3169: LD_LOC 3
3173: PPUSH
3174: CALL_OW 300
3178: PUSH
3179: LD_LOC 4
3183: PPUSH
3184: CALL_OW 300
3188: OR
3189: IFFALSE 3275
// begin DialogueOn ;
3191: CALL_OW 6
// Say ( Kar , DDoubts-Kar-1 ) ;
3195: LD_LOC 3
3199: PPUSH
3200: LD_STRING DDoubts-Kar-1
3202: PPUSH
3203: CALL_OW 88
// Say ( Ptr , DDoubts-Ptr-1 ) ;
3207: LD_LOC 4
3211: PPUSH
3212: LD_STRING DDoubts-Ptr-1
3214: PPUSH
3215: CALL_OW 88
// Say ( who , DDoubts-Bur-1 ) ;
3219: LD_VAR 0 2
3223: PPUSH
3224: LD_STRING DDoubts-Bur-1
3226: PPUSH
3227: CALL_OW 88
// if Say ( Kar , DDoubts-Kar-2 ) then
3231: LD_LOC 3
3235: PPUSH
3236: LD_STRING DDoubts-Kar-2
3238: PPUSH
3239: CALL_OW 88
3243: IFFALSE 3271
// if Say ( Glb , DDoubts-Glb-2 ) then
3245: LD_LOC 5
3249: PPUSH
3250: LD_STRING DDoubts-Glb-2
3252: PPUSH
3253: CALL_OW 88
3257: IFFALSE 3271
// Say ( Bur , DDoubts-Bur-2 ) ;
3259: LD_LOC 1
3263: PPUSH
3264: LD_STRING DDoubts-Bur-2
3266: PPUSH
3267: CALL_OW 88
// DialogueOff ;
3271: CALL_OW 7
// end ; end ;
3275: LD_VAR 0 1
3279: RET
// every 0 0$5 trigger dialogy and ( SeeArea ( you , vidi_je ) or See_any ( you , fort ) ) do
3280: LD_EXP 46
3284: PUSH
3285: LD_EXP 1
3289: PPUSH
3290: LD_INT 24
3292: PPUSH
3293: CALL_OW 294
3297: PUSH
3298: LD_EXP 1
3302: PPUSH
3303: LD_EXP 43
3307: PPUSH
3308: CALL 23798 0 2
3312: OR
3313: AND
3314: IFFALSE 3327
3316: GO 3318
3318: DISABLE
// begin DArabs ;
3319: CALL 3328 0 0
// DSurrender ;
3323: CALL 3450 0 0
// end ;
3327: END
// export function DArabs ; var who ; begin
3328: LD_INT 0
3330: PPUSH
3331: PPUSH
// SetAttitude ( you , arabians , att_enemy , true ) ;
3332: LD_EXP 1
3336: PPUSH
3337: LD_EXP 3
3341: PPUSH
3342: LD_INT 2
3344: PPUSH
3345: LD_INT 1
3347: PPUSH
3348: CALL_OW 80
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3352: LD_ADDR_VAR 0 2
3356: PUSH
3357: LD_LOC 11
3361: PPUSH
3362: LD_EXP 1
3366: PPUSH
3367: LD_INT 1
3369: PPUSH
3370: LD_INT 0
3372: PPUSH
3373: LD_INT 0
3375: PPUSH
3376: CALL 23597 0 5
3380: ST_TO_ADDR
// DialogueOn ;
3381: CALL_OW 6
// Say ( who , DArabs-RSol1-1 ) ;
3385: LD_VAR 0 2
3389: PPUSH
3390: LD_STRING DArabs-RSol1-1
3392: PPUSH
3393: CALL_OW 88
// Say ( Kar , DArabs-Kar-1 ) ;
3397: LD_LOC 3
3401: PPUSH
3402: LD_STRING DArabs-Kar-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Bur , DArabs-Bur-1 ) ;
3409: LD_LOC 1
3413: PPUSH
3414: LD_STRING DArabs-Bur-1
3416: PPUSH
3417: CALL_OW 88
// SayRadio ( Pla , DArabs-Pla-1 ) ;
3421: LD_LOC 2
3425: PPUSH
3426: LD_STRING DArabs-Pla-1
3428: PPUSH
3429: CALL_OW 94
// DialogueOff ;
3433: CALL_OW 7
// DefendLast := true ;
3437: LD_ADDR_EXP 8
3441: PUSH
3442: LD_INT 1
3444: ST_TO_ADDR
// end ;
3445: LD_VAR 0 1
3449: RET
// function DSurrender ; var qr ; begin
3450: LD_INT 0
3452: PPUSH
3453: PPUSH
// DialogueOn ;
3454: CALL_OW 6
// Say ( Omar , DSurrender-Omar-1 ) ;
3458: LD_EXP 61
3462: PPUSH
3463: LD_STRING DSurrender-Omar-1
3465: PPUSH
3466: CALL_OW 88
// qr := Query ( QSurrender ) ;
3470: LD_ADDR_VAR 0 2
3474: PUSH
3475: LD_STRING QSurrender
3477: PPUSH
3478: CALL_OW 97
3482: ST_TO_ADDR
// case qr of 1 :
3483: LD_VAR 0 2
3487: PUSH
3488: LD_INT 1
3490: DOUBLE
3491: EQUAL
3492: IFTRUE 3496
3494: GO 3503
3496: POP
// DQrSurrender_1 ; 2 :
3497: CALL 3543 0 0
3501: GO 3534
3503: LD_INT 2
3505: DOUBLE
3506: EQUAL
3507: IFTRUE 3511
3509: GO 3518
3511: POP
// DQrSurrender_2 ; 3 :
3512: CALL 3570 0 0
3516: GO 3534
3518: LD_INT 3
3520: DOUBLE
3521: EQUAL
3522: IFTRUE 3526
3524: GO 3533
3526: POP
// DQrSurrender_3 ; end ;
3527: CALL 3598 0 0
3531: GO 3534
3533: POP
// DialogueOff ;
3534: CALL_OW 7
// end ;
3538: LD_VAR 0 1
3542: RET
// function DQrSurrender_1 ; begin
3543: LD_INT 0
3545: PPUSH
// Say ( Bur , DQrSurrender#1-Bur-1 ) ;
3546: LD_LOC 1
3550: PPUSH
3551: LD_STRING DQrSurrender#1-Bur-1
3553: PPUSH
3554: CALL_OW 88
// YouLost ( Surrender ) ;
3558: LD_STRING Surrender
3560: PPUSH
3561: CALL_OW 104
// end ;
3565: LD_VAR 0 1
3569: RET
// function DQrSurrender_2 ; begin
3570: LD_INT 0
3572: PPUSH
// Say ( Bur , DQrSurrender#2-Bur-1 ) ;
3573: LD_LOC 1
3577: PPUSH
3578: LD_STRING DQrSurrender#2-Bur-1
3580: PPUSH
3581: CALL_OW 88
// wait_while := true ;
3585: LD_ADDR_EXP 12
3589: PUSH
3590: LD_INT 1
3592: ST_TO_ADDR
// end ;
3593: LD_VAR 0 1
3597: RET
// function DQrSurrender_3 ; begin
3598: LD_INT 0
3600: PPUSH
// Say ( Bur , DQrSurrender#3-Bur-1 ) ;
3601: LD_LOC 1
3605: PPUSH
3606: LD_STRING DQrSurrender#3-Bur-1
3608: PPUSH
3609: CALL_OW 88
// end ;
3613: LD_VAR 0 1
3617: RET
// every 0 0$1 trigger dialogy and ( FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3618: LD_EXP 46
3622: PUSH
3623: LD_INT 8
3625: PPUSH
3626: LD_INT 26
3628: PUSH
3629: LD_INT 1
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: PUSH
3636: LD_INT 22
3638: PUSH
3639: LD_EXP 1
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: LD_INT 23
3650: PUSH
3651: LD_INT 3
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: LIST
3662: PPUSH
3663: CALL_OW 70
3667: AND
3668: IFFALSE 3754
3670: GO 3672
3672: DISABLE
3673: LD_INT 0
3675: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3676: LD_ADDR_VAR 0 1
3680: PUSH
3681: LD_LOC 11
3685: PUSH
3686: LD_INT 8
3688: PPUSH
3689: LD_INT 26
3691: PUSH
3692: LD_INT 1
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 22
3701: PUSH
3702: LD_EXP 1
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PUSH
3711: LD_INT 23
3713: PUSH
3714: LD_INT 3
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: LIST
3725: PPUSH
3726: CALL_OW 70
3730: ISECT
3731: ST_TO_ADDR
// if b then
3732: LD_VAR 0 1
3736: IFFALSE 3753
// DShipments ( b [ 1 ] ) else
3738: LD_VAR 0 1
3742: PUSH
3743: LD_INT 1
3745: ARRAY
3746: PPUSH
3747: CALL 3757 0 1
3751: GO 3754
// enable ;
3753: ENABLE
// end ;
3754: PPOPN 1
3756: END
// function DShipments ( who ) ; begin
3757: LD_INT 0
3759: PPUSH
// CreateCratesArea ( 5 , second_crate , true ) ;
3760: LD_INT 5
3762: PPUSH
3763: LD_INT 7
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: CALL_OW 55
// wait ( 0 0$6 ) ;
3773: LD_INT 210
3775: PPUSH
3776: CALL_OW 67
// DialogueOn ;
3780: CALL_OW 6
// if Say ( who , DShipments-RSol1-1 ) then
3784: LD_VAR 0 1
3788: PPUSH
3789: LD_STRING DShipments-RSol1-1
3791: PPUSH
3792: CALL_OW 88
3796: IFFALSE 3824
// if Say ( Bur , DShipments-Bur-1 ) then
3798: LD_LOC 1
3802: PPUSH
3803: LD_STRING DShipments-Bur-1
3805: PPUSH
3806: CALL_OW 88
3810: IFFALSE 3824
// Say ( who , DShipments-RSol1-2 ) ;
3812: LD_VAR 0 1
3816: PPUSH
3817: LD_STRING DShipments-RSol1-2
3819: PPUSH
3820: CALL_OW 88
// DialogueOff ;
3824: CALL_OW 7
// end ;
3828: LD_VAR 0 2
3832: RET
// every 0 0$3 + 0 0$2 trigger dialogy and ( FilterUnitsInArea ( enter_near_road , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3833: LD_EXP 46
3837: PUSH
3838: LD_INT 9
3840: PPUSH
3841: LD_INT 26
3843: PUSH
3844: LD_INT 1
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 22
3853: PUSH
3854: LD_EXP 1
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PUSH
3863: LD_INT 23
3865: PUSH
3866: LD_INT 3
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 70
3882: AND
3883: IFFALSE 3969
3885: GO 3887
3887: DISABLE
3888: LD_INT 0
3890: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3891: LD_ADDR_VAR 0 1
3895: PUSH
3896: LD_LOC 11
3900: PUSH
3901: LD_INT 8
3903: PPUSH
3904: LD_INT 26
3906: PUSH
3907: LD_INT 1
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: LD_INT 22
3916: PUSH
3917: LD_EXP 1
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 23
3928: PUSH
3929: LD_INT 3
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: PPUSH
3941: CALL_OW 70
3945: ISECT
3946: ST_TO_ADDR
// if b then
3947: LD_VAR 0 1
3951: IFFALSE 3968
// DRoad ( b [ 1 ] ) else
3953: LD_VAR 0 1
3957: PUSH
3958: LD_INT 1
3960: ARRAY
3961: PPUSH
3962: CALL 3972 0 1
3966: GO 3969
// enable ;
3968: ENABLE
// end ;
3969: PPOPN 1
3971: END
// function DRoad ( who ) ; begin
3972: LD_INT 0
3974: PPUSH
// if who <> Burlak then
3975: LD_VAR 0 1
3979: PUSH
3980: LD_EXP 50
3984: NONEQUAL
3985: IFFALSE 4026
// begin DialogueOn ;
3987: CALL_OW 6
// Say ( who , DRoad-RSol1-1 ) ;
3991: LD_VAR 0 1
3995: PPUSH
3996: LD_STRING DRoad-RSol1-1
3998: PPUSH
3999: CALL_OW 88
// if not breaked_trough then
4003: LD_EXP 10
4007: NOT
4008: IFFALSE 4022
// Say ( who , DRoad-RSol1-1a ) ;
4010: LD_VAR 0 1
4014: PPUSH
4015: LD_STRING DRoad-RSol1-1a
4017: PPUSH
4018: CALL_OW 88
// DialogueOff ;
4022: CALL_OW 7
// end ; end ;
4026: LD_VAR 0 2
4030: RET
// every 0 0$3 + 0 0$2 trigger dialogy and see_any ( you , UnitFilter ( apemans , [ [ f_side , neutral ] ] ) ) do var a ;
4031: LD_EXP 46
4035: PUSH
4036: LD_EXP 1
4040: PPUSH
4041: LD_EXP 7
4045: PPUSH
4046: LD_INT 22
4048: PUSH
4049: LD_EXP 4
4053: PUSH
4054: EMPTY
4055: LIST
4056: LIST
4057: PUSH
4058: EMPTY
4059: LIST
4060: PPUSH
4061: CALL_OW 72
4065: PPUSH
4066: CALL 23798 0 2
4070: AND
4071: IFFALSE 4253
4073: GO 4075
4075: DISABLE
4076: LD_INT 0
4078: PPUSH
// begin a := ( FilterAllUnits ( [ [ f_side , you ] , [ f_see , neutral ] ] ) isect donttalk ) ^ Burlak ;
4079: LD_ADDR_VAR 0 1
4083: PUSH
4084: LD_INT 22
4086: PUSH
4087: LD_EXP 1
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 101
4098: PUSH
4099: LD_EXP 4
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: PPUSH
4112: CALL_OW 69
4116: PUSH
4117: LD_LOC 11
4121: ISECT
4122: PUSH
4123: LD_EXP 50
4127: ADD
4128: ST_TO_ADDR
// if a then
4129: LD_VAR 0 1
4133: IFFALSE 4252
// begin if not GetTech ( tech_ApeLang , you ) = state_researched then
4135: LD_INT 1
4137: PPUSH
4138: LD_EXP 1
4142: PPUSH
4143: CALL_OW 321
4147: PUSH
4148: LD_INT 2
4150: EQUAL
4151: NOT
4152: IFFALSE 4250
// begin DApeSpot ( a [ Rand ( 1 , a ) ] ) ;
4154: LD_VAR 0 1
4158: PUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_VAR 0 1
4166: PPUSH
4167: CALL_OW 12
4171: ARRAY
4172: PPUSH
4173: CALL 4256 0 1
// wait ( 2 2$0 ) ;
4177: LD_INT 4200
4179: PPUSH
4180: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4184: LD_INT 22
4186: PUSH
4187: LD_EXP 1
4191: PUSH
4192: EMPTY
4193: LIST
4194: LIST
4195: PUSH
4196: LD_INT 2
4198: PUSH
4199: LD_INT 30
4201: PUSH
4202: LD_INT 6
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PUSH
4209: LD_INT 30
4211: PUSH
4212: LD_INT 7
4214: PUSH
4215: EMPTY
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 30
4221: PUSH
4222: LD_INT 8
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PPUSH
4239: CALL_OW 69
4243: NOT
4244: IFFALSE 4250
// DApeLab ;
4246: CALL 4479 0 0
// end ; end else
4250: GO 4253
// enable ;
4252: ENABLE
// end ;
4253: PPOPN 1
4255: END
// function DApeSpot ( who ) ; var Sci1 ; begin
4256: LD_INT 0
4258: PPUSH
4259: PPUSH
// Sci1 := Pty ;
4260: LD_ADDR_VAR 0 3
4264: PUSH
4265: LD_LOC 6
4269: ST_TO_ADDR
// if not IsLive ( Pty ) then
4270: LD_LOC 6
4274: PPUSH
4275: CALL_OW 300
4279: NOT
4280: IFFALSE 4311
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4282: LD_ADDR_VAR 0 3
4286: PUSH
4287: LD_LOC 11
4291: PPUSH
4292: LD_EXP 1
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 4
4302: PPUSH
4303: LD_INT 0
4305: PPUSH
4306: CALL 23597 0 5
4310: ST_TO_ADDR
// DialogueOn ;
4311: CALL_OW 6
// if who = Bur then
4315: LD_VAR 0 1
4319: PUSH
4320: LD_LOC 1
4324: EQUAL
4325: IFFALSE 4341
// Say ( Bur , DApeSpot-Bur-1a ) else
4327: LD_LOC 1
4331: PPUSH
4332: LD_STRING DApeSpot-Bur-1a
4334: PPUSH
4335: CALL_OW 88
4339: GO 4365
// begin Say ( Bur , DApeSpot-Bur-1 ) ;
4341: LD_LOC 1
4345: PPUSH
4346: LD_STRING DApeSpot-Bur-1
4348: PPUSH
4349: CALL_OW 88
// Say ( who , DApeSpot-RSol1-1 ) ;
4353: LD_VAR 0 1
4357: PPUSH
4358: LD_STRING DApeSpot-RSol1-1
4360: PPUSH
4361: CALL_OW 88
// end ; if Sci1 then
4365: LD_VAR 0 3
4369: IFFALSE 4470
// begin Say ( Sci1 , DApeSpot-Pty-1 ) ;
4371: LD_VAR 0 3
4375: PPUSH
4376: LD_STRING DApeSpot-Pty-1
4378: PPUSH
4379: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4383: LD_INT 22
4385: PUSH
4386: LD_EXP 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 2
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 6
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 30
4410: PUSH
4411: LD_INT 7
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 30
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PPUSH
4438: CALL_OW 69
4442: IFFALSE 4458
// Say ( Sci1 , DApeSpot-Pty-1a ) else
4444: LD_VAR 0 3
4448: PPUSH
4449: LD_STRING DApeSpot-Pty-1a
4451: PPUSH
4452: CALL_OW 88
4456: GO 4470
// Say ( Sci1 , DApeSpot-Pty-1b ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_STRING DApeSpot-Pty-1b
4465: PPUSH
4466: CALL_OW 88
// end ; DialogueOff ;
4470: CALL_OW 7
// end ;
4474: LD_VAR 0 2
4478: RET
// function DApeLab ; var Sci1 ; begin
4479: LD_INT 0
4481: PPUSH
4482: PPUSH
// Sci1 := Pty ;
4483: LD_ADDR_VAR 0 2
4487: PUSH
4488: LD_LOC 6
4492: ST_TO_ADDR
// if not IsLive ( Pty ) then
4493: LD_LOC 6
4497: PPUSH
4498: CALL_OW 300
4502: NOT
4503: IFFALSE 4534
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4505: LD_ADDR_VAR 0 2
4509: PUSH
4510: LD_LOC 11
4514: PPUSH
4515: LD_EXP 1
4519: PPUSH
4520: LD_INT 1
4522: PPUSH
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 0
4528: PPUSH
4529: CALL 23597 0 5
4533: ST_TO_ADDR
// if Sci1 then
4534: LD_VAR 0 2
4538: IFFALSE 4560
// begin DialogueOn ;
4540: CALL_OW 6
// Say ( Sci1 , DApeLab-Pty-1 ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_STRING DApeLab-Pty-1
4551: PPUSH
4552: CALL_OW 88
// DialogueOff ;
4556: CALL_OW 7
// end ; end ;
4560: LD_VAR 0 1
4564: RET
// export function DApeLangCompl ; var Sci1 ; begin
4565: LD_INT 0
4567: PPUSH
4568: PPUSH
// Sci1 := Pty ;
4569: LD_ADDR_VAR 0 2
4573: PUSH
4574: LD_LOC 6
4578: ST_TO_ADDR
// if not IsLive ( Pty ) then
4579: LD_LOC 6
4583: PPUSH
4584: CALL_OW 300
4588: NOT
4589: IFFALSE 4620
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4591: LD_ADDR_VAR 0 2
4595: PUSH
4596: LD_LOC 11
4600: PPUSH
4601: LD_EXP 1
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: LD_INT 4
4611: PPUSH
4612: LD_INT 0
4614: PPUSH
4615: CALL 23597 0 5
4619: ST_TO_ADDR
// if Sci1 then
4620: LD_VAR 0 2
4624: IFFALSE 4718
// begin DialogueOn ;
4626: CALL_OW 6
// Say ( Sci1 , DApeLangCompl-Pty-1 ) ;
4630: LD_VAR 0 2
4634: PPUSH
4635: LD_STRING DApeLangCompl-Pty-1
4637: PPUSH
4638: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-1 ) ;
4642: LD_LOC 1
4646: PPUSH
4647: LD_STRING DApeLangCompl-Bur-1
4649: PPUSH
4650: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-2 ) ;
4654: LD_VAR 0 2
4658: PPUSH
4659: LD_STRING DApeLangCompl-Pty-2
4661: PPUSH
4662: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-2 ) ;
4666: LD_LOC 1
4670: PPUSH
4671: LD_STRING DApeLangCompl-Bur-2
4673: PPUSH
4674: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-3 ) ;
4678: LD_VAR 0 2
4682: PPUSH
4683: LD_STRING DApeLangCompl-Pty-3
4685: PPUSH
4686: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-3 ) ;
4690: LD_LOC 1
4694: PPUSH
4695: LD_STRING DApeLangCompl-Bur-3
4697: PPUSH
4698: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-4 ) ;
4702: LD_VAR 0 2
4706: PPUSH
4707: LD_STRING DApeLangCompl-Pty-4
4709: PPUSH
4710: CALL_OW 88
// DialogueOff ;
4714: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4718: LD_STRING ApemenTaming
4720: PPUSH
4721: CALL 25518 0 1
// end ;
4725: LD_VAR 0 1
4729: RET
// export function DApeTame ; var Sci1 ; begin
4730: LD_INT 0
4732: PPUSH
4733: PPUSH
// first_apeman_tamed := true ;
4734: LD_ADDR_EXP 45
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// Sci1 := Pty ;
4742: LD_ADDR_VAR 0 2
4746: PUSH
4747: LD_LOC 6
4751: ST_TO_ADDR
// if not IsLive ( Pty ) then
4752: LD_LOC 6
4756: PPUSH
4757: CALL_OW 300
4761: NOT
4762: IFFALSE 4793
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4764: LD_ADDR_VAR 0 2
4768: PUSH
4769: LD_LOC 11
4773: PPUSH
4774: LD_EXP 1
4778: PPUSH
4779: LD_INT 1
4781: PPUSH
4782: LD_INT 4
4784: PPUSH
4785: LD_INT 0
4787: PPUSH
4788: CALL 23597 0 5
4792: ST_TO_ADDR
// if Sci1 then
4793: LD_VAR 0 2
4797: IFFALSE 4831
// begin DialogueOn ;
4799: CALL_OW 6
// Say ( Sci1 , DApeTame-Sci1-1 ) ;
4803: LD_VAR 0 2
4807: PPUSH
4808: LD_STRING DApeTame-Sci1-1
4810: PPUSH
4811: CALL_OW 88
// Say ( Bur , DApeTame-Bur-1 ) ;
4815: LD_LOC 1
4819: PPUSH
4820: LD_STRING DApeTame-Bur-1
4822: PPUSH
4823: CALL_OW 88
// DialogueOff ;
4827: CALL_OW 7
// end ; end ;
4831: LD_VAR 0 1
4835: RET
// function ApemansInLabs ; var labs , i , inlabs ; begin
4836: LD_INT 0
4838: PPUSH
4839: PPUSH
4840: PPUSH
4841: PPUSH
// inlabs := [ ] ;
4842: LD_ADDR_VAR 0 4
4846: PUSH
4847: EMPTY
4848: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4849: LD_ADDR_VAR 0 2
4853: PUSH
4854: LD_INT 22
4856: PUSH
4857: LD_EXP 1
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 2
4868: PUSH
4869: LD_INT 30
4871: PUSH
4872: LD_INT 6
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PUSH
4879: LD_INT 30
4881: PUSH
4882: LD_INT 7
4884: PUSH
4885: EMPTY
4886: LIST
4887: LIST
4888: PUSH
4889: LD_INT 30
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: EMPTY
4900: LIST
4901: LIST
4902: LIST
4903: LIST
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PPUSH
4909: CALL_OW 69
4913: ST_TO_ADDR
// for i in labs do
4914: LD_ADDR_VAR 0 3
4918: PUSH
4919: LD_VAR 0 2
4923: PUSH
4924: FOR_IN
4925: IFFALSE 4950
// inlabs := inlabs ^ UnitsInside ( i ) ;
4927: LD_ADDR_VAR 0 4
4931: PUSH
4932: LD_VAR 0 4
4936: PUSH
4937: LD_VAR 0 3
4941: PPUSH
4942: CALL_OW 313
4946: ADD
4947: ST_TO_ADDR
4948: GO 4924
4950: POP
4951: POP
// result := UnitFilter ( inlabs , [ [ f_nation , nation_nature ] ] ) ;
4952: LD_ADDR_VAR 0 1
4956: PUSH
4957: LD_VAR 0 4
4961: PPUSH
4962: LD_INT 23
4964: PUSH
4965: LD_INT 0
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: EMPTY
4973: LIST
4974: PPUSH
4975: CALL_OW 72
4979: ST_TO_ADDR
// end ;
4980: LD_VAR 0 1
4984: RET
// every 0 0$3 trigger dialogy and ApemansInLabs do
4985: LD_EXP 46
4989: PUSH
4990: CALL 4836 0 0
4994: AND
4995: IFFALSE 5004
4997: GO 4999
4999: DISABLE
// begin DApeWorkSol ;
5000: CALL 5005 0 0
// end ;
5004: END
// function DApeWorkSol ; var Sci1 ; begin
5005: LD_INT 0
5007: PPUSH
5008: PPUSH
// Sci1 := Pty ;
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: LD_LOC 6
5018: ST_TO_ADDR
// if not IsLive ( Pty ) then
5019: LD_LOC 6
5023: PPUSH
5024: CALL_OW 300
5028: NOT
5029: IFFALSE 5060
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5031: LD_ADDR_VAR 0 2
5035: PUSH
5036: LD_LOC 11
5040: PPUSH
5041: LD_EXP 1
5045: PPUSH
5046: LD_INT 1
5048: PPUSH
5049: LD_INT 4
5051: PPUSH
5052: LD_INT 0
5054: PPUSH
5055: CALL 23597 0 5
5059: ST_TO_ADDR
// if Sci1 then
5060: LD_VAR 0 2
5064: IFFALSE 5119
// begin DialogueOn ;
5066: CALL_OW 6
// Say ( Bur , DApeWorkSol-Bur-1 ) ;
5070: LD_LOC 1
5074: PPUSH
5075: LD_STRING DApeWorkSol-Bur-1
5077: PPUSH
5078: CALL_OW 88
// if Say ( Sci1 , DApeWorkSol-Pty-1 ) then
5082: LD_VAR 0 2
5086: PPUSH
5087: LD_STRING DApeWorkSol-Pty-1
5089: PPUSH
5090: CALL_OW 88
5094: IFFALSE 5108
// Say ( Bur , DApeWorkSol-Bur-2 ) ;
5096: LD_LOC 1
5100: PPUSH
5101: LD_STRING DApeWorkSol-Bur-2
5103: PPUSH
5104: CALL_OW 88
// MyHint ( ApemenUsing ) ;
5108: LD_STRING ApemenUsing
5110: PPUSH
5111: CALL 25518 0 1
// DialogueOff ;
5115: CALL_OW 7
// end ; end ;
5119: LD_VAR 0 1
5123: RET
// export function DApeWorkCompl ; var Sci1 ; begin
5124: LD_INT 0
5126: PPUSH
5127: PPUSH
// first_apeman_tamed := true ;
5128: LD_ADDR_EXP 45
5132: PUSH
5133: LD_INT 1
5135: ST_TO_ADDR
// Sci1 := Pty ;
5136: LD_ADDR_VAR 0 2
5140: PUSH
5141: LD_LOC 6
5145: ST_TO_ADDR
// if not IsLive ( Pty ) then
5146: LD_LOC 6
5150: PPUSH
5151: CALL_OW 300
5155: NOT
5156: IFFALSE 5187
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: LD_LOC 11
5167: PPUSH
5168: LD_EXP 1
5172: PPUSH
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 4
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: CALL 23597 0 5
5186: ST_TO_ADDR
// if Sci1 then
5187: LD_VAR 0 2
5191: IFFALSE 5227
// begin DialogueOn ;
5193: CALL_OW 6
// if Say ( Sci1 , DApeWorkCompl-Pty-1 ) then
5197: LD_VAR 0 2
5201: PPUSH
5202: LD_STRING DApeWorkCompl-Pty-1
5204: PPUSH
5205: CALL_OW 88
5209: IFFALSE 5223
// Say ( Bur , DApeWorkCompl-Bur-1 ) ;
5211: LD_LOC 1
5215: PPUSH
5216: LD_STRING DApeWorkCompl-Bur-1
5218: PPUSH
5219: CALL_OW 88
// DialogueOff ;
5223: CALL_OW 7
// end ; end ;
5227: LD_VAR 0 1
5231: RET
// export function DApeSolCompl ; var Sci1 ; begin
5232: LD_INT 0
5234: PPUSH
5235: PPUSH
// Sci1 := Pty ;
5236: LD_ADDR_VAR 0 2
5240: PUSH
5241: LD_LOC 6
5245: ST_TO_ADDR
// if not IsLive ( Pty ) then
5246: LD_LOC 6
5250: PPUSH
5251: CALL_OW 300
5255: NOT
5256: IFFALSE 5287
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5258: LD_ADDR_VAR 0 2
5262: PUSH
5263: LD_LOC 11
5267: PPUSH
5268: LD_EXP 1
5272: PPUSH
5273: LD_INT 1
5275: PPUSH
5276: LD_INT 4
5278: PPUSH
5279: LD_INT 0
5281: PPUSH
5282: CALL 23597 0 5
5286: ST_TO_ADDR
// if Sci1 then
5287: LD_VAR 0 2
5291: IFFALSE 5327
// begin DialogueOn ;
5293: CALL_OW 6
// if Say ( Sci1 , DApeSolCompl-Pty-1 ) then
5297: LD_VAR 0 2
5301: PPUSH
5302: LD_STRING DApeSolCompl-Pty-1
5304: PPUSH
5305: CALL_OW 88
5309: IFFALSE 5323
// Say ( Bur , DApeSolCompl-Bur-1 ) ;
5311: LD_LOC 1
5315: PPUSH
5316: LD_STRING DApeSolCompl-Bur-1
5318: PPUSH
5319: CALL_OW 88
// DialogueOff ;
5323: CALL_OW 7
// end ; end ;
5327: LD_VAR 0 1
5331: RET
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and depot and ( FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Petrovova , Gleb ] ) do
5332: LD_EXP 46
5336: PUSH
5337: LD_EXP 66
5341: NOT
5342: AND
5343: PUSH
5344: LD_EXP 14
5348: AND
5349: PUSH
5350: LD_INT 10
5352: PPUSH
5353: LD_INT 22
5355: PUSH
5356: LD_EXP 1
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_INT 23
5367: PUSH
5368: LD_INT 3
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PPUSH
5379: CALL_OW 70
5383: PUSH
5384: LD_EXP 50
5388: PUSH
5389: LD_EXP 53
5393: PUSH
5394: LD_EXP 54
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: DIFF
5404: AND
5405: IFFALSE 5546
5407: GO 5409
5409: DISABLE
// begin if IsDead ( Pty ) then
5410: LD_LOC 6
5414: PPUSH
5415: CALL_OW 301
5419: IFFALSE 5431
// Pty := Dol ;
5421: LD_ADDR_LOC 6
5425: PUSH
5426: LD_LOC 10
5430: ST_TO_ADDR
// if IsDead ( Pty ) then
5431: LD_LOC 6
5435: PPUSH
5436: CALL_OW 301
5440: IFFALSE 5452
// Pty := Kar ;
5442: LD_ADDR_LOC 6
5446: PUSH
5447: LD_LOC 3
5451: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5452: LD_LOC 6
5456: PUSH
5457: LD_INT 10
5459: PPUSH
5460: LD_INT 22
5462: PUSH
5463: LD_EXP 1
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: LD_INT 23
5474: PUSH
5475: LD_INT 3
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: CALL_OW 70
5490: IN
5491: IFFALSE 5504
// DStevens ( Pty ) else
5493: LD_LOC 6
5497: PPUSH
5498: CALL 5747 0 1
5502: GO 5546
// DStevens ( FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) [ 1 ] ) ;
5504: LD_INT 10
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_EXP 1
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 23
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PPUSH
5533: CALL_OW 70
5537: PUSH
5538: LD_INT 1
5540: ARRAY
5541: PPUSH
5542: CALL 5747 0 1
// end ;
5546: END
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) > 3 ) do
5547: LD_EXP 46
5551: PUSH
5552: LD_EXP 66
5556: NOT
5557: AND
5558: PUSH
5559: LD_INT 28
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_EXP 1
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 21
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PPUSH
5588: CALL_OW 70
5592: PUSH
5593: LD_INT 3
5595: GREATER
5596: AND
5597: IFFALSE 5746
5599: GO 5601
5601: DISABLE
// begin if IsDead ( Pty ) then
5602: LD_LOC 6
5606: PPUSH
5607: CALL_OW 301
5611: IFFALSE 5623
// Pty := Dol ;
5613: LD_ADDR_LOC 6
5617: PUSH
5618: LD_LOC 10
5622: ST_TO_ADDR
// if IsDead ( Pty ) then
5623: LD_LOC 6
5627: PPUSH
5628: CALL_OW 301
5632: IFFALSE 5644
// Pty := Kar ;
5634: LD_ADDR_LOC 6
5638: PUSH
5639: LD_LOC 3
5643: ST_TO_ADDR
// vespod := true ;
5644: LD_ADDR_EXP 64
5648: PUSH
5649: LD_INT 1
5651: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5652: LD_LOC 6
5656: PUSH
5657: LD_INT 28
5659: PPUSH
5660: LD_INT 22
5662: PUSH
5663: LD_EXP 1
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 23
5674: PUSH
5675: LD_INT 3
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PPUSH
5686: CALL_OW 70
5690: IN
5691: IFFALSE 5704
// DStevens ( Pty ) else
5693: LD_LOC 6
5697: PPUSH
5698: CALL 5747 0 1
5702: GO 5746
// DStevens ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) [ 1 ] ) ;
5704: LD_INT 28
5706: PPUSH
5707: LD_INT 22
5709: PUSH
5710: LD_EXP 1
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 23
5721: PUSH
5722: LD_INT 3
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PPUSH
5733: CALL_OW 70
5737: PUSH
5738: LD_INT 1
5740: ARRAY
5741: PPUSH
5742: CALL 5747 0 1
// end ;
5746: END
// export vespod , vespod2 , byl_stevens ; function DStevens ( who ) ; begin
5747: LD_INT 0
5749: PPUSH
// if not vespod then
5750: LD_EXP 64
5754: NOT
5755: IFFALSE 5774
// PlaceUnitArea ( Huck , stv_site , true ) else
5757: LD_LOC 7
5761: PPUSH
5762: LD_INT 12
5764: PPUSH
5765: LD_INT 1
5767: PPUSH
5768: CALL_OW 49
5772: GO 5789
// PlaceUnitArea ( Huck , stv_site2 , true ) ;
5774: LD_LOC 7
5778: PPUSH
5779: LD_INT 29
5781: PPUSH
5782: LD_INT 1
5784: PPUSH
5785: CALL_OW 49
// wait ( 0 0$4 ) ;
5789: LD_INT 140
5791: PPUSH
5792: CALL_OW 67
// ComStop ( who ) ;
5796: LD_VAR 0 1
5800: PPUSH
5801: CALL_OW 141
// ComTurnUnit ( who , huck ) ;
5805: LD_VAR 0 1
5809: PPUSH
5810: LD_LOC 7
5814: PPUSH
5815: CALL_OW 119
// ComTurnUnit ( huck , who ) ;
5819: LD_LOC 7
5823: PPUSH
5824: LD_VAR 0 1
5828: PPUSH
5829: CALL_OW 119
// CenterNowOnUnits ( huck ) ;
5833: LD_LOC 7
5837: PPUSH
5838: CALL_OW 87
// Stevens_killed := true ;
5842: LD_ADDR_EXP 11
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5850: LD_INT 35
5852: PPUSH
5853: CALL_OW 67
// DialogueOn ;
5857: CALL_OW 6
// if IsDead ( Pty ) then
5861: LD_LOC 6
5865: PPUSH
5866: CALL_OW 301
5870: IFFALSE 5882
// Pty := Dol ;
5872: LD_ADDR_LOC 6
5876: PUSH
5877: LD_LOC 10
5881: ST_TO_ADDR
// if IsDead ( Pty ) then
5882: LD_LOC 6
5886: PPUSH
5887: CALL_OW 301
5891: IFFALSE 5903
// Pty := Kar ;
5893: LD_ADDR_LOC 6
5897: PUSH
5898: LD_LOC 3
5902: ST_TO_ADDR
// if IsOk ( Pty ) then
5903: LD_LOC 6
5907: PPUSH
5908: CALL_OW 302
5912: IFFALSE 6293
// begin if who = Pty then
5914: LD_VAR 0 1
5918: PUSH
5919: LD_LOC 6
5923: EQUAL
5924: IFFALSE 6028
// begin SetAttitude ( you , americans , att_enemy , false ) ;
5926: LD_EXP 1
5930: PPUSH
5931: LD_EXP 2
5935: PPUSH
5936: LD_INT 2
5938: PPUSH
5939: LD_INT 0
5941: PPUSH
5942: CALL_OW 80
// DialogueOff ;
5946: CALL_OW 7
// while GetLives ( huck ) > 940 do
5950: LD_LOC 7
5954: PPUSH
5955: CALL_OW 256
5959: PUSH
5960: LD_INT 940
5962: GREATER
5963: IFFALSE 5974
// Wait ( 0 0$0.5 ) ;
5965: LD_INT 18
5967: PPUSH
5968: CALL_OW 67
5972: GO 5950
// SetAttitude ( you , americans , att_neutral , true ) ;
5974: LD_EXP 1
5978: PPUSH
5979: LD_EXP 2
5983: PPUSH
5984: LD_INT 0
5986: PPUSH
5987: LD_INT 1
5989: PPUSH
5990: CALL_OW 80
// ComStop ( who ) ;
5994: LD_VAR 0 1
5998: PPUSH
5999: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
6003: LD_INT 4
6005: PPUSH
6006: CALL_OW 67
// DialogueOn ;
6010: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
6014: LD_LOC 7
6018: PPUSH
6019: LD_STRING DStevens-Huck-1
6021: PPUSH
6022: CALL_OW 88
// end else
6026: GO 6159
// begin Say ( who , DStevens-RSol1-1 ) ;
6028: LD_VAR 0 1
6032: PPUSH
6033: LD_STRING DStevens-RSol1-1
6035: PPUSH
6036: CALL_OW 88
// DialogueOff ;
6040: CALL_OW 7
// Wait ( 0 0$0.7 ) ;
6044: LD_INT 24
6046: PPUSH
6047: CALL_OW 67
// SetAttitude ( you , americans , att_enemy , false ) ;
6051: LD_EXP 1
6055: PPUSH
6056: LD_EXP 2
6060: PPUSH
6061: LD_INT 2
6063: PPUSH
6064: LD_INT 0
6066: PPUSH
6067: CALL_OW 80
// while GetLives ( huck ) > 940 do
6071: LD_LOC 7
6075: PPUSH
6076: CALL_OW 256
6080: PUSH
6081: LD_INT 940
6083: GREATER
6084: IFFALSE 6095
// Wait ( 0 0$0.5 ) ;
6086: LD_INT 18
6088: PPUSH
6089: CALL_OW 67
6093: GO 6071
// SetAttitude ( you , americans , att_neutral , true ) ;
6095: LD_EXP 1
6099: PPUSH
6100: LD_EXP 2
6104: PPUSH
6105: LD_INT 0
6107: PPUSH
6108: LD_INT 1
6110: PPUSH
6111: CALL_OW 80
// ComStop ( who ) ;
6115: LD_VAR 0 1
6119: PPUSH
6120: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
6124: LD_INT 4
6126: PPUSH
6127: CALL_OW 67
// DialogueOn ;
6131: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
6135: LD_LOC 7
6139: PPUSH
6140: LD_STRING DStevens-Huck-1
6142: PPUSH
6143: CALL_OW 88
// Say ( Pty , DStevens-Pty-1 ) ;
6147: LD_LOC 6
6151: PPUSH
6152: LD_STRING DStevens-Pty-1
6154: PPUSH
6155: CALL_OW 88
// end ; Say ( Pty , DStevens-Pty-1a ) ;
6159: LD_LOC 6
6163: PPUSH
6164: LD_STRING DStevens-Pty-1a
6166: PPUSH
6167: CALL_OW 88
// Say ( Huck , DStevens-Huck-2 ) ;
6171: LD_LOC 7
6175: PPUSH
6176: LD_STRING DStevens-Huck-2
6178: PPUSH
6179: CALL_OW 88
// Say ( Pty , DStevens-Pty-2 ) ;
6183: LD_LOC 6
6187: PPUSH
6188: LD_STRING DStevens-Pty-2
6190: PPUSH
6191: CALL_OW 88
// Say ( Huck , DStevens-Huck-3 ) ;
6195: LD_LOC 7
6199: PPUSH
6200: LD_STRING DStevens-Huck-3
6202: PPUSH
6203: CALL_OW 88
// Say ( Pty , DStevens-Pty-3 ) ;
6207: LD_LOC 6
6211: PPUSH
6212: LD_STRING DStevens-Pty-3
6214: PPUSH
6215: CALL_OW 88
// Say ( Huck , DStevens-Huck-4 ) ;
6219: LD_LOC 7
6223: PPUSH
6224: LD_STRING DStevens-Huck-4
6226: PPUSH
6227: CALL_OW 88
// Say ( Pty , DStevens-Pty-4 ) ;
6231: LD_LOC 6
6235: PPUSH
6236: LD_STRING DStevens-Pty-4
6238: PPUSH
6239: CALL_OW 88
// SetAttitude ( you , americans , att_friend , true ) ;
6243: LD_EXP 1
6247: PPUSH
6248: LD_EXP 2
6252: PPUSH
6253: LD_INT 1
6255: PPUSH
6256: LD_INT 1
6258: PPUSH
6259: CALL_OW 80
// SetSide ( huck , you2 ) ;
6263: LD_LOC 7
6267: PPUSH
6268: LD_EXP 5
6272: PPUSH
6273: CALL_OW 235
// ComMoveUnit ( huck , who ) ;
6277: LD_LOC 7
6281: PPUSH
6282: LD_VAR 0 1
6286: PPUSH
6287: CALL_OW 112
// end else
6291: GO 6325
// begin Say ( who , DStevens-RSol1-1 ) ;
6293: LD_VAR 0 1
6297: PPUSH
6298: LD_STRING DStevens-RSol1-1
6300: PPUSH
6301: CALL_OW 88
// SetAttitude ( you , americans , att_enemy , true ) ;
6305: LD_EXP 1
6309: PPUSH
6310: LD_EXP 2
6314: PPUSH
6315: LD_INT 2
6317: PPUSH
6318: LD_INT 1
6320: PPUSH
6321: CALL_OW 80
// end ; byl_stevens := true ;
6325: LD_ADDR_EXP 66
6329: PUSH
6330: LD_INT 1
6332: ST_TO_ADDR
// DialogueOff ;
6333: CALL_OW 7
// end ;
6337: LD_VAR 0 2
6341: RET
// var stv_depot ; every 1 trigger GetSide ( Huck ) = 3 or GetSide ( Huck ) = 6 do
6342: LD_LOC 7
6346: PPUSH
6347: CALL_OW 255
6351: PUSH
6352: LD_INT 3
6354: EQUAL
6355: PUSH
6356: LD_LOC 7
6360: PPUSH
6361: CALL_OW 255
6365: PUSH
6366: LD_INT 6
6368: EQUAL
6369: OR
6370: IFFALSE 6404
6372: GO 6374
6374: DISABLE
// begin if not GetClass ( Huck ) = 4 then
6375: LD_LOC 7
6379: PPUSH
6380: CALL_OW 257
6384: PUSH
6385: LD_INT 4
6387: EQUAL
6388: NOT
6389: IFFALSE 6403
// SetClass ( Huck , 4 ) ;
6391: LD_LOC 7
6395: PPUSH
6396: LD_INT 4
6398: PPUSH
6399: CALL_OW 336
// enable ;
6403: ENABLE
// end ;
6404: END
// function HumansInDepots ; var labs , i , inlabs ; begin
6405: LD_INT 0
6407: PPUSH
6408: PPUSH
6409: PPUSH
6410: PPUSH
// inlabs := [ ] ;
6411: LD_ADDR_VAR 0 4
6415: PUSH
6416: EMPTY
6417: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6418: LD_ADDR_VAR 0 2
6422: PUSH
6423: LD_INT 22
6425: PUSH
6426: LD_EXP 1
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 2
6437: PUSH
6438: LD_INT 30
6440: PUSH
6441: LD_INT 0
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 30
6450: PUSH
6451: LD_INT 1
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PPUSH
6467: CALL_OW 69
6471: ST_TO_ADDR
// for i in labs do
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: LD_VAR 0 2
6481: PUSH
6482: FOR_IN
6483: IFFALSE 6508
// inlabs := inlabs ^ UnitsInside ( i ) ;
6485: LD_ADDR_VAR 0 4
6489: PUSH
6490: LD_VAR 0 4
6494: PUSH
6495: LD_VAR 0 3
6499: PPUSH
6500: CALL_OW 313
6504: ADD
6505: ST_TO_ADDR
6506: GO 6482
6508: POP
6509: POP
// result := inlabs ;
6510: LD_ADDR_VAR 0 1
6514: PUSH
6515: LD_VAR 0 4
6519: ST_TO_ADDR
// end ;
6520: LD_VAR 0 1
6524: RET
// every 0 0$5 + 0 0$3 trigger dialogy and byl_stevens and ( not vespod and ( IsInArea ( Huck , stred ) ) or GetDistUnits ( Burlak , Huck ) < 13 ) do
6525: LD_EXP 46
6529: PUSH
6530: LD_EXP 66
6534: AND
6535: PUSH
6536: LD_EXP 64
6540: NOT
6541: PUSH
6542: LD_LOC 7
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 308
6554: AND
6555: PUSH
6556: LD_EXP 50
6560: PPUSH
6561: LD_LOC 7
6565: PPUSH
6566: CALL_OW 296
6570: PUSH
6571: LD_INT 13
6573: LESS
6574: OR
6575: AND
6576: IFFALSE 6649
6578: GO 6580
6580: DISABLE
// begin if IsDead ( Pty ) then
6581: LD_LOC 6
6585: PPUSH
6586: CALL_OW 301
6590: IFFALSE 6602
// Pty := Dol ;
6592: LD_ADDR_LOC 6
6596: PUSH
6597: LD_LOC 10
6601: ST_TO_ADDR
// if IsDead ( Pty ) then
6602: LD_LOC 6
6606: PPUSH
6607: CALL_OW 301
6611: IFFALSE 6623
// Pty := Kar ;
6613: LD_ADDR_LOC 6
6617: PUSH
6618: LD_LOC 3
6622: ST_TO_ADDR
// if IsLive ( Pty ) and IsLive ( Huck ) then
6623: LD_LOC 6
6627: PPUSH
6628: CALL_OW 300
6632: PUSH
6633: LD_LOC 7
6637: PPUSH
6638: CALL_OW 300
6642: AND
6643: IFFALSE 6649
// DStevensBurlak ;
6645: CALL 6650 0 0
// end ;
6649: END
// function DStevensBurlak ; var qr , tmp_depot ; begin
6650: LD_INT 0
6652: PPUSH
6653: PPUSH
6654: PPUSH
// DialogueOn ;
6655: CALL_OW 6
// Say ( Pty , DStevensBurlak-Pty-1 ) ;
6659: LD_LOC 6
6663: PPUSH
6664: LD_STRING DStevensBurlak-Pty-1
6666: PPUSH
6667: CALL_OW 88
// Say ( Bur , DStevensBurlak-Bur-1 ) ;
6671: LD_LOC 1
6675: PPUSH
6676: LD_STRING DStevensBurlak-Bur-1
6678: PPUSH
6679: CALL_OW 88
// Say ( Pty , DStevensBurlak-Pty-2 ) ;
6683: LD_LOC 6
6687: PPUSH
6688: LD_STRING DStevensBurlak-Pty-2
6690: PPUSH
6691: CALL_OW 88
// qr := Query ( QKill ) ;
6695: LD_ADDR_VAR 0 2
6699: PUSH
6700: LD_STRING QKill
6702: PPUSH
6703: CALL_OW 97
6707: ST_TO_ADDR
// if qr = 1 then
6708: LD_VAR 0 2
6712: PUSH
6713: LD_INT 1
6715: EQUAL
6716: IFFALSE 6787
// begin Say ( Bur , DKill-1-Bur-1 ) ;
6718: LD_LOC 1
6722: PPUSH
6723: LD_STRING DKill-1-Bur-1
6725: PPUSH
6726: CALL_OW 88
// SetSide ( Huck , americans ) ;
6730: LD_LOC 7
6734: PPUSH
6735: LD_EXP 2
6739: PPUSH
6740: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
6744: LD_EXP 1
6748: PPUSH
6749: LD_EXP 2
6753: PPUSH
6754: LD_INT 2
6756: PPUSH
6757: LD_INT 1
6759: PPUSH
6760: CALL_OW 80
// if IsLive ( Glb ) then
6764: LD_LOC 5
6768: PPUSH
6769: CALL_OW 300
6773: IFFALSE 6787
// Say ( Glb , DKill-1-Glb-1 ) ;
6775: LD_LOC 5
6779: PPUSH
6780: LD_STRING DKill-1-Glb-1
6782: PPUSH
6783: CALL_OW 88
// end ; if qr = 2 then
6787: LD_VAR 0 2
6791: PUSH
6792: LD_INT 2
6794: EQUAL
6795: IFFALSE 6848
// begin Say ( Bur , DKill-2-Bur-1 ) ;
6797: LD_LOC 1
6801: PPUSH
6802: LD_STRING DKill-2-Bur-1
6804: PPUSH
6805: CALL_OW 88
// Say ( Pty , DKill-2-Pty-1 ) ;
6809: LD_LOC 6
6813: PPUSH
6814: LD_STRING DKill-2-Pty-1
6816: PPUSH
6817: CALL_OW 88
// if not vespod then
6821: LD_EXP 64
6825: NOT
6826: IFFALSE 6840
// Say ( Bur , DKill-2-Bur-2 ) ;
6828: LD_LOC 1
6832: PPUSH
6833: LD_STRING DKill-2-Bur-2
6835: PPUSH
6836: CALL_OW 88
// StevensStayInBase = 1 ;
6840: LD_ADDR_EXP 49
6844: PUSH
6845: LD_INT 1
6847: ST_TO_ADDR
// end ; DialogueOff ;
6848: CALL_OW 7
// if not vespod and qr = 2 then
6852: LD_EXP 64
6856: NOT
6857: PUSH
6858: LD_VAR 0 2
6862: PUSH
6863: LD_INT 2
6865: EQUAL
6866: AND
6867: IFFALSE 7053
// begin while not tmp_depot do
6869: LD_VAR 0 3
6873: NOT
6874: IFFALSE 6950
// begin tmp_depot := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
6876: LD_ADDR_VAR 0 3
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_EXP 1
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: LD_INT 50
6895: PUSH
6896: EMPTY
6897: LIST
6898: PUSH
6899: LD_INT 2
6901: PUSH
6902: LD_INT 30
6904: PUSH
6905: LD_INT 1
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PUSH
6912: LD_INT 30
6914: PUSH
6915: LD_INT 0
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: LIST
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: PPUSH
6932: CALL_OW 69
6936: PUSH
6937: LD_INT 1
6939: ARRAY
6940: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
6941: LD_INT 35
6943: PPUSH
6944: CALL_OW 67
// end ;
6948: GO 6869
// while GetDistUnits ( Huck , tmp_depot ) > 5 do
6950: LD_LOC 7
6954: PPUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 296
6964: PUSH
6965: LD_INT 5
6967: GREATER
6968: IFFALSE 6993
// begin ComMoveUnit ( Huck , tmp_depot ) ;
6970: LD_LOC 7
6974: PPUSH
6975: LD_VAR 0 3
6979: PPUSH
6980: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
6984: LD_INT 4
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6950
// SetSide ( Huck , you ) ;
6993: LD_LOC 7
6997: PPUSH
6998: LD_EXP 1
7002: PPUSH
7003: CALL_OW 235
// while not ( huck in HumansInDepots ) do
7007: LD_LOC 7
7011: PUSH
7012: CALL 6405 0 0
7016: IN
7017: NOT
7018: IFFALSE 7043
// begin ComMoveUnit ( Huck , tmp_depot ) ;
7020: LD_LOC 7
7024: PPUSH
7025: LD_VAR 0 3
7029: PPUSH
7030: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
7034: LD_INT 4
7036: PPUSH
7037: CALL_OW 67
// end ;
7041: GO 7007
// stv_depot := tmp_depot ;
7043: LD_ADDR_LOC 12
7047: PUSH
7048: LD_VAR 0 3
7052: ST_TO_ADDR
// end ; if vespod and qr = 2 then
7053: LD_EXP 64
7057: PUSH
7058: LD_VAR 0 2
7062: PUSH
7063: LD_INT 2
7065: EQUAL
7066: AND
7067: IFFALSE 7092
// begin DialogueOn ;
7069: CALL_OW 6
// DWait ( 0 0$4.5 ) ;
7073: LD_INT 158
7075: PPUSH
7076: CALL_OW 68
// DialogueOff ;
7080: CALL_OW 7
// vespod2 := true ;
7084: LD_ADDR_EXP 65
7088: PUSH
7089: LD_INT 1
7091: ST_TO_ADDR
// end ; if qr = 1 then
7092: LD_VAR 0 2
7096: PUSH
7097: LD_INT 1
7099: EQUAL
7100: IFFALSE 7149
// begin while not IsInArea ( huck , stv_exit ) do
7102: LD_LOC 7
7106: PPUSH
7107: LD_INT 21
7109: PPUSH
7110: CALL_OW 308
7114: NOT
7115: IFFALSE 7140
// begin ComMoveToArea ( Huck , stv_exit ) ;
7117: LD_LOC 7
7121: PPUSH
7122: LD_INT 21
7124: PPUSH
7125: CALL_OW 113
// DU_wait ( Huck ) ;
7129: LD_LOC 7
7133: PPUSH
7134: CALL 22055 0 1
// end ;
7138: GO 7102
// RemoveUnit ( Huck ) ;
7140: LD_LOC 7
7144: PPUSH
7145: CALL_OW 64
// end ; end ;
7149: LD_VAR 0 1
7153: RET
// function DQrKillAgain_1 ; begin
7154: LD_INT 0
7156: PPUSH
// DialogueOn ;
7157: CALL_OW 6
// Say ( Bur , DQrKillAgain#1-Bur-1 ) ;
7161: LD_LOC 1
7165: PPUSH
7166: LD_STRING DQrKillAgain#1-Bur-1
7168: PPUSH
7169: CALL_OW 88
// DialogueOff ;
7173: CALL_OW 7
// SetSide ( Huck , americans ) ;
7177: LD_LOC 7
7181: PPUSH
7182: LD_EXP 2
7186: PPUSH
7187: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
7191: LD_EXP 1
7195: PPUSH
7196: LD_EXP 2
7200: PPUSH
7201: LD_INT 2
7203: PPUSH
7204: LD_INT 1
7206: PPUSH
7207: CALL_OW 80
// Stevens_Killed := true ;
7211: LD_ADDR_EXP 11
7215: PUSH
7216: LD_INT 1
7218: ST_TO_ADDR
// stv_depot := 0 ;
7219: LD_ADDR_LOC 12
7223: PUSH
7224: LD_INT 0
7226: ST_TO_ADDR
// end ;
7227: LD_VAR 0 1
7231: RET
// function DQrKillAgain_2 ; begin
7232: LD_INT 0
7234: PPUSH
// DialogueOn ;
7235: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1 ) ;
7239: LD_LOC 1
7243: PPUSH
7244: LD_STRING DQrKillAgain#2-Bur-1
7246: PPUSH
7247: CALL_OW 88
// DialogueOff ;
7251: CALL_OW 7
// stv_depot := 0 ;
7255: LD_ADDR_LOC 12
7259: PUSH
7260: LD_INT 0
7262: ST_TO_ADDR
// SetSide ( Huck , americans ) ;
7263: LD_LOC 7
7267: PPUSH
7268: LD_EXP 2
7272: PPUSH
7273: CALL_OW 235
// ComMoveToArea ( Huck , Stv_exit ) ;
7277: LD_LOC 7
7281: PPUSH
7282: LD_INT 21
7284: PPUSH
7285: CALL_OW 113
// while not ( IsInArea ( Huck , stv_exit ) ) do
7289: LD_LOC 7
7293: PPUSH
7294: LD_INT 21
7296: PPUSH
7297: CALL_OW 308
7301: NOT
7302: IFFALSE 7313
// wait ( 0 0$1 ) ;
7304: LD_INT 35
7306: PPUSH
7307: CALL_OW 67
7311: GO 7289
// RemoveUnit ( Huck ) ;
7313: LD_LOC 7
7317: PPUSH
7318: CALL_OW 64
// end ;
7322: LD_VAR 0 1
7326: RET
// function DQrKillAgain_3 ; var tmp_depot ; begin
7327: LD_INT 0
7329: PPUSH
7330: PPUSH
// DialogueOn ;
7331: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1a ) ;
7335: LD_LOC 1
7339: PPUSH
7340: LD_STRING DQrKillAgain#2-Bur-1a
7342: PPUSH
7343: CALL_OW 88
// DialogueOff ;
7347: CALL_OW 7
// SetSide ( Huck , you2 ) ;
7351: LD_LOC 7
7355: PPUSH
7356: LD_EXP 5
7360: PPUSH
7361: CALL_OW 235
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7365: LD_ADDR_VAR 0 2
7369: PUSH
7370: LD_INT 22
7372: PUSH
7373: LD_EXP 1
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: PUSH
7382: LD_INT 50
7384: PUSH
7385: EMPTY
7386: LIST
7387: PUSH
7388: LD_INT 2
7390: PUSH
7391: LD_INT 30
7393: PUSH
7394: LD_INT 1
7396: PUSH
7397: EMPTY
7398: LIST
7399: LIST
7400: PUSH
7401: LD_INT 30
7403: PUSH
7404: LD_INT 0
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: LIST
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: LIST
7420: PPUSH
7421: CALL_OW 69
7425: ST_TO_ADDR
// if tmp_depot = 0 then
7426: LD_VAR 0 2
7430: PUSH
7431: LD_INT 0
7433: EQUAL
7434: IFFALSE 7560
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7443: LD_ADDR_VAR 0 2
7447: PUSH
7448: LD_INT 22
7450: PUSH
7451: LD_EXP 1
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 50
7462: PUSH
7463: EMPTY
7464: LIST
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: LD_INT 30
7471: PUSH
7472: LD_INT 1
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 30
7481: PUSH
7482: LD_INT 0
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: LIST
7498: PPUSH
7499: CALL_OW 69
7503: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7504: LD_LOC 1
7508: PPUSH
7509: CALL_OW 310
7513: IFFALSE 7536
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7515: LD_LOC 7
7519: PPUSH
7520: LD_LOC 1
7524: PPUSH
7525: CALL_OW 310
7529: PPUSH
7530: CALL_OW 112
7534: GO 7550
// ComMoveUnit ( Huck , Bur ) ;
7536: LD_LOC 7
7540: PPUSH
7541: LD_LOC 1
7545: PPUSH
7546: CALL_OW 112
// until tmp_depot > 0 ;
7550: LD_VAR 0 2
7554: PUSH
7555: LD_INT 0
7557: GREATER
7558: IFFALSE 7436
// if tmp_depot > 0 then
7560: LD_VAR 0 2
7564: PUSH
7565: LD_INT 0
7567: GREATER
7568: IFFALSE 7874
// begin repeat tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_EXP 1
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PUSH
7587: LD_INT 50
7589: PUSH
7590: EMPTY
7591: LIST
7592: PUSH
7593: LD_INT 2
7595: PUSH
7596: LD_INT 30
7598: PUSH
7599: LD_INT 1
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: LD_INT 30
7608: PUSH
7609: LD_INT 0
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 69
7630: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7631: LD_INT 35
7633: PPUSH
7634: CALL_OW 67
// ComMoveUnit ( Huck , tmp_depot [ 1 ] ) ;
7638: LD_LOC 7
7642: PPUSH
7643: LD_VAR 0 2
7647: PUSH
7648: LD_INT 1
7650: ARRAY
7651: PPUSH
7652: CALL_OW 112
// until GetDistUnits ( Huck , tmp_depot [ 1 ] ) < 5 or tmp_depot = 0 ;
7656: LD_LOC 7
7660: PPUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: ARRAY
7669: PPUSH
7670: CALL_OW 296
7674: PUSH
7675: LD_INT 5
7677: LESS
7678: PUSH
7679: LD_VAR 0 2
7683: PUSH
7684: LD_INT 0
7686: EQUAL
7687: OR
7688: IFFALSE 7570
// if tmp_depot = 0 then
7690: LD_VAR 0 2
7694: PUSH
7695: LD_INT 0
7697: EQUAL
7698: IFFALSE 7824
// repeat wait ( 0 0$1 ) ;
7700: LD_INT 35
7702: PPUSH
7703: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7707: LD_ADDR_VAR 0 2
7711: PUSH
7712: LD_INT 22
7714: PUSH
7715: LD_EXP 1
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: LD_INT 50
7726: PUSH
7727: EMPTY
7728: LIST
7729: PUSH
7730: LD_INT 2
7732: PUSH
7733: LD_INT 30
7735: PUSH
7736: LD_INT 1
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 30
7745: PUSH
7746: LD_INT 0
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: PPUSH
7763: CALL_OW 69
7767: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7768: LD_LOC 1
7772: PPUSH
7773: CALL_OW 310
7777: IFFALSE 7800
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7779: LD_LOC 7
7783: PPUSH
7784: LD_LOC 1
7788: PPUSH
7789: CALL_OW 310
7793: PPUSH
7794: CALL_OW 112
7798: GO 7814
// ComMoveUnit ( Huck , Bur ) ;
7800: LD_LOC 7
7804: PPUSH
7805: LD_LOC 1
7809: PPUSH
7810: CALL_OW 112
// until tmp_depot > 0 ;
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 0
7821: GREATER
7822: IFFALSE 7700
// SetSide ( Huck , you ) ;
7824: LD_LOC 7
7828: PPUSH
7829: LD_EXP 1
7833: PPUSH
7834: CALL_OW 235
// repeat wait ( 0 0$0.1 ) ;
7838: LD_INT 4
7840: PPUSH
7841: CALL_OW 67
// ComEnterUnit ( Huck , tmp_depot [ 1 ] ) ;
7845: LD_LOC 7
7849: PPUSH
7850: LD_VAR 0 2
7854: PUSH
7855: LD_INT 1
7857: ARRAY
7858: PPUSH
7859: CALL_OW 120
// until IsInUnit ( Huck ) ;
7863: LD_LOC 7
7867: PPUSH
7868: CALL_OW 310
7872: IFFALSE 7838
// end ; end ;
7874: LD_VAR 0 1
7878: RET
// every 0 0$3 trigger dialogy and byl_stevens and IsOK ( Huck ) and StevensStayInBase = 1 and not IsInUnit ( Huck ) do var qr ;
7879: LD_EXP 46
7883: PUSH
7884: LD_EXP 66
7888: AND
7889: PUSH
7890: LD_LOC 7
7894: PPUSH
7895: CALL_OW 302
7899: AND
7900: PUSH
7901: LD_EXP 49
7905: PUSH
7906: LD_INT 1
7908: EQUAL
7909: AND
7910: PUSH
7911: LD_LOC 7
7915: PPUSH
7916: CALL_OW 310
7920: NOT
7921: AND
7922: IFFALSE 8078
7924: GO 7926
7926: DISABLE
7927: LD_INT 0
7929: PPUSH
// begin DialogueOn ;
7930: CALL_OW 6
// Stevens_killed := false ;
7934: LD_ADDR_EXP 11
7938: PUSH
7939: LD_INT 0
7941: ST_TO_ADDR
// Say ( Bur , DRelease-Bur-1 ) ;
7942: LD_LOC 1
7946: PPUSH
7947: LD_STRING DRelease-Bur-1
7949: PPUSH
7950: CALL_OW 88
// DialogueOff ;
7954: CALL_OW 7
// if vespod then
7958: LD_EXP 64
7962: IFFALSE 7989
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 ] ) else
7964: LD_ADDR_VAR 0 1
7968: PUSH
7969: LD_STRING QKillAgain
7971: PPUSH
7972: LD_INT 1
7974: PUSH
7975: LD_INT 2
7977: PUSH
7978: EMPTY
7979: LIST
7980: LIST
7981: PPUSH
7982: CALL_OW 98
7986: ST_TO_ADDR
7987: GO 8016
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 , 3 ] ) ;
7989: LD_ADDR_VAR 0 1
7993: PUSH
7994: LD_STRING QKillAgain
7996: PPUSH
7997: LD_INT 1
7999: PUSH
8000: LD_INT 2
8002: PUSH
8003: LD_INT 3
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: PPUSH
8011: CALL_OW 98
8015: ST_TO_ADDR
// case qr of 1 :
8016: LD_VAR 0 1
8020: PUSH
8021: LD_INT 1
8023: DOUBLE
8024: EQUAL
8025: IFTRUE 8029
8027: GO 8036
8029: POP
// DQrKillAgain_1 ; 2 :
8030: CALL 7154 0 0
8034: GO 8067
8036: LD_INT 2
8038: DOUBLE
8039: EQUAL
8040: IFTRUE 8044
8042: GO 8051
8044: POP
// DQrKillAgain_2 ; 3 :
8045: CALL 7232 0 0
8049: GO 8067
8051: LD_INT 3
8053: DOUBLE
8054: EQUAL
8055: IFTRUE 8059
8057: GO 8066
8059: POP
// DQrKillAgain_3 ; end ;
8060: CALL 7327 0 0
8064: GO 8067
8066: POP
// if qr = 3 then
8067: LD_VAR 0 1
8071: PUSH
8072: LD_INT 3
8074: EQUAL
8075: IFFALSE 8078
// enable ;
8077: ENABLE
// end ;
8078: PPOPN 1
8080: END
// function DStevensLeftBehind ; var r , Sol1 ; begin
8081: LD_INT 0
8083: PPUSH
8084: PPUSH
8085: PPUSH
// DialogueOn ;
8086: CALL_OW 6
// Sol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
8090: LD_ADDR_VAR 0 3
8094: PUSH
8095: LD_LOC 11
8099: PPUSH
8100: LD_EXP 1
8104: PPUSH
8105: LD_INT 1
8107: PPUSH
8108: LD_INT 0
8110: PPUSH
8111: LD_INT 0
8113: PPUSH
8114: CALL 23597 0 5
8118: ST_TO_ADDR
// if IsOk ( Pty ) then
8119: LD_LOC 6
8123: PPUSH
8124: CALL_OW 302
8128: IFFALSE 8150
// r := Say ( Pty , DStevensLeftBehind-Pty-1 ) else
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_LOC 6
8139: PPUSH
8140: LD_STRING DStevensLeftBehind-Pty-1
8142: PPUSH
8143: CALL_OW 88
8147: ST_TO_ADDR
8148: GO 8168
// r := Say ( Sol1 , DStevensLeftBehind-RSol1-1 ) ;
8150: LD_ADDR_VAR 0 2
8154: PUSH
8155: LD_VAR 0 3
8159: PPUSH
8160: LD_STRING DStevensLeftBehind-RSol1-1
8162: PPUSH
8163: CALL_OW 88
8167: ST_TO_ADDR
// if r then
8168: LD_VAR 0 2
8172: IFFALSE 8186
// Say ( Bur , DStevensLeftBehind-Bur-1 ) ;
8174: LD_LOC 1
8178: PPUSH
8179: LD_STRING DStevensLeftBehind-Bur-1
8181: PPUSH
8182: CALL_OW 88
// Stevens_Killed := true ;
8186: LD_ADDR_EXP 11
8190: PUSH
8191: LD_INT 1
8193: ST_TO_ADDR
// DialogueOff ;
8194: CALL_OW 7
// end ;
8198: LD_VAR 0 1
8202: RET
// var was_sheikh_obj ; every 0 0$1 trigger dialogy and See ( you , Mastodon ) do var a ;
8203: LD_EXP 46
8207: PUSH
8208: LD_EXP 1
8212: PPUSH
8213: LD_INT 1
8215: PPUSH
8216: CALL_OW 292
8220: AND
8221: IFFALSE 8308
8223: GO 8225
8225: DISABLE
8226: LD_INT 0
8228: PPUSH
// begin if not was_sheikh_obj then
8229: LD_LOC 13
8233: NOT
8234: IFFALSE 8251
// begin ChangeMissionObjectives ( MAddSheikh ) ;
8236: LD_STRING MAddSheikh
8238: PPUSH
8239: CALL_OW 337
// was_sheikh_obj := true ;
8243: LD_ADDR_LOC 13
8247: PUSH
8248: LD_INT 1
8250: ST_TO_ADDR
// end ; a := NearestUnitToUnit ( UnitFilter ( donttalk , [ f_sex , sex_male ] ) ^ Burlak , Mastodon ) ;
8251: LD_ADDR_VAR 0 1
8255: PUSH
8256: LD_LOC 11
8260: PPUSH
8261: LD_INT 26
8263: PUSH
8264: LD_INT 1
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: PPUSH
8271: CALL_OW 72
8275: PUSH
8276: LD_EXP 50
8280: ADD
8281: PPUSH
8282: LD_INT 1
8284: PPUSH
8285: CALL_OW 74
8289: ST_TO_ADDR
// if a then
8290: LD_VAR 0 1
8294: IFFALSE 8307
// DMastodon ( a ) else
8296: LD_VAR 0 1
8300: PPUSH
8301: CALL 8311 0 1
8305: GO 8308
// enable ;
8307: ENABLE
// end ;
8308: PPOPN 1
8310: END
// function DMastodon ( who ) ; begin
8311: LD_INT 0
8313: PPUSH
// DialogueOn ;
8314: CALL_OW 6
// if who = Bur then
8318: LD_VAR 0 1
8322: PUSH
8323: LD_LOC 1
8327: EQUAL
8328: IFFALSE 8344
// Say ( who , DMastodon-Bur-1 ) else
8330: LD_VAR 0 1
8334: PPUSH
8335: LD_STRING DMastodon-Bur-1
8337: PPUSH
8338: CALL_OW 88
8342: GO 8356
// Say ( who , DMastodon-RSol1-1 ) ;
8344: LD_VAR 0 1
8348: PPUSH
8349: LD_STRING DMastodon-RSol1-1
8351: PPUSH
8352: CALL_OW 88
// Say ( Glb , DMastodon-Glb-1 ) ;
8356: LD_LOC 5
8360: PPUSH
8361: LD_STRING DMastodon-Glb-1
8363: PPUSH
8364: CALL_OW 88
// DialogueOff ;
8368: CALL_OW 7
// end ;
8372: LD_VAR 0 2
8376: RET
// every 0 0$1 trigger dialogy and IsDead ( Omar ) do
8377: LD_EXP 46
8381: PUSH
8382: LD_EXP 61
8386: PPUSH
8387: CALL_OW 301
8391: AND
8392: IFFALSE 8408
8394: GO 8396
8396: DISABLE
// begin DOmar ;
8397: CALL 8409 0 0
// ChangeMissionObjectives ( MOutSheikh ) ;
8401: LD_STRING MOutSheikh
8403: PPUSH
8404: CALL_OW 337
// end ;
8408: END
// function DOmar ; var who , mytick ; begin
8409: LD_INT 0
8411: PPUSH
8412: PPUSH
8413: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , class_soldier , 0 ) ;
8414: LD_ADDR_VAR 0 2
8418: PUSH
8419: LD_LOC 11
8423: PPUSH
8424: LD_EXP 1
8428: PPUSH
8429: LD_INT 1
8431: PPUSH
8432: LD_INT 1
8434: PPUSH
8435: LD_INT 0
8437: PPUSH
8438: CALL 23597 0 5
8442: ST_TO_ADDR
// DialogueOn ;
8443: CALL_OW 6
// if IsLive ( Kar ) then
8447: LD_LOC 3
8451: PPUSH
8452: CALL_OW 300
8456: IFFALSE 8470
// Say ( Kar , DOmar-Kar-1 ) ;
8458: LD_LOC 3
8462: PPUSH
8463: LD_STRING DOmar-Kar-1
8465: PPUSH
8466: CALL_OW 88
// if IsLive ( Ptr ) then
8470: LD_LOC 4
8474: PPUSH
8475: CALL_OW 300
8479: IFFALSE 8493
// Say ( Ptr , DOmar-Ptr-1 ) ;
8481: LD_LOC 4
8485: PPUSH
8486: LD_STRING DOmar-Ptr-1
8488: PPUSH
8489: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
8493: LD_LOC 3
8497: PPUSH
8498: CALL_OW 300
8502: NOT
8503: PUSH
8504: LD_LOC 4
8508: PPUSH
8509: CALL_OW 300
8513: NOT
8514: AND
8515: IFFALSE 8529
// Say ( who , DOmar-RSol1-1 ) ;
8517: LD_VAR 0 2
8521: PPUSH
8522: LD_STRING DOmar-RSol1-1
8524: PPUSH
8525: CALL_OW 88
// if SayRadio ( Heike , DOmar-Hke-1 ) then
8529: LD_EXP 60
8533: PPUSH
8534: LD_STRING DOmar-Hke-1
8536: PPUSH
8537: CALL_OW 94
8541: IFFALSE 8555
// Say ( Bur , DOmar-Bur-1 ) ;
8543: LD_LOC 1
8547: PPUSH
8548: LD_STRING DOmar-Bur-1
8550: PPUSH
8551: CALL_OW 88
// DialogueOff ;
8555: CALL_OW 7
// end ;
8559: LD_VAR 0 1
8563: RET
// every 0 0$1 + 0 0$3.5 trigger dialogy do var i , arForces ;
8564: LD_EXP 46
8568: IFFALSE 8715
8570: GO 8572
8572: DISABLE
8573: LD_INT 0
8575: PPUSH
8576: PPUSH
// begin enable ;
8577: ENABLE
// arForces = FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
8578: LD_ADDR_VAR 0 2
8582: PUSH
8583: LD_INT 22
8585: PUSH
8586: LD_INT 2
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 21
8595: PUSH
8596: LD_INT 1
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: PPUSH
8607: CALL_OW 69
8611: ST_TO_ADDR
// for i in UnitsInside ( FilterUnitsInArea ( RoadArea , [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ) do
8612: LD_ADDR_VAR 0 1
8616: PUSH
8617: LD_INT 32
8619: PPUSH
8620: LD_INT 22
8622: PUSH
8623: LD_INT 2
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 21
8632: PUSH
8633: LD_INT 2
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 70
8648: PPUSH
8649: CALL_OW 313
8653: PUSH
8654: FOR_IN
8655: IFFALSE 8675
// arForces = arForces diff i ;
8657: LD_ADDR_VAR 0 2
8661: PUSH
8662: LD_VAR 0 2
8666: PUSH
8667: LD_VAR 0 1
8671: DIFF
8672: ST_TO_ADDR
8673: GO 8654
8675: POP
8676: POP
// if arForces <= 4 and ( IsDead ( Omar ) or not IsPlaced ( Omar ) ) then
8677: LD_VAR 0 2
8681: PUSH
8682: LD_INT 4
8684: LESSEQUAL
8685: PUSH
8686: LD_EXP 61
8690: PPUSH
8691: CALL_OW 301
8695: PUSH
8696: LD_EXP 61
8700: PPUSH
8701: CALL_OW 305
8705: NOT
8706: OR
8707: AND
8708: IFFALSE 8715
// begin disable ;
8710: DISABLE
// DBreaktrough ;
8711: CALL 8718 0 0
// end ; end ;
8715: PPOPN 2
8717: END
// function DBreaktrough ; begin
8718: LD_INT 0
8720: PPUSH
// if tick <= breaketrough_time then
8721: LD_OWVAR 1
8725: PUSH
8726: LD_EXP 17
8730: LESSEQUAL
8731: IFFALSE 8741
// action_was_fast := true ;
8733: LD_ADDR_EXP 9
8737: PUSH
8738: LD_INT 1
8740: ST_TO_ADDR
// breaked_trough := true ;
8741: LD_ADDR_EXP 10
8745: PUSH
8746: LD_INT 1
8748: ST_TO_ADDR
// DialogueOn ;
8749: CALL_OW 6
// Say ( Ptr , DBreakthrough-Ptr-1 ) ;
8753: LD_LOC 4
8757: PPUSH
8758: LD_STRING DBreakthrough-Ptr-1
8760: PPUSH
8761: CALL_OW 88
// Say ( Bur , DBreakthrough-Bur-1 ) ;
8765: LD_LOC 1
8769: PPUSH
8770: LD_STRING DBreakthrough-Bur-1
8772: PPUSH
8773: CALL_OW 88
// SayRadio ( Pla , DBreakthrough-Pla-1 ) ;
8777: LD_LOC 2
8781: PPUSH
8782: LD_STRING DBreakthrough-Pla-1
8784: PPUSH
8785: CALL_OW 94
// if action_was_fast then
8789: LD_EXP 9
8793: IFFALSE 8809
// SayRadio ( Pla , DBreakthrough-Pla-1a ) else
8795: LD_LOC 2
8799: PPUSH
8800: LD_STRING DBreakthrough-Pla-1a
8802: PPUSH
8803: CALL_OW 94
8807: GO 8821
// SayRadio ( Pla , DBreakthrough-Pla-1b ) ;
8809: LD_LOC 2
8813: PPUSH
8814: LD_STRING DBreakthrough-Pla-1b
8816: PPUSH
8817: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
8821: LD_INT 22
8823: PUSH
8824: LD_EXP 1
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PUSH
8833: LD_INT 23
8835: PUSH
8836: LD_INT 3
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 2
8845: PUSH
8846: LD_INT 30
8848: PUSH
8849: LD_INT 6
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: PUSH
8856: LD_INT 30
8858: PUSH
8859: LD_INT 7
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: PUSH
8866: LD_INT 30
8868: PUSH
8869: LD_INT 8
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: LIST
8886: PPUSH
8887: CALL_OW 69
8891: IFFALSE 8920
// begin SayRadio ( Pla , DBreakthrough-Pla-1c ) ;
8893: LD_LOC 2
8897: PPUSH
8898: LD_STRING DBreakthrough-Pla-1c
8900: PPUSH
8901: CALL_OW 94
// ChangeMissionObjectives ( MAddLab ) ;
8905: LD_STRING MAddLab
8907: PPUSH
8908: CALL_OW 337
// znicit_lab := true ;
8912: LD_ADDR_EXP 67
8916: PUSH
8917: LD_INT 1
8919: ST_TO_ADDR
// end ; if byl_stevens and IsLive ( Huck ) and stv_depot then
8920: LD_EXP 66
8924: PUSH
8925: LD_LOC 7
8929: PPUSH
8930: CALL_OW 300
8934: AND
8935: PUSH
8936: LD_LOC 12
8940: AND
8941: IFFALSE 8947
// DStevensLeftBehind ;
8943: CALL 8081 0 0
// DialogueOff ;
8947: CALL_OW 7
// end ;
8951: LD_VAR 0 1
8955: RET
// export znicit_lab ; every 0 0$3 trigger znicit_lab and not FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
8956: LD_EXP 67
8960: PUSH
8961: LD_INT 22
8963: PUSH
8964: LD_EXP 1
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 23
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 2
8985: PUSH
8986: LD_INT 30
8988: PUSH
8989: LD_INT 6
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: LD_INT 30
8998: PUSH
8999: LD_INT 7
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PUSH
9006: LD_INT 30
9008: PUSH
9009: LD_INT 8
9011: PUSH
9012: EMPTY
9013: LIST
9014: LIST
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: NOT
9032: AND
9033: IFFALSE 9045
9035: GO 9037
9037: DISABLE
// begin ChangeMissionObjectives ( MOutLab ) ;
9038: LD_STRING MOutLab
9040: PPUSH
9041: CALL_OW 337
// end ;
9045: END
// every 0 0$5 + 0 0$0.5 trigger dialogy and breaked_trough and FilterUnitsInArea ( enter_near_road , [ [ f_side , you ] ] ) and See_any ( you , [ ArScout1 , ArScout2 , ArScout3 ] ) do
9046: LD_EXP 46
9050: PUSH
9051: LD_EXP 10
9055: AND
9056: PUSH
9057: LD_INT 9
9059: PPUSH
9060: LD_INT 22
9062: PUSH
9063: LD_EXP 1
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 70
9079: AND
9080: PUSH
9081: LD_EXP 1
9085: PPUSH
9086: LD_EXP 76
9090: PUSH
9091: LD_EXP 77
9095: PUSH
9096: LD_EXP 78
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL 23798 0 2
9110: AND
9111: IFFALSE 9120
9113: GO 9115
9115: DISABLE
// begin DPatrol ;
9116: CALL 9121 0 0
// end ;
9120: END
// function DPatrol ; var RSol1 ; begin
9121: LD_INT 0
9123: PPUSH
9124: PPUSH
// RSol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
9125: LD_ADDR_VAR 0 2
9129: PUSH
9130: LD_LOC 11
9134: PPUSH
9135: LD_EXP 1
9139: PPUSH
9140: LD_INT 1
9142: PPUSH
9143: LD_INT 0
9145: PPUSH
9146: LD_INT 0
9148: PPUSH
9149: CALL 23597 0 5
9153: ST_TO_ADDR
// DialogueOn ;
9154: CALL_OW 6
// if IsLive ( Kar ) then
9158: LD_LOC 3
9162: PPUSH
9163: CALL_OW 300
9167: IFFALSE 9181
// Say ( Kar , DPatrol-Kar-1 ) ;
9169: LD_LOC 3
9173: PPUSH
9174: LD_STRING DPatrol-Kar-1
9176: PPUSH
9177: CALL_OW 88
// if IsLive ( Ptr ) then
9181: LD_LOC 4
9185: PPUSH
9186: CALL_OW 300
9190: IFFALSE 9204
// Say ( Ptr , DPatrol-Ptr-1 ) ;
9192: LD_LOC 4
9196: PPUSH
9197: LD_STRING DPatrol-Ptr-1
9199: PPUSH
9200: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
9204: LD_LOC 3
9208: PPUSH
9209: CALL_OW 300
9213: NOT
9214: PUSH
9215: LD_LOC 4
9219: PPUSH
9220: CALL_OW 300
9224: NOT
9225: AND
9226: IFFALSE 9240
// Say ( RSol1 , DPatrol-RSol1-1 ) ;
9228: LD_VAR 0 2
9232: PPUSH
9233: LD_STRING DPatrol-RSol1-1
9235: PPUSH
9236: CALL_OW 88
// Say ( Bur , DPatrol-Bur-1 ) ;
9240: LD_LOC 1
9244: PPUSH
9245: LD_STRING DPatrol-Bur-1
9247: PPUSH
9248: CALL_OW 88
// DialogueOff ;
9252: CALL_OW 7
// end ;
9256: LD_VAR 0 1
9260: RET
// var used1 , used2 ; function TestEnd ; var lidi_in , lidi_in_cars , lidi_all , i ; begin
9261: LD_INT 0
9263: PPUSH
9264: PPUSH
9265: PPUSH
9266: PPUSH
9267: PPUSH
// lidi_in_cars = [ ] ;
9268: LD_ADDR_VAR 0 3
9272: PUSH
9273: EMPTY
9274: ST_TO_ADDR
// lidi_in := FilterHumansInArea ( exit_rus , [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9275: LD_ADDR_VAR 0 2
9279: PUSH
9280: LD_INT 22
9282: PPUSH
9283: LD_INT 22
9285: PUSH
9286: LD_EXP 1
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 23
9297: PUSH
9298: LD_INT 3
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: LD_INT 21
9307: PUSH
9308: LD_INT 1
9310: PUSH
9311: EMPTY
9312: LIST
9313: LIST
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PPUSH
9320: CALL 23882 0 2
9324: ST_TO_ADDR
// for i in lidi_in do
9325: LD_ADDR_VAR 0 5
9329: PUSH
9330: LD_VAR 0 2
9334: PUSH
9335: FOR_IN
9336: IFFALSE 9379
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
9338: LD_VAR 0 5
9342: PPUSH
9343: CALL_OW 310
9347: PPUSH
9348: CALL_OW 247
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9377
// begin lidi_in_cars := lidi_in_cars ^ [ i ] ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_VAR 0 3
9367: PUSH
9368: LD_VAR 0 5
9372: PUSH
9373: EMPTY
9374: LIST
9375: ADD
9376: ST_TO_ADDR
// end ;
9377: GO 9335
9379: POP
9380: POP
// result := 0 ;
9381: LD_ADDR_VAR 0 1
9385: PUSH
9386: LD_INT 0
9388: ST_TO_ADDR
// if ( lidi_in >= 6 ) and ( IsInArea ( IsInUnit ( Bur ) , exit_rus ) ) then
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 6
9396: GREATEREQUAL
9397: PUSH
9398: LD_LOC 1
9402: PPUSH
9403: CALL_OW 310
9407: PPUSH
9408: LD_INT 22
9410: PPUSH
9411: CALL_OW 308
9415: AND
9416: IFFALSE 9568
// begin lidi_all := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9418: LD_ADDR_VAR 0 4
9422: PUSH
9423: LD_INT 22
9425: PUSH
9426: LD_EXP 1
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 23
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 21
9447: PUSH
9448: LD_INT 1
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PPUSH
9460: CALL_OW 69
9464: ST_TO_ADDR
// if lidi_in_cars >= 6 then
9465: LD_VAR 0 3
9469: PUSH
9470: LD_INT 6
9472: GREATEREQUAL
9473: IFFALSE 9533
// begin if ( lidi_all + 0 ) > ( lidi_in_cars + 0 ) then
9475: LD_VAR 0 4
9479: PUSH
9480: LD_INT 0
9482: PLUS
9483: PUSH
9484: LD_VAR 0 3
9488: PUSH
9489: LD_INT 0
9491: PLUS
9492: GREATER
9493: IFFALSE 9503
// begin result := 2 ;
9495: LD_ADDR_VAR 0 1
9499: PUSH
9500: LD_INT 2
9502: ST_TO_ADDR
// end ; if ( lidi_all + 0 ) <= ( lidi_in_cars + 0 ) then
9503: LD_VAR 0 4
9507: PUSH
9508: LD_INT 0
9510: PLUS
9511: PUSH
9512: LD_VAR 0 3
9516: PUSH
9517: LD_INT 0
9519: PLUS
9520: LESSEQUAL
9521: IFFALSE 9531
// result := 3 ;
9523: LD_ADDR_VAR 0 1
9527: PUSH
9528: LD_INT 3
9530: ST_TO_ADDR
// end else
9531: GO 9568
// begin if not used1 and ( lidi_in + 0 ) > ( lidi_in_cars + 0 ) then
9533: LD_LOC 14
9537: NOT
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: LD_INT 0
9546: PLUS
9547: PUSH
9548: LD_VAR 0 3
9552: PUSH
9553: LD_INT 0
9555: PLUS
9556: GREATER
9557: AND
9558: IFFALSE 9568
// begin result := 1 ;
9560: LD_ADDR_VAR 0 1
9564: PUSH
9565: LD_INT 1
9567: ST_TO_ADDR
// end ; end ; end ; end ;
9568: LD_VAR 0 1
9572: RET
// every 0 0$2 do var qr ;
9573: GO 9575
9575: DISABLE
9576: LD_INT 0
9578: PPUSH
// begin case TestEnd of 0 :
9579: CALL 9261 0 0
9583: PUSH
9584: LD_INT 0
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9603
9592: POP
// begin end_the_mission_allowed := false ;
9593: LD_ADDR_OWVAR 57
9597: PUSH
9598: LD_INT 0
9600: ST_TO_ADDR
// end ; 1 :
9601: GO 9734
9603: LD_INT 1
9605: DOUBLE
9606: EQUAL
9607: IFTRUE 9611
9609: GO 9650
9611: POP
// begin end_the_mission_allowed := false ;
9612: LD_ADDR_OWVAR 57
9616: PUSH
9617: LD_INT 0
9619: ST_TO_ADDR
// if not used1 then
9620: LD_LOC 14
9624: NOT
9625: IFFALSE 9648
// begin qr := Query ( Qvehicles ) ;
9627: LD_ADDR_VAR 0 1
9631: PUSH
9632: LD_STRING Qvehicles
9634: PPUSH
9635: CALL_OW 97
9639: ST_TO_ADDR
// used1 := true ;
9640: LD_ADDR_LOC 14
9644: PUSH
9645: LD_INT 1
9647: ST_TO_ADDR
// end ; end ; 2 :
9648: GO 9734
9650: LD_INT 2
9652: DOUBLE
9653: EQUAL
9654: IFTRUE 9658
9656: GO 9718
9658: POP
// begin end_the_mission_allowed := true ;
9659: LD_ADDR_OWVAR 57
9663: PUSH
9664: LD_INT 1
9666: ST_TO_ADDR
// if not used2 then
9667: LD_LOC 15
9671: NOT
9672: IFFALSE 9716
// begin ChangeMissionObjectives ( MOutDefend ) ;
9674: LD_STRING MOutDefend
9676: PPUSH
9677: CALL_OW 337
// qr := Query ( QEndMission ) ;
9681: LD_ADDR_VAR 0 1
9685: PUSH
9686: LD_STRING QEndMission
9688: PPUSH
9689: CALL_OW 97
9693: ST_TO_ADDR
// used2 := true ;
9694: LD_ADDR_LOC 15
9698: PUSH
9699: LD_INT 1
9701: ST_TO_ADDR
// if qr = 1 then
9702: LD_VAR 0 1
9706: PUSH
9707: LD_INT 1
9709: EQUAL
9710: IFFALSE 9716
// Vyhra ;
9712: CALL 301 0 0
// end ; end ; 3 :
9716: GO 9734
9718: LD_INT 3
9720: DOUBLE
9721: EQUAL
9722: IFTRUE 9726
9724: GO 9733
9726: POP
// begin Vyhra ;
9727: CALL 301 0 0
// end ; end ;
9731: GO 9734
9733: POP
// enable ;
9734: ENABLE
// end ;
9735: PPOPN 1
9737: END
// every 0 0$2 trigger IsInUnit ( Omar ) = mastodon do
9738: LD_EXP 61
9742: PPUSH
9743: CALL_OW 310
9747: PUSH
9748: LD_INT 1
9750: EQUAL
9751: IFFALSE 9768
9753: GO 9755
9755: DISABLE
// begin ComCarabine ( Omar ) ;
9756: LD_EXP 61
9760: PPUSH
9761: CALL_OW 162
// enable ( 99 ) ;
9765: LD_INT 99
9767: ENABLE_MARKED
// end ;
9768: END
// every 0 0$2 trigger not IsInUnit ( Omar ) = mastodon marked 99 do var mytick ;
9769: LD_EXP 61
9773: PPUSH
9774: CALL_OW 310
9778: PUSH
9779: LD_INT 1
9781: EQUAL
9782: NOT
9783: IFFALSE 9963
9785: GO 9787
9787: DISABLE
9788: LD_INT 0
9790: PPUSH
// begin ComSabre ( Omar ) ;
9791: LD_EXP 61
9795: PPUSH
9796: CALL_OW 163
// wait ( 0 0$1 ) ;
9800: LD_INT 35
9802: PPUSH
9803: CALL_OW 67
// mytick := tick + 0 0$5 ;
9807: LD_ADDR_VAR 0 1
9811: PUSH
9812: LD_OWVAR 1
9816: PUSH
9817: LD_INT 175
9819: PLUS
9820: ST_TO_ADDR
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
9821: LD_EXP 61
9825: PPUSH
9826: LD_INT 26
9828: PPUSH
9829: CALL_OW 308
9833: NOT
9834: PUSH
9835: LD_OWVAR 1
9839: PUSH
9840: LD_VAR 0 1
9844: LESS
9845: AND
9846: IFFALSE 9871
// begin ComMoveToArea ( Omar , omar_exit ) ;
9848: LD_EXP 61
9852: PPUSH
9853: LD_INT 26
9855: PPUSH
9856: CALL_OW 113
// DU_wait ( Omar ) ;
9860: LD_EXP 61
9864: PPUSH
9865: CALL 22055 0 1
// end ;
9869: GO 9821
// ComStop ( Omar ) ;
9871: LD_EXP 61
9875: PPUSH
9876: CALL_OW 141
// wait ( [ 4 4$30 , 2 2$15 , 0 0$30 ] [ difficulty ] ) ;
9880: LD_INT 9450
9882: PUSH
9883: LD_INT 4725
9885: PUSH
9886: LD_INT 1050
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: LIST
9893: PUSH
9894: LD_OWVAR 67
9898: ARRAY
9899: PPUSH
9900: CALL_OW 67
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
9904: LD_EXP 61
9908: PPUSH
9909: LD_INT 26
9911: PPUSH
9912: CALL_OW 308
9916: NOT
9917: PUSH
9918: LD_OWVAR 1
9922: PUSH
9923: LD_VAR 0 1
9927: LESS
9928: AND
9929: IFFALSE 9954
// begin ComMoveToArea ( Omar , omar_exit ) ;
9931: LD_EXP 61
9935: PPUSH
9936: LD_INT 26
9938: PPUSH
9939: CALL_OW 113
// DU_wait ( Omar ) ;
9943: LD_EXP 61
9947: PPUSH
9948: CALL 22055 0 1
// end ;
9952: GO 9904
// RemoveUnit ( Omar ) ;
9954: LD_EXP 61
9958: PPUSH
9959: CALL_OW 64
// end ; end_of_file
9963: PPOPN 1
9965: END
// var builds1 , builds2 , builds3 , builds4 , builds5 , builds6 , builds7 , builds8 ; export stavi ; var arabs_init ; var arabs ; var upgrade ; every 0 0$5 do var a ;
9966: GO 9968
9968: DISABLE
9969: LD_INT 0
9971: PPUSH
// begin a := sol ;
9972: LD_ADDR_VAR 0 1
9976: PUSH
9977: LD_EXP 19
9981: ST_TO_ADDR
// sol := UnitFilter ( a , [ [ f_class , class_soldier ] ] ) ;
9982: LD_ADDR_EXP 19
9986: PUSH
9987: LD_VAR 0 1
9991: PPUSH
9992: LD_INT 25
9994: PUSH
9995: LD_INT 1
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: EMPTY
10003: LIST
10004: PPUSH
10005: CALL_OW 72
10009: ST_TO_ADDR
// mor := UnitFilter ( a , [ [ f_class , class_mortar ] ] ) ;
10010: LD_ADDR_EXP 20
10014: PUSH
10015: LD_VAR 0 1
10019: PPUSH
10020: LD_INT 25
10022: PUSH
10023: LD_INT 8
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PUSH
10030: EMPTY
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// enable ;
10038: ENABLE
// end ;
10039: PPOPN 1
10041: END
// every 30 30$0 do var a , i ;
10042: GO 10044
10044: DISABLE
10045: LD_INT 0
10047: PPUSH
10048: PPUSH
// begin InitUc ;
10049: CALL_OW 18
// InitHc ;
10053: CALL_OW 19
// uc_nation := nation_arabian ;
10057: LD_ADDR_OWVAR 21
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
// uc_side := arabians ;
10065: LD_ADDR_OWVAR 20
10069: PUSH
10070: LD_EXP 3
10074: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
10075: LD_ADDR_VAR 0 2
10079: PUSH
10080: DOUBLE
10081: LD_INT 1
10083: DEC
10084: ST_TO_ADDR
10085: LD_INT 2
10087: PUSH
10088: LD_OWVAR 67
10092: PLUS
10093: PUSH
10094: FOR_TO
10095: IFFALSE 10161
// begin a := CreateHuman ;
10097: LD_ADDR_VAR 0 1
10101: PUSH
10102: CALL_OW 44
10106: ST_TO_ADDR
// PlaceUnitXYR ( a , 148 , 58 , 5 , false ) ;
10107: LD_VAR 0 1
10111: PPUSH
10112: LD_INT 148
10114: PPUSH
10115: LD_INT 58
10117: PPUSH
10118: LD_INT 5
10120: PPUSH
10121: LD_INT 0
10123: PPUSH
10124: CALL_OW 50
// ComMoveXY ( a , 134 , 68 ) ;
10128: LD_VAR 0 1
10132: PPUSH
10133: LD_INT 134
10135: PPUSH
10136: LD_INT 68
10138: PPUSH
10139: CALL_OW 111
// sol := sol ^ a ;
10143: LD_ADDR_EXP 19
10147: PUSH
10148: LD_EXP 19
10152: PUSH
10153: LD_VAR 0 1
10157: ADD
10158: ST_TO_ADDR
// end ;
10159: GO 10094
10161: POP
10162: POP
// end ;
10163: PPOPN 2
10165: END
// export function place_arabs_base ; begin
10166: LD_INT 0
10168: PPUSH
// upgrade := 10 ;
10169: LD_ADDR_LOC 26
10173: PUSH
10174: LD_INT 10
10176: ST_TO_ADDR
// arabs_init := [ [ [ 2 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 3 ] , [ 0 , class_mortar , 2 ] , [ 3 , class_mechanic , 3 ] ] , [ [ 2 , class_engineer , 5 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 1 , class_mortar , 3 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 2 , class_engineer , 6 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 6 ] , [ 2 , class_mortar , 5 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ;
10177: LD_ADDR_LOC 24
10181: PUSH
10182: LD_INT 2
10184: PUSH
10185: LD_INT 2
10187: PUSH
10188: LD_INT 4
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: LIST
10195: PUSH
10196: LD_INT 1
10198: PUSH
10199: LD_INT 4
10201: PUSH
10202: LD_INT 4
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 8
10212: PUSH
10213: LD_INT 1
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: PUSH
10224: LD_INT 0
10226: PUSH
10227: LD_INT 8
10229: PUSH
10230: LD_INT 2
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 3
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: LIST
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: LD_INT 2
10264: PUSH
10265: LD_INT 5
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: LIST
10272: PUSH
10273: LD_INT 1
10275: PUSH
10276: LD_INT 4
10278: PUSH
10279: LD_INT 4
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: LIST
10286: PUSH
10287: LD_INT 8
10289: PUSH
10290: LD_INT 1
10292: PUSH
10293: LD_INT 4
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 1
10303: PUSH
10304: LD_INT 8
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 3
10317: PUSH
10318: LD_INT 3
10320: PUSH
10321: LD_INT 4
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: LIST
10328: PUSH
10329: EMPTY
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 2
10338: PUSH
10339: LD_INT 2
10341: PUSH
10342: LD_INT 6
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 1
10352: PUSH
10353: LD_INT 4
10355: PUSH
10356: LD_INT 4
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: PUSH
10364: LD_INT 8
10366: PUSH
10367: LD_INT 1
10369: PUSH
10370: LD_INT 6
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: PUSH
10378: LD_INT 2
10380: PUSH
10381: LD_INT 8
10383: PUSH
10384: LD_INT 5
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: LIST
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 3
10397: PUSH
10398: LD_INT 6
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: LIST
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: PUSH
10418: LD_OWVAR 67
10422: ARRAY
10423: ST_TO_ADDR
// builds1 := [ [ 124 , 60 , 2 , b_depot ] , [ 118 , 63 , 1 , b_breastwork ] , [ 120 , 66 , 1 , b_breastwork ] , [ 123 , 73 , 1 , b_breastwork ] ] ;
10424: LD_ADDR_LOC 16
10428: PUSH
10429: LD_INT 124
10431: PUSH
10432: LD_INT 60
10434: PUSH
10435: LD_INT 2
10437: PUSH
10438: LD_INT 0
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: LIST
10445: LIST
10446: PUSH
10447: LD_INT 118
10449: PUSH
10450: LD_INT 63
10452: PUSH
10453: LD_INT 1
10455: PUSH
10456: LD_INT 31
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: LD_INT 120
10467: PUSH
10468: LD_INT 66
10470: PUSH
10471: LD_INT 1
10473: PUSH
10474: LD_INT 31
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: PUSH
10483: LD_INT 123
10485: PUSH
10486: LD_INT 73
10488: PUSH
10489: LD_INT 1
10491: PUSH
10492: LD_INT 31
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: ST_TO_ADDR
// builds2 := [ [ 129 , 74 , 2 , b_armoury ] , [ 131 , 51 , 2 , b_oil_mine ] , [ 138 , 78 , 5 , b_lab ] ] ;
10507: LD_ADDR_LOC 17
10511: PUSH
10512: LD_INT 129
10514: PUSH
10515: LD_INT 74
10517: PUSH
10518: LD_INT 2
10520: PUSH
10521: LD_INT 4
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: LD_INT 131
10532: PUSH
10533: LD_INT 51
10535: PUSH
10536: LD_INT 2
10538: PUSH
10539: LD_INT 29
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: PUSH
10548: LD_INT 138
10550: PUSH
10551: LD_INT 78
10553: PUSH
10554: LD_INT 5
10556: PUSH
10557: LD_INT 6
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: LIST
10570: ST_TO_ADDR
// builds3 := [ [ 137 , 63 , 4 , b_workshop ] , [ 137 , 63 , upgrade , b_workshop ] , [ 137 , 60 , 3 , b_ext_stitch ] , [ 128 , 53 , 1 , b_oil_power ] , [ 140 , 66 , 5 , b_ext_track ] ] ;
10571: LD_ADDR_LOC 18
10575: PUSH
10576: LD_INT 137
10578: PUSH
10579: LD_INT 63
10581: PUSH
10582: LD_INT 4
10584: PUSH
10585: LD_INT 2
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: PUSH
10594: LD_INT 137
10596: PUSH
10597: LD_INT 63
10599: PUSH
10600: LD_LOC 26
10604: PUSH
10605: LD_INT 2
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: LD_INT 137
10616: PUSH
10617: LD_INT 60
10619: PUSH
10620: LD_INT 3
10622: PUSH
10623: LD_INT 23
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: PUSH
10632: LD_INT 128
10634: PUSH
10635: LD_INT 53
10637: PUSH
10638: LD_INT 1
10640: PUSH
10641: LD_INT 26
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: LIST
10648: LIST
10649: PUSH
10650: LD_INT 140
10652: PUSH
10653: LD_INT 66
10655: PUSH
10656: LD_INT 5
10658: PUSH
10659: LD_INT 16
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: LIST
10672: LIST
10673: LIST
10674: ST_TO_ADDR
// builds4 := [ [ 128 , 56 , 1 , b_oil_power ] , [ 138 , 78 , upgrade , b_lab , b_lab_weapon ] ] ;
10675: LD_ADDR_LOC 19
10679: PUSH
10680: LD_INT 128
10682: PUSH
10683: LD_INT 56
10685: PUSH
10686: LD_INT 1
10688: PUSH
10689: LD_INT 26
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 138
10700: PUSH
10701: LD_INT 78
10703: PUSH
10704: LD_LOC 26
10708: PUSH
10709: LD_INT 6
10711: PUSH
10712: LD_INT 10
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: ST_TO_ADDR
// builds5 := [ [ 141 , 63 , 4 , b_ext_gun ] ] ;
10726: LD_ADDR_LOC 20
10730: PUSH
10731: LD_INT 141
10733: PUSH
10734: LD_INT 63
10736: PUSH
10737: LD_INT 4
10739: PUSH
10740: LD_INT 17
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PUSH
10749: EMPTY
10750: LIST
10751: ST_TO_ADDR
// builds6 := [ [ 129 , 74 , upgrade , b_armoury ] ] ;
10752: LD_ADDR_LOC 21
10756: PUSH
10757: LD_INT 129
10759: PUSH
10760: LD_INT 74
10762: PUSH
10763: LD_LOC 26
10767: PUSH
10768: LD_INT 4
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: LIST
10776: PUSH
10777: EMPTY
10778: LIST
10779: ST_TO_ADDR
// builds7 := [ [ 138 , 78 , upgrade , b_lab , b_lab_opto ] , [ 118 , 61 , upgrade , b_breastwork , ar_gun ] , [ 120 , 66 , upgrade , b_breastwork , ar_gun ] , [ 123 , 73 , upgrade , b_breastwork , ar_gun ] , [ 124 , 60 , upgrade , b_depot ] ] ;
10780: LD_ADDR_LOC 22
10784: PUSH
10785: LD_INT 138
10787: PUSH
10788: LD_INT 78
10790: PUSH
10791: LD_LOC 26
10795: PUSH
10796: LD_INT 6
10798: PUSH
10799: LD_INT 15
10801: PUSH
10802: EMPTY
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: PUSH
10809: LD_INT 118
10811: PUSH
10812: LD_INT 61
10814: PUSH
10815: LD_LOC 26
10819: PUSH
10820: LD_INT 31
10822: PUSH
10823: LD_INT 27
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: PUSH
10833: LD_INT 120
10835: PUSH
10836: LD_INT 66
10838: PUSH
10839: LD_LOC 26
10843: PUSH
10844: LD_INT 31
10846: PUSH
10847: LD_INT 27
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 123
10859: PUSH
10860: LD_INT 73
10862: PUSH
10863: LD_LOC 26
10867: PUSH
10868: LD_INT 31
10870: PUSH
10871: LD_INT 27
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: PUSH
10881: LD_INT 124
10883: PUSH
10884: LD_INT 60
10886: PUSH
10887: LD_LOC 26
10891: PUSH
10892: LD_INT 0
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: ST_TO_ADDR
// builds8 := [ [ 137 , 67 , 0 , b_ext_radar ] ] ;
10908: LD_ADDR_LOC 23
10912: PUSH
10913: LD_INT 137
10915: PUSH
10916: LD_INT 67
10918: PUSH
10919: LD_INT 0
10921: PUSH
10922: LD_INT 20
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: PUSH
10931: EMPTY
10932: LIST
10933: ST_TO_ADDR
// place_base ( builds1 ) ;
10934: LD_LOC 16
10938: PPUSH
10939: CALL 11061 0 1
// place_arabs ;
10943: CALL 11267 0 0
// end ;
10947: LD_VAR 0 1
10951: RET
// every 0 0$5 do
10952: GO 10954
10954: DISABLE
// begin build_base ( builds2 ) ;
10955: LD_LOC 17
10959: PPUSH
10960: CALL 11487 0 1
// wait ( 0 0$40 ) ;
10964: LD_INT 1400
10966: PPUSH
10967: CALL_OW 67
// build_base ( builds3 ) ;
10971: LD_LOC 18
10975: PPUSH
10976: CALL 11487 0 1
// wait ( 2 2$0 ) ;
10980: LD_INT 4200
10982: PPUSH
10983: CALL_OW 67
// build_base ( builds4 ) ;
10987: LD_LOC 19
10991: PPUSH
10992: CALL 11487 0 1
// wait ( 3 3$0 ) ;
10996: LD_INT 6300
10998: PPUSH
10999: CALL_OW 67
// build_base ( builds5 ) ;
11003: LD_LOC 20
11007: PPUSH
11008: CALL 11487 0 1
// wait ( 10 10$0 ) ;
11012: LD_INT 21000
11014: PPUSH
11015: CALL_OW 67
// build_base ( builds6 ) ;
11019: LD_LOC 21
11023: PPUSH
11024: CALL 11487 0 1
// wait ( 10 10$0 ) ;
11028: LD_INT 21000
11030: PPUSH
11031: CALL_OW 67
// build_base ( builds7 ) ;
11035: LD_LOC 22
11039: PPUSH
11040: CALL 11487 0 1
// wait ( 5 5$0 ) ;
11044: LD_INT 10500
11046: PPUSH
11047: CALL_OW 67
// build_base ( builds8 ) ;
11051: LD_LOC 23
11055: PPUSH
11056: CALL 11487 0 1
// end ;
11060: END
// function place_base ( builds ) ; var i , base ; begin
11061: LD_INT 0
11063: PPUSH
11064: PPUSH
11065: PPUSH
// InitUc ;
11066: CALL_OW 18
// InitBc ;
11070: CALL_OW 21
// uc_side := arabians ;
11074: LD_ADDR_OWVAR 20
11078: PUSH
11079: LD_EXP 3
11083: ST_TO_ADDR
// uc_nation := nation_arabian ;
11084: LD_ADDR_OWVAR 21
11088: PUSH
11089: LD_INT 2
11091: ST_TO_ADDR
// for i in builds do
11092: LD_ADDR_VAR 0 3
11096: PUSH
11097: LD_VAR 0 1
11101: PUSH
11102: FOR_IN
11103: IFFALSE 11201
// begin bc_type := i [ 4 ] ;
11105: LD_ADDR_OWVAR 42
11109: PUSH
11110: LD_VAR 0 3
11114: PUSH
11115: LD_INT 4
11117: ARRAY
11118: ST_TO_ADDR
// if bc_type in [ b_lab , b_lab_half , b_lab_full ] then
11119: LD_OWVAR 42
11123: PUSH
11124: LD_INT 6
11126: PUSH
11127: LD_INT 7
11129: PUSH
11130: LD_INT 8
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: IN
11138: IFFALSE 11168
// begin bc_kind1 := i [ 5 ] ;
11140: LD_ADDR_OWVAR 44
11144: PUSH
11145: LD_VAR 0 3
11149: PUSH
11150: LD_INT 5
11152: ARRAY
11153: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
11154: LD_ADDR_OWVAR 45
11158: PUSH
11159: LD_VAR 0 3
11163: PUSH
11164: LD_INT 6
11166: ARRAY
11167: ST_TO_ADDR
// end ; CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11168: LD_VAR 0 3
11172: PUSH
11173: LD_INT 1
11175: ARRAY
11176: PPUSH
11177: LD_VAR 0 3
11181: PUSH
11182: LD_INT 2
11184: ARRAY
11185: PPUSH
11186: LD_VAR 0 3
11190: PUSH
11191: LD_INT 3
11193: ARRAY
11194: PPUSH
11195: CALL_OW 47
// end ;
11199: GO 11102
11201: POP
11202: POP
// base := GetBase ( FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
11203: LD_ADDR_VAR 0 4
11207: PUSH
11208: LD_INT 30
11210: PUSH
11211: LD_INT 0
11213: PUSH
11214: EMPTY
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: PUSH
11223: LD_INT 1
11225: ARRAY
11226: PPUSH
11227: CALL_OW 274
11231: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 450 ) ;
11232: LD_VAR 0 4
11236: PPUSH
11237: LD_INT 1
11239: PPUSH
11240: LD_INT 450
11242: PPUSH
11243: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11247: LD_VAR 0 4
11251: PPUSH
11252: LD_INT 2
11254: PPUSH
11255: LD_INT 200
11257: PPUSH
11258: CALL_OW 277
// end ;
11262: LD_VAR 0 2
11266: RET
// function place_arabs ; var i , j ; begin
11267: LD_INT 0
11269: PPUSH
11270: PPUSH
11271: PPUSH
// InitUc ;
11272: CALL_OW 18
// InitHc ;
11276: CALL_OW 19
// uc_side := arabians ;
11280: LD_ADDR_OWVAR 20
11284: PUSH
11285: LD_EXP 3
11289: ST_TO_ADDR
// uc_nation := nation_arabian ;
11290: LD_ADDR_OWVAR 21
11294: PUSH
11295: LD_INT 2
11297: ST_TO_ADDR
// PlaceUnitXY ( Mastodon , 130 , 67 , false ) ;
11298: LD_INT 1
11300: PPUSH
11301: LD_INT 130
11303: PPUSH
11304: LD_INT 67
11306: PPUSH
11307: LD_INT 0
11309: PPUSH
11310: CALL_OW 48
// PlaceUnitXYR ( Omar , GetX ( Mastodon ) , GetY ( Mastodon ) , 5 , false ) ;
11314: LD_EXP 61
11318: PPUSH
11319: LD_INT 1
11321: PPUSH
11322: CALL_OW 250
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: CALL_OW 251
11334: PPUSH
11335: LD_INT 5
11337: PPUSH
11338: LD_INT 0
11340: PPUSH
11341: CALL_OW 50
// ComCarabine ( Omar ) ;
11345: LD_EXP 61
11349: PPUSH
11350: CALL_OW 162
// AddComEnterUnit ( Omar , Mastodon ) ;
11354: LD_EXP 61
11358: PPUSH
11359: LD_INT 1
11361: PPUSH
11362: CALL_OW 180
// for i in arabs_init do
11366: LD_ADDR_VAR 0 2
11370: PUSH
11371: LD_LOC 24
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11448
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
11379: LD_INT 0
11381: PPUSH
11382: LD_VAR 0 2
11386: PUSH
11387: LD_INT 2
11389: ARRAY
11390: PPUSH
11391: LD_VAR 0 2
11395: PUSH
11396: LD_INT 3
11398: ARRAY
11399: PPUSH
11400: CALL_OW 380
// for j := 1 to i [ 1 ] do
11404: LD_ADDR_VAR 0 3
11408: PUSH
11409: DOUBLE
11410: LD_INT 1
11412: DEC
11413: ST_TO_ADDR
11414: LD_VAR 0 2
11418: PUSH
11419: LD_INT 1
11421: ARRAY
11422: PUSH
11423: FOR_TO
11424: IFFALSE 11444
// begin arabs := arabs ^ CreateHuman ;
11426: LD_ADDR_LOC 25
11430: PUSH
11431: LD_LOC 25
11435: PUSH
11436: CALL_OW 44
11440: ADD
11441: ST_TO_ADDR
// end ;
11442: GO 11423
11444: POP
11445: POP
// end ;
11446: GO 11376
11448: POP
11449: POP
// for i in arabs do
11450: LD_ADDR_VAR 0 2
11454: PUSH
11455: LD_LOC 25
11459: PUSH
11460: FOR_IN
11461: IFFALSE 11480
// PlaceUnitArea ( i , ar_place , false ) ;
11463: LD_VAR 0 2
11467: PPUSH
11468: LD_INT 4
11470: PPUSH
11471: LD_INT 0
11473: PPUSH
11474: CALL_OW 49
11478: GO 11460
11480: POP
11481: POP
// end ;
11482: LD_VAR 0 1
11486: RET
// function build_base ( builds ) ; var i , a , tmp_eng , eng2 ; begin
11487: LD_INT 0
11489: PPUSH
11490: PPUSH
11491: PPUSH
11492: PPUSH
11493: PPUSH
// while not eng do
11494: LD_EXP 23
11498: NOT
11499: IFFALSE 11510
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
11508: GO 11494
// eng2 := eng ;
11510: LD_ADDR_VAR 0 6
11514: PUSH
11515: LD_EXP 23
11519: ST_TO_ADDR
// tmp_eng := eng2 ;
11520: LD_ADDR_VAR 0 5
11524: PUSH
11525: LD_VAR 0 6
11529: ST_TO_ADDR
// eng := [ ] ;
11530: LD_ADDR_EXP 23
11534: PUSH
11535: EMPTY
11536: ST_TO_ADDR
// for i in builds do
11537: LD_ADDR_VAR 0 3
11541: PUSH
11542: LD_VAR 0 1
11546: PUSH
11547: FOR_IN
11548: IFFALSE 11949
// begin ComExitBuilding ( tmp_eng ) ;
11550: LD_VAR 0 5
11554: PPUSH
11555: CALL_OW 122
// while not BuildingsInProgress ( arabians ) do
11559: LD_EXP 3
11563: PPUSH
11564: CALL_OW 345
11568: NOT
11569: IFFALSE 11894
// begin tmp_eng := eng2 diff DU_units ;
11571: LD_ADDR_VAR 0 5
11575: PUSH
11576: LD_VAR 0 6
11580: PUSH
11581: LD_EXP 82
11585: DIFF
11586: ST_TO_ADDR
// if i [ 3 ] = upgrade then
11587: LD_VAR 0 3
11591: PUSH
11592: LD_INT 3
11594: ARRAY
11595: PUSH
11596: LD_LOC 26
11600: EQUAL
11601: IFFALSE 11822
// begin if i [ 4 ] in [ b_lab , b_lab_half ] then
11603: LD_VAR 0 3
11607: PUSH
11608: LD_INT 4
11610: ARRAY
11611: PUSH
11612: LD_INT 6
11614: PUSH
11615: LD_INT 7
11617: PUSH
11618: EMPTY
11619: LIST
11620: LIST
11621: IN
11622: IFFALSE 11698
// begin AddComUpgradeLab ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11624: LD_VAR 0 3
11628: PUSH
11629: LD_INT 1
11631: ARRAY
11632: PPUSH
11633: LD_VAR 0 3
11637: PUSH
11638: LD_INT 2
11640: ARRAY
11641: PPUSH
11642: LD_VAR 0 3
11646: PUSH
11647: LD_INT 4
11649: ARRAY
11650: PPUSH
11651: CALL 11972 0 3
11655: PPUSH
11656: LD_VAR 0 3
11660: PUSH
11661: LD_INT 5
11663: ARRAY
11664: PPUSH
11665: CALL_OW 207
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11669: LD_VAR 0 5
11673: PPUSH
11674: LD_VAR 0 3
11678: PUSH
11679: LD_INT 1
11681: ARRAY
11682: PPUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_INT 2
11690: ARRAY
11691: PPUSH
11692: CALL_OW 171
// end else
11696: GO 11820
// begin AddComUpgrade ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) ) ;
11698: LD_VAR 0 3
11702: PUSH
11703: LD_INT 1
11705: ARRAY
11706: PPUSH
11707: LD_VAR 0 3
11711: PUSH
11712: LD_INT 2
11714: ARRAY
11715: PPUSH
11716: LD_VAR 0 3
11720: PUSH
11721: LD_INT 4
11723: ARRAY
11724: PPUSH
11725: CALL 11972 0 3
11729: PPUSH
11730: CALL_OW 206
// if i [ 4 ] = b_breastwork then
11734: LD_VAR 0 3
11738: PUSH
11739: LD_INT 4
11741: ARRAY
11742: PUSH
11743: LD_INT 31
11745: EQUAL
11746: IFFALSE 11793
// AddComPlaceWeapon ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11748: LD_VAR 0 3
11752: PUSH
11753: LD_INT 1
11755: ARRAY
11756: PPUSH
11757: LD_VAR 0 3
11761: PUSH
11762: LD_INT 2
11764: ARRAY
11765: PPUSH
11766: LD_VAR 0 3
11770: PUSH
11771: LD_INT 4
11773: ARRAY
11774: PPUSH
11775: CALL 11972 0 3
11779: PPUSH
11780: LD_VAR 0 3
11784: PUSH
11785: LD_INT 5
11787: ARRAY
11788: PPUSH
11789: CALL_OW 208
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11793: LD_VAR 0 5
11797: PPUSH
11798: LD_VAR 0 3
11802: PUSH
11803: LD_INT 1
11805: ARRAY
11806: PPUSH
11807: LD_VAR 0 3
11811: PUSH
11812: LD_INT 2
11814: ARRAY
11815: PPUSH
11816: CALL_OW 171
// end ; end else
11820: GO 11885
// begin AddComBuild ( UnitFilter ( tmp_eng , [ f_not , [ f_hastask ] ] ) , i [ 4 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11822: LD_VAR 0 5
11826: PPUSH
11827: LD_INT 3
11829: PUSH
11830: LD_INT 60
11832: PUSH
11833: EMPTY
11834: LIST
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PPUSH
11840: CALL_OW 72
11844: PPUSH
11845: LD_VAR 0 3
11849: PUSH
11850: LD_INT 4
11852: ARRAY
11853: PPUSH
11854: LD_VAR 0 3
11858: PUSH
11859: LD_INT 1
11861: ARRAY
11862: PPUSH
11863: LD_VAR 0 3
11867: PUSH
11868: LD_INT 2
11870: ARRAY
11871: PPUSH
11872: LD_VAR 0 3
11876: PUSH
11877: LD_INT 3
11879: ARRAY
11880: PPUSH
11881: CALL_OW 205
// end ; wait ( 0 0$5 ) ;
11885: LD_INT 175
11887: PPUSH
11888: CALL_OW 67
// end ;
11892: GO 11559
// stavi := i ;
11894: LD_ADDR_EXP 68
11898: PUSH
11899: LD_VAR 0 3
11903: ST_TO_ADDR
// while BuildingsInProgress ( arabians ) do
11904: LD_EXP 3
11908: PPUSH
11909: CALL_OW 345
11913: IFFALSE 11924
// wait ( 0 0$1 ) ;
11915: LD_INT 35
11917: PPUSH
11918: CALL_OW 67
11922: GO 11904
// stavi := [ ] ;
11924: LD_ADDR_EXP 68
11928: PUSH
11929: EMPTY
11930: ST_TO_ADDR
// ComStop ( tmp_eng ) ;
11931: LD_VAR 0 5
11935: PPUSH
11936: CALL_OW 141
// wait ( 0 0$1 ) ;
11940: LD_INT 35
11942: PPUSH
11943: CALL_OW 67
// end ;
11947: GO 11547
11949: POP
11950: POP
// eng := eng union eng2 ;
11951: LD_ADDR_EXP 23
11955: PUSH
11956: LD_EXP 23
11960: PUSH
11961: LD_VAR 0 6
11965: UNION
11966: ST_TO_ADDR
// end ;
11967: LD_VAR 0 2
11971: RET
// function get_build ( x , y , btype ) ; var blds , i ; begin
11972: LD_INT 0
11974: PPUSH
11975: PPUSH
11976: PPUSH
// blds := FilterAllUnits ( [ f_btype , btype ] ) ;
11977: LD_ADDR_VAR 0 5
11981: PUSH
11982: LD_INT 30
11984: PUSH
11985: LD_VAR 0 3
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: PPUSH
11994: CALL_OW 69
11998: ST_TO_ADDR
// for i in blds do
11999: LD_ADDR_VAR 0 6
12003: PUSH
12004: LD_VAR 0 5
12008: PUSH
12009: FOR_IN
12010: IFFALSE 12050
// if GetX ( i ) = x and GetY ( i ) = y then
12012: LD_VAR 0 6
12016: PPUSH
12017: CALL_OW 250
12021: PUSH
12022: LD_VAR 0 1
12026: EQUAL
12027: PUSH
12028: LD_VAR 0 6
12032: PPUSH
12033: CALL_OW 251
12037: PUSH
12038: LD_VAR 0 2
12042: EQUAL
12043: AND
12044: IFFALSE 12048
// break ;
12046: GO 12050
12048: GO 12009
12050: POP
12051: POP
// if GetX ( i ) = x and GetY ( i ) = y then
12052: LD_VAR 0 6
12056: PPUSH
12057: CALL_OW 250
12061: PUSH
12062: LD_VAR 0 1
12066: EQUAL
12067: PUSH
12068: LD_VAR 0 6
12072: PPUSH
12073: CALL_OW 251
12077: PUSH
12078: LD_VAR 0 2
12082: EQUAL
12083: AND
12084: IFFALSE 12098
// result := i else
12086: LD_ADDR_VAR 0 4
12090: PUSH
12091: LD_VAR 0 6
12095: ST_TO_ADDR
12096: GO 12106
// result := 0 ;
12098: LD_ADDR_VAR 0 4
12102: PUSH
12103: LD_INT 0
12105: ST_TO_ADDR
// end ;
12106: LD_VAR 0 4
12110: RET
// export function get_stavari ; begin
12111: LD_INT 0
12113: PPUSH
// result := get_x_best ( arabs_init [ 1 ] [ 1 ] , skill_engineering , class_engineer ) diff Omar ;
12114: LD_ADDR_VAR 0 1
12118: PUSH
12119: LD_LOC 24
12123: PUSH
12124: LD_INT 1
12126: ARRAY
12127: PUSH
12128: LD_INT 1
12130: ARRAY
12131: PPUSH
12132: LD_INT 2
12134: PPUSH
12135: LD_INT 2
12137: PPUSH
12138: CALL 23328 0 3
12142: PUSH
12143: LD_EXP 61
12147: DIFF
12148: ST_TO_ADDR
// end ; end_of_file
12149: LD_VAR 0 1
12153: RET
// export under_attack ; function full_forts ; var kdo , empty , i , a , uz_in ; begin
12154: LD_INT 0
12156: PPUSH
12157: PPUSH
12158: PPUSH
12159: PPUSH
12160: PPUSH
12161: PPUSH
// empty := [ ] ;
12162: LD_ADDR_VAR 0 3
12166: PUSH
12167: EMPTY
12168: ST_TO_ADDR
// uz_in := [ ] ;
12169: LD_ADDR_VAR 0 6
12173: PUSH
12174: EMPTY
12175: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_combat , class_mortar ) ^ get_x_best ( 0 , skill_combat , class_soldier ) ;
12176: LD_ADDR_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: PPUSH
12184: LD_INT 1
12186: PPUSH
12187: LD_INT 8
12189: PPUSH
12190: CALL 23328 0 3
12194: PUSH
12195: LD_INT 0
12197: PPUSH
12198: LD_INT 1
12200: PPUSH
12201: LD_INT 1
12203: PPUSH
12204: CALL 23328 0 3
12208: ADD
12209: ST_TO_ADDR
// for i in fort do
12210: LD_ADDR_VAR 0 4
12214: PUSH
12215: LD_EXP 43
12219: PUSH
12220: FOR_IN
12221: IFFALSE 12297
// begin if not UnitsInside ( i ) then
12223: LD_VAR 0 4
12227: PPUSH
12228: CALL_OW 313
12232: NOT
12233: IFFALSE 12253
// begin empty := empty ^ i ;
12235: LD_ADDR_VAR 0 3
12239: PUSH
12240: LD_VAR 0 3
12244: PUSH
12245: LD_VAR 0 4
12249: ADD
12250: ST_TO_ADDR
// end else
12251: GO 12295
// begin kdo := kdo diff UnitsInside ( i ) ;
12253: LD_ADDR_VAR 0 2
12257: PUSH
12258: LD_VAR 0 2
12262: PUSH
12263: LD_VAR 0 4
12267: PPUSH
12268: CALL_OW 313
12272: DIFF
12273: ST_TO_ADDR
// uz_in := uz_in ^ UnitsInside ( i ) ;
12274: LD_ADDR_VAR 0 6
12278: PUSH
12279: LD_VAR 0 6
12283: PUSH
12284: LD_VAR 0 4
12288: PPUSH
12289: CALL_OW 313
12293: ADD
12294: ST_TO_ADDR
// end ; end ;
12295: GO 12220
12297: POP
12298: POP
// if kdo < empty then
12299: LD_VAR 0 2
12303: PUSH
12304: LD_VAR 0 3
12308: LESS
12309: IFFALSE 12321
// kdo := kdo ;
12311: LD_ADDR_VAR 0 2
12315: PUSH
12316: LD_VAR 0 2
12320: ST_TO_ADDR
// if kdo < empty then
12321: LD_VAR 0 2
12325: PUSH
12326: LD_VAR 0 3
12330: LESS
12331: IFFALSE 12349
// a := ( kdo + 0 ) else
12333: LD_ADDR_VAR 0 5
12337: PUSH
12338: LD_VAR 0 2
12342: PUSH
12343: LD_INT 0
12345: PLUS
12346: ST_TO_ADDR
12347: GO 12363
// a := ( empty + 0 ) ;
12349: LD_ADDR_VAR 0 5
12353: PUSH
12354: LD_VAR 0 3
12358: PUSH
12359: LD_INT 0
12361: PLUS
12362: ST_TO_ADDR
// for i := 1 to a do
12363: LD_ADDR_VAR 0 4
12367: PUSH
12368: DOUBLE
12369: LD_INT 1
12371: DEC
12372: ST_TO_ADDR
12373: LD_VAR 0 5
12377: PUSH
12378: FOR_TO
12379: IFFALSE 12493
// begin ComStop ( kdo [ i ] ) ;
12381: LD_VAR 0 2
12385: PUSH
12386: LD_VAR 0 4
12390: ARRAY
12391: PPUSH
12392: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12396: LD_VAR 0 2
12400: PUSH
12401: LD_VAR 0 4
12405: ARRAY
12406: PPUSH
12407: CALL_OW 310
12411: IFFALSE 12443
// begin AddComExitBuilding ( kdo [ i ] ) ;
12413: LD_VAR 0 2
12417: PUSH
12418: LD_VAR 0 4
12422: ARRAY
12423: PPUSH
12424: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12428: LD_VAR 0 2
12432: PUSH
12433: LD_VAR 0 4
12437: ARRAY
12438: PPUSH
12439: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12443: LD_VAR 0 2
12447: PUSH
12448: LD_VAR 0 4
12452: ARRAY
12453: PPUSH
12454: LD_VAR 0 3
12458: PUSH
12459: LD_VAR 0 4
12463: ARRAY
12464: PPUSH
12465: CALL_OW 180
// uz_in := uz_in ^ kdo [ i ] ;
12469: LD_ADDR_VAR 0 6
12473: PUSH
12474: LD_VAR 0 6
12478: PUSH
12479: LD_VAR 0 2
12483: PUSH
12484: LD_VAR 0 4
12488: ARRAY
12489: ADD
12490: ST_TO_ADDR
// end ;
12491: GO 12378
12493: POP
12494: POP
// empty := [ ] ;
12495: LD_ADDR_VAR 0 3
12499: PUSH
12500: EMPTY
12501: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_mechanical , class_soldier ) diff uz_in ;
12502: LD_ADDR_VAR 0 2
12506: PUSH
12507: LD_INT 0
12509: PPUSH
12510: LD_INT 3
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL 23328 0 3
12520: PUSH
12521: LD_VAR 0 6
12525: DIFF
12526: ST_TO_ADDR
// for i in defence diff Mastodon do
12527: LD_ADDR_VAR 0 4
12531: PUSH
12532: LD_EXP 28
12536: PUSH
12537: LD_INT 1
12539: DIFF
12540: PUSH
12541: FOR_IN
12542: IFFALSE 12597
// begin if not UnitsInside ( i ) then
12544: LD_VAR 0 4
12548: PPUSH
12549: CALL_OW 313
12553: NOT
12554: IFFALSE 12574
// begin empty := empty ^ i ;
12556: LD_ADDR_VAR 0 3
12560: PUSH
12561: LD_VAR 0 3
12565: PUSH
12566: LD_VAR 0 4
12570: ADD
12571: ST_TO_ADDR
// end else
12572: GO 12595
// kdo := kdo diff UnitsInside ( i ) ;
12574: LD_ADDR_VAR 0 2
12578: PUSH
12579: LD_VAR 0 2
12583: PUSH
12584: LD_VAR 0 4
12588: PPUSH
12589: CALL_OW 313
12593: DIFF
12594: ST_TO_ADDR
// end ;
12595: GO 12541
12597: POP
12598: POP
// if kdo < empty then
12599: LD_VAR 0 2
12603: PUSH
12604: LD_VAR 0 3
12608: LESS
12609: IFFALSE 12621
// kdo := kdo ;
12611: LD_ADDR_VAR 0 2
12615: PUSH
12616: LD_VAR 0 2
12620: ST_TO_ADDR
// if kdo < empty then
12621: LD_VAR 0 2
12625: PUSH
12626: LD_VAR 0 3
12630: LESS
12631: IFFALSE 12649
// a := ( kdo + 0 ) else
12633: LD_ADDR_VAR 0 5
12637: PUSH
12638: LD_VAR 0 2
12642: PUSH
12643: LD_INT 0
12645: PLUS
12646: ST_TO_ADDR
12647: GO 12663
// a := ( empty + 0 ) ;
12649: LD_ADDR_VAR 0 5
12653: PUSH
12654: LD_VAR 0 3
12658: PUSH
12659: LD_INT 0
12661: PLUS
12662: ST_TO_ADDR
// for i := 1 to a do
12663: LD_ADDR_VAR 0 4
12667: PUSH
12668: DOUBLE
12669: LD_INT 1
12671: DEC
12672: ST_TO_ADDR
12673: LD_VAR 0 5
12677: PUSH
12678: FOR_TO
12679: IFFALSE 12771
// begin ComStop ( kdo [ i ] ) ;
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PPUSH
12692: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PPUSH
12707: CALL_OW 310
12711: IFFALSE 12743
// begin AddComExitBuilding ( kdo [ i ] ) ;
12713: LD_VAR 0 2
12717: PUSH
12718: LD_VAR 0 4
12722: ARRAY
12723: PPUSH
12724: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12728: LD_VAR 0 2
12732: PUSH
12733: LD_VAR 0 4
12737: ARRAY
12738: PPUSH
12739: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12743: LD_VAR 0 2
12747: PUSH
12748: LD_VAR 0 4
12752: ARRAY
12753: PPUSH
12754: LD_VAR 0 3
12758: PUSH
12759: LD_VAR 0 4
12763: ARRAY
12764: PPUSH
12765: CALL_OW 180
// end ;
12769: GO 12678
12771: POP
12772: POP
// enable ;
12773: ENABLE
// end ;
12774: LD_VAR 0 1
12778: RET
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var uns , a ;
12779: LD_INT 13
12781: PPUSH
12782: LD_INT 22
12784: PUSH
12785: LD_EXP 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PPUSH
12794: CALL_OW 70
12798: IFFALSE 12816
12800: GO 12802
12802: DISABLE
12803: LD_INT 0
12805: PPUSH
12806: PPUSH
// begin under_attack := true ;
12807: LD_ADDR_EXP 69
12811: PUSH
12812: LD_INT 1
12814: ST_TO_ADDR
// enable ;
12815: ENABLE
// end ;
12816: PPOPN 2
12818: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do
12819: LD_INT 13
12821: PPUSH
12822: LD_INT 22
12824: PUSH
12825: LD_EXP 1
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PPUSH
12834: CALL_OW 70
12838: NOT
12839: IFFALSE 12853
12841: GO 12843
12843: DISABLE
// begin under_attack := false ;
12844: LD_ADDR_EXP 69
12848: PUSH
12849: LD_INT 0
12851: ST_TO_ADDR
// enable ;
12852: ENABLE
// end ;
12853: END
// every 0 0$10 trigger defence do
12854: LD_EXP 28
12858: IFFALSE 12896
12860: GO 12862
12862: DISABLE
// begin ComMoveXY ( defence [ 1 ] , 121 , 69 ) ;
12863: LD_EXP 28
12867: PUSH
12868: LD_INT 1
12870: ARRAY
12871: PPUSH
12872: LD_INT 121
12874: PPUSH
12875: LD_INT 69
12877: PPUSH
12878: CALL_OW 111
// AddComStand ( defence [ 1 ] ) ;
12882: LD_EXP 28
12886: PUSH
12887: LD_INT 1
12889: ARRAY
12890: PPUSH
12891: CALL_OW 225
// enable ;
12895: ENABLE
// end ;
12896: END
// every 0 0$5 + 0 0$2 marked 50 do
12897: GO 12899
12899: DISABLE
// begin full_forts ;
12900: CALL 12154 0 0
// enable ;
12904: ENABLE
// end ;
12905: END
// every 0 0$5.0 do var i ;
12906: GO 12908
12908: DISABLE
12909: LD_INT 0
12911: PPUSH
// begin if fact1 then
12912: LD_EXP 40
12916: IFFALSE 12975
// for i in mec do
12918: LD_ADDR_VAR 0 1
12922: PUSH
12923: LD_EXP 22
12927: PUSH
12928: FOR_IN
12929: IFFALSE 12973
// begin if IsIdle ( i ) or not IsInArea ( i , near_base ) then
12931: LD_VAR 0 1
12935: PPUSH
12936: CALL_OW 316
12940: PUSH
12941: LD_VAR 0 1
12945: PPUSH
12946: LD_INT 13
12948: PPUSH
12949: CALL_OW 308
12953: NOT
12954: OR
12955: IFFALSE 12971
// ComEnterUnit ( i , fact1 ) ;
12957: LD_VAR 0 1
12961: PPUSH
12962: LD_EXP 40
12966: PPUSH
12967: CALL_OW 120
// end ;
12971: GO 12928
12973: POP
12974: POP
// enable ;
12975: ENABLE
// end ;
12976: PPOPN 1
12978: END
// every 0 0$5.0 do var i ;
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
// begin if dep1 then
12985: LD_EXP 41
12989: IFFALSE 13077
// if under_attack then
12991: LD_EXP 69
12995: IFFALSE 13068
// for i in eng do
12997: LD_ADDR_VAR 0 1
13001: PUSH
13002: LD_EXP 23
13006: PUSH
13007: FOR_IN
13008: IFFALSE 13064
// begin if IsIdle ( i ) or ( not IsInArea ( i , near_base ) and not IsInUnit ( i ) ) then
13010: LD_VAR 0 1
13014: PPUSH
13015: CALL_OW 316
13019: PUSH
13020: LD_VAR 0 1
13024: PPUSH
13025: LD_INT 13
13027: PPUSH
13028: CALL_OW 308
13032: NOT
13033: PUSH
13034: LD_VAR 0 1
13038: PPUSH
13039: CALL_OW 310
13043: NOT
13044: AND
13045: OR
13046: IFFALSE 13062
// ComEnterUnit ( i , dep1 ) ;
13048: LD_VAR 0 1
13052: PPUSH
13053: LD_EXP 41
13057: PPUSH
13058: CALL_OW 120
// end else
13062: GO 13007
13064: POP
13065: POP
13066: GO 13077
// ComExitBuilding ( dep1 ) ;
13068: LD_EXP 41
13072: PPUSH
13073: CALL_OW 122
// enable ;
13077: ENABLE
// end ;
13078: PPOPN 1
13080: END
// every 0 0$5.0 do var i ;
13081: GO 13083
13083: DISABLE
13084: LD_INT 0
13086: PPUSH
// begin if lab1 then
13087: LD_EXP 42
13091: IFFALSE 13135
// for i in sci do
13093: LD_ADDR_VAR 0 1
13097: PUSH
13098: LD_EXP 21
13102: PUSH
13103: FOR_IN
13104: IFFALSE 13133
// begin if IsIdle ( i ) then
13106: LD_VAR 0 1
13110: PPUSH
13111: CALL_OW 316
13115: IFFALSE 13131
// ComEnterUnit ( i , lab1 ) ;
13117: LD_VAR 0 1
13121: PPUSH
13122: LD_EXP 42
13126: PPUSH
13127: CALL_OW 120
// end ;
13131: GO 13103
13133: POP
13134: POP
// enable ;
13135: ENABLE
// end ;
13136: PPOPN 1
13138: END
// every 0 0$1 do var a ;
13139: GO 13141
13141: DISABLE
13142: LD_INT 0
13144: PPUSH
// begin enable ;
13145: ENABLE
// end ; end_of_file
13146: PPOPN 1
13148: END
// every 0 0$2 do var temp1 , people , cars ;
13149: GO 13151
13151: DISABLE
13152: LD_INT 0
13154: PPUSH
13155: PPUSH
13156: PPUSH
// begin vodni_utok := 6000 ;
13157: LD_ADDR_EXP 35
13161: PUSH
13162: LD_INT 6000
13164: ST_TO_ADDR
// normal1_utok := 6001 ;
13165: LD_ADDR_EXP 36
13169: PUSH
13170: LD_INT 6001
13172: ST_TO_ADDR
// normal2_utok := 6002 ;
13173: LD_ADDR_EXP 37
13177: PUSH
13178: LD_INT 6002
13180: ST_TO_ADDR
// normal3_utok := 6003 ;
13181: LD_ADDR_EXP 38
13185: PUSH
13186: LD_INT 6003
13188: ST_TO_ADDR
// normal4_utok := 6004 ;
13189: LD_ADDR_EXP 39
13193: PUSH
13194: LD_INT 6004
13196: ST_TO_ADDR
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
13197: LD_ADDR_EXP 7
13201: PUSH
13202: LD_INT 23
13204: PUSH
13205: LD_INT 0
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: EMPTY
13213: LIST
13214: PPUSH
13215: CALL_OW 69
13219: ST_TO_ADDR
// to_defence := false ;
13220: LD_ADDR_EXP 30
13224: PUSH
13225: LD_INT 0
13227: ST_TO_ADDR
// to_remote := false ;
13228: LD_ADDR_EXP 34
13232: PUSH
13233: LD_INT 0
13235: ST_TO_ADDR
// to_attack := false ;
13236: LD_ADDR_EXP 31
13240: PUSH
13241: LD_INT 0
13243: ST_TO_ADDR
// to_cargo := false ;
13244: LD_ADDR_EXP 33
13248: PUSH
13249: LD_INT 0
13251: ST_TO_ADDR
// to_scout := false ;
13252: LD_ADDR_EXP 32
13256: PUSH
13257: LD_INT 0
13259: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ [ f_side , arabians ] ] ) ;
13260: LD_ADDR_VAR 0 1
13264: PUSH
13265: LD_INT 22
13267: PUSH
13268: LD_EXP 3
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: PUSH
13277: EMPTY
13278: LIST
13279: PPUSH
13280: CALL_OW 69
13284: ST_TO_ADDR
// ComRemember ( temp1 ) ;
13285: LD_VAR 0 1
13289: PPUSH
13290: CALL_OW 143
// people := UnitFilter ( temp1 , [ [ f_type , unit_human ] ] ) ;
13294: LD_ADDR_VAR 0 2
13298: PUSH
13299: LD_VAR 0 1
13303: PPUSH
13304: LD_INT 21
13306: PUSH
13307: LD_INT 1
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: PUSH
13314: EMPTY
13315: LIST
13316: PPUSH
13317: CALL_OW 72
13321: ST_TO_ADDR
// sol := UnitFilter ( people , [ [ f_class , class_soldier ] ] ) ;
13322: LD_ADDR_EXP 19
13326: PUSH
13327: LD_VAR 0 2
13331: PPUSH
13332: LD_INT 25
13334: PUSH
13335: LD_INT 1
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PUSH
13342: EMPTY
13343: LIST
13344: PPUSH
13345: CALL_OW 72
13349: ST_TO_ADDR
// sci := UnitFilter ( people , [ [ f_class , class_scientistic ] ] ) ;
13350: LD_ADDR_EXP 21
13354: PUSH
13355: LD_VAR 0 2
13359: PPUSH
13360: LD_INT 25
13362: PUSH
13363: LD_INT 4
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: EMPTY
13371: LIST
13372: PPUSH
13373: CALL_OW 72
13377: ST_TO_ADDR
// mor := UnitFilter ( people , [ [ f_class , class_mortar ] ] ) ;
13378: LD_ADDR_EXP 20
13382: PUSH
13383: LD_VAR 0 2
13387: PPUSH
13388: LD_INT 25
13390: PUSH
13391: LD_INT 8
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: PPUSH
13401: CALL_OW 72
13405: ST_TO_ADDR
// mec := UnitFilter ( people , [ [ f_class , class_mechanic ] ] ) ;
13406: LD_ADDR_EXP 22
13410: PUSH
13411: LD_VAR 0 2
13415: PPUSH
13416: LD_INT 25
13418: PUSH
13419: LD_INT 3
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: EMPTY
13427: LIST
13428: PPUSH
13429: CALL_OW 72
13433: ST_TO_ADDR
// eng := UnitFilter ( people , [ [ f_class , class_engineer ] ] ) ;
13434: LD_ADDR_EXP 23
13438: PUSH
13439: LD_VAR 0 2
13443: PPUSH
13444: LD_INT 25
13446: PUSH
13447: LD_INT 2
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: EMPTY
13455: LIST
13456: PPUSH
13457: CALL_OW 72
13461: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ [ f_type , unit_vehicle ] ] ) ;
13462: LD_ADDR_VAR 0 3
13466: PUSH
13467: LD_VAR 0 1
13471: PPUSH
13472: LD_INT 21
13474: PUSH
13475: LD_INT 2
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PUSH
13482: EMPTY
13483: LIST
13484: PPUSH
13485: CALL_OW 72
13489: ST_TO_ADDR
// cargo := [ ] ;
13490: LD_ADDR_EXP 25
13494: PUSH
13495: EMPTY
13496: ST_TO_ADDR
// scout := [ ] ;
13497: LD_ADDR_EXP 26
13501: PUSH
13502: EMPTY
13503: ST_TO_ADDR
// defence := [ Mastodon ] ;
13504: LD_ADDR_EXP 28
13508: PUSH
13509: LD_INT 1
13511: PUSH
13512: EMPTY
13513: LIST
13514: ST_TO_ADDR
// attack := [ ] ;
13515: LD_ADDR_EXP 27
13519: PUSH
13520: EMPTY
13521: ST_TO_ADDR
// fort := UnitFilter ( temp1 , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
13522: LD_ADDR_EXP 43
13526: PUSH
13527: LD_VAR 0 1
13531: PPUSH
13532: LD_INT 2
13534: PUSH
13535: LD_INT 30
13537: PUSH
13538: LD_INT 32
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 30
13547: PUSH
13548: LD_INT 31
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: LIST
13559: PUSH
13560: EMPTY
13561: LIST
13562: PPUSH
13563: CALL_OW 72
13567: ST_TO_ADDR
// dep1 := UnitFilter ( temp1 , [ [ f_btype , b_depot ] ] ) [ 1 ] + 0 ;
13568: LD_ADDR_EXP 41
13572: PUSH
13573: LD_VAR 0 1
13577: PPUSH
13578: LD_INT 30
13580: PUSH
13581: LD_INT 0
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PUSH
13588: EMPTY
13589: LIST
13590: PPUSH
13591: CALL_OW 72
13595: PUSH
13596: LD_INT 1
13598: ARRAY
13599: PUSH
13600: LD_INT 0
13602: PLUS
13603: ST_TO_ADDR
// end ;
13604: PPOPN 3
13606: END
// var zasek_cargo ; every 0 0$50 trigger cargo do var j , pojedou , new ;
13607: LD_EXP 25
13611: IFFALSE 13984
13613: GO 13615
13615: DISABLE
13616: LD_INT 0
13618: PPUSH
13619: PPUSH
13620: PPUSH
// begin uc_side := arabians ;
13621: LD_ADDR_OWVAR 20
13625: PUSH
13626: LD_EXP 3
13630: ST_TO_ADDR
// uc_nation := nation_arabian ;
13631: LD_ADDR_OWVAR 21
13635: PUSH
13636: LD_INT 2
13638: ST_TO_ADDR
// PrepareEngineer ( 0 , 2 ) ;
13639: LD_INT 0
13641: PPUSH
13642: LD_INT 2
13644: PPUSH
13645: CALL_OW 382
// SetFuel ( cargo , 100 ) ;
13649: LD_EXP 25
13653: PPUSH
13654: LD_INT 100
13656: PPUSH
13657: CALL_OW 240
// if not HasTask ( Cargo [ 1 ] ) and GetLives ( Cargo [ 1 ] ) >= 900 and crates >= 2 then
13661: LD_EXP 25
13665: PUSH
13666: LD_INT 1
13668: ARRAY
13669: PPUSH
13670: CALL_OW 314
13674: NOT
13675: PUSH
13676: LD_EXP 25
13680: PUSH
13681: LD_INT 1
13683: ARRAY
13684: PPUSH
13685: CALL_OW 256
13689: PUSH
13690: LD_INT 900
13692: GREATEREQUAL
13693: AND
13694: PUSH
13695: LD_EXP 85
13699: PUSH
13700: LD_INT 2
13702: GREATEREQUAL
13703: AND
13704: IFFALSE 13983
// begin new := [ ] ;
13706: LD_ADDR_VAR 0 3
13710: PUSH
13711: EMPTY
13712: ST_TO_ADDR
// pojedou := find_drivers ( cargo [ 1 ] , eng ^ sol ^ sci ^ mec , false ) ;
13713: LD_ADDR_VAR 0 2
13717: PUSH
13718: LD_EXP 25
13722: PUSH
13723: LD_INT 1
13725: ARRAY
13726: PPUSH
13727: LD_EXP 23
13731: PUSH
13732: LD_EXP 19
13736: ADD
13737: PUSH
13738: LD_EXP 21
13742: ADD
13743: PUSH
13744: LD_EXP 22
13748: ADD
13749: PPUSH
13750: LD_INT 0
13752: PPUSH
13753: CALL 24026 0 3
13757: ST_TO_ADDR
// wait_for_drivers ( pojedou , 0 0$25 ) ;
13758: LD_VAR 0 2
13762: PPUSH
13763: LD_INT 875
13765: PPUSH
13766: CALL 24358 0 2
// if IsDrivenBy ( cargo [ 1 ] ) then
13770: LD_EXP 25
13774: PUSH
13775: LD_INT 1
13777: ARRAY
13778: PPUSH
13779: CALL_OW 311
13783: IFFALSE 13795
// zasek_cargo := 1 else
13785: LD_ADDR_LOC 27
13789: PUSH
13790: LD_INT 1
13792: ST_TO_ADDR
13793: GO 13809
// zasek_cargo := zasek_cargo + 1 ;
13795: LD_ADDR_LOC 27
13799: PUSH
13800: LD_LOC 27
13804: PUSH
13805: LD_INT 1
13807: PLUS
13808: ST_TO_ADDR
// if zasek_cargo > 5 then
13809: LD_LOC 27
13813: PUSH
13814: LD_INT 5
13816: GREATER
13817: IFFALSE 13837
// PlaceHumanInUnit ( CreateHuman , cargo [ 1 ] ) ;
13819: CALL_OW 44
13823: PPUSH
13824: LD_EXP 25
13828: PUSH
13829: LD_INT 1
13831: ARRAY
13832: PPUSH
13833: CALL_OW 52
// for j := 1 to 2 do
13837: LD_ADDR_VAR 0 1
13841: PUSH
13842: DOUBLE
13843: LD_INT 1
13845: DEC
13846: ST_TO_ADDR
13847: LD_INT 2
13849: PUSH
13850: FOR_TO
13851: IFFALSE 13894
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
13853: LD_VAR 0 2
13857: PPUSH
13858: LD_EXP 85
13862: PUSH
13863: LD_VAR 0 1
13867: ARRAY
13868: PUSH
13869: LD_INT 1
13871: ARRAY
13872: PPUSH
13873: LD_EXP 85
13877: PUSH
13878: LD_VAR 0 1
13882: ARRAY
13883: PUSH
13884: LD_INT 2
13886: ARRAY
13887: PPUSH
13888: CALL_OW 177
// end ;
13892: GO 13850
13894: POP
13895: POP
// if crates >= 3 then
13896: LD_EXP 85
13900: PUSH
13901: LD_INT 3
13903: GREATEREQUAL
13904: IFFALSE 13953
// for j := 3 to crates do
13906: LD_ADDR_VAR 0 1
13910: PUSH
13911: DOUBLE
13912: LD_INT 3
13914: DEC
13915: ST_TO_ADDR
13916: LD_EXP 85
13920: PUSH
13921: FOR_TO
13922: IFFALSE 13951
// begin new := new ^ [ crates [ j ] ] ;
13924: LD_ADDR_VAR 0 3
13928: PUSH
13929: LD_VAR 0 3
13933: PUSH
13934: LD_EXP 85
13938: PUSH
13939: LD_VAR 0 1
13943: ARRAY
13944: PUSH
13945: EMPTY
13946: LIST
13947: ADD
13948: ST_TO_ADDR
// end ;
13949: GO 13921
13951: POP
13952: POP
// crates := new ;
13953: LD_ADDR_EXP 85
13957: PUSH
13958: LD_VAR 0 3
13962: ST_TO_ADDR
// if dep1 then
13963: LD_EXP 41
13967: IFFALSE 13983
// AddComMoveUnit ( pojedou , dep1 ) ;
13969: LD_VAR 0 2
13973: PPUSH
13974: LD_EXP 41
13978: PPUSH
13979: CALL_OW 172
// end ; enable ;
13983: ENABLE
// end ;
13984: PPOPN 3
13986: END
// every 0 0$30 do var a ;
13987: GO 13989
13989: DISABLE
13990: LD_INT 0
13992: PPUSH
// begin a := GetResourceType ( Getbase ( dep1 ) , mat_cans ) ;
13993: LD_ADDR_VAR 0 1
13997: PUSH
13998: LD_EXP 41
14002: PPUSH
14003: CALL_OW 274
14007: PPUSH
14008: LD_INT 1
14010: PPUSH
14011: CALL_OW 275
14015: ST_TO_ADDR
// if a < 100 then
14016: LD_VAR 0 1
14020: PUSH
14021: LD_INT 100
14023: LESS
14024: IFFALSE 14052
// SetResourceType ( Getbase ( dep1 ) , mat_cans , a + 100 ) ;
14026: LD_EXP 41
14030: PPUSH
14031: CALL_OW 274
14035: PPUSH
14036: LD_INT 1
14038: PPUSH
14039: LD_VAR 0 1
14043: PUSH
14044: LD_INT 100
14046: PLUS
14047: PPUSH
14048: CALL_OW 277
// a := GetResourceType ( Getbase ( dep1 ) , mat_oil ) ;
14052: LD_ADDR_VAR 0 1
14056: PUSH
14057: LD_EXP 41
14061: PPUSH
14062: CALL_OW 274
14066: PPUSH
14067: LD_INT 2
14069: PPUSH
14070: CALL_OW 275
14074: ST_TO_ADDR
// if a < 100 then
14075: LD_VAR 0 1
14079: PUSH
14080: LD_INT 100
14082: LESS
14083: IFFALSE 14111
// SetResourceType ( Getbase ( dep1 ) , mat_oil , a + 100 ) ;
14085: LD_EXP 41
14089: PPUSH
14090: CALL_OW 274
14094: PPUSH
14095: LD_INT 2
14097: PPUSH
14098: LD_VAR 0 1
14102: PUSH
14103: LD_INT 100
14105: PLUS
14106: PPUSH
14107: CALL_OW 277
// enable ;
14111: ENABLE
// end ;
14112: PPOPN 1
14114: END
// every 0 0$15 trigger IsOk ( fact1 ) and IsIdle ( fact1 ) and ( ( defence + attack ) < ( 5 + difficulty * 2 ) ) do var a , ec , cm , ac , podvozky , ovladani , def_pod , att_pod , tmec ;
14115: LD_EXP 40
14119: PPUSH
14120: CALL_OW 302
14124: PUSH
14125: LD_EXP 40
14129: PPUSH
14130: CALL_OW 316
14134: AND
14135: PUSH
14136: LD_EXP 28
14140: PUSH
14141: LD_EXP 27
14145: PLUS
14146: PUSH
14147: LD_INT 5
14149: PUSH
14150: LD_OWVAR 67
14154: PUSH
14155: LD_INT 2
14157: MUL
14158: PLUS
14159: LESS
14160: AND
14161: IFFALSE 15472
14163: GO 14165
14165: DISABLE
14166: LD_INT 0
14168: PPUSH
14169: PPUSH
14170: PPUSH
14171: PPUSH
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// begin ec := engine_combustion ;
14177: LD_ADDR_VAR 0 2
14181: PUSH
14182: LD_INT 1
14184: ST_TO_ADDR
// cm := control_manual ;
14185: LD_ADDR_VAR 0 3
14189: PUSH
14190: LD_INT 1
14192: ST_TO_ADDR
// podvozky := AvailableChassisList ( fact1 ) ;
14193: LD_ADDR_VAR 0 5
14197: PUSH
14198: LD_EXP 40
14202: PPUSH
14203: CALL_OW 475
14207: ST_TO_ADDR
// ovladani := AvailableControlList ( fact1 ) ;
14208: LD_ADDR_VAR 0 6
14212: PUSH
14213: LD_EXP 40
14217: PPUSH
14218: CALL_OW 477
14222: ST_TO_ADDR
// if control_remote in ovladani then
14223: LD_INT 2
14225: PUSH
14226: LD_VAR 0 6
14230: IN
14231: IFFALSE 14243
// ac := control_remote else
14233: LD_ADDR_VAR 0 4
14237: PUSH
14238: LD_INT 2
14240: ST_TO_ADDR
14241: GO 14253
// ac := cm ;
14243: LD_ADDR_VAR 0 4
14247: PUSH
14248: LD_VAR 0 3
14252: ST_TO_ADDR
// att_pod := ar_half_tracked ;
14253: LD_ADDR_VAR 0 8
14257: PUSH
14258: LD_INT 14
14260: ST_TO_ADDR
// case true of ar_half_tracked in podvozky :
14261: LD_INT 1
14263: PUSH
14264: LD_INT 14
14266: PUSH
14267: LD_VAR 0 5
14271: IN
14272: DOUBLE
14273: EQUAL
14274: IFTRUE 14278
14276: GO 14289
14278: POP
// def_pod := ar_half_tracked ; ar_medium_trike in podvozky :
14279: LD_ADDR_VAR 0 7
14283: PUSH
14284: LD_INT 14
14286: ST_TO_ADDR
14287: GO 14315
14289: LD_INT 13
14291: PUSH
14292: LD_VAR 0 5
14296: IN
14297: DOUBLE
14298: EQUAL
14299: IFTRUE 14303
14301: GO 14314
14303: POP
// def_pod := ar_medium_trike ; end ;
14304: LD_ADDR_VAR 0 7
14308: PUSH
14309: LD_INT 13
14311: ST_TO_ADDR
14312: GO 14315
14314: POP
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14315: LD_ADDR_VAR 0 9
14319: PUSH
14320: LD_EXP 22
14324: PPUSH
14325: LD_INT 56
14327: PUSH
14328: EMPTY
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: PPUSH
14334: CALL_OW 72
14338: ST_TO_ADDR
// while tmec do
14339: LD_VAR 0 9
14343: IFFALSE 14403
// begin ComExitVehicle ( tmec ) ;
14345: LD_VAR 0 9
14349: PPUSH
14350: CALL_OW 121
// AddComEnterUnit ( tmec , fact1 ) ;
14354: LD_VAR 0 9
14358: PPUSH
14359: LD_EXP 40
14363: PPUSH
14364: CALL_OW 180
// DU_wait ( tmec ) ;
14368: LD_VAR 0 9
14372: PPUSH
14373: CALL 22055 0 1
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14377: LD_ADDR_VAR 0 9
14381: PUSH
14382: LD_EXP 22
14386: PPUSH
14387: LD_INT 56
14389: PUSH
14390: EMPTY
14391: LIST
14392: PUSH
14393: EMPTY
14394: LIST
14395: PPUSH
14396: CALL_OW 72
14400: ST_TO_ADDR
// end ;
14401: GO 14339
// case true of cargo < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_cargo_bay ) :
14403: LD_INT 1
14405: PUSH
14406: LD_EXP 25
14410: PUSH
14411: LD_INT 1
14413: LESS
14414: PUSH
14415: LD_EXP 40
14419: PPUSH
14420: LD_INT 13
14422: PPUSH
14423: LD_VAR 0 2
14427: PPUSH
14428: LD_VAR 0 3
14432: PPUSH
14433: LD_INT 32
14435: PPUSH
14436: CALL_OW 448
14440: AND
14441: DOUBLE
14442: EQUAL
14443: IFTRUE 14447
14445: GO 14485
14447: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_cargo_bay ) ;
14448: LD_EXP 40
14452: PPUSH
14453: LD_VAR 0 7
14457: PPUSH
14458: LD_VAR 0 2
14462: PPUSH
14463: LD_VAR 0 3
14467: PPUSH
14468: LD_INT 32
14470: PPUSH
14471: CALL_OW 125
// to_cargo := true ;
14475: LD_ADDR_EXP 33
14479: PUSH
14480: LD_INT 1
14482: ST_TO_ADDR
// end ; defence >= 1 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gun ) :
14483: GO 15471
14485: LD_EXP 28
14489: PUSH
14490: LD_INT 1
14492: GREATEREQUAL
14493: PUSH
14494: LD_EXP 28
14498: PUSH
14499: LD_INT 3
14501: LESS
14502: AND
14503: PUSH
14504: LD_EXP 40
14508: PPUSH
14509: LD_VAR 0 7
14513: PPUSH
14514: LD_VAR 0 2
14518: PPUSH
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 27
14526: PPUSH
14527: CALL_OW 448
14531: AND
14532: DOUBLE
14533: EQUAL
14534: IFTRUE 14538
14536: GO 14576
14538: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gun ) ;
14539: LD_EXP 40
14543: PPUSH
14544: LD_VAR 0 7
14548: PPUSH
14549: LD_VAR 0 2
14553: PPUSH
14554: LD_VAR 0 3
14558: PPUSH
14559: LD_INT 27
14561: PPUSH
14562: CALL_OW 125
// to_defence := true ;
14566: LD_ADDR_EXP 30
14570: PUSH
14571: LD_INT 1
14573: ST_TO_ADDR
// end ; defence >= 2 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gatling_gun ) :
14574: GO 15471
14576: LD_EXP 28
14580: PUSH
14581: LD_INT 2
14583: GREATEREQUAL
14584: PUSH
14585: LD_EXP 28
14589: PUSH
14590: LD_INT 3
14592: LESS
14593: AND
14594: PUSH
14595: LD_EXP 40
14599: PPUSH
14600: LD_VAR 0 7
14604: PPUSH
14605: LD_VAR 0 2
14609: PPUSH
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 25
14617: PPUSH
14618: CALL_OW 448
14622: AND
14623: DOUBLE
14624: EQUAL
14625: IFTRUE 14629
14627: GO 14667
14629: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gatling_gun ) ;
14630: LD_EXP 40
14634: PPUSH
14635: LD_VAR 0 7
14639: PPUSH
14640: LD_VAR 0 2
14644: PPUSH
14645: LD_VAR 0 3
14649: PPUSH
14650: LD_INT 25
14652: PPUSH
14653: CALL_OW 125
// to_defence := true ;
14657: LD_ADDR_EXP 30
14661: PUSH
14662: LD_INT 1
14664: ST_TO_ADDR
// end ; defence < 2 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_flame_thrower ) :
14665: GO 15471
14667: LD_EXP 28
14671: PUSH
14672: LD_INT 2
14674: LESS
14675: PUSH
14676: LD_EXP 40
14680: PPUSH
14681: LD_VAR 0 7
14685: PPUSH
14686: LD_VAR 0 2
14690: PPUSH
14691: LD_VAR 0 3
14695: PPUSH
14696: LD_INT 26
14698: PPUSH
14699: CALL_OW 448
14703: AND
14704: DOUBLE
14705: EQUAL
14706: IFTRUE 14710
14708: GO 14748
14710: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_flame_thrower ) ;
14711: LD_EXP 40
14715: PPUSH
14716: LD_VAR 0 7
14720: PPUSH
14721: LD_VAR 0 2
14725: PPUSH
14726: LD_VAR 0 3
14730: PPUSH
14731: LD_INT 26
14733: PPUSH
14734: CALL_OW 125
// to_defence := true ;
14738: LD_ADDR_EXP 30
14742: PUSH
14743: LD_INT 1
14745: ST_TO_ADDR
// end ; remote < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) :
14746: GO 15471
14748: LD_EXP 29
14752: PUSH
14753: LD_INT 1
14755: LESS
14756: PUSH
14757: LD_EXP 40
14761: PPUSH
14762: LD_INT 13
14764: PPUSH
14765: LD_VAR 0 2
14769: PPUSH
14770: LD_VAR 0 3
14774: PPUSH
14775: LD_INT 31
14777: PPUSH
14778: CALL_OW 448
14782: AND
14783: DOUBLE
14784: EQUAL
14785: IFTRUE 14789
14787: GO 14825
14789: POP
// begin ComConstruct ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) ;
14790: LD_EXP 40
14794: PPUSH
14795: LD_INT 13
14797: PPUSH
14798: LD_VAR 0 2
14802: PPUSH
14803: LD_VAR 0 3
14807: PPUSH
14808: LD_INT 31
14810: PPUSH
14811: CALL_OW 125
// to_remote := true ;
14815: LD_ADDR_EXP 34
14819: PUSH
14820: LD_INT 1
14822: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
14823: GO 15471
14825: LD_OWVAR 1
14829: PUSH
14830: LD_INT 42000
14832: LESS
14833: PUSH
14834: LD_EXP 27
14838: PUSH
14839: LD_INT 3
14841: LESS
14842: AND
14843: PUSH
14844: LD_EXP 40
14848: PPUSH
14849: LD_INT 11
14851: PPUSH
14852: LD_VAR 0 2
14856: PPUSH
14857: LD_VAR 0 4
14861: PPUSH
14862: LD_INT 23
14864: PPUSH
14865: CALL_OW 448
14869: AND
14870: DOUBLE
14871: EQUAL
14872: IFTRUE 14876
14874: GO 14912
14876: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
14877: LD_EXP 40
14881: PPUSH
14882: LD_INT 11
14884: PPUSH
14885: LD_VAR 0 2
14889: PPUSH
14890: LD_VAR 0 4
14894: PPUSH
14895: LD_INT 23
14897: PPUSH
14898: CALL_OW 125
// to_attack := true ;
14902: LD_ADDR_EXP 31
14906: PUSH
14907: LD_INT 1
14909: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
14910: GO 15471
14912: LD_OWVAR 1
14916: PUSH
14917: LD_INT 42000
14919: LESS
14920: PUSH
14921: LD_EXP 27
14925: PUSH
14926: LD_INT 3
14928: LESS
14929: AND
14930: PUSH
14931: LD_EXP 40
14935: PPUSH
14936: LD_VAR 0 8
14940: PPUSH
14941: LD_VAR 0 2
14945: PPUSH
14946: LD_VAR 0 4
14950: PPUSH
14951: LD_INT 25
14953: PPUSH
14954: CALL_OW 448
14958: AND
14959: DOUBLE
14960: EQUAL
14961: IFTRUE 14965
14963: GO 15003
14965: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
14966: LD_EXP 40
14970: PPUSH
14971: LD_VAR 0 8
14975: PPUSH
14976: LD_VAR 0 2
14980: PPUSH
14981: LD_VAR 0 4
14985: PPUSH
14986: LD_INT 25
14988: PPUSH
14989: CALL_OW 125
// to_attack := true ;
14993: LD_ADDR_EXP 31
14997: PUSH
14998: LD_INT 1
15000: ST_TO_ADDR
// end ; tick < 10 10$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) :
15001: GO 15471
15003: LD_OWVAR 1
15007: PUSH
15008: LD_INT 21000
15010: LESS
15011: PUSH
15012: LD_EXP 27
15016: PUSH
15017: LD_INT 3
15019: LESS
15020: AND
15021: PUSH
15022: LD_EXP 40
15026: PPUSH
15027: LD_INT 11
15029: PPUSH
15030: LD_VAR 0 2
15034: PPUSH
15035: LD_VAR 0 4
15039: PPUSH
15040: LD_INT 24
15042: PPUSH
15043: CALL_OW 448
15047: AND
15048: DOUBLE
15049: EQUAL
15050: IFTRUE 15054
15052: GO 15090
15054: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) ;
15055: LD_EXP 40
15059: PPUSH
15060: LD_INT 11
15062: PPUSH
15063: LD_VAR 0 2
15067: PPUSH
15068: LD_VAR 0 4
15072: PPUSH
15073: LD_INT 24
15075: PPUSH
15076: CALL_OW 125
// to_attack := true ;
15080: LD_ADDR_EXP 31
15084: PUSH
15085: LD_INT 1
15087: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15088: GO 15471
15090: LD_OWVAR 1
15094: PUSH
15095: LD_INT 42000
15097: GREATER
15098: PUSH
15099: LD_OWVAR 1
15103: PUSH
15104: LD_INT 84000
15106: LESS
15107: AND
15108: PUSH
15109: LD_EXP 27
15113: PUSH
15114: LD_INT 2
15116: LESS
15117: AND
15118: PUSH
15119: LD_EXP 40
15123: PPUSH
15124: LD_VAR 0 8
15128: PPUSH
15129: LD_VAR 0 2
15133: PPUSH
15134: LD_VAR 0 4
15138: PPUSH
15139: LD_INT 27
15141: PPUSH
15142: CALL_OW 448
15146: AND
15147: DOUBLE
15148: EQUAL
15149: IFTRUE 15153
15151: GO 15191
15153: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15154: LD_EXP 40
15158: PPUSH
15159: LD_VAR 0 8
15163: PPUSH
15164: LD_VAR 0 2
15168: PPUSH
15169: LD_VAR 0 4
15173: PPUSH
15174: LD_INT 27
15176: PPUSH
15177: CALL_OW 125
// to_attack := true ;
15181: LD_ADDR_EXP 31
15185: PUSH
15186: LD_INT 1
15188: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
15189: GO 15471
15191: LD_OWVAR 1
15195: PUSH
15196: LD_INT 42000
15198: GREATER
15199: PUSH
15200: LD_OWVAR 1
15204: PUSH
15205: LD_INT 84000
15207: LESS
15208: AND
15209: PUSH
15210: LD_EXP 27
15214: PUSH
15215: LD_INT 3
15217: LESS
15218: AND
15219: PUSH
15220: LD_EXP 40
15224: PPUSH
15225: LD_VAR 0 8
15229: PPUSH
15230: LD_VAR 0 2
15234: PPUSH
15235: LD_VAR 0 4
15239: PPUSH
15240: LD_INT 25
15242: PPUSH
15243: CALL_OW 448
15247: AND
15248: DOUBLE
15249: EQUAL
15250: IFTRUE 15254
15252: GO 15292
15254: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
15255: LD_EXP 40
15259: PPUSH
15260: LD_VAR 0 8
15264: PPUSH
15265: LD_VAR 0 2
15269: PPUSH
15270: LD_VAR 0 4
15274: PPUSH
15275: LD_INT 25
15277: PPUSH
15278: CALL_OW 125
// to_attack := true ;
15282: LD_ADDR_EXP 31
15286: PUSH
15287: LD_INT 1
15289: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
15290: GO 15471
15292: LD_OWVAR 1
15296: PUSH
15297: LD_INT 84000
15299: GREATER
15300: PUSH
15301: LD_EXP 27
15305: PUSH
15306: LD_INT 2
15308: LESS
15309: AND
15310: PUSH
15311: LD_EXP 40
15315: PPUSH
15316: LD_INT 11
15318: PPUSH
15319: LD_VAR 0 2
15323: PPUSH
15324: LD_VAR 0 4
15328: PPUSH
15329: LD_INT 23
15331: PPUSH
15332: CALL_OW 448
15336: AND
15337: DOUBLE
15338: EQUAL
15339: IFTRUE 15343
15341: GO 15379
15343: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
15344: LD_EXP 40
15348: PPUSH
15349: LD_INT 11
15351: PPUSH
15352: LD_VAR 0 2
15356: PPUSH
15357: LD_VAR 0 4
15361: PPUSH
15362: LD_INT 23
15364: PPUSH
15365: CALL_OW 125
// to_attack := true ;
15369: LD_ADDR_EXP 31
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 4 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15377: GO 15471
15379: LD_OWVAR 1
15383: PUSH
15384: LD_INT 84000
15386: GREATER
15387: PUSH
15388: LD_EXP 27
15392: PUSH
15393: LD_INT 4
15395: LESS
15396: AND
15397: PUSH
15398: LD_EXP 40
15402: PPUSH
15403: LD_VAR 0 8
15407: PPUSH
15408: LD_VAR 0 2
15412: PPUSH
15413: LD_VAR 0 4
15417: PPUSH
15418: LD_INT 27
15420: PPUSH
15421: CALL_OW 448
15425: AND
15426: DOUBLE
15427: EQUAL
15428: IFTRUE 15432
15430: GO 15470
15432: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15433: LD_EXP 40
15437: PPUSH
15438: LD_VAR 0 8
15442: PPUSH
15443: LD_VAR 0 2
15447: PPUSH
15448: LD_VAR 0 4
15452: PPUSH
15453: LD_INT 27
15455: PPUSH
15456: CALL_OW 125
// to_attack := true ;
15460: LD_ADDR_EXP 31
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// end ; end ;
15468: GO 15471
15470: POP
// enable ;
15471: ENABLE
// end ;
15472: PPOPN 9
15474: END
// export hover , zbytek ; every 0 0$10 trigger ( ( attack diff brk_cars ) >= 2 ) do var pouzit ;
15475: LD_EXP 27
15479: PUSH
15480: LD_EXP 74
15484: DIFF
15485: PUSH
15486: LD_INT 2
15488: GREATEREQUAL
15489: IFFALSE 15738
15491: GO 15493
15493: DISABLE
15494: LD_INT 0
15496: PPUSH
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
15497: LD_EXP 1
15501: PPUSH
15502: LD_EXP 3
15506: PPUSH
15507: LD_INT 2
15509: PPUSH
15510: LD_INT 1
15512: PPUSH
15513: CALL_OW 80
// first_attack := true ;
15517: LD_ADDR_EXP 18
15521: PUSH
15522: LD_INT 1
15524: ST_TO_ADDR
// pouzit := UnitFilter ( attack diff brk_cars , [ f_not , [ f_hastask ] ] ) ;
15525: LD_ADDR_VAR 0 1
15529: PUSH
15530: LD_EXP 27
15534: PUSH
15535: LD_EXP 74
15539: DIFF
15540: PPUSH
15541: LD_INT 3
15543: PUSH
15544: LD_INT 60
15546: PUSH
15547: EMPTY
15548: LIST
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// hover := UnitFilter ( pouzit , [ [ f_chassis , ar_hovercraft ] ] ) ;
15559: LD_ADDR_EXP 70
15563: PUSH
15564: LD_VAR 0 1
15568: PPUSH
15569: LD_INT 31
15571: PUSH
15572: LD_INT 11
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: PPUSH
15582: CALL_OW 72
15586: ST_TO_ADDR
// zbytek := pouzit diff hover ;
15587: LD_ADDR_EXP 71
15591: PUSH
15592: LD_VAR 0 1
15596: PUSH
15597: LD_EXP 70
15601: DIFF
15602: ST_TO_ADDR
// if wait_while then
15603: LD_EXP 12
15607: IFFALSE 15624
// begin wait ( 3 3$0 ) ;
15609: LD_INT 6300
15611: PPUSH
15612: CALL_OW 67
// wait_while := false ;
15616: LD_ADDR_EXP 12
15620: PUSH
15621: LD_INT 0
15623: ST_TO_ADDR
// end ; if hover then
15624: LD_EXP 70
15628: IFFALSE 15639
// RaiseSailEvent ( vodni_utok ) ;
15630: LD_EXP 35
15634: PPUSH
15635: CALL_OW 427
// if zbytek then
15639: LD_EXP 71
15643: IFFALSE 15737
// case Rand ( 1 , 2 ) of 1 :
15645: LD_INT 1
15647: PPUSH
15648: LD_INT 2
15650: PPUSH
15651: CALL_OW 12
15655: PUSH
15656: LD_INT 1
15658: DOUBLE
15659: EQUAL
15660: IFTRUE 15664
15662: GO 15676
15664: POP
// RaiseSailEvent ( normal1_utok ) ; 2 :
15665: LD_EXP 36
15669: PPUSH
15670: CALL_OW 427
15674: GO 15737
15676: LD_INT 2
15678: DOUBLE
15679: EQUAL
15680: IFTRUE 15684
15682: GO 15696
15684: POP
// RaiseSailEvent ( normal2_utok ) ; 1 :
15685: LD_EXP 37
15689: PPUSH
15690: CALL_OW 427
15694: GO 15737
15696: LD_INT 1
15698: DOUBLE
15699: EQUAL
15700: IFTRUE 15704
15702: GO 15716
15704: POP
// RaiseSailEvent ( normal3_utok ) ; 2 :
15705: LD_EXP 38
15709: PPUSH
15710: CALL_OW 427
15714: GO 15737
15716: LD_INT 2
15718: DOUBLE
15719: EQUAL
15720: IFTRUE 15724
15722: GO 15736
15724: POP
// RaiseSailEvent ( normal4_utok ) ; end ;
15725: LD_EXP 39
15729: PPUSH
15730: CALL_OW 427
15734: GO 15737
15736: POP
// enable ;
15737: ENABLE
// end ;
15738: PPOPN 1
15740: END
// every 0 0$3 trigger remote do var i ;
15741: LD_EXP 29
15745: IFFALSE 15849
15747: GO 15749
15749: DISABLE
15750: LD_INT 0
15752: PPUSH
// begin if mec then
15753: LD_EXP 22
15757: IFFALSE 15848
// for i in remote do
15759: LD_ADDR_VAR 0 1
15763: PUSH
15764: LD_EXP 29
15768: PUSH
15769: FOR_IN
15770: IFFALSE 15846
// if not UnitsInside ( i ) then
15772: LD_VAR 0 1
15776: PPUSH
15777: CALL_OW 313
15781: NOT
15782: IFFALSE 15844
// begin if not rmec then
15784: LD_EXP 24
15788: NOT
15789: IFFALSE 15805
// rmec := mec [ 1 ] ;
15791: LD_ADDR_EXP 24
15795: PUSH
15796: LD_EXP 22
15800: PUSH
15801: LD_INT 1
15803: ARRAY
15804: ST_TO_ADDR
// ComExitVehicle ( rmec ) ;
15805: LD_EXP 24
15809: PPUSH
15810: CALL_OW 121
// AddComEnterUnit ( rmec , i ) ;
15814: LD_EXP 24
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: CALL_OW 180
// mec := mec diff rmec ;
15828: LD_ADDR_EXP 22
15832: PUSH
15833: LD_EXP 22
15837: PUSH
15838: LD_EXP 24
15842: DIFF
15843: ST_TO_ADDR
// end ;
15844: GO 15769
15846: POP
15847: POP
// enable ;
15848: ENABLE
// end ;
15849: PPOPN 1
15851: END
// every 0 0$3 trigger not remote do
15852: LD_EXP 29
15856: NOT
15857: IFFALSE 15879
15859: GO 15861
15861: DISABLE
// begin mec := mec union rmec ;
15862: LD_ADDR_EXP 22
15866: PUSH
15867: LD_EXP 22
15871: PUSH
15872: LD_EXP 24
15876: UNION
15877: ST_TO_ADDR
// enable ;
15878: ENABLE
// end ;
15879: END
// every 0 0$3 trigger UnitFilter ( attack , [ f_not , [ f_linked ] ] ) do var i ;
15880: LD_EXP 27
15884: PPUSH
15885: LD_INT 3
15887: PUSH
15888: LD_INT 61
15890: PUSH
15891: EMPTY
15892: LIST
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PPUSH
15898: CALL_OW 72
15902: IFFALSE 15943
15904: GO 15906
15906: DISABLE
15907: LD_INT 0
15909: PPUSH
// begin ComLinkTo ( UnitFilter ( attack , [ f_not , [ f_linked ] ] ) , rmec ) ;
15910: LD_EXP 27
15914: PPUSH
15915: LD_INT 3
15917: PUSH
15918: LD_INT 61
15920: PUSH
15921: EMPTY
15922: LIST
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PPUSH
15928: CALL_OW 72
15932: PPUSH
15933: LD_EXP 24
15937: PPUSH
15938: CALL_OW 135
// enable ;
15942: ENABLE
// end ;
15943: PPOPN 1
15945: END
// export function f_vodni_utok ; var path , i ; begin
15946: LD_INT 0
15948: PPUSH
15949: PPUSH
15950: PPUSH
// path := [ [ 177 , 126 ] , [ 149 , 114 ] , [ 117 , 87 ] , [ 107 , 99 ] , [ 81 , 98 ] , [ 60 , 86 ] , [ 49 , 72 ] , [ 37 , 43 ] , [ 54 , 29 ] , [ 62 , 27 ] , [ 54 , 29 ] , [ 37 , 43 ] , [ 49 , 72 ] , [ 60 , 86 ] , [ 81 , 98 ] , [ 107 , 99 ] , [ 117 , 87 ] , [ 149 , 114 ] , [ 177 , 126 ] ] ;
15951: LD_ADDR_VAR 0 2
15955: PUSH
15956: LD_INT 177
15958: PUSH
15959: LD_INT 126
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 149
15968: PUSH
15969: LD_INT 114
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: LD_INT 117
15978: PUSH
15979: LD_INT 87
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 107
15988: PUSH
15989: LD_INT 99
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: LD_INT 81
15998: PUSH
15999: LD_INT 98
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PUSH
16006: LD_INT 60
16008: PUSH
16009: LD_INT 86
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 49
16018: PUSH
16019: LD_INT 72
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PUSH
16026: LD_INT 37
16028: PUSH
16029: LD_INT 43
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: PUSH
16036: LD_INT 54
16038: PUSH
16039: LD_INT 29
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: PUSH
16046: LD_INT 62
16048: PUSH
16049: LD_INT 27
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: LD_INT 54
16058: PUSH
16059: LD_INT 29
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PUSH
16066: LD_INT 37
16068: PUSH
16069: LD_INT 43
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: PUSH
16076: LD_INT 49
16078: PUSH
16079: LD_INT 72
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 60
16088: PUSH
16089: LD_INT 86
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 81
16098: PUSH
16099: LD_INT 98
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PUSH
16106: LD_INT 107
16108: PUSH
16109: LD_INT 99
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: PUSH
16116: LD_INT 117
16118: PUSH
16119: LD_INT 87
16121: PUSH
16122: EMPTY
16123: LIST
16124: LIST
16125: PUSH
16126: LD_INT 149
16128: PUSH
16129: LD_INT 114
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 177
16138: PUSH
16139: LD_INT 126
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: LIST
16151: LIST
16152: LIST
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: LIST
16164: LIST
16165: LIST
16166: ST_TO_ADDR
// find_and_wait ( UnitFilter ( hover , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16167: LD_EXP 70
16171: PPUSH
16172: LD_INT 33
16174: PUSH
16175: LD_INT 1
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PUSH
16182: EMPTY
16183: LIST
16184: PPUSH
16185: CALL_OW 72
16189: PPUSH
16190: LD_EXP 19
16194: PPUSH
16195: LD_INT 0
16197: PPUSH
16198: LD_INT 0
16200: PPUSH
16201: LD_INT 1750
16203: PPUSH
16204: CALL 24458 0 5
// find_and_wait_r ( UnitFilter ( hover , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16208: LD_EXP 70
16212: PPUSH
16213: LD_INT 33
16215: PUSH
16216: LD_INT 2
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: PPUSH
16226: CALL_OW 72
16230: PPUSH
16231: LD_EXP 29
16235: PPUSH
16236: LD_INT 1750
16238: PPUSH
16239: CALL 25158 0 3
// for i in path do
16243: LD_ADDR_VAR 0 3
16247: PUSH
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_IN
16254: IFFALSE 16329
// AddComAgressiveMove ( hover , Rand ( i [ 1 ] - 1 , i [ 1 ] + 1 ) , Rand ( i [ 2 ] - 1 , i [ 2 ] + 1 ) ) ;
16256: LD_EXP 70
16260: PPUSH
16261: LD_VAR 0 3
16265: PUSH
16266: LD_INT 1
16268: ARRAY
16269: PUSH
16270: LD_INT 1
16272: MINUS
16273: PPUSH
16274: LD_VAR 0 3
16278: PUSH
16279: LD_INT 1
16281: ARRAY
16282: PUSH
16283: LD_INT 1
16285: PLUS
16286: PPUSH
16287: CALL_OW 12
16291: PPUSH
16292: LD_VAR 0 3
16296: PUSH
16297: LD_INT 2
16299: ARRAY
16300: PUSH
16301: LD_INT 1
16303: MINUS
16304: PPUSH
16305: LD_VAR 0 3
16309: PUSH
16310: LD_INT 2
16312: ARRAY
16313: PUSH
16314: LD_INT 1
16316: PLUS
16317: PPUSH
16318: CALL_OW 12
16322: PPUSH
16323: CALL_OW 174
16327: GO 16253
16329: POP
16330: POP
// end ;
16331: LD_VAR 0 1
16335: RET
// export function f_normal1_utok ; var path , i ; begin
16336: LD_INT 0
16338: PPUSH
16339: PPUSH
16340: PPUSH
// path := [ [ 102 , 68 ] , [ 96 , 67 ] , [ 73 , 55 ] , [ 69 , 77 ] , [ 59 , 54 ] ] ;
16341: LD_ADDR_VAR 0 2
16345: PUSH
16346: LD_INT 102
16348: PUSH
16349: LD_INT 68
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 96
16358: PUSH
16359: LD_INT 67
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 73
16368: PUSH
16369: LD_INT 55
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: LD_INT 69
16378: PUSH
16379: LD_INT 77
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 59
16388: PUSH
16389: LD_INT 54
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: LIST
16401: LIST
16402: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16403: LD_EXP 71
16407: PPUSH
16408: LD_INT 33
16410: PUSH
16411: LD_INT 1
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PUSH
16418: EMPTY
16419: LIST
16420: PPUSH
16421: CALL_OW 72
16425: PPUSH
16426: LD_EXP 19
16430: PPUSH
16431: LD_INT 0
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: LD_INT 1750
16439: PPUSH
16440: CALL 24458 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16444: LD_EXP 71
16448: PPUSH
16449: LD_INT 33
16451: PUSH
16452: LD_INT 2
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: EMPTY
16460: LIST
16461: PPUSH
16462: CALL_OW 72
16466: PPUSH
16467: LD_EXP 29
16471: PPUSH
16472: LD_INT 1750
16474: PPUSH
16475: CALL 25158 0 3
// for i in path do
16479: LD_ADDR_VAR 0 3
16483: PUSH
16484: LD_VAR 0 2
16488: PUSH
16489: FOR_IN
16490: IFFALSE 16565
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16492: LD_EXP 71
16496: PPUSH
16497: LD_VAR 0 3
16501: PUSH
16502: LD_INT 1
16504: ARRAY
16505: PUSH
16506: LD_INT 4
16508: MINUS
16509: PPUSH
16510: LD_VAR 0 3
16514: PUSH
16515: LD_INT 1
16517: ARRAY
16518: PUSH
16519: LD_INT 4
16521: PLUS
16522: PPUSH
16523: CALL_OW 12
16527: PPUSH
16528: LD_VAR 0 3
16532: PUSH
16533: LD_INT 2
16535: ARRAY
16536: PUSH
16537: LD_INT 4
16539: MINUS
16540: PPUSH
16541: LD_VAR 0 3
16545: PUSH
16546: LD_INT 2
16548: ARRAY
16549: PUSH
16550: LD_INT 4
16552: PLUS
16553: PPUSH
16554: CALL_OW 12
16558: PPUSH
16559: CALL_OW 174
16563: GO 16489
16565: POP
16566: POP
// end ;
16567: LD_VAR 0 1
16571: RET
// export function f_normal2_utok ; var path , i ; begin
16572: LD_INT 0
16574: PPUSH
16575: PPUSH
16576: PPUSH
// path := [ [ 91 , 61 ] , [ 79 , 79 ] , [ 57 , 61 ] , [ 68 , 48 ] , [ 64 , 94 ] ] ;
16577: LD_ADDR_VAR 0 2
16581: PUSH
16582: LD_INT 91
16584: PUSH
16585: LD_INT 61
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PUSH
16592: LD_INT 79
16594: PUSH
16595: LD_INT 79
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_INT 57
16604: PUSH
16605: LD_INT 61
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 68
16614: PUSH
16615: LD_INT 48
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: LD_INT 64
16624: PUSH
16625: LD_INT 94
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: LIST
16636: LIST
16637: LIST
16638: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16639: LD_EXP 71
16643: PPUSH
16644: LD_INT 33
16646: PUSH
16647: LD_INT 1
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PUSH
16654: EMPTY
16655: LIST
16656: PPUSH
16657: CALL_OW 72
16661: PPUSH
16662: LD_EXP 19
16666: PPUSH
16667: LD_INT 0
16669: PPUSH
16670: LD_INT 0
16672: PPUSH
16673: LD_INT 1750
16675: PPUSH
16676: CALL 24458 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16680: LD_EXP 71
16684: PPUSH
16685: LD_INT 33
16687: PUSH
16688: LD_INT 2
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PUSH
16695: EMPTY
16696: LIST
16697: PPUSH
16698: CALL_OW 72
16702: PPUSH
16703: LD_EXP 29
16707: PPUSH
16708: LD_INT 1750
16710: PPUSH
16711: CALL 25158 0 3
// for i in path do
16715: LD_ADDR_VAR 0 3
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: FOR_IN
16726: IFFALSE 16801
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16728: LD_EXP 71
16732: PPUSH
16733: LD_VAR 0 3
16737: PUSH
16738: LD_INT 1
16740: ARRAY
16741: PUSH
16742: LD_INT 4
16744: MINUS
16745: PPUSH
16746: LD_VAR 0 3
16750: PUSH
16751: LD_INT 1
16753: ARRAY
16754: PUSH
16755: LD_INT 4
16757: PLUS
16758: PPUSH
16759: CALL_OW 12
16763: PPUSH
16764: LD_VAR 0 3
16768: PUSH
16769: LD_INT 2
16771: ARRAY
16772: PUSH
16773: LD_INT 4
16775: MINUS
16776: PPUSH
16777: LD_VAR 0 3
16781: PUSH
16782: LD_INT 2
16784: ARRAY
16785: PUSH
16786: LD_INT 4
16788: PLUS
16789: PPUSH
16790: CALL_OW 12
16794: PPUSH
16795: CALL_OW 174
16799: GO 16725
16801: POP
16802: POP
// end ;
16803: LD_VAR 0 1
16807: RET
// export function f_normal3_utok ; var path , i ; begin
16808: LD_INT 0
16810: PPUSH
16811: PPUSH
16812: PPUSH
// path := [ [ 114 , 67 ] , [ 108 , 67 ] , [ 102 , 66 ] , [ 94 , 65 ] , [ 95 , 79 ] , [ 91 , 89 ] , [ 81 , 93 ] , [ 71 , 83 ] , [ 61 , 75 ] , [ 52 , 58 ] , [ 67 , 71 ] , [ 70 , 59 ] , [ 65 , 49 ] , [ 51 , 45 ] , [ 65 , 40 ] , [ 92 , 67 ] ] ;
16813: LD_ADDR_VAR 0 2
16817: PUSH
16818: LD_INT 114
16820: PUSH
16821: LD_INT 67
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 108
16830: PUSH
16831: LD_INT 67
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: LD_INT 102
16840: PUSH
16841: LD_INT 66
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 94
16850: PUSH
16851: LD_INT 65
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 95
16860: PUSH
16861: LD_INT 79
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PUSH
16868: LD_INT 91
16870: PUSH
16871: LD_INT 89
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: LD_INT 81
16880: PUSH
16881: LD_INT 93
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: LD_INT 71
16890: PUSH
16891: LD_INT 83
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: PUSH
16898: LD_INT 61
16900: PUSH
16901: LD_INT 75
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 52
16910: PUSH
16911: LD_INT 58
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 67
16920: PUSH
16921: LD_INT 71
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 70
16930: PUSH
16931: LD_INT 59
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: LD_INT 65
16940: PUSH
16941: LD_INT 49
16943: PUSH
16944: EMPTY
16945: LIST
16946: LIST
16947: PUSH
16948: LD_INT 51
16950: PUSH
16951: LD_INT 45
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: PUSH
16958: LD_INT 65
16960: PUSH
16961: LD_INT 40
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PUSH
16968: LD_INT 92
16970: PUSH
16971: LD_INT 67
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: EMPTY
16979: LIST
16980: LIST
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16996: LD_EXP 71
17000: PPUSH
17001: LD_INT 33
17003: PUSH
17004: LD_INT 1
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PUSH
17011: EMPTY
17012: LIST
17013: PPUSH
17014: CALL_OW 72
17018: PPUSH
17019: LD_EXP 19
17023: PPUSH
17024: LD_INT 0
17026: PPUSH
17027: LD_INT 0
17029: PPUSH
17030: LD_INT 1750
17032: PPUSH
17033: CALL 24458 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
17037: LD_EXP 71
17041: PPUSH
17042: LD_INT 33
17044: PUSH
17045: LD_INT 2
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: PUSH
17052: EMPTY
17053: LIST
17054: PPUSH
17055: CALL_OW 72
17059: PPUSH
17060: LD_EXP 29
17064: PPUSH
17065: LD_INT 1750
17067: PPUSH
17068: CALL 25158 0 3
// for i in path do
17072: LD_ADDR_VAR 0 3
17076: PUSH
17077: LD_VAR 0 2
17081: PUSH
17082: FOR_IN
17083: IFFALSE 17158
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17085: LD_EXP 71
17089: PPUSH
17090: LD_VAR 0 3
17094: PUSH
17095: LD_INT 1
17097: ARRAY
17098: PUSH
17099: LD_INT 4
17101: MINUS
17102: PPUSH
17103: LD_VAR 0 3
17107: PUSH
17108: LD_INT 1
17110: ARRAY
17111: PUSH
17112: LD_INT 4
17114: PLUS
17115: PPUSH
17116: CALL_OW 12
17120: PPUSH
17121: LD_VAR 0 3
17125: PUSH
17126: LD_INT 2
17128: ARRAY
17129: PUSH
17130: LD_INT 4
17132: MINUS
17133: PPUSH
17134: LD_VAR 0 3
17138: PUSH
17139: LD_INT 2
17141: ARRAY
17142: PUSH
17143: LD_INT 4
17145: PLUS
17146: PPUSH
17147: CALL_OW 12
17151: PPUSH
17152: CALL_OW 174
17156: GO 17082
17158: POP
17159: POP
// end ;
17160: LD_VAR 0 1
17164: RET
// export function f_normal4_utok ; var path , i ; begin
17165: LD_INT 0
17167: PPUSH
17168: PPUSH
17169: PPUSH
// path := [ [ 112 , 68 ] , [ 98 , 67 ] , [ 80 , 61 ] , [ 72 , 61 ] , [ 62 , 60 ] , [ 61 , 50 ] , [ 49 , 38 ] , [ 52 , 48 ] , [ 62 , 62 ] , [ 66 , 78 ] , [ 74 , 80 ] ] ;
17170: LD_ADDR_VAR 0 2
17174: PUSH
17175: LD_INT 112
17177: PUSH
17178: LD_INT 68
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 98
17187: PUSH
17188: LD_INT 67
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: LD_INT 80
17197: PUSH
17198: LD_INT 61
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 72
17207: PUSH
17208: LD_INT 61
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: LD_INT 62
17217: PUSH
17218: LD_INT 60
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: PUSH
17225: LD_INT 61
17227: PUSH
17228: LD_INT 50
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: LD_INT 49
17237: PUSH
17238: LD_INT 38
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 52
17247: PUSH
17248: LD_INT 48
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: LD_INT 62
17257: PUSH
17258: LD_INT 62
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: PUSH
17265: LD_INT 66
17267: PUSH
17268: LD_INT 78
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: PUSH
17275: LD_INT 74
17277: PUSH
17278: LD_INT 80
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PUSH
17285: EMPTY
17286: LIST
17287: LIST
17288: LIST
17289: LIST
17290: LIST
17291: LIST
17292: LIST
17293: LIST
17294: LIST
17295: LIST
17296: LIST
17297: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
17298: LD_EXP 71
17302: PPUSH
17303: LD_INT 33
17305: PUSH
17306: LD_INT 1
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: EMPTY
17314: LIST
17315: PPUSH
17316: CALL_OW 72
17320: PPUSH
17321: LD_EXP 19
17325: PPUSH
17326: LD_INT 0
17328: PPUSH
17329: LD_INT 0
17331: PPUSH
17332: LD_INT 1750
17334: PPUSH
17335: CALL 24458 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
17339: LD_EXP 71
17343: PPUSH
17344: LD_INT 33
17346: PUSH
17347: LD_INT 2
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PUSH
17354: EMPTY
17355: LIST
17356: PPUSH
17357: CALL_OW 72
17361: PPUSH
17362: LD_EXP 29
17366: PPUSH
17367: LD_INT 1750
17369: PPUSH
17370: CALL 25158 0 3
// for i in path do
17374: LD_ADDR_VAR 0 3
17378: PUSH
17379: LD_VAR 0 2
17383: PUSH
17384: FOR_IN
17385: IFFALSE 17460
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17387: LD_EXP 71
17391: PPUSH
17392: LD_VAR 0 3
17396: PUSH
17397: LD_INT 1
17399: ARRAY
17400: PUSH
17401: LD_INT 4
17403: MINUS
17404: PPUSH
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 1
17412: ARRAY
17413: PUSH
17414: LD_INT 4
17416: PLUS
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_VAR 0 3
17427: PUSH
17428: LD_INT 2
17430: ARRAY
17431: PUSH
17432: LD_INT 4
17434: MINUS
17435: PPUSH
17436: LD_VAR 0 3
17440: PUSH
17441: LD_INT 2
17443: ARRAY
17444: PUSH
17445: LD_INT 4
17447: PLUS
17448: PPUSH
17449: CALL_OW 12
17453: PPUSH
17454: CALL_OW 174
17458: GO 17384
17460: POP
17461: POP
// end ;
17462: LD_VAR 0 1
17466: RET
// export mines ; every 0 0$1 do var i ;
17467: GO 17469
17469: DISABLE
17470: LD_INT 0
17472: PPUSH
// begin mines := [ ] ;
17473: LD_ADDR_EXP 72
17477: PUSH
17478: EMPTY
17479: ST_TO_ADDR
// sol := UnitFilter ( sol , [ [ f_alive ] ] ) ;
17480: LD_ADDR_EXP 19
17484: PUSH
17485: LD_EXP 19
17489: PPUSH
17490: LD_INT 51
17492: PUSH
17493: EMPTY
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: PPUSH
17499: CALL_OW 72
17503: ST_TO_ADDR
// for i in sol do
17504: LD_ADDR_VAR 0 1
17508: PUSH
17509: LD_EXP 19
17513: PUSH
17514: FOR_IN
17515: IFFALSE 17549
// if MineOfUnit ( i ) then
17517: LD_VAR 0 1
17521: PPUSH
17522: CALL_OW 459
17526: IFFALSE 17547
// mines := mines ^ [ i ] ;
17528: LD_ADDR_EXP 72
17532: PUSH
17533: LD_EXP 72
17537: PUSH
17538: LD_VAR 0 1
17542: PUSH
17543: EMPTY
17544: LIST
17545: ADD
17546: ST_TO_ADDR
17547: GO 17514
17549: POP
17550: POP
// enable ;
17551: ENABLE
// end ;
17552: PPOPN 1
17554: END
// every 0 0$30 trigger mines < pocet_min do var i , a , s ;
17555: LD_EXP 72
17559: PUSH
17560: LD_EXP 16
17564: LESS
17565: IFFALSE 17706
17567: GO 17569
17569: DISABLE
17570: LD_INT 0
17572: PPUSH
17573: PPUSH
17574: PPUSH
// begin s := UnitFilter ( sol , [ [ f_outside ] ] ) ;
17575: LD_ADDR_VAR 0 3
17579: PUSH
17580: LD_EXP 19
17584: PPUSH
17585: LD_INT 56
17587: PUSH
17588: EMPTY
17589: LIST
17590: PUSH
17591: EMPTY
17592: LIST
17593: PPUSH
17594: CALL_OW 72
17598: ST_TO_ADDR
// if s then
17599: LD_VAR 0 3
17603: IFFALSE 17705
// begin i := s [ Rand ( 1 , s ) ] ;
17605: LD_ADDR_VAR 0 1
17609: PUSH
17610: LD_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: PPUSH
17618: LD_VAR 0 3
17622: PPUSH
17623: CALL_OW 12
17627: ARRAY
17628: ST_TO_ADDR
// if not MineOfUnit ( i ) then
17629: LD_VAR 0 1
17633: PPUSH
17634: CALL_OW 459
17638: NOT
17639: IFFALSE 17705
// begin ComRemember ( i ) ;
17641: LD_VAR 0 1
17645: PPUSH
17646: CALL_OW 143
// a := RandHexArea ( miny , false ) ;
17650: LD_ADDR_VAR 0 2
17654: PUSH
17655: LD_INT 25
17657: PPUSH
17658: LD_INT 0
17660: PPUSH
17661: CALL_OW 16
17665: ST_TO_ADDR
// AddComPlaceRemoteCharge ( i , a [ 1 ] , a [ 2 ] , 0 ) ;
17666: LD_VAR 0 1
17670: PPUSH
17671: LD_VAR 0 2
17675: PUSH
17676: LD_INT 1
17678: ARRAY
17679: PPUSH
17680: LD_VAR 0 2
17684: PUSH
17685: LD_INT 2
17687: ARRAY
17688: PPUSH
17689: LD_INT 0
17691: PPUSH
17692: CALL_OW 193
// AddComReturn ( i ) ;
17696: LD_VAR 0 1
17700: PPUSH
17701: CALL_OW 204
// end ; end ; enable ;
17705: ENABLE
// end ;
17706: PPOPN 3
17708: END
// every 0 0$2 trigger mines and FilterUnitsInArea ( miny , [ [ f_side , you ] ] ) and ( FilterUnitsInArea ( miny , [ [ f_side , arabians ] ] ) < 2 ) do
17709: LD_EXP 72
17713: PUSH
17714: LD_INT 25
17716: PPUSH
17717: LD_INT 22
17719: PUSH
17720: LD_EXP 1
17724: PUSH
17725: EMPTY
17726: LIST
17727: LIST
17728: PUSH
17729: EMPTY
17730: LIST
17731: PPUSH
17732: CALL_OW 70
17736: AND
17737: PUSH
17738: LD_INT 25
17740: PPUSH
17741: LD_INT 22
17743: PUSH
17744: LD_EXP 3
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PUSH
17753: EMPTY
17754: LIST
17755: PPUSH
17756: CALL_OW 70
17760: PUSH
17761: LD_INT 2
17763: LESS
17764: AND
17765: IFFALSE 17816
17767: GO 17769
17769: DISABLE
// begin ComFireExplosives ( mines [ 1 ] ) ;
17770: LD_EXP 72
17774: PUSH
17775: LD_INT 1
17777: ARRAY
17778: PPUSH
17779: CALL_OW 134
// mines := mines diff [ mines [ 1 ] ] ;
17783: LD_ADDR_EXP 72
17787: PUSH
17788: LD_EXP 72
17792: PUSH
17793: LD_EXP 72
17797: PUSH
17798: LD_INT 1
17800: ARRAY
17801: PUSH
17802: EMPTY
17803: LIST
17804: DIFF
17805: ST_TO_ADDR
// wait ( mezera_mezi_minami ) ;
17806: LD_EXP 15
17810: PPUSH
17811: CALL_OW 67
// enable ;
17815: ENABLE
// end ; end_of_file
17816: END
// export opravit ; every 0 0$1 do var set_fuel , fuel ;
17817: GO 17819
17819: DISABLE
17820: LD_INT 0
17822: PPUSH
17823: PPUSH
// begin for set_fuel in FilterUnitsInArea ( near_base , [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) do
17824: LD_ADDR_VAR 0 1
17828: PUSH
17829: LD_INT 13
17831: PPUSH
17832: LD_INT 21
17834: PUSH
17835: LD_INT 2
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: PUSH
17842: LD_INT 22
17844: PUSH
17845: LD_EXP 3
17849: PUSH
17850: EMPTY
17851: LIST
17852: LIST
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: PPUSH
17858: CALL_OW 70
17862: PUSH
17863: FOR_IN
17864: IFFALSE 17905
// begin fuel := GetFuel ( set_fuel ) ;
17866: LD_ADDR_VAR 0 2
17870: PUSH
17871: LD_VAR 0 1
17875: PPUSH
17876: CALL_OW 261
17880: ST_TO_ADDR
// if fuel < 100 then
17881: LD_VAR 0 2
17885: PUSH
17886: LD_INT 100
17888: LESS
17889: IFFALSE 17903
// SetFuel ( set_fuel , 100 ) ;
17891: LD_VAR 0 1
17895: PPUSH
17896: LD_INT 100
17898: PPUSH
17899: CALL_OW 240
// end ;
17903: GO 17863
17905: POP
17906: POP
// enable ;
17907: ENABLE
// end ;
17908: PPOPN 2
17910: END
// every 0 0$10 + 0 0$8 do var zivoty , i ;
17911: GO 17913
17913: DISABLE
17914: LD_INT 0
17916: PPUSH
17917: PPUSH
// begin opravit := [ ] ;
17918: LD_ADDR_EXP 73
17922: PUSH
17923: EMPTY
17924: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
17925: LD_ADDR_VAR 0 2
17929: PUSH
17930: LD_INT 22
17932: PUSH
17933: LD_EXP 3
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: PUSH
17942: LD_INT 21
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: PPUSH
17956: CALL_OW 69
17960: PUSH
17961: FOR_IN
17962: IFFALSE 18018
// begin if GetLives ( i ) < 950 then
17964: LD_VAR 0 2
17968: PPUSH
17969: CALL_OW 256
17973: PUSH
17974: LD_INT 950
17976: LESS
17977: IFFALSE 18016
// begin opravit := opravit ^ i ;
17979: LD_ADDR_EXP 73
17983: PUSH
17984: LD_EXP 73
17988: PUSH
17989: LD_VAR 0 2
17993: ADD
17994: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
17995: LD_ADDR_VAR 0 1
17999: PUSH
18000: LD_VAR 0 1
18004: PUSH
18005: LD_VAR 0 2
18009: PPUSH
18010: CALL_OW 256
18014: ADD
18015: ST_TO_ADDR
// end ; end ;
18016: GO 17961
18018: POP
18019: POP
// opravit := SortListByListAsc ( opravit , zivoty ) ;
18020: LD_ADDR_EXP 73
18024: PUSH
18025: LD_EXP 73
18029: PPUSH
18030: LD_VAR 0 1
18034: PPUSH
18035: CALL_OW 76
18039: ST_TO_ADDR
// enable ;
18040: ENABLE
// end ;
18041: PPOPN 2
18043: END
// every 0 0$20 trigger opravit do var tmp_eng ;
18044: LD_EXP 73
18048: IFFALSE 18140
18050: GO 18052
18052: DISABLE
18053: LD_INT 0
18055: PPUSH
// begin while not eng do
18056: LD_EXP 23
18060: NOT
18061: IFFALSE 18072
// wait ( 0 0$5 ) ;
18063: LD_INT 175
18065: PPUSH
18066: CALL_OW 67
18070: GO 18056
// tmp_eng := eng ;
18072: LD_ADDR_VAR 0 1
18076: PUSH
18077: LD_EXP 23
18081: ST_TO_ADDR
// eng := [ ] ;
18082: LD_ADDR_EXP 23
18086: PUSH
18087: EMPTY
18088: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ) ;
18089: LD_VAR 0 1
18093: PPUSH
18094: CALL_OW 122
// AddComRepairBuilding ( tmp_eng , opravit [ 1 ] ) ;
18098: LD_VAR 0 1
18102: PPUSH
18103: LD_EXP 73
18107: PUSH
18108: LD_INT 1
18110: ARRAY
18111: PPUSH
18112: CALL_OW 190
// wait ( 0 0$19.9 ) ;
18116: LD_INT 696
18118: PPUSH
18119: CALL_OW 67
// eng := eng union tmp_eng ;
18123: LD_ADDR_EXP 23
18127: PUSH
18128: LD_EXP 23
18132: PUSH
18133: LD_VAR 0 1
18137: UNION
18138: ST_TO_ADDR
// enable ;
18139: ENABLE
// end ;
18140: PPOPN 1
18142: END
// every 0 0$10 trigger stavi do var tmp_eng , tmp_sci ;
18143: LD_EXP 68
18147: IFFALSE 18271
18149: GO 18151
18151: DISABLE
18152: LD_INT 0
18154: PPUSH
18155: PPUSH
// begin tmp_eng := eng ;
18156: LD_ADDR_VAR 0 1
18160: PUSH
18161: LD_EXP 23
18165: ST_TO_ADDR
// eng := [ ] ;
18166: LD_ADDR_EXP 23
18170: PUSH
18171: EMPTY
18172: ST_TO_ADDR
// tmp_sci := sci ;
18173: LD_ADDR_VAR 0 2
18177: PUSH
18178: LD_EXP 21
18182: ST_TO_ADDR
// sci := [ ] ;
18183: LD_ADDR_EXP 21
18187: PUSH
18188: EMPTY
18189: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ^ tmp_sci ) ;
18190: LD_VAR 0 1
18194: PUSH
18195: LD_VAR 0 2
18199: ADD
18200: PPUSH
18201: CALL_OW 122
// AddComMoveXY ( tmp_eng ^ tmp_sci , stavi [ 1 ] , stavi [ 2 ] ) ;
18205: LD_VAR 0 1
18209: PUSH
18210: LD_VAR 0 2
18214: ADD
18215: PPUSH
18216: LD_EXP 68
18220: PUSH
18221: LD_INT 1
18223: ARRAY
18224: PPUSH
18225: LD_EXP 68
18229: PUSH
18230: LD_INT 2
18232: ARRAY
18233: PPUSH
18234: CALL_OW 171
// eng := eng union tmp_eng ;
18238: LD_ADDR_EXP 23
18242: PUSH
18243: LD_EXP 23
18247: PUSH
18248: LD_VAR 0 1
18252: UNION
18253: ST_TO_ADDR
// sci := sci union tmp_sci ;
18254: LD_ADDR_EXP 21
18258: PUSH
18259: LD_EXP 21
18263: PUSH
18264: LD_VAR 0 2
18268: UNION
18269: ST_TO_ADDR
// enable ;
18270: ENABLE
// end ;
18271: PPOPN 2
18273: END
// export brk_cars ; every 0 0$1 do var zivoty , i ;
18274: GO 18276
18276: DISABLE
18277: LD_INT 0
18279: PPUSH
18280: PPUSH
// begin for i in attack do
18281: LD_ADDR_VAR 0 2
18285: PUSH
18286: LD_EXP 27
18290: PUSH
18291: FOR_IN
18292: IFFALSE 18405
// begin if GetLives ( i ) < 600 or GetFuel ( i ) < 30 then
18294: LD_VAR 0 2
18298: PPUSH
18299: CALL_OW 256
18303: PUSH
18304: LD_INT 600
18306: LESS
18307: PUSH
18308: LD_VAR 0 2
18312: PPUSH
18313: CALL_OW 261
18317: PUSH
18318: LD_INT 30
18320: LESS
18321: OR
18322: IFFALSE 18357
// begin ComMoveXY ( i , 141 , 72 ) ;
18324: LD_VAR 0 2
18328: PPUSH
18329: LD_INT 141
18331: PPUSH
18332: LD_INT 72
18334: PPUSH
18335: CALL_OW 111
// brk_cars := brk_cars union i ;
18339: LD_ADDR_EXP 74
18343: PUSH
18344: LD_EXP 74
18348: PUSH
18349: LD_VAR 0 2
18353: UNION
18354: ST_TO_ADDR
// end else
18355: GO 18403
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18357: LD_VAR 0 2
18361: PPUSH
18362: CALL_OW 256
18366: PUSH
18367: LD_INT 995
18369: GREATER
18370: PUSH
18371: LD_VAR 0 2
18375: PPUSH
18376: CALL_OW 261
18380: PUSH
18381: LD_INT 99
18383: GREATER
18384: AND
18385: IFFALSE 18403
// brk_cars := brk_cars diff i ;
18387: LD_ADDR_EXP 74
18391: PUSH
18392: LD_EXP 74
18396: PUSH
18397: LD_VAR 0 2
18401: DIFF
18402: ST_TO_ADDR
// end ;
18403: GO 18291
18405: POP
18406: POP
// enable ;
18407: ENABLE
// end ;
18408: PPOPN 2
18410: END
// every 0 0$10 do var zivoty , i ;
18411: GO 18413
18413: DISABLE
18414: LD_INT 0
18416: PPUSH
18417: PPUSH
// begin for i in ( defence diff mastodon ) do
18418: LD_ADDR_VAR 0 2
18422: PUSH
18423: LD_EXP 28
18427: PUSH
18428: LD_INT 1
18430: DIFF
18431: PUSH
18432: FOR_IN
18433: IFFALSE 18546
// begin if GetLives ( i ) < 400 and GetFuel ( i ) < 15 then
18435: LD_VAR 0 2
18439: PPUSH
18440: CALL_OW 256
18444: PUSH
18445: LD_INT 400
18447: LESS
18448: PUSH
18449: LD_VAR 0 2
18453: PPUSH
18454: CALL_OW 261
18458: PUSH
18459: LD_INT 15
18461: LESS
18462: AND
18463: IFFALSE 18498
// begin ComMoveXY ( i , 141 , 72 ) ;
18465: LD_VAR 0 2
18469: PPUSH
18470: LD_INT 141
18472: PPUSH
18473: LD_INT 72
18475: PPUSH
18476: CALL_OW 111
// brk_cars := brk_cars union i ;
18480: LD_ADDR_EXP 74
18484: PUSH
18485: LD_EXP 74
18489: PUSH
18490: LD_VAR 0 2
18494: UNION
18495: ST_TO_ADDR
// end else
18496: GO 18544
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18498: LD_VAR 0 2
18502: PPUSH
18503: CALL_OW 256
18507: PUSH
18508: LD_INT 995
18510: GREATER
18511: PUSH
18512: LD_VAR 0 2
18516: PPUSH
18517: CALL_OW 261
18521: PUSH
18522: LD_INT 99
18524: GREATER
18525: AND
18526: IFFALSE 18544
// brk_cars := brk_cars diff i ;
18528: LD_ADDR_EXP 74
18532: PUSH
18533: LD_EXP 74
18537: PUSH
18538: LD_VAR 0 2
18542: DIFF
18543: ST_TO_ADDR
// end ;
18544: GO 18432
18546: POP
18547: POP
// enable ;
18548: ENABLE
// end ;
18549: PPOPN 2
18551: END
// every 0 0$5 do var zivoty , i ;
18552: GO 18554
18554: DISABLE
18555: LD_INT 0
18557: PPUSH
18558: PPUSH
// begin for i in cargo do
18559: LD_ADDR_VAR 0 2
18563: PUSH
18564: LD_EXP 25
18568: PUSH
18569: FOR_IN
18570: IFFALSE 18653
// begin if GetLives ( i ) < 800 then
18572: LD_VAR 0 2
18576: PPUSH
18577: CALL_OW 256
18581: PUSH
18582: LD_INT 800
18584: LESS
18585: IFFALSE 18620
// begin ComMoveXY ( i , 141 , 72 ) ;
18587: LD_VAR 0 2
18591: PPUSH
18592: LD_INT 141
18594: PPUSH
18595: LD_INT 72
18597: PPUSH
18598: CALL_OW 111
// brk_cars := brk_cars union i ;
18602: LD_ADDR_EXP 74
18606: PUSH
18607: LD_EXP 74
18611: PUSH
18612: LD_VAR 0 2
18616: UNION
18617: ST_TO_ADDR
// end else
18618: GO 18651
// if GetLives ( i ) > 995 then
18620: LD_VAR 0 2
18624: PPUSH
18625: CALL_OW 256
18629: PUSH
18630: LD_INT 995
18632: GREATER
18633: IFFALSE 18651
// brk_cars := brk_cars diff i ;
18635: LD_ADDR_EXP 74
18639: PUSH
18640: LD_EXP 74
18644: PUSH
18645: LD_VAR 0 2
18649: DIFF
18650: ST_TO_ADDR
// end ;
18651: GO 18569
18653: POP
18654: POP
// enable ;
18655: ENABLE
// end ;
18656: PPOPN 2
18658: END
// export rep_cars ; every 0 0$10 do var zivoty , i , tmp_mec , nejhorsi , mytick ;
18659: GO 18661
18661: DISABLE
18662: LD_INT 0
18664: PPUSH
18665: PPUSH
18666: PPUSH
18667: PPUSH
18668: PPUSH
// begin rep_cars := [ ] ;
18669: LD_ADDR_EXP 75
18673: PUSH
18674: EMPTY
18675: ST_TO_ADDR
// zivoty := [ ] ;
18676: LD_ADDR_VAR 0 1
18680: PUSH
18681: EMPTY
18682: ST_TO_ADDR
// for i in UnitFilter ( attack ^ ( defence diff mastodon ) ^ cargo , [ [ f_distxy , 141 , 72 , 20 ] ] ) do
18683: LD_ADDR_VAR 0 2
18687: PUSH
18688: LD_EXP 27
18692: PUSH
18693: LD_EXP 28
18697: PUSH
18698: LD_INT 1
18700: DIFF
18701: ADD
18702: PUSH
18703: LD_EXP 25
18707: ADD
18708: PPUSH
18709: LD_INT 92
18711: PUSH
18712: LD_INT 141
18714: PUSH
18715: LD_INT 72
18717: PUSH
18718: LD_INT 20
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: PUSH
18727: EMPTY
18728: LIST
18729: PPUSH
18730: CALL_OW 72
18734: PUSH
18735: FOR_IN
18736: IFFALSE 18792
// begin if GetLives ( i ) < 1000 then
18738: LD_VAR 0 2
18742: PPUSH
18743: CALL_OW 256
18747: PUSH
18748: LD_INT 1000
18750: LESS
18751: IFFALSE 18790
// begin rep_cars := rep_cars ^ i ;
18753: LD_ADDR_EXP 75
18757: PUSH
18758: LD_EXP 75
18762: PUSH
18763: LD_VAR 0 2
18767: ADD
18768: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
18769: LD_ADDR_VAR 0 1
18773: PUSH
18774: LD_VAR 0 1
18778: PUSH
18779: LD_VAR 0 2
18783: PPUSH
18784: CALL_OW 256
18788: ADD
18789: ST_TO_ADDR
// end ; end ;
18790: GO 18735
18792: POP
18793: POP
// if rep_cars then
18794: LD_EXP 75
18798: IFFALSE 18926
// begin nejhorsi := WorstFromListByList ( rep_cars , zivoty ) ;
18800: LD_ADDR_VAR 0 4
18804: PUSH
18805: LD_EXP 75
18809: PPUSH
18810: LD_VAR 0 1
18814: PPUSH
18815: CALL_OW 78
18819: ST_TO_ADDR
// tmp_mec := mec ;
18820: LD_ADDR_VAR 0 3
18824: PUSH
18825: LD_EXP 22
18829: ST_TO_ADDR
// mec := [ ] ;
18830: LD_ADDR_EXP 22
18834: PUSH
18835: EMPTY
18836: ST_TO_ADDR
// ComExitBuilding ( tmp_mec ) ;
18837: LD_VAR 0 3
18841: PPUSH
18842: CALL_OW 122
// AddComRepairVehicle ( tmp_mec , nejhorsi ) ;
18846: LD_VAR 0 3
18850: PPUSH
18851: LD_VAR 0 4
18855: PPUSH
18856: CALL_OW 189
// mytick := tick + 0 0$9.9 ;
18860: LD_ADDR_VAR 0 5
18864: PUSH
18865: LD_OWVAR 1
18869: PUSH
18870: LD_INT 347
18872: PLUS
18873: ST_TO_ADDR
// while mytick > tick and GetLives ( nejhorsi ) < 1000 do
18874: LD_VAR 0 5
18878: PUSH
18879: LD_OWVAR 1
18883: GREATER
18884: PUSH
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 256
18894: PUSH
18895: LD_INT 1000
18897: LESS
18898: AND
18899: IFFALSE 18910
// wait ( 0 0$1 ) ;
18901: LD_INT 35
18903: PPUSH
18904: CALL_OW 67
18908: GO 18874
// mec := mec union tmp_mec ;
18910: LD_ADDR_EXP 22
18914: PUSH
18915: LD_EXP 22
18919: PUSH
18920: LD_VAR 0 3
18924: UNION
18925: ST_TO_ADDR
// end ; enable ;
18926: ENABLE
// end ; end_of_file
18927: PPOPN 5
18929: END
// every 3 3$12 trigger vsichni_gone do
18930: CALL 19222 0 0
18934: IFFALSE 19077
18936: GO 18938
18938: DISABLE
// begin create_arabs_scout ;
18939: CALL 19786 0 0
// SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
18943: LD_EXP 76
18947: PUSH
18948: LD_EXP 77
18952: PUSH
18953: LD_EXP 78
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: LIST
18962: PPUSH
18963: LD_INT 100
18965: PPUSH
18966: CALL_OW 240
// PlaceUnitArea ( ArScout1 , ar_in_area , false ) ;
18970: LD_EXP 76
18974: PPUSH
18975: LD_INT 2
18977: PPUSH
18978: LD_INT 0
18980: PPUSH
18981: CALL_OW 49
// if difficulty >= 2 then
18985: LD_OWVAR 67
18989: PUSH
18990: LD_INT 2
18992: GREATEREQUAL
18993: IFFALSE 19010
// PlaceUnitArea ( ArScout2 , ar_in_area , false ) ;
18995: LD_EXP 77
18999: PPUSH
19000: LD_INT 2
19002: PPUSH
19003: LD_INT 0
19005: PPUSH
19006: CALL_OW 49
// if difficulty >= 3 then
19010: LD_OWVAR 67
19014: PUSH
19015: LD_INT 3
19017: GREATEREQUAL
19018: IFFALSE 19035
// PlaceUnitArea ( ArScout3 , ar_in_area , false ) ;
19020: LD_EXP 78
19024: PPUSH
19025: LD_INT 2
19027: PPUSH
19028: LD_INT 0
19030: PPUSH
19031: CALL_OW 49
// RaiseSailEvent ( 5001 ) ;
19035: LD_INT 5001
19037: PPUSH
19038: CALL_OW 427
// if difficulty >= 2 then
19042: LD_OWVAR 67
19046: PUSH
19047: LD_INT 2
19049: GREATEREQUAL
19050: IFFALSE 19059
// RaiseSailEvent ( 5002 ) ;
19052: LD_INT 5002
19054: PPUSH
19055: CALL_OW 427
// if difficulty >= 3 then
19059: LD_OWVAR 67
19063: PUSH
19064: LD_INT 3
19066: GREATEREQUAL
19067: IFFALSE 19076
// RaiseSailEvent ( 5003 ) ;
19069: LD_INT 5003
19071: PPUSH
19072: CALL_OW 427
// enable ;
19076: ENABLE
// end ;
19077: END
// every 3 3$12 + 1 1$0 trigger vsichni_gone do
19078: CALL 19222 0 0
19082: IFFALSE 19221
19084: GO 19086
19086: DISABLE
// begin SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
19087: LD_EXP 76
19091: PUSH
19092: LD_EXP 77
19096: PUSH
19097: LD_EXP 78
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: LIST
19106: PPUSH
19107: LD_INT 100
19109: PPUSH
19110: CALL_OW 240
// PlaceUnitArea ( ArScout1 , exit_area , false ) ;
19114: LD_EXP 76
19118: PPUSH
19119: LD_INT 1
19121: PPUSH
19122: LD_INT 0
19124: PPUSH
19125: CALL_OW 49
// if difficulty >= 2 then
19129: LD_OWVAR 67
19133: PUSH
19134: LD_INT 2
19136: GREATEREQUAL
19137: IFFALSE 19154
// PlaceUnitArea ( ArScout2 , exit_area , false ) ;
19139: LD_EXP 77
19143: PPUSH
19144: LD_INT 1
19146: PPUSH
19147: LD_INT 0
19149: PPUSH
19150: CALL_OW 49
// if difficulty >= 3 then
19154: LD_OWVAR 67
19158: PUSH
19159: LD_INT 3
19161: GREATEREQUAL
19162: IFFALSE 19179
// PlaceUnitArea ( ArScout3 , exit_area , false ) ;
19164: LD_EXP 78
19168: PPUSH
19169: LD_INT 1
19171: PPUSH
19172: LD_INT 0
19174: PPUSH
19175: CALL_OW 49
// RaiseSailEvent ( 5051 ) ;
19179: LD_INT 5051
19181: PPUSH
19182: CALL_OW 427
// if difficulty >= 2 then
19186: LD_OWVAR 67
19190: PUSH
19191: LD_INT 2
19193: GREATEREQUAL
19194: IFFALSE 19203
// RaiseSailEvent ( 5052 ) ;
19196: LD_INT 5052
19198: PPUSH
19199: CALL_OW 427
// if difficulty >= 3 then
19203: LD_OWVAR 67
19207: PUSH
19208: LD_INT 3
19210: GREATEREQUAL
19211: IFFALSE 19220
// RaiseSailEvent ( 5053 ) ;
19213: LD_INT 5053
19215: PPUSH
19216: CALL_OW 427
// enable ;
19220: ENABLE
// end ;
19221: END
// export function vsichni_gone ; begin
19222: LD_INT 0
19224: PPUSH
// result := false ;
19225: LD_ADDR_VAR 0 1
19229: PUSH
19230: LD_INT 0
19232: ST_TO_ADDR
// if not UnitFilter ( [ ArScout1 , ArScout2 , ArScout3 ] , [ [ f_ok ] ] ) then
19233: LD_EXP 76
19237: PUSH
19238: LD_EXP 77
19242: PUSH
19243: LD_EXP 78
19247: PUSH
19248: EMPTY
19249: LIST
19250: LIST
19251: LIST
19252: PPUSH
19253: LD_INT 50
19255: PUSH
19256: EMPTY
19257: LIST
19258: PUSH
19259: EMPTY
19260: LIST
19261: PPUSH
19262: CALL_OW 72
19266: NOT
19267: IFFALSE 19277
// result := true ;
19269: LD_ADDR_VAR 0 1
19273: PUSH
19274: LD_INT 1
19276: ST_TO_ADDR
// end ;
19277: LD_VAR 0 1
19281: RET
// export function f_arcar1_in ; begin
19282: LD_INT 0
19284: PPUSH
// while not IsInArea ( ArScout1 , exit_area ) do
19285: LD_EXP 76
19289: PPUSH
19290: LD_INT 1
19292: PPUSH
19293: CALL_OW 308
19297: NOT
19298: IFFALSE 19352
// begin if IsIdle ( arscout1 ) then
19300: LD_EXP 76
19304: PPUSH
19305: CALL_OW 316
19309: IFFALSE 19341
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19311: LD_EXP 76
19315: PPUSH
19316: LD_INT 127
19318: PPUSH
19319: LD_INT 135
19321: PPUSH
19322: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 70 , 134 ) ;
19326: LD_EXP 76
19330: PPUSH
19331: LD_INT 70
19333: PPUSH
19334: LD_INT 134
19336: PPUSH
19337: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19341: LD_EXP 76
19345: PPUSH
19346: CALL 22055 0 1
// end ;
19350: GO 19285
// RemoveUnit ( ArScout1 ) ;
19352: LD_EXP 76
19356: PPUSH
19357: CALL_OW 64
// end ;
19361: LD_VAR 0 1
19365: RET
// export function f_arcar2_in ; begin
19366: LD_INT 0
19368: PPUSH
// while not IsInArea ( ArScout2 , exit_area ) do
19369: LD_EXP 77
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 308
19381: NOT
19382: IFFALSE 19436
// begin if IsIdle ( arscout2 ) then
19384: LD_EXP 77
19388: PPUSH
19389: CALL_OW 316
19393: IFFALSE 19425
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19395: LD_EXP 77
19399: PPUSH
19400: LD_INT 127
19402: PPUSH
19403: LD_INT 135
19405: PPUSH
19406: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 70 , 134 ) ;
19410: LD_EXP 77
19414: PPUSH
19415: LD_INT 70
19417: PPUSH
19418: LD_INT 134
19420: PPUSH
19421: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19425: LD_EXP 77
19429: PPUSH
19430: CALL 22055 0 1
// end ;
19434: GO 19369
// RemoveUnit ( ArScout2 ) ;
19436: LD_EXP 77
19440: PPUSH
19441: CALL_OW 64
// end ;
19445: LD_VAR 0 1
19449: RET
// export function f_arcar3_in ; begin
19450: LD_INT 0
19452: PPUSH
// while not IsInArea ( ArScout3 , exit_area ) do
19453: LD_EXP 78
19457: PPUSH
19458: LD_INT 1
19460: PPUSH
19461: CALL_OW 308
19465: NOT
19466: IFFALSE 19520
// begin if IsIdle ( arscout3 ) then
19468: LD_EXP 78
19472: PPUSH
19473: CALL_OW 316
19477: IFFALSE 19509
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19479: LD_EXP 78
19483: PPUSH
19484: LD_INT 127
19486: PPUSH
19487: LD_INT 135
19489: PPUSH
19490: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 70 , 134 ) ;
19494: LD_EXP 78
19498: PPUSH
19499: LD_INT 70
19501: PPUSH
19502: LD_INT 134
19504: PPUSH
19505: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19509: LD_EXP 78
19513: PPUSH
19514: CALL 22055 0 1
// end ;
19518: GO 19453
// RemoveUnit ( ArScout3 ) ;
19520: LD_EXP 78
19524: PPUSH
19525: CALL_OW 64
// end ;
19529: LD_VAR 0 1
19533: RET
// export function f_arcar1_exit ; begin
19534: LD_INT 0
19536: PPUSH
// while not IsInArea ( ArScout1 , ar_in_area ) do
19537: LD_EXP 76
19541: PPUSH
19542: LD_INT 2
19544: PPUSH
19545: CALL_OW 308
19549: NOT
19550: IFFALSE 19604
// begin if IsIdle ( arscout1 ) then
19552: LD_EXP 76
19556: PPUSH
19557: CALL_OW 316
19561: IFFALSE 19593
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19563: LD_EXP 76
19567: PPUSH
19568: LD_INT 127
19570: PPUSH
19571: LD_INT 135
19573: PPUSH
19574: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 185 , 134 ) ;
19578: LD_EXP 76
19582: PPUSH
19583: LD_INT 185
19585: PPUSH
19586: LD_INT 134
19588: PPUSH
19589: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19593: LD_EXP 76
19597: PPUSH
19598: CALL 22055 0 1
// end ;
19602: GO 19537
// RemoveUnit ( ArScout1 ) ;
19604: LD_EXP 76
19608: PPUSH
19609: CALL_OW 64
// end ;
19613: LD_VAR 0 1
19617: RET
// export function f_arcar2_exit ; begin
19618: LD_INT 0
19620: PPUSH
// while not IsInArea ( ArScout2 , ar_in_area ) do
19621: LD_EXP 77
19625: PPUSH
19626: LD_INT 2
19628: PPUSH
19629: CALL_OW 308
19633: NOT
19634: IFFALSE 19688
// begin if IsIdle ( arscout2 ) then
19636: LD_EXP 77
19640: PPUSH
19641: CALL_OW 316
19645: IFFALSE 19677
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19647: LD_EXP 77
19651: PPUSH
19652: LD_INT 127
19654: PPUSH
19655: LD_INT 135
19657: PPUSH
19658: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 185 , 134 ) ;
19662: LD_EXP 77
19666: PPUSH
19667: LD_INT 185
19669: PPUSH
19670: LD_INT 134
19672: PPUSH
19673: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19677: LD_EXP 77
19681: PPUSH
19682: CALL 22055 0 1
// end ;
19686: GO 19621
// RemoveUnit ( ArScout2 ) ;
19688: LD_EXP 77
19692: PPUSH
19693: CALL_OW 64
// end ;
19697: LD_VAR 0 1
19701: RET
// export function f_arcar3_exit ; begin
19702: LD_INT 0
19704: PPUSH
// while not IsInArea ( ArScout3 , ar_in_area ) do
19705: LD_EXP 78
19709: PPUSH
19710: LD_INT 2
19712: PPUSH
19713: CALL_OW 308
19717: NOT
19718: IFFALSE 19772
// begin if IsIdle ( arscout3 ) then
19720: LD_EXP 78
19724: PPUSH
19725: CALL_OW 316
19729: IFFALSE 19761
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19731: LD_EXP 78
19735: PPUSH
19736: LD_INT 127
19738: PPUSH
19739: LD_INT 135
19741: PPUSH
19742: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 185 , 134 ) ;
19746: LD_EXP 78
19750: PPUSH
19751: LD_INT 185
19753: PPUSH
19754: LD_INT 134
19756: PPUSH
19757: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19761: LD_EXP 78
19765: PPUSH
19766: CALL 22055 0 1
// end ;
19770: GO 19705
// RemoveUnit ( ArScout3 ) ;
19772: LD_EXP 78
19776: PPUSH
19777: CALL_OW 64
// end ;
19781: LD_VAR 0 1
19785: RET
// export ArScout1 , ArScout2 , ArScout3 , ArSc1 , ArSc2 , ArSc3 ; export function create_arabs_scout ; begin
19786: LD_INT 0
19788: PPUSH
// InitUc ;
19789: CALL_OW 18
// InitVc ;
19793: CALL_OW 20
// uc_side := arabians ;
19797: LD_ADDR_OWVAR 20
19801: PUSH
19802: LD_EXP 3
19806: ST_TO_ADDR
// uc_nation := nation_arabian ;
19807: LD_ADDR_OWVAR 21
19811: PUSH
19812: LD_INT 2
19814: ST_TO_ADDR
// uc_direction := 4 ;
19815: LD_ADDR_OWVAR 24
19819: PUSH
19820: LD_INT 4
19822: ST_TO_ADDR
// vc_control := control_manual ;
19823: LD_ADDR_OWVAR 38
19827: PUSH
19828: LD_INT 1
19830: ST_TO_ADDR
// vc_engine := engine_combustion ;
19831: LD_ADDR_OWVAR 39
19835: PUSH
19836: LD_INT 1
19838: ST_TO_ADDR
// vc_fuel_battery := 100 ;
19839: LD_ADDR_OWVAR 41
19843: PUSH
19844: LD_INT 100
19846: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19847: LD_ADDR_OWVAR 37
19851: PUSH
19852: LD_INT 14
19854: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
19855: LD_ADDR_OWVAR 40
19859: PUSH
19860: LD_INT 26
19862: ST_TO_ADDR
// if not ArScout1 or IsDead ( ArScout1 ) then
19863: LD_EXP 76
19867: NOT
19868: PUSH
19869: LD_EXP 76
19873: PPUSH
19874: CALL_OW 301
19878: OR
19879: IFFALSE 19891
// ArScout1 := CreateVehicle ;
19881: LD_ADDR_EXP 76
19885: PUSH
19886: CALL_OW 45
19890: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19891: LD_ADDR_OWVAR 37
19895: PUSH
19896: LD_INT 14
19898: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
19899: LD_ADDR_OWVAR 40
19903: PUSH
19904: LD_INT 25
19906: ST_TO_ADDR
// if not ArScout2 or IsDead ( ArScout2 ) then
19907: LD_EXP 77
19911: NOT
19912: PUSH
19913: LD_EXP 77
19917: PPUSH
19918: CALL_OW 301
19922: OR
19923: IFFALSE 19935
// ArScout2 := CreateVehicle ;
19925: LD_ADDR_EXP 77
19929: PUSH
19930: CALL_OW 45
19934: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19935: LD_ADDR_OWVAR 37
19939: PUSH
19940: LD_INT 14
19942: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
19943: LD_ADDR_OWVAR 40
19947: PUSH
19948: LD_INT 25
19950: ST_TO_ADDR
// if not ArScout3 or IsDead ( ArScout3 ) then
19951: LD_EXP 78
19955: NOT
19956: PUSH
19957: LD_EXP 78
19961: PPUSH
19962: CALL_OW 301
19966: OR
19967: IFFALSE 19979
// ArScout3 := CreateVehicle ;
19969: LD_ADDR_EXP 78
19973: PUSH
19974: CALL_OW 45
19978: ST_TO_ADDR
// InitHc ;
19979: CALL_OW 19
// PrepareMechanic ( 0 , 5 ) ;
19983: LD_INT 0
19985: PPUSH
19986: LD_INT 5
19988: PPUSH
19989: CALL_OW 383
// if not ArSc1 or IsDead ( ArSc1 ) then
19993: LD_EXP 79
19997: NOT
19998: PUSH
19999: LD_EXP 79
20003: PPUSH
20004: CALL_OW 301
20008: OR
20009: IFFALSE 20021
// ArSc1 := CreateHuman ;
20011: LD_ADDR_EXP 79
20015: PUSH
20016: CALL_OW 44
20020: ST_TO_ADDR
// if not ArSc2 or IsDead ( ArSc2 ) then
20021: LD_EXP 80
20025: NOT
20026: PUSH
20027: LD_EXP 80
20031: PPUSH
20032: CALL_OW 301
20036: OR
20037: IFFALSE 20049
// ArSc2 := CreateHuman ;
20039: LD_ADDR_EXP 80
20043: PUSH
20044: CALL_OW 44
20048: ST_TO_ADDR
// if not ArSc3 or IsDead ( ArSc3 ) then
20049: LD_EXP 81
20053: NOT
20054: PUSH
20055: LD_EXP 81
20059: PPUSH
20060: CALL_OW 301
20064: OR
20065: IFFALSE 20077
// ArSc3 := CreateHuman ;
20067: LD_ADDR_EXP 81
20071: PUSH
20072: CALL_OW 44
20076: ST_TO_ADDR
// PlaceHumanInUnit ( ArSc1 , ArScout1 ) ;
20077: LD_EXP 79
20081: PPUSH
20082: LD_EXP 76
20086: PPUSH
20087: CALL_OW 52
// PlaceHumanInUnit ( ArSc2 , ArScout2 ) ;
20091: LD_EXP 80
20095: PPUSH
20096: LD_EXP 77
20100: PPUSH
20101: CALL_OW 52
// PlaceHumanInUnit ( ArSc3 , ArScout3 ) ;
20105: LD_EXP 81
20109: PPUSH
20110: LD_EXP 78
20114: PPUSH
20115: CALL_OW 52
// end ; end_of_file
20119: LD_VAR 0 1
20123: RET
// on UnitDestroyed ( un ) do begin if un = Stevens then
20124: LD_VAR 0 1
20128: PUSH
20129: LD_EXP 59
20133: EQUAL
20134: IFFALSE 20140
// SA_KillStevens ;
20136: CALL 25750 0 0
// if un in rulive then
20140: LD_VAR 0 1
20144: PUSH
20145: LD_EXP 6
20149: IN
20150: IFFALSE 20168
// rulive := rulive diff un ;
20152: LD_ADDR_EXP 6
20156: PUSH
20157: LD_EXP 6
20161: PUSH
20162: LD_VAR 0 1
20166: DIFF
20167: ST_TO_ADDR
// if un in apemans then
20168: LD_VAR 0 1
20172: PUSH
20173: LD_EXP 7
20177: IN
20178: IFFALSE 20196
// apemans := apemans diff un ;
20180: LD_ADDR_EXP 7
20184: PUSH
20185: LD_EXP 7
20189: PUSH
20190: LD_VAR 0 1
20194: DIFF
20195: ST_TO_ADDR
// if un = Burlak then
20196: LD_VAR 0 1
20200: PUSH
20201: LD_EXP 50
20205: EQUAL
20206: IFFALSE 20221
// if canlost then
20208: LD_EXP 47
20212: IFFALSE 20221
// YouLost ( Burlak ) ;
20214: LD_STRING Burlak
20216: PPUSH
20217: CALL_OW 104
// if un = depot then
20221: LD_VAR 0 1
20225: PUSH
20226: LD_EXP 14
20230: EQUAL
20231: IFFALSE 20241
// depot := 0 ;
20233: LD_ADDR_EXP 14
20237: PUSH
20238: LD_INT 0
20240: ST_TO_ADDR
// defence := defence diff un ;
20241: LD_ADDR_EXP 28
20245: PUSH
20246: LD_EXP 28
20250: PUSH
20251: LD_VAR 0 1
20255: DIFF
20256: ST_TO_ADDR
// cargo := cargo diff un ;
20257: LD_ADDR_EXP 25
20261: PUSH
20262: LD_EXP 25
20266: PUSH
20267: LD_VAR 0 1
20271: DIFF
20272: ST_TO_ADDR
// attack := attack diff un ;
20273: LD_ADDR_EXP 27
20277: PUSH
20278: LD_EXP 27
20282: PUSH
20283: LD_VAR 0 1
20287: DIFF
20288: ST_TO_ADDR
// scout := scout diff un ;
20289: LD_ADDR_EXP 26
20293: PUSH
20294: LD_EXP 26
20298: PUSH
20299: LD_VAR 0 1
20303: DIFF
20304: ST_TO_ADDR
// remote := remote diff un ;
20305: LD_ADDR_EXP 29
20309: PUSH
20310: LD_EXP 29
20314: PUSH
20315: LD_VAR 0 1
20319: DIFF
20320: ST_TO_ADDR
// brk_cars := brk_cars diff un ;
20321: LD_ADDR_EXP 74
20325: PUSH
20326: LD_EXP 74
20330: PUSH
20331: LD_VAR 0 1
20335: DIFF
20336: ST_TO_ADDR
// rep_cars := rep_cars diff un ;
20337: LD_ADDR_EXP 75
20341: PUSH
20342: LD_EXP 75
20346: PUSH
20347: LD_VAR 0 1
20351: DIFF
20352: ST_TO_ADDR
// opravit := opravit diff un ;
20353: LD_ADDR_EXP 73
20357: PUSH
20358: LD_EXP 73
20362: PUSH
20363: LD_VAR 0 1
20367: DIFF
20368: ST_TO_ADDR
// sol := sol diff un ;
20369: LD_ADDR_EXP 19
20373: PUSH
20374: LD_EXP 19
20378: PUSH
20379: LD_VAR 0 1
20383: DIFF
20384: ST_TO_ADDR
// eng := eng diff un ;
20385: LD_ADDR_EXP 23
20389: PUSH
20390: LD_EXP 23
20394: PUSH
20395: LD_VAR 0 1
20399: DIFF
20400: ST_TO_ADDR
// mec := mec diff un ;
20401: LD_ADDR_EXP 22
20405: PUSH
20406: LD_EXP 22
20410: PUSH
20411: LD_VAR 0 1
20415: DIFF
20416: ST_TO_ADDR
// sci := sci diff un ;
20417: LD_ADDR_EXP 21
20421: PUSH
20422: LD_EXP 21
20426: PUSH
20427: LD_VAR 0 1
20431: DIFF
20432: ST_TO_ADDR
// mor := mor diff un ;
20433: LD_ADDR_EXP 20
20437: PUSH
20438: LD_EXP 20
20442: PUSH
20443: LD_VAR 0 1
20447: DIFF
20448: ST_TO_ADDR
// case un of dep1 :
20449: LD_VAR 0 1
20453: PUSH
20454: LD_EXP 41
20458: DOUBLE
20459: EQUAL
20460: IFTRUE 20464
20462: GO 20475
20464: POP
// dep1 := 0 ; lab1 :
20465: LD_ADDR_EXP 41
20469: PUSH
20470: LD_INT 0
20472: ST_TO_ADDR
20473: GO 20518
20475: LD_EXP 42
20479: DOUBLE
20480: EQUAL
20481: IFTRUE 20485
20483: GO 20496
20485: POP
// lab1 := 0 ; fact1 :
20486: LD_ADDR_EXP 42
20490: PUSH
20491: LD_INT 0
20493: ST_TO_ADDR
20494: GO 20518
20496: LD_EXP 40
20500: DOUBLE
20501: EQUAL
20502: IFTRUE 20506
20504: GO 20517
20506: POP
// fact1 := 0 ; end ;
20507: LD_ADDR_EXP 40
20511: PUSH
20512: LD_INT 0
20514: ST_TO_ADDR
20515: GO 20518
20517: POP
// fort := fort diff un ;
20518: LD_ADDR_EXP 43
20522: PUSH
20523: LD_EXP 43
20527: PUSH
20528: LD_VAR 0 1
20532: DIFF
20533: ST_TO_ADDR
// end ;
20534: PPOPN 1
20536: END
// on ApemanTamed ( ape , sci ) do begin MyHint ( ApemenUsing ) ;
20537: LD_STRING ApemenUsing
20539: PPUSH
20540: CALL 25518 0 1
// apemans := apemans diff ape ;
20544: LD_ADDR_EXP 7
20548: PUSH
20549: LD_EXP 7
20553: PUSH
20554: LD_VAR 0 1
20558: DIFF
20559: ST_TO_ADDR
// if not first_apeman_tamed then
20560: LD_EXP 45
20564: NOT
20565: IFFALSE 20571
// DApeTame ;
20567: CALL 4730 0 0
// end ;
20571: PPOPN 2
20573: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = you then
20574: LD_VAR 0 2
20578: PPUSH
20579: CALL_OW 255
20583: PUSH
20584: LD_EXP 1
20588: EQUAL
20589: IFFALSE 20658
// begin if tech = tech_ApeLang then
20591: LD_VAR 0 1
20595: PUSH
20596: LD_INT 1
20598: EQUAL
20599: IFFALSE 20618
// begin MyHint ( ApemenTaming ) ;
20601: LD_STRING ApemenTaming
20603: PPUSH
20604: CALL 25518 0 1
// if dialogy then
20608: LD_EXP 46
20612: IFFALSE 20618
// DApeLangCompl ;
20614: CALL 4565 0 0
// end ; if tech = tech_ApePsych then
20618: LD_VAR 0 1
20622: PUSH
20623: LD_INT 2
20625: EQUAL
20626: IFFALSE 20638
// begin if dialogy then
20628: LD_EXP 46
20632: IFFALSE 20638
// DApeWorkCompl ;
20634: CALL 5124 0 0
// end ; if tech = tech_ApeAgres then
20638: LD_VAR 0 1
20642: PUSH
20643: LD_INT 11
20645: EQUAL
20646: IFFALSE 20658
// begin if dialogy then
20648: LD_EXP 46
20652: IFFALSE 20658
// DApeSolCompl ;
20654: CALL 5232 0 0
// end ; end ; end ;
20658: PPOPN 2
20660: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
20661: LD_VAR 0 1
20665: PPUSH
20666: CALL_OW 255
20670: PUSH
20671: LD_EXP 1
20675: EQUAL
20676: IFFALSE 20712
// begin if not depot and GetBType ( build ) = b_depot then
20678: LD_EXP 14
20682: NOT
20683: PUSH
20684: LD_VAR 0 1
20688: PPUSH
20689: CALL_OW 266
20693: PUSH
20694: LD_INT 0
20696: EQUAL
20697: AND
20698: IFFALSE 20710
// depot := build ;
20700: LD_ADDR_EXP 14
20704: PUSH
20705: LD_VAR 0 1
20709: ST_TO_ADDR
// end else
20710: GO 20873
// begin if GetBType ( build ) in [ b_depot , b_warehouse ] then
20712: LD_VAR 0 1
20716: PPUSH
20717: CALL_OW 266
20721: PUSH
20722: LD_INT 0
20724: PUSH
20725: LD_INT 1
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: IN
20732: IFFALSE 20748
// dep1 := build + 0 ;
20734: LD_ADDR_EXP 41
20738: PUSH
20739: LD_VAR 0 1
20743: PUSH
20744: LD_INT 0
20746: PLUS
20747: ST_TO_ADDR
// if GetBType ( build ) in [ b_workshop , b_factory ] then
20748: LD_VAR 0 1
20752: PPUSH
20753: CALL_OW 266
20757: PUSH
20758: LD_INT 2
20760: PUSH
20761: LD_INT 3
20763: PUSH
20764: EMPTY
20765: LIST
20766: LIST
20767: IN
20768: IFFALSE 20784
// fact1 := build + 0 ;
20770: LD_ADDR_EXP 40
20774: PUSH
20775: LD_VAR 0 1
20779: PUSH
20780: LD_INT 0
20782: PLUS
20783: ST_TO_ADDR
// if GetBType ( build ) in [ b_lab , b_lab_half , b_lab_full ] then
20784: LD_VAR 0 1
20788: PPUSH
20789: CALL_OW 266
20793: PUSH
20794: LD_INT 6
20796: PUSH
20797: LD_INT 7
20799: PUSH
20800: LD_INT 8
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: LIST
20807: IN
20808: IFFALSE 20824
// lab1 := build + 0 ;
20810: LD_ADDR_EXP 42
20814: PUSH
20815: LD_VAR 0 1
20819: PUSH
20820: LD_INT 0
20822: PLUS
20823: ST_TO_ADDR
// if GetBType ( build ) in [ b_breastwork , b_bunker , b_armoury , b_barracks ] then
20824: LD_VAR 0 1
20828: PPUSH
20829: CALL_OW 266
20833: PUSH
20834: LD_INT 31
20836: PUSH
20837: LD_INT 32
20839: PUSH
20840: LD_INT 4
20842: PUSH
20843: LD_INT 5
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: LIST
20850: LIST
20851: IN
20852: IFFALSE 20873
// fort := fort ^ [ build ] ;
20854: LD_ADDR_EXP 43
20858: PUSH
20859: LD_EXP 43
20863: PUSH
20864: LD_VAR 0 1
20868: PUSH
20869: EMPTY
20870: LIST
20871: ADD
20872: ST_TO_ADDR
// end ; end ;
20873: PPOPN 1
20875: END
// on UpgradeComplete ( build ) do var ar , i ;
20876: LD_INT 0
20878: PPUSH
20879: PPUSH
// begin if GetSide ( build ) = arabians then
20880: LD_VAR 0 1
20884: PPUSH
20885: CALL_OW 255
20889: PUSH
20890: LD_EXP 3
20894: EQUAL
20895: IFFALSE 21033
// begin if GetBType ( build ) = b_barracks then
20897: LD_VAR 0 1
20901: PPUSH
20902: CALL_OW 266
20906: PUSH
20907: LD_INT 5
20909: EQUAL
20910: IFFALSE 21033
// begin sol := sol diff ar ;
20912: LD_ADDR_EXP 19
20916: PUSH
20917: LD_EXP 19
20921: PUSH
20922: LD_VAR 0 2
20926: DIFF
20927: ST_TO_ADDR
// mor := mor diff ar ;
20928: LD_ADDR_EXP 20
20932: PUSH
20933: LD_EXP 20
20937: PUSH
20938: LD_VAR 0 2
20942: DIFF
20943: ST_TO_ADDR
// for i in fort do
20944: LD_ADDR_VAR 0 3
20948: PUSH
20949: LD_EXP 43
20953: PUSH
20954: FOR_IN
20955: IFFALSE 20980
// ar := ar ^ UnitsInside ( i ) ;
20957: LD_ADDR_VAR 0 2
20961: PUSH
20962: LD_VAR 0 2
20966: PUSH
20967: LD_VAR 0 3
20971: PPUSH
20972: CALL_OW 313
20976: ADD
20977: ST_TO_ADDR
20978: GO 20954
20980: POP
20981: POP
// ComEnterUnit ( ar , build ) ;
20982: LD_VAR 0 2
20986: PPUSH
20987: LD_VAR 0 1
20991: PPUSH
20992: CALL_OW 120
// AddComChangeProfession ( ar , class_mortar ) ;
20996: LD_VAR 0 2
21000: PPUSH
21001: LD_INT 8
21003: PPUSH
21004: CALL_OW 183
// AddComExitBuilding ( ar ) ;
21008: LD_VAR 0 2
21012: PPUSH
21013: CALL_OW 182
// sol := sol union ar ;
21017: LD_ADDR_EXP 19
21021: PUSH
21022: LD_EXP 19
21026: PUSH
21027: LD_VAR 0 2
21031: UNION
21032: ST_TO_ADDR
// end ; end ; if Getside ( build ) = you then
21033: LD_VAR 0 1
21037: PPUSH
21038: CALL_OW 255
21042: PUSH
21043: LD_EXP 1
21047: EQUAL
21048: IFFALSE 21072
// begin if GetBType ( build ) = b_factory then
21050: LD_VAR 0 1
21054: PPUSH
21055: CALL_OW 266
21059: PUSH
21060: LD_INT 3
21062: EQUAL
21063: IFFALSE 21072
// begin MyHint ( Tracks ) ;
21065: LD_STRING Tracks
21067: PPUSH
21068: CALL 25518 0 1
// end ; end ; end ;
21072: PPOPN 3
21074: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = arabians then
21075: LD_VAR 0 3
21079: PUSH
21080: LD_EXP 3
21084: EQUAL
21085: IFFALSE 21199
// begin defence := defence diff vehold ;
21087: LD_ADDR_EXP 28
21091: PUSH
21092: LD_EXP 28
21096: PUSH
21097: LD_VAR 0 2
21101: DIFF
21102: ST_TO_ADDR
// cargo := cargo diff vehold ;
21103: LD_ADDR_EXP 25
21107: PUSH
21108: LD_EXP 25
21112: PUSH
21113: LD_VAR 0 2
21117: DIFF
21118: ST_TO_ADDR
// attack := attack diff vehold ;
21119: LD_ADDR_EXP 27
21123: PUSH
21124: LD_EXP 27
21128: PUSH
21129: LD_VAR 0 2
21133: DIFF
21134: ST_TO_ADDR
// scout := scout diff vehold ;
21135: LD_ADDR_EXP 26
21139: PUSH
21140: LD_EXP 26
21144: PUSH
21145: LD_VAR 0 2
21149: DIFF
21150: ST_TO_ADDR
// remote := remote diff vehold ;
21151: LD_ADDR_EXP 29
21155: PUSH
21156: LD_EXP 29
21160: PUSH
21161: LD_VAR 0 2
21165: DIFF
21166: ST_TO_ADDR
// brk_cars := brk_cars diff vehold ;
21167: LD_ADDR_EXP 74
21171: PUSH
21172: LD_EXP 74
21176: PUSH
21177: LD_VAR 0 2
21181: DIFF
21182: ST_TO_ADDR
// rep_cars := rep_cars diff vehold ;
21183: LD_ADDR_EXP 75
21187: PUSH
21188: LD_EXP 75
21192: PUSH
21193: LD_VAR 0 2
21197: DIFF
21198: ST_TO_ADDR
// end ; end ;
21199: PPOPN 4
21201: END
// on BuildingCaptured ( build , origside , eng ) do begin opravit := opravit diff build ;
21202: LD_ADDR_EXP 73
21206: PUSH
21207: LD_EXP 73
21211: PUSH
21212: LD_VAR 0 1
21216: DIFF
21217: ST_TO_ADDR
// case build of dep1 :
21218: LD_VAR 0 1
21222: PUSH
21223: LD_EXP 41
21227: DOUBLE
21228: EQUAL
21229: IFTRUE 21233
21231: GO 21244
21233: POP
// dep1 := 0 ; lab1 :
21234: LD_ADDR_EXP 41
21238: PUSH
21239: LD_INT 0
21241: ST_TO_ADDR
21242: GO 21287
21244: LD_EXP 42
21248: DOUBLE
21249: EQUAL
21250: IFTRUE 21254
21252: GO 21265
21254: POP
// lab1 := 0 ; fact1 :
21255: LD_ADDR_EXP 42
21259: PUSH
21260: LD_INT 0
21262: ST_TO_ADDR
21263: GO 21287
21265: LD_EXP 40
21269: DOUBLE
21270: EQUAL
21271: IFTRUE 21275
21273: GO 21286
21275: POP
// fact1 := 0 ; end ;
21276: LD_ADDR_EXP 40
21280: PUSH
21281: LD_INT 0
21283: ST_TO_ADDR
21284: GO 21287
21286: POP
// fort := fort diff build ;
21287: LD_ADDR_EXP 43
21291: PUSH
21292: LD_EXP 43
21296: PUSH
21297: LD_VAR 0 1
21301: DIFF
21302: ST_TO_ADDR
// end ;
21303: PPOPN 3
21305: END
// on VehicleConstructed ( veh , fact ) do var i , sc , a , mt ;
21306: LD_INT 0
21308: PPUSH
21309: PPUSH
21310: PPUSH
21311: PPUSH
// begin if GetSide ( fact ) = arabians then
21312: LD_VAR 0 2
21316: PPUSH
21317: CALL_OW 255
21321: PUSH
21322: LD_EXP 3
21326: EQUAL
21327: IFFALSE 21730
// begin if to_defence then
21329: LD_EXP 30
21333: IFFALSE 21351
// begin defence := defence union veh ;
21335: LD_ADDR_EXP 28
21339: PUSH
21340: LD_EXP 28
21344: PUSH
21345: LD_VAR 0 1
21349: UNION
21350: ST_TO_ADDR
// end ; if to_remote then
21351: LD_EXP 34
21355: IFFALSE 21373
// begin remote := remote union veh ;
21357: LD_ADDR_EXP 29
21361: PUSH
21362: LD_EXP 29
21366: PUSH
21367: LD_VAR 0 1
21371: UNION
21372: ST_TO_ADDR
// end ; if to_cargo then
21373: LD_EXP 33
21377: IFFALSE 21395
// begin cargo := cargo union veh ;
21379: LD_ADDR_EXP 25
21383: PUSH
21384: LD_EXP 25
21388: PUSH
21389: LD_VAR 0 1
21393: UNION
21394: ST_TO_ADDR
// end ; if to_attack then
21395: LD_EXP 31
21399: IFFALSE 21417
// begin attack := attack union veh ;
21401: LD_ADDR_EXP 27
21405: PUSH
21406: LD_EXP 27
21410: PUSH
21411: LD_VAR 0 1
21415: UNION
21416: ST_TO_ADDR
// end ; if to_scout then
21417: LD_EXP 32
21421: IFFALSE 21439
// begin scout := scout union veh ;
21423: LD_ADDR_EXP 26
21427: PUSH
21428: LD_EXP 26
21432: PUSH
21433: LD_VAR 0 1
21437: UNION
21438: ST_TO_ADDR
// end ; to_remote := false ;
21439: LD_ADDR_EXP 34
21443: PUSH
21444: LD_INT 0
21446: ST_TO_ADDR
// to_cargo := false ;
21447: LD_ADDR_EXP 33
21451: PUSH
21452: LD_INT 0
21454: ST_TO_ADDR
// to_scout := false ;
21455: LD_ADDR_EXP 32
21459: PUSH
21460: LD_INT 0
21462: ST_TO_ADDR
// to_attack := false ;
21463: LD_ADDR_EXP 31
21467: PUSH
21468: LD_INT 0
21470: ST_TO_ADDR
// to_defence := false ;
21471: LD_ADDR_EXP 30
21475: PUSH
21476: LD_INT 0
21478: ST_TO_ADDR
// if GetControl ( veh ) = control_remote then
21479: LD_VAR 0 1
21483: PPUSH
21484: CALL_OW 263
21488: PUSH
21489: LD_INT 2
21491: EQUAL
21492: IFFALSE 21508
// ComLinkTo ( veh , rmec ) ;
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_EXP 24
21503: PPUSH
21504: CALL_OW 135
// mt := tick + 0 0$7 ;
21508: LD_ADDR_VAR 0 6
21512: PUSH
21513: LD_OWVAR 1
21517: PUSH
21518: LD_INT 245
21520: PLUS
21521: ST_TO_ADDR
// if veh in defence then
21522: LD_VAR 0 1
21526: PUSH
21527: LD_EXP 28
21531: IN
21532: IFFALSE 21584
// begin ComMoveToArea ( veh , for_cars_defence ) ;
21534: LD_VAR 0 1
21538: PPUSH
21539: LD_INT 17
21541: PPUSH
21542: CALL_OW 113
// while not IsInArea ( veh , for_cars_defence ) and mt > tick do
21546: LD_VAR 0 1
21550: PPUSH
21551: LD_INT 17
21553: PPUSH
21554: CALL_OW 308
21558: NOT
21559: PUSH
21560: LD_VAR 0 6
21564: PUSH
21565: LD_OWVAR 1
21569: GREATER
21570: AND
21571: IFFALSE 21582
// wait ( 0 0$1 ) ;
21573: LD_INT 35
21575: PPUSH
21576: CALL_OW 67
21580: GO 21546
// end else
21582: GO 21632
// begin ComMoveToArea ( veh , for_cars ) ;
21584: LD_VAR 0 1
21588: PPUSH
21589: LD_INT 14
21591: PPUSH
21592: CALL_OW 113
// while not IsInArea ( veh , for_cars ) and mt > tick do
21596: LD_VAR 0 1
21600: PPUSH
21601: LD_INT 14
21603: PPUSH
21604: CALL_OW 308
21608: NOT
21609: PUSH
21610: LD_VAR 0 6
21614: PUSH
21615: LD_OWVAR 1
21619: GREATER
21620: AND
21621: IFFALSE 21632
// wait ( 0 0$1 ) ;
21623: LD_INT 35
21625: PPUSH
21626: CALL_OW 67
21630: GO 21596
// end ; a := UnitsInside ( veh ) ;
21632: LD_ADDR_VAR 0 5
21636: PUSH
21637: LD_VAR 0 1
21641: PPUSH
21642: CALL_OW 313
21646: ST_TO_ADDR
// ComRemember ( veh ) ;
21647: LD_VAR 0 1
21651: PPUSH
21652: CALL_OW 143
// ComExitVehicle ( a ) ;
21656: LD_VAR 0 5
21660: PPUSH
21661: CALL_OW 121
// AddComEnterUnit ( a , fact1 ) ;
21665: LD_VAR 0 5
21669: PPUSH
21670: LD_EXP 40
21674: PPUSH
21675: CALL_OW 180
// if GetWeapon ( veh ) <> ar_radar then
21679: LD_VAR 0 1
21683: PPUSH
21684: CALL_OW 264
21688: PUSH
21689: LD_INT 30
21691: NONEQUAL
21692: IFFALSE 21713
// find_drivers ( veh , sol , false ) else
21694: LD_VAR 0 1
21698: PPUSH
21699: LD_EXP 19
21703: PPUSH
21704: LD_INT 0
21706: PPUSH
21707: CALL 24026 0 3
21711: GO 21730
// find_drivers ( veh , mec , true ) ;
21713: LD_VAR 0 1
21717: PPUSH
21718: LD_EXP 22
21722: PPUSH
21723: LD_INT 1
21725: PPUSH
21726: CALL 24026 0 3
// end ; end ;
21730: PPOPN 6
21732: END
// on SailEvent ( num ) do begin case num of vodni_utok :
21733: LD_VAR 0 1
21737: PUSH
21738: LD_EXP 35
21742: DOUBLE
21743: EQUAL
21744: IFTRUE 21748
21746: GO 21755
21748: POP
// begin f_vodni_utok ;
21749: CALL 15946 0 0
// end ; normal1_utok :
21753: GO 21914
21755: LD_EXP 36
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21772
21765: POP
// begin f_normal1_utok ;
21766: CALL 16336 0 0
// end ; normal2_utok :
21770: GO 21914
21772: LD_EXP 37
21776: DOUBLE
21777: EQUAL
21778: IFTRUE 21782
21780: GO 21789
21782: POP
// begin f_normal2_utok ;
21783: CALL 16572 0 0
// end ; normal3_utok :
21787: GO 21914
21789: LD_EXP 38
21793: DOUBLE
21794: EQUAL
21795: IFTRUE 21799
21797: GO 21806
21799: POP
// begin f_normal3_utok ;
21800: CALL 16808 0 0
// end ; normal4_utok :
21804: GO 21914
21806: LD_EXP 39
21810: DOUBLE
21811: EQUAL
21812: IFTRUE 21816
21814: GO 21823
21816: POP
// begin f_normal4_utok ;
21817: CALL 17165 0 0
// end ; 5001 :
21821: GO 21914
21823: LD_INT 5001
21825: DOUBLE
21826: EQUAL
21827: IFTRUE 21831
21829: GO 21838
21831: POP
// begin f_arcar1_in ;
21832: CALL 19282 0 0
// end ; 5002 :
21836: GO 21914
21838: LD_INT 5002
21840: DOUBLE
21841: EQUAL
21842: IFTRUE 21846
21844: GO 21853
21846: POP
// begin f_arcar2_in ;
21847: CALL 19366 0 0
// end ; 5003 :
21851: GO 21914
21853: LD_INT 5003
21855: DOUBLE
21856: EQUAL
21857: IFTRUE 21861
21859: GO 21868
21861: POP
// begin f_arcar3_in ;
21862: CALL 19450 0 0
// end ; 5051 :
21866: GO 21914
21868: LD_INT 5051
21870: DOUBLE
21871: EQUAL
21872: IFTRUE 21876
21874: GO 21883
21876: POP
// begin f_arcar1_exit ;
21877: CALL 19534 0 0
// end ; 5052 :
21881: GO 21914
21883: LD_INT 5052
21885: DOUBLE
21886: EQUAL
21887: IFTRUE 21891
21889: GO 21898
21891: POP
// begin f_arcar2_exit ;
21892: CALL 19618 0 0
// end ; 5053 :
21896: GO 21914
21898: LD_INT 5053
21900: DOUBLE
21901: EQUAL
21902: IFTRUE 21906
21904: GO 21913
21906: POP
// begin f_arcar3_exit ;
21907: CALL 19702 0 0
// end ; end ;
21911: GO 21914
21913: POP
// end ;
21914: PPOPN 1
21916: END
// export DU_units ; on DestinationUnreachable ( un ) do begin DU_units := DU_units union un ;
21917: LD_ADDR_EXP 82
21921: PUSH
21922: LD_EXP 82
21926: PUSH
21927: LD_VAR 0 1
21931: UNION
21932: ST_TO_ADDR
// SetTag ( un + 10000 , 2 ) ;
21933: LD_VAR 0 1
21937: PUSH
21938: LD_INT 10000
21940: PLUS
21941: PPUSH
21942: LD_INT 2
21944: PPUSH
21945: CALL_OW 109
// end ;
21949: PPOPN 1
21951: END
// every 0 0$2 trigger DU_units do var i , a ;
21952: LD_EXP 82
21956: IFFALSE 22052
21958: GO 21960
21960: DISABLE
21961: LD_INT 0
21963: PPUSH
21964: PPUSH
// begin for i in DU_units do
21965: LD_ADDR_VAR 0 1
21969: PUSH
21970: LD_EXP 82
21974: PUSH
21975: FOR_IN
21976: IFFALSE 22049
// begin a := GetTag ( i + 10000 ) ;
21978: LD_ADDR_VAR 0 2
21982: PUSH
21983: LD_VAR 0 1
21987: PUSH
21988: LD_INT 10000
21990: PLUS
21991: PPUSH
21992: CALL_OW 110
21996: ST_TO_ADDR
// if a = 0 then
21997: LD_VAR 0 2
22001: PUSH
22002: LD_INT 0
22004: EQUAL
22005: IFFALSE 22025
// DU_units := DU_units diff i else
22007: LD_ADDR_EXP 82
22011: PUSH
22012: LD_EXP 82
22016: PUSH
22017: LD_VAR 0 1
22021: DIFF
22022: ST_TO_ADDR
22023: GO 22047
// SetTag ( i + 10000 , a - 1 ) ;
22025: LD_VAR 0 1
22029: PUSH
22030: LD_INT 10000
22032: PLUS
22033: PPUSH
22034: LD_VAR 0 2
22038: PUSH
22039: LD_INT 1
22041: MINUS
22042: PPUSH
22043: CALL_OW 109
// end ;
22047: GO 21975
22049: POP
22050: POP
// enable ;
22051: ENABLE
// end ;
22052: PPOPN 2
22054: END
// export function DU_wait ( un ) ; begin
22055: LD_INT 0
22057: PPUSH
// wait ( 0 0$1 ) ;
22058: LD_INT 35
22060: PPUSH
22061: CALL_OW 67
// while un in DU_units do
22065: LD_VAR 0 1
22069: PUSH
22070: LD_EXP 82
22074: IN
22075: IFFALSE 22086
// wait ( 0 0$1 ) ;
22077: LD_INT 35
22079: PPUSH
22080: CALL_OW 67
22084: GO 22065
// end ; end_of_file
22086: LD_VAR 0 2
22090: RET
// var rDef1 , rDef2 ; var idDef1 , idDef2 ; export toDef1 , toDef2 ; every 0 0$1 do
22091: GO 22093
22093: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ^ sci ^ mec ^ eng ;
22094: LD_ADDR_EXP 83
22098: PUSH
22099: LD_EXP 43
22103: PUSH
22104: LD_EXP 27
22108: ADD
22109: PUSH
22110: LD_EXP 28
22114: ADD
22115: PUSH
22116: LD_EXP 20
22120: ADD
22121: PUSH
22122: LD_EXP 19
22126: ADD
22127: PUSH
22128: LD_EXP 21
22132: ADD
22133: PUSH
22134: LD_EXP 22
22138: ADD
22139: PUSH
22140: LD_EXP 23
22144: ADD
22145: ST_TO_ADDR
// rDef1 := McRegistry ( arabians , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , def_base ] , [ mc_reg_area_to_protect , def_base ] ] ) ;
22146: LD_ADDR_LOC 28
22150: PUSH
22151: LD_EXP 3
22155: PPUSH
22156: LD_INT 1
22158: PUSH
22159: LD_INT 70
22161: PUSH
22162: EMPTY
22163: LIST
22164: LIST
22165: PUSH
22166: LD_INT 2
22168: PUSH
22169: LD_INT 23
22171: PUSH
22172: EMPTY
22173: LIST
22174: LIST
22175: PUSH
22176: LD_INT 3
22178: PUSH
22179: LD_INT 23
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: LIST
22190: PPUSH
22191: CALL_OW 399
22195: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef_difficulty ] ) ;
22196: LD_ADDR_LOC 30
22200: PUSH
22201: LD_INT 10
22203: PPUSH
22204: LD_LOC 28
22208: PPUSH
22209: LD_EXP 83
22213: PPUSH
22214: LD_INT 1
22216: PUSH
22217: LD_EXP 13
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PPUSH
22226: CALL_OW 401
22230: ST_TO_ADDR
// end ;
22231: END
// every 0 0$2 do
22232: GO 22234
22234: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ;
22235: LD_ADDR_EXP 83
22239: PUSH
22240: LD_EXP 43
22244: PUSH
22245: LD_EXP 27
22249: ADD
22250: PUSH
22251: LD_EXP 28
22255: ADD
22256: PUSH
22257: LD_EXP 20
22261: ADD
22262: PUSH
22263: LD_EXP 19
22267: ADD
22268: ST_TO_ADDR
// AddMcUnits ( idDef1 , todef1 diff GetMcUnits ( idDef1 ) ) ;
22269: LD_LOC 30
22273: PPUSH
22274: LD_EXP 83
22278: PUSH
22279: LD_LOC 30
22283: PPUSH
22284: CALL_OW 389
22288: DIFF
22289: PPUSH
22290: CALL_OW 390
// RemoveMcUnits ( idDef1 , GetMcUnits ( idDef1 ) diff todef1 ) ;
22294: LD_LOC 30
22298: PPUSH
22299: LD_LOC 30
22303: PPUSH
22304: CALL_OW 389
22308: PUSH
22309: LD_EXP 83
22313: DIFF
22314: PPUSH
22315: CALL_OW 391
// enable ;
22319: ENABLE
// end ; end_of_file
22320: END
// var objevovani_zasilek ; var ar_objevovani_zasilek ; export crates ; every 0 0$0.1 do
22321: GO 22323
22323: DISABLE
// begin SetResourceVisibility ( 131 , 51 , arabians ) ;
22324: LD_INT 131
22326: PPUSH
22327: LD_INT 51
22329: PPUSH
22330: LD_EXP 3
22334: PPUSH
22335: CALL_OW 441
// case difficulty of 1 :
22339: LD_OWVAR 67
22343: PUSH
22344: LD_INT 1
22346: DOUBLE
22347: EQUAL
22348: IFTRUE 22352
22350: GO 22450
22352: POP
// objevovani_zasilek := [ 3 , 6 , 4 , 4 , 1 , 4 , 2 , 2 , 3 , 5 , 0 , 2 , 3 , 5 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ] ; 2 :
22353: LD_ADDR_LOC 32
22357: PUSH
22358: LD_INT 3
22360: PUSH
22361: LD_INT 6
22363: PUSH
22364: LD_INT 4
22366: PUSH
22367: LD_INT 4
22369: PUSH
22370: LD_INT 1
22372: PUSH
22373: LD_INT 4
22375: PUSH
22376: LD_INT 2
22378: PUSH
22379: LD_INT 2
22381: PUSH
22382: LD_INT 3
22384: PUSH
22385: LD_INT 5
22387: PUSH
22388: LD_INT 0
22390: PUSH
22391: LD_INT 2
22393: PUSH
22394: LD_INT 3
22396: PUSH
22397: LD_INT 5
22399: PUSH
22400: LD_INT 1
22402: PUSH
22403: LD_INT 2
22405: PUSH
22406: LD_INT 1
22408: PUSH
22409: LD_INT 2
22411: PUSH
22412: LD_INT 1
22414: PUSH
22415: LD_INT 2
22417: PUSH
22418: LD_INT 1
22420: PUSH
22421: LD_INT 2
22423: PUSH
22424: EMPTY
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: LIST
22447: ST_TO_ADDR
22448: GO 22663
22450: LD_INT 2
22452: DOUBLE
22453: EQUAL
22454: IFTRUE 22458
22456: GO 22556
22458: POP
// objevovani_zasilek := [ 2 , 5 , 3 , 2 , 1 , 3 , 2 , 2 , 3 , 4 , 0 , 2 , 3 , 4 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; 3 :
22459: LD_ADDR_LOC 32
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: LD_INT 5
22469: PUSH
22470: LD_INT 3
22472: PUSH
22473: LD_INT 2
22475: PUSH
22476: LD_INT 1
22478: PUSH
22479: LD_INT 3
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 2
22487: PUSH
22488: LD_INT 3
22490: PUSH
22491: LD_INT 4
22493: PUSH
22494: LD_INT 0
22496: PUSH
22497: LD_INT 2
22499: PUSH
22500: LD_INT 3
22502: PUSH
22503: LD_INT 4
22505: PUSH
22506: LD_INT 0
22508: PUSH
22509: LD_INT 2
22511: PUSH
22512: LD_INT 0
22514: PUSH
22515: LD_INT 2
22517: PUSH
22518: LD_INT 0
22520: PUSH
22521: LD_INT 2
22523: PUSH
22524: LD_INT 0
22526: PUSH
22527: LD_INT 2
22529: PUSH
22530: EMPTY
22531: LIST
22532: LIST
22533: LIST
22534: LIST
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: LIST
22546: LIST
22547: LIST
22548: LIST
22549: LIST
22550: LIST
22551: LIST
22552: LIST
22553: ST_TO_ADDR
22554: GO 22663
22556: LD_INT 3
22558: DOUBLE
22559: EQUAL
22560: IFTRUE 22564
22562: GO 22662
22564: POP
// objevovani_zasilek := [ 2 , 4 , 2 , 2 , 0 , 3 , 1 , 2 , 3 , 3 , 0 , 2 , 3 , 2 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; end ;
22565: LD_ADDR_LOC 32
22569: PUSH
22570: LD_INT 2
22572: PUSH
22573: LD_INT 4
22575: PUSH
22576: LD_INT 2
22578: PUSH
22579: LD_INT 2
22581: PUSH
22582: LD_INT 0
22584: PUSH
22585: LD_INT 3
22587: PUSH
22588: LD_INT 1
22590: PUSH
22591: LD_INT 2
22593: PUSH
22594: LD_INT 3
22596: PUSH
22597: LD_INT 3
22599: PUSH
22600: LD_INT 0
22602: PUSH
22603: LD_INT 2
22605: PUSH
22606: LD_INT 3
22608: PUSH
22609: LD_INT 2
22611: PUSH
22612: LD_INT 0
22614: PUSH
22615: LD_INT 2
22617: PUSH
22618: LD_INT 0
22620: PUSH
22621: LD_INT 2
22623: PUSH
22624: LD_INT 0
22626: PUSH
22627: LD_INT 2
22629: PUSH
22630: LD_INT 0
22632: PUSH
22633: LD_INT 2
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: LIST
22640: LIST
22641: LIST
22642: LIST
22643: LIST
22644: LIST
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: LIST
22650: LIST
22651: LIST
22652: LIST
22653: LIST
22654: LIST
22655: LIST
22656: LIST
22657: LIST
22658: LIST
22659: ST_TO_ADDR
22660: GO 22663
22662: POP
// ar_objevovani_zasilek := [ 5 , 6 , 4 , 4 , 2 , 5 , 2 , 4 , 6 , 5 , 2 , 4 , 6 , 5 , 5 , 4 , 5 , 2 , 9 , 8 , 6 , 5 ] ;
22663: LD_ADDR_LOC 33
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: LD_INT 6
22673: PUSH
22674: LD_INT 4
22676: PUSH
22677: LD_INT 4
22679: PUSH
22680: LD_INT 2
22682: PUSH
22683: LD_INT 5
22685: PUSH
22686: LD_INT 2
22688: PUSH
22689: LD_INT 4
22691: PUSH
22692: LD_INT 6
22694: PUSH
22695: LD_INT 5
22697: PUSH
22698: LD_INT 2
22700: PUSH
22701: LD_INT 4
22703: PUSH
22704: LD_INT 6
22706: PUSH
22707: LD_INT 5
22709: PUSH
22710: LD_INT 5
22712: PUSH
22713: LD_INT 4
22715: PUSH
22716: LD_INT 5
22718: PUSH
22719: LD_INT 2
22721: PUSH
22722: LD_INT 9
22724: PUSH
22725: LD_INT 8
22727: PUSH
22728: LD_INT 6
22730: PUSH
22731: LD_INT 5
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: LIST
22738: LIST
22739: LIST
22740: LIST
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: LIST
22746: LIST
22747: LIST
22748: LIST
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: ST_TO_ADDR
// Randomize ;
22758: CALL_OW 10
// end ;
22762: END
// every 0 0$10 do
22763: GO 22765
22765: DISABLE
// begin Randomize ;
22766: CALL_OW 10
// enable ;
22770: ENABLE
// end ;
22771: END
// every 15 15$0 do
22772: GO 22774
22774: DISABLE
// begin CreateCratesArea ( 4 , other_crates , true ) ;
22775: LD_INT 4
22777: PPUSH
22778: LD_INT 27
22780: PPUSH
22781: LD_INT 1
22783: PPUSH
22784: CALL_OW 55
// end ;
22788: END
// every 23 23$0 do
22789: GO 22791
22791: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22792: LD_INT 5
22794: PPUSH
22795: LD_INT 27
22797: PPUSH
22798: LD_INT 1
22800: PPUSH
22801: CALL_OW 55
// end ;
22805: END
// every 37 37$0 do
22806: GO 22808
22808: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22809: LD_INT 5
22811: PPUSH
22812: LD_INT 27
22814: PPUSH
22815: LD_INT 1
22817: PPUSH
22818: CALL_OW 55
// end ;
22822: END
// every 47 47$0 do
22823: GO 22825
22825: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22826: LD_INT 5
22828: PPUSH
22829: LD_INT 27
22831: PPUSH
22832: LD_INT 1
22834: PPUSH
22835: CALL_OW 55
// end ;
22839: END
// every 0 0$5 do var a , i ;
22840: GO 22842
22842: DISABLE
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
// begin crates := [ ] ;
22847: LD_ADDR_EXP 85
22851: PUSH
22852: EMPTY
22853: ST_TO_ADDR
// a := GetListOfCratesInArea ( ar_crates_site ) ;
22854: LD_ADDR_VAR 0 1
22858: PUSH
22859: LD_INT 16
22861: PPUSH
22862: CALL_OW 435
22866: ST_TO_ADDR
// for i := 1 to ( a div 2 ) do
22867: LD_ADDR_VAR 0 2
22871: PUSH
22872: DOUBLE
22873: LD_INT 1
22875: DEC
22876: ST_TO_ADDR
22877: LD_VAR 0 1
22881: PUSH
22882: LD_INT 2
22884: DIV
22885: PUSH
22886: FOR_TO
22887: IFFALSE 22943
// crates := crates ^ [ [ a [ i * 2 - 1 ] , a [ i * 2 ] ] ] ;
22889: LD_ADDR_EXP 85
22893: PUSH
22894: LD_EXP 85
22898: PUSH
22899: LD_VAR 0 1
22903: PUSH
22904: LD_VAR 0 2
22908: PUSH
22909: LD_INT 2
22911: MUL
22912: PUSH
22913: LD_INT 1
22915: MINUS
22916: ARRAY
22917: PUSH
22918: LD_VAR 0 1
22922: PUSH
22923: LD_VAR 0 2
22927: PUSH
22928: LD_INT 2
22930: MUL
22931: ARRAY
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: PUSH
22937: EMPTY
22938: LIST
22939: ADD
22940: ST_TO_ADDR
22941: GO 22886
22943: POP
22944: POP
// enable ;
22945: ENABLE
// end ;
22946: PPOPN 2
22948: END
// every 0 0$1 do
22949: GO 22951
22951: DISABLE
// begin Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
22952: LD_INT 3
22954: PPUSH
22955: LD_INT 7
22957: PPUSH
22958: CALL_OW 12
22962: PUSH
22963: LD_INT 35
22965: MUL
22966: PPUSH
22967: CALL_OW 67
// CreateCratesArea ( 2 , first_crate , true ) ;
22971: LD_INT 2
22973: PPUSH
22974: LD_INT 6
22976: PPUSH
22977: LD_INT 1
22979: PPUSH
22980: CALL_OW 55
// Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
22984: LD_INT 3
22986: PPUSH
22987: LD_INT 7
22989: PPUSH
22990: CALL_OW 12
22994: PUSH
22995: LD_INT 35
22997: MUL
22998: PPUSH
22999: CALL_OW 67
// CreateCratesArea ( 2 , second_crate , true ) ;
23003: LD_INT 2
23005: PPUSH
23006: LD_INT 7
23008: PPUSH
23009: LD_INT 1
23011: PPUSH
23012: CALL_OW 55
// end ;
23016: END
// every 0 0$5 do
23017: GO 23019
23019: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
23020: LD_LOC 32
23024: PPUSH
23025: LD_INT 5
23027: PPUSH
23028: CALL 23083 0 2
// end ;
23032: END
// every 0 0$5 do
23033: GO 23035
23035: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
23036: LD_LOC 33
23040: PPUSH
23041: LD_INT 16
23043: PPUSH
23044: CALL 23083 0 2
// end ;
23048: END
// every 5 5$0 + 0 0$5 do
23049: GO 23051
23051: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
23052: LD_LOC 32
23056: PPUSH
23057: LD_INT 5
23059: PPUSH
23060: CALL 23083 0 2
// enable ;
23064: ENABLE
// end ;
23065: END
// every 5 5$0 + 0 0$5 do
23066: GO 23068
23068: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
23069: LD_LOC 33
23073: PPUSH
23074: LD_INT 16
23076: PPUSH
23077: CALL 23083 0 2
// enable ;
23081: ENABLE
// end ;
23082: END
// function objev ( zasilky , area ) ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
23083: LD_INT 0
23085: PPUSH
23086: PPUSH
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
23094: LD_ADDR_VAR 0 11
23098: PUSH
23099: LD_OWVAR 1
23103: PUSH
23104: LD_INT 10500
23106: DIV
23107: PUSH
23108: LD_INT 1
23110: PLUS
23111: ST_TO_ADDR
// cek := [ ] ;
23112: LD_ADDR_VAR 0 8
23116: PUSH
23117: EMPTY
23118: ST_TO_ADDR
// cek2 := [ ] ;
23119: LD_ADDR_VAR 0 9
23123: PUSH
23124: EMPTY
23125: ST_TO_ADDR
// last := 0 ;
23126: LD_ADDR_VAR 0 10
23130: PUSH
23131: LD_INT 0
23133: ST_TO_ADDR
// x := zasilky [ min5 ] ;
23134: LD_ADDR_VAR 0 4
23138: PUSH
23139: LD_VAR 0 1
23143: PUSH
23144: LD_VAR 0 11
23148: ARRAY
23149: ST_TO_ADDR
// for i := 1 to x do
23150: LD_ADDR_VAR 0 6
23154: PUSH
23155: DOUBLE
23156: LD_INT 1
23158: DEC
23159: ST_TO_ADDR
23160: LD_VAR 0 4
23164: PUSH
23165: FOR_TO
23166: IFFALSE 23192
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
23168: LD_ADDR_VAR 0 8
23172: PUSH
23173: LD_VAR 0 8
23177: PUSH
23178: LD_INT 525
23180: PPUSH
23181: LD_INT 10500
23183: PPUSH
23184: CALL_OW 12
23188: ADD
23189: ST_TO_ADDR
23190: GO 23165
23192: POP
23193: POP
// cek := SortListByListAsc ( cek , cek ) ;
23194: LD_ADDR_VAR 0 8
23198: PUSH
23199: LD_VAR 0 8
23203: PPUSH
23204: LD_VAR 0 8
23208: PPUSH
23209: CALL_OW 76
23213: ST_TO_ADDR
// for i in cek do
23214: LD_ADDR_VAR 0 6
23218: PUSH
23219: LD_VAR 0 8
23223: PUSH
23224: FOR_IN
23225: IFFALSE 23261
// begin cek2 := cek2 ^ i - last ;
23227: LD_ADDR_VAR 0 9
23231: PUSH
23232: LD_VAR 0 9
23236: PUSH
23237: LD_VAR 0 6
23241: PUSH
23242: LD_VAR 0 10
23246: MINUS
23247: ADD
23248: ST_TO_ADDR
// last := i ;
23249: LD_ADDR_VAR 0 10
23253: PUSH
23254: LD_VAR 0 6
23258: ST_TO_ADDR
// end ;
23259: GO 23224
23261: POP
23262: POP
// for i := 1 to x do
23263: LD_ADDR_VAR 0 6
23267: PUSH
23268: DOUBLE
23269: LD_INT 1
23271: DEC
23272: ST_TO_ADDR
23273: LD_VAR 0 4
23277: PUSH
23278: FOR_TO
23279: IFFALSE 23321
// begin CreateCratesArea ( Rand ( 4 , 5 ) , area , true ) ;
23281: LD_INT 4
23283: PPUSH
23284: LD_INT 5
23286: PPUSH
23287: CALL_OW 12
23291: PPUSH
23292: LD_VAR 0 2
23296: PPUSH
23297: LD_INT 1
23299: PPUSH
23300: CALL_OW 55
// Wait ( cek2 [ i ] ) ;
23304: LD_VAR 0 9
23308: PUSH
23309: LD_VAR 0 6
23313: ARRAY
23314: PPUSH
23315: CALL_OW 67
// end ;
23319: GO 23278
23321: POP
23322: POP
// end ; end_of_file
23323: LD_VAR 0 3
23327: RET
// export function get_x_best ( num , skill , mclass ) ; var i , lidi , skills ; begin
23328: LD_INT 0
23330: PPUSH
23331: PPUSH
23332: PPUSH
23333: PPUSH
// if mclass then
23334: LD_VAR 0 3
23338: IFFALSE 23391
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] , [ f_class , mclass ] ] ) else
23340: LD_ADDR_VAR 0 6
23344: PUSH
23345: LD_INT 22
23347: PUSH
23348: LD_EXP 3
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: PUSH
23357: LD_INT 21
23359: PUSH
23360: LD_INT 1
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PUSH
23367: LD_INT 25
23369: PUSH
23370: LD_VAR 0 3
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: PPUSH
23384: CALL_OW 69
23388: ST_TO_ADDR
23389: GO 23427
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
23391: LD_ADDR_VAR 0 6
23395: PUSH
23396: LD_INT 22
23398: PUSH
23399: LD_EXP 3
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: LD_INT 21
23410: PUSH
23411: LD_INT 1
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: PPUSH
23422: CALL_OW 69
23426: ST_TO_ADDR
// skills := [ ] ;
23427: LD_ADDR_VAR 0 7
23431: PUSH
23432: EMPTY
23433: ST_TO_ADDR
// result := [ ] ;
23434: LD_ADDR_VAR 0 4
23438: PUSH
23439: EMPTY
23440: ST_TO_ADDR
// for i in lidi do
23441: LD_ADDR_VAR 0 5
23445: PUSH
23446: LD_VAR 0 6
23450: PUSH
23451: FOR_IN
23452: IFFALSE 23482
// skills := skills ^ GetSkill ( i , skill ) ;
23454: LD_ADDR_VAR 0 7
23458: PUSH
23459: LD_VAR 0 7
23463: PUSH
23464: LD_VAR 0 5
23468: PPUSH
23469: LD_VAR 0 2
23473: PPUSH
23474: CALL_OW 259
23478: ADD
23479: ST_TO_ADDR
23480: GO 23451
23482: POP
23483: POP
// SortListByListDesc ( lidi , skills ) ;
23484: LD_VAR 0 6
23488: PPUSH
23489: LD_VAR 0 7
23493: PPUSH
23494: CALL_OW 77
// if num = 0 then
23498: LD_VAR 0 1
23502: PUSH
23503: LD_INT 0
23505: EQUAL
23506: IFFALSE 23522
// num := ( lidi + 0 ) ;
23508: LD_ADDR_VAR 0 1
23512: PUSH
23513: LD_VAR 0 6
23517: PUSH
23518: LD_INT 0
23520: PLUS
23521: ST_TO_ADDR
// if num > lidi then
23522: LD_VAR 0 1
23526: PUSH
23527: LD_VAR 0 6
23531: GREATER
23532: IFFALSE 23548
// num := lidi + 0 ;
23534: LD_ADDR_VAR 0 1
23538: PUSH
23539: LD_VAR 0 6
23543: PUSH
23544: LD_INT 0
23546: PLUS
23547: ST_TO_ADDR
// for i := 1 to num do
23548: LD_ADDR_VAR 0 5
23552: PUSH
23553: DOUBLE
23554: LD_INT 1
23556: DEC
23557: ST_TO_ADDR
23558: LD_VAR 0 1
23562: PUSH
23563: FOR_TO
23564: IFFALSE 23590
// result := result ^ lidi [ i ] ;
23566: LD_ADDR_VAR 0 4
23570: PUSH
23571: LD_VAR 0 4
23575: PUSH
23576: LD_VAR 0 6
23580: PUSH
23581: LD_VAR 0 5
23585: ARRAY
23586: ADD
23587: ST_TO_ADDR
23588: GO 23563
23590: POP
23591: POP
// end ;
23592: LD_VAR 0 4
23596: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
23597: LD_INT 0
23599: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_alive ] , [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
23600: LD_ADDR_VAR 0 1
23604: PUSH
23605: LD_VAR 0 1
23609: PPUSH
23610: LD_INT 51
23612: PUSH
23613: EMPTY
23614: LIST
23615: PUSH
23616: LD_INT 21
23618: PUSH
23619: LD_INT 1
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 22
23628: PUSH
23629: LD_VAR 0 2
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 3
23640: PUSH
23641: LD_INT 23
23643: PUSH
23644: LD_INT 0
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: ST_TO_ADDR
// if sex <> 0 then
23663: LD_VAR 0 3
23667: PUSH
23668: LD_INT 0
23670: NONEQUAL
23671: IFFALSE 23700
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
23673: LD_ADDR_VAR 0 1
23677: PUSH
23678: LD_VAR 0 1
23682: PPUSH
23683: LD_INT 26
23685: PUSH
23686: LD_VAR 0 3
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: PPUSH
23695: CALL_OW 72
23699: ST_TO_ADDR
// if Hclass <> 0 then
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 0
23707: NONEQUAL
23708: IFFALSE 23737
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
23710: LD_ADDR_VAR 0 1
23714: PUSH
23715: LD_VAR 0 1
23719: PPUSH
23720: LD_INT 25
23722: PUSH
23723: LD_VAR 0 4
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PPUSH
23732: CALL_OW 72
23736: ST_TO_ADDR
// if index <= 0 then
23737: LD_VAR 0 5
23741: PUSH
23742: LD_INT 0
23744: LESSEQUAL
23745: IFFALSE 23755
// index := 1 ;
23747: LD_ADDR_VAR 0 5
23751: PUSH
23752: LD_INT 1
23754: ST_TO_ADDR
// if lidi >= index then
23755: LD_VAR 0 1
23759: PUSH
23760: LD_VAR 0 5
23764: GREATEREQUAL
23765: IFFALSE 23785
// result := lidi [ index ] else
23767: LD_ADDR_VAR 0 6
23771: PUSH
23772: LD_VAR 0 1
23776: PUSH
23777: LD_VAR 0 5
23781: ARRAY
23782: ST_TO_ADDR
23783: GO 23793
// result := 0 ;
23785: LD_ADDR_VAR 0 6
23789: PUSH
23790: LD_INT 0
23792: ST_TO_ADDR
// end ;
23793: LD_VAR 0 6
23797: RET
// export function see_any ( strana , sez ) ; var i ; begin
23798: LD_INT 0
23800: PPUSH
23801: PPUSH
// result := [ ] ;
23802: LD_ADDR_VAR 0 3
23806: PUSH
23807: EMPTY
23808: ST_TO_ADDR
// for i in sez do
23809: LD_ADDR_VAR 0 4
23813: PUSH
23814: LD_VAR 0 2
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23859
// if See ( strana , i ) then
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_VAR 0 4
23831: PPUSH
23832: CALL_OW 292
23836: IFFALSE 23857
// begin result := result ^ [ i ] ;
23838: LD_ADDR_VAR 0 3
23842: PUSH
23843: LD_VAR 0 3
23847: PUSH
23848: LD_VAR 0 4
23852: PUSH
23853: EMPTY
23854: LIST
23855: ADD
23856: ST_TO_ADDR
// end ;
23857: GO 23819
23859: POP
23860: POP
// ; end ;
23861: LD_VAR 0 3
23865: RET
// export function TalkOn ; begin
23866: LD_INT 0
23868: PPUSH
// end ;
23869: LD_VAR 0 1
23873: RET
// export function TalkOff ; begin
23874: LD_INT 0
23876: PPUSH
// end ;
23877: LD_VAR 0 1
23881: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
23882: LD_INT 0
23884: PPUSH
23885: PPUSH
23886: PPUSH
// result := [ ] ;
23887: LD_ADDR_VAR 0 3
23891: PUSH
23892: EMPTY
23893: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
23894: LD_ADDR_VAR 0 4
23898: PUSH
23899: LD_VAR 0 1
23903: PPUSH
23904: EMPTY
23905: PPUSH
23906: CALL_OW 70
23910: ST_TO_ADDR
// for i in inbase do
23911: LD_ADDR_VAR 0 5
23915: PUSH
23916: LD_VAR 0 4
23920: PUSH
23921: FOR_IN
23922: IFFALSE 23995
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
23924: LD_VAR 0 5
23928: PPUSH
23929: CALL_OW 247
23933: PUSH
23934: LD_INT 3
23936: EQUAL
23937: PUSH
23938: LD_VAR 0 5
23942: PPUSH
23943: CALL_OW 247
23947: PUSH
23948: LD_INT 2
23950: EQUAL
23951: OR
23952: IFFALSE 23977
// begin result := result ^ UnitsInside ( i ) ;
23954: LD_ADDR_VAR 0 3
23958: PUSH
23959: LD_VAR 0 3
23963: PUSH
23964: LD_VAR 0 5
23968: PPUSH
23969: CALL_OW 313
23973: ADD
23974: ST_TO_ADDR
// end else
23975: GO 23993
// begin result := result ^ i ;
23977: LD_ADDR_VAR 0 3
23981: PUSH
23982: LD_VAR 0 3
23986: PUSH
23987: LD_VAR 0 5
23991: ADD
23992: ST_TO_ADDR
// end ; end ;
23993: GO 23921
23995: POP
23996: POP
// result := UnitFilter ( result diff 0 , filter ) ;
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_VAR 0 3
24006: PUSH
24007: LD_INT 0
24009: DIFF
24010: PPUSH
24011: LD_VAR 0 2
24015: PPUSH
24016: CALL_OW 72
24020: ST_TO_ADDR
// end ;
24021: LD_VAR 0 3
24025: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
24026: LD_INT 0
24028: PPUSH
24029: PPUSH
24030: PPUSH
24031: PPUSH
24032: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) ;
24033: LD_ADDR_VAR 0 1
24037: PUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: LD_INT 51
24045: PUSH
24046: EMPTY
24047: LIST
24048: PPUSH
24049: CALL_OW 72
24053: ST_TO_ADDR
// if take_out then
24054: LD_VAR 0 3
24058: IFFALSE 24086
// drivers := UnitFilter ( drivers , [ [ f_alive ] ] ) else
24060: LD_ADDR_VAR 0 2
24064: PUSH
24065: LD_VAR 0 2
24069: PPUSH
24070: LD_INT 51
24072: PUSH
24073: EMPTY
24074: LIST
24075: PUSH
24076: EMPTY
24077: LIST
24078: PPUSH
24079: CALL_OW 72
24083: ST_TO_ADDR
24084: GO 24117
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
24086: LD_ADDR_VAR 0 2
24090: PUSH
24091: LD_VAR 0 2
24095: PPUSH
24096: LD_INT 51
24098: PUSH
24099: EMPTY
24100: LIST
24101: PUSH
24102: LD_INT 56
24104: PUSH
24105: EMPTY
24106: LIST
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: PPUSH
24112: CALL_OW 72
24116: ST_TO_ADDR
// empty := [ ] ;
24117: LD_ADDR_VAR 0 5
24121: PUSH
24122: EMPTY
24123: ST_TO_ADDR
// free := [ ] ;
24124: LD_ADDR_VAR 0 6
24128: PUSH
24129: EMPTY
24130: ST_TO_ADDR
// for i in cars do
24131: LD_ADDR_VAR 0 7
24135: PUSH
24136: LD_VAR 0 1
24140: PUSH
24141: FOR_IN
24142: IFFALSE 24177
// if not IsDrivenBy ( i ) then
24144: LD_VAR 0 7
24148: PPUSH
24149: CALL_OW 311
24153: NOT
24154: IFFALSE 24175
// empty := empty ^ [ i ] ;
24156: LD_ADDR_VAR 0 5
24160: PUSH
24161: LD_VAR 0 5
24165: PUSH
24166: LD_VAR 0 7
24170: PUSH
24171: EMPTY
24172: LIST
24173: ADD
24174: ST_TO_ADDR
24175: GO 24141
24177: POP
24178: POP
// for i in drivers do
24179: LD_ADDR_VAR 0 7
24183: PUSH
24184: LD_VAR 0 2
24188: PUSH
24189: FOR_IN
24190: IFFALSE 24231
// if not ( IsInUnit ( i ) in cars ) then
24192: LD_VAR 0 7
24196: PPUSH
24197: CALL_OW 310
24201: PUSH
24202: LD_VAR 0 1
24206: IN
24207: NOT
24208: IFFALSE 24229
// free := free ^ [ i ] ;
24210: LD_ADDR_VAR 0 6
24214: PUSH
24215: LD_VAR 0 6
24219: PUSH
24220: LD_VAR 0 7
24224: PUSH
24225: EMPTY
24226: LIST
24227: ADD
24228: ST_TO_ADDR
24229: GO 24189
24231: POP
24232: POP
// if empty <= free then
24233: LD_VAR 0 5
24237: PUSH
24238: LD_VAR 0 6
24242: LESSEQUAL
24243: IFFALSE 24257
// konec := empty else
24245: LD_ADDR_VAR 0 8
24249: PUSH
24250: LD_VAR 0 5
24254: ST_TO_ADDR
24255: GO 24267
// konec := free ;
24257: LD_ADDR_VAR 0 8
24261: PUSH
24262: LD_VAR 0 6
24266: ST_TO_ADDR
// result := cars diff empty ;
24267: LD_ADDR_VAR 0 4
24271: PUSH
24272: LD_VAR 0 1
24276: PUSH
24277: LD_VAR 0 5
24281: DIFF
24282: ST_TO_ADDR
// for i := 1 to konec do
24283: LD_ADDR_VAR 0 7
24287: PUSH
24288: DOUBLE
24289: LD_INT 1
24291: DEC
24292: ST_TO_ADDR
24293: LD_VAR 0 8
24297: PUSH
24298: FOR_TO
24299: IFFALSE 24351
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
24301: LD_VAR 0 6
24305: PUSH
24306: LD_VAR 0 7
24310: ARRAY
24311: PPUSH
24312: LD_VAR 0 5
24316: PUSH
24317: LD_VAR 0 7
24321: ARRAY
24322: PPUSH
24323: CALL_OW 120
// result := result ^ empty [ i ] ;
24327: LD_ADDR_VAR 0 4
24331: PUSH
24332: LD_VAR 0 4
24336: PUSH
24337: LD_VAR 0 5
24341: PUSH
24342: LD_VAR 0 7
24346: ARRAY
24347: ADD
24348: ST_TO_ADDR
// end ;
24349: GO 24298
24351: POP
24352: POP
// end ;
24353: LD_VAR 0 4
24357: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , pockat ; begin
24358: LD_INT 0
24360: PPUSH
24361: PPUSH
24362: PPUSH
24363: PPUSH
// pockat := tick + cas ;
24364: LD_ADDR_VAR 0 6
24368: PUSH
24369: LD_OWVAR 1
24373: PUSH
24374: LD_VAR 0 2
24378: PLUS
24379: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
24380: LD_VAR 0 5
24384: NOT
24385: PUSH
24386: LD_OWVAR 1
24390: PUSH
24391: LD_VAR 0 6
24395: LESS
24396: AND
24397: IFFALSE 24453
// begin vsichni_ready := true ;
24399: LD_ADDR_VAR 0 5
24403: PUSH
24404: LD_INT 1
24406: ST_TO_ADDR
// for i in cars do
24407: LD_ADDR_VAR 0 4
24411: PUSH
24412: LD_VAR 0 1
24416: PUSH
24417: FOR_IN
24418: IFFALSE 24442
// if not IsDrivenBy ( i ) then
24420: LD_VAR 0 4
24424: PPUSH
24425: CALL_OW 311
24429: NOT
24430: IFFALSE 24440
// vsichni_ready := false ;
24432: LD_ADDR_VAR 0 5
24436: PUSH
24437: LD_INT 0
24439: ST_TO_ADDR
24440: GO 24417
24442: POP
24443: POP
// wait ( 0 0$1.0 ) ;
24444: LD_INT 35
24446: PPUSH
24447: CALL_OW 67
// end ;
24451: GO 24380
// end ;
24453: LD_VAR 0 3
24457: RET
// export function find_and_wait ( cars , drivers , take_out , change , cas ) ; var empty , full , free , i , konec , mytick ; begin
24458: LD_INT 0
24460: PPUSH
24461: PPUSH
24462: PPUSH
24463: PPUSH
24464: PPUSH
24465: PPUSH
24466: PPUSH
// mytick := tick + cas ;
24467: LD_ADDR_VAR 0 12
24471: PUSH
24472: LD_OWVAR 1
24476: PUSH
24477: LD_VAR 0 5
24481: PLUS
24482: ST_TO_ADDR
// cars := UnitFilter ( cars , [ [ f_alive ] ] ) ;
24483: LD_ADDR_VAR 0 1
24487: PUSH
24488: LD_VAR 0 1
24492: PPUSH
24493: LD_INT 51
24495: PUSH
24496: EMPTY
24497: LIST
24498: PUSH
24499: EMPTY
24500: LIST
24501: PPUSH
24502: CALL_OW 72
24506: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
24507: LD_ADDR_VAR 0 2
24511: PUSH
24512: LD_VAR 0 2
24516: PPUSH
24517: LD_INT 51
24519: PUSH
24520: EMPTY
24521: LIST
24522: PUSH
24523: LD_INT 56
24525: PUSH
24526: EMPTY
24527: LIST
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: PPUSH
24533: CALL_OW 72
24537: ST_TO_ADDR
// if take_out then
24538: LD_VAR 0 3
24542: IFFALSE 24583
// drivers := drivers ^ UnitFilter ( drivers , [ [ f_alive ] , [ f_inside ] ] ) else
24544: LD_ADDR_VAR 0 2
24548: PUSH
24549: LD_VAR 0 2
24553: PUSH
24554: LD_VAR 0 2
24558: PPUSH
24559: LD_INT 51
24561: PUSH
24562: EMPTY
24563: LIST
24564: PUSH
24565: LD_INT 54
24567: PUSH
24568: EMPTY
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 72
24579: ADD
24580: ST_TO_ADDR
24581: GO 24614
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
24583: LD_ADDR_VAR 0 7
24587: PUSH
24588: LD_VAR 0 1
24592: PPUSH
24593: LD_INT 58
24595: PUSH
24596: EMPTY
24597: LIST
24598: PUSH
24599: LD_INT 51
24601: PUSH
24602: EMPTY
24603: LIST
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: PPUSH
24609: CALL_OW 72
24613: ST_TO_ADDR
// repeat full := UnitFilter ( cars , [ [ f_occupied ] , [ f_alive ] ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_VAR 0 1
24623: PPUSH
24624: LD_INT 59
24626: PUSH
24627: EMPTY
24628: LIST
24629: PUSH
24630: LD_INT 51
24632: PUSH
24633: EMPTY
24634: LIST
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PPUSH
24640: CALL_OW 72
24644: ST_TO_ADDR
// if change then
24645: LD_VAR 0 4
24649: IFFALSE 24671
// ComExitVehicle ( inside_units ( full ) diff drivers ) ;
24651: LD_VAR 0 8
24655: PPUSH
24656: CALL 25406 0 1
24660: PUSH
24661: LD_VAR 0 2
24665: DIFF
24666: PPUSH
24667: CALL_OW 121
// for i in drivers do
24671: LD_ADDR_VAR 0 10
24675: PUSH
24676: LD_VAR 0 2
24680: PUSH
24681: FOR_IN
24682: IFFALSE 24744
// if not ( IsInUnit ( i ) in cars ) then
24684: LD_VAR 0 10
24688: PPUSH
24689: CALL_OW 310
24693: PUSH
24694: LD_VAR 0 1
24698: IN
24699: NOT
24700: IFFALSE 24742
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
24702: LD_VAR 0 10
24706: PPUSH
24707: CALL_OW 310
24711: PPUSH
24712: CALL_OW 247
24716: PUSH
24717: LD_INT 2
24719: EQUAL
24720: IFFALSE 24733
// ComExitVehicle ( i ) else
24722: LD_VAR 0 10
24726: PPUSH
24727: CALL_OW 121
24731: GO 24742
// ComExitBuilding ( i ) ;
24733: LD_VAR 0 10
24737: PPUSH
24738: CALL_OW 122
24742: GO 24681
24744: POP
24745: POP
// free := UnitFilter ( drivers , [ [ f_outside ] , [ f_alive ] ] ) ;
24746: LD_ADDR_VAR 0 9
24750: PUSH
24751: LD_VAR 0 2
24755: PPUSH
24756: LD_INT 56
24758: PUSH
24759: EMPTY
24760: LIST
24761: PUSH
24762: LD_INT 51
24764: PUSH
24765: EMPTY
24766: LIST
24767: PUSH
24768: EMPTY
24769: LIST
24770: LIST
24771: PPUSH
24772: CALL_OW 72
24776: ST_TO_ADDR
// i := 1 ;
24777: LD_ADDR_VAR 0 10
24781: PUSH
24782: LD_INT 1
24784: ST_TO_ADDR
// while i <= free and i <= empty do
24785: LD_VAR 0 10
24789: PUSH
24790: LD_VAR 0 9
24794: LESSEQUAL
24795: PUSH
24796: LD_VAR 0 10
24800: PUSH
24801: LD_VAR 0 7
24805: LESSEQUAL
24806: AND
24807: IFFALSE 24870
// begin if not free [ i ] in DU_units then
24809: LD_VAR 0 9
24813: PUSH
24814: LD_VAR 0 10
24818: ARRAY
24819: PUSH
24820: LD_EXP 82
24824: IN
24825: NOT
24826: IFFALSE 24854
// ComEnterUnit ( free [ i ] , empty [ i ] ) ;
24828: LD_VAR 0 9
24832: PUSH
24833: LD_VAR 0 10
24837: ARRAY
24838: PPUSH
24839: LD_VAR 0 7
24843: PUSH
24844: LD_VAR 0 10
24848: ARRAY
24849: PPUSH
24850: CALL_OW 120
// i := i + 1 ;
24854: LD_ADDR_VAR 0 10
24858: PUSH
24859: LD_VAR 0 10
24863: PUSH
24864: LD_INT 1
24866: PLUS
24867: ST_TO_ADDR
// end ;
24868: GO 24785
// wait ( 0 0$1 ) ;
24870: LD_INT 35
24872: PPUSH
24873: CALL_OW 67
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
24877: LD_ADDR_VAR 0 7
24881: PUSH
24882: LD_VAR 0 1
24886: PPUSH
24887: LD_INT 58
24889: PUSH
24890: EMPTY
24891: LIST
24892: PUSH
24893: LD_INT 51
24895: PUSH
24896: EMPTY
24897: LIST
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PPUSH
24903: CALL_OW 72
24907: ST_TO_ADDR
// until not empty or tick > mytick ;
24908: LD_VAR 0 7
24912: NOT
24913: PUSH
24914: LD_OWVAR 1
24918: PUSH
24919: LD_VAR 0 12
24923: GREATER
24924: OR
24925: IFFALSE 24614
// end ;
24927: LD_VAR 0 6
24931: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
24932: LD_INT 0
24934: PPUSH
24935: PPUSH
24936: PPUSH
// while remotes > mechs do
24937: LD_VAR 0 3
24941: PUSH
24942: LD_VAR 0 2
24946: GREATER
24947: IFFALSE 24963
// delete ( remotes , 1 ) ;
24949: LD_VAR 0 3
24953: PPUSH
24954: LD_INT 1
24956: PPUSH
24957: CALL_OW 3
24961: GO 24937
// for i := 1 to remotes do
24963: LD_ADDR_VAR 0 6
24967: PUSH
24968: DOUBLE
24969: LD_INT 1
24971: DEC
24972: ST_TO_ADDR
24973: LD_VAR 0 3
24977: PUSH
24978: FOR_TO
24979: IFFALSE 25009
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
24981: LD_VAR 0 2
24985: PUSH
24986: LD_VAR 0 6
24990: ARRAY
24991: PPUSH
24992: LD_VAR 0 3
24996: PUSH
24997: LD_VAR 0 6
25001: ARRAY
25002: PPUSH
25003: CALL_OW 120
25007: GO 24978
25009: POP
25010: POP
// end ;
25011: LD_VAR 0 4
25015: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
25016: LD_INT 0
25018: PPUSH
25019: PPUSH
25020: PPUSH
25021: PPUSH
// c := tick + cas ;
25022: LD_ADDR_VAR 0 5
25026: PUSH
25027: LD_OWVAR 1
25031: PUSH
25032: LD_VAR 0 3
25036: PLUS
25037: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
25038: LD_OWVAR 1
25042: PUSH
25043: LD_VAR 0 5
25047: LESS
25048: PUSH
25049: LD_VAR 0 2
25053: PPUSH
25054: CALL 25406 0 1
25058: PUSH
25059: LD_INT 0
25061: PLUS
25062: PUSH
25063: LD_VAR 0 2
25067: EQUAL
25068: NOT
25069: AND
25070: IFFALSE 25081
// wait ( 0 0$1 ) ;
25072: LD_INT 35
25074: PPUSH
25075: CALL_OW 67
25079: GO 25038
// unlinked := cars ;
25081: LD_ADDR_VAR 0 6
25085: PUSH
25086: LD_VAR 0 1
25090: ST_TO_ADDR
// for i in remotes do
25091: LD_ADDR_VAR 0 7
25095: PUSH
25096: LD_VAR 0 2
25100: PUSH
25101: FOR_IN
25102: IFFALSE 25151
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
25104: LD_VAR 0 6
25108: PPUSH
25109: LD_VAR 0 7
25113: PPUSH
25114: CALL_OW 313
25118: PPUSH
25119: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
25123: LD_ADDR_VAR 0 6
25127: PUSH
25128: LD_VAR 0 6
25132: PUSH
25133: LD_VAR 0 7
25137: PPUSH
25138: CALL_OW 313
25142: PPUSH
25143: CALL_OW 432
25147: DIFF
25148: ST_TO_ADDR
// end ;
25149: GO 25101
25151: POP
25152: POP
// end ;
25153: LD_VAR 0 4
25157: RET
// export function find_and_wait_r ( cars , remote , cas ) ; var linked , unlinked , i , konec , mytick , rmecs , max ; begin
25158: LD_INT 0
25160: PPUSH
25161: PPUSH
25162: PPUSH
25163: PPUSH
25164: PPUSH
25165: PPUSH
25166: PPUSH
25167: PPUSH
// mytick := tick + cas ;
25168: LD_ADDR_VAR 0 9
25172: PUSH
25173: LD_OWVAR 1
25177: PUSH
25178: LD_VAR 0 3
25182: PLUS
25183: ST_TO_ADDR
// rmecs := inside_units ( remote ) ;
25184: LD_ADDR_VAR 0 10
25188: PUSH
25189: LD_VAR 0 2
25193: PPUSH
25194: CALL 25406 0 1
25198: ST_TO_ADDR
// max := 0 ;
25199: LD_ADDR_VAR 0 11
25203: PUSH
25204: LD_INT 0
25206: ST_TO_ADDR
// for i in rmecs do
25207: LD_ADDR_VAR 0 7
25211: PUSH
25212: LD_VAR 0 10
25216: PUSH
25217: FOR_IN
25218: IFFALSE 25246
// max := max + GetSkill ( i , skill_mechanical ) ;
25220: LD_ADDR_VAR 0 11
25224: PUSH
25225: LD_VAR 0 11
25229: PUSH
25230: LD_VAR 0 7
25234: PPUSH
25235: LD_INT 3
25237: PPUSH
25238: CALL_OW 259
25242: PLUS
25243: ST_TO_ADDR
25244: GO 25217
25246: POP
25247: POP
// while mytick < tick and ( unlinked or linked < max or max = 0 ) do
25248: LD_VAR 0 9
25252: PUSH
25253: LD_OWVAR 1
25257: LESS
25258: PUSH
25259: LD_VAR 0 6
25263: PUSH
25264: LD_VAR 0 5
25268: PUSH
25269: LD_VAR 0 11
25273: LESS
25274: OR
25275: PUSH
25276: LD_VAR 0 11
25280: PUSH
25281: LD_INT 0
25283: EQUAL
25284: OR
25285: AND
25286: IFFALSE 25401
// begin rmecs := inside_units ( remote ) ;
25288: LD_ADDR_VAR 0 10
25292: PUSH
25293: LD_VAR 0 2
25297: PPUSH
25298: CALL 25406 0 1
25302: ST_TO_ADDR
// max := 0 ;
25303: LD_ADDR_VAR 0 11
25307: PUSH
25308: LD_INT 0
25310: ST_TO_ADDR
// for i in rmecs do
25311: LD_ADDR_VAR 0 7
25315: PUSH
25316: LD_VAR 0 10
25320: PUSH
25321: FOR_IN
25322: IFFALSE 25350
// max := max + GetSkill ( i , skill_mechanical ) ;
25324: LD_ADDR_VAR 0 11
25328: PUSH
25329: LD_VAR 0 11
25333: PUSH
25334: LD_VAR 0 7
25338: PPUSH
25339: LD_INT 3
25341: PPUSH
25342: CALL_OW 259
25346: PLUS
25347: ST_TO_ADDR
25348: GO 25321
25350: POP
25351: POP
// linked := UnitFilter ( cars , [ [ f_linked ] ] ) ;
25352: LD_ADDR_VAR 0 5
25356: PUSH
25357: LD_VAR 0 1
25361: PPUSH
25362: LD_INT 61
25364: PUSH
25365: EMPTY
25366: LIST
25367: PUSH
25368: EMPTY
25369: LIST
25370: PPUSH
25371: CALL_OW 72
25375: ST_TO_ADDR
// unlinked := linked diff unlinked ;
25376: LD_ADDR_VAR 0 6
25380: PUSH
25381: LD_VAR 0 5
25385: PUSH
25386: LD_VAR 0 6
25390: DIFF
25391: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25392: LD_INT 35
25394: PPUSH
25395: CALL_OW 67
// end ;
25399: GO 25248
// end ;
25401: LD_VAR 0 4
25405: RET
// export function inside_units ( uns ) ; var i ; begin
25406: LD_INT 0
25408: PPUSH
25409: PPUSH
// result := [ ] ;
25410: LD_ADDR_VAR 0 2
25414: PUSH
25415: EMPTY
25416: ST_TO_ADDR
// for i in uns do
25417: LD_ADDR_VAR 0 3
25421: PUSH
25422: LD_VAR 0 1
25426: PUSH
25427: FOR_IN
25428: IFFALSE 25453
// result := result ^ UnitsInside ( i ) ;
25430: LD_ADDR_VAR 0 2
25434: PUSH
25435: LD_VAR 0 2
25439: PUSH
25440: LD_VAR 0 3
25444: PPUSH
25445: CALL_OW 313
25449: ADD
25450: ST_TO_ADDR
25451: GO 25427
25453: POP
25454: POP
// end ;
25455: LD_VAR 0 2
25459: RET
// export function add ( list , list1 ) ; begin
25460: LD_INT 0
25462: PPUSH
// if list = 0 then
25463: LD_VAR 0 1
25467: PUSH
25468: LD_INT 0
25470: EQUAL
25471: IFFALSE 25480
// list := [ ] ;
25473: LD_ADDR_VAR 0 1
25477: PUSH
25478: EMPTY
25479: ST_TO_ADDR
// if list1 = 0 then
25480: LD_VAR 0 2
25484: PUSH
25485: LD_INT 0
25487: EQUAL
25488: IFFALSE 25497
// list1 := [ ] ;
25490: LD_ADDR_VAR 0 2
25494: PUSH
25495: EMPTY
25496: ST_TO_ADDR
// result := list ^ list1 ;
25497: LD_ADDR_VAR 0 3
25501: PUSH
25502: LD_VAR 0 1
25506: PUSH
25507: LD_VAR 0 2
25511: ADD
25512: ST_TO_ADDR
// end ;
25513: LD_VAR 0 3
25517: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
25518: LD_INT 0
25520: PPUSH
// if not hinty_co_byli then
25521: LD_EXP 86
25525: NOT
25526: IFFALSE 25535
// hinty_co_byli := [ ] ;
25528: LD_ADDR_EXP 86
25532: PUSH
25533: EMPTY
25534: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
25535: LD_VAR 0 1
25539: PUSH
25540: LD_EXP 86
25544: IN
25545: NOT
25546: IFFALSE 25573
// begin hinty_co_byli := hinty_co_byli ^ ident ;
25548: LD_ADDR_EXP 86
25552: PUSH
25553: LD_EXP 86
25557: PUSH
25558: LD_VAR 0 1
25562: ADD
25563: ST_TO_ADDR
// Hint ( ident ) ;
25564: LD_VAR 0 1
25568: PPUSH
25569: CALL_OW 339
// end ; end ; end_of_file
25573: LD_VAR 0 2
25577: RET
// every 0 0$2 + 0 0$0.1 do
25578: GO 25580
25580: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25581: LD_INT 22
25583: PUSH
25584: LD_INT 3
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: LD_INT 2
25593: PUSH
25594: LD_INT 25
25596: PUSH
25597: LD_INT 12
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: LD_INT 25
25606: PUSH
25607: LD_INT 16
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: PUSH
25614: LD_INT 25
25616: PUSH
25617: LD_INT 15
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: PUSH
25624: LD_INT 25
25626: PUSH
25627: LD_INT 17
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: LIST
25638: LIST
25639: LIST
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: PPUSH
25645: CALL_OW 69
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_INT 3
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: LD_INT 21
25662: PUSH
25663: LD_INT 1
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 3
25672: PUSH
25673: LD_INT 2
25675: PUSH
25676: LD_INT 25
25678: PUSH
25679: LD_INT 12
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 25
25688: PUSH
25689: LD_INT 16
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 25
25698: PUSH
25699: LD_INT 15
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PUSH
25706: LD_INT 25
25708: PUSH
25709: LD_INT 17
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: LIST
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: LIST
25731: PPUSH
25732: CALL_OW 69
25736: GREATER
25737: IFFALSE 25748
// begin SetAchievement ( ACH_POTA ) ;
25739: LD_STRING ACH_POTA
25741: PPUSH
25742: CALL_OW 543
// exit ;
25746: GO 25749
// end ; enable ;
25748: ENABLE
// end ;
25749: END
// export function SA_KillStevens ; begin
25750: LD_INT 0
25752: PPUSH
// SetAchievement ( ACH_SNI ) ;
25753: LD_STRING ACH_SNI
25755: PPUSH
25756: CALL_OW 543
// end ; end_of_file
25760: LD_VAR 0 1
25764: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
25765: LD_INT 0
25767: PPUSH
25768: PPUSH
// if not missionNumber then
25769: LD_VAR 0 2
25773: NOT
25774: IFFALSE 25778
// exit ;
25776: GO 25908
// achiv := false ;
25778: LD_ADDR_VAR 0 7
25782: PUSH
25783: LD_INT 0
25785: ST_TO_ADDR
// case campaignNumber of 1 :
25786: LD_VAR 0 1
25790: PUSH
25791: LD_INT 1
25793: DOUBLE
25794: EQUAL
25795: IFTRUE 25799
25797: GO 25810
25799: POP
// achiv := ACH_GOTA ; 2 :
25800: LD_ADDR_VAR 0 7
25804: PUSH
25805: LD_STRING ACH_GOTA
25807: ST_TO_ADDR
25808: GO 25860
25810: LD_INT 2
25812: DOUBLE
25813: EQUAL
25814: IFTRUE 25818
25816: GO 25821
25818: POP
// ; 3 :
25819: GO 25860
25821: LD_INT 3
25823: DOUBLE
25824: EQUAL
25825: IFTRUE 25829
25827: GO 25840
25829: POP
// achiv := ACH_MOTSU ; 4 :
25830: LD_ADDR_VAR 0 7
25834: PUSH
25835: LD_STRING ACH_MOTSU
25837: ST_TO_ADDR
25838: GO 25860
25840: LD_INT 4
25842: DOUBLE
25843: EQUAL
25844: IFTRUE 25848
25846: GO 25859
25848: POP
// achiv := ACH_LOP ; end ;
25849: LD_ADDR_VAR 0 7
25853: PUSH
25854: LD_STRING ACH_LOP
25856: ST_TO_ADDR
25857: GO 25860
25859: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
25860: LD_OWVAR 67
25864: PUSH
25865: LD_INT 3
25867: EQUAL
25868: PUSH
25869: LD_VAR 0 7
25873: AND
25874: PUSH
25875: LD_VAR 0 3
25879: AND
25880: PUSH
25881: LD_VAR 0 4
25885: AND
25886: PUSH
25887: LD_VAR 0 5
25891: AND
25892: IFFALSE 25908
// SetAchievementEX ( achiv , missionNumber ) ;
25894: LD_VAR 0 7
25898: PPUSH
25899: LD_VAR 0 2
25903: PPUSH
25904: CALL_OW 564
// end ;
25908: LD_VAR 0 6
25912: RET
